head	1.12;
access;
symbols
	OPENBSD_5_3:1.11.0.10
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.8
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.6
	OPENBSD_5_0:1.11.0.4
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.2
	OPENBSD_4_9_BASE:1.11
	PERL_5_12_2:1.1.1.11
	OPENBSD_4_8:1.10.0.4
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.2
	OPENBSD_4_7_BASE:1.10
	PERL_5_10_1:1.1.1.10
	OPENBSD_4_6:1.9.0.6
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.2
	OPENBSD_4_5_BASE:1.9
	PERL_5_10_0:1.1.1.9
	OPENBSD_4_4:1.8.0.10
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.8
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.6
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.4
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.2
	OPENBSD_4_0_BASE:1.8
	PERL_5_8_8:1.1.1.8
	OPENBSD_3_9:1.7.0.6
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.4
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.2
	OPENBSD_3_7_BASE:1.7
	PERL_5_8_6:1.1.1.7
	OPENBSD_3_6:1.6.0.4
	OPENBSD_3_6_BASE:1.6
	PERL_5_8_5:1.1.1.6
	PERL_5_8_3:1.1.1.5
	OPENBSD_3_5:1.6.0.2
	OPENBSD_3_5_BASE:1.6
	PERL_5_8_2:1.1.1.5
	OPENBSD_3_4:1.5.0.4
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.4.0.6
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.4
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.3.0.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	PERL_500503:1.1.1.1
	CPAN:1.1.1
	OPENBSD_2_5:1.1.0.6
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.4
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.2
	OPENBSD_2_3_BASE:1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.12
date	2013.03.25.20.40.58;	author sthen;	state dead;
branches;
next	1.11;

1.11
date	2010.09.24.15.07.04;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2009.10.12.18.24.47;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2008.09.29.17.36.16;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2006.03.28.19.23.10;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2005.01.15.21.30.36;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2003.12.03.03.02.45;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.10.27.22.25.33;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.24.18.35.55;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.06.17.07.28;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	99.04.29.22.52.12;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	97.11.30.07.59.12;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.29.22.40.44;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.04.06.16.10.24;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.05.24.18.24.37;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.27.22.15.04;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.12.03.02.44.21;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.08.09.17.48.13;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2005.01.15.21.17.54;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2006.03.28.18.49.18;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2008.09.29.17.18.51;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2009.10.12.18.10.40;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2010.09.24.14.49.11;	author millert;	state Exp;
branches;
next	;


desc
@perl 5.004_04
@


1.12
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@=head1 NAME

perlfaq9 - Networking

=head1 DESCRIPTION

This section deals with questions related to networking, the internet,
and a few on the web.

=head2 What is the correct form of response from a CGI script?

(Alan Flavell <flavell+www@@a5.ph.gla.ac.uk> answers...)

The Common Gateway Interface (CGI) specifies a software interface between
a program ("CGI script") and a web server (HTTPD). It is not specific
to Perl, and has its own FAQs and tutorials, and usenet group,
comp.infosystems.www.authoring.cgi

The CGI specification is outlined in an informational RFC:
http://www.ietf.org/rfc/rfc3875

Other relevant documentation listed in: http://www.perl.org/CGI_MetaFAQ.html

These Perl FAQs very selectively cover some CGI issues. However, Perl
programmers are strongly advised to use the C<CGI.pm> module, to take care
of the details for them.

The similarity between CGI response headers (defined in the CGI
specification) and HTTP response headers (defined in the HTTP
specification, RFC2616) is intentional, but can sometimes be confusing.

The CGI specification defines two kinds of script: the "Parsed Header"
script, and the "Non Parsed Header" (NPH) script. Check your server
documentation to see what it supports. "Parsed Header" scripts are
simpler in various respects. The CGI specification allows any of the
usual newline representations in the CGI response (it's the server's
job to create an accurate HTTP response based on it). So "\n" written in
text mode is technically correct, and recommended. NPH scripts are more
tricky: they must put out a complete and accurate set of HTTP
transaction response headers; the HTTP specification calls for records
to be terminated with carriage-return and line-feed, i.e ASCII \015\012
written in binary mode.

Using C<CGI.pm> gives excellent platform independence, including EBCDIC
systems. C<CGI.pm> selects an appropriate newline representation
(C<$CGI::CRLF>) and sets binmode as appropriate.

=head2 My CGI script runs from the command line but not the browser.  (500 Server Error)

Several things could be wrong.  You can go through the "Troubleshooting
Perl CGI scripts" guide at

	http://www.perl.org/troubleshooting_CGI.html

If, after that, you can demonstrate that you've read the FAQs and that
your problem isn't something simple that can be easily answered, you'll
probably receive a courteous and useful reply to your question if you
post it on comp.infosystems.www.authoring.cgi (if it's something to do
with HTTP or the CGI protocols).  Questions that appear to be Perl
questions but are really CGI ones that are posted to comp.lang.perl.misc
are not so well received.

The useful FAQs, related documents, and troubleshooting guides are
listed in the CGI Meta FAQ:

	http://www.perl.org/CGI_MetaFAQ.html

=head2 How can I get better error messages from a CGI program?

Use the C<CGI::Carp> module.  It replaces C<warn> and C<die>, plus the
normal C<Carp> modules C<carp>, C<croak>, and C<confess> functions with
more verbose and safer versions.  It still sends them to the normal
server error log.

	use CGI::Carp;
	warn "This is a complaint";
	die "But this one is serious";

The following use of C<CGI::Carp> also redirects errors to a file of your choice,
placed in a C<BEGIN> block to catch compile-time warnings as well:

	BEGIN {
		use CGI::Carp qw(carpout);
		open(LOG, ">>/var/local/cgi-logs/mycgi-log")
			or die "Unable to append to mycgi-log: $!\n";
		carpout(*LOG);
	}

You can even arrange for fatal errors to go back to the client browser,
which is nice for your own debugging, but might confuse the end user.

	use CGI::Carp qw(fatalsToBrowser);
	die "Bad error here";

Even if the error happens before you get the HTTP header out, the module
will try to take care of this to avoid the dreaded server 500 errors.
Normal warnings still go out to the server error log (or wherever
you've sent them with C<carpout>) with the application name and date
stamp prepended.

=head2 How do I remove HTML from a string?

The most correct way (albeit not the fastest) is to use C<HTML::Parser>
from CPAN.  Another mostly correct
way is to use C<HTML::FormatText> which not only removes HTML but also
attempts to do a little simple formatting of the resulting plain text.

Many folks attempt a simple-minded regular expression approach, like
C<< s/<.*?>//g >>, but that fails in many cases because the tags
may continue over line breaks, they may contain quoted angle-brackets,
or HTML comment may be present.  Plus, folks forget to convert
entities--like C<&lt;> for example.

Here's one "simple-minded" approach, that works for most files:

	#!/usr/bin/perl -p0777
	s/<(?:[^>'"]*|(['"]).*?\1)*>//gs

If you want a more complete solution, see the 3-stage striphtml
program in
http://www.cpan.org/authors/Tom_Christiansen/scripts/striphtml.gz
.

Here are some tricky cases that you should think about when picking
a solution:

	<IMG SRC = "foo.gif" ALT = "A > B">

	<IMG SRC = "foo.gif"
	 ALT = "A > B">

	<!-- <A comment> -->

	<script>if (a<b && a>c)</script>

	<# Just data #>

	<![INCLUDE CDATA [ >>>>>>>>>>>> ]]>

If HTML comments include other tags, those solutions would also break
on text like this:

	<!-- This section commented out.
		<B>You can't see me!</B>
	-->

=head2 How do I extract URLs?

You can easily extract all sorts of URLs from HTML with
C<HTML::SimpleLinkExtor> which handles anchors, images, objects,
frames, and many other tags that can contain a URL.  If you need
anything more complex, you can create your own subclass of
C<HTML::LinkExtor> or C<HTML::Parser>.  You might even use
C<HTML::SimpleLinkExtor> as an example for something specifically
suited to your needs.

You can use C<URI::Find> to extract URLs from an arbitrary text document.

Less complete solutions involving regular expressions can save
you a lot of processing time if you know that the input is simple.  One
solution from Tom Christiansen runs 100 times faster than most
module based approaches but only extracts URLs from anchors where the first
attribute is HREF and there are no other attributes.

	#!/usr/bin/perl -n00
	# qxurl - tchrist@@perl.com
	print "$2\n" while m{
		< \s*
		  A \s+ HREF \s* = \s* (["']) (.*?) \1
		\s* >
	}gsix;

=head2 How do I download a file from the user's machine?  How do I open a file on another machine?

In this case, download means to use the file upload feature of HTML
forms.  You allow the web surfer to specify a file to send to your web
server.  To you it looks like a download, and to the user it looks
like an upload.  No matter what you call it, you do it with what's
known as B<multipart/form-data> encoding.  The C<CGI.pm> module (which
comes with Perl as part of the Standard Library) supports this in the
C<start_multipart_form()> method, which isn't the same as the C<startform()>
method.

See the section in the C<CGI.pm> documentation on file uploads for code
examples and details.

=head2 How do I make an HTML pop-up menu with Perl?

(contributed by brian d foy)

The C<CGI.pm> module (which comes with Perl) has functions to create
the HTML form widgets. See the C<CGI.pm> documentation for more
examples.

	use CGI qw/:standard/;
	print header,
		start_html('Favorite Animals'),

		start_form,
			"What's your favorite animal? ",
		popup_menu(
			-name   => 'animal',
			-values => [ qw( Llama Alpaca Camel Ram ) ]
			),
		submit,

		end_form,
		end_html;

=head2 How do I fetch an HTML file?

(contributed by brian d foy)

Use the libwww-perl distribution. The C<LWP::Simple> module can fetch web
resources and give their content back to you as a string:

	use LWP::Simple qw(get);

	my $html = get( "http://www.example.com/index.html" );

It can also store the resource directly in a file:

	use LWP::Simple qw(getstore);

	getstore( "http://www.example.com/index.html", "foo.html" );

If you need to do something more complicated, you can use
C<LWP::UserAgent> module to create your own user-agent (e.g. browser)
to get the job done. If you want to simulate an interactive web
browser, you can use the C<WWW::Mechanize> module.

=head2 How do I automate an HTML form submission?

If you are doing something complex, such as moving through many pages
and forms or a web site, you can use C<WWW::Mechanize>.  See its
documentation for all the details.

If you're submitting values using the GET method, create a URL and encode
the form using the C<query_form> method:

	use LWP::Simple;
	use URI::URL;

	my $url = url('http://www.perl.com/cgi-bin/cpan_mod');
	$url->query_form(module => 'DB_File', readme => 1);
	$content = get($url);

If you're using the POST method, create your own user agent and encode
the content appropriately.

	use HTTP::Request::Common qw(POST);
	use LWP::UserAgent;

	$ua = LWP::UserAgent->new();
	my $req = POST 'http://www.perl.com/cgi-bin/cpan_mod',
				   [ module => 'DB_File', readme => 1 ];
	$content = $ua->request($req)->as_string;

=head2 How do I decode or create those %-encodings on the web?
X<URI> X<CGI.pm> X<CGI> X<URI::Escape> X<RFC 2396>

(contributed by brian d foy)

Those C<%> encodings handle reserved characters in URIs, as described
in RFC 2396, Section 2. This encoding replaces the reserved character
with the hexadecimal representation of the character's number from
the US-ASCII table. For instance, a colon, C<:>, becomes C<%3A>.

In CGI scripts, you don't have to worry about decoding URIs if you are
using C<CGI.pm>. You shouldn't have to process the URI yourself,
either on the way in or the way out.

If you have to encode a string yourself, remember that you should
never try to encode an already-composed URI. You need to escape the
components separately then put them together. To encode a string, you
can use the the C<URI::Escape> module. The C<uri_escape> function
returns the escaped string:

	my $original = "Colon : Hash # Percent %";

	my $escaped = uri_escape( $original );

	print "$escaped\n"; # 'Colon%20%3A%20Hash%20%23%20Percent%20%25'

To decode the string, use the C<uri_unescape> function:

	my $unescaped = uri_unescape( $escaped );

	print $unescaped; # back to original

If you wanted to do it yourself, you simply need to replace the
reserved characters with their encodings. A global substitution
is one way to do it:

	# encode
	$string =~ s/([^^A-Za-z0-9\-_.!~*'()])/ sprintf "%%%0x", ord $1 /eg;

	#decode
	$string =~ s/%([A-Fa-f\d]{2})/chr hex $1/eg;

=head2 How do I redirect to another page?

Specify the complete URL of the destination (even if it is on the same
server). This is one of the two different kinds of CGI "Location:"
responses which are defined in the CGI specification for a Parsed Headers
script. The other kind (an absolute URLpath) is resolved internally to
the server without any HTTP redirection. The CGI specifications do not
allow relative URLs in either case.

Use of C<CGI.pm> is strongly recommended.  This example shows redirection
with a complete URL. This redirection is handled by the web browser.

	use CGI qw/:standard/;

	my $url = 'http://www.cpan.org/';
	print redirect($url);

This example shows a redirection with an absolute URLpath.  This
redirection is handled by the local web server.

	my $url = '/CPAN/index.html';
	print redirect($url);

But if coded directly, it could be as follows (the final "\n" is
shown separately, for clarity), using either a complete URL or
an absolute URLpath.

	print "Location: $url\n";   # CGI response header
	print "\n";                 # end of headers

=head2 How do I put a password on my web pages?

To enable authentication for your web server, you need to configure
your web server.  The configuration is different for different sorts
of web servers--apache does it differently from iPlanet which does
it differently from IIS.  Check your web server documentation for
the details for your particular server.

=head2 How do I edit my .htpasswd and .htgroup files with Perl?

The C<HTTPD::UserAdmin> and C<HTTPD::GroupAdmin> modules provide a
consistent OO interface to these files, regardless of how they're
stored.  Databases may be text, dbm, Berkeley DB or any database with
a DBI compatible driver.  C<HTTPD::UserAdmin> supports files used by the
"Basic" and "Digest" authentication schemes.  Here's an example:

	use HTTPD::UserAdmin ();
	HTTPD::UserAdmin
	  ->new(DB => "/foo/.htpasswd")
	  ->add($username => $password);

=head2 How do I make sure users can't enter values into a form that cause my CGI script to do bad things?

See the security references listed in the CGI Meta FAQ

	http://www.perl.org/CGI_MetaFAQ.html

=head2 How do I parse a mail header?

For a quick-and-dirty solution, try this solution derived
from L<perlfunc/split>:

	$/ = '';
	$header = <MSG>;
	$header =~ s/\n\s+/ /g;	 # merge continuation lines
	%head = ( UNIX_FROM_LINE, split /^([-\w]+):\s*/m, $header );

That solution doesn't do well if, for example, you're trying to
maintain all the Received lines.  A more complete approach is to use
the C<Mail::Header> module from CPAN (part of the C<MailTools> package).

=head2 How do I decode a CGI form?

(contributed by brian d foy)

Use the C<CGI.pm> module that comes with Perl.  It's quick,
it's easy, and it actually does quite a bit of work to
ensure things happen correctly.  It handles GET, POST, and
HEAD requests, multipart forms, multivalued fields, query
string and message body combinations, and many other things
you probably don't want to think about.

It doesn't get much easier: the C<CGI.pm> module automatically
parses the input and makes each value available through the
C<param()> function.

	use CGI qw(:standard);

	my $total = param( 'price' ) + param( 'shipping' );

	my @@items = param( 'item' ); # multiple values, same field name

If you want an object-oriented approach, C<CGI.pm> can do that too.

	use CGI;

	my $cgi = CGI->new();

	my $total = $cgi->param( 'price' ) + $cgi->param( 'shipping' );

	my @@items = $cgi->param( 'item' );

You might also try C<CGI::Minimal> which is a lightweight version
of the same thing.  Other CGI::* modules on CPAN might work better
for you, too.

Many people try to write their own decoder (or copy one from
another program) and then run into one of the many "gotchas"
of the task.  It's much easier and less hassle to use C<CGI.pm>.

=head2 How do I check a valid mail address?

(partly contributed by Aaron Sherman)

This isn't as simple a question as it sounds.  There are two parts:

a) How do I verify that an email address is correctly formatted?

b) How do I verify that an email address targets a valid recipient?

Without sending mail to the address and seeing whether there's a human
on the other end to answer you, you cannot fully answer part I<b>, but
either the C<Email::Valid> or the C<RFC::RFC822::Address> module will do
both part I<a> and part I<b> as far as you can in real-time.

If you want to just check part I<a> to see that the address is valid
according to the mail header standard with a simple regular expression,
you can have problems, because there are deliverable addresses that
aren't RFC-2822 (the latest mail header standard) compliant, and
addresses that aren't deliverable which, are compliant.  However,  the
following will match valid RFC-2822 addresses that do not have comments,
folding whitespace, or any other obsolete or non-essential elements.
This I<just> matches the address itself:

	my $atom       = qr{[a-zA-Z0-9_!#\$\%&'*+/=?\^`{}~|\-]+};
	my $dot_atom   = qr{$atom(?:\.$atom)*};
	my $quoted     = qr{"(?:\\[^\r\n]|[^\\"])*"};
	my $local      = qr{(?:$dot_atom|$quoted)};
	my $quotedpair = qr{\\[\x00-\x09\x0B-\x0c\x0e-\x7e]};
	my $domain_lit = qr{\[(?:$quotedpair|[\x21-\x5a\x5e-\x7e])*\]};
 	my $domain     = qr{(?:$dot_atom|$domain_lit)};
	my $addr_spec  = qr{$local\@@$domain};

Just match an address against C</^${addr_spec}$/> to see if it follows
the RFC2822 specification.  However, because it is impossible to be
sure that such a correctly formed address is actually the correct way
to reach a particular person or even has a mailbox associated with it,
you must be very careful about how you use this.

Our best advice for verifying a person's mail address is to have them
enter their address twice, just as you normally do to change a
password. This usually weeds out typos. If both versions match, send
mail to that address with a personal message. If you get the message
back and they've followed your directions, you can be reasonably
assured that it's real.

A related strategy that's less open to forgery is to give them a PIN
(personal ID number).  Record the address and PIN (best that it be a
random one) for later processing. In the mail you send, ask them to
include the PIN in their reply.  But if it bounces, or the message is
included via a "vacation" script, it'll be there anyway.  So it's
best to ask them to mail back a slight alteration of the PIN, such as
with the characters reversed, one added or subtracted to each digit, etc.

=head2 How do I decode a MIME/BASE64 string?

The C<MIME-Base64> package (available from CPAN) handles this as well as
the MIME/QP encoding.  Decoding BASE64 becomes as simple as:

	use MIME::Base64;
	$decoded = decode_base64($encoded);

The C<MIME-Tools> package (available from CPAN) supports extraction with
decoding of BASE64 encoded attachments and content directly from email
messages.

If the string to decode is short (less than 84 bytes long)
a more direct approach is to use the C<unpack()> function's "u"
format after minor transliterations:

	tr#A-Za-z0-9+/##cd;                   # remove non-base64 chars
	tr#A-Za-z0-9+/# -_#;                  # convert to uuencoded format
	$len = pack("c", 32 + 0.75*length);   # compute length byte
	print unpack("u", $len . $_);         # uudecode and print

=head2 How do I return the user's mail address?

On systems that support getpwuid, the C<< $< >> variable, and the
C<Sys::Hostname> module (which is part of the standard perl distribution),
you can probably try using something like this:

	use Sys::Hostname;
	$address = sprintf('%s@@%s', scalar getpwuid($<), hostname);

Company policies on mail address can mean that this generates addresses
that the company's mail system will not accept, so you should ask for
users' mail addresses when this matters.  Furthermore, not all systems
on which Perl runs are so forthcoming with this information as is Unix.

The C<Mail::Util> module from CPAN (part of the C<MailTools> package) provides a
C<mailaddress()> function that tries to guess the mail address of the user.
It makes a more intelligent guess than the code above, using information
given when the module was installed, but it could still be incorrect.
Again, the best way is often just to ask the user.

=head2 How do I send mail?

Use the C<sendmail> program directly:

	open(SENDMAIL, "|/usr/lib/sendmail -oi -t -odq")
		or die "Can't fork for sendmail: $!\n";
	print SENDMAIL <<"EOF";
	From: User Originating Mail <me\@@host>
	To: Final Destination <you\@@otherhost>
	Subject: A relevant subject line

	Body of the message goes here after the blank line
	in as many lines as you like.
	EOF
	close(SENDMAIL)     or warn "sendmail didn't close nicely";

The B<-oi> option prevents C<sendmail> from interpreting a line consisting
of a single dot as "end of message".  The B<-t> option says to use the
headers to decide who to send the message to, and B<-odq> says to put
the message into the queue.  This last option means your message won't
be immediately delivered, so leave it out if you want immediate
delivery.

Alternate, less convenient approaches include calling C<mail> (sometimes
called C<mailx>) directly or simply opening up port 25 have having an
intimate conversation between just you and the remote SMTP daemon,
probably C<sendmail>.

Or you might be able use the CPAN module C<Mail::Mailer>:

	use Mail::Mailer;

	$mailer = Mail::Mailer->new();
	$mailer->open({ From    => $from_address,
					To      => $to_address,
					Subject => $subject,
				  })
		or die "Can't open: $!\n";
	print $mailer $body;
	$mailer->close();

The C<Mail::Internet> module uses C<Net::SMTP> which is less Unix-centric than
C<Mail::Mailer>, but less reliable.  Avoid raw SMTP commands.  There
are many reasons to use a mail transport agent like C<sendmail>.  These
include queuing, MX records, and security.

=head2 How do I use MIME to make an attachment to a mail message?

This answer is extracted directly from the C<MIME::Lite> documentation.
Create a multipart message (i.e., one with attachments).

	use MIME::Lite;

	### Create a new multipart message:
	$msg = MIME::Lite->new(
				 From    =>'me@@myhost.com',
				 To      =>'you@@yourhost.com',
				 Cc      =>'some@@other.com, some@@more.com',
				 Subject =>'A message with 2 parts...',
				 Type    =>'multipart/mixed'
				 );

	### Add parts (each "attach" has same arguments as "new"):
	$msg->attach(Type     =>'TEXT',
				 Data     =>"Here's the GIF file you wanted"
				 );
	$msg->attach(Type     =>'image/gif',
				 Path     =>'aaa000123.gif',
				 Filename =>'logo.gif'
				 );

	$text = $msg->as_string;

C<MIME::Lite> also includes a method for sending these things.

	$msg->send;

This defaults to using L<sendmail> but can be customized to use
SMTP via L<Net::SMTP>.

=head2 How do I read mail?

While you could use the C<Mail::Folder> module from CPAN (part of the
C<MailFolder> package) or the C<Mail::Internet> module from CPAN (part
of the C<MailTools> package), often a module is overkill.  Here's a
mail sorter.

	#!/usr/bin/perl

	my(@@msgs, @@sub);
	my $msgno = -1;
	$/ = '';                    # paragraph reads
	while (<>) {
		if (/^From /m) {
			/^Subject:\s*(?:Re:\s*)*(.*)/mi;
			$sub[++$msgno] = lc($1) || '';
		}
		$msgs[$msgno] .= $_;
	}
	for my $i (sort { $sub[$a] cmp $sub[$b] || $a <=> $b } (0 .. $#msgs)) {
		print $msgs[$i];
	}

Or more succinctly,

	#!/usr/bin/perl -n00
	# bysub2 - awkish sort-by-subject
	BEGIN { $msgno = -1 }
	$sub[++$msgno] = (/^Subject:\s*(?:Re:\s*)*(.*)/mi)[0] if /^From/m;
	$msg[$msgno] .= $_;
	END { print @@msg[ sort { $sub[$a] cmp $sub[$b] || $a <=> $b } (0 .. $#msg) ] }

=head2 How do I find out my hostname, domainname, or IP address?
X<hostname, domainname, IP address, host, domain, hostfqdn, inet_ntoa,
gethostbyname, Socket, Net::Domain, Sys::Hostname>

(contributed by brian d foy)

The C<Net::Domain> module, which is part of the standard distribution starting
in perl5.7.3, can get you the fully qualified domain name (FQDN), the host
name, or the domain name.

	use Net::Domain qw(hostname hostfqdn hostdomain);

	my $host = hostfqdn();

The C<Sys::Hostname> module, included in the standard distribution since
perl5.6, can also get the hostname.

	use Sys::Hostname;

	$host = hostname();

To get the IP address, you can use the C<gethostbyname> built-in function
to turn the name into a number. To turn that number into the dotted octet
form (a.b.c.d) that most people expect, use the C<inet_ntoa> function
from the C<Socket> module, which also comes with perl.

	use Socket;

	my $address = inet_ntoa(
		scalar gethostbyname( $host || 'localhost' )
		);

=head2 How do I fetch a news article or the active newsgroups?

Use the C<Net::NNTP> or C<News::NNTPClient> modules, both available from CPAN.
This can make tasks like fetching the newsgroup list as simple as

	perl -MNews::NNTPClient
	  -e 'print News::NNTPClient->new->list("newsgroups")'

=head2 How do I fetch/put an FTP file?

C<LWP::Simple> (available from CPAN) can fetch but not put.  C<Net::FTP> (also
available from CPAN) is more complex but can put as well as fetch.

=head2 How can I do RPC in Perl?

(Contributed by brian d foy)

Use one of the RPC modules you can find on CPAN (
http://search.cpan.org/search?query=RPC&mode=all ).

=head1 AUTHOR AND COPYRIGHT

Copyright (c) 1997-2010 Tom Christiansen, Nathan Torkington, and
other authors as noted. All rights reserved.

This documentation is free; you can redistribute it and/or modify it
under the same terms as Perl itself.

Irrespective of its distribution, all code examples in this file
are hereby placed into the public domain.  You are permitted and
encouraged to use this code in your own programs for fun
or for profit as you see fit.  A simple comment in the code giving
credit would be courteous but is not required.
@


1.11
log
@merge in perl 5.12.2 plus local changes
@
text
@@


1.10
log
@Merge in perl 5.10.1
@
text
@d25 1
a25 1
programmers are strongly advised to use the CGI.pm module, to take care
d44 3
a46 3
Using CGI.pm gives excellent platform independence, including EBCDIC
systems. CGI.pm selects an appropriate newline representation
($CGI::CRLF) and sets binmode as appropriate.
d70 2
a71 2
Use the CGI::Carp module.  It replaces C<warn> and C<die>, plus the
normal Carp modules C<carp>, C<croak>, and C<confess> functions with
d79 2
a80 2
The following use of CGI::Carp also redirects errors to a file of your choice,
placed in a BEGIN block to catch compile-time warnings as well:
d103 1
a103 1
The most correct way (albeit not the fastest) is to use HTML::Parser
d105 1
a105 1
way is to use HTML::FormatText which not only removes HTML but also
d157 1
a157 1
You can use URI::Find to extract URLs from an arbitrary text document.
d179 1
a179 1
known as B<multipart/form-data> encoding.  The CGI.pm module (which
d181 1
a181 1
start_multipart_form() method, which isn't the same as the startform()
d184 1
a184 1
See the section in the CGI.pm documentation on file uploads for code
d191 2
a192 2
The CGI.pm module (which comes with Perl) has functions to create
the HTML form widgets. See the CGI.pm documentation for more
d281 1
a281 1
	my $escaped = uri_escape( $original )
d283 1
a283 1
	print "$string\n"; # 'Colon%20%3A%20Hash%20%23%20Percent%20%25%20'
d310 1
a310 1
Use of CGI.pm is strongly recommended.  This example shows redirection
d341 1
a341 1
The HTTPD::UserAdmin and HTTPD::GroupAdmin modules provide a
d344 1
a344 1
a DBI compatible driver.  HTTPD::UserAdmin supports files used by the
d370 1
a370 1
the Mail::Header module from CPAN (part of the MailTools package).
d376 1
a376 1
Use the CGI.pm module that comes with Perl.  It's quick,
d383 1
a383 1
It doesn't get much easier: the CGI module automatically
d393 1
a393 1
If you want an object-oriented approach, CGI.pm can do that too.
d403 1
a403 1
You might also try CGI::Minimal which is a lightweight version
d409 1
a409 1
of the task.  It's much easier and less hassle to use CGI.pm.
d467 1
a467 1
The MIME-Base64 package (available from CPAN) handles this as well as
d473 1
a473 1
The MIME-Tools package (available from CPAN) supports extraction with
d478 1
a478 1
a more direct approach is to use the unpack() function's "u"
d488 2
a489 2
On systems that support getpwuid, the $< variable, and the
Sys::Hostname module (which is part of the standard perl distribution),
d500 2
a501 2
The Mail::Util module from CPAN (part of the MailTools package) provides a
mailaddress() function that tries to guess the mail address of the user.
d522 1
a522 1
The B<-oi> option prevents sendmail from interpreting a line consisting
d529 2
a530 2
Alternate, less convenient approaches include calling mail (sometimes
called mailx) directly or simply opening up port 25 have having an
d532 1
a532 1
probably sendmail.
d534 1
a534 1
Or you might be able use the CPAN module Mail::Mailer:
d547 3
a549 3
The Mail::Internet module uses Net::SMTP which is less Unix-centric than
Mail::Mailer, but less reliable.  Avoid raw SMTP commands.  There
are many reasons to use a mail transport agent like sendmail.  These
d554 1
a554 1
This answer is extracted directly from the MIME::Lite documentation.
d579 1
a579 1
MIME::Lite also includes a method for sending these things.
d588 3
a590 3
While you could use the Mail::Folder module from CPAN (part of the
MailFolder package) or the Mail::Internet module from CPAN (part
of the MailTools package), often a module is overkill.  Here's a
d624 1
a624 1
The Net::Domain module, which is part of the standard distribution starting
d642 1
a642 1
from the <Socket> module, which also comes with perl.
d652 1
a652 1
Use the Net::NNTP or News::NNTPClient modules, both available from CPAN.
d660 1
a660 1
LWP::Simple (available from CPAN) can fetch but not put.  Net::FTP (also
a669 8
=head1 REVISION

Revision: $Revision$

Date: $Date$

See L<perlfaq> for source control details and availability.

d672 1
a672 1
Copyright (c) 1997-2009 Tom Christiansen, Nathan Torkington, and
@


1.9
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@a67 1

d75 3
a77 3
    use CGI::Carp;
    warn "This is a complaint";
    die "But this one is serious";
d82 6
a87 6
    BEGIN {
        use CGI::Carp qw(carpout);
        open(LOG, ">>/var/local/cgi-logs/mycgi-log")
            or die "Unable to append to mycgi-log: $!\n";
        carpout(*LOG);
    }
d92 2
a93 2
    use CGI::Carp qw(fatalsToBrowser);
    die "Bad error here";
d116 2
a117 2
    #!/usr/bin/perl -p0777
    s/<(?:[^>'"]*|(['"]).*?\1)*>//gs
d127 1
a127 1
    <IMG SRC = "foo.gif" ALT = "A > B">
d129 1
a129 1
    <IMG SRC = "foo.gif"
d132 1
a132 1
    <!-- <A comment> -->
d134 1
a134 1
    <script>if (a<b && a>c)</script>
d136 1
a136 1
    <# Just data #>
d138 1
a138 1
    <![INCLUDE CDATA [ >>>>>>>>>>>> ]]>
d143 3
a145 3
    <!-- This section commented out.
        <B>You can't see me!</B>
    -->
d165 7
a171 8
        #!/usr/bin/perl -n00
        # qxurl - tchrist@@perl.com
        print "$2\n" while m{
            < \s*
              A \s+ HREF \s* = \s* (["']) (.*?) \1
            \s* >
        }gsix;

d201 2
a202 2
        popup_menu(
        	-name   => 'animal',
d205 8
a212 1
        submit,
d214 2
a215 2
 		end_form,
        end_html;
d217 1
d219 3
a221 1
=head2 How do I fetch an HTML file?
d223 1
a223 2
One approach, if you have the lynx text-based HTML browser installed
on your system, is this:
d225 1
a225 2
    $html_code = `lynx -source $url`;
    $text_data = `lynx -dump $url`;
d227 4
a230 23
The libwww-perl (LWP) modules from CPAN provide a more powerful way
to do this.  They don't require lynx, but like lynx, can still work
through proxies:

    # simplest version
    use LWP::Simple;
    $content = get($URL);

    # or print HTML from a URL
    use LWP::Simple;
    getprint "http://www.linpro.no/lwp/";

    # or print ASCII from HTML from a URL
    # also need HTML-Tree package from CPAN
    use LWP::Simple;
    use HTML::Parser;
    use HTML::FormatText;
    my ($html, $ascii);
    $html = get("http://www.perl.com/");
    defined $html
        or die "Can't fetch HTML from http://www.perl.com/";
    $ascii = HTML::FormatText->new->format(parse_html($html));
    print $ascii;
d241 2
a242 2
    use LWP::Simple;
    use URI::URL;
d244 3
a246 3
    my $url = url('http://www.perl.com/cgi-bin/cpan_mod');
    $url->query_form(module => 'DB_File', readme => 1);
    $content = get($url);
d251 2
a252 2
    use HTTP::Request::Common qw(POST);
    use LWP::UserAgent;
d254 4
a257 4
    $ua = LWP::UserAgent->new();
    my $req = POST 'http://www.perl.com/cgi-bin/cpan_mod',
                   [ module => 'DB_File', readme => 1 ];
    $content = $ua->request($req)->as_string;
d260 12
d273 5
a277 17
If you are writing a CGI script, you should be using the CGI.pm module
that comes with perl, or some other equivalent module.  The CGI module
automatically decodes queries for you, and provides an escape()
function to handle encoding.

The best source of detailed information on URI encoding is RFC 2396.
Basically, the following substitutions do it:

    s/([^\w()'*~!.-])/sprintf '%%%02x', ord $1/eg;   # encode

    s/%([A-Fa-f\d]{2})/chr hex $1/eg;                # decode
	s/%([[:xdigit:]]{2})/chr hex $1/eg;          # same thing

However, you should only apply them to individual URI components, not
the entire URI, otherwise you'll lose information and generally mess
things up.  If that didn't explain it, don't worry.  Just go read
section 2 of the RFC, it's probably the best explanation there is.
d279 21
a299 2
RFC 2396 also contains a lot of other useful information, including a
regexp for breaking any arbitrary URI into components (Appendix B).
d313 1
a313 4
      use CGI qw/:standard/;

      my $url = 'http://www.cpan.org/';
      print redirect($url);
d315 2
d321 2
a322 3
      my $url = '/CPAN/index.html';
      print redirect($url);

d328 2
a329 3
      print "Location: $url\n";   # CGI response header
      print "\n";                 # end of headers

d347 2
a348 2
    use HTTPD::UserAdmin ();
    HTTPD::UserAdmin
d363 4
a366 4
    $/ = '';
    $header = <MSG>;
    $header =~ s/\n\s+/ /g;	 # merge continuation lines
    %head = ( UNIX_FROM_LINE, split /^([-\w]+):\s*/m, $header );
d435 8
a442 7
    my $atom       = qr{[a-zA-Z0-9_!#\$\%&'*+/=?\^`{}~|\-]+};
    my $dot_atom   = qr{$atom(?:\.$atom)*};
    my $quoted     = qr{"(?:\\[^\r\n]|[^\\"])*"};
    my $local      = qr{(?:$dot_atom|$quoted)};
    my $domain_lit = qr{\[(?:\\\S|[\x21-\x5a\x5e-\x7e])*\]};
    my $domain     = qr{(?:$dot_atom|$domain_lit)};
    my $addr_spec  = qr{$local\@@$domain};
d470 2
a471 2
    use MIME::Base64;
    $decoded = decode_base64($encoded);
d481 4
a484 4
    tr#A-Za-z0-9+/##cd;                   # remove non-base64 chars
    tr#A-Za-z0-9+/# -_#;                  # convert to uuencoded format
    $len = pack("c", 32 + 0.75*length);   # compute length byte
    print unpack("u", $len . $_);         # uudecode and print
d492 2
a493 2
    use Sys::Hostname;
    $address = sprintf('%s@@%s', scalar getpwuid($<), hostname);
d510 11
a520 11
    open(SENDMAIL, "|/usr/lib/sendmail -oi -t -odq")
                        or die "Can't fork for sendmail: $!\n";
    print SENDMAIL <<"EOF";
    From: User Originating Mail <me\@@host>
    To: Final Destination <you\@@otherhost>
    Subject: A relevant subject line

    Body of the message goes here after the blank line
    in as many lines as you like.
    EOF
    close(SENDMAIL)     or warn "sendmail didn't close nicely";
d536 1
a536 1
    use Mail::Mailer;
d538 8
a545 8
    $mailer = Mail::Mailer->new();
    $mailer->open({ From    => $from_address,
                    To      => $to_address,
                    Subject => $subject,
                  })
        or die "Can't open: $!\n";
    print $mailer $body;
    $mailer->close();
d557 1
a557 1
    use MIME::Lite;
d559 17
a575 17
    ### Create a new multipart message:
    $msg = MIME::Lite->new(
                 From    =>'me@@myhost.com',
                 To      =>'you@@yourhost.com',
                 Cc      =>'some@@other.com, some@@more.com',
                 Subject =>'A message with 2 parts...',
                 Type    =>'multipart/mixed'
                 );

    ### Add parts (each "attach" has same arguments as "new"):
    $msg->attach(Type     =>'TEXT',
                 Data     =>"Here's the GIF file you wanted"
                 );
    $msg->attach(Type     =>'image/gif',
                 Path     =>'aaa000123.gif',
                 Filename =>'logo.gif'
                 );
d577 1
a577 1
    $text = $msg->as_string;
d581 1
a581 1
    $msg->send;
d593 1
a593 1
    #!/usr/bin/perl
d595 13
a607 13
    my(@@msgs, @@sub);
    my $msgno = -1;
    $/ = '';                    # paragraph reads
    while (<>) {
        if (/^From /m) {
            /^Subject:\s*(?:Re:\s*)*(.*)/mi;
            $sub[++$msgno] = lc($1) || '';
        }
        $msgs[$msgno] .= $_;
    }
    for my $i (sort { $sub[$a] cmp $sub[$b] || $a <=> $b } (0 .. $#msgs)) {
        print $msgs[$i];
    }
d611 6
a616 6
    #!/usr/bin/perl -n00
    # bysub2 - awkish sort-by-subject
    BEGIN { $msgno = -1 }
    $sub[++$msgno] = (/^Subject:\s*(?:Re:\s*)*(.*)/mi)[0] if /^From/m;
    $msg[$msgno] .= $_;
    END { print @@msg[ sort { $sub[$a] cmp $sub[$b] || $a <=> $b } (0 .. $#msg) ] }
d644 1
a644 1
    use Socket;
d646 3
a648 3
    my $address = inet_ntoa(
    	scalar gethostbyname( $host || 'localhost' )
    	);
d655 2
a656 2
    perl -MNews::NNTPClient
      -e 'print News::NNTPClient->new->list("newsgroups")'
d672 1
a672 1
Revision: $Revision: 8539 $
d674 1
a674 1
Date: $Date: 2007-01-11 00:07:14 +0100 (Thu, 11 Jan 2007) $
d680 1
a680 1
Copyright (c) 1997-2007 Tom Christiansen, Nathan Torkington, and
@


1.8
log
@merge in perl 5.8.8
@
text
@d189 22
a210 1
=head2 How do I make a pop-up menu in HTML?
a211 3
Use the B<< <SELECT> >> and B<< <OPTION> >> tags.  The CGI.pm
module (available from CPAN) supports this widget, as well as many
others, including some that it cleverly synthesizes on its own.
d332 1
a332 1
of web servers---apache does it differently from iPlanet which does
d410 7
a416 1
You can't, at least, not in real time.  Bummer, eh?
d419 26
a444 25
on the other end to answer you, you cannot determine whether a mail
address is valid.  Even if you apply the mail header standard, you
can have problems, because there are deliverable addresses that aren't
RFC-822 (the mail header standard) compliant, and addresses that aren't
deliverable which are compliant.

You can use the Email::Valid or RFC::RFC822::Address which check
the format of the address, although they cannot actually tell you
if it is a deliverable address (i.e. that mail to the address
will not bounce).  Modules like Mail::CheckUser and Mail::EXPN
try to interact with the domain name system or particular
mail servers to learn even more, but their methods do not
work everywhere---especially for security conscious administrators.

Many are tempted to try to eliminate many frequently-invalid
mail addresses with a simple regex, such as
C</^[\w.-]+\@@(?:[\w-]+\.)+\w+$/>.  It's a very bad idea.  However,
this also throws out many valid ones, and says nothing about
potential deliverability, so it is not suggested.  Instead, see
http://www.cpan.org/authors/Tom_Christiansen/scripts/ckaddr.gz ,
which actually checks against the full RFC spec (except for nested
comments), looks for addresses you may not wish to accept mail to
(say, Bill Clinton or your postmaster), and then makes sure that the
hostname given can be looked up in the DNS MX records.  It's not fast,
but it works for what it tries to do.
d447 5
a451 14
enter their address twice, just as you normally do to change a password.
This usually weeds out typos.  If both versions match, send
mail to that address with a personal message that looks somewhat like:

    Dear someuser@@host.com,

    Please confirm the mail address you gave us Wed May  6 09:38:41
    MDT 1998 by replying to this message.  Include the string
    "Rumpelstiltskin" in that reply, but spelled in reverse; that is,
    start with "Nik...".  Once this is done, your confirmed address will
    be entered into our records.

If you get the message back and they've followed your directions,
you can be reasonably assured that it's real.
d455 1
a455 1
random one) for later processing.  In the mail you send, ask them to
d666 8
d676 1
a676 1
Copyright (c) 1997-2006 Tom Christiansen, Nathan Torkington, and
@


1.7
log
@sync in-tree perl with 5.8.6
@
text
@d3 1
a3 1
perlfaq9 - Networking ($Revision: 1.6 $, $Date: 2003/12/03 03:02:45 $)
d19 2
a20 3
The original CGI specification is at: http://hoohoo.ncsa.uiuc.edu/cgi/

Current best-practice RFC draft at: http://CGI-Spec.Golux.Com/
d229 4
a255 1

a260 1

d266 2
a267 1
    s/%([A-Fa-f\d]{2})/chr hex $1/eg;            # decode
d324 1
a324 1
`Basic' and `Digest' authentication schemes.  Here's an example:
d353 26
a378 2
You use a standard module, probably CGI.pm.  Under no circumstances
should you attempt to do so by hand!
d380 9
a388 26
You'll see a lot of CGI programs that blindly read from STDIN the number
of bytes equal to CONTENT_LENGTH for POSTs, or grab QUERY_STRING for
decoding GETs.  These programs are very poorly written.  They only work
sometimes.  They typically forget to check the return value of the read()
system call, which is a cardinal sin.  They don't handle HEAD requests.
They don't handle multipart forms used for file uploads.  They don't deal
with GET/POST combinations where query fields are in more than one place.
They don't deal with keywords in the query string.

In short, they're bad hacks.  Resist them at all costs.  Please do not be
tempted to reinvent the wheel.  Instead, use the CGI.pm or CGI_Lite.pm
(available from CPAN), or if you're trapped in the module-free land
of perl1 .. perl4, you might look into cgi-lib.pl (available from
http://cgi-lib.stanford.edu/cgi-lib/ ).

Make sure you know whether to use a GET or a POST in your form.
GETs should only be used for something that doesn't update the server.
Otherwise you can get mangled databases and repeated feedback mail
messages.  The fancy word for this is ``idempotency''.  This simply
means that there should be no difference between making a GET request
for a particular URL once or multiple times.  This is because the
HTTP protocol definition says that a GET request may be cached by the
browser, or server, or an intervening proxy.  POST requests cannot be
cached, because each request is independent and matters.  Typically,
POST requests change or depend on state on the server (query or update
a database, send mail, or purchase a computer).
d441 1
a441 1
included via a ``vacation'' script, it'll be there anyway.  So it's
d598 13
a610 1
=head2 How do I find out my hostname/domainname/IP address?
d612 11
a622 8
The normal way to find your own hostname is to call the C<`hostname`>
program.  While sometimes expedient, this has some problems, such as
not knowing whether you've got the canonical name or not.  It's one of
those tradeoffs of convenience versus portability.

The Sys::Hostname module (part of the standard perl distribution) will
give you the hostname after which you can find out the IP address
(assuming you have working DNS) with a gethostbyname() call.
a624 8
    use Sys::Hostname;
    my $host = hostname();
    my $addr = inet_ntoa(scalar gethostbyname($host || 'localhost'));

Probably the simplest way to learn your DNS domain name is to grok
it out of /etc/resolv.conf, at least under Unix.  Of course, this
assumes several things about your resolv.conf configuration, including
that it exists.
d626 3
a628 2
(We still need a good DNS domain name-learning method for non-Unix
systems.)
d645 4
a648 4
A DCE::RPC module is being developed (but is not yet available) and
will be released as part of the DCE-Perl package (available from
CPAN).  The rpcgen suite, available from CPAN/authors/id/JAKE/, is
an RPC stub generator and includes an RPC::ONC module.
d652 2
a653 2
Copyright (c) 1997-2002 Tom Christiansen and Nathan Torkington.
All rights reserved.
@


1.6
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d3 1
a3 1
perlfaq9 - Networking ($Revision: 1.15 $, $Date: 2003/01/31 17:36:57 $)
d386 1
a386 1
on the other hand to answer you, you cannot determine whether a mail
@


1.5
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d3 1
a3 1
perlfaq9 - Networking ($Revision: 1.9 $, $Date: 2002/04/07 18:46:13 $)
d14 4
a17 4
The Common Gateway Interface (CGI) specifies a software interface between 
a program ("CGI script") and a web server (HTTPD). It is not specific 
to Perl, and has its own FAQs and tutorials, and usenet group, 
comp.infosystems.www.authoring.cgi 
d25 1
a25 1
These Perl FAQs very selectively cover some CGI issues. However, Perl 
d27 1
a27 1
of the details for them. 
d56 1
a56 1
If, after that, you can demonstrate that you've read the FAQs and that 
d64 1
a64 1
The useful FAQs, related documents, and troubleshooting guides are 
d153 3
a155 3
frames, and many other tags that can contain a URL.  If you need 
anything more complex, you can create your own subclass of 
C<HTML::LinkExtor> or C<HTML::Parser>.  You might even use 
d159 3
a161 1
Less complete solutions involving regular expressions can save 
d165 1
a165 1
attribute is HREF and there are no other attributes. 
d178 11
a188 4
In the context of an HTML form, you can use what's known as
B<multipart/form-data> encoding.  The CGI.pm module (available from
CPAN) supports this in the start_multipart_form() method, which isn't
the same as the startform() method.
d300 1
a300 1
But if coded directly, it could be as follows (the final "\n" is 
d302 1
a302 1
an absolute URLpath. 
d310 5
a314 2
That depends.  You'll need to read the documentation for your web
server, or perhaps check some of the other FAQs referenced above.
d392 8
d554 1
a554 1
This defaults to using L<sendmail(1)> but can be customized to use
d560 1
a560 1
MailFolder package) or the Mail::Internet module from CPAN (also part
d565 1
a565 1
    # bysub1 - simple sort by subject
d570 1
a570 1
        if (/^From/m) {
@


1.4
log
@merge in perl 5.6.1 with our local changes
@
text
@d3 1
a3 1
perlfaq9 - Networking ($Revision: 1.26 $, $Date: 1999/05/23 16:08:30 $)
d10 39
d51 6
a56 1
If you can demonstrate that you've read the following FAQs and that
d60 1
a60 1
with HTTP, HTML, or the CGI protocols).  Questions that appear to be Perl
d62 1
a62 9
may not be so well received.

The useful FAQs and related documents are:

    CGI FAQ
        http://www.webthing.com/tutorials/cgifaq.html

    Web FAQ
        http://www.boutell.com/faq/
d64 2
a65 2
    WWW Security FAQ
        http://www.w3.org/Security/Faq/
d67 1
a67 2
    HTTP Spec
        http://www.w3.org/pub/WWW/Protocols/HTTP/
a68 9
    HTML Spec
        http://www.w3.org/TR/REC-html40/
        http://www.w3.org/pub/WWW/MarkUp/

    CGI Spec
        http://www.w3.org/CGI/

    CGI Security FAQ
        http://www.go2net.com/people/paulp/cgi-security/safe-cgi.txt
d123 1
a123 1
http://www.perl.com/CPAN/authors/Tom_Christiansen/scripts/striphtml.gz
d151 21
a171 1
A quick but imperfect approach is
a172 14
    #!/usr/bin/perl -n00
    # qxurl - tchrist@@perl.com
    print "$2\n" while m{
	< \s*
	  A \s+ HREF \s* = \s* (["']) (.*?) \1
	\s* >
    }gsix;

This version does not adjust relative URLs, understand alternate
bases, deal with HTML comments, deal with HREF and NAME attributes
in the same tag, understand extra qualifiers like TARGET, or accept
URLs themselves as arguments.  It also runs about 100x faster than a
more "complete" solution using the LWP suite of modules, such as the
http://www.perl.com/CPAN/authors/Tom_Christiansen/scripts/xurl.gz program.
d254 1
a254 1
    s/([^\w()'*~!.-])/sprintf '%%%02x', $1/eg;   # encode
d268 9
a276 3
According to RFC 2616, "Hypertext Transfer Protocol -- HTTP/1.1", the
preferred method is to send a C<Location:> header instead of a
C<Content-Type:> header:
d278 1
a278 1
    Location: http://www.domain.com/newpage
d280 2
a281 2
Note that relative URLs in these headers can cause strange effects
because of "optimizations" that servers do.
a282 3
    $url = "http://www.perl.com/CPAN/";
    print "Location: $url\n\n";
    exit;
d284 2
a285 2
To target a particular frame in a frameset, include the "Window-target:"
in the header.
d287 2
a288 3
    print <<EOF;
    Location: http://www.domain.com/newpage
    Window-target: <FrameName>
a289 1
    EOF
d291 7
a297 6
To be correct to the spec, each of those virtual newlines should
really be physical C<"\015\012"> sequences by the time your message is
received by the client browser.  Except for NPH scripts, though, that
local newline should get translated by your server into standard form,
so you shouldn't have a problem here, even if you are stuck on MacOS.
Everybody else probably won't even notice.
d308 2
a309 2
stored.  Databases may be text, dbm, Berkley DB or any database with a
DBI compatible driver.  HTTPD::UserAdmin supports files used by the
d319 3
a321 10
Read the CGI security FAQ, at
http://www-genome.wi.mit.edu/WWW/faqs/www-security-faq.html , and the
Perl/CGI FAQ at
http://www.perl.com/CPAN/doc/FAQs/cgi/perl-cgi-faq.html .

In brief: use tainting (see L<perlsec>), which makes sure that data
from outside your script (eg, CGI parameters) are never used in
C<eval> or C<system> calls.  In addition to tainting, never use the
single-argument form of system() or exec().  Instead, supply the
command and arguments as a list, which prevents shell globbing.
d385 1
a385 1
http://www.perl.com/CPAN/authors/Tom_Christiansen/scripts/ckaddr.gz,
d501 1
a501 1
include queueing, MX records, and security.
d615 1
a615 1
Copyright (c) 1997-1999 Tom Christiansen and Nathan Torkington.
d618 2
a619 6
When included as part of the Standard Version of Perl, or as part of
its complete documentation whether printed or otherwise, this work
may be distributed only under the terms of Perl's Artistic License.
Any distribution of this file or derivatives thereof I<outside>
of that package require that special arrangements be made with
copyright holder.
@


1.3
log
@perl-5.6.0 + local changes
@
text
@d10 1
a10 1
=head2 My CGI script runs from the command line but not the browser.   (500 Server Error)
d87 2
a88 2
or HTML comment may be present.  Plus folks forget to convert
entities, like C<&lt;> for example.
a211 1
Here's an example of decoding:
d213 4
a216 2
    $string = "http://altavista.digital.com/cgi-bin/query?pg=q&what=news&fmt=.&q=%2Bcgi-bin+%2Bperl.exe";
    $string =~ s/%([a-fA-F0-9]{2})/chr(hex($1))/ge;
d218 15
a232 6
Encoding is a bit harder, because you can't just blindly change
all the non-alphanumunder character (C<\W>) into their hex escapes.
It's important that characters with special meaning like C</> and C<?>
I<not> be translated.  Probably the easiest way to get this right is
to avoid reinventing the wheel and just use the URI::Escape module,
available from CPAN.
d236 3
a238 4
Instead of sending back a C<Content-Type> as the headers of your
reply, send back a C<Location:> header.  Officially this should be a
C<URI:> header, so the CGI.pm module (available from CPAN) sends back
both:
a240 1
    URI: http://www.domain.com/newpage
d258 6
a263 6
To be correct to the spec, each of those virtual newlines should really be
physical C<"\015\012"> sequences by the time you hit the client browser.
Except for NPH scripts, though, that local newline should get translated
by your server into standard form, so you shouldn't have a problem
here, even if you are stuck on MacOS.  Everybody else probably won't
even notice.
d286 1
a286 1
http://www-genome.wi.mit.edu/WWW/faqs/www-security-faq.html, and the
d288 1
a288 1
http://www.perl.com/CPAN/doc/FAQs/cgi/perl-cgi-faq.html.
d299 1
a299 1
from page 222 of the 2nd edition of "Programming Perl":
d355 1
a355 1
C</^[\w.-]+\@@([\w.-]\.)+\w+$/>.  It's a very bad idea.  However,
d357 2
a358 2
potential deliverability, so is not suggested.  Instead, see
http://www.perl.com/CPAN/authors/Tom_Christiansen/scripts/ckaddr.gz ,
d391 2
a392 2
The MIME-tools package (available from CPAN) handles this and a lot
more.  Decoding BASE64 becomes as simple as:
d394 1
a394 1
    use MIME::base64;
d397 6
a402 1
A more direct approach is to use the unpack() function's "u"
d412 1
a412 1
On systems that support getpwuid, the $< variable and the
d476 34
d514 1
a514 1
of the MailTools package), often a module is overkill, though.  Here's a
d569 1
a569 1
This can make tasks like fetching the newsgroup list as simple as:
d581 1
a581 1
A DCE::RPC module is being developed (but is not yet available), and
@


1.2
log
@perl5.005_03 (stock)
@
text
@d3 1
a3 1
perlfaq9 - Networking ($Revision: 1.24 $, $Date: 1999/01/08 05:39:48 $)
d79 4
a82 2
The most correct way (albeit not the fastest) is to use HTML::Parse
from CPAN (part of the HTML-Tree package on CPAN).
d85 1
a85 1
C<s/E<lt>.*?E<gt>//g>, but that fails in many cases because the tags
d105 1
a105 1
    <IMG SRC = "foo.gif" 
d136 5
a140 6
bases, deal with HTML comments, deal with HREF and NAME attributes in
the same tag, or accept URLs themselves as arguments.  It also runs
about 100x faster than a more "complete" solution using the LWP suite
of modules, such as the
http://www.perl.com/CPAN/authors/Tom_Christiansen/scripts/xurl.gz
program.
d151 1
a151 1
Use the B<E<lt>SELECTE<gt>> and B<E<lt>OPTIONE<gt>> tags.  The CGI.pm
d163 3
a165 2
The libwww-perl (LWP) modules from CPAN provide a more powerful way to
do this.  They work through proxies, and don't require lynx:
d173 1
a173 1
    getprint "http://www.sn.no/libwww-perl/";
d178 1
a178 1
    use HTML::Parse;
d218 1
a218 1
all the non-alphanumeric characters (C<\W>) into their hex escapes.
d222 1
a222 1
which is part of the libwww-perl package (LWP) available from CPAN.
d241 15
a255 3
To be correct to the spec, each of those C<"\n">
should really each be C<"\015\012">, but unless you're
stuck on MacOS, you probably won't notice.
d346 1
a346 1
mail addresses with a simple regexp, such as
d399 1
a399 1
On systems that support getpwuid, the $E<lt> variable and the
d404 1
a404 1
    $address = sprintf('%s@@%s', getpwuid($<), hostname);
d440 6
a445 1
Or use the CPAN module Mail::Mailer:
d460 1
a460 1
are many reasons to use a mail transport agent like sendmail.  These 
d465 4
a468 21
Use the Mail::Folder module from CPAN (part of the MailFolder package) or
the Mail::Internet module from CPAN (also part of the MailTools package).

   # sending mail
    use Mail::Internet;
    use Mail::Header;
    # say which mail host to use
    $ENV{SMTPHOSTS} = 'mail.frii.com';
    # create headers
    $header = new Mail::Header;
    $header->add('From', 'gnat@@frii.com');
    $header->add('Subject', 'Testing');
    $header->add('To', 'gnat@@frii.com');
    # create body
    $body = 'This is a test, ignore';
    # create mail object
    $mail = new Mail::Internet(undef, Header => $header, Body => \[$body]);
    # send it
    $mail->smtpsend or die;

Often a module is overkill, though.  Here's a mail sorter.
d470 1
a470 1
    #!/usr/bin/perl 
d481 1
a481 1
    } 
d486 1
a486 1
Or more succinctly, 
d546 1
a546 1
may be distributed only under the terms of Perl's Artistic Licence.
a555 1

@


1.1
log
@perl 5.004_04
@
text
@d3 1
a3 1
perlfaq9 - Networking ($Revision: 1.17 $, $Date: 1997/04/24 22:44:29 $)
d10 1
a10 1
=head2 My CGI script runs from the command line but not the browser.  Can you help me fix it?
d12 7
a18 1
Sure, but you probably can't afford our contracting rates :-)
d20 56
a75 15
Seriously, if you can demonstrate that you've read the following FAQs
and that your problem isn't something simple that can be easily
answered, you'll probably receive a courteous and useful reply to your
question if you post it on comp.infosystems.www.authoring.cgi (if it's
something to do with HTTP, HTML, or the CGI protocols).  Questions that
appear to be Perl questions but are really CGI ones that are posted to
comp.lang.perl.misc may not be so well received.

The useful FAQs are:

    http://www.perl.com/perl/faq/idiots-guide.html
    http://www3.pair.com/webthing/docs/cgi/faqs/cgifaq.shtml
    http://www.perl.com/perl/faq/perl-cgi-faq.html
    http://www-genome.wi.mit.edu/WWW/faqs/www-security-faq.html
    http://www.boutell.com/faq/
d80 1
a80 2
from CPAN (part of the libwww-perl distribution, which is a must-have
module for all web hackers).
d98 23
d165 5
a169 1
    # print HTML from a URL
d173 2
a174 1
    # print ASCII from HTML from a URL
d185 24
a208 1
=head2 how do I decode or create those %-encodings on the web?
d216 1
a216 1
all the non-alphanumunder character (C<\W>) into their hex escapes.
d235 8
d274 1
a274 1
=head2 How do I parse an email header?
d290 46
a335 27
A lot of people are tempted to code this up themselves, so you've
probably all seen a lot of code involving C<$ENV{CONTENT_LENGTH}> and
C<$ENV{QUERY_STRING}>.  It's true that this can work, but there are
also a lot of versions of this floating around that are quite simply
broken!

Please do not be tempted to reinvent the wheel.  Instead, use the
CGI.pm or CGI_Lite.pm (available from CPAN), or if you're trapped in
the module-free land of perl1 .. perl4, you might look into cgi-lib.pl
(available from http://www.bio.cam.ac.uk/web/form.html).

=head2 How do I check a valid email address?

You can't.

Without sending mail to the address and seeing whether it bounces (and
even then you face the halting problem), you cannot determine whether
an email address is valid.  Even if you apply the email header
standard, you can have problems, because there are deliverable
addresses that aren't RFC-822 (the mail header standard) compliant,
and addresses that aren't deliverable which are compliant.

Many are tempted to try to eliminate many frequently-invalid email
addresses with a simple regexp, such as
C</^[\w.-]+\@@([\w.-]\.)+\w+$/>.  However, this also throws out many
valid ones, and says nothing about potential deliverability, so is not
suggested.  Instead, see
d338 1
a338 1
comments), looks for addresses you may not wish to accept email to
d340 2
a341 1
hostname given can be looked up in DNS.  It's not fast, but it works.
d343 23
a365 5
Here's an alternative strategy used by many CGI script authors: Check
the email address with a simple regexp (such as the one above).  If
the regexp matched the address, accept the address.  If the regexp
didn't match the address, request confirmation from the user that the
email address they entered was correct.
d383 1
a383 1
=head2 How do I return the user's email address?
d392 3
a394 3
Company policies on email address can mean that this generates addresses
that the company's email system will not accept, so you should ask for
users' email addresses when this matters.  Furthermore, not all systems
d403 3
a405 1
=head2 How do I send/read mail?
d407 41
a447 5
Sending mail: the Mail::Mailer module from CPAN (part of the MailTools
package) is UNIX-centric, while Mail::Internet uses Net::SMTP which is
not UNIX-centric.  Reading mail: use the Mail::Folder module from CPAN
(part of the MailFolder package) or the Mail::Internet module from
CPAN (also part of the MailTools package).
d466 27
d495 4
a498 3
A lot of code has historically cavalierly called the C<`hostname`>
program.  While sometimes expedient, this isn't very portable.  It's
one of those tradeoffs of convenience versus portability.
d507 1
a507 1
    my $addr = inet_ntoa(scalar(gethostbyname($name)) || 'localhost');
d534 2
a535 1
CPAN).  No ONC::RPC module is known.
d539 15
a553 2
Copyright (c) 1997 Tom Christiansen and Nathan Torkington.
All rights reserved.  See L<perlfaq> for distribution information.
@


1.1.1.1
log
@perl5.005_03
@
text
@d3 1
a3 1
perlfaq9 - Networking ($Revision: 1.24 $, $Date: 1999/01/08 05:39:48 $)
d10 1
a10 1
=head2 My CGI script runs from the command line but not the browser.   (500 Server Error)
d12 1
a12 7
If you can demonstrate that you've read the following FAQs and that
your problem isn't something simple that can be easily answered, you'll
probably receive a courteous and useful reply to your question if you
post it on comp.infosystems.www.authoring.cgi (if it's something to do
with HTTP, HTML, or the CGI protocols).  Questions that appear to be Perl
questions but are really CGI ones that are posted to comp.lang.perl.misc
may not be so well received.
d14 15
a28 56
The useful FAQs and related documents are:

    CGI FAQ
        http://www.webthing.com/tutorials/cgifaq.html

    Web FAQ
        http://www.boutell.com/faq/

    WWW Security FAQ
        http://www.w3.org/Security/Faq/

    HTTP Spec
        http://www.w3.org/pub/WWW/Protocols/HTTP/

    HTML Spec
        http://www.w3.org/TR/REC-html40/
        http://www.w3.org/pub/WWW/MarkUp/

    CGI Spec
        http://www.w3.org/CGI/

    CGI Security FAQ
        http://www.go2net.com/people/paulp/cgi-security/safe-cgi.txt

=head2 How can I get better error messages from a CGI program?

Use the CGI::Carp module.  It replaces C<warn> and C<die>, plus the
normal Carp modules C<carp>, C<croak>, and C<confess> functions with
more verbose and safer versions.  It still sends them to the normal
server error log.

    use CGI::Carp;
    warn "This is a complaint";
    die "But this one is serious";

The following use of CGI::Carp also redirects errors to a file of your choice,
placed in a BEGIN block to catch compile-time warnings as well:

    BEGIN {
        use CGI::Carp qw(carpout);
        open(LOG, ">>/var/local/cgi-logs/mycgi-log")
            or die "Unable to append to mycgi-log: $!\n";
        carpout(*LOG);
    }

You can even arrange for fatal errors to go back to the client browser,
which is nice for your own debugging, but might confuse the end user.

    use CGI::Carp qw(fatalsToBrowser);
    die "Bad error here";

Even if the error happens before you get the HTTP header out, the module
will try to take care of this to avoid the dreaded server 500 errors.
Normal warnings still go out to the server error log (or wherever
you've sent them with C<carpout>) with the application name and date
stamp prepended.
d33 2
a34 1
from CPAN (part of the HTML-Tree package on CPAN).
a51 23
Here are some tricky cases that you should think about when picking
a solution:

    <IMG SRC = "foo.gif" ALT = "A > B">

    <IMG SRC = "foo.gif" 
	 ALT = "A > B">

    <!-- <A comment> -->

    <script>if (a<b && a>c)</script>

    <# Just data #>

    <![INCLUDE CDATA [ >>>>>>>>>>>> ]]>

If HTML comments include other tags, those solutions would also break
on text like this:

    <!-- This section commented out.
        <B>You can't see me!</B>
    -->

d96 1
a96 5
    # simplest version
    use LWP::Simple;
    $content = get($URL);

    # or print HTML from a URL
d100 1
a100 2
    # or print ASCII from HTML from a URL
    # also need HTML-Tree package from CPAN
d111 1
a111 24
=head2 How do I automate an HTML form submission?

If you're submitting values using the GET method, create a URL and encode
the form using the C<query_form> method:

    use LWP::Simple;
    use URI::URL;

    my $url = url('http://www.perl.com/cgi-bin/cpan_mod');
    $url->query_form(module => 'DB_File', readme => 1);
    $content = get($url);

If you're using the POST method, create your own user agent and encode
the content appropriately.

    use HTTP::Request::Common qw(POST);
    use LWP::UserAgent;

    $ua = LWP::UserAgent->new();
    my $req = POST 'http://www.perl.com/cgi-bin/cpan_mod',
                   [ module => 'DB_File', readme => 1 ];
    $content = $ua->request($req)->as_string;

=head2 How do I decode or create those %-encodings on the web?
d119 1
a119 1
all the non-alphanumeric characters (C<\W>) into their hex escapes.
a137 8
    $url = "http://www.perl.com/CPAN/";
    print "Location: $url\n\n";
    exit;

To be correct to the spec, each of those C<"\n">
should really each be C<"\015\012">, but unless you're
stuck on MacOS, you probably won't notice.

d169 1
a169 1
=head2 How do I parse a mail header?
d185 27
a211 46
You use a standard module, probably CGI.pm.  Under no circumstances
should you attempt to do so by hand!

You'll see a lot of CGI programs that blindly read from STDIN the number
of bytes equal to CONTENT_LENGTH for POSTs, or grab QUERY_STRING for
decoding GETs.  These programs are very poorly written.  They only work
sometimes.  They typically forget to check the return value of the read()
system call, which is a cardinal sin.  They don't handle HEAD requests.
They don't handle multipart forms used for file uploads.  They don't deal
with GET/POST combinations where query fields are in more than one place.
They don't deal with keywords in the query string.

In short, they're bad hacks.  Resist them at all costs.  Please do not be
tempted to reinvent the wheel.  Instead, use the CGI.pm or CGI_Lite.pm
(available from CPAN), or if you're trapped in the module-free land
of perl1 .. perl4, you might look into cgi-lib.pl (available from
http://cgi-lib.stanford.edu/cgi-lib/ ).

Make sure you know whether to use a GET or a POST in your form.
GETs should only be used for something that doesn't update the server.
Otherwise you can get mangled databases and repeated feedback mail
messages.  The fancy word for this is ``idempotency''.  This simply
means that there should be no difference between making a GET request
for a particular URL once or multiple times.  This is because the
HTTP protocol definition says that a GET request may be cached by the
browser, or server, or an intervening proxy.  POST requests cannot be
cached, because each request is independent and matters.  Typically,
POST requests change or depend on state on the server (query or update
a database, send mail, or purchase a computer).

=head2 How do I check a valid mail address?

You can't, at least, not in real time.  Bummer, eh?

Without sending mail to the address and seeing whether there's a human
on the other hand to answer you, you cannot determine whether a mail
address is valid.  Even if you apply the mail header standard, you
can have problems, because there are deliverable addresses that aren't
RFC-822 (the mail header standard) compliant, and addresses that aren't
deliverable which are compliant.

Many are tempted to try to eliminate many frequently-invalid
mail addresses with a simple regexp, such as
C</^[\w.-]+\@@([\w.-]\.)+\w+$/>.  It's a very bad idea.  However,
this also throws out many valid ones, and says nothing about
potential deliverability, so is not suggested.  Instead, see
d214 1
a214 1
comments), looks for addresses you may not wish to accept mail to
d216 1
a216 2
hostname given can be looked up in the DNS MX records.  It's not fast,
but it works for what it tries to do.
d218 5
a222 23
Our best advice for verifying a person's mail address is to have them
enter their address twice, just as you normally do to change a password.
This usually weeds out typos.  If both versions match, send
mail to that address with a personal message that looks somewhat like:

    Dear someuser@@host.com,

    Please confirm the mail address you gave us Wed May  6 09:38:41
    MDT 1998 by replying to this message.  Include the string
    "Rumpelstiltskin" in that reply, but spelled in reverse; that is,
    start with "Nik...".  Once this is done, your confirmed address will
    be entered into our records.

If you get the message back and they've followed your directions,
you can be reasonably assured that it's real.

A related strategy that's less open to forgery is to give them a PIN
(personal ID number).  Record the address and PIN (best that it be a
random one) for later processing.  In the mail you send, ask them to
include the PIN in their reply.  But if it bounces, or the message is
included via a ``vacation'' script, it'll be there anyway.  So it's
best to ask them to mail back a slight alteration of the PIN, such as
with the characters reversed, one added or subtracted to each digit, etc.
d240 1
a240 1
=head2 How do I return the user's mail address?
d249 3
a251 3
Company policies on mail address can mean that this generates addresses
that the company's mail system will not accept, so you should ask for
users' mail addresses when this matters.  Furthermore, not all systems
d260 1
a260 3
=head2 How do I send mail?

Use the C<sendmail> program directly:
d262 5
a266 41
    open(SENDMAIL, "|/usr/lib/sendmail -oi -t -odq")
                        or die "Can't fork for sendmail: $!\n";
    print SENDMAIL <<"EOF";
    From: User Originating Mail <me\@@host>
    To: Final Destination <you\@@otherhost>
    Subject: A relevant subject line

    Body of the message goes here after the blank line
    in as many lines as you like.
    EOF
    close(SENDMAIL)     or warn "sendmail didn't close nicely";

The B<-oi> option prevents sendmail from interpreting a line consisting
of a single dot as "end of message".  The B<-t> option says to use the
headers to decide who to send the message to, and B<-odq> says to put
the message into the queue.  This last option means your message won't
be immediately delivered, so leave it out if you want immediate
delivery.

Or use the CPAN module Mail::Mailer:

    use Mail::Mailer;

    $mailer = Mail::Mailer->new();
    $mailer->open({ From    => $from_address,
                    To      => $to_address,
                    Subject => $subject,
                  })
        or die "Can't open: $!\n";
    print $mailer $body;
    $mailer->close();

The Mail::Internet module uses Net::SMTP which is less Unix-centric than
Mail::Mailer, but less reliable.  Avoid raw SMTP commands.  There
are many reasons to use a mail transport agent like sendmail.  These 
include queueing, MX records, and security.

=head2 How do I read mail?

Use the Mail::Folder module from CPAN (part of the MailFolder package) or
the Mail::Internet module from CPAN (also part of the MailTools package).
a284 27
Often a module is overkill, though.  Here's a mail sorter.

    #!/usr/bin/perl 
    # bysub1 - simple sort by subject
    my(@@msgs, @@sub);
    my $msgno = -1;
    $/ = '';                    # paragraph reads
    while (<>) {
        if (/^From/m) {
            /^Subject:\s*(?:Re:\s*)*(.*)/mi;
            $sub[++$msgno] = lc($1) || '';
        }
        $msgs[$msgno] .= $_;
    } 
    for my $i (sort { $sub[$a] cmp $sub[$b] || $a <=> $b } (0 .. $#msgs)) {
        print $msgs[$i];
    }

Or more succinctly, 

    #!/usr/bin/perl -n00
    # bysub2 - awkish sort-by-subject
    BEGIN { $msgno = -1 }
    $sub[++$msgno] = (/^Subject:\s*(?:Re:\s*)*(.*)/mi)[0] if /^From/m;
    $msg[$msgno] .= $_;
    END { print @@msg[ sort { $sub[$a] cmp $sub[$b] || $a <=> $b } (0 .. $#msg) ] }

d287 3
a289 4
The normal way to find your own hostname is to call the C<`hostname`>
program.  While sometimes expedient, this has some problems, such as
not knowing whether you've got the canonical name or not.  It's one of
those tradeoffs of convenience versus portability.
d298 1
a298 1
    my $addr = inet_ntoa(scalar gethostbyname($host || 'localhost'));
d325 1
a325 2
CPAN).  The rpcgen suite, available from CPAN/authors/id/JAKE/, is
an RPC stub generator and includes an RPC::ONC module.
d329 2
a330 15
Copyright (c) 1997-1999 Tom Christiansen and Nathan Torkington.
All rights reserved.

When included as part of the Standard Version of Perl, or as part of
its complete documentation whether printed or otherwise, this work
may be distributed only under the terms of Perl's Artistic Licence.
Any distribution of this file or derivatives thereof I<outside>
of that package require that special arrangements be made with
copyright holder.

Irrespective of its distribution, all code examples in this file
are hereby placed into the public domain.  You are permitted and
encouraged to use this code in your own programs for fun
or for profit as you see fit.  A simple comment in the code giving
credit would be courteous but is not required.
@


1.1.1.2
log
@virgin perl 5.6.0
@
text
@d3 1
a3 1
perlfaq9 - Networking ($Revision: 1.26 $, $Date: 1999/05/23 16:08:30 $)
d79 2
a80 4
The most correct way (albeit not the fastest) is to use HTML::Parser
from CPAN.  Another mostly correct
way is to use HTML::FormatText which not only removes HTML but also
attempts to do a little simple formatting of the resulting plain text.
d83 1
a83 1
C<< s/<.*?>//g >>, but that fails in many cases because the tags
d103 1
a103 1
    <IMG SRC = "foo.gif"
d134 6
a139 5
bases, deal with HTML comments, deal with HREF and NAME attributes
in the same tag, understand extra qualifiers like TARGET, or accept
URLs themselves as arguments.  It also runs about 100x faster than a
more "complete" solution using the LWP suite of modules, such as the
http://www.perl.com/CPAN/authors/Tom_Christiansen/scripts/xurl.gz program.
d150 1
a150 1
Use the B<< <SELECT> >> and B<< <OPTION> >> tags.  The CGI.pm
d162 2
a163 3
The libwww-perl (LWP) modules from CPAN provide a more powerful way
to do this.  They don't require lynx, but like lynx, can still work
through proxies:
d171 1
a171 1
    getprint "http://www.linpro.no/lwp/";
d176 1
a176 1
    use HTML::Parser;
d216 1
a216 1
all the non-alphanumunder character (C<\W>) into their hex escapes.
d220 1
a220 1
available from CPAN.
d239 3
a241 15
To target a particular frame in a frameset, include the "Window-target:"
in the header.

    print <<EOF;
    Location: http://www.domain.com/newpage
    Window-target: <FrameName>

    EOF

To be correct to the spec, each of those virtual newlines should really be
physical C<"\015\012"> sequences by the time you hit the client browser.
Except for NPH scripts, though, that local newline should get translated
by your server into standard form, so you shouldn't have a problem
here, even if you are stuck on MacOS.  Everybody else probably won't
even notice.
d332 1
a332 1
mail addresses with a simple regex, such as
d385 1
a385 1
On systems that support getpwuid, the $< variable and the
d390 1
a390 1
    $address = sprintf('%s@@%s', scalar getpwuid($<), hostname);
d426 1
a426 6
Alternate, less convenient approaches include calling mail (sometimes
called mailx) directly or simply opening up port 25 have having an
intimate conversation between just you and the remote SMTP daemon,
probably sendmail.

Or you might be able use the CPAN module Mail::Mailer:
d441 1
a441 1
are many reasons to use a mail transport agent like sendmail.  These
d446 21
a466 4
While you could use the Mail::Folder module from CPAN (part of the
MailFolder package) or the Mail::Internet module from CPAN (also part
of the MailTools package), often a module is overkill, though.  Here's a
mail sorter.
d468 1
a468 1
    #!/usr/bin/perl
d479 1
a479 1
    }
d484 1
a484 1
Or more succinctly,
d544 1
a544 1
may be distributed only under the terms of Perl's Artistic License.
d554 1
@


1.1.1.3
log
@stock perl 5.6.1
@
text
@d10 1
a10 1
=head2 My CGI script runs from the command line but not the browser.  (500 Server Error)
d87 2
a88 2
or HTML comment may be present.  Plus, folks forget to convert
entities--like C<&lt;> for example.
d212 1
d214 2
a215 4
If you are writing a CGI script, you should be using the CGI.pm module
that comes with perl, or some other equivalent module.  The CGI module
automatically decodes queries for you, and provides an escape()
function to handle encoding.
d217 6
a222 15

The best source of detailed information on URI encoding is RFC 2396.
Basically, the following substitutions do it:

    s/([^\w()'*~!.-])/sprintf '%%%02x', $1/eg;   # encode

    s/%([A-Fa-f\d]{2})/chr hex $1/eg;            # decode

However, you should only apply them to individual URI components, not
the entire URI, otherwise you'll lose information and generally mess
things up.  If that didn't explain it, don't worry.  Just go read
section 2 of the RFC, it's probably the best explanation there is.

RFC 2396 also contains a lot of other useful information, including a
regexp for breaking any arbitrary URI into components (Appendix B).
d226 4
a229 3
According to RFC 2616, "Hypertext Transfer Protocol -- HTTP/1.1", the
preferred method is to send a C<Location:> header instead of a
C<Content-Type:> header:
d232 1
d250 6
a255 6
To be correct to the spec, each of those virtual newlines should
really be physical C<"\015\012"> sequences by the time your message is
received by the client browser.  Except for NPH scripts, though, that
local newline should get translated by your server into standard form,
so you shouldn't have a problem here, even if you are stuck on MacOS.
Everybody else probably won't even notice.
d278 1
a278 1
http://www-genome.wi.mit.edu/WWW/faqs/www-security-faq.html , and the
d280 1
a280 1
http://www.perl.com/CPAN/doc/FAQs/cgi/perl-cgi-faq.html .
d291 1
a291 1
from L<perlfunc/split>:
d347 1
a347 1
C</^[\w.-]+\@@(?:[\w-]+\.)+\w+$/>.  It's a very bad idea.  However,
d349 2
a350 2
potential deliverability, so it is not suggested.  Instead, see
http://www.perl.com/CPAN/authors/Tom_Christiansen/scripts/ckaddr.gz,
d383 2
a384 2
The MIME-Base64 package (available from CPAN) handles this as well as
the MIME/QP encoding.  Decoding BASE64 becomes as simple as:
d386 1
a386 1
    use MIME::Base64;
d389 1
a389 6
The MIME-Tools package (available from CPAN) supports extraction with
decoding of BASE64 encoded attachments and content directly from email
messages.

If the string to decode is short (less than 84 bytes long)
a more direct approach is to use the unpack() function's "u"
d399 1
a399 1
On systems that support getpwuid, the $< variable, and the
a462 34
=head2 How do I use MIME to make an attachment to a mail message?

This answer is extracted directly from the MIME::Lite documentation.
Create a multipart message (i.e., one with attachments).

    use MIME::Lite;

    ### Create a new multipart message:
    $msg = MIME::Lite->new(
                 From    =>'me@@myhost.com',
                 To      =>'you@@yourhost.com',
                 Cc      =>'some@@other.com, some@@more.com',
                 Subject =>'A message with 2 parts...',
                 Type    =>'multipart/mixed'
                 );

    ### Add parts (each "attach" has same arguments as "new"):
    $msg->attach(Type     =>'TEXT',
                 Data     =>"Here's the GIF file you wanted"
                 );
    $msg->attach(Type     =>'image/gif',
                 Path     =>'aaa000123.gif',
                 Filename =>'logo.gif'
                 );

    $text = $msg->as_string;

MIME::Lite also includes a method for sending these things.

    $msg->send;

This defaults to using L<sendmail(1)> but can be customized to use
SMTP via L<Net::SMTP>.

d467 1
a467 1
of the MailTools package), often a module is overkill.  Here's a
d522 1
a522 1
This can make tasks like fetching the newsgroup list as simple as
d534 1
a534 1
A DCE::RPC module is being developed (but is not yet available) and
@


1.1.1.4
log
@stock perl 5.8.0 from CPAN
@
text
@d3 1
a3 1
perlfaq9 - Networking ($Revision: 1.9 $, $Date: 2002/04/07 18:46:13 $)
d10 1
a10 1
=head2 What is the correct form of response from a CGI script?
d12 7
a18 1
(Alan Flavell <flavell+www@@a5.ph.gla.ac.uk> answers...)
d20 1
a20 34
The Common Gateway Interface (CGI) specifies a software interface between 
a program ("CGI script") and a web server (HTTPD). It is not specific 
to Perl, and has its own FAQs and tutorials, and usenet group, 
comp.infosystems.www.authoring.cgi 

The original CGI specification is at: http://hoohoo.ncsa.uiuc.edu/cgi/

Current best-practice RFC draft at: http://CGI-Spec.Golux.Com/

Other relevant documentation listed in: http://www.perl.org/CGI_MetaFAQ.html

These Perl FAQs very selectively cover some CGI issues. However, Perl 
programmers are strongly advised to use the CGI.pm module, to take care
of the details for them. 

The similarity between CGI response headers (defined in the CGI
specification) and HTTP response headers (defined in the HTTP
specification, RFC2616) is intentional, but can sometimes be confusing.

The CGI specification defines two kinds of script: the "Parsed Header"
script, and the "Non Parsed Header" (NPH) script. Check your server
documentation to see what it supports. "Parsed Header" scripts are
simpler in various respects. The CGI specification allows any of the
usual newline representations in the CGI response (it's the server's
job to create an accurate HTTP response based on it). So "\n" written in
text mode is technically correct, and recommended. NPH scripts are more
tricky: they must put out a complete and accurate set of HTTP
transaction response headers; the HTTP specification calls for records
to be terminated with carriage-return and line-feed, i.e ASCII \015\012
written in binary mode.

Using CGI.pm gives excellent platform independence, including EBCDIC
systems. CGI.pm selects an appropriate newline representation
($CGI::CRLF) and sets binmode as appropriate.
d22 2
a23 1
=head2 My CGI script runs from the command line but not the browser.  (500 Server Error)
d25 2
a26 2
Several things could be wrong.  You can go through the "Troubleshooting
Perl CGI scripts" guide at
d28 2
a29 1
	http://www.perl.org/troubleshooting_CGI.html
d31 2
a32 7
If, after that, you can demonstrate that you've read the FAQs and that 
your problem isn't something simple that can be easily answered, you'll
probably receive a courteous and useful reply to your question if you
post it on comp.infosystems.www.authoring.cgi (if it's something to do
with HTTP or the CGI protocols).  Questions that appear to be Perl
questions but are really CGI ones that are posted to comp.lang.perl.misc
are not so well received.
d34 3
a36 2
The useful FAQs, related documents, and troubleshooting guides are 
listed in the CGI Meta FAQ:
d38 2
a39 1
	http://www.perl.org/CGI_MetaFAQ.html
d41 2
d97 1
a97 1
http://www.cpan.org/authors/Tom_Christiansen/scripts/striphtml.gz
d125 1
a125 21
You can easily extract all sorts of URLs from HTML with
C<HTML::SimpleLinkExtor> which handles anchors, images, objects,
frames, and many other tags that can contain a URL.  If you need 
anything more complex, you can create your own subclass of 
C<HTML::LinkExtor> or C<HTML::Parser>.  You might even use 
C<HTML::SimpleLinkExtor> as an example for something specifically
suited to your needs.

Less complete solutions involving regular expressions can save 
you a lot of processing time if you know that the input is simple.  One
solution from Tom Christiansen runs 100 times faster than most
module based approaches but only extracts URLs from anchors where the first
attribute is HREF and there are no other attributes. 

        #!/usr/bin/perl -n00
        # qxurl - tchrist@@perl.com
        print "$2\n" while m{
            < \s*
              A \s+ HREF \s* = \s* (["']) (.*?) \1
            \s* >
        }gsix;
d127 14
d222 1
a222 1
    s/([^\w()'*~!.-])/sprintf '%%%02x', ord $1/eg;   # encode
d236 3
a238 6
Specify the complete URL of the destination (even if it is on the same
server). This is one of the two different kinds of CGI "Location:"
responses which are defined in the CGI specification for a Parsed Headers
script. The other kind (an absolute URLpath) is resolved internally to
the server without any HTTP redirection. The CGI specifications do not
allow relative URLs in either case.
d240 1
a240 2
Use of CGI.pm is strongly recommended.  This example shows redirection
with a complete URL. This redirection is handled by the web browser.
d242 2
a243 1
      use CGI qw/:standard/;
d245 3
a247 2
      my $url = 'http://www.cpan.org/';
      print redirect($url);
d249 2
d252 3
a254 2
This example shows a redirection with an absolute URLpath.  This
redirection is handled by the local web server.
d256 1
a256 10
      my $url = '/CPAN/index.html';
      print redirect($url);


But if coded directly, it could be as follows (the final "\n" is 
shown separately, for clarity), using either a complete URL or
an absolute URLpath. 

      print "Location: $url\n";   # CGI response header
      print "\n";                 # end of headers
d258 6
d274 2
a275 2
stored.  Databases may be text, dbm, Berkeley DB or any database with
a DBI compatible driver.  HTTPD::UserAdmin supports files used by the
d285 10
a294 3
See the security references listed in the CGI Meta FAQ

	http://www.perl.org/CGI_MetaFAQ.html
d358 1
a358 1
http://www.cpan.org/authors/Tom_Christiansen/scripts/ckaddr.gz ,
d474 1
a474 1
include queuing, MX records, and security.
d588 1
a588 1
Copyright (c) 1997-2002 Tom Christiansen and Nathan Torkington.
d591 6
a596 2
This documentation is free; you can redistribute it and/or modify it
under the same terms as Perl itself.
@


1.1.1.5
log
@perl 5.8.2 from CPAN
@
text
@d3 1
a3 1
perlfaq9 - Networking ($Revision: 1.15 $, $Date: 2003/01/31 17:36:57 $)
d14 4
a17 4
The Common Gateway Interface (CGI) specifies a software interface between
a program ("CGI script") and a web server (HTTPD). It is not specific
to Perl, and has its own FAQs and tutorials, and usenet group,
comp.infosystems.www.authoring.cgi
d25 1
a25 1
These Perl FAQs very selectively cover some CGI issues. However, Perl
d27 1
a27 1
of the details for them.
d56 1
a56 1
If, after that, you can demonstrate that you've read the FAQs and that
d64 1
a64 1
The useful FAQs, related documents, and troubleshooting guides are
d153 3
a155 3
frames, and many other tags that can contain a URL.  If you need
anything more complex, you can create your own subclass of
C<HTML::LinkExtor> or C<HTML::Parser>.  You might even use
d159 1
a159 3
You can use URI::Find to extract URLs from an arbitrary text document.

Less complete solutions involving regular expressions can save
d163 1
a163 1
attribute is HREF and there are no other attributes.
d176 4
a179 11
In this case, download means to use the file upload feature of HTML
forms.  You allow the web surfer to specify a file to send to your web
server.  To you it looks like a download, and to the user it looks
like an upload.  No matter what you call it, you do it with what's
known as B<multipart/form-data> encoding.  The CGI.pm module (which
comes with Perl as part of the Standard Library) supports this in the
start_multipart_form() method, which isn't the same as the startform()
method.

See the section in the CGI.pm documentation on file uploads for code
examples and details.
d291 1
a291 1
But if coded directly, it could be as follows (the final "\n" is
d293 1
a293 1
an absolute URLpath.
d301 2
a302 5
To enable authentication for your web server, you need to configure
your web server.  The configuration is different for different sorts
of web servers---apache does it differently from iPlanet which does
it differently from IIS.  Check your web server documentation for
the details for your particular server.
a379 8
You can use the Email::Valid or RFC::RFC822::Address which check
the format of the address, although they cannot actually tell you
if it is a deliverable address (i.e. that mail to the address
will not bounce).  Modules like Mail::CheckUser and Mail::EXPN
try to interact with the domain name system or particular
mail servers to learn even more, but their methods do not
work everywhere---especially for security conscious administrators.

d534 1
a534 1
This defaults to using L<sendmail> but can be customized to use
d540 1
a540 1
MailFolder package) or the Mail::Internet module from CPAN (part
d545 1
a545 1

d550 1
a550 1
        if (/^From /m) {
@


1.1.1.6
log
@Import of stock perl 5.8.5
@
text
@d3 1
a3 1
perlfaq9 - Networking ($Revision: 1.6 $, $Date: 2003/12/03 03:02:45 $)
@


1.1.1.7
log
@perl 5.8.6 from CPAN
@
text
@d3 1
a3 1
perlfaq9 - Networking ($Revision: 1.16 $, $Date: 2004/10/30 12:20:59 $)
d386 1
a386 1
on the other end to answer you, you cannot determine whether a mail
@


1.1.1.8
log
@perl 5.8.8 import
@
text
@d3 1
a3 1
perlfaq9 - Networking ($Revision: 1.28 $, $Date: 2005/12/31 00:54:37 $)
d19 3
a21 2
The CGI specification is outlined in an informational RFC:
http://www.ietf.org/rfc/rfc3875
a229 4
If you are doing something complex, such as moving through many pages
and forms or a web site, you can use C<WWW::Mechanize>.  See its
documentation for all the details.

d253 1
d259 1
d265 1
a265 2
    s/%([A-Fa-f\d]{2})/chr hex $1/eg;                # decode
	s/%([[:xdigit:]]{2})/chr hex $1/eg;          # same thing
d322 1
a322 1
"Basic" and "Digest" authentication schemes.  Here's an example:
d351 2
a352 26
(contributed by brian d foy)

Use the CGI.pm module that comes with Perl.  It's quick,
it's easy, and it actually does quite a bit of work to
ensure things happen correctly.  It handles GET, POST, and
HEAD requests, multipart forms, multivalued fields, query
string and message body combinations, and many other things
you probably don't want to think about.

It doesn't get much easier: the CGI module automatically
parses the input and makes each value available through the
C<param()> function.

	use CGI qw(:standard);

	my $total = param( 'price' ) + param( 'shipping' );

	my @@items = param( 'item' ); # multiple values, same field name

If you want an object-oriented approach, CGI.pm can do that too.

	use CGI;

	my $cgi = CGI->new();

	my $total = $cgi->param( 'price' ) + $cgi->param( 'shipping' );
d354 26
a379 9
	my @@items = $cgi->param( 'item' );

You might also try CGI::Minimal which is a lightweight version
of the same thing.  Other CGI::* modules on CPAN might work better
for you, too.

Many people try to write their own decoder (or copy one from
another program) and then run into one of the many "gotchas"
of the task.  It's much easier and less hassle to use CGI.pm.
d432 1
a432 1
included via a "vacation" script, it'll be there anyway.  So it's
d589 1
a589 3
=head2 How do I find out my hostname, domainname, or IP address?
X<hostname, domainname, IP address, host, domain, hostfqdn, inet_ntoa,
gethostbyname, Socket, Net::Domain, Sys::Hostname>
d591 8
a598 1
(contributed by brian d foy)
d600 4
a603 7
The Net::Domain module, which is part of the standard distribution starting
in perl5.7.3, can get you the fully qualified domain name (FQDN), the host
name, or the domain name.

	use Net::Domain qw(hostname hostfqdn hostdomain);

	my $host = hostfqdn();
d605 4
a608 2
The C<Sys::Hostname> module, included in the standard distribution since
perl5.6, can also get the hostname.
d610 2
a611 14
	use Sys::Hostname;

	$host = hostname();

To get the IP address, you can use the C<gethostbyname> built-in function
to turn the name into a number. To turn that number into the dotted octet
form (a.b.c.d) that most people expect, use the C<inet_ntoa> function
from the <Socket> module, which also comes with perl.

    use Socket;

    my $address = inet_ntoa(
    	scalar gethostbyname( $host || 'localhost' )
    	);
d628 4
a631 4
(Contributed by brian d foy)

Use one of the RPC modules you can find on CPAN (
http://search.cpan.org/search?query=RPC&mode=all ).
d635 2
a636 2
Copyright (c) 1997-2006 Tom Christiansen, Nathan Torkington, and
other authors as noted. All rights reserved.
@


1.1.1.9
log
@import perl 5.10.0 from CPAN
@
text
@d3 1
a3 1
perlfaq9 - Networking ($Revision: 8539 $)
d189 1
a189 22
=head2 How do I make an HTML pop-up menu with Perl?

(contributed by brian d foy)

The CGI.pm module (which comes with Perl) has functions to create
the HTML form widgets. See the CGI.pm documentation for more
examples.

	use CGI qw/:standard/;
	print header,
		start_html('Favorite Animals'),

		start_form,
			"What's your favorite animal? ",
        popup_menu(
        	-name   => 'animal',
			-values => [ qw( Llama Alpaca Camel Ram ) ]
			),
        submit,

 		end_form,
        end_html;
d191 3
d314 1
a314 1
of web servers--apache does it differently from iPlanet which does
d392 1
a392 7
(partly contributed by Aaron Sherman)

This isn't as simple a question as it sounds.  There are two parts:

a) How do I verify that an email address is correctly formatted?

b) How do I verify that an email address targets a valid recipient?
d395 25
a419 26
on the other end to answer you, you cannot fully answer part I<b>, but
either the C<Email::Valid> or the C<RFC::RFC822::Address> module will do
both part I<a> and part I<b> as far as you can in real-time.

If you want to just check part I<a> to see that the address is valid
according to the mail header standard with a simple regular expression,
you can have problems, because there are deliverable addresses that
aren't RFC-2822 (the latest mail header standard) compliant, and
addresses that aren't deliverable which, are compliant.  However,  the
following will match valid RFC-2822 addresses that do not have comments,
folding whitespace, or any other obsolete or non-essential elements.
This I<just> matches the address itself:

    my $atom       = qr{[a-zA-Z0-9_!#\$\%&'*+/=?\^`{}~|\-]+};
    my $dot_atom   = qr{$atom(?:\.$atom)*};
    my $quoted     = qr{"(?:\\[^\r\n]|[^\\"])*"};
    my $local      = qr{(?:$dot_atom|$quoted)};
    my $domain_lit = qr{\[(?:\\\S|[\x21-\x5a\x5e-\x7e])*\]};
    my $domain     = qr{(?:$dot_atom|$domain_lit)};
    my $addr_spec  = qr{$local\@@$domain};

Just match an address against C</^${addr_spec}$/> to see if it follows
the RFC2822 specification.  However, because it is impossible to be
sure that such a correctly formed address is actually the correct way
to reach a particular person or even has a mailbox associated with it,
you must be very careful about how you use this.
d422 14
a435 5
enter their address twice, just as you normally do to change a
password. This usually weeds out typos. If both versions match, send
mail to that address with a personal message. If you get the message
back and they've followed your directions, you can be reasonably
assured that it's real.
d439 1
a439 1
random one) for later processing. In the mail you send, ask them to
a649 8
=head1 REVISION

Revision: $Revision: 8539 $

Date: $Date: 2007-01-11 00:07:14 +0100 (Thu, 11 Jan 2007) $

See L<perlfaq> for source control details and availability.

d652 1
a652 1
Copyright (c) 1997-2007 Tom Christiansen, Nathan Torkington, and
@


1.1.1.10
log
@import perl 5.10.1
@
text
@d3 1
a3 1
perlfaq9 - Networking
d68 1
d76 3
a78 3
	use CGI::Carp;
	warn "This is a complaint";
	die "But this one is serious";
d83 6
a88 6
	BEGIN {
		use CGI::Carp qw(carpout);
		open(LOG, ">>/var/local/cgi-logs/mycgi-log")
			or die "Unable to append to mycgi-log: $!\n";
		carpout(*LOG);
	}
d93 2
a94 2
	use CGI::Carp qw(fatalsToBrowser);
	die "Bad error here";
d117 2
a118 2
	#!/usr/bin/perl -p0777
	s/<(?:[^>'"]*|(['"]).*?\1)*>//gs
d128 1
a128 1
	<IMG SRC = "foo.gif" ALT = "A > B">
d130 1
a130 1
	<IMG SRC = "foo.gif"
d133 1
a133 1
	<!-- <A comment> -->
d135 1
a135 1
	<script>if (a<b && a>c)</script>
d137 1
a137 1
	<# Just data #>
d139 1
a139 1
	<![INCLUDE CDATA [ >>>>>>>>>>>> ]]>
d144 3
a146 3
	<!-- This section commented out.
		<B>You can't see me!</B>
	-->
d166 8
a173 7
	#!/usr/bin/perl -n00
	# qxurl - tchrist@@perl.com
	print "$2\n" while m{
		< \s*
		  A \s+ HREF \s* = \s* (["']) (.*?) \1
		\s* >
	}gsix;
d203 2
a204 2
		popup_menu(
			-name   => 'animal',
d207 4
a210 1
		submit,
a211 2
		end_form,
		end_html;
d215 2
a216 8
(contributed by brian d foy)

Use the libwww-perl distribution. The C<LWP::Simple> module can fetch web
resources and give their content back to you as a string:

	use LWP::Simple qw(get);

	my $html = get( "http://www.example.com/index.html" );
d218 2
a219 1
It can also store the resource directly in a file:
d221 23
a243 8
	use LWP::Simple qw(getstore);

	getstore( "http://www.example.com/index.html", "foo.html" );

If you need to do something more complicated, you can use
C<LWP::UserAgent> module to create your own user-agent (e.g. browser)
to get the job done. If you want to simulate an interactive web
browser, you can use the C<WWW::Mechanize> module.
d254 2
a255 2
	use LWP::Simple;
	use URI::URL;
d257 3
a259 3
	my $url = url('http://www.perl.com/cgi-bin/cpan_mod');
	$url->query_form(module => 'DB_File', readme => 1);
	$content = get($url);
d264 2
a265 2
	use HTTP::Request::Common qw(POST);
	use LWP::UserAgent;
d267 4
a270 4
	$ua = LWP::UserAgent->new();
	my $req = POST 'http://www.perl.com/cgi-bin/cpan_mod',
				   [ module => 'DB_File', readme => 1 ];
	$content = $ua->request($req)->as_string;
a272 12
X<URI> X<CGI.pm> X<CGI> X<URI::Escape> X<RFC 2396>

(contributed by brian d foy)

Those C<%> encodings handle reserved characters in URIs, as described
in RFC 2396, Section 2. This encoding replaces the reserved character
with the hexadecimal representation of the character's number from
the US-ASCII table. For instance, a colon, C<:>, becomes C<%3A>.

In CGI scripts, you don't have to worry about decoding URIs if you are
using C<CGI.pm>. You shouldn't have to process the URI yourself,
either on the way in or the way out.
d274 17
a290 5
If you have to encode a string yourself, remember that you should
never try to encode an already-composed URI. You need to escape the
components separately then put them together. To encode a string, you
can use the the C<URI::Escape> module. The C<uri_escape> function
returns the escaped string:
d292 2
a293 21
	my $original = "Colon : Hash # Percent %";

	my $escaped = uri_escape( $original )

	print "$string\n"; # 'Colon%20%3A%20Hash%20%23%20Percent%20%25%20'

To decode the string, use the C<uri_unescape> function:

	my $unescaped = uri_unescape( $escaped );

	print $unescaped; # back to original

If you wanted to do it yourself, you simply need to replace the
reserved characters with their encodings. A global substitution
is one way to do it:

	# encode
	$string =~ s/([^^A-Za-z0-9\-_.!~*'()])/ sprintf "%%%0x", ord $1 /eg;

	#decode
	$string =~ s/%([A-Fa-f\d]{2})/chr hex $1/eg;
d307 4
a310 1
	use CGI qw/:standard/;
a311 2
	my $url = 'http://www.cpan.org/';
	print redirect($url);
d316 3
a318 2
	my $url = '/CPAN/index.html';
	print redirect($url);
d324 3
a326 2
	print "Location: $url\n";   # CGI response header
	print "\n";                 # end of headers
d344 2
a345 2
	use HTTPD::UserAdmin ();
	HTTPD::UserAdmin
d360 4
a363 4
	$/ = '';
	$header = <MSG>;
	$header =~ s/\n\s+/ /g;	 # merge continuation lines
	%head = ( UNIX_FROM_LINE, split /^([-\w]+):\s*/m, $header );
d432 7
a438 8
	my $atom       = qr{[a-zA-Z0-9_!#\$\%&'*+/=?\^`{}~|\-]+};
	my $dot_atom   = qr{$atom(?:\.$atom)*};
	my $quoted     = qr{"(?:\\[^\r\n]|[^\\"])*"};
	my $local      = qr{(?:$dot_atom|$quoted)};
	my $quotedpair = qr{\\[\x00-\x09\x0B-\x0c\x0e-\x7e]};
	my $domain_lit = qr{\[(?:$quotedpair|[\x21-\x5a\x5e-\x7e])*\]};
 	my $domain     = qr{(?:$dot_atom|$domain_lit)};
	my $addr_spec  = qr{$local\@@$domain};
d466 2
a467 2
	use MIME::Base64;
	$decoded = decode_base64($encoded);
d477 4
a480 4
	tr#A-Za-z0-9+/##cd;                   # remove non-base64 chars
	tr#A-Za-z0-9+/# -_#;                  # convert to uuencoded format
	$len = pack("c", 32 + 0.75*length);   # compute length byte
	print unpack("u", $len . $_);         # uudecode and print
d488 2
a489 2
	use Sys::Hostname;
	$address = sprintf('%s@@%s', scalar getpwuid($<), hostname);
d506 11
a516 11
	open(SENDMAIL, "|/usr/lib/sendmail -oi -t -odq")
		or die "Can't fork for sendmail: $!\n";
	print SENDMAIL <<"EOF";
	From: User Originating Mail <me\@@host>
	To: Final Destination <you\@@otherhost>
	Subject: A relevant subject line

	Body of the message goes here after the blank line
	in as many lines as you like.
	EOF
	close(SENDMAIL)     or warn "sendmail didn't close nicely";
d532 1
a532 1
	use Mail::Mailer;
d534 8
a541 8
	$mailer = Mail::Mailer->new();
	$mailer->open({ From    => $from_address,
					To      => $to_address,
					Subject => $subject,
				  })
		or die "Can't open: $!\n";
	print $mailer $body;
	$mailer->close();
d553 1
a553 1
	use MIME::Lite;
d555 17
a571 17
	### Create a new multipart message:
	$msg = MIME::Lite->new(
				 From    =>'me@@myhost.com',
				 To      =>'you@@yourhost.com',
				 Cc      =>'some@@other.com, some@@more.com',
				 Subject =>'A message with 2 parts...',
				 Type    =>'multipart/mixed'
				 );

	### Add parts (each "attach" has same arguments as "new"):
	$msg->attach(Type     =>'TEXT',
				 Data     =>"Here's the GIF file you wanted"
				 );
	$msg->attach(Type     =>'image/gif',
				 Path     =>'aaa000123.gif',
				 Filename =>'logo.gif'
				 );
d573 1
a573 1
	$text = $msg->as_string;
d577 1
a577 1
	$msg->send;
d589 1
a589 1
	#!/usr/bin/perl
d591 13
a603 13
	my(@@msgs, @@sub);
	my $msgno = -1;
	$/ = '';                    # paragraph reads
	while (<>) {
		if (/^From /m) {
			/^Subject:\s*(?:Re:\s*)*(.*)/mi;
			$sub[++$msgno] = lc($1) || '';
		}
		$msgs[$msgno] .= $_;
	}
	for my $i (sort { $sub[$a] cmp $sub[$b] || $a <=> $b } (0 .. $#msgs)) {
		print $msgs[$i];
	}
d607 6
a612 6
	#!/usr/bin/perl -n00
	# bysub2 - awkish sort-by-subject
	BEGIN { $msgno = -1 }
	$sub[++$msgno] = (/^Subject:\s*(?:Re:\s*)*(.*)/mi)[0] if /^From/m;
	$msg[$msgno] .= $_;
	END { print @@msg[ sort { $sub[$a] cmp $sub[$b] || $a <=> $b } (0 .. $#msg) ] }
d640 1
a640 1
	use Socket;
d642 3
a644 3
	my $address = inet_ntoa(
		scalar gethostbyname( $host || 'localhost' )
		);
d651 2
a652 2
	perl -MNews::NNTPClient
	  -e 'print News::NNTPClient->new->list("newsgroups")'
d668 1
a668 1
Revision: $Revision$
d670 1
a670 1
Date: $Date$
d676 1
a676 1
Copyright (c) 1997-2009 Tom Christiansen, Nathan Torkington, and
@


1.1.1.11
log
@Perl 5.12.2 from CPAN
@
text
@d25 1
a25 1
programmers are strongly advised to use the C<CGI.pm> module, to take care
d44 3
a46 3
Using C<CGI.pm> gives excellent platform independence, including EBCDIC
systems. C<CGI.pm> selects an appropriate newline representation
(C<$CGI::CRLF>) and sets binmode as appropriate.
d70 2
a71 2
Use the C<CGI::Carp> module.  It replaces C<warn> and C<die>, plus the
normal C<Carp> modules C<carp>, C<croak>, and C<confess> functions with
d79 2
a80 2
The following use of C<CGI::Carp> also redirects errors to a file of your choice,
placed in a C<BEGIN> block to catch compile-time warnings as well:
d103 1
a103 1
The most correct way (albeit not the fastest) is to use C<HTML::Parser>
d105 1
a105 1
way is to use C<HTML::FormatText> which not only removes HTML but also
d157 1
a157 1
You can use C<URI::Find> to extract URLs from an arbitrary text document.
d179 1
a179 1
known as B<multipart/form-data> encoding.  The C<CGI.pm> module (which
d181 1
a181 1
C<start_multipart_form()> method, which isn't the same as the C<startform()>
d184 1
a184 1
See the section in the C<CGI.pm> documentation on file uploads for code
d191 2
a192 2
The C<CGI.pm> module (which comes with Perl) has functions to create
the HTML form widgets. See the C<CGI.pm> documentation for more
d281 1
a281 1
	my $escaped = uri_escape( $original );
d283 1
a283 1
	print "$escaped\n"; # 'Colon%20%3A%20Hash%20%23%20Percent%20%25'
d310 1
a310 1
Use of C<CGI.pm> is strongly recommended.  This example shows redirection
d341 1
a341 1
The C<HTTPD::UserAdmin> and C<HTTPD::GroupAdmin> modules provide a
d344 1
a344 1
a DBI compatible driver.  C<HTTPD::UserAdmin> supports files used by the
d370 1
a370 1
the C<Mail::Header> module from CPAN (part of the C<MailTools> package).
d376 1
a376 1
Use the C<CGI.pm> module that comes with Perl.  It's quick,
d383 1
a383 1
It doesn't get much easier: the C<CGI.pm> module automatically
d393 1
a393 1
If you want an object-oriented approach, C<CGI.pm> can do that too.
d403 1
a403 1
You might also try C<CGI::Minimal> which is a lightweight version
d409 1
a409 1
of the task.  It's much easier and less hassle to use C<CGI.pm>.
d467 1
a467 1
The C<MIME-Base64> package (available from CPAN) handles this as well as
d473 1
a473 1
The C<MIME-Tools> package (available from CPAN) supports extraction with
d478 1
a478 1
a more direct approach is to use the C<unpack()> function's "u"
d488 2
a489 2
On systems that support getpwuid, the C<< $< >> variable, and the
C<Sys::Hostname> module (which is part of the standard perl distribution),
d500 2
a501 2
The C<Mail::Util> module from CPAN (part of the C<MailTools> package) provides a
C<mailaddress()> function that tries to guess the mail address of the user.
d522 1
a522 1
The B<-oi> option prevents C<sendmail> from interpreting a line consisting
d529 2
a530 2
Alternate, less convenient approaches include calling C<mail> (sometimes
called C<mailx>) directly or simply opening up port 25 have having an
d532 1
a532 1
probably C<sendmail>.
d534 1
a534 1
Or you might be able use the CPAN module C<Mail::Mailer>:
d547 3
a549 3
The C<Mail::Internet> module uses C<Net::SMTP> which is less Unix-centric than
C<Mail::Mailer>, but less reliable.  Avoid raw SMTP commands.  There
are many reasons to use a mail transport agent like C<sendmail>.  These
d554 1
a554 1
This answer is extracted directly from the C<MIME::Lite> documentation.
d579 1
a579 1
C<MIME::Lite> also includes a method for sending these things.
d588 3
a590 3
While you could use the C<Mail::Folder> module from CPAN (part of the
C<MailFolder> package) or the C<Mail::Internet> module from CPAN (part
of the C<MailTools> package), often a module is overkill.  Here's a
d624 1
a624 1
The C<Net::Domain> module, which is part of the standard distribution starting
d642 1
a642 1
from the C<Socket> module, which also comes with perl.
d652 1
a652 1
Use the C<Net::NNTP> or C<News::NNTPClient> modules, both available from CPAN.
d660 1
a660 1
C<LWP::Simple> (available from CPAN) can fetch but not put.  C<Net::FTP> (also
d670 8
d680 1
a680 1
Copyright (c) 1997-2010 Tom Christiansen, Nathan Torkington, and
@


