head	1.16;
access;
symbols
	OPENBSD_6_2_BASE:1.16
	PERL_5_24_2:1.1.1.14
	OPENBSD_6_1:1.16.0.4
	OPENBSD_6_1_BASE:1.16
	OPENBSD_6_0:1.15.0.4
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.14.0.4
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.14.0.6
	OPENBSD_5_8_BASE:1.14
	PERL_5_20_2:1.1.1.13
	OPENBSD_5_7:1.14.0.2
	OPENBSD_5_7_BASE:1.14
	PERL_5_20_1:1.1.1.13
	OPENBSD_5_6:1.13.0.4
	OPENBSD_5_6_BASE:1.13
	PERL_5_18_2:1.1.1.12
	PERL:1.1.1
	OPENBSD_5_5:1.12.0.6
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.2
	OPENBSD_5_4_BASE:1.12
	PERL_5_16_3:1.1.1.11
	OPENBSD_5_3:1.11.0.10
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.8
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.6
	OPENBSD_5_0:1.11.0.4
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.2
	OPENBSD_4_9_BASE:1.11
	PERL_5_12_2:1.1.1.10
	OPENBSD_4_8:1.10.0.4
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.2
	OPENBSD_4_7_BASE:1.10
	PERL_5_10_1:1.1.1.9
	OPENBSD_4_6:1.9.0.6
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.2
	OPENBSD_4_5_BASE:1.9
	PERL_5_10_0:1.1.1.8
	OPENBSD_4_4:1.8.0.10
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.8
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.6
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.4
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.2
	OPENBSD_4_0_BASE:1.8
	PERL_5_8_8:1.1.1.7
	OPENBSD_3_9:1.7.0.10
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.8
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.6
	OPENBSD_3_7_BASE:1.7
	PERL_5_8_6:1.1.1.6
	OPENBSD_3_6:1.7.0.4
	OPENBSD_3_6_BASE:1.7
	PERL_5_8_5:1.1.1.6
	PERL_5_8_3:1.1.1.6
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.16
date	2017.02.05.00.32.18;	author afresh1;	state Exp;
branches;
next	1.15;
commitid	cxJ08BvJA9Pt2PTM;

1.15
date	2016.07.03.01.08.03;	author afresh1;	state Exp;
branches;
next	1.14;
commitid	GzHqjSTnBjdF7Wcw;

1.14
date	2014.11.17.20.57.07;	author afresh1;	state Exp;
branches;
next	1.13;
commitid	QP75iYx42Uo7mMxO;

1.13
date	2014.03.24.15.05.33;	author afresh1;	state Exp;
branches;
next	1.12;

1.12
date	2013.03.25.20.40.59;	author sthen;	state Exp;
branches;
next	1.11;

1.11
date	2010.09.24.15.07.04;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2009.10.12.18.24.47;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2008.09.29.17.36.17;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2006.03.28.19.23.11;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.45;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.33;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.35.58;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.07.36;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.52.18;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.59.24;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.13.03;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.13.03;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.40.56;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.10.29;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.24.44;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.15.06;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.44.23;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2006.03.28.18.49.23;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2008.09.29.17.18.53;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2009.10.12.18.10.38;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2010.09.24.14.49.07;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2013.03.25.20.09.22;	author sthen;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2014.03.24.14.59.08;	author afresh1;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2014.11.17.20.53.15;	author afresh1;	state Exp;
branches;
next	1.1.1.14;
commitid	B31cAbBIXiCqnL97;

1.1.1.14
date	2017.08.14.13.46.20;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.16
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@
=for comment
This document is in Pod format.  To read this, use a Pod formatter,
like "perldoc perlpod".

=head1 NAME
X<POD> X<plain old documentation>

perlpod - the Plain Old Documentation format

=head1 DESCRIPTION

Pod is a simple-to-use markup language used for writing documentation
for Perl, Perl programs, and Perl modules.

Translators are available for converting Pod to various formats
like plain text, HTML, man pages, and more.

Pod markup consists of three basic kinds of paragraphs:
L<ordinary|/"Ordinary Paragraph">,
L<verbatim|/"Verbatim Paragraph">, and 
L<command|/"Command Paragraph">.


=head2 Ordinary Paragraph
X<POD, ordinary paragraph>

Most paragraphs in your documentation will be ordinary blocks
of text, like this one.  You can simply type in your text without
any markup whatsoever, and with just a blank line before and
after.  When it gets formatted, it will undergo minimal formatting, 
like being rewrapped, probably put into a proportionally spaced
font, and maybe even justified.

You can use formatting codes in ordinary paragraphs, for B<bold>,
I<italic>, C<code-style>, L<hyperlinks|perlfaq>, and more.  Such
codes are explained in the "L<Formatting Codes|/"Formatting Codes">"
section, below.


=head2 Verbatim Paragraph
X<POD, verbatim paragraph> X<verbatim>

Verbatim paragraphs are usually used for presenting a codeblock or
other text which does not require any special parsing or formatting,
and which shouldn't be wrapped.

A verbatim paragraph is distinguished by having its first character
be a space or a tab.  (And commonly, all its lines begin with spaces
and/or tabs.)  It should be reproduced exactly, with tabs assumed to
be on 8-column boundaries.  There are no special formatting codes,
so you can't italicize or anything like that.  A \ means \, and
nothing else.


=head2 Command Paragraph
X<POD, command>

A command paragraph is used for special treatment of whole chunks
of text, usually as headings or parts of lists.

All command paragraphs (which are typically only one line long) start
with "=", followed by an identifier, followed by arbitrary text that
the command can use however it pleases.  Currently recognized commands
are

    =pod
    =head1 Heading Text
    =head2 Heading Text
    =head3 Heading Text
    =head4 Heading Text
    =over indentlevel
    =item stuff
    =back
    =begin format
    =end format
    =for format text...
    =encoding type
    =cut

To explain them each in detail:

=over

=item C<=head1 I<Heading Text>>
X<=head1> X<=head2> X<=head3> X<=head4>
X<head1> X<head2> X<head3> X<head4>

=item C<=head2 I<Heading Text>>

=item C<=head3 I<Heading Text>>

=item C<=head4 I<Heading Text>>

Head1 through head4 produce headings, head1 being the highest
level.  The text in the rest of this paragraph is the content of the
heading.  For example:

  =head2 Object Attributes

The text "Object Attributes" comprises the heading there.
The text in these heading commands can use formatting codes, as seen here:

  =head2 Possible Values for C<$/>

Such commands are explained in the
"L<Formatting Codes|/"Formatting Codes">" section, below.

=item C<=over I<indentlevel>>
X<=over> X<=item> X<=back> X<over> X<item> X<back>

=item C<=item I<stuff...>>

=item C<=back>

Item, over, and back require a little more explanation:  "=over" starts
a region specifically for the generation of a list using "=item"
commands, or for indenting (groups of) normal paragraphs.  At the end
of your list, use "=back" to end it.  The I<indentlevel> option to
"=over" indicates how far over to indent, generally in ems (where
one em is the width of an "M" in the document's base font) or roughly
comparable units; if there is no I<indentlevel> option, it defaults
to four.  (And some formatters may just ignore whatever I<indentlevel>
you provide.)  In the I<stuff> in C<=item I<stuff...>>, you may
use formatting codes, as seen here:

  =item Using C<$|> to Control Buffering

Such commands are explained in the
"L<Formatting Codes|/"Formatting Codes">" section, below.

Note also that there are some basic rules to using "=over" ...
"=back" regions:

=over

=item *

Don't use "=item"s outside of an "=over" ... "=back" region.

=item *

The first thing after the "=over" command should be an "=item", unless
there aren't going to be any items at all in this "=over" ... "=back"
region.

=item *

Don't put "=headI<n>" commands inside an "=over" ... "=back" region.

=item *

And perhaps most importantly, keep the items consistent: either use
"=item *" for all of them, to produce bullets; or use "=item 1.",
"=item 2.", etc., to produce numbered lists; or use "=item foo",
"=item bar", etc.--namely, things that look nothing like bullets or
numbers.

If you start with bullets or numbers, stick with them, as
formatters use the first "=item" type to decide how to format the
list.

=back

=item C<=cut>
X<=cut> X<cut>

To end a Pod block, use a blank line,
then a line beginning with "=cut", and a blank
line after it.  This lets Perl (and the Pod formatter) know that
this is where Perl code is resuming.  (The blank line before the "=cut"
is not technically necessary, but many older Pod processors require it.)

=item C<=pod>
X<=pod> X<pod>

The "=pod" command by itself doesn't do much of anything, but it
signals to Perl (and Pod formatters) that a Pod block starts here.  A
Pod block starts with I<any> command paragraph, so a "=pod" command is
usually used just when you want to start a Pod block with an ordinary
paragraph or a verbatim paragraph.  For example:

  =item stuff()

  This function does stuff.

  =cut

  sub stuff {
    ...
  }

  =pod

  Remember to check its return value, as in:

    stuff() || die "Couldn't do stuff!";

  =cut

=item C<=begin I<formatname>>
X<=begin> X<=end> X<=for> X<begin> X<end> X<for>

=item C<=end I<formatname>>

=item C<=for I<formatname> I<text...>>

For, begin, and end will let you have regions of text/code/data that
are not generally interpreted as normal Pod text, but are passed
directly to particular formatters, or are otherwise special.  A
formatter that can use that format will use the region, otherwise it
will be completely ignored.

A command "=begin I<formatname>", some paragraphs, and a
command "=end I<formatname>", mean that the text/data in between
is meant for formatters that understand the special format
called I<formatname>.  For example,

  =begin html

  <hr> <img src="thang.png">
  <p> This is a raw HTML paragraph </p>

  =end html

The command "=for I<formatname> I<text...>"
specifies that the remainder of just this paragraph (starting
right after I<formatname>) is in that special format.  

  =for html <hr> <img src="thang.png">
  <p> This is a raw HTML paragraph </p>

This means the same thing as the above "=begin html" ... "=end html"
region.

That is, with "=for", you can have only one paragraph's worth
of text (i.e., the text in "=foo targetname text..."), but with
"=begin targetname" ... "=end targetname", you can have any amount
of stuff in between.  (Note that there still must be a blank line
after the "=begin" command and a blank line before the "=end"
command.)

Here are some examples of how to use these:

  =begin html

  <br>Figure 1.<br><IMG SRC="figure1.png"><br>

  =end html

  =begin text

    ---------------
    |  foo        |
    |        bar  |
    ---------------

  ^^^^ Figure 1. ^^^^

  =end text

Some format names that formatters currently are known to accept
include "roff", "man", "latex", "tex", "text", and "html".  (Some
formatters will treat some of these as synonyms.)

A format name of "comment" is common for just making notes (presumably
to yourself) that won't appear in any formatted version of the Pod
document:

  =for comment
  Make sure that all the available options are documented!

Some I<formatnames> will require a leading colon (as in
C<"=for :formatname">, or
C<"=begin :formatname" ... "=end :formatname">),
to signal that the text is not raw data, but instead I<is> Pod text
(i.e., possibly containing formatting codes) that's just not for
normal formatting (e.g., may not be a normal-use paragraph, but might
be for formatting as a footnote).

=item C<=encoding I<encodingname>>
X<=encoding> X<encoding>

This command is used for declaring the encoding of a document.  Most
users won't need this; but if your encoding isn't US-ASCII,
then put a C<=encoding I<encodingname>> command very early in the document so
that pod formatters will know how to decode the document.  For
I<encodingname>, use a name recognized by the L<Encode::Supported>
module.  Some pod formatters may try to guess between a Latin-1 or
CP-1252 versus
UTF-8 encoding, but they may guess wrong.  It's best to be explicit if
you use anything besides strict ASCII.  Examples:

  =encoding latin1

  =encoding utf8

  =encoding koi8-r

  =encoding ShiftJIS

  =encoding big5

C<=encoding> affects the whole document, and must occur only once.

=back

And don't forget, all commands but C<=encoding> last up
until the end of its I<paragraph>, not its line.  So in the
examples below, you can see that every command needs the blank
line after it, to end its paragraph.  (And some older Pod translators
may require the C<=encoding> line to have a following blank line as
well, even though it should be legal to omit.)

Some examples of lists include:

  =over

  =item *

  First item

  =item *

  Second item

  =back

  =over

  =item Foo()

  Description of Foo function

  =item Bar()

  Description of Bar function

  =back


=head2 Formatting Codes
X<POD, formatting code> X<formatting code>
X<POD, interior sequence> X<interior sequence>

In ordinary paragraphs and in some command paragraphs, various
formatting codes (a.k.a. "interior sequences") can be used:

=for comment
 "interior sequences" is such an opaque term.
 Prefer "formatting codes" instead.

=over

=item C<IE<lt>textE<gt>> -- italic text
X<I> X<< IZ<><> >> X<POD, formatting code, italic> X<italic>

Used for emphasis ("C<be IE<lt>careful!E<gt>>") and parameters
("C<redo IE<lt>LABELE<gt>>")

=item C<BE<lt>textE<gt>> -- bold text
X<B> X<< BZ<><> >> X<POD, formatting code, bold> X<bold>

Used for switches ("C<perl's BE<lt>-nE<gt> switch>"), programs
("C<some systems provide a BE<lt>chfnE<gt> for that>"),
emphasis ("C<be BE<lt>careful!E<gt>>"), and so on
("C<and that feature is known as BE<lt>autovivificationE<gt>>").

=item C<CE<lt>codeE<gt>> -- code text
X<C> X<< CZ<><> >> X<POD, formatting code, code> X<code>

Renders code in a typewriter font, or gives some other indication that
this represents program text ("C<CE<lt>gmtime($^T)E<gt>>") or some other
form of computerese ("C<CE<lt>drwxr-xr-xE<gt>>").

=item C<LE<lt>nameE<gt>> -- a hyperlink
X<L> X<< LZ<><> >> X<POD, formatting code, hyperlink> X<hyperlink>

There are various syntaxes, listed below.  In the syntaxes given,
C<text>, C<name>, and C<section> cannot contain the characters
'/' and '|'; and any '<' or '>' should be matched.

=over

=item *

C<LE<lt>nameE<gt>>

Link to a Perl manual page (e.g., C<LE<lt>Net::PingE<gt>>).  Note
that C<name> should not contain spaces.  This syntax
is also occasionally used for references to Unix man pages, as in
C<LE<lt>crontab(5)E<gt>>.

=item *

C<LE<lt>name/"sec"E<gt>> or C<LE<lt>name/secE<gt>>

Link to a section in other manual page.  E.g.,
C<LE<lt>perlsyn/"For Loops"E<gt>>

=item *

C<LE<lt>/"sec"E<gt>> or C<LE<lt>/secE<gt>>

Link to a section in this manual page.  E.g.,
C<LE<lt>/"Object Methods"E<gt>>

=back

A section is started by the named heading or item.  For
example, C<LE<lt>perlvar/$.E<gt>> or C<LE<lt>perlvar/"$."E<gt>> both
link to the section started by "C<=item $.>" in perlvar.  And
C<LE<lt>perlsyn/For LoopsE<gt>> or C<LE<lt>perlsyn/"For Loops"E<gt>>
both link to the section started by "C<=head2 For Loops>"
in perlsyn.

To control what text is used for display, you
use "C<LE<lt>text|...E<gt>>", as in:

=over

=item *

C<LE<lt>text|nameE<gt>>

Link this text to that manual page.  E.g.,
C<LE<lt>Perl Error Messages|perldiagE<gt>>

=item *

C<LE<lt>text|name/"sec"E<gt>> or C<LE<lt>text|name/secE<gt>>

Link this text to that section in that manual page.  E.g.,
C<LE<lt>postfix "if"|perlsyn/"Statement Modifiers"E<gt>>

=item *

C<LE<lt>text|/"sec"E<gt>> or C<LE<lt>text|/secE<gt>>
or C<LE<lt>text|"sec"E<gt>>

Link this text to that section in this manual page.  E.g.,
C<LE<lt>the various attributes|/"Member Data"E<gt>>

=back

Or you can link to a web page:

=over

=item *

C<LE<lt>scheme:...E<gt>>

C<LE<lt>text|scheme:...E<gt>>

Links to an absolute URL.  For example, C<LE<lt>http://www.perl.org/E<gt>> or
C<LE<lt>The Perl Home Page|http://www.perl.org/E<gt>>.

=back

=item C<EE<lt>escapeE<gt>> -- a character escape
X<E> X<< EZ<><> >> X<POD, formatting code, escape> X<escape>

Very similar to HTML/XML C<&I<foo>;> "entity references":

=over

=item *

C<EE<lt>ltE<gt>> -- a literal E<lt> (less than)

=item *

C<EE<lt>gtE<gt>> -- a literal E<gt> (greater than)

=item *

C<EE<lt>verbarE<gt>> -- a literal | (I<ver>tical I<bar>)

=item *

C<EE<lt>solE<gt>> -- a literal / (I<sol>idus)

The above four are optional except in other formatting codes,
notably C<LE<lt>...E<gt>>, and when preceded by a
capital letter.

=item *

C<EE<lt>htmlnameE<gt>>

Some non-numeric HTML entity name, such as C<EE<lt>eacuteE<gt>>,
meaning the same thing as C<&eacute;> in HTML -- i.e., a lowercase
e with an acute (/-shaped) accent.

=item *

C<EE<lt>numberE<gt>>

The ASCII/Latin-1/Unicode character with that number.  A
leading "0x" means that I<number> is hex, as in
C<EE<lt>0x201EE<gt>>.  A leading "0" means that I<number> is octal,
as in C<EE<lt>075E<gt>>.  Otherwise I<number> is interpreted as being
in decimal, as in C<EE<lt>181E<gt>>.

Note that older Pod formatters might not recognize octal or
hex numeric escapes, and that many formatters cannot reliably
render characters above 255.  (Some formatters may even have
to use compromised renderings of Latin-1/CP-1252 characters, like
rendering C<EE<lt>eacuteE<gt>> as just a plain "e".)

=back

=item C<FE<lt>filenameE<gt>> -- used for filenames
X<F> X<< FZ<><> >> X<POD, formatting code, filename> X<filename>

Typically displayed in italics.  Example: "C<FE<lt>.cshrcE<gt>>"

=item C<SE<lt>textE<gt>> -- text contains non-breaking spaces
X<S> X<< SZ<><> >> X<POD, formatting code, non-breaking space> 
X<non-breaking space>

This means that the words in I<text> should not be broken
across lines.  Example: S<C<SE<lt>$x ? $y : $zE<gt>>>.

=item C<XE<lt>topic nameE<gt>> -- an index entry
X<X> X<< XZ<><> >> X<POD, formatting code, index entry> X<index entry>

This is ignored by most formatters, but some may use it for building
indexes.  It always renders as empty-string.
Example: C<XE<lt>absolutizing relative URLsE<gt>>

=item C<ZE<lt>E<gt>> -- a null (zero-effect) formatting code
X<Z> X<< ZZ<><> >> X<POD, formatting code, null> X<null>

This is rarely used.  It's one way to get around using an
EE<lt>...E<gt> code sometimes.  For example, instead of
"C<NEE<lt>ltE<gt>3>" (for "NE<lt>3") you could write
"C<NZE<lt>E<gt>E<lt>3>" (the "ZE<lt>E<gt>" breaks up the "N" and
the "E<lt>" so they can't be considered
the part of a (fictitious) "NE<lt>...E<gt>" code).

=for comment
 This was formerly explained as a "zero-width character".  But it in
 most parser models, it parses to nothing at all, as opposed to parsing
 as if it were a E<zwnj> or E<zwj>, which are REAL zero-width characters.
 So "width" and "character" are exactly the wrong words.

=back

Most of the time, you will need only a single set of angle brackets to
delimit the beginning and end of formatting codes.  However,
sometimes you will want to put a real right angle bracket (a
greater-than sign, '>') inside of a formatting code.  This is particularly
common when using a formatting code to provide a different font-type for a
snippet of code.  As with all things in Perl, there is more than
one way to do it.  One way is to simply escape the closing bracket
using an C<E> code:

    C<$a E<lt>=E<gt> $b>

This will produce: "C<$a E<lt>=E<gt> $b>"

A more readable, and perhaps more "plain" way is to use an alternate
set of delimiters that doesn't require a single ">" to be escaped.
Doubled angle brackets ("<<" and ">>") may be used I<if and only if there is
whitespace right after the opening delimiter and whitespace right
before the closing delimiter!>  For example, the following will
do the trick:
X<POD, formatting code, escaping with multiple brackets>

    C<< $a <=> $b >>

In fact, you can use as many repeated angle-brackets as you like so
long as you have the same number of them in the opening and closing
delimiters, and make sure that whitespace immediately follows the last
'<' of the opening delimiter, and immediately precedes the first '>'
of the closing delimiter.  (The whitespace is ignored.)  So the
following will also work:
X<POD, formatting code, escaping with multiple brackets>

    C<<< $a <=> $b >>>
    C<<<<  $a <=> $b     >>>>

And they all mean exactly the same as this:

    C<$a E<lt>=E<gt> $b>

The multiple-bracket form does not affect the interpretation of the contents of
the formatting code, only how it must end.  That means that the examples above
are also exactly the same as this:

    C<< $a E<lt>=E<gt> $b >>

As a further example, this means that if you wanted to put these bits of
code in C<C> (code) style:

    open(X, ">>thing.dat") || die $!
    $foo->bar();

you could do it like so:

    C<<< open(X, ">>thing.dat") || die $! >>>
    C<< $foo->bar(); >>

which is presumably easier to read than the old way:

    C<open(X, "E<gt>E<gt>thing.dat") || die $!>
    C<$foo-E<gt>bar();>

This is currently supported by pod2text (Pod::Text), pod2man (Pod::Man),
and any other pod2xxx or Pod::Xxxx translators that use
Pod::Parser 1.093 or later, or Pod::Tree 1.02 or later.

=head2 The Intent
X<POD, intent of>

The intent is simplicity of use, not power of expression.  Paragraphs
look like paragraphs (block format), so that they stand out
visually, and so that I could run them through C<fmt> easily to reformat
them (that's F7 in my version of B<vi>, or Esc Q in my version of
B<emacs>).  I wanted the translator to always leave the C<'> and C<`> and
C<"> quotes alone, in verbatim mode, so I could slurp in a
working program, shift it over four spaces, and have it print out, er,
verbatim.  And presumably in a monospace font.

The Pod format is not necessarily sufficient for writing a book.  Pod
is just meant to be an idiot-proof common source for nroff, HTML,
TeX, and other markup languages, as used for online
documentation.  Translators exist for B<pod2text>, B<pod2html>,
B<pod2man> (that's for nroff(1) and troff(1)), B<pod2latex>, and
B<pod2fm>.  Various others are available in CPAN.


=head2 Embedding Pods in Perl Modules
X<POD, embedding>

You can embed Pod documentation in your Perl modules and scripts.  Start
your documentation with an empty line, a "=head1" command at the
beginning, and end it with a "=cut" command and an empty line.  The
B<perl> executable will ignore the Pod text.  You can place a Pod
statement where B<perl> expects the beginning of a new statement, but
not within a statement, as that would result in an error.  See any of
the supplied library modules for examples.

If you're going to put your Pod at the end of the file, and you're using
an C<__END__> or C<__DATA__> cut mark, make sure to put an empty line there
before the first Pod command.

  __END__

  =head1 NAME

  Time::Local - efficiently compute time from local and GMT time

Without that empty line before the "=head1", many translators wouldn't
have recognized the "=head1" as starting a Pod block.

=head2 Hints for Writing Pod

=over

=item *
X<podchecker> X<POD, validating>

The B<podchecker> command is provided for checking Pod syntax for errors
and warnings.  For example, it checks for completely blank lines in
Pod blocks and for unknown commands and formatting codes.  You should
still also pass your document through one or more translators and proofread
the result, or print out the result and proofread that.  Some of the
problems found may be bugs in the translators, which you may or may not
wish to work around.

=item *

If you're more familiar with writing in HTML than with writing in Pod, you
can try your hand at writing documentation in simple HTML, and converting
it to Pod with the experimental L<Pod::HTML2Pod|Pod::HTML2Pod> module,
(available in CPAN), and looking at the resulting code.  The experimental
L<Pod::PXML|Pod::PXML> module in CPAN might also be useful.

=item *

Many older Pod translators require the lines before every Pod
command and after every Pod command (including "=cut"!) to be a blank
line.  Having something like this:

 # - - - - - - - - - - - -
 =item $firecracker->boom()

 This noisily detonates the firecracker object.
 =cut
 sub boom {
 ...

...will make such Pod translators completely fail to see the Pod block
at all.

Instead, have it like this:

 # - - - - - - - - - - - -

 =item $firecracker->boom()

 This noisily detonates the firecracker object.

 =cut

 sub boom {
 ...

=item *

Some older Pod translators require paragraphs (including command
paragraphs like "=head2 Functions") to be separated by I<completely>
empty lines.  If you have an apparently empty line with some spaces
on it, this might not count as a separator for those translators, and
that could cause odd formatting.

=item *

Older translators might add wording around an LE<lt>E<gt> link, so that
C<LE<lt>Foo::BarE<gt>> may become "the Foo::Bar manpage", for example.
So you shouldn't write things like C<the LE<lt>fooE<gt>
documentation>, if you want the translated document to read sensibly.
Instead, write C<the LE<lt>Foo::Bar|Foo::BarE<gt> documentation> or
C<LE<lt>the Foo::Bar documentation|Foo::BarE<gt>>, to control how the
link comes out.

=item *

Going past the 70th column in a verbatim block might be ungracefully
wrapped by some formatters.

=back

=head1 SEE ALSO

L<perlpodspec>, L<perlsyn/"PODs: Embedded Documentation">,
L<perlnewmod>, L<perldoc>, L<pod2html>, L<pod2man>, L<podchecker>.

=head1 AUTHOR

Larry Wall, Sean M. Burke

=cut
@


1.15
log
@Update to perl 5.20.3

OK bluhm@@
@
text
@d289 2
a290 1
module.  Some pod formatters may try to guess between a Latin-1 versus
d509 1
a509 1
to use compromised renderings of Latin-1 characters, like
@


1.14
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d285 2
a286 2
users won't need this; but if your encoding isn't US-ASCII or Latin-1,
then put a C<=encoding I<encodingname>> command early in the document so
d289 5
a293 1
module.  Examples:
@


1.13
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d299 2
d303 1
a303 3
C<=encoding> affects the whole document, and must occur only once.

And don't forget, when using any other command, that the command lasts up
d306 3
a308 1
line after it, to end its paragraph.
d633 11
a643 7
You can embed Pod documentation in your Perl modules and scripts.
Start your documentation with an empty line, a "=head1" command at the
beginning, and end it with a "=cut" command and an empty line.  Perl
will ignore the Pod text.  See any of the supplied library modules for
examples.  If you're going to put your Pod at the end of the file, and
you're using an __END__ or __DATA__ cut mark, make sure to put an
empty line there before the first Pod command.
@


1.12
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d101 2
a102 4
The text "Object Attributes" comprises the heading there.  (Note that
head3 and head4 are recent additions, not supported in older Pod
translators.)  The text in these heading commands can use
formatting codes, as seen here:
d241 1
a241 1
command.
d294 1
a294 1
  
d296 1
a296 1
  
d534 1
a534 1
the part of a (fictitious) "NE<lt>...E<gt>" code.
@


1.11
log
@merge in perl 5.12.2 plus local changes
@
text
@d241 1
a241 1
of stuff inbetween.  (Note that there still must be a blank line
d477 1
a477 1
C<EE<lt>solE<gt>> = a literal / (I<sol>idus)
@


1.10
log
@Merge in perl 5.10.1
@
text
@d158 1
a158 1
"=item bar", etc. -- namely, things that look nothing like bullets or
d386 1
a386 1
is also occasionally used for references to UNIX man pages, as in
d398 1
a398 1
C<LE<lt>/"sec"E<gt>> or C<LE<lt>/secE<gt>> or C<LE<lt>"sec"E<gt>>
d449 4
a452 4
Links to an absolute URL.  For example,
C<LE<lt>http://www.perl.org/E<gt>>.  But note
that there is no corresponding C<LE<lt>text|scheme:...E<gt>> syntax, for
various reasons.
d560 2
a561 3
set of delimiters that doesn't require a single ">" to be escaped.  With
the Pod formatters that are standard starting with perl5.5.660, doubled
angle brackets ("<<" and ">>") may be used I<if and only if there is
d584 6
d716 2
a717 2
documentation>, if you want the translated document to read sensibly
-- instead write C<the LE<lt>Foo::Bar|Foo::BarE<gt> documentation> or
@


1.9
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d303 3
a305 1
And don't forget, when using any command, that the command lasts up
@


1.8
log
@merge in perl 5.8.8
@
text
@d217 1
a217 1
command "=end I<formatname>", mean that the text/data inbetween
d427 1
a427 2
C<LE<lt>SWITCH statements|perlsyn/"Basic BLOCKs and Switch
Statements"E<gt>>
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d7 1
d26 1
d42 1
d57 1
d67 1
a74 2
    =cut
    =pod
d78 2
d86 2
d112 1
d168 1
d177 1
d204 1
d284 1
d336 2
d349 1
d355 1
d363 1
d370 1
d456 1
d509 1
d514 2
d521 1
d528 1
d565 1
d575 1
d605 1
d625 1
d649 1
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d272 17
d572 1
a572 1
    C<$foo-E<gt>bar(); >>
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d1 5
d8 1
a8 1
perlpod - plain old documentation
d12 26
a37 6
A pod-to-whatever translator reads a pod file paragraph by paragraph,
and translates it to the appropriate output format.  There are
three kinds of paragraphs:
L<verbatim|/"Verbatim Paragraph">,
L<command|/"Command Paragraph">, and
L<ordinary text|/"Ordinary Block of Text">.
d41 11
a51 5
A verbatim paragraph, distinguished by being indented (that is,
it starts with space or tab).  It should be reproduced exactly,
with tabs assumed to be on 8-column boundaries.  There are no
special formatting escapes, so you can't italicize or anything
like that.  A \ means \, and nothing else.
d55 14
a68 8
All command paragraphs start with "=", followed by an
identifier, followed by arbitrary text that the command can
use however it pleases.  Currently recognized commands are

    =head1 heading
    =head2 heading
    =item text
    =over N
d72 94
a165 3
    =for X
    =begin X
    =end X
d167 1
a167 1
=over 4
d169 5
a173 1
=item =pod
d175 1
a175 1
=item =cut
d177 1
a177 3
The "=pod" directive does nothing beyond telling the compiler to lay
off parsing code through the next "=cut".  It's useful for adding
another paragraph to the doc if you're mixing up code and pod a lot.
d179 1
a179 1
=item =head1
d181 3
a183 1
=item =head2
d185 1
a185 2
Head1 and head2 produce first and second level headings, with the text in
the same paragraph as the "=headn" directive forming the heading description.
d187 1
a187 1
=item =over
d189 1
a189 1
=item =back
d191 1
a191 1
=item =item
d193 1
a193 15
Item, over, and back require a little more explanation: "=over" starts a
section specifically for the generation of a list using "=item" commands. At
the end of your list, use "=back" to end it. You will probably want to give
"4" as the number to "=over", as some formatters will use this for indentation.
The unit of indentation is optional. If the unit is not given the natural
indentation of the formatting system applied will be used. Note also that
there are some basic rules to using =item: don't use them outside of 
an =over/=back block, use at least one inside an =over/=back block, you don't
_have_ to include the =back if the list just runs off the document, and
perhaps most importantly, keep the items consistent: either use "=item *" for
all of them, to produce bullets, or use "=item 1.", "=item 2.", etc., to
produce numbered lists, or use "=item foo", "=item bar", etc., i.e., things
that looks nothing like bullets or numbers. If you start with bullets or
numbers, stick with them, as many formatters use the first "=item" type to
decide how to format the list.
d195 1
a195 1
=item =for
d197 1
a197 1
=item =begin
d199 5
a203 1
=item =end
d205 4
a208 6
For, begin, and end let you include sections that are not interpreted
as pod text, but passed directly to particular formatters. A formatter
that can utilize that format will use the section, otherwise it will be
completely ignored.  The directive "=for" specifies that the entire next
paragraph is in the format indicated by the first word after
"=for", like this:
d210 12
a221 1
 =for html <br>
d224 9
a232 3
The paired commands "=begin" and "=end" work very similarly to "=for", but
instead of only accepting a single paragraph, all text from "=begin" to a
paragraph with a matching "=end" are treated as a particular format.
d236 1
a236 1
 =begin html
d238 1
a238 1
 <br>Figure 1.<IMG SRC="figure1.png"><br>
d240 1
a240 1
 =end html
d242 1
a242 1
 =begin text
d244 4
a247 4
   ---------------
   |  foo        |
   |        bar  |
   ---------------
d249 1
a249 1
 ^^^^ Figure 1. ^^^^
d251 1
a251 1
 =end text
d253 20
a272 3
Some format names that formatters currently are known to accept include
"roff", "man", "latex", "tex", "text", and "html". (Some formatters will
treat some of these as synonyms.)
d274 4
a277 3
And don't forget, when using any command, that the command lasts up until
the end of the B<paragraph>, not the line. Hence in the examples below, you
can see the empty lines after each command to end its paragraph.
d281 152
a432 1
 =over 4
d434 1
a434 1
 =item *
d436 1
a436 1
 First item
d438 1
a438 1
 =item *
d440 1
a440 1
 Second item
d442 3
a444 1
 =back
d446 1
a446 1
 =over 4
d448 1
a448 1
 =item Foo()
d450 3
a452 1
 Description of Foo function
d454 1
a454 1
 =item Bar()
d456 1
a456 1
 Description of Bar function
d458 11
a468 1
 =back
d472 23
a494 1
=head2 Ordinary Block of Text
d496 16
a511 46
It will be filled, and maybe even
justified.  Certain interior sequences are recognized both
here and in commands:

    I<text>     Italicize text, used for emphasis or variables
    B<text>     Embolden text, used for switches and programs
    S<text>     Text contains non-breaking spaces
    C<code>     Render code in a typewriter font, or give some other
                indication that this represents program text
    L<name>     A link (cross reference) to name
		    L<name>		manual page
		    L<name/ident>	item in manual page
		    L<name/"sec">	section in other manual page
		    L<"sec">		section in this manual page
					(the quotes are optional)
		    L</"sec">		ditto
		same as above but only 'text' is used for output.
		(Text can not contain the characters '/' and '|', 
		and should contain matched '<' or '>')
		    L<text|name>
		    L<text|name/ident>
		    L<text|name/"sec">
		    L<text|"sec">
		    L<text|/"sec">

    F<file>	Used for filenames
    X<index>	An index entry
    Z<>		A zero-width character
    E<escape>   A named character (very similar to HTML escapes)
		    E<lt>		A literal <
		    E<gt>		A literal >
		    E<sol>		A literal /
		    E<verbar>		A literal |
		    (these are optional except in other interior
		     sequences and when preceded by a capital letter)
		    E<n>		Character number n (probably in ASCII)
    	    	    E<html>		Some non-numeric HTML entity, such
					as E<Agrave>

Most of the time, you will only need a single set of angle brackets to
delimit the beginning and end of interior sequences.  However, sometimes
you will want to put a right angle bracket (or greater-than sign '>')
inside of a sequence.  This is particularly common when using a sequence
to provide a different font-type for a snippet of code.  As with all
things in Perl, there is more than one way to do it.  One way is to
simply escape the closing bracket using an C<E> sequence:
d517 7
a523 6
A more readable, and perhaps more "plain" way is to use an alternate set of
delimiters that doesn't require a ">" to be escaped.  As of perl5.5.660,
doubled angle brackets ("<<" and ">>") may be used I<if and only if there
is whitespace immediately following the opening delimiter and immediately
preceding the closing delimiter!> For example, the following will do the
trick:
d530 3
a532 2
'<' of the opening delimiter, and immediately precedes the first '>' of
the closing delimiter.  So the following will also work:
d535 21
a555 1
    C<<<< $a <=> $b >>>>
d558 2
a559 2
and any other pod2xxx and Pod::Xxxx translator that uses Pod::Parser
1.093 or later.
d561 1
d563 15
a577 1
=head2 The Intent
a578 26
That's it.  The intent is simplicity, not power.  I wanted paragraphs
to look like paragraphs (block format), so that they stand out
visually, and so that I could run them through fmt easily to reformat
them (that's F7 in my version of B<vi>).  I wanted the translator (and not
me) to worry about whether " or ' is a left quote or a right quote
within filled text, and I wanted it to leave the quotes alone, dammit, in
verbatim mode, so I could slurp in a working program, shift it over 4
spaces, and have it print out, er, verbatim.  And presumably in a
constant width font.

In particular, you can leave things like this verbatim in your text:

    Perl
    FILEHANDLE
    $variable
    function()
    manpage(3r)

Doubtless a few other commands or sequences will need to be added along
the way, but I've gotten along surprisingly well with just these.

Note that I'm not at all claiming this to be sufficient for producing a
book.  I'm just trying to make an idiot-proof common source for nroff,
TeX, and other markup languages, as used for online documentation.
Translators exist for B<pod2man>  (that's for nroff(1) and troff(1)),
B<pod2text>, B<pod2html>, B<pod2latex>, and B<pod2fm>.
d582 7
a588 7
You can embed pod documentation in your Perl scripts.  Start your
documentation with a "=head1" command at the beginning, and end it
with a "=cut" command.  Perl will ignore the pod text.  See any of the
supplied library modules for examples.  If you're going to put your
pods at the end of the file, and you're using an __END__ or __DATA__
cut mark, make sure to put an empty line there before the first pod
directive.
d590 1
a590 1
    __END__
d592 1
a592 1
    =head1 NAME
d594 1
a594 1
    modern - I am a modern module
d596 2
a597 2
If you had not had that empty line there, then the translators wouldn't
have seen it.
d599 1
a599 1
=head2 Common Pod Pitfalls
d601 1
a601 1
=over 4
d605 7
a611 3
Pod translators usually will require paragraphs to be separated by
completely empty lines.  If you have an apparently empty line with
some spaces on it, this can cause odd formatting.
d615 45
a659 5
Translators will mostly add wording around a LE<lt>E<gt> link, so that
C<LE<lt>foo(1)E<gt>> becomes "the I<foo>(1) manpage", for example (see
B<pod2man> for details).  Thus, you shouldn't write things like C<the
LE<lt>fooE<gt> manpage>, if you want the translated document to read
sensibly.
d661 7
a667 2
If you need total control of the text used for a link in the output
use the form LE<lt>show this text|fooE<gt> instead.
d671 2
a672 7
The B<podchecker> command is provided to check pod syntax
for errors and warnings. For example, it checks for completely
blank lines in pod segments and for unknown escape sequences.
It is still advised to pass it through
one or more translators and proofread the result, or print out the
result and proofread that.  Some of the problems found may be bugs in
the translators, which you may or may not wish to work around.
d678 2
a679 2
L<pod2man>, L<perlsyn/"PODs: Embedded Documentation">,
L<podchecker>
d683 1
a683 1
Larry Wall
d685 1
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d66 11
a76 9
This should probably be a default. Note also that there are some basic rules
to using =item: don't use them outside of an =over/=back block, use at least
one inside an =over/=back block, you don't _have_ to include the =back if
the list just runs off the document, and perhaps most importantly, keep the
items consistent: either use "=item *" for all of them, to produce bullets,
or use "=item 1.", "=item 2.", etc., to produce numbered lists, or use
"=item foo", "=item bar", etc., i.e., things that looks nothing like bullets
or numbers. If you start with bullets or numbers, stick with them, as many
formatters use the first "=item" type to decide how to format the list.
@


1.3
log
@perl5.005_03 (stock)
@
text
@a13 1

a21 1

a75 1

a148 1

a150 1

d157 5
a161 4
    I<text>     italicize text, used for emphasis or variables
    B<text>     embolden text, used for switches and programs
    S<text>     text contains non-breaking spaces
    C<code>	literal code
d177 1
a177 1
		
d192 34
a255 1

a267 1

a274 1

d293 2
a294 3
If you don need or want total control of the text used for a
link in the output use the form LE<lt>show this text|fooE<gt>
instead.
d298 4
a301 4
The script F<pod/checkpods.PL> in the Perl source distribution
provides skeletal checking for lines that look empty but aren't
B<only>, but is there as a placeholder until someone writes
Pod::Checker.  The best way to check your pod is to pass it through
d310 2
a311 1
L<pod2man> and L<perlsyn/"PODs: Embedded Documentation">
@


1.2
log
@perl 5.004_04
@
text
@d10 3
a13 1
=over 4
d15 1
a15 1
=item *
a22 1
=item *
d24 3
a26 1
A command.  All command paragraphs start with "=", followed by an
d41 6
d51 4
d58 6
d78 7
a151 1
=item *
d153 6
a158 1
An ordinary block of text.  It will be filled, and maybe even
d173 9
d188 2
d196 2
a197 1
=back
d224 1
a224 1
B<pod2html>, B<pod2latex>, and B<pod2fm>.
d226 2
a227 1
=head1 Embedding Pods in Perl Modules
d247 2
a248 1
=head1 Common Pod Pitfalls
d265 4
@


1.1
log
@Initial revision
@
text
@d34 3
d39 2
a40 2
off of through the next "=cut".  It's useful for adding another 
paragraph to the doc if you're mixing up code and pod a lot.  
d42 2
a43 2
Head1 and head2 produce first and second level headings, with the text on
the same paragraph as "=headn" forming the heading description.
d45 4
a48 4
Item, over, and back require a little more explanation: Over starts a
section specifically for the generation of a list using =item commands. At
the end of your list, use =back to end it. You will probably want to give
"4" as the number to =over, as some formatters will use this for indention.
d57 1
a57 1
formatters you the first =item type to decide how to format the list.  
d59 38
a96 1
And don't forget, when using any command, that that command lasts up until
d98 1
a98 1
can see the blank lines after each command to end it's paragraph.
d135 1
a135 1
    C<code>	literal code 
d137 4
a140 4
		    L<name>		manpage
		    L<name/ident>	item in manpage
		    L<name/"sec">	section in other manpage
		    L<"sec">		section in this manpage
d145 11
a155 1
    Z<>         A zero-width character
d162 1
a162 1
within filled text, and I wanted it to leave the quotes alone dammit in
d187 6
a192 6
documentation with a =head1 command at the beg, and end it with 
an =cut command.  Perl will ignore the pod text.  See any of the
supplied library modules for examples.  If you're going to put
your pods at the end of the file, and you're using an __END__
or __DATA__ cut mark, make sure to put a blank line there before
the first pod directive.
d196 1
d201 1
a201 1
If you had not had that blank line there, then the translators wouldn't
d203 30
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@a9 3
L<verbatim|/"Verbatim Paragraph">,
L<command|/"Command Paragraph">, and
L<ordinary text|/"Ordinary Block of Text">.
d11 1
d13 1
a13 1
=head2 Verbatim Paragraph
d21 1
d23 1
a23 3
=head2 Command Paragraph

All command paragraphs start with "=", followed by an
a33 9
    =for X
    =begin X
    =end X

=over 4

=item =pod

=item =cut
d36 2
a37 13
off parsing code through the next "=cut".  It's useful for adding
another paragraph to the doc if you're mixing up code and pod a lot.

=item =head1

=item =head2

Head1 and head2 produce first and second level headings, with the text in
the same paragraph as the "=headn" directive forming the heading description.

=item =over

=item =back
d39 2
a40 1
=item =item
d42 4
a45 4
Item, over, and back require a little more explanation: "=over" starts a
section specifically for the generation of a list using "=item" commands. At
the end of your list, use "=back" to end it. You will probably want to give
"4" as the number to "=over", as some formatters will use this for indentation.
d54 1
a54 37
formatters use the first "=item" type to decide how to format the list.


=item =for

=item =begin

=item =end

For, begin, and end let you include sections that are not interpreted
as pod text, but passed directly to particular formatters. A formatter
that can utilize that format will use the section, otherwise it will be
completely ignored.  The directive "=for" specifies that the entire next
paragraph is in the format indicated by the first word after
"=for", like this:

 =for html <br>
  <p> This is a raw HTML paragraph </p>

The paired commands "=begin" and "=end" work very similarly to "=for", but
instead of only accepting a single paragraph, all text from "=begin" to a
paragraph with a matching "=end" are treated as a particular format.

Here are some examples of how to use these:

 =begin html

 <br>Figure 1.<IMG SRC="figure1.png"><br>

 =end html

 =begin text

   ---------------
   |  foo        |
   |        bar  |
   ---------------
d56 1
a56 9
 ^^^^ Figure 1. ^^^^

 =end text

Some format names that formatters currently are known to accept include
"roff", "man", "latex", "tex", "text", and "html". (Some formatters will
treat some of these as synonyms.)

And don't forget, when using any command, that the command lasts up until
d58 1
a58 1
can see the empty lines after each command to end its paragraph.
d86 1
d88 1
a88 6
=back


=head2 Ordinary Block of Text

It will be filled, and maybe even
d95 1
a95 1
    C<code>	literal code
d97 4
a100 4
		    L<name>		manual page
		    L<name/ident>	item in manual page
		    L<name/"sec">	section in other manual page
		    L<"sec">		section in this manual page
a102 9
		same as above but only 'text' is used for output.
		(Text can not contain the characters '/' and '|', 
		and should contain matched '<' or '>')
		    L<text|name>
		    L<text|name/ident>
		    L<text|name/"sec">
		    L<text|"sec">
		    L<text|/"sec">
		
d105 1
a105 14
    Z<>		A zero-width character
    E<escape>   A named character (very similar to HTML escapes)
		    E<lt>		A literal <
		    E<gt>		A literal >
		    E<sol>		A literal /
		    E<verbar>		A literal |
		    (these are optional except in other interior
		     sequences and when preceded by a capital letter)
		    E<n>		Character number n (probably in ASCII)
    	    	    E<html>		Some non-numeric HTML entity, such
					as E<Agrave>


=head2 The Intent
d112 1
a112 1
within filled text, and I wanted it to leave the quotes alone, dammit, in
d132 1
a132 2
B<pod2text>, B<pod2html>, B<pod2latex>, and B<pod2fm>.

d134 1
a134 1
=head2 Embedding Pods in Perl Modules
d137 6
a142 6
documentation with a "=head1" command at the beginning, and end it
with a "=cut" command.  Perl will ignore the pod text.  See any of the
supplied library modules for examples.  If you're going to put your
pods at the end of the file, and you're using an __END__ or __DATA__
cut mark, make sure to put an empty line there before the first pod
directive.
a145 1

d150 1
a150 1
If you had not had that empty line there, then the translators wouldn't
a151 35


=head2 Common Pod Pitfalls

=over 4

=item *

Pod translators usually will require paragraphs to be separated by
completely empty lines.  If you have an apparently empty line with
some spaces on it, this can cause odd formatting.

=item *

Translators will mostly add wording around a LE<lt>E<gt> link, so that
C<LE<lt>foo(1)E<gt>> becomes "the I<foo>(1) manpage", for example (see
B<pod2man> for details).  Thus, you shouldn't write things like C<the
LE<lt>fooE<gt> manpage>, if you want the translated document to read
sensibly.

If you don need or want total control of the text used for a
link in the output use the form LE<lt>show this text|fooE<gt>
instead.

=item *

The script F<pod/checkpods.PL> in the Perl source distribution
provides skeletal checking for lines that look empty but aren't
B<only>, but is there as a placeholder until someone writes
Pod::Checker.  The best way to check your pod is to pass it through
one or more translators and proofread the result, or print out the
result and proofread that.  Some of the problems found may be bugs in
the translators, which you may or may not wish to work around.

=back
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d14 1
d23 1
d78 1
d152 1
d155 1
d162 4
a165 5
    I<text>     Italicize text, used for emphasis or variables
    B<text>     Embolden text, used for switches and programs
    S<text>     Text contains non-breaking spaces
    C<code>     Render code in a typewriter font, or give some other
                indication that this represents program text
d181 1
a181 1

a195 34
Most of the time, you will only need a single set of angle brackets to
delimit the beginning and end of interior sequences.  However, sometimes
you will want to put a right angle bracket (or greater-than sign '>')
inside of a sequence.  This is particularly common when using a sequence
to provide a different font-type for a snippet of code.  As with all
things in Perl, there is more than one way to do it.  One way is to
simply escape the closing bracket using an C<E> sequence:

    C<$a E<lt>=E<gt> $b>

This will produce: "C<$a E<lt>=E<gt> $b>"

A more readable, and perhaps more "plain" way is to use an alternate set of
delimiters that doesn't require a ">" to be escaped.  As of perl5.5.660,
doubled angle brackets ("<<" and ">>") may be used I<if and only if there
is whitespace immediately following the opening delimiter and immediately
preceding the closing delimiter!> For example, the following will do the
trick:

    C<< $a <=> $b >>

In fact, you can use as many repeated angle-brackets as you like so
long as you have the same number of them in the opening and closing
delimiters, and make sure that whitespace immediately follows the last
'<' of the opening delimiter, and immediately precedes the first '>' of
the closing delimiter.  So the following will also work:

    C<<< $a <=> $b >>>
    C<<<< $a <=> $b >>>>

This is currently supported by pod2text (Pod::Text), pod2man (Pod::Man),
and any other pod2xxx and Pod::Xxxx translator that uses Pod::Parser
1.093 or later.

d226 1
d239 1
d247 1
d266 3
a268 2
If you need total control of the text used for a link in the output
use the form LE<lt>show this text|fooE<gt> instead.
d272 4
a275 4
The B<podchecker> command is provided to check pod syntax
for errors and warnings. For example, it checks for completely
blank lines in pod segments and for unknown escape sequences.
It is still advised to pass it through
d284 1
a284 2
L<pod2man>, L<perlsyn/"PODs: Embedded Documentation">,
L<podchecker>
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d66 9
a74 11
The unit of indentation is optional. If the unit is not given the natural
indentation of the formatting system applied will be used. Note also that
there are some basic rules to using =item: don't use them outside of 
an =over/=back block, use at least one inside an =over/=back block, you don't
_have_ to include the =back if the list just runs off the document, and
perhaps most importantly, keep the items consistent: either use "=item *" for
all of them, to produce bullets, or use "=item 1.", "=item 2.", etc., to
produce numbered lists, or use "=item foo", "=item bar", etc., i.e., things
that looks nothing like bullets or numbers. If you start with bullets or
numbers, stick with them, as many formatters use the first "=item" type to
decide how to format the list.
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@a0 5

=for comment
This document is in Pod format.  To read this, use a Pod formatter,
like "perldoc perlpod".

d3 1
a3 1
perlpod - the Plain Old Documentation format
d7 6
a12 26
Pod is a simple-to-use markup language used for writing documentation
for Perl, Perl programs, and Perl modules.

Translators are available for converting Pod to various formats
like plain text, HTML, man pages, and more.

Pod markup consists of three basic kinds of paragraphs:
L<ordinary|/"Ordinary Paragraph">,
L<verbatim|/"Verbatim Paragraph">, and 
L<command|/"Command Paragraph">.


=head2 Ordinary Paragraph

Most paragraphs in your documentation will be ordinary blocks
of text, like this one.  You can simply type in your text without
any markup whatsoever, and with just a blank line before and
after.  When it gets formatted, it will undergo minimal formatting, 
like being rewrapped, probably put into a proportionally spaced
font, and maybe even justified.

You can use formatting codes in ordinary paragraphs, for B<bold>,
I<italic>, C<code-style>, L<hyperlinks|perlfaq>, and more.  Such
codes are explained in the "L<Formatting Codes|/"Formatting Codes">"
section, below.

d16 5
a20 11
Verbatim paragraphs are usually used for presenting a codeblock or
other text which does not require any special parsing or formatting,
and which shouldn't be wrapped.

A verbatim paragraph is distinguished by having its first character
be a space or a tab.  (And commonly, all its lines begin with spaces
and/or tabs.)  It should be reproduced exactly, with tabs assumed to
be on 8-column boundaries.  There are no special formatting codes,
so you can't italicize or anything like that.  A \ means \, and
nothing else.

d24 8
a31 14
A command paragraph is used for special treatment of whole chunks
of text, usually as headings or parts of lists.

All command paragraphs (which are typically only one line long) start
with "=", followed by an identifier, followed by arbitrary text that
the command can use however it pleases.  Currently recognized commands
are

    =head1 Heading Text
    =head2 Heading Text
    =head3 Heading Text
    =head4 Heading Text
    =over indentlevel
    =item stuff
d35 3
a37 94
    =begin format
    =end format
    =for format text...

To explain them each in detail:

=over

=item C<=head1 I<Heading Text>>

=item C<=head2 I<Heading Text>>

=item C<=head3 I<Heading Text>>

=item C<=head4 I<Heading Text>>

Head1 through head4 produce headings, head1 being the highest
level.  The text in the rest of this paragraph is the content of the
heading.  For example:

  =head2 Object Attributes

The text "Object Attributes" comprises the heading there.  (Note that
head3 and head4 are recent additions, not supported in older Pod
translators.)  The text in these heading commands can use
formatting codes, as seen here:

  =head2 Possible Values for C<$/>

Such commands are explained in the
"L<Formatting Codes|/"Formatting Codes">" section, below.

=item C<=over I<indentlevel>>

=item C<=item I<stuff...>>

=item C<=back>

Item, over, and back require a little more explanation:  "=over" starts
a region specifically for the generation of a list using "=item"
commands, or for indenting (groups of) normal paragraphs.  At the end
of your list, use "=back" to end it.  The I<indentlevel> option to
"=over" indicates how far over to indent, generally in ems (where
one em is the width of an "M" in the document's base font) or roughly
comparable units; if there is no I<indentlevel> option, it defaults
to four.  (And some formatters may just ignore whatever I<indentlevel>
you provide.)  In the I<stuff> in C<=item I<stuff...>>, you may
use formatting codes, as seen here:

  =item Using C<$|> to Control Buffering

Such commands are explained in the
"L<Formatting Codes|/"Formatting Codes">" section, below.

Note also that there are some basic rules to using "=over" ...
"=back" regions:

=over

=item *

Don't use "=item"s outside of an "=over" ... "=back" region.

=item *

The first thing after the "=over" command should be an "=item", unless
there aren't going to be any items at all in this "=over" ... "=back"
region.

=item *

Don't put "=headI<n>" commands inside an "=over" ... "=back" region.

=item *

And perhaps most importantly, keep the items consistent: either use
"=item *" for all of them, to produce bullets; or use "=item 1.",
"=item 2.", etc., to produce numbered lists; or use "=item foo",
"=item bar", etc. -- namely, things that look nothing like bullets or
numbers.

If you start with bullets or numbers, stick with them, as
formatters use the first "=item" type to decide how to format the
list.

=back

=item C<=cut>

To end a Pod block, use a blank line,
then a line beginning with "=cut", and a blank
line after it.  This lets Perl (and the Pod formatter) know that
this is where Perl code is resuming.  (The blank line before the "=cut"
is not technically necessary, but many older Pod processors require it.)
d39 1
a39 1
=item C<=pod>
d41 1
a41 5
The "=pod" command by itself doesn't do much of anything, but it
signals to Perl (and Pod formatters) that a Pod block starts here.  A
Pod block starts with I<any> command paragraph, so a "=pod" command is
usually used just when you want to start a Pod block with an ordinary
paragraph or a verbatim paragraph.  For example:
d43 1
a43 1
  =item stuff()
d45 3
a47 1
  This function does stuff.
d49 1
a49 1
  =cut
d51 1
a51 3
  sub stuff {
    ...
  }
d53 2
a54 1
  =pod
d56 1
a56 1
  Remember to check its return value, as in:
d58 1
a58 1
    stuff() || die "Couldn't do stuff!";
d60 1
a60 1
  =cut
d62 15
a76 1
=item C<=begin I<formatname>>
d78 1
a78 1
=item C<=end I<formatname>>
d80 1
a80 1
=item C<=for I<formatname> I<text...>>
d82 1
a82 5
For, begin, and end will let you have regions of text/code/data that
are not generally interpreted as normal Pod text, but are passed
directly to particular formatters, or are otherwise special.  A
formatter that can use that format will use the region, otherwise it
will be completely ignored.
d84 6
a89 4
A command "=begin I<formatname>", some paragraphs, and a
command "=end I<formatname>", mean that the text/data inbetween
is meant for formatters that understand the special format
called I<formatname>.  For example,
d91 1
a91 12
  =begin html

  <hr> <img src="thang.png">
  <p> This is a raw HTML paragraph </p>

  =end html

The command "=for I<formatname> I<text...>"
specifies that the remainder of just this paragraph (starting
right after I<formatname>) is in that special format.  

  =for html <hr> <img src="thang.png">
d94 3
a96 9
This means the same thing as the above "=begin html" ... "=end html"
region.

That is, with "=for", you can have only one paragraph's worth
of text (i.e., the text in "=foo targetname text..."), but with
"=begin targetname" ... "=end targetname", you can have any amount
of stuff inbetween.  (Note that there still must be a blank line
after the "=begin" command and a blank line before the "=end"
command.
d100 1
a100 1
  =begin html
d102 1
a102 1
  <br>Figure 1.<br><IMG SRC="figure1.png"><br>
d104 1
a104 1
  =end html
d106 1
a106 1
  =begin text
d108 4
a111 4
    ---------------
    |  foo        |
    |        bar  |
    ---------------
d113 1
a113 1
  ^^^^ Figure 1. ^^^^
d115 1
a115 1
  =end text
d117 3
a119 20
Some format names that formatters currently are known to accept
include "roff", "man", "latex", "tex", "text", and "html".  (Some
formatters will treat some of these as synonyms.)

A format name of "comment" is common for just making notes (presumably
to yourself) that won't appear in any formatted version of the Pod
document:

  =for comment
  Make sure that all the available options are documented!

Some I<formatnames> will require a leading colon (as in
C<"=for :formatname">, or
C<"=begin :formatname" ... "=end :formatname">),
to signal that the text is not raw data, but instead I<is> Pod text
(i.e., possibly containing formatting codes) that's just not for
normal formatting (e.g., may not be a normal-use paragraph, but might
be for formatting as a footnote).

=back
d121 3
a123 4
And don't forget, when using any command, that the command lasts up
until the end of its I<paragraph>, not its line.  So in the
examples below, you can see that every command needs the blank
line after it, to end its paragraph.
d127 1
a127 152
  =over

  =item *

  First item

  =item *

  Second item

  =back

  =over

  =item Foo()

  Description of Foo function

  =item Bar()

  Description of Bar function

  =back


=head2 Formatting Codes

In ordinary paragraphs and in some command paragraphs, various
formatting codes (a.k.a. "interior sequences") can be used:

=for comment
 "interior sequences" is such an opaque term.
 Prefer "formatting codes" instead.

=over

=item C<IE<lt>textE<gt>> -- italic text

Used for emphasis ("C<be IE<lt>careful!E<gt>>") and parameters
("C<redo IE<lt>LABELE<gt>>")

=item C<BE<lt>textE<gt>> -- bold text

Used for switches ("C<perl's BE<lt>-nE<gt> switch>"), programs
("C<some systems provide a BE<lt>chfnE<gt> for that>"),
emphasis ("C<be BE<lt>careful!E<gt>>"), and so on
("C<and that feature is known as BE<lt>autovivificationE<gt>>").

=item C<CE<lt>codeE<gt>> -- code text

Renders code in a typewriter font, or gives some other indication that
this represents program text ("C<CE<lt>gmtime($^T)E<gt>>") or some other
form of computerese ("C<CE<lt>drwxr-xr-xE<gt>>").

=item C<LE<lt>nameE<gt>> -- a hyperlink

There are various syntaxes, listed below.  In the syntaxes given,
C<text>, C<name>, and C<section> cannot contain the characters
'/' and '|'; and any '<' or '>' should be matched.

=over

=item *

C<LE<lt>nameE<gt>>

Link to a Perl manual page (e.g., C<LE<lt>Net::PingE<gt>>).  Note
that C<name> should not contain spaces.  This syntax
is also occasionally used for references to UNIX man pages, as in
C<LE<lt>crontab(5)E<gt>>.

=item *

C<LE<lt>name/"sec"E<gt>> or C<LE<lt>name/secE<gt>>

Link to a section in other manual page.  E.g.,
C<LE<lt>perlsyn/"For Loops"E<gt>>

=item *

C<LE<lt>/"sec"E<gt>> or C<LE<lt>/secE<gt>> or C<LE<lt>"sec"E<gt>>

Link to a section in this manual page.  E.g.,
C<LE<lt>/"Object Methods"E<gt>>

=back

A section is started by the named heading or item.  For
example, C<LE<lt>perlvar/$.E<gt>> or C<LE<lt>perlvar/"$."E<gt>> both
link to the section started by "C<=item $.>" in perlvar.  And
C<LE<lt>perlsyn/For LoopsE<gt>> or C<LE<lt>perlsyn/"For Loops"E<gt>>
both link to the section started by "C<=head2 For Loops>"
in perlsyn.

To control what text is used for display, you
use "C<LE<lt>text|...E<gt>>", as in:

=over

=item *

C<LE<lt>text|nameE<gt>>

Link this text to that manual page.  E.g.,
C<LE<lt>Perl Error Messages|perldiagE<gt>>

=item *

C<LE<lt>text|name/"sec"E<gt>> or C<LE<lt>text|name/secE<gt>>

Link this text to that section in that manual page.  E.g.,
C<LE<lt>SWITCH statements|perlsyn/"Basic BLOCKs and Switch
Statements"E<gt>>

=item *

C<LE<lt>text|/"sec"E<gt>> or C<LE<lt>text|/secE<gt>>
or C<LE<lt>text|"sec"E<gt>>

Link this text to that section in this manual page.  E.g.,
C<LE<lt>the various attributes|/"Member Data"E<gt>>

=back

Or you can link to a web page:

=over

=item *

C<LE<lt>scheme:...E<gt>>

Links to an absolute URL.  For example,
C<LE<lt>http://www.perl.org/E<gt>>.  But note
that there is no corresponding C<LE<lt>text|scheme:...E<gt>> syntax, for
various reasons.

=back

=item C<EE<lt>escapeE<gt>> -- a character escape

Very similar to HTML/XML C<&I<foo>;> "entity references":

=over

=item *

C<EE<lt>ltE<gt>> -- a literal E<lt> (less than)

=item *

C<EE<lt>gtE<gt>> -- a literal E<gt> (greater than)
d129 1
a129 1
=item *
d131 1
a131 1
C<EE<lt>verbarE<gt>> -- a literal | (I<ver>tical I<bar>)
d133 1
a133 1
=item *
d135 1
a135 1
C<EE<lt>solE<gt>> = a literal / (I<sol>idus)
d137 1
a137 3
The above four are optional except in other formatting codes,
notably C<LE<lt>...E<gt>>, and when preceded by a
capital letter.
d139 1
a139 1
=item *
d141 1
a141 1
C<EE<lt>htmlnameE<gt>>
d143 1
a143 3
Some non-numeric HTML entity name, such as C<EE<lt>eacuteE<gt>>,
meaning the same thing as C<&eacute;> in HTML -- i.e., a lowercase
e with an acute (/-shaped) accent.
d145 1
a145 1
=item *
d147 1
a147 1
C<EE<lt>numberE<gt>>
d149 1
a149 11
The ASCII/Latin-1/Unicode character with that number.  A
leading "0x" means that I<number> is hex, as in
C<EE<lt>0x201EE<gt>>.  A leading "0" means that I<number> is octal,
as in C<EE<lt>075E<gt>>.  Otherwise I<number> is interpreted as being
in decimal, as in C<EE<lt>181E<gt>>.

Note that older Pod formatters might not recognize octal or
hex numeric escapes, and that many formatters cannot reliably
render characters above 255.  (Some formatters may even have
to use compromised renderings of Latin-1 characters, like
rendering C<EE<lt>eacuteE<gt>> as just a plain "e".)
d153 1
a153 23
=item C<FE<lt>filenameE<gt>> -- used for filenames

Typically displayed in italics.  Example: "C<FE<lt>.cshrcE<gt>>"

=item C<SE<lt>textE<gt>> -- text contains non-breaking spaces

This means that the words in I<text> should not be broken
across lines.  Example: S<C<SE<lt>$x ? $y : $zE<gt>>>.

=item C<XE<lt>topic nameE<gt>> -- an index entry

This is ignored by most formatters, but some may use it for building
indexes.  It always renders as empty-string.
Example: C<XE<lt>absolutizing relative URLsE<gt>>

=item C<ZE<lt>E<gt>> -- a null (zero-effect) formatting code

This is rarely used.  It's one way to get around using an
EE<lt>...E<gt> code sometimes.  For example, instead of
"C<NEE<lt>ltE<gt>3>" (for "NE<lt>3") you could write
"C<NZE<lt>E<gt>E<lt>3>" (the "ZE<lt>E<gt>" breaks up the "N" and
the "E<lt>" so they can't be considered
the part of a (fictitious) "NE<lt>...E<gt>" code.
d155 46
a200 16
=for comment
 This was formerly explained as a "zero-width character".  But it in
 most parser models, it parses to nothing at all, as opposed to parsing
 as if it were a E<zwnj> or E<zwj>, which are REAL zero-width characters.
 So "width" and "character" are exactly the wrong words.

=back

Most of the time, you will need only a single set of angle brackets to
delimit the beginning and end of formatting codes.  However,
sometimes you will want to put a real right angle bracket (a
greater-than sign, '>') inside of a formatting code.  This is particularly
common when using a formatting code to provide a different font-type for a
snippet of code.  As with all things in Perl, there is more than
one way to do it.  One way is to simply escape the closing bracket
using an C<E> code:
d206 6
a211 7
A more readable, and perhaps more "plain" way is to use an alternate
set of delimiters that doesn't require a single ">" to be escaped.  With
the Pod formatters that are standard starting with perl5.5.660, doubled
angle brackets ("<<" and ">>") may be used I<if and only if there is
whitespace right after the opening delimiter and whitespace right
before the closing delimiter!>  For example, the following will
do the trick:
d218 2
a219 3
'<' of the opening delimiter, and immediately precedes the first '>'
of the closing delimiter.  (The whitespace is ignored.)  So the
following will also work:
d222 1
a222 1
    C<<<<  $a <=> $b     >>>>
d224 3
a226 14
And they all mean exactly the same as this:

    C<$a E<lt>=E<gt> $b>

As a further example, this means that if you wanted to put these bits of
code in C<C> (code) style:

    open(X, ">>thing.dat") || die $!
    $foo->bar();

you could do it like so:

    C<<< open(X, ">>thing.dat") || die $! >>>
    C<< $foo->bar(); >>
a227 8
which is presumably easier to read than the old way:

    C<open(X, "E<gt>E<gt>thing.dat") || die $!>
    C<$foo-E<gt>bar(); >>

This is currently supported by pod2text (Pod::Text), pod2man (Pod::Man),
and any other pod2xxx or Pod::Xxxx translators that use
Pod::Parser 1.093 or later, or Pod::Tree 1.02 or later.
d231 26
a256 16
The intent is simplicity of use, not power of expression.  Paragraphs
look like paragraphs (block format), so that they stand out
visually, and so that I could run them through C<fmt> easily to reformat
them (that's F7 in my version of B<vi>, or Esc Q in my version of
B<emacs>).  I wanted the translator to always leave the C<'> and C<`> and
C<"> quotes alone, in verbatim mode, so I could slurp in a
working program, shift it over four spaces, and have it print out, er,
verbatim.  And presumably in a monospace font.

The Pod format is not necessarily sufficient for writing a book.  Pod
is just meant to be an idiot-proof common source for nroff, HTML,
TeX, and other markup languages, as used for online
documentation.  Translators exist for B<pod2text>, B<pod2html>,
B<pod2man> (that's for nroff(1) and troff(1)), B<pod2latex>, and
B<pod2fm>.  Various others are available in CPAN.

d260 7
a266 7
You can embed Pod documentation in your Perl modules and scripts.
Start your documentation with an empty line, a "=head1" command at the
beginning, and end it with a "=cut" command and an empty line.  Perl
will ignore the Pod text.  See any of the supplied library modules for
examples.  If you're going to put your Pod at the end of the file, and
you're using an __END__ or __DATA__ cut mark, make sure to put an
empty line there before the first Pod command.
d268 1
a268 1
  __END__
d270 1
a270 1
  =head1 NAME
d272 1
a272 1
  Time::Local - efficiently compute time from local and GMT time
d274 2
a275 2
Without that empty line before the "=head1", many translators wouldn't
have recognized the "=head1" as starting a Pod block.
d277 1
a277 1
=head2 Hints for Writing Pod
d279 1
a279 1
=over
d283 3
a285 7
The B<podchecker> command is provided for checking Pod syntax for errors
and warnings.  For example, it checks for completely blank lines in
Pod blocks and for unknown commands and formatting codes.  You should
still also pass your document through one or more translators and proofread
the result, or print out the result and proofread that.  Some of the
problems found may be bugs in the translators, which you may or may not
wish to work around.
d289 5
a293 45
If you're more familiar with writing in HTML than with writing in Pod, you
can try your hand at writing documentation in simple HTML, and converting
it to Pod with the experimental L<Pod::HTML2Pod|Pod::HTML2Pod> module,
(available in CPAN), and looking at the resulting code.  The experimental
L<Pod::PXML|Pod::PXML> module in CPAN might also be useful.

=item *

Many older Pod translators require the lines before every Pod
command and after every Pod command (including "=cut"!) to be a blank
line.  Having something like this:

 # - - - - - - - - - - - -
 =item $firecracker->boom()

 This noisily detonates the firecracker object.
 =cut
 sub boom {
 ...

...will make such Pod translators completely fail to see the Pod block
at all.

Instead, have it like this:

 # - - - - - - - - - - - -

 =item $firecracker->boom()

 This noisily detonates the firecracker object.

 =cut

 sub boom {
 ...

=item *

Some older Pod translators require paragraphs (including command
paragraphs like "=head2 Functions") to be separated by I<completely>
empty lines.  If you have an apparently empty line with some spaces
on it, this might not count as a separator for those translators, and
that could cause odd formatting.

=item *
d295 2
a296 7
Older translators might add wording around an LE<lt>E<gt> link, so that
C<LE<lt>Foo::BarE<gt>> may become "the Foo::Bar manpage", for example.
So you shouldn't write things like C<the LE<lt>fooE<gt>
documentation>, if you want the translated document to read sensibly
-- instead write C<the LE<lt>Foo::Bar|Foo::BarE<gt> documentation> or
C<LE<lt>the Foo::Bar documentation|Foo::BarE<gt>>, to control how the
link comes out.
d300 7
a306 2
Going past the 70th column in a verbatim block might be ungracefully
wrapped by some formatters.
d312 2
a313 2
L<perlpodspec>, L<perlsyn/"PODs: Embedded Documentation">,
L<perlnewmod>, L<perldoc>, L<pod2html>, L<pod2man>, L<podchecker>.
d317 1
a317 1
Larry Wall, Sean M. Burke
a318 1
=cut
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@a271 17
=item C<=encoding I<encodingname>>

This command is used for declaring the encoding of a document.  Most
users won't need this; but if your encoding isn't US-ASCII or Latin-1,
then put a C<=encoding I<encodingname>> command early in the document so
that pod formatters will know how to decode the document.  For
I<encodingname>, use a name recognized by the L<Encode::Supported>
module.  Examples:

  =encoding utf8

  =encoding koi8-r
  
  =encoding ShiftJIS
  
  =encoding big5

d555 1
a555 1
    C<$foo-E<gt>bar();>
@


1.1.1.7
log
@perl 5.8.8 import
@
text
@a6 1
X<POD> X<plain old documentation>
a24 1
X<POD, ordinary paragraph>
a39 1
X<POD, verbatim paragraph> X<verbatim>
a53 1
X<POD, command>
a62 1
    =pod
d70 2
a74 2
    =encoding type
    =cut
a80 2
X<=head1> X<=head2> X<=head3> X<=head4>
X<head1> X<head2> X<head3> X<head4>
a104 1
X<=over> X<=item> X<=back> X<over> X<item> X<back>
a159 1
X<=cut> X<cut>
a167 1
X<=pod> X<pod>
a193 1
X<=begin> X<=end> X<=for> X<begin> X<end> X<for>
a272 1
X<=encoding> X<encoding>
a323 2
X<POD, formatting code> X<formatting code>
X<POD, interior sequence> X<interior sequence>
a334 1
X<I> X<< IZ<><> >> X<POD, formatting code, italic> X<italic>
a339 1
X<B> X<< BZ<><> >> X<POD, formatting code, bold> X<bold>
a346 1
X<C> X<< CZ<><> >> X<POD, formatting code, code> X<code>
a352 1
X<L> X<< LZ<><> >> X<POD, formatting code, hyperlink> X<hyperlink>
a437 1
X<E> X<< EZ<><> >> X<POD, formatting code, escape> X<escape>
a489 1
X<F> X<< FZ<><> >> X<POD, formatting code, filename> X<filename>
a493 2
X<S> X<< SZ<><> >> X<POD, formatting code, non-breaking space> 
X<non-breaking space>
a498 1
X<X> X<< XZ<><> >> X<POD, formatting code, index entry> X<index entry>
a504 1
X<Z> X<< ZZ<><> >> X<POD, formatting code, null> X<null>
a540 1
X<POD, formatting code, escaping with multiple brackets>
a549 1
X<POD, formatting code, escaping with multiple brackets>
a578 1
X<POD, intent of>
a597 1
X<POD, embedding>
a620 1
X<podchecker> X<POD, validating>
@


1.1.1.8
log
@import perl 5.10.0 from CPAN
@
text
@d217 1
a217 1
command "=end I<formatname>", mean that the text/data in between
d427 2
a428 1
C<LE<lt>postfix "if"|perlsyn/"Statement Modifiers"E<gt>>
@


1.1.1.9
log
@import perl 5.10.1
@
text
@d303 1
a303 3
C<=encoding> affects the whole document, and must occur only once.

And don't forget, when using any other command, that the command lasts up
@


1.1.1.10
log
@Perl 5.12.2 from CPAN
@
text
@d158 1
a158 1
"=item bar", etc.--namely, things that look nothing like bullets or
d386 1
a386 1
is also occasionally used for references to Unix man pages, as in
d398 1
a398 1
C<LE<lt>/"sec"E<gt>> or C<LE<lt>/secE<gt>>
d449 4
a452 4
C<LE<lt>text|scheme:...E<gt>>

Links to an absolute URL.  For example, C<LE<lt>http://www.perl.org/E<gt>> or
C<LE<lt>The Perl Home Page|http://www.perl.org/E<gt>>.
d560 3
a562 2
set of delimiters that doesn't require a single ">" to be escaped.
Doubled angle brackets ("<<" and ">>") may be used I<if and only if there is
a584 6
The multiple-bracket form does not affect the interpretation of the contents of
the formatting code, only how it must end.  That means that the examples above
are also exactly the same as this:

    C<< $a E<lt>=E<gt> $b >>

d711 2
a712 2
documentation>, if you want the translated document to read sensibly.
Instead, write C<the LE<lt>Foo::Bar|Foo::BarE<gt> documentation> or
@


1.1.1.11
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d241 1
a241 1
of stuff in between.  (Note that there still must be a blank line
d477 1
a477 1
C<EE<lt>solE<gt>> -- a literal / (I<sol>idus)
@


1.1.1.12
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d101 4
a104 2
The text "Object Attributes" comprises the heading there.
The text in these heading commands can use formatting codes, as seen here:
d243 1
a243 1
command.)
d296 1
a296 1

d298 1
a298 1

d536 1
a536 1
the part of a (fictitious) "NE<lt>...E<gt>" code).
@


1.1.1.13
log
@Import perl-5.20.1
@
text
@d299 2
d303 1
a303 3
=back

And don't forget, all commands but C<=encoding> last up
d306 1
a306 3
line after it, to end its paragraph.  (And some older Pod translators
may require the C<=encoding> line to have a following blank line as
well, even though it should be legal to omit.)
d631 7
a637 11
You can embed Pod documentation in your Perl modules and scripts.  Start
your documentation with an empty line, a "=head1" command at the
beginning, and end it with a "=cut" command and an empty line.  The
B<perl> executable will ignore the Pod text.  You can place a Pod
statement where B<perl> expects the beginning of a new statement, but
not within a statement, as that would result in an error.  See any of
the supplied library modules for examples.

If you're going to put your Pod at the end of the file, and you're using
an C<__END__> or C<__DATA__> cut mark, make sure to put an empty line there
before the first Pod command.
@


1.1.1.14
log
@Import perl-5.24.2
@
text
@d285 2
a286 2
users won't need this; but if your encoding isn't US-ASCII,
then put a C<=encoding I<encodingname>> command very early in the document so
d289 1
a289 6
module.  Some pod formatters may try to guess between a Latin-1 or
CP-1252 versus
UTF-8 encoding, but they may guess wrong.  It's best to be explicit if
you use anything besides strict ASCII.  Examples:

  =encoding latin1
d504 1
a504 1
to use compromised renderings of Latin-1/CP-1252 characters, like
@


