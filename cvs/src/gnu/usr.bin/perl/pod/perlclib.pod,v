head	1.3;
access;
symbols
	OPENBSD_6_1_BASE:1.3
	OPENBSD_6_0:1.2.0.4
	OPENBSD_6_0_BASE:1.2
	OPENBSD_5_9:1.1.1.9.0.4
	OPENBSD_5_9_BASE:1.1.1.9
	OPENBSD_5_8:1.1.1.9.0.6
	OPENBSD_5_8_BASE:1.1.1.9
	PERL_5_20_2:1.1.1.9
	OPENBSD_5_7:1.1.1.9.0.2
	OPENBSD_5_7_BASE:1.1.1.9
	PERL_5_20_1:1.1.1.9
	OPENBSD_5_6:1.1.1.8.0.4
	OPENBSD_5_6_BASE:1.1.1.8
	PERL_5_18_2:1.1.1.8
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.7.0.6
	OPENBSD_5_5_BASE:1.1.1.7
	OPENBSD_5_4:1.1.1.7.0.2
	OPENBSD_5_4_BASE:1.1.1.7
	PERL_5_16_3:1.1.1.7
	OPENBSD_5_3:1.1.1.6.0.10
	OPENBSD_5_3_BASE:1.1.1.6
	OPENBSD_5_2:1.1.1.6.0.8
	OPENBSD_5_2_BASE:1.1.1.6
	OPENBSD_5_1_BASE:1.1.1.6
	OPENBSD_5_1:1.1.1.6.0.6
	OPENBSD_5_0:1.1.1.6.0.4
	OPENBSD_5_0_BASE:1.1.1.6
	OPENBSD_4_9:1.1.1.6.0.2
	OPENBSD_4_9_BASE:1.1.1.6
	PERL_5_12_2:1.1.1.6
	OPENBSD_4_8:1.1.1.5.0.4
	OPENBSD_4_8_BASE:1.1.1.5
	OPENBSD_4_7:1.1.1.5.0.2
	OPENBSD_4_7_BASE:1.1.1.5
	PERL_5_10_1:1.1.1.5
	OPENBSD_4_6:1.1.1.4.0.6
	OPENBSD_4_6_BASE:1.1.1.4
	OPENBSD_4_5:1.1.1.4.0.2
	OPENBSD_4_5_BASE:1.1.1.4
	PERL_5_10_0:1.1.1.4
	OPENBSD_4_4:1.1.1.3.0.10
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.8
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_2:1.1.1.3.0.6
	OPENBSD_4_2_BASE:1.1.1.3
	OPENBSD_4_1:1.1.1.3.0.4
	OPENBSD_4_1_BASE:1.1.1.3
	OPENBSD_4_0:1.1.1.3.0.2
	OPENBSD_4_0_BASE:1.1.1.3
	PERL_5_8_8:1.1.1.3
	OPENBSD_3_9:1.1.1.2.0.14
	OPENBSD_3_9_BASE:1.1.1.2
	OPENBSD_3_8:1.1.1.2.0.12
	OPENBSD_3_8_BASE:1.1.1.2
	OPENBSD_3_7:1.1.1.2.0.10
	OPENBSD_3_7_BASE:1.1.1.2
	PERL_5_8_6:1.1.1.2
	OPENBSD_3_6:1.1.1.2.0.8
	OPENBSD_3_6_BASE:1.1.1.2
	PERL_5_8_5:1.1.1.2
	PERL_5_8_3:1.1.1.2
	OPENBSD_3_5:1.1.1.2.0.6
	OPENBSD_3_5_BASE:1.1.1.2
	PERL_5_8_2:1.1.1.2
	OPENBSD_3_4:1.1.1.2.0.4
	OPENBSD_3_4_BASE:1.1.1.2
	OPENBSD_3_3:1.1.1.2.0.2
	OPENBSD_3_3_BASE:1.1.1.2
	PERL_5_8_0:1.1.1.2
	OPENBSD_3_2:1.1.1.1.0.6
	OPENBSD_3_2_BASE:1.1.1.1
	OPENBSD_3_1:1.1.1.1.0.4
	OPENBSD_3_1_BASE:1.1.1.1
	OPENBSD_3_0:1.1.1.1.0.2
	OPENBSD_3_0_BASE:1.1.1.1
	PERL_5_6_1:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.3
date	2017.02.05.00.32.18;	author afresh1;	state Exp;
branches;
next	1.2;
commitid	cxJ08BvJA9Pt2PTM;

1.2
date	2016.07.03.01.08.03;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	GzHqjSTnBjdF7Wcw;

1.1
date	2001.05.24.18.24.29;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.05.24.18.24.29;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.10.27.22.15.04;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2006.03.28.18.49.16;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2008.09.29.17.18.50;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2009.10.12.18.10.39;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2010.09.24.14.49.06;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2013.03.25.20.09.17;	author sthen;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2014.03.24.14.59.07;	author afresh1;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2014.11.17.20.53.13;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.3
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@=head1 NAME

perlclib - Internal replacements for standard C library functions

=head1 DESCRIPTION

One thing Perl porters should note is that F<perl> doesn't tend to use that
much of the C standard library internally; you'll see very little use of, 
for example, the F<ctype.h> functions in there. This is because Perl
tends to reimplement or abstract standard library functions, so that we
know exactly how they're going to operate.

This is a reference card for people who are familiar with the C library
and who want to do things the Perl way; to tell them which functions
they ought to use instead of the more normal C functions. 

=head2 Conventions

In the following tables:

=over 3

=item C<t>

is a type.

=item C<p>

is a pointer.

=item C<n>

is a number.

=item C<s>

is a string.

=back

C<sv>, C<av>, C<hv>, etc. represent variables of their respective types.

=head2 File Operations

Instead of the F<stdio.h> functions, you should use the Perl abstraction
layer. Instead of C<FILE*> types, you need to be handling C<PerlIO*>
types.  Don't forget that with the new PerlIO layered I/O abstraction 
C<FILE*> types may not even be available. See also the C<perlapio>
documentation for more information about the following functions:

 Instead Of:                 Use:

 stdin                       PerlIO_stdin()
 stdout                      PerlIO_stdout()
 stderr                      PerlIO_stderr()

 fopen(fn, mode)             PerlIO_open(fn, mode)
 freopen(fn, mode, stream)   PerlIO_reopen(fn, mode, perlio) (Dep-
                               recated)
 fflush(stream)              PerlIO_flush(perlio)
 fclose(stream)              PerlIO_close(perlio)

=head2 File Input and Output

 Instead Of:                 Use:

 fprintf(stream, fmt, ...)   PerlIO_printf(perlio, fmt, ...)

 [f]getc(stream)             PerlIO_getc(perlio)
 [f]putc(stream, n)          PerlIO_putc(perlio, n)
 ungetc(n, stream)           PerlIO_ungetc(perlio, n)

Note that the PerlIO equivalents of C<fread> and C<fwrite> are slightly
different from their C library counterparts:

 fread(p, size, n, stream)   PerlIO_read(perlio, buf, numbytes)
 fwrite(p, size, n, stream)  PerlIO_write(perlio, buf, numbytes)

 fputs(s, stream)            PerlIO_puts(perlio, s)

There is no equivalent to C<fgets>; one should use C<sv_gets> instead:

 fgets(s, n, stream)         sv_gets(sv, perlio, append)

=head2 File Positioning

 Instead Of:                 Use:

 feof(stream)                PerlIO_eof(perlio)
 fseek(stream, n, whence)    PerlIO_seek(perlio, n, whence)
 rewind(stream)              PerlIO_rewind(perlio)

 fgetpos(stream, p)          PerlIO_getpos(perlio, sv)
 fsetpos(stream, p)          PerlIO_setpos(perlio, sv)

 ferror(stream)              PerlIO_error(perlio)
 clearerr(stream)            PerlIO_clearerr(perlio)

=head2 Memory Management and String Handling

 Instead Of:                    Use:

 t* p = malloc(n)               Newx(p, n, t)
 t* p = calloc(n, s)            Newxz(p, n, t)
 p = realloc(p, n)              Renew(p, n, t)
 memcpy(dst, src, n)            Copy(src, dst, n, t)
 memmove(dst, src, n)           Move(src, dst, n, t)
 memcpy(dst, src, sizeof(t))    StructCopy(src, dst, t)
 memset(dst, 0, n * sizeof(t))  Zero(dst, n, t)
 memzero(dst, 0)                Zero(dst, n, char)
 free(p)                        Safefree(p)

 strdup(p)                      savepv(p)
 strndup(p, n)                  savepvn(p, n) (Hey, strndup doesn't
                                               exist!)

 strstr(big, little)            instr(big, little)
 strcmp(s1, s2)                 strLE(s1, s2) / strEQ(s1, s2)
                                              / strGT(s1,s2)
 strncmp(s1, s2, n)             strnNE(s1, s2, n) / strnEQ(s1, s2, n)

 memcmp(p1, p2, n)              memNE(p1, p2, n)
 !memcmp(p1, p2, n)             memEQ(p1, p2, n)

Notice the different order of arguments to C<Copy> and C<Move> than used
in C<memcpy> and C<memmove>.

Most of the time, though, you'll want to be dealing with SVs internally
instead of raw C<char *> strings:

 strlen(s)                   sv_len(sv)
 strcpy(dt, src)             sv_setpv(sv, s)
 strncpy(dt, src, n)         sv_setpvn(sv, s, n)
 strcat(dt, src)             sv_catpv(sv, s)
 strncat(dt, src)            sv_catpvn(sv, s)
 sprintf(s, fmt, ...)        sv_setpvf(sv, fmt, ...)

Note also the existence of C<sv_catpvf> and C<sv_vcatpvfn>, combining
concatenation with formatting.

Sometimes instead of zeroing the allocated heap by using Newxz() you
should consider "poisoning" the data.  This means writing a bit
pattern into it that should be illegal as pointers (and floating point
numbers), and also hopefully surprising enough as integers, so that
any code attempting to use the data without forethought will break
sooner rather than later.  Poisoning can be done using the Poison()
macros, which have similar arguments to Zero():

 PoisonWith(dst, n, t, b)    scribble memory with byte b
 PoisonNew(dst, n, t)        equal to PoisonWith(dst, n, t, 0xAB)
 PoisonFree(dst, n, t)       equal to PoisonWith(dst, n, t, 0xEF)
 Poison(dst, n, t)           equal to PoisonFree(dst, n, t)

=head2 Character Class Tests

There are several types of character class tests that Perl implements.
The only ones described here are those that directly correspond to C
library functions that operate on 8-bit characters, but there are
equivalents that operate on wide characters, and UTF-8 encoded strings.
All are more fully described in L<perlapi/Character classification> and
L<perlapi/Character case changing>.

The C library routines listed in the table below return values based on
the current locale.  Use the entries in the final column for that
functionality.  The other two columns always assume a POSIX (or C)
locale.  The entries in the ASCII column are only meaningful for ASCII
inputs, returning FALSE for anything else.  Use these only when you
B<know> that is what you want.  The entries in the Latin1 column assume
that the non-ASCII 8-bit characters are as Unicode defines, them, the
same as ISO-8859-1, often called Latin 1.

 Instead Of:  Use for ASCII:   Use for Latin1:      Use for locale:

 isalnum(c)  isALPHANUMERIC(c) isALPHANUMERIC_L1(c) isALPHANUMERIC_LC(c)
 isalpha(c)  isALPHA(c)        isALPHA_L1(c)        isALPHA_LC(u )
 isascii(c)  isASCII(c)                             isASCII_LC(c)
 isblank(c)  isBLANK(c)        isBLANK_L1(c)        isBLANK_LC(c)
 iscntrl(c)  isCNTRL(c)        isCNTRL_L1(c)        isCNTRL_LC(c)
 isdigit(c)  isDIGIT(c)        isDIGIT_L1(c)        isDIGIT_LC(c)
 isgraph(c)  isGRAPH(c)        isGRAPH_L1(c)        isGRAPH_LC(c)
 islower(c)  isLOWER(c)        isLOWER_L1(c)        isLOWER_LC(c)
 isprint(c)  isPRINT(c)        isPRINT_L1(c)        isPRINT_LC(c)
 ispunct(c)  isPUNCT(c)        isPUNCT_L1(c)        isPUNCT_LC(c)
 isspace(c)  isSPACE(c)        isSPACE_L1(c)        isSPACE_LC(c)
 isupper(c)  isUPPER(c)        isUPPER_L1(c)        isUPPER_LC(c)
 isxdigit(c) isXDIGIT(c)       isXDIGIT_L1(c)       isXDIGIT_LC(c)

 tolower(c)  toLOWER(c)        toLOWER_L1(c)        toLOWER_LC(c)
 toupper(c)  toUPPER(c)                             toUPPER_LC(c)

To emphasize that you are operating only on ASCII characters, you can
append C<_A> to each of the macros in the ASCII column: C<isALPHA_A>,
C<isDIGIT_A>, and so on.

(There is no entry in the Latin1 column for C<isascii> even though there
is an C<isASCII_L1>, which is identical to C<isASCII>;  the
latter name is clearer.  There is no entry in the Latin1 column for
C<toupper> because the result can be non-Latin1.  You have to use
C<toUPPER_uni>, as described in L<perlapi/Character case changing>.)

=head2 F<stdlib.h> functions

 Instead Of:                 Use:

 atof(s)                     Atof(s)
 atoi(s)                     grok_atoUV(s, &uv, &e)
 atol(s)                     grok_atoUV(s, &uv, &e)
 strtod(s, &p)               Nothing.  Just don't use it.
 strtol(s, &p, n)            grok_atoUV(s, &uv, &e)
 strtoul(s, &p, n)           grok_atoUV(s, &uv, &e)

Typical use is to do range checks on C<uv> before casting:

  int i; UV uv; char* end_ptr;
  if (grok_atoUV(input, &uv, &end_ptr)
      && uv <= INT_MAX)
    i = (int)uv;
    ... /* continue parsing from end_ptr */
  } else {
    ... /* parse error: not a decimal integer in range 0 .. MAX_IV */
  }

Notice also the C<grok_bin>, C<grok_hex>, and C<grok_oct> functions in
F<numeric.c> for converting strings representing numbers in the respective
bases into C<NV>s.  Note that grok_atoUV() doesn't handle negative inputs,
or leading whitespace (being purposefully strict).

Note that strtol() and strtoul() may be disguised as Strtol(), Strtoul(),
Atol(), Atoul().  Avoid those, too.

In theory C<Strtol> and C<Strtoul> may not be defined if the machine perl is
built on doesn't actually have strtol and strtoul. But as those 2
functions are part of the 1989 ANSI C spec we suspect you'll find them
everywhere by now.

 int rand()                  double Drand01()
 srand(n)                    { seedDrand01((Rand_seed_t)n);
                               PL_srand_called = TRUE; }

 exit(n)                     my_exit(n)
 system(s)                   Don't. Look at pp_system or use my_popen.

 getenv(s)                   PerlEnv_getenv(s)
 setenv(s, val)              my_setenv(s, val)

=head2 Miscellaneous functions

You should not even B<want> to use F<setjmp.h> functions, but if you
think you do, use the C<JMPENV> stack in F<scope.h> instead.

For C<signal>/C<sigaction>, use C<rsignal(signo, handler)>.

=head1 SEE ALSO

L<perlapi>, L<perlapio>, L<perlguts>

@


1.2
log
@Update to perl 5.20.3

OK bluhm@@
@
text
@d122 3
d160 1
a160 1
All are more fully described in L<perlapi/Character classes> and
d206 2
a207 1
 atol(s)                     Atol(s)
d209 13
a221 2
 strtol(s, &p, n)            Strtol(s, &p, n)
 strtoul(s, &p, n)           Strtoul(s, &p, n)
d225 5
a229 1
bases into C<NV>s.
d241 1
a241 1
 system(s)                   Don't. Look at pp_system or use my_popen
@


1.1
log
@Initial revision
@
text
@d51 1
a51 1
    Instead Of:                 Use:
d53 9
a61 8
    stdin                       PerlIO_stdin()
    stdout                      PerlIO_stdout()
    stderr                      PerlIO_stderr()

    fopen(fn, mode)             PerlIO_open(fn, mode)
    freopen(fn, mode, stream)   PerlIO_reopen(fn, mode, perlio) (Deprecated)
    fflush(stream)              PerlIO_flush(perlio)
    fclose(stream)              PerlIO_close(perlio)
d65 1
a65 1
    Instead Of:                 Use:
d67 1
a67 1
    fprintf(stream, fmt, ...)   PerlIO_printf(perlio, fmt, ...)
d69 3
a71 3
    [f]getc(stream)             PerlIO_getc(perlio)
    [f]putc(stream, n)          PerlIO_putc(perlio, n)
    ungetc(n, stream)           PerlIO_ungetc(perlio, n)
d76 2
a77 2
    fread(p, size, n, stream)   PerlIO_read(perlio, buf, numbytes)
    fwrite(p, size, n, stream)  PerlIO_write(perlio, buf, numbytes)
d79 1
a79 1
    fputs(s, stream)            PerlIO_puts(perlio, s)
d83 1
a83 1
    fgets(s, n, stream)         sv_gets(sv, perlio, append)
d87 1
a87 1
    Instead Of:                 Use:
d89 3
a91 3
    feof(stream)                PerlIO_eof(perlio)
    fseek(stream, n, whence)    PerlIO_seek(perlio, n, whence)
    rewind(stream)              PerlIO_rewind(perlio)
d93 2
a94 2
    fgetpos(stream, p)          PerlIO_getpos(perlio, sv)
    fsetpos(stream, p)          PerlIO_setpos(perlio, sv)
d96 2
a97 2
    ferror(stream)              PerlIO_error(perlio)
    clearerr(stream)            PerlIO_clearerr(perlio)
d101 1
a101 1
    Instead Of:                 Use:
d103 18
a120 14
    t* p = malloc(n)            New(id, p, n, t)
    t* p = calloc(n, s)         Newz(id, p, n, t)
    p = realloc(p, n)           Renew(p, n, t)
    memcpy(dst, src, n)         Copy(src, dst, n, t)
    memmove(dst, src, n)        Move(src, dst, n, t)
    memcpy/*(struct foo *)      StructCopy(src, dst, t)
    free(p)                     Safefree(p)

    strdup(p)                   savepv(p)
    strndup(p, n)               savepvn(p, n) (Hey, strndup doesn't exist!)

    strstr(big, little)         instr(big, little)
    strcmp(s1, s2)              strLE(s1, s2) / strEQ(s1, s2) / strGT(s1,s2)
    strncmp(s1, s2, n)          strnNE(s1, s2, n) / strnEQ(s1, s2, n)
d128 6
a133 6
    strlen(s)                   sv_len(sv)
    strcpy(dt, src)             sv_setpv(sv, s)
    strncpy(dt, src, n)         sv_setpvn(sv, s, n)
    strcat(dt, src)             sv_catpv(sv, s)
    strncat(dt, src)            sv_catpvn(sv, s)
    sprintf(s, fmt, ...)        sv_setpvf(sv, fmt, ...)
d135 1
a135 1
Note also the existence of C<sv_catpvf> and C<sv_catpvfn>, combining
d138 13
d153 44
a196 22
There are two types of character class tests that Perl implements: one
type deals in C<char>s and are thus B<not> Unicode aware (and hence
deprecated unless you B<know> you should use them) and the other type
deal in C<UV>s and know about Unicode properties. In the following
table, C<c> is a C<char>, and C<u> is a Unicode codepoint.

    Instead Of:                 Use:            But better use:

    isalnum(c)                  isALNUM(c)      isALNUM_uni(u)
    isalpha(c)                  isALPHA(c)      isALPHA_uni(u)
    iscntrl(c)                  isCNTRL(c)      isCNTRL_uni(u)
    isdigit(c)                  isDIGIT(c)      isDIGIT_uni(u)
    isgraph(c)                  isGRAPH(c)      isGRAPH_uni(u)
    islower(c)                  isLOWER(c)      isLOWER_uni(u)
    isprint(c)                  isPRINT(c)      isPRINT_uni(u)
    ispunct(c)                  isPUNCT(c)      isPUNCT_uni(u)
    isspace(c)                  isSPACE(c)      isSPACE_uni(u)
    isupper(c)                  isUPPER(c)      isUPPER_uni(u)
    isxdigit(c)                 isXDIGIT(c)     isXDIGIT_uni(u)

    tolower(c)                  toLOWER(c)      toLOWER_uni(u)
    toupper(c)                  toUPPER(c)      toUPPER_uni(u)
d200 1
a200 1
    Instead Of:                 Use: 
d202 5
a206 5
    atof(s)                     Atof(s)
    atol(s)                     Atol(s)
    strtod(s, *p)               Nothing.  Just don't use it.
    strtol(s, *p, n)            Strtol(s, *p, n)
    strtoul(s, *p, n)           Strtoul(s, *p, n)
d208 2
a209 2
Notice also the C<scan_bin>, C<scan_hex>, and C<scan_oct> functions in
F<util.c> for converting strings representing numbers in the respective
d217 3
a219 3
    int rand()                  double Drand01()
    srand(n)                    { seedDrand01((Rand_seed_t)n); 
                                  PL_srand_called = TRUE; }
d221 2
a222 2
    exit(n)                     my_exit(n)
    system(s)                   Don't. Look at pp_system or use my_popen
d224 2
a225 2
    getenv(s)                   PerlEnv_getenv(s)
    setenv(s, val)              my_putenv(s, val)
d236 1
a236 1
C<perlapi>, C<perlapio>, C<perlguts>
@


1.1.1.1
log
@stock perl 5.6.1
@
text
@@


1.1.1.2
log
@stock perl 5.8.0 from CPAN
@
text
@d100 1
a100 1
    Instead Of:                 	Use:
d102 7
a108 9
    t* p = malloc(n)            	New(id, p, n, t)
    t* p = calloc(n, s)         	Newz(id, p, n, t)
    p = realloc(p, n)           	Renew(p, n, t)
    memcpy(dst, src, n)         	Copy(src, dst, n, t)
    memmove(dst, src, n)        	Move(src, dst, n, t)
    memcpy/*(struct foo *)      	StructCopy(src, dst, t)
    memset(dst, 0, n * sizeof(t))	Zero(dst, n, t)
    memzero(dst, 0)			Zero(dst, n, char)
    free(p)             	        Safefree(p)
d130 1
a130 1
Note also the existence of C<sv_catpvf> and C<sv_vcatpvfn>, combining
a132 10
Sometimes instead of zeroing the allocated heap by using Newz() you
should consider "poisoning" the data.  This means writing a bit
pattern into it that should be illegal as pointers (and floating point
numbers), and also hopefully surprising enough as integers, so that
any code attempting to use the data without forethought will break
sooner rather than later.  Poisoning can be done using the Poison()
macro, which has similar arguments as Zero():

    Poison(dst, n, t)

d168 2
a169 2
Notice also the C<grok_bin>, C<grok_hex>, and C<grok_oct> functions in
F<numeric.c> for converting strings representing numbers in the respective
@


1.1.1.3
log
@perl 5.8.8 import
@
text
@d102 2
a103 2
    t* p = malloc(n)            	Newx(id, p, n, t)
    t* p = calloc(n, s)         	Newxz(id, p, n, t)
d135 1
a135 1
Sometimes instead of zeroing the allocated heap by using Newxz() you
@


1.1.1.4
log
@import perl 5.10.0 from CPAN
@
text
@d141 1
a141 1
macros, which have similar arguments as Zero():
d143 1
a143 4
    PoisonWith(dst, n, t, b)    scribble memory with byte b
    PoisonNew(dst, n, t)        equal to PoisonWith(dst, n, t, 0xAB)
    PoisonFree(dst, n, t)       equal to PoisonWith(dst, n, t, 0xEF)
    Poison(dst, n, t)           equal to PoisonFree(dst, n, t)
@


1.1.1.5
log
@import perl 5.10.1
@
text
@d107 1
a107 1
    memcpy(dst, src, sizeof(t))		StructCopy(src, dst, t)
d179 3
a181 3
    strtod(s, &p)               Nothing.  Just don't use it.
    strtol(s, &p, n)            Strtol(s, &p, n)
    strtoul(s, &p, n)           Strtoul(s, &p, n)
@


1.1.1.6
log
@Perl 5.12.2 from CPAN
@
text
@d211 1
a211 1
L<perlapi>, L<perlapio>, L<perlguts>
@


1.1.1.7
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d141 1
a141 1
macros, which have similar arguments to Zero():
@


1.1.1.8
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d102 2
a103 2
    t* p = malloc(n)            	Newx(p, n, t)
    t* p = calloc(n, s)         	Newxz(p, n, t)
@


1.1.1.9
log
@Import perl-5.20.1
@
text
@d51 1
a51 1
 Instead Of:                 Use:
d53 8
a60 9
 stdin                       PerlIO_stdin()
 stdout                      PerlIO_stdout()
 stderr                      PerlIO_stderr()

 fopen(fn, mode)             PerlIO_open(fn, mode)
 freopen(fn, mode, stream)   PerlIO_reopen(fn, mode, perlio) (Dep-
                               recated)
 fflush(stream)              PerlIO_flush(perlio)
 fclose(stream)              PerlIO_close(perlio)
d64 1
a64 1
 Instead Of:                 Use:
d66 1
a66 1
 fprintf(stream, fmt, ...)   PerlIO_printf(perlio, fmt, ...)
d68 3
a70 3
 [f]getc(stream)             PerlIO_getc(perlio)
 [f]putc(stream, n)          PerlIO_putc(perlio, n)
 ungetc(n, stream)           PerlIO_ungetc(perlio, n)
d75 2
a76 2
 fread(p, size, n, stream)   PerlIO_read(perlio, buf, numbytes)
 fwrite(p, size, n, stream)  PerlIO_write(perlio, buf, numbytes)
d78 1
a78 1
 fputs(s, stream)            PerlIO_puts(perlio, s)
d82 1
a82 1
 fgets(s, n, stream)         sv_gets(sv, perlio, append)
d86 1
a86 1
 Instead Of:                 Use:
d88 3
a90 3
 feof(stream)                PerlIO_eof(perlio)
 fseek(stream, n, whence)    PerlIO_seek(perlio, n, whence)
 rewind(stream)              PerlIO_rewind(perlio)
d92 2
a93 2
 fgetpos(stream, p)          PerlIO_getpos(perlio, sv)
 fsetpos(stream, p)          PerlIO_setpos(perlio, sv)
d95 2
a96 2
 ferror(stream)              PerlIO_error(perlio)
 clearerr(stream)            PerlIO_clearerr(perlio)
d100 1
a100 1
 Instead Of:                    Use:
d102 16
a117 18
 t* p = malloc(n)               Newx(p, n, t)
 t* p = calloc(n, s)            Newxz(p, n, t)
 p = realloc(p, n)              Renew(p, n, t)
 memcpy(dst, src, n)            Copy(src, dst, n, t)
 memmove(dst, src, n)           Move(src, dst, n, t)
 memcpy(dst, src, sizeof(t))    StructCopy(src, dst, t)
 memset(dst, 0, n * sizeof(t))  Zero(dst, n, t)
 memzero(dst, 0)                Zero(dst, n, char)
 free(p)                        Safefree(p)

 strdup(p)                      savepv(p)
 strndup(p, n)                  savepvn(p, n) (Hey, strndup doesn't
                                               exist!)

 strstr(big, little)            instr(big, little)
 strcmp(s1, s2)                 strLE(s1, s2) / strEQ(s1, s2)
                                              / strGT(s1,s2)
 strncmp(s1, s2, n)             strnNE(s1, s2, n) / strnEQ(s1, s2, n)
d125 6
a130 6
 strlen(s)                   sv_len(sv)
 strcpy(dt, src)             sv_setpv(sv, s)
 strncpy(dt, src, n)         sv_setpvn(sv, s, n)
 strcat(dt, src)             sv_catpv(sv, s)
 strncat(dt, src)            sv_catpvn(sv, s)
 sprintf(s, fmt, ...)        sv_setpvf(sv, fmt, ...)
d143 4
a146 4
 PoisonWith(dst, n, t, b)    scribble memory with byte b
 PoisonNew(dst, n, t)        equal to PoisonWith(dst, n, t, 0xAB)
 PoisonFree(dst, n, t)       equal to PoisonWith(dst, n, t, 0xEF)
 Poison(dst, n, t)           equal to PoisonFree(dst, n, t)
d150 22
a171 44
There are several types of character class tests that Perl implements.
The only ones described here are those that directly correspond to C
library functions that operate on 8-bit characters, but there are
equivalents that operate on wide characters, and UTF-8 encoded strings.
All are more fully described in L<perlapi/Character classes> and
L<perlapi/Character case changing>.

The C library routines listed in the table below return values based on
the current locale.  Use the entries in the final column for that
functionality.  The other two columns always assume a POSIX (or C)
locale.  The entries in the ASCII column are only meaningful for ASCII
inputs, returning FALSE for anything else.  Use these only when you
B<know> that is what you want.  The entries in the Latin1 column assume
that the non-ASCII 8-bit characters are as Unicode defines, them, the
same as ISO-8859-1, often called Latin 1.

 Instead Of:  Use for ASCII:   Use for Latin1:      Use for locale:

 isalnum(c)  isALPHANUMERIC(c) isALPHANUMERIC_L1(c) isALPHANUMERIC_LC(c)
 isalpha(c)  isALPHA(c)        isALPHA_L1(c)        isALPHA_LC(u )
 isascii(c)  isASCII(c)                             isASCII_LC(c)
 isblank(c)  isBLANK(c)        isBLANK_L1(c)        isBLANK_LC(c)
 iscntrl(c)  isCNTRL(c)        isCNTRL_L1(c)        isCNTRL_LC(c)
 isdigit(c)  isDIGIT(c)        isDIGIT_L1(c)        isDIGIT_LC(c)
 isgraph(c)  isGRAPH(c)        isGRAPH_L1(c)        isGRAPH_LC(c)
 islower(c)  isLOWER(c)        isLOWER_L1(c)        isLOWER_LC(c)
 isprint(c)  isPRINT(c)        isPRINT_L1(c)        isPRINT_LC(c)
 ispunct(c)  isPUNCT(c)        isPUNCT_L1(c)        isPUNCT_LC(c)
 isspace(c)  isSPACE(c)        isSPACE_L1(c)        isSPACE_LC(c)
 isupper(c)  isUPPER(c)        isUPPER_L1(c)        isUPPER_LC(c)
 isxdigit(c) isXDIGIT(c)       isXDIGIT_L1(c)       isXDIGIT_LC(c)

 tolower(c)  toLOWER(c)        toLOWER_L1(c)        toLOWER_LC(c)
 toupper(c)  toUPPER(c)                             toUPPER_LC(c)

To emphasize that you are operating only on ASCII characters, you can
append C<_A> to each of the macros in the ASCII column: C<isALPHA_A>,
C<isDIGIT_A>, and so on.

(There is no entry in the Latin1 column for C<isascii> even though there
is an C<isASCII_L1>, which is identical to C<isASCII>;  the
latter name is clearer.  There is no entry in the Latin1 column for
C<toupper> because the result can be non-Latin1.  You have to use
C<toUPPER_uni>, as described in L<perlapi/Character case changing>.)
d175 1
a175 1
 Instead Of:                 Use:
d177 5
a181 5
 atof(s)                     Atof(s)
 atol(s)                     Atol(s)
 strtod(s, &p)               Nothing.  Just don't use it.
 strtol(s, &p, n)            Strtol(s, &p, n)
 strtoul(s, &p, n)           Strtoul(s, &p, n)
d192 3
a194 3
 int rand()                  double Drand01()
 srand(n)                    { seedDrand01((Rand_seed_t)n);
                               PL_srand_called = TRUE; }
d196 2
a197 2
 exit(n)                     my_exit(n)
 system(s)                   Don't. Look at pp_system or use my_popen
d199 2
a200 2
 getenv(s)                   PerlEnv_getenv(s)
 setenv(s, val)              my_putenv(s, val)
@


