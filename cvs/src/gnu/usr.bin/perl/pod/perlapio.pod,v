head	1.10;
access;
symbols
	OPENBSD_6_2:1.10.0.2
	OPENBSD_6_2_BASE:1.10
	PERL_5_24_2:1.1.1.9
	OPENBSD_6_1:1.10.0.4
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.9.0.10
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.4
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.9.0.6
	OPENBSD_5_8_BASE:1.9
	PERL_5_20_2:1.1.1.8
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	PERL_5_20_1:1.1.1.8
	OPENBSD_5_6:1.8.0.8
	OPENBSD_5_6_BASE:1.8
	PERL_5_18_2:1.1.1.7
	PERL:1.1.1
	OPENBSD_5_5:1.8.0.6
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	PERL_5_16_3:1.1.1.7
	OPENBSD_5_3:1.7.0.14
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.12
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.10
	OPENBSD_5_0:1.7.0.8
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.6
	OPENBSD_4_9_BASE:1.7
	PERL_5_12_2:1.1.1.6
	OPENBSD_4_8:1.7.0.4
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.2
	OPENBSD_4_7_BASE:1.7
	PERL_5_10_1:1.1.1.6
	OPENBSD_4_6:1.6.0.16
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.12
	OPENBSD_4_5_BASE:1.6
	PERL_5_10_0:1.1.1.5
	OPENBSD_4_4:1.6.0.10
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.8
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.6
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.4
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.2
	OPENBSD_4_0_BASE:1.6
	PERL_5_8_8:1.1.1.5
	OPENBSD_3_9:1.5.0.6
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.4
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.2
	OPENBSD_3_7_BASE:1.5
	PERL_5_8_6:1.1.1.4
	OPENBSD_3_6:1.4.0.4
	OPENBSD_3_6_BASE:1.4
	PERL_5_8_5:1.1.1.3
	PERL_5_8_3:1.1.1.3
	OPENBSD_3_5:1.4.0.2
	OPENBSD_3_5_BASE:1.4
	PERL_5_8_2:1.1.1.3
	OPENBSD_3_4:1.3.0.4
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.3.0.2
	OPENBSD_3_3_BASE:1.3
	PERL_5_8_0:1.1.1.2
	OPENBSD_3_2:1.2.0.14
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.12
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.10
	OPENBSD_3_0_BASE:1.2
	PERL_5_6_1:1.1.1.1
	OPENBSD_2_9:1.2.0.8
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.6
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.4
	OPENBSD_2_7_BASE:1.2
	PERL_5_6_0:1.1.1.1
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	PERL_500503:1.1.1.1
	CPAN:1.1.1
	OPENBSD_2_5:1.1.0.6
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.4
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.2
	OPENBSD_2_3_BASE:1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.10
date	2017.02.05.00.32.18;	author afresh1;	state Exp;
branches;
next	1.9;
commitid	cxJ08BvJA9Pt2PTM;

1.9
date	2014.11.17.20.57.07;	author afresh1;	state Exp;
branches;
next	1.8;
commitid	QP75iYx42Uo7mMxO;

1.8
date	2013.03.25.20.40.58;	author sthen;	state Exp;
branches;
next	1.7;

1.7
date	2009.10.12.18.24.47;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2006.03.28.19.23.09;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2005.01.15.21.30.35;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2003.12.03.03.02.43;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2002.10.27.22.25.32;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	99.04.29.22.52.07;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	97.11.30.07.58.58;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.29.22.40.33;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.10.27.22.15.03;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.12.03.02.44.19;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2005.01.15.21.17.47;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2006.03.28.18.49.15;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2009.10.12.18.10.38;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2013.03.25.20.09.16;	author sthen;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2014.11.17.20.53.13;	author afresh1;	state Exp;
branches;
next	1.1.1.9;
commitid	B31cAbBIXiCqnL97;

1.1.1.9
date	2017.08.14.13.46.19;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@perl 5.004_04
@


1.10
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@=head1 NAME

perlapio - perl's IO abstraction interface.

=head1 SYNOPSIS

  #define PERLIO_NOT_STDIO 0    /* For co-existence with stdio only */
  #include <perlio.h>           /* Usually via #include <perl.h> */

  PerlIO *PerlIO_stdin(void);
  PerlIO *PerlIO_stdout(void);
  PerlIO *PerlIO_stderr(void);

  PerlIO *PerlIO_open(const char *path,const char *mode);
  PerlIO *PerlIO_fdopen(int fd, const char *mode);
  PerlIO *PerlIO_reopen(const char *path, /* deprecated */
          const char *mode, PerlIO *old);
  int     PerlIO_close(PerlIO *f);

  int     PerlIO_stdoutf(const char *fmt,...)
  int     PerlIO_puts(PerlIO *f,const char *string);
  int     PerlIO_putc(PerlIO *f,int ch);
  SSize_t PerlIO_write(PerlIO *f,const void *buf,size_t numbytes);
  int     PerlIO_printf(PerlIO *f, const char *fmt,...);
  int     PerlIO_vprintf(PerlIO *f, const char *fmt, va_list args);
  int     PerlIO_flush(PerlIO *f);

  int     PerlIO_eof(PerlIO *f);
  int     PerlIO_error(PerlIO *f);
  void    PerlIO_clearerr(PerlIO *f);

  int     PerlIO_getc(PerlIO *d);
  int     PerlIO_ungetc(PerlIO *f,int ch);
  SSize_t PerlIO_read(PerlIO *f, void *buf, size_t numbytes);

  int     PerlIO_fileno(PerlIO *f);

  void    PerlIO_setlinebuf(PerlIO *f);

  Off_t   PerlIO_tell(PerlIO *f);
  int     PerlIO_seek(PerlIO *f, Off_t offset, int whence);
  void    PerlIO_rewind(PerlIO *f);

  int     PerlIO_getpos(PerlIO *f, SV *save);    /* prototype changed */
  int     PerlIO_setpos(PerlIO *f, SV *saved);   /* prototype changed */

  int     PerlIO_fast_gets(PerlIO *f);
  int     PerlIO_has_cntptr(PerlIO *f);
  SSize_t PerlIO_get_cnt(PerlIO *f);
  char   *PerlIO_get_ptr(PerlIO *f);
  void    PerlIO_set_ptrcnt(PerlIO *f, char *ptr, SSize_t count);

  int     PerlIO_canset_cnt(PerlIO *f);              /* deprecated */
  void    PerlIO_set_cnt(PerlIO *f, int count);      /* deprecated */

  int     PerlIO_has_base(PerlIO *f);
  char   *PerlIO_get_base(PerlIO *f);
  SSize_t PerlIO_get_bufsiz(PerlIO *f);

  PerlIO *PerlIO_importFILE(FILE *stdio, const char *mode);
  FILE   *PerlIO_exportFILE(PerlIO *f, int flags);
  FILE   *PerlIO_findFILE(PerlIO *f);
  void    PerlIO_releaseFILE(PerlIO *f,FILE *stdio);

  int     PerlIO_apply_layers(PerlIO *f, const char *mode,
                                                    const char *layers);
  int     PerlIO_binmode(PerlIO *f, int ptype, int imode,
                                                    const char *layers);
  void    PerlIO_debug(const char *fmt,...)

=head1 DESCRIPTION

Perl's source code, and extensions that want maximum portability,
should use the above functions instead of those defined in ANSI C's
I<stdio.h>.  The perl headers (in particular "perlio.h") will
C<#define> them to the I/O mechanism selected at Configure time.

The functions are modeled on those in I<stdio.h>, but parameter order
has been "tidied up a little".

C<PerlIO *> takes the place of FILE *. Like FILE * it should be
treated as opaque (it is probably safe to assume it is a pointer to
something).

There are currently three implementations:

=over 4

=item 1. USE_STDIO

All above are #define'd to stdio functions or are trivial wrapper
functions which call stdio. In this case I<only> PerlIO * is a FILE *.
This has been the default implementation since the abstraction was
introduced in perl5.003_02.

=item 2. USE_PERLIO

Introduced just after perl5.7.0, this is a re-implementation of the
above abstraction which allows perl more control over how IO is done
as it decouples IO from the way the operating system and C library
choose to do things. For USE_PERLIO PerlIO * has an extra layer of
indirection - it is a pointer-to-a-pointer.  This allows the PerlIO *
to remain with a known value while swapping the implementation around
underneath I<at run time>. In this case all the above are true (but
very simple) functions which call the underlying implementation.

This is the only implementation for which C<PerlIO_apply_layers()>
does anything "interesting".

The USE_PERLIO implementation is described in L<perliol>.

=back

Because "perlio.h" is a thin layer (for efficiency) the semantics of
these functions are somewhat dependent on the underlying implementation.
Where these variations are understood they are noted below.

Unless otherwise noted, functions return 0 on success, or a negative
value (usually C<EOF> which is usually -1) and set C<errno> on error.

=over 4

=item B<PerlIO_stdin()>, B<PerlIO_stdout()>, B<PerlIO_stderr()>

Use these rather than C<stdin>, C<stdout>, C<stderr>. They are written
to look like "function calls" rather than variables because this makes
it easier to I<make them> function calls if platform cannot export data
to loaded modules, or if (say) different "threads" might have different
values.

=item B<PerlIO_open(path, mode)>, B<PerlIO_fdopen(fd,mode)>

These correspond to fopen()/fdopen() and the arguments are the same.
Return C<NULL> and set C<errno> if there is an error.  There may be an
implementation limit on the number of open handles, which may be lower
than the limit on the number of open files - C<errno> may not be set
when C<NULL> is returned if this limit is exceeded.

=item B<PerlIO_reopen(path,mode,f)>

While this currently exists in all three implementations perl itself
does not use it. I<As perl does not use it, it is not well tested.>

Perl prefers to C<dup> the new low-level descriptor to the descriptor
used by the existing PerlIO. This may become the behaviour of this
function in the future.

=item B<PerlIO_printf(f,fmt,...)>, B<PerlIO_vprintf(f,fmt,a)>

These are fprintf()/vfprintf() equivalents.

=item B<PerlIO_stdoutf(fmt,...)>

This is printf() equivalent. printf is #defined to this function,
so it is (currently) legal to use C<printf(fmt,...)> in perl sources.

=item B<PerlIO_read(f,buf,count)>, B<PerlIO_write(f,buf,count)>

These correspond functionally to fread() and fwrite() but the
arguments and return values are different.  The PerlIO_read() and
PerlIO_write() signatures have been modeled on the more sane low level
read() and write() functions instead: The "file" argument is passed
first, there is only one "count", and the return value can distinguish
between error and C<EOF>.

Returns a byte count if successful (which may be zero or
positive), returns negative value and sets C<errno> on error.
Depending on implementation C<errno> may be C<EINTR> if operation was
interrupted by a signal.

=item B<PerlIO_close(f)>

Depending on implementation C<errno> may be C<EINTR> if operation was
interrupted by a signal.

=item B<PerlIO_puts(f,s)>, B<PerlIO_putc(f,c)>

These correspond to fputs() and fputc().
Note that arguments have been revised to have "file" first.

=item B<PerlIO_ungetc(f,c)>

This corresponds to ungetc().  Note that arguments have been revised
to have "file" first.  Arranges that next read operation will return
the byte B<c>.  Despite the implied "character" in the name only
values in the range 0..0xFF are defined. Returns the byte B<c> on
success or -1 (C<EOF>) on error.  The number of bytes that can be
"pushed back" may vary, only 1 character is certain, and then only if
it is the last character that was read from the handle.

=item B<PerlIO_getc(f)>

This corresponds to getc().
Despite the c in the name only byte range 0..0xFF is supported.
Returns the character read or -1 (C<EOF>) on error.

=item B<PerlIO_eof(f)>

This corresponds to feof().  Returns a true/false indication of
whether the handle is at end of file.  For terminal devices this may
or may not be "sticky" depending on the implementation.  The flag is
cleared by PerlIO_seek(), or PerlIO_rewind().

=item B<PerlIO_error(f)>

This corresponds to ferror().  Returns a true/false indication of
whether there has been an IO error on the handle.

=item B<PerlIO_fileno(f)>

This corresponds to fileno(), note that on some platforms, the meaning
of "fileno" may not match Unix. Returns -1 if the handle has no open
descriptor associated with it.

=item B<PerlIO_clearerr(f)>

This corresponds to clearerr(), i.e., clears 'error' and (usually)
'eof' flags for the "stream". Does not return a value.

=item B<PerlIO_flush(f)>

This corresponds to fflush().  Sends any buffered write data to the
underlying file.  If called with C<NULL> this may flush all open
streams (or core dump with some USE_STDIO implementations).  Calling
on a handle open for read only, or on which last operation was a read
of some kind may lead to undefined behaviour on some USE_STDIO
implementations.  The USE_PERLIO (layers) implementation tries to
behave better: it flushes all open streams when passed C<NULL>, and
attempts to retain data on read streams either in the buffer or by
seeking the handle to the current logical position.

=item B<PerlIO_seek(f,offset,whence)>

This corresponds to fseek().  Sends buffered write data to the
underlying file, or discards any buffered read data, then positions
the file descriptor as specified by B<offset> and B<whence> (sic).
This is the correct thing to do when switching between read and write
on the same handle (see issues with PerlIO_flush() above).  Offset is
of type C<Off_t> which is a perl Configure value which may not be same
as stdio's C<off_t>.

=item B<PerlIO_tell(f)>

This corresponds to ftell().  Returns the current file position, or
(Off_t) -1 on error.  May just return value system "knows" without
making a system call or checking the underlying file descriptor (so
use on shared file descriptors is not safe without a
PerlIO_seek()). Return value is of type C<Off_t> which is a perl
Configure value which may not be same as stdio's C<off_t>.

=item B<PerlIO_getpos(f,p)>, B<PerlIO_setpos(f,p)>

These correspond (loosely) to fgetpos() and fsetpos(). Rather than
stdio's Fpos_t they expect a "Perl Scalar Value" to be passed. What is
stored there should be considered opaque. The layout of the data may
vary from handle to handle.  When not using stdio or if platform does
not have the stdio calls then they are implemented in terms of
PerlIO_tell() and PerlIO_seek().

=item B<PerlIO_rewind(f)>

This corresponds to rewind(). It is usually defined as being

    PerlIO_seek(f,(Off_t)0L, SEEK_SET);
    PerlIO_clearerr(f);

=item B<PerlIO_tmpfile()>

This corresponds to tmpfile(), i.e., returns an anonymous PerlIO or
NULL on error.  The system will attempt to automatically delete the
file when closed.  On Unix the file is usually C<unlink>-ed just after
it is created so it does not matter how it gets closed. On other
systems the file may only be deleted if closed via PerlIO_close()
and/or the program exits via C<exit>.  Depending on the implementation
there may be "race conditions" which allow other processes access to
the file, though in general it will be safer in this regard than
ad. hoc. schemes.

=item B<PerlIO_setlinebuf(f)>

This corresponds to setlinebuf().  Does not return a value. What
constitutes a "line" is implementation dependent but usually means
that writing "\n" flushes the buffer.  What happens with things like
"this\nthat" is uncertain.  (Perl core uses it I<only> when "dumping";
it has nothing to do with $| auto-flush.)

=back

=head2 Co-existence with stdio

There is outline support for co-existence of PerlIO with stdio.
Obviously if PerlIO is implemented in terms of stdio there is no
problem. However in other cases then mechanisms must exist to create a
FILE * which can be passed to library code which is going to use stdio
calls.

The first step is to add this line:

   #define PERLIO_NOT_STDIO 0

I<before> including any perl header files. (This will probably become
the default at some point).  That prevents "perlio.h" from attempting
to #define stdio functions onto PerlIO functions.

XS code is probably better using "typemap" if it expects FILE *
arguments.  The standard typemap will be adjusted to comprehend any
changes in this area.

=over 4

=item B<PerlIO_importFILE(f,mode)>

Used to get a PerlIO * from a FILE *.

The mode argument should be a string as would be passed to
fopen/PerlIO_open.  If it is NULL then - for legacy support - the code
will (depending upon the platform and the implementation) either
attempt to empirically determine the mode in which I<f> is open, or
use "r+" to indicate a read/write stream.

Once called the FILE * should I<ONLY> be closed by calling
C<PerlIO_close()> on the returned PerlIO *.

The PerlIO is set to textmode. Use PerlIO_binmode if this is
not the desired mode.

This is B<not> the reverse of PerlIO_exportFILE().

=item B<PerlIO_exportFILE(f,mode)>

Given a PerlIO * create a 'native' FILE * suitable for passing to code
expecting to be compiled and linked with ANSI C I<stdio.h>.  The mode
argument should be a string as would be passed to fopen/PerlIO_open.
If it is NULL then - for legacy support - the FILE * is opened in same
mode as the PerlIO *.

The fact that such a FILE * has been 'exported' is recorded, (normally
by pushing a new :stdio "layer" onto the PerlIO *), which may affect
future PerlIO operations on the original PerlIO *.  You should not
call C<fclose()> on the file unless you call C<PerlIO_releaseFILE()>
to disassociate it from the PerlIO *.  (Do not use PerlIO_importFILE()
for doing the disassociation.)

Calling this function repeatedly will create a FILE * on each call
(and will push an :stdio layer each time as well).

=item B<PerlIO_releaseFILE(p,f)>

Calling PerlIO_releaseFILE informs PerlIO that all use of FILE * is
complete. It is removed from the list of 'exported' FILE *s, and the
associated PerlIO * should revert to its original behaviour.

Use this to disassociate a file from a PerlIO * that was associated
using PerlIO_exportFILE().

=item B<PerlIO_findFILE(f)>

Returns a native FILE * used by a stdio layer. If there is none, it
will create one with PerlIO_exportFILE. In either case the FILE *
should be considered as belonging to PerlIO subsystem and should
only be closed by calling C<PerlIO_close()>.


=back

=head2 "Fast gets" Functions

In addition to standard-like API defined so far above there is an
"implementation" interface which allows perl to get at internals of
PerlIO.  The following calls correspond to the various FILE_xxx macros
determined by Configure - or their equivalent in other
implementations. This section is really of interest to only those
concerned with detailed perl-core behaviour, implementing a PerlIO
mapping or writing code which can make use of the "read ahead" that
has been done by the IO system in the same way perl does. Note that
any code that uses these interfaces must be prepared to do things the
traditional way if a handle does not support them.

=over 4

=item B<PerlIO_fast_gets(f)>

Returns true if implementation has all the interfaces required to
allow perl's C<sv_gets> to "bypass" normal IO mechanism.  This can
vary from handle to handle.

  PerlIO_fast_gets(f) = PerlIO_has_cntptr(f) && \
                        PerlIO_canset_cnt(f) && \
                        'Can set pointer into buffer'

=item B<PerlIO_has_cntptr(f)>

Implementation can return pointer to current position in the "buffer"
and a count of bytes available in the buffer.  Do not use this - use
PerlIO_fast_gets.

=item B<PerlIO_get_cnt(f)>

Return count of readable bytes in the buffer. Zero or negative return
means no more bytes available.

=item B<PerlIO_get_ptr(f)>

Return pointer to next readable byte in buffer, accessing via the
pointer (dereferencing) is only safe if PerlIO_get_cnt() has returned
a positive value.  Only positive offsets up to value returned by
PerlIO_get_cnt() are allowed.

=item B<PerlIO_set_ptrcnt(f,p,c)>

Set pointer into buffer, and a count of bytes still in the
buffer. Should be used only to set pointer to within range implied by
previous calls to C<PerlIO_get_ptr> and C<PerlIO_get_cnt>. The two
values I<must> be consistent with each other (implementation may only
use one or the other or may require both).

=item B<PerlIO_canset_cnt(f)>

Implementation can adjust its idea of number of bytes in the buffer.
Do not use this - use PerlIO_fast_gets.

=item B<PerlIO_set_cnt(f,c)>

Obscure - set count of bytes in the buffer. Deprecated.  Only usable
if PerlIO_canset_cnt() returns true.  Currently used in only doio.c to
force count less than -1 to -1.  Perhaps should be PerlIO_set_empty or
similar.  This call may actually do nothing if "count" is deduced from
pointer and a "limit".  Do not use this - use PerlIO_set_ptrcnt().

=item B<PerlIO_has_base(f)>

Returns true if implementation has a buffer, and can return pointer
to whole buffer and its size. Used by perl for B<-T> / B<-B> tests.
Other uses would be very obscure...

=item B<PerlIO_get_base(f)>

Return I<start> of buffer. Access only positive offsets in the buffer
up to the value returned by PerlIO_get_bufsiz().

=item B<PerlIO_get_bufsiz(f)>

Return the I<total number of bytes> in the buffer, this is neither the
number that can be read, nor the amount of memory allocated to the
buffer. Rather it is what the operating system and/or implementation
happened to C<read()> (or whatever) last time IO was requested.

=back

=head2 Other Functions

=over 4

=item PerlIO_apply_layers(f,mode,layers)

The new interface to the USE_PERLIO implementation. The layers ":crlf"
and ":raw" are only ones allowed for other implementations and those
are silently ignored. (As of perl5.8 ":raw" is deprecated.)  Use
PerlIO_binmode() below for the portable case.

=item PerlIO_binmode(f,ptype,imode,layers)

The hook used by perl's C<binmode> operator.
B<ptype> is perl's character for the kind of IO:

=over 8

=item 'E<lt>' read

=item 'E<gt>' write

=item '+' read/write

=back

B<imode> is C<O_BINARY> or C<O_TEXT>.

B<layers> is a string of layers to apply, only ":crlf" makes sense in
the non USE_PERLIO case. (As of perl5.8 ":raw" is deprecated in favour
of passing NULL.)

Portable cases are:

    PerlIO_binmode(f,ptype,O_BINARY,NULL);
and
    PerlIO_binmode(f,ptype,O_TEXT,":crlf");

On Unix these calls probably have no effect whatsoever.  Elsewhere
they alter "\n" to CR,LF translation and possibly cause a special text
"end of file" indicator to be written or honoured on read. The effect
of making the call after doing any IO to the handle depends on the
implementation. (It may be ignored, affect any data which is already
buffered as well, or only apply to subsequent data.)

=item PerlIO_debug(fmt,...)

PerlIO_debug is a printf()-like function which can be used for
debugging.  No return value. Its main use is inside PerlIO where using
real printf, warn() etc. would recursively call PerlIO and be a
problem.

PerlIO_debug writes to the file named by $ENV{'PERLIO_DEBUG'} or defaults
to stderr if the environment variable is not defined. Typical
use might be

  Bourne shells (sh, ksh, bash, zsh, ash, ...):
   PERLIO_DEBUG=/tmp/perliodebug.log ./perl -Di somescript some args

  Csh/Tcsh:
   setenv PERLIO_DEBUG /tmp/perliodebug.log
   ./perl -Di somescript some args

  If you have the "env" utility:
   env PERLIO_DEBUG=/tmp/perliodebug.log ./perl -Di somescript args

  Win32:
   set PERLIO_DEBUG=perliodebug.log
   perl -Di somescript some args

On a Perl built without C<-DDEBUGGING>, or when the C<-Di> command-line switch
is not specified, or under taint, PerlIO_debug() is a no-op.

=back
@


1.9
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d7 2
a8 2
    #define PERLIO_NOT_STDIO 0    /* For co-existence with stdio only */
    #include <perlio.h>           /* Usually via #include <perl.h> */
d10 60
a69 57
    PerlIO *PerlIO_stdin(void);
    PerlIO *PerlIO_stdout(void);
    PerlIO *PerlIO_stderr(void);

    PerlIO *PerlIO_open(const char *path,const char *mode);
    PerlIO *PerlIO_fdopen(int fd, const char *mode);
    PerlIO *PerlIO_reopen(const char *path, const char *mode, PerlIO *old);  /* deprecated */
    int     PerlIO_close(PerlIO *f);

    int     PerlIO_stdoutf(const char *fmt,...)
    int     PerlIO_puts(PerlIO *f,const char *string);
    int     PerlIO_putc(PerlIO *f,int ch);
    SSize_t PerlIO_write(PerlIO *f,const void *buf,size_t numbytes);
    int     PerlIO_printf(PerlIO *f, const char *fmt,...);
    int     PerlIO_vprintf(PerlIO *f, const char *fmt, va_list args);
    int     PerlIO_flush(PerlIO *f);

    int     PerlIO_eof(PerlIO *f);
    int     PerlIO_error(PerlIO *f);
    void    PerlIO_clearerr(PerlIO *f);

    int     PerlIO_getc(PerlIO *d);
    int     PerlIO_ungetc(PerlIO *f,int ch);
    SSize_t PerlIO_read(PerlIO *f, void *buf, size_t numbytes);

    int     PerlIO_fileno(PerlIO *f);

    void    PerlIO_setlinebuf(PerlIO *f);

    Off_t   PerlIO_tell(PerlIO *f);
    int     PerlIO_seek(PerlIO *f, Off_t offset, int whence);
    void    PerlIO_rewind(PerlIO *f);

    int     PerlIO_getpos(PerlIO *f, SV *save);        /* prototype changed */
    int     PerlIO_setpos(PerlIO *f, SV *saved);       /* prototype changed */

    int     PerlIO_fast_gets(PerlIO *f);
    int     PerlIO_has_cntptr(PerlIO *f);
    SSize_t PerlIO_get_cnt(PerlIO *f);
    char   *PerlIO_get_ptr(PerlIO *f);
    void    PerlIO_set_ptrcnt(PerlIO *f, char *ptr, SSize_t count);

    int     PerlIO_canset_cnt(PerlIO *f);              /* deprecated */
    void    PerlIO_set_cnt(PerlIO *f, int count);      /* deprecated */

    int     PerlIO_has_base(PerlIO *f);
    char   *PerlIO_get_base(PerlIO *f);
    SSize_t PerlIO_get_bufsiz(PerlIO *f);

    PerlIO *PerlIO_importFILE(FILE *stdio, const char *mode);
    FILE   *PerlIO_exportFILE(PerlIO *f, int flags);
    FILE   *PerlIO_findFILE(PerlIO *f);
    void    PerlIO_releaseFILE(PerlIO *f,FILE *stdio);

    int     PerlIO_apply_layers(PerlIO *f, const char *mode, const char *layers);
    int     PerlIO_binmode(PerlIO *f, int ptype, int imode, const char *layers);
    void    PerlIO_debug(const char *fmt,...)
d502 2
a503 1
PerlIO_debug writes to the file named by $ENV{'PERLIO_DEBUG'} typical
d507 1
a507 1
   PERLIO_DEBUG=/dev/tty ./perl somescript some args
d510 2
a511 2
   setenv PERLIO_DEBUG /dev/tty
   ./perl somescript some args
d514 1
a514 1
   env PERLIO_DEBUG=/dev/tty ./perl somescript some args
d517 2
a518 2
   set PERLIO_DEBUG=CON
   perl somescript some args
d520 2
a521 1
If $ENV{'PERLIO_DEBUG'} is not set PerlIO_debug() is a no-op.
@


1.8
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d22 1
a22 1
    int     PerlIO_write(PerlIO *f,const void *buf,size_t numbytes);
d33 1
a33 1
    int     PerlIO_read(PerlIO *f, void *buf, size_t numbytes);
d48 1
a48 1
    int     PerlIO_get_cnt(PerlIO *f);
d50 1
a50 1
    void    PerlIO_set_ptrcnt(PerlIO *f, char *ptr, int count);
d57 1
a57 1
    int     PerlIO_get_bufsiz(PerlIO *f);
d93 1
a93 8
=item 2. USE_SFIO

A "legacy" implementation in terms of the "sfio" library. Used for
some specialist applications on Unix machines ("sfio" is not widely
ported away from Unix).  Most of above are #define'd to the sfio
functions. PerlIO * is in this case Sfio_t *.

=item 3. USE_PERLIO
@


1.7
log
@Merge in perl 5.10.1
@
text
@d393 1
a393 2
                        `Can set pointer into buffer'

@


1.6
log
@merge in perl 5.8.8
@
text
@d489 1
a489 1
    PerlIO_binmode(f,ptype,O_BINARY,Nullch);
@


1.5
log
@sync in-tree perl with 5.8.6
@
text
@d240 1
a240 1
the file desciptor as specified by B<offset> and B<whence> (sic).
@


1.4
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d228 1
a228 1
streams (or core dump with some USE_STDIO implementattions).  Calling
@


1.3
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d163 11
a173 6
These correspond to fread() and fwrite(). Note that arguments are
different, there is only one "count" and order has "file"
first. Returns a byte count if successful (which may be zero or positive), returns
negative value and sets C<errno> on error.  Depending on
implementation C<errno> may be C<EINTR> if operation was interrupted
by a signal.
d228 7
a234 6
streams (or core dump with some USE_STDIO implementattions).
Calling on a handle open for read only, or on  which last operation was a read of some kind
may lead to undefined behaviour on some USE_STDIO implementations.
The USE_PERLIO (layers) implementation tries to behave better: it flushes all open streams
when passed C<NULL>, and attempts to retain data on read streams either in the buffer
or by seeking the handle to the current logical position.
d319 5
a323 4
The mode argument should be a string as would be passed to fopen/PerlIO_open.
If it is NULL then - for legacy support - the code will (depending upon
the platform and the implementation) either attempt to empirically determine the mode in
which I<f> is open, or use "r+" to indicate a read/write stream.
d336 11
a346 11
expecting to be compiled and linked with ANSI C I<stdio.h>.
The mode argument should be a string as would be passed to fopen/PerlIO_open.
If it is NULL then - for legacy support - the FILE * is opened
in same mode as the PerlIO *.

The fact that such a FILE * has been 'exported' is recorded, (normally by
pushing a new :stdio "layer" onto the PerlIO *), which may affect future
PerlIO operations on the original PerlIO *.
You should not call C<fclose()> on the file unless you call
C<PerlIO_releaseFILE()> to disassociate it from the PerlIO *.
(Do not use PerlIO_importFILE() for doing the disassociation.)
d388 2
a389 2
allow perl's C<sv_gets> to "bypass" normal IO mechanism.
This can vary from handle to handle.
d463 2
a464 2
are silently ignored. (As of perl5.8 ":raw" is deprecated.)
Use PerlIO_binmode() below for the portable case.
d483 3
a485 2
B<layers> is a string of layers to apply, only ":crlf" makes sense in the non USE_PERLIO
case. (As of perl5.8 ":raw" is deprecated in favour of passing NULL.)
@


1.2
log
@perl5.005_03 (stock)
@
text
@d7 3
d14 53
a66 45
    PerlIO *PerlIO_open(const char *,const char *);
    int     PerlIO_close(PerlIO *);

    int     PerlIO_stdoutf(const char *,...)
    int     PerlIO_puts(PerlIO *,const char *);
    int     PerlIO_putc(PerlIO *,int);
    int     PerlIO_write(PerlIO *,const void *,size_t);
    int     PerlIO_printf(PerlIO *, const char *,...);
    int     PerlIO_vprintf(PerlIO *, const char *, va_list);
    int     PerlIO_flush(PerlIO *);

    int     PerlIO_eof(PerlIO *);
    int     PerlIO_error(PerlIO *);
    void    PerlIO_clearerr(PerlIO *);

    int     PerlIO_getc(PerlIO *);
    int     PerlIO_ungetc(PerlIO *,int);
    int     PerlIO_read(PerlIO *,void *,size_t);

    int     PerlIO_fileno(PerlIO *);
    PerlIO *PerlIO_fdopen(int, const char *);
    PerlIO *PerlIO_importFILE(FILE *, int flags);
    FILE   *PerlIO_exportFILE(PerlIO *, int flags);
    FILE   *PerlIO_findFILE(PerlIO *);
    void    PerlIO_releaseFILE(PerlIO *,FILE *);

    void    PerlIO_setlinebuf(PerlIO *);

    long    PerlIO_tell(PerlIO *);
    int     PerlIO_seek(PerlIO *,off_t,int);
    int     PerlIO_getpos(PerlIO *,Fpos_t *)
    int     PerlIO_setpos(PerlIO *,Fpos_t *)
    void    PerlIO_rewind(PerlIO *);

    int     PerlIO_has_base(PerlIO *);
    int     PerlIO_has_cntptr(PerlIO *);
    int     PerlIO_fast_gets(PerlIO *);
    int     PerlIO_canset_cnt(PerlIO *);

    char   *PerlIO_get_ptr(PerlIO *);
    int     PerlIO_get_cnt(PerlIO *);
    void    PerlIO_set_cnt(PerlIO *,int);
    void    PerlIO_set_ptrcnt(PerlIO *,char *,int);
    char   *PerlIO_get_base(PerlIO *);
    int     PerlIO_get_bufsiz(PerlIO *);
d70 4
a73 3
Perl's source code should use the above functions instead of those
defined in ANSI C's I<stdio.h>.  The perl headers will C<#define> them to
the I/O mechanism selected at Configure time.
d78 6
d86 35
a120 1
=item B<PerlIO *>
d122 4
a125 2
This takes the place of FILE *. Like FILE * it should be treated as
opaque (it is probably safe to assume it is a pointer to something).
d137 14
a150 1
These correspond to fopen()/fdopen() arguments are the same.
d163 6
a168 3
These correspond to fread() and fwrite(). Note that arguments
are different, there is only one "count" and order has
"file" first.
d172 3
d182 7
a188 2
This corresponds to ungetc().
Note that arguments have been revised to have "file" first.
d193 2
d198 4
a201 1
This corresponds to feof().
d205 2
a206 1
This corresponds to ferror().
d210 3
a212 2
This corresponds to fileno(), note that on some platforms,
the meaning of "fileno" may not match Unix.
d216 2
a217 2
This corresponds to clearerr(), i.e., clears 'eof' and 'error'
flags for the "stream".
d221 18
a238 1
This corresponds to fflush().
d242 6
a247 5
This corresponds to ftell().

=item B<PerlIO_seek(f,o,w)>

This corresponds to fseek().
d251 6
a256 3
These correspond to fgetpos() and fsetpos(). If platform does not
have the stdio calls then they are implemented in terms of PerlIO_tell()
and PerlIO_seek().
d260 4
a263 2
This corresponds to rewind(). Note may be redefined
in terms of PerlIO_seek() at some point.
d267 17
a283 2
This corresponds to tmpfile(), i.e., returns an anonymous
PerlIO which will automatically be deleted when closed.
d290 16
a305 4
Obviously if PerlIO is implemented in terms of stdio there is
no problem. However if perlio is implemented on top of (say) sfio
then mechanisms must exist to create a FILE * which can be passed
to library code which is going to use stdio calls.
d309 1
a309 1
=item B<PerlIO_importFILE(f,flags)>
a311 1
May need additional arguments, interface under review.
d313 27
a339 1
=item B<PerlIO_exportFILE(f,flags)>
d341 2
a342 3
Given an PerlIO * return a 'native' FILE * suitable for
passing to code expecting to be compiled and linked with
ANSI C I<stdio.h>.
d344 1
a344 3
The fact that such a FILE * has been 'exported' is recorded,
and may affect future PerlIO operations on the original
PerlIO *.
d346 3
a348 1
=item B<PerlIO_findFILE(f)>
d350 2
a351 2
Returns previously 'exported' FILE * (if any).
Place holder until interface is fully defined.
d353 1
a353 1
=item B<PerlIO_releaseFILE(p,f)>
d355 4
a358 4
Calling PerlIO_releaseFILE informs PerlIO that all use
of FILE * is complete. It is removed from list of 'exported'
FILE *s, and associated PerlIO * should revert to original
behaviour.
a359 1
=item B<PerlIO_setlinebuf(f)>
d361 1
a361 3
This corresponds to setlinebuf(). Use is deprecated pending
further discussion. (Perl core uses it I<only> when "dumping";
it has nothing to do with $| auto-flush.)
d363 1
a363 1
=back
d365 10
a374 6
In addition to user API above there is an "implementation" interface
which allows perl to get at internals of PerlIO.
The following calls correspond to the various FILE_xxx macros determined
by Configure. This section is really of interest to only those
concerned with detailed perl-core behaviour or implementing a
PerlIO mapping.
d378 1
a378 1
=item B<PerlIO_has_cntptr(f)>
d380 3
a382 2
Implementation can return pointer to current position in the "buffer" and
a count of bytes available in the buffer.
d384 3
a386 1
=item B<PerlIO_get_ptr(f)>
a387 1
Return pointer to next readable byte in buffer.
d389 1
a389 1
=item B<PerlIO_get_cnt(f)>
d391 3
a393 1
Return count of readable bytes in the buffer.
d395 1
a395 1
=item B<PerlIO_canset_cnt(f)>
d397 2
a398 2
Implementation can adjust its idea of number of
bytes in the buffer.
d400 1
a400 1
=item B<PerlIO_fast_gets(f)>
d402 4
a405 6
Implementation has all the interfaces required to
allow perl's fast code to handle <FILE> mechanism.

  PerlIO_fast_gets(f) = PerlIO_has_cntptr(f) && \
                        PerlIO_canset_cnt(f) && \
                        `Can set pointer into buffer'
d410 9
a418 3
buffer. Should be used only to set
pointer to within range implied by previous calls
to C<PerlIO_get_ptr> and C<PerlIO_get_cnt>.
d422 5
a426 5
Obscure - set count of bytes in the buffer. Deprecated.
Currently used in only doio.c to force count < -1 to -1.
Perhaps should be PerlIO_set_empty or similar.
This call may actually do nothing if "count" is deduced from pointer
and a "limit".
d430 1
a430 1
Implementation has a buffer, and can return pointer
d436 2
a437 1
Return I<start> of buffer.
d441 76
a516 1
Return I<total size> of buffer.
@


1.1
log
@perl 5.004_04
@
text
@d60 1
a60 1
defined in ANSI C's I<stdio.h>,  I<perlio.h> will the C<#define> them to
d70 1
a70 1
This takes the place of FILE *. Unlike FILE * it should be treated as
d87 1
a87 1
These are is fprintf()/vfprintf equivalents.
d204 2
a205 2
further discussion. (Perl core uses it I<only> when "dumping"
is has nothing to do with $| auto-flush.)
@


1.1.1.1
log
@perl5.005_03
@
text
@d60 1
a60 1
defined in ANSI C's I<stdio.h>.  The perl headers will C<#define> them to
d70 1
a70 1
This takes the place of FILE *. Like FILE * it should be treated as
d87 1
a87 1
These are fprintf()/vfprintf() equivalents.
d204 2
a205 2
further discussion. (Perl core uses it I<only> when "dumping";
it has nothing to do with $| auto-flush.)
@


1.1.1.2
log
@stock perl 5.8.0 from CPAN
@
text
@a6 3
    #define PERLIO_NOT_STDIO 0    /* For co-existence with stdio only */
    #include <perlio.h>           /* Usually via #include <perl.h> */

d11 45
a55 53
    PerlIO *PerlIO_open(const char *path,const char *mode);
    PerlIO *PerlIO_fdopen(int fd, const char *mode);
    PerlIO *PerlIO_reopen(const char *path, const char *mode, PerlIO *old);  /* deprecated */
    int     PerlIO_close(PerlIO *f);

    int     PerlIO_stdoutf(const char *fmt,...)
    int     PerlIO_puts(PerlIO *f,const char *string);
    int     PerlIO_putc(PerlIO *f,int ch);
    int     PerlIO_write(PerlIO *f,const void *buf,size_t numbytes);
    int     PerlIO_printf(PerlIO *f, const char *fmt,...);
    int     PerlIO_vprintf(PerlIO *f, const char *fmt, va_list args);
    int     PerlIO_flush(PerlIO *f);

    int     PerlIO_eof(PerlIO *f);
    int     PerlIO_error(PerlIO *f);
    void    PerlIO_clearerr(PerlIO *f);

    int     PerlIO_getc(PerlIO *d);
    int     PerlIO_ungetc(PerlIO *f,int ch);
    int     PerlIO_read(PerlIO *f, void *buf, size_t numbytes);

    int     PerlIO_fileno(PerlIO *f);

    void    PerlIO_setlinebuf(PerlIO *f);

    Off_t   PerlIO_tell(PerlIO *f);
    int     PerlIO_seek(PerlIO *f, Off_t offset, int whence);
    void    PerlIO_rewind(PerlIO *f);

    int     PerlIO_getpos(PerlIO *f, SV *save);        /* prototype changed */
    int     PerlIO_setpos(PerlIO *f, SV *saved);       /* prototype changed */

    int     PerlIO_fast_gets(PerlIO *f);
    int     PerlIO_has_cntptr(PerlIO *f);
    int     PerlIO_get_cnt(PerlIO *f);
    char   *PerlIO_get_ptr(PerlIO *f);
    void    PerlIO_set_ptrcnt(PerlIO *f, char *ptr, int count);

    int     PerlIO_canset_cnt(PerlIO *f);              /* deprecated */
    void    PerlIO_set_cnt(PerlIO *f, int count);      /* deprecated */

    int     PerlIO_has_base(PerlIO *f);
    char   *PerlIO_get_base(PerlIO *f);
    int     PerlIO_get_bufsiz(PerlIO *f);

    PerlIO *PerlIO_importFILE(FILE *stdio, const char *mode);
    FILE   *PerlIO_exportFILE(PerlIO *f, int flags);
    FILE   *PerlIO_findFILE(PerlIO *f);
    void    PerlIO_releaseFILE(PerlIO *f,FILE *stdio);

    int     PerlIO_apply_layers(PerlIO *f, const char *mode, const char *layers);
    int     PerlIO_binmode(PerlIO *f, int ptype, int imode, const char *layers);
    void    PerlIO_debug(const char *fmt,...)
d59 3
a61 4
Perl's source code, and extensions that want maximum portability,
should use the above functions instead of those defined in ANSI C's
I<stdio.h>.  The perl headers (in particular "perlio.h") will
C<#define> them to the I/O mechanism selected at Configure time.
a65 6
C<PerlIO *> takes the place of FILE *. Like FILE * it should be
treated as opaque (it is probably safe to assume it is a pointer to
something).

There are currently three implementations:

d68 1
a68 35
=item 1. USE_STDIO

All above are #define'd to stdio functions or are trivial wrapper
functions which call stdio. In this case I<only> PerlIO * is a FILE *.
This has been the default implementation since the abstraction was
introduced in perl5.003_02.

=item 2. USE_SFIO

A "legacy" implementation in terms of the "sfio" library. Used for
some specialist applications on Unix machines ("sfio" is not widely
ported away from Unix).  Most of above are #define'd to the sfio
functions. PerlIO * is in this case Sfio_t *.

=item 3. USE_PERLIO

Introduced just after perl5.7.0, this is a re-implementation of the
above abstraction which allows perl more control over how IO is done
as it decouples IO from the way the operating system and C library
choose to do things. For USE_PERLIO PerlIO * has an extra layer of
indirection - it is a pointer-to-a-pointer.  This allows the PerlIO *
to remain with a known value while swapping the implementation around
underneath I<at run time>. In this case all the above are true (but
very simple) functions which call the underlying implementation.

This is the only implementation for which C<PerlIO_apply_layers()>
does anything "interesting".

The USE_PERLIO implementation is described in L<perliol>.

=back

Because "perlio.h" is a thin layer (for efficiency) the semantics of
these functions are somewhat dependent on the underlying implementation.
Where these variations are understood they are noted below.
d70 2
a71 4
Unless otherwise noted, functions return 0 on success, or a negative
value (usually C<EOF> which is usually -1) and set C<errno> on error.

=over 4
d83 1
a83 14
These correspond to fopen()/fdopen() and the arguments are the same.
Return C<NULL> and set C<errno> if there is an error.  There may be an
implementation limit on the number of open handles, which may be lower
than the limit on the number of open files - C<errno> may not be set
when C<NULL> is returned if this limit is exceeded.

=item B<PerlIO_reopen(path,mode,f)>

While this currently exists in all three implementations perl itself
does not use it. I<As perl does not use it, it is not well tested.>

Perl prefers to C<dup> the new low-level descriptor to the descriptor
used by the existing PerlIO. This may become the behaviour of this
function in the future.
d96 3
a98 6
These correspond to fread() and fwrite(). Note that arguments are
different, there is only one "count" and order has "file"
first. Returns a byte count if successful (which may be zero or positive), returns
negative value and sets C<errno> on error.  Depending on
implementation C<errno> may be C<EINTR> if operation was interrupted
by a signal.
a101 3
Depending on implementation C<errno> may be C<EINTR> if operation was
interrupted by a signal.

d109 2
a110 7
This corresponds to ungetc().  Note that arguments have been revised
to have "file" first.  Arranges that next read operation will return
the byte B<c>.  Despite the implied "character" in the name only
values in the range 0..0xFF are defined. Returns the byte B<c> on
success or -1 (C<EOF>) on error.  The number of bytes that can be
"pushed back" may vary, only 1 character is certain, and then only if
it is the last character that was read from the handle.
a114 2
Despite the c in the name only byte range 0..0xFF is supported.
Returns the character read or -1 (C<EOF>) on error.
d118 1
a118 4
This corresponds to feof().  Returns a true/false indication of
whether the handle is at end of file.  For terminal devices this may
or may not be "sticky" depending on the implementation.  The flag is
cleared by PerlIO_seek(), or PerlIO_rewind().
d122 1
a122 2
This corresponds to ferror().  Returns a true/false indication of
whether there has been an IO error on the handle.
d126 2
a127 3
This corresponds to fileno(), note that on some platforms, the meaning
of "fileno" may not match Unix. Returns -1 if the handle has no open
descriptor associated with it.
d131 2
a132 2
This corresponds to clearerr(), i.e., clears 'error' and (usually)
'eof' flags for the "stream". Does not return a value.
d136 1
a136 18
This corresponds to fflush().  Sends any buffered write data to the
underlying file.  If called with C<NULL> this may flush all open
streams (or core dump with some USE_STDIO implementattions).
Calling on a handle open for read only, or on  which last operation was a read of some kind
may lead to undefined behaviour on some USE_STDIO implementations.
The USE_PERLIO (layers) implementation tries to behave better: it flushes all open streams
when passed C<NULL>, and attempts to retain data on read streams either in the buffer
or by seeking the handle to the current logical position.

=item B<PerlIO_seek(f,offset,whence)>

This corresponds to fseek().  Sends buffered write data to the
underlying file, or discards any buffered read data, then positions
the file desciptor as specified by B<offset> and B<whence> (sic).
This is the correct thing to do when switching between read and write
on the same handle (see issues with PerlIO_flush() above).  Offset is
of type C<Off_t> which is a perl Configure value which may not be same
as stdio's C<off_t>.
d140 5
a144 6
This corresponds to ftell().  Returns the current file position, or
(Off_t) -1 on error.  May just return value system "knows" without
making a system call or checking the underlying file descriptor (so
use on shared file descriptors is not safe without a
PerlIO_seek()). Return value is of type C<Off_t> which is a perl
Configure value which may not be same as stdio's C<off_t>.
d148 3
a150 6
These correspond (loosely) to fgetpos() and fsetpos(). Rather than
stdio's Fpos_t they expect a "Perl Scalar Value" to be passed. What is
stored there should be considered opaque. The layout of the data may
vary from handle to handle.  When not using stdio or if platform does
not have the stdio calls then they are implemented in terms of
PerlIO_tell() and PerlIO_seek().
d154 2
a155 4
This corresponds to rewind(). It is usually defined as being

    PerlIO_seek(f,(Off_t)0L, SEEK_SET);
    PerlIO_clearerr(f);
d159 2
a160 17
This corresponds to tmpfile(), i.e., returns an anonymous PerlIO or
NULL on error.  The system will attempt to automatically delete the
file when closed.  On Unix the file is usually C<unlink>-ed just after
it is created so it does not matter how it gets closed. On other
systems the file may only be deleted if closed via PerlIO_close()
and/or the program exits via C<exit>.  Depending on the implementation
there may be "race conditions" which allow other processes access to
the file, though in general it will be safer in this regard than
ad. hoc. schemes.

=item B<PerlIO_setlinebuf(f)>

This corresponds to setlinebuf().  Does not return a value. What
constitutes a "line" is implementation dependent but usually means
that writing "\n" flushes the buffer.  What happens with things like
"this\nthat" is uncertain.  (Perl core uses it I<only> when "dumping";
it has nothing to do with $| auto-flush.)
d167 4
a170 16
Obviously if PerlIO is implemented in terms of stdio there is no
problem. However in other cases then mechanisms must exist to create a
FILE * which can be passed to library code which is going to use stdio
calls.

The first step is to add this line:

   #define PERLIO_NOT_STDIO 0

I<before> including any perl header files. (This will probably become
the default at some point).  That prevents "perlio.h" from attempting
to #define stdio functions onto PerlIO functions.

XS code is probably better using "typemap" if it expects FILE *
arguments.  The standard typemap will be adjusted to comprehend any
changes in this area.
d174 1
a174 1
=item B<PerlIO_importFILE(f,mode)>
d177 3
d181 3
a183 27
The mode argument should be a string as would be passed to fopen/PerlIO_open.
If it is NULL then - for legacy support - the code will (depending upon
the platform and the implementation) either attempt to empirically determine the mode in
which I<f> is open, or use "r+" to indicate a read/write stream.

Once called the FILE * should I<ONLY> be closed by calling
C<PerlIO_close()> on the returned PerlIO *.

The PerlIO is set to textmode. Use PerlIO_binmode if this is
not the desired mode.

This is B<not> the reverse of PerlIO_exportFILE().

=item B<PerlIO_exportFILE(f,mode)>

Given a PerlIO * create a 'native' FILE * suitable for passing to code
expecting to be compiled and linked with ANSI C I<stdio.h>.
The mode argument should be a string as would be passed to fopen/PerlIO_open.
If it is NULL then - for legacy support - the FILE * is opened
in same mode as the PerlIO *.

The fact that such a FILE * has been 'exported' is recorded, (normally by
pushing a new :stdio "layer" onto the PerlIO *), which may affect future
PerlIO operations on the original PerlIO *.
You should not call C<fclose()> on the file unless you call
C<PerlIO_releaseFILE()> to disassociate it from the PerlIO *.
(Do not use PerlIO_importFILE() for doing the disassociation.)
d185 3
a187 2
Calling this function repeatedly will create a FILE * on each call
(and will push an :stdio layer each time as well).
d189 1
a189 1
=item B<PerlIO_releaseFILE(p,f)>
d191 2
a192 3
Calling PerlIO_releaseFILE informs PerlIO that all use of FILE * is
complete. It is removed from the list of 'exported' FILE *s, and the
associated PerlIO * should revert to its original behaviour.
d194 1
a194 2
Use this to disassociate a file from a PerlIO * that was associated
using PerlIO_exportFILE().
d196 4
a199 1
=item B<PerlIO_findFILE(f)>
d201 1
a201 4
Returns a native FILE * used by a stdio layer. If there is none, it
will create one with PerlIO_exportFILE. In either case the FILE *
should be considered as belonging to PerlIO subsystem and should
only be closed by calling C<PerlIO_close()>.
d203 3
d209 6
a214 1
=head2 "Fast gets" Functions
d216 1
a216 10
In addition to standard-like API defined so far above there is an
"implementation" interface which allows perl to get at internals of
PerlIO.  The following calls correspond to the various FILE_xxx macros
determined by Configure - or their equivalent in other
implementations. This section is really of interest to only those
concerned with detailed perl-core behaviour, implementing a PerlIO
mapping or writing code which can make use of the "read ahead" that
has been done by the IO system in the same way perl does. Note that
any code that uses these interfaces must be prepared to do things the
traditional way if a handle does not support them.
d218 1
a218 1
=over 4
d220 2
a221 1
=item B<PerlIO_fast_gets(f)>
d223 1
a223 3
Returns true if implementation has all the interfaces required to
allow perl's C<sv_gets> to "bypass" normal IO mechanism.
This can vary from handle to handle.
d225 1
a225 3
  PerlIO_fast_gets(f) = PerlIO_has_cntptr(f) && \
                        PerlIO_canset_cnt(f) && \
                        `Can set pointer into buffer'
d227 1
d229 1
a229 1
=item B<PerlIO_has_cntptr(f)>
d231 1
a231 3
Implementation can return pointer to current position in the "buffer"
and a count of bytes available in the buffer.  Do not use this - use
PerlIO_fast_gets.
d233 2
a234 1
=item B<PerlIO_get_cnt(f)>
d236 1
a236 2
Return count of readable bytes in the buffer. Zero or negative return
means no more bytes available.
d238 2
a239 1
=item B<PerlIO_get_ptr(f)>
d241 3
a243 4
Return pointer to next readable byte in buffer, accessing via the
pointer (dereferencing) is only safe if PerlIO_get_cnt() has returned
a positive value.  Only positive offsets up to value returned by
PerlIO_get_cnt() are allowed.
d248 3
a250 9
buffer. Should be used only to set pointer to within range implied by
previous calls to C<PerlIO_get_ptr> and C<PerlIO_get_cnt>. The two
values I<must> be consistent with each other (implementation may only
use one or the other or may require both).

=item B<PerlIO_canset_cnt(f)>

Implementation can adjust its idea of number of bytes in the buffer.
Do not use this - use PerlIO_fast_gets.
d254 5
a258 5
Obscure - set count of bytes in the buffer. Deprecated.  Only usable
if PerlIO_canset_cnt() returns true.  Currently used in only doio.c to
force count less than -1 to -1.  Perhaps should be PerlIO_set_empty or
similar.  This call may actually do nothing if "count" is deduced from
pointer and a "limit".  Do not use this - use PerlIO_set_ptrcnt().
d262 1
a262 1
Returns true if implementation has a buffer, and can return pointer
d268 1
a268 2
Return I<start> of buffer. Access only positive offsets in the buffer
up to the value returned by PerlIO_get_bufsiz().
d272 1
a272 76
Return the I<total number of bytes> in the buffer, this is neither the
number that can be read, nor the amount of memory allocated to the
buffer. Rather it is what the operating system and/or implementation
happened to C<read()> (or whatever) last time IO was requested.

=back

=head2 Other Functions

=over 4

=item PerlIO_apply_layers(f,mode,layers)

The new interface to the USE_PERLIO implementation. The layers ":crlf"
and ":raw" are only ones allowed for other implementations and those
are silently ignored. (As of perl5.8 ":raw" is deprecated.)
Use PerlIO_binmode() below for the portable case.

=item PerlIO_binmode(f,ptype,imode,layers)

The hook used by perl's C<binmode> operator.
B<ptype> is perl's character for the kind of IO:

=over 8

=item 'E<lt>' read

=item 'E<gt>' write

=item '+' read/write

=back

B<imode> is C<O_BINARY> or C<O_TEXT>.

B<layers> is a string of layers to apply, only ":crlf" makes sense in the non USE_PERLIO
case. (As of perl5.8 ":raw" is deprecated in favour of passing NULL.)

Portable cases are:

    PerlIO_binmode(f,ptype,O_BINARY,Nullch);
and
    PerlIO_binmode(f,ptype,O_TEXT,":crlf");

On Unix these calls probably have no effect whatsoever.  Elsewhere
they alter "\n" to CR,LF translation and possibly cause a special text
"end of file" indicator to be written or honoured on read. The effect
of making the call after doing any IO to the handle depends on the
implementation. (It may be ignored, affect any data which is already
buffered as well, or only apply to subsequent data.)

=item PerlIO_debug(fmt,...)

PerlIO_debug is a printf()-like function which can be used for
debugging.  No return value. Its main use is inside PerlIO where using
real printf, warn() etc. would recursively call PerlIO and be a
problem.

PerlIO_debug writes to the file named by $ENV{'PERLIO_DEBUG'} typical
use might be

  Bourne shells (sh, ksh, bash, zsh, ash, ...):
   PERLIO_DEBUG=/dev/tty ./perl somescript some args

  Csh/Tcsh:
   setenv PERLIO_DEBUG /dev/tty
   ./perl somescript some args

  If you have the "env" utility:
   env PERLIO_DEBUG=/dev/tty ./perl somescript some args

  Win32:
   set PERLIO_DEBUG=CON
   perl somescript some args

If $ENV{'PERLIO_DEBUG'} is not set PerlIO_debug() is a no-op.
@


1.1.1.3
log
@perl 5.8.2 from CPAN
@
text
@d163 6
a168 11
These correspond functionally to fread() and fwrite() but the
arguments and return values are different.  The PerlIO_read() and
PerlIO_write() signatures have been modeled on the more sane low level
read() and write() functions instead: The "file" argument is passed
first, there is only one "count", and the return value can distinguish
between error and C<EOF>.

Returns a byte count if successful (which may be zero or
positive), returns negative value and sets C<errno> on error.
Depending on implementation C<errno> may be C<EINTR> if operation was
interrupted by a signal.
d223 6
a228 7
streams (or core dump with some USE_STDIO implementattions).  Calling
on a handle open for read only, or on which last operation was a read
of some kind may lead to undefined behaviour on some USE_STDIO
implementations.  The USE_PERLIO (layers) implementation tries to
behave better: it flushes all open streams when passed C<NULL>, and
attempts to retain data on read streams either in the buffer or by
seeking the handle to the current logical position.
d313 4
a316 5
The mode argument should be a string as would be passed to
fopen/PerlIO_open.  If it is NULL then - for legacy support - the code
will (depending upon the platform and the implementation) either
attempt to empirically determine the mode in which I<f> is open, or
use "r+" to indicate a read/write stream.
d329 11
a339 11
expecting to be compiled and linked with ANSI C I<stdio.h>.  The mode
argument should be a string as would be passed to fopen/PerlIO_open.
If it is NULL then - for legacy support - the FILE * is opened in same
mode as the PerlIO *.

The fact that such a FILE * has been 'exported' is recorded, (normally
by pushing a new :stdio "layer" onto the PerlIO *), which may affect
future PerlIO operations on the original PerlIO *.  You should not
call C<fclose()> on the file unless you call C<PerlIO_releaseFILE()>
to disassociate it from the PerlIO *.  (Do not use PerlIO_importFILE()
for doing the disassociation.)
d381 2
a382 2
allow perl's C<sv_gets> to "bypass" normal IO mechanism.  This can
vary from handle to handle.
d456 2
a457 2
are silently ignored. (As of perl5.8 ":raw" is deprecated.)  Use
PerlIO_binmode() below for the portable case.
d476 2
a477 3
B<layers> is a string of layers to apply, only ":crlf" makes sense in
the non USE_PERLIO case. (As of perl5.8 ":raw" is deprecated in favour
of passing NULL.)
@


1.1.1.4
log
@perl 5.8.6 from CPAN
@
text
@d228 1
a228 1
streams (or core dump with some USE_STDIO implementations).  Calling
@


1.1.1.5
log
@perl 5.8.8 import
@
text
@d240 1
a240 1
the file descriptor as specified by B<offset> and B<whence> (sic).
@


1.1.1.6
log
@import perl 5.10.1
@
text
@d489 1
a489 1
    PerlIO_binmode(f,ptype,O_BINARY,NULL);
@


1.1.1.7
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d393 2
a394 1
                        'Can set pointer into buffer'
@


1.1.1.8
log
@Import perl-5.20.1
@
text
@d22 1
a22 1
    SSize_t PerlIO_write(PerlIO *f,const void *buf,size_t numbytes);
d33 1
a33 1
    SSize_t PerlIO_read(PerlIO *f, void *buf, size_t numbytes);
d48 1
a48 1
    SSize_t PerlIO_get_cnt(PerlIO *f);
d50 1
a50 1
    void    PerlIO_set_ptrcnt(PerlIO *f, char *ptr, SSize_t count);
d57 1
a57 1
    SSize_t PerlIO_get_bufsiz(PerlIO *f);
d93 8
a100 1
=item 2. USE_PERLIO
@


1.1.1.9
log
@Import perl-5.24.2
@
text
@d7 2
a8 2
  #define PERLIO_NOT_STDIO 0    /* For co-existence with stdio only */
  #include <perlio.h>           /* Usually via #include <perl.h> */
d10 57
a66 60
  PerlIO *PerlIO_stdin(void);
  PerlIO *PerlIO_stdout(void);
  PerlIO *PerlIO_stderr(void);

  PerlIO *PerlIO_open(const char *path,const char *mode);
  PerlIO *PerlIO_fdopen(int fd, const char *mode);
  PerlIO *PerlIO_reopen(const char *path, /* deprecated */
          const char *mode, PerlIO *old);
  int     PerlIO_close(PerlIO *f);

  int     PerlIO_stdoutf(const char *fmt,...)
  int     PerlIO_puts(PerlIO *f,const char *string);
  int     PerlIO_putc(PerlIO *f,int ch);
  SSize_t PerlIO_write(PerlIO *f,const void *buf,size_t numbytes);
  int     PerlIO_printf(PerlIO *f, const char *fmt,...);
  int     PerlIO_vprintf(PerlIO *f, const char *fmt, va_list args);
  int     PerlIO_flush(PerlIO *f);

  int     PerlIO_eof(PerlIO *f);
  int     PerlIO_error(PerlIO *f);
  void    PerlIO_clearerr(PerlIO *f);

  int     PerlIO_getc(PerlIO *d);
  int     PerlIO_ungetc(PerlIO *f,int ch);
  SSize_t PerlIO_read(PerlIO *f, void *buf, size_t numbytes);

  int     PerlIO_fileno(PerlIO *f);

  void    PerlIO_setlinebuf(PerlIO *f);

  Off_t   PerlIO_tell(PerlIO *f);
  int     PerlIO_seek(PerlIO *f, Off_t offset, int whence);
  void    PerlIO_rewind(PerlIO *f);

  int     PerlIO_getpos(PerlIO *f, SV *save);    /* prototype changed */
  int     PerlIO_setpos(PerlIO *f, SV *saved);   /* prototype changed */

  int     PerlIO_fast_gets(PerlIO *f);
  int     PerlIO_has_cntptr(PerlIO *f);
  SSize_t PerlIO_get_cnt(PerlIO *f);
  char   *PerlIO_get_ptr(PerlIO *f);
  void    PerlIO_set_ptrcnt(PerlIO *f, char *ptr, SSize_t count);

  int     PerlIO_canset_cnt(PerlIO *f);              /* deprecated */
  void    PerlIO_set_cnt(PerlIO *f, int count);      /* deprecated */

  int     PerlIO_has_base(PerlIO *f);
  char   *PerlIO_get_base(PerlIO *f);
  SSize_t PerlIO_get_bufsiz(PerlIO *f);

  PerlIO *PerlIO_importFILE(FILE *stdio, const char *mode);
  FILE   *PerlIO_exportFILE(PerlIO *f, int flags);
  FILE   *PerlIO_findFILE(PerlIO *f);
  void    PerlIO_releaseFILE(PerlIO *f,FILE *stdio);

  int     PerlIO_apply_layers(PerlIO *f, const char *mode,
                                                    const char *layers);
  int     PerlIO_binmode(PerlIO *f, int ptype, int imode,
                                                    const char *layers);
  void    PerlIO_debug(const char *fmt,...)
d499 1
a499 2
PerlIO_debug writes to the file named by $ENV{'PERLIO_DEBUG'} or defaults
to stderr if the environment variable is not defined. Typical
d503 1
a503 1
   PERLIO_DEBUG=/tmp/perliodebug.log ./perl -Di somescript some args
d506 2
a507 2
   setenv PERLIO_DEBUG /tmp/perliodebug.log
   ./perl -Di somescript some args
d510 1
a510 1
   env PERLIO_DEBUG=/tmp/perliodebug.log ./perl -Di somescript args
d513 2
a514 2
   set PERLIO_DEBUG=perliodebug.log
   perl -Di somescript some args
d516 1
a516 2
On a Perl built without C<-DDEBUGGING>, or when the C<-Di> command-line switch
is not specified, or under taint, PerlIO_debug() is a no-op.
@


