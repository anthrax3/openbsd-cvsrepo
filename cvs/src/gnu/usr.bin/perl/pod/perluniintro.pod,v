head	1.2;
access;
symbols
	OPENBSD_6_2:1.2.0.2
	OPENBSD_6_2_BASE:1.2
	PERL_5_24_2:1.1.1.11
	OPENBSD_6_1:1.2.0.4
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.10.0.8
	OPENBSD_6_0_BASE:1.1.1.10
	OPENBSD_5_9:1.1.1.10.0.2
	OPENBSD_5_9_BASE:1.1.1.10
	OPENBSD_5_8:1.1.1.10.0.4
	OPENBSD_5_8_BASE:1.1.1.10
	PERL_5_20_2:1.1.1.10
	OPENBSD_5_7:1.1.1.9.0.2
	OPENBSD_5_7_BASE:1.1.1.9
	PERL_5_20_1:1.1.1.9
	OPENBSD_5_6:1.1.1.8.0.4
	OPENBSD_5_6_BASE:1.1.1.8
	PERL_5_18_2:1.1.1.8
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.7.0.6
	OPENBSD_5_5_BASE:1.1.1.7
	OPENBSD_5_4:1.1.1.7.0.2
	OPENBSD_5_4_BASE:1.1.1.7
	PERL_5_16_3:1.1.1.7
	OPENBSD_5_3:1.1.1.6.0.10
	OPENBSD_5_3_BASE:1.1.1.6
	OPENBSD_5_2:1.1.1.6.0.8
	OPENBSD_5_2_BASE:1.1.1.6
	OPENBSD_5_1_BASE:1.1.1.6
	OPENBSD_5_1:1.1.1.6.0.6
	OPENBSD_5_0:1.1.1.6.0.4
	OPENBSD_5_0_BASE:1.1.1.6
	OPENBSD_4_9:1.1.1.6.0.2
	OPENBSD_4_9_BASE:1.1.1.6
	PERL_5_12_2:1.1.1.6
	OPENBSD_4_8:1.1.1.5.0.4
	OPENBSD_4_8_BASE:1.1.1.5
	OPENBSD_4_7:1.1.1.5.0.2
	OPENBSD_4_7_BASE:1.1.1.5
	PERL_5_10_1:1.1.1.5
	OPENBSD_4_6:1.1.1.4.0.6
	OPENBSD_4_6_BASE:1.1.1.4
	OPENBSD_4_5:1.1.1.4.0.2
	OPENBSD_4_5_BASE:1.1.1.4
	PERL_5_10_0:1.1.1.4
	OPENBSD_4_4:1.1.1.3.0.18
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.16
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_2:1.1.1.3.0.14
	OPENBSD_4_2_BASE:1.1.1.3
	OPENBSD_4_1:1.1.1.3.0.12
	OPENBSD_4_1_BASE:1.1.1.3
	OPENBSD_4_0:1.1.1.3.0.10
	OPENBSD_4_0_BASE:1.1.1.3
	PERL_5_8_8:1.1.1.3
	OPENBSD_3_9:1.1.1.3.0.8
	OPENBSD_3_9_BASE:1.1.1.3
	OPENBSD_3_8:1.1.1.3.0.6
	OPENBSD_3_8_BASE:1.1.1.3
	OPENBSD_3_7:1.1.1.3.0.4
	OPENBSD_3_7_BASE:1.1.1.3
	PERL_5_8_6:1.1.1.3
	OPENBSD_3_6:1.1.1.3.0.2
	OPENBSD_3_6_BASE:1.1.1.3
	PERL_5_8_5:1.1.1.3
	PERL_5_8_3:1.1.1.2
	OPENBSD_3_5:1.1.1.2.0.2
	OPENBSD_3_5_BASE:1.1.1.2
	PERL_5_8_2:1.1.1.2
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	PERL_5_8_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.32.19;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2002.10.27.22.15.08;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.27.22.15.08;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.12.03.02.44.28;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.08.09.17.48.29;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2008.09.29.17.18.57;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2009.10.12.18.10.39;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2010.09.24.14.49.09;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2013.03.25.20.09.27;	author sthen;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2014.03.24.14.59.08;	author afresh1;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2014.11.17.20.53.15;	author afresh1;	state Exp;
branches;
next	1.1.1.10;
commitid	B31cAbBIXiCqnL97;

1.1.1.10
date	2015.04.25.19.10.45;	author afresh1;	state Exp;
branches;
next	1.1.1.11;
commitid	Wpcs5S8qILgEZC7F;

1.1.1.11
date	2017.08.14.13.46.21;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@=head1 NAME

perluniintro - Perl Unicode introduction

=head1 DESCRIPTION

This document gives a general idea of Unicode and how to use Unicode
in Perl.  See L</Further Resources> for references to more in-depth
treatments of Unicode.

=head2 Unicode

Unicode is a character set standard which plans to codify all of the
writing systems of the world, plus many other symbols.

Unicode and ISO/IEC 10646 are coordinated standards that unify
almost all other modern character set standards,
covering more than 80 writing systems and hundreds of languages,
including all commercially-important modern languages.  All characters
in the largest Chinese, Japanese, and Korean dictionaries are also
encoded. The standards will eventually cover almost all characters in
more than 250 writing systems and thousands of languages.
Unicode 1.0 was released in October 1991, and 6.0 in October 2010.

A Unicode I<character> is an abstract entity.  It is not bound to any
particular integer width, especially not to the C language C<char>.
Unicode is language-neutral and display-neutral: it does not encode the
language of the text, and it does not generally define fonts or other graphical
layout details.  Unicode operates on characters and on text built from
those characters.

Unicode defines characters like C<LATIN CAPITAL LETTER A> or C<GREEK
SMALL LETTER ALPHA> and unique numbers for the characters, in this
case 0x0041 and 0x03B1, respectively.  These unique numbers are called
I<code points>.  A code point is essentially the position of the
character within the set of all possible Unicode characters, and thus in
Perl, the term I<ordinal> is often used interchangeably with it.

The Unicode standard prefers using hexadecimal notation for the code
points.  If numbers like C<0x0041> are unfamiliar to you, take a peek
at a later section, L</"Hexadecimal Notation">.  The Unicode standard
uses the notation C<U+0041 LATIN CAPITAL LETTER A>, to give the
hexadecimal code point and the normative name of the character.

Unicode also defines various I<properties> for the characters, like
"uppercase" or "lowercase", "decimal digit", or "punctuation";
these properties are independent of the names of the characters.
Furthermore, various operations on the characters like uppercasing,
lowercasing, and collating (sorting) are defined.

A Unicode I<logical> "character" can actually consist of more than one internal
I<actual> "character" or code point.  For Western languages, this is adequately
modelled by a I<base character> (like C<LATIN CAPITAL LETTER A>) followed
by one or more I<modifiers> (like C<COMBINING ACUTE ACCENT>).  This sequence of
base character and modifiers is called a I<combining character
sequence>.  Some non-western languages require more complicated
models, so Unicode created the I<grapheme cluster> concept, which was
later further refined into the I<extended grapheme cluster>.  For
example, a Korean Hangul syllable is considered a single logical
character, but most often consists of three actual
Unicode characters: a leading consonant followed by an interior vowel followed
by a trailing consonant.

Whether to call these extended grapheme clusters "characters" depends on your
point of view. If you are a programmer, you probably would tend towards seeing
each element in the sequences as one unit, or "character".  However from
the user's point of view, the whole sequence could be seen as one
"character" since that's probably what it looks like in the context of the
user's language.  In this document, we take the programmer's point of
view: one "character" is one Unicode code point.

For some combinations of base character and modifiers, there are
I<precomposed> characters.  There is a single character equivalent, for
example, for the sequence C<LATIN CAPITAL LETTER A> followed by
C<COMBINING ACUTE ACCENT>.  It is called  C<LATIN CAPITAL LETTER A WITH
ACUTE>.  These precomposed characters are, however, only available for
some combinations, and are mainly meant to support round-trip
conversions between Unicode and legacy standards (like ISO 8859).  Using
sequences, as Unicode does, allows for needing fewer basic building blocks
(code points) to express many more potential grapheme clusters.  To
support conversion between equivalent forms, various I<normalization
forms> are also defined.  Thus, C<LATIN CAPITAL LETTER A WITH ACUTE> is
in I<Normalization Form Composed>, (abbreviated NFC), and the sequence
C<LATIN CAPITAL LETTER A> followed by C<COMBINING ACUTE ACCENT>
represents the same character in I<Normalization Form Decomposed> (NFD).

Because of backward compatibility with legacy encodings, the "a unique
number for every character" idea breaks down a bit: instead, there is
"at least one number for every character".  The same character could
be represented differently in several legacy encodings.  The
converse is not true: some code points do not have an assigned
character.  Firstly, there are unallocated code points within
otherwise used blocks.  Secondly, there are special Unicode control
characters that do not represent true characters.

When Unicode was first conceived, it was thought that all the world's
characters could be represented using a 16-bit word; that is a maximum of
C<0x10000> (or 65,536) characters would be needed, from C<0x0000> to
C<0xFFFF>.  This soon proved to be wrong, and since Unicode 2.0 (July
1996), Unicode has been defined all the way up to 21 bits (C<0x10FFFF>),
and Unicode 3.1 (March 2001) defined the first characters above C<0xFFFF>.
The first C<0x10000> characters are called the I<Plane 0>, or the
I<Basic Multilingual Plane> (BMP).  With Unicode 3.1, 17 (yes,
seventeen) planes in all were defined--but they are nowhere near full of
defined characters, yet.

When a new language is being encoded, Unicode generally will choose a
C<block> of consecutive unallocated code points for its characters.  So
far, the number of code points in these blocks has always been evenly
divisible by 16.  Extras in a block, not currently needed, are left
unallocated, for future growth.  But there have been occasions when
a later release needed more code points than the available extras, and a
new block had to allocated somewhere else, not contiguous to the initial
one, to handle the overflow.  Thus, it became apparent early on that
"block" wasn't an adequate organizing principal, and so the C<Script>
property was created.  (Later an improved script property was added as
well, the C<Script_Extensions> property.)  Those code points that are in
overflow blocks can still
have the same script as the original ones.  The script concept fits more
closely with natural language: there is C<Latin> script, C<Greek>
script, and so on; and there are several artificial scripts, like
C<Common> for characters that are used in multiple scripts, such as
mathematical symbols.  Scripts usually span varied parts of several
blocks.  For more information about scripts, see L<perlunicode/Scripts>.
The division into blocks exists, but it is almost completely
accidental--an artifact of how the characters have been and still are
allocated.  (Note that this paragraph has oversimplified things for the
sake of this being an introduction.  Unicode doesn't really encode
languages, but the writing systems for them--their scripts; and one
script can be used by many languages.  Unicode also encodes things that
aren't really about languages, such as symbols like C<BAGGAGE CLAIM>.)

The Unicode code points are just abstract numbers.  To input and
output these abstract numbers, the numbers must be I<encoded> or
I<serialised> somehow.  Unicode defines several I<character encoding
forms>, of which I<UTF-8> is the most popular.  UTF-8 is a
variable length encoding that encodes Unicode characters as 1 to 4
bytes.  Other encodings
include UTF-16 and UTF-32 and their big- and little-endian variants
(UTF-8 is byte-order independent).  The ISO/IEC 10646 defines the UCS-2
and UCS-4 encoding forms.

For more information about encodings--for instance, to learn what
I<surrogates> and I<byte order marks> (BOMs) are--see L<perlunicode>.

=head2 Perl's Unicode Support

Starting from Perl v5.6.0, Perl has had the capacity to handle Unicode
natively.  Perl v5.8.0, however, is the first recommended release for
serious Unicode work.  The maintenance release 5.6.1 fixed many of the
problems of the initial Unicode implementation, but for example
regular expressions still do not work with Unicode in 5.6.1.
Perl v5.14.0 is the first release where Unicode support is
(almost) seamlessly integrable without some gotchas (the exception being
some differences in L<quotemeta|perlfunc/quotemeta>, and that is fixed
starting in Perl 5.16.0).   To enable this
seamless support, you should C<use feature 'unicode_strings'> (which is
automatically selected if you C<use 5.012> or higher).  See L<feature>.
(5.14 also fixes a number of bugs and departures from the Unicode
standard.)

Before Perl v5.8.0, the use of C<use utf8> was used to declare
that operations in the current block or file would be Unicode-aware.
This model was found to be wrong, or at least clumsy: the "Unicodeness"
is now carried with the data, instead of being attached to the
operations.
Starting with Perl v5.8.0, only one case remains where an explicit C<use
utf8> is needed: if your Perl script itself is encoded in UTF-8, you can
use UTF-8 in your identifier names, and in string and regular expression
literals, by saying C<use utf8>.  This is not the default because
scripts with legacy 8-bit data in them would break.  See L<utf8>.

=head2 Perl's Unicode Model

Perl supports both pre-5.6 strings of eight-bit native bytes, and
strings of Unicode characters.  The general principle is that Perl tries
to keep its data as eight-bit bytes for as long as possible, but as soon
as Unicodeness cannot be avoided, the data is transparently upgraded
to Unicode.  Prior to Perl v5.14.0, the upgrade was not completely
transparent (see L<perlunicode/The "Unicode Bug">), and for backwards
compatibility, full transparency is not gained unless C<use feature
'unicode_strings'> (see L<feature>) or C<use 5.012> (or higher) is
selected.

Internally, Perl currently uses either whatever the native eight-bit
character set of the platform (for example Latin-1) is, defaulting to
UTF-8, to encode Unicode strings. Specifically, if all code points in
the string are C<0xFF> or less, Perl uses the native eight-bit
character set.  Otherwise, it uses UTF-8.

A user of Perl does not normally need to know nor care how Perl
happens to encode its internal strings, but it becomes relevant when
outputting Unicode strings to a stream without a PerlIO layer (one with
the "default" encoding).  In such a case, the raw bytes used internally
(the native character set or UTF-8, as appropriate for each string)
will be used, and a "Wide character" warning will be issued if those
strings contain a character beyond 0x00FF.

For example,

      perl -e 'print "\x{DF}\n", "\x{0100}\x{DF}\n"'

produces a fairly useless mixture of native bytes and UTF-8, as well
as a warning:

     Wide character in print at ...

To output UTF-8, use the C<:encoding> or C<:utf8> output layer.  Prepending

      binmode(STDOUT, ":utf8");

to this sample program ensures that the output is completely UTF-8,
and removes the program's warning.

You can enable automatic UTF-8-ification of your standard file
handles, default C<open()> layer, and C<@@ARGV> by using either
the C<-C> command line switch or the C<PERL_UNICODE> environment
variable, see L<perlrun> for the documentation of the C<-C> switch.

Note that this means that Perl expects other software to work the same
way:
if Perl has been led to believe that STDIN should be UTF-8, but then
STDIN coming in from another command is not UTF-8, Perl will likely
complain about the malformed UTF-8.

All features that combine Unicode and I/O also require using the new
PerlIO feature.  Almost all Perl 5.8 platforms do use PerlIO, though:
you can see whether yours is by running "perl -V" and looking for
C<useperlio=define>.

=head2 Unicode and EBCDIC

Perl 5.8.0 added support for Unicode on EBCDIC platforms.  This support
was allowed to lapse in later releases, but was revived in 5.22.
Unicode support is somewhat more complex to implement since additional
conversions are needed.  See L<perlebcdic> for more information.

On EBCDIC platforms, the internal Unicode encoding form is UTF-EBCDIC
instead of UTF-8.  The difference is that as UTF-8 is "ASCII-safe" in
that ASCII characters encode to UTF-8 as-is, while UTF-EBCDIC is
"EBCDIC-safe", in that all the basic characters (which includes all
those that have ASCII equivalents (like C<"A">, C<"0">, C<"%">, I<etc.>)
are the same in both EBCDIC and UTF-EBCDIC.  Often, documentation
will use the term "UTF-8" to mean UTF-EBCDIC as well.  This is the case
in this document.

=head2 Creating Unicode

This section applies fully to Perls starting with v5.22.  Various
caveats for earlier releases are in the L</Earlier releases caveats>
subsection below.

To create Unicode characters in literals,
use the C<\N{...}> notation in double-quoted strings:

 my $smiley_from_name = "\N{WHITE SMILING FACE}";
 my $smiley_from_code_point = "\N{U+263a}";

Similarly, they can be used in regular expression literals

 $smiley =~ /\N{WHITE SMILING FACE}/;
 $smiley =~ /\N{U+263a}/;

At run-time you can use:

 use charnames ();
 my $hebrew_alef_from_name
                      = charnames::string_vianame("HEBREW LETTER ALEF");
 my $hebrew_alef_from_code_point = charnames::string_vianame("U+05D0");

Naturally, C<ord()> will do the reverse: it turns a character into
a code point.

There are other runtime options as well.  You can use C<pack()>:

 my $hebrew_alef_from_code_point = pack("U", 0x05d0);

Or you can use C<chr()>, though it is less convenient in the general
case:

 $hebrew_alef_from_code_point = chr(utf8::unicode_to_native(0x05d0));
 utf8::upgrade($hebrew_alef_from_code_point);

The C<utf8::unicode_to_native()> and C<utf8::upgrade()> aren't needed if
the argument is above 0xFF, so the above could have been written as

 $hebrew_alef_from_code_point = chr(0x05d0);

since 0x5d0 is above 255.

C<\x{}> and C<\o{}> can also be used to specify code points at compile
time in double-quotish strings, but, for backward compatibility with
older Perls, the same rules apply as with C<chr()> for code points less
than 256.

C<utf8::unicode_to_native()> is used so that the Perl code is portable
to EBCDIC platforms.  You can omit it if you're I<really> sure no one
will ever want to use your code on a non-ASCII platform.  Starting in
Perl v5.22, calls to it on ASCII platforms are optimized out, so there's
no performance penalty at all in adding it.  Or you can simply use the
other constructs that don't require it.

See L</"Further Resources"> for how to find all these names and numeric
codes.

=head3 Earlier releases caveats

On EBCDIC platforms, prior to v5.22, using C<\N{U+...}> doesn't work
properly.

Prior to v5.16, using C<\N{...}> with a character name (as opposed to a
C<U+...> code point) required a S<C<use charnames :full>>.

Prior to v5.14, there were some bugs in C<\N{...}> with a character name
(as opposed to a C<U+...> code point).

C<charnames::string_vianame()> was introduced in v5.14.  Prior to that,
C<charnames::vianame()> should work, but only if the argument is of the
form C<"U+...">.  Your best bet there for runtime Unicode by character
name is probably:

 use charnames ();
 my $hebrew_alef_from_name
                  = pack("U", charnames::vianame("HEBREW LETTER ALEF"));

=head2 Handling Unicode

Handling Unicode is for the most part transparent: just use the
strings as usual.  Functions like C<index()>, C<length()>, and
C<substr()> will work on the Unicode characters; regular expressions
will work on the Unicode characters (see L<perlunicode> and L<perlretut>).

Note that Perl considers grapheme clusters to be separate characters, so for
example

 print length("\N{LATIN CAPITAL LETTER A}\N{COMBINING ACUTE ACCENT}"),
       "\n";

will print 2, not 1.  The only exception is that regular expressions
have C<\X> for matching an extended grapheme cluster.  (Thus C<\X> in a
regular expression would match the entire sequence of both the example
characters.)

Life is not quite so transparent, however, when working with legacy
encodings, I/O, and certain special cases:

=head2 Legacy Encodings

When you combine legacy data and Unicode, the legacy data needs
to be upgraded to Unicode.  Normally the legacy data is assumed to be
ISO 8859-1 (or EBCDIC, if applicable).

The C<Encode> module knows about many encodings and has interfaces
for doing conversions between those encodings:

    use Encode 'decode';
    $data = decode("iso-8859-3", $data); # convert from legacy to utf-8

=head2 Unicode I/O

Normally, writing out Unicode data

    print FH $some_string_with_unicode, "\n";

produces raw bytes that Perl happens to use to internally encode the
Unicode string.  Perl's internal encoding depends on the system as
well as what characters happen to be in the string at the time. If
any of the characters are at code points C<0x100> or above, you will get
a warning.  To ensure that the output is explicitly rendered in the
encoding you desire--and to avoid the warning--open the stream with
the desired encoding. Some examples:

    open FH, ">:utf8", "file";

    open FH, ">:encoding(ucs2)",      "file";
    open FH, ">:encoding(UTF-8)",     "file";
    open FH, ">:encoding(shift_jis)", "file";

and on already open streams, use C<binmode()>:

    binmode(STDOUT, ":utf8");

    binmode(STDOUT, ":encoding(ucs2)");
    binmode(STDOUT, ":encoding(UTF-8)");
    binmode(STDOUT, ":encoding(shift_jis)");

The matching of encoding names is loose: case does not matter, and
many encodings have several aliases.  Note that the C<:utf8> layer
must always be specified exactly like that; it is I<not> subject to
the loose matching of encoding names. Also note that currently C<:utf8> is unsafe for
input, because it accepts the data without validating that it is indeed valid
UTF-8; you should instead use C<:encoding(utf-8)> (with or without a
hyphen).

See L<PerlIO> for the C<:utf8> layer, L<PerlIO::encoding> and
L<Encode::PerlIO> for the C<:encoding()> layer, and
L<Encode::Supported> for many encodings supported by the C<Encode>
module.

Reading in a file that you know happens to be encoded in one of the
Unicode or legacy encodings does not magically turn the data into
Unicode in Perl's eyes.  To do that, specify the appropriate
layer when opening files

    open(my $fh,'<:encoding(utf8)', 'anything');
    my $line_of_unicode = <$fh>;

    open(my $fh,'<:encoding(Big5)', 'anything');
    my $line_of_unicode = <$fh>;

The I/O layers can also be specified more flexibly with
the C<open> pragma.  See L<open>, or look at the following example.

    use open ':encoding(utf8)'; # input/output default encoding will be
                                # UTF-8
    open X, ">file";
    print X chr(0x100), "\n";
    close X;
    open Y, "<file";
    printf "%#x\n", ord(<Y>); # this should print 0x100
    close Y;

With the C<open> pragma you can use the C<:locale> layer

    BEGIN { $ENV{LC_ALL} = $ENV{LANG} = 'ru_RU.KOI8-R' }
    # the :locale will probe the locale environment variables like
    # LC_ALL
    use open OUT => ':locale'; # russki parusski
    open(O, ">koi8");
    print O chr(0x430); # Unicode CYRILLIC SMALL LETTER A = KOI8-R 0xc1
    close O;
    open(I, "<koi8");
    printf "%#x\n", ord(<I>), "\n"; # this should print 0xc1
    close I;

These methods install a transparent filter on the I/O stream that
converts data from the specified encoding when it is read in from the
stream.  The result is always Unicode.

The L<open> pragma affects all the C<open()> calls after the pragma by
setting default layers.  If you want to affect only certain
streams, use explicit layers directly in the C<open()> call.

You can switch encodings on an already opened stream by using
C<binmode()>; see L<perlfunc/binmode>.

The C<:locale> does not currently work with
C<open()> and C<binmode()>, only with the C<open> pragma.  The
C<:utf8> and C<:encoding(...)> methods do work with all of C<open()>,
C<binmode()>, and the C<open> pragma.

Similarly, you may use these I/O layers on output streams to
automatically convert Unicode to the specified encoding when it is
written to the stream. For example, the following snippet copies the
contents of the file "text.jis" (encoded as ISO-2022-JP, aka JIS) to
the file "text.utf8", encoded as UTF-8:

    open(my $nihongo, '<:encoding(iso-2022-jp)', 'text.jis');
    open(my $unicode, '>:utf8',                  'text.utf8');
    while (<$nihongo>) { print $unicode $_ }

The naming of encodings, both by the C<open()> and by the C<open>
pragma allows for flexible names: C<koi8-r> and C<KOI8R> will both be
understood.

Common encodings recognized by ISO, MIME, IANA, and various other
standardisation organisations are recognised; for a more detailed
list see L<Encode::Supported>.

C<read()> reads characters and returns the number of characters.
C<seek()> and C<tell()> operate on byte counts, as do C<sysread()>
and C<sysseek()>.

Notice that because of the default behaviour of not doing any
conversion upon input if there is no default layer,
it is easy to mistakenly write code that keeps on expanding a file
by repeatedly encoding the data:

    # BAD CODE WARNING
    open F, "file";
    local $/; ## read in the whole file of 8-bit characters
    $t = <F>;
    close F;
    open F, ">:encoding(utf8)", "file";
    print F $t; ## convert to UTF-8 on output
    close F;

If you run this code twice, the contents of the F<file> will be twice
UTF-8 encoded.  A C<use open ':encoding(utf8)'> would have avoided the
bug, or explicitly opening also the F<file> for input as UTF-8.

B<NOTE>: the C<:utf8> and C<:encoding> features work only if your
Perl has been built with L<PerlIO>, which is the default
on most systems.

=head2 Displaying Unicode As Text

Sometimes you might want to display Perl scalars containing Unicode as
simple ASCII (or EBCDIC) text.  The following subroutine converts
its argument so that Unicode characters with code points greater than
255 are displayed as C<\x{...}>, control characters (like C<\n>) are
displayed as C<\x..>, and the rest of the characters as themselves:

 sub nice_string {
        join("",
        map { $_ > 255                    # if wide character...
              ? sprintf("\\x{%04X}", $_)  # \x{...}
              : chr($_) =~ /[[:cntrl:]]/  # else if control character...
                ? sprintf("\\x%02X", $_)  # \x..
                : quotemeta(chr($_))      # else quoted or as themselves
        } unpack("W*", $_[0]));           # unpack Unicode characters
   }

For example,

   nice_string("foo\x{100}bar\n")

returns the string

   'foo\x{0100}bar\x0A'

which is ready to be printed.

(C<\\x{}> is used here instead of C<\\N{}>, since it's most likely that
you want to see what the native values are.)

=head2 Special Cases

=over 4

=item *

Bit Complement Operator ~ And vec()

The bit complement operator C<~> may produce surprising results if
used on strings containing characters with ordinal values above
255. In such a case, the results are consistent with the internal
encoding of the characters, but not with much else. So don't do
that. Similarly for C<vec()>: you will be operating on the
internally-encoded bit patterns of the Unicode characters, not on
the code point values, which is very probably not what you want.

=item *

Peeking At Perl's Internal Encoding

Normal users of Perl should never care how Perl encodes any particular
Unicode string (because the normal ways to get at the contents of a
string with Unicode--via input and output--should always be via
explicitly-defined I/O layers). But if you must, there are two
ways of looking behind the scenes.

One way of peeking inside the internal encoding of Unicode characters
is to use C<unpack("C*", ...> to get the bytes of whatever the string
encoding happens to be, or C<unpack("U0..", ...)> to get the bytes of the
UTF-8 encoding:

    # this prints  c4 80  for the UTF-8 bytes 0xc4 0x80
    print join(" ", unpack("U0(H2)*", pack("U", 0x100))), "\n";

Yet another way would be to use the Devel::Peek module:

    perl -MDevel::Peek -e 'Dump(chr(0x100))'

That shows the C<UTF8> flag in FLAGS and both the UTF-8 bytes
and Unicode characters in C<PV>.  See also later in this document
the discussion about the C<utf8::is_utf8()> function.

=back

=head2 Advanced Topics

=over 4

=item *

String Equivalence

The question of string equivalence turns somewhat complicated
in Unicode: what do you mean by "equal"?

(Is C<LATIN CAPITAL LETTER A WITH ACUTE> equal to
C<LATIN CAPITAL LETTER A>?)

The short answer is that by default Perl compares equivalence (C<eq>,
C<ne>) based only on code points of the characters.  In the above
case, the answer is no (because 0x00C1 != 0x0041).  But sometimes, any
CAPITAL LETTER A's should be considered equal, or even A's of any case.

The long answer is that you need to consider character normalization
and casing issues: see L<Unicode::Normalize>, Unicode Technical Report #15,
L<Unicode Normalization Forms|http://www.unicode.org/unicode/reports/tr15> and
sections on case mapping in the L<Unicode Standard|http://www.unicode.org>.

As of Perl 5.8.0, the "Full" case-folding of I<Case
Mappings/SpecialCasing> is implemented, but bugs remain in C<qr//i> with them,
mostly fixed by 5.14, and essentially entirely by 5.18.

=item *

String Collation

People like to see their strings nicely sorted--or as Unicode
parlance goes, collated.  But again, what do you mean by collate?

(Does C<LATIN CAPITAL LETTER A WITH ACUTE> come before or after
C<LATIN CAPITAL LETTER A WITH GRAVE>?)

The short answer is that by default, Perl compares strings (C<lt>,
C<le>, C<cmp>, C<ge>, C<gt>) based only on the code points of the
characters.  In the above case, the answer is "after", since
C<0x00C1> > C<0x00C0>.

The long answer is that "it depends", and a good answer cannot be
given without knowing (at the very least) the language context.
See L<Unicode::Collate>, and I<Unicode Collation Algorithm>
L<http://www.unicode.org/unicode/reports/tr10/>

=back

=head2 Miscellaneous

=over 4

=item *

Character Ranges and Classes

Character ranges in regular expression bracketed character classes ( e.g.,
C</[a-z]/>) and in the C<tr///> (also known as C<y///>) operator are not
magically Unicode-aware.  What this means is that C<[A-Za-z]> will not
magically start to mean "all alphabetic letters" (not that it does mean that
even for 8-bit characters; for those, if you are using locales (L<perllocale>),
use C</[[:alpha:]]/>; and if not, use the 8-bit-aware property C<\p{alpha}>).

All the properties that begin with C<\p> (and its inverse C<\P>) are actually
character classes that are Unicode-aware.  There are dozens of them, see
L<perluniprops>.

Starting in v5.22, you can use Unicode code points as the end points of
regular expression pattern character ranges, and the range will include
all Unicode code points that lie between those end points, inclusive.

 qr/ [\N{U+03]-\N{U+20}] /x

includes the code points
C<\N{U+03}>, C<\N{U+04}>, ..., C<\N{U+20}>.

(It is planned to extend this behavior to ranges in C<tr///> in Perl
v5.24.)

=item *

String-To-Number Conversions

Unicode does define several other decimal--and numeric--characters
besides the familiar 0 to 9, such as the Arabic and Indic digits.
Perl does not support string-to-number conversion for digits other
than ASCII C<0> to C<9> (and ASCII C<a> to C<f> for hexadecimal).
To get safe conversions from any Unicode string, use
L<Unicode::UCD/num()>.

=back

=head2 Questions With Answers

=over 4

=item *

Will My Old Scripts Break?

Very probably not.  Unless you are generating Unicode characters
somehow, old behaviour should be preserved.  About the only behaviour
that has changed and which could start generating Unicode is the old
behaviour of C<chr()> where supplying an argument more than 255
produced a character modulo 255.  C<chr(300)>, for example, was equal
to C<chr(45)> or "-" (in ASCII), now it is LATIN CAPITAL LETTER I WITH
BREVE.

=item *

How Do I Make My Scripts Work With Unicode?

Very little work should be needed since nothing changes until you
generate Unicode data.  The most important thing is getting input as
Unicode; for that, see the earlier I/O discussion.
To get full seamless Unicode support, add
C<use feature 'unicode_strings'> (or C<use 5.012> or higher) to your
script.

=item *

How Do I Know Whether My String Is In Unicode?

You shouldn't have to care.  But you may if your Perl is before 5.14.0
or you haven't specified C<use feature 'unicode_strings'> or C<use
5.012> (or higher) because otherwise the rules for the code points
in the range 128 to 255 are different depending on
whether the string they are contained within is in Unicode or not.
(See L<perlunicode/When Unicode Does Not Happen>.)

To determine if a string is in Unicode, use:

    print utf8::is_utf8($string) ? 1 : 0, "\n";

But note that this doesn't mean that any of the characters in the
string are necessary UTF-8 encoded, or that any of the characters have
code points greater than 0xFF (255) or even 0x80 (128), or that the
string has any characters at all.  All the C<is_utf8()> does is to
return the value of the internal "utf8ness" flag attached to the
C<$string>.  If the flag is off, the bytes in the scalar are interpreted
as a single byte encoding.  If the flag is on, the bytes in the scalar
are interpreted as the (variable-length, potentially multi-byte) UTF-8 encoded
code points of the characters.  Bytes added to a UTF-8 encoded string are
automatically upgraded to UTF-8.  If mixed non-UTF-8 and UTF-8 scalars
are merged (double-quoted interpolation, explicit concatenation, or
printf/sprintf parameter substitution), the result will be UTF-8 encoded
as if copies of the byte strings were upgraded to UTF-8: for example,

    $a = "ab\x80c";
    $b = "\x{100}";
    print "$a = $b\n";

the output string will be UTF-8-encoded C<ab\x80c = \x{100}\n>, but
C<$a> will stay byte-encoded.

Sometimes you might really need to know the byte length of a string
instead of the character length. For that use either the
C<Encode::encode_utf8()> function or the C<bytes> pragma
and the C<length()> function:

    my $unicode = chr(0x100);
    print length($unicode), "\n"; # will print 1
    require Encode;
    print length(Encode::encode_utf8($unicode)),"\n"; # will print 2
    use bytes;
    print length($unicode), "\n"; # will also print 2
                                  # (the 0xC4 0x80 of the UTF-8)
    no bytes;

=item *

How Do I Find Out What Encoding a File Has?

You might try L<Encode::Guess>, but it has a number of limitations.

=item *

How Do I Detect Data That's Not Valid In a Particular Encoding?

Use the C<Encode> package to try converting it.
For example,

    use Encode 'decode_utf8';

    if (eval { decode_utf8($string, Encode::FB_CROAK); 1 }) {
        # $string is valid utf8
    } else {
        # $string is not valid utf8
    }

Or use C<unpack> to try decoding it:

    use warnings;
    @@chars = unpack("C0U*", $string_of_bytes_that_I_think_is_utf8);

If invalid, a C<Malformed UTF-8 character> warning is produced. The "C0" means
"process the string character per character".  Without that, the
C<unpack("U*", ...)> would work in C<U0> mode (the default if the format
string starts with C<U>) and it would return the bytes making up the UTF-8
encoding of the target string, something that will always work.

=item *

How Do I Convert Binary Data Into a Particular Encoding, Or Vice Versa?

This probably isn't as useful as you might think.
Normally, you shouldn't need to.

In one sense, what you are asking doesn't make much sense: encodings
are for characters, and binary data are not "characters", so converting
"data" into some encoding isn't meaningful unless you know in what
character set and encoding the binary data is in, in which case it's
not just binary data, now is it?

If you have a raw sequence of bytes that you know should be
interpreted via a particular encoding, you can use C<Encode>:

    use Encode 'from_to';
    from_to($data, "iso-8859-1", "utf-8"); # from latin-1 to utf-8

The call to C<from_to()> changes the bytes in C<$data>, but nothing
material about the nature of the string has changed as far as Perl is
concerned.  Both before and after the call, the string C<$data>
contains just a bunch of 8-bit bytes. As far as Perl is concerned,
the encoding of the string remains as "system-native 8-bit bytes".

You might relate this to a fictional 'Translate' module:

   use Translate;
   my $phrase = "Yes";
   Translate::from_to($phrase, 'english', 'deutsch');
   ## phrase now contains "Ja"

The contents of the string changes, but not the nature of the string.
Perl doesn't know any more after the call than before that the
contents of the string indicates the affirmative.

Back to converting data.  If you have (or want) data in your system's
native 8-bit encoding (e.g. Latin-1, EBCDIC, etc.), you can use
pack/unpack to convert to/from Unicode.

    $native_string  = pack("W*", unpack("U*", $Unicode_string));
    $Unicode_string = pack("U*", unpack("W*", $native_string));

If you have a sequence of bytes you B<know> is valid UTF-8,
but Perl doesn't know it yet, you can make Perl a believer, too:

    use Encode 'decode_utf8';
    $Unicode = decode_utf8($bytes);

or:

    $Unicode = pack("U0a*", $bytes);

You can find the bytes that make up a UTF-8 sequence with

    @@bytes = unpack("C*", $Unicode_string)

and you can create well-formed Unicode with

    $Unicode_string = pack("U*", 0xff, ...)

=item *

How Do I Display Unicode?  How Do I Input Unicode?

See L<http://www.alanwood.net/unicode/> and
L<http://www.cl.cam.ac.uk/~mgk25/unicode.html>

=item *

How Does Unicode Work With Traditional Locales?

If your locale is a UTF-8 locale, starting in Perl v5.20, Perl works
well for all categories except C<LC_COLLATE> dealing with sorting and
the C<cmp> operator.

For other locales, starting in Perl 5.16, you can specify

    use locale ':not_characters';

to get Perl to work well with them.  The catch is that you
have to translate from the locale character set to/from Unicode
yourself.  See L</Unicode IE<sol>O> above for how to

    use open ':locale';

to accomplish this, but full details are in L<perllocale/Unicode and
UTF-8>, including gotchas that happen if you don't specify
C<:not_characters>.

=back

=head2 Hexadecimal Notation

The Unicode standard prefers using hexadecimal notation because
that more clearly shows the division of Unicode into blocks of 256 characters.
Hexadecimal is also simply shorter than decimal.  You can use decimal
notation, too, but learning to use hexadecimal just makes life easier
with the Unicode standard.  The C<U+HHHH> notation uses hexadecimal,
for example.

The C<0x> prefix means a hexadecimal number, the digits are 0-9 I<and>
a-f (or A-F, case doesn't matter).  Each hexadecimal digit represents
four bits, or half a byte.  C<print 0x..., "\n"> will show a
hexadecimal number in decimal, and C<printf "%x\n", $decimal> will
show a decimal number in hexadecimal.  If you have just the
"hex digits" of a hexadecimal number, you can use the C<hex()> function.

    print 0x0009, "\n";    # 9
    print 0x000a, "\n";    # 10
    print 0x000f, "\n";    # 15
    print 0x0010, "\n";    # 16
    print 0x0011, "\n";    # 17
    print 0x0100, "\n";    # 256

    print 0x0041, "\n";    # 65

    printf "%x\n",  65;    # 41
    printf "%#x\n", 65;    # 0x41

    print hex("41"), "\n"; # 65

=head2 Further Resources

=over 4

=item *

Unicode Consortium

L<http://www.unicode.org/>

=item *

Unicode FAQ

L<http://www.unicode.org/unicode/faq/>

=item *

Unicode Glossary

L<http://www.unicode.org/glossary/>

=item *

Unicode Recommended Reading List

The Unicode Consortium has a list of articles and books, some of which
give a much more in depth treatment of Unicode:
L<http://unicode.org/resources/readinglist.html>

=item *

Unicode Useful Resources

L<http://www.unicode.org/unicode/onlinedat/resources.html>

=item *

Unicode and Multilingual Support in HTML, Fonts, Web Browsers and Other Applications

L<http://www.alanwood.net/unicode/>

=item *

UTF-8 and Unicode FAQ for Unix/Linux

L<http://www.cl.cam.ac.uk/~mgk25/unicode.html>

=item *

Legacy Character Sets

L<http://www.czyborra.com/>
L<http://www.eki.ee/letter/>

=item *

You can explore various information from the Unicode data files using
the C<Unicode::UCD> module.

=back

=head1 UNICODE IN OLDER PERLS

If you cannot upgrade your Perl to 5.8.0 or later, you can still
do some Unicode processing by using the modules C<Unicode::String>,
C<Unicode::Map8>, and C<Unicode::Map>, available from CPAN.
If you have the GNU recode installed, you can also use the
Perl front-end C<Convert::Recode> for character conversions.

The following are fast conversions from ISO 8859-1 (Latin-1) bytes
to UTF-8 bytes and back, the code works even with older Perl 5 versions.

    # ISO 8859-1 to UTF-8
    s/([\x80-\xFF])/chr(0xC0|ord($1)>>6).chr(0x80|ord($1)&0x3F)/eg;

    # UTF-8 to ISO 8859-1
    s/([\xC2\xC3])([\x80-\xBF])/chr(ord($1)<<6&0xC0|ord($2)&0x3F)/eg;

=head1 SEE ALSO

L<perlunitut>, L<perlunicode>, L<Encode>, L<open>, L<utf8>, L<bytes>,
L<perlretut>, L<perlrun>, L<Unicode::Collate>, L<Unicode::Normalize>,
L<Unicode::UCD>

=head1 ACKNOWLEDGMENTS

Thanks to the kind readers of the perl5-porters@@perl.org,
perl-unicode@@perl.org, linux-utf8@@nl.linux.org, and unicore@@unicode.org
mailing lists for their valuable feedback.

=head1 AUTHOR, COPYRIGHT, AND LICENSE

Copyright 2001-2011 Jarkko Hietaniemi E<lt>jhi@@iki.fiE<gt>.
Now maintained by Perl 5 Porters.

This document may be distributed under the same terms as Perl itself.
@


1.1
log
@Initial revision
@
text
@d8 2
a9 1
in Perl.
d16 3
a18 3
Unicode and ISO/IEC 10646 are coordinated standards that provide code
points for characters in almost all modern character set standards,
covering more than 30 writing systems and hundreds of languages,
d23 1
d28 1
a28 1
language of the text and it does not define fonts or other graphical
d35 3
a37 1
I<code points>.
d40 4
a43 5
points.  If numbers like C<0x0041> are unfamiliar to
you, take a peek at a later section, L</"Hexadecimal Notation">.
The Unicode standard uses the notation C<U+0041 LATIN CAPITAL LETTER A>,
to give the hexadecimal code point and the normative name of
the character.
d51 4
a54 3
A Unicode character consists either of a single code point, or a
I<base character> (like C<LATIN CAPITAL LETTER A>), followed by one or
more I<modifiers> (like C<COMBINING ACUTE ACCENT>).  This sequence of
d56 30
a85 25
sequence>.

Whether to call these combining character sequences "characters"
depends on your point of view. If you are a programmer, you probably
would tend towards seeing each element in the sequences as one unit,
or "character".  The whole sequence could be seen as one "character",
however, from the user's point of view, since that's probably what it
looks like in the context of the user's language.

With this "whole sequence" view of characters, the total number of
characters is open-ended. But in the programmer's "one unit is one
character" point of view, the concept of "characters" is more
deterministic.  In this document, we take that second  point of view:
one "character" is one Unicode code point, be it a base character or
a combining character.

For some combinations, there are I<precomposed> characters.
C<LATIN CAPITAL LETTER A WITH ACUTE>, for example, is defined as
a single code point.  These precomposed characters are, however,
only available for some combinations, and are mainly
meant to support round-trip conversions between Unicode and legacy
standards (like the ISO 8859).  In the general case, the composing
method is more extensible.  To support conversion between
different compositions of the characters, various I<normalization
forms> to standardize representations are also defined.
d91 1
a91 1
converse is also not true: some code points do not have an assigned
d96 29
a124 12
A common myth about Unicode is that it would be "16-bit", that is,
Unicode is only represented as C<0x10000> (or 65536) characters from
C<0x0000> to C<0xFFFF>.  B<This is untrue.> Since Unicode 2.0, Unicode
has been defined all the way up to 21 bits (C<0x10FFFF>), and since
Unicode 3.1, characters have been defined beyond C<0xFFFF>.  The first
C<0x10000> characters are called the I<Plane 0>, or the I<Basic
Multilingual Plane> (BMP).  With Unicode 3.1, 17 planes in all are
defined--but nowhere near full of defined characters, yet.

Another myth is that the 256-character blocks have something to
do with languages--that each block would define the characters used
by a language or a set of languages.  B<This is also untrue.>
d126 6
a131 5
accidental--an artifact of how the characters have been and
still are allocated.  Instead, there is a concept called I<scripts>,
which is more useful: there is C<Latin> script, C<Greek> script, and
so on.  Scripts usually span varied parts of several blocks.
For further information see L<Unicode::UCD>.
d134 8
a141 7
output these abstract numbers, the numbers must be I<encoded> somehow.
Unicode defines several I<character encoding forms>, of which I<UTF-8>
is perhaps the most popular.  UTF-8 is a variable length encoding that
encodes Unicode characters as 1 to 6 bytes (only 4 with the currently
defined characters).  Other encodings include UTF-16 and UTF-32 and their
big- and little-endian variants (UTF-8 is byte-order independent)
The ISO/IEC 10646 defines the UCS-2 and UCS-4 encoding forms.
d148 2
a149 2
Starting from Perl 5.6.0, Perl has had the capacity to handle Unicode
natively.  Perl 5.8.0, however, is the first recommended release for
d153 8
d162 1
a162 2
B<Starting from Perl 5.8.0, the use of C<use utf8> is no longer
necessary.> In earlier releases the C<utf8> pragma was used to declare
d166 4
a169 3
operations.  Only one case remains where an explicit C<use utf8> is
needed: if your Perl script itself is encoded in UTF-8, you can use
UTF-8 in your identifier names, and in string and regular expression
d176 2
a177 2
strings of Unicode characters.  The principle is that Perl tries to
keep its data as eight-bit bytes for as long as possible, but as soon
d179 5
a183 1
to Unicode.
d193 2
a194 2
outputting Unicode strings to a stream without a PerlIO layer -- one with
the "default" encoding.  In such a case, the raw bytes used internally
d201 1
a201 1
      perl -e 'print "\x{DF}\n", "\x{0100}\x{DF}\n"'              
d208 1
a208 1
To output UTF-8, use the C<:utf8> output layer.  Prepending
d215 10
a224 8
If your locale environment variables (C<LANGUAGE>, C<LC_ALL>,
C<LC_CTYPE>, C<LANG>) contain the strings 'UTF-8' or 'UTF8',
regardless of case, then the default encoding of your STDIN, STDOUT,
and STDERR and of B<any subsequent file open>, is UTF-8.  Note that
this means that Perl expects other software to work, too: if Perl has
been led to believe that STDIN should be UTF-8, but then STDIN coming
in from another command is not UTF-8, Perl will complain about the
malformed UTF-8.
d233 4
a236 4
Perl 5.8.0 also supports Unicode on EBCDIC platforms.  There,
Unicode support is somewhat more complex to implement since
additional conversions are needed at every step.  Some problems
remain, see L<perlebcdic> for details.
a237 2
In any case, the Unicode support on EBCDIC platforms is better than
in the 5.6 series, which didn't work much at all for EBCDIC platform.
d241 5
a245 1
"EBCDIC-safe".
d249 3
a251 2
To create Unicode characters in literals for code points above C<0xFF>,
use the C<\x{...}> notation in double-quoted strings:
d253 2
a254 1
    my $smiley = "\x{263a}";
d256 2
a257 1
Similarly, it can be used in regular expression literals
d259 1
a259 1
    $smiley =~ /\x{263a}/;
d261 2
a262 1
At run-time you can use C<chr()>:
d264 1
a264 1
    my $hebrew_alef = chr(0x05d0);
d266 4
a269 1
See L</"Further Resources"> for how to find all these numeric codes.
d274 14
a287 7
Note that C<\x..> (no C<{}> and only two hexadecimal digits), C<\x{...}>,
and C<chr(...)> for arguments less than C<0x100> (decimal 256)
generate an eight-bit character for backward compatibility with older
Perls.  For arguments of C<0x100> or more, Unicode characters are
always produced. If you want to force the production of Unicode
characters regardless of the numeric value, use C<pack("U", ...)>
instead of C<\x..>, C<\x{...}>, or C<chr()>.
d289 1
a289 2
You can also use the C<charnames> pragma to invoke characters
by name in double-quoted strings:
d291 4
a294 2
    use charnames ':full';
    my $arabic_alef = "\N{ARABIC LETTER ALEF}";
d296 6
a301 2
And, as mentioned above, you can also C<pack()> numbers into Unicode
characters:
d303 2
a304 1
   my $georgian_an  = pack("U", 0x10a0);
d306 1
a306 3
Note that both C<\x{...}> and C<\N{...}> are compile-time string
constants: you cannot use variables in them.  if you want similar
run-time functionality, use C<chr()> and C<charnames::vianame()>.
d308 2
a309 2
Also note that if all the code points for pack "U" are below 0x100,
bytes will be generated, just like if you were using C<chr()>.
d311 2
a312 1
   my $bytes = pack("U*", 0x80, 0xFF);
d314 2
a315 3
If you want to force the result to Unicode characters, use the special
C<"U0"> prefix.  It consumes no arguments but forces the result to be
in Unicode characters, instead of bytes.
d317 8
a324 1
   my $chars = pack("U0U*", 0x80, 0xFF);
d333 2
a334 2
Note that Perl considers combining character sequences to be
characters, so for example
d336 2
a337 2
    use charnames ':full';
    print length("\N{LATIN CAPITAL LETTER A}\N{COMBINING ACUTE ACCENT}"), "\n";
d340 3
a342 1
have C<\X> for matching a combining character sequence.
d349 3
a351 17
When you combine legacy data and Unicode the legacy data needs
to be upgraded to Unicode.  Normally ISO 8859-1 (or EBCDIC, if
applicable) is assumed.  You can override this assumption by
using the C<encoding> pragma, for example

    use encoding 'latin2'; # ISO 8859-2

in which case literals (string or regular expressions), C<chr()>,
and C<ord()> in your whole script are assumed to produce Unicode
characters from ISO 8859-2 code points.  Note that the matching for
encoding names is forgiving: instead of C<latin2> you could have
said C<Latin 2>, or C<iso8859-2>, or other variations.  With just

    use encoding;

the environment variable C<PERL_ENCODING> will be consulted.
If that variable isn't set, the encoding pragma will fail.
d356 2
a357 2
    use Encode 'from_to';
    from_to($data, "iso-8859-3", "utf-8"); # from legacy to utf-8
d390 4
a393 1
the loose matching of encoding names.
d405 1
a405 1
    open(my $fh,'<:utf8', 'anything');
d414 2
a415 1
    use open ':utf8'; # input and output default layer will be UTF-8
d425 3
a427 2
    $ENV{LC_ALL} = $ENV{LANG} = 'ru_RU.KOI8-R';
    # the :locale will probe the locale environment variables like LC_ALL
a435 5
or you can also use the C<':encoding(...)'> layer

    open(my $epic,'<:encoding(iso-8859-7)','iliad.greek');
    my $line_of_unicode = <$epic>;

d447 1
a447 1
The C<:locale> does not currently (as of Perl 5.8.0) work with
d458 3
a460 3
    open(my $nihongo, '<:encoding(iso2022-jp)', 'text.jis');
    open(my $unicode, '>:utf8',                 'text.utf8');
    while (<$nihongo>) { print $unicode }
d463 2
a464 2
pragma, is similar to the C<encoding> pragma in that it allows for
flexible names: C<koi8-r> and C<KOI8R> will both be understood.
d484 1
a484 1
    open F, ">:utf8", "file";
d489 2
a490 2
UTF-8 encoded.  A C<use open ':utf8'> would have avoided the bug, or
explicitly opening also the F<file> for input as UTF-8.
d493 2
a494 1
Perl has been built with the new PerlIO feature.
d504 8
a511 8
   sub nice_string {
       join("",
         map { $_ > 255 ?                  # if wide character...
               sprintf("\\x{%04X}", $_) :  # \x{...}
               chr($_) =~ /[[:cntrl:]]/ ?  # else if control character ...
               sprintf("\\x%02X", $_) :    # \x..
               chr($_)                     # else as themselves
         } unpack("U*", $_[0]));           # unpack Unicode characters
d518 5
a522 1
returns:
d524 2
a525 1
   "foo\x{0100}bar\x0A"
d554 3
a556 2
is to use C<unpack("C*", ...> to get the bytes or C<unpack("H*", ...)>
to display the bytes:
d559 1
a559 1
    print join(" ", unpack("H*", pack("U", 0x100))), "\n";
d565 1
a565 1
That shows the UTF8 flag in FLAGS and both the UTF-8 bytes
d567 1
a567 1
the discussion about the C<is_utf8> function of the C<Encode> module.
d588 1
a588 1
CAPITAL LETTER As should be considered equal, or even As of any case.
d591 3
a593 4
and casing issues: see L<Unicode::Normalize>, Unicode Technical
Reports #15 and #21, I<Unicode Normalization Forms> and I<Case
Mappings>, http://www.unicode.org/unicode/reports/tr15/ and 
http://www.unicode.org/unicode/reports/tr21/ 
d596 2
a597 1
Mappings/SpecialCasing> is implemented.
d617 1
a617 1
http://www.unicode.org/unicode/reports/tr10/
d629 22
a650 13
Character ranges in regular expression character classes (C</[a-z]/>)
and in the C<tr///> (also known as C<y///>) operator are not magically
Unicode-aware.  What this means that C<[A-Za-z]> will not magically start
to mean "all alphabetic letters"; not that it does mean that even for
8-bit characters, you should be using C</[[:alpha:]]/> in that case.

For specifying character classes like that in regular expressions,
you can use the various Unicode properties--C<\pL>, or perhaps
C<\p{Alphabetic}>, in this particular case.  You can use Unicode
code points as the end points of character ranges, but there is no
magic associated with specifying a certain range.  For further
information--there are dozens of Unicode character classes--see
L<perlunicode>.
d659 3
a661 1
than ASCII 0 to 9 (and ASCII a to f for hexadecimal).
d688 3
d696 6
a701 3
You shouldn't care.  No, you really shouldn't.  No, really.  If you
have to care--beyond the cases described above--it means that we
didn't get the transparency of Unicode quite right.
d703 1
a703 1
Okay, if you insist:
d705 1
a705 2
    use Encode 'is_utf8';
    print is_utf8($string) ? 1 : 0, "\n";
d714 4
a717 4
are interpreted as the (multi-byte, variable-length) UTF-8 encoded code
points of the characters.  Bytes added to an UTF-8 encoded string are
automatically upgraded to UTF-8.  If mixed non-UTF8 and UTF-8 scalars
are merged (double-quoted interpolation, explicit concatenation, and
d725 2
a726 2
the output string will be UTF-8-encoded C<ab\x80c\x{100}\n>, but note
that C<$a> will stay byte-encoded.
d730 2
a731 2
C<Encode::encode_utf8()> function or the C<bytes> pragma and its only
defined function C<length()>:
d736 1
a736 1
    print length(Encode::encode_utf8($unicode)), "\n"; # will print 2
d740 7
d755 4
a758 3
    use Encode 'encode_utf8';
    if (encode_utf8($string_of_bytes_that_I_think_is_utf8)) {
        # valid
d760 1
a760 1
        # invalid
d763 1
a763 1
For UTF-8 only, you can use:
d766 1
a766 1
    @@chars = unpack("U0U*", $string_of_bytes_that_I_think_is_utf8);
d768 5
a772 4
If invalid, a C<Malformed UTF-8 character (byte 0x##) in unpack>
warning is produced. The "U0" means "expect strictly UTF-8 encoded
Unicode".  Without that the C<unpack("U*", ...)> would accept also
data like C<chr(0xFF>), similarly to the C<pack> as we saw earlier.
d814 2
a815 2
    $native_string  = pack("C*", unpack("U*", $Unicode_string));
    $Unicode_string = pack("U*", unpack("C*", $native_string));
d823 11
a833 5
You can convert well-formed UTF-8 to a sequence of bytes, but if
you just want to convert random binary data into UTF-8, you can't.
B<Any random collection of bytes isn't well-formed UTF-8>.  You can
use C<unpack("C*", $string)> for the former, and you can create
well-formed Unicode data by C<pack("U*", 0xff, ...)>.
d839 2
a840 2
See http://www.alanwood.net/unicode/ and
http://www.cl.cam.ac.uk/~mgk25/unicode.html
d846 17
a862 2
In Perl, not very well.  Avoid using locales through the C<locale>
pragma.  Use only one or the other.
d904 1
a904 1
    http://www.unicode.org/
d910 1
a910 1
    http://www.unicode.org/unicode/faq/
d916 9
a924 1
    http://www.unicode.org/glossary/
d930 1
a930 1
    http://www.unicode.org/unicode/onlinedat/resources.html
d936 1
a936 1
    http://www.alanwood.net/unicode/
d942 1
a942 1
    http://www.cl.cam.ac.uk/~mgk25/unicode.html
d948 2
a949 2
    http://www.czyborra.com/
    http://www.eki.ee/letter/
a952 16
The Unicode support files live within the Perl installation in the
directory

    $Config{installprivlib}/unicore

in Perl 5.8.0 or newer, and 

    $Config{installprivlib}/unicode

in the Perl 5.6 series.  (The renaming to F<lib/unicore> was done to
avoid naming conflicts with lib/Unicode in case-insensitive filesystems.)
The main Unicode data file is F<UnicodeData.txt> (or F<Unicode.301> in
Perl 5.6.1.)  You can find the C<$Config{installprivlib}> by

    perl "-V:installprivlib"

d967 1
a967 1
to UTF-8 bytes, the code works even with older Perl 5 versions.
d977 3
a979 2
L<perlunicode>, L<Encode>, L<encoding>, L<open>, L<utf8>, L<bytes>,
L<perlretut>, L<Unicode::Collate>, L<Unicode::Normalize>, L<Unicode::UCD>
d989 2
a990 1
Copyright 2001-2002 Jarkko Hietaniemi <jhi@@iki.fi>
@


1.1.1.1
log
@stock perl 5.8.0 from CPAN
@
text
@@


1.1.1.2
log
@perl 5.8.2 from CPAN
@
text
@a21 1
Unicode 1.0 was released in October 1991, and 4.0 in April 2003.
d36 5
a40 4
points.  If numbers like C<0x0041> are unfamiliar to you, take a peek
at a later section, L</"Hexadecimal Notation">.  The Unicode standard
uses the notation C<U+0041 LATIN CAPITAL LETTER A>, to give the
hexadecimal code point and the normative name of the character.
d89 6
a94 7
C<0x0000> to C<0xFFFF>.  B<This is untrue.>  Since Unicode 2.0 (July
1996), Unicode has been defined all the way up to 21 bits (C<0x10FFFF>),
and since Unicode 3.1 (March 2001), characters have been defined
beyond C<0xFFFF>.  The first C<0x10000> characters are called the
I<Plane 0>, or the I<Basic Multilingual Plane> (BMP).  With Unicode
3.1, 17 (yes, seventeen) planes in all were defined--but they are
nowhere near full of defined characters, yet.
d107 7
a113 8
output these abstract numbers, the numbers must be I<encoded> or
I<serialised> somehow.  Unicode defines several I<character encoding
forms>, of which I<UTF-8> is perhaps the most popular.  UTF-8 is a
variable length encoding that encodes Unicode characters as 1 to 6
bytes (only 4 with the currently defined characters).  Other encodings
include UTF-16 and UTF-32 and their big- and little-endian variants
(UTF-8 is byte-order independent) The ISO/IEC 10646 defines the UCS-2
and UCS-4 encoding forms.
d175 8
a182 9
You can enable automatic UTF-8-ification of your standard file
handles, default C<open()> layer, and C<@@ARGV> by using either
the C<-C> command line switch or the C<PERL_UNICODE> environment
variable, see L<perlrun> for the documentation of the C<-C> switch.

Note that this means that Perl expects other software to work, too:
if Perl has been led to believe that STDIN should be UTF-8, but then
STDIN coming in from another command is not UTF-8, Perl will complain
about the malformed UTF-8.
d364 1
a364 1
    BEGIN { $ENV{LC_ALL} = $ENV{LANG} = 'ru_RU.KOI8-R' }
d401 3
a403 3
    open(my $nihongo, '<:encoding(iso-2022-jp)', 'text.jis');
    open(my $unicode, '>:utf8',                  'text.utf8');
    while (<$nihongo>) { print $unicode $_ }
d436 1
a436 2
Perl has been built with the new PerlIO feature (which is the default
on most systems).
d452 1
a452 1
               quotemeta(chr($_))          # else quoted or as themselves
d460 1
a460 1
returns the string
d462 1
a462 3
   'foo\x{0100}bar\x0A'

which is ready to be printed.
d501 1
a501 1
That shows the C<UTF8> flag in FLAGS and both the UTF-8 bytes
d503 1
a503 1
the discussion about the C<utf8::is_utf8()> function.
d624 2
a625 1
    print utf8::is_utf8($string) ? 1 : 0, "\n";
d636 1
a636 1
automatically upgraded to UTF-8.  If mixed non-UTF-8 and UTF-8 scalars
d645 2
a646 2
the output string will be UTF-8-encoded C<ab\x80c = \x{100}\n>, but
C<$a> will stay byte-encoded.
d752 1
a752 4
pragma.  Use only one or the other.  But see L<perlrun> for the
description of the C<-C> switch and its environment counterpart,
C<$ENV{PERL_UNICODE}> to see how to enable various Unicode features,
for example by using locale settings.
d865 1
a865 1
to UTF-8 bytes and back, the code works even with older Perl 5 versions.
d876 1
a876 2
L<perlretut>, L<perlrun>, L<Unicode::Collate>, L<Unicode::Normalize>,
L<Unicode::UCD>
d886 1
a886 1
Copyright 2001-2002 Jarkko Hietaniemi E<lt>jhi@@iki.fiE<gt>
@


1.1.1.3
log
@Import of stock perl 5.8.5
@
text
@d249 5
d258 1
a258 4
   my $chars = pack("U0C*", 0x80, 0x42);

Likewise, you can force the result to be bytes by using the special
C<"C0"> prefix.
d268 1
a268 1
separate characters, so for example
d302 2
a303 2
    use Encode 'decode';
    $data = decode("iso-8859-3", $data); # convert from legacy to utf-8
d673 2
a674 2
    use Encode 'decode_utf8';
    if (decode_utf8($string_of_bytes_that_I_think_is_utf8)) {
@


1.1.1.4
log
@import perl 5.10.0 from CPAN
@
text
@d163 1
a163 1
      perl -e 'print "\x{DF}\n", "\x{0100}\x{DF}\n"'
d170 1
a170 1
To output UTF-8, use the C<:encoding> or C<:utf8> output layer.  Prepending
d250 2
a251 2
C<"U0"> prefix.  It consumes no arguments but causes the following bytes
to be interpreted as the UTF-8 encoding of Unicode characters:
d253 1
a253 1
   my $chars = pack("U0W*", 0x80, 0x42);
d255 1
a255 1
Likewise, you can stop such UTF-8 interpretation by using the special
d281 15
a295 1
applicable) is assumed.
d334 1
a334 3
the loose matching of encoding names. Also note that C<:utf8> is unsafe for
input, because it accepts the data without validating that it is indeed valid
UTF8.
d346 1
a346 1
    open(my $fh,'<:encoding(utf8)', 'anything');
d355 1
a355 1
    use open ':encoding(utf8)'; # input/output default encoding will be UTF-8
d375 5
d407 2
a408 2
pragma allows for flexible names: C<koi8-r> and C<KOI8R> will both be
understood.
d428 1
a428 1
    open F, ">:encoding(utf8)", "file";
d433 2
a434 2
UTF-8 encoded.  A C<use open ':encoding(utf8)'> would have avoided the
bug, or explicitly opening also the F<file> for input as UTF-8.
d455 1
a455 1
         } unpack("W*", $_[0]));           # unpack Unicode characters
d495 2
a496 3
is to use C<unpack("C*", ...> to get the bytes of whatever the string
encoding happens to be, or C<unpack("U0..", ...)> to get the bytes of the
UTF-8 encoding:
d499 1
a499 1
    print join(" ", unpack("U0(H2)*", pack("U", 0x100))), "\n";
d533 2
a534 2
Mappings>, http://www.unicode.org/unicode/reports/tr15/ and
http://www.unicode.org/unicode/reports/tr21/
d672 2
a673 3
    eval { decode_utf8($string, Encode::FB_CROAK) };
    if ($@@) {
        # $string is valid utf8
d675 1
a675 1
        # $string is not valid utf8
d678 1
a678 1
Or use C<unpack> to try decoding it:
d681 1
a681 1
    @@chars = unpack("C0U*", $string_of_bytes_that_I_think_is_utf8);
d683 4
a686 5
If invalid, a C<Malformed UTF-8 character> warning is produced. The "C0" means
"process the string character per character".  Without that, the
C<unpack("U*", ...)> would work in C<U0> mode (the default if the format
string starts with C<U>) and it would return the bytes making up the UTF-8
encoding of the target string, something that will always work.
d728 2
a729 2
    $native_string  = pack("W*", unpack("U*", $Unicode_string));
    $Unicode_string = pack("U*", unpack("W*", $native_string));
a736 4
or:

    $Unicode = pack("U0a*", $bytes);

d800 1
a800 1
http://www.unicode.org/
d806 1
a806 1
http://www.unicode.org/unicode/faq/
d812 1
a812 1
http://www.unicode.org/glossary/
d818 1
a818 1
http://www.unicode.org/unicode/onlinedat/resources.html
d824 1
a824 1
http://www.alanwood.net/unicode/
d830 1
a830 1
http://www.cl.cam.ac.uk/~mgk25/unicode.html
d836 2
a837 2
http://www.czyborra.com/
http://www.eki.ee/letter/
d846 1
a846 1
in Perl 5.8.0 or newer, and
d881 1
a881 1
L<perlunitut>, L<perlunicode>, L<Encode>, L<open>, L<utf8>, L<bytes>,
@


1.1.1.5
log
@import perl 5.10.1
@
text
@d27 1
a27 1
language of the text and it does not generally define fonts or other graphical
d128 2
a129 1
B<Starting from Perl 5.8.0, the use of C<use utf8> is needed only in much more restricted circumstances.> In earlier releases the C<utf8> pragma was used to declare
d517 2
a518 2
Mappings>, L<http://www.unicode.org/unicode/reports/tr15/> and
L<http://www.unicode.org/unicode/reports/tr21/>
d541 1
a541 1
L<http://www.unicode.org/unicode/reports/tr10/>
d555 1
a555 1
Unicode-aware.  What this means is that C<[A-Za-z]> will not magically start
d606 3
a608 4
You shouldn't have to care.  But you may, because currently the semantics of the
characters whose ordinals are in the range 128 to 255 is different depending on
whether the string they are contained within is in Unicode or not.
(See L<perlunicode>.) 
d610 1
a610 1
To determine if a string is in Unicode, use:
d637 2
a638 2
C<Encode::encode_utf8()> function or the C<bytes> pragma  and
the C<length()> function:
d656 2
a657 2

    if (eval { decode_utf8($string, Encode::FB_CROAK); 1 }) {
d727 5
a731 7
You can find the bytes that make up a UTF-8 sequence with

	@@bytes = unpack("C*", $Unicode_string)

and you can create well-formed Unicode with

	$Unicode_string = pack("U*", 0xff, ...)
d737 2
a738 2
See L<http://www.alanwood.net/unicode/> and
L<http://www.cl.cam.ac.uk/~mgk25/unicode.html>
d790 1
a790 1
L<http://www.unicode.org/>
d796 1
a796 1
L<http://www.unicode.org/unicode/faq/>
d802 1
a802 1
L<http://www.unicode.org/glossary/>
d808 1
a808 1
L<http://www.unicode.org/unicode/onlinedat/resources.html>
d814 1
a814 1
L<http://www.alanwood.net/unicode/>
d820 1
a820 1
L<http://www.cl.cam.ac.uk/~mgk25/unicode.html>
d826 2
a827 2
L<http://www.czyborra.com/>
L<http://www.eki.ee/letter/>
@


1.1.1.6
log
@Perl 5.12.2 from CPAN
@
text
@d27 1
a27 1
language of the text, and it does not generally define fonts or other graphical
d48 3
a50 4
A Unicode I<logical> "character" can actually consist of more than one internal
I<actual> "character" or code point.  For Western languages, this is adequately
modelled by a I<base character> (like C<LATIN CAPITAL LETTER A>) followed
by one or more I<modifiers> (like C<COMBINING ACUTE ACCENT>).  This sequence of
d52 8
a59 12
sequence>.  Some non-western languages require more complicated
models, so Unicode created the I<grapheme cluster> concept, and then the
I<extended grapheme cluster>.  For example, a Korean Hangul syllable is
considered a single logical character, but most often consists of three actual
Unicode characters: a leading consonant followed by an interior vowel followed
by a trailing consonant.

Whether to call these extended grapheme clusters "characters" depends on your
point of view. If you are a programmer, you probably would tend towards seeing
each element in the sequences as one unit, or "character".  The whole sequence
could be seen as one "character", however, from the user's point of view, since
that's probably what it looks like in the context of the user's language.
d64 3
a66 2
deterministic.  In this document, we take that second point of view:
one "character" is one Unicode code point.
d87 1
a87 1
A common myth about Unicode is that it is "16-bit", that is,
d97 1
a97 1
Another myth is about Unicode blocks--that they have something to
d102 4
a105 4
still are allocated.  Instead, there is a concept called I<scripts>, which is
more useful: there is C<Latin> script, C<Greek> script, and so on.  Scripts
usually span varied parts of several blocks.  For more information about
scripts, see L<perlunicode/Scripts>.
d112 1
a112 1
bytes.  Other encodings
d143 2
a144 2
as Unicodeness cannot be avoided, the data is (mostly) transparently upgraded
to Unicode.  There are some problems--see L<perlunicode/The "Unicode Bug">.
d154 2
a155 2
outputting Unicode strings to a stream without a PerlIO layer (one with
the "default" encoding).  In such a case, the raw bytes used internally
d195 2
a196 5
additional conversions are needed at every step.

Later Perl releases have added code that will not work on EBCDIC platforms, and
no one has complained, so the divergence has continued.  If you want to run
Perl on an EBCDIC platform, send email to perlbug@@perl.org
d198 2
d264 2
a265 2
Note that Perl considers grapheme clusters to be separate characters, so for
example
d271 1
a271 1
have C<\X> for matching an extended grapheme cluster.
d514 4
a517 3
and casing issues: see L<Unicode::Normalize>, Unicode Technical Report #15,
L<Unicode Normalization Forms|http://www.unicode.org/unicode/reports/tr15> and
sections on case mapping in the L<Unicode Standard|http://www.unicode.org>.
d520 1
a520 1
Mappings/SpecialCasing> is implemented, but bugs remain in C<qr//i> with them.
d608 1
a608 1
(See L<perlunicode/When Unicode Does Not Happen>.)
d622 1
a622 1
points of the characters.  Bytes added to a UTF-8 encoded string are
@


1.1.1.7
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d8 1
a8 2
in Perl.  See L</Further Resources> for references to more in-depth
treatments of Unicode.
d15 3
a17 3
Unicode and ISO/IEC 10646 are coordinated standards that unify
almost all other modern character set standards,
covering more than 80 writing systems and hundreds of languages,
d22 1
a22 1
Unicode 1.0 was released in October 1991, and 6.0 in October 2010.
d34 1
a34 3
I<code points>.  A code point is essentially the position of the
character within the set of all possible Unicode characters, and thus in
Perl, the term I<ordinal> is often used interchangeably with it.
d54 3
a56 4
models, so Unicode created the I<grapheme cluster> concept, which was
later further refined into the I<extended grapheme cluster>.  For
example, a Korean Hangul syllable is considered a single logical
character, but most often consists of three actual
d62 19
a80 20
each element in the sequences as one unit, or "character".  However from
the user's point of view, the whole sequence could be seen as one
"character" since that's probably what it looks like in the context of the
user's language.  In this document, we take the programmer's point of
view: one "character" is one Unicode code point.

For some combinations of base character and modifiers, there are
I<precomposed> characters.  There is a single character equivalent, for
example, to the sequence C<LATIN CAPITAL LETTER A> followed by
C<COMBINING ACUTE ACCENT>.  It is called  C<LATIN CAPITAL LETTER A WITH
ACUTE>.  These precomposed characters are, however, only available for
some combinations, and are mainly meant to support round-trip
conversions between Unicode and legacy standards (like ISO 8859).  Using
sequences, as Unicode does, allows for needing fewer basic building blocks
(code points) to express many more potential grapheme clusters.  To
support conversion between equivalent forms, various I<normalization
forms> are also defined.  Thus, C<LATIN CAPITAL LETTER A WITH ACUTE> is
in I<Normalization Form Composed>, (abbreviated NFC), and the sequence
C<LATIN CAPITAL LETTER A> followed by C<COMBINING ACUTE ACCENT>
represents the same character in I<Normalization Form Decomposed> (NFD).
d86 1
a86 1
converse is not also true: some code points do not have an assigned
d91 3
a93 4
When Unicode was first conceived, it was thought that all the world's
characters could be represented using a 16-bit word; that is a maximum of
C<0x10000> (or 65536) characters from C<0x0000> to C<0xFFFF> would be
needed.  This soon proved to be false, and since Unicode 2.0 (July
d95 9
a103 24
and Unicode 3.1 (March 2001) defined the first characters above C<0xFFFF>.
The first C<0x10000> characters are called the I<Plane 0>, or the
I<Basic Multilingual Plane> (BMP).  With Unicode 3.1, 17 (yes,
seventeen) planes in all were defined--but they are nowhere near full of
defined characters, yet.

When a new language is being encoded, Unicode generally will choose a
C<block> of consecutive unallocated code points for its characters.  So
far, the number of code points in these blocks has always been evenly
divisible by 16.  Extras in a block, not currently needed, are left
unallocated, for future growth.  But there have been occasions when
a later relase needed more code points than the available extras, and a
new block had to allocated somewhere else, not contiguous to the initial
one, to handle the overflow.  Thus, it became apparent early on that
"block" wasn't an adequate organizing principal, and so the C<Script>
property was created.  (Later an improved script property was added as
well, the C<Script_Extensions> property.)  Those code points that are in
overflow blocks can still
have the same script as the original ones.  The script concept fits more
closely with natural language: there is C<Latin> script, C<Greek>
script, and so on; and there are several artificial scripts, like
C<Common> for characters that are used in multiple scripts, such as
mathematical symbols.  Scripts usually span varied parts of several
blocks.  For more information about scripts, see L<perlunicode/Scripts>.
d105 5
a109 6
accidental--an artifact of how the characters have been and still are
allocated.  (Note that this paragraph has oversimplified things for the
sake of this being an introduction.  Unicode doesn't really encode
languages, but the writing systems for them--their scripts; and one
script can be used by many languages.  Unicode also encodes things that
aren't really about languages, such as symbols like C<BAGGAGE CLAIM>.)
a130 8
Perl 5.14.0 is the first release where Unicode support is
(almost) seamlessly integrable without some gotchas (the exception being
some differences in L<quotemeta|perlfunc/quotemeta>, which is fixed
starting in Perl 5.16.0).   To enable this
seamless support, you should C<use feature 'unicode_strings'> (which is
automatically selected if you C<use 5.012> or higher).  See L<feature>.
(5.14 also fixes a number of bugs and departures from the Unicode
standard.)
d132 1
a132 1
Before Perl 5.8.0, the use of C<use utf8> was used to declare
d136 3
a138 4
operations.
Starting with Perl 5.8.0, only one case remains where an explicit C<use
utf8> is needed: if your Perl script itself is encoded in UTF-8, you can
use UTF-8 in your identifier names, and in string and regular expression
d145 4
a148 8
strings of Unicode characters.  The general principle is that Perl tries
to keep its data as eight-bit bytes for as long as possible, but as soon
as Unicodeness cannot be avoided, the data is transparently upgraded
to Unicode.  Prior to Perl 5.14, the upgrade was not completely
transparent (see L<perlunicode/The "Unicode Bug">), and for backwards
compatibility, full transparency is not gained unless C<use feature
'unicode_strings'> (see L<feature>) or C<use 5.012> (or higher) is
selected.
d185 1
a185 2
Note that this means that Perl expects other software to work the same
way:
d187 2
a188 2
STDIN coming in from another command is not UTF-8, Perl will likely
complain about the malformed UTF-8.
d238 1
a238 1
You can invoke characters
d241 1
d251 1
a251 1
run-time functionality, use C<chr()> and C<charnames::string_vianame()>.
d272 2
a273 2
 print length("\N{LATIN CAPITAL LETTER A}\N{COMBINING ACUTE ACCENT}"),
       "\n";
d276 1
a276 3
have C<\X> for matching an extended grapheme cluster.  (Thus C<\X> in a
regular expression would match the entire sequence of both the example
characters.)
d283 3
a285 3
When you combine legacy data and Unicode, the legacy data needs
to be upgraded to Unicode.  Normally the legacy data is assumed to be
ISO 8859-1 (or EBCDIC, if applicable).
d324 1
a324 1
the loose matching of encoding names. Also note that currently C<:utf8> is unsafe for
d326 1
a326 2
UTF-8; you should instead use C<:encoding(utf-8)> (with or without a
hyphen).
d347 1
a347 2
    use open ':encoding(utf8)'; # input/output default encoding will be
                                # UTF-8
d358 1
a358 2
    # the :locale will probe the locale environment variables like
    # LC_ALL
d435 7
a441 7
 sub nice_string {
     join("",
       map { $_ > 255 ?                  # if wide character...
              sprintf("\\x{%04X}", $_) :  # \x{...}
              chr($_) =~ /[[:cntrl:]]/ ?  # else if control character...
              sprintf("\\x%02X", $_) :    # \x..
              quotemeta(chr($_))          # else quoted or as themselves
d516 1
a516 1
CAPITAL LETTER A's should be considered equal, or even A's of any case.
d524 1
a524 2
Mappings/SpecialCasing> is implemented, but bugs remain in C<qr//i> with them,
mostly fixed by 5.14.
d556 13
a568 13
Character ranges in regular expression bracketed character classes ( e.g.,
C</[a-z]/>) and in the C<tr///> (also known as C<y///>) operator are not
magically Unicode-aware.  What this means is that C<[A-Za-z]> will not
magically start to mean "all alphabetic letters" (not that it does mean that
even for 8-bit characters; for those, if you are using locales (L<perllocale>),
use C</[[:alpha:]]/>; and if not, use the 8-bit-aware property C<\p{alpha}>).

All the properties that begin with C<\p> (and its inverse C<\P>) are actually
character classes that are Unicode-aware.  There are dozens of them, see
L<perluniprops>.

You can use Unicode code points as the end points of character ranges, and the
range will include all Unicode code points that lie between those end points.
a577 2
To get safe conversions from any Unicode string, use
L<Unicode::UCD/num()>.
a603 3
To get full seamless Unicode support, add
C<use feature 'unicode_strings'> (or C<use 5.012> or higher) to your
script.
d609 2
a610 4
You shouldn't have to care.  But you may if your Perl is before 5.14.0
or you haven't specified C<use feature 'unicode_strings'> or C<use
5.012> (or higher) because otherwise the semantics of the code points
in the range 128 to 255 are different depending on
d625 2
a626 2
are interpreted as the (variable-length, potentially multi-byte) UTF-8 encoded
code points of the characters.  Bytes added to a UTF-8 encoded string are
d628 1
a628 1
are merged (double-quoted interpolation, explicit concatenation, or
d641 2
a642 2
C<Encode::encode_utf8()> function or the C<bytes> pragma
and the C<length()> function:
d647 1
a647 1
    print length(Encode::encode_utf8($unicode)),"\n"; # will print 2
a650 7
    no bytes;

=item *

How Do I Find Out What Encoding a File Has?

You might try L<Encode::Guess>, but it has a number of limitations.
d733 1
a733 1
    @@bytes = unpack("C*", $Unicode_string)
d737 1
a737 1
    $Unicode_string = pack("U*", 0xff, ...)
d750 5
a754 13
Starting in Perl 5.16, you can specify

    use locale ':not_characters';

to get Perl to work well with tradtional locales.  The catch is that you
have to translate from the locale character set to/from Unicode
yourself.  See L</Unicode IE<sol>O> above for how to

    use open ':locale';

to accomplish this, but full details are in L<perllocale/Unicode and
UTF-8>, including gotchas that happen if you don't specifiy
C<:not_characters>.
a811 8
Unicode Recommended Reading List

The Unicode Consortium has a list of articles and books, some of which
give a much more in depth treatment of Unicode:
L<http://unicode.org/resources/readinglist.html>

=item *

d837 16
d889 1
a889 1
Copyright 2001-2011 Jarkko Hietaniemi E<lt>jhi@@iki.fiE<gt>
@


1.1.1.8
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d140 1
a140 1
(UTF-8 is byte-order independent).  The ISO/IEC 10646 defines the UCS-2
d148 2
a149 2
Starting from Perl v5.6.0, Perl has had the capacity to handle Unicode
natively.  Perl v5.8.0, however, is the first recommended release for
d153 1
a153 1
Perl v5.14.0 is the first release where Unicode support is
d162 1
a162 1
Before Perl v5.8.0, the use of C<use utf8> was used to declare
d167 1
a167 1
Starting with Perl v5.8.0, only one case remains where an explicit C<use
d179 1
a179 1
to Unicode.  Prior to Perl v5.14.0, the upgrade was not completely
d418 1
a418 1
The C<:locale> does not currently work with
@


1.1.1.9
log
@Import perl-5.20.1
@
text
@d74 1
a74 1
example, for the sequence C<LATIN CAPITAL LETTER A> followed by
d112 1
a112 1
a later release needed more code points than the available extras, and a
d464 2
a465 2
Perl has been built with L<PerlIO>, which is the default
on most systems.
d565 1
a565 1
mostly fixed by 5.14, and essentially entirely by 5.18.
d618 1
a618 1
than ASCII C<0> to C<9> (and ASCII C<a> to C<f> for hexadecimal).
d805 1
a805 5
If your locale is a UTF-8 locale, starting in Perl v5.20, Perl works
well for all categories except C<LC_COLLATE> dealing with sorting and
the C<cmp> operator.

For other locales, starting in Perl 5.16, you can specify
d809 1
a809 1
to get Perl to work well with them.  The catch is that you
d816 1
a816 1
UTF-8>, including gotchas that happen if you don't specify
@


1.1.1.10
log
@Import perl-5.20.2
@
text
@d476 7
a482 7
        join("",
        map { $_ > 255                    # if wide character...
              ? sprintf("\\x{%04X}", $_)  # \x{...}
              : chr($_) =~ /[[:cntrl:]]/  # else if control character...
                ? sprintf("\\x%02X", $_)  # \x..
                : quotemeta(chr($_))      # else quoted or as themselves
        } unpack("W*", $_[0]));           # unpack Unicode characters
@


1.1.1.11
log
@Import perl-5.24.2
@
text
@d91 1
a91 1
converse is not true: some code points do not have an assigned
d98 2
a99 2
C<0x10000> (or 65,536) characters would be needed, from C<0x0000> to
C<0xFFFF>.  This soon proved to be wrong, and since Unicode 2.0 (July
d136 2
a137 2
forms>, of which I<UTF-8> is the most popular.  UTF-8 is a
variable length encoding that encodes Unicode characters as 1 to 4
d155 1
a155 1
some differences in L<quotemeta|perlfunc/quotemeta>, and that is fixed
d233 7
a239 4
Perl 5.8.0 added support for Unicode on EBCDIC platforms.  This support
was allowed to lapse in later releases, but was revived in 5.22.
Unicode support is somewhat more complex to implement since additional
conversions are needed.  See L<perlebcdic> for more information.
d244 1
a244 5
"EBCDIC-safe", in that all the basic characters (which includes all
those that have ASCII equivalents (like C<"A">, C<"0">, C<"%">, I<etc.>)
are the same in both EBCDIC and UTF-EBCDIC.  Often, documentation
will use the term "UTF-8" to mean UTF-EBCDIC as well.  This is the case
in this document.
d248 2
a249 3
This section applies fully to Perls starting with v5.22.  Various
caveats for earlier releases are in the L</Earlier releases caveats>
subsection below.
d251 1
a251 2
To create Unicode characters in literals,
use the C<\N{...}> notation in double-quoted strings:
d253 1
a253 2
 my $smiley_from_name = "\N{WHITE SMILING FACE}";
 my $smiley_from_code_point = "\N{U+263a}";
d255 1
a255 1
Similarly, they can be used in regular expression literals
d257 1
a257 2
 $smiley =~ /\N{WHITE SMILING FACE}/;
 $smiley =~ /\N{U+263a}/;
d259 1
a259 1
At run-time you can use:
d261 1
a261 4
 use charnames ();
 my $hebrew_alef_from_name
                      = charnames::string_vianame("HEBREW LETTER ALEF");
 my $hebrew_alef_from_code_point = charnames::string_vianame("U+05D0");
d266 7
a272 1
There are other runtime options as well.  You can use C<pack()>:
d274 2
a275 1
 my $hebrew_alef_from_code_point = pack("U", 0x05d0);
d277 1
a277 2
Or you can use C<chr()>, though it is less convenient in the general
case:
d279 2
a280 2
 $hebrew_alef_from_code_point = chr(utf8::unicode_to_native(0x05d0));
 utf8::upgrade($hebrew_alef_from_code_point);
d282 1
a282 2
The C<utf8::unicode_to_native()> and C<utf8::upgrade()> aren't needed if
the argument is above 0xFF, so the above could have been written as
d284 3
a286 1
 $hebrew_alef_from_code_point = chr(0x05d0);
d288 3
a290 1
since 0x5d0 is above 255.
d292 1
a292 4
C<\x{}> and C<\o{}> can also be used to specify code points at compile
time in double-quotish strings, but, for backward compatibility with
older Perls, the same rules apply as with C<chr()> for code points less
than 256.
d294 2
a295 29
C<utf8::unicode_to_native()> is used so that the Perl code is portable
to EBCDIC platforms.  You can omit it if you're I<really> sure no one
will ever want to use your code on a non-ASCII platform.  Starting in
Perl v5.22, calls to it on ASCII platforms are optimized out, so there's
no performance penalty at all in adding it.  Or you can simply use the
other constructs that don't require it.

See L</"Further Resources"> for how to find all these names and numeric
codes.

=head3 Earlier releases caveats

On EBCDIC platforms, prior to v5.22, using C<\N{U+...}> doesn't work
properly.

Prior to v5.16, using C<\N{...}> with a character name (as opposed to a
C<U+...> code point) required a S<C<use charnames :full>>.

Prior to v5.14, there were some bugs in C<\N{...}> with a character name
(as opposed to a C<U+...> code point).

C<charnames::string_vianame()> was introduced in v5.14.  Prior to that,
C<charnames::vianame()> should work, but only if the argument is of the
form C<"U+...">.  Your best bet there for runtime Unicode by character
name is probably:

 use charnames ();
 my $hebrew_alef_from_name
                  = pack("U", charnames::vianame("HEBREW LETTER ALEF"));
a494 3
(C<\\x{}> is used here instead of C<\\N{}>, since it's most likely that
you want to see what the native values are.)

d608 2
a609 11
Starting in v5.22, you can use Unicode code points as the end points of
regular expression pattern character ranges, and the range will include
all Unicode code points that lie between those end points, inclusive.

 qr/ [\N{U+03]-\N{U+20}] /x

includes the code points
C<\N{U+03}>, C<\N{U+04}>, ..., C<\N{U+20}>.

(It is planned to extend this behavior to ranges in C<tr///> in Perl
v5.24.)
d657 1
a657 1
5.012> (or higher) because otherwise the rules for the code points
d948 1
a948 2
Copyright 2001-2011 Jarkko Hietaniemi E<lt>jhi@@iki.fiE<gt>.
Now maintained by Perl 5 Porters.
@


