head	1.11;
access;
symbols
	OPENBSD_6_1:1.11.0.4
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.10.0.12
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.6
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.10.0.8
	OPENBSD_5_8_BASE:1.10
	PERL_5_20_2:1.1.1.9
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	PERL_5_20_1:1.1.1.9
	OPENBSD_5_6:1.10.0.4
	OPENBSD_5_6_BASE:1.10
	PERL_5_18_2:1.1.1.9
	PERL:1.1.1
	OPENBSD_5_5:1.9.0.16
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.12
	OPENBSD_5_4_BASE:1.9
	PERL_5_16_3:1.1.1.8
	OPENBSD_5_3:1.9.0.10
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.8
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.6
	OPENBSD_5_0:1.9.0.4
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.2
	OPENBSD_4_9_BASE:1.9
	PERL_5_12_2:1.1.1.8
	OPENBSD_4_8:1.8.0.4
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	PERL_5_10_1:1.1.1.7
	OPENBSD_4_6:1.7.0.6
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.2
	OPENBSD_4_5_BASE:1.7
	PERL_5_10_0:1.1.1.6
	OPENBSD_4_4:1.6.0.10
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.8
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.6
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.4
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.2
	OPENBSD_4_0_BASE:1.6
	PERL_5_8_8:1.1.1.5
	OPENBSD_3_9:1.5.0.14
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.12
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.10
	OPENBSD_3_7_BASE:1.5
	PERL_5_8_6:1.1.1.4
	OPENBSD_3_6:1.5.0.8
	OPENBSD_3_6_BASE:1.5
	PERL_5_8_5:1.1.1.4
	PERL_5_8_3:1.1.1.4
	OPENBSD_3_5:1.5.0.6
	OPENBSD_3_5_BASE:1.5
	PERL_5_8_2:1.1.1.4
	OPENBSD_3_4:1.5.0.4
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.4.0.12
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.10
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.8
	OPENBSD_3_0_BASE:1.4
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.11
date	2017.02.05.00.32.18;	author afresh1;	state Exp;
branches;
next	1.10;
commitid	cxJ08BvJA9Pt2PTM;

1.10
date	2014.03.24.15.05.32;	author afresh1;	state Exp;
branches;
next	1.9;

1.9
date	2010.09.24.15.07.03;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2009.10.12.18.24.47;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2008.09.29.17.36.16;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2006.03.28.19.23.10;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.10.27.22.25.32;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.07.24;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.52.10;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.59.05;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.12.58;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.12.58;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.40.39;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.10.22;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.27.22.15.04;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2006.03.28.18.49.17;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2008.09.29.17.18.51;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2009.10.12.18.10.39;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2010.09.24.14.49.09;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2014.03.24.14.59.07;	author afresh1;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@=head1 NAME
X<data structure> X<complex data structure> X<struct>

perldsc - Perl Data Structures Cookbook

=head1 DESCRIPTION

Perl lets us have complex data structures.  You can write something like
this and all of a sudden, you'd have an array with three dimensions!

    for my $x (1 .. 10) {
        for my $y (1 .. 10) {
            for my $z (1 .. 10) {
                $AoA[$x][$y][$z] =
                    $x ** $y + $z;
            }
        }
    }

Alas, however simple this may appear, underneath it's a much more
elaborate construct than meets the eye!

How do you print it out?  Why can't you say just C<print @@AoA>?  How do
you sort it?  How can you pass it to a function or get one of these back
from a function?  Is it an object?  Can you save it to disk to read
back later?  How do you access whole rows or columns of that matrix?  Do
all the values have to be numeric?

As you see, it's quite easy to become confused.  While some small portion
of the blame for this can be attributed to the reference-based
implementation, it's really more due to a lack of existing documentation with
examples designed for the beginner.

This document is meant to be a detailed but understandable treatment of the
many different sorts of data structures you might want to develop.  It
should also serve as a cookbook of examples.  That way, when you need to
create one of these complex data structures, you can just pinch, pilfer, or
purloin a drop-in example from here.

Let's look at each of these possible constructs in detail.  There are separate
sections on each of the following:

=over 5

=item * arrays of arrays

=item * hashes of arrays

=item * arrays of hashes

=item * hashes of hashes

=item * more elaborate constructs

=back

But for now, let's look at general issues common to all
these types of data structures.

=head1 REFERENCES
X<reference> X<dereference> X<dereferencing> X<pointer>

The most important thing to understand about all data structures in
Perl--including multidimensional arrays--is that even though they might
appear otherwise, Perl C<@@ARRAY>s and C<%HASH>es are all internally
one-dimensional.  They can hold only scalar values (meaning a string,
number, or a reference).  They cannot directly contain other arrays or
hashes, but instead contain I<references> to other arrays or hashes.
X<multidimensional array> X<array, multidimensional>

You can't use a reference to an array or hash in quite the same way that you
would a real array or hash.  For C or C++ programmers unused to
distinguishing between arrays and pointers to the same, this can be
confusing.  If so, just think of it as the difference between a structure
and a pointer to a structure.

You can (and should) read more about references in L<perlref>.
Briefly, references are rather like pointers that know what they
point to.  (Objects are also a kind of reference, but we won't be needing
them right away--if ever.)  This means that when you have something which
looks to you like an access to a two-or-more-dimensional array and/or hash,
what's really going on is that the base type is
merely a one-dimensional entity that contains references to the next
level.  It's just that you can I<use> it as though it were a
two-dimensional one.  This is actually the way almost all C
multidimensional arrays work as well.

    $array[7][12]                       # array of arrays
    $array[7]{string}                   # array of hashes
    $hash{string}[7]                    # hash of arrays
    $hash{string}{'another string'}     # hash of hashes

Now, because the top level contains only references, if you try to print
out your array in with a simple print() function, you'll get something
that doesn't look very nice, like this:

    my @@AoA = ( [2, 3], [4, 5, 7], [0] );
    print $AoA[1][2];
  7
    print @@AoA;
  ARRAY(0x83c38)ARRAY(0x8b194)ARRAY(0x8b1d0)


That's because Perl doesn't (ever) implicitly dereference your variables.
If you want to get at the thing a reference is referring to, then you have
to do this yourself using either prefix typing indicators, like
C<${$blah}>, C<@@{$blah}>, C<@@{$blah[$i]}>, or else postfix pointer arrows,
like C<$a-E<gt>[3]>, C<$h-E<gt>{fred}>, or even C<$ob-E<gt>method()-E<gt>[3]>.

=head1 COMMON MISTAKES

The two most common mistakes made in constructing something like
an array of arrays is either accidentally counting the number of
elements or else taking a reference to the same memory location
repeatedly.  Here's the case where you just get the count instead
of a nested array:

    for my $i (1..10) {
        my @@array = somefunc($i);
        $AoA[$i] = @@array;      # WRONG!
    }

That's just the simple case of assigning an array to a scalar and getting
its element count.  If that's what you really and truly want, then you
might do well to consider being a tad more explicit about it, like this:

    for my $i (1..10) {
        my @@array = somefunc($i);
        $counts[$i] = scalar @@array;
    }

Here's the case of taking a reference to the same memory location
again and again:

    # Either without strict or having an outer-scope my @@array;
    # declaration.

    for my $i (1..10) {
        @@array = somefunc($i);
        $AoA[$i] = \@@array;     # WRONG!
    }

So, what's the big problem with that?  It looks right, doesn't it?
After all, I just told you that you need an array of references, so by
golly, you've made me one!

Unfortunately, while this is true, it's still broken.  All the references
in @@AoA refer to the I<very same place>, and they will therefore all hold
whatever was last in @@array!  It's similar to the problem demonstrated in
the following C program:

    #include <pwd.h>
    main() {
        struct passwd *getpwnam(), *rp, *dp;
        rp = getpwnam("root");
        dp = getpwnam("daemon");

        printf("daemon name is %s\nroot name is %s\n",
                dp->pw_name, rp->pw_name);
    }

Which will print

    daemon name is daemon
    root name is daemon

The problem is that both C<rp> and C<dp> are pointers to the same location
in memory!  In C, you'd have to remember to malloc() yourself some new
memory.  In Perl, you'll want to use the array constructor C<[]> or the
hash constructor C<{}> instead.   Here's the right way to do the preceding
broken code fragments:
X<[]> X<{}>

    # Either without strict or having an outer-scope my @@array;
    # declaration.

    for my $i (1..10) {
        @@array = somefunc($i);
        $AoA[$i] = [ @@array ];
    }

The square brackets make a reference to a new array with a I<copy>
of what's in @@array at the time of the assignment.  This is what
you want.

Note that this will produce something similar, but it's
much harder to read:

    # Either without strict or having an outer-scope my @@array;
    # declaration.
    for my $i (1..10) {
        @@array = 0 .. $i;
        @@{$AoA[$i]} = @@array;
    }

Is it the same?  Well, maybe so--and maybe not.  The subtle difference
is that when you assign something in square brackets, you know for sure
it's always a brand new reference with a new I<copy> of the data.
Something else could be going on in this new case with the C<@@{$AoA[$i]}>
dereference on the left-hand-side of the assignment.  It all depends on
whether C<$AoA[$i]> had been undefined to start with, or whether it
already contained a reference.  If you had already populated @@AoA with
references, as in

    $AoA[3] = \@@another_array;

Then the assignment with the indirection on the left-hand-side would
use the existing reference that was already there:

    @@{$AoA[3]} = @@array;

Of course, this I<would> have the "interesting" effect of clobbering
@@another_array.  (Have you ever noticed how when a programmer says
something is "interesting", that rather than meaning "intriguing",
they're disturbingly more apt to mean that it's "annoying",
"difficult", or both?  :-)

So just remember always to use the array or hash constructors with C<[]>
or C<{}>, and you'll be fine, although it's not always optimally
efficient.

Surprisingly, the following dangerous-looking construct will
actually work out fine:

    for my $i (1..10) {
        my @@array = somefunc($i);
        $AoA[$i] = \@@array;
    }

That's because my() is more of a run-time statement than it is a
compile-time declaration I<per se>.  This means that the my() variable is
remade afresh each time through the loop.  So even though it I<looks> as
though you stored the same variable reference each time, you actually did
not!  This is a subtle distinction that can produce more efficient code at
the risk of misleading all but the most experienced of programmers.  So I
usually advise against teaching it to beginners.  In fact, except for
passing arguments to functions, I seldom like to see the gimme-a-reference
operator (backslash) used much at all in code.  Instead, I advise
beginners that they (and most of the rest of us) should try to use the
much more easily understood constructors C<[]> and C<{}> instead of
relying upon lexical (or dynamic) scoping and hidden reference-counting to
do the right thing behind the scenes.

In summary:

    $AoA[$i] = [ @@array ];     # usually best
    $AoA[$i] = \@@array;        # perilous; just how my() was that array?
    @@{ $AoA[$i] } = @@array;    # way too tricky for most programmers


=head1 CAVEAT ON PRECEDENCE
X<dereference, precedence> X<dereferencing, precedence>

Speaking of things like C<@@{$AoA[$i]}>, the following are actually the
same thing:
X<< -> >>

    $aref->[2][2]       # clear
    $$aref[2][2]        # confusing

That's because Perl's precedence rules on its five prefix dereferencers
(which look like someone swearing: C<$ @@ * % &>) make them bind more
tightly than the postfix subscripting brackets or braces!  This will no
doubt come as a great shock to the C or C++ programmer, who is quite
accustomed to using C<*a[i]> to mean what's pointed to by the I<i'th>
element of C<a>.  That is, they first take the subscript, and only then
dereference the thing at that subscript.  That's fine in C, but this isn't C.

The seemingly equivalent construct in Perl, C<$$aref[$i]> first does
the deref of $aref, making it take $aref as a reference to an
array, and then dereference that, and finally tell you the I<i'th> value
of the array pointed to by $AoA. If you wanted the C notion, you'd have to
write C<${$AoA[$i]}> to force the C<$AoA[$i]> to get evaluated first
before the leading C<$> dereferencer.

=head1 WHY YOU SHOULD ALWAYS C<use strict>

If this is starting to sound scarier than it's worth, relax.  Perl has
some features to help you avoid its most common pitfalls.  The best
way to avoid getting confused is to start every program like this:

    #!/usr/bin/perl -w
    use strict;

This way, you'll be forced to declare all your variables with my() and
also disallow accidental "symbolic dereferencing".  Therefore if you'd done
this:

    my $aref = [
        [ "fred", "barney", "pebbles", "bambam", "dino", ],
        [ "homer", "bart", "marge", "maggie", ],
        [ "george", "jane", "elroy", "judy", ],
    ];

    print $aref[2][2];

The compiler would immediately flag that as an error I<at compile time>,
because you were accidentally accessing C<@@aref>, an undeclared
variable, and it would thereby remind you to write instead:

    print $aref->[2][2]

=head1 DEBUGGING
X<data structure, debugging> X<complex data structure, debugging>
X<AoA, debugging> X<HoA, debugging> X<AoH, debugging> X<HoH, debugging>
X<array of arrays, debugging> X<hash of arrays, debugging>
X<array of hashes, debugging> X<hash of hashes, debugging>

You can use the debugger's C<x> command to dump out complex data structures.
For example, given the assignment to $AoA above, here's the debugger output:

    DB<1> x $AoA
    $AoA = ARRAY(0x13b5a0)
       0  ARRAY(0x1f0a24)
          0  'fred'
          1  'barney'
          2  'pebbles'
          3  'bambam'
          4  'dino'
       1  ARRAY(0x13b558)
          0  'homer'
          1  'bart'
          2  'marge'
          3  'maggie'
       2  ARRAY(0x13b540)
          0  'george'
          1  'jane'
          2  'elroy'
          3  'judy'

=head1 CODE EXAMPLES

Presented with little comment (these will get their own manpages someday)
here are short code examples illustrating access of various
types of data structures.

=head1 ARRAYS OF ARRAYS
X<array of arrays> X<AoA>

=head2 Declaration of an ARRAY OF ARRAYS

 @@AoA = (
        [ "fred", "barney" ],
        [ "george", "jane", "elroy" ],
        [ "homer", "marge", "bart" ],
      );

=head2 Generation of an ARRAY OF ARRAYS

 # reading from file
 while ( <> ) {
     push @@AoA, [ split ];
 }

 # calling a function
 for $i ( 1 .. 10 ) {
     $AoA[$i] = [ somefunc($i) ];
 }

 # using temp vars
 for $i ( 1 .. 10 ) {
     @@tmp = somefunc($i);
     $AoA[$i] = [ @@tmp ];
 }

 # add to an existing row
 push @@{ $AoA[0] }, "wilma", "betty";

=head2 Access and Printing of an ARRAY OF ARRAYS

 # one element
 $AoA[0][0] = "Fred";

 # another element
 $AoA[1][1] =~ s/(\w)/\u$1/;

 # print the whole thing with refs
 for $aref ( @@AoA ) {
     print "\t [ @@$aref ],\n";
 }

 # print the whole thing with indices
 for $i ( 0 .. $#AoA ) {
     print "\t [ @@{$AoA[$i]} ],\n";
 }

 # print the whole thing one at a time
 for $i ( 0 .. $#AoA ) {
     for $j ( 0 .. $#{ $AoA[$i] } ) {
         print "elt $i $j is $AoA[$i][$j]\n";
     }
 }

=head1 HASHES OF ARRAYS
X<hash of arrays> X<HoA>

=head2 Declaration of a HASH OF ARRAYS

 %HoA = (
        flintstones        => [ "fred", "barney" ],
        jetsons            => [ "george", "jane", "elroy" ],
        simpsons           => [ "homer", "marge", "bart" ],
      );

=head2 Generation of a HASH OF ARRAYS

 # reading from file
 # flintstones: fred barney wilma dino
 while ( <> ) {
     next unless s/^(.*?):\s*//;
     $HoA{$1} = [ split ];
 }

 # reading from file; more temps
 # flintstones: fred barney wilma dino
 while ( $line = <> ) {
     ($who, $rest) = split /:\s*/, $line, 2;
     @@fields = split ' ', $rest;
     $HoA{$who} = [ @@fields ];
 }

 # calling a function that returns a list
 for $group ( "simpsons", "jetsons", "flintstones" ) {
     $HoA{$group} = [ get_family($group) ];
 }

 # likewise, but using temps
 for $group ( "simpsons", "jetsons", "flintstones" ) {
     @@members = get_family($group);
     $HoA{$group} = [ @@members ];
 }

 # append new members to an existing family
 push @@{ $HoA{"flintstones"} }, "wilma", "betty";

=head2 Access and Printing of a HASH OF ARRAYS

 # one element
 $HoA{flintstones}[0] = "Fred";

 # another element
 $HoA{simpsons}[1] =~ s/(\w)/\u$1/;

 # print the whole thing
 foreach $family ( keys %HoA ) {
     print "$family: @@{ $HoA{$family} }\n"
 }

 # print the whole thing with indices
 foreach $family ( keys %HoA ) {
     print "family: ";
     foreach $i ( 0 .. $#{ $HoA{$family} } ) {
         print " $i = $HoA{$family}[$i]";
     }
     print "\n";
 }

 # print the whole thing sorted by number of members
 foreach $family ( sort { @@{$HoA{$b}} <=> @@{$HoA{$a}} } keys %HoA ) {
     print "$family: @@{ $HoA{$family} }\n"
 }

 # print the whole thing sorted by number of members and name
 foreach $family ( sort {
                            @@{$HoA{$b}} <=> @@{$HoA{$a}}
                                        ||
                                    $a cmp $b
            } keys %HoA )
 {
     print "$family: ", join(", ", sort @@{ $HoA{$family} }), "\n";
 }

=head1 ARRAYS OF HASHES
X<array of hashes> X<AoH>

=head2 Declaration of an ARRAY OF HASHES

 @@AoH = (
        {
            Lead     => "fred",
            Friend   => "barney",
        },
        {
            Lead     => "george",
            Wife     => "jane",
            Son      => "elroy",
        },
        {
            Lead     => "homer",
            Wife     => "marge",
            Son      => "bart",
        }
  );

=head2 Generation of an ARRAY OF HASHES

 # reading from file
 # format: LEAD=fred FRIEND=barney
 while ( <> ) {
     $rec = {};
     for $field ( split ) {
         ($key, $value) = split /=/, $field;
         $rec->{$key} = $value;
     }
     push @@AoH, $rec;
 }


 # reading from file
 # format: LEAD=fred FRIEND=barney
 # no temp
 while ( <> ) {
     push @@AoH, { split /[\s+=]/ };
 }

 # calling a function  that returns a key/value pair list, like
 # "lead","fred","daughter","pebbles"
 while ( %fields = getnextpairset() ) {
     push @@AoH, { %fields };
 }

 # likewise, but using no temp vars
 while (<>) {
     push @@AoH, { parsepairs($_) };
 }

 # add key/value to an element
 $AoH[0]{pet} = "dino";
 $AoH[2]{pet} = "santa's little helper";

=head2 Access and Printing of an ARRAY OF HASHES

 # one element
 $AoH[0]{lead} = "fred";

 # another element
 $AoH[1]{lead} =~ s/(\w)/\u$1/;

 # print the whole thing with refs
 for $href ( @@AoH ) {
     print "{ ";
     for $role ( keys %$href ) {
         print "$role=$href->{$role} ";
     }
     print "}\n";
 }

 # print the whole thing with indices
 for $i ( 0 .. $#AoH ) {
     print "$i is { ";
     for $role ( keys %{ $AoH[$i] } ) {
         print "$role=$AoH[$i]{$role} ";
     }
     print "}\n";
 }

 # print the whole thing one at a time
 for $i ( 0 .. $#AoH ) {
     for $role ( keys %{ $AoH[$i] } ) {
         print "elt $i $role is $AoH[$i]{$role}\n";
     }
 }

=head1 HASHES OF HASHES
X<hash of hashes> X<HoH>

=head2 Declaration of a HASH OF HASHES

 %HoH = (
        flintstones => {
                lead      => "fred",
                pal       => "barney",
        },
        jetsons     => {
                lead      => "george",
                wife      => "jane",
                "his boy" => "elroy",
        },
        simpsons    => {
                lead      => "homer",
                wife      => "marge",
                kid       => "bart",
        },
 );

=head2 Generation of a HASH OF HASHES

 # reading from file
 # flintstones: lead=fred pal=barney wife=wilma pet=dino
 while ( <> ) {
     next unless s/^(.*?):\s*//;
     $who = $1;
     for $field ( split ) {
         ($key, $value) = split /=/, $field;
         $HoH{$who}{$key} = $value;
     }


 # reading from file; more temps
 while ( <> ) {
     next unless s/^(.*?):\s*//;
     $who = $1;
     $rec = {};
     $HoH{$who} = $rec;
     for $field ( split ) {
         ($key, $value) = split /=/, $field;
         $rec->{$key} = $value;
     }
 }

 # calling a function  that returns a key,value hash
 for $group ( "simpsons", "jetsons", "flintstones" ) {
     $HoH{$group} = { get_family($group) };
 }

 # likewise, but using temps
 for $group ( "simpsons", "jetsons", "flintstones" ) {
     %members = get_family($group);
     $HoH{$group} = { %members };
 }

 # append new members to an existing family
 %new_folks = (
     wife => "wilma",
     pet  => "dino",
 );

 for $what (keys %new_folks) {
     $HoH{flintstones}{$what} = $new_folks{$what};
 }

=head2 Access and Printing of a HASH OF HASHES

 # one element
 $HoH{flintstones}{wife} = "wilma";

 # another element
 $HoH{simpsons}{lead} =~ s/(\w)/\u$1/;

 # print the whole thing
 foreach $family ( keys %HoH ) {
     print "$family: { ";
     for $role ( keys %{ $HoH{$family} } ) {
         print "$role=$HoH{$family}{$role} ";
     }
     print "}\n";
 }

 # print the whole thing  somewhat sorted
 foreach $family ( sort keys %HoH ) {
     print "$family: { ";
     for $role ( sort keys %{ $HoH{$family} } ) {
         print "$role=$HoH{$family}{$role} ";
     }
     print "}\n";
 }


 # print the whole thing sorted by number of members
 foreach $family ( sort { keys %{$HoH{$b}} <=> keys %{$HoH{$a}} }
                                                             keys %HoH )
 {
     print "$family: { ";
     for $role ( sort keys %{ $HoH{$family} } ) {
         print "$role=$HoH{$family}{$role} ";
     }
     print "}\n";
 }

 # establish a sort order (rank) for each role
 $i = 0;
 for ( qw(lead wife son daughter pal pet) ) { $rank{$_} = ++$i }

 # now print the whole thing sorted by number of members
 foreach $family ( sort { keys %{ $HoH{$b} } <=> keys %{ $HoH{$a} } }
                                                             keys %HoH )
 {
     print "$family: { ";
     # and print these according to rank order
     for $role ( sort { $rank{$a} <=> $rank{$b} }
                                               keys %{ $HoH{$family} } )
     {
         print "$role=$HoH{$family}{$role} ";
     }
     print "}\n";
 }


=head1 MORE ELABORATE RECORDS
X<record> X<structure> X<struct>

=head2 Declaration of MORE ELABORATE RECORDS

Here's a sample showing how to create and use a record whose fields are of
many different sorts:

     $rec = {
         TEXT      => $string,
         SEQUENCE  => [ @@old_values ],
         LOOKUP    => { %some_table },
         THATCODE  => \&some_function,
         THISCODE  => sub { $_[0] ** $_[1] },
         HANDLE    => \*STDOUT,
     };

     print $rec->{TEXT};

     print $rec->{SEQUENCE}[0];
     $last = pop @@ { $rec->{SEQUENCE} };

     print $rec->{LOOKUP}{"key"};
     ($first_k, $first_v) = each %{ $rec->{LOOKUP} };

     $answer = $rec->{THATCODE}->($arg);
     $answer = $rec->{THISCODE}->($arg1, $arg2);

     # careful of extra block braces on fh ref
     print { $rec->{HANDLE} } "a string\n";

     use FileHandle;
     $rec->{HANDLE}->autoflush(1);
     $rec->{HANDLE}->print(" a string\n");

=head2 Declaration of a HASH OF COMPLEX RECORDS

     %TV = (
        flintstones => {
            series   => "flintstones",
            nights   => [ qw(monday thursday friday) ],
            members  => [
                { name => "fred",    role => "lead", age  => 36, },
                { name => "wilma",   role => "wife", age  => 31, },
                { name => "pebbles", role => "kid",  age  =>  4, },
            ],
        },

        jetsons     => {
            series   => "jetsons",
            nights   => [ qw(wednesday saturday) ],
            members  => [
                { name => "george",  role => "lead", age  => 41, },
                { name => "jane",    role => "wife", age  => 39, },
                { name => "elroy",   role => "kid",  age  =>  9, },
            ],
         },

        simpsons    => {
            series   => "simpsons",
            nights   => [ qw(monday) ],
            members  => [
                { name => "homer", role => "lead", age  => 34, },
                { name => "marge", role => "wife", age => 37, },
                { name => "bart",  role => "kid",  age  =>  11, },
            ],
         },
      );

=head2 Generation of a HASH OF COMPLEX RECORDS

     # reading from file
     # this is most easily done by having the file itself be
     # in the raw data format as shown above.  perl is happy
     # to parse complex data structures if declared as data, so
     # sometimes it's easiest to do that

     # here's a piece by piece build up
     $rec = {};
     $rec->{series} = "flintstones";
     $rec->{nights} = [ find_days() ];

     @@members = ();
     # assume this file in field=value syntax
     while (<>) {
         %fields = split /[\s=]+/;
         push @@members, { %fields };
     }
     $rec->{members} = [ @@members ];

     # now remember the whole thing
     $TV{ $rec->{series} } = $rec;

     ###########################################################
     # now, you might want to make interesting extra fields that
     # include pointers back into the same data structure so if
     # change one piece, it changes everywhere, like for example
     # if you wanted a {kids} field that was a reference
     # to an array of the kids' records without having duplicate
     # records and thus update problems.
     ###########################################################
     foreach $family (keys %TV) {
         $rec = $TV{$family}; # temp pointer
         @@kids = ();
         for $person ( @@{ $rec->{members} } ) {
             if ($person->{role} =~ /kid|son|daughter/) {
                 push @@kids, $person;
             }
         }
         # REMEMBER: $rec and $TV{$family} point to same data!!
         $rec->{kids} = [ @@kids ];
     }

     # you copied the array, but the array itself contains pointers
     # to uncopied objects. this means that if you make bart get
     # older via

     $TV{simpsons}{kids}[0]{age}++;

     # then this would also change in
     print $TV{simpsons}{members}[2]{age};

     # because $TV{simpsons}{kids}[0] and $TV{simpsons}{members}[2]
     # both point to the same underlying anonymous hash table

     # print the whole thing
     foreach $family ( keys %TV ) {
         print "the $family";
         print " is on during @@{ $TV{$family}{nights} }\n";
         print "its members are:\n";
         for $who ( @@{ $TV{$family}{members} } ) {
             print " $who->{name} ($who->{role}), age $who->{age}\n";
         }
         print "it turns out that $TV{$family}{lead} has ";
         print scalar ( @@{ $TV{$family}{kids} } ), " kids named ";
         print join (", ", map { $_->{name} } @@{ $TV{$family}{kids} } );
         print "\n";
     }

=head1 Database Ties

You cannot easily tie a multilevel data structure (such as a hash of
hashes) to a dbm file.  The first problem is that all but GDBM and
Berkeley DB have size limitations, but beyond that, you also have problems
with how references are to be represented on disk.  One experimental
module that does partially attempt to address this need is the MLDBM
module.  Check your nearest CPAN site as described in L<perlmodlib> for
source code to MLDBM.

=head1 SEE ALSO

L<perlref>, L<perllol>, L<perldata>, L<perlobj>

=head1 AUTHOR

Tom Christiansen <F<tchrist@@perl.com>>
@


1.10
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d11 7
a17 7
    for $x (1 .. 10) {
	for $y (1 .. 10) {
	    for $z (1 .. 10) {
		$AoA[$x][$y][$z] =
		    $x ** $y + $z;
	    }
	}
d88 4
a91 4
    $array[7][12]			# array of arrays
    $array[7]{string}			# array of hashes
    $hash{string}[7]			# hash of arrays
    $hash{string}{'another string'}	# hash of hashes
d97 1
a97 1
    @@AoA = ( [2, 3], [4, 5, 7], [0] );
d118 3
a120 3
    for $i (1..10) {
	@@array = somefunc($i);
	$AoA[$i] = @@array;	# WRONG!
d127 3
a129 3
    for $i (1..10) {
	@@array = somefunc($i);
	$counts[$i] = scalar @@array;
d135 6
a140 3
    for $i (1..10) {
	@@array = somefunc($i);
	$AoA[$i] = \@@array;	# WRONG!
d154 3
a156 3
	struct passwd *getpwnam(), *rp, *dp;
	rp = getpwnam("root");
	dp = getpwnam("daemon");
d158 2
a159 2
	printf("daemon name is %s\nroot name is %s\n",
		dp->pw_name, rp->pw_name);
d174 6
a179 3
    for $i (1..10) {
	@@array = somefunc($i);
	$AoA[$i] = [ @@array ];
d189 5
a193 3
    for $i (1..10) {
	@@array = 0 .. $i;
	@@{$AoA[$i]} = @@array;
d225 1
a225 1
    for $i (1..10) {
d246 3
a248 3
    $AoA[$i] = [ @@array ];	# usually best
    $AoA[$i] = \@@array;		# perilous; just how my() was that array?
    @@{ $AoA[$i] } = @@array;	# way too tricky for most programmers
d258 2
a259 2
    $aref->[2][2]	# clear
    $$aref[2][2]	# confusing
d290 3
a292 3
	[ "fred", "barney", "pebbles", "bambam", "dino", ],
	[ "homer", "bart", "marge", "maggie", ],
	[ "george", "jane", "elroy", "judy", ],
d315 5
a319 5
	  0  'fred'
	  1  'barney'
	  2  'pebbles'
	  3  'bambam'
	  4  'dino'
d321 4
a324 4
	  0  'homer'
	  1  'bart'
	  2  'marge'
	  3  'maggie'
d326 4
a329 4
	  0  'george'
	  1  'jane'
	  2  'elroy'
	  3  'judy'
d465 4
a468 4
			    @@{$HoA{$b}} <=> @@{$HoA{$a}}
					||
				    $a cmp $b
	    } keys %HoA )
d571 2
a572 2
		lead      => "fred",
		pal       => "barney",
d575 3
a577 3
		lead      => "george",
		wife      => "jane",
		"his boy" => "elroy",
d580 4
a583 4
		lead      => "homer",
		wife      => "marge",
		kid       => "bart",
	},
d660 3
a662 1
 foreach $family ( sort { keys %{$HoH{$b}} <=> keys %{$HoH{$a}} } keys %HoH ) {
d675 3
a677 1
 foreach $family ( sort { keys %{ $HoH{$b} } <=> keys %{ $HoH{$a} } } keys %HoH ) {
d680 3
a682 1
     for $role ( sort { $rank{$a} <=> $rank{$b} }  keys %{ $HoH{$family} } ) {
d698 6
a703 6
	 TEXT      => $string,
	 SEQUENCE  => [ @@old_values ],
	 LOOKUP    => { %some_table },
	 THATCODE  => \&some_function,
	 THISCODE  => sub { $_[0] ** $_[1] },
	 HANDLE    => \*STDOUT,
@


1.9
log
@merge in perl 5.12.2 plus local changes
@
text
@d8 2
a9 13
The single feature most sorely lacking in the Perl programming language
prior to its 5.0 release was complex data structures.  Even without direct
language support, some valiant programmers did manage to emulate them, but
it was hard work and not for the faint of heart.  You could occasionally
get away with the C<$m{$AoA,$b}> notation borrowed from B<awk> in which the
keys are actually more like a single concatenated string C<"$AoA$b">, but
traversal and sorting were difficult.  More desperate programmers even
hacked Perl's internal symbol table directly, a strategy that proved hard
to develop and maintain--to put it mildly.

The 5.0 release of Perl let us have complex data structures.  You
may now write something like this and all of a sudden, you'd have an array
with three dimensions!
d301 2
a302 5
Before version 5.002, the standard Perl debugger didn't do a very nice job of
printing out complex data structures.  With 5.002 or above, the
debugger includes several new features, including command line editing as
well as the C<x> command to dump out complex data structures.  For
example, given the assignment to $AoA above, here's the debugger output:
a830 3

Last update:
Wed Oct 23 04:57:50 MET DST 1996
@


1.8
log
@Merge in perl 5.10.1
@
text
@d88 2
a89 2
You can (and should) read more about references in the perlref(1) man
page.  Briefly, references are rather like pointers that know what they
d840 1
a840 1
perlref(1), perllol(1), perldata(1), perlobj(1)
@


1.7
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d74 2
a75 2
The most important thing to understand about all data structures in Perl
-- including multidimensional arrays--is that even though they might
d571 1
a571 1
X<hass of hashes> X<HoH>
@


1.6
log
@merge in perl 5.8.8
@
text
@d202 1
a202 1
Something else could be going on in this new case with the C<@@{$AoA[$i]}}>
@


1.5
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d2 1
d72 1
d80 1
d180 1
d255 1
d259 1
d307 4
d344 1
d401 1
d480 1
d571 1
d690 1
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d18 1
a18 1
may now write something like this and all of a sudden, you'd have a array
d35 1
a35 1
from a function?  Is is an object?  Can you save it to disk to read
d79 1
a79 1
You can't use a reference to a array or hash in quite the same way that you
d335 1
a335 1
=head2 Declaration of a ARRAY OF ARRAYS
d343 1
a343 1
=head2 Generation of a ARRAY OF ARRAYS
d364 1
a364 1
=head2 Access and Printing of a ARRAY OF ARRAYS
d469 1
a469 1
=head2 Declaration of a ARRAY OF HASHES
d488 1
a488 1
=head2 Generation of a ARRAY OF HASHES
d524 1
a524 1
=head2 Access and Printing of a ARRAY OF HASHES
@


1.3
log
@perl5.005_03 (stock)
@
text
@d11 2
a12 2
get away with the C<$m{$LoL,$b}> notation borrowed from I<awk> in which the
keys are actually more like a single concatenated string C<"$LoL$b">, but
d24 1
a24 1
		$LoL[$x][$y][$z] =
d33 1
a33 1
How do you print it out?  Why can't you say just C<print @@LoL>?  How do
d96 2
a97 2
    $list[7][12]			# array of arrays
    $list[7]{string}			# array of hashes
d105 2
a106 2
    @@LoL = ( [2, 3], [4, 5, 7], [0] );
    print $LoL[1][2];
d108 1
a108 1
    print @@LoL;
d127 2
a128 2
	@@list = somefunc($i);
	$LoL[$i] = @@list;	# WRONG!
d131 1
a131 1
That's just the simple case of assigning a list to a scalar and getting
d136 2
a137 2
	@@list = somefunc($i);
	$counts[$i] = scalar @@list;
d144 2
a145 2
	@@list = somefunc($i);
	$LoL[$i] = \@@list;	# WRONG!
d153 2
a154 2
in @@LoL refer to the I<very same place>, and they will therefore all hold
whatever was last in @@list!  It's similar to the problem demonstrated in
d179 2
a180 2
	@@list = somefunc($i);
	$LoL[$i] = [ @@list ];
d184 1
a184 1
of what's in @@list at the time of the assignment.  This is what
d191 2
a192 2
	@@list = 0 .. $i;
	@@{$LoL[$i]} = @@list;
d198 1
a198 1
Something else could be going on in this new case with the C<@@{$LoL[$i]}}>
d200 2
a201 2
whether C<$LoL[$i]> had been undefined to start with, or whether it
already contained a reference.  If you had already populated @@LoL with
d204 1
a204 1
    $LoL[3] = \@@another_list;
d209 1
a209 1
    @@{$LoL[3]} = @@list;
d212 1
a212 1
@@another_list.  (Have you ever noticed how when a programmer says
d225 2
a226 2
        my @@list = somefunc($i);
        $LoL[$i] = \@@list;
d245 3
a247 3
    $LoL[$i] = [ @@list ];	# usually best
    $LoL[$i] = \@@list;		# perilous; just how my() was that list?
    @@{ $LoL[$i] } = @@list;	# way too tricky for most programmers
d252 1
a252 1
Speaking of things like C<@@{$LoL[$i]}>, the following are actually the
d255 2
a256 2
    $listref->[2][2]	# clear
    $$listref[2][2]	# confusing
d266 2
a267 2
The seemingly equivalent construct in Perl, C<$$listref[$i]> first does
the deref of C<$listref>, making it take $listref as a reference to an
d269 2
a270 2
of the array pointed to by $LoL. If you wanted the C notion, you'd have to
write C<${$LoL[$i]}> to force the C<$LoL[$i]> to get evaluated first
d286 1
a286 1
    my $listref = [
d292 1
a292 1
    print $listref[2][2];
d295 1
a295 1
because you were accidentally accessing C<@@listref>, an undeclared
d298 1
a298 1
    print $listref->[2][2]
d306 1
a306 1
example, given the assignment to $LoL above, here's the debugger output:
d308 2
a309 2
    DB<1> x $LoL
    $LoL = ARRAY(0x13b5a0)
d333 1
a333 1
=head1 LISTS OF LISTS
d335 1
a335 1
=head2 Declaration of a LIST OF LISTS
d337 1
a337 1
 @@LoL = (
d343 1
a343 1
=head2 Generation of a LIST OF LISTS
d347 1
a347 1
     push @@LoL, [ split ];
d352 1
a352 1
     $LoL[$i] = [ somefunc($i) ];
d358 1
a358 1
     $LoL[$i] = [ @@tmp ];
d362 1
a362 1
 push @@{ $LoL[0] }, "wilma", "betty";
d364 1
a364 1
=head2 Access and Printing of a LIST OF LISTS
d367 1
a367 1
 $LoL[0][0] = "Fred";
d370 1
a370 1
 $LoL[1][1] =~ s/(\w)/\u$1/;
d373 1
a373 1
 for $aref ( @@LoL ) {
d378 2
a379 2
 for $i ( 0 .. $#LoL ) {
     print "\t [ @@{$LoL[$i]} ],\n";
d383 3
a385 3
 for $i ( 0 .. $#LoL ) {
     for $j ( 0 .. $#{ $LoL[$i] } ) {
         print "elt $i $j is $LoL[$i][$j]\n";
d389 1
a389 1
=head1 HASHES OF LISTS
d391 1
a391 1
=head2 Declaration of a HASH OF LISTS
d393 1
a393 1
 %HoL = (
d399 1
a399 1
=head2 Generation of a HASH OF LISTS
d405 1
a405 1
     $HoL{$1} = [ split ];
d413 1
a413 1
     $HoL{$who} = [ @@fields ];
d418 1
a418 1
     $HoL{$group} = [ get_family($group) ];
d424 1
a424 1
     $HoL{$group} = [ @@members ];
d428 1
a428 1
 push @@{ $HoL{"flintstones"} }, "wilma", "betty";
d430 1
a430 1
=head2 Access and Printing of a HASH OF LISTS
d433 1
a433 1
 $HoL{flintstones}[0] = "Fred";
d436 1
a436 1
 $HoL{simpsons}[1] =~ s/(\w)/\u$1/;
d439 2
a440 2
 foreach $family ( keys %HoL ) {
     print "$family: @@{ $HoL{$family} }\n"
d444 1
a444 1
 foreach $family ( keys %HoL ) {
d446 2
a447 2
     foreach $i ( 0 .. $#{ $HoL{$family} } ) {
         print " $i = $HoL{$family}[$i]";
d453 2
a454 2
 foreach $family ( sort { @@{$HoL{$b}} <=> @@{$HoL{$a}} } keys %HoL ) {
     print "$family: @@{ $HoL{$family} }\n"
d459 1
a459 1
			    @@{$HoL{$b}} <=> @@{$HoL{$a}}
d462 1
a462 1
	    } keys %HoL )
d464 1
a464 1
     print "$family: ", join(", ", sort @@{ $HoL{$family} }), "\n";
d467 1
a467 1
=head1 LISTS OF HASHES
d469 1
a469 1
=head2 Declaration of a LIST OF HASHES
d471 1
a471 1
 @@LoH = (
d488 1
a488 1
=head2 Generation of a LIST OF HASHES
d498 1
a498 1
     push @@LoH, $rec;
d506 1
a506 1
     push @@LoH, { split /[\s+=]/ };
d509 1
a509 1
 # calling a function  that returns a key,value list, like
d512 1
a512 1
     push @@LoH, { %fields };
d517 1
a517 1
     push @@LoH, { parsepairs($_) };
d521 2
a522 2
 $LoH[0]{pet} = "dino";
 $LoH[2]{pet} = "santa's little helper";
d524 1
a524 1
=head2 Access and Printing of a LIST OF HASHES
d527 1
a527 1
 $LoH[0]{lead} = "fred";
d530 1
a530 1
 $LoH[1]{lead} =~ s/(\w)/\u$1/;
d533 1
a533 1
 for $href ( @@LoH ) {
d542 1
a542 1
 for $i ( 0 .. $#LoH ) {
d544 2
a545 2
     for $role ( keys %{ $LoH[$i] } ) {
         print "$role=$LoH[$i]{$role} ";
d551 3
a553 3
 for $i ( 0 .. $#LoH ) {
     for $role ( keys %{ $LoH[$i] } ) {
         print "elt $i $role is $LoH[$i]{$role}\n";
d770 3
a772 3
     # change one piece, it changes everywhere, like for examples
     # if you wanted a {kids} field that was an array reference
     # to a list of the kids' records without having duplicate
d787 1
a787 1
     # you copied the list, but the list itself contains pointers
@


1.2
log
@perl 5.004_04
@
text
@d67 2
a68 2
But for now, let's look at some of the general issues common to all
of these types of data structures.
d308 1
a308 1
    DB<1> X $LoL
a326 2
There's also a lowercase B<x> command which is nearly the same.

d464 1
a464 1
     print "$family: ", join(", ", sort @@{ $HoL{$family}), "\n";
d617 1
a617 1
     pet  => "dino";
d693 1
a693 1
     print $rec->{LIST}[0];
@


1.1
log
@Initial revision
@
text
@d24 1
a24 1
		$LoL[$x][$y][$z] = 
d33 1
a33 1
How do you print it out?  Why can't you just say C<print @@LoL>?  How do
d37 1
a37 1
all the values have to be numeric?  
d44 5
a48 5
This document is meant to be a detailed but understandable treatment of
the many different sorts of data structures you might want to develop.  It should
also serve as a cookbook of examples.  That way, when you need to create one of these
complex data structures, you can just pinch, pilfer, or purloin
a drop-in example from here.
d51 1
a51 1
documents on each of the following:
a64 4
=item * recursive and self-referential data structures

=item * objects

d68 1
a68 1
of these types of data structures. 
d75 1
a75 1
one-dimensional.  They can only hold scalar values (meaning a string,
d79 5
a83 5
You can't use a reference to a array or hash in quite the same way that
you would a real array or hash.  For C or C++ programmers unused to distinguishing
between arrays and pointers to the same, this can be confusing.  If so,
just think of it as the difference between a structure and a pointer to a
structure.  
d88 3
a90 3
them right away--if ever.)  That means that when you have something that
looks to you like an access to two-or-more-dimensional array and/or hash,
that what's really going on is that in all these cases, the base type is
d101 1
a101 1
Now, because the top level only contains references, if you try to print
d129 1
a129 1
    } 
d137 2
a138 2
	$counts[$i] = scalar @@list;	
    } 
d146 1
a146 1
    } 
d148 1
a148 1
So, just what's the big problem with that?  It looks right, doesn't it?
d163 1
a163 1
	printf("daemon name is %s\nroot name is %s\n", 
d170 1
a170 1
    root name is daemon 
d176 1
a176 1
broken code fragments
d181 1
a181 1
    } 
d185 1
a185 1
you want.  
d193 1
a193 1
    } 
d217 1
a217 1
So just remember to always use the array or hash constructors with C<[]>
d219 1
a219 1
efficient.  
d227 1
a227 1
    } 
d250 1
a250 1
=head1 CAVEAT ON PRECEDENCE 
d289 1
a289 1
	[ "george", "jane", "alroy", "judy", ],
d296 1
a296 1
variable, and it would thereby remind you to instead write:
d302 5
a306 10
The standard Perl debugger in 5.001 doesn't do a very nice job of 
printing out complex data structures.  However, the perl5db that
Ilya Zakharevich E<lt>F<ilya@@math.ohio-state.edu>E<gt>
wrote, which is accessible at

    ftp://ftp.perl.com/pub/perl/ext/perl5db-kit-0.9.tar.gz

has several new features, including command line editing as well
as the C<x> command to dump out complex data structures.  For example, 
given the assignment to $LoL above, here's the debugger output:
d324 1
a324 1
	  2  'alroy'
d327 1
a327 1
There's also a lower-case B<x> command which is nearly the same.
d331 2
a332 2
Presented with little comment (these will get their own man pages someday)
here are short code examples illustrating access of various 
d350 1
a350 1

d355 1
a355 1

d361 1
a361 1

d377 1
a377 1

d382 1
a382 1

d386 1
a386 1
     for $j ( 0 .. $#{$LoL[$i]} ) {
d389 1
a389 1

d396 3
a398 3
        "flintstones"        => [ "fred", "barney" ],
        "jetsons"            => [ "george", "jane", "elroy" ],
        "simpsons"           => [ "homer", "marge", "bart" ],
d408 1
a408 1

d416 1
a416 1

d421 1
a421 1

d427 1
a427 1

d443 1
a443 1

d448 1
a448 1
     foreach $i ( 0 .. $#{ $HoL{$family} ) {
d452 1
a452 1

d455 1
a455 1
 foreach $family ( sort { @@{$HoL{$b}} <=> @@{$HoL{$b}} } keys %HoL ) {
d457 1
d460 6
a465 1
 foreach $family ( sort { @@{$HoL{$b}} <=> @@{$HoL{$a}} } keys %HoL ) {
d467 1
d475 2
a476 2
           Lead      => "fred",
           Friend    => "barney",
d501 1
d509 1
a509 1

d513 1
a513 1
 while ( %fields = getnextpairset() )
d515 1
a515 1

d520 1
a520 1

d523 2
a524 2
 $LoH[0]{"pet"} = "dino";
 $LoH[2]{"pet"} = "santa's little helper";
d529 1
a529 1
 $LoH[0]{"lead"} = "fred";
d532 1
a532 1
 $LoH[1]{"lead"} =~ s/(\w)/\u$1/;
d541 1
a541 1

d550 1
a550 1

d557 1
d564 8
a571 3
        "flintstones" => {
            "lead"    => "fred",
            "pal"     => "barney",
d573 6
a578 10
        "jetsons"     => {
             "lead"   => "george",
             "wife"   => "jane",
             "his boy"=> "elroy",
         }
        "simpsons"    => {
             "lead"   => "homer",
             "wife"   => "marge",
             "kid"    => "bart",
      );
d603 1
a603 7


 # calling a function  that returns a key,value list, like
 # "lead","fred","daughter","pebbles"
 while ( %fields = getnextpairset() )
     push @@a, { %fields };

d608 1
a608 1

d614 1
a614 1

d618 2
a619 2
     "wife" => "wilma",
     "pet"  => "dino";
d621 1
d624 1
a624 1

d629 1
a629 1
 $HoH{"flintstones"}{"wife"} = "wilma";
d636 2
a637 2
     print "$family: ";
     for $role ( keys %{ $HoH{$family} } {
d641 1
a641 1

d645 2
a646 2
     print "$family: ";
     for $role ( sort keys %{ $HoH{$family} } {
d650 1
d654 3
a656 3
 foreach $family ( sort { keys %{$HoH{$b}} <=> keys %{$HoH{$b}} } keys %HoH ) {
     print "$family: ";
     for $role ( sort keys %{ $HoH{$family} } {
d660 1
a660 1

d667 2
a668 2
 foreach $family ( sort { keys %{$HoH{$b}} <=> keys %{$HoH{$b}} } keys %HoH ) {
     print "$family: ";
d670 1
a670 1
     for $role ( sort { $rank{$a} <=> $rank{$b} keys %{ $HoH{$family} } {
d674 1
d685 6
a690 6
         STRING  => $string,
         LIST    => [ @@old_values ],
         LOOKUP  => { %some_table },
         FUNC    => \&some_function,
         FANON   => sub { $_[0] ** $_[1] },
         FH      => \*STDOUT,
d693 1
a693 1
     print $rec->{STRING};
d696 1
a696 1
     $last = pop @@ { $rec->{LIST} };
d701 2
a702 2
     $answer = &{ $rec->{FUNC} }($arg);
     $answer = &{ $rec->{FANON} }($arg1, $arg2);
d705 1
a705 1
     print { $rec->{FH} } "a string\n";
d708 2
a709 2
     $rec->{FH}->autoflush(1);
     $rec->{FH}->print(" a string\n");
d714 1
a714 1
        "flintstones" => {
d716 1
a716 1
            nights   => [ qw(monday thursday friday) ];
d720 1
a720 1
                { name => "pebbles", role => "kid", age  =>  4, },
d724 1
a724 1
        "jetsons"     => {
d726 1
a726 1
            nights   => [ qw(wednesday saturday) ];
d734 1
a734 1
        "simpsons"    => {
d736 1
a736 1
            nights   => [ qw(monday) ];
d750 1
a750 1
     # to parse complex datastructures if declared as data, so
d760 1
a760 1
     while () {
d780 1
a780 1
         for $person ( @@{$rec->{members}} ) {
d809 1
a809 1
         print "it turns out that $TV{$family}{'lead'} has ";
d821 2
a822 2
module that does attempt to partially address this need is the MLDBM
module.  Check your nearest CPAN site as described in L<perlmod> for
d827 1
a827 1
L<perlref>, L<perllol>, L<perldata>, L<perlobj>
d831 1
a831 4
Tom Christiansen E<lt>F<tchrist@@perl.com>E<gt>

Last update: 
Tue Dec 12 09:20:26 MST 1995
d833 2
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d24 1
a24 1
		$LoL[$x][$y][$z] =
d33 1
a33 1
How do you print it out?  Why can't you say just C<print @@LoL>?  How do
d37 1
a37 1
all the values have to be numeric?
d44 5
a48 5
This document is meant to be a detailed but understandable treatment of the
many different sorts of data structures you might want to develop.  It
should also serve as a cookbook of examples.  That way, when you need to
create one of these complex data structures, you can just pinch, pilfer, or
purloin a drop-in example from here.
d51 1
a51 1
sections on each of the following:
d65 4
d71 2
a72 2
But for now, let's look at general issues common to all
these types of data structures.
d79 1
a79 1
one-dimensional.  They can hold only scalar values (meaning a string,
d83 5
a87 5
You can't use a reference to a array or hash in quite the same way that you
would a real array or hash.  For C or C++ programmers unused to
distinguishing between arrays and pointers to the same, this can be
confusing.  If so, just think of it as the difference between a structure
and a pointer to a structure.
d92 3
a94 3
them right away--if ever.)  This means that when you have something which
looks to you like an access to a two-or-more-dimensional array and/or hash,
what's really going on is that the base type is
d105 1
a105 1
Now, because the top level contains only references, if you try to print
d133 1
a133 1
    }
d141 2
a142 2
	$counts[$i] = scalar @@list;
    }
d150 1
a150 1
    }
d152 1
a152 1
So, what's the big problem with that?  It looks right, doesn't it?
d167 1
a167 1
	printf("daemon name is %s\nroot name is %s\n",
d174 1
a174 1
    root name is daemon
d180 1
a180 1
broken code fragments:
d185 1
a185 1
    }
d189 1
a189 1
you want.
d197 1
a197 1
    }
d221 1
a221 1
So just remember always to use the array or hash constructors with C<[]>
d223 1
a223 1
efficient.
d231 1
a231 1
    }
d254 1
a254 1
=head1 CAVEAT ON PRECEDENCE
d293 1
a293 1
	[ "george", "jane", "elroy", "judy", ],
d300 1
a300 1
variable, and it would thereby remind you to write instead:
d306 10
a315 5
Before version 5.002, the standard Perl debugger didn't do a very nice job of
printing out complex data structures.  With 5.002 or above, the
debugger includes several new features, including command line editing as
well as the C<x> command to dump out complex data structures.  For
example, given the assignment to $LoL above, here's the debugger output:
d317 1
a317 1
    DB<1> x $LoL
d333 1
a333 1
	  2  'elroy'
d336 2
d340 2
a341 2
Presented with little comment (these will get their own manpages someday)
here are short code examples illustrating access of various
d359 1
a359 1
 }
d364 1
a364 1
 }
d370 1
a370 1
 }
d386 1
a386 1
 }
d391 1
a391 1
 }
d395 1
a395 1
     for $j ( 0 .. $#{ $LoL[$i] } ) {
d398 1
a398 1
 }
d405 3
a407 3
        flintstones        => [ "fred", "barney" ],
        jetsons            => [ "george", "jane", "elroy" ],
        simpsons           => [ "homer", "marge", "bart" ],
d417 1
a417 1
 }
d425 1
a425 1
 }
d430 1
a430 1
 }
d436 1
a436 1
 }
d452 1
a452 1
 }
d457 1
a457 1
     foreach $i ( 0 .. $#{ $HoL{$family} } ) {
d461 1
a461 1
 }
d464 1
a464 1
 foreach $family ( sort { @@{$HoL{$b}} <=> @@{$HoL{$a}} } keys %HoL ) {
a465 1
 }
d468 2
a469 8
 foreach $family ( sort {
			    @@{$HoL{$b}} <=> @@{$HoL{$a}}
					||
				    $a cmp $b
	    } keys %HoL )
 {
     print "$family: ", join(", ", sort @@{ $HoL{$family} }), "\n";
 }
d477 2
a478 2
            Lead     => "fred",
            Friend   => "barney",
a502 1
 }
d510 1
a510 1
 }
d514 1
a514 1
 while ( %fields = getnextpairset() ) {
d516 1
a516 1
 }
d521 1
a521 1
 }
d524 2
a525 2
 $LoH[0]{pet} = "dino";
 $LoH[2]{pet} = "santa's little helper";
d530 1
a530 1
 $LoH[0]{lead} = "fred";
d533 1
a533 1
 $LoH[1]{lead} =~ s/(\w)/\u$1/;
d542 1
a542 1
 }
d551 1
a551 1
 }
a557 1
 }
d564 3
a566 3
        flintstones => {
		lead      => "fred",
		pal       => "barney",
d568 10
a577 11
        jetsons     => {
		lead      => "george",
		wife      => "jane",
		"his boy" => "elroy",
        },
        simpsons    => {
		lead      => "homer",
		wife      => "marge",
		kid       => "bart",
	},
 );
d602 7
a608 1
 }
d613 1
a613 1
 }
d619 1
a619 1
 }
d623 2
a624 2
     wife => "wilma",
     pet  => "dino",
a625 1

d628 1
a628 1
 }
d633 1
a633 1
 $HoH{flintstones}{wife} = "wilma";
d640 2
a641 2
     print "$family: { ";
     for $role ( keys %{ $HoH{$family} } ) {
d645 1
a645 1
 }
d649 2
a650 2
     print "$family: { ";
     for $role ( sort keys %{ $HoH{$family} } ) {
a653 1
 }
d657 3
a659 3
 foreach $family ( sort { keys %{$HoH{$b}} <=> keys %{$HoH{$a}} } keys %HoH ) {
     print "$family: { ";
     for $role ( sort keys %{ $HoH{$family} } ) {
d663 1
a663 1
 }
d670 2
a671 2
 foreach $family ( sort { keys %{ $HoH{$b} } <=> keys %{ $HoH{$a} } } keys %HoH ) {
     print "$family: { ";
d673 1
a673 1
     for $role ( sort { $rank{$a} <=> $rank{$b} }  keys %{ $HoH{$family} } ) {
a676 1
 }
d687 6
a692 6
	 TEXT      => $string,
	 SEQUENCE  => [ @@old_values ],
	 LOOKUP    => { %some_table },
	 THATCODE  => \&some_function,
	 THISCODE  => sub { $_[0] ** $_[1] },
	 HANDLE    => \*STDOUT,
d695 1
a695 1
     print $rec->{TEXT};
d697 2
a698 2
     print $rec->{SEQUENCE}[0];
     $last = pop @@ { $rec->{SEQUENCE} };
d703 2
a704 2
     $answer = $rec->{THATCODE}->($arg);
     $answer = $rec->{THISCODE}->($arg1, $arg2);
d707 1
a707 1
     print { $rec->{HANDLE} } "a string\n";
d710 2
a711 2
     $rec->{HANDLE}->autoflush(1);
     $rec->{HANDLE}->print(" a string\n");
d716 1
a716 1
        flintstones => {
d718 1
a718 1
            nights   => [ qw(monday thursday friday) ],
d722 1
a722 1
                { name => "pebbles", role => "kid",  age  =>  4, },
d726 1
a726 1
        jetsons     => {
d728 1
a728 1
            nights   => [ qw(wednesday saturday) ],
d736 1
a736 1
        simpsons    => {
d738 1
a738 1
            nights   => [ qw(monday) ],
d752 1
a752 1
     # to parse complex data structures if declared as data, so
d762 1
a762 1
     while (<>) {
d782 1
a782 1
         for $person ( @@{ $rec->{members} } ) {
d811 1
a811 1
         print "it turns out that $TV{$family}{lead} has ";
d823 2
a824 2
module that does partially attempt to address this need is the MLDBM
module.  Check your nearest CPAN site as described in L<perlmodlib> for
d829 1
a829 1
perlref(1), perllol(1), perldata(1), perlobj(1)
d833 4
a836 1
Tom Christiansen <F<tchrist@@perl.com>>
a837 2
Last update:
Wed Oct 23 04:57:50 MET DST 1996
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d11 2
a12 2
get away with the C<$m{$AoA,$b}> notation borrowed from B<awk> in which the
keys are actually more like a single concatenated string C<"$AoA$b">, but
d24 1
a24 1
		$AoA[$x][$y][$z] =
d33 1
a33 1
How do you print it out?  Why can't you say just C<print @@AoA>?  How do
d96 2
a97 2
    $array[7][12]			# array of arrays
    $array[7]{string}			# array of hashes
d105 2
a106 2
    @@AoA = ( [2, 3], [4, 5, 7], [0] );
    print $AoA[1][2];
d108 1
a108 1
    print @@AoA;
d127 2
a128 2
	@@array = somefunc($i);
	$AoA[$i] = @@array;	# WRONG!
d131 1
a131 1
That's just the simple case of assigning an array to a scalar and getting
d136 2
a137 2
	@@array = somefunc($i);
	$counts[$i] = scalar @@array;
d144 2
a145 2
	@@array = somefunc($i);
	$AoA[$i] = \@@array;	# WRONG!
d153 2
a154 2
in @@AoA refer to the I<very same place>, and they will therefore all hold
whatever was last in @@array!  It's similar to the problem demonstrated in
d179 2
a180 2
	@@array = somefunc($i);
	$AoA[$i] = [ @@array ];
d184 1
a184 1
of what's in @@array at the time of the assignment.  This is what
d191 2
a192 2
	@@array = 0 .. $i;
	@@{$AoA[$i]} = @@array;
d198 1
a198 1
Something else could be going on in this new case with the C<@@{$AoA[$i]}}>
d200 2
a201 2
whether C<$AoA[$i]> had been undefined to start with, or whether it
already contained a reference.  If you had already populated @@AoA with
d204 1
a204 1
    $AoA[3] = \@@another_array;
d209 1
a209 1
    @@{$AoA[3]} = @@array;
d212 1
a212 1
@@another_array.  (Have you ever noticed how when a programmer says
d225 2
a226 2
        my @@array = somefunc($i);
        $AoA[$i] = \@@array;
d245 3
a247 3
    $AoA[$i] = [ @@array ];	# usually best
    $AoA[$i] = \@@array;		# perilous; just how my() was that array?
    @@{ $AoA[$i] } = @@array;	# way too tricky for most programmers
d252 1
a252 1
Speaking of things like C<@@{$AoA[$i]}>, the following are actually the
d255 2
a256 2
    $aref->[2][2]	# clear
    $$aref[2][2]	# confusing
d266 2
a267 2
The seemingly equivalent construct in Perl, C<$$aref[$i]> first does
the deref of $aref, making it take $aref as a reference to an
d269 2
a270 2
of the array pointed to by $AoA. If you wanted the C notion, you'd have to
write C<${$AoA[$i]}> to force the C<$AoA[$i]> to get evaluated first
d286 1
a286 1
    my $aref = [
d292 1
a292 1
    print $aref[2][2];
d295 1
a295 1
because you were accidentally accessing C<@@aref>, an undeclared
d298 1
a298 1
    print $aref->[2][2]
d306 1
a306 1
example, given the assignment to $AoA above, here's the debugger output:
d308 2
a309 2
    DB<1> x $AoA
    $AoA = ARRAY(0x13b5a0)
d333 1
a333 1
=head1 ARRAYS OF ARRAYS
d335 1
a335 1
=head2 Declaration of a ARRAY OF ARRAYS
d337 1
a337 1
 @@AoA = (
d343 1
a343 1
=head2 Generation of a ARRAY OF ARRAYS
d347 1
a347 1
     push @@AoA, [ split ];
d352 1
a352 1
     $AoA[$i] = [ somefunc($i) ];
d358 1
a358 1
     $AoA[$i] = [ @@tmp ];
d362 1
a362 1
 push @@{ $AoA[0] }, "wilma", "betty";
d364 1
a364 1
=head2 Access and Printing of a ARRAY OF ARRAYS
d367 1
a367 1
 $AoA[0][0] = "Fred";
d370 1
a370 1
 $AoA[1][1] =~ s/(\w)/\u$1/;
d373 1
a373 1
 for $aref ( @@AoA ) {
d378 2
a379 2
 for $i ( 0 .. $#AoA ) {
     print "\t [ @@{$AoA[$i]} ],\n";
d383 3
a385 3
 for $i ( 0 .. $#AoA ) {
     for $j ( 0 .. $#{ $AoA[$i] } ) {
         print "elt $i $j is $AoA[$i][$j]\n";
d389 1
a389 1
=head1 HASHES OF ARRAYS
d391 1
a391 1
=head2 Declaration of a HASH OF ARRAYS
d393 1
a393 1
 %HoA = (
d399 1
a399 1
=head2 Generation of a HASH OF ARRAYS
d405 1
a405 1
     $HoA{$1} = [ split ];
d413 1
a413 1
     $HoA{$who} = [ @@fields ];
d418 1
a418 1
     $HoA{$group} = [ get_family($group) ];
d424 1
a424 1
     $HoA{$group} = [ @@members ];
d428 1
a428 1
 push @@{ $HoA{"flintstones"} }, "wilma", "betty";
d430 1
a430 1
=head2 Access and Printing of a HASH OF ARRAYS
d433 1
a433 1
 $HoA{flintstones}[0] = "Fred";
d436 1
a436 1
 $HoA{simpsons}[1] =~ s/(\w)/\u$1/;
d439 2
a440 2
 foreach $family ( keys %HoA ) {
     print "$family: @@{ $HoA{$family} }\n"
d444 1
a444 1
 foreach $family ( keys %HoA ) {
d446 2
a447 2
     foreach $i ( 0 .. $#{ $HoA{$family} } ) {
         print " $i = $HoA{$family}[$i]";
d453 2
a454 2
 foreach $family ( sort { @@{$HoA{$b}} <=> @@{$HoA{$a}} } keys %HoA ) {
     print "$family: @@{ $HoA{$family} }\n"
d459 1
a459 1
			    @@{$HoA{$b}} <=> @@{$HoA{$a}}
d462 1
a462 1
	    } keys %HoA )
d464 1
a464 1
     print "$family: ", join(", ", sort @@{ $HoA{$family} }), "\n";
d467 1
a467 1
=head1 ARRAYS OF HASHES
d469 1
a469 1
=head2 Declaration of a ARRAY OF HASHES
d471 1
a471 1
 @@AoH = (
d488 1
a488 1
=head2 Generation of a ARRAY OF HASHES
d498 1
a498 1
     push @@AoH, $rec;
d506 1
a506 1
     push @@AoH, { split /[\s+=]/ };
d509 1
a509 1
 # calling a function  that returns a key/value pair list, like
d512 1
a512 1
     push @@AoH, { %fields };
d517 1
a517 1
     push @@AoH, { parsepairs($_) };
d521 2
a522 2
 $AoH[0]{pet} = "dino";
 $AoH[2]{pet} = "santa's little helper";
d524 1
a524 1
=head2 Access and Printing of a ARRAY OF HASHES
d527 1
a527 1
 $AoH[0]{lead} = "fred";
d530 1
a530 1
 $AoH[1]{lead} =~ s/(\w)/\u$1/;
d533 1
a533 1
 for $href ( @@AoH ) {
d542 1
a542 1
 for $i ( 0 .. $#AoH ) {
d544 2
a545 2
     for $role ( keys %{ $AoH[$i] } ) {
         print "$role=$AoH[$i]{$role} ";
d551 3
a553 3
 for $i ( 0 .. $#AoH ) {
     for $role ( keys %{ $AoH[$i] } ) {
         print "elt $i $role is $AoH[$i]{$role}\n";
d770 3
a772 3
     # change one piece, it changes everywhere, like for example
     # if you wanted a {kids} field that was a reference
     # to an array of the kids' records without having duplicate
d787 1
a787 1
     # you copied the array, but the array itself contains pointers
@


1.1.1.4
log
@stock perl 5.8.0 from CPAN
@
text
@d18 1
a18 1
may now write something like this and all of a sudden, you'd have an array
d35 1
a35 1
from a function?  Is it an object?  Can you save it to disk to read
d79 1
a79 1
You can't use a reference to an array or hash in quite the same way that you
d335 1
a335 1
=head2 Declaration of an ARRAY OF ARRAYS
d343 1
a343 1
=head2 Generation of an ARRAY OF ARRAYS
d364 1
a364 1
=head2 Access and Printing of an ARRAY OF ARRAYS
d469 1
a469 1
=head2 Declaration of an ARRAY OF HASHES
d488 1
a488 1
=head2 Generation of an ARRAY OF HASHES
d524 1
a524 1
=head2 Access and Printing of an ARRAY OF HASHES
@


1.1.1.5
log
@perl 5.8.8 import
@
text
@a1 1
X<data structure> X<complex data structure> X<struct>
a70 1
X<reference> X<dereference> X<dereferencing> X<pointer>
a77 1
X<multidimensional array> X<array, multidimensional>
a176 1
X<[]> X<{}>
a250 1
X<dereference, precedence> X<dereferencing, precedence>
a253 1
X<< -> >>
a300 4
X<data structure, debugging> X<complex data structure, debugging>
X<AoA, debugging> X<HoA, debugging> X<AoH, debugging> X<HoH, debugging>
X<array of arrays, debugging> X<hash of arrays, debugging>
X<array of hashes, debugging> X<hash of hashes, debugging>
a333 1
X<array of arrays> X<AoA>
a389 1
X<hash of arrays> X<HoA>
a467 1
X<array of hashes> X<AoH>
a557 1
X<hass of hashes> X<HoH>
a675 1
X<record> X<structure> X<struct>
@


1.1.1.6
log
@import perl 5.10.0 from CPAN
@
text
@d202 1
a202 1
Something else could be going on in this new case with the C<@@{$AoA[$i]}>
@


1.1.1.7
log
@import perl 5.10.1
@
text
@d74 2
a75 2
The most important thing to understand about all data structures in
Perl--including multidimensional arrays--is that even though they might
d571 1
a571 1
X<hash of hashes> X<HoH>
@


1.1.1.8
log
@Perl 5.12.2 from CPAN
@
text
@d88 2
a89 2
You can (and should) read more about references in L<perlref>.
Briefly, references are rather like pointers that know what they
d840 1
a840 1
L<perlref>, L<perllol>, L<perldata>, L<perlobj>
@


1.1.1.9
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d8 13
a20 2
Perl lets us have complex data structures.  You can write something like
this and all of a sudden, you'd have an array with three dimensions!
d312 5
a316 2
You can use the debugger's C<x> command to dump out complex data structures.
For example, given the assignment to $AoA above, here's the debugger output:
d845 3
@


