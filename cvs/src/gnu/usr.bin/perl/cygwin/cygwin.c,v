head	1.2;
access;
symbols
	OPENBSD_6_0:1.1.1.9.0.10
	OPENBSD_6_0_BASE:1.1.1.9
	OPENBSD_5_9:1.1.1.9.0.4
	OPENBSD_5_9_BASE:1.1.1.9
	OPENBSD_5_8:1.1.1.9.0.6
	OPENBSD_5_8_BASE:1.1.1.9
	PERL_5_20_2:1.1.1.9
	OPENBSD_5_7:1.1.1.9.0.2
	OPENBSD_5_7_BASE:1.1.1.9
	PERL_5_20_1:1.1.1.9
	OPENBSD_5_6:1.1.1.8.0.4
	OPENBSD_5_6_BASE:1.1.1.8
	PERL_5_18_2:1.1.1.8
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.7.0.6
	OPENBSD_5_5_BASE:1.1.1.7
	OPENBSD_5_4:1.1.1.7.0.2
	OPENBSD_5_4_BASE:1.1.1.7
	PERL_5_16_3:1.1.1.7
	OPENBSD_5_3:1.1.1.6.0.14
	OPENBSD_5_3_BASE:1.1.1.6
	OPENBSD_5_2:1.1.1.6.0.12
	OPENBSD_5_2_BASE:1.1.1.6
	OPENBSD_5_1_BASE:1.1.1.6
	OPENBSD_5_1:1.1.1.6.0.10
	OPENBSD_5_0:1.1.1.6.0.8
	OPENBSD_5_0_BASE:1.1.1.6
	OPENBSD_4_9:1.1.1.6.0.6
	OPENBSD_4_9_BASE:1.1.1.6
	PERL_5_12_2:1.1.1.6
	OPENBSD_4_8:1.1.1.6.0.4
	OPENBSD_4_8_BASE:1.1.1.6
	OPENBSD_4_7:1.1.1.6.0.2
	OPENBSD_4_7_BASE:1.1.1.6
	PERL_5_10_1:1.1.1.6
	OPENBSD_4_6:1.1.1.5.0.6
	OPENBSD_4_6_BASE:1.1.1.5
	OPENBSD_4_5:1.1.1.5.0.2
	OPENBSD_4_5_BASE:1.1.1.5
	PERL_5_10_0:1.1.1.5
	OPENBSD_4_4:1.1.1.4.0.10
	OPENBSD_4_4_BASE:1.1.1.4
	OPENBSD_4_3:1.1.1.4.0.8
	OPENBSD_4_3_BASE:1.1.1.4
	OPENBSD_4_2:1.1.1.4.0.6
	OPENBSD_4_2_BASE:1.1.1.4
	OPENBSD_4_1:1.1.1.4.0.4
	OPENBSD_4_1_BASE:1.1.1.4
	OPENBSD_4_0:1.1.1.4.0.2
	OPENBSD_4_0_BASE:1.1.1.4
	PERL_5_8_8:1.1.1.4
	OPENBSD_3_9:1.1.1.3.0.14
	OPENBSD_3_9_BASE:1.1.1.3
	OPENBSD_3_8:1.1.1.3.0.12
	OPENBSD_3_8_BASE:1.1.1.3
	OPENBSD_3_7:1.1.1.3.0.10
	OPENBSD_3_7_BASE:1.1.1.3
	PERL_5_8_6:1.1.1.3
	OPENBSD_3_6:1.1.1.3.0.8
	OPENBSD_3_6_BASE:1.1.1.3
	PERL_5_8_5:1.1.1.3
	PERL_5_8_3:1.1.1.3
	OPENBSD_3_5:1.1.1.3.0.6
	OPENBSD_3_5_BASE:1.1.1.3
	PERL_5_8_2:1.1.1.3
	OPENBSD_3_4:1.1.1.3.0.4
	OPENBSD_3_4_BASE:1.1.1.3
	OPENBSD_3_3:1.1.1.3.0.2
	OPENBSD_3_3_BASE:1.1.1.3
	PERL_5_8_0:1.1.1.3
	OPENBSD_3_2:1.1.1.2.0.6
	OPENBSD_3_2_BASE:1.1.1.2
	OPENBSD_3_1:1.1.1.2.0.4
	OPENBSD_3_1_BASE:1.1.1.2
	OPENBSD_3_0:1.1.1.2.0.2
	OPENBSD_3_0_BASE:1.1.1.2
	PERL_5_6_1:1.1.1.2
	OPENBSD_2_9:1.1.1.1.0.6
	OPENBSD_2_9_BASE:1.1.1.1
	OPENBSD_2_8:1.1.1.1.0.4
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.2
	OPENBSD_2_7_BASE:1.1.1.1
	PERL_5_6_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.2
date	2017.02.05.00.32.08;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2000.04.06.16.08.58;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.04.06.16.08.58;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.05.24.18.22.35;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.10.27.22.14.52;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2006.03.28.18.47.50;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2008.09.29.17.18.26;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2009.10.12.18.10.38;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2013.03.25.20.08.32;	author sthen;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2014.03.24.14.58.59;	author afresh1;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2014.11.17.20.53.02;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@/*
 * Cygwin extras
 */

#define PERLIO_NOT_STDIO 0
#include "EXTERN.h"
#include "perl.h"
#undef USE_DYNAMIC_LOADING
#include "XSUB.h"

#include <unistd.h>
#include <process.h>
#include <sys/cygwin.h>
#include <cygwin/version.h>
#include <mntent.h>
#include <alloca.h>
#include <dlfcn.h>
#if (CYGWIN_VERSION_API_MINOR >= 181)
#include <wchar.h>
#endif

/*
 * pp_system() implemented via spawn()
 * - more efficient and useful when embedding Perl in non-Cygwin apps
 * - code mostly borrowed from djgpp.c
 */
static int
do_spawnvp (const char *path, const char * const *argv)
{
    dTHX;
    Sigsave_t ihand,qhand;
    int childpid, result, status;

    rsignal_save(SIGINT, (Sighandler_t) SIG_IGN, &ihand);
    rsignal_save(SIGQUIT, (Sighandler_t) SIG_IGN, &qhand);
    childpid = spawnvp(_P_NOWAIT,path,argv);
    if (childpid < 0) {
	status = -1;
	if(ckWARN(WARN_EXEC))
	    Perl_warner(aTHX_ packWARN(WARN_EXEC),"Can't spawn \"%s\": %s",
		    path,Strerror (errno));
    } else {
	do {
	    result = wait4pid(childpid, &status, 0);
	} while (result == -1 && errno == EINTR);
	if(result < 0)
	    status = -1;
    }
    (void)rsignal_restore(SIGINT, &ihand);
    (void)rsignal_restore(SIGQUIT, &qhand);
    return status;
}

int
do_aspawn (SV *really, void **mark, void **sp)
{
    dTHX;
    int  rc;
    char const **a;
    char *tmps,**argv;
    STRLEN n_a;

    if (sp<=mark)
        return -1;
    argv=(char**) alloca ((sp-mark+3)*sizeof (char*));
    a=(char const **)argv;

    while (++mark <= sp)
        if (*mark)
            *a++ = SvPVx((SV *)*mark, n_a);
        else
            *a++ = "";
    *a = (char*)NULL;

    if (argv[0][0] != '/' && argv[0][0] != '\\'
        && !(argv[0][0] && argv[0][1] == ':'
        && (argv[0][2] == '/' || argv[0][2] != '\\'))
     ) /* will swawnvp use PATH? */
         TAINT_ENV();	/* testing IFS here is overkill, probably */

    if (really && *(tmps = SvPV(really, n_a)))
        rc=do_spawnvp (tmps,(const char * const *)argv);
    else
        rc=do_spawnvp (argv[0],(const char *const *)argv);

    return rc;
}

int
do_spawn (char *cmd)
{
    dTHX;
    char const **a;
    char *s;
    char const *metachars = "$&*(){}[]'\";\\?>|<~`\n";
    const char *command[4];

    while (*cmd && isSPACE(*cmd))
	cmd++;

    if (strnEQ (cmd,"/bin/sh",7) && isSPACE (cmd[7]))
        cmd+=5;

    /* save an extra exec if possible */
    /* see if there are shell metacharacters in it */
    if (strstr (cmd,"..."))
	goto doshell;
    if (*cmd=='.' && isSPACE (cmd[1]))
	goto doshell;
    if (strnEQ (cmd,"exec",4) && isSPACE (cmd[4]))
	goto doshell;
    for (s=cmd; *s && isALPHA (*s); s++) ;	/* catch VAR=val gizmo */
	if (*s=='=')
	    goto doshell;

    for (s=cmd; *s; s++)
	if (strchr (metachars,*s))
	{
	    if (*s=='\n' && s[1]=='\0')
	    {
		*s='\0';
		break;
	    }
	doshell:
	    command[0] = "sh";
	    command[1] = "-c";
	    command[2] = cmd;
	    command[3] = NULL;

	    return do_spawnvp("sh",command);
	}

    Newx (PL_Argv, (s-cmd)/2+2, const char*);
    PL_Cmd=savepvn (cmd,s-cmd);
    a=PL_Argv;
    for (s=PL_Cmd; *s;) {
	while (*s && isSPACE (*s)) s++;
	if (*s)
	    *(a++)=s;
	while (*s && !isSPACE (*s)) s++;
	if (*s)
	    *s++='\0';
    }
    *a = (char*)NULL;
    if (!PL_Argv[0])
        return -1;

    return do_spawnvp(PL_Argv[0],(const char * const *)PL_Argv);
}

#if (CYGWIN_VERSION_API_MINOR >= 181)
char*
wide_to_utf8(const wchar_t *wbuf)
{
    char *buf;
    int wlen = 0;
    char *oldlocale;
    dVAR;

    /* Here and elsewhere in this file, we have a critical section to prevent
     * another thread from changing the locale out from under us.  XXX But why
     * not just use uvchr_to_utf8? */
    LOCALE_LOCK;

    oldlocale = setlocale(LC_CTYPE, NULL);
    setlocale(LC_CTYPE, "utf-8");

    /* uvchr_to_utf8(buf, chr) or Encoding::_bytes_to_utf8(sv, "UCS-2BE"); */
    wlen = wcsrtombs(NULL, (const wchar_t **)&wbuf, wlen, NULL);
    buf = (char *) safemalloc(wlen+1);
    wcsrtombs(buf, (const wchar_t **)&wbuf, wlen, NULL);

    if (oldlocale) setlocale(LC_CTYPE, oldlocale);
    else setlocale(LC_CTYPE, "C");

    LOCALE_UNLOCK;

    return buf;
}

wchar_t*
utf8_to_wide(const char *buf)
{
    wchar_t *wbuf;
    mbstate_t mbs;
    char *oldlocale;
    int wlen = sizeof(wchar_t)*strlen(buf);
    dVAR;

    LOCALE_LOCK;

    oldlocale = setlocale(LC_CTYPE, NULL);

    setlocale(LC_CTYPE, "utf-8");
    wbuf = (wchar_t *) safemalloc(wlen);
    /* utf8_to_uvchr_buf(pathname, pathname + wlen, wpath) or Encoding::_utf8_to_bytes(sv, "UCS-2BE"); */
    wlen = mbsrtowcs(wbuf, (const char**)&buf, wlen, &mbs);

    if (oldlocale) setlocale(LC_CTYPE, oldlocale);
    else setlocale(LC_CTYPE, "C");

    LOCALE_UNLOCK;

    return wbuf;
}
#endif /* cygwin 1.7 */

/* see also Cwd.pm */
XS(Cygwin_cwd)
{
    dXSARGS;
    char *cwd;

    /* See http://rt.perl.org/rt3/Ticket/Display.html?id=38628 
       There is Cwd->cwd() usage in the wild, and previous versions didn't die.
     */
    if(items > 1)
	Perl_croak(aTHX_ "Usage: Cwd::cwd()");
    if((cwd = getcwd(NULL, -1))) {
	ST(0) = sv_2mortal(newSVpv(cwd, 0));
	free(cwd);
	SvTAINTED_on(ST(0));
	XSRETURN(1);
    }
    XSRETURN_UNDEF;
}

XS(XS_Cygwin_pid_to_winpid)
{
    dXSARGS;
    dXSTARG;
    pid_t pid, RETVAL;

    if (items != 1)
        Perl_croak(aTHX_ "Usage: Cygwin::pid_to_winpid(pid)");

    pid = (pid_t)SvIV(ST(0));

    if ((RETVAL = cygwin_internal(CW_CYGWIN_PID_TO_WINPID, pid)) > 0) {
	XSprePUSH; PUSHi((IV)RETVAL);
        XSRETURN(1);
    }
    XSRETURN_UNDEF;
}

XS(XS_Cygwin_winpid_to_pid)
{
    dXSARGS;
    dXSTARG;
    pid_t pid, RETVAL;

    if (items != 1)
        Perl_croak(aTHX_ "Usage: Cygwin::winpid_to_pid(pid)");

    pid = (pid_t)SvIV(ST(0));

#if (CYGWIN_VERSION_API_MINOR >= 181)
    RETVAL = cygwin_winpid_to_pid(pid);
#else
    RETVAL = cygwin32_winpid_to_pid(pid);
#endif
    if (RETVAL > 0) {
        XSprePUSH; PUSHi((IV)RETVAL);
        XSRETURN(1);
    }
    XSRETURN_UNDEF;
}

XS(XS_Cygwin_win_to_posix_path)

{
    dXSARGS;
    int absolute_flag = 0;
    STRLEN len;
    int err = 0;
    char *src_path;
    char *posix_path;
    int isutf8 = 0;

    if (items < 1 || items > 2)
        Perl_croak(aTHX_ "Usage: Cygwin::win_to_posix_path(pathname, [absolute])");

    src_path = SvPV(ST(0), len);
    if (items == 2)
	absolute_flag = SvTRUE(ST(1));

    if (!len)
	Perl_croak(aTHX_ "can't convert empty path");
    isutf8 = SvUTF8(ST(0));

#if (CYGWIN_VERSION_API_MINOR >= 181)
    /* Check utf8 flag and use wide api then.
       Size calculation: On overflow let cygwin_conv_path calculate the final size.
     */
    if (isutf8) {
	int what = absolute_flag ? CCP_WIN_W_TO_POSIX : CCP_WIN_W_TO_POSIX | CCP_RELATIVE;
	int wlen = sizeof(wchar_t)*(len + 260 + 1001);
	wchar_t *wpath = (wchar_t *) safemalloc(sizeof(wchar_t)*len);
	wchar_t *wbuf = (wchar_t *) safemalloc(wlen);
	if (!IN_BYTES) {
	    mbstate_t mbs;
            char *oldlocale;
            dVAR;

            LOCALE_LOCK;

            oldlocale = setlocale(LC_CTYPE, NULL);
            setlocale(LC_CTYPE, "utf-8");
	    /* utf8_to_uvchr_buf(src_path, src_path + wlen, wpath) or Encoding::_utf8_to_bytes(sv, "UCS-2BE"); */
	    wlen = mbsrtowcs(wpath, (const char**)&src_path, wlen, &mbs);
	    if (wlen > 0)
		err = cygwin_conv_path(what, wpath, wbuf, wlen);
            if (oldlocale) setlocale(LC_CTYPE, oldlocale);
            else setlocale(LC_CTYPE, "C");

            LOCALE_UNLOCK;
	} else { /* use bytes; assume already ucs-2 encoded bytestream */
	    err = cygwin_conv_path(what, src_path, wbuf, wlen);
	}
	if (err == ENOSPC) { /* our space assumption was wrong, not enough space */
	    int newlen = cygwin_conv_path(what, wpath, wbuf, 0);
	    wbuf = (wchar_t *) realloc(&wbuf, newlen);
	    err = cygwin_conv_path(what, wpath, wbuf, newlen);
	    wlen = newlen;
	}
	/* utf16_to_utf8(*p, *d, bytlen, *newlen) */
	posix_path = (char *) safemalloc(wlen*3);
	Perl_utf16_to_utf8(aTHX_ (U8*)&wpath, (U8*)posix_path, (I32)wlen*2, (I32*)&len);
	/*
	wlen = wcsrtombs(NULL, (const wchar_t **)&wbuf, wlen, NULL);
	posix_path = (char *) safemalloc(wlen+1);
	wcsrtombs(posix_path, (const wchar_t **)&wbuf, wlen, NULL);
	*/
    } else {
	int what = absolute_flag ? CCP_WIN_A_TO_POSIX : CCP_WIN_A_TO_POSIX | CCP_RELATIVE;
	posix_path = (char *) safemalloc (len + 260 + 1001);
	err = cygwin_conv_path(what, src_path, posix_path, len + 260 + 1001);
	if (err == ENOSPC) { /* our space assumption was wrong, not enough space */
	    int newlen = cygwin_conv_path(what, src_path, posix_path, 0);
	    posix_path = (char *) realloc(&posix_path, newlen);
	    err = cygwin_conv_path(what, src_path, posix_path, newlen);
	}
    }
#else
    posix_path = (char *) safemalloc (len + 260 + 1001);
    if (absolute_flag)
	err = cygwin_conv_to_full_posix_path(src_path, posix_path);
    else
	err = cygwin_conv_to_posix_path(src_path, posix_path);
#endif
    if (!err) {
	EXTEND(SP, 1);
	ST(0) = sv_2mortal(newSVpv(posix_path, 0));
	if (isutf8) { /* src was utf-8, so result should also */
	    /* TODO: convert ANSI (local windows encoding) to utf-8 on cygwin-1.5 */
	    SvUTF8_on(ST(0));
	}
	safefree(posix_path);
        XSRETURN(1);
    } else {
	safefree(posix_path);
	XSRETURN_UNDEF;
    }
}

XS(XS_Cygwin_posix_to_win_path)
{
    dXSARGS;
    int absolute_flag = 0;
    STRLEN len;
    int err = 0;
    char *src_path, *win_path;
    int isutf8 = 0;

    if (items < 1 || items > 2)
        Perl_croak(aTHX_ "Usage: Cygwin::posix_to_win_path(pathname, [absolute])");

    src_path = SvPVx(ST(0), len);
    if (items == 2)
	absolute_flag = SvTRUE(ST(1));

    if (!len)
	Perl_croak(aTHX_ "can't convert empty path");
    isutf8 = SvUTF8(ST(0));
#if (CYGWIN_VERSION_API_MINOR >= 181)
    /* Check utf8 flag and use wide api then.
       Size calculation: On overflow let cygwin_conv_path calculate the final size.
     */
    if (isutf8) {
	int what = absolute_flag ? CCP_POSIX_TO_WIN_W : CCP_POSIX_TO_WIN_W | CCP_RELATIVE;
	int wlen = sizeof(wchar_t)*(len + 260 + 1001);
	wchar_t *wpath = (wchar_t *) safemalloc(sizeof(wchar_t)*len);
	wchar_t *wbuf = (wchar_t *) safemalloc(wlen);
	char *oldlocale;
        dVAR;

        LOCALE_LOCK;

	oldlocale = setlocale(LC_CTYPE, NULL);
	setlocale(LC_CTYPE, "utf-8");
	if (!IN_BYTES) {
	    mbstate_t mbs;
	    /* utf8_to_uvchr_buf(src_path, src_path + wlen, wpath) or Encoding::_utf8_to_bytes(sv, "UCS-2BE"); */
	    wlen = mbsrtowcs(wpath, (const char**)&src_path, wlen, &mbs);
	    if (wlen > 0)
		err = cygwin_conv_path(what, wpath, wbuf, wlen);
	} else { /* use bytes; assume already ucs-2 encoded bytestream */
	    err = cygwin_conv_path(what, src_path, wbuf, wlen);
	}
	if (err == ENOSPC) { /* our space assumption was wrong, not enough space */
	    int newlen = cygwin_conv_path(what, wpath, wbuf, 0);
	    wbuf = (wchar_t *) realloc(&wbuf, newlen);
	    err = cygwin_conv_path(what, wpath, wbuf, newlen);
	    wlen = newlen;
	}
	/* also see utf8.c: Perl_utf16_to_utf8() or Encoding::_bytes_to_utf8(sv, "UCS-2BE"); */
	wlen = wcsrtombs(NULL, (const wchar_t **)&wbuf, wlen, NULL);
	win_path = (char *) safemalloc(wlen+1);
	wcsrtombs(win_path, (const wchar_t **)&wbuf, wlen, NULL);
	if (oldlocale) setlocale(LC_CTYPE, oldlocale);
	else setlocale(LC_CTYPE, "C");

        LOCALE_UNLOCK;
    } else {
	int what = absolute_flag ? CCP_POSIX_TO_WIN_A : CCP_POSIX_TO_WIN_A | CCP_RELATIVE;
	win_path = (char *) safemalloc(len + 260 + 1001);
	err = cygwin_conv_path(what, src_path, win_path, len + 260 + 1001);
	if (err == ENOSPC) { /* our space assumption was wrong, not enough space */
	    int newlen = cygwin_conv_path(what, src_path, win_path, 0);
	    win_path = (char *) realloc(&win_path, newlen);
	    err = cygwin_conv_path(what, src_path, win_path, newlen);
	}
    }
#else
    if (isutf8)
	Perl_warn(aTHX_ "can't convert utf8 path");
    win_path = (char *) safemalloc(len + 260 + 1001);
    if (absolute_flag)
	err = cygwin_conv_to_full_win32_path(src_path, win_path);
    else
	err = cygwin_conv_to_win32_path(src_path, win_path);
#endif
    if (!err) {
	EXTEND(SP, 1);
	ST(0) = sv_2mortal(newSVpv(win_path, 0));
	if (isutf8) {
	    SvUTF8_on(ST(0));
	}
	safefree(win_path);
	XSRETURN(1);
    } else {
	safefree(win_path);
	XSRETURN_UNDEF;
    }
}

XS(XS_Cygwin_mount_table)
{
    dXSARGS;
    struct mntent *mnt;

    if (items != 0)
        Perl_croak(aTHX_ "Usage: Cygwin::mount_table");
    /* => array of [mnt_dir mnt_fsname mnt_type mnt_opts] */

    setmntent (0, 0);
    while ((mnt = getmntent (0))) {
	AV* av = newAV();
	av_push(av, newSVpvn(mnt->mnt_dir, strlen(mnt->mnt_dir)));
	av_push(av, newSVpvn(mnt->mnt_fsname, strlen(mnt->mnt_fsname)));
	av_push(av, newSVpvn(mnt->mnt_type, strlen(mnt->mnt_type)));
	av_push(av, newSVpvn(mnt->mnt_opts, strlen(mnt->mnt_opts)));
	XPUSHs(sv_2mortal(newRV_noinc((SV*)av)));
    }
    endmntent (0);
    PUTBACK;
}

XS(XS_Cygwin_mount_flags)
{
    dXSARGS;
    char *pathname;
    char flags[PATH_MAX];
    flags[0] = '\0';

    if (items != 1)
        Perl_croak(aTHX_ "Usage: Cygwin::mount_flags( mnt_dir | '/cygdrive' )");

    pathname = SvPV_nolen(ST(0));

    if (!strcmp(pathname, "/cygdrive")) {
	char user[PATH_MAX];
	char system[PATH_MAX];
	char user_flags[PATH_MAX];
	char system_flags[PATH_MAX];

	cygwin_internal (CW_GET_CYGDRIVE_INFO, user, system,
			 user_flags, system_flags);

        if (strlen(user) > 0) {
            sprintf(flags, "%s,cygdrive,%s", user_flags, user);
        } else {
            sprintf(flags, "%s,cygdrive,%s", system_flags, system);
        }

	ST(0) = sv_2mortal(newSVpv(flags, 0));
	XSRETURN(1);

    } else {
	struct mntent *mnt;
	int found = 0;
	setmntent (0, 0);
	while ((mnt = getmntent (0))) {
	    if (!strcmp(pathname, mnt->mnt_dir)) {
		strcpy(flags, mnt->mnt_type);
		if (strlen(mnt->mnt_opts) > 0) {
		    strcat(flags, ",");
		    strcat(flags, mnt->mnt_opts);
		}
		found++;
		break;
	    }
	}
	endmntent (0);

	/* Check if arg is the current volume moint point if not default,
	 * and then use CW_GET_CYGDRIVE_INFO also.
	 */
	if (!found) {
	    char user[PATH_MAX];
	    char system[PATH_MAX];
	    char user_flags[PATH_MAX];
	    char system_flags[PATH_MAX];

	    cygwin_internal (CW_GET_CYGDRIVE_INFO, user, system,
			     user_flags, system_flags);

	    if (strlen(user) > 0) {
		if (strcmp(user,pathname)) {
		    sprintf(flags, "%s,cygdrive,%s", user_flags, user);
		    found++;
		}
	    } else {
		if (strcmp(user,pathname)) {
		    sprintf(flags, "%s,cygdrive,%s", system_flags, system);
		    found++;
		}
	    }
	}
	if (found) {
	    ST(0) = sv_2mortal(newSVpv(flags, 0));
	    XSRETURN(1);
	} else {
	    XSRETURN_UNDEF;
	}
    }
}

XS(XS_Cygwin_is_binmount)
{
    dXSARGS;
    char *pathname;

    if (items != 1)
        Perl_croak(aTHX_ "Usage: Cygwin::is_binmount(pathname)");

    pathname = SvPV_nolen(ST(0));

    ST(0) = boolSV(cygwin_internal(CW_GET_BINMODE, pathname));
    XSRETURN(1);
}

XS(XS_Cygwin_sync_winenv){ cygwin_internal(CW_SYNC_WINENV); }

void
init_os_extras(void)
{
    dTHX;
    char const *file = __FILE__;
    void *handle;

    newXS("Cwd::cwd", Cygwin_cwd, file);
    newXSproto("Cygwin::winpid_to_pid", XS_Cygwin_winpid_to_pid, file, "$");
    newXSproto("Cygwin::pid_to_winpid", XS_Cygwin_pid_to_winpid, file, "$");
    newXSproto("Cygwin::win_to_posix_path", XS_Cygwin_win_to_posix_path, file, "$;$");
    newXSproto("Cygwin::posix_to_win_path", XS_Cygwin_posix_to_win_path, file, "$;$");
    newXSproto("Cygwin::mount_table", XS_Cygwin_mount_table, file, "");
    newXSproto("Cygwin::mount_flags", XS_Cygwin_mount_flags, file, "$");
    newXSproto("Cygwin::is_binmount", XS_Cygwin_is_binmount, file, "$");
    newXS("Cygwin::sync_winenv", XS_Cygwin_sync_winenv, file);

    /* Initialize Win32CORE if it has been statically linked. */
    handle = dlopen(NULL, RTLD_LAZY);
    if (handle) {
        void (*pfn_init)(pTHX);
        pfn_init = (void (*)(pTHX))dlsym(handle, "init_Win32CORE");
        if (pfn_init)
            pfn_init(aTHX);
        dlclose(handle);
    }
}
@


1.1
log
@Initial revision
@
text
@d5 1
d12 9
d22 185
a208 1
static
d214 4
a217 1
    if(items != 0)
d219 1
a219 1
    if(cwd = getcwd(NULL, 0)) {
d221 2
a222 1
	safesysfree(cwd);
d228 347
a577 1
    char *file = __FILE__;
d579 2
d583 18
@


1.1.1.1
log
@virgin perl 5.6.0
@
text
@@


1.1.1.2
log
@stock perl 5.6.1
@
text
@a10 1
#include <process.h>
a11 124
/*
 * pp_system() implemented via spawn()
 * - more efficient and useful when embedding Perl in non-Cygwin apps
 * - code mostly borrowed from djgpp.c
 */
static int
do_spawnvp (const char *path, const char * const *argv)
{
    dTHXo;
    Sigsave_t ihand,qhand;
    int childpid, result, status;

    rsignal_save(SIGINT, SIG_IGN, &ihand);
    rsignal_save(SIGQUIT, SIG_IGN, &qhand);
    childpid = spawnvp(_P_NOWAIT,path,argv);
    if (childpid < 0) {
	status = -1;
	if(ckWARN(WARN_EXEC))
	    Perl_warner(aTHX_ WARN_EXEC,"Can't spawn \"%s\": %s",
		    path,Strerror (errno));
    } else {
	do {
	    result = wait4pid(childpid, &status, 0);
	} while (result == -1 && errno == EINTR);
	if(result < 0)
	    status = -1;
    }
    (void)rsignal_restore(SIGINT, &ihand);
    (void)rsignal_restore(SIGQUIT, &qhand);
    return status;
}

int
do_aspawn (SV *really, void **mark, void **sp)
{
    dTHXo;
    int  rc;
    char **a,*tmps,**argv; 
    STRLEN n_a; 

    if (sp<=mark)
        return -1;
    a=argv=(char**) alloca ((sp-mark+3)*sizeof (char*));

    while (++mark <= sp)
        if (*mark)
            *a++ = SvPVx(*mark, n_a);
        else
            *a++ = "";
    *a = Nullch;

    if (argv[0][0] != '/' && argv[0][0] != '\\'
        && !(argv[0][0] && argv[0][1] == ':'
        && (argv[0][2] == '/' || argv[0][2] != '\\'))
     ) /* will swawnvp use PATH? */
         TAINT_ENV();	/* testing IFS here is overkill, probably */

    if (really && *(tmps = SvPV(really, n_a)))
        rc=do_spawnvp (tmps,(const char * const *)argv);
    else
        rc=do_spawnvp (argv[0],(const char *const *)argv);

    return rc;
}

int
do_spawn (char *cmd)
{
    dTHXo;
    char **a,*s,*metachars = "$&*(){}[]'\";\\?>|<~`\n";
    const char *command[4];

    while (*cmd && isSPACE(*cmd))
	cmd++;

    if (strnEQ (cmd,"/bin/sh",7) && isSPACE (cmd[7]))
        cmd+=5;

    /* save an extra exec if possible */
    /* see if there are shell metacharacters in it */
    if (strstr (cmd,"..."))
	goto doshell;
    if (*cmd=='.' && isSPACE (cmd[1]))
	goto doshell;
    if (strnEQ (cmd,"exec",4) && isSPACE (cmd[4]))
	goto doshell;
    for (s=cmd; *s && isALPHA (*s); s++) ;	/* catch VAR=val gizmo */
	if (*s=='=')
	    goto doshell;

    for (s=cmd; *s; s++)
	if (strchr (metachars,*s))
	{
	    if (*s=='\n' && s[1]=='\0')
	    {
		*s='\0';
		break;
	    }
	doshell:
	    command[0] = "sh";
	    command[1] = "-c";
	    command[2] = cmd;
	    command[3] = NULL;

	    return do_spawnvp("sh",command);
	}

    New (1303,PL_Argv,(s-cmd)/2+2,char*);
    PL_Cmd=savepvn (cmd,s-cmd);
    a=PL_Argv;
    for (s=PL_Cmd; *s;) {
	while (*s && isSPACE (*s)) s++;
	if (*s)
	    *(a++)=s;
	while (*s && !isSPACE (*s)) s++;
	if (*s)
	    *s++='\0';
    }
    *a=Nullch;
    if (!PL_Argv[0])
        return -1;

    return do_spawnvp(PL_Argv[0],(const char * const *)PL_Argv);
}
d22 1
a22 1
    if((cwd = getcwd(NULL, -1))) {
@


1.1.1.3
log
@stock perl 5.8.0 from CPAN
@
text
@d21 1
a21 1
    dTHX;
d31 1
a31 1
	    Perl_warner(aTHX_ packWARN(WARN_EXEC),"Can't spawn \"%s\": %s",
d48 1
a48 1
    dTHX;
d81 1
a81 1
    dTHX;
a149 3
#ifndef INCOMPLETE_TAINTS
	SvTAINTED_on(ST(0));
#endif
@


1.1.1.4
log
@perl 5.8.8 import
@
text
@a11 1
#include <sys/cygwin.h>
d120 1
a120 1
    Newx (PL_Argv,(s-cmd)/2+2,char*);
d149 1
a149 1
	free(cwd);
a157 39
static
XS(XS_Cygwin_pid_to_winpid)
{
    dXSARGS;
    dXSTARG;
    pid_t pid, RETVAL;

    if (items != 1)
        Perl_croak(aTHX_ "Usage: Cygwin::pid_to_winpid(pid)");

    pid = (pid_t)SvIV(ST(0));

    if ((RETVAL = cygwin_internal(CW_CYGWIN_PID_TO_WINPID, pid)) > 0) {
	XSprePUSH; PUSHi((IV)RETVAL);
        XSRETURN(1);
    }
    XSRETURN_UNDEF;
}

static
XS(XS_Cygwin_winpid_to_pid)
{
    dXSARGS;
    dXSTARG;
    pid_t pid, RETVAL;

    if (items != 1)
        Perl_croak(aTHX_ "Usage: Cygwin::winpid_to_pid(pid)");

    pid = (pid_t)SvIV(ST(0));

    if ((RETVAL = cygwin32_winpid_to_pid(pid)) > 0) {
        XSprePUSH; PUSHi((IV)RETVAL);
        XSRETURN(1);
    }
    XSRETURN_UNDEF;
}


a164 2
    newXS("Cygwin::winpid_to_pid", XS_Cygwin_winpid_to_pid, file);
    newXS("Cygwin::pid_to_winpid", XS_Cygwin_pid_to_winpid, file);
@


1.1.1.5
log
@import perl 5.10.0 from CPAN
@
text
@a12 3
#include <mntent.h>
#include <alloca.h>
#include <dlfcn.h>
d26 2
a27 2
    rsignal_save(SIGINT, (Sighandler_t) SIG_IGN, &ihand);
    rsignal_save(SIGQUIT, (Sighandler_t) SIG_IGN, &qhand);
d60 1
a60 1
            *a++ = SvPVx((SV *)*mark, n_a);
d140 1
d146 1
a146 4
    /* See http://rt.perl.org/rt3/Ticket/Display.html?id=38628 
       There is Cwd->cwd() usage in the wild, and previous versions didn't die.
     */
    if(items > 1)
d159 1
d178 1
a196 152
XS(XS_Cygwin_win_to_posix_path)
{
    dXSARGS;
    int absolute_flag = 0;
    STRLEN len;
    int err;
    char *pathname, *buf;

    if (items < 1 || items > 2)
        Perl_croak(aTHX_ "Usage: Cygwin::win_to_posix_path(pathname, [absolute])");

    pathname = SvPV(ST(0), len);
    if (items == 2)
	absolute_flag = SvTRUE(ST(1));

    if (!len)
	Perl_croak(aTHX_ "can't convert empty path");
    buf = (char *) safemalloc (len + 260 + 1001);

    if (absolute_flag)
	err = cygwin_conv_to_full_posix_path(pathname, buf);
    else
	err = cygwin_conv_to_posix_path(pathname, buf);
    if (!err) {
	ST(0) = sv_2mortal(newSVpv(buf, 0));
	safefree(buf);
       XSRETURN(1);
    } else {
	safefree(buf);
	XSRETURN_UNDEF;
    }
}

XS(XS_Cygwin_posix_to_win_path)
{
    dXSARGS;
    int absolute_flag = 0;
    STRLEN len;
    int err;
    char *pathname, *buf;

    if (items < 1 || items > 2)
        Perl_croak(aTHX_ "Usage: Cygwin::posix_to_win_path(pathname, [absolute])");

    pathname = SvPV(ST(0), len);
    if (items == 2)
	absolute_flag = SvTRUE(ST(1));

    if (!len)
	Perl_croak(aTHX_ "can't convert empty path");
    buf = (char *) safemalloc(len + 260 + 1001);

    if (absolute_flag)
	err = cygwin_conv_to_full_win32_path(pathname, buf);
    else
	err = cygwin_conv_to_win32_path(pathname, buf);
    if (!err) {
	ST(0) = sv_2mortal(newSVpv(buf, 0));
	safefree(buf);
       XSRETURN(1);
    } else {
	safefree(buf);
	XSRETURN_UNDEF;
    }
}

XS(XS_Cygwin_mount_table)
{
    dXSARGS;
    struct mntent *mnt;

    if (items != 0)
        Perl_croak(aTHX_ "Usage: Cygwin::mount_table");
    /* => array of [mnt_dir mnt_fsname mnt_type mnt_opts] */

    setmntent (0, 0);
    while ((mnt = getmntent (0))) {
	AV* av = newAV();
	av_push(av, newSVpvn(mnt->mnt_dir, strlen(mnt->mnt_dir)));
	av_push(av, newSVpvn(mnt->mnt_fsname, strlen(mnt->mnt_fsname)));
	av_push(av, newSVpvn(mnt->mnt_type, strlen(mnt->mnt_type)));
	av_push(av, newSVpvn(mnt->mnt_opts, strlen(mnt->mnt_opts)));
	XPUSHs(sv_2mortal(newRV_noinc((SV*)av)));
    }
    endmntent (0);
    PUTBACK;
}

XS(XS_Cygwin_mount_flags)
{
    dXSARGS;
    char *pathname;
    char flags[260];

    if (items != 1)
        Perl_croak(aTHX_ "Usage: Cygwin::mount_flags(mnt_dir|'/cygwin')");

    pathname = SvPV_nolen(ST(0));

    /* TODO: Check for cygdrive registry setting,
     *       and then use CW_GET_CYGDRIVE_INFO
     */
    if (!strcmp(pathname, "/cygdrive")) {
	char user[260];
	char system[260];
	char user_flags[260];
	char system_flags[260];

	cygwin_internal (CW_GET_CYGDRIVE_INFO, user, system, user_flags,
			 system_flags);

        if (strlen(user) > 0) {
            sprintf(flags, "%s,cygdrive,%s", user_flags, user);
        } else {
            sprintf(flags, "%s,cygdrive,%s", system_flags, system);
        }

	ST(0) = sv_2mortal(newSVpv(flags, 0));
	XSRETURN(1);

    } else {
	struct mntent *mnt;
	setmntent (0, 0);
	while ((mnt = getmntent (0))) {
	    if (!strcmp(pathname, mnt->mnt_dir)) {
		strcpy(flags, mnt->mnt_type);
		if (strlen(mnt->mnt_opts) > 0) {
		    strcat(flags, ",");
		    strcat(flags, mnt->mnt_opts);
		}
		break;
	    }
	}
	endmntent (0);
	ST(0) = sv_2mortal(newSVpv(flags, 0));
	XSRETURN(1);
    }
}

XS(XS_Cygwin_is_binmount)
{
    dXSARGS;
    char *pathname;

    if (items != 1)
        Perl_croak(aTHX_ "Usage: Cygwin::is_binmount(pathname)");

    pathname = SvPV_nolen(ST(0));

    ST(0) = boolSV(cygwin_internal(CW_GET_BINMODE, pathname));
    XSRETURN(1);
}
d201 1
a202 2
    char *file = __FILE__;
    void *handle;
d205 2
a206 17
    newXSproto("Cygwin::winpid_to_pid", XS_Cygwin_winpid_to_pid, file, "$");
    newXSproto("Cygwin::pid_to_winpid", XS_Cygwin_pid_to_winpid, file, "$");
    newXSproto("Cygwin::win_to_posix_path", XS_Cygwin_win_to_posix_path, file, "$;$");
    newXSproto("Cygwin::posix_to_win_path", XS_Cygwin_posix_to_win_path, file, "$;$");
    newXSproto("Cygwin::mount_table", XS_Cygwin_mount_table, file, "");
    newXSproto("Cygwin::mount_flags", XS_Cygwin_mount_flags, file, "$");
    newXSproto("Cygwin::is_binmount", XS_Cygwin_is_binmount, file, "$");

    /* Initialize Win32CORE if it has been statically linked. */
    handle = dlopen(NULL, RTLD_LAZY);
    if (handle) {
        void (*pfn_init)(pTHX);
        pfn_init = (void (*)(pTHX))dlsym(handle, "init_Win32CORE");
        if (pfn_init)
            pfn_init(aTHX);
        dlclose(handle);
    }
@


1.1.1.6
log
@import perl 5.10.1
@
text
@d66 1
a66 1
    *a = (char*)NULL;
d86 1
a86 2
    char const **a;
    char *s,*metachars = "$&*(){}[]'\";\\?>|<~`\n";
d124 1
a124 1
    Newx (PL_Argv,(s-cmd)/2+2,const char*);
d135 1
a135 1
    *a = (char*)NULL;
@


1.1.1.7
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@a12 1
#include <cygwin/version.h>
a15 3
#if (CYGWIN_VERSION_API_MINOR >= 181)
#include <wchar.h>
#endif
d54 2
a55 3
    char const **a;
    char *tmps,**argv;
    STRLEN n_a;
d59 1
a59 2
    argv=(char**) alloca ((sp-mark+3)*sizeof (char*));
    a=(char const **)argv;
d87 1
a87 2
    char *s;
    char const *metachars = "$&*(){}[]'\";\\?>|<~`\n";
d125 1
a125 1
    Newx (PL_Argv,(s-cmd)/2+2,char*);
a142 38
#if (CYGWIN_VERSION_API_MINOR >= 181)
char*
wide_to_utf8(const wchar_t *wbuf)
{
    char *buf;
    int wlen = 0;
    char *oldlocale = setlocale(LC_CTYPE, NULL);
    setlocale(LC_CTYPE, "utf-8");

    /* uvuni_to_utf8(buf, chr) or Encoding::_bytes_to_utf8(sv, "UCS-2BE"); */
    wlen = wcsrtombs(NULL, (const wchar_t **)&wbuf, wlen, NULL);
    buf = (char *) safemalloc(wlen+1);
    wcsrtombs(buf, (const wchar_t **)&wbuf, wlen, NULL);

    if (oldlocale) setlocale(LC_CTYPE, oldlocale);
    else setlocale(LC_CTYPE, "C");
    return buf;
}

wchar_t*
utf8_to_wide(const char *buf)
{
    wchar_t *wbuf;
    mbstate_t mbs;
    char *oldlocale = setlocale(LC_CTYPE, NULL);
    int wlen = sizeof(wchar_t)*strlen(buf);

    setlocale(LC_CTYPE, "utf-8");
    wbuf = (wchar_t *) safemalloc(wlen);
    /* utf8_to_uvuni_buf(pathname, pathname + wlen, wpath) or Encoding::_utf8_to_bytes(sv, "UCS-2BE"); */
    wlen = mbsrtowcs(wbuf, (const char**)&buf, wlen, &mbs);

    if (oldlocale) setlocale(LC_CTYPE, oldlocale);
    else setlocale(LC_CTYPE, "C");
    return wbuf;
}
#endif /* cygwin 1.7 */

d194 1
a194 6
#if (CYGWIN_VERSION_API_MINOR >= 181)
    RETVAL = cygwin_winpid_to_pid(pid);
#else
    RETVAL = cygwin32_winpid_to_pid(pid);
#endif
    if (RETVAL > 0) {
a201 1

d207 1
a207 3
    char *src_path;
    char *posix_path;
    int isutf8 = 0;
d212 1
a212 1
    src_path = SvPV(ST(0), len);
d218 1
a218 1
    isutf8 = SvUTF8(ST(0));
a219 48
#if (CYGWIN_VERSION_API_MINOR >= 181)
    /* Check utf8 flag and use wide api then.
       Size calculation: On overflow let cygwin_conv_path calculate the final size.
     */
    if (isutf8) {
	int what = absolute_flag ? CCP_WIN_W_TO_POSIX : CCP_WIN_W_TO_POSIX | CCP_RELATIVE;
	int wlen = sizeof(wchar_t)*(len + 260 + 1001);
	wchar_t *wpath = (wchar_t *) safemalloc(sizeof(wchar_t)*len);
	wchar_t *wbuf = (wchar_t *) safemalloc(wlen);
	if (!IN_BYTES) {
	    mbstate_t mbs;
            char *oldlocale = setlocale(LC_CTYPE, NULL);
            setlocale(LC_CTYPE, "utf-8");
	    /* utf8_to_uvuni_buf(src_path, src_path + wlen, wpath) or Encoding::_utf8_to_bytes(sv, "UCS-2BE"); */
	    wlen = mbsrtowcs(wpath, (const char**)&src_path, wlen, &mbs);
	    if (wlen > 0)
		err = cygwin_conv_path(what, wpath, wbuf, wlen);
            if (oldlocale) setlocale(LC_CTYPE, oldlocale);
            else setlocale(LC_CTYPE, "C");
	} else { /* use bytes; assume already ucs-2 encoded bytestream */
	    err = cygwin_conv_path(what, src_path, wbuf, wlen);
	}
	if (err == ENOSPC) { /* our space assumption was wrong, not enough space */
	    int newlen = cygwin_conv_path(what, wpath, wbuf, 0);
	    wbuf = (wchar_t *) realloc(&wbuf, newlen);
	    err = cygwin_conv_path(what, wpath, wbuf, newlen);
	    wlen = newlen;
	}
	/* utf16_to_utf8(*p, *d, bytlen, *newlen) */
	posix_path = (char *) safemalloc(wlen*3);
	Perl_utf16_to_utf8(aTHX_ (U8*)&wpath, (U8*)posix_path, (I32)wlen*2, (I32*)&len);
	/*
	wlen = wcsrtombs(NULL, (const wchar_t **)&wbuf, wlen, NULL);
	posix_path = (char *) safemalloc(wlen+1);
	wcsrtombs(posix_path, (const wchar_t **)&wbuf, wlen, NULL);
	*/
    } else {
	int what = absolute_flag ? CCP_WIN_A_TO_POSIX : CCP_WIN_A_TO_POSIX | CCP_RELATIVE;
	posix_path = (char *) safemalloc (len + 260 + 1001);
	err = cygwin_conv_path(what, src_path, posix_path, len + 260 + 1001);
	if (err == ENOSPC) { /* our space assumption was wrong, not enough space */
	    int newlen = cygwin_conv_path(what, src_path, posix_path, 0);
	    posix_path = (char *) realloc(&posix_path, newlen);
	    err = cygwin_conv_path(what, src_path, posix_path, newlen);
	}
    }
#else
    posix_path = (char *) safemalloc (len + 260 + 1001);
d221 1
a221 1
	err = cygwin_conv_to_full_posix_path(src_path, posix_path);
d223 1
a223 2
	err = cygwin_conv_to_posix_path(src_path, posix_path);
#endif
d225 3
a227 8
	EXTEND(SP, 1);
	ST(0) = sv_2mortal(newSVpv(posix_path, 0));
	if (isutf8) { /* src was utf-8, so result should also */
	    /* TODO: convert ANSI (local windows encoding) to utf-8 on cygwin-1.5 */
	    SvUTF8_on(ST(0));
	}
	safefree(posix_path);
        XSRETURN(1);
d229 1
a229 1
	safefree(posix_path);
d240 1
a240 2
    char *src_path, *win_path;
    int isutf8 = 0;
d245 1
a245 1
    src_path = SvPVx(ST(0), len);
d251 2
a252 47
    isutf8 = SvUTF8(ST(0));
#if (CYGWIN_VERSION_API_MINOR >= 181)
    /* Check utf8 flag and use wide api then.
       Size calculation: On overflow let cygwin_conv_path calculate the final size.
     */
    if (isutf8) {
	int what = absolute_flag ? CCP_POSIX_TO_WIN_W : CCP_POSIX_TO_WIN_W | CCP_RELATIVE;
	int wlen = sizeof(wchar_t)*(len + 260 + 1001);
	wchar_t *wpath = (wchar_t *) safemalloc(sizeof(wchar_t)*len);
	wchar_t *wbuf = (wchar_t *) safemalloc(wlen);
	char *oldlocale = setlocale(LC_CTYPE, NULL);
	setlocale(LC_CTYPE, "utf-8");
	if (!IN_BYTES) {
	    mbstate_t mbs;
	    /* utf8_to_uvuni_buf(src_path, src_path + wlen, wpath) or Encoding::_utf8_to_bytes(sv, "UCS-2BE"); */
	    wlen = mbsrtowcs(wpath, (const char**)&src_path, wlen, &mbs);
	    if (wlen > 0)
		err = cygwin_conv_path(what, wpath, wbuf, wlen);
	} else { /* use bytes; assume already ucs-2 encoded bytestream */
	    err = cygwin_conv_path(what, src_path, wbuf, wlen);
	}
	if (err == ENOSPC) { /* our space assumption was wrong, not enough space */
	    int newlen = cygwin_conv_path(what, wpath, wbuf, 0);
	    wbuf = (wchar_t *) realloc(&wbuf, newlen);
	    err = cygwin_conv_path(what, wpath, wbuf, newlen);
	    wlen = newlen;
	}
	/* also see utf8.c: Perl_utf16_to_utf8() or Encoding::_bytes_to_utf8(sv, "UCS-2BE"); */
	wlen = wcsrtombs(NULL, (const wchar_t **)&wbuf, wlen, NULL);
	win_path = (char *) safemalloc(wlen+1);
	wcsrtombs(win_path, (const wchar_t **)&wbuf, wlen, NULL);
	if (oldlocale) setlocale(LC_CTYPE, oldlocale);
	else setlocale(LC_CTYPE, "C");
    } else {
	int what = absolute_flag ? CCP_POSIX_TO_WIN_A : CCP_POSIX_TO_WIN_A | CCP_RELATIVE;
	win_path = (char *) safemalloc(len + 260 + 1001);
	err = cygwin_conv_path(what, src_path, win_path, len + 260 + 1001);
	if (err == ENOSPC) { /* our space assumption was wrong, not enough space */
	    int newlen = cygwin_conv_path(what, src_path, win_path, 0);
	    win_path = (char *) realloc(&win_path, newlen);
	    err = cygwin_conv_path(what, src_path, win_path, newlen);
	}
    }
#else
    if (isutf8)
	Perl_warn(aTHX_ "can't convert utf8 path");
    win_path = (char *) safemalloc(len + 260 + 1001);
d254 1
a254 1
	err = cygwin_conv_to_full_win32_path(src_path, win_path);
d256 1
a256 2
	err = cygwin_conv_to_win32_path(src_path, win_path);
#endif
d258 3
a260 7
	EXTEND(SP, 1);
	ST(0) = sv_2mortal(newSVpv(win_path, 0));
	if (isutf8) {
	    SvUTF8_on(ST(0));
	}
	safefree(win_path);
	XSRETURN(1);
d262 1
a262 1
	safefree(win_path);
d293 1
a293 2
    char flags[PATH_MAX];
    flags[0] = '\0';
d296 1
a296 1
        Perl_croak(aTHX_ "Usage: Cygwin::mount_flags( mnt_dir | '/cygdrive' )");
d300 3
d304 4
a307 4
	char user[PATH_MAX];
	char system[PATH_MAX];
	char user_flags[PATH_MAX];
	char system_flags[PATH_MAX];
d309 2
a310 2
	cygwin_internal (CW_GET_CYGDRIVE_INFO, user, system,
			 user_flags, system_flags);
a322 1
	int found = 0;
a330 1
		found++;
d335 2
a336 31

	/* Check if arg is the current volume moint point if not default,
	 * and then use CW_GET_CYGDRIVE_INFO also.
	 */
	if (!found) {
	    char user[PATH_MAX];
	    char system[PATH_MAX];
	    char user_flags[PATH_MAX];
	    char system_flags[PATH_MAX];

	    cygwin_internal (CW_GET_CYGDRIVE_INFO, user, system,
			     user_flags, system_flags);

	    if (strlen(user) > 0) {
		if (strcmp(user,pathname)) {
		    sprintf(flags, "%s,cygdrive,%s", user_flags, user);
		    found++;
		}
	    } else {
		if (strcmp(user,pathname)) {
		    sprintf(flags, "%s,cygdrive,%s", system_flags, system);
		    found++;
		}
	    }
	}
	if (found) {
	    ST(0) = sv_2mortal(newSVpv(flags, 0));
	    XSRETURN(1);
	} else {
	    XSRETURN_UNDEF;
	}
a353 2
XS(XS_Cygwin_sync_winenv){ cygwin_internal(CW_SYNC_WINENV); }

d358 1
a358 1
    char const *file = __FILE__;
a368 1
    newXS("Cygwin::sync_winenv", XS_Cygwin_sync_winenv, file);
@


1.1.1.8
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d132 1
a132 1
    Newx (PL_Argv, (s-cmd)/2+2, const char*);
d257 1
a257 1
    int err = 0;
d346 1
a346 1
    int err = 0;
@


1.1.1.9
log
@Import perl-5.20.1
@
text
@a4 1
#define PERLIO_NOT_STDIO 0
d159 1
a159 1
    /* uvchr_to_utf8(buf, chr) or Encoding::_bytes_to_utf8(sv, "UCS-2BE"); */
d179 1
a179 1
    /* utf8_to_uvchr_buf(pathname, pathname + wlen, wpath) or Encoding::_utf8_to_bytes(sv, "UCS-2BE"); */
d202 1
d204 1
d286 1
a286 1
	    /* utf8_to_uvchr_buf(src_path, src_path + wlen, wpath) or Encoding::_utf8_to_bytes(sv, "UCS-2BE"); */
d373 1
a373 1
	    /* utf8_to_uvchr_buf(src_path, src_path + wlen, wpath) or Encoding::_utf8_to_bytes(sv, "UCS-2BE"); */
@


