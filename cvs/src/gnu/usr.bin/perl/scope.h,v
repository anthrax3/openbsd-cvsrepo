head	1.17;
access;
symbols
	OPENBSD_6_2:1.17.0.6
	OPENBSD_6_2_BASE:1.17
	PERL_5_24_2:1.1.1.16
	OPENBSD_6_1:1.17.0.4
	OPENBSD_6_1_BASE:1.17
	OPENBSD_6_0:1.16.0.10
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.16.0.4
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.16.0.6
	OPENBSD_5_8_BASE:1.16
	PERL_5_20_2:1.1.1.15
	OPENBSD_5_7:1.16.0.2
	OPENBSD_5_7_BASE:1.16
	PERL_5_20_1:1.1.1.15
	OPENBSD_5_6:1.15.0.4
	OPENBSD_5_6_BASE:1.15
	PERL_5_18_2:1.1.1.14
	PERL:1.1.1
	OPENBSD_5_5:1.14.0.6
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.2
	OPENBSD_5_4_BASE:1.14
	PERL_5_16_3:1.1.1.13
	OPENBSD_5_3:1.13.0.10
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.8
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.6
	OPENBSD_5_0:1.13.0.4
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.2
	OPENBSD_4_9_BASE:1.13
	PERL_5_12_2:1.1.1.12
	OPENBSD_4_8:1.12.0.4
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	PERL_5_10_1:1.1.1.11
	OPENBSD_4_6:1.11.0.6
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.2
	OPENBSD_4_5_BASE:1.11
	PERL_5_10_0:1.1.1.10
	OPENBSD_4_4:1.10.0.10
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.8
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.6
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.4
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.2
	OPENBSD_4_0_BASE:1.10
	PERL_5_8_8:1.1.1.9
	OPENBSD_3_9:1.9.0.6
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.4
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.2
	OPENBSD_3_7_BASE:1.9
	PERL_5_8_6:1.1.1.8
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	PERL_5_8_5:1.1.1.7
	PERL_5_8_3:1.1.1.6
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.17
date	2017.02.05.00.31.53;	author afresh1;	state Exp;
branches;
next	1.16;
commitid	cxJ08BvJA9Pt2PTM;

1.16
date	2014.11.17.20.56.48;	author afresh1;	state Exp;
branches;
next	1.15;
commitid	QP75iYx42Uo7mMxO;

1.15
date	2014.03.24.15.05.13;	author afresh1;	state Exp;
branches;
next	1.14;

1.14
date	2013.03.25.20.40.45;	author sthen;	state Exp;
branches;
next	1.13;

1.13
date	2010.09.24.15.06.43;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2009.10.12.18.24.22;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2008.09.29.17.35.59;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2006.03.28.19.22.59;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2005.01.15.21.30.22;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2004.08.09.18.08.56;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.22;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.19;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.34.58;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.04.25;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.51.11;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.49.19;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.11.49;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.11.49;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.37.56;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.08.47;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.22.22;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.14.51;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.43.37;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.08.09.17.45.48;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2005.01.15.21.16.36;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2006.03.28.18.47.43;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2008.09.29.17.18.10;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2009.10.12.18.10.33;	author millert;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2010.09.24.14.48.32;	author millert;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2013.03.25.20.06.40;	author sthen;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2014.03.24.14.58.47;	author afresh1;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	2014.11.17.20.52.39;	author afresh1;	state Exp;
branches;
next	1.1.1.16;
commitid	B31cAbBIXiCqnL97;

1.1.1.16
date	2017.08.14.13.45.30;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.17
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@/*    scope.h
 *
 *    Copyright (C) 1993, 1994, 1996, 1997, 1998, 1999, 2000, 2001,
 *    2002, 2004, 2005, 2006, 2007, 2008 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

/* *** these are ordered by number of of auto-popped args */

/* zero args */

#define SAVEt_ALLOC		0
#define SAVEt_CLEARPADRANGE	1
#define SAVEt_CLEARSV		2
#define SAVEt_REGCONTEXT	3

#define SAVEt_ARG0_MAX		3

/* one arg */

#define SAVEt_TMPSFLOOR		4
#define SAVEt_BOOL		5
#define SAVEt_COMPILE_WARNINGS	6
#define SAVEt_COMPPAD		7
#define SAVEt_FREECOPHH		8
#define SAVEt_FREEOP		9
#define SAVEt_FREEPV		10
#define SAVEt_FREESV		11
#define SAVEt_I16		12
#define SAVEt_I32_SMALL		13
#define SAVEt_I8		14
#define SAVEt_INT_SMALL		15
#define SAVEt_MORTALIZESV	16
#define SAVEt_NSTAB		17
#define SAVEt_OP		18
#define SAVEt_PARSER		19
#define SAVEt_STACK_POS		20
#define SAVEt_READONLY_OFF	21
#define SAVEt_FREEPADNAME	22

#define SAVEt_ARG1_MAX		22

/* two args */

#define SAVEt_AV		23
#define SAVEt_DESTRUCTOR	24
#define SAVEt_DESTRUCTOR_X	25
#define SAVEt_GENERIC_PVREF	26
#define SAVEt_GENERIC_SVREF	27
#define SAVEt_GP		28
#define SAVEt_GVSV		29
#define SAVEt_HINTS		30
#define SAVEt_HPTR		31
#define SAVEt_HV		32
#define SAVEt_I32		33
#define SAVEt_INT		34
#define SAVEt_ITEM		35
#define SAVEt_IV		36
#define SAVEt_LONG		37
#define SAVEt_PPTR		38
#define SAVEt_SAVESWITCHSTACK	39
#define SAVEt_SHARED_PVREF	40
#define SAVEt_SPTR		41
#define SAVEt_STRLEN		42
#define SAVEt_SV		43
#define SAVEt_SVREF		44
#define SAVEt_VPTR		45
#define SAVEt_ADELETE		46
#define SAVEt_APTR		47

#define SAVEt_ARG2_MAX		47

/* three args */

#define SAVEt_HELEM		48
#define SAVEt_PADSV_AND_MORTALIZE 49
#define SAVEt_SET_SVFLAGS	50
#define SAVEt_GVSLOT		51
#define SAVEt_AELEM		52
#define SAVEt_DELETE		53


#define SAVEf_SETMAGIC		1
#define SAVEf_KEEPOLDELEM	2

#define SAVE_TIGHT_SHIFT	6
#define SAVE_MASK		0x3F

#define save_aelem(av,idx,sptr)	save_aelem_flags(av,idx,sptr,SAVEf_SETMAGIC)
#define save_helem(hv,key,sptr)	save_helem_flags(hv,key,sptr,SAVEf_SETMAGIC)

#ifndef SCOPE_SAVES_SIGNAL_MASK
#define SCOPE_SAVES_SIGNAL_MASK 0
#endif

/* the maximum number of entries that might be pushed using the SS_ADD*
 * macros */
#define SS_MAXPUSH 4

#define SSCHECK(need) if (UNLIKELY(PL_savestack_ix + (I32)(need) > PL_savestack_max)) savestack_grow()
#define SSGROW(need) if (UNLIKELY(PL_savestack_ix + (I32)(need) > PL_savestack_max)) savestack_grow_cnt(need)
#define SSPUSHINT(i) (PL_savestack[PL_savestack_ix++].any_i32 = (I32)(i))
#define SSPUSHLONG(i) (PL_savestack[PL_savestack_ix++].any_long = (long)(i))
#define SSPUSHBOOL(p) (PL_savestack[PL_savestack_ix++].any_bool = (p))
#define SSPUSHIV(i) (PL_savestack[PL_savestack_ix++].any_iv = (IV)(i))
#define SSPUSHUV(u) (PL_savestack[PL_savestack_ix++].any_uv = (UV)(u))
#define SSPUSHPTR(p) (PL_savestack[PL_savestack_ix++].any_ptr = (void*)(p))
#define SSPUSHDPTR(p) (PL_savestack[PL_savestack_ix++].any_dptr = (p))
#define SSPUSHDXPTR(p) (PL_savestack[PL_savestack_ix++].any_dxptr = (p))

/* SS_ADD*: newer, faster versions of the above. Don't mix the two sets of
 * macros. These are fast because they save reduce accesses to the PL_
 * vars and move the size check to the end. Doing the check last means
 * that values in registers will have been pushed and no longer needed, so
 * don't need saving around the call to grow. Also, tail-call elimination
 * of the grow() can be done. These changes reduce the code of something
 * like save_pushptrptr() to half its former size.
 * Of course, doing the size check *after* pushing means we must always
 * ensure there are SS_MAXPUSH free slots on the savestack. This ensured
 * bt savestack_grow() and savestack_grow_cnt always allocating SS_MAXPUSH
 * slots more than asked for, or that it sets PL_savestack_max to
 *
 * These are for internal core use only and are subject to change */

#define dSS_ADD \
    I32 ix = PL_savestack_ix;     \
    ANY *ssp = &PL_savestack[ix]

#define SS_ADD_END(need) \
    assert((need) <= SS_MAXPUSH);                               \
    ix += (need);                                               \
    PL_savestack_ix = ix;                                       \
    assert(ix <= PL_savestack_max + SS_MAXPUSH);                \
    if (UNLIKELY(ix > PL_savestack_max)) savestack_grow();      \
    assert(PL_savestack_ix <= PL_savestack_max);

#define SS_ADD_INT(i)   ((ssp++)->any_i32 = (I32)(i))
#define SS_ADD_LONG(i)  ((ssp++)->any_long = (long)(i))
#define SS_ADD_BOOL(p)  ((ssp++)->any_bool = (p))
#define SS_ADD_IV(i)    ((ssp++)->any_iv = (IV)(i))
#define SS_ADD_UV(u)    ((ssp++)->any_uv = (UV)(u))
#define SS_ADD_PTR(p)   ((ssp++)->any_ptr = (void*)(p))
#define SS_ADD_DPTR(p)  ((ssp++)->any_dptr = (p))
#define SS_ADD_DXPTR(p) ((ssp++)->any_dxptr = (p))

#define SSPOPINT (PL_savestack[--PL_savestack_ix].any_i32)
#define SSPOPLONG (PL_savestack[--PL_savestack_ix].any_long)
#define SSPOPBOOL (PL_savestack[--PL_savestack_ix].any_bool)
#define SSPOPIV (PL_savestack[--PL_savestack_ix].any_iv)
#define SSPOPUV (PL_savestack[--PL_savestack_ix].any_uv)
#define SSPOPPTR (PL_savestack[--PL_savestack_ix].any_ptr)
#define SSPOPDPTR (PL_savestack[--PL_savestack_ix].any_dptr)
#define SSPOPDXPTR (PL_savestack[--PL_savestack_ix].any_dxptr)


/*
=head1 Callback Functions

=for apidoc Ams||SAVETMPS
Opening bracket for temporaries on a callback.  See C<L</FREETMPS>> and
L<perlcall>.

=for apidoc Ams||FREETMPS
Closing bracket for temporaries on a callback.  See C<L</SAVETMPS>> and
L<perlcall>.

=for apidoc Ams||ENTER
Opening bracket on a callback.  See C<L</LEAVE>> and L<perlcall>.

=for apidoc Ams||LEAVE
Closing bracket on a callback.  See C<L</ENTER>> and L<perlcall>.

=over

=item ENTER_with_name(name)

Same as C<ENTER>, but when debugging is enabled it also associates the
given literal string with the new scope.

=item LEAVE_with_name(name)

Same as C<LEAVE>, but when debugging is enabled it first checks that the
scope has the given name. C<name> must be a C<NUL>-terminated literal string.

=back

=cut
*/

#define SAVETMPS Perl_savetmps(aTHX)

#define FREETMPS if (PL_tmps_ix > PL_tmps_floor) free_tmps()

#ifdef DEBUGGING
#define ENTER							\
    STMT_START {						\
	push_scope();						\
	DEBUG_SCOPE("ENTER")					\
    } STMT_END
#define LEAVE							\
    STMT_START {						\
	DEBUG_SCOPE("LEAVE")					\
	pop_scope();						\
    } STMT_END
#define ENTER_with_name(name)						\
    STMT_START {							\
	push_scope();							\
	if (PL_scopestack_name)						\
	    PL_scopestack_name[PL_scopestack_ix-1] = name;		\
	DEBUG_SCOPE("ENTER \"" name "\"")				\
    } STMT_END
#define LEAVE_with_name(name)						\
    STMT_START {							\
	DEBUG_SCOPE("LEAVE \"" name "\"")				\
	if (PL_scopestack_name)	{					\
	    assert(((char*)PL_scopestack_name[PL_scopestack_ix-1]	\
			== (char*)name)					\
		    || strEQ(PL_scopestack_name[PL_scopestack_ix-1], name));        \
	}								\
	pop_scope();							\
    } STMT_END
#else
#define ENTER push_scope()
#define LEAVE pop_scope()
#define ENTER_with_name(name) ENTER
#define LEAVE_with_name(name) LEAVE
#endif
#define LEAVE_SCOPE(old) STMT_START { \
	if (PL_savestack_ix > old) leave_scope(old); \
    } STMT_END

#define SAVEI8(i)	save_I8((I8*)&(i))
#define SAVEI16(i)	save_I16((I16*)&(i))
#define SAVEI32(i)	save_I32((I32*)&(i))
#define SAVEINT(i)	save_int((int*)&(i))
#define SAVEIV(i)	save_iv((IV*)&(i))
#define SAVELONG(l)	save_long((long*)&(l))
#define SAVEBOOL(b)	save_bool(&(b))
#define SAVESPTR(s)	save_sptr((SV**)&(s))
#define SAVEPPTR(s)	save_pptr((char**)&(s))
#define SAVEVPTR(s)	save_vptr((void*)&(s))
#define SAVEPADSVANDMORTALIZE(s)	save_padsv_and_mortalize(s)
#define SAVEFREESV(s)	save_freesv(MUTABLE_SV(s))
#define SAVEFREEPADNAME(s) save_pushptr((void *)(s), SAVEt_FREEPADNAME)
#define SAVEMORTALIZESV(s)	save_mortalizesv(MUTABLE_SV(s))
#define SAVEFREEOP(o)	save_freeop((OP*)(o))
#define SAVEFREEPV(p)	save_freepv((char*)(p))
#define SAVECLEARSV(sv)	save_clearsv((SV**)&(sv))
#define SAVEGENERICSV(s)	save_generic_svref((SV**)&(s))
#define SAVEGENERICPV(s)	save_generic_pvref((char**)&(s))
#define SAVESHAREDPV(s)		save_shared_pvref((char**)&(s))
#define SAVESETSVFLAGS(sv,mask,val)	save_set_svflags(sv,mask,val)
#define SAVEFREECOPHH(h)	save_pushptr((void *)(h), SAVEt_FREECOPHH)
#define SAVEDELETE(h,k,l) \
	  save_delete(MUTABLE_HV(h), (char*)(k), (I32)(l))
#define SAVEHDELETE(h,s) \
	  save_hdelete(MUTABLE_HV(h), (s))
#define SAVEADELETE(a,k) \
	  save_adelete(MUTABLE_AV(a), (SSize_t)(k))
#define SAVEDESTRUCTOR(f,p) \
	  save_destructor((DESTRUCTORFUNC_NOCONTEXT_t)(f), (void*)(p))

#define SAVEDESTRUCTOR_X(f,p) \
	  save_destructor_x((DESTRUCTORFUNC_t)(f), (void*)(p))

#define SAVESTACK_POS() \
    STMT_START {				   \
        dSS_ADD;                                   \
        SS_ADD_INT(PL_stack_sp - PL_stack_base);   \
        SS_ADD_UV(SAVEt_STACK_POS);                \
        SS_ADD_END(2);                             \
    } STMT_END

#define SAVEOP()	save_op()

#define SAVEHINTS()	save_hints()

#define SAVECOMPPAD() save_pushptr(MUTABLE_SV(PL_comppad), SAVEt_COMPPAD)

#define SAVESWITCHSTACK(f,t) \
    STMT_START {					\
	save_pushptrptr(MUTABLE_SV(f), MUTABLE_SV(t), SAVEt_SAVESWITCHSTACK); \
	SWITCHSTACK((f),(t));				\
	PL_curstackinfo->si_stack = (t);		\
    } STMT_END

/* Need to do the cop warnings like this, rather than a "SAVEFREESHAREDPV",
   because realloc() means that the value can actually change. Possibly
   could have done savefreesharedpvREF, but this way actually seems cleaner,
   as it simplifies the code that does the saves, and reduces the load on the
   save stack.  */
#define SAVECOMPILEWARNINGS() save_pushptr(PL_compiling.cop_warnings, SAVEt_COMPILE_WARNINGS)

#define SAVEPARSER(p) save_pushptr((p), SAVEt_PARSER)

#ifdef USE_ITHREADS
#  define SAVECOPSTASH_FREE(c)	SAVEIV((c)->cop_stashoff)
#  define SAVECOPFILE(c)	SAVEPPTR(CopFILE(c))
#  define SAVECOPFILE_FREE(c)	SAVESHAREDPV(CopFILE(c))
#else
#  /* XXX not refcounted */
#  define SAVECOPSTASH_FREE(c)	SAVESPTR(CopSTASH(c))
#  define SAVECOPFILE(c)	SAVESPTR(CopFILEGV(c))
#  define SAVECOPFILE_FREE(c)	SAVEGENERICSV(CopFILEGV(c))
#endif

#define SAVECOPLINE(c)		SAVEI32(CopLINE(c))

/* SSNEW() temporarily allocates a specified number of bytes of data on the
 * savestack.  It returns an I32 index into the savestack, because a
 * pointer would get broken if the savestack is moved on reallocation.
 * SSNEWa() works like SSNEW(), but also aligns the data to the specified
 * number of bytes.  MEM_ALIGNBYTES is perhaps the most useful.  The
 * alignment will be preserved through savestack reallocation *only* if
 * realloc returns data aligned to a size divisible by "align"!
 *
 * SSPTR() converts the index returned by SSNEW/SSNEWa() into a pointer.
 */

#define SSNEW(size)             Perl_save_alloc(aTHX_ (size), 0)
#define SSNEWt(n,t)             SSNEW((n)*sizeof(t))
#define SSNEWa(size,align)	Perl_save_alloc(aTHX_ (size), \
    (I32)(align - ((size_t)((caddr_t)&PL_savestack[PL_savestack_ix]) % align)) % align)
#define SSNEWat(n,t,align)	SSNEWa((n)*sizeof(t), align)

#define SSPTR(off,type)         ((type)  ((char*)PL_savestack + off))
#define SSPTRt(off,type)        ((type*) ((char*)PL_savestack + off))

#define save_freesv(op)		save_pushptr((void *)(op), SAVEt_FREESV)
#define save_mortalizesv(op)	save_pushptr((void *)(op), SAVEt_MORTALIZESV)

# define save_freeop(op)                    \
STMT_START {                                 \
      OP * const _o = (OP *)(op);             \
      assert(!_o->op_savefree);               \
      _o->op_savefree = 1;                     \
      save_pushptr((void *)(_o), SAVEt_FREEOP); \
    } STMT_END
#define save_freepv(pv)		save_pushptr((void *)(pv), SAVEt_FREEPV)
#define save_op()		save_pushptr((void *)(PL_op), SAVEt_OP)

/*
 * ex: set ts=8 sts=4 sw=4 et:
 */
@


1.16
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@a18 1
/*** SPARE      	        4 ***/
d20 1
a20 1
#define SAVEt_ARG0_MAX		4
d24 1
d42 1
d44 1
a44 1
#define SAVEt_ARG1_MAX		21
a47 1
#define SAVEt_APTR		22
d72 1
d74 1
a74 1
#define SAVEt_ARG2_MAX		46
a77 1
#define SAVEt_DELETE		47
d83 2
d103 2
a104 2
#define SSCHECK(need) if (UNLIKELY(PL_savestack_ix + (I32)(need) + SS_MAXPUSH > PL_savestack_max)) savestack_grow()
#define SSGROW(need) if (UNLIKELY(PL_savestack_ix + (I32)(need) + SS_MAXPUSH > PL_savestack_max)) savestack_grow_cnt(need + SS_MAXPUSH)
d122 3
a124 1
 * ensure there are SS_MAXPUSH free slots on the savestack
d136 3
a138 3
    assert(ix <= PL_savestack_max);                             \
    if (UNLIKELY((ix + SS_MAXPUSH) > PL_savestack_max)) savestack_grow(); \
    assert(PL_savestack_ix + SS_MAXPUSH <= PL_savestack_max);
d163 1
a163 1
Opening bracket for temporaries on a callback.  See C<FREETMPS> and
d167 1
a167 1
Closing bracket for temporaries on a callback.  See C<SAVETMPS> and
d171 1
a171 1
Opening bracket on a callback.  See C<LEAVE> and L<perlcall>.
d174 1
a174 1
Closing bracket on a callback.  See C<ENTER> and L<perlcall>.
d186 1
a186 1
scope has the given name. Name must be a literal string.
d193 2
a194 2
#define SAVETMPS Perl_save_strlen(aTHX_ (STRLEN *)&PL_tmps_floor), \
		 PL_tmps_floor = PL_tmps_ix
d247 1
d313 1
a313 1
 * savestack.  It returns an integer index into the savestack, because a
a345 6
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
@


1.15
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d19 1
a19 1
#define SAVEt_RE_STATE		4
d41 1
d43 1
a43 1
#define SAVEt_ARG1_MAX		20
a46 1
#define SAVEt_ADELETE		21
d67 1
a67 1
#define SAVEt_STACK_CXPOS	42
d71 1
d73 1
a73 1
#define SAVEt_ARG2_MAX		45
a76 1
#define SAVEt_AELEM		46
d82 1
d101 2
a102 2
#define SSCHECK(need) if (PL_savestack_ix + (I32)(need) + SS_MAXPUSH > PL_savestack_max) savestack_grow()
#define SSGROW(need) if (PL_savestack_ix + (I32)(need) + SS_MAXPUSH > PL_savestack_max) savestack_grow_cnt(need + SS_MAXPUSH)
d126 1
a126 1
    ANY *ssp = &PL_savestack[ix];
d133 1
a133 1
    if ((ix + SS_MAXPUSH) > PL_savestack_max) savestack_grow(); \
d189 2
a190 1
#define SAVETMPS save_int((int*)&PL_tmps_floor), PL_tmps_floor = PL_tmps_ix
d257 1
a257 1
	  save_adelete(MUTABLE_AV(a), (I32)(k))
a290 9

#define SAVESTACK_CXPOS() \
    STMT_START {                                   \
        dSS_ADD;                                   \
        SS_ADD_INT(cxstack[cxstack_ix].blk_oldsp); \
        SS_ADD_INT(cxstack_ix);                    \
        SS_ADD_UV(SAVEt_STACK_CXPOS);              \
        SS_ADD_END(3);                             \
    } STMT_END
@


1.14
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d11 71
a81 50
#define SAVEt_ITEM		0
#define SAVEt_SV		1
#define SAVEt_AV		2
#define SAVEt_HV		3
#define SAVEt_INT		4
#define SAVEt_LONG		5
#define SAVEt_I32		6
#define SAVEt_IV		7
#define SAVEt_SPTR		8
#define SAVEt_APTR		9
#define SAVEt_HPTR		10
#define SAVEt_PPTR		11
#define SAVEt_NSTAB		12
#define SAVEt_SVREF		13
#define SAVEt_GP		14
#define SAVEt_FREESV		15
#define SAVEt_FREEOP		16
#define SAVEt_FREEPV		17
#define SAVEt_CLEARSV		18
#define SAVEt_DELETE		19
#define SAVEt_DESTRUCTOR	20
#define SAVEt_REGCONTEXT	21
#define SAVEt_STACK_POS		22
#define SAVEt_I16		23
#define SAVEt_AELEM		24
#define SAVEt_HELEM		25
#define SAVEt_OP		26
#define SAVEt_HINTS		27
#define SAVEt_ALLOC		28
#define SAVEt_GENERIC_SVREF	29
#define SAVEt_DESTRUCTOR_X	30
#define SAVEt_VPTR		31
#define SAVEt_I8		32
#define SAVEt_COMPPAD		33
#define SAVEt_GENERIC_PVREF	34
#define SAVEt_PADSV_AND_MORTALIZE	35
#define SAVEt_MORTALIZESV	36
#define SAVEt_SHARED_PVREF	37
#define SAVEt_BOOL		38
#define SAVEt_SET_SVFLAGS	39
#define SAVEt_SAVESWITCHSTACK	40
#define SAVEt_RE_STATE		42
#define SAVEt_COMPILE_WARNINGS	43
#define SAVEt_STACK_CXPOS	44
#define SAVEt_PARSER		45
#define SAVEt_ADELETE		46
#define SAVEt_I32_SMALL		47
#define SAVEt_INT_SMALL		48
#define SAVEt_GVSV		49
#define SAVEt_FREECOPHH		50
d96 6
a101 2
#define SSCHECK(need) if (PL_savestack_ix + (I32)(need) > PL_savestack_max) savestack_grow()
#define SSGROW(need) if (PL_savestack_ix + (I32)(need) > PL_savestack_max) savestack_grow_cnt(need)
d110 34
d153 1
d225 3
a227 1
#define LEAVE_SCOPE(old) if (PL_savestack_ix > old) leave_scope(old)
d263 5
a267 4
    STMT_START {				\
	SSCHECK(2);				\
	SSPUSHINT(PL_stack_sp - PL_stack_base);	\
	SSPUSHUV(SAVEt_STACK_POS);		\
d291 6
a296 5
    STMT_START {                                  \
        SSCHECK(3);                               \
        SSPUSHINT(cxstack[cxstack_ix].blk_oldsp); \
        SSPUSHINT(cxstack_ix);                    \
        SSPUSHUV(SAVEt_STACK_CXPOS);              \
d302 1
a302 4
#  define SAVECOPSTASH(c)	(SAVEPPTR(CopSTASHPV(c)), \
				 SAVEI32(CopSTASH_len(c)))
#  define SAVECOPSTASH_FREE(c)	(SAVESHAREDPV(CopSTASHPV(c)), \
	                         SAVEI32(CopSTASH_len(c)))
d306 2
a307 2
#  define SAVECOPSTASH(c)	SAVESPTR(CopSTASH(c))
#  define SAVECOPSTASH_FREE(c)	SAVECOPSTASH(c)	/* XXX not refcounted */
d336 8
a343 1
#define save_freeop(op)		save_pushptr((void *)(op), SAVEt_FREEOP)
d351 1
a351 1
 * indent-tabs-mode: t
d354 1
a354 1
 * ex: set ts=8 sts=4 sw=4 noet:
@


1.13
log
@merge in perl 5.12.2 plus local changes
@
text
@a51 1
#define SAVEt_COP_ARYBASE	41
d57 4
d65 3
d81 1
d89 1
d173 1
a173 1
#define SAVEBOOL(b)	save_bool((bool*)&(b))
d187 1
d204 1
a204 1
	SSPUSHINT(SAVEt_STACK_POS);		\
a219 2
#define SAVECOPARYBASE(c) save_pushi32ptr(CopARYBASE_get(c), c, SAVEt_COP_ARYBASE);

d232 1
a232 1
        SSPUSHINT(SAVEt_STACK_CXPOS);             \
d238 4
a241 2
#  define SAVECOPSTASH(c)	SAVEPPTR(CopSTASHPV(c))
#  define SAVECOPSTASH_FREE(c)	SAVESHAREDPV(CopSTASHPV(c))
d258 1
a258 1
 * alignment will be preserved therough savestack reallocation *only* if
@


1.12
log
@Merge in perl 5.10.1
@
text
@d46 1
a46 1
#define SAVEt_PADSV		35
d57 7
a63 1
#define SAVEt_PADSV_AND_MORTALIZE	46
d103 14
d134 17
d154 2
a168 1
#define SAVEPADSV(s)	save_padsv(s)
d181 4
a234 2
#  define SAVECOPLABEL(c)	SAVEPPTR(CopLABEL(c))
#  define SAVECOPLABEL_FREE(c)	SAVESHAREDPV(CopLABEL(c))
a239 2
#  define SAVECOPLABEL(c)	SAVEPPTR(CopLABEL(c))
#  define SAVECOPLABEL_FREE(c)	SAVEPPTR(CopLABEL(c))
@


1.11
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d3 2
a4 2
 *    Copyright (C) 1993, 1994, 1996, 1997, 1998, 1999,
 *    2000, 2001, 2002, 2004, 2005, 2006, 2007 by Larry Wall and others
d57 1
d131 3
a133 2
#define SAVEFREESV(s)	save_freesv((SV*)(s))
#define SAVEMORTALIZESV(s)	save_mortalizesv((SV*)(s))
d142 1
a142 1
	  save_delete((HV*)(h), (char*)(k), (I32)(l))
d158 1
a158 16
#define SAVEHINTS() \
    STMT_START {					\
	SSCHECK(4);					\
	if (PL_hints & HINT_LOCALIZE_HH) {		\
	    SSPUSHPTR(GvHV(PL_hintgv));			\
	    GvHV(PL_hintgv) = Perl_hv_copy_hints_hv(aTHX_ GvHV(PL_hintgv)); \
	}						\
	if (PL_compiling.cop_hints_hash) {		\
	    HINTS_REFCNT_LOCK;				\
	    PL_compiling.cop_hints_hash->refcounted_he_refcnt++;	\
	    HINTS_REFCNT_UNLOCK;			\
	}						\
	SSPUSHPTR(PL_compiling.cop_hints_hash);		\
	SSPUSHINT(PL_hints);				\
	SSPUSHINT(SAVEt_HINTS);				\
    } STMT_END
d160 1
a160 6
#define SAVECOMPPAD() \
    STMT_START {						\
	SSCHECK(2);						\
	SSPUSHPTR((SV*)PL_comppad);				\
	SSPUSHINT(SAVEt_COMPPAD);				\
    } STMT_END
d164 1
a164 4
	SSCHECK(3);					\
	SSPUSHPTR((SV*)(f));				\
	SSPUSHPTR((SV*)(t));				\
	SSPUSHINT(SAVEt_SAVESWITCHSTACK);		\
d169 1
a169 7
#define SAVECOPARYBASE(c) \
    STMT_START {					\
	SSCHECK(3);					\
	SSPUSHINT(CopARYBASE_get(c));			\
	SSPUSHPTR(c);					\
	SSPUSHINT(SAVEt_COP_ARYBASE);			\
    } STMT_END
d176 1
a176 6
#define SAVECOMPILEWARNINGS() \
    STMT_START {					\
	SSCHECK(2);					\
	SSPUSHPTR(PL_compiling.cop_warnings);		\
	SSPUSHINT(SAVEt_COMPILE_WARNINGS);		\
    } STMT_END
d186 1
a186 6
#define SAVEPARSER(p) \
    STMT_START {                                  \
        SSCHECK(2);                               \
        SSPUSHPTR(p);		                  \
        SSPUSHINT(SAVEt_PARSER); 	          \
    } STMT_END
d220 1
a220 1
    (align - ((int)((caddr_t)&PL_savestack[PL_savestack_ix]) % align)) % align)
d226 15
@


1.10
log
@merge in perl 5.8.8
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2004, 2005 by Larry Wall and others
d50 1
d52 5
d62 2
a63 2
#define SSCHECK(need) if (PL_savestack_ix + (need) > PL_savestack_max) savestack_grow()
#define SSGROW(need) if (PL_savestack_ix + (need) > PL_savestack_max) savestack_grow_cnt(need)
d119 7
a125 11
/*
 * Not using SOFT_CAST on SAVESPTR, SAVEGENERICSV and SAVEFREESV
 * because these are used for several kinds of pointer values
 */
#define SAVEI8(i)	save_I8(SOFT_CAST(I8*)&(i))
#define SAVEI16(i)	save_I16(SOFT_CAST(I16*)&(i))
#define SAVEI32(i)	save_I32(SOFT_CAST(I32*)&(i))
#define SAVEINT(i)	save_int(SOFT_CAST(int*)&(i))
#define SAVEIV(i)	save_iv(SOFT_CAST(IV*)&(i))
#define SAVELONG(l)	save_long(SOFT_CAST(long*)&(l))
#define SAVEBOOL(b)	save_bool(SOFT_CAST(bool*)&(b))
d127 1
a127 1
#define SAVEPPTR(s)	save_pptr(SOFT_CAST(char**)&(s))
d132 3
a134 3
#define SAVEFREEOP(o)	save_freeop(SOFT_CAST(OP*)(o))
#define SAVEFREEPV(p)	save_freepv(SOFT_CAST(char*)(p))
#define SAVECLEARSV(sv)	save_clearsv(SOFT_CAST(SV**)&(sv))
d138 1
d140 1
a140 1
	  save_delete(SOFT_CAST(HV*)(h), SOFT_CAST(char*)(k), (I32)(l))
d142 1
a142 1
	  save_destructor((DESTRUCTORFUNC_NOCONTEXT_t)(f), SOFT_CAST(void*)(p))
d145 1
a145 1
	  save_destructor_x((DESTRUCTORFUNC_t)(f), SOFT_CAST(void*)(p))
d158 1
a158 1
	SSCHECK(3);					\
d161 1
a161 1
	    GvHV(PL_hintgv) = newHVhv(GvHV(PL_hintgv));	\
d163 6
d190 35
d230 2
d237 2
a262 197
/* A jmpenv packages the state required to perform a proper non-local jump.
 * Note that there is a start_env initialized when perl starts, and top_env
 * points to this initially, so top_env should always be non-null.
 *
 * Existence of a non-null top_env->je_prev implies it is valid to call
 * longjmp() at that runlevel (we make sure start_env.je_prev is always
 * null to ensure this).
 *
 * je_mustcatch, when set at any runlevel to TRUE, means eval ops must
 * establish a local jmpenv to handle exception traps.  Care must be taken
 * to restore the previous value of je_mustcatch before exiting the
 * stack frame iff JMPENV_PUSH was not called in that stack frame.
 * GSAR 97-03-27
 */

struct jmpenv {
    struct jmpenv *	je_prev;
    Sigjmp_buf		je_buf;		/* only for use if !je_throw */
    int			je_ret;		/* last exception thrown */
    bool		je_mustcatch;	/* need to call longjmp()? */
#ifdef PERL_FLEXIBLE_EXCEPTIONS
    void		(*je_throw)(int v); /* last for bincompat */
    bool		je_noset;	/* no need for setjmp() */
#endif
};

typedef struct jmpenv JMPENV;

#ifdef OP_IN_REGISTER
#define OP_REG_TO_MEM	PL_opsave = op
#define OP_MEM_TO_REG	op = PL_opsave
#else
#define OP_REG_TO_MEM	NOOP
#define OP_MEM_TO_REG	NOOP
#endif

/*
 * How to build the first jmpenv.
 *
 * top_env needs to be non-zero. It points to an area
 * in which longjmp() stuff is stored, as C callstack
 * info there at least is thread specific this has to
 * be per-thread. Otherwise a 'die' in a thread gives
 * that thread the C stack of last thread to do an eval {}!
 */

#define JMPENV_BOOTSTRAP \
    STMT_START {				\
	Zero(&PL_start_env, 1, JMPENV);		\
	PL_start_env.je_ret = -1;		\
	PL_start_env.je_mustcatch = TRUE;	\
	PL_top_env = &PL_start_env;		\
    } STMT_END

#ifdef PERL_FLEXIBLE_EXCEPTIONS

/*
 * These exception-handling macros are split up to
 * ease integration with C++ exceptions.
 *
 * To use C++ try+catch to catch Perl exceptions, an extension author
 * needs to first write an extern "C" function to throw an appropriate
 * exception object; typically it will be or contain an integer,
 * because Perl's internals use integers to track exception types:
 *    extern "C" { static void thrower(int i) { throw i; } }
 *
 * Then (as shown below) the author needs to use, not the simple
 * JMPENV_PUSH, but several of its constitutent macros, to arrange for
 * the Perl internals to call thrower() rather than longjmp() to
 * report exceptions:
 *
 *    dJMPENV;
 *    JMPENV_PUSH_INIT(thrower);
 *    try {
 *        ... stuff that may throw exceptions ...
 *    }
 *    catch (int why) {  // or whatever matches thrower()
 *        JMPENV_POST_CATCH;
 *        EXCEPT_SET(why);
 *        switch (why) {
 *          ... // handle various Perl exception codes
 *        }
 *    }
 *    JMPENV_POP;  // don't forget this!
 */

/*
 * Function that catches/throws, and its callback for the
 *  body of protected processing.
 */
typedef void *(CPERLscope(*protect_body_t)) (pTHX_ va_list);
typedef void *(CPERLscope(*protect_proc_t)) (pTHX_ volatile JMPENV *pcur_env,
					     int *, protect_body_t, ...);

#define dJMPENV	JMPENV cur_env;	\
		volatile JMPENV *pcur_env = ((cur_env.je_noset = 0),&cur_env)

#define JMPENV_PUSH_INIT_ENV(ce,THROWFUNC) \
    STMT_START {					\
	(ce).je_throw = (THROWFUNC);			\
	(ce).je_ret = -1;				\
	(ce).je_mustcatch = FALSE;			\
	(ce).je_prev = PL_top_env;			\
	PL_top_env = &(ce);				\
	OP_REG_TO_MEM;					\
    } STMT_END

#define JMPENV_PUSH_INIT(THROWFUNC) JMPENV_PUSH_INIT_ENV(*(JMPENV*)pcur_env,THROWFUNC)

#define JMPENV_POST_CATCH_ENV(ce) \
    STMT_START {					\
	OP_MEM_TO_REG;					\
	PL_top_env = &(ce);				\
    } STMT_END

#define JMPENV_POST_CATCH JMPENV_POST_CATCH_ENV(*(JMPENV*)pcur_env)

#define JMPENV_PUSH_ENV(ce,v) \
    STMT_START {						\
	if (!(ce).je_noset) {					\
	    DEBUG_l(Perl_deb(aTHX_ "Setting up jumplevel %p, was %p\n",	\
			     ce, PL_top_env));			\
	    JMPENV_PUSH_INIT_ENV(ce,NULL);			\
	    EXCEPT_SET_ENV(ce,PerlProc_setjmp((ce).je_buf, SCOPE_SAVES_SIGNAL_MASK));\
	    (ce).je_noset = 1;					\
	}							\
	else							\
	    EXCEPT_SET_ENV(ce,0);				\
	JMPENV_POST_CATCH_ENV(ce);				\
	(v) = EXCEPT_GET_ENV(ce);				\
    } STMT_END

#define JMPENV_PUSH(v) JMPENV_PUSH_ENV(*(JMPENV*)pcur_env,v)

#define JMPENV_POP_ENV(ce) \
    STMT_START {						\
	if (PL_top_env == &(ce))				\
	    PL_top_env = (ce).je_prev;				\
    } STMT_END

#define JMPENV_POP  JMPENV_POP_ENV(*(JMPENV*)pcur_env)

#define JMPENV_JUMP(v) \
    STMT_START {						\
	OP_REG_TO_MEM;						\
	if (PL_top_env->je_prev) {				\
	    if (PL_top_env->je_throw)				\
		PL_top_env->je_throw(v);			\
	    else						\
		PerlProc_longjmp(PL_top_env->je_buf, (v));	\
	}							\
	if ((v) == 2)						\
	    PerlProc_exit(STATUS_NATIVE_EXPORT);		\
	PerlIO_printf(Perl_error_log, "panic: top_env\n");	\
	PerlProc_exit(1);					\
    } STMT_END

#define EXCEPT_GET_ENV(ce)	((ce).je_ret)
#define EXCEPT_GET		EXCEPT_GET_ENV(*(JMPENV*)pcur_env)
#define EXCEPT_SET_ENV(ce,v)	((ce).je_ret = (v))
#define EXCEPT_SET(v)		EXCEPT_SET_ENV(*(JMPENV*)pcur_env,v)

#else /* !PERL_FLEXIBLE_EXCEPTIONS */

#define dJMPENV		JMPENV cur_env

#define JMPENV_PUSH(v) \
    STMT_START {							\
	DEBUG_l(Perl_deb(aTHX_ "Setting up jumplevel %p, was %p\n",	\
			 &cur_env, PL_top_env));			\
	cur_env.je_prev = PL_top_env;					\
	OP_REG_TO_MEM;							\
	cur_env.je_ret = PerlProc_setjmp(cur_env.je_buf, SCOPE_SAVES_SIGNAL_MASK);		\
	OP_MEM_TO_REG;							\
	PL_top_env = &cur_env;						\
	cur_env.je_mustcatch = FALSE;					\
	(v) = cur_env.je_ret;						\
    } STMT_END

#define JMPENV_POP \
    STMT_START { PL_top_env = cur_env.je_prev; } STMT_END

#define JMPENV_JUMP(v) \
    STMT_START {						\
	OP_REG_TO_MEM;						\
	if (PL_top_env->je_prev)				\
	    PerlProc_longjmp(PL_top_env->je_buf, (v));		\
	if ((v) == 2)						\
	    PerlProc_exit(STATUS_NATIVE_EXPORT);		\
	PerlIO_printf(PerlIO_stderr(), "panic: top_env\n");	\
	PerlProc_exit(1);					\
    } STMT_END

#endif /* PERL_FLEXIBLE_EXCEPTIONS */

#define CATCH_GET		(PL_top_env->je_mustcatch)
#define CATCH_SET(v)		(PL_top_env->je_mustcatch = (v))
@


1.9
log
@sync in-tree perl with 5.8.6
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2004, by Larry Wall and others
d201 1
a201 1
 * realloc returns data aligned to a size divisible by `align'!
@


1.8
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d50 1
d169 10
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, by Larry Wall and others
d153 8
a160 8
    STMT_START {				\
	if (PL_hints & HINT_LOCALIZE_HH)	\
	    save_hints();			\
	else {					\
	    SSCHECK(2);				\
	    SSPUSHINT(PL_hints);		\
	    SSPUSHINT(SAVEt_HINTS);		\
	}					\
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d3 2
a4 1
 *    Copyright (c) 1997-2002, Larry Wall
d49 1
d55 2
a56 1
#define SSCHECK(need) if (PL_savestack_ix + need > PL_savestack_max) savestack_grow()
d59 1
d66 1
d99 1
a99 2
	DEBUG_l(WITH_THR(Perl_deb(aTHX_ "ENTER scope %ld at %s:%d\n",	\
		    PL_scopestack_ix, __FILE__, __LINE__)));	\
d103 1
a103 2
	DEBUG_l(WITH_THR(Perl_deb(aTHX_ "LEAVE scope %ld at %s:%d\n",	\
		    PL_scopestack_ix, __FILE__, __LINE__)));	\
d122 1
d165 3
a167 9
	if (PL_comppad && PL_curpad == AvARRAY(PL_comppad)) {	\
	    SSCHECK(2);						\
	    SSPUSHPTR((SV*)PL_comppad);				\
	    SSPUSHINT(SAVEt_COMPPAD);				\
	}							\
	else {							\
	    SAVEVPTR(PL_curpad);				\
	    SAVESPTR(PL_comppad);				\
	}							\
d182 1
a182 1
#define SAVECOPLINE(c)		SAVEI16(CopLINE(c))
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d1 9
d47 5
d68 2
d130 1
d174 1
a174 1
#  define SAVECOPSTASH_FREE(c)	SAVEGENERICPV(CopSTASHPV(c))
d176 1
a176 1
#  define SAVECOPFILE_FREE(c)	SAVEGENERICPV(CopFILE(c))
d329 1
a329 1
	    EXCEPT_SET_ENV(ce,PerlProc_setjmp((ce).je_buf, 1));\
d378 1
a378 1
	cur_env.je_ret = PerlProc_setjmp(cur_env.je_buf, 1);		\
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d35 3
d106 1
d108 1
d113 1
d156 4
a159 2
#  define SAVECOPSTASH(cop)	SAVEPPTR(CopSTASHPV(cop))
#  define SAVECOPFILE(cop)	SAVEPPTR(CopFILE(cop))
d161 4
a164 2
#  define SAVECOPSTASH(cop)	SAVESPTR(CopSTASH(cop))
#  define SAVECOPFILE(cop)	SAVESPTR(CopFILEGV(cop))
d167 1
a167 1
#define SAVECOPLINE(cop)	SAVEI16(CopLINE(cop))
d180 3
a182 2
#define SSNEW(size)             save_alloc(size, 0)
#define SSNEWa(size,align)	save_alloc(size, \
d184 1
d186 2
a187 1
#define SSPTR(off,type)         ((type) ((char*)PL_savestack + off))
d296 1
a296 1
#define JMPENV_PUSH_INIT(THROWFUNC) JMPENV_PUSH_INIT_ENV(*(JMPENV*)pcur_env,THROWFUNC) 
d321 1
a321 1
#define JMPENV_PUSH(v) JMPENV_PUSH_ENV(*(JMPENV*)pcur_env,v) 
d329 1
a329 1
#define JMPENV_POP  JMPENV_POP_ENV(*(JMPENV*)pcur_env) 
@


1.3
log
@perl5.005_03 (stock)
@
text
@d1 29
a29 29
#define SAVEt_ITEM	0
#define SAVEt_SV	1
#define SAVEt_AV	2
#define SAVEt_HV	3
#define SAVEt_INT	4
#define SAVEt_LONG	5
#define SAVEt_I32	6
#define SAVEt_IV	7
#define SAVEt_SPTR	8
#define SAVEt_APTR	9
#define SAVEt_HPTR	10
#define SAVEt_PPTR	11
#define SAVEt_NSTAB	12
#define SAVEt_SVREF	13
#define SAVEt_GP	14
#define SAVEt_FREESV	15
#define SAVEt_FREEOP	16
#define SAVEt_FREEPV	17
#define SAVEt_CLEARSV	18
#define SAVEt_DELETE	19
#define SAVEt_DESTRUCTOR 20
#define SAVEt_REGCONTEXT 21
#define SAVEt_STACK_POS  22
#define SAVEt_I16	23
#define SAVEt_AELEM     24
#define SAVEt_HELEM     25
#define SAVEt_OP	26
#define SAVEt_HINTS	27
/* #define SAVEt_ALLOC		28 */ /* defined in 5.005_5x */
d31 4
d42 1
d48 19
d75 1
a75 1
	DEBUG_l(WITH_THR(deb("ENTER scope %ld at %s:%d\n",	\
d80 1
a80 1
	DEBUG_l(WITH_THR(deb("LEAVE scope %ld at %s:%d\n",	\
d94 1
d102 1
a109 2
#ifdef PERL_OBJECT
#define CALLDESTRUCTOR this->*SSPOPDPTR
d111 4
a114 8
	  save_destructor((DESTRUCTORFUNC)(FUNC_NAME_TO_PTR(f)),	\
			  SOFT_CAST(void*)(p))
#else
#define CALLDESTRUCTOR *SSPOPDPTR
#define SAVEDESTRUCTOR(f,p) \
	  save_destructor(SOFT_CAST(void(*)_((void*)))(FUNC_NAME_TO_PTR(f)), \
			  SOFT_CAST(void*)(p))
#endif
d136 40
d193 7
a199 3
    Sigjmp_buf		je_buf;		
    int			je_ret;		/* return value of last setjmp() */
    bool		je_mustcatch;	/* longjmp()s must be caught locally */
d212 62
a273 2
#define dJMPENV		JMPENV cur_env
#define JMPENV_PUSH(v) \
d275 5
a279 1
	cur_env.je_prev = PL_top_env;			\
d281 6
a286 1
	cur_env.je_ret = PerlProc_setjmp(cur_env.je_buf, 1);	\
d288 26
a313 3
	PL_top_env = &cur_env;				\
	cur_env.je_mustcatch = FALSE;			\
	(v) = cur_env.je_ret;				\
d315 40
d357 1
d361 2
a362 2
	if (PL_top_env->je_prev)					\
	    PerlProc_longjmp(PL_top_env->je_buf, (v));			\
d364 1
a364 1
	    PerlProc_exit(STATUS_NATIVE_EXPORT);				\
d366 1
a366 1
	PerlProc_exit(1);						\
d368 5
a372 4
   
#define CATCH_GET	(PL_top_env->je_mustcatch)
#define CATCH_SET(v)	(PL_top_env->je_mustcatch = (v))
   
@


1.2
log
@perl 5.004_04
@
text
@d25 18
d44 2
a45 17
#define SSCHECK(need) if (savestack_ix + need > savestack_max) savestack_grow()
#define SSPUSHINT(i) (savestack[savestack_ix++].any_i32 = (I32)(i))
#define SSPUSHLONG(i) (savestack[savestack_ix++].any_long = (long)(i))
#define SSPUSHIV(i) (savestack[savestack_ix++].any_iv = (IV)(i))
#define SSPUSHPTR(p) (savestack[savestack_ix++].any_ptr = (void*)(p))
#define SSPUSHDPTR(p) (savestack[savestack_ix++].any_dptr = (p))
#define SSPOPINT (savestack[--savestack_ix].any_i32)
#define SSPOPLONG (savestack[--savestack_ix].any_long)
#define SSPOPIV (savestack[--savestack_ix].any_iv)
#define SSPOPPTR (savestack[--savestack_ix].any_ptr)
#define SSPOPDPTR (savestack[--savestack_ix].any_dptr)

#define SAVETMPS save_int((int*)&tmps_floor), tmps_floor = tmps_ix
#define FREETMPS if (tmps_ix > tmps_floor) free_tmps()
#ifdef DEPRECATED
#define FREE_TMPS() FREETMPS
#endif
d47 14
d63 2
a64 1
#define LEAVE_SCOPE(old) if (savestack_ix > old) leave_scope(old)
d67 1
a67 1
 * Not using SOFT_CAST on SAVEFREESV and SAVEFREESV
d81 1
d84 7
d92 10
a101 6
	  save_destructor(SOFT_CAST(void(*)_((void*)))(f),SOFT_CAST(void*)(p))
#define SAVESTACK_POS() STMT_START {	\
    SSCHECK(2);				\
    SSPUSHINT(stack_sp - stack_base);	\
    SSPUSHINT(SAVEt_STACK_POS);		\
 } STMT_END
d103 12
d140 8
d151 5
a155 3
	cur_env.je_prev = top_env;			\
	cur_env.je_ret = Sigsetjmp(cur_env.je_buf, 1);	\
	top_env = &cur_env;				\
d160 1
a160 1
    STMT_START { top_env = cur_env.je_prev; } STMT_END
d163 3
a165 2
	if (top_env->je_prev)					\
	    Siglongjmp(top_env->je_buf, (v));			\
d167 1
a167 1
	    exit(STATUS_NATIVE_EXPORT);				\
d169 1
a169 1
	exit(1);						\
d172 2
a173 2
#define CATCH_GET	(top_env->je_mustcatch)
#define CATCH_SET(v)	(top_env->je_mustcatch = (v))
@


1.1
log
@Initial revision
@
text
@d23 2
d48 24
a71 12
#define SAVEINT(i) save_int((int*)(&i));
#define SAVEIV(i) save_iv((IV*)(&i));
#define SAVEI32(i) save_I32((I32*)(&i));
#define SAVELONG(l) save_long((long*)(&l));
#define SAVESPTR(s) save_sptr((SV**)(&s))
#define SAVEPPTR(s) save_pptr((char**)(&s))
#define SAVEFREESV(s) save_freesv((SV*)(s))
#define SAVEFREEOP(o) save_freeop((OP*)(o))
#define SAVEFREEPV(p) save_freepv((char*)(p))
#define SAVECLEARSV(sv) save_clearsv((SV**)(&sv))
#define SAVEDELETE(h,k,l) save_delete((HV*)(h), (char*)(k), (I32)l)
#define SAVEDESTRUCTOR(f,p) save_destructor(f,(void*)p)
d73 49
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@a22 8
#define SAVEt_STACK_POS  22
#define SAVEt_I16	23
#define SAVEt_AELEM     24
#define SAVEt_HELEM     25
#define SAVEt_OP	26
#define SAVEt_HINTS	27
/* #define SAVEt_ALLOC		28 */ /* defined in 5.005_5x */
#define SAVEt_GENERIC_SVREF	29
d24 17
a40 14
#define SSCHECK(need) if (PL_savestack_ix + need > PL_savestack_max) savestack_grow()
#define SSPUSHINT(i) (PL_savestack[PL_savestack_ix++].any_i32 = (I32)(i))
#define SSPUSHLONG(i) (PL_savestack[PL_savestack_ix++].any_long = (long)(i))
#define SSPUSHIV(i) (PL_savestack[PL_savestack_ix++].any_iv = (IV)(i))
#define SSPUSHPTR(p) (PL_savestack[PL_savestack_ix++].any_ptr = (void*)(p))
#define SSPUSHDPTR(p) (PL_savestack[PL_savestack_ix++].any_dptr = (p))
#define SSPOPINT (PL_savestack[--PL_savestack_ix].any_i32)
#define SSPOPLONG (PL_savestack[--PL_savestack_ix].any_long)
#define SSPOPIV (PL_savestack[--PL_savestack_ix].any_iv)
#define SSPOPPTR (PL_savestack[--PL_savestack_ix].any_ptr)
#define SSPOPDPTR (PL_savestack[--PL_savestack_ix].any_dptr)

#define SAVETMPS save_int((int*)&PL_tmps_floor), PL_tmps_floor = PL_tmps_ix
#define FREETMPS if (PL_tmps_ix > PL_tmps_floor) free_tmps()
a41 14
#ifdef DEBUGGING
#define ENTER							\
    STMT_START {						\
	push_scope();						\
	DEBUG_l(WITH_THR(deb("ENTER scope %ld at %s:%d\n",	\
		    PL_scopestack_ix, __FILE__, __LINE__)));	\
    } STMT_END
#define LEAVE							\
    STMT_START {						\
	DEBUG_l(WITH_THR(deb("LEAVE scope %ld at %s:%d\n",	\
		    PL_scopestack_ix, __FILE__, __LINE__)));	\
	pop_scope();						\
    } STMT_END
#else
d44 1
a44 39
#endif
#define LEAVE_SCOPE(old) if (PL_savestack_ix > old) leave_scope(old)

/*
 * Not using SOFT_CAST on SAVESPTR, SAVEGENERICSV and SAVEFREESV
 * because these are used for several kinds of pointer values
 */
#define SAVEI16(i)	save_I16(SOFT_CAST(I16*)&(i))
#define SAVEI32(i)	save_I32(SOFT_CAST(I32*)&(i))
#define SAVEINT(i)	save_int(SOFT_CAST(int*)&(i))
#define SAVEIV(i)	save_iv(SOFT_CAST(IV*)&(i))
#define SAVELONG(l)	save_long(SOFT_CAST(long*)&(l))
#define SAVESPTR(s)	save_sptr((SV**)&(s))
#define SAVEPPTR(s)	save_pptr(SOFT_CAST(char**)&(s))
#define SAVEFREESV(s)	save_freesv((SV*)(s))
#define SAVEFREEOP(o)	save_freeop(SOFT_CAST(OP*)(o))
#define SAVEFREEPV(p)	save_freepv(SOFT_CAST(char*)(p))
#define SAVECLEARSV(sv)	save_clearsv(SOFT_CAST(SV**)&(sv))
#define SAVEGENERICSV(s)	save_generic_svref((SV**)&(s))
#define SAVEDELETE(h,k,l) \
	  save_delete(SOFT_CAST(HV*)(h), SOFT_CAST(char*)(k), (I32)(l))
#ifdef PERL_OBJECT
#define CALLDESTRUCTOR this->*SSPOPDPTR
#define SAVEDESTRUCTOR(f,p) \
	  save_destructor((DESTRUCTORFUNC)(FUNC_NAME_TO_PTR(f)),	\
			  SOFT_CAST(void*)(p))
#else
#define CALLDESTRUCTOR *SSPOPDPTR
#define SAVEDESTRUCTOR(f,p) \
	  save_destructor(SOFT_CAST(void(*)_((void*)))(FUNC_NAME_TO_PTR(f)), \
			  SOFT_CAST(void*)(p))
#endif

#define SAVESTACK_POS() \
    STMT_START {				\
	SSCHECK(2);				\
	SSPUSHINT(PL_stack_sp - PL_stack_base);	\
	SSPUSHINT(SAVEt_STACK_POS);		\
    } STMT_END
d46 12
a57 44
#define SAVEOP()	save_op()

#define SAVEHINTS() \
    STMT_START {				\
	if (PL_hints & HINT_LOCALIZE_HH)	\
	    save_hints();			\
	else {					\
	    SSCHECK(2);				\
	    SSPUSHINT(PL_hints);		\
	    SSPUSHINT(SAVEt_HINTS);		\
	}					\
    } STMT_END

/* A jmpenv packages the state required to perform a proper non-local jump.
 * Note that there is a start_env initialized when perl starts, and top_env
 * points to this initially, so top_env should always be non-null.
 *
 * Existence of a non-null top_env->je_prev implies it is valid to call
 * longjmp() at that runlevel (we make sure start_env.je_prev is always
 * null to ensure this).
 *
 * je_mustcatch, when set at any runlevel to TRUE, means eval ops must
 * establish a local jmpenv to handle exception traps.  Care must be taken
 * to restore the previous value of je_mustcatch before exiting the
 * stack frame iff JMPENV_PUSH was not called in that stack frame.
 * GSAR 97-03-27
 */

struct jmpenv {
    struct jmpenv *	je_prev;
    Sigjmp_buf		je_buf;		
    int			je_ret;		/* return value of last setjmp() */
    bool		je_mustcatch;	/* longjmp()s must be caught locally */
};

typedef struct jmpenv JMPENV;

#ifdef OP_IN_REGISTER
#define OP_REG_TO_MEM	PL_opsave = op
#define OP_MEM_TO_REG	op = PL_opsave
#else
#define OP_REG_TO_MEM	NOOP
#define OP_MEM_TO_REG	NOOP
#endif
a58 27
#define dJMPENV		JMPENV cur_env
#define JMPENV_PUSH(v) \
    STMT_START {					\
	cur_env.je_prev = PL_top_env;			\
	OP_REG_TO_MEM;					\
	cur_env.je_ret = PerlProc_setjmp(cur_env.je_buf, 1);	\
	OP_MEM_TO_REG;					\
	PL_top_env = &cur_env;				\
	cur_env.je_mustcatch = FALSE;			\
	(v) = cur_env.je_ret;				\
    } STMT_END
#define JMPENV_POP \
    STMT_START { PL_top_env = cur_env.je_prev; } STMT_END
#define JMPENV_JUMP(v) \
    STMT_START {						\
	OP_REG_TO_MEM;						\
	if (PL_top_env->je_prev)					\
	    PerlProc_longjmp(PL_top_env->je_buf, (v));			\
	if ((v) == 2)						\
	    PerlProc_exit(STATUS_NATIVE_EXPORT);				\
	PerlIO_printf(PerlIO_stderr(), "panic: top_env\n");	\
	PerlProc_exit(1);						\
    } STMT_END
   
#define CATCH_GET	(PL_top_env->je_mustcatch)
#define CATCH_SET(v)	(PL_top_env->je_mustcatch = (v))
   
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d1 29
a29 29
#define SAVEt_ITEM		0
#define SAVEt_SV		1
#define SAVEt_AV		2
#define SAVEt_HV		3
#define SAVEt_INT		4
#define SAVEt_LONG		5
#define SAVEt_I32		6
#define SAVEt_IV		7
#define SAVEt_SPTR		8
#define SAVEt_APTR		9
#define SAVEt_HPTR		10
#define SAVEt_PPTR		11
#define SAVEt_NSTAB		12
#define SAVEt_SVREF		13
#define SAVEt_GP		14
#define SAVEt_FREESV		15
#define SAVEt_FREEOP		16
#define SAVEt_FREEPV		17
#define SAVEt_CLEARSV		18
#define SAVEt_DELETE		19
#define SAVEt_DESTRUCTOR	20
#define SAVEt_REGCONTEXT	21
#define SAVEt_STACK_POS		22
#define SAVEt_I16		23
#define SAVEt_AELEM		24
#define SAVEt_HELEM		25
#define SAVEt_OP		26
#define SAVEt_HINTS		27
#define SAVEt_ALLOC		28
a30 4
#define SAVEt_DESTRUCTOR_X	30
#define SAVEt_VPTR		31
#define SAVEt_I8		32
#define SAVEt_COMPPAD		33
a37 1
#define SSPUSHDXPTR(p) (PL_savestack[PL_savestack_ix++].any_dxptr = (p))
a42 19
#define SSPOPDXPTR (PL_savestack[--PL_savestack_ix].any_dxptr)

/*
=for apidoc Ams||SAVETMPS
Opening bracket for temporaries on a callback.  See C<FREETMPS> and
L<perlcall>.

=for apidoc Ams||FREETMPS
Closing bracket for temporaries on a callback.  See C<SAVETMPS> and
L<perlcall>.

=for apidoc Ams||ENTER
Opening bracket on a callback.  See C<LEAVE> and L<perlcall>.

=for apidoc Ams||LEAVE
Closing bracket on a callback.  See C<ENTER> and L<perlcall>.

=cut
*/
d51 1
a51 1
	DEBUG_l(WITH_THR(Perl_deb(aTHX_ "ENTER scope %ld at %s:%d\n",	\
d56 1
a56 1
	DEBUG_l(WITH_THR(Perl_deb(aTHX_ "LEAVE scope %ld at %s:%d\n",	\
a69 1
#define SAVEI8(i)	save_I8(SOFT_CAST(I8*)&(i))
a76 1
#define SAVEVPTR(s)	save_vptr((void*)&(s))
d84 2
d87 8
a94 4
	  save_destructor((DESTRUCTORFUNC_NOCONTEXT_t)(f), SOFT_CAST(void*)(p))

#define SAVEDESTRUCTOR_X(f,p) \
	  save_destructor_x((DESTRUCTORFUNC_t)(f), SOFT_CAST(void*)(p))
a115 40
#define SAVECOMPPAD() \
    STMT_START {						\
	if (PL_comppad && PL_curpad == AvARRAY(PL_comppad)) {	\
	    SSCHECK(2);						\
	    SSPUSHPTR((SV*)PL_comppad);				\
	    SSPUSHINT(SAVEt_COMPPAD);				\
	}							\
	else {							\
	    SAVEVPTR(PL_curpad);				\
	    SAVESPTR(PL_comppad);				\
	}							\
    } STMT_END

#ifdef USE_ITHREADS
#  define SAVECOPSTASH(cop)	SAVEPPTR(CopSTASHPV(cop))
#  define SAVECOPFILE(cop)	SAVEPPTR(CopFILE(cop))
#else
#  define SAVECOPSTASH(cop)	SAVESPTR(CopSTASH(cop))
#  define SAVECOPFILE(cop)	SAVESPTR(CopFILEGV(cop))
#endif

#define SAVECOPLINE(cop)	SAVEI16(CopLINE(cop))

/* SSNEW() temporarily allocates a specified number of bytes of data on the
 * savestack.  It returns an integer index into the savestack, because a
 * pointer would get broken if the savestack is moved on reallocation.
 * SSNEWa() works like SSNEW(), but also aligns the data to the specified
 * number of bytes.  MEM_ALIGNBYTES is perhaps the most useful.  The
 * alignment will be preserved therough savestack reallocation *only* if
 * realloc returns data aligned to a size divisible by `align'!
 *
 * SSPTR() converts the index returned by SSNEW/SSNEWa() into a pointer.
 */

#define SSNEW(size)             save_alloc(size, 0)
#define SSNEWa(size,align)	save_alloc(size, \
    (align - ((int)((caddr_t)&PL_savestack[PL_savestack_ix]) % align)) % align)

#define SSPTR(off,type)         ((type) ((char*)PL_savestack + off))

d133 3
a135 7
    Sigjmp_buf		je_buf;		/* only for use if !je_throw */
    int			je_ret;		/* last exception thrown */
    bool		je_mustcatch;	/* need to call longjmp()? */
#ifdef PERL_FLEXIBLE_EXCEPTIONS
    void		(*je_throw)(int v); /* last for bincompat */
    bool		je_noset;	/* no need for setjmp() */
#endif
d148 2
a149 62
/*
 * How to build the first jmpenv.
 *
 * top_env needs to be non-zero. It points to an area
 * in which longjmp() stuff is stored, as C callstack
 * info there at least is thread specific this has to
 * be per-thread. Otherwise a 'die' in a thread gives
 * that thread the C stack of last thread to do an eval {}!
 */

#define JMPENV_BOOTSTRAP \
    STMT_START {				\
	Zero(&PL_start_env, 1, JMPENV);		\
	PL_start_env.je_ret = -1;		\
	PL_start_env.je_mustcatch = TRUE;	\
	PL_top_env = &PL_start_env;		\
    } STMT_END

#ifdef PERL_FLEXIBLE_EXCEPTIONS

/*
 * These exception-handling macros are split up to
 * ease integration with C++ exceptions.
 *
 * To use C++ try+catch to catch Perl exceptions, an extension author
 * needs to first write an extern "C" function to throw an appropriate
 * exception object; typically it will be or contain an integer,
 * because Perl's internals use integers to track exception types:
 *    extern "C" { static void thrower(int i) { throw i; } }
 *
 * Then (as shown below) the author needs to use, not the simple
 * JMPENV_PUSH, but several of its constitutent macros, to arrange for
 * the Perl internals to call thrower() rather than longjmp() to
 * report exceptions:
 *
 *    dJMPENV;
 *    JMPENV_PUSH_INIT(thrower);
 *    try {
 *        ... stuff that may throw exceptions ...
 *    }
 *    catch (int why) {  // or whatever matches thrower()
 *        JMPENV_POST_CATCH;
 *        EXCEPT_SET(why);
 *        switch (why) {
 *          ... // handle various Perl exception codes
 *        }
 *    }
 *    JMPENV_POP;  // don't forget this!
 */

/*
 * Function that catches/throws, and its callback for the
 *  body of protected processing.
 */
typedef void *(CPERLscope(*protect_body_t)) (pTHX_ va_list);
typedef void *(CPERLscope(*protect_proc_t)) (pTHX_ volatile JMPENV *pcur_env,
					     int *, protect_body_t, ...);

#define dJMPENV	JMPENV cur_env;	\
		volatile JMPENV *pcur_env = ((cur_env.je_noset = 0),&cur_env)

#define JMPENV_PUSH_INIT_ENV(ce,THROWFUNC) \
d151 1
a151 5
	(ce).je_throw = (THROWFUNC);			\
	(ce).je_ret = -1;				\
	(ce).je_mustcatch = FALSE;			\
	(ce).je_prev = PL_top_env;			\
	PL_top_env = &(ce);				\
d153 1
a153 6
    } STMT_END

#define JMPENV_PUSH_INIT(THROWFUNC) JMPENV_PUSH_INIT_ENV(*(JMPENV*)pcur_env,THROWFUNC) 

#define JMPENV_POST_CATCH_ENV(ce) \
    STMT_START {					\
d155 3
a157 26
	PL_top_env = &(ce);				\
    } STMT_END

#define JMPENV_POST_CATCH JMPENV_POST_CATCH_ENV(*(JMPENV*)pcur_env)

#define JMPENV_PUSH_ENV(ce,v) \
    STMT_START {						\
	if (!(ce).je_noset) {					\
	    DEBUG_l(Perl_deb(aTHX_ "Setting up jumplevel %p, was %p\n",	\
			     ce, PL_top_env));			\
	    JMPENV_PUSH_INIT_ENV(ce,NULL);			\
	    EXCEPT_SET_ENV(ce,PerlProc_setjmp((ce).je_buf, 1));\
	    (ce).je_noset = 1;					\
	}							\
	else							\
	    EXCEPT_SET_ENV(ce,0);				\
	JMPENV_POST_CATCH_ENV(ce);				\
	(v) = EXCEPT_GET_ENV(ce);				\
    } STMT_END

#define JMPENV_PUSH(v) JMPENV_PUSH_ENV(*(JMPENV*)pcur_env,v) 

#define JMPENV_POP_ENV(ce) \
    STMT_START {						\
	if (PL_top_env == &(ce))				\
	    PL_top_env = (ce).je_prev;				\
a158 40

#define JMPENV_POP  JMPENV_POP_ENV(*(JMPENV*)pcur_env) 

#define JMPENV_JUMP(v) \
    STMT_START {						\
	OP_REG_TO_MEM;						\
	if (PL_top_env->je_prev) {				\
	    if (PL_top_env->je_throw)				\
		PL_top_env->je_throw(v);			\
	    else						\
		PerlProc_longjmp(PL_top_env->je_buf, (v));	\
	}							\
	if ((v) == 2)						\
	    PerlProc_exit(STATUS_NATIVE_EXPORT);		\
	PerlIO_printf(Perl_error_log, "panic: top_env\n");	\
	PerlProc_exit(1);					\
    } STMT_END

#define EXCEPT_GET_ENV(ce)	((ce).je_ret)
#define EXCEPT_GET		EXCEPT_GET_ENV(*(JMPENV*)pcur_env)
#define EXCEPT_SET_ENV(ce,v)	((ce).je_ret = (v))
#define EXCEPT_SET(v)		EXCEPT_SET_ENV(*(JMPENV*)pcur_env,v)

#else /* !PERL_FLEXIBLE_EXCEPTIONS */

#define dJMPENV		JMPENV cur_env

#define JMPENV_PUSH(v) \
    STMT_START {							\
	DEBUG_l(Perl_deb(aTHX_ "Setting up jumplevel %p, was %p\n",	\
			 &cur_env, PL_top_env));			\
	cur_env.je_prev = PL_top_env;					\
	OP_REG_TO_MEM;							\
	cur_env.je_ret = PerlProc_setjmp(cur_env.je_buf, 1);		\
	OP_MEM_TO_REG;							\
	PL_top_env = &cur_env;						\
	cur_env.je_mustcatch = FALSE;					\
	(v) = cur_env.je_ret;						\
    } STMT_END

a160 1

d164 2
a165 2
	if (PL_top_env->je_prev)				\
	    PerlProc_longjmp(PL_top_env->je_buf, (v));		\
d167 1
a167 1
	    PerlProc_exit(STATUS_NATIVE_EXPORT);		\
d169 1
a169 1
	PerlProc_exit(1);					\
d171 4
a174 5

#endif /* PERL_FLEXIBLE_EXCEPTIONS */

#define CATCH_GET		(PL_top_env->je_mustcatch)
#define CATCH_SET(v)		(PL_top_env->je_mustcatch = (v))
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@a34 3
#define SAVEt_GENERIC_PVREF	34
#define SAVEt_PADSV		35
#define SAVEt_MORTALIZESV	36
a102 1
#define SAVEPADSV(s)	save_padsv(s)
a103 1
#define SAVEMORTALIZESV(s)	save_mortalizesv((SV*)(s))
a107 1
#define SAVEGENERICPV(s)	save_generic_pvref((char**)&(s))
d150 2
a151 4
#  define SAVECOPSTASH(c)	SAVEPPTR(CopSTASHPV(c))
#  define SAVECOPSTASH_FREE(c)	SAVEGENERICPV(CopSTASHPV(c))
#  define SAVECOPFILE(c)	SAVEPPTR(CopFILE(c))
#  define SAVECOPFILE_FREE(c)	SAVEGENERICPV(CopFILE(c))
d153 2
a154 4
#  define SAVECOPSTASH(c)	SAVESPTR(CopSTASH(c))
#  define SAVECOPSTASH_FREE(c)	SAVECOPSTASH(c)	/* XXX not refcounted */
#  define SAVECOPFILE(c)	SAVESPTR(CopFILEGV(c))
#  define SAVECOPFILE_FREE(c)	SAVEGENERICSV(CopFILEGV(c))
d157 1
a157 1
#define SAVECOPLINE(c)		SAVEI16(CopLINE(c))
d170 2
a171 3
#define SSNEW(size)             Perl_save_alloc(aTHX_ (size), 0)
#define SSNEWt(n,t)             SSNEW((n)*sizeof(t))
#define SSNEWa(size,align)	Perl_save_alloc(aTHX_ (size), \
a172 1
#define SSNEWat(n,t,align)	SSNEWa((n)*sizeof(t), align)
d174 1
a174 2
#define SSPTR(off,type)         ((type)  ((char*)PL_savestack + off))
#define SSPTRt(off,type)        ((type*) ((char*)PL_savestack + off))
d283 1
a283 1
#define JMPENV_PUSH_INIT(THROWFUNC) JMPENV_PUSH_INIT_ENV(*(JMPENV*)pcur_env,THROWFUNC)
d308 1
a308 1
#define JMPENV_PUSH(v) JMPENV_PUSH_ENV(*(JMPENV*)pcur_env,v)
d316 1
a316 1
#define JMPENV_POP  JMPENV_POP_ENV(*(JMPENV*)pcur_env)
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@a0 9
/*    scope.h
 *
 *    Copyright (c) 1997-2002, Larry Wall
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

a37 5
#define SAVEt_SHARED_PVREF	37

#ifndef SCOPE_SAVES_SIGNAL_MASK
#define SCOPE_SAVES_SIGNAL_MASK 0
#endif
a53 2
=head1 Callback Functions

a113 1
#define SAVESHAREDPV(s)		save_shared_pvref((char**)&(s))
d157 1
a157 1
#  define SAVECOPSTASH_FREE(c)	SAVESHAREDPV(CopSTASHPV(c))
d159 1
a159 1
#  define SAVECOPFILE_FREE(c)	SAVESHAREDPV(CopFILE(c))
d312 1
a312 1
	    EXCEPT_SET_ENV(ce,PerlProc_setjmp((ce).je_buf, SCOPE_SAVES_SIGNAL_MASK));\
d361 1
a361 1
	cur_env.je_ret = PerlProc_setjmp(cur_env.je_buf, SCOPE_SAVES_SIGNAL_MASK);		\
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@d3 1
a3 2
 *    Copyright (C) 1993, 1994, 1996, 1997, 1998, 1999,
 *    2000, 2001, 2002, by Larry Wall and others
a47 1
#define SAVEt_BOOL		38
d53 1
a53 2
#define SSCHECK(need) if (PL_savestack_ix + (need) > PL_savestack_max) savestack_grow()
#define SSGROW(need) if (PL_savestack_ix + (need) > PL_savestack_max) savestack_grow_cnt(need)
a55 1
#define SSPUSHBOOL(p) (PL_savestack[PL_savestack_ix++].any_bool = (p))
a61 1
#define SSPOPBOOL (PL_savestack[--PL_savestack_ix].any_bool)
d94 2
a95 1
	DEBUG_SCOPE("ENTER")					\
d99 2
a100 1
	DEBUG_SCOPE("LEAVE")					\
a118 1
#define SAVEBOOL(b)	save_bool(SOFT_CAST(bool*)&(b))
d161 9
a169 3
	SSCHECK(2);						\
	SSPUSHPTR((SV*)PL_comppad);				\
	SSPUSHINT(SAVEt_COMPPAD);				\
d184 1
a184 1
#define SAVECOPLINE(c)		SAVEI32(CopLINE(c))
@


1.1.1.7
log
@Import of stock perl 5.8.5
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2004, by Larry Wall and others
d153 8
a160 8
    STMT_START {					\
	SSCHECK(3);					\
	if (PL_hints & HINT_LOCALIZE_HH) {		\
	    SSPUSHPTR(GvHV(PL_hintgv));			\
	    GvHV(PL_hintgv) = newHVhv(GvHV(PL_hintgv));	\
	}						\
	SSPUSHINT(PL_hints);				\
	SSPUSHINT(SAVEt_HINTS);				\
@


1.1.1.8
log
@perl 5.8.6 from CPAN
@
text
@a49 1
#define SAVEt_SAVESWITCHSTACK	40
a167 10
    } STMT_END

#define SAVESWITCHSTACK(f,t) \
    STMT_START {					\
	SSCHECK(3);					\
	SSPUSHPTR((SV*)(f));				\
	SSPUSHPTR((SV*)(t));				\
	SSPUSHINT(SAVEt_SAVESWITCHSTACK);		\
	SWITCHSTACK((f),(t));				\
	PL_curstackinfo->si_stack = (t);		\
@


1.1.1.9
log
@perl 5.8.8 import
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2004, 2005 by Larry Wall and others
d201 1
a201 1
 * realloc returns data aligned to a size divisible by "align"!
@


1.1.1.10
log
@import perl 5.10.0 from CPAN
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2004, 2005, 2006, 2007 by Larry Wall and others
a49 1
#define SAVEt_SET_SVFLAGS	39
a50 5
#define SAVEt_COP_ARYBASE	41
#define SAVEt_RE_STATE		42
#define SAVEt_COMPILE_WARNINGS	43
#define SAVEt_STACK_CXPOS	44
#define SAVEt_PARSER		45
d56 2
a57 2
#define SSCHECK(need) if (PL_savestack_ix + (I32)(need) > PL_savestack_max) savestack_grow()
#define SSGROW(need) if (PL_savestack_ix + (I32)(need) > PL_savestack_max) savestack_grow_cnt(need)
d113 11
a123 7
#define SAVEI8(i)	save_I8((I8*)&(i))
#define SAVEI16(i)	save_I16((I16*)&(i))
#define SAVEI32(i)	save_I32((I32*)&(i))
#define SAVEINT(i)	save_int((int*)&(i))
#define SAVEIV(i)	save_iv((IV*)&(i))
#define SAVELONG(l)	save_long((long*)&(l))
#define SAVEBOOL(b)	save_bool((bool*)&(b))
d125 1
a125 1
#define SAVEPPTR(s)	save_pptr((char**)&(s))
d130 3
a132 3
#define SAVEFREEOP(o)	save_freeop((OP*)(o))
#define SAVEFREEPV(p)	save_freepv((char*)(p))
#define SAVECLEARSV(sv)	save_clearsv((SV**)&(sv))
a135 1
#define SAVESETSVFLAGS(sv,mask,val)	save_set_svflags(sv,mask,val)
d137 1
a137 1
	  save_delete((HV*)(h), (char*)(k), (I32)(l))
d139 1
a139 1
	  save_destructor((DESTRUCTORFUNC_NOCONTEXT_t)(f), (void*)(p))
d142 1
a142 1
	  save_destructor_x((DESTRUCTORFUNC_t)(f), (void*)(p))
d155 1
a155 1
	SSCHECK(4);					\
d158 1
a158 1
	    GvHV(PL_hintgv) = Perl_hv_copy_hints_hv(aTHX_ GvHV(PL_hintgv)); \
a159 6
	if (PL_compiling.cop_hints_hash) {		\
	    HINTS_REFCNT_LOCK;				\
	    PL_compiling.cop_hints_hash->refcounted_he_refcnt++;	\
	    HINTS_REFCNT_UNLOCK;			\
	}						\
	SSPUSHPTR(PL_compiling.cop_hints_hash);		\
a180 35
#define SAVECOPARYBASE(c) \
    STMT_START {					\
	SSCHECK(3);					\
	SSPUSHINT(CopARYBASE_get(c));			\
	SSPUSHPTR(c);					\
	SSPUSHINT(SAVEt_COP_ARYBASE);			\
    } STMT_END

/* Need to do the cop warnings like this, rather than a "SAVEFREESHAREDPV",
   because realloc() means that the value can actually change. Possibly
   could have done savefreesharedpvREF, but this way actually seems cleaner,
   as it simplifies the code that does the saves, and reduces the load on the
   save stack.  */
#define SAVECOMPILEWARNINGS() \
    STMT_START {					\
	SSCHECK(2);					\
	SSPUSHPTR(PL_compiling.cop_warnings);		\
	SSPUSHINT(SAVEt_COMPILE_WARNINGS);		\
    } STMT_END

#define SAVESTACK_CXPOS() \
    STMT_START {                                  \
        SSCHECK(3);                               \
        SSPUSHINT(cxstack[cxstack_ix].blk_oldsp); \
        SSPUSHINT(cxstack_ix);                    \
        SSPUSHINT(SAVEt_STACK_CXPOS);             \
    } STMT_END

#define SAVEPARSER(p) \
    STMT_START {                                  \
        SSCHECK(2);                               \
        SSPUSHPTR(p);		                  \
        SSPUSHINT(SAVEt_PARSER); 	          \
    } STMT_END

a185 2
#  define SAVECOPLABEL(c)	SAVEPPTR(CopLABEL(c))
#  define SAVECOPLABEL_FREE(c)	SAVESHAREDPV(CopLABEL(c))
a190 2
#  define SAVECOPLABEL(c)	SAVEPPTR(CopLABEL(c))
#  define SAVECOPLABEL_FREE(c)	SAVEPPTR(CopLABEL(c))
d215 197
@


1.1.1.11
log
@import perl 5.10.1
@
text
@d3 2
a4 2
 *    Copyright (C) 1993, 1994, 1996, 1997, 1998, 1999, 2000, 2001,
 *    2002, 2004, 2005, 2006, 2007, 2008 by Larry Wall and others
a56 1
#define SAVEt_PADSV_AND_MORTALIZE	46
d130 2
a131 3
#define SAVEPADSVANDMORTALIZE(s)	save_padsv_and_mortalize(s)
#define SAVEFREESV(s)	save_freesv(MUTABLE_SV(s))
#define SAVEMORTALIZESV(s)	save_mortalizesv(MUTABLE_SV(s))
d140 1
a140 1
	  save_delete(MUTABLE_HV(h), (char*)(k), (I32)(l))
d156 16
a171 1
#define SAVEHINTS()	save_hints()
d173 6
a178 1
#define SAVECOMPPAD() save_pushptr(MUTABLE_SV(PL_comppad), SAVEt_COMPPAD)
d182 4
a185 1
	save_pushptrptr(MUTABLE_SV(f), MUTABLE_SV(t), SAVEt_SAVESWITCHSTACK); \
d190 7
a196 1
#define SAVECOPARYBASE(c) save_pushi32ptr(CopARYBASE_get(c), c, SAVEt_COP_ARYBASE);
d203 6
a208 1
#define SAVECOMPILEWARNINGS() save_pushptr(PL_compiling.cop_warnings, SAVEt_COMPILE_WARNINGS)
d218 6
a223 1
#define SAVEPARSER(p) save_pushptr((p), SAVEt_PARSER)
d257 1
a257 1
    (I32)(align - ((size_t)((caddr_t)&PL_savestack[PL_savestack_ix]) % align)) % align)
a262 15
#define save_freesv(op)		save_pushptr((void *)(op), SAVEt_FREESV)
#define save_mortalizesv(op)	save_pushptr((void *)(op), SAVEt_MORTALIZESV)
#define save_freeop(op)		save_pushptr((void *)(op), SAVEt_FREEOP)
#define save_freepv(pv)		save_pushptr((void *)(pv), SAVEt_FREEPV)
#define save_op()		save_pushptr((void *)(PL_op), SAVEt_OP)

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 noet:
 */
@


1.1.1.12
log
@Perl 5.12.2 from CPAN
@
text
@d46 1
a46 1
#define SAVEt_PADSV_AND_MORTALIZE	35
d57 1
a57 7
#define SAVEt_ADELETE		46

#define SAVEf_SETMAGIC		1
#define SAVEf_KEEPOLDELEM	2

#define save_aelem(av,idx,sptr)	save_aelem_flags(av,idx,sptr,SAVEf_SETMAGIC)
#define save_helem(hv,key,sptr)	save_helem_flags(hv,key,sptr,SAVEf_SETMAGIC)
a96 14
=over

=item ENTER_with_name(name)

Same as C<ENTER>, but when debugging is enabled it also associates the
given literal string with the new scope.

=item LEAVE_with_name(name)

Same as C<LEAVE>, but when debugging is enabled it first checks that the
scope has the given name. Name must be a literal string.

=back

a113 17
#define ENTER_with_name(name)						\
    STMT_START {							\
	push_scope();							\
	if (PL_scopestack_name)						\
	    PL_scopestack_name[PL_scopestack_ix-1] = name;		\
	DEBUG_SCOPE("ENTER \"" name "\"")				\
    } STMT_END
#define LEAVE_with_name(name)						\
    STMT_START {							\
	DEBUG_SCOPE("LEAVE \"" name "\"")				\
	if (PL_scopestack_name)	{					\
	    assert(((char*)PL_scopestack_name[PL_scopestack_ix-1]	\
			== (char*)name)					\
		    || strEQ(PL_scopestack_name[PL_scopestack_ix-1], name));        \
	}								\
	pop_scope();							\
    } STMT_END
a116 2
#define ENTER_with_name(name) ENTER
#define LEAVE_with_name(name) LEAVE
d130 1
a142 4
#define SAVEHDELETE(h,s) \
	  save_hdelete(MUTABLE_HV(h), (s))
#define SAVEADELETE(a,k) \
	  save_adelete(MUTABLE_AV(a), (I32)(k))
d193 2
d200 2
@


1.1.1.13
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d52 1
a57 4
#define SAVEt_I32_SMALL		47
#define SAVEt_INT_SMALL		48
#define SAVEt_GVSV		49
#define SAVEt_FREECOPHH		50
a61 3
#define SAVE_TIGHT_SHIFT	6
#define SAVE_MASK		0x3F

a74 1
#define SSPUSHUV(u) (PL_savestack[PL_savestack_ix++].any_uv = (UV)(u))
a81 1
#define SSPOPUV (PL_savestack[--PL_savestack_ix].any_uv)
d165 1
a165 1
#define SAVEBOOL(b)	save_bool(&(b))
a178 1
#define SAVEFREECOPHH(h)	save_pushptr((void *)(h), SAVEt_FREECOPHH)
d195 1
a195 1
	SSPUSHUV(SAVEt_STACK_POS);		\
d211 2
d225 1
a225 1
        SSPUSHUV(SAVEt_STACK_CXPOS);              \
d231 2
a232 4
#  define SAVECOPSTASH(c)	(SAVEPPTR(CopSTASHPV(c)), \
				 SAVEI32(CopSTASH_len(c)))
#  define SAVECOPSTASH_FREE(c)	(SAVESHAREDPV(CopSTASHPV(c)), \
	                         SAVEI32(CopSTASH_len(c)))
d249 1
a249 1
 * alignment will be preserved through savestack reallocation *only* if
@


1.1.1.14
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d11 50
a60 71
/* *** these are ordered by number of of auto-popped args */

/* zero args */

#define SAVEt_ALLOC		0
#define SAVEt_CLEARPADRANGE	1
#define SAVEt_CLEARSV		2
#define SAVEt_REGCONTEXT	3
#define SAVEt_RE_STATE		4

#define SAVEt_ARG0_MAX		4

/* one arg */

#define SAVEt_BOOL		5
#define SAVEt_COMPILE_WARNINGS	6
#define SAVEt_COMPPAD		7
#define SAVEt_FREECOPHH		8
#define SAVEt_FREEOP		9
#define SAVEt_FREEPV		10
#define SAVEt_FREESV		11
#define SAVEt_I16		12
#define SAVEt_I32_SMALL		13
#define SAVEt_I8		14
#define SAVEt_INT_SMALL		15
#define SAVEt_MORTALIZESV	16
#define SAVEt_NSTAB		17
#define SAVEt_OP		18
#define SAVEt_PARSER		19
#define SAVEt_STACK_POS		20

#define SAVEt_ARG1_MAX		20

/* two args */

#define SAVEt_ADELETE		21
#define SAVEt_APTR		22
#define SAVEt_AV		23
#define SAVEt_DESTRUCTOR	24
#define SAVEt_DESTRUCTOR_X	25
#define SAVEt_GENERIC_PVREF	26
#define SAVEt_GENERIC_SVREF	27
#define SAVEt_GP		28
#define SAVEt_GVSV		29
#define SAVEt_HINTS		30
#define SAVEt_HPTR		31
#define SAVEt_HV		32
#define SAVEt_I32		33
#define SAVEt_INT		34
#define SAVEt_ITEM		35
#define SAVEt_IV		36
#define SAVEt_LONG		37
#define SAVEt_PPTR		38
#define SAVEt_SAVESWITCHSTACK	39
#define SAVEt_SHARED_PVREF	40
#define SAVEt_SPTR		41
#define SAVEt_STACK_CXPOS	42
#define SAVEt_SV		43
#define SAVEt_SVREF		44
#define SAVEt_VPTR		45

#define SAVEt_ARG2_MAX		45

/* three args */

#define SAVEt_AELEM		46
#define SAVEt_DELETE		47
#define SAVEt_HELEM		48
#define SAVEt_PADSV_AND_MORTALIZE 49
#define SAVEt_SET_SVFLAGS	50
#define SAVEt_GVSLOT		51
d75 2
a76 6
/* the maximum number of entries that might be pushed using the SS_ADD*
 * macros */
#define SS_MAXPUSH 4

#define SSCHECK(need) if (PL_savestack_ix + (I32)(need) + SS_MAXPUSH > PL_savestack_max) savestack_grow()
#define SSGROW(need) if (PL_savestack_ix + (I32)(need) + SS_MAXPUSH > PL_savestack_max) savestack_grow_cnt(need + SS_MAXPUSH)
a84 34

/* SS_ADD*: newer, faster versions of the above. Don't mix the two sets of
 * macros. These are fast because they save reduce accesses to the PL_
 * vars and move the size check to the end. Doing the check last means
 * that values in registers will have been pushed and no longer needed, so
 * don't need saving around the call to grow. Also, tail-call elimination
 * of the grow() can be done. These changes reduce the code of something
 * like save_pushptrptr() to half its former size.
 * Of course, doing the size check *after* pushing means we must always
 * ensure there are SS_MAXPUSH free slots on the savestack
 *
 * These are for internal core use only and are subject to change */

#define dSS_ADD \
    I32 ix = PL_savestack_ix;     \
    ANY *ssp = &PL_savestack[ix];

#define SS_ADD_END(need) \
    assert((need) <= SS_MAXPUSH);                               \
    ix += (need);                                               \
    PL_savestack_ix = ix;                                       \
    assert(ix <= PL_savestack_max);                             \
    if ((ix + SS_MAXPUSH) > PL_savestack_max) savestack_grow(); \
    assert(PL_savestack_ix + SS_MAXPUSH <= PL_savestack_max);

#define SS_ADD_INT(i)   ((ssp++)->any_i32 = (I32)(i))
#define SS_ADD_LONG(i)  ((ssp++)->any_long = (long)(i))
#define SS_ADD_BOOL(p)  ((ssp++)->any_bool = (p))
#define SS_ADD_IV(i)    ((ssp++)->any_iv = (IV)(i))
#define SS_ADD_UV(u)    ((ssp++)->any_uv = (UV)(u))
#define SS_ADD_PTR(p)   ((ssp++)->any_ptr = (void*)(p))
#define SS_ADD_DPTR(p)  ((ssp++)->any_dptr = (p))
#define SS_ADD_DXPTR(p) ((ssp++)->any_dxptr = (p))

a93 1

d165 1
a165 3
#define LEAVE_SCOPE(old) STMT_START { \
	if (PL_savestack_ix > old) leave_scope(old); \
    } STMT_END
d201 4
a204 5
    STMT_START {				   \
        dSS_ADD;                                   \
        SS_ADD_INT(PL_stack_sp - PL_stack_base);   \
        SS_ADD_UV(SAVEt_STACK_POS);                \
        SS_ADD_END(2);                             \
d228 5
a232 6
    STMT_START {                                   \
        dSS_ADD;                                   \
        SS_ADD_INT(cxstack[cxstack_ix].blk_oldsp); \
        SS_ADD_INT(cxstack_ix);                    \
        SS_ADD_UV(SAVEt_STACK_CXPOS);              \
        SS_ADD_END(3);                             \
d238 4
a241 1
#  define SAVECOPSTASH_FREE(c)	SAVEIV((c)->cop_stashoff)
d245 2
a246 2
#  /* XXX not refcounted */
#  define SAVECOPSTASH_FREE(c)	SAVESPTR(CopSTASH(c))
d275 1
a275 8

# define save_freeop(op)                    \
STMT_START {                                 \
      OP * const _o = (OP *)(op);             \
      assert(!_o->op_savefree);               \
      _o->op_savefree = 1;                     \
      save_pushptr((void *)(_o), SAVEt_FREEOP); \
    } STMT_END
d283 1
a283 1
 * indent-tabs-mode: nil
d286 1
a286 1
 * ex: set ts=8 sts=4 sw=4 et:
@


1.1.1.15
log
@Import perl-5.20.1
@
text
@d19 1
a19 1
/*** SPARE      	        4 ***/
a40 1
#define SAVEt_READONLY_OFF	21
d42 1
a42 1
#define SAVEt_ARG1_MAX		21
d46 1
d67 1
a67 1
#define SAVEt_STRLEN		42
a70 1
#define SAVEt_ADELETE		46
d72 1
a72 1
#define SAVEt_ARG2_MAX		46
d76 1
a81 1
#define SAVEt_AELEM		52
d100 2
a101 2
#define SSCHECK(need) if (UNLIKELY(PL_savestack_ix + (I32)(need) + SS_MAXPUSH > PL_savestack_max)) savestack_grow()
#define SSGROW(need) if (UNLIKELY(PL_savestack_ix + (I32)(need) + SS_MAXPUSH > PL_savestack_max)) savestack_grow_cnt(need + SS_MAXPUSH)
d125 1
a125 1
    ANY *ssp = &PL_savestack[ix]
d132 1
a132 1
    if (UNLIKELY((ix + SS_MAXPUSH) > PL_savestack_max)) savestack_grow(); \
d188 1
a188 2
#define SAVETMPS Perl_save_strlen(aTHX_ (STRLEN *)&PL_tmps_floor), \
		 PL_tmps_floor = PL_tmps_ix
d255 1
a255 1
	  save_adelete(MUTABLE_AV(a), (SSize_t)(k))
d289 9
@


1.1.1.16
log
@Import perl-5.24.2
@
text
@d19 1
d21 1
a21 1
#define SAVEt_ARG0_MAX		3
a24 1
#define SAVEt_TMPSFLOOR		4
a41 1
#define SAVEt_FREEPADNAME	22
d43 1
a43 1
#define SAVEt_ARG1_MAX		22
d47 1
a71 1
#define SAVEt_APTR		47
d73 1
a73 1
#define SAVEt_ARG2_MAX		47
d77 1
a82 2
#define SAVEt_DELETE		53

d101 2
a102 2
#define SSCHECK(need) if (UNLIKELY(PL_savestack_ix + (I32)(need) > PL_savestack_max)) savestack_grow()
#define SSGROW(need) if (UNLIKELY(PL_savestack_ix + (I32)(need) > PL_savestack_max)) savestack_grow_cnt(need)
d120 1
a120 3
 * ensure there are SS_MAXPUSH free slots on the savestack. This ensured
 * bt savestack_grow() and savestack_grow_cnt always allocating SS_MAXPUSH
 * slots more than asked for, or that it sets PL_savestack_max to
d132 3
a134 3
    assert(ix <= PL_savestack_max + SS_MAXPUSH);                \
    if (UNLIKELY(ix > PL_savestack_max)) savestack_grow();      \
    assert(PL_savestack_ix <= PL_savestack_max);
d159 1
a159 1
Opening bracket for temporaries on a callback.  See C<L</FREETMPS>> and
d163 1
a163 1
Closing bracket for temporaries on a callback.  See C<L</SAVETMPS>> and
d167 1
a167 1
Opening bracket on a callback.  See C<L</LEAVE>> and L<perlcall>.
d170 1
a170 1
Closing bracket on a callback.  See C<L</ENTER>> and L<perlcall>.
d182 1
a182 1
scope has the given name. C<name> must be a C<NUL>-terminated literal string.
d189 2
a190 2
#define SAVETMPS Perl_savetmps(aTHX)

a242 1
#define SAVEFREEPADNAME(s) save_pushptr((void *)(s), SAVEt_FREEPADNAME)
d308 1
a308 1
 * savestack.  It returns an I32 index into the savestack, because a
d341 6
@


