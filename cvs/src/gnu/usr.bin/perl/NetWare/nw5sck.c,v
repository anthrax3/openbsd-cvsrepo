head	1.1;
branch	1.1.1;
access;
symbols
	PERL_5_24_2:1.1.1.2
	OPENBSD_6_1:1.1.1.2.0.18
	OPENBSD_6_1_BASE:1.1.1.2
	OPENBSD_6_0:1.1.1.2.0.16
	OPENBSD_6_0_BASE:1.1.1.2
	OPENBSD_5_9:1.1.1.2.0.10
	OPENBSD_5_9_BASE:1.1.1.2
	OPENBSD_5_8:1.1.1.2.0.12
	OPENBSD_5_8_BASE:1.1.1.2
	PERL_5_20_2:1.1.1.2
	OPENBSD_5_7:1.1.1.2.0.4
	OPENBSD_5_7_BASE:1.1.1.2
	PERL_5_20_1:1.1.1.2
	OPENBSD_5_6:1.1.1.2.0.8
	OPENBSD_5_6_BASE:1.1.1.2
	PERL_5_18_2:1.1.1.2
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.2.0.6
	OPENBSD_5_5_BASE:1.1.1.2
	OPENBSD_5_4:1.1.1.2.0.2
	OPENBSD_5_4_BASE:1.1.1.2
	PERL_5_16_3:1.1.1.2
	OPENBSD_5_3:1.1.1.1.0.42
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.40
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.38
	OPENBSD_5_0:1.1.1.1.0.36
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.34
	OPENBSD_4_9_BASE:1.1.1.1
	PERL_5_12_2:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.32
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.28
	OPENBSD_4_7_BASE:1.1.1.1
	PERL_5_10_1:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.30
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.26
	OPENBSD_4_5_BASE:1.1.1.1
	PERL_5_10_0:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.24
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.22
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.20
	OPENBSD_4_2_BASE:1.1.1.1
	OPENBSD_4_1:1.1.1.1.0.18
	OPENBSD_4_1_BASE:1.1.1.1
	OPENBSD_4_0:1.1.1.1.0.16
	OPENBSD_4_0_BASE:1.1.1.1
	PERL_5_8_8:1.1.1.1
	OPENBSD_3_9:1.1.1.1.0.14
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.12
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.10
	OPENBSD_3_7_BASE:1.1.1.1
	PERL_5_8_6:1.1.1.1
	OPENBSD_3_6:1.1.1.1.0.8
	OPENBSD_3_6_BASE:1.1.1.1
	PERL_5_8_5:1.1.1.1
	PERL_5_8_3:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.6
	OPENBSD_3_5_BASE:1.1.1.1
	PERL_5_8_2:1.1.1.1
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	PERL_5_8_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.1
date	2002.10.27.22.15.02;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.27.22.15.02;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.03.25.20.09.11;	author sthen;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@
/*
 * Copyright © 2001 Novell, Inc. All Rights Reserved.
 *
 * You may distribute under the terms of either the GNU General Public
 * License or the Artistic License, as specified in the README file.
 *
 */

/*
 * FILENAME     :  nw5sck.c
 * DESCRIPTION	:  Socket related functions.
 * Author		:  SGP
 * Date			:  January 2001.
 * Date Modified:  June 26th 2001.
 */



#include "EXTERN.h"
#include "perl.h"

#include "nw5iop.h"
#include "nw5sck.h"
#include <fcntl.h>
#include <sys/stat.h>

// This is defined here since  arpa\inet.h  defines this array as an extern,
// and  arpa\inet.h  gets included by the  inet_ntoa  call.
char nwinet_scratch[18] = {'\0'};


u_long
nw_htonl(u_long hostlong)
{
    return htonl(hostlong);
}

u_short
nw_htons(u_short hostshort)
{
    return htons(hostshort);
}

u_long
nw_ntohl(u_long netlong)
{
    return ntohl(netlong);
}

u_short
nw_ntohs(u_short netshort)
{
    return ntohs(netshort);
}

SOCKET
nw_accept(SOCKET s, struct sockaddr *addr, int *addrlen)
{
	return ((SOCKET)(accept(s, addr, addrlen)));
}

int
nw_bind(SOCKET s, const struct sockaddr *addr, int addrlen)
{
	return ((int)bind(s, (struct sockaddr *)addr, addrlen));

}

int
nw_connect(SOCKET s, const struct sockaddr *addr, int addrlen)
{
	return((int)connect(s, (struct sockaddr *)addr, addrlen));
}

void
nw_endhostent() 
{
	endhostent();
}

void
nw_endnetent()
{
	endnetent();
}

void
nw_endprotoent()
{
	endprotoent();
}

void
nw_endservent()
{
	endservent();
}

struct hostent *
nw_gethostent()
{
	return(gethostent());
}

struct netent *
nw_getnetent(void) 
{
    return ((struct netent *) getnetent());
}

struct protoent *
nw_getprotoent(void) 
{
    return ((struct protoent *) getprotoent());
}

struct hostent *
nw_gethostbyname(const char *name)
{
	return(gethostbyname((char*)name));
}

int
nw_gethostname(char *name, int len)
{
    return(gethostname(name, len));
}

struct hostent *
nw_gethostbyaddr(const char *addr, int len, int type)
{
	return(gethostbyaddr((char*)addr, len, type));
}

struct netent *
nw_getnetbyaddr(long net, int type) 
{
	return(getnetbyaddr(net,type));
}

struct netent *
nw_getnetbyname(char *name) 
{
    return (struct netent *)getnetbyname(name);
}

int
nw_getpeername(SOCKET s, struct sockaddr *addr, int *addrlen)
{
	return((int)getpeername(s, addr, addrlen));
}

struct protoent *
nw_getprotobyname(const char *name)
{
	return ((struct protoent *)getprotobyname((char*)name));
}

struct protoent *
nw_getprotobynumber(int num)
{
	return ((struct protoent *)getprotobynumber(num));
}

struct servent *
nw_getservbyname(const char *name, const char *proto)
{
    return (struct servent *)getservbyname((char*)name, (char*)proto);
}


struct servent *
nw_getservbyport(int port, const char *proto)
{
    return (struct servent *)getservbyport(port, (char*)proto);
}

struct servent *
nw_getservent(void) 
{
    return (struct servent *) getservent();
}

void
nw_sethostent(int stayopen)
{
#ifdef HAS_SETHOSTENT
	sethostent(stayopen);
#endif
}

void
nw_setnetent(int stayopen)
{
#ifdef HAS_SETNETENT
	setnetent(stayopen);
#endif
}

void
nw_setprotoent(int stayopen)
{
#ifdef HAS_SETPROTENT
	setprotoent(stayopen);
#endif
}

void
nw_setservent(int stayopen)
{
#ifdef HAS_SETSERVENT
	setservent(stayopen);
#endif
}

int
nw_setsockopt(SOCKET s, int level, int optname, const char* optval, int optlen)
{
	return setsockopt(s, level, optname, (char*)optval, optlen);
}

int
nw_getsockname(SOCKET s, struct sockaddr *addr, int *addrlen)
{
	return getsockname(s, addr, addrlen);
}

int
nw_getsockopt(SOCKET s, int level, int optname, char *optval, int *optlen)
{
	return ((int)getsockopt(s, level, optname, optval, optlen));
}

unsigned long
nw_inet_addr(const char *cp)
{
    return inet_addr((char*)cp);
}

char *
nw_inet_ntoa(struct in_addr in)
{
    return inet_ntoa(in);
}

SOCKET
nw_socket(int af, int type, int protocol)
{
    SOCKET s;

#ifndef USE_SOCKETS_AS_HANDLES
    s = socket(af, type, protocol);
#else
    if((s = socket(af, type, protocol)) == INVALID_SOCKET)
	//errno = WSAGetLastError();
    else
	s = s;
#endif	/* USE_SOCKETS_AS_HANDLES */

    return s;
}

int
nw_listen(SOCKET s, int backlog)
{
    return(listen(s, backlog));
}

int
nw_send(SOCKET s, const char *buf, int len, int flags)
{
	return(send(s,(char*)buf,len,flags));
}

int
nw_recv(SOCKET s, char *buf, int len, int flags)
{
	return (recv(s, buf, len, flags));
}

int
nw_sendto(SOCKET s, const char *buf, int len, int flags,
	     const struct sockaddr *to, int tolen)
{
    return(sendto(s, (char*)buf, len, flags, (struct sockaddr *)to, tolen));
}

int
nw_recvfrom(SOCKET s, char *buf, int len, int flags, struct sockaddr *from, int *fromlen)
{
    int r;
    int frombufsize = *fromlen;

    r = recvfrom(s, buf, len, flags, from, fromlen);
	//Not sure if the is required - chksgp
    if (r && frombufsize == *fromlen)
	(void)nw_getpeername(s, from, fromlen);
    return r;
}

int
nw_select(int nfds, fd_set* rd, fd_set* wr, fd_set* ex, const struct timeval* timeout)
{
	return(select(nfds, rd, wr, ex, (struct timeval*)timeout));
}

int
nw_shutdown(SOCKET s, int how)
{
    return (shutdown(s, how));
}

@


1.1.1.1
log
@stock perl 5.8.0 from CPAN
@
text
@@


1.1.1.2
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d3 1
a3 1
 * Copyright Â© 2001 Novell, Inc. All Rights Reserved.
@

