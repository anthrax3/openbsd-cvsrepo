head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2_BASE:1.1.1.3
	PERL_5_24_2:1.1.1.3
	OPENBSD_6_1:1.1.1.3.0.14
	OPENBSD_6_1_BASE:1.1.1.3
	OPENBSD_6_0:1.1.1.3.0.12
	OPENBSD_6_0_BASE:1.1.1.3
	OPENBSD_5_9:1.1.1.3.0.6
	OPENBSD_5_9_BASE:1.1.1.3
	OPENBSD_5_8:1.1.1.3.0.8
	OPENBSD_5_8_BASE:1.1.1.3
	PERL_5_20_2:1.1.1.3
	OPENBSD_5_7:1.1.1.3.0.2
	OPENBSD_5_7_BASE:1.1.1.3
	PERL_5_20_1:1.1.1.3
	OPENBSD_5_6:1.1.1.3.0.4
	OPENBSD_5_6_BASE:1.1.1.3
	PERL_5_18_2:1.1.1.3
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.2.0.6
	OPENBSD_5_5_BASE:1.1.1.2
	OPENBSD_5_4:1.1.1.2.0.2
	OPENBSD_5_4_BASE:1.1.1.2
	PERL_5_16_3:1.1.1.2
	OPENBSD_5_3:1.1.1.1.0.42
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.40
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.38
	OPENBSD_5_0:1.1.1.1.0.36
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.34
	OPENBSD_4_9_BASE:1.1.1.1
	PERL_5_12_2:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.32
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.28
	OPENBSD_4_7_BASE:1.1.1.1
	PERL_5_10_1:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.30
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.26
	OPENBSD_4_5_BASE:1.1.1.1
	PERL_5_10_0:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.24
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.22
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.20
	OPENBSD_4_2_BASE:1.1.1.1
	OPENBSD_4_1:1.1.1.1.0.18
	OPENBSD_4_1_BASE:1.1.1.1
	OPENBSD_4_0:1.1.1.1.0.16
	OPENBSD_4_0_BASE:1.1.1.1
	PERL_5_8_8:1.1.1.1
	OPENBSD_3_9:1.1.1.1.0.14
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.12
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.10
	OPENBSD_3_7_BASE:1.1.1.1
	PERL_5_8_6:1.1.1.1
	OPENBSD_3_6:1.1.1.1.0.8
	OPENBSD_3_6_BASE:1.1.1.1
	PERL_5_8_5:1.1.1.1
	PERL_5_8_3:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.6
	OPENBSD_3_5_BASE:1.1.1.1
	PERL_5_8_2:1.1.1.1
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	PERL_5_8_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@// @;
expand	@o@;


1.1
date	2002.10.27.22.15.02;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.27.22.15.02;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.03.25.20.09.11;	author sthen;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.03.24.14.59.06;	author afresh1;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/*
 * Copyright © 2001 Novell, Inc. All Rights Reserved.
 *
 * You may distribute under the terms of either the GNU General Public
 * License or the Artistic License, as specified in the README file.
 *
 */

/*
 * FILENAME     :  hashcls.cpp
 * DESCRIPTION  :  Implementation of Equivalent of Hash class, NWPerlHashList and 
					NWPerlKeyHashList
 *                 
 * Author       :  Srivathsa M
 * Date	Created :  July 26 2001
 */

#include "nwhashcls.h"

NWPerlHashList::NWPerlHashList()
{
	//initialize the hash list to null
	for(int i=0;i<BUCKET_SIZE;i++)
		MemListHash[i] = NULL;
	DEBUGPRINT("In constructor\n");
}
			
NWPerlHashList::~NWPerlHashList()
{
	DEBUGPRINT("In destructor\n");
	removeAll();
}

int
NWPerlHashList::insert(void *ldata)
{
	HASHNODE *list = new HASHNODE;
	if (list) {
		list->data = ldata;
		list->next = NULL;
		unsigned long Bucket = ((unsigned long)ldata) % BUCKET_SIZE;
		if (MemListHash[Bucket]) {
			//Elements existing, insert at the beginning
			list->next = MemListHash[Bucket];
			MemListHash[Bucket] = list;
			DEBUGPRINT("Inserted to %d\n",Bucket);
		} else {
			//First element
			MemListHash[Bucket] = list;
			DEBUGPRINT("Inserted first time to %d\n",Bucket);
		}
		return 1;
	} else 
		return 0;
}

int
NWPerlHashList::remove(void *ldata)
{
	unsigned long Bucket = ((unsigned long)ldata) % BUCKET_SIZE;
	HASHNODE *list = MemListHash[Bucket];
	if (list) {
		int found = 0;
		HASHNODE *next =list;
		HASHNODE *prev =NULL;
		do 
		{
			if (list->data != ldata) {
				prev = list;
				list = list->next;
			}
			else {
				found = 1;
				next = list->next;
				/*if(list->data)
				{
					free(list->data);
					list->data = NULL;
				}*/
				//ConsolePrintf ("A:%x;",list->data);
				delete list;
				list = NULL;
				if (prev) {
					prev->next = next;
				} else {
					MemListHash[Bucket]=next;
				}
				DEBUGPRINT("Removed element from %d\n",Bucket);
			}
			ThreadSwitchWithDelay();
		} while(list && !found);
//		if (!found)
//			ConsolePrintf("Couldn;t find %x in Bucket %d\n",ldata,Bucket);
		return(found);
	} 
	return 1;
}


void NWPerlHashList::forAll( register void (*user_fn)(void *, void*), void *data ) const 
{

	for(int i=0; i<BUCKET_SIZE; i++) 
	{
		HASHNODE *next = MemListHash[i];
		while(next)
		{
			HASHNODE *temp = next->next;
			if(next->data)
			{
				DEBUGPRINT("- To remove element from bucket %d\n",i);
	            user_fn( next->data, data );
			}
			next = temp;
			ThreadSwitchWithDelay();
		}
	}
	return ;
};

void NWPerlHashList::removeAll( ) const 
{

	for(int i=0; i<BUCKET_SIZE; i++) 
	{
		HASHNODE *next = MemListHash[i];
		while(next)
		{
			HASHNODE *temp = next->next;
			delete next;
			next = temp;
			ThreadSwitchWithDelay();
		}
	}
	return ;
};

/**
NWPerlKeyHashList::NWPerlKeyHashList()
{
	//initialize the hash list to null
	for(int i=0;i<BUCKET_SIZE;i++)
		MemListHash[i] = NULL;
	DEBUGPRINT("In constructor\n");
}
			
NWPerlKeyHashList::~NWPerlKeyHashList()
{
	DEBUGPRINT("In destructor\n");
	removeAll();
}

int
NWPerlKeyHashList::insert(void *key, void *ldata)
{
	KEYHASHNODE *list = new KEYHASHNODE;
	if (list) {
		list->key = key;
		list->data = ldata;
		list->next = NULL;
		unsigned long Bucket = ((unsigned long)key) % BUCKET_SIZE;
		if (MemListHash[Bucket]) {
			//Elements existing, insert at the beginning
			list->next = MemListHash[Bucket];
			MemListHash[Bucket] = list;
			DEBUGPRINT("Inserted to %d\n",Bucket);
		} else {
			//First element
			MemListHash[Bucket] = list;
			DEBUGPRINT("Inserted first time to %d\n",Bucket);
		}
		return 1;
	} else 
		return 0;
}

int
NWPerlKeyHashList::remove(void *key)
{
	unsigned long Bucket = ((unsigned long)key) % BUCKET_SIZE;
	KEYHASHNODE *list = MemListHash[Bucket];
	if (list) {
		int found = 0;
		KEYHASHNODE *next =list;
		KEYHASHNODE *prev =NULL;
		do 
		{
			if (list->key != key) {
				prev = list;
				list = list->next;
			}
			else {
				found = 1;
				next = list->next;
				delete list;
				list = NULL;
				if (prev) {
					prev->next = next;
				} else {
					MemListHash[Bucket]=next;
				}
				DEBUGPRINT("Removed element from %d\n",Bucket);
			}
		} while(list && !found);
//		if (!found)
//			ConsolePrintf("Couldn;t find %x in Bucket %d\n",key,Bucket);
		return(found);
	} 
	return 1;
}


void NWPerlKeyHashList::forAll( register void (*user_fn)(void *, void*), void *data ) const 
{

	for(int i=0; i<BUCKET_SIZE; i++) 
	{
		KEYHASHNODE *next = MemListHash[i];
		while(next)
		{
			KEYHASHNODE *temp = next->next;
			if(next->data)
			{
				DEBUGPRINT("- To remove element from bucket %d\n",i);
	            user_fn( next->data, data );
			}
			next = temp;
			ThreadSwitchWithDelay();
		}
	}
	return ;
};

int NWPerlKeyHashList::find(void *key,void **pData)
{
	for(int i=0; i<BUCKET_SIZE; i++) 
	{
		KEYHASHNODE *next = MemListHash[i];
		while(next)
		{
			if(next->key==key)
			{
				*pData=next->data;
				return 1;
			}
			next = next->next;
			ThreadSwitchWithDelay();
		}
	}
	return 0;
}

void NWPerlKeyHashList::removeAll( ) const 
{

	for(int i=0; i<BUCKET_SIZE; i++) 
	{
		KEYHASHNODE *next = MemListHash[i];
		while(next)
		{
			KEYHASHNODE *temp = next->next;
			delete next;
			next = temp;
			ThreadSwitchWithDelay();
		}
	}
	return ;
};
**/
@


1.1.1.1
log
@stock perl 5.8.0 from CPAN
@
text
@@


1.1.1.2
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d2 1
a2 1
 * Copyright Â© 2001 Novell, Inc. All Rights Reserved.
@


1.1.1.3
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d100 1
a100 1
void NWPerlHashList::forAll( void (*user_fn)(void *, void*), void *data ) const
d213 1
a213 1
void NWPerlKeyHashList::forAll( void (*user_fn)(void *, void*), void *data ) const
@


