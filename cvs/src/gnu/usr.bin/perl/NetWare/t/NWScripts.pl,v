head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2:1.1.1.2.0.14
	OPENBSD_6_2_BASE:1.1.1.2
	PERL_5_24_2:1.1.1.2
	OPENBSD_6_1:1.1.1.2.0.18
	OPENBSD_6_1_BASE:1.1.1.2
	OPENBSD_6_0:1.1.1.2.0.16
	OPENBSD_6_0_BASE:1.1.1.2
	OPENBSD_5_9:1.1.1.2.0.10
	OPENBSD_5_9_BASE:1.1.1.2
	OPENBSD_5_8:1.1.1.2.0.12
	OPENBSD_5_8_BASE:1.1.1.2
	PERL_5_20_2:1.1.1.2
	OPENBSD_5_7:1.1.1.2.0.4
	OPENBSD_5_7_BASE:1.1.1.2
	PERL_5_20_1:1.1.1.2
	OPENBSD_5_6:1.1.1.2.0.8
	OPENBSD_5_6_BASE:1.1.1.2
	PERL_5_18_2:1.1.1.2
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.2.0.6
	OPENBSD_5_5_BASE:1.1.1.2
	OPENBSD_5_4:1.1.1.2.0.2
	OPENBSD_5_4_BASE:1.1.1.2
	PERL_5_16_3:1.1.1.2
	OPENBSD_5_3:1.1.1.1.0.42
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.40
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.38
	OPENBSD_5_0:1.1.1.1.0.36
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.34
	OPENBSD_4_9_BASE:1.1.1.1
	PERL_5_12_2:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.32
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.28
	OPENBSD_4_7_BASE:1.1.1.1
	PERL_5_10_1:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.30
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.26
	OPENBSD_4_5_BASE:1.1.1.1
	PERL_5_10_0:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.24
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.22
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.20
	OPENBSD_4_2_BASE:1.1.1.1
	OPENBSD_4_1:1.1.1.1.0.18
	OPENBSD_4_1_BASE:1.1.1.1
	OPENBSD_4_0:1.1.1.1.0.16
	OPENBSD_4_0_BASE:1.1.1.1
	PERL_5_8_8:1.1.1.1
	OPENBSD_3_9:1.1.1.1.0.14
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.12
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.10
	OPENBSD_3_7_BASE:1.1.1.1
	PERL_5_8_6:1.1.1.1
	OPENBSD_3_6:1.1.1.1.0.8
	OPENBSD_3_6_BASE:1.1.1.1
	PERL_5_8_5:1.1.1.1
	PERL_5_8_3:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.6
	OPENBSD_3_5_BASE:1.1.1.1
	PERL_5_8_2:1.1.1.1
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	PERL_5_8_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.1
date	2002.10.27.22.15.02;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.27.22.15.02;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.03.25.20.09.11;	author sthen;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@

print "\nGenerating automated scripts for NetWare...\n\n\n";


use File::Basename;
use File::Copy;

chdir '/perl/scripts/';
$DirName = "t";

# These scripts have problems (either abend or hang) as of now (11 May 2001).
# So, they are commented out in the corresponding auto scripts, io.pl and lib.pl
@@ScriptsNotUsed = ("t/io/openpid.t", "t/lib/filehandle.t", "t/lib/memoize/t/expire_module_t.t", "t/lib/NEXT/t/next.t", "t/lib/Math/BigInt/t/require.t", "t/ext/B/t/debug.t", "t/lib/IPC/Open3.t", "t/ext/B/t/showlex.t", "t/op/subst_wamp.t", "t/uni/upper.t", "t/lib/Net/t/ftp.t", "t/op/sort.t", "t/ext/POSIX/t/posix.t", "t/lib/CPAN/t/loadme.t", "t/lib/CPAN/t/vcmp.t");

opendir(DIR, $DirName);
@@Dirs = readdir(DIR);
close(DIR);
foreach $DirItem(@@Dirs)
{
	$DirItem1 = $DirName."/".$DirItem;
	push @@DirNames, $DirItem1;	# All items under  $DirName  folder is copied into an array.

	if(-d $DirItem1)
	{	# If an item is a folder, then open it further.

		# Intemediary automated script like base.pl, lib.pl, cmd.pl etc.
		$IntAutoScript = "t/".$DirItem.".pl";

		# Open once in write mode since later files are opened in append mode,
		# and if there already exists a file with the same name, all further opens
		# will append to that file!!
		open(FHW, "> $IntAutoScript") or die "Unable to open the file,  $IntAutoScript  for writing.\n";
		seek(FHW, 0, 0);	# seek to the beginning of the file.
		close FHW;			# close the file.
	}
}


print "Generating  t/nwauto.pl ...\n\n\n";

open(FHWA, "> t/nwauto.pl") or die "Unable to open the file,  t/nwauto.pl  for writing.\n";
seek(FHWA, 0, 0);	# seek to the beginning of the file.

$version = sprintf("%vd",$^V);
print FHWA "\n\nprint \"Automated Unit Testing of Perl$version for NetWare\\n\\n\\n\"\;\n\n\n";


foreach $FileName(@@DirNames)
{
	$index = 0;
	if(-d $FileName)
	{	# If an item is a folder, then open it further.

		$dir = dirname($FileName);		# Get the folder name

		foreach $DirItem1(@@Dirs)
		{
			$DirItem2 = $DirItem1;
			if($FileName =~ m/$DirItem2/)
			{
				$DirItem = $DirItem1;

				# Intemediary automated script like base.pl, lib.pl, cmd.pl etc.
				$IntAutoScript = "t/".$DirItem.".pl";
			}
		}

		# Write into the intermediary auto script.
		open(FHW, ">> $IntAutoScript") or die "Unable to open the file,  $IntAutoScript  for appending.\n";
		seek(FHW, 0, 2);	# seek to the end of the file.

		$pos = tell(FHW);
		if($pos <= 0)
		{
			print "Generating  $IntAutoScript...\n";
			print FHW "\n\nprint \"Testing  $DirItem  folder:\\n\\n\\n\"\;\n\n\n";
		}

		opendir(SUBDIR, $FileName);
		@@SubDirs = readdir(SUBDIR);
		close(SUBDIR);
		foreach $SubFileName(@@SubDirs)
		{
			$SubFileName = $FileName."/".$SubFileName;
			if(-d $SubFileName)
			{
				push @@DirNames, $SubFileName;	# If sub-folder, push it into the array.
			}
			else
			{
				&Process_File($SubFileName);	# If file, process it.
			}

			$index++;
		}

		close FHW;			# close the file.

		if($index <= 0)
		{
			# The folder is empty and delete the corresponding '.pl' file.
			unlink($IntAutoScript);
			print "Deleted  $IntAutoScript  since it corresponded to an empty folder.\n";
		}
		else
		{
			if($pos <= 0)
			{	# This logic to make sure that it is written only once.
				# Only if something is written into the intermediary auto script,
				# only then make an entry of the intermediary auto script in  nwauto.pl
				print FHWA "print \`perl $IntAutoScript\`\;\n";
				print FHWA "print \"\\n\\n\\n\"\;\n\n";
			}
		}
	}
	else
	{
		if(-f $FileName)
		{
			$dir = dirname($FileName);		# Get the folder name
			$base = basename($FileName);	# Get the base name
			($base, $dir, $ext) = fileparse($FileName, '\..*');	# Get the extension of the file passed.
			
			# Do the processing only if the file has '.t' extension.
			if($ext eq '.t')
			{
				print FHWA "print \`perl $FileName\`\;\n";
				print FHWA "print \"\\n\\n\\n\"\;\n\n";
			}
		}
	}
}


## Below adds the ending comments into all the intermediary auto scripts:

opendir(DIR, $DirName);
@@Dirs = readdir(DIR);
close(DIR);
foreach $DirItem(@@Dirs)
{
	$index = 0;

	$FileName = $DirName."/".$DirItem;
	if(-d $FileName)
	{	# If an item is a folder, then open it further.

		opendir(SUBDIR, $FileName);
		@@SubDirs = readdir(SUBDIR);
		close(SUBDIR);

		# To not to write into the file if the corresponding folder was empty.
		foreach $SubDir(@@SubDirs)
		{
			$index++;
		}

		if($index > 0)
		{
			# The folder not empty.

			# Intemediary automated script like base.pl, lib.pl, cmd.pl etc.
			$IntAutoScript = "t/".$DirItem.".pl";

			# Write into the intermediary auto script.
			open(FHW, ">> $IntAutoScript") or die "Unable to open the file,  $IntAutoScript  for appending.\n";
			seek(FHW, 0, 2);	# seek to the end of the file.

			# Write into the intermediary auto script.
			print FHW "\nprint \"Testing of  $DirItem  folder done!\\n\\n\"\;\n\n";

			close FHW;			# close the file.
		}
	}
}


# Write into  nwauto.pl
print FHWA "\nprint \"Automated Unit Testing of Perl$version for NetWare done!\\n\\n\"\;\n\n";

close FHWA;			# close the file.

print "\n\nGeneration of  t/nwauto.pl  Done!\n\n";

print "\nGeneration of automated scripts for NetWare DONE!\n";




# Process the file.
sub Process_File
{
	local($FileToProcess) = @@_;		# File name.
	local($Script) = 0;
	local($HeadCut) = 0;

	## For example:
	## If the value of $FileToProcess is '/perl/scripts/t/pragma/warnings.t', then
		## $dir1 = '/perl/scripts/t/pragma/'
		## $base1 = 'warnings'
		## $ext1 = '.t'
	$dir1 = dirname($FileToProcess);	# Get the folder name
	$base1 = basename($FileToProcess);	# Get the base name
	($base1, $dir1, $ext1) = fileparse($FileToProcess, '\..*');	# Get the extension of the file passed.

	# Do the processing only if the file has '.t' extension.
	if($ext1 eq '.t')
	{
		foreach $Script(@@ScriptsNotUsed)
		{
			# The variables are converted to lower case before they are compared.
			# This is done to remove the case-sensitive comparison done by 'eq'.
			$Script1 = lc($Script);
			$FileToProcess1 = lc($FileToProcess);
			if($Script1 eq $FileToProcess1)
			{
				$HeadCut = 1;
			}
		}

		if($HeadCut)
		{
			# Write into the intermediary auto script.
			print FHW "=head\n";
		}

		# Write into the intermediary auto script.
		print FHW "print \"Testing  $base1"."$ext1:\\n\\n\"\;\n";
		print FHW "print \`perl $FileToProcess\`\;\n";	# Write the changed array into the file.
		print FHW "print \"\\n\\n\\n\"\;\n";

		if($HeadCut)
		{
			# Write into the intermediary auto script.
			print FHW "=cut\n";
		}

		$HeadCut = 0;
		print FHW "\n";
	}
}

@


1.1.1.1
log
@stock perl 5.8.0 from CPAN
@
text
@@


1.1.1.2
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d27 1
a27 1
		# Intermediary automated script like base.pl, lib.pl, cmd.pl etc.
d64 1
a64 1
				# Intermediary automated script like base.pl, lib.pl, cmd.pl etc.
d163 1
a163 1
			# Intermediary automated script like base.pl, lib.pl, cmd.pl etc.
@

