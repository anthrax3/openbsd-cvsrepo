head	1.2;
access;
symbols
	OPENBSD_6_1:1.2.0.4
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.10.0.10
	OPENBSD_6_0_BASE:1.1.1.10
	OPENBSD_5_9:1.1.1.10.0.4
	OPENBSD_5_9_BASE:1.1.1.10
	OPENBSD_5_8:1.1.1.10.0.6
	OPENBSD_5_8_BASE:1.1.1.10
	PERL_5_20_2:1.1.1.10
	OPENBSD_5_7:1.1.1.10.0.2
	OPENBSD_5_7_BASE:1.1.1.10
	PERL_5_20_1:1.1.1.10
	OPENBSD_5_6:1.1.1.9.0.4
	OPENBSD_5_6_BASE:1.1.1.9
	PERL_5_18_2:1.1.1.9
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.8.0.6
	OPENBSD_5_5_BASE:1.1.1.8
	OPENBSD_5_4:1.1.1.8.0.2
	OPENBSD_5_4_BASE:1.1.1.8
	PERL_5_16_3:1.1.1.8
	OPENBSD_5_3:1.1.1.7.0.10
	OPENBSD_5_3_BASE:1.1.1.7
	OPENBSD_5_2:1.1.1.7.0.8
	OPENBSD_5_2_BASE:1.1.1.7
	OPENBSD_5_1_BASE:1.1.1.7
	OPENBSD_5_1:1.1.1.7.0.6
	OPENBSD_5_0:1.1.1.7.0.4
	OPENBSD_5_0_BASE:1.1.1.7
	OPENBSD_4_9:1.1.1.7.0.2
	OPENBSD_4_9_BASE:1.1.1.7
	PERL_5_12_2:1.1.1.7
	OPENBSD_4_8:1.1.1.6.0.4
	OPENBSD_4_8_BASE:1.1.1.6
	OPENBSD_4_7:1.1.1.6.0.2
	OPENBSD_4_7_BASE:1.1.1.6
	PERL_5_10_1:1.1.1.6
	OPENBSD_4_6:1.1.1.5.0.6
	OPENBSD_4_6_BASE:1.1.1.5
	OPENBSD_4_5:1.1.1.5.0.2
	OPENBSD_4_5_BASE:1.1.1.5
	PERL_5_10_0:1.1.1.5
	OPENBSD_4_4:1.1.1.4.0.10
	OPENBSD_4_4_BASE:1.1.1.4
	OPENBSD_4_3:1.1.1.4.0.8
	OPENBSD_4_3_BASE:1.1.1.4
	OPENBSD_4_2:1.1.1.4.0.6
	OPENBSD_4_2_BASE:1.1.1.4
	OPENBSD_4_1:1.1.1.4.0.4
	OPENBSD_4_1_BASE:1.1.1.4
	OPENBSD_4_0:1.1.1.4.0.2
	OPENBSD_4_0_BASE:1.1.1.4
	PERL_5_8_8:1.1.1.4
	OPENBSD_3_9:1.1.1.3.0.6
	OPENBSD_3_9_BASE:1.1.1.3
	OPENBSD_3_8:1.1.1.3.0.4
	OPENBSD_3_8_BASE:1.1.1.3
	OPENBSD_3_7:1.1.1.3.0.2
	OPENBSD_3_7_BASE:1.1.1.3
	PERL_5_8_6:1.1.1.3
	OPENBSD_3_6:1.1.1.2.0.4
	OPENBSD_3_6_BASE:1.1.1.2
	PERL_5_8_5:1.1.1.2
	PERL_5_8_3:1.1.1.2
	OPENBSD_3_5:1.1.1.2.0.2
	OPENBSD_3_5_BASE:1.1.1.2
	PERL_5_8_2:1.1.1.2
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	PERL_5_8_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.2
date	2017.02.05.00.31.53;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2002.10.27.22.14.50;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.27.22.14.50;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.12.03.02.43.36;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2005.01.15.21.16.34;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2006.03.28.18.47.41;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2008.09.29.17.18.09;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2009.10.12.18.10.34;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2010.09.24.14.48.33;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2013.03.25.20.06.37;	author sthen;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2014.03.24.14.58.47;	author afresh1;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2014.11.17.20.52.39;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@/* -*- buffer-read-only: t -*-
 *
 *    reentr.c
 *
 *    Copyright (C) 2002, 2003, 2005, 2006, 2007 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 * !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
 * This file is built by regen/reentr.pl from data in regen/reentr.pl.
 * Any changes made here will be lost!
 */

/*
 * "Saruman," I said, standing away from him, "only one hand at a time can
 *  wield the One, and you know that well, so do not trouble to say we!"
 *
 *     [p.260 of _The Lord of the Rings_, II/ii: "The Council of Elrond"]
 */

/*
 * This file contains a collection of automatically created wrappers
 * (created by running reentr.pl) for reentrant (thread-safe) versions of
 * various library calls, such as getpwent_r.  The wrapping is done so
 * that other files like pp_sys.c calling those library functions need not
 * care about the differences between various platforms' idiosyncrasies
 * regarding these reentrant interfaces.  
 */

#include "EXTERN.h"
#define PERL_IN_REENTR_C
#include "perl.h"
#include "reentr.h"

void
Perl_reentrant_size(pTHX) {
	PERL_UNUSED_CONTEXT;
#ifdef USE_REENTRANT_API
#define REENTRANTSMALLSIZE	 256	/* Make something up. */
#define REENTRANTUSUALSIZE	4096	/* Make something up. */
#ifdef HAS_ASCTIME_R
	PL_reentrant_buffer->_asctime_size = REENTRANTSMALLSIZE;
#endif /* HAS_ASCTIME_R */
#ifdef HAS_CRYPT_R
#endif /* HAS_CRYPT_R */
#ifdef HAS_CTIME_R
	PL_reentrant_buffer->_ctime_size = REENTRANTSMALLSIZE;
#endif /* HAS_CTIME_R */
#ifdef HAS_GETGRNAM_R
#   if defined(HAS_SYSCONF) && defined(_SC_GETGR_R_SIZE_MAX) && !defined(__GLIBC__)
	PL_reentrant_buffer->_grent_size = sysconf(_SC_GETGR_R_SIZE_MAX);
	if (PL_reentrant_buffer->_grent_size == (size_t) -1)
		PL_reentrant_buffer->_grent_size = REENTRANTUSUALSIZE;
#   else
#       if defined(__osf__) && defined(__alpha) && defined(SIABUFSIZ)
	PL_reentrant_buffer->_grent_size = SIABUFSIZ;
#       else
#           ifdef __sgi
	PL_reentrant_buffer->_grent_size = BUFSIZ;
#           else
	PL_reentrant_buffer->_grent_size = REENTRANTUSUALSIZE;
#           endif
#       endif
#   endif 
#endif /* HAS_GETGRNAM_R */
#ifdef HAS_GETHOSTBYNAME_R
#if   !(GETHOSTBYNAME_R_PROTO == REENTRANT_PROTO_I_CSD)
	PL_reentrant_buffer->_hostent_size = REENTRANTUSUALSIZE;
#endif
#endif /* HAS_GETHOSTBYNAME_R */
#ifdef HAS_GETLOGIN_R
	PL_reentrant_buffer->_getlogin_size = REENTRANTSMALLSIZE;
#endif /* HAS_GETLOGIN_R */
#ifdef HAS_GETNETBYNAME_R
#if   !(GETNETBYNAME_R_PROTO == REENTRANT_PROTO_I_CSD)
	PL_reentrant_buffer->_netent_size = REENTRANTUSUALSIZE;
#endif
#endif /* HAS_GETNETBYNAME_R */
#ifdef HAS_GETPROTOBYNAME_R
#if   !(GETPROTOBYNAME_R_PROTO == REENTRANT_PROTO_I_CSD)
	PL_reentrant_buffer->_protoent_size = REENTRANTUSUALSIZE;
#endif
#endif /* HAS_GETPROTOBYNAME_R */
#ifdef HAS_GETPWNAM_R
#   if defined(HAS_SYSCONF) && defined(_SC_GETPW_R_SIZE_MAX) && !defined(__GLIBC__)
	PL_reentrant_buffer->_pwent_size = sysconf(_SC_GETPW_R_SIZE_MAX);
	if (PL_reentrant_buffer->_pwent_size == (size_t) -1)
		PL_reentrant_buffer->_pwent_size = REENTRANTUSUALSIZE;
#   else
#       if defined(__osf__) && defined(__alpha) && defined(SIABUFSIZ)
	PL_reentrant_buffer->_pwent_size = SIABUFSIZ;
#       else
#           ifdef __sgi
	PL_reentrant_buffer->_pwent_size = BUFSIZ;
#           else
	PL_reentrant_buffer->_pwent_size = REENTRANTUSUALSIZE;
#           endif
#       endif
#   endif 
#endif /* HAS_GETPWNAM_R */
#ifdef HAS_GETSERVBYNAME_R
#if   !(GETSERVBYNAME_R_PROTO == REENTRANT_PROTO_I_CCSD)
	PL_reentrant_buffer->_servent_size = REENTRANTUSUALSIZE;
#endif
#endif /* HAS_GETSERVBYNAME_R */
#ifdef HAS_GETSPNAM_R
#   if defined(HAS_SYSCONF) && defined(_SC_GETPW_R_SIZE_MAX) && !defined(__GLIBC__)
	PL_reentrant_buffer->_spent_size = sysconf(_SC_GETPW_R_SIZE_MAX);
	if (PL_reentrant_buffer->_spent_size == (size_t) -1)
		PL_reentrant_buffer->_spent_size = REENTRANTUSUALSIZE;
#   else
#       if defined(__osf__) && defined(__alpha) && defined(SIABUFSIZ)
	PL_reentrant_buffer->_spent_size = SIABUFSIZ;
#       else
#           ifdef __sgi
	PL_reentrant_buffer->_spent_size = BUFSIZ;
#           else
	PL_reentrant_buffer->_spent_size = REENTRANTUSUALSIZE;
#           endif
#       endif
#   endif 
#endif /* HAS_GETSPNAM_R */
#ifdef HAS_READDIR_R
	/* This is the size Solaris recommends.
	 * (though we go static, should use pathconf() instead) */
	PL_reentrant_buffer->_readdir_size = sizeof(struct dirent) + MAXPATHLEN + 1;
#endif /* HAS_READDIR_R */
#ifdef HAS_READDIR64_R
	/* This is the size Solaris recommends.
	 * (though we go static, should use pathconf() instead) */
	PL_reentrant_buffer->_readdir64_size = sizeof(struct dirent64) + MAXPATHLEN + 1;
#endif /* HAS_READDIR64_R */
#ifdef HAS_SETLOCALE_R
	PL_reentrant_buffer->_setlocale_size = REENTRANTSMALLSIZE;
#endif /* HAS_SETLOCALE_R */
#ifdef HAS_STRERROR_R
	PL_reentrant_buffer->_strerror_size = REENTRANTSMALLSIZE;
#endif /* HAS_STRERROR_R */
#ifdef HAS_TTYNAME_R
	PL_reentrant_buffer->_ttyname_size = REENTRANTSMALLSIZE;
#endif /* HAS_TTYNAME_R */

#endif /* USE_REENTRANT_API */
}

void
Perl_reentrant_init(pTHX) {
	PERL_UNUSED_CONTEXT;
#ifdef USE_REENTRANT_API
	Newx(PL_reentrant_buffer, 1, REENTR);
	Perl_reentrant_size(aTHX);
#ifdef HAS_ASCTIME_R
	Newx(PL_reentrant_buffer->_asctime_buffer, PL_reentrant_buffer->_asctime_size, char);
#endif /* HAS_ASCTIME_R */
#ifdef HAS_CRYPT_R
#if CRYPT_R_PROTO != REENTRANT_PROTO_B_CCD
	PL_reentrant_buffer->_crypt_struct_buffer = 0;
#endif
#endif /* HAS_CRYPT_R */
#ifdef HAS_CTIME_R
	Newx(PL_reentrant_buffer->_ctime_buffer, PL_reentrant_buffer->_ctime_size, char);
#endif /* HAS_CTIME_R */
#ifdef HAS_GETGRNAM_R
#   ifdef USE_GRENT_FPTR
	PL_reentrant_buffer->_grent_fptr = NULL;
#   endif
	Newx(PL_reentrant_buffer->_grent_buffer, PL_reentrant_buffer->_grent_size, char);
#endif /* HAS_GETGRNAM_R */
#ifdef HAS_GETHOSTBYNAME_R
#if   !(GETHOSTBYNAME_R_PROTO == REENTRANT_PROTO_I_CSD)
	Newx(PL_reentrant_buffer->_hostent_buffer, PL_reentrant_buffer->_hostent_size, char);
#endif
#endif /* HAS_GETHOSTBYNAME_R */
#ifdef HAS_GETLOGIN_R
	Newx(PL_reentrant_buffer->_getlogin_buffer, PL_reentrant_buffer->_getlogin_size, char);
#endif /* HAS_GETLOGIN_R */
#ifdef HAS_GETNETBYNAME_R
#if   !(GETNETBYNAME_R_PROTO == REENTRANT_PROTO_I_CSD)
	Newx(PL_reentrant_buffer->_netent_buffer, PL_reentrant_buffer->_netent_size, char);
#endif
#endif /* HAS_GETNETBYNAME_R */
#ifdef HAS_GETPROTOBYNAME_R
#if   !(GETPROTOBYNAME_R_PROTO == REENTRANT_PROTO_I_CSD)
	Newx(PL_reentrant_buffer->_protoent_buffer, PL_reentrant_buffer->_protoent_size, char);
#endif
#endif /* HAS_GETPROTOBYNAME_R */
#ifdef HAS_GETPWNAM_R
#   ifdef USE_PWENT_FPTR
	PL_reentrant_buffer->_pwent_fptr = NULL;
#   endif
	Newx(PL_reentrant_buffer->_pwent_buffer, PL_reentrant_buffer->_pwent_size, char);
#endif /* HAS_GETPWNAM_R */
#ifdef HAS_GETSERVBYNAME_R
#if   !(GETSERVBYNAME_R_PROTO == REENTRANT_PROTO_I_CCSD)
	Newx(PL_reentrant_buffer->_servent_buffer, PL_reentrant_buffer->_servent_size, char);
#endif
#endif /* HAS_GETSERVBYNAME_R */
#ifdef HAS_GETSPNAM_R
#   ifdef USE_SPENT_FPTR
	PL_reentrant_buffer->_spent_fptr = NULL;
#   endif
	Newx(PL_reentrant_buffer->_spent_buffer, PL_reentrant_buffer->_spent_size, char);
#endif /* HAS_GETSPNAM_R */
#ifdef HAS_READDIR_R
	PL_reentrant_buffer->_readdir_struct = (struct dirent*)safemalloc(PL_reentrant_buffer->_readdir_size);
#endif /* HAS_READDIR_R */
#ifdef HAS_READDIR64_R
	PL_reentrant_buffer->_readdir64_struct = (struct dirent64*)safemalloc(PL_reentrant_buffer->_readdir64_size);
#endif /* HAS_READDIR64_R */
#ifdef HAS_SETLOCALE_R
	Newx(PL_reentrant_buffer->_setlocale_buffer, PL_reentrant_buffer->_setlocale_size, char);
#endif /* HAS_SETLOCALE_R */
#ifdef HAS_STRERROR_R
	Newx(PL_reentrant_buffer->_strerror_buffer, PL_reentrant_buffer->_strerror_size, char);
#endif /* HAS_STRERROR_R */
#ifdef HAS_TTYNAME_R
	Newx(PL_reentrant_buffer->_ttyname_buffer, PL_reentrant_buffer->_ttyname_size, char);
#endif /* HAS_TTYNAME_R */

#endif /* USE_REENTRANT_API */
}

void
Perl_reentrant_free(pTHX) {
	PERL_UNUSED_CONTEXT;
#ifdef USE_REENTRANT_API
#ifdef HAS_ASCTIME_R
	Safefree(PL_reentrant_buffer->_asctime_buffer);
#endif /* HAS_ASCTIME_R */
#ifdef HAS_CRYPT_R
#if CRYPT_R_PROTO != REENTRANT_PROTO_B_CCD
	Safefree(PL_reentrant_buffer->_crypt_struct_buffer);
#endif
#endif /* HAS_CRYPT_R */
#ifdef HAS_CTIME_R
	Safefree(PL_reentrant_buffer->_ctime_buffer);
#endif /* HAS_CTIME_R */
#ifdef HAS_GETGRNAM_R
	Safefree(PL_reentrant_buffer->_grent_buffer);
#endif /* HAS_GETGRNAM_R */
#ifdef HAS_GETHOSTBYNAME_R
#if   !(GETHOSTBYNAME_R_PROTO == REENTRANT_PROTO_I_CSD)
	Safefree(PL_reentrant_buffer->_hostent_buffer);
#endif
#endif /* HAS_GETHOSTBYNAME_R */
#ifdef HAS_GETLOGIN_R
	Safefree(PL_reentrant_buffer->_getlogin_buffer);
#endif /* HAS_GETLOGIN_R */
#ifdef HAS_GETNETBYNAME_R
#if   !(GETNETBYNAME_R_PROTO == REENTRANT_PROTO_I_CSD)
	Safefree(PL_reentrant_buffer->_netent_buffer);
#endif
#endif /* HAS_GETNETBYNAME_R */
#ifdef HAS_GETPROTOBYNAME_R
#if   !(GETPROTOBYNAME_R_PROTO == REENTRANT_PROTO_I_CSD)
	Safefree(PL_reentrant_buffer->_protoent_buffer);
#endif
#endif /* HAS_GETPROTOBYNAME_R */
#ifdef HAS_GETPWNAM_R
	Safefree(PL_reentrant_buffer->_pwent_buffer);
#endif /* HAS_GETPWNAM_R */
#ifdef HAS_GETSERVBYNAME_R
#if   !(GETSERVBYNAME_R_PROTO == REENTRANT_PROTO_I_CCSD)
	Safefree(PL_reentrant_buffer->_servent_buffer);
#endif
#endif /* HAS_GETSERVBYNAME_R */
#ifdef HAS_GETSPNAM_R
	Safefree(PL_reentrant_buffer->_spent_buffer);
#endif /* HAS_GETSPNAM_R */
#ifdef HAS_READDIR_R
	Safefree(PL_reentrant_buffer->_readdir_struct);
#endif /* HAS_READDIR_R */
#ifdef HAS_READDIR64_R
	Safefree(PL_reentrant_buffer->_readdir64_struct);
#endif /* HAS_READDIR64_R */
#ifdef HAS_SETLOCALE_R
	Safefree(PL_reentrant_buffer->_setlocale_buffer);
#endif /* HAS_SETLOCALE_R */
#ifdef HAS_STRERROR_R
	Safefree(PL_reentrant_buffer->_strerror_buffer);
#endif /* HAS_STRERROR_R */
#ifdef HAS_TTYNAME_R
	Safefree(PL_reentrant_buffer->_ttyname_buffer);
#endif /* HAS_TTYNAME_R */

	Safefree(PL_reentrant_buffer);
#endif /* USE_REENTRANT_API */
}

void*
Perl_reentrant_retry(const char *f, ...)
{
    void *retptr = NULL;
    va_list ap;
#ifdef USE_REENTRANT_API
    dTHX;
    /* Easier to special case this here than in embed.pl. (Look at what it
       generates for proto.h) */
    PERL_ARGS_ASSERT_REENTRANT_RETRY;
#endif
    va_start(ap, f);
    {
#ifdef USE_REENTRANT_API
#  if defined(USE_HOSTENT_BUFFER) || defined(USE_GRENT_BUFFER) || defined(USE_NETENT_BUFFER) || defined(USE_PWENT_BUFFER) || defined(USE_PROTOENT_BUFFER) || defined(USE_SERVENT_BUFFER)
    void *p0;
#  endif
#  if defined(USE_SERVENT_BUFFER)
    void *p1;
#  endif
#  if defined(USE_HOSTENT_BUFFER)
    size_t asize;
#  endif
#  if defined(USE_HOSTENT_BUFFER) || defined(USE_NETENT_BUFFER) || defined(USE_PROTOENT_BUFFER) || defined(USE_SERVENT_BUFFER)
    int anint;
#  endif

    switch (PL_op->op_type) {
#ifdef USE_HOSTENT_BUFFER
    case OP_GHBYADDR:
    case OP_GHBYNAME:
    case OP_GHOSTENT:
	{
#ifdef PERL_REENTRANT_MAXSIZE
	    if (PL_reentrant_buffer->_hostent_size <=
		PERL_REENTRANT_MAXSIZE / 2)
#endif
	    {
		PL_reentrant_buffer->_hostent_size *= 2;
		Renew(PL_reentrant_buffer->_hostent_buffer,
		      PL_reentrant_buffer->_hostent_size, char);
		switch (PL_op->op_type) {
	        case OP_GHBYADDR:
		    p0    = va_arg(ap, void *);
		    asize = va_arg(ap, size_t);
		    anint  = va_arg(ap, int);
		    retptr = gethostbyaddr(p0, asize, anint); break;
	        case OP_GHBYNAME:
		    p0 = va_arg(ap, void *);
		    retptr = gethostbyname((char *)p0); break;
	        case OP_GHOSTENT:
		    retptr = gethostent(); break;
	        default:
		    SETERRNO(ERANGE, LIB_INVARG);
		    break;
	        }
	    }
	}
	break;
#endif
#ifdef USE_GRENT_BUFFER
    case OP_GGRNAM:
    case OP_GGRGID:
    case OP_GGRENT:
	{
#ifdef PERL_REENTRANT_MAXSIZE
	    if (PL_reentrant_buffer->_grent_size <=
		PERL_REENTRANT_MAXSIZE / 2)
#endif
	    {
		Gid_t gid;
		PL_reentrant_buffer->_grent_size *= 2;
		Renew(PL_reentrant_buffer->_grent_buffer,
		      PL_reentrant_buffer->_grent_size, char);
		switch (PL_op->op_type) {
	        case OP_GGRNAM:
		    p0 = va_arg(ap, void *);
		    retptr = getgrnam((char *)p0); break;
	        case OP_GGRGID:
#if Gid_t_size < INTSIZE
		    gid = (Gid_t)va_arg(ap, int);
#else
		    gid = va_arg(ap, Gid_t);
#endif
		    retptr = getgrgid(gid); break;
	        case OP_GGRENT:
		    retptr = getgrent(); break;
	        default:
		    SETERRNO(ERANGE, LIB_INVARG);
		    break;
	        }
	    }
	}
	break;
#endif
#ifdef USE_NETENT_BUFFER
    case OP_GNBYADDR:
    case OP_GNBYNAME:
    case OP_GNETENT:
	{
#ifdef PERL_REENTRANT_MAXSIZE
	    if (PL_reentrant_buffer->_netent_size <=
		PERL_REENTRANT_MAXSIZE / 2)
#endif
	    {
		Netdb_net_t net;
		PL_reentrant_buffer->_netent_size *= 2;
		Renew(PL_reentrant_buffer->_netent_buffer,
		      PL_reentrant_buffer->_netent_size, char);
		switch (PL_op->op_type) {
	        case OP_GNBYADDR:
		    net = va_arg(ap, Netdb_net_t);
		    anint = va_arg(ap, int);
		    retptr = getnetbyaddr(net, anint); break;
	        case OP_GNBYNAME:
		    p0 = va_arg(ap, void *);
		    retptr = getnetbyname((char *)p0); break;
	        case OP_GNETENT:
		    retptr = getnetent(); break;
	        default:
		    SETERRNO(ERANGE, LIB_INVARG);
		    break;
	        }
	    }
	}
	break;
#endif
#ifdef USE_PWENT_BUFFER
    case OP_GPWNAM:
    case OP_GPWUID:
    case OP_GPWENT:
	{
#ifdef PERL_REENTRANT_MAXSIZE
	    if (PL_reentrant_buffer->_pwent_size <=
		PERL_REENTRANT_MAXSIZE / 2)
#endif
	    {
		Uid_t uid;
		PL_reentrant_buffer->_pwent_size *= 2;
		Renew(PL_reentrant_buffer->_pwent_buffer,
		      PL_reentrant_buffer->_pwent_size, char);
		switch (PL_op->op_type) {
	        case OP_GPWNAM:
		    p0 = va_arg(ap, void *);
		    retptr = getpwnam((char *)p0); break;
	        case OP_GPWUID:
#if Uid_t_size < INTSIZE
		    uid = (Uid_t)va_arg(ap, int);
#else
		    uid = va_arg(ap, Uid_t);
#endif
		    retptr = getpwuid(uid); break;
#if defined(HAS_GETPWENT) || defined(HAS_GETPWENT_R)
	        case OP_GPWENT:
		    retptr = getpwent(); break;
#endif
	        default:
		    SETERRNO(ERANGE, LIB_INVARG);
		    break;
	        }
	    }
	}
	break;
#endif
#ifdef USE_PROTOENT_BUFFER
    case OP_GPBYNAME:
    case OP_GPBYNUMBER:
    case OP_GPROTOENT:
	{
#ifdef PERL_REENTRANT_MAXSIZE
	    if (PL_reentrant_buffer->_protoent_size <=
		PERL_REENTRANT_MAXSIZE / 2)
#endif
	    {
		PL_reentrant_buffer->_protoent_size *= 2;
		Renew(PL_reentrant_buffer->_protoent_buffer,
		      PL_reentrant_buffer->_protoent_size, char);
		switch (PL_op->op_type) {
	        case OP_GPBYNAME:
		    p0 = va_arg(ap, void *);
		    retptr = getprotobyname((char *)p0); break;
	        case OP_GPBYNUMBER:
		    anint = va_arg(ap, int);
		    retptr = getprotobynumber(anint); break;
	        case OP_GPROTOENT:
		    retptr = getprotoent(); break;
	        default:
		    SETERRNO(ERANGE, LIB_INVARG);
		    break;
	        }
	    }
	}
	break;
#endif
#ifdef USE_SERVENT_BUFFER
    case OP_GSBYNAME:
    case OP_GSBYPORT:
    case OP_GSERVENT:
	{
#ifdef PERL_REENTRANT_MAXSIZE
	    if (PL_reentrant_buffer->_servent_size <=
		PERL_REENTRANT_MAXSIZE / 2)
#endif
	    {
		PL_reentrant_buffer->_servent_size *= 2;
		Renew(PL_reentrant_buffer->_servent_buffer,
		      PL_reentrant_buffer->_servent_size, char);
		switch (PL_op->op_type) {
	        case OP_GSBYNAME:
		    p0 = va_arg(ap, void *);
		    p1 = va_arg(ap, void *);
		    retptr = getservbyname((char *)p0, (char *)p1); break;
	        case OP_GSBYPORT:
		    anint = va_arg(ap, int);
		    p0 = va_arg(ap, void *);
		    retptr = getservbyport(anint, (char *)p0); break;
	        case OP_GSERVENT:
		    retptr = getservent(); break;
	        default:
		    SETERRNO(ERANGE, LIB_INVARG);
		    break;
	        }
	    }
	}
	break;
#endif
    default:
	/* Not known how to retry, so just fail. */
	break;
    }
#else
    PERL_UNUSED_ARG(f);
#endif
    }
    va_end(ap);
    return retptr;
}

/* ex: set ro: */
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*
d5 1
a5 1
 *    Copyright (c) 1997-2002, Larry Wall
d10 6
a15 3
 *  !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
 *  This file is built by reentrl.pl from data in reentr.pl.
 *
d19 10
d38 1
a49 2
#ifdef HAS_DRAND48_R
#endif /* HAS_DRAND48_R */
d51 4
a54 4
#   if defined(HAS_SYSCONF) && defined(_SC_GETPW_R_SIZE_MAX) && !defined(__GLIBC__)
	PL_reentrant_buffer->_grent_size = sysconf(_SC_GETPW_R_SIZE_MAX);
	if (PL_reentrant_buffer->_pwent_size == -1)
		PL_reentrant_buffer->_pwent_size = REENTRANTUSUALSIZE;
d88 1
a88 1
	if (PL_reentrant_buffer->_pwent_size == -1)
d110 2
a111 2
	if (PL_reentrant_buffer->_pwent_size == -1)
		PL_reentrant_buffer->_pwent_size = REENTRANTUSUALSIZE;
a123 6
#ifdef HAS_GMTIME_R
#endif /* HAS_GMTIME_R */
#ifdef HAS_LOCALTIME_R
#endif /* HAS_LOCALTIME_R */
#ifdef HAS_RANDOM_R
#endif /* HAS_RANDOM_R */
d149 1
d151 1
a151 1
	New(31337, PL_reentrant_buffer, 1, REENTR);
d154 1
a154 1
	New(31338, PL_reentrant_buffer->_asctime_buffer, PL_reentrant_buffer->_asctime_size, char);
d157 2
a158 2
#ifdef __GLIBC__
	PL_reentrant_buffer->_crypt_struct.initialized = 0;
d162 1
a162 1
	New(31338, PL_reentrant_buffer->_ctime_buffer, PL_reentrant_buffer->_ctime_size, char);
a163 2
#ifdef HAS_DRAND48_R
#endif /* HAS_DRAND48_R */
d168 1
a168 1
	New(31338, PL_reentrant_buffer->_grent_buffer, PL_reentrant_buffer->_grent_size, char);
d172 1
a172 1
	New(31338, PL_reentrant_buffer->_hostent_buffer, PL_reentrant_buffer->_hostent_size, char);
d176 1
a176 1
	New(31338, PL_reentrant_buffer->_getlogin_buffer, PL_reentrant_buffer->_getlogin_size, char);
d180 1
a180 1
	New(31338, PL_reentrant_buffer->_netent_buffer, PL_reentrant_buffer->_netent_size, char);
d185 1
a185 1
	New(31338, PL_reentrant_buffer->_protoent_buffer, PL_reentrant_buffer->_protoent_size, char);
d192 1
a192 1
	New(31338, PL_reentrant_buffer->_pwent_buffer, PL_reentrant_buffer->_pwent_size, char);
d196 1
a196 1
	New(31338, PL_reentrant_buffer->_servent_buffer, PL_reentrant_buffer->_servent_size, char);
d203 1
a203 1
	New(31338, PL_reentrant_buffer->_spent_buffer, PL_reentrant_buffer->_spent_size, char);
a204 6
#ifdef HAS_GMTIME_R
#endif /* HAS_GMTIME_R */
#ifdef HAS_LOCALTIME_R
#endif /* HAS_LOCALTIME_R */
#ifdef HAS_RANDOM_R
#endif /* HAS_RANDOM_R */
d212 1
a212 1
	New(31338, PL_reentrant_buffer->_setlocale_buffer, PL_reentrant_buffer->_setlocale_size, char);
d215 1
a215 1
	New(31338, PL_reentrant_buffer->_strerror_buffer, PL_reentrant_buffer->_strerror_size, char);
d218 1
a218 1
	New(31338, PL_reentrant_buffer->_ttyname_buffer, PL_reentrant_buffer->_ttyname_size, char);
d226 1
d232 3
a238 2
#ifdef HAS_DRAND48_R
#endif /* HAS_DRAND48_R */
a270 6
#ifdef HAS_GMTIME_R
#endif /* HAS_GMTIME_R */
#ifdef HAS_LOCALTIME_R
#endif /* HAS_LOCALTIME_R */
#ifdef HAS_RANDOM_R
#endif /* HAS_RANDOM_R */
d294 3
d298 6
a303 1
    void *retptr = NULL;
d305 1
a305 1
#  if defined(USE_HOSTENT_BUFFER) || defined(USE_GRENT_BUFFER) || defined(USE_NETENT_BUFFER) || defined(USE_PWENT_BUFFER) || defined(USE_PROTOENT_BUFFER) || defined(USE_SRVENT_BUFFER)
a316 5
    va_list ap;

    va_start(ap, f);

#define REENTRANTHALFMAXSIZE 32768 /* The maximum may end up twice this. */
d324 5
a328 1
	    if (PL_reentrant_buffer->_hostent_size <= REENTRANTHALFMAXSIZE) {
d340 1
a340 1
		    retptr = gethostbyname(p0); break;
d344 1
d356 5
a360 1
	    if (PL_reentrant_buffer->_grent_size <= REENTRANTHALFMAXSIZE) {
d368 1
a368 1
		    retptr = getgrnam(p0); break;
d370 3
d374 1
d379 1
d391 5
a395 1
	    if (PL_reentrant_buffer->_netent_size <= REENTRANTHALFMAXSIZE) {
d407 1
a407 1
		    retptr = getnetbyname(p0); break;
d411 1
d423 5
a427 1
	    if (PL_reentrant_buffer->_pwent_size <= REENTRANTHALFMAXSIZE) {
d435 1
a435 1
		    retptr = getpwnam(p0); break;
d437 3
d441 1
d443 1
d446 1
d448 1
d460 5
a464 1
	    if (PL_reentrant_buffer->_protoent_size <= REENTRANTHALFMAXSIZE) {
d471 1
a471 1
		    retptr = getprotobyname(p0); break;
d478 1
d490 5
a494 1
	    if (PL_reentrant_buffer->_servent_size <= REENTRANTHALFMAXSIZE) {
d502 1
a502 1
		    retptr = getservbyname(p0, p1); break;
d506 1
a506 1
		    retptr = getservbyport(anint, p0); break;
d510 1
d521 4
a524 1

a525 1
#endif
d529 1
@


1.1.1.1
log
@stock perl 5.8.0 from CPAN
@
text
@@


1.1.1.2
log
@perl 5.8.2 from CPAN
@
text
@d4 1
a4 1
 *    Copyright (C) 2002, 2003, by Larry Wall and others
d38 4
a41 4
#   if defined(HAS_SYSCONF) && defined(_SC_GETGR_R_SIZE_MAX) && !defined(__GLIBC__)
	PL_reentrant_buffer->_grent_size = sysconf(_SC_GETGR_R_SIZE_MAX);
	if (PL_reentrant_buffer->_grent_size == -1)
		PL_reentrant_buffer->_grent_size = REENTRANTUSUALSIZE;
d97 2
a98 2
	if (PL_reentrant_buffer->_spent_size == -1)
		PL_reentrant_buffer->_spent_size = REENTRANTUSUALSIZE;
d149 2
a150 2
#if CRYPT_R_PROTO != REENTRANT_PROTO_B_CCD
	PL_reentrant_buffer->_crypt_struct_buffer = 0;
a230 3
#if CRYPT_R_PROTO != REENTRANT_PROTO_B_CCD
	Safefree(PL_reentrant_buffer->_crypt_struct_buffer);
#endif
d301 1
a301 1
#  if defined(USE_HOSTENT_BUFFER) || defined(USE_GRENT_BUFFER) || defined(USE_NETENT_BUFFER) || defined(USE_PWENT_BUFFER) || defined(USE_PROTOENT_BUFFER) || defined(USE_SERVENT_BUFFER)
d317 2
d325 1
a325 5
#ifdef PERL_REENTRANT_MAXSIZE
	    if (PL_reentrant_buffer->_hostent_size <=
		PERL_REENTRANT_MAXSIZE / 2)
#endif
	    {
a340 1
		    SETERRNO(ERANGE, LIB_INVARG);
d352 1
a352 5
#ifdef PERL_REENTRANT_MAXSIZE
	    if (PL_reentrant_buffer->_grent_size <=
		PERL_REENTRANT_MAXSIZE / 2)
#endif
	    {
a361 3
#if Gid_t_size < INTSIZE
		    gid = (Gid_t)va_arg(ap, int);
#else
a362 1
#endif
a366 1
		    SETERRNO(ERANGE, LIB_INVARG);
d378 1
a378 5
#ifdef PERL_REENTRANT_MAXSIZE
	    if (PL_reentrant_buffer->_netent_size <=
		PERL_REENTRANT_MAXSIZE / 2)
#endif
	    {
a393 1
		    SETERRNO(ERANGE, LIB_INVARG);
d405 1
a405 5
#ifdef PERL_REENTRANT_MAXSIZE
	    if (PL_reentrant_buffer->_pwent_size <=
		PERL_REENTRANT_MAXSIZE / 2)
#endif
	    {
a414 3
#if Uid_t_size < INTSIZE
		    uid = (Uid_t)va_arg(ap, int);
#else
a415 1
#endif
a419 1
		    SETERRNO(ERANGE, LIB_INVARG);
d431 1
a431 5
#ifdef PERL_REENTRANT_MAXSIZE
	    if (PL_reentrant_buffer->_protoent_size <=
		PERL_REENTRANT_MAXSIZE / 2)
#endif
	    {
a444 1
		    SETERRNO(ERANGE, LIB_INVARG);
d456 1
a456 5
#ifdef PERL_REENTRANT_MAXSIZE
	    if (PL_reentrant_buffer->_servent_size <=
		PERL_REENTRANT_MAXSIZE / 2)
#endif
	    {
a471 1
		    SETERRNO(ERANGE, LIB_INVARG);
@


1.1.1.3
log
@perl 5.8.6 from CPAN
@
text
@d10 1
a10 1
 *  This file is built by reentr.pl from data in reentr.pl.
a14 6
 * This file contains a collection of automatically created wrappers
 * (created by running reentr.pl) for reentrant (thread-safe) versions of
 * various library calls, such as getpwent_r.  The wrapping is done so
 * that other files like pp_sys.c calling those library functions need not
 * care about the differences between various platforms' idiosyncrasies
 * regarding these reentrant interfaces.  
@


1.1.1.4
log
@perl 5.8.8 import
@
text
@d1 1
a1 2
/* -*- buffer-read-only: t -*-
 *
d4 1
a4 1
 *    Copyright (C) 2002, 2003, 2005 by Larry Wall and others
d149 1
a149 1
	Newx(PL_reentrant_buffer, 1, REENTR);
d152 1
a152 1
	Newx(PL_reentrant_buffer->_asctime_buffer, PL_reentrant_buffer->_asctime_size, char);
d160 1
a160 1
	Newx(PL_reentrant_buffer->_ctime_buffer, PL_reentrant_buffer->_ctime_size, char);
d168 1
a168 1
	Newx(PL_reentrant_buffer->_grent_buffer, PL_reentrant_buffer->_grent_size, char);
d172 1
a172 1
	Newx(PL_reentrant_buffer->_hostent_buffer, PL_reentrant_buffer->_hostent_size, char);
d176 1
a176 1
	Newx(PL_reentrant_buffer->_getlogin_buffer, PL_reentrant_buffer->_getlogin_size, char);
d180 1
a180 1
	Newx(PL_reentrant_buffer->_netent_buffer, PL_reentrant_buffer->_netent_size, char);
d185 1
a185 1
	Newx(PL_reentrant_buffer->_protoent_buffer, PL_reentrant_buffer->_protoent_size, char);
d192 1
a192 1
	Newx(PL_reentrant_buffer->_pwent_buffer, PL_reentrant_buffer->_pwent_size, char);
d196 1
a196 1
	Newx(PL_reentrant_buffer->_servent_buffer, PL_reentrant_buffer->_servent_size, char);
d203 1
a203 1
	Newx(PL_reentrant_buffer->_spent_buffer, PL_reentrant_buffer->_spent_size, char);
d218 1
a218 1
	Newx(PL_reentrant_buffer->_setlocale_buffer, PL_reentrant_buffer->_setlocale_size, char);
d221 1
a221 1
	Newx(PL_reentrant_buffer->_strerror_buffer, PL_reentrant_buffer->_strerror_size, char);
d224 1
a224 1
	Newx(PL_reentrant_buffer->_ttyname_buffer, PL_reentrant_buffer->_ttyname_size, char);
d348 1
a348 1
		    retptr = gethostbyname((char *)p0); break;
d376 1
a376 1
		    retptr = getgrnam((char *)p0); break;
d415 1
a415 1
		    retptr = getnetbyname((char *)p0); break;
d443 1
a443 1
		    retptr = getpwnam((char *)p0); break;
d477 1
a477 1
		    retptr = getprotobyname((char *)p0); break;
d508 1
a508 1
		    retptr = getservbyname((char *)p0, (char *)p1); break;
d512 1
a512 1
		    retptr = getservbyport(anint, (char *)p0); break;
a532 1
/* ex: set ro: */
@


1.1.1.5
log
@import perl 5.10.0 from CPAN
@
text
@d5 1
a5 1
 *    Copyright (C) 2002, 2003, 2005, 2006, 2007 by Larry Wall and others
d47 1
a47 1
	if (PL_reentrant_buffer->_grent_size == (size_t) -1)
d82 1
a82 1
	if (PL_reentrant_buffer->_pwent_size == (size_t) -1)
d104 1
a104 1
	if (PL_reentrant_buffer->_spent_size == (size_t) -1)
a136 2
#ifdef HAS_SRANDOM_R
#endif /* HAS_SRANDOM_R */
a220 2
#ifdef HAS_SRANDOM_R
#endif /* HAS_SRANDOM_R */
a293 2
#ifdef HAS_SRANDOM_R
#endif /* HAS_SRANDOM_R */
a309 3
    va_list ap;
    va_start(ap, f);
    {
d323 3
d528 2
a529 2
#else
    PERL_UNUSED_ARG(f);
a530 2
    }
    va_end(ap);
@


1.1.1.6
log
@import perl 5.10.1
@
text
@a316 5
#ifdef USE_REENTRANT_API
    /* Easier to special case this here than in embed.pl. (Look at what it
       generates for proto.h) */
    PERL_ARGS_ASSERT_REENTRANT_RETRY;
#endif
@


1.1.1.7
log
@Perl 5.12.2 from CPAN
@
text
@d118 4
d208 4
d283 4
@


1.1.1.8
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d10 2
a11 3
 * !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
 * This file is built by regen/reentr.pl from data in regen/reentr.pl.
 * Any changes made here will be lost!
@


1.1.1.9
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d303 1
a306 1
    dTHX;
@


1.1.1.10
log
@Import perl-5.20.1
@
text
@d43 2
d119 2
d134 2
d162 2
d205 2
d216 2
d242 2
d276 2
d287 2
a451 1
#if defined(HAS_GETPWENT) || defined(HAS_GETPWENT_R)
a453 1
#endif
@


