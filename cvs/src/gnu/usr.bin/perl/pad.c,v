head	1.3;
access;
symbols
	OPENBSD_6_2_BASE:1.3
	PERL_5_24_2:1.1.1.12
	OPENBSD_6_1:1.3.0.4
	OPENBSD_6_1_BASE:1.3
	OPENBSD_6_0:1.2.0.4
	OPENBSD_6_0_BASE:1.2
	OPENBSD_5_9:1.1.1.11.0.2
	OPENBSD_5_9_BASE:1.1.1.11
	OPENBSD_5_8:1.1.1.11.0.4
	OPENBSD_5_8_BASE:1.1.1.11
	PERL_5_20_2:1.1.1.11
	OPENBSD_5_7:1.1.1.10.0.2
	OPENBSD_5_7_BASE:1.1.1.10
	PERL_5_20_1:1.1.1.10
	OPENBSD_5_6:1.1.1.9.0.4
	OPENBSD_5_6_BASE:1.1.1.9
	PERL_5_18_2:1.1.1.9
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.8.0.6
	OPENBSD_5_5_BASE:1.1.1.8
	OPENBSD_5_4:1.1.1.8.0.2
	OPENBSD_5_4_BASE:1.1.1.8
	PERL_5_16_3:1.1.1.8
	OPENBSD_5_3:1.1.1.7.0.10
	OPENBSD_5_3_BASE:1.1.1.7
	OPENBSD_5_2:1.1.1.7.0.8
	OPENBSD_5_2_BASE:1.1.1.7
	OPENBSD_5_1_BASE:1.1.1.7
	OPENBSD_5_1:1.1.1.7.0.6
	OPENBSD_5_0:1.1.1.7.0.4
	OPENBSD_5_0_BASE:1.1.1.7
	OPENBSD_4_9:1.1.1.7.0.2
	OPENBSD_4_9_BASE:1.1.1.7
	PERL_5_12_2:1.1.1.7
	OPENBSD_4_8:1.1.1.6.0.4
	OPENBSD_4_8_BASE:1.1.1.6
	OPENBSD_4_7:1.1.1.6.0.2
	OPENBSD_4_7_BASE:1.1.1.6
	PERL_5_10_1:1.1.1.6
	OPENBSD_4_6:1.1.1.5.0.6
	OPENBSD_4_6_BASE:1.1.1.5
	OPENBSD_4_5:1.1.1.5.0.2
	OPENBSD_4_5_BASE:1.1.1.5
	PERL_5_10_0:1.1.1.5
	OPENBSD_4_4:1.1.1.4.0.10
	OPENBSD_4_4_BASE:1.1.1.4
	OPENBSD_4_3:1.1.1.4.0.8
	OPENBSD_4_3_BASE:1.1.1.4
	OPENBSD_4_2:1.1.1.4.0.6
	OPENBSD_4_2_BASE:1.1.1.4
	OPENBSD_4_1:1.1.1.4.0.4
	OPENBSD_4_1_BASE:1.1.1.4
	OPENBSD_4_0:1.1.1.4.0.2
	OPENBSD_4_0_BASE:1.1.1.4
	PERL_5_8_8:1.1.1.4
	OPENBSD_3_9:1.1.1.3.0.6
	OPENBSD_3_9_BASE:1.1.1.3
	OPENBSD_3_8:1.1.1.3.0.4
	OPENBSD_3_8_BASE:1.1.1.3
	OPENBSD_3_7:1.1.1.3.0.2
	OPENBSD_3_7_BASE:1.1.1.3
	PERL_5_8_6:1.1.1.3
	OPENBSD_3_6:1.1.1.2.0.2
	OPENBSD_3_6_BASE:1.1.1.2
	PERL_5_8_5:1.1.1.2
	PERL_5_8_3:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.2
	OPENBSD_3_5_BASE:1.1.1.1
	PERL_5_8_2:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.3
date	2017.02.05.00.31.53;	author afresh1;	state Exp;
branches;
next	1.2;
commitid	cxJ08BvJA9Pt2PTM;

1.2
date	2016.07.03.01.07.48;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	GzHqjSTnBjdF7Wcw;

1.1
date	2003.12.03.02.43.32;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.12.03.02.43.32;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.08.09.17.45.51;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2005.01.15.21.16.28;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2006.03.28.18.47.33;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2008.09.29.17.18.07;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2009.10.12.18.10.37;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2010.09.24.14.48.18;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2013.03.25.20.06.28;	author sthen;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2014.03.24.14.58.45;	author afresh1;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2014.11.17.20.52.37;	author afresh1;	state Exp;
branches;
next	1.1.1.11;
commitid	B31cAbBIXiCqnL97;

1.1.1.11
date	2015.04.25.19.10.10;	author afresh1;	state Exp;
branches;
next	1.1.1.12;
commitid	Wpcs5S8qILgEZC7F;

1.1.1.12
date	2017.08.14.13.45.27;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.3
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@/*    pad.c
 *
 *    Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008
 *    by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 */

/*
 *  'Anyway: there was this Mr. Frodo left an orphan and stranded, as you
 *   might say, among those queer Bucklanders, being brought up anyhow in
 *   Brandy Hall.  A regular warren, by all accounts.  Old Master Gorbadoc
 *   never had fewer than a couple of hundred relations in the place.
 *   Mr. Bilbo never did a kinder deed than when he brought the lad back
 *   to live among decent folk.'                           --the Gaffer
 *
 *     [p.23 of _The Lord of the Rings_, I/i: "A Long-Expected Party"]
 */

/* XXX DAPM
 * As of Sept 2002, this file is new and may be in a state of flux for
 * a while. I've marked things I intent to come back and look at further
 * with an 'XXX DAPM' comment.
 */

/*
=head1 Pad Data Structures

=for apidoc Amx|PADLIST *|CvPADLIST|CV *cv

CV's can have CvPADLIST(cv) set to point to a PADLIST.  This is the CV's
scratchpad, which stores lexical variables and opcode temporary and
per-thread values.

For these purposes "formats" are a kind-of CV; eval""s are too (except they're
not callable at will and are always thrown away after the eval"" is done
executing).  Require'd files are simply evals without any outer lexical
scope.

XSUBs do not have a C<CvPADLIST>.  C<dXSTARG> fetches values from C<PL_curpad>,
but that is really the callers pad (a slot of which is allocated by
every entersub). Do not get or set C<CvPADLIST> if a CV is an XSUB (as
determined by C<CvISXSUB()>), C<CvPADLIST> slot is reused for a different
internal purpose in XSUBs.

The PADLIST has a C array where pads are stored.

The 0th entry of the PADLIST is a PADNAMELIST
which represents the "names" or rather
the "static type information" for lexicals.  The individual elements of a
PADNAMELIST are PADNAMEs.  Future
refactorings might stop the PADNAMELIST from being stored in the PADLIST's
array, so don't rely on it.  See L</PadlistNAMES>.

The CvDEPTH'th entry of a PADLIST is a PAD (an AV) which is the stack frame
at that depth of recursion into the CV.  The 0th slot of a frame AV is an
AV which is C<@@_>.  Other entries are storage for variables and op targets.

Iterating over the PADNAMELIST iterates over all possible pad
items.  Pad slots for targets (C<SVs_PADTMP>)
and GVs end up having &PL_padname_undef "names", while slots for constants 
have C<&PL_padname_const> "names" (see C<L</pad_alloc>>).  That
C<&PL_padname_undef>
and C<&PL_padname_const> are used is an implementation detail subject to
change.  To test for them, use C<!PadnamePV(name)> and
S<C<PadnamePV(name) && !PadnameLEN(name)>>, respectively.

Only C<my>/C<our> variable slots get valid names.
The rest are op targets/GVs/constants which are statically allocated
or resolved at compile time.  These don't have names by which they
can be looked up from Perl code at run time through eval"" the way
C<my>/C<our> variables can be.  Since they can't be looked up by "name"
but only by their index allocated at compile time (which is usually
in C<PL_op->op_targ>), wasting a name SV for them doesn't make sense.

The pad names in the PADNAMELIST have their PV holding the name of
the variable.  The C<COP_SEQ_RANGE_LOW> and C<_HIGH> fields form a range
(low+1..high inclusive) of cop_seq numbers for which the name is
valid.  During compilation, these fields may hold the special value
PERL_PADSEQ_INTRO to indicate various stages:

 COP_SEQ_RANGE_LOW        _HIGH
 -----------------        -----
 PERL_PADSEQ_INTRO            0   variable not yet introduced:
                                  { my ($x
 valid-seq#   PERL_PADSEQ_INTRO   variable in scope:
                                  { my ($x)
 valid-seq#          valid-seq#   compilation of scope complete:
                                  { my ($x) }

For typed lexicals C<PadnameTYPE> points at the type stash.  For C<our>
lexicals, C<PadnameOURSTASH> points at the stash of the associated global (so
that duplicate C<our> declarations in the same package can be detected).
C<PadnameGEN> is sometimes used to store the generation number during
compilation.

If C<PadnameOUTER> is set on the pad name, then that slot in the frame AV
is a REFCNT'ed reference to a lexical from "outside".  Such entries
are sometimes referred to as 'fake'.  In this case, the name does not
use 'low' and 'high' to store a cop_seq range, since it is in scope
throughout.  Instead 'high' stores some flags containing info about
the real lexical (is it declared in an anon, and is it capable of being
instantiated multiple times?), and for fake ANONs, 'low' contains the index
within the parent's pad where the lexical's value is stored, to make
cloning quicker.

If the 'name' is C<&> the corresponding entry in the PAD
is a CV representing a possible closure.

Note that formats are treated as anon subs, and are cloned each time
write is called (if necessary).

The flag C<SVs_PADSTALE> is cleared on lexicals each time the C<my()> is executed,
and set on scope exit.  This allows the
C<"Variable $x is not available"> warning
to be generated in evals, such as 

    { my $x = 1; sub f { eval '$x'} } f();

For state vars, C<SVs_PADSTALE> is overloaded to mean 'not yet initialised',
but this internal state is stored in a separate pad entry.

=for apidoc AmxU|PADNAMELIST *|PL_comppad_name

During compilation, this points to the array containing the names part
of the pad for the currently-compiling code.

=for apidoc AmxU|PAD *|PL_comppad

During compilation, this points to the array containing the values
part of the pad for the currently-compiling code.  (At runtime a CV may
have many such value arrays; at compile time just one is constructed.)
At runtime, this points to the array containing the currently-relevant
values for the pad for the currently-executing code.

=for apidoc AmxU|SV **|PL_curpad

Points directly to the body of the L</PL_comppad> array.
(I.e., this is C<PAD_ARRAY(PL_comppad)>.)

=cut
*/


#include "EXTERN.h"
#define PERL_IN_PAD_C
#include "perl.h"
#include "keywords.h"

#define COP_SEQ_RANGE_LOW_set(sv,val)		\
  STMT_START { (sv)->xpadn_low = (val); } STMT_END
#define COP_SEQ_RANGE_HIGH_set(sv,val)		\
  STMT_START { (sv)->xpadn_high = (val); } STMT_END

#define PARENT_PAD_INDEX_set		COP_SEQ_RANGE_LOW_set
#define PARENT_FAKELEX_FLAGS_set	COP_SEQ_RANGE_HIGH_set

#ifdef DEBUGGING
void
Perl_set_padlist(CV * cv, PADLIST *padlist){
    PERL_ARGS_ASSERT_SET_PADLIST;
#  if PTRSIZE == 8
    assert((Size_t)padlist != UINT64_C(0xEFEFEFEFEFEFEFEF));
#  elif PTRSIZE == 4
    assert((Size_t)padlist != 0xEFEFEFEF);
#  else
#    error unknown pointer size
#  endif
    assert(!CvISXSUB(cv));
    ((XPVCV*)MUTABLE_PTR(SvANY(cv)))->xcv_padlist_u.xcv_padlist = padlist;
}
#endif

/*
=for apidoc Am|PADLIST *|pad_new|int flags

Create a new padlist, updating the global variables for the
currently-compiling padlist to point to the new padlist.  The following
flags can be OR'ed together:

    padnew_CLONE	this pad is for a cloned CV
    padnew_SAVE		save old globals on the save stack
    padnew_SAVESUB	also save extra stuff for start of sub

=cut
*/

PADLIST *
Perl_pad_new(pTHX_ int flags)
{
    PADLIST *padlist;
    PADNAMELIST *padname;
    PAD *pad;
    PAD **ary;

    ASSERT_CURPAD_LEGAL("pad_new");

    /* XXX DAPM really need a new SAVEt_PAD which restores all or most
     * vars (based on flags) rather than storing vals + addresses for
     * each individually. Also see pad_block_start.
     * XXX DAPM Try to see whether all these conditionals are required
     */

    /* save existing state, ... */

    if (flags & padnew_SAVE) {
	SAVECOMPPAD();
	if (! (flags & padnew_CLONE)) {
	    SAVESPTR(PL_comppad_name);
	    SAVEI32(PL_padix);
	    SAVEI32(PL_constpadix);
	    SAVEI32(PL_comppad_name_fill);
	    SAVEI32(PL_min_intro_pending);
	    SAVEI32(PL_max_intro_pending);
	    SAVEBOOL(PL_cv_has_eval);
	    if (flags & padnew_SAVESUB) {
		SAVEBOOL(PL_pad_reset_pending);
	    }
	}
    }
    /* XXX DAPM interestingly, PL_comppad_name_floor never seems to be
     * saved - check at some pt that this is okay */

    /* ... create new pad ... */

    Newxz(padlist, 1, PADLIST);
    pad		= newAV();

    if (flags & padnew_CLONE) {
	/* XXX DAPM  I dont know why cv_clone needs it
	 * doing differently yet - perhaps this separate branch can be
	 * dispensed with eventually ???
	 */

        AV * const a0 = newAV();			/* will be @@_ */
	av_store(pad, 0, MUTABLE_SV(a0));
	AvREIFY_only(a0);

	PadnamelistREFCNT(padname = PL_comppad_name)++;
    }
    else {
	padlist->xpadl_id = PL_padlist_generation++;
	av_store(pad, 0, NULL);
	padname = newPADNAMELIST(0);
	padnamelist_store(padname, 0, &PL_padname_undef);
    }

    /* Most subroutines never recurse, hence only need 2 entries in the padlist
       array - names, and depth=1.  The default for av_store() is to allocate
       0..3, and even an explicit call to av_extend() with <3 will be rounded
       up, so we inline the allocation of the array here.  */
    Newx(ary, 2, PAD *);
    PadlistMAX(padlist) = 1;
    PadlistARRAY(padlist) = ary;
    ary[0] = (PAD *)padname;
    ary[1] = pad;

    /* ... then update state variables */

    PL_comppad		= pad;
    PL_curpad		= AvARRAY(pad);

    if (! (flags & padnew_CLONE)) {
	PL_comppad_name	     = padname;
	PL_comppad_name_fill = 0;
	PL_min_intro_pending = 0;
	PL_padix	     = 0;
	PL_constpadix	     = 0;
	PL_cv_has_eval	     = 0;
    }

    DEBUG_X(PerlIO_printf(Perl_debug_log,
	  "Pad 0x%"UVxf"[0x%"UVxf"] new:       compcv=0x%"UVxf
	      " name=0x%"UVxf" flags=0x%"UVxf"\n",
	  PTR2UV(PL_comppad), PTR2UV(PL_curpad), PTR2UV(PL_compcv),
	      PTR2UV(padname), (UV)flags
	)
    );

    return (PADLIST*)padlist;
}


/*
=head1 Embedding Functions

=for apidoc cv_undef

Clear out all the active components of a CV.  This can happen either
by an explicit C<undef &foo>, or by the reference count going to zero.
In the former case, we keep the C<CvOUTSIDE> pointer, so that any anonymous
children can still follow the full lexical scope chain.

=cut
*/

void
Perl_cv_undef(pTHX_ CV *cv)
{
    PERL_ARGS_ASSERT_CV_UNDEF;
    cv_undef_flags(cv, 0);
}

void
Perl_cv_undef_flags(pTHX_ CV *cv, U32 flags)
{
    CV cvbody;/*CV body will never be realloced inside this func,
               so dont read it more than once, use fake CV so existing macros
               will work, the indirection and CV head struct optimized away*/
    SvANY(&cvbody) = SvANY(cv);

    PERL_ARGS_ASSERT_CV_UNDEF_FLAGS;

    DEBUG_X(PerlIO_printf(Perl_debug_log,
	  "CV undef: cv=0x%"UVxf" comppad=0x%"UVxf"\n",
	    PTR2UV(cv), PTR2UV(PL_comppad))
    );

    if (CvFILE(&cvbody)) {
	char * file = CvFILE(&cvbody);
	CvFILE(&cvbody) = NULL;
	if(CvDYNFILE(&cvbody))
	    Safefree(file);
    }

    /* CvSLABBED_off(&cvbody); *//* turned off below */
    /* release the sub's body */
    if (!CvISXSUB(&cvbody)) {
        if(CvROOT(&cvbody)) {
            assert(SvTYPE(cv) == SVt_PVCV || SvTYPE(cv) == SVt_PVFM); /*unsafe is safe */
            if (CvDEPTHunsafe(&cvbody)) {
                assert(SvTYPE(cv) == SVt_PVCV);
                Perl_croak_nocontext("Can't undef active subroutine");
            }
            ENTER;

            PAD_SAVE_SETNULLPAD();

            if (CvSLABBED(&cvbody)) OpslabREFCNT_dec_padok(OpSLAB(CvROOT(&cvbody)));
            op_free(CvROOT(&cvbody));
            CvROOT(&cvbody) = NULL;
            CvSTART(&cvbody) = NULL;
            LEAVE;
        }
	else if (CvSLABBED(&cvbody)) {
            if( CvSTART(&cvbody)) {
                ENTER;
                PAD_SAVE_SETNULLPAD();

                /* discard any leaked ops */
                if (PL_parser)
                    parser_free_nexttoke_ops(PL_parser, (OPSLAB *)CvSTART(&cvbody));
                opslab_force_free((OPSLAB *)CvSTART(&cvbody));
                CvSTART(&cvbody) = NULL;

                LEAVE;
            }
#ifdef DEBUGGING
            else Perl_warn(aTHX_ "Slab leaked from cv %p", (void*)cv);
#endif
        }
    }
    else { /* dont bother checking if CvXSUB(cv) is true, less branching */
	CvXSUB(&cvbody) = NULL;
    }
    SvPOK_off(MUTABLE_SV(cv));		/* forget prototype */
    sv_unmagic((SV *)cv, PERL_MAGIC_checkcall);
    if (!(flags & CV_UNDEF_KEEP_NAME)) {
	if (CvNAMED(&cvbody)) {
	    CvNAME_HEK_set(&cvbody, NULL);
	    CvNAMED_off(&cvbody);
	}
	else CvGV_set(cv, NULL);
    }

    /* This statement and the subsequence if block was pad_undef().  */
    pad_peg("pad_undef");

    if (!CvISXSUB(&cvbody) && CvPADLIST(&cvbody)) {
	I32 ix;
	const PADLIST *padlist = CvPADLIST(&cvbody);

	/* Free the padlist associated with a CV.
	   If parts of it happen to be current, we null the relevant PL_*pad*
	   global vars so that we don't have any dangling references left.
	   We also repoint the CvOUTSIDE of any about-to-be-orphaned inner
	   subs to the outer of this cv.  */

	DEBUG_X(PerlIO_printf(Perl_debug_log,
			      "Pad undef: cv=0x%"UVxf" padlist=0x%"UVxf" comppad=0x%"UVxf"\n",
			      PTR2UV(cv), PTR2UV(padlist), PTR2UV(PL_comppad))
		);

	/* detach any '&' anon children in the pad; if afterwards they
	 * are still live, fix up their CvOUTSIDEs to point to our outside,
	 * bypassing us. */
	/* XXX DAPM for efficiency, we should only do this if we know we have
	 * children, or integrate this loop with general cleanup */

	if (PL_phase != PERL_PHASE_DESTRUCT) { /* don't bother during global destruction */
	    CV * const outercv = CvOUTSIDE(&cvbody);
	    const U32 seq = CvOUTSIDE_SEQ(&cvbody);
	    PADNAMELIST * const comppad_name = PadlistNAMES(padlist);
	    PADNAME ** const namepad = PadnamelistARRAY(comppad_name);
	    PAD * const comppad = PadlistARRAY(padlist)[1];
	    SV ** const curpad = AvARRAY(comppad);
	    for (ix = PadnamelistMAX(comppad_name); ix > 0; ix--) {
		PADNAME * const name = namepad[ix];
		if (name && PadnamePV(name) && *PadnamePV(name) == '&')
		    {
			CV * const innercv = MUTABLE_CV(curpad[ix]);
			U32 inner_rc = SvREFCNT(innercv);
			assert(inner_rc);
			assert(SvTYPE(innercv) != SVt_PVFM);

			if (SvREFCNT(comppad) < 2) { /* allow for /(?{ sub{} })/  */
			    curpad[ix] = NULL;
			    SvREFCNT_dec_NN(innercv);
			    inner_rc--;
			}

			/* in use, not just a prototype */
			if (inner_rc && SvTYPE(innercv) == SVt_PVCV
			 && (CvOUTSIDE(innercv) == cv))
			{
			    assert(CvWEAKOUTSIDE(innercv));
			    /* don't relink to grandfather if he's being freed */
			    if (outercv && SvREFCNT(outercv)) {
				CvWEAKOUTSIDE_off(innercv);
				CvOUTSIDE(innercv) = outercv;
				CvOUTSIDE_SEQ(innercv) = seq;
				SvREFCNT_inc_simple_void_NN(outercv);
			    }
			    else {
				CvOUTSIDE(innercv) = NULL;
			    }
			}
		    }
	    }
	}

	ix = PadlistMAX(padlist);
	while (ix > 0) {
	    PAD * const sv = PadlistARRAY(padlist)[ix--];
	    if (sv) {
		if (sv == PL_comppad) {
		    PL_comppad = NULL;
		    PL_curpad = NULL;
		}
		SvREFCNT_dec_NN(sv);
	    }
	}
	{
	    PADNAMELIST * const names = PadlistNAMES(padlist);
	    if (names == PL_comppad_name && PadnamelistREFCNT(names) == 1)
		PL_comppad_name = NULL;
	    PadnamelistREFCNT_dec(names);
	}
	if (PadlistARRAY(padlist)) Safefree(PadlistARRAY(padlist));
	Safefree(padlist);
	CvPADLIST_set(&cvbody, NULL);
    }
    else if (CvISXSUB(&cvbody))
	CvHSCXT(&cvbody) = NULL;
    /* else is (!CvISXSUB(&cvbody) && !CvPADLIST(&cvbody)) {do nothing;} */


    /* remove CvOUTSIDE unless this is an undef rather than a free */
    if (!SvREFCNT(cv)) {
	CV * outside = CvOUTSIDE(&cvbody);
	if(outside) {
	    CvOUTSIDE(&cvbody) = NULL;
	    if (!CvWEAKOUTSIDE(&cvbody))
		SvREFCNT_dec_NN(outside);
	}
    }
    if (CvCONST(&cvbody)) {
	SvREFCNT_dec(MUTABLE_SV(CvXSUBANY(&cvbody).any_ptr));
	/* CvCONST_off(cv); *//* turned off below */
    }
    /* delete all flags except WEAKOUTSIDE and CVGV_RC, which indicate the
     * ref status of CvOUTSIDE and CvGV, and ANON, NAMED and
     * LEXICAL, which are used to determine the sub's name.  */
    CvFLAGS(&cvbody) &= (CVf_WEAKOUTSIDE|CVf_CVGV_RC|CVf_ANON|CVf_LEXICAL
		   |CVf_NAMED);
}

/*
=for apidoc cv_forget_slab

When a CV has a reference count on its slab (C<CvSLABBED>), it is responsible
for making sure it is freed.  (Hence, no two CVs should ever have a
reference count on the same slab.)  The CV only needs to reference the slab
during compilation.  Once it is compiled and C<CvROOT> attached, it has
finished its job, so it can forget the slab.

=cut
*/

void
Perl_cv_forget_slab(pTHX_ CV *cv)
{
    bool slabbed;
    OPSLAB *slab = NULL;

    if (!cv)
        return;
    slabbed = cBOOL(CvSLABBED(cv));
    if (!slabbed) return;

    CvSLABBED_off(cv);

    if      (CvROOT(cv))  slab = OpSLAB(CvROOT(cv));
    else if (CvSTART(cv)) slab = (OPSLAB *)CvSTART(cv);
#ifdef DEBUGGING
    else if (slabbed)     Perl_warn(aTHX_ "Slab leaked from cv %p", (void*)cv);
#endif

    if (slab) {
#ifdef PERL_DEBUG_READONLY_OPS
	const size_t refcnt = slab->opslab_refcnt;
#endif
	OpslabREFCNT_dec(slab);
#ifdef PERL_DEBUG_READONLY_OPS
	if (refcnt > 1) Slab_to_ro(slab);
#endif
    }
}

/*
=for apidoc m|PADOFFSET|pad_alloc_name|PADNAME *name|U32 flags|HV *typestash|HV *ourstash

Allocates a place in the currently-compiling
pad (via L<perlapi/pad_alloc>) and
then stores a name for that entry.  C<name> is adopted and
becomes the name entry; it must already contain the name
string.  C<typestash> and C<ourstash> and the C<padadd_STATE>
flag get added to C<name>.  None of the other
processing of L<perlapi/pad_add_name_pvn>
is done.  Returns the offset of the allocated pad slot.

=cut
*/

static PADOFFSET
S_pad_alloc_name(pTHX_ PADNAME *name, U32 flags, HV *typestash,
		       HV *ourstash)
{
    const PADOFFSET offset = pad_alloc(OP_PADSV, SVs_PADMY);

    PERL_ARGS_ASSERT_PAD_ALLOC_NAME;

    ASSERT_CURPAD_ACTIVE("pad_alloc_name");

    if (typestash) {
	SvPAD_TYPED_on(name);
	PadnameTYPE(name) =
	    MUTABLE_HV(SvREFCNT_inc_simple_NN(MUTABLE_SV(typestash)));
    }
    if (ourstash) {
	SvPAD_OUR_on(name);
	SvOURSTASH_set(name, ourstash);
	SvREFCNT_inc_simple_void_NN(ourstash);
    }
    else if (flags & padadd_STATE) {
	SvPAD_STATE_on(name);
    }

    padnamelist_store(PL_comppad_name, offset, name);
    if (PadnameLEN(name) > 1)
	PadnamelistMAXNAMED(PL_comppad_name) = offset;
    return offset;
}

/*
=for apidoc Am|PADOFFSET|pad_add_name_pvn|const char *namepv|STRLEN namelen|U32 flags|HV *typestash|HV *ourstash

Allocates a place in the currently-compiling pad for a named lexical
variable.  Stores the name and other metadata in the name part of the
pad, and makes preparations to manage the variable's lexical scoping.
Returns the offset of the allocated pad slot.

C<namepv>/C<namelen> specify the variable's name, including leading sigil.
If C<typestash> is non-null, the name is for a typed lexical, and this
identifies the type.  If C<ourstash> is non-null, it's a lexical reference
to a package variable, and this identifies the package.  The following
flags can be OR'ed together:

 padadd_OUR          redundantly specifies if it's a package var
 padadd_STATE        variable will retain value persistently
 padadd_NO_DUP_CHECK skip check for lexical shadowing

=cut
*/

PADOFFSET
Perl_pad_add_name_pvn(pTHX_ const char *namepv, STRLEN namelen,
		U32 flags, HV *typestash, HV *ourstash)
{
    PADOFFSET offset;
    PADNAME *name;

    PERL_ARGS_ASSERT_PAD_ADD_NAME_PVN;

    if (flags & ~(padadd_OUR|padadd_STATE|padadd_NO_DUP_CHECK))
	Perl_croak(aTHX_ "panic: pad_add_name_pvn illegal flag bits 0x%" UVxf,
		   (UV)flags);

    name = newPADNAMEpvn(namepv, namelen);

    if ((flags & padadd_NO_DUP_CHECK) == 0) {
	ENTER;
	SAVEFREEPADNAME(name); /* in case of fatal warnings */
	/* check for duplicate declaration */
	pad_check_dup(name, flags & padadd_OUR, ourstash);
	PadnameREFCNT(name)++;
	LEAVE;
    }

    offset = pad_alloc_name(name, flags, typestash, ourstash);

    /* not yet introduced */
    COP_SEQ_RANGE_LOW_set(name, PERL_PADSEQ_INTRO);
    COP_SEQ_RANGE_HIGH_set(name, 0);

    if (!PL_min_intro_pending)
	PL_min_intro_pending = offset;
    PL_max_intro_pending = offset;
    /* if it's not a simple scalar, replace with an AV or HV */
    assert(SvTYPE(PL_curpad[offset]) == SVt_NULL);
    assert(SvREFCNT(PL_curpad[offset]) == 1);
    if (namelen != 0 && *namepv == '@@')
	sv_upgrade(PL_curpad[offset], SVt_PVAV);
    else if (namelen != 0 && *namepv == '%')
	sv_upgrade(PL_curpad[offset], SVt_PVHV);
    else if (namelen != 0 && *namepv == '&')
	sv_upgrade(PL_curpad[offset], SVt_PVCV);
    assert(SvPADMY(PL_curpad[offset]));
    DEBUG_Xv(PerlIO_printf(Perl_debug_log,
			   "Pad addname: %ld \"%s\" new lex=0x%"UVxf"\n",
			   (long)offset, PadnamePV(name),
			   PTR2UV(PL_curpad[offset])));

    return offset;
}

/*
=for apidoc Am|PADOFFSET|pad_add_name_pv|const char *name|U32 flags|HV *typestash|HV *ourstash

Exactly like L</pad_add_name_pvn>, but takes a nul-terminated string
instead of a string/length pair.

=cut
*/

PADOFFSET
Perl_pad_add_name_pv(pTHX_ const char *name,
		     const U32 flags, HV *typestash, HV *ourstash)
{
    PERL_ARGS_ASSERT_PAD_ADD_NAME_PV;
    return pad_add_name_pvn(name, strlen(name), flags, typestash, ourstash);
}

/*
=for apidoc Am|PADOFFSET|pad_add_name_sv|SV *name|U32 flags|HV *typestash|HV *ourstash

Exactly like L</pad_add_name_pvn>, but takes the name string in the form
of an SV instead of a string/length pair.

=cut
*/

PADOFFSET
Perl_pad_add_name_sv(pTHX_ SV *name, U32 flags, HV *typestash, HV *ourstash)
{
    char *namepv;
    STRLEN namelen;
    PERL_ARGS_ASSERT_PAD_ADD_NAME_SV;
    namepv = SvPVutf8(name, namelen);
    return pad_add_name_pvn(namepv, namelen, flags, typestash, ourstash);
}

/*
=for apidoc Amx|PADOFFSET|pad_alloc|I32 optype|U32 tmptype

Allocates a place in the currently-compiling pad,
returning the offset of the allocated pad slot.
No name is initially attached to the pad slot.
C<tmptype> is a set of flags indicating the kind of pad entry required,
which will be set in the value SV for the allocated pad entry:

    SVs_PADMY    named lexical variable ("my", "our", "state")
    SVs_PADTMP   unnamed temporary store
    SVf_READONLY constant shared between recursion levels

C<SVf_READONLY> has been supported here only since perl 5.20.  To work with
earlier versions as well, use C<SVf_READONLY|SVs_PADTMP>.  C<SVf_READONLY>
does not cause the SV in the pad slot to be marked read-only, but simply
tells C<pad_alloc> that it I<will> be made read-only (by the caller), or at
least should be treated as such.

C<optype> should be an opcode indicating the type of operation that the
pad entry is to support.  This doesn't affect operational semantics,
but is used for debugging.

=cut
*/

/* XXX DAPM integrate alloc(), add_name() and add_anon(),
 * or at least rationalise ??? */

PADOFFSET
Perl_pad_alloc(pTHX_ I32 optype, U32 tmptype)
{
    SV *sv;
    I32 retval;

    PERL_UNUSED_ARG(optype);
    ASSERT_CURPAD_ACTIVE("pad_alloc");

    if (AvARRAY(PL_comppad) != PL_curpad)
	Perl_croak(aTHX_ "panic: pad_alloc, %p!=%p",
		   AvARRAY(PL_comppad), PL_curpad);
    if (PL_pad_reset_pending)
	pad_reset();
    if (tmptype == SVs_PADMY) { /* Not & because this ‘flag’ is 0.  */
	/* For a my, simply push a null SV onto the end of PL_comppad. */
	sv = *av_fetch(PL_comppad, AvFILLp(PL_comppad) + 1, TRUE);
	retval = AvFILLp(PL_comppad);
    }
    else {
	/* For a tmp, scan the pad from PL_padix upwards
	 * for a slot which has no name and no active value.
	 * For a constant, likewise, but use PL_constpadix.
	 */
	PADNAME * const * const names = PadnamelistARRAY(PL_comppad_name);
	const SSize_t names_fill = PadnamelistMAX(PL_comppad_name);
	const bool konst = cBOOL(tmptype & SVf_READONLY);
	retval = konst ? PL_constpadix : PL_padix;
	for (;;) {
	    /*
	     * Entries that close over unavailable variables
	     * in outer subs contain values not marked PADMY.
	     * Thus we must skip, not just pad values that are
	     * marked as current pad values, but also those with names.
	     * If pad_reset is enabled, ‘current’ means different
	     * things depending on whether we are allocating a con-
	     * stant or a target.  For a target, things marked PADTMP
	     * can be reused; not so for constants.
	     */
	    PADNAME *pn;
	    if (++retval <= names_fill &&
		   (pn = names[retval]) && PadnamePV(pn))
		continue;
	    sv = *av_fetch(PL_comppad, retval, TRUE);
	    if (!(SvFLAGS(sv) &
#ifdef USE_PAD_RESET
		    (konst ? SVs_PADTMP : 0))
#else
		    SVs_PADTMP
#endif
		 ))
		break;
	}
	if (konst) {
	    padnamelist_store(PL_comppad_name, retval, &PL_padname_const);
	    tmptype &= ~SVf_READONLY;
	    tmptype |= SVs_PADTMP;
	}
	*(konst ? &PL_constpadix : &PL_padix) = retval;
    }
    SvFLAGS(sv) |= tmptype;
    PL_curpad = AvARRAY(PL_comppad);

    DEBUG_X(PerlIO_printf(Perl_debug_log,
	  "Pad 0x%"UVxf"[0x%"UVxf"] alloc:   %ld for %s\n",
	  PTR2UV(PL_comppad), PTR2UV(PL_curpad), (long) retval,
	  PL_op_name[optype]));
#ifdef DEBUG_LEAKING_SCALARS
    sv->sv_debug_optype = optype;
    sv->sv_debug_inpad = 1;
#endif
    return (PADOFFSET)retval;
}

/*
=for apidoc Am|PADOFFSET|pad_add_anon|CV *func|I32 optype

Allocates a place in the currently-compiling pad (via L</pad_alloc>)
for an anonymous function that is lexically scoped inside the
currently-compiling function.
The function C<func> is linked into the pad, and its C<CvOUTSIDE> link
to the outer scope is weakened to avoid a reference loop.

One reference count is stolen, so you may need to do C<SvREFCNT_inc(func)>.

C<optype> should be an opcode indicating the type of operation that the
pad entry is to support.  This doesn't affect operational semantics,
but is used for debugging.

=cut
*/

PADOFFSET
Perl_pad_add_anon(pTHX_ CV* func, I32 optype)
{
    PADOFFSET ix;
    PADNAME * const name = newPADNAMEpvn("&", 1);

    PERL_ARGS_ASSERT_PAD_ADD_ANON;
    assert (SvTYPE(func) == SVt_PVCV);

    pad_peg("add_anon");
    /* These two aren't used; just make sure they're not equal to
     * PERL_PADSEQ_INTRO.  They should be 0 by default.  */
    assert(COP_SEQ_RANGE_LOW (name) != PERL_PADSEQ_INTRO);
    assert(COP_SEQ_RANGE_HIGH(name) != PERL_PADSEQ_INTRO);
    ix = pad_alloc(optype, SVs_PADMY);
    padnamelist_store(PL_comppad_name, ix, name);
    /* XXX DAPM use PL_curpad[] ? */
    av_store(PL_comppad, ix, (SV*)func);

    /* to avoid ref loops, we never have parent + child referencing each
     * other simultaneously */
    if (CvOUTSIDE(func)) {
	assert(!CvWEAKOUTSIDE(func));
	CvWEAKOUTSIDE_on(func);
	SvREFCNT_dec_NN(CvOUTSIDE(func));
    }
    return ix;
}

void
Perl_pad_add_weakref(pTHX_ CV* func)
{
    const PADOFFSET ix = pad_alloc(OP_NULL, SVs_PADMY);
    PADNAME * const name = newPADNAMEpvn("&", 1);
    SV * const rv = newRV_inc((SV *)func);

    PERL_ARGS_ASSERT_PAD_ADD_WEAKREF;

    /* These two aren't used; just make sure they're not equal to
     * PERL_PADSEQ_INTRO.  They should be 0 by default.  */
    assert(COP_SEQ_RANGE_LOW (name) != PERL_PADSEQ_INTRO);
    assert(COP_SEQ_RANGE_HIGH(name) != PERL_PADSEQ_INTRO);
    padnamelist_store(PL_comppad_name, ix, name);
    sv_rvweaken(rv);
    av_store(PL_comppad, ix, rv);
}

/*
=for apidoc pad_check_dup

Check for duplicate declarations: report any of:

     * a 'my' in the current scope with the same name;
     * an 'our' (anywhere in the pad) with the same name and the
       same stash as 'ourstash'

C<is_our> indicates that the name to check is an C<"our"> declaration.

=cut
*/

STATIC void
S_pad_check_dup(pTHX_ PADNAME *name, U32 flags, const HV *ourstash)
{
    PADNAME	**svp;
    PADOFFSET	top, off;
    const U32	is_our = flags & padadd_OUR;

    PERL_ARGS_ASSERT_PAD_CHECK_DUP;

    ASSERT_CURPAD_ACTIVE("pad_check_dup");

    assert((flags & ~padadd_OUR) == 0);

    if (PadnamelistMAX(PL_comppad_name) < 0 || !ckWARN(WARN_MISC))
	return; /* nothing to check */

    svp = PadnamelistARRAY(PL_comppad_name);
    top = PadnamelistMAX(PL_comppad_name);
    /* check the current scope */
    /* XXX DAPM - why the (I32) cast - shouldn't we ensure they're the same
     * type ? */
    for (off = top; (I32)off > PL_comppad_name_floor; off--) {
	PADNAME * const sv = svp[off];
	if (sv
	    && PadnameLEN(sv) == PadnameLEN(name)
	    && !PadnameOUTER(sv)
	    && (   COP_SEQ_RANGE_LOW(sv)  == PERL_PADSEQ_INTRO
		|| COP_SEQ_RANGE_HIGH(sv) == PERL_PADSEQ_INTRO)
	    && memEQ(PadnamePV(sv), PadnamePV(name), PadnameLEN(name)))
	{
	    if (is_our && (SvPAD_OUR(sv)))
		break; /* "our" masking "our" */
	    /* diag_listed_as: "%s" variable %s masks earlier declaration in same %s */
	    Perl_warner(aTHX_ packWARN(WARN_MISC),
		"\"%s\" %s %"PNf" masks earlier declaration in same %s",
		(is_our ? "our" : PL_parser->in_my == KEY_my ? "my" : "state"),
		*PadnamePV(sv) == '&' ? "subroutine" : "variable",
		PNfARG(sv),
		(COP_SEQ_RANGE_HIGH(sv) == PERL_PADSEQ_INTRO
		    ? "scope" : "statement"));
	    --off;
	    break;
	}
    }
    /* check the rest of the pad */
    if (is_our) {
	while (off > 0) {
	    PADNAME * const sv = svp[off];
	    if (sv
		&& PadnameLEN(sv) == PadnameLEN(name)
		&& !PadnameOUTER(sv)
		&& (   COP_SEQ_RANGE_LOW(sv)  == PERL_PADSEQ_INTRO
		    || COP_SEQ_RANGE_HIGH(sv) == PERL_PADSEQ_INTRO)
		&& SvOURSTASH(sv) == ourstash
		&& memEQ(PadnamePV(sv), PadnamePV(name), PadnameLEN(name)))
	    {
		Perl_warner(aTHX_ packWARN(WARN_MISC),
		    "\"our\" variable %"PNf" redeclared", PNfARG(sv));
		if ((I32)off <= PL_comppad_name_floor)
		    Perl_warner(aTHX_ packWARN(WARN_MISC),
			"\t(Did you mean \"local\" instead of \"our\"?)\n");
		break;
	    }
	    --off;
	}
    }
}


/*
=for apidoc Am|PADOFFSET|pad_findmy_pvn|const char *namepv|STRLEN namelen|U32 flags

Given the name of a lexical variable, find its position in the
currently-compiling pad.
C<namepv>/C<namelen> specify the variable's name, including leading sigil.
C<flags> is reserved and must be zero.
If it is not in the current pad but appears in the pad of any lexically
enclosing scope, then a pseudo-entry for it is added in the current pad.
Returns the offset in the current pad,
or C<NOT_IN_PAD> if no such lexical is in scope.

=cut
*/

PADOFFSET
Perl_pad_findmy_pvn(pTHX_ const char *namepv, STRLEN namelen, U32 flags)
{
    PADNAME *out_pn;
    int out_flags;
    I32 offset;
    const PADNAMELIST *namelist;
    PADNAME **name_p;

    PERL_ARGS_ASSERT_PAD_FINDMY_PVN;

    pad_peg("pad_findmy_pvn");

    if (flags)
	Perl_croak(aTHX_ "panic: pad_findmy_pvn illegal flag bits 0x%" UVxf,
		   (UV)flags);

    /* compilation errors can zero PL_compcv */
    if (!PL_compcv)
        return NOT_IN_PAD;

    offset = pad_findlex(namepv, namelen, flags,
                PL_compcv, PL_cop_seqmax, 1, NULL, &out_pn, &out_flags);
    if ((PADOFFSET)offset != NOT_IN_PAD) 
	return offset;

    /* Skip the ‘our’ hack for subroutines, as the warning does not apply.
     */
    if (*namepv == '&') return NOT_IN_PAD;

    /* look for an our that's being introduced; this allows
     *    our $foo = 0 unless defined $foo;
     * to not give a warning. (Yes, this is a hack) */

    namelist = PadlistNAMES(CvPADLIST(PL_compcv));
    name_p = PadnamelistARRAY(namelist);
    for (offset = PadnamelistMAXNAMED(namelist); offset > 0; offset--) {
        const PADNAME * const name = name_p[offset];
        if (name && PadnameLEN(name) == namelen
            && !PadnameOUTER(name)
            && (PadnameIsOUR(name))
            && (  PadnamePV(name) == namepv
               || memEQ(PadnamePV(name), namepv, namelen)  )
            && COP_SEQ_RANGE_LOW(name) == PERL_PADSEQ_INTRO
	)
	    return offset;
    }
    return NOT_IN_PAD;
}

/*
=for apidoc Am|PADOFFSET|pad_findmy_pv|const char *name|U32 flags

Exactly like L</pad_findmy_pvn>, but takes a nul-terminated string
instead of a string/length pair.

=cut
*/

PADOFFSET
Perl_pad_findmy_pv(pTHX_ const char *name, U32 flags)
{
    PERL_ARGS_ASSERT_PAD_FINDMY_PV;
    return pad_findmy_pvn(name, strlen(name), flags);
}

/*
=for apidoc Am|PADOFFSET|pad_findmy_sv|SV *name|U32 flags

Exactly like L</pad_findmy_pvn>, but takes the name string in the form
of an SV instead of a string/length pair.

=cut
*/

PADOFFSET
Perl_pad_findmy_sv(pTHX_ SV *name, U32 flags)
{
    char *namepv;
    STRLEN namelen;
    PERL_ARGS_ASSERT_PAD_FINDMY_SV;
    namepv = SvPVutf8(name, namelen);
    return pad_findmy_pvn(namepv, namelen, flags);
}

/*
=for apidoc Amp|PADOFFSET|find_rundefsvoffset

Until the lexical C<$_> feature was removed, this function would
find the position of the lexical C<$_> in the pad of the
currently-executing function and returns the offset in the current pad,
or C<NOT_IN_PAD>.

Now it always returns C<NOT_IN_PAD>.

=cut
*/

PADOFFSET
Perl_find_rundefsvoffset(pTHX)
{
    PERL_UNUSED_CONTEXT; /* Can we just remove the pTHX from the sig? */
    return NOT_IN_PAD;
}

/*
=for apidoc Am|SV *|find_rundefsv

Returns the global variable C<$_>.

=cut
*/

SV *
Perl_find_rundefsv(pTHX)
{
    return DEFSV;
}

/*
=for apidoc m|PADOFFSET|pad_findlex|const char *namepv|STRLEN namelen|U32 flags|const CV* cv|U32 seq|int warn|SV** out_capture|PADNAME** out_name|int *out_flags

Find a named lexical anywhere in a chain of nested pads.  Add fake entries
in the inner pads if it's found in an outer one.

Returns the offset in the bottom pad of the lex or the fake lex.
C<cv> is the CV in which to start the search, and seq is the current C<cop_seq>
to match against.  If C<warn> is true, print appropriate warnings.  The C<out_>*
vars return values, and so are pointers to where the returned values
should be stored.  C<out_capture>, if non-null, requests that the innermost
instance of the lexical is captured; C<out_name> is set to the innermost
matched pad name or fake pad name; C<out_flags> returns the flags normally
associated with the C<PARENT_FAKELEX_FLAGS> field of a fake pad name.

Note that C<pad_findlex()> is recursive; it recurses up the chain of CVs,
then comes back down, adding fake entries
as it goes.  It has to be this way
because fake names in anon protoypes have to store in C<xlow> the index into
the parent pad.

=cut
*/

/* the CV has finished being compiled. This is not a sufficient test for
 * all CVs (eg XSUBs), but suffices for the CVs found in a lexical chain */
#define CvCOMPILED(cv)	CvROOT(cv)

/* the CV does late binding of its lexicals */
#define CvLATE(cv) (CvANON(cv) || CvCLONE(cv) || SvTYPE(cv) == SVt_PVFM)

static void
S_unavailable(pTHX_ PADNAME *name)
{
    /* diag_listed_as: Variable "%s" is not available */
    Perl_ck_warner(aTHX_ packWARN(WARN_CLOSURE),
			"%se \"%"PNf"\" is not available",
			 *PadnamePV(name) == '&'
					 ? "Subroutin"
					 : "Variabl",
			 PNfARG(name));
}

STATIC PADOFFSET
S_pad_findlex(pTHX_ const char *namepv, STRLEN namelen, U32 flags, const CV* cv, U32 seq,
	int warn, SV** out_capture, PADNAME** out_name, int *out_flags)
{
    I32 offset, new_offset;
    SV *new_capture;
    SV **new_capturep;
    const PADLIST * const padlist = CvPADLIST(cv);
    const bool staleok = !!(flags & padadd_STALEOK);

    PERL_ARGS_ASSERT_PAD_FINDLEX;

    flags &= ~ padadd_STALEOK; /* one-shot flag */
    if (flags)
	Perl_croak(aTHX_ "panic: pad_findlex illegal flag bits 0x%" UVxf,
		   (UV)flags);

    *out_flags = 0;

    DEBUG_Xv(PerlIO_printf(Perl_debug_log,
	"Pad findlex cv=0x%"UVxf" searching \"%.*s\" seq=%d%s\n",
			   PTR2UV(cv), (int)namelen, namepv, (int)seq,
	out_capture ? " capturing" : "" ));

    /* first, search this pad */

    if (padlist) { /* not an undef CV */
	I32 fake_offset = 0;
        const PADNAMELIST * const names = PadlistNAMES(padlist);
	PADNAME * const * const name_p = PadnamelistARRAY(names);

	for (offset = PadnamelistMAXNAMED(names); offset > 0; offset--) {
            const PADNAME * const name = name_p[offset];
            if (name && PadnameLEN(name) == namelen
                     && (  PadnamePV(name) == namepv
                        || memEQ(PadnamePV(name), namepv, namelen)  ))
	    {
		if (PadnameOUTER(name)) {
		    fake_offset = offset; /* in case we don't find a real one */
		    continue;
		}
		if (PadnameIN_SCOPE(name, seq))
		    break;
	    }
	}

	if (offset > 0 || fake_offset > 0 ) { /* a match! */
	    if (offset > 0) { /* not fake */
		fake_offset = 0;
		*out_name = name_p[offset]; /* return the name */

		/* set PAD_FAKELEX_MULTI if this lex can have multiple
		 * instances. For now, we just test !CvUNIQUE(cv), but
		 * ideally, we should detect my's declared within loops
		 * etc - this would allow a wider range of 'not stayed
		 * shared' warnings. We also treated already-compiled
		 * lexes as not multi as viewed from evals. */

		*out_flags = CvANON(cv) ?
			PAD_FAKELEX_ANON :
			    (!CvUNIQUE(cv) && ! CvCOMPILED(cv))
				? PAD_FAKELEX_MULTI : 0;

		DEBUG_Xv(PerlIO_printf(Perl_debug_log,
		    "Pad findlex cv=0x%"UVxf" matched: offset=%ld (%lu,%lu)\n",
		    PTR2UV(cv), (long)offset,
		    (unsigned long)COP_SEQ_RANGE_LOW(*out_name),
		    (unsigned long)COP_SEQ_RANGE_HIGH(*out_name)));
	    }
	    else { /* fake match */
		offset = fake_offset;
		*out_name = name_p[offset]; /* return the name */
		*out_flags = PARENT_FAKELEX_FLAGS(*out_name);
		DEBUG_Xv(PerlIO_printf(Perl_debug_log,
		    "Pad findlex cv=0x%"UVxf" matched: offset=%ld flags=0x%lx index=%lu\n",
		    PTR2UV(cv), (long)offset, (unsigned long)*out_flags,
		    (unsigned long) PARENT_PAD_INDEX(*out_name) 
		));
	    }

	    /* return the lex? */

	    if (out_capture) {

		/* our ? */
		if (PadnameIsOUR(*out_name)) {
		    *out_capture = NULL;
		    return offset;
		}

		/* trying to capture from an anon prototype? */
		if (CvCOMPILED(cv)
			? CvANON(cv) && CvCLONE(cv) && !CvCLONED(cv)
			: *out_flags & PAD_FAKELEX_ANON)
		{
		    if (warn)
			S_unavailable(aTHX_
				      *out_name);

		    *out_capture = NULL;
		}

		/* real value */
		else {
		    int newwarn = warn;
		    if (!CvCOMPILED(cv) && (*out_flags & PAD_FAKELEX_MULTI)
			 && !PadnameIsSTATE(name_p[offset])
			 && warn && ckWARN(WARN_CLOSURE)) {
			newwarn = 0;
			/* diag_listed_as: Variable "%s" will not stay
					   shared */
			Perl_warner(aTHX_ packWARN(WARN_CLOSURE),
			    "%se \"%"UTF8f"\" will not stay shared",
			     *namepv == '&' ? "Subroutin" : "Variabl",
			     UTF8fARG(1, namelen, namepv));
		    }

		    if (fake_offset && CvANON(cv)
			    && CvCLONE(cv) &&!CvCLONED(cv))
		    {
			PADNAME *n;
			/* not yet caught - look further up */
			DEBUG_Xv(PerlIO_printf(Perl_debug_log,
			    "Pad findlex cv=0x%"UVxf" chasing lex in outer pad\n",
			    PTR2UV(cv)));
			n = *out_name;
			(void) pad_findlex(namepv, namelen, flags, CvOUTSIDE(cv),
			    CvOUTSIDE_SEQ(cv),
			    newwarn, out_capture, out_name, out_flags);
			*out_name = n;
			return offset;
		    }

		    *out_capture = AvARRAY(PadlistARRAY(padlist)[
				    CvDEPTH(cv) ? CvDEPTH(cv) : 1])[offset];
		    DEBUG_Xv(PerlIO_printf(Perl_debug_log,
			"Pad findlex cv=0x%"UVxf" found lex=0x%"UVxf"\n",
			PTR2UV(cv), PTR2UV(*out_capture)));

		    if (SvPADSTALE(*out_capture)
			&& (!CvDEPTH(cv) || !staleok)
			&& !PadnameIsSTATE(name_p[offset]))
		    {
			S_unavailable(aTHX_
				      name_p[offset]);
			*out_capture = NULL;
		    }
		}
		if (!*out_capture) {
		    if (namelen != 0 && *namepv == '@@')
			*out_capture = sv_2mortal(MUTABLE_SV(newAV()));
		    else if (namelen != 0 && *namepv == '%')
			*out_capture = sv_2mortal(MUTABLE_SV(newHV()));
		    else if (namelen != 0 && *namepv == '&')
			*out_capture = sv_2mortal(newSV_type(SVt_PVCV));
		    else
			*out_capture = sv_newmortal();
		}
	    }

	    return offset;
	}
    }

    /* it's not in this pad - try above */

    if (!CvOUTSIDE(cv))
	return NOT_IN_PAD;

    /* out_capture non-null means caller wants us to capture lex; in
     * addition we capture ourselves unless it's an ANON/format */
    new_capturep = out_capture ? out_capture :
		CvLATE(cv) ? NULL : &new_capture;

    offset = pad_findlex(namepv, namelen,
		flags | padadd_STALEOK*(new_capturep == &new_capture),
		CvOUTSIDE(cv), CvOUTSIDE_SEQ(cv), 1,
		new_capturep, out_name, out_flags);
    if ((PADOFFSET)offset == NOT_IN_PAD)
	return NOT_IN_PAD;

    /* found in an outer CV. Add appropriate fake entry to this pad */

    /* don't add new fake entries (via eval) to CVs that we have already
     * finished compiling, or to undef CVs */
    if (CvCOMPILED(cv) || !padlist)
	return 0; /* this dummy (and invalid) value isnt used by the caller */

    {
	PADNAME *new_name = newPADNAMEouter(*out_name);
	PADNAMELIST * const ocomppad_name = PL_comppad_name;
	PAD * const ocomppad = PL_comppad;
	PL_comppad_name = PadlistNAMES(padlist);
	PL_comppad = PadlistARRAY(padlist)[1];
	PL_curpad = AvARRAY(PL_comppad);

	new_offset
	    = pad_alloc_name(new_name,
			      PadnameIsSTATE(*out_name) ? padadd_STATE : 0,
			      PadnameTYPE(*out_name),
			      PadnameOURSTASH(*out_name)
			      );

	DEBUG_Xv(PerlIO_printf(Perl_debug_log,
			       "Pad addname: %ld \"%.*s\" FAKE\n",
			       (long)new_offset,
			       (int) PadnameLEN(new_name),
			       PadnamePV(new_name)));
	PARENT_FAKELEX_FLAGS_set(new_name, *out_flags);

	PARENT_PAD_INDEX_set(new_name, 0);
	if (PadnameIsOUR(new_name)) {
	    NOOP;   /* do nothing */
	}
	else if (CvLATE(cv)) {
	    /* delayed creation - just note the offset within parent pad */
	    PARENT_PAD_INDEX_set(new_name, offset);
	    CvCLONE_on(cv);
	}
	else {
	    /* immediate creation - capture outer value right now */
	    av_store(PL_comppad, new_offset, SvREFCNT_inc(*new_capturep));
	    /* But also note the offset, as newMYSUB needs it */
	    PARENT_PAD_INDEX_set(new_name, offset);
	    DEBUG_Xv(PerlIO_printf(Perl_debug_log,
		"Pad findlex cv=0x%"UVxf" saved captured sv 0x%"UVxf" at offset %ld\n",
		PTR2UV(cv), PTR2UV(*new_capturep), (long)new_offset));
	}
	*out_name = new_name;
	*out_flags = PARENT_FAKELEX_FLAGS(new_name);

	PL_comppad_name = ocomppad_name;
	PL_comppad = ocomppad;
	PL_curpad = ocomppad ? AvARRAY(ocomppad) : NULL;
    }
    return new_offset;
}

#ifdef DEBUGGING

/*
=for apidoc Am|SV *|pad_sv|PADOFFSET po

Get the value at offset C<po> in the current (compiling or executing) pad.
Use macro C<PAD_SV> instead of calling this function directly.

=cut
*/

SV *
Perl_pad_sv(pTHX_ PADOFFSET po)
{
    ASSERT_CURPAD_ACTIVE("pad_sv");

    if (!po)
	Perl_croak(aTHX_ "panic: pad_sv po");
    DEBUG_X(PerlIO_printf(Perl_debug_log,
	"Pad 0x%"UVxf"[0x%"UVxf"] sv:      %ld sv=0x%"UVxf"\n",
	PTR2UV(PL_comppad), PTR2UV(PL_curpad), (long)po, PTR2UV(PL_curpad[po]))
    );
    return PL_curpad[po];
}

/*
=for apidoc Am|void|pad_setsv|PADOFFSET po|SV *sv

Set the value at offset C<po> in the current (compiling or executing) pad.
Use the macro C<PAD_SETSV()> rather than calling this function directly.

=cut
*/

void
Perl_pad_setsv(pTHX_ PADOFFSET po, SV* sv)
{
    PERL_ARGS_ASSERT_PAD_SETSV;

    ASSERT_CURPAD_ACTIVE("pad_setsv");

    DEBUG_X(PerlIO_printf(Perl_debug_log,
	"Pad 0x%"UVxf"[0x%"UVxf"] setsv:   %ld sv=0x%"UVxf"\n",
	PTR2UV(PL_comppad), PTR2UV(PL_curpad), (long)po, PTR2UV(sv))
    );
    PL_curpad[po] = sv;
}

#endif /* DEBUGGING */

/*
=for apidoc m|void|pad_block_start|int full

Update the pad compilation state variables on entry to a new block.

=cut
*/

/* XXX DAPM perhaps:
 * 	- integrate this in general state-saving routine ???
 * 	- combine with the state-saving going on in pad_new ???
 * 	- introduce a new SAVE type that does all this in one go ?
 */

void
Perl_pad_block_start(pTHX_ int full)
{
    ASSERT_CURPAD_ACTIVE("pad_block_start");
    SAVEI32(PL_comppad_name_floor);
    PL_comppad_name_floor = PadnamelistMAX(PL_comppad_name);
    if (full)
	PL_comppad_name_fill = PL_comppad_name_floor;
    if (PL_comppad_name_floor < 0)
	PL_comppad_name_floor = 0;
    SAVEI32(PL_min_intro_pending);
    SAVEI32(PL_max_intro_pending);
    PL_min_intro_pending = 0;
    SAVEI32(PL_comppad_name_fill);
    SAVEI32(PL_padix_floor);
    /* PL_padix_floor is what PL_padix is reset to at the start of each
       statement, by pad_reset().  We set it when entering a new scope
       to keep things like this working:
	    print "$foo$bar", do { this(); that() . "foo" };
       We must not let "$foo$bar" and the later concatenation share the
       same target.  */
    PL_padix_floor = PL_padix;
    PL_pad_reset_pending = FALSE;
}

/*
=for apidoc Am|U32|intro_my

"Introduce" C<my> variables to visible status.  This is called during parsing
at the end of each statement to make lexical variables visible to subsequent
statements.

=cut
*/

U32
Perl_intro_my(pTHX)
{
    PADNAME **svp;
    I32 i;
    U32 seq;

    ASSERT_CURPAD_ACTIVE("intro_my");
    if (PL_compiling.cop_seq) {
	seq = PL_compiling.cop_seq;
	PL_compiling.cop_seq = 0;
    }
    else
	seq = PL_cop_seqmax;
    if (! PL_min_intro_pending)
	return seq;

    svp = PadnamelistARRAY(PL_comppad_name);
    for (i = PL_min_intro_pending; i <= PL_max_intro_pending; i++) {
	PADNAME * const sv = svp[i];

	if (sv && PadnameLEN(sv) && !PadnameOUTER(sv)
	    && COP_SEQ_RANGE_LOW(sv) == PERL_PADSEQ_INTRO)
	{
	    COP_SEQ_RANGE_HIGH_set(sv, PERL_PADSEQ_INTRO); /* Don't know scope end yet. */
	    COP_SEQ_RANGE_LOW_set(sv, PL_cop_seqmax);
	    DEBUG_Xv(PerlIO_printf(Perl_debug_log,
		"Pad intromy: %ld \"%s\", (%lu,%lu)\n",
		(long)i, PadnamePV(sv),
		(unsigned long)COP_SEQ_RANGE_LOW(sv),
		(unsigned long)COP_SEQ_RANGE_HIGH(sv))
	    );
	}
    }
    COP_SEQMAX_INC;
    PL_min_intro_pending = 0;
    PL_comppad_name_fill = PL_max_intro_pending; /* Needn't search higher */
    DEBUG_Xv(PerlIO_printf(Perl_debug_log,
		"Pad intromy: seq -> %ld\n", (long)(PL_cop_seqmax)));

    return seq;
}

/*
=for apidoc m|void|pad_leavemy

Cleanup at end of scope during compilation: set the max seq number for
lexicals in this scope and warn of any lexicals that never got introduced.

=cut
*/

OP *
Perl_pad_leavemy(pTHX)
{
    I32 off;
    OP *o = NULL;
    PADNAME * const * const svp = PadnamelistARRAY(PL_comppad_name);

    PL_pad_reset_pending = FALSE;

    ASSERT_CURPAD_ACTIVE("pad_leavemy");
    if (PL_min_intro_pending && PL_comppad_name_fill < PL_min_intro_pending) {
	for (off = PL_max_intro_pending; off >= PL_min_intro_pending; off--) {
	    const PADNAME * const name = svp[off];
	    if (name && PadnameLEN(name) && !PadnameOUTER(name))
		Perl_ck_warner_d(aTHX_ packWARN(WARN_INTERNAL),
				      "%"PNf" never introduced",
				       PNfARG(name));
	}
    }
    /* "Deintroduce" my variables that are leaving with this scope. */
    for (off = PadnamelistMAX(PL_comppad_name);
	 off > PL_comppad_name_fill; off--) {
	PADNAME * const sv = svp[off];
	if (sv && PadnameLEN(sv) && !PadnameOUTER(sv)
	    && COP_SEQ_RANGE_HIGH(sv) == PERL_PADSEQ_INTRO)
	{
	    COP_SEQ_RANGE_HIGH_set(sv, PL_cop_seqmax);
	    DEBUG_Xv(PerlIO_printf(Perl_debug_log,
		"Pad leavemy: %ld \"%s\", (%lu,%lu)\n",
		(long)off, PadnamePV(sv),
		(unsigned long)COP_SEQ_RANGE_LOW(sv),
		(unsigned long)COP_SEQ_RANGE_HIGH(sv))
	    );
	    if (!PadnameIsSTATE(sv) && !PadnameIsOUR(sv)
	     && *PadnamePV(sv) == '&' && PadnameLEN(sv) > 1) {
		OP *kid = newOP(OP_INTROCV, 0);
		kid->op_targ = off;
		o = op_prepend_elem(OP_LINESEQ, kid, o);
	    }
	}
    }
    COP_SEQMAX_INC;
    DEBUG_Xv(PerlIO_printf(Perl_debug_log,
	    "Pad leavemy: seq = %ld\n", (long)PL_cop_seqmax));
    return o;
}

/*
=for apidoc m|void|pad_swipe|PADOFFSET po|bool refadjust

Abandon the tmp in the current pad at offset C<po> and replace with a
new one.

=cut
*/

void
Perl_pad_swipe(pTHX_ PADOFFSET po, bool refadjust)
{
    ASSERT_CURPAD_LEGAL("pad_swipe");
    if (!PL_curpad)
	return;
    if (AvARRAY(PL_comppad) != PL_curpad)
	Perl_croak(aTHX_ "panic: pad_swipe curpad, %p!=%p",
		   AvARRAY(PL_comppad), PL_curpad);
    if (!po || ((SSize_t)po) > AvFILLp(PL_comppad))
	Perl_croak(aTHX_ "panic: pad_swipe po=%ld, fill=%ld",
		   (long)po, (long)AvFILLp(PL_comppad));

    DEBUG_X(PerlIO_printf(Perl_debug_log,
		"Pad 0x%"UVxf"[0x%"UVxf"] swipe:   %ld\n",
		PTR2UV(PL_comppad), PTR2UV(PL_curpad), (long)po));

    if (refadjust)
	SvREFCNT_dec(PL_curpad[po]);


    /* if pad tmps aren't shared between ops, then there's no need to
     * create a new tmp when an existing op is freed */
#ifdef USE_PAD_RESET
    PL_curpad[po] = newSV(0);
    SvPADTMP_on(PL_curpad[po]);
#else
    PL_curpad[po] = NULL;
#endif
    if (PadnamelistMAX(PL_comppad_name) != -1
     && (PADOFFSET)PadnamelistMAX(PL_comppad_name) >= po) {
	if (PadnamelistARRAY(PL_comppad_name)[po]) {
	    assert(!PadnameLEN(PadnamelistARRAY(PL_comppad_name)[po]));
	}
	PadnamelistARRAY(PL_comppad_name)[po] = &PL_padname_undef;
    }
    /* Use PL_constpadix here, not PL_padix.  The latter may have been
       reset by pad_reset.  We don’t want pad_alloc to have to scan the
       whole pad when allocating a constant. */
    if ((I32)po < PL_constpadix)
	PL_constpadix = po - 1;
}

/*
=for apidoc m|void|pad_reset

Mark all the current temporaries for reuse

=cut
*/

/* pad_reset() causes pad temp TARGs (operator targets) to be shared
 * between OPs from different statements.  During compilation, at the start
 * of each statement pad_reset resets PL_padix back to its previous value.
 * When allocating a target, pad_alloc begins its scan through the pad at
 * PL_padix+1.  */
static void
S_pad_reset(pTHX)
{
#ifdef USE_PAD_RESET
    if (AvARRAY(PL_comppad) != PL_curpad)
	Perl_croak(aTHX_ "panic: pad_reset curpad, %p!=%p",
		   AvARRAY(PL_comppad), PL_curpad);

    DEBUG_X(PerlIO_printf(Perl_debug_log,
	    "Pad 0x%"UVxf"[0x%"UVxf"] reset:     padix %ld -> %ld",
	    PTR2UV(PL_comppad), PTR2UV(PL_curpad),
		(long)PL_padix, (long)PL_padix_floor
	    )
    );

    if (!TAINTING_get) {	/* Can't mix tainted and non-tainted temporaries. */
	PL_padix = PL_padix_floor;
    }
#endif
    PL_pad_reset_pending = FALSE;
}

/*
=for apidoc Amx|void|pad_tidy|padtidy_type type

Tidy up a pad at the end of compilation of the code to which it belongs.
Jobs performed here are: remove most stuff from the pads of anonsub
prototypes; give it a C<@@_>; mark temporaries as such.  C<type> indicates
the kind of subroutine:

    padtidy_SUB        ordinary subroutine
    padtidy_SUBCLONE   prototype for lexical closure
    padtidy_FORMAT     format

=cut
*/

/* XXX DAPM surely most of this stuff should be done properly
 * at the right time beforehand, rather than going around afterwards
 * cleaning up our mistakes ???
 */

void
Perl_pad_tidy(pTHX_ padtidy_type type)
{
    dVAR;

    ASSERT_CURPAD_ACTIVE("pad_tidy");

    /* If this CV has had any 'eval-capable' ops planted in it:
     * i.e. it contains any of:
     *
     *     * eval '...',
     *     * //ee,
     *     * use re 'eval'; /$var/
     *     * /(?{..})/),
     *
     * Then any anon prototypes in the chain of CVs should be marked as
     * cloneable, so that for example the eval's CV in
     *
     *    sub { eval '$x' }
     *
     * gets the right CvOUTSIDE.  If running with -d, *any* sub may
     * potentially have an eval executed within it.
     */

    if (PL_cv_has_eval || PL_perldb) {
        const CV *cv;
	for (cv = PL_compcv ;cv; cv = CvOUTSIDE(cv)) {
	    if (cv != PL_compcv && CvCOMPILED(cv))
		break; /* no need to mark already-compiled code */
	    if (CvANON(cv)) {
		DEBUG_Xv(PerlIO_printf(Perl_debug_log,
		    "Pad clone on cv=0x%"UVxf"\n", PTR2UV(cv)));
		CvCLONE_on(cv);
	    }
	    CvHASEVAL_on(cv);
	}
    }

    /* extend namepad to match curpad */
    if (PadnamelistMAX(PL_comppad_name) < AvFILLp(PL_comppad))
	padnamelist_store(PL_comppad_name, AvFILLp(PL_comppad), NULL);

    if (type == padtidy_SUBCLONE) {
	PADNAME ** const namep = PadnamelistARRAY(PL_comppad_name);
	PADOFFSET ix;

	for (ix = AvFILLp(PL_comppad); ix > 0; ix--) {
	    PADNAME *namesv;
	    if (!namep[ix]) namep[ix] = &PL_padname_undef;

	    /*
	     * The only things that a clonable function needs in its
	     * pad are anonymous subs, constants and GVs.
	     * The rest are created anew during cloning.
	     */
	    if (!PL_curpad[ix] || SvIMMORTAL(PL_curpad[ix]))
		continue;
	    namesv = namep[ix];
	    if (!(PadnamePV(namesv) &&
		   (!PadnameLEN(namesv) || *PadnamePV(namesv) == '&')))
	    {
		SvREFCNT_dec(PL_curpad[ix]);
		PL_curpad[ix] = NULL;
	    }
	}
    }
    else if (type == padtidy_SUB) {
	/* XXX DAPM this same bit of code keeps appearing !!! Rationalise? */
	AV * const av = newAV();			/* Will be @@_ */
	av_store(PL_comppad, 0, MUTABLE_SV(av));
	AvREIFY_only(av);
    }

    if (type == padtidy_SUB || type == padtidy_FORMAT) {
	PADNAME ** const namep = PadnamelistARRAY(PL_comppad_name);
	PADOFFSET ix;
	for (ix = AvFILLp(PL_comppad); ix > 0; ix--) {
	    if (!namep[ix]) namep[ix] = &PL_padname_undef;
	    if (!PL_curpad[ix] || SvIMMORTAL(PL_curpad[ix]))
		continue;
	    if (SvPADMY(PL_curpad[ix]) && !PadnameOUTER(namep[ix])) {
		/* This is a work around for how the current implementation of
		   ?{ } blocks in regexps interacts with lexicals.

		   One of our lexicals.
		   Can't do this on all lexicals, otherwise sub baz() won't
		   compile in

		   my $foo;

		   sub bar { ++$foo; }

		   sub baz { ++$foo; }

		   because completion of compiling &bar calling pad_tidy()
		   would cause (top level) $foo to be marked as stale, and
		   "no longer available".  */
		SvPADSTALE_on(PL_curpad[ix]);
	    }
	}
    }
    PL_curpad = AvARRAY(PL_comppad);
}

/*
=for apidoc m|void|pad_free|PADOFFSET po

Free the SV at offset po in the current pad.

=cut
*/

/* XXX DAPM integrate with pad_swipe ???? */
void
Perl_pad_free(pTHX_ PADOFFSET po)
{
#ifndef USE_PAD_RESET
    SV *sv;
#endif
    ASSERT_CURPAD_LEGAL("pad_free");
    if (!PL_curpad)
	return;
    if (AvARRAY(PL_comppad) != PL_curpad)
	Perl_croak(aTHX_ "panic: pad_free curpad, %p!=%p",
		   AvARRAY(PL_comppad), PL_curpad);
    if (!po)
	Perl_croak(aTHX_ "panic: pad_free po");

    DEBUG_X(PerlIO_printf(Perl_debug_log,
	    "Pad 0x%"UVxf"[0x%"UVxf"] free:    %ld\n",
	    PTR2UV(PL_comppad), PTR2UV(PL_curpad), (long)po)
    );

#ifndef USE_PAD_RESET
    sv = PL_curpad[po];
    if (sv && sv != &PL_sv_undef && !SvPADMY(sv))
	SvFLAGS(sv) &= ~SVs_PADTMP;

    if ((I32)po < PL_padix)
	PL_padix = po - 1;
#endif
}

/*
=for apidoc m|void|do_dump_pad|I32 level|PerlIO *file|PADLIST *padlist|int full

Dump the contents of a padlist

=cut
*/

void
Perl_do_dump_pad(pTHX_ I32 level, PerlIO *file, PADLIST *padlist, int full)
{
    const PADNAMELIST *pad_name;
    const AV *pad;
    PADNAME **pname;
    SV **ppad;
    I32 ix;

    PERL_ARGS_ASSERT_DO_DUMP_PAD;

    if (!padlist) {
	return;
    }
    pad_name = PadlistNAMES(padlist);
    pad = PadlistARRAY(padlist)[1];
    pname = PadnamelistARRAY(pad_name);
    ppad = AvARRAY(pad);
    Perl_dump_indent(aTHX_ level, file,
	    "PADNAME = 0x%"UVxf"(0x%"UVxf") PAD = 0x%"UVxf"(0x%"UVxf")\n",
	    PTR2UV(pad_name), PTR2UV(pname), PTR2UV(pad), PTR2UV(ppad)
    );

    for (ix = 1; ix <= PadnamelistMAX(pad_name); ix++) {
        const PADNAME *namesv = pname[ix];
	if (namesv && !PadnameLEN(namesv)) {
	    namesv = NULL;
	}
	if (namesv) {
	    if (PadnameOUTER(namesv))
		Perl_dump_indent(aTHX_ level+1, file,
		    "%2d. 0x%"UVxf"<%lu> FAKE \"%s\" flags=0x%lx index=%lu\n",
		    (int) ix,
		    PTR2UV(ppad[ix]),
		    (unsigned long) (ppad[ix] ? SvREFCNT(ppad[ix]) : 0),
		    PadnamePV(namesv),
		    (unsigned long)PARENT_FAKELEX_FLAGS(namesv),
		    (unsigned long)PARENT_PAD_INDEX(namesv)

		);
	    else
		Perl_dump_indent(aTHX_ level+1, file,
		    "%2d. 0x%"UVxf"<%lu> (%lu,%lu) \"%s\"\n",
		    (int) ix,
		    PTR2UV(ppad[ix]),
		    (unsigned long) (ppad[ix] ? SvREFCNT(ppad[ix]) : 0),
		    (unsigned long)COP_SEQ_RANGE_LOW(namesv),
		    (unsigned long)COP_SEQ_RANGE_HIGH(namesv),
		    PadnamePV(namesv)
		);
	}
	else if (full) {
	    Perl_dump_indent(aTHX_ level+1, file,
		"%2d. 0x%"UVxf"<%lu>\n",
		(int) ix,
		PTR2UV(ppad[ix]),
		(unsigned long) (ppad[ix] ? SvREFCNT(ppad[ix]) : 0)
	    );
	}
    }
}

#ifdef DEBUGGING

/*
=for apidoc m|void|cv_dump|CV *cv|const char *title

dump the contents of a CV

=cut
*/

STATIC void
S_cv_dump(pTHX_ const CV *cv, const char *title)
{
    const CV * const outside = CvOUTSIDE(cv);
    PADLIST* const padlist = CvPADLIST(cv);

    PERL_ARGS_ASSERT_CV_DUMP;

    PerlIO_printf(Perl_debug_log,
		  "  %s: CV=0x%"UVxf" (%s), OUTSIDE=0x%"UVxf" (%s)\n",
		  title,
		  PTR2UV(cv),
		  (CvANON(cv) ? "ANON"
		   : (SvTYPE(cv) == SVt_PVFM) ? "FORMAT"
		   : (cv == PL_main_cv) ? "MAIN"
		   : CvUNIQUE(cv) ? "UNIQUE"
		   : CvGV(cv) ? GvNAME(CvGV(cv)) : "UNDEFINED"),
		  PTR2UV(outside),
		  (!outside ? "null"
		   : CvANON(outside) ? "ANON"
		   : (outside == PL_main_cv) ? "MAIN"
		   : CvUNIQUE(outside) ? "UNIQUE"
		   : CvGV(outside) ? GvNAME(CvGV(outside)) : "UNDEFINED"));

    PerlIO_printf(Perl_debug_log,
		    "    PADLIST = 0x%"UVxf"\n", PTR2UV(padlist));
    do_dump_pad(1, Perl_debug_log, padlist, 1);
}

#endif /* DEBUGGING */

/*
=for apidoc Am|CV *|cv_clone|CV *proto

Clone a CV, making a lexical closure.  C<proto> supplies the prototype
of the function: its code, pad structure, and other attributes.
The prototype is combined with a capture of outer lexicals to which the
code refers, which are taken from the currently-executing instance of
the immediately surrounding code.

=cut
*/

static CV *S_cv_clone(pTHX_ CV *proto, CV *cv, CV *outside, HV *cloned);

static CV *
S_cv_clone_pad(pTHX_ CV *proto, CV *cv, CV *outside, HV *cloned,
		     bool newcv)
{
    I32 ix;
    PADLIST* const protopadlist = CvPADLIST(proto);
    PADNAMELIST *const protopad_name = PadlistNAMES(protopadlist);
    const PAD *const protopad = PadlistARRAY(protopadlist)[1];
    PADNAME** const pname = PadnamelistARRAY(protopad_name);
    SV** const ppad = AvARRAY(protopad);
    const I32 fname = PadnamelistMAX(protopad_name);
    const I32 fpad = AvFILLp(protopad);
    SV** outpad;
    long depth;
    U32 subclones = 0;
    bool trouble = FALSE;

    assert(!CvUNIQUE(proto));

    /* Anonymous subs have a weak CvOUTSIDE pointer, so its value is not
     * reliable.  The currently-running sub is always the one we need to
     * close over.
     * For my subs, the currently-running sub may not be the one we want.
     * We have to check whether it is a clone of CvOUTSIDE.
     * Note that in general for formats, CvOUTSIDE != find_runcv.
     * Since formats may be nested inside closures, CvOUTSIDE may point
     * to a prototype; we instead want the cloned parent who called us.
     */

    if (!outside) {
      if (CvWEAKOUTSIDE(proto))
	outside = find_runcv(NULL);
      else {
	outside = CvOUTSIDE(proto);
	if ((CvCLONE(outside) && ! CvCLONED(outside))
	    || !CvPADLIST(outside)
	    || CvPADLIST(outside)->xpadl_id != protopadlist->xpadl_outid) {
	    outside = find_runcv_where(
		FIND_RUNCV_padid_eq, PTR2IV(protopadlist->xpadl_outid), NULL
	    );
	    /* outside could be null */
	}
      }
    }
    depth = outside ? CvDEPTH(outside) : 0;
    if (!depth)
	depth = 1;

    ENTER;
    SAVESPTR(PL_compcv);
    PL_compcv = cv;
    if (newcv) SAVEFREESV(cv); /* in case of fatal warnings */

    if (CvHASEVAL(cv))
	CvOUTSIDE(cv)	= MUTABLE_CV(SvREFCNT_inc_simple(outside));

    SAVESPTR(PL_comppad_name);
    PL_comppad_name = protopad_name;
    CvPADLIST_set(cv, pad_new(padnew_CLONE|padnew_SAVE));
    CvPADLIST(cv)->xpadl_id = protopadlist->xpadl_id;

    av_fill(PL_comppad, fpad);

    PL_curpad = AvARRAY(PL_comppad);

    outpad = outside && CvPADLIST(outside)
	? AvARRAY(PadlistARRAY(CvPADLIST(outside))[depth])
	: NULL;
    if (outpad) CvPADLIST(cv)->xpadl_outid = CvPADLIST(outside)->xpadl_id;

    for (ix = fpad; ix > 0; ix--) {
	PADNAME* const namesv = (ix <= fname) ? pname[ix] : NULL;
	SV *sv = NULL;
	if (namesv && PadnameLEN(namesv)) { /* lexical */
	  if (PadnameIsOUR(namesv)) { /* or maybe not so lexical */
		NOOP;
	  }
	  else {
	    if (PadnameOUTER(namesv)) {   /* lexical from outside? */
		/* formats may have an inactive, or even undefined, parent;
		   but state vars are always available. */
		if (!outpad || !(sv = outpad[PARENT_PAD_INDEX(namesv)])
		 || (  SvPADSTALE(sv) && !SvPAD_STATE(namesv)
		    && (!outside || !CvDEPTH(outside)))  ) {
		    S_unavailable(aTHX_ namesv);
		    sv = NULL;
		}
		else 
		    SvREFCNT_inc_simple_void_NN(sv);
	    }
	    if (!sv) {
                const char sigil = PadnamePV(namesv)[0];
                if (sigil == '&')
		    /* If there are state subs, we need to clone them, too.
		       But they may need to close over variables we have
		       not cloned yet.  So we will have to do a second
		       pass.  Furthermore, there may be state subs clos-
		       ing over other state subs’ entries, so we have
		       to put a stub here and then clone into it on the
		       second pass. */
		    if (SvPAD_STATE(namesv) && !CvCLONED(ppad[ix])) {
			assert(SvTYPE(ppad[ix]) == SVt_PVCV);
			subclones ++;
			if (CvOUTSIDE(ppad[ix]) != proto)
			     trouble = TRUE;
			sv = newSV_type(SVt_PVCV);
			CvLEXICAL_on(sv);
		    }
		    else if (PadnameLEN(namesv)>1 && !PadnameIsOUR(namesv))
		    {
			/* my sub */
			/* Just provide a stub, but name it.  It will be
			   upgrade to the real thing on scope entry. */
                        dVAR;
			U32 hash;
			PERL_HASH(hash, PadnamePV(namesv)+1,
				  PadnameLEN(namesv) - 1);
			sv = newSV_type(SVt_PVCV);
			CvNAME_HEK_set(
			    sv,
			    share_hek(PadnamePV(namesv)+1,
				      1 - PadnameLEN(namesv),
				      hash)
			);
			CvLEXICAL_on(sv);
		    }
		    else sv = SvREFCNT_inc(ppad[ix]);
                else if (sigil == '@@')
		    sv = MUTABLE_SV(newAV());
                else if (sigil == '%')
		    sv = MUTABLE_SV(newHV());
		else
		    sv = newSV(0);
		/* reset the 'assign only once' flag on each state var */
		if (sigil != '&' && SvPAD_STATE(namesv))
		    SvPADSTALE_on(sv);
	    }
	  }
	}
	else if (namesv && PadnamePV(namesv)) {
	    sv = SvREFCNT_inc_NN(ppad[ix]);
	}
	else {
	    sv = newSV(0);
	    SvPADTMP_on(sv);
	}
	PL_curpad[ix] = sv;
    }

    if (subclones)
    {
	if (trouble || cloned) {
	    /* Uh-oh, we have trouble!  At least one of the state subs here
	       has its CvOUTSIDE pointer pointing somewhere unexpected.  It
	       could be pointing to another state protosub that we are
	       about to clone.  So we have to track which sub clones come
	       from which protosubs.  If the CvOUTSIDE pointer for a parti-
	       cular sub points to something we have not cloned yet, we
	       delay cloning it.  We must loop through the pad entries,
	       until we get a full pass with no cloning.  If any uncloned
	       subs remain (probably nested inside anonymous or ‘my’ subs),
	       then they get cloned in a final pass.
	     */
	    bool cloned_in_this_pass;
	    if (!cloned)
		cloned = (HV *)sv_2mortal((SV *)newHV());
	    do {
		cloned_in_this_pass = FALSE;
		for (ix = fpad; ix > 0; ix--) {
		    PADNAME * const name =
			(ix <= fname) ? pname[ix] : NULL;
		    if (name && name != &PL_padname_undef
		     && !PadnameOUTER(name) && PadnamePV(name)[0] == '&'
		     && PadnameIsSTATE(name) && !CvCLONED(PL_curpad[ix]))
		    {
			CV * const protokey = CvOUTSIDE(ppad[ix]);
			CV ** const cvp = protokey == proto
			    ? &cv
			    : (CV **)hv_fetch(cloned, (char *)&protokey,
					      sizeof(CV *), 0);
			if (cvp && *cvp) {
			    S_cv_clone(aTHX_ (CV *)ppad[ix],
					     (CV *)PL_curpad[ix],
					     *cvp, cloned);
			    (void)hv_store(cloned, (char *)&ppad[ix],
				     sizeof(CV *),
				     SvREFCNT_inc_simple_NN(PL_curpad[ix]),
				     0);
			    subclones--;
			    cloned_in_this_pass = TRUE;
			}
		    }
		}
	    } while (cloned_in_this_pass);
	    if (subclones)
		for (ix = fpad; ix > 0; ix--) {
		    PADNAME * const name =
			(ix <= fname) ? pname[ix] : NULL;
		    if (name && name != &PL_padname_undef
		     && !PadnameOUTER(name) && PadnamePV(name)[0] == '&'
		     && PadnameIsSTATE(name) && !CvCLONED(PL_curpad[ix]))
			S_cv_clone(aTHX_ (CV *)ppad[ix],
					 (CV *)PL_curpad[ix],
					 CvOUTSIDE(ppad[ix]), cloned);
		}
	}
	else for (ix = fpad; ix > 0; ix--) {
	    PADNAME * const name = (ix <= fname) ? pname[ix] : NULL;
	    if (name && name != &PL_padname_undef && !PadnameOUTER(name)
	     && PadnamePV(name)[0] == '&' && PadnameIsSTATE(name))
		S_cv_clone(aTHX_ (CV *)ppad[ix], (CV *)PL_curpad[ix], cv,
				 NULL);
	}
    }

    if (newcv) SvREFCNT_inc_simple_void_NN(cv);
    LEAVE;

    if (CvCONST(cv)) {
	/* Constant sub () { $x } closing over $x:
	 * The prototype was marked as a candiate for const-ization,
	 * so try to grab the current const value, and if successful,
	 * turn into a const sub:
	 */
	SV* const_sv;
	OP *o = CvSTART(cv);
	assert(newcv);
	for (; o; o = o->op_next)
	    if (o->op_type == OP_PADSV)
		break;
	ASSUME(o->op_type == OP_PADSV);
	const_sv = PAD_BASE_SV(CvPADLIST(cv), o->op_targ);
	/* the candidate should have 1 ref from this pad and 1 ref
	 * from the parent */
	if (const_sv && SvREFCNT(const_sv) == 2) {
	    const bool was_method = cBOOL(CvMETHOD(cv));
	    bool copied = FALSE;
	    if (outside) {
		PADNAME * const pn =
		    PadlistNAMESARRAY(CvPADLIST(outside))
			[PARENT_PAD_INDEX(PadlistNAMESARRAY(
			    CvPADLIST(cv))[o->op_targ])];
		assert(PadnameOUTER(PadlistNAMESARRAY(CvPADLIST(cv))
					[o->op_targ]));
		if (PadnameLVALUE(pn)) {
		    /* We have a lexical that is potentially modifiable
		       elsewhere, so making a constant will break clo-
		       sure behaviour.  If this is a ‘simple lexical
		       op tree’, i.e., sub(){$x}, emit a deprecation
		       warning, but continue to exhibit the old behav-
		       iour of making it a constant based on the ref-
		       count of the candidate variable.

		       A simple lexical op tree looks like this:

		         leavesub
			   lineseq
			     nextstate
			     padsv
		     */
		    if (OpSIBLING(
			 cUNOPx(cUNOPx(CvROOT(cv))->op_first)->op_first
			) == o
		     && !OpSIBLING(o))
		    {
			Perl_ck_warner_d(aTHX_
					  packWARN(WARN_DEPRECATED),
					 "Constants from lexical "
					 "variables potentially "
					 "modified elsewhere are "
					 "deprecated");
			/* We *copy* the lexical variable, and donate the
			   copy to newCONSTSUB.  Yes, this is ugly, and
			   should be killed.  We need to do this for the
			   time being, however, because turning on SvPADTMP
			   on a lexical will have observable effects
			   elsewhere.  */
			const_sv = newSVsv(const_sv);
			copied = TRUE;
		    }
		    else
			goto constoff;
		}
	    }
	    if (!copied)
		SvREFCNT_inc_simple_void_NN(const_sv);
	    /* If the lexical is not used elsewhere, it is safe to turn on
	       SvPADTMP, since it is only when it is used in lvalue con-
	       text that the difference is observable.  */
	    SvREADONLY_on(const_sv);
	    SvPADTMP_on(const_sv);
	    SvREFCNT_dec_NN(cv);
	    cv = newCONSTSUB(CvSTASH(proto), NULL, const_sv);
	    if (was_method)
		CvMETHOD_on(cv);
	}
	else {
	  constoff:
	    CvCONST_off(cv);
	}
    }

    return cv;
}

static CV *
S_cv_clone(pTHX_ CV *proto, CV *cv, CV *outside, HV *cloned)
{
#ifdef USE_ITHREADS
    dVAR;
#endif
    const bool newcv = !cv;

    assert(!CvUNIQUE(proto));

    if (!cv) cv = MUTABLE_CV(newSV_type(SvTYPE(proto)));
    CvFLAGS(cv) = CvFLAGS(proto) & ~(CVf_CLONE|CVf_WEAKOUTSIDE|CVf_CVGV_RC
				    |CVf_SLABBED);
    CvCLONED_on(cv);

    CvFILE(cv)		= CvDYNFILE(proto) ? savepv(CvFILE(proto))
					   : CvFILE(proto);
    if (CvNAMED(proto))
	 CvNAME_HEK_set(cv, share_hek_hek(CvNAME_HEK(proto)));
    else CvGV_set(cv,CvGV(proto));
    CvSTASH_set(cv, CvSTASH(proto));
    OP_REFCNT_LOCK;
    CvROOT(cv)		= OpREFCNT_inc(CvROOT(proto));
    OP_REFCNT_UNLOCK;
    CvSTART(cv)		= CvSTART(proto);
    CvOUTSIDE_SEQ(cv) = CvOUTSIDE_SEQ(proto);

    if (SvPOK(proto)) {
	sv_setpvn(MUTABLE_SV(cv), SvPVX_const(proto), SvCUR(proto));
        if (SvUTF8(proto))
           SvUTF8_on(MUTABLE_SV(cv));
    }
    if (SvMAGIC(proto))
	mg_copy((SV *)proto, (SV *)cv, 0, 0);

    if (CvPADLIST(proto))
	cv = S_cv_clone_pad(aTHX_ proto, cv, outside, cloned, newcv);

    DEBUG_Xv(
	PerlIO_printf(Perl_debug_log, "\nPad CV clone\n");
	if (CvOUTSIDE(cv)) cv_dump(CvOUTSIDE(cv), "Outside");
	cv_dump(proto,	 "Proto");
	cv_dump(cv,	 "To");
    );

    return cv;
}

CV *
Perl_cv_clone(pTHX_ CV *proto)
{
    PERL_ARGS_ASSERT_CV_CLONE;

    if (!CvPADLIST(proto)) Perl_croak(aTHX_ "panic: no pad in cv_clone");
    return S_cv_clone(aTHX_ proto, NULL, NULL, NULL);
}

/* Called only by pp_clonecv */
CV *
Perl_cv_clone_into(pTHX_ CV *proto, CV *target)
{
    PERL_ARGS_ASSERT_CV_CLONE_INTO;
    cv_undef(target);
    return S_cv_clone(aTHX_ proto, target, NULL, NULL);
}

/*
=for apidoc cv_name

Returns an SV containing the name of the CV, mainly for use in error
reporting.  The CV may actually be a GV instead, in which case the returned
SV holds the GV's name.  Anything other than a GV or CV is treated as a
string already holding the sub name, but this could change in the future.

An SV may be passed as a second argument.  If so, the name will be assigned
to it and it will be returned.  Otherwise the returned SV will be a new
mortal.

If C<flags> has the C<CV_NAME_NOTQUAL> bit set, then the package name will not be
included.  If the first argument is neither a CV nor a GV, this flag is
ignored (subject to change).

=cut
*/

SV *
Perl_cv_name(pTHX_ CV *cv, SV *sv, U32 flags)
{
    PERL_ARGS_ASSERT_CV_NAME;
    if (!isGV_with_GP(cv) && SvTYPE(cv) != SVt_PVCV) {
	if (sv) sv_setsv(sv,(SV *)cv);
	return sv ? (sv) : (SV *)cv;
    }
    {
	SV * const retsv = sv ? (sv) : sv_newmortal();
    	if (SvTYPE(cv) == SVt_PVCV) {
	    if (CvNAMED(cv)) {
		if (CvLEXICAL(cv) || flags & CV_NAME_NOTQUAL)
		    sv_sethek(retsv, CvNAME_HEK(cv));
		else {
		    sv_sethek(retsv, HvNAME_HEK(CvSTASH(cv)));
		    sv_catpvs(retsv, "::");
		    sv_cathek(retsv, CvNAME_HEK(cv));
		}
	    }
	    else if (CvLEXICAL(cv) || flags & CV_NAME_NOTQUAL)
		sv_sethek(retsv, GvNAME_HEK(GvEGV(CvGV(cv))));
	    else gv_efullname3(retsv, CvGV(cv), NULL);
	}
	else if (flags & CV_NAME_NOTQUAL) sv_sethek(retsv, GvNAME_HEK(cv));
	else gv_efullname3(retsv,(GV *)cv,NULL);
	return retsv;
    }
}

/*
=for apidoc m|void|pad_fixup_inner_anons|PADLIST *padlist|CV *old_cv|CV *new_cv

For any anon CVs in the pad, change C<CvOUTSIDE> of that CV from
C<old_cv> to C<new_cv> if necessary.  Needed when a newly-compiled CV has to be
moved to a pre-existing CV struct.

=cut
*/

void
Perl_pad_fixup_inner_anons(pTHX_ PADLIST *padlist, CV *old_cv, CV *new_cv)
{
    I32 ix;
    PADNAMELIST * const comppad_name = PadlistNAMES(padlist);
    AV * const comppad = PadlistARRAY(padlist)[1];
    PADNAME ** const namepad = PadnamelistARRAY(comppad_name);
    SV ** const curpad = AvARRAY(comppad);

    PERL_ARGS_ASSERT_PAD_FIXUP_INNER_ANONS;
    PERL_UNUSED_ARG(old_cv);

    for (ix = PadnamelistMAX(comppad_name); ix > 0; ix--) {
        const PADNAME *name = namepad[ix];
	if (name && name != &PL_padname_undef && !PadnameIsOUR(name)
	    && *PadnamePV(name) == '&')
	{
	  CV *innercv = MUTABLE_CV(curpad[ix]);
	  if (UNLIKELY(PadnameOUTER(name))) {
	    CV *cv = new_cv;
	    PADNAME **names = namepad;
	    PADOFFSET i = ix;
	    while (PadnameOUTER(name)) {
		cv = CvOUTSIDE(cv);
		names = PadlistNAMESARRAY(CvPADLIST(cv));
		i = PARENT_PAD_INDEX(name);
		name = names[i];
	    }
	    innercv = (CV *)PadARRAY(PadlistARRAY(CvPADLIST(cv))[1])[i];
	  }
	  if (SvTYPE(innercv) == SVt_PVCV) {
	    /* XXX 0afba48f added code here to check for a proto CV
		   attached to the pad entry by magic.  But shortly there-
		   after 81df9f6f95 moved the magic to the pad name.  The
		   code here was never updated, so it wasn’t doing anything
		   and got deleted when PADNAME became a distinct type.  Is
		   there any bug as a result?  */
	    if (CvOUTSIDE(innercv) == old_cv) {
		if (!CvWEAKOUTSIDE(innercv)) {
		    SvREFCNT_dec(old_cv);
		    SvREFCNT_inc_simple_void_NN(new_cv);
		}
		CvOUTSIDE(innercv) = new_cv;
	    }
	  }
	  else { /* format reference */
	    SV * const rv = curpad[ix];
	    CV *innercv;
	    if (!SvOK(rv)) continue;
	    assert(SvROK(rv));
	    assert(SvWEAKREF(rv));
	    innercv = (CV *)SvRV(rv);
	    assert(!CvWEAKOUTSIDE(innercv));
	    SvREFCNT_dec(CvOUTSIDE(innercv));
	    CvOUTSIDE(innercv) = (CV *)SvREFCNT_inc_simple_NN(new_cv);
	  }
	}
    }
}

/*
=for apidoc m|void|pad_push|PADLIST *padlist|int depth

Push a new pad frame onto the padlist, unless there's already a pad at
this depth, in which case don't bother creating a new one.  Then give
the new pad an C<@@_> in slot zero.

=cut
*/

void
Perl_pad_push(pTHX_ PADLIST *padlist, int depth)
{
    PERL_ARGS_ASSERT_PAD_PUSH;

    if (depth > PadlistMAX(padlist) || !PadlistARRAY(padlist)[depth]) {
	PAD** const svp = PadlistARRAY(padlist);
	AV* const newpad = newAV();
	SV** const oldpad = AvARRAY(svp[depth-1]);
	I32 ix = AvFILLp((const AV *)svp[1]);
	const I32 names_fill = PadnamelistMAX((PADNAMELIST *)svp[0]);
	PADNAME ** const names = PadnamelistARRAY((PADNAMELIST *)svp[0]);
	AV *av;

	for ( ;ix > 0; ix--) {
	    if (names_fill >= ix && PadnameLEN(names[ix])) {
		const char sigil = PadnamePV(names[ix])[0];
		if (PadnameOUTER(names[ix])
			|| PadnameIsSTATE(names[ix])
			|| sigil == '&')
		{
		    /* outer lexical or anon code */
		    av_store(newpad, ix, SvREFCNT_inc(oldpad[ix]));
		}
		else {		/* our own lexical */
		    SV *sv; 
		    if (sigil == '@@')
			sv = MUTABLE_SV(newAV());
		    else if (sigil == '%')
			sv = MUTABLE_SV(newHV());
		    else
			sv = newSV(0);
		    av_store(newpad, ix, sv);
		}
	    }
	    else if (PadnamePV(names[ix])) {
		av_store(newpad, ix, SvREFCNT_inc_NN(oldpad[ix]));
	    }
	    else {
		/* save temporaries on recursion? */
		SV * const sv = newSV(0);
		av_store(newpad, ix, sv);
		SvPADTMP_on(sv);
	    }
	}
	av = newAV();
	av_store(newpad, 0, MUTABLE_SV(av));
	AvREIFY_only(av);

	padlist_store(padlist, depth, newpad);
    }
}

#if defined(USE_ITHREADS)

#  define av_dup_inc(s,t)	MUTABLE_AV(sv_dup_inc((const SV *)s,t))

/*
=for apidoc padlist_dup

Duplicates a pad.

=cut
*/

PADLIST *
Perl_padlist_dup(pTHX_ PADLIST *srcpad, CLONE_PARAMS *param)
{
    PADLIST *dstpad;
    bool cloneall;
    PADOFFSET max;

    PERL_ARGS_ASSERT_PADLIST_DUP;

    cloneall = cBOOL(param->flags & CLONEf_COPY_STACKS);
    assert (SvREFCNT(PadlistARRAY(srcpad)[1]) == 1);

    max = cloneall ? PadlistMAX(srcpad) : 1;

    Newx(dstpad, 1, PADLIST);
    ptr_table_store(PL_ptr_table, srcpad, dstpad);
    PadlistMAX(dstpad) = max;
    Newx(PadlistARRAY(dstpad), max + 1, PAD *);

    PadlistARRAY(dstpad)[0] = (PAD *)
	    padnamelist_dup(PadlistNAMES(srcpad), param);
    PadnamelistREFCNT(PadlistNAMES(dstpad))++;
    if (cloneall) {
	PADOFFSET depth;
	for (depth = 1; depth <= max; ++depth)
	    PadlistARRAY(dstpad)[depth] =
		av_dup_inc(PadlistARRAY(srcpad)[depth], param);
    } else {
	/* CvDEPTH() on our subroutine will be set to 0, so there's no need
	   to build anything other than the first level of pads.  */
	I32 ix = AvFILLp(PadlistARRAY(srcpad)[1]);
	AV *pad1;
	const I32 names_fill = PadnamelistMAX(PadlistNAMES(srcpad));
	const PAD *const srcpad1 = PadlistARRAY(srcpad)[1];
	SV **oldpad = AvARRAY(srcpad1);
	PADNAME ** const names = PadnamelistARRAY(PadlistNAMES(dstpad));
	SV **pad1a;
	AV *args;

	pad1 = newAV();

	av_extend(pad1, ix);
	PadlistARRAY(dstpad)[1] = pad1;
	pad1a = AvARRAY(pad1);

	if (ix > -1) {
	    AvFILLp(pad1) = ix;

	    for ( ;ix > 0; ix--) {
		if (!oldpad[ix]) {
		    pad1a[ix] = NULL;
		} else if (names_fill >= ix && names[ix] &&
			   PadnameLEN(names[ix])) {
		    const char sigil = PadnamePV(names[ix])[0];
		    if (PadnameOUTER(names[ix])
			|| PadnameIsSTATE(names[ix])
			|| sigil == '&')
			{
			    /* outer lexical or anon code */
			    pad1a[ix] = sv_dup_inc(oldpad[ix], param);
			}
		    else {		/* our own lexical */
			if(SvPADSTALE(oldpad[ix]) && SvREFCNT(oldpad[ix]) > 1) {
			    /* This is a work around for how the current
			       implementation of ?{ } blocks in regexps
			       interacts with lexicals.  */
			    pad1a[ix] = sv_dup_inc(oldpad[ix], param);
			} else {
			    SV *sv; 
			    
			    if (sigil == '@@')
				sv = MUTABLE_SV(newAV());
			    else if (sigil == '%')
				sv = MUTABLE_SV(newHV());
			    else
				sv = newSV(0);
			    pad1a[ix] = sv;
			}
		    }
		}
		else if ((  names_fill >= ix && names[ix]
			 && PadnamePV(names[ix])  )) {
		    pad1a[ix] = sv_dup_inc(oldpad[ix], param);
		}
		else {
		    /* save temporaries on recursion? */
		    SV * const sv = newSV(0);
		    pad1a[ix] = sv;

		    /* SvREFCNT(oldpad[ix]) != 1 for some code in threads.xs
		       FIXTHAT before merging this branch.
		       (And I know how to) */
		    if (SvPADTMP(oldpad[ix]))
			SvPADTMP_on(sv);
		}
	    }

	    if (oldpad[0]) {
		args = newAV();			/* Will be @@_ */
		AvREIFY_only(args);
		pad1a[0] = (SV *)args;
	    }
	}
    }

    return dstpad;
}

#endif /* USE_ITHREADS */

PAD **
Perl_padlist_store(pTHX_ PADLIST *padlist, I32 key, PAD *val)
{
    PAD **ary;
    SSize_t const oldmax = PadlistMAX(padlist);

    PERL_ARGS_ASSERT_PADLIST_STORE;

    assert(key >= 0);

    if (key > PadlistMAX(padlist)) {
	av_extend_guts(NULL,key,&PadlistMAX(padlist),
		       (SV ***)&PadlistARRAY(padlist),
		       (SV ***)&PadlistARRAY(padlist));
	Zero(PadlistARRAY(padlist)+oldmax+1, PadlistMAX(padlist)-oldmax,
	     PAD *);
    }
    ary = PadlistARRAY(padlist);
    SvREFCNT_dec(ary[key]);
    ary[key] = val;
    return &ary[key];
}

/*
=for apidoc newPADNAMELIST

Creates a new pad name list.  C<max> is the highest index for which space
is allocated.

=cut
*/

PADNAMELIST *
Perl_newPADNAMELIST(size_t max)
{
    PADNAMELIST *pnl;
    Newx(pnl, 1, PADNAMELIST);
    Newxz(PadnamelistARRAY(pnl), max+1, PADNAME *);
    PadnamelistMAX(pnl) = -1;
    PadnamelistREFCNT(pnl) = 1;
    PadnamelistMAXNAMED(pnl) = 0;
    pnl->xpadnl_max = max;
    return pnl;
}

/*
=for apidoc padnamelist_store

Stores the pad name (which may be null) at the given index, freeing any
existing pad name in that slot.

=cut
*/

PADNAME **
Perl_padnamelist_store(pTHX_ PADNAMELIST *pnl, SSize_t key, PADNAME *val)
{
    PADNAME **ary;

    PERL_ARGS_ASSERT_PADNAMELIST_STORE;

    assert(key >= 0);

    if (key > pnl->xpadnl_max)
	av_extend_guts(NULL,key,&pnl->xpadnl_max,
		       (SV ***)&PadnamelistARRAY(pnl),
		       (SV ***)&PadnamelistARRAY(pnl));
    if (PadnamelistMAX(pnl) < key) {
	Zero(PadnamelistARRAY(pnl)+PadnamelistMAX(pnl)+1,
	     key-PadnamelistMAX(pnl), PADNAME *);
	PadnamelistMAX(pnl) = key;
    }
    ary = PadnamelistARRAY(pnl);
    if (ary[key])
	PadnameREFCNT_dec(ary[key]);
    ary[key] = val;
    return &ary[key];
}

/*
=for apidoc padnamelist_fetch

Fetches the pad name from the given index.

=cut
*/

PADNAME *
Perl_padnamelist_fetch(PADNAMELIST *pnl, SSize_t key)
{
    PERL_ARGS_ASSERT_PADNAMELIST_FETCH;
    ASSUME(key >= 0);

    return key > PadnamelistMAX(pnl) ? NULL : PadnamelistARRAY(pnl)[key];
}

void
Perl_padnamelist_free(pTHX_ PADNAMELIST *pnl)
{
    PERL_ARGS_ASSERT_PADNAMELIST_FREE;
    if (!--PadnamelistREFCNT(pnl)) {
	while(PadnamelistMAX(pnl) >= 0)
	{
	    PADNAME * const pn =
		PadnamelistARRAY(pnl)[PadnamelistMAX(pnl)--];
	    if (pn)
		PadnameREFCNT_dec(pn);
	}
	Safefree(PadnamelistARRAY(pnl));
	Safefree(pnl);
    }
}

#if defined(USE_ITHREADS)

/*
=for apidoc padnamelist_dup

Duplicates a pad name list.

=cut
*/

PADNAMELIST *
Perl_padnamelist_dup(pTHX_ PADNAMELIST *srcpad, CLONE_PARAMS *param)
{
    PADNAMELIST *dstpad;
    SSize_t max = PadnamelistMAX(srcpad);

    PERL_ARGS_ASSERT_PADNAMELIST_DUP;

    /* look for it in the table first */
    dstpad = (PADNAMELIST *)ptr_table_fetch(PL_ptr_table, srcpad);
    if (dstpad)
	return dstpad;

    dstpad = newPADNAMELIST(max);
    PadnamelistREFCNT(dstpad) = 0; /* The caller will increment it.  */
    PadnamelistMAXNAMED(dstpad) = PadnamelistMAXNAMED(srcpad);
    PadnamelistMAX(dstpad) = max;

    ptr_table_store(PL_ptr_table, srcpad, dstpad);
    for (; max >= 0; max--)
      if (PadnamelistARRAY(srcpad)[max]) {
	PadnamelistARRAY(dstpad)[max] =
	    padname_dup(PadnamelistARRAY(srcpad)[max], param);
	PadnameREFCNT(PadnamelistARRAY(dstpad)[max])++;
      }

    return dstpad;
}

#endif /* USE_ITHREADS */

/*
=for apidoc newPADNAMEpvn

Constructs and returns a new pad name.  C<s> must be a UTF-8 string.  Do not
use this for pad names that point to outer lexicals.  See
C<L</newPADNAMEouter>>.

=cut
*/

PADNAME *
Perl_newPADNAMEpvn(const char *s, STRLEN len)
{
    struct padname_with_str *alloc;
    char *alloc2; /* for Newxz */
    PADNAME *pn;
    PERL_ARGS_ASSERT_NEWPADNAMEPVN;
    Newxz(alloc2,
	  STRUCT_OFFSET(struct padname_with_str, xpadn_str[0]) + len + 1,
	  char);
    alloc = (struct padname_with_str *)alloc2;
    pn = (PADNAME *)alloc;
    PadnameREFCNT(pn) = 1;
    PadnamePV(pn) = alloc->xpadn_str;
    Copy(s, PadnamePV(pn), len, char);
    *(PadnamePV(pn) + len) = '\0';
    PadnameLEN(pn) = len;
    return pn;
}

/*
=for apidoc newPADNAMEouter

Constructs and returns a new pad name.  Only use this function for names
that refer to outer lexicals.  (See also L</newPADNAMEpvn>.)  C<outer> is
the outer pad name that this one mirrors.  The returned pad name has the
C<PADNAMEt_OUTER> flag already set.

=cut
*/

PADNAME *
Perl_newPADNAMEouter(PADNAME *outer)
{
    PADNAME *pn;
    PERL_ARGS_ASSERT_NEWPADNAMEOUTER;
    Newxz(pn, 1, PADNAME);
    PadnameREFCNT(pn) = 1;
    PadnamePV(pn) = PadnamePV(outer);
    /* Not PadnameREFCNT(outer), because ‘outer’ may itself close over
       another entry.  The original pad name owns the buffer.  */
    PadnameREFCNT(PADNAME_FROM_PV(PadnamePV(outer)))++;
    PadnameFLAGS(pn) = PADNAMEt_OUTER;
    PadnameLEN(pn) = PadnameLEN(outer);
    return pn;
}

void
Perl_padname_free(pTHX_ PADNAME *pn)
{
    PERL_ARGS_ASSERT_PADNAME_FREE;
    if (!--PadnameREFCNT(pn)) {
	if (UNLIKELY(pn == &PL_padname_undef || pn == &PL_padname_const)) {
	    PadnameREFCNT(pn) = SvREFCNT_IMMORTAL;
	    return;
	}
	SvREFCNT_dec(PadnameTYPE(pn)); /* Takes care of protocv, too.  */
	SvREFCNT_dec(PadnameOURSTASH(pn));
	if (PadnameOUTER(pn))
	    PadnameREFCNT_dec(PADNAME_FROM_PV(PadnamePV(pn)));
	Safefree(pn);
    }
}

#if defined(USE_ITHREADS)

/*
=for apidoc padname_dup

Duplicates a pad name.

=cut
*/

PADNAME *
Perl_padname_dup(pTHX_ PADNAME *src, CLONE_PARAMS *param)
{
    PADNAME *dst;

    PERL_ARGS_ASSERT_PADNAME_DUP;

    /* look for it in the table first */
    dst = (PADNAME *)ptr_table_fetch(PL_ptr_table, src);
    if (dst)
	return dst;

    if (!PadnamePV(src)) {
	dst = &PL_padname_undef;
	ptr_table_store(PL_ptr_table, src, dst);
	return dst;
    }

    dst = PadnameOUTER(src)
     ? newPADNAMEouter(padname_dup(PADNAME_FROM_PV(PadnamePV(src)), param))
     : newPADNAMEpvn(PadnamePV(src), PadnameLEN(src));
    ptr_table_store(PL_ptr_table, src, dst);
    PadnameLEN(dst) = PadnameLEN(src);
    PadnameFLAGS(dst) = PadnameFLAGS(src);
    PadnameREFCNT(dst) = 0; /* The caller will increment it.  */
    PadnameTYPE   (dst) = (HV *)sv_dup_inc((SV *)PadnameTYPE(src), param);
    PadnameOURSTASH(dst) = (HV *)sv_dup_inc((SV *)PadnameOURSTASH(src),
					    param);
    dst->xpadn_low  = src->xpadn_low;
    dst->xpadn_high = src->xpadn_high;
    dst->xpadn_gen  = src->xpadn_gen;
    return dst;
}

#endif /* USE_ITHREADS */

/*
 * ex: set ts=8 sts=4 sw=4 et:
 */
@


1.2
log
@Update to perl 5.20.3

OK bluhm@@
@
text
@d41 1
a41 1
XSUBs don't have CvPADLIST set - dXSTARG fetches values from PL_curpad,
d43 3
a45 1
every entersub).
d49 2
a50 2
The 0th entry of the PADLIST is a PADNAMELIST (which is actually just an
AV, but that may change) which represents the "names" or rather
d52 1
a52 1
PADNAMELIST are PADNAMEs (just SVs; but, again, that may change).  Future
d58 1
a58 1
AV which is @@_.  Other entries are storage for variables and op targets.
d61 7
a67 5
items.  Pad slots for targets (SVs_PADTMP)
and GVs end up having &PL_sv_undef
"names", while slots for constants have &PL_sv_no "names" (see
pad_alloc()).  That &PL_sv_no is used is an implementation detail subject
to change.  To test for it, use C<PadnamePV(name) && !PadnameLEN(name)>.
d69 1
a69 1
Only my/our variable (SvPADMY/PADNAME_isOUR) slots get valid names.
d73 1
a73 1
my/our variables can be.  Since they can't be looked up by "name"
d75 1
a75 1
in PL_op->op_targ), wasting a name SV for them doesn't make sense.
d77 4
a80 4
The SVs in the names AV have their PV being the name of the variable.
xlow+1..xhigh inclusive in the NV union is a range of cop_seq numbers for
which the name is valid (accessed through the macros COP_SEQ_RANGE_LOW and
_HIGH).  During compilation, these fields may hold the special value
d83 20
a102 17
   COP_SEQ_RANGE_LOW        _HIGH
   -----------------        -----
   PERL_PADSEQ_INTRO            0   variable not yet introduced:   { my ($x
   valid-seq#   PERL_PADSEQ_INTRO   variable in scope:             { my ($x)
   valid-seq#          valid-seq#   compilation of scope complete: { my ($x) }

For typed lexicals name SV is SVt_PVMG and SvSTASH
points at the type.  For C<our> lexicals, the type is also SVt_PVMG, with the
SvOURSTASH slot pointing at the stash of the associated global (so that
duplicate C<our> declarations in the same package can be detected).  SvUVX is
sometimes hijacked to store the generation number during compilation.

If PADNAME_OUTER (SvFAKE) is set on the
name SV, then that slot in the frame AV is
a REFCNT'ed reference to a lexical from "outside".  In this case,
the name SV does not use xlow and xhigh to store a cop_seq range, since it is
in scope throughout.  Instead xhigh stores some flags containing info about
d104 1
a104 1
instantiated multiple times?), and for fake ANONs, xlow contains the index
d108 1
a108 1
If the 'name' is '&' the corresponding entry in the PAD
a109 3
(PADNAME_OUTER and name of '&' is not a
meaningful combination currently but could
become so if C<my sub foo {}> is implemented.)
d114 1
a114 1
The flag SVs_PADSTALE is cleared on lexicals each time the my() is executed,
d116 1
a116 1
'Variable $x is not available' warning
d121 2
a122 1
For state vars, SVs_PADSTALE is overloaded to mean 'not yet initialised'.
d152 1
a152 1
  STMT_START { ((XPVNV*)SvANY(sv))->xnv_u.xpad_cop_seq.xlow = (val); } STMT_END
d154 1
a154 1
  STMT_START { ((XPVNV*)SvANY(sv))->xnv_u.xpad_cop_seq.xhigh = (val); } STMT_END
d156 2
a157 4
#define PARENT_PAD_INDEX_set(sv,val)		\
  STMT_START { ((XPVNV*)SvANY(sv))->xnv_u.xpad_cop_seq.xlow = (val); } STMT_END
#define PARENT_FAKELEX_FLAGS_set(sv,val)	\
  STMT_START { ((XPVNV*)SvANY(sv))->xnv_u.xpad_cop_seq.xhigh = (val); } STMT_END
d159 13
a171 19
/*
=for apidoc mx|void|pad_peg|const char *s

When PERL_MAD is enabled, this is a small no-op function that gets called
at the start of each pad-related function.  It can be breakpointed to
track all pad operations.  The parameter is a string indicating the type
of pad operation being performed.

=cut
*/

#ifdef PERL_MAD
void pad_peg(const char* s) {
    static int pegcnt; /* XXX not threadsafe */
    PERL_UNUSED_ARG(s);

    PERL_ARGS_ASSERT_PAD_PEG;

    pegcnt++;
a175 41
This is basically sv_eq_flags() in sv.c, but we avoid the magic
and bytes checking.
*/

static bool
sv_eq_pvn_flags(pTHX_ const SV *sv, const char* pv, const STRLEN pvlen, const U32 flags) {
    if ( (SvUTF8(sv) & SVf_UTF8 ) != (flags & SVf_UTF8) ) {
        const char *pv1 = SvPVX_const(sv);
        STRLEN cur1     = SvCUR(sv);
        const char *pv2 = pv;
        STRLEN cur2     = pvlen;
	if (PL_encoding) {
              SV* svrecode = NULL;
	      if (SvUTF8(sv)) {
		   svrecode = newSVpvn(pv2, cur2);
		   sv_recode_to_utf8(svrecode, PL_encoding);
		   pv2      = SvPV_const(svrecode, cur2);
	      }
	      else {
		   svrecode = newSVpvn(pv1, cur1);
		   sv_recode_to_utf8(svrecode, PL_encoding);
		   pv1      = SvPV_const(svrecode, cur1);
	      }
              SvREFCNT_dec_NN(svrecode);
        }
        if (flags & SVf_UTF8)
            return (bytes_cmp_utf8(
                        (const U8*)pv1, cur1,
		        (const U8*)pv2, cur2) == 0);
        else
            return (bytes_cmp_utf8(
                        (const U8*)pv2, cur2,
		        (const U8*)pv1, cur1) == 0);
    }
    else
        return ((SvPVX_const(sv) == pv)
                    || memEQ(SvPVX_const(sv), pv, pvlen));
}


/*
a191 1
    dVAR;
d193 2
a194 1
    PAD *padname, *pad;
d212 1
d240 1
a240 1
	padname = (PAD *)SvREFCNT_inc_simple_NN(PL_comppad_name);
d243 1
d245 2
a246 3
	padname = newAV();
	AvPAD_NAMELIST_on(padname);
	av_store(padname, 0, &PL_sv_undef);
d256 1
a256 1
    ary[0] = padname;
d269 1
d292 1
a292 1
In the former case, we keep the CvOUTSIDE pointer, so that any anonymous
d301 11
a311 3
    dVAR;
    const PADLIST *padlist = CvPADLIST(cv);
    bool const slabbed = !!CvSLABBED(cv);
d313 1
a313 1
    PERL_ARGS_ASSERT_CV_UNDEF;
d320 36
a355 4
    if (CvFILE(cv) && CvDYNFILE(cv)) {
	Safefree(CvFILE(cv));
    }
    CvFILE(cv) = NULL;
d357 6
a362 13
    CvSLABBED_off(cv);
    if (!CvISXSUB(cv) && CvROOT(cv)) {
	if (SvTYPE(cv) == SVt_PVCV && CvDEPTH(cv))
	    Perl_croak(aTHX_ "Can't undef active subroutine");
	ENTER;

	PAD_SAVE_SETNULLPAD();

	if (slabbed) OpslabREFCNT_dec_padok(OpSLAB(CvROOT(cv)));
	op_free(CvROOT(cv));
	CvROOT(cv) = NULL;
	CvSTART(cv) = NULL;
	LEAVE;
d364 2
a365 11
    else if (slabbed && CvSTART(cv)) {
	ENTER;
	PAD_SAVE_SETNULLPAD();

	/* discard any leaked ops */
	if (PL_parser)
	    parser_free_nexttoke_ops(PL_parser, (OPSLAB *)CvSTART(cv));
	opslab_force_free((OPSLAB *)CvSTART(cv));
	CvSTART(cv) = NULL;

	LEAVE;
a366 3
#ifdef DEBUGGING
    else if (slabbed) Perl_warn(aTHX_ "Slab leaked from cv %p", cv);
#endif
d369 7
a375 2
    if (CvNAMED(cv)) CvNAME_HEK_set(cv, NULL);
    else	     CvGV_set(cv, NULL);
d380 1
a380 1
    if (padlist) {
d382 1
d402 4
a405 4
	    CV * const outercv = CvOUTSIDE(cv);
	    const U32 seq = CvOUTSIDE_SEQ(cv);
	    PAD * const comppad_name = PadlistARRAY(padlist)[0];
	    SV ** const namepad = AvARRAY(comppad_name);
d408 3
a410 4
	    for (ix = AvFILLp(comppad_name); ix > 0; ix--) {
		SV * const namesv = namepad[ix];
		if (namesv && namesv != &PL_sv_undef
		    && *SvPVX_const(namesv) == '&')
d424 3
a426 1
			if (inner_rc && (CvOUTSIDE(innercv) == cv)) {
d455 2
a456 2
	    PAD * const sv = PadlistARRAY(padlist)[0];
	    if (sv == PL_comppad_name && SvREFCNT(sv) == 1)
d458 1
a458 1
	    SvREFCNT_dec(sv);
d462 1
a462 1
	CvPADLIST(cv) = NULL;
d464 3
d470 7
a476 8
    if (!SvREFCNT(cv) && CvOUTSIDE(cv)) {
	if (!CvWEAKOUTSIDE(cv))
	    SvREFCNT_dec(CvOUTSIDE(cv));
	CvOUTSIDE(cv) = NULL;
    }
    if (CvCONST(cv)) {
	SvREFCNT_dec(MUTABLE_SV(CvXSUBANY(cv).any_ptr));
	CvCONST_off(cv);
d478 3
a480 2
    if (CvISXSUB(cv) && CvXSUB(cv)) {
	CvXSUB(cv) = NULL;
d483 4
a486 3
     * ref status of CvOUTSIDE and CvGV, and ANON, which pp_entersub uses
     * to choose an error message */
    CvFLAGS(cv) &= (CVf_WEAKOUTSIDE|CVf_CVGV_RC|CVf_ANON);
d492 1
a492 1
When a CV has a reference count on its slab (CvSLABBED), it is responsible
d495 1
a495 1
during compilation.  Once it is compiled and CvROOT attached, it has
d504 1
a504 1
    const bool slabbed = !!CvSLABBED(cv);
d507 3
a509 2
    PERL_ARGS_ASSERT_CV_FORGET_SLAB;

d517 1
a517 1
    else if (slabbed)     Perl_warn(aTHX_ "Slab leaked from cv %p", cv);
d532 1
a532 1
=for apidoc m|PADOFFSET|pad_alloc_name|SV *namesv|U32 flags|HV *typestash|HV *ourstash
d536 4
a539 4
then stores a name for that entry.  I<namesv> is adopted and becomes the
name entry; it must already contain the name string and be sufficiently
upgraded.  I<typestash> and I<ourstash> and the C<padadd_STATE> flag get
added to I<namesv>.  None of the other
d547 2
a548 1
S_pad_alloc_name(pTHX_ SV *namesv, U32 flags, HV *typestash, HV *ourstash)
a549 1
    dVAR;
d557 3
a559 3
	assert(SvTYPE(namesv) == SVt_PVMG);
	SvPAD_TYPED_on(namesv);
	SvSTASH_set(namesv, MUTABLE_HV(SvREFCNT_inc_simple_NN(MUTABLE_SV(typestash))));
d562 2
a563 2
	SvPAD_OUR_on(namesv);
	SvOURSTASH_set(namesv, ourstash);
d567 1
a567 1
	SvPAD_STATE_on(namesv);
d570 3
a572 2
    av_store(PL_comppad_name, offset, namesv);
    PadnamelistMAXNAMED(PL_comppad_name) = offset;
d584 3
a586 3
I<namepv>/I<namelen> specify the variable's name, including leading sigil.
If I<typestash> is non-null, the name is for a typed lexical, and this
identifies the type.  If I<ourstash> is non-null, it's a lexical reference
d590 3
a592 3
    padadd_OUR          redundantly specifies if it's a package var
    padadd_STATE        variable will retain value persistently
    padadd_NO_DUP_CHECK skip check for lexical shadowing
a600 1
    dVAR;
d602 1
a602 2
    SV *namesv;
    bool is_utf8;
d606 1
a606 1
    if (flags & ~(padadd_OUR|padadd_STATE|padadd_NO_DUP_CHECK|padadd_UTF8_NAME))
d610 1
a610 14
    namesv = newSV_type((ourstash || typestash) ? SVt_PVMG : SVt_PVNV);
    
    if ((is_utf8 = ((flags & padadd_UTF8_NAME) != 0))) {
        namepv = (const char*)bytes_from_utf8((U8*)namepv, &namelen, &is_utf8);
    }

    sv_setpvn(namesv, namepv, namelen);

    if (is_utf8) {
        flags |= padadd_UTF8_NAME;
        SvUTF8_on(namesv);
    }
    else
        flags &= ~padadd_UTF8_NAME;
d614 1
a614 1
	SAVEFREESV(namesv); /* in case of fatal warnings */
d616 2
a617 2
	pad_check_dup(namesv, flags & padadd_OUR, ourstash);
	SvREFCNT_inc_simple_void_NN(namesv);
d621 1
a621 1
    offset = pad_alloc_name(namesv, flags & ~padadd_UTF8_NAME, typestash, ourstash);
d624 2
a625 2
    COP_SEQ_RANGE_LOW_set(namesv, PERL_PADSEQ_INTRO);
    COP_SEQ_RANGE_HIGH_set(namesv, 0);
d642 1
a642 1
			   (long)offset, SvPVX(namesv),
d680 1
a680 3
    namepv = SvPV(name, namelen);
    if (SvUTF8(name))
        flags |= padadd_UTF8_NAME;
d690 1
a690 1
I<tmptype> is a set of flags indicating the kind of pad entry required,
d703 1
a703 1
I<optype> should be an opcode indicating the type of operation that the
a715 1
    dVAR;
d727 1
a727 1
    if (tmptype & SVs_PADMY) {
d735 1
d737 4
a740 2
	SV * const * const names = AvARRAY(PL_comppad_name);
        const SSize_t names_fill = AvFILLp(PL_comppad_name);
d747 4
d752 3
a754 2
	    if (++PL_padix <= names_fill &&
		   (sv = names[PL_padix]) && sv != &PL_sv_undef)
d756 8
a763 3
	    sv = *av_fetch(PL_comppad, PL_padix, TRUE);
	    if (!(SvFLAGS(sv) & (SVs_PADTMP | SVs_PADMY)) &&
		!IS_PADGV(sv))
d766 2
a767 2
	if (tmptype & SVf_READONLY) {
	    av_store(PL_comppad_name, PL_padix, &PL_sv_no);
d771 1
a771 1
	retval = PL_padix;
d793 1
a793 1
The function I<func> is linked into the pad, and its C<CvOUTSIDE> link
d798 1
a798 1
I<optype> should be an opcode indicating the type of operation that the
a807 1
    dVAR;
d809 1
a809 1
    SV* const name = newSV_type(SVt_PVNV);
d812 1
a814 1
    sv_setpvs(name, "&");
d816 3
a818 3
     * PERL_PADSEQ_INTRO */
    COP_SEQ_RANGE_LOW_set(name, 0);
    COP_SEQ_RANGE_HIGH_set(name, 0);
d820 1
a820 1
    av_store(PL_comppad_name, ix, name);
d822 1
a822 9
    if (SvTYPE(func) == SVt_PVCV || !CvOUTSIDE(func))
	av_store(PL_comppad, ix, (SV*)func);
    else {
	SV *rv = newRV_noinc((SV *)func);
	sv_rvweaken(rv);
	assert (SvTYPE(func) == SVt_PVFM);
	av_store(PL_comppad, ix, rv);
    }
    SvPADMY_on((SV*)func);
d826 1
a826 1
    if (CvOUTSIDE(func) && SvTYPE(func) == SVt_PVCV) {
d834 18
d857 3
a859 3
     * a my in the current scope with the same name;
     * an our (anywhere in the pad) with the same name and the
       same stash as C<ourstash>
d861 1
a861 1
C<is_our> indicates that the name to check is an 'our' declaration.
d867 1
a867 1
S_pad_check_dup(pTHX_ SV *name, U32 flags, const HV *ourstash)
d869 1
a869 2
    dVAR;
    SV		**svp;
d879 1
a879 1
    if (AvFILLp(PL_comppad_name) < 0 || !ckWARN(WARN_MISC))
d882 2
a883 2
    svp = AvARRAY(PL_comppad_name);
    top = AvFILLp(PL_comppad_name);
d888 1
a888 1
	SV * const sv = svp[off];
d890 2
a891 2
	    && PadnameLEN(sv)
	    && !SvFAKE(sv)
d894 1
a894 1
	    && sv_eq(name, sv))
d900 1
a900 1
		"\"%s\" %s %"SVf" masks earlier declaration in same %s",
d902 2
a903 2
		*SvPVX(sv) == '&' ? "subroutine" : "variable",
		sv,
d913 1
a913 1
	    SV * const sv = svp[off];
d915 2
a916 2
		&& PadnameLEN(sv)
		&& !SvFAKE(sv)
d920 1
a920 1
		&& sv_eq(name, sv))
d923 1
a923 1
		    "\"our\" variable %"SVf" redeclared", sv);
d940 2
a941 2
I<namepv>/I<namelen> specify the variable's name, including leading sigil.
I<flags> is reserved and must be zero.
d953 1
a953 2
    dVAR;
    SV *out_sv;
d956 2
a957 2
    const AV *nameav;
    SV **name_svp;
d963 1
a963 1
    if (flags & ~padadd_UTF8_NAME)
d967 3
a969 11
    if (flags & padadd_UTF8_NAME) {
        bool is_utf8 = TRUE;
        namepv = (const char*)bytes_from_utf8((U8*)namepv, &namelen, &is_utf8);

        if (is_utf8)
            flags |= padadd_UTF8_NAME;
        else {
            flags &= ~padadd_UTF8_NAME;
            SAVEFREEPV(namepv);
        }
    }
d972 1
a972 1
                PL_compcv, PL_cop_seqmax, 1, NULL, &out_sv, &out_flags);
d976 4
d984 10
a993 10
    nameav = PadlistARRAY(CvPADLIST(PL_compcv))[0];
    name_svp = AvARRAY(nameav);
    for (offset = AvFILLp(nameav); offset > 0; offset--) {
        const SV * const namesv = name_svp[offset];
	if (namesv && PadnameLEN(namesv) == namelen
	    && !SvFAKE(namesv)
	    && (SvPAD_OUR(namesv))
            && sv_eq_pvn_flags(aTHX_ namesv, namepv, namelen,
                                flags & padadd_UTF8_NAME ? SVf_UTF8 : 0 )
	    && COP_SEQ_RANGE_LOW(namesv) == PERL_PADSEQ_INTRO
d1031 1
a1031 3
    namepv = SvPV(name, namelen);
    if (SvUTF8(name))
        flags |= padadd_UTF8_NAME;
d1038 6
a1043 5
Find the position of the lexical C<$_> in the pad of the
currently-executing function.  Returns the offset in the current pad,
or C<NOT_IN_PAD> if there is no lexical C<$_> in scope (in which case
the global one should be used instead).
L</find_rundefsv> is likely to be more convenient.
d1051 2
a1052 5
    dVAR;
    SV *out_sv;
    int out_flags;
    return pad_findlex("$_", 2, 0, find_runcv(NULL), PL_curcop->cop_seq, 1,
	    NULL, &out_sv, &out_flags);
d1058 1
a1058 3
Find and return the variable that is named C<$_> in the lexical scope
of the currently-executing function.  This may be a lexical C<$_>,
or will otherwise be the global one.
d1066 1
a1066 29
    SV *namesv;
    int flags;
    PADOFFSET po;

    po = pad_findlex("$_", 2, 0, find_runcv(NULL), PL_curcop->cop_seq, 1,
	    NULL, &namesv, &flags);

    if (po == NOT_IN_PAD || SvPAD_OUR(namesv))
	return DEFSV;

    return PAD_SVl(po);
}

SV *
Perl_find_rundefsv2(pTHX_ CV *cv, U32 seq)
{
    SV *namesv;
    int flags;
    PADOFFSET po;

    PERL_ARGS_ASSERT_FIND_RUNDEFSV2;

    po = pad_findlex("$_", 2, 0, cv, seq, 1,
	    NULL, &namesv, &flags);

    if (po == NOT_IN_PAD || SvPAD_OUR(namesv))
	return DEFSV;

    return AvARRAY(PadlistARRAY(CvPADLIST(cv))[CvDEPTH(cv)])[po];
d1070 1
a1070 1
=for apidoc m|PADOFFSET|pad_findlex|const char *namepv|STRLEN namelen|U32 flags|const CV* cv|U32 seq|int warn|SV** out_capture|SV** out_name_sv|int *out_flags
d1076 2
a1077 2
cv is the CV in which to start the search, and seq is the current cop_seq
to match against.  If warn is true, print appropriate warnings.  The out_*
d1079 4
a1082 4
should be stored.  out_capture, if non-null, requests that the innermost
instance of the lexical is captured; out_name_sv is set to the innermost
matched namesv or fake namesv; out_flags returns the flags normally
associated with the IVX field of a fake namesv.
d1084 1
a1084 1
Note that pad_findlex() is recursive; it recurses up the chain of CVs,
d1087 1
a1087 1
because fake namesvs in anon protoypes have to store in xlow the index into
d1101 1
a1101 1
S_unavailable(pTHX_ SV *namesv)
d1105 2
a1106 2
			"%se \"%"SVf"\" is not available",
			 *SvPVX_const(namesv) == '&'
d1109 1
a1109 1
			 namesv);
d1114 1
a1114 1
	int warn, SV** out_capture, SV** out_name_sv, int *out_flags)
a1115 1
    dVAR;
d1124 2
a1125 1
    if (flags & ~(padadd_UTF8_NAME|padadd_STALEOK))
a1127 1
    flags &= ~ padadd_STALEOK; /* one-shot flag */
d1140 2
a1141 2
        const AV * const nameav = PadlistARRAY(padlist)[0];
	SV * const * const name_svp = AvARRAY(nameav);
d1143 5
a1147 5
	for (offset = PadnamelistMAXNAMED(nameav); offset > 0; offset--) {
            const SV * const namesv = name_svp[offset];
	    if (namesv && PadnameLEN(namesv) == namelen
                    && sv_eq_pvn_flags(aTHX_ namesv, namepv, namelen,
                                    flags & padadd_UTF8_NAME ? SVf_UTF8 : 0))
d1149 1
a1149 1
		if (SvFAKE(namesv)) {
d1153 2
a1154 25
		/* is seq within the range _LOW to _HIGH ?
		 * This is complicated by the fact that PL_cop_seqmax
		 * may have wrapped around at some point */
		if (COP_SEQ_RANGE_LOW(namesv) == PERL_PADSEQ_INTRO)
		    continue; /* not yet introduced */

		if (COP_SEQ_RANGE_HIGH(namesv) == PERL_PADSEQ_INTRO) {
		    /* in compiling scope */
		    if (
			(seq >  COP_SEQ_RANGE_LOW(namesv))
			? (seq - COP_SEQ_RANGE_LOW(namesv) < (U32_MAX >> 1))
			: (COP_SEQ_RANGE_LOW(namesv) - seq > (U32_MAX >> 1))
		    )
		       break;
		}
		else if (
		    (COP_SEQ_RANGE_LOW(namesv) > COP_SEQ_RANGE_HIGH(namesv))
		    ?
			(  seq >  COP_SEQ_RANGE_LOW(namesv)
			|| seq <= COP_SEQ_RANGE_HIGH(namesv))

		    :    (  seq >  COP_SEQ_RANGE_LOW(namesv)
			 && seq <= COP_SEQ_RANGE_HIGH(namesv))
		)
		break;
d1161 1
a1161 1
		*out_name_sv = name_svp[offset]; /* return the namesv */
d1178 2
a1179 2
		    (unsigned long)COP_SEQ_RANGE_LOW(*out_name_sv),
		    (unsigned long)COP_SEQ_RANGE_HIGH(*out_name_sv)));
d1183 2
a1184 2
		*out_name_sv = name_svp[offset]; /* return the namesv */
		*out_flags = PARENT_FAKELEX_FLAGS(*out_name_sv);
d1188 1
a1188 1
		    (unsigned long) PARENT_PAD_INDEX(*out_name_sv) 
d1197 1
a1197 1
		if (SvPAD_OUR(*out_name_sv)) {
d1209 1
a1209 3
                                       newSVpvn_flags(namepv, namelen,
                                           SVs_TEMP |
                                           (flags & padadd_UTF8_NAME ? SVf_UTF8 : 0)));
d1218 1
a1218 1
			 && !SvPAD_STATE(name_svp[offset])
d1221 2
d1224 3
a1226 4
			    "Variable \"%"SVf"\" will not stay shared",
                            newSVpvn_flags(namepv, namelen,
                                SVs_TEMP |
                                (flags & padadd_UTF8_NAME ? SVf_UTF8 : 0)));
d1232 1
a1232 1
			SV *n;
d1237 1
a1237 1
			n = *out_name_sv;
d1240 2
a1241 2
			    newwarn, out_capture, out_name_sv, out_flags);
			*out_name_sv = n;
d1253 1
a1253 1
			&& !SvPAD_STATE(name_svp[offset]))
d1256 1
a1256 3
                                       newSVpvn_flags(namepv, namelen,
                                           SVs_TEMP |
                                           (flags & padadd_UTF8_NAME ? SVf_UTF8 : 0)));
d1289 1
a1289 1
		new_capturep, out_name_sv, out_flags);
d1301 2
a1302 6
	/* This relies on sv_setsv_flags() upgrading the destination to the same
	   type as the source, independent of the flags set, and on it being
	   "good" and only copying flag bits and pointers that it understands.
	*/
	SV *new_namesv = newSVsv(*out_name_sv);
	AV *  const ocomppad_name = PL_comppad_name;
d1304 1
a1304 1
	PL_comppad_name = PadlistARRAY(padlist)[0];
d1309 4
a1312 5
	    = pad_alloc_name(new_namesv,
			      (SvPAD_STATE(*out_name_sv) ? padadd_STATE : 0),
			      SvPAD_TYPED(*out_name_sv)
			      ? SvSTASH(*out_name_sv) : NULL,
			      SvOURSTASH(*out_name_sv)
a1314 1
	SvFAKE_on(new_namesv);
d1318 3
a1320 2
			       (int) SvCUR(new_namesv), SvPVX(new_namesv)));
	PARENT_FAKELEX_FLAGS_set(new_namesv, *out_flags);
d1322 2
a1323 2
	PARENT_PAD_INDEX_set(new_namesv, 0);
	if (SvPAD_OUR(new_namesv)) {
d1328 1
a1328 1
	    PARENT_PAD_INDEX_set(new_namesv, offset);
d1335 1
a1335 1
	    PARENT_PAD_INDEX_set(new_namesv, offset);
d1340 2
a1341 2
	*out_name_sv = new_namesv;
	*out_flags = PARENT_FAKELEX_FLAGS(new_namesv);
d1355 2
a1356 2
Get the value at offset I<po> in the current (compiling or executing) pad.
Use macro PAD_SV instead of calling this function directly.
a1363 1
    dVAR;
d1378 2
a1379 2
Set the value at offset I<po> in the current (compiling or executing) pad.
Use the macro PAD_SETSV() rather than calling this function directly.
a1386 2
    dVAR;

a1416 1
    dVAR;
d1419 1
a1419 1
    PL_comppad_name_floor = AvFILLp(PL_comppad_name);
d1429 6
d1440 1
a1440 1
=for apidoc m|U32|intro_my
d1442 3
a1444 3
"Introduce" my variables to visible status.  This is called during parsing
at the end of each statement to make lexical variables visible to
subsequent statements.
d1452 1
a1452 2
    dVAR;
    SV **svp;
d1457 6
d1464 1
a1464 1
	return PL_cop_seqmax;
d1466 1
a1466 1
    svp = AvARRAY(PL_comppad_name);
d1468 1
a1468 1
	SV * const sv = svp[i];
d1470 1
a1470 1
	if (sv && PadnameLEN(sv) && !SvFAKE(sv)
d1477 1
a1477 1
		(long)i, SvPVX_const(sv),
d1483 1
a1483 4
    seq = PL_cop_seqmax;
    PL_cop_seqmax++;
    if (PL_cop_seqmax == PERL_PADSEQ_INTRO) /* not a legal value */
	PL_cop_seqmax++;
a1503 1
    dVAR;
d1506 1
a1506 1
    SV * const * const svp = AvARRAY(PL_comppad_name);
d1513 2
a1514 2
	    const SV * const sv = svp[off];
	    if (sv && PadnameLEN(sv) && !SvFAKE(sv))
d1516 2
a1517 2
				 "%"SVf" never introduced",
				 SVfARG(sv));
d1521 4
a1524 3
    for (off = AvFILLp(PL_comppad_name); off > PL_comppad_name_fill; off--) {
	SV * const sv = svp[off];
	if (sv && PadnameLEN(sv) && !SvFAKE(sv)
d1530 1
a1530 1
		(long)off, SvPVX_const(sv),
d1542 1
a1542 3
    PL_cop_seqmax++;
    if (PL_cop_seqmax == PERL_PADSEQ_INTRO) /* not a legal value */
	PL_cop_seqmax++;
d1551 1
a1551 1
Abandon the tmp in the current pad at offset po and replace with a
a1559 1
    dVAR;
d1580 1
a1580 1
#ifdef USE_BROKEN_PAD_RESET
d1591 1
a1591 1
	PadnamelistARRAY(PL_comppad_name)[po] = &PL_sv_undef;
d1593 5
a1597 2
    if ((I32)po < PL_padix)
	PL_padix = po - 1;
d1608 5
a1612 6
/* XXX pad_reset() is currently disabled because it results in serious bugs.
 * It causes pad temp TARGs to be shared between OPs. Since TARGs are pushed
 * on the stack by OPs that use them, there are several ways to get an alias
 * to  a shared TARG.  Such an alias will change randomly and unpredictably.
 * We avoid doing this until we can think of a Better Way.
 * GSAR 97-10-29 */
d1616 1
a1616 2
    dVAR;
#ifdef USE_BROKEN_PAD_RESET
a1628 5
        I32 po;
	for (po = AvMAX(PL_comppad); po > PL_padix_floor; po--) {
	    if (PL_curpad[po] && !SvIMMORTAL(PL_curpad[po]))
		SvPADTMP_off(PL_curpad[po]);
	}
d1640 1
a1640 1
prototypes; give it a @@_; mark temporaries as such.  I<type> indicates
d1694 2
a1695 2
    if (AvFILLp(PL_comppad_name) < AvFILLp(PL_comppad))
	av_store(PL_comppad_name, AvFILLp(PL_comppad), NULL);
d1698 1
a1698 1
	SV ** const namep = AvARRAY(PL_comppad_name);
d1702 2
a1703 2
	    SV *namesv;
	    if (!namep[ix]) namep[ix] = &PL_sv_undef;
d1710 1
a1710 2
	    if (!PL_curpad[ix] || SvIMMORTAL(PL_curpad[ix])
		 || IS_PADGV(PL_curpad[ix]))
d1714 1
a1714 1
		   (!PadnameLEN(namesv) || *SvPVX_const(namesv) == '&')))
d1729 1
a1729 1
	SV ** const namep = AvARRAY(PL_comppad_name);
d1732 2
a1733 3
	    if (!namep[ix]) namep[ix] = &PL_sv_undef;
	    if (!PL_curpad[ix] || SvIMMORTAL(PL_curpad[ix])
		 || IS_PADGV(PL_curpad[ix]) || IS_PADCONST(PL_curpad[ix]))
d1735 1
a1735 3
	    if (!SvPADMY(PL_curpad[ix])) {
		SvPADTMP_on(PL_curpad[ix]);
	    } else if (!SvFAKE(namep[ix])) {
d1771 1
a1771 1
    dVAR;
d1773 1
d1788 1
a1788 1

d1795 1
d1809 1
a1809 2
    dVAR;
    const AV *pad_name;
d1811 1
a1811 1
    SV **pname;
d1820 1
a1820 1
    pad_name = *PadlistARRAY(padlist);
d1822 1
a1822 1
    pname = AvARRAY(pad_name);
d1829 2
a1830 2
    for (ix = 1; ix <= AvFILLp(pad_name); ix++) {
        const SV *namesv = pname[ix];
d1835 1
a1835 1
	    if (SvFAKE(namesv))
d1841 1
a1841 1
		    SvPVX_const(namesv),
d1854 1
a1854 1
		    SvPVX_const(namesv)
a1880 1
    dVAR;
d1912 1
a1912 1
Clone a CV, making a lexical closure.  I<proto> supplies the prototype
d1921 1
a1921 1
static CV *S_cv_clone(pTHX_ CV *proto, CV *cv, CV *outside);
d1923 3
a1925 2
static void
S_cv_clone_pad(pTHX_ CV *proto, CV *cv, CV *outside, bool newcv)
a1926 1
    dVAR;
d1929 1
a1929 1
    PAD *const protopad_name = *PadlistARRAY(protopadlist);
d1931 1
a1931 1
    SV** const pname = AvARRAY(protopad_name);
d1933 1
a1933 1
    const I32 fname = AvFILLp(protopad_name);
d1937 2
a1938 1
    bool subclones = FALSE;
d1959 1
a1959 2
	    || PadlistNAMES(CvPADLIST(outside))
		 != protopadlist->xpadl_outid) {
d1981 2
a1982 1
    CvPADLIST(cv) = pad_new(padnew_CLONE|padnew_SAVE);
d1991 1
a1991 2
    if (outpad)
	CvPADLIST(cv)->xpadl_outid = PadlistNAMES(CvPADLIST(outside));
d1994 1
a1994 1
	SV* const namesv = (ix <= fname) ? pname[ix] : NULL;
d2001 1
a2001 1
	    if (SvFAKE(namesv)) {   /* lexical from outside? */
d2014 1
a2014 1
                const char sigil = SvPVX_const(namesv)[0];
d2025 3
a2027 1
			subclones = 1;
d2029 1
d2036 4
d2043 3
a2045 4
			    share_hek(SvPVX_const(namesv)+1,
				      SvCUR(namesv) - 1
					 * (SvUTF8(namesv) ? -1 : 1),
				      0)
d2047 1
a2055 1
		SvPADMY_on(sv);
d2062 1
a2062 1
	else if (IS_PADGV(ppad[ix]) || (namesv && PadnamePV(namesv))) {
d2073 62
a2134 5
	for (ix = fpad; ix > 0; ix--) {
	    SV* const namesv = (ix <= fname) ? pname[ix] : NULL;
	    if (namesv && namesv != &PL_sv_undef && !SvFAKE(namesv)
	     && SvPVX_const(namesv)[0] == '&' && SvPAD_STATE(namesv))
		S_cv_clone(aTHX_ (CV *)ppad[ix], (CV *)PL_curpad[ix], cv);
d2136 1
d2140 86
d2229 1
a2229 1
S_cv_clone(pTHX_ CV *proto, CV *cv, CV *outside)
d2231 1
d2233 1
d2263 2
a2264 1
    if (CvPADLIST(proto)) S_cv_clone_pad(aTHX_ proto, cv, outside, newcv);
a2272 19
    if (CvCONST(cv)) {
	/* Constant sub () { $x } closing over $x - see lib/constant.pm:
	 * The prototype was marked as a candiate for const-ization,
	 * so try to grab the current const value, and if successful,
	 * turn into a const sub:
	 */
	SV* const const_sv = op_const_sv(CvSTART(cv), cv);
	if (const_sv) {
	    SvREFCNT_dec_NN(cv);
            /* For this calling case, op_const_sv returns a *copy*, which we
               donate to newCONSTSUB. Yes, this is ugly, and should be killed.
               Need to fix how lib/constant.pm works to eliminate this.  */
	    cv = newCONSTSUB(CvSTASH(proto), NULL, const_sv);
	}
	else {
	    CvCONST_off(cv);
	}
    }

d2282 1
a2282 1
    return S_cv_clone(aTHX_ proto, NULL, NULL);
d2291 50
a2340 1
    return S_cv_clone(aTHX_ proto, target, NULL);
d2346 2
a2347 2
For any anon CVs in the pad, change CvOUTSIDE of that CV from
old_cv to new_cv if necessary.  Needed when a newly-compiled CV has to be
a2355 1
    dVAR;
d2357 1
a2357 1
    AV * const comppad_name = PadlistARRAY(padlist)[0];
d2359 1
a2359 1
    SV ** const namepad = AvARRAY(comppad_name);
d2365 4
a2368 4
    for (ix = AvFILLp(comppad_name); ix > 0; ix--) {
        const SV * const namesv = namepad[ix];
	if (namesv && namesv != &PL_sv_undef && !SvPAD_STATE(namesv)
	    && *SvPVX_const(namesv) == '&')
d2370 20
a2389 6
	  if (SvTYPE(curpad[ix]) == SVt_PVCV) {
	    MAGIC * const mg =
		SvMAGICAL(curpad[ix])
		    ? mg_find(curpad[ix], PERL_MAGIC_proto)
		    : NULL;
	    CV * const innercv = MUTABLE_CV(mg ? mg->mg_obj : curpad[ix]);
d2418 1
a2418 1
the new pad an @@_ in slot zero.
a2425 2
    dVAR;

d2433 2
a2434 2
        const I32 names_fill = AvFILLp((const AV *)svp[0]);
	SV** const names = AvARRAY(svp[0]);
d2439 3
a2441 3
		const char sigil = SvPVX_const(names[ix])[0];
		if ((SvFLAGS(names[ix]) & SVf_FAKE)
			|| (SvFLAGS(names[ix]) & SVpad_STATE)
a2455 1
		    SvPADMY_on(sv);
d2458 1
a2458 1
	    else if (IS_PADGV(oldpad[ix]) || PadnamePV(names[ix])) {
a2475 21
/*
=for apidoc Am|HV *|pad_compname_type|PADOFFSET po

Looks up the type of the lexical variable at position I<po> in the
currently-compiling pad.  If the variable is typed, the stash of the
class to which it is typed is returned.  If not, C<NULL> is returned.

=cut
*/

HV *
Perl_pad_compname_type(pTHX_ const PADOFFSET po)
{
    dVAR;
    SV* const * const av = av_fetch(PL_comppad_name, po, FALSE);
    if ( SvPAD_TYPED(*av) ) {
        return SvSTASH(*av);
    }
    return NULL;
}

d2497 1
a2497 5
    if (!srcpad)
	return NULL;

    cloneall = param->flags & CLONEf_COPY_STACKS
	|| SvREFCNT(PadlistARRAY(srcpad)[1]) > 1;
d2507 3
d2512 1
a2512 1
	for (depth = 0; depth <= max; ++depth)
d2520 1
a2520 1
	const I32 names_fill = AvFILLp(PadlistARRAY(srcpad)[0]);
d2523 1
a2523 1
	SV **names;
a2526 4
	PadlistARRAY(dstpad)[0] =
	    av_dup_inc(PadlistARRAY(srcpad)[0], param);
	names = AvARRAY(PadlistARRAY(dstpad)[0]);

d2541 3
a2543 3
		    const char sigil = SvPVX_const(names[ix])[0];
		    if ((SvFLAGS(names[ix]) & SVf_FAKE)
			|| (SvFLAGS(names[ix]) & SVpad_STATE)
a2564 1
			    SvPADMY_on(sv);
d2568 1
a2568 2
		else if (IS_PADGV(oldpad[ix])
		      || (  names_fill >= ix && names[ix]
d2580 1
a2580 3
		    if (SvPADMY(oldpad[ix]))
			SvPADMY_on(sv);
		    else
a2600 1
    dVAR;
d2622 251
a2872 6
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
@


1.1
log
@Initial revision
@
text
@d3 2
a4 1
 *    Copyright (C) 2002, by Larry Wall and others
d8 9
d18 1
a18 6
 *  "Anyway: there was this Mr Frodo left an orphan and stranded, as you
 *  might say, among those queer Bucklanders, being brought up anyhow in
 *  Brandy Hall. A regular warren, by all accounts. Old Master Gorbadoc
 *  never had fewer than a couple of hundred relations in the place. Mr
 *  Bilbo never did a kinder deed than when he brought the lad back to
 *  live among decent folk." --the Gaffer
d30 5
a34 2
=for apidoc m|AV *|CvPADLIST|CV *cv
CV's can have CvPADLIST(cv) set to point to an AV.
d36 1
a36 1
For these purposes "forms" are a kind-of CV, eval""s are too (except they're
d38 2
a39 1
executing).
d45 1
a45 23
The CvPADLIST AV has does not have AvREAL set, so REFCNT of component items
is managed "manual" (mostly in pad.c) rather than normal av.c rules.
The items in the AV are not SVs as for a normal AV, but other AVs:

0'th Entry of the CvPADLIST is an AV which represents the "names" or rather
the "static type information" for lexicals.

The CvDEPTH'th entry of CvPADLIST AV is an AV which is the stack frame at that
depth of recursion into the CV.
The 0'th slot of a frame AV is an AV which is @@_.
other entries are storage for variables and op targets.

During compilation:
C<PL_comppad_name> is set to the names AV.
C<PL_comppad> is set to the frame AV for the frame CvDEPTH == 1.
C<PL_curpad> is set to the body of the frame AV (i.e. AvARRAY(PL_comppad)).

During execution, C<PL_comppad> and C<PL_curpad> refer to the live
frame of the currently executing sub.

Iterating over the names AV iterates over all possible pad
items. Pad slots that are SVs_PADTMP (targets/GVs/constants) end up having
&PL_sv_undef "names" (see pad_alloc()).
d47 19
a65 1
Only my/our variable (SVs_PADMY/SVs_PADOUR) slots get valid names.
d68 1
a68 1
can be looked up from Perl code at run time through eval"" like
d74 26
a99 11
NV+1..IV inclusive is a range of cop_seq numbers for which the name is
valid.  For typed lexicals name SV is SVt_PVMG and SvSTASH points at the
type.  For C<our> lexicals, the type is SVt_PVGV, and GvSTASH points at the
stash of the associated global (so that duplicate C<our> delarations in the
same package can be detected).  SvCUR is sometimes hijacked to
store the generation number during compilation.

If SvFAKE is set on the name SV then slot in the frame AVs are
a REFCNT'ed references to a lexical from "outside". In this case,
the name SV does not have a cop_seq range, since it is in scope
throughout.
d101 1
a101 1
If the 'name' is '&' the corresponding entry in frame AV
d103 2
a104 1
(SvFAKE and name of '&' is not a meaningful combination currently but could
d107 30
d144 1
d146 4
d151 31
a181 1
#define PAD_MAX 999999999
d183 34
d220 1
a220 1
=for apidoc pad_new
d222 3
a224 3
Create a new compiling padlist, saving and updating the various global
vars at the same time as creating the pad itself. The following flags
can be OR'ed together:
d227 1
a227 1
    padnew_SAVE		save old globals
d236 4
a239 1
    AV *padlist, *padname, *pad, *a0;
a252 1
	SAVESPTR(PL_comppad_name);
d254 1
d259 1
d261 1
a261 1
		SAVEI32(PL_pad_reset_pending);
d270 1
a270 2
    padlist	= newAV();
    padname	= newAV();
d279 5
a283 4
	a0 = newAV();			/* will be @@_ */
	av_extend(a0, 0);
	av_store(pad, 0, (SV*)a0);
	AvFLAGS(a0) = AVf_REIFY;
d286 4
a289 8
#ifdef USE_5005THREADS
	av_store(padname, 0, newSVpvn("@@_", 2));
	a0 = newAV();
	SvPADMY_on((SV*)a0);		/* XXX Needed? */
	av_store(pad, 0, (SV*)a0);
#else
	av_store(pad, 0, Nullsv);
#endif /* USE_THREADS */
d292 9
a300 3
    AvREAL_off(padlist);
    av_store(padlist, 0, (SV*)padname);
    av_store(padlist, 1, (SV*)pad);
d304 2
a305 3
    PL_comppad_name	= (AV*)(*av_fetch(padlist, 0, FALSE));
    PL_comppad		= (AV*)(*av_fetch(padlist, 1, FALSE));
    PL_curpad		= AvARRAY(PL_comppad);
d308 1
d312 1
d316 1
a316 1
	  "Pad 0x%"UVxf"[0x%"UVxf"] new:       padlist=0x%"UVxf
d318 1
a318 1
	  PTR2UV(PL_comppad), PTR2UV(PL_curpad), PTR2UV(padlist),
d326 1
d328 1
a328 1
=for apidoc pad_undef
d330 1
a330 5
Free the padlist associated with a CV.
If parts of it happen to be current, we null the relevant
PL_*pad* global vars so that we don't have any dangling references left.
We also repoint the CvOUTSIDE of any about-to-be-orphaned
inner subs to the outer of this cv.
d332 4
a335 2
(This function should really be called pad_free, but the name was already
taken)
d341 1
a341 1
Perl_pad_undef(pTHX_ CV* cv)
d343 3
a345 2
    I32 ix;
    PADLIST *padlist = CvPADLIST(cv);
d347 1
a347 4
    if (!padlist)
	return;
    if (!SvREFCNT(CvPADLIST(cv))) /* may be during global destruction */
	return;
d350 2
a351 1
	  "Pad undef: padlist=0x%"UVxf"\n" , PTR2UV(padlist))
d354 99
a452 36
    /* detach any '&' anon children in the pad; if afterwards they
     * are still live, fix up their CvOUTSIDEs to point to our outside,
     * bypassing us. */
    /* XXX DAPM for efficiency, we should only do this if we know we have
     * children, or integrate this loop with general cleanup */

    if (!PL_dirty) { /* don't bother during global destruction */
	CV *outercv = CvOUTSIDE(cv);
	U32 seq = CvOUTSIDE_SEQ(cv);
	AV *comppad_name = (AV*)AvARRAY(padlist)[0];
	SV **namepad = AvARRAY(comppad_name);
	AV *comppad = (AV*)AvARRAY(padlist)[1];
	SV **curpad = AvARRAY(comppad);
	for (ix = AvFILLp(comppad_name); ix > 0; ix--) {
	    SV *namesv = namepad[ix];
	    if (namesv && namesv != &PL_sv_undef
		&& *SvPVX(namesv) == '&')
	    {
		CV *innercv = (CV*)curpad[ix];
		namepad[ix] = Nullsv;
		SvREFCNT_dec(namesv);
		curpad[ix] = Nullsv;
		SvREFCNT_dec(innercv);
		if (SvREFCNT(innercv) /* in use, not just a prototype */
		    && CvOUTSIDE(innercv) == cv)
		{
		    assert(CvWEAKOUTSIDE(innercv));
		    /* don't relink to grandfather if he's being freed */
		    if (outercv && SvREFCNT(outercv)) {
			CvWEAKOUTSIDE_off(innercv);
			CvOUTSIDE(innercv) = outercv;
			CvOUTSIDE_SEQ(innercv) = seq;
			SvREFCNT_inc(outercv);
		    }
		    else {
			CvOUTSIDE(innercv) = Nullcv;
d454 2
d457 7
d465 1
a465 1

d468 9
d479 13
a491 12
    ix = AvFILLp(padlist);
    while (ix >= 0) {
	SV* sv = AvARRAY(padlist)[ix--];
	if (!sv)
	    continue;
	if (sv == (SV*)PL_comppad_name)
	    PL_comppad_name = Nullav;
	else if (sv == (SV*)PL_comppad) {
	    PL_comppad = Null(PAD*);
	    PL_curpad = Null(SV**);
	}
	SvREFCNT_dec(sv);
d493 4
a496 2
    SvREFCNT_dec((SV*)CvPADLIST(cv));
    CvPADLIST(cv) = Null(PADLIST*);
d499 2
d502 5
d508 2
d511 7
a517 2
/*
=for apidoc pad_add_name
d519 1
a519 5
Create a new name in the current pad at the specified offset.
If C<typestash> is valid, the name is for a typed lexical; set the
name's stash to that value.
If C<ourstash> is valid, it's an our lexical, set the name's
GvSTASH to that value
d521 1
a521 1
Also, if the name is @@.. or %.., create a new array or hash for that slot
d523 5
a527 1
If fake, it means we're cloning an existing entry
d529 10
a538 2
=cut
*/
d541 1
a541 5
 * XXX DAPM this doesn't seem the right place to create a new array/hash.
 * Whatever we do, we should be consistent - create scalars too, and
 * create even if fake. Really need to integrate better the whole entry
 * creation business - when + where does the name and value get created?
 */
d543 8
a550 5
PADOFFSET
Perl_pad_add_name(pTHX_ char *name, HV* typestash, HV* ourstash, bool fake)
{
    PADOFFSET offset = pad_alloc(OP_PADSV, SVs_PADMY);
    SV* namesv = NEWSV(1102, 0);
d552 2
a553 1
    ASSERT_CURPAD_ACTIVE("pad_add_name");
d555 5
d561 1
a561 5
    DEBUG_Xv(PerlIO_printf(Perl_debug_log,
	  "Pad addname: %ld \"%s\"%s\n",
	   (long)offset, name, (fake ? " FAKE" : "")
	  )
    );
d563 1
a563 2
    sv_upgrade(namesv, ourstash ? SVt_PVGV : typestash ? SVt_PVMG : SVt_PVNV);
    sv_setpv(namesv, name);
d566 3
a568 2
	SvFLAGS(namesv) |= SVpad_TYPED;
	SvSTASH(namesv) = (HV*)SvREFCNT_inc((SV*) typestash);
d571 6
a576 2
	SvFLAGS(namesv) |= SVpad_OUR;
	GvSTASH(namesv) = (HV*)SvREFCNT_inc((SV*) ourstash);
d580 51
a630 17
    if (fake)
	SvFAKE_on(namesv);
    else {
	/* not yet introduced */
	SvNVX(namesv) = (NV)PAD_MAX;	/* min */
	SvIVX(namesv) = 0;		/* max */

	if (!PL_min_intro_pending)
	    PL_min_intro_pending = offset;
	PL_max_intro_pending = offset;
	/* XXX DAPM since slot has been allocated, replace
	 * av_store with PL_curpad[offset] ? */
	if (*name == '@@')
	    av_store(PL_comppad, offset, (SV*)newAV());
	else if (*name == '%')
	    av_store(PL_comppad, offset, (SV*)newHV());
	SvPADMY_on(PL_curpad[offset]);
d632 35
d671 5
d677 2
d680 7
d689 4
a692 1
=for apidoc pad_alloc
d694 37
a730 3
Allocate a new my or tmp pad entry. For a my, simply push a null SV onto
the end of PL_comppad, but for a tmp, scan the pad from PL_padix upwards
for a slot which has no name and and no active value.
a737 1

d741 1
d745 1
d749 2
a750 1
	Perl_croak(aTHX_ "panic: pad_alloc");
d754 2
a755 3
	do {
	    sv = *av_fetch(PL_comppad, AvFILLp(PL_comppad) + 1, TRUE);
	} while (SvPADBUSY(sv));		/* need a fresh one */
d759 5
a763 2
	SV **names = AvARRAY(PL_comppad_name);
	SSize_t names_fill = AvFILLp(PL_comppad_name);
d766 3
a768 2
	     * "foreach" index vars temporarily become aliases to non-"my"
	     * values.  Thus we must skip, not just pad values that are
a770 1
	    /* HVDS why copy to sv here? we don't seem to use it */
d776 1
a776 1
		!IS_PADGV(sv) && !IS_PADCONST(sv))
d779 5
d793 4
d801 1
a801 1
=for apidoc pad_add_anon
d803 11
a813 1
Add an anon code entry to the current compiling pad
d819 1
a819 1
Perl_pad_add_anon(pTHX_ SV* sv, OPCODE op_type)
d821 1
d823 1
a823 1
    SV* name;
d825 9
a833 6
    name = NEWSV(1106, 0);
    sv_upgrade(name, SVt_PVNV);
    sv_setpvn(name, "&", 1);
    SvIVX(name) = -1;
    SvNVX(name) = 1;
    ix = pad_alloc(op_type, SVs_PADMY);
d836 9
a844 2
    av_store(PL_comppad, ix, sv);
    SvPADMY_on(sv);
d848 4
a851 4
    if (CvOUTSIDE((CV*)sv)) {
	assert(!CvWEAKOUTSIDE((CV*)sv));
	CvWEAKOUTSIDE_on((CV*)sv);
	SvREFCNT_dec(CvOUTSIDE((CV*)sv));
a855 2


d860 1
d862 4
a865 3
     * an our (anywhere in the pad) with the same name and the same stash
       as C<ourstash>
C<is_our> indicates that the name to check is an 'our' declaration
d870 2
a871 4
/* XXX DAPM integrate this into pad_add_name ??? */

void
Perl_pad_check_dup(pTHX_ char *name, bool is_our, HV *ourstash)
d873 2
a874 1
    SV		**svp, *sv;
d876 3
d881 4
a884 1
    if (!ckWARN(WARN_MISC) || AvFILLp(PL_comppad_name) < 0)
d893 3
a895 2
	if ((sv = svp[off])
	    && sv != &PL_sv_undef
d897 3
a899 4
	    && (SvIVX(sv) == PAD_MAX || SvIVX(sv) == 0)
	    && (!is_our
		|| ((SvFLAGS(sv) & SVpad_OUR) && GvSTASH(sv) == ourstash))
	    && strEQ(name, SvPVX(sv)))
d901 3
d905 6
a910 4
		"\"%s\" variable %s masks earlier declaration in same %s",
		(is_our ? "our" : "my"),
		name,
		(SvIVX(sv) == PAD_MAX ? "scope" : "statement"));
d917 4
a920 3
	do {
	    if ((sv = svp[off])
		&& sv != &PL_sv_undef
d922 4
a925 3
		&& (SvIVX(sv) == PAD_MAX || SvIVX(sv) == 0)
		&& ((SvFLAGS(sv) & SVpad_OUR) && GvSTASH(sv) == ourstash)
		&& strEQ(name, SvPVX(sv)))
d928 4
a931 3
		    "\"our\" variable %s redeclared", name);
		Perl_warner(aTHX_ packWARN(WARN_MISC),
		    "\t(Did you mean \"local\" instead of \"our\"?)\n");
d934 72
a1005 1
	} while ( off-- > 0 );
d1007 1
d1010 2
d1013 12
d1027 1
a1027 1
=for apidoc pad_findmy
d1029 2
a1030 5
Given a lexical name, try to find its offset, first in the current pad,
or failing that, in the pads of any lexically enclosing subs (including
the complications introduced by eval). If the name is found in an outer pad,
then a fake entry is added to the current pad.
Returns the offset in the current pad, or NOT_IN_PAD on failure.
d1036 1
a1036 1
Perl_pad_findmy(pTHX_ char *name)
d1038 40
a1077 6
    I32 off;
    I32 fake_off = 0;
    I32 our_off = 0;
    SV *sv;
    SV **svp = AvARRAY(PL_comppad_name);
    U32 seq = PL_cop_seqmax;
d1079 6
a1084 2
    ASSERT_CURPAD_ACTIVE("pad_findmy");
    DEBUG_Xv(PerlIO_printf(Perl_debug_log, "Pad findmy:  \"%s\"\n", name));
d1086 2
a1087 39
#ifdef USE_5005THREADS
    /*
     * Special case to get lexical (and hence per-thread) @@_.
     * XXX I need to find out how to tell at parse-time whether use
     * of @@_ should refer to a lexical (from a sub) or defgv (global
     * scope and maybe weird sub-ish things like formats). See
     * startsub in perly.y.  It's possible that @@_ could be lexical
     * (at least from subs) even in non-threaded perl.
     */
    if (strEQ(name, "@@_"))
	return 0;		/* success. (NOT_IN_PAD indicates failure) */
#endif /* USE_5005THREADS */

    /* The one we're looking for is probably just before comppad_name_fill. */
    for (off = AvFILLp(PL_comppad_name); off > 0; off--) {
	sv = svp[off];
	if (!sv || sv == &PL_sv_undef || !strEQ(SvPVX(sv), name))
	    continue;
	if (SvFAKE(sv)) {
	    /* we'll use this later if we don't find a real entry */
	    fake_off = off;
	    continue;
	}
	else {
	    if (   seq >  U_32(SvNVX(sv))	/* min */
		&& seq <= (U32)SvIVX(sv))	/* max */
		return off;
	    else if ((SvFLAGS(sv) & SVpad_OUR)
		    && U_32(SvNVX(sv)) == PAD_MAX) /* min */
	    {
		/* look for an our that's being introduced; this allows
		 *    our $foo = 0 unless defined $foo;
		 * to not give a warning. (Yes, this is a hack) */
		our_off = off;
	    }
	}
    }
    if (fake_off)
	return fake_off;
d1089 2
a1090 7
    /* See if it's in a nested scope */
    off = pad_findlex(name, 0, PL_compcv);
    if (off)			/* pad_findlex returns 0 for failure...*/
	return off;
    if (our_off)
	return our_off;
    return NOT_IN_PAD;		/* ...but we return NOT_IN_PAD for failure */
d1092 1
d1095 8
d1104 8
d1114 13
a1126 1
=for apidoc pad_findlex
d1128 5
a1132 5
Find a named lexical anywhere in a chain of nested pads. Add fake entries
in the inner pads if it's found in an outer one. innercv is the CV *inside*
the chain of outer CVs to be searched. If newoff is non-null, this is a
run-time cloning: don't add fake entries, just find the lexical and add a
ref to it at newoff in the current pad.
d1137 19
d1157 2
a1158 1
S_pad_findlex(pTHX_ char *name, PADOFFSET newoff, CV* innercv)
d1160 15
a1174 9
    CV *cv;
    I32 off = 0;
    SV *sv;
    CV* startcv;
    U32 seq;
    I32 depth;
    AV *oldpad;
    SV *oldsv;
    AV *curlist;
a1175 1
    ASSERT_CURPAD_ACTIVE("pad_findlex");
d1177 41
a1217 3
	"Pad findlex: \"%s\" off=%ld startcv=0x%"UVxf"\n",
	    name, (long)newoff, PTR2UV(innercv))
    );
d1219 6
a1224 2
    seq = CvOUTSIDE_SEQ(innercv);
    startcv = CvOUTSIDE(innercv);
d1226 22
a1247 28
    for (cv = startcv; cv; seq = CvOUTSIDE_SEQ(cv), cv = CvOUTSIDE(cv)) {
	SV **svp;
	AV *curname;
	I32 fake_off = 0;

	DEBUG_Xv(PerlIO_printf(Perl_debug_log,
	    "             searching: cv=0x%"UVxf" seq=%d\n",
	    PTR2UV(cv), (int) seq )
	);

	curlist = CvPADLIST(cv);
	if (!curlist)
	    continue; /* an undef CV */
	svp = av_fetch(curlist, 0, FALSE);
	if (!svp || *svp == &PL_sv_undef)
	    continue;
	curname = (AV*)*svp;
	svp = AvARRAY(curname);

	depth = CvDEPTH(cv);
	for (off = AvFILLp(curname); off > 0; off--) {
	    sv = svp[off];
	    if (!sv || sv == &PL_sv_undef || !strEQ(SvPVX(sv), name))
		continue;
	    if (SvFAKE(sv)) {
		/* we'll use this later if we don't find a real entry */
		fake_off = off;
		continue;
d1249 9
a1257 6
	    else {
		if (   seq >  U_32(SvNVX(sv))	/* min */
		    && seq <= (U32)SvIVX(sv)	/* max */
		    && !(newoff && !depth) /* ignore inactive when cloning */
		)
		    goto found;
a1258 1
	}
d1260 1
a1260 10
	/* no real entry - but did we find a fake one? */
	if (fake_off) {
	    if (newoff && !depth)
		return 0; /* don't clone from inactive stack frame */
	    off = fake_off;
	    sv = svp[off];
	    goto found;
	}
    }
    return 0;
d1262 1
a1262 1
found:
d1264 5
a1268 2
    if (!depth) 
	depth = 1;
d1270 10
a1279 2
    oldpad = (AV*)AvARRAY(curlist)[depth];
    oldsv = *av_fetch(oldpad, off, TRUE);
d1281 2
a1282 20
#ifdef DEBUGGING
    if (SvFAKE(sv))
	DEBUG_Xv(PerlIO_printf(Perl_debug_log,
		"             matched:   offset %ld"
		    " FAKE, sv=0x%"UVxf"\n",
		(long)off,
		PTR2UV(oldsv)
	    )
	);
    else
	DEBUG_Xv(PerlIO_printf(Perl_debug_log,
		"             matched:   offset %ld"
		    " (%lu,%lu), sv=0x%"UVxf"\n",
		(long)off,
		(unsigned long)U_32(SvNVX(sv)),
		(unsigned long)SvIVX(sv),
		PTR2UV(oldsv)
	    )
	);
#endif
d1284 13
a1296 38
    if (!newoff) {		/* Not a mere clone operation. */
	newoff = pad_add_name(
	    SvPVX(sv),
	    (SvFLAGS(sv) & SVpad_TYPED) ? SvSTASH(sv) : Nullhv,
	    (SvFLAGS(sv) & SVpad_OUR)   ? GvSTASH(sv) : Nullhv,
	    1  /* fake */
	);

	if (CvANON(PL_compcv) || SvTYPE(PL_compcv) == SVt_PVFM) {
	    /* "It's closures all the way down." */
	    CvCLONE_on(PL_compcv);
	    if (cv == startcv) {
		if (CvANON(PL_compcv))
		    oldsv = Nullsv; /* no need to keep ref */
	    }
	    else {
		CV *bcv;
		for (bcv = startcv;
		     bcv && bcv != cv && !CvCLONE(bcv);
		     bcv = CvOUTSIDE(bcv))
		{
		    if (CvANON(bcv)) {
			/* install the missing pad entry in intervening
			 * nested subs and mark them cloneable. */
			AV *ocomppad_name = PL_comppad_name;
			PAD *ocomppad = PL_comppad;
			AV *padlist = CvPADLIST(bcv);
			PL_comppad_name = (AV*)AvARRAY(padlist)[0];
			PL_comppad = (AV*)AvARRAY(padlist)[1];
			PL_curpad = AvARRAY(PL_comppad);
			pad_add_name(
			    SvPVX(sv),
			    (SvFLAGS(sv) & SVpad_TYPED)
				? SvSTASH(sv) : Nullhv,
			    (SvFLAGS(sv) & SVpad_OUR)
				? GvSTASH(sv) : Nullhv,
			    1  /* fake */
			);
d1298 14
a1311 5
			PL_comppad_name = ocomppad_name;
			PL_comppad = ocomppad;
			PL_curpad = ocomppad ?
				AvARRAY(ocomppad) : Null(SV **);
			CvCLONE_on(bcv);
d1313 16
a1328 9
		    else {
			if (ckWARN(WARN_CLOSURE)
			    && !CvUNIQUE(bcv) && !CvUNIQUE(cv))
			{
			    Perl_warner(aTHX_ packWARN(WARN_CLOSURE),
			      "Variable \"%s\" may be unavailable",
				 name);
			}
			break;
d1331 10
d1342 64
d1407 8
a1414 7
	else if (!CvUNIQUE(PL_compcv)) {
	    if (ckWARN(WARN_CLOSURE) && !SvFAKE(sv) && !CvUNIQUE(cv)
		&& !(SvFLAGS(sv) & SVpad_OUR))
	    {
		Perl_warner(aTHX_ packWARN(WARN_CLOSURE),
		    "Variable \"%s\" will not stay shared", name);
	    }
d1416 6
d1423 1
a1423 8
    av_store(PL_comppad, newoff, SvREFCNT_inc(oldsv));
    ASSERT_CURPAD_ACTIVE("pad_findlex 2");
    DEBUG_Xv(PerlIO_printf(Perl_debug_log,
		"Pad findlex: set offset %ld to sv 0x%"UVxf"\n",
		(long)newoff, PTR2UV(oldsv)
	    )
    );
    return newoff;
d1426 1
d1429 1
a1429 1
=for apidoc pad_sv
d1431 1
a1431 1
Get the value at offset po in the current pad.
a1436 1

d1440 1
a1442 1
#ifndef USE_5005THREADS
a1444 1
#endif
a1451 1

d1453 1
a1453 1
=for apidoc pad_setsv
d1455 1
a1455 1
Set the entry at offset po in the current pad to sv.
a1460 1
#ifdef DEBUGGING
d1464 4
a1475 2
#endif

d1477 1
d1480 1
a1480 1
=for apidoc pad_block_start
d1482 1
a1482 1
Update the pad compilation state variables on entry to a new block
d1496 1
a1512 1

d1514 1
a1514 1
=for apidoc intro_my
d1516 3
a1518 1
"Introduce" my variables to visible status.
d1526 1
a1527 1
    SV *sv;
d1529 1
d1537 4
a1540 2
	if ((sv = svp[i]) && sv != &PL_sv_undef
		&& !SvFAKE(sv) && !SvIVX(sv))
d1542 2
a1543 2
	    SvIVX(sv) = PAD_MAX;	/* Don't know scope end yet. */
	    SvNVX(sv) = (NV)PL_cop_seqmax;
d1546 3
a1548 2
		(long)i, SvPVX(sv),
		(unsigned long)U_32(SvNVX(sv)), (unsigned long)SvIVX(sv))
d1552 4
d1559 1
a1559 1
		"Pad intromy: seq -> %ld\n", (long)(PL_cop_seqmax+1)));
d1561 1
a1561 1
    return PL_cop_seqmax++;
d1565 1
a1565 1
=for apidoc pad_leavemy
d1573 1
a1573 1
void
d1576 1
d1578 2
a1579 2
    SV **svp = AvARRAY(PL_comppad_name);
    SV *sv;
d1586 5
a1590 4
	    if ((sv = svp[off]) && sv != &PL_sv_undef
		    && !SvFAKE(sv) && ckWARN_d(WARN_INTERNAL))
		Perl_warner(aTHX_ packWARN(WARN_INTERNAL),
					"%"SVf" never introduced", sv);
d1595 3
a1597 2
	if ((sv = svp[off]) && sv != &PL_sv_undef
		&& !SvFAKE(sv) && SvIVX(sv) == PAD_MAX)
d1599 1
a1599 1
	    SvIVX(sv) = PL_cop_seqmax;
d1602 3
a1604 2
		(long)off, SvPVX(sv),
		(unsigned long)U_32(SvNVX(sv)), (unsigned long)SvIVX(sv))
d1606 6
d1615 2
d1619 1
a1621 1

d1623 1
a1623 1
=for apidoc pad_swipe
d1634 1
d1639 5
a1643 3
	Perl_croak(aTHX_ "panic: pad_swipe curpad");
    if (!po)
	Perl_croak(aTHX_ "panic: pad_swipe po");
a1648 2
    if (PL_curpad[po])
	SvPADTMP_off(PL_curpad[po]);
d1652 5
a1656 1
    PL_curpad[po] = NEWSV(1107,0);
d1658 10
a1671 1

d1673 1
a1673 1
=for apidoc pad_reset
d1686 2
a1687 2
void
Perl_pad_reset(pTHX)
d1689 1
a1690 2
    register I32 po;

d1692 2
a1693 1
	Perl_croak(aTHX_ "panic: pad_reset curpad");
d1702 2
a1703 1
    if (!PL_tainting) {	/* Can't mix tainted and non-tainted temporaries. */
a1713 1

d1715 1
a1715 1
=for apidoc pad_tidy
d1717 8
a1724 4
Tidy up a pad after we've finished compiling it:
    * remove most stuff from the pads of anonsub prototypes;
    * give it a @@_;
    * mark tmps as such.
d1737 1
a1737 1
    PADOFFSET ix;
d1740 33
a1772 1
    /* extend curpad to match namepad */
d1774 1
a1774 1
	av_store(PL_comppad_name, AvFILLp(PL_comppad), Nullsv);
d1777 3
a1779 1
	SV **namep = AvARRAY(PL_comppad_name);
d1782 1
a1783 2
	    if (SvIMMORTAL(PL_curpad[ix]) || IS_PADGV(PL_curpad[ix]) || IS_PADCONST(PL_curpad[ix]))
		continue;
d1786 1
a1786 1
	     * pad are references to outer lexicals and anonymous subs.
d1789 6
a1794 4
	    if (!((namesv = namep[ix]) != Nullsv &&
		  namesv != &PL_sv_undef &&
		  (SvFAKE(namesv) ||
		   *SvPVX(namesv) == '&')))
d1797 1
a1797 1
		PL_curpad[ix] = Nullsv;
d1803 3
a1805 4
	AV *av = newAV();			/* Will be @@_ */
	av_extend(av, 0);
	av_store(PL_comppad, 0, (SV*)av);
	AvFLAGS(av) = AVf_REIFY;
d1808 3
a1810 3
    /* XXX DAPM rationalise these two similar branches */

    if (type == padtidy_SUB) {
d1812 3
a1814 1
	    if (SvIMMORTAL(PL_curpad[ix]) || IS_PADGV(PL_curpad[ix]) || IS_PADCONST(PL_curpad[ix]))
d1816 1
a1816 7
	    if (!SvPADMY(PL_curpad[ix]))
		SvPADTMP_on(PL_curpad[ix]);
	}
    }
    else if (type == padtidy_FORMAT) {
	for (ix = AvFILLp(PL_comppad); ix > 0; ix--) {
	    if (!SvPADMY(PL_curpad[ix]) && !SvIMMORTAL(PL_curpad[ix]))
d1818 19
a1841 1

d1843 1
a1843 1
=for apidoc pad_free
d1845 1
a1845 1
Free the SV at offet po in the current pad.
d1854 2
d1860 2
a1861 1
	Perl_croak(aTHX_ "panic: pad_free curpad");
a1869 7
    if (PL_curpad[po] && PL_curpad[po] != &PL_sv_undef) {
	SvPADTMP_off(PL_curpad[po]);
#ifdef USE_ITHREADS
	/* SV could be a shared hash key (eg bugid #19022) */
	if (!SvFAKE(PL_curpad[po]))
	    SvREADONLY_off(PL_curpad[po]);	/* could be a freed constant */
#endif
d1871 4
a1874 1
    }
a1878 2


d1880 1
a1880 1
=for apidoc do_dump_pad
d1890 3
a1892 2
    AV *pad_name;
    AV *pad;
a1894 1
    SV *namesv;
d1897 2
d1902 2
a1903 2
    pad_name = (AV*)*av_fetch((AV*)padlist, 0, FALSE);
    pad = (AV*)*av_fetch((AV*)padlist, 1, FALSE);
d1912 3
a1914 3
	namesv = pname[ix];
	if (namesv && namesv == &PL_sv_undef) {
	    namesv = Nullsv;
d1919 1
a1919 1
		    "%2d. 0x%"UVxf"<%lu> FAKE \"%s\"\n",
d1923 4
a1926 1
		    SvPVX(namesv)
d1934 3
a1936 3
		    (unsigned long)U_32(SvNVX(namesv)),
		    (unsigned long)SvIVX(namesv),
		    SvPVX(namesv)
d1950 1
a1950 1

d1953 1
a1953 1
=for apidoc cv_dump
a1959 1
#ifdef DEBUGGING
d1961 1
a1961 1
S_cv_dump(pTHX_ CV *cv, char *title)
d1963 5
a1967 2
    CV *outside = CvOUTSIDE(cv);
    AV* padlist = CvPADLIST(cv);
d1974 1
d1989 1
a1991 4




d1993 1
a1993 1
=for apidoc cv_clone
d1995 5
a1999 3
Clone a CV: make a new CV which points to the same code etc, but which
has a newly-created pad built by copying the prototype pad and capturing
any outer lexicals.
d2004 1
a2004 11
CV *
Perl_cv_clone(pTHX_ CV *proto)
{
    CV *cv;

    LOCK_CRED_MUTEX;			/* XXX create separate mutex */
    cv = cv_clone2(proto, CvOUTSIDE(proto));
    UNLOCK_CRED_MUTEX;			/* XXX create separate mutex */
    return cv;
}

d2006 2
a2007 6
/* XXX DAPM separate out cv and paddish bits ???
 * ideally the CV-related stuff shouldn't be in pad.c - how about
 * a cv.c? */

STATIC CV *
S_cv_clone2(pTHX_ CV *proto, CV *outside)
d2009 1
d2011 10
a2020 9
    AV* protopadlist = CvPADLIST(proto);
    AV* protopad_name = (AV*)*av_fetch(protopadlist, 0, FALSE);
    AV* protopad = (AV*)*av_fetch(protopadlist, 1, FALSE);
    SV** pname = AvARRAY(protopad_name);
    SV** ppad = AvARRAY(protopad);
    I32 fname = AvFILLp(protopad_name);
    I32 fpad = AvFILLp(protopad);
    AV* comppadlist;
    CV* cv;
d2024 9
a2032 2
    ENTER;
    SAVESPTR(PL_compcv);
d2034 15
a2048 23
    cv = PL_compcv = (CV*)NEWSV(1104, 0);
    sv_upgrade((SV *)cv, SvTYPE(proto));
    CvFLAGS(cv) = CvFLAGS(proto) & ~(CVf_CLONE|CVf_WEAKOUTSIDE);
    CvCLONED_on(cv);

#ifdef USE_5005THREADS
    New(666, CvMUTEXP(cv), 1, perl_mutex);
    MUTEX_INIT(CvMUTEXP(cv));
    CvOWNER(cv)		= 0;
#endif /* USE_5005THREADS */
#ifdef USE_ITHREADS
    CvFILE(cv)		= CvXSUB(proto) ? CvFILE(proto)
					: savepv(CvFILE(proto));
#else
    CvFILE(cv)		= CvFILE(proto);
#endif
    CvGV(cv)		= CvGV(proto);
    CvSTASH(cv)		= CvSTASH(proto);
    CvROOT(cv)		= OpREFCNT_inc(CvROOT(proto));
    CvSTART(cv)		= CvSTART(proto);
    if (outside) {
	CvOUTSIDE(cv)	= (CV*)SvREFCNT_inc(outside);
	CvOUTSIDE_SEQ(cv) = CvOUTSIDE_SEQ(proto);
d2050 3
d2054 4
a2057 2
    if (SvPOK(proto))
	sv_setpvn((SV*)cv, SvPVX(proto), SvCUR(proto));
d2059 2
a2060 1
    CvPADLIST(cv) = comppadlist = pad_new(padnew_CLONE|padnew_SAVE);
d2062 3
a2064 2
    for (ix = fname; ix >= 0; ix--)
	av_store(PL_comppad_name, ix, SvREFCNT_inc(pname[ix]));
d2067 1
d2070 6
d2077 18
a2094 9
	SV* namesv = (ix <= fname) ? pname[ix] : Nullsv;
	if (namesv && namesv != &PL_sv_undef) {
	    char *name = SvPVX(namesv);    /* XXX */
	    if (SvFLAGS(namesv) & SVf_FAKE) {   /* lexical from outside? */
		I32 off = pad_findlex(name, ix, cv);
		if (!off)
		    PL_curpad[ix] = SvREFCNT_inc(ppad[ix]);
		else if (off != ix)
		    Perl_croak(aTHX_ "panic: cv_clone: %s", name);
d2096 34
a2129 10
	    else {				/* our own lexical */
		SV* sv;
		if (*name == '&') {
		    /* anon code -- we'll come back for it */
		    sv = SvREFCNT_inc(ppad[ix]);
		}
		else if (*name == '@@')
		    sv = (SV*)newAV();
		else if (*name == '%')
		    sv = (SV*)newHV();
d2131 5
a2135 4
		    sv = NEWSV(0, 0);
		if (!SvPADBUSY(sv))
		    SvPADMY_on(sv);
		PL_curpad[ix] = sv;
d2137 1
d2139 2
a2140 2
	else if (IS_PADGV(ppad[ix]) || IS_PADCONST(ppad[ix])) {
	    PL_curpad[ix] = SvREFCNT_inc(ppad[ix]);
d2143 1
a2143 1
	    SV* sv = NEWSV(0, 0);
a2144 1
	    PL_curpad[ix] = sv;
d2146 1
d2149 24
a2172 1
    /* Now that vars are all in place, clone nested closures. */
d2174 16
a2189 17
    for (ix = fpad; ix > 0; ix--) {
	SV* namesv = (ix <= fname) ? pname[ix] : Nullsv;
	if (namesv
	    && namesv != &PL_sv_undef
	    && !(SvFLAGS(namesv) & SVf_FAKE)
	    && *SvPVX(namesv) == '&'
	    && CvCLONE(ppad[ix]))
	{
	    CV *kid = cv_clone2((CV*)ppad[ix], cv);
	    SvREFCNT_dec(ppad[ix]);
	    CvCLONE_on(kid);
	    SvPADMY_on(kid);
	    PL_curpad[ix] = (SV*)kid;
	    /* '&' entry points to child, so child mustn't refcnt parent */
	    CvWEAKOUTSIDE_on(kid);
	    SvREFCNT_dec(cv);
	}
d2191 4
d2198 1
a2198 1
	cv_dump(outside, "Outside");
a2202 2
    LEAVE;

d2204 16
a2219 5
	SV* const_sv = op_const_sv(CvSTART(cv), cv);
	assert(const_sv);
	/* constant sub () { $x } closing over $x - see lib/constant.pm */
	SvREFCNT_dec(cv);
	cv = newCONSTSUB(CvSTASH(proto), 0, const_sv);
d2225 17
d2244 1
a2244 1
=for apidoc pad_fixup_inner_anons
d2247 1
a2247 1
old_cv to new_cv if necessary. Needed when a newly-compiled CV has to be
d2256 1
d2258 8
a2265 4
    AV *comppad_name = (AV*)AvARRAY(padlist)[0];
    AV *comppad = (AV*)AvARRAY(padlist)[1];
    SV **namepad = AvARRAY(comppad_name);
    SV **curpad = AvARRAY(comppad);
d2267 3
a2269 3
	SV *namesv = namepad[ix];
	if (namesv && namesv != &PL_sv_undef
	    && *SvPVX(namesv) == '&')
d2271 25
a2295 4
	    CV *innercv = (CV*)curpad[ix];
	    assert(CvWEAKOUTSIDE(innercv));
	    assert(CvOUTSIDE(innercv) == old_cv);
	    CvOUTSIDE(innercv) = new_cv;
a2299 1

d2301 1
a2301 1
=for apidoc pad_push
d2304 2
a2305 2
this depth, in which case don't bother creating a new one.
If has_args is true, give the new pad an @@_ in slot zero.
d2311 1
a2311 1
Perl_pad_push(pTHX_ PADLIST *padlist, int depth, int has_args)
d2313 12
a2324 2
    if (depth <= AvFILLp(padlist))
	return;
a2325 8
    {
	SV** svp = AvARRAY(padlist);
	AV *newpad = newAV();
	SV **oldpad = AvARRAY(svp[depth-1]);
	I32 ix = AvFILLp((AV*)svp[1]);
	I32 names_fill = AvFILLp((AV*)svp[0]);
	SV** names = AvARRAY(svp[0]);
	SV* sv;
d2327 6
a2332 3
	    if (names_fill >= ix && names[ix] != &PL_sv_undef) {
		char *name = SvPVX(names[ix]);
		if ((SvFLAGS(names[ix]) & SVf_FAKE) || *name == '&') {
d2337 5
a2341 4
		    if (*name == '@@')
			av_store(newpad, ix, sv = (SV*)newAV());
		    else if (*name == '%')
			av_store(newpad, ix, sv = (SV*)newHV());
d2343 2
a2344 1
			av_store(newpad, ix, sv = NEWSV(0, 0));
d2348 2
a2349 2
	    else if (IS_PADGV(oldpad[ix]) || IS_PADCONST(oldpad[ix])) {
		av_store(newpad, ix, sv = SvREFCNT_inc(oldpad[ix]));
d2353 2
a2354 1
		av_store(newpad, ix, sv = NEWSV(0, 0));
d2358 152
a2509 5
	if (has_args) {
	    AV* av = newAV();
	    av_extend(av, 0);
	    av_store(newpad, 0, (SV*)av);
	    AvFLAGS(av) = AVf_REIFY;
a2510 2
	av_store(padlist, depth, (SV*)newpad);
	AvFILLp(padlist) = depth;
d2512 28
d2541 10
@


1.1.1.1
log
@perl 5.8.2 from CPAN
@
text
@@


1.1.1.2
log
@Import of stock perl 5.8.5
@
text
@d3 1
a3 1
 *    Copyright (C) 2002, 2003, 2004, by Larry Wall and others
a85 6
The flag SVf_PADSTALE is cleared on lexicals each time the my() is executed,
and set on scope exit. This allows the 'Variable $x is not available' warning
to be generated in evals, such as 

    { my $x = 1; sub f { eval '$x'} } f();

d250 2
a251 5

		if (SvREFCNT(comppad) < 2) { /* allow for /(?{ sub{} })/  */
		    curpad[ix] = Nullsv;
		    SvREFCNT_dec(innercv);
		}
a1480 3

/* XXX pad_push is now always called with has_args == 1. Get rid of
 * this arg at some point */
@


1.1.1.3
log
@perl 5.8.6 from CPAN
@
text
@a24 5
This file contains the functions that create and manipulate scratchpads,
which are array-of-array data structures attached to a CV (ie a sub)
and which store lexical variables and opcode temporary and per-thread
values.

@


1.1.1.4
log
@perl 5.8.8 import
@
text
@d3 1
a3 1
 *    Copyright (C) 2002, 2003, 2004, 2005, 2006, by Larry Wall and others
d77 1
a77 1
stash of the associated global (so that duplicate C<our> declarations in the
d127 1
a127 1
    AV *padlist, *padname, *pad;
d167 1
a167 1
        AV * const a0 = newAV();			/* will be @@_ */
a173 1
        AV * const a0 = newAV();			/* will be @@_ */
d175 1
d229 1
a229 1
    const PADLIST * const padlist = CvPADLIST(cv);
d247 6
a252 6
	CV * const outercv = CvOUTSIDE(cv);
        const U32 seq = CvOUTSIDE_SEQ(cv);
	AV *  const comppad_name = (AV*)AvARRAY(padlist)[0];
	SV ** const namepad = AvARRAY(comppad_name);
	AV *  const comppad = (AV*)AvARRAY(padlist)[1];
	SV ** const curpad = AvARRAY(comppad);
d254 1
a254 1
	    SV * const namesv = namepad[ix];
d256 1
a256 1
		&& *SvPVX_const(namesv) == '&')
d258 1
a258 3
		CV * const innercv = (CV*)curpad[ix];
		U32 inner_rc = SvREFCNT(innercv);
		assert(inner_rc);
a264 1
		    inner_rc--;
d266 1
a266 1
		if (inner_rc /* in use, not just a prototype */
d275 1
a275 1
			(void)SvREFCNT_inc(outercv);
d289 1
a289 1
	SV* const sv = AvARRAY(padlist)[ix--];
d333 2
a334 2
    const PADOFFSET offset = pad_alloc(OP_PADSV, SVs_PADMY);
    SV* const namesv = NEWSV(1102, 0);
d350 1
a350 1
	SvSTASH_set(namesv, (HV*)SvREFCNT_inc((SV*) typestash));
d362 2
a363 2
	SvNV_set(namesv, (NV)PAD_MAX);	/* min */
	SvIV_set(namesv, 0);		/* max */
d388 1
a388 1
for a slot which has no name and no active value.
d416 2
a417 2
	SV * const * const names = AvARRAY(PL_comppad_name);
        const SSize_t names_fill = AvFILLp(PL_comppad_name);
d457 3
a459 1
    SV* const name = NEWSV(1106, 0);
d462 2
a463 2
    SvIV_set(name, -1);
    SvNV_set(name, 1);
d499 1
a499 1
    SV		**svp;
d503 1
a503 1
    if (AvFILLp(PL_comppad_name) < 0 || !ckWARN(WARN_MISC))
d512 1
a512 2
	SV * const sv = svp[off];
	if (sv
d518 1
a518 1
	    && strEQ(name, SvPVX_const(sv)))
d532 1
a532 2
	    SV * const sv = svp[off];
	    if (sv
d537 1
a537 1
		&& strEQ(name, SvPVX_const(sv)))
d592 1
a592 1
	if (!sv || sv == &PL_sv_undef || !strEQ(SvPVX_const(sv), name))
d641 1
a641 1
S_pad_findlex(pTHX_ const char *name, PADOFFSET newoff, const CV* innercv)
d684 1
a684 1
	    if (!sv || sv == &PL_sv_undef || !strEQ(SvPVX_const(sv), name))
d916 1
d925 5
a929 5
	SV * const sv = svp[i];

	if (sv && sv != &PL_sv_undef && !SvFAKE(sv) && !SvIVX(sv)) {
	    SvIV_set(sv, PAD_MAX);	/* Don't know scope end yet. */
	    SvNV_set(sv, (NV)PL_cop_seqmax);
d932 1
a932 1
		(long)i, SvPVX_const(sv),
d958 2
a959 1
    SV * const * const svp = AvARRAY(PL_comppad_name);
d966 1
a966 2
	    const SV * const sv = svp[off];
	    if (sv && sv != &PL_sv_undef
d974 4
a977 3
	const SV * const sv = svp[off];
	if (sv && sv != &PL_sv_undef && !SvFAKE(sv) && SvIVX(sv) == PAD_MAX) {
	    SvIV_set(sv, PL_cop_seqmax);
d980 1
a980 1
		(long)off, SvPVX_const(sv),
a1019 4

    /* if pad tmps aren't shared between ops, then there's no need to
     * create a new tmp when an existing op is freed */
#ifdef USE_BROKEN_PAD_RESET
a1021 3
#else
    PL_curpad[po] = &PL_sv_undef;
#endif
d1045 2
a1057 1
        register I32 po;
d1088 1
d1096 1
a1096 2
	SV * const * const namep = AvARRAY(PL_comppad_name);
	PADOFFSET ix;
d1110 1
a1110 1
		   *SvPVX_const(namesv) == '&')))
d1119 1
a1119 1
	AV * const av = newAV();			/* Will be @@_ */
a1127 1
	PADOFFSET ix;
a1135 1
	PADOFFSET ix;
d1148 1
a1148 1
Free the SV at offset po in the current pad.
d1196 2
a1197 2
    const AV *pad_name;
    const AV *pad;
d1200 1
d1216 1
a1216 1
        const SV *namesv = pname[ix];
d1227 1
a1227 1
		    SvPVX_const(namesv)
d1237 1
a1237 1
		    SvPVX_const(namesv)
d1263 1
a1263 1
S_cv_dump(pTHX_ const CV *cv, const char *title)
d1265 2
a1266 2
    const CV * const outside = CvOUTSIDE(cv);
    AV* const padlist = CvPADLIST(cv);
d1323 8
a1330 7
    AV* const protopadlist = CvPADLIST(proto);
    const AV* const protopad_name = (AV*)*av_fetch(protopadlist, 0, FALSE);
    const AV* const protopad = (AV*)*av_fetch(protopadlist, 1, FALSE);
    SV** const pname = AvARRAY(protopad_name);
    SV** const ppad = AvARRAY(protopad);
    const I32 fname = AvFILLp(protopad_name);
    const I32 fpad = AvFILLp(protopad);
a1355 1
    OP_REFCNT_LOCK;
a1356 1
    OP_REFCNT_UNLOCK;
d1364 1
a1364 1
	sv_setpvn((SV*)cv, SvPVX_const(proto), SvCUR(proto));
d1366 1
a1366 1
    CvPADLIST(cv) = pad_new(padnew_CLONE|padnew_SAVE);
d1375 1
a1375 1
	SV* const namesv = (ix <= fname) ? pname[ix] : Nullsv;
d1377 1
a1377 1
	    const char *name = SvPVX_const(namesv);    /* XXX */
d1443 1
a1443 1
	SV* const const_sv = op_const_sv(CvSTART(cv), cv);
d1447 1
a1447 1
	cv = newCONSTSUB(CvSTASH(proto), Nullch, const_sv);
d1468 4
a1471 4
    AV * const comppad_name = (AV*)AvARRAY(padlist)[0];
    AV * const comppad = (AV*)AvARRAY(padlist)[1];
    SV ** const namepad = AvARRAY(comppad_name);
    SV ** const curpad = AvARRAY(comppad);
d1473 1
a1473 1
        const SV * const namesv = namepad[ix];
d1475 1
a1475 1
	    && *SvPVX_const(namesv) == '&')
d1477 1
a1477 1
	    CV * const innercv = (CV*)curpad[ix];
d1506 3
a1508 3
	SV** const svp = AvARRAY(padlist);
	AV* const newpad = newAV();
	SV** const oldpad = AvARRAY(svp[depth-1]);
d1511 1
a1511 1
	SV** const names = AvARRAY(svp[0]);
d1515 1
a1515 1
		const char *name = SvPVX_const(names[ix]);
a1548 21


HV *
Perl_pad_compname_type(pTHX_ const PADOFFSET po)
{
    SV* const * const av = av_fetch(PL_comppad_name, po, FALSE);
    if ( SvFLAGS(*av) & SVpad_TYPED ) {
        return SvSTASH(*av);
    }
    return Nullhv;
}

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 noet:
 */
@


1.1.1.5
log
@import perl 5.10.0 from CPAN
@
text
@d3 1
a3 1
 *    Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007 by Larry Wall and others
d35 1
a35 2
executing). Require'd files are simply evals without any outer lexical
scope.
d74 11
a84 15
xlow+1..xhigh inclusive in the NV union is a range of cop_seq numbers for
which the name is valid.  For typed lexicals name SV is SVt_PVMG and SvSTASH
points at the type.  For C<our> lexicals, the type is also SVt_PVMG, with the
SvOURSTASH slot pointing at the stash of the associated global (so that
duplicate C<our> declarations in the same package can be detected).  SvUVX is
sometimes hijacked to store the generation number during compilation.

If SvFAKE is set on the name SV, then that slot in the frame AV is
a REFCNT'ed reference to a lexical from "outside". In this case,
the name SV does not use xlow and xhigh to store a cop_seq range, since it is
in scope throughout. Instead xhigh stores some flags containing info about
the real lexical (is it declared in an anon, and is it capable of being
instantiated multiple times?), and for fake ANONs, xlow contains the index
within the parent's pad where the lexical's value is stored, to make
cloning quicker.
a90 3
Note that formats are treated as anon subs, and are cloned each time
write is called (if necessary).

a103 1
#include "keywords.h"
d105 4
a108 18
#define COP_SEQ_RANGE_LOW_set(sv,val)		\
  STMT_START { ((XPVNV*)SvANY(sv))->xnv_u.xpad_cop_seq.xlow = (val); } STMT_END
#define COP_SEQ_RANGE_HIGH_set(sv,val)		\
  STMT_START { ((XPVNV*)SvANY(sv))->xnv_u.xpad_cop_seq.xhigh = (val); } STMT_END

#define PARENT_PAD_INDEX_set(sv,val)		\
  STMT_START { ((XPVNV*)SvANY(sv))->xnv_u.xpad_cop_seq.xlow = (val); } STMT_END
#define PARENT_FAKELEX_FLAGS_set(sv,val)	\
  STMT_START { ((XPVNV*)SvANY(sv))->xnv_u.xpad_cop_seq.xhigh = (val); } STMT_END

#define PAD_MAX I32_MAX

#ifdef PERL_MAD
void pad_peg(const char* s) {
    static int pegcnt;
    pegcnt++;
}
#endif
a126 1
    dVAR;
a146 1
	    SAVEBOOL(PL_cv_has_eval);
d170 1
a170 1
	AvREIFY_only(a0);
d173 8
a180 1
	av_store(pad, 0, NULL);
a196 1
	PL_cv_has_eval	     = 0;
d200 1
a200 1
	  "Pad 0x%"UVxf"[0x%"UVxf"] new:       compcv=0x%"UVxf
d202 1
a202 1
	  PTR2UV(PL_comppad), PTR2UV(PL_curpad), PTR2UV(PL_compcv),
a227 1
    dVAR;
a230 1
    pad_peg("pad_undef");
d233 1
a233 1
    if (SvIS_FREED(padlist)) /* may be during global destruction */
d237 1
a237 2
	  "Pad undef: cv=0x%"UVxf" padlist=0x%"UVxf" comppad=0x%"UVxf"\n",
	    PTR2UV(cv), PTR2UV(padlist), PTR2UV(PL_comppad))
d261 1
a261 1
		namepad[ix] = NULL;
d265 1
a265 1
		    curpad[ix] = NULL;
d269 3
a271 3

		/* in use, not just a prototype */
		if (inner_rc && (CvOUTSIDE(innercv) == cv)) {
d278 1
a278 1
			SvREFCNT_inc_simple_void_NN(outercv);
d281 1
a281 1
			CvOUTSIDE(innercv) = NULL;
d283 1
d285 1
d292 8
a299 8
	const SV* const sv = AvARRAY(padlist)[ix--];
	if (sv) {
	    if (sv == (SV*)PL_comppad_name)
		PL_comppad_name = NULL;
	    else if (sv == (SV*)PL_comppad) {
		PL_comppad = NULL;
		PL_curpad = NULL;
	    }
d304 1
a304 1
    CvPADLIST(cv) = NULL;
d313 1
a313 2
Create a new name and associated PADMY SV in the current pad; return the
offset.
d317 3
a319 1
SvOURSTASH to that value
d326 7
d334 1
a334 1
Perl_pad_add_name(pTHX_ const char *name, HV* typestash, HV* ourstash, bool fake, bool state)
a335 1
    dVAR;
d337 1
a337 2
    SV* const namesv
	= newSV_type((ourstash || typestash) ? SVt_PVMG : SVt_PVNV);
d341 8
d352 2
a353 3
	assert(SvTYPE(namesv) == SVt_PVMG);
	SvPAD_TYPED_on(namesv);
	SvSTASH_set(namesv, (HV*)SvREFCNT_inc_simple_NN((SV*)typestash));
d356 2
a357 6
	SvPAD_OUR_on(namesv);
	SvOURSTASH_set(namesv, ourstash);
	SvREFCNT_inc_simple_void_NN(ourstash);
    }
    else if (state) {
	SvPAD_STATE_on(namesv);
d361 1
a361 1
    if (fake) {
a362 3
	DEBUG_Xv(PerlIO_printf(Perl_debug_log,
	    "Pad addname: %ld \"%s\" FAKE\n", (long)offset, name));
    }
d365 2
a366 2
	COP_SEQ_RANGE_LOW_set(namesv, PAD_MAX);	/* min */
	COP_SEQ_RANGE_HIGH_set(namesv, 0);		/* max */
a370 1
	/* if it's not a simple scalar, replace with an AV or HV */
a377 3
	DEBUG_Xv(PerlIO_printf(Perl_debug_log,
	    "Pad addname: %ld \"%s\" new lex=0x%"UVxf"\n",
	    (long)offset, name, PTR2UV(PL_curpad[offset])));
d398 1
a398 5
/* And flag whether the incoming name is UTF8 or 8 bit?
   Could do this either with the +ve/-ve hack of the HV code, or expanding
   the flag bits. Either way, this makes proper Unicode safe pad support.
   NWC
*/
a402 1
    dVAR;
a405 1
    PERL_UNUSED_ARG(optype);
d413 3
a415 1
	sv = *av_fetch(PL_comppad, AvFILLp(PL_comppad) + 1, TRUE);
a444 4
#ifdef DEBUG_LEAKING_SCALARS
    sv->sv_debug_optype = optype;
    sv->sv_debug_inpad = 1;
#endif
a458 1
    dVAR;
d460 2
a461 2
    SV* const name = newSV_type(SVt_PVNV);
    pad_peg("add_anon");
d463 2
a464 3
    /* Are these two actually ever read? */
    COP_SEQ_RANGE_HIGH_set(name, ~0);
    COP_SEQ_RANGE_LOW_set(name, 1);
d498 1
a498 1
Perl_pad_check_dup(pTHX_ const char *name, bool is_our, const HV *ourstash)
a499 1
    dVAR;
d517 3
a519 1
	    && (COP_SEQ_RANGE_HIGH(sv) == PAD_MAX || COP_SEQ_RANGE_HIGH(sv) == 0)
a521 2
	    if (is_our && (SvPAD_OUR(sv)))
		break; /* "our" masking "our" */
d524 1
a524 1
		(is_our ? "our" : PL_parser->in_my == KEY_my ? "my" : "state"),
d526 1
a526 1
		(COP_SEQ_RANGE_HIGH(sv) == PAD_MAX ? "scope" : "statement"));
d538 2
a539 2
		&& (COP_SEQ_RANGE_HIGH(sv) == PAD_MAX || COP_SEQ_RANGE_HIGH(sv) == 0)
		&& SvOURSTASH(sv) == ourstash
d544 2
a545 3
		if ((I32)off <= PL_comppad_name_floor)
		    Perl_warner(aTHX_ packWARN(WARN_MISC),
			"\t(Did you mean \"local\" instead of \"our\"?)\n");
d553 1
d567 1
a567 1
Perl_pad_findmy(pTHX_ const char *name)
d569 46
a614 28
    dVAR;
    SV *out_sv;
    int out_flags;
    I32 offset;
    const AV *nameav;
    SV **name_svp;

    pad_peg("pad_findmy");
    offset = pad_findlex(name, PL_compcv, PL_cop_seqmax, 1,
		NULL, &out_sv, &out_flags);
    if ((PADOFFSET)offset != NOT_IN_PAD) 
	return offset;

    /* look for an our that's being introduced; this allows
     *    our $foo = 0 unless defined $foo;
     * to not give a warning. (Yes, this is a hack) */

    nameav = (AV*)AvARRAY(CvPADLIST(PL_compcv))[0];
    name_svp = AvARRAY(nameav);
    for (offset = AvFILLp(nameav); offset > 0; offset--) {
        const SV * const namesv = name_svp[offset];
	if (namesv && namesv != &PL_sv_undef
	    && !SvFAKE(namesv)
	    && (SvPAD_OUR(namesv))
	    && strEQ(SvPVX_const(namesv), name)
	    && COP_SEQ_RANGE_LOW(namesv) == PAD_MAX /* min */
	)
	    return offset;
d616 11
a626 1
    return NOT_IN_PAD;
a628 4
/*
 * Returns the offset of a lexical $_, if there is one, at run time.
 * Used by the UNDERBAR XS macro.
 */
a629 9
PADOFFSET
Perl_find_rundefsvoffset(pTHX)
{
    dVAR;
    SV *out_sv;
    int out_flags;
    return pad_findlex("$_", find_runcv(NULL), PL_curcop->cop_seq, 1,
	    NULL, &out_sv, &out_flags);
}
d635 4
a638 15
in the inner pads if it's found in an outer one.

Returns the offset in the bottom pad of the lex or the fake lex.
cv is the CV in which to start the search, and seq is the current cop_seq
to match against. If warn is true, print appropriate warnings.  The out_*
vars return values, and so are pointers to where the returned values
should be stored. out_capture, if non-null, requests that the innermost
instance of the lexical is captured; out_name_sv is set to the innermost
matched namesv or fake namesv; out_flags returns the flags normally
associated with the IVX field of a fake namesv.

Note that pad_findlex() is recursive; it recurses up the chain of CVs,
then comes back down, adding fake entries as it goes. It has to be this way
because fake namesvs in anon protoypes have to store in xlow the index into
the parent pad.
a642 8
/* the CV has finished being compiled. This is not a sufficient test for
 * all CVs (eg XSUBs), but suffices for the CVs found in a lexical chain */
#define CvCOMPILED(cv)	CvROOT(cv)

/* the CV does late binding of its lexicals */
#define CvLATE(cv) (CvANON(cv) || SvTYPE(cv) == SVt_PVFM)


d644 1
a644 2
S_pad_findlex(pTHX_ const char *name, const CV* cv, U32 seq, int warn,
	SV** out_capture, SV** out_name_sv, int *out_flags)
d646 9
a654 7
    dVAR;
    I32 offset, new_offset;
    SV *new_capture;
    SV **new_capturep;
    const AV * const padlist = CvPADLIST(cv);

    *out_flags = 0;
d656 1
d658 3
a660 2
	"Pad findlex cv=0x%"UVxf" searching \"%s\" seq=%d%s\n",
	PTR2UV(cv), name, (int)seq, out_capture ? " capturing" : "" ));
d662 2
a663 1
    /* first, search this pad */
d665 4
a668 4
    if (padlist) { /* not an undef CV */
	I32 fake_offset = 0;
        const AV * const nameav = (AV*)AvARRAY(padlist)[0];
	SV * const * const name_svp = AvARRAY(nameav);
d670 30
a699 10
	for (offset = AvFILLp(nameav); offset > 0; offset--) {
            const SV * const namesv = name_svp[offset];
	    if (namesv && namesv != &PL_sv_undef
		    && strEQ(SvPVX_const(namesv), name))
	    {
		if (SvFAKE(namesv))
		    fake_offset = offset; /* in case we don't find a real one */
		else if (  seq >  COP_SEQ_RANGE_LOW(namesv)	/* min */
			&& seq <= COP_SEQ_RANGE_HIGH(namesv))	/* max */
		    break;
d703 10
a712 33
	if (offset > 0 || fake_offset > 0 ) { /* a match! */
	    if (offset > 0) { /* not fake */
		fake_offset = 0;
		*out_name_sv = name_svp[offset]; /* return the namesv */

		/* set PAD_FAKELEX_MULTI if this lex can have multiple
		 * instances. For now, we just test !CvUNIQUE(cv), but
		 * ideally, we should detect my's declared within loops
		 * etc - this would allow a wider range of 'not stayed
		 * shared' warnings. We also treated alreadly-compiled
		 * lexes as not multi as viewed from evals. */

		*out_flags = CvANON(cv) ?
			PAD_FAKELEX_ANON :
			    (!CvUNIQUE(cv) && ! CvCOMPILED(cv))
				? PAD_FAKELEX_MULTI : 0;

		DEBUG_Xv(PerlIO_printf(Perl_debug_log,
		    "Pad findlex cv=0x%"UVxf" matched: offset=%ld (%lu,%lu)\n",
		    PTR2UV(cv), (long)offset,
		    (unsigned long)COP_SEQ_RANGE_LOW(*out_name_sv),
		    (unsigned long)COP_SEQ_RANGE_HIGH(*out_name_sv)));
	    }
	    else { /* fake match */
		offset = fake_offset;
		*out_name_sv = name_svp[offset]; /* return the namesv */
		*out_flags = PARENT_FAKELEX_FLAGS(*out_name_sv);
		DEBUG_Xv(PerlIO_printf(Perl_debug_log,
		    "Pad findlex cv=0x%"UVxf" matched: offset=%ld flags=0x%lx index=%lu\n",
		    PTR2UV(cv), (long)offset, (unsigned long)*out_flags,
		    (unsigned long) PARENT_PAD_INDEX(*out_name_sv) 
		));
	    }
d714 1
a714 1
	    /* return the lex? */
d716 2
a717 1
	    if (out_capture) {
d719 2
a720 5
		/* our ? */
		if (SvPAD_OUR(*out_name_sv)) {
		    *out_capture = NULL;
		    return offset;
		}
d722 20
a741 10
		/* trying to capture from an anon prototype? */
		if (CvCOMPILED(cv)
			? CvANON(cv) && CvCLONE(cv) && !CvCLONED(cv)
			: *out_flags & PAD_FAKELEX_ANON)
		{
		    if (warn && ckWARN(WARN_CLOSURE))
			Perl_warner(aTHX_ packWARN(WARN_CLOSURE),
			    "Variable \"%s\" is not available", name);
		    *out_capture = NULL;
		}
d743 7
a749 9
		/* real value */
		else {
		    int newwarn = warn;
		    if (!CvCOMPILED(cv) && (*out_flags & PAD_FAKELEX_MULTI)
			 && warn && ckWARN(WARN_CLOSURE)) {
			newwarn = 0;
			Perl_warner(aTHX_ packWARN(WARN_CLOSURE),
			    "Variable \"%s\" will not stay shared", name);
		    }
d751 36
a786 14
		    if (fake_offset && CvANON(cv)
			    && CvCLONE(cv) &&!CvCLONED(cv))
		    {
			SV *n;
			/* not yet caught - look further up */
			DEBUG_Xv(PerlIO_printf(Perl_debug_log,
			    "Pad findlex cv=0x%"UVxf" chasing lex in outer pad\n",
			    PTR2UV(cv)));
			n = *out_name_sv;
			(void) pad_findlex(name, CvOUTSIDE(cv),
			    CvOUTSIDE_SEQ(cv),
			    newwarn, out_capture, out_name_sv, out_flags);
			*out_name_sv = n;
			return offset;
d788 4
a791 9

		    *out_capture = AvARRAY((AV*)AvARRAY(padlist)[
				    CvDEPTH(cv) ? CvDEPTH(cv) : 1])[offset];
		    DEBUG_Xv(PerlIO_printf(Perl_debug_log,
			"Pad findlex cv=0x%"UVxf" found lex=0x%"UVxf"\n",
			PTR2UV(cv), PTR2UV(*out_capture)));

		    if (SvPADSTALE(*out_capture)) {
			if (ckWARN(WARN_CLOSURE))
d793 4
a796 2
				"Variable \"%s\" is not available", name);
			*out_capture = NULL;
a798 8
		if (!*out_capture) {
		    if (*name == '@@')
			*out_capture = sv_2mortal((SV*)newAV());
		    else if (*name == '%')
			*out_capture = sv_2mortal((SV*)newHV());
		    else
			*out_capture = sv_newmortal();
		}
a799 2

	    return offset;
d801 7
a807 59
    }

    /* it's not in this pad - try above */

    if (!CvOUTSIDE(cv))
	return NOT_IN_PAD;

    /* out_capture non-null means caller wants us to capture lex; in
     * addition we capture ourselves unless it's an ANON/format */
    new_capturep = out_capture ? out_capture :
		CvLATE(cv) ? NULL : &new_capture;

    offset = pad_findlex(name, CvOUTSIDE(cv), CvOUTSIDE_SEQ(cv), 1,
		new_capturep, out_name_sv, out_flags);
    if ((PADOFFSET)offset == NOT_IN_PAD)
	return NOT_IN_PAD;

    /* found in an outer CV. Add appropriate fake entry to this pad */

    /* don't add new fake entries (via eval) to CVs that we have already
     * finished compiling, or to undef CVs */
    if (CvCOMPILED(cv) || !padlist)
	return 0; /* this dummy (and invalid) value isnt used by the caller */

    {
	SV *new_namesv;
	AV *  const ocomppad_name = PL_comppad_name;
	PAD * const ocomppad = PL_comppad;
	PL_comppad_name = (AV*)AvARRAY(padlist)[0];
	PL_comppad = (AV*)AvARRAY(padlist)[1];
	PL_curpad = AvARRAY(PL_comppad);

	new_offset = pad_add_name(
	    SvPVX_const(*out_name_sv),
	    SvPAD_TYPED(*out_name_sv)
		    ? SvSTASH(*out_name_sv) : NULL,
	    SvOURSTASH(*out_name_sv),
	    1,  /* fake */
	    0   /* not a state variable */
	);

	new_namesv = AvARRAY(PL_comppad_name)[new_offset];
	PARENT_FAKELEX_FLAGS_set(new_namesv, *out_flags);

	PARENT_PAD_INDEX_set(new_namesv, 0);
	if (SvPAD_OUR(new_namesv)) {
	    NOOP;   /* do nothing */
	}
	else if (CvLATE(cv)) {
	    /* delayed creation - just note the offset within parent pad */
	    PARENT_PAD_INDEX_set(new_namesv, offset);
	    CvCLONE_on(cv);
	}
	else {
	    /* immediate creation - capture outer value right now */
	    av_store(PL_comppad, new_offset, SvREFCNT_inc(*new_capturep));
	    DEBUG_Xv(PerlIO_printf(Perl_debug_log,
		"Pad findlex cv=0x%"UVxf" saved captured sv 0x%"UVxf" at offset %ld\n",
		PTR2UV(cv), PTR2UV(*new_capturep), (long)new_offset));
a808 6
	*out_name_sv = new_namesv;
	*out_flags = PARENT_FAKELEX_FLAGS(new_namesv);

	PL_comppad_name = ocomppad_name;
	PL_comppad = ocomppad;
	PL_curpad = ocomppad ? AvARRAY(ocomppad) : NULL;
d810 8
a817 1
    return new_offset;
a820 1
#ifdef DEBUGGING
a833 1
    dVAR;
d836 1
d839 1
d857 1
a860 1
    dVAR;
a889 1
    dVAR;
a917 1
    dVAR;
d929 3
a931 3
	if (sv && sv != &PL_sv_undef && !SvFAKE(sv) && !COP_SEQ_RANGE_HIGH(sv)) {
	    COP_SEQ_RANGE_HIGH_set(sv, PAD_MAX);	/* Don't know scope end yet. */
	    COP_SEQ_RANGE_LOW_set(sv, PL_cop_seqmax);
d935 1
a935 2
		(unsigned long)COP_SEQ_RANGE_LOW(sv),
		(unsigned long)COP_SEQ_RANGE_HIGH(sv))
a958 1
    dVAR;
d971 1
a971 2
			    "%"SVf" never introduced",
			    SVfARG(sv));
d977 2
a978 2
	if (sv && sv != &PL_sv_undef && !SvFAKE(sv) && COP_SEQ_RANGE_HIGH(sv) == PAD_MAX) {
	    COP_SEQ_RANGE_HIGH_set(sv, PL_cop_seqmax);
d982 1
a982 2
		(unsigned long)COP_SEQ_RANGE_LOW(sv),
		(unsigned long)COP_SEQ_RANGE_HIGH(sv))
a1003 1
    dVAR;
d1025 1
a1025 1
    PL_curpad[po] = newSV(0);
a1051 1
    dVAR;
a1094 1
    dVAR;
a1096 23

    /* If this CV has had any 'eval-capable' ops planted in it
     * (ie it contains eval '...', //ee, /$var/ or /(?{..})/), Then any
     * anon prototypes in the chain of CVs should be marked as cloneable,
     * so that for example the eval's CV in C<< sub { eval '$x' } >> gets
     * the right CvOUTSIDE.
     * If running with -d, *any* sub may potentially have an eval
     * excuted within it.
     */

    if (PL_cv_has_eval || PL_perldb) {
        const CV *cv;
	for (cv = PL_compcv ;cv; cv = CvOUTSIDE(cv)) {
	    if (cv != PL_compcv && CvCOMPILED(cv))
		break; /* no need to mark already-compiled code */
	    if (CvANON(cv)) {
		DEBUG_Xv(PerlIO_printf(Perl_debug_log,
		    "Pad clone on cv=0x%"UVxf"\n", PTR2UV(cv)));
		CvCLONE_on(cv);
	    }
	}
    }

d1099 1
a1099 1
	av_store(PL_comppad_name, AvFILLp(PL_comppad), NULL);
a1103 1

d1111 1
a1111 1
	     * pad are anonymous subs.
d1114 1
a1114 1
	    if (!((namesv = namep[ix]) != NULL &&
d1116 2
a1117 1
		   *SvPVX_const(namesv) == '&'))
d1120 1
a1120 1
		PL_curpad[ix] = NULL;
d1129 1
a1129 1
	AvREIFY_only(av);
a1165 1
    dVAR;
d1183 1
a1183 7
	if (
#ifdef PERL_OLD_COPY_ON_WRITE
	    !SvIsCOW(PL_curpad[po])
#else
	    !SvFAKE(PL_curpad[po])
#endif
	    )
d1186 1
a1204 1
    dVAR;
d1226 1
a1226 1
	    namesv = NULL;
d1231 1
a1231 1
		    "%2d. 0x%"UVxf"<%lu> FAKE \"%s\" flags=0x%lx index=%lu\n",
d1235 1
a1235 4
		    SvPVX_const(namesv),
		    (unsigned long)PARENT_FAKELEX_FLAGS(namesv),
		    (unsigned long)PARENT_PAD_INDEX(namesv)

d1243 2
a1244 2
		    (unsigned long)COP_SEQ_RANGE_LOW(namesv),
		    (unsigned long)COP_SEQ_RANGE_HIGH(namesv),
a1272 1
    dVAR;
a1280 1
		   : (SvTYPE(cv) == SVt_PVFM) ? "FORMAT"
d1314 16
a1329 1
    dVAR;
a1338 3
    SV** outpad;
    CV* outside;
    long depth;
a1341 13
    /* Since cloneable anon subs can be nested, CvOUTSIDE may point
     * to a prototype; we instead want the cloned parent who called us.
     * Note that in general for formats, CvOUTSIDE != find_runcv */

    outside = CvOUTSIDE(proto);
    if (outside && CvCLONE(outside) && ! CvCLONED(outside))
	outside = find_runcv(NULL);
    depth = CvDEPTH(outside);
    assert(depth || SvTYPE(proto) == SVt_PVFM);
    if (!depth)
	depth = 1;
    assert(CvPADLIST(outside));

d1345 2
a1346 1
    cv = PL_compcv = (CV*)newSV_type(SvTYPE(proto));
d1350 5
d1356 2
a1357 2
    CvFILE(cv)		= CvISXSUB(proto) ? CvFILE(proto)
					  : savepv(CvFILE(proto));
d1367 4
a1370 2
    CvOUTSIDE(cv)	= (CV*)SvREFCNT_inc_simple(outside);
    CvOUTSIDE_SEQ(cv) = CvOUTSIDE_SEQ(proto);
a1376 1
    av_fill(PL_comppad, fpad);
d1380 1
a1382 2
    outpad = AvARRAY(AvARRAY(CvPADLIST(outside))[depth]);

d1384 9
a1392 17
	SV* const namesv = (ix <= fname) ? pname[ix] : NULL;
	SV *sv = NULL;
	if (namesv && namesv != &PL_sv_undef) { /* lexical */
	    if (SvFAKE(namesv)) {   /* lexical from outside? */
		sv = outpad[PARENT_PAD_INDEX(namesv)];
		assert(sv);
		/* formats may have an inactive parent */
		if (SvTYPE(proto) == SVt_PVFM && SvPADSTALE(sv)) {
		    if (ckWARN(WARN_CLOSURE))
			Perl_warner(aTHX_ packWARN(WARN_CLOSURE),
			    "Variable \"%s\" is not available", SvPVX_const(namesv));
		    sv = NULL;
		}
		/* 'my $x if $y' can leave $x stale even in an active sub */
		else if (!SvPADSTALE(sv)) {
		    SvREFCNT_inc_simple_void_NN(sv);
		}
d1394 4
a1397 3
	    if (!sv) {
                const char sigil = SvPVX_const(namesv)[0];
                if (sigil == '&')
d1399 2
a1400 1
                else if (sigil == '@@')
d1402 1
a1402 1
                else if (sigil == '%')
d1405 4
a1408 5
		    sv = newSV(0);
		SvPADMY_on(sv);
		/* reset the 'assign only once' flag on each state var */
		if (SvPAD_STATE(namesv))
		    SvPADSTALE_on(sv);
d1412 1
a1412 1
	    sv = SvREFCNT_inc_NN(ppad[ix]);
d1415 1
a1415 1
	    sv = newSV(0);
d1417 22
a1439 1
	PL_curpad[ix] = sv;
a1451 5
	/* Constant sub () { $x } closing over $x - see lib/constant.pm:
	 * The prototype was marked as a candiate for const-ization,
	 * so try to grab the current const value, and if successful,
	 * turn into a const sub:
	 */
d1453 4
a1456 7
	if (const_sv) {
	    SvREFCNT_dec(cv);
	    cv = newCONSTSUB(CvSTASH(proto), NULL, const_sv);
	}
	else {
	    CvCONST_off(cv);
	}
a1475 1
    dVAR;
a1480 2
    PERL_UNUSED_ARG(old_cv);

d1499 2
a1500 2
this depth, in which case don't bother creating a new one.  Then give
the new pad an @@_ in slot zero.
d1505 3
d1509 1
a1509 1
Perl_pad_push(pTHX_ PADLIST *padlist, int depth)
d1511 4
a1514 2
    dVAR;
    if (depth > AvFILLp(padlist)) {
d1519 1
a1519 1
        const I32 names_fill = AvFILLp((AV*)svp[0]);
d1521 1
a1521 2
	AV *av;

d1524 2
a1525 5
		const char sigil = SvPVX_const(names[ix])[0];
		if ((SvFLAGS(names[ix]) & SVf_FAKE)
			|| (SvFLAGS(names[ix]) & SVpad_STATE)
			|| sigil == '&')
		{
d1530 4
a1533 5
		    SV *sv; 
		    if (sigil == '@@')
			sv = (SV*)newAV();
		    else if (sigil == '%')
			sv = (SV*)newHV();
d1535 1
a1535 2
			sv = newSV(0);
		    av_store(newpad, ix, sv);
d1540 1
a1540 1
		av_store(newpad, ix, SvREFCNT_inc_NN(oldpad[ix]));
d1544 1
a1544 2
		SV * const sv = newSV(0);
		av_store(newpad, ix, sv);
d1548 6
a1553 5
	av = newAV();
	av_extend(av, 0);
	av_store(newpad, 0, (SV*)av);
	AvREIFY_only(av);

a1562 1
    dVAR;
d1564 1
a1564 1
    if ( SvPAD_TYPED(*av) ) {
d1567 1
a1567 1
    return NULL;
@


1.1.1.6
log
@import perl 5.10.1
@
text
@d3 1
a3 2
 *    Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008
 *    by Larry Wall and others
a6 9
 */

/*
 *  'Anyway: there was this Mr. Frodo left an orphan and stranded, as you
 *   might say, among those queer Bucklanders, being brought up anyhow in
 *   Brandy Hall.  A regular warren, by all accounts.  Old Master Gorbadoc
 *   never had fewer than a couple of hundred relations in the place.
 *   Mr. Bilbo never did a kinder deed than when he brought the lad back
 *   to live among decent folk.'                           --the Gaffer
d8 6
a13 1
 *     [p.23 of _The Lord of the Rings_, I/i: "A Long-Expected Party"]
a104 2
For state vars, SVf_PADSTALE is overloaded to mean 'not yet initialised'

a128 3

    PERL_ARGS_ASSERT_PAD_PEG;

d194 1
a194 1
	av_store(pad, 0, MUTABLE_SV(a0));
d202 2
a203 2
    av_store(padlist, 0, MUTABLE_SV(padname));
    av_store(padlist, 1, MUTABLE_SV(pad));
d207 2
a208 2
    PL_comppad_name	= MUTABLE_AV((*av_fetch(padlist, 0, FALSE)));
    PL_comppad		= MUTABLE_AV((*av_fetch(padlist, 1, FALSE)));
a250 2
    PERL_ARGS_ASSERT_PAD_UNDEF;

d271 1
a271 1
	AV *  const comppad_name = MUTABLE_AV(AvARRAY(padlist)[0]);
d273 1
a273 1
	AV *  const comppad = MUTABLE_AV(AvARRAY(padlist)[1]);
d280 1
a280 1
		CV * const innercv = MUTABLE_CV(curpad[ix]);
d312 1
a312 1
	SV* const sv = AvARRAY(padlist)[ix--];
d314 1
a314 1
	    if (sv == (const SV *)PL_comppad_name)
d316 1
a316 1
	    else if (sv == (const SV *)PL_comppad) {
d323 1
a323 1
    SvREFCNT_dec(MUTABLE_SV(CvPADLIST(cv)));
a352 2
    PERL_ARGS_ASSERT_PAD_ADD_NAME;

d360 1
a360 1
	SvSTASH_set(namesv, MUTABLE_HV(SvREFCNT_inc_simple_NN(MUTABLE_SV(typestash))));
d389 1
a389 1
	    av_store(PL_comppad, offset, MUTABLE_SV(newAV()));
d391 1
a391 1
	    av_store(PL_comppad, offset, MUTABLE_SV(newHV()));
a487 3

    PERL_ARGS_ASSERT_PAD_ADD_ANON;

d489 1
a489 1
    sv_setpvs(name, "&");
d501 4
a504 4
    if (CvOUTSIDE((const CV *)sv)) {
	assert(!CvWEAKOUTSIDE((const CV *)sv));
	CvWEAKOUTSIDE_on(MUTABLE_CV(sv));
	SvREFCNT_dec(CvOUTSIDE(MUTABLE_CV(sv)));
a531 2
    PERL_ARGS_ASSERT_PAD_CHECK_DUP;

a604 2
    PERL_ARGS_ASSERT_PAD_FINDMY;

d615 1
a615 1
    nameav = MUTABLE_AV(AvARRAY(CvPADLIST(PL_compcv))[0]);
a685 2
    PERL_ARGS_ASSERT_PAD_FINDLEX;

d696 1
a696 1
        const AV * const nameav = MUTABLE_AV(AvARRAY(padlist)[0]);
a770 1
			 && !SvPAD_STATE(name_svp[offset])
d793 2
a794 2
		    *out_capture = AvARRAY(MUTABLE_AV(AvARRAY(padlist)[
				    CvDEPTH(cv) ? CvDEPTH(cv) : 1]))[offset];
d799 1
a799 3
		    if (SvPADSTALE(*out_capture)
			&& !SvPAD_STATE(name_svp[offset]))
		    {
d808 1
a808 1
			*out_capture = sv_2mortal(MUTABLE_SV(newAV()));
d810 1
a810 1
			*out_capture = sv_2mortal(MUTABLE_SV(newHV()));
d846 2
a847 2
	PL_comppad_name = MUTABLE_AV(AvARRAY(padlist)[0]);
	PL_comppad = MUTABLE_AV(AvARRAY(padlist)[1]);
d856 1
a856 1
	    SvPAD_STATE(*out_name_sv) ? 1 : 0 /* state variable ? */
a928 3

    PERL_ARGS_ASSERT_PAD_SETSV;

d1228 1
a1228 1
	av_store(PL_comppad, 0, MUTABLE_SV(av));
d1284 7
a1290 1
	if (!SvIsCOW(PL_curpad[po]))
a1317 2
    PERL_ARGS_ASSERT_DO_DUMP_PAD;

d1321 2
a1322 2
    pad_name = MUTABLE_AV(*av_fetch(MUTABLE_AV(padlist), 0, FALSE));
    pad = MUTABLE_AV(*av_fetch(MUTABLE_AV(padlist), 1, FALSE));
a1386 2
    PERL_ARGS_ASSERT_CV_DUMP;

d1429 2
a1430 2
    const AV *const protopad_name = (const AV *)*av_fetch(protopadlist, 0, FALSE);
    const AV *const protopad = (const AV *)*av_fetch(protopadlist, 1, FALSE);
a1439 2
    PERL_ARGS_ASSERT_CV_CLONE;

d1458 1
a1458 1
    cv = PL_compcv = MUTABLE_CV(newSV_type(SvTYPE(proto)));
d1474 1
a1474 1
    CvOUTSIDE(cv)	= MUTABLE_CV(SvREFCNT_inc_simple(outside));
d1478 1
a1478 1
	sv_setpvn(MUTABLE_SV(cv), SvPVX_const(proto), SvCUR(proto));
d1497 2
a1498 4
		/* formats may have an inactive parent,
		   while my $x if $false can leave an active var marked as
		   stale. And state vars are always available */
		if (SvPADSTALE(sv) && !SvPAD_STATE(namesv)) {
d1504 2
a1505 1
		else 
d1507 1
d1514 1
a1514 1
		    sv = MUTABLE_SV(newAV());
d1516 1
a1516 1
		    sv = MUTABLE_SV(newHV());
d1579 2
a1580 2
    AV * const comppad_name = MUTABLE_AV(AvARRAY(padlist)[0]);
    AV * const comppad = MUTABLE_AV(AvARRAY(padlist)[1]);
a1582 2

    PERL_ARGS_ASSERT_PAD_FIXUP_INNER_ANONS;
d1590 1
a1590 1
	    CV * const innercv = MUTABLE_CV(curpad[ix]);
a1612 3

    PERL_ARGS_ASSERT_PAD_PUSH;

d1617 2
a1618 2
	I32 ix = AvFILLp((const AV *)svp[1]);
        const I32 names_fill = AvFILLp((const AV *)svp[0]);
d1635 1
a1635 1
			sv = MUTABLE_SV(newAV());
d1637 1
a1637 1
			sv = MUTABLE_SV(newHV());
d1656 1
a1656 1
	av_store(newpad, 0, MUTABLE_SV(av));
d1659 1
a1659 1
	av_store(padlist, depth, MUTABLE_SV(newpad));
@


1.1.1.7
log
@Perl 5.12.2 from CPAN
@
text
@d104 1
a104 1
The flag SVs_PADSTALE is cleared on lexicals each time the my() is executed,
d110 1
a110 1
For state vars, SVs_PADSTALE is overloaded to mean 'not yet initialised'
d183 1
a183 1
		SAVEBOOL(PL_pad_reset_pending);
a341 29
static PADOFFSET
S_pad_add_name_sv(pTHX_ SV *namesv, const U32 flags, HV *typestash,
		  HV *ourstash)
{
    dVAR;
    const PADOFFSET offset = pad_alloc(OP_PADSV, SVs_PADMY);

    PERL_ARGS_ASSERT_PAD_ADD_NAME_SV;

    ASSERT_CURPAD_ACTIVE("pad_add_name");

    if (typestash) {
	assert(SvTYPE(namesv) == SVt_PVMG);
	SvPAD_TYPED_on(namesv);
	SvSTASH_set(namesv, MUTABLE_HV(SvREFCNT_inc_simple_NN(MUTABLE_SV(typestash))));
    }
    if (ourstash) {
	SvPAD_OUR_on(namesv);
	SvOURSTASH_set(namesv, ourstash);
	SvREFCNT_inc_simple_void_NN(ourstash);
    }
    else if (flags & padadd_STATE) {
	SvPAD_STATE_on(namesv);
    }

    av_store(PL_comppad_name, offset, namesv);
    return offset;
}

d358 1
a358 2
Perl_pad_add_name(pTHX_ const char *name, const STRLEN len, const U32 flags,
		  HV *typestash, HV *ourstash)
d361 3
a363 2
    PADOFFSET offset;
    SV *namesv;
d367 1
a367 10
    if (flags & ~(padadd_OUR|padadd_STATE|padadd_NO_DUP_CHECK))
	Perl_croak(aTHX_ "panic: pad_add_name illegal flag bits 0x%" UVxf,
		   (UV)flags);

    namesv = newSV_type((ourstash || typestash) ? SVt_PVMG : SVt_PVNV);

    /* Until we're using the length for real, cross check that we're being told
       the truth.  */
    PERL_UNUSED_ARG(len);
    assert(strlen(name) == len);
d371 40
a410 25
    if ((flags & padadd_NO_DUP_CHECK) == 0) {
	/* check for duplicate declaration */
	pad_check_dup(namesv, flags & padadd_OUR, ourstash);
    }

    offset = pad_add_name_sv(namesv, flags, typestash, ourstash);

    /* not yet introduced */
    COP_SEQ_RANGE_LOW_set(namesv, PAD_MAX);	/* min */
    COP_SEQ_RANGE_HIGH_set(namesv, 0);		/* max */

    if (!PL_min_intro_pending)
	PL_min_intro_pending = offset;
    PL_max_intro_pending = offset;
    /* if it's not a simple scalar, replace with an AV or HV */
    /* XXX DAPM since slot has been allocated, replace
     * av_store with PL_curpad[offset] ? */
    if (*name == '@@')
	av_store(PL_comppad, offset, MUTABLE_SV(newAV()));
    else if (*name == '%')
	av_store(PL_comppad, offset, MUTABLE_SV(newHV()));
    SvPADMY_on(PL_curpad[offset]);
    DEBUG_Xv(PerlIO_printf(Perl_debug_log,
			   "Pad addname: %ld \"%s\" new lex=0x%"UVxf"\n",
			   (long)offset, name, PTR2UV(PL_curpad[offset])));
d540 4
a543 2
STATIC void
S_pad_check_dup(pTHX_ SV *name, const U32 flags, const HV *ourstash)
a547 1
    const U32	is_our = flags & padadd_OUR;
a551 3

    assert((flags & ~padadd_OUR) == 0);

d566 1
a566 1
	    && sv_eq(name, sv))
d571 1
a571 1
		"\"%s\" variable %"SVf" masks earlier declaration in same %s",
d573 1
a573 1
		sv,
d588 1
a588 1
		&& sv_eq(name, sv))
d591 1
a591 1
		    "\"our\" variable %"SVf" redeclared", sv);
d615 1
a615 1
Perl_pad_findmy(pTHX_ const char *name, STRLEN len, U32 flags)
a626 16

    if (flags)
	Perl_croak(aTHX_ "panic: pad_findmy illegal flag bits 0x%" UVxf,
		   (UV)flags);

    /* Yes, it is a bug (read work in progress) that we're not really using this
       length parameter, and instead relying on strlen() later on. But I'm not
       comfortable about changing the pad API piecemeal to use and rely on
       lengths. This only exists to avoid an "unused parameter" warning.  */
    if (len < 2) 
	return NOT_IN_PAD;

    /* But until we're using the length for real, cross check that we're being
       told the truth.  */
    assert(strlen(name) == len);

d784 3
a786 3
		    if (warn)
			Perl_ck_warner(aTHX_ packWARN(WARN_CLOSURE),
				       "Variable \"%s\" is not available", name);
d826 3
a828 2
			Perl_ck_warner(aTHX_ packWARN(WARN_CLOSURE),
				       "Variable \"%s\" is not available", name);
d869 1
a869 5
	/* This relies on sv_setsv_flags() upgrading the destination to the same
	   type as the source, independant of the flags set, and on it being
	   "good" and only copying flag bits and pointers that it understands.
	*/
	SV *new_namesv = newSVsv(*out_name_sv);
d876 8
a883 7
	new_offset
	    = pad_add_name_sv(new_namesv,
			      (SvPAD_STATE(*out_name_sv) ? padadd_STATE : 0),
			      SvPAD_TYPED(*out_name_sv)
			      ? SvSTASH(*out_name_sv) : NULL,
			      SvOURSTASH(*out_name_sv)
			      );
d885 1
a885 5
	SvFAKE_on(new_namesv);
	DEBUG_Xv(PerlIO_printf(Perl_debug_log,
			       "Pad addname: %ld \"%.*s\" FAKE\n",
			       (long)new_offset,
			       (int) SvCUR(new_namesv), SvPVX(new_namesv)));
d1069 5
a1073 4
	    if (sv && sv != &PL_sv_undef && !SvFAKE(sv))
		Perl_ck_warner_d(aTHX_ packWARN(WARN_INTERNAL),
				 "%"SVf" never introduced",
				 SVfARG(sv));
d1153 2
a1154 2
static void
S_pad_reset(pTHX)
d1530 3
a1532 2
		    Perl_ck_warner(aTHX_ packWARN(WARN_CLOSURE),
				   "Variable \"%s\" is not available", SvPVX_const(namesv));
@


1.1.1.8
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d30 4
a33 1
=for apidoc Amx|PADLIST *|CvPADLIST|CV *cv
d35 2
a36 3
CV's can have CvPADLIST(cv) set to point to an AV.  This is the CV's
scratchpad, which stores lexical variables and opcode temporary and
per-thread values.
d47 2
a48 3
The CvPADLIST AV has the REFCNT of its component items managed "manually"
(mostly in pad.c) rather than by normal av.c rules.  So we turn off AvREAL
just before freeing it, to let av.c know not to touch the entries.
d59 8
d81 1
a81 11
which the name is valid (accessed through the macros COP_SEQ_RANGE_LOW and
_HIGH).  During compilation, these fields may hold the special value
PERL_PADSEQ_INTRO to indicate various stages:

   COP_SEQ_RANGE_LOW        _HIGH
   -----------------        -----
   PERL_PADSEQ_INTRO            0   variable not yet introduced:   { my ($x
   valid-seq#   PERL_PADSEQ_INTRO   variable in scope:             { my ($x)
   valid-seq#          valid-seq#   compilation of scope complete: { my ($x) }

For typed lexicals name SV is SVt_PVMG and SvSTASH
a111 18
=for apidoc AmxU|AV *|PL_comppad_name

During compilation, this points to the array containing the names part
of the pad for the currently-compiling code.

=for apidoc AmxU|AV *|PL_comppad

During compilation, this points to the array containing the values
part of the pad for the currently-compiling code.  (At runtime a CV may
have many such value arrays; at compile time just one is constructed.)
At runtime, this points to the array containing the currently-relevant
values for the pad for the currently-executing code.

=for apidoc AmxU|SV **|PL_curpad

Points directly to the body of the L</PL_comppad> array.
(I.e., this is C<AvARRAY(PL_comppad)>.)

d131 1
a131 10
/*
=for apidoc mx|void|pad_peg|const char *s

When PERL_MAD is enabled, this is a small no-op function that gets called
at the start of each pad-related function.  It can be breakpointed to
track all pad operations.  The parameter is a string indicating the type
of pad operation being performed.

=cut
*/
d135 1
a135 2
    static int pegcnt; /* XXX not threadsafe */
    PERL_UNUSED_ARG(s);
d144 1
a144 3
This is basically sv_eq_flags() in sv.c, but we avoid the magic
and bytes checking.
*/
d146 3
a148 42
static bool
sv_eq_pvn_flags(pTHX_ const SV *sv, const char* pv, const STRLEN pvlen, const U32 flags) {
    if ( (SvUTF8(sv) & SVf_UTF8 ) != (flags & SVf_UTF8) ) {
        const char *pv1 = SvPVX_const(sv);
        STRLEN cur1     = SvCUR(sv);
        const char *pv2 = pv;
        STRLEN cur2     = pvlen;
	if (PL_encoding) {
              SV* svrecode = NULL;
	      if (SvUTF8(sv)) {
		   svrecode = newSVpvn(pv2, cur2);
		   sv_recode_to_utf8(svrecode, PL_encoding);
		   pv2      = SvPV_const(svrecode, cur2);
	      }
	      else {
		   svrecode = newSVpvn(pv1, cur1);
		   sv_recode_to_utf8(svrecode, PL_encoding);
		   pv1      = SvPV_const(svrecode, cur1);
	      }
              SvREFCNT_dec(svrecode);
        }
        if (flags & SVf_UTF8)
            return (bytes_cmp_utf8(
                        (const U8*)pv1, cur1,
		        (const U8*)pv2, cur2) == 0);
        else
            return (bytes_cmp_utf8(
                        (const U8*)pv2, cur2,
		        (const U8*)pv1, cur1) == 0);
    }
    else
        return ((SvPVX_const(sv) == pv)
                    || memEQ(SvPVX_const(sv), pv, pvlen));
}


/*
=for apidoc Am|PADLIST *|pad_new|int flags

Create a new padlist, updating the global variables for the
currently-compiling padlist to point to the new padlist.  The following
flags can be OR'ed together:
d151 1
a151 1
    padnew_SAVE		save old globals on the save stack
a161 1
    SV **ary;
d203 1
d211 3
a213 11
    /* Most subroutines never recurse, hence only need 2 entries in the padlist
       array - names, and depth=1.  The default for av_store() is to allocate
       0..3, and even an explicit call to av_extend() with <3 will be rounded
       up, so we inline the allocation of the array here.  */
    Newx(ary, 2, SV*);
    AvFILLp(padlist) = 1;
    AvMAX(padlist) = 1;
    AvALLOC(padlist) = ary;
    AvARRAY(padlist) = ary;
    ary[0] = MUTABLE_SV(padname);
    ary[1] = MUTABLE_SV(pad);
d217 3
a219 3
    PL_comppad_name	= padname;
    PL_comppad		= pad;
    PL_curpad		= AvARRAY(pad);
a238 1

d240 1
a240 1
=head1 Embedding Functions
d242 5
a246 1
=for apidoc cv_undef
d248 2
a249 4
Clear out all the active components of a CV. This can happen either
by an explicit C<undef &foo>, or by the reference count going to zero.
In the former case, we keep the CvOUTSIDE pointer, so that any anonymous
children can still follow the full lexical scope chain.
d255 1
a255 1
Perl_cv_undef(pTHX_ CV *cv)
d258 4
a261 1
    const PADLIST *padlist = CvPADLIST(cv);
d263 5
a267 1
    PERL_ARGS_ASSERT_CV_UNDEF;
d270 2
a271 2
	  "CV undef: cv=0x%"UVxf" comppad=0x%"UVxf"\n",
	    PTR2UV(cv), PTR2UV(PL_comppad))
d274 29
a302 4
    if (CvFILE(cv) && CvDYNFILE(cv)) {
	Safefree(CvFILE(cv));
    }
    CvFILE(cv) = NULL;
d304 12
a315 78
    if (!CvISXSUB(cv) && CvROOT(cv)) {
	if (SvTYPE(cv) == SVt_PVCV && CvDEPTH(cv))
	    Perl_croak(aTHX_ "Can't undef active subroutine");
	ENTER;

	PAD_SAVE_SETNULLPAD();

	op_free(CvROOT(cv));
	CvROOT(cv) = NULL;
	CvSTART(cv) = NULL;
	LEAVE;
    }
    SvPOK_off(MUTABLE_SV(cv));		/* forget prototype */
    CvGV_set(cv, NULL);

    /* This statement and the subsequence if block was pad_undef().  */
    pad_peg("pad_undef");

    if (padlist && !SvIS_FREED(padlist) /* may be during global destruction */
	) {
	I32 ix;

	/* Free the padlist associated with a CV.
	   If parts of it happen to be current, we null the relevant PL_*pad*
	   global vars so that we don't have any dangling references left.
	   We also repoint the CvOUTSIDE of any about-to-be-orphaned inner
	   subs to the outer of this cv.  */

	DEBUG_X(PerlIO_printf(Perl_debug_log,
			      "Pad undef: cv=0x%"UVxf" padlist=0x%"UVxf" comppad=0x%"UVxf"\n",
			      PTR2UV(cv), PTR2UV(padlist), PTR2UV(PL_comppad))
		);

	/* detach any '&' anon children in the pad; if afterwards they
	 * are still live, fix up their CvOUTSIDEs to point to our outside,
	 * bypassing us. */
	/* XXX DAPM for efficiency, we should only do this if we know we have
	 * children, or integrate this loop with general cleanup */

	if (PL_phase != PERL_PHASE_DESTRUCT) { /* don't bother during global destruction */
	    CV * const outercv = CvOUTSIDE(cv);
	    const U32 seq = CvOUTSIDE_SEQ(cv);
	    AV *  const comppad_name = MUTABLE_AV(AvARRAY(padlist)[0]);
	    SV ** const namepad = AvARRAY(comppad_name);
	    AV *  const comppad = MUTABLE_AV(AvARRAY(padlist)[1]);
	    SV ** const curpad = AvARRAY(comppad);
	    for (ix = AvFILLp(comppad_name); ix > 0; ix--) {
		SV * const namesv = namepad[ix];
		if (namesv && namesv != &PL_sv_undef
		    && *SvPVX_const(namesv) == '&')
		    {
			CV * const innercv = MUTABLE_CV(curpad[ix]);
			U32 inner_rc = SvREFCNT(innercv);
			assert(inner_rc);
			assert(SvTYPE(innercv) != SVt_PVFM);
			namepad[ix] = NULL;
			SvREFCNT_dec(namesv);

			if (SvREFCNT(comppad) < 2) { /* allow for /(?{ sub{} })/  */
			    curpad[ix] = NULL;
			    SvREFCNT_dec(innercv);
			    inner_rc--;
			}

			/* in use, not just a prototype */
			if (inner_rc && (CvOUTSIDE(innercv) == cv)) {
			    assert(CvWEAKOUTSIDE(innercv));
			    /* don't relink to grandfather if he's being freed */
			    if (outercv && SvREFCNT(outercv)) {
				CvWEAKOUTSIDE_off(innercv);
				CvOUTSIDE(innercv) = outercv;
				CvOUTSIDE_SEQ(innercv) = seq;
				SvREFCNT_inc_simple_void_NN(outercv);
			    }
			    else {
				CvOUTSIDE(innercv) = NULL;
			    }
			}
d317 1
d320 1
d322 4
a325 13
	ix = AvFILLp(padlist);
	while (ix > 0) {
	    SV* const sv = AvARRAY(padlist)[ix--];
	    if (sv) {
		if (sv == (const SV *)PL_comppad) {
		    PL_comppad = NULL;
		    PL_curpad = NULL;
		}
		SvREFCNT_dec(sv);
	    }
	}
	{
	    SV *const sv = AvARRAY(padlist)[0];
d328 4
a331 1
	    SvREFCNT_dec(sv);
d333 1
a333 15
	AvREAL_off(CvPADLIST(cv));
	SvREFCNT_dec(MUTABLE_SV(CvPADLIST(cv)));
	CvPADLIST(cv) = NULL;
    }


    /* remove CvOUTSIDE unless this is an undef rather than a free */
    if (!SvREFCNT(cv) && CvOUTSIDE(cv)) {
	if (!CvWEAKOUTSIDE(cv))
	    SvREFCNT_dec(CvOUTSIDE(cv));
	CvOUTSIDE(cv) = NULL;
    }
    if (CvCONST(cv)) {
	SvREFCNT_dec(MUTABLE_SV(CvXSUBANY(cv).any_ptr));
	CvCONST_off(cv);
d335 2
a336 7
    if (CvISXSUB(cv) && CvXSUB(cv)) {
	CvXSUB(cv) = NULL;
    }
    /* delete all flags except WEAKOUTSIDE and CVGV_RC, which indicate the
     * ref status of CvOUTSIDE and CvGV, and ANON, which pp_entersub uses
     * to choose an error message */
    CvFLAGS(cv) &= (CVf_WEAKOUTSIDE|CVf_CVGV_RC|CVf_ANON);
a338 2
/*
=for apidoc m|PADOFFSET|pad_alloc_name|SV *namesv|U32 flags|HV *typestash|HV *ourstash
a339 8
Allocates a place in the currently-compiling
pad (via L<perlapi/pad_alloc>) and
then stores a name for that entry.  I<namesv> is adopted and becomes the
name entry; it must already contain the name string and be sufficiently
upgraded.  I<typestash> and I<ourstash> and the C<padadd_STATE> flag get
added to I<namesv>.  None of the other
processing of L<perlapi/pad_add_name_pvn>
is done.  Returns the offset of the allocated pad slot.
a340 2
=cut
*/
d343 2
a344 1
S_pad_alloc_name(pTHX_ SV *namesv, U32 flags, HV *typestash, HV *ourstash)
d349 1
a349 1
    PERL_ARGS_ASSERT_PAD_ALLOC_NAME;
d351 1
a351 1
    ASSERT_CURPAD_ACTIVE("pad_alloc_name");
d372 8
a379 1
=for apidoc Am|PADOFFSET|pad_add_name_pvn|const char *namepv|STRLEN namelen|U32 flags|HV *typestash|HV *ourstash
d381 1
a381 14
Allocates a place in the currently-compiling pad for a named lexical
variable.  Stores the name and other metadata in the name part of the
pad, and makes preparations to manage the variable's lexical scoping.
Returns the offset of the allocated pad slot.

I<namepv>/I<namelen> specify the variable's name, including leading sigil.
If I<typestash> is non-null, the name is for a typed lexical, and this
identifies the type.  If I<ourstash> is non-null, it's a lexical reference
to a package variable, and this identifies the package.  The following
flags can be OR'ed together:

    padadd_OUR          redundantly specifies if it's a package var
    padadd_STATE        variable will retain value persistently
    padadd_NO_DUP_CHECK skip check for lexical shadowing
d387 2
a388 2
Perl_pad_add_name_pvn(pTHX_ const char *namepv, STRLEN namelen,
		U32 flags, HV *typestash, HV *ourstash)
a392 1
    bool is_utf8;
d394 1
a394 1
    PERL_ARGS_ASSERT_PAD_ADD_NAME_PVN;
d396 2
a397 2
    if (flags & ~(padadd_OUR|padadd_STATE|padadd_NO_DUP_CHECK|padadd_UTF8_NAME))
	Perl_croak(aTHX_ "panic: pad_add_name_pvn illegal flag bits 0x%" UVxf,
a400 4
    
    if ((is_utf8 = ((flags & padadd_UTF8_NAME) != 0))) {
        namepv = (const char*)bytes_from_utf8((U8*)namepv, &namelen, &is_utf8);
    }
d402 4
a405 1
    sv_setpvn(namesv, namepv, namelen);
d407 1
a407 6
    if (is_utf8) {
        flags |= padadd_UTF8_NAME;
        SvUTF8_on(namesv);
    }
    else
        flags &= ~padadd_UTF8_NAME;
d414 1
a414 1
    offset = pad_alloc_name(namesv, flags & ~padadd_UTF8_NAME, typestash, ourstash);
d417 2
a418 2
    COP_SEQ_RANGE_LOW_set(namesv, PERL_PADSEQ_INTRO);
    COP_SEQ_RANGE_HIGH_set(namesv, 0);
d424 7
a430 7
    assert(SvTYPE(PL_curpad[offset]) == SVt_NULL);
    assert(SvREFCNT(PL_curpad[offset]) == 1);
    if (namelen != 0 && *namepv == '@@')
	sv_upgrade(PL_curpad[offset], SVt_PVAV);
    else if (namelen != 0 && *namepv == '%')
	sv_upgrade(PL_curpad[offset], SVt_PVHV);
    assert(SvPADMY(PL_curpad[offset]));
d433 1
a433 2
			   (long)offset, SvPVX(namesv),
			   PTR2UV(PL_curpad[offset])));
a437 5
/*
=for apidoc Am|PADOFFSET|pad_add_name_pv|const char *name|U32 flags|HV *typestash|HV *ourstash

Exactly like L</pad_add_name_pvn>, but takes a nul-terminated string
instead of a string/length pair.
a438 2
=cut
*/
a439 7
PADOFFSET
Perl_pad_add_name_pv(pTHX_ const char *name,
		     const U32 flags, HV *typestash, HV *ourstash)
{
    PERL_ARGS_ASSERT_PAD_ADD_NAME_PV;
    return pad_add_name_pvn(name, strlen(name), flags, typestash, ourstash);
}
d442 1
a442 1
=for apidoc Am|PADOFFSET|pad_add_name_sv|SV *name|U32 flags|HV *typestash|HV *ourstash
d444 3
a446 33
Exactly like L</pad_add_name_pvn>, but takes the name string in the form
of an SV instead of a string/length pair.

=cut
*/

PADOFFSET
Perl_pad_add_name_sv(pTHX_ SV *name, U32 flags, HV *typestash, HV *ourstash)
{
    char *namepv;
    STRLEN namelen;
    PERL_ARGS_ASSERT_PAD_ADD_NAME_SV;
    namepv = SvPV(name, namelen);
    if (SvUTF8(name))
        flags |= padadd_UTF8_NAME;
    return pad_add_name_pvn(namepv, namelen, flags, typestash, ourstash);
}

/*
=for apidoc Amx|PADOFFSET|pad_alloc|I32 optype|U32 tmptype

Allocates a place in the currently-compiling pad,
returning the offset of the allocated pad slot.
No name is initially attached to the pad slot.
I<tmptype> is a set of flags indicating the kind of pad entry required,
which will be set in the value SV for the allocated pad entry:

    SVs_PADMY    named lexical variable ("my", "our", "state")
    SVs_PADTMP   unnamed temporary store

I<optype> should be an opcode indicating the type of operation that the
pad entry is to support.  This doesn't affect operational semantics,
but is used for debugging.
d470 1
a470 2
	Perl_croak(aTHX_ "panic: pad_alloc, %p!=%p",
		   AvARRAY(PL_comppad), PL_curpad);
a473 1
	/* For a my, simply push a null SV onto the end of PL_comppad. */
a477 3
	/* For a tmp, scan the pad from PL_padix upwards
	 * for a slot which has no name and no active value.
	 */
d512 1
a512 1
=for apidoc Am|PADOFFSET|pad_add_anon|CV *func|I32 optype
d514 1
a514 9
Allocates a place in the currently-compiling pad (via L</pad_alloc>)
for an anonymous function that is lexically scoped inside the
currently-compiling function.
The function I<func> is linked into the pad, and its C<CvOUTSIDE> link
to the outer scope is weakened to avoid a reference loop.

I<optype> should be an opcode indicating the type of operation that the
pad entry is to support.  This doesn't affect operational semantics,
but is used for debugging.
d520 1
a520 1
Perl_pad_add_anon(pTHX_ CV* func, I32 optype)
d530 4
a533 5
    /* These two aren't used; just make sure they're not equal to
     * PERL_PADSEQ_INTRO */
    COP_SEQ_RANGE_LOW_set(name, 0);
    COP_SEQ_RANGE_HIGH_set(name, 0);
    ix = pad_alloc(optype, SVs_PADMY);
d536 2
a537 9
    if (SvTYPE(func) == SVt_PVCV || !CvOUTSIDE(func))
	av_store(PL_comppad, ix, (SV*)func);
    else {
	SV *rv = newRV_inc((SV *)func);
	sv_rvweaken(rv);
	assert (SvTYPE(func) == SVt_PVFM);
	av_store(PL_comppad, ix, rv);
    }
    SvPADMY_on((SV*)func);
d541 4
a544 4
    if (CvOUTSIDE(func) && SvTYPE(func) == SVt_PVCV) {
	assert(!CvWEAKOUTSIDE(func));
	CvWEAKOUTSIDE_on(func);
	SvREFCNT_dec(CvOUTSIDE(func));
d549 2
a554 1

d556 3
a558 4
     * an our (anywhere in the pad) with the same name and the
       same stash as C<ourstash>

C<is_our> indicates that the name to check is an 'our' declaration.
d564 1
a564 1
S_pad_check_dup(pTHX_ SV *name, U32 flags, const HV *ourstash)
d590 1
a590 2
	    && (   COP_SEQ_RANGE_LOW(sv)  == PERL_PADSEQ_INTRO
		|| COP_SEQ_RANGE_HIGH(sv) == PERL_PADSEQ_INTRO)
d599 1
a599 2
		(COP_SEQ_RANGE_HIGH(sv) == PERL_PADSEQ_INTRO
		    ? "scope" : "statement"));
d606 1
a606 1
	while (off > 0) {
d611 1
a611 2
		&& (   COP_SEQ_RANGE_LOW(sv)  == PERL_PADSEQ_INTRO
		    || COP_SEQ_RANGE_HIGH(sv) == PERL_PADSEQ_INTRO)
d622 1
a622 2
	    --off;
	}
d628 1
a628 1
=for apidoc Am|PADOFFSET|pad_findmy_pvn|const char *namepv|STRLEN namelen|U32 flags
d630 5
a634 8
Given the name of a lexical variable, find its position in the
currently-compiling pad.
I<namepv>/I<namelen> specify the variable's name, including leading sigil.
I<flags> is reserved and must be zero.
If it is not in the current pad but appears in the pad of any lexically
enclosing scope, then a pseudo-entry for it is added in the current pad.
Returns the offset in the current pad,
or C<NOT_IN_PAD> if no such lexical is in scope.
d640 1
a640 1
Perl_pad_findmy_pvn(pTHX_ const char *namepv, STRLEN namelen, U32 flags)
d649 1
a649 1
    PERL_ARGS_ASSERT_PAD_FINDMY_PVN;
d651 1
a651 1
    pad_peg("pad_findmy_pvn");
d653 2
a654 2
    if (flags & ~padadd_UTF8_NAME)
	Perl_croak(aTHX_ "panic: pad_findmy_pvn illegal flag bits 0x%" UVxf,
d657 10
a666 9
    if (flags & padadd_UTF8_NAME) {
        bool is_utf8 = TRUE;
        namepv = (const char*)bytes_from_utf8((U8*)namepv, &namelen, &is_utf8);

        if (is_utf8)
            flags |= padadd_UTF8_NAME;
        else
            flags &= ~padadd_UTF8_NAME;
    }
d668 2
a669 2
    offset = pad_findlex(namepv, namelen, flags,
                PL_compcv, PL_cop_seqmax, 1, NULL, &out_sv, &out_flags);
d684 2
a685 4
	    && SvCUR(namesv) == namelen
            && sv_eq_pvn_flags(aTHX_ namesv, namepv, namelen,
                                flags & padadd_UTF8_NAME ? SVf_UTF8 : 0 )
	    && COP_SEQ_RANGE_LOW(namesv) == PERL_PADSEQ_INTRO
d693 3
a695 47
=for apidoc Am|PADOFFSET|pad_findmy_pv|const char *name|U32 flags

Exactly like L</pad_findmy_pvn>, but takes a nul-terminated string
instead of a string/length pair.

=cut
*/

PADOFFSET
Perl_pad_findmy_pv(pTHX_ const char *name, U32 flags)
{
    PERL_ARGS_ASSERT_PAD_FINDMY_PV;
    return pad_findmy_pvn(name, strlen(name), flags);
}

/*
=for apidoc Am|PADOFFSET|pad_findmy_sv|SV *name|U32 flags

Exactly like L</pad_findmy_pvn>, but takes the name string in the form
of an SV instead of a string/length pair.

=cut
*/

PADOFFSET
Perl_pad_findmy_sv(pTHX_ SV *name, U32 flags)
{
    char *namepv;
    STRLEN namelen;
    PERL_ARGS_ASSERT_PAD_FINDMY_SV;
    namepv = SvPV(name, namelen);
    if (SvUTF8(name))
        flags |= padadd_UTF8_NAME;
    return pad_findmy_pvn(namepv, namelen, flags);
}

/*
=for apidoc Amp|PADOFFSET|find_rundefsvoffset

Find the position of the lexical C<$_> in the pad of the
currently-executing function.  Returns the offset in the current pad,
or C<NOT_IN_PAD> if there is no lexical C<$_> in scope (in which case
the global one should be used instead).
L</find_rundefsv> is likely to be more convenient.

=cut
*/
d703 1
a703 1
    return pad_findlex("$_", 2, 0, find_runcv(NULL), PL_curcop->cop_seq, 1,
d708 1
a708 45
=for apidoc Am|SV *|find_rundefsv

Find and return the variable that is named C<$_> in the lexical scope
of the currently-executing function.  This may be a lexical C<$_>,
or will otherwise be the global one.

=cut
*/

SV *
Perl_find_rundefsv(pTHX)
{
    SV *namesv;
    int flags;
    PADOFFSET po;

    po = pad_findlex("$_", 2, 0, find_runcv(NULL), PL_curcop->cop_seq, 1,
	    NULL, &namesv, &flags);

    if (po == NOT_IN_PAD || SvPAD_OUR(namesv))
	return DEFSV;

    return PAD_SVl(po);
}

SV *
Perl_find_rundefsv2(pTHX_ CV *cv, U32 seq)
{
    SV *namesv;
    int flags;
    PADOFFSET po;

    PERL_ARGS_ASSERT_FIND_RUNDEFSV2;

    po = pad_findlex("$_", 2, 0, cv, seq, 1,
	    NULL, &namesv, &flags);

    if (po == NOT_IN_PAD || SvPAD_OUR(namesv))
	return DEFSV;

    return AvARRAY((PAD*) (AvARRAY(CvPADLIST(cv))[CvDEPTH(cv)]))[po];
}

/*
=for apidoc m|PADOFFSET|pad_findlex|const char *namepv|STRLEN namelen|U32 flags|const CV* cv|U32 seq|int warn|SV** out_capture|SV** out_name_sv|int *out_flags
d739 2
a740 2
S_pad_findlex(pTHX_ const char *namepv, STRLEN namelen, U32 flags, const CV* cv, U32 seq,
	int warn, SV** out_capture, SV** out_name_sv, int *out_flags)
a749 4
    if (flags & ~padadd_UTF8_NAME)
	Perl_croak(aTHX_ "panic: pad_findlex illegal flag bits 0x%" UVxf,
		   (UV)flags);

d753 2
a754 3
	"Pad findlex cv=0x%"UVxf" searching \"%.*s\" seq=%d%s\n",
			   PTR2UV(cv), (int)namelen, namepv, (int)seq,
	out_capture ? " capturing" : "" ));
d766 1
a766 3
		    && SvCUR(namesv) == namelen
                    && sv_eq_pvn_flags(aTHX_ namesv, namepv, namelen,
                                    flags & padadd_UTF8_NAME ? SVf_UTF8 : 0))
d768 1
a768 1
		if (SvFAKE(namesv)) {
d770 3
a772 27
		    continue;
		}
		/* is seq within the range _LOW to _HIGH ?
		 * This is complicated by the fact that PL_cop_seqmax
		 * may have wrapped around at some point */
		if (COP_SEQ_RANGE_LOW(namesv) == PERL_PADSEQ_INTRO)
		    continue; /* not yet introduced */

		if (COP_SEQ_RANGE_HIGH(namesv) == PERL_PADSEQ_INTRO) {
		    /* in compiling scope */
		    if (
			(seq >  COP_SEQ_RANGE_LOW(namesv))
			? (seq - COP_SEQ_RANGE_LOW(namesv) < (U32_MAX >> 1))
			: (COP_SEQ_RANGE_LOW(namesv) - seq > (U32_MAX >> 1))
		    )
		       break;
		}
		else if (
		    (COP_SEQ_RANGE_LOW(namesv) > COP_SEQ_RANGE_HIGH(namesv))
		    ?
			(  seq >  COP_SEQ_RANGE_LOW(namesv)
			|| seq <= COP_SEQ_RANGE_HIGH(namesv))

		    :    (  seq >  COP_SEQ_RANGE_LOW(namesv)
			 && seq <= COP_SEQ_RANGE_HIGH(namesv))
		)
		break;
d785 1
a785 1
		 * shared' warnings. We also treated already-compiled
d827 1
a827 5
				       "Variable \"%"SVf"\" is not available",
                                       newSVpvn_flags(namepv, namelen,
                                           SVs_TEMP |
                                           (flags & padadd_UTF8_NAME ? SVf_UTF8 : 0)));

d839 1
a839 4
			    "Variable \"%"SVf"\" will not stay shared",
                            newSVpvn_flags(namepv, namelen,
                                SVs_TEMP |
                                (flags & padadd_UTF8_NAME ? SVf_UTF8 : 0)));
d851 1
a851 1
			(void) pad_findlex(namepv, namelen, flags, CvOUTSIDE(cv),
d868 1
a868 4
				       "Variable \"%"SVf"\" is not available",
                                       newSVpvn_flags(namepv, namelen,
                                           SVs_TEMP |
                                           (flags & padadd_UTF8_NAME ? SVf_UTF8 : 0)));
d873 1
a873 1
		    if (namelen != 0 && *namepv == '@@')
d875 1
a875 1
		    else if (namelen != 0 && *namepv == '%')
d896 1
a896 1
    offset = pad_findlex(namepv, namelen, flags, CvOUTSIDE(cv), CvOUTSIDE_SEQ(cv), 1,
d910 1
a910 1
	   type as the source, independent of the flags set, and on it being
d921 1
a921 1
	    = pad_alloc_name(new_namesv,
d961 1
a962 1

d964 1
a964 1
=for apidoc Am|SV *|pad_sv|PADOFFSET po
d966 1
a966 1
Get the value at offset I<po> in the current (compiling or executing) pad.
d972 1
d988 1
d990 1
a990 1
=for apidoc Am|void|pad_setsv|PADOFFSET po|SV *sv
d992 1
a992 1
Set the value at offset I<po> in the current (compiling or executing) pad.
d1013 2
a1015 1
#endif /* DEBUGGING */
d1018 1
a1018 1
=for apidoc m|void|pad_block_start|int full
d1051 1
d1053 1
a1053 1
=for apidoc m|U32|intro_my
a1065 1
    U32 seq;
d1075 2
a1076 4
	if (sv && sv != &PL_sv_undef && !SvFAKE(sv)
	    && COP_SEQ_RANGE_LOW(sv) == PERL_PADSEQ_INTRO)
	{
	    COP_SEQ_RANGE_HIGH_set(sv, PERL_PADSEQ_INTRO); /* Don't know scope end yet. */
a1085 4
    seq = PL_cop_seqmax;
    PL_cop_seqmax++;
    if (PL_cop_seqmax == PERL_PADSEQ_INTRO) /* not a legal value */
	PL_cop_seqmax++;
d1089 1
a1089 1
		"Pad intromy: seq -> %ld\n", (long)(PL_cop_seqmax)));
d1091 1
a1091 1
    return seq;
d1095 1
a1095 1
=for apidoc m|void|pad_leavemy
d1125 1
a1125 3
	if (sv && sv != &PL_sv_undef && !SvFAKE(sv)
	    && COP_SEQ_RANGE_HIGH(sv) == PERL_PADSEQ_INTRO)
	{
a1135 2
    if (PL_cop_seqmax == PERL_PADSEQ_INTRO) /* not a legal value */
	PL_cop_seqmax++;
d1140 1
d1142 1
a1142 1
=for apidoc m|void|pad_swipe|PADOFFSET po|bool refadjust
d1158 3
a1160 5
	Perl_croak(aTHX_ "panic: pad_swipe curpad, %p!=%p",
		   AvARRAY(PL_comppad), PL_curpad);
    if (!po || ((SSize_t)po) > AvFILLp(PL_comppad))
	Perl_croak(aTHX_ "panic: pad_swipe po=%ld, fill=%ld",
		   (long)po, (long)AvFILLp(PL_comppad));
d1184 1
d1186 1
a1186 1
=for apidoc m|void|pad_reset
d1205 1
a1205 2
	Perl_croak(aTHX_ "panic: pad_reset curpad, %p!=%p",
		   AvARRAY(PL_comppad), PL_curpad);
d1226 1
d1228 1
a1228 1
=for apidoc Amx|void|pad_tidy|padtidy_type type
d1230 4
a1233 8
Tidy up a pad at the end of compilation of the code to which it belongs.
Jobs performed here are: remove most stuff from the pads of anonsub
prototypes; give it a @@_; mark temporaries as such.  I<type> indicates
the kind of subroutine:

    padtidy_SUB        ordinary subroutine
    padtidy_SUBCLONE   prototype for lexical closure
    padtidy_FORMAT     format
d1256 1
a1256 1
     * executed within it.
d1302 1
d1307 3
a1309 2
    if (type == padtidy_SUB || type == padtidy_FORMAT) {
	SV * const * const namep = AvARRAY(PL_comppad_name);
d1314 8
a1321 1
	    if (!SvPADMY(PL_curpad[ix])) {
a1322 19
	    } else if (!SvFAKE(namep[ix])) {
		/* This is a work around for how the current implementation of
		   ?{ } blocks in regexps interacts with lexicals.

		   One of our lexicals.
		   Can't do this on all lexicals, otherwise sub baz() won't
		   compile in

		   my $foo;

		   sub bar { ++$foo; }

		   sub baz { ++$foo; }

		   because completion of compiling &bar calling pad_tidy()
		   would cause (top level) $foo to be marked as stale, and
		   "no longer available".  */
		SvPADSTALE_on(PL_curpad[ix]);
	    }
d1328 1
d1330 1
a1330 1
=for apidoc m|void|pad_free|PADOFFSET po
d1346 1
a1346 2
	Perl_croak(aTHX_ "panic: pad_free curpad, %p!=%p",
		   AvARRAY(PL_comppad), PL_curpad);
d1356 6
a1361 1
	SvFLAGS(PL_curpad[po]) &= ~SVs_PADTMP; /* also clears SVs_PADSTALE */
d1367 2
d1370 1
a1370 1
=for apidoc m|void|do_dump_pad|I32 level|PerlIO *file|PADLIST *padlist|int full
d1440 1
a1440 1
#ifdef DEBUGGING
d1443 1
a1443 1
=for apidoc m|void|cv_dump|CV *cv|const char *title
d1450 1
d1480 4
a1484 1
#endif /* DEBUGGING */
d1487 1
a1487 1
=for apidoc Am|CV *|cv_clone|CV *proto
d1489 3
a1491 5
Clone a CV, making a lexical closure.  I<proto> supplies the prototype
of the function: its code, pad structure, and other attributes.
The prototype is combined with a capture of outer lexicals to which the
code refers, which are taken from the currently-executing instance of
the immediately surrounding code.
d1519 1
a1519 3
     * Note that in general for formats, CvOUTSIDE != find_runcv; formats
     * inside closures, however, only work if CvOUTSIDE == find_runcv.
     */
a1523 3
    if (SvTYPE(proto) == SVt_PVFM
     && CvROOT(outside) != CvROOT(CvOUTSIDE(proto)))
	outside = CvOUTSIDE(proto);
d1528 1
a1528 1
    assert(CvPADLIST(outside) || SvTYPE(proto) == SVt_PVFM);
d1534 1
a1534 1
    CvFLAGS(cv) = CvFLAGS(proto) & ~(CVf_CLONE|CVf_WEAKOUTSIDE|CVf_CVGV_RC);
d1537 8
a1544 4
    CvFILE(cv)		= CvDYNFILE(proto) ? savepv(CvFILE(proto))
					   : CvFILE(proto);
    CvGV_set(cv,CvGV(proto));
    CvSTASH_set(cv, CvSTASH(proto));
d1558 1
a1558 1
    for (ix = fname; ix > 0; ix--)
d1563 1
a1563 3
    outpad = CvPADLIST(outside)
	? AvARRAY(AvARRAY(CvPADLIST(outside))[depth])
	: NULL;
d1570 3
a1572 1
		/* formats may have an inactive, or even undefined, parent,
d1575 1
a1575 2
		if (!outpad || !(sv = outpad[PARENT_PAD_INDEX(namesv)])
		 || (SvPADSTALE(sv) && !SvPAD_STATE(namesv))) {
d1577 1
a1577 1
				   "Variable \"%"SVf"\" is not available", namesv);
d1637 1
d1639 1
a1639 1
=for apidoc m|void|pad_fixup_inner_anons|PADLIST *padlist|CV *old_cv|CV *new_cv
a1665 1
	  if (SvTYPE(curpad[ix]) == SVt_PVCV) {
a1669 12
	  }
	  else { /* format reference */
	    SV * const rv = curpad[ix];
	    CV *innercv;
	    if (!SvOK(rv)) continue;
	    assert(SvROK(rv));
	    assert(SvWEAKREF(rv));
	    innercv = (CV *)SvRV(rv);
	    assert(!CvWEAKOUTSIDE(innercv));
	    SvREFCNT_dec(CvOUTSIDE(innercv));
	    CvOUTSIDE(innercv) = (CV *)SvREFCNT_inc_simple_NN(new_cv);
	  }
d1674 1
d1676 1
a1676 1
=for apidoc m|void|pad_push|PADLIST *padlist|int depth
d1734 1
a1742 9
/*
=for apidoc Am|HV *|pad_compname_type|PADOFFSET po

Looks up the type of the lexical variable at position I<po> in the
currently-compiling pad.  If the variable is typed, the stash of the
class to which it is typed is returned.  If not, C<NULL> is returned.

=cut
*/
a1753 125

#if defined(USE_ITHREADS)

#  define av_dup_inc(s,t)	MUTABLE_AV(sv_dup_inc((const SV *)s,t))

/*
=for apidoc m|AV *|padlist_dup|AV *srcpad|CLONE_PARAMS *param

Duplicates a pad.

=cut
*/

AV *
Perl_padlist_dup(pTHX_ AV *srcpad, CLONE_PARAMS *param)
{
    AV *dstpad;
    PERL_ARGS_ASSERT_PADLIST_DUP;

    if (!srcpad)
	return NULL;

    if (param->flags & CLONEf_COPY_STACKS
	|| SvREFCNT(AvARRAY(srcpad)[1]) > 1) {
	dstpad = av_dup_inc(srcpad, param);
	assert (SvREFCNT(AvARRAY(srcpad)[1]) == 1);
    } else {
	/* CvDEPTH() on our subroutine will be set to 0, so there's no need
	   to build anything other than the first level of pads.  */

	I32 ix = AvFILLp((const AV *)AvARRAY(srcpad)[1]);
	AV *pad1;
	const I32 names_fill = AvFILLp((const AV *)(AvARRAY(srcpad)[0]));
	const AV *const srcpad1 = (const AV *) AvARRAY(srcpad)[1];
	SV **oldpad = AvARRAY(srcpad1);
	SV **names;
	SV **pad1a;
	AV *args;
	/* Look for it in the table first, as the padlist may have ended up
	   as an element of @@DB::args (or theoretically even @@_), so it may
	   may have been cloned already.  It may also be there because of
	   how Perl_sv_compile_2op() "works". :-(   */
	dstpad = (AV*)ptr_table_fetch(PL_ptr_table, srcpad);

	if (dstpad)
	    return (AV *)SvREFCNT_inc_simple_NN(dstpad);

	dstpad = newAV();
	ptr_table_store(PL_ptr_table, srcpad, dstpad);
	av_extend(dstpad, 1);
	AvARRAY(dstpad)[0] = MUTABLE_SV(av_dup_inc(AvARRAY(srcpad)[0], param));
	names = AvARRAY(AvARRAY(dstpad)[0]);

	pad1 = newAV();

	av_extend(pad1, ix);
	AvARRAY(dstpad)[1] = MUTABLE_SV(pad1);
	pad1a = AvARRAY(pad1);
	AvFILLp(dstpad) = 1;

	if (ix > -1) {
	    AvFILLp(pad1) = ix;

	    for ( ;ix > 0; ix--) {
		if (!oldpad[ix]) {
		    pad1a[ix] = NULL;
		} else if (names_fill >= ix && names[ix] != &PL_sv_undef) {
		    const char sigil = SvPVX_const(names[ix])[0];
		    if ((SvFLAGS(names[ix]) & SVf_FAKE)
			|| (SvFLAGS(names[ix]) & SVpad_STATE)
			|| sigil == '&')
			{
			    /* outer lexical or anon code */
			    pad1a[ix] = sv_dup_inc(oldpad[ix], param);
			}
		    else {		/* our own lexical */
			if(SvPADSTALE(oldpad[ix]) && SvREFCNT(oldpad[ix]) > 1) {
			    /* This is a work around for how the current
			       implementation of ?{ } blocks in regexps
			       interacts with lexicals.  */
			    pad1a[ix] = sv_dup_inc(oldpad[ix], param);
			} else {
			    SV *sv; 
			    
			    if (sigil == '@@')
				sv = MUTABLE_SV(newAV());
			    else if (sigil == '%')
				sv = MUTABLE_SV(newHV());
			    else
				sv = newSV(0);
			    pad1a[ix] = sv;
			    SvPADMY_on(sv);
			}
		    }
		}
		else if (IS_PADGV(oldpad[ix]) || IS_PADCONST(oldpad[ix])) {
		    pad1a[ix] = sv_dup_inc(oldpad[ix], param);
		}
		else {
		    /* save temporaries on recursion? */
		    SV * const sv = newSV(0);
		    pad1a[ix] = sv;

		    /* SvREFCNT(oldpad[ix]) != 1 for some code in threads.xs
		       FIXTHAT before merging this branch.
		       (And I know how to) */
		    if (SvPADMY(oldpad[ix]))
			SvPADMY_on(sv);
		    else
			SvPADTMP_on(sv);
		}
	    }

	    if (oldpad[0]) {
		args = newAV();			/* Will be @@_ */
		AvREIFY_only(args);
		pad1a[0] = (SV *)args;
	    }
	}
    }

    return dstpad;
}

#endif /* USE_ITHREADS */
@


1.1.1.9
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d32 1
a32 1
CV's can have CvPADLIST(cv) set to point to a PADLIST.  This is the CV's
d36 1
a36 1
For these purposes "formats" are a kind-of CV; eval""s are too (except they're
d38 1
a38 1
executing).  Require'd files are simply evals without any outer lexical
d45 12
a56 1
The PADLIST has a C array where pads are stored.
d58 2
a59 13
The 0th entry of the PADLIST is a PADNAMELIST (which is actually just an
AV, but that may change) which represents the "names" or rather
the "static type information" for lexicals.  The individual elements of a
PADNAMELIST are PADNAMEs (just SVs; but, again, that may change).  Future
refactorings might stop the PADNAMELIST from being stored in the PADLIST's
array, so don't rely on it.  See L</PadlistNAMES>.

The CvDEPTH'th entry of a PADLIST is a PAD (an AV) which is the stack frame
at that depth of recursion into the CV.  The 0th slot of a frame AV is an
AV which is @@_.  Other entries are storage for variables and op targets.

Iterating over the PADNAMELIST iterates over all possible pad
items.  Pad slots that are SVs_PADTMP (targets/GVs/constants) end up having
d62 1
a62 1
Only my/our variable (SvPADMY/PADNAME_isOUR) slots get valid names.
d65 1
a65 1
can be looked up from Perl code at run time through eval"" the way
d88 1
a88 2
If PADNAME_OUTER (SvFAKE) is set on the
name SV, then that slot in the frame AV is
d97 1
a97 1
If the 'name' is '&' the corresponding entry in the PAD
d99 1
a99 2
(PADNAME_OUTER and name of '&' is not a
meaningful combination currently but could
d106 1
a106 2
and set on scope exit.  This allows the
'Variable $x is not available' warning
d111 1
a111 1
For state vars, SVs_PADSTALE is overloaded to mean 'not yet initialised'.
d113 1
a113 1
=for apidoc AmxU|PADNAMELIST *|PL_comppad_name
d118 1
a118 1
=for apidoc AmxU|PAD *|PL_comppad
d129 1
a129 1
(I.e., this is C<PAD_ARRAY(PL_comppad)>.)
d196 1
a196 1
              SvREFCNT_dec_NN(svrecode);
d231 2
a232 3
    PADLIST *padlist;
    PAD *padname, *pad;
    PAD **ary;
d246 1
a247 1
	    SAVESPTR(PL_comppad_name);
d263 2
a264 1
    Newxz(padlist, 1, PADLIST);
a275 2

	padname = (PAD *)SvREFCNT_inc_simple_NN(PL_comppad_name);
a278 1
	padname = newAV();
d285 7
a291 5
    Newx(ary, 2, PAD *);
    PadlistMAX(padlist) = 1;
    PadlistARRAY(padlist) = ary;
    ary[0] = padname;
    ary[1] = pad;
d295 1
a299 1
	PL_comppad_name	     = padname;
a335 1
    bool const slabbed = !!CvSLABBED(cv);
a348 1
    CvSLABBED_off(cv);
a355 1
	if (slabbed) OpslabREFCNT_dec_padok(OpSLAB(CvROOT(cv)));
a360 15
    else if (slabbed && CvSTART(cv)) {
	ENTER;
	PAD_SAVE_SETNULLPAD();

	/* discard any leaked ops */
	if (PL_parser)
	    parser_free_nexttoke_ops(PL_parser, (OPSLAB *)CvSTART(cv));
	opslab_force_free((OPSLAB *)CvSTART(cv));
	CvSTART(cv) = NULL;

	LEAVE;
    }
#ifdef DEBUGGING
    else if (slabbed) Perl_warn(aTHX_ "Slab leaked from cv %p", cv);
#endif
d362 1
a362 3
    sv_unmagic((SV *)cv, PERL_MAGIC_checkcall);
    if (CvNAMED(cv)) CvNAME_HEK_set(cv, NULL);
    else	     CvGV_set(cv, NULL);
d367 2
a368 1
    if (padlist) {
d391 1
a391 1
	    PAD * const comppad_name = PadlistARRAY(padlist)[0];
d393 1
a393 1
	    PAD * const comppad = PadlistARRAY(padlist)[1];
d404 2
d409 1
a409 1
			    SvREFCNT_dec_NN(innercv);
d431 1
a431 1
	ix = PadlistMAX(padlist);
d433 1
a433 1
	    PAD * const sv = PadlistARRAY(padlist)[ix--];
d435 1
a435 1
		if (sv == PL_comppad) {
d439 1
a439 1
		SvREFCNT_dec_NN(sv);
d443 2
a444 2
	    PAD * const sv = PadlistARRAY(padlist)[0];
	    if (sv == PL_comppad_name && SvREFCNT(sv) == 1)
d448 2
a449 2
	if (PadlistARRAY(padlist)) Safefree(PadlistARRAY(padlist));
	Safefree(padlist);
a473 41
=for apidoc cv_forget_slab

When a CV has a reference count on its slab (CvSLABBED), it is responsible
for making sure it is freed.  (Hence, no two CVs should ever have a
reference count on the same slab.)  The CV only needs to reference the slab
during compilation.  Once it is compiled and CvROOT attached, it has
finished its job, so it can forget the slab.

=cut
*/

void
Perl_cv_forget_slab(pTHX_ CV *cv)
{
    const bool slabbed = !!CvSLABBED(cv);
    OPSLAB *slab = NULL;

    PERL_ARGS_ASSERT_CV_FORGET_SLAB;

    if (!slabbed) return;

    CvSLABBED_off(cv);

    if      (CvROOT(cv))  slab = OpSLAB(CvROOT(cv));
    else if (CvSTART(cv)) slab = (OPSLAB *)CvSTART(cv);
#ifdef DEBUGGING
    else if (slabbed)     Perl_warn(aTHX_ "Slab leaked from cv %p", cv);
#endif

    if (slab) {
#ifdef PERL_DEBUG_READONLY_OPS
	const size_t refcnt = slab->opslab_refcnt;
#endif
	OpslabREFCNT_dec(slab);
#ifdef PERL_DEBUG_READONLY_OPS
	if (refcnt > 1) Slab_to_ro(slab);
#endif
    }
}

/*
a567 2
	ENTER;
	SAVEFREESV(namesv); /* in case of fatal warnings */
a569 2
	SvREFCNT_inc_simple_void_NN(namesv);
	LEAVE;
a587 2
    else if (namelen != 0 && *namepv == '&')
	sv_upgrade(PL_curpad[offset], SVt_PVCV);
d656 5
a727 2
One reference count is stolen, so you may need to do C<SvREFCNT_inc(func)>.

d756 1
a756 1
	SV *rv = newRV_noinc((SV *)func);
d768 1
a768 1
	SvREFCNT_dec_NN(CvOUTSIDE(func));
a819 1
	    /* diag_listed_as: "%s" variable %s masks earlier declaration in same %s */
d821 1
a821 1
		"\"%s\" %s %"SVf" masks earlier declaration in same %s",
a822 1
		*SvPVX(sv) == '&' ? "subroutine" : "variable",
d907 1
a907 1
    nameav = PadlistARRAY(CvPADLIST(PL_compcv))[0];
d1024 1
a1024 1
    return AvARRAY(PadlistARRAY(CvPADLIST(cv))[CvDEPTH(cv)])[po];
d1055 1
a1055 1
#define CvLATE(cv) (CvANON(cv) || CvCLONE(cv) || SvTYPE(cv) == SVt_PVFM)
a1056 11
static void
S_unavailable(pTHX_ SV *namesv)
{
    /* diag_listed_as: Variable "%s" is not available */
    Perl_ck_warner(aTHX_ packWARN(WARN_CLOSURE),
			"%se \"%"SVf"\" is not available",
			 *SvPVX_const(namesv) == '&'
					 ? "Subroutin"
					 : "Variabl",
			 namesv);
}
d1066 1
a1066 2
    const PADLIST * const padlist = CvPADLIST(cv);
    const bool staleok = !!(flags & padadd_STALEOK);
d1070 1
a1070 1
    if (flags & ~(padadd_UTF8_NAME|padadd_STALEOK))
a1072 1
    flags &= ~ padadd_STALEOK; /* one-shot flag */
d1085 1
a1085 1
        const AV * const nameav = PadlistARRAY(padlist)[0];
d1177 2
a1178 1
			S_unavailable(aTHX_
d1216 2
a1217 2
		    *out_capture = AvARRAY(PadlistARRAY(padlist)[
				    CvDEPTH(cv) ? CvDEPTH(cv) : 1])[offset];
a1222 1
			&& (!CvDEPTH(cv) || !staleok)
d1225 2
a1226 1
			S_unavailable(aTHX_
a1237 2
		    else if (namelen != 0 && *namepv == '&')
			*out_capture = sv_2mortal(newSV_type(SVt_PVCV));
d1257 1
a1257 3
    offset = pad_findlex(namepv, namelen,
		flags | padadd_STALEOK*(new_capturep == &new_capture),
		CvOUTSIDE(cv), CvOUTSIDE_SEQ(cv), 1,
d1277 2
a1278 2
	PL_comppad_name = PadlistARRAY(padlist)[0];
	PL_comppad = PadlistARRAY(padlist)[1];
a1307 2
	    /* But also note the offset, as newMYSUB needs it */
	    PARENT_PAD_INDEX_set(new_namesv, offset);
d1378 1
a1378 1
Update the pad compilation state variables on entry to a new block.
d1412 1
a1412 3
"Introduce" my variables to visible status.  This is called during parsing
at the end of each statement to make lexical variables visible to
subsequent statements.
d1467 1
a1467 1
OP *
a1471 1
    OP *o = NULL;
d1488 1
a1488 1
	SV * const sv = svp[off];
a1498 6
	    if (!PadnameIsSTATE(sv) && !PadnameIsOUR(sv)
	     && *PadnamePV(sv) == '&' && PadnameLEN(sv) > 1) {
		OP *kid = newOP(OP_INTROCV, 0);
		kid->op_targ = off;
		o = op_prepend_elem(OP_LINESEQ, kid, o);
	    }
a1505 1
    return o;
d1583 2
a1584 2
    if (!TAINTING_get) {	/* Can't mix tainted and non-tainted temporaries. */
        I32 po;
d1622 7
a1628 15
    /* If this CV has had any 'eval-capable' ops planted in it:
     * i.e. it contains any of:
     *
     *     * eval '...',
     *     * //ee,
     *     * use re 'eval'; /$var/
     *     * /(?{..})/),
     *
     * Then any anon prototypes in the chain of CVs should be marked as
     * cloneable, so that for example the eval's CV in
     *
     *    sub { eval '$x' }
     *
     * gets the right CvOUTSIDE.  If running with -d, *any* sub may
     * potentially have an eval executed within it.
a1640 1
	    CvHASEVAL_on(cv);
a1722 1
    SV *sv;
d1737 3
a1739 5

    sv = PL_curpad[po];
    if (sv && sv != &PL_sv_undef && !SvPADMY(sv))
	SvFLAGS(sv) &= ~SVs_PADTMP;

d1767 2
a1768 2
    pad_name = *PadlistARRAY(padlist);
    pad = PadlistARRAY(padlist)[1];
d1830 1
a1830 1
    PADLIST* const padlist = CvPADLIST(cv);
d1869 2
a1870 4
static CV *S_cv_clone(pTHX_ CV *proto, CV *cv, CV *outside);

static void
S_cv_clone_pad(pTHX_ CV *proto, CV *cv, CV *outside, bool newcv)
d1874 3
a1876 3
    PADLIST* const protopadlist = CvPADLIST(proto);
    PAD *const protopad_name = *PadlistARRAY(protopadlist);
    const PAD *const protopad = PadlistARRAY(protopadlist)[1];
d1881 1
d1883 1
d1885 2
a1886 1
    bool subclones = FALSE;
d1890 1
a1890 7
    /* Anonymous subs have a weak CvOUTSIDE pointer, so its value is not
     * reliable.  The currently-running sub is always the one we need to
     * close over.
     * For my subs, the currently-running sub may not be the one we want.
     * We have to check whether it is a clone of CvOUTSIDE.
     * Note that in general for formats, CvOUTSIDE != find_runcv.
     * Since formats may be nested inside closures, CvOUTSIDE may point
d1892 2
d1896 2
a1897 2
    if (!outside) {
      if (CvWEAKOUTSIDE(proto))
d1899 2
a1900 1
      else {
d1902 2
a1903 12
	if ((CvCLONE(outside) && ! CvCLONED(outside))
	    || !CvPADLIST(outside)
	    || PadlistNAMES(CvPADLIST(outside))
		 != protopadlist->xpadl_outid) {
	    outside = find_runcv_where(
		FIND_RUNCV_padid_eq, PTR2IV(protopadlist->xpadl_outid), NULL
	    );
	    /* outside could be null */
	}
      }
    }
    depth = outside ? CvDEPTH(outside) : 0;
d1906 1
a1909 2
    PL_compcv = cv;
    if (newcv) SAVEFREESV(cv); /* in case of fatal warnings */
d1911 17
a1927 2
    if (CvHASEVAL(cv))
	CvOUTSIDE(cv)	= MUTABLE_CV(SvREFCNT_inc_simple(outside));
a1928 2
    SAVESPTR(PL_comppad_name);
    PL_comppad_name = protopad_name;
d1932 2
d1937 2
a1938 2
    outpad = outside && CvPADLIST(outside)
	? AvARRAY(PadlistARRAY(CvPADLIST(outside))[depth])
a1939 2
    if (outpad)
	CvPADLIST(cv)->xpadl_outid = PadlistNAMES(CvPADLIST(outside));
d1946 3
a1948 2
		/* formats may have an inactive, or even undefined, parent;
		   but state vars are always available. */
d1950 3
a1952 3
		 || (  SvPADSTALE(sv) && !SvPAD_STATE(namesv)
		    && (!outside || !CvDEPTH(outside)))  ) {
		    S_unavailable(aTHX_ namesv);
d1961 1
a1961 27
		    /* If there are state subs, we need to clone them, too.
		       But they may need to close over variables we have
		       not cloned yet.  So we will have to do a second
		       pass.  Furthermore, there may be state subs clos-
		       ing over other state subs’ entries, so we have
		       to put a stub here and then clone into it on the
		       second pass. */
		    if (SvPAD_STATE(namesv) && !CvCLONED(ppad[ix])) {
			assert(SvTYPE(ppad[ix]) == SVt_PVCV);
			subclones = 1;
			sv = newSV_type(SVt_PVCV);
		    }
		    else if (PadnameLEN(namesv)>1 && !PadnameIsOUR(namesv))
		    {
			/* my sub */
			/* Just provide a stub, but name it.  It will be
			   upgrade to the real thing on scope entry. */
			sv = newSV_type(SVt_PVCV);
			CvNAME_HEK_set(
			    sv,
			    share_hek(SvPVX_const(namesv)+1,
				      SvCUR(namesv) - 1
					 * (SvUTF8(namesv) ? -1 : 1),
				      0)
			);
		    }
		    else sv = SvREFCNT_inc(ppad[ix]);
d1970 1
a1970 1
		if (sigil != '&' && SvPAD_STATE(namesv))
a1983 44
    if (subclones)
	for (ix = fpad; ix > 0; ix--) {
	    SV* const namesv = (ix <= fname) ? pname[ix] : NULL;
	    if (namesv && namesv != &PL_sv_undef && !SvFAKE(namesv)
	     && SvPVX_const(namesv)[0] == '&' && SvPAD_STATE(namesv))
		S_cv_clone(aTHX_ (CV *)ppad[ix], (CV *)PL_curpad[ix], cv);
	}

    if (newcv) SvREFCNT_inc_simple_void_NN(cv);
    LEAVE;
}

static CV *
S_cv_clone(pTHX_ CV *proto, CV *cv, CV *outside)
{
    dVAR;
    const bool newcv = !cv;

    assert(!CvUNIQUE(proto));

    if (!cv) cv = MUTABLE_CV(newSV_type(SvTYPE(proto)));
    CvFLAGS(cv) = CvFLAGS(proto) & ~(CVf_CLONE|CVf_WEAKOUTSIDE|CVf_CVGV_RC
				    |CVf_SLABBED);
    CvCLONED_on(cv);

    CvFILE(cv)		= CvDYNFILE(proto) ? savepv(CvFILE(proto))
					   : CvFILE(proto);
    if (CvNAMED(proto))
	 CvNAME_HEK_set(cv, share_hek_hek(CvNAME_HEK(proto)));
    else CvGV_set(cv,CvGV(proto));
    CvSTASH_set(cv, CvSTASH(proto));
    OP_REFCNT_LOCK;
    CvROOT(cv)		= OpREFCNT_inc(CvROOT(proto));
    OP_REFCNT_UNLOCK;
    CvSTART(cv)		= CvSTART(proto);
    CvOUTSIDE_SEQ(cv) = CvOUTSIDE_SEQ(proto);

    if (SvPOK(proto))
	sv_setpvn(MUTABLE_SV(cv), SvPVX_const(proto), SvCUR(proto));
    if (SvMAGIC(proto))
	mg_copy((SV *)proto, (SV *)cv, 0, 0);

    if (CvPADLIST(proto)) S_cv_clone_pad(aTHX_ proto, cv, outside, newcv);

d1986 1
a1986 1
	if (CvOUTSIDE(cv)) cv_dump(CvOUTSIDE(cv), "Outside");
d1991 2
d2001 1
a2001 4
	    SvREFCNT_dec_NN(cv);
            /* For this calling case, op_const_sv returns a *copy*, which we
               donate to newCONSTSUB. Yes, this is ugly, and should be killed.
               Need to fix how lib/constant.pm works to eliminate this.  */
a2011 18
CV *
Perl_cv_clone(pTHX_ CV *proto)
{
    PERL_ARGS_ASSERT_CV_CLONE;

    if (!CvPADLIST(proto)) Perl_croak(aTHX_ "panic: no pad in cv_clone");
    return S_cv_clone(aTHX_ proto, NULL, NULL);
}

/* Called only by pp_clonecv */
CV *
Perl_cv_clone_into(pTHX_ CV *proto, CV *target)
{
    PERL_ARGS_ASSERT_CV_CLONE_INTO;
    cv_undef(target);
    return S_cv_clone(aTHX_ proto, target, NULL);
}

d2027 2
a2028 2
    AV * const comppad_name = PadlistARRAY(padlist)[0];
    AV * const comppad = PadlistARRAY(padlist)[1];
d2037 1
a2037 1
	if (namesv && namesv != &PL_sv_undef && !SvPAD_STATE(namesv)
d2041 4
a2044 12
	    MAGIC * const mg =
		SvMAGICAL(curpad[ix])
		    ? mg_find(curpad[ix], PERL_MAGIC_proto)
		    : NULL;
	    CV * const innercv = MUTABLE_CV(mg ? mg->mg_obj : curpad[ix]);
	    if (CvOUTSIDE(innercv) == old_cv) {
		if (!CvWEAKOUTSIDE(innercv)) {
		    SvREFCNT_dec(old_cv);
		    SvREFCNT_inc_simple_void_NN(new_cv);
		}
		CvOUTSIDE(innercv) = new_cv;
	    }
d2078 2
a2079 2
    if (depth > PadlistMAX(padlist) || !PadlistARRAY(padlist)[depth]) {
	PAD** const svp = PadlistARRAY(padlist);
d2123 2
a2124 1
	padlist_store(padlist, depth, newpad);
d2154 1
a2154 1
=for apidoc padlist_dup
d2161 2
a2162 2
PADLIST *
Perl_padlist_dup(pTHX_ PADLIST *srcpad, CLONE_PARAMS *param)
d2164 1
a2164 4
    PADLIST *dstpad;
    bool cloneall;
    PADOFFSET max;

d2170 4
a2173 16
    cloneall = param->flags & CLONEf_COPY_STACKS
	|| SvREFCNT(PadlistARRAY(srcpad)[1]) > 1;
    assert (SvREFCNT(PadlistARRAY(srcpad)[1]) == 1);

    max = cloneall ? PadlistMAX(srcpad) : 1;

    Newx(dstpad, 1, PADLIST);
    ptr_table_store(PL_ptr_table, srcpad, dstpad);
    PadlistMAX(dstpad) = max;
    Newx(PadlistARRAY(dstpad), max + 1, PAD *);

    if (cloneall) {
	PADOFFSET depth;
	for (depth = 0; depth <= max; ++depth)
	    PadlistARRAY(dstpad)[depth] =
		av_dup_inc(PadlistARRAY(srcpad)[depth], param);
d2177 2
a2178 1
	I32 ix = AvFILLp(PadlistARRAY(srcpad)[1]);
d2180 2
a2181 2
	const I32 names_fill = AvFILLp(PadlistARRAY(srcpad)[0]);
	const PAD *const srcpad1 = PadlistARRAY(srcpad)[1];
d2186 14
a2199 4

	PadlistARRAY(dstpad)[0] =
	    av_dup_inc(PadlistARRAY(srcpad)[0], param);
	names = AvARRAY(PadlistARRAY(dstpad)[0]);
d2204 1
a2204 1
	PadlistARRAY(dstpad)[1] = pad1;
d2206 1
a2273 24
PAD **
Perl_padlist_store(pTHX_ PADLIST *padlist, I32 key, PAD *val)
{
    dVAR;
    PAD **ary;
    SSize_t const oldmax = PadlistMAX(padlist);

    PERL_ARGS_ASSERT_PADLIST_STORE;

    assert(key >= 0);

    if (key > PadlistMAX(padlist)) {
	av_extend_guts(NULL,key,&PadlistMAX(padlist),
		       (SV ***)&PadlistARRAY(padlist),
		       (SV ***)&PadlistARRAY(padlist));
	Zero(PadlistARRAY(padlist)+oldmax+1, PadlistMAX(padlist)-oldmax,
	     PAD *);
    }
    ary = PadlistARRAY(padlist);
    SvREFCNT_dec(ary[key]);
    ary[key] = val;
    return &ary[key];
}

d2278 1
a2278 1
 * indent-tabs-mode: nil
d2281 1
a2281 1
 * ex: set ts=8 sts=4 sw=4 et:
@


1.1.1.10
log
@Import perl-5.20.1
@
text
@d59 2
a60 4
items.  Pad slots for targets (SVs_PADTMP) and GVs end up having &PL_sv_no
"names", while slots for constants have &PL_sv_no "names" (see
pad_alloc()).  That &PL_sv_no is used is an implementation detail subject
to change.  To test for it, use C<PadnamePV(name) && !PadnameLEN(name)>.
d90 1
a90 1
a REFCNT'ed reference to a lexical from "outside".  In this case,
d92 1
a92 1
in scope throughout.  Instead xhigh stores some flags containing info about
a284 2
	AvPAD_NAMELIST_on(padname);
	av_store(padname, 0, &PL_sv_undef);
d327 1
a327 1
Clear out all the active components of a CV.  This can happen either
a574 1
    PadnamelistMAXNAMED(PL_comppad_name) = offset;
a713 7
    SVf_READONLY constant shared between recursion levels

C<SVf_READONLY> has been supported here only since perl 5.20.  To work with
earlier versions as well, use C<SVf_READONLY|SVs_PADTMP>.  C<SVf_READONLY>
does not cause the SV in the pad slot to be marked read-only, but simply
tells C<pad_alloc> that it I<will> be made read-only (by the caller), or at
least should be treated as such.
d753 2
a754 3
	     * Entries that close over unavailable variables
	     * in outer subs contain values not marked PADMY.
	     * Thus we must skip, not just pad values that are
d757 1
d763 1
a763 1
		!IS_PADGV(sv))
a765 5
	if (tmptype & SVf_READONLY) {
	    av_store(PL_comppad_name, PL_padix, &PL_sv_no);
	    tmptype &= ~SVf_READONLY;
	    tmptype |= SVs_PADTMP;
	}
d877 1
a877 1
	    && PadnameLEN(sv)
d902 1
a902 1
		&& PadnameLEN(sv)
d978 1
a978 1
	if (namesv && PadnameLEN(namesv) == namelen
d981 1
d1097 1
a1097 1
Find a named lexical anywhere in a chain of nested pads.  Add fake entries
d1102 1
a1102 1
to match against.  If warn is true, print appropriate warnings.  The out_*
d1104 1
a1104 1
should be stored.  out_capture, if non-null, requests that the innermost
d1110 1
a1110 2
then comes back down, adding fake entries
as it goes.  It has to be this way
d1168 1
a1168 1
	for (offset = PadnamelistMAXNAMED(nameav); offset > 0; offset--) {
d1170 2
a1171 1
	    if (namesv && PadnameLEN(namesv) == namelen
d1520 1
a1520 1
	if (sv && PadnameLEN(sv) && !SvFAKE(sv)
d1568 1
a1568 1
	    if (sv && PadnameLEN(sv) && !SvFAKE(sv))
d1577 1
a1577 1
	if (sv && PadnameLEN(sv) && !SvFAKE(sv)
d1630 2
d1642 1
a1642 1
    PL_curpad[po] = NULL;
a1643 7
    if (PadnamelistMAX(PL_comppad_name) != -1
     && (PADOFFSET)PadnamelistMAX(PL_comppad_name) >= po) {
	if (PadnamelistARRAY(PL_comppad_name)[po]) {
	    assert(!PadnameLEN(PadnamelistARRAY(PL_comppad_name)[po]));
	}
	PadnamelistARRAY(PL_comppad_name)[po] = &PL_sv_undef;
    }
d1748 1
a1748 1
    /* extend namepad to match curpad */
d1753 1
a1753 1
	SV ** const namep = AvARRAY(PL_comppad_name);
a1757 1
	    if (!namep[ix]) namep[ix] = &PL_sv_undef;
d1759 2
d1763 1
a1763 1
	     * pad are anonymous subs, constants and GVs.
d1766 3
a1768 6
	    if (!PL_curpad[ix] || SvIMMORTAL(PL_curpad[ix])
		 || IS_PADGV(PL_curpad[ix]))
		continue;
	    namesv = namep[ix];
	    if (!(PadnamePV(namesv) &&
		   (!PadnameLEN(namesv) || *SvPVX_const(namesv) == '&')))
d1783 1
a1783 1
	SV ** const namep = AvARRAY(PL_comppad_name);
d1786 1
a1786 3
	    if (!namep[ix]) namep[ix] = &PL_sv_undef;
	    if (!PL_curpad[ix] || SvIMMORTAL(PL_curpad[ix])
		 || IS_PADGV(PL_curpad[ix]) || IS_PADCONST(PL_curpad[ix]))
d1885 1
a1885 1
	if (namesv && !PadnameLEN(namesv)) {
d2051 1
a2051 5
	if (namesv && PadnameLEN(namesv)) { /* lexical */
	  if (PadnameIsOUR(namesv)) { /* or maybe not so lexical */
		NOOP;
	  }
	  else {
a2104 1
	  }
d2106 1
a2106 1
	else if (IS_PADGV(ppad[ix]) || (namesv && PadnamePV(namesv))) {
d2153 1
a2153 1
    if (SvPOK(proto)) {
a2154 3
        if (SvUTF8(proto))
           SvUTF8_on(MUTABLE_SV(cv));
    }
d2211 1
a2211 1
old_cv to new_cv if necessary.  Needed when a newly-compiled CV has to be
d2291 1
a2291 1
	    if (names_fill >= ix && PadnameLEN(names[ix])) {
d2312 1
a2312 1
	    else if (IS_PADGV(oldpad[ix]) || PadnamePV(names[ix])) {
d2419 1
a2419 2
		} else if (names_fill >= ix && names[ix] &&
			   PadnameLEN(names[ix])) {
d2448 1
a2448 3
		else if (IS_PADGV(oldpad[ix])
		      || (  names_fill >= ix && names[ix]
			 && PadnamePV(names[ix])  )) {
@


1.1.1.11
log
@Import perl-5.20.2
@
text
@d59 1
a59 2
items.  Pad slots for targets (SVs_PADTMP)
and GVs end up having &PL_sv_undef
@


1.1.1.12
log
@Import perl-5.24.2
@
text
@d41 1
a41 1
XSUBs do not have a C<CvPADLIST>.  C<dXSTARG> fetches values from C<PL_curpad>,
d43 1
a43 3
every entersub). Do not get or set C<CvPADLIST> if a CV is an XSUB (as
determined by C<CvISXSUB()>), C<CvPADLIST> slot is reused for a different
internal purpose in XSUBs.
d47 2
a48 2
The 0th entry of the PADLIST is a PADNAMELIST
which represents the "names" or rather
d50 1
a50 1
PADNAMELIST are PADNAMEs.  Future
d56 1
a56 1
AV which is C<@@_>.  Other entries are storage for variables and op targets.
d59 5
a63 7
items.  Pad slots for targets (C<SVs_PADTMP>)
and GVs end up having &PL_padname_undef "names", while slots for constants 
have C<&PL_padname_const> "names" (see C<L</pad_alloc>>).  That
C<&PL_padname_undef>
and C<&PL_padname_const> are used is an implementation detail subject to
change.  To test for them, use C<!PadnamePV(name)> and
S<C<PadnamePV(name) && !PadnameLEN(name)>>, respectively.
d65 1
a65 1
Only C<my>/C<our> variable slots get valid names.
d69 1
a69 1
C<my>/C<our> variables can be.  Since they can't be looked up by "name"
d71 1
a71 1
in C<PL_op->op_targ>), wasting a name SV for them doesn't make sense.
d73 4
a76 4
The pad names in the PADNAMELIST have their PV holding the name of
the variable.  The C<COP_SEQ_RANGE_LOW> and C<_HIGH> fields form a range
(low+1..high inclusive) of cop_seq numbers for which the name is
valid.  During compilation, these fields may hold the special value
d79 17
a95 20
 COP_SEQ_RANGE_LOW        _HIGH
 -----------------        -----
 PERL_PADSEQ_INTRO            0   variable not yet introduced:
                                  { my ($x
 valid-seq#   PERL_PADSEQ_INTRO   variable in scope:
                                  { my ($x)
 valid-seq#          valid-seq#   compilation of scope complete:
                                  { my ($x) }

For typed lexicals C<PadnameTYPE> points at the type stash.  For C<our>
lexicals, C<PadnameOURSTASH> points at the stash of the associated global (so
that duplicate C<our> declarations in the same package can be detected).
C<PadnameGEN> is sometimes used to store the generation number during
compilation.

If C<PadnameOUTER> is set on the pad name, then that slot in the frame AV
is a REFCNT'ed reference to a lexical from "outside".  Such entries
are sometimes referred to as 'fake'.  In this case, the name does not
use 'low' and 'high' to store a cop_seq range, since it is in scope
throughout.  Instead 'high' stores some flags containing info about
d97 1
a97 1
instantiated multiple times?), and for fake ANONs, 'low' contains the index
d101 1
a101 1
If the 'name' is C<&> the corresponding entry in the PAD
d103 3
d110 1
a110 1
The flag C<SVs_PADSTALE> is cleared on lexicals each time the C<my()> is executed,
d112 1
a112 1
C<"Variable $x is not available"> warning
d117 1
a117 2
For state vars, C<SVs_PADSTALE> is overloaded to mean 'not yet initialised',
but this internal state is stored in a separate pad entry.
d147 1
a147 1
  STMT_START { (sv)->xpadn_low = (val); } STMT_END
d149 1
a149 1
  STMT_START { (sv)->xpadn_high = (val); } STMT_END
d151 4
a154 2
#define PARENT_PAD_INDEX_set		COP_SEQ_RANGE_LOW_set
#define PARENT_FAKELEX_FLAGS_set	COP_SEQ_RANGE_HIGH_set
d156 19
a174 13
#ifdef DEBUGGING
void
Perl_set_padlist(CV * cv, PADLIST *padlist){
    PERL_ARGS_ASSERT_SET_PADLIST;
#  if PTRSIZE == 8
    assert((Size_t)padlist != UINT64_C(0xEFEFEFEFEFEFEFEF));
#  elif PTRSIZE == 4
    assert((Size_t)padlist != 0xEFEFEFEF);
#  else
#    error unknown pointer size
#  endif
    assert(!CvISXSUB(cv));
    ((XPVCV*)MUTABLE_PTR(SvANY(cv)))->xcv_padlist_u.xcv_padlist = padlist;
d179 41
d236 1
d238 1
a238 2
    PADNAMELIST *padname;
    PAD *pad;
a255 1
	    SAVEI32(PL_constpadix);
d283 1
a283 1
	PadnamelistREFCNT(padname = PL_comppad_name)++;
a285 1
	padlist->xpadl_id = PL_padlist_generation++;
d287 3
a289 2
	padname = newPADNAMELIST(0);
	padnamelist_store(padname, 0, &PL_padname_undef);
d299 1
a299 1
    ary[0] = (PAD *)padname;
a311 1
	PL_constpadix	     = 0;
d334 1
a334 1
In the former case, we keep the C<CvOUTSIDE> pointer, so that any anonymous
d343 4
a347 12
    cv_undef_flags(cv, 0);
}

void
Perl_cv_undef_flags(pTHX_ CV *cv, U32 flags)
{
    CV cvbody;/*CV body will never be realloced inside this func,
               so dont read it more than once, use fake CV so existing macros
               will work, the indirection and CV head struct optimized away*/
    SvANY(&cvbody) = SvANY(cv);

    PERL_ARGS_ASSERT_CV_UNDEF_FLAGS;
d354 28
a381 36
    if (CvFILE(&cvbody)) {
	char * file = CvFILE(&cvbody);
	CvFILE(&cvbody) = NULL;
	if(CvDYNFILE(&cvbody))
	    Safefree(file);
    }

    /* CvSLABBED_off(&cvbody); *//* turned off below */
    /* release the sub's body */
    if (!CvISXSUB(&cvbody)) {
        if(CvROOT(&cvbody)) {
            assert(SvTYPE(cv) == SVt_PVCV || SvTYPE(cv) == SVt_PVFM); /*unsafe is safe */
            if (CvDEPTHunsafe(&cvbody)) {
                assert(SvTYPE(cv) == SVt_PVCV);
                Perl_croak_nocontext("Can't undef active subroutine");
            }
            ENTER;

            PAD_SAVE_SETNULLPAD();

            if (CvSLABBED(&cvbody)) OpslabREFCNT_dec_padok(OpSLAB(CvROOT(&cvbody)));
            op_free(CvROOT(&cvbody));
            CvROOT(&cvbody) = NULL;
            CvSTART(&cvbody) = NULL;
            LEAVE;
        }
	else if (CvSLABBED(&cvbody)) {
            if( CvSTART(&cvbody)) {
                ENTER;
                PAD_SAVE_SETNULLPAD();

                /* discard any leaked ops */
                if (PL_parser)
                    parser_free_nexttoke_ops(PL_parser, (OPSLAB *)CvSTART(&cvbody));
                opslab_force_free((OPSLAB *)CvSTART(&cvbody));
                CvSTART(&cvbody) = NULL;
d383 2
a384 2
                LEAVE;
            }
d386 1
a386 1
            else Perl_warn(aTHX_ "Slab leaked from cv %p", (void*)cv);
a387 5
        }
    }
    else { /* dont bother checking if CvXSUB(cv) is true, less branching */
	CvXSUB(&cvbody) = NULL;
    }
d390 2
a391 7
    if (!(flags & CV_UNDEF_KEEP_NAME)) {
	if (CvNAMED(&cvbody)) {
	    CvNAME_HEK_set(&cvbody, NULL);
	    CvNAMED_off(&cvbody);
	}
	else CvGV_set(cv, NULL);
    }
d396 1
a396 1
    if (!CvISXSUB(&cvbody) && CvPADLIST(&cvbody)) {
a397 1
	const PADLIST *padlist = CvPADLIST(&cvbody);
d417 4
a420 4
	    CV * const outercv = CvOUTSIDE(&cvbody);
	    const U32 seq = CvOUTSIDE_SEQ(&cvbody);
	    PADNAMELIST * const comppad_name = PadlistNAMES(padlist);
	    PADNAME ** const namepad = PadnamelistARRAY(comppad_name);
d423 4
a426 3
	    for (ix = PadnamelistMAX(comppad_name); ix > 0; ix--) {
		PADNAME * const name = namepad[ix];
		if (name && PadnamePV(name) && *PadnamePV(name) == '&')
d440 1
a440 3
			if (inner_rc && SvTYPE(innercv) == SVt_PVCV
			 && (CvOUTSIDE(innercv) == cv))
			{
d469 2
a470 2
	    PADNAMELIST * const names = PadlistNAMES(padlist);
	    if (names == PL_comppad_name && PadnamelistREFCNT(names) == 1)
d472 1
a472 1
	    PadnamelistREFCNT_dec(names);
d476 1
a476 1
	CvPADLIST_set(&cvbody, NULL);
a477 3
    else if (CvISXSUB(&cvbody))
	CvHSCXT(&cvbody) = NULL;
    /* else is (!CvISXSUB(&cvbody) && !CvPADLIST(&cvbody)) {do nothing;} */
d481 8
a488 7
    if (!SvREFCNT(cv)) {
	CV * outside = CvOUTSIDE(&cvbody);
	if(outside) {
	    CvOUTSIDE(&cvbody) = NULL;
	    if (!CvWEAKOUTSIDE(&cvbody))
		SvREFCNT_dec_NN(outside);
	}
d490 2
a491 3
    if (CvCONST(&cvbody)) {
	SvREFCNT_dec(MUTABLE_SV(CvXSUBANY(&cvbody).any_ptr));
	/* CvCONST_off(cv); *//* turned off below */
d494 3
a496 4
     * ref status of CvOUTSIDE and CvGV, and ANON, NAMED and
     * LEXICAL, which are used to determine the sub's name.  */
    CvFLAGS(&cvbody) &= (CVf_WEAKOUTSIDE|CVf_CVGV_RC|CVf_ANON|CVf_LEXICAL
		   |CVf_NAMED);
d502 1
a502 1
When a CV has a reference count on its slab (C<CvSLABBED>), it is responsible
d505 1
a505 1
during compilation.  Once it is compiled and C<CvROOT> attached, it has
d514 1
a514 1
    bool slabbed;
d517 2
a518 3
    if (!cv)
        return;
    slabbed = cBOOL(CvSLABBED(cv));
d526 1
a526 1
    else if (slabbed)     Perl_warn(aTHX_ "Slab leaked from cv %p", (void*)cv);
d541 1
a541 1
=for apidoc m|PADOFFSET|pad_alloc_name|PADNAME *name|U32 flags|HV *typestash|HV *ourstash
d545 4
a548 4
then stores a name for that entry.  C<name> is adopted and
becomes the name entry; it must already contain the name
string.  C<typestash> and C<ourstash> and the C<padadd_STATE>
flag get added to C<name>.  None of the other
d556 1
a556 2
S_pad_alloc_name(pTHX_ PADNAME *name, U32 flags, HV *typestash,
		       HV *ourstash)
d558 1
d566 3
a568 3
	SvPAD_TYPED_on(name);
	PadnameTYPE(name) =
	    MUTABLE_HV(SvREFCNT_inc_simple_NN(MUTABLE_SV(typestash)));
d571 2
a572 2
	SvPAD_OUR_on(name);
	SvOURSTASH_set(name, ourstash);
d576 1
a576 1
	SvPAD_STATE_on(name);
d579 2
a580 3
    padnamelist_store(PL_comppad_name, offset, name);
    if (PadnameLEN(name) > 1)
	PadnamelistMAXNAMED(PL_comppad_name) = offset;
d592 3
a594 3
C<namepv>/C<namelen> specify the variable's name, including leading sigil.
If C<typestash> is non-null, the name is for a typed lexical, and this
identifies the type.  If C<ourstash> is non-null, it's a lexical reference
d598 3
a600 3
 padadd_OUR          redundantly specifies if it's a package var
 padadd_STATE        variable will retain value persistently
 padadd_NO_DUP_CHECK skip check for lexical shadowing
d609 1
d611 2
a612 1
    PADNAME *name;
d616 1
a616 1
    if (flags & ~(padadd_OUR|padadd_STATE|padadd_NO_DUP_CHECK))
d620 14
a633 1
    name = newPADNAMEpvn(namepv, namelen);
d637 1
a637 1
	SAVEFREEPADNAME(name); /* in case of fatal warnings */
d639 2
a640 2
	pad_check_dup(name, flags & padadd_OUR, ourstash);
	PadnameREFCNT(name)++;
d644 1
a644 1
    offset = pad_alloc_name(name, flags, typestash, ourstash);
d647 2
a648 2
    COP_SEQ_RANGE_LOW_set(name, PERL_PADSEQ_INTRO);
    COP_SEQ_RANGE_HIGH_set(name, 0);
d665 1
a665 1
			   (long)offset, PadnamePV(name),
d703 3
a705 1
    namepv = SvPVutf8(name, namelen);
d715 1
a715 1
C<tmptype> is a set of flags indicating the kind of pad entry required,
d728 1
a728 1
C<optype> should be an opcode indicating the type of operation that the
d741 1
d753 1
a753 1
    if (tmptype == SVs_PADMY) { /* Not & because this ‘flag’ is 0.  */
a760 1
	 * For a constant, likewise, but use PL_constpadix.
d762 2
a763 4
	PADNAME * const * const names = PadnamelistARRAY(PL_comppad_name);
	const SSize_t names_fill = PadnamelistMAX(PL_comppad_name);
	const bool konst = cBOOL(tmptype & SVf_READONLY);
	retval = konst ? PL_constpadix : PL_padix;
a769 4
	     * If pad_reset is enabled, ‘current’ means different
	     * things depending on whether we are allocating a con-
	     * stant or a target.  For a target, things marked PADTMP
	     * can be reused; not so for constants.
d771 2
a772 3
	    PADNAME *pn;
	    if (++retval <= names_fill &&
		   (pn = names[retval]) && PadnamePV(pn))
d774 3
a776 8
	    sv = *av_fetch(PL_comppad, retval, TRUE);
	    if (!(SvFLAGS(sv) &
#ifdef USE_PAD_RESET
		    (konst ? SVs_PADTMP : 0))
#else
		    SVs_PADTMP
#endif
		 ))
d779 2
a780 2
	if (konst) {
	    padnamelist_store(PL_comppad_name, retval, &PL_padname_const);
d784 1
a784 1
	*(konst ? &PL_constpadix : &PL_padix) = retval;
d806 1
a806 1
The function C<func> is linked into the pad, and its C<CvOUTSIDE> link
d811 1
a811 1
C<optype> should be an opcode indicating the type of operation that the
d821 1
d823 1
a823 1
    PADNAME * const name = newPADNAMEpvn("&", 1);
a825 1
    assert (SvTYPE(func) == SVt_PVCV);
d828 1
d830 3
a832 3
     * PERL_PADSEQ_INTRO.  They should be 0 by default.  */
    assert(COP_SEQ_RANGE_LOW (name) != PERL_PADSEQ_INTRO);
    assert(COP_SEQ_RANGE_HIGH(name) != PERL_PADSEQ_INTRO);
d834 1
a834 1
    padnamelist_store(PL_comppad_name, ix, name);
d836 9
a844 1
    av_store(PL_comppad, ix, (SV*)func);
d848 1
a848 1
    if (CvOUTSIDE(func)) {
a855 18
void
Perl_pad_add_weakref(pTHX_ CV* func)
{
    const PADOFFSET ix = pad_alloc(OP_NULL, SVs_PADMY);
    PADNAME * const name = newPADNAMEpvn("&", 1);
    SV * const rv = newRV_inc((SV *)func);

    PERL_ARGS_ASSERT_PAD_ADD_WEAKREF;

    /* These two aren't used; just make sure they're not equal to
     * PERL_PADSEQ_INTRO.  They should be 0 by default.  */
    assert(COP_SEQ_RANGE_LOW (name) != PERL_PADSEQ_INTRO);
    assert(COP_SEQ_RANGE_HIGH(name) != PERL_PADSEQ_INTRO);
    padnamelist_store(PL_comppad_name, ix, name);
    sv_rvweaken(rv);
    av_store(PL_comppad, ix, rv);
}

d861 3
a863 3
     * a 'my' in the current scope with the same name;
     * an 'our' (anywhere in the pad) with the same name and the
       same stash as 'ourstash'
d865 1
a865 1
C<is_our> indicates that the name to check is an C<"our"> declaration.
d871 1
a871 1
S_pad_check_dup(pTHX_ PADNAME *name, U32 flags, const HV *ourstash)
d873 2
a874 1
    PADNAME	**svp;
d884 1
a884 1
    if (PadnamelistMAX(PL_comppad_name) < 0 || !ckWARN(WARN_MISC))
d887 2
a888 2
    svp = PadnamelistARRAY(PL_comppad_name);
    top = PadnamelistMAX(PL_comppad_name);
d893 1
a893 1
	PADNAME * const sv = svp[off];
d895 2
a896 2
	    && PadnameLEN(sv) == PadnameLEN(name)
	    && !PadnameOUTER(sv)
d899 1
a899 1
	    && memEQ(PadnamePV(sv), PadnamePV(name), PadnameLEN(name)))
d905 1
a905 1
		"\"%s\" %s %"PNf" masks earlier declaration in same %s",
d907 2
a908 2
		*PadnamePV(sv) == '&' ? "subroutine" : "variable",
		PNfARG(sv),
d918 1
a918 1
	    PADNAME * const sv = svp[off];
d920 2
a921 2
		&& PadnameLEN(sv) == PadnameLEN(name)
		&& !PadnameOUTER(sv)
d925 1
a925 1
		&& memEQ(PadnamePV(sv), PadnamePV(name), PadnameLEN(name)))
d928 1
a928 1
		    "\"our\" variable %"PNf" redeclared", PNfARG(sv));
d945 2
a946 2
C<namepv>/C<namelen> specify the variable's name, including leading sigil.
C<flags> is reserved and must be zero.
d958 2
a959 1
    PADNAME *out_pn;
d962 2
a963 2
    const PADNAMELIST *namelist;
    PADNAME **name_p;
d969 1
a969 1
    if (flags)
d973 9
a981 3
    /* compilation errors can zero PL_compcv */
    if (!PL_compcv)
        return NOT_IN_PAD;
d984 1
a984 1
                PL_compcv, PL_cop_seqmax, 1, NULL, &out_pn, &out_flags);
a987 4
    /* Skip the ‘our’ hack for subroutines, as the warning does not apply.
     */
    if (*namepv == '&') return NOT_IN_PAD;

d992 10
a1001 10
    namelist = PadlistNAMES(CvPADLIST(PL_compcv));
    name_p = PadnamelistARRAY(namelist);
    for (offset = PadnamelistMAXNAMED(namelist); offset > 0; offset--) {
        const PADNAME * const name = name_p[offset];
        if (name && PadnameLEN(name) == namelen
            && !PadnameOUTER(name)
            && (PadnameIsOUR(name))
            && (  PadnamePV(name) == namepv
               || memEQ(PadnamePV(name), namepv, namelen)  )
            && COP_SEQ_RANGE_LOW(name) == PERL_PADSEQ_INTRO
d1039 3
a1041 1
    namepv = SvPVutf8(name, namelen);
d1048 5
a1052 6
Until the lexical C<$_> feature was removed, this function would
find the position of the lexical C<$_> in the pad of the
currently-executing function and returns the offset in the current pad,
or C<NOT_IN_PAD>.

Now it always returns C<NOT_IN_PAD>.
d1060 5
a1064 2
    PERL_UNUSED_CONTEXT; /* Can we just remove the pTHX from the sig? */
    return NOT_IN_PAD;
d1070 3
a1072 1
Returns the global variable C<$_>.
d1080 29
a1108 1
    return DEFSV;
d1112 1
a1112 1
=for apidoc m|PADOFFSET|pad_findlex|const char *namepv|STRLEN namelen|U32 flags|const CV* cv|U32 seq|int warn|SV** out_capture|PADNAME** out_name|int *out_flags
d1118 2
a1119 2
C<cv> is the CV in which to start the search, and seq is the current C<cop_seq>
to match against.  If C<warn> is true, print appropriate warnings.  The C<out_>*
d1121 4
a1124 4
should be stored.  C<out_capture>, if non-null, requests that the innermost
instance of the lexical is captured; C<out_name> is set to the innermost
matched pad name or fake pad name; C<out_flags> returns the flags normally
associated with the C<PARENT_FAKELEX_FLAGS> field of a fake pad name.
d1126 1
a1126 1
Note that C<pad_findlex()> is recursive; it recurses up the chain of CVs,
d1129 1
a1129 1
because fake names in anon protoypes have to store in C<xlow> the index into
d1143 1
a1143 1
S_unavailable(pTHX_ PADNAME *name)
d1147 2
a1148 2
			"%se \"%"PNf"\" is not available",
			 *PadnamePV(name) == '&'
d1151 1
a1151 1
			 PNfARG(name));
d1156 1
a1156 1
	int warn, SV** out_capture, PADNAME** out_name, int *out_flags)
d1158 1
d1167 1
a1167 2
    flags &= ~ padadd_STALEOK; /* one-shot flag */
    if (flags)
d1170 1
d1183 2
a1184 2
        const PADNAMELIST * const names = PadlistNAMES(padlist);
	PADNAME * const * const name_p = PadnamelistARRAY(names);
d1186 5
a1190 5
	for (offset = PadnamelistMAXNAMED(names); offset > 0; offset--) {
            const PADNAME * const name = name_p[offset];
            if (name && PadnameLEN(name) == namelen
                     && (  PadnamePV(name) == namepv
                        || memEQ(PadnamePV(name), namepv, namelen)  ))
d1192 1
a1192 1
		if (PadnameOUTER(name)) {
d1196 25
a1220 2
		if (PadnameIN_SCOPE(name, seq))
		    break;
d1227 1
a1227 1
		*out_name = name_p[offset]; /* return the name */
d1244 2
a1245 2
		    (unsigned long)COP_SEQ_RANGE_LOW(*out_name),
		    (unsigned long)COP_SEQ_RANGE_HIGH(*out_name)));
d1249 2
a1250 2
		*out_name = name_p[offset]; /* return the name */
		*out_flags = PARENT_FAKELEX_FLAGS(*out_name);
d1254 1
a1254 1
		    (unsigned long) PARENT_PAD_INDEX(*out_name) 
d1263 1
a1263 1
		if (PadnameIsOUR(*out_name)) {
d1275 3
a1277 1
				      *out_name);
d1286 1
a1286 1
			 && !PadnameIsSTATE(name_p[offset])
a1288 2
			/* diag_listed_as: Variable "%s" will not stay
					   shared */
d1290 4
a1293 3
			    "%se \"%"UTF8f"\" will not stay shared",
			     *namepv == '&' ? "Subroutin" : "Variabl",
			     UTF8fARG(1, namelen, namepv));
d1299 1
a1299 1
			PADNAME *n;
d1304 1
a1304 1
			n = *out_name;
d1307 2
a1308 2
			    newwarn, out_capture, out_name, out_flags);
			*out_name = n;
d1320 1
a1320 1
			&& !PadnameIsSTATE(name_p[offset]))
d1323 3
a1325 1
				      name_p[offset]);
d1358 1
a1358 1
		new_capturep, out_name, out_flags);
d1370 6
a1375 2
	PADNAME *new_name = newPADNAMEouter(*out_name);
	PADNAMELIST * const ocomppad_name = PL_comppad_name;
d1377 1
a1377 1
	PL_comppad_name = PadlistNAMES(padlist);
d1382 5
a1386 4
	    = pad_alloc_name(new_name,
			      PadnameIsSTATE(*out_name) ? padadd_STATE : 0,
			      PadnameTYPE(*out_name),
			      PadnameOURSTASH(*out_name)
d1389 1
d1393 2
a1394 3
			       (int) PadnameLEN(new_name),
			       PadnamePV(new_name)));
	PARENT_FAKELEX_FLAGS_set(new_name, *out_flags);
d1396 2
a1397 2
	PARENT_PAD_INDEX_set(new_name, 0);
	if (PadnameIsOUR(new_name)) {
d1402 1
a1402 1
	    PARENT_PAD_INDEX_set(new_name, offset);
d1409 1
a1409 1
	    PARENT_PAD_INDEX_set(new_name, offset);
d1414 2
a1415 2
	*out_name = new_name;
	*out_flags = PARENT_FAKELEX_FLAGS(new_name);
d1429 2
a1430 2
Get the value at offset C<po> in the current (compiling or executing) pad.
Use macro C<PAD_SV> instead of calling this function directly.
d1438 1
d1453 2
a1454 2
Set the value at offset C<po> in the current (compiling or executing) pad.
Use the macro C<PAD_SETSV()> rather than calling this function directly.
d1462 2
d1494 1
d1497 1
a1497 1
    PL_comppad_name_floor = PadnamelistMAX(PL_comppad_name);
a1506 6
    /* PL_padix_floor is what PL_padix is reset to at the start of each
       statement, by pad_reset().  We set it when entering a new scope
       to keep things like this working:
	    print "$foo$bar", do { this(); that() . "foo" };
       We must not let "$foo$bar" and the later concatenation share the
       same target.  */
d1512 1
a1512 1
=for apidoc Am|U32|intro_my
d1514 3
a1516 3
"Introduce" C<my> variables to visible status.  This is called during parsing
at the end of each statement to make lexical variables visible to subsequent
statements.
d1524 2
a1525 1
    PADNAME **svp;
a1529 6
    if (PL_compiling.cop_seq) {
	seq = PL_compiling.cop_seq;
	PL_compiling.cop_seq = 0;
    }
    else
	seq = PL_cop_seqmax;
d1531 1
a1531 1
	return seq;
d1533 1
a1533 1
    svp = PadnamelistARRAY(PL_comppad_name);
d1535 1
a1535 1
	PADNAME * const sv = svp[i];
d1537 1
a1537 1
	if (sv && PadnameLEN(sv) && !PadnameOUTER(sv)
d1544 1
a1544 1
		(long)i, PadnamePV(sv),
d1550 4
a1553 1
    COP_SEQMAX_INC;
d1574 1
d1577 1
a1577 1
    PADNAME * const * const svp = PadnamelistARRAY(PL_comppad_name);
d1584 2
a1585 2
	    const PADNAME * const name = svp[off];
	    if (name && PadnameLEN(name) && !PadnameOUTER(name))
d1587 2
a1588 2
				      "%"PNf" never introduced",
				       PNfARG(name));
d1592 3
a1594 4
    for (off = PadnamelistMAX(PL_comppad_name);
	 off > PL_comppad_name_fill; off--) {
	PADNAME * const sv = svp[off];
	if (sv && PadnameLEN(sv) && !PadnameOUTER(sv)
d1600 1
a1600 1
		(long)off, PadnamePV(sv),
d1612 3
a1614 1
    COP_SEQMAX_INC;
d1623 1
a1623 1
Abandon the tmp in the current pad at offset C<po> and replace with a
d1632 1
d1653 1
a1653 1
#ifdef USE_PAD_RESET
d1664 1
a1664 1
	PadnamelistARRAY(PL_comppad_name)[po] = &PL_padname_undef;
d1666 2
a1667 5
    /* Use PL_constpadix here, not PL_padix.  The latter may have been
       reset by pad_reset.  We don’t want pad_alloc to have to scan the
       whole pad when allocating a constant. */
    if ((I32)po < PL_constpadix)
	PL_constpadix = po - 1;
d1678 6
a1683 5
/* pad_reset() causes pad temp TARGs (operator targets) to be shared
 * between OPs from different statements.  During compilation, at the start
 * of each statement pad_reset resets PL_padix back to its previous value.
 * When allocating a target, pad_alloc begins its scan through the pad at
 * PL_padix+1.  */
d1687 2
a1688 1
#ifdef USE_PAD_RESET
d1701 5
d1717 1
a1717 1
prototypes; give it a C<@@_>; mark temporaries as such.  C<type> indicates
d1771 2
a1772 2
    if (PadnamelistMAX(PL_comppad_name) < AvFILLp(PL_comppad))
	padnamelist_store(PL_comppad_name, AvFILLp(PL_comppad), NULL);
d1775 1
a1775 1
	PADNAME ** const namep = PadnamelistARRAY(PL_comppad_name);
d1779 2
a1780 2
	    PADNAME *namesv;
	    if (!namep[ix]) namep[ix] = &PL_padname_undef;
d1787 2
a1788 1
	    if (!PL_curpad[ix] || SvIMMORTAL(PL_curpad[ix]))
d1792 1
a1792 1
		   (!PadnameLEN(namesv) || *PadnamePV(namesv) == '&')))
d1807 1
a1807 1
	PADNAME ** const namep = PadnamelistARRAY(PL_comppad_name);
d1810 3
a1812 2
	    if (!namep[ix]) namep[ix] = &PL_padname_undef;
	    if (!PL_curpad[ix] || SvIMMORTAL(PL_curpad[ix]))
d1814 3
a1816 1
	    if (SvPADMY(PL_curpad[ix]) && !PadnameOUTER(namep[ix])) {
d1852 1
a1852 1
#ifndef USE_PAD_RESET
a1853 1
#endif
d1868 1
a1868 1
#ifndef USE_PAD_RESET
a1874 1
#endif
d1888 2
a1889 1
    const PADNAMELIST *pad_name;
d1891 1
a1891 1
    PADNAME **pname;
d1900 1
a1900 1
    pad_name = PadlistNAMES(padlist);
d1902 1
a1902 1
    pname = PadnamelistARRAY(pad_name);
d1909 2
a1910 2
    for (ix = 1; ix <= PadnamelistMAX(pad_name); ix++) {
        const PADNAME *namesv = pname[ix];
d1915 1
a1915 1
	    if (PadnameOUTER(namesv))
d1921 1
a1921 1
		    PadnamePV(namesv),
d1934 1
a1934 1
		    PadnamePV(namesv)
d1961 1
d1993 1
a1993 1
Clone a CV, making a lexical closure.  C<proto> supplies the prototype
d2002 1
a2002 1
static CV *S_cv_clone(pTHX_ CV *proto, CV *cv, CV *outside, HV *cloned);
d2004 2
a2005 3
static CV *
S_cv_clone_pad(pTHX_ CV *proto, CV *cv, CV *outside, HV *cloned,
		     bool newcv)
d2007 1
d2010 1
a2010 1
    PADNAMELIST *const protopad_name = PadlistNAMES(protopadlist);
d2012 1
a2012 1
    PADNAME** const pname = PadnamelistARRAY(protopad_name);
d2014 1
a2014 1
    const I32 fname = PadnamelistMAX(protopad_name);
d2018 1
a2018 2
    U32 subclones = 0;
    bool trouble = FALSE;
d2039 2
a2040 1
	    || CvPADLIST(outside)->xpadl_id != protopadlist->xpadl_outid) {
d2062 1
a2062 2
    CvPADLIST_set(cv, pad_new(padnew_CLONE|padnew_SAVE));
    CvPADLIST(cv)->xpadl_id = protopadlist->xpadl_id;
d2071 2
a2072 1
    if (outpad) CvPADLIST(cv)->xpadl_outid = CvPADLIST(outside)->xpadl_id;
d2075 1
a2075 1
	PADNAME* const namesv = (ix <= fname) ? pname[ix] : NULL;
d2082 1
a2082 1
	    if (PadnameOUTER(namesv)) {   /* lexical from outside? */
d2095 1
a2095 1
                const char sigil = PadnamePV(namesv)[0];
d2106 1
a2106 3
			subclones ++;
			if (CvOUTSIDE(ppad[ix]) != proto)
			     trouble = TRUE;
a2107 1
			CvLEXICAL_on(sv);
a2113 4
                        dVAR;
			U32 hash;
			PERL_HASH(hash, PadnamePV(namesv)+1,
				  PadnameLEN(namesv) - 1);
d2117 4
a2120 3
			    share_hek(PadnamePV(namesv)+1,
				      1 - PadnameLEN(namesv),
				      hash)
a2121 1
			CvLEXICAL_on(sv);
d2130 1
d2137 1
a2137 1
	else if (namesv && PadnamePV(namesv)) {
d2148 5
a2152 62
    {
	if (trouble || cloned) {
	    /* Uh-oh, we have trouble!  At least one of the state subs here
	       has its CvOUTSIDE pointer pointing somewhere unexpected.  It
	       could be pointing to another state protosub that we are
	       about to clone.  So we have to track which sub clones come
	       from which protosubs.  If the CvOUTSIDE pointer for a parti-
	       cular sub points to something we have not cloned yet, we
	       delay cloning it.  We must loop through the pad entries,
	       until we get a full pass with no cloning.  If any uncloned
	       subs remain (probably nested inside anonymous or ‘my’ subs),
	       then they get cloned in a final pass.
	     */
	    bool cloned_in_this_pass;
	    if (!cloned)
		cloned = (HV *)sv_2mortal((SV *)newHV());
	    do {
		cloned_in_this_pass = FALSE;
		for (ix = fpad; ix > 0; ix--) {
		    PADNAME * const name =
			(ix <= fname) ? pname[ix] : NULL;
		    if (name && name != &PL_padname_undef
		     && !PadnameOUTER(name) && PadnamePV(name)[0] == '&'
		     && PadnameIsSTATE(name) && !CvCLONED(PL_curpad[ix]))
		    {
			CV * const protokey = CvOUTSIDE(ppad[ix]);
			CV ** const cvp = protokey == proto
			    ? &cv
			    : (CV **)hv_fetch(cloned, (char *)&protokey,
					      sizeof(CV *), 0);
			if (cvp && *cvp) {
			    S_cv_clone(aTHX_ (CV *)ppad[ix],
					     (CV *)PL_curpad[ix],
					     *cvp, cloned);
			    (void)hv_store(cloned, (char *)&ppad[ix],
				     sizeof(CV *),
				     SvREFCNT_inc_simple_NN(PL_curpad[ix]),
				     0);
			    subclones--;
			    cloned_in_this_pass = TRUE;
			}
		    }
		}
	    } while (cloned_in_this_pass);
	    if (subclones)
		for (ix = fpad; ix > 0; ix--) {
		    PADNAME * const name =
			(ix <= fname) ? pname[ix] : NULL;
		    if (name && name != &PL_padname_undef
		     && !PadnameOUTER(name) && PadnamePV(name)[0] == '&'
		     && PadnameIsSTATE(name) && !CvCLONED(PL_curpad[ix]))
			S_cv_clone(aTHX_ (CV *)ppad[ix],
					 (CV *)PL_curpad[ix],
					 CvOUTSIDE(ppad[ix]), cloned);
		}
	}
	else for (ix = fpad; ix > 0; ix--) {
	    PADNAME * const name = (ix <= fname) ? pname[ix] : NULL;
	    if (name && name != &PL_padname_undef && !PadnameOUTER(name)
	     && PadnamePV(name)[0] == '&' && PadnameIsSTATE(name))
		S_cv_clone(aTHX_ (CV *)ppad[ix], (CV *)PL_curpad[ix], cv,
				 NULL);
a2153 1
    }
a2156 86

    if (CvCONST(cv)) {
	/* Constant sub () { $x } closing over $x:
	 * The prototype was marked as a candiate for const-ization,
	 * so try to grab the current const value, and if successful,
	 * turn into a const sub:
	 */
	SV* const_sv;
	OP *o = CvSTART(cv);
	assert(newcv);
	for (; o; o = o->op_next)
	    if (o->op_type == OP_PADSV)
		break;
	ASSUME(o->op_type == OP_PADSV);
	const_sv = PAD_BASE_SV(CvPADLIST(cv), o->op_targ);
	/* the candidate should have 1 ref from this pad and 1 ref
	 * from the parent */
	if (const_sv && SvREFCNT(const_sv) == 2) {
	    const bool was_method = cBOOL(CvMETHOD(cv));
	    bool copied = FALSE;
	    if (outside) {
		PADNAME * const pn =
		    PadlistNAMESARRAY(CvPADLIST(outside))
			[PARENT_PAD_INDEX(PadlistNAMESARRAY(
			    CvPADLIST(cv))[o->op_targ])];
		assert(PadnameOUTER(PadlistNAMESARRAY(CvPADLIST(cv))
					[o->op_targ]));
		if (PadnameLVALUE(pn)) {
		    /* We have a lexical that is potentially modifiable
		       elsewhere, so making a constant will break clo-
		       sure behaviour.  If this is a ‘simple lexical
		       op tree’, i.e., sub(){$x}, emit a deprecation
		       warning, but continue to exhibit the old behav-
		       iour of making it a constant based on the ref-
		       count of the candidate variable.

		       A simple lexical op tree looks like this:

		         leavesub
			   lineseq
			     nextstate
			     padsv
		     */
		    if (OpSIBLING(
			 cUNOPx(cUNOPx(CvROOT(cv))->op_first)->op_first
			) == o
		     && !OpSIBLING(o))
		    {
			Perl_ck_warner_d(aTHX_
					  packWARN(WARN_DEPRECATED),
					 "Constants from lexical "
					 "variables potentially "
					 "modified elsewhere are "
					 "deprecated");
			/* We *copy* the lexical variable, and donate the
			   copy to newCONSTSUB.  Yes, this is ugly, and
			   should be killed.  We need to do this for the
			   time being, however, because turning on SvPADTMP
			   on a lexical will have observable effects
			   elsewhere.  */
			const_sv = newSVsv(const_sv);
			copied = TRUE;
		    }
		    else
			goto constoff;
		}
	    }
	    if (!copied)
		SvREFCNT_inc_simple_void_NN(const_sv);
	    /* If the lexical is not used elsewhere, it is safe to turn on
	       SvPADTMP, since it is only when it is used in lvalue con-
	       text that the difference is observable.  */
	    SvREADONLY_on(const_sv);
	    SvPADTMP_on(const_sv);
	    SvREFCNT_dec_NN(cv);
	    cv = newCONSTSUB(CvSTASH(proto), NULL, const_sv);
	    if (was_method)
		CvMETHOD_on(cv);
	}
	else {
	  constoff:
	    CvCONST_off(cv);
	}
    }

    return cv;
d2160 1
a2160 1
S_cv_clone(pTHX_ CV *proto, CV *cv, CV *outside, HV *cloned)
a2161 1
#ifdef USE_ITHREADS
a2162 1
#endif
d2192 1
a2192 2
    if (CvPADLIST(proto))
	cv = S_cv_clone_pad(aTHX_ proto, cv, outside, cloned, newcv);
d2201 19
d2229 1
a2229 1
    return S_cv_clone(aTHX_ proto, NULL, NULL, NULL);
d2238 1
a2238 50
    return S_cv_clone(aTHX_ proto, target, NULL, NULL);
}

/*
=for apidoc cv_name

Returns an SV containing the name of the CV, mainly for use in error
reporting.  The CV may actually be a GV instead, in which case the returned
SV holds the GV's name.  Anything other than a GV or CV is treated as a
string already holding the sub name, but this could change in the future.

An SV may be passed as a second argument.  If so, the name will be assigned
to it and it will be returned.  Otherwise the returned SV will be a new
mortal.

If C<flags> has the C<CV_NAME_NOTQUAL> bit set, then the package name will not be
included.  If the first argument is neither a CV nor a GV, this flag is
ignored (subject to change).

=cut
*/

SV *
Perl_cv_name(pTHX_ CV *cv, SV *sv, U32 flags)
{
    PERL_ARGS_ASSERT_CV_NAME;
    if (!isGV_with_GP(cv) && SvTYPE(cv) != SVt_PVCV) {
	if (sv) sv_setsv(sv,(SV *)cv);
	return sv ? (sv) : (SV *)cv;
    }
    {
	SV * const retsv = sv ? (sv) : sv_newmortal();
    	if (SvTYPE(cv) == SVt_PVCV) {
	    if (CvNAMED(cv)) {
		if (CvLEXICAL(cv) || flags & CV_NAME_NOTQUAL)
		    sv_sethek(retsv, CvNAME_HEK(cv));
		else {
		    sv_sethek(retsv, HvNAME_HEK(CvSTASH(cv)));
		    sv_catpvs(retsv, "::");
		    sv_cathek(retsv, CvNAME_HEK(cv));
		}
	    }
	    else if (CvLEXICAL(cv) || flags & CV_NAME_NOTQUAL)
		sv_sethek(retsv, GvNAME_HEK(GvEGV(CvGV(cv))));
	    else gv_efullname3(retsv, CvGV(cv), NULL);
	}
	else if (flags & CV_NAME_NOTQUAL) sv_sethek(retsv, GvNAME_HEK(cv));
	else gv_efullname3(retsv,(GV *)cv,NULL);
	return retsv;
    }
d2244 2
a2245 2
For any anon CVs in the pad, change C<CvOUTSIDE> of that CV from
C<old_cv> to C<new_cv> if necessary.  Needed when a newly-compiled CV has to be
d2254 1
d2256 1
a2256 1
    PADNAMELIST * const comppad_name = PadlistNAMES(padlist);
d2258 1
a2258 1
    PADNAME ** const namepad = PadnamelistARRAY(comppad_name);
d2264 4
a2267 4
    for (ix = PadnamelistMAX(comppad_name); ix > 0; ix--) {
        const PADNAME *name = namepad[ix];
	if (name && name != &PL_padname_undef && !PadnameIsOUR(name)
	    && *PadnamePV(name) == '&')
d2269 6
a2274 20
	  CV *innercv = MUTABLE_CV(curpad[ix]);
	  if (UNLIKELY(PadnameOUTER(name))) {
	    CV *cv = new_cv;
	    PADNAME **names = namepad;
	    PADOFFSET i = ix;
	    while (PadnameOUTER(name)) {
		cv = CvOUTSIDE(cv);
		names = PadlistNAMESARRAY(CvPADLIST(cv));
		i = PARENT_PAD_INDEX(name);
		name = names[i];
	    }
	    innercv = (CV *)PadARRAY(PadlistARRAY(CvPADLIST(cv))[1])[i];
	  }
	  if (SvTYPE(innercv) == SVt_PVCV) {
	    /* XXX 0afba48f added code here to check for a proto CV
		   attached to the pad entry by magic.  But shortly there-
		   after 81df9f6f95 moved the magic to the pad name.  The
		   code here was never updated, so it wasn’t doing anything
		   and got deleted when PADNAME became a distinct type.  Is
		   there any bug as a result?  */
d2303 1
a2303 1
the new pad an C<@@_> in slot zero.
d2311 2
d2320 2
a2321 2
	const I32 names_fill = PadnamelistMAX((PADNAMELIST *)svp[0]);
	PADNAME ** const names = PadnamelistARRAY((PADNAMELIST *)svp[0]);
d2326 3
a2328 3
		const char sigil = PadnamePV(names[ix])[0];
		if (PadnameOUTER(names[ix])
			|| PadnameIsSTATE(names[ix])
d2343 1
d2346 1
a2346 1
	    else if (PadnamePV(names[ix])) {
d2364 21
d2406 5
a2410 1
    cloneall = cBOOL(param->flags & CLONEf_COPY_STACKS);
a2419 3
    PadlistARRAY(dstpad)[0] = (PAD *)
	    padnamelist_dup(PadlistNAMES(srcpad), param);
    PadnamelistREFCNT(PadlistNAMES(dstpad))++;
d2422 1
a2422 1
	for (depth = 1; depth <= max; ++depth)
d2430 1
a2430 1
	const I32 names_fill = PadnamelistMAX(PadlistNAMES(srcpad));
d2433 1
a2433 1
	PADNAME ** const names = PadnamelistARRAY(PadlistNAMES(dstpad));
d2437 4
d2455 3
a2457 3
		    const char sigil = PadnamePV(names[ix])[0];
		    if (PadnameOUTER(names[ix])
			|| PadnameIsSTATE(names[ix])
d2479 1
d2483 2
a2484 1
		else if ((  names_fill >= ix && names[ix]
d2496 3
a2498 1
		    if (SvPADTMP(oldpad[ix]))
d2519 1
d2541 6
a2546 251
=for apidoc newPADNAMELIST

Creates a new pad name list.  C<max> is the highest index for which space
is allocated.

=cut
*/

PADNAMELIST *
Perl_newPADNAMELIST(size_t max)
{
    PADNAMELIST *pnl;
    Newx(pnl, 1, PADNAMELIST);
    Newxz(PadnamelistARRAY(pnl), max+1, PADNAME *);
    PadnamelistMAX(pnl) = -1;
    PadnamelistREFCNT(pnl) = 1;
    PadnamelistMAXNAMED(pnl) = 0;
    pnl->xpadnl_max = max;
    return pnl;
}

/*
=for apidoc padnamelist_store

Stores the pad name (which may be null) at the given index, freeing any
existing pad name in that slot.

=cut
*/

PADNAME **
Perl_padnamelist_store(pTHX_ PADNAMELIST *pnl, SSize_t key, PADNAME *val)
{
    PADNAME **ary;

    PERL_ARGS_ASSERT_PADNAMELIST_STORE;

    assert(key >= 0);

    if (key > pnl->xpadnl_max)
	av_extend_guts(NULL,key,&pnl->xpadnl_max,
		       (SV ***)&PadnamelistARRAY(pnl),
		       (SV ***)&PadnamelistARRAY(pnl));
    if (PadnamelistMAX(pnl) < key) {
	Zero(PadnamelistARRAY(pnl)+PadnamelistMAX(pnl)+1,
	     key-PadnamelistMAX(pnl), PADNAME *);
	PadnamelistMAX(pnl) = key;
    }
    ary = PadnamelistARRAY(pnl);
    if (ary[key])
	PadnameREFCNT_dec(ary[key]);
    ary[key] = val;
    return &ary[key];
}

/*
=for apidoc padnamelist_fetch

Fetches the pad name from the given index.

=cut
*/

PADNAME *
Perl_padnamelist_fetch(PADNAMELIST *pnl, SSize_t key)
{
    PERL_ARGS_ASSERT_PADNAMELIST_FETCH;
    ASSUME(key >= 0);

    return key > PadnamelistMAX(pnl) ? NULL : PadnamelistARRAY(pnl)[key];
}

void
Perl_padnamelist_free(pTHX_ PADNAMELIST *pnl)
{
    PERL_ARGS_ASSERT_PADNAMELIST_FREE;
    if (!--PadnamelistREFCNT(pnl)) {
	while(PadnamelistMAX(pnl) >= 0)
	{
	    PADNAME * const pn =
		PadnamelistARRAY(pnl)[PadnamelistMAX(pnl)--];
	    if (pn)
		PadnameREFCNT_dec(pn);
	}
	Safefree(PadnamelistARRAY(pnl));
	Safefree(pnl);
    }
}

#if defined(USE_ITHREADS)

/*
=for apidoc padnamelist_dup

Duplicates a pad name list.

=cut
*/

PADNAMELIST *
Perl_padnamelist_dup(pTHX_ PADNAMELIST *srcpad, CLONE_PARAMS *param)
{
    PADNAMELIST *dstpad;
    SSize_t max = PadnamelistMAX(srcpad);

    PERL_ARGS_ASSERT_PADNAMELIST_DUP;

    /* look for it in the table first */
    dstpad = (PADNAMELIST *)ptr_table_fetch(PL_ptr_table, srcpad);
    if (dstpad)
	return dstpad;

    dstpad = newPADNAMELIST(max);
    PadnamelistREFCNT(dstpad) = 0; /* The caller will increment it.  */
    PadnamelistMAXNAMED(dstpad) = PadnamelistMAXNAMED(srcpad);
    PadnamelistMAX(dstpad) = max;

    ptr_table_store(PL_ptr_table, srcpad, dstpad);
    for (; max >= 0; max--)
      if (PadnamelistARRAY(srcpad)[max]) {
	PadnamelistARRAY(dstpad)[max] =
	    padname_dup(PadnamelistARRAY(srcpad)[max], param);
	PadnameREFCNT(PadnamelistARRAY(dstpad)[max])++;
      }

    return dstpad;
}

#endif /* USE_ITHREADS */

/*
=for apidoc newPADNAMEpvn

Constructs and returns a new pad name.  C<s> must be a UTF-8 string.  Do not
use this for pad names that point to outer lexicals.  See
C<L</newPADNAMEouter>>.

=cut
*/

PADNAME *
Perl_newPADNAMEpvn(const char *s, STRLEN len)
{
    struct padname_with_str *alloc;
    char *alloc2; /* for Newxz */
    PADNAME *pn;
    PERL_ARGS_ASSERT_NEWPADNAMEPVN;
    Newxz(alloc2,
	  STRUCT_OFFSET(struct padname_with_str, xpadn_str[0]) + len + 1,
	  char);
    alloc = (struct padname_with_str *)alloc2;
    pn = (PADNAME *)alloc;
    PadnameREFCNT(pn) = 1;
    PadnamePV(pn) = alloc->xpadn_str;
    Copy(s, PadnamePV(pn), len, char);
    *(PadnamePV(pn) + len) = '\0';
    PadnameLEN(pn) = len;
    return pn;
}

/*
=for apidoc newPADNAMEouter

Constructs and returns a new pad name.  Only use this function for names
that refer to outer lexicals.  (See also L</newPADNAMEpvn>.)  C<outer> is
the outer pad name that this one mirrors.  The returned pad name has the
C<PADNAMEt_OUTER> flag already set.

=cut
*/

PADNAME *
Perl_newPADNAMEouter(PADNAME *outer)
{
    PADNAME *pn;
    PERL_ARGS_ASSERT_NEWPADNAMEOUTER;
    Newxz(pn, 1, PADNAME);
    PadnameREFCNT(pn) = 1;
    PadnamePV(pn) = PadnamePV(outer);
    /* Not PadnameREFCNT(outer), because ‘outer’ may itself close over
       another entry.  The original pad name owns the buffer.  */
    PadnameREFCNT(PADNAME_FROM_PV(PadnamePV(outer)))++;
    PadnameFLAGS(pn) = PADNAMEt_OUTER;
    PadnameLEN(pn) = PadnameLEN(outer);
    return pn;
}

void
Perl_padname_free(pTHX_ PADNAME *pn)
{
    PERL_ARGS_ASSERT_PADNAME_FREE;
    if (!--PadnameREFCNT(pn)) {
	if (UNLIKELY(pn == &PL_padname_undef || pn == &PL_padname_const)) {
	    PadnameREFCNT(pn) = SvREFCNT_IMMORTAL;
	    return;
	}
	SvREFCNT_dec(PadnameTYPE(pn)); /* Takes care of protocv, too.  */
	SvREFCNT_dec(PadnameOURSTASH(pn));
	if (PadnameOUTER(pn))
	    PadnameREFCNT_dec(PADNAME_FROM_PV(PadnamePV(pn)));
	Safefree(pn);
    }
}

#if defined(USE_ITHREADS)

/*
=for apidoc padname_dup

Duplicates a pad name.

=cut
*/

PADNAME *
Perl_padname_dup(pTHX_ PADNAME *src, CLONE_PARAMS *param)
{
    PADNAME *dst;

    PERL_ARGS_ASSERT_PADNAME_DUP;

    /* look for it in the table first */
    dst = (PADNAME *)ptr_table_fetch(PL_ptr_table, src);
    if (dst)
	return dst;

    if (!PadnamePV(src)) {
	dst = &PL_padname_undef;
	ptr_table_store(PL_ptr_table, src, dst);
	return dst;
    }

    dst = PadnameOUTER(src)
     ? newPADNAMEouter(padname_dup(PADNAME_FROM_PV(PadnamePV(src)), param))
     : newPADNAMEpvn(PadnamePV(src), PadnameLEN(src));
    ptr_table_store(PL_ptr_table, src, dst);
    PadnameLEN(dst) = PadnameLEN(src);
    PadnameFLAGS(dst) = PadnameFLAGS(src);
    PadnameREFCNT(dst) = 0; /* The caller will increment it.  */
    PadnameTYPE   (dst) = (HV *)sv_dup_inc((SV *)PadnameTYPE(src), param);
    PadnameOURSTASH(dst) = (HV *)sv_dup_inc((SV *)PadnameOURSTASH(src),
					    param);
    dst->xpadn_low  = src->xpadn_low;
    dst->xpadn_high = src->xpadn_high;
    dst->xpadn_gen  = src->xpadn_gen;
    return dst;
}

#endif /* USE_ITHREADS */

/*
@


