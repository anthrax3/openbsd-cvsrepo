head	1.4;
access;
symbols
	OPENBSD_6_2:1.4.0.52
	OPENBSD_6_2_BASE:1.4
	PERL_5_24_2:1.1.1.4
	OPENBSD_6_1:1.4.0.56
	OPENBSD_6_1_BASE:1.4
	OPENBSD_6_0:1.4.0.54
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.48
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.50
	OPENBSD_5_8_BASE:1.4
	PERL_5_20_2:1.1.1.4
	OPENBSD_5_7:1.4.0.42
	OPENBSD_5_7_BASE:1.4
	PERL_5_20_1:1.1.1.4
	OPENBSD_5_6:1.4.0.46
	OPENBSD_5_6_BASE:1.4
	PERL_5_18_2:1.1.1.4
	PERL:1.1.1
	OPENBSD_5_5:1.4.0.44
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.40
	OPENBSD_5_4_BASE:1.4
	PERL_5_16_3:1.1.1.4
	OPENBSD_5_3:1.4.0.38
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.36
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.34
	OPENBSD_5_0:1.4.0.32
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.30
	OPENBSD_4_9_BASE:1.4
	PERL_5_12_2:1.1.1.4
	OPENBSD_4_8:1.4.0.28
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.24
	OPENBSD_4_7_BASE:1.4
	PERL_5_10_1:1.1.1.4
	OPENBSD_4_6:1.4.0.26
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.22
	OPENBSD_4_5_BASE:1.4
	PERL_5_10_0:1.1.1.4
	OPENBSD_4_4:1.4.0.20
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.18
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.16
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.14
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.12
	OPENBSD_4_0_BASE:1.4
	PERL_5_8_8:1.1.1.4
	OPENBSD_3_9:1.4.0.10
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.8
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.6
	OPENBSD_3_7_BASE:1.4
	PERL_5_8_6:1.1.1.4
	OPENBSD_3_6:1.4.0.4
	OPENBSD_3_6_BASE:1.4
	PERL_5_8_5:1.1.1.4
	PERL_5_8_3:1.1.1.4
	OPENBSD_3_5:1.4.0.2
	OPENBSD_3_5_BASE:1.4
	PERL_5_8_2:1.1.1.4
	OPENBSD_3_4:1.3.0.4
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.3.0.2
	OPENBSD_3_3_BASE:1.3
	PERL_5_8_0:1.1.1.3
	OPENBSD_3_2:1.2.0.12
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.10
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.8
	OPENBSD_3_0_BASE:1.2
	PERL_5_6_1:1.1.1.2
	OPENBSD_2_9:1.2.0.6
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.1.0.8
	OPENBSD_2_6_BASE:1.1
	PERL_500503:1.1.1.1
	CPAN:1.1.1
	OPENBSD_2_5:1.1.0.6
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.4
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.2
	OPENBSD_2_3_BASE:1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.4
date	2003.12.03.03.02.42;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2002.10.27.22.25.31;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.06.17.07.04;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	97.11.30.07.58.20;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.29.22.40.22;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.04.06.16.10.15;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.10.27.22.15.03;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.12.03.02.44.17;	author millert;	state Exp;
branches;
next	;


desc
@perl 5.004_04
@


1.4
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@#include "dlfcn.h"
#include "string.h"
#include "stdio.h"

#define INCL_BASE
#include <os2.h>
#include <float.h>
#include <stdlib.h>

static ULONG retcode;
static char fail[300];

static ULONG dllHandle;
static int handle_found;
static int handle_loaded;
#ifdef PERL_CORE

#include "EXTERN.h"
#include "perl.h"

#else

char *os2error(int rc);

#endif

#ifdef DLOPEN_INITTERM
unsigned long _DLL_InitTerm(unsigned long modHandle, unsigned long flag)
{
    switch (flag) {
    case 0:     /* INIT */
        /* Save handle */
        dllHandle = modHandle;
	handle_found = 1;
        return TRUE;

    case 1:     /* TERM */
	handle_found = 0;
        dllHandle = (unsigned long)NULLHANDLE;
        return TRUE;
    }

    return FALSE;
}

#endif

HMODULE
find_myself(void)
{

  static APIRET APIENTRY (*pDosQueryModFromEIP) (HMODULE * hmod, ULONG * obj, ULONG BufLen, PCHAR Buf,
		    ULONG * Offset, ULONG Address);
  HMODULE doscalls_h, mod;
  static int failed;
  ULONG obj, offset, rc;
  char buf[260];

  if (failed)
	return 0;
  failed = 1;
  doscalls_h = (HMODULE)dlopen("DOSCALLS",0);
  if (!doscalls_h)
	return 0;
/*  {&doscalls_handle, NULL, 360}, */	/* DosQueryModFromEIP */
  rc = DosQueryProcAddr(doscalls_h, 360, 0, (PFN*)&pDosQueryModFromEIP);
  if (rc)
	return 0;
  rc = pDosQueryModFromEIP(&mod, &obj, sizeof(buf), buf, &offset, (ULONG)dlopen);
  if (rc)
	return 0;
  failed = 0;
  handle_found = 1;
  dllHandle = mod;
  return mod;
}

void *
dlopen(const char *path, int mode)
{
	HMODULE handle;
	char tmp[260];
	const char *beg, *dot;
	ULONG rc;
	unsigned fpflag = _control87(0,0);

	fail[0] = 0;
	if (!path) {			/* Our own handle. */
	    if (handle_found || find_myself()) {
		char dllname[260];

		if (handle_loaded)
		    return (void*)dllHandle;
		rc = DosQueryModuleName(dllHandle, sizeof(dllname), dllname);
		if (rc) {
	            strcpy(fail, "can't find my DLL name by the handle");
		    retcode = rc;
		    return 0;
		}
		rc = DosLoadModule(fail, sizeof fail, dllname, &handle);
		if (rc) {
	            strcpy(fail, "can't load my own DLL");
		    retcode = rc;
		    return 0;
		}
		handle_loaded = 1;
		goto ret;
	    }
	    retcode = ERROR_MOD_NOT_FOUND;
            strcpy(fail, "can't load from myself: compiled without -DDLOPEN_INITTERM");
	    return 0;
	}
	if ((rc = DosLoadModule(fail, sizeof fail, (char*)path, &handle)) == 0)
		goto ret;

	retcode = rc;

	if (strlen(path) >= sizeof(tmp))
	    return NULL;

	/* Not found. Check for non-FAT name and try truncated name. */
	/* Don't know if this helps though... */
	for (beg = dot = path + strlen(path);
	     beg > path && !strchr(":/\\", *(beg-1));
	     beg--)
		if (*beg == '.')
			dot = beg;
	if (dot - beg > 8) {
		int n = beg+8-path;

		memmove(tmp, path, n);
		memmove(tmp+n, dot, strlen(dot)+1);
		if (DosLoadModule(fail, sizeof fail, tmp, &handle) == 0)
		    goto ret;
	}
	handle = 0;

      ret:
	_control87(fpflag, MCW_EM); /* Some modules reset FP flags on load */
	return (void *)handle;
}

#define ERROR_WRONG_PROCTYPE 0xffffffff

void *
dlsym(void *handle, const char *symbol)
{
	ULONG rc, type;
	PFN addr;

	fail[0] = 0;
	rc = DosQueryProcAddr((HMODULE)handle, 0, symbol, &addr);
	if (rc == 0) {
		rc = DosQueryProcType((HMODULE)handle, 0, symbol, &type);
		if (rc == 0 && type == PT_32BIT)
			return (void *)addr;
		rc = ERROR_WRONG_PROCTYPE;
	}
	retcode = rc;
	return NULL;
}

char *
dlerror(void)
{
	static char buf[700];
	ULONG len;
	char *err;

	if (retcode == 0)
		return NULL;
	if (retcode == ERROR_WRONG_PROCTYPE)
	    err = "Wrong procedure type";
	else
	    err = os2error(retcode);
	len = strlen(err);
	if (len > sizeof(buf) - 1)
	    len = sizeof(buf) - 1;
	strncpy(buf, err, len+1);
	if (fail[0] && len + strlen(fail) < sizeof(buf) - 100)
	    sprintf(buf + len, ", possible problematic module: '%s'", fail);
	retcode = 0;
	return buf;
}

int
dlclose(void *handle)
{
	ULONG rc;

	if ((rc = DosFreeModule((HMODULE)handle)) == 0) return 0;

	retcode = rc;
	return 2;
}
@


1.3
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d7 2
d13 10
d25 53
d82 2
a83 1
	char tmp[260], *beg, *dot;
d85 1
d88 25
d114 1
a114 1
		return (void *)handle;
d134 1
a134 1
			return (void *)handle;
d136 1
d138 3
a140 1
	return NULL;
d143 2
d157 1
a157 1
		rc = ERROR_CALL_NOT_IMPLEMENTED;
d172 4
a175 1
	err = os2error(retcode);
d180 1
a180 1
	if (fail[0] && len < 300)
@


1.2
log
@perl-5.6.0 + local changes
@
text
@d2 2
d11 2
d14 1
a14 1
dlopen(char *path, int mode)
d21 1
a21 1
	if ((rc = DosLoadModule(fail, sizeof fail, path, &handle)) == 0)
d26 3
d38 1
d49 1
a49 1
dlsym(void *handle, char *symbol)
d71 1
d75 7
a81 20
	if (DosGetMessage(NULL, 0, buf, sizeof buf - 1, retcode,
			  "OSO001.MSG", &len)) {
		if (fail[0])
		  sprintf(buf, 
"OS/2 system error code %d, possible problematic module: '%s'",
			  retcode, fail);
		else
		  sprintf(buf, "OS/2 system error code %d", retcode);
	} else {
		buf[len] = '\0';
		if (len && buf[len - 1] == '\n')
			buf[--len] = 0;
		if (len && buf[len - 1] == '\r')
			buf[--len] = 0;
		if (len && buf[len - 1] == '.')
			buf[--len] = 0;
		if (fail[0] && len < 300)
		  sprintf(buf + len, ", possible problematic module: '%s'",
			  fail);
	}
@


1.1
log
@perl 5.004_04
@
text
@d7 1
a13 1
	char fail[300];
d16 1
d46 1
d61 1
a61 1
	static char buf[300];
d66 9
a74 3
	if (DosGetMessage(NULL, 0, buf, sizeof buf - 1, retcode, "OSO001.MSG", &len))
		sprintf(buf, "OS/2 system error code %d", retcode);
	else
d76 10
d90 10
@


1.1.1.1
log
@perl5.005_03
@
text
@@


1.1.1.2
log
@virgin perl 5.6.0
@
text
@a6 1
static char fail[300];
d13 1
a15 1
	fail[0] = 0;
a44 1
	fail[0] = 0;
d59 1
a59 1
	static char buf[700];
d64 3
a66 9
	if (DosGetMessage(NULL, 0, buf, sizeof buf - 1, retcode,
			  "OSO001.MSG", &len)) {
		if (fail[0])
		  sprintf(buf, 
"OS/2 system error code %d, possible problematic module: '%s'",
			  retcode, fail);
		else
		  sprintf(buf, "OS/2 system error code %d", retcode);
	} else {
a67 10
		if (len && buf[len - 1] == '\n')
			buf[--len] = 0;
		if (len && buf[len - 1] == '\r')
			buf[--len] = 0;
		if (len && buf[len - 1] == '.')
			buf[--len] = 0;
		if (fail[0] && len < 300)
		  sprintf(buf + len, ", possible problematic module: '%s'",
			  fail);
	}
a71 10
int
dlclose(void *handle)
{
	ULONG rc;

	if ((rc = DosFreeModule((HMODULE)handle)) == 0) return 0;

	retcode = rc;
	return 2;
}
@


1.1.1.3
log
@stock perl 5.8.0 from CPAN
@
text
@a1 2
#include "string.h"
#include "stdio.h"
a8 2
char *os2error(int rc);

d10 1
a10 1
dlopen(const char *path, int mode)
d17 1
a17 1
	if ((rc = DosLoadModule(fail, sizeof fail, (char*)path, &handle)) == 0)
a21 3
	if (strlen(path) >= sizeof(tmp))
	    return NULL;

a30 1

d41 1
a41 1
dlsym(void *handle, const char *symbol)
a62 1
	char *err;
d66 20
a85 7
	err = os2error(retcode);
	len = strlen(err);
	if (len > sizeof(buf) - 1)
	    len = sizeof(buf) - 1;
	strncpy(buf, err, len+1);
	if (fail[0] && len < 300)
	    sprintf(buf + len, ", possible problematic module: '%s'", fail);
@


1.1.1.4
log
@perl 5.8.2 from CPAN
@
text
@a6 2
#include <float.h>
#include <stdlib.h>
a10 10
static ULONG dllHandle;
static int handle_found;
static int handle_loaded;
#ifdef PERL_CORE

#include "EXTERN.h"
#include "perl.h"

#else

a12 53
#endif

#ifdef DLOPEN_INITTERM
unsigned long _DLL_InitTerm(unsigned long modHandle, unsigned long flag)
{
    switch (flag) {
    case 0:     /* INIT */
        /* Save handle */
        dllHandle = modHandle;
	handle_found = 1;
        return TRUE;

    case 1:     /* TERM */
	handle_found = 0;
        dllHandle = (unsigned long)NULLHANDLE;
        return TRUE;
    }

    return FALSE;
}

#endif

HMODULE
find_myself(void)
{

  static APIRET APIENTRY (*pDosQueryModFromEIP) (HMODULE * hmod, ULONG * obj, ULONG BufLen, PCHAR Buf,
		    ULONG * Offset, ULONG Address);
  HMODULE doscalls_h, mod;
  static int failed;
  ULONG obj, offset, rc;
  char buf[260];

  if (failed)
	return 0;
  failed = 1;
  doscalls_h = (HMODULE)dlopen("DOSCALLS",0);
  if (!doscalls_h)
	return 0;
/*  {&doscalls_handle, NULL, 360}, */	/* DosQueryModFromEIP */
  rc = DosQueryProcAddr(doscalls_h, 360, 0, (PFN*)&pDosQueryModFromEIP);
  if (rc)
	return 0;
  rc = pDosQueryModFromEIP(&mod, &obj, sizeof(buf), buf, &offset, (ULONG)dlopen);
  if (rc)
	return 0;
  failed = 0;
  handle_found = 1;
  dllHandle = mod;
  return mod;
}

d17 1
a17 2
	char tmp[260];
	const char *beg, *dot;
a18 1
	unsigned fpflag = _control87(0,0);
a20 25
	if (!path) {			/* Our own handle. */
	    if (handle_found || find_myself()) {
		char dllname[260];

		if (handle_loaded)
		    return (void*)dllHandle;
		rc = DosQueryModuleName(dllHandle, sizeof(dllname), dllname);
		if (rc) {
	            strcpy(fail, "can't find my DLL name by the handle");
		    retcode = rc;
		    return 0;
		}
		rc = DosLoadModule(fail, sizeof fail, dllname, &handle);
		if (rc) {
	            strcpy(fail, "can't load my own DLL");
		    retcode = rc;
		    return 0;
		}
		handle_loaded = 1;
		goto ret;
	    }
	    retcode = ERROR_MOD_NOT_FOUND;
            strcpy(fail, "can't load from myself: compiled without -DDLOPEN_INITTERM");
	    return 0;
	}
d22 1
a22 1
		goto ret;
d42 1
a42 1
		    goto ret;
a43 1
	handle = 0;
d45 1
a45 3
      ret:
	_control87(fpflag, MCW_EM); /* Some modules reset FP flags on load */
	return (void *)handle;
a47 2
#define ERROR_WRONG_PROCTYPE 0xffffffff

d60 1
a60 1
		rc = ERROR_WRONG_PROCTYPE;
d75 1
a75 4
	if (retcode == ERROR_WRONG_PROCTYPE)
	    err = "Wrong procedure type";
	else
	    err = os2error(retcode);
d80 1
a80 1
	if (fail[0] && len + strlen(fail) < sizeof(buf) - 100)
@


