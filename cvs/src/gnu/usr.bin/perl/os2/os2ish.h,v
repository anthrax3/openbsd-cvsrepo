head	1.10;
access;
symbols
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.10.0.16
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.10
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.10.0.12
	OPENBSD_5_8_BASE:1.10
	PERL_5_20_2:1.1.1.9
	OPENBSD_5_7:1.10.0.4
	OPENBSD_5_7_BASE:1.10
	PERL_5_20_1:1.1.1.9
	OPENBSD_5_6:1.10.0.8
	OPENBSD_5_6_BASE:1.10
	PERL_5_18_2:1.1.1.9
	PERL:1.1.1
	OPENBSD_5_5:1.10.0.6
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.2
	OPENBSD_5_4_BASE:1.10
	PERL_5_16_3:1.1.1.9
	OPENBSD_5_3:1.9.0.18
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.16
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.14
	OPENBSD_5_0:1.9.0.12
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.10
	OPENBSD_4_9_BASE:1.9
	PERL_5_12_2:1.1.1.8
	OPENBSD_4_8:1.9.0.8
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.4
	OPENBSD_4_7_BASE:1.9
	PERL_5_10_1:1.1.1.8
	OPENBSD_4_6:1.9.0.6
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.2
	OPENBSD_4_5_BASE:1.9
	PERL_5_10_0:1.1.1.8
	OPENBSD_4_4:1.8.0.18
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.16
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.14
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.12
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.10
	OPENBSD_4_0_BASE:1.8
	PERL_5_8_8:1.1.1.7
	OPENBSD_3_9:1.8.0.8
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.6
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.4
	OPENBSD_3_7_BASE:1.8
	PERL_5_8_6:1.1.1.7
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	PERL_5_8_5:1.1.1.7
	PERL_5_8_3:1.1.1.7
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.10
date	2013.03.25.20.40.56;	author sthen;	state Exp;
branches;
next	1.9;

1.9
date	2008.09.29.17.36.15;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2004.04.07.21.33.07;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.42;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.31;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.35.46;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.07.05;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.52.03;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.58.22;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.12.54;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.12.54;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.40.24;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.10.15;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.24.23;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.15.03;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.44.18;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.04.07.21.13.30;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2008.09.29.17.18.48;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2013.03.25.20.09.11;	author sthen;	state Exp;
branches;
next	;


desc
@@


1.10
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@#include <signal.h>
#include <io.h>
/* #include <sys/select.h> */

/* HAS_IOCTL:
 *	This symbol, if defined, indicates that the ioctl() routine is
 *	available to set I/O characteristics
 */
#define	HAS_IOCTL		/**/
 
/* HAS_UTIME:
 *	This symbol, if defined, indicates that the routine utime() is
 *	available to update the access and modification times of files.
 */
#define HAS_UTIME		/**/

/* BIG_TIME:
 *	This symbol is defined if Time_t is an unsigned type on this system.
 */
#define BIG_TIME

#define HAS_KILL
#define HAS_WAIT
#define HAS_DLERROR
#define HAS_WAITPID_RUNTIME (_emx_env & 0x200)

/* HAS_PASSWD
 *	This symbol, if defined, indicates that the getpwnam() and
 *	getpwuid() routines are available to get password entries.
 *	The getpwent() has a separate definition, HAS_GETPWENT.
 */
#define HAS_PASSWD

/* HAS_GROUP
 *	This symbol, if defined, indicates that the getgrnam() and
 *	getgrgid() routines are available to get group entries.
 *	The getgrent() has a separate definition, HAS_GETGRENT.
 */
#define HAS_GROUP
#define HAS_GETGRENT			/* fake */
#define HAS_SETGRENT			/* fake */
#define HAS_ENDGRENT			/* fake */

/* USEMYBINMODE
 *	This symbol, if defined, indicates that the program should
 *	use the routine my_binmode(FILE *fp, char iotype, int mode) to insure
 *	that a file is in "binary" mode -- that is, that no translation
 *	of bytes occurs on read or write operations.
 */
#undef USEMYBINMODE

#define SOCKET_OPEN_MODE	"b"

/* Stat_t:
 *	This symbol holds the type used to declare buffers for information
 *	returned by stat().  It's usually just struct stat.  It may be necessary
 *	to include <sys/stat.h> and <sys/types.h> to get any typedef'ed
 *	information.
 */
#define Stat_t struct stat

/* USE_STAT_RDEV:
 *	This symbol is defined if this system has a stat structure declaring
 *	st_rdev
 */
#define USE_STAT_RDEV 	/**/

/* ACME_MESS:
 *	This symbol, if defined, indicates that error messages should be 
 *	should be generated in a format that allows the use of the Acme
 *	GUI/editor's autofind feature.
 */
#undef ACME_MESS	/**/

/* ALTERNATE_SHEBANG:
 *	This symbol, if defined, contains a "magic" string which may be used
 *	as the first line of a Perl program designed to be executed directly
 *	by name, instead of the standard Unix #!.  If ALTERNATE_SHEBANG
 *	begins with a character other then #, then Perl will only treat
 *	it as a command line if if finds the string "perl" in the first
 *	word; otherwise it's treated as the first line of code in the script.
 *	(IOW, Perl won't hand off to another interpreter via an alternate
 *	shebang sequence that might be legal Perl code.)
 */
#define ALTERNATE_SHEBANG "extproc "

#ifndef SIGABRT
#    define SIGABRT SIGILL
#endif
#ifndef SIGILL
#    define SIGILL 6         /* blech */
#endif
#define ABORT() kill(PerlProc_getpid(),SIGABRT);

#define BIT_BUCKET "/dev/nul"  /* Will this work? */

/* Apparently TCPIPV4 defines may be included even with only IAK present */

#if !defined(NO_TCPIPV4) && !defined(TCPIPV4)
#  define TCPIPV4
#  define TCPIPV4_FORCED		/* Just in case */
#endif

#if defined(I_SYS_UN) && !defined(TCPIPV4)
/* It is not working without TCPIPV4 defined. */
# undef I_SYS_UN
#endif 

#ifdef USE_ITHREADS

#define do_spawn(a)      os2_do_spawn(aTHX_ (a))
#define do_aspawn(a,b,c) os2_do_aspawn(aTHX_ (a),(b),(c))

#define OS2_ERROR_ALREADY_POSTED 299	/* Avoid os2.h */

extern int rc;

#define MUTEX_INIT(m) \
    STMT_START {						\
	int rc;							\
	if ((rc = _rmutex_create(m,0)))				\
	    Perl_croak_nocontext("panic: MUTEX_INIT: rc=%i", rc);	\
    } STMT_END
#define MUTEX_LOCK(m) \
    STMT_START {						\
	int rc;							\
	if ((rc = _rmutex_request(m,_FMR_IGNINT)))		\
	    Perl_croak_nocontext("panic: MUTEX_LOCK: rc=%i", rc);	\
    } STMT_END
#define MUTEX_UNLOCK(m) \
    STMT_START {						\
	int rc;							\
	if ((rc = _rmutex_release(m)))				\
	    Perl_croak_nocontext("panic: MUTEX_UNLOCK: rc=%i", rc);	\
    } STMT_END
#define MUTEX_DESTROY(m) \
    STMT_START {						\
	int rc;							\
	if ((rc = _rmutex_close(m)))				\
	    Perl_croak_nocontext("panic: MUTEX_DESTROY: rc=%i", rc);	\
    } STMT_END

#define COND_INIT(c) \
    STMT_START {						\
	int rc;							\
	if ((rc = DosCreateEventSem(NULL,c,0,0)))		\
	    Perl_croak_nocontext("panic: COND_INIT: rc=%i", rc);	\
    } STMT_END
#define COND_SIGNAL(c) \
    STMT_START {						\
	int rc;							\
	if ((rc = DosPostEventSem(*(c))) && rc != OS2_ERROR_ALREADY_POSTED)\
	    Perl_croak_nocontext("panic: COND_SIGNAL, rc=%ld", rc);	\
    } STMT_END
#define COND_BROADCAST(c) \
    STMT_START {						\
	int rc;							\
	if ((rc = DosPostEventSem(*(c))) && rc != OS2_ERROR_ALREADY_POSTED)\
	    Perl_croak_nocontext("panic: COND_BROADCAST, rc=%i", rc);	\
    } STMT_END
/* #define COND_WAIT(c, m) \
    STMT_START {						\
	if (WaitForSingleObject(*(c),INFINITE) == WAIT_FAILED)	\
	    Perl_croak_nocontext("panic: COND_WAIT");		\
    } STMT_END
*/
#define COND_WAIT(c, m) os2_cond_wait(c,m)

#define COND_WAIT_win32(c, m) \
    STMT_START {						\
	int rc;							\
	if ((rc = SignalObjectAndWait(*(m),*(c),INFINITE,FALSE)))	\
	    Perl_croak_nocontext("panic: COND_WAIT");			\
	else							\
	    MUTEX_LOCK(m);					\
    } STMT_END
#define COND_DESTROY(c) \
    STMT_START {						\
	int rc;							\
	if ((rc = DosCloseEventSem(*(c))))			\
	    Perl_croak_nocontext("panic: COND_DESTROY, rc=%i", rc);	\
    } STMT_END
/*#define THR ((struct thread *) TlsGetValue(PL_thr_key))
*/

#ifdef USE_SLOW_THREAD_SPECIFIC
#  define pthread_getspecific(k)	(*_threadstore())
#  define pthread_setspecific(k,v)	(*_threadstore()=v,0)
#  define pthread_key_create(keyp,flag)	(*keyp=_gettid(),0)
#else /* USE_SLOW_THREAD_SPECIFIC */
#  define pthread_getspecific(k)	(*(k))
#  define pthread_setspecific(k,v)	(*(k)=(v),0)
#  define pthread_key_create(keyp,flag)			\
	( DosAllocThreadLocalMemory(1,(unsigned long**)keyp)	\
	  ? Perl_croak_nocontext("LocalMemory"),1	\
	  : 0						\
	)
#endif /* USE_SLOW_THREAD_SPECIFIC */
#define pthread_key_delete(keyp)
#define pthread_self()			_gettid()
#define YIELD				DosSleep(0)

#ifdef PTHREADS_INCLUDED		/* For ./x2p stuff. */
int pthread_join(pthread_t tid, void **status);
int pthread_detach(pthread_t tid);
int pthread_create(pthread_t *tid, const pthread_attr_t *attr,
		   void *(*start_routine)(void*), void *arg);
#endif /* PTHREAD_INCLUDED */

#define THREADS_ELSEWHERE

#else /* USE_ITHREADS */

#define do_spawn(a)      os2_do_spawn(a)
#define do_aspawn(a,b,c) os2_do_aspawn((a),(b),(c))
 
void Perl_OS2_init(char **);
void Perl_OS2_init3(char **envp, void **excH, int flags);
void Perl_OS2_term(void **excH, int exitstatus, int flags);

/* The code without INIT3 hideously puts env inside: */

/* These ones should be in the same block as PERL_SYS_TERM() */
#ifdef PERL_CORE

#  define PERL_SYS_INIT3_BODY(argcp, argvp, envp)	\
  { void *xreg[2];				\
    MALLOC_CHECK_TAINT(*argcp, *argvp, *envp)	\
    _response(argcp, argvp);			\
    _wildcard(argcp, argvp);			\
    Perl_OS2_init3(*envp, xreg, 0);		\
    PERLIO_INIT

#  define PERL_SYS_INIT_BODY(argcp, argvp)  {	\
  { void *xreg[2];				\
    _response(argcp, argvp);			\
    _wildcard(argcp, argvp);			\
    Perl_OS2_init3(NULL, xreg, 0);		\
    PERLIO_INIT

#else  /* Compiling embedded Perl or Perl extension */

#  define PERL_SYS_INIT3_BODY(argcp, argvp, envp)	\
  { void *xreg[2];				\
    Perl_OS2_init3(*envp, xreg, 0);		\
    PERLIO_INIT
#  define PERL_SYS_INIT_BODY(argcp, argvp)	{	\
  { void *xreg[2];				\
    Perl_OS2_init3(NULL, xreg, 0);		\
    PERLIO_INIT
#endif

#define FORCE_EMX_DEINIT_EXIT		1
#define FORCE_EMX_DEINIT_CRT_TERM	2
#define FORCE_EMX_DEINIT_RUN_ATEXIT	4

#define PERL_SYS_TERM2(xreg,flags)					\
  Perl_OS2_term(xreg, 0, flags);					\
  PERLIO_TERM;								\
  MALLOC_TERM

#define PERL_SYS_TERM1(xreg)						\
     Perl_OS2_term(xreg, 0, FORCE_EMX_DEINIT_RUN_ATEXIT)

/* This one should come in pair with PERL_SYS_INIT_BODY() and in the same block */
#define PERL_SYS_TERM_BODY()							\
     PERL_SYS_TERM1(xreg);						\
  }

#ifndef __EMX__
#  define PERL_CALLCONV _System
#endif

/* #define PERL_SYS_TERM_BODY() STMT_START {	\
    if (Perl_HAB_set) WinTerminate(Perl_hab);	} STMT_END */

#define dXSUB_SYS OS2_XS_init()

#ifdef PERL_IS_AOUT
/* #  define HAS_FORK */
/* #  define HIDEMYMALLOC */
/* #  define PERL_SBRK_VIA_MALLOC */ /* gets off-page sbrk... */
#else /* !PERL_IS_AOUT */
#  ifndef PERL_FOR_X2P
#    ifdef EMX_BAD_SBRK
#      define USE_PERL_SBRK
#    endif 
#  else
#    define PerlIO FILE
#  endif 
#  define SYSTEM_ALLOC(a) sys_alloc(a)

void *sys_alloc(int size);

#endif /* !PERL_IS_AOUT */
#if !defined(PERL_CORE) && !defined(PerlIO) /* a2p */
#  define PerlIO FILE
#endif 

/* os2ish is used from a2p/a2p.h without pTHX/pTHX_ first being
 * defined.  Hack around this to get us to compile.
*/
#ifdef PTHX_UNUSED
# ifndef pTHX
#  define pTHX
# endif
# ifndef pTHX_
#  define pTHX_
# endif
#endif

#define TMPPATH1 "plXXXXXX"
extern const char *tmppath;
PerlIO *my_syspopen(pTHX_ char *cmd, char *mode);
#ifdef PERL_CORE
/* Cannot prototype with I32, SV at this point (used in x2p too). */
PerlIO *my_syspopen4(pTHX_ char *cmd, char *mode, I32 cnt, SV** args);
#endif
int my_syspclose(PerlIO *f);
FILE *my_tmpfile (void);
char *my_tmpnam (char *);
int my_mkdir (__const__ char *, long);
int my_rmdir (__const__ char *);
struct passwd *my_getpwent (void);
void my_setpwent (void);
void my_endpwent (void);
char *gcvt_os2(double value, int digits, char *buffer);

extern int async_mssleep(unsigned long ms, int switch_priority);
extern unsigned long msCounter(void);
extern unsigned long InfoTable(int local);
extern unsigned long find_myself(void);

#define MAX_SLEEP	(((1<30) / (1000/4))-1)	/* 1<32 msec */

static __inline__ unsigned
my_sleep(unsigned sec)
{
  int remain;
  while (sec > MAX_SLEEP) {
    sec -= MAX_SLEEP;
    remain = sleep(MAX_SLEEP);
    if (remain)
      return remain + sec;
  }
  return sleep(sec);
}

#define sleep		my_sleep

#ifndef INCL_DOS
unsigned long DosSleep(unsigned long);
unsigned long DosAllocThreadLocalMemory (unsigned long cb, unsigned long **p);
#endif

struct group *getgrent (void);
void setgrent (void);
void endgrent (void);

struct passwd *my_getpwuid (uid_t);
struct passwd *my_getpwnam (__const__ char *);

#undef L_tmpnam
#define L_tmpnam MAXPATHLEN

#define tmpfile	my_tmpfile
#define tmpnam	my_tmpnam
#define isatty	_isterm
#define rand	random
#define srand	srandom
#define strtoll	_strtoll
#define strtoull	_strtoull

#define usleep(usec)	((void)async_mssleep(((usec)+500)/1000, 500))


/*
 * fwrite1() should be a routine with the same calling sequence as fwrite(),
 * but which outputs all of the bytes requested as a single stream (unlike
 * fwrite() itself, which on some systems outputs several distinct records
 * if the number_of_items parameter is >1).
 */
#define fwrite1 fwrite

#define my_getenv(var) getenv(var)
#define flock	my_flock
#define rmdir	my_rmdir
#define mkdir	my_mkdir
#define setpwent	my_setpwent
#define getpwent	my_getpwent
#define endpwent	my_endpwent
#define getpwuid	my_getpwuid
#define getpwnam	my_getpwnam

void *emx_calloc (size_t, size_t);
void emx_free (void *);
void *emx_malloc (size_t);
void *emx_realloc (void *, size_t);

/*****************************************************************************/

#include <stdlib.h>	/* before the following definitions */
#include <unistd.h>	/* before the following definitions */
#include <fcntl.h>
#include <sys/stat.h>

#define chdir	_chdir2
#define getcwd	_getcwd2

/* This guy is needed for quick stdstd  */

#if defined(USE_STDIO_PTR) && defined(STDIO_PTR_LVALUE) && defined(STDIO_CNT_LVALUE)
	/* Perl uses ungetc only with successful return */
#  define ungetc(c,fp) \
	(FILE_ptr(fp) > FILE_base(fp) && c == (int)*(FILE_ptr(fp) - 1) \
	 ? (--FILE_ptr(fp), ++FILE_cnt(fp), (int)c) : ungetc(c,fp))
#endif

#define PERLIO_IS_BINMODE_FD(fd) _PERLIO_IS_BINMODE_FD(fd)

#ifdef __GNUG__
# define HAS_BOOL 
#endif
#ifndef HAS_BOOL
# define bool char
# define HAS_BOOL 1
#endif

#include <emx/io.h> /* for _fd_flags() prototype */

static inline bool
_PERLIO_IS_BINMODE_FD(int fd)
{
    int *pflags = _fd_flags(fd);

    return pflags && (*pflags) & O_BINARY;
}

/* ctermid is missing from emx0.9d */
char *ctermid(char *s);

#define OP_BINARY O_BINARY

#define OS2_STAT_HACK 1
#if OS2_STAT_HACK

#define Stat(fname,bufptr) os2_stat((fname),(bufptr))
#define Fstat(fd,bufptr)   os2_fstat((fd),(bufptr))
#define Fflush(fp)         fflush(fp)
#define Mkdir(path,mode)   mkdir((path),(mode))
#define chmod(path,mode)   os2_chmod((path),(mode))

#undef S_IFBLK
#undef S_ISBLK
#define S_IFBLK		0120000		/* Hacks to make things compile... */
#define S_ISBLK(mode)	(((mode) & S_IFMT) == S_IFBLK)

int os2_chmod(const char *name, int pmode);
int os2_fstat(int handle, struct stat *st);

#else

#define Stat(fname,bufptr) stat((fname),(bufptr))
#define Fstat(fd,bufptr)   fstat((fd),(bufptr))
#define Fflush(fp)         fflush(fp)
#define Mkdir(path,mode)   mkdir((path),(mode))

#endif

/* With SD386 it is impossible to debug register variables. */
#if !defined(PERL_IS_AOUT) && defined(DEBUGGING) && !defined(register)
#  define register
#endif

/* Our private OS/2 specific data. */

typedef struct OS2_Perl_data {
  unsigned long flags;
  unsigned long phab;
  int (*xs_init)();
  unsigned long rc;
  unsigned long severity;
  unsigned long	phmq;			/* Handle to message queue */
  unsigned long	phmq_refcnt;
  unsigned long	phmq_servers;
  unsigned long	initial_mode;		/* VIO etc. mode we were started in */
  unsigned long	morph_refcnt;
} OS2_Perl_data_t;

extern OS2_Perl_data_t OS2_Perl_data;

#define Perl_hab		((HAB)OS2_Perl_data.phab)
#define Perl_rc			(OS2_Perl_data.rc)
#define Perl_severity		(OS2_Perl_data.severity)
#define errno_isOS2		12345678
#define errno_isOS2_set		12345679
#define OS2_Perl_flags	(OS2_Perl_data.flags)
#define Perl_HAB_set_f	1
#define Perl_HAB_set	(OS2_Perl_flags & Perl_HAB_set_f)
#define set_Perl_HAB_f	(OS2_Perl_flags |= Perl_HAB_set_f)
#define set_Perl_HAB(h) (set_Perl_HAB_f, Perl_hab = h)
#define _obtain_Perl_HAB (init_PMWIN_entries(),				\
			  Perl_hab = (*PMWIN_entries.Initialize)(0),	\
			  set_Perl_HAB_f, Perl_hab)
#define perl_hab_GET()	(Perl_HAB_set ? Perl_hab : _obtain_Perl_HAB)
#define Acquire_hab()	perl_hab_GET()
#define Perl_hmq	((HMQ)OS2_Perl_data.phmq)
#define Perl_hmq_refcnt	(OS2_Perl_data.phmq_refcnt)
#define Perl_hmq_servers	(OS2_Perl_data.phmq_servers)
#define Perl_os2_initial_mode	(OS2_Perl_data.initial_mode)
#define Perl_morph_refcnt	(OS2_Perl_data.morph_refcnt)

unsigned long Perl_hab_GET();
unsigned long Perl_Register_MQ(int serve);
void	Perl_Deregister_MQ(int serve);
int	Perl_Serve_Messages(int force);
/* Cannot prototype with I32 at this point. */
int	Perl_Process_Messages(int force, long *cntp);
char	*os2_execname(pTHX);

struct _QMSG;
struct PMWIN_entries_t {
    unsigned long (*Initialize)( unsigned long fsOptions );
    unsigned long (*CreateMsgQueue)(unsigned long hab, long cmsg);
    int (*DestroyMsgQueue)(unsigned long hmq);
    int (*PeekMsg)(unsigned long hab, struct _QMSG *pqmsg,
		   unsigned long hwndFilter, unsigned long msgFilterFirst,
		   unsigned long msgFilterLast, unsigned long fl);
    int (*GetMsg)(unsigned long hab, struct _QMSG *pqmsg,
		  unsigned long hwndFilter, unsigned long msgFilterFirst,
		  unsigned long msgFilterLast);
    void * (*DispatchMsg)(unsigned long hab, struct _QMSG *pqmsg);
    unsigned long (*GetLastError)(unsigned long hab);
    unsigned long (*CancelShutdown)(unsigned long hmq, unsigned long fCancelAlways);
};
extern struct PMWIN_entries_t PMWIN_entries;
void init_PMWIN_entries(void);

#define perl_hmq_GET(serve)	Perl_Register_MQ(serve)
#define perl_hmq_UNSET(serve)	Perl_Deregister_MQ(serve)

#define OS2_XS_init() (*OS2_Perl_data.xs_init)(aTHX)

#if _EMX_CRT_REV_ >= 60
# define os2_setsyserrno(rc)	(Perl_rc = rc, errno = errno_isOS2_set, \
				_setsyserrno(rc))
#else
# define os2_setsyserrno(rc)	(Perl_rc = rc, errno = errno_isOS2)
#endif

/* The expressions below return true on error. */
/* INCL_DOSERRORS needed. rc should be declared outside. */
#define CheckOSError(expr) ((rc = (expr)) ? (FillOSError(rc), rc) : 0)
/* INCL_WINERRORS needed. */
#define CheckWinError(expr) ((expr) ? 0: (FillWinError, 1))

/* This form propagates the return value, setting $^E if needed */
#define SaveWinError(expr) ((expr) ? : (FillWinError, 0))

/* This form propagates the return value, dieing with $^E if needed */
#define SaveCroakWinError(expr,die,name1,name2)		\
  ((expr) ? : (CroakWinError(die,name1 name2), 0))

#define FillOSError(rc) (os2_setsyserrno(rc),				\
			Perl_severity = SEVERITY_ERROR) 

#define WinError_2_Perl_rc	\
 (	init_PMWIN_entries(),	\
	Perl_rc=(*PMWIN_entries.GetLastError)(perl_hab_GET()) )

/* Calling WinGetLastError() resets the error code of the current thread.
   Since for some Win* API return value 0 is normal, one needs to call
   this before calling them to distinguish normal and anomalous returns.  */
/*#define ResetWinError()	WinError_2_Perl_rc */

/* At this moment init_PMWIN_entries() should be a nop (WinInitialize should
   be called already, right?), so we do not risk stepping over our own error */
#define FillWinError (	WinError_2_Perl_rc,				\
			Perl_severity = ERRORIDSEV(Perl_rc),		\
			Perl_rc = ERRORIDERROR(Perl_rc),		\
			os2_setsyserrno(Perl_rc))

#define STATIC_FILE_LENGTH 127

    /* This should match loadOrdinals[] array in os2.c */
enum entries_ordinals {
    ORD_DosQueryExtLibpath,
    ORD_DosSetExtLibpath,
    ORD_DosVerifyPidTid,
    ORD_SETHOSTENT,
    ORD_SETNETENT, 
    ORD_SETPROTOENT,
    ORD_SETSERVENT,
    ORD_GETHOSTENT,
    ORD_GETNETENT, 
    ORD_GETPROTOENT,
    ORD_GETSERVENT,
    ORD_ENDHOSTENT,
    ORD_ENDNETENT,
    ORD_ENDPROTOENT,
    ORD_ENDSERVENT,
    ORD_WinInitialize,
    ORD_WinCreateMsgQueue,
    ORD_WinDestroyMsgQueue,
    ORD_WinPeekMsg,
    ORD_WinGetMsg,
    ORD_WinDispatchMsg,
    ORD_WinGetLastError,
    ORD_WinCancelShutdown,
    ORD_RexxStart,
    ORD_RexxVariablePool,
    ORD_RexxRegisterFunctionExe,
    ORD_RexxDeregisterFunction,
    ORD_DOSSMSETTITLE,
    ORD_PRF32QUERYPROFILESIZE,
    ORD_PRF32OPENPROFILE,
    ORD_PRF32CLOSEPROFILE,
    ORD_PRF32QUERYPROFILE,
    ORD_PRF32RESET,
    ORD_PRF32QUERYPROFILEDATA,
    ORD_PRF32WRITEPROFILEDATA,

    ORD_WinChangeSwitchEntry,
    ORD_WinQuerySwitchEntry,
    ORD_WinQuerySwitchHandle,
    ORD_WinQuerySwitchList,
    ORD_WinSwitchToProgram,
    ORD_WinBeginEnumWindows,
    ORD_WinEndEnumWindows,
    ORD_WinEnumDlgItem,
    ORD_WinGetNextWindow,
    ORD_WinIsChild,
    ORD_WinQueryActiveWindow,
    ORD_WinQueryClassName,
    ORD_WinQueryFocus,
    ORD_WinQueryWindow,
    ORD_WinQueryWindowPos,
    ORD_WinQueryWindowProcess,
    ORD_WinQueryWindowText,
    ORD_WinQueryWindowTextLength,
    ORD_WinSetFocus,
    ORD_WinSetWindowPos,
    ORD_WinSetWindowText,
    ORD_WinShowWindow,
    ORD_WinIsWindow,
    ORD_WinWindowFromId,
    ORD_WinWindowFromPoint,
    ORD_WinPostMsg,
    ORD_WinEnableWindow,
    ORD_WinEnableWindowUpdate,
    ORD_WinIsWindowEnabled,
    ORD_WinIsWindowShowing,
    ORD_WinIsWindowVisible,
    ORD_WinQueryWindowPtr,
    ORD_WinQueryWindowULong,
    ORD_WinQueryWindowUShort,
    ORD_WinSetWindowBits,
    ORD_WinSetWindowPtr,
    ORD_WinSetWindowULong,
    ORD_WinSetWindowUShort,
    ORD_WinQueryDesktopWindow,
    ORD_WinSetActiveWindow,
    ORD_DosQueryModFromEIP,
    ORD_Dos32QueryHeaderInfo,
    ORD_DosTmrQueryFreq,
    ORD_DosTmrQueryTime,
    ORD_WinQueryActiveDesktopPathname,
    ORD_WinInvalidateRect,
    ORD_WinCreateFrameControls,
    ORD_WinQueryClipbrdFmtInfo,
    ORD_WinQueryClipbrdOwner,
    ORD_WinQueryClipbrdViewer,
    ORD_WinQueryClipbrdData,
    ORD_WinOpenClipbrd,
    ORD_WinCloseClipbrd,
    ORD_WinSetClipbrdData,
    ORD_WinSetClipbrdOwner,
    ORD_WinSetClipbrdViewer,
    ORD_WinEnumClipbrdFmts, 
    ORD_WinEmptyClipbrd,
    ORD_WinAddAtom,
    ORD_WinFindAtom,
    ORD_WinDeleteAtom,
    ORD_WinQueryAtomUsage,
    ORD_WinQueryAtomName,
    ORD_WinQueryAtomLength,
    ORD_WinQuerySystemAtomTable,
    ORD_WinCreateAtomTable,
    ORD_WinDestroyAtomTable,
    ORD_WinOpenWindowDC,
    ORD_DevOpenDC,
    ORD_DevQueryCaps,
    ORD_DevCloseDC,
    ORD_WinMessageBox,
    ORD_WinMessageBox2,
    ORD_WinQuerySysValue,
    ORD_WinSetSysValue,
    ORD_WinAlarm,
    ORD_WinFlashWindow,
    ORD_WinLoadPointer,
    ORD_WinQuerySysPointer,
    ORD_DosReplaceModule,
    ORD_DosPerfSysCall,
    ORD_RexxRegisterSubcomExe,
    ORD_NENTRIES
};

/* RET: return type, AT: argument signature in (), ARGS: should be in () */
#define CallORD(ret,o,at,args)	(((ret (*)at) loadByOrdinal(o, 1))args)
#define DeclFuncByORD(ret,name,o,at,args)	\
  ret name at { return CallORD(ret,o,at,args); }
#define DeclVoidFuncByORD(name,o,at,args)	\
  void name at { CallORD(void,o,at,args); }

/* This function returns error code on error, and saves the error info in $^E and Perl_rc */
#define DeclOSFuncByORD_native(ret,name,o,at,args)	\
  ret name at { unsigned long rc; return CheckOSError(CallORD(ret,o,at,args)); }

/* These functions return false on error, and save the error info in $^E and Perl_rc */
#define DeclOSFuncByORD(ret,name,o,at,args)	\
  ret name at { unsigned long rc; return !CheckOSError(CallORD(ret,o,at,args)); }
#define DeclWinFuncByORD(ret,name,o,at,args)	\
  ret name at { return SaveWinError(CallORD(ret,o,at,args)); }

#define AssignFuncPByORD(p,o)	(*(Perl_PFN*)&(p) = (loadByOrdinal(o, 1)))

/* This flavor caches the procedure pointer (named as p__Win#name) locally */
#define DeclWinFuncByORD_CACHE(ret,name,o,at,args)	\
	DeclWinFuncByORD_CACHE_r(ret,name,o,at,args,0,1)

/* This flavor may reset the last error before the call (if ret=0 may be OK) */
#define DeclWinFuncByORD_CACHE_resetError(ret,name,o,at,args)	\
	DeclWinFuncByORD_CACHE_r(ret,name,o,at,args,1,1)

/* Two flavors below do the same as above, but do not auto-croak */
/* This flavor caches the procedure pointer (named as p__Win#name) locally */
#define DeclWinFuncByORD_CACHE_survive(ret,name,o,at,args)	\
	DeclWinFuncByORD_CACHE_r(ret,name,o,at,args,0,0)

/* This flavor may reset the last error before the call (if ret=0 may be OK) */
#define DeclWinFuncByORD_CACHE_resetError_survive(ret,name,o,at,args)	\
	DeclWinFuncByORD_CACHE_r(ret,name,o,at,args,1,0)

#define DeclWinFuncByORD_CACHE_r(ret,name,o,at,args,r,die)	\
  static ret (*CAT2(p__Win,name)) at;				\
  static ret name at {						\
	if (!CAT2(p__Win,name))					\
	    AssignFuncPByORD(CAT2(p__Win,name), o);		\
	if (r) ResetWinError();					\
	return SaveCroakWinError(CAT2(p__Win,name) args, die, "[Win]", STRINGIFY(name)); }

/* These flavors additionally assume ORD is name with prepended ORD_Win  */
#define DeclWinFunc_CACHE(ret,name,at,args)	\
	DeclWinFuncByORD_CACHE(ret,name,CAT2(ORD_Win,name),at,args)
#define DeclWinFunc_CACHE_resetError(ret,name,at,args)	\
	DeclWinFuncByORD_CACHE_resetError(ret,name,CAT2(ORD_Win,name),at,args)
#define DeclWinFunc_CACHE_survive(ret,name,at,args)	\
	DeclWinFuncByORD_CACHE_survive(ret,name,CAT2(ORD_Win,name),at,args)
#define DeclWinFunc_CACHE_resetError_survive(ret,name,at,args)	\
	DeclWinFuncByORD_CACHE_resetError_survive(ret,name,CAT2(ORD_Win,name),at,args)

void ResetWinError(void);
void CroakWinError(int die, char *name);

enum Perlos2_handler { 
  Perlos2_handler_mangle = 1,
  Perlos2_handler_perl_sh,
  Perlos2_handler_perllib_from,
  Perlos2_handler_perllib_to,
};
enum dir_subst_e {
    dir_subst_fatal = 1,
    dir_subst_pathlike = 2
};

extern int Perl_OS2_handler_install(void *handler, enum Perlos2_handler how);
extern char *dir_subst(char *s, unsigned int l, char *b, unsigned int bl, enum dir_subst_e flags, char *msg);
extern unsigned long fill_extLibpath(int type, char *pre, char *post, int replace, char *msg);

#define PERLLIB_MANGLE(s, n) perllib_mangle((s), (n))
char *perllib_mangle(char *, unsigned int);

#define fork	fork_with_resources

#ifdef EINTR				/* x2p do not include perl.h!!! */
static __inline__ int
my_select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)
{
  if (nfds == 0 && timeout && (_emx_env & 0x200)) {
    if (async_mssleep(1000 * timeout->tv_sec + (timeout->tv_usec + 500)/1000, 500))
      return 0;
    errno = EINTR;
    return -1;
  }
  return select(nfds, readfds, writefds, exceptfds, timeout);
}

#define select		my_select
#endif


typedef int (*Perl_PFN)();
Perl_PFN loadByOrdinal(enum entries_ordinals ord, int fail);
extern const Perl_PFN * const pExtFCN;
char *os2error(int rc);
int os2_stat(const char *name, struct stat *st);
int fork_with_resources();
int setpriority(int which, int pid, int val);
int getpriority(int which /* ignored */, int pid);

void croak_with_os2error(char *s) __attribute__((noreturn));

/* void return value */
#define os2cp_croak(rc,msg)	(CheckOSError(rc) && (croak_with_os2error(msg),0))

/* propagates rc */
#define os2win_croak(rc,msg)						\
	SaveCroakWinError((expr), 1 /* die */, /* no prefix */, (msg))

/* propagates rc; use with functions which may return 0 on success */
#define os2win_croak_0OK(rc,msg)					\
	SaveCroakWinError((ResetWinError, (expr)),			\
			  1 /* die */, /* no prefix */, (msg))

#ifdef PERL_CORE
int os2_do_spawn(pTHX_ char *cmd);
int os2_do_aspawn(pTHX_ SV *really, SV **vmark, SV **vsp);
#endif

#ifndef LOG_DAEMON

/* Replacement for syslog.h */
#  define	LOG_EMERG	0	/* system is unusable */
#  define	LOG_ALERT	1	/* action must be taken immediately */
#  define	LOG_CRIT	2	/* critical conditions */
#  define	LOG_ERR	3	/* error conditions */
#  define	LOG_WARNING	4	/* warning conditions */
#  define	LOG_NOTICE	5	/* normal but significant condition */
#  define	LOG_INFO	6	/* informational */
#  define	LOG_DEBUG	7	/* debug-level messages */

#  define	LOG_PRIMASK	0x007	/* mask to extract priority part (internal) */
				/* extract priority */
#  define	LOG_PRI(p)	((p) & LOG_PRIMASK)
#  define	LOG_MAKEPRI(fac, pri)	(((fac) << 3) | (pri))

/* facility codes */
#  define	LOG_KERN	(0<<3)	/* kernel messages */
#  define	LOG_USER	(1<<3)	/* random user-level messages */
#  define	LOG_MAIL	(2<<3)	/* mail system */
#  define	LOG_DAEMON	(3<<3)	/* system daemons */
#  define	LOG_AUTH	(4<<3)	/* security/authorization messages */
#  define	LOG_SYSLOG	(5<<3)	/* messages generated internally by syslogd */
#  define	LOG_LPR	(6<<3)	/* line printer subsystem */
#  define	LOG_NEWS	(7<<3)	/* network news subsystem */
#  define	LOG_UUCP	(8<<3)	/* UUCP subsystem */
#  define	LOG_CRON	(15<<3)	/* clock daemon */
	/* other codes through 15 reserved for system use */
#  define	LOG_LOCAL0	(16<<3)	/* reserved for local use */
#  define	LOG_LOCAL1	(17<<3)	/* reserved for local use */
#  define	LOG_LOCAL2	(18<<3)	/* reserved for local use */
#  define	LOG_LOCAL3	(19<<3)	/* reserved for local use */
#  define	LOG_LOCAL4	(20<<3)	/* reserved for local use */
#  define	LOG_LOCAL5	(21<<3)	/* reserved for local use */
#  define	LOG_LOCAL6	(22<<3)	/* reserved for local use */
#  define	LOG_LOCAL7	(23<<3)	/* reserved for local use */

#  define	LOG_NFACILITIES	24	/* current number of facilities */
#  define	LOG_FACMASK	0x03f8	/* mask to extract facility part */
				/* facility of pri */
#  define	LOG_FAC(p)	(((p) & LOG_FACMASK) >> 3)

/*
 * arguments to setlogmask.
 */
#  define	LOG_MASK(pri)	(1 << (pri))		/* mask for one priority */
#  define	LOG_UPTO(pri)	((1 << ((pri)+1)) - 1)	/* all priorities through pri */

/*
 * Option flags for openlog.
 *
 * LOG_ODELAY no longer does anything.
 * LOG_NDELAY is the inverse of what it used to be.
 */
#  define	LOG_PID		0x01	/* log the pid with each message */
#  define	LOG_CONS	0x02	/* log on the console if errors in sending */
#  define	LOG_ODELAY	0x04	/* delay open until first syslog() (default) */
#  define	LOG_NDELAY	0x08	/* don't delay open */
#  define	LOG_NOWAIT	0x10	/* don't wait for console forks: DEPRECATED */
#  define	LOG_PERROR	0x20	/* log to stderr as well */

#endif

/* ************************************************* */
#ifndef MAKEPLINFOSEG

/* From $DDK\base32\rel\os2c\include\base\os2\16bit\infoseg.h + typedefs */

/*
 * The structure below defines the content and organization of the system
 * information segment (InfoSeg).  The actual table is statically defined in
 * SDATA.ASM.  Ring 0, read/write access is obtained by the clock device
 * driver using the DevHlp GetDOSVar function.  (GetDOSVar returns a ring 0,
 * read-only selector to all other requestors.)
 *
 * In order to prevent an errant process from destroying the infoseg, two
 * identical global infosegs are maintained.  One is in the tiled shared
 * arena and is accessible in user mode (and therefore can potentially be
 * overwritten from ring 2), and the other is in the system arena and is
 * accessible only in kernel mode.  All kernel code (except the clock driver)
 * is responsible for updating BOTH copies of the infoseg.  The copy kept
 * in the system arena is addressable as DOSGROUP:SISData, and the copy
 * in the shared arena is addressable via a system arena alias.  16:16 and
 * 0:32 pointers to the alias are stored in _Sis2.
 */

typedef struct InfoSegGDT {

/* Time (offset 0x00) */

unsigned long   SIS_BigTime;    /* Time from 1-1-1970 in seconds */
unsigned long   SIS_MsCount;    /* Freerunning milliseconds counter */
unsigned char   SIS_HrsTime;    /* Hours */
unsigned char   SIS_MinTime;    /* Minutes */
unsigned char   SIS_SecTime;    /* Seconds */
unsigned char   SIS_HunTime;    /* Hundredths of seconds */
unsigned short  SIS_TimeZone;   /* Timezone in min from GMT (Set to EST) */
unsigned short  SIS_ClkIntrvl;  /* Timer interval (units=0.0001 secs) */

/* Date (offset 0x10) */

unsigned char   SIS_DayDate;    /* Day-of-month (1-31) */
unsigned char   SIS_MonDate;    /* Month (1-12) */
unsigned short  SIS_YrsDate;    /* Year (>= 1980) */
unsigned char   SIS_DOWDate;    /* Day-of-week (1-1-80 = Tues = 3) */

/* Version (offset 0x15) */

unsigned char   SIS_VerMajor;   /* Major version number */
unsigned char   SIS_VerMinor;   /* Minor version number */
unsigned char   SIS_RevLettr;   /* Revision letter */

/* System Status (offset 0x18) */

unsigned char   SIS_CurScrnGrp; /* Fgnd screen group # */
unsigned char   SIS_MaxScrnGrp; /* Maximum number of screen groups */
unsigned char   SIS_HugeShfCnt; /* Shift count for huge segments */
unsigned char   SIS_ProtMdOnly; /* Protect-mode-only indicator */
unsigned short  SIS_FgndPID;    /* Foreground process ID */

/* Scheduler Parms (offset 0x1E) */

unsigned char   SIS_Dynamic;    /* Dynamic variation flag (1=enabled) */
unsigned char   SIS_MaxWait;    /* Maxwait (seconds) */
unsigned short  SIS_MinSlice;   /* Minimum timeslice (milliseconds) */
unsigned short  SIS_MaxSlice;   /* Maximum timeslice (milliseconds) */

/* Boot Drive (offset 0x24) */

unsigned short  SIS_BootDrv;    /* Drive from which system was booted */

/* RAS Major Event Code Table (offset 0x26) */

unsigned char   SIS_mec_table[32]; /* Table of RAS Major Event Codes (MECs) */

/* Additional Session Data (offset 0x46) */

unsigned char   SIS_MaxVioWinSG;  /* Max. no. of VIO windowable SG's */
unsigned char   SIS_MaxPresMgrSG; /* Max. no. of Presentation Manager SG's */

/* Error logging Information (offset 0x48) */

unsigned short  SIS_SysLog;     /* Error Logging Status */

/* Additional RAS Information (offset 0x4A) */

unsigned short  SIS_MMIOBase;   /* Memory mapped I/O selector */
unsigned long   SIS_MMIOAddr;   /* Memory mapped I/O address  */

/* Additional 2.0 Data (offset 0x50) */

unsigned char   SIS_MaxVDMs;      /* Max. no. of Virtual DOS machines */
unsigned char   SIS_Reserved;

unsigned char   SIS_perf_mec_table[32]; /* varga 6/5/97 Table of Performance Major Event Codes (MECS) varga*/
} GINFOSEG, *PGINFOSEG;

#define SIS_LEN         sizeof(struct InfoSegGDT)

/*
 *      InfoSeg LDT Data Segment Structure
 *
 * The structure below defines the content and organization of the system
 * information in a special per-process segment to be accessible by the
 * process through the LDT (read-only).
 *
 * As in the global infoseg, two copies of the current processes local
 * infoseg exist, one accessible in both user and kernel mode, the other
 * only in kernel mode.  Kernel code is responsible for updating BOTH copies.
 * Pointers to the local infoseg copy are stored in _Lis2.
 *
 * Note that only the currently running process has an extra copy of the
 * local infoseg.  The copy is done at context switch time.
 */

typedef struct InfoSegLDT {
unsigned short  LIS_CurProcID;  /* Current process ID */
unsigned short  LIS_ParProcID;  /* Process ID of parent */
unsigned short  LIS_CurThrdPri; /* Current thread priority */
unsigned short  LIS_CurThrdID;  /* Current thread ID */
unsigned short  LIS_CurScrnGrp; /* Screengroup */
unsigned char   LIS_ProcStatus; /* Process status bits */
unsigned char   LIS_fillbyte1;  /* filler byte */
unsigned short  LIS_Fgnd;       /* Current process is in foreground */
unsigned char   LIS_ProcType;   /* Current process type */
unsigned char   LIS_fillbyte2;  /* filler byte */

unsigned short  LIS_AX;         /* @@@@V1 Environment selector */
unsigned short  LIS_BX;         /* @@@@V1 Offset of command line start */
unsigned short  LIS_CX;         /* @@@@V1 Length of Data Segment */
unsigned short  LIS_DX;         /* @@@@V1 STACKSIZE from the .EXE file */
unsigned short  LIS_SI;         /* @@@@V1 HEAPSIZE  from the .EXE file */
unsigned short  LIS_DI;         /* @@@@V1 Module handle of the application */
unsigned short  LIS_DS;         /* @@@@V1 Data Segment Handle of application */

unsigned short  LIS_PackSel;    /* First tiled selector in this EXE */
unsigned short  LIS_PackShrSel; /* First selector above shared arena */
unsigned short  LIS_PackPckSel; /* First selector above packed arena */
/* #ifdef SMP */
unsigned long   LIS_pTIB;       /* Pointer to TIB */
unsigned long   LIS_pPIB;       /* Pointer to PIB */
/* #endif */
} LINFOSEG, *PLINFOSEG;

#define LIS_LEN         sizeof(struct InfoSegLDT)


/*
 *      Process Type codes
 *
 *      These are the definitions for the codes stored
 *      in the LIS_ProcType field in the local infoseg.
 */

#define         LIS_PT_FULLSCRN 0       /* Full screen app. */
#define         LIS_PT_REALMODE 1       /* Real mode process */
#define         LIS_PT_VIOWIN   2       /* VIO windowable app. */
#define         LIS_PT_PRESMGR  3       /* Presentation Manager app. */
#define         LIS_PT_DETACHED 4       /* Detached app. */


/*
 *
 *      Process Status Bit Definitions
 *
 */

#define         LIS_PS_EXITLIST 0x01    /* In exitlist handler */


/*
 *      Flags equates for the Global Info Segment
 *      SIS_SysLog  WORD in Global Info Segment
 *
 *        xxxx xxxx xxxx xxx0         Error Logging Disabled
 *        xxxx xxxx xxxx xxx1         Error Logging Enabled
 *
 *        xxxx xxxx xxxx xx0x         Error Logging not available
 *        xxxx xxxx xxxx xx1x         Error Logging available
 */

#define LF_LOGENABLE    0x0001          /* Logging enabled */
#define LF_LOGAVAILABLE 0x0002          /* Logging available */

#define MAKEPGINFOSEG(sel)  ((PGINFOSEG)MAKEP(sel, 0))
#define MAKEPLINFOSEG(sel)  ((PLINFOSEG)MAKEP(sel, 0))

#endif	/* ndef(MAKEPLINFOSEG) */

/* ************************************************************ */
#define Dos32QuerySysState DosQuerySysState
#define QuerySysState(flags, pid, buf, bufsz) \
	Dos32QuerySysState(flags, 0,  pid, 0, buf, bufsz)

#define QSS_PROCESS	1
#define QSS_MODULE	4
#define QSS_SEMAPHORES	2
#define QSS_FILE	8		/* Buggy until fixpack18 */
#define QSS_SHARED	16

#ifdef _OS2_H

APIRET APIENTRY Dos32QuerySysState(ULONG func,ULONG arg1,ULONG pid,
			ULONG _res_,PVOID buf,ULONG bufsz);
typedef struct {
	ULONG	threadcnt;
	ULONG	proccnt;
	ULONG	modulecnt;
} QGLOBAL, *PQGLOBAL;

typedef struct {
	ULONG	rectype;
	USHORT	threadid;
	USHORT	slotid;
	ULONG	sleepid;
	ULONG	priority;
	ULONG	systime;
	ULONG	usertime;
	UCHAR	state;
	UCHAR	_reserved1_;	/* padding to ULONG */
	USHORT	_reserved2_;	/* padding to ULONG */
} QTHREAD, *PQTHREAD;

typedef struct {
	USHORT	sfn;
	USHORT	refcnt;
	USHORT	flags1;
	USHORT	flags2;
	USHORT	accmode1;
	USHORT	accmode2;
	ULONG	filesize;
	USHORT  volhnd;
	USHORT	attrib;
	USHORT	_reserved_;
} QFDS, *PQFDS;

typedef struct qfile {
	ULONG		rectype;
	struct qfile	*next;
	ULONG		opencnt;
	PQFDS		filedata;
	char		name[1];
} QFILE, *PQFILE;

typedef struct {
	ULONG	rectype;
	PQTHREAD threads;
	USHORT	pid;
	USHORT	ppid;
	ULONG	type;
	ULONG	state;
	ULONG	sessid;
	USHORT	hndmod;
	USHORT	threadcnt;
	ULONG	privsem32cnt;
	ULONG	_reserved2_;
	USHORT	sem16cnt;
	USHORT	dllcnt;
	USHORT	shrmemcnt;
	USHORT	fdscnt;
	PUSHORT	sem16s;
	PUSHORT	dlls;
	PUSHORT	shrmems;
	PUSHORT	fds;
} QPROCESS, *PQPROCESS;

typedef struct sema {
	struct sema *next;
	USHORT	refcnt;
	UCHAR	sysflags;
	UCHAR	sysproccnt;
	ULONG	_reserved1_;
	USHORT	index;
	CHAR	name[1];
} QSEMA, *PQSEMA;

typedef struct {
	ULONG	rectype;
	ULONG	_reserved1_;
	USHORT	_reserved2_;
	USHORT	syssemidx;
	ULONG	index;
	QSEMA	sema;
} QSEMSTRUC, *PQSEMSTRUC;

typedef struct {
	USHORT	pid;
	USHORT	opencnt;
} QSEMOWNER32, *PQSEMOWNER32;

typedef struct {
	PQSEMOWNER32	own;
	PCHAR		name;
	PVOID		semrecs; /* array of associated sema's */
	USHORT		flags;
	USHORT		semreccnt;
	USHORT		waitcnt;
	USHORT		_reserved_;	/* padding to ULONG */
} QSEMSMUX32, *PQSEMSMUX32;

typedef struct {
	PQSEMOWNER32	own;
	PCHAR		name;
	PQSEMSMUX32	mux;
	USHORT		flags;
	USHORT		postcnt;
} QSEMEV32, *PQSEMEV32;

typedef struct {
	PQSEMOWNER32	own;
	PCHAR		name;
	PQSEMSMUX32	mux;
	USHORT		flags;
	USHORT		refcnt;
	USHORT		thrdnum;
	USHORT		_reserved_;	/* padding to ULONG */
} QSEMMUX32, *PQSEMMUX32;

typedef struct semstr32 {
	struct semstr *next;
	QSEMEV32 evsem;
	QSEMMUX32  muxsem;
	QSEMSMUX32 smuxsem;
} QSEMSTRUC32, *PQSEMSTRUC32;

typedef struct shrmem {
	struct shrmem *next;
	USHORT	hndshr;
	USHORT	selshr;
	USHORT	refcnt;
	CHAR	name[1];
} QSHRMEM, *PQSHRMEM;

typedef struct module {
	struct module *next;
	USHORT	hndmod;
	USHORT	type;
	ULONG	refcnt;
	ULONG	segcnt;
	PVOID	_reserved_;
	PCHAR	name;
	USHORT	modref[1];
} QMODULE, *PQMODULE;

typedef struct {
	PQGLOBAL	gbldata;
	PQPROCESS	procdata;
	PQSEMSTRUC	semadata;
	PQSEMSTRUC32	sem32data;
	PQSHRMEM	shrmemdata;
	PQMODULE	moddata;
	PVOID		_reserved2_;
	PQFILE		filedata;
} QTOPLEVEL, *PQTOPLEVEL;
/* ************************************************************ */

PQTOPLEVEL get_sysinfo(ULONG pid, ULONG flags);

#endif /* _OS2_H */

@


1.9
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d985 1
a985 1
unsigned char   SIS_perf_mec_table[32]; /* varga 6/5/97 Table of Perfomance Major Event Codes (MECS) varga*/
d1041 1
a1041 1
 *      These are the definitons for the codes stored
@


1.8
log
@merge local changes into perl-5.8.3
@
text
@d109 1
a109 1
#if defined(USE_5005THREADS) || defined(USE_ITHREADS)
d212 1
a212 1
#else /* USE_5005THREADS */
a215 2

#endif /* USE_5005THREADS */
d226 1
a226 1
#  define PERL_SYS_INIT3(argcp, argvp, envp)	\
d231 2
a232 1
    Perl_OS2_init3(*envp, xreg, 0)
d234 1
a234 1
#  define PERL_SYS_INIT(argcp, argvp)  {	\
d238 2
a239 1
    Perl_OS2_init3(NULL, xreg, 0)
d243 1
a243 1
#  define PERL_SYS_INIT3(argcp, argvp, envp)	\
d245 3
a247 2
    Perl_OS2_init3(*envp, xreg, 0)
#  define PERL_SYS_INIT(argcp, argvp)	{	\
d249 2
a250 1
    Perl_OS2_init3(NULL, xreg, 0)
d259 1
d265 2
a266 2
/* This one should come in pair with PERL_SYS_INIT() and in the same block */
#define PERL_SYS_TERM()							\
d274 1
a274 1
/* #define PERL_SYS_TERM() STMT_START {	\
d315 4
a318 1
/* Cannot prototype with I32 at this point. */
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d323 5
d368 1
a368 1
#define usleep(usec)	((void)_sleep2(((usec)+500)/1000))
d759 15
d784 1
a784 1
    if (DosSleep(1000 * timeout->tv_sec	+ (timeout->tv_usec + 500)/1000) == 0)
d807 12
d887 186
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d17 5
d52 2
d109 1
a109 1
#ifdef USE_5005THREADS
d194 1
a194 1
	( DosAllocThreadLocalMemory(1,(U32*)keyp)	\
d230 1
d310 1
a310 1
extern char *tmppath;
d323 22
d363 3
d437 1
a437 1
#define Fstat(fd,bufptr)   fstat((fd),(bufptr))
d440 1
d444 1
a444 1
#define S_IFBLK		0120000
d447 3
d476 1
d500 1
d542 1
a542 1
#define CheckOSError(expr) (!(rc = (expr)) ? 0 : (FillOSError(rc), 1))
d653 41
d704 5
a708 1
/* These functions return false on error, and save the error info in $^E */
d757 19
d781 1
d785 2
d789 1
a789 1
int os2_do_aspawn(pTHX_ SV *really, void **vmark, void **vsp);
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d2 2
d22 17
d102 1
a102 1
#ifdef USE_THREADS
d205 1
a205 1
#else /* USE_THREADS */
d210 1
a210 1
#endif /* USE_THREADS */
d213 2
d216 1
a216 1
/* XXX This code hideously puts env inside: */
d218 1
d220 3
a222 1
#  define PERL_SYS_INIT3(argcp, argvp, envp) STMT_START {	\
d225 4
a228 2
    Perl_OS2_init(*envp);	} STMT_END
#  define PERL_SYS_INIT(argcp, argvp) STMT_START {	\
d231 2
a232 1
    Perl_OS2_init(NULL);	} STMT_END
d234 7
a240 4
#  define PERL_SYS_INIT3(argcp, argvp, envp) STMT_START {	\
    Perl_OS2_init(*envp);	} STMT_END
#  define PERL_SYS_INIT(argcp, argvp) STMT_START {	\
    Perl_OS2_init(NULL);	} STMT_END
d243 16
a262 2
#define PERL_SYS_TERM()		MALLOC_TERM

d310 11
d345 5
d360 2
d375 20
d505 3
d509 5
a513 1
#define CheckWinError(expr) ((expr) ? 0: (FillWinError, 1))
d517 9
d528 1
a528 2
#define FillWinError (	init_PMWIN_entries(),				\
			Perl_rc=(*PMWIN_entries.GetLastError)(perl_hab_GET()),\
d535 135
d673 3
d677 72
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d85 3
d96 1
a96 1
	    croak("panic: MUTEX_INIT: rc=%i", rc);		\
d102 1
a102 1
	    croak("panic: MUTEX_LOCK: rc=%i", rc);		\
d108 1
a108 1
	    croak("panic: MUTEX_UNLOCK: rc=%i", rc);		\
d114 1
a114 1
	    croak("panic: MUTEX_DESTROY: rc=%i", rc);		\
d121 1
a121 1
	    croak("panic: COND_INIT: rc=%i", rc);		\
d126 2
a127 2
	if ((rc = DosPostEventSem(*(c))) && rc != OS2_ERROR_ALREADY_POSTED)		\
	    croak("panic: COND_SIGNAL, rc=%ld", rc);		\
d133 1
a133 1
	    croak("panic: COND_BROADCAST, rc=%i", rc);		\
d138 1
a138 1
	    croak("panic: COND_WAIT");				\
d146 2
a147 2
	if ((rc = SignalObjectAndWait(*(m),*(c),INFINITE,FALSE)))\
	    croak("panic: COND_WAIT");				\
d155 1
a155 1
	    croak("panic: COND_DESTROY, rc=%i", rc);		\
a157 1
#define dTHR struct thread *thr = THR
d164 1
a164 1
#else
d167 6
a172 2
#  define pthread_key_create(keyp,flag)	(DosAllocThreadLocalMemory(1,(U32*)keyp) ? croak("LocalMemory"),1 : 0)
#endif
d182 1
a182 1
#endif 
d186 6
a191 1
#endif 
d245 12
d259 1
a259 1
PerlIO *my_syspopen(char *cmd, char *mode);
d264 2
d275 2
d288 2
d313 3
d387 1
a387 1
char	*os2_execname(void);
d401 2
d410 1
a410 1
#define OS2_XS_init() (*OS2_Perl_data.xs_init)()
d427 8
a434 3
#define FillWinError (Perl_severity = ERRORIDSEV(Perl_rc),		\
			Perl_rc = ERRORIDERROR(Perl_rc)),		\
			os2_setsyserrno(Perl_rc)
@


1.3
log
@perl5.005_03 (stock)
@
text
@d22 1
a22 1
 *	use the routine my_binmode(FILE *fp, char iotype) to insure
d67 1
a67 1
#define ABORT() kill(getpid(),SIGABRT);
d71 7
d158 10
a167 2
#define pthread_getspecific(k)		(*_threadstore())
#define pthread_setspecific(k,v)	(*_threadstore()=v,0)
a168 1
#define pthread_key_create(keyp,flag)	(*keyp=_gettid(),0)
d186 5
a190 1
#ifdef __EMX__
d194 4
a197 2
    Perl_OS2_init(env);	} STMT_END
#else  /* Compiling embedded Perl with non-EMX compiler */
d199 4
a202 1
    Perl_OS2_init(env);	} STMT_END
d205 1
a233 1
#define TMPPATH tmppath
d242 3
d321 4
d333 1
d339 37
d377 8
d391 1
a391 2
#define FillOSError(rc) (Perl_rc = rc,					\
			errno = errno_isOS2,				\
d393 3
a395 9
#define FillWinError (Perl_rc = WinGetLastError(Perl_hab),		\
			errno = errno_isOS2,				\
			Perl_severity = ERRORIDSEV(Perl_rc),		\
			Perl_rc = ERRORIDERROR(Perl_rc)) 
#define Acquire_hab() if (!Perl_HAB_set) {				\
	   Perl_hab = WinInitialize(0);					\
	   if (!Perl_hab) die("WinInitialize failed");			\
	   set_Perl_HAB_f;						\
	}
d415 1
a415 1
#ifdef _OS2EMX_H
d573 1
a573 1
#endif /* _OS2EMX_H */
@


1.2
log
@perl 5.004_04
@
text
@d28 8
d75 92
d172 2
a173 1
#define PERL_SYS_INIT(argcp, argvp) STMT_START {	\
d177 6
a182 2

#define PERL_SYS_TERM()
@


1.1
log
@Initial revision
@
text
@d17 35
d61 8
a68 1
#define BIT_BUCKET "/dev/null"  /* Will this work? */
d70 1
a70 1
void Perl_OS2_init();
d75 1
a75 1
    Perl_OS2_init();	} STMT_END
d79 25
a103 1
#define dXSUB_SYS int fake = OS2_XS_init()
d108 11
d129 6
a146 1
#  define _filbuf _fill
d161 1
d173 3
d177 3
d188 2
d194 5
a198 2
#define hab		((HAB)OS2_Perl_data->phab)
#define OS2_Perl_flag	(OS2_Perl_data->flag)
d200 3
a202 3
#define Perl_HAB_set	(OS2_Perl_flag & Perl_HAB_set_f)
#define set_Perl_HAB_f	(OS2_Perl_flag |= Perl_HAB_set_f)
#define set_Perl_HAB(h) (set_Perl_HAB_f, hab = h)
d204 197
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@a16 43
#define HAS_DLERROR
#define HAS_WAITPID_RUNTIME (_emx_env & 0x200)

/* USEMYBINMODE
 *	This symbol, if defined, indicates that the program should
 *	use the routine my_binmode(FILE *fp, char iotype) to insure
 *	that a file is in "binary" mode -- that is, that no translation
 *	of bytes occurs on read or write operations.
 */
#undef USEMYBINMODE

/* Stat_t:
 *	This symbol holds the type used to declare buffers for information
 *	returned by stat().  It's usually just struct stat.  It may be necessary
 *	to include <sys/stat.h> and <sys/types.h> to get any typedef'ed
 *	information.
 */
#define Stat_t struct stat

/* USE_STAT_RDEV:
 *	This symbol is defined if this system has a stat structure declaring
 *	st_rdev
 */
#define USE_STAT_RDEV 	/**/

/* ACME_MESS:
 *	This symbol, if defined, indicates that error messages should be 
 *	should be generated in a format that allows the use of the Acme
 *	GUI/editor's autofind feature.
 */
#undef ACME_MESS	/**/

/* ALTERNATE_SHEBANG:
 *	This symbol, if defined, contains a "magic" string which may be used
 *	as the first line of a Perl program designed to be executed directly
 *	by name, instead of the standard Unix #!.  If ALTERNATE_SHEBANG
 *	begins with a character other then #, then Perl will only treat
 *	it as a command line if if finds the string "perl" in the first
 *	word; otherwise it's treated as the first line of code in the script.
 *	(IOW, Perl won't hand off to another interpreter via an alternate
 *	shebang sequence that might be legal Perl code.)
 */
#define ALTERNATE_SHEBANG "extproc "
d26 1
a26 1
#define BIT_BUCKET "/dev/nul"  /* Will this work? */
d28 1
a28 98
#if defined(I_SYS_UN) && !defined(TCPIPV4)
/* It is not working without TCPIPV4 defined. */
# undef I_SYS_UN
#endif 

#ifdef USE_THREADS

#define OS2_ERROR_ALREADY_POSTED 299	/* Avoid os2.h */

extern int rc;

#define MUTEX_INIT(m) \
    STMT_START {						\
	int rc;							\
	if ((rc = _rmutex_create(m,0)))				\
	    croak("panic: MUTEX_INIT: rc=%i", rc);		\
    } STMT_END
#define MUTEX_LOCK(m) \
    STMT_START {						\
	int rc;							\
	if ((rc = _rmutex_request(m,_FMR_IGNINT)))		\
	    croak("panic: MUTEX_LOCK: rc=%i", rc);		\
    } STMT_END
#define MUTEX_UNLOCK(m) \
    STMT_START {						\
	int rc;							\
	if ((rc = _rmutex_release(m)))				\
	    croak("panic: MUTEX_UNLOCK: rc=%i", rc);		\
    } STMT_END
#define MUTEX_DESTROY(m) \
    STMT_START {						\
	int rc;							\
	if ((rc = _rmutex_close(m)))				\
	    croak("panic: MUTEX_DESTROY: rc=%i", rc);		\
    } STMT_END

#define COND_INIT(c) \
    STMT_START {						\
	int rc;							\
	if ((rc = DosCreateEventSem(NULL,c,0,0)))		\
	    croak("panic: COND_INIT: rc=%i", rc);		\
    } STMT_END
#define COND_SIGNAL(c) \
    STMT_START {						\
	int rc;							\
	if ((rc = DosPostEventSem(*(c))) && rc != OS2_ERROR_ALREADY_POSTED)		\
	    croak("panic: COND_SIGNAL, rc=%ld", rc);		\
    } STMT_END
#define COND_BROADCAST(c) \
    STMT_START {						\
	int rc;							\
	if ((rc = DosPostEventSem(*(c))) && rc != OS2_ERROR_ALREADY_POSTED)\
	    croak("panic: COND_BROADCAST, rc=%i", rc);		\
    } STMT_END
/* #define COND_WAIT(c, m) \
    STMT_START {						\
	if (WaitForSingleObject(*(c),INFINITE) == WAIT_FAILED)	\
	    croak("panic: COND_WAIT");				\
    } STMT_END
*/
#define COND_WAIT(c, m) os2_cond_wait(c,m)

#define COND_WAIT_win32(c, m) \
    STMT_START {						\
	int rc;							\
	if ((rc = SignalObjectAndWait(*(m),*(c),INFINITE,FALSE)))\
	    croak("panic: COND_WAIT");				\
	else							\
	    MUTEX_LOCK(m);					\
    } STMT_END
#define COND_DESTROY(c) \
    STMT_START {						\
	int rc;							\
	if ((rc = DosCloseEventSem(*(c))))			\
	    croak("panic: COND_DESTROY, rc=%i", rc);		\
    } STMT_END
/*#define THR ((struct thread *) TlsGetValue(PL_thr_key))
#define dTHR struct thread *thr = THR
*/

#define pthread_getspecific(k)		(*_threadstore())
#define pthread_setspecific(k,v)	(*_threadstore()=v,0)
#define pthread_self()			_gettid()
#define pthread_key_create(keyp,flag)	(*keyp=_gettid(),0)
#define YIELD				DosSleep(0)

#ifdef PTHREADS_INCLUDED		/* For ./x2p stuff. */
int pthread_join(pthread_t tid, void **status);
int pthread_detach(pthread_t tid);
int pthread_create(pthread_t *tid, const pthread_attr_t *attr,
		   void *(*start_routine)(void*), void *arg);
#endif 

#define THREADS_ELSEWHERE

#endif 
 
void Perl_OS2_init(char **);
d30 1
a30 4
/* XXX This code hideously puts env inside: */

#ifdef __EMX__
#  define PERL_SYS_INIT(argcp, argvp) STMT_START {	\
d33 1
a33 10
    Perl_OS2_init(env);	} STMT_END
#else  /* Compiling embedded Perl with non-EMX compiler */
#  define PERL_SYS_INIT(argcp, argvp) STMT_START {	\
    Perl_OS2_init(env);	} STMT_END
#  define PERL_CALLCONV _System
#endif
#define PERL_SYS_TERM()		MALLOC_TERM

/* #define PERL_SYS_TERM() STMT_START {	\
    if (Perl_HAB_set) WinTerminate(Perl_hab);	} STMT_END */
d35 1
a35 1
#define dXSUB_SYS OS2_XS_init()
d37 1
a37 20
#ifdef PERL_IS_AOUT
/* #  define HAS_FORK */
/* #  define HIDEMYMALLOC */
/* #  define PERL_SBRK_VIA_MALLOC */ /* gets off-page sbrk... */
#else /* !PERL_IS_AOUT */
#  ifndef PERL_FOR_X2P
#    ifdef EMX_BAD_SBRK
#      define USE_PERL_SBRK
#    endif 
#  else
#    define PerlIO FILE
#  endif 
#  define SYSTEM_ALLOC(a) sys_alloc(a)

void *sys_alloc(int size);

#endif /* !PERL_IS_AOUT */
#if !defined(PERL_CORE) && !defined(PerlIO) /* a2p */
#  define PerlIO FILE
#endif 
a41 11
PerlIO *my_syspopen(char *cmd, char *mode);
/* Cannot prototype with I32 at this point. */
int my_syspclose(PerlIO *f);
FILE *my_tmpfile (void);
char *my_tmpnam (char *);

#define tmpfile	my_tmpfile
#define tmpnam	my_tmpnam
#define isatty	_isterm
#define rand	random
#define srand	srandom
a51 6
#define flock	my_flock

void *emx_calloc (size_t, size_t);
void emx_free (void *);
void *emx_malloc (size_t);
void *emx_realloc (void *, size_t);
d64 1
a78 1
#define Mkdir(path,mode)   mkdir((path),(mode))
a89 1
#define Mkdir(path,mode)   mkdir((path),(mode))
a92 5
/* With SD386 it is impossible to debug register variables. */
#if !defined(PERL_IS_AOUT) && defined(DEBUGGING) && !defined(register)
#  define register
#endif

a98 2
  unsigned long rc;
  unsigned long severity;
d103 2
a104 5
#define Perl_hab		((HAB)OS2_Perl_data.phab)
#define Perl_rc			(OS2_Perl_data.rc)
#define Perl_severity		(OS2_Perl_data.severity)
#define errno_isOS2		12345678
#define OS2_Perl_flags	(OS2_Perl_data.flags)
d106 3
a108 3
#define Perl_HAB_set	(OS2_Perl_flags & Perl_HAB_set_f)
#define set_Perl_HAB_f	(OS2_Perl_flags |= Perl_HAB_set_f)
#define set_Perl_HAB(h) (set_Perl_HAB_f, Perl_hab = h)
a109 197
/* The expressions below return true on error. */
/* INCL_DOSERRORS needed. rc should be declared outside. */
#define CheckOSError(expr) (!(rc = (expr)) ? 0 : (FillOSError(rc), 1))
/* INCL_WINERRORS needed. */
#define SaveWinError(expr) ((expr) ? : (FillWinError, 0))
#define CheckWinError(expr) ((expr) ? 0: (FillWinError, 1))
#define FillOSError(rc) (Perl_rc = rc,					\
			errno = errno_isOS2,				\
			Perl_severity = SEVERITY_ERROR) 
#define FillWinError (Perl_rc = WinGetLastError(Perl_hab),		\
			errno = errno_isOS2,				\
			Perl_severity = ERRORIDSEV(Perl_rc),		\
			Perl_rc = ERRORIDERROR(Perl_rc)) 
#define Acquire_hab() if (!Perl_HAB_set) {				\
	   Perl_hab = WinInitialize(0);					\
	   if (!Perl_hab) die("WinInitialize failed");			\
	   set_Perl_HAB_f;						\
	}

#define STATIC_FILE_LENGTH 127

#define PERLLIB_MANGLE(s, n) perllib_mangle((s), (n))
char *perllib_mangle(char *, unsigned int);

char *os2error(int rc);

/* ************************************************************ */
#define Dos32QuerySysState DosQuerySysState
#define QuerySysState(flags, pid, buf, bufsz) \
	Dos32QuerySysState(flags, 0,  pid, 0, buf, bufsz)

#define QSS_PROCESS	1
#define QSS_MODULE	4
#define QSS_SEMAPHORES	2
#define QSS_FILE	8		/* Buggy until fixpack18 */
#define QSS_SHARED	16

#ifdef _OS2EMX_H

APIRET APIENTRY Dos32QuerySysState(ULONG func,ULONG arg1,ULONG pid,
			ULONG _res_,PVOID buf,ULONG bufsz);
typedef struct {
	ULONG	threadcnt;
	ULONG	proccnt;
	ULONG	modulecnt;
} QGLOBAL, *PQGLOBAL;

typedef struct {
	ULONG	rectype;
	USHORT	threadid;
	USHORT	slotid;
	ULONG	sleepid;
	ULONG	priority;
	ULONG	systime;
	ULONG	usertime;
	UCHAR	state;
	UCHAR	_reserved1_;	/* padding to ULONG */
	USHORT	_reserved2_;	/* padding to ULONG */
} QTHREAD, *PQTHREAD;

typedef struct {
	USHORT	sfn;
	USHORT	refcnt;
	USHORT	flags1;
	USHORT	flags2;
	USHORT	accmode1;
	USHORT	accmode2;
	ULONG	filesize;
	USHORT  volhnd;
	USHORT	attrib;
	USHORT	_reserved_;
} QFDS, *PQFDS;

typedef struct qfile {
	ULONG		rectype;
	struct qfile	*next;
	ULONG		opencnt;
	PQFDS		filedata;
	char		name[1];
} QFILE, *PQFILE;

typedef struct {
	ULONG	rectype;
	PQTHREAD threads;
	USHORT	pid;
	USHORT	ppid;
	ULONG	type;
	ULONG	state;
	ULONG	sessid;
	USHORT	hndmod;
	USHORT	threadcnt;
	ULONG	privsem32cnt;
	ULONG	_reserved2_;
	USHORT	sem16cnt;
	USHORT	dllcnt;
	USHORT	shrmemcnt;
	USHORT	fdscnt;
	PUSHORT	sem16s;
	PUSHORT	dlls;
	PUSHORT	shrmems;
	PUSHORT	fds;
} QPROCESS, *PQPROCESS;

typedef struct sema {
	struct sema *next;
	USHORT	refcnt;
	UCHAR	sysflags;
	UCHAR	sysproccnt;
	ULONG	_reserved1_;
	USHORT	index;
	CHAR	name[1];
} QSEMA, *PQSEMA;

typedef struct {
	ULONG	rectype;
	ULONG	_reserved1_;
	USHORT	_reserved2_;
	USHORT	syssemidx;
	ULONG	index;
	QSEMA	sema;
} QSEMSTRUC, *PQSEMSTRUC;

typedef struct {
	USHORT	pid;
	USHORT	opencnt;
} QSEMOWNER32, *PQSEMOWNER32;

typedef struct {
	PQSEMOWNER32	own;
	PCHAR		name;
	PVOID		semrecs; /* array of associated sema's */
	USHORT		flags;
	USHORT		semreccnt;
	USHORT		waitcnt;
	USHORT		_reserved_;	/* padding to ULONG */
} QSEMSMUX32, *PQSEMSMUX32;

typedef struct {
	PQSEMOWNER32	own;
	PCHAR		name;
	PQSEMSMUX32	mux;
	USHORT		flags;
	USHORT		postcnt;
} QSEMEV32, *PQSEMEV32;

typedef struct {
	PQSEMOWNER32	own;
	PCHAR		name;
	PQSEMSMUX32	mux;
	USHORT		flags;
	USHORT		refcnt;
	USHORT		thrdnum;
	USHORT		_reserved_;	/* padding to ULONG */
} QSEMMUX32, *PQSEMMUX32;

typedef struct semstr32 {
	struct semstr *next;
	QSEMEV32 evsem;
	QSEMMUX32  muxsem;
	QSEMSMUX32 smuxsem;
} QSEMSTRUC32, *PQSEMSTRUC32;

typedef struct shrmem {
	struct shrmem *next;
	USHORT	hndshr;
	USHORT	selshr;
	USHORT	refcnt;
	CHAR	name[1];
} QSHRMEM, *PQSHRMEM;

typedef struct module {
	struct module *next;
	USHORT	hndmod;
	USHORT	type;
	ULONG	refcnt;
	ULONG	segcnt;
	PVOID	_reserved_;
	PCHAR	name;
	USHORT	modref[1];
} QMODULE, *PQMODULE;

typedef struct {
	PQGLOBAL	gbldata;
	PQPROCESS	procdata;
	PQSEMSTRUC	semadata;
	PQSEMSTRUC32	sem32data;
	PQSHRMEM	shrmemdata;
	PQMODULE	moddata;
	PVOID		_reserved2_;
	PQFILE		filedata;
} QTOPLEVEL, *PQTOPLEVEL;
/* ************************************************************ */

PQTOPLEVEL get_sysinfo(ULONG pid, ULONG flags);

#endif /* _OS2EMX_H */

@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d22 1
a22 1
 *	use the routine my_binmode(FILE *fp, char iotype, int mode) to insure
d67 1
a67 1
#define ABORT() kill(PerlProc_getpid(),SIGABRT);
a70 7
/* Apparently TCPIPV4 defines may be included even with only IAK present */

#if !defined(NO_TCPIPV4) && !defined(TCPIPV4)
#  define TCPIPV4
#  define TCPIPV4_FORCED		/* Just in case */
#endif

d151 2
a152 10
#ifdef USE_SLOW_THREAD_SPECIFIC
#  define pthread_getspecific(k)	(*_threadstore())
#  define pthread_setspecific(k,v)	(*_threadstore()=v,0)
#  define pthread_key_create(keyp,flag)	(*keyp=_gettid(),0)
#else
#  define pthread_getspecific(k)	(*(k))
#  define pthread_setspecific(k,v)	(*(k)=(v),0)
#  define pthread_key_create(keyp,flag)	(DosAllocThreadLocalMemory(1,(U32*)keyp) ? croak("LocalMemory"),1 : 0)
#endif
#define pthread_key_delete(keyp)
d154 1
d172 1
a172 5
#ifdef PERL_CORE
#  define PERL_SYS_INIT3(argcp, argvp, envp) STMT_START {	\
    _response(argcp, argvp);			\
    _wildcard(argcp, argvp);			\
    Perl_OS2_init(*envp);	} STMT_END
d176 2
a177 4
    Perl_OS2_init(NULL);	} STMT_END
#else  /* Compiling embedded Perl or Perl extension */
#  define PERL_SYS_INIT3(argcp, argvp, envp) STMT_START {	\
    Perl_OS2_init(*envp);	} STMT_END
d179 1
a179 4
    Perl_OS2_init(NULL);	} STMT_END
#endif

#ifndef __EMX__
a181 1

d210 1
a218 3
#undef L_tmpnam
#define L_tmpnam MAXPATHLEN

a294 4
  unsigned long	phmq;			/* Handle to message queue */
  unsigned long	phmq_refcnt;
  unsigned long	phmq_servers;
  unsigned long	initial_mode;		/* VIO etc. mode we were started in */
a302 1
#define errno_isOS2_set		12345679
a307 37
#define _obtain_Perl_HAB (init_PMWIN_entries(),				\
			  Perl_hab = (*PMWIN_entries.Initialize)(0),	\
			  set_Perl_HAB_f, Perl_hab)
#define perl_hab_GET()	(Perl_HAB_set ? Perl_hab : _obtain_Perl_HAB)
#define Acquire_hab()	perl_hab_GET()
#define Perl_hmq	((HMQ)OS2_Perl_data.phmq)
#define Perl_hmq_refcnt	(OS2_Perl_data.phmq_refcnt)
#define Perl_hmq_servers	(OS2_Perl_data.phmq_servers)
#define Perl_os2_initial_mode	(OS2_Perl_data.initial_mode)

unsigned long Perl_hab_GET();
unsigned long Perl_Register_MQ(int serve);
void	Perl_Deregister_MQ(int serve);
int	Perl_Serve_Messages(int force);
/* Cannot prototype with I32 at this point. */
int	Perl_Process_Messages(int force, long *cntp);
char	*os2_execname(void);

struct _QMSG;
struct PMWIN_entries_t {
    unsigned long (*Initialize)( unsigned long fsOptions );
    unsigned long (*CreateMsgQueue)(unsigned long hab, long cmsg);
    int (*DestroyMsgQueue)(unsigned long hmq);
    int (*PeekMsg)(unsigned long hab, struct _QMSG *pqmsg,
		   unsigned long hwndFilter, unsigned long msgFilterFirst,
		   unsigned long msgFilterLast, unsigned long fl);
    int (*GetMsg)(unsigned long hab, struct _QMSG *pqmsg,
		  unsigned long hwndFilter, unsigned long msgFilterFirst,
		  unsigned long msgFilterLast);
    void * (*DispatchMsg)(unsigned long hab, struct _QMSG *pqmsg);
};
extern struct PMWIN_entries_t PMWIN_entries;
void init_PMWIN_entries(void);

#define perl_hmq_GET(serve)	Perl_Register_MQ(serve)
#define perl_hmq_UNSET(serve)	Perl_Deregister_MQ(serve)

a308 8

#if _EMX_CRT_REV_ >= 60
# define os2_setsyserrno(rc)	(Perl_rc = rc, errno = errno_isOS2_set, \
				_setsyserrno(rc))
#else
# define os2_setsyserrno(rc)	(Perl_rc = rc, errno = errno_isOS2)
#endif

d315 2
a316 1
#define FillOSError(rc) (os2_setsyserrno(rc),				\
d318 9
a326 3
#define FillWinError (Perl_severity = ERRORIDSEV(Perl_rc),		\
			Perl_rc = ERRORIDERROR(Perl_rc)),		\
			os2_setsyserrno(Perl_rc)
d346 1
a346 1
#ifdef _OS2_H
d504 1
a504 1
#endif /* _OS2_H */
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@a84 3
#define do_spawn(a)      os2_do_spawn(aTHX_ (a))
#define do_aspawn(a,b,c) os2_do_aspawn(aTHX_ (a),(b),(c))

d93 1
a93 1
	    Perl_croak_nocontext("panic: MUTEX_INIT: rc=%i", rc);	\
d99 1
a99 1
	    Perl_croak_nocontext("panic: MUTEX_LOCK: rc=%i", rc);	\
d105 1
a105 1
	    Perl_croak_nocontext("panic: MUTEX_UNLOCK: rc=%i", rc);	\
d111 1
a111 1
	    Perl_croak_nocontext("panic: MUTEX_DESTROY: rc=%i", rc);	\
d118 1
a118 1
	    Perl_croak_nocontext("panic: COND_INIT: rc=%i", rc);	\
d123 2
a124 2
	if ((rc = DosPostEventSem(*(c))) && rc != OS2_ERROR_ALREADY_POSTED)\
	    Perl_croak_nocontext("panic: COND_SIGNAL, rc=%ld", rc);	\
d130 1
a130 1
	    Perl_croak_nocontext("panic: COND_BROADCAST, rc=%i", rc);	\
d135 1
a135 1
	    Perl_croak_nocontext("panic: COND_WAIT");		\
d143 2
a144 2
	if ((rc = SignalObjectAndWait(*(m),*(c),INFINITE,FALSE)))	\
	    Perl_croak_nocontext("panic: COND_WAIT");			\
d152 1
a152 1
	    Perl_croak_nocontext("panic: COND_DESTROY, rc=%i", rc);	\
d155 1
d162 1
a162 1
#else /* USE_SLOW_THREAD_SPECIFIC */
d165 2
a166 6
#  define pthread_key_create(keyp,flag)			\
	( DosAllocThreadLocalMemory(1,(U32*)keyp)	\
	  ? Perl_croak_nocontext("LocalMemory"),1	\
	  : 0						\
	)
#endif /* USE_SLOW_THREAD_SPECIFIC */
d176 1
a176 1
#endif /* PTHREAD_INCLUDED */
d180 1
a180 6
#else /* USE_THREADS */

#define do_spawn(a)      os2_do_spawn(a)
#define do_aspawn(a,b,c) os2_do_aspawn((a),(b),(c))

#endif /* USE_THREADS */
a233 12
/* os2ish is used from a2p/a2p.h without pTHX/pTHX_ first being
 * defined.  Hack around this to get us to compile.
*/
#ifdef PTHX_UNUSED
# ifndef pTHX
#  define pTHX
# endif
# ifndef pTHX_
#  define pTHX_
# endif
#endif

d236 1
a236 1
PerlIO *my_syspopen(pTHX_ char *cmd, char *mode);
a240 2
int my_mkdir (__const__ char *, long);
int my_rmdir (__const__ char *);
a249 2
#define strtoll	_strtoll
#define strtoull	_strtoull
a260 2
#define rmdir	my_rmdir
#define mkdir	my_mkdir
a283 3
/* ctermid is missing from emx0.9d */
char *ctermid(char *s);

d355 1
a355 1
char	*os2_execname(pTHX);
a368 2
    unsigned long (*GetLastError)(unsigned long hab);
    unsigned long (*CancelShutdown)(unsigned long hmq, unsigned long fCancelAlways);
d376 1
a376 1
#define OS2_XS_init() (*OS2_Perl_data.xs_init)(aTHX)
d393 3
a395 8

/* At this moment init_PMWIN_entries() should be a nop (WinInitialize should
   be called already, right?), so we do not risk stepping over our own error */
#define FillWinError (	init_PMWIN_entries(),				\
			Perl_rc=(*PMWIN_entries.GetLastError)(perl_hab_GET()),\
			Perl_severity = ERRORIDSEV(Perl_rc),		\
			Perl_rc = ERRORIDERROR(Perl_rc),		\
			os2_setsyserrno(Perl_rc))
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@a1 2
#include <io.h>
/* #include <sys/select.h> */
a19 17
/* HAS_PASSWD
 *	This symbol, if defined, indicates that the getpwnam() and
 *	getpwuid() routines are available to get password entries.
 *	The getpwent() has a separate definition, HAS_GETPWENT.
 */
#define HAS_PASSWD

/* HAS_GROUP
 *	This symbol, if defined, indicates that the getgrnam() and
 *	getgrgid() routines are available to get group entries.
 *	The getgrent() has a separate definition, HAS_GETGRENT.
 */
#define HAS_GROUP
#define HAS_GETGRENT			/* fake */
#define HAS_SETGRENT			/* fake */
#define HAS_ENDGRENT			/* fake */

d83 1
a83 1
#ifdef USE_5005THREADS
d186 1
a186 1
#else /* USE_5005THREADS */
d191 1
a191 1
#endif /* USE_5005THREADS */
a193 2
void Perl_OS2_init3(char **envp, void **excH, int flags);
void Perl_OS2_term(void **excH, int exitstatus, int flags);
d195 1
a195 1
/* The code without INIT3 hideously puts env inside: */
a196 1
/* These ones should be in the same block as PERL_SYS_TERM() */
d198 1
a198 3

#  define PERL_SYS_INIT3(argcp, argvp, envp)	\
  { void *xreg[2];				\
d201 2
a202 4
    Perl_OS2_init3(*envp, xreg, 0)

#  define PERL_SYS_INIT(argcp, argvp)  {	\
  { void *xreg[2];				\
d205 1
a205 2
    Perl_OS2_init3(NULL, xreg, 0)

d207 4
a210 7

#  define PERL_SYS_INIT3(argcp, argvp, envp)	\
  { void *xreg[2];				\
    Perl_OS2_init3(*envp, xreg, 0)
#  define PERL_SYS_INIT(argcp, argvp)	{	\
  { void *xreg[2];				\
    Perl_OS2_init3(NULL, xreg, 0)
a212 16
#define FORCE_EMX_DEINIT_EXIT		1
#define FORCE_EMX_DEINIT_CRT_TERM	2
#define FORCE_EMX_DEINIT_RUN_ATEXIT	4

#define PERL_SYS_TERM2(xreg,flags)					\
  Perl_OS2_term(xreg, 0, flags);					\
  MALLOC_TERM

#define PERL_SYS_TERM1(xreg)						\
     Perl_OS2_term(xreg, 0, FORCE_EMX_DEINIT_RUN_ATEXIT)

/* This one should come in pair with PERL_SYS_INIT() and in the same block */
#define PERL_SYS_TERM()							\
     PERL_SYS_TERM1(xreg);						\
  }

d217 2
a265 11
struct passwd *my_getpwent (void);
void my_setpwent (void);
void my_endpwent (void);
char *gcvt_os2(double value, int digits, char *buffer);

struct group *getgrent (void);
void setgrent (void);
void endgrent (void);

struct passwd *my_getpwuid (uid_t);
struct passwd *my_getpwnam (__const__ char *);
a289 5
#define setpwent	my_setpwent
#define getpwent	my_getpwent
#define endpwent	my_endpwent
#define getpwuid	my_getpwuid
#define getpwnam	my_getpwnam
a299 2
#include <fcntl.h>
#include <sys/stat.h>
a312 20
#define PERLIO_IS_BINMODE_FD(fd) _PERLIO_IS_BINMODE_FD(fd)

#ifdef __GNUG__
# define HAS_BOOL 
#endif
#ifndef HAS_BOOL
# define bool char
# define HAS_BOOL 1
#endif

#include <emx/io.h> /* for _fd_flags() prototype */

static inline bool
_PERLIO_IS_BINMODE_FD(int fd)
{
    int *pflags = _fd_flags(fd);

    return pflags && (*pflags) & O_BINARY;
}

d423 1
a424 8

/* This form propagates the return value, setting $^E if needed */
#define SaveWinError(expr) ((expr) ? : (FillWinError, 0))

/* This form propagates the return value, dieing with $^E if needed */
#define SaveCroakWinError(expr,die,name1,name2)		\
  ((expr) ? : (CroakWinError(die,name1 name2), 0))

a427 9
#define WinError_2_Perl_rc	\
 (	init_PMWIN_entries(),	\
	Perl_rc=(*PMWIN_entries.GetLastError)(perl_hab_GET()) )

/* Calling WinGetLastError() resets the error code of the current thread.
   Since for some Win* API return value 0 is normal, one needs to call
   this before calling them to distinguish normal and anomalous returns.  */
/*#define ResetWinError()	WinError_2_Perl_rc */

d430 2
a431 1
#define FillWinError (	WinError_2_Perl_rc,				\
a437 135
    /* This should match loadOrdinals[] array in os2.c */
enum entries_ordinals {
    ORD_DosQueryExtLibpath,
    ORD_DosSetExtLibpath,
    ORD_DosVerifyPidTid,
    ORD_SETHOSTENT,
    ORD_SETNETENT, 
    ORD_SETPROTOENT,
    ORD_SETSERVENT,
    ORD_GETHOSTENT,
    ORD_GETNETENT, 
    ORD_GETPROTOENT,
    ORD_GETSERVENT,
    ORD_ENDHOSTENT,
    ORD_ENDNETENT,
    ORD_ENDPROTOENT,
    ORD_ENDSERVENT,
    ORD_WinInitialize,
    ORD_WinCreateMsgQueue,
    ORD_WinDestroyMsgQueue,
    ORD_WinPeekMsg,
    ORD_WinGetMsg,
    ORD_WinDispatchMsg,
    ORD_WinGetLastError,
    ORD_WinCancelShutdown,
    ORD_RexxStart,
    ORD_RexxVariablePool,
    ORD_RexxRegisterFunctionExe,
    ORD_RexxDeregisterFunction,
    ORD_DOSSMSETTITLE,
    ORD_PRF32QUERYPROFILESIZE,
    ORD_PRF32OPENPROFILE,
    ORD_PRF32CLOSEPROFILE,
    ORD_PRF32QUERYPROFILE,
    ORD_PRF32RESET,
    ORD_PRF32QUERYPROFILEDATA,
    ORD_PRF32WRITEPROFILEDATA,

    ORD_WinChangeSwitchEntry,
    ORD_WinQuerySwitchEntry,
    ORD_WinQuerySwitchHandle,
    ORD_WinQuerySwitchList,
    ORD_WinSwitchToProgram,
    ORD_WinBeginEnumWindows,
    ORD_WinEndEnumWindows,
    ORD_WinEnumDlgItem,
    ORD_WinGetNextWindow,
    ORD_WinIsChild,
    ORD_WinQueryActiveWindow,
    ORD_WinQueryClassName,
    ORD_WinQueryFocus,
    ORD_WinQueryWindow,
    ORD_WinQueryWindowPos,
    ORD_WinQueryWindowProcess,
    ORD_WinQueryWindowText,
    ORD_WinQueryWindowTextLength,
    ORD_WinSetFocus,
    ORD_WinSetWindowPos,
    ORD_WinSetWindowText,
    ORD_WinShowWindow,
    ORD_WinIsWindow,
    ORD_WinWindowFromId,
    ORD_WinWindowFromPoint,
    ORD_WinPostMsg,
    ORD_WinEnableWindow,
    ORD_WinEnableWindowUpdate,
    ORD_WinIsWindowEnabled,
    ORD_WinIsWindowShowing,
    ORD_WinIsWindowVisible,
    ORD_WinQueryWindowPtr,
    ORD_WinQueryWindowULong,
    ORD_WinQueryWindowUShort,
    ORD_WinSetWindowBits,
    ORD_WinSetWindowPtr,
    ORD_WinSetWindowULong,
    ORD_WinSetWindowUShort,
    ORD_WinQueryDesktopWindow,
    ORD_WinSetActiveWindow,
    ORD_DosQueryModFromEIP,
    ORD_NENTRIES
};

/* RET: return type, AT: argument signature in (), ARGS: should be in () */
#define CallORD(ret,o,at,args)	(((ret (*)at) loadByOrdinal(o, 1))args)
#define DeclFuncByORD(ret,name,o,at,args)	\
  ret name at { return CallORD(ret,o,at,args); }
#define DeclVoidFuncByORD(name,o,at,args)	\
  void name at { CallORD(void,o,at,args); }

/* These functions return false on error, and save the error info in $^E */
#define DeclOSFuncByORD(ret,name,o,at,args)	\
  ret name at { unsigned long rc; return !CheckOSError(CallORD(ret,o,at,args)); }
#define DeclWinFuncByORD(ret,name,o,at,args)	\
  ret name at { return SaveWinError(CallORD(ret,o,at,args)); }

#define AssignFuncPByORD(p,o)	(*(Perl_PFN*)&(p) = (loadByOrdinal(o, 1)))

/* This flavor caches the procedure pointer (named as p__Win#name) locally */
#define DeclWinFuncByORD_CACHE(ret,name,o,at,args)	\
	DeclWinFuncByORD_CACHE_r(ret,name,o,at,args,0,1)

/* This flavor may reset the last error before the call (if ret=0 may be OK) */
#define DeclWinFuncByORD_CACHE_resetError(ret,name,o,at,args)	\
	DeclWinFuncByORD_CACHE_r(ret,name,o,at,args,1,1)

/* Two flavors below do the same as above, but do not auto-croak */
/* This flavor caches the procedure pointer (named as p__Win#name) locally */
#define DeclWinFuncByORD_CACHE_survive(ret,name,o,at,args)	\
	DeclWinFuncByORD_CACHE_r(ret,name,o,at,args,0,0)

/* This flavor may reset the last error before the call (if ret=0 may be OK) */
#define DeclWinFuncByORD_CACHE_resetError_survive(ret,name,o,at,args)	\
	DeclWinFuncByORD_CACHE_r(ret,name,o,at,args,1,0)

#define DeclWinFuncByORD_CACHE_r(ret,name,o,at,args,r,die)	\
  static ret (*CAT2(p__Win,name)) at;				\
  static ret name at {						\
	if (!CAT2(p__Win,name))					\
	    AssignFuncPByORD(CAT2(p__Win,name), o);		\
	if (r) ResetWinError();					\
	return SaveCroakWinError(CAT2(p__Win,name) args, die, "[Win]", STRINGIFY(name)); }

/* These flavors additionally assume ORD is name with prepended ORD_Win  */
#define DeclWinFunc_CACHE(ret,name,at,args)	\
	DeclWinFuncByORD_CACHE(ret,name,CAT2(ORD_Win,name),at,args)
#define DeclWinFunc_CACHE_resetError(ret,name,at,args)	\
	DeclWinFuncByORD_CACHE_resetError(ret,name,CAT2(ORD_Win,name),at,args)
#define DeclWinFunc_CACHE_survive(ret,name,at,args)	\
	DeclWinFuncByORD_CACHE_survive(ret,name,CAT2(ORD_Win,name),at,args)
#define DeclWinFunc_CACHE_resetError_survive(ret,name,at,args)	\
	DeclWinFuncByORD_CACHE_resetError_survive(ret,name,CAT2(ORD_Win,name),at,args)

void ResetWinError(void);
void CroakWinError(int die, char *name);

a440 3
typedef int (*Perl_PFN)();
Perl_PFN loadByOrdinal(enum entries_ordinals ord, int fail);
extern const Perl_PFN * const pExtFCN;
a441 72
int os2_stat(const char *name, struct stat *st);
int setpriority(int which, int pid, int val);
int getpriority(int which /* ignored */, int pid);

#ifdef PERL_CORE
int os2_do_spawn(pTHX_ char *cmd);
int os2_do_aspawn(pTHX_ SV *really, void **vmark, void **vsp);
#endif

#ifndef LOG_DAEMON

/* Replacement for syslog.h */
#  define	LOG_EMERG	0	/* system is unusable */
#  define	LOG_ALERT	1	/* action must be taken immediately */
#  define	LOG_CRIT	2	/* critical conditions */
#  define	LOG_ERR	3	/* error conditions */
#  define	LOG_WARNING	4	/* warning conditions */
#  define	LOG_NOTICE	5	/* normal but significant condition */
#  define	LOG_INFO	6	/* informational */
#  define	LOG_DEBUG	7	/* debug-level messages */

#  define	LOG_PRIMASK	0x007	/* mask to extract priority part (internal) */
				/* extract priority */
#  define	LOG_PRI(p)	((p) & LOG_PRIMASK)
#  define	LOG_MAKEPRI(fac, pri)	(((fac) << 3) | (pri))

/* facility codes */
#  define	LOG_KERN	(0<<3)	/* kernel messages */
#  define	LOG_USER	(1<<3)	/* random user-level messages */
#  define	LOG_MAIL	(2<<3)	/* mail system */
#  define	LOG_DAEMON	(3<<3)	/* system daemons */
#  define	LOG_AUTH	(4<<3)	/* security/authorization messages */
#  define	LOG_SYSLOG	(5<<3)	/* messages generated internally by syslogd */
#  define	LOG_LPR	(6<<3)	/* line printer subsystem */
#  define	LOG_NEWS	(7<<3)	/* network news subsystem */
#  define	LOG_UUCP	(8<<3)	/* UUCP subsystem */
#  define	LOG_CRON	(15<<3)	/* clock daemon */
	/* other codes through 15 reserved for system use */
#  define	LOG_LOCAL0	(16<<3)	/* reserved for local use */
#  define	LOG_LOCAL1	(17<<3)	/* reserved for local use */
#  define	LOG_LOCAL2	(18<<3)	/* reserved for local use */
#  define	LOG_LOCAL3	(19<<3)	/* reserved for local use */
#  define	LOG_LOCAL4	(20<<3)	/* reserved for local use */
#  define	LOG_LOCAL5	(21<<3)	/* reserved for local use */
#  define	LOG_LOCAL6	(22<<3)	/* reserved for local use */
#  define	LOG_LOCAL7	(23<<3)	/* reserved for local use */

#  define	LOG_NFACILITIES	24	/* current number of facilities */
#  define	LOG_FACMASK	0x03f8	/* mask to extract facility part */
				/* facility of pri */
#  define	LOG_FAC(p)	(((p) & LOG_FACMASK) >> 3)

/*
 * arguments to setlogmask.
 */
#  define	LOG_MASK(pri)	(1 << (pri))		/* mask for one priority */
#  define	LOG_UPTO(pri)	((1 << ((pri)+1)) - 1)	/* all priorities through pri */

/*
 * Option flags for openlog.
 *
 * LOG_ODELAY no longer does anything.
 * LOG_NDELAY is the inverse of what it used to be.
 */
#  define	LOG_PID		0x01	/* log the pid with each message */
#  define	LOG_CONS	0x02	/* log on the console if errors in sending */
#  define	LOG_ODELAY	0x04	/* delay open until first syslog() (default) */
#  define	LOG_NDELAY	0x08	/* don't delay open */
#  define	LOG_NOWAIT	0x10	/* don't wait for console forks: DEPRECATED */
#  define	LOG_PERROR	0x20	/* log to stderr as well */

#endif
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@a16 5
/* BIG_TIME:
 *	This symbol is defined if Time_t is an unsigned type on this system.
 */
#define BIG_TIME

a46 2
#define SOCKET_OPEN_MODE	"b"

d102 1
a102 1
#if defined(USE_5005THREADS) || defined(USE_ITHREADS)
d187 1
a187 1
	( DosAllocThreadLocalMemory(1,(unsigned long**)keyp)	\
a222 1
    MALLOC_CHECK_TAINT(*argcp, *argvp, *envp)	\
d302 1
a302 1
extern const char *tmppath;
a314 22
#define MAX_SLEEP	(((1<30) / (1000/4))-1)	/* 1<32 msec */

static __inline__ unsigned
my_sleep(unsigned sec)
{
  int remain;
  while (sec > MAX_SLEEP) {
    sec -= MAX_SLEEP;
    remain = sleep(MAX_SLEEP);
    if (remain)
      return remain + sec;
  }
  return sleep(sec);
}

#define sleep		my_sleep

#ifndef INCL_DOS
unsigned long DosSleep(unsigned long);
unsigned long DosAllocThreadLocalMemory (unsigned long cb, unsigned long **p);
#endif

a332 3
#define usleep(usec)	((void)_sleep2(((usec)+500)/1000))


d404 1
a404 1
#define Fstat(fd,bufptr)   os2_fstat((fd),(bufptr))
a406 1
#define chmod(path,mode)   os2_chmod((path),(mode))
d410 1
a410 1
#define S_IFBLK		0120000		/* Hacks to make things compile... */
a412 3
int os2_chmod(const char *name, int pmode);
int os2_fstat(int handle, struct stat *st);

a438 1
  unsigned long	morph_refcnt;
a461 1
#define Perl_morph_refcnt	(OS2_Perl_data.morph_refcnt)
d503 1
a503 1
#define CheckOSError(expr) ((rc = (expr)) ? (FillOSError(rc), rc) : 0)
a613 41
    ORD_Dos32QueryHeaderInfo,
    ORD_DosTmrQueryFreq,
    ORD_DosTmrQueryTime,
    ORD_WinQueryActiveDesktopPathname,
    ORD_WinInvalidateRect,
    ORD_WinCreateFrameControls,
    ORD_WinQueryClipbrdFmtInfo,
    ORD_WinQueryClipbrdOwner,
    ORD_WinQueryClipbrdViewer,
    ORD_WinQueryClipbrdData,
    ORD_WinOpenClipbrd,
    ORD_WinCloseClipbrd,
    ORD_WinSetClipbrdData,
    ORD_WinSetClipbrdOwner,
    ORD_WinSetClipbrdViewer,
    ORD_WinEnumClipbrdFmts, 
    ORD_WinEmptyClipbrd,
    ORD_WinAddAtom,
    ORD_WinFindAtom,
    ORD_WinDeleteAtom,
    ORD_WinQueryAtomUsage,
    ORD_WinQueryAtomName,
    ORD_WinQueryAtomLength,
    ORD_WinQuerySystemAtomTable,
    ORD_WinCreateAtomTable,
    ORD_WinDestroyAtomTable,
    ORD_WinOpenWindowDC,
    ORD_DevOpenDC,
    ORD_DevQueryCaps,
    ORD_DevCloseDC,
    ORD_WinMessageBox,
    ORD_WinMessageBox2,
    ORD_WinQuerySysValue,
    ORD_WinSetSysValue,
    ORD_WinAlarm,
    ORD_WinFlashWindow,
    ORD_WinLoadPointer,
    ORD_WinQuerySysPointer,
    ORD_DosReplaceModule,
    ORD_DosPerfSysCall,
    ORD_RexxRegisterSubcomExe,
d624 1
a624 5
/* This function returns error code on error, and saves the error info in $^E and Perl_rc */
#define DeclOSFuncByORD_native(ret,name,o,at,args)	\
  ret name at { unsigned long rc; return CheckOSError(CallORD(ret,o,at,args)); }

/* These functions return false on error, and save the error info in $^E and Perl_rc */
a672 19
#define fork	fork_with_resources

#ifdef EINTR				/* x2p do not include perl.h!!! */
static __inline__ int
my_select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)
{
  if (nfds == 0 && timeout && (_emx_env & 0x200)) {
    if (DosSleep(1000 * timeout->tv_sec	+ (timeout->tv_usec + 500)/1000) == 0)
      return 0;
    errno = EINTR;
    return -1;
  }
  return select(nfds, readfds, writefds, exceptfds, timeout);
}

#define select		my_select
#endif


a677 1
int fork_with_resources();
a680 2
void croak_with_os2error(char *s) __attribute__((noreturn));

d683 1
a683 1
int os2_do_aspawn(pTHX_ SV *really, SV **vmark, SV **vsp);
@


1.1.1.7
log
@perl 5.8.3 from CPAN
@
text
@a322 5
extern int async_mssleep(unsigned long ms, int switch_priority);
extern unsigned long msCounter(void);
extern unsigned long InfoTable(int local);
extern unsigned long find_myself(void);

d363 1
a363 1
#define usleep(usec)	((void)async_mssleep(((usec)+500)/1000, 500))
a753 15
enum Perlos2_handler { 
  Perlos2_handler_mangle = 1,
  Perlos2_handler_perl_sh,
  Perlos2_handler_perllib_from,
  Perlos2_handler_perllib_to,
};
enum dir_subst_e {
    dir_subst_fatal = 1,
    dir_subst_pathlike = 2
};

extern int Perl_OS2_handler_install(void *handler, enum Perlos2_handler how);
extern char *dir_subst(char *s, unsigned int l, char *b, unsigned int bl, enum dir_subst_e flags, char *msg);
extern unsigned long fill_extLibpath(int type, char *pre, char *post, int replace, char *msg);

d764 1
a764 1
    if (async_mssleep(1000 * timeout->tv_sec + (timeout->tv_usec + 500)/1000, 500))
a786 12
/* void return value */
#define os2cp_croak(rc,msg)	(CheckOSError(rc) && (croak_with_os2error(msg),0))

/* propagates rc */
#define os2win_croak(rc,msg)						\
	SaveCroakWinError((expr), 1 /* die */, /* no prefix */, (msg))

/* propagates rc; use with functions which may return 0 on success */
#define os2win_croak_0OK(rc,msg)					\
	SaveCroakWinError((ResetWinError, (expr)),			\
			  1 /* die */, /* no prefix */, (msg))

a854 186

/* ************************************************* */
#ifndef MAKEPLINFOSEG

/* From $DDK\base32\rel\os2c\include\base\os2\16bit\infoseg.h + typedefs */

/*
 * The structure below defines the content and organization of the system
 * information segment (InfoSeg).  The actual table is statically defined in
 * SDATA.ASM.  Ring 0, read/write access is obtained by the clock device
 * driver using the DevHlp GetDOSVar function.  (GetDOSVar returns a ring 0,
 * read-only selector to all other requestors.)
 *
 * In order to prevent an errant process from destroying the infoseg, two
 * identical global infosegs are maintained.  One is in the tiled shared
 * arena and is accessible in user mode (and therefore can potentially be
 * overwritten from ring 2), and the other is in the system arena and is
 * accessible only in kernel mode.  All kernel code (except the clock driver)
 * is responsible for updating BOTH copies of the infoseg.  The copy kept
 * in the system arena is addressable as DOSGROUP:SISData, and the copy
 * in the shared arena is addressable via a system arena alias.  16:16 and
 * 0:32 pointers to the alias are stored in _Sis2.
 */

typedef struct InfoSegGDT {

/* Time (offset 0x00) */

unsigned long   SIS_BigTime;    /* Time from 1-1-1970 in seconds */
unsigned long   SIS_MsCount;    /* Freerunning milliseconds counter */
unsigned char   SIS_HrsTime;    /* Hours */
unsigned char   SIS_MinTime;    /* Minutes */
unsigned char   SIS_SecTime;    /* Seconds */
unsigned char   SIS_HunTime;    /* Hundredths of seconds */
unsigned short  SIS_TimeZone;   /* Timezone in min from GMT (Set to EST) */
unsigned short  SIS_ClkIntrvl;  /* Timer interval (units=0.0001 secs) */

/* Date (offset 0x10) */

unsigned char   SIS_DayDate;    /* Day-of-month (1-31) */
unsigned char   SIS_MonDate;    /* Month (1-12) */
unsigned short  SIS_YrsDate;    /* Year (>= 1980) */
unsigned char   SIS_DOWDate;    /* Day-of-week (1-1-80 = Tues = 3) */

/* Version (offset 0x15) */

unsigned char   SIS_VerMajor;   /* Major version number */
unsigned char   SIS_VerMinor;   /* Minor version number */
unsigned char   SIS_RevLettr;   /* Revision letter */

/* System Status (offset 0x18) */

unsigned char   SIS_CurScrnGrp; /* Fgnd screen group # */
unsigned char   SIS_MaxScrnGrp; /* Maximum number of screen groups */
unsigned char   SIS_HugeShfCnt; /* Shift count for huge segments */
unsigned char   SIS_ProtMdOnly; /* Protect-mode-only indicator */
unsigned short  SIS_FgndPID;    /* Foreground process ID */

/* Scheduler Parms (offset 0x1E) */

unsigned char   SIS_Dynamic;    /* Dynamic variation flag (1=enabled) */
unsigned char   SIS_MaxWait;    /* Maxwait (seconds) */
unsigned short  SIS_MinSlice;   /* Minimum timeslice (milliseconds) */
unsigned short  SIS_MaxSlice;   /* Maximum timeslice (milliseconds) */

/* Boot Drive (offset 0x24) */

unsigned short  SIS_BootDrv;    /* Drive from which system was booted */

/* RAS Major Event Code Table (offset 0x26) */

unsigned char   SIS_mec_table[32]; /* Table of RAS Major Event Codes (MECs) */

/* Additional Session Data (offset 0x46) */

unsigned char   SIS_MaxVioWinSG;  /* Max. no. of VIO windowable SG's */
unsigned char   SIS_MaxPresMgrSG; /* Max. no. of Presentation Manager SG's */

/* Error logging Information (offset 0x48) */

unsigned short  SIS_SysLog;     /* Error Logging Status */

/* Additional RAS Information (offset 0x4A) */

unsigned short  SIS_MMIOBase;   /* Memory mapped I/O selector */
unsigned long   SIS_MMIOAddr;   /* Memory mapped I/O address  */

/* Additional 2.0 Data (offset 0x50) */

unsigned char   SIS_MaxVDMs;      /* Max. no. of Virtual DOS machines */
unsigned char   SIS_Reserved;

unsigned char   SIS_perf_mec_table[32]; /* varga 6/5/97 Table of Perfomance Major Event Codes (MECS) varga*/
} GINFOSEG, *PGINFOSEG;

#define SIS_LEN         sizeof(struct InfoSegGDT)

/*
 *      InfoSeg LDT Data Segment Structure
 *
 * The structure below defines the content and organization of the system
 * information in a special per-process segment to be accessible by the
 * process through the LDT (read-only).
 *
 * As in the global infoseg, two copies of the current processes local
 * infoseg exist, one accessible in both user and kernel mode, the other
 * only in kernel mode.  Kernel code is responsible for updating BOTH copies.
 * Pointers to the local infoseg copy are stored in _Lis2.
 *
 * Note that only the currently running process has an extra copy of the
 * local infoseg.  The copy is done at context switch time.
 */

typedef struct InfoSegLDT {
unsigned short  LIS_CurProcID;  /* Current process ID */
unsigned short  LIS_ParProcID;  /* Process ID of parent */
unsigned short  LIS_CurThrdPri; /* Current thread priority */
unsigned short  LIS_CurThrdID;  /* Current thread ID */
unsigned short  LIS_CurScrnGrp; /* Screengroup */
unsigned char   LIS_ProcStatus; /* Process status bits */
unsigned char   LIS_fillbyte1;  /* filler byte */
unsigned short  LIS_Fgnd;       /* Current process is in foreground */
unsigned char   LIS_ProcType;   /* Current process type */
unsigned char   LIS_fillbyte2;  /* filler byte */

unsigned short  LIS_AX;         /* @@@@V1 Environment selector */
unsigned short  LIS_BX;         /* @@@@V1 Offset of command line start */
unsigned short  LIS_CX;         /* @@@@V1 Length of Data Segment */
unsigned short  LIS_DX;         /* @@@@V1 STACKSIZE from the .EXE file */
unsigned short  LIS_SI;         /* @@@@V1 HEAPSIZE  from the .EXE file */
unsigned short  LIS_DI;         /* @@@@V1 Module handle of the application */
unsigned short  LIS_DS;         /* @@@@V1 Data Segment Handle of application */

unsigned short  LIS_PackSel;    /* First tiled selector in this EXE */
unsigned short  LIS_PackShrSel; /* First selector above shared arena */
unsigned short  LIS_PackPckSel; /* First selector above packed arena */
/* #ifdef SMP */
unsigned long   LIS_pTIB;       /* Pointer to TIB */
unsigned long   LIS_pPIB;       /* Pointer to PIB */
/* #endif */
} LINFOSEG, *PLINFOSEG;

#define LIS_LEN         sizeof(struct InfoSegLDT)


/*
 *      Process Type codes
 *
 *      These are the definitons for the codes stored
 *      in the LIS_ProcType field in the local infoseg.
 */

#define         LIS_PT_FULLSCRN 0       /* Full screen app. */
#define         LIS_PT_REALMODE 1       /* Real mode process */
#define         LIS_PT_VIOWIN   2       /* VIO windowable app. */
#define         LIS_PT_PRESMGR  3       /* Presentation Manager app. */
#define         LIS_PT_DETACHED 4       /* Detached app. */


/*
 *
 *      Process Status Bit Definitions
 *
 */

#define         LIS_PS_EXITLIST 0x01    /* In exitlist handler */


/*
 *      Flags equates for the Global Info Segment
 *      SIS_SysLog  WORD in Global Info Segment
 *
 *        xxxx xxxx xxxx xxx0         Error Logging Disabled
 *        xxxx xxxx xxxx xxx1         Error Logging Enabled
 *
 *        xxxx xxxx xxxx xx0x         Error Logging not available
 *        xxxx xxxx xxxx xx1x         Error Logging available
 */

#define LF_LOGENABLE    0x0001          /* Logging enabled */
#define LF_LOGAVAILABLE 0x0002          /* Logging available */

#define MAKEPGINFOSEG(sel)  ((PGINFOSEG)MAKEP(sel, 0))
#define MAKEPLINFOSEG(sel)  ((PLINFOSEG)MAKEP(sel, 0))

#endif	/* ndef(MAKEPLINFOSEG) */
@


1.1.1.8
log
@import perl 5.10.0 from CPAN
@
text
@d109 1
a109 1
#ifdef USE_ITHREADS
d212 1
a212 1
#else /* USE_ITHREADS */
d216 2
d228 1
a228 1
#  define PERL_SYS_INIT3_BODY(argcp, argvp, envp)	\
d233 1
a233 2
    Perl_OS2_init3(*envp, xreg, 0);		\
    PERLIO_INIT
d235 1
a235 1
#  define PERL_SYS_INIT_BODY(argcp, argvp)  {	\
d239 1
a239 2
    Perl_OS2_init3(NULL, xreg, 0);		\
    PERLIO_INIT
d243 1
a243 1
#  define PERL_SYS_INIT3_BODY(argcp, argvp, envp)	\
d245 2
a246 3
    Perl_OS2_init3(*envp, xreg, 0);		\
    PERLIO_INIT
#  define PERL_SYS_INIT_BODY(argcp, argvp)	{	\
d248 1
a248 2
    Perl_OS2_init3(NULL, xreg, 0);		\
    PERLIO_INIT
a256 1
  PERLIO_TERM;								\
d262 2
a263 2
/* This one should come in pair with PERL_SYS_INIT_BODY() and in the same block */
#define PERL_SYS_TERM_BODY()							\
d271 1
a271 1
/* #define PERL_SYS_TERM_BODY() STMT_START {	\
d312 1
a312 4
#ifdef PERL_CORE
/* Cannot prototype with I32, SV at this point (used in x2p too). */
PerlIO *my_syspopen4(pTHX_ char *cmd, char *mode, I32 cnt, SV** args);
#endif
@


1.1.1.9
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d985 1
a985 1
unsigned char   SIS_perf_mec_table[32]; /* varga 6/5/97 Table of Performance Major Event Codes (MECS) varga*/
d1041 1
a1041 1
 *      These are the definitions for the codes stored
@


