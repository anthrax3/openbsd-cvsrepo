head	1.7;
access;
symbols
	OPENBSD_4_8:1.6.0.8
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.4
	OPENBSD_4_7_BASE:1.6
	PERL_5_10_1:1.1.1.5
	OPENBSD_4_6:1.6.0.6
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.2
	OPENBSD_4_5_BASE:1.6
	PERL_5_10_0:1.1.1.5
	OPENBSD_4_4:1.5.0.20
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.18
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.16
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.14
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.12
	OPENBSD_4_0_BASE:1.5
	PERL_5_8_8:1.1.1.4
	OPENBSD_3_9:1.5.0.10
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.8
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.6
	OPENBSD_3_7_BASE:1.5
	PERL_5_8_6:1.1.1.4
	OPENBSD_3_6:1.5.0.4
	OPENBSD_3_6_BASE:1.5
	PERL_5_8_5:1.1.1.4
	PERL_5_8_3:1.1.1.4
	OPENBSD_3_5:1.5.0.2
	OPENBSD_3_5_BASE:1.5
	PERL_5_8_2:1.1.1.4
	OPENBSD_3_4:1.4.0.4
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.4.0.2
	OPENBSD_3_3_BASE:1.4
	PERL_5_8_0:1.1.1.3
	OPENBSD_3_2:1.3.0.12
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.10
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.8
	OPENBSD_3_0_BASE:1.3
	PERL_5_6_1:1.1.1.2
	OPENBSD_2_9:1.3.0.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	PERL_500503:1.1.1.1
	CPAN:1.1.1
	OPENBSD_2_5:1.1.0.6
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.4
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.2
	OPENBSD_2_3_BASE:1.1;
locks; strict;
comment	@# @;


1.7
date	2010.09.24.14.59.58;	author millert;	state dead;
branches;
next	1.6;

1.6
date	2008.09.29.17.36.15;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2003.12.03.03.02.43;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2002.10.27.22.25.32;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.06.17.07.09;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	99.04.29.22.52.05;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	97.11.30.07.58.38;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.29.22.40.29;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.04.06.16.10.17;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.10.27.22.15.03;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.12.03.02.44.18;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2008.09.29.17.18.49;	author millert;	state Exp;
branches;
next	;


desc
@@


1.7
log
@remove files no longer in perl 5.12.2 (or that have moved)
@
text
@#include <process.h>
#define INCL_DOS
#define INCL_DOSERRORS
#define INCL_DOSNLS
#define INCL_WINSWITCHLIST
#define INCL_WINWINDOWMGR
#define INCL_WININPUT
#define INCL_VIO
#define INCL_KBD
#define INCL_WINCLIPBOARD
#define INCL_WINATOM
#include <os2.h>

#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

static unsigned long
constant(char *name, int arg)
{
    errno = 0;
    if (name[0] == 'P' && name[1] == '_') {
	if (strEQ(name, "P_BACKGROUND"))
#ifdef P_BACKGROUND
	    return P_BACKGROUND;
#else
	    goto not_there;
#endif
	if (strEQ(name, "P_DEBUG"))
#ifdef P_DEBUG
	    return P_DEBUG;
#else
	    goto not_there;
#endif
	if (strEQ(name, "P_DEFAULT"))
#ifdef P_DEFAULT
	    return P_DEFAULT;
#else
	    goto not_there;
#endif
	if (strEQ(name, "P_DETACH"))
#ifdef P_DETACH
	    return P_DETACH;
#else
	    goto not_there;
#endif
	if (strEQ(name, "P_FOREGROUND"))
#ifdef P_FOREGROUND
	    return P_FOREGROUND;
#else
	    goto not_there;
#endif
	if (strEQ(name, "P_FULLSCREEN"))
#ifdef P_FULLSCREEN
	    return P_FULLSCREEN;
#else
	    goto not_there;
#endif
	if (strEQ(name, "P_MAXIMIZE"))
#ifdef P_MAXIMIZE
	    return P_MAXIMIZE;
#else
	    goto not_there;
#endif
	if (strEQ(name, "P_MINIMIZE"))
#ifdef P_MINIMIZE
	    return P_MINIMIZE;
#else
	    goto not_there;
#endif
	if (strEQ(name, "P_NOCLOSE"))
#ifdef P_NOCLOSE
	    return P_NOCLOSE;
#else
	    goto not_there;
#endif
	if (strEQ(name, "P_NOSESSION"))
#ifdef P_NOSESSION
	    return P_NOSESSION;
#else
	    goto not_there;
#endif
	if (strEQ(name, "P_NOWAIT"))
#ifdef P_NOWAIT
	    return P_NOWAIT;
#else
	    goto not_there;
#endif
	if (strEQ(name, "P_OVERLAY"))
#ifdef P_OVERLAY
	    return P_OVERLAY;
#else
	    goto not_there;
#endif
	if (strEQ(name, "P_PM"))
#ifdef P_PM
	    return P_PM;
#else
	    goto not_there;
#endif
	if (strEQ(name, "P_QUOTE"))
#ifdef P_QUOTE
	    return P_QUOTE;
#else
	    goto not_there;
#endif
	if (strEQ(name, "P_SESSION"))
#ifdef P_SESSION
	    return P_SESSION;
#else
	    goto not_there;
#endif
	if (strEQ(name, "P_TILDE"))
#ifdef P_TILDE
	    return P_TILDE;
#else
	    goto not_there;
#endif
	if (strEQ(name, "P_UNRELATED"))
#ifdef P_UNRELATED
	    return P_UNRELATED;
#else
	    goto not_there;
#endif
	if (strEQ(name, "P_WAIT"))
#ifdef P_WAIT
	    return P_WAIT;
#else
	    goto not_there;
#endif
	if (strEQ(name, "P_WINDOWED"))
#ifdef P_WINDOWED
	    return P_WINDOWED;
#else
	    goto not_there;
#endif
    } else if (name[0] == 'T' && name[1] == '_') {
	if (strEQ(name, "FAPPTYP_NOTSPEC"))
#ifdef FAPPTYP_NOTSPEC
	    return FAPPTYP_NOTSPEC;
#else
	    goto not_there;
#endif
	if (strEQ(name, "T_NOTWINDOWCOMPAT"))
#ifdef FAPPTYP_NOTWINDOWCOMPAT
	    return FAPPTYP_NOTWINDOWCOMPAT;
#else
	    goto not_there;
#endif
	if (strEQ(name, "T_WINDOWCOMPAT"))
#ifdef FAPPTYP_WINDOWCOMPAT
	    return FAPPTYP_WINDOWCOMPAT;
#else
	    goto not_there;
#endif
	if (strEQ(name, "T_WINDOWAPI"))
#ifdef FAPPTYP_WINDOWAPI
	    return FAPPTYP_WINDOWAPI;
#else
	    goto not_there;
#endif
	if (strEQ(name, "T_BOUND"))
#ifdef FAPPTYP_BOUND
	    return FAPPTYP_BOUND;
#else
	    goto not_there;
#endif
	if (strEQ(name, "T_DLL"))
#ifdef FAPPTYP_DLL
	    return FAPPTYP_DLL;
#else
	    goto not_there;
#endif
	if (strEQ(name, "T_DOS"))
#ifdef FAPPTYP_DOS
	    return FAPPTYP_DOS;
#else
	    goto not_there;
#endif
	if (strEQ(name, "T_PHYSDRV"))
#ifdef FAPPTYP_PHYSDRV
	    return FAPPTYP_PHYSDRV;
#else
	    goto not_there;
#endif
	if (strEQ(name, "T_VIRTDRV"))
#ifdef FAPPTYP_VIRTDRV
	    return FAPPTYP_VIRTDRV;
#else
	    goto not_there;
#endif
	if (strEQ(name, "T_PROTDLL"))
#ifdef FAPPTYP_PROTDLL
	    return FAPPTYP_PROTDLL;
#else
	    goto not_there;
#endif
	if (strEQ(name, "T_32BIT"))
#ifdef FAPPTYP_32BIT
	    return FAPPTYP_32BIT;
#else
	    goto not_there;
#endif
    }

    errno = EINVAL;
    return 0;

not_there:
    errno = ENOENT;
    return 0;
}

const char* const ptypes[] = { "FS", "DOS", "VIO", "PM", "DETACH" };

static char *
my_type()
{
    int rc;
    TIB *tib;
    PIB *pib;
    
    if (!(_emx_env & 0x200)) return (char*)ptypes[1]; /* not OS/2. */
    if (CheckOSError(DosGetInfoBlocks(&tib, &pib))) 
	return NULL; 
    
    return (pib->pib_ultype <= 4 ? (char*)ptypes[pib->pib_ultype] : "UNKNOWN");
}

static ULONG
file_type(char *path)
{
    int rc;
    ULONG apptype;
    
    if (!(_emx_env & 0x200)) 
	croak("file_type not implemented on DOS"); /* not OS/2. */
    if (CheckOSError(DosQueryAppType(path, &apptype))) {
#if 0
	if (rc == ERROR_INVALID_EXE_SIGNATURE) 
	    croak("Invalid EXE signature"); 
	else if (rc == ERROR_EXE_MARKED_INVALID) {
	    croak("EXE marked invalid"); 
	}
#endif
	croak_with_os2error("DosQueryAppType"); 
    }
    
    return apptype;
}

/* These use different type of wrapper.  Good to check wrappers. ;-)  */
/* XXXX This assumes DOS type return type, without SEVERITY?! */
DeclFuncByORD(HSWITCH, myWinQuerySwitchHandle,  ORD_WinQuerySwitchHandle,
		  (HWND hwnd, PID pid), (hwnd, pid))
DeclFuncByORD(ULONG, myWinQuerySwitchEntry,  ORD_WinQuerySwitchEntry,
		  (HSWITCH hsw, PSWCNTRL pswctl), (hsw, pswctl))
DeclFuncByORD(ULONG, myWinSetWindowText,  ORD_WinSetWindowText,
		  (HWND hwnd, char* text), (hwnd, text))
DeclFuncByORD(BOOL, myWinQueryWindowProcess,  ORD_WinQueryWindowProcess,
		  (HWND hwnd, PPID ppid, PTID ptid), (hwnd, ppid, ptid))
DeclFuncByORD(ULONG, XmyWinSwitchToProgram,  ORD_WinSwitchToProgram,
		  (HSWITCH hsw), (hsw))
#define myWinSwitchToProgram(hsw) (!CheckOSError(XmyWinSwitchToProgram(hsw)))


/* These function croak if the return value is 0. */
DeclWinFunc_CACHE(HWND, QueryWindow, (HWND hwnd, LONG cmd), (hwnd, cmd))
DeclWinFunc_CACHE(BOOL, QueryWindowPos, (HWND hwnd, PSWP pswp),
		  (hwnd, pswp))
DeclWinFunc_CACHE(LONG, QueryWindowText,
		  (HWND hwnd, LONG cchBufferMax, PCH pchBuffer),
		  (hwnd, cchBufferMax, pchBuffer))
DeclWinFunc_CACHE(LONG, QueryClassName, (HWND hwnd, LONG cchMax, PCH pch),
		  (hwnd, cchMax, pch))
DeclWinFunc_CACHE(HWND, QueryFocus, (HWND hwndDesktop), (hwndDesktop))
DeclWinFunc_CACHE(BOOL, SetFocus, (HWND hwndDesktop, HWND hwndFocus),
		  (hwndDesktop, hwndFocus))
DeclWinFunc_CACHE(BOOL, ShowWindow, (HWND hwnd, BOOL fShow), (hwnd, fShow))
DeclWinFunc_CACHE(BOOL, EnableWindow, (HWND hwnd, BOOL fEnable),
		      (hwnd, fEnable))
DeclWinFunc_CACHE(BOOL, SetWindowPos,
		  (HWND hwnd, HWND hwndInsertBehind, LONG x, LONG y,
		   LONG cx, LONG cy, ULONG fl),
		  (hwnd, hwndInsertBehind, x, y, cx, cy, fl))
DeclWinFunc_CACHE(HENUM, BeginEnumWindows, (HWND hwnd), (hwnd))
DeclWinFunc_CACHE(BOOL, EndEnumWindows, (HENUM henum), (henum))
DeclWinFunc_CACHE(BOOL, EnableWindowUpdate, (HWND hwnd, BOOL fEnable),
		  (hwnd, fEnable))
DeclWinFunc_CACHE(BOOL, SetWindowBits,
		  (HWND hwnd, LONG index, ULONG flData, ULONG flMask),
		  (hwnd, index, flData, flMask))
DeclWinFunc_CACHE(BOOL, SetWindowPtr, (HWND hwnd, LONG index, PVOID p),
		  (hwnd, index, p))
DeclWinFunc_CACHE(BOOL, SetWindowULong, (HWND hwnd, LONG index, ULONG ul),
		  (hwnd, index, ul))
DeclWinFunc_CACHE(BOOL, SetWindowUShort, (HWND hwnd, LONG index, USHORT us),
		  (hwnd, index, us))
DeclWinFunc_CACHE(HWND, IsChild, (HWND hwnd, HWND hwndParent),
		  (hwnd, hwndParent))
DeclWinFunc_CACHE(HWND, WindowFromId, (HWND hwnd, ULONG id), (hwnd, id))
DeclWinFunc_CACHE(HWND, EnumDlgItem, (HWND hwndDlg, HWND hwnd, ULONG code),
		  (hwndDlg, hwnd, code))
DeclWinFunc_CACHE(HWND, QueryDesktopWindow, (HAB hab, HDC hdc), (hab, hdc));
DeclWinFunc_CACHE(BOOL, SetActiveWindow, (HWND hwndDesktop, HWND hwnd),
		  (hwndDesktop, hwnd));
DeclWinFunc_CACHE(BOOL, QueryActiveDesktopPathname, (PSZ pszPathName, ULONG ulSize),
		  (pszPathName, ulSize));
DeclWinFunc_CACHE(BOOL, InvalidateRect,
		  (HWND hwnd, /*RECTL*/ char *prcl, BOOL fIncludeChildren),
		  (hwnd, prcl, fIncludeChildren));
DeclWinFunc_CACHE(BOOL, CreateFrameControls,
		  (HWND hwndFrame, /*PFRAMECDATA*/ char* pfcdata, PCSZ pszTitle),
		  (hwndFrame, pfcdata, pszTitle));
DeclWinFunc_CACHE(BOOL, OpenClipbrd, (HAB hab), (hab));
DeclWinFunc_CACHE(BOOL, EmptyClipbrd, (HAB hab), (hab));
DeclWinFunc_CACHE(BOOL, CloseClipbrd, (HAB hab), (hab));
DeclWinFunc_CACHE(BOOL, QueryClipbrdFmtInfo, (HAB hab, ULONG fmt, PULONG prgfFmtInfo), (hab, fmt, prgfFmtInfo));
DeclWinFunc_CACHE(ULONG, QueryClipbrdData, (HAB hab, ULONG fmt), (hab, fmt));
DeclWinFunc_CACHE(HWND, SetClipbrdViewer, (HAB hab, HWND hwnd), (hab, hwnd));
DeclWinFunc_CACHE(HWND, SetClipbrdOwner, (HAB hab, HWND hwnd), (hab, hwnd));
DeclWinFunc_CACHE(ULONG, EnumClipbrdFmts, (HAB hab, ULONG fmt), (hab, fmt));
DeclWinFunc_CACHE(ATOM, AddAtom, (HATOMTBL hAtomTbl, PCSZ pszAtomName),
		  (hAtomTbl, pszAtomName));
DeclWinFunc_CACHE(ULONG, QueryAtomUsage, (HATOMTBL hAtomTbl, ATOM atom),
		  (hAtomTbl, atom));
DeclWinFunc_CACHE(ULONG, QueryAtomLength, (HATOMTBL hAtomTbl, ATOM atom),
		  (hAtomTbl, atom));
DeclWinFunc_CACHE(ULONG, QueryAtomName,
		  (HATOMTBL hAtomTbl, ATOM atom, PSZ pchBuffer, ULONG cchBufferMax),
		  (hAtomTbl, atom, pchBuffer, cchBufferMax));
DeclWinFunc_CACHE(HATOMTBL, QuerySystemAtomTable, (VOID), ());
DeclWinFunc_CACHE(HATOMTBL, CreateAtomTable, (ULONG initial, ULONG buckets),
		  (initial, buckets));
DeclWinFunc_CACHE(ULONG, MessageBox, (HWND hwndParent, HWND hwndOwner, PCSZ pszText, PCSZ pszCaption, ULONG idWindow, ULONG flStyle), (hwndParent, hwndOwner, pszText, pszCaption, idWindow, flStyle));
DeclWinFunc_CACHE(ULONG, MessageBox2,
		  (HWND hwndParent, HWND hwndOwner, PCSZ pszText,
		   PCSZ pszCaption, ULONG idWindow, PMB2INFO pmb2info),
		  (hwndParent, hwndOwner, pszText, pszCaption, idWindow, pmb2info));
DeclWinFunc_CACHE(HPOINTER, LoadPointer,
		  (HWND hwndDesktop, HMODULE hmod, ULONG idres),
		  (hwndDesktop, hmod, idres));
DeclWinFunc_CACHE(HPOINTER, QuerySysPointer,
		  (HWND hwndDesktop, LONG lId, BOOL fCopy),
		  (hwndDesktop, lId, fCopy));
DeclWinFunc_CACHE(BOOL, Alarm, (HWND hwndDesktop, ULONG rgfType), (hwndDesktop, rgfType));
DeclWinFunc_CACHE(BOOL, FlashWindow, (HWND hwndFrame, BOOL fFlash), (hwndFrame, fFlash));

#if 0		/* Need to have the entry points described in the parent */
DeclWinFunc_CACHE(BOOL, QueryClassInfo, (HAB hab, char* pszClassName, PCLASSINFO pClassInfo), (hab, pszClassName, pClassInfo));

#define _QueryClassInfo(hab, pszClassName, pClassInfo)	\
	QueryClassInfo(hab, pszClassName, (PCLASSINFO)pClassInfo)

#endif

/* These functions do not croak on error */
DeclWinFunc_CACHE_survive(BOOL, SetClipbrdData,
			  (HAB hab, ULONG ulData, ULONG fmt, ULONG rgfFmtInfo),
			  (hab, ulData, fmt, rgfFmtInfo));

#define get_InvalidateRect	InvalidateRect
#define get_CreateFrameControls	CreateFrameControls

/* These functions may return 0 on success; check $^E/Perl_rc on res==0: */
DeclWinFunc_CACHE_resetError(PVOID, QueryWindowPtr, (HWND hwnd, LONG index),
			     (hwnd, index))
DeclWinFunc_CACHE_resetError(ULONG, QueryWindowULong, (HWND hwnd, LONG index),
			     (hwnd, index))
DeclWinFunc_CACHE_resetError(SHORT, QueryWindowUShort, (HWND hwnd, LONG index),
			     (hwnd, index))
DeclWinFunc_CACHE_resetError(LONG,  QueryWindowTextLength, (HWND hwnd), (hwnd))
DeclWinFunc_CACHE_resetError(HWND,  QueryActiveWindow, (HWND hwnd), (hwnd))
DeclWinFunc_CACHE_resetError(BOOL, PostMsg,
			     (HWND hwnd, ULONG msg, MPARAM mp1, MPARAM mp2),
			     (hwnd, msg, mp1, mp2))
DeclWinFunc_CACHE_resetError(HWND, GetNextWindow, (HENUM henum), (henum))
DeclWinFunc_CACHE_resetError(BOOL, IsWindowEnabled, (HWND hwnd), (hwnd))
DeclWinFunc_CACHE_resetError(BOOL, IsWindowVisible, (HWND hwnd), (hwnd))
DeclWinFunc_CACHE_resetError(BOOL, IsWindowShowing, (HWND hwnd), (hwnd))
DeclWinFunc_CACHE_resetError(ATOM, FindAtom, (HATOMTBL hAtomTbl, PCSZ pszAtomName),
			     (hAtomTbl, pszAtomName));
DeclWinFunc_CACHE_resetError(ATOM, DeleteAtom, (HATOMTBL hAtomTbl, ATOM atom),
			     (hAtomTbl, atom));
DeclWinFunc_CACHE_resetError(HATOMTBL, DestroyAtomTable, (HATOMTBL hAtomTbl), (hAtomTbl));
DeclWinFunc_CACHE_resetError(HWND, QueryClipbrdViewer, (HAB hab), (hab));
DeclWinFunc_CACHE_resetError(HWND, QueryClipbrdOwner, (HAB hab), (hab));

#define _DeleteAtom		DeleteAtom
#define _DestroyAtomTable	DestroyAtomTable

/* No die()ing on error */
DeclWinFunc_CACHE_survive(BOOL, IsWindow, (HAB hab, HWND hwnd), (hab, hwnd))

/* These functions are called frow complicated wrappers: */
ULONG (*pWinQuerySwitchList) (HAB hab, PSWBLOCK pswblk, ULONG usDataLength);
ULONG (*pWinChangeSwitchEntry) (HSWITCH hsw, __const__ SWCNTRL *pswctl);
HWND (*pWinWindowFromPoint)(HWND hwnd, __const__ POINTL *pptl, BOOL fChildren);


/* These functions have different names/signatures than what is
   declared above */
#define QueryFocusWindow QueryFocus
#define FocusWindow_set(hwndFocus, hwndDesktop) SetFocus(hwndDesktop, hwndFocus)
#define WindowPos_set(hwnd, x, y, fl, cx, cy, hwndInsertBehind)	\
	SetWindowPos(hwnd, hwndInsertBehind, x, y, cx, cy, fl)
#define myWinQueryWindowPtr(hwnd, i)	((ULONG)QueryWindowPtr(hwnd, i))
#define _ClipbrdData_set SetClipbrdData
#define ClipbrdOwner_set SetClipbrdOwner
#define ClipbrdViewer_set SetClipbrdViewer

int
WindowText_set(HWND hwnd, char* text)
{
   return !CheckWinError(myWinSetWindowText(hwnd, text));
}

SV *
myQueryWindowText(HWND hwnd)
{
    LONG l = QueryWindowTextLength(hwnd), len;
    SV *sv;
    STRLEN n_a;

    if (l == 0) {
	if (Perl_rc)		/* Last error */
	    return &PL_sv_undef;
	return &PL_sv_no;
    }
    sv = newSVpvn("", 0);
    SvGROW(sv, l + 1);
    len = QueryWindowText(hwnd, l + 1, SvPV_force(sv, n_a));
    if (len != l) {
	Safefree(sv);
	croak("WinQueryWindowText() uncompatible with WinQueryWindowTextLength()");
    }
    SvCUR_set(sv, l);
    return sv;
}

SWP
QueryWindowSWP_(HWND hwnd)
{
    SWP swp;

    if (!QueryWindowPos(hwnd, &swp))
	croak("WinQueryWindowPos() error");
    return swp;
}

SV *
QueryWindowSWP(HWND hwnd)
{
    SWP swp = QueryWindowSWP_(hwnd);

    return newSVpvn((char*)&swp, sizeof(swp));
}

SV *
myQueryClassName(HWND hwnd)
{
    SV *sv = newSVpvn("",0);
    STRLEN l = 46, len = 0, n_a;

    while (l + 1 >= len) {
	if (len)
	    len = 2*len + 10;		/* Grow quick */
	else
	    len = l + 2;
	SvGROW(sv, len);
	l = QueryClassName(hwnd, len, SvPV_force(sv, n_a));
    }
    SvCUR_set(sv, l);
    return sv;
}

HWND
WindowFromPoint(long x, long y, HWND hwnd, BOOL fChildren)
{
    POINTL ppl;

    ppl.x = x; ppl.y = y;
    if (!pWinWindowFromPoint)
	AssignFuncPByORD(pWinWindowFromPoint, ORD_WinWindowFromPoint);
    return SaveWinError(pWinWindowFromPoint(hwnd, &ppl, fChildren));
}

static HSWITCH
switch_of(HWND hwnd, PID pid)
{
	 HSWITCH hSwitch;    

	 if (!(_emx_env & 0x200)) 
	     croak("switch_entry not implemented on DOS"); /* not OS/2. */
	 if (CheckWinError(hSwitch = 
			   myWinQuerySwitchHandle(hwnd, pid)))
	     croak_with_os2error("WinQuerySwitchHandle");
	 return hSwitch;
}


static void
fill_swentry(SWENTRY *swentryp, HWND hwnd, PID pid)
{
	 int rc;
	 HSWITCH hSwitch = switch_of(hwnd, pid);

	 swentryp->hswitch = hSwitch;
	 if (CheckOSError(myWinQuerySwitchEntry(hSwitch, &swentryp->swctl)))
	     croak_with_os2error("WinQuerySwitchEntry");
}

static void
fill_swentry_default(SWENTRY *swentryp)
{
	fill_swentry(swentryp, NULLHANDLE, getpid());
}

static SV*
myWinQueryActiveDesktopPathname()
{
    SV *buf = newSVpv("",0);
    STRLEN n_a;

    SvGROW(buf, MAXPATHLEN);
    QueryActiveDesktopPathname(SvPV(buf,n_a), MAXPATHLEN);
    SvCUR_set(buf, strlen(SvPV(buf, n_a)));
    return buf;
}

SV *
myWinQueryAtomName(ATOM atom, HATOMTBL hAtomTbl)
{
  ULONG len = QueryAtomLength(hAtomTbl, atom);

  if (len) {			/* Probably always so... */
    SV *sv = newSVpvn("",0);
    STRLEN n_a;

    SvGROW(sv, len + 1);
    len = QueryAtomName(hAtomTbl, atom, SvPV(sv, n_a), len + 1);
    if (len) {			/* Probably always so... */
      SvCUR_set(sv, len);
      *SvEND(sv) = 0;
      return sv;
    }
    SvREFCNT_dec(sv);
  }
  return &PL_sv_undef;
}

#define myWinQueryClipbrdFmtInfo	QueryClipbrdFmtInfo

/* Put data into shared memory, then call SetClipbrdData */
void
ClipbrdData_set(SV *sv, int convert_nl, unsigned long fmt, unsigned long rgfFmtInfo, HAB hab)
{
    STRLEN len;
    char *buf;
    char *pByte = 0, *s, c;
    ULONG nls = 0, rc, handle;

    if (rgfFmtInfo & CFI_POINTER) {
      s = buf = SvPV_force(sv, len);
      if (convert_nl) {
	while ((c = *s++)) {
	    if (c == '\r' && *s == '\n')
		s++;
	    else if (c == '\n')
		nls++;
	}
      }

      if (CheckOSError(DosAllocSharedMem((PPVOID)&pByte, 0, len + nls + 1,
				       PAG_WRITE | PAG_COMMIT | OBJ_GIVEABLE | OBJ_GETTABLE)))
	croak_with_os2error("ClipbrdData_set: DosAllocSharedMem error");

      if (!nls)
	memcpy(pByte, buf, len + 1);
      else {
	char *t = pByte, *e = buf + len;

	while (buf < e) {
	    c = *t++ = *buf++;
	    if (c == '\n' && (t == pByte + 1 || t[-2] != '\r'))
		t[-1] = '\r', *t++ = '\n';
	}
      }
      handle = (ULONG)pByte;
    } else {
      handle = (ULONG)SvUV(sv);
    }

    if (!SetClipbrdData(hab, handle, fmt, rgfFmtInfo)) {
	if (fmt & CFI_POINTER)
	    DosFreeMem((PPVOID)&pByte);
	croak_with_os2error("ClipbrdData_set: WinSetClipbrdData error");
    }
}

ULONG
QueryMemoryRegionSize(ULONG addr, ULONG *flagp, ULONG len, I32 interrupt)
{
    ULONG l, f;				/* Modifiable copy */
    ULONG rc;

    do {
	l = len;
	rc = DosQueryMem((void *)addr, &l, &f);
    } while ( interrupt ? 0 : rc == ERROR_INTERRUPT );

    /* We assume this is not about addr */
/*
    if (rc == ERROR_INVALID_ADDRESS)
	return 0xFFFFFFFF;
*/
    os2cp_croak(rc,"QueryMemoryRegionSize");
    if (flagp)
	*flagp = f;
    return l;
}

static ULONG
default_fmtInfo(ULONG fmt)
{
   switch (fmt) {
     case CF_PALETTE:	/* Actually, fmtInfo not documented for palette... */
     case CF_BITMAP:
     case CF_METAFILE:
     case CF_DSPBITMAP:
     case CF_DSPMETAFILE:
	return CFI_HANDLE;
     default:
	return CFI_POINTER;
   }
}

#if 0

ULONG
myWinMessageBox(HWND hwndParent, HWND hwndOwner, PCSZ pszText, PCSZ pszCaption, ULONG idWindow, ULONG flStyle)
{
    ULONG rc = MessageBox(hwndParent, hwndOwner, pszText, pszCaption,
			  idWindow, flStyle);

    if (rc == MBID_ERROR)
	rc = 0;
    if (CheckWinError(rc))
	croak_with_os2error("MessageBox");
    return rc;
}

ULONG
myWinMessageBox2(HWND hwndParent, HWND hwndOwner, PCSZ pszText,
		   PCSZ pszCaption, ULONG idWindow, PMB2INFO pmb2info)
{
    ULONG rc = MessageBox2(hwndParent, hwndOwner, pszText, pszCaption, idWindow, pmb2info);

    if (rc == MBID_ERROR)
	rc = 0;
    if (CheckWinError(rc))
	croak_with_os2error("MessageBox2");
    return rc;
}
#endif

/* static ULONG (* APIENTRY16 pDosSmSetTitle)(ULONG, PSZ); */
ULONG _THUNK_FUNCTION(DosSmSetTitle)(ULONG, PSZ);

#if 0			/*  Does not work.  */
static ULONG (*pDosSmSetTitle)(ULONG, PSZ);

static void
sesmgr_title_set(char *s)
{
    SWENTRY swentry;
    static HMODULE hdosc = 0;
    BYTE buf[20];
    long rc;

    fill_swentry_default(&swentry);
    if (!pDosSmSetTitle || !hdosc) {
	if (CheckOSError(DosLoadModule(buf, sizeof buf, "sesmgr", &hdosc)))
	    croak("Cannot load SESMGR: no `%s'", buf);
	if (CheckOSError(DosQueryProcAddr(hdosc, 0, "DOSSMSETTITLE",
					  (PFN*)&pDosSmSetTitle)))
	    croak("Cannot load SESMGR.DOSSMSETTITLE, err=%ld", rc);
    }
/*     (pDosSmSetTitle)(swcntrl.idSession,s); */
    rc = ((USHORT)
          (_THUNK_PROLOG (2+4);
           _THUNK_SHORT (swcntrl.idSession);
           _THUNK_FLAT (s);
           _THUNK_CALLI (*pDosSmSetTitle)));
    if (CheckOSError(rc))
	warn("*DOSSMSETTITLE: err=%ld, ses=%ld, addr=%x, *paddr=%x", 
	     rc, swcntrl.idSession, &_THUNK_FUNCTION(DosSmSetTitle),
	     pDosSmSetTitle);
}

#else /* !0 */

static bool
sesmgr_title_set(char *s)
{
    SWENTRY swentry;
    long rc;

    fill_swentry_default(&swentry);
    rc = ((USHORT)
          (_THUNK_PROLOG (2+4);
           _THUNK_SHORT (swentry.swctl.idSession);
           _THUNK_FLAT (s);
           _THUNK_CALL (DosSmSetTitle)));
#if 0
    if (CheckOSError(rc))
	warn("DOSSMSETTITLE: err=%ld, ses=%ld, addr=%x", 
	     rc, swcntrl.idSession, _THUNK_FUNCTION(DosSmSetTitle));
#endif
    return !CheckOSError(rc);
}
#endif /* !0 */

#if 0			/*  Does not work.  */
USHORT _THUNK_FUNCTION(Win16SetTitle) ();

static void
set_title2(char *s)
{
    long rc;

    rc = ((USHORT)
          (_THUNK_PROLOG (4);
           _THUNK_FLAT (s);
           _THUNK_CALL (Win16SetTitle)));
    if (CheckWinError(rc))
	warn("Win16SetTitle: err=%ld", rc);
}
#endif

SV *
process_swentry(unsigned long pid, HWND hwnd)
{
    SWENTRY swentry;

    if (!(_emx_env & 0x200)) 
	     croak("process_swentry not implemented on DOS"); /* not OS/2. */
    fill_swentry(&swentry, hwnd, pid);
    return newSVpvn((char*)&swentry, sizeof(swentry));
}

SV *
swentries_list()
{
    int num, n = 0;
    STRLEN n_a;
    PSWBLOCK pswblk;
    SV *sv = newSVpvn("",0);

    if (!(_emx_env & 0x200)) 
	     croak("swentries_list not implemented on DOS"); /* not OS/2. */
    if (!pWinQuerySwitchList)
	AssignFuncPByORD(pWinQuerySwitchList, ORD_WinQuerySwitchList);
    num = pWinQuerySwitchList(0, NULL, 0);	/* HAB is not required */
    if (!num)
	croak("(Unknown) error during WinQuerySwitchList()");
    /* Allow one extra entry to allow overflow detection (may happen
	if the list has been changed). */
    while (num > n) {
	if (n == 0)
	    n = num + 1;
	else
	    n = 2*num + 10;			/* Enlarge quickly */
	SvGROW(sv, sizeof(ULONG) + sizeof(SWENTRY) * n + 1);
	pswblk = (PSWBLOCK) SvPV_force(sv, n_a);
	num = pWinQuerySwitchList(0, pswblk, SvLEN(sv));
    }
    SvCUR_set(sv, sizeof(ULONG) + sizeof(SWENTRY) * num);
    *SvEND(sv) = 0;
    return sv;
}

SWENTRY
swentry( char *title, HWND sw_hwnd, HWND icon_hwnd, HPROGRAM owner_phandle,
	 PID owner_pid, ULONG owner_sid, ULONG visible, ULONG nonswitchable,
	 ULONG jumpable, ULONG ptype, HSWITCH sw_entry)
{
  SWENTRY e;

  strncpy(e.swctl.szSwtitle, title, MAXNAMEL);
  e.swctl.szSwtitle[60] = 0;
  e.swctl.hwnd = sw_hwnd;
  e.swctl.hwndIcon = icon_hwnd;
  e.swctl.hprog = owner_phandle;
  e.swctl.idProcess = owner_pid;
  e.swctl.idSession = owner_sid;
  e.swctl.uchVisibility = ((visible ? SWL_VISIBLE : SWL_INVISIBLE)
			   | (nonswitchable ? SWL_GRAYED : 0));
  e.swctl.fbJump = (jumpable ? SWL_JUMPABLE : 0);
  e.swctl.bProgType = ptype;
  e.hswitch = sw_entry;
  return e;
}

SV *
create_swentry( char *title, HWND owner_hwnd, HWND icon_hwnd, HPROGRAM owner_phandle,
	 PID owner_pid, ULONG owner_sid, ULONG visible, ULONG nonswitchable,
	 ULONG jumpable, ULONG ptype, HSWITCH sw_entry)
{
    SWENTRY e = swentry(title, owner_hwnd, icon_hwnd, owner_phandle, owner_pid,
			owner_sid, visible, nonswitchable, jumpable, ptype,
			sw_entry);

    return newSVpvn((char*)&e, sizeof(e));
}

int
change_swentrysw(SWENTRY *sw)
{
    ULONG rc;			/* For CheckOSError */

    if (!(_emx_env & 0x200)) 
	     croak("change_entry() not implemented on DOS"); /* not OS/2. */
    if (!pWinChangeSwitchEntry)
	AssignFuncPByORD(pWinChangeSwitchEntry, ORD_WinChangeSwitchEntry);
    return !CheckOSError(pWinChangeSwitchEntry(sw->hswitch, &sw->swctl));
}

int
change_swentry(SV *sv)
{
    STRLEN l;
    PSWENTRY pswentry = (PSWENTRY)SvPV(sv, l);

    if (l != sizeof(SWENTRY))
	croak("Wrong structure size %ld!=%ld in change_swentry()", (long)l, (long)sizeof(SWENTRY));
    return change_swentrysw(pswentry);
}


#define swentry_size()		(sizeof(SWENTRY))

void
getscrsize(int *wp, int *hp)
{
    int i[2];

    _scrsize(i);
    *wp = i[0];
    *hp = i[1];
}

/* Force vio to not cross 64K-boundary: */
#define VIO_FROM_VIOB			\
    vio = viob;				\
    if (!_THUNK_PTR_STRUCT_OK(vio))	\
	vio++

bool
scrsize_set(int w, int h)
{
    VIOMODEINFO viob[2], *vio;
    ULONG rc;

    VIO_FROM_VIOB;

    if (h == -9999)
	h = w, w = 0;
    vio->cb = sizeof(*vio);
    if (CheckOSError(VioGetMode( vio, 0 )))
	return 0;

    if( w > 0 )
      vio->col = (USHORT)w;

    if( h > 0 )
      vio->row = (USHORT)h;

    vio->cb = 8;
    if (CheckOSError(VioSetMode( vio, 0 )))
	return 0;
    return 1;
}

void
cursor(int *sp, int *ep, int *wp, int *ap)
{
    VIOCURSORINFO viob[2], *vio;
    ULONG rc;

    VIO_FROM_VIOB;

    if (CheckOSError(VioGetCurType( vio, 0 )))
	croak_with_os2error("VioGetCurType() error");

    *sp = vio->yStart;
    *ep = vio->cEnd;
    *wp = vio->cx;
    *ep = vio->attr;
}

bool
cursor__(int is_a)
{
    int s,e,w,a;

    cursor(&s, &e, &w, &a);
    if (is_a)
	return a;
    else
	return w;
}

bool
cursor_set(int s, int e, int w, int a)
{
    VIOCURSORINFO viob[2], *vio;
    ULONG rc;

    VIO_FROM_VIOB;

    vio->yStart = s;
    vio->cEnd = e;
    vio->cx = w;
    vio->attr = a;
    return !CheckOSError(VioSetCurType( vio, 0 ));
}

static int
bufsize(void)
{
#if 1
    VIOMODEINFO viob[2], *vio;
    ULONG rc;

    VIO_FROM_VIOB;

    vio->cb = sizeof(*vio);
    if (CheckOSError(VioGetMode( vio, 0 )))
	croak_with_os2error("Can't get size of buffer for screen");
#if 0	/* buf=323552247, full=1118455, partial=0 */
    croak("Lengths: buf=%d, full=%d, partial=%d",vio->buf_length,vio->full_length,vio->partial_length);
    return newSVpvn((char*)vio->buf_addr, vio->full_length);
#endif
    return vio->col * vio->row * 2;	/* How to get bytes/cell?  2 or 4? */
#else	/* 0 */
    int i[2];

    _scrsize(i);
    return i[0]*i[1]*2;
#endif	/* 0 */
}

SV*
_kbdChar(unsigned int nowait, int handle)
{
    KBDKEYINFO viob[2], *vio;
    ULONG rc;

    VIO_FROM_VIOB;

    if (nowait > 2)
	croak("unexpected nowait");
    if (CheckOSError(nowait == 2
		     ? KbdPeek( vio, handle )
		     : KbdCharIn( vio, nowait == 1, handle )))
	croak_with_os2error("Can't _kbdChar");
    return newSVpvn((char*)vio, sizeof(*vio));
}

SV*
_kbdStatus(int handle)
{
    KBDINFO viob[2], *vio;
    ULONG rc;

    VIO_FROM_VIOB;

    vio->cb = sizeof(*vio);
    if (CheckOSError(KbdGetStatus( vio, handle )))
	croak_with_os2error("Can't _kbdStatus");
    return newSVpvn((char*)vio, sizeof(*vio));
}

void
_kbdStatus_set(SV* sv, int handle)
{
    KBDINFO viob[2], *vio;
    ULONG rc;
    STRLEN l;
    char *s = SvPV(sv, l);

    VIO_FROM_VIOB;

    if (l != sizeof(*vio))
	croak("unexpected datasize");
    Copy((KBDINFO*)s, vio, 1, KBDINFO);
    if (vio->cb != sizeof(*vio))
	croak("unexpected datasize");
    if (CheckOSError(KbdSetStatus( vio, handle )))
	croak_with_os2error("Can't kbdStatus_set()");
}

SV*
_vioConfig(int which, int handle)
{
    struct {VIOCONFIGINFO i; short a[20];} viob[2], *vio;
    ULONG rc;

    VIO_FROM_VIOB;

    vio->i.cb = 2;
    if (CheckOSError(VioGetConfig( which, &vio->i, handle )))
	croak_with_os2error("Can't get VIO config size");
    if (vio->i.cb > sizeof(*vio))
	vio->i.cb = sizeof(*vio);
    if (CheckOSError(VioGetConfig( which, &vio->i, handle )))
	croak_with_os2error("Can't get VIO config");
    return newSVpvn((char*)vio, vio->i.cb);
}

SV*
_vioMode(void)
{
    VIOMODEINFO viob[2], *vio;
    ULONG rc;

    VIO_FROM_VIOB;

    vio->cb = sizeof(*vio);
    if (CheckOSError(VioGetMode( vio, 0 )))
	croak_with_os2error("Can't get VIO mode");
    return newSVpvn((char*)vio, sizeof(*vio));
}

void
_vioMode_set(SV* sv)
{
    VIOMODEINFO viob[2], *vio;
    ULONG rc;
    STRLEN l;
    char *s = SvPV(sv, l);

    VIO_FROM_VIOB;

    Copy((VIOMODEINFO*)s, vio, 1, VIOMODEINFO);
    if (vio->cb != sizeof(*vio) || l != vio->cb)
	croak("unexpected datasize");
    if (CheckOSError(VioSetMode( vio, 0 )))
	croak_with_os2error("Can't set VIO mode");
}

SV*
vioFont(int type, int *w, int *h) /* 0 for actual RAM font, 1 for ROM font */
{
    VIOFONTINFO viob[2], *vio;
    ULONG rc;
    UCHAR b[1<<17];
    UCHAR *buf = b;
    SV *sv;

    VIO_FROM_VIOB;

    /* Should not cross 64K boundaries too: */
    if (((ULONG)buf) & 0xFFFF)
	buf += 0x10000 - (((ULONG)buf) & 0xFFFF);

    vio->cb = sizeof(*vio);
    vio->type = type;			/* BIOS or the loaded font. */
    vio->cbData = 0xFFFF;		/* How large is my buffer? */
    vio->pbData = _emx_32to16(buf);	/* Wants an 16:16 pointer */
    if (CheckOSError(VioGetFont( vio, 0 )))
	croak_with_os2error("Can't get VIO font");
    *w = vio->cxCell;
    *h = vio->cyCell;
    return newSVpvn(buf,vio->cbData);
}

void
vioFont_set(SV *sv, int cellwidth, int cellheight, int type)
{
    VIOFONTINFO viob[2], *vio;
    ULONG rc;
    UCHAR b[1<<17];
    UCHAR *buf = b;
    STRLEN l;
    char *s = SvPV(sv, l);

    VIO_FROM_VIOB;

    /* Should not cross 64K boundaries too: */
    if (((ULONG)buf) & 0xFFFF)
	buf += 0x10000 - (((ULONG)buf) & 0xFFFF);

    if (l > 0xFFFF)
	croak("length overflow of VIO font");
    if (l != (cellwidth + 7)/8 * cellheight * 256)
	warn("unexpected length of VIO font");
    vio->cb = sizeof(*vio);
    vio->type = type;			/* BIOS or the loaded font. */
    vio->cbData = l;			/* How large is my buffer? */
    vio->pbData = _emx_32to16(buf);	/* Wants an 16:16 pointer */
    vio->cxCell = cellwidth;
    vio->cyCell = cellheight;
    Copy(s, buf, l, char);

    if (CheckOSError(VioSetFont( vio, 0 )))
	croak_with_os2error("Can't set VIO font");
}

/*
  uses use32,os2def,os2base,crt,defs;
  var   Plt :Plt256;
  const Pal :VioPalState=(Cb:sizeof(VioPalState);rType:0;iFirst:0;
    Acolor:($FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF));
        CReg:VioColorReg=(Cb:sizeof(VioColorReg);rType:3;FirstColorReg:0;
    NumColorRegs:256; ColorRegAddr:@@Plt);
  var   ii:Pointer;
  begin
   VioGetState(Pal,0);
   Pal.Acolor[09]:=$0F;
   Pal.Acolor[10]:=$A;
   Pal.Acolor[13]:=$2F;
   VioSetState(Pal,0); // ce smena EGA registrov
   asm
  lea   eax,Plt
     call  DosFlatToSel
     mov   ii,eax
   end;
   CReg.ColorRegAddr:=ii;
   VioGetState(CReg,0);
   Plt[10,0]:=$00;
   Plt[10,1]:=$32;
   Plt[10,2]:=$2A;
   VioSetState(CReg,0); // a ce - VGA registrov
  end.
*/

typedef union {
  VIOPALSTATE pal;
  struct { VIOPALSTATE pal; USHORT a[15]; } pal_padded;
  VIOOVERSCAN overscan;
  VIOINTENSITY intensity;
  VIOCOLORREG colorreg;
  struct { VIOCOLORREG reg; char rgb[3*256]; } colorreg_padded;
  VIOSETULINELOC lineloc;
  VIOSETTARGET target;
} my_VIOSTATE;

int
vio_state_size(int what)
{
    static const char sizes[] = {
	sizeof(VIOPALSTATE),
	sizeof(VIOOVERSCAN),
	sizeof(VIOINTENSITY),
	sizeof(VIOCOLORREG),
	6,				/* Random number: Reserved entry */
	sizeof(VIOSETULINELOC),
	sizeof(VIOSETTARGET)
    };
    if (what < 0 || what >= sizeof(sizes))
	croak("Unexpected VIO state type");
    return sizes[what];
}

SV*
_vioState(int what, int first, int count)
{
    my_VIOSTATE viob[2], *vio;
    ULONG rc, size = vio_state_size(what);

    VIO_FROM_VIOB;

    vio->pal.cb = size;
    vio->pal.type = what;
    if (what == 0) {
	vio->pal.iFirst = first;
	if (first < 0 || first >= 16)
	    croak("unexpected palette start value");
	if (count < 0 || count > 16)
	    croak("unexpected palette count");
	vio->pal.cb = (size += (count - 1) * sizeof(short));
    } else if (what == 3) {
	/* Wants an 16:16 pointer */
	if (count < 0 || count > 256)
	    croak("unexpected palette count");
	vio->colorreg.colorregaddr = (PCH)_emx_32to16(vio->colorreg_padded.rgb);
	vio->colorreg.numcolorregs = count;		/* 256 is max */
	vio->colorreg.firstcolorreg = first;
	size += 3 * count;
    }
    if (CheckOSError(VioGetState( (void*)vio, 0 )))
	croak_with_os2error("Can't get VIO state");
    return newSVpvn((char*)vio, size);
}

void
_vioState_set(SV *sv)
{
    my_VIOSTATE viob[2], *ovio = (my_VIOSTATE*)SvPV_nolen(sv), *vio = ovio;
    int what = ovio->pal.type, cb = ovio->pal.cb;
    ULONG rc, size = vio_state_size(what);
    STRLEN l;
    char *s = SvPV(sv, l);

    VIO_FROM_VIOB;

    switch (what) {
    case 0:
	if ( cb < size || cb > size + 15*sizeof(SHORT) || l != cb)
	    croak("unexpected datasize");
	size = l;
	break;
    case 3:
	if (l != cb + 3 * ovio->colorreg.numcolorregs || cb != size)
	    croak("unexpected datasize");
	size = l;
	break;
    default:
	if (l != cb || l != size )
	    croak("unexpected datasize");
	break;
    }
    Copy(s, (char*)vio, size, char);
    if (what == 3)	/* We expect colors put after VIOCOLORREG */
	vio->colorreg.colorregaddr = (PCH)_emx_32to16(vio->colorreg_padded.rgb);

    if (CheckOSError(VioSetState( (void*)vio, 0 )))
	croak_with_os2error("Can't set VIO state");
}

SV *
screen(void)
{
    ULONG rc;
    USHORT bufl = bufsize();
    char b[(1<<16) * 3]; /* This/3 is enough for 16-bit calls, we need
			    2x overhead due to 2 vs 4 issue, and extra
			    64K due to alignment logic */
    char *buf = b;
    
    if (((ULONG)buf) & 0xFFFF)
	buf += 0x10000 - (((ULONG)buf) & 0xFFFF);
    if ((sizeof(b) - (buf - b)) < 2*bufl)
	croak("panic: VIO buffer allocation");
    if (CheckOSError(VioReadCellStr( buf, &bufl, 0, 0, 0 )))
	return &PL_sv_undef;
    return newSVpvn(buf,bufl);
}

bool
screen_set(SV *sv)
{
    ULONG rc;
    STRLEN l = SvCUR(sv), bufl = bufsize();
    char b[(1<<16) * 2]; /* This/2 is enough for 16-bit calls, we need
			    extra 64K due to alignment logic */
    char *buf = b;
    
    if (((ULONG)buf) & 0xFFFF)
	buf += 0x10000 - (((ULONG)buf) & 0xFFFF);
    if (!SvPOK(sv) || ((l != bufl) && (l != 2*bufl)))
	croak("Wrong size %d of saved screen data", SvCUR(sv));
    if ((sizeof(b) - (buf - b)) < l)
	croak("panic: VIO buffer allocation");
    Copy(SvPV(sv,l), buf, bufl, char);
    if (CheckOSError(VioWrtCellStr( buf, bufl, 0, 0, 0 )))
	return 0;
    return 1;
}

int
process_codepages()
{
    ULONG cps[4], cp, rc;

    if (CheckOSError(DosQueryCp( sizeof(cps), cps, &cp )))
	croak_with_os2error("DosQueryCp()");
    return cp;
}

int
out_codepage()
{
    USHORT cp, rc;

    if (CheckOSError(VioGetCp( 0, &cp, 0 )))
	croak_with_os2error("VioGetCp()");
    return cp;
}

bool
out_codepage_set(int cp)
{
    USHORT rc;

    return !(CheckOSError(VioSetCp( 0, cp, 0 )));
}

int
in_codepage()
{
    USHORT cp, rc;

    if (CheckOSError(KbdGetCp( 0, &cp, 0 )))
	croak_with_os2error("KbdGetCp()");
    return cp;
}

bool
in_codepage_set(int cp)
{
    USHORT rc;

    return !(CheckOSError(KbdSetCp( 0, cp, 0 )));
}

bool
process_codepage_set(int cp)
{
    USHORT rc;

    return !(CheckOSError(DosSetProcessCp( cp )));
}

int
ppidOf(int pid)
{
  PQTOPLEVEL psi;
  int ppid;

  if (!pid)
      return -1;
  psi = get_sysinfo(pid, QSS_PROCESS);
  if (!psi)
      return -1;
  ppid = psi->procdata->ppid;
  Safefree(psi);
  return ppid;
}

int
sidOf(int pid)
{
  PQTOPLEVEL psi;
  int sid;

  if (!pid)
      return -1;
  psi = get_sysinfo(pid, QSS_PROCESS);
  if (!psi)
      return -1;
  sid = psi->procdata->sessid;
  Safefree(psi);
  return sid;
}

STRLEN
StrLen(ULONG addr, ULONG lim, I32 unitsize)
{
    switch (unitsize) {
      case 1:
	{
	    char *s = (char *)addr;
	    char *s1 = s, *e = (char *)(addr + lim);

	    while (s < e && *s)
		s++;
	    return s - s1;
	}
	break;
      case 2:
	{
	    short *s = (short *)addr;
	    short *s1 = s, *e = (short *)(addr + lim);

	    while (s < e && *s)
		s++;
	    return (char*)s - (char*)s1;
	}
	break;
      case 4:
	{
	    int *s = (int *)addr;
	    int *s1 = s, *e = (int *)(addr + lim);

	    while (s < e && *s)
		s++;
	    return (char*)s - (char*)s1;
	}
	break;
      case 8:
	{
	    long long *s = (long long *)addr;
	    long long *s1 = s, *e = (long long *)(addr + lim);

	    while (s < e && *s)
		s++;
	    return (char*)s - (char*)s1;
	}
	break;
      default:
	croak("StrLen: unknown unitsize %d", (int)unitsize);
    }
}

#define ulMPFROMSHORT(i)		((unsigned long)MPFROMSHORT(i))
#define ulMPVOID()			((unsigned long)MPVOID)
#define ulMPFROMCHAR(i)			((unsigned long)MPFROMCHAR(i))
#define ulMPFROM2SHORT(x1,x2)		((unsigned long)MPFROM2SHORT(x1,x2))
#define ulMPFROMSH2CH(s, c1, c2)	((unsigned long)MPFROMSH2CH(s, c1, c2))
#define ulMPFROMLONG(x)			((unsigned long)MPFROMLONG(x))

#define _MessageBox			MessageBox
#define _MessageBox2			MessageBox2

MODULE = OS2::Process		PACKAGE = OS2::Process

PROTOTYPES: ENABLE

unsigned long
constant(name,arg)
	char *		name
	int		arg

char *
my_type()

U32
file_type(path)
    char *path

SV *
swentry_expand( SV *sv )
    PPCODE:
     {
	 STRLEN l;
	 PSWENTRY pswentry = (PSWENTRY)SvPV(sv, l);

	 if (l != sizeof(SWENTRY))
		croak("Wrong structure size %ld!=%ld in swentry_expand()", (long)l, (long)sizeof(SWENTRY));
	 EXTEND(sp,11);
	 PUSHs(sv_2mortal(newSVpv(pswentry->swctl.szSwtitle, 0)));
	 PUSHs(sv_2mortal(newSVnv(pswentry->swctl.hwnd)));
	 PUSHs(sv_2mortal(newSVnv(pswentry->swctl.hwndIcon)));
	 PUSHs(sv_2mortal(newSViv(pswentry->swctl.hprog)));
	 PUSHs(sv_2mortal(newSViv(pswentry->swctl.idProcess)));
	 PUSHs(sv_2mortal(newSViv(pswentry->swctl.idSession)));
	 PUSHs(sv_2mortal(newSViv(pswentry->swctl.uchVisibility & SWL_VISIBLE)));
	 PUSHs(sv_2mortal(newSViv(pswentry->swctl.uchVisibility & SWL_GRAYED)));
	 PUSHs(sv_2mortal(newSViv(pswentry->swctl.fbJump == SWL_JUMPABLE)));
	 PUSHs(sv_2mortal(newSViv(pswentry->swctl.bProgType)));
	 PUSHs(sv_2mortal(newSViv(pswentry->hswitch)));
     }

SV *
create_swentry( char *title, unsigned long sw_hwnd, unsigned long icon_hwnd, unsigned long owner_phandle, unsigned long owner_pid, unsigned long owner_sid, unsigned long visible, unsigned long switchable,	 unsigned long jumpable, unsigned long ptype, unsigned long sw_entry)
PROTOTYPE: DISABLE

int
change_swentry( SV *sv )

bool
sesmgr_title_set(s)
    char *s

SV *
process_swentry(unsigned long pid = getpid(), HWND hwnd = NULLHANDLE);
  PROTOTYPE: DISABLE

int
swentry_size()

SV *
swentries_list()

void
ResetWinError()
   POSTCALL:
	XSRETURN_YES;

int
WindowText_set(HWND hwndFrame, char *title)

bool
FocusWindow_set(HWND hwndFocus, HWND hwndDesktop = HWND_DESKTOP)

bool
ShowWindow(HWND hwnd, bool fShow = TRUE)

bool
EnableWindow(HWND hwnd, bool fEnable = TRUE)

bool
PostMsg(HWND hwnd, unsigned long msg, unsigned long mp1 = 0, unsigned long mp2 = 0)
    C_ARGS: hwnd, msg, (MPARAM)mp1, (MPARAM)mp2

bool
WindowPos_set(HWND hwnd, long x, long y, unsigned long fl = SWP_MOVE, long cx = 0, long cy = 0, HWND hwndInsertBehind = HWND_TOP)
  PROTOTYPE: DISABLE

unsigned long
BeginEnumWindows(HWND hwnd)

bool
EndEnumWindows(unsigned long henum)

unsigned long
GetNextWindow(unsigned long henum)

bool
IsWindowVisible(HWND hwnd)

bool
IsWindowEnabled(HWND hwnd)

bool
IsWindowShowing(HWND hwnd)

unsigned long
QueryWindow(HWND hwnd, long cmd)

unsigned long
IsChild(HWND hwnd, HWND hwndParent)

unsigned long
WindowFromId(HWND hwndParent, unsigned long id)

unsigned long
WindowFromPoint(long x, long y, HWND hwnd = HWND_DESKTOP, bool fChildren = TRUE)
PROTOTYPE: DISABLE

unsigned long
EnumDlgItem(HWND hwndDlg, unsigned long code, HWND hwnd = NULLHANDLE)
   C_ARGS: hwndDlg, hwnd, code

bool
EnableWindowUpdate(HWND hwnd, bool fEnable = TRUE)

bool
SetWindowBits(HWND hwnd, long index, unsigned long flData, unsigned long flMask)

bool
SetWindowPtr(HWND hwnd, long index, unsigned long p)
    C_ARGS: hwnd, index, (PVOID)p

bool
SetWindowULong(HWND hwnd, long index, unsigned long i)

bool
SetWindowUShort(HWND hwnd, long index, unsigned short i)

bool
IsWindow(HWND hwnd, HAB hab = Acquire_hab())
    C_ARGS: hab, hwnd

BOOL
ActiveWindow_set(HWND hwnd, HWND hwndDesktop = HWND_DESKTOP)
    CODE:
	RETVAL = SetActiveWindow(hwndDesktop, hwnd);

unsigned long
LoadPointer(unsigned long idres, unsigned long hmod = 0, HWND hwndDesktop = HWND_DESKTOP)
    C_ARGS: hwndDesktop, hmod, idres

int
out_codepage()

bool
out_codepage_set(int cp)

int
in_codepage()

bool
in_codepage_set(int cp)

SV *
screen()

bool
screen_set(SV *sv)

SV *
process_codepages()
  PPCODE:
  {
    ULONG cps[4], c, i = 0, rc;

    if (CheckOSError(DosQueryCp( sizeof(cps), cps, &c )))
	c = 0;
    c /= sizeof(ULONG);
    if (c >= 3)
    EXTEND(sp, c);
    while (i < c)
	PUSHs(sv_2mortal(newSViv(cps[i++])));
  }

bool
process_codepage_set(int cp)

void
cursor(OUTLIST int stp, OUTLIST int ep, OUTLIST int wp, OUTLIST int ap)
  PROTOTYPE:

bool
cursor_set(int s, int e, int w = cursor__(0), int a = cursor__(1))

SV*
_kbdChar(int nowait = 0, int handle = 0)

SV*
_kbdStatus(int handle = 0)

void
_kbdStatus_set(SV *sv, int handle = 0)
   POSTCALL:
	XSRETURN_YES;

SV*
_vioConfig(int which = 0, int handle = 0)

SV*
_vioMode()

void
_vioMode_set(SV *buffer)
   POSTCALL:
	XSRETURN_YES;

SV*
_vioState(int what, int first = -1, int count = -1)

void
_vioState_set(SV *buffer)
   POSTCALL:
	XSRETURN_YES;

SV*
vioFont( int type = 0, OUTLIST int w, OUTLIST int h)

void
vioFont_set(SV *buffer, int cellwidth, int cellheight, int type = 0)
   POSTCALL:
	XSRETURN_YES;

NO_OUTPUT bool
_ClipbrdData_set(unsigned long ulData, unsigned long fmt = CF_TEXT, unsigned long rgfFmtInfo = default_fmtInfo(fmt), HAB hab = perl_hab_GET())
    PROTOTYPE: DISABLE
    C_ARGS: hab, ulData, fmt, rgfFmtInfo
    POSTCALL:
	if (CheckWinError(RETVAL))
	    croak_with_os2error("_ClipbrdData_set() error");
	XSRETURN_YES;

void
ClipbrdData_set(SV *text, int convert_nl = 1, unsigned long fmt = CF_TEXT, unsigned long rgfFmtInfo = default_fmtInfo(fmt), HAB hab = perl_hab_GET())
    PROTOTYPE: DISABLE
    POSTCALL:
	XSRETURN_YES;

void
ClipbrdOwner_set(HWND hwnd, HAB hab = perl_hab_GET())
    C_ARGS: hab, hwnd
    POSTCALL:
	XSRETURN_YES;

void
ClipbrdViewer_set(HWND hwnd, HAB hab = perl_hab_GET())
    C_ARGS: hab, hwnd
    POSTCALL:
	XSRETURN_YES;

unsigned long
EnumClipbrdFmts(unsigned long fmt = 0, HAB hab = perl_hab_GET())
    C_ARGS: hab, fmt

unsigned long
AddAtom(char *pszAtomName, HATOMTBL hAtomTbl = QuerySystemAtomTable())
    C_ARGS: hAtomTbl, pszAtomName

unsigned long
FindAtom(char *pszAtomName, HATOMTBL hAtomTbl = QuerySystemAtomTable())
    C_ARGS: hAtomTbl, pszAtomName

unsigned long
_DeleteAtom(ATOM atom, HATOMTBL hAtomTbl = QuerySystemAtomTable())
    PROTOTYPE: DISABLE
    C_ARGS: hAtomTbl, atom

#if 0

unsigned long
WinDeleteAtom(ATOM atom, HATOMTBL hAtomTbl = QuerySystemAtomTable())
    C_ARGS: hAtomTbl, atom

#endif

void
Alarm(unsigned long rgfType = WA_ERROR, HWND hwndDesktop = HWND_DESKTOP)
    C_ARGS: hwndDesktop, rgfType
    POSTCALL:
	XSRETURN_YES;

void
FlashWindow(HWND hwndFrame, bool fFlash)
    POSTCALL:
	XSRETURN_YES;

STRLEN
StrLen(ULONG addr, ULONG lim, I32 unitsize = 1)

MODULE = OS2::Process		PACKAGE = OS2::Process	PREFIX = myQuery

SV *
myQueryWindowText(HWND hwnd)

SV *
myQueryClassName(HWND hwnd)

MODULE = OS2::Process		PACKAGE = OS2::Process	PREFIX = Query

unsigned long
QueryFocusWindow(HWND hwndDesktop = HWND_DESKTOP)

long
QueryWindowTextLength(HWND hwnd)

SV *
QueryWindowSWP(HWND hwnd)

unsigned long
QueryWindowULong(HWND hwnd, long index)

unsigned short
QueryWindowUShort(HWND hwnd, long index)

unsigned long
QueryActiveWindow(HWND hwnd = HWND_DESKTOP)

unsigned long
QueryDesktopWindow(HAB hab = Acquire_hab(), unsigned long hdc = NULLHANDLE)

unsigned long
QueryClipbrdData(unsigned long fmt = CF_TEXT, HAB hab = perl_hab_GET())
    C_ARGS: hab, fmt
    PROTOTYPE: DISABLE

ULONG
QueryMemoryRegionSize(ULONG addr, OUTLIST ULONG flagp, ULONG len = 0xFFFFFFFF - addr, I32 interrupt = 1)

unsigned long
QueryClipbrdViewer(HAB hab = perl_hab_GET())

unsigned long
QueryClipbrdOwner(HAB hab = perl_hab_GET())

void
CloseClipbrd(HAB hab = perl_hab_GET())
    POSTCALL:
	XSRETURN_YES;

void
EmptyClipbrd(HAB hab = perl_hab_GET())
   POSTCALL:
	XSRETURN_YES;

bool
OpenClipbrd(HAB hab = perl_hab_GET())

unsigned long
QueryAtomUsage(ATOM atom, HATOMTBL hAtomTbl = QuerySystemAtomTable())
    C_ARGS: hAtomTbl, atom

unsigned long
QueryAtomLength(ATOM atom, HATOMTBL hAtomTbl = QuerySystemAtomTable())
    C_ARGS: hAtomTbl, atom
   POSTCALL:
	if (!RETVAL)
	    XSRETURN_EMPTY;

unsigned long
QuerySystemAtomTable()

unsigned long
QuerySysPointer(long lId, bool fCopy = 1, HWND hwndDesktop = HWND_DESKTOP)
    C_ARGS: hwndDesktop, lId, fCopy

unsigned long
CreateAtomTable(unsigned long initial = 0, unsigned long buckets = 0)

unsigned long
_DestroyAtomTable(HATOMTBL hAtomTbl)
    PROTOTYPE: DISABLE


MODULE = OS2::Process		PACKAGE = OS2::Process	PREFIX = myWinQuery

unsigned long
myWinQueryWindowPtr(HWND hwnd, long index)

NO_OUTPUT BOOL
myWinQueryWindowProcess(HWND hwnd, OUTLIST unsigned long pid, OUTLIST unsigned long tid)
   PROTOTYPE: $
   POSTCALL:
	if (CheckWinError(RETVAL))
	    croak_with_os2error("WindowProcess() error");

SV *
myWinQueryActiveDesktopPathname()

void
myWinQueryClipbrdFmtInfo(OUTLIST unsigned long prgfFmtInfo, unsigned long fmt = CF_TEXT, HAB hab = perl_hab_GET())
   C_ARGS: hab, fmt, &prgfFmtInfo

SV *
myWinQueryAtomName(ATOM atom, HATOMTBL hAtomTbl = QuerySystemAtomTable())

MODULE = OS2::Process		PACKAGE = OS2::Process	PREFIX = myWin

int
myWinSwitchToProgram(HSWITCH hsw = switch_of(NULLHANDLE, getpid()))
    PREINIT:
	ULONG rc;

#if 0

unsigned long
myWinMessageBox(unsigned long pszText, char* pszCaption = "Perl script message", unsigned long flStyle = MB_CANCEL | MB_ICONHAND, HWND hwndParent = HWND_DESKTOP, HWND hwndOwner = HWND_DESKTOP, unsigned long idWindow = 0)
    C_ARGS: hwndParent, hwndOwner, pszText, pszCaption, idWindow, flStyle

#endif

unsigned long
_MessageBox(char* pszText, char* pszCaption = "Perl script message", unsigned long flStyle = MB_CANCEL | MB_INFORMATION | MB_MOVEABLE, HWND hwndParent = HWND_DESKTOP, HWND hwndOwner = NULLHANDLE, unsigned long idWindow = 0)
    C_ARGS: hwndParent, hwndOwner, pszText, pszCaption, idWindow, flStyle
    POSTCALL:
	if (RETVAL == MBID_ERROR)
	    RETVAL = 0;

unsigned long
_MessageBox2(char *pszText, char* pmb2info, char *pszCaption = "Perl script message", HWND hwndParent = HWND_DESKTOP, HWND hwndOwner = NULLHANDLE, unsigned long idWindow = 0)
    C_ARGS: hwndParent, hwndOwner, pszText, pszCaption, idWindow, (PMB2INFO)pmb2info
    POSTCALL:
	if (RETVAL == MBID_ERROR)
	    RETVAL = 0;

MODULE = OS2::Process		PACKAGE = OS2::Process	PREFIX = myWinQuery

MODULE = OS2::Process		PACKAGE = OS2::Process	PREFIX = get

int
getppid()

int
ppidOf(int pid = getpid())

int
sidOf(int pid = getpid())

void
getscrsize(OUTLIST int wp, OUTLIST int hp)
  PROTOTYPE:

bool
scrsize_set(int w_or_h, int h = -9999)

void
get_InvalidateRect(HWND hwnd, char *prcl, bool fIncludeChildren)

void
get_CreateFrameControls(HWND hwndFrame, char *pfcdata, char* pszTitle)

MODULE = OS2::Process		PACKAGE = OS2::Process	PREFIX = ul

unsigned long
ulMPFROMSHORT(unsigned short i)

unsigned long
ulMPVOID()

unsigned long
ulMPFROMCHAR(unsigned char i)

unsigned long
ulMPFROM2SHORT(unsigned short x1, unsigned short x2)
  PROTOTYPE: DISABLE

unsigned long
ulMPFROMSH2CH(unsigned short s, unsigned char c1, unsigned char c2)
  PROTOTYPE: DISABLE

unsigned long
ulMPFROMLONG(unsigned long x)

@


1.6
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@@


1.5
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@a317 2
DeclWinFunc_CACHE(HWND, QueryClipbrdViewer, (HAB hab), (hab));
DeclWinFunc_CACHE(HWND, QueryClipbrdOwner, (HAB hab), (hab));
a324 4
DeclWinFunc_CACHE(ATOM, FindAtom, (HATOMTBL hAtomTbl, PCSZ pszAtomName),
		  (hAtomTbl, pszAtomName));
DeclWinFunc_CACHE(ATOM, DeleteAtom, (HATOMTBL hAtomTbl, PCSZ pszAtomName),
		  (hAtomTbl, pszAtomName));
a334 1
DeclWinFunc_CACHE(HATOMTBL, DestroyAtomTable, (HATOMTBL hAtomTbl), (hAtomTbl));
d349 7
d381 10
d534 3
a536 1
    ULONG len = QueryAtomLength(hAtomTbl, atom);
d541 9
a549 4
    QueryAtomName(hAtomTbl, atom, SvPV(sv, n_a), len);
    SvCUR_set(sv, len);
    *SvEND(sv) = 0;
    return sv;
d559 7
a565 5
    char *buf = SvPV_force(sv, len);
    char *pByte = 0, *s = buf, c;
    ULONG nls = 0, rc;

    if (convert_nl) {
d572 1
a572 1
    }
d574 1
a574 1
    if (CheckOSError(DosAllocSharedMem((PPVOID)&pByte, 0, len + nls + 1,
d578 1
a578 1
    if (!nls)
d580 1
a580 1
    else {
d588 4
d594 3
a596 2
    if (!SetClipbrdData(hab, (ULONG)pByte, fmt, rgfFmtInfo)) {
	DosFreeMem((PPVOID)&pByte);
d601 37
d1359 49
d1480 2
d1618 2
d1629 2
d1637 2
d1645 2
d1649 1
a1649 1
_ClipbrdData_set(unsigned long ulData, unsigned long fmt = CF_TEXT, unsigned long rgfFmtInfo = ((fmt == CF_TEXT || fmt == CF_DSPTEXT) ? CFI_POINTER : CFI_HANDLE), HAB hab = perl_hab_GET())
d1655 1
d1658 1
a1658 1
ClipbrdData_set(SV *text, int convert_nl = 1, unsigned long fmt = CF_TEXT, unsigned long rgfFmtInfo = ((fmt == CF_TEXT || fmt == CF_DSPTEXT) ? CFI_POINTER : CFI_HANDLE), HAB hab = perl_hab_GET())
d1660 2
d1666 2
d1672 2
d1688 11
a1698 2
DeleteAtom(char *pszAtomName, HATOMTBL hAtomTbl = QuerySystemAtomTable())
    C_ARGS: hAtomTbl, pszAtomName
d1703 2
d1708 5
d1750 3
d1761 2
d1766 2
d1779 3
d1794 2
a1795 1
DestroyAtomTable(HATOMTBL hAtomTbl)
d1830 1
a1830 1
myWinMessageBox(unsigned long pszText, char* pszCaption = "Perl script error", unsigned long flStyle = MB_CANCEL | MB_ICONHAND, HWND hwndParent = HWND_DESKTOP, HWND hwndOwner = HWND_DESKTOP, unsigned long idWindow = 0)
d1836 1
a1836 1
_MessageBox(char* pszText, char* pszCaption = "Perl script error", unsigned long flStyle = MB_CANCEL | MB_INFORMATION | MB_MOVEABLE, HWND hwndParent = HWND_DESKTOP, HWND hwndOwner = NULLHANDLE, unsigned long idWindow = 0)
d1843 1
a1843 1
_MessageBox2(char *pszText, char* pmb2info, char *pszCaption, HWND hwndParent = HWND_DESKTOP, HWND hwndOwner = NULLHANDLE, unsigned long idWindow = 0)
@


1.4
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d10 2
d239 1
d245 2
a246 1
	croak("DosQueryAppType err %ld", rc); 
d267 1
a267 1

d307 57
d398 3
d422 1
a422 1
    len = WinQueryWindowText(hwnd, l + 1, SvPV_force(sv, n_a));
d478 2
a479 2
static void
fill_swentry(SWENTRY *swentryp, HWND hwnd, PID pid)
a480 1
	 int rc;
d487 11
a497 1
	     croak("WinQuerySwitchHandle: %s", os2error(Perl_rc));
d500 1
a500 1
	     croak("WinQuerySwitchEntry err %ld", rc);
d509 97
d681 1
a681 1
process_swentry(unsigned long pid, unsigned long hwnd)
d833 1
a833 1
	croak("VioGetCurType() error");
d879 1
a879 1
	croak("Can't get size of buffer for screen");
d892 280
a1171 1
    
d1218 1
a1218 1
	croak("DosQueryCp() error");
d1228 1
a1228 1
	croak("VioGetCp() error");
d1246 1
a1246 1
	croak("KbdGetCp() error");
d1305 3
d1359 1
a1359 1
process_swentry(unsigned long pid = getpid(), unsigned long hwnd = NULLHANDLE);
d1372 1
a1372 1
WindowText_set(unsigned long hwndFrame, char *title)
d1375 1
a1375 1
FocusWindow_set(unsigned long hwndFocus, unsigned long hwndDesktop = HWND_DESKTOP)
d1378 1
a1378 1
ShowWindow(unsigned long hwnd, bool fShow = TRUE)
d1381 1
a1381 1
EnableWindow(unsigned long hwnd, bool fEnable = TRUE)
d1384 1
a1384 1
PostMsg(unsigned long hwnd, unsigned long msg, unsigned long mp1 = 0, unsigned long mp2 = 0)
d1388 1
a1388 1
WindowPos_set(unsigned long hwnd, long x, long y, unsigned long fl = SWP_MOVE, long cx = 0, long cy = 0, unsigned long hwndInsertBehind = HWND_TOP)
d1392 1
a1392 1
BeginEnumWindows(unsigned long hwnd)
d1401 1
a1401 1
IsWindowVisible(unsigned long hwnd)
d1404 1
a1404 1
IsWindowEnabled(unsigned long hwnd)
d1407 1
a1407 1
IsWindowShowing(unsigned long hwnd)
d1410 1
a1410 1
QueryWindow(unsigned long hwnd, long cmd)
d1413 1
a1413 1
IsChild(unsigned long hwnd, unsigned long hwndParent)
d1416 1
a1416 1
WindowFromId(unsigned long hwndParent, unsigned long id)
d1419 1
a1419 1
WindowFromPoint(long x, long y, unsigned long hwnd = HWND_DESKTOP, bool fChildren = TRUE)
d1423 1
a1423 1
EnumDlgItem(unsigned long hwndDlg, unsigned long code, unsigned long hwnd = NULLHANDLE)
d1427 1
a1427 1
EnableWindowUpdate(unsigned long hwnd, bool fEnable = TRUE)
d1430 1
a1430 1
SetWindowBits(unsigned long hwnd, long index, unsigned long flData, unsigned long flMask)
d1433 1
a1433 1
SetWindowPtr(unsigned long hwnd, long index, unsigned long p)
d1437 1
a1437 1
SetWindowULong(unsigned long hwnd, long index, unsigned long i)
d1440 1
a1440 1
SetWindowUShort(unsigned long hwnd, long index, unsigned short i)
d1443 1
a1443 1
IsWindow(unsigned long hwnd, unsigned long hab = Acquire_hab())
d1447 1
a1447 1
ActiveWindow_set(unsigned long hwnd, unsigned long hwndDesktop = HWND_DESKTOP)
d1451 4
d1498 73
d1574 1
a1574 1
myQueryWindowText(unsigned long hwnd)
d1577 1
a1577 1
myQueryClassName(unsigned long hwnd)
d1582 1
a1582 1
QueryFocusWindow(unsigned long hwndDesktop = HWND_DESKTOP)
d1585 1
a1585 1
QueryWindowTextLength(unsigned long hwnd)
d1588 1
a1588 1
QueryWindowSWP(unsigned long hwnd)
d1591 1
a1591 1
QueryWindowULong(unsigned long hwnd, long index)
d1594 38
a1631 1
QueryWindowUShort(unsigned long hwnd, long index)
d1634 2
a1635 1
QueryActiveWindow(unsigned long hwnd = HWND_DESKTOP)
d1638 5
a1642 1
QueryDesktopWindow(unsigned long hab = Acquire_hab(), unsigned long hdc = NULLHANDLE)
d1647 1
a1647 1
myWinQueryWindowPtr(unsigned long hwnd, long index)
d1650 1
a1650 1
myWinQueryWindowProcess(unsigned long hwnd, OUTLIST unsigned long pid, OUTLIST unsigned long tid)
d1654 11
a1664 1
	    croak("WindowProcess() error");
d1669 1
a1669 1
myWinSwitchToProgram(unsigned long hsw)
d1673 22
d1714 6
@


1.3
log
@perl-5.6.0 + local changes
@
text
@a0 4
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

d4 6
d12 4
d248 166
d415 1
a415 1
fill_swcntrl(SWCNTRL *swcntrlp)
a417 2
	 PTIB ptib;
	 PPIB ppib;
a418 1
	 HWND hwndMe;
a421 2
	 if (CheckOSError(DosGetInfoBlocks(&ptib, &ppib)))
	     croak("DosGetInfoBlocks err %ld", rc);
d423 4
a426 4
			   WinQuerySwitchHandle(NULLHANDLE, 
						(PID)ppib->pib_ulpid)))
	     croak("WinQuerySwitchHandle err %ld", Perl_rc);
	 if (CheckOSError(WinQuerySwitchEntry(hSwitch, swcntrlp)))
d430 6
d443 1
a443 1
set_title(char *s)
d445 1
a445 1
    SWCNTRL swcntrl;
d450 1
a450 1
    fill_swcntrl(&swcntrl);
d473 1
a473 1
set_title(char *s)
d475 1
a475 3
    SWCNTRL swcntrl;
    static HMODULE hdosc = 0;
    BYTE buf[20];
d478 1
a478 1
    fill_swcntrl(&swcntrl);
d481 1
a481 1
           _THUNK_SHORT (swcntrl.idSession);
d510 346
d858 1
d872 2
a873 2
U32
process_entry()
d876 2
a877 1
	 SWCNTRL swcntrl;
d879 14
a892 12
	 fill_swcntrl(&swcntrl);
	 EXTEND(sp,9);
	 PUSHs(sv_2mortal(newSVpv(swcntrl.szSwtitle, 0)));
	 PUSHs(sv_2mortal(newSVnv(swcntrl.hwnd)));
	 PUSHs(sv_2mortal(newSVnv(swcntrl.hwndIcon)));
	 PUSHs(sv_2mortal(newSViv(swcntrl.hprog)));
	 PUSHs(sv_2mortal(newSViv(swcntrl.idProcess)));
	 PUSHs(sv_2mortal(newSViv(swcntrl.idSession)));
	 PUSHs(sv_2mortal(newSViv(swcntrl.uchVisibility != SWL_INVISIBLE)));
	 PUSHs(sv_2mortal(newSViv(swcntrl.uchVisibility == SWL_GRAYED)));
	 PUSHs(sv_2mortal(newSViv(swcntrl.fbJump == SWL_JUMPABLE)));
	 PUSHs(sv_2mortal(newSViv(swcntrl.bProgType)));
d895 7
d903 1
a903 1
set_title(s)
d905 229
@


1.2
log
@perl5.005_03 (stock)
@
text
@a9 8
static int
not_here(s)
char *s;
{
    croak("%s not implemented on this architecture", s);
    return -1;
}

d11 1
a11 3
constant(name, arg)
char *name;
int arg;
@


1.1
log
@perl 5.004_04
@
text
@d6 3
d139 67
d216 132
d357 30
@


1.1.1.1
log
@perl5.005_03
@
text
@a5 3
#define INCL_DOS
#define INCL_DOSERRORS
#include <os2.h>
a135 67
    } else if (name[0] == 'T' && name[1] == '_') {
	if (strEQ(name, "FAPPTYP_NOTSPEC"))
#ifdef FAPPTYP_NOTSPEC
	    return FAPPTYP_NOTSPEC;
#else
	    goto not_there;
#endif
	if (strEQ(name, "T_NOTWINDOWCOMPAT"))
#ifdef FAPPTYP_NOTWINDOWCOMPAT
	    return FAPPTYP_NOTWINDOWCOMPAT;
#else
	    goto not_there;
#endif
	if (strEQ(name, "T_WINDOWCOMPAT"))
#ifdef FAPPTYP_WINDOWCOMPAT
	    return FAPPTYP_WINDOWCOMPAT;
#else
	    goto not_there;
#endif
	if (strEQ(name, "T_WINDOWAPI"))
#ifdef FAPPTYP_WINDOWAPI
	    return FAPPTYP_WINDOWAPI;
#else
	    goto not_there;
#endif
	if (strEQ(name, "T_BOUND"))
#ifdef FAPPTYP_BOUND
	    return FAPPTYP_BOUND;
#else
	    goto not_there;
#endif
	if (strEQ(name, "T_DLL"))
#ifdef FAPPTYP_DLL
	    return FAPPTYP_DLL;
#else
	    goto not_there;
#endif
	if (strEQ(name, "T_DOS"))
#ifdef FAPPTYP_DOS
	    return FAPPTYP_DOS;
#else
	    goto not_there;
#endif
	if (strEQ(name, "T_PHYSDRV"))
#ifdef FAPPTYP_PHYSDRV
	    return FAPPTYP_PHYSDRV;
#else
	    goto not_there;
#endif
	if (strEQ(name, "T_VIRTDRV"))
#ifdef FAPPTYP_VIRTDRV
	    return FAPPTYP_VIRTDRV;
#else
	    goto not_there;
#endif
	if (strEQ(name, "T_PROTDLL"))
#ifdef FAPPTYP_PROTDLL
	    return FAPPTYP_PROTDLL;
#else
	    goto not_there;
#endif
	if (strEQ(name, "T_32BIT"))
#ifdef FAPPTYP_32BIT
	    return FAPPTYP_32BIT;
#else
	    goto not_there;
#endif
a145 132
const char* const ptypes[] = { "FS", "DOS", "VIO", "PM", "DETACH" };

static char *
my_type()
{
    int rc;
    TIB *tib;
    PIB *pib;
    
    if (!(_emx_env & 0x200)) return (char*)ptypes[1]; /* not OS/2. */
    if (CheckOSError(DosGetInfoBlocks(&tib, &pib))) 
	return NULL; 
    
    return (pib->pib_ultype <= 4 ? (char*)ptypes[pib->pib_ultype] : "UNKNOWN");
}

static ULONG
file_type(char *path)
{
    int rc;
    ULONG apptype;
    
    if (!(_emx_env & 0x200)) 
	croak("file_type not implemented on DOS"); /* not OS/2. */
    if (CheckOSError(DosQueryAppType(path, &apptype))) {
	if (rc == ERROR_INVALID_EXE_SIGNATURE) 
	    croak("Invalid EXE signature"); 
	else if (rc == ERROR_EXE_MARKED_INVALID) {
	    croak("EXE marked invalid"); 
	}
	croak("DosQueryAppType err %ld", rc); 
    }
    
    return apptype;
}

static void
fill_swcntrl(SWCNTRL *swcntrlp)
{
	 int rc;
	 PTIB ptib;
	 PPIB ppib;
	 HSWITCH hSwitch;    
	 HWND hwndMe;

	 if (!(_emx_env & 0x200)) 
	     croak("switch_entry not implemented on DOS"); /* not OS/2. */
	 if (CheckOSError(DosGetInfoBlocks(&ptib, &ppib)))
	     croak("DosGetInfoBlocks err %ld", rc);
	 if (CheckWinError(hSwitch = 
			   WinQuerySwitchHandle(NULLHANDLE, 
						(PID)ppib->pib_ulpid)))
	     croak("WinQuerySwitchHandle err %ld", Perl_rc);
	 if (CheckOSError(WinQuerySwitchEntry(hSwitch, swcntrlp)))
	     croak("WinQuerySwitchEntry err %ld", rc);
}

/* static ULONG (* APIENTRY16 pDosSmSetTitle)(ULONG, PSZ); */
ULONG _THUNK_FUNCTION(DosSmSetTitle)(ULONG, PSZ);

#if 0			/*  Does not work.  */
static ULONG (*pDosSmSetTitle)(ULONG, PSZ);

static void
set_title(char *s)
{
    SWCNTRL swcntrl;
    static HMODULE hdosc = 0;
    BYTE buf[20];
    long rc;

    fill_swcntrl(&swcntrl);
    if (!pDosSmSetTitle || !hdosc) {
	if (CheckOSError(DosLoadModule(buf, sizeof buf, "sesmgr", &hdosc)))
	    croak("Cannot load SESMGR: no `%s'", buf);
	if (CheckOSError(DosQueryProcAddr(hdosc, 0, "DOSSMSETTITLE",
					  (PFN*)&pDosSmSetTitle)))
	    croak("Cannot load SESMGR.DOSSMSETTITLE, err=%ld", rc);
    }
/*     (pDosSmSetTitle)(swcntrl.idSession,s); */
    rc = ((USHORT)
          (_THUNK_PROLOG (2+4);
           _THUNK_SHORT (swcntrl.idSession);
           _THUNK_FLAT (s);
           _THUNK_CALLI (*pDosSmSetTitle)));
    if (CheckOSError(rc))
	warn("*DOSSMSETTITLE: err=%ld, ses=%ld, addr=%x, *paddr=%x", 
	     rc, swcntrl.idSession, &_THUNK_FUNCTION(DosSmSetTitle),
	     pDosSmSetTitle);
}

#else /* !0 */

static bool
set_title(char *s)
{
    SWCNTRL swcntrl;
    static HMODULE hdosc = 0;
    BYTE buf[20];
    long rc;

    fill_swcntrl(&swcntrl);
    rc = ((USHORT)
          (_THUNK_PROLOG (2+4);
           _THUNK_SHORT (swcntrl.idSession);
           _THUNK_FLAT (s);
           _THUNK_CALL (DosSmSetTitle)));
#if 0
    if (CheckOSError(rc))
	warn("DOSSMSETTITLE: err=%ld, ses=%ld, addr=%x", 
	     rc, swcntrl.idSession, _THUNK_FUNCTION(DosSmSetTitle));
#endif
    return !CheckOSError(rc);
}
#endif /* !0 */

#if 0			/*  Does not work.  */
USHORT _THUNK_FUNCTION(Win16SetTitle) ();

static void
set_title2(char *s)
{
    long rc;

    rc = ((USHORT)
          (_THUNK_PROLOG (4);
           _THUNK_FLAT (s);
           _THUNK_CALL (Win16SetTitle)));
    if (CheckWinError(rc))
	warn("Win16SetTitle: err=%ld", rc);
}
#endif
a154 30
char *
my_type()

U32
file_type(path)
    char *path

U32
process_entry()
    PPCODE:
     {
	 SWCNTRL swcntrl;

	 fill_swcntrl(&swcntrl);
	 EXTEND(sp,9);
	 PUSHs(sv_2mortal(newSVpv(swcntrl.szSwtitle, 0)));
	 PUSHs(sv_2mortal(newSVnv(swcntrl.hwnd)));
	 PUSHs(sv_2mortal(newSVnv(swcntrl.hwndIcon)));
	 PUSHs(sv_2mortal(newSViv(swcntrl.hprog)));
	 PUSHs(sv_2mortal(newSViv(swcntrl.idProcess)));
	 PUSHs(sv_2mortal(newSViv(swcntrl.idSession)));
	 PUSHs(sv_2mortal(newSViv(swcntrl.uchVisibility != SWL_INVISIBLE)));
	 PUSHs(sv_2mortal(newSViv(swcntrl.uchVisibility == SWL_GRAYED)));
	 PUSHs(sv_2mortal(newSViv(swcntrl.fbJump == SWL_JUMPABLE)));
	 PUSHs(sv_2mortal(newSViv(swcntrl.bProgType)));
     }

bool
set_title(s)
    char *s
@


1.1.1.2
log
@virgin perl 5.6.0
@
text
@d10 8
d19 3
a21 1
constant(char *name, int arg)
@


1.1.1.3
log
@stock perl 5.8.0 from CPAN
@
text
@d1 4
a7 6
#define INCL_DOSNLS
#define INCL_WINSWITCHLIST
#define INCL_WINWINDOWMGR
#define INCL_WININPUT
#define INCL_VIO
#define INCL_KBD
a9 4
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

a241 166
/* These use different type of wrapper.  Good to check wrappers. ;-)  */
/* XXXX This assumes DOS type return type, without SEVERITY?! */
DeclFuncByORD(HSWITCH, myWinQuerySwitchHandle,  ORD_WinQuerySwitchHandle,
		  (HWND hwnd, PID pid), (hwnd, pid))
DeclFuncByORD(ULONG, myWinQuerySwitchEntry,  ORD_WinQuerySwitchEntry,
		  (HSWITCH hsw, PSWCNTRL pswctl), (hsw, pswctl))
DeclFuncByORD(ULONG, myWinSetWindowText,  ORD_WinSetWindowText,
		  (HWND hwnd, char* text), (hwnd, text))
DeclFuncByORD(BOOL, myWinQueryWindowProcess,  ORD_WinQueryWindowProcess,
		  (HWND hwnd, PPID ppid, PTID ptid), (hwnd, ppid, ptid))
DeclFuncByORD(ULONG, XmyWinSwitchToProgram,  ORD_WinSwitchToProgram,
		  (HSWITCH hsw), (hsw))
#define myWinSwitchToProgram(hsw) (!CheckOSError(XmyWinSwitchToProgram(hsw)))



DeclWinFunc_CACHE(HWND, QueryWindow, (HWND hwnd, LONG cmd), (hwnd, cmd))
DeclWinFunc_CACHE(BOOL, QueryWindowPos, (HWND hwnd, PSWP pswp),
		  (hwnd, pswp))
DeclWinFunc_CACHE(LONG, QueryWindowText,
		  (HWND hwnd, LONG cchBufferMax, PCH pchBuffer),
		  (hwnd, cchBufferMax, pchBuffer))
DeclWinFunc_CACHE(LONG, QueryClassName, (HWND hwnd, LONG cchMax, PCH pch),
		  (hwnd, cchMax, pch))
DeclWinFunc_CACHE(HWND, QueryFocus, (HWND hwndDesktop), (hwndDesktop))
DeclWinFunc_CACHE(BOOL, SetFocus, (HWND hwndDesktop, HWND hwndFocus),
		  (hwndDesktop, hwndFocus))
DeclWinFunc_CACHE(BOOL, ShowWindow, (HWND hwnd, BOOL fShow), (hwnd, fShow))
DeclWinFunc_CACHE(BOOL, EnableWindow, (HWND hwnd, BOOL fEnable),
		      (hwnd, fEnable))
DeclWinFunc_CACHE(BOOL, SetWindowPos,
		  (HWND hwnd, HWND hwndInsertBehind, LONG x, LONG y,
		   LONG cx, LONG cy, ULONG fl),
		  (hwnd, hwndInsertBehind, x, y, cx, cy, fl))
DeclWinFunc_CACHE(HENUM, BeginEnumWindows, (HWND hwnd), (hwnd))
DeclWinFunc_CACHE(BOOL, EndEnumWindows, (HENUM henum), (henum))
DeclWinFunc_CACHE(BOOL, EnableWindowUpdate, (HWND hwnd, BOOL fEnable),
		  (hwnd, fEnable))
DeclWinFunc_CACHE(BOOL, SetWindowBits,
		  (HWND hwnd, LONG index, ULONG flData, ULONG flMask),
		  (hwnd, index, flData, flMask))
DeclWinFunc_CACHE(BOOL, SetWindowPtr, (HWND hwnd, LONG index, PVOID p),
		  (hwnd, index, p))
DeclWinFunc_CACHE(BOOL, SetWindowULong, (HWND hwnd, LONG index, ULONG ul),
		  (hwnd, index, ul))
DeclWinFunc_CACHE(BOOL, SetWindowUShort, (HWND hwnd, LONG index, USHORT us),
		  (hwnd, index, us))
DeclWinFunc_CACHE(HWND, IsChild, (HWND hwnd, HWND hwndParent),
		  (hwnd, hwndParent))
DeclWinFunc_CACHE(HWND, WindowFromId, (HWND hwnd, ULONG id), (hwnd, id))
DeclWinFunc_CACHE(HWND, EnumDlgItem, (HWND hwndDlg, HWND hwnd, ULONG code),
		  (hwndDlg, hwnd, code))
DeclWinFunc_CACHE(HWND, QueryDesktopWindow, (HAB hab, HDC hdc), (hab, hdc));
DeclWinFunc_CACHE(BOOL, SetActiveWindow, (HWND hwndDesktop, HWND hwnd),
		  (hwndDesktop, hwnd));

/* These functions may return 0 on success; check $^E/Perl_rc on res==0: */
DeclWinFunc_CACHE_resetError(PVOID, QueryWindowPtr, (HWND hwnd, LONG index),
			     (hwnd, index))
DeclWinFunc_CACHE_resetError(ULONG, QueryWindowULong, (HWND hwnd, LONG index),
			     (hwnd, index))
DeclWinFunc_CACHE_resetError(SHORT, QueryWindowUShort, (HWND hwnd, LONG index),
			     (hwnd, index))
DeclWinFunc_CACHE_resetError(LONG,  QueryWindowTextLength, (HWND hwnd), (hwnd))
DeclWinFunc_CACHE_resetError(HWND,  QueryActiveWindow, (HWND hwnd), (hwnd))
DeclWinFunc_CACHE_resetError(BOOL, PostMsg,
			     (HWND hwnd, ULONG msg, MPARAM mp1, MPARAM mp2),
			     (hwnd, msg, mp1, mp2))
DeclWinFunc_CACHE_resetError(HWND, GetNextWindow, (HENUM henum), (henum))
DeclWinFunc_CACHE_resetError(BOOL, IsWindowEnabled, (HWND hwnd), (hwnd))
DeclWinFunc_CACHE_resetError(BOOL, IsWindowVisible, (HWND hwnd), (hwnd))
DeclWinFunc_CACHE_resetError(BOOL, IsWindowShowing, (HWND hwnd), (hwnd))

/* No die()ing on error */
DeclWinFunc_CACHE_survive(BOOL, IsWindow, (HAB hab, HWND hwnd), (hab, hwnd))

/* These functions are called frow complicated wrappers: */
ULONG (*pWinQuerySwitchList) (HAB hab, PSWBLOCK pswblk, ULONG usDataLength);
ULONG (*pWinChangeSwitchEntry) (HSWITCH hsw, __const__ SWCNTRL *pswctl);
HWND (*pWinWindowFromPoint)(HWND hwnd, __const__ POINTL *pptl, BOOL fChildren);


/* These functions have different names/signatures than what is
   declared above */
#define QueryFocusWindow QueryFocus
#define FocusWindow_set(hwndFocus, hwndDesktop) SetFocus(hwndDesktop, hwndFocus)
#define WindowPos_set(hwnd, x, y, fl, cx, cy, hwndInsertBehind)	\
	SetWindowPos(hwnd, hwndInsertBehind, x, y, cx, cy, fl)
#define myWinQueryWindowPtr(hwnd, i)	((ULONG)QueryWindowPtr(hwnd, i))

int
WindowText_set(HWND hwnd, char* text)
{
   return !CheckWinError(myWinSetWindowText(hwnd, text));
}

SV *
myQueryWindowText(HWND hwnd)
{
    LONG l = QueryWindowTextLength(hwnd), len;
    SV *sv;
    STRLEN n_a;

    if (l == 0) {
	if (Perl_rc)		/* Last error */
	    return &PL_sv_undef;
	return &PL_sv_no;
    }
    sv = newSVpvn("", 0);
    SvGROW(sv, l + 1);
    len = WinQueryWindowText(hwnd, l + 1, SvPV_force(sv, n_a));
    if (len != l) {
	Safefree(sv);
	croak("WinQueryWindowText() uncompatible with WinQueryWindowTextLength()");
    }
    SvCUR_set(sv, l);
    return sv;
}

SWP
QueryWindowSWP_(HWND hwnd)
{
    SWP swp;

    if (!QueryWindowPos(hwnd, &swp))
	croak("WinQueryWindowPos() error");
    return swp;
}

SV *
QueryWindowSWP(HWND hwnd)
{
    SWP swp = QueryWindowSWP_(hwnd);

    return newSVpvn((char*)&swp, sizeof(swp));
}

SV *
myQueryClassName(HWND hwnd)
{
    SV *sv = newSVpvn("",0);
    STRLEN l = 46, len = 0, n_a;

    while (l + 1 >= len) {
	if (len)
	    len = 2*len + 10;		/* Grow quick */
	else
	    len = l + 2;
	SvGROW(sv, len);
	l = QueryClassName(hwnd, len, SvPV_force(sv, n_a));
    }
    SvCUR_set(sv, l);
    return sv;
}

HWND
WindowFromPoint(long x, long y, HWND hwnd, BOOL fChildren)
{
    POINTL ppl;

    ppl.x = x; ppl.y = y;
    if (!pWinWindowFromPoint)
	AssignFuncPByORD(pWinWindowFromPoint, ORD_WinWindowFromPoint);
    return SaveWinError(pWinWindowFromPoint(hwnd, &ppl, fChildren));
}

d243 1
a243 1
fill_swentry(SWENTRY *swentryp, HWND hwnd, PID pid)
d246 2
d249 1
d253 2
d256 4
a259 4
			   myWinQuerySwitchHandle(hwnd, pid)))
	     croak("WinQuerySwitchHandle: %s", os2error(Perl_rc));
	 swentryp->hswitch = hSwitch;
	 if (CheckOSError(myWinQuerySwitchEntry(hSwitch, &swentryp->swctl)))
a262 6
static void
fill_swentry_default(SWENTRY *swentryp)
{
	fill_swentry(swentryp, NULLHANDLE, getpid());
}

d270 1
a270 1
sesmgr_title_set(char *s)
d272 1
a272 1
    SWENTRY swentry;
d277 1
a277 1
    fill_swentry_default(&swentry);
d300 1
a300 1
sesmgr_title_set(char *s)
d302 3
a304 1
    SWENTRY swentry;
d307 1
a307 1
    fill_swentry_default(&swentry);
d310 1
a310 1
           _THUNK_SHORT (swentry.swctl.idSession);
a338 346
SV *
process_swentry(unsigned long pid, unsigned long hwnd)
{
    SWENTRY swentry;

    if (!(_emx_env & 0x200)) 
	     croak("process_swentry not implemented on DOS"); /* not OS/2. */
    fill_swentry(&swentry, hwnd, pid);
    return newSVpvn((char*)&swentry, sizeof(swentry));
}

SV *
swentries_list()
{
    int num, n = 0;
    STRLEN n_a;
    PSWBLOCK pswblk;
    SV *sv = newSVpvn("",0);

    if (!(_emx_env & 0x200)) 
	     croak("swentries_list not implemented on DOS"); /* not OS/2. */
    if (!pWinQuerySwitchList)
	AssignFuncPByORD(pWinQuerySwitchList, ORD_WinQuerySwitchList);
    num = pWinQuerySwitchList(0, NULL, 0);	/* HAB is not required */
    if (!num)
	croak("(Unknown) error during WinQuerySwitchList()");
    /* Allow one extra entry to allow overflow detection (may happen
	if the list has been changed). */
    while (num > n) {
	if (n == 0)
	    n = num + 1;
	else
	    n = 2*num + 10;			/* Enlarge quickly */
	SvGROW(sv, sizeof(ULONG) + sizeof(SWENTRY) * n + 1);
	pswblk = (PSWBLOCK) SvPV_force(sv, n_a);
	num = pWinQuerySwitchList(0, pswblk, SvLEN(sv));
    }
    SvCUR_set(sv, sizeof(ULONG) + sizeof(SWENTRY) * num);
    *SvEND(sv) = 0;
    return sv;
}

SWENTRY
swentry( char *title, HWND sw_hwnd, HWND icon_hwnd, HPROGRAM owner_phandle,
	 PID owner_pid, ULONG owner_sid, ULONG visible, ULONG nonswitchable,
	 ULONG jumpable, ULONG ptype, HSWITCH sw_entry)
{
  SWENTRY e;

  strncpy(e.swctl.szSwtitle, title, MAXNAMEL);
  e.swctl.szSwtitle[60] = 0;
  e.swctl.hwnd = sw_hwnd;
  e.swctl.hwndIcon = icon_hwnd;
  e.swctl.hprog = owner_phandle;
  e.swctl.idProcess = owner_pid;
  e.swctl.idSession = owner_sid;
  e.swctl.uchVisibility = ((visible ? SWL_VISIBLE : SWL_INVISIBLE)
			   | (nonswitchable ? SWL_GRAYED : 0));
  e.swctl.fbJump = (jumpable ? SWL_JUMPABLE : 0);
  e.swctl.bProgType = ptype;
  e.hswitch = sw_entry;
  return e;
}

SV *
create_swentry( char *title, HWND owner_hwnd, HWND icon_hwnd, HPROGRAM owner_phandle,
	 PID owner_pid, ULONG owner_sid, ULONG visible, ULONG nonswitchable,
	 ULONG jumpable, ULONG ptype, HSWITCH sw_entry)
{
    SWENTRY e = swentry(title, owner_hwnd, icon_hwnd, owner_phandle, owner_pid,
			owner_sid, visible, nonswitchable, jumpable, ptype,
			sw_entry);

    return newSVpvn((char*)&e, sizeof(e));
}

int
change_swentrysw(SWENTRY *sw)
{
    ULONG rc;			/* For CheckOSError */

    if (!(_emx_env & 0x200)) 
	     croak("change_entry() not implemented on DOS"); /* not OS/2. */
    if (!pWinChangeSwitchEntry)
	AssignFuncPByORD(pWinChangeSwitchEntry, ORD_WinChangeSwitchEntry);
    return !CheckOSError(pWinChangeSwitchEntry(sw->hswitch, &sw->swctl));
}

int
change_swentry(SV *sv)
{
    STRLEN l;
    PSWENTRY pswentry = (PSWENTRY)SvPV(sv, l);

    if (l != sizeof(SWENTRY))
	croak("Wrong structure size %ld!=%ld in change_swentry()", (long)l, (long)sizeof(SWENTRY));
    return change_swentrysw(pswentry);
}


#define swentry_size()		(sizeof(SWENTRY))

void
getscrsize(int *wp, int *hp)
{
    int i[2];

    _scrsize(i);
    *wp = i[0];
    *hp = i[1];
}

/* Force vio to not cross 64K-boundary: */
#define VIO_FROM_VIOB			\
    vio = viob;				\
    if (!_THUNK_PTR_STRUCT_OK(vio))	\
	vio++

bool
scrsize_set(int w, int h)
{
    VIOMODEINFO viob[2], *vio;
    ULONG rc;

    VIO_FROM_VIOB;

    if (h == -9999)
	h = w, w = 0;
    vio->cb = sizeof(*vio);
    if (CheckOSError(VioGetMode( vio, 0 )))
	return 0;

    if( w > 0 )
      vio->col = (USHORT)w;

    if( h > 0 )
      vio->row = (USHORT)h;

    vio->cb = 8;
    if (CheckOSError(VioSetMode( vio, 0 )))
	return 0;
    return 1;
}

void
cursor(int *sp, int *ep, int *wp, int *ap)
{
    VIOCURSORINFO viob[2], *vio;
    ULONG rc;

    VIO_FROM_VIOB;

    if (CheckOSError(VioGetCurType( vio, 0 )))
	croak("VioGetCurType() error");

    *sp = vio->yStart;
    *ep = vio->cEnd;
    *wp = vio->cx;
    *ep = vio->attr;
}

bool
cursor__(int is_a)
{
    int s,e,w,a;

    cursor(&s, &e, &w, &a);
    if (is_a)
	return a;
    else
	return w;
}

bool
cursor_set(int s, int e, int w, int a)
{
    VIOCURSORINFO viob[2], *vio;
    ULONG rc;

    VIO_FROM_VIOB;

    vio->yStart = s;
    vio->cEnd = e;
    vio->cx = w;
    vio->attr = a;
    return !CheckOSError(VioSetCurType( vio, 0 ));
}

static int
bufsize(void)
{
#if 1
    VIOMODEINFO viob[2], *vio;
    ULONG rc;

    VIO_FROM_VIOB;

    vio->cb = sizeof(*vio);
    if (CheckOSError(VioGetMode( vio, 0 )))
	croak("Can't get size of buffer for screen");
#if 0	/* buf=323552247, full=1118455, partial=0 */
    croak("Lengths: buf=%d, full=%d, partial=%d",vio->buf_length,vio->full_length,vio->partial_length);
    return newSVpvn((char*)vio->buf_addr, vio->full_length);
#endif
    return vio->col * vio->row * 2;	/* How to get bytes/cell?  2 or 4? */
#else	/* 0 */
    int i[2];

    _scrsize(i);
    return i[0]*i[1]*2;
#endif	/* 0 */
}
    
SV *
screen(void)
{
    ULONG rc;
    USHORT bufl = bufsize();
    char b[(1<<16) * 3]; /* This/3 is enough for 16-bit calls, we need
			    2x overhead due to 2 vs 4 issue, and extra
			    64K due to alignment logic */
    char *buf = b;
    
    if (((ULONG)buf) & 0xFFFF)
	buf += 0x10000 - (((ULONG)buf) & 0xFFFF);
    if ((sizeof(b) - (buf - b)) < 2*bufl)
	croak("panic: VIO buffer allocation");
    if (CheckOSError(VioReadCellStr( buf, &bufl, 0, 0, 0 )))
	return &PL_sv_undef;
    return newSVpvn(buf,bufl);
}

bool
screen_set(SV *sv)
{
    ULONG rc;
    STRLEN l = SvCUR(sv), bufl = bufsize();
    char b[(1<<16) * 2]; /* This/2 is enough for 16-bit calls, we need
			    extra 64K due to alignment logic */
    char *buf = b;
    
    if (((ULONG)buf) & 0xFFFF)
	buf += 0x10000 - (((ULONG)buf) & 0xFFFF);
    if (!SvPOK(sv) || ((l != bufl) && (l != 2*bufl)))
	croak("Wrong size %d of saved screen data", SvCUR(sv));
    if ((sizeof(b) - (buf - b)) < l)
	croak("panic: VIO buffer allocation");
    Copy(SvPV(sv,l), buf, bufl, char);
    if (CheckOSError(VioWrtCellStr( buf, bufl, 0, 0, 0 )))
	return 0;
    return 1;
}

int
process_codepages()
{
    ULONG cps[4], cp, rc;

    if (CheckOSError(DosQueryCp( sizeof(cps), cps, &cp )))
	croak("DosQueryCp() error");
    return cp;
}

int
out_codepage()
{
    USHORT cp, rc;

    if (CheckOSError(VioGetCp( 0, &cp, 0 )))
	croak("VioGetCp() error");
    return cp;
}

bool
out_codepage_set(int cp)
{
    USHORT rc;

    return !(CheckOSError(VioSetCp( 0, cp, 0 )));
}

int
in_codepage()
{
    USHORT cp, rc;

    if (CheckOSError(KbdGetCp( 0, &cp, 0 )))
	croak("KbdGetCp() error");
    return cp;
}

bool
in_codepage_set(int cp)
{
    USHORT rc;

    return !(CheckOSError(KbdSetCp( 0, cp, 0 )));
}

bool
process_codepage_set(int cp)
{
    USHORT rc;

    return !(CheckOSError(DosSetProcessCp( cp )));
}

int
ppidOf(int pid)
{
  PQTOPLEVEL psi;
  int ppid;

  if (!pid)
      return -1;
  psi = get_sysinfo(pid, QSS_PROCESS);
  if (!psi)
      return -1;
  ppid = psi->procdata->ppid;
  Safefree(psi);
  return ppid;
}

int
sidOf(int pid)
{
  PQTOPLEVEL psi;
  int sid;

  if (!pid)
      return -1;
  psi = get_sysinfo(pid, QSS_PROCESS);
  if (!psi)
      return -1;
  sid = psi->procdata->sessid;
  Safefree(psi);
  return sid;
}

#define ulMPFROMSHORT(i)		((unsigned long)MPFROMSHORT(i))
#define ulMPVOID()			((unsigned long)MPVOID)
#define ulMPFROMCHAR(i)			((unsigned long)MPFROMCHAR(i))
#define ulMPFROM2SHORT(x1,x2)		((unsigned long)MPFROM2SHORT(x1,x2))
#define ulMPFROMSH2CH(s, c1, c2)	((unsigned long)MPFROMSH2CH(s, c1, c2))
#define ulMPFROMLONG(x)			((unsigned long)MPFROMLONG(x))

a340 1
PROTOTYPES: ENABLE
d354 2
a355 2
SV *
swentry_expand( SV *sv )
d358 1
a358 2
	 STRLEN l;
	 PSWENTRY pswentry = (PSWENTRY)SvPV(sv, l);
d360 12
a371 14
	 if (l != sizeof(SWENTRY))
		croak("Wrong structure size %ld!=%ld in swentry_expand()", (long)l, (long)sizeof(SWENTRY));
	 EXTEND(sp,11);
	 PUSHs(sv_2mortal(newSVpv(pswentry->swctl.szSwtitle, 0)));
	 PUSHs(sv_2mortal(newSVnv(pswentry->swctl.hwnd)));
	 PUSHs(sv_2mortal(newSVnv(pswentry->swctl.hwndIcon)));
	 PUSHs(sv_2mortal(newSViv(pswentry->swctl.hprog)));
	 PUSHs(sv_2mortal(newSViv(pswentry->swctl.idProcess)));
	 PUSHs(sv_2mortal(newSViv(pswentry->swctl.idSession)));
	 PUSHs(sv_2mortal(newSViv(pswentry->swctl.uchVisibility & SWL_VISIBLE)));
	 PUSHs(sv_2mortal(newSViv(pswentry->swctl.uchVisibility & SWL_GRAYED)));
	 PUSHs(sv_2mortal(newSViv(pswentry->swctl.fbJump == SWL_JUMPABLE)));
	 PUSHs(sv_2mortal(newSViv(pswentry->swctl.bProgType)));
	 PUSHs(sv_2mortal(newSViv(pswentry->hswitch)));
a373 7
SV *
create_swentry( char *title, unsigned long sw_hwnd, unsigned long icon_hwnd, unsigned long owner_phandle, unsigned long owner_pid, unsigned long owner_sid, unsigned long visible, unsigned long switchable,	 unsigned long jumpable, unsigned long ptype, unsigned long sw_entry)
PROTOTYPE: DISABLE

int
change_swentry( SV *sv )

d375 1
a375 1
sesmgr_title_set(s)
a376 229

SV *
process_swentry(unsigned long pid = getpid(), unsigned long hwnd = NULLHANDLE);
  PROTOTYPE: DISABLE

int
swentry_size()

SV *
swentries_list()

void
ResetWinError()

int
WindowText_set(unsigned long hwndFrame, char *title)

bool
FocusWindow_set(unsigned long hwndFocus, unsigned long hwndDesktop = HWND_DESKTOP)

bool
ShowWindow(unsigned long hwnd, bool fShow = TRUE)

bool
EnableWindow(unsigned long hwnd, bool fEnable = TRUE)

bool
PostMsg(unsigned long hwnd, unsigned long msg, unsigned long mp1 = 0, unsigned long mp2 = 0)
    C_ARGS: hwnd, msg, (MPARAM)mp1, (MPARAM)mp2

bool
WindowPos_set(unsigned long hwnd, long x, long y, unsigned long fl = SWP_MOVE, long cx = 0, long cy = 0, unsigned long hwndInsertBehind = HWND_TOP)
  PROTOTYPE: DISABLE

unsigned long
BeginEnumWindows(unsigned long hwnd)

bool
EndEnumWindows(unsigned long henum)

unsigned long
GetNextWindow(unsigned long henum)

bool
IsWindowVisible(unsigned long hwnd)

bool
IsWindowEnabled(unsigned long hwnd)

bool
IsWindowShowing(unsigned long hwnd)

unsigned long
QueryWindow(unsigned long hwnd, long cmd)

unsigned long
IsChild(unsigned long hwnd, unsigned long hwndParent)

unsigned long
WindowFromId(unsigned long hwndParent, unsigned long id)

unsigned long
WindowFromPoint(long x, long y, unsigned long hwnd = HWND_DESKTOP, bool fChildren = TRUE)
PROTOTYPE: DISABLE

unsigned long
EnumDlgItem(unsigned long hwndDlg, unsigned long code, unsigned long hwnd = NULLHANDLE)
   C_ARGS: hwndDlg, hwnd, code

bool
EnableWindowUpdate(unsigned long hwnd, bool fEnable = TRUE)

bool
SetWindowBits(unsigned long hwnd, long index, unsigned long flData, unsigned long flMask)

bool
SetWindowPtr(unsigned long hwnd, long index, unsigned long p)
    C_ARGS: hwnd, index, (PVOID)p

bool
SetWindowULong(unsigned long hwnd, long index, unsigned long i)

bool
SetWindowUShort(unsigned long hwnd, long index, unsigned short i)

bool
IsWindow(unsigned long hwnd, unsigned long hab = Acquire_hab())
    C_ARGS: hab, hwnd

BOOL
ActiveWindow_set(unsigned long hwnd, unsigned long hwndDesktop = HWND_DESKTOP)
    CODE:
	RETVAL = SetActiveWindow(hwndDesktop, hwnd);

int
out_codepage()

bool
out_codepage_set(int cp)

int
in_codepage()

bool
in_codepage_set(int cp)

SV *
screen()

bool
screen_set(SV *sv)

SV *
process_codepages()
  PPCODE:
  {
    ULONG cps[4], c, i = 0, rc;

    if (CheckOSError(DosQueryCp( sizeof(cps), cps, &c )))
	c = 0;
    c /= sizeof(ULONG);
    if (c >= 3)
    EXTEND(sp, c);
    while (i < c)
	PUSHs(sv_2mortal(newSViv(cps[i++])));
  }

bool
process_codepage_set(int cp)

void
cursor(OUTLIST int stp, OUTLIST int ep, OUTLIST int wp, OUTLIST int ap)
  PROTOTYPE:

bool
cursor_set(int s, int e, int w = cursor__(0), int a = cursor__(1))

MODULE = OS2::Process		PACKAGE = OS2::Process	PREFIX = myQuery

SV *
myQueryWindowText(unsigned long hwnd)

SV *
myQueryClassName(unsigned long hwnd)

MODULE = OS2::Process		PACKAGE = OS2::Process	PREFIX = Query

unsigned long
QueryFocusWindow(unsigned long hwndDesktop = HWND_DESKTOP)

long
QueryWindowTextLength(unsigned long hwnd)

SV *
QueryWindowSWP(unsigned long hwnd)

unsigned long
QueryWindowULong(unsigned long hwnd, long index)

unsigned short
QueryWindowUShort(unsigned long hwnd, long index)

unsigned long
QueryActiveWindow(unsigned long hwnd = HWND_DESKTOP)

unsigned long
QueryDesktopWindow(unsigned long hab = Acquire_hab(), unsigned long hdc = NULLHANDLE)

MODULE = OS2::Process		PACKAGE = OS2::Process	PREFIX = myWinQuery

unsigned long
myWinQueryWindowPtr(unsigned long hwnd, long index)

NO_OUTPUT BOOL
myWinQueryWindowProcess(unsigned long hwnd, OUTLIST unsigned long pid, OUTLIST unsigned long tid)
   PROTOTYPE: $
   POSTCALL:
	if (CheckWinError(RETVAL))
	    croak("WindowProcess() error");

MODULE = OS2::Process		PACKAGE = OS2::Process	PREFIX = myWin

int
myWinSwitchToProgram(unsigned long hsw)
    PREINIT:
	ULONG rc;

MODULE = OS2::Process		PACKAGE = OS2::Process	PREFIX = myWinQuery

MODULE = OS2::Process		PACKAGE = OS2::Process	PREFIX = get

int
getppid()

int
ppidOf(int pid = getpid())

int
sidOf(int pid = getpid())

void
getscrsize(OUTLIST int wp, OUTLIST int hp)
  PROTOTYPE:

bool
scrsize_set(int w_or_h, int h = -9999)

MODULE = OS2::Process		PACKAGE = OS2::Process	PREFIX = ul

unsigned long
ulMPFROMSHORT(unsigned short i)

unsigned long
ulMPVOID()

unsigned long
ulMPFROMCHAR(unsigned char i)

unsigned long
ulMPFROM2SHORT(unsigned short x1, unsigned short x2)
  PROTOTYPE: DISABLE

unsigned long
ulMPFROMSH2CH(unsigned short s, unsigned char c1, unsigned char c2)
  PROTOTYPE: DISABLE

unsigned long
ulMPFROMLONG(unsigned long x)

@


1.1.1.4
log
@perl 5.8.2 from CPAN
@
text
@a9 2
#define INCL_WINCLIPBOARD
#define INCL_WINATOM
a236 1
#if 0
d242 1
a242 2
#endif
	croak_with_os2error("DosQueryAppType"); 
d263 1
a263 1
/* These function croak if the return value is 0. */
a302 57
DeclWinFunc_CACHE(BOOL, QueryActiveDesktopPathname, (PSZ pszPathName, ULONG ulSize),
		  (pszPathName, ulSize));
DeclWinFunc_CACHE(BOOL, InvalidateRect,
		  (HWND hwnd, /*RECTL*/ char *prcl, BOOL fIncludeChildren),
		  (hwnd, prcl, fIncludeChildren));
DeclWinFunc_CACHE(BOOL, CreateFrameControls,
		  (HWND hwndFrame, /*PFRAMECDATA*/ char* pfcdata, PCSZ pszTitle),
		  (hwndFrame, pfcdata, pszTitle));
DeclWinFunc_CACHE(BOOL, OpenClipbrd, (HAB hab), (hab));
DeclWinFunc_CACHE(BOOL, EmptyClipbrd, (HAB hab), (hab));
DeclWinFunc_CACHE(BOOL, CloseClipbrd, (HAB hab), (hab));
DeclWinFunc_CACHE(HWND, QueryClipbrdViewer, (HAB hab), (hab));
DeclWinFunc_CACHE(HWND, QueryClipbrdOwner, (HAB hab), (hab));
DeclWinFunc_CACHE(BOOL, QueryClipbrdFmtInfo, (HAB hab, ULONG fmt, PULONG prgfFmtInfo), (hab, fmt, prgfFmtInfo));
DeclWinFunc_CACHE(ULONG, QueryClipbrdData, (HAB hab, ULONG fmt), (hab, fmt));
DeclWinFunc_CACHE(HWND, SetClipbrdViewer, (HAB hab, HWND hwnd), (hab, hwnd));
DeclWinFunc_CACHE(HWND, SetClipbrdOwner, (HAB hab, HWND hwnd), (hab, hwnd));
DeclWinFunc_CACHE(ULONG, EnumClipbrdFmts, (HAB hab, ULONG fmt), (hab, fmt));
DeclWinFunc_CACHE(ATOM, AddAtom, (HATOMTBL hAtomTbl, PCSZ pszAtomName),
		  (hAtomTbl, pszAtomName));
DeclWinFunc_CACHE(ATOM, FindAtom, (HATOMTBL hAtomTbl, PCSZ pszAtomName),
		  (hAtomTbl, pszAtomName));
DeclWinFunc_CACHE(ATOM, DeleteAtom, (HATOMTBL hAtomTbl, PCSZ pszAtomName),
		  (hAtomTbl, pszAtomName));
DeclWinFunc_CACHE(ULONG, QueryAtomUsage, (HATOMTBL hAtomTbl, ATOM atom),
		  (hAtomTbl, atom));
DeclWinFunc_CACHE(ULONG, QueryAtomLength, (HATOMTBL hAtomTbl, ATOM atom),
		  (hAtomTbl, atom));
DeclWinFunc_CACHE(ULONG, QueryAtomName,
		  (HATOMTBL hAtomTbl, ATOM atom, PSZ pchBuffer, ULONG cchBufferMax),
		  (hAtomTbl, atom, pchBuffer, cchBufferMax));
DeclWinFunc_CACHE(HATOMTBL, QuerySystemAtomTable, (VOID), ());
DeclWinFunc_CACHE(HATOMTBL, CreateAtomTable, (ULONG initial, ULONG buckets),
		  (initial, buckets));
DeclWinFunc_CACHE(HATOMTBL, DestroyAtomTable, (HATOMTBL hAtomTbl), (hAtomTbl));
DeclWinFunc_CACHE(ULONG, MessageBox, (HWND hwndParent, HWND hwndOwner, PCSZ pszText, PCSZ pszCaption, ULONG idWindow, ULONG flStyle), (hwndParent, hwndOwner, pszText, pszCaption, idWindow, flStyle));
DeclWinFunc_CACHE(ULONG, MessageBox2,
		  (HWND hwndParent, HWND hwndOwner, PCSZ pszText,
		   PCSZ pszCaption, ULONG idWindow, PMB2INFO pmb2info),
		  (hwndParent, hwndOwner, pszText, pszCaption, idWindow, pmb2info));
DeclWinFunc_CACHE(HPOINTER, LoadPointer,
		  (HWND hwndDesktop, HMODULE hmod, ULONG idres),
		  (hwndDesktop, hmod, idres));
DeclWinFunc_CACHE(HPOINTER, QuerySysPointer,
		  (HWND hwndDesktop, LONG lId, BOOL fCopy),
		  (hwndDesktop, lId, fCopy));
DeclWinFunc_CACHE(BOOL, Alarm, (HWND hwndDesktop, ULONG rgfType), (hwndDesktop, rgfType));
DeclWinFunc_CACHE(BOOL, FlashWindow, (HWND hwndFrame, BOOL fFlash), (hwndFrame, fFlash));


/* These functions do not croak on error */
DeclWinFunc_CACHE_survive(BOOL, SetClipbrdData,
			  (HAB hab, ULONG ulData, ULONG fmt, ULONG rgfFmtInfo),
			  (hab, ulData, fmt, rgfFmtInfo));

#define get_InvalidateRect	InvalidateRect
#define get_CreateFrameControls	CreateFrameControls
a336 3
#define _ClipbrdData_set SetClipbrdData
#define ClipbrdOwner_set SetClipbrdOwner
#define ClipbrdViewer_set SetClipbrdViewer
d358 1
a358 1
    len = QueryWindowText(hwnd, l + 1, SvPV_force(sv, n_a));
d414 2
a415 2
static HSWITCH
switch_of(HWND hwnd, PID pid)
d417 1
d424 1
a424 11
	     croak_with_os2error("WinQuerySwitchHandle");
	 return hSwitch;
}


static void
fill_swentry(SWENTRY *swentryp, HWND hwnd, PID pid)
{
	 int rc;
	 HSWITCH hSwitch = switch_of(hwnd, pid);

d427 1
a427 1
	     croak_with_os2error("WinQuerySwitchEntry");
a435 97
static SV*
myWinQueryActiveDesktopPathname()
{
    SV *buf = newSVpv("",0);
    STRLEN n_a;

    SvGROW(buf, MAXPATHLEN);
    QueryActiveDesktopPathname(SvPV(buf,n_a), MAXPATHLEN);
    SvCUR_set(buf, strlen(SvPV(buf, n_a)));
    return buf;
}

SV *
myWinQueryAtomName(ATOM atom, HATOMTBL hAtomTbl)
{
    ULONG len = QueryAtomLength(hAtomTbl, atom);
    SV *sv = newSVpvn("",0);
    STRLEN n_a;

    SvGROW(sv, len + 1);
    QueryAtomName(hAtomTbl, atom, SvPV(sv, n_a), len);
    SvCUR_set(sv, len);
    *SvEND(sv) = 0;
    return sv;
}

#define myWinQueryClipbrdFmtInfo	QueryClipbrdFmtInfo

/* Put data into shared memory, then call SetClipbrdData */
void
ClipbrdData_set(SV *sv, int convert_nl, unsigned long fmt, unsigned long rgfFmtInfo, HAB hab)
{
    STRLEN len;
    char *buf = SvPV_force(sv, len);
    char *pByte = 0, *s = buf, c;
    ULONG nls = 0, rc;

    if (convert_nl) {
	while ((c = *s++)) {
	    if (c == '\r' && *s == '\n')
		s++;
	    else if (c == '\n')
		nls++;
	}
    }

    if (CheckOSError(DosAllocSharedMem((PPVOID)&pByte, 0, len + nls + 1,
				       PAG_WRITE | PAG_COMMIT | OBJ_GIVEABLE | OBJ_GETTABLE)))
	croak_with_os2error("ClipbrdData_set: DosAllocSharedMem error");

    if (!nls)
	memcpy(pByte, buf, len + 1);
    else {
	char *t = pByte, *e = buf + len;

	while (buf < e) {
	    c = *t++ = *buf++;
	    if (c == '\n' && (t == pByte + 1 || t[-2] != '\r'))
		t[-1] = '\r', *t++ = '\n';
	}
    }

    if (!SetClipbrdData(hab, (ULONG)pByte, fmt, rgfFmtInfo)) {
	DosFreeMem((PPVOID)&pByte);
	croak_with_os2error("ClipbrdData_set: WinSetClipbrdData error");
    }
}

#if 0

ULONG
myWinMessageBox(HWND hwndParent, HWND hwndOwner, PCSZ pszText, PCSZ pszCaption, ULONG idWindow, ULONG flStyle)
{
    ULONG rc = MessageBox(hwndParent, hwndOwner, pszText, pszCaption,
			  idWindow, flStyle);

    if (rc == MBID_ERROR)
	rc = 0;
    if (CheckWinError(rc))
	croak_with_os2error("MessageBox");
    return rc;
}

ULONG
myWinMessageBox2(HWND hwndParent, HWND hwndOwner, PCSZ pszText,
		   PCSZ pszCaption, ULONG idWindow, PMB2INFO pmb2info)
{
    ULONG rc = MessageBox2(hwndParent, hwndOwner, pszText, pszCaption, idWindow, pmb2info);

    if (rc == MBID_ERROR)
	rc = 0;
    if (CheckWinError(rc))
	croak_with_os2error("MessageBox2");
    return rc;
}
#endif

d511 1
a511 1
process_swentry(unsigned long pid, HWND hwnd)
d663 1
a663 1
	croak_with_os2error("VioGetCurType() error");
d709 1
a709 1
	croak_with_os2error("Can't get size of buffer for screen");
d722 1
a722 280

SV*
_kbdChar(unsigned int nowait, int handle)
{
    KBDKEYINFO viob[2], *vio;
    ULONG rc;

    VIO_FROM_VIOB;

    if (nowait > 2)
	croak("unexpected nowait");
    if (CheckOSError(nowait == 2
		     ? KbdPeek( vio, handle )
		     : KbdCharIn( vio, nowait == 1, handle )))
	croak_with_os2error("Can't _kbdChar");
    return newSVpvn((char*)vio, sizeof(*vio));
}

SV*
_kbdStatus(int handle)
{
    KBDINFO viob[2], *vio;
    ULONG rc;

    VIO_FROM_VIOB;

    vio->cb = sizeof(*vio);
    if (CheckOSError(KbdGetStatus( vio, handle )))
	croak_with_os2error("Can't _kbdStatus");
    return newSVpvn((char*)vio, sizeof(*vio));
}

void
_kbdStatus_set(SV* sv, int handle)
{
    KBDINFO viob[2], *vio;
    ULONG rc;
    STRLEN l;
    char *s = SvPV(sv, l);

    VIO_FROM_VIOB;

    if (l != sizeof(*vio))
	croak("unexpected datasize");
    Copy((KBDINFO*)s, vio, 1, KBDINFO);
    if (vio->cb != sizeof(*vio))
	croak("unexpected datasize");
    if (CheckOSError(KbdSetStatus( vio, handle )))
	croak_with_os2error("Can't kbdStatus_set()");
}

SV*
_vioConfig(int which, int handle)
{
    struct {VIOCONFIGINFO i; short a[20];} viob[2], *vio;
    ULONG rc;

    VIO_FROM_VIOB;

    vio->i.cb = 2;
    if (CheckOSError(VioGetConfig( which, &vio->i, handle )))
	croak_with_os2error("Can't get VIO config size");
    if (vio->i.cb > sizeof(*vio))
	vio->i.cb = sizeof(*vio);
    if (CheckOSError(VioGetConfig( which, &vio->i, handle )))
	croak_with_os2error("Can't get VIO config");
    return newSVpvn((char*)vio, vio->i.cb);
}

SV*
_vioMode(void)
{
    VIOMODEINFO viob[2], *vio;
    ULONG rc;

    VIO_FROM_VIOB;

    vio->cb = sizeof(*vio);
    if (CheckOSError(VioGetMode( vio, 0 )))
	croak_with_os2error("Can't get VIO mode");
    return newSVpvn((char*)vio, sizeof(*vio));
}

void
_vioMode_set(SV* sv)
{
    VIOMODEINFO viob[2], *vio;
    ULONG rc;
    STRLEN l;
    char *s = SvPV(sv, l);

    VIO_FROM_VIOB;

    Copy((VIOMODEINFO*)s, vio, 1, VIOMODEINFO);
    if (vio->cb != sizeof(*vio) || l != vio->cb)
	croak("unexpected datasize");
    if (CheckOSError(VioSetMode( vio, 0 )))
	croak_with_os2error("Can't set VIO mode");
}

SV*
vioFont(int type, int *w, int *h) /* 0 for actual RAM font, 1 for ROM font */
{
    VIOFONTINFO viob[2], *vio;
    ULONG rc;
    UCHAR b[1<<17];
    UCHAR *buf = b;
    SV *sv;

    VIO_FROM_VIOB;

    /* Should not cross 64K boundaries too: */
    if (((ULONG)buf) & 0xFFFF)
	buf += 0x10000 - (((ULONG)buf) & 0xFFFF);

    vio->cb = sizeof(*vio);
    vio->type = type;			/* BIOS or the loaded font. */
    vio->cbData = 0xFFFF;		/* How large is my buffer? */
    vio->pbData = _emx_32to16(buf);	/* Wants an 16:16 pointer */
    if (CheckOSError(VioGetFont( vio, 0 )))
	croak_with_os2error("Can't get VIO font");
    *w = vio->cxCell;
    *h = vio->cyCell;
    return newSVpvn(buf,vio->cbData);
}

void
vioFont_set(SV *sv, int cellwidth, int cellheight, int type)
{
    VIOFONTINFO viob[2], *vio;
    ULONG rc;
    UCHAR b[1<<17];
    UCHAR *buf = b;
    STRLEN l;
    char *s = SvPV(sv, l);

    VIO_FROM_VIOB;

    /* Should not cross 64K boundaries too: */
    if (((ULONG)buf) & 0xFFFF)
	buf += 0x10000 - (((ULONG)buf) & 0xFFFF);

    if (l > 0xFFFF)
	croak("length overflow of VIO font");
    if (l != (cellwidth + 7)/8 * cellheight * 256)
	warn("unexpected length of VIO font");
    vio->cb = sizeof(*vio);
    vio->type = type;			/* BIOS or the loaded font. */
    vio->cbData = l;			/* How large is my buffer? */
    vio->pbData = _emx_32to16(buf);	/* Wants an 16:16 pointer */
    vio->cxCell = cellwidth;
    vio->cyCell = cellheight;
    Copy(s, buf, l, char);

    if (CheckOSError(VioSetFont( vio, 0 )))
	croak_with_os2error("Can't set VIO font");
}

/*
  uses use32,os2def,os2base,crt,defs;
  var   Plt :Plt256;
  const Pal :VioPalState=(Cb:sizeof(VioPalState);rType:0;iFirst:0;
    Acolor:($FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF));
        CReg:VioColorReg=(Cb:sizeof(VioColorReg);rType:3;FirstColorReg:0;
    NumColorRegs:256; ColorRegAddr:@@Plt);
  var   ii:Pointer;
  begin
   VioGetState(Pal,0);
   Pal.Acolor[09]:=$0F;
   Pal.Acolor[10]:=$A;
   Pal.Acolor[13]:=$2F;
   VioSetState(Pal,0); // ce smena EGA registrov
   asm
  lea   eax,Plt
     call  DosFlatToSel
     mov   ii,eax
   end;
   CReg.ColorRegAddr:=ii;
   VioGetState(CReg,0);
   Plt[10,0]:=$00;
   Plt[10,1]:=$32;
   Plt[10,2]:=$2A;
   VioSetState(CReg,0); // a ce - VGA registrov
  end.
*/

typedef union {
  VIOPALSTATE pal;
  struct { VIOPALSTATE pal; USHORT a[15]; } pal_padded;
  VIOOVERSCAN overscan;
  VIOINTENSITY intensity;
  VIOCOLORREG colorreg;
  struct { VIOCOLORREG reg; char rgb[3*256]; } colorreg_padded;
  VIOSETULINELOC lineloc;
  VIOSETTARGET target;
} my_VIOSTATE;

int
vio_state_size(int what)
{
    static const char sizes[] = {
	sizeof(VIOPALSTATE),
	sizeof(VIOOVERSCAN),
	sizeof(VIOINTENSITY),
	sizeof(VIOCOLORREG),
	6,				/* Random number: Reserved entry */
	sizeof(VIOSETULINELOC),
	sizeof(VIOSETTARGET)
    };
    if (what < 0 || what >= sizeof(sizes))
	croak("Unexpected VIO state type");
    return sizes[what];
}

SV*
_vioState(int what, int first, int count)
{
    my_VIOSTATE viob[2], *vio;
    ULONG rc, size = vio_state_size(what);

    VIO_FROM_VIOB;

    vio->pal.cb = size;
    vio->pal.type = what;
    if (what == 0) {
	vio->pal.iFirst = first;
	if (first < 0 || first >= 16)
	    croak("unexpected palette start value");
	if (count < 0 || count > 16)
	    croak("unexpected palette count");
	vio->pal.cb = (size += (count - 1) * sizeof(short));
    } else if (what == 3) {
	/* Wants an 16:16 pointer */
	if (count < 0 || count > 256)
	    croak("unexpected palette count");
	vio->colorreg.colorregaddr = (PCH)_emx_32to16(vio->colorreg_padded.rgb);
	vio->colorreg.numcolorregs = count;		/* 256 is max */
	vio->colorreg.firstcolorreg = first;
	size += 3 * count;
    }
    if (CheckOSError(VioGetState( (void*)vio, 0 )))
	croak_with_os2error("Can't get VIO state");
    return newSVpvn((char*)vio, size);
}

void
_vioState_set(SV *sv)
{
    my_VIOSTATE viob[2], *ovio = (my_VIOSTATE*)SvPV_nolen(sv), *vio = ovio;
    int what = ovio->pal.type, cb = ovio->pal.cb;
    ULONG rc, size = vio_state_size(what);
    STRLEN l;
    char *s = SvPV(sv, l);

    VIO_FROM_VIOB;

    switch (what) {
    case 0:
	if ( cb < size || cb > size + 15*sizeof(SHORT) || l != cb)
	    croak("unexpected datasize");
	size = l;
	break;
    case 3:
	if (l != cb + 3 * ovio->colorreg.numcolorregs || cb != size)
	    croak("unexpected datasize");
	size = l;
	break;
    default:
	if (l != cb || l != size )
	    croak("unexpected datasize");
	break;
    }
    Copy(s, (char*)vio, size, char);
    if (what == 3)	/* We expect colors put after VIOCOLORREG */
	vio->colorreg.colorregaddr = (PCH)_emx_32to16(vio->colorreg_padded.rgb);

    if (CheckOSError(VioSetState( (void*)vio, 0 )))
	croak_with_os2error("Can't set VIO state");
}

d769 1
a769 1
	croak_with_os2error("DosQueryCp()");
d779 1
a779 1
	croak_with_os2error("VioGetCp()");
d797 1
a797 1
	croak_with_os2error("KbdGetCp()");
a855 3
#define _MessageBox			MessageBox
#define _MessageBox2			MessageBox2

d907 1
a907 1
process_swentry(unsigned long pid = getpid(), HWND hwnd = NULLHANDLE);
d920 1
a920 1
WindowText_set(HWND hwndFrame, char *title)
d923 1
a923 1
FocusWindow_set(HWND hwndFocus, HWND hwndDesktop = HWND_DESKTOP)
d926 1
a926 1
ShowWindow(HWND hwnd, bool fShow = TRUE)
d929 1
a929 1
EnableWindow(HWND hwnd, bool fEnable = TRUE)
d932 1
a932 1
PostMsg(HWND hwnd, unsigned long msg, unsigned long mp1 = 0, unsigned long mp2 = 0)
d936 1
a936 1
WindowPos_set(HWND hwnd, long x, long y, unsigned long fl = SWP_MOVE, long cx = 0, long cy = 0, HWND hwndInsertBehind = HWND_TOP)
d940 1
a940 1
BeginEnumWindows(HWND hwnd)
d949 1
a949 1
IsWindowVisible(HWND hwnd)
d952 1
a952 1
IsWindowEnabled(HWND hwnd)
d955 1
a955 1
IsWindowShowing(HWND hwnd)
d958 1
a958 1
QueryWindow(HWND hwnd, long cmd)
d961 1
a961 1
IsChild(HWND hwnd, HWND hwndParent)
d964 1
a964 1
WindowFromId(HWND hwndParent, unsigned long id)
d967 1
a967 1
WindowFromPoint(long x, long y, HWND hwnd = HWND_DESKTOP, bool fChildren = TRUE)
d971 1
a971 1
EnumDlgItem(HWND hwndDlg, unsigned long code, HWND hwnd = NULLHANDLE)
d975 1
a975 1
EnableWindowUpdate(HWND hwnd, bool fEnable = TRUE)
d978 1
a978 1
SetWindowBits(HWND hwnd, long index, unsigned long flData, unsigned long flMask)
d981 1
a981 1
SetWindowPtr(HWND hwnd, long index, unsigned long p)
d985 1
a985 1
SetWindowULong(HWND hwnd, long index, unsigned long i)
d988 1
a988 1
SetWindowUShort(HWND hwnd, long index, unsigned short i)
d991 1
a991 1
IsWindow(HWND hwnd, HAB hab = Acquire_hab())
d995 1
a995 1
ActiveWindow_set(HWND hwnd, HWND hwndDesktop = HWND_DESKTOP)
a998 4
unsigned long
LoadPointer(unsigned long idres, unsigned long hmod = 0, HWND hwndDesktop = HWND_DESKTOP)
    C_ARGS: hwndDesktop, hmod, idres

a1041 73
SV*
_kbdChar(int nowait = 0, int handle = 0)

SV*
_kbdStatus(int handle = 0)

void
_kbdStatus_set(SV *sv, int handle = 0)

SV*
_vioConfig(int which = 0, int handle = 0)

SV*
_vioMode()

void
_vioMode_set(SV *buffer)

SV*
_vioState(int what, int first = -1, int count = -1)

void
_vioState_set(SV *buffer)

SV*
vioFont( int type = 0, OUTLIST int w, OUTLIST int h)

void
vioFont_set(SV *buffer, int cellwidth, int cellheight, int type = 0)

NO_OUTPUT bool
_ClipbrdData_set(unsigned long ulData, unsigned long fmt = CF_TEXT, unsigned long rgfFmtInfo = ((fmt == CF_TEXT || fmt == CF_DSPTEXT) ? CFI_POINTER : CFI_HANDLE), HAB hab = perl_hab_GET())
    PROTOTYPE: DISABLE
    C_ARGS: hab, ulData, fmt, rgfFmtInfo
    POSTCALL:
	if (CheckWinError(RETVAL))
	    croak_with_os2error("_ClipbrdData_set() error");

void
ClipbrdData_set(SV *text, int convert_nl = 1, unsigned long fmt = CF_TEXT, unsigned long rgfFmtInfo = ((fmt == CF_TEXT || fmt == CF_DSPTEXT) ? CFI_POINTER : CFI_HANDLE), HAB hab = perl_hab_GET())
    PROTOTYPE: DISABLE

void
ClipbrdOwner_set(HWND hwnd, HAB hab = perl_hab_GET())
    C_ARGS: hab, hwnd

void
ClipbrdViewer_set(HWND hwnd, HAB hab = perl_hab_GET())
    C_ARGS: hab, hwnd

unsigned long
EnumClipbrdFmts(unsigned long fmt = 0, HAB hab = perl_hab_GET())
    C_ARGS: hab, fmt

unsigned long
AddAtom(char *pszAtomName, HATOMTBL hAtomTbl = QuerySystemAtomTable())
    C_ARGS: hAtomTbl, pszAtomName

unsigned long
FindAtom(char *pszAtomName, HATOMTBL hAtomTbl = QuerySystemAtomTable())
    C_ARGS: hAtomTbl, pszAtomName

unsigned long
DeleteAtom(char *pszAtomName, HATOMTBL hAtomTbl = QuerySystemAtomTable())
    C_ARGS: hAtomTbl, pszAtomName

void
Alarm(unsigned long rgfType = WA_ERROR, HWND hwndDesktop = HWND_DESKTOP)
    C_ARGS: hwndDesktop, rgfType

void
FlashWindow(HWND hwndFrame, bool fFlash)

d1045 1
a1045 1
myQueryWindowText(HWND hwnd)
d1048 1
a1048 1
myQueryClassName(HWND hwnd)
d1053 1
a1053 1
QueryFocusWindow(HWND hwndDesktop = HWND_DESKTOP)
d1056 1
a1056 1
QueryWindowTextLength(HWND hwnd)
d1059 1
a1059 1
QueryWindowSWP(HWND hwnd)
d1062 1
a1062 1
QueryWindowULong(HWND hwnd, long index)
d1065 1
a1065 38
QueryWindowUShort(HWND hwnd, long index)

unsigned long
QueryActiveWindow(HWND hwnd = HWND_DESKTOP)

unsigned long
QueryDesktopWindow(HAB hab = Acquire_hab(), unsigned long hdc = NULLHANDLE)

unsigned long
QueryClipbrdData(unsigned long fmt = CF_TEXT, HAB hab = perl_hab_GET())
    C_ARGS: hab, fmt
    PROTOTYPE: DISABLE

unsigned long
QueryClipbrdViewer(HAB hab = perl_hab_GET())

unsigned long
QueryClipbrdOwner(HAB hab = perl_hab_GET())

void
CloseClipbrd(HAB hab = perl_hab_GET())

void
EmptyClipbrd(HAB hab = perl_hab_GET())

bool
OpenClipbrd(HAB hab = perl_hab_GET())

unsigned long
QueryAtomUsage(ATOM atom, HATOMTBL hAtomTbl = QuerySystemAtomTable())
    C_ARGS: hAtomTbl, atom

unsigned long
QueryAtomLength(ATOM atom, HATOMTBL hAtomTbl = QuerySystemAtomTable())
    C_ARGS: hAtomTbl, atom

unsigned long
QuerySystemAtomTable()
d1068 1
a1068 2
QuerySysPointer(long lId, bool fCopy = 1, HWND hwndDesktop = HWND_DESKTOP)
    C_ARGS: hwndDesktop, lId, fCopy
d1071 1
a1071 5
CreateAtomTable(unsigned long initial = 0, unsigned long buckets = 0)

unsigned long
DestroyAtomTable(HATOMTBL hAtomTbl)

d1076 1
a1076 1
myWinQueryWindowPtr(HWND hwnd, long index)
d1079 1
a1079 1
myWinQueryWindowProcess(HWND hwnd, OUTLIST unsigned long pid, OUTLIST unsigned long tid)
d1083 1
a1083 11
	    croak_with_os2error("WindowProcess() error");

SV *
myWinQueryActiveDesktopPathname()

void
myWinQueryClipbrdFmtInfo(OUTLIST unsigned long prgfFmtInfo, unsigned long fmt = CF_TEXT, HAB hab = perl_hab_GET())
   C_ARGS: hab, fmt, &prgfFmtInfo

SV *
myWinQueryAtomName(ATOM atom, HATOMTBL hAtomTbl = QuerySystemAtomTable())
d1088 1
a1088 1
myWinSwitchToProgram(HSWITCH hsw = switch_of(NULLHANDLE, getpid()))
a1091 22
#if 0

unsigned long
myWinMessageBox(unsigned long pszText, char* pszCaption = "Perl script error", unsigned long flStyle = MB_CANCEL | MB_ICONHAND, HWND hwndParent = HWND_DESKTOP, HWND hwndOwner = HWND_DESKTOP, unsigned long idWindow = 0)
    C_ARGS: hwndParent, hwndOwner, pszText, pszCaption, idWindow, flStyle

#endif

unsigned long
_MessageBox(char* pszText, char* pszCaption = "Perl script error", unsigned long flStyle = MB_CANCEL | MB_INFORMATION | MB_MOVEABLE, HWND hwndParent = HWND_DESKTOP, HWND hwndOwner = NULLHANDLE, unsigned long idWindow = 0)
    C_ARGS: hwndParent, hwndOwner, pszText, pszCaption, idWindow, flStyle
    POSTCALL:
	if (RETVAL == MBID_ERROR)
	    RETVAL = 0;

unsigned long
_MessageBox2(char *pszText, char* pmb2info, char *pszCaption, HWND hwndParent = HWND_DESKTOP, HWND hwndOwner = NULLHANDLE, unsigned long idWindow = 0)
    C_ARGS: hwndParent, hwndOwner, pszText, pszCaption, idWindow, (PMB2INFO)pmb2info
    POSTCALL:
	if (RETVAL == MBID_ERROR)
	    RETVAL = 0;

a1110 6

void
get_InvalidateRect(HWND hwnd, char *prcl, bool fIncludeChildren)

void
get_CreateFrameControls(HWND hwndFrame, char *pfcdata, char* pszTitle)
@


1.1.1.5
log
@import perl 5.10.0 from CPAN
@
text
@d318 2
d327 4
d341 1
a355 7
#if 0		/* Need to have the entry points described in the parent */
DeclWinFunc_CACHE(BOOL, QueryClassInfo, (HAB hab, char* pszClassName, PCLASSINFO pClassInfo), (hab, pszClassName, pClassInfo));

#define _QueryClassInfo(hab, pszClassName, pClassInfo)	\
	QueryClassInfo(hab, pszClassName, (PCLASSINFO)pClassInfo)

#endif
a380 10
DeclWinFunc_CACHE_resetError(ATOM, FindAtom, (HATOMTBL hAtomTbl, PCSZ pszAtomName),
			     (hAtomTbl, pszAtomName));
DeclWinFunc_CACHE_resetError(ATOM, DeleteAtom, (HATOMTBL hAtomTbl, ATOM atom),
			     (hAtomTbl, atom));
DeclWinFunc_CACHE_resetError(HATOMTBL, DestroyAtomTable, (HATOMTBL hAtomTbl), (hAtomTbl));
DeclWinFunc_CACHE_resetError(HWND, QueryClipbrdViewer, (HAB hab), (hab));
DeclWinFunc_CACHE_resetError(HWND, QueryClipbrdOwner, (HAB hab), (hab));

#define _DeleteAtom		DeleteAtom
#define _DestroyAtomTable	DestroyAtomTable
d524 1
a524 3
  ULONG len = QueryAtomLength(hAtomTbl, atom);

  if (len) {			/* Probably always so... */
d529 4
a532 9
    len = QueryAtomName(hAtomTbl, atom, SvPV(sv, n_a), len + 1);
    if (len) {			/* Probably always so... */
      SvCUR_set(sv, len);
      *SvEND(sv) = 0;
      return sv;
    }
    SvREFCNT_dec(sv);
  }
  return &PL_sv_undef;
d542 5
a546 7
    char *buf;
    char *pByte = 0, *s, c;
    ULONG nls = 0, rc, handle;

    if (rgfFmtInfo & CFI_POINTER) {
      s = buf = SvPV_force(sv, len);
      if (convert_nl) {
d553 1
a553 1
      }
d555 1
a555 1
      if (CheckOSError(DosAllocSharedMem((PPVOID)&pByte, 0, len + nls + 1,
d559 1
a559 1
      if (!nls)
d561 1
a561 1
      else {
a568 4
      }
      handle = (ULONG)pByte;
    } else {
      handle = (ULONG)SvUV(sv);
d571 2
a572 3
    if (!SetClipbrdData(hab, handle, fmt, rgfFmtInfo)) {
	if (fmt & CFI_POINTER)
	    DosFreeMem((PPVOID)&pByte);
a576 37
ULONG
QueryMemoryRegionSize(ULONG addr, ULONG *flagp, ULONG len, I32 interrupt)
{
    ULONG l, f;				/* Modifiable copy */
    ULONG rc;

    do {
	l = len;
	rc = DosQueryMem((void *)addr, &l, &f);
    } while ( interrupt ? 0 : rc == ERROR_INTERRUPT );

    /* We assume this is not about addr */
/*
    if (rc == ERROR_INVALID_ADDRESS)
	return 0xFFFFFFFF;
*/
    os2cp_croak(rc,"QueryMemoryRegionSize");
    if (flagp)
	*flagp = f;
    return l;
}

static ULONG
default_fmtInfo(ULONG fmt)
{
   switch (fmt) {
     case CF_PALETTE:	/* Actually, fmtInfo not documented for palette... */
     case CF_BITMAP:
     case CF_METAFILE:
     case CF_DSPBITMAP:
     case CF_DSPMETAFILE:
	return CFI_HANDLE;
     default:
	return CFI_POINTER;
   }
}

a1297 49
STRLEN
StrLen(ULONG addr, ULONG lim, I32 unitsize)
{
    switch (unitsize) {
      case 1:
	{
	    char *s = (char *)addr;
	    char *s1 = s, *e = (char *)(addr + lim);

	    while (s < e && *s)
		s++;
	    return s - s1;
	}
	break;
      case 2:
	{
	    short *s = (short *)addr;
	    short *s1 = s, *e = (short *)(addr + lim);

	    while (s < e && *s)
		s++;
	    return (char*)s - (char*)s1;
	}
	break;
      case 4:
	{
	    int *s = (int *)addr;
	    int *s1 = s, *e = (int *)(addr + lim);

	    while (s < e && *s)
		s++;
	    return (char*)s - (char*)s1;
	}
	break;
      case 8:
	{
	    long long *s = (long long *)addr;
	    long long *s1 = s, *e = (long long *)(addr + lim);

	    while (s < e && *s)
		s++;
	    return (char*)s - (char*)s1;
	}
	break;
      default:
	croak("StrLen: unknown unitsize %d", (int)unitsize);
    }
}

a1369 2
   POSTCALL:
	XSRETURN_YES;
a1505 2
   POSTCALL:
	XSRETURN_YES;
a1514 2
   POSTCALL:
	XSRETURN_YES;
a1520 2
   POSTCALL:
	XSRETURN_YES;
a1526 2
   POSTCALL:
	XSRETURN_YES;
d1529 1
a1529 1
_ClipbrdData_set(unsigned long ulData, unsigned long fmt = CF_TEXT, unsigned long rgfFmtInfo = default_fmtInfo(fmt), HAB hab = perl_hab_GET())
a1534 1
	XSRETURN_YES;
d1537 1
a1537 1
ClipbrdData_set(SV *text, int convert_nl = 1, unsigned long fmt = CF_TEXT, unsigned long rgfFmtInfo = default_fmtInfo(fmt), HAB hab = perl_hab_GET())
a1538 2
    POSTCALL:
	XSRETURN_YES;
a1542 2
    POSTCALL:
	XSRETURN_YES;
a1546 2
    POSTCALL:
	XSRETURN_YES;
d1561 2
a1562 11
_DeleteAtom(ATOM atom, HATOMTBL hAtomTbl = QuerySystemAtomTable())
    PROTOTYPE: DISABLE
    C_ARGS: hAtomTbl, atom

#if 0

unsigned long
WinDeleteAtom(ATOM atom, HATOMTBL hAtomTbl = QuerySystemAtomTable())
    C_ARGS: hAtomTbl, atom

#endif
a1566 2
    POSTCALL:
	XSRETURN_YES;
a1569 5
    POSTCALL:
	XSRETURN_YES;

STRLEN
StrLen(ULONG addr, ULONG lim, I32 unitsize = 1)
a1606 3
ULONG
QueryMemoryRegionSize(ULONG addr, OUTLIST ULONG flagp, ULONG len = 0xFFFFFFFF - addr, I32 interrupt = 1)

a1614 2
    POSTCALL:
	XSRETURN_YES;
a1617 2
   POSTCALL:
	XSRETURN_YES;
a1628 3
   POSTCALL:
	if (!RETVAL)
	    XSRETURN_EMPTY;
d1641 1
a1641 2
_DestroyAtomTable(HATOMTBL hAtomTbl)
    PROTOTYPE: DISABLE
d1676 1
a1676 1
myWinMessageBox(unsigned long pszText, char* pszCaption = "Perl script message", unsigned long flStyle = MB_CANCEL | MB_ICONHAND, HWND hwndParent = HWND_DESKTOP, HWND hwndOwner = HWND_DESKTOP, unsigned long idWindow = 0)
d1682 1
a1682 1
_MessageBox(char* pszText, char* pszCaption = "Perl script message", unsigned long flStyle = MB_CANCEL | MB_INFORMATION | MB_MOVEABLE, HWND hwndParent = HWND_DESKTOP, HWND hwndOwner = NULLHANDLE, unsigned long idWindow = 0)
d1689 1
a1689 1
_MessageBox2(char *pszText, char* pmb2info, char *pszCaption = "Perl script message", HWND hwndParent = HWND_DESKTOP, HWND hwndOwner = NULLHANDLE, unsigned long idWindow = 0)
@


