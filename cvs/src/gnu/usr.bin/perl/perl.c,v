head	1.30;
access;
symbols
	OPENBSD_6_1:1.30.0.2
	OPENBSD_6_1_BASE:1.30
	OPENBSD_6_0:1.28.0.4
	OPENBSD_6_0_BASE:1.28
	OPENBSD_5_9:1.26.0.2
	OPENBSD_5_9_BASE:1.26
	OPENBSD_5_8:1.25.0.4
	OPENBSD_5_8_BASE:1.25
	PERL_5_20_2:1.1.1.17
	OPENBSD_5_7:1.24.0.2
	OPENBSD_5_7_BASE:1.24
	PERL_5_20_1:1.1.1.16
	OPENBSD_5_6:1.23.0.4
	OPENBSD_5_6_BASE:1.23
	PERL_5_18_2:1.1.1.15
	PERL:1.1.1
	OPENBSD_5_5:1.22.0.6
	OPENBSD_5_5_BASE:1.22
	OPENBSD_5_4:1.22.0.2
	OPENBSD_5_4_BASE:1.22
	PERL_5_16_3:1.1.1.14
	OPENBSD_5_3:1.21.0.10
	OPENBSD_5_3_BASE:1.21
	OPENBSD_5_2:1.21.0.8
	OPENBSD_5_2_BASE:1.21
	OPENBSD_5_1_BASE:1.21
	OPENBSD_5_1:1.21.0.6
	OPENBSD_5_0:1.21.0.4
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.21.0.2
	OPENBSD_4_9_BASE:1.21
	PERL_5_12_2:1.1.1.13
	OPENBSD_4_8:1.20.0.4
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.2
	OPENBSD_4_7_BASE:1.20
	PERL_5_10_1:1.1.1.12
	OPENBSD_4_6:1.18.0.6
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.18.0.2
	OPENBSD_4_5_BASE:1.18
	PERL_5_10_0:1.1.1.11
	OPENBSD_4_4:1.17.0.2
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.15.0.8
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.15.0.6
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.4
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.2
	OPENBSD_4_0_BASE:1.15
	PERL_5_8_8:1.1.1.10
	OPENBSD_3_9:1.14.0.6
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.4
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.2
	OPENBSD_3_7_BASE:1.14
	PERL_5_8_6:1.1.1.9
	OPENBSD_3_6:1.12.0.2
	OPENBSD_3_6_BASE:1.12
	PERL_5_8_5:1.1.1.8
	PERL_5_8_3:1.1.1.7
	OPENBSD_3_5:1.10.0.2
	OPENBSD_3_5_BASE:1.10
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.9.0.4
	OPENBSD_3_4_BASE:1.9
	OPENBSD_3_3:1.9.0.2
	OPENBSD_3_3_BASE:1.9
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.8.0.6
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.8.0.4
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.7.0.4
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_8:1.7.0.2
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.5.0.2
	OPENBSD_2_7_BASE:1.5
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.4.0.2
	OPENBSD_2_6_BASE:1.4
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.3.0.6
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.4
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.2
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.2.0.4
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.30
date	2017.02.05.00.33.38;	author afresh1;	state Exp;
branches;
next	1.29;
commitid	7JLVNm1wwPgqSqTa;

1.29
date	2017.02.05.00.31.53;	author afresh1;	state Exp;
branches;
next	1.28;
commitid	cxJ08BvJA9Pt2PTM;

1.28
date	2016.07.03.01.07.48;	author afresh1;	state Exp;
branches;
next	1.27;
commitid	GzHqjSTnBjdF7Wcw;

1.27
date	2016.04.25.11.11.51;	author daniel;	state Exp;
branches;
next	1.26;
commitid	irISPuRuuVphcf2L;

1.26
date	2016.02.24.23.13.17;	author afresh1;	state Exp;
branches;
next	1.25;
commitid	YZ0xBieA3JzjWVeb;

1.25
date	2015.04.25.19.14.37;	author afresh1;	state Exp;
branches
	1.25.4.1;
next	1.24;
commitid	XRK22kO4se3v2i2I;

1.24
date	2014.11.17.20.56.47;	author afresh1;	state Exp;
branches
	1.24.2.1;
next	1.23;
commitid	QP75iYx42Uo7mMxO;

1.23
date	2014.03.24.15.05.13;	author afresh1;	state Exp;
branches;
next	1.22;

1.22
date	2013.03.25.20.40.44;	author sthen;	state Exp;
branches;
next	1.21;

1.21
date	2010.09.24.15.06.40;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2009.10.13.01.25.48;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2009.10.12.18.24.21;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2008.09.29.17.35.58;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2008.03.24.16.10.55;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2008.03.15.16.27.25;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2006.03.28.19.22.58;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2005.03.02.07.46.35;	author mbalmer;	state Exp;
branches;
next	1.13;

1.13
date	2005.01.15.21.30.20;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2004.08.09.18.08.55;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2004.04.07.21.32.59;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2003.12.03.03.02.21;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.10.27.22.25.18;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.05.24.18.34.52;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2000.08.08.15.51.10;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2000.08.07.19.22.54;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2000.04.06.17.04.08;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	99.04.29.22.51.03;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.11.30.07.48.55;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.01.23.04.31.36;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.11.44;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.11.44;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.37.32;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.08.41;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.22.11;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.14.48;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.43.32;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.04.07.21.12.52;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.08.09.17.45.43;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2005.01.15.21.16.29;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2006.03.28.18.47.33;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2008.09.29.17.18.07;	author millert;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2009.10.12.18.10.34;	author millert;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2010.09.24.14.48.32;	author millert;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2013.03.25.20.06.29;	author sthen;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	2014.03.24.14.58.46;	author afresh1;	state Exp;
branches;
next	1.1.1.16;

1.1.1.16
date	2014.11.17.20.52.37;	author afresh1;	state Exp;
branches;
next	1.1.1.17;
commitid	B31cAbBIXiCqnL97;

1.1.1.17
date	2015.04.25.19.10.10;	author afresh1;	state Exp;
branches;
next	;
commitid	Wpcs5S8qILgEZC7F;

1.24.2.1
date	2016.03.03.16.16.09;	author afresh1;	state Exp;
branches;
next	;
commitid	VqXCANs0mgdIPayF;

1.25.4.1
date	2016.03.03.16.15.16;	author afresh1;	state Exp;
branches;
next	;
commitid	PiMIO0iFH2mGPt8c;


desc
@@


1.30
log
@Apply local patches - perl-5.24.1
@
text
@#line 2 "perl.c"
/*    perl.c
 *
 *    Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
 *    2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012
 *    2013, 2014, 2015, 2016, 2017 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

/*
 *      A ship then new they built for him
 *      of mithril and of elven-glass
 *              --from Bilbo's song of EÃ¤rendil
 *
 *     [p.236 of _The Lord of the Rings_, II/i: "Many Meetings"]
 */

/* This file contains the top-level functions that are used to create, use
 * and destroy a perl interpreter, plus the functions used by XS code to
 * call back into perl. Note that it does not contain the actual main()
 * function of the interpreter; that can be found in perlmain.c
 */

#if defined(PERL_IS_MINIPERL) && !defined(USE_SITECUSTOMIZE)
#  define USE_SITECUSTOMIZE
#endif

#include "EXTERN.h"
#define PERL_IN_PERL_C
#include "perl.h"
#include "patchlevel.h"			/* for local_patches */
#include "XSUB.h"

#ifdef NETWARE
#include "nwutil.h"	
#endif

#ifdef DEBUG_LEAKING_SCALARS_FORK_DUMP
#  ifdef I_SYSUIO
#    include <sys/uio.h>
#  endif

union control_un {
  struct cmsghdr cm;
  char control[CMSG_SPACE(sizeof(int))];
};

#endif

#ifndef HZ
#  ifdef CLK_TCK
#    define HZ CLK_TCK
#  else
#    define HZ 60
#  endif
#endif

#if !defined(STANDARD_C) && !defined(HAS_GETENV_PROTOTYPE) && !defined(PERL_MICRO)
char *getenv (char *); /* Usually in <stdlib.h> */
#endif

static I32 read_e_script(pTHX_ int idx, SV *buf_sv, int maxlen);

#ifdef SETUID_SCRIPTS_ARE_SECURE_NOW
#  define validate_suid(rsfp) NOOP
#else
#  define validate_suid(rsfp) S_validate_suid(aTHX_ rsfp)
#endif

#define CALL_BODY_SUB(myop) \
    if (PL_op == (myop)) \
	PL_op = PL_ppaddr[OP_ENTERSUB](aTHX); \
    if (PL_op) \
	CALLRUNOPS(aTHX);

#define CALL_LIST_BODY(cv) \
    PUSHMARK(PL_stack_sp); \
    call_sv(MUTABLE_SV((cv)), G_EVAL|G_DISCARD|G_VOID);

static void
S_init_tls_and_interp(PerlInterpreter *my_perl)
{
    dVAR;
    if (!PL_curinterp) {			
	PERL_SET_INTERP(my_perl);
#if defined(USE_ITHREADS)
	INIT_THREADS;
	ALLOC_THREAD_KEY;
	PERL_SET_THX(my_perl);
	OP_REFCNT_INIT;
	OP_CHECK_MUTEX_INIT;
	HINTS_REFCNT_INIT;
        LOCALE_INIT;
	MUTEX_INIT(&PL_dollarzero_mutex);
	MUTEX_INIT(&PL_my_ctx_mutex);
#  endif
    }
#if defined(USE_ITHREADS)
    else
#else
    /* This always happens for non-ithreads  */
#endif
    {
	PERL_SET_THX(my_perl);
    }
}


/* these implement the PERL_SYS_INIT, PERL_SYS_INIT3, PERL_SYS_TERM macros */

void
Perl_sys_init(int* argc, char*** argv)
{
    dVAR;

    PERL_ARGS_ASSERT_SYS_INIT;

    PERL_UNUSED_ARG(argc); /* may not be used depending on _BODY macro */
    PERL_UNUSED_ARG(argv);
    PERL_SYS_INIT_BODY(argc, argv);
}

void
Perl_sys_init3(int* argc, char*** argv, char*** env)
{
    dVAR;

    PERL_ARGS_ASSERT_SYS_INIT3;

    PERL_UNUSED_ARG(argc); /* may not be used depending on _BODY macro */
    PERL_UNUSED_ARG(argv);
    PERL_UNUSED_ARG(env);
    PERL_SYS_INIT3_BODY(argc, argv, env);
}

void
Perl_sys_term(void)
{
    dVAR;
    if (!PL_veto_cleanup) {
	PERL_SYS_TERM_BODY();
    }
}


#ifdef PERL_IMPLICIT_SYS
PerlInterpreter *
perl_alloc_using(struct IPerlMem* ipM, struct IPerlMem* ipMS,
		 struct IPerlMem* ipMP, struct IPerlEnv* ipE,
		 struct IPerlStdIO* ipStd, struct IPerlLIO* ipLIO,
		 struct IPerlDir* ipD, struct IPerlSock* ipS,
		 struct IPerlProc* ipP)
{
    PerlInterpreter *my_perl;

    PERL_ARGS_ASSERT_PERL_ALLOC_USING;

    /* Newx() needs interpreter, so call malloc() instead */
    my_perl = (PerlInterpreter*)(*ipM->pMalloc)(ipM, sizeof(PerlInterpreter));
    S_init_tls_and_interp(my_perl);
    Zero(my_perl, 1, PerlInterpreter);
    PL_Mem = ipM;
    PL_MemShared = ipMS;
    PL_MemParse = ipMP;
    PL_Env = ipE;
    PL_StdIO = ipStd;
    PL_LIO = ipLIO;
    PL_Dir = ipD;
    PL_Sock = ipS;
    PL_Proc = ipP;
    INIT_TRACK_MEMPOOL(PL_memory_debug_header, my_perl);

    return my_perl;
}
#else

/*
=head1 Embedding Functions

=for apidoc perl_alloc

Allocates a new Perl interpreter.  See L<perlembed>.

=cut
*/

PerlInterpreter *
perl_alloc(void)
{
    PerlInterpreter *my_perl;

    /* Newx() needs interpreter, so call malloc() instead */
    my_perl = (PerlInterpreter*)PerlMem_malloc(sizeof(PerlInterpreter));

    S_init_tls_and_interp(my_perl);
#ifndef PERL_TRACK_MEMPOOL
    return (PerlInterpreter *) ZeroD(my_perl, 1, PerlInterpreter);
#else
    Zero(my_perl, 1, PerlInterpreter);
    INIT_TRACK_MEMPOOL(PL_memory_debug_header, my_perl);
    return my_perl;
#endif
}
#endif /* PERL_IMPLICIT_SYS */

/*
=for apidoc perl_construct

Initializes a new Perl interpreter.  See L<perlembed>.

=cut
*/

void
perl_construct(pTHXx)
{
    dVAR;

    PERL_ARGS_ASSERT_PERL_CONSTRUCT;

#ifdef MULTIPLICITY
    init_interp();
    PL_perl_destruct_level = 1;
#else
    PERL_UNUSED_ARG(my_perl);
   if (PL_perl_destruct_level > 0)
       init_interp();
#endif
    PL_curcop = &PL_compiling;	/* needed by ckWARN, right away */

#ifdef PERL_TRACE_OPS
    Zero(PL_op_exec_cnt, OP_max+2, UV);
#endif

    init_constants();

    SvREADONLY_on(&PL_sv_placeholder);
    SvREFCNT(&PL_sv_placeholder) = SvREFCNT_IMMORTAL;

    PL_sighandlerp = (Sighandler_t) Perl_sighandler;
#ifdef PERL_USES_PL_PIDSTATUS
    PL_pidstatus = newHV();
#endif

    PL_rs = newSVpvs("\n");

    init_stacks();

    init_ids();

    JMPENV_BOOTSTRAP;
    STATUS_ALL_SUCCESS;

    init_i18nl10n(1);

#if defined(LOCAL_PATCH_COUNT)
    PL_localpatches = local_patches;	/* For possible -v */
#endif

#ifdef HAVE_INTERP_INTERN
    sys_intern_init();
#endif

    PerlIO_init(aTHX);			/* Hook to IO system */

    PL_fdpid = newAV();			/* for remembering popen pids by fd */
    PL_modglobal = newHV();		/* pointers to per-interpreter module globals */
    PL_errors = newSVpvs("");
    sv_setpvs(PERL_DEBUG_PAD(0), "");	/* For regex debugging. */
    sv_setpvs(PERL_DEBUG_PAD(1), "");	/* ext/re needs these */
    sv_setpvs(PERL_DEBUG_PAD(2), "");	/* even without DEBUGGING. */
#ifdef USE_ITHREADS
    /* First entry is a list of empty elements. It needs to be initialised
       else all hell breaks loose in S_find_uninit_var().  */
    Perl_av_create_and_push(aTHX_ &PL_regex_padav, newSVpvs(""));
    PL_regex_pad = AvARRAY(PL_regex_padav);
    Newxz(PL_stashpad, PL_stashpadmax, HV *);
#endif
#ifdef USE_REENTRANT_API
    Perl_reentrant_init(aTHX);
#endif
#if defined(USE_HASH_SEED) || defined(USE_HASH_SEED_EXPLICIT)
        /* [perl #22371] Algorimic Complexity Attack on Perl 5.6.1, 5.8.0
         * This MUST be done before any hash stores or fetches take place.
         * If you set PL_hash_seed (and presumably also PL_hash_seed_set)
         * yourself, it is your responsibility to provide a good random seed!
         * You can also define PERL_HASH_SEED in compile time, see hv.h.
         *
         * XXX: fix this comment */
    if (PL_hash_seed_set == FALSE) {
        Perl_get_hash_seed(aTHX_ PL_hash_seed);
        PL_hash_seed_set= TRUE;
    }
#endif /* #if defined(USE_HASH_SEED) || defined(USE_HASH_SEED_EXPLICIT) */

    /* Note that strtab is a rather special HV.  Assumptions are made
       about not iterating on it, and not adding tie magic to it.
       It is properly deallocated in perl_destruct() */
    PL_strtab = newHV();

    HvSHAREKEYS_off(PL_strtab);			/* mandatory */
    hv_ksplit(PL_strtab, 512);

    Zero(PL_sv_consts, SV_CONSTS_COUNT, SV*);

#ifndef PERL_MICRO
#   ifdef  USE_ENVIRON_ARRAY
    PL_origenviron = environ;
#   endif
#endif

    /* Use sysconf(_SC_CLK_TCK) if available, if not
     * available or if the sysconf() fails, use the HZ.
     * The HZ if not originally defined has been by now
     * been defined as CLK_TCK, if available. */
#if defined(HAS_SYSCONF) && defined(_SC_CLK_TCK)
    PL_clocktick = sysconf(_SC_CLK_TCK);
    if (PL_clocktick <= 0)
#endif
	 PL_clocktick = HZ;

    PL_stashcache = newHV();

    PL_patchlevel = newSVpvs("v" PERL_VERSION_STRING);

#ifdef HAS_MMAP
    if (!PL_mmap_page_size) {
#if defined(HAS_SYSCONF) && (defined(_SC_PAGESIZE) || defined(_SC_MMAP_PAGE_SIZE))
      {
	SETERRNO(0, SS_NORMAL);
#   ifdef _SC_PAGESIZE
	PL_mmap_page_size = sysconf(_SC_PAGESIZE);
#   else
	PL_mmap_page_size = sysconf(_SC_MMAP_PAGE_SIZE);
#   endif
	if ((long) PL_mmap_page_size < 0) {
	  if (errno) {
	    SV * const error = ERRSV;
	    SvUPGRADE(error, SVt_PV);
	    Perl_croak(aTHX_ "panic: sysconf: %s", SvPV_nolen_const(error));
	  }
	  else
	    Perl_croak(aTHX_ "panic: sysconf: pagesize unknown");
	}
      }
#else
#   ifdef HAS_GETPAGESIZE
      PL_mmap_page_size = getpagesize();
#   else
#       if defined(I_SYS_PARAM) && defined(PAGESIZE)
      PL_mmap_page_size = PAGESIZE;       /* compiletime, bad */
#       endif
#   endif
#endif
      if (PL_mmap_page_size <= 0)
	Perl_croak(aTHX_ "panic: bad pagesize %" IVdf,
		   (IV) PL_mmap_page_size);
    }
#endif /* HAS_MMAP */

#if defined(HAS_TIMES) && defined(PERL_NEED_TIMESBASE)
    PL_timesbase.tms_utime  = 0;
    PL_timesbase.tms_stime  = 0;
    PL_timesbase.tms_cutime = 0;
    PL_timesbase.tms_cstime = 0;
#endif

    PL_osname = Perl_savepvn(aTHX_ STR_WITH_LEN(OSNAME));

    PL_registered_mros = newHV();
    /* Start with 1 bucket, for DFS.  It's unlikely we'll need more.  */
    HvMAX(PL_registered_mros) = 0;

    PL_XPosix_ptrs[_CC_ASCII] = _new_invlist_C_array(ASCII_invlist);
    PL_XPosix_ptrs[_CC_ALPHANUMERIC] = _new_invlist_C_array(XPosixAlnum_invlist);
    PL_XPosix_ptrs[_CC_ALPHA] = _new_invlist_C_array(XPosixAlpha_invlist);
    PL_XPosix_ptrs[_CC_BLANK] = _new_invlist_C_array(XPosixBlank_invlist);
    PL_XPosix_ptrs[_CC_CASED] =  _new_invlist_C_array(Cased_invlist);
    PL_XPosix_ptrs[_CC_CNTRL] = _new_invlist_C_array(XPosixCntrl_invlist);
    PL_XPosix_ptrs[_CC_DIGIT] = _new_invlist_C_array(XPosixDigit_invlist);
    PL_XPosix_ptrs[_CC_GRAPH] = _new_invlist_C_array(XPosixGraph_invlist);
    PL_XPosix_ptrs[_CC_LOWER] = _new_invlist_C_array(XPosixLower_invlist);
    PL_XPosix_ptrs[_CC_PRINT] = _new_invlist_C_array(XPosixPrint_invlist);
    PL_XPosix_ptrs[_CC_PUNCT] = _new_invlist_C_array(XPosixPunct_invlist);
    PL_XPosix_ptrs[_CC_SPACE] = _new_invlist_C_array(XPerlSpace_invlist);
    PL_XPosix_ptrs[_CC_UPPER] = _new_invlist_C_array(XPosixUpper_invlist);
    PL_XPosix_ptrs[_CC_VERTSPACE] = _new_invlist_C_array(VertSpace_invlist);
    PL_XPosix_ptrs[_CC_WORDCHAR] = _new_invlist_C_array(XPosixWord_invlist);
    PL_XPosix_ptrs[_CC_XDIGIT] = _new_invlist_C_array(XPosixXDigit_invlist);
    PL_GCB_invlist = _new_invlist_C_array(_Perl_GCB_invlist);
    PL_SB_invlist = _new_invlist_C_array(_Perl_SB_invlist);
    PL_WB_invlist = _new_invlist_C_array(_Perl_WB_invlist);
    PL_LB_invlist = _new_invlist_C_array(_Perl_LB_invlist);

    ENTER;
}

/*
=for apidoc nothreadhook

Stub that provides thread hook for perl_destruct when there are
no threads.

=cut
*/

int
Perl_nothreadhook(pTHX)
{
    PERL_UNUSED_CONTEXT;
    return 0;
}

#ifdef DEBUG_LEAKING_SCALARS_FORK_DUMP
void
Perl_dump_sv_child(pTHX_ SV *sv)
{
    ssize_t got;
    const int sock = PL_dumper_fd;
    const int debug_fd = PerlIO_fileno(Perl_debug_log);
    union control_un control;
    struct msghdr msg;
    struct iovec vec[2];
    struct cmsghdr *cmptr;
    int returned_errno;
    unsigned char buffer[256];

    PERL_ARGS_ASSERT_DUMP_SV_CHILD;

    if(sock == -1 || debug_fd == -1)
	return;

    PerlIO_flush(Perl_debug_log);

    /* All these shenanigans are to pass a file descriptor over to our child for
       it to dump out to.  We can't let it hold open the file descriptor when it
       forks, as the file descriptor it will dump to can turn out to be one end
       of pipe that some other process will wait on for EOF. (So as it would
       be open, the wait would be forever.)  */

    msg.msg_control = control.control;
    msg.msg_controllen = sizeof(control.control);
    /* We're a connected socket so we don't need a destination  */
    msg.msg_name = NULL;
    msg.msg_namelen = 0;
    msg.msg_iov = vec;
    msg.msg_iovlen = 1;

    cmptr = CMSG_FIRSTHDR(&msg);
    cmptr->cmsg_len = CMSG_LEN(sizeof(int));
    cmptr->cmsg_level = SOL_SOCKET;
    cmptr->cmsg_type = SCM_RIGHTS;
    *((int *)CMSG_DATA(cmptr)) = 1;

    vec[0].iov_base = (void*)&sv;
    vec[0].iov_len = sizeof(sv);
    got = sendmsg(sock, &msg, 0);

    if(got < 0) {
	perror("Debug leaking scalars parent sendmsg failed");
	abort();
    }
    if(got < sizeof(sv)) {
	perror("Debug leaking scalars parent short sendmsg");
	abort();
    }

    /* Return protocol is
       int:		errno value
       unsigned char:	length of location string (0 for empty)
       unsigned char*:	string (not terminated)
    */
    vec[0].iov_base = (void*)&returned_errno;
    vec[0].iov_len = sizeof(returned_errno);
    vec[1].iov_base = buffer;
    vec[1].iov_len = 1;

    got = readv(sock, vec, 2);

    if(got < 0) {
	perror("Debug leaking scalars parent read failed");
	PerlIO_flush(PerlIO_stderr());
	abort();
    }
    if(got < sizeof(returned_errno) + 1) {
	perror("Debug leaking scalars parent short read");
	PerlIO_flush(PerlIO_stderr());
	abort();
    }

    if (*buffer) {
	got = read(sock, buffer + 1, *buffer);
	if(got < 0) {
	    perror("Debug leaking scalars parent read 2 failed");
	    PerlIO_flush(PerlIO_stderr());
	    abort();
	}

	if(got < *buffer) {
	    perror("Debug leaking scalars parent short read 2");
	    PerlIO_flush(PerlIO_stderr());
	    abort();
	}
    }

    if (returned_errno || *buffer) {
	Perl_warn(aTHX_ "Debug leaking scalars child failed%s%.*s with errno"
		  " %d: %s", (*buffer ? " at " : ""), (int) *buffer, buffer + 1,
		  returned_errno, Strerror(returned_errno));
    }
}
#endif

/*
=for apidoc perl_destruct

Shuts down a Perl interpreter.  See L<perlembed>.

=cut
*/

int
perl_destruct(pTHXx)
{
    dVAR;
    VOL signed char destruct_level;  /* see possible values in intrpvar.h */
    HV *hv;
#ifdef DEBUG_LEAKING_SCALARS_FORK_DUMP
    pid_t child;
#endif
    int i;

    PERL_ARGS_ASSERT_PERL_DESTRUCT;
#ifndef MULTIPLICITY
    PERL_UNUSED_ARG(my_perl);
#endif

    assert(PL_scopestack_ix == 1);

    /* wait for all pseudo-forked children to finish */
    PERL_WAIT_FOR_CHILDREN;

    destruct_level = PL_perl_destruct_level;
#if defined(DEBUGGING) || defined(PERL_TRACK_MEMPOOL)
    {
	const char * const s = PerlEnv_getenv("PERL_DESTRUCT_LEVEL");
	if (s) {
            int i;
            if (strEQ(s, "-1")) { /* Special case: modperl folklore. */
                i = -1;
            } else {
                UV uv;
                if (grok_atoUV(s, &uv, NULL) && uv <= INT_MAX)
                    i = (int)uv;
                else
                    i = 0;
            }
#ifdef DEBUGGING
	    if (destruct_level < i) destruct_level = i;
#endif
#ifdef PERL_TRACK_MEMPOOL
            /* RT #114496, for perl_free */
            PL_perl_destruct_level = i;
#endif
	}
    }
#endif

    if (PL_exit_flags & PERL_EXIT_DESTRUCT_END) {
        dJMPENV;
        int x = 0;

        JMPENV_PUSH(x);
	PERL_UNUSED_VAR(x);
        if (PL_endav && !PL_minus_c) {
	    PERL_SET_PHASE(PERL_PHASE_END);
            call_list(PL_scopestack_ix, PL_endav);
	}
        JMPENV_POP;
    }
    LEAVE;
    FREETMPS;
    assert(PL_scopestack_ix == 0);

    /* Need to flush since END blocks can produce output */
    /* flush stdout separately, since we can identify it */
#ifdef USE_PERLIO
    {
        PerlIO *stdo = PerlIO_stdout();
        if (*stdo && PerlIO_flush(stdo)) {
            PerlIO_restore_errno(stdo);
            PerlIO_printf(PerlIO_stderr(), "Unable to flush stdout: %s",
                          Strerror(errno));
            if (!STATUS_UNIX)
                STATUS_ALL_FAILURE;
        }
    }
#endif
    my_fflush_all();

#ifdef PERL_TRACE_OPS
    /* If we traced all Perl OP usage, report and clean up */
    PerlIO_printf(Perl_debug_log, "Trace of all OPs executed:\n");
    for (i = 0; i <= OP_max; ++i) {
        PerlIO_printf(Perl_debug_log, "  %s: %"UVuf"\n", PL_op_name[i], PL_op_exec_cnt[i]);
        PL_op_exec_cnt[i] = 0;
    }
    /* Utility slot for easily doing little tracing experiments in the runloop: */
    if (PL_op_exec_cnt[OP_max+1] != 0)
        PerlIO_printf(Perl_debug_log, "  SPECIAL: %"UVuf"\n", PL_op_exec_cnt[OP_max+1]);
    PerlIO_printf(Perl_debug_log, "\n");
#endif


    if (PL_threadhook(aTHX)) {
        /* Threads hook has vetoed further cleanup */
	PL_veto_cleanup = TRUE;
        return STATUS_EXIT;
    }

#ifdef DEBUG_LEAKING_SCALARS_FORK_DUMP
    if (destruct_level != 0) {
	/* Fork here to create a child. Our child's job is to preserve the
	   state of scalars prior to destruction, so that we can instruct it
	   to dump any scalars that we later find have leaked.
	   There's no subtlety in this code - it assumes POSIX, and it doesn't
	   fail gracefully  */
	int fd[2];

	if(socketpair(AF_UNIX, SOCK_STREAM, 0, fd)) {
	    perror("Debug leaking scalars socketpair failed");
	    abort();
	}

	child = fork();
	if(child == -1) {
	    perror("Debug leaking scalars fork failed");
	    abort();
	}
	if (!child) {
	    /* We are the child */
	    const int sock = fd[1];
	    const int debug_fd = PerlIO_fileno(Perl_debug_log);
	    int f;
	    const char *where;
	    /* Our success message is an integer 0, and a char 0  */
	    static const char success[sizeof(int) + 1] = {0};

	    close(fd[0]);

	    /* We need to close all other file descriptors otherwise we end up
	       with interesting hangs, where the parent closes its end of a
	       pipe, and sits waiting for (another) child to terminate. Only
	       that child never terminates, because it never gets EOF, because
	       we also have the far end of the pipe open.  We even need to
	       close the debugging fd, because sometimes it happens to be one
	       end of a pipe, and a process is waiting on the other end for
	       EOF. Normally it would be closed at some point earlier in
	       destruction, but if we happen to cause the pipe to remain open,
	       EOF never occurs, and we get an infinite hang. Hence all the
	       games to pass in a file descriptor if it's actually needed.  */

	    f = sysconf(_SC_OPEN_MAX);
	    if(f < 0) {
		where = "sysconf failed";
		goto abort;
	    }
	    while (f--) {
		if (f == sock)
		    continue;
		close(f);
	    }

	    while (1) {
		SV *target;
		union control_un control;
		struct msghdr msg;
		struct iovec vec[1];
		struct cmsghdr *cmptr;
		ssize_t got;
		int got_fd;

		msg.msg_control = control.control;
		msg.msg_controllen = sizeof(control.control);
		/* We're a connected socket so we don't need a source  */
		msg.msg_name = NULL;
		msg.msg_namelen = 0;
		msg.msg_iov = vec;
		msg.msg_iovlen = C_ARRAY_LENGTH(vec);

		vec[0].iov_base = (void*)&target;
		vec[0].iov_len = sizeof(target);
      
		got = recvmsg(sock, &msg, 0);

		if(got == 0)
		    break;
		if(got < 0) {
		    where = "recv failed";
		    goto abort;
		}
		if(got < sizeof(target)) {
		    where = "short recv";
		    goto abort;
		}

		if(!(cmptr = CMSG_FIRSTHDR(&msg))) {
		    where = "no cmsg";
		    goto abort;
		}
		if(cmptr->cmsg_len != CMSG_LEN(sizeof(int))) {
		    where = "wrong cmsg_len";
		    goto abort;
		}
		if(cmptr->cmsg_level != SOL_SOCKET) {
		    where = "wrong cmsg_level";
		    goto abort;
		}
		if(cmptr->cmsg_type != SCM_RIGHTS) {
		    where = "wrong cmsg_type";
		    goto abort;
		}

		got_fd = *(int*)CMSG_DATA(cmptr);
		/* For our last little bit of trickery, put the file descriptor
		   back into Perl_debug_log, as if we never actually closed it
		*/
		if(got_fd != debug_fd) {
		    if (dup2(got_fd, debug_fd) == -1) {
			where = "dup2";
			goto abort;
		    }
		}
		sv_dump(target);

		PerlIO_flush(Perl_debug_log);

		got = write(sock, &success, sizeof(success));

		if(got < 0) {
		    where = "write failed";
		    goto abort;
		}
		if(got < sizeof(success)) {
		    where = "short write";
		    goto abort;
		}
	    }
	    _exit(0);
	abort:
	    {
		int send_errno = errno;
		unsigned char length = (unsigned char) strlen(where);
		struct iovec failure[3] = {
		    {(void*)&send_errno, sizeof(send_errno)},
		    {&length, 1},
		    {(void*)where, length}
		};
		int got = writev(sock, failure, 3);
		/* Bad news travels fast. Faster than data. We'll get a SIGPIPE
		   in the parent if we try to read from the socketpair after the
		   child has exited, even if there was data to read.
		   So sleep a bit to give the parent a fighting chance of
		   reading the data.  */
		sleep(2);
		_exit((got == -1) ? errno : 0);
	    }
	    /* End of child.  */
	}
	PL_dumper_fd = fd[0];
	close(fd[1]);
    }
#endif
    
    /* We must account for everything.  */

    /* Destroy the main CV and syntax tree */
    /* Set PL_curcop now, because destroying ops can cause new SVs
       to be generated in Perl_pad_swipe, and when running with
      -DDEBUG_LEAKING_SCALARS they expect PL_curcop to point to a valid
       op from which the filename structure member is copied.  */
    PL_curcop = &PL_compiling;
    if (PL_main_root) {
	/* ensure comppad/curpad to refer to main's pad */
	if (CvPADLIST(PL_main_cv)) {
	    PAD_SET_CUR_NOSAVE(CvPADLIST(PL_main_cv), 1);
	    PL_comppad_name = PadlistNAMES(CvPADLIST(PL_main_cv));
	}
	op_free(PL_main_root);
	PL_main_root = NULL;
    }
    PL_main_start = NULL;
    /* note that  PL_main_cv isn't usually actually freed at this point,
     * due to the CvOUTSIDE refs from subs compiled within it. It will
     * get freed once all the subs are freed in sv_clean_all(), for
     * destruct_level > 0 */
    SvREFCNT_dec(PL_main_cv);
    PL_main_cv = NULL;
    PERL_SET_PHASE(PERL_PHASE_DESTRUCT);

    /* Tell PerlIO we are about to tear things apart in case
       we have layers which are using resources that should
       be cleaned up now.
     */

    PerlIO_destruct(aTHX);

    /*
     * Try to destruct global references.  We do this first so that the
     * destructors and destructees still exist.  Some sv's might remain.
     * Non-referenced objects are on their own.
     */
    sv_clean_objs();

    /* unhook hooks which will soon be, or use, destroyed data */
    SvREFCNT_dec(PL_warnhook);
    PL_warnhook = NULL;
    SvREFCNT_dec(PL_diehook);
    PL_diehook = NULL;

    /* call exit list functions */
    while (PL_exitlistlen-- > 0)
	PL_exitlist[PL_exitlistlen].fn(aTHX_ PL_exitlist[PL_exitlistlen].ptr);

    Safefree(PL_exitlist);

    PL_exitlist = NULL;
    PL_exitlistlen = 0;

    SvREFCNT_dec(PL_registered_mros);

    /* jettison our possibly duplicated environment */
    /* if PERL_USE_SAFE_PUTENV is defined environ will not have been copied
     * so we certainly shouldn't free it here
     */
#ifndef PERL_MICRO
#if defined(USE_ENVIRON_ARRAY) && !defined(PERL_USE_SAFE_PUTENV)
    if (environ != PL_origenviron && !PL_use_safe_putenv
#ifdef USE_ITHREADS
	/* only main thread can free environ[0] contents */
	&& PL_curinterp == aTHX
#endif
	)
    {
	I32 i;

	for (i = 0; environ[i]; i++)
	    safesysfree(environ[i]);

	/* Must use safesysfree() when working with environ. */
	safesysfree(environ);		

	environ = PL_origenviron;
    }
#endif
#endif /* !PERL_MICRO */

    if (destruct_level == 0) {

	DEBUG_P(debprofdump());

#if defined(PERLIO_LAYERS)
	/* No more IO - including error messages ! */
	PerlIO_cleanup(aTHX);
#endif

	CopFILE_free(&PL_compiling);

	/* The exit() function will do everything that needs doing. */
        return STATUS_EXIT;
    }

    /* Below, do clean up for when PERL_DESTRUCT_LEVEL is not 0 */

#ifdef USE_ITHREADS
    /* the syntax tree is shared between clones
     * so op_free(PL_main_root) only ReREFCNT_dec's
     * REGEXPs in the parent interpreter
     * we need to manually ReREFCNT_dec for the clones
     */
    {
	I32 i = AvFILLp(PL_regex_padav);
	SV **ary = AvARRAY(PL_regex_padav);

	for (; i; i--) {
	    SvREFCNT_dec(ary[i]);
	    ary[i] = &PL_sv_undef;
	}
    }
#endif


    SvREFCNT_dec(MUTABLE_SV(PL_stashcache));
    PL_stashcache = NULL;

    /* loosen bonds of global variables */

    /* XXX can PL_parser still be non-null here? */
    if(PL_parser && PL_parser->rsfp) {
	(void)PerlIO_close(PL_parser->rsfp);
	PL_parser->rsfp = NULL;
    }

    if (PL_minus_F) {
	Safefree(PL_splitstr);
	PL_splitstr = NULL;
    }

    /* switches */
    PL_minus_n      = FALSE;
    PL_minus_p      = FALSE;
    PL_minus_l      = FALSE;
    PL_minus_a      = FALSE;
    PL_minus_F      = FALSE;
    PL_doswitches   = FALSE;
    PL_dowarn       = G_WARN_OFF;
#ifdef PERL_SAWAMPERSAND
    PL_sawampersand = 0;	/* must save all match strings */
#endif
    PL_unsafe       = FALSE;

    Safefree(PL_inplace);
    PL_inplace = NULL;
    SvREFCNT_dec(PL_patchlevel);

    if (PL_e_script) {
	SvREFCNT_dec(PL_e_script);
	PL_e_script = NULL;
    }

    PL_perldb = 0;

    /* magical thingies */

    SvREFCNT_dec(PL_ofsgv);	/* *, */
    PL_ofsgv = NULL;

    SvREFCNT_dec(PL_ors_sv);	/* $\ */
    PL_ors_sv = NULL;

    SvREFCNT_dec(PL_rs);	/* $/ */
    PL_rs = NULL;

    Safefree(PL_osname);	/* $^O */
    PL_osname = NULL;

    SvREFCNT_dec(PL_statname);
    PL_statname = NULL;
    PL_statgv = NULL;

    /* defgv, aka *_ should be taken care of elsewhere */

    /* float buffer */
    Safefree(PL_efloatbuf);
    PL_efloatbuf = NULL;
    PL_efloatsize = 0;

    /* startup and shutdown function lists */
    SvREFCNT_dec(PL_beginav);
    SvREFCNT_dec(PL_beginav_save);
    SvREFCNT_dec(PL_endav);
    SvREFCNT_dec(PL_checkav);
    SvREFCNT_dec(PL_checkav_save);
    SvREFCNT_dec(PL_unitcheckav);
    SvREFCNT_dec(PL_unitcheckav_save);
    SvREFCNT_dec(PL_initav);
    PL_beginav = NULL;
    PL_beginav_save = NULL;
    PL_endav = NULL;
    PL_checkav = NULL;
    PL_checkav_save = NULL;
    PL_unitcheckav = NULL;
    PL_unitcheckav_save = NULL;
    PL_initav = NULL;

    /* shortcuts just get cleared */
    PL_hintgv = NULL;
    PL_errgv = NULL;
    PL_argvoutgv = NULL;
    PL_stdingv = NULL;
    PL_stderrgv = NULL;
    PL_last_in_gv = NULL;
    PL_DBsingle = NULL;
    PL_DBtrace = NULL;
    PL_DBsignal = NULL;
    PL_DBsingle_iv = 0;
    PL_DBtrace_iv = 0;
    PL_DBsignal_iv = 0;
    PL_DBcv = NULL;
    PL_dbargs = NULL;
    PL_debstash = NULL;

    SvREFCNT_dec(PL_envgv);
    SvREFCNT_dec(PL_incgv);
    SvREFCNT_dec(PL_argvgv);
    SvREFCNT_dec(PL_replgv);
    SvREFCNT_dec(PL_DBgv);
    SvREFCNT_dec(PL_DBline);
    SvREFCNT_dec(PL_DBsub);
    PL_envgv = NULL;
    PL_incgv = NULL;
    PL_argvgv = NULL;
    PL_replgv = NULL;
    PL_DBgv = NULL;
    PL_DBline = NULL;
    PL_DBsub = NULL;

    SvREFCNT_dec(PL_argvout_stack);
    PL_argvout_stack = NULL;

    SvREFCNT_dec(PL_modglobal);
    PL_modglobal = NULL;
    SvREFCNT_dec(PL_preambleav);
    PL_preambleav = NULL;
    SvREFCNT_dec(PL_subname);
    PL_subname = NULL;
#ifdef PERL_USES_PL_PIDSTATUS
    SvREFCNT_dec(PL_pidstatus);
    PL_pidstatus = NULL;
#endif
    SvREFCNT_dec(PL_toptarget);
    PL_toptarget = NULL;
    SvREFCNT_dec(PL_bodytarget);
    PL_bodytarget = NULL;
    PL_formtarget = NULL;

    /* free locale stuff */
#ifdef USE_LOCALE_COLLATE
    Safefree(PL_collation_name);
    PL_collation_name = NULL;
#endif

#ifdef USE_LOCALE_NUMERIC
    Safefree(PL_numeric_name);
    PL_numeric_name = NULL;
    SvREFCNT_dec(PL_numeric_radix_sv);
    PL_numeric_radix_sv = NULL;
#endif

    /* clear character classes  */
    for (i = 0; i < POSIX_SWASH_COUNT; i++) {
        SvREFCNT_dec(PL_utf8_swash_ptrs[i]);
        PL_utf8_swash_ptrs[i] = NULL;
    }
    SvREFCNT_dec(PL_utf8_mark);
    SvREFCNT_dec(PL_utf8_toupper);
    SvREFCNT_dec(PL_utf8_totitle);
    SvREFCNT_dec(PL_utf8_tolower);
    SvREFCNT_dec(PL_utf8_tofold);
    SvREFCNT_dec(PL_utf8_idstart);
    SvREFCNT_dec(PL_utf8_idcont);
    SvREFCNT_dec(PL_utf8_foldable);
    SvREFCNT_dec(PL_utf8_foldclosures);
    SvREFCNT_dec(PL_AboveLatin1);
    SvREFCNT_dec(PL_InBitmap);
    SvREFCNT_dec(PL_UpperLatin1);
    SvREFCNT_dec(PL_Latin1);
    SvREFCNT_dec(PL_NonL1NonFinalFold);
    SvREFCNT_dec(PL_HasMultiCharFold);
#ifdef USE_LOCALE_CTYPE
    SvREFCNT_dec(PL_warn_locale);
#endif
    PL_utf8_mark	= NULL;
    PL_utf8_toupper	= NULL;
    PL_utf8_totitle	= NULL;
    PL_utf8_tolower	= NULL;
    PL_utf8_tofold	= NULL;
    PL_utf8_idstart	= NULL;
    PL_utf8_idcont	= NULL;
    PL_utf8_foldclosures = NULL;
    PL_AboveLatin1       = NULL;
    PL_InBitmap          = NULL;
    PL_HasMultiCharFold  = NULL;
#ifdef USE_LOCALE_CTYPE
    PL_warn_locale       = NULL;
#endif
    PL_Latin1            = NULL;
    PL_NonL1NonFinalFold = NULL;
    PL_UpperLatin1       = NULL;
    for (i = 0; i < POSIX_CC_COUNT; i++) {
        SvREFCNT_dec(PL_XPosix_ptrs[i]);
        PL_XPosix_ptrs[i] = NULL;
    }
    PL_GCB_invlist = NULL;
    PL_LB_invlist = NULL;
    PL_SB_invlist = NULL;
    PL_WB_invlist = NULL;

    if (!specialWARN(PL_compiling.cop_warnings))
	PerlMemShared_free(PL_compiling.cop_warnings);
    PL_compiling.cop_warnings = NULL;
    cophh_free(CopHINTHASH_get(&PL_compiling));
    CopHINTHASH_set(&PL_compiling, cophh_new_empty());
    CopFILE_free(&PL_compiling);

    /* Prepare to destruct main symbol table.  */

    hv = PL_defstash;
    /* break ref loop  *:: <=> %:: */
    (void)hv_delete(hv, "main::", 6, G_DISCARD);
    PL_defstash = 0;
    SvREFCNT_dec(hv);
    SvREFCNT_dec(PL_curstname);
    PL_curstname = NULL;

    /* clear queued errors */
    SvREFCNT_dec(PL_errors);
    PL_errors = NULL;

    SvREFCNT_dec(PL_isarev);

    FREETMPS;
    if (destruct_level >= 2) {
	if (PL_scopestack_ix != 0)
	    Perl_ck_warner_d(aTHX_ packWARN(WARN_INTERNAL),
			     "Unbalanced scopes: %ld more ENTERs than LEAVEs\n",
			     (long)PL_scopestack_ix);
	if (PL_savestack_ix != 0)
	    Perl_ck_warner_d(aTHX_ packWARN(WARN_INTERNAL),
			     "Unbalanced saves: %ld more saves than restores\n",
			     (long)PL_savestack_ix);
	if (PL_tmps_floor != -1)
	    Perl_ck_warner_d(aTHX_ packWARN(WARN_INTERNAL),"Unbalanced tmps: %ld more allocs than frees\n",
			     (long)PL_tmps_floor + 1);
	if (cxstack_ix != -1)
	    Perl_ck_warner_d(aTHX_ packWARN(WARN_INTERNAL),"Unbalanced context: %ld more PUSHes than POPs\n",
			     (long)cxstack_ix + 1);
    }

#ifdef USE_ITHREADS
    SvREFCNT_dec(PL_regex_padav);
    PL_regex_padav = NULL;
    PL_regex_pad = NULL;
#endif

#ifdef PERL_IMPLICIT_CONTEXT
    /* the entries in this list are allocated via SV PVX's, so get freed
     * in sv_clean_all */
    Safefree(PL_my_cxt_list);
#endif

    /* Now absolutely destruct everything, somehow or other, loops or no. */

    /* the 2 is for PL_fdpid and PL_strtab */
    while (sv_clean_all() > 2)
	;

#ifdef USE_ITHREADS
    Safefree(PL_stashpad); /* must come after sv_clean_all */
#endif

    AvREAL_off(PL_fdpid);		/* no surviving entries */
    SvREFCNT_dec(PL_fdpid);		/* needed in io_close() */
    PL_fdpid = NULL;

#ifdef HAVE_INTERP_INTERN
    sys_intern_clear();
#endif

    /* constant strings */
    for (i = 0; i < SV_CONSTS_COUNT; i++) {
        SvREFCNT_dec(PL_sv_consts[i]);
        PL_sv_consts[i] = NULL;
    }

    /* Destruct the global string table. */
    {
	/* Yell and reset the HeVAL() slots that are still holding refcounts,
	 * so that sv_free() won't fail on them.
	 * Now that the global string table is using a single hunk of memory
	 * for both HE and HEK, we either need to explicitly unshare it the
	 * correct way, or actually free things here.
	 */
	I32 riter = 0;
	const I32 max = HvMAX(PL_strtab);
	HE * const * const array = HvARRAY(PL_strtab);
	HE *hent = array[0];

	for (;;) {
	    if (hent && ckWARN_d(WARN_INTERNAL)) {
		HE * const next = HeNEXT(hent);
		Perl_warner(aTHX_ packWARN(WARN_INTERNAL),
		     "Unbalanced string table refcount: (%ld) for \"%s\"",
		     (long)hent->he_valu.hent_refcount, HeKEY(hent));
		Safefree(hent);
		hent = next;
	    }
	    if (!hent) {
		if (++riter > max)
		    break;
		hent = array[riter];
	    }
	}

	Safefree(array);
	HvARRAY(PL_strtab) = 0;
	HvTOTALKEYS(PL_strtab) = 0;
    }
    SvREFCNT_dec(PL_strtab);

#ifdef USE_ITHREADS
    /* free the pointer tables used for cloning */
    ptr_table_free(PL_ptr_table);
    PL_ptr_table = (PTR_TBL_t*)NULL;
#endif

    /* free special SVs */

    SvREFCNT(&PL_sv_yes) = 0;
    sv_clear(&PL_sv_yes);
    SvANY(&PL_sv_yes) = NULL;
    SvFLAGS(&PL_sv_yes) = 0;

    SvREFCNT(&PL_sv_no) = 0;
    sv_clear(&PL_sv_no);
    SvANY(&PL_sv_no) = NULL;
    SvFLAGS(&PL_sv_no) = 0;

    {
        int i;
        for (i=0; i<=2; i++) {
            SvREFCNT(PERL_DEBUG_PAD(i)) = 0;
            sv_clear(PERL_DEBUG_PAD(i));
            SvANY(PERL_DEBUG_PAD(i)) = NULL;
            SvFLAGS(PERL_DEBUG_PAD(i)) = 0;
        }
    }

    if (PL_sv_count != 0 && ckWARN_d(WARN_INTERNAL))
	Perl_warner(aTHX_ packWARN(WARN_INTERNAL),"Scalars leaked: %ld\n", (long)PL_sv_count);

#ifdef DEBUG_LEAKING_SCALARS
    if (PL_sv_count != 0) {
	SV* sva;
	SV* sv;
	SV* svend;

	for (sva = PL_sv_arenaroot; sva; sva = MUTABLE_SV(SvANY(sva))) {
	    svend = &sva[SvREFCNT(sva)];
	    for (sv = sva + 1; sv < svend; ++sv) {
		if (SvTYPE(sv) != (svtype)SVTYPEMASK) {
		    PerlIO_printf(Perl_debug_log, "leaked: sv=0x%p"
			" flags=0x%"UVxf
			" refcnt=%"UVuf pTHX__FORMAT "\n"
			"\tallocated at %s:%d %s %s (parent 0x%"UVxf");"
			"serial %"UVuf"\n",
			(void*)sv, (UV)sv->sv_flags, (UV)sv->sv_refcnt
			pTHX__VALUE,
			sv->sv_debug_file ? sv->sv_debug_file : "(unknown)",
			sv->sv_debug_line,
			sv->sv_debug_inpad ? "for" : "by",
			sv->sv_debug_optype ?
			    PL_op_name[sv->sv_debug_optype]: "(none)",
			PTR2UV(sv->sv_debug_parent),
			sv->sv_debug_serial
		    );
#ifdef DEBUG_LEAKING_SCALARS_FORK_DUMP
		    Perl_dump_sv_child(aTHX_ sv);
#endif
		}
	    }
	}
    }
#ifdef DEBUG_LEAKING_SCALARS_FORK_DUMP
    {
	int status;
	fd_set rset;
	/* Wait for up to 4 seconds for child to terminate.
	   This seems to be the least effort way of timing out on reaping
	   its exit status.  */
	struct timeval waitfor = {4, 0};
	int sock = PL_dumper_fd;

	shutdown(sock, 1);
	FD_ZERO(&rset);
	FD_SET(sock, &rset);
	select(sock + 1, &rset, NULL, NULL, &waitfor);
	waitpid(child, &status, WNOHANG);
	close(sock);
    }
#endif
#endif
#ifdef DEBUG_LEAKING_SCALARS_ABORT
    if (PL_sv_count)
	abort();
#endif
    PL_sv_count = 0;

#if defined(PERLIO_LAYERS)
    /* No more IO - including error messages ! */
    PerlIO_cleanup(aTHX);
#endif

    /* sv_undef needs to stay immortal until after PerlIO_cleanup
       as currently layers use it rather than NULL as a marker
       for no arg - and will try and SvREFCNT_dec it.
     */
    SvREFCNT(&PL_sv_undef) = 0;
    SvREADONLY_off(&PL_sv_undef);

    Safefree(PL_origfilename);
    PL_origfilename = NULL;
    Safefree(PL_reg_curpm);
    free_tied_hv_pool();
    Safefree(PL_op_mask);
    Safefree(PL_psig_name);
    PL_psig_name = (SV**)NULL;
    PL_psig_ptr = (SV**)NULL;
    {
	/* We need to NULL PL_psig_pend first, so that
	   signal handlers know not to use it */
	int *psig_save = PL_psig_pend;
	PL_psig_pend = (int*)NULL;
	Safefree(psig_save);
    }
    nuke_stacks();
    TAINTING_set(FALSE);
    TAINT_WARN_set(FALSE);
    PL_hints = 0;		/* Reset hints. Should hints be per-interpreter ? */

    DEBUG_P(debprofdump());

    PL_debug = 0;

#ifdef USE_REENTRANT_API
    Perl_reentrant_free(aTHX);
#endif

    /* These all point to HVs that are about to be blown away.
       Code in core and on CPAN assumes that if the interpreter is re-started
       that they will be cleanly NULL or pointing to a valid HV.  */
    PL_custom_op_names = NULL;
    PL_custom_op_descs = NULL;
    PL_custom_ops = NULL;

    sv_free_arenas();

    while (PL_regmatch_slab) {
	regmatch_slab  *s = PL_regmatch_slab;
	PL_regmatch_slab = PL_regmatch_slab->next;
	Safefree(s);
    }

    /* As the absolutely last thing, free the non-arena SV for mess() */

    if (PL_mess_sv) {
	/* we know that type == SVt_PVMG */

	/* it could have accumulated taint magic */
	MAGIC* mg;
	MAGIC* moremagic;
	for (mg = SvMAGIC(PL_mess_sv); mg; mg = moremagic) {
	    moremagic = mg->mg_moremagic;
	    if (mg->mg_ptr && mg->mg_type != PERL_MAGIC_regex_global
		&& mg->mg_len >= 0)
		Safefree(mg->mg_ptr);
	    Safefree(mg);
	}

	/* we know that type >= SVt_PV */
	SvPV_free(PL_mess_sv);
	Safefree(SvANY(PL_mess_sv));
	Safefree(PL_mess_sv);
	PL_mess_sv = NULL;
    }
    return STATUS_EXIT;
}

/*
=for apidoc perl_free

Releases a Perl interpreter.  See L<perlembed>.

=cut
*/

void
perl_free(pTHXx)
{
    dVAR;

    PERL_ARGS_ASSERT_PERL_FREE;

    if (PL_veto_cleanup)
	return;

#ifdef PERL_TRACK_MEMPOOL
    {
	/*
	 * Don't free thread memory if PERL_DESTRUCT_LEVEL is set to a non-zero
	 * value as we're probably hunting memory leaks then
	 */
	if (PL_perl_destruct_level == 0) {
	    const U32 old_debug = PL_debug;
	    /* Emulate the PerlHost behaviour of free()ing all memory allocated in this
	       thread at thread exit.  */
	    if (DEBUG_m_TEST) {
		PerlIO_puts(Perl_debug_log, "Disabling memory debugging as we "
			    "free this thread's memory\n");
		PL_debug &= ~ DEBUG_m_FLAG;
	    }
	    while(aTHXx->Imemory_debug_header.next != &(aTHXx->Imemory_debug_header)){
		char * next = (char *)(aTHXx->Imemory_debug_header.next);
		Malloc_t ptr = PERL_MEMORY_DEBUG_HEADER_SIZE + next;
		safesysfree(ptr);
	    }
	    PL_debug = old_debug;
	}
    }
#endif

#if defined(WIN32) || defined(NETWARE)
#  if defined(PERL_IMPLICIT_SYS)
    {
#    ifdef NETWARE
	void *host = nw_internal_host;
	PerlMem_free(aTHXx);
	nw_delete_internal_host(host);
#    else
	void *host = w32_internal_host;
	PerlMem_free(aTHXx);
	win32_delete_internal_host(host);
#    endif
    }
#  else
    PerlMem_free(aTHXx);
#  endif
#else
    PerlMem_free(aTHXx);
#endif
}

#if defined(USE_ITHREADS)
/* provide destructors to clean up the thread key when libperl is unloaded */
#ifndef WIN32 /* handled during DLL_PROCESS_DETACH in win32/perllib.c */

#if defined(__hpux) && !(defined(__ux_version) && __ux_version <= 1020) && !defined(__GNUC__)
#pragma fini "perl_fini"
#elif defined(__sun) && !defined(__GNUC__)
#pragma fini (perl_fini)
#endif

static void
#if defined(__GNUC__)
__attribute__((destructor))
#endif
perl_fini(void)
{
    dVAR;
    if (
#ifdef PERL_GLOBAL_STRUCT_PRIVATE
        my_vars &&
#endif
        PL_curinterp && !PL_veto_cleanup)
	FREE_THREAD_KEY;
}

#endif /* WIN32 */
#endif /* THREADS */

void
Perl_call_atexit(pTHX_ ATEXIT_t fn, void *ptr)
{
    Renew(PL_exitlist, PL_exitlistlen+1, PerlExitListEntry);
    PL_exitlist[PL_exitlistlen].fn = fn;
    PL_exitlist[PL_exitlistlen].ptr = ptr;
    ++PL_exitlistlen;
}

/*
=for apidoc perl_parse

Tells a Perl interpreter to parse a Perl script.  See L<perlembed>.

=cut
*/

#define SET_CURSTASH(newstash)                       \
	if (PL_curstash != newstash) {                \
	    SvREFCNT_dec(PL_curstash);                 \
	    PL_curstash = (HV *)SvREFCNT_inc(newstash); \
	}

int
perl_parse(pTHXx_ XSINIT_t xsinit, int argc, char **argv, char **env)
{
    dVAR;
    I32 oldscope;
    int ret;
    dJMPENV;

    PERL_ARGS_ASSERT_PERL_PARSE;
#ifndef MULTIPLICITY
    PERL_UNUSED_ARG(my_perl);
#endif
#if defined(USE_HASH_SEED) || defined(USE_HASH_SEED_EXPLICIT) || defined(USE_HASH_SEED_DEBUG)
    {
        const char * const s = PerlEnv_getenv("PERL_HASH_SEED_DEBUG");

        if (s && strEQ(s, "1")) {
            const unsigned char *seed= PERL_HASH_SEED;
            const unsigned char *seed_end= PERL_HASH_SEED + PERL_HASH_SEED_BYTES;
            PerlIO_printf(Perl_debug_log, "HASH_FUNCTION = %s HASH_SEED = 0x", PERL_HASH_FUNC);
            while (seed < seed_end) {
                PerlIO_printf(Perl_debug_log, "%02x", *seed++);
            }
#ifdef PERL_HASH_RANDOMIZE_KEYS
            PerlIO_printf(Perl_debug_log, " PERTURB_KEYS = %d (%s)",
                    PL_HASH_RAND_BITS_ENABLED,
                    PL_HASH_RAND_BITS_ENABLED == 0 ? "NO" : PL_HASH_RAND_BITS_ENABLED == 1 ? "RANDOM" : "DETERMINISTIC");
#endif
            PerlIO_printf(Perl_debug_log, "\n");
        }
    }
#endif /* #if defined(USE_HASH_SEED) || defined(USE_HASH_SEED_EXPLICIT) */

#ifdef __amigaos4__
    {
        struct NameTranslationInfo nti;
        __translate_amiga_to_unix_path_name(&argv[0],&nti); 
    }
#endif

    PL_origargc = argc;
    PL_origargv = argv;

    if (PL_origalen != 0) {
	PL_origalen = 1; /* don't use old PL_origalen if perl_parse() is called again */
    }
    else {
	/* Set PL_origalen be the sum of the contiguous argv[]
	 * elements plus the size of the env in case that it is
	 * contiguous with the argv[].  This is used in mg.c:Perl_magic_set()
	 * as the maximum modifiable length of $0.  In the worst case
	 * the area we are able to modify is limited to the size of
	 * the original argv[0].  (See below for 'contiguous', though.)
	 * --jhi */
	 const char *s = NULL;
	 int i;
	 const UV mask = ~(UV)(PTRSIZE-1);
         /* Do the mask check only if the args seem like aligned. */
	 const UV aligned =
	   (mask < ~(UV)0) && ((PTR2UV(argv[0]) & mask) == PTR2UV(argv[0]));

	 /* See if all the arguments are contiguous in memory.  Note
	  * that 'contiguous' is a loose term because some platforms
	  * align the argv[] and the envp[].  If the arguments look
	  * like non-aligned, assume that they are 'strictly' or
	  * 'traditionally' contiguous.  If the arguments look like
	  * aligned, we just check that they are within aligned
	  * PTRSIZE bytes.  As long as no system has something bizarre
	  * like the argv[] interleaved with some other data, we are
	  * fine.  (Did I just evoke Murphy's Law?)  --jhi */
	 if (PL_origargv && PL_origargc >= 1 && (s = PL_origargv[0])) {
	      while (*s) s++;
	      for (i = 1; i < PL_origargc; i++) {
		   if ((PL_origargv[i] == s + 1
#ifdef OS2
			|| PL_origargv[i] == s + 2
#endif 
			    )
		       ||
		       (aligned &&
			(PL_origargv[i] >  s &&
			 PL_origargv[i] <=
			 INT2PTR(char *, PTR2UV(s + PTRSIZE) & mask)))
			)
		   {
			s = PL_origargv[i];
			while (*s) s++;
		   }
		   else
			break;
	      }
	 }

#ifndef PERL_USE_SAFE_PUTENV
	 /* Can we grab env area too to be used as the area for $0? */
	 if (s && PL_origenviron && !PL_use_safe_putenv) {
	      if ((PL_origenviron[0] == s + 1)
		  ||
		  (aligned &&
		   (PL_origenviron[0] >  s &&
		    PL_origenviron[0] <=
		    INT2PTR(char *, PTR2UV(s + PTRSIZE) & mask)))
		 )
	      {
#ifndef OS2		/* ENVIRON is read by the kernel too. */
		   s = PL_origenviron[0];
		   while (*s) s++;
#endif
		   my_setenv("NoNe  SuCh", NULL);
		   /* Force copy of environment. */
		   for (i = 1; PL_origenviron[i]; i++) {
			if (PL_origenviron[i] == s + 1
			    ||
			    (aligned &&
			     (PL_origenviron[i] >  s &&
			      PL_origenviron[i] <=
			      INT2PTR(char *, PTR2UV(s + PTRSIZE) & mask)))
			   )
			{
			     s = PL_origenviron[i];
			     while (*s) s++;
			}
			else
			     break;
		   }
	      }
	 }
#endif /* !defined(PERL_USE_SAFE_PUTENV) */

	 PL_origalen = s ? s - PL_origargv[0] + 1 : 0;
    }

    if (PL_do_undump) {

	/* Come here if running an undumped a.out. */

	PL_origfilename = savepv(argv[0]);
	PL_do_undump = FALSE;
	cxstack_ix = -1;		/* start label stack again */
	init_ids();
	assert (!TAINT_get);
	TAINT;
	set_caret_X();
	TAINT_NOT;
	init_postdump_symbols(argc,argv,env);
	return 0;
    }

    if (PL_main_root) {
	op_free(PL_main_root);
	PL_main_root = NULL;
    }
    PL_main_start = NULL;
    SvREFCNT_dec(PL_main_cv);
    PL_main_cv = NULL;

    time(&PL_basetime);
    oldscope = PL_scopestack_ix;
    PL_dowarn = G_WARN_OFF;

    JMPENV_PUSH(ret);
    switch (ret) {
    case 0:
	parse_body(env,xsinit);
	if (PL_unitcheckav) {
	    call_list(oldscope, PL_unitcheckav);
	}
	if (PL_checkav) {
	    PERL_SET_PHASE(PERL_PHASE_CHECK);
	    call_list(oldscope, PL_checkav);
	}
	ret = 0;
	break;
    case 1:
	STATUS_ALL_FAILURE;
	/* FALLTHROUGH */
    case 2:
	/* my_exit() was called */
	while (PL_scopestack_ix > oldscope)
	    LEAVE;
	FREETMPS;
	SET_CURSTASH(PL_defstash);
	if (PL_unitcheckav) {
	    call_list(oldscope, PL_unitcheckav);
	}
	if (PL_checkav) {
	    PERL_SET_PHASE(PERL_PHASE_CHECK);
	    call_list(oldscope, PL_checkav);
	}
	ret = STATUS_EXIT;
	break;
    case 3:
	PerlIO_printf(Perl_error_log, "panic: top_env\n");
	ret = 1;
	break;
    }
    JMPENV_POP;
    return ret;
}

/* This needs to stay in perl.c, as perl.c is compiled with different flags for
   miniperl, and we need to see those flags reflected in the values here.  */

/* What this returns is subject to change.  Use the public interface in Config.
 */
static void
S_Internals_V(pTHX_ CV *cv)
{
    dXSARGS;
#ifdef LOCAL_PATCH_COUNT
    const int local_patch_count = LOCAL_PATCH_COUNT;
#else
    const int local_patch_count = 0;
#endif
    const int entries = 3 + local_patch_count;
    int i;
    static const char non_bincompat_options[] = 
#  ifdef DEBUGGING
			     " DEBUGGING"
#  endif
#  ifdef NO_MATHOMS
			     " NO_MATHOMS"
#  endif
#  ifdef NO_HASH_SEED
			     " NO_HASH_SEED"
#  endif
#  ifdef NO_TAINT_SUPPORT
			     " NO_TAINT_SUPPORT"
#  endif
#  ifdef PERL_BOOL_AS_CHAR
			     " PERL_BOOL_AS_CHAR"
#  endif
#  ifdef PERL_COPY_ON_WRITE
			     " PERL_COPY_ON_WRITE"
#  endif
#  ifdef PERL_DISABLE_PMC
			     " PERL_DISABLE_PMC"
#  endif
#  ifdef PERL_DONT_CREATE_GVSV
			     " PERL_DONT_CREATE_GVSV"
#  endif
#  ifdef PERL_EXTERNAL_GLOB
			     " PERL_EXTERNAL_GLOB"
#  endif
#  ifdef PERL_HASH_FUNC_SIPHASH
			     " PERL_HASH_FUNC_SIPHASH"
#  endif
#  ifdef PERL_HASH_FUNC_SDBM
			     " PERL_HASH_FUNC_SDBM"
#  endif
#  ifdef PERL_HASH_FUNC_DJB2
			     " PERL_HASH_FUNC_DJB2"
#  endif
#  ifdef PERL_HASH_FUNC_SUPERFAST
			     " PERL_HASH_FUNC_SUPERFAST"
#  endif
#  ifdef PERL_HASH_FUNC_MURMUR3
			     " PERL_HASH_FUNC_MURMUR3"
#  endif
#  ifdef PERL_HASH_FUNC_ONE_AT_A_TIME
			     " PERL_HASH_FUNC_ONE_AT_A_TIME"
#  endif
#  ifdef PERL_HASH_FUNC_ONE_AT_A_TIME_HARD
			     " PERL_HASH_FUNC_ONE_AT_A_TIME_HARD"
#  endif
#  ifdef PERL_HASH_FUNC_ONE_AT_A_TIME_OLD
			     " PERL_HASH_FUNC_ONE_AT_A_TIME_OLD"
#  endif
#  ifdef PERL_IS_MINIPERL
			     " PERL_IS_MINIPERL"
#  endif
#  ifdef PERL_MALLOC_WRAP
			     " PERL_MALLOC_WRAP"
#  endif
#  ifdef PERL_MEM_LOG
			     " PERL_MEM_LOG"
#  endif
#  ifdef PERL_MEM_LOG_NOIMPL
			     " PERL_MEM_LOG_NOIMPL"
#  endif
#  ifdef PERL_PERTURB_KEYS_DETERMINISTIC
			     " PERL_PERTURB_KEYS_DETERMINISTIC"
#  endif
#  ifdef PERL_PERTURB_KEYS_DISABLED
			     " PERL_PERTURB_KEYS_DISABLED"
#  endif
#  ifdef PERL_PERTURB_KEYS_RANDOM
			     " PERL_PERTURB_KEYS_RANDOM"
#  endif
#  ifdef PERL_PRESERVE_IVUV
			     " PERL_PRESERVE_IVUV"
#  endif
#  ifdef PERL_RELOCATABLE_INCPUSH
			     " PERL_RELOCATABLE_INCPUSH"
#  endif
#  ifdef PERL_USE_DEVEL
			     " PERL_USE_DEVEL"
#  endif
#  ifdef PERL_USE_SAFE_PUTENV
			     " PERL_USE_SAFE_PUTENV"
#  endif
#  ifdef SILENT_NO_TAINT_SUPPORT
                             " SILENT_NO_TAINT_SUPPORT"
#  endif
#  ifdef UNLINK_ALL_VERSIONS
			     " UNLINK_ALL_VERSIONS"
#  endif
#  ifdef USE_ATTRIBUTES_FOR_PERLIO
			     " USE_ATTRIBUTES_FOR_PERLIO"
#  endif
#  ifdef USE_FAST_STDIO
			     " USE_FAST_STDIO"
#  endif	       
#  ifdef USE_HASH_SEED_EXPLICIT
			     " USE_HASH_SEED_EXPLICIT"
#  endif
#  ifdef USE_LOCALE
			     " USE_LOCALE"
#  endif
#  ifdef USE_LOCALE_CTYPE
			     " USE_LOCALE_CTYPE"
#  endif
#  ifdef WIN32_NO_REGISTRY
			     " USE_NO_REGISTRY"
#  endif
#  ifdef USE_PERL_ATOF
			     " USE_PERL_ATOF"
#  endif	       
#  ifdef USE_SITECUSTOMIZE
			     " USE_SITECUSTOMIZE"
#  endif	       
	;
    PERL_UNUSED_ARG(cv);
    PERL_UNUSED_VAR(items);

    EXTEND(SP, entries);

    PUSHs(sv_2mortal(newSVpv(PL_bincompat_options, 0)));
    PUSHs(Perl_newSVpvn_flags(aTHX_ non_bincompat_options,
			      sizeof(non_bincompat_options) - 1, SVs_TEMP));

#ifndef PERL_BUILD_DATE
#  ifdef __DATE__
#    ifdef __TIME__
#      define PERL_BUILD_DATE __DATE__ " " __TIME__
#    else
#      define PERL_BUILD_DATE __DATE__
#    endif
#  endif
#endif

#undef PERL_BUILD_DATE

#ifdef PERL_BUILD_DATE
    PUSHs(Perl_newSVpvn_flags(aTHX_
			      STR_WITH_LEN("Compiled at " PERL_BUILD_DATE),
			      SVs_TEMP));
#else
    PUSHs(&PL_sv_undef);
#endif

    for (i = 1; i <= local_patch_count; i++) {
	/* This will be an undef, if PL_localpatches[i] is NULL.  */
	PUSHs(sv_2mortal(newSVpv(PL_localpatches[i], 0)));
    }

    XSRETURN(entries);
}

#define INCPUSH_UNSHIFT			0x01
#define INCPUSH_ADD_OLD_VERS		0x02
#define INCPUSH_ADD_VERSIONED_SUB_DIRS	0x04
#define INCPUSH_ADD_ARCHONLY_SUB_DIRS	0x08
#define INCPUSH_NOT_BASEDIR		0x10
#define INCPUSH_CAN_RELOCATE		0x20
#define INCPUSH_ADD_SUB_DIRS	\
    (INCPUSH_ADD_VERSIONED_SUB_DIRS|INCPUSH_ADD_ARCHONLY_SUB_DIRS)

STATIC void *
S_parse_body(pTHX_ char **env, XSINIT_t xsinit)
{
    dVAR;
    PerlIO *rsfp;
    int argc = PL_origargc;
    char **argv = PL_origargv;
    const char *scriptname = NULL;
    bool dosearch = FALSE;
    char c;
    bool doextract = FALSE;
    const char *cddir = NULL;
#ifdef USE_SITECUSTOMIZE
    bool minus_f = FALSE;
#endif
    SV *linestr_sv = NULL;
    bool add_read_e_script = FALSE;
    U32 lex_start_flags = 0;

    PERL_SET_PHASE(PERL_PHASE_START);

    init_main_stash();

    {
	const char *s;
    for (argc--,argv++; argc > 0; argc--,argv++) {
	if (argv[0][0] != '-' || !argv[0][1])
	    break;
	s = argv[0]+1;
      reswitch:
	switch ((c = *s)) {
	case 'C':
#ifndef PERL_STRICT_CR
	case '\r':
#endif
	case ' ':
	case '0':
	case 'F':
	case 'a':
	case 'c':
	case 'd':
	case 'D':
	case 'h':
	case 'i':
	case 'l':
	case 'M':
	case 'm':
	case 'n':
	case 'p':
	case 's':
	case 'u':
	case 'U':
	case 'v':
	case 'W':
	case 'X':
	case 'w':
	    if ((s = moreswitches(s)))
		goto reswitch;
	    break;

	case 't':
#if defined(SILENT_NO_TAINT_SUPPORT)
            /* silently ignore */
#elif defined(NO_TAINT_SUPPORT)
            Perl_croak_nocontext("This perl was compiled without taint support. "
                       "Cowardly refusing to run with -t or -T flags");
#else
	    CHECK_MALLOC_TOO_LATE_FOR('t');
	    if( !TAINTING_get ) {
	         TAINT_WARN_set(TRUE);
	         TAINTING_set(TRUE);
	    }
#endif
	    s++;
	    goto reswitch;
	case 'T':
#if defined(SILENT_NO_TAINT_SUPPORT)
            /* silently ignore */
#elif defined(NO_TAINT_SUPPORT)
            Perl_croak_nocontext("This perl was compiled without taint support. "
                       "Cowardly refusing to run with -t or -T flags");
#else
	    CHECK_MALLOC_TOO_LATE_FOR('T');
	    TAINTING_set(TRUE);
	    TAINT_WARN_set(FALSE);
#endif
	    s++;
	    goto reswitch;

	case 'E':
	    PL_minus_E = TRUE;
	    /* FALLTHROUGH */
	case 'e':
	    forbid_setid('e', FALSE);
	    if (!PL_e_script) {
		PL_e_script = newSVpvs("");
		add_read_e_script = TRUE;
	    }
	    if (*++s)
		sv_catpv(PL_e_script, s);
	    else if (argv[1]) {
		sv_catpv(PL_e_script, argv[1]);
		argc--,argv++;
	    }
	    else
		Perl_croak(aTHX_ "No code specified for -%c", c);
	    sv_catpvs(PL_e_script, "\n");
	    break;

	case 'f':
#ifdef USE_SITECUSTOMIZE
	    minus_f = TRUE;
#endif
	    s++;
	    goto reswitch;

	case 'I':	/* -I handled both here and in moreswitches() */
	    forbid_setid('I', FALSE);
	    if (!*++s && (s=argv[1]) != NULL) {
		argc--,argv++;
	    }
	    if (s && *s) {
		STRLEN len = strlen(s);
		incpush(s, len, INCPUSH_ADD_SUB_DIRS|INCPUSH_ADD_OLD_VERS);
	    }
	    else
		Perl_croak(aTHX_ "No directory specified for -I");
	    break;
	case 'S':
	    forbid_setid('S', FALSE);
	    dosearch = TRUE;
	    s++;
	    goto reswitch;
	case 'V':
	    {
		SV *opts_prog;

		if (*++s != ':')  {
		    opts_prog = newSVpvs("use Config; Config::_V()");
		}
		else {
		    ++s;
		    opts_prog = Perl_newSVpvf(aTHX_
					      "use Config; Config::config_vars(qw%c%s%c)",
					      0, s, 0);
		    s += strlen(s);
		}
		Perl_av_create_and_push(aTHX_ &PL_preambleav, opts_prog);
		/* don't look for script or read stdin */
		scriptname = BIT_BUCKET;
		goto reswitch;
	    }
	case 'x':
	    doextract = TRUE;
	    s++;
	    if (*s)
		cddir = s;
	    break;
	case 0:
	    break;
	case '-':
	    if (!*++s || isSPACE(*s)) {
		argc--,argv++;
		goto switch_end;
	    }
	    /* catch use of gnu style long options.
	       Both of these exit immediately.  */
	    if (strEQ(s, "version"))
		minus_v();
	    if (strEQ(s, "help"))
		usage();
	    s--;
	    /* FALLTHROUGH */
	default:
	    Perl_croak(aTHX_ "Unrecognized switch: -%s  (-h will show valid options)",s);
	}
    }
    }

  switch_end:

    {
	char *s;

    if (
#ifndef SECURE_INTERNAL_GETENV
        !TAINTING_get &&
#endif
	(s = PerlEnv_getenv("PERL5OPT")))
    {
        /* s points to static memory in getenv(), which may be overwritten at
         * any time; use a mortal copy instead */
	s = SvPVX(sv_2mortal(newSVpv(s, 0)));

	while (isSPACE(*s))
	    s++;
	if (*s == '-' && *(s+1) == 'T') {
#if defined(SILENT_NO_TAINT_SUPPORT)
            /* silently ignore */
#elif defined(NO_TAINT_SUPPORT)
            Perl_croak_nocontext("This perl was compiled without taint support. "
                       "Cowardly refusing to run with -t or -T flags");
#else
	    CHECK_MALLOC_TOO_LATE_FOR('T');
	    TAINTING_set(TRUE);
            TAINT_WARN_set(FALSE);
#endif
	}
	else {
	    char *popt_copy = NULL;
	    while (s && *s) {
	        const char *d;
		while (isSPACE(*s))
		    s++;
		if (*s == '-') {
		    s++;
		    if (isSPACE(*s))
			continue;
		}
		d = s;
		if (!*s)
		    break;
		if (!strchr("CDIMUdmtwW", *s))
		    Perl_croak(aTHX_ "Illegal switch in PERL5OPT: -%c", *s);
		while (++s && *s) {
		    if (isSPACE(*s)) {
			if (!popt_copy) {
			    popt_copy = SvPVX(sv_2mortal(newSVpv(d,0)));
			    s = popt_copy + (s - d);
			    d = popt_copy;
			}
		        *s++ = '\0';
			break;
		    }
		}
		if (*d == 't') {
#if defined(SILENT_NO_TAINT_SUPPORT)
            /* silently ignore */
#elif defined(NO_TAINT_SUPPORT)
                    Perl_croak_nocontext("This perl was compiled without taint support. "
                               "Cowardly refusing to run with -t or -T flags");
#else
		    if( !TAINTING_get) {
		        TAINT_WARN_set(TRUE);
		        TAINTING_set(TRUE);
		    }
#endif
		} else {
		    moreswitches(d);
		}
	    }
	}
    }
    }

    /* Set $^X early so that it can be used for relocatable paths in @@INC  */
    /* and for SITELIB_EXP in USE_SITECUSTOMIZE                            */
    assert (!TAINT_get);
    TAINT;
    set_caret_X();
    TAINT_NOT;

#if defined(USE_SITECUSTOMIZE)
    if (!minus_f) {
	/* The games with local $! are to avoid setting errno if there is no
	   sitecustomize script.  "q%c...%c", 0, ..., 0 becomes "q\0...\0",
	   ie a q() operator with a NUL byte as a the delimiter. This avoids
	   problems with pathnames containing (say) '  */
#  ifdef PERL_IS_MINIPERL
	AV *const inc = GvAV(PL_incgv);
	SV **const inc0 = inc ? av_fetch(inc, 0, FALSE) : NULL;

	if (inc0) {
            /* if lib/buildcustomize.pl exists, it should not fail. If it does,
               it should be reported immediately as a build failure.  */
	    (void)Perl_av_create_and_unshift_one(aTHX_ &PL_preambleav,
						 Perl_newSVpvf(aTHX_
		"BEGIN { my $f = q%c%s%"SVf"/buildcustomize.pl%c; "
			"do {local $!; -f $f }"
			" and do $f || die $@@ || qq '$f: $!' }",
                                0, (TAINTING_get ? "./" : ""), SVfARG(*inc0), 0));
	}
#  else
	/* SITELIB_EXP is a function call on Win32.  */
	const char *const raw_sitelib = SITELIB_EXP;
	if (raw_sitelib) {
	    /* process .../.. if PERL_RELOCATABLE_INC is defined */
	    SV *sitelib_sv = mayberelocate(raw_sitelib, strlen(raw_sitelib),
					   INCPUSH_CAN_RELOCATE);
	    const char *const sitelib = SvPVX(sitelib_sv);
	    (void)Perl_av_create_and_unshift_one(aTHX_ &PL_preambleav,
						 Perl_newSVpvf(aTHX_
							       "BEGIN { do {local $!; -f q%c%s/sitecustomize.pl%c} && do q%c%s/sitecustomize.pl%c }",
							       0, SVfARG(sitelib), 0,
							       0, SVfARG(sitelib), 0));
	    assert (SvREFCNT(sitelib_sv) == 1);
	    SvREFCNT_dec(sitelib_sv);
	}
#  endif
    }
#endif

    if (!scriptname)
	scriptname = argv[0];
    if (PL_e_script) {
	argc++,argv--;
	scriptname = BIT_BUCKET;	/* don't look for script or read stdin */
    }
    else if (scriptname == NULL) {
#ifdef MSDOS
	if ( PerlLIO_isatty(PerlIO_fileno(PerlIO_stdin())) )
	    moreswitches("h");
#endif
	scriptname = "-";
    }

    assert (!TAINT_get);
    init_perllib();

    {
	bool suidscript = FALSE;

	rsfp = open_script(scriptname, dosearch, &suidscript);
	if (!rsfp) {
	    rsfp = PerlIO_stdin();
	    lex_start_flags = LEX_DONT_CLOSE_RSFP;
	}

	validate_suid(rsfp);

#ifndef PERL_MICRO
#  if defined(SIGCHLD) || defined(SIGCLD)
	{
#  ifndef SIGCHLD
#    define SIGCHLD SIGCLD
#  endif
	    Sighandler_t sigstate = rsignal_state(SIGCHLD);
	    if (sigstate == (Sighandler_t) SIG_IGN) {
		Perl_ck_warner(aTHX_ packWARN(WARN_SIGNAL),
			       "Can't ignore signal CHLD, forcing to default");
		(void)rsignal(SIGCHLD, (Sighandler_t)SIG_DFL);
	    }
	}
#  endif
#endif

	if (doextract) {

	    /* This will croak if suidscript is true, as -x cannot be used with
	       setuid scripts.  */
	    forbid_setid('x', suidscript);
	    /* Hence you can't get here if suidscript is true */

	    linestr_sv = newSV_type(SVt_PV);
	    lex_start_flags |= LEX_START_COPIED;
	    find_beginning(linestr_sv, rsfp);
	    if (cddir && PerlDir_chdir( (char *)cddir ) < 0)
		Perl_croak(aTHX_ "Can't chdir to %s",cddir);
	}
    }

    PL_main_cv = PL_compcv = MUTABLE_CV(newSV_type(SVt_PVCV));
    CvUNIQUE_on(PL_compcv);

    CvPADLIST_set(PL_compcv, pad_new(0));

    PL_isarev = newHV();

    boot_core_PerlIO();
    boot_core_UNIVERSAL();
    boot_core_mro();
    newXS("Internals::V", S_Internals_V, __FILE__);

    if (xsinit)
	(*xsinit)(aTHX);	/* in case linked C routines want magical variables */
#ifndef PERL_MICRO
#if defined(VMS) || defined(WIN32) || defined(DJGPP) || defined(__CYGWIN__) || defined(SYMBIAN)
    init_os_extras();
#endif
#endif

#ifdef USE_SOCKS
#   ifdef HAS_SOCKS5_INIT
    socks5_init(argv[0]);
#   else
    SOCKSinit(argv[0]);
#   endif
#endif

    init_predump_symbols();
    /* init_postdump_symbols not currently designed to be called */
    /* more than once (ENV isn't cleared first, for example)	 */
    /* But running with -u leaves %ENV & @@ARGV undefined!    XXX */
    if (!PL_do_undump)
	init_postdump_symbols(argc,argv,env);

    /* PL_unicode is turned on by -C, or by $ENV{PERL_UNICODE},
     * or explicitly in some platforms.
     * locale.c:Perl_init_i18nl10n() if the environment
     * look like the user wants to use UTF-8. */
#if defined(__SYMBIAN32__)
    PL_unicode = PERL_UNICODE_STD_FLAG; /* See PERL_SYMBIAN_CONSOLE_UTF8. */
#endif
#  ifndef PERL_IS_MINIPERL
    if (PL_unicode) {
	 /* Requires init_predump_symbols(). */
	 if (!(PL_unicode & PERL_UNICODE_LOCALE_FLAG) || PL_utf8locale) {
	      IO* io;
	      PerlIO* fp;
	      SV* sv;

	      /* Turn on UTF-8-ness on STDIN, STDOUT, STDERR
	       * and the default open disciplines. */
	      if ((PL_unicode & PERL_UNICODE_STDIN_FLAG) &&
		  PL_stdingv  && (io = GvIO(PL_stdingv)) &&
		  (fp = IoIFP(io)))
		   PerlIO_binmode(aTHX_ fp, IoTYPE(io), 0, ":utf8");
	      if ((PL_unicode & PERL_UNICODE_STDOUT_FLAG) &&
		  PL_defoutgv && (io = GvIO(PL_defoutgv)) &&
		  (fp = IoOFP(io)))
		   PerlIO_binmode(aTHX_ fp, IoTYPE(io), 0, ":utf8");
	      if ((PL_unicode & PERL_UNICODE_STDERR_FLAG) &&
		  PL_stderrgv && (io = GvIO(PL_stderrgv)) &&
		  (fp = IoOFP(io)))
		   PerlIO_binmode(aTHX_ fp, IoTYPE(io), 0, ":utf8");
	      if ((PL_unicode & PERL_UNICODE_INOUT_FLAG) &&
		  (sv = GvSV(gv_fetchpvs("\017PEN", GV_ADD|GV_NOTQUAL,
					 SVt_PV)))) {
		   U32 in  = PL_unicode & PERL_UNICODE_IN_FLAG;
		   U32 out = PL_unicode & PERL_UNICODE_OUT_FLAG;
		   if (in) {
			if (out)
			     sv_setpvs(sv, ":utf8\0:utf8");
			else
			     sv_setpvs(sv, ":utf8\0");
		   }
		   else if (out)
			sv_setpvs(sv, "\0:utf8");
		   SvSETMAGIC(sv);
	      }
	 }
    }
#endif

    {
	const char *s;
    if ((s = PerlEnv_getenv("PERL_SIGNALS"))) {
	 if (strEQ(s, "unsafe"))
	      PL_signals |=  PERL_SIGNALS_UNSAFE_FLAG;
	 else if (strEQ(s, "safe"))
	      PL_signals &= ~PERL_SIGNALS_UNSAFE_FLAG;
	 else
	      Perl_croak(aTHX_ "PERL_SIGNALS illegal: \"%s\"", s);
    }
    }


    lex_start(linestr_sv, rsfp, lex_start_flags);
    SvREFCNT_dec(linestr_sv);

    PL_subname = newSVpvs("main");

    if (add_read_e_script)
	filter_add(read_e_script, NULL);

    /* now parse the script */

    SETERRNO(0,SS_NORMAL);
    if (yyparse(GRAMPROG) || PL_parser->error_count) {
	if (PL_minus_c)
	    Perl_croak(aTHX_ "%s had compilation errors.\n", PL_origfilename);
	else {
	    Perl_croak(aTHX_ "Execution of %s aborted due to compilation errors.\n",
		       PL_origfilename);
	}
    }
    CopLINE_set(PL_curcop, 0);
    SET_CURSTASH(PL_defstash);
    if (PL_e_script) {
	SvREFCNT_dec(PL_e_script);
	PL_e_script = NULL;
    }

    if (PL_do_undump)
	my_unexec();

    if (isWARN_ONCE) {
	SAVECOPFILE(PL_curcop);
	SAVECOPLINE(PL_curcop);
	gv_check(PL_defstash);
    }

    LEAVE;
    FREETMPS;

#ifdef MYMALLOC
    {
	const char *s;
        UV uv;
        s = PerlEnv_getenv("PERL_DEBUG_MSTATS");
        if (s && grok_atoUV(s, &uv, NULL) && uv >= 2)
            dump_mstats("after compilation:");
    }
#endif

    ENTER;
    PL_restartjmpenv = NULL;
    PL_restartop = 0;
    return NULL;
}

/*
=for apidoc perl_run

Tells a Perl interpreter to run.  See L<perlembed>.

=cut
*/

int
perl_run(pTHXx)
{
    I32 oldscope;
    int ret = 0;
    dJMPENV;

    PERL_ARGS_ASSERT_PERL_RUN;
#ifndef MULTIPLICITY
    PERL_UNUSED_ARG(my_perl);
#endif

    oldscope = PL_scopestack_ix;
#ifdef VMS
    VMSISH_HUSHED = 0;
#endif

    JMPENV_PUSH(ret);
    switch (ret) {
    case 1:
	cxstack_ix = -1;		/* start context stack again */
	goto redo_body;
    case 0:				/* normal completion */
 redo_body:
	run_body(oldscope);
	/* FALLTHROUGH */
    case 2:				/* my_exit() */
	while (PL_scopestack_ix > oldscope)
	    LEAVE;
	FREETMPS;
	SET_CURSTASH(PL_defstash);
	if (!(PL_exit_flags & PERL_EXIT_DESTRUCT_END) &&
	    PL_endav && !PL_minus_c) {
	    PERL_SET_PHASE(PERL_PHASE_END);
	    call_list(oldscope, PL_endav);
	}
#ifdef MYMALLOC
	if (PerlEnv_getenv("PERL_DEBUG_MSTATS"))
	    dump_mstats("after execution:  ");
#endif
	ret = STATUS_EXIT;
	break;
    case 3:
	if (PL_restartop) {
	    POPSTACK_TO(PL_mainstack);
	    goto redo_body;
	}
	PerlIO_printf(Perl_error_log, "panic: restartop in perl_run\n");
	FREETMPS;
	ret = 1;
	break;
    }

    JMPENV_POP;
    return ret;
}

STATIC void
S_run_body(pTHX_ I32 oldscope)
{
    DEBUG_r(PerlIO_printf(Perl_debug_log, "%s $` $& $' support (0x%x).\n",
                    PL_sawampersand ? "Enabling" : "Omitting",
                    (unsigned int)(PL_sawampersand)));

    if (!PL_restartop) {
#ifdef DEBUGGING
	if (DEBUG_x_TEST || DEBUG_B_TEST)
	    dump_all_perl(!DEBUG_B_TEST);
	if (!DEBUG_q_TEST)
	  PERL_DEBUG(PerlIO_printf(Perl_debug_log, "\nEXECUTING...\n\n"));
#endif

	if (PL_minus_c) {
	    PerlIO_printf(Perl_error_log, "%s syntax OK\n", PL_origfilename);
	    my_exit(0);
	}
	if (PERLDB_SINGLE && PL_DBsingle)
            PL_DBsingle_iv = 1;
	if (PL_initav) {
	    PERL_SET_PHASE(PERL_PHASE_INIT);
	    call_list(oldscope, PL_initav);
	}
#ifdef PERL_DEBUG_READONLY_OPS
	if (PL_main_root && PL_main_root->op_slabbed)
	    Slab_to_ro(OpSLAB(PL_main_root));
#endif
    }

    /* do it */

    PERL_SET_PHASE(PERL_PHASE_RUN);

    if (PL_restartop) {
	PL_restartjmpenv = NULL;
	PL_op = PL_restartop;
	PL_restartop = 0;
	CALLRUNOPS(aTHX);
    }
    else if (PL_main_start) {
	CvDEPTH(PL_main_cv) = 1;
	PL_op = PL_main_start;
	CALLRUNOPS(aTHX);
    }
    my_exit(0);
    NOT_REACHED; /* NOTREACHED */
}

/*
=head1 SV Manipulation Functions

=for apidoc p||get_sv

Returns the SV of the specified Perl scalar.  C<flags> are passed to
C<gv_fetchpv>.  If C<GV_ADD> is set and the
Perl variable does not exist then it will be created.  If C<flags> is zero
and the variable does not exist then NULL is returned.

=cut
*/

SV*
Perl_get_sv(pTHX_ const char *name, I32 flags)
{
    GV *gv;

    PERL_ARGS_ASSERT_GET_SV;

    gv = gv_fetchpv(name, flags, SVt_PV);
    if (gv)
	return GvSV(gv);
    return NULL;
}

/*
=head1 Array Manipulation Functions

=for apidoc p||get_av

Returns the AV of the specified Perl global or package array with the given
name (so it won't work on lexical variables).  C<flags> are passed 
to C<gv_fetchpv>.  If C<GV_ADD> is set and the
Perl variable does not exist then it will be created.  If C<flags> is zero
and the variable does not exist then NULL is returned.

Perl equivalent: C<@@{"$name"}>.

=cut
*/

AV*
Perl_get_av(pTHX_ const char *name, I32 flags)
{
    GV* const gv = gv_fetchpv(name, flags, SVt_PVAV);

    PERL_ARGS_ASSERT_GET_AV;

    if (flags)
    	return GvAVn(gv);
    if (gv)
	return GvAV(gv);
    return NULL;
}

/*
=head1 Hash Manipulation Functions

=for apidoc p||get_hv

Returns the HV of the specified Perl hash.  C<flags> are passed to
C<gv_fetchpv>.  If C<GV_ADD> is set and the
Perl variable does not exist then it will be created.  If C<flags> is zero
and the variable does not exist then C<NULL> is returned.

=cut
*/

HV*
Perl_get_hv(pTHX_ const char *name, I32 flags)
{
    GV* const gv = gv_fetchpv(name, flags, SVt_PVHV);

    PERL_ARGS_ASSERT_GET_HV;

    if (flags)
    	return GvHVn(gv);
    if (gv)
	return GvHV(gv);
    return NULL;
}

/*
=head1 CV Manipulation Functions

=for apidoc p||get_cvn_flags

Returns the CV of the specified Perl subroutine.  C<flags> are passed to
C<gv_fetchpvn_flags>.  If C<GV_ADD> is set and the Perl subroutine does not
exist then it will be declared (which has the same effect as saying
C<sub name;>).  If C<GV_ADD> is not set and the subroutine does not exist
then NULL is returned.

=for apidoc p||get_cv

Uses C<strlen> to get the length of C<name>, then calls C<get_cvn_flags>.

=cut
*/

CV*
Perl_get_cvn_flags(pTHX_ const char *name, STRLEN len, I32 flags)
{
    GV* const gv = gv_fetchpvn_flags(name, len, flags, SVt_PVCV);

    PERL_ARGS_ASSERT_GET_CVN_FLAGS;

    /* XXX this is probably not what they think they're getting.
     * It has the same effect as "sub name;", i.e. just a forward
     * declaration! */
    if ((flags & ~GV_NOADD_MASK) && !GvCVu(gv)) {
    	return newSTUB(gv,0);
    }
    if (gv)
	return GvCVu(gv);
    return NULL;
}

/* Nothing in core calls this now, but we can't replace it with a macro and
   move it to mathoms.c as a macro would evaluate name twice.  */
CV*
Perl_get_cv(pTHX_ const char *name, I32 flags)
{
    PERL_ARGS_ASSERT_GET_CV;

    return get_cvn_flags(name, strlen(name), flags);
}

/* Be sure to refetch the stack pointer after calling these routines. */

/*

=head1 Callback Functions

=for apidoc p||call_argv

Performs a callback to the specified named and package-scoped Perl subroutine 
with C<argv> (a C<NULL>-terminated array of strings) as arguments.  See
L<perlcall>.

Approximate Perl equivalent: C<&{"$sub_name"}(@@$argv)>.

=cut
*/

I32
Perl_call_argv(pTHX_ const char *sub_name, I32 flags, char **argv)

          		/* See G_* flags in cop.h */
                     	/* null terminated arg list */
{
    dSP;

    PERL_ARGS_ASSERT_CALL_ARGV;

    PUSHMARK(SP);
    while (*argv) {
        mXPUSHs(newSVpv(*argv,0));
        argv++;
    }
    PUTBACK;
    return call_pv(sub_name, flags);
}

/*
=for apidoc p||call_pv

Performs a callback to the specified Perl sub.  See L<perlcall>.

=cut
*/

I32
Perl_call_pv(pTHX_ const char *sub_name, I32 flags)
              		/* name of the subroutine */
          		/* See G_* flags in cop.h */
{
    PERL_ARGS_ASSERT_CALL_PV;

    return call_sv(MUTABLE_SV(get_cv(sub_name, GV_ADD)), flags);
}

/*
=for apidoc p||call_method

Performs a callback to the specified Perl method.  The blessed object must
be on the stack.  See L<perlcall>.

=cut
*/

I32
Perl_call_method(pTHX_ const char *methname, I32 flags)
               		/* name of the subroutine */
          		/* See G_* flags in cop.h */
{
    STRLEN len;
    SV* sv;
    PERL_ARGS_ASSERT_CALL_METHOD;

    len = strlen(methname);
    sv = flags & G_METHOD_NAMED
        ? sv_2mortal(newSVpvn_share(methname, len,0))
        : newSVpvn_flags(methname, len, SVs_TEMP);

    return call_sv(sv, flags | G_METHOD);
}

/* May be called with any of a CV, a GV, or an SV containing the name. */
/*
=for apidoc p||call_sv

Performs a callback to the Perl sub specified by the SV.

If neither the C<G_METHOD> nor C<G_METHOD_NAMED> flag is supplied, the
SV may be any of a CV, a GV, a reference to a CV, a reference to a GV
or C<SvPV(sv)> will be used as the name of the sub to call.

If the C<G_METHOD> flag is supplied, the SV may be a reference to a CV or
C<SvPV(sv)> will be used as the name of the method to call.

If the C<G_METHOD_NAMED> flag is supplied, C<SvPV(sv)> will be used as
the name of the method to call.

Some other values are treated specially for internal use and should
not be depended on.

See L<perlcall>.

=cut
*/

I32
Perl_call_sv(pTHX_ SV *sv, VOL I32 flags)
          		/* See G_* flags in cop.h */
{
    dVAR;
    LOGOP myop;		/* fake syntax tree node */
    METHOP method_op;
    I32 oldmark;
    VOL I32 retval = 0;
    bool oldcatch = CATCH_GET;
    int ret;
    OP* const oldop = PL_op;
    dJMPENV;

    PERL_ARGS_ASSERT_CALL_SV;

    if (flags & G_DISCARD) {
	ENTER;
	SAVETMPS;
    }
    if (!(flags & G_WANT)) {
	/* Backwards compatibility - as G_SCALAR was 0, it could be omitted.
	 */
	flags |= G_SCALAR;
    }

    Zero(&myop, 1, LOGOP);
    if (!(flags & G_NOARGS))
	myop.op_flags |= OPf_STACKED;
    myop.op_flags |= OP_GIMME_REVERSE(flags);
    SAVEOP();
    PL_op = (OP*)&myop;

    if (!(flags & G_METHOD_NAMED)) {
	dSP;
	EXTEND(SP, 1);
	PUSHs(sv);
	PUTBACK;
    }
    oldmark = TOPMARK;

    if (PERLDB_SUB && PL_curstash != PL_debstash
	   /* Handle first BEGIN of -d. */
	  && (PL_DBcv || (PL_DBcv = GvCV(PL_DBsub)))
	   /* Try harder, since this may have been a sighandler, thus
	    * curstash may be meaningless. */
	  && (SvTYPE(sv) != SVt_PVCV || CvSTASH((const CV *)sv) != PL_debstash)
	  && !(flags & G_NODEBUG))
	myop.op_private |= OPpENTERSUB_DB;

    if (flags & (G_METHOD|G_METHOD_NAMED)) {
        Zero(&method_op, 1, METHOP);
        method_op.op_next = (OP*)&myop;
        PL_op = (OP*)&method_op;
        if ( flags & G_METHOD_NAMED ) {
            method_op.op_ppaddr = PL_ppaddr[OP_METHOD_NAMED];
            method_op.op_type = OP_METHOD_NAMED;
            method_op.op_u.op_meth_sv = sv;
        } else {
            method_op.op_ppaddr = PL_ppaddr[OP_METHOD];
            method_op.op_type = OP_METHOD;
        }
        myop.op_ppaddr = PL_ppaddr[OP_ENTERSUB];
        myop.op_type = OP_ENTERSUB;
    }

    if (!(flags & G_EVAL)) {
	CATCH_SET(TRUE);
	CALL_BODY_SUB((OP*)&myop);
	retval = PL_stack_sp - (PL_stack_base + oldmark);
	CATCH_SET(oldcatch);
    }
    else {
        I32 old_cxix;
	myop.op_other = (OP*)&myop;
	(void)POPMARK;
        old_cxix = cxstack_ix;
	create_eval_scope(NULL, flags|G_FAKINGEVAL);
	(void)INCMARK;

	JMPENV_PUSH(ret);

	switch (ret) {
	case 0:
 redo_body:
	    CALL_BODY_SUB((OP*)&myop);
	    retval = PL_stack_sp - (PL_stack_base + oldmark);
	    if (!(flags & G_KEEPERR)) {
		CLEAR_ERRSV();
	    }
	    break;
	case 1:
	    STATUS_ALL_FAILURE;
	    /* FALLTHROUGH */
	case 2:
	    /* my_exit() was called */
	    SET_CURSTASH(PL_defstash);
	    FREETMPS;
	    JMPENV_POP;
	    my_exit_jump();
	    NOT_REACHED; /* NOTREACHED */
	case 3:
	    if (PL_restartop) {
		PL_restartjmpenv = NULL;
		PL_op = PL_restartop;
		PL_restartop = 0;
		goto redo_body;
	    }
	    PL_stack_sp = PL_stack_base + oldmark;
	    if ((flags & G_WANT) == G_ARRAY)
		retval = 0;
	    else {
		retval = 1;
		*++PL_stack_sp = &PL_sv_undef;
	    }
	    break;
	}

        /* if we croaked, depending on how we croaked the eval scope
         * may or may not have already been popped */
	if (cxstack_ix > old_cxix) {
            assert(cxstack_ix == old_cxix + 1);
            assert(CxTYPE(CX_CUR()) == CXt_EVAL);
	    delete_eval_scope();
        }
	JMPENV_POP;
    }

    if (flags & G_DISCARD) {
	PL_stack_sp = PL_stack_base + oldmark;
	retval = 0;
	FREETMPS;
	LEAVE;
    }
    PL_op = oldop;
    return retval;
}

/* Eval a string. The G_EVAL flag is always assumed. */

/*
=for apidoc p||eval_sv

Tells Perl to C<eval> the string in the SV.  It supports the same flags
as C<call_sv>, with the obvious exception of C<G_EVAL>.  See L<perlcall>.

=cut
*/

I32
Perl_eval_sv(pTHX_ SV *sv, I32 flags)

          		/* See G_* flags in cop.h */
{
    dVAR;
    UNOP myop;		/* fake syntax tree node */
    VOL I32 oldmark;
    VOL I32 retval = 0;
    int ret;
    OP* const oldop = PL_op;
    dJMPENV;

    PERL_ARGS_ASSERT_EVAL_SV;

    if (flags & G_DISCARD) {
	ENTER;
	SAVETMPS;
    }

    SAVEOP();
    PL_op = (OP*)&myop;
    Zero(&myop, 1, UNOP);
    {
	dSP;
	oldmark = SP - PL_stack_base;
	EXTEND(SP, 1);
	PUSHs(sv);
	PUTBACK;
    }

    if (!(flags & G_NOARGS))
	myop.op_flags = OPf_STACKED;
    myop.op_type = OP_ENTEREVAL;
    myop.op_flags |= OP_GIMME_REVERSE(flags);
    if (flags & G_KEEPERR)
	myop.op_flags |= OPf_SPECIAL;

    if (flags & G_RE_REPARSING)
	myop.op_private = (OPpEVAL_COPHH | OPpEVAL_RE_REPARSING);

    /* fail now; otherwise we could fail after the JMPENV_PUSH but
     * before a cx_pusheval(), which corrupts the stack after a croak */
    TAINT_PROPER("eval_sv()");

    JMPENV_PUSH(ret);
    switch (ret) {
    case 0:
 redo_body:
	if (PL_op == (OP*)(&myop)) {
	    PL_op = PL_ppaddr[OP_ENTEREVAL](aTHX);
	    if (!PL_op)
		goto fail; /* failed in compilation */
	}
	CALLRUNOPS(aTHX);
	retval = PL_stack_sp - (PL_stack_base + oldmark);
	if (!(flags & G_KEEPERR)) {
	    CLEAR_ERRSV();
	}
	break;
    case 1:
	STATUS_ALL_FAILURE;
	/* FALLTHROUGH */
    case 2:
	/* my_exit() was called */
	SET_CURSTASH(PL_defstash);
	FREETMPS;
	JMPENV_POP;
	my_exit_jump();
	NOT_REACHED; /* NOTREACHED */
    case 3:
	if (PL_restartop) {
	    PL_restartjmpenv = NULL;
	    PL_op = PL_restartop;
	    PL_restartop = 0;
	    goto redo_body;
	}
      fail:
	PL_stack_sp = PL_stack_base + oldmark;
	if ((flags & G_WANT) == G_ARRAY)
	    retval = 0;
	else {
	    retval = 1;
	    *++PL_stack_sp = &PL_sv_undef;
	}
	break;
    }

    JMPENV_POP;
    if (flags & G_DISCARD) {
	PL_stack_sp = PL_stack_base + oldmark;
	retval = 0;
	FREETMPS;
	LEAVE;
    }
    PL_op = oldop;
    return retval;
}

/*
=for apidoc p||eval_pv

Tells Perl to C<eval> the given string in scalar context and return an SV* result.

=cut
*/

SV*
Perl_eval_pv(pTHX_ const char *p, I32 croak_on_error)
{
    SV* sv = newSVpv(p, 0);

    PERL_ARGS_ASSERT_EVAL_PV;

    eval_sv(sv, G_SCALAR);
    SvREFCNT_dec(sv);

    {
        dSP;
        sv = POPs;
        PUTBACK;
    }

    /* just check empty string or undef? */
    if (croak_on_error) {
	SV * const errsv = ERRSV;
	if(SvTRUE_NN(errsv))
	    /* replace with croak_sv? */
	    Perl_croak_nocontext("%s", SvPV_nolen_const(errsv));
    }

    return sv;
}

/* Require a module. */

/*
=head1 Embedding Functions

=for apidoc p||require_pv

Tells Perl to C<require> the file named by the string argument.  It is
analogous to the Perl code C<eval "require '$file'">.  It's even
implemented that way; consider using load_module instead.

=cut */

void
Perl_require_pv(pTHX_ const char *pv)
{
    dSP;
    SV* sv;

    PERL_ARGS_ASSERT_REQUIRE_PV;

    PUSHSTACKi(PERLSI_REQUIRE);
    sv = Perl_newSVpvf(aTHX_ "require q%c%s%c", 0, pv, 0);
    eval_sv(sv_2mortal(sv), G_DISCARD);
    POPSTACK;
}

STATIC void
S_usage(pTHX)		/* XXX move this out into a module ? */
{
    /* This message really ought to be max 23 lines.
     * Removed -h because the user already knows that option. Others? */

    /* Grouped as 6 lines per C string literal, to keep under the ANSI C 89
       minimum of 509 character string literals.  */
    static const char * const usage_msg[] = {
"  -0[octal]         specify record separator (\\0, if no argument)\n"
"  -a                autosplit mode with -n or -p (splits $_ into @@F)\n"
"  -C[number/list]   enables the listed Unicode features\n"
"  -c                check syntax only (runs BEGIN and CHECK blocks)\n"
"  -d[:debugger]     run program under debugger\n"
"  -D[number/list]   set debugging flags (argument is a bit mask or alphabets)\n",
"  -e program        one line of program (several -e's allowed, omit programfile)\n"
"  -E program        like -e, but enables all optional features\n"
"  -f                don't do $sitelib/sitecustomize.pl at startup\n"
"  -F/pattern/       split() pattern for -a switch (//'s are optional)\n"
"  -i[extension]     edit <> files in place (makes backup if extension supplied)\n"
"  -Idirectory       specify @@INC/#include directory (several -I's allowed)\n",
"  -l[octal]         enable line ending processing, specifies line terminator\n"
"  -[mM][-]module    execute \"use/no module...\" before executing program\n"
"  -n                assume \"while (<>) { ... }\" loop around program\n"
"  -p                assume loop like -n but print line also, like sed\n"
"  -s                enable rudimentary parsing for switches after programfile\n"
"  -S                look for programfile using PATH environment variable\n",
"  -t                enable tainting warnings\n"
"  -T                enable tainting checks\n"
"  -u                dump core after parsing program\n"
"  -U                allow unsafe operations\n"
"  -v                print version, patchlevel and license\n"
"  -V[:variable]     print configuration summary (or a single Config.pm variable)\n",
"  -w                enable many useful warnings\n"
"  -W                enable all warnings\n"
"  -x[directory]     ignore text before #!perl line (optionally cd to directory)\n"
"  -X                disable all warnings\n"
"  \n"
"Run 'perldoc perl' for more help with Perl.\n\n",
NULL
};
    const char * const *p = usage_msg;
    PerlIO *out = PerlIO_stdout();

    PerlIO_printf(out,
		  "\nUsage: %s [switches] [--] [programfile] [arguments]\n",
		  PL_origargv[0]);
    while (*p)
	PerlIO_puts(out, *p++);
    my_exit(0);
}

/* convert a string of -D options (or digits) into an int.
 * sets *s to point to the char after the options */

#ifdef DEBUGGING
int
Perl_get_debug_opts(pTHX_ const char **s, bool givehelp)
{
    static const char * const usage_msgd[] = {
      " Debugging flag values: (see also -d)\n"
      "  p  Tokenizing and parsing (with v, displays parse stack)\n"
      "  s  Stack snapshots (with v, displays all stacks)\n"
      "  l  Context (loop) stack processing\n"
      "  t  Trace execution\n"
      "  o  Method and overloading resolution\n",
      "  c  String/numeric conversions\n"
      "  P  Print profiling info, source file input state\n"
      "  m  Memory and SV allocation\n"
      "  f  Format processing\n"
      "  r  Regular expression parsing and execution\n"
      "  x  Syntax tree dump\n",
      "  u  Tainting checks\n"
      "  H  Hash dump -- usurps values()\n"
      "  X  Scratchpad allocation\n"
      "  D  Cleaning up\n"
      "  S  Op slab allocation\n"
      "  T  Tokenising\n"
      "  R  Include reference counts of dumped variables (eg when using -Ds)\n",
      "  J  Do not s,t,P-debug (Jump over) opcodes within package DB\n"
      "  v  Verbose: use in conjunction with other flags\n"
      "  C  Copy On Write\n"
      "  A  Consistency checks on internal structures\n"
      "  q  quiet - currently only suppresses the 'EXECUTING' message\n"
      "  M  trace smart match resolution\n"
      "  B  dump suBroutine definitions, including special Blocks like BEGIN\n",
      "  L  trace some locale setting information--for Perl core development\n",
      "  i  trace PerlIO layer processing\n",
      NULL
    };
    UV uv = 0;

    PERL_ARGS_ASSERT_GET_DEBUG_OPTS;

    if (isALPHA(**s)) {
	/* if adding extra options, remember to update DEBUG_MASK */
	static const char debopts[] = "psltocPmfrxuUHXDSTRJvCAqMBLi";

	for (; isWORDCHAR(**s); (*s)++) {
	    const char * const d = strchr(debopts,**s);
	    if (d)
		uv |= 1 << (d - debopts);
	    else if (ckWARN_d(WARN_DEBUGGING))
	        Perl_warner(aTHX_ packWARN(WARN_DEBUGGING),
		    "invalid option -D%c, use -D'' to see choices\n", **s);
	}
    }
    else if (isDIGIT(**s)) {
        const char* e;
	if (grok_atoUV(*s, &uv, &e))
            *s = e;
	for (; isWORDCHAR(**s); (*s)++) ;
    }
    else if (givehelp) {
      const char *const *p = usage_msgd;
      while (*p) PerlIO_puts(PerlIO_stdout(), *p++);
    }
    return (int)uv; /* ignore any UV->int conversion loss */
}
#endif

/* This routine handles any switches that can be given during run */

const char *
Perl_moreswitches(pTHX_ const char *s)
{
    dVAR;
    UV rschar;
    const char option = *s; /* used to remember option in -m/-M code */

    PERL_ARGS_ASSERT_MORESWITCHES;

    switch (*s) {
    case '0':
    {
	 I32 flags = 0;
	 STRLEN numlen;

	 SvREFCNT_dec(PL_rs);
	 if (s[1] == 'x' && s[2]) {
	      const char *e = s+=2;
	      U8 *tmps;

	      while (*e)
		e++;
	      numlen = e - s;
	      flags = PERL_SCAN_SILENT_ILLDIGIT;
	      rschar = (U32)grok_hex(s, &numlen, &flags, NULL);
	      if (s + numlen < e) {
		   rschar = 0; /* Grandfather -0xFOO as -0 -xFOO. */
		   numlen = 0;
		   s--;
	      }
	      PL_rs = newSVpvs("");
	      SvGROW(PL_rs, (STRLEN)(UVCHR_SKIP(rschar) + 1));
	      tmps = (U8*)SvPVX(PL_rs);
	      uvchr_to_utf8(tmps, rschar);
	      SvCUR_set(PL_rs, UVCHR_SKIP(rschar));
	      SvUTF8_on(PL_rs);
	 }
	 else {
	      numlen = 4;
	      rschar = (U32)grok_oct(s, &numlen, &flags, NULL);
	      if (rschar & ~((U8)~0))
		   PL_rs = &PL_sv_undef;
	      else if (!rschar && numlen >= 2)
		   PL_rs = newSVpvs("");
	      else {
		   char ch = (char)rschar;
		   PL_rs = newSVpvn(&ch, 1);
	      }
	 }
	 sv_setsv(get_sv("/", GV_ADD), PL_rs);
	 return s + numlen;
    }
    case 'C':
        s++;
        PL_unicode = parse_unicode_opts( (const char **)&s );
	if (PL_unicode & PERL_UNICODE_UTF8CACHEASSERT_FLAG)
	    PL_utf8cache = -1;
	return s;
    case 'F':
	PL_minus_a = TRUE;
	PL_minus_F = TRUE;
        PL_minus_n = TRUE;
	PL_splitstr = ++s;
	while (*s && !isSPACE(*s)) ++s;
	PL_splitstr = savepvn(PL_splitstr, s - PL_splitstr);
	return s;
    case 'a':
	PL_minus_a = TRUE;
        PL_minus_n = TRUE;
	s++;
	return s;
    case 'c':
	PL_minus_c = TRUE;
	s++;
	return s;
    case 'd':
	forbid_setid('d', FALSE);
	s++;

        /* -dt indicates to the debugger that threads will be used */
	if (*s == 't' && !isWORDCHAR(s[1])) {
	    ++s;
	    my_setenv("PERL5DB_THREADED", "1");
	}

	/* The following permits -d:Mod to accepts arguments following an =
	   in the fashion that -MSome::Mod does. */
	if (*s == ':' || *s == '=') {
	    const char *start;
	    const char *end;
	    SV *sv;

	    if (*++s == '-') {
		++s;
		sv = newSVpvs("no Devel::");
	    } else {
		sv = newSVpvs("use Devel::");
	    }

	    start = s;
	    end = s + strlen(s);

	    /* We now allow -d:Module=Foo,Bar and -d:-Module */
	    while(isWORDCHAR(*s) || *s==':') ++s;
	    if (*s != '=')
		sv_catpvn(sv, start, end - start);
	    else {
		sv_catpvn(sv, start, s-start);
		/* Don't use NUL as q// delimiter here, this string goes in the
		 * environment. */
		Perl_sv_catpvf(aTHX_ sv, " split(/,/,q{%s});", ++s);
	    }
	    s = end;
	    my_setenv("PERL5DB", SvPV_nolen_const(sv));
	    SvREFCNT_dec(sv);
	}
	if (!PL_perldb) {
	    PL_perldb = PERLDB_ALL;
	    init_debugger();
	}
	return s;
    case 'D':
    {	
#ifdef DEBUGGING
	forbid_setid('D', FALSE);
	s++;
	PL_debug = get_debug_opts( (const char **)&s, 1) | DEBUG_TOP_FLAG;
#else /* !DEBUGGING */
	if (ckWARN_d(WARN_DEBUGGING))
	    Perl_warner(aTHX_ packWARN(WARN_DEBUGGING),
	           "Recompile perl with -DDEBUGGING to use -D switch (did you mean -d ?)\n");
	for (s++; isWORDCHAR(*s); s++) ;
#endif
	return s;
        NOT_REACHED; /* NOTREACHED */
    }	
    case 'h':
	usage();
        NOT_REACHED; /* NOTREACHED */

    case 'i':
	Safefree(PL_inplace);
#if defined(__CYGWIN__) /* do backup extension automagically */
	if (*(s+1) == '\0') {
	PL_inplace = savepvs(".bak");
	return s+1;
	}
#endif /* __CYGWIN__ */
	{
	    const char * const start = ++s;
	    while (*s && !isSPACE(*s))
		++s;

	    PL_inplace = savepvn(start, s - start);
	}
	if (*s) {
	    ++s;
	    if (*s == '-')	/* Additional switches on #! line. */
		s++;
	}
	return s;
    case 'I':	/* -I handled both here and in parse_body() */
	forbid_setid('I', FALSE);
	++s;
	while (*s && isSPACE(*s))
	    ++s;
	if (*s) {
	    const char *e, *p;
	    p = s;
	    /* ignore trailing spaces (possibly followed by other switches) */
	    do {
		for (e = p; *e && !isSPACE(*e); e++) ;
		p = e;
		while (isSPACE(*p))
		    p++;
	    } while (*p && *p != '-');
	    incpush(s, e-s,
		    INCPUSH_ADD_SUB_DIRS|INCPUSH_ADD_OLD_VERS|INCPUSH_UNSHIFT);
	    s = p;
	    if (*s == '-')
		s++;
	}
	else
	    Perl_croak(aTHX_ "No directory specified for -I");
	return s;
    case 'l':
	PL_minus_l = TRUE;
	s++;
	if (PL_ors_sv) {
	    SvREFCNT_dec(PL_ors_sv);
	    PL_ors_sv = NULL;
	}
	if (isDIGIT(*s)) {
            I32 flags = 0;
	    STRLEN numlen;
	    PL_ors_sv = newSVpvs("\n");
	    numlen = 3 + (*s == '0');
	    *SvPVX(PL_ors_sv) = (char)grok_oct(s, &numlen, &flags, NULL);
	    s += numlen;
	}
	else {
	    if (RsPARA(PL_rs)) {
		PL_ors_sv = newSVpvs("\n\n");
	    }
	    else {
		PL_ors_sv = newSVsv(PL_rs);
	    }
	}
	return s;
    case 'M':
	forbid_setid('M', FALSE);	/* XXX ? */
	/* FALLTHROUGH */
    case 'm':
	forbid_setid('m', FALSE);	/* XXX ? */
	if (*++s) {
	    const char *start;
	    const char *end;
	    SV *sv;
	    const char *use = "use ";
	    bool colon = FALSE;
	    /* -M-foo == 'no foo'	*/
	    /* Leading space on " no " is deliberate, to make both
	       possibilities the same length.  */
	    if (*s == '-') { use = " no "; ++s; }
	    sv = newSVpvn(use,4);
	    start = s;
	    /* We allow -M'Module qw(Foo Bar)'	*/
	    while(isWORDCHAR(*s) || *s==':') {
		if( *s++ == ':' ) {
		    if( *s == ':' ) 
			s++;
		    else
			colon = TRUE;
		}
	    }
	    if (s == start)
		Perl_croak(aTHX_ "Module name required with -%c option",
				    option);
	    if (colon) 
		Perl_croak(aTHX_ "Invalid module name %.*s with -%c option: "
				    "contains single ':'",
				    (int)(s - start), start, option);
	    end = s + strlen(s);
	    if (*s != '=') {
		sv_catpvn(sv, start, end - start);
		if (option == 'm') {
		    if (*s != '\0')
			Perl_croak(aTHX_ "Can't use '%c' after -mname", *s);
		    sv_catpvs( sv, " ()");
		}
	    } else {
		sv_catpvn(sv, start, s-start);
		/* Use NUL as q''-delimiter.  */
		sv_catpvs(sv, " split(/,/,q\0");
		++s;
		sv_catpvn(sv, s, end - s);
		sv_catpvs(sv,  "\0)");
	    }
	    s = end;
	    Perl_av_create_and_push(aTHX_ &PL_preambleav, sv);
	}
	else
	    Perl_croak(aTHX_ "Missing argument to -%c", option);
	return s;
    case 'n':
	PL_minus_n = TRUE;
	s++;
	return s;
    case 'p':
	PL_minus_p = TRUE;
	s++;
	return s;
    case 's':
	forbid_setid('s', FALSE);
	PL_doswitches = TRUE;
	s++;
	return s;
    case 't':
    case 'T':
#if defined(SILENT_NO_TAINT_SUPPORT)
            /* silently ignore */
#elif defined(NO_TAINT_SUPPORT)
        Perl_croak_nocontext("This perl was compiled without taint support. "
                   "Cowardly refusing to run with -t or -T flags");
#else
        if (!TAINTING_get)
	    TOO_LATE_FOR(*s);
#endif
        s++;
	return s;
    case 'u':
	PL_do_undump = TRUE;
	s++;
	return s;
    case 'U':
	PL_unsafe = TRUE;
	s++;
	return s;
    case 'v':
	minus_v();
    case 'w':
	if (! (PL_dowarn & G_WARN_ALL_MASK)) {
	    PL_dowarn |= G_WARN_ON;
	}
	s++;
	return s;
    case 'W':
	PL_dowarn = G_WARN_ALL_ON|G_WARN_ON;
        if (!specialWARN(PL_compiling.cop_warnings))
            PerlMemShared_free(PL_compiling.cop_warnings);
	PL_compiling.cop_warnings = pWARN_ALL ;
	s++;
	return s;
    case 'X':
	PL_dowarn = G_WARN_ALL_OFF;
        if (!specialWARN(PL_compiling.cop_warnings))
            PerlMemShared_free(PL_compiling.cop_warnings);
	PL_compiling.cop_warnings = pWARN_NONE ;
	s++;
	return s;
    case '*':
    case ' ':
        while( *s == ' ' )
          ++s;
	if (s[0] == '-')	/* Additional switches on #! line. */
	    return s+1;
	break;
    case '-':
    case 0:
#if defined(WIN32) || !defined(PERL_STRICT_CR)
    case '\r':
#endif
    case '\n':
    case '\t':
	break;
#ifdef ALTERNATE_SHEBANG
    case 'S':			/* OS/2 needs -S on "extproc" line. */
	break;
#endif
    case 'e': case 'f': case 'x': case 'E':
#ifndef ALTERNATE_SHEBANG
    case 'S':
#endif
    case 'V':
	Perl_croak(aTHX_ "Can't emulate -%.1s on #! line",s);
    default:
	Perl_croak(aTHX_
	    "Unrecognized switch: -%.1s  (-h will show valid options)",s
	);
    }
    return NULL;
}


STATIC void
S_minus_v(pTHX)
{
	PerlIO * PIO_stdout;
	{
	    const char * const level_str = "v" PERL_VERSION_STRING;
	    const STRLEN level_len = sizeof("v" PERL_VERSION_STRING)-1;
#ifdef PERL_PATCHNUM
	    SV* level;
#  ifdef PERL_GIT_UNCOMMITTED_CHANGES
	    static const char num [] = PERL_PATCHNUM "*";
#  else
	    static const char num [] = PERL_PATCHNUM;
#  endif
	    {
		const STRLEN num_len = sizeof(num)-1;
		/* A very advanced compiler would fold away the strnEQ
		   and this whole conditional, but most (all?) won't do it.
		   SV level could also be replaced by with preprocessor
		   catenation.
		*/
		if (num_len >= level_len && strnEQ(num,level_str,level_len)) {
		    /* per 46807d8e80, PERL_PATCHNUM is outside of the control
		       of the interp so it might contain format characters
		    */
		    level = newSVpvn(num, num_len);
		} else {
		    level = Perl_newSVpvf_nocontext("%s (%s)", level_str, num);
		}
	    }
#else
	SV* level = newSVpvn(level_str, level_len);
#endif /* #ifdef PERL_PATCHNUM */
	PIO_stdout =  PerlIO_stdout();
	    PerlIO_printf(PIO_stdout,
		"\nThis is perl "	STRINGIFY(PERL_REVISION)
		", version "		STRINGIFY(PERL_VERSION)
		", subversion "		STRINGIFY(PERL_SUBVERSION)
		" (%"SVf") built for "	ARCHNAME, SVfARG(level)
		);
	    SvREFCNT_dec_NN(level);
	}
#if defined(LOCAL_PATCH_COUNT)
	if (LOCAL_PATCH_COUNT > 0)
	    PerlIO_printf(PIO_stdout,
			  "\n(with %d registered patch%s, "
			  "see perl -V for more detail)",
			  LOCAL_PATCH_COUNT,
			  (LOCAL_PATCH_COUNT!=1) ? "es" : "");
#endif

	PerlIO_printf(PIO_stdout,
		      "\n\nCopyright 1987-2017, Larry Wall\n");
#ifdef MSDOS
	PerlIO_printf(PIO_stdout,
		      "\nMS-DOS port Copyright (c) 1989, 1990, Diomidis Spinellis\n");
#endif
#ifdef DJGPP
	PerlIO_printf(PIO_stdout,
		      "djgpp v2 port (jpl5003c) by Hirofumi Watanabe, 1996\n"
		      "djgpp v2 port (perl5004+) by Laszlo Molnar, 1997-1999\n");
#endif
#ifdef OS2
	PerlIO_printf(PIO_stdout,
		      "\n\nOS/2 port Copyright (c) 1990, 1991, Raymond Chen, Kai Uwe Rommel\n"
		      "Version 5 port Copyright (c) 1994-2002, Andreas Kaiser, Ilya Zakharevich\n");
#endif
#ifdef OEMVS
	PerlIO_printf(PIO_stdout,
		      "MVS (OS390) port by Mortice Kern Systems, 1997-1999\n");
#endif
#ifdef __VOS__
	PerlIO_printf(PIO_stdout,
		      "Stratus OpenVOS port by Paul.Green@@stratus.com, 1997-2013\n");
#endif
#ifdef POSIX_BC
	PerlIO_printf(PIO_stdout,
		      "BS2000 (POSIX) port by Start Amadeus GmbH, 1998-1999\n");
#endif
#ifdef UNDER_CE
	PerlIO_printf(PIO_stdout,
			"WINCE port by Rainer Keuchel, 2001-2002\n"
			"Built on " __DATE__ " " __TIME__ "\n\n");
	wce_hitreturn();
#endif
#ifdef __SYMBIAN32__
	PerlIO_printf(PIO_stdout,
		      "Symbian port by Nokia, 2004-2005\n");
#endif
#ifdef BINARY_BUILD_NOTICE
	BINARY_BUILD_NOTICE;
#endif
	PerlIO_printf(PIO_stdout,
		      "\n\
Perl may be copied only under the terms of either the Artistic License or the\n\
GNU General Public License, which may be found in the Perl 5 source kit.\n\n\
Complete documentation for Perl, including FAQ lists, should be found on\n\
this system using \"man perl\" or \"perldoc perl\".  If you have access to the\n\
Internet, point your browser at http://www.perl.org/, the Perl Home Page.\n\n");
	my_exit(0);
}

/* compliments of Tom Christiansen */

/* unexec() can be found in the Gnu emacs distribution */
/* Known to work with -DUNEXEC and using unexelf.c from GNU emacs-20.2 */

#ifdef VMS
#include <lib$routines.h>
#endif

void
Perl_my_unexec(pTHX)
{
#ifdef UNEXEC
    SV *    prog = newSVpv(BIN_EXP, 0);
    SV *    file = newSVpv(PL_origfilename, 0);
    int    status = 1;
    extern int etext;

    sv_catpvs(prog, "/perl");
    sv_catpvs(file, ".perldump");

    unexec(SvPVX(file), SvPVX(prog), &etext, sbrk(0), 0);
    /* unexec prints msg to stderr in case of failure */
    PerlProc_exit(status);
#else
    PERL_UNUSED_CONTEXT;
#  ifdef VMS
     lib$signal(SS$_DEBUG);  /* ssdef.h #included from vmsish.h */
#  elif defined(WIN32) || defined(__CYGWIN__)
    Perl_croak_nocontext("dump is not supported");
#  else
    ABORT();		/* for use with undump */
#  endif
#endif
}

/* initialize curinterp */
STATIC void
S_init_interp(pTHX)
{
#ifdef MULTIPLICITY
#  define PERLVAR(prefix,var,type)
#  define PERLVARA(prefix,var,n,type)
#  if defined(PERL_IMPLICIT_CONTEXT)
#    define PERLVARI(prefix,var,type,init)	aTHX->prefix##var = init;
#    define PERLVARIC(prefix,var,type,init)	aTHX->prefix##var = init;
#  else
#    define PERLVARI(prefix,var,type,init)	PERL_GET_INTERP->var = init;
#    define PERLVARIC(prefix,var,type,init)	PERL_GET_INTERP->var = init;
#  endif
#  include "intrpvar.h"
#  undef PERLVAR
#  undef PERLVARA
#  undef PERLVARI
#  undef PERLVARIC
#else
#  define PERLVAR(prefix,var,type)
#  define PERLVARA(prefix,var,n,type)
#  define PERLVARI(prefix,var,type,init)	PL_##var = init;
#  define PERLVARIC(prefix,var,type,init)	PL_##var = init;
#  include "intrpvar.h"
#  undef PERLVAR
#  undef PERLVARA
#  undef PERLVARI
#  undef PERLVARIC
#endif

}

STATIC void
S_init_main_stash(pTHX)
{
    GV *gv;

    PL_curstash = PL_defstash = (HV *)SvREFCNT_inc_simple_NN(newHV());
    /* We know that the string "main" will be in the global shared string
       table, so it's a small saving to use it rather than allocate another
       8 bytes.  */
    PL_curstname = newSVpvs_share("main");
    gv = gv_fetchpvs("main::", GV_ADD|GV_NOTQUAL, SVt_PVHV);
    /* If we hadn't caused another reference to "main" to be in the shared
       string table above, then it would be worth reordering these two,
       because otherwise all we do is delete "main" from it as a consequence
       of the SvREFCNT_dec, only to add it again with hv_name_set */
    SvREFCNT_dec(GvHV(gv));
    hv_name_set(PL_defstash, "main", 4, 0);
    GvHV(gv) = MUTABLE_HV(SvREFCNT_inc_simple(PL_defstash));
    SvREADONLY_on(gv);
    PL_incgv = gv_HVadd(gv_AVadd(gv_fetchpvs("INC", GV_ADD|GV_NOTQUAL,
					     SVt_PVAV)));
    SvREFCNT_inc_simple_void(PL_incgv); /* Don't allow it to be freed */
    GvMULTI_on(PL_incgv);
    PL_hintgv = gv_fetchpvs("\010", GV_ADD|GV_NOTQUAL, SVt_PV); /* ^H */
    SvREFCNT_inc_simple_void(PL_hintgv);
    GvMULTI_on(PL_hintgv);
    PL_defgv = gv_fetchpvs("_", GV_ADD|GV_NOTQUAL, SVt_PVAV);
    SvREFCNT_inc_simple_void(PL_defgv);
    PL_errgv = gv_fetchpvs("@@", GV_ADD|GV_NOTQUAL, SVt_PV);
    SvREFCNT_inc_simple_void(PL_errgv);
    GvMULTI_on(PL_errgv);
    PL_replgv = gv_fetchpvs("\022", GV_ADD|GV_NOTQUAL, SVt_PV); /* ^R */
    SvREFCNT_inc_simple_void(PL_replgv);
    GvMULTI_on(PL_replgv);
    (void)Perl_form(aTHX_ "%240s","");	/* Preallocate temp - for immediate signals. */
#ifdef PERL_DONT_CREATE_GVSV
    (void)gv_SVadd(PL_errgv);
#endif
    sv_grow(ERRSV, 240);	/* Preallocate - for immediate signals. */
    CLEAR_ERRSV();
    SET_CURSTASH(PL_defstash);
    CopSTASH_set(&PL_compiling, PL_defstash);
    PL_debstash = GvHV(gv_fetchpvs("DB::", GV_ADDMULTI, SVt_PVHV));
    PL_globalstash = GvHV(gv_fetchpvs("CORE::GLOBAL::", GV_ADDMULTI,
				      SVt_PVHV));
    /* We must init $/ before switches are processed. */
    sv_setpvs(get_sv("/", GV_ADD), "\n");
}

STATIC PerlIO *
S_open_script(pTHX_ const char *scriptname, bool dosearch, bool *suidscript)
{
    int fdscript = -1;
    PerlIO *rsfp = NULL;
    Stat_t tmpstatbuf;
    int fd;

    PERL_ARGS_ASSERT_OPEN_SCRIPT;

    if (PL_e_script) {
	PL_origfilename = savepvs("-e");
    }
    else {
        const char *s;
        UV uv;
	/* if find_script() returns, it returns a malloc()-ed value */
	scriptname = PL_origfilename = find_script(scriptname, dosearch, NULL, 1);

	if (strnEQ(scriptname, "/dev/fd/", 8)
            && isDIGIT(scriptname[8])
            && grok_atoUV(scriptname + 8, &uv, &s)
            && uv <= PERL_INT_MAX
        ) {
            fdscript = (int)uv;
	    if (*s) {
		/* PSz 18 Feb 04
		 * Tell apart "normal" usage of fdscript, e.g.
		 * with bash on FreeBSD:
		 *   perl <( echo '#!perl -DA'; echo 'print "$0\n"')
		 * from usage in suidperl.
		 * Does any "normal" usage leave garbage after the number???
		 * Is it a mistake to use a similar /dev/fd/ construct for
		 * suidperl?
		 */
		*suidscript = TRUE;
		/* PSz 20 Feb 04  
		 * Be supersafe and do some sanity-checks.
		 * Still, can we be sure we got the right thing?
		 */
		if (*s != '/') {
		    Perl_croak(aTHX_ "Wrong syntax (suid) fd script name \"%s\"\n", s);
		}
		if (! *(s+1)) {
		    Perl_croak(aTHX_ "Missing (suid) fd script name\n");
		}
		scriptname = savepv(s + 1);
		Safefree(PL_origfilename);
		PL_origfilename = (char *)scriptname;
	    }
	}
    }

    CopFILE_free(PL_curcop);
    CopFILE_set(PL_curcop, PL_origfilename);
    if (*PL_origfilename == '-' && PL_origfilename[1] == '\0')
	scriptname = (char *)"";
    if (fdscript >= 0) {
	rsfp = PerlIO_fdopen(fdscript,PERL_SCRIPT_MODE);
    }
    else if (!*scriptname) {
	forbid_setid(0, *suidscript);
	return NULL;
    }
    else {
#ifdef FAKE_BIT_BUCKET
	/* This hack allows one not to have /dev/null (or BIT_BUCKET as it
	 * is called) and still have the "-e" work.  (Believe it or not,
	 * a /dev/null is required for the "-e" to work because source
	 * filter magic is used to implement it. ) This is *not* a general
	 * replacement for a /dev/null.  What we do here is create a temp
	 * file (an empty file), open up that as the script, and then
	 * immediately close and unlink it.  Close enough for jazz. */ 
#define FAKE_BIT_BUCKET_PREFIX "/tmp/perlnull-"
#define FAKE_BIT_BUCKET_SUFFIX "XXXXXXXX"
#define FAKE_BIT_BUCKET_TEMPLATE FAKE_BIT_BUCKET_PREFIX FAKE_BIT_BUCKET_SUFFIX
	char tmpname[sizeof(FAKE_BIT_BUCKET_TEMPLATE)] = {
	    FAKE_BIT_BUCKET_TEMPLATE
	};
	const char * const err = "Failed to create a fake bit bucket";
	if (strEQ(scriptname, BIT_BUCKET)) {
#ifdef HAS_MKSTEMP /* Hopefully mkstemp() is safe here. */
            int old_umask = umask(0177);
	    int tmpfd = mkstemp(tmpname);
            umask(old_umask);
	    if (tmpfd > -1) {
		scriptname = tmpname;
		close(tmpfd);
	    } else
		Perl_croak(aTHX_ err);
#else
#  ifdef HAS_MKTEMP
	    scriptname = mktemp(tmpname);
	    if (!scriptname)
		Perl_croak(aTHX_ err);
#  endif
#endif
	}
#endif
	rsfp = PerlIO_open(scriptname,PERL_SCRIPT_MODE);
#ifdef FAKE_BIT_BUCKET
	if (memEQ(scriptname, FAKE_BIT_BUCKET_PREFIX,
		  sizeof(FAKE_BIT_BUCKET_PREFIX) - 1)
	    && strlen(scriptname) == sizeof(tmpname) - 1) {
	    unlink(scriptname);
	}
	scriptname = BIT_BUCKET;
#endif
    }
    if (!rsfp) {
	/* PSz 16 Sep 03  Keep neat error message */
	if (PL_e_script)
	    Perl_croak(aTHX_ "Can't open "BIT_BUCKET": %s\n", Strerror(errno));
	else
	    Perl_croak(aTHX_ "Can't open perl script \"%s\": %s\n",
		    CopFILE(PL_curcop), Strerror(errno));
    }
    fd = PerlIO_fileno(rsfp);
#if defined(HAS_FCNTL) && defined(F_SETFD) && defined(FD_CLOEXEC)
    if (fd >= 0) {
        /* ensure close-on-exec */
        if (fcntl(fd, F_SETFD, FD_CLOEXEC) < 0) {
            Perl_croak(aTHX_ "Can't open perl script \"%s\": %s\n",
                       CopFILE(PL_curcop), Strerror(errno));
        }
    }
#endif

    if (fd < 0 ||
        (PerlLIO_fstat(fd, &tmpstatbuf) >= 0
         && S_ISDIR(tmpstatbuf.st_mode)))
        Perl_croak(aTHX_ "Can't open perl script \"%s\": %s\n",
            CopFILE(PL_curcop),
            Strerror(EISDIR));

    return rsfp;
}

/* Mention
 * I_SYSSTATVFS	HAS_FSTATVFS
 * I_SYSMOUNT
 * I_STATFS	HAS_FSTATFS	HAS_GETFSSTAT
 * I_MNTENT	HAS_GETMNTENT	HAS_HASMNTOPT
 * here so that metaconfig picks them up. */


#ifdef SETUID_SCRIPTS_ARE_SECURE_NOW
/* Don't even need this function.  */
#else
STATIC void
S_validate_suid(pTHX_ PerlIO *rsfp)
{
    const Uid_t  my_uid = PerlProc_getuid();
    const Uid_t my_euid = PerlProc_geteuid();
    const Gid_t  my_gid = PerlProc_getgid();
    const Gid_t my_egid = PerlProc_getegid();

    PERL_ARGS_ASSERT_VALIDATE_SUID;

    if (my_euid != my_uid || my_egid != my_gid) {	/* (suidperl doesn't exist, in fact) */
	dVAR;
        int fd = PerlIO_fileno(rsfp);
        Stat_t statbuf;
        if (fd < 0 || PerlLIO_fstat(fd, &statbuf) < 0) { /* may be either wrapped or real suid */
            Perl_croak_nocontext( "Illegal suidscript");
        }
        if ((my_euid != my_uid && my_euid == statbuf.st_uid && statbuf.st_mode & S_ISUID)
            ||
            (my_egid != my_gid && my_egid == statbuf.st_gid && statbuf.st_mode & S_ISGID)
            )
	    if (!PL_do_undump)
		Perl_croak(aTHX_ "YOU HAVEN'T DISABLED SET-ID SCRIPTS IN THE KERNEL YET!\n\
FIX YOUR KERNEL, PUT A C WRAPPER AROUND THIS SCRIPT, OR USE -u AND UNDUMP!\n");
	/* not set-id, must be wrapped */
    }
}
#endif /* SETUID_SCRIPTS_ARE_SECURE_NOW */

STATIC void
S_find_beginning(pTHX_ SV* linestr_sv, PerlIO *rsfp)
{
    const char *s;
    const char *s2;

    PERL_ARGS_ASSERT_FIND_BEGINNING;

    /* skip forward in input to the real script? */

    do {
	if ((s = sv_gets(linestr_sv, rsfp, 0)) == NULL)
	    Perl_croak(aTHX_ "No Perl script found in input\n");
	s2 = s;
    } while (!(*s == '#' && s[1] == '!' && ((s = instr(s,"perl")) || (s = instr(s2,"PERL")))));
    PerlIO_ungetc(rsfp, '\n');		/* to keep line count right */
    while (*s && !(isSPACE (*s) || *s == '#')) s++;
    s2 = s;
    while (*s == ' ' || *s == '\t') s++;
    if (*s++ == '-') {
	while (isDIGIT(s2[-1]) || s2[-1] == '-' || s2[-1] == '.'
	       || s2[-1] == '_') s2--;
	if (strnEQ(s2-4,"perl",4))
	    while ((s = moreswitches(s)))
		;
    }
}


STATIC void
S_init_ids(pTHX)
{
    /* no need to do anything here any more if we don't
     * do tainting. */
#ifndef NO_TAINT_SUPPORT
    const Uid_t my_uid = PerlProc_getuid();
    const Uid_t my_euid = PerlProc_geteuid();
    const Gid_t my_gid = PerlProc_getgid();
    const Gid_t my_egid = PerlProc_getegid();

    PERL_UNUSED_CONTEXT;

    /* Should not happen: */
    CHECK_MALLOC_TAINT(my_uid && (my_euid != my_uid || my_egid != my_gid));
    TAINTING_set( TAINTING_get | (my_uid && (my_euid != my_uid || my_egid != my_gid)) );
#endif
    /* BUG */
    /* PSz 27 Feb 04
     * Should go by suidscript, not uid!=euid: why disallow
     * system("ls") in scripts run from setuid things?
     * Or, is this run before we check arguments and set suidscript?
     * What about SETUID_SCRIPTS_ARE_SECURE_NOW: could we use fdscript then?
     * (We never have suidscript, can we be sure to have fdscript?)
     * Or must then go by UID checks? See comments in forbid_setid also.
     */
}

/* This is used very early in the lifetime of the program,
 * before even the options are parsed, so PL_tainting has
 * not been initialized properly.  */
bool
Perl_doing_taint(int argc, char *argv[], char *envp[])
{
#ifndef PERL_IMPLICIT_SYS
    /* If we have PERL_IMPLICIT_SYS we can't call getuid() et alia
     * before we have an interpreter-- and the whole point of this
     * function is to be called at such an early stage.  If you are on
     * a system with PERL_IMPLICIT_SYS but you do have a concept of
     * "tainted because running with altered effective ids', you'll
     * have to add your own checks somewhere in here.  The two most
     * known samples of 'implicitness' are Win32 and NetWare, neither
     * of which has much of concept of 'uids'. */
    Uid_t uid  = PerlProc_getuid();
    Uid_t euid = PerlProc_geteuid();
    Gid_t gid  = PerlProc_getgid();
    Gid_t egid = PerlProc_getegid();
    (void)envp;

#ifdef VMS
    uid  |=  gid << 16;
    euid |= egid << 16;
#endif
    if (uid && (euid != uid || egid != gid))
	return 1;
#endif /* !PERL_IMPLICIT_SYS */
    /* This is a really primitive check; environment gets ignored only
     * if -T are the first chars together; otherwise one gets
     *  "Too late" message. */
    if ( argc > 1 && argv[1][0] == '-'
         && isALPHA_FOLD_EQ(argv[1][1], 't'))
	return 1;
    return 0;
}

/* Passing the flag as a single char rather than a string is a slight space
   optimisation.  The only message that isn't /^-.$/ is
   "program input from stdin", which is substituted in place of '\0', which
   could never be a command line flag.  */
STATIC void
S_forbid_setid(pTHX_ const char flag, const bool suidscript) /* g */
{
    char string[3] = "-x";
    const char *message = "program input from stdin";

    PERL_UNUSED_CONTEXT;
    if (flag) {
	string[1] = flag;
	message = string;
    }

#ifdef SETUID_SCRIPTS_ARE_SECURE_NOW
    if (PerlProc_getuid() != PerlProc_geteuid())
        Perl_croak(aTHX_ "No %s allowed while running setuid", message);
    if (PerlProc_getgid() != PerlProc_getegid())
        Perl_croak(aTHX_ "No %s allowed while running setgid", message);
#endif /* SETUID_SCRIPTS_ARE_SECURE_NOW */
    if (suidscript)
        Perl_croak(aTHX_ "No %s allowed with (suid) fdscript", message);
}

void
Perl_init_dbargs(pTHX)
{
    AV *const args = PL_dbargs = GvAV(gv_AVadd((gv_fetchpvs("DB::args",
							    GV_ADDMULTI,
							    SVt_PVAV))));

    if (AvREAL(args)) {
	/* Someone has already created it.
	   It might have entries, and if we just turn off AvREAL(), they will
	   "leak" until global destruction.  */
	av_clear(args);
	if (SvTIED_mg((const SV *)args, PERL_MAGIC_tied))
	    Perl_croak(aTHX_ "Cannot set tied @@DB::args");
    }
    AvREIFY_only(PL_dbargs);
}

void
Perl_init_debugger(pTHX)
{
    HV * const ostash = PL_curstash;
    MAGIC *mg;

    PL_curstash = (HV *)SvREFCNT_inc_simple(PL_debstash);

    Perl_init_dbargs(aTHX);
    PL_DBgv = MUTABLE_GV(
	SvREFCNT_inc(gv_fetchpvs("DB::DB", GV_ADDMULTI, SVt_PVGV))
    );
    PL_DBline = MUTABLE_GV(
	SvREFCNT_inc(gv_fetchpvs("DB::dbline", GV_ADDMULTI, SVt_PVAV))
    );
    PL_DBsub = MUTABLE_GV(SvREFCNT_inc(
	gv_HVadd(gv_fetchpvs("DB::sub", GV_ADDMULTI, SVt_PVHV))
    ));
    PL_DBsingle = GvSV((gv_fetchpvs("DB::single", GV_ADDMULTI, SVt_PV)));
    if (!SvIOK(PL_DBsingle))
	sv_setiv(PL_DBsingle, 0);
    mg = sv_magicext(PL_DBsingle, NULL, PERL_MAGIC_debugvar, &PL_vtbl_debugvar, 0, 0);
    mg->mg_private = DBVARMG_SINGLE;
    SvSETMAGIC(PL_DBsingle);

    PL_DBtrace = GvSV((gv_fetchpvs("DB::trace", GV_ADDMULTI, SVt_PV)));
    if (!SvIOK(PL_DBtrace))
	sv_setiv(PL_DBtrace, 0);
    mg = sv_magicext(PL_DBtrace, NULL, PERL_MAGIC_debugvar, &PL_vtbl_debugvar, 0, 0);
    mg->mg_private = DBVARMG_TRACE;
    SvSETMAGIC(PL_DBtrace);

    PL_DBsignal = GvSV((gv_fetchpvs("DB::signal", GV_ADDMULTI, SVt_PV)));
    if (!SvIOK(PL_DBsignal))
	sv_setiv(PL_DBsignal, 0);
    mg = sv_magicext(PL_DBsignal, NULL, PERL_MAGIC_debugvar, &PL_vtbl_debugvar, 0, 0);
    mg->mg_private = DBVARMG_SIGNAL;
    SvSETMAGIC(PL_DBsignal);

    SvREFCNT_dec(PL_curstash);
    PL_curstash = ostash;
}

#ifndef STRESS_REALLOC
#define REASONABLE(size) (size)
#define REASONABLE_but_at_least(size,min) (size)
#else
#define REASONABLE(size) (1) /* unreasonable */
#define REASONABLE_but_at_least(size,min) (min)
#endif

void
Perl_init_stacks(pTHX)
{
    SSize_t size;

    /* start with 128-item stack and 8K cxstack */
    PL_curstackinfo = new_stackinfo(REASONABLE(128),
				 REASONABLE(8192/sizeof(PERL_CONTEXT) - 1));
    PL_curstackinfo->si_type = PERLSI_MAIN;
    PL_curstack = PL_curstackinfo->si_stack;
    PL_mainstack = PL_curstack;		/* remember in case we switch stacks */

    PL_stack_base = AvARRAY(PL_curstack);
    PL_stack_sp = PL_stack_base;
    PL_stack_max = PL_stack_base + AvMAX(PL_curstack);

    Newx(PL_tmps_stack,REASONABLE(128),SV*);
    PL_tmps_floor = -1;
    PL_tmps_ix = -1;
    PL_tmps_max = REASONABLE(128);

    Newx(PL_markstack,REASONABLE(32),I32);
    PL_markstack_ptr = PL_markstack;
    PL_markstack_max = PL_markstack + REASONABLE(32);

    SET_MARK_OFFSET;

    Newx(PL_scopestack,REASONABLE(32),I32);
#ifdef DEBUGGING
    Newx(PL_scopestack_name,REASONABLE(32),const char*);
#endif
    PL_scopestack_ix = 0;
    PL_scopestack_max = REASONABLE(32);

    size = REASONABLE_but_at_least(128,SS_MAXPUSH);
    Newx(PL_savestack, size, ANY);
    PL_savestack_ix = 0;
    /*PL_savestack_max lies: it always has SS_MAXPUSH more than it claims */
    PL_savestack_max = size - SS_MAXPUSH;
}

#undef REASONABLE

STATIC void
S_nuke_stacks(pTHX)
{
    while (PL_curstackinfo->si_next)
	PL_curstackinfo = PL_curstackinfo->si_next;
    while (PL_curstackinfo) {
	PERL_SI *p = PL_curstackinfo->si_prev;
	/* curstackinfo->si_stack got nuked by sv_free_arenas() */
	Safefree(PL_curstackinfo->si_cxstack);
	Safefree(PL_curstackinfo);
	PL_curstackinfo = p;
    }
    Safefree(PL_tmps_stack);
    Safefree(PL_markstack);
    Safefree(PL_scopestack);
#ifdef DEBUGGING
    Safefree(PL_scopestack_name);
#endif
    Safefree(PL_savestack);
}

void
Perl_populate_isa(pTHX_ const char *name, STRLEN len, ...)
{
    GV *const gv = gv_fetchpvn(name, len, GV_ADD | GV_ADDMULTI, SVt_PVAV);
    AV *const isa = GvAVn(gv);
    va_list args;

    PERL_ARGS_ASSERT_POPULATE_ISA;

    if(AvFILLp(isa) != -1)
	return;

    /* NOTE: No support for tied ISA */

    va_start(args, len);
    do {
	const char *const parent = va_arg(args, const char*);
	size_t parent_len;

	if (!parent)
	    break;
	parent_len = va_arg(args, size_t);

	/* Arguments are supplied with a trailing ::  */
	assert(parent_len > 2);
	assert(parent[parent_len - 1] == ':');
	assert(parent[parent_len - 2] == ':');
	av_push(isa, newSVpvn(parent, parent_len - 2));
	(void) gv_fetchpvn(parent, parent_len, GV_ADD, SVt_PVGV);
    } while (1);
    va_end(args);
}


STATIC void
S_init_predump_symbols(pTHX)
{
    GV *tmpgv;
    IO *io;

    sv_setpvs(get_sv("\"", GV_ADD), " ");
    PL_ofsgv = (GV*)SvREFCNT_inc(gv_fetchpvs(",", GV_ADD|GV_NOTQUAL, SVt_PV));


    /* Historically, PVIOs were blessed into IO::Handle, unless
       FileHandle was loaded, in which case they were blessed into
       that. Action at a distance.
       However, if we simply bless into IO::Handle, we break code
       that assumes that PVIOs will have (among others) a seek
       method. IO::File inherits from IO::Handle and IO::Seekable,
       and provides the needed methods. But if we simply bless into
       it, then we break code that assumed that by loading
       IO::Handle, *it* would work.
       So a compromise is to set up the correct @@IO::File::ISA,
       so that code that does C<use IO::Handle>; will still work.
    */
		   
    Perl_populate_isa(aTHX_ STR_WITH_LEN("IO::File::ISA"),
		      STR_WITH_LEN("IO::Handle::"),
		      STR_WITH_LEN("IO::Seekable::"),
		      STR_WITH_LEN("Exporter::"),
		      NULL);

    PL_stdingv = gv_fetchpvs("STDIN", GV_ADD|GV_NOTQUAL, SVt_PVIO);
    GvMULTI_on(PL_stdingv);
    io = GvIOp(PL_stdingv);
    IoTYPE(io) = IoTYPE_RDONLY;
    IoIFP(io) = PerlIO_stdin();
    tmpgv = gv_fetchpvs("stdin", GV_ADD|GV_NOTQUAL, SVt_PV);
    GvMULTI_on(tmpgv);
    GvIOp(tmpgv) = MUTABLE_IO(SvREFCNT_inc_simple(io));

    tmpgv = gv_fetchpvs("STDOUT", GV_ADD|GV_NOTQUAL, SVt_PVIO);
    GvMULTI_on(tmpgv);
    io = GvIOp(tmpgv);
    IoTYPE(io) = IoTYPE_WRONLY;
    IoOFP(io) = IoIFP(io) = PerlIO_stdout();
    setdefout(tmpgv);
    tmpgv = gv_fetchpvs("stdout", GV_ADD|GV_NOTQUAL, SVt_PV);
    GvMULTI_on(tmpgv);
    GvIOp(tmpgv) = MUTABLE_IO(SvREFCNT_inc_simple(io));

    PL_stderrgv = gv_fetchpvs("STDERR", GV_ADD|GV_NOTQUAL, SVt_PVIO);
    GvMULTI_on(PL_stderrgv);
    io = GvIOp(PL_stderrgv);
    IoTYPE(io) = IoTYPE_WRONLY;
    IoOFP(io) = IoIFP(io) = PerlIO_stderr();
    tmpgv = gv_fetchpvs("stderr", GV_ADD|GV_NOTQUAL, SVt_PV);
    GvMULTI_on(tmpgv);
    GvIOp(tmpgv) = MUTABLE_IO(SvREFCNT_inc_simple(io));

    PL_statname = newSVpvs("");		/* last filename we did stat on */
}

void
Perl_init_argv_symbols(pTHX_ int argc, char **argv)
{
    PERL_ARGS_ASSERT_INIT_ARGV_SYMBOLS;

    argc--,argv++;	/* skip name of script */
    if (PL_doswitches) {
	for (; argc > 0 && **argv == '-'; argc--,argv++) {
	    char *s;
	    if (!argv[0][1])
		break;
	    if (argv[0][1] == '-' && !argv[0][2]) {
		argc--,argv++;
		break;
	    }
	    if ((s = strchr(argv[0], '='))) {
		const char *const start_name = argv[0] + 1;
		sv_setpv(GvSV(gv_fetchpvn_flags(start_name, s - start_name,
						TRUE, SVt_PV)), s + 1);
	    }
	    else
		sv_setiv(GvSV(gv_fetchpv(argv[0]+1, GV_ADD, SVt_PV)),1);
	}
    }
    if ((PL_argvgv = gv_fetchpvs("ARGV", GV_ADD|GV_NOTQUAL, SVt_PVAV))) {
	SvREFCNT_inc_simple_void_NN(PL_argvgv);
	GvMULTI_on(PL_argvgv);
	av_clear(GvAVn(PL_argvgv));
	for (; argc > 0; argc--,argv++) {
	    SV * const sv = newSVpv(argv[0],0);
	    av_push(GvAV(PL_argvgv),sv);
	    if (!(PL_unicode & PERL_UNICODE_LOCALE_FLAG) || PL_utf8locale) {
		 if (PL_unicode & PERL_UNICODE_ARGV_FLAG)
		      SvUTF8_on(sv);
	    }
	    if (PL_unicode & PERL_UNICODE_WIDESYSCALLS_FLAG) /* Sarathy? */
		 (void)sv_utf8_decode(sv);
	}
    }

    if (PL_inplace && (!PL_argvgv || AvFILL(GvAV(PL_argvgv)) == -1))
        Perl_ck_warner_d(aTHX_ packWARN(WARN_INPLACE),
                         "-i used with no filenames on the command line, "
                         "reading from STDIN");
}

STATIC void
S_init_postdump_symbols(pTHX_ int argc, char **argv, char **env)
{
#ifdef USE_ITHREADS
    dVAR;
#endif
    GV* tmpgv;

    PERL_ARGS_ASSERT_INIT_POSTDUMP_SYMBOLS;

    PL_toptarget = newSV_type(SVt_PVIV);
    sv_setpvs(PL_toptarget, "");
    PL_bodytarget = newSV_type(SVt_PVIV);
    sv_setpvs(PL_bodytarget, "");
    PL_formtarget = PL_bodytarget;

    TAINT;

    init_argv_symbols(argc,argv);

    if ((tmpgv = gv_fetchpvs("0", GV_ADD|GV_NOTQUAL, SVt_PV))) {
	sv_setpv(GvSV(tmpgv),PL_origfilename);
    }
    if ((PL_envgv = gv_fetchpvs("ENV", GV_ADD|GV_NOTQUAL, SVt_PVHV))) {
	HV *hv;
	bool env_is_not_environ;
	SvREFCNT_inc_simple_void_NN(PL_envgv);
	GvMULTI_on(PL_envgv);
	hv = GvHVn(PL_envgv);
	hv_magic(hv, NULL, PERL_MAGIC_env);
#ifndef PERL_MICRO
#ifdef USE_ENVIRON_ARRAY
	/* Note that if the supplied env parameter is actually a copy
	   of the global environ then it may now point to free'd memory
	   if the environment has been modified since. To avoid this
	   problem we treat env==NULL as meaning 'use the default'
	*/
	if (!env)
	    env = environ;
	env_is_not_environ = env != environ;
	if (env_is_not_environ
#  ifdef USE_ITHREADS
	    && PL_curinterp == aTHX
#  endif
	   )
	{
	    environ[0] = NULL;
	}
	if (env) {
	  char *s, *old_var;
          STRLEN nlen;
	  SV *sv;
          HV *dups = newHV();

	  for (; *env; env++) {
	    old_var = *env;

	    if (!(s = strchr(old_var,'=')) || s == old_var)
		continue;
            nlen = s - old_var;

#if defined(MSDOS) && !defined(DJGPP)
	    *s = '\0';
	    (void)strupr(old_var);
	    *s = '=';
#endif
            if (hv_exists(hv, old_var, nlen)) {
                const char *name = savepvn(old_var, nlen);

                /* make sure we use the same value as getenv(), otherwise code that
                   uses getenv() (like setlocale()) might see a different value to %ENV
                 */
                sv = newSVpv(PerlEnv_getenv(name), 0);

                /* keep a count of the dups of this name so we can de-dup environ later */
                if (hv_exists(dups, name, nlen))
                    ++SvIVX(*hv_fetch(dups, name, nlen, 0));
                else
                    (void)hv_store(dups, name, nlen, newSViv(1), 0);

                Safefree(name);
            }
            else {
                sv = newSVpv(s+1, 0);
            }
	    (void)hv_store(hv, old_var, nlen, sv, 0);
	    if (env_is_not_environ)
	        mg_set(sv);
	  }
          if (HvKEYS(dups)) {
              /* environ has some duplicate definitions, remove them */
              HE *entry;
              hv_iterinit(dups);
              while ((entry = hv_iternext_flags(dups, 0))) {
                  STRLEN nlen;
                  const char *name = HePV(entry, nlen);
                  IV count = SvIV(HeVAL(entry));
                  IV i;
                  SV **valp = hv_fetch(hv, name, nlen, 0);

                  assert(valp);

                  /* try to remove any duplicate names, depending on the
                   * implementation used in my_setenv() the iteration might
                   * not be necessary, but let's be safe.
                   */
                  for (i = 0; i < count; ++i)
                      my_setenv(name, 0);

                  /* and set it back to the value we set $ENV{name} to */
                  my_setenv(name, SvPV_nolen(*valp));
              }
          }
          SvREFCNT_dec_NN(dups);
      }
#endif /* USE_ENVIRON_ARRAY */
#endif /* !PERL_MICRO */
    }
    TAINT_NOT;

    /* touch @@F array to prevent spurious warnings 20020415 MJD */
    if (PL_minus_a) {
      (void) get_av("main::F", GV_ADD | GV_ADDMULTI);
    }
}

STATIC void
S_init_perllib(pTHX)
{
#ifndef VMS
    const char *perl5lib = NULL;
#endif
    const char *s;
#if defined(WIN32) && !defined(PERL_IS_MINIPERL)
    STRLEN len;
#endif

    if (!TAINTING_get) {
#ifndef VMS
	perl5lib = PerlEnv_getenv("PERL5LIB");
/*
 * It isn't possible to delete an environment variable with
 * PERL_USE_SAFE_PUTENV set unless unsetenv() is also available, so in that
 * case we treat PERL5LIB as undefined if it has a zero-length value.
 */
#if defined(PERL_USE_SAFE_PUTENV) && ! defined(HAS_UNSETENV)
	if (perl5lib && *perl5lib != '\0')
#else
	if (perl5lib)
#endif
	    incpush_use_sep(perl5lib, 0, INCPUSH_ADD_SUB_DIRS);
	else {
	    s = PerlEnv_getenv("PERLLIB");
	    if (s)
		incpush_use_sep(s, 0, 0);
	}
#else /* VMS */
	/* Treat PERL5?LIB as a possible search list logical name -- the
	 * "natural" VMS idiom for a Unix path string.  We allow each
	 * element to be a set of |-separated directories for compatibility.
	 */
	char buf[256];
	int idx = 0;
	if (vmstrnenv("PERL5LIB",buf,0,NULL,0))
	    do {
		incpush_use_sep(buf, 0, INCPUSH_ADD_SUB_DIRS);
	    } while (vmstrnenv("PERL5LIB",buf,++idx,NULL,0));
	else {
	    while (vmstrnenv("PERLLIB",buf,idx++,NULL,0))
		incpush_use_sep(buf, 0, 0);
	}
#endif /* VMS */
    }

#ifndef PERL_IS_MINIPERL
    /* miniperl gets just -I..., the split of $ENV{PERL5LIB}, and "." in @@INC
       (and not the architecture specific directories from $ENV{PERL5LIB}) */

/* Use the ~-expanded versions of APPLLIB (undocumented),
    SITEARCH, SITELIB, VENDORARCH, VENDORLIB, ARCHLIB and PRIVLIB
*/
#ifdef APPLLIB_EXP
    S_incpush_use_sep(aTHX_ STR_WITH_LEN(APPLLIB_EXP),
		      INCPUSH_ADD_SUB_DIRS|INCPUSH_CAN_RELOCATE);
#endif

#ifdef SITEARCH_EXP
    /* sitearch is always relative to sitelib on Windows for
     * DLL-based path intuition to work correctly */
#  if !defined(WIN32)
	S_incpush_use_sep(aTHX_ STR_WITH_LEN(SITEARCH_EXP),
			  INCPUSH_CAN_RELOCATE);
#  endif
#endif

#ifdef SITELIB_EXP
#  if defined(WIN32)
    /* this picks up sitearch as well */
	s = PerlEnv_sitelib_path(PERL_FS_VERSION, &len);
	if (s)
	    incpush_use_sep(s, len, INCPUSH_ADD_SUB_DIRS|INCPUSH_CAN_RELOCATE);
#  else
	S_incpush_use_sep(aTHX_ STR_WITH_LEN(SITELIB_EXP), INCPUSH_CAN_RELOCATE);
#  endif
#endif

#ifdef PERL_VENDORARCH_EXP
    /* vendorarch is always relative to vendorlib on Windows for
     * DLL-based path intuition to work correctly */
#  if !defined(WIN32)
    S_incpush_use_sep(aTHX_ STR_WITH_LEN(PERL_VENDORARCH_EXP),
		      INCPUSH_CAN_RELOCATE);
#  endif
#endif

#ifdef PERL_VENDORLIB_EXP
#  if defined(WIN32)
    /* this picks up vendorarch as well */
	s = PerlEnv_vendorlib_path(PERL_FS_VERSION, &len);
	if (s)
	    incpush_use_sep(s, len, INCPUSH_ADD_SUB_DIRS|INCPUSH_CAN_RELOCATE);
#  else
	S_incpush_use_sep(aTHX_ STR_WITH_LEN(PERL_VENDORLIB_EXP),
			  INCPUSH_CAN_RELOCATE);
#  endif
#endif

#ifdef ARCHLIB_EXP
    S_incpush_use_sep(aTHX_ STR_WITH_LEN(ARCHLIB_EXP), INCPUSH_CAN_RELOCATE);
#endif

#ifndef PRIVLIB_EXP
#  define PRIVLIB_EXP "/usr/local/lib/perl5:/usr/local/lib/perl"
#endif

#if defined(WIN32)
    s = PerlEnv_lib_path(PERL_FS_VERSION, &len);
    if (s)
	incpush_use_sep(s, len, INCPUSH_ADD_SUB_DIRS|INCPUSH_CAN_RELOCATE);
#else
#  ifdef NETWARE
    S_incpush_use_sep(aTHX_ PRIVLIB_EXP, 0, INCPUSH_CAN_RELOCATE);
#  else
    S_incpush_use_sep(aTHX_ STR_WITH_LEN(PRIVLIB_EXP), INCPUSH_CAN_RELOCATE);
#  endif
#endif

#ifdef PERL_OTHERLIBDIRS
    S_incpush_use_sep(aTHX_ STR_WITH_LEN(PERL_OTHERLIBDIRS),
		      INCPUSH_ADD_VERSIONED_SUB_DIRS|INCPUSH_NOT_BASEDIR
		      |INCPUSH_CAN_RELOCATE);
#endif

    if (!TAINTING_get) {
#ifndef VMS
/*
 * It isn't possible to delete an environment variable with
 * PERL_USE_SAFE_PUTENV set unless unsetenv() is also available, so in that
 * case we treat PERL5LIB as undefined if it has a zero-length value.
 */
#if defined(PERL_USE_SAFE_PUTENV) && ! defined(HAS_UNSETENV)
	if (perl5lib && *perl5lib != '\0')
#else
	if (perl5lib)
#endif
	    incpush_use_sep(perl5lib, 0,
			    INCPUSH_ADD_OLD_VERS|INCPUSH_NOT_BASEDIR);
#else /* VMS */
	/* Treat PERL5?LIB as a possible search list logical name -- the
	 * "natural" VMS idiom for a Unix path string.  We allow each
	 * element to be a set of |-separated directories for compatibility.
	 */
	char buf[256];
	int idx = 0;
	if (vmstrnenv("PERL5LIB",buf,0,NULL,0))
	    do {
		incpush_use_sep(buf, 0,
				INCPUSH_ADD_OLD_VERS|INCPUSH_NOT_BASEDIR);
	    } while (vmstrnenv("PERL5LIB",buf,++idx,NULL,0));
#endif /* VMS */
    }

/* Use the ~-expanded versions of APPLLIB (undocumented),
    SITELIB and VENDORLIB for older versions
*/
#ifdef APPLLIB_EXP
    S_incpush_use_sep(aTHX_ STR_WITH_LEN(APPLLIB_EXP), INCPUSH_ADD_OLD_VERS
		      |INCPUSH_NOT_BASEDIR|INCPUSH_CAN_RELOCATE);
#endif

#if defined(SITELIB_STEM) && defined(PERL_INC_VERSION_LIST)
    /* Search for version-specific dirs below here */
    S_incpush_use_sep(aTHX_ STR_WITH_LEN(SITELIB_STEM),
		      INCPUSH_ADD_OLD_VERS|INCPUSH_CAN_RELOCATE);
#endif


#if defined(PERL_VENDORLIB_STEM) && defined(PERL_INC_VERSION_LIST)
    /* Search for version-specific dirs below here */
    S_incpush_use_sep(aTHX_ STR_WITH_LEN(PERL_VENDORLIB_STEM),
		      INCPUSH_ADD_OLD_VERS|INCPUSH_CAN_RELOCATE);
#endif

#ifdef PERL_OTHERLIBDIRS
    S_incpush_use_sep(aTHX_ STR_WITH_LEN(PERL_OTHERLIBDIRS),
		      INCPUSH_ADD_OLD_VERS|INCPUSH_ADD_ARCHONLY_SUB_DIRS
		      |INCPUSH_CAN_RELOCATE);
#endif
#endif /* !PERL_IS_MINIPERL */

    if (!TAINTING_get)
	S_incpush(aTHX_ STR_WITH_LEN("."), 0);
}

#if defined(DOSISH) || defined(__SYMBIAN32__)
#    define PERLLIB_SEP ';'
#else
#  if defined(VMS)
#    define PERLLIB_SEP '|'
#  else
#    define PERLLIB_SEP ':'
#  endif
#endif
#ifndef PERLLIB_MANGLE
#  define PERLLIB_MANGLE(s,n) (s)
#endif

#ifndef PERL_IS_MINIPERL
/* Push a directory onto @@INC if it exists.
   Generate a new SV if we do this, to save needing to copy the SV we push
   onto @@INC  */
STATIC SV *
S_incpush_if_exists(pTHX_ AV *const av, SV *dir, SV *const stem)
{
    Stat_t tmpstatbuf;

    PERL_ARGS_ASSERT_INCPUSH_IF_EXISTS;

    if (PerlLIO_stat(SvPVX_const(dir), &tmpstatbuf) >= 0 &&
	S_ISDIR(tmpstatbuf.st_mode)) {
	av_push(av, dir);
	dir = newSVsv(stem);
    } else {
	/* Truncate dir back to stem.  */
	SvCUR_set(dir, SvCUR(stem));
    }
    return dir;
}
#endif

STATIC SV *
S_mayberelocate(pTHX_ const char *const dir, STRLEN len, U32 flags)
{
    const U8 canrelocate = (U8)flags & INCPUSH_CAN_RELOCATE;
    SV *libdir;

    PERL_ARGS_ASSERT_MAYBERELOCATE;
    assert(len > 0);

    /* I am not convinced that this is valid when PERLLIB_MANGLE is
       defined to so something (in os2/os2.c), but the code has been
       this way, ignoring any possible changed of length, since
       760ac839baf413929cd31cc32ffd6dba6b781a81 (5.003_02) so I'll leave
       it be.  */
    libdir = newSVpvn(PERLLIB_MANGLE(dir, len), len);

#ifdef VMS
    {
	char *unix;

	if ((unix = tounixspec_ts(SvPV(libdir,len),NULL)) != NULL) {
	    len = strlen(unix);
	    while (len > 1 && unix[len-1] == '/') len--;  /* Cosmetic */
	    sv_usepvn(libdir,unix,len);
	}
	else
	    PerlIO_printf(Perl_error_log,
		          "Failed to unixify @@INC element \"%s\"\n",
			  SvPV_nolen_const(libdir));
    }
#endif

	/* Do the if() outside the #ifdef to avoid warnings about an unused
	   parameter.  */
	if (canrelocate) {
#ifdef PERL_RELOCATABLE_INC
	/*
	 * Relocatable include entries are marked with a leading .../
	 *
	 * The algorithm is
	 * 0: Remove that leading ".../"
	 * 1: Remove trailing executable name (anything after the last '/')
	 *    from the perl path to give a perl prefix
	 * Then
	 * While the @@INC element starts "../" and the prefix ends with a real
	 * directory (ie not . or ..) chop that real directory off the prefix
	 * and the leading "../" from the @@INC element. ie a logical "../"
	 * cleanup
	 * Finally concatenate the prefix and the remainder of the @@INC element
	 * The intent is that /usr/local/bin/perl and .../../lib/perl5
	 * generates /usr/local/lib/perl5
	 */
	    const char *libpath = SvPVX(libdir);
	    STRLEN libpath_len = SvCUR(libdir);
	    if (libpath_len >= 4 && memEQ (libpath, ".../", 4)) {
		/* Game on!  */
		SV * const caret_X = get_sv("\030", 0);
		/* Going to use the SV just as a scratch buffer holding a C
		   string:  */
		SV *prefix_sv;
		char *prefix;
		char *lastslash;

		/* $^X is *the* source of taint if tainting is on, hence
		   SvPOK() won't be true.  */
		assert(caret_X);
		assert(SvPOKp(caret_X));
		prefix_sv = newSVpvn_flags(SvPVX(caret_X), SvCUR(caret_X),
					   SvUTF8(caret_X));
		/* Firstly take off the leading .../
		   If all else fail we'll do the paths relative to the current
		   directory.  */
		sv_chop(libdir, libpath + 4);
		/* Don't use SvPV as we're intentionally bypassing taining,
		   mortal copies that the mg_get of tainting creates, and
		   corruption that seems to come via the save stack.
		   I guess that the save stack isn't correctly set up yet.  */
		libpath = SvPVX(libdir);
		libpath_len = SvCUR(libdir);

		/* This would work more efficiently with memrchr, but as it's
		   only a GNU extension we'd need to probe for it and
		   implement our own. Not hard, but maybe not worth it?  */

		prefix = SvPVX(prefix_sv);
		lastslash = strrchr(prefix, '/');

		/* First time in with the *lastslash = '\0' we just wipe off
		   the trailing /perl from (say) /usr/foo/bin/perl
		*/
		if (lastslash) {
		    SV *tempsv;
		    while ((*lastslash = '\0'), /* Do that, come what may.  */
			   (libpath_len >= 3 && memEQ(libpath, "../", 3)
			    && (lastslash = strrchr(prefix, '/')))) {
			if (lastslash[1] == '\0'
			    || (lastslash[1] == '.'
				&& (lastslash[2] == '/' /* ends "/."  */
				    || (lastslash[2] == '/'
					&& lastslash[3] == '/' /* or "/.."  */
					)))) {
			    /* Prefix ends "/" or "/." or "/..", any of which
			       are fishy, so don't do any more logical cleanup.
			    */
			    break;
			}
			/* Remove leading "../" from path  */
			libpath += 3;
			libpath_len -= 3;
			/* Next iteration round the loop removes the last
			   directory name from prefix by writing a '\0' in
			   the while clause.  */
		    }
		    /* prefix has been terminated with a '\0' to the correct
		       length. libpath points somewhere into the libdir SV.
		       We need to join the 2 with '/' and drop the result into
		       libdir.  */
		    tempsv = Perl_newSVpvf(aTHX_ "%s/%s", prefix, libpath);
		    SvREFCNT_dec(libdir);
		    /* And this is the new libdir.  */
		    libdir = tempsv;
		    if (TAINTING_get &&
			(PerlProc_getuid() != PerlProc_geteuid() ||
			 PerlProc_getgid() != PerlProc_getegid())) {
			/* Need to taint relocated paths if running set ID  */
			SvTAINTED_on(libdir);
		    }
		}
		SvREFCNT_dec(prefix_sv);
	    }
#endif
	}
    return libdir;
}

STATIC void
S_incpush(pTHX_ const char *const dir, STRLEN len, U32 flags)
{
#ifndef PERL_IS_MINIPERL
    const U8 using_sub_dirs
	= (U8)flags & (INCPUSH_ADD_VERSIONED_SUB_DIRS
		       |INCPUSH_ADD_ARCHONLY_SUB_DIRS|INCPUSH_ADD_OLD_VERS);
    const U8 add_versioned_sub_dirs
	= (U8)flags & INCPUSH_ADD_VERSIONED_SUB_DIRS;
    const U8 add_archonly_sub_dirs
	= (U8)flags & INCPUSH_ADD_ARCHONLY_SUB_DIRS;
#ifdef PERL_INC_VERSION_LIST
    const U8 addoldvers  = (U8)flags & INCPUSH_ADD_OLD_VERS;
#endif
#endif
    const U8 unshift     = (U8)flags & INCPUSH_UNSHIFT;
    const U8 push_basedir = (flags & INCPUSH_NOT_BASEDIR) ? 0 : 1;
    AV *const inc = GvAVn(PL_incgv);

    PERL_ARGS_ASSERT_INCPUSH;
    assert(len > 0);

    /* Could remove this vestigial extra block, if we don't mind a lot of
       re-indenting diff noise.  */
    {
	SV *const libdir = mayberelocate(dir, len, flags);
	/* Change 20189146be79a0596543441fa369c6bf7f85103f, to fix RT#6665,
	   arranged to unshift #! line -I onto the front of @@INC. However,
	   -I can add version and architecture specific libraries, and they
	   need to go first. The old code assumed that it was always
	   pushing. Hence to make it work, need to push the architecture
	   (etc) libraries onto a temporary array, then "unshift" that onto
	   the front of @@INC.  */
#ifndef PERL_IS_MINIPERL
	AV *const av = (using_sub_dirs) ? (unshift ? newAV() : inc) : NULL;

	/*
	 * BEFORE pushing libdir onto @@INC we may first push version- and
	 * archname-specific sub-directories.
	 */
	if (using_sub_dirs) {
	    SV *subdir = newSVsv(libdir);
#ifdef PERL_INC_VERSION_LIST
	    /* Configure terminates PERL_INC_VERSION_LIST with a NULL */
	    const char * const incverlist[] = { PERL_INC_VERSION_LIST };
	    const char * const *incver;
#endif

	    if (add_versioned_sub_dirs) {
		/* .../version/archname if -d .../version/archname */
		sv_catpvs(subdir, "/" PERL_FS_VERSION "/" ARCHNAME);
		subdir = S_incpush_if_exists(aTHX_ av, subdir, libdir);

		/* .../version if -d .../version */
		sv_catpvs(subdir, "/" PERL_FS_VERSION);
		subdir = S_incpush_if_exists(aTHX_ av, subdir, libdir);
	    }

#ifdef PERL_INC_VERSION_LIST
	    if (addoldvers) {
		for (incver = incverlist; *incver; incver++) {
		    /* .../xxx if -d .../xxx */
		    Perl_sv_catpvf(aTHX_ subdir, "/%s", *incver);
		    subdir = S_incpush_if_exists(aTHX_ av, subdir, libdir);
		}
	    }
#endif

	    if (add_archonly_sub_dirs) {
		/* .../archname if -d .../archname */
		sv_catpvs(subdir, "/" ARCHNAME);
		subdir = S_incpush_if_exists(aTHX_ av, subdir, libdir);

	    }

	    assert (SvREFCNT(subdir) == 1);
	    SvREFCNT_dec(subdir);
	}
#endif /* !PERL_IS_MINIPERL */
	/* finally add this lib directory at the end of @@INC */
	if (unshift) {
#ifdef PERL_IS_MINIPERL
	    const Size_t extra = 0;
#else
	    Size_t extra = av_tindex(av) + 1;
#endif
	    av_unshift(inc, extra + push_basedir);
	    if (push_basedir)
		av_store(inc, extra, libdir);
#ifndef PERL_IS_MINIPERL
	    while (extra--) {
		/* av owns a reference, av_store() expects to be donated a
		   reference, and av expects to be sane when it's cleared.
		   If I wanted to be naughty and wrong, I could peek inside the
		   implementation of av_clear(), realise that it uses
		   SvREFCNT_dec() too, so av's array could be a run of NULLs,
		   and so directly steal from it (with a memcpy() to inc, and
		   then memset() to NULL them out. But people copy code from the
		   core expecting it to be best practise, so let's use the API.
		   Although studious readers will note that I'm not checking any
		   return codes.  */
		av_store(inc, extra, SvREFCNT_inc(*av_fetch(av, extra, FALSE)));
	    }
	    SvREFCNT_dec(av);
#endif
	}
	else if (push_basedir) {
	    av_push(inc, libdir);
	}

	if (!push_basedir) {
	    assert (SvREFCNT(libdir) == 1);
	    SvREFCNT_dec(libdir);
	}
    }
}

STATIC void
S_incpush_use_sep(pTHX_ const char *p, STRLEN len, U32 flags)
{
    const char *s;
    const char *end;
    /* This logic has been broken out from S_incpush(). It may be possible to
       simplify it.  */

    PERL_ARGS_ASSERT_INCPUSH_USE_SEP;

    /* perl compiled with -DPERL_RELOCATABLE_INCPUSH will ignore the len
     * argument to incpush_use_sep.  This allows creation of relocatable
     * Perl distributions that patch the binary at install time.  Those
     * distributions will have to provide their own relocation tools; this
     * is not a feature otherwise supported by core Perl.
     */
#ifndef PERL_RELOCATABLE_INCPUSH
    if (!len)
#endif
	len = strlen(p);

    end = p + len;

    /* Break at all separators */
    while ((s = (const char*)memchr(p, PERLLIB_SEP, end - p))) {
	if (s == p) {
	    /* skip any consecutive separators */

	    /* Uncomment the next line for PATH semantics */
	    /* But you'll need to write tests */
	    /* av_push(GvAVn(PL_incgv), newSVpvs(".")); */
	} else {
	    incpush(p, (STRLEN)(s - p), flags);
	}
	p = s + 1;
    }
    if (p != end)
	incpush(p, (STRLEN)(end - p), flags);

}

void
Perl_call_list(pTHX_ I32 oldscope, AV *paramList)
{
    SV *atsv;
    VOL const line_t oldline = PL_curcop ? CopLINE(PL_curcop) : 0;
    CV *cv;
    STRLEN len;
    int ret;
    dJMPENV;

    PERL_ARGS_ASSERT_CALL_LIST;

    while (av_tindex(paramList) >= 0) {
	cv = MUTABLE_CV(av_shift(paramList));
	if (PL_savebegin) {
	    if (paramList == PL_beginav) {
		/* save PL_beginav for compiler */
		Perl_av_create_and_push(aTHX_ &PL_beginav_save, MUTABLE_SV(cv));
	    }
	    else if (paramList == PL_checkav) {
		/* save PL_checkav for compiler */
		Perl_av_create_and_push(aTHX_ &PL_checkav_save, MUTABLE_SV(cv));
	    }
	    else if (paramList == PL_unitcheckav) {
		/* save PL_unitcheckav for compiler */
		Perl_av_create_and_push(aTHX_ &PL_unitcheckav_save, MUTABLE_SV(cv));
	    }
	} else {
            SAVEFREESV(cv);
	}
	JMPENV_PUSH(ret);
	switch (ret) {
	case 0:
	    CALL_LIST_BODY(cv);
	    atsv = ERRSV;
	    (void)SvPV_const(atsv, len);
	    if (len) {
		PL_curcop = &PL_compiling;
		CopLINE_set(PL_curcop, oldline);
		if (paramList == PL_beginav)
		    sv_catpvs(atsv, "BEGIN failed--compilation aborted");
		else
		    Perl_sv_catpvf(aTHX_ atsv,
				   "%s failed--call queue aborted",
				   paramList == PL_checkav ? "CHECK"
				   : paramList == PL_initav ? "INIT"
				   : paramList == PL_unitcheckav ? "UNITCHECK"
				   : "END");
		while (PL_scopestack_ix > oldscope)
		    LEAVE;
		JMPENV_POP;
		Perl_croak(aTHX_ "%"SVf"", SVfARG(atsv));
	    }
	    break;
	case 1:
	    STATUS_ALL_FAILURE;
	    /* FALLTHROUGH */
	case 2:
	    /* my_exit() was called */
	    while (PL_scopestack_ix > oldscope)
		LEAVE;
	    FREETMPS;
	    SET_CURSTASH(PL_defstash);
	    PL_curcop = &PL_compiling;
	    CopLINE_set(PL_curcop, oldline);
	    JMPENV_POP;
	    my_exit_jump();
	    NOT_REACHED; /* NOTREACHED */
	case 3:
	    if (PL_restartop) {
		PL_curcop = &PL_compiling;
		CopLINE_set(PL_curcop, oldline);
		JMPENV_JUMP(3);
	    }
	    PerlIO_printf(Perl_error_log, "panic: restartop in call_list\n");
	    FREETMPS;
	    break;
	}
	JMPENV_POP;
    }
}

void
Perl_my_exit(pTHX_ U32 status)
{
    if (PL_exit_flags & PERL_EXIT_ABORT) {
	abort();
    }
    if (PL_exit_flags & PERL_EXIT_WARN) {
	PL_exit_flags |= PERL_EXIT_ABORT; /* Protect against reentrant calls */
	Perl_warn(aTHX_ "Unexpected exit %lu", (unsigned long)status);
	PL_exit_flags &= ~PERL_EXIT_ABORT;
    }
    switch (status) {
    case 0:
	STATUS_ALL_SUCCESS;
	break;
    case 1:
	STATUS_ALL_FAILURE;
	break;
    default:
	STATUS_EXIT_SET(status);
	break;
    }
    my_exit_jump();
}

void
Perl_my_failure_exit(pTHX)
{
#ifdef VMS
     /* We have been called to fall on our sword.  The desired exit code
      * should be already set in STATUS_UNIX, but could be shifted over
      * by 8 bits.  STATUS_UNIX_EXIT_SET will handle the cases where a
      * that code is set.
      *
      * If an error code has not been set, then force the issue.
      */
    if (MY_POSIX_EXIT) {

        /* According to the die_exit.t tests, if errno is non-zero */
        /* It should be used for the error status. */

	if (errno == EVMSERR) {
	    STATUS_NATIVE = vaxc$errno;
	} else {

            /* According to die_exit.t tests, if the child_exit code is */
            /* also zero, then we need to exit with a code of 255 */
            if ((errno != 0) && (errno < 256))
		STATUS_UNIX_EXIT_SET(errno);
            else if (STATUS_UNIX < 255) {
		STATUS_UNIX_EXIT_SET(255);
            }

	}

	/* The exit code could have been set by $? or vmsish which
	 * means that it may not have fatal set.  So convert
	 * success/warning codes to fatal with out changing
	 * the POSIX status code.  The severity makes VMS native
	 * status handling work, while UNIX mode programs use the
	 * the POSIX exit codes.
	 */
	 if ((STATUS_NATIVE & (STS$K_SEVERE|STS$K_ERROR)) == 0) {
	    STATUS_NATIVE &= STS$M_COND_ID;
	    STATUS_NATIVE |= STS$K_ERROR | STS$M_INHIB_MSG;
         }
    }
    else {
	/* Traditionally Perl on VMS always expects a Fatal Error. */
	if (vaxc$errno & 1) {

	    /* So force success status to failure */
	    if (STATUS_NATIVE & 1)
		STATUS_ALL_FAILURE;
	}
	else {
	    if (!vaxc$errno) {
		STATUS_UNIX = EINTR; /* In case something cares */
		STATUS_ALL_FAILURE;
	    }
	    else {
		int severity;
		STATUS_NATIVE = vaxc$errno; /* Should already be this */

		/* Encode the severity code */
		severity = STATUS_NATIVE & STS$M_SEVERITY;
		STATUS_UNIX = (severity ? severity : 1) << 8;

		/* Perl expects this to be a fatal error */
		if (severity != STS$K_SEVERE)
		    STATUS_ALL_FAILURE;
	    }
	}
    }

#else
    int exitstatus;
    if (errno & 255)
	STATUS_UNIX_SET(errno);
    else {
	exitstatus = STATUS_UNIX >> 8;
	if (exitstatus & 255)
	    STATUS_UNIX_SET(exitstatus);
	else
	    STATUS_UNIX_SET(255);
    }
#endif
    if (PL_exit_flags & PERL_EXIT_ABORT) {
	abort();
    }
    if (PL_exit_flags & PERL_EXIT_WARN) {
	PL_exit_flags |= PERL_EXIT_ABORT; /* Protect against reentrant calls */
	Perl_warn(aTHX_ "Unexpected exit failure %ld", (long)PL_statusvalue);
	PL_exit_flags &= ~PERL_EXIT_ABORT;
    }
    my_exit_jump();
}

STATIC void
S_my_exit_jump(pTHX)
{
    if (PL_e_script) {
	SvREFCNT_dec(PL_e_script);
	PL_e_script = NULL;
    }

    POPSTACK_TO(PL_mainstack);
    if (cxstack_ix >= 0) {
        dounwind(-1);
        cx_popblock(cxstack);
    }
    LEAVE_SCOPE(0);

    JMPENV_JUMP(2);
}

static I32
read_e_script(pTHX_ int idx, SV *buf_sv, int maxlen)
{
    const char * const p  = SvPVX_const(PL_e_script);
    const char *nl = strchr(p, '\n');

    PERL_UNUSED_ARG(idx);
    PERL_UNUSED_ARG(maxlen);

    nl = (nl) ? nl+1 : SvEND(PL_e_script);
    if (nl-p == 0) {
	filter_del(read_e_script);
	return 0;
    }
    sv_catpvn(buf_sv, p, nl-p);
    sv_chop(PL_e_script, nl);
    return 1;
}

/* removes boilerplate code at the end of each boot_Module xsub */
void
Perl_xs_boot_epilog(pTHX_ const I32 ax)
{
  if (PL_unitcheckav)
	call_list(PL_scopestack_ix, PL_unitcheckav);
    XSRETURN_YES;
}

/*
 * ex: set ts=8 sts=4 sw=4 et:
 */
@


1.29
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@d1838 2
@


1.28
log
@Update to perl 5.20.3

OK bluhm@@
@
text
@d6 1
a6 1
 *     by Larry Wall and others
a35 1
#include "charclass_invlists.h"
d96 1
a258 7
    /* Keep LC_NUMERIC in the C locale for backwards compatibility for XS
     * modules.  (Core operations that need the underlying locale change to it
     * temporarily).  An explicit call to POSIX::setlocale() still will cause
     * XS module failures, but this is how it has been for a long time [perl
     * #121317] */
    SET_NUMERIC_STANDARD();

a308 5
#if defined(__DYNAMIC__) && (defined(NeXT) || defined(__NeXT__))
    _dyld_lookup_and_bind
	("__environ", (unsigned long *) &environ_pointer, NULL);
#endif /* environ */

a327 1
    PL_apiversion = newSVpvs("v" PERL_API_VERSION_STRING);
a388 1
    PL_XPosix_ptrs[_CC_PSXSPC] = _new_invlist_C_array(XPosixSpace_invlist);
d393 4
d551 10
a560 1
            const int i = atoi(s);
d589 13
a927 1
    SvREFCNT_dec(PL_apiversion);
d989 3
d1058 1
d1063 3
d1075 1
d1077 3
d1087 4
a1322 1
    PL_debug = 0;
d1326 2
d1332 7
d1405 5
a1409 2
	    while(aTHXx->Imemory_debug_header.next != &(aTHXx->Imemory_debug_header))
		safesysfree(PERL_MEMORY_DEBUG_HEADER_SIZE + (char *)(aTHXx->Imemory_debug_header.next));
a1466 1
    dVAR;
d1503 3
a1505 3
        if (s && (atoi(s) == 1)) {
            unsigned char *seed= PERL_HASH_SEED;
            unsigned char *seed_end= PERL_HASH_SEED + PERL_HASH_SEED_BYTES;
d1519 8
d1543 1
a1543 2
	 const UV mask =
	   ~(UV)(PTRSIZE == 4 ? 3 : PTRSIZE == 8 ? 7 : PTRSIZE == 16 ? 15 : 0);
d1662 1
a1662 1
	/* FALL THROUGH */
d1719 3
a1766 3
#  ifdef PERL_NEW_COPY_ON_WRITE
			     " PERL_NEW_COPY_ON_WRITE"
#  endif
d1788 3
d1809 3
d1820 1
a1820 1
    PERL_UNUSED_ARG(items);
a1837 2
#undef PERL_BUILD_DATE

d1871 1
a1871 1
    VOL bool dosearch = FALSE;
d1954 1
a1954 1
	    /* FALL THROUGH */
d2035 1
a2035 1
	    /* FALL THROUGH */
d2140 4
a2143 3
        "BEGIN { do {local $!; -f q%c%"SVf"/buildcustomize.pl%c} and do q%c%"SVf"/buildcustomize.pl%c || die $@@ }",
							       0, *inc0, 0,
							       0, *inc0, 0));
d2156 2
a2157 2
							       0, sitelib, 0,
							       0, sitelib, 0));
d2227 1
a2227 1
    CvPADLIST(PL_compcv) = pad_new(0);
a2318 26
#ifdef PERL_MAD
    {
	const char *s;
    if (!TAINTING_get &&
        (s = PerlEnv_getenv("PERL_XMLDUMP"))) {
	PL_madskills = 1;
	PL_minus_c = 1;
	if (!s || !s[0])
	    PL_xmlfp = PerlIO_stdout();
	else {
	    PL_xmlfp = PerlIO_open(s, "w");
	    if (!PL_xmlfp)
		Perl_croak(aTHX_ "Can't open %s", s);
	}
	my_setenv("PERL_XMLDUMP", NULL);	/* hide from subprocs */
    }
    }

    {
	const char *s;
    if ((s = PerlEnv_getenv("PERL_MADSKILLS"))) {
	PL_madskills = atoi(s);
	my_setenv("PERL_MADSKILLS", NULL);	/* hide from subprocs */
    }
    }
#endif
d2361 4
a2364 2
    if ((s=PerlEnv_getenv("PERL_DEBUG_MSTATS")) && atoi(s) >= 2)
	dump_mstats("after compilation:");
a2384 1
    dVAR;
d2407 1
a2407 1
	/* FALL THROUGH */
a2441 1
    dVAR;
a2446 6
#ifdef PERL_MAD
	if (PL_xmlfp) {
	    xmldump_all();
	    exit(0);	/* less likely to core dump than my_exit(0) */
	}
#endif
d2459 1
a2459 1
	    sv_setiv(PL_DBsingle, 1);
d2486 1
a2486 1
    assert(0); /* NOTREACHED */
d2553 1
a2553 1
and the variable does not exist then NULL is returned.
d2627 1
a2627 1
with C<argv> (a NULL-terminated array of strings) as arguments.  See
a2640 1
    dVAR;
d2646 3
a2648 6
    if (argv) {
	while (*argv) {
	    mXPUSHs(newSVpv(*argv,0));
	    argv++;
	}
	PUTBACK;
d2650 1
d2702 16
a2717 2
Performs a callback to the Perl sub whose name is in the SV.  See
L<perlcall>.
d2726 1
a2726 1
    dVAR; dSP;
d2728 1
a2728 2
    UNOP method_unop;
    SVOP method_svop;
a2730 1
    I32 oldscope;
d2755 6
a2760 3
    EXTEND(PL_stack_sp, 1);
    if (!(flags & G_METHOD_NAMED))
        *++PL_stack_sp = sv;
a2761 1
    oldscope = PL_scopestack_ix;
d2773 3
d2777 3
a2779 6
            Zero(&method_svop, 1, SVOP);
            method_svop.op_next = (OP*)&myop;
            method_svop.op_ppaddr = PL_ppaddr[OP_METHOD_NAMED];
            method_svop.op_type = OP_METHOD_NAMED;
            method_svop.op_sv = sv;
            PL_op = (OP*)&method_svop;
d2781 2
a2782 5
            Zero(&method_unop, 1, UNOP);
            method_unop.op_next = (OP*)&myop;
            method_unop.op_ppaddr = PL_ppaddr[OP_METHOD];
            method_unop.op_type = OP_METHOD;
            PL_op = (OP*)&method_unop;
a2785 1

d2795 1
d2797 4
a2800 3
	PL_markstack_ptr--;
	create_eval_scope(flags|G_FAKINGEVAL);
	PL_markstack_ptr++;
d2815 1
a2815 1
	    /* FALL THROUGH */
d2822 1
a2822 1
	    assert(0); /* NOTREACHED */
d2840 5
a2844 1
	if (PL_scopestack_ix > oldscope)
d2846 1
d2866 1
a2866 1
as C<call_sv>, with the obvious exception of G_EVAL.  See L<perlcall>.
a2876 1
    dSP;
d2878 1
a2878 1
    VOL I32 oldmark = SP - PL_stack_base;
d2894 7
a2900 2
    EXTEND(PL_stack_sp, 1);
    *++PL_stack_sp = sv;
d2913 1
a2913 1
     * before a PUSHEVAL, which corrupts the stack after a croak */
d2933 1
a2933 1
	/* FALL THROUGH */
d2940 1
a2940 1
	assert(0); /* NOTREACHED */
a2980 1
    dVAR;
a3020 1
    dVAR;
d3119 1
d3122 1
a3122 1
    int i = 0;
d3128 1
a3128 1
	static const char debopts[] = "psltocPmfrxuUHXDSTRJvCAqMBL";
d3133 1
a3133 1
		i |= 1 << (d - debopts);
d3140 3
a3142 1
	i = atoi(*s);
d3149 1
a3149 6
#  ifdef EBCDIC
    if ((i & DEBUG_p_FLAG) && ckWARN_d(WARN_DEBUGGING))
	Perl_warner(aTHX_ packWARN(WARN_DEBUGGING),
		"-Dp not implemented on this platform\n");
#  endif
    return i;
d3186 1
a3186 1
	      SvGROW(PL_rs, (STRLEN)(UNISKIP(rschar) + 1));
d3189 1
a3189 1
	      SvCUR_set(PL_rs, UNISKIP(rschar));
d3289 1
d3293 2
d3366 1
a3366 1
	/* FALL THROUGH */
d3547 1
a3547 1
		" (%"SVf") built for "	ARCHNAME, level
d3561 1
a3561 1
		      "\n\nCopyright 1987-2015, Larry Wall\n");
a3622 1
    PERL_UNUSED_CONTEXT;
d3636 1
d3640 1
a3640 1
    Perl_croak(aTHX_ "dump is not supported");
a3650 1
    dVAR;
a3682 1
    dVAR;
d3716 1
a3716 1
    gv_SVadd(PL_errgv);
a3733 1
    dVAR;
d3735 1
d3743 2
d3748 6
a3753 5
	if (strnEQ(scriptname, "/dev/fd/", 8) && isDIGIT(scriptname[8]) ) {
            const char *s = scriptname + 8;
	    fdscript = atoi(s);
	    while (isDIGIT(*s))
		s++;
d3811 1
d3813 1
d3846 9
a3854 3
#if defined(HAS_FCNTL) && defined(F_SETFD)
    /* ensure close-on-exec */
    fcntl(PerlIO_fileno(rsfp), F_SETFD, 1);
d3857 3
a3859 2
    if (PerlLIO_fstat(PerlIO_fileno(rsfp), &tmpstatbuf) >= 0
        && S_ISDIR(tmpstatbuf.st_mode))
d3890 9
a3898 6

	PerlLIO_fstat(PerlIO_fileno(rsfp),&PL_statbuf);	/* may be either wrapped or real suid */
	if ((my_euid != my_uid && my_euid == PL_statbuf.st_uid && PL_statbuf.st_mode & S_ISUID)
	    ||
	    (my_egid != my_gid && my_egid == PL_statbuf.st_gid && PL_statbuf.st_mode & S_ISGID)
	   )
a3909 1
    dVAR;
a3941 1
    dVAR;
d3947 2
d3996 1
a3996 1
         && (argv[1][1] == 't' || argv[1][1] == 'T') )
a4007 1
    dVAR;
d4011 1
a4047 1
    dVAR;
d4049 1
d4066 4
d4073 4
d4080 4
d4099 2
a4100 1
    dVAR;
d4130 2
a4131 1
    Newx(PL_savestack,REASONABLE_but_at_least(128,SS_MAXPUSH),ANY);
d4133 2
a4134 1
    PL_savestack_max = REASONABLE_but_at_least(128,SS_MAXPUSH);
a4141 1
    dVAR;
a4196 1
    dVAR;
a4256 2
    dVAR;

d4303 1
d4305 1
a4428 1
    dVAR;
d4463 1
a4463 1
	if (my_trnlnm("PERL5LIB",buf,0))
d4466 1
a4466 1
	    } while (my_trnlnm("PERL5LIB",buf,++idx));
d4468 1
a4468 1
	    while (my_trnlnm("PERLLIB",buf,idx++))
d4498 1
a4498 1
	s = win32_get_sitelib(PERL_FS_VERSION, &len);
d4518 1
a4518 1
	s = win32_get_vendorlib(PERL_FS_VERSION, &len);
d4536 1
a4536 1
    s = win32_get_privlib(PERL_FS_VERSION, &len);
d4574 1
a4574 1
	if (my_trnlnm("PERL5LIB",buf,0))
d4578 1
a4578 1
	    } while (my_trnlnm("PERL5LIB",buf,++idx));
a4633 1
    dVAR;
a4787 1
    dVAR;
a4945 1
    dVAR;
d4947 1
a4947 1
    volatile const line_t oldline = PL_curcop ? CopLINE(PL_curcop) : 0;
d4971 1
a4971 2
	    if (!PL_madskills)
		SAVEFREESV(cv);
a4975 4
#ifdef PERL_MAD
	    if (PL_madskills)
		PL_madskills |= 16384;
#endif
a4976 4
#ifdef PERL_MAD
	    if (PL_madskills)
		PL_madskills &= ~16384;
#endif
d4999 1
a4999 1
	    /* FALL THROUGH */
d5010 1
a5010 1
	    assert(0); /* NOTREACHED */
a5027 1
    dVAR;
a5052 1
    dVAR;
a5145 2
    dVAR;

d5152 4
a5155 1
    dounwind(-1);
a5163 1
    dVAR;
d5180 9
a5189 6
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
@


1.27
log
@Stop embedding the build time in the Perl binary.

This is a backport of commit 6baa8d with the local addition of:
    undef PERL_BUILD_DATE

ok afresh1@@
@
text
@d2006 4
@


1.26
log
@Cope with ambiguous environments

from Ricardo Signes

ok deraadt@@
@
text
@d1779 13
a1791 2
#ifdef __DATE__
#  ifdef __TIME__
d1793 1
a1793 4
			      STR_WITH_LEN("Compiled at " __DATE__ " " __TIME__),
			      SVs_TEMP));
#  else
    PUSHs(Perl_newSVpvn_flags(aTHX_ STR_WITH_LEN("Compiled on " __DATE__),
a1794 1
#  endif
@


1.25
log
@Fix merge issues, remove excess files - match perl-5.20.2 dist
@
text
@d4280 1
d4282 2
d4289 1
d4296 20
a4315 2
	    sv = newSVpv(s+1, 0);
	    (void)hv_store(hv, old_var, s - old_var, sv, 0);
d4319 25
@


1.25.4.1
log
@Fix for perl CVE-2016-2381

Prior to this patch, when an environment variable "X" appears multiple times in
envp, perl could return different values for $ENV{"X"} than that provided by
getenv("X").  Further, subprocessses could inherit surprising environment
variables because of this.

from Ricardo Signes <rjbs cpan.org>

This problem was originally reported by Stephane Chazelas.

http://perl5.git.perl.org/perl.git/commit/7098efff946437a2db6013d12c4fc3193fc328ce
http://perl5.git.perl.org/perl.git/commit/2c2d7ae2ec598bff43f056060e4a83656066a4c4
@
text
@a4279 1
          STRLEN nlen;
a4280 2
          HV *dups = newHV();

a4285 1
            nlen = s - old_var;
d4292 2
a4293 20
            if (hv_exists(hv, old_var, nlen)) {
                const char *name = savepvn(old_var, nlen);

                /* make sure we use the same value as getenv(), otherwise code that
                   uses getenv() (like setlocale()) might see a different value to %ENV
                 */
                sv = newSVpv(PerlEnv_getenv(name), 0);

                /* keep a count of the dups of this name so we can de-dup environ later */
                if (hv_exists(dups, name, nlen))
                    ++SvIVX(*hv_fetch(dups, name, nlen, 0));
                else
                    (void)hv_store(dups, name, nlen, newSViv(1), 0);

                Safefree(name);
            }
            else {
                sv = newSVpv(s+1, 0);
            }
	    (void)hv_store(hv, old_var, nlen, sv, 0);
a4296 25
          if (HvKEYS(dups)) {
              /* environ has some duplicate definitions, remove them */
              HE *entry;
              hv_iterinit(dups);
              while ((entry = hv_iternext_flags(dups, 0))) {
                  STRLEN nlen;
                  const char *name = HePV(entry, nlen);
                  IV count = SvIV(HeVAL(entry));
                  IV i;
                  SV **valp = hv_fetch(hv, name, nlen, 0);

                  assert(valp);

                  /* try to remove any duplicate names, depending on the
                   * implementation used in my_setenv() the iteration might
                   * not be necessary, but let's be safe.
                   */
                  for (i = 0; i < count; ++i)
                      my_setenv(name, 0);

                  /* and set it back to the value we set $ENV{name} to */
                  my_setenv(name, SvPV_nolen(*valp));
              }
          }
          SvREFCNT_dec_NN(dups);
@


1.24
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d2928 1
a2928 1
Tells Perl to C<eval> the given string and return an SV* result.
d3517 1
a3517 1
		      "\n\nCopyright 1987-2014, Larry Wall\n");
@


1.24.2.1
log
@Fix for perl CVE-2016-2381

Prior to this patch, when an environment variable "X" appears multiple times in
envp, perl could return different values for $ENV{"X"} than that provided by
getenv("X").  Further, subprocessses could inherit surprising environment
variables because of this.

from Ricardo Signes <rjbs cpan.org>

This problem was originally reported by Stephane Chazelas.

http://perl5.git.perl.org/perl.git/commit/7098efff946437a2db6013d12c4fc3193fc328ce
http://perl5.git.perl.org/perl.git/commit/2c2d7ae2ec598bff43f056060e4a83656066a4c4
@
text
@a4279 1
          STRLEN nlen;
a4280 2
          HV *dups = newHV();

a4285 1
            nlen = s - old_var;
d4292 2
a4293 20
            if (hv_exists(hv, old_var, nlen)) {
                const char *name = savepvn(old_var, nlen);

                /* make sure we use the same value as getenv(), otherwise code that
                   uses getenv() (like setlocale()) might see a different value to %ENV
                 */
                sv = newSVpv(PerlEnv_getenv(name), 0);

                /* keep a count of the dups of this name so we can de-dup environ later */
                if (hv_exists(dups, name, nlen))
                    ++SvIVX(*hv_fetch(dups, name, nlen, 0));
                else
                    (void)hv_store(dups, name, nlen, newSViv(1), 0);

                Safefree(name);
            }
            else {
                sv = newSVpv(s+1, 0);
            }
	    (void)hv_store(hv, old_var, nlen, sv, 0);
a4296 25
          if (HvKEYS(dups)) {
              /* environ has some duplicate definitions, remove them */
              HE *entry;
              hv_iterinit(dups);
              while ((entry = hv_iternext_flags(dups, 0))) {
                  STRLEN nlen;
                  const char *name = HePV(entry, nlen);
                  IV count = SvIV(HeVAL(entry));
                  IV i;
                  SV **valp = hv_fetch(hv, name, nlen, 0);

                  assert(valp);

                  /* try to remove any duplicate names, depending on the
                   * implementation used in my_setenv() the iteration might
                   * not be necessary, but let's be safe.
                   */
                  for (i = 0; i < count; ++i)
                      my_setenv(name, 0);

                  /* and set it back to the value we set $ENV{name} to */
                  my_setenv(name, SvPV_nolen(*valp));
              }
          }
          SvREFCNT_dec_NN(dups);
@


1.23
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d36 1
a41 8
#ifdef USE_KERN_PROC_PATHNAME
#  include <sys/sysctl.h>
#endif

#ifdef USE_NSGETEXECUTABLEPATH
#  include <mach-o/dyld.h>
#endif

d140 1
a140 1
Perl_sys_term()
d234 4
d258 6
d314 2
d390 18
d522 1
a522 1
		  returned_errno, strerror(returned_errno));
d561 1
a561 1
        const int i = atoi(s);
d566 2
a567 2
        /* RT #114496, for perl_free */
        PL_perl_destruct_level = i;
d592 14
d680 1
a680 1
		msg.msg_iovlen = sizeof(vec)/sizeof(vec[0]);
d778 1
d864 2
a968 2
    PL_envgv = NULL;
    PL_incgv = NULL;
a970 1
    PL_argvgv = NULL;
a974 4
    PL_replgv = NULL;
    PL_DBgv = NULL;
    PL_DBline = NULL;
    PL_DBsub = NULL;
d982 15
d1041 1
d1043 5
d1056 5
a1061 6
        SvREFCNT_dec(PL_Posix_ptrs[i]);
        PL_Posix_ptrs[i] = NULL;

        SvREFCNT_dec(PL_L1Posix_ptrs[i]);
        PL_L1Posix_ptrs[i] = NULL;

d1137 6
a1280 1
    Safefree(PL_reg_poscache);
d1372 1
a1372 1
		safesysfree(sTHX + (char *)(aTHXx->Imemory_debug_header.next));
d1383 2
a1386 1
#    endif
a1387 3
#    ifdef NETWARE
	nw_delete_internal_host(host);
#    else
d1416 5
a1420 1
    if (PL_curinterp  && !PL_veto_cleanup)
a1436 79
STATIC void
S_set_caret_X(pTHX) {
    dVAR;
    GV* tmpgv = gv_fetchpvs("\030", GV_ADD|GV_NOTQUAL, SVt_PV); /* $^X */
    if (tmpgv) {
	SV *const caret_x = GvSV(tmpgv);
#if defined(OS2)
	sv_setpv(caret_x, os2_execname(aTHX));
#else
#  ifdef USE_KERN_PROC_PATHNAME
	size_t size = 0;
	int mib[4];
	mib[0] = CTL_KERN;
	mib[1] = KERN_PROC;
	mib[2] = KERN_PROC_PATHNAME;
	mib[3] = -1;

	if (sysctl(mib, 4, NULL, &size, NULL, 0) == 0
	    && size > 0 && size < MAXPATHLEN * MAXPATHLEN) {
	    sv_grow(caret_x, size);

	    if (sysctl(mib, 4, SvPVX(caret_x), &size, NULL, 0) == 0
		&& size > 2) {
		SvPOK_only(caret_x);
		SvCUR_set(caret_x, size - 1);
		SvTAINT(caret_x);
		return;
	    }
	}
#  elif defined(USE_NSGETEXECUTABLEPATH)
	char buf[1];
	uint32_t size = sizeof(buf);

	_NSGetExecutablePath(buf, &size);
	if (size < MAXPATHLEN * MAXPATHLEN) {
	    sv_grow(caret_x, size);
	    if (_NSGetExecutablePath(SvPVX(caret_x), &size) == 0) {
		char *const tidied = realpath(SvPVX(caret_x), NULL);
		if (tidied) {
		    sv_setpv(caret_x, tidied);
		    free(tidied);
		} else {
		    SvPOK_only(caret_x);
		    SvCUR_set(caret_x, size);
		}
		return;
	    }
	}
#  elif defined(HAS_PROCSELFEXE)
	char buf[MAXPATHLEN];
	int len = readlink(PROCSELFEXE_PATH, buf, sizeof(buf) - 1);

	/* On Playstation2 Linux V1.0 (kernel 2.2.1) readlink(/proc/self/exe)
	   includes a spurious NUL which will cause $^X to fail in system
	   or backticks (this will prevent extensions from being built and
	   many tests from working). readlink is not meant to add a NUL.
	   Normal readlink works fine.
	*/
	if (len > 0 && buf[len-1] == '\0') {
	    len--;
	}

	/* FreeBSD's implementation is acknowledged to be imperfect, sometimes
	   returning the text "unknown" from the readlink rather than the path
	   to the executable (or returning an error from the readlink). Any
	   valid path has a '/' in it somewhere, so use that to validate the
	   result. See http://www.freebsd.org/cgi/query-pr.cgi?pr=35703
	*/
	if (len > 0 && memchr(buf, '/', len)) {
	    sv_setpvn(caret_x, buf, len);
	    return;
	}
#  endif
	/* Fallback to this:  */
	sv_setpv(caret_x, PL_origargv[0]);
#endif
    }
}

d1586 1
a1586 1
	S_set_caret_X(aTHX);
d1670 6
d1870 1
a1870 1
#if SILENT_NO_TAINT_SUPPORT
d1872 1
a1872 1
#elif NO_TAINT_SUPPORT
d1885 1
a1885 1
#if SILENT_NO_TAINT_SUPPORT
d1887 1
a1887 1
#elif NO_TAINT_SUPPORT
d2002 1
a2002 1
#if SILENT_NO_TAINT_SUPPORT
d2004 1
a2004 1
#elif NO_TAINT_SUPPORT
d2041 1
a2041 1
#if SILENT_NO_TAINT_SUPPORT
d2043 1
a2043 1
#elif NO_TAINT_SUPPORT
d2064 1
a2064 1
    S_set_caret_X(aTHX);
d2078 2
d2082 1
a2082 1
							       "BEGIN { do {local $!; -f q%c%"SVf"/buildcustomize.pl%c} && do q%c%"SVf"/buildcustomize.pl%c }",
d2468 1
a2468 1
C<gv_fetchpv>. If C<GV_ADD> is set and the
d2495 1
a2495 1
to C<gv_fetchpv>. If C<GV_ADD> is set and the
d2524 1
a2524 1
C<gv_fetchpv>. If C<GV_ADD> is set and the
d2551 1
a2551 1
C<gv_fetchpvn_flags>. If C<GV_ADD> is set and the Perl subroutine does not
d2600 2
a2601 1
with C<argv> (a NULL-terminated array of strings) as arguments. See L<perlcall>.
d2663 1
d2667 3
d2671 1
a2671 2
    /* XXX: sv_2mortal(newSVpvn_share(methname, len)) can be faster */
    return call_sv(newSVpvn_flags(methname, len, SVs_TEMP), flags | G_METHOD);
d2690 2
a2691 1
    UNOP method_op;
d2720 2
a2721 1
    *++PL_stack_sp = sv;
d2734 18
a2751 8
    if (flags & G_METHOD) {
	Zero(&method_op, 1, UNOP);
	method_op.op_next = (OP*)&myop;
	method_op.op_ppaddr = PL_ppaddr[OP_METHOD];
	method_op.op_type = OP_METHOD;
	myop.op_ppaddr = PL_ppaddr[OP_ENTERSUB];
	myop.op_type = OP_ENTERSUB;
	PL_op = (OP*)&method_op;
d2824 2
a2825 2
Tells Perl to C<eval> the string in the SV. It supports the same flags
as C<call_sv>, with the obvious exception of G_EVAL. See L<perlcall>.
a2983 1
    PUTBACK;
a2985 1
    SPAGAIN;
d3075 1
d3084 1
a3084 1
	static const char debopts[] = "psltocPmfrxuUHXDSTRJvCAqMB";
d3173 1
d3175 1
d3182 1
d3390 1
a3390 1
#if SILENT_NO_TAINT_SUPPORT
d3392 1
a3392 1
#elif NO_TAINT_SUPPORT
a3468 3
	if (!sv_derived_from(PL_patchlevel, "version"))
	    upg_version(PL_patchlevel, TRUE);
#if !defined(DGUX)
d3470 2
a3471 1
	    SV* level= vstringify(PL_patchlevel);
d3473 1
d3475 1
a3475 1
	    SV *num = newSVpvs(PERL_PATCHNUM "*");
d3477 1
a3477 1
	    SV *num = newSVpvs(PERL_PATCHNUM);
d3480 11
a3490 7
		STRLEN level_len, num_len;
		char * level_str, * num_str;
		num_str = SvPV(num, num_len);
		level_str = SvPV(level, level_len);
		if (num_len>=level_len && strnEQ(num_str,level_str,level_len)) {
		    SvREFCNT_dec(level);
		    level= num;
d3492 1
a3492 2
		    Perl_sv_catpvf(aTHX_ level, " (%"SVf")", num);
		    SvREFCNT_dec(num);
d3495 3
a3497 1
 #endif
d3505 1
a3505 1
	    SvREFCNT_dec(level);
a3506 13
#else /* DGUX */
	PIO_stdout =  PerlIO_stdout();
/* Adjust verbose output as in the perl that ships with the DG/UX OS from EMC */
	PerlIO_printf(PIO_stdout,
		Perl_form(aTHX_ "\nThis is perl, %"SVf"\n",
		    SVfARG(vstringify(PL_patchlevel))));
	PerlIO_printf(PIO_stdout,
			Perl_form(aTHX_ "        built under %s at %s %s\n",
					OSNAME, __DATE__, __TIME__));
	PerlIO_printf(PIO_stdout,
			Perl_form(aTHX_ "        OS Specific Release: %s\n",
					OSVERS));
#endif /* !DGUX */
d3517 1
a3517 1
		      "\n\nCopyright 1987-2013, Larry Wall\n");
a3634 4
    /* As these are inside a structure, PERLVARI isn't capable of initialising
       them  */
    PL_reg_oldcurpm = PL_reg_curpm = NULL;
    PL_reg_poscache = PL_reg_starttry = NULL;
d3662 1
d3666 1
a3666 1
    PL_errgv = gv_HVadd(gv_fetchpvs("@@", GV_ADD|GV_NOTQUAL, SVt_PV));
d3670 1
d3808 1
a3808 1
            strerror(EISDIR));
d3827 4
a3830 4
    const UV  my_uid = PerlProc_getuid();
    const UV my_euid = PerlProc_geteuid();
    const UV  my_gid = PerlProc_getgid();
    const UV my_egid = PerlProc_getegid();
d3885 1
a3885 1
#if !NO_TAINT_SUPPORT
d3887 4
a3890 4
    const UV my_uid = PerlProc_getuid();
    const UV my_euid = PerlProc_geteuid();
    const UV my_gid = PerlProc_getgid();
    const UV my_egid = PerlProc_getegid();
d3922 4
a3925 4
    int uid  = PerlProc_getuid();
    int euid = PerlProc_geteuid();
    int gid  = PerlProc_getgid();
    int egid = PerlProc_getegid();
d3997 9
a4005 3
    PL_DBgv = gv_fetchpvs("DB::DB", GV_ADDMULTI, SVt_PVGV);
    PL_DBline = gv_fetchpvs("DB::dbline", GV_ADDMULTI, SVt_PVAV);
    PL_DBsub = gv_HVadd(gv_fetchpvs("DB::sub", GV_ADDMULTI, SVt_PVHV));
d4021 1
d4024 1
d4060 1
a4060 1
    Newx(PL_savestack,REASONABLE(128),ANY);
d4062 1
a4062 1
    PL_savestack_max = REASONABLE(128);
d4211 1
a4212 1
	(void)gv_AVadd(PL_argvgv);
d4216 1
a4216 1
	    av_push(GvAVn(PL_argvgv),sv);
d4256 1
d4557 1
a4557 1
	    while (unix[len-1] == '/') len--;  /* Cosmetic */
d4753 1
a4753 1
	    const U32 extra = 0;
d4755 1
a4755 1
	    U32 extra = av_len(av) + 1;
d4842 1
a4842 1
    while (av_len(paramList) >= 0) {
d4925 8
d5030 8
@


1.22
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@a60 4
#ifdef __BEOS__
#  define HZ 1000000
#endif

d241 1
a241 23
    /* set read-only and try to insure than we wont see REFCNT==0
       very often */

    SvREADONLY_on(&PL_sv_undef);
    SvREFCNT(&PL_sv_undef) = (~(U32)0)/2;

    sv_setpv(&PL_sv_no,PL_No);
    /* value lookup in void context - happens to have the side effect
       of caching the numeric forms. However, as &PL_sv_no doesn't contain
       a string that is a valid numer, we have to turn the public flags by
       hand:  */
    SvNV(&PL_sv_no);
    SvIV(&PL_sv_no);
    SvIOK_on(&PL_sv_no);
    SvNOK_on(&PL_sv_no);
    SvREADONLY_on(&PL_sv_no);
    SvREFCNT(&PL_sv_no) = (~(U32)0)/2;

    sv_setpv(&PL_sv_yes,PL_Yes);
    SvNV(&PL_sv_yes);
    SvIV(&PL_sv_yes);
    SvREADONLY_on(&PL_sv_yes);
    SvREFCNT(&PL_sv_yes) = (~(U32)0)/2;
d244 1
a244 1
    SvREFCNT(&PL_sv_placeholder) = (~(U32)0)/2;
d284 1
d289 13
a323 1
     * BeOS has those, but returns the wrong value.
d326 1
a326 1
#if defined(HAS_SYSCONF) && defined(_SC_CLK_TCK) && !defined(__BEOS__)
d521 1
d534 1
a534 1
#ifdef DEBUGGING
d538 8
a545 3
            const int i = atoi(s);
	    if (destruct_level < i)
		destruct_level = i;
d732 4
a735 4
    /* Do this now, because destroying ops can cause new SVs to be generated
       in Perl_pad_swipe, and when running with -DDEBUG_LEAKING_SCALARS they
       PL_curcop to point to a valid op from which the filename structure
       member is copied.  */
d761 6
a766 9
    if (PL_sv_objcount) {
	/*
	 * Try to destruct global references.  We do this first so that the
	 * destructors and destructees still exist.  Some sv's might remain.
	 * Non-referenced objects are on their own.
	 */
	sv_clean_objs();
	PL_sv_objcount = 0;
    }
a820 1
	CopSTASH_free(&PL_compiling);
d832 9
a840 3
    SvREFCNT_dec(PL_regex_padav);
    PL_regex_padav = NULL;
    PL_regex_pad = NULL;
d843 1
d868 3
a870 1
    PL_sawampersand = FALSE;	/* must save all match strings */
d981 5
a985 11
    /* clear utf8 character classes */
    SvREFCNT_dec(PL_utf8_alnum);
    SvREFCNT_dec(PL_utf8_alpha);
    SvREFCNT_dec(PL_utf8_space);
    SvREFCNT_dec(PL_utf8_graph);
    SvREFCNT_dec(PL_utf8_digit);
    SvREFCNT_dec(PL_utf8_upper);
    SvREFCNT_dec(PL_utf8_lower);
    SvREFCNT_dec(PL_utf8_print);
    SvREFCNT_dec(PL_utf8_punct);
    SvREFCNT_dec(PL_utf8_xdigit);
a993 10
    PL_utf8_alnum	= NULL;
    PL_utf8_alpha	= NULL;
    PL_utf8_space	= NULL;
    PL_utf8_graph	= NULL;
    PL_utf8_digit	= NULL;
    PL_utf8_upper	= NULL;
    PL_utf8_lower	= NULL;
    PL_utf8_print	= NULL;
    PL_utf8_punct	= NULL;
    PL_utf8_xdigit	= NULL;
d1002 10
a1018 1
    CopSTASH_free(&PL_compiling);
d1054 6
d1072 4
d1154 1
a1154 1
	register SV* svend;
a1206 6
#ifdef PERL_DEBUG_READONLY_OPS
    free(PL_slabs);
    PL_slabs = NULL;
    PL_slab_count = 0;
#endif

a1220 3
    Safefree(PL_reg_start_tmp);
    PL_reg_start_tmp = (char**)NULL;
    PL_reg_start_tmpl = 0;
a1234 1
    PL_formfeed = NULL;
d1236 2
a1237 2
    PL_tainting = FALSE;
    PL_taint_warn = FALSE;
d1304 1
a1304 2
	const char * const s = PerlEnv_getenv("PERL_DESTRUCT_LEVEL");
	if (!s || atoi(s) == 0) {
d1482 1
a1482 9

#if defined(USE_HASH_SEED) || defined(USE_HASH_SEED_EXPLICIT)
    /* [perl #22371] Algorimic Complexity Attack on Perl 5.6.1, 5.8.0
     * This MUST be done before any hash stores or fetches take place.
     * If you set PL_rehash_seed (and presumably also PL_rehash_seed_set)
     * yourself, it is your responsibility to provide a good random seed!
     * You can also define PERL_HASH_SEED in compile time, see hv.h. */
    if (!PL_rehash_seed_set)
	 PL_rehash_seed = get_hash_seed();
d1484 1
a1484 1
	const char * const s = PerlEnv_getenv("PERL_HASH_SEED_DEBUG");
d1486 14
a1499 2
	if (s && (atoi(s) == 1))
	    PerlIO_printf(Perl_debug_log, "HASH_SEED = %"UVuf"\n", PL_rehash_seed);
a1501 1

d1603 1
a1603 1
	assert (!PL_tainted);
d1679 1
a1679 1
    static char non_bincompat_options[] = 
d1686 3
d1698 24
d1734 12
d1767 3
d1831 1
a1831 1
    register char c;
d1883 6
d1890 3
a1892 3
	    if( !PL_tainting ) {
	         PL_taint_warn = TRUE;
	         PL_tainting = TRUE;
d1894 1
d1898 6
d1905 3
a1907 2
	    PL_tainting = TRUE;
	    PL_taint_warn = FALSE;
d2008 1
a2008 1
        !PL_tainting &&
d2015 6
d2022 3
a2024 2
	    PL_tainting = TRUE;
            PL_taint_warn = FALSE;
d2054 9
a2062 3
		    if( !PL_tainting ) {
		        PL_taint_warn = TRUE;
		        PL_tainting = TRUE;
d2064 1
d2075 1
a2075 1
    assert (!PL_tainted);
d2131 1
a2131 1
    assert (!PL_tainted);
d2191 1
a2191 1
#if defined(VMS) || defined(WIN32) || defined(DJGPP) || defined(__CYGWIN__) || defined(EPOC) || defined(SYMBIAN)
d2274 2
a2275 1
    if ((s = PerlEnv_getenv("PERL_XMLDUMP"))) {
d2299 1
a2299 2
    if(linestr_sv)
	SvREFCNT_dec(linestr_sv);
d2420 3
a2422 2
    DEBUG_r(PerlIO_printf(Perl_debug_log, "%s $` $& $' support.\n",
                    PL_sawampersand ? "Enabling" : "Omitting"));
d2449 2
a2450 1
	Perl_pending_Slabs_to_ro(aTHX);
d2470 1
a2470 1
    /* NOTREACHED */
d2578 3
a2583 3

    PERL_ARGS_ASSERT_GET_CVN_FLAGS;

d2585 1
a2585 4
	SV *const sv = newSVpvn_flags(name, len, flags & SVf_UTF8);
    	return newSUB(start_subparse(FALSE, 0),
		      newSVOP(OP_CONST, 0, sv),
		      NULL, NULL);
d2619 1
a2619 1
Perl_call_argv(pTHX_ const char *sub_name, I32 flags, register char **argv)
a2718 1
    myop.op_next = NULL;
d2737 1
a2737 1
	PL_op->op_private |= OPpENTERSUB_DB;
d2741 1
a2741 1
	method_op.op_next = PL_op;
d2781 1
a2781 1
	    /* NOTREACHED */
d2848 1
a2848 1
    Zero(PL_op, 1, UNOP);
a2853 1
    myop.op_next = NULL;
d2859 3
d2890 1
a2890 1
	/* NOTREACHED */
a2931 1
    dSP;
d2939 5
a2943 3
    SPAGAIN;
    sv = POPs;
    PUTBACK;
d2945 6
a2950 2
    if (croak_on_error && SvTRUE(ERRSV)) {
	Perl_croak(aTHX_ "%s", SvPVx_nolen_const(ERRSV));
d3062 1
d3082 1
a3082 1
	for (; isALNUM(**s); (*s)++) {
d3093 1
a3093 1
	for (; isALNUM(**s); (*s)++) ;
d3187 1
a3187 1
	if (*s == 't' && !isALNUM(s[1])) {
d3210 1
a3210 1
	    while(isALNUM(*s) || *s==':') ++s;
d3238 1
a3238 1
	for (s++; isALNUM(*s); s++) ;
d3331 1
a3331 1
	    while(isALNUM(*s) || *s==':') {
d3383 7
a3389 1
        if (!PL_tainting)
d3391 1
d3461 1
d3473 12
a3484 7

	    if (sv_len(num)>=sv_len(level) && strnEQ(SvPV_nolen(num),SvPV_nolen(level),sv_len(level))) {
		SvREFCNT_dec(level);
		level= num;
	    } else {
		Perl_sv_catpvf(aTHX_ level, " (%"SVf")", num);
		SvREFCNT_dec(num);
d3487 2
a3488 1
	    PerlIO_printf(PerlIO_stdout(),
d3497 1
d3499 1
a3499 1
	PerlIO_printf(PerlIO_stdout(),
d3502 1
a3502 1
	PerlIO_printf(PerlIO_stdout(),
d3505 1
a3505 1
	PerlIO_printf(PerlIO_stdout(),
d3511 1
a3511 1
	    PerlIO_printf(PerlIO_stdout(),
d3518 2
a3519 2
	PerlIO_printf(PerlIO_stdout(),
		      "\n\nCopyright 1987-2012, Larry Wall\n");
d3521 1
a3521 1
	PerlIO_printf(PerlIO_stdout(),
d3525 1
a3525 1
	PerlIO_printf(PerlIO_stdout(),
d3530 1
a3530 1
	PerlIO_printf(PerlIO_stdout(),
a3533 12
#ifdef atarist
	PerlIO_printf(PerlIO_stdout(),
		      "atariST series port, ++jrb  bammi@@cadence.com\n");
#endif
#ifdef __BEOS__
	PerlIO_printf(PerlIO_stdout(),
		      "BeOS port Copyright Tom Spindler, 1997-1999\n");
#endif
#ifdef MPE
	PerlIO_printf(PerlIO_stdout(),
		      "MPE/iX port Copyright by Mark Klein and Mark Bixby, 1996-2003\n");
#endif
d3535 1
a3535 1
	PerlIO_printf(PerlIO_stdout(),
d3539 2
a3540 6
	PerlIO_printf(PerlIO_stdout(),
		      "Stratus VOS port by Paul.Green@@stratus.com, 1997-2002\n");
#endif
#ifdef __OPEN_VM
	PerlIO_printf(PerlIO_stdout(),
		      "VM/ESA port by Neale Ferguson, 1998-1999\n");
d3543 1
a3543 1
	PerlIO_printf(PerlIO_stdout(),
a3545 4
#ifdef EPOC
	PerlIO_printf(PerlIO_stdout(),
		      "EPOC port by Olaf Flebbe, 1999-2002\n");
#endif
d3547 3
a3549 2
	PerlIO_printf(PerlIO_stdout(),"WINCE port by Rainer Keuchel, 2001-2002\n");
	PerlIO_printf(PerlIO_stdout(),"Built on " __DATE__ " " __TIME__ "\n\n");
d3553 1
a3553 1
	PerlIO_printf(PerlIO_stdout(),
d3559 1
a3559 1
	PerlIO_printf(PerlIO_stdout(),
d3574 4
a3595 1
#    include <lib$routines.h>
d3697 1
d3807 7
d3859 1
a3859 1
    register const char *s2;
d3887 3
d3898 2
a3899 1
    PL_tainting |= (my_uid && (my_euid != my_uid || my_egid != my_gid));
d4181 1
a4181 1
Perl_init_argv_symbols(pTHX_ register int argc, register char **argv)
d4221 5
d4229 1
a4229 1
S_init_postdump_symbols(pTHX_ register int argc, register char **argv, register char **env)
d4236 1
a4236 1
    PL_toptarget = newSV_type(SVt_PVFM);
d4238 1
a4238 1
    PL_bodytarget = newSV_type(SVt_PVFM);
d4316 1
a4316 1
    if (!PL_tainting) {
d4432 1
a4432 1
    if (!PL_tainting) {
d4489 1
a4489 1
    if (!PL_tainting)
d4493 1
a4493 1
#if defined(DOSISH) || defined(EPOC) || defined(__SYMBIAN32__)
d4539 6
a4544 10
	if (len) {
	    /* I am not convinced that this is valid when PERLLIB_MANGLE is
	       defined to so something (in os2/os2.c), but the code has been
	       this way, ignoring any possible changed of length, since
	       760ac839baf413929cd31cc32ffd6dba6b781a81 (5.003_02) so I'll leave
	       it be.  */
	    libdir = newSVpvn(PERLLIB_MANGLE(dir, len), len);
	} else {
	    libdir = newSVpv(PERLLIB_MANGLE(dir, 0), 0);
	}
d4651 1
a4651 1
		    if (PL_tainting &&
d4901 1
a4901 1
	    /* NOTREACHED */
d5061 1
a5061 1
 * indent-tabs-mode: t
d5064 1
a5064 1
 * ex: set ts=8 sts=4 sw=4 noet:
@


1.21
log
@merge in perl 5.12.2 plus local changes
@
text
@d5 2
a6 2
 *    2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010 by Larry Wall
 *    and others
d16 1
a16 1
 *              --from Bilbo's song of Eärendil
d27 4
d41 6
a46 3
/* XXX If this causes problems, set i_unistd=undef in the hint file.  */
#ifdef I_UNISTD
#include <unistd.h>
a49 3
#  ifdef I_SYS_WAIT
#   include <sys/wait.h>
#  endif
d80 1
a80 2
/* Drop everything. Heck, don't even try to call it */
#  define validate_suid(validarg, scriptname, fdscript, suidscript, linestr_sv, rsfp) NOOP
d82 1
a82 2
/* Drop almost everything */
#  define validate_suid(validarg, scriptname, fdscript, suidscript, linestr_sv, rsfp) S_validate_suid(aTHX_ rsfp)
a84 6
#define CALL_BODY_EVAL(myop) \
    if (PL_op == (myop)) \
	PL_op = PL_ppaddr[OP_ENTEREVAL](aTHX); \
    if (PL_op) \
	CALLRUNOPS(aTHX);

d93 1
a93 1
    call_sv(MUTABLE_SV((cv)), G_EVAL|G_DISCARD);
d106 1
d348 1
d563 2
a564 1
        if (PL_endav && !PL_minus_c)
d566 1
d576 1
a576 1
    if (CALL_FPTR(PL_threadhook)(aTHX)) {
d753 4
d759 1
a759 1
    PL_dirty = TRUE;
a775 2
	if (PL_defoutgv && !SvREFCNT(PL_defoutgv))
	    PL_defoutgv = NULL; /* may have been freed */
a836 3
    /* reset so print() ends up where we expect */
    setdefout(NULL);

a871 1
    PL_doextract    = FALSE;
d878 1
a906 8
    /* clean up after study() */
    SvREFCNT_dec(PL_lastscream);
    PL_lastscream = NULL;
    Safefree(PL_screamfirst);
    PL_screamfirst = 0;
    Safefree(PL_screamnext);
    PL_screamnext  = 0;

a984 1
    SvREFCNT_dec(PL_utf8_ascii);
a986 1
    SvREFCNT_dec(PL_utf8_cntrl);
d1001 1
a1002 1
    PL_utf8_ascii	= NULL;
a1004 1
    PL_utf8_cntrl	= NULL;
d1019 1
d1024 2
a1025 2
    Perl_refcounted_he_free(aTHX_ PL_compiling.cop_hints_hash);
    PL_compiling.cop_hints_hash = NULL;
d1032 2
d1063 6
a1114 1
	HvFILL(PL_strtab) = 0;
d1158 1
a1158 1
		if (SvTYPE(sv) != SVTYPEMASK) {
d1162 2
a1163 1
			"\tallocated at %s:%d %s %s%s; serial %"UVuf"\n",
d1171 1
a1171 1
			sv->sv_debug_cloned ? " (cloned)" : "",
a1235 2
    Safefree(PL_psig_pend);
    PL_psig_pend = (int*)NULL;
a1386 35
#ifdef HAS_PROCSELFEXE
/* This is a function so that we don't hold on to MAXPATHLEN
   bytes of stack longer than necessary
 */
STATIC void
S_procself_val(pTHX_ SV *sv, const char *arg0)
{
    char buf[MAXPATHLEN];
    int len = readlink(PROCSELFEXE_PATH, buf, sizeof(buf) - 1);

    /* On Playstation2 Linux V1.0 (kernel 2.2.1) readlink(/proc/self/exe)
       includes a spurious NUL which will cause $^X to fail in system
       or backticks (this will prevent extensions from being built and
       many tests from working). readlink is not meant to add a NUL.
       Normal readlink works fine.
     */
    if (len > 0 && buf[len-1] == '\0') {
      len--;
    }

    /* FreeBSD's implementation is acknowledged to be imperfect, sometimes
       returning the text "unknown" from the readlink rather than the path
       to the executable (or returning an error from the readlink).  Any valid
       path has a '/' in it somewhere, so use that to validate the result.
       See http://www.freebsd.org/cgi/query-pr.cgi?pr=35703
    */
    if (len > 0 && memchr(buf, '/', len)) {
	sv_setpvn(sv,buf,len);
    }
    else {
	sv_setpv(sv,arg0);
    }
}
#endif /* HAS_PROCSELFEXE */

d1392 3
a1394 2
#ifdef HAS_PROCSELFEXE
	S_procself_val(aTHX_ GvSV(tmpgv), PL_origargv[0]);
d1396 66
a1461 5
#ifdef OS2
	sv_setpv(GvSVn(tmpgv), os2_execname(aTHX));
#else
	sv_setpv(GvSVn(tmpgv),PL_origargv[0]);
#endif
d1474 6
d1496 1
a1496 1
     * If you set PL_rehash_seed (and assumedly also PL_rehash_seed_set)
d1634 1
a1634 1
	if (PL_unitcheckav)
d1636 3
a1638 1
	if (PL_checkav)
d1640 1
d1651 2
a1652 2
	PL_curstash = PL_defstash;
	if (PL_unitcheckav)
d1654 3
a1656 1
	if (PL_checkav)
d1658 1
d1699 3
d1714 6
d1726 3
d1735 6
d1757 1
a1757 1
#if defined(__DATE__) && !defined(__OpenBSD__)
d1797 1
d1802 1
a1802 1
    SV *linestr_sv = newSV_type(SVt_PVIV);
d1804 1
d1806 1
a1806 2
    SvGROW(linestr_sv, 80);
    sv_setpvs(linestr_sv,"");
d1926 1
a1926 1
	    PL_doextract = TRUE;
d1938 6
a1943 9
	    /* catch use of gnu style long options */
	    if (strEQ(s, "version")) {
		s = (char *)"v";
		goto reswitch;
	    }
	    if (strEQ(s, "help")) {
		s = (char *)"h";
		goto reswitch;
	    }
d2010 8
a2017 1
#if defined(USE_SITECUSTOMIZE) && !defined(PERL_IS_MINIPERL)
d2019 32
a2050 7
	/* SITELIB_EXP is a function call on Win32.
	   The games with local $! are to avoid setting errno if there is no
	   sitecustomize script.  */
	const char *const sitelib = SITELIB_EXP;
	(void)Perl_av_create_and_unshift_one(aTHX_ &PL_preambleav,
					     Perl_newSVpvf(aTHX_
							   "BEGIN { do {local $!; -f '%s/sitecustomize.pl'} && do '%s/sitecustomize.pl' }", sitelib, sitelib));
a2067 1
    /* Set $^X early so that it can be used for relocatable paths in @@INC  */
a2068 3
    TAINT;
    S_set_caret_X(aTHX);
    TAINT_NOT;
d2074 5
a2078 1
	open_script(scriptname, dosearch, &suidscript, &rsfp);
d2080 1
a2080 2
	validate_suid(validarg, scriptname, fdscript, suidscript,
		      linestr_sv, rsfp);
d2098 1
a2098 1
	if (PL_doextract) {
d2105 2
d2234 4
a2237 1
    lex_start(linestr_sv, rsfp, TRUE);
d2246 1
a2246 1
    if (yyparse() || PL_parser->error_count) {
d2255 1
a2255 1
    PL_curstash = PL_defstash;
d2282 1
d2326 1
a2326 1
	PL_curstash = PL_defstash;
d2328 2
a2329 1
	    PL_endav && !PL_minus_c)
d2331 1
d2343 1
a2343 1
	PerlIO_printf(Perl_error_log, "panic: restartop\n");
d2380 2
a2381 1
	if (PL_initav)
d2383 1
d2391 2
d2394 1
d2439 3
a2441 2
Returns the AV of the specified Perl array.  C<flags> are passed to
C<gv_fetchpv>. If C<GV_ADD> is set and the
d2445 2
d2548 4
a2551 1
Performs a callback to the specified Perl sub.  See L<perlcall>.
d2716 1
a2716 1
	    PL_curstash = PL_defstash;
d2723 1
d2758 2
a2759 1
Tells Perl to C<eval> the string in the SV.
d2807 6
a2812 1
	CALL_BODY_EVAL((OP*)&myop);
d2823 1
a2823 1
	PL_curstash = PL_defstash;
d2830 1
d2835 1
d2919 1
a2919 1
S_usage(pTHX_ const char *name)		/* XXX move this out into a module ? */
d2924 2
d2927 30
a2956 29
"-0[octal]         specify record separator (\\0, if no argument)",
"-a                autosplit mode with -n or -p (splits $_ into @@F)",
"-C[number/list]   enables the listed Unicode features",
"-c                check syntax only (runs BEGIN and CHECK blocks)",
"-d[:debugger]     run program under debugger",
"-D[number/list]   set debugging flags (argument is a bit mask or alphabets)",
"-e program        one line of program (several -e's allowed, omit programfile)",
"-E program        like -e, but enables all optional features",
"-f                don't do $sitelib/sitecustomize.pl at startup",
"-F/pattern/       split() pattern for -a switch (//'s are optional)",
"-i[extension]     edit <> files in place (makes backup if extension supplied)",
"-Idirectory       specify @@INC/#include directory (several -I's allowed)",
"-l[octal]         enable line ending processing, specifies line terminator",
"-[mM][-]module    execute \"use/no module...\" before executing program",
"-n                assume \"while (<>) { ... }\" loop around program",
"-p                assume loop like -n but print line also, like sed",
"-s                enable rudimentary parsing for switches after programfile",
"-S                look for programfile using PATH environment variable",
"-t                enable tainting warnings",
"-T                enable tainting checks",
"-u                dump core after parsing program",
"-U                allow unsafe operations",
"-v                print version, subversion (includes VERY IMPORTANT perl info)",
"-V[:variable]     print configuration summary (or a single Config.pm variable)",
"-w                enable many useful warnings (RECOMMENDED)",
"-W                enable all warnings",
"-x[directory]     strip off text before #!perl line and perhaps cd to directory",
"-X                disable all warnings",
"\n",
d2960 1
d2962 3
a2964 5
    PERL_ARGS_ASSERT_USAGE;

    PerlIO_printf(PerlIO_stdout(),
		  "\nUsage: %s [switches] [--] [programfile] [arguments]",
		  name);
d2966 2
a2967 1
	PerlIO_printf(PerlIO_stdout(), "\n  %s", *p++);
d2978 25
a3002 25
      " Debugging flag values: (see also -d)",
      "  p  Tokenizing and parsing (with v, displays parse stack)",
      "  s  Stack snapshots (with v, displays all stacks)",
      "  l  Context (loop) stack processing",
      "  t  Trace execution",
      "  o  Method and overloading resolution",
      "  c  String/numeric conversions",
      "  P  Print profiling info, source file input state",
      "  m  Memory and SV allocation",
      "  f  Format processing",
      "  r  Regular expression parsing and execution",
      "  x  Syntax tree dump",
      "  u  Tainting checks",
      "  H  Hash dump -- usurps values()",
      "  X  Scratchpad allocation",
      "  D  Cleaning up",
      "  T  Tokenising",
      "  R  Include reference counts of dumped variables (eg when using -Ds)",
      "  J  Do not s,t,P-debug (Jump over) opcodes within package DB",
      "  v  Verbose: use in conjunction with other flags",
      "  C  Copy On Write",
      "  A  Consistency checks on internal structures",
      "  q  quiet - currently only suppresses the 'EXECUTING' message",
      "  M  trace smart match resolution",
      "  B  dump suBroutine definitions, including special Blocks like BEGIN",
d3028 1
a3028 1
      while (*p) PerlIO_printf(PerlIO_stdout(), "%s\n", *p++);
d3126 10
a3135 3
	    const char *start = ++s;
	    const char *const end = s + strlen(s);
	    SV * const sv = newSVpvs("use Devel::");
d3137 4
a3140 1
	    /* We now allow -d:Module=Foo,Bar */
d3174 1
a3174 2
	usage(PL_origargv[0]);
	my_exit(0);
d3313 1
d3315 1
a3315 1
	    TOO_LATE_FOR('t');
a3316 5
        return s;
    case 'T':
	if (!PL_tainting)
	    TOO_LATE_FOR('T');
	s++;
d3327 58
d3435 1
a3435 1
		      "\n\nCopyright 1987-2010, Larry Wall\n");
a3501 43
    case 'w':
	if (! (PL_dowarn & G_WARN_ALL_MASK)) {
	    PL_dowarn |= G_WARN_ON;
	}
	s++;
	return s;
    case 'W':
	PL_dowarn = G_WARN_ALL_ON|G_WARN_ON;
        if (!specialWARN(PL_compiling.cop_warnings))
            PerlMemShared_free(PL_compiling.cop_warnings);
	PL_compiling.cop_warnings = pWARN_ALL ;
	s++;
	return s;
    case 'X':
	PL_dowarn = G_WARN_ALL_OFF;
        if (!specialWARN(PL_compiling.cop_warnings))
            PerlMemShared_free(PL_compiling.cop_warnings);
	PL_compiling.cop_warnings = pWARN_NONE ;
	s++;
	return s;
    case '*':
    case ' ':
        while( *s == ' ' )
          ++s;
	if (s[0] == '-')	/* Additional switches on #! line. */
	    return s+1;
	break;
    case '-':
    case 0:
#if defined(WIN32) || !defined(PERL_STRICT_CR)
    case '\r':
#endif
    case '\n':
    case '\t':
	break;
#ifdef ALTERNATE_SHEBANG
    case 'S':			/* OS/2 needs -S on "extproc" line. */
	break;
#endif
    default:
	Perl_croak(aTHX_ "Can't emulate -%.1s on #! line",s);
    }
    return NULL;
d3543 2
a3544 2
#  define PERLVAR(var,type)
#  define PERLVARA(var,n,type)
d3546 2
a3547 2
#    define PERLVARI(var,type,init)		aTHX->var = init;
#    define PERLVARIC(var,type,init)	aTHX->var = init;
d3549 2
a3550 2
#    define PERLVARI(var,type,init)	PERL_GET_INTERP->var = init;
#    define PERLVARIC(var,type,init)	PERL_GET_INTERP->var = init;
d3558 4
a3561 4
#  define PERLVAR(var,type)
#  define PERLVARA(var,n,type)
#  define PERLVARI(var,type,init)	PL_##var = init;
#  define PERLVARIC(var,type,init)	PL_##var = init;
d3581 1
a3581 1
    PL_curstash = PL_defstash = newHV();
d3614 1
a3614 1
    PL_curstash = PL_defstash;
d3623 2
a3624 3
STATIC int
S_open_script(pTHX_ const char *scriptname, bool dosearch,
	      bool *suidscript, PerlIO **rsfpp)
d3627 1
d3677 1
a3677 6
	*rsfpp = PerlIO_fdopen(fdscript,PERL_SCRIPT_MODE);
#       if defined(HAS_FCNTL) && defined(F_SETFD)
	    if (*rsfpp)
                /* ensure close-on-exec */
	        fcntl(PerlIO_fileno(*rsfpp),F_SETFD,1);
#       endif
d3681 1
a3681 1
	*rsfpp = PerlIO_stdin();
d3716 1
a3716 1
	*rsfpp = PerlIO_open(scriptname,PERL_SCRIPT_MODE);
a3724 5
#       if defined(HAS_FCNTL) && defined(F_SETFD)
	    if (*rsfpp)
                /* ensure close-on-exec */
	        fcntl(PerlIO_fileno(*rsfpp),F_SETFD,1);
#       endif
d3726 1
a3726 1
    if (!*rsfpp) {
d3734 5
a3738 1
    return fdscript;
d3755 5
d3762 1
a3762 1
    if (PL_euid != PL_uid || PL_egid != PL_gid) {	/* (suidperl doesn't exist, in fact) */
d3766 1
a3766 1
	if ((PL_euid != PL_uid && PL_euid == PL_statbuf.st_uid && PL_statbuf.st_mode & S_ISUID)
d3768 1
a3768 1
	    (PL_egid != PL_gid && PL_egid == PL_statbuf.st_gid && PL_statbuf.st_mode & S_ISGID)
d3789 1
a3789 1
    while (PL_doextract) {
d3793 11
a3803 14
	if (*s == '#' && s[1] == '!' && ((s = instr(s,"perl")) || (s = instr(s2,"PERL")))) {
	    PerlIO_ungetc(rsfp, '\n');		/* to keep line count right */
	    PL_doextract = FALSE;
	    while (*s && !(isSPACE (*s) || *s == '#')) s++;
	    s2 = s;
	    while (*s == ' ' || *s == '\t') s++;
	    if (*s++ == '-') {
		while (isDIGIT(s2[-1]) || s2[-1] == '-' || s2[-1] == '.'
		       || s2[-1] == '_') s2--;
		if (strnEQ(s2-4,"perl",4))
		    while ((s = moreswitches(s)))
			;
	    }
	}
d3812 5
a3816 8
    PL_uid = PerlProc_getuid();
    PL_euid = PerlProc_geteuid();
    PL_gid = PerlProc_getgid();
    PL_egid = PerlProc_getegid();
#ifdef VMS
    PL_uid |= PL_gid << 16;
    PL_euid |= PL_egid << 16;
#endif
d3818 2
a3819 2
    CHECK_MALLOC_TAINT(PL_uid && (PL_euid != PL_uid || PL_egid != PL_gid));
    PL_tainting |= (PL_uid && (PL_euid != PL_uid || PL_egid != PL_gid));
d3885 1
a3885 1
    if (PL_euid != PL_uid)
d3887 1
a3887 1
    if (PL_egid != PL_gid)
d3906 2
d3909 1
a3909 1
    AvREAL_off(PL_dbargs);	/* XXX should be REIFY (see av.h) */
d3918 1
a3918 1
    PL_curstash = PL_debstash;
d3925 2
a3926 1
    sv_setiv(PL_DBsingle, 0);
d3928 2
a3929 1
    sv_setiv(PL_DBtrace, 0);
d3931 3
a3933 1
    sv_setiv(PL_DBsignal, 0);
d4005 33
a4044 1
    AV *isa;
d4063 5
a4067 8
    isa = get_av("IO::File::ISA", GV_ADD | GV_ADDMULTI);
    av_push(isa, newSVpvs("IO::Handle"));
    av_push(isa, newSVpvs("IO::Seekable"));
    av_push(isa, newSVpvs("Exporter"));
    (void) gv_fetchpvs("IO::Handle::", GV_ADD, SVt_PVGV);
    (void) gv_fetchpvs("IO::Seekable::", GV_ADD, SVt_PVGV);
    (void) gv_fetchpvs("Exporter::", GV_ADD, SVt_PVGV);

d4097 1
a4097 1
    PL_statname = newSV(0);		/* last filename we did stat on */
a4211 8
    if ((tmpgv = gv_fetchpvs("$", GV_ADD|GV_NOTQUAL, SVt_PV))) {
        SvREADONLY_off(GvSV(tmpgv));
	sv_setiv(GvSV(tmpgv), (IV)PerlProc_getpid());
        SvREADONLY_on(GvSV(tmpgv));
    }
#ifdef THREADS_HAVE_PIDS
    PL_ppid = (IV)getppid();
#endif
d4421 1
d4443 1
d4445 2
a4446 2
STATIC void
S_incpush(pTHX_ const char *const dir, STRLEN len, U32 flags)
a4447 11
    dVAR;
    const U8 using_sub_dirs
	= (U8)flags & (INCPUSH_ADD_VERSIONED_SUB_DIRS
		       |INCPUSH_ADD_ARCHONLY_SUB_DIRS|INCPUSH_ADD_OLD_VERS);
    const U8 add_versioned_sub_dirs
	= (U8)flags & INCPUSH_ADD_VERSIONED_SUB_DIRS;
    const U8 add_archonly_sub_dirs
	= (U8)flags & INCPUSH_ADD_ARCHONLY_SUB_DIRS;
#ifdef PERL_INC_VERSION_LIST
    const U8 addoldvers  = (U8)flags & INCPUSH_ADD_OLD_VERS;
#endif
d4449 1
a4449 3
    const U8 unshift     = (U8)flags & INCPUSH_UNSHIFT;
    const U8 push_basedir = (flags & INCPUSH_NOT_BASEDIR) ? 0 : 1;
    AV *const inc = GvAVn(PL_incgv);
d4451 1
a4451 1
    PERL_ARGS_ASSERT_INCPUSH;
a4453 13
    /* Could remove this vestigial extra block, if we don't mind a lot of
       re-indenting diff noise.  */
    {
	SV *libdir;
	/* Change 20189146be79a0596543441fa369c6bf7f85103f, to fix RT#6665,
	   arranged to unshift #! line -I onto the front of @@INC. However,
	   -I can add version and architecture specific libraries, and they
	   need to go first. The old code assumed that it was always
	   pushing. Hence to make it work, need to push the architecture
	   (etc) libraries onto a temporary array, then "unshift" that onto
	   the front of @@INC.  */
	AV *const av = (using_sub_dirs) ? (unshift ? newAV() : inc) : NULL;

d4465 16
d4571 3
a4573 2
			(PL_uid != PL_euid || PL_gid != PL_egid)) {
			/* Need to taint reloccated paths if running set ID  */
d4581 40
d4626 1
a4626 1
	    SV *subdir;
a4631 17
#ifdef VMS
	    char *unix;
	    STRLEN len;


	    if ((unix = tounixspec_ts(SvPV(libdir,len),NULL)) != NULL) {
		len = strlen(unix);
		while (unix[len-1] == '/') len--;  /* Cosmetic */
		sv_usepvn(libdir,unix,len);
	    }
	    else
		PerlIO_printf(Perl_error_log,
		              "Failed to unixify @@INC element \"%s\"\n",
			      SvPV(libdir,len));
#endif

	    subdir = newSVsv(libdir);
d4663 1
a4663 1

d4666 3
d4670 1
d4674 1
d4689 1
d4712 7
d4720 1
d4815 1
a4815 1
	    PL_curstash = PL_defstash;
d4827 1
a4827 1
	    PerlIO_printf(Perl_error_log, "panic: restartop\n");
@


1.20
log
@Merge in some local changes that got lost.
@
text
@d1 1
d5 2
a6 1
 *    2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 by Larry Wall and others
a26 59
/* PSz 12 Nov 03
 * 
 * Be proud that perl(1) may proclaim:
 *   Setuid Perl scripts are safer than C programs ...
 * Do not abandon (deprecate) suidperl. Do not advocate C wrappers.
 * 
 * The flow was: perl starts, notices script is suid, execs suidperl with same
 * arguments; suidperl opens script, checks many things, sets itself with
 * right UID, execs perl with similar arguments but with script pre-opened on
 * /dev/fd/xxx; perl checks script is as should be and does work. This was
 * insecure: see perlsec(1) for many problems with this approach.
 * 
 * The "correct" flow should be: perl starts, opens script and notices it is
 * suid, checks many things, execs suidperl with similar arguments but with
 * script on /dev/fd/xxx; suidperl checks script and /dev/fd/xxx object are
 * same, checks arguments match #! line, sets itself with right UID, execs
 * perl with same arguments; perl checks many things and does work.
 * 
 * (Opening the script in perl instead of suidperl, we "lose" scripts that
 * are readable to the target UID but not to the invoker. Where did
 * unreadable scripts work anyway?)
 * 
 * For now, suidperl and perl are pretty much the same large and cumbersome
 * program, so suidperl can check its argument list (see comments elsewhere).
 * 
 * References:
 * Original bug report:
 *   http://bugs.perl.org/index.html?req=bug_id&bug_id=20010322.218
 *   http://rt.perl.org/rt2/Ticket/Display.html?id=6511
 * Comments and discussion with Debian:
 *   http://bugs.debian.org/203426
 *   http://bugs.debian.org/220486
 * Debian Security Advisory DSA 431-1 (does not fully fix problem):
 *   http://www.debian.org/security/2004/dsa-431
 * CVE candidate:
 *   http://cve.mitre.org/cgi-bin/cvename.cgi?name=CAN-2003-0618
 * Previous versions of this patch sent to perl5-porters:
 *   http://www.mail-archive.com/perl5-porters@@perl.org/msg71953.html
 *   http://www.mail-archive.com/perl5-porters@@perl.org/msg75245.html
 *   http://www.mail-archive.com/perl5-porters@@perl.org/msg75563.html
 *   http://www.mail-archive.com/perl5-porters@@perl.org/msg75635.html
 * 
Paul Szabo - psz@@maths.usyd.edu.au  http://www.maths.usyd.edu.au:8000/u/psz/
School of Mathematics and Statistics  University of Sydney   2006  Australia
 * 
 */
/* PSz 13 Nov 03
 * Use truthful, neat, specific error messages.
 * Cannot always hide the truth; security must not depend on doing so.
 */

/* PSz 18 Feb 04
 * Use global(?), thread-local fdscript for easier checks.
 * (I do not understand how we could possibly get a thread race:
 * do not all threads go through the same initialization? Or in
 * fact, are not threads started only after we get the script and
 * so know what to do? Oh well, make things super-safe...)
 */

d31 1
a34 1
char *nw_get_sitelib(const char *pl);
d75 3
a77 8
#ifdef DOSUID
#  ifdef IAMSUID
/* Drop scriptname */
#    define validate_suid(validarg, scriptname, fdscript, suidscript, linestr_sv, rsfp) S_validate_suid(aTHX_ validarg, fdscript, suidscript, linestr_sv, rsfp)
#  else
/* Drop suidscript */
#    define validate_suid(validarg, scriptname, fdscript, suidscript, linestr_sv, rsfp) S_validate_suid(aTHX_ validarg, scriptname, fdscript, linestr_sv, rsfp)
#  endif
a78 4
#  ifdef SETUID_SCRIPTS_ARE_SECURE_NOW
/* Drop everything. Heck, don't even try to call it */
#    define validate_suid(validarg, scriptname, fdscript, suidscript, linestr_sv, rsfp) NOOP
#  else
d80 1
a80 2
#    define validate_suid(validarg, scriptname, fdscript, suidscript, linestr_sv, rsfp) S_validate_suid(aTHX_ rsfp)
#  endif
a111 2
#  endif
#ifdef PERL_IMPLICIT_CONTEXT
d309 3
a311 2
    /* First entry is an array of empty elements */
    Perl_av_create_and_push(aTHX_ &PL_regex_padav,(SV*)newAV());
d394 2
d542 2
d571 1
a843 16
    {
        I32 i = AvFILLp(PL_regex_padav) + 1;
        SV * const * const ary = AvARRAY(PL_regex_padav);

        while (i) {
            SV * const resv = ary[--i];

	    if(SvREPADTMP(resv)) {
	      SvREPADTMP_off(resv);
	    }
            else if(SvIOKp(resv)) {
		REGEXP *re = INT2PTR(REGEXP *,SvIVX(resv));
                ReREFCNT_dec(re);
            }
        }
    }
a865 1
    PL_preprocess   = FALSE;
d890 2
a891 2
    SvREFCNT_dec(PL_ofs_sv);	/* $, */
    PL_ofs_sv = NULL;
a993 1
    SvREFCNT_dec(PL_utf8_alnumc);
a1012 1
    PL_utf8_alnumc	= NULL;
d1055 1
a1055 1
    if (destruct_level >= 2 && ckWARN_d(WARN_INTERNAL)) {
d1057 3
a1059 3
	    Perl_warner(aTHX_ packWARN(WARN_INTERNAL),
	         "Unbalanced scopes: %ld more ENTERs than LEAVEs\n",
		 (long)PL_scopestack_ix);
d1061 3
a1063 3
	    Perl_warner(aTHX_ packWARN(WARN_INTERNAL),
		 "Unbalanced saves: %ld more saves than restores\n",
		 (long)PL_savestack_ix);
d1065 2
a1066 2
	    Perl_warner(aTHX_ packWARN(WARN_INTERNAL),"Unbalanced tmps: %ld more allocs than frees\n",
		 (long)PL_tmps_floor + 1);
d1068 2
a1069 2
	    Perl_warner(aTHX_ packWARN(WARN_INTERNAL),"Unbalanced context: %ld more PUSHes than POPs\n",
		 (long)cxstack_ix + 1);
d1166 1
a1166 1
			"\tallocated at %s:%d %s %s%s\n",
d1174 2
a1175 1
			sv->sv_debug_cloned ? " (cloned)" : ""
a1235 2
    Safefree(PL_psig_ptr);
    PL_psig_ptr = (SV**)NULL;
d1238 1
a1238 2
    Safefree(PL_bitcount);
    PL_bitcount = NULL;
d1241 7
a1464 5
#ifdef SETUID_SCRIPTS_ARE_SECURE_NOW_AND_IAMSUID
    Perl_croak(aTHX_ "suidperl is no longer needed since the kernel can now "
	       "execute\nsetuid perl scripts securely.\n");
#endif

d1636 99
a1743 4
#ifdef DOSUID
    const char *validarg = "";
#endif
    register SV *sv;
a1754 2
    sv = newSVpvs("");		/* first used for -I flags */
    SAVEFREESV(sv);
a1761 12
#ifdef DOSUID
    if (*validarg)
	validarg = " PHOOEY ";
    else
	validarg = argv[0];
    /*
     * Can we rely on the kernel to start scripts with argv[1] set to
     * contain all #! line switches (the whole line)? (argv[0] is set to
     * the interpreter name, argv[2] to the script name; argv[3] and
     * above may contain other arguments.)
     */
#endif
a1812 5
#ifdef MACOS_TRADITIONAL
	    /* ignore -e for Dev:Pseudo argument */
	    if (argv[1] && !strcmp(argv[1], "Dev:Pseudo"))
		break;
#endif
d1843 1
a1843 6
		const char * const p = savepvn(s, len);
		incpush(p, TRUE, TRUE, FALSE, FALSE);
		sv_catpvs(sv, "-I");
		sv_catpvn(sv, p, len);
		sv_catpvs(sv, " ");
		Safefree(p);
a1847 6
	case 'P':
	    forbid_setid('P', FALSE);
	    PL_preprocess = TRUE;
	    s++;
	    deprecate("-P");
	    goto reswitch;
a1856 1
		Perl_av_create_and_push(aTHX_ &PL_preambleav, newSVpvs("use Config;"));
d1858 1
a1858 91
		    /* Can't do newSVpvs() as that would involve pre-processor
		       condititionals inside a macro expansion.  */
		    opts_prog = Perl_newSVpv(aTHX_ "$_ = join ' ', sort qw("
#  ifdef DEBUGGING
			     " DEBUGGING"
#  endif
#  ifdef NO_MATHOMS
                            " NO_MATHOMS"
#  endif
#  ifdef PERL_DONT_CREATE_GVSV
			     " PERL_DONT_CREATE_GVSV"
#  endif
#  ifdef PERL_MALLOC_WRAP
			     " PERL_MALLOC_WRAP"
#  endif
#  ifdef PERL_MEM_LOG
			     " PERL_MEM_LOG"
#  endif
#  ifdef PERL_MEM_LOG_ENV
			     " PERL_MEM_LOG_ENV"
#  endif
#  ifdef PERL_MEM_LOG_ENV_FD
			     " PERL_MEM_LOG_ENV_FD"
#  endif
#  ifdef PERL_MEM_LOG_STDERR
			     " PERL_MEM_LOG_STDERR"
#  endif
#  ifdef PERL_MEM_LOG_TIMESTAMP
			     " PERL_MEM_LOG_TIMESTAMP"
#  endif
#  ifdef PERL_USE_DEVEL
			     " PERL_USE_DEVEL"
#  endif
#  ifdef PERL_USE_SAFE_PUTENV
			     " PERL_USE_SAFE_PUTENV"
#  endif
#  ifdef USE_SITECUSTOMIZE
			     " USE_SITECUSTOMIZE"
#  endif	       
#  ifdef USE_FAST_STDIO
			     " USE_FAST_STDIO"
#  endif	       
					     , 0);

		    sv_catpv(opts_prog, PL_bincompat_options);
		    /* Terminate the qw(, and then wrap at 76 columns.  */
		    sv_catpvs(opts_prog, "); s/(?=.{53})(.{1,53}) /$1\\n                        /mg;print Config::myconfig(),");
#ifdef VMS
		    sv_catpvs(opts_prog,"\"\\nCharacteristics of this PERLSHR image: \\n");
#else
		    sv_catpvs(opts_prog,"\"\\nCharacteristics of this binary (from libperl): \\n");
#endif
		    sv_catpvs(opts_prog,"  Compile-time options: $_\\n\",");

#if defined(LOCAL_PATCH_COUNT)
		    if (LOCAL_PATCH_COUNT > 0) {
			int i;
			sv_catpvs(opts_prog,
				 "\"  Locally applied patches:\\n\",");
			for (i = 1; i <= LOCAL_PATCH_COUNT; i++) {
			    if (PL_localpatches[i])
				Perl_sv_catpvf(aTHX_ opts_prog,"q%c\t%s\n%c,",
				    0, PL_localpatches[i], 0);
			}
		    }
#endif
#ifdef __OpenBSD__
		    Perl_sv_catpvf(aTHX_ opts_prog,
				   "\"  Built under OpenBSD\\n\"");
#else
		    Perl_sv_catpvf(aTHX_ opts_prog,
				   "\"  Built under %s\\n",OSNAME);
#ifdef __DATE__
#  ifdef __TIME__
		    sv_catpvs(opts_prog,
			      "  Compiled at " __DATE__ " " __TIME__ "\\n\"");
#  else
		    sv_catpvs(opts_prog, "  Compiled on " __DATE__ "\\n\"");
#  endif
#endif
#endif
		    sv_catpvs(opts_prog, "; $\"=\"\\n    \"; "
			     "@@env = map { \"$_=\\\"$ENV{$_}\\\"\" } "
			     "sort grep {/^PERL/} keys %ENV; ");
#ifdef __CYGWIN__
		    sv_catpvs(opts_prog,
			     "push @@env, \"CYGWIN=\\\"$ENV{CYGWIN}\\\"\";");
#endif
		    sv_catpvs(opts_prog, 
			     "print \"  \\%ENV:\\n    @@env\\n\" if @@env;"
			     "print \"  \\@@INC:\\n    @@INC\\n\";");
d1863 1
a1863 1
					      "Config::config_vars(qw%c%s%c)",
d1867 1
a1867 1
		av_push(PL_preambleav, opts_prog);
d1934 1
a1934 1
		if (!strchr("CDIMUdmtw", *s))
d1960 1
a1960 1
#ifdef USE_SITECUSTOMIZE
d1962 4
d1967 2
a1968 1
					     Perl_newSVpvf(aTHX_ "BEGIN { do '%s/sitecustomize.pl' }", SITELIB_EXP));
d1996 1
a1996 4
#ifdef DOSUID
	const int fdscript =
#endif
	    open_script(scriptname, dosearch, sv, &suidscript, &rsfp);
d1999 1
a1999 1
		linestr_sv, rsfp);
d2009 2
a2010 3
		if (ckWARN(WARN_SIGNAL))
		    Perl_warner(aTHX_ packWARN(WARN_SIGNAL),
				"Can't ignore signal CHLD, forcing to default");
d2017 1
a2017 5
	if (PL_doextract
#ifdef MACOS_TRADITIONAL
	    || gMacPerl_AlwaysExtract
#endif
	    ) {
a2038 1
    boot_core_xsutils();
d2040 1
d2072 1
d2111 1
a2159 10
#ifdef MACOS_TRADITIONAL
    if (gMacPerl_SyntaxError = (yyparse() || PL_parser->error_count)) {
	if (PL_minus_c)
	    Perl_croak(aTHX_ "%s had compilation errors.\n", MacPerl_MPWFileName(PL_origfilename));
	else {
	    Perl_croak(aTHX_ "Execution of %s aborted due to compilation errors.\n",
		       MacPerl_MPWFileName(PL_origfilename));
	}
    }
#else
a2167 1
#endif
a2169 1
    PL_preprocess = FALSE;
a2277 1
	DEBUG_x(dump_all());
d2279 2
a2283 2
	DEBUG_S(PerlIO_printf(Perl_debug_log, "main thread is 0x%"UVxf"\n",
			      PTR2UV(thr)));
a2285 5
#ifdef MACOS_TRADITIONAL
	    PerlIO_printf(Perl_error_log, "%s%s syntax OK\n",
		(gMacPerl_ErrorFormat ? "# " : ""),
		MacPerl_MPWFileName(PL_origfilename));
#else
a2286 1
#endif
d2433 2
d2510 1
d2513 4
a2516 1
    return call_sv(sv_2mortal(newSVpv(methname,0)), flags | G_METHOD);
d2550 5
a2618 2
	    if (PL_statusvalue && !(PL_exit_flags & PERL_EXIT_EXPECTED))
		Perl_croak(aTHX_ "Callback called exit");
a2718 2
	if (PL_statusvalue && !(PL_exit_flags & PERL_EXIT_EXPECTED))
	    Perl_croak(aTHX_ "Callback called exit");
a2808 11
void
Perl_magicname(pTHX_ const char *sym, const char *name, I32 namlen)
{
    register GV * const gv = gv_fetchpv(sym, GV_ADD, SVt_PV);

    PERL_ARGS_ASSERT_MAGICNAME;

    if (gv)
	sv_magic(GvSV(gv), MUTABLE_SV(gv), PERL_MAGIC_sv, name, namlen);
}

a2831 1
"-P                run program through C preprocessor before compilation",
d2873 1
a2873 1
      "  P  Print profiling info, preprocessor command for -P, source file input state",
a2881 1
      "  S  Thread synchronization",
d2889 2
d2899 1
a2899 1
	static const char debopts[] = "psltocPmfrxuUHXDSTRJvCAq";
d3090 2
a3091 3
	    e = savepvn(s, e-s);
	    incpush(e, TRUE, TRUE, FALSE, FALSE);
	    Safefree(e);
a3201 3
#ifdef MACOS_TRADITIONAL
	Perl_croak(aTHX_ "Believe me, you don't want to use \"-u\" on a Macintosh");
#endif
d3231 5
a3235 4
		"\nThis is perl, %"SVf
		" built for %s",
		level,
		ARCHNAME);
d3260 1
a3260 6
		      "\n\nCopyright 1987-2009, Larry Wall\n");
#ifdef MACOS_TRADITIONAL
	PerlIO_printf(PerlIO_stdout(),
		      "\nMac OS port Copyright 1991-2002, Matthias Neeracher;\n"
		      "maintained by Chris Nandor\n");
#endif
a3302 4
#ifdef __MINT__
	PerlIO_printf(PerlIO_stdout(),
		      "MiNT port by Guido Flohr, 1997-1999\n");
#endif
a3365 4
    case 'P':
	if (PL_preprocess)
	    return s+1;
	/* FALL THROUGH */
d3492 1
a3492 1
S_open_script(pTHX_ const char *scriptname, bool dosearch, SV *sv,
a3494 6
#ifndef IAMSUID
    const char *quote;
    const char *code;
    const char *cpp_discard_flag;
    const char *perl;
#endif
a3551 83
#ifdef IAMSUID
    else {
	Perl_croak(aTHX_ "sperl needs fd script\n"
		   "You should not call sperl directly; do you need to "
		   "change a #! line\nfrom sperl to perl?\n");

/* PSz 11 Nov 03
 * Do not open (or do other fancy stuff) while setuid.
 * Perl does the open, and hands script to suidperl on a fd;
 * suidperl only does some checks, sets up UIDs and re-execs
 * perl with that fd as it has always done.
 */
    }
    if (!*suidscript) {
	Perl_croak(aTHX_ "suidperl needs (suid) fd script\n");
    }
#else /* IAMSUID */
    else if (PL_preprocess) {
	const char * const cpp_cfg = CPPSTDIN;
	SV * const cpp = newSVpvs("");
	SV * const cmd = newSV(0);

	if (cpp_cfg[0] == 0) /* PERL_MICRO? */
	     Perl_croak(aTHX_ "Can't run with cpp -P with CPPSTDIN undefined");
	if (strEQ(cpp_cfg, "cppstdin"))
	    Perl_sv_catpvf(aTHX_ cpp, "%s/", BIN_EXP);
	sv_catpv(cpp, cpp_cfg);

#       ifndef VMS
	    sv_catpvs(sv, "-I");
	    sv_catpv(sv,PRIVLIB_EXP);
#       endif

	DEBUG_P(PerlIO_printf(Perl_debug_log,
			      "PL_preprocess: scriptname=\"%s\", cpp=\"%s\", sv=\"%s\", CPPMINUS=\"%s\"\n",
			      scriptname, SvPVX_const (cpp), SvPVX_const (sv),
			      CPPMINUS));

#       if defined(MSDOS) || defined(WIN32) || defined(VMS)
            quote = "\"";
#       else
            quote = "'";
#       endif

#       ifdef VMS
            cpp_discard_flag = "";
#       else
            cpp_discard_flag = "-C";
#       endif

#       ifdef OS2
            perl = os2_execname(aTHX);
#       else
            perl = PL_origargv[0];
#       endif


        /* This strips off Perl comments which might interfere with
           the C pre-processor, including #!.  #line directives are
           deliberately stripped to avoid confusion with Perl's version
           of #line.  FWP played some golf with it so it will fit
           into VMS's 255 character buffer.
        */
        if( PL_doextract )
            code = "(1../^#!.*perl/i)|/^\\s*#(?!\\s*((ifn?|un)def|(el|end)?if|define|include|else|error|pragma)\\b)/||!($|=1)||print";
        else
            code = "/^\\s*#(?!\\s*((ifn?|un)def|(el|end)?if|define|include|else|error|pragma)\\b)/||!($|=1)||print";

        Perl_sv_setpvf(aTHX_ cmd, "\
%s -ne%s%s%s %s | %"SVf" %s %"SVf" %s",
                       perl, quote, code, quote, scriptname, SVfARG(cpp),
                       cpp_discard_flag, SVfARG(sv), CPPMINUS);

	PL_doextract = FALSE;

        DEBUG_P(PerlIO_printf(Perl_debug_log,
                              "PL_preprocess: cmd=\"%s\"\n",
                              SvPVX_const(cmd)));

	*rsfpp = PerlProc_popen((char *)SvPVX_const(cmd), (char *)"r");
	SvREFCNT_dec(cmd);
	SvREFCNT_dec(cpp);
    }
a3603 1
#endif /* IAMSUID */
a3621 16
#ifdef IAMSUID
STATIC int
S_fd_on_nosuid_fs(pTHX_ int fd)
{
/* PSz 27 Feb 04
 * We used to do this as "plain" user (after swapping UIDs with setreuid);
 * but is needed also on machines without setreuid.
 * Seems safe enough to run as root.
 */
    int check_okay = 0; /* able to do all the required sys/libcalls */
    int on_nosuid  = 0; /* the fd is on a nosuid fs */
    /* PSz 12 Nov 03
     * Need to check noexec also: nosuid might not be set, the average
     * sysadmin would say that nosuid is irrelevant once he sets noexec.
     */
    int on_noexec  = 0; /* the fd is on a noexec fs */
d3623 1
a3623 498
/*
 * Preferred order: fstatvfs(), fstatfs(), ustat()+getmnt(), getmntent().
 * fstatvfs() is UNIX98.
 * fstatfs() is 4.3 BSD.
 * ustat()+getmnt() is pre-4.3 BSD.
 * getmntent() is O(number-of-mounted-filesystems) and can hang on
 * an irrelevant filesystem while trying to reach the right one.
 */

#undef FD_ON_NOSUID_CHECK_OKAY  /* found the syscalls to do the check? */

#   if !defined(FD_ON_NOSUID_CHECK_OKAY) && \
        defined(HAS_FSTATVFS)
#   define FD_ON_NOSUID_CHECK_OKAY
    struct statvfs stfs;

    check_okay = fstatvfs(fd, &stfs) == 0;
    on_nosuid  = check_okay && (stfs.f_flag  & ST_NOSUID);
#ifdef ST_NOEXEC
    /* ST_NOEXEC certainly absent on AIX 5.1, and doesn't seem to be documented
       on platforms where it is present.  */
    on_noexec  = check_okay && (stfs.f_flag  & ST_NOEXEC);
#endif
#   endif /* fstatvfs */

#   if !defined(FD_ON_NOSUID_CHECK_OKAY) && \
        defined(PERL_MOUNT_NOSUID)	&& \
        defined(PERL_MOUNT_NOEXEC)	&& \
        defined(HAS_FSTATFS) 		&& \
        defined(HAS_STRUCT_STATFS)	&& \
        defined(HAS_STRUCT_STATFS_F_FLAGS)
#   define FD_ON_NOSUID_CHECK_OKAY
    struct statfs  stfs;

    check_okay = fstatfs(fd, &stfs)  == 0;
    on_nosuid  = check_okay && (stfs.f_flags & PERL_MOUNT_NOSUID);
    on_noexec  = check_okay && (stfs.f_flags & PERL_MOUNT_NOEXEC);
#   endif /* fstatfs */

#   if !defined(FD_ON_NOSUID_CHECK_OKAY) && \
        defined(PERL_MOUNT_NOSUID)	&& \
        defined(PERL_MOUNT_NOEXEC)	&& \
        defined(HAS_FSTAT)		&& \
        defined(HAS_USTAT)		&& \
        defined(HAS_GETMNT)		&& \
        defined(HAS_STRUCT_FS_DATA)	&& \
        defined(NOSTAT_ONE)
#   define FD_ON_NOSUID_CHECK_OKAY
    Stat_t fdst;

    if (fstat(fd, &fdst) == 0) {
        struct ustat us;
        if (ustat(fdst.st_dev, &us) == 0) {
            struct fs_data fsd;
            /* NOSTAT_ONE here because we're not examining fields which
             * vary between that case and STAT_ONE. */
            if (getmnt((int*)0, &fsd, (int)0, NOSTAT_ONE, us.f_fname) == 0) {
                size_t cmplen = sizeof(us.f_fname);
                if (sizeof(fsd.fd_req.path) < cmplen)
                    cmplen = sizeof(fsd.fd_req.path);
                if (strnEQ(fsd.fd_req.path, us.f_fname, cmplen) &&
                    fdst.st_dev == fsd.fd_req.dev) {
                    check_okay = 1;
                    on_nosuid = fsd.fd_req.flags & PERL_MOUNT_NOSUID;
                    on_noexec = fsd.fd_req.flags & PERL_MOUNT_NOEXEC;
                }
            }
        }
    }
#   endif /* fstat+ustat+getmnt */

#   if !defined(FD_ON_NOSUID_CHECK_OKAY) && \
        defined(HAS_GETMNTENT)		&& \
        defined(HAS_HASMNTOPT)		&& \
        defined(MNTOPT_NOSUID)		&& \
        defined(MNTOPT_NOEXEC)
#   define FD_ON_NOSUID_CHECK_OKAY
    FILE                *mtab = fopen("/etc/mtab", "r");
    struct mntent       *entry;
    Stat_t              stb, fsb;

    if (mtab && (fstat(fd, &stb) == 0)) {
        while (entry = getmntent(mtab)) {
            if (stat(entry->mnt_dir, &fsb) == 0
                && fsb.st_dev == stb.st_dev)
            {
                /* found the filesystem */
                check_okay = 1;
                if (hasmntopt(entry, MNTOPT_NOSUID))
                    on_nosuid = 1;
                if (hasmntopt(entry, MNTOPT_NOEXEC))
                    on_noexec = 1;
                break;
            } /* A single fs may well fail its stat(). */
        }
    }
    if (mtab)
        fclose(mtab);
#   endif /* getmntent+hasmntopt */

    if (!check_okay)
	Perl_croak(aTHX_ "Can't check filesystem of script \"%s\" for nosuid/noexec", PL_origfilename);
    if (on_nosuid)
	Perl_croak(aTHX_ "Setuid script \"%s\" on nosuid filesystem", PL_origfilename);
    if (on_noexec)
	Perl_croak(aTHX_ "Setuid script \"%s\" on noexec filesystem", PL_origfilename);
    return ((!check_okay) || on_nosuid || on_noexec);
}
#endif /* IAMSUID */

#ifdef DOSUID
STATIC void
S_validate_suid(pTHX_ const char *validarg,
#  ifndef IAMSUID
		const char *scriptname,
#  endif
		int fdscript,
#  ifdef IAMSUID
		bool suidscript,
#  endif
		SV *linestr_sv, PerlIO *rsfp)
{
    dVAR;
    const char *s, *s2;

    PERL_ARGS_ASSERT_VALIDATE_SUID;

    /* do we need to emulate setuid on scripts? */

    /* This code is for those BSD systems that have setuid #! scripts disabled
     * in the kernel because of a security problem.  Merely defining DOSUID
     * in perl will not fix that problem, but if you have disabled setuid
     * scripts in the kernel, this will attempt to emulate setuid and setgid
     * on scripts that have those now-otherwise-useless bits set.  The setuid
     * root version must be called suidperl or sperlN.NNN.  If regular perl
     * discovers that it has opened a setuid script, it calls suidperl with
     * the same argv that it had.  If suidperl finds that the script it has
     * just opened is NOT setuid root, it sets the effective uid back to the
     * uid.  We don't just make perl setuid root because that loses the
     * effective uid we had before invoking perl, if it was different from the
     * uid.
     * PSz 27 Feb 04
     * Description/comments above do not match current workings:
     *   suidperl must be hardlinked to sperlN.NNN (that is what we exec);
     *   suidperl called with script open and name changed to /dev/fd/N/X;
     *   suidperl croaks if script is not setuid;
     *   making perl setuid would be a huge security risk (and yes, that
     *     would lose any euid we might have had).
     *
     * DOSUID must be defined in both perl and suidperl, and IAMSUID must
     * be defined in suidperl only.  suidperl must be setuid root.  The
     * Configure script will set this up for you if you want it.
     */

    if (PerlLIO_fstat(PerlIO_fileno(rsfp),&PL_statbuf) < 0)	/* normal stat is insecure */
	Perl_croak(aTHX_ "Can't stat script \"%s\"",PL_origfilename);
    if (PL_statbuf.st_mode & (S_ISUID|S_ISGID)) {
	I32 len;
	const char *linestr;
	const char *s_end;

#  ifdef IAMSUID
	if (fdscript < 0 || !suidscript)
	    Perl_croak(aTHX_ "Need (suid) fdscript in suidperl\n");	/* We already checked this */
	/* PSz 11 Nov 03
	 * Since the script is opened by perl, not suidperl, some of these
	 * checks are superfluous. Leaving them in probably does not lower
	 * security(?!).
	 */
	/* PSz 27 Feb 04
	 * Do checks even for systems with no HAS_SETREUID.
	 * We used to swap, then re-swap UIDs with
#    ifdef HAS_SETREUID
	    if (setreuid(PL_euid,PL_uid) < 0
		|| PerlProc_getuid() != PL_euid || PerlProc_geteuid() != PL_uid)
		Perl_croak(aTHX_ "Can't swap uid and euid");
#    endif
#    ifdef HAS_SETREUID
	    if (setreuid(PL_uid,PL_euid) < 0
		|| PerlProc_getuid() != PL_uid || PerlProc_geteuid() != PL_euid)
		Perl_croak(aTHX_ "Can't reswap uid and euid");
#    endif
	 */

	/* On this access check to make sure the directories are readable,
	 * there is actually a small window that the user could use to make
	 * filename point to an accessible directory.  So there is a faint
	 * chance that someone could execute a setuid script down in a
	 * non-accessible directory.  I don't know what to do about that.
	 * But I don't think it's too important.  The manual lies when
	 * it says access() is useful in setuid programs.
	 * 
	 * So, access() is pretty useless... but not harmful... do anyway.
	 */
	if (PerlLIO_access(CopFILE(PL_curcop),1)) { /*double check*/
	    Perl_croak(aTHX_ "Can't access() script\n");
	}

	/* If we can swap euid and uid, then we can determine access rights
	 * with a simple stat of the file, and then compare device and
	 * inode to make sure we did stat() on the same file we opened.
	 * Then we just have to make sure he or she can execute it.
	 * 
	 * PSz 24 Feb 04
	 * As the script is opened by perl, not suidperl, we do not need to
	 * care much about access rights.
	 * 
	 * The 'script changed' check is needed, or we can get lied to
	 * about $0 with e.g.
	 *  suidperl /dev/fd/4//bin/x 4<setuidscript
	 * Without HAS_SETREUID, is it safe to stat() as root?
	 * 
	 * Are there any operating systems that pass /dev/fd/xxx for setuid
	 * scripts, as suggested/described in perlsec(1)? Surely they do not
	 * pass the script name as we do, so the "script changed" test would
	 * fail for them... but we never get here with
	 * SETUID_SCRIPTS_ARE_SECURE_NOW defined.
	 * 
	 * This is one place where we must "lie" about return status: not
	 * say if the stat() failed. We are doing this as root, and could
	 * be tricked into reporting existence or not of files that the
	 * "plain" user cannot even see.
	 */
	{
	    Stat_t tmpstatbuf;
	    if (PerlLIO_stat(CopFILE(PL_curcop),&tmpstatbuf) < 0 ||
		tmpstatbuf.st_dev != PL_statbuf.st_dev ||
		tmpstatbuf.st_ino != PL_statbuf.st_ino) {
		Perl_croak(aTHX_ "Setuid script changed\n");
	    }

	}
	if (!cando(S_IXUSR,FALSE,&PL_statbuf))		/* can real uid exec? */
	    Perl_croak(aTHX_ "Real UID cannot exec script\n");

	/* PSz 27 Feb 04
	 * We used to do this check as the "plain" user (after swapping
	 * UIDs). But the check for nosuid and noexec filesystem is needed,
	 * and should be done even without HAS_SETREUID. (Maybe those
	 * operating systems do not have such mount options anyway...)
	 * Seems safe enough to do as root.
	 */
#    if !defined(NO_NOSUID_CHECK)
	if (fd_on_nosuid_fs(PerlIO_fileno(rsfp))) {
	    Perl_croak(aTHX_ "Setuid script on nosuid or noexec filesystem\n");
	}
#    endif
#  endif /* IAMSUID */

	if (!S_ISREG(PL_statbuf.st_mode)) {
	    Perl_croak(aTHX_ "Setuid script not plain file\n");
	}
	if (PL_statbuf.st_mode & S_IWOTH)
	    Perl_croak(aTHX_ "Setuid/gid script is writable by world");
	PL_doswitches = FALSE;		/* -s is insecure in suid */
	/* PSz 13 Nov 03  But -s was caught elsewhere ... so unsetting it here is useless(?!) */
	CopLINE_inc(PL_curcop);
	if (sv_gets(linestr_sv, rsfp, 0) == NULL)
	    Perl_croak(aTHX_ "No #! line");
	linestr = SvPV_nolen_const(linestr_sv);
	/* required even on Sys V */
	if (!*linestr || !linestr[1] || strnNE(linestr,"#!",2))
	    Perl_croak(aTHX_ "No #! line");
	linestr += 2;
	s = linestr;
	/* PSz 27 Feb 04 */
	/* Sanity check on line length */
	s_end = s + strlen(s);
	if (s_end == s || (s_end - s) > 4000)
	    Perl_croak(aTHX_ "Very long #! line");
	/* Allow more than a single space after #! */
	while (isSPACE(*s)) s++;
	/* Sanity check on buffer end */
	while ((*s) && !isSPACE(*s)) s++;
	for (s2 = s;  (s2 > linestr &&
		       (isDIGIT(s2[-1]) || s2[-1] == '.' || s2[-1] == '_'
			|| s2[-1] == '-'));  s2--) ;
	/* Sanity check on buffer start */
	if ( (s2-4 < linestr || strnNE(s2-4,"perl",4)) &&
	      (s-9 < linestr || strnNE(s-9,"perl",4)) )
	    Perl_croak(aTHX_ "Not a perl script");
	while (*s == ' ' || *s == '\t') s++;
	/*
	 * #! arg must be what we saw above.  They can invoke it by
	 * mentioning suidperl explicitly, but they may not add any strange
	 * arguments beyond what #! says if they do invoke suidperl that way.
	 */
	/*
	 * The way validarg was set up, we rely on the kernel to start
	 * scripts with argv[1] set to contain all #! line switches (the
	 * whole line).
	 */
	/*
	 * Check that we got all the arguments listed in the #! line (not
	 * just that there are no extraneous arguments). Might not matter
	 * much, as switches from #! line seem to be acted upon (also), and
	 * so may be checked and trapped in perl. But, security checks must
	 * be done in suidperl and not deferred to perl. Note that suidperl
	 * does not get around to parsing (and checking) the switches on
	 * the #! line (but execs perl sooner).
	 * Allow (require) a trailing newline (which may be of two
	 * characters on some architectures?) (but no other trailing
	 * whitespace).
	 */
	len = strlen(validarg);
	if (strEQ(validarg," PHOOEY ") ||
	    strnNE(s,validarg,len) || !isSPACE(s[len]) ||
	    !((s_end - s) == len+1
	      || ((s_end - s) == len+2 && isSPACE(s[len+1]))))
	    Perl_croak(aTHX_ "Args must match #! line");

#  ifndef IAMSUID
	if (fdscript < 0 &&
	    PL_euid != PL_uid && (PL_statbuf.st_mode & S_ISUID) &&
	    PL_euid == PL_statbuf.st_uid)
	    if (!PL_do_undump)
		Perl_croak(aTHX_ "YOU HAVEN'T DISABLED SET-ID SCRIPTS IN THE KERNEL YET!\n\
FIX YOUR KERNEL, OR PUT A C WRAPPER AROUND THIS SCRIPT!\n");
#  endif /* IAMSUID */

	if (fdscript < 0 &&
	    PL_euid) {	/* oops, we're not the setuid root perl */
	    /* PSz 18 Feb 04
	     * When root runs a setuid script, we do not go through the same
	     * steps of execing sperl and then perl with fd scripts, but
	     * simply set up UIDs within the same perl invocation; so do
	     * not have the same checks (on options, whatever) that we have
	     * for plain users. No problem really: would have to be a script
	     * that does not actually work for plain users; and if root is
	     * foolish and can be persuaded to run such an unsafe script, he
	     * might run also non-setuid ones, and deserves what he gets.
	     * 
	     * Or, we might drop the PL_euid check above (and rely just on
	     * fdscript to avoid loops), and do the execs
	     * even for root.
	     */
#  ifndef IAMSUID
	    int which;
	    /* PSz 11 Nov 03
	     * Pass fd script to suidperl.
	     * Exec suidperl, substituting fd script for scriptname.
	     * Pass script name as "subdir" of fd, which perl will grok;
	     * in fact will use that to distinguish this from "normal"
	     * usage, see comments above.
	     */
	    PerlIO_rewind(rsfp);
	    PerlLIO_lseek(PerlIO_fileno(rsfp),(Off_t)0,0);  /* just in case rewind didn't */
	    /* PSz 27 Feb 04  Sanity checks on scriptname */
	    if ((!scriptname) || (!*scriptname) ) {
		Perl_croak(aTHX_ "No setuid script name\n");
	    }
	    if (*scriptname == '-') {
		Perl_croak(aTHX_ "Setuid script name may not begin with dash\n");
		/* Or we might confuse it with an option when replacing
		 * name in argument list, below (though we do pointer, not
		 * string, comparisons).
		 */
	    }
	    for (which = 1; PL_origargv[which] && PL_origargv[which] != scriptname; which++) ;
	    if (!PL_origargv[which]) {
		Perl_croak(aTHX_ "Can't change argv to have fd script\n");
	    }
	    PL_origargv[which] = savepv(Perl_form(aTHX_ "/dev/fd/%d/%s",
					  PerlIO_fileno(rsfp), PL_origargv[which]));
#    if defined(HAS_FCNTL) && defined(F_SETFD)
	    fcntl(PerlIO_fileno(rsfp),F_SETFD,0);	/* ensure no close-on-exec */
#    endif
	    PERL_FPU_PRE_EXEC
	    PerlProc_execv(BIN_EXP "/sperl" PERL_FS_VERSION, PL_origargv);
	    PERL_FPU_POST_EXEC
#  endif /* IAMSUID */
	    Perl_croak(aTHX_ "Can't do setuid (cannot exec sperl)\n");
	}

	if (PL_statbuf.st_mode & S_ISGID && PL_statbuf.st_gid != PL_egid) {
/* PSz 26 Feb 04
 * This seems back to front: we try HAS_SETEGID first; if not available
 * then try HAS_SETREGID; as a last chance we try HAS_SETRESGID. May be OK
 * in the sense that we only want to set EGID; but are there any machines
 * with either of the latter, but not the former? Same with UID, later.
 */
#  ifdef HAS_SETEGID
	    (void)setegid(PL_statbuf.st_gid);
#  else
#    ifdef HAS_SETREGID
           (void)setregid((Gid_t)-1,PL_statbuf.st_gid);
#    else
#      ifdef HAS_SETRESGID
           (void)setresgid((Gid_t)-1,PL_statbuf.st_gid,(Gid_t)-1);
#      else
	    PerlProc_setgid(PL_statbuf.st_gid);
#      endif
#    endif
#  endif
	    if (PerlProc_getegid() != PL_statbuf.st_gid)
		Perl_croak(aTHX_ "Can't do setegid!\n");
	}
	if (PL_statbuf.st_mode & S_ISUID) {
	    if (PL_statbuf.st_uid != PL_euid)
#  ifdef HAS_SETEUID
		(void)seteuid(PL_statbuf.st_uid);	/* all that for this */
#  else
#    ifdef HAS_SETREUID
                (void)setreuid((Uid_t)-1,PL_statbuf.st_uid);
#    else
#      ifdef HAS_SETRESUID
                (void)setresuid((Uid_t)-1,PL_statbuf.st_uid,(Uid_t)-1);
#      else
		PerlProc_setuid(PL_statbuf.st_uid);
#      endif
#    endif
#  endif
	    if (PerlProc_geteuid() != PL_statbuf.st_uid)
		Perl_croak(aTHX_ "Can't do seteuid!\n");
	}
	else if (PL_uid) {			/* oops, mustn't run as root */
#  ifdef HAS_SETEUID
          (void)seteuid((Uid_t)PL_uid);
#  else
#    ifdef HAS_SETREUID
          (void)setreuid((Uid_t)-1,(Uid_t)PL_uid);
#    else
#      ifdef HAS_SETRESUID
          (void)setresuid((Uid_t)-1,(Uid_t)PL_uid,(Uid_t)-1);
#      else
          PerlProc_setuid((Uid_t)PL_uid);
#      endif
#    endif
#  endif
	    if (PerlProc_geteuid() != PL_uid)
		Perl_croak(aTHX_ "Can't do seteuid!\n");
	}
	init_ids();
	if (!cando(S_IXUSR,TRUE,&PL_statbuf))
	    Perl_croak(aTHX_ "Effective UID cannot exec script\n");	/* they can't do this */
    }
#  ifdef IAMSUID
    else if (PL_preprocess)	/* PSz 13 Nov 03  Caught elsewhere, useless(?!) here */
	Perl_croak(aTHX_ "-P not allowed for setuid/setgid script\n");
    else if (fdscript < 0 || !suidscript)
	/* PSz 13 Nov 03  Caught elsewhere, useless(?!) here */
	Perl_croak(aTHX_ "(suid) fdscript needed in suidperl\n");
    else {
/* PSz 16 Sep 03  Keep neat error message */
	Perl_croak(aTHX_ "Script is not setuid/setgid in suidperl\n");
    }

    /* We absolutely must clear out any saved ids here, so we */
    /* exec the real perl, substituting fd script for scriptname. */
    /* (We pass script name as "subdir" of fd, which perl will grok.) */
    /* 
     * It might be thought that using setresgid and/or setresuid (changed to
     * set the saved IDs) above might obviate the need to exec, and we could
     * go on to "do the perl thing".
     * 
     * Is there such a thing as "saved GID", and is that set for setuid (but
     * not setgid) execution like suidperl? Without exec, it would not be
     * cleared for setuid (but not setgid) scripts (or might need a dummy
     * setresgid).
     * 
     * We need suidperl to do the exact same argument checking that perl
     * does. Thus it cannot be very small; while it could be significantly
     * smaller, it is safer (simpler?) to make it essentially the same
     * binary as perl (but they are not identical). - Maybe could defer that
     * check to the invoked perl, and suidperl be a tiny wrapper instead;
     * but prefer to do thorough checks in suidperl itself. Such deferral
     * would make suidperl security rely on perl, a design no-no.
     * 
     * Setuid things should be short and simple, thus easy to understand and
     * verify. They should do their "own thing", without influence by
     * attackers. It may help if their internal execution flow is fixed,
     * regardless of platform: it may be best to exec anyway.
     * 
     * Suidperl should at least be conceptually simple: a wrapper only,
     * never to do any real perl. Maybe we should put
     * #ifdef IAMSUID
     *         Perl_croak(aTHX_ "Suidperl should never do real perl\n");
     * #endif
     * into the perly bits.
     */
    PerlIO_rewind(rsfp);
    PerlLIO_lseek(PerlIO_fileno(rsfp),(Off_t)0,0);  /* just in case rewind didn't */
    /* PSz 11 Nov 03
     * Keep original arguments: suidperl already has fd script.
     */
#  if defined(HAS_FCNTL) && defined(F_SETFD)
    fcntl(PerlIO_fileno(rsfp),F_SETFD,0);	/* ensure no close-on-exec */
#  endif
    PERL_FPU_PRE_EXEC
    PerlProc_execv(BIN_EXP "/perl" PERL_FS_VERSION, PL_origargv);/* try again */
    PERL_FPU_POST_EXEC
    Perl_croak(aTHX_ "Can't do setuid (suidperl cannot exec perl)\n");
#  endif /* IAMSUID */
}

#else /* !DOSUID */

#  ifdef SETUID_SCRIPTS_ARE_SECURE_NOW
d3625 1
a3625 1
#  else
d3645 1
a3645 2
#  endif /* SETUID_SCRIPTS_ARE_SECURE_NOW */
#endif /* DOSUID */
a3652 3
#ifdef MACOS_TRADITIONAL
    int maclines = 0;
#endif
a3657 20
#ifdef MACOS_TRADITIONAL
    /* Since the Mac OS does not honor #! arguments for us, we do it ourselves */

    while (PL_doextract || gMacPerl_AlwaysExtract) {
	if ((s = sv_gets(linestr_sv, rsfp, 0)) == NULL) {
	    if (!gMacPerl_AlwaysExtract)
		Perl_croak(aTHX_ "No Perl script found in input\n");

	    if (PL_doextract)			/* require explicit override ? */
		if (!OverrideExtract(PL_origfilename))
		    Perl_croak(aTHX_ "User aborted script\n");
		else
		    PL_doextract = FALSE;

	    /* Pater peccavi, file does not have #! */
	    PerlIO_rewind(rsfp);

	    break;
	}
#else
a3660 1
#endif
a3674 14
#ifdef MACOS_TRADITIONAL
	    /* We are always searching for the #!perl line in MacPerl,
	     * so if we find it, still keep the line count correct
	     * by counting lines we already skipped over
	     */
	    for (; maclines > 0 ; maclines--)
		PerlIO_ungetc(rsfp, '\n');

	    break;

	/* gMacPerl_AlwaysExtract is false in MPW tool */
	} else if (gMacPerl_AlwaysExtract) {
	    ++maclines;
#endif
a3764 22
    /* PSz 29 Feb 04
     * Checks for UID/GID above "wrong": why disallow
     *   perl -e 'print "Hello\n"'
     * from within setuid things?? Simply drop them: replaced by
     * fdscript/suidscript and #ifdef IAMSUID checks below.
     * 
     * This may be too late for command-line switches. Will catch those on
     * the #! line, after finding the script name and setting up
     * fdscript/suidscript. Note that suidperl does not get around to
     * parsing (and checking) the switches on the #! line, but checks that
     * the two sets are identical.
     * 
     * With SETUID_SCRIPTS_ARE_SECURE_NOW, could we use fdscript, also or
     * instead, or would that be "too late"? (We never have suidscript, can
     * we be sure to have fdscript?)
     * 
     * Catch things with suidscript (in descendant of suidperl), even with
     * right UID/GID. Was already checked in suidperl, with #ifdef IAMSUID,
     * below; but I am paranoid.
     * 
     * Also see comments about root running a setuid script, elsewhere.
     */
d3767 16
a3782 4
#ifdef IAMSUID
    /* PSz 11 Nov 03  Catch it in suidperl, always! */
    Perl_croak(aTHX_ "No %s allowed in suidperl", message);
#endif /* IAMSUID */
d3792 2
a3793 3
    PL_dbargs = GvAV(gv_AVadd((gv_fetchpvs("DB::args", GV_ADDMULTI,
					   SVt_PVAV))));
    AvREAL_off(PL_dbargs);
d3839 3
d3868 3
d3881 1
d3884 25
a3937 3

    Safefree(PL_osname);
    PL_osname = savepv(OSNAME);
a4001 4
#ifdef MACOS_TRADITIONAL
	/* $0 is not majick on a Mac */
	sv_setpv(GvSV(tmpgv),MacPerl_MPWFileName(PL_origfilename));
#else
a4002 2
	magicname("0", "0", 1);
#endif
d4071 8
a4078 1
    char *s;
d4081 1
a4081 1
	s = PerlEnv_getenv("PERL5LIB");
d4088 1
a4088 1
	if (s && *s != '\0')
d4090 1
a4090 1
	if (s)
d4092 6
a4097 3
	    incpush(s, TRUE, TRUE, TRUE, FALSE);
	else
	    incpush(PerlEnv_getenv("PERLLIB"), FALSE, FALSE, TRUE, FALSE);
d4106 7
a4112 3
	    do { incpush(buf,TRUE,TRUE,TRUE,FALSE); } while (my_trnlnm("PERL5LIB",buf,++idx));
	else
	    while (my_trnlnm("PERLLIB",buf,idx++)) incpush(buf,FALSE,FALSE,TRUE,FALSE);
d4116 4
d4121 1
a4121 1
    ARCHLIB PRIVLIB SITEARCH SITELIB VENDORARCH and VENDORLIB
d4124 2
a4125 34
    incpush(APPLLIB_EXP, TRUE, TRUE, TRUE, TRUE);
#endif

#ifdef ARCHLIB_EXP
    incpush(ARCHLIB_EXP, FALSE, FALSE, TRUE, TRUE);
#endif
#ifdef MACOS_TRADITIONAL
    {
	Stat_t tmpstatbuf;
    	SV * privdir = newSV(0);
	char * macperl = PerlEnv_getenv("MACPERL");
	
	if (!macperl)
	    macperl = "";
	
	Perl_sv_setpvf(aTHX_ privdir, "%slib:", macperl);
	if (PerlLIO_stat(SvPVX(privdir), &tmpstatbuf) >= 0 && S_ISDIR(tmpstatbuf.st_mode))
	    incpush(SvPVX(privdir), TRUE, FALSE, TRUE, FALSE);
	Perl_sv_setpvf(aTHX_ privdir, "%ssite_perl:", macperl);
	if (PerlLIO_stat(SvPVX(privdir), &tmpstatbuf) >= 0 && S_ISDIR(tmpstatbuf.st_mode))
	    incpush(SvPVX(privdir), TRUE, FALSE, TRUE, FALSE);
	
   	SvREFCNT_dec(privdir);
    }
    if (!PL_tainting)
	incpush(":", FALSE, FALSE, TRUE, FALSE);
#else
#ifndef PRIVLIB_EXP
#  define PRIVLIB_EXP "/usr/local/lib/perl5:/usr/local/lib/perl"
#endif
#if defined(WIN32)
    incpush(PRIVLIB_EXP, TRUE, FALSE, TRUE, TRUE);
#else
    incpush(PRIVLIB_EXP, FALSE, FALSE, TRUE, TRUE);
d4132 2
a4133 1
    incpush(SITEARCH_EXP, FALSE, FALSE, TRUE, TRUE);
d4140 3
a4142 1
    incpush(SITELIB_EXP, TRUE, FALSE, TRUE, TRUE);
d4144 1
a4144 1
    incpush(SITELIB_EXP, FALSE, FALSE, TRUE, TRUE);
a4147 5
#if defined(SITELIB_STEM) && defined(PERL_INC_VERSION_LIST)
    /* Search for version-specific dirs below here */
    incpush(SITELIB_STEM, FALSE, TRUE, TRUE, TRUE);
#endif

d4152 2
a4153 1
    incpush(PERL_VENDORARCH_EXP, FALSE, FALSE, TRUE, TRUE);
d4159 4
a4162 1
    incpush(PERL_VENDORLIB_EXP, TRUE, FALSE, TRUE, TRUE);	/* this picks up vendorarch as well */
d4164 2
a4165 1
    incpush(PERL_VENDORLIB_EXP, FALSE, FALSE, TRUE, TRUE);
d4169 18
a4186 2
#ifdef PERL_VENDORLIB_STEM /* Search for version-specific dirs below here */
    incpush(PERL_VENDORLIB_STEM, FALSE, TRUE, TRUE, TRUE);
d4190 16
a4205 1
    incpush(PERL_OTHERLIBDIRS, TRUE, TRUE, TRUE, TRUE);
d4207 44
d4253 1
a4253 2
	incpush(".", FALSE, FALSE, TRUE, FALSE);
#endif /* MACOS_TRADITIONAL */
d4262 1
a4262 5
#    if defined(MACOS_TRADITIONAL)
#      define PERLLIB_SEP ','
#    else
#      define PERLLIB_SEP ':'
#    endif
d4273 1
a4273 1
S_incpush_if_exists(pTHX_ SV *dir)
d4282 5
a4286 2
	av_push(GvAVn(PL_incgv), dir);
	dir = newSV(0);
d4292 1
a4292 2
S_incpush(pTHX_ const char *dir, bool addsubdirs, bool addoldvers, bool usesep,
	  bool canrelocate)
d4295 14
a4308 2
    SV *subdir = NULL;
    const char *p = dir;
d4310 2
a4311 2
    if (!p || !*p)
	return;
d4313 22
a4334 16
    if (addsubdirs || addoldvers) {
	subdir = newSV(0);
    }

    /* Break at all separators */
    while (p && *p) {
	SV *libdir = newSV(0);
        const char *s;

	/* skip any consecutive separators */
	if (usesep) {
	    while ( *p == PERLLIB_SEP ) {
		/* Uncomment the next line for PATH semantics */
		/* av_push(GvAVn(PL_incgv), newSVpvs(".")); */
		p++;
	    }
a4336 19
	if ( usesep && (s = strchr(p, PERLLIB_SEP)) != NULL ) {
	    sv_setpvn(libdir, PERLLIB_MANGLE(p, (STRLEN)(s - p)),
		      (STRLEN)(s - p));
	    p = s + 1;
	}
	else {
	    sv_setpv(libdir, PERLLIB_MANGLE(p, 0));
	    p = NULL;	/* break out */
	}
#ifdef MACOS_TRADITIONAL
	if (!strchr(SvPVX(libdir), ':')) {
	    char buf[256];

	    sv_setpv(libdir, MacPerl_CanonDir(SvPVX(libdir), buf, 0));
	}
	if (SvPVX(libdir)[SvCUR(libdir)-1] != ':')
	    sv_catpvs(libdir, ":");
#endif

d4440 2
a4441 1
	if (addsubdirs || addoldvers) {
d4451 1
d4462 4
a4465 10
	    if (addsubdirs) {
#ifdef MACOS_TRADITIONAL
#define PERL_ARCH_FMT_PREFIX	""
#define PERL_ARCH_FMT_SUFFIX	":"
#define PERL_ARCH_FMT_PATH	PERL_FS_VERSION ""
#else
#define PERL_ARCH_FMT_PREFIX	"/"
#define PERL_ARCH_FMT_SUFFIX	""
#define PERL_ARCH_FMT_PATH	"/" PERL_FS_VERSION
#endif
d4467 2
a4468 4
		sv_setsv(subdir, libdir);
		sv_catpvs(subdir, PERL_ARCH_FMT_PATH \
			  PERL_ARCH_FMT_PREFIX ARCHNAME PERL_ARCH_FMT_SUFFIX);
		subdir = S_incpush_if_exists(aTHX_ subdir);
d4471 2
a4472 10
		sv_setsv(subdir, libdir);
		sv_catpvs(subdir, PERL_ARCH_FMT_PATH);
		subdir = S_incpush_if_exists(aTHX_ subdir);

		/* .../archname if -d .../archname */
		sv_setsv(subdir, libdir);
		sv_catpvs(subdir,
			  PERL_ARCH_FMT_PREFIX ARCHNAME PERL_ARCH_FMT_SUFFIX);
		subdir = S_incpush_if_exists(aTHX_ subdir);

d4479 2
a4480 4
		    Perl_sv_setpvf(aTHX_ subdir, "%"SVf PERL_ARCH_FMT_PREFIX \
				   "%s" PERL_ARCH_FMT_SUFFIX,
				   SVfARG(libdir), *incver);
		    subdir = S_incpush_if_exists(aTHX_ subdir);
d4484 10
d4496 29
a4524 2
	/* finally push this lib directory on the end of @@INC */
	av_push(GvAVn(PL_incgv), libdir);
d4526 29
a4554 3
    if (subdir) {
	assert (SvREFCNT(subdir) == 1);
	SvREFCNT_dec(subdir);
d4556 3
a4560 1

a4636 10
	    if (PL_statusvalue && !(PL_exit_flags & PERL_EXIT_EXPECTED)) {
		if (paramList == PL_beginav)
		    Perl_croak(aTHX_ "BEGIN failed--compilation aborted");
		else
		    Perl_croak(aTHX_ "%s failed--call queue aborted",
			       paramList == PL_checkav ? "CHECK"
			       : paramList == PL_initav ? "INIT"
			       : paramList == PL_unitcheckav ? "UNITCHECK"
			       : "END");
	    }
a4656 2
    DEBUG_S(PerlIO_printf(Perl_debug_log, "my_exit: thread %p, status %lu\n",
			  (void*)thr, (unsigned long) status));
@


1.19
log
@Merge in perl 5.10.1
@
text
@d1942 4
d1955 1
@


1.18
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d3 2
a4 2
 *    Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999,
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007 by Larry Wall and others
d12 5
a16 1
 * "A ship then new they built for him/of mithril and of elven glass" --Bilbo
a131 7
#ifdef IAMSUID
#ifndef DOSUID
#define DOSUID
#endif
#endif /* IAMSUID */

#ifdef SETUID_SCRIPTS_ARE_SECURE_NOW
d133 15
a147 2
#undef DOSUID
#endif
d152 1
a152 1
	PL_op = Perl_pp_entereval(aTHX); \
d158 1
a158 1
	PL_op = Perl_pp_entersub(aTHX); \
d164 1
a164 1
    call_sv((SV*)(cv), G_EVAL|G_DISCARD);
d201 3
d213 3
d241 3
d304 3
a306 1
    PERL_UNUSED_ARG(my_perl);
d311 1
d325 4
a328 1
       of caching the numeric forms.  */
d330 2
a331 1
    SvNV(&PL_sv_no);
d336 1
a337 1
    SvNV(&PL_sv_yes);
d374 3
a376 3
    sv_setpvn(PERL_DEBUG_PAD(0), "", 0);	/* For regex debugging. */
    sv_setpvn(PERL_DEBUG_PAD(1), "", 0);	/* ext/re needs these */
    sv_setpvn(PERL_DEBUG_PAD(2), "", 0);	/* even without DEBUGGING. */
d418 1
a418 2
    PL_patchlevel = Perl_newSVpvf(aTHX_ "v%d.%d.%d", (int)PERL_REVISION,
				  (int)PERL_VERSION, (int)PERL_SUBVERSION);
d462 4
d499 2
d603 2
d606 1
d671 1
a671 1
	    static const char success[sizeof(int) + 1];
d854 2
d914 1
a914 7
            if (SvFLAGS(resv) & SVf_BREAK) {
                /* this is PL_reg_curpm, already freed
                 * flag is set in regexec.c:S_regtry
                 */
                SvFLAGS(resv) &= ~SVf_BREAK;
            }
	    else if(SvREPADTMP(resv)) {
d928 1
a928 1
    SvREFCNT_dec((SV*) PL_stashcache);
a1154 2
    SvFLAGS(PL_fdpid) |= SVTYPEMASK;		/* don't clean out pid table now */
    SvFLAGS(PL_strtab) |= SVTYPEMASK;		/* don't clean out strtab now */
d1157 1
a1157 1
    while (PL_sv_count > 2 && sv_clean_all())
a1159 5
    SvFLAGS(PL_fdpid) &= ~SVTYPEMASK;
    SvFLAGS(PL_fdpid) |= SVt_PVAV;
    SvFLAGS(PL_strtab) &= ~SVTYPEMASK;
    SvFLAGS(PL_strtab) |= SVt_PVHV;

d1241 1
a1241 1
	for (sva = PL_sv_arenaroot; sva; sva = (SV*)SvANY(sva)) {
d1249 2
a1250 1
			(void*)sv, sv->sv_flags, sv->sv_refcnt pTHX__VALUE,
d1284 4
d1384 2
d1397 1
d1400 5
d1407 1
d1537 2
d1540 1
d1542 3
a1544 6
#ifdef SETUID_SCRIPTS_ARE_SECURE_NOW
#ifdef IAMSUID
#undef IAMSUID
    Perl_croak(aTHX_ "suidperl is no longer needed since the kernel can now execute\n\
setuid perl scripts securely.\n");
#endif /* IAMSUID */
d1727 1
d1729 1
d1740 1
a1740 1
    sv_setpvn(linestr_sv,"",0);
d1819 1
a1819 1
	    forbid_setid('e', -1);
d1843 1
a1843 1
	    forbid_setid('I', -1);
d1860 1
a1860 1
	    forbid_setid('P', -1);
d1866 1
a1866 1
	    forbid_setid('S', -1);
d1906 3
d1915 3
a1927 1

d1938 1
a1938 1
					       0, PL_localpatches[i], 0);
a1941 4
#ifdef __OpenBSD__
		    Perl_sv_catpvf(aTHX_ opts_prog,
				   "\"  Built under OpenBSD\\n\"");
#else
d1946 2
a1947 3
		    Perl_sv_catpvf(aTHX_ opts_prog,
				   "  Compiled at %s %s\\n\"",__DATE__,
				   __TIME__);
d1949 1
a1949 2
		    Perl_sv_catpvf(aTHX_ opts_prog,"  Compiled on %s\\n\"",
				   __DATE__);
a1951 1
#endif
a2015 1
    	const char *popt = s;
d2026 1
a2026 1
	        char *d;
d2042 3
a2044 3
			    popt_copy = SvPVX(sv_2mortal(newSVpv(popt,0)));
			    s = popt_copy + (s - popt);
			    d = popt_copy + (d - popt);
d2092 6
a2097 3
	int suidscript;
	const int fdscript
	    = open_script(scriptname, dosearch, sv, &suidscript, &rsfp);
d2125 1
a2125 1
	    /* This will croak if suidscript is >= 0, as -x cannot be used with
d2128 1
a2128 1
	    /* Hence you can't get here if suidscript >= 0  */
d2136 1
a2136 1
    PL_main_cv = PL_compcv = (CV*)newSV_type(SVt_PVCV);
d2206 1
a2206 1
			     sv_setpvn(sv, ":utf8\0:utf8", 11);
d2208 1
a2208 1
			     sv_setpvn(sv, ":utf8\0", 6);
d2211 1
a2211 1
			sv_setpvn(sv, "\0:utf8", 6);
d2332 2
d2335 1
d2442 4
a2445 3
Returns the SV of the specified Perl scalar.  If C<create> is set and the
Perl variable does not exist then it will be created.  If C<create> is not
set and the variable does not exist then NULL is returned.
d2451 1
a2451 1
Perl_get_sv(pTHX_ const char *name, I32 create)
d2454 4
a2457 1
    gv = gv_fetchpv(name, create, SVt_PV);
d2468 4
a2471 3
Returns the AV of the specified Perl array.  If C<create> is set and the
Perl variable does not exist then it will be created.  If C<create> is not
set and the variable does not exist then NULL is returned.
d2477 1
a2477 1
Perl_get_av(pTHX_ const char *name, I32 create)
d2479 5
a2483 2
    GV* const gv = gv_fetchpv(name, create, SVt_PVAV);
    if (create)
d2495 4
a2498 3
Returns the HV of the specified Perl hash.  If C<create> is set and the
Perl variable does not exist then it will be created.  If C<create> is not
set and the variable does not exist then NULL is returned.
d2504 1
a2504 1
Perl_get_hv(pTHX_ const char *name, I32 create)
d2506 5
a2510 2
    GV* const gv = gv_fetchpv(name, create, SVt_PVHV);
    if (create)
d2542 3
d2546 1
a2546 2
	SV *const sv = newSVpvn(name,len);
	SvFLAGS(sv) |= flags & SVf_UTF8;
d2559 2
d2586 2
d2591 1
a2591 1
	    XPUSHs(sv_2mortal(newSVpv(*argv,0)));
d2612 3
a2614 1
    return call_sv((SV*)get_cv(sub_name, TRUE), flags);
d2631 2
d2647 1
a2647 1
Perl_call_sv(pTHX_ SV *sv, I32 flags)
d2661 2
d2672 1
a2672 3
    myop.op_flags |= ((flags & G_VOID) ? OPf_WANT_VOID :
		      (flags & G_ARRAY) ? OPf_WANT_LIST :
		      OPf_WANT_SCALAR);
d2686 1
a2686 1
	  && (SvTYPE(sv) != SVt_PVCV || CvSTASH((CV*)sv) != PL_debstash)
d2694 1
d2696 1
d2719 3
a2721 2
	    if (!(flags & G_KEEPERR))
		sv_setpvn(ERRSV,"",0);
d2742 1
a2742 1
	    if (flags & G_ARRAY)
d2790 2
d2807 1
a2807 3
    myop.op_flags |= ((flags & G_VOID) ? OPf_WANT_VOID :
		      (flags & G_ARRAY) ? OPf_WANT_LIST :
		      OPf_WANT_SCALAR);
d2821 3
a2823 2
	if (!(flags & G_KEEPERR))
	    sv_setpvn(ERRSV,"",0);
d2844 1
a2844 1
	if (flags & G_ARRAY)
d2879 2
d2889 1
a2889 1
	Perl_croak(aTHX_ SvPVx_nolen_const(ERRSV));
d2914 3
d2930 2
d2933 1
a2933 1
	sv_magic(GvSV(gv), (SV*)gv, PERL_MAGIC_sv, name, namlen);
d2977 2
d3002 1
a3002 1
      "  m  Memory allocation",
d3021 3
d3061 3
d3105 1
a3105 1
	 sv_setsv(get_sv("/", TRUE), PL_rs);
d3129 1
a3129 1
	forbid_setid('d', -1);
d3167 1
a3167 1
	forbid_setid('D', -1);
d3203 1
a3203 1
	forbid_setid('I', -1);
d3252 1
a3252 1
	forbid_setid('M', -1);	/* XXX ? */
d3255 1
a3255 1
	forbid_setid('m', -1);	/* XXX ? */
d3261 1
d3269 15
a3283 1
	    while(isALNUM(*s) || *s==':') ++s;
d3287 1
a3287 1
		if (*(start-1) == 'm') {
a3292 3
                if (s == start)
                    Perl_croak(aTHX_ "Module name required with -%c option",
			       s[-1]);
d3304 1
a3304 1
	    Perl_croak(aTHX_ "Missing argument to -%c", *(s-1));
d3315 1
a3315 1
	forbid_setid('s', -1);
d3344 2
a3345 2
	PerlIO_printf(PerlIO_stdout(),
		Perl_form(aTHX_ "\nThis is perl, %"SVf
d3347 21
a3367 5
			  " DEVEL" STRINGIFY(PERL_PATCHNUM)
#endif
			  " built for %s",
			  SVfARG(vstringify(PL_patchlevel)),
			  ARCHNAME));
a3379 1

d3390 1
a3390 1
		      "\n\nCopyright 1987-2007, Larry Wall\n");
d3488 4
a3491 2
	if (s[1] == '-')	/* Additional switches on #! line. */
	    return s+2;
d3604 1
a3604 1
    GvHV(gv) = (HV*)SvREFCNT_inc_simple(PL_defstash);
d3624 1
a3624 1
    sv_setpvn(ERRSV, "", 0);
d3631 1
a3631 1
    sv_setpvn(get_sv("/", TRUE), "\n", 1);
d3636 1
a3636 1
	      int *suidscript, PerlIO **rsfpp)
d3647 1
a3647 1
    *suidscript = -1;
d3671 1
a3671 1
		*suidscript = 1;
d3714 1
a3714 1
    if (*suidscript != 1) {
d3982 1
d3984 9
a3992 2
S_validate_suid(pTHX_ const char *validarg, const char *scriptname,
		int fdscript, int suidscript, SV *linestr_sv, PerlIO *rsfp)
d3995 3
a3997 3
#ifdef IAMSUID
    /* int which; */
#endif /* IAMSUID */
a4025 3
#ifdef DOSUID
    const char *s, *s2;

d4034 1
a4034 1
	if (fdscript < 0 || suidscript != 1)
d4240 1
a4240 3
	    PerlProc_execv(Perl_form(aTHX_ "%s/sperl"PERL_FS_VER_FMT, BIN_EXP,
				     (int)PERL_REVISION, (int)PERL_VERSION,
				     (int)PERL_SUBVERSION), PL_origargv);
d4311 1
a4311 1
    else if (fdscript < 0 || suidscript != 1)
a4356 7
/*  for (which = 1; PL_origargv[which] && PL_origargv[which] != scriptname; which++) ;	*/
/*  if (!PL_origargv[which]) {						*/
/*	errno = EPERM;							*/
/*	Perl_croak(aTHX_ "Permission denied\n");			*/
/*  }									*/
/*  PL_origargv[which] = savepv(Perl_form(aTHX_ "/dev/fd/%d/%s",	*/
/*				  PerlIO_fileno(rsfp), PL_origargv[which]));	*/
d4361 1
a4361 3
    PerlProc_execv(Perl_form(aTHX_ "%s/perl"PERL_FS_VER_FMT, BIN_EXP,
			     (int)PERL_REVISION, (int)PERL_VERSION,
			     (int)PERL_SUBVERSION), PL_origargv);/* try again */
d4365 2
d4368 1
a4368 3
    PERL_UNUSED_ARG(fdscript);
    PERL_UNUSED_ARG(suidscript);
    if (PL_euid != PL_uid || PL_egid != PL_gid) {	/* (suidperl doesn't exist, in fact) */
d4370 1
a4370 1
    PERL_UNUSED_ARG(rsfp);
d4372 8
a4387 1
#  endif /* SETUID_SCRIPTS_ARE_SECURE_NOW */
d4390 2
a4392 4
    PERL_UNUSED_ARG(validarg);
    PERL_UNUSED_ARG(scriptname);
    PERL_UNUSED_ARG(linestr_sv);
}
d4404 2
d4533 1
a4533 1
S_forbid_setid(pTHX_ const char flag, const int suidscript)
d4572 1
a4572 1
    if (suidscript >= 0)
d4672 1
a4672 1
    sv_setpvn(get_sv("\"", TRUE), " ", 1);
d4680 1
a4680 1
    GvIOp(tmpgv) = (IO*)SvREFCNT_inc_simple(io);
d4690 1
a4690 1
    GvIOp(tmpgv) = (IO*)SvREFCNT_inc_simple(io);
d4699 1
a4699 1
    GvIOp(tmpgv) = (IO*)SvREFCNT_inc_simple(io);
d4711 3
d4756 2
d4759 1
a4759 1
    sv_setpvn(PL_toptarget, "", 0);
d4761 1
a4761 1
    sv_setpvn(PL_bodytarget, "", 0);
d4802 1
a4802 1
	  char *s;
d4805 3
a4807 1
	    if (!(s = strchr(*env,'=')) || s == *env)
d4809 1
d4812 1
a4812 1
	    (void)strupr(*env);
d4816 1
a4816 1
	    (void)hv_store(hv, *env, s - *env, sv, 0);
d4836 1
a4836 1
      (void) get_av("main::F", TRUE | GV_ADDMULTI);
d4991 3
d5085 2
a5086 1
		prefix_sv = newSVpvn(SvPVX(caret_X), SvCUR(caret_X));
d5175 3
a5177 3
#define PERL_AV_SUFFIX_FMT	""
#define PERL_ARCH_FMT 		"%s:"
#define PERL_ARCH_FMT_PATH	PERL_FS_VER_FMT PERL_AV_SUFFIX_FMT
d5179 3
a5181 3
#define PERL_AV_SUFFIX_FMT 	"/"
#define PERL_ARCH_FMT 		"/%s"
#define PERL_ARCH_FMT_PATH	PERL_AV_SUFFIX_FMT PERL_FS_VER_FMT
d5184 3
a5186 4
		Perl_sv_setpvf(aTHX_ subdir, "%"SVf PERL_ARCH_FMT_PATH PERL_ARCH_FMT,
			       SVfARG(libdir),
			       (int)PERL_REVISION, (int)PERL_VERSION,
			       (int)PERL_SUBVERSION, ARCHNAME);
d5190 2
a5191 4
		Perl_sv_setpvf(aTHX_ subdir, "%"SVf PERL_ARCH_FMT_PATH,
			       SVfARG(libdir),
			       (int)PERL_REVISION, (int)PERL_VERSION,
			       (int)PERL_SUBVERSION);
d5195 3
a5197 2
		Perl_sv_setpvf(aTHX_ subdir, "%"SVf PERL_ARCH_FMT,
			       SVfARG(libdir), ARCHNAME);
d5206 2
a5207 1
		    Perl_sv_setpvf(aTHX_ subdir, "%"SVf PERL_ARCH_FMT,
d5236 2
d5239 1
a5239 1
	cv = (CV*)av_shift(paramList);
d5243 1
a5243 1
		Perl_av_create_and_push(aTHX_ &PL_beginav_save, (SV*)cv);
d5247 1
a5247 1
		Perl_av_create_and_push(aTHX_ &PL_checkav_save, (SV*)cv);
d5251 1
a5251 1
		Perl_av_create_and_push(aTHX_ &PL_unitcheckav_save, (SV*)cv);
d5361 2
a5362 3
	/* In POSIX_EXIT mode follow Perl documentations and use 255 for
	 * the exit code when there isn't an error.
	 */
d5364 3
a5366 4
	if (STATUS_UNIX == 0)
	    STATUS_UNIX_EXIT_SET(255);
	else {
	    STATUS_UNIX_EXIT_SET(STATUS_UNIX);
d5368 5
a5372 5
	    /* The exit code could have been set by $? or vmsish which
	     * means that it may not be fatal.  So convert
	     * success/warning codes to fatal.
	     */
	    if ((STATUS_NATIVE & (STS$K_SEVERE|STS$K_ERROR)) == 0)
d5374 2
d5377 12
@


1.17
log
@msg_controllen has to be CMSG_SPACE so that the kernel can account for
each cmsg_len (ie. msg_controllen = sum of CMSG_ALIGN(cmsg_len).  This
works now that kernel fd passing has been fixed to accept a bit of
sloppiness because of this ABI repair.
lots of discussion with kettenis
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006, by Larry Wall and others
d140 36
a175 9
#if defined(USE_5005THREADS)
#  define INIT_TLS_AND_INTERP \
    STMT_START {				\
	if (!PL_curinterp) {			\
	    PERL_SET_INTERP(my_perl);		\
	    INIT_THREADS;			\
	    ALLOC_THREAD_KEY;			\
	}					\
    } STMT_END
d177 1
a177 24
#  if defined(USE_ITHREADS)
#  define INIT_TLS_AND_INTERP \
    STMT_START {				\
	if (!PL_curinterp) {			\
	    PERL_SET_INTERP(my_perl);		\
	    INIT_THREADS;			\
	    ALLOC_THREAD_KEY;			\
	    PERL_SET_THX(my_perl);		\
	    OP_REFCNT_INIT;			\
	    MUTEX_INIT(&PL_dollarzero_mutex);	\
	}					\
	else {					\
	    PERL_SET_THX(my_perl);		\
	}					\
    } STMT_END
#  else
#  define INIT_TLS_AND_INTERP \
    STMT_START {				\
	if (!PL_curinterp) {			\
	    PERL_SET_INTERP(my_perl);		\
	}					\
	PERL_SET_THX(my_perl);			\
    } STMT_END
#  endif
d179 36
d227 1
a227 1
    INIT_TLS_AND_INTERP;
d238 1
a257 3
#ifdef USE_5005THREADS
    dTHX;
#endif
d262 2
a263 1
    INIT_TLS_AND_INTERP;
d265 5
d284 1
a284 6
#ifdef USE_5005THREADS
#ifndef FAKE_THREADS
    struct perl_thread *thr = NULL;
#endif /* FAKE_THREADS */
#endif /* USE_5005THREADS */

d293 1
a293 19
   /* Init the real globals (and main thread)? */
    if (!PL_linestr) {
#ifdef USE_5005THREADS
	MUTEX_INIT(&PL_sv_mutex);
	/*
	 * Safe to use basic SV functions from now on (though
	 * not things like mortals or tainting yet).
	 */
	MUTEX_INIT(&PL_eval_mutex);
	COND_INIT(&PL_eval_cond);
	MUTEX_INIT(&PL_threads_mutex);
	COND_INIT(&PL_nthreads_cond);
#  ifdef EMULATE_ATOMIC_REFCOUNTS
	MUTEX_INIT(&PL_svref_mutex);
#  endif /* EMULATE_ATOMIC_REFCOUNTS */
	
	MUTEX_INIT(&PL_cred_mutex);
	MUTEX_INIT(&PL_sv_lock_mutex);
	MUTEX_INIT(&PL_fdpid_mutex);
d295 2
a296 2
	thr = init_main_thread();
#endif /* USE_5005THREADS */
d298 2
a299 3
#ifdef PERL_FLEXIBLE_EXCEPTIONS
	PL_protect = MEMBER_TO_FPTR(Perl_default_protect); /* for exceptions */
#endif
d301 7
a307 1
	PL_curcop = &PL_compiling;	/* needed by ckWARN, right away */
d309 5
a313 2
	PL_linestr = NEWSV(65,79);
	sv_upgrade(PL_linestr,SVt_PVIV);
d315 2
a316 3
	if (!SvREADONLY(&PL_sv_undef)) {
	    /* set read-only and try to insure than we wont see REFCNT==0
	       very often */
d318 4
a321 2
	    SvREADONLY_on(&PL_sv_undef);
	    SvREFCNT(&PL_sv_undef) = (~(U32)0)/2;
d323 1
a323 23
	    sv_setpv(&PL_sv_no,PL_No);
	    /* value lookup in void context - happens to have the side effect
	       of caching the numeric forms.  */
	    SvIV(&PL_sv_no);
	    SvNV(&PL_sv_no);
	    SvREADONLY_on(&PL_sv_no);
	    SvREFCNT(&PL_sv_no) = (~(U32)0)/2;

	    sv_setpv(&PL_sv_yes,PL_Yes);
	    SvIV(&PL_sv_yes);
	    SvNV(&PL_sv_yes);
	    SvREADONLY_on(&PL_sv_yes);
	    SvREFCNT(&PL_sv_yes) = (~(U32)0)/2;

	    SvREADONLY_on(&PL_sv_placeholder);
	    SvREFCNT(&PL_sv_placeholder) = (~(U32)0)/2;
	}

	PL_sighandlerp = Perl_sighandler;
	PL_pidstatus = newHV();
    }

    PL_rs = newSVpvn("\n", 1);
a327 1
    PL_lex_state = LEX_NOTPARSING;
a334 22
    {
	U8 *s;
	PL_patchlevel = NEWSV(0,4);
	(void)SvUPGRADE(PL_patchlevel, SVt_PVNV);
	if (PERL_REVISION > 127 || PERL_VERSION > 127 || PERL_SUBVERSION > 127)
	    SvGROW(PL_patchlevel, UTF8_MAXLEN*3+1);
	s = (U8*)SvPVX(PL_patchlevel);
	/* Build version strings using "native" characters */
	s = uvchr_to_utf8(s, (UV)PERL_REVISION);
	s = uvchr_to_utf8(s, (UV)PERL_VERSION);
	s = uvchr_to_utf8(s, (UV)PERL_SUBVERSION);
	*s = '\0';
	SvCUR_set(PL_patchlevel, s - (U8*)SvPVX(PL_patchlevel));
	SvPOK_on(PL_patchlevel);
	SvNVX(PL_patchlevel) = (NV)PERL_REVISION +
			      ((NV)PERL_VERSION / (NV)1000) +
			      ((NV)PERL_SUBVERSION / (NV)1000000);
	SvNOK_on(PL_patchlevel);	/* dual valued */
	SvUTF8_on(PL_patchlevel);
	SvREADONLY_on(PL_patchlevel);
    }

d336 1
a336 1
    PL_localpatches = (char **) local_patches;	/* For possible -v */
d347 1
a347 1
    PL_errors = newSVpvn("",0);
d352 2
a353 2
    PL_regex_padav = newAV();
    av_push(PL_regex_padav,(SV*)newAV());    /* First entry is an array of empty elements */
a364 3
#ifdef USE_5005THREADS
    MUTEX_INIT(&PL_strtab_mutex);
#endif
d392 45
d452 1
d479 1
a479 1
       be open, the wait would be forever.  */
d565 2
a566 1
    volatile int destruct_level;  /* 0=none, 1=full, 2=full with checks */
a570 4
#ifdef USE_5005THREADS
    Thread t;
    dTHX;
#endif /* USE_5005THREADS */
a576 71
#ifdef USE_5005THREADS
#ifndef FAKE_THREADS
    /* Pass 1 on any remaining threads: detach joinables, join zombies */
  retry_cleanup:
    MUTEX_LOCK(&PL_threads_mutex);
    DEBUG_S(PerlIO_printf(Perl_debug_log,
			  "perl_destruct: waiting for %d threads...\n",
			  PL_nthreads - 1));
    for (t = thr->next; t != thr; t = t->next) {
	MUTEX_LOCK(&t->mutex);
	switch (ThrSTATE(t)) {
	    AV *av;
	case THRf_ZOMBIE:
	    DEBUG_S(PerlIO_printf(Perl_debug_log,
				  "perl_destruct: joining zombie %p\n", t));
	    ThrSETSTATE(t, THRf_DEAD);
	    MUTEX_UNLOCK(&t->mutex);
	    PL_nthreads--;
	    /*
	     * The SvREFCNT_dec below may take a long time (e.g. av
	     * may contain an object scalar whose destructor gets
	     * called) so we have to unlock threads_mutex and start
	     * all over again.
	     */
	    MUTEX_UNLOCK(&PL_threads_mutex);
	    JOIN(t, &av);
	    SvREFCNT_dec((SV*)av);
	    DEBUG_S(PerlIO_printf(Perl_debug_log,
				  "perl_destruct: joined zombie %p OK\n", t));
	    goto retry_cleanup;
	case THRf_R_JOINABLE:
	    DEBUG_S(PerlIO_printf(Perl_debug_log,
				  "perl_destruct: detaching thread %p\n", t));
	    ThrSETSTATE(t, THRf_R_DETACHED);
	    /*
	     * We unlock threads_mutex and t->mutex in the opposite order
	     * from which we locked them just so that DETACH won't
	     * deadlock if it panics. It's only a breach of good style
	     * not a bug since they are unlocks not locks.
	     */
	    MUTEX_UNLOCK(&PL_threads_mutex);
	    DETACH(t);
	    MUTEX_UNLOCK(&t->mutex);
	    goto retry_cleanup;
	default:
	    DEBUG_S(PerlIO_printf(Perl_debug_log,
				  "perl_destruct: ignoring %p (state %u)\n",
				  t, ThrSTATE(t)));
	    MUTEX_UNLOCK(&t->mutex);
	    /* fall through and out */
	}
    }
    /* We leave the above "Pass 1" loop with threads_mutex still locked */

    /* Pass 2 on remaining threads: wait for the thread count to drop to one */
    while (PL_nthreads > 1)
    {
	DEBUG_S(PerlIO_printf(Perl_debug_log,
			      "perl_destruct: final wait for %d threads\n",
			      PL_nthreads - 1));
	COND_WAIT(&PL_nthreads_cond, &PL_threads_mutex);
    }
    /* At this point, we're the last thread */
    MUTEX_UNLOCK(&PL_threads_mutex);
    DEBUG_S(PerlIO_printf(Perl_debug_log, "perl_destruct: armageddon has arrived\n"));
    MUTEX_DESTROY(&PL_threads_mutex);
    COND_DESTROY(&PL_nthreads_cond);
    PL_nthreads--;
#endif /* !defined(FAKE_THREADS) */
#endif /* USE_5005THREADS */

d607 2
a608 1
        return STATUS_NATIVE_EXPORT;
d779 1
a779 1
	PL_main_root = Nullop;
d781 1
a781 1
    PL_main_start = Nullop;
d783 1
a783 1
    PL_main_cv = Nullcv;
d802 1
a802 1
	    PL_defoutgv = Nullgv; /* may have been freed */
d807 1
a807 1
    PL_warnhook = Nullsv;
d809 1
a809 1
    PL_diehook = Nullsv;
a819 13
    if (destruct_level == 0){

	DEBUG_P(debprofdump());

#if defined(PERLIO_LAYERS)
	/* No more IO - including error messages ! */
	PerlIO_cleanup(aTHX);
#endif

	/* The exit() function will do everything that needs doing. */
        return STATUS_NATIVE_EXPORT;
    }

d846 16
d863 1
a863 1
    setdefout(Nullgv);
d873 1
a873 1
        SV **ary = AvARRAY(PL_regex_padav);
d876 1
a876 1
            SV *resv = ary[--i];
d894 1
a894 1
    PL_regex_padav = Nullav;
d903 4
a906 3
    if(PL_rsfp) {
	(void)PerlIO_close(PL_rsfp);
	PL_rsfp = Nullfp;
d909 4
a912 3
    /* Filters for program text */
    SvREFCNT_dec(PL_rsfp_filters);
    PL_rsfp_filters = Nullav;
d928 1
a928 1
    PL_inplace = Nullch;
d933 1
a933 1
	PL_e_script = Nullsv;
d941 1
a941 1
    PL_ofs_sv = Nullsv;
d944 1
a944 1
    PL_ors_sv = Nullsv;
d947 1
a947 1
    PL_rs = Nullsv;
a948 1
    PL_multiline = 0;		/* $* */
d950 1
a950 1
    PL_osname = Nullch;
d953 2
a954 2
    PL_statname = Nullsv;
    PL_statgv = Nullgv;
d960 1
a960 1
    PL_lastscream = Nullsv;
d968 1
a968 1
    PL_efloatbuf = Nullch;
d977 2
d980 8
a987 6
    PL_beginav = Nullav;
    PL_beginav_save = Nullav;
    PL_endav = Nullav;
    PL_checkav = Nullav;
    PL_checkav_save = Nullav;
    PL_initav = Nullav;
d990 19
a1008 19
    PL_envgv = Nullgv;
    PL_incgv = Nullgv;
    PL_hintgv = Nullgv;
    PL_errgv = Nullgv;
    PL_argvgv = Nullgv;
    PL_argvoutgv = Nullgv;
    PL_stdingv = Nullgv;
    PL_stderrgv = Nullgv;
    PL_last_in_gv = Nullgv;
    PL_replgv = Nullgv;
    PL_DBgv = Nullgv;
    PL_DBline = Nullgv;
    PL_DBsub = Nullgv;
    PL_DBsingle = Nullsv;
    PL_DBtrace = Nullsv;
    PL_DBsignal = Nullsv;
    PL_DBcv = Nullcv;
    PL_dbargs = Nullav;
    PL_debstash = Nullhv;
d1011 1
a1011 1
    PL_argvout_stack = Nullav;
d1014 1
a1014 1
    PL_modglobal = Nullhv;
d1016 1
a1016 1
    PL_preambleav = Nullav;
d1018 2
a1019 3
    PL_subname = Nullsv;
    SvREFCNT_dec(PL_linestr);
    PL_linestr = Nullsv;
d1021 2
a1022 1
    PL_pidstatus = Nullhv;
d1024 1
a1024 1
    PL_toptarget = Nullsv;
d1026 2
a1027 2
    PL_bodytarget = Nullsv;
    PL_formtarget = Nullsv;
d1032 1
a1032 1
    PL_collation_name = Nullch;
d1037 1
a1037 1
    PL_numeric_name = Nullch;
d1039 1
a1039 1
    PL_numeric_radix_sv = Nullsv;
d1063 20
a1082 20
    PL_utf8_alnum	= Nullsv;
    PL_utf8_alnumc	= Nullsv;
    PL_utf8_ascii	= Nullsv;
    PL_utf8_alpha	= Nullsv;
    PL_utf8_space	= Nullsv;
    PL_utf8_cntrl	= Nullsv;
    PL_utf8_graph	= Nullsv;
    PL_utf8_digit	= Nullsv;
    PL_utf8_upper	= Nullsv;
    PL_utf8_lower	= Nullsv;
    PL_utf8_print	= Nullsv;
    PL_utf8_punct	= Nullsv;
    PL_utf8_xdigit	= Nullsv;
    PL_utf8_mark	= Nullsv;
    PL_utf8_toupper	= Nullsv;
    PL_utf8_totitle	= Nullsv;
    PL_utf8_tolower	= Nullsv;
    PL_utf8_tofold	= Nullsv;
    PL_utf8_idstart	= Nullsv;
    PL_utf8_idcont	= Nullsv;
d1085 4
a1088 5
	SvREFCNT_dec(PL_compiling.cop_warnings);
    PL_compiling.cop_warnings = Nullsv;
    if (!specialCopIO(PL_compiling.cop_io))
	SvREFCNT_dec(PL_compiling.cop_io);
    PL_compiling.cop_io = Nullsv;
d1098 1
a1098 1
    PL_curstname = Nullsv;
d1102 3
a1104 1
    PL_errors = Nullsv;
d1139 1
a1139 1
    PL_fdpid = Nullav;
d1149 3
d1155 1
a1155 1
	HE ** const array = HvARRAY(PL_strtab);
d1160 1
d1163 3
a1165 3
		     (long)(HeVAL(hent) - Nullsv), HeKEY(hent));
		HeVAL(hent) = Nullsv;
		hent = HeNEXT(hent);
d1173 5
d1182 1
a1182 1
    /* free the pointer table used for cloning */
d1223 11
a1233 3
			" flags=0x08%"UVxf
			" refcnt=%"UVuf pTHX__FORMAT "\n",
			sv, sv->sv_flags, sv->sv_refcnt pTHX__VALUE);
d1262 5
d1274 1
a1274 1
       as currently layers use it rather than Nullsv as a marker
d1281 1
a1281 1
    PL_origfilename = Nullch;
d1294 1
a1294 1
    PL_bitcount = Nullch;
d1297 1
a1297 3
    PL_formfeed = Nullsv;
    Safefree(PL_ofmt);
    PL_ofmt = Nullch;
a1304 17
#ifdef USE_5005THREADS
    MUTEX_DESTROY(&PL_strtab_mutex);
    MUTEX_DESTROY(&PL_sv_mutex);
    MUTEX_DESTROY(&PL_eval_mutex);
    MUTEX_DESTROY(&PL_cred_mutex);
    MUTEX_DESTROY(&PL_fdpid_mutex);
    COND_DESTROY(&PL_eval_cond);
#ifdef EMULATE_ATOMIC_REFCOUNTS
    MUTEX_DESTROY(&PL_svref_mutex);
#endif /* EMULATE_ATOMIC_REFCOUNTS */

    /* As the penultimate thing, free the non-arena SV for thrsv */
    Safefree(SvPVX(PL_thrsv));
    Safefree(SvANY(PL_thrsv));
    Safefree(PL_thrsv);
    PL_thrsv = Nullsv;
#endif /* USE_5005THREADS */
d1312 6
d1338 1
a1338 1
	PL_mess_sv = Nullsv;
d1340 1
a1340 1
    return STATUS_NATIVE_EXPORT;
d1354 21
d1377 1
d1379 1
a1379 1
    void *host = nw_internal_host;
d1381 1
a1381 1
    void *host = w32_internal_host;
d1383 1
a1383 1
    PerlMem_free(aTHXx);
d1385 1
a1385 1
    nw_delete_internal_host(host);
d1387 1
a1387 1
    win32_delete_internal_host(host);
d1389 1
d1398 1
a1398 1
#if defined(USE_5005THREADS) || defined(USE_ITHREADS)
d1402 1
a1402 1
#if defined(__hpux) && __ux_version > 1020 && !defined(__GNUC__)
d1404 2
d1414 2
a1415 1
    if (PL_curinterp)
d1425 1
d1432 52
d1495 1
a1498 3
#ifdef USE_5005THREADS
    dTHX;
#endif
d1500 1
a1500 1
    PERL_UNUSED_VAR(my_perl);
d1529 4
a1532 1
    {
d1579 2
d1582 2
a1583 6
	 if (PL_origenviron) {
	      if ((PL_origenviron[0] == s + 1
#ifdef OS2
		   || (PL_origenviron[0] == s + 9 && (s += 8))
#endif 
		  )
d1591 1
a1591 1
#ifndef OS2
d1595 1
a1595 1
		   my_setenv("NoNe  SuCh", Nullch);
d1614 3
a1616 1
	 PL_origalen = s - PL_origargv[0];
d1627 4
d1637 1
a1637 1
	PL_main_root = Nullop;
d1639 1
a1639 1
    PL_main_start = Nullop;
d1641 1
a1641 1
    PL_main_cv = Nullcv;
a1646 3
#ifdef PERL_FLEXIBLE_EXCEPTIONS
    CALLPROTECT(aTHX_ pcur_env, &ret, MEMBER_TO_FPTR(S_vparse_body), env, xsinit);
#else
a1647 1
#endif
a1649 1
#ifndef PERL_FLEXIBLE_EXCEPTIONS
d1651 2
a1652 1
#endif
d1666 2
d1670 1
a1670 1
	ret = STATUS_NATIVE_EXPORT;
a1680 11
#ifdef PERL_FLEXIBLE_EXCEPTIONS
STATIC void *
S_vparse_body(pTHX_ va_list args)
{
    char **env = va_arg(args, char**);
    XSINIT_t xsinit = va_arg(args, XSINIT_t);

    return parse_body(env, xsinit);
}
#endif

d1684 2
d1692 2
a1693 2
    register char *s;
    const char *cddir = Nullch;
d1697 2
d1700 4
a1703 4
    PL_fdscript = -1;
    PL_suidscript = -1;
    sv_setpvn(PL_linestr,"",0);
    sv = newSVpvn("",0);		/* first used for -I flags */
d1707 2
d1726 1
a1726 1
	switch (*s) {
d1771 3
d1780 1
a1780 1
	    forbid_setid("-e");
d1782 2
a1783 2
		PL_e_script = newSVpvn("",0);
		filter_add(read_e_script, NULL);
d1792 2
a1793 2
		Perl_croak(aTHX_ "No code specified for -e");
	    sv_catpv(PL_e_script, "\n");
d1804 2
a1805 2
	    forbid_setid("-I");
	    if (!*++s && (s=argv[1]) != Nullch) {
d1811 2
a1812 2
		incpush(p, TRUE, TRUE, FALSE);
		sv_catpvn(sv, "-I", 2);
d1814 1
a1814 1
		sv_catpvn(sv, " ", 1);
d1821 1
a1821 1
	    forbid_setid("-P");
d1824 1
d1827 1
a1827 1
	    forbid_setid("-S");
d1835 1
a1835 4
		if (!PL_preambleav)
		    PL_preambleav = newAV();
		av_push(PL_preambleav,
			newSVpv("use Config;",0));
d1837 3
a1839 11
		    STRLEN opts;
		
		    opts_prog = newSVpv("print Config::myconfig(),",0);
#ifdef VMS
		    sv_catpv(opts_prog,"\"\\nCharacteristics of this PERLSHR image: \\n\",");
#else
		    sv_catpv(opts_prog,"\"\\nCharacteristics of this binary (from libperl): \\n\",");
#endif
		    opts = SvCUR(opts_prog);

		    Perl_sv_catpv(aTHX_ opts_prog,"\"  Compile-time options:"
d1843 2
a1844 14
#  ifdef DEBUG_LEAKING_SCALARS
			     " DEBUG_LEAKING_SCALARS"
#  endif
#  ifdef DEBUG_LEAKING_SCALARS_FORK_DUMP
			     " DEBUG_LEAKING_SCALARS_FORK_DUMP"
#  endif
#  ifdef FAKE_THREADS
			     " FAKE_THREADS"
#  endif
#  ifdef MULTIPLICITY
			     " MULTIPLICITY"
#  endif
#  ifdef MYMALLOC
			     " MYMALLOC"
a1848 9
#  ifdef PERL_GLOBAL_STRUCT
			     " PERL_GLOBAL_STRUCT"
#  endif
#  ifdef PERL_IMPLICIT_CONTEXT
			     " PERL_IMPLICIT_CONTEXT"
#  endif
#  ifdef PERL_IMPLICIT_SYS
			     " PERL_IMPLICIT_SYS"
#  endif
d1852 2
a1853 2
#  ifdef PERL_NEED_APPCTX
			     " PERL_NEED_APPCTX"
d1855 2
a1856 2
#  ifdef PERL_NEED_TIMESBASE
			     " PERL_NEED_TIMESBASE"
d1858 2
a1859 2
#  ifdef PERL_OLD_COPY_ON_WRITE
			     " PERL_OLD_COPY_ON_WRITE"
d1861 5
a1865 2
#  ifdef PERL_TRACK_MEMPOOL
			     " PERL_TRACK_MEMPOOL"
a1869 33
#  ifdef PL_OP_SLAB_ALLOC
			     " PL_OP_SLAB_ALLOC"
#  endif
#  ifdef THREADS_HAVE_PIDS
			     " THREADS_HAVE_PIDS"
#  endif
#  ifdef USE_5005THREADS
			     " USE_5005THREADS"
#  endif
#  ifdef USE_64_BIT_ALL
			     " USE_64_BIT_ALL"
#  endif
#  ifdef USE_64_BIT_INT
			     " USE_64_BIT_INT"
#  endif
#  ifdef USE_ITHREADS
			     " USE_ITHREADS"
#  endif
#  ifdef USE_LARGE_FILES
			     " USE_LARGE_FILES"
#  endif
#  ifdef USE_LONG_DOUBLE
			     " USE_LONG_DOUBLE"
#  endif
#  ifdef USE_PERLIO
			     " USE_PERLIO"
#  endif
#  ifdef USE_REENTRANT_API
			     " USE_REENTRANT_API"
#  endif
#  ifdef USE_SFIO
			     " USE_SFIO"
#  endif
d1873 1
a1873 4
#  ifdef USE_SOCKS
			     " USE_SOCKS"
#  endif
			     );
d1875 8
a1882 18
		    while (SvCUR(opts_prog) > opts+76) {
			/* find last space after "options: " and before col 76
			 */

			const char *space;
			char *pv = SvPV_nolen(opts_prog);
			const char c = pv[opts+76];
			pv[opts+76] = '\0';
			space = strrchr(pv+opts+26, ' ');
			pv[opts+76] = c;
			if (!space) break; /* "Can't happen" */

			/* break the line before that space */

			opts = space - pv;
			sv_insert(opts_prog, opts, 0,
				  "\\n                       ", 25);
		    }
d1884 1
a1884 1
		    sv_catpv(opts_prog,"\\n\",");
d1889 1
a1889 1
			sv_catpv(opts_prog,
d1898 4
d1903 1
a1903 2
				   "\"  Built under %s\\n\"",OSNAME);
#ifndef __OpenBSD__
d1907 1
a1907 1
				   ",\"  Compiled at %s %s\\n\"",__DATE__,
d1910 1
a1910 1
		    Perl_sv_catpvf(aTHX_ opts_prog,",\"  Compiled on %s\\n\"",
d1915 1
a1915 1
		    sv_catpv(opts_prog, "; $\"=\"\\n    \"; "
d1919 1
a1919 1
		    sv_catpv(opts_prog,
d1922 1
a1922 1
		    sv_catpv(opts_prog, 
d1966 2
d1970 3
d1988 1
a1988 1
	    char *popt_copy = Nullch;
d2001 1
a2001 1
		if (!strchr("DIMUdmtw", *s))
d2025 1
d2029 2
a2030 4
	if (!PL_preambleav)
	    PL_preambleav = newAV();
	av_unshift(PL_preambleav, 1);
	(void)av_store(PL_preambleav, 0, Perl_newSVpvf(aTHX_ "BEGIN { do '%s/sitecustomize.pl' }", SITELIB_EXP));
a2033 4
    if (PL_taint_warn && PL_dowarn != G_WARN_ALL_OFF) {
       PL_compiling.cop_warnings = newSVpvn(WARN_TAINTstring, WARNsize);
    }

d2040 1
a2040 1
    else if (scriptname == Nullch) {
d2048 5
d2055 4
a2058 1
    open_script(scriptname,dosearch,sv);
d2060 2
a2061 1
    validate_suid(validarg, scriptname);
d2064 12
a2075 11
#if defined(SIGCHLD) || defined(SIGCLD)
    {
#ifndef SIGCHLD
#  define SIGCHLD SIGCLD
#endif
	Sighandler_t sigstate = rsignal_state(SIGCHLD);
	if (sigstate == SIG_IGN) {
	    if (ckWARN(WARN_SIGNAL))
		Perl_warner(aTHX_ packWARN(WARN_SIGNAL),
			    "Can't ignore signal CHLD, forcing to default");
	    (void)rsignal(SIGCHLD, (Sighandler_t)SIG_DFL);
d2077 1
a2077 2
    }
#endif
d2080 1
d2082 1
a2082 3
    if (PL_doextract || gMacPerl_AlwaysExtract) {
#else
    if (PL_doextract) {
d2084 6
a2089 3
	find_beginning();
	if (cddir && PerlDir_chdir( (char *)cddir ) < 0)
	    Perl_croak(aTHX_ "Can't chdir to %s",cddir);
d2091 4
d2097 1
a2097 2
    PL_main_cv = PL_compcv = (CV*)NEWSV(1104,0);
    sv_upgrade((SV *)PL_compcv, SVt_PVCV);
d2101 2
a2102 5
#ifdef USE_5005THREADS
    CvOWNER(PL_compcv) = 0;
    Newx(CvMUTEXP(PL_compcv), 1, perl_mutex);
    MUTEX_INIT(CvMUTEXP(PL_compcv));
#endif /* USE_5005THREADS */
d2107 1
d2112 1
a2112 1
#if defined(VMS) || defined(WIN32) || defined(DJGPP) || defined(__CYGWIN__) || defined(EPOC)
d2136 1
a2136 1
#if defined(SYMBIAN)
d2161 2
a2162 1
		  (sv = GvSV(gv_fetchpv("\017PEN", TRUE, SVt_PV)))) {
d2178 2
d2188 1
d2190 31
a2220 1
    init_lexer();
a2224 1
    PL_error_count = 0;
d2226 1
a2226 1
    if (gMacPerl_SyntaxError = (yyparse() || PL_error_count)) {
d2235 1
a2235 1
    if (yyparse() || PL_error_count) {
d2249 1
a2249 1
	PL_e_script = Nullsv;
d2265 2
d2269 1
d2288 1
a2291 3
#ifdef USE_5005THREADS
    dTHX;
#endif
a2299 4
#ifdef PERL_FLEXIBLE_EXCEPTIONS
 redo_body:
    CALLPROTECT(aTHX_ pcur_env, &ret, MEMBER_TO_FPTR(S_vrun_body), oldscope);
#else
a2300 1
#endif
a2305 1
#ifndef PERL_FLEXIBLE_EXCEPTIONS
a2307 1
#endif
d2321 1
a2321 1
	ret = STATUS_NATIVE_EXPORT;
d2334 2
a2335 11
    JMPENV_POP;
    return ret;
}

#ifdef PERL_FLEXIBLE_EXCEPTIONS
STATIC void *
S_vrun_body(pTHX_ va_list args)
{
    I32 oldscope = va_arg(args, I32);

    return run_body(oldscope);
a2336 2
#endif

d2341 1
d2346 6
d2354 2
a2355 1
	PERL_DEBUG(PerlIO_printf(Perl_debug_log, "\nEXECUTING...\n\n"));
d2374 3
a2410 7
#ifdef USE_5005THREADS
    if (name[1] == '\0' && !isALPHA(name[0])) {
	PADOFFSET tmp = find_threadsv(name);
    	if (tmp != NOT_IN_PAD)
	    return THREADSV(tmp);
    }
#endif /* USE_5005THREADS */
d2414 1
a2414 1
    return Nullsv;
d2432 1
a2432 1
    GV* gv = gv_fetchpv(name, create, SVt_PVAV);
d2437 1
a2437 1
    return Nullav;
d2460 1
a2460 1
    return Nullhv;
d2466 8
d2476 1
a2476 4
Returns the CV of the specified Perl subroutine.  If C<create> is set and
the Perl subroutine does not exist then it will be declared (which has the
same effect as saying C<sub name;>).  If C<create> is not set and the
subroutine does not exist then NULL is returned.
d2482 1
a2482 1
Perl_get_cv(pTHX_ const char *name, I32 create)
d2484 1
a2484 2
    GV* gv = gv_fetchpv(name, create, SVt_PVCV);
    /* XXX unsafe for threads if eval_owner isn't held */
d2488 3
a2490 1
    if (create && !GvCVu(gv))
d2492 3
a2494 3
		      newSVOP(OP_CONST, 0, newSVpv(name,0)),
		      Nullop,
		      Nullop);
d2497 7
a2503 1
    return Nullcv;
d2525 1
d2586 1
a2586 1
    dSP;
d2590 1
a2590 1
    volatile I32 retval = 0;
d2594 1
a2594 1
    OP* oldop = PL_op;
d2603 1
a2603 1
    myop.op_next = Nullop;
d2636 1
a2636 1
	call_body((OP*)&myop, FALSE);
d2643 1
a2643 19
	/* we're trying to emulate pp_entertry() here */
	{
	    register PERL_CONTEXT *cx;
	    const I32 gimme = GIMME_V;
	
	    ENTER;
	    SAVETMPS;
	
	    push_return(Nullop);
	    PUSHBLOCK(cx, (CXt_EVAL|CXp_TRYBLOCK), PL_stack_sp);
	    PUSHEVAL(cx, 0, 0);
	    PL_eval_root = PL_op;             /* Only needed so that goto works right. */
	
	    PL_in_eval = EVAL_INEVAL;
	    if (flags & G_KEEPERR)
		PL_in_eval |= EVAL_KEEPERR;
	    else
		sv_setpvn(ERRSV,"",0);
	}
a2645 5
#ifdef PERL_FLEXIBLE_EXCEPTIONS
 redo_body:
	CALLPROTECT(aTHX_ pcur_env, &ret, MEMBER_TO_FPTR(S_vcall_body),
		    (OP*)&myop, FALSE);
#else
d2647 1
a2647 1
#endif
a2649 1
#ifndef PERL_FLEXIBLE_EXCEPTIONS
d2651 1
a2651 2
	    call_body((OP*)&myop, FALSE);
#endif
d2684 2
a2685 16
	if (PL_scopestack_ix > oldscope) {
	    SV **newsp;
	    PMOP *newpm;
	    I32 gimme;
	    register PERL_CONTEXT *cx;
	    I32 optype;

	    POPBLOCK(cx,newpm);
	    POPEVAL(cx);
	    pop_return();
	    PL_curpm = newpm;
	    LEAVE;
	    PERL_UNUSED_VAR(newsp);
	    PERL_UNUSED_VAR(gimme);
	    PERL_UNUSED_VAR(optype);
	}
a2698 25
#ifdef PERL_FLEXIBLE_EXCEPTIONS
STATIC void *
S_vcall_body(pTHX_ va_list args)
{
    OP *myop = va_arg(args, OP*);
    int is_eval = va_arg(args, int);

    call_body(myop, is_eval);
    return NULL;
}
#endif

STATIC void
S_call_body(pTHX_ const OP *myop, bool is_eval)
{
    if (PL_op == myop) {
	if (is_eval)
	    PL_op = Perl_pp_entereval(aTHX);	/* this doesn't do a POPMARK */
	else
	    PL_op = Perl_pp_entersub(aTHX);	/* this does */
    }
    if (PL_op)
	CALLRUNOPS(aTHX);
}

d2714 1
d2717 2
a2718 2
    volatile I32 oldmark = SP - PL_stack_base;
    volatile I32 retval = 0;
d2720 1
a2720 1
    OP* oldop = PL_op;
d2736 1
a2736 1
    myop.op_next = Nullop;
a2743 5
#ifdef PERL_FLEXIBLE_EXCEPTIONS
 redo_body:
    CALLPROTECT(aTHX_ pcur_env, &ret, MEMBER_TO_FPTR(S_vcall_body),
		(OP*)&myop, TRUE);
#else
a2748 1
#endif
a2750 1
#ifndef PERL_FLEXIBLE_EXCEPTIONS
d2752 1
a2752 2
	call_body((OP*)&myop,TRUE);
#endif
d2807 1
d2841 2
a2843 1
    dSP;
d2853 1
a2853 1
Perl_magicname(pTHX_ char *sym, char *name, I32 namlen)
d2855 1
a2855 1
    register GV *gv;
d2857 1
a2857 1
    if ((gv = gv_fetchpv(sym,TRUE, SVt_PV)))
d2868 29
a2896 28
"-0[octal]       specify record separator (\\0, if no argument)",
"-a              autosplit mode with -n or -p (splits $_ into @@F)",
"-C[number/list] enables the listed Unicode features",
"-c              check syntax only (runs BEGIN and CHECK blocks)",
"-d[:debugger]   run program under debugger",
"-D[number/list] set debugging flags (argument is a bit mask or alphabets)",
"-e program      one line of program (several -e's allowed, omit programfile)",
"-f              don't do $sitelib/sitecustomize.pl at startup",
"-F/pattern/     split() pattern for -a switch (//'s are optional)",
"-i[extension]   edit <> files in place (makes backup if extension supplied)",
"-Idirectory     specify @@INC/#include directory (several -I's allowed)",
"-l[octal]       enable line ending processing, specifies line terminator",
"-[mM][-]module  execute \"use/no module...\" before executing program",
"-n              assume \"while (<>) { ... }\" loop around program",
"-p              assume loop like -n but print line also, like sed",
"-P              run program through C preprocessor before compilation",
"-s              enable rudimentary parsing for switches after programfile",
"-S              look for programfile using PATH environment variable",
"-t              enable tainting warnings",
"-T              enable tainting checks",
"-u              dump core after parsing program",
"-U              allow unsafe operations",
"-v              print version, subversion (includes VERY IMPORTANT perl info)",
"-V[:variable]   print configuration summary (or a single Config.pm variable)",
"-w              enable many useful warnings (RECOMMENDED)",
"-W              enable all warnings",
"-x[directory]   strip off text before #!perl line and perhaps cd to directory",
"-X              disable all warnings",
d2914 1
a2914 7
Perl_get_debug_opts(pTHX_ char **s)
{
  return get_debug_opts_flags(s, 1);
}

int
Perl_get_debug_opts_flags(pTHX_ char **s, int flags)
d2946 1
a2946 1
	static const char debopts[] = "psltocPmfrxu HXDSTRJvC";
d2949 1
a2949 1
	    const char *d = strchr(debopts,**s);
d2961 1
a2961 2
    else if (flags & 1) {
      /* Give help.  */
d2976 2
a2977 2
char *
Perl_moreswitches(pTHX_ char *s)
d2979 1
d3003 1
a3003 1
	      PL_rs = newSVpvn("", 0);
d3016 1
a3016 1
		   PL_rs = newSVpvn("", 0);
d3027 3
a3029 1
        PL_unicode = parse_unicode_opts(&s);
d3035 1
a3035 2
	*s = '\0';
	PL_splitstr = savepv(PL_splitstr);
d3046 1
a3046 1
	forbid_setid("-d");
d3058 4
a3061 4
            const char *start;
	    SV *sv;
	    sv = newSVpv("use Devel::", 0);
	    start = ++s;
d3065 1
a3065 1
		sv_catpv(sv, start);
d3068 7
a3074 4
		Perl_sv_catpvf(aTHX_ sv, " split(/,/,q%c%s%c)", 0, ++s, 0);
	    }
	    s += strlen(s);
	    my_setenv("PERL5DB", (char *)SvPV_nolen_const(sv));
d3084 1
a3084 1
	forbid_setid("-D");
d3086 1
a3086 1
	PL_debug = get_debug_opts_flags( &s, 1) | DEBUG_TOP_FLAG;
d3102 1
a3102 1
	PL_inplace = savepv(".bak");
d3106 7
a3112 3
	PL_inplace = savepv(s+1);
	for (s = PL_inplace; *s && !isSPACE(*s); s++)
	    ;
d3114 1
a3114 1
	    *s++ = '\0';
d3116 1
a3116 1
	        s++;
d3120 1
a3120 1
	forbid_setid("-I");
d3125 1
a3125 1
	    char *e, *p;
d3135 1
a3135 1
	    incpush(e, TRUE, TRUE, FALSE);
d3149 1
a3149 1
	    PL_ors_sv = Nullsv;
d3154 1
a3154 1
	    PL_ors_sv = newSVpvn("\n",1);
d3161 1
a3161 1
		PL_ors_sv = newSVpvn("\n\n",2);
d3169 1
a3169 1
	forbid_setid("-M");	/* XXX ? */
d3172 1
a3172 1
	forbid_setid("-m");	/* XXX ? */
d3174 2
a3175 1
	    char *start;
d3186 1
d3188 1
a3188 1
		sv_catpv(sv, start);
d3192 1
a3192 1
		    sv_catpv( sv, " ()");
d3199 8
a3206 9
		sv_catpv(sv, " split(/,/,q");
		sv_catpvn(sv, "\0)", 1);        /* Use NUL as q//-delimiter. */
		sv_catpv(sv, ++s);
		sv_catpvn(sv,  "\0)", 2);
	    }
	    s += strlen(s);
	    if (!PL_preambleav)
		PL_preambleav = newAV();
	    av_push(PL_preambleav, sv);
d3220 1
a3220 1
	forbid_setid("-s");
d3246 2
d3250 7
a3256 2
		      Perl_form(aTHX_ "\nThis is perl, v%"VDf" built for %s",
				PL_patchlevel, ARCHNAME));
d3260 2
a3261 1
			Perl_form(aTHX_ "\nThis is perl, version %vd\n", PL_patchlevel));
d3275 1
a3275 1
			  (int)LOCAL_PATCH_COUNT,
d3280 1
a3280 1
		      "\n\nCopyright 1987-2006, Larry Wall\n");
d3341 4
d3357 1
a3357 1
	if (! (PL_dowarn & G_WARN_ALL_MASK))
d3359 1
d3365 1
a3365 1
            SvREFCNT_dec(PL_compiling.cop_warnings);
d3372 1
a3372 1
            SvREFCNT_dec(PL_compiling.cop_warnings);
d3400 1
a3400 1
    return Nullch;
d3411 1
d3413 2
a3414 2
    SV*    prog;
    SV*    file;
d3418 2
a3419 4
    prog = newSVpv(BIN_EXP, 0);
    sv_catpv(prog, "/perl");
    file = newSVpv(PL_origfilename, 0);
    sv_catpv(file, ".perldump");
d3428 2
d3440 1
a3440 1

d3445 2
a3446 7
#    if defined(USE_5005THREADS)
#      define PERLVARI(var,type,init)		PERL_GET_INTERP->var = init;
#      define PERLVARIC(var,type,init)		PERL_GET_INTERP->var = init;
#    else /* !USE_5005THREADS */
#      define PERLVARI(var,type,init)		aTHX->var = init;
#      define PERLVARIC(var,type,init)	aTHX->var = init;
#    endif /* USE_5005THREADS */
a3451 3
#  ifndef USE_5005THREADS
#    include "thrdvar.h"
#  endif
a3461 3
#  ifndef USE_5005THREADS
#    include "thrdvar.h"
#  endif
d3468 4
d3477 1
d3481 9
a3489 2
    PL_curstname = newSVpvn("main",4);
    gv = gv_fetchpv("main::",TRUE, SVt_PVHV);
d3491 2
a3492 1
    GvHV(gv) = (HV*)SvREFCNT_inc(PL_defstash);
d3494 3
a3496 2
    hv_name_set(PL_defstash, "main", 4, 0);
    PL_incgv = gv_HVadd(gv_AVadd(gv_fetchpv("INC",TRUE, SVt_PVAV)));
d3498 1
a3498 1
    PL_hintgv = gv_fetchpv("\010",TRUE, SVt_PV); /* ^H */
d3500 4
a3503 2
    PL_defgv = gv_fetchpv("_",TRUE, SVt_PVAV);
    PL_errgv = gv_HVadd(gv_fetchpv("@@", TRUE, SVt_PV));
d3505 1
a3505 1
    PL_replgv = gv_fetchpv("\022", TRUE, SVt_PV); /* ^R */
d3515 3
a3517 3
    PL_debstash = GvHV(gv_fetchpv("DB::", GV_ADDMULTI, SVt_PVHV));
    PL_globalstash = GvHV(gv_fetchpv("CORE::GLOBAL::", GV_ADDMULTI, SVt_PVHV));
    PL_nullstash = GvHV(gv_fetchpv("<none>::", GV_ADDMULTI, SVt_PVHV));
d3522 3
a3524 3
/* PSz 18 Nov 03  fdscript now global but do not change prototype */
STATIC void
S_open_script(pTHX_ const char *scriptname, bool dosearch, SV *sv)
d3532 2
d3535 1
a3535 2
    PL_fdscript = -1;
    PL_suidscript = -1;
d3538 1
a3538 1
	PL_origfilename = savepv("-e");
d3542 1
a3542 1
	scriptname = PL_origfilename = find_script((char *)scriptname, dosearch, NULL, 1);
d3546 1
a3546 1
	    PL_fdscript = atoi(s);
d3559 1
a3559 1
		PL_suidscript = 1;
d3581 2
a3582 2
    if (PL_fdscript >= 0) {
	PL_rsfp = PerlIO_fdopen(PL_fdscript,PERL_SCRIPT_MODE);
d3584 1
a3584 1
	    if (PL_rsfp)
d3586 1
a3586 1
	        fcntl(PerlIO_fileno(PL_rsfp),F_SETFD,1);
d3602 1
a3602 1
    if (PL_suidscript != 1) {
d3607 3
a3609 3
	const char *cpp_cfg = CPPSTDIN;
	SV *cpp = newSVpvn("",0);
	SV *cmd = NEWSV(0,0);
d3618 1
a3618 1
	    sv_catpvn(sv, "-I", 2);
d3659 2
a3660 2
                       perl, quote, code, quote, scriptname, cpp,
                       cpp_discard_flag, sv, CPPMINUS);
d3668 1
a3668 1
	PL_rsfp = PerlProc_popen((char *)SvPVX_const(cmd), (char *)"r");
d3673 2
a3674 2
	forbid_setid("program input from stdin");
	PL_rsfp = PerlIO_stdin();
d3677 41
a3717 1
	PL_rsfp = PerlIO_open(scriptname,PERL_SCRIPT_MODE);
d3719 1
a3719 1
	    if (PL_rsfp)
d3721 1
a3721 1
	        fcntl(PerlIO_fileno(PL_rsfp),F_SETFD,1);
d3725 1
a3725 1
    if (!PL_rsfp) {
d3733 1
d3871 2
a3872 1
S_validate_suid(pTHX_ const char *validarg, const char *scriptname)
d3874 1
d3909 1
a3909 1
    if (PerlLIO_fstat(PerlIO_fileno(PL_rsfp),&PL_statbuf) < 0)	/* normal stat is insecure */
d3914 1
d3916 2
a3917 2
#ifdef IAMSUID
	if (PL_fdscript < 0 || PL_suidscript != 1)
d3927 1
a3927 1
#ifdef HAS_SETREUID
d3931 2
a3932 2
#endif
#ifdef HAS_SETREUID
d3936 1
a3936 1
#endif
d3997 2
a3998 2
#if !defined(NO_NOSUID_CHECK)
	if (fd_on_nosuid_fs(PerlIO_fileno(PL_rsfp))) {
d4001 2
a4002 2
#endif
#endif /* IAMSUID */
d4012 1
a4012 1
	if (sv_gets(PL_linestr, PL_rsfp, 0) == Nullch)
d4014 1
a4014 1
	linestr = SvPV_nolen_const(PL_linestr);
d4022 2
a4023 1
	if (strlen(s) < 1 || strlen(s) > 4000)
d4062 2
a4063 1
	    !(strlen(s) == len+1 || (strlen(s) == len+2 && isSPACE(s[len+1]))))
d4066 2
a4067 2
#ifndef IAMSUID
	if (PL_fdscript < 0 &&
d4073 1
a4073 1
#endif /* IAMSUID */
d4075 1
a4075 1
	if (PL_fdscript < 0 &&
d4088 1
a4088 1
	     * PL_fdscript to avoid loops), and do the execs
d4091 1
a4091 1
#ifndef IAMSUID
d4100 2
a4101 2
	    PerlIO_rewind(PL_rsfp);
	    PerlLIO_lseek(PerlIO_fileno(PL_rsfp),(Off_t)0,0);  /* just in case rewind didn't */
d4118 4
a4121 4
					  PerlIO_fileno(PL_rsfp), PL_origargv[which]));
#if defined(HAS_FCNTL) && defined(F_SETFD)
	    fcntl(PerlIO_fileno(PL_rsfp),F_SETFD,0);	/* ensure no close-on-exec */
#endif
d4127 1
a4127 1
#endif /* IAMSUID */
d4138 1
a4138 1
#ifdef HAS_SETEGID
d4140 2
a4141 2
#else
#ifdef HAS_SETREGID
d4143 2
a4144 2
#else
#ifdef HAS_SETRESGID
d4146 1
a4146 1
#else
d4148 3
a4150 3
#endif
#endif
#endif
d4156 1
a4156 1
#ifdef HAS_SETEUID
d4158 2
a4159 2
#else
#ifdef HAS_SETREUID
d4161 2
a4162 2
#else
#ifdef HAS_SETRESUID
d4164 1
a4164 1
#else
d4166 3
a4168 3
#endif
#endif
#endif
d4173 1
a4173 1
#ifdef HAS_SETEUID
d4175 2
a4176 2
#else
#ifdef HAS_SETREUID
d4178 2
a4179 2
#else
#ifdef HAS_SETRESUID
d4181 1
a4181 1
#else
d4183 3
a4185 3
#endif
#endif
#endif
d4193 1
a4193 1
#ifdef IAMSUID
d4196 1
a4196 1
    else if (PL_fdscript < 0 || PL_suidscript != 1)
d4237 2
a4238 2
    PerlIO_rewind(PL_rsfp);
    PerlLIO_lseek(PerlIO_fileno(PL_rsfp),(Off_t)0,0);  /* just in case rewind didn't */
d4248 4
a4251 4
/*				  PerlIO_fileno(PL_rsfp), PL_origargv[which]));	*/
#if defined(HAS_FCNTL) && defined(F_SETFD)
    fcntl(PerlIO_fileno(PL_rsfp),F_SETFD,0);	/* ensure no close-on-exec */
#endif
d4258 1
a4258 1
#endif /* IAMSUID */
d4260 2
d4263 4
a4266 2
#ifndef SETUID_SCRIPTS_ARE_SECURE_NOW
	PerlLIO_fstat(PerlIO_fileno(PL_rsfp),&PL_statbuf);	/* may be either wrapped or real suid */
d4274 1
a4274 1
#endif /* SETUID_SCRIPTS_ARE_SECURE_NOW */
d4278 3
a4280 2
    (void)validarg;
    (void)scriptname;
d4284 1
a4284 1
S_find_beginning(pTHX)
d4286 2
a4287 1
    register char *s;
a4294 1
    forbid_setid("-x");
d4299 1
a4299 1
	if ((s = sv_gets(PL_linestr, PL_rsfp, 0)) == Nullch) {
d4310 1
a4310 1
	    PerlIO_rewind(PL_rsfp);
d4316 1
a4316 1
	if ((s = sv_gets(PL_linestr, PL_rsfp, 0)) == Nullch)
d4321 1
a4321 1
	    PerlIO_ungetc(PL_rsfp, '\n');		/* to keep line count right */
d4339 1
a4339 1
		PerlIO_ungetc(PL_rsfp, '\n');
d4355 1
d4415 4
d4420 1
a4420 1
S_forbid_setid(pTHX_ const char *s)
d4422 9
d4433 1
a4433 1
        Perl_croak(aTHX_ "No %s allowed while running setuid", s);
d4435 1
a4435 1
        Perl_croak(aTHX_ "No %s allowed while running setgid", s);
d4459 2
a4460 2
    if (PL_suidscript >= 0)
        Perl_croak(aTHX_ "No %s allowed with (suid) fdscript", s);
d4463 1
a4463 1
    Perl_croak(aTHX_ "No %s allowed in suidperl", s);
d4470 2
a4471 1
    HV *ostash = PL_curstash;
d4474 2
a4475 1
    PL_dbargs = GvAV(gv_AVadd((gv_fetchpv("DB::args", GV_ADDMULTI, SVt_PVAV))));
d4477 4
a4480 4
    PL_DBgv = gv_fetchpv("DB::DB", GV_ADDMULTI, SVt_PVGV);
    PL_DBline = gv_fetchpv("DB::dbline", GV_ADDMULTI, SVt_PVAV);
    PL_DBsub = gv_HVadd(gv_fetchpv("DB::sub", GV_ADDMULTI, SVt_PVHV));
    PL_DBsingle = GvSV((gv_fetchpv("DB::single", GV_ADDMULTI, SVt_PV)));
d4482 1
a4482 1
    PL_DBtrace = GvSV((gv_fetchpv("DB::trace", GV_ADDMULTI, SVt_PV)));
d4484 1
a4484 1
    PL_DBsignal = GvSV((gv_fetchpv("DB::signal", GV_ADDMULTI, SVt_PV)));
d4498 1
a4527 4

    New(54,PL_retstack,REASONABLE(16),OP*);
    PL_retstack_ix = 0;
    PL_retstack_max = REASONABLE(16);
d4535 1
a4548 1
    Safefree(PL_retstack);
a4550 10
STATIC void
S_init_lexer(pTHX)
{
    PerlIO *tmpfp;
    tmpfp = PL_rsfp;
    PL_rsfp = Nullfp;
    lex_start(PL_linestr);
    PL_rsfp = tmpfp;
    PL_subname = newSVpvn("main",4);
}
d4555 1
d4560 1
a4560 1
    PL_stdingv = gv_fetchpv("STDIN",TRUE, SVt_PVIO);
d4565 1
a4565 1
    tmpgv = gv_fetchpv("stdin",TRUE, SVt_PV);
d4567 1
a4567 1
    GvIOp(tmpgv) = (IO*)SvREFCNT_inc(io);
d4569 1
a4569 1
    tmpgv = gv_fetchpv("STDOUT",TRUE, SVt_PVIO);
d4575 1
a4575 1
    tmpgv = gv_fetchpv("stdout",TRUE, SVt_PV);
d4577 1
a4577 1
    GvIOp(tmpgv) = (IO*)SvREFCNT_inc(io);
d4579 1
a4579 1
    PL_stderrgv = gv_fetchpv("STDERR",TRUE, SVt_PVIO);
d4584 1
a4584 1
    tmpgv = gv_fetchpv("stderr",TRUE, SVt_PV);
d4586 1
a4586 1
    GvIOp(tmpgv) = (IO*)SvREFCNT_inc(io);
d4588 1
a4588 1
    PL_statname = NEWSV(66,0);		/* last filename we did stat on */
d4597 1
d4609 3
a4611 2
		*s++ = '\0';
		sv_setpv(GvSV(gv_fetchpv(argv[0]+1,TRUE, SVt_PV)),s);
d4614 1
a4614 1
		sv_setiv(GvSV(gv_fetchpv(argv[0]+1,TRUE, SVt_PV)),1);
d4617 1
a4617 1
    if ((PL_argvgv = gv_fetchpv("ARGV",TRUE, SVt_PVAV))) {
a4633 51
#ifdef HAS_PROCSELFEXE
/* This is a function so that we don't hold on to MAXPATHLEN
   bytes of stack longer than necessary
 */
STATIC void
S_procself_val(pTHX_ SV *sv, char *arg0)
{
    char buf[MAXPATHLEN];
    int len = readlink(PROCSELFEXE_PATH, buf, sizeof(buf) - 1);

    /* On Playstation2 Linux V1.0 (kernel 2.2.1) readlink(/proc/self/exe)
       includes a spurious NUL which will cause $^X to fail in system
       or backticks (this will prevent extensions from being built and
       many tests from working). readlink is not meant to add a NUL.
       Normal readlink works fine.
     */
    if (len > 0 && buf[len-1] == '\0') {
      len--;
    }

    /* FreeBSD's implementation is acknowledged to be imperfect, sometimes
       returning the text "unknown" from the readlink rather than the path
       to the executable (or returning an error from the readlink).  Any valid
       path has a '/' in it somewhere, so use that to validate the result.
       See http://www.freebsd.org/cgi/query-pr.cgi?pr=35703
    */
    if (len > 0 && memchr(buf, '/', len)) {
	sv_setpvn(sv,buf,len);
    }
    else {
	sv_setpv(sv,arg0);
    }
}
#endif /* HAS_PROCSELFEXE */

STATIC void
S_set_caret_X(pTHX) {
    GV* tmpgv = gv_fetchpv("\030",TRUE, SVt_PV); /* $^X */
    if (tmpgv) {
#ifdef HAS_PROCSELFEXE
	S_procself_val(aTHX_ GvSV(tmpgv), PL_origargv[0]);
#else
#ifdef OS2
	sv_setpv(GvSVn(tmpgv), os2_execname(aTHX));
#else
	sv_setpv(GvSVn(tmpgv),PL_origargv[0]);
#endif
#endif
    }
}

d4637 1
d4640 1
a4640 2
    PL_toptarget = NEWSV(0,0);
    sv_upgrade(PL_toptarget, SVt_PVFM);
d4642 1
a4642 2
    PL_bodytarget = NEWSV(0,0);
    sv_upgrade(PL_bodytarget, SVt_PVFM);
d4650 1
a4650 1
    if ((tmpgv = gv_fetchpv("0",TRUE, SVt_PV))) {
d4659 1
a4659 2
    S_set_caret_X(aTHX);
    if ((PL_envgv = gv_fetchpv("ENV",TRUE, SVt_PVHV))) {
d4661 1
d4664 1
a4664 1
	hv_magic(hv, Nullgv, PERL_MAGIC_env);
d4674 2
a4675 1
	if (env != environ
d4681 1
a4681 1
	    environ[0] = Nullch;
a4683 1
          char** origenv = environ;
d4696 1
a4696 1
	    if (env != environ)
a4697 5
	    if (origenv != environ) {
	      /* realloc has shifted us */
	      env = (env - origenv) + environ;
	      origenv = environ;
	    }
d4704 1
a4704 1
    if ((tmpgv = gv_fetchpv("$",TRUE, SVt_PV))) {
a4716 3
    /* touch @@- and @@+ arrays to prevent spurious warnings 20020415 MJD */
    (void) get_av("main::-", TRUE | GV_ADDMULTI);
    (void) get_av("main::+", TRUE | GV_ADDMULTI);
d4722 1
d4737 1
a4737 1
	    incpush(s, TRUE, TRUE, TRUE);
d4739 1
a4739 1
	    incpush(PerlEnv_getenv("PERLLIB"), FALSE, FALSE, TRUE);
d4748 1
a4748 1
	    do { incpush(buf,TRUE,TRUE,TRUE); } while (my_trnlnm("PERL5LIB",buf,++idx));
d4750 1
a4750 1
	    while (my_trnlnm("PERLLIB",buf,idx++)) incpush(buf,FALSE,FALSE,TRUE);
d4758 1
a4758 1
    incpush(APPLLIB_EXP, TRUE, TRUE, TRUE);
d4762 1
a4762 1
    incpush(ARCHLIB_EXP, FALSE, FALSE, TRUE);
d4767 1
a4767 1
    	SV * privdir = NEWSV(55, 0);
d4775 1
a4775 1
	    incpush(SvPVX(privdir), TRUE, FALSE, TRUE);
d4778 1
a4778 1
	    incpush(SvPVX(privdir), TRUE, FALSE, TRUE);
d4783 1
a4783 1
	incpush(":", FALSE, FALSE, TRUE);
d4789 1
a4789 1
    incpush(PRIVLIB_EXP, TRUE, FALSE, TRUE);
d4791 1
a4791 1
    incpush(PRIVLIB_EXP, FALSE, FALSE, TRUE);
d4798 1
a4798 1
    incpush(SITEARCH_EXP, FALSE, FALSE, TRUE);
d4805 1
a4805 1
    incpush(SITELIB_EXP, TRUE, FALSE, TRUE);
d4807 1
a4807 1
    incpush(SITELIB_EXP, FALSE, FALSE, TRUE);
d4811 3
a4813 2
#ifdef SITELIB_STEM /* Search for version-specific dirs below here */
    incpush(SITELIB_STEM, FALSE, TRUE, TRUE);
d4820 1
a4820 1
    incpush(PERL_VENDORARCH_EXP, FALSE, FALSE, TRUE);
d4826 1
a4826 1
    incpush(PERL_VENDORLIB_EXP, TRUE, FALSE, TRUE);	/* this picks up vendorarch as well */
d4828 1
a4828 1
    incpush(PERL_VENDORLIB_EXP, FALSE, FALSE, TRUE);
d4833 1
a4833 1
    incpush(PERL_VENDORLIB_STEM, FALSE, TRUE, TRUE);
d4837 1
a4837 1
    incpush(PERL_OTHERLIBDIRS, TRUE, TRUE, TRUE);
d4841 1
a4841 1
	incpush(".", FALSE, FALSE, TRUE);
d4845 1
a4845 1
#if defined(DOSISH) || defined(EPOC) || defined(SYMBIAN)
d4868 1
d4873 1
a4873 1
	dir = NEWSV(0,0);
d4879 2
a4880 1
S_incpush(pTHX_ const char *dir, bool addsubdirs, bool addoldvers, bool usesep)
d4882 2
a4883 1
    SV *subdir = Nullsv;
d4890 1
a4890 1
	subdir = NEWSV(0,0);
d4895 1
a4895 1
	SV *libdir = NEWSV(55,0);
d4902 1
a4902 1
		/* av_push(GvAVn(PL_incgv), newSVpvn(".", 1)); */
d4907 1
a4907 1
	if ( usesep && (s = strchr(p, PERLLIB_SEP)) != Nullch ) {
d4914 1
a4914 1
	    p = Nullch;	/* break out */
d4923 1
a4923 1
	    sv_catpv(libdir, ":");
d4926 98
d5031 2
a5032 2
	    const char *incverlist[] = { PERL_INC_VERSION_LIST };
	    const char **incver;
d5038 1
a5038 1
	    if ((unix = tounixspec_ts(SvPV(libdir,len),Nullch)) != Nullch) {
d5060 1
a5060 1
				libdir,
d5066 2
a5067 1
		Perl_sv_setpvf(aTHX_ subdir, "%"SVf PERL_ARCH_FMT_PATH, libdir,
d5073 2
a5074 1
		Perl_sv_setpvf(aTHX_ subdir, "%"SVf PERL_ARCH_FMT, libdir, ARCHNAME);
d5083 2
a5084 1
		    Perl_sv_setpvf(aTHX_ subdir, "%"SVf PERL_ARCH_FMT, libdir, *incver);
a5099 79
#ifdef USE_5005THREADS
STATIC struct perl_thread *
S_init_main_thread(pTHX)
{
#if !defined(PERL_IMPLICIT_CONTEXT)
    struct perl_thread *thr;
#endif
    XPV *xpv;

    Newxz(thr, 1, struct perl_thread);
    PL_curcop = &PL_compiling;
    thr->interp = PERL_GET_INTERP;
    thr->cvcache = newHV();
    thr->threadsv = newAV();
    /* thr->threadsvp is set when find_threadsv is called */
    thr->specific = newAV();
    thr->flags = THRf_R_JOINABLE;
    MUTEX_INIT(&thr->mutex);
    /* Handcraft thrsv similarly to mess_sv */
    Newx(PL_thrsv, 1, SV);
    Newxz(xpv, 1, XPV);
    SvFLAGS(PL_thrsv) = SVt_PV;
    SvANY(PL_thrsv) = (void*)xpv;
    SvREFCNT(PL_thrsv) = 1 << 30;	/* practically infinite */
    SvPV_set(PL_thrsv, (char*)thr);
    SvCUR_set(PL_thrsv, sizeof(thr));
    SvLEN_set(PL_thrsv, sizeof(thr));
    *SvEND(PL_thrsv) = '\0';	/* in the trailing_nul field */
    thr->oursv = PL_thrsv;
    PL_chopset = " \n-";
    PL_dumpindent = 4;

    MUTEX_LOCK(&PL_threads_mutex);
    PL_nthreads++;
    thr->tid = 0;
    thr->next = thr;
    thr->prev = thr;
    thr->thr_done = 0;
    MUTEX_UNLOCK(&PL_threads_mutex);

#ifdef HAVE_THREAD_INTERN
    Perl_init_thread_intern(thr);
#endif

#ifdef SET_THREAD_SELF
    SET_THREAD_SELF(thr);
#else
    thr->self = pthread_self();
#endif /* SET_THREAD_SELF */
    PERL_SET_THX(thr);

    /*
     * These must come after the thread self setting
     * because sv_setpvn does SvTAINT and the taint
     * fields thread selfness being set.
     */
    PL_toptarget = NEWSV(0,0);
    sv_upgrade(PL_toptarget, SVt_PVFM);
    sv_setpvn(PL_toptarget, "", 0);
    PL_bodytarget = NEWSV(0,0);
    sv_upgrade(PL_bodytarget, SVt_PVFM);
    sv_setpvn(PL_bodytarget, "", 0);
    PL_formtarget = PL_bodytarget;
    thr->errsv = newSVpvn("", 0);
    (void) find_threadsv("@@");	/* Ensure $@@ is initialised early */

    PL_maxscream = -1;
    PL_peepp = MEMBER_TO_FPTR(Perl_peep);
    PL_regcompp = MEMBER_TO_FPTR(Perl_pregcomp);
    PL_regexecp = MEMBER_TO_FPTR(Perl_regexec_flags);
    PL_regint_start = MEMBER_TO_FPTR(Perl_re_intuit_start);
    PL_regint_string = MEMBER_TO_FPTR(Perl_re_intuit_string);
    PL_regfree = MEMBER_TO_FPTR(Perl_pregfree);
    PL_regindent = 0;
    PL_reginterp_cnt = 0;

    return thr;
}
#endif /* USE_5005THREADS */
d5104 1
d5106 1
a5106 1
    const line_t oldline = CopLINE(PL_curcop);
d5117 1
a5117 3
		if (! PL_beginav_save)
		    PL_beginav_save = newAV();
		av_push(PL_beginav_save, (SV*)cv);
d5121 5
a5125 3
		if (! PL_checkav_save)
		    PL_checkav_save = newAV();
		av_push(PL_checkav_save, (SV*)cv);
d5128 2
a5129 1
	    SAVEFREESV(cv);
a5130 3
#ifdef PERL_FLEXIBLE_EXCEPTIONS
	CALLPROTECT(aTHX_ pcur_env, &ret, MEMBER_TO_FPTR(S_vcall_list_body), cv);
#else
a5131 1
#endif
d5134 8
a5141 2
#ifndef PERL_FLEXIBLE_EXCEPTIONS
	    call_list_body(cv);
d5149 1
a5149 1
		    sv_catpv(atsv, "BEGIN failed--compilation aborted");
d5155 1
d5160 1
a5160 1
		Perl_croak(aTHX_ "%"SVf"", atsv);
d5182 1
a5200 17
#ifdef PERL_FLEXIBLE_EXCEPTIONS
STATIC void *
S_vcall_list_body(pTHX_ va_list args)
{
    CV *cv = va_arg(args, CV*);
    return call_list_body(cv);
}
#endif

STATIC void *
S_call_list_body(pTHX_ CV *cv)
{
    PUSHMARK(PL_stack_sp);
    call_sv((SV*)cv, G_EVAL|G_DISCARD);
    return NULL;
}

d5204 1
d5206 1
a5206 1
			  thr, (unsigned long) status));
d5215 1
a5215 1
	STATUS_NATIVE_SET(status);
d5224 1
d5226 25
a5250 3
    if (vaxc$errno & 1) {
	if (STATUS_NATIVE & 1)		/* fortuitiously includes "-1" */
	    STATUS_NATIVE_SET(44);
d5253 25
a5277 4
	if (!vaxc$errno)		/* unlikely */
	    STATUS_NATIVE_SET(44);
	else
	    STATUS_NATIVE_SET(vaxc$errno);
d5279 1
d5283 1
a5283 1
	STATUS_POSIX_SET(errno);
d5285 1
a5285 1
	exitstatus = STATUS_POSIX >> 8;
d5287 1
a5287 1
	    STATUS_POSIX_SET(exitstatus);
d5289 1
a5289 1
	    STATUS_POSIX_SET(255);
d5298 1
a5298 3
    register PERL_CONTEXT *cx;
    I32 gimme;
    SV **newsp;
d5302 1
a5302 1
	PL_e_script = Nullsv;
d5306 2
a5307 6
    if (cxstack_ix >= 0) {
	if (cxstack_ix > 0)
	    dounwind(0);
	POPBLOCK(cx,PL_curpm);
	LEAVE;
    }
a5309 2
    PERL_UNUSED_VAR(gimme);
    PERL_UNUSED_VAR(newsp);
d5315 1
d5328 1
a5328 1
    sv_chop(PL_e_script, (char *) nl);
@


1.16
log
@This should set msg_control using CMSG_SIZE(), and not assume that
sizeof(buffer) is the right size (alignments can mess it up).  Code is
apparently not used, but it is better if all examples show the correct
idiom
ok hshoexer
@
text
@d454 1
a454 1
    msg.msg_controllen = CMSG_LEN(sizeof(int));
d719 1
a719 1
		msg.msg_controllen = CMSG_LEN(sizeof(int));
@


1.15
log
@merge in perl 5.8.8
@
text
@d454 1
a454 1
    msg.msg_controllen = sizeof(control.control);
d719 1
a719 1
		msg.msg_controllen = sizeof(control.control);
@


1.14
log
@get rid of an embedded compilation date in perl(1)

ok henning@@, millert@@
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, by Larry Wall and others
d95 15
d185 1
a185 1
    /* New() needs interpreter, so call malloc() instead */
d221 1
a221 1
    /* New() needs interpreter, so call malloc() instead */
d225 1
a225 1
    return ZeroD(my_perl, 1, PerlInterpreter);
d246 1
d351 1
a351 1
    PL_localpatches = local_patches;	/* For possible -v */
d398 5
a402 2
     * available or if the sysconf() fails, use the HZ. */
#if defined(HAS_SYSCONF) && defined(_SC_CLK_TCK)
d428 98
d539 3
d547 2
d626 3
a628 3
	char *s;
	if ((s = PerlEnv_getenv("PERL_DESTRUCT_LEVEL"))) {
	    int i = atoi(s);
d635 1
a635 2

    if(PL_exit_flags & PERL_EXIT_DESTRUCT_END) {
d640 1
d656 154
d813 5
a825 1
    PL_curcop = &PL_compiling;
d846 2
a918 1
            REGEXP *re = INT2PTR(REGEXP *,SvIVX(resv));
d929 2
a930 1
            else {
d1186 5
a1190 9
	I32 riter;
	I32 max;
	HE *hent;
	HE **array;

	riter = 0;
	max = HvMAX(PL_strtab);
	array = HvARRAY(PL_strtab);
	hent = array[0];
d1194 2
a1195 2
		     "Unbalanced string table refcount: (%d) for \"%s\"",
		     HeVAL(hent) - Nullsv, HeKEY(hent));
d1253 3
d1260 18
d1299 1
a1299 2
    if (PL_reg_curpm)
	Safefree(PL_reg_curpm);
d1348 2
d1351 8
a1358 10
	if (SvTYPE(PL_mess_sv) >= SVt_PVMG) {
	    MAGIC* mg;
	    MAGIC* moremagic;
	    for (mg = SvMAGIC(PL_mess_sv); mg; mg = moremagic) {
		moremagic = mg->mg_moremagic;
		if (mg->mg_ptr && mg->mg_type != PERL_MAGIC_regex_global
						&& mg->mg_len >= 0)
		    Safefree(mg->mg_ptr);
		Safefree(mg);
	    }
d1360 1
d1362 1
a1362 2
	SvOOK_off(PL_mess_sv);
	Safefree(SvPVX(PL_mess_sv));
d1402 21
d1450 2
d1469 1
a1469 4
	 char *s = PerlEnv_getenv("PERL_HASH_SEED_DEBUG");

	 if (s) {
	      int i = atoi(s);
d1471 2
a1472 4
	      if (i == 1)
		   PerlIO_printf(Perl_debug_log, "HASH_SEED = %"UVuf"\n",
				 PL_rehash_seed);
	 }
d1487 1
a1487 1
	 char *s = NULL;
d1489 1
a1489 1
	 UV mask =
d1492 1
a1492 1
	 UV aligned =
d1642 1
a1642 1
    char *scriptname = NULL;
d1644 1
a1644 1
    char *validarg = "";
d1647 4
a1650 1
    char *cddir = Nullch;
d1743 7
a1755 1
		char *p;
d1757 1
a1757 1
		p = savepvn(s, len);
d1778 11
a1788 5
	    if (!PL_preambleav)
		PL_preambleav = newAV();
	    av_push(PL_preambleav, newSVpv("use Config qw(myconfig config_vars)",0));
	    if (*++s != ':')  {
		PL_Sv = newSVpv("print myconfig();",0);
d1790 1
a1790 1
		sv_catpv(PL_Sv,"print \"\\nCharacteristics of this PERLSHR image: \\n\",");
d1792 1
a1792 1
		sv_catpv(PL_Sv,"print \"\\nCharacteristics of this binary (from libperl): \\n\",");
d1794 3
a1796 1
		sv_catpv(PL_Sv,"\"  Compile-time options:");
d1798 10
a1807 1
		sv_catpv(PL_Sv," DEBUGGING");
d1810 40
a1849 1
		sv_catpv(PL_Sv," MULTIPLICITY");
d1852 1
a1852 1
		sv_catpv(PL_Sv," USE_5005THREADS");
d1854 2
a1855 2
#  ifdef USE_ITHREADS
		sv_catpv(PL_Sv," USE_ITHREADS");
d1858 4
a1861 1
		sv_catpv(PL_Sv," USE_64_BIT_INT");
d1863 2
a1864 2
#  ifdef USE_64_BIT_ALL
		sv_catpv(PL_Sv," USE_64_BIT_ALL");
d1867 1
a1867 1
		sv_catpv(PL_Sv," USE_LONG_DOUBLE");
d1869 2
a1870 2
#  ifdef USE_LARGE_FILES
		sv_catpv(PL_Sv," USE_LARGE_FILES");
d1872 2
a1873 2
#  ifdef USE_SOCKS
		sv_catpv(PL_Sv," USE_SOCKS");
d1875 2
a1876 2
#  ifdef PERL_IMPLICIT_CONTEXT
		sv_catpv(PL_Sv," PERL_IMPLICIT_CONTEXT");
d1878 5
a1882 2
#  ifdef PERL_IMPLICIT_SYS
		sv_catpv(PL_Sv," PERL_IMPLICIT_SYS");
d1884 22
a1905 1
		sv_catpv(PL_Sv,"\\n\",");
d1908 9
a1916 7
		if (LOCAL_PATCH_COUNT > 0) {
		    int i;
		    sv_catpv(PL_Sv,"\"  Locally applied patches:\\n\",");
		    for (i = 1; i <= LOCAL_PATCH_COUNT; i++) {
			if (PL_localpatches[i])
			    Perl_sv_catpvf(aTHX_ PL_Sv,"q%c\t%s\n%c,",
				    0, PL_localpatches[i], 0);
a1917 1
		}
d1919 2
a1920 1
		Perl_sv_catpvf(aTHX_ PL_Sv,"\"  Built under %s\\n\"",OSNAME);
d1924 3
a1926 1
		Perl_sv_catpvf(aTHX_ PL_Sv,",\"  Compiled at %s %s\\n\"",__DATE__,__TIME__);
d1928 2
a1929 1
		Perl_sv_catpvf(aTHX_ PL_Sv,",\"  Compiled on %s\\n\"",__DATE__);
d1933 3
a1935 3
		sv_catpv(PL_Sv, "; \
$\"=\"\\n    \"; \
@@env = map { \"$_=\\\"$ENV{$_}\\\"\" } sort grep {/^PERL/} keys %ENV; ");
d1937 2
a1938 2
		sv_catpv(PL_Sv,"\
push @@env, \"CYGWIN=\\\"$ENV{CYGWIN}\\\"\";");
d1940 15
a1954 9
		sv_catpv(PL_Sv, "\
print \"  \\%ENV:\\n    @@env\\n\" if @@env; \
print \"  \\@@INC:\\n    @@INC\\n\";");
	    }
	    else {
		PL_Sv = newSVpv("config_vars(qw(",0);
		sv_catpv(PL_Sv, ++s);
		sv_catpv(PL_Sv, "))");
		s += strlen(s);
a1955 3
	    av_push(PL_preambleav, PL_Sv);
	    scriptname = BIT_BUCKET;	/* don't look for script or read stdin */
	    goto reswitch;
d1971 1
a1971 1
		s = "v";
d1975 1
a1975 1
		s = "h";
d1992 1
a1992 1
    	char *popt = s;
d2039 9
d2095 1
a2095 1
	if (cddir && PerlDir_chdir(cddir) < 0)
d2107 1
a2107 1
    New(666, CvMUTEXP(PL_compcv), 1, perl_mutex);
d2138 2
a2139 2
    /* PL_unicode is turned on by -C or by $ENV{PERL_UNICODE}.
     * PL_utf8locale is conditionally turned on by
d2142 3
d2265 2
d2328 1
a2328 1
STATIC void *
d2336 1
d2338 1
a2369 1

a2371 1
    return NULL;
d2441 1
a2441 1
    GV* gv = gv_fetchpv(name, create, SVt_PVHV);
d2619 1
a2619 1
	    I32 gimme = GIMME_V;
d2633 1
a2633 1
		sv_setpv(ERRSV,"");
d2652 1
a2652 1
		sv_setpv(ERRSV,"");
d2694 3
d2724 1
a2724 1
S_call_body(pTHX_ OP *myop, int is_eval)
a2754 1
    I32 oldscope;
a2768 1
    oldscope = PL_scopestack_ix;
d2799 1
a2799 1
	    sv_setpv(ERRSV,"");
d2862 1
a2862 2
	STRLEN n_a;
	Perl_croak(aTHX_ SvPVx(ERRSV, n_a));
d2888 2
a2889 5
    sv = sv_newmortal();
    sv_setpv(sv, "require '");
    sv_catpv(sv, pv);
    sv_catpv(sv, "'");
    eval_sv(sv, G_DISCARD);
d2904 1
a2904 1
S_usage(pTHX_ char *name)		/* XXX move this out into a module ? */
d2909 1
a2909 1
    static char *usage_msg[] = {
d2917 1
d2922 2
a2923 2
"-[mM][-]module  execute `use/no module...' before executing program",
"-n              assume 'while (<>) { ... }' loop around program",
d2941 1
a2941 1
    char **p = usage_msg;
d2963 1
a2963 1
    static char *usage_msgd[] = {
d2993 1
a2993 1
	static char debopts[] = "psltocPmfrxu HXDSTRJvC";
d2996 1
a2996 1
	    char *d = strchr(debopts,**s);
d3010 1
a3010 1
      char **p = usage_msgd;
a3026 1
    STRLEN numlen;
d3033 1
d3037 1
a3037 1
	      char *e;
d3040 2
a3041 1
	      for (s += 2, e = s; *e; e++);
d3104 1
a3104 1
	    char *start;
d3114 1
a3114 3
		sv_catpv(sv, " split(/,/,q{");
		sv_catpv(sv, ++s);
		sv_catpv(sv, "})");
d3117 1
a3117 1
	    my_setenv("PERL5DB", SvPV(sv, PL_na));
d3129 1
a3129 1
	PL_debug = get_debug_opts_flags(&s, 1) | DEBUG_TOP_FLAG;
a3135 1
	/*SUPPRESS 530*/
d3142 1
a3142 2
	if (PL_inplace)
	    Safefree(PL_inplace);
d3150 2
a3151 2
	/*SUPPRESS 530*/
	for (s = PL_inplace; *s && !isSPACE(*s); s++) ;
d3192 1
d3215 1
a3215 1
	    char *use = "use ";
d3217 4
a3220 2
	    if (*s == '-') { use = "no "; ++s; }
	    sv = newSVpv(use,0);
d3310 1
a3310 1
		      "\n\nCopyright 1987-2004, Larry Wall\n");
d3379 1
a3379 1
this system using `man perl' or `perldoc perl'.  If you have access to the\n\
d3471 1
a3471 1
#      define PERLVARIC(var,type,init)	PERL_GET_INTERP->var = init;
d3516 1
a3516 1
    HvNAME(PL_defstash) = savepv("main");
d3527 3
d3543 1
a3543 1
S_open_script(pTHX_ char *scriptname, bool dosearch, SV *sv)
d3546 4
a3549 4
    char *quote;
    char *code;
    char *cpp_discard_flag;
    char *perl;
d3560 1
a3560 1
	PL_origfilename = scriptname = find_script(scriptname, dosearch, NULL, 1);
d3563 1
a3563 1
	    char *s = scriptname + 8;
d3590 1
a3590 1
		PL_origfilename = scriptname;
d3597 2
a3598 2
    if (strEQ(PL_origfilename,"-"))
	scriptname = "";
d3625 1
a3625 1
	char *cpp_cfg = CPPSTDIN;
d3642 2
a3643 1
			      scriptname, SvPVX (cpp), SvPVX (sv), CPPMINUS));
d3684 1
a3684 1
                              SvPVX(cmd)));
d3686 1
a3686 1
	PL_rsfp = PerlProc_popen(SvPVX(cmd), "r");
d3705 5
a3709 2
	Perl_croak(aTHX_ "Can't open perl script \"%s\": %s\n",
		CopFILE(PL_curcop), Strerror(errno));
d3799 3
a3801 4
                        check_okay = 1;
                        on_nosuid = fsd.fd_req.flags & PERL_MOUNT_NOSUID;
                        on_noexec = fsd.fd_req.flags & PERL_MOUNT_NOEXEC;
                    }
d3848 1
a3848 1
S_validate_suid(pTHX_ char *validarg, char *scriptname)
d3882 1
a3882 1
    char *s, *s2;
d3888 1
a3888 1
	STRLEN n_a;
d3986 5
a3990 2
	if (sv_gets(PL_linestr, PL_rsfp, 0) == Nullch ||
	  strnNE(SvPV(PL_linestr,n_a),"#!",2) )	/* required even on Sys V */
d3992 2
a3993 1
	s = SvPV(PL_linestr,n_a)+2;
d4002 3
a4004 2
	for (s2 = s;  (s2 > SvPV(PL_linestr,n_a)+2 &&
		       (isDIGIT(s2[-1]) || strchr("._-", s2[-1])));  s2--) ;
d4006 2
a4007 2
	if ( (s2-4 < SvPV(PL_linestr,n_a)+2 || strnNE(s2-4,"perl",4)) &&
	      (s-9 < SvPV(PL_linestr,n_a)+2 || strnNE(s-9,"perl",4)) )
d4246 2
d4253 2
a4254 1
    register char *s, *s2;
d4294 2
a4295 1
		while (isDIGIT(s2[-1]) || strchr("-._", s2[-1])) s2--;
a4296 1
		    /*SUPPRESS 530*/
d4363 1
d4382 1
a4382 1
S_forbid_setid(pTHX_ char *s)
a4430 1
    sv_upgrade(GvSV(PL_DBsub), SVt_IV);	/* IVX accessed if PERLDB_SUB_NN */
d4460 1
a4460 1
    New(50,PL_tmps_stack,REASONABLE(128),SV*);
d4465 1
a4465 1
    New(54,PL_markstack,REASONABLE(32),I32);
d4471 1
a4471 1
    New(54,PL_scopestack,REASONABLE(32),I32);
d4475 1
a4475 1
    New(54,PL_savestack,REASONABLE(128),ANY);
d4553 1
a4553 2
    if (PL_osname)
    	Safefree(PL_osname);
a4559 1
    char *s;
d4563 1
d4583 1
a4583 1
	    SV *sv = newSVpv(argv[0],0);
d4631 16
a4648 2
    char *s;
    SV *sv;
d4672 1
a4672 11
    if ((tmpgv = gv_fetchpv("\030",TRUE, SVt_PV))) {/* $^X */
#ifdef HAS_PROCSELFEXE
	S_procself_val(aTHX_ GvSV(tmpgv), PL_origargv[0]);
#else
#ifdef OS2
	sv_setpv(GvSV(tmpgv), os2_execname(aTHX));
#else
	sv_setpv(GvSV(tmpgv),PL_origargv[0]);
#endif
#endif
    }
d4697 2
d4747 8
d4756 1
d4864 1
a4864 1
#if defined(DOSISH) || defined(EPOC)
d4881 15
d4897 1
a4897 1
S_incpush(pTHX_ char *p, int addsubdirs, int addoldvers, int usesep)
d4900 1
d4906 1
a4906 1
	subdir = sv_newmortal();
d4912 1
a4912 1
	char *s;
a4951 1
	    Stat_t tmpstatbuf;
d4981 1
a4981 3
		if (PerlLIO_stat(SvPVX(subdir), &tmpstatbuf) >= 0 &&
		      S_ISDIR(tmpstatbuf.st_mode))
		    av_push(GvAVn(PL_incgv), newSVsv(subdir));
d4987 1
a4987 3
		if (PerlLIO_stat(SvPVX(subdir), &tmpstatbuf) >= 0 &&
		      S_ISDIR(tmpstatbuf.st_mode))
		    av_push(GvAVn(PL_incgv), newSVsv(subdir));
d4991 2
a4992 3
		if (PerlLIO_stat(SvPVX(subdir), &tmpstatbuf) >= 0 &&
		      S_ISDIR(tmpstatbuf.st_mode))
		    av_push(GvAVn(PL_incgv), newSVsv(subdir));
d5000 1
a5000 3
		    if (PerlLIO_stat(SvPVX(subdir), &tmpstatbuf) >= 0 &&
			  S_ISDIR(tmpstatbuf.st_mode))
			av_push(GvAVn(PL_incgv), newSVsv(subdir));
d5009 4
d5024 1
a5024 1
    Newz(53, thr, 1, struct perl_thread);
d5034 2
a5035 2
    New(53, PL_thrsv, 1, SV);
    Newz(53, xpv, 1, XPV);
d5039 1
a5039 1
    SvPVX(PL_thrsv) = (char*)thr;
d5099 1
a5099 1
    line_t oldline = CopLINE(PL_curcop);
d5105 1
a5105 1
    while (AvFILL(paramList) >= 0) {
d5134 1
a5134 1
	    (void)SvPV(atsv, len);
d5275 2
d5282 6
a5287 3
    char *p, *nl;
    p  = SvPVX(PL_e_script);
    nl = strchr(p, '\n');
d5294 1
a5294 1
    sv_chop(PL_e_script, nl);
d5297 10
@


1.13
log
@sync in-tree perl with 5.8.6
@
text
@d1511 1
d1518 1
@


1.12
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d15 6
d210 1
a210 2
    Zero(my_perl, 1, PerlInterpreter);
    return my_perl;
d278 3
d286 1
d602 1
a602 1
    if (environ != PL_origenviron
d622 3
a764 3
    /* reset so print() ends up where we expect */
    setdefout(Nullgv);

d971 4
a974 3
		    PerlIO_printf(Perl_debug_log, "leaked: 0x%p"
                                  pTHX__FORMAT "\n",
                                  sv pTHX__VALUE);
d1063 1
a1063 1
	(void)SvOOK_off(PL_mess_sv);
d2352 4
d2527 6
d2536 1
a2536 1
      "  s  Stack snapshots. with v, displays all stacks",
d2546 1
a2546 1
      "  u  Tainting checks (Obsolete, previously used for LEAKTEST)",
d2557 1
a2557 1
      "  q  quiet - currently only suppressed the 'EXECUTING' message",
d2578 2
a2579 1
    else {
d2663 7
d2700 1
a2700 1
	PL_debug = get_debug_opts(&s) | DEBUG_TOP_FLAG;
d2817 1
a2817 1
	    Perl_croak(aTHX_ "No space allowed after -%c", *(s-1));
d2950 1
a2950 1
Internet, point your browser at http://www.perl.com/, the Perl Home Page.\n\n");
d3271 2
a3272 3
	Perl_croak(aTHX_ "Can't open perl script \"%s\": %s%s\n",
		CopFILE(PL_curcop), Strerror(errno),
		".\nUse -S to search $PATH for it.");
d4248 2
a4249 1
	if (env)
d4251 1
a4251 1
	    if (!(s = strchr(*env,'=')))
d4262 5
d4268 1
@


1.11
log
@merge local changes into perl-5.8.3
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, by Larry Wall and others
d15 59
d111 1
a111 1
#endif
d962 3
a964 1
		    PerlIO_printf(Perl_debug_log, "leaked: 0x%p\n", sv);
d1126 1
a1126 1
#endif
d1156 1
a1156 1
	 * contiguous with the argv[].  This is used in mg.c:mg_set()
a1316 1
    int fdscript = -1;
d1323 2
d1338 6
d1398 1
a1398 2
	    if (PL_euid != PL_uid || PL_egid != PL_gid)
		Perl_croak(aTHX_ "No -e allowed in setuid scripts");
d1495 2
a1496 1
			    Perl_sv_catpvf(aTHX_ PL_Sv,"q\"  \t%s\n\",",PL_localpatches[i]);
a1556 1
    sv_setsv(get_sv("/", TRUE), PL_rs);
d1631 1
a1631 1
    open_script(scriptname,dosearch,sv,&fdscript);
d1633 1
a1633 1
    validate_suid(validarg, scriptname,fdscript);
d2513 27
d2550 2
a2551 2
		Perl_warner(aTHX_ packWARN(WARN_DEBUGGING),
		    "invalid option -D%c\n", **s);
d2554 1
a2554 1
    else {
d2558 4
d2617 1
d2676 1
a2676 1
	           "Recompile perl with -DDEBUGGING to use -D switch\n");
d2852 1
a2852 1
		      "\n\nCopyright 1987-2003, Larry Wall\n");
d3080 1
d3082 1
a3082 1
S_open_script(pTHX_ char *scriptname, bool dosearch, SV *sv, int *fdscript)
d3084 1
d3089 1
d3091 2
a3092 1
    *fdscript = -1;
d3103 1
a3103 1
	    *fdscript = atoi(s);
d3107 20
d3138 2
a3139 2
    if (*fdscript >= 0) {
	PL_rsfp = PerlIO_fdopen(*fdscript,PERL_SCRIPT_MODE);
d3146 17
a3218 19
#       ifdef IAMSUID			/* actually, this is caught earlier */
	    if (PL_euid != PL_uid && !PL_euid) {  /* if running suidperl */
#               ifdef HAS_SETEUID
	            (void)seteuid(PL_uid);	  /* musn't stay setuid root */
#               else
#               ifdef HAS_SETREUID
	            (void)setreuid((Uid_t)-1, PL_uid);
#               else
#               ifdef HAS_SETRESUID
	            (void)setresuid((Uid_t)-1, PL_uid, (Uid_t)-1);
#               else
	            PerlProc_setuid(PL_uid);
#               endif
#               endif
#               endif
	    if (PerlProc_geteuid() != PL_uid)
		Perl_croak(aTHX_ "Can't do seteuid!\n");
	}
#       endif /* IAMSUID */
d3240 1
d3242 4
a3245 24
#       ifdef DOSUID
#       ifndef IAMSUID	/* in case script is not readable before setuid */
	    if (PL_euid &&
                PerlLIO_stat(CopFILE(PL_curcop),&PL_statbuf) >= 0 &&
                PL_statbuf.st_mode & (S_ISUID|S_ISGID))
            {
                /* try again */
                PERL_FPU_PRE_EXEC
                PerlProc_execv(Perl_form(aTHX_ "%s/sperl"PERL_FS_VER_FMT,
                                         BIN_EXP, (int)PERL_REVISION,
                                         (int)PERL_VERSION,
                                         (int)PERL_SUBVERSION), PL_origargv);
                PERL_FPU_POST_EXEC
                Perl_croak(aTHX_ "Can't do setuid\n");
            }
#       endif
#       endif
#       ifdef IAMSUID
            errno = EPERM;
            Perl_croak(aTHX_ "Permission denied\n");
#       else
            Perl_croak(aTHX_ "Can't open perl script \"%s\": %s\n",
                       CopFILE(PL_curcop), Strerror(errno));
#       endif
d3260 5
d3267 6
d3291 5
d3300 1
d3309 1
d3314 1
d3337 1
d3348 2
a3349 1
        defined(MNTOPT_NOSUID)
d3364 2
d3375 6
a3380 2
	Perl_croak(aTHX_ "Can't check filesystem of script \"%s\" for nosuid", PL_origfilename);
    return on_nosuid;
d3385 1
a3385 1
S_validate_suid(pTHX_ char *validarg, char *scriptname, int fdscript)
d3388 2
a3389 2
    int which;
#endif
d3405 7
d3423 1
a3423 1
    if (fdscript < 0 && PL_statbuf.st_mode & (S_ISUID|S_ISGID)) {
d3428 22
a3449 1
#ifndef HAS_SETREUID
d3457 2
d3461 1
a3461 2
            errno = EPERM;
	    Perl_croak(aTHX_ "Permission denied\n");
d3463 1
a3463 1
#else
d3468 20
d3491 2
a3492 22

	    if (
#ifdef HAS_SETREUID
		setreuid(PL_euid,PL_uid) < 0
#else
# if HAS_SETRESUID
		setresuid(PL_euid,PL_uid,(Uid_t)-1) < 0
# endif
#endif
		|| PerlProc_getuid() != PL_euid || PerlProc_geteuid() != PL_uid)
		Perl_croak(aTHX_ "Can't swap uid and euid");	/* really paranoid */
	    if (PerlLIO_stat(CopFILE(PL_curcop),&tmpstatbuf) < 0) {
		errno = EPERM;
		Perl_croak(aTHX_ "Permission denied\n");	/* testing full pathname here */
	    }
#if defined(IAMSUID) && !defined(NO_NOSUID_CHECK)
	    if (fd_on_nosuid_fs(PerlIO_fileno(PL_rsfp))) {
		errno = EPERM;
		Perl_croak(aTHX_ "Permission denied\n");
	    }
#endif
	    if (tmpstatbuf.st_dev != PL_statbuf.st_dev ||
d3494 1
a3494 3
		(void)PerlIO_close(PL_rsfp);
		errno = EPERM;
		Perl_croak(aTHX_ "Permission denied\n");
d3496 16
a3511 7
	    if (
#ifdef HAS_SETREUID
              setreuid(PL_uid,PL_euid) < 0
#else
# if defined(HAS_SETRESUID)
              setresuid(PL_uid,PL_euid,(Uid_t)-1) < 0
# endif
a3512 6
              || PerlProc_getuid() != PL_uid || PerlProc_geteuid() != PL_euid)
		Perl_croak(aTHX_ "Can't reswap uid and euid");
	    if (!cando(S_IXUSR,FALSE,&PL_statbuf))		/* can real uid exec? */
		Perl_croak(aTHX_ "Permission denied\n");
	}
#endif /* HAS_SETREUID */
d3516 1
a3516 2
            errno = EPERM;
	    Perl_croak(aTHX_ "Permission denied\n");
d3521 1
d3527 8
a3534 2
	if (*s == ' ') s++;
	while (!isSPACE(*s)) s++;
d3537 3
a3539 1
	if (strnNE(s2-4,"perl",4) && strnNE(s-9,"perl",4))  /* sanity check */
d3547 17
d3566 2
a3567 1
	    strnNE(s,validarg,len) || !isSPACE(s[len]))
d3571 2
a3572 1
	if (PL_euid != PL_uid && (PL_statbuf.st_mode & S_ISUID) &&
d3579 16
a3594 2
	if (PL_euid) {	/* oops, we're not the setuid root perl */
	    (void)PerlIO_close(PL_rsfp);
d3596 30
a3625 1
	    /* try again */
d3631 2
a3632 2
#endif
	    Perl_croak(aTHX_ "Can't do setuid\n");
d3636 6
d3695 1
a3695 1
	    Perl_croak(aTHX_ "Permission denied\n");	/* they can't do this */
d3698 1
a3698 1
    else if (PL_preprocess)
d3700 3
a3702 2
    else if (fdscript >= 0)
	Perl_croak(aTHX_ "fd script not allowed in suidperl\n");
d3704 2
a3705 2
	errno = EPERM;
	Perl_croak(aTHX_ "Permission denied\n");
d3711 30
d3743 10
a3752 7
    for (which = 1; PL_origargv[which] && PL_origargv[which] != scriptname; which++) ;
    if (!PL_origargv[which]) {
	errno = EPERM;
	Perl_croak(aTHX_ "Permission denied\n");
    }
    PL_origargv[which] = savepv(Perl_form(aTHX_ "/dev/fd/%d/%s",
				  PerlIO_fileno(PL_rsfp), PL_origargv[which]));
d3761 1
a3761 1
    Perl_croak(aTHX_ "Can't do setuid\n");
d3862 9
d3912 1
d3917 29
d4730 1
a4730 1
	if (!vaxc$errno && errno)	/* unlikely */
@


1.10
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@a923 3
    SvREFCNT(&PL_sv_placeholder) = 0;
    SvREADONLY_off(&PL_sv_placeholder);

@


1.9
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d3 2
a4 1
 *    Copyright (c) 1987-2002 Larry Wall
d30 12
d79 1
a173 1

d222 3
d258 3
a260 6
	SvNVX(PL_patchlevel) = (NV)PERL_REVISION
				+ ((NV)PERL_VERSION / (NV)1000)
#if defined(PERL_SUBVERSION) && PERL_SUBVERSION > 0
				+ ((NV)PERL_SUBVERSION / (NV)1000000)
#endif
				;
d307 2
a308 1
#ifdef  USE_ENVIRON_ARRAY
d310 1
d313 10
d470 4
a473 2
        /* If running under -d may not have PL_comppad. */
        PL_curpad = PL_comppad ? AvARRAY(PL_comppad) : NULL;
d497 1
d512 3
d532 1
d552 1
d587 3
d623 1
a623 4
    while (--PL_origargc >= 0) {
        Safefree(PL_origargv[PL_origargc]);
    }
    Safefree(PL_origargv);
d664 1
d670 1
d684 8
d726 1
d865 1
d893 19
d924 3
d928 1
d930 2
d935 1
a935 1
    Safefree(HeKEY_hek(&PL_hv_fetch_ent_mh));
d938 1
d940 1
d942 1
d944 4
d949 2
d952 1
d1071 8
a1078 1
    PL_origargc = argc;
d1080 9
a1088 11
        /* we copy rather than point to argv
         * since perl_clone will copy and perl_destruct
         * has no way of knowing if we've made a copy or
         * just point to argv
         */
        int i = PL_origargc;
        New(0, PL_origargv, i+1, char*);
        PL_origargv[i] = '\0';
        while (i-- > 0) {
            PL_origargv[i] = savepv(argv[i]);
        }
d1090 1
d1092 2
d1095 86
a1194 1
	PL_curpad = AvARRAY(PL_comppad);
a1261 1
    AV* comppadlist;
a1283 4
#ifdef	WIN32
	    win32_argv2utf8(argc-1, argv+1);
	    /* FALL THROUGH */
#endif
d1313 1
d1321 1
d1331 1
a1331 1
	    	break;
d1359 1
a1359 1
		incpush(p, TRUE, TRUE);
d1492 1
d1504 1
d1603 1
a1603 7
    PL_comppad = newAV();
    av_push(PL_comppad, Nullsv);
    PL_curpad = AvARRAY(PL_comppad);
    PL_comppad_name = newAV();
    PL_comppad_name_fill = 0;
    PL_min_intro_pending = 0;
    PL_padix = 0;
a1604 3
    av_store(PL_comppad_name, 0, newSVpvn("@@_", 2));
    PL_curpad[0] = (SV*)newAV();
    SvPADMY_on(PL_curpad[0]);	/* XXX Needed? */
a1609 6
    comppadlist = newAV();
    AvREAL_off(comppadlist);
    av_store(comppadlist, 0, (SV*)PL_comppad_name);
    av_store(comppadlist, 1, (SV*)PL_comppad);
    CvPADLIST(PL_compcv) = comppadlist;

a1611 1
#ifndef PERL_MICRO
a1612 1
#endif
d1637 2
a1638 1
    /* PL_wantutf8 is conditionally turned on by
d1641 35
a1675 15
    if (PL_wantutf8) { /* Requires init_predump_symbols(). */
	 IO* io;
	 PerlIO* fp;
	 SV* sv;
	 /* Turn on UTF-8-ness on STDIN, STDOUT, STDERR
	  *  _and_ the default open discipline. */
	 if (PL_stdingv  && (io = GvIO(PL_stdingv))  && (fp = IoIFP(io)))
	      PerlIO_binmode(aTHX_ fp, IoTYPE(io), 0, ":utf8");
	 if (PL_defoutgv && (io = GvIO(PL_defoutgv)) && (fp = IoOFP(io)))
	      PerlIO_binmode(aTHX_ fp, IoTYPE(io), 0, ":utf8");
	 if (PL_stderrgv && (io = GvIO(PL_stderrgv)) && (fp = IoOFP(io)))
	      PerlIO_binmode(aTHX_ fp, IoTYPE(io), 0, ":utf8");
	 if ((sv = GvSV(gv_fetchpv("\017PEN", TRUE, SVt_PV)))) {
	     sv_setpvn(sv, ":utf8\0:utf8", 11);
	     SvSETMAGIC(sv);
d1679 9
d1692 1
a1692 1
    SETERRNO(0,SS$_NORMAL);
a1720 6
/*
   Not sure that this is still the right place to do this now that we
   no longer use PL_nrs. HVDS 2001/09/09
*/
    sv_setsv(get_sv("/", TRUE), PL_rs);

d1830 1
a1830 1
	DEBUG(PerlIO_printf(Perl_debug_log, "\nEXECUTING...\n\n"));
d2367 1
a2367 1
implemented that way; consider using Perl_load_module instead.
d2405 1
a2405 1
"-C              enable native wide character system interfaces",
d2409 1
a2409 1
"-e 'command'    one line of program (several -e's allowed, omit programfile)",
d2420 1
a2421 1
"-t              enable tainting warnings",
d2428 1
a2429 1
"-x[directory]   strip off text before #!perl line and perhaps cd to directory",
d2442 34
d2482 1
a2482 1
    U32 rschar;
d2487 36
a2522 13
        I32 flags = 0;
	numlen = 4;
	rschar = (U32)grok_oct(s, &numlen, &flags, NULL);
	SvREFCNT_dec(PL_rs);
	if (rschar & ~((U8)~0))
	    PL_rs = &PL_sv_undef;
	else if (!rschar && numlen >= 2)
	    PL_rs = newSVpvn("", 0);
	else {
	    char ch = (char)rschar;
	    PL_rs = newSVpvn(&ch, 1);
	}
	return s + numlen;
d2525 2
a2526 2
	PL_widesyscalls = TRUE;
	s++;
d2561 1
a2561 1
		sv_catpv(sv,    "})");
d2575 2
a2576 18
	if (isALPHA(s[1])) {
	    /* if adding extra options, remember to update DEBUG_MASK */
	    static char debopts[] = "psltocPmfrxuLHXDSTRJ";
	    char *d;

	    for (s++; *s && (d = strchr(debopts,*s)); s++)
		PL_debug |= 1 << (d - debopts);
	}
	else {
	    PL_debug = atoi(s+1);
	    for (s++; isDIGIT(*s); s++) ;
	}
#ifdef EBCDIC
	if (DEBUG_p_TEST_ && ckWARN_d(WARN_DEBUGGING))
	    Perl_warner(aTHX_ packWARN(WARN_DEBUGGING),
		    "-Dp not implemented on this platform\n");
#endif
	PL_debug |= DEBUG_TOP_FLAG;
d2623 1
a2623 1
	    incpush(e, TRUE, TRUE);
d2682 2
a2683 1
		sv_catpv(sv, " split(/,/,q{");
d2685 1
a2685 1
		sv_catpv(sv,    "})");
d2710 1
a2710 1
            Perl_croak(aTHX_ "Too late for \"-t\" option");
d2715 1
a2715 1
	    Perl_croak(aTHX_ "Too late for \"-T\" option");
d2756 1
a2756 1
		      "\n\nCopyright 1987-2002, Larry Wall\n");
d2786 1
a2786 1
		      "MPE/iX port Copyright by Mark Klein and Mark Bixby, 1996-2002\n");
d2813 2
a2814 2
	printf("WINCE port by Rainer Keuchel, 2001-2002\n");
	printf("Built on " __DATE__ " " __TIME__ "\n\n");
d3031 2
d3130 1
d3135 1
d3142 1
a3142 2
            Perl_croak(aTHX_ "Can't open perl script: %s\n",
                       Strerror(errno));
d3304 4
a3307 2
	if (PerlLIO_access(CopFILE(PL_curcop),1)) /*double check*/
	    Perl_croak(aTHX_ "Permission denied");
d3327 4
a3330 2
	    if (PerlLIO_stat(CopFILE(PL_curcop),&tmpstatbuf) < 0)
		Perl_croak(aTHX_ "Permission denied");	/* testing full pathname here */
d3332 4
a3335 2
	    if (fd_on_nosuid_fs(PerlIO_fileno(PL_rsfp)))
		Perl_croak(aTHX_ "Permission denied");
d3340 1
d3359 4
a3362 2
	if (!S_ISREG(PL_statbuf.st_mode))
	    Perl_croak(aTHX_ "Permission denied");
d3393 1
a3393 1
FIX YOUR KERNEL, PUT A C WRAPPER AROUND THIS SCRIPT, OR USE -u AND UNDUMP!\n");
d3400 1
d3404 1
d3470 4
a3473 2
    else
	Perl_croak(aTHX_ "Script is not setuid/setgid in suidperl\n");
d3481 4
a3484 2
    if (!PL_origargv[which])
	Perl_croak(aTHX_ "Permission denied");
d3490 1
d3494 1
d3518 3
d3532 1
a3532 1
		
d3538 1
a3538 1
		
d3541 1
a3541 1
	
d3564 7
d3572 4
d3593 2
d3598 36
d3649 1
a3649 1
    PL_dbargs = GvAV(gv_AVadd((gv_fetchpv("args", GV_ADDMULTI, SVt_PVAV))));
d3651 3
a3653 3
    PL_DBgv = gv_fetchpv("DB", GV_ADDMULTI, SVt_PVGV);
    PL_DBline = gv_fetchpv("dbline", GV_ADDMULTI, SVt_PVAV);
    PL_DBsub = gv_HVadd(gv_fetchpv("sub", GV_ADDMULTI, SVt_PVHV));
d3655 1
a3655 1
    PL_DBsingle = GvSV((gv_fetchpv("single", GV_ADDMULTI, SVt_PV)));
d3657 1
a3657 1
    PL_DBtrace = GvSV((gv_fetchpv("trace", GV_ADDMULTI, SVt_PV)));
d3659 1
a3659 1
    PL_DBsignal = GvSV((gv_fetchpv("signal", GV_ADDMULTI, SVt_PV)));
d3810 6
a3815 2
	    if (PL_widesyscalls)
		(void)sv_utf8_decode(sv);
d3899 1
d3920 1
a3920 1
#if defined(MSDOS)
d3931 1
d3939 3
d3960 1
a3960 1
	    incpush(s, TRUE, TRUE);
d3962 1
a3962 1
	    incpush(PerlEnv_getenv("PERLLIB"), FALSE, FALSE);
d3971 1
a3971 1
	    do { incpush(buf,TRUE,TRUE); } while (my_trnlnm("PERL5LIB",buf,++idx));
d3973 1
a3973 1
	    while (my_trnlnm("PERLLIB",buf,idx++)) incpush(buf,FALSE,FALSE);
d3981 1
a3981 1
    incpush(APPLLIB_EXP, TRUE, TRUE);
d3985 1
a3985 1
    incpush(ARCHLIB_EXP, FALSE, FALSE);
d3998 1
a3998 1
	    incpush(SvPVX(privdir), TRUE, FALSE);
d4001 1
a4001 1
	    incpush(SvPVX(privdir), TRUE, FALSE);
d4006 1
a4006 1
	incpush(":", FALSE, FALSE);
d4012 1
a4012 1
    incpush(PRIVLIB_EXP, TRUE, FALSE);
d4014 1
a4014 1
    incpush(PRIVLIB_EXP, FALSE, FALSE);
d4021 1
a4021 1
    incpush(SITEARCH_EXP, FALSE, FALSE);
d4027 2
a4028 1
    incpush(SITELIB_EXP, TRUE, FALSE);	/* this picks up sitearch as well */
d4030 1
a4030 1
    incpush(SITELIB_EXP, FALSE, FALSE);
d4035 1
a4035 1
    incpush(SITELIB_STEM, FALSE, TRUE);
d4042 1
a4042 1
    incpush(PERL_VENDORARCH_EXP, FALSE, FALSE);
d4048 1
a4048 1
    incpush(PERL_VENDORLIB_EXP, TRUE, FALSE);	/* this picks up vendorarch as well */
d4050 1
a4050 1
    incpush(PERL_VENDORLIB_EXP, FALSE, FALSE);
d4055 1
a4055 1
    incpush(PERL_VENDORLIB_STEM, FALSE, TRUE);
d4059 1
a4059 1
    incpush(PERL_OTHERLIBDIRS, TRUE, TRUE);
d4063 1
a4063 1
	incpush(".", FALSE, FALSE);
d4085 1
a4085 1
S_incpush(pTHX_ char *p, int addsubdirs, int addoldvers)
d4102 6
a4107 4
	while ( *p == PERLLIB_SEP ) {
	    /* Uncomment the next line for PATH semantics */
	    /* av_push(GvAVn(PL_incgv), newSVpvn(".", 1)); */
	    p++;
d4110 1
a4110 1
	if ( (s = strchr(p, PERLLIB_SEP)) != Nullch ) {
d4298 2
a4299 1
	if (PL_savebegin && (paramList == PL_beginav)) {
d4301 10
a4310 3
	    if (! PL_beginav_save)
		PL_beginav_save = newAV();
	    av_push(PL_beginav_save, (SV*)cv);
a4326 1
		STRLEN n_a;
d4340 1
a4340 1
		Perl_croak(aTHX_ "%s", SvPVx(atsv, n_a));
@


1.8
log
@merge in perl 5.6.1 with our local changes
@
text
@d3 1
a3 1
 *    Copyright (c) 1987-2001 Larry Wall
d19 5
d29 1
a29 1
#if !defined(STANDARD_C) && !defined(HAS_GETENV_PROTOTYPE)
d33 1
a33 1
static I32 read_e_script(pTHXo_ int idx, SV *buf_sv, int maxlen);
d47 1
a47 9
#ifdef PERL_OBJECT
#define perl_construct	Perl_construct
#define perl_parse	Perl_parse
#define perl_run	Perl_run
#define perl_destruct	Perl_destruct
#define perl_free	Perl_free
#endif

#if defined(USE_THREADS)
a90 5
#ifdef PERL_OBJECT
    my_perl = (PerlInterpreter*)new(ipM) CPerlObj(ipM, ipMS, ipMP, ipE, ipStd,
						  ipLIO, ipD, ipS, ipP);
    INIT_TLS_AND_INTERP;
#else
a103 1
#endif
d110 2
d123 3
d147 1
a147 2
#ifdef USE_THREADS
    int i;
d151 1
a151 1
#endif /* USE_THREADS */
d155 1
a155 1
    PL_perl_destruct_level = 1; 
d163 1
a163 1
#ifdef USE_THREADS
d182 1
a182 1
#endif /* USE_THREADS */
a210 4
#ifdef PERL_OBJECT
	/* TODO: */
	/* PL_sighandlerp = sighandler; */
#else
a211 1
#endif
a212 10

#ifdef MSDOS
	/*
	 * There is no way we can refer to them from Perl so close them to save
	 * space.  The other alternative would be to provide STDAUX and STDPRN
	 * filehandles.
	 */
	(void)fclose(stdaux);
	(void)fclose(stdprn);
#endif
d215 1
a215 2
    PL_nrs = newSVpvn("\n", 1);
    PL_rs = SvREFCNT_inc(PL_nrs);
d235 4
a238 3
	s = uv_to_utf8(s, (UV)PERL_REVISION);
	s = uv_to_utf8(s, (UV)PERL_VERSION);
	s = uv_to_utf8(s, (UV)PERL_SUBVERSION);
d261 1
a261 1
    PerlIO_init();			/* Hook to IO system */
d266 31
d302 15
d324 1
a324 1
void
d327 1
a327 1
    int destruct_level;  /* 0=none, 1=full, 2=full with checks */
d329 1
a329 1
#ifdef USE_THREADS
d332 1
a332 1
#endif /* USE_THREADS */
d337 1
a337 1
#ifdef USE_THREADS
d371 1
a371 1
	    /* 
d406 1
a406 1
#endif /* USE_THREADS */
d420 10
d433 8
d445 2
a446 1
	PL_curpad = AvARRAY(PL_comppad);
d456 7
d480 1
a480 1
	PL_exitlist[PL_exitlistlen].fn(aTHXo_ PL_exitlist[PL_exitlistlen].ptr);
d487 6
a492 1
    
d494 1
a494 1
	return;
d498 11
a508 3

#ifdef USE_ENVIRON_ARRAY
    if (environ != PL_origenviron) {
d513 1
d521 33
d587 5
d594 2
a595 2
    Safefree(PL_ofs);		/* $, */
    PL_ofs = Nullch;
d597 2
a598 2
    Safefree(PL_ors);		/* $\ */
    PL_ors = Nullch;
a602 3
    SvREFCNT_dec(PL_nrs);	/* $/ helper */
    PL_nrs = Nullsv;

d628 1
d633 1
d701 1
d703 3
d723 3
d730 5
a734 9
#ifdef USE_ITHREADS
    Safefree(CopFILE(&PL_compiling));
    CopFILE(&PL_compiling) = Nullch;
    Safefree(CopSTASHPV(&PL_compiling));
#else
    SvREFCNT_dec(CopFILEGV(&PL_compiling));
    CopFILEGV(&PL_compiling) = Nullgv;
    /* cop_stash is not refcounted */
#endif
d751 1
a751 1
	    Perl_warner(aTHX_ WARN_INTERNAL,
d755 1
a755 1
	    Perl_warner(aTHX_ WARN_INTERNAL,
d759 1
a759 1
	    Perl_warner(aTHX_ WARN_INTERNAL,"Unbalanced tmps: %ld more allocs than frees\n",
d762 1
a762 1
	    Perl_warner(aTHX_ WARN_INTERNAL,"Unbalanced context: %ld more PUSHes than POPs\n",
d803 1
a803 1
		Perl_warner(aTHX_ WARN_INTERNAL,
d835 22
a859 3
    if (PL_sv_count != 0 && ckWARN_d(WARN_INTERNAL))
	Perl_warner(aTHX_ WARN_INTERNAL,"Scalars leaked: %ld\n", (long)PL_sv_count);

d870 1
d873 1
a873 1
    
d875 1
a875 1
#ifdef USE_THREADS
d891 5
a895 1
#endif /* USE_THREADS */
d908 2
a909 1
		if (mg->mg_ptr && mg->mg_type != 'g' && mg->mg_len >= 0)
d921 1
d935 5
a939 4
#if defined(PERL_OBJECT)
    PerlMem_free(this);
#else
#  if defined(PERL_IMPLICIT_SYS) && defined(WIN32)
d941 1
d943 3
d947 1
d951 2
d979 1
a979 1
#ifdef USE_THREADS
d991 15
a1005 4
#if defined(__DYNAMIC__) && (defined(NeXT) || defined(__NeXT__))
    _dyld_lookup_and_bind
	("__environ", (unsigned long *) &environ_pointer, NULL);
#endif /* environ */
a1006 5
    PL_origargv = argv;
    PL_origargc = argc;
#ifdef  USE_ENVIRON_ARRAY
    PL_origenviron = environ;
#endif
d1144 7
d1153 1
d1161 1
a1161 1
	    	break; 
d1226 2
a1227 2
#  ifdef USE_THREADS
		sv_catpv(PL_Sv," USE_THREADS");
a1246 3
#  ifdef PERL_OBJECT
		sv_catpv(PL_Sv," PERL_OBJECT");
#  endif
d1275 6
a1280 1
@@env = map { \"$_=\\\"$ENV{$_}\\\"\" } sort grep {/^PERL/} keys %ENV; \
d1329 1
d1332 1
a1332 1
	if (*s == '-' && *(s+1) == 'T')
d1334 2
d1337 1
d1350 1
a1350 1
		if (!strchr("DIMUdmw", *s))
d1354 5
d1363 8
a1370 1
		moreswitches(d);
d1375 4
d1399 1
d1408 1
a1408 1
		Perl_warner(aTHX_ WARN_SIGNAL,
d1414 1
d1438 1
a1438 1
#ifdef USE_THREADS
d1445 1
a1445 1
#endif /* USE_THREADS */
d1453 1
d1460 2
a1461 1
	(*xsinit)(aTHXo);	/* in case linked C routines want magical variables */
d1465 1
d1473 1
a1473 1
#endif    
d1482 21
d1536 4
a1539 3
    /* now that script is parsed, we can modify record separator */
    SvREFCNT_dec(PL_rs);
    PL_rs = SvREFCNT_inc(PL_nrs);
d1541 1
d1578 1
a1578 1
#ifdef USE_THREADS
d1583 3
d1608 2
a1609 1
	if (PL_endav && !PL_minus_c)
d1657 3
a1659 1
	    PerlIO_printf(Perl_error_log, "%s syntax OK\n", MacPerl_MPWFileName(PL_origfilename));
d1666 1
a1666 1
	    sv_setiv(PL_DBsingle, 1); 
d1690 2
d1705 1
a1705 1
#ifdef USE_THREADS
d1711 1
a1711 1
#endif /* USE_THREADS */
d1719 2
d1742 2
d1765 2
d1798 3
d1810 1
a1810 1
              
d1878 1
a1878 1
    I32 retval;
d1935 1
a1935 1
	    
d1938 1
a1938 1
	    
d1943 1
a1943 1
	    
d2060 1
a2060 1
       
d2065 2
a2066 2
    I32 oldmark = SP - PL_stack_base;
    I32 retval;
d2182 2
d2186 3
a2188 1
Tells Perl to C<require> a module.
d2190 1
a2190 2
=cut
*/
d2214 1
a2214 1
	sv_magic(GvSV(gv), (SV*)gv, 0, name, namlen);
d2221 1
a2221 1
     * Removed -h because the user already knows that opton. Others? */
d2242 1
d2274 4
a2277 3
	numlen = 0;			/* disallow underscores */
	rschar = (U32)scan_oct(s, 4, &numlen);
	SvREFCNT_dec(PL_nrs);
d2279 1
a2279 1
	    PL_nrs = &PL_sv_undef;
d2281 1
a2281 1
	    PL_nrs = newSVpvn("", 0);
d2283 2
a2284 2
	    char ch = rschar;
	    PL_nrs = newSVpvn(&ch, 1);
d2294 4
a2297 2
	PL_splitstr = savepv(s + 1);
	s += strlen(s);
d2340 2
a2341 1
	    static char debopts[] = "psltocPmfrxuLHXDST";
d2351 7
a2357 2
	PL_debug |= 0x80000000;
#else
d2359 1
a2359 1
	    Perl_warner(aTHX_ WARN_DEBUGGING,
d2367 2
a2368 2
	usage(PL_origargv[0]);    
	PerlProc_exit(0);
d2372 6
d2387 1
a2387 1
    case 'I':	/* -I handled both here and in parse_perl() */
d2415 4
a2418 2
	if (PL_ors)
	    Safefree(PL_ors);
d2420 4
a2423 4
	    PL_ors = savepv("\n");
	    PL_orslen = 1;
	    numlen = 0;			/* disallow underscores */
	    *PL_ors = (char)scan_oct(s, 3 + (*s == '0'), &numlen);
d2427 5
a2431 3
	    if (RsPARA(PL_nrs)) {
		PL_ors = "\n\n";
		PL_orslen = 2;
a2432 3
	    else
		PL_ors = SvPV(PL_nrs, PL_orslen);
	    PL_ors = savepvn(PL_ors, PL_orslen);
d2487 5
d2509 1
d2513 12
d2535 1
a2535 1
		      "\n\nCopyright 1987-2001, Larry Wall\n");
d2538 2
a2539 1
		      "\nMac OS port Copyright (c) 1991-2001, Matthias Neeracher\n");
d2553 1
a2553 1
		      "Version 5 port Copyright (c) 1994-1999, Andreas Kaiser, Ilya Zakharevich\n");
d2565 1
a2565 1
		      "MPE/iX port Copyright by Mark Klein and Mark Bixby, 1996-1999\n");
d2573 1
a2573 1
		      "Stratus VOS port by Paul_Green@@stratus.com, 1997-1999\n");
d2589 6
a2594 1
		      "EPOC port by Olaf Flebbe, 1999-2000\n");
d2606 1
a2606 1
	PerlProc_exit(0);
d2609 1
a2609 1
	    PL_dowarn |= G_WARN_ON; 
d2613 3
a2615 1
	PL_dowarn = G_WARN_ALL_ON|G_WARN_ON; 
d2620 3
a2622 1
	PL_dowarn = G_WARN_ALL_OFF; 
d2690 6
a2695 47
#ifdef PERL_OBJECT		/* XXX kludge */
#define I_REINIT \
  STMT_START {				\
    PL_chopset		= " \n-";	\
    PL_copline		= NOLINE;	\
    PL_curcop		= &PL_compiling;\
    PL_curcopdb		= NULL;		\
    PL_dbargs		= 0;		\
    PL_dumpindent	= 4;		\
    PL_laststatval	= -1;		\
    PL_laststype	= OP_STAT;	\
    PL_maxscream	= -1;		\
    PL_maxsysfd		= MAXSYSFD;	\
    PL_statname		= Nullsv;	\
    PL_tmps_floor	= -1;		\
    PL_tmps_ix		= -1;		\
    PL_op_mask		= NULL;		\
    PL_laststatval	= -1;		\
    PL_laststype	= OP_STAT;	\
    PL_mess_sv		= Nullsv;	\
    PL_splitstr		= " ";		\
    PL_generation	= 100;		\
    PL_exitlist		= NULL;		\
    PL_exitlistlen	= 0;		\
    PL_regindent	= 0;		\
    PL_in_clean_objs	= FALSE;	\
    PL_in_clean_all	= FALSE;	\
    PL_profiledata	= NULL;		\
    PL_rsfp		= Nullfp;	\
    PL_rsfp_filters	= Nullav;	\
    PL_dirty		= FALSE;	\
  } STMT_END
    I_REINIT;
#else
#  ifdef MULTIPLICITY
#    define PERLVAR(var,type)
#    define PERLVARA(var,n,type)
#    if defined(PERL_IMPLICIT_CONTEXT)
#      if defined(USE_THREADS)
#        define PERLVARI(var,type,init)		PERL_GET_INTERP->var = init;
#        define PERLVARIC(var,type,init)	PERL_GET_INTERP->var = init;
#      else /* !USE_THREADS */
#        define PERLVARI(var,type,init)		aTHX->var = init;
#        define PERLVARIC(var,type,init)	aTHX->var = init;
#      endif /* USE_THREADS */
#    else
#      define PERLVARI(var,type,init)	PERL_GET_INTERP->var = init;
d2697 4
a2700 9
#    endif
#    include "intrpvar.h"
#    ifndef USE_THREADS
#      include "thrdvar.h"
#    endif
#    undef PERLVAR
#    undef PERLVARA
#    undef PERLVARI
#    undef PERLVARIC
d2702 19
a2720 12
#    define PERLVAR(var,type)
#    define PERLVARA(var,n,type)
#    define PERLVARI(var,type,init)	PL_##var = init;
#    define PERLVARIC(var,type,init)	PL_##var = init;
#    include "intrpvar.h"
#    ifndef USE_THREADS
#      include "thrdvar.h"
#    endif
#    undef PERLVAR
#    undef PERLVARA
#    undef PERLVARI
#    undef PERLVARIC
d2722 4
a2734 10
    /* Note that strtab is a rather special HV.  Assumptions are made
       about not iterating on it, and not adding tie magic to it.
       It is properly deallocated in perl_destruct() */
    PL_strtab = newHV();
#ifdef USE_THREADS
    MUTEX_INIT(&PL_strtab_mutex);
#endif
    HvSHAREKEYS_off(PL_strtab);			/* mandatory */
    hv_ksplit(PL_strtab, 512);
    
d2766 5
d2793 1
a2793 5
#ifdef USE_ITHREADS
    Safefree(CopFILE(PL_curcop));
#else
    SvREFCNT_dec(CopFILEGV(PL_curcop));
#endif
d2799 5
a2803 4
#if defined(HAS_FCNTL) && defined(F_SETFD)
	if (PL_rsfp)
	    fcntl(PerlIO_fileno(PL_rsfp),F_SETFD,1);  /* ensure close-on-exec */
#endif
d2814 43
a2856 2
	sv_catpvn(sv, "-I", 2);
	sv_catpv(sv,PRIVLIB_EXP);
a2857 53
#if defined(MSDOS) || defined(WIN32)
	Perl_sv_setpvf(aTHX_ cmd, "\
sed %s -e \"/^[^#]/b\" \
 -e \"/^#[ 	]*include[ 	]/b\" \
 -e \"/^#[ 	]*define[ 	]/b\" \
 -e \"/^#[ 	]*if[ 	]/b\" \
 -e \"/^#[ 	]*ifdef[ 	]/b\" \
 -e \"/^#[ 	]*ifndef[ 	]/b\" \
 -e \"/^#[ 	]*else/b\" \
 -e \"/^#[ 	]*elif[ 	]/b\" \
 -e \"/^#[ 	]*undef[ 	]/b\" \
 -e \"/^#[ 	]*endif/b\" \
 -e \"s/^#.*//\" \
 %s | %"SVf" -C %"SVf" %s",
	  (PL_doextract ? "-e \"1,/^#/d\n\"" : ""),
#else
#  ifdef __OPEN_VM
	Perl_sv_setpvf(aTHX_ cmd, "\
%s %s -e '/^[^#]/b' \
 -e '/^#[ 	]*include[ 	]/b' \
 -e '/^#[ 	]*define[ 	]/b' \
 -e '/^#[ 	]*if[ 	]/b' \
 -e '/^#[ 	]*ifdef[ 	]/b' \
 -e '/^#[ 	]*ifndef[ 	]/b' \
 -e '/^#[ 	]*else/b' \
 -e '/^#[ 	]*elif[ 	]/b' \
 -e '/^#[ 	]*undef[ 	]/b' \
 -e '/^#[ 	]*endif/b' \
 -e 's/^[ 	]*#.*//' \
 %s | %"SVf" %"SVf" %s",
#  else
	Perl_sv_setpvf(aTHX_ cmd, "\
%s %s -e '/^[^#]/b' \
 -e '/^#[ 	]*include[ 	]/b' \
 -e '/^#[ 	]*define[ 	]/b' \
 -e '/^#[ 	]*if[ 	]/b' \
 -e '/^#[ 	]*ifdef[ 	]/b' \
 -e '/^#[ 	]*ifndef[ 	]/b' \
 -e '/^#[ 	]*else/b' \
 -e '/^#[ 	]*elif[ 	]/b' \
 -e '/^#[ 	]*undef[ 	]/b' \
 -e '/^#[ 	]*endif/b' \
 -e 's/^[ 	]*#.*//' \
 %s | %"SVf" -C %"SVf" %s",
#  endif
#ifdef LOC_SED
	  LOC_SED,
#else
	  "sed",
#endif
	  (PL_doextract ? "-e '1,/^#/d\n'" : ""),
#endif
	  scriptname, cpp, sv, CPPMINUS);
d2859 15
a2873 15
#ifdef IAMSUID				/* actually, this is caught earlier */
	if (PL_euid != PL_uid && !PL_euid) {	/* if running suidperl */
#ifdef HAS_SETEUID
	    (void)seteuid(PL_uid);		/* musn't stay setuid root */
#else
#ifdef HAS_SETREUID
	    (void)setreuid((Uid_t)-1, PL_uid);
#else
#ifdef HAS_SETRESUID
	    (void)setresuid((Uid_t)-1, PL_uid, (Uid_t)-1);
#else
	    PerlProc_setuid(PL_uid);
#endif
#endif
#endif
d2877 6
a2882 1
#endif /* IAMSUID */
d2893 5
a2897 4
#if defined(HAS_FCNTL) && defined(F_SETFD)
	if (PL_rsfp)
	    fcntl(PerlIO_fileno(PL_rsfp),F_SETFD,1);  /* ensure close-on-exec */
#endif
d2900 23
a2922 16
#ifdef DOSUID
#ifndef IAMSUID		/* in case script is not readable before setuid */
	if (PL_euid &&
	    PerlLIO_stat(CopFILE(PL_curcop),&PL_statbuf) >= 0 &&
	    PL_statbuf.st_mode & (S_ISUID|S_ISGID))
	{
	    /* try again */
	    PerlProc_execv(Perl_form(aTHX_ "%s/sperl"PERL_FS_VER_FMT, BIN_EXP,
				     (int)PERL_REVISION, (int)PERL_VERSION,
				     (int)PERL_SUBVERSION), PL_origargv);
	    Perl_croak(aTHX_ "Can't do setuid\n");
	}
#endif
#endif
	Perl_croak(aTHX_ "Can't open perl script \"%s\": %s\n",
		   CopFILE(PL_curcop), Strerror(errno));
d2958 1
a2958 1
 
d2979 1
a2979 1
    struct stat fdst;
d3009 1
a3009 1
    struct stat         stb, fsb;
d3028 1
a3028 1
    if (!check_okay) 
d3089 1
a3089 1
	    struct stat tmpstatbuf;
d3283 1
d3297 1
a3297 1
	    
d3305 2
a3306 1
	if (*s == '#' && s[1] == '!' && (s = instr(s,"perl"))) {
d3319 3
d3363 1
a3363 1
    sv_setiv(PL_DBsingle, 0); 
d3365 1
a3365 1
    sv_setiv(PL_DBtrace, 0); 
d3367 1
a3367 1
    sv_setiv(PL_DBsignal, 0); 
a3435 4
#ifndef PERL_OBJECT
static PerlIO *tmpfp;  /* moved outside init_lexer() because of UNICOS bug */
#endif

d3439 1
a3439 3
#ifdef PERL_OBJECT
	PerlIO *tmpfp;
#endif
d3457 1
d3466 1
d3476 1
d3489 2
a3490 2
STATIC void
S_init_postdump_symbols(pTHX_ register int argc, register char **argv, register char **env)
a3492 5
    SV *sv;
    GV* tmpgv;
    char **dup_env_base = 0;
    int dup_env_count = 0;

d3510 55
d3574 3
d3586 4
a3589 1
    if ((tmpgv = gv_fetchpv("\030",TRUE, SVt_PV)))
d3595 1
a3595 10
    if ((PL_argvgv = gv_fetchpv("ARGV",TRUE, SVt_PVAV))) {
	GvMULTI_on(PL_argvgv);
	(void)gv_AVadd(PL_argvgv);
	av_clear(GvAVn(PL_argvgv));
	for (; argc > 0; argc--,argv++) {
	    SV *sv = newSVpv(argv[0],0);
	    av_push(GvAVn(PL_argvgv),sv);
	    if (PL_widesyscalls)
		(void)sv_utf8_decode(sv);
	}
d3601 1
a3601 1
	hv_magic(hv, Nullgv, 'E');
d3610 6
a3615 1
	if (env != environ)
a3616 18
#ifdef NEED_ENVIRON_DUP_FOR_MODIFY
	{
	    char **env_base;
	    for (env_base = env; *env; env++) 
		dup_env_count++;
	    if ((dup_env_base = (char **)
		 safesysmalloc( sizeof(char *) * (dup_env_count+1) ))) {
		char **dup_env;
		for (env = env_base, dup_env = dup_env_base;
		     *env;
		     env++, dup_env++) {
		    /* With environ one needs to use safesysmalloc(). */
		    *dup_env = safesysmalloc(strlen(*env) + 1);
		    (void)strcpy(*dup_env, *env);
		}
		*dup_env = Nullch;
		env = dup_env_base;
	    } /* else what? */
d3618 2
a3619 2
#endif /* NEED_ENVIRON_DUP_FOR_MODIFY */
	for (; *env; env++) {
a3621 1
	    *s++ = '\0';
d3623 1
d3625 1
d3627 1
a3627 1
	    sv = newSVpv(s--,0);
d3629 3
a3631 10
	    *s = '=';
	}
#ifdef NEED_ENVIRON_DUP_FOR_MODIFY
	if (dup_env_base) {
	    char **dup_env;
	    for (dup_env = dup_env_base; *dup_env; dup_env++)
		safesysfree(*dup_env);
	    safesysfree(dup_env_base);
	}
#endif /* NEED_ENVIRON_DUP_FOR_MODIFY */
a3632 3
#ifdef DYNAMIC_ENV_FETCH
	HvNAME(hv) = savepv(ENV_HV_NAME);
#endif
d3635 2
a3636 1
    if ((tmpgv = gv_fetchpv("$",TRUE, SVt_PV)))
d3638 10
d3687 1
a3687 1
	struct stat tmpstatbuf;
d3700 1
a3700 1
	    
d3709 1
a3709 1
#if defined(WIN32) 
d3779 1
a3779 1
#endif 
d3815 5
a3819 2
	if (!strchr(SvPVX(libdir), ':'))
	    sv_insert(libdir, 0, 0, ":", 1);
d3834 1
a3834 1
	    struct stat tmpstatbuf;
d3901 1
a3901 1
#ifdef USE_THREADS
d3938 1
d3968 1
d3979 1
a3979 1
#endif /* USE_THREADS */
d3993 1
a3993 1
	if ((PL_minus_c & 0x10) && (paramList == PL_beginav)) {
d4123 1
a4123 1
	exitstatus = STATUS_POSIX >> 8; 
a4155 4
#ifdef PERL_OBJECT
#include "XSUB.h"
#endif

d4157 1
a4157 1
read_e_script(pTHXo_ int idx, SV *buf_sv, int maxlen)
@


1.7
log
@The official perl fix deletes the /bin/mail code entirely.
@
text
@d3 1
a3 1
 *    Copyright (c) 1987-2000 Larry Wall
d183 2
d277 4
d285 1
a300 1
    dTHR;
a301 1
    I32 last_sv_count;
d378 1
d440 15
d579 1
d620 5
a624 1
#ifndef USE_ITHREADS
d626 2
a627 1
    CopFILEGV_set(&PL_compiling, Nullgv);
a660 1
    last_sv_count = 0;
d663 5
a667 4
    while (PL_sv_count != 0 && PL_sv_count != last_sv_count) {
	last_sv_count = PL_sv_count;
	sv_clean_all();
    }
d677 4
d712 5
a734 3
    sv_free_arenas();

    /* No SVs have survived, need to clean out */
d742 3
d754 1
d767 2
a835 1
    dTHR;
d858 1
a858 1
#ifndef VMS  /* VMS doesn't have environ array */
a936 1
    dTHR;
d1004 5
d1179 1
d1187 1
d1192 7
a1198 1
		s = moreswitches(s);
d1238 3
d1242 1
d1282 1
a1282 1
#if defined(VMS) || defined(WIN32) || defined(DJGPP) || defined(__CYGWIN__)
d1287 3
d1291 1
d1307 10
d1325 1
a1370 1
    dTHR;
a1437 2
    dTHR;

d1448 3
d1452 1
d1496 1
a1496 2
    	if (tmp != NOT_IN_PAD) {
	    dTHR;
a1497 1
	}
d1636 1
a1636 12
    dSP;
    OP myop;
    if (!PL_op) {
	Zero(&myop, 1, OP);
	PL_op = &myop;
    }
    XPUSHs(sv_2mortal(newSVpv(methname,0)));
    PUTBACK;
    pp_method();
    if (PL_op == &myop)
	PL_op = Nullop;
    return call_sv(*PL_stack_sp--, flags);
a1650 1
       
d1655 1
d1693 8
d1708 1
a1708 1
	cLOGOP->op_other = PL_op;
d1718 1
a1718 1
	    push_return(PL_op->op_next);
a1816 2
    dTHR;

d1819 1
a1819 1
	    PL_op = Perl_pp_entereval(aTHX);
d1821 1
a1821 1
	    PL_op = Perl_pp_entersub(aTHX);
a1942 1
    PUSHMARK(SP);
d2003 1
a2003 1
"-c              check syntax only (runs BEGIN and END blocks)",
d2031 3
a2033 1
    printf("\nUsage: %s [switches] [--] [programfile] [arguments]", name);
d2035 1
a2035 1
	printf("\n  %s", *p++);
d2043 1
a2043 1
    I32 numlen;
d2049 1
a2049 1
	dTHR;
d2082 17
a2098 2
	if (*s == ':' || *s == '=')  {
	    my_setenv("PERL5DB", Perl_form(aTHX_ "use Devel::%s;", ++s));
d2100 1
d2112 1
a2112 1
	    static char debopts[] = "psltocPmfrxuLHXDS";
a2123 1
	dTHR;
d2180 1
a2184 1
	    dTHR;
d2217 3
d2252 3
d2263 3
a2265 2
	printf(Perl_form(aTHX_ "\nThis is perl, v%vd built for %s",
			 PL_patchlevel, ARCHNAME));
d2268 5
a2272 2
	    printf("\n(with %d registered patch%s, see perl -V for more detail)",
		(int)LOCAL_PATCH_COUNT, (LOCAL_PATCH_COUNT!=1) ? "es" : "");
d2275 6
a2280 1
	printf("\n\nCopyright 1987-2000, Larry Wall\n");
d2282 2
a2283 1
	printf("\nMS-DOS port Copyright (c) 1989, 1990, Diomidis Spinellis\n");
d2286 3
a2288 2
	printf("djgpp v2 port (jpl5003c) by Hirofumi Watanabe, 1996\n");
	printf("djgpp v2 port (perl5004+) by Laszlo Molnar, 1997-1999\n");
d2291 3
a2293 2
	printf("\n\nOS/2 port Copyright (c) 1990, 1991, Raymond Chen, Kai Uwe Rommel\n"
	    "Version 5 port Copyright (c) 1994-1999, Andreas Kaiser, Ilya Zakharevich\n");
d2296 2
a2297 1
	printf("atariST series port, ++jrb  bammi@@cadence.com\n");
d2300 2
a2301 1
	printf("BeOS port Copyright Tom Spindler, 1997-1999\n");
d2304 2
a2305 1
	printf("MPE/iX port Copyright by Mark Klein and Mark Bixby, 1996-1999\n");
d2308 2
a2309 1
	printf("MVS (OS390) port by Mortice Kern Systems, 1997-1999\n");
d2312 2
a2313 1
	printf("Stratus VOS port by Paul_Green@@stratus.com, 1997-1999\n");
d2316 2
a2317 1
	printf("VM/ESA port by Neale Ferguson, 1998-1999\n");
d2320 2
a2321 1
	printf("BS2000 (POSIX) port by Start Amadeus GmbH, 1998-1999\n");
d2324 2
a2325 1
	printf("MiNT port by Guido Flohr, 1997-1999\n");
d2328 2
a2329 1
	printf("EPOC port by Olaf Flebbe, 1999-2000\n");
d2334 2
a2335 1
	printf("\n\
d2337 1
a2337 1
GNU General Public License, which may be found in the Perl 5.0 source kit.\n\n\
a2498 1
    dTHR;
d2534 1
a2541 2
    dTHR;

d2564 5
d2591 1
a2591 1
#ifdef MSDOS
d2721 5
a2725 1
#   ifdef HAS_FSTATVFS
d2727 1
d2730 8
a2737 5
#   else
#       ifdef PERL_MOUNT_NOSUID
#           if defined(HAS_FSTATFS) && \
	       defined(HAS_STRUCT_STATFS) && \
	       defined(HAS_STRUCT_STATFS_F_FLAGS)
d2739 1
d2742 10
a2751 6
#           else
#               if defined(HAS_FSTAT) && \
		   defined(HAS_USTAT) && \
		   defined(HAS_GETMNT) && \
		   defined(HAS_STRUCT_FS_DATA) && \
		   defined(NOSTAT_ONE)
d2753 1
d2755 5
a2759 5
	struct ustat us;
	if (ustat(fdst.st_dev, &us) == 0) {
	    struct fs_data fsd;
	    /* NOSTAT_ONE here because we're not examining fields which
	     * vary between that case and STAT_ONE. */
d2761 22
a2782 21
		size_t cmplen = sizeof(us.f_fname);
		if (sizeof(fsd.fd_req.path) < cmplen)
		    cmplen = sizeof(fsd.fd_req.path);
		if (strnEQ(fsd.fd_req.path, us.f_fname, cmplen) &&
		    fdst.st_dev == fsd.fd_req.dev) {
			check_okay = 1;
			on_nosuid = fsd.fd_req.flags & PERL_MOUNT_NOSUID;
		    }
		}
	    }
	}
    }
#               endif /* fstat+ustat+getmnt */
#           endif /* fstatfs */
#       else
#           if defined(HAS_GETMNTENT) && \
	       defined(HAS_HASMNTOPT) && \
	       defined(MNTOPT_NOSUID)
    FILE		*mtab = fopen("/etc/mtab", "r");
    struct mntent	*entry;
    struct stat		stb, fsb;
d2785 11
a2795 11
	while (entry = getmntent(mtab)) {
	    if (stat(entry->mnt_dir, &fsb) == 0
		&& fsb.st_dev == stb.st_dev)
	    {
		/* found the filesystem */
		check_okay = 1;
		if (hasmntopt(entry, MNTOPT_NOSUID))
		    on_nosuid = 1;
		break;
	    } /* A single fs may well fail its stat(). */
	}
d2798 2
a2799 4
	fclose(mtab);
#           endif /* getmntent+hasmntopt */
#       endif /* PERL_MOUNT_NOSUID: fstatfs or fstat+ustat+statfs */
#   endif /* statvfs */
a2834 1
    dTHR;
a3031 1
	dTHR;
d3054 19
d3076 1
a3120 1
    dTHR;
a3187 1
    dTHR;
a3223 1
    dTHR;
d3255 3
a3257 2
    if (!PL_osname)
	PL_osname = savepv(OSNAME);
a3262 1
    dTHR;
d3266 2
d3296 4
d3302 1
d3306 1
a3306 1
	sv_setpv(GvSV(tmpgv), os2_execname());
d3318 1
a3318 1
		sv_utf8_upgrade(sv);
d3325 2
a3326 2
	hv_magic(hv, PL_envgv, 'E');
#if !defined( VMS) && !defined(EPOC)  /* VMS doesn't have environ array */
d3336 20
a3365 4
#if defined(__BORLANDC__) && defined(USE_WIN32_RTL_ENV)
	    /* Sins of the RTL. See note in my_setenv(). */
	    (void)PerlEnv_putenv(savepv(*env));
#endif
d3367 9
a3375 1
#endif
d3420 21
d3490 4
d3496 1
d3499 1
a3499 1
#if defined(DOSISH)
d3505 5
a3509 1
#    define PERLLIB_SEP ':'
d3549 6
d3582 9
d3592 1
a3592 1
		Perl_sv_setpvf(aTHX_ subdir, "%"SVf"/"PERL_FS_VER_FMT"/%s", 
d3601 1
a3601 1
		Perl_sv_setpvf(aTHX_ subdir, "%"SVf"/"PERL_FS_VER_FMT, libdir,
d3609 1
a3609 1
		Perl_sv_setpvf(aTHX_ subdir, "%"SVf"/%s", libdir, ARCHNAME);
d3619 1
a3619 1
		    Perl_sv_setpvf(aTHX_ subdir, "%"SVf"/%s", libdir, *incver);
d3684 3
a3686 2
     * These must come after the SET_THR because sv_setpvn does
     * SvTAINT and the taint fields require dTHR.
a3713 1
    dTHR;
d3723 8
a3730 1
	SAVEFREESV(cv);
a3817 2
    dTHR;

a3865 1
    dTHR;
@


1.6
log
@#ifdef out code that runs /bin/mail insecurely.  We don't have a /bin/mail
so this bug doesn't bite us but...
@
text
@a2760 12
#ifdef DISGUSTINGLY_INSECURE
		if (PL_rsfp = PerlProc_popen("/bin/mail root","w")) {	/* heh, heh */
		    PerlIO_printf(PL_rsfp,
"User %"Uid_t_f" tried to run dev %ld ino %ld in place of dev %ld ino %ld!\n\
(Filename of set-id script was %s, uid %"Uid_t_f" gid %"Gid_t_f".)\n\nSincerely,\nperl\n",
			PL_uid,(long)tmpstatbuf.st_dev, (long)tmpstatbuf.st_ino,
			(long)PL_statbuf.st_dev, (long)PL_statbuf.st_ino,
			CopFILE(PL_curcop),
			PL_statbuf.st_uid, PL_statbuf.st_gid);
		    (void)PerlProc_pclose(PL_rsfp);
		}
#endif
@


1.5
log
@perl-5.6.0 + local changes
@
text
@d2761 1
d2772 1
@


1.4
log
@perl5.005_03 (stock)
@
text
@d3 1
a3 1
 *    Copyright (c) 1987-1999 Larry Wall
d15 1
d17 1
a17 1
#include "patchlevel.h"
d25 1
a25 1
char *getenv _((char *)); /* Usually in <stdlib.h> */
d28 1
a28 6
#ifdef I_FCNTL
#include <fcntl.h>
#endif
#ifdef I_SYS_FILE
#include <sys/file.h>
#endif
d43 40
a82 25
static I32 read_e_script _((CPerlObj* pPerl, int idx, SV *buf_sv, int maxlen));
#else
static void find_beginning _((void));
static void forbid_setid _((char *));
static void incpush _((char *, int));
static void init_interp _((void));
static void init_ids _((void));
static void init_debugger _((void));
static void init_lexer _((void));
static void init_main_stash _((void));
#ifdef USE_THREADS
static struct perl_thread * init_main_thread _((void));
#endif /* USE_THREADS */
static void init_perllib _((void));
static void init_postdump_symbols _((int, char **, char **));
static void init_predump_symbols _((void));
static void my_exit_jump _((void)) __attribute__((noreturn));
static void nuke_stacks _((void));
static void open_script _((char *, bool, SV *, int *fd));
static void usage _((char *));
#ifdef IAMSUID
static int  fd_on_nosuid_fs _((int));
#endif
static void validate_suid _((char *, char*, int));
static I32 read_e_script _((int idx, SV *buf_sv, int maxlen));
d85 9
d95 18
a112 6
CPerlObj* perl_alloc(IPerlMem* ipM, IPerlEnv* ipE, IPerlStdIO* ipStd,
					     IPerlLIO* ipLIO, IPerlDir* ipD, IPerlSock* ipS, IPerlProc* ipP)
{
    CPerlObj* pPerl = new(ipM) CPerlObj(ipM, ipE, ipStd, ipLIO, ipD, ipS, ipP);
    if(pPerl != NULL)
	pPerl->Init();
d114 1
a114 1
    return pPerl;
d117 9
d129 4
a132 1
    PerlInterpreter *sv_interp;
d134 3
a136 3
    PL_curinterp = 0;
    New(53, sv_interp, 1, PerlInterpreter);
    return sv_interp;
d138 9
a146 1
#endif /* PERL_OBJECT */
d149 1
a149 5
#ifdef PERL_OBJECT
CPerlObj::perl_construct(void)
#else
perl_construct(register PerlInterpreter *sv_interp)
#endif
d154 1
a154 1
    struct perl_thread *thr;
a156 5
    
#ifndef PERL_OBJECT
    if (!(PL_curinterp = sv_interp))
	return;
#endif
d159 5
a163 2
    ++PL_ninterps;
    Zero(sv_interp, 1, PerlInterpreter);
a168 8

    	INIT_THREADS;
#ifdef ALLOC_THREAD_KEY
        ALLOC_THREAD_KEY;
#else
	if (pthread_key_create(&PL_thr_key, 0))
	    croak("panic: pthread_key_create");
#endif
a169 1
	MUTEX_INIT(&PL_cred_mutex);
d178 1
a178 1
#ifdef EMULATE_ATOMIC_REFCOUNTS
d180 1
a180 1
#endif /* EMULATE_ATOMIC_REFCOUNTS */
d182 2
d187 6
d218 1
a218 1
	PL_sighandlerp = sighandler;
d233 1
a233 1
    PL_nrs = newSVpv("\n", 1);
d236 1
a236 8
    init_stacks(ARGS);
#ifdef MULTIPLICITY
    init_interp();
    PL_perl_destruct_level = 1; 
#else
   if (PL_perl_destruct_level > 0)
       init_interp();
#endif
d241 1
a241 4
    PL_start_env.je_prev = NULL;
    PL_start_env.je_ret = -1;
    PL_start_env.je_mustcatch = TRUE;
    PL_top_env     = &PL_start_env;
d244 1
d246 24
a269 8
#if defined(SUBVERSION) && SUBVERSION > 0
    sprintf(PL_patchlevel, "%7.5f",   (double) 5 
				+ ((double) PATCHLEVEL / (double) 1000)
				+ ((double) SUBVERSION / (double) 100000));
#else
    sprintf(PL_patchlevel, "%5.3f", (double) 5 +
				((double) PATCHLEVEL / (double) 1000));
#endif
a279 5
    DEBUG( {
	New(51,PL_debname,128,char);
	New(52,PL_debdelim,128,char);
    } )

d283 8
d292 1
a292 5
#ifdef PERL_OBJECT
CPerlObj::perl_destruct(void)
#else
perl_destruct(register PerlInterpreter *sv_interp)
#endif
d300 1
d303 2
a304 4
#ifndef PERL_OBJECT
    if (!(PL_curinterp = sv_interp))
	return;
#endif
d311 1
a311 1
    DEBUG_S(PerlIO_printf(PerlIO_stderr(),
d319 1
a319 1
	    DEBUG_S(PerlIO_printf(PerlIO_stderr(),
d333 1
a333 1
	    DEBUG_S(PerlIO_printf(PerlIO_stderr(),
d337 1
a337 1
	    DEBUG_S(PerlIO_printf(PerlIO_stderr(),
d351 1
a351 1
	    DEBUG_S(PerlIO_printf(PerlIO_stderr(),
d363 1
a363 1
	DEBUG_S(PerlIO_printf(PerlIO_stderr(),
d370 1
a370 1
    DEBUG_S(PerlIO_printf(PerlIO_stderr(), "perl_destruct: armageddon has arrived\n"));
d380 1
a380 1
	if (s = PerlEnv_getenv("PERL_DESTRUCT_LEVEL")) {
a390 4
#ifdef MULTIPLICITY
    --PL_ninterps;
#endif

d403 1
a410 2
    
	PL_dirty = TRUE;
a418 2
    SvREFCNT_dec(PL_parsehook);
    PL_parsehook = Nullsv;
d422 1
a422 1
	PL_exitlist[PL_exitlistlen].fn(PERL_OBJECT_THIS_ PL_exitlist[PL_exitlistlen].ptr);
d453 1
a453 1
    PL_dowarn       = FALSE;
a455 2
    PL_sawstudy     = FALSE;	/* do fbm_instr on all strings */
    PL_sawvec       = FALSE;
d460 1
d469 1
a469 1
    Safefree(PL_ofs);	/* $, */
d472 1
a472 1
    Safefree(PL_ors);	/* $\ */
d481 3
a483 1
    PL_multiline = 0;	/* $* */
d499 5
d507 1
d511 1
a515 1
    PL_siggv = Nullgv;
d522 1
d525 1
d530 73
d608 6
d616 1
a616 1
    if (destruct_level >= 2) {
d618 2
a619 1
	    warn("Unbalanced scopes: %ld more ENTERs than LEAVEs\n",
d622 2
a623 1
	    warn("Unbalanced saves: %ld more saves than restores\n",
d626 1
a626 1
	    warn("Unbalanced tmps: %ld more allocs than frees\n",
d629 1
a629 1
	    warn("Unbalanced context: %ld more PUSHes than POPs\n",
d635 1
d641 2
d645 5
a649 1
    
d665 3
a667 2
	    if (hent) {
		warn("Unbalanced string table refcount: (%d) for \"%s\"",
d681 17
a697 2
    if (PL_sv_count != 0)
	warn("Scalars leaked: %ld\n", (long)PL_sv_count);
a701 2
    PL_linestr = NULL;
    PL_pidstatus = Nullhv;
a702 1
    Safefree(PL_archpat_auto);
d704 3
d716 1
a717 1
    MUTEX_DESTROY(&PL_eval_mutex);
d729 1
a729 1
    
d745 1
a745 1
	SvOOK_off(PL_mess_sv);
d753 8
d762 1
a762 5
#ifdef PERL_OBJECT
CPerlObj::perl_free(void)
#else
perl_free(PerlInterpreter *sv_interp)
#endif
d764 2
a765 2
#ifdef PERL_OBJECT
	Safefree(this);
d767 7
a773 3
    if (!(PL_curinterp = sv_interp))
	return;
    Safefree(sv_interp);
d778 1
a778 5
#ifdef PERL_OBJECT
CPerlObj::perl_atexit(void (*fn) (CPerlObj*,void *), void *ptr)
#else
perl_atexit(void (*fn) (void *), void *ptr)
#endif
d786 8
d795 1
a795 5
#ifdef PERL_OBJECT
CPerlObj::perl_parse(void (*xsinit) (CPerlObj*), int argc, char **argv, char **env)
#else
perl_parse(PerlInterpreter *sv_interp, void (*xsinit) (void), int argc, char **argv, char **env)
#endif
a797 5
    register SV *sv;
    register char *s;
    char *scriptname = NULL;
    VOL bool dosearch = FALSE;
    char *validarg = "";
d799 1
a799 1
    AV* comppadlist;
d801 3
a803 2
    int ret;
    int fdscript = -1;
d808 1
a808 1
    croak("suidperl is no longer needed since the kernel can now execute\n\
d813 1
a813 6
#ifndef PERL_OBJECT
    if (!(PL_curinterp = sv_interp))
	return 255;
#endif

#if defined(NeXT) && defined(__DYNAMIC__)
d847 1
d849 3
d853 1
d855 8
d872 4
a875 4
	if (PL_endav)
	    call_list(oldscope, PL_endav);
	JMPENV_POP;
	return STATUS_NATIVE_EXPORT;
d877 3
a879 3
	JMPENV_POP;
	PerlIO_printf(PerlIO_stderr(), "panic: top_env\n");
	return 1;
d881 29
d912 1
a912 1
    sv = newSVpv("",0);		/* first used for -I flags */
d928 5
d954 2
d957 1
a957 1
	    if (s = moreswitches(s))
d968 1
a968 1
		croak("No -e allowed in setuid scripts");
d970 1
a970 1
		PL_e_script = newSVpv("",0);
d980 1
a980 1
		croak("No code specified for -e");
a988 2
	    while (s && isSPACE(*s))
		++s;
d990 7
a996 7
		char *e, *p;
		for (e = s; *e && !isSPACE(*e); e++) ;
		p = savepvn(s, e-s);
		incpush(p, TRUE);
		sv_catpv(sv,"-I");
		sv_catpv(sv,p);
		sv_catpv(sv," ");
d998 3
a1000 1
	    }	/* XXX else croak? */
a1022 1
#if defined(DEBUGGING) || defined(NO_EMBED) || defined(MULTIPLICITY)
a1026 3
#  ifdef NO_EMBED
		sv_catpv(PL_Sv," NO_EMBED");
#  endif
d1030 30
d1061 1
a1061 1
#endif
d1068 1
a1068 1
			    sv_catpvf(PL_Sv,"\"  \\t%s\\n\",",PL_localpatches[i]);
d1072 1
a1072 1
		sv_catpvf(PL_Sv,"\"  Built under %s\\n\"",OSNAME);
d1075 1
a1075 1
		sv_catpvf(PL_Sv,",\"  Compiled at %s %s\\n\"",__DATE__,__TIME__);
d1077 1
a1077 1
		sv_catpvf(PL_Sv,",\"  Compiled on %s\\n\"",__DATE__);
d1099 1
a1099 1
		PL_cddir = savepv(s);
d1120 1
a1120 1
	    croak("Unrecognized switch: -%s  (-h will show valid options)",s);
d1125 24
a1148 8
    if (!PL_tainting && (s = PerlEnv_getenv("PERL5OPT"))) {
	while (s && *s) {
	    while (isSPACE(*s))
		s++;
	    if (*s == '-') {
		s++;
		if (isSPACE(*s))
		    continue;
a1149 5
	    if (!*s)
		break;
	    if (!strchr("DIMUdmw", *s))
		croak("Illegal switch in PERL5OPT: -%c", *s);
	    s = moreswitches(s);
d1173 16
a1188 1
    if (PL_doextract)
d1190 4
d1207 1
a1207 1
    av_store(PL_comppad_name, 0, newSVpv("@@_", 2));
d1222 3
d1227 2
a1228 2
	(*xsinit)(PERL_OBJECT_THIS);	/* in case linked C routines want magical variables */
#if defined(VMS) || defined(WIN32) || defined(DJGPP)
d1232 4
d1251 1
a1251 1
	    croak("%s had compilation errors.\n", PL_origfilename);
d1253 2
a1254 2
	    croak("Execution of %s aborted due to compilation errors.\n",
		PL_origfilename);
d1257 1
a1257 1
    PL_curcop->cop_line = 0;
d1268 1
a1268 1
    sv_setsv(perl_get_sv("/", TRUE), PL_rs);
d1272 3
a1274 1
    if (PL_dowarn)
d1276 1
d1288 1
a1288 2
    JMPENV_POP;
    return 0;
d1291 8
d1300 1
a1300 5
#ifdef PERL_OBJECT
CPerlObj::perl_run(void)
#else
perl_run(PerlInterpreter *sv_interp)
#endif
d1302 1
a1302 1
    dSP;
d1304 1
d1306 2
a1307 5
    int ret;

#ifndef PERL_OBJECT
    if (!(PL_curinterp = sv_interp))
	return 255;
d1312 4
d1317 1
d1321 8
a1328 3
	break;
    case 2:
	/* my_exit() was called */
d1333 1
a1333 1
	if (PL_endav)
d1339 2
a1340 2
	JMPENV_POP;
	return STATUS_NATIVE_EXPORT;
d1342 3
a1344 5
	if (!PL_restartop) {
	    PerlIO_printf(PerlIO_stderr(), "panic: restartop\n");
	    FREETMPS;
	    JMPENV_POP;
	    return 1;
d1346 3
a1348 1
	POPSTACK_TO(PL_mainstack);
d1352 20
d1378 2
a1379 2
	DEBUG_S(PerlIO_printf(Perl_debug_log, "main thread is 0x%lx\n",
			      (unsigned long) thr));
d1382 1
a1382 1
	    PerlIO_printf(PerlIO_stderr(), "%s syntax OK\n", PL_origfilename);
d1386 1
a1386 1
	   sv_setiv(PL_DBsingle, 1); 
d1396 1
a1396 1
	CALLRUNOPS();
d1401 1
a1401 1
	CALLRUNOPS();
d1406 1
a1406 1
    return 0;
d1409 10
d1420 1
a1420 1
perl_get_sv(char *name, I32 create)
d1438 10
d1449 1
a1449 1
perl_get_av(char *name, I32 create)
d1459 10
d1470 1
a1470 1
perl_get_hv(char *name, I32 create)
d1480 11
d1492 1
a1492 1
perl_get_cv(char *name, I32 create)
d1496 3
d1511 8
d1520 1
a1520 1
perl_call_argv(char *sub_name, I32 flags, register char **argv)
d1535 1
a1535 1
    return perl_call_pv(sub_name, flags);
d1538 8
d1547 1
a1547 1
perl_call_pv(char *sub_name, I32 flags)
d1551 1
a1551 1
    return perl_call_sv((SV*)perl_get_cv(sub_name, TRUE), flags);
d1554 9
d1564 1
a1564 1
perl_call_method(char *methname, I32 flags)
d1570 2
a1571 1
    if (!PL_op)
d1573 1
d1576 4
a1579 4
    pp_method(ARGS);
	if(PL_op == &myop)
		PL_op = Nullop;
    return perl_call_sv(*PL_stack_sp--, flags);
d1583 9
d1593 1
a1593 1
perl_call_sv(SV *sv, I32 flags)
a1602 1
    dJMPENV;
d1605 1
d1636 7
a1642 1
    if (flags & G_EVAL) {
d1654 1
a1654 1
	    PUSHBLOCK(cx, CXt_EVAL, PL_stack_sp);
d1658 1
a1658 1
	    PL_in_eval = 1;
d1660 1
a1660 1
		PL_in_eval |= 4;
d1666 5
d1672 1
d1675 7
d1691 2
a1692 2
	    if (PL_statusvalue)
		croak("Callback called exit");
d1699 1
a1699 1
		break;
d1708 1
a1708 1
	    goto cleanup;
a1709 11
    }
    else
	CATCH_SET(TRUE);

    if (PL_op == (OP*)&myop)
	PL_op = pp_entersub(ARGS);
    if (PL_op)
	CALLRUNOPS();
    retval = PL_stack_sp - (PL_stack_base + oldmark);
    if ((flags & G_EVAL) && !(flags & G_KEEPERR))
	sv_setpv(ERRSV,"");
a1710 2
  cleanup:
    if (flags & G_EVAL) {
a1725 2
    else
	CATCH_SET(oldcatch);
d1737 27
d1766 8
d1775 1
a1775 1
perl_eval_sv(SV *sv, I32 flags)
a1783 1
    dJMPENV;
d1786 1
d1810 5
d1816 1
d1819 7
d1835 2
a1836 2
	if (PL_statusvalue)
	    croak("Callback called exit");
d1843 1
a1843 1
	    break;
d1852 1
a1852 1
	goto cleanup;
a1854 9
    if (PL_op == (OP*)&myop)
	PL_op = pp_entereval(ARGS);
    if (PL_op)
	CALLRUNOPS();
    retval = PL_stack_sp - (PL_stack_base + oldmark);
    if (!(flags & G_KEEPERR))
	sv_setpv(ERRSV,"");

  cleanup:
d1866 8
d1875 1
a1875 1
perl_eval_pv(char *p, I32 croak_on_error)
d1881 1
a1881 1
    perl_eval_sv(sv, G_SCALAR);
d1890 1
a1890 1
	croak(SvPVx(ERRSV, n_a));
d1898 8
d1907 1
a1907 1
perl_require_pv(char *pv)
d1917 1
a1917 1
    perl_eval_sv(sv, G_DISCARD);
d1923 1
a1923 1
magicname(char *sym, char *name, I32 namlen)
d1927 1
a1927 1
    if (gv = gv_fetchpv(sym,TRUE, SVt_PV))
d1932 1
a1932 2
usage(char *name)		/* XXX move this out into a module ? */
           
d1940 1
d1942 6
a1947 6
"-d[:debugger]   run scripts under debugger",
"-D[number/list] set debugging flags (argument is a bit mask or flags)",
"-e 'command'    one line of script. Several -e's allowed. Omit [programfile].",
"-F/pattern/     split() pattern for autosplit (-a). The //'s are optional.",
"-i[extension]   edit <> files in place (make backup if extension supplied)",
"-Idirectory     specify @@INC/#include directory (may be used more than once)",
d1949 8
a1956 8
"-[mM][-]module.. executes `use/no module...' before executing your script.",
"-n              assume 'while (<>) { ... }' loop around your script",
"-p              assume loop like -n but print line also like sed",
"-P              run script through C preprocessor before compilation",
"-s              enable some switch parsing for switches after script name",
"-S              look for the script using PATH environment variable",
"-T              turn on tainting checks",
"-u              dump core after parsing script",
d1958 5
a1962 3
"-v              print version number, patchlevel plus VERY IMPORTANT perl info",
"-V[:variable]   print perl configuration information",
"-w              TURN WARNINGS ON FOR COMPILATION OF YOUR SCRIPT. Recommended.",
d1977 1
a1977 1
moreswitches(char *s)
d1986 1
a1986 1
	rschar = scan_oct(s, 4, &numlen);
d1991 1
a1991 1
	    PL_nrs = newSVpv("", 0);
d1994 1
a1994 1
	    PL_nrs = newSVpv(&ch, 1);
d1998 4
d2019 1
a2019 1
	    my_setenv("PERL5DB", form("use Devel::%s;", ++s));
d2028 1
d2044 4
a2047 1
	warn("Recompile perl with -DDEBUGGING to use -D switch\n");
d2052 1
d2075 14
a2088 5
	    for (e = s; *e && !isSPACE(*e); e++) ;
	    p = savepvn(s, e-s);
	    incpush(p, TRUE);
	    Safefree(p);
	    s = e;
d2091 1
a2091 1
	    croak("No space allowed after -I");
d2101 1
a2101 1
	    *PL_ors = scan_oct(s, 3 + (*s == '0'), &numlen);
d2134 1
a2134 1
			croak("Can't use '%c' after -mname", *s);
d2144 1
a2144 1
	    if (PL_preambleav == NULL)
d2149 1
a2149 1
	    croak("No space allowed after -%c", *(s-1));
d2166 1
a2166 1
	    croak("Too late for \"-T\" option");
d2178 2
a2179 7
#if defined(SUBVERSION) && SUBVERSION > 0
	printf("\nThis is perl, version 5.%03d_%02d built for %s",
	    PATCHLEVEL, SUBVERSION, ARCHNAME);
#else
	printf("\nThis is perl, version %s built for %s",
		PL_patchlevel, ARCHNAME);
#endif
d2183 1
a2183 1
		LOCAL_PATCH_COUNT, (LOCAL_PATCH_COUNT!=1) ? "es" : "");
d2186 1
a2186 1
	printf("\n\nCopyright 1987-1999, Larry Wall\n");
d2192 1
a2192 1
	printf("djgpp v2 port (perl5004+) by Laszlo Molnar, 1997-1998\n");
d2196 1
a2196 1
	    "Version 5 port Copyright (c) 1994-1998, Andreas Kaiser, Ilya Zakharevich\n");
d2202 1
a2202 1
	printf("BeOS port Copyright Tom Spindler, 1997-1998\n");
d2205 1
a2205 1
	printf("MPE/iX port Copyright by Mark Klein and Mark Bixby, 1996-1998\n");
d2208 1
a2208 1
	printf("MVS (OS390) port by Mortice Kern Systems, 1997-1998\n");
d2213 6
d2220 4
a2223 1
	printf("MiNT port by Guido Flohr, 1997\n");
d2236 12
a2247 1
	PL_dowarn = TRUE;
d2272 1
a2272 1
	croak("Can't emulate -%.1s on #! line",s);
d2283 1
a2283 1
my_unexec(void)
d2311 1
a2311 1
init_interp(void)
d2322 1
a2322 1
    PL_dlmax		= 128;		\
a2330 1
    PL_dlmax		= 128;		\
d2344 1
d2350 13
a2362 2
#    define PERLVARI(var,type,init)	PL_curinterp->var = init;
#    define PERLVARIC(var,type,init)	PL_curinterp->var = init;
d2368 1
d2371 1
a2371 1
#    else
d2373 1
d2381 1
d2390 1
a2390 1
init_main_stash(void)
d2406 1
a2406 1
    PL_curstname = newSVpv("main",4);
d2421 1
a2421 1
    (void)form("%240s","");	/* Preallocate temp - for immediate signals. */
d2425 1
a2425 1
    PL_compiling.cop_stash = PL_defstash;
d2429 1
a2429 1
    sv_setpvn(perl_get_sv("/", TRUE), "\n", 1);
d2433 1
a2433 1
open_script(char *scriptname, bool dosearch, SV *sv, int *fdscript)
a2435 1
    register char *s;
d2459 1
a2459 1
    PL_curcop->cop_filegv = gv_fetchfile(PL_origfilename);
d2471 1
a2471 1
	SV *cpp = newSVpv("",0);
d2475 1
a2475 1
	    sv_catpvf(cpp, "%s/", BIN_EXP);
d2478 1
a2478 1
	sv_catpv(sv,"-I");
d2482 1
a2482 1
	sv_setpvf(cmd, "\
d2494 1
a2494 1
 %s | %_ -C %_ %s",
d2497 2
a2498 1
	sv_setpvf(cmd, "\
d2510 16
a2525 1
 %s | %_ -C %_ %s",
d2551 1
a2551 1
		croak("Can't do seteuid!\n");
d2573 1
a2573 1
	    PerlLIO_stat(SvPVX(GvSV(PL_curcop->cop_filegv)),&PL_statbuf) >= 0 &&
d2577 4
a2580 2
	    PerlProc_execv(form("%s/sperl%s", BIN_EXP, PL_patchlevel), PL_origargv);
	    croak("Can't do setuid\n");
d2584 2
a2585 2
	croak("Can't open perl script \"%s\": %s\n",
	  SvPVX(GvSV(PL_curcop->cop_filegv)), Strerror(errno));
d2589 7
d2597 2
a2598 2
static int
fd_on_nosuid_fs(int fd)
d2600 2
a2601 2
    int on_nosuid  = 0;
    int check_okay = 0;
d2603 1
a2603 1
 * Preferred order: fstatvfs(), fstatfs(), getmntent().
d2605 4
a2608 2
 * fstatfs() is BSD.
 * getmntent() is O(number-of-mounted-filesystems) and can hang.
d2616 4
a2619 1
#       if defined(HAS_FSTATFS) && defined(HAS_STRUCT_STATFS_FLAGS)
a2621 11
#           undef PERL_MOUNT_NOSUID
#           if !defined(PERL_MOUNT_NOSUID) && defined(MNT_NOSUID)
#              define PERL_MOUNT_NOSUID MNT_NOSUID
#           endif
#           if !defined(PERL_MOUNT_NOSUID) && defined(MS_NOSUID)
#              define PERL_MOUNT_NOSUID MS_NOSUID
#           endif
#           if !defined(PERL_MOUNT_NOSUID) && defined(M_NOSUID)
#              define PERL_MOUNT_NOSUID M_NOSUID
#           endif
#           ifdef PERL_MOUNT_NOSUID
d2623 28
a2650 1
#           endif
d2652 3
a2654 1
#           if defined(HAS_GETMNTENT) && defined(HAS_HASMNTOPT) && defined(MNTOPT_NOSUID)
d2674 2
a2675 2
#           endif /* mntent */
#       endif /* statfs */
d2677 1
d2679 1
a2679 2
	croak("Can't check filesystem of script \"%s\" for nosuid",
	      PL_origfilename);
d2685 1
a2685 1
validate_suid(char *validarg, char *scriptname, int fdscript)
d2687 1
d2689 1
d2716 1
a2716 1
	croak("Can't stat script \"%s\"",PL_origfilename);
d2731 2
a2732 2
	if (PerlLIO_access(SvPVX(GvSV(PL_curcop->cop_filegv)),1)) /*double check*/
	    croak("Permission denied");
d2751 3
a2753 3
		croak("Can't swap uid and euid");	/* really paranoid */
	    if (PerlLIO_stat(SvPVX(GvSV(PL_curcop->cop_filegv)),&tmpstatbuf) < 0)
		croak("Permission denied");	/* testing full pathname here */
d2756 1
a2756 1
		croak("Permission denied");
d2763 3
a2765 3
"User %ld tried to run dev %ld ino %ld in place of dev %ld ino %ld!\n\
(Filename of set-id script was %s, uid %ld gid %ld.)\n\nSincerely,\nperl\n",
			(long)PL_uid,(long)tmpstatbuf.st_dev, (long)tmpstatbuf.st_ino,
d2767 2
a2768 2
			SvPVX(GvSV(PL_curcop->cop_filegv)),
			(long)PL_statbuf.st_uid, (long)PL_statbuf.st_gid);
d2771 1
a2771 1
		croak("Permission denied\n");
d2782 1
a2782 1
		croak("Can't reswap uid and euid");
d2784 1
a2784 1
		croak("Permission denied\n");
d2790 1
a2790 1
	    croak("Permission denied");
d2792 1
a2792 1
	    croak("Setuid/gid script is writable by world");
d2794 1
a2794 1
	PL_curcop->cop_line++;
d2797 1
a2797 1
	    croak("No #! line");
d2804 1
a2804 1
	    croak("Not a perl script");
d2814 1
a2814 1
	    croak("Args must match #! line");
d2820 1
a2820 1
		croak("YOU HAVEN'T DISABLED SET-ID SCRIPTS IN THE KERNEL YET!\n\
d2828 3
a2830 1
	    PerlProc_execv(form("%s/sperl%s", BIN_EXP, PL_patchlevel), PL_origargv);
d2832 1
a2832 1
	    croak("Can't do setuid\n");
d2850 1
a2850 1
		croak("Can't do setegid!\n");
d2868 1
a2868 1
		croak("Can't do seteuid!\n");
d2885 1
a2885 1
		croak("Can't do seteuid!\n");
d2889 1
a2889 1
	    croak("Permission denied\n");	/* they can't do this */
d2893 1
a2893 1
	croak("-P not allowed for setuid/setgid script\n");
d2895 1
a2895 1
	croak("fd script not allowed in suidperl\n");
d2897 1
a2897 1
	croak("Script is not setuid/setgid in suidperl\n");
d2906 2
a2907 2
	croak("Permission denied");
    PL_origargv[which] = savepv(form("/dev/fd/%d/%s",
d2912 4
a2915 2
    PerlProc_execv(form("%s/perl%s", BIN_EXP, PL_patchlevel), PL_origargv);/* try again */
    croak("Can't do setuid\n");
d2927 1
a2927 1
		croak("YOU HAVEN'T DISABLED SET-ID SCRIPTS IN THE KERNEL YET!\n\
d2936 1
a2936 1
find_beginning(void)
d2945 1
a2945 1
	    croak("No Perl script found in input\n");
d2956 2
a2957 1
		    while (s = moreswitches(s)) ;
a2958 2
	    if (PL_cddir && PerlDir_chdir(PL_cddir) < 0)
		croak("Can't chdir to %s",PL_cddir);
d2965 1
a2965 1
init_ids(void)
d2967 4
a2970 4
    PL_uid = (int)PerlProc_getuid();
    PL_euid = (int)PerlProc_geteuid();
    PL_gid = (int)PerlProc_getgid();
    PL_egid = (int)PerlProc_getegid();
d2979 1
a2979 1
forbid_setid(char *s)
d2982 1
a2982 1
        croak("No %s allowed while running setuid", s);
d2984 1
a2984 1
        croak("No %s allowed while running setgid", s);
d2987 2
a2988 2
STATIC void
init_debugger(void)
d2991 2
d2999 1
d3006 1
a3006 1
    PL_curstash = PL_defstash;
d3016 1
a3016 1
init_stacks(ARGSproto)
d3038 1
a3038 1
    SET_MARKBASE;
d3056 1
a3056 1
nuke_stacks(void)
a3072 4
    DEBUG( {
	Safefree(PL_debname);
	Safefree(PL_debdelim);
    } )
d3080 1
a3080 1
init_lexer(void)
d3089 1
a3089 1
    PL_subname = newSVpv("main",4);
d3093 1
a3093 1
init_predump_symbols(void)
d3097 1
a3097 1
    GV *othergv;
d3099 1
a3099 1
    sv_setpvn(perl_get_sv("\"", TRUE), " ", 1);
d3102 2
a3103 1
    IoIFP(GvIOp(PL_stdingv)) = PerlIO_stdin();
d3106 1
a3106 1
    GvIOp(tmpgv) = (IO*)SvREFCNT_inc(GvIOp(PL_stdingv));
d3110 2
a3111 1
    IoOFP(GvIOp(tmpgv)) = IoIFP(GvIOp(tmpgv)) = PerlIO_stdout();
d3115 1
a3115 1
    GvIOp(tmpgv) = (IO*)SvREFCNT_inc(GvIOp(PL_defoutgv));
d3117 4
a3120 3
    othergv = gv_fetchpv("STDERR",TRUE, SVt_PVIO);
    GvMULTI_on(othergv);
    IoOFP(GvIOp(othergv)) = IoIFP(GvIOp(othergv)) = PerlIO_stderr();
d3123 1
a3123 1
    GvIOp(tmpgv) = (IO*)SvREFCNT_inc(GvIOp(othergv));
d3132 1
a3132 1
init_postdump_symbols(register int argc, register char **argv, register char **env)
d3144 1
a3144 1
	    if (argv[0][1] == '-') {
d3148 1
a3148 1
	    if (s = strchr(argv[0], '=')) {
d3165 1
a3165 1
    if (tmpgv = gv_fetchpv("0",TRUE, SVt_PV)) {
d3169 4
a3172 1
    if (tmpgv = gv_fetchpv("\030",TRUE, SVt_PV))
d3174 2
a3175 1
    if (PL_argvgv = gv_fetchpv("ARGV",TRUE, SVt_PVAV)) {
d3180 4
a3183 1
	    av_push(GvAVn(PL_argvgv),newSVpv(argv[0],0));
d3186 1
a3186 1
    if (PL_envgv = gv_fetchpv("ENV",TRUE, SVt_PVHV)) {
d3191 1
a3191 1
#ifndef VMS  /* VMS doesn't have environ array */
d3222 2
a3223 2
    if (tmpgv = gv_fetchpv("$",TRUE, SVt_PV))
	sv_setiv(GvSV(tmpgv), (IV)getpid());
d3227 1
a3227 1
init_perllib(void)
d3234 1
a3234 1
	    incpush(s, TRUE);
d3236 1
a3236 1
	    incpush(PerlEnv_getenv("PERLLIB"), FALSE);
d3245 1
a3245 1
	    do { incpush(buf,TRUE); } while (my_trnlnm("PERL5LIB",buf,++idx));
d3247 1
a3247 1
	    while (my_trnlnm("PERLLIB",buf,idx++)) incpush(buf,FALSE);
d3252 1
a3252 1
    ARCHLIB PRIVLIB SITEARCH and SITELIB 
d3255 1
a3255 1
    incpush(APPLLIB_EXP, TRUE);
d3259 1
a3259 1
    incpush(ARCHLIB_EXP, FALSE);
d3262 1
a3262 1
#define PRIVLIB_EXP "/usr/local/lib/perl5:/usr/local/lib/perl"
d3265 1
a3265 1
    incpush(PRIVLIB_EXP, TRUE);
d3267 1
a3267 1
    incpush(PRIVLIB_EXP, FALSE);
d3271 5
a3275 1
    incpush(SITEARCH_EXP, FALSE);
d3277 1
d3279 25
a3303 4
#if defined(WIN32) 
    incpush(SITELIB_EXP, TRUE);
#else
    incpush(SITELIB_EXP, FALSE);
d3305 3
d3309 1
d3311 1
a3311 1
	incpush(".", FALSE);
d3328 1
a3328 1
incpush(char *p, int addsubdirs)
d3332 1
a3332 1
    if (!p)
d3335 1
a3335 1
    if (addsubdirs) {
a3336 11
	if (!PL_archpat_auto) {
	    STRLEN len = (sizeof(ARCHNAME) + strlen(PL_patchlevel)
			  + sizeof("//auto"));
	    New(55, PL_archpat_auto, len, char);
	    sprintf(PL_archpat_auto, "/%s/%s/auto", ARCHNAME, PL_patchlevel);
#ifdef VMS
	for (len = sizeof(ARCHNAME) + 2;
	     PL_archpat_auto[len] != '\0' && PL_archpat_auto[len] != '/'; len++)
		if (PL_archpat_auto[len] == '.') PL_archpat_auto[len] = '_';
#endif
	}
d3347 1
a3347 1
	    /* av_push(GvAVn(PL_incgv), newSVpv(".", 1)); */
d3365 6
a3370 1
	if (addsubdirs) {
d3382 1
a3382 1
		PerlIO_printf(PerlIO_stderr(),
d3386 36
a3421 15
	    /* .../archname/version if -d .../archname/version/auto */
	    sv_setsv(subdir, libdir);
	    sv_catpv(subdir, PL_archpat_auto);
	    if (PerlLIO_stat(SvPVX(subdir), &tmpstatbuf) >= 0 &&
		  S_ISDIR(tmpstatbuf.st_mode))
		av_push(GvAVn(PL_incgv),
			newSVpv(SvPVX(subdir), SvCUR(subdir) - sizeof "auto"));

	    /* .../archname if -d .../archname/auto */
	    sv_insert(subdir, SvCUR(libdir) + sizeof(ARCHNAME),
		      strlen(PL_patchlevel) + 1, "", 0);
	    if (PerlLIO_stat(SvPVX(subdir), &tmpstatbuf) >= 0 &&
		  S_ISDIR(tmpstatbuf.st_mode))
		av_push(GvAVn(PL_incgv),
			newSVpv(SvPVX(subdir), SvCUR(subdir) - sizeof "auto"));
d3431 1
a3431 1
init_main_thread()
d3433 1
d3435 1
d3440 1
a3444 1
    thr->errhv = newHV();
d3459 1
d3469 1
a3469 1
    init_thread_intern(thr);
d3477 1
a3477 1
    SET_THR(thr);
d3490 1
a3490 1
    thr->errsv = newSVpv("", 0);
d3494 5
a3498 2
    PL_regcompp = FUNC_NAME_TO_PTR(pregcomp);
    PL_regexecp = FUNC_NAME_TO_PTR(regexec_flags);
d3507 1
a3507 1
call_list(I32 oldscope, AV *paramList)
d3510 3
a3512 1
    line_t oldline = PL_curcop->cop_line;
d3514 1
a3515 1
    int ret;
d3518 1
a3518 2
	CV *cv = (CV*)av_shift(paramList);

d3520 3
a3522 1

d3524 1
d3526 22
a3547 17
	case 0: {
		SV* atsv = ERRSV;
		PUSHMARK(PL_stack_sp);
		perl_call_sv((SV*)cv, G_EVAL|G_DISCARD);
		(void)SvPV(atsv, len);
		if (len) {
		    JMPENV_POP;
		    PL_curcop = &PL_compiling;
		    PL_curcop->cop_line = oldline;
		    if (paramList == PL_beginav)
			sv_catpv(atsv, "BEGIN failed--compilation aborted");
		    else
			sv_catpv(atsv, "END failed--cleanup aborted");
		    while (PL_scopestack_ix > oldscope)
			LEAVE;
		    croak("%s", SvPVX(atsv));
		}
d3559 2
a3560 2
	    if (PL_endav)
		call_list(oldscope, PL_endav);
d3562 1
a3562 3
	    PL_curcop = &PL_compiling;
	    PL_curcop->cop_line = oldline;
	    if (PL_statusvalue) {
d3564 1
a3564 1
		    croak("BEGIN failed--compilation aborted");
d3566 4
a3569 1
		    croak("END failed--cleanup aborted");
d3574 4
a3577 4
	    if (!PL_restartop) {
		PerlIO_printf(PerlIO_stderr(), "panic: restartop\n");
		FREETMPS;
		break;
d3579 3
a3581 4
	    JMPENV_POP;
	    PL_curcop = &PL_compiling;
	    PL_curcop->cop_line = oldline;
	    JMPENV_JUMP(3);
d3587 17
d3605 1
a3605 1
my_exit(U32 status)
d3626 1
a3626 1
my_failure_exit(void)
d3655 1
a3655 1
my_exit_jump(void)
d3657 1
a3657 1
    dSP;
a3678 3
#define NO_XSLOCKS
#endif  /* PERL_OBJECT */

d3680 1
d3683 1
a3683 5
#ifdef PERL_OBJECT
read_e_script(CPerlObj *pPerl, int idx, SV *buf_sv, int maxlen)
#else
read_e_script(int idx, SV *buf_sv, int maxlen)
#endif
a3696 2


@


1.3
log
@perl 5.004_04
@
text
@d3 1
a3 1
 *    Copyright (c) 1987-1997 Larry Wall
d27 6
a32 1
dEXTCONST char rcsid[] = "perl.c\nPatch level: ###\n";
d46 3
a48 24
#define I_REINIT \
  STMT_START {			\
    chopset	= " \n-";	\
    copline	= NOLINE;	\
    curcop	= &compiling;	\
    curcopdb    = NULL;		\
    cxstack_ix  = -1;		\
    cxstack_max = 128;		\
    dbargs	= 0;		\
    dlmax	= 128;		\
    laststatval	= -1;		\
    laststype	= OP_STAT;	\
    maxscream	= -1;		\
    maxsysfd	= MAXSYSFD;	\
    statname	= Nullsv;	\
    tmps_floor	= -1;		\
    tmps_ix     = -1;		\
    op_mask     = NULL;		\
    dlmax       = 128;		\
    laststatval = -1;		\
    laststype   = OP_STAT;	\
    mess_sv     = Nullsv;	\
  } STMT_END

d52 1
d57 3
a62 1
static void init_stacks _((void));
d65 1
a65 1
static void open_script _((char *, bool, SV *));
d67 6
a72 1
static void validate_suid _((char *, char*));
d74 7
a80 1
static int fdscript = -1;
d82 3
d86 1
a86 1
perl_alloc()
d90 1
a90 1
    curinterp = 0;
d94 1
d97 5
a101 2
perl_construct( sv_interp )
register PerlInterpreter *sv_interp;
d103 9
a111 1
    if (!(curinterp = sv_interp))
d113 1
d116 1
d120 27
a146 4
    /* Init the real globals? */
    if (!linestr) {
	linestr = NEWSV(65,80);
	sv_upgrade(linestr,SVt_PVIV);
d148 2
a149 2
	if (!SvREADONLY(&sv_undef)) {
	    SvREADONLY_on(&sv_undef);
d151 3
a153 3
	    sv_setpv(&sv_no,No);
	    SvNV(&sv_no);
	    SvREADONLY_on(&sv_no);
d155 12
a166 3
	    sv_setpv(&sv_yes,Yes);
	    SvNV(&sv_yes);
	    SvREADONLY_on(&sv_yes);
d169 7
a175 4
	nrs = newSVpv("\n", 1);
	rs = SvREFCNT_inc(nrs);

	pidstatus = newHV();
d188 4
d193 2
a194 2
    I_REINIT;
    perl_destruct_level = 1; 
d196 2
a197 2
   if(perl_destruct_level > 0)
       I_REINIT;
d201 1
a201 1
    lex_state = LEX_NOTPARSING;
d203 4
a206 4
    start_env.je_prev = NULL;
    start_env.je_ret = -1;
    start_env.je_mustcatch = TRUE;
    top_env     = &start_env;
d211 1
a211 1
    sprintf(patchlevel, "%7.5f",   (double) 5 
d215 1
a215 1
    sprintf(patchlevel, "%5.3f", (double) 5 +
d220 1
a220 1
    localpatches = local_patches;	/* For possible -v */
d223 4
a226 1
    PerlIO_init();      /* Hook to IO system */
d228 4
a231 1
    fdpid = newAV();	/* for remembering popen pids by fd */
a232 1
    init_stacks();
d237 5
a241 2
perl_destruct(sv_interp)
register PerlInterpreter *sv_interp;
d243 1
d247 3
d251 2
a252 1
    if (!(curinterp = sv_interp))
d254 71
d326 1
a326 1
    destruct_level = perl_destruct_level;
d330 1
a330 1
	if (s = getenv("PERL_DESTRUCT_LEVEL")) {
d341 4
d348 9
a356 8
    if (main_root) {
	curpad = AvARRAY(comppad);
	op_free(main_root);
	main_root = Nullop;
    }
    main_start = Nullop;
    SvREFCNT_dec(main_cv);
    main_cv = Nullcv;
d358 1
a358 1
    if (sv_objcount) {
d365 1
a365 1
	dirty = TRUE;
d370 12
a381 6
    SvREFCNT_dec(warnhook);
    warnhook = Nullsv;
    SvREFCNT_dec(diehook);
    diehook = Nullsv;
    SvREFCNT_dec(parsehook);
    parsehook = Nullsv;
d393 3
a395 3
    if(rsfp) {
	(void)PerlIO_close(rsfp);
	rsfp = Nullfp;
d399 2
a400 2
    SvREFCNT_dec(rsfp_filters);
    rsfp_filters = Nullav;
d403 20
a422 23
    preprocess   = FALSE;
    minus_n      = FALSE;
    minus_p      = FALSE;
    minus_l      = FALSE;
    minus_a      = FALSE;
    minus_F      = FALSE;
    doswitches   = FALSE;
    dowarn       = FALSE;
    doextract    = FALSE;
    sawampersand = FALSE;	/* must save all match strings */
    sawstudy     = FALSE;	/* do fbm_instr on all strings */
    sawvec       = FALSE;
    unsafe       = FALSE;

    Safefree(inplace);
    inplace = Nullch;

    Safefree(e_tmpname);
    e_tmpname = Nullch;

    if (e_fp) {
	PerlIO_close(e_fp);
	e_fp = Nullfp;
d427 2
a428 2
    Safefree(ofs);	/* $, */
    ofs = Nullch;
d430 2
a431 2
    Safefree(ors);	/* $\ */
    ors = Nullch;
d433 2
a434 2
    SvREFCNT_dec(nrs);	/* $\ helper */
    nrs = Nullsv;
d436 2
a437 1
    multiline = 0;	/* $* */
d439 5
a443 3
    SvREFCNT_dec(statname);
    statname = Nullsv;
    statgv = Nullgv;
a446 30
#if 0  /* just about all regexp stuff, seems to be ok */

    /* shortcuts to regexp stuff */
    leftgv = Nullgv;
    ampergv = Nullgv;

    SAVEFREEOP(curpm);
    SAVEFREEOP(oldlastpm); /* for saving regexp context during debugger */

    regprecomp = NULL;	/* uncompiled string. */
    regparse = NULL;	/* Input-scan pointer. */
    regxend = NULL;	/* End of input for compile */
    regnpar = 0;	/* () count. */
    regcode = NULL;	/* Code-emit pointer; &regdummy = don't. */
    regsize = 0;	/* Code size. */
    regnaughty = 0;	/* How bad is this pattern? */
    regsawback = 0;	/* Did we see \1, ...? */

    reginput = NULL;		/* String-input pointer. */
    regbol = NULL;		/* Beginning of input, for ^ check. */
    regeol = NULL;		/* End of input, for $ check. */
    regstartp = (char **)NULL;	/* Pointer to startp array. */
    regendp = (char **)NULL;	/* Ditto for endp. */
    reglastparen = 0;		/* Similarly for lastparen. */
    regtill = NULL;		/* How far we are required to go. */
    regflags = 0;		/* are we folding, multilining? */
    regprev = (char)NULL;	/* char before regbol, \n if none */

#endif /* if 0 */

d448 6
a453 6
    SvREFCNT_dec(lastscream);
    lastscream = Nullsv;
    Safefree(screamfirst);
    screamfirst = 0;
    Safefree(screamnext);
    screamnext  = 0;
d456 6
a461 8
    SvREFCNT_dec(beginav);
    SvREFCNT_dec(endav);
    beginav = Nullav;
    endav = Nullav;

    /* temp stack during pp_sort() */
    SvREFCNT_dec(sortstack);
    sortstack = Nullav;
d464 10
a473 8
    envgv = Nullgv;
    siggv = Nullgv;
    incgv = Nullgv;
    errgv = Nullgv;
    argvgv = Nullgv;
    argvoutgv = Nullgv;
    stdingv = Nullgv;
    last_in_gv = Nullgv;
d480 2
a481 2
    hv = defstash;
    defstash = 0;
d486 1
a486 1
	if (scopestack_ix != 0)
d488 2
a489 2
		 (long)scopestack_ix);
	if (savestack_ix != 0)
d491 2
a492 2
		 (long)savestack_ix);
	if (tmps_floor != -1)
d494 1
a494 1
		 (long)tmps_floor + 1);
d502 3
a504 3
    SvFLAGS(strtab) |= SVTYPEMASK;		/* don't clean out strtab now */
    while (sv_count != 0 && sv_count != last_sv_count) {
	last_sv_count = sv_count;
d507 2
a508 2
    SvFLAGS(strtab) &= ~SVTYPEMASK;
    SvFLAGS(strtab) |= SVt_PVHV;
d521 2
a522 2
	max = HvMAX(strtab);
	array = HvARRAY(strtab);
d538 1
a538 1
    SvREFCNT_dec(strtab);
d540 2
a541 2
    if (sv_count != 0)
	warn("Scalars leaked: %ld\n", (long)sv_count);
d546 7
a552 4
    linestr = NULL;
    pidstatus = Nullhv;
    if (origfilename)
    	Safefree(origfilename);
d554 1
a554 1
    hints = 0;		/* Reset hints. Should hints be per-interpreter ? */
d557 17
a573 1

d576 12
a587 1
    if (mess_sv) {
d589 5
a593 5
	SvOOK_off(mess_sv);
	Safefree(SvPVX(mess_sv));
	Safefree(SvANY(mess_sv));
	Safefree(mess_sv);
	mess_sv = Nullsv;
d598 5
a602 2
perl_free(sv_interp)
PerlInterpreter *sv_interp;
d604 4
a607 1
    if (!(curinterp = sv_interp))
d610 14
d627 5
a631 6
perl_parse(sv_interp, xsinit, argc, argv, env)
PerlInterpreter *sv_interp;
void (*xsinit)_((void));
int argc;
char **argv;
char **env;
d633 1
d643 1
d653 2
a654 1
    if (!(curinterp = sv_interp))
d656 1
d663 2
a664 2
    origargv = argv;
    origargc = argc;
d666 1
a666 1
    origenviron = environ;
a667 1
    e_tmpname = Nullch;
d669 1
a669 1
    if (do_undump) {
d673 2
a674 2
	origfilename = savepv(argv[0]);
	do_undump = FALSE;
d681 8
a688 8
    if (main_root) {
	curpad = AvARRAY(comppad);
	op_free(main_root);
	main_root = Nullop;
    }
    main_start = Nullop;
    SvREFCNT_dec(main_cv);
    main_cv = Nullcv;
d690 2
a691 2
    time(&basetime);
    oldscope = scopestack_ix;
d700 1
a700 1
	while (scopestack_ix > oldscope)
d703 3
a705 3
	curstash = defstash;
	if (endav)
	    call_list(oldscope, endav);
d714 1
a714 1
    sv_setpvn(linestr,"",0);
d731 4
d758 1
a758 1
	    tainting = TRUE;
d763 1
a763 1
	    if (euid != uid || egid != gid)
d765 3
a767 12
	    if (!e_fp) {
		int fd;

	        e_tmpname = savepv(TMPPATH);
		fd = mkstemp(e_tmpname);
		if (fd == -1)
		    croak("Can't mkstemp()");
		e_fp = PerlIO_fdopen(fd,"w");
		if (!e_fp) {
		    (void)close(fd);
		    croak("Cannot open temporary file");
		}
d770 1
a770 1
		PerlIO_puts(e_fp,s);
d772 1
a772 1
		PerlIO_puts(e_fp,argv[1]);
d777 1
a777 1
	    (void)PerlIO_putc(e_fp,'\n');
d779 1
d800 1
a800 1
	    preprocess = TRUE;
d809 3
a811 3
	    if (!preambleav)
		preambleav = newAV();
	    av_push(preambleav, newSVpv("use Config qw(myconfig config_vars)",0));
d813 1
a813 1
		Sv = newSVpv("print myconfig();",0);
d815 1
a815 1
		sv_catpv(Sv,"print \"\\nCharacteristics of this PERLSHR image: \\n\",");
d817 1
a817 1
		sv_catpv(Sv,"print \"\\nCharacteristics of this binary (from libperl): \\n\",");
d820 1
a820 1
		sv_catpv(Sv,"\"  Compile-time options:");
d822 1
a822 1
		sv_catpv(Sv," DEBUGGING");
d825 1
a825 1
		sv_catpv(Sv," NO_EMBED");
d828 1
a828 1
		sv_catpv(Sv," MULTIPLICITY");
d830 1
a830 1
		sv_catpv(Sv,"\\n\",");
d835 1
a835 1
		    sv_catpv(Sv,"\"  Locally applied patches:\\n\",");
d837 2
a838 2
			if (localpatches[i])
			    sv_catpvf(Sv,"\"  \\t%s\\n\",",localpatches[i]);
d842 1
a842 1
		sv_catpvf(Sv,"\"  Built under %s\\n\"",OSNAME);
d845 1
a845 1
		sv_catpvf(Sv,",\"  Compiled at %s %s\\n\"",__DATE__,__TIME__);
d847 1
a847 1
		sv_catpvf(Sv,",\"  Compiled on %s\\n\"",__DATE__);
d850 1
a850 1
		sv_catpv(Sv, "; \
d857 3
a859 3
		Sv = newSVpv("config_vars(qw(",0);
		sv_catpv(Sv, ++s);
		sv_catpv(Sv, "))");
d862 1
a862 1
	    av_push(preambleav, Sv);
d866 1
a866 1
	    doextract = TRUE;
d869 1
a869 1
		cddir = savepv(s);
d895 1
a895 1
    if (!tainting && (s = getenv("PERL5OPT"))) {
d914 1
a914 8
    if (e_fp) {
	if (PerlIO_flush(e_fp) || PerlIO_error(e_fp) || PerlIO_close(e_fp)) {
#ifndef MULTIPLICITY
	    warn("Did you forget to compile with -DMULTIPLICITY?");
#endif	    
	    croak("Can't write to temp file for -e: %s", Strerror(errno));
	}
	e_fp = Nullfp;
d916 1
a916 1
	scriptname = e_tmpname;
d920 1
a920 1
	if ( isatty(PerlIO_fileno(PerlIO_stdin())) )
d928 1
a928 1
    open_script(scriptname,dosearch,sv);
d930 1
a930 1
    validate_suid(validarg, scriptname);
d932 1
a932 1
    if (doextract)
d935 19
a953 11
    main_cv = compcv = (CV*)NEWSV(1104,0);
    sv_upgrade((SV *)compcv, SVt_PVCV);
    CvUNIQUE_on(compcv);

    comppad = newAV();
    av_push(comppad, Nullsv);
    curpad = AvARRAY(comppad);
    comppad_name = newAV();
    comppad_name_fill = 0;
    min_intro_pending = 0;
    padix = 0;
d957 3
a959 3
    av_store(comppadlist, 0, (SV*)comppad_name);
    av_store(comppadlist, 1, (SV*)comppad);
    CvPADLIST(compcv) = comppadlist;
d962 1
d964 2
a965 2
	(*xsinit)();	/* in case linked C routines want magical variables */
#if defined(VMS) || defined(WIN32)
d970 4
a973 1
    if (!do_undump)
d980 5
a984 4
    error_count = 0;
    if (yyparse() || error_count) {
	if (minus_c)
	    croak("%s had compilation errors.\n", origfilename);
d987 1
a987 1
		origfilename);
d990 6
a995 7
    curcop->cop_line = 0;
    curstash = defstash;
    preprocess = FALSE;
    if (e_tmpname) {
	(void)UNLINK(e_tmpname);
	Safefree(e_tmpname);
	e_tmpname = Nullch;
d999 4
a1002 5
    SvREFCNT_dec(rs);
    rs = SvREFCNT_inc(nrs);
    sv_setsv(GvSV(gv_fetchpv("/", TRUE, SVt_PV)), rs);

    if (do_undump)
d1005 2
a1006 2
    if (dowarn)
	gv_check(defstash);
d1012 1
a1012 1
    if ((s=getenv("PERL_DEBUG_MSTATS")) && atoi(s) >= 2)
d1017 1
a1017 1
    restartop = 0;
d1023 5
a1027 2
perl_run(sv_interp)
PerlInterpreter *sv_interp;
d1029 1
d1034 2
a1035 1
    if (!(curinterp = sv_interp))
d1037 1
d1039 1
a1039 1
    oldscope = scopestack_ix;
d1048 1
a1048 1
	while (scopestack_ix > oldscope)
d1051 3
a1053 3
	curstash = defstash;
	if (endav)
	    call_list(oldscope, endav);
d1055 1
a1055 1
	if (getenv("PERL_DEBUG_MSTATS"))
d1061 1
a1061 1
	if (!restartop) {
d1067 1
a1067 4
	if (curstack != mainstack) {
	    dSP;
	    SWITCHSTACK(curstack, mainstack);
	}
d1072 1
a1072 1
                    sawampersand ? "Enabling" : "Omitting"));
d1074 1
a1074 1
    if (!restartop) {
d1077 2
d1080 2
a1081 2
	if (minus_c) {
	    PerlIO_printf(PerlIO_stderr(), "%s syntax OK\n", origfilename);
d1084 4
a1087 2
	if (PERLDB_SINGLE && DBsingle)
	   sv_setiv(DBsingle, 1); 
d1092 9
a1100 9
    if (restartop) {
	op = restartop;
	restartop = 0;
	runops();
    }
    else if (main_start) {
	CvDEPTH(main_cv) = 1;
	op = main_start;
	runops();
d1109 1
a1109 3
perl_get_sv(name, create)
char* name;
I32 create;
d1111 11
a1121 1
    GV* gv = gv_fetchpv(name, create, SVt_PV);
d1128 1
a1128 3
perl_get_av(name, create)
char* name;
I32 create;
d1139 1
a1139 3
perl_get_hv(name, create)
char* name;
I32 create;
d1150 1
a1150 3
perl_get_cv(name, create)
char* name;
I32 create;
d1153 1
d1167 4
a1170 4
perl_call_argv(subname, flags, argv)
char *subname;
I32 flags;		/* See G_* flags in cop.h */
register char **argv;	/* null terminated arg list */
d1174 1
a1174 1
    PUSHMARK(sp);
d1182 1
a1182 1
    return perl_call_pv(subname, flags);
d1186 3
a1188 3
perl_call_pv(subname, flags)
char *subname;		/* name of the subroutine */
I32 flags;		/* See G_* flags in cop.h */
d1190 1
a1190 1
    return perl_call_sv((SV*)perl_get_cv(subname, TRUE), flags);
d1194 3
a1196 3
perl_call_method(methname, flags)
char *methname;		/* name of the subroutine */
I32 flags;		/* See G_* flags in cop.h */
d1200 2
a1201 2
    if (!op)
	op = &myop;
d1204 4
a1207 2
    pp_method();
    return perl_call_sv(*stack_sp--, flags);
d1212 3
a1214 3
perl_call_sv(sv, flags)
SV* sv;
I32 flags;		/* See G_* flags in cop.h */
d1216 1
a1217 1
    SV** sp = stack_sp;
a1220 1
    static CV *DBcv;
d1224 1
a1224 1
    OP* oldop = op;
d1238 2
a1239 2
    SAVESPTR(op);
    op = (OP*)&myop;
d1241 2
a1242 2
    EXTEND(stack_sp, 1);
    *++stack_sp = sv;
d1244 1
a1244 1
    oldscope = scopestack_ix;
d1246 1
a1246 1
    if (PERLDB_SUB && curstash != debstash
d1248 1
a1248 1
	  && (DBcv || (DBcv = GvCV(DBsub)))
d1251 3
a1253 2
	  && (SvTYPE(sv) != SVt_PVCV || CvSTASH((CV*)sv) != debstash))
	op->op_private |= OPpENTERSUB_DB;
d1256 2
a1257 2
	cLOGOP->op_other = op;
	markstack_ptr--;
d1260 1
a1260 1
	    register CONTEXT *cx;
d1266 2
a1267 2
	    push_return(op->op_next);
	    PUSHBLOCK(cx, CXt_EVAL, stack_sp);
d1269 1
a1269 1
	    eval_root = op;             /* Only needed so that goto works right. */
d1271 1
a1271 1
	    in_eval = 1;
d1273 1
a1273 1
		in_eval |= 4;
d1275 1
a1275 1
		sv_setpv(GvSV(errgv),"");
d1277 1
a1277 1
	markstack_ptr++;
d1288 1
a1288 1
	    curstash = defstash;
d1291 1
a1291 1
	    if (statusvalue)
d1296 3
a1298 3
	    if (restartop) {
		op = restartop;
		restartop = 0;
d1301 1
a1301 1
	    stack_sp = stack_base + oldmark;
d1306 1
a1306 1
		*++stack_sp = &sv_undef;
d1314 5
a1318 5
    if (op == (OP*)&myop)
	op = pp_entersub();
    if (op)
	runops();
    retval = stack_sp - (stack_base + oldmark);
d1320 1
a1320 1
	sv_setpv(GvSV(errgv),"");
d1324 1
a1324 1
	if (scopestack_ix > oldscope) {
d1328 1
a1328 1
	    register CONTEXT *cx;
d1334 1
a1334 1
	    curpm = newpm;
d1343 1
a1343 1
	stack_sp = stack_base + oldmark;
d1348 1
a1348 1
    op = oldop;
d1355 3
a1357 3
perl_eval_sv(sv, flags)
SV* sv;
I32 flags;		/* See G_* flags in cop.h */
d1359 1
d1361 1
a1361 2
    SV** sp = stack_sp;
    I32 oldmark = sp - stack_base;
d1366 1
a1366 1
    OP* oldop = op;
d1373 6
a1378 6
    SAVESPTR(op);
    op = (OP*)&myop;
    Zero(op, 1, UNOP);
    EXTEND(stack_sp, 1);
    *++stack_sp = sv;
    oldscope = scopestack_ix;
d1399 1
a1399 1
	curstash = defstash;
d1402 1
a1402 1
	if (statusvalue)
d1407 3
a1409 3
	if (restartop) {
	    op = restartop;
	    restartop = 0;
d1412 1
a1412 1
	stack_sp = stack_base + oldmark;
d1417 1
a1417 1
	    *++stack_sp = &sv_undef;
d1422 5
a1426 5
    if (op == (OP*)&myop)
	op = pp_entereval();
    if (op)
	runops();
    retval = stack_sp - (stack_base + oldmark);
d1428 1
a1428 1
	sv_setpv(GvSV(errgv),"");
d1433 1
a1433 1
	stack_sp = stack_base + oldmark;
d1438 1
a1438 1
    op = oldop;
d1443 1
a1443 3
perl_eval_pv(p, croak_on_error)
char* p;
I32 croak_on_error;
d1448 1
a1448 1
    PUSHMARK(sp);
d1456 4
a1459 2
    if (croak_on_error && SvTRUE(GvSV(errgv)))
	croak(SvPVx(GvSV(errgv), na));
d1467 1
a1467 2
perl_require_pv(pv)
char* pv;
d1469 5
a1473 1
    SV* sv = sv_newmortal();
d1478 2
d1483 1
a1483 4
magicname(sym,name,namlen)
char *sym;
char *name;
I32 namlen;
d1491 3
a1493 3
static void
usage(name)		/* XXX move this out into a module ? */
char *name;
d1498 1
a1498 1
    static char *usage[] = {
d1518 1
a1518 1
"-v              print version number and patchlevel of perl",
d1525 1
a1525 1
    char **p = usage;
d1535 1
a1535 2
moreswitches(s)
char *s;
d1542 2
d1545 1
a1545 1
	SvREFCNT_dec(nrs);
d1547 1
a1547 1
	    nrs = &sv_undef;
d1549 1
a1549 1
	    nrs = newSVpv("", 0);
d1552 1
a1552 1
	    nrs = newSVpv(&ch, 1);
d1555 1
d1557 2
a1558 2
	minus_F = TRUE;
	splitstr = savepv(s + 1);
d1562 1
a1562 1
	minus_a = TRUE;
d1566 1
a1566 1
	minus_c = TRUE;
d1576 2
a1577 2
	if (!perldb) {
	    perldb = PERLDB_ALL;
d1585 1
a1585 1
	    static char debopts[] = "psltocPmfrxuLHXD";
d1589 1
a1589 1
		debug |= 1 << (d - debopts);
d1592 1
a1592 1
	    debug = atoi(s+1);
d1595 1
a1595 1
	debug |= 0x80000000;
d1603 2
a1604 2
	usage(origargv[0]);    
	exit(0);
d1606 3
a1608 3
	if (inplace)
	    Safefree(inplace);
	inplace = savepv(s+1);
d1610 2
a1611 2
	for (s = inplace; *s && !isSPACE(*s); s++) ;
	if (*s)
d1613 3
d1634 1
a1634 1
	minus_l = TRUE;
d1636 2
a1637 2
	if (ors)
	    Safefree(ors);
d1639 3
a1641 3
	    ors = savepv("\n");
	    orslen = 1;
	    *ors = scan_oct(s, 3 + (*s == '0'), &numlen);
d1645 4
a1648 3
	    if (RsPARA(nrs)) {
		ors = "\n\n";
		orslen = 2;
d1651 2
a1652 2
		ors = SvPV(nrs, orslen);
	    ors = savepvn(ors, orslen);
d1662 1
d1666 1
a1666 1
	    Sv = newSVpv(use,0);
d1671 1
a1671 1
		sv_catpv(Sv, start);
d1675 1
a1675 1
		    sv_catpv( Sv, " ()");
d1678 4
a1681 4
		sv_catpvn(Sv, start, s-start);
		sv_catpv(Sv, " split(/,/,q{");
		sv_catpv(Sv, ++s);
		sv_catpv(Sv,    "})");
d1684 3
a1686 3
	    if (preambleav == NULL)
		preambleav = newAV();
	    av_push(preambleav, Sv);
d1692 1
a1692 1
	minus_n = TRUE;
d1696 1
a1696 1
	minus_p = TRUE;
d1701 1
a1701 1
	doswitches = TRUE;
d1705 1
a1705 1
	if (!tainting)
d1710 1
a1710 1
	do_undump = TRUE;
d1714 1
a1714 1
	unsafe = TRUE;
d1723 1
a1723 1
		patchlevel, ARCHNAME);
d1731 1
a1731 1
	printf("\n\nCopyright 1987-1997, Larry Wall\n");
d1737 1
d1741 1
a1741 1
	    "Version 5 port Copyright (c) 1994-1997, Andreas Kaiser, Ilya Zakharevich\n");
d1746 18
d1766 5
a1770 2
GNU General Public License, which may be found in the Perl 5.0 source kit.\n\n");
	exit(0);
d1772 1
a1772 1
	dowarn = TRUE;
d1782 3
d1793 1
a1793 1
	if (preprocess)
d1805 1
d1808 1
a1808 1
my_unexec()
d1813 1
a1813 1
    int    status;
d1816 1
a1816 1
    prog = newSVpv(BIN_EXP);
d1818 1
a1818 1
    file = newSVpv(origfilename);
d1821 3
a1823 5
    status = unexec(SvPVX(file), SvPVX(prog), &etext, sbrk(0), 0);
    if (status)
	PerlIO_printf(PerlIO_stderr(), "unexec of %s into %s failed!\n",
		      SvPVX(prog), SvPVX(file));
    exit(status);
d1834 68
a1901 2
static void
init_main_stash()
d1903 1
d1909 6
a1914 4
    strtab = newHV();
    HvSHAREKEYS_off(strtab);			/* mandatory */
    Newz(506,((XPVHV*)SvANY(strtab))->xhv_array,
	 sizeof(HE*) * (((XPVHV*)SvANY(strtab))->xhv_max + 1), char);
d1916 2
a1917 2
    curstash = defstash = newHV();
    curstname = newSVpv("main",4);
d1920 1
a1920 1
    GvHV(gv) = (HV*)SvREFCNT_inc(defstash);
d1922 10
a1931 6
    HvNAME(defstash) = savepv("main");
    incgv = gv_HVadd(gv_AVadd(gv_fetchpv("INC",TRUE, SVt_PVAV)));
    GvMULTI_on(incgv);
    defgv = gv_fetchpv("_",TRUE, SVt_PVAV);
    errgv = gv_HVadd(gv_fetchpv("@@", TRUE, SVt_PV));
    GvMULTI_on(errgv);
d1933 6
a1938 5
    sv_grow(GvSV(errgv), 240);	/* Preallocate - for immediate signals. */
    sv_setpvn(GvSV(errgv), "", 0);
    curstash = defstash;
    compiling.cop_stash = defstash;
    debstash = GvHV(gv_fetchpv("DB::", GV_ADDMULTI, SVt_PVHV));
d1940 1
a1940 1
    sv_setpvn(GvSV(gv_fetchpv("/", TRUE, SVt_PV)), "\n", 1);
d1943 2
a1944 10
#ifdef CAN_PROTOTYPE
static void
open_script(char *scriptname, bool dosearch, SV *sv)
#else
static void
open_script(scriptname,dosearch,sv)
char *scriptname;
bool dosearch;
SV *sv;
#endif
d1946 1
a1946 2
    char *xfound = Nullch;
    char *xfailed = Nullch;
a1947 22
    I32 len;
    int retval;
#if defined(DOSISH) && !defined(OS2) && !defined(atarist)
#  define SEARCH_EXTS ".bat", ".cmd", NULL
#  define MAX_EXT_LEN 4
#endif
#ifdef OS2
#  define SEARCH_EXTS ".cmd", ".btm", ".bat", ".pl", NULL
#  define MAX_EXT_LEN 4
#endif
#ifdef VMS
#  define SEARCH_EXTS ".pl", ".com", NULL
#  define MAX_EXT_LEN 4
#endif
    /* additional extensions to try in each dir if scriptname not found */
#ifdef SEARCH_EXTS
    char *ext[] = { SEARCH_EXTS };
    int extidx = 0, i = 0;
    char *curext = Nullch;
#else
#  define MAX_EXT_LEN 0
#endif
d1949 1
a1949 18
    /*
     * If dosearch is true and if scriptname does not contain path
     * delimiters, search the PATH for scriptname.
     *
     * If SEARCH_EXTS is also defined, will look for each
     * scriptname{SEARCH_EXTS} whenever scriptname is not found
     * while searching the PATH.
     *
     * Assuming SEARCH_EXTS is C<".foo",".bar",NULL>, PATH search
     * proceeds as follows:
     *   If DOSISH:
     *     + look for ./scriptname{,.foo,.bar}
     *     + search the PATH for scriptname{,.foo,.bar}
     *
     *   If !DOSISH:
     *     + look *only* in the PATH for scriptname{,.foo,.bar} (note
     *       this will not look in '.' if it's not in the PATH)
     */
d1951 2
a1952 54
#ifdef VMS
    if (dosearch) {
	int hasdir, idx = 0, deftypes = 1;
	bool seen_dot = 1;

	hasdir = (strpbrk(scriptname,":[</") != Nullch) ;
	/* The first time through, just add SEARCH_EXTS to whatever we
	 * already have, so we can check for default file types. */
	while (deftypes ||
	       (!hasdir && my_trnlnm("DCL$PATH",tokenbuf,idx++)) )
	{
	    if (deftypes) {
		deftypes = 0;
		*tokenbuf = '\0';
	    }
	    if ((strlen(tokenbuf) + strlen(scriptname)
		 + MAX_EXT_LEN) >= sizeof tokenbuf)
		continue;	/* don't search dir with too-long name */
	    strcat(tokenbuf, scriptname);
#else  /* !VMS */

#ifdef DOSISH
    if (strEQ(scriptname, "-"))
 	dosearch = 0;
    if (dosearch) {		/* Look in '.' first. */
	char *cur = scriptname;
#ifdef SEARCH_EXTS
	if ((curext = strrchr(scriptname,'.')))	/* possible current ext */
	    while (ext[i])
		if (strEQ(ext[i++],curext)) {
		    extidx = -1;		/* already has an ext */
		    break;
		}
	do {
#endif
	    DEBUG_p(PerlIO_printf(Perl_debug_log,
				  "Looking for %s\n",cur));
	    if (Stat(cur,&statbuf) >= 0) {
		dosearch = 0;
		scriptname = cur;
#ifdef SEARCH_EXTS
		break;
#endif
	    }
#ifdef SEARCH_EXTS
	    if (cur == scriptname) {
		len = strlen(scriptname);
		if (len+MAX_EXT_LEN+1 >= sizeof(tokenbuf))
		    break;
		cur = strcpy(tokenbuf, scriptname);
	    }
	} while (extidx >= 0 && ext[extidx]	/* try an extension? */
		 && strcpy(tokenbuf+len, ext[extidx++]));
#endif
d1954 3
a1956 1
#endif
d1958 4
a1961 26
    if (dosearch && !strchr(scriptname, '/')
#ifdef DOSISH
		 && !strchr(scriptname, '\\')
#endif
		 && (s = getenv("PATH"))) {
	bool seen_dot = 0;
	
	bufend = s + strlen(s);
	while (s < bufend) {
#if defined(atarist) || defined(DOSISH)
	    for (len = 0; *s
#  ifdef atarist
		    && *s != ','
#  endif
		    && *s != ';'; len++, s++) {
		if (len < sizeof tokenbuf)
		    tokenbuf[len] = *s;
	    }
	    if (len < sizeof tokenbuf)
		tokenbuf[len] = '\0';
#else  /* ! (atarist || DOSISH) */
	    s = delimcpy(tokenbuf, tokenbuf + sizeof tokenbuf, s, bufend,
			':',
			&len);
#endif /* ! (atarist || DOSISH) */
	    if (s < bufend)
d1963 4
a1966 39
	    if (len + 1 + strlen(scriptname) + MAX_EXT_LEN >= sizeof tokenbuf)
		continue;	/* don't search dir with too-long name */
	    if (len
#if defined(atarist) || defined(DOSISH)
		&& tokenbuf[len - 1] != '/'
		&& tokenbuf[len - 1] != '\\'
#endif
	       )
		tokenbuf[len++] = '/';
	    if (len == 2 && tokenbuf[0] == '.')
		seen_dot = 1;
	    (void)strcpy(tokenbuf + len, scriptname);
#endif  /* !VMS */

#ifdef SEARCH_EXTS
	    len = strlen(tokenbuf);
	    if (extidx > 0)	/* reset after previous loop */
		extidx = 0;
	    do {
#endif
	    	DEBUG_p(PerlIO_printf(Perl_debug_log, "Looking for %s\n",tokenbuf));
		retval = Stat(tokenbuf,&statbuf);
#ifdef SEARCH_EXTS
	    } while (  retval < 0		/* not there */
		    && extidx>=0 && ext[extidx]	/* try an extension? */
		    && strcpy(tokenbuf+len, ext[extidx++])
		);
#endif
	    if (retval < 0)
		continue;
	    if (S_ISREG(statbuf.st_mode)
		&& cando(S_IRUSR,TRUE,&statbuf)
#ifndef DOSISH
		&& cando(S_IXUSR,TRUE,&statbuf)
#endif
		)
	    {
		xfound = tokenbuf;              /* bingo! */
		break;
a1967 2
	    if (!xfailed)
		xfailed = savepv(tokenbuf);
a1968 22
#ifndef DOSISH
	if (!xfound && !seen_dot && !xfailed && (Stat(scriptname,&statbuf) < 0))
#endif
	    seen_dot = 1;			/* Disable message. */
	if (!xfound)
	    croak("Can't %s %s%s%s",
		  (xfailed ? "execute" : "find"),
		  (xfailed ? xfailed : scriptname),
		  (xfailed ? "" : " on PATH"),
		  (xfailed || seen_dot) ? "" : ", '.' not in PATH");
	if (xfailed)
	    Safefree(xfailed);
	scriptname = xfound;
    }

    if (strnEQ(scriptname, "/dev/fd/", 8) && isDIGIT(scriptname[8]) ) {
	char *s = scriptname + 8;
	fdscript = atoi(s);
	while (isDIGIT(*s))
	    s++;
	if (*s)
	    scriptname = s + 1;
d1970 3
a1972 5
    else
	fdscript = -1;
    origfilename = savepv(e_tmpname ? "-e" : scriptname);
    curcop->cop_filegv = gv_fetchfile(origfilename);
    if (strEQ(origfilename,"-"))
d1974 2
a1975 2
    if (fdscript >= 0) {
	rsfp = PerlIO_fdopen(fdscript,"r");
d1977 2
a1978 2
	if (rsfp)
	    fcntl(PerlIO_fileno(rsfp),F_SETFD,1);  /* ensure close-on-exec */
d1981 1
a1981 1
    else if (preprocess) {
d1983 1
a1983 1
	SV *cpp = NEWSV(0,0);
d2007 1
a2007 1
	  (doextract ? "-e \"1,/^#/d\n\"" : ""),
d2027 1
a2027 1
	  (doextract ? "-e '1,/^#/d\n'" : ""),
d2030 1
a2030 1
	doextract = FALSE;
d2032 1
a2032 1
	if (euid != uid && !euid) {	/* if running suidperl */
d2034 1
a2034 1
	    (void)seteuid(uid);		/* musn't stay setuid root */
d2037 1
a2037 1
	    (void)setreuid((Uid_t)-1, uid);
d2040 1
a2040 1
	    (void)setresuid((Uid_t)-1, uid, (Uid_t)-1);
d2042 1
a2042 1
	    setuid(uid);
d2046 1
a2046 1
	    if (geteuid() != uid)
d2050 1
a2050 1
	rsfp = my_popen(SvPVX(cmd), "r");
d2056 1
a2056 1
	rsfp = PerlIO_stdin();
d2059 1
a2059 1
	rsfp = PerlIO_open(scriptname,"r");
d2061 2
a2062 2
	if (rsfp)
	    fcntl(PerlIO_fileno(rsfp),F_SETFD,1);  /* ensure close-on-exec */
d2065 1
a2065 4
    if (e_tmpname) {
	e_fp = rsfp;
    }
    if (!rsfp) {
d2068 4
a2071 2
	if (euid && Stat(SvPVX(GvSV(curcop->cop_filegv)),&statbuf) >= 0 &&
	  statbuf.st_mode & (S_ISUID|S_ISGID)) {
d2073 1
a2073 1
	    execv(form("%s/sperl%s", BIN_EXP, patchlevel), origargv);
d2079 1
a2079 1
	  SvPVX(GvSV(curcop->cop_filegv)), Strerror(errno));
d2083 67
a2149 4
static void
validate_suid(validarg, scriptname)
char *validarg;
char *scriptname;
d2174 1
d2177 3
a2179 3
    if (Fstat(PerlIO_fileno(rsfp),&statbuf) < 0)	/* normal stat is insecure */
	croak("Can't stat script \"%s\"",origfilename);
    if (fdscript < 0 && statbuf.st_mode & (S_ISUID|S_ISGID)) {
d2181 1
d2193 1
a2193 1
	if (access(SvPVX(GvSV(curcop->cop_filegv)),1))	/*double check*/
d2206 1
a2206 1
		setreuid(euid,uid) < 0
d2209 1
a2209 1
		setresuid(euid,uid,(Uid_t)-1) < 0
d2212 1
a2212 1
		|| getuid() != euid || geteuid() != uid)
d2214 1
a2214 1
	    if (Stat(SvPVX(GvSV(curcop->cop_filegv)),&tmpstatbuf) < 0)
d2216 9
a2224 5
	    if (tmpstatbuf.st_dev != statbuf.st_dev ||
		tmpstatbuf.st_ino != statbuf.st_ino) {
		(void)PerlIO_close(rsfp);
		if (rsfp = my_popen("/bin/mail root","w")) {	/* heh, heh */
		    PerlIO_printf(rsfp,
d2227 5
a2231 5
			(long)uid,(long)tmpstatbuf.st_dev, (long)tmpstatbuf.st_ino,
			(long)statbuf.st_dev, (long)statbuf.st_ino,
			SvPVX(GvSV(curcop->cop_filegv)),
			(long)statbuf.st_uid, (long)statbuf.st_gid);
		    (void)my_pclose(rsfp);
d2237 1
a2237 1
              setreuid(uid,euid) < 0
d2240 1
a2240 1
              setresuid(uid,euid,(Uid_t)-1) < 0
d2243 1
a2243 1
              || getuid() != uid || geteuid() != euid)
d2245 1
a2245 1
	    if (!cando(S_IXUSR,FALSE,&statbuf))		/* can real uid exec? */
d2251 1
a2251 1
	if (!S_ISREG(statbuf.st_mode))
d2253 1
a2253 1
	if (statbuf.st_mode & S_IWOTH)
d2255 4
a2258 4
	doswitches = FALSE;		/* -s is insecure in suid */
	curcop->cop_line++;
	if (sv_gets(linestr, rsfp, 0) == Nullch ||
	  strnNE(SvPV(linestr,na),"#!",2) )	/* required even on Sys V */
d2260 1
a2260 1
	s = SvPV(linestr,na)+2;
d2263 1
a2263 1
	for (s2 = s;  (s2 > SvPV(linestr,na)+2 &&
d2279 3
a2281 3
	if (euid != uid && (statbuf.st_mode & S_ISUID) &&
	    euid == statbuf.st_uid)
	    if (!do_undump)
d2286 2
a2287 2
	if (euid) {	/* oops, we're not the setuid root perl */
	    (void)PerlIO_close(rsfp);
d2290 1
a2290 1
	    execv(form("%s/sperl%s", BIN_EXP, patchlevel), origargv);
d2295 1
a2295 1
	if (statbuf.st_mode & S_ISGID && statbuf.st_gid != egid) {
d2297 1
a2297 1
	    (void)setegid(statbuf.st_gid);
d2300 1
a2300 1
           (void)setregid((Gid_t)-1,statbuf.st_gid);
d2303 1
a2303 1
           (void)setresgid((Gid_t)-1,statbuf.st_gid,(Gid_t)-1);
d2305 1
a2305 1
	    setgid(statbuf.st_gid);
d2309 1
a2309 1
	    if (getegid() != statbuf.st_gid)
d2312 2
a2313 2
	if (statbuf.st_mode & S_ISUID) {
	    if (statbuf.st_uid != euid)
d2315 1
a2315 1
		(void)seteuid(statbuf.st_uid);	/* all that for this */
d2318 1
a2318 1
                (void)setreuid((Uid_t)-1,statbuf.st_uid);
d2321 1
a2321 1
                (void)setresuid((Uid_t)-1,statbuf.st_uid,(Uid_t)-1);
d2323 1
a2323 1
		setuid(statbuf.st_uid);
d2327 1
a2327 1
	    if (geteuid() != statbuf.st_uid)
d2330 1
a2330 1
	else if (uid) {			/* oops, mustn't run as root */
d2332 1
a2332 1
          (void)seteuid((Uid_t)uid);
d2335 1
a2335 1
          (void)setreuid((Uid_t)-1,(Uid_t)uid);
d2338 1
a2338 1
          (void)setresuid((Uid_t)-1,(Uid_t)uid,(Uid_t)-1);
d2340 1
a2340 1
          setuid((Uid_t)uid);
d2344 1
a2344 1
	    if (geteuid() != uid)
d2348 1
a2348 1
	if (!cando(S_IXUSR,TRUE,&statbuf))
d2352 1
a2352 1
    else if (preprocess)
d2362 4
a2365 4
    PerlIO_rewind(rsfp);
    lseek(PerlIO_fileno(rsfp),(Off_t)0,0);  /* just in case rewind didn't */
    for (which = 1; origargv[which] && origargv[which] != scriptname; which++) ;
    if (!origargv[which])
d2367 2
a2368 2
    origargv[which] = savepv(form("/dev/fd/%d/%s",
				  PerlIO_fileno(rsfp), origargv[which]));
d2370 1
a2370 1
    fcntl(PerlIO_fileno(rsfp),F_SETFD,0);	/* ensure no close-on-exec */
d2372 1
a2372 1
    execv(form("%s/perl%s", BIN_EXP, patchlevel), origargv);	/* try again */
d2376 1
a2376 1
    if (euid != uid || egid != gid) {	/* (suidperl doesn't exist, in fact) */
d2378 3
a2380 2
	Fstat(PerlIO_fileno(rsfp),&statbuf);	/* may be either wrapped or real suid */
	if ((euid != uid && euid == statbuf.st_uid && statbuf.st_mode & S_ISUID)
d2382 1
a2382 1
	    (egid != gid && egid == statbuf.st_gid && statbuf.st_mode & S_ISGID)
d2384 1
a2384 1
	    if (!do_undump)
d2393 2
a2394 2
static void
find_beginning()
d2401 2
a2402 2
    while (doextract) {
	if ((s = sv_gets(linestr, rsfp, 0)) == Nullch)
d2405 2
a2406 2
	    PerlIO_ungetc(rsfp, '\n');		/* to keep line count right */
	    doextract = FALSE;
d2416 2
a2417 2
	    if (cddir && chdir(cddir) < 0)
		croak("Can't chdir to %s",cddir);
d2422 3
a2424 2
static void
init_ids()
d2426 4
a2429 4
    uid = (int)getuid();
    euid = (int)geteuid();
    gid = (int)getgid();
    egid = (int)getegid();
d2431 2
a2432 2
    uid |= gid << 16;
    euid |= egid << 16;
d2434 1
a2434 1
    tainting |= (uid && (euid != uid || egid != gid));
d2437 2
a2438 3
static void
forbid_setid(s)
char *s;
d2440 1
a2440 1
    if (euid != uid)
d2442 1
a2442 1
    if (egid != gid)
d2446 2
a2447 2
static void
init_debugger()
d2449 15
a2463 34
    curstash = debstash;
    dbargs = GvAV(gv_AVadd((gv_fetchpv("args", GV_ADDMULTI, SVt_PVAV))));
    AvREAL_off(dbargs);
    DBgv = gv_fetchpv("DB", GV_ADDMULTI, SVt_PVGV);
    DBline = gv_fetchpv("dbline", GV_ADDMULTI, SVt_PVAV);
    DBsub = gv_HVadd(gv_fetchpv("sub", GV_ADDMULTI, SVt_PVHV));
    DBsingle = GvSV((gv_fetchpv("single", GV_ADDMULTI, SVt_PV)));
    sv_setiv(DBsingle, 0); 
    DBtrace = GvSV((gv_fetchpv("trace", GV_ADDMULTI, SVt_PV)));
    sv_setiv(DBtrace, 0); 
    DBsignal = GvSV((gv_fetchpv("signal", GV_ADDMULTI, SVt_PV)));
    sv_setiv(DBsignal, 0); 
    curstash = defstash;
}

static void
init_stacks()
{
    curstack = newAV();
    mainstack = curstack;		/* remember in case we switch stacks */
    AvREAL_off(curstack);		/* not a real array */
    av_extend(curstack,127);

    stack_base = AvARRAY(curstack);
    stack_sp = stack_base;
    stack_max = stack_base + 127;

    cxstack_max = 8192 / sizeof(CONTEXT) - 2;	/* Use most of 8K. */
    New(50,cxstack,cxstack_max + 1,CONTEXT);
    cxstack_ix	= -1;

    New(50,tmps_stack,128,SV*);
    tmps_ix = -1;
    tmps_max = 128;
d2465 5
a2469 4
    DEBUG( {
	New(51,debname,128,char);
	New(52,debdelim,128,char);
    } )
d2471 2
a2472 40
    /*
     * The following stacks almost certainly should be per-interpreter,
     * but for now they're not.  XXX
     */

    if (markstack) {
	markstack_ptr = markstack;
    } else {
	New(54,markstack,64,I32);
	markstack_ptr = markstack;
	markstack_max = markstack + 64;
    }

    if (scopestack) {
	scopestack_ix = 0;
    } else {
	New(54,scopestack,32,I32);
	scopestack_ix = 0;
	scopestack_max = 32;
    }

    if (savestack) {
	savestack_ix = 0;
    } else {
	New(54,savestack,128,ANY);
	savestack_ix = 0;
	savestack_max = 128;
    }

    if (retstack) {
	retstack_ix = 0;
    } else {
	New(54,retstack,16,OP*);
	retstack_ix = 0;
	retstack_max = 16;
    }
}

static void
nuke_stacks()
d2474 55
a2528 2
    Safefree(cxstack);
    Safefree(tmps_stack);
d2530 2
a2531 2
	Safefree(debname);
	Safefree(debdelim);
d2535 1
d2537 1
d2539 2
a2540 2
static void
init_lexer()
d2542 8
a2549 5
    tmpfp = rsfp;
    rsfp = Nullfp;
    lex_start(linestr);
    rsfp = tmpfp;
    subname = newSVpv("main",4);
d2552 2
a2553 2
static void
init_predump_symbols()
d2555 1
d2559 4
a2562 5
    sv_setpvn(GvSV(gv_fetchpv("\"", TRUE, SVt_PV)), " ", 1);

    stdingv = gv_fetchpv("STDIN",TRUE, SVt_PVIO);
    GvMULTI_on(stdingv);
    IoIFP(GvIOp(stdingv)) = PerlIO_stdin();
d2565 1
a2565 1
    GvIOp(tmpgv) = (IO*)SvREFCNT_inc(GvIOp(stdingv));
d2573 1
a2573 1
    GvIOp(tmpgv) = (IO*)SvREFCNT_inc(GvIOp(defoutgv));
d2582 1
a2582 1
    statname = NEWSV(66,0);		/* last filename we did stat on */
d2584 2
a2585 2
    if (!osname)
	osname = savepv(OSNAME);
d2588 2
a2589 5
static void
init_postdump_symbols(argc,argv,env)
register int argc;
register char **argv;
register char **env;
d2591 1
d2597 1
a2597 1
    if (doswitches) {
d2613 7
a2619 7
    toptarget = NEWSV(0,0);
    sv_upgrade(toptarget, SVt_PVFM);
    sv_setpvn(toptarget, "", 0);
    bodytarget = NEWSV(0,0);
    sv_upgrade(bodytarget, SVt_PVFM);
    sv_setpvn(bodytarget, "", 0);
    formtarget = bodytarget;
d2623 1
a2623 1
	sv_setpv(GvSV(tmpgv),origfilename);
d2627 5
a2631 5
	sv_setpv(GvSV(tmpgv),origargv[0]);
    if (argvgv = gv_fetchpv("ARGV",TRUE, SVt_PVAV)) {
	GvMULTI_on(argvgv);
	(void)gv_AVadd(argvgv);
	av_clear(GvAVn(argvgv));
d2633 1
a2633 1
	    av_push(GvAVn(argvgv),newSVpv(argv[0],0));
d2636 1
a2636 1
    if (envgv = gv_fetchpv("ENV",TRUE, SVt_PVHV)) {
d2638 3
a2640 3
	GvMULTI_on(envgv);
	hv = GvHVn(envgv);
	hv_magic(hv, envgv, 'E');
d2655 1
a2655 1
#ifdef WIN32
d2663 1
a2663 1
	    (void)putenv(savepv(*env));
d2676 2
a2677 2
static void
init_perllib()
d2680 1
a2680 1
    if (!tainting) {
d2682 1
a2682 1
	s = getenv("PERL5LIB");
d2686 1
a2686 1
	    incpush(getenv("PERLLIB"), FALSE);
d2702 1
a2702 1
    ARCHLIB PRIVLIB SITEARCH SITELIB and OLDARCHLIB
d2705 1
a2705 1
    incpush(APPLLIB_EXP, FALSE);
d2714 3
d2718 1
d2724 3
a2728 2
#ifdef OLDARCHLIB_EXP  /* 5.00[01] compatibility */
    incpush(OLDARCHLIB_EXP, FALSE);
d2730 1
a2730 2
    
    if (!tainting)
d2747 2
a2748 4
static void
incpush(p, addsubdirs)
char *p;
int addsubdirs;
a2750 1
    static char *archpat_auto;
d2756 3
a2758 3
	subdir = newSV(0);
	if (!archpat_auto) {
	    STRLEN len = (sizeof(ARCHNAME) + strlen(patchlevel)
d2760 2
a2761 2
	    New(55, archpat_auto, len, char);
	    sprintf(archpat_auto, "/%s/%s/auto", ARCHNAME, patchlevel);
d2764 2
a2765 2
	     archpat_auto[len] != '\0' && archpat_auto[len] != '/'; len++)
		if (archpat_auto[len] == '.') archpat_auto[len] = '_';
d2772 1
a2772 1
	SV *libdir = newSV(0);
d2778 1
a2778 1
	    /* av_push(GvAVn(incgv), newSVpv(".", 1)); */
d2802 1
a2802 1
	    if ((unix = tounixspec_ts(SvPV(libdir,na),Nullch)) != Nullch) {
d2810 1
a2810 1
			      SvPV(libdir,na));
d2814 2
a2815 2
	    sv_catpv(subdir, archpat_auto);
	    if (Stat(SvPVX(subdir), &tmpstatbuf) >= 0 &&
d2817 1
a2817 1
		av_push(GvAVn(incgv),
d2822 2
a2823 2
		      strlen(patchlevel) + 1, "", 0);
	    if (Stat(SvPVX(subdir), &tmpstatbuf) >= 0 &&
d2825 1
a2825 1
		av_push(GvAVn(incgv),
d2830 1
a2830 1
	av_push(GvAVn(incgv), libdir);
d2832 48
d2881 21
a2901 1
    SvREFCNT_dec(subdir);
d2903 1
d2906 1
a2906 3
call_list(oldscope, list)
I32 oldscope;
AV* list;
d2908 2
a2909 1
    line_t oldline = curcop->cop_line;
d2914 2
a2915 2
    while (AvFILL(list) >= 0) {
	CV *cv = (CV*)av_shift(list);
d2922 2
a2923 2
		SV* atsv = GvSV(errgv);
		PUSHMARK(stack_sp);
d2928 3
a2930 3
		    curcop = &compiling;
		    curcop->cop_line = oldline;
		    if (list == beginav)
d2934 1
a2934 1
		    while (scopestack_ix > oldscope)
d2945 1
a2945 1
	    while (scopestack_ix > oldscope)
d2948 3
a2950 3
	    curstash = defstash;
	    if (endav)
		call_list(oldscope, endav);
d2952 4
a2955 4
	    curcop = &compiling;
	    curcop->cop_line = oldline;
	    if (statusvalue) {
		if (list == beginav)
d2963 1
a2963 1
	    if (!restartop) {
d2969 2
a2970 2
	    curcop = &compiling;
	    curcop->cop_line = oldline;
d2978 1
a2978 2
my_exit(status)
U32 status;
d2980 4
d2999 1
a2999 1
my_failure_exit()
d3013 1
d3016 7
a3022 2
    else if (STATUS_POSIX == 0)
	STATUS_POSIX_SET(255);
d3027 2
a3028 2
static void
my_exit_jump()
d3030 2
a3031 1
    register CONTEXT *cx;
d3035 3
a3037 8
    if (e_tmpname) {
	if (e_fp) {
	    PerlIO_close(e_fp);
	    e_fp = Nullfp;
	}
	(void)UNLINK(e_tmpname);
	Safefree(e_tmpname);
	e_tmpname = Nullch;
d3040 1
d3044 1
a3044 1
	POPBLOCK(cx,curpm);
d3050 28
@


1.2
log
@perl mktemp race; fix mailed to larry
@
text
@d3 1
a3 1
 *    Copyright (c) 1987-1996 Larry Wall
d18 1
a18 1
/* Omit -- it causes too much grief on mixed systems.
a21 1
*/
d23 5
a27 1
dEXT char rcsid[] = "perl.c\nPatch level: ###\n";
d41 24
d66 2
a67 1
static void incpush _((char *));
d76 2
d110 2
a111 1
	SvREADONLY_on(&sv_undef);
d113 8
a120 7
	sv_setpv(&sv_no,No);
	SvNV(&sv_no);
	SvREADONLY_on(&sv_no);

	sv_setpv(&sv_yes,Yes);
	SvNV(&sv_yes);
	SvREADONLY_on(&sv_yes);
d125 2
d139 5
a143 12
    chopset	= " \n-";
    copline	= NOLINE;
    curcop	= &compiling;
    dbargs	= 0;
    dlmax	= 128;
    laststatval	= -1;
    laststype	= OP_STAT;
    maxscream	= -1;
    maxsysfd	= MAXSYSFD;
    rsfp	= Nullfp;
    statname	= Nullsv;
    tmps_floor	= -1;
d147 1
d149 7
d157 3
a159 2
    sprintf(patchlevel, "%7.5f", 5.0 + (PATCHLEVEL / 1000.0)
				     + (SUBVERSION / 100000.0));
d161 2
a162 1
    sprintf(patchlevel, "%5.3f", 5.0 + (PATCHLEVEL / 1000.0));
d166 1
a166 1
    Ilocalpatches = local_patches;	/* For possible -v */
d169 2
a171 1
    pidstatus = newHV();/* for remembering status of dead pids */
d192 5
a196 2
	if (s = getenv("PERL_DESTRUCT_LEVEL"))
	    destruct_level = atoi(s);
d203 7
a209 7
    if (sv_objcount) {
	/* We must account for everything.  First the syntax tree. */
	if (main_root) {
	    curpad = AvARRAY(comppad);
	    op_free(main_root);
	    main_root = 0;
	}
d211 4
d226 8
d241 118
a358 1
    
d360 1
d368 2
a369 1
	    warn("Unbalanced scopes: %d more ENTERs than LEAVEs\n", scopestack_ix);
d371 2
a372 1
	    warn("Unbalanced saves: %d more saves than restores\n", savestack_ix);
d374 2
a375 1
	    warn("Unbalanced tmps: %d more allocs than frees\n", tmps_floor + 1);
d377 2
a378 1
	    warn("Unbalanced context: %d more PUSHes than POPs\n", cxstack_ix + 1);
d383 1
d388 33
d422 2
a423 1
	warn("Scalars leaked: %d\n", sv_count);
d425 8
d435 11
a455 3
#if !defined(STANDARD_C) && !defined(HAS_GETENV_PROTOTYPE)
char *getenv _((char *)); /* Usually in <stdlib.h> */
#endif
d470 1
d472 2
d486 5
d510 2
a511 1
    if (main_root)
d513 8
a520 1
    main_root = 0;
d522 2
a523 1
    switch (Sigsetjmp(top_env,1)) {
d525 2
a526 5
#ifdef VMS
	statusvalue = 255;
#else
	statusvalue = 1;
#endif
d528 4
d534 3
a536 2
	    calllist(endav);
	return(statusvalue);	/* my_exit() was called */
d538 2
a539 1
	fprintf(stderr, "panic: top_env\n");
d547 1
a573 1
	case 'T':
d582 5
d597 1
a597 1
		e_fp = fdopen(fd,"w");
d599 1
a599 1
		    close(fd);
d603 4
a606 2
	    if (argv[1]) {
		fputs(argv[1],e_fp);
d609 3
a611 1
	    (void)putc('\n', e_fp);
d613 4
a616 7
	case 'I':
	    taint_not("-I");
	    sv_catpv(sv,"-");
	    sv_catpv(sv,s);
	    sv_catpv(sv," ");
	    if (*++s) {
		av_push(GvAVn(incgv),newSVpv(s,0));
d618 9
a626 4
	    else if (argv[1]) {
		av_push(GvAVn(incgv),newSVpv(argv[1],0));
		sv_catpv(sv,argv[1]);
		argc--,argv++;
d628 2
a629 1
	    }
d632 1
a632 1
	    taint_not("-P");
d637 1
a637 1
	    taint_not("-S");
d646 42
a687 1
		Sv = newSVpv("print myconfig(),'@@INC: '.\"@@INC\\n\"",0);
a703 3
	case '-':
	    argc--,argv++;
	    goto switch_end;
d706 16
d723 1
a723 1
	    croak("Unrecognized switch: -%s",s);
d727 18
d748 4
a751 1
	if (Fflush(e_fp) || ferror(e_fp) || fclose(e_fp))
d753 1
d760 2
a761 2
	if ( isatty(fileno(stdin)) )
	    moreswitches("v");
d775 1
a775 1
    compcv = (CV*)NEWSV(1104,0);
d777 1
d779 1
a779 2
    pad = newAV();
    comppad = pad;
d782 1
a782 2
    padname = newAV();
    comppad_name = padname;
d793 1
d796 1
a796 1
#ifdef VMS
d840 1
a840 1
#ifdef DEBUGGING_MSTATS
d847 1
d855 4
d861 5
a865 1
    switch (Sigsetjmp(top_env,1)) {
d870 4
d876 2
a877 3
	    calllist(endav);
	FREETMPS;
#ifdef DEBUGGING_MSTATS
d881 2
a882 1
	return(statusvalue);		/* my_exit() was called */
d885 1
a885 1
	    fprintf(stderr, "panic: restartop\n");
d887 1
d890 1
a890 1
	if (stack != mainstack) {
d892 1
a892 1
	    SWITCHSTACK(stack, mainstack);
d897 3
d902 1
a902 1
	DEBUG(fprintf(stderr,"\nEXECUTING...\n\n"));
d905 1
a905 1
	    fprintf(stderr,"%s syntax OK\n", origfilename);
d908 1
a908 1
	if (perldb && DBsingle)
d920 1
d926 1
a929 18
void
my_exit(status)
U32 status;
{
    register CONTEXT *cx;
    I32 gimme;
    SV **newsp;

    statusvalue = FIXSTATUS(status);
    if (cxstack_ix >= 0) {
	if (cxstack_ix > 0)
	    dounwind(0);
	POPBLOCK(cx,curpm);
	LEAVE;
    }
    Siglongjmp(top_env, 2);
}

d973 2
a974 2
    if (create && !GvCV(gv))
    	return newSUB(start_subparse(),
d979 1
a979 1
	return GvCV(gv);
d1035 1
a1035 1
    I32 oldmark = TOPMARK;
a1036 1
    Sigjmp_buf oldtop;
d1038 6
a1043 1
    
d1049 7
d1058 1
a1058 1
    Zero(op, 1, LOGOP);
d1061 1
d1064 7
a1070 6
    if (!(flags & G_NOARGS))
	myop.op_flags = OPf_STACKED;
    myop.op_next = Nullop;
    myop.op_flags |= OPf_KNOW;
    if (flags & G_ARRAY)
      myop.op_flags |= OPf_LIST;
a1072 2
	Copy(top_env, oldtop, 1, Sigjmp_buf);

d1078 1
a1078 1
	    I32 gimme = GIMME;
d1096 2
a1097 2
    restart:
	switch (Sigsetjmp(top_env,1)) {
d1101 1
a1101 5
#ifdef VMS
	    statusvalue = 255;	/* XXX I don't think we use 1 anymore. */
#else
	statusvalue = 1;
#endif
d1107 1
a1107 1
	    Copy(oldtop, top_env, 1, Sigjmp_buf);
d1110 1
a1110 1
	    my_exit(statusvalue);
d1116 1
a1116 1
		goto restart;
d1128 2
d1154 1
a1154 1
	Copy(oldtop, top_env, 1, Sigjmp_buf);
d1156 3
d1165 1
d1169 1
a1169 1
/* Eval a string. */
a1179 1
    Sigjmp_buf oldtop;
d1181 4
a1184 1
    
d1200 6
a1205 5
    myop.op_flags |= OPf_KNOW;
    if (flags & G_ARRAY)
      myop.op_flags |= OPf_LIST;

    Copy(top_env, oldtop, 1, Sigjmp_buf);
d1207 2
a1208 2
restart:
    switch (Sigsetjmp(top_env,1)) {
d1212 1
a1212 5
#ifdef VMS
	statusvalue = 255;	/* XXX I don't think we use 1 anymore. */
#else
    statusvalue = 1;
#endif
d1218 1
a1218 1
	Copy(oldtop, top_env, 1, Sigjmp_buf);
d1221 1
a1221 1
	my_exit(statusvalue);
d1227 1
a1227 1
	    goto restart;
d1244 1
a1244 1
    if ((flags & G_EVAL) && !(flags & G_KEEPERR))
d1248 1
a1248 1
    Copy(oldtop, top_env, 1, Sigjmp_buf);
d1255 1
d1259 22
a1305 37
#if defined(DOSISH)
#    define PERLLIB_SEP ';'
#else
#  if defined(VMS)
#    define PERLLIB_SEP '|'
#  else
#    define PERLLIB_SEP ':'
#  endif
#endif

static void
incpush(p)
char *p;
{
    char *s;

    if (!p)
	return;

    /* Break at all separators */
    while (*p) {
	/* First, skip any consecutive separators */
	while ( *p == PERLLIB_SEP ) {
	    /* Uncomment the next line for PATH semantics */
	    /* av_push(GvAVn(incgv), newSVpv(".", 1)); */
	    p++;
	}
	if ( (s = strchr(p, PERLLIB_SEP)) != Nullch ) {
	    av_push(GvAVn(incgv), newSVpv(p, (STRLEN)(s - p)));
	    p = s + 1;
	} else {
	    av_push(GvAVn(incgv), newSVpv(p, 0));
	    break;
	}
    }
}

d1312 30
d1343 2
a1344 26
    printf("\n  -0[octal]       specify record separator (\\0, if no argument)");
    printf("\n  -a              autosplit mode with -n or -p (splits $_ into @@F)");
    printf("\n  -c              check syntax only (runs BEGIN and END blocks)");
    printf("\n  -d[:debugger]   run scripts under debugger");
    printf("\n  -D[number/list] set debugging flags (argument is a bit mask or flags)");
    printf("\n  -e 'command'    one line of script. Several -e's allowed. Omit [programfile].");
    printf("\n  -F/pattern/     split() pattern for autosplit (-a). The //'s are optional.");
    printf("\n  -i[extension]   edit <> files in place (make backup if extension supplied)");
    printf("\n  -Idirectory     specify @@INC/#include directory (may be used more then once)");
    printf("\n  -l[octal]       enable line ending processing, specifies line teminator");
    printf("\n  -[mM][-]module.. executes `use/no module...' before executing your script.");
    printf("\n  -n              assume 'while (<>) { ... }' loop arround your script");
    printf("\n  -p              assume loop like -n but print line also like sed");
    printf("\n  -P              run script through C preprocessor before compilation");
#ifdef OS2
    printf("\n  -R              enable REXX variable pool");
#endif      
    printf("\n  -s              enable some switch parsing for switches after script name");
    printf("\n  -S              look for the script using PATH environment variable");
    printf("\n  -T              turn on tainting checks");
    printf("\n  -u              dump core after parsing script");
    printf("\n  -U              allow unsafe operations");
    printf("\n  -v              print version number and patchlevel of perl");
    printf("\n  -V[:variable]   print perl configuration information");
    printf("\n  -w              TURN WARNINGS ON FOR COMPILATION OF YOUR SCRIPT.");
    printf("\n  -x[directory]   strip off text before #!perl line and perhaps cd to directory\n");
d1383 1
a1383 1
	taint_not("-d");
d1386 1
a1386 1
	    sprintf(buf, "use Devel::%s;", ++s);
a1387 1
	    my_setenv("PERL5DB",buf);
d1390 1
a1390 1
	    perldb = TRUE;
d1396 1
a1396 1
	taint_not("-D");
d1424 10
a1433 6
	*s = '\0';
	break;
    case 'I':
	taint_not("-I");
	if (*++s) {
	    char *e;
d1435 4
a1438 3
	    av_push(GvAVn(incgv),newSVpv(s,e-s));
	    if (*e)
		return e;
d1442 1
a1442 1
	break;
d1456 1
a1456 1
		ors = savepvn("\n\n", 2);
d1461 1
d1465 1
a1465 1
	taint_not("-M");	/* XXX ? */
d1468 1
a1468 1
	taint_not("-m");	/* XXX ? */
d1508 1
a1508 1
	taint_not("-s");
d1513 2
a1514 1
	tainting = TRUE;
d1527 2
a1528 1
	printf("\nThis is perl, version 5.%03d_%02d", PATCHLEVEL, SUBVERSION);
d1530 2
a1531 13
	printf("\nThis is perl, version %s",patchlevel);
#endif

#if defined(DEBUGGING) || defined(EMBED) || defined(MULTIPLICITY)
	fputs(" with", stdout);
#ifdef DEBUGGING
	fputs(" DEBUGGING", stdout);
#endif
#ifdef EMBED
	fputs(" EMBED", stdout);
#endif
#ifdef MULTIPLICITY
	fputs(" MULTIPLICITY", stdout);
d1533 4
d1539 3
a1541 9
#if defined(LOCAL_PATCH_COUNT)
    if (LOCAL_PATCH_COUNT > 0)
    {	int i;
	fputs("\n\tLocally applied patches:\n", stdout);
	for (i = 1; i <= LOCAL_PATCH_COUNT; i++) {
		if (Ilocalpatches[i])
			fprintf(stdout, "\t  %s\n", Ilocalpatches[i]);
	}
    }
d1543 2
a1544 13
    printf("\n\tbuilt under %s",OSNAME);
#ifdef __DATE__
#  ifdef __TIME__
	printf(" at %s %s",__DATE__,__TIME__);
#  else
	printf(" on %s",__DATE__);
#  endif
#endif
	fputs("\n\t+ suidperl security patch", stdout);
	fputs("\n\nCopyright 1987-1996, Larry Wall\n",stdout);
#ifdef MSDOS
	fputs("MS-DOS port Copyright (c) 1989, 1990, Diomidis Spinellis\n",
	stdout);
d1547 2
a1548 2
	fputs("OS/2 port Copyright (c) 1990, 1991, Raymond Chen, Kai Uwe Rommel\n"
	    "Version 5 port Copyright (c) 1994-1995, Andreas Kaiser\n", stdout);
d1551 1
a1551 1
	fputs("atariST series port, ++jrb  bammi@@cadence.com\n", stdout);
d1553 1
a1553 1
	fputs("\n\
d1555 1
a1555 4
GNU General Public License, which may be found in the Perl 5.0 source kit.\n\n",stdout);
#ifdef MSDOS
        usage(origargv[0]);
#endif
d1571 4
d1593 2
d1598 4
a1601 2
    sprintf (buf, "%s.perldump", origfilename);
    sprintf (tokenbuf, "%s/perl", BIN);
d1603 1
a1603 1
    status = unexec(buf, tokenbuf, &etext, sbrk(0), 0);
d1605 2
a1606 1
	fprintf(stderr, "unexec of %s into %s failed!\n", tokenbuf, buf);
d1612 1
a1612 1
#else
d1614 1
a1614 1
#endif
d1622 9
d1643 3
d1670 6
a1675 1
#define SEARCH_EXTS ".bat", ".cmd", NULL
d1679 1
d1684 4
a1687 1
    int extidx = (strchr(scriptname,'.')) ? -1 : 0; /* has ext already */
d1690 19
d1710 18
a1727 5
    if (dosearch && !strpbrk(scriptname,":[</") && (my_getenv("DCL$PATH"))) {
	int idx = 0;

	while (my_trnlnm("DCL$PATH",tokenbuf,idx++)) {
	    strcat(tokenbuf,scriptname);
a1728 1
    if (dosearch && !strchr(scriptname, '/') && (s = getenv("PATH"))) {
d1730 21
a1750 11
	bufend = s + strlen(s);
	while (*s) {
#ifndef DOSISH
	    s = cpytill(tokenbuf,s,bufend,':',&len);
#else
#ifdef atarist
	    for (len = 0; *s && *s != ',' && *s != ';'; tokenbuf[len++] = *s++);
	    tokenbuf[len] = '\0';
#else
	    for (len = 0; *s && *s != ';'; tokenbuf[len++] = *s++);
	    tokenbuf[len] = '\0';
d1752 10
d1763 1
a1763 9
	    if (*s)
		s++;
#ifndef DOSISH
	    if (len && tokenbuf[len-1] != '/')
#else
#ifdef atarist
	    if (len && ((tokenbuf[len-1] != '\\') && (tokenbuf[len-1] != '/')))
#else
	    if (len && tokenbuf[len-1] != '\\')
d1765 4
d1770 35
a1804 2
		(void)strcat(tokenbuf+len,"/");
	    (void)strcat(tokenbuf+len,scriptname);
d1813 1
a1813 1
		DEBUG_p(fprintf(stderr,"Looking for %s\n",tokenbuf));
d1824 6
a1829 1
	     && cando(S_IRUSR,TRUE,&statbuf) && cando(S_IXUSR,TRUE,&statbuf)) {
d1836 4
d1841 5
a1845 1
	    croak("Can't execute %s", xfailed ? xfailed : scriptname );
d1866 1
a1866 1
	rsfp = fdopen(fdscript,"r");
d1868 2
a1869 1
	fcntl(fileno(rsfp),F_SETFD,1);	/* ensure close-on-exec */
d1873 7
a1879 1
	char *cpp = CPPSTDIN;
a1880 4
	if (strEQ(cpp,"cppstdin"))
	    sprintf(tokenbuf, "%s/%s", SCRIPTDIR, cpp);
	else
	    sprintf(tokenbuf, "%s", cpp);
d1883 1
d1885 1
a1885 1
	(void)sprintf(buf, "\
d1897 1
a1897 1
 %s | %s -C %s %s",
d1900 1
a1900 1
	(void)sprintf(buf, "\
d1912 1
a1912 1
 %s | %s -C %s %s",
d1920 1
a1920 1
	  scriptname, tokenbuf, SvPV(sv, na), CPPMINUS);
d1941 3
a1943 1
	rsfp = my_popen(buf,"r");
d1946 2
a1947 2
	taint_not("program input from stdin");
	rsfp = stdin;
d1950 1
a1950 1
	rsfp = fopen(scriptname,"r");
d1952 2
a1953 1
	fcntl(fileno(rsfp),F_SETFD,1);	/* ensure close-on-exec */
d1956 4
a1959 1
    if ((FILE*)rsfp == Nullfp) {
d1964 2
a1965 2
	    (void)sprintf(buf, "%s/sperl%s", BIN, patchlevel);
	    execv(buf, origargv);	/* try again */
d2003 1
a2003 1
    char *s;
d2005 1
a2005 1
    if (Fstat(fileno(rsfp),&statbuf) < 0)	/* normal stat is insecure */
d2045 1
a2045 1
		(void)fclose(rsfp);
d2047 5
a2051 5
		    fprintf(rsfp,
"User %d tried to run dev %d ino %d in place of dev %d ino %d!\n\
(Filename of set-id script was %s, uid %d gid %d.)\n\nSincerely,\nperl\n",
			uid,tmpstatbuf.st_dev, tmpstatbuf.st_ino,
			statbuf.st_dev, statbuf.st_ino,
d2053 1
a2053 1
			statbuf.st_uid, statbuf.st_gid);
d2080 2
a2081 2
	if (fgets(tokenbuf,sizeof tokenbuf, rsfp) == Nullch ||
	  strnNE(tokenbuf,"#!",2) )	/* required even on Sys V */
d2083 1
a2083 1
	s = tokenbuf+2;
d2086 3
a2088 1
	if (strnNE(s-4,"perl",4) && strnNE(s-9,"perl",4))  /* sanity check */
d2110 1
a2110 1
	    (void)fclose(rsfp);
d2112 2
a2113 2
	    (void)sprintf(buf, "%s/sperl%s", BIN, patchlevel);
	    execv(buf, origargv);	/* try again */
d2185 2
a2186 1
    rewind(rsfp);
d2190 2
a2191 3
    (void)sprintf(buf, "/dev/fd/%d/%.127s", fileno(rsfp), origargv[which]);
    origargv[which] = buf;

d2193 1
a2193 1
    fcntl(fileno(rsfp),F_SETFD,0);	/* ensure no close-on-exec */
d2195 1
a2195 3

    (void)sprintf(tokenbuf, "%s/perl%s", BIN, patchlevel);
    execv(tokenbuf, origargv);	/* try again */
d2201 1
a2201 1
	Fstat(fileno(rsfp),&statbuf);	/* may be either wrapped or real suid */
d2218 1
a2218 1
    register char *s;
d2222 1
a2222 1
    taint_not("-x");
d2226 2
a2227 2
	if (*s == '#' && s[1] == '!' && instr(s,"perl")) {
	    ungetc('\n',rsfp);		/* to keep line count right */
d2229 8
a2236 4
	    if (s = instr(s,"perl -")) {
		s += 6;
		/*SUPPRESS 530*/
		while (s = moreswitches(s)) ;
d2259 10
d2289 4
a2292 4
    stack = newAV();
    mainstack = stack;			/* remember in case we switch stacks */
    AvREAL_off(stack);			/* not a real array */
    av_extend(stack,127);
d2294 1
a2294 1
    stack_base = AvARRAY(stack);
a2297 16
    New(54,markstack,64,I32);
    markstack_ptr = markstack;
    markstack_max = markstack + 64;

    New(54,scopestack,32,I32);
    scopestack_ix = 0;
    scopestack_max = 32;

    New(54,savestack,128,ANY);
    savestack_ix = 0;
    savestack_max = 128;

    New(54,retstack,16,OP*);
    retstack_ix = 0;
    retstack_max = 16;

d2310 48
d2360 2
a2361 1
static FILE *tmpfp;  /* moved outside init_lexer() because of UNICOS bug */
d2366 1
a2366 1

d2382 1
a2382 1
    IoIFP(GvIOp(stdingv)) = stdin;
d2389 1
a2389 1
    IoOFP(GvIOp(tmpgv)) = IoIFP(GvIOp(tmpgv)) = stdout;
d2397 1
a2397 1
    IoOFP(GvIOp(othergv)) = IoIFP(GvIOp(othergv)) = stderr;
d2404 2
a2405 1
    osname = savepv(OSNAME);
d2443 1
a2443 1
    tainted = 1;
a2447 2
    if (tmpgv = gv_fetchpv("\024",TRUE, SVt_PV))
	time(&basetime);
d2462 1
a2462 1
	hv_clear(hv);
d2471 1
a2471 1
	if (env != environ) {
a2472 2
	    hv_magic(hv, envgv, 'E');
	}
d2477 3
a2480 1
	    sv_magic(sv, sv, 'e', *env, s - *env);
d2483 4
a2491 1
	hv_magic(hv, envgv, 'E');
d2493 1
a2493 1
    tainted = 0;
d2495 1
a2495 2
	sv_setiv(GvSV(tmpgv),(I32)getpid());

d2503 1
d2506 12
a2517 1
	    incpush(s);
d2519 2
a2520 1
	    incpush(getenv("PERLLIB"));
d2523 3
d2527 1
a2527 1
    incpush(APPLLIB_EXP);
d2531 1
a2531 1
    incpush(ARCHLIB_EXP);
d2536 1
a2536 1
    incpush(PRIVLIB_EXP);
d2539 1
a2539 1
    incpush(SITEARCH_EXP);
d2542 1
a2542 1
    incpush(SITELIB_EXP);
d2545 1
a2545 1
    incpush(OLDARCHLIB_EXP);
d2549 106
a2654 1
	incpush(".");
d2658 2
a2659 1
calllist(list)
d2662 1
a2662 1
    Sigjmp_buf oldtop;
d2664 2
a2665 3
    line_t oldline = curcop->cop_line;

    Copy(top_env, oldtop, 1, Sigjmp_buf);
d2672 2
a2673 1
	switch (Sigsetjmp(top_env,1)) {
d2680 1
a2680 1
		    Copy(oldtop, top_env, 1, Sigjmp_buf);
d2687 2
d2694 1
a2694 5
#ifdef VMS
	    statusvalue = 255;	/* XXX I don't think we use 1 anymore. */
#else
	statusvalue = 1;
#endif
d2698 3
d2703 2
a2704 3
		calllist(endav);
	    FREETMPS;
	    Copy(oldtop, top_env, 1, Sigjmp_buf);
d2713 1
a2713 1
	    my_exit(statusvalue);
a2714 1
	    return;
d2717 1
a2717 1
		fprintf(stderr, "panic: restartop\n");
d2721 1
a2721 1
	    Copy(oldtop, top_env, 1, Sigjmp_buf);
d2724 1
a2724 1
	    Siglongjmp(top_env, 3);
d2726 18
d2745 2
d2748 21
a2768 1
    Copy(oldtop, top_env, 1, Sigjmp_buf);
d2771 26
@


1.1
log
@Initial revision
@
text
@d340 2
d343 6
a348 5
		(void)mktemp(e_tmpname);
		if (!*e_tmpname)
		    croak("Can't mktemp()");
		e_fp = fopen(e_tmpname,"w");
		if (!e_fp)
d350 1
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d3 1
a3 1
 *    Copyright (c) 1987-1999 Larry Wall
d18 1
a18 1
/* XXX If this causes problems, set i_unistd=undef in the hint file.  */
d22 1
d24 1
a24 10
#if !defined(STANDARD_C) && !defined(HAS_GETENV_PROTOTYPE)
char *getenv _((char *)); /* Usually in <stdlib.h> */
#endif

#ifdef I_FCNTL
#include <fcntl.h>
#endif
#ifdef I_SYS_FILE
#include <sys/file.h>
#endif
a37 3
#ifdef PERL_OBJECT
static I32 read_e_script _((CPerlObj* pPerl, int idx, SV *buf_sv, int maxlen));
#else
d39 1
a39 3
static void forbid_setid _((char *));
static void incpush _((char *, int));
static void init_interp _((void));
a43 3
#ifdef USE_THREADS
static struct perl_thread * init_main_thread _((void));
#endif /* USE_THREADS */
d47 2
a48 3
static void my_exit_jump _((void)) __attribute__((noreturn));
static void nuke_stacks _((void));
static void open_script _((char *, bool, SV *, int *fd));
d50 1
a50 6
#ifdef IAMSUID
static int  fd_on_nosuid_fs _((int));
#endif
static void validate_suid _((char *, char*, int));
static I32 read_e_script _((int idx, SV *buf_sv, int maxlen));
#endif
d52 1
a52 7
#ifdef PERL_OBJECT
CPerlObj* perl_alloc(IPerlMem* ipM, IPerlEnv* ipE, IPerlStdIO* ipStd,
					     IPerlLIO* ipLIO, IPerlDir* ipD, IPerlSock* ipS, IPerlProc* ipP)
{
    CPerlObj* pPerl = new(ipM) CPerlObj(ipM, ipE, ipStd, ipLIO, ipD, ipS, ipP);
    if(pPerl != NULL)
	pPerl->Init();
a53 3
    return pPerl;
}
#else
d55 1
a55 1
perl_alloc(void)
d59 1
a59 1
    PL_curinterp = 0;
a62 1
#endif /* PERL_OBJECT */
d65 2
a66 5
#ifdef PERL_OBJECT
CPerlObj::perl_construct(void)
#else
perl_construct(register PerlInterpreter *sv_interp)
#endif
d68 1
a68 9
#ifdef USE_THREADS
    int i;
#ifndef FAKE_THREADS
    struct perl_thread *thr;
#endif /* FAKE_THREADS */
#endif /* USE_THREADS */
    
#ifndef PERL_OBJECT
    if (!(PL_curinterp = sv_interp))
a69 1
#endif
a71 1
    ++PL_ninterps;
d75 17
a91 56
   /* Init the real globals (and main thread)? */
    if (!PL_linestr) {
#ifdef USE_THREADS

    	INIT_THREADS;
#ifdef ALLOC_THREAD_KEY
        ALLOC_THREAD_KEY;
#else
	if (pthread_key_create(&PL_thr_key, 0))
	    croak("panic: pthread_key_create");
#endif
	MUTEX_INIT(&PL_sv_mutex);
	MUTEX_INIT(&PL_cred_mutex);
	/*
	 * Safe to use basic SV functions from now on (though
	 * not things like mortals or tainting yet).
	 */
	MUTEX_INIT(&PL_eval_mutex);
	COND_INIT(&PL_eval_cond);
	MUTEX_INIT(&PL_threads_mutex);
	COND_INIT(&PL_nthreads_cond);
#ifdef EMULATE_ATOMIC_REFCOUNTS
	MUTEX_INIT(&PL_svref_mutex);
#endif /* EMULATE_ATOMIC_REFCOUNTS */
	
	thr = init_main_thread();
#endif /* USE_THREADS */

	PL_linestr = NEWSV(65,79);
	sv_upgrade(PL_linestr,SVt_PVIV);

	if (!SvREADONLY(&PL_sv_undef)) {
	    /* set read-only and try to insure than we wont see REFCNT==0
	       very often */

	    SvREADONLY_on(&PL_sv_undef);
	    SvREFCNT(&PL_sv_undef) = (~(U32)0)/2;

	    sv_setpv(&PL_sv_no,PL_No);
	    SvNV(&PL_sv_no);
	    SvREADONLY_on(&PL_sv_no);
	    SvREFCNT(&PL_sv_no) = (~(U32)0)/2;

	    sv_setpv(&PL_sv_yes,PL_Yes);
	    SvNV(&PL_sv_yes);
	    SvREADONLY_on(&PL_sv_yes);
	    SvREFCNT(&PL_sv_yes) = (~(U32)0)/2;
	}

#ifdef PERL_OBJECT
	/* TODO: */
	/* PL_sighandlerp = sighandler; */
#else
	PL_sighandlerp = sighandler;
#endif
	PL_pidstatus = newHV();
a103 4
    PL_nrs = newSVpv("\n", 1);
    PL_rs = SvREFCNT_inc(PL_nrs);

    init_stacks(ARGS);
d105 12
a116 5
    init_interp();
    PL_perl_destruct_level = 1; 
#else
   if (PL_perl_destruct_level > 0)
       init_interp();
a119 7
    PL_lex_state = LEX_NOTPARSING;

    PL_start_env.je_prev = NULL;
    PL_start_env.je_ret = -1;
    PL_start_env.je_mustcatch = TRUE;
    PL_top_env     = &PL_start_env;
    STATUS_ALL_SUCCESS;
a120 1
    SET_NUMERIC_STANDARD();
d122 2
a123 3
    sprintf(PL_patchlevel, "%7.5f",   (double) 5 
				+ ((double) PATCHLEVEL / (double) 1000)
				+ ((double) SUBVERSION / (double) 100000));
d125 1
a125 2
    sprintf(PL_patchlevel, "%5.3f", (double) 5 +
				((double) PATCHLEVEL / (double) 1000));
d129 1
a129 1
    PL_localpatches = local_patches;	/* For possible -v */
d132 2
a133 9
    PerlIO_init();			/* Hook to IO system */

    PL_fdpid = newAV();			/* for remembering popen pids by fd */
    PL_modglobal = newHV();		/* pointers to per-interpreter module globals */

    DEBUG( {
	New(51,PL_debname,128,char);
	New(52,PL_debdelim,128,char);
    } )
d135 1
d140 2
a141 5
#ifdef PERL_OBJECT
CPerlObj::perl_destruct(void)
#else
perl_destruct(register PerlInterpreter *sv_interp)
#endif
a142 1
    dTHR;
a145 3
#ifdef USE_THREADS
    Thread t;
#endif /* USE_THREADS */
d147 1
a147 2
#ifndef PERL_OBJECT
    if (!(PL_curinterp = sv_interp))
a148 55
#endif

#ifdef USE_THREADS
#ifndef FAKE_THREADS
    /* Pass 1 on any remaining threads: detach joinables, join zombies */
  retry_cleanup:
    MUTEX_LOCK(&PL_threads_mutex);
    DEBUG_S(PerlIO_printf(PerlIO_stderr(),
			  "perl_destruct: waiting for %d threads...\n",
			  PL_nthreads - 1));
    for (t = thr->next; t != thr; t = t->next) {
	MUTEX_LOCK(&t->mutex);
	switch (ThrSTATE(t)) {
	    AV *av;
	case THRf_ZOMBIE:
	    DEBUG_S(PerlIO_printf(PerlIO_stderr(),
				  "perl_destruct: joining zombie %p\n", t));
	    ThrSETSTATE(t, THRf_DEAD);
	    MUTEX_UNLOCK(&t->mutex);
	    PL_nthreads--;
	    /*
	     * The SvREFCNT_dec below may take a long time (e.g. av
	     * may contain an object scalar whose destructor gets
	     * called) so we have to unlock threads_mutex and start
	     * all over again.
	     */
	    MUTEX_UNLOCK(&PL_threads_mutex);
	    JOIN(t, &av);
	    SvREFCNT_dec((SV*)av);
	    DEBUG_S(PerlIO_printf(PerlIO_stderr(),
				  "perl_destruct: joined zombie %p OK\n", t));
	    goto retry_cleanup;
	case THRf_R_JOINABLE:
	    DEBUG_S(PerlIO_printf(PerlIO_stderr(),
				  "perl_destruct: detaching thread %p\n", t));
	    ThrSETSTATE(t, THRf_R_DETACHED);
	    /* 
	     * We unlock threads_mutex and t->mutex in the opposite order
	     * from which we locked them just so that DETACH won't
	     * deadlock if it panics. It's only a breach of good style
	     * not a bug since they are unlocks not locks.
	     */
	    MUTEX_UNLOCK(&PL_threads_mutex);
	    DETACH(t);
	    MUTEX_UNLOCK(&t->mutex);
	    goto retry_cleanup;
	default:
	    DEBUG_S(PerlIO_printf(PerlIO_stderr(),
				  "perl_destruct: ignoring %p (state %u)\n",
				  t, ThrSTATE(t)));
	    MUTEX_UNLOCK(&t->mutex);
	    /* fall through and out */
	}
    }
    /* We leave the above "Pass 1" loop with threads_mutex still locked */
d150 1
a150 17
    /* Pass 2 on remaining threads: wait for the thread count to drop to one */
    while (PL_nthreads > 1)
    {
	DEBUG_S(PerlIO_printf(PerlIO_stderr(),
			      "perl_destruct: final wait for %d threads\n",
			      PL_nthreads - 1));
	COND_WAIT(&PL_nthreads_cond, &PL_threads_mutex);
    }
    /* At this point, we're the last thread */
    MUTEX_UNLOCK(&PL_threads_mutex);
    DEBUG_S(PerlIO_printf(PerlIO_stderr(), "perl_destruct: armageddon has arrived\n"));
    MUTEX_DESTROY(&PL_threads_mutex);
    COND_DESTROY(&PL_nthreads_cond);
#endif /* !defined(FAKE_THREADS) */
#endif /* USE_THREADS */

    destruct_level = PL_perl_destruct_level;
d154 2
a155 5
	if (s = PerlEnv_getenv("PERL_DESTRUCT_LEVEL")) {
	    int i = atoi(s);
	    if (destruct_level < i)
		destruct_level = i;
	}
d162 7
a168 11
#ifdef MULTIPLICITY
    --PL_ninterps;
#endif

    /* We must account for everything.  */

    /* Destroy the main CV and syntax tree */
    if (PL_main_root) {
	PL_curpad = AvARRAY(PL_comppad);
	op_free(PL_main_root);
	PL_main_root = Nullop;
d170 1
a170 6
    PL_curcop = &PL_compiling;
    PL_main_start = Nullop;
    SvREFCNT_dec(PL_main_cv);
    PL_main_cv = Nullcv;

    if (PL_sv_objcount) {
d177 1
a177 1
	PL_dirty = TRUE;
a180 14
    /* unhook hooks which will soon be, or use, destroyed data */
    SvREFCNT_dec(PL_warnhook);
    PL_warnhook = Nullsv;
    SvREFCNT_dec(PL_diehook);
    PL_diehook = Nullsv;
    SvREFCNT_dec(PL_parsehook);
    PL_parsehook = Nullsv;

    /* call exit list functions */
    while (PL_exitlistlen-- > 0)
	PL_exitlist[PL_exitlistlen].fn(PERL_OBJECT_THIS_ PL_exitlist[PL_exitlistlen].ptr);

    Safefree(PL_exitlist);

d188 1
a188 88

    /* loosen bonds of global variables */

    if(PL_rsfp) {
	(void)PerlIO_close(PL_rsfp);
	PL_rsfp = Nullfp;
    }

    /* Filters for program text */
    SvREFCNT_dec(PL_rsfp_filters);
    PL_rsfp_filters = Nullav;

    /* switches */
    PL_preprocess   = FALSE;
    PL_minus_n      = FALSE;
    PL_minus_p      = FALSE;
    PL_minus_l      = FALSE;
    PL_minus_a      = FALSE;
    PL_minus_F      = FALSE;
    PL_doswitches   = FALSE;
    PL_dowarn       = FALSE;
    PL_doextract    = FALSE;
    PL_sawampersand = FALSE;	/* must save all match strings */
    PL_sawstudy     = FALSE;	/* do fbm_instr on all strings */
    PL_sawvec       = FALSE;
    PL_unsafe       = FALSE;

    Safefree(PL_inplace);
    PL_inplace = Nullch;

    if (PL_e_script) {
	SvREFCNT_dec(PL_e_script);
	PL_e_script = Nullsv;
    }

    /* magical thingies */

    Safefree(PL_ofs);	/* $, */
    PL_ofs = Nullch;

    Safefree(PL_ors);	/* $\ */
    PL_ors = Nullch;

    SvREFCNT_dec(PL_rs);	/* $/ */
    PL_rs = Nullsv;

    SvREFCNT_dec(PL_nrs);	/* $/ helper */
    PL_nrs = Nullsv;

    PL_multiline = 0;	/* $* */

    SvREFCNT_dec(PL_statname);
    PL_statname = Nullsv;
    PL_statgv = Nullgv;

    /* defgv, aka *_ should be taken care of elsewhere */

    /* clean up after study() */
    SvREFCNT_dec(PL_lastscream);
    PL_lastscream = Nullsv;
    Safefree(PL_screamfirst);
    PL_screamfirst = 0;
    Safefree(PL_screamnext);
    PL_screamnext  = 0;

    /* startup and shutdown function lists */
    SvREFCNT_dec(PL_beginav);
    SvREFCNT_dec(PL_endav);
    SvREFCNT_dec(PL_initav);
    PL_beginav = Nullav;
    PL_endav = Nullav;
    PL_initav = Nullav;

    /* shortcuts just get cleared */
    PL_envgv = Nullgv;
    PL_siggv = Nullgv;
    PL_incgv = Nullgv;
    PL_hintgv = Nullgv;
    PL_errgv = Nullgv;
    PL_argvgv = Nullgv;
    PL_argvoutgv = Nullgv;
    PL_stdingv = Nullgv;
    PL_last_in_gv = Nullgv;
    PL_replgv = Nullgv;

    /* reset so print() ends up where we expect */
    setdefout(Nullgv);

d190 2
a191 3

    hv = PL_defstash;
    PL_defstash = 0;
d196 6
a201 9
	if (PL_scopestack_ix != 0)
	    warn("Unbalanced scopes: %ld more ENTERs than LEAVEs\n",
		 (long)PL_scopestack_ix);
	if (PL_savestack_ix != 0)
	    warn("Unbalanced saves: %ld more saves than restores\n",
		 (long)PL_savestack_ix);
	if (PL_tmps_floor != -1)
	    warn("Unbalanced tmps: %ld more allocs than frees\n",
		 (long)PL_tmps_floor + 1);
d203 1
a203 2
	    warn("Unbalanced context: %ld more PUSHes than POPs\n",
		 (long)cxstack_ix + 1);
d208 2
a209 3
    SvFLAGS(PL_strtab) |= SVTYPEMASK;		/* don't clean out strtab now */
    while (PL_sv_count != 0 && PL_sv_count != last_sv_count) {
	last_sv_count = PL_sv_count;
d212 2
a213 36
    SvFLAGS(PL_strtab) &= ~SVTYPEMASK;
    SvFLAGS(PL_strtab) |= SVt_PVHV;
    
    /* Destruct the global string table. */
    {
	/* Yell and reset the HeVAL() slots that are still holding refcounts,
	 * so that sv_free() won't fail on them.
	 */
	I32 riter;
	I32 max;
	HE *hent;
	HE **array;

	riter = 0;
	max = HvMAX(PL_strtab);
	array = HvARRAY(PL_strtab);
	hent = array[0];
	for (;;) {
	    if (hent) {
		warn("Unbalanced string table refcount: (%d) for \"%s\"",
		     HeVAL(hent) - Nullsv, HeKEY(hent));
		HeVAL(hent) = Nullsv;
		hent = HeNEXT(hent);
	    }
	    if (!hent) {
		if (++riter > max)
		    break;
		hent = array[riter];
	    }
	}
    }
    SvREFCNT_dec(PL_strtab);

    if (PL_sv_count != 0)
	warn("Scalars leaked: %ld\n", (long)PL_sv_count);

a214 11

    /* No SVs have survived, need to clean out */
    PL_linestr = NULL;
    PL_pidstatus = Nullhv;
    Safefree(PL_origfilename);
    Safefree(PL_archpat_auto);
    Safefree(PL_reg_start_tmp);
    Safefree(HeKEY_hek(&PL_hv_fetch_ent_mh));
    Safefree(PL_op_mask);
    nuke_stacks();
    PL_hints = 0;		/* Reset hints. Should hints be per-interpreter ? */
a216 38
#ifdef USE_THREADS
    MUTEX_DESTROY(&PL_strtab_mutex);
    MUTEX_DESTROY(&PL_sv_mutex);
    MUTEX_DESTROY(&PL_cred_mutex);
    MUTEX_DESTROY(&PL_eval_mutex);
    COND_DESTROY(&PL_eval_cond);
#ifdef EMULATE_ATOMIC_REFCOUNTS
    MUTEX_DESTROY(&PL_svref_mutex);
#endif /* EMULATE_ATOMIC_REFCOUNTS */

    /* As the penultimate thing, free the non-arena SV for thrsv */
    Safefree(SvPVX(PL_thrsv));
    Safefree(SvANY(PL_thrsv));
    Safefree(PL_thrsv);
    PL_thrsv = Nullsv;
#endif /* USE_THREADS */
    
    /* As the absolutely last thing, free the non-arena SV for mess() */

    if (PL_mess_sv) {
	/* it could have accumulated taint magic */
	if (SvTYPE(PL_mess_sv) >= SVt_PVMG) {
	    MAGIC* mg;
	    MAGIC* moremagic;
	    for (mg = SvMAGIC(PL_mess_sv); mg; mg = moremagic) {
		moremagic = mg->mg_moremagic;
		if (mg->mg_ptr && mg->mg_type != 'g' && mg->mg_len >= 0)
		    Safefree(mg->mg_ptr);
		Safefree(mg);
	    }
	}
	/* we know that type >= SVt_PV */
	SvOOK_off(PL_mess_sv);
	Safefree(SvPVX(PL_mess_sv));
	Safefree(SvANY(PL_mess_sv));
	Safefree(PL_mess_sv);
	PL_mess_sv = Nullsv;
    }
d220 2
a221 5
#ifdef PERL_OBJECT
CPerlObj::perl_free(void)
#else
perl_free(PerlInterpreter *sv_interp)
#endif
d223 1
a223 4
#ifdef PERL_OBJECT
	Safefree(this);
#else
    if (!(PL_curinterp = sv_interp))
a225 1
#endif
d227 2
a228 6

void
#ifdef PERL_OBJECT
CPerlObj::perl_atexit(void (*fn) (CPerlObj*,void *), void *ptr)
#else
perl_atexit(void (*fn) (void *), void *ptr)
a229 6
{
    Renew(PL_exitlist, PL_exitlistlen+1, PerlExitListEntry);
    PL_exitlist[PL_exitlistlen].fn = fn;
    PL_exitlist[PL_exitlistlen].ptr = ptr;
    ++PL_exitlistlen;
}
d232 6
a237 5
#ifdef PERL_OBJECT
CPerlObj::perl_parse(void (*xsinit) (CPerlObj*), int argc, char **argv, char **env)
#else
perl_parse(PerlInterpreter *sv_interp, void (*xsinit) (void), int argc, char **argv, char **env)
#endif
a238 1
    dTHR;
a243 1
    I32 oldscope;
a244 3
    dJMPENV;
    int ret;
    int fdscript = -1;
d254 1
a254 2
#ifndef PERL_OBJECT
    if (!(PL_curinterp = sv_interp))
a255 1
#endif
d257 2
a258 7
#if defined(NeXT) && defined(__DYNAMIC__)
    _dyld_lookup_and_bind
	("__environ", (unsigned long *) &environ_pointer, NULL);
#endif /* environ */

    PL_origargv = argv;
    PL_origargc = argc;
d260 1
a260 1
    PL_origenviron = environ;
d262 1
d264 1
a264 1
    if (PL_do_undump) {
d268 2
a269 2
	PL_origfilename = savepv(argv[0]);
	PL_do_undump = FALSE;
d276 3
a278 11
    if (PL_main_root) {
	PL_curpad = AvARRAY(PL_comppad);
	op_free(PL_main_root);
	PL_main_root = Nullop;
    }
    PL_main_start = Nullop;
    SvREFCNT_dec(PL_main_cv);
    PL_main_cv = Nullcv;

    time(&PL_basetime);
    oldscope = PL_scopestack_ix;
d280 1
a280 2
    JMPENV_PUSH(ret);
    switch (ret) {
d282 5
a286 2
	STATUS_ALL_FAILURE;
	/* FALL THROUGH */
d288 4
a291 9
	/* my_exit() was called */
	while (PL_scopestack_ix > oldscope)
	    LEAVE;
	FREETMPS;
	PL_curstash = PL_defstash;
	if (PL_endav)
	    call_list(oldscope, PL_endav);
	JMPENV_POP;
	return STATUS_NATIVE_EXPORT;
d293 1
a293 2
	JMPENV_POP;
	PerlIO_printf(PerlIO_stderr(), "panic: top_env\n");
d297 1
a297 1
    sv_setpvn(PL_linestr,"",0);
a300 1

a312 4
#ifndef PERL_STRICT_CR
	case '\r':
#endif
	case ' ':
d327 1
a335 5
	case 'T':
	    PL_tainting = TRUE;
	    s++;
	    goto reswitch;

d337 1
a337 1
	    if (PL_euid != PL_uid || PL_egid != PL_gid)
d339 8
a346 3
	    if (!PL_e_script) {
		PL_e_script = newSVpv("",0);
		filter_add(read_e_script, NULL);
d348 2
a349 4
	    if (*++s)
		sv_catpv(PL_e_script, s);
	    else if (argv[1]) {
		sv_catpv(PL_e_script, argv[1]);
d352 1
a352 3
	    else
		croak("No code specified for -e");
	    sv_catpv(PL_e_script, "\n");
d354 11
a364 4

	case 'I':	/* -I handled both here and in moreswitches() */
	    forbid_setid("-I");
	    if (!*++s && (s=argv[1]) != Nullch) {
d366 1
a367 12
	    while (s && isSPACE(*s))
		++s;
	    if (s && *s) {
		char *e, *p;
		for (e = s; *e && !isSPACE(*e); e++) ;
		p = savepvn(s, e-s);
		incpush(p, TRUE);
		sv_catpv(sv,"-I");
		sv_catpv(sv,p);
		sv_catpv(sv," ");
		Safefree(p);
	    }	/* XXX else croak? */
d370 2
a371 2
	    forbid_setid("-P");
	    PL_preprocess = TRUE;
d375 1
a375 1
	    forbid_setid("-S");
d380 3
a382 3
	    if (!PL_preambleav)
		PL_preambleav = newAV();
	    av_push(PL_preambleav, newSVpv("use Config qw(myconfig config_vars)",0));
d384 1
a384 42
		PL_Sv = newSVpv("print myconfig();",0);
#ifdef VMS
		sv_catpv(PL_Sv,"print \"\\nCharacteristics of this PERLSHR image: \\n\",");
#else
		sv_catpv(PL_Sv,"print \"\\nCharacteristics of this binary (from libperl): \\n\",");
#endif
#if defined(DEBUGGING) || defined(NO_EMBED) || defined(MULTIPLICITY)
		sv_catpv(PL_Sv,"\"  Compile-time options:");
#  ifdef DEBUGGING
		sv_catpv(PL_Sv," DEBUGGING");
#  endif
#  ifdef NO_EMBED
		sv_catpv(PL_Sv," NO_EMBED");
#  endif
#  ifdef MULTIPLICITY
		sv_catpv(PL_Sv," MULTIPLICITY");
#  endif
		sv_catpv(PL_Sv,"\\n\",");
#endif
#if defined(LOCAL_PATCH_COUNT)
		if (LOCAL_PATCH_COUNT > 0) {
		    int i;
		    sv_catpv(PL_Sv,"\"  Locally applied patches:\\n\",");
		    for (i = 1; i <= LOCAL_PATCH_COUNT; i++) {
			if (PL_localpatches[i])
			    sv_catpvf(PL_Sv,"\"  \\t%s\\n\",",PL_localpatches[i]);
		    }
		}
#endif
		sv_catpvf(PL_Sv,"\"  Built under %s\\n\"",OSNAME);
#ifdef __DATE__
#  ifdef __TIME__
		sv_catpvf(PL_Sv,",\"  Compiled at %s %s\\n\"",__DATE__,__TIME__);
#  else
		sv_catpvf(PL_Sv,",\"  Compiled on %s\\n\"",__DATE__);
#  endif
#endif
		sv_catpv(PL_Sv, "; \
$\"=\"\\n    \"; \
@@env = map { \"$_=\\\"$ENV{$_}\\\"\" } sort grep {/^PERL/} keys %ENV; \
print \"  \\%ENV:\\n    @@env\\n\" if @@env; \
print \"  \\@@INC:\\n    @@INC\\n\";");
d387 3
a389 3
		PL_Sv = newSVpv("config_vars(qw(",0);
		sv_catpv(PL_Sv, ++s);
		sv_catpv(PL_Sv, "))");
d392 1
a392 1
	    av_push(PL_preambleav, PL_Sv);
d396 1
a396 1
	    PL_doextract = TRUE;
d399 1
a399 1
		PL_cddir = savepv(s);
d401 3
a405 16
	case '-':
	    if (!*++s || isSPACE(*s)) {
		argc--,argv++;
		goto switch_end;
	    }
	    /* catch use of gnu style long options */
	    if (strEQ(s, "version")) {
		s = "v";
		goto reswitch;
	    }
	    if (strEQ(s, "help")) {
		s = "h";
		goto reswitch;
	    }
	    s--;
	    /* FALL THROUGH */
d407 1
a407 1
	    croak("Unrecognized switch: -%s  (-h will show valid options)",s);
a410 18

    if (!PL_tainting && (s = PerlEnv_getenv("PERL5OPT"))) {
	while (s && *s) {
	    while (isSPACE(*s))
		s++;
	    if (*s == '-') {
		s++;
		if (isSPACE(*s))
		    continue;
	    }
	    if (!*s)
		break;
	    if (!strchr("DIMUdmw", *s))
		croak("Illegal switch in PERL5OPT: -%c", *s);
	    s = moreswitches(s);
	}
    }

d413 4
a416 1
    if (PL_e_script) {
d418 1
a418 1
	scriptname = BIT_BUCKET;	/* don't look for script or read stdin */
d422 2
a423 2
	if ( PerlLIO_isatty(PerlIO_fileno(PerlIO_stdin())) )
	    moreswitches("h");
d430 1
a430 1
    open_script(scriptname,dosearch,sv,&fdscript);
d432 1
a432 1
    validate_suid(validarg, scriptname,fdscript);
d434 1
a434 1
    if (PL_doextract)
d437 12
a448 19
    PL_main_cv = PL_compcv = (CV*)NEWSV(1104,0);
    sv_upgrade((SV *)PL_compcv, SVt_PVCV);
    CvUNIQUE_on(PL_compcv);

    PL_comppad = newAV();
    av_push(PL_comppad, Nullsv);
    PL_curpad = AvARRAY(PL_comppad);
    PL_comppad_name = newAV();
    PL_comppad_name_fill = 0;
    PL_min_intro_pending = 0;
    PL_padix = 0;
#ifdef USE_THREADS
    av_store(PL_comppad_name, 0, newSVpv("@@_", 2));
    PL_curpad[0] = (SV*)newAV();
    SvPADMY_on(PL_curpad[0]);	/* XXX Needed? */
    CvOWNER(PL_compcv) = 0;
    New(666, CvMUTEXP(PL_compcv), 1, perl_mutex);
    MUTEX_INIT(CvMUTEXP(PL_compcv));
#endif /* USE_THREADS */
d452 3
a454 5
    av_store(comppadlist, 0, (SV*)PL_comppad_name);
    av_store(comppadlist, 1, (SV*)PL_comppad);
    CvPADLIST(PL_compcv) = comppadlist;

    boot_core_UNIVERSAL();
d457 2
a458 2
	(*xsinit)(PERL_OBJECT_THIS);	/* in case linked C routines want magical variables */
#if defined(VMS) || defined(WIN32) || defined(DJGPP)
d463 1
a463 4
    /* init_postdump_symbols not currently designed to be called */
    /* more than once (ENV isn't cleared first, for example)	 */
    /* But running with -u leaves %ENV & @@ARGV undefined!    XXX */
    if (!PL_do_undump)
d470 4
a473 5
    SETERRNO(0,SS$_NORMAL);
    PL_error_count = 0;
    if (yyparse() || PL_error_count) {
	if (PL_minus_c)
	    croak("%s had compilation errors.\n", PL_origfilename);
d476 1
a476 1
		PL_origfilename);
d479 7
a485 6
    PL_curcop->cop_line = 0;
    PL_curstash = PL_defstash;
    PL_preprocess = FALSE;
    if (PL_e_script) {
	SvREFCNT_dec(PL_e_script);
	PL_e_script = Nullsv;
d489 5
a493 4
    SvREFCNT_dec(PL_rs);
    PL_rs = SvREFCNT_inc(PL_nrs);
    sv_setsv(perl_get_sv("/", TRUE), PL_rs);
    if (PL_do_undump)
d496 2
a497 2
    if (PL_dowarn)
	gv_check(PL_defstash);
d502 2
a503 2
#ifdef MYMALLOC
    if ((s=PerlEnv_getenv("PERL_DEBUG_MSTATS")) && atoi(s) >= 2)
d508 1
a508 2
    PL_restartop = 0;
    JMPENV_POP;
d513 2
a514 5
#ifdef PERL_OBJECT
CPerlObj::perl_run(void)
#else
perl_run(PerlInterpreter *sv_interp)
#endif
d516 1
a516 7
    dSP;
    I32 oldscope;
    dJMPENV;
    int ret;

#ifndef PERL_OBJECT
    if (!(PL_curinterp = sv_interp))
d518 1
a518 6
#endif

    oldscope = PL_scopestack_ix;

    JMPENV_PUSH(ret);
    switch (ret) {
d523 3
a525 3
	/* my_exit() was called */
	while (PL_scopestack_ix > oldscope)
	    LEAVE;
d527 2
a528 5
	PL_curstash = PL_defstash;
	if (PL_endav)
	    call_list(oldscope, PL_endav);
#ifdef MYMALLOC
	if (PerlEnv_getenv("PERL_DEBUG_MSTATS"))
d531 1
a531 2
	JMPENV_POP;
	return STATUS_NATIVE_EXPORT;
d533 2
a534 2
	if (!PL_restartop) {
	    PerlIO_printf(PerlIO_stderr(), "panic: restartop\n");
a535 1
	    JMPENV_POP;
d538 4
a541 1
	POPSTACK_TO(PL_mainstack);
d545 1
a545 4
    DEBUG_r(PerlIO_printf(Perl_debug_log, "%s $` $& $' support.\n",
                    PL_sawampersand ? "Enabling" : "Omitting"));

    if (!PL_restartop) {
d547 1
a547 3
	DEBUG(PerlIO_printf(Perl_debug_log, "\nEXECUTING...\n\n"));
	DEBUG_S(PerlIO_printf(Perl_debug_log, "main thread is 0x%lx\n",
			      (unsigned long) thr));
d549 2
a550 2
	if (PL_minus_c) {
	    PerlIO_printf(PerlIO_stderr(), "%s syntax OK\n", PL_origfilename);
d553 2
a554 4
	if (PERLDB_SINGLE && PL_DBsingle)
	   sv_setiv(PL_DBsingle, 1); 
	if (PL_initav)
	    call_list(oldscope, PL_initav);
d559 8
a566 9
    if (PL_restartop) {
	PL_op = PL_restartop;
	PL_restartop = 0;
	CALLRUNOPS();
    }
    else if (PL_main_start) {
	CvDEPTH(PL_main_cv) = 1;
	PL_op = PL_main_start;
	CALLRUNOPS();
a569 1
    /* NOTREACHED */
d573 18
d592 3
a594 1
perl_get_sv(char *name, I32 create)
d596 1
a596 11
    GV *gv;
#ifdef USE_THREADS
    if (name[1] == '\0' && !isALPHA(name[0])) {
	PADOFFSET tmp = find_threadsv(name);
    	if (tmp != NOT_IN_PAD) {
	    dTHR;
	    return THREADSV(tmp);
	}
    }
#endif /* USE_THREADS */
    gv = gv_fetchpv(name, create, SVt_PV);
d603 3
a605 1
perl_get_av(char *name, I32 create)
d616 3
a618 1
perl_get_hv(char *name, I32 create)
d629 3
a631 1
perl_get_cv(char *name, I32 create)
d634 2
a635 3
    /* XXX unsafe for threads if eval_owner isn't held */
    if (create && !GvCVu(gv))
    	return newSUB(start_subparse(FALSE, 0),
d640 1
a640 1
	return GvCVu(gv);
d647 4
a650 4
perl_call_argv(char *sub_name, I32 flags, register char **argv)
              
          		/* See G_* flags in cop.h */
                     	/* null terminated arg list */
d654 1
a654 1
    PUSHMARK(SP);
d662 1
a662 1
    return perl_call_pv(sub_name, flags);
d666 3
a668 3
perl_call_pv(char *sub_name, I32 flags)
              		/* name of the subroutine */
          		/* See G_* flags in cop.h */
d670 1
a670 1
    return perl_call_sv((SV*)perl_get_cv(sub_name, TRUE), flags);
d674 3
a676 3
perl_call_method(char *methname, I32 flags)
               		/* name of the subroutine */
          		/* See G_* flags in cop.h */
d680 2
a681 2
    if (!PL_op)
	PL_op = &myop;
d684 2
a685 4
    pp_method(ARGS);
	if(PL_op == &myop)
		PL_op = Nullop;
    return perl_call_sv(*PL_stack_sp--, flags);
d690 3
a692 3
perl_call_sv(SV *sv, I32 flags)
       
          		/* See G_* flags in cop.h */
a693 1
    dSP;
d695 2
a696 1
    I32 oldmark;
d698 1
d700 1
a700 5
    bool oldcatch = CATCH_GET;
    dJMPENV;
    int ret;
    OP* oldop = PL_op;

d706 9
a714 1
    Zero(&myop, 1, LOGOP);
d716 3
a718 21
    if (!(flags & G_NOARGS))
	myop.op_flags |= OPf_STACKED;
    myop.op_flags |= ((flags & G_VOID) ? OPf_WANT_VOID :
		      (flags & G_ARRAY) ? OPf_WANT_LIST :
		      OPf_WANT_SCALAR);
    SAVEOP();
    PL_op = (OP*)&myop;

    EXTEND(PL_stack_sp, 1);
    *++PL_stack_sp = sv;
    oldmark = TOPMARK;
    oldscope = PL_scopestack_ix;

    if (PERLDB_SUB && PL_curstash != PL_debstash
	   /* Handle first BEGIN of -d. */
	  && (PL_DBcv || (PL_DBcv = GvCV(PL_DBsub)))
	   /* Try harder, since this may have been a sighandler, thus
	    * curstash may be meaningless. */
	  && (SvTYPE(sv) != SVt_PVCV || CvSTASH((CV*)sv) != PL_debstash)
	  && !(flags & G_NODEBUG))
	PL_op->op_private |= OPpENTERSUB_DB;
d721 4
a724 2
	cLOGOP->op_other = PL_op;
	PL_markstack_ptr--;
d727 2
a728 2
	    register PERL_CONTEXT *cx;
	    I32 gimme = GIMME_V;
d733 2
a734 2
	    push_return(PL_op->op_next);
	    PUSHBLOCK(cx, CXt_EVAL, PL_stack_sp);
d736 1
a736 1
	    PL_eval_root = PL_op;             /* Only needed so that goto works right. */
d738 1
a738 1
	    PL_in_eval = 1;
d740 1
a740 1
		PL_in_eval |= 4;
d742 1
a742 1
		sv_setpv(ERRSV,"");
d744 1
a744 1
	PL_markstack_ptr++;
d746 2
a747 2
	JMPENV_PUSH(ret);
	switch (ret) {
d751 5
a755 1
	    STATUS_ALL_FAILURE;
d759 1
a759 1
	    PL_curstash = PL_defstash;
d761 2
a762 2
	    JMPENV_POP;
	    if (PL_statusvalue)
d764 1
a764 1
	    my_exit_jump();
d767 4
a770 4
	    if (PL_restartop) {
		PL_op = PL_restartop;
		PL_restartop = 0;
		break;
d772 1
a772 1
	    PL_stack_sp = PL_stack_base + oldmark;
d777 1
a777 1
		*++PL_stack_sp = &PL_sv_undef;
a781 2
    else
	CATCH_SET(TRUE);
d783 5
a787 5
    if (PL_op == (OP*)&myop)
	PL_op = pp_entersub(ARGS);
    if (PL_op)
	CALLRUNOPS();
    retval = PL_stack_sp - (PL_stack_base + oldmark);
d789 1
a789 1
	sv_setpv(ERRSV,"");
d793 1
a793 1
	if (PL_scopestack_ix > oldscope) {
d797 1
a797 1
	    register PERL_CONTEXT *cx;
d803 1
a803 1
	    PL_curpm = newpm;
d806 1
a806 1
	JMPENV_POP;
a807 3
    else
	CATCH_SET(oldcatch);

d809 1
a809 1
	PL_stack_sp = PL_stack_base + oldmark;
a813 1
    PL_op = oldop;
d817 1
a817 1
/* Eval a string. The G_EVAL flag is always assumed. */
d820 3
a822 3
perl_eval_sv(SV *sv, I32 flags)
       
          		/* See G_* flags in cop.h */
a823 1
    dSP;
d825 2
a826 1
    I32 oldmark = SP - PL_stack_base;
d828 1
d830 1
a830 4
    dJMPENV;
    int ret;
    OP* oldop = PL_op;

d836 6
a841 6
    SAVEOP();
    PL_op = (OP*)&myop;
    Zero(PL_op, 1, UNOP);
    EXTEND(PL_stack_sp, 1);
    *++PL_stack_sp = sv;
    oldscope = PL_scopestack_ix;
d846 3
a848 6
    myop.op_type = OP_ENTEREVAL;
    myop.op_flags |= ((flags & G_VOID) ? OPf_WANT_VOID :
		      (flags & G_ARRAY) ? OPf_WANT_LIST :
		      OPf_WANT_SCALAR);
    if (flags & G_KEEPERR)
	myop.op_flags |= OPf_SPECIAL;
d850 4
a853 2
    JMPENV_PUSH(ret);
    switch (ret) {
d857 5
a861 1
	STATUS_ALL_FAILURE;
d865 1
a865 1
	PL_curstash = PL_defstash;
d867 2
a868 2
	JMPENV_POP;
	if (PL_statusvalue)
d870 1
a870 1
	my_exit_jump();
d873 4
a876 4
	if (PL_restartop) {
	    PL_op = PL_restartop;
	    PL_restartop = 0;
	    break;
d878 1
a878 1
	PL_stack_sp = PL_stack_base + oldmark;
d883 1
a883 1
	    *++PL_stack_sp = &PL_sv_undef;
d888 7
a894 7
    if (PL_op == (OP*)&myop)
	PL_op = pp_entereval(ARGS);
    if (PL_op)
	CALLRUNOPS();
    retval = PL_stack_sp - (PL_stack_base + oldmark);
    if (!(flags & G_KEEPERR))
	sv_setpv(ERRSV,"");
d897 1
a897 1
    JMPENV_POP;
d899 1
a899 1
	PL_stack_sp = PL_stack_base + oldmark;
a903 1
    PL_op = oldop;
a906 22
SV*
perl_eval_pv(char *p, I32 croak_on_error)
{
    dSP;
    SV* sv = newSVpv(p, 0);

    PUSHMARK(SP);
    perl_eval_sv(sv, G_SCALAR);
    SvREFCNT_dec(sv);

    SPAGAIN;
    sv = POPs;
    PUTBACK;

    if (croak_on_error && SvTRUE(ERRSV)) {
	STRLEN n_a;
	croak(SvPVx(ERRSV, n_a));
    }

    return sv;
}

d910 2
a911 1
perl_require_pv(char *pv)
d913 1
a913 5
    SV* sv;
    dSP;
    PUSHSTACKi(PERLSI_REQUIRE);
    PUTBACK;
    sv = sv_newmortal();
a917 2
    SPAGAIN;
    POPSTACK;
d921 4
a924 1
magicname(char *sym, char *name, I32 namlen)
d932 40
a971 3
STATIC void
usage(char *name)		/* XXX move this out into a module ? */
           
a974 30

    static char *usage_msg[] = {
"-0[octal]       specify record separator (\\0, if no argument)",
"-a              autosplit mode with -n or -p (splits $_ into @@F)",
"-c              check syntax only (runs BEGIN and END blocks)",
"-d[:debugger]   run scripts under debugger",
"-D[number/list] set debugging flags (argument is a bit mask or flags)",
"-e 'command'    one line of script. Several -e's allowed. Omit [programfile].",
"-F/pattern/     split() pattern for autosplit (-a). The //'s are optional.",
"-i[extension]   edit <> files in place (make backup if extension supplied)",
"-Idirectory     specify @@INC/#include directory (may be used more than once)",
"-l[octal]       enable line ending processing, specifies line terminator",
"-[mM][-]module.. executes `use/no module...' before executing your script.",
"-n              assume 'while (<>) { ... }' loop around your script",
"-p              assume loop like -n but print line also like sed",
"-P              run script through C preprocessor before compilation",
"-s              enable some switch parsing for switches after script name",
"-S              look for the script using PATH environment variable",
"-T              turn on tainting checks",
"-u              dump core after parsing script",
"-U              allow unsafe operations",
"-v              print version number, patchlevel plus VERY IMPORTANT perl info",
"-V[:variable]   print perl configuration information",
"-w              TURN WARNINGS ON FOR COMPILATION OF YOUR SCRIPT. Recommended.",
"-x[directory]   strip off text before #!perl line and perhaps cd to directory",
"\n",
NULL
};
    char **p = usage_msg;

d976 26
a1001 2
    while (*p)
	printf("\n  %s", *p++);
d1007 2
a1008 1
moreswitches(char *s)
a1014 2
    {
	dTHR;
d1016 1
a1016 1
	SvREFCNT_dec(PL_nrs);
d1018 1
a1018 1
	    PL_nrs = &PL_sv_undef;
d1020 1
a1020 1
	    PL_nrs = newSVpv("", 0);
d1023 1
a1023 1
	    PL_nrs = newSVpv(&ch, 1);
a1025 1
    }
d1027 2
a1028 2
	PL_minus_F = TRUE;
	PL_splitstr = savepv(s + 1);
d1032 1
a1032 1
	PL_minus_a = TRUE;
d1036 1
a1036 1
	PL_minus_c = TRUE;
d1040 1
a1040 1
	forbid_setid("-d");
d1043 1
a1043 1
	    my_setenv("PERL5DB", form("use Devel::%s;", ++s));
d1045 1
d1047 2
a1048 2
	if (!PL_perldb) {
	    PL_perldb = PERLDB_ALL;
d1054 1
a1054 1
	forbid_setid("-D");
d1056 1
a1056 1
	    static char debopts[] = "psltocPmfrxuLHXDS";
d1060 1
a1060 1
		PL_debug |= 1 << (d - debopts);
d1063 1
a1063 1
	    PL_debug = atoi(s+1);
d1066 1
a1066 1
	PL_debug |= 0x80000000;
d1074 2
a1075 2
	usage(PL_origargv[0]);    
	PerlProc_exit(0);
d1077 3
a1079 3
	if (PL_inplace)
	    Safefree(PL_inplace);
	PL_inplace = savepv(s+1);
d1081 7
a1087 14
	for (s = PL_inplace; *s && !isSPACE(*s); s++) ;
	if (*s) {
	    *s++ = '\0';
	    if (*s == '-')	/* Additional switches on #! line. */
	        s++;
	}
	return s;
    case 'I':	/* -I handled both here and in parse_perl() */
	forbid_setid("-I");
	++s;
	while (*s && isSPACE(*s))
	    ++s;
	if (*s) {
	    char *e, *p;
d1089 3
a1091 4
	    p = savepvn(s, e-s);
	    incpush(p, TRUE);
	    Safefree(p);
	    s = e;
d1095 1
a1095 1
	return s;
d1097 1
a1097 1
	PL_minus_l = TRUE;
d1099 2
a1100 2
	if (PL_ors)
	    Safefree(PL_ors);
d1102 3
a1104 3
	    PL_ors = savepv("\n");
	    PL_orslen = 1;
	    *PL_ors = scan_oct(s, 3 + (*s == '0'), &numlen);
d1108 3
a1110 4
	    dTHR;
	    if (RsPARA(PL_nrs)) {
		PL_ors = "\n\n";
		PL_orslen = 2;
d1113 1
a1113 2
		PL_ors = SvPV(PL_nrs, PL_orslen);
	    PL_ors = savepvn(PL_ors, PL_orslen);
d1117 1
a1117 1
	forbid_setid("-M");	/* XXX ? */
d1120 1
a1120 1
	forbid_setid("-m");	/* XXX ? */
a1122 1
	    SV *sv;
d1126 1
a1126 1
	    sv = newSVpv(use,0);
d1131 1
a1131 1
		sv_catpv(sv, start);
d1135 1
a1135 1
		    sv_catpv( sv, " ()");
d1138 4
a1141 4
		sv_catpvn(sv, start, s-start);
		sv_catpv(sv, " split(/,/,q{");
		sv_catpv(sv, ++s);
		sv_catpv(sv,    "})");
d1144 3
a1146 3
	    if (PL_preambleav == NULL)
		PL_preambleav = newAV();
	    av_push(PL_preambleav, sv);
d1152 1
a1152 1
	PL_minus_n = TRUE;
d1156 1
a1156 1
	PL_minus_p = TRUE;
d1160 2
a1161 2
	forbid_setid("-s");
	PL_doswitches = TRUE;
d1165 1
a1165 2
	if (!PL_tainting)
	    croak("Too late for \"-T\" option");
d1169 1
a1169 1
	PL_do_undump = TRUE;
d1173 1
a1173 1
	PL_unsafe = TRUE;
d1178 1
a1178 2
	printf("\nThis is perl, version 5.%03d_%02d built for %s",
	    PATCHLEVEL, SUBVERSION, ARCHNAME);
d1180 1
a1180 7
	printf("\nThis is perl, version %s built for %s",
		PL_patchlevel, ARCHNAME);
#endif
#if defined(LOCAL_PATCH_COUNT)
	if (LOCAL_PATCH_COUNT > 0)
	    printf("\n(with %d registered patch%s, see perl -V for more detail)",
		LOCAL_PATCH_COUNT, (LOCAL_PATCH_COUNT!=1) ? "es" : "");
d1183 4
a1186 3
	printf("\n\nCopyright 1987-1999, Larry Wall\n");
#ifdef MSDOS
	printf("\nMS-DOS port Copyright (c) 1989, 1990, Diomidis Spinellis\n");
d1188 2
a1189 3
#ifdef DJGPP
	printf("djgpp v2 port (jpl5003c) by Hirofumi Watanabe, 1996\n");
	printf("djgpp v2 port (perl5004+) by Laszlo Molnar, 1997-1998\n");
d1191 2
a1192 3
#ifdef OS2
	printf("\n\nOS/2 port Copyright (c) 1990, 1991, Raymond Chen, Kai Uwe Rommel\n"
	    "Version 5 port Copyright (c) 1994-1998, Andreas Kaiser, Ilya Zakharevich\n");
a1193 2
#ifdef atarist
	printf("atariST series port, ++jrb  bammi@@cadence.com\n");
d1195 10
a1204 2
#ifdef __BEOS__
	printf("BeOS port Copyright Tom Spindler, 1997-1998\n");
d1206 7
a1212 2
#ifdef MPE
	printf("MPE/iX port Copyright by Mark Klein and Mark Bixby, 1996-1998\n");
d1214 5
a1218 2
#ifdef OEMVS
	printf("MVS (OS390) port by Mortice Kern Systems, 1997-1998\n");
d1220 3
a1222 2
#ifdef __VOS__
	printf("Stratus VOS port by Paul_Green@@stratus.com, 1997-1999\n");
d1224 2
a1225 2
#ifdef __MINT__
	printf("MiNT port by Guido Flohr, 1997\n");
d1227 5
a1231 2
#ifdef BINARY_BUILD_NOTICE
	BINARY_BUILD_NOTICE;
d1233 1
a1233 7
	printf("\n\
Perl may be copied only under the terms of either the Artistic License or the\n\
GNU General Public License, which may be found in the Perl 5.0 source kit.\n\n\
Complete documentation for Perl, including FAQ lists, should be found on\n\
this system using `man perl' or `perldoc perl'.  If you have access to the\n\
Internet, point your browser at http://www.perl.com/, the Perl Home Page.\n\n");
	PerlProc_exit(0);
d1235 1
a1235 1
	PL_dowarn = TRUE;
a1244 3
#if defined(WIN32) || !defined(PERL_STRICT_CR)
    case '\r':
#endif
a1247 4
#ifdef ALTERNATE_SHEBANG
    case 'S':			/* OS/2 needs -S on "extproc" line. */
	break;
#endif
d1249 1
a1249 1
	if (PL_preprocess)
a1260 1
/* Known to work with -DUNEXEC and using unexelf.c from GNU emacs-20.2 */
d1263 1
a1263 1
my_unexec(void)
d1266 1
a1266 3
    SV*    prog;
    SV*    file;
    int    status = 1;
d1269 7
a1275 8
    prog = newSVpv(BIN_EXP, 0);
    sv_catpv(prog, "/perl");
    file = newSVpv(PL_origfilename, 0);
    sv_catpv(file, ".perldump");

    unexec(SvPVX(file), SvPVX(prog), &etext, sbrk(0), 0);
    /* unexec prints msg to stderr in case of failure */
    PerlProc_exit(status);
d1280 1
a1280 1
#  else
a1281 1
#  endif
a1282 64
}

/* initialize curinterp */
STATIC void
init_interp(void)
{

#ifdef PERL_OBJECT		/* XXX kludge */
#define I_REINIT \
  STMT_START {				\
    PL_chopset		= " \n-";	\
    PL_copline		= NOLINE;	\
    PL_curcop		= &PL_compiling;\
    PL_curcopdb		= NULL;		\
    PL_dbargs		= 0;		\
    PL_dlmax		= 128;		\
    PL_laststatval	= -1;		\
    PL_laststype	= OP_STAT;	\
    PL_maxscream	= -1;		\
    PL_maxsysfd		= MAXSYSFD;	\
    PL_statname		= Nullsv;	\
    PL_tmps_floor	= -1;		\
    PL_tmps_ix		= -1;		\
    PL_op_mask		= NULL;		\
    PL_dlmax		= 128;		\
    PL_laststatval	= -1;		\
    PL_laststype	= OP_STAT;	\
    PL_mess_sv		= Nullsv;	\
    PL_splitstr		= " ";		\
    PL_generation	= 100;		\
    PL_exitlist		= NULL;		\
    PL_exitlistlen	= 0;		\
    PL_regindent	= 0;		\
    PL_in_clean_objs	= FALSE;	\
    PL_in_clean_all	= FALSE;	\
    PL_profiledata	= NULL;		\
    PL_rsfp		= Nullfp;	\
    PL_rsfp_filters	= Nullav;	\
  } STMT_END
    I_REINIT;
#else
#  ifdef MULTIPLICITY
#    define PERLVAR(var,type)
#    define PERLVARI(var,type,init)	PL_curinterp->var = init;
#    define PERLVARIC(var,type,init)	PL_curinterp->var = init;
#    include "intrpvar.h"
#    ifndef USE_THREADS
#      include "thrdvar.h"
#    endif
#    undef PERLVAR
#    undef PERLVARI
#    undef PERLVARIC
#    else
#    define PERLVAR(var,type)
#    define PERLVARI(var,type,init)	PL_##var = init;
#    define PERLVARIC(var,type,init)	PL_##var = init;
#    include "intrpvar.h"
#    ifndef USE_THREADS
#      include "thrdvar.h"
#    endif
#    undef PERLVAR
#    undef PERLVARI
#    undef PERLVARIC
#  endif
a1283 1

d1286 2
a1287 2
STATIC void
init_main_stash(void)
a1288 1
    dTHR;
d1290 2
a1291 13

    /* Note that strtab is a rather special HV.  Assumptions are made
       about not iterating on it, and not adding tie magic to it.
       It is properly deallocated in perl_destruct() */
    PL_strtab = newHV();
#ifdef USE_THREADS
    MUTEX_INIT(&PL_strtab_mutex);
#endif
    HvSHAREKEYS_off(PL_strtab);			/* mandatory */
    hv_ksplit(PL_strtab, 512);
    
    PL_curstash = PL_defstash = newHV();
    PL_curstname = newSVpv("main",4);
d1294 1
a1294 1
    GvHV(gv) = (HV*)SvREFCNT_inc(PL_defstash);
d1296 9
a1304 17
    HvNAME(PL_defstash) = savepv("main");
    PL_incgv = gv_HVadd(gv_AVadd(gv_fetchpv("INC",TRUE, SVt_PVAV)));
    GvMULTI_on(PL_incgv);
    PL_hintgv = gv_fetchpv("\010",TRUE, SVt_PV); /* ^H */
    GvMULTI_on(PL_hintgv);
    PL_defgv = gv_fetchpv("_",TRUE, SVt_PVAV);
    PL_errgv = gv_HVadd(gv_fetchpv("@@", TRUE, SVt_PV));
    GvMULTI_on(PL_errgv);
    PL_replgv = gv_fetchpv("\022", TRUE, SVt_PV); /* ^R */
    GvMULTI_on(PL_replgv);
    (void)form("%240s","");	/* Preallocate temp - for immediate signals. */
    sv_grow(ERRSV, 240);	/* Preallocate - for immediate signals. */
    sv_setpvn(ERRSV, "", 0);
    PL_curstash = PL_defstash;
    PL_compiling.cop_stash = PL_defstash;
    PL_debstash = GvHV(gv_fetchpv("DB::", GV_ADDMULTI, SVt_PVHV));
    PL_globalstash = GvHV(gv_fetchpv("CORE::GLOBAL::", GV_ADDMULTI, SVt_PVHV));
d1306 1
a1306 1
    sv_setpvn(perl_get_sv("/", TRUE), "\n", 1);
d1309 10
a1318 2
STATIC void
open_script(char *scriptname, bool dosearch, SV *sv, int *fdscript)
d1320 2
a1321 1
    dTHR;
d1323 13
d1337 3
a1339 1
    *fdscript = -1;
d1341 19
a1359 11
    if (PL_e_script) {
	PL_origfilename = savepv("-e");
    }
    else {
	/* if find_script() returns, it returns a malloc()-ed value */
	PL_origfilename = scriptname = find_script(scriptname, dosearch, NULL, 1);

	if (strnEQ(scriptname, "/dev/fd/", 8) && isDIGIT(scriptname[8]) ) {
	    char *s = scriptname + 8;
	    *fdscript = atoi(s);
	    while (isDIGIT(*s))
d1361 33
a1393 4
	    if (*s) {
		scriptname = savepv(s + 1);
		Safefree(PL_origfilename);
		PL_origfilename = scriptname;
d1395 2
d1398 5
d1405 13
a1417 2
    PL_curcop->cop_filegv = gv_fetchfile(PL_origfilename);
    if (strEQ(PL_origfilename,"-"))
d1419 2
a1420 2
    if (*fdscript >= 0) {
	PL_rsfp = PerlIO_fdopen(*fdscript,PERL_SCRIPT_MODE);
d1422 1
a1422 2
	if (PL_rsfp)
	    fcntl(PerlIO_fileno(PL_rsfp),F_SETFD,1);  /* ensure close-on-exec */
d1425 2
a1426 8
    else if (PL_preprocess) {
	char *cpp_cfg = CPPSTDIN;
	SV *cpp = newSVpv("",0);
	SV *cmd = NEWSV(0,0);

	if (strEQ(cpp_cfg, "cppstdin"))
	    sv_catpvf(cpp, "%s/", BIN_EXP);
	sv_catpv(cpp, cpp_cfg);
d1428 4
a1433 1

d1435 1
a1435 1
	sv_setpvf(cmd, "\
d1447 2
a1448 2
 %s | %_ -C %_ %s",
	  (PL_doextract ? "-e \"1,/^#/d\n\"" : ""),
d1450 1
a1450 1
	sv_setpvf(cmd, "\
d1462 1
a1462 1
 %s | %_ -C %_ %s",
d1468 1
a1468 1
	  (PL_doextract ? "-e '1,/^#/d\n'" : ""),
d1470 2
a1471 2
	  scriptname, cpp, sv, CPPMINUS);
	PL_doextract = FALSE;
d1473 1
a1473 1
	if (PL_euid != PL_uid && !PL_euid) {	/* if running suidperl */
d1475 1
a1475 1
	    (void)seteuid(PL_uid);		/* musn't stay setuid root */
d1478 1
a1478 1
	    (void)setreuid((Uid_t)-1, PL_uid);
d1481 1
a1481 1
	    (void)setresuid((Uid_t)-1, PL_uid, (Uid_t)-1);
d1483 1
a1483 1
	    PerlProc_setuid(PL_uid);
d1487 1
a1487 1
	    if (PerlProc_geteuid() != PL_uid)
d1491 1
a1491 3
	PL_rsfp = PerlProc_popen(SvPVX(cmd), "r");
	SvREFCNT_dec(cmd);
	SvREFCNT_dec(cpp);
d1494 2
a1495 2
	forbid_setid("program input from stdin");
	PL_rsfp = PerlIO_stdin();
d1498 1
a1498 1
	PL_rsfp = PerlIO_open(scriptname,PERL_SCRIPT_MODE);
d1500 1
a1500 2
	if (PL_rsfp)
	    fcntl(PerlIO_fileno(PL_rsfp),F_SETFD,1);  /* ensure close-on-exec */
d1503 1
a1503 1
    if (!PL_rsfp) {
d1506 4
a1509 6
	if (PL_euid &&
	    PerlLIO_stat(SvPVX(GvSV(PL_curcop->cop_filegv)),&PL_statbuf) >= 0 &&
	    PL_statbuf.st_mode & (S_ISUID|S_ISGID))
	{
	    /* try again */
	    PerlProc_execv(form("%s/sperl%s", BIN_EXP, PL_patchlevel), PL_origargv);
d1515 1
a1515 56
	  SvPVX(GvSV(PL_curcop->cop_filegv)), Strerror(errno));
    }
}

#ifdef IAMSUID
static int
fd_on_nosuid_fs(int fd)
{
    int on_nosuid  = 0;
    int check_okay = 0;
/*
 * Preferred order: fstatvfs(), fstatfs(), getmntent().
 * fstatvfs() is UNIX98.
 * fstatfs() is BSD.
 * getmntent() is O(number-of-mounted-filesystems) and can hang.
 */

#   ifdef HAS_FSTATVFS
    struct statvfs stfs;
    check_okay = fstatvfs(fd, &stfs) == 0;
    on_nosuid  = check_okay && (stfs.f_flag  & ST_NOSUID);
#   else
#       if defined(HAS_FSTATFS) && defined(HAS_STRUCT_STATFS_FLAGS)
    struct statfs  stfs;
    check_okay = fstatfs(fd, &stfs)  == 0;
#           undef PERL_MOUNT_NOSUID
#           if !defined(PERL_MOUNT_NOSUID) && defined(MNT_NOSUID)
#              define PERL_MOUNT_NOSUID MNT_NOSUID
#           endif
#           if !defined(PERL_MOUNT_NOSUID) && defined(MS_NOSUID)
#              define PERL_MOUNT_NOSUID MS_NOSUID
#           endif
#           if !defined(PERL_MOUNT_NOSUID) && defined(M_NOSUID)
#              define PERL_MOUNT_NOSUID M_NOSUID
#           endif
#           ifdef PERL_MOUNT_NOSUID
    on_nosuid  = check_okay && (stfs.f_flags & PERL_MOUNT_NOSUID);
#           endif
#       else
#           if defined(HAS_GETMNTENT) && defined(HAS_HASMNTOPT) && defined(MNTOPT_NOSUID)
    FILE		*mtab = fopen("/etc/mtab", "r");
    struct mntent	*entry;
    struct stat		stb, fsb;

    if (mtab && (fstat(fd, &stb) == 0)) {
	while (entry = getmntent(mtab)) {
	    if (stat(entry->mnt_dir, &fsb) == 0
		&& fsb.st_dev == stb.st_dev)
	    {
		/* found the filesystem */
		check_okay = 1;
		if (hasmntopt(entry, MNTOPT_NOSUID))
		    on_nosuid = 1;
		break;
	    } /* A single fs may well fail its stat(). */
	}
a1516 9
    if (mtab)
	fclose(mtab);
#           endif /* mntent */
#       endif /* statfs */
#   endif /* statvfs */
    if (!check_okay) 
	croak("Can't check filesystem of script \"%s\" for nosuid",
	      PL_origfilename);
    return on_nosuid;
a1517 1
#endif /* IAMSUID */
d1519 4
a1522 2
STATIC void
validate_suid(char *validarg, char *scriptname, int fdscript)
d1547 1
a1547 2
    dTHR;
    char *s, *s2;
d1549 3
a1551 3
    if (PerlLIO_fstat(PerlIO_fileno(PL_rsfp),&PL_statbuf) < 0)	/* normal stat is insecure */
	croak("Can't stat script \"%s\"",PL_origfilename);
    if (fdscript < 0 && PL_statbuf.st_mode & (S_ISUID|S_ISGID)) {
a1552 1
	STRLEN n_a;
d1564 1
a1564 1
	if (PerlLIO_access(SvPVX(GvSV(PL_curcop->cop_filegv)),1)) /*double check*/
d1577 1
a1577 1
		setreuid(PL_euid,PL_uid) < 0
d1580 1
a1580 1
		setresuid(PL_euid,PL_uid,(Uid_t)-1) < 0
d1583 1
a1583 1
		|| PerlProc_getuid() != PL_euid || PerlProc_geteuid() != PL_uid)
d1585 1
a1585 1
	    if (PerlLIO_stat(SvPVX(GvSV(PL_curcop->cop_filegv)),&tmpstatbuf) < 0)
d1587 12
a1598 16
#if defined(IAMSUID) && !defined(NO_NOSUID_CHECK)
	    if (fd_on_nosuid_fs(PerlIO_fileno(PL_rsfp)))
		croak("Permission denied");
#endif
	    if (tmpstatbuf.st_dev != PL_statbuf.st_dev ||
		tmpstatbuf.st_ino != PL_statbuf.st_ino) {
		(void)PerlIO_close(PL_rsfp);
		if (PL_rsfp = PerlProc_popen("/bin/mail root","w")) {	/* heh, heh */
		    PerlIO_printf(PL_rsfp,
"User %ld tried to run dev %ld ino %ld in place of dev %ld ino %ld!\n\
(Filename of set-id script was %s, uid %ld gid %ld.)\n\nSincerely,\nperl\n",
			(long)PL_uid,(long)tmpstatbuf.st_dev, (long)tmpstatbuf.st_ino,
			(long)PL_statbuf.st_dev, (long)PL_statbuf.st_ino,
			SvPVX(GvSV(PL_curcop->cop_filegv)),
			(long)PL_statbuf.st_uid, (long)PL_statbuf.st_gid);
		    (void)PerlProc_pclose(PL_rsfp);
d1604 1
a1604 1
              setreuid(PL_uid,PL_euid) < 0
d1607 1
a1607 1
              setresuid(PL_uid,PL_euid,(Uid_t)-1) < 0
d1610 1
a1610 1
              || PerlProc_getuid() != PL_uid || PerlProc_geteuid() != PL_euid)
d1612 1
a1612 1
	    if (!cando(S_IXUSR,FALSE,&PL_statbuf))		/* can real uid exec? */
d1618 1
a1618 1
	if (!S_ISREG(PL_statbuf.st_mode))
d1620 1
a1620 1
	if (PL_statbuf.st_mode & S_IWOTH)
d1622 4
a1625 4
	PL_doswitches = FALSE;		/* -s is insecure in suid */
	PL_curcop->cop_line++;
	if (sv_gets(PL_linestr, PL_rsfp, 0) == Nullch ||
	  strnNE(SvPV(PL_linestr,n_a),"#!",2) )	/* required even on Sys V */
d1627 1
a1627 1
	s = SvPV(PL_linestr,n_a)+2;
d1630 1
a1630 3
	for (s2 = s;  (s2 > SvPV(PL_linestr,n_a)+2 &&
		       (isDIGIT(s2[-1]) || strchr("._-", s2[-1])));  s2--) ;
	if (strnNE(s2-4,"perl",4) && strnNE(s-9,"perl",4))  /* sanity check */
d1644 3
a1646 3
	if (PL_euid != PL_uid && (PL_statbuf.st_mode & S_ISUID) &&
	    PL_euid == PL_statbuf.st_uid)
	    if (!PL_do_undump)
d1651 2
a1652 2
	if (PL_euid) {	/* oops, we're not the setuid root perl */
	    (void)PerlIO_close(PL_rsfp);
d1654 2
a1655 2
	    /* try again */
	    PerlProc_execv(form("%s/sperl%s", BIN_EXP, PL_patchlevel), PL_origargv);
d1660 1
a1660 1
	if (PL_statbuf.st_mode & S_ISGID && PL_statbuf.st_gid != PL_egid) {
d1662 1
a1662 1
	    (void)setegid(PL_statbuf.st_gid);
d1665 1
a1665 1
           (void)setregid((Gid_t)-1,PL_statbuf.st_gid);
d1668 1
a1668 1
           (void)setresgid((Gid_t)-1,PL_statbuf.st_gid,(Gid_t)-1);
d1670 1
a1670 1
	    PerlProc_setgid(PL_statbuf.st_gid);
d1674 1
a1674 1
	    if (PerlProc_getegid() != PL_statbuf.st_gid)
d1677 2
a1678 2
	if (PL_statbuf.st_mode & S_ISUID) {
	    if (PL_statbuf.st_uid != PL_euid)
d1680 1
a1680 1
		(void)seteuid(PL_statbuf.st_uid);	/* all that for this */
d1683 1
a1683 1
                (void)setreuid((Uid_t)-1,PL_statbuf.st_uid);
d1686 1
a1686 1
                (void)setresuid((Uid_t)-1,PL_statbuf.st_uid,(Uid_t)-1);
d1688 1
a1688 1
		PerlProc_setuid(PL_statbuf.st_uid);
d1692 1
a1692 1
	    if (PerlProc_geteuid() != PL_statbuf.st_uid)
d1695 1
a1695 1
	else if (PL_uid) {			/* oops, mustn't run as root */
d1697 1
a1697 1
          (void)seteuid((Uid_t)PL_uid);
d1700 1
a1700 1
          (void)setreuid((Uid_t)-1,(Uid_t)PL_uid);
d1703 1
a1703 1
          (void)setresuid((Uid_t)-1,(Uid_t)PL_uid,(Uid_t)-1);
d1705 1
a1705 1
          PerlProc_setuid((Uid_t)PL_uid);
d1709 1
a1709 1
	    if (PerlProc_geteuid() != PL_uid)
d1713 1
a1713 1
	if (!cando(S_IXUSR,TRUE,&PL_statbuf))
d1717 1
a1717 1
    else if (PL_preprocess)
d1727 3
a1729 4
    PerlIO_rewind(PL_rsfp);
    PerlLIO_lseek(PerlIO_fileno(PL_rsfp),(Off_t)0,0);  /* just in case rewind didn't */
    for (which = 1; PL_origargv[which] && PL_origargv[which] != scriptname; which++) ;
    if (!PL_origargv[which])
d1731 3
a1733 2
    PL_origargv[which] = savepv(form("/dev/fd/%d/%s",
				  PerlIO_fileno(PL_rsfp), PL_origargv[which]));
d1735 1
a1735 1
    fcntl(PerlIO_fileno(PL_rsfp),F_SETFD,0);	/* ensure no close-on-exec */
d1737 3
a1739 1
    PerlProc_execv(form("%s/perl%s", BIN_EXP, PL_patchlevel), PL_origargv);/* try again */
d1743 1
a1743 1
    if (PL_euid != PL_uid || PL_egid != PL_gid) {	/* (suidperl doesn't exist, in fact) */
d1745 2
a1746 3
	dTHR;
	PerlLIO_fstat(PerlIO_fileno(PL_rsfp),&PL_statbuf);	/* may be either wrapped or real suid */
	if ((PL_euid != PL_uid && PL_euid == PL_statbuf.st_uid && PL_statbuf.st_mode & S_ISUID)
d1748 1
a1748 1
	    (PL_egid != PL_gid && PL_egid == PL_statbuf.st_gid && PL_statbuf.st_mode & S_ISGID)
d1750 1
a1750 1
	    if (!PL_do_undump)
d1759 2
a1760 2
STATIC void
find_beginning(void)
d1762 1
a1762 1
    register char *s, *s2;
d1766 3
a1768 3
    forbid_setid("-x");
    while (PL_doextract) {
	if ((s = sv_gets(PL_linestr, PL_rsfp, 0)) == Nullch)
d1770 7
a1776 11
	if (*s == '#' && s[1] == '!' && (s = instr(s,"perl"))) {
	    PerlIO_ungetc(PL_rsfp, '\n');		/* to keep line count right */
	    PL_doextract = FALSE;
	    while (*s && !(isSPACE (*s) || *s == '#')) s++;
	    s2 = s;
	    while (*s == ' ' || *s == '\t') s++;
	    if (*s++ == '-') {
		while (isDIGIT(s2[-1]) || strchr("-._", s2[-1])) s2--;
		if (strnEQ(s2-4,"perl",4))
		    /*SUPPRESS 530*/
		    while (s = moreswitches(s)) ;
d1778 2
a1779 2
	    if (PL_cddir && PerlDir_chdir(PL_cddir) < 0)
		croak("Can't chdir to %s",PL_cddir);
d1784 2
a1785 3

STATIC void
init_ids(void)
d1787 4
a1790 4
    PL_uid = (int)PerlProc_getuid();
    PL_euid = (int)PerlProc_geteuid();
    PL_gid = (int)PerlProc_getgid();
    PL_egid = (int)PerlProc_getegid();
d1792 2
a1793 2
    PL_uid |= PL_gid << 16;
    PL_euid |= PL_egid << 16;
d1795 1
a1795 1
    PL_tainting |= (PL_uid && (PL_euid != PL_uid || PL_egid != PL_gid));
d1798 2
a1799 2
STATIC void
forbid_setid(char *s)
d1801 50
a1850 24
    if (PL_euid != PL_uid)
        croak("No %s allowed while running setuid", s);
    if (PL_egid != PL_gid)
        croak("No %s allowed while running setgid", s);
}

STATIC void
init_debugger(void)
{
    dTHR;
    PL_curstash = PL_debstash;
    PL_dbargs = GvAV(gv_AVadd((gv_fetchpv("args", GV_ADDMULTI, SVt_PVAV))));
    AvREAL_off(PL_dbargs);
    PL_DBgv = gv_fetchpv("DB", GV_ADDMULTI, SVt_PVGV);
    PL_DBline = gv_fetchpv("dbline", GV_ADDMULTI, SVt_PVAV);
    PL_DBsub = gv_HVadd(gv_fetchpv("sub", GV_ADDMULTI, SVt_PVHV));
    PL_DBsingle = GvSV((gv_fetchpv("single", GV_ADDMULTI, SVt_PV)));
    sv_setiv(PL_DBsingle, 0); 
    PL_DBtrace = GvSV((gv_fetchpv("trace", GV_ADDMULTI, SVt_PV)));
    sv_setiv(PL_DBtrace, 0); 
    PL_DBsignal = GvSV((gv_fetchpv("signal", GV_ADDMULTI, SVt_PV)));
    sv_setiv(PL_DBsignal, 0); 
    PL_curstash = PL_defstash;
}
a1851 64
#ifndef STRESS_REALLOC
#define REASONABLE(size) (size)
#else
#define REASONABLE(size) (1) /* unreasonable */
#endif

void
init_stacks(ARGSproto)
{
    /* start with 128-item stack and 8K cxstack */
    PL_curstackinfo = new_stackinfo(REASONABLE(128),
				 REASONABLE(8192/sizeof(PERL_CONTEXT) - 1));
    PL_curstackinfo->si_type = PERLSI_MAIN;
    PL_curstack = PL_curstackinfo->si_stack;
    PL_mainstack = PL_curstack;		/* remember in case we switch stacks */

    PL_stack_base = AvARRAY(PL_curstack);
    PL_stack_sp = PL_stack_base;
    PL_stack_max = PL_stack_base + AvMAX(PL_curstack);

    New(50,PL_tmps_stack,REASONABLE(128),SV*);
    PL_tmps_floor = -1;
    PL_tmps_ix = -1;
    PL_tmps_max = REASONABLE(128);

    New(54,PL_markstack,REASONABLE(32),I32);
    PL_markstack_ptr = PL_markstack;
    PL_markstack_max = PL_markstack + REASONABLE(32);

    SET_MARKBASE;

    New(54,PL_scopestack,REASONABLE(32),I32);
    PL_scopestack_ix = 0;
    PL_scopestack_max = REASONABLE(32);

    New(54,PL_savestack,REASONABLE(128),ANY);
    PL_savestack_ix = 0;
    PL_savestack_max = REASONABLE(128);

    New(54,PL_retstack,REASONABLE(16),OP*);
    PL_retstack_ix = 0;
    PL_retstack_max = REASONABLE(16);
}

#undef REASONABLE

STATIC void
nuke_stacks(void)
{
    dTHR;
    while (PL_curstackinfo->si_next)
	PL_curstackinfo = PL_curstackinfo->si_next;
    while (PL_curstackinfo) {
	PERL_SI *p = PL_curstackinfo->si_prev;
	/* curstackinfo->si_stack got nuked by sv_free_arenas() */
	Safefree(PL_curstackinfo->si_cxstack);
	Safefree(PL_curstackinfo);
	PL_curstackinfo = p;
    }
    Safefree(PL_tmps_stack);
    Safefree(PL_markstack);
    Safefree(PL_scopestack);
    Safefree(PL_savestack);
    Safefree(PL_retstack);
d1853 2
a1854 2
	Safefree(PL_debname);
	Safefree(PL_debdelim);
d1858 5
a1862 3
#ifndef PERL_OBJECT
static PerlIO *tmpfp;  /* moved outside init_lexer() because of UNICOS bug */
#endif
d1864 3
a1866 11
STATIC void
init_lexer(void)
{
#ifdef PERL_OBJECT
	PerlIO *tmpfp;
#endif
    tmpfp = PL_rsfp;
    PL_rsfp = Nullfp;
    lex_start(PL_linestr);
    PL_rsfp = tmpfp;
    PL_subname = newSVpv("main",4);
d1869 2
a1870 2
STATIC void
init_predump_symbols(void)
a1871 1
    dTHR;
d1875 5
a1879 4
    sv_setpvn(perl_get_sv("\"", TRUE), " ", 1);
    PL_stdingv = gv_fetchpv("STDIN",TRUE, SVt_PVIO);
    GvMULTI_on(PL_stdingv);
    IoIFP(GvIOp(PL_stdingv)) = PerlIO_stdin();
d1882 1
a1882 1
    GvIOp(tmpgv) = (IO*)SvREFCNT_inc(GvIOp(PL_stdingv));
d1886 1
a1886 1
    IoOFP(GvIOp(tmpgv)) = IoIFP(GvIOp(tmpgv)) = PerlIO_stdout();
d1890 1
a1890 1
    GvIOp(tmpgv) = (IO*)SvREFCNT_inc(GvIOp(PL_defoutgv));
d1894 1
a1894 1
    IoOFP(GvIOp(othergv)) = IoIFP(GvIOp(othergv)) = PerlIO_stderr();
d1899 1
a1899 1
    PL_statname = NEWSV(66,0);		/* last filename we did stat on */
d1901 1
a1901 2
    if (!PL_osname)
	PL_osname = savepv(OSNAME);
d1904 5
a1908 2
STATIC void
init_postdump_symbols(register int argc, register char **argv, register char **env)
a1909 1
    dTHR;
d1915 1
a1915 1
    if (PL_doswitches) {
d1931 7
a1937 7
    PL_toptarget = NEWSV(0,0);
    sv_upgrade(PL_toptarget, SVt_PVFM);
    sv_setpvn(PL_toptarget, "", 0);
    PL_bodytarget = NEWSV(0,0);
    sv_upgrade(PL_bodytarget, SVt_PVFM);
    sv_setpvn(PL_bodytarget, "", 0);
    PL_formtarget = PL_bodytarget;
d1939 1
a1939 1
    TAINT;
d1941 1
a1941 1
	sv_setpv(GvSV(tmpgv),PL_origfilename);
d1944 2
d1947 5
a1951 5
	sv_setpv(GvSV(tmpgv),PL_origargv[0]);
    if (PL_argvgv = gv_fetchpv("ARGV",TRUE, SVt_PVAV)) {
	GvMULTI_on(PL_argvgv);
	(void)gv_AVadd(PL_argvgv);
	av_clear(GvAVn(PL_argvgv));
d1953 1
a1953 1
	    av_push(GvAVn(PL_argvgv),newSVpv(argv[0],0));
d1956 1
a1956 1
    if (PL_envgv = gv_fetchpv("ENV",TRUE, SVt_PVHV)) {
d1958 3
a1960 3
	GvMULTI_on(PL_envgv);
	hv = GvHVn(PL_envgv);
	hv_magic(hv, PL_envgv, 'E');
d1969 1
a1969 1
	if (env != environ)
d1971 2
a1976 3
#if defined(MSDOS)
	    (void)strupr(*env);
#endif
d1978 1
a1980 4
#if defined(__BORLANDC__) && defined(USE_WIN32_RTL_ENV)
	    /* Sins of the RTL. See note in my_setenv(). */
	    (void)PerlEnv_putenv(savepv(*env));
#endif
d1986 1
d1988 1
a1988 1
    TAINT_NOT;
d1990 2
a1991 1
	sv_setiv(GvSV(tmpgv), (IV)getpid());
d1994 2
a1995 2
STATIC void
init_perllib(void)
d1998 2
a1999 3
    if (!PL_tainting) {
#ifndef VMS
	s = PerlEnv_getenv("PERL5LIB");
d2001 1
a2001 1
	    incpush(s, TRUE);
d2003 1
a2003 13
	    incpush(PerlEnv_getenv("PERLLIB"), FALSE);
#else /* VMS */
	/* Treat PERL5?LIB as a possible search list logical name -- the
	 * "natural" VMS idiom for a Unix path string.  We allow each
	 * element to be a set of |-separated directories for compatibility.
	 */
	char buf[256];
	int idx = 0;
	if (my_trnlnm("PERL5LIB",buf,0))
	    do { incpush(buf,TRUE); } while (my_trnlnm("PERL5LIB",buf,++idx));
	else
	    while (my_trnlnm("PERLLIB",buf,idx++)) incpush(buf,FALSE);
#endif /* VMS */
a2005 3
/* Use the ~-expanded versions of APPLLIB (undocumented),
    ARCHLIB PRIVLIB SITEARCH and SITELIB 
*/
d2007 1
a2007 1
    incpush(APPLLIB_EXP, TRUE);
d2011 1
a2011 1
    incpush(ARCHLIB_EXP, FALSE);
d2016 1
a2016 5
#if defined(WIN32) 
    incpush(PRIVLIB_EXP, TRUE);
#else
    incpush(PRIVLIB_EXP, FALSE);
#endif
d2019 1
a2019 1
    incpush(SITEARCH_EXP, FALSE);
d2022 1
a2022 4
#if defined(WIN32) 
    incpush(SITELIB_EXP, TRUE);
#else
    incpush(SITELIB_EXP, FALSE);
d2024 2
d2027 3
a2029 172
    if (!PL_tainting)
	incpush(".", FALSE);
}

#if defined(DOSISH)
#    define PERLLIB_SEP ';'
#else
#  if defined(VMS)
#    define PERLLIB_SEP '|'
#  else
#    define PERLLIB_SEP ':'
#  endif
#endif
#ifndef PERLLIB_MANGLE
#  define PERLLIB_MANGLE(s,n) (s)
#endif 

STATIC void
incpush(char *p, int addsubdirs)
{
    SV *subdir = Nullsv;

    if (!p)
	return;

    if (addsubdirs) {
	subdir = sv_newmortal();
	if (!PL_archpat_auto) {
	    STRLEN len = (sizeof(ARCHNAME) + strlen(PL_patchlevel)
			  + sizeof("//auto"));
	    New(55, PL_archpat_auto, len, char);
	    sprintf(PL_archpat_auto, "/%s/%s/auto", ARCHNAME, PL_patchlevel);
#ifdef VMS
	for (len = sizeof(ARCHNAME) + 2;
	     PL_archpat_auto[len] != '\0' && PL_archpat_auto[len] != '/'; len++)
		if (PL_archpat_auto[len] == '.') PL_archpat_auto[len] = '_';
#endif
	}
    }

    /* Break at all separators */
    while (p && *p) {
	SV *libdir = NEWSV(55,0);
	char *s;

	/* skip any consecutive separators */
	while ( *p == PERLLIB_SEP ) {
	    /* Uncomment the next line for PATH semantics */
	    /* av_push(GvAVn(PL_incgv), newSVpv(".", 1)); */
	    p++;
	}

	if ( (s = strchr(p, PERLLIB_SEP)) != Nullch ) {
	    sv_setpvn(libdir, PERLLIB_MANGLE(p, (STRLEN)(s - p)),
		      (STRLEN)(s - p));
	    p = s + 1;
	}
	else {
	    sv_setpv(libdir, PERLLIB_MANGLE(p, 0));
	    p = Nullch;	/* break out */
	}

	/*
	 * BEFORE pushing libdir onto @@INC we may first push version- and
	 * archname-specific sub-directories.
	 */
	if (addsubdirs) {
	    struct stat tmpstatbuf;
#ifdef VMS
	    char *unix;
	    STRLEN len;

	    if ((unix = tounixspec_ts(SvPV(libdir,len),Nullch)) != Nullch) {
		len = strlen(unix);
		while (unix[len-1] == '/') len--;  /* Cosmetic */
		sv_usepvn(libdir,unix,len);
	    }
	    else
		PerlIO_printf(PerlIO_stderr(),
		              "Failed to unixify @@INC element \"%s\"\n",
			      SvPV(libdir,len));
#endif
	    /* .../archname/version if -d .../archname/version/auto */
	    sv_setsv(subdir, libdir);
	    sv_catpv(subdir, PL_archpat_auto);
	    if (PerlLIO_stat(SvPVX(subdir), &tmpstatbuf) >= 0 &&
		  S_ISDIR(tmpstatbuf.st_mode))
		av_push(GvAVn(PL_incgv),
			newSVpv(SvPVX(subdir), SvCUR(subdir) - sizeof "auto"));

	    /* .../archname if -d .../archname/auto */
	    sv_insert(subdir, SvCUR(libdir) + sizeof(ARCHNAME),
		      strlen(PL_patchlevel) + 1, "", 0);
	    if (PerlLIO_stat(SvPVX(subdir), &tmpstatbuf) >= 0 &&
		  S_ISDIR(tmpstatbuf.st_mode))
		av_push(GvAVn(PL_incgv),
			newSVpv(SvPVX(subdir), SvCUR(subdir) - sizeof "auto"));
	}

	/* finally push this lib directory on the end of @@INC */
	av_push(GvAVn(PL_incgv), libdir);
    }
}

#ifdef USE_THREADS
STATIC struct perl_thread *
init_main_thread()
{
    struct perl_thread *thr;
    XPV *xpv;

    Newz(53, thr, 1, struct perl_thread);
    PL_curcop = &PL_compiling;
    thr->cvcache = newHV();
    thr->threadsv = newAV();
    /* thr->threadsvp is set when find_threadsv is called */
    thr->specific = newAV();
    thr->errhv = newHV();
    thr->flags = THRf_R_JOINABLE;
    MUTEX_INIT(&thr->mutex);
    /* Handcraft thrsv similarly to mess_sv */
    New(53, PL_thrsv, 1, SV);
    Newz(53, xpv, 1, XPV);
    SvFLAGS(PL_thrsv) = SVt_PV;
    SvANY(PL_thrsv) = (void*)xpv;
    SvREFCNT(PL_thrsv) = 1 << 30;	/* practically infinite */
    SvPVX(PL_thrsv) = (char*)thr;
    SvCUR_set(PL_thrsv, sizeof(thr));
    SvLEN_set(PL_thrsv, sizeof(thr));
    *SvEND(PL_thrsv) = '\0';	/* in the trailing_nul field */
    thr->oursv = PL_thrsv;
    PL_chopset = " \n-";

    MUTEX_LOCK(&PL_threads_mutex);
    PL_nthreads++;
    thr->tid = 0;
    thr->next = thr;
    thr->prev = thr;
    MUTEX_UNLOCK(&PL_threads_mutex);

#ifdef HAVE_THREAD_INTERN
    init_thread_intern(thr);
#endif

#ifdef SET_THREAD_SELF
    SET_THREAD_SELF(thr);
#else
    thr->self = pthread_self();
#endif /* SET_THREAD_SELF */
    SET_THR(thr);

    /*
     * These must come after the SET_THR because sv_setpvn does
     * SvTAINT and the taint fields require dTHR.
     */
    PL_toptarget = NEWSV(0,0);
    sv_upgrade(PL_toptarget, SVt_PVFM);
    sv_setpvn(PL_toptarget, "", 0);
    PL_bodytarget = NEWSV(0,0);
    sv_upgrade(PL_bodytarget, SVt_PVFM);
    sv_setpvn(PL_bodytarget, "", 0);
    PL_formtarget = PL_bodytarget;
    thr->errsv = newSVpv("", 0);
    (void) find_threadsv("@@");	/* Ensure $@@ is initialised early */

    PL_maxscream = -1;
    PL_regcompp = FUNC_NAME_TO_PTR(pregcomp);
    PL_regexecp = FUNC_NAME_TO_PTR(regexec_flags);
    PL_regindent = 0;
    PL_reginterp_cnt = 0;

    return thr;
a2030 1
#endif /* USE_THREADS */
d2033 2
a2034 1
call_list(I32 oldscope, AV *paramList)
d2036 1
a2036 2
    dTHR;
    line_t oldline = PL_curcop->cop_line;
d2038 3
a2040 2
    dJMPENV;
    int ret;
d2042 2
a2043 2
    while (AvFILL(paramList) >= 0) {
	CV *cv = (CV*)av_shift(paramList);
d2047 1
a2047 2
	JMPENV_PUSH(ret);
	switch (ret) {
d2049 2
a2050 2
		SV* atsv = ERRSV;
		PUSHMARK(PL_stack_sp);
d2054 4
a2057 4
		    JMPENV_POP;
		    PL_curcop = &PL_compiling;
		    PL_curcop->cop_line = oldline;
		    if (paramList == PL_beginav)
a2060 2
		    while (PL_scopestack_ix > oldscope)
			LEAVE;
d2066 5
a2070 1
	    STATUS_ALL_FAILURE;
d2074 3
a2076 2
	    while (PL_scopestack_ix > oldscope)
		LEAVE;
d2078 5
a2082 8
	    PL_curstash = PL_defstash;
	    if (PL_endav)
		call_list(oldscope, PL_endav);
	    JMPENV_POP;
	    PL_curcop = &PL_compiling;
	    PL_curcop->cop_line = oldline;
	    if (PL_statusvalue) {
		if (paramList == PL_beginav)
d2087 1
a2087 1
	    my_exit_jump();
d2089 1
d2091 2
a2092 2
	    if (!PL_restartop) {
		PerlIO_printf(PerlIO_stderr(), "panic: restartop\n");
d2096 4
a2099 4
	    JMPENV_POP;
	    PL_curcop = &PL_compiling;
	    PL_curcop->cop_line = oldline;
	    JMPENV_JUMP(3);
a2100 1
	JMPENV_POP;
a2101 1
}
d2103 1
a2103 19
void
my_exit(U32 status)
{
    dTHR;

    DEBUG_S(PerlIO_printf(Perl_debug_log, "my_exit: thread %p, status %lu\n",
			  thr, (unsigned long) status));
    switch (status) {
    case 0:
	STATUS_ALL_SUCCESS;
	break;
    case 1:
	STATUS_ALL_FAILURE;
	break;
    default:
	STATUS_NATIVE_SET(status);
	break;
    }
    my_exit_jump();
a2104 80

void
my_failure_exit(void)
{
#ifdef VMS
    if (vaxc$errno & 1) {
	if (STATUS_NATIVE & 1)		/* fortuitiously includes "-1" */
	    STATUS_NATIVE_SET(44);
    }
    else {
	if (!vaxc$errno && errno)	/* unlikely */
	    STATUS_NATIVE_SET(44);
	else
	    STATUS_NATIVE_SET(vaxc$errno);
    }
#else
    int exitstatus;
    if (errno & 255)
	STATUS_POSIX_SET(errno);
    else {
	exitstatus = STATUS_POSIX >> 8; 
	if (exitstatus & 255)
	    STATUS_POSIX_SET(exitstatus);
	else
	    STATUS_POSIX_SET(255);
    }
#endif
    my_exit_jump();
}

STATIC void
my_exit_jump(void)
{
    dSP;
    register PERL_CONTEXT *cx;
    I32 gimme;
    SV **newsp;

    if (PL_e_script) {
	SvREFCNT_dec(PL_e_script);
	PL_e_script = Nullsv;
    }

    POPSTACK_TO(PL_mainstack);
    if (cxstack_ix >= 0) {
	if (cxstack_ix > 0)
	    dounwind(0);
	POPBLOCK(cx,PL_curpm);
	LEAVE;
    }

    JMPENV_JUMP(2);
}

#ifdef PERL_OBJECT
#define NO_XSLOCKS
#endif  /* PERL_OBJECT */

#include "XSUB.h"

static I32
#ifdef PERL_OBJECT
read_e_script(CPerlObj *pPerl, int idx, SV *buf_sv, int maxlen)
#else
read_e_script(int idx, SV *buf_sv, int maxlen)
#endif
{
    char *p, *nl;
    p  = SvPVX(PL_e_script);
    nl = strchr(p, '\n');
    nl = (nl) ? nl+1 : SvEND(PL_e_script);
    if (nl-p == 0) {
	filter_del(read_e_script);
	return 0;
    }
    sv_catpvn(buf_sv, p, nl-p);
    sv_chop(PL_e_script, nl);
    return 1;
}

@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d3 1
a3 1
 *    Copyright (c) 1987-2000 Larry Wall
a14 1
#define PERL_IN_PERL_C
d16 1
a16 1
#include "patchlevel.h"			/* for local_patches */
d24 1
a24 1
char *getenv (char *); /* Usually in <stdlib.h> */
d27 6
a32 1
static I32 read_e_script(pTHXo_ int idx, SV *buf_sv, int maxlen);
d47 25
a71 40
#define perl_construct	Perl_construct
#define perl_parse	Perl_parse
#define perl_run	Perl_run
#define perl_destruct	Perl_destruct
#define perl_free	Perl_free
#endif

#if defined(USE_THREADS)
#  define INIT_TLS_AND_INTERP \
    STMT_START {				\
	if (!PL_curinterp) {			\
	    PERL_SET_INTERP(my_perl);		\
	    INIT_THREADS;			\
	    ALLOC_THREAD_KEY;			\
	}					\
    } STMT_END
#else
#  if defined(USE_ITHREADS)
#  define INIT_TLS_AND_INTERP \
    STMT_START {				\
	if (!PL_curinterp) {			\
	    PERL_SET_INTERP(my_perl);		\
	    INIT_THREADS;			\
	    ALLOC_THREAD_KEY;			\
	    PERL_SET_THX(my_perl);		\
	    OP_REFCNT_INIT;			\
	}					\
	else {					\
	    PERL_SET_THX(my_perl);		\
	}					\
    } STMT_END
#  else
#  define INIT_TLS_AND_INTERP \
    STMT_START {				\
	if (!PL_curinterp) {			\
	    PERL_SET_INTERP(my_perl);		\
	}					\
	PERL_SET_THX(my_perl);			\
    } STMT_END
#  endif
d74 3
a76 7
#ifdef PERL_IMPLICIT_SYS
PerlInterpreter *
perl_alloc_using(struct IPerlMem* ipM, struct IPerlMem* ipMS,
		 struct IPerlMem* ipMP, struct IPerlEnv* ipE,
		 struct IPerlStdIO* ipStd, struct IPerlLIO* ipLIO,
		 struct IPerlDir* ipD, struct IPerlSock* ipS,
		 struct IPerlProc* ipP)
d78 3
a80 20
    PerlInterpreter *my_perl;
#ifdef PERL_OBJECT
    my_perl = (PerlInterpreter*)new(ipM) CPerlObj(ipM, ipMS, ipMP, ipE, ipStd,
						  ipLIO, ipD, ipS, ipP);
    INIT_TLS_AND_INTERP;
#else
    /* New() needs interpreter, so call malloc() instead */
    my_perl = (PerlInterpreter*)(*ipM->pMalloc)(ipM, sizeof(PerlInterpreter));
    INIT_TLS_AND_INTERP;
    Zero(my_perl, 1, PerlInterpreter);
    PL_Mem = ipM;
    PL_MemShared = ipMS;
    PL_MemParse = ipMP;
    PL_Env = ipE;
    PL_StdIO = ipStd;
    PL_LIO = ipLIO;
    PL_Dir = ipD;
    PL_Sock = ipS;
    PL_Proc = ipP;
#endif
d82 1
a82 1
    return my_perl;
a84 9

/*
=for apidoc perl_alloc

Allocates a new Perl interpreter.  See L<perlembed>.

=cut
*/

d88 1
a88 4
    PerlInterpreter *my_perl;

    /* New() needs interpreter, so call malloc() instead */
    my_perl = (PerlInterpreter*)PerlMem_malloc(sizeof(PerlInterpreter));
d90 3
a92 3
    INIT_TLS_AND_INTERP;
    Zero(my_perl, 1, PerlInterpreter);
    return my_perl;
d94 1
a94 9
#endif /* PERL_IMPLICIT_SYS */

/*
=for apidoc perl_construct

Initializes a new Perl interpreter.  See L<perlembed>.

=cut
*/
d97 5
a101 1
perl_construct(pTHXx)
d106 1
a106 1
    struct perl_thread *thr = NULL;
d109 5
d116 2
a117 5
    init_interp();
    PL_perl_destruct_level = 1; 
#else
   if (PL_perl_destruct_level > 0)
       init_interp();
d123 8
d132 1
d141 1
a141 1
#  ifdef EMULATE_ATOMIC_REFCOUNTS
d143 1
a143 1
#  endif /* EMULATE_ATOMIC_REFCOUNTS */
a144 2
	MUTEX_INIT(&PL_cred_mutex);

a147 6
#ifdef PERL_FLEXIBLE_EXCEPTIONS
	PL_protect = MEMBER_TO_FPTR(Perl_default_protect); /* for exceptions */
#endif

	PL_curcop = &PL_compiling;	/* needed by ckWARN, right away */

d173 1
a173 1
	PL_sighandlerp = Perl_sighandler;
d188 1
a188 1
    PL_nrs = newSVpvn("\n", 1);
d191 8
a198 1
    init_stacks();
d203 4
a206 1
    JMPENV_BOOTSTRAP;
a208 1
    init_i18nl10n(1);
d210 8
a217 24

    {
	U8 *s;
	PL_patchlevel = NEWSV(0,4);
	(void)SvUPGRADE(PL_patchlevel, SVt_PVNV);
	if (PERL_REVISION > 127 || PERL_VERSION > 127 || PERL_SUBVERSION > 127)
	    SvGROW(PL_patchlevel, UTF8_MAXLEN*3+1);
	s = (U8*)SvPVX(PL_patchlevel);
	s = uv_to_utf8(s, (UV)PERL_REVISION);
	s = uv_to_utf8(s, (UV)PERL_VERSION);
	s = uv_to_utf8(s, (UV)PERL_SUBVERSION);
	*s = '\0';
	SvCUR_set(PL_patchlevel, s - (U8*)SvPVX(PL_patchlevel));
	SvPOK_on(PL_patchlevel);
	SvNVX(PL_patchlevel) = (NV)PERL_REVISION
				+ ((NV)PERL_VERSION / (NV)1000)
#if defined(PERL_SUBVERSION) && PERL_SUBVERSION > 0
				+ ((NV)PERL_SUBVERSION / (NV)1000000)
#endif
				;
	SvNOK_on(PL_patchlevel);	/* dual valued */
	SvUTF8_on(PL_patchlevel);
	SvREADONLY_on(PL_patchlevel);
    }
d228 5
a235 8
/*
=for apidoc perl_destruct

Shuts down a Perl interpreter.  See L<perlembed>.

=cut
*/

d237 5
a241 1
perl_destruct(pTHXx)
a248 1
    dTHX;
d251 4
a254 2
    /* wait for all pseudo-forked children to finish */
    PERL_WAIT_FOR_CHILDREN;
d261 1
a261 1
    DEBUG_S(PerlIO_printf(Perl_debug_log,
d269 1
a269 1
	    DEBUG_S(PerlIO_printf(Perl_debug_log,
d283 1
a283 1
	    DEBUG_S(PerlIO_printf(Perl_debug_log,
d287 1
a287 1
	    DEBUG_S(PerlIO_printf(Perl_debug_log,
d301 1
a301 1
	    DEBUG_S(PerlIO_printf(Perl_debug_log,
d313 1
a313 1
	DEBUG_S(PerlIO_printf(Perl_debug_log,
d320 1
a320 1
    DEBUG_S(PerlIO_printf(Perl_debug_log, "perl_destruct: armageddon has arrived\n"));
d330 1
a330 1
	if ((s = PerlEnv_getenv("PERL_DESTRUCT_LEVEL"))) {
d341 4
a356 1
    PL_dirty = TRUE;
d364 2
d374 2
d379 1
a379 1
	PL_exitlist[PL_exitlistlen].fn(aTHXo_ PL_exitlist[PL_exitlistlen].ptr);
d410 1
a410 1
    PL_dowarn       = G_WARN_OFF;
d413 2
a418 1
    SvREFCNT_dec(PL_patchlevel);
d427 1
a427 1
    Safefree(PL_ofs);		/* $, */
d430 1
a430 1
    Safefree(PL_ors);		/* $\ */
d439 1
a439 3
    PL_multiline = 0;		/* $* */
    Safefree(PL_osname);	/* $^O */
    PL_osname = Nullch;
a454 5
    /* float buffer */
    Safefree(PL_efloatbuf);
    PL_efloatbuf = Nullch;
    PL_efloatsize = 0;

a457 1
    SvREFCNT_dec(PL_checkav);
a460 1
    PL_checkav = Nullav;
d465 1
a471 1
    PL_stderrgv = Nullgv;
a473 1
    PL_debstash = Nullhv;
a477 73
    SvREFCNT_dec(PL_argvout_stack);
    PL_argvout_stack = Nullav;

    SvREFCNT_dec(PL_modglobal);
    PL_modglobal = Nullhv;
    SvREFCNT_dec(PL_preambleav);
    PL_preambleav = Nullav;
    SvREFCNT_dec(PL_subname);
    PL_subname = Nullsv;
    SvREFCNT_dec(PL_linestr);
    PL_linestr = Nullsv;
    SvREFCNT_dec(PL_pidstatus);
    PL_pidstatus = Nullhv;
    SvREFCNT_dec(PL_toptarget);
    PL_toptarget = Nullsv;
    SvREFCNT_dec(PL_bodytarget);
    PL_bodytarget = Nullsv;
    PL_formtarget = Nullsv;

    /* free locale stuff */
#ifdef USE_LOCALE_COLLATE
    Safefree(PL_collation_name);
    PL_collation_name = Nullch;
#endif

#ifdef USE_LOCALE_NUMERIC
    Safefree(PL_numeric_name);
    PL_numeric_name = Nullch;
#endif

    /* clear utf8 character classes */
    SvREFCNT_dec(PL_utf8_alnum);
    SvREFCNT_dec(PL_utf8_alnumc);
    SvREFCNT_dec(PL_utf8_ascii);
    SvREFCNT_dec(PL_utf8_alpha);
    SvREFCNT_dec(PL_utf8_space);
    SvREFCNT_dec(PL_utf8_cntrl);
    SvREFCNT_dec(PL_utf8_graph);
    SvREFCNT_dec(PL_utf8_digit);
    SvREFCNT_dec(PL_utf8_upper);
    SvREFCNT_dec(PL_utf8_lower);
    SvREFCNT_dec(PL_utf8_print);
    SvREFCNT_dec(PL_utf8_punct);
    SvREFCNT_dec(PL_utf8_xdigit);
    SvREFCNT_dec(PL_utf8_mark);
    SvREFCNT_dec(PL_utf8_toupper);
    SvREFCNT_dec(PL_utf8_tolower);
    PL_utf8_alnum	= Nullsv;
    PL_utf8_alnumc	= Nullsv;
    PL_utf8_ascii	= Nullsv;
    PL_utf8_alpha	= Nullsv;
    PL_utf8_space	= Nullsv;
    PL_utf8_cntrl	= Nullsv;
    PL_utf8_graph	= Nullsv;
    PL_utf8_digit	= Nullsv;
    PL_utf8_upper	= Nullsv;
    PL_utf8_lower	= Nullsv;
    PL_utf8_print	= Nullsv;
    PL_utf8_punct	= Nullsv;
    PL_utf8_xdigit	= Nullsv;
    PL_utf8_mark	= Nullsv;
    PL_utf8_toupper	= Nullsv;
    PL_utf8_totitle	= Nullsv;
    PL_utf8_tolower	= Nullsv;

    if (!specialWARN(PL_compiling.cop_warnings))
	SvREFCNT_dec(PL_compiling.cop_warnings);
    PL_compiling.cop_warnings = Nullsv;
#ifndef USE_ITHREADS
    SvREFCNT_dec(CopFILEGV(&PL_compiling));
    CopFILEGV_set(&PL_compiling, Nullgv);
#endif

a482 6
    SvREFCNT_dec(PL_curstname);
    PL_curstname = Nullsv;

    /* clear queued errors */
    SvREFCNT_dec(PL_errors);
    PL_errors = Nullsv;
d485 1
a485 1
    if (destruct_level >= 2 && ckWARN_d(WARN_INTERNAL)) {
d487 1
a487 2
	    Perl_warner(aTHX_ WARN_INTERNAL,
	         "Unbalanced scopes: %ld more ENTERs than LEAVEs\n",
d490 1
a490 2
	    Perl_warner(aTHX_ WARN_INTERNAL,
		 "Unbalanced saves: %ld more saves than restores\n",
d493 1
a493 1
	    Perl_warner(aTHX_ WARN_INTERNAL,"Unbalanced tmps: %ld more allocs than frees\n",
d496 1
a496 1
	    Perl_warner(aTHX_ WARN_INTERNAL,"Unbalanced context: %ld more PUSHes than POPs\n",
a501 1
    SvFLAGS(PL_fdpid) |= SVTYPEMASK;		/* don't clean out pid table now */
a506 2
    SvFLAGS(PL_fdpid) &= ~SVTYPEMASK;
    SvFLAGS(PL_fdpid) |= SVt_PVAV;
d509 1
a509 5

    AvREAL_off(PL_fdpid);		/* no surviving entries */
    SvREFCNT_dec(PL_fdpid);		/* needed in io_close() */
    PL_fdpid = Nullav;

d525 2
a526 3
	    if (hent && ckWARN_d(WARN_INTERNAL)) {
		Perl_warner(aTHX_ WARN_INTERNAL,
		     "Unbalanced string table refcount: (%d) for \"%s\"",
d540 2
a541 17
    /* free special SVs */

    SvREFCNT(&PL_sv_yes) = 0;
    sv_clear(&PL_sv_yes);
    SvANY(&PL_sv_yes) = NULL;
    SvFLAGS(&PL_sv_yes) = 0;

    SvREFCNT(&PL_sv_no) = 0;
    sv_clear(&PL_sv_no);
    SvANY(&PL_sv_no) = NULL;
    SvFLAGS(&PL_sv_no) = 0;

    SvREFCNT(&PL_sv_undef) = 0;
    SvREADONLY_off(&PL_sv_undef);

    if (PL_sv_count != 0 && ckWARN_d(WARN_INTERNAL))
	Perl_warner(aTHX_ WARN_INTERNAL,"Scalars leaked: %ld\n", (long)PL_sv_count);
d546 2
d549 1
a550 3
    if (PL_reg_curpm)
	Safefree(PL_reg_curpm);
    Safefree(PL_reg_poscache);
d560 1
a561 1
    MUTEX_DESTROY(&PL_cred_mutex);
d573 1
a573 1

d589 1
a589 1
	(void)SvOOK_off(PL_mess_sv);
a596 8
/*
=for apidoc perl_free

Releases a Perl interpreter.  See L<perlembed>.

=cut
*/

d598 5
a602 1
perl_free(pTHXx)
d604 2
a605 2
#if defined(PERL_OBJECT)
    PerlMem_free(this);
d607 3
a609 7
#  if defined(PERL_IMPLICIT_SYS) && defined(WIN32)
    void *host = w32_internal_host;
    PerlMem_free(aTHXx);
    win32_delete_internal_host(host);
#  else
    PerlMem_free(aTHXx);
#  endif
d614 5
a618 1
Perl_call_atexit(pTHX_ ATEXIT_t fn, void *ptr)
a625 8
/*
=for apidoc perl_parse

Tells a Perl interpreter to parse a Perl script.  See L<perlembed>.

=cut
*/

d627 5
a631 1
perl_parse(pTHXx_ XSINIT_t xsinit, int argc, char **argv, char **env)
d634 5
d640 2
d643 1
a643 4
    dJMPENV;
#ifdef USE_THREADS
    dTHX;
#endif
d648 1
a648 1
    Perl_croak(aTHX_ "suidperl is no longer needed since the kernel can now execute\n\
d653 6
a658 1
#if defined(__DYNAMIC__) && (defined(NeXT) || defined(__NeXT__))
a691 1
    PL_dowarn = G_WARN_OFF;
a692 3
#ifdef PERL_FLEXIBLE_EXCEPTIONS
    CALLPROTECT(aTHX_ pcur_env, &ret, MEMBER_TO_FPTR(S_vparse_body), env, xsinit);
#else
a693 1
#endif
a694 8
    case 0:
#ifndef PERL_FLEXIBLE_EXCEPTIONS
	parse_body(env,xsinit);
#endif
	if (PL_checkav)
	    call_list(oldscope, PL_checkav);
	ret = 0;
	break;
d704 4
a707 4
	if (PL_checkav)
	    call_list(oldscope, PL_checkav);
	ret = STATUS_NATIVE_EXPORT;
	break;
d709 3
a711 3
	PerlIO_printf(Perl_error_log, "panic: top_env\n");
	ret = 1;
	break;
a712 29
    JMPENV_POP;
    return ret;
}

#ifdef PERL_FLEXIBLE_EXCEPTIONS
STATIC void *
S_vparse_body(pTHX_ va_list args)
{
    char **env = va_arg(args, char**);
    XSINIT_t xsinit = va_arg(args, XSINIT_t);

    return parse_body(env, xsinit);
}
#endif

STATIC void *
S_parse_body(pTHX_ char **env, XSINIT_t xsinit)
{
    dTHR;
    int argc = PL_origargc;
    char **argv = PL_origargv;
    char *scriptname = NULL;
    int fdscript = -1;
    VOL bool dosearch = FALSE;
    char *validarg = "";
    AV* comppadlist;
    register SV *sv;
    register char *s;
    char *cddir = Nullch;
d715 1
a715 1
    sv = newSVpvn("",0);		/* first used for -I flags */
a730 5
	case 'C':
#ifdef	WIN32
	    win32_argv2utf8(argc-1, argv+1);
	    /* FALL THROUGH */
#endif
a751 2
	case 'W':
	case 'X':
d753 1
a753 1
	    if ((s = moreswitches(s)))
d764 1
a764 1
		Perl_croak(aTHX_ "No -e allowed in setuid scripts");
d766 1
a766 1
		PL_e_script = newSVpvn("",0);
d776 1
a776 1
		Perl_croak(aTHX_ "No code specified for -e");
d785 2
d788 7
a794 7
		char *p;
		STRLEN len = strlen(s);
		p = savepvn(s, len);
		incpush(p, TRUE, TRUE);
		sv_catpvn(sv, "-I", 2);
		sv_catpvn(sv, p, len);
		sv_catpvn(sv, " ", 1);
d796 1
a796 3
	    }
	    else
		Perl_croak(aTHX_ "No directory specified for -I");
d819 1
d824 3
a829 30
#  ifdef USE_THREADS
		sv_catpv(PL_Sv," USE_THREADS");
#  endif
#  ifdef USE_ITHREADS
		sv_catpv(PL_Sv," USE_ITHREADS");
#  endif
#  ifdef USE_64_BIT_INT
		sv_catpv(PL_Sv," USE_64_BIT_INT");
#  endif
#  ifdef USE_64_BIT_ALL
		sv_catpv(PL_Sv," USE_64_BIT_ALL");
#  endif
#  ifdef USE_LONG_DOUBLE
		sv_catpv(PL_Sv," USE_LONG_DOUBLE");
#  endif
#  ifdef USE_LARGE_FILES
		sv_catpv(PL_Sv," USE_LARGE_FILES");
#  endif
#  ifdef USE_SOCKS
		sv_catpv(PL_Sv," USE_SOCKS");
#  endif
#  ifdef PERL_OBJECT
		sv_catpv(PL_Sv," PERL_OBJECT");
#  endif
#  ifdef PERL_IMPLICIT_CONTEXT
		sv_catpv(PL_Sv," PERL_IMPLICIT_CONTEXT");
#  endif
#  ifdef PERL_IMPLICIT_SYS
		sv_catpv(PL_Sv," PERL_IMPLICIT_SYS");
#  endif
d831 1
a831 1

d838 1
a838 1
			    Perl_sv_catpvf(aTHX_ PL_Sv,"q\"  \t%s\n\",",PL_localpatches[i]);
d842 1
a842 1
		Perl_sv_catpvf(aTHX_ PL_Sv,"\"  Built under %s\\n\"",OSNAME);
d845 1
a845 1
		Perl_sv_catpvf(aTHX_ PL_Sv,",\"  Compiled at %s %s\\n\"",__DATE__,__TIME__);
d847 1
a847 1
		Perl_sv_catpvf(aTHX_ PL_Sv,",\"  Compiled on %s\\n\"",__DATE__);
d869 1
a869 1
		cddir = s;
d890 1
a890 1
	    Perl_croak(aTHX_ "Unrecognized switch: -%s  (-h will show valid options)",s);
d895 8
a902 24
    if (
#ifndef SECURE_INTERNAL_GETENV
        !PL_tainting &&
#endif
	(s = PerlEnv_getenv("PERL5OPT")))
    {
	while (isSPACE(*s))
	    s++;
	if (*s == '-' && *(s+1) == 'T')
	    PL_tainting = TRUE;
	else {
	    while (s && *s) {
		while (isSPACE(*s))
		    s++;
		if (*s == '-') {
		    s++;
		    if (isSPACE(*s))
			continue;
		}
		if (!*s)
		    break;
		if (!strchr("DIMUdmw", *s))
		    Perl_croak(aTHX_ "Illegal switch in PERL5OPT: -%c", *s);
		s = moreswitches(s);
d904 5
d932 1
a932 16
#if defined(SIGCHLD) || defined(SIGCLD)
    {
#ifndef SIGCHLD
#  define SIGCHLD SIGCLD
#endif
	Sighandler_t sigstate = rsignal_state(SIGCHLD);
	if (sigstate == SIG_IGN) {
	    if (ckWARN(WARN_SIGNAL))
		Perl_warner(aTHX_ WARN_SIGNAL,
			    "Can't ignore signal CHLD, forcing to default");
	    (void)rsignal(SIGCHLD, (Sighandler_t)SIG_DFL);
	}
    }
#endif

    if (PL_doextract) {
a933 4
	if (cddir && PerlDir_chdir(cddir) < 0)
	    Perl_croak(aTHX_ "Can't chdir to %s",cddir);

    }
d947 1
a947 1
    av_store(PL_comppad_name, 0, newSVpvn("@@_", 2));
a961 3
#ifndef PERL_MICRO
    boot_core_xsutils();
#endif
d964 2
a965 2
	(*xsinit)(aTHXo);	/* in case linked C routines want magical variables */
#if defined(VMS) || defined(WIN32) || defined(DJGPP) || defined(__CYGWIN__)
a968 4
#ifdef USE_SOCKS
    SOCKSinit(argv[0]);
#endif    

d984 1
a984 1
	    Perl_croak(aTHX_ "%s had compilation errors.\n", PL_origfilename);
d986 2
a987 2
	    Perl_croak(aTHX_ "Execution of %s aborted due to compilation errors.\n",
		       PL_origfilename);
d990 1
a990 1
    CopLINE_set(PL_curcop, 0);
d1001 1
a1001 1
    sv_setsv(get_sv("/", TRUE), PL_rs);
d1005 1
a1005 3
    if (isWARN_ONCE) {
	SAVECOPFILE(PL_curcop);
	SAVECOPLINE(PL_curcop);
a1006 1
    }
d1018 2
a1019 1
    return NULL;
a1021 8
/*
=for apidoc perl_run

Tells a Perl interpreter to run.  See L<perlembed>.

=cut
*/

d1023 5
a1027 1
perl_run(pTHXx)
d1029 1
a1029 1
    dTHR;
a1030 1
    int ret = 0;
d1032 5
a1036 2
#ifdef USE_THREADS
    dTHX;
a1040 4
#ifdef PERL_FLEXIBLE_EXCEPTIONS
 redo_body:
    CALLPROTECT(aTHX_ pcur_env, &ret, MEMBER_TO_FPTR(S_vrun_body), oldscope);
#else
a1041 1
#endif
d1045 3
a1047 8
	goto redo_body;
    case 0:				/* normal completion */
#ifndef PERL_FLEXIBLE_EXCEPTIONS
 redo_body:
	run_body(oldscope);
#endif
	/* FALL THROUGH */
    case 2:				/* my_exit() */
d1052 1
a1052 1
	if (PL_endav && !PL_minus_c)
d1058 2
a1059 2
	ret = STATUS_NATIVE_EXPORT;
	break;
d1061 5
a1065 3
	if (PL_restartop) {
	    POPSTACK_TO(PL_mainstack);
	    goto redo_body;
d1067 1
a1067 3
	PerlIO_printf(Perl_error_log, "panic: restartop\n");
	FREETMPS;
	ret = 1;
a1070 20
    JMPENV_POP;
    return ret;
}

#ifdef PERL_FLEXIBLE_EXCEPTIONS
STATIC void *
S_vrun_body(pTHX_ va_list args)
{
    I32 oldscope = va_arg(args, I32);

    return run_body(oldscope);
}
#endif


STATIC void *
S_run_body(pTHX_ I32 oldscope)
{
    dTHR;

d1077 2
a1078 2
	DEBUG_S(PerlIO_printf(Perl_debug_log, "main thread is 0x%"UVxf"\n",
			      PTR2UV(thr)));
d1081 1
a1081 1
	    PerlIO_printf(Perl_error_log, "%s syntax OK\n", PL_origfilename);
d1085 1
a1085 1
	    sv_setiv(PL_DBsingle, 1); 
d1095 1
a1095 1
	CALLRUNOPS(aTHX);
d1100 1
a1100 1
	CALLRUNOPS(aTHX);
d1105 1
a1105 1
    return NULL;
a1107 10
/*
=for apidoc p||get_sv

Returns the SV of the specified Perl scalar.  If C<create> is set and the
Perl variable does not exist then it will be created.  If C<create> is not
set and the variable does not exist then NULL is returned.

=cut
*/

d1109 1
a1109 1
Perl_get_sv(pTHX_ const char *name, I32 create)
a1126 10
/*
=for apidoc p||get_av

Returns the AV of the specified Perl array.  If C<create> is set and the
Perl variable does not exist then it will be created.  If C<create> is not
set and the variable does not exist then NULL is returned.

=cut
*/

d1128 1
a1128 1
Perl_get_av(pTHX_ const char *name, I32 create)
a1137 10
/*
=for apidoc p||get_hv

Returns the HV of the specified Perl hash.  If C<create> is set and the
Perl variable does not exist then it will be created.  If C<create> is not
set and the variable does not exist then NULL is returned.

=cut
*/

d1139 1
a1139 1
Perl_get_hv(pTHX_ const char *name, I32 create)
a1148 11
/*
=for apidoc p||get_cv

Returns the CV of the specified Perl subroutine.  If C<create> is set and
the Perl subroutine does not exist then it will be declared (which has the
same effect as saying C<sub name;>).  If C<create> is not set and the
subroutine does not exist then NULL is returned.

=cut
*/

d1150 1
a1150 1
Perl_get_cv(pTHX_ const char *name, I32 create)
a1153 3
    /* XXX this is probably not what they think they're getting.
     * It has the same effect as "sub name;", i.e. just a forward
     * declaration! */
a1165 8
/*
=for apidoc p||call_argv

Performs a callback to the specified Perl sub.  See L<perlcall>.

=cut
*/

d1167 1
a1167 1
Perl_call_argv(pTHX_ const char *sub_name, I32 flags, register char **argv)
d1182 1
a1182 1
    return call_pv(sub_name, flags);
a1184 8
/*
=for apidoc p||call_pv

Performs a callback to the specified Perl sub.  See L<perlcall>.

=cut
*/

d1186 1
a1186 1
Perl_call_pv(pTHX_ const char *sub_name, I32 flags)
d1190 1
a1190 1
    return call_sv((SV*)get_cv(sub_name, TRUE), flags);
a1192 9
/*
=for apidoc p||call_method

Performs a callback to the specified Perl method.  The blessed object must
be on the stack.  See L<perlcall>.

=cut
*/

d1194 1
a1194 1
Perl_call_method(pTHX_ const char *methname, I32 flags)
d1200 1
a1200 2
    if (!PL_op) {
	Zero(&myop, 1, OP);
a1201 1
    }
d1204 4
a1207 4
    pp_method();
    if (PL_op == &myop)
	PL_op = Nullop;
    return call_sv(*PL_stack_sp--, flags);
a1210 9
/*
=for apidoc p||call_sv

Performs a callback to the Perl sub whose name is in the SV.  See
L<perlcall>.

=cut
*/

d1212 1
a1212 1
Perl_call_sv(pTHX_ SV *sv, I32 flags)
d1222 1
a1224 1
    dJMPENV;
d1255 1
a1255 7
    if (!(flags & G_EVAL)) {
	CATCH_SET(TRUE);
	call_body((OP*)&myop, FALSE);
	retval = PL_stack_sp - (PL_stack_base + oldmark);
	CATCH_SET(oldcatch);
    }
    else {
d1267 1
a1267 1
	    PUSHBLOCK(cx, (CXt_EVAL|CXp_TRYBLOCK), PL_stack_sp);
d1271 1
a1271 1
	    PL_in_eval = EVAL_INEVAL;
d1273 1
a1273 1
		PL_in_eval |= EVAL_KEEPERR;
a1278 5
#ifdef PERL_FLEXIBLE_EXCEPTIONS
 redo_body:
	CALLPROTECT(aTHX_ pcur_env, &ret, MEMBER_TO_FPTR(S_vcall_body),
		    (OP*)&myop, FALSE);
#else
a1279 1
#endif
a1281 7
#ifndef PERL_FLEXIBLE_EXCEPTIONS
 redo_body:
	    call_body((OP*)&myop, FALSE);
#endif
	    retval = PL_stack_sp - (PL_stack_base + oldmark);
	    if (!(flags & G_KEEPERR))
		sv_setpv(ERRSV,"");
d1291 2
a1292 2
	    if (PL_statusvalue && !(PL_exit_flags & PERL_EXIT_EXPECTED))
		Perl_croak(aTHX_ "Callback called exit");
d1299 1
a1299 1
		goto redo_body;
d1308 1
a1308 1
	    break;
d1310 11
d1322 2
d1339 2
a1351 27
#ifdef PERL_FLEXIBLE_EXCEPTIONS
STATIC void *
S_vcall_body(pTHX_ va_list args)
{
    OP *myop = va_arg(args, OP*);
    int is_eval = va_arg(args, int);

    call_body(myop, is_eval);
    return NULL;
}
#endif

STATIC void
S_call_body(pTHX_ OP *myop, int is_eval)
{
    dTHR;

    if (PL_op == myop) {
	if (is_eval)
	    PL_op = Perl_pp_entereval(aTHX);
	else
	    PL_op = Perl_pp_entersub(aTHX);
    }
    if (PL_op)
	CALLRUNOPS(aTHX);
}

a1353 8
/*
=for apidoc p||eval_sv

Tells Perl to C<eval> the string in the SV.

=cut
*/

d1355 1
a1355 1
Perl_eval_sv(pTHX_ SV *sv, I32 flags)
d1364 1
a1366 1
    dJMPENV;
a1389 5
#ifdef PERL_FLEXIBLE_EXCEPTIONS
 redo_body:
    CALLPROTECT(aTHX_ pcur_env, &ret, MEMBER_TO_FPTR(S_vcall_body),
		(OP*)&myop, TRUE);
#else
a1390 1
#endif
a1392 7
#ifndef PERL_FLEXIBLE_EXCEPTIONS
 redo_body:
	call_body((OP*)&myop,TRUE);
#endif
	retval = PL_stack_sp - (PL_stack_base + oldmark);
	if (!(flags & G_KEEPERR))
	    sv_setpv(ERRSV,"");
d1402 2
a1403 2
	if (PL_statusvalue && !(PL_exit_flags & PERL_EXIT_EXPECTED))
	    Perl_croak(aTHX_ "Callback called exit");
d1410 1
a1410 1
	    goto redo_body;
d1419 1
a1419 1
	break;
d1422 9
a1441 8
/*
=for apidoc p||eval_pv

Tells Perl to C<eval> the given string and return an SV* result.

=cut
*/

d1443 1
a1443 1
Perl_eval_pv(pTHX_ const char *p, I32 croak_on_error)
d1449 1
a1449 1
    eval_sv(sv, G_SCALAR);
d1458 1
a1458 1
	Perl_croak(aTHX_ SvPVx(ERRSV, n_a));
a1465 8
/*
=for apidoc p||require_pv

Tells Perl to C<require> a module.

=cut
*/

d1467 1
a1467 1
Perl_require_pv(pTHX_ const char *pv)
d1477 1
a1477 1
    eval_sv(sv, G_DISCARD);
d1483 1
a1483 1
Perl_magicname(pTHX_ char *sym, char *name, I32 namlen)
d1487 1
a1487 1
    if ((gv = gv_fetchpv(sym,TRUE, SVt_PV)))
d1492 2
a1493 1
S_usage(pTHX_ char *name)		/* XXX move this out into a module ? */
a1500 1
"-C              enable native wide character system interfaces",
d1502 6
a1507 6
"-d[:debugger]   run program under debugger",
"-D[number/list] set debugging flags (argument is a bit mask or alphabets)",
"-e 'command'    one line of program (several -e's allowed, omit programfile)",
"-F/pattern/     split() pattern for -a switch (//'s are optional)",
"-i[extension]   edit <> files in place (makes backup if extension supplied)",
"-Idirectory     specify @@INC/#include directory (several -I's allowed)",
d1509 8
a1516 8
"-[mM][-]module  execute `use/no module...' before executing program",
"-n              assume 'while (<>) { ... }' loop around program",
"-p              assume loop like -n but print line also, like sed",
"-P              run program through C preprocessor before compilation",
"-s              enable rudimentary parsing for switches after programfile",
"-S              look for programfile using PATH environment variable",
"-T              enable tainting checks",
"-u              dump core after parsing program",
d1518 3
a1520 5
"-v              print version, subversion (includes VERY IMPORTANT perl info)",
"-V[:variable]   print configuration summary (or a single Config.pm variable)",
"-w              enable many useful warnings (RECOMMENDED)",
"-W              enable all warnings",
"-X              disable all warnings",
d1535 1
a1535 1
Perl_moreswitches(pTHX_ char *s)
d1544 1
a1544 1
	rschar = (U32)scan_oct(s, 4, &numlen);
d1549 1
a1549 1
	    PL_nrs = newSVpvn("", 0);
d1552 1
a1552 1
	    PL_nrs = newSVpvn(&ch, 1);
a1555 4
    case 'C':
	PL_widesyscalls = TRUE;
	s++;
	return s;
d1573 1
a1573 1
	    my_setenv("PERL5DB", Perl_form(aTHX_ "use Devel::%s;", ++s));
a1581 1
    {	
d1597 1
a1597 4
	dTHR;
	if (ckWARN_d(WARN_DEBUGGING))
	    Perl_warner(aTHX_ WARN_DEBUGGING,
	           "Recompile perl with -DDEBUGGING to use -D switch\n");
a1601 1
    }	
d1624 5
a1628 14
	    p = s;
	    /* ignore trailing spaces (possibly followed by other switches) */
	    do {
		for (e = p; *e && !isSPACE(*e); e++) ;
		p = e;
		while (isSPACE(*p))
		    p++;
	    } while (*p && *p != '-');
	    e = savepvn(s, e-s);
	    incpush(e, TRUE, TRUE);
	    Safefree(e);
	    s = p;
	    if (*s == '-')
		s++;
d1631 1
a1631 1
	    Perl_croak(aTHX_ "No directory specified for -I");
d1641 1
a1641 1
	    *PL_ors = (char)scan_oct(s, 3 + (*s == '0'), &numlen);
d1674 1
a1674 1
			Perl_croak(aTHX_ "Can't use '%c' after -mname", *s);
d1684 1
a1684 1
	    if (!PL_preambleav)
d1689 1
a1689 1
	    Perl_croak(aTHX_ "No space allowed after -%c", *(s-1));
d1706 1
a1706 1
	    Perl_croak(aTHX_ "Too late for \"-T\" option");
d1718 7
a1724 2
	printf(Perl_form(aTHX_ "\nThis is perl, v%vd built for %s",
			 PL_patchlevel, ARCHNAME));
d1728 1
a1728 1
		(int)LOCAL_PATCH_COUNT, (LOCAL_PATCH_COUNT!=1) ? "es" : "");
d1731 1
a1731 1
	printf("\n\nCopyright 1987-2000, Larry Wall\n");
d1737 1
a1737 1
	printf("djgpp v2 port (perl5004+) by Laszlo Molnar, 1997-1999\n");
d1741 1
a1741 1
	    "Version 5 port Copyright (c) 1994-1999, Andreas Kaiser, Ilya Zakharevich\n");
d1747 1
a1747 1
	printf("BeOS port Copyright Tom Spindler, 1997-1999\n");
d1750 1
a1750 1
	printf("MPE/iX port Copyright by Mark Klein and Mark Bixby, 1996-1999\n");
d1753 1
a1753 1
	printf("MVS (OS390) port by Mortice Kern Systems, 1997-1999\n");
a1757 6
#ifdef __OPEN_VM
	printf("VM/ESA port by Neale Ferguson, 1998-1999\n");
#endif
#ifdef POSIX_BC
	printf("BS2000 (POSIX) port by Start Amadeus GmbH, 1998-1999\n");
#endif
d1759 1
a1759 4
	printf("MiNT port by Guido Flohr, 1997-1999\n");
#endif
#ifdef EPOC
	printf("EPOC port by Olaf Flebbe, 1999-2000\n");
d1772 1
a1772 12
	if (! (PL_dowarn & G_WARN_ALL_MASK))
	    PL_dowarn |= G_WARN_ON; 
	s++;
	return s;
    case 'W':
	PL_dowarn = G_WARN_ALL_ON|G_WARN_ON; 
	PL_compiling.cop_warnings = pWARN_ALL ;
	s++;
	return s;
    case 'X':
	PL_dowarn = G_WARN_ALL_OFF; 
	PL_compiling.cop_warnings = pWARN_NONE ;
d1797 1
a1797 1
	Perl_croak(aTHX_ "Can't emulate -%.1s on #! line",s);
d1808 1
a1808 1
Perl_my_unexec(pTHX)
d1836 1
a1836 1
S_init_interp(pTHX)
d1847 1
a1847 1
    PL_dumpindent	= 4;		\
d1856 1
a1869 1
    PL_dirty		= FALSE;	\
d1875 2
a1876 13
#    define PERLVARA(var,n,type)
#    if defined(PERL_IMPLICIT_CONTEXT)
#      if defined(USE_THREADS)
#        define PERLVARI(var,type,init)		PERL_GET_INTERP->var = init;
#        define PERLVARIC(var,type,init)	PERL_GET_INTERP->var = init;
#      else /* !USE_THREADS */
#        define PERLVARI(var,type,init)		aTHX->var = init;
#        define PERLVARIC(var,type,init)	aTHX->var = init;
#      endif /* USE_THREADS */
#    else
#      define PERLVARI(var,type,init)	PERL_GET_INTERP->var = init;
#      define PERLVARIC(var,type,init)	PERL_GET_INTERP->var = init;
#    endif
a1881 1
#    undef PERLVARA
d1884 1
a1884 1
#  else
a1885 1
#    define PERLVARA(var,n,type)
a1892 1
#    undef PERLVARA
d1901 1
a1901 1
S_init_main_stash(pTHX)
d1917 1
a1917 1
    PL_curstname = newSVpvn("main",4);
d1932 1
a1932 1
    (void)Perl_form(aTHX_ "%240s","");	/* Preallocate temp - for immediate signals. */
d1936 1
a1936 1
    CopSTASH_set(&PL_compiling, PL_defstash);
d1940 1
a1940 1
    sv_setpvn(get_sv("/", TRUE), "\n", 1);
d1944 1
a1944 1
S_open_script(pTHX_ char *scriptname, bool dosearch, SV *sv, int *fdscript)
d1947 1
d1971 1
a1971 1
    CopFILE_set(PL_curcop, PL_origfilename);
d1983 1
a1983 1
	SV *cpp = newSVpvn("",0);
d1987 1
a1987 1
	    Perl_sv_catpvf(aTHX_ cpp, "%s/", BIN_EXP);
d1990 1
a1990 1
	sv_catpvn(sv, "-I", 2);
d1994 1
a1994 1
	Perl_sv_setpvf(aTHX_ cmd, "\
d2006 1
a2006 1
 %s | %"SVf" -C %"SVf" %s",
d2009 1
a2009 2
#  ifdef __OPEN_VM
	Perl_sv_setpvf(aTHX_ cmd, "\
d2021 1
a2021 16
 %s | %"SVf" %"SVf" %s",
#  else
	Perl_sv_setpvf(aTHX_ cmd, "\
%s %s -e '/^[^#]/b' \
 -e '/^#[ 	]*include[ 	]/b' \
 -e '/^#[ 	]*define[ 	]/b' \
 -e '/^#[ 	]*if[ 	]/b' \
 -e '/^#[ 	]*ifdef[ 	]/b' \
 -e '/^#[ 	]*ifndef[ 	]/b' \
 -e '/^#[ 	]*else/b' \
 -e '/^#[ 	]*elif[ 	]/b' \
 -e '/^#[ 	]*undef[ 	]/b' \
 -e '/^#[ 	]*endif/b' \
 -e 's/^[ 	]*#.*//' \
 %s | %"SVf" -C %"SVf" %s",
#  endif
d2047 1
a2047 1
		Perl_croak(aTHX_ "Can't do seteuid!\n");
d2069 1
a2069 1
	    PerlLIO_stat(CopFILE(PL_curcop),&PL_statbuf) >= 0 &&
d2073 2
a2074 4
	    PerlProc_execv(Perl_form(aTHX_ "%s/sperl"PERL_FS_VER_FMT, BIN_EXP,
				     (int)PERL_REVISION, (int)PERL_VERSION,
				     (int)PERL_SUBVERSION), PL_origargv);
	    Perl_croak(aTHX_ "Can't do setuid\n");
d2078 2
a2079 2
	Perl_croak(aTHX_ "Can't open perl script \"%s\": %s\n",
		   CopFILE(PL_curcop), Strerror(errno));
a2082 7
/* Mention
 * I_SYSSTATVFS	HAS_FSTATVFS
 * I_SYSMOUNT
 * I_STATFS	HAS_FSTATFS	HAS_GETFSSTAT
 * I_MNTENT	HAS_GETMNTENT	HAS_HASMNTOPT
 * here so that metaconfig picks them up. */

d2084 2
a2085 2
STATIC int
S_fd_on_nosuid_fs(pTHX_ int fd)
d2087 2
a2088 2
    int check_okay = 0; /* able to do all the required sys/libcalls */
    int on_nosuid  = 0; /* the fd is on a nosuid fs */
d2090 1
a2090 1
 * Preferred order: fstatvfs(), fstatfs(), ustat()+getmnt(), getmntent().
d2092 2
a2093 4
 * fstatfs() is 4.3 BSD.
 * ustat()+getmnt() is pre-4.3 BSD.
 * getmntent() is O(number-of-mounted-filesystems) and can hang on
 * an irrelevant filesystem while trying to reach the right one.
d2101 1
a2101 4
#       ifdef PERL_MOUNT_NOSUID
#           if defined(HAS_FSTATFS) && \
	       defined(HAS_STRUCT_STATFS) && \
	       defined(HAS_STRUCT_STATFS_F_FLAGS)
d2104 11
d2116 1
a2116 28
#           else
#               if defined(HAS_FSTAT) && \
		   defined(HAS_USTAT) && \
		   defined(HAS_GETMNT) && \
		   defined(HAS_STRUCT_FS_DATA) && \
		   defined(NOSTAT_ONE)
    struct stat fdst;
    if (fstat(fd, &fdst) == 0) {
	struct ustat us;
	if (ustat(fdst.st_dev, &us) == 0) {
	    struct fs_data fsd;
	    /* NOSTAT_ONE here because we're not examining fields which
	     * vary between that case and STAT_ONE. */
            if (getmnt((int*)0, &fsd, (int)0, NOSTAT_ONE, us.f_fname) == 0) {
		size_t cmplen = sizeof(us.f_fname);
		if (sizeof(fsd.fd_req.path) < cmplen)
		    cmplen = sizeof(fsd.fd_req.path);
		if (strnEQ(fsd.fd_req.path, us.f_fname, cmplen) &&
		    fdst.st_dev == fsd.fd_req.dev) {
			check_okay = 1;
			on_nosuid = fsd.fd_req.flags & PERL_MOUNT_NOSUID;
		    }
		}
	    }
	}
    }
#               endif /* fstat+ustat+getmnt */
#           endif /* fstatfs */
d2118 1
a2118 3
#           if defined(HAS_GETMNTENT) && \
	       defined(HAS_HASMNTOPT) && \
	       defined(MNTOPT_NOSUID)
d2138 2
a2139 2
#           endif /* getmntent+hasmntopt */
#       endif /* PERL_MOUNT_NOSUID: fstatfs or fstat+ustat+statfs */
a2140 1

d2142 2
a2143 1
	Perl_croak(aTHX_ "Can't check filesystem of script \"%s\" for nosuid", PL_origfilename);
d2149 1
a2149 1
S_validate_suid(pTHX_ char *validarg, char *scriptname, int fdscript)
a2150 1
#ifdef IAMSUID
a2151 1
#endif
d2178 1
a2178 1
	Perl_croak(aTHX_ "Can't stat script \"%s\"",PL_origfilename);
d2193 2
a2194 2
	if (PerlLIO_access(CopFILE(PL_curcop),1)) /*double check*/
	    Perl_croak(aTHX_ "Permission denied");
d2213 3
a2215 3
		Perl_croak(aTHX_ "Can't swap uid and euid");	/* really paranoid */
	    if (PerlLIO_stat(CopFILE(PL_curcop),&tmpstatbuf) < 0)
		Perl_croak(aTHX_ "Permission denied");	/* testing full pathname here */
d2218 1
a2218 1
		Perl_croak(aTHX_ "Permission denied");
d2225 3
a2227 3
"User %"Uid_t_f" tried to run dev %ld ino %ld in place of dev %ld ino %ld!\n\
(Filename of set-id script was %s, uid %"Uid_t_f" gid %"Gid_t_f".)\n\nSincerely,\nperl\n",
			PL_uid,(long)tmpstatbuf.st_dev, (long)tmpstatbuf.st_ino,
d2229 2
a2230 2
			CopFILE(PL_curcop),
			PL_statbuf.st_uid, PL_statbuf.st_gid);
d2233 1
a2233 1
		Perl_croak(aTHX_ "Permission denied\n");
d2244 1
a2244 1
		Perl_croak(aTHX_ "Can't reswap uid and euid");
d2246 1
a2246 1
		Perl_croak(aTHX_ "Permission denied\n");
d2252 1
a2252 1
	    Perl_croak(aTHX_ "Permission denied");
d2254 1
a2254 1
	    Perl_croak(aTHX_ "Setuid/gid script is writable by world");
d2256 1
a2256 1
	CopLINE_inc(PL_curcop);
d2259 1
a2259 1
	    Perl_croak(aTHX_ "No #! line");
d2266 1
a2266 1
	    Perl_croak(aTHX_ "Not a perl script");
d2276 1
a2276 1
	    Perl_croak(aTHX_ "Args must match #! line");
d2282 1
a2282 1
		Perl_croak(aTHX_ "YOU HAVEN'T DISABLED SET-ID SCRIPTS IN THE KERNEL YET!\n\
d2290 1
a2290 3
	    PerlProc_execv(Perl_form(aTHX_ "%s/sperl"PERL_FS_VER_FMT, BIN_EXP,
				     (int)PERL_REVISION, (int)PERL_VERSION,
				     (int)PERL_SUBVERSION), PL_origargv);
d2292 1
a2292 1
	    Perl_croak(aTHX_ "Can't do setuid\n");
d2310 1
a2310 1
		Perl_croak(aTHX_ "Can't do setegid!\n");
d2328 1
a2328 1
		Perl_croak(aTHX_ "Can't do seteuid!\n");
d2345 1
a2345 1
		Perl_croak(aTHX_ "Can't do seteuid!\n");
d2349 1
a2349 1
	    Perl_croak(aTHX_ "Permission denied\n");	/* they can't do this */
d2353 1
a2353 1
	Perl_croak(aTHX_ "-P not allowed for setuid/setgid script\n");
d2355 1
a2355 1
	Perl_croak(aTHX_ "fd script not allowed in suidperl\n");
d2357 1
a2357 1
	Perl_croak(aTHX_ "Script is not setuid/setgid in suidperl\n");
d2366 2
a2367 2
	Perl_croak(aTHX_ "Permission denied");
    PL_origargv[which] = savepv(Perl_form(aTHX_ "/dev/fd/%d/%s",
d2372 2
a2373 4
    PerlProc_execv(Perl_form(aTHX_ "%s/perl"PERL_FS_VER_FMT, BIN_EXP,
			     (int)PERL_REVISION, (int)PERL_VERSION,
			     (int)PERL_SUBVERSION), PL_origargv);/* try again */
    Perl_croak(aTHX_ "Can't do setuid\n");
d2385 1
a2385 1
		Perl_croak(aTHX_ "YOU HAVEN'T DISABLED SET-ID SCRIPTS IN THE KERNEL YET!\n\
d2394 1
a2394 1
S_find_beginning(pTHX)
d2403 1
a2403 1
	    Perl_croak(aTHX_ "No Perl script found in input\n");
d2414 1
a2414 2
		    while ((s = moreswitches(s)))
			;
d2416 2
d2424 1
a2424 1
S_init_ids(pTHX)
d2426 4
a2429 4
    PL_uid = PerlProc_getuid();
    PL_euid = PerlProc_geteuid();
    PL_gid = PerlProc_getgid();
    PL_egid = PerlProc_getegid();
d2438 1
a2438 1
S_forbid_setid(pTHX_ char *s)
d2441 1
a2441 1
        Perl_croak(aTHX_ "No %s allowed while running setuid", s);
d2443 1
a2443 1
        Perl_croak(aTHX_ "No %s allowed while running setgid", s);
d2446 2
a2447 2
void
Perl_init_debugger(pTHX)
a2449 2
    HV *ostash = PL_curstash;

a2455 1
    sv_upgrade(GvSV(PL_DBsub), SVt_IV);	/* IVX accessed if PERLDB_SUB_NN */
d2462 1
a2462 1
    PL_curstash = ostash;
d2472 1
a2472 1
Perl_init_stacks(pTHX)
d2494 1
a2494 1
    SET_MARK_OFFSET;
d2512 1
a2512 1
S_nuke_stacks(pTHX)
d2529 4
d2540 1
a2540 1
S_init_lexer(pTHX)
d2549 1
a2549 1
    PL_subname = newSVpvn("main",4);
d2553 1
a2553 1
S_init_predump_symbols(pTHX)
d2557 1
a2557 1
    IO *io;
d2559 1
a2559 1
    sv_setpvn(get_sv("\"", TRUE), " ", 1);
d2562 1
a2562 2
    io = GvIOp(PL_stdingv);
    IoIFP(io) = PerlIO_stdin();
d2565 1
a2565 1
    GvIOp(tmpgv) = (IO*)SvREFCNT_inc(io);
d2569 1
a2569 2
    io = GvIOp(tmpgv);
    IoOFP(io) = IoIFP(io) = PerlIO_stdout();
d2573 1
a2573 1
    GvIOp(tmpgv) = (IO*)SvREFCNT_inc(io);
d2575 3
a2577 4
    PL_stderrgv = gv_fetchpv("STDERR",TRUE, SVt_PVIO);
    GvMULTI_on(PL_stderrgv);
    io = GvIOp(PL_stderrgv);
    IoOFP(io) = IoIFP(io) = PerlIO_stderr();
d2580 1
a2580 1
    GvIOp(tmpgv) = (IO*)SvREFCNT_inc(io);
d2589 1
a2589 1
S_init_postdump_symbols(pTHX_ register int argc, register char **argv, register char **env)
d2601 1
a2601 1
	    if (argv[0][1] == '-' && !argv[0][2]) {
d2605 1
a2605 1
	    if ((s = strchr(argv[0], '='))) {
d2622 1
a2622 1
    if ((tmpgv = gv_fetchpv("0",TRUE, SVt_PV))) {
d2626 1
a2626 4
    if ((tmpgv = gv_fetchpv("\030",TRUE, SVt_PV)))
#ifdef OS2
	sv_setpv(GvSV(tmpgv), os2_execname());
#else
d2628 1
a2628 2
#endif
    if ((PL_argvgv = gv_fetchpv("ARGV",TRUE, SVt_PVAV))) {
d2633 1
a2633 4
	    SV *sv = newSVpv(argv[0],0);
	    av_push(GvAVn(PL_argvgv),sv);
	    if (PL_widesyscalls)
		sv_utf8_upgrade(sv);
d2636 1
a2636 1
    if ((PL_envgv = gv_fetchpv("ENV",TRUE, SVt_PVHV))) {
d2641 1
a2641 1
#if !defined( VMS) && !defined(EPOC)  /* VMS doesn't have environ array */
d2672 2
a2673 2
    if ((tmpgv = gv_fetchpv("$",TRUE, SVt_PV)))
	sv_setiv(GvSV(tmpgv), (IV)PerlProc_getpid());
d2677 1
a2677 1
S_init_perllib(pTHX)
d2684 1
a2684 1
	    incpush(s, TRUE, TRUE);
d2686 1
a2686 1
	    incpush(PerlEnv_getenv("PERLLIB"), FALSE, FALSE);
d2695 1
a2695 1
	    do { incpush(buf,TRUE,TRUE); } while (my_trnlnm("PERL5LIB",buf,++idx));
d2697 1
a2697 1
	    while (my_trnlnm("PERLLIB",buf,idx++)) incpush(buf,FALSE,FALSE);
d2702 1
a2702 1
    ARCHLIB PRIVLIB SITEARCH SITELIB VENDORARCH and VENDORLIB
d2705 1
a2705 1
    incpush(APPLLIB_EXP, TRUE, TRUE);
d2709 1
a2709 1
    incpush(ARCHLIB_EXP, FALSE, FALSE);
d2712 1
a2712 1
#  define PRIVLIB_EXP "/usr/local/lib/perl5:/usr/local/lib/perl"
d2715 1
a2715 1
    incpush(PRIVLIB_EXP, TRUE, FALSE);
d2717 1
a2717 1
    incpush(PRIVLIB_EXP, FALSE, FALSE);
d2721 1
a2721 5
    /* sitearch is always relative to sitelib on Windows for
     * DLL-based path intuition to work correctly */
#  if !defined(WIN32)
    incpush(SITEARCH_EXP, FALSE, FALSE);
#  endif
a2722 1

d2724 4
a2727 25
#  if defined(WIN32)
    incpush(SITELIB_EXP, TRUE, FALSE);	/* this picks up sitearch as well */
#  else
    incpush(SITELIB_EXP, FALSE, FALSE);
#  endif
#endif

#ifdef SITELIB_STEM /* Search for version-specific dirs below here */
    incpush(SITELIB_STEM, FALSE, TRUE);
#endif

#ifdef PERL_VENDORARCH_EXP
    /* vendorarch is always relative to vendorlib on Windows for
     * DLL-based path intuition to work correctly */
#  if !defined(WIN32)
    incpush(PERL_VENDORARCH_EXP, FALSE, FALSE);
#  endif
#endif

#ifdef PERL_VENDORLIB_EXP
#  if defined(WIN32)
    incpush(PERL_VENDORLIB_EXP, TRUE, FALSE);	/* this picks up vendorarch as well */
#  else
    incpush(PERL_VENDORLIB_EXP, FALSE, FALSE);
#  endif
a2728 3

#ifdef PERL_VENDORLIB_STEM /* Search for version-specific dirs below here */
    incpush(PERL_VENDORLIB_STEM, FALSE, TRUE);
a2729 1

d2731 1
a2731 1
	incpush(".", FALSE, FALSE);
d2748 1
a2748 1
S_incpush(pTHX_ char *p, int addsubdirs, int addoldvers)
d2752 1
a2752 1
    if (!p || !*p)
d2755 1
a2755 1
    if (addsubdirs || addoldvers) {
d2757 11
d2778 1
a2778 1
	    /* av_push(GvAVn(PL_incgv), newSVpvn(".", 1)); */
d2796 1
a2796 6
	if (addsubdirs || addoldvers) {
#ifdef PERL_INC_VERSION_LIST
	    /* Configure terminates PERL_INC_VERSION_LIST with a NULL */
	    const char *incverlist[] = { PERL_INC_VERSION_LIST };
	    const char **incver;
#endif
d2808 1
a2808 1
		PerlIO_printf(Perl_error_log,
d2812 15
a2826 36
	    if (addsubdirs) {
		/* .../version/archname if -d .../version/archname */
		Perl_sv_setpvf(aTHX_ subdir, "%"SVf"/"PERL_FS_VER_FMT"/%s", 
				libdir,
			       (int)PERL_REVISION, (int)PERL_VERSION,
			       (int)PERL_SUBVERSION, ARCHNAME);
		if (PerlLIO_stat(SvPVX(subdir), &tmpstatbuf) >= 0 &&
		      S_ISDIR(tmpstatbuf.st_mode))
		    av_push(GvAVn(PL_incgv), newSVsv(subdir));

		/* .../version if -d .../version */
		Perl_sv_setpvf(aTHX_ subdir, "%"SVf"/"PERL_FS_VER_FMT, libdir,
			       (int)PERL_REVISION, (int)PERL_VERSION,
			       (int)PERL_SUBVERSION);
		if (PerlLIO_stat(SvPVX(subdir), &tmpstatbuf) >= 0 &&
		      S_ISDIR(tmpstatbuf.st_mode))
		    av_push(GvAVn(PL_incgv), newSVsv(subdir));

		/* .../archname if -d .../archname */
		Perl_sv_setpvf(aTHX_ subdir, "%"SVf"/%s", libdir, ARCHNAME);
		if (PerlLIO_stat(SvPVX(subdir), &tmpstatbuf) >= 0 &&
		      S_ISDIR(tmpstatbuf.st_mode))
		    av_push(GvAVn(PL_incgv), newSVsv(subdir));
	    }

#ifdef PERL_INC_VERSION_LIST
	    if (addoldvers) {
		for (incver = incverlist; *incver; incver++) {
		    /* .../xxx if -d .../xxx */
		    Perl_sv_setpvf(aTHX_ subdir, "%"SVf"/%s", libdir, *incver);
		    if (PerlLIO_stat(SvPVX(subdir), &tmpstatbuf) >= 0 &&
			  S_ISDIR(tmpstatbuf.st_mode))
			av_push(GvAVn(PL_incgv), newSVsv(subdir));
		}
	    }
#endif
d2836 1
a2836 1
S_init_main_thread(pTHX)
a2837 1
#if !defined(PERL_IMPLICIT_CONTEXT)
a2838 1
#endif
a2842 1
    thr->interp = PERL_GET_INTERP;
d2847 1
a2861 1
    PL_dumpindent = 4;
d2871 1
a2871 1
    Perl_init_thread_intern(thr);
d2879 1
a2879 1
    PERL_SET_THX(thr);
d2892 1
a2892 1
    thr->errsv = newSVpvn("", 0);
d2896 2
a2897 5
    PL_regcompp = MEMBER_TO_FPTR(Perl_pregcomp);
    PL_regexecp = MEMBER_TO_FPTR(Perl_regexec_flags);
    PL_regint_start = MEMBER_TO_FPTR(Perl_re_intuit_start);
    PL_regint_string = MEMBER_TO_FPTR(Perl_re_intuit_string);
    PL_regfree = MEMBER_TO_FPTR(Perl_pregfree);
d2906 1
a2906 1
Perl_call_list(pTHX_ I32 oldscope, AV *paramList)
d2909 1
a2909 3
    SV *atsv;
    line_t oldline = CopLINE(PL_curcop);
    CV *cv;
d2911 1
a2912 1
    dJMPENV;
d2915 2
a2916 1
	cv = (CV*)av_shift(paramList);
d2918 1
a2918 3
#ifdef PERL_FLEXIBLE_EXCEPTIONS
	CALLPROTECT(aTHX_ pcur_env, &ret, MEMBER_TO_FPTR(S_vcall_list_body), cv);
#else
a2919 1
#endif
d2921 17
a2937 22
	case 0:
#ifndef PERL_FLEXIBLE_EXCEPTIONS
	    call_list_body(cv);
#endif
	    atsv = ERRSV;
	    (void)SvPV(atsv, len);
	    if (len) {
		STRLEN n_a;
		PL_curcop = &PL_compiling;
		CopLINE_set(PL_curcop, oldline);
		if (paramList == PL_beginav)
		    sv_catpv(atsv, "BEGIN failed--compilation aborted");
		else
		    Perl_sv_catpvf(aTHX_ atsv,
				   "%s failed--call queue aborted",
				   paramList == PL_checkav ? "CHECK"
				   : paramList == PL_initav ? "INIT"
				   : "END");
		while (PL_scopestack_ix > oldscope)
		    LEAVE;
		JMPENV_POP;
		Perl_croak(aTHX_ "%s", SvPVx(atsv, n_a));
d2949 3
d2953 2
a2954 3
	    CopLINE_set(PL_curcop, oldline);
	    JMPENV_POP;
	    if (PL_statusvalue && !(PL_exit_flags & PERL_EXIT_EXPECTED)) {
d2956 1
a2956 1
		    Perl_croak(aTHX_ "BEGIN failed--compilation aborted");
d2958 1
a2958 4
		    Perl_croak(aTHX_ "%s failed--call queue aborted",
			       paramList == PL_checkav ? "CHECK"
			       : paramList == PL_initav ? "INIT"
			       : "END");
d2963 4
a2966 4
	    if (PL_restartop) {
		PL_curcop = &PL_compiling;
		CopLINE_set(PL_curcop, oldline);
		JMPENV_JUMP(3);
d2968 4
a2971 3
	    PerlIO_printf(Perl_error_log, "panic: restartop\n");
	    FREETMPS;
	    break;
a2976 17
#ifdef PERL_FLEXIBLE_EXCEPTIONS
STATIC void *
S_vcall_list_body(pTHX_ va_list args)
{
    CV *cv = va_arg(args, CV*);
    return call_list_body(cv);
}
#endif

STATIC void *
S_call_list_body(pTHX_ CV *cv)
{
    PUSHMARK(PL_stack_sp);
    call_sv((SV*)cv, G_EVAL|G_DISCARD);
    return NULL;
}

d2978 1
a2978 1
Perl_my_exit(pTHX_ U32 status)
d2999 1
a2999 1
Perl_my_failure_exit(pTHX)
d3028 1
a3028 1
S_my_exit_jump(pTHX)
d3030 1
a3030 1
    dTHR;
d3052 3
a3055 1
#endif
d3058 5
a3062 1
read_e_script(pTHXo_ int idx, SV *buf_sv, int maxlen)
d3076 2
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d3 1
a3 1
 *    Copyright (c) 1987-2001 Larry Wall
a182 2
	MUTEX_INIT(&PL_sv_lock_mutex);
	MUTEX_INIT(&PL_fdpid_mutex);
a274 4
#ifdef HAVE_INTERP_INTERN
    sys_intern_init();
#endif

a278 1
    PL_errors = newSVpvn("",0);
d294 1
d296 1
a372 1
    PL_nthreads--;
a433 15
    /* jettison our possibly duplicated environment */

#ifdef USE_ENVIRON_ARRAY
    if (environ != PL_origenviron) {
	I32 i;

	for (i = 0; environ[i]; i++)
	    safesysfree(environ[i]);
	/* Must use safesysfree() when working with environ. */
	safesysfree(environ);		

	environ = PL_origenviron;
    }
#endif

a557 1
    SvREFCNT_dec(PL_numeric_radix_sv);
d598 1
a598 5
#ifdef USE_ITHREADS
    Safefree(CopFILE(&PL_compiling));
    CopFILE(&PL_compiling) = Nullch;
    Safefree(CopSTASHPV(&PL_compiling));
#else
d600 1
a600 2
    CopFILEGV(&PL_compiling) = Nullgv;
    /* cop_stash is not refcounted */
d634 1
d637 4
a640 5

    /* the 2 is for PL_fdpid and PL_strtab */
    while (PL_sv_count > 2 && sv_clean_all())
	;

a649 4
#ifdef HAVE_INTERP_INTERN
    sys_intern_clear();
#endif

a680 5
#ifdef USE_ITHREADS
    /* free the pointer table used for cloning */
    ptr_table_free(PL_ptr_table);
#endif

d699 3
a708 3
    Safefree(PL_psig_ptr);
    Safefree(PL_psig_name);
    Safefree(PL_bitcount);
a717 1
    MUTEX_DESTROY(&PL_fdpid_mutex);
a729 2
    sv_free_arenas();

d797 1
d820 1
a820 1
#ifdef  USE_ENVIRON_ARRAY
d899 1
a966 5
#ifdef MACOS_TRADITIONAL
	    /* ignore -e for Dev:Pseudo argument */
	    if (argv[1] && !strcmp(argv[1], "Dev:Pseudo"))
	    	break; 
#endif
a1136 1
	        char *d;
a1143 1
		d = s;
d1148 1
a1148 7
		while (++s && *s) {
		    if (isSPACE(*s)) {
		        *s++ = '\0';
			break;
		    }
		}
		moreswitches(d);
a1187 3
#ifdef MACOS_TRADITIONAL
    if (PL_doextract || gMacPerl_AlwaysExtract) {
#else
a1188 1
#endif
d1228 1
a1228 1
#if defined(VMS) || defined(WIN32) || defined(DJGPP) || defined(__CYGWIN__) || defined(EPOC)
a1232 3
#   ifdef HAS_SOCKS5_INIT
    socks5_init(argv[0]);
#   else
a1233 1
#   endif
a1248 10
#ifdef MACOS_TRADITIONAL
    if (gMacPerl_SyntaxError = (yyparse() || PL_error_count)) {
	if (PL_minus_c)
	    Perl_croak(aTHX_ "%s had compilation errors.\n", MacPerl_MPWFileName(PL_origfilename));
	else {
	    Perl_croak(aTHX_ "Execution of %s aborted due to compilation errors.\n",
		       MacPerl_MPWFileName(PL_origfilename));
	}
    }
#else
a1256 1
#endif
d1302 1
d1370 2
a1381 3
#ifdef MACOS_TRADITIONAL
	    PerlIO_printf(Perl_error_log, "%s syntax OK\n", MacPerl_MPWFileName(PL_origfilename));
#else
a1382 1
#endif
d1426 2
a1427 1
    	if (tmp != NOT_IN_PAD)
d1429 1
d1568 12
a1579 1
    return call_sv(sv_2mortal(newSVpv(methname,0)), flags | G_METHOD);
d1594 1
a1598 1
    UNOP method_op;
a1635 8
    if (flags & G_METHOD) {
	Zero(&method_op, 1, UNOP);
	method_op.op_next = PL_op;
	method_op.op_ppaddr = PL_ppaddr[OP_METHOD];
	myop.op_ppaddr = PL_ppaddr[OP_ENTERSUB];
	PL_op = (OP*)&method_op;
    }

d1643 1
a1643 1
	myop.op_other = (OP*)&myop;
d1653 1
a1653 1
	    push_return(Nullop);
d1752 2
d1756 1
a1756 1
	    PL_op = Perl_pp_entereval(aTHX);	/* this doesn't do a POPMARK */
d1758 1
a1758 1
	    PL_op = Perl_pp_entersub(aTHX);	/* this does */
d1880 1
d1941 1
a1941 1
"-c              check syntax only (runs BEGIN and CHECK blocks)",
d1969 1
a1969 3
    PerlIO_printf(PerlIO_stdout(),
		  "\nUsage: %s [switches] [--] [programfile] [arguments]",
		  name);
d1971 1
a1971 1
	PerlIO_printf(PerlIO_stdout(), "\n  %s", *p++);
d1979 1
a1979 1
    STRLEN numlen;
d1985 1
a1985 1
	numlen = 0;			/* disallow underscores */
d2018 2
a2019 17
	/* The following permits -d:Mod to accepts arguments following an =
	   in the fashion that -MSome::Mod does. */
	if (*s == ':' || *s == '=') {
	    char *start;
	    SV *sv;
	    sv = newSVpv("use Devel::", 0);
	    start = ++s;
	    /* We now allow -d:Module=Foo,Bar */
	    while(isALNUM(*s) || *s==':') ++s;
	    if (*s != '=')
		sv_catpv(sv, start);
	    else {
		sv_catpvn(sv, start, s-start);
		sv_catpv(sv, " split(/,/,q{");
		sv_catpv(sv, ++s);
		sv_catpv(sv,    "})");
	    }
a2020 1
	    my_setenv("PERL5DB", SvPV(sv, PL_na));
d2032 1
a2032 1
	    static char debopts[] = "psltocPmfrxuLHXDST";
d2044 1
a2100 1
	    numlen = 0;			/* disallow underscores */
d2105 1
a2137 3
                if (s == start)
                    Perl_croak(aTHX_ "Module name required with -%c option",
			       s[-1]);
a2169 3
#ifdef MACOS_TRADITIONAL
	Perl_croak(aTHX_ "Believe me, you don't want to use \"-u\" on a Macintosh");
#endif
d2178 2
a2179 3
	PerlIO_printf(PerlIO_stdout(),
		      Perl_form(aTHX_ "\nThis is perl, v%"VDf" built for %s",
				PL_patchlevel, ARCHNAME));
d2182 2
a2183 5
	    PerlIO_printf(PerlIO_stdout(),
			  "\n(with %d registered patch%s, "
			  "see perl -V for more detail)",
			  (int)LOCAL_PATCH_COUNT,
			  (LOCAL_PATCH_COUNT!=1) ? "es" : "");
d2186 1
a2186 6
	PerlIO_printf(PerlIO_stdout(),
		      "\n\nCopyright 1987-2001, Larry Wall\n");
#ifdef MACOS_TRADITIONAL
	PerlIO_printf(PerlIO_stdout(),
		      "\nMac OS port Copyright (c) 1991-2001, Matthias Neeracher\n");
#endif
d2188 1
a2188 2
	PerlIO_printf(PerlIO_stdout(),
		      "\nMS-DOS port Copyright (c) 1989, 1990, Diomidis Spinellis\n");
d2191 2
a2192 3
	PerlIO_printf(PerlIO_stdout(),
		      "djgpp v2 port (jpl5003c) by Hirofumi Watanabe, 1996\n"
		      "djgpp v2 port (perl5004+) by Laszlo Molnar, 1997-1999\n");
d2195 2
a2196 3
	PerlIO_printf(PerlIO_stdout(),
		      "\n\nOS/2 port Copyright (c) 1990, 1991, Raymond Chen, Kai Uwe Rommel\n"
		      "Version 5 port Copyright (c) 1994-1999, Andreas Kaiser, Ilya Zakharevich\n");
d2199 1
a2199 2
	PerlIO_printf(PerlIO_stdout(),
		      "atariST series port, ++jrb  bammi@@cadence.com\n");
d2202 1
a2202 2
	PerlIO_printf(PerlIO_stdout(),
		      "BeOS port Copyright Tom Spindler, 1997-1999\n");
d2205 1
a2205 2
	PerlIO_printf(PerlIO_stdout(),
		      "MPE/iX port Copyright by Mark Klein and Mark Bixby, 1996-1999\n");
d2208 1
a2208 2
	PerlIO_printf(PerlIO_stdout(),
		      "MVS (OS390) port by Mortice Kern Systems, 1997-1999\n");
d2211 1
a2211 2
	PerlIO_printf(PerlIO_stdout(),
		      "Stratus VOS port by Paul_Green@@stratus.com, 1997-1999\n");
d2214 1
a2214 2
	PerlIO_printf(PerlIO_stdout(),
		      "VM/ESA port by Neale Ferguson, 1998-1999\n");
d2217 1
a2217 2
	PerlIO_printf(PerlIO_stdout(),
		      "BS2000 (POSIX) port by Start Amadeus GmbH, 1998-1999\n");
d2220 1
a2220 2
	PerlIO_printf(PerlIO_stdout(),
		      "MiNT port by Guido Flohr, 1997-1999\n");
d2223 1
a2223 2
	PerlIO_printf(PerlIO_stdout(),
		      "EPOC port by Olaf Flebbe, 1999-2000\n");
d2228 1
a2228 2
	PerlIO_printf(PerlIO_stdout(),
		      "\n\
d2230 1
a2230 1
GNU General Public License, which may be found in the Perl 5 source kit.\n\n\
d2392 1
a2427 1
    PL_nullstash = GvHV(gv_fetchpv("<none>::", GV_ADDMULTI, SVt_PVHV));
d2435 2
a2458 5
#ifdef USE_ITHREADS
    Safefree(CopFILE(PL_curcop));
#else
    SvREFCNT_dec(CopFILEGV(PL_curcop));
#endif
d2481 1
a2481 1
#if defined(MSDOS) || defined(WIN32)
d2611 1
a2611 5
#undef FD_ON_NOSUID_CHECK_OKAY  /* found the syscalls to do the check? */

#   if !defined(FD_ON_NOSUID_CHECK_OKAY) && \
        defined(HAS_FSTATVFS)
#   define FD_ON_NOSUID_CHECK_OKAY
a2612 1

d2615 5
a2619 8
#   endif /* fstatvfs */
 
#   if !defined(FD_ON_NOSUID_CHECK_OKAY) && \
        defined(PERL_MOUNT_NOSUID)	&& \
        defined(HAS_FSTATFS) 		&& \
        defined(HAS_STRUCT_STATFS)	&& \
        defined(HAS_STRUCT_STATFS_F_FLAGS)
#   define FD_ON_NOSUID_CHECK_OKAY
a2620 1

d2623 6
a2628 10
#   endif /* fstatfs */

#   if !defined(FD_ON_NOSUID_CHECK_OKAY) && \
        defined(PERL_MOUNT_NOSUID)	&& \
        defined(HAS_FSTAT)		&& \
        defined(HAS_USTAT)		&& \
        defined(HAS_GETMNT)		&& \
        defined(HAS_STRUCT_FS_DATA)	&& \
        defined(NOSTAT_ONE)
#   define FD_ON_NOSUID_CHECK_OKAY
a2629 1

d2631 5
a2635 5
        struct ustat us;
        if (ustat(fdst.st_dev, &us) == 0) {
            struct fs_data fsd;
            /* NOSTAT_ONE here because we're not examining fields which
             * vary between that case and STAT_ONE. */
d2637 21
a2657 22
                size_t cmplen = sizeof(us.f_fname);
                if (sizeof(fsd.fd_req.path) < cmplen)
                    cmplen = sizeof(fsd.fd_req.path);
                if (strnEQ(fsd.fd_req.path, us.f_fname, cmplen) &&
                    fdst.st_dev == fsd.fd_req.dev) {
                        check_okay = 1;
                        on_nosuid = fsd.fd_req.flags & PERL_MOUNT_NOSUID;
                    }
                }
            }
        }
    }
#   endif /* fstat+ustat+getmnt */

#   if !defined(FD_ON_NOSUID_CHECK_OKAY) && \
        defined(HAS_GETMNTENT)		&& \
        defined(HAS_HASMNTOPT)		&& \
        defined(MNTOPT_NOSUID)
#   define FD_ON_NOSUID_CHECK_OKAY
    FILE                *mtab = fopen("/etc/mtab", "r");
    struct mntent       *entry;
    struct stat         stb, fsb;
d2660 11
a2670 11
        while (entry = getmntent(mtab)) {
            if (stat(entry->mnt_dir, &fsb) == 0
                && fsb.st_dev == stb.st_dev)
            {
                /* found the filesystem */
                check_okay = 1;
                if (hasmntopt(entry, MNTOPT_NOSUID))
                    on_nosuid = 1;
                break;
            } /* A single fs may well fail its stat(). */
        }
d2673 4
a2676 2
        fclose(mtab);
#   endif /* getmntent+hasmntopt */
d2712 1
d2761 10
d2920 1
a2942 19
#ifdef MACOS_TRADITIONAL
    /* Since the Mac OS does not honor #! arguments for us, we do it ourselves */
    while (PL_doextract || gMacPerl_AlwaysExtract) {
	if ((s = sv_gets(PL_linestr, PL_rsfp, 0)) == Nullch) {
	    if (!gMacPerl_AlwaysExtract)
		Perl_croak(aTHX_ "No Perl script found in input\n");
		
	    if (PL_doextract)			/* require explicit override ? */
		if (!OverrideExtract(PL_origfilename))
		    Perl_croak(aTHX_ "User aborted script\n");
		else
		    PL_doextract = FALSE;
		
	    /* Pater peccavi, file does not have #! */
	    PerlIO_rewind(PL_rsfp);
	    
	    break;
	}
#else
a2945 1
#endif
d2990 1
d3058 1
d3095 1
d3127 2
a3128 3
    if (PL_osname)
    	Safefree(PL_osname);
    PL_osname = savepv(OSNAME);
d3134 1
a3137 2
    char **dup_env_base = 0;
    int dup_env_count = 0;
a3165 4
#ifdef MACOS_TRADITIONAL
	/* $0 is not majick on a Mac */
	sv_setpv(GvSV(tmpgv),MacPerl_MPWFileName(PL_origfilename));
#else
a3167 1
#endif
d3171 1
a3171 1
	sv_setpv(GvSV(tmpgv), os2_execname(aTHX));
d3183 1
a3183 1
		(void)sv_utf8_decode(sv);
d3190 2
a3191 2
	hv_magic(hv, Nullgv, 'E');
#ifdef USE_ENVIRON_ARRAY
a3200 20
#ifdef NEED_ENVIRON_DUP_FOR_MODIFY
	{
	    char **env_base;
	    for (env_base = env; *env; env++) 
		dup_env_count++;
	    if ((dup_env_base = (char **)
		 safesysmalloc( sizeof(char *) * (dup_env_count+1) ))) {
		char **dup_env;
		for (env = env_base, dup_env = dup_env_base;
		     *env;
		     env++, dup_env++) {
		    /* With environ one needs to use safesysmalloc(). */
		    *dup_env = safesysmalloc(strlen(*env) + 1);
		    (void)strcpy(*dup_env, *env);
		}
		*dup_env = Nullch;
		env = dup_env_base;
	    } /* else what? */
	}
#endif /* NEED_ENVIRON_DUP_FOR_MODIFY */
d3211 4
d3216 1
a3216 9
#ifdef NEED_ENVIRON_DUP_FOR_MODIFY
	if (dup_env_base) {
	    char **dup_env;
	    for (dup_env = dup_env_base; *dup_env; dup_env++)
		safesysfree(*dup_env);
	    safesysfree(dup_env_base);
	}
#endif /* NEED_ENVIRON_DUP_FOR_MODIFY */
#endif /* USE_ENVIRON_ARRAY */
a3260 21
#ifdef MACOS_TRADITIONAL
    {
	struct stat tmpstatbuf;
    	SV * privdir = NEWSV(55, 0);
	char * macperl = PerlEnv_getenv("MACPERL");
	
	if (!macperl)
	    macperl = "";
	
	Perl_sv_setpvf(aTHX_ privdir, "%slib:", macperl);
	if (PerlLIO_stat(SvPVX(privdir), &tmpstatbuf) >= 0 && S_ISDIR(tmpstatbuf.st_mode))
	    incpush(SvPVX(privdir), TRUE, FALSE);
	Perl_sv_setpvf(aTHX_ privdir, "%ssite_perl:", macperl);
	if (PerlLIO_stat(SvPVX(privdir), &tmpstatbuf) >= 0 && S_ISDIR(tmpstatbuf.st_mode))
	    incpush(SvPVX(privdir), TRUE, FALSE);
	    
   	SvREFCNT_dec(privdir);
    }
    if (!PL_tainting)
	incpush(":", FALSE, FALSE);
#else
a3309 4
#ifdef PERL_OTHERLIBDIRS
    incpush(PERL_OTHERLIBDIRS, TRUE, TRUE);
#endif

a3311 1
#endif /* MACOS_TRADITIONAL */
d3314 1
a3314 1
#if defined(DOSISH) || defined(EPOC)
d3320 1
a3320 5
#    if defined(MACOS_TRADITIONAL)
#      define PERLLIB_SEP ','
#    else
#      define PERLLIB_SEP ':'
#    endif
a3359 6
#ifdef MACOS_TRADITIONAL
	if (!strchr(SvPVX(libdir), ':'))
	    sv_insert(libdir, 0, 0, ":", 1);
	if (SvPVX(libdir)[SvCUR(libdir)-1] != ':')
	    sv_catpv(libdir, ":");
#endif
a3386 9
#ifdef MACOS_TRADITIONAL
#define PERL_AV_SUFFIX_FMT	""
#define PERL_ARCH_FMT 		"%s:"
#define PERL_ARCH_FMT_PATH	PERL_FS_VER_FMT PERL_AV_SUFFIX_FMT
#else
#define PERL_AV_SUFFIX_FMT 	"/"
#define PERL_ARCH_FMT 		"/%s"
#define PERL_ARCH_FMT_PATH	PERL_AV_SUFFIX_FMT PERL_FS_VER_FMT
#endif
d3388 1
a3388 1
		Perl_sv_setpvf(aTHX_ subdir, "%"SVf PERL_ARCH_FMT_PATH PERL_ARCH_FMT,
d3397 1
a3397 1
		Perl_sv_setpvf(aTHX_ subdir, "%"SVf PERL_ARCH_FMT_PATH, libdir,
d3405 1
a3405 1
		Perl_sv_setpvf(aTHX_ subdir, "%"SVf PERL_ARCH_FMT, libdir, ARCHNAME);
d3415 1
a3415 1
		    Perl_sv_setpvf(aTHX_ subdir, "%"SVf PERL_ARCH_FMT, libdir, *incver);
d3480 2
a3481 3
     * These must come after the thread self setting
     * because sv_setpvn does SvTAINT and the taint
     * fields thread selfness being set.
d3509 1
d3519 1
a3519 8
	if ((PL_minus_c & 0x10) && (paramList == PL_beginav)) {
		/* save PL_beginav for compiler */
	    if (! PL_beginav_save)
		PL_beginav_save = newAV();
	    av_push(PL_beginav_save, (SV*)cv);
	} else {
	    SAVEFREESV(cv);
	}
d3607 2
d3657 1
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d3 1
a3 1
 *    Copyright (c) 1987-2002 Larry Wall
a18 5
#ifdef NETWARE
#include "nwutil.h"	
char *nw_get_sitelib(const char *pl);
#endif

d24 1
a24 1
#if !defined(STANDARD_C) && !defined(HAS_GETENV_PROTOTYPE) && !defined(PERL_MICRO)
d28 1
a28 1
static I32 read_e_script(pTHX_ int idx, SV *buf_sv, int maxlen);
d42 9
a50 1
#if defined(USE_5005THREADS)
d94 5
d112 1
a118 2
=head1 Embedding Functions

a129 3
#ifdef USE_5005THREADS
    dTHX;
#endif
d151 2
a152 1
#ifdef USE_5005THREADS
d156 1
a156 1
#endif /* USE_5005THREADS */
d160 1
a160 1
    PL_perl_destruct_level = 1;
d168 1
a168 1
#ifdef USE_5005THREADS
d187 1
a187 1
#endif /* USE_5005THREADS */
d216 4
d221 1
d223 10
d235 2
a236 1
    PL_rs = newSVpvn("\n", 1);
d256 3
a258 4
	/* Build version strings using "native" characters */
	s = uvchr_to_utf8(s, (UV)PERL_REVISION);
	s = uvchr_to_utf8(s, (UV)PERL_VERSION);
	s = uvchr_to_utf8(s, (UV)PERL_SUBVERSION);
d281 1
a281 1
    PerlIO_init(aTHX);			/* Hook to IO system */
a285 31
    sv_setpvn(PERL_DEBUG_PAD(0), "", 0);	/* For regex debugging. */
    sv_setpvn(PERL_DEBUG_PAD(1), "", 0);	/* ext/re needs these */
    sv_setpvn(PERL_DEBUG_PAD(2), "", 0);	/* even without DEBUGGING. */
#ifdef USE_ITHREADS
    PL_regex_padav = newAV();
    av_push(PL_regex_padav,(SV*)newAV());    /* First entry is an array of empty elements */
    PL_regex_pad = AvARRAY(PL_regex_padav);
#endif
#ifdef USE_REENTRANT_API
    Perl_reentrant_init(aTHX);
#endif

    /* Note that strtab is a rather special HV.  Assumptions are made
       about not iterating on it, and not adding tie magic to it.
       It is properly deallocated in perl_destruct() */
    PL_strtab = newHV();

#ifdef USE_5005THREADS
    MUTEX_INIT(&PL_strtab_mutex);
#endif
    HvSHAREKEYS_off(PL_strtab);			/* mandatory */
    hv_ksplit(PL_strtab, 512);

#if defined(__DYNAMIC__) && (defined(NeXT) || defined(__NeXT__))
    _dyld_lookup_and_bind
	("__environ", (unsigned long *) &environ_pointer, NULL);
#endif /* environ */

#ifdef  USE_ENVIRON_ARRAY
    PL_origenviron = environ;
#endif
a290 15
=for apidoc nothreadhook

Stub that provides thread hook for perl_destruct when there are
no threads.

=cut
*/

int
Perl_nothreadhook(pTHX)
{
    return 0;
}

/*
d298 1
a298 1
int
d301 1
a301 1
    volatile int destruct_level;  /* 0=none, 1=full, 2=full with checks */
d303 1
a303 1
#ifdef USE_5005THREADS
d306 1
a306 1
#endif /* USE_5005THREADS */
d311 1
a311 1
#ifdef USE_5005THREADS
d345 1
a345 1
	    /*
d380 1
a380 1
#endif /* USE_5005THREADS */
a393 10

    if(PL_exit_flags & PERL_EXIT_DESTRUCT_END) {
        dJMPENV;
        int x = 0;

        JMPENV_PUSH(x);
        if (PL_endav && !PL_minus_c)
            call_list(PL_scopestack_ix, PL_endav);
        JMPENV_POP;
    }
a396 8
    /* Need to flush since END blocks can produce output */
    my_fflush_all();

    if (CALL_FPTR(PL_threadhook)(aTHX)) {
        /* Threads hook has vetoed further cleanup */
        return STATUS_NATIVE_EXPORT;
    }

d401 1
a401 2
        /* If running under -d may not have PL_comppad. */
        PL_curpad = PL_comppad ? AvARRAY(PL_comppad) : NULL;
a410 7
    /* Tell PerlIO we are about to tear things apart in case
       we have layers which are using resources that should
       be cleaned up now.
     */

    PerlIO_destruct(aTHX);

d428 1
a428 1
	PL_exitlist[PL_exitlistlen].fn(aTHX_ PL_exitlist[PL_exitlistlen].ptr);
d435 1
a435 6

#if defined(PERLIO_LAYERS)
	/* No more IO - including error messages ! */
	PerlIO_cleanup(aTHX);
#endif

d437 1
a437 1
        return STATUS_NATIVE_EXPORT;
d441 3
a443 11
    /* if PERL_USE_SAFE_PUTENV is defined environ will not have been copied
     * so we certainly shouldn't free it here
     */
#if defined(USE_ENVIRON_ARRAY) && !defined(PERL_USE_SAFE_PUTENV)
    if (environ != PL_origenviron
#ifdef USE_ITHREADS
	/* only main thread can free environ[0] contents */
	&& PL_curinterp == aTHX
#endif
	)
    {
a447 1

a454 33
#ifdef USE_ITHREADS
    /* the syntax tree is shared between clones
     * so op_free(PL_main_root) only ReREFCNT_dec's
     * REGEXPs in the parent interpreter
     * we need to manually ReREFCNT_dec for the clones
     */
    {
        I32 i = AvFILLp(PL_regex_padav) + 1;
        SV **ary = AvARRAY(PL_regex_padav);

        while (i) {
            SV *resv = ary[--i];
            REGEXP *re = INT2PTR(REGEXP *,SvIVX(resv));

            if (SvFLAGS(resv) & SVf_BREAK) {
                /* this is PL_reg_curpm, already freed
                 * flag is set in regexec.c:S_regtry
                 */
                SvFLAGS(resv) &= ~SVf_BREAK;
            }
	    else if(SvREPADTMP(resv)) {
	      SvREPADTMP_off(resv);
	    }
            else {
                ReREFCNT_dec(re);
            }
        }
    }
    SvREFCNT_dec(PL_regex_padav);
    PL_regex_padav = Nullav;
    PL_regex_pad = NULL;
#endif

a487 5
    while (--PL_origargc >= 0) {
        Safefree(PL_origargv[PL_origargc]);
    }
    Safefree(PL_origargv);

d490 2
a491 2
    SvREFCNT_dec(PL_ofs_sv);	/* $, */
    PL_ofs_sv = Nullsv;
d493 2
a494 2
    SvREFCNT_dec(PL_ors_sv);	/* $\ */
    PL_ors_sv = Nullsv;
d499 3
a526 1
    SvREFCNT_dec(PL_beginav_save);
a530 1
    PL_beginav_save = Nullav;
a597 1
    SvREFCNT_dec(PL_utf8_totitle);
a598 3
    SvREFCNT_dec(PL_utf8_tofold);
    SvREFCNT_dec(PL_utf8_idstart);
    SvREFCNT_dec(PL_utf8_idcont);
a615 3
    PL_utf8_tofold	= Nullsv;
    PL_utf8_idstart	= Nullsv;
    PL_utf8_idcont	= Nullsv;
d620 9
a628 5
    if (!specialCopIO(PL_compiling.cop_io))
	SvREFCNT_dec(PL_compiling.cop_io);
    PL_compiling.cop_io = Nullsv;
    CopFILE_free(&PL_compiling);
    CopSTASH_free(&PL_compiling);
d645 1
a645 1
	    Perl_warner(aTHX_ packWARN(WARN_INTERNAL),
d649 1
a649 1
	    Perl_warner(aTHX_ packWARN(WARN_INTERNAL),
d653 1
a653 1
	    Perl_warner(aTHX_ packWARN(WARN_INTERNAL),"Unbalanced tmps: %ld more allocs than frees\n",
d656 1
a656 1
	    Perl_warner(aTHX_ packWARN(WARN_INTERNAL),"Unbalanced context: %ld more PUSHes than POPs\n",
d697 1
a697 1
		Perl_warner(aTHX_ packWARN(WARN_INTERNAL),
d729 2
a730 9
    {
        int i;
        for (i=0; i<=2; i++) {
            SvREFCNT(PERL_DEBUG_PAD(i)) = 0;
            sv_clear(PERL_DEBUG_PAD(i));
            SvANY(PERL_DEBUG_PAD(i)) = NULL;
            SvFLAGS(PERL_DEBUG_PAD(i)) = 0;
        }
    }
d733 1
a733 13
	Perl_warner(aTHX_ packWARN(WARN_INTERNAL),"Scalars leaked: %ld\n", (long)PL_sv_count);

#if defined(PERLIO_LAYERS)
    /* No more IO - including error messages ! */
    PerlIO_cleanup(aTHX);
#endif

    /* sv_undef needs to stay immortal until after PerlIO_cleanup
       as currently layers use it rather than Nullsv as a marker
       for no arg - and will try and SvREFCNT_dec it.
     */
    SvREFCNT(&PL_sv_undef) = 0;
    SvREADONLY_off(&PL_sv_undef);
a744 1
    Safefree(PL_psig_pend);
d747 1
a747 1

d749 1
a749 1
#ifdef USE_5005THREADS
d765 1
a765 5
#endif /* USE_5005THREADS */

#ifdef USE_REENTRANT_API
    Perl_reentrant_free(aTHX);
#endif
d778 1
a778 2
		if (mg->mg_ptr && mg->mg_type != PERL_MAGIC_regex_global
						&& mg->mg_len >= 0)
a789 1
    return STATUS_NATIVE_EXPORT;
d803 4
a806 5
#if defined(WIN32) || defined(NETWARE)
#  if defined(PERL_IMPLICIT_SYS)
#    ifdef NETWARE
    void *host = nw_internal_host;
#    else
a807 1
#    endif
a808 3
#    ifdef NETWARE
    nw_delete_internal_host(host);
#    else
a809 1
#    endif
a812 2
#else
    PerlMem_free(aTHXx);
d839 1
a839 1
#ifdef USE_5005THREADS
d851 6
d858 3
a860 15
    {
        /* we copy rather than point to argv
         * since perl_clone will copy and perl_destruct
         * has no way of knowing if we've made a copy or
         * just point to argv
         */
        int i = PL_origargc;
        New(0, PL_origargv, i+1, char*);
        PL_origargv[i] = '\0';
        while (i-- > 0) {
            PL_origargv[i] = savepv(argv[i]);
        }
    }


a997 7
	case 't':
	    if( !PL_tainting ) {
	         PL_taint_warn = TRUE;
	         PL_tainting = TRUE;
	    }
	    s++;
	    goto reswitch;
a999 1
	    PL_taint_warn = FALSE;
d1007 1
a1007 1
	    	break;
d1072 2
a1073 2
#  ifdef USE_5005THREADS
		sv_catpv(PL_Sv," USE_5005THREADS");
d1093 3
d1124 1
a1124 6
@@env = map { \"$_=\\\"$ENV{$_}\\\"\" } sort grep {/^PERL/} keys %ENV; ");
#ifdef __CYGWIN__
		sv_catpv(PL_Sv,"\
push @@env, \"CYGWIN=\\\"$ENV{CYGWIN}\\\"\";");
#endif
		sv_catpv(PL_Sv, "\
a1172 1
    	char *popt = s;
d1175 1
a1175 1
	if (*s == '-' && *(s+1) == 'T') {
a1176 2
            PL_taint_warn = FALSE;
	}
a1177 1
	    char *popt_copy = Nullch;
d1190 1
a1190 1
		if (!strchr("DIMUdmtw", *s))
a1193 5
			if (!popt_copy) {
			    popt_copy = SvPVX(sv_2mortal(newSVpv(popt,0)));
			    s = popt_copy + (s - popt);
			    d = popt_copy + (d - popt);
			}
d1198 1
a1198 8
		if (*d == 't') {
		    if( !PL_tainting ) {
		        PL_taint_warn = TRUE;
		        PL_tainting = TRUE;
		    }
		} else {
		    moreswitches(d);
		}
a1202 4
    if (PL_taint_warn && PL_dowarn != G_WARN_ALL_OFF) {
       PL_compiling.cop_warnings = newSVpvn(WARN_TAINTstring, WARNsize);
    }

a1222 1
#ifndef PERL_MICRO
d1231 1
a1231 1
		Perl_warner(aTHX_ packWARN(WARN_SIGNAL),
a1236 1
#endif
d1260 1
a1260 1
#ifdef USE_5005THREADS
d1267 1
a1267 1
#endif /* USE_5005THREADS */
a1274 1
    boot_core_PerlIO();
d1281 1
a1281 2
	(*xsinit)(aTHX);	/* in case linked C routines want magical variables */
#ifndef PERL_MICRO
a1284 1
#endif
d1292 1
a1292 1
#endif
a1300 21
    /* PL_wantutf8 is conditionally turned on by
     * locale.c:Perl_init_i18nl10n() if the environment
     * look like the user wants to use UTF-8. */
    if (PL_wantutf8) { /* Requires init_predump_symbols(). */
	 IO* io;
	 PerlIO* fp;
	 SV* sv;
	 /* Turn on UTF-8-ness on STDIN, STDOUT, STDERR
	  *  _and_ the default open discipline. */
	 if (PL_stdingv  && (io = GvIO(PL_stdingv))  && (fp = IoIFP(io)))
	      PerlIO_binmode(aTHX_ fp, IoTYPE(io), 0, ":utf8");
	 if (PL_defoutgv && (io = GvIO(PL_defoutgv)) && (fp = IoOFP(io)))
	      PerlIO_binmode(aTHX_ fp, IoTYPE(io), 0, ":utf8");
	 if (PL_stderrgv && (io = GvIO(PL_stderrgv)) && (fp = IoOFP(io)))
	      PerlIO_binmode(aTHX_ fp, IoTYPE(io), 0, ":utf8");
	 if ((sv = GvSV(gv_fetchpv("\017PEN", TRUE, SVt_PV)))) {
	     sv_setpvn(sv, ":utf8\0:utf8", 11);
	     SvSETMAGIC(sv);
	 }
    }

d1334 3
a1336 4
/*
   Not sure that this is still the right place to do this now that we
   no longer use PL_nrs. HVDS 2001/09/09
*/
a1337 1

d1374 1
a1374 1
#ifdef USE_5005THREADS
a1378 3
#ifdef VMS
    VMSISH_HUSHED = 0;
#endif
d1401 1
a1401 2
	if (!(PL_exit_flags & PERL_EXIT_DESTRUCT_END) &&
	    PL_endav && !PL_minus_c)
d1449 1
a1449 3
	    PerlIO_printf(Perl_error_log, "%s%s syntax OK\n",
		(gMacPerl_ErrorFormat ? "# " : ""),
		MacPerl_MPWFileName(PL_origfilename));
d1456 1
a1456 1
	    sv_setiv(PL_DBsingle, 1);
a1479 2
=head1 SV Manipulation Functions

d1493 1
a1493 1
#ifdef USE_5005THREADS
d1499 1
a1499 1
#endif /* USE_5005THREADS */
a1506 2
=head1 Array Manipulation Functions

a1527 2
=head1 Hash Manipulation Functions

a1548 2
=head1 CV Manipulation Functions

a1579 3

=head1 Callback Functions

d1589 1
a1589 1

d1657 1
a1657 1
    volatile I32 retval = 0;
d1714 1
a1714 1
	
d1717 1
a1717 1
	
d1722 1
a1722 1
	
d1839 1
a1839 1

d1844 2
a1845 2
    volatile I32 oldmark = SP - PL_stack_base;
    volatile I32 retval = 0;
a1960 2
=head1 Embedding Functions

d1963 1
a1963 3
Tells Perl to C<require> the file named by the string argument.  It is
analogous to the Perl code C<eval "require '$file'">.  It's even
implemented that way; consider using Perl_load_module instead.
d1965 2
a1966 1
=cut */
d1990 1
a1990 1
	sv_magic(GvSV(gv), (SV*)gv, PERL_MAGIC_sv, name, namlen);
d1997 1
a1997 1
     * Removed -h because the user already knows that option. Others? */
a2017 1
"-t              enable tainting warnings",
d2049 3
a2051 4
        I32 flags = 0;
	numlen = 4;
	rschar = (U32)grok_oct(s, &numlen, &flags, NULL);
	SvREFCNT_dec(PL_rs);
d2053 1
a2053 1
	    PL_rs = &PL_sv_undef;
d2055 1
a2055 1
	    PL_rs = newSVpvn("", 0);
d2057 2
a2058 2
	    char ch = (char)rschar;
	    PL_rs = newSVpvn(&ch, 1);
d2068 2
a2069 4
	PL_splitstr = ++s;
	while (*s && !isSPACE(*s)) ++s;
	*s = '\0';
	PL_splitstr = savepv(PL_splitstr);
d2112 1
a2112 2
	    /* if adding extra options, remember to update DEBUG_MASK */
	    static char debopts[] = "psltocPmfrxuLHXDSTRJ";
d2122 2
a2123 7
#ifdef EBCDIC
	if (DEBUG_p_TEST_ && ckWARN_d(WARN_DEBUGGING))
	    Perl_warner(aTHX_ packWARN(WARN_DEBUGGING),
		    "-Dp not implemented on this platform\n");
#endif
	PL_debug |= DEBUG_TOP_FLAG;
#else /* !DEBUGGING */
d2125 1
a2125 1
	    Perl_warner(aTHX_ packWARN(WARN_DEBUGGING),
d2133 2
a2134 2
	usage(PL_origargv[0]);
	my_exit(0);
a2137 6
#if defined(__CYGWIN__) /* do backup extension automagically */
	if (*(s+1) == '\0') {
	PL_inplace = savepv(".bak");
	return s+1;
	}
#endif /* __CYGWIN__ */
d2147 1
a2147 1
    case 'I':	/* -I handled both here and in parse_body() */
d2175 2
a2176 4
	if (PL_ors_sv) {
	    SvREFCNT_dec(PL_ors_sv);
	    PL_ors_sv = Nullsv;
	}
d2178 4
a2181 4
            I32 flags = 0;
	    PL_ors_sv = newSVpvn("\n",1);
	    numlen = 3 + (*s == '0');
	    *SvPVX(PL_ors_sv) = (char)grok_oct(s, &numlen, &flags, NULL);
d2185 3
a2187 5
	    if (RsPARA(PL_rs)) {
		PL_ors_sv = newSVpvn("\n\n",2);
	    }
	    else {
		PL_ors_sv = newSVsv(PL_rs);
d2189 3
a2245 5
    case 't':
        if (!PL_tainting)
            Perl_croak(aTHX_ "Too late for \"-t\" option");
        s++;
        return s;
a2262 1
#if !defined(DGUX)
a2265 12
#else /* DGUX */
/* Adjust verbose output as in the perl that ships with the DG/UX OS from EMC */
	PerlIO_printf(PerlIO_stdout(),
			Perl_form(aTHX_ "\nThis is perl, version %vd\n", PL_patchlevel));
	PerlIO_printf(PerlIO_stdout(),
			Perl_form(aTHX_ "        built under %s at %s %s\n",
					OSNAME, __DATE__, __TIME__));
	PerlIO_printf(PerlIO_stdout(),
			Perl_form(aTHX_ "        OS Specific Release: %s\n",
					OSVERS));
#endif /* !DGUX */

d2276 1
a2276 1
		      "\n\nCopyright 1987-2002, Larry Wall\n");
d2279 1
a2279 2
		      "\nMac OS port Copyright 1991-2002, Matthias Neeracher;\n"
		      "maintained by Chris Nandor\n");
d2293 1
a2293 1
		      "Version 5 port Copyright (c) 1994-2002, Andreas Kaiser, Ilya Zakharevich\n");
d2305 1
a2305 1
		      "MPE/iX port Copyright by Mark Klein and Mark Bixby, 1996-2002\n");
d2313 1
a2313 1
		      "Stratus VOS port by Paul.Green@@stratus.com, 1997-2002\n");
d2329 1
a2329 6
		      "EPOC port by Olaf Flebbe, 1999-2002\n");
#endif
#ifdef UNDER_CE
	printf("WINCE port by Rainer Keuchel, 2001-2002\n");
	printf("Built on " __DATE__ " " __TIME__ "\n\n");
	wce_hitreturn();
d2341 1
a2341 1
	my_exit(0);
d2344 1
a2344 1
	    PL_dowarn |= G_WARN_ON;
d2348 1
a2348 3
	PL_dowarn = G_WARN_ALL_ON|G_WARN_ON;
        if (!specialWARN(PL_compiling.cop_warnings))
            SvREFCNT_dec(PL_compiling.cop_warnings);
d2353 1
a2353 3
	PL_dowarn = G_WARN_ALL_OFF;
        if (!specialWARN(PL_compiling.cop_warnings))
            SvREFCNT_dec(PL_compiling.cop_warnings);
d2421 47
a2467 6
#ifdef MULTIPLICITY
#  define PERLVAR(var,type)
#  define PERLVARA(var,n,type)
#  if defined(PERL_IMPLICIT_CONTEXT)
#    if defined(USE_5005THREADS)
#      define PERLVARI(var,type,init)		PERL_GET_INTERP->var = init;
d2469 9
a2477 4
#    else /* !USE_5005THREADS */
#      define PERLVARI(var,type,init)		aTHX->var = init;
#      define PERLVARIC(var,type,init)	aTHX->var = init;
#    endif /* USE_5005THREADS */
d2479 12
a2490 6
#    define PERLVARI(var,type,init)	PERL_GET_INTERP->var = init;
#    define PERLVARIC(var,type,init)	PERL_GET_INTERP->var = init;
#  endif
#  include "intrpvar.h"
#  ifndef USE_5005THREADS
#    include "thrdvar.h"
a2491 17
#  undef PERLVAR
#  undef PERLVARA
#  undef PERLVARI
#  undef PERLVARIC
#else
#  define PERLVAR(var,type)
#  define PERLVARA(var,n,type)
#  define PERLVARI(var,type,init)	PL_##var = init;
#  define PERLVARIC(var,type,init)	PL_##var = init;
#  include "intrpvar.h"
#  ifndef USE_5005THREADS
#    include "thrdvar.h"
#  endif
#  undef PERLVAR
#  undef PERLVARA
#  undef PERLVARI
#  undef PERLVARIC
d2501 10
a2541 5
    char *quote;
    char *code;
    char *cpp_discard_flag;
    char *perl;

d2564 5
a2568 1
    CopFILE_free(PL_curcop);
d2574 4
a2577 5
#       if defined(HAS_FCNTL) && defined(F_SETFD)
	    if (PL_rsfp)
                /* ensure close-on-exec */
	        fcntl(PerlIO_fileno(PL_rsfp),F_SETFD,1);
#       endif
d2588 2
a2589 43
#       ifndef VMS
	    sv_catpvn(sv, "-I", 2);
	    sv_catpv(sv,PRIVLIB_EXP);
#       endif

	DEBUG_P(PerlIO_printf(Perl_debug_log,
			      "PL_preprocess: scriptname=\"%s\", cpp=\"%s\", sv=\"%s\", CPPMINUS=\"%s\"\n",
			      scriptname, SvPVX (cpp), SvPVX (sv), CPPMINUS));

#       if defined(MSDOS) || defined(WIN32) || defined(VMS)
            quote = "\"";
#       else
            quote = "'";
#       endif

#       ifdef VMS
            cpp_discard_flag = "";
#       else
            cpp_discard_flag = "-C";
#       endif

#       ifdef OS2
            perl = os2_execname(aTHX);
#       else
            perl = PL_origargv[0];
#       endif


        /* This strips off Perl comments which might interfere with
           the C pre-processor, including #!.  #line directives are
           deliberately stripped to avoid confusion with Perl's version
           of #line.  FWP played some golf with it so it will fit
           into VMS's 255 character buffer.
        */
        if( PL_doextract )
            code = "(1../^#!.*perl/i)|/^\\s*#(?!\\s*((ifn?|un)def|(el|end)?if|define|include|else|error|pragma)\\b)/||!($|=1)||print";
        else
            code = "/^\\s*#(?!\\s*((ifn?|un)def|(el|end)?if|define|include|else|error|pragma)\\b)/||!($|=1)||print";

        Perl_sv_setpvf(aTHX_ cmd, "\
%s -ne%s%s%s %s | %"SVf" %s %"SVf" %s",
                       perl, quote, code, quote, scriptname, cpp,
                       cpp_discard_flag, sv, CPPMINUS);
d2591 53
d2645 15
a2659 15
#       ifdef IAMSUID			/* actually, this is caught earlier */
	    if (PL_euid != PL_uid && !PL_euid) {  /* if running suidperl */
#               ifdef HAS_SETEUID
	            (void)seteuid(PL_uid);	  /* musn't stay setuid root */
#               else
#               ifdef HAS_SETREUID
	            (void)setreuid((Uid_t)-1, PL_uid);
#               else
#               ifdef HAS_SETRESUID
	            (void)setresuid((Uid_t)-1, PL_uid, (Uid_t)-1);
#               else
	            PerlProc_setuid(PL_uid);
#               endif
#               endif
#               endif
d2663 1
a2663 6
#       endif /* IAMSUID */

        DEBUG_P(PerlIO_printf(Perl_debug_log,
                              "PL_preprocess: cmd=\"%s\"\n",
                              SvPVX(cmd)));

d2674 4
a2677 5
#       if defined(HAS_FCNTL) && defined(F_SETFD)
	    if (PL_rsfp)
                /* ensure close-on-exec */
	        fcntl(PerlIO_fileno(PL_rsfp),F_SETFD,1);
#       endif
d2680 16
a2695 23
#       ifdef DOSUID
#       ifndef IAMSUID	/* in case script is not readable before setuid */
	    if (PL_euid &&
                PerlLIO_stat(CopFILE(PL_curcop),&PL_statbuf) >= 0 &&
                PL_statbuf.st_mode & (S_ISUID|S_ISGID))
            {
                /* try again */
                PerlProc_execv(Perl_form(aTHX_ "%s/sperl"PERL_FS_VER_FMT,
                                         BIN_EXP, (int)PERL_REVISION,
                                         (int)PERL_VERSION,
                                         (int)PERL_SUBVERSION), PL_origargv);
                Perl_croak(aTHX_ "Can't do setuid\n");
            }
#       endif
#       endif
#       ifdef IAMSUID
            errno = EPERM;
            Perl_croak(aTHX_ "Can't open perl script: %s\n",
                       Strerror(errno));
#       else
            Perl_croak(aTHX_ "Can't open perl script \"%s\": %s\n",
                       CopFILE(PL_curcop), Strerror(errno));
#       endif
d2731 1
a2731 1

d2752 1
a2752 1
    Stat_t fdst;
d2782 1
a2782 1
    Stat_t              stb, fsb;
d2801 1
a2801 1
    if (!check_okay)
d2862 1
a2862 1
	    Stat_t tmpstatbuf;
a3055 1

d3069 1
a3069 1
	
d3077 1
a3077 2
	s2 = s;
	if (*s == '#' && s[1] == '!' && ((s = instr(s,"perl")) || (s = instr(s2,"PERL")))) {
a3089 3
#ifdef MACOS_TRADITIONAL
	    break;
#endif
d3131 1
a3131 1
    sv_setiv(PL_DBsingle, 0);
d3133 1
a3133 1
    sv_setiv(PL_DBtrace, 0);
d3135 1
a3135 1
    sv_setiv(PL_DBsignal, 0);
d3204 4
d3211 3
a3213 1
    PerlIO *tmpfp;
a3230 1
    IoTYPE(io) = IoTYPE_RDONLY;
a3238 1
    IoTYPE(io) = IoTYPE_WRONLY;
a3247 1
    IoTYPE(io) = IoTYPE_WRONLY;
d3260 2
a3261 2
void
Perl_init_argv_symbols(pTHX_ register int argc, register char **argv)
d3264 5
a3285 55
    if ((PL_argvgv = gv_fetchpv("ARGV",TRUE, SVt_PVAV))) {
	GvMULTI_on(PL_argvgv);
	(void)gv_AVadd(PL_argvgv);
	av_clear(GvAVn(PL_argvgv));
	for (; argc > 0; argc--,argv++) {
	    SV *sv = newSVpv(argv[0],0);
	    av_push(GvAVn(PL_argvgv),sv);
	    if (PL_widesyscalls)
		(void)sv_utf8_decode(sv);
	}
    }
}

#ifdef HAS_PROCSELFEXE
/* This is a function so that we don't hold on to MAXPATHLEN
   bytes of stack longer than necessary
 */
STATIC void
S_procself_val(pTHX_ SV *sv, char *arg0)
{
    char buf[MAXPATHLEN];
    int len = readlink(PROCSELFEXE_PATH, buf, sizeof(buf) - 1);

    /* On Playstation2 Linux V1.0 (kernel 2.2.1) readlink(/proc/self/exe)
       includes a spurious NUL which will cause $^X to fail in system
       or backticks (this will prevent extensions from being built and
       many tests from working). readlink is not meant to add a NUL.
       Normal readlink works fine.
     */
    if (len > 0 && buf[len-1] == '\0') {
      len--;
    }

    /* FreeBSD's implementation is acknowledged to be imperfect, sometimes
       returning the text "unknown" from the readlink rather than the path
       to the executable (or returning an error from the readlink).  Any valid
       path has a '/' in it somewhere, so use that to validate the result.
       See http://www.freebsd.org/cgi/query-pr.cgi?pr=35703
    */
    if (len > 0 && memchr(buf, '/', len)) {
	sv_setpvn(sv,buf,len);
    }
    else {
	sv_setpv(sv,arg0);
    }
}
#endif /* HAS_PROCSELFEXE */

STATIC void
S_init_postdump_symbols(pTHX_ register int argc, register char **argv, register char **env)
{
    char *s;
    SV *sv;
    GV* tmpgv;

a3294 3

    init_argv_symbols(argc,argv);

d3304 1
a3304 4
    if ((tmpgv = gv_fetchpv("\030",TRUE, SVt_PV))) {/* $^X */
#ifdef HAS_PROCSELFEXE
	S_procself_val(aTHX_ GvSV(tmpgv), PL_origargv[0]);
#else
d3310 10
a3319 1
#endif
d3325 1
a3325 1
	hv_magic(hv, Nullgv, PERL_MAGIC_env);
d3334 3
a3336 5
	if (env != environ
#  ifdef USE_ITHREADS
	    && PL_curinterp == aTHX
#  endif
	   )
d3338 16
a3353 1
	    environ[0] = Nullch;
d3355 2
a3356 2
	if (env)
	  for (; *env; env++) {
d3359 1
a3360 1
	    *s = '\0';
a3361 1
	    *s = '=';
d3363 1
a3363 1
	    sv = newSVpv(s+1, 0);
d3365 10
a3374 3
	    if (env != environ)
	        mg_set(sv);
	  }
d3376 3
d3381 1
a3381 2
    if ((tmpgv = gv_fetchpv("$",TRUE, SVt_PV))) {
        SvREADONLY_off(GvSV(tmpgv));
a3382 10
        SvREADONLY_on(GvSV(tmpgv));
    }

    /* touch @@F array to prevent spurious warnings 20020415 MJD */
    if (PL_minus_a) {
      (void) get_av("main::F", TRUE | GV_ADDMULTI);
    }
    /* touch @@- and @@+ arrays to prevent spurious warnings 20020415 MJD */
    (void) get_av("main::-", TRUE | GV_ADDMULTI);
    (void) get_av("main::+", TRUE | GV_ADDMULTI);
d3422 1
a3422 1
	Stat_t tmpstatbuf;
d3435 1
a3435 1
	
d3444 1
a3444 1
#if defined(WIN32)
d3514 1
a3514 1
#endif
d3550 2
a3551 5
	if (!strchr(SvPVX(libdir), ':')) {
	    char buf[256];

	    sv_setpv(libdir, MacPerl_CanonDir(SvPVX(libdir), buf, 0));
	}
d3566 1
a3566 1
	    Stat_t tmpstatbuf;
d3633 1
a3633 1
#ifdef USE_5005THREADS
a3669 1
    thr->thr_done = 0;
a3698 1
    PL_peepp = MEMBER_TO_FPTR(Perl_peep);
d3709 1
a3709 1
#endif /* USE_5005THREADS */
d3723 1
a3723 1
	if (PL_savebegin && (paramList == PL_beginav)) {
d3853 1
a3853 1
	exitstatus = STATUS_POSIX >> 8;
d3886 4
d3891 1
a3891 1
read_e_script(pTHX_ int idx, SV *buf_sv, int maxlen)
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@d3 1
a3 2
 *    Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999,
 *    2000, 2001, 2002, 2003, by Larry Wall and others
a28 12
#ifdef __BEOS__
#  define HZ 1000000
#endif

#ifndef HZ
#  ifdef CLK_TCK
#    define HZ CLK_TCK
#  else
#    define HZ 60
#  endif
#endif

a65 1
	    MUTEX_INIT(&PL_dollarzero_mutex);	\
d160 1
a208 3

	    SvREADONLY_on(&PL_sv_placeholder);
	    SvREFCNT(&PL_sv_placeholder) = (~(U32)0)/2;
d242 6
a247 3
	SvNVX(PL_patchlevel) = (NV)PERL_REVISION +
			      ((NV)PERL_VERSION / (NV)1000) +
			      ((NV)PERL_SUBVERSION / (NV)1000000);
d294 1
a294 2
#ifndef PERL_MICRO
#   ifdef  USE_ENVIRON_ARRAY
a295 1
#   endif
a297 10
    /* Use sysconf(_SC_CLK_TCK) if available, if not
     * available or if the sysconf() fails, use the HZ. */
#if defined(HAS_SYSCONF) && defined(_SC_CLK_TCK)
    PL_clocktick = sysconf(_SC_CLK_TCK);
    if (PL_clocktick <= 0)
#endif
	 PL_clocktick = HZ;

    PL_stashcache = newHV();

d445 2
a446 4
	/* ensure comppad/curpad to refer to main's pad */
	if (CvPADLIST(PL_main_cv)) {
	    PAD_SET_CUR_NOSAVE(CvPADLIST(PL_main_cv), 1);
	}
a469 1
	PL_sv_objcount = 0;
a483 3
    PL_exitlist = NULL;
    PL_exitlistlen = 0;

a500 1
#ifndef PERL_MICRO
a519 1
#endif /* !PERL_MICRO */
a553 3
    SvREFCNT_dec((SV*) PL_stashcache);
    PL_stashcache = NULL;

d587 4
a590 1
    PL_perldb = 0;
a630 1
    SvREFCNT_dec(PL_checkav_save);
a635 1
    PL_checkav_save = Nullav;
a648 8
    PL_DBgv = Nullgv;
    PL_DBline = Nullgv;
    PL_DBsub = Nullgv;
    PL_DBsingle = Nullsv;
    PL_DBtrace = Nullsv;
    PL_DBsignal = Nullsv;
    PL_DBcv = Nullcv;
    PL_dbargs = Nullav;
a682 1
    PL_numeric_radix_sv = Nullsv;
a820 1
    PL_ptr_table = (PTR_TBL_t*)NULL;
a847 19
#ifdef DEBUG_LEAKING_SCALARS
    if (PL_sv_count != 0) {
	SV* sva;
	SV* sv;
	register SV* svend;

	for (sva = PL_sv_arenaroot; sva; sva = (SV*)SvANY(sva)) {
	    svend = &sva[SvREFCNT(sva)];
	    for (sv = sva + 1; sv < svend; ++sv) {
		if (SvTYPE(sv) != SVTYPEMASK) {
		    PerlIO_printf(Perl_debug_log, "leaked: 0x%p\n", sv);
		}
	    }
	}
    }
#endif
    PL_sv_count = 0;


a859 3
    SvREFCNT(&PL_sv_placeholder) = 0;
    SvREADONLY_off(&PL_sv_placeholder);

a860 1
    PL_origfilename = Nullch;
a861 2
    PL_reg_start_tmp = (char**)NULL;
    PL_reg_start_tmpl = 0;
d865 1
a865 1
    free_tied_hv_pool();
a867 1
    PL_psig_ptr = (SV**)NULL;
a868 1
    PL_psig_name = (SV**)NULL;
a869 1
    PL_bitcount = Nullch;
a870 4
    PL_psig_pend = (int*)NULL;
    PL_formfeed = Nullsv;
    Safefree(PL_ofmt);
    PL_ofmt = Nullch;
a871 2
    PL_tainting = FALSE;
    PL_taint_warn = FALSE;
a872 1
    PL_debug = 0;
d991 1
a991 8
#if defined(USE_HASH_SEED) || defined(USE_HASH_SEED_EXPLICIT)
    /* [perl #22371] Algorimic Complexity Attack on Perl 5.6.1, 5.8.0
     * This MUST be done before any hash stores or fetches take place.
     * If you set PL_rehash_seed (and assumedly also PL_rehash_seed_set)
     * yourself, it is your responsibility to provide a good random seed!
     * You can also define PERL_HASH_SEED in compile time, see hv.h. */
    if (!PL_rehash_seed_set)
	 PL_rehash_seed = get_hash_seed();
d993 11
a1003 9
	 char *s = PerlEnv_getenv("PERL_HASH_SEED_DEBUG");

	 if (s) {
	      int i = atoi(s);

	      if (i == 1)
		   PerlIO_printf(Perl_debug_log, "HASH_SEED = %"UVuf"\n",
				 PL_rehash_seed);
	 }
a1004 1
#endif /* #if defined(USE_HASH_SEED) || defined(USE_HASH_SEED_EXPLICIT) */
a1005 2
    PL_origargc = argc;
    PL_origargv = argv;
a1006 86
    {
	/* Set PL_origalen be the sum of the contiguous argv[]
	 * elements plus the size of the env in case that it is
	 * contiguous with the argv[].  This is used in mg.c:mg_set()
	 * as the maximum modifiable length of $0.  In the worst case
	 * the area we are able to modify is limited to the size of
	 * the original argv[0].  (See below for 'contiguous', though.)
	 * --jhi */
	 char *s = NULL;
	 int i;
	 UV mask =
	   ~(UV)(PTRSIZE == 4 ? 3 : PTRSIZE == 8 ? 7 : PTRSIZE == 16 ? 15 : 0);
         /* Do the mask check only if the args seem like aligned. */
	 UV aligned =
	   (mask < ~(UV)0) && ((PTR2UV(argv[0]) & mask) == PTR2UV(argv[0]));

	 /* See if all the arguments are contiguous in memory.  Note
	  * that 'contiguous' is a loose term because some platforms
	  * align the argv[] and the envp[].  If the arguments look
	  * like non-aligned, assume that they are 'strictly' or
	  * 'traditionally' contiguous.  If the arguments look like
	  * aligned, we just check that they are within aligned
	  * PTRSIZE bytes.  As long as no system has something bizarre
	  * like the argv[] interleaved with some other data, we are
	  * fine.  (Did I just evoke Murphy's Law?)  --jhi */
	 if (PL_origargv && PL_origargc >= 1 && (s = PL_origargv[0])) {
	      while (*s) s++;
	      for (i = 1; i < PL_origargc; i++) {
		   if ((PL_origargv[i] == s + 1
#ifdef OS2
			|| PL_origargv[i] == s + 2
#endif 
			    )
		       ||
		       (aligned &&
			(PL_origargv[i] >  s &&
			 PL_origargv[i] <=
			 INT2PTR(char *, PTR2UV(s + PTRSIZE) & mask)))
			)
		   {
			s = PL_origargv[i];
			while (*s) s++;
		   }
		   else
			break;
	      }
	 }
	 /* Can we grab env area too to be used as the area for $0? */
	 if (PL_origenviron) {
	      if ((PL_origenviron[0] == s + 1
#ifdef OS2
		   || (PL_origenviron[0] == s + 9 && (s += 8))
#endif 
		  )
		  ||
		  (aligned &&
		   (PL_origenviron[0] >  s &&
		    PL_origenviron[0] <=
		    INT2PTR(char *, PTR2UV(s + PTRSIZE) & mask)))
		 )
	      {
#ifndef OS2
		   s = PL_origenviron[0];
		   while (*s) s++;
#endif
		   my_setenv("NoNe  SuCh", Nullch);
		   /* Force copy of environment. */
		   for (i = 1; PL_origenviron[i]; i++) {
			if (PL_origenviron[i] == s + 1
			    ||
			    (aligned &&
			     (PL_origenviron[i] >  s &&
			      PL_origenviron[i] <=
			      INT2PTR(char *, PTR2UV(s + PTRSIZE) & mask)))
			   )
			{
			     s = PL_origenviron[i];
			     while (*s) s++;
			}
			else
			     break;
		   }
	      }
	 }
	 PL_origalen = s - PL_origargv[0];
    }
d1021 1
d1089 1
d1112 4
a1144 1
	    CHECK_MALLOC_TOO_LATE_FOR('t');
a1151 1
	    CHECK_MALLOC_TOO_LATE_FOR('T');
d1161 1
a1161 1
		break;
d1189 1
a1189 1
		incpush(p, TRUE, TRUE, FALSE);
a1321 1
    sv_setsv(get_sv("/", TRUE), PL_rs);
a1332 1
	    CHECK_MALLOC_TOO_LATE_FOR('T');
d1431 7
a1437 1
    CvPADLIST(PL_compcv) = pad_new(0);
d1439 3
d1447 6
d1455 1
d1457 1
d1482 1
a1482 2
    /* PL_unicode is turned on by -C or by $ENV{PERL_UNICODE}.
     * PL_utf8locale is conditionally turned on by
d1485 15
a1499 35
    if (PL_unicode) {
	 /* Requires init_predump_symbols(). */
	 if (!(PL_unicode & PERL_UNICODE_LOCALE_FLAG) || PL_utf8locale) {
	      IO* io;
	      PerlIO* fp;
	      SV* sv;

	      /* Turn on UTF-8-ness on STDIN, STDOUT, STDERR
	       * and the default open disciplines. */
	      if ((PL_unicode & PERL_UNICODE_STDIN_FLAG) &&
		  PL_stdingv  && (io = GvIO(PL_stdingv)) &&
		  (fp = IoIFP(io)))
		   PerlIO_binmode(aTHX_ fp, IoTYPE(io), 0, ":utf8");
	      if ((PL_unicode & PERL_UNICODE_STDOUT_FLAG) &&
		  PL_defoutgv && (io = GvIO(PL_defoutgv)) &&
		  (fp = IoOFP(io)))
		   PerlIO_binmode(aTHX_ fp, IoTYPE(io), 0, ":utf8");
	      if ((PL_unicode & PERL_UNICODE_STDERR_FLAG) &&
		  PL_stderrgv && (io = GvIO(PL_stderrgv)) &&
		  (fp = IoOFP(io)))
		   PerlIO_binmode(aTHX_ fp, IoTYPE(io), 0, ":utf8");
	      if ((PL_unicode & PERL_UNICODE_INOUT_FLAG) &&
		  (sv = GvSV(gv_fetchpv("\017PEN", TRUE, SVt_PV)))) {
		   U32 in  = PL_unicode & PERL_UNICODE_IN_FLAG;
		   U32 out = PL_unicode & PERL_UNICODE_OUT_FLAG;
		   if (in) {
			if (out)
			     sv_setpvn(sv, ":utf8\0:utf8", 11);
			else
			     sv_setpvn(sv, ":utf8\0", 6);
		   }
		   else if (out)
			sv_setpvn(sv, "\0:utf8", 6);
		   SvSETMAGIC(sv);
	      }
a1502 9
    if ((s = PerlEnv_getenv("PERL_SIGNALS"))) {
	 if (strEQ(s, "unsafe"))
	      PL_signals |=  PERL_SIGNALS_UNSAFE_FLAG;
	 else if (strEQ(s, "safe"))
	      PL_signals &= ~PERL_SIGNALS_UNSAFE_FLAG;
	 else
	      Perl_croak(aTHX_ "PERL_SIGNALS illegal: \"%s\"", s);
    }

d1507 1
a1507 1
    SETERRNO(0,SS_NORMAL);
d1536 6
d1651 1
a1651 1
	PERL_DEBUG(PerlIO_printf(Perl_debug_log, "\nEXECUTING...\n\n"));
d2188 1
a2188 1
implemented that way; consider using load_module instead.
d2226 1
a2226 1
"-C[number/list] enables the listed Unicode features",
d2230 1
a2230 1
"-e program      one line of program (several -e's allowed, omit programfile)",
d2241 1
a2242 1
"-T              enable tainting checks",
d2249 1
a2250 1
"-X              disable all warnings",
a2262 34
/* convert a string of -D options (or digits) into an int.
 * sets *s to point to the char after the options */

#ifdef DEBUGGING
int
Perl_get_debug_opts(pTHX_ char **s)
{
    int i = 0;
    if (isALPHA(**s)) {
	/* if adding extra options, remember to update DEBUG_MASK */
	static char debopts[] = "psltocPmfrxu HXDSTRJvC";

	for (; isALNUM(**s); (*s)++) {
	    char *d = strchr(debopts,**s);
	    if (d)
		i |= 1 << (d - debopts);
	    else if (ckWARN_d(WARN_DEBUGGING))
		Perl_warner(aTHX_ packWARN(WARN_DEBUGGING),
		    "invalid option -D%c\n", **s);
	}
    }
    else {
	i = atoi(*s);
	for (; isALNUM(**s); (*s)++) ;
    }
#  ifdef EBCDIC
    if ((i & DEBUG_p_FLAG) && ckWARN_d(WARN_DEBUGGING))
	Perl_warner(aTHX_ packWARN(WARN_DEBUGGING),
		"-Dp not implemented on this platform\n");
#  endif
    return i;
}
#endif

d2269 1
a2269 1
    UV rschar;
d2274 13
a2286 36
	 I32 flags = 0;

	 SvREFCNT_dec(PL_rs);
	 if (s[1] == 'x' && s[2]) {
	      char *e;
	      U8 *tmps;

	      for (s += 2, e = s; *e; e++);
	      numlen = e - s;
	      flags = PERL_SCAN_SILENT_ILLDIGIT;
	      rschar = (U32)grok_hex(s, &numlen, &flags, NULL);
	      if (s + numlen < e) {
		   rschar = 0; /* Grandfather -0xFOO as -0 -xFOO. */
		   numlen = 0;
		   s--;
	      }
	      PL_rs = newSVpvn("", 0);
	      SvGROW(PL_rs, (STRLEN)(UNISKIP(rschar) + 1));
	      tmps = (U8*)SvPVX(PL_rs);
	      uvchr_to_utf8(tmps, rschar);
	      SvCUR_set(PL_rs, UNISKIP(rschar));
	      SvUTF8_on(PL_rs);
	 }
	 else {
	      numlen = 4;
	      rschar = (U32)grok_oct(s, &numlen, &flags, NULL);
	      if (rschar & ~((U8)~0))
		   PL_rs = &PL_sv_undef;
	      else if (!rschar && numlen >= 2)
		   PL_rs = newSVpvn("", 0);
	      else {
		   char ch = (char)rschar;
		   PL_rs = newSVpvn(&ch, 1);
	      }
	 }
	 return s + numlen;
d2289 2
a2290 2
        s++;
        PL_unicode = parse_unicode_opts(&s);
d2325 1
a2325 1
		sv_catpv(sv, "})");
d2339 18
a2356 2
	s++;
	PL_debug = get_debug_opts(&s) | DEBUG_TOP_FLAG;
d2403 1
a2403 1
	    incpush(e, TRUE, TRUE, FALSE);
d2462 1
a2462 2
		sv_catpv(sv, " split(/,/,q");
		sv_catpvn(sv, "\0)", 1);        /* Use NUL as q//-delimiter. */
d2464 1
a2464 1
		sv_catpvn(sv,  "\0)", 2);
d2489 1
a2489 1
	    TOO_LATE_FOR('t');
d2494 1
a2494 1
	    TOO_LATE_FOR('T');
d2535 1
a2535 1
		      "\n\nCopyright 1987-2003, Larry Wall\n");
d2565 1
a2565 1
		      "MPE/iX port Copyright by Mark Klein and Mark Bixby, 1996-2003\n");
d2592 2
a2593 2
	PerlIO_printf(PerlIO_stdout(),"WINCE port by Rainer Keuchel, 2001-2002\n");
	PerlIO_printf(PerlIO_stdout(),"Built on " __DATE__ " " __TIME__ "\n\n");
a2809 2
	if (cpp_cfg[0] == 0) /* PERL_MICRO? */
	     Perl_croak(aTHX_ "Can't run with cpp -P with CPPSTDIN undefined");
a2906 1
                PERL_FPU_PRE_EXEC
a2910 1
                PERL_FPU_POST_EXEC
d2917 2
a2918 1
            Perl_croak(aTHX_ "Permission denied\n");
d3080 2
a3081 4
	if (PerlLIO_access(CopFILE(PL_curcop),1)) { /*double check*/
            errno = EPERM;
	    Perl_croak(aTHX_ "Permission denied\n");
	}
d3101 2
a3102 4
	    if (PerlLIO_stat(CopFILE(PL_curcop),&tmpstatbuf) < 0) {
		errno = EPERM;
		Perl_croak(aTHX_ "Permission denied\n");	/* testing full pathname here */
	    }
d3104 2
a3105 4
	    if (fd_on_nosuid_fs(PerlIO_fileno(PL_rsfp))) {
		errno = EPERM;
		Perl_croak(aTHX_ "Permission denied\n");
	    }
a3109 1
		errno = EPERM;
d3128 2
a3129 4
	if (!S_ISREG(PL_statbuf.st_mode)) {
            errno = EPERM;
	    Perl_croak(aTHX_ "Permission denied\n");
	}
d3160 1
a3160 1
FIX YOUR KERNEL, OR PUT A C WRAPPER AROUND THIS SCRIPT!\n");
a3166 1
	    PERL_FPU_PRE_EXEC
a3169 1
	    PERL_FPU_POST_EXEC
d3235 2
a3236 4
    else {
	errno = EPERM;
	Perl_croak(aTHX_ "Permission denied\n");
    }
d3244 2
a3245 4
    if (!PL_origargv[which]) {
	errno = EPERM;
	Perl_croak(aTHX_ "Permission denied\n");
    }
a3250 1
    PERL_FPU_PRE_EXEC
a3253 1
    PERL_FPU_POST_EXEC
a3276 3
#ifdef MACOS_TRADITIONAL
    int maclines = 0;
#endif
d3288 1
a3288 1

d3294 1
a3294 1

d3297 1
a3297 1

a3319 7
	    /* We are always searching for the #!perl line in MacPerl,
	     * so if we find it, still keep the line count correct
	     * by counting lines we already skipped over
	     */
	    for (; maclines > 0 ; maclines--)
		PerlIO_ungetc(PL_rsfp, '\n');

a3320 4

	/* gMacPerl_AlwaysExtract is false in MPW tool */
	} else if (gMacPerl_AlwaysExtract) {
	    ++maclines;
a3337 2
    /* Should not happen: */
    CHECK_MALLOC_TAINT(PL_uid && (PL_euid != PL_uid || PL_egid != PL_gid));
a3340 36
/* This is used very early in the lifetime of the program,
 * before even the options are parsed, so PL_tainting has
 * not been initialized properly.  */
bool
Perl_doing_taint(int argc, char *argv[], char *envp[])
{
#ifndef PERL_IMPLICIT_SYS
    /* If we have PERL_IMPLICIT_SYS we can't call getuid() et alia
     * before we have an interpreter-- and the whole point of this
     * function is to be called at such an early stage.  If you are on
     * a system with PERL_IMPLICIT_SYS but you do have a concept of
     * "tainted because running with altered effective ids', you'll
     * have to add your own checks somewhere in here.  The two most
     * known samples of 'implicitness' are Win32 and NetWare, neither
     * of which has much of concept of 'uids'. */
    int uid  = PerlProc_getuid();
    int euid = PerlProc_geteuid();
    int gid  = PerlProc_getgid();
    int egid = PerlProc_getegid();

#ifdef VMS
    uid  |=  gid << 16;
    euid |= egid << 16;
#endif
    if (uid && (euid != uid || egid != gid))
	return 1;
#endif /* !PERL_IMPLICIT_SYS */
    /* This is a really primitive check; environment gets ignored only
     * if -T are the first chars together; otherwise one gets
     *  "Too late" message. */
    if ( argc > 1 && argv[1][0] == '-'
         && (argv[1][1] == 't' || argv[1][1] == 'T') )
	return 1;
    return 0;
}

d3356 1
a3356 1
    PL_dbargs = GvAV(gv_AVadd((gv_fetchpv("DB::args", GV_ADDMULTI, SVt_PVAV))));
d3358 3
a3360 3
    PL_DBgv = gv_fetchpv("DB::DB", GV_ADDMULTI, SVt_PVGV);
    PL_DBline = gv_fetchpv("DB::dbline", GV_ADDMULTI, SVt_PVAV);
    PL_DBsub = gv_HVadd(gv_fetchpv("DB::sub", GV_ADDMULTI, SVt_PVHV));
d3362 1
a3362 1
    PL_DBsingle = GvSV((gv_fetchpv("DB::single", GV_ADDMULTI, SVt_PV)));
d3364 1
a3364 1
    PL_DBtrace = GvSV((gv_fetchpv("DB::trace", GV_ADDMULTI, SVt_PV)));
d3366 1
a3366 1
    PL_DBsignal = GvSV((gv_fetchpv("DB::signal", GV_ADDMULTI, SVt_PV)));
d3517 2
a3518 6
	    if (!(PL_unicode & PERL_UNICODE_LOCALE_FLAG) || PL_utf8locale) {
		 if (PL_unicode & PERL_UNICODE_ARGV_FLAG)
		      SvUTF8_on(sv);
	    }
	    if (PL_unicode & PERL_UNICODE_WIDESYSCALLS_FLAG) /* Sarathy? */
		 (void)sv_utf8_decode(sv);
a3601 1
#ifndef PERL_MICRO
d3622 1
a3622 1
#if defined(MSDOS) && !defined(DJGPP)
a3632 1
#endif /* !PERL_MICRO */
a3639 3
#ifdef THREADS_HAVE_PIDS
    PL_ppid = (IV)getppid();
#endif
d3658 1
a3658 1
	    incpush(s, TRUE, TRUE, TRUE);
d3660 1
a3660 1
	    incpush(PerlEnv_getenv("PERLLIB"), FALSE, FALSE, TRUE);
d3669 1
a3669 1
	    do { incpush(buf,TRUE,TRUE,TRUE); } while (my_trnlnm("PERL5LIB",buf,++idx));
d3671 1
a3671 1
	    while (my_trnlnm("PERLLIB",buf,idx++)) incpush(buf,FALSE,FALSE,TRUE);
d3679 1
a3679 1
    incpush(APPLLIB_EXP, TRUE, TRUE, TRUE);
d3683 1
a3683 1
    incpush(ARCHLIB_EXP, FALSE, FALSE, TRUE);
d3696 1
a3696 1
	    incpush(SvPVX(privdir), TRUE, FALSE, TRUE);
d3699 1
a3699 1
	    incpush(SvPVX(privdir), TRUE, FALSE, TRUE);
d3704 1
a3704 1
	incpush(":", FALSE, FALSE, TRUE);
d3710 1
a3710 1
    incpush(PRIVLIB_EXP, TRUE, FALSE, TRUE);
d3712 1
a3712 1
    incpush(PRIVLIB_EXP, FALSE, FALSE, TRUE);
d3719 1
a3719 1
    incpush(SITEARCH_EXP, FALSE, FALSE, TRUE);
d3725 1
a3725 2
    /* this picks up sitearch as well */
    incpush(SITELIB_EXP, TRUE, FALSE, TRUE);
d3727 1
a3727 1
    incpush(SITELIB_EXP, FALSE, FALSE, TRUE);
d3732 1
a3732 1
    incpush(SITELIB_STEM, FALSE, TRUE, TRUE);
d3739 1
a3739 1
    incpush(PERL_VENDORARCH_EXP, FALSE, FALSE, TRUE);
d3745 1
a3745 1
    incpush(PERL_VENDORLIB_EXP, TRUE, FALSE, TRUE);	/* this picks up vendorarch as well */
d3747 1
a3747 1
    incpush(PERL_VENDORLIB_EXP, FALSE, FALSE, TRUE);
d3752 1
a3752 1
    incpush(PERL_VENDORLIB_STEM, FALSE, TRUE, TRUE);
d3756 1
a3756 1
    incpush(PERL_OTHERLIBDIRS, TRUE, TRUE, TRUE);
d3760 1
a3760 1
	incpush(".", FALSE, FALSE, TRUE);
d3782 1
a3782 1
S_incpush(pTHX_ char *p, int addsubdirs, int addoldvers, int usesep)
d3799 4
a3802 6
	if (usesep) {
	    while ( *p == PERLLIB_SEP ) {
		/* Uncomment the next line for PATH semantics */
		/* av_push(GvAVn(PL_incgv), newSVpvn(".", 1)); */
		p++;
	    }
d3805 1
a3805 1
	if ( usesep && (s = strchr(p, PERLLIB_SEP)) != Nullch ) {
d3993 1
a3993 2
	if (PL_savebegin) {
	    if (paramList == PL_beginav) {
d3995 3
a3997 10
		if (! PL_beginav_save)
		    PL_beginav_save = newAV();
		av_push(PL_beginav_save, (SV*)cv);
	    }
	    else if (paramList == PL_checkav) {
		/* save PL_checkav for compiler */
		if (! PL_checkav_save)
		    PL_checkav_save = newAV();
		av_push(PL_checkav_save, (SV*)cv);
	    }
d4014 1
d4028 1
a4028 1
		Perl_croak(aTHX_ "%"SVf"", atsv);
@


1.1.1.7
log
@perl 5.8.3 from CPAN
@
text
@d924 3
@


1.1.1.8
log
@Import of stock perl 5.8.5
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, by Larry Wall and others
a14 59
/* PSz 12 Nov 03
 * 
 * Be proud that perl(1) may proclaim:
 *   Setuid Perl scripts are safer than C programs ...
 * Do not abandon (deprecate) suidperl. Do not advocate C wrappers.
 * 
 * The flow was: perl starts, notices script is suid, execs suidperl with same
 * arguments; suidperl opens script, checks many things, sets itself with
 * right UID, execs perl with similar arguments but with script pre-opened on
 * /dev/fd/xxx; perl checks script is as should be and does work. This was
 * insecure: see perlsec(1) for many problems with this approach.
 * 
 * The "correct" flow should be: perl starts, opens script and notices it is
 * suid, checks many things, execs suidperl with similar arguments but with
 * script on /dev/fd/xxx; suidperl checks script and /dev/fd/xxx object are
 * same, checks arguments match #! line, sets itself with right UID, execs
 * perl with same arguments; perl checks many things and does work.
 * 
 * (Opening the script in perl instead of suidperl, we "lose" scripts that
 * are readable to the target UID but not to the invoker. Where did
 * unreadable scripts work anyway?)
 * 
 * For now, suidperl and perl are pretty much the same large and cumbersome
 * program, so suidperl can check its argument list (see comments elsewhere).
 * 
 * References:
 * Original bug report:
 *   http://bugs.perl.org/index.html?req=bug_id&bug_id=20010322.218
 *   http://rt.perl.org/rt2/Ticket/Display.html?id=6511
 * Comments and discussion with Debian:
 *   http://bugs.debian.org/203426
 *   http://bugs.debian.org/220486
 * Debian Security Advisory DSA 431-1 (does not fully fix problem):
 *   http://www.debian.org/security/2004/dsa-431
 * CVE candidate:
 *   http://cve.mitre.org/cgi-bin/cvename.cgi?name=CAN-2003-0618
 * Previous versions of this patch sent to perl5-porters:
 *   http://www.mail-archive.com/perl5-porters@@perl.org/msg71953.html
 *   http://www.mail-archive.com/perl5-porters@@perl.org/msg75245.html
 *   http://www.mail-archive.com/perl5-porters@@perl.org/msg75563.html
 *   http://www.mail-archive.com/perl5-porters@@perl.org/msg75635.html
 * 
Paul Szabo - psz@@maths.usyd.edu.au  http://www.maths.usyd.edu.au:8000/u/psz/
School of Mathematics and Statistics  University of Sydney   2006  Australia
 * 
 */
/* PSz 13 Nov 03
 * Use truthful, neat, specific error messages.
 * Cannot always hide the truth; security must not depend on doing so.
 */

/* PSz 18 Feb 04
 * Use global(?), thread-local fdscript for easier checks.
 * (I do not understand how we could possibly get a thread race:
 * do not all threads go through the same initialization? Or in
 * fact, are not threads started only after we get the script and
 * so know what to do? Oh well, make things super-safe...)
 */

d52 1
a52 1
#endif /* IAMSUID */
d903 1
a903 3
		    PerlIO_printf(Perl_debug_log, "leaked: 0x%p"
                                  pTHX__FORMAT "\n",
                                  sv pTHX__VALUE);
d1065 1
a1065 1
#endif /* IAMSUID */
d1095 1
a1095 1
	 * contiguous with the argv[].  This is used in mg.c:Perl_magic_set()
d1256 1
a1262 2
    PL_fdscript = -1;
    PL_suidscript = -1;
a1275 6
    /*
     * Can we rely on the kernel to start scripts with argv[1] set to
     * contain all #! line switches (the whole line)? (argv[0] is set to
     * the interpreter name, argv[2] to the script name; argv[3] and
     * above may contain other arguments.)
     */
d1330 2
a1331 1
	    forbid_setid("-e");
d1428 1
a1428 2
			    Perl_sv_catpvf(aTHX_ PL_Sv,"q%c\t%s\n%c,",
				    0, PL_localpatches[i], 0);
d1489 1
d1564 1
a1564 1
    open_script(scriptname,dosearch,sv);
d1566 1
a1566 1
    validate_suid(validarg, scriptname);
a2445 27
    static char *usage_msgd[] = {
      " Debugging flag values: (see also -d)",
      "  p  Tokenizing and parsing (with v, displays parse stack)",
      "  s  Stack snapshots. with v, displays all stacks",
      "  l  Context (loop) stack processing",
      "  t  Trace execution",
      "  o  Method and overloading resolution",
      "  c  String/numeric conversions",
      "  P  Print profiling info, preprocessor command for -P, source file input state",
      "  m  Memory allocation",
      "  f  Format processing",
      "  r  Regular expression parsing and execution",
      "  x  Syntax tree dump",
      "  u  Tainting checks (Obsolete, previously used for LEAKTEST)",
      "  H  Hash dump -- usurps values()",
      "  X  Scratchpad allocation",
      "  D  Cleaning up",
      "  S  Thread synchronization",
      "  T  Tokenising",
      "  R  Include reference counts of dumped variables (eg when using -Ds)",
      "  J  Do not s,t,P-debug (Jump over) opcodes within package DB",
      "  v  Verbose: use in conjunction with other flags",
      "  C  Copy On Write",
      "  A  Consistency checks on internal structures",
      "  q  quiet - currently only suppressed the 'EXECUTING' message",
      NULL
    };
d2456 2
a2457 2
	        Perl_warner(aTHX_ packWARN(WARN_DEBUGGING),
		    "invalid option -D%c, use -D'' to see choices\n", **s);
d2460 1
a2460 1
    else if (isDIGIT(**s)) {
a2463 4
    else {
      char **p = usage_msgd;
      while (*p) PerlIO_printf(PerlIO_stdout(), "%s\n", *p++);
    }
a2518 1
	 sv_setsv(get_sv("/", TRUE), PL_rs);
d2577 1
a2577 1
	           "Recompile perl with -DDEBUGGING to use -D switch (did you mean -d ?)\n");
d2753 1
a2753 1
		      "\n\nCopyright 1987-2004, Larry Wall\n");
a2980 1
/* PSz 18 Nov 03  fdscript now global but do not change prototype */
d2982 1
a2982 1
S_open_script(pTHX_ char *scriptname, bool dosearch, SV *sv)
a2983 1
#ifndef IAMSUID
a2987 1
#endif
d2989 1
a2989 2
    PL_fdscript = -1;
    PL_suidscript = -1;
d3000 1
a3000 1
	    PL_fdscript = atoi(s);
a3003 20
		/* PSz 18 Feb 04
		 * Tell apart "normal" usage of fdscript, e.g.
		 * with bash on FreeBSD:
		 *   perl <( echo '#!perl -DA'; echo 'print "$0\n"')
		 * from usage in suidperl.
		 * Does any "normal" usage leave garbage after the number???
		 * Is it a mistake to use a similar /dev/fd/ construct for
		 * suidperl?
		 */
		PL_suidscript = 1;
		/* PSz 20 Feb 04  
		 * Be supersafe and do some sanity-checks.
		 * Still, can we be sure we got the right thing?
		 */
		if (*s != '/') {
		    Perl_croak(aTHX_ "Wrong syntax (suid) fd script name \"%s\"\n", s);
		}
		if (! *(s+1)) {
		    Perl_croak(aTHX_ "Missing (suid) fd script name\n");
		}
d3015 2
a3016 2
    if (PL_fdscript >= 0) {
	PL_rsfp = PerlIO_fdopen(PL_fdscript,PERL_SCRIPT_MODE);
a3022 17
#ifdef IAMSUID
    else {
	Perl_croak(aTHX_ "sperl needs fd script\n"
		   "You should not call sperl directly; do you need to "
		   "change a #! line\nfrom sperl to perl?\n");

/* PSz 11 Nov 03
 * Do not open (or do other fancy stuff) while setuid.
 * Perl does the open, and hands script to suidperl on a fd;
 * suidperl only does some checks, sets up UIDs and re-execs
 * perl with that fd as it has always done.
 */
    }
    if (PL_suidscript != 1) {
	Perl_croak(aTHX_ "suidperl needs (suid) fd script\n");
    }
#else /* IAMSUID */
d3079 19
a3118 1
#endif /* IAMSUID */
d3120 24
a3143 4
	/* PSz 16 Sep 03  Keep neat error message */
	Perl_croak(aTHX_ "Can't open perl script \"%s\": %s%s\n",
		CopFILE(PL_curcop), Strerror(errno),
		".\nUse -S to search $PATH for it.");
a3157 5
/* PSz 27 Feb 04
 * We used to do this as "plain" user (after swapping UIDs with setreuid);
 * but is needed also on machines without setreuid.
 * Seems safe enough to run as root.
 */
a3159 6
    /* PSz 12 Nov 03
     * Need to check noexec also: nosuid might not be set, the average
     * sysadmin would say that nosuid is irrelevant once he sets noexec.
     */
    int on_noexec  = 0; /* the fd is on a noexec fs */

a3177 5
#ifdef ST_NOEXEC
    /* ST_NOEXEC certainly absent on AIX 5.1, and doesn't seem to be documented
       on platforms where it is present.  */
    on_noexec  = check_okay && (stfs.f_flag  & ST_NOEXEC);
#endif
a3181 1
        defined(PERL_MOUNT_NOEXEC)	&& \
a3189 1
    on_noexec  = check_okay && (stfs.f_flags & PERL_MOUNT_NOEXEC);
a3193 1
        defined(PERL_MOUNT_NOEXEC)	&& \
a3215 1
                        on_noexec = fsd.fd_req.flags & PERL_MOUNT_NOEXEC;
d3226 1
a3226 2
        defined(MNTOPT_NOSUID)		&& \
        defined(MNTOPT_NOEXEC)
a3240 2
                if (hasmntopt(entry, MNTOPT_NOEXEC))
                    on_noexec = 1;
d3250 2
a3251 6
	Perl_croak(aTHX_ "Can't check filesystem of script \"%s\" for nosuid/noexec", PL_origfilename);
    if (on_nosuid)
	Perl_croak(aTHX_ "Setuid script \"%s\" on nosuid filesystem", PL_origfilename);
    if (on_noexec)
	Perl_croak(aTHX_ "Setuid script \"%s\" on noexec filesystem", PL_origfilename);
    return ((!check_okay) || on_nosuid || on_noexec);
d3256 1
a3256 1
S_validate_suid(pTHX_ char *validarg, char *scriptname)
d3259 2
a3260 2
    /* int which; */
#endif /* IAMSUID */
a3275 7
     * PSz 27 Feb 04
     * Description/comments above do not match current workings:
     *   suidperl must be hardlinked to sperlN.NNN (that is what we exec);
     *   suidperl called with script open and name changed to /dev/fd/N/X;
     *   suidperl croaks if script is not setuid;
     *   making perl setuid would be a huge security risk (and yes, that
     *     would lose any euid we might have had).
d3287 1
a3287 1
    if (PL_statbuf.st_mode & (S_ISUID|S_ISGID)) {
d3292 1
a3292 22
	if (PL_fdscript < 0 || PL_suidscript != 1)
	    Perl_croak(aTHX_ "Need (suid) fdscript in suidperl\n");	/* We already checked this */
	/* PSz 11 Nov 03
	 * Since the script is opened by perl, not suidperl, some of these
	 * checks are superfluous. Leaving them in probably does not lower
	 * security(?!).
	 */
	/* PSz 27 Feb 04
	 * Do checks even for systems with no HAS_SETREUID.
	 * We used to swap, then re-swap UIDs with
#ifdef HAS_SETREUID
	    if (setreuid(PL_euid,PL_uid) < 0
		|| PerlProc_getuid() != PL_euid || PerlProc_geteuid() != PL_uid)
		Perl_croak(aTHX_ "Can't swap uid and euid");
#endif
#ifdef HAS_SETREUID
	    if (setreuid(PL_uid,PL_euid) < 0
		|| PerlProc_getuid() != PL_uid || PerlProc_geteuid() != PL_euid)
		Perl_croak(aTHX_ "Can't reswap uid and euid");
#endif
	 */

a3299 2
	 * 
	 * So, access() is pretty useless... but not harmful... do anyway.
d3302 2
a3303 1
	    Perl_croak(aTHX_ "Can't access() script\n");
d3305 1
a3305 1

a3309 20
	 * 
	 * PSz 24 Feb 04
	 * As the script is opened by perl, not suidperl, we do not need to
	 * care much about access rights.
	 * 
	 * The 'script changed' check is needed, or we can get lied to
	 * about $0 with e.g.
	 *  suidperl /dev/fd/4//bin/x 4<setuidscript
	 * Without HAS_SETREUID, is it safe to stat() as root?
	 * 
	 * Are there any operating systems that pass /dev/fd/xxx for setuid
	 * scripts, as suggested/described in perlsec(1)? Surely they do not
	 * pass the script name as we do, so the "script changed" test would
	 * fail for them... but we never get here with
	 * SETUID_SCRIPTS_ARE_SECURE_NOW defined.
	 * 
	 * This is one place where we must "lie" about return status: not
	 * say if the stat() failed. We are doing this as root, and could
	 * be tricked into reporting existence or not of files that the
	 * "plain" user cannot even see.
d3313 22
a3334 2
	    if (PerlLIO_stat(CopFILE(PL_curcop),&tmpstatbuf) < 0 ||
		tmpstatbuf.st_dev != PL_statbuf.st_dev ||
d3336 3
a3338 1
		Perl_croak(aTHX_ "Setuid script changed\n");
d3340 12
a3351 1

d3353 1
a3353 15
	if (!cando(S_IXUSR,FALSE,&PL_statbuf))		/* can real uid exec? */
	    Perl_croak(aTHX_ "Real UID cannot exec script\n");

	/* PSz 27 Feb 04
	 * We used to do this check as the "plain" user (after swapping
	 * UIDs). But the check for nosuid and noexec filesystem is needed,
	 * and should be done even without HAS_SETREUID. (Maybe those
	 * operating systems do not have such mount options anyway...)
	 * Seems safe enough to do as root.
	 */
#if !defined(NO_NOSUID_CHECK)
	if (fd_on_nosuid_fs(PerlIO_fileno(PL_rsfp))) {
	    Perl_croak(aTHX_ "Setuid script on nosuid or noexec filesystem\n");
	}
#endif
d3357 2
a3358 1
	    Perl_croak(aTHX_ "Setuid script not plain file\n");
a3362 1
	/* PSz 13 Nov 03  But -s was caught elsewhere ... so unsetting it here is useless(?!) */
d3368 2
a3369 8
	/* PSz 27 Feb 04 */
	/* Sanity check on line length */
	if (strlen(s) < 1 || strlen(s) > 4000)
	    Perl_croak(aTHX_ "Very long #! line");
	/* Allow more than a single space after #! */
	while (isSPACE(*s)) s++;
	/* Sanity check on buffer end */
	while ((*s) && !isSPACE(*s)) s++;
d3372 1
a3372 3
	/* Sanity check on buffer start */
	if ( (s2-4 < SvPV(PL_linestr,n_a)+2 || strnNE(s2-4,"perl",4)) &&
	      (s-9 < SvPV(PL_linestr,n_a)+2 || strnNE(s-9,"perl",4)) )
a3379 17
	/*
	 * The way validarg was set up, we rely on the kernel to start
	 * scripts with argv[1] set to contain all #! line switches (the
	 * whole line).
	 */
	/*
	 * Check that we got all the arguments listed in the #! line (not
	 * just that there are no extraneous arguments). Might not matter
	 * much, as switches from #! line seem to be acted upon (also), and
	 * so may be checked and trapped in perl. But, security checks must
	 * be done in suidperl and not deferred to perl. Note that suidperl
	 * does not get around to parsing (and checking) the switches on
	 * the #! line (but execs perl sooner).
	 * Allow (require) a trailing newline (which may be of two
	 * characters on some architectures?) (but no other trailing
	 * whitespace).
	 */
d3382 1
a3382 2
	    strnNE(s,validarg,len) || !isSPACE(s[len]) ||
	    !(strlen(s) == len+1 || (strlen(s) == len+2 && isSPACE(s[len+1]))))
d3386 1
a3386 2
	if (PL_fdscript < 0 &&
	    PL_euid != PL_uid && (PL_statbuf.st_mode & S_ISUID) &&
d3393 2
a3394 16
	if (PL_fdscript < 0 &&
	    PL_euid) {	/* oops, we're not the setuid root perl */
	    /* PSz 18 Feb 04
	     * When root runs a setuid script, we do not go through the same
	     * steps of execing sperl and then perl with fd scripts, but
	     * simply set up UIDs within the same perl invocation; so do
	     * not have the same checks (on options, whatever) that we have
	     * for plain users. No problem really: would have to be a script
	     * that does not actually work for plain users; and if root is
	     * foolish and can be persuaded to run such an unsafe script, he
	     * might run also non-setuid ones, and deserves what he gets.
	     * 
	     * Or, we might drop the PL_euid check above (and rely just on
	     * PL_fdscript to avoid loops), and do the execs
	     * even for root.
	     */
d3396 1
a3396 30
	    int which;
	    /* PSz 11 Nov 03
	     * Pass fd script to suidperl.
	     * Exec suidperl, substituting fd script for scriptname.
	     * Pass script name as "subdir" of fd, which perl will grok;
	     * in fact will use that to distinguish this from "normal"
	     * usage, see comments above.
	     */
	    PerlIO_rewind(PL_rsfp);
	    PerlLIO_lseek(PerlIO_fileno(PL_rsfp),(Off_t)0,0);  /* just in case rewind didn't */
	    /* PSz 27 Feb 04  Sanity checks on scriptname */
	    if ((!scriptname) || (!*scriptname) ) {
		Perl_croak(aTHX_ "No setuid script name\n");
	    }
	    if (*scriptname == '-') {
		Perl_croak(aTHX_ "Setuid script name may not begin with dash\n");
		/* Or we might confuse it with an option when replacing
		 * name in argument list, below (though we do pointer, not
		 * string, comparisons).
		 */
	    }
	    for (which = 1; PL_origargv[which] && PL_origargv[which] != scriptname; which++) ;
	    if (!PL_origargv[which]) {
		Perl_croak(aTHX_ "Can't change argv to have fd script\n");
	    }
	    PL_origargv[which] = savepv(Perl_form(aTHX_ "/dev/fd/%d/%s",
					  PerlIO_fileno(PL_rsfp), PL_origargv[which]));
#if defined(HAS_FCNTL) && defined(F_SETFD)
	    fcntl(PerlIO_fileno(PL_rsfp),F_SETFD,0);	/* ensure no close-on-exec */
#endif
d3402 2
a3403 2
#endif /* IAMSUID */
	    Perl_croak(aTHX_ "Can't do setuid (cannot exec sperl)\n");
a3406 6
/* PSz 26 Feb 04
 * This seems back to front: we try HAS_SETEGID first; if not available
 * then try HAS_SETREGID; as a last chance we try HAS_SETRESGID. May be OK
 * in the sense that we only want to set EGID; but are there any machines
 * with either of the latter, but not the former? Same with UID, later.
 */
d3460 1
a3460 1
	    Perl_croak(aTHX_ "Effective UID cannot exec script\n");	/* they can't do this */
d3463 1
a3463 1
    else if (PL_preprocess)	/* PSz 13 Nov 03  Caught elsewhere, useless(?!) here */
d3465 2
a3466 3
    else if (PL_fdscript < 0 || PL_suidscript != 1)
	/* PSz 13 Nov 03  Caught elsewhere, useless(?!) here */
	Perl_croak(aTHX_ "(suid) fdscript needed in suidperl\n");
d3468 2
a3469 2
/* PSz 16 Sep 03  Keep neat error message */
	Perl_croak(aTHX_ "Script is not setuid/setgid in suidperl\n");
a3474 30
    /* 
     * It might be thought that using setresgid and/or setresuid (changed to
     * set the saved IDs) above might obviate the need to exec, and we could
     * go on to "do the perl thing".
     * 
     * Is there such a thing as "saved GID", and is that set for setuid (but
     * not setgid) execution like suidperl? Without exec, it would not be
     * cleared for setuid (but not setgid) scripts (or might need a dummy
     * setresgid).
     * 
     * We need suidperl to do the exact same argument checking that perl
     * does. Thus it cannot be very small; while it could be significantly
     * smaller, it is safer (simpler?) to make it essentially the same
     * binary as perl (but they are not identical). - Maybe could defer that
     * check to the invoked perl, and suidperl be a tiny wrapper instead;
     * but prefer to do thorough checks in suidperl itself. Such deferral
     * would make suidperl security rely on perl, a design no-no.
     * 
     * Setuid things should be short and simple, thus easy to understand and
     * verify. They should do their "own thing", without influence by
     * attackers. It may help if their internal execution flow is fixed,
     * regardless of platform: it may be best to exec anyway.
     * 
     * Suidperl should at least be conceptually simple: a wrapper only,
     * never to do any real perl. Maybe we should put
     * #ifdef IAMSUID
     *         Perl_croak(aTHX_ "Suidperl should never do real perl\n");
     * #endif
     * into the perly bits.
     */
d3477 7
a3483 10
    /* PSz 11 Nov 03
     * Keep original arguments: suidperl already has fd script.
     */
/*  for (which = 1; PL_origargv[which] && PL_origargv[which] != scriptname; which++) ;	*/
/*  if (!PL_origargv[which]) {						*/
/*	errno = EPERM;							*/
/*	Perl_croak(aTHX_ "Permission denied\n");			*/
/*  }									*/
/*  PL_origargv[which] = savepv(Perl_form(aTHX_ "/dev/fd/%d/%s",	*/
/*				  PerlIO_fileno(PL_rsfp), PL_origargv[which]));	*/
d3492 1
a3492 1
    Perl_croak(aTHX_ "Can't do setuid (suidperl cannot exec perl)\n");
a3592 9
    /* BUG */
    /* PSz 27 Feb 04
     * Should go by suidscript, not uid!=euid: why disallow
     * system("ls") in scripts run from setuid things?
     * Or, is this run before we check arguments and set suidscript?
     * What about SETUID_SCRIPTS_ARE_SECURE_NOW: could we use fdscript then?
     * (We never have suidscript, can we be sure to have fdscript?)
     * Or must then go by UID checks? See comments in forbid_setid also.
     */
a3633 1
#ifdef SETUID_SCRIPTS_ARE_SECURE_NOW
a3637 29
#endif /* SETUID_SCRIPTS_ARE_SECURE_NOW */
    /* PSz 29 Feb 04
     * Checks for UID/GID above "wrong": why disallow
     *   perl -e 'print "Hello\n"'
     * from within setuid things?? Simply drop them: replaced by
     * fdscript/suidscript and #ifdef IAMSUID checks below.
     * 
     * This may be too late for command-line switches. Will catch those on
     * the #! line, after finding the script name and setting up
     * fdscript/suidscript. Note that suidperl does not get around to
     * parsing (and checking) the switches on the #! line, but checks that
     * the two sets are identical.
     * 
     * With SETUID_SCRIPTS_ARE_SECURE_NOW, could we use fdscript, also or
     * instead, or would that be "too late"? (We never have suidscript, can
     * we be sure to have fdscript?)
     * 
     * Catch things with suidscript (in descendant of suidperl), even with
     * right UID/GID. Was already checked in suidperl, with #ifdef IAMSUID,
     * below; but I am paranoid.
     * 
     * Also see comments about root running a setuid script, elsewhere.
     */
    if (PL_suidscript >= 0)
        Perl_croak(aTHX_ "No %s allowed with (suid) fdscript", s);
#ifdef IAMSUID
    /* PSz 11 Nov 03  Catch it in suidperl, always! */
    Perl_croak(aTHX_ "No %s allowed in suidperl", s);
#endif /* IAMSUID */
d4422 1
a4422 1
	if (!vaxc$errno)		/* unlikely */
@


1.1.1.9
log
@perl 5.8.6 from CPAN
@
text
@a14 6
/* This file contains the top-level functions that are used to create, use
 * and destroy a perl interpreter, plus the functions used by XS code to
 * call back into perl. Note that it does not contain the actual main()
 * function of the interpreter; that can be found in perlmain.c
 */

d204 2
a205 1
    return ZeroD(my_perl, 1, PerlInterpreter);
a272 3
	    /* value lookup in void context - happens to have the side effect
	       of caching the numeric forms.  */
	    SvIV(&PL_sv_no);
a277 1
	    SvIV(&PL_sv_yes);
d593 1
a593 1
    if (environ != PL_origenviron && !PL_use_safe_putenv
a612 3
    /* reset so print() ends up where we expect */
    setdefout(Nullgv);

d753 3
d962 3
a964 4
		    PerlIO_printf(Perl_debug_log, "leaked: sv=0x%p"
			" flags=0x08%"UVxf
			" refcnt=%"UVuf pTHX__FORMAT "\n",
			sv, sv->sv_flags, sv->sv_refcnt pTHX__VALUE);
d1053 1
a1053 1
	SvOOK_off(PL_mess_sv);
a2341 4
    /* fail now; otherwise we could fail after the JMPENV_PUSH but
     * before a PUSHEVAL, which corrupts the stack after a croak */
    TAINT_PROPER("eval_sv()");

a2512 6
  return get_debug_opts_flags(s, 1);
}

int
Perl_get_debug_opts_flags(pTHX_ char **s, int flags)
{
d2516 1
a2516 1
      "  s  Stack snapshots (with v, displays all stacks)",
d2526 1
a2526 1
      "  u  Tainting checks",
d2537 1
a2537 1
      "  q  quiet - currently only suppresses the 'EXECUTING' message",
d2558 1
a2558 2
    else if (flags & 1) {
      /* Give help.  */
a2641 7

        /* -dt indicates to the debugger that threads will be used */
	if (*s == 't' && !isALNUM(s[1])) {
	    ++s;
	    my_setenv("PERL5DB_THREADED", "1");
	}

d2672 1
a2672 1
	PL_debug = get_debug_opts_flags(&s, 1) | DEBUG_TOP_FLAG;
d2789 1
a2789 1
	    Perl_croak(aTHX_ "Missing argument to -%c", *(s-1));
d2922 1
a2922 1
Internet, point your browser at http://www.perl.org/, the Perl Home Page.\n\n");
d3243 3
a3245 2
	Perl_croak(aTHX_ "Can't open perl script \"%s\": %s\n",
		CopFILE(PL_curcop), Strerror(errno));
d4221 1
a4221 2
	if (env) {
          char** origenv = environ;
d4223 1
a4223 1
	    if (!(s = strchr(*env,'=')) || s == *env)
a4233 5
	    if (origenv != environ) {
	      /* realloc has shifted us */
	      env = (env - origenv) + environ;
	      origenv = environ;
	    }
a4234 1
      }
@


1.1.1.10
log
@perl 5.8.8 import
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006, by Larry Wall and others
a94 15
#ifdef DEBUG_LEAKING_SCALARS_FORK_DUMP
#  ifdef I_SYS_WAIT
#   include <sys/wait.h>
#  endif
#  ifdef I_SYSUIO
#    include <sys/uio.h>
#  endif

union control_un {
  struct cmsghdr cm;
  char control[CMSG_SPACE(sizeof(int))];
};

#endif

d170 1
a170 1
    /* Newx() needs interpreter, so call malloc() instead */
d206 1
a206 1
    /* Newx() needs interpreter, so call malloc() instead */
d210 1
a210 1
    return (PerlInterpreter *) ZeroD(my_perl, 1, PerlInterpreter);
a230 1
    PERL_UNUSED_ARG(my_perl);
d335 1
a335 1
    PL_localpatches = (char **) local_patches;	/* For possible -v */
d382 2
a383 5
     * available or if the sysconf() fails, use the HZ.
     * BeOS has those, but returns the wrong value.
     * The HZ if not originally defined has been by now
     * been defined as CLK_TCK, if available. */
#if defined(HAS_SYSCONF) && defined(_SC_CLK_TCK) && !defined(__BEOS__)
a408 98
#ifdef DEBUG_LEAKING_SCALARS_FORK_DUMP
void
Perl_dump_sv_child(pTHX_ SV *sv)
{
    ssize_t got;
    const int sock = PL_dumper_fd;
    const int debug_fd = PerlIO_fileno(Perl_debug_log);
    union control_un control;
    struct msghdr msg;
    struct iovec vec[2];
    struct cmsghdr *cmptr;
    int returned_errno;
    unsigned char buffer[256];

    if(sock == -1 || debug_fd == -1)
	return;

    PerlIO_flush(Perl_debug_log);

    /* All these shenanigans are to pass a file descriptor over to our child for
       it to dump out to.  We can't let it hold open the file descriptor when it
       forks, as the file descriptor it will dump to can turn out to be one end
       of pipe that some other process will wait on for EOF. (So as it would
       be open, the wait would be forever.  */

    msg.msg_control = control.control;
    msg.msg_controllen = sizeof(control.control);
    /* We're a connected socket so we don't need a destination  */
    msg.msg_name = NULL;
    msg.msg_namelen = 0;
    msg.msg_iov = vec;
    msg.msg_iovlen = 1;

    cmptr = CMSG_FIRSTHDR(&msg);
    cmptr->cmsg_len = CMSG_LEN(sizeof(int));
    cmptr->cmsg_level = SOL_SOCKET;
    cmptr->cmsg_type = SCM_RIGHTS;
    *((int *)CMSG_DATA(cmptr)) = 1;

    vec[0].iov_base = (void*)&sv;
    vec[0].iov_len = sizeof(sv);
    got = sendmsg(sock, &msg, 0);

    if(got < 0) {
	perror("Debug leaking scalars parent sendmsg failed");
	abort();
    }
    if(got < sizeof(sv)) {
	perror("Debug leaking scalars parent short sendmsg");
	abort();
    }

    /* Return protocol is
       int:		errno value
       unsigned char:	length of location string (0 for empty)
       unsigned char*:	string (not terminated)
    */
    vec[0].iov_base = (void*)&returned_errno;
    vec[0].iov_len = sizeof(returned_errno);
    vec[1].iov_base = buffer;
    vec[1].iov_len = 1;

    got = readv(sock, vec, 2);

    if(got < 0) {
	perror("Debug leaking scalars parent read failed");
	PerlIO_flush(PerlIO_stderr());
	abort();
    }
    if(got < sizeof(returned_errno) + 1) {
	perror("Debug leaking scalars parent short read");
	PerlIO_flush(PerlIO_stderr());
	abort();
    }

    if (*buffer) {
	got = read(sock, buffer + 1, *buffer);
	if(got < 0) {
	    perror("Debug leaking scalars parent read 2 failed");
	    PerlIO_flush(PerlIO_stderr());
	    abort();
	}

	if(got < *buffer) {
	    perror("Debug leaking scalars parent short read 2");
	    PerlIO_flush(PerlIO_stderr());
	    abort();
	}
    }

    if (returned_errno || *buffer) {
	Perl_warn(aTHX_ "Debug leaking scalars child failed%s%.*s with errno"
		  " %d: %s", (*buffer ? " at " : ""), (int) *buffer, buffer + 1,
		  returned_errno, strerror(returned_errno));
    }
}
#endif

a421 3
#ifdef DEBUG_LEAKING_SCALARS_FORK_DUMP
    pid_t child;
#endif
a426 2
    PERL_UNUSED_ARG(my_perl);

d504 3
a506 3
	const char * const s = PerlEnv_getenv("PERL_DESTRUCT_LEVEL");
	if (s) {
            const int i = atoi(s);
d513 2
a514 1
    if (PL_exit_flags & PERL_EXIT_DESTRUCT_END) {
a518 1
	PERL_UNUSED_VAR(x);
a533 154
#ifdef DEBUG_LEAKING_SCALARS_FORK_DUMP
    if (destruct_level != 0) {
	/* Fork here to create a child. Our child's job is to preserve the
	   state of scalars prior to destruction, so that we can instruct it
	   to dump any scalars that we later find have leaked.
	   There's no subtlety in this code - it assumes POSIX, and it doesn't
	   fail gracefully  */
	int fd[2];

	if(socketpair(AF_UNIX, SOCK_STREAM, 0, fd)) {
	    perror("Debug leaking scalars socketpair failed");
	    abort();
	}

	child = fork();
	if(child == -1) {
	    perror("Debug leaking scalars fork failed");
	    abort();
	}
	if (!child) {
	    /* We are the child */
	    const int sock = fd[1];
	    const int debug_fd = PerlIO_fileno(Perl_debug_log);
	    int f;
	    const char *where;
	    /* Our success message is an integer 0, and a char 0  */
	    static const char success[sizeof(int) + 1];

	    close(fd[0]);

	    /* We need to close all other file descriptors otherwise we end up
	       with interesting hangs, where the parent closes its end of a
	       pipe, and sits waiting for (another) child to terminate. Only
	       that child never terminates, because it never gets EOF, because
	       we also have the far end of the pipe open.  We even need to
	       close the debugging fd, because sometimes it happens to be one
	       end of a pipe, and a process is waiting on the other end for
	       EOF. Normally it would be closed at some point earlier in
	       destruction, but if we happen to cause the pipe to remain open,
	       EOF never occurs, and we get an infinite hang. Hence all the
	       games to pass in a file descriptor if it's actually needed.  */

	    f = sysconf(_SC_OPEN_MAX);
	    if(f < 0) {
		where = "sysconf failed";
		goto abort;
	    }
	    while (f--) {
		if (f == sock)
		    continue;
		close(f);
	    }

	    while (1) {
		SV *target;
		union control_un control;
		struct msghdr msg;
		struct iovec vec[1];
		struct cmsghdr *cmptr;
		ssize_t got;
		int got_fd;

		msg.msg_control = control.control;
		msg.msg_controllen = sizeof(control.control);
		/* We're a connected socket so we don't need a source  */
		msg.msg_name = NULL;
		msg.msg_namelen = 0;
		msg.msg_iov = vec;
		msg.msg_iovlen = sizeof(vec)/sizeof(vec[0]);

		vec[0].iov_base = (void*)&target;
		vec[0].iov_len = sizeof(target);
      
		got = recvmsg(sock, &msg, 0);

		if(got == 0)
		    break;
		if(got < 0) {
		    where = "recv failed";
		    goto abort;
		}
		if(got < sizeof(target)) {
		    where = "short recv";
		    goto abort;
		}

		if(!(cmptr = CMSG_FIRSTHDR(&msg))) {
		    where = "no cmsg";
		    goto abort;
		}
		if(cmptr->cmsg_len != CMSG_LEN(sizeof(int))) {
		    where = "wrong cmsg_len";
		    goto abort;
		}
		if(cmptr->cmsg_level != SOL_SOCKET) {
		    where = "wrong cmsg_level";
		    goto abort;
		}
		if(cmptr->cmsg_type != SCM_RIGHTS) {
		    where = "wrong cmsg_type";
		    goto abort;
		}

		got_fd = *(int*)CMSG_DATA(cmptr);
		/* For our last little bit of trickery, put the file descriptor
		   back into Perl_debug_log, as if we never actually closed it
		*/
		if(got_fd != debug_fd) {
		    if (dup2(got_fd, debug_fd) == -1) {
			where = "dup2";
			goto abort;
		    }
		}
		sv_dump(target);

		PerlIO_flush(Perl_debug_log);

		got = write(sock, &success, sizeof(success));

		if(got < 0) {
		    where = "write failed";
		    goto abort;
		}
		if(got < sizeof(success)) {
		    where = "short write";
		    goto abort;
		}
	    }
	    _exit(0);
	abort:
	    {
		int send_errno = errno;
		unsigned char length = (unsigned char) strlen(where);
		struct iovec failure[3] = {
		    {(void*)&send_errno, sizeof(send_errno)},
		    {&length, 1},
		    {(void*)where, length}
		};
		int got = writev(sock, failure, 3);
		/* Bad news travels fast. Faster than data. We'll get a SIGPIPE
		   in the parent if we try to read from the socketpair after the
		   child has exited, even if there was data to read.
		   So sleep a bit to give the parent a fighting chance of
		   reading the data.  */
		sleep(2);
		_exit((got == -1) ? errno : 0);
	    }
	    /* End of child.  */
	}
	PL_dumper_fd = fd[0];
	close(fd[1]);
    }
#endif
    
a536 5
    /* Do this now, because destroying ops can cause new SVs to be generated
       in Perl_pad_swipe, and when running with -DDEBUG_LEAKING_SCALARS they
       PL_curcop to point to a valid op from which the filename structure
       member is copied.  */
    PL_curcop = &PL_compiling;
d545 1
a565 2
	if (PL_defoutgv && !SvREFCNT(PL_defoutgv))
	    PL_defoutgv = Nullgv; /* may have been freed */
d637 1
d648 1
a648 2
            else if(SvIOKp(resv)) {
		REGEXP *re = INT2PTR(REGEXP *,SvIVX(resv));
d904 9
a912 5
	I32 riter = 0;
	const I32 max = HvMAX(PL_strtab);
	HE ** const array = HvARRAY(PL_strtab);
	HE *hent = array[0];

d916 2
a917 2
		     "Unbalanced string table refcount: (%ld) for \"%s\"",
		     (long)(HeVAL(hent) - Nullsv), HeKEY(hent));
a974 3
#ifdef DEBUG_LEAKING_SCALARS_FORK_DUMP
		    Perl_dump_sv_child(aTHX_ sv);
#endif
a978 18
#ifdef DEBUG_LEAKING_SCALARS_FORK_DUMP
    {
	int status;
	fd_set rset;
	/* Wait for up to 4 seconds for child to terminate.
	   This seems to be the least effort way of timing out on reaping
	   its exit status.  */
	struct timeval waitfor = {4, 0};
	int sock = PL_dumper_fd;

	shutdown(sock, 1);
	FD_ZERO(&rset);
	FD_SET(sock, &rset);
	select(sock + 1, &rset, NULL, NULL, &waitfor);
	waitpid(child, &status, WNOHANG);
	close(sock);
    }
#endif
d1000 2
a1001 1
    Safefree(PL_reg_curpm);
a1049 2
	/* we know that type == SVt_PVMG */

d1051 10
a1060 8
	MAGIC* mg;
	MAGIC* moremagic;
	for (mg = SvMAGIC(PL_mess_sv); mg; mg = moremagic) {
	    moremagic = mg->mg_moremagic;
	    if (mg->mg_ptr && mg->mg_type != PERL_MAGIC_regex_global
		&& mg->mg_len >= 0)
		Safefree(mg->mg_ptr);
	    Safefree(mg);
a1061 1

d1063 2
a1064 1
	SvPV_free(PL_mess_sv);
a1103 21
#if defined(USE_5005THREADS) || defined(USE_ITHREADS)
/* provide destructors to clean up the thread key when libperl is unloaded */
#ifndef WIN32 /* handled during DLL_PROCESS_DETACH in win32/perllib.c */

#if defined(__hpux) && __ux_version > 1020 && !defined(__GNUC__)
#pragma fini "perl_fini"
#endif

static void
#if defined(__GNUC__)
__attribute__((destructor))
#endif
perl_fini(void)
{
    if (PL_curinterp)
	FREE_THREAD_KEY;
}

#endif /* WIN32 */
#endif /* THREADS */

a1130 2
    PERL_UNUSED_VAR(my_perl);

d1148 4
a1151 1
	const char * const s = PerlEnv_getenv("PERL_HASH_SEED_DEBUG");
d1153 4
a1156 2
	if (s && (atoi(s) == 1))
	    PerlIO_printf(Perl_debug_log, "HASH_SEED = %"UVuf"\n", PL_rehash_seed);
d1171 1
a1171 1
	 const char *s = NULL;
d1173 1
a1173 1
	 const UV mask =
d1176 1
a1176 1
	 const UV aligned =
d1326 1
a1326 1
    const char *scriptname = NULL;
d1328 1
a1328 1
    const char *validarg = "";
d1331 1
a1331 4
    const char *cddir = Nullch;
#ifdef USE_SITECUSTOMIZE
    bool minus_f = FALSE;
#endif
a1423 7
	case 'f':
#ifdef USE_SITECUSTOMIZE
	    minus_f = TRUE;
#endif
	    s++;
	    goto reswitch;

d1430 1
d1432 1
a1432 1
		const char * const p = savepvn(s, len);
d1453 5
a1457 11
	    {
		SV *opts_prog;

		if (!PL_preambleav)
		    PL_preambleav = newAV();
		av_push(PL_preambleav,
			newSVpv("use Config;",0));
		if (*++s != ':')  {
		    STRLEN opts;
		
		    opts_prog = newSVpv("print Config::myconfig(),",0);
d1459 1
a1459 1
		    sv_catpv(opts_prog,"\"\\nCharacteristics of this PERLSHR image: \\n\",");
d1461 1
a1461 1
		    sv_catpv(opts_prog,"\"\\nCharacteristics of this binary (from libperl): \\n\",");
d1463 1
a1463 3
		    opts = SvCUR(opts_prog);

		    Perl_sv_catpv(aTHX_ opts_prog,"\"  Compile-time options:"
d1465 1
a1465 10
			     " DEBUGGING"
#  endif
#  ifdef DEBUG_LEAKING_SCALARS
			     " DEBUG_LEAKING_SCALARS"
#  endif
#  ifdef DEBUG_LEAKING_SCALARS_FORK_DUMP
			     " DEBUG_LEAKING_SCALARS_FORK_DUMP"
#  endif
#  ifdef FAKE_THREADS
			     " FAKE_THREADS"
d1468 1
a1468 40
			     " MULTIPLICITY"
#  endif
#  ifdef MYMALLOC
			     " MYMALLOC"
#  endif
#  ifdef PERL_DONT_CREATE_GVSV
			     " PERL_DONT_CREATE_GVSV"
#  endif
#  ifdef PERL_GLOBAL_STRUCT
			     " PERL_GLOBAL_STRUCT"
#  endif
#  ifdef PERL_IMPLICIT_CONTEXT
			     " PERL_IMPLICIT_CONTEXT"
#  endif
#  ifdef PERL_IMPLICIT_SYS
			     " PERL_IMPLICIT_SYS"
#  endif
#  ifdef PERL_MALLOC_WRAP
			     " PERL_MALLOC_WRAP"
#  endif
#  ifdef PERL_NEED_APPCTX
			     " PERL_NEED_APPCTX"
#  endif
#  ifdef PERL_NEED_TIMESBASE
			     " PERL_NEED_TIMESBASE"
#  endif
#  ifdef PERL_OLD_COPY_ON_WRITE
			     " PERL_OLD_COPY_ON_WRITE"
#  endif
#  ifdef PERL_TRACK_MEMPOOL
			     " PERL_TRACK_MEMPOOL"
#  endif
#  ifdef PERL_USE_SAFE_PUTENV
			     " PERL_USE_SAFE_PUTENV"
#  endif
#  ifdef PL_OP_SLAB_ALLOC
			     " PL_OP_SLAB_ALLOC"
#  endif
#  ifdef THREADS_HAVE_PIDS
			     " THREADS_HAVE_PIDS"
d1471 1
a1471 1
			     " USE_5005THREADS"
d1473 2
a1474 2
#  ifdef USE_64_BIT_ALL
			     " USE_64_BIT_ALL"
d1477 1
a1477 1
			     " USE_64_BIT_INT"
d1479 2
a1480 5
#  ifdef USE_ITHREADS
			     " USE_ITHREADS"
#  endif
#  ifdef USE_LARGE_FILES
			     " USE_LARGE_FILES"
d1483 1
a1483 1
			     " USE_LONG_DOUBLE"
d1485 2
a1486 2
#  ifdef USE_PERLIO
			     " USE_PERLIO"
d1488 2
a1489 2
#  ifdef USE_REENTRANT_API
			     " USE_REENTRANT_API"
d1491 2
a1492 2
#  ifdef USE_SFIO
			     " USE_SFIO"
d1494 2
a1495 5
#  ifdef USE_SITECUSTOMIZE
			     " USE_SITECUSTOMIZE"
#  endif	       
#  ifdef USE_SOCKS
			     " USE_SOCKS"
d1497 1
a1497 22
			     );

		    while (SvCUR(opts_prog) > opts+76) {
			/* find last space after "options: " and before col 76
			 */

			const char *space;
			char *pv = SvPV_nolen(opts_prog);
			const char c = pv[opts+76];
			pv[opts+76] = '\0';
			space = strrchr(pv+opts+26, ' ');
			pv[opts+76] = c;
			if (!space) break; /* "Can't happen" */

			/* break the line before that space */

			opts = space - pv;
			sv_insert(opts_prog, opts, 0,
				  "\\n                       ", 25);
		    }

		    sv_catpv(opts_prog,"\\n\",");
d1500 7
a1506 9
		    if (LOCAL_PATCH_COUNT > 0) {
			int i;
			sv_catpv(opts_prog,
				 "\"  Locally applied patches:\\n\",");
			for (i = 1; i <= LOCAL_PATCH_COUNT; i++) {
			    if (PL_localpatches[i])
				Perl_sv_catpvf(aTHX_ opts_prog,"q%c\t%s\n%c,",
					       0, PL_localpatches[i], 0);
			}
d1508 1
d1510 1
a1510 2
		    Perl_sv_catpvf(aTHX_ opts_prog,
				   "\"  Built under %s\\n\"",OSNAME);
d1513 1
a1513 3
		    Perl_sv_catpvf(aTHX_ opts_prog,
				   ",\"  Compiled at %s %s\\n\"",__DATE__,
				   __TIME__);
d1515 1
a1515 2
		    Perl_sv_catpvf(aTHX_ opts_prog,",\"  Compiled on %s\\n\"",
				   __DATE__);
d1518 3
a1520 3
		    sv_catpv(opts_prog, "; $\"=\"\\n    \"; "
			     "@@env = map { \"$_=\\\"$ENV{$_}\\\"\" } "
			     "sort grep {/^PERL/} keys %ENV; ");
d1522 2
a1523 2
		    sv_catpv(opts_prog,
			     "push @@env, \"CYGWIN=\\\"$ENV{CYGWIN}\\\"\";");
d1525 9
a1533 15
		    sv_catpv(opts_prog, 
			     "print \"  \\%ENV:\\n    @@env\\n\" if @@env;"
			     "print \"  \\@@INC:\\n    @@INC\\n\";");
		}
		else {
		    ++s;
		    opts_prog = Perl_newSVpvf(aTHX_
					      "Config::config_vars(qw%c%s%c)",
					      0, s, 0);
		    s += strlen(s);
		}
		av_push(PL_preambleav, opts_prog);
		/* don't look for script or read stdin */
		scriptname = BIT_BUCKET;
		goto reswitch;
d1535 3
d1553 1
a1553 1
		s = (char *)"v";
d1557 1
a1557 1
		s = (char *)"h";
d1574 1
a1574 1
    	const char *popt = s;
a1620 9
#ifdef USE_SITECUSTOMIZE
    if (!minus_f) {
	if (!PL_preambleav)
	    PL_preambleav = newAV();
	av_unshift(PL_preambleav, 1);
	(void)av_store(PL_preambleav, 0, Perl_newSVpvf(aTHX_ "BEGIN { do '%s/sitecustomize.pl' }", SITELIB_EXP));
    }
#endif

d1668 1
a1668 1
	if (cddir && PerlDir_chdir( (char *)cddir ) < 0)
d1680 1
a1680 1
    Newx(CvMUTEXP(PL_compcv), 1, perl_mutex);
d1711 2
a1712 2
    /* PL_unicode is turned on by -C, or by $ENV{PERL_UNICODE},
     * or explicitly in some platforms.
a1714 3
#if defined(SYMBIAN)
    PL_unicode = PERL_UNICODE_STD_FLAG; /* See PERL_SYMBIAN_CONSOLE_UTF8. */
#endif
a1834 2
    PERL_UNUSED_ARG(my_perl);

d1896 1
a1896 1
STATIC void
a1903 1
#ifdef DEBUGGING
a1904 1
#endif
d1936 1
d1939 1
d2009 1
a2009 1
    GV* const gv = gv_fetchpv(name, create, SVt_PVHV);
d2187 1
a2187 1
	    const I32 gimme = GIMME_V;
d2201 1
a2201 1
		sv_setpvn(ERRSV,"",0);
d2220 1
a2220 1
		sv_setpvn(ERRSV,"",0);
a2261 3
	    PERL_UNUSED_VAR(newsp);
	    PERL_UNUSED_VAR(gimme);
	    PERL_UNUSED_VAR(optype);
d2289 1
a2289 1
S_call_body(pTHX_ const OP *myop, bool is_eval)
d2320 1
d2335 1
d2366 1
a2366 1
	    sv_setpvn(ERRSV,"",0);
d2429 2
a2430 1
	Perl_croak(aTHX_ SvPVx_nolen_const(ERRSV));
d2456 5
a2460 2
    sv = Perl_newSVpvf(aTHX_ "require q%c%s%c", 0, pv, 0);
    eval_sv(sv_2mortal(sv), G_DISCARD);
d2475 1
a2475 1
S_usage(pTHX_ const char *name)		/* XXX move this out into a module ? */
d2480 1
a2480 1
    static const char * const usage_msg[] = {
a2487 1
"-f              don't do $sitelib/sitecustomize.pl at startup",
d2492 2
a2493 2
"-[mM][-]module  execute \"use/no module...\" before executing program",
"-n              assume \"while (<>) { ... }\" loop around program",
d2511 1
a2511 1
    const char * const *p = usage_msg;
d2533 1
a2533 1
    static const char * const usage_msgd[] = {
d2563 1
a2563 1
	static const char debopts[] = "psltocPmfrxu HXDSTRJvC";
d2566 1
a2566 1
	    const char *d = strchr(debopts,**s);
d2580 1
a2580 1
      const char *const *p = usage_msgd;
d2597 1
a2603 1
	 STRLEN numlen;
d2607 1
a2607 1
	      const char *e = s+=2;
d2610 1
a2610 2
	      while (*e)
		e++;
d2673 1
a2673 1
            const char *start;
d2683 3
a2685 1
		Perl_sv_catpvf(aTHX_ sv, " split(/,/,q%c%s%c)", 0, ++s, 0);
d2688 1
a2688 1
	    my_setenv("PERL5DB", (char *)SvPV_nolen_const(sv));
d2700 1
a2700 1
	PL_debug = get_debug_opts_flags( &s, 1) | DEBUG_TOP_FLAG;
d2707 1
d2714 2
a2715 1
	Safefree(PL_inplace);
d2723 2
a2724 2
	for (s = PL_inplace; *s && !isSPACE(*s); s++)
	    ;
a2764 1
	    STRLEN numlen;
d2787 1
a2787 1
	    const char *use = "use ";
d2789 2
a2790 4
	    /* Leading space on " no " is deliberate, to make both
	       possibilities the same length.  */
	    if (*s == '-') { use = " no "; ++s; }
	    sv = newSVpvn(use,4);
d2880 1
a2880 1
		      "\n\nCopyright 1987-2006, Larry Wall\n");
d2949 1
a2949 1
this system using \"man perl\" or \"perldoc perl\".  If you have access to the\n\
d3041 1
a3041 1
#      define PERLVARIC(var,type,init)		PERL_GET_INTERP->var = init;
d3086 1
a3086 1
    hv_name_set(PL_defstash, "main", 4, 0);
a3096 3
#ifdef PERL_DONT_CREATE_GVSV
    gv_SVadd(PL_errgv);
#endif
d3110 1
a3110 1
S_open_script(pTHX_ const char *scriptname, bool dosearch, SV *sv)
d3113 4
a3116 4
    const char *quote;
    const char *code;
    const char *cpp_discard_flag;
    const char *perl;
d3127 1
a3127 1
	scriptname = PL_origfilename = find_script((char *)scriptname, dosearch, NULL, 1);
d3130 1
a3130 1
            const char *s = scriptname + 8;
d3157 1
a3157 1
		PL_origfilename = (char *)scriptname;
d3164 2
a3165 2
    if (*PL_origfilename == '-' && PL_origfilename[1] == '\0')
	scriptname = (char *)"";
d3192 1
a3192 1
	const char *cpp_cfg = CPPSTDIN;
d3209 1
a3209 2
			      scriptname, SvPVX_const (cpp), SvPVX_const (sv),
			      CPPMINUS));
d3250 1
a3250 1
                              SvPVX_const(cmd)));
d3252 1
a3252 1
	PL_rsfp = PerlProc_popen((char *)SvPVX_const(cmd), (char *)"r");
d3271 2
a3272 5
	if (PL_e_script)
	    Perl_croak(aTHX_ "Can't open "BIT_BUCKET": %s\n", Strerror(errno));
	else
	    Perl_croak(aTHX_ "Can't open perl script \"%s\": %s\n",
		    CopFILE(PL_curcop), Strerror(errno));
d3362 4
a3365 3
                    check_okay = 1;
                    on_nosuid = fsd.fd_req.flags & PERL_MOUNT_NOSUID;
                    on_noexec = fsd.fd_req.flags & PERL_MOUNT_NOEXEC;
d3412 1
a3412 1
S_validate_suid(pTHX_ const char *validarg, const char *scriptname)
d3446 1
a3446 1
    const char *s, *s2;
d3452 1
a3452 1
	const char *linestr;
d3550 2
a3551 5
	if (sv_gets(PL_linestr, PL_rsfp, 0) == Nullch)
	    Perl_croak(aTHX_ "No #! line");
	linestr = SvPV_nolen_const(PL_linestr);
	/* required even on Sys V */
	if (!*linestr || !linestr[1] || strnNE(linestr,"#!",2))
d3553 1
a3553 2
	linestr += 2;
	s = linestr;
d3562 2
a3563 3
	for (s2 = s;  (s2 > linestr &&
		       (isDIGIT(s2[-1]) || s2[-1] == '.' || s2[-1] == '_'
			|| s2[-1] == '-'));  s2--) ;
d3565 2
a3566 2
	if ( (s2-4 < linestr || strnNE(s2-4,"perl",4)) &&
	      (s-9 < linestr || strnNE(s-9,"perl",4)) )
a3804 2
    (void)validarg;
    (void)scriptname;
d3810 1
a3810 2
    register char *s;
    register const char *s2;
d3850 1
a3850 2
		while (isDIGIT(s2[-1]) || s2[-1] == '-' || s2[-1] == '.'
		       || s2[-1] == '_') s2--;
d3852 1
a3918 1
    (void)envp;
d3937 1
a3937 1
S_forbid_setid(pTHX_ const char *s)
d3986 1
d4016 1
a4016 1
    Newx(PL_tmps_stack,REASONABLE(128),SV*);
d4021 1
a4021 1
    Newx(PL_markstack,REASONABLE(32),I32);
d4027 1
a4027 1
    Newx(PL_scopestack,REASONABLE(32),I32);
d4031 1
a4031 1
    Newx(PL_savestack,REASONABLE(128),ANY);
d4109 2
a4110 1
    Safefree(PL_osname);
d4117 1
a4120 1
	    char *s;
d4140 1
a4140 1
	    SV * const sv = newSVpv(argv[0],0);
a4187 16
S_set_caret_X(pTHX) {
    GV* tmpgv = gv_fetchpv("\030",TRUE, SVt_PV); /* $^X */
    if (tmpgv) {
#ifdef HAS_PROCSELFEXE
	S_procself_val(aTHX_ GvSV(tmpgv), PL_origargv[0]);
#else
#ifdef OS2
	sv_setpv(GvSVn(tmpgv), os2_execname(aTHX));
#else
	sv_setpv(GvSVn(tmpgv),PL_origargv[0]);
#endif
#endif
    }
}

STATIC void
d4190 2
d4215 11
a4225 1
    S_set_caret_X(aTHX);
a4249 2
	  char *s;
	  SV *sv;
a4297 8
/*
 * It isn't possible to delete an environment variable with
 * PERL_USE_SAFE_PUTENV set unless unsetenv() is also available, so in that
 * case we treat PERL5LIB as undefined if it has a zero-length value.
 */
#if defined(PERL_USE_SAFE_PUTENV) && ! defined(HAS_UNSETENV)
	if (s && *s != '\0')
#else
a4298 1
#endif
d4406 1
a4406 1
#if defined(DOSISH) || defined(EPOC) || defined(SYMBIAN)
a4422 15
/* Push a directory onto @@INC if it exists.
   Generate a new SV if we do this, to save needing to copy the SV we push
   onto @@INC  */
STATIC SV *
S_incpush_if_exists(pTHX_ SV *dir)
{
    Stat_t tmpstatbuf;
    if (PerlLIO_stat(SvPVX_const(dir), &tmpstatbuf) >= 0 &&
	S_ISDIR(tmpstatbuf.st_mode)) {
	av_push(GvAVn(PL_incgv), dir);
	dir = NEWSV(0,0);
    }
    return dir;
}

d4424 1
a4424 1
S_incpush(pTHX_ const char *dir, bool addsubdirs, bool addoldvers, bool usesep)
a4426 1
    const char *p = dir;
d4432 1
a4432 1
	subdir = NEWSV(0,0);
d4438 1
a4438 1
        const char *s;
d4478 1
d4508 3
a4510 1
		subdir = S_incpush_if_exists(aTHX_ subdir);
d4516 3
a4518 1
		subdir = S_incpush_if_exists(aTHX_ subdir);
d4522 3
a4524 2
		subdir = S_incpush_if_exists(aTHX_ subdir);

d4532 3
a4534 1
		    subdir = S_incpush_if_exists(aTHX_ subdir);
a4542 4
    if (subdir) {
	assert (SvREFCNT(subdir) == 1);
	SvREFCNT_dec(subdir);
    }
d4554 1
a4554 1
    Newxz(thr, 1, struct perl_thread);
d4564 2
a4565 2
    Newx(PL_thrsv, 1, SV);
    Newxz(xpv, 1, XPV);
d4569 1
a4569 1
    SvPV_set(PL_thrsv, (char*)thr);
d4629 1
a4629 1
    const line_t oldline = CopLINE(PL_curcop);
d4635 1
a4635 1
    while (av_len(paramList) >= 0) {
d4664 1
a4664 1
	    (void)SvPV_const(atsv, len);
a4804 2
    PERL_UNUSED_VAR(gimme);
    PERL_UNUSED_VAR(newsp);
d4810 3
a4812 6
    const char * const p  = SvPVX_const(PL_e_script);
    const char *nl = strchr(p, '\n');

    PERL_UNUSED_ARG(idx);
    PERL_UNUSED_ARG(maxlen);

d4819 1
a4819 1
    sv_chop(PL_e_script, (char *) nl);
a4821 10

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 noet:
 */
@


1.1.1.11
log
@import perl 5.10.0 from CPAN
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007 by Larry Wall and others
d140 33
a172 29
#define CALL_BODY_EVAL(myop) \
    if (PL_op == (myop)) \
	PL_op = Perl_pp_entereval(aTHX); \
    if (PL_op) \
	CALLRUNOPS(aTHX);

#define CALL_BODY_SUB(myop) \
    if (PL_op == (myop)) \
	PL_op = Perl_pp_entersub(aTHX); \
    if (PL_op) \
	CALLRUNOPS(aTHX);

#define CALL_LIST_BODY(cv) \
    PUSHMARK(PL_stack_sp); \
    call_sv((SV*)(cv), G_EVAL|G_DISCARD);

static void
S_init_tls_and_interp(PerlInterpreter *my_perl)
{
    dVAR;
    if (!PL_curinterp) {			
	PERL_SET_INTERP(my_perl);
#if defined(USE_ITHREADS)
	INIT_THREADS;
	ALLOC_THREAD_KEY;
	PERL_SET_THX(my_perl);
	OP_REFCNT_INIT;
	HINTS_REFCNT_INIT;
	MUTEX_INIT(&PL_dollarzero_mutex);
a173 8
#ifdef PERL_IMPLICIT_CONTEXT
	MUTEX_INIT(&PL_my_ctx_mutex);
#  endif
    }
#if defined(USE_ITHREADS)
    else
#else
    /* This always happens for non-ithreads  */
a174 36
    {
	PERL_SET_THX(my_perl);
    }
}


/* these implement the PERL_SYS_INIT, PERL_SYS_INIT3, PERL_SYS_TERM macros */

void
Perl_sys_init(int* argc, char*** argv)
{
    dVAR;
    PERL_UNUSED_ARG(argc); /* may not be used depending on _BODY macro */
    PERL_UNUSED_ARG(argv);
    PERL_SYS_INIT_BODY(argc, argv);
}

void
Perl_sys_init3(int* argc, char*** argv, char*** env)
{
    dVAR;
    PERL_UNUSED_ARG(argc); /* may not be used depending on _BODY macro */
    PERL_UNUSED_ARG(argv);
    PERL_UNUSED_ARG(env);
    PERL_SYS_INIT3_BODY(argc, argv, env);
}

void
Perl_sys_term()
{
    dVAR;
    if (!PL_veto_cleanup) {
	PERL_SYS_TERM_BODY();
    }
}

d187 1
a187 1
    S_init_tls_and_interp(my_perl);
a197 1
    INIT_TRACK_MEMPOOL(PL_memory_debug_header, my_perl);
d217 3
d224 1
a224 2
    S_init_tls_and_interp(my_perl);
#ifndef PERL_TRACK_MEMPOOL
a225 5
#else
    Zero(my_perl, 1, PerlInterpreter);
    INIT_TRACK_MEMPOOL(PL_memory_debug_header, my_perl);
    return my_perl;
#endif
d240 6
a245 1
    dVAR;
d254 19
a272 1
    PL_curcop = &PL_compiling;	/* needed by ckWARN, right away */
d274 6
a279 2
    /* set read-only and try to insure than we wont see REFCNT==0
       very often */
d281 1
a281 2
    SvREADONLY_on(&PL_sv_undef);
    SvREFCNT(&PL_sv_undef) = (~(U32)0)/2;
d283 2
a284 7
    sv_setpv(&PL_sv_no,PL_No);
    /* value lookup in void context - happens to have the side effect
       of caching the numeric forms.  */
    SvIV(&PL_sv_no);
    SvNV(&PL_sv_no);
    SvREADONLY_on(&PL_sv_no);
    SvREFCNT(&PL_sv_no) = (~(U32)0)/2;
d286 3
a288 5
    sv_setpv(&PL_sv_yes,PL_Yes);
    SvIV(&PL_sv_yes);
    SvNV(&PL_sv_yes);
    SvREADONLY_on(&PL_sv_yes);
    SvREFCNT(&PL_sv_yes) = (~(U32)0)/2;
d290 2
a291 2
    SvREADONLY_on(&PL_sv_placeholder);
    SvREFCNT(&PL_sv_placeholder) = (~(U32)0)/2;
d293 21
a313 4
    PL_sighandlerp = (Sighandler_t) Perl_sighandler;
#ifdef PERL_USES_PL_PIDSTATUS
    PL_pidstatus = newHV();
#endif
d315 1
a315 1
    PL_rs = newSVpvs("\n");
d320 1
d328 22
d351 1
a351 1
    PL_localpatches = local_patches;	/* For possible -v */
d362 1
a362 1
    PL_errors = newSVpvs("");
d367 2
a368 2
    /* First entry is an array of empty elements */
    Perl_av_create_and_push(aTHX_ &PL_regex_padav,(SV*)newAV());
d380 3
a409 45
    PL_patchlevel = Perl_newSVpvf(aTHX_ "v%d.%d.%d", (int)PERL_REVISION,
				  (int)PERL_VERSION, (int)PERL_SUBVERSION);

#ifdef HAS_MMAP
    if (!PL_mmap_page_size) {
#if defined(HAS_SYSCONF) && (defined(_SC_PAGESIZE) || defined(_SC_MMAP_PAGE_SIZE))
      {
	SETERRNO(0, SS_NORMAL);
#   ifdef _SC_PAGESIZE
	PL_mmap_page_size = sysconf(_SC_PAGESIZE);
#   else
	PL_mmap_page_size = sysconf(_SC_MMAP_PAGE_SIZE);
#   endif
	if ((long) PL_mmap_page_size < 0) {
	  if (errno) {
	    SV * const error = ERRSV;
	    SvUPGRADE(error, SVt_PV);
	    Perl_croak(aTHX_ "panic: sysconf: %s", SvPV_nolen_const(error));
	  }
	  else
	    Perl_croak(aTHX_ "panic: sysconf: pagesize unknown");
	}
      }
#else
#   ifdef HAS_GETPAGESIZE
      PL_mmap_page_size = getpagesize();
#   else
#       if defined(I_SYS_PARAM) && defined(PAGESIZE)
      PL_mmap_page_size = PAGESIZE;       /* compiletime, bad */
#       endif
#   endif
#endif
      if (PL_mmap_page_size <= 0)
	Perl_croak(aTHX_ "panic: bad pagesize %" IVdf,
		   (IV) PL_mmap_page_size);
    }
#endif /* HAS_MMAP */

#if defined(HAS_TIMES) && defined(PERL_NEED_TIMESBASE)
    PL_timesbase.tms_utime  = 0;
    PL_timesbase.tms_stime  = 0;
    PL_timesbase.tms_cutime = 0;
    PL_timesbase.tms_cstime = 0;
#endif

a424 1
    PERL_UNUSED_CONTEXT;
d451 1
a451 1
       be open, the wait would be forever.)  */
d537 1
a537 2
    dVAR;
    VOL signed char destruct_level;  /* see possible values in intrpvar.h */
d542 4
d552 71
d653 1
a653 2
	PL_veto_cleanup = TRUE;
        return STATUS_EXIT;
d824 1
a824 1
	PL_main_root = NULL;
d826 1
a826 1
    PL_main_start = NULL;
d828 1
a828 1
    PL_main_cv = NULL;
d847 1
a847 1
	    PL_defoutgv = NULL; /* may have been freed */
d852 1
a852 1
    PL_warnhook = NULL;
d854 1
a854 1
    PL_diehook = NULL;
d865 13
a903 16
    if (destruct_level == 0) {

	DEBUG_P(debprofdump());

#if defined(PERLIO_LAYERS)
	/* No more IO - including error messages ! */
	PerlIO_cleanup(aTHX);
#endif

	CopFILE_free(&PL_compiling);
	CopSTASH_free(&PL_compiling);

	/* The exit() function will do everything that needs doing. */
        return STATUS_EXIT;
    }

d905 1
a905 1
    setdefout(NULL);
d915 1
a915 1
        SV * const * const ary = AvARRAY(PL_regex_padav);
d918 1
a918 1
            SV * const resv = ary[--i];
d936 1
a936 1
    PL_regex_padav = NULL;
d945 3
a947 4
    /* XXX can PL_parser still be non-null here? */
    if(PL_parser && PL_parser->rsfp) {
	(void)PerlIO_close(PL_parser->rsfp);
	PL_parser->rsfp = NULL;
d950 3
a952 4
    if (PL_minus_F) {
	Safefree(PL_splitstr);
	PL_splitstr = NULL;
    }
d968 1
a968 1
    PL_inplace = NULL;
d973 1
a973 1
	PL_e_script = NULL;
d981 1
a981 1
    PL_ofs_sv = NULL;
d984 1
a984 1
    PL_ors_sv = NULL;
d987 1
a987 1
    PL_rs = NULL;
d989 1
d991 1
a991 1
    PL_osname = NULL;
d994 2
a995 2
    PL_statname = NULL;
    PL_statgv = NULL;
d1001 1
a1001 1
    PL_lastscream = NULL;
d1009 1
a1009 1
    PL_efloatbuf = NULL;
a1017 2
    SvREFCNT_dec(PL_unitcheckav);
    SvREFCNT_dec(PL_unitcheckav_save);
d1019 6
a1024 8
    PL_beginav = NULL;
    PL_beginav_save = NULL;
    PL_endav = NULL;
    PL_checkav = NULL;
    PL_checkav_save = NULL;
    PL_unitcheckav = NULL;
    PL_unitcheckav_save = NULL;
    PL_initav = NULL;
d1027 19
a1045 19
    PL_envgv = NULL;
    PL_incgv = NULL;
    PL_hintgv = NULL;
    PL_errgv = NULL;
    PL_argvgv = NULL;
    PL_argvoutgv = NULL;
    PL_stdingv = NULL;
    PL_stderrgv = NULL;
    PL_last_in_gv = NULL;
    PL_replgv = NULL;
    PL_DBgv = NULL;
    PL_DBline = NULL;
    PL_DBsub = NULL;
    PL_DBsingle = NULL;
    PL_DBtrace = NULL;
    PL_DBsignal = NULL;
    PL_DBcv = NULL;
    PL_dbargs = NULL;
    PL_debstash = NULL;
d1048 1
a1048 1
    PL_argvout_stack = NULL;
d1051 1
a1051 1
    PL_modglobal = NULL;
d1053 1
a1053 1
    PL_preambleav = NULL;
d1055 3
a1057 2
    PL_subname = NULL;
#ifdef PERL_USES_PL_PIDSTATUS
d1059 1
a1059 2
    PL_pidstatus = NULL;
#endif
d1061 1
a1061 1
    PL_toptarget = NULL;
d1063 2
a1064 2
    PL_bodytarget = NULL;
    PL_formtarget = NULL;
d1069 1
a1069 1
    PL_collation_name = NULL;
d1074 1
a1074 1
    PL_numeric_name = NULL;
d1076 1
a1076 1
    PL_numeric_radix_sv = NULL;
d1100 20
a1119 20
    PL_utf8_alnum	= NULL;
    PL_utf8_alnumc	= NULL;
    PL_utf8_ascii	= NULL;
    PL_utf8_alpha	= NULL;
    PL_utf8_space	= NULL;
    PL_utf8_cntrl	= NULL;
    PL_utf8_graph	= NULL;
    PL_utf8_digit	= NULL;
    PL_utf8_upper	= NULL;
    PL_utf8_lower	= NULL;
    PL_utf8_print	= NULL;
    PL_utf8_punct	= NULL;
    PL_utf8_xdigit	= NULL;
    PL_utf8_mark	= NULL;
    PL_utf8_toupper	= NULL;
    PL_utf8_totitle	= NULL;
    PL_utf8_tolower	= NULL;
    PL_utf8_tofold	= NULL;
    PL_utf8_idstart	= NULL;
    PL_utf8_idcont	= NULL;
d1122 5
a1126 4
	PerlMemShared_free(PL_compiling.cop_warnings);
    PL_compiling.cop_warnings = NULL;
    Perl_refcounted_he_free(aTHX_ PL_compiling.cop_hints_hash);
    PL_compiling.cop_hints_hash = NULL;
d1136 1
a1136 1
    PL_curstname = NULL;
d1140 1
a1140 3
    PL_errors = NULL;

    SvREFCNT_dec(PL_isarev);
d1175 1
a1175 1
    PL_fdpid = NULL;
a1184 3
	 * Now that the global string table is using a single hunk of memory
	 * for both HE and HEK, we either need to explicitly unshare it the
	 * correct way, or actually free things here.
d1188 1
a1188 1
	HE * const * const array = HvARRAY(PL_strtab);
a1192 1
		HE * const next = HeNEXT(hent);
d1195 3
a1197 3
		     (long)hent->he_valu.hent_refcount, HeKEY(hent));
		Safefree(hent);
		hent = next;
a1204 5

	Safefree(array);
	HvARRAY(PL_strtab) = 0;
	HvTOTALKEYS(PL_strtab) = 0;
	HvFILL(PL_strtab) = 0;
d1209 1
a1209 1
    /* free the pointer tables used for cloning */
d1250 3
a1252 11
			" flags=0x%"UVxf
			" refcnt=%"UVuf pTHX__FORMAT "\n"
			"\tallocated at %s:%d %s %s%s\n",
			(void*)sv, sv->sv_flags, sv->sv_refcnt pTHX__VALUE,
			sv->sv_debug_file ? sv->sv_debug_file : "(unknown)",
			sv->sv_debug_line,
			sv->sv_debug_inpad ? "for" : "by",
			sv->sv_debug_optype ?
			    PL_op_name[sv->sv_debug_optype]: "(none)",
			sv->sv_debug_cloned ? " (cloned)" : ""
		    );
a1280 5
#ifdef PERL_DEBUG_READONLY_OPS
    free(PL_slabs);
    PL_slabs = NULL;
    PL_slab_count = 0;
#endif
d1288 1
a1288 1
       as currently layers use it rather than NULL as a marker
d1295 1
a1295 1
    PL_origfilename = NULL;
d1308 1
a1308 1
    PL_bitcount = NULL;
d1311 3
a1313 1
    PL_formfeed = NULL;
d1321 17
a1344 6
    while (PL_regmatch_slab) {
	regmatch_slab  *s = PL_regmatch_slab;
	PL_regmatch_slab = PL_regmatch_slab->next;
	Safefree(s);
    }

d1365 1
a1365 1
	PL_mess_sv = NULL;
d1367 1
a1367 1
    return STATUS_EXIT;
a1380 21
    dVAR;

    if (PL_veto_cleanup)
	return;

#ifdef PERL_TRACK_MEMPOOL
    {
	/*
	 * Don't free thread memory if PERL_DESTRUCT_LEVEL is set to a non-zero
	 * value as we're probably hunting memory leaks then
	 */
	const char * const s = PerlEnv_getenv("PERL_DESTRUCT_LEVEL");
	if (!s || atoi(s) == 0) {
	    /* Emulate the PerlHost behaviour of free()ing all memory allocated in this
	       thread at thread exit.  */
	    while(aTHXx->Imemory_debug_header.next != &(aTHXx->Imemory_debug_header))
		safesysfree(sTHX + (char *)(aTHXx->Imemory_debug_header.next));
	}
    }
#endif

a1382 1
    {
d1384 1
a1384 1
	void *host = nw_internal_host;
d1386 1
a1386 1
	void *host = w32_internal_host;
d1388 1
a1388 1
	PerlMem_free(aTHXx);
d1390 1
a1390 1
	nw_delete_internal_host(host);
d1392 1
a1392 1
	win32_delete_internal_host(host);
a1393 1
    }
d1402 1
a1402 1
#if defined(USE_ITHREADS)
d1406 1
a1406 1
#if defined(__hpux) && !(defined(__ux_version) && __ux_version <= 1020) && !defined(__GNUC__)
a1407 2
#elif defined(__sun) && !defined(__GNUC__)
#pragma fini (perl_fini)
d1416 1
a1416 2
    dVAR;
    if (PL_curinterp  && !PL_veto_cleanup)
a1425 1
    dVAR;
a1431 52
#ifdef HAS_PROCSELFEXE
/* This is a function so that we don't hold on to MAXPATHLEN
   bytes of stack longer than necessary
 */
STATIC void
S_procself_val(pTHX_ SV *sv, const char *arg0)
{
    char buf[MAXPATHLEN];
    int len = readlink(PROCSELFEXE_PATH, buf, sizeof(buf) - 1);

    /* On Playstation2 Linux V1.0 (kernel 2.2.1) readlink(/proc/self/exe)
       includes a spurious NUL which will cause $^X to fail in system
       or backticks (this will prevent extensions from being built and
       many tests from working). readlink is not meant to add a NUL.
       Normal readlink works fine.
     */
    if (len > 0 && buf[len-1] == '\0') {
      len--;
    }

    /* FreeBSD's implementation is acknowledged to be imperfect, sometimes
       returning the text "unknown" from the readlink rather than the path
       to the executable (or returning an error from the readlink).  Any valid
       path has a '/' in it somewhere, so use that to validate the result.
       See http://www.freebsd.org/cgi/query-pr.cgi?pr=35703
    */
    if (len > 0 && memchr(buf, '/', len)) {
	sv_setpvn(sv,buf,len);
    }
    else {
	sv_setpv(sv,arg0);
    }
}
#endif /* HAS_PROCSELFEXE */

STATIC void
S_set_caret_X(pTHX) {
    dVAR;
    GV* tmpgv = gv_fetchpvs("\030", GV_ADD|GV_NOTQUAL, SVt_PV); /* $^X */
    if (tmpgv) {
#ifdef HAS_PROCSELFEXE
	S_procself_val(aTHX_ GvSV(tmpgv), PL_origargv[0]);
#else
#ifdef OS2
	sv_setpv(GvSVn(tmpgv), os2_execname(aTHX));
#else
	sv_setpv(GvSVn(tmpgv),PL_origargv[0]);
#endif
#endif
    }
}

a1442 1
    dVAR;
d1446 3
d1450 1
a1450 1
    PERL_UNUSED_ARG(my_perl);
d1479 1
a1479 4
    if (PL_origalen != 0) {
	PL_origalen = 1; /* don't use old PL_origalen if perl_parse() is called again */
    }
    else {
a1525 2

#ifndef PERL_USE_SAFE_PUTENV
d1527 6
a1532 2
	 if (s && PL_origenviron && !PL_use_safe_putenv) {
	      if ((PL_origenviron[0] == s + 1)
d1540 1
a1540 1
#ifndef OS2		/* ENVIRON is read by the kernel too. */
d1544 1
a1544 1
		   my_setenv("NoNe  SuCh", NULL);
d1563 1
a1563 3
#endif /* !defined(PERL_USE_SAFE_PUTENV) */

	 PL_origalen = s ? s - PL_origargv[0] + 1 : 0;
a1573 4
	assert (!PL_tainted);
	TAINT;
	S_set_caret_X(aTHX);
	TAINT_NOT;
d1580 1
a1580 1
	PL_main_root = NULL;
d1582 1
a1582 1
    PL_main_start = NULL;
d1584 1
a1584 1
    PL_main_cv = NULL;
d1590 3
d1594 1
d1597 1
d1599 1
a1599 2
	if (PL_unitcheckav)
	    call_list(oldscope, PL_unitcheckav);
a1612 2
	if (PL_unitcheckav)
	    call_list(oldscope, PL_unitcheckav);
d1615 1
a1615 1
	ret = STATUS_EXIT;
d1626 11
a1639 2
    dVAR;
    PerlIO *rsfp;
d1646 2
a1647 2
    register char c;
    const char *cddir = NULL;
a1650 5
    SV *linestr_sv = newSV_type(SVt_PVIV);
    bool add_read_e_script = FALSE;

    SvGROW(linestr_sv, 80);
    sv_setpvn(linestr_sv,"",0);
d1652 4
a1655 1
    sv = newSVpvs("");		/* first used for -I flags */
a1658 2
    {
	const char *s;
d1676 1
a1676 1
	switch ((c = *s)) {
a1720 3
	case 'E':
	    PL_minus_E = TRUE;
	    /* FALL THROUGH */
d1727 1
a1727 1
	    forbid_setid('e', -1);
d1729 2
a1730 2
		PL_e_script = newSVpvs("");
		add_read_e_script = TRUE;
d1739 2
a1740 2
		Perl_croak(aTHX_ "No code specified for -%c", c);
	    sv_catpvs(PL_e_script, "\n");
d1751 2
a1752 2
	    forbid_setid('I', -1);
	    if (!*++s && (s=argv[1]) != NULL) {
d1758 2
a1759 2
		incpush(p, TRUE, TRUE, FALSE, FALSE);
		sv_catpvs(sv, "-I");
d1761 1
a1761 1
		sv_catpvs(sv, " ");
d1768 1
a1768 1
	    forbid_setid('P', -1);
a1770 1
	    deprecate("-P");
d1773 1
a1773 1
	    forbid_setid('S', -1);
d1781 4
a1784 1
		Perl_av_create_and_push(aTHX_ &PL_preambleav, newSVpvs("use Config;"));
d1786 11
a1796 3
		    /* Can't do newSVpvs() as that would involve pre-processor
		       condititionals inside a macro expansion.  */
		    opts_prog = Perl_newSVpv(aTHX_ "$_ = join ' ', sort qw("
d1800 14
a1813 2
#  ifdef NO_MATHOMS
                            " NO_MATHOMS"
d1818 9
d1830 2
a1831 2
#  ifdef PERL_MEM_LOG
			     " PERL_MEM_LOG"
d1833 2
a1834 2
#  ifdef PERL_MEM_LOG_ENV
			     " PERL_MEM_LOG_ENV"
d1836 2
a1837 2
#  ifdef PERL_MEM_LOG_ENV_FD
			     " PERL_MEM_LOG_ENV_FD"
d1839 2
a1840 5
#  ifdef PERL_MEM_LOG_STDERR
			     " PERL_MEM_LOG_STDERR"
#  endif
#  ifdef PERL_MEM_LOG_TIMESTAMP
			     " PERL_MEM_LOG_TIMESTAMP"
d1845 33
d1881 4
a1884 1
					     , 0);
d1886 18
a1903 8
		    sv_catpv(opts_prog, PL_bincompat_options);
		    /* Terminate the qw(, and then wrap at 76 columns.  */
		    sv_catpvs(opts_prog, "); s/(?=.{53})(.{1,53}) /$1\\n                        /mg;print Config::myconfig(),");
#ifdef VMS
		    sv_catpvs(opts_prog,"\"\\nCharacteristics of this PERLSHR image: \\n");
#else
		    sv_catpvs(opts_prog,"\"\\nCharacteristics of this binary (from libperl): \\n");
#endif
d1905 1
a1905 1
		    sv_catpvs(opts_prog,"  Compile-time options: $_\\n\",");
d1910 1
a1910 1
			sv_catpvs(opts_prog,
d1920 1
a1920 1
				   "\"  Built under %s\\n",OSNAME);
d1924 1
a1924 1
				   "  Compiled at %s %s\\n\"",__DATE__,
d1927 1
a1927 1
		    Perl_sv_catpvf(aTHX_ opts_prog,"  Compiled on %s\\n\"",
d1931 1
a1931 1
		    sv_catpvs(opts_prog, "; $\"=\"\\n    \"; "
d1935 1
a1935 1
		    sv_catpvs(opts_prog,
d1938 1
a1938 1
		    sv_catpvs(opts_prog, 
a1981 2
    }

a1983 3
    {
	char *s;

d1999 1
a1999 1
	    char *popt_copy = NULL;
d2012 1
a2012 1
		if (!strchr("CDIMUdmtw", *s))
a2035 1
    }
d2039 4
a2042 2
	(void)Perl_av_create_and_unshift_one(aTHX_ &PL_preambleav,
					     Perl_newSVpvf(aTHX_ "BEGIN { do '%s/sitecustomize.pl' }", SITELIB_EXP));
d2046 4
d2056 1
a2056 1
    else if (scriptname == NULL) {
a2063 5
    /* Set $^X early so that it can be used for relocatable paths in @@INC  */
    assert (!PL_tainted);
    TAINT;
    S_set_caret_X(aTHX);
    TAINT_NOT;
d2066 1
a2066 4
    {
	int suidscript;
	const int fdscript
	    = open_script(scriptname, dosearch, sv, &suidscript, &rsfp);
d2068 1
a2068 2
	validate_suid(validarg, scriptname, fdscript, suidscript,
		linestr_sv, rsfp);
d2071 11
a2081 12
#  if defined(SIGCHLD) || defined(SIGCLD)
	{
#  ifndef SIGCHLD
#    define SIGCHLD SIGCLD
#  endif
	    Sighandler_t sigstate = rsignal_state(SIGCHLD);
	    if (sigstate == (Sighandler_t) SIG_IGN) {
		if (ckWARN(WARN_SIGNAL))
		    Perl_warner(aTHX_ packWARN(WARN_SIGNAL),
				"Can't ignore signal CHLD, forcing to default");
		(void)rsignal(SIGCHLD, (Sighandler_t)SIG_DFL);
	    }
d2083 2
a2084 1
#  endif
a2086 1
	if (PL_doextract
d2088 3
a2090 1
	    || gMacPerl_AlwaysExtract
d2092 3
a2094 1
	    ) {
a2095 9
	    /* This will croak if suidscript is >= 0, as -x cannot be used with
	       setuid scripts.  */
	    forbid_setid('x', suidscript);
	    /* Hence you can't get here if suidscript >= 0  */

	    find_beginning(linestr_sv, rsfp);
	    if (cddir && PerlDir_chdir( (char *)cddir ) < 0)
		Perl_croak(aTHX_ "Can't chdir to %s",cddir);
	}
d2098 2
a2099 1
    PL_main_cv = PL_compcv = (CV*)newSV_type(SVt_PVCV);
d2103 5
a2107 2

    PL_isarev = newHV();
a2111 1
    boot_core_mro();
d2116 1
a2116 1
#if defined(VMS) || defined(WIN32) || defined(DJGPP) || defined(__CYGWIN__) || defined(EPOC) || defined(SYMBIAN)
d2140 1
a2140 1
#if defined(__SYMBIAN32__)
d2165 1
a2165 2
		  (sv = GvSV(gv_fetchpvs("\017PEN", GV_ADD|GV_NOTQUAL,
					 SVt_PV)))) {
a2180 2
    {
	const char *s;
a2188 30
    }

#ifdef PERL_MAD
    {
	const char *s;
    if ((s = PerlEnv_getenv("PERL_XMLDUMP"))) {
	PL_madskills = 1;
	PL_minus_c = 1;
	if (!s || !s[0])
	    PL_xmlfp = PerlIO_stdout();
	else {
	    PL_xmlfp = PerlIO_open(s, "w");
	    if (!PL_xmlfp)
		Perl_croak(aTHX_ "Can't open %s", s);
	}
	my_setenv("PERL_XMLDUMP", NULL);	/* hide from subprocs */
    }
    }

    {
	const char *s;
    if ((s = PerlEnv_getenv("PERL_MADSKILLS"))) {
	PL_madskills = atoi(s);
	my_setenv("PERL_MADSKILLS", NULL);	/* hide from subprocs */
    }
    }
#endif

    lex_start(linestr_sv, rsfp, TRUE);
    PL_subname = newSVpvs("main");
d2190 1
a2190 2
    if (add_read_e_script)
	filter_add(read_e_script, NULL);
d2195 1
d2197 1
a2197 1
    if (gMacPerl_SyntaxError = (yyparse() || PL_parser->error_count)) {
d2206 1
a2206 1
    if (yyparse() || PL_parser->error_count) {
d2220 1
a2220 1
	PL_e_script = NULL;
a2235 2
    {
	const char *s;
a2237 1
    }
a2255 1
    dVAR;
d2259 3
d2270 4
d2275 1
d2281 1
d2284 1
d2298 1
a2298 1
	ret = STATUS_EXIT;
d2308 12
a2319 2
	break;
    }
d2321 1
a2321 2
    JMPENV_POP;
    return ret;
d2323 2
a2328 1
    dVAR;
a2332 6
#ifdef PERL_MAD
	if (PL_xmlfp) {
	    xmldump_all();
	    exit(0);	/* less likely to core dump than my_exit(0) */
	}
#endif
d2335 1
a2335 2
	if (!DEBUG_q_TEST)
	  PERL_DEBUG(PerlIO_printf(Perl_debug_log, "\nEXECUTING...\n\n"));
a2353 3
#ifdef PERL_DEBUG_READONLY_OPS
	Perl_pending_Slabs_to_ro(aTHX);
#endif
d2388 7
d2398 1
a2398 1
    return NULL;
d2416 1
a2416 1
    GV* const gv = gv_fetchpv(name, create, SVt_PVAV);
d2421 1
a2421 1
    return NULL;
d2444 1
a2444 1
    return NULL;
a2449 8
=for apidoc p||get_cvn_flags

Returns the CV of the specified Perl subroutine.  C<flags> are passed to
C<gv_fetchpvn_flags>. If C<GV_ADD> is set and the Perl subroutine does not
exist then it will be declared (which has the same effect as saying
C<sub name;>).  If C<GV_ADD> is not set and the subroutine does not exist
then NULL is returned.

d2452 4
a2455 1
Uses C<strlen> to get the length of C<name>, then calls C<get_cvn_flags>.
d2461 1
a2461 1
Perl_get_cvn_flags(pTHX_ const char *name, STRLEN len, I32 flags)
d2463 2
a2464 1
    GV* const gv = gv_fetchpvn_flags(name, len, flags, SVt_PVCV);
d2468 1
a2468 3
    if ((flags & ~GV_NOADD_MASK) && !GvCVu(gv)) {
	SV *const sv = newSVpvn(name,len);
	SvFLAGS(sv) |= flags & SVf_UTF8;
d2470 3
a2472 3
		      newSVOP(OP_CONST, 0, sv),
		      NULL, NULL);
    }
d2475 1
a2475 7
    return NULL;
}

CV*
Perl_get_cv(pTHX_ const char *name, I32 flags)
{
    return get_cvn_flags(name, strlen(name), flags);
a2496 1
    dVAR;
d2557 1
a2557 1
    dVAR; dSP;
d2561 1
a2561 1
    VOL I32 retval = 0;
d2565 1
a2565 1
    OP* const oldop = PL_op;
d2574 1
a2574 1
    myop.op_next = NULL;
d2607 1
a2607 1
	CALL_BODY_SUB((OP*)&myop);
d2614 19
a2632 1
	create_eval_scope(flags|G_FAKINGEVAL);
d2635 5
d2641 1
a2641 1

d2644 1
d2646 2
a2647 1
	    CALL_BODY_SUB((OP*)&myop);
d2680 16
a2695 2
	if (PL_scopestack_ix > oldscope)
	    delete_eval_scope();
d2709 25
a2748 1
    dVAR;
d2751 2
a2752 2
    VOL I32 oldmark = SP - PL_stack_base;
    VOL I32 retval = 0;
d2754 1
a2754 1
    OP* const oldop = PL_op;
d2770 1
a2770 1
    myop.op_next = NULL;
d2778 5
d2788 1
d2791 1
d2793 2
a2794 1
	CALL_BODY_EVAL((OP*)&myop);
a2848 1
    dVAR;
d2882 1
a2882 1
    dVAR;
a2883 1
    SV* sv;
d2893 1
a2893 1
Perl_magicname(pTHX_ const char *sym, const char *name, I32 namlen)
d2895 1
a2895 1
    register GV * const gv = gv_fetchpv(sym, GV_ADD, SVt_PV);
d2897 1
a2897 1
    if (gv)
d2908 28
a2935 29
"-0[octal]         specify record separator (\\0, if no argument)",
"-a                autosplit mode with -n or -p (splits $_ into @@F)",
"-C[number/list]   enables the listed Unicode features",
"-c                check syntax only (runs BEGIN and CHECK blocks)",
"-d[:debugger]     run program under debugger",
"-D[number/list]   set debugging flags (argument is a bit mask or alphabets)",
"-e program        one line of program (several -e's allowed, omit programfile)",
"-E program        like -e, but enables all optional features",
"-f                don't do $sitelib/sitecustomize.pl at startup",
"-F/pattern/       split() pattern for -a switch (//'s are optional)",
"-i[extension]     edit <> files in place (makes backup if extension supplied)",
"-Idirectory       specify @@INC/#include directory (several -I's allowed)",
"-l[octal]         enable line ending processing, specifies line terminator",
"-[mM][-]module    execute \"use/no module...\" before executing program",
"-n                assume \"while (<>) { ... }\" loop around program",
"-p                assume loop like -n but print line also, like sed",
"-P                run program through C preprocessor before compilation",
"-s                enable rudimentary parsing for switches after programfile",
"-S                look for programfile using PATH environment variable",
"-t                enable tainting warnings",
"-T                enable tainting checks",
"-u                dump core after parsing program",
"-U                allow unsafe operations",
"-v                print version, subversion (includes VERY IMPORTANT perl info)",
"-V[:variable]     print configuration summary (or a single Config.pm variable)",
"-w                enable many useful warnings (RECOMMENDED)",
"-W                enable all warnings",
"-x[directory]     strip off text before #!perl line and perhaps cd to directory",
"-X                disable all warnings",
d2953 7
a2959 1
Perl_get_debug_opts(pTHX_ const char **s, bool givehelp)
d2991 1
a2991 1
	static const char debopts[] = "psltocPmfrxuUHXDSTRJvCAq";
d2994 1
a2994 1
	    const char * const d = strchr(debopts,**s);
d3006 2
a3007 1
    else if (givehelp) {
d3022 2
a3023 2
const char *
Perl_moreswitches(pTHX_ const char *s)
a3024 1
    dVAR;
d3048 1
a3048 1
	      PL_rs = newSVpvs("");
d3061 1
a3061 1
		   PL_rs = newSVpvs("");
d3072 1
a3072 3
        PL_unicode = parse_unicode_opts( (const char **)&s );
	if (PL_unicode & PERL_UNICODE_UTF8CACHEASSERT_FLAG)
	    PL_utf8cache = -1;
d3078 2
a3079 1
	PL_splitstr = savepvn(PL_splitstr, s - PL_splitstr);
d3090 1
a3090 1
	forbid_setid('d', -1);
d3102 4
a3105 4
	    const char *start = ++s;
	    const char *const end = s + strlen(s);
	    SV * const sv = newSVpvs("use Devel::");

d3109 1
a3109 1
		sv_catpvn(sv, start, end - start);
d3112 4
a3115 7
		/* Don't use NUL as q// delimiter here, this string goes in the
		 * environment. */
		Perl_sv_catpvf(aTHX_ sv, " split(/,/,q{%s});", ++s);
	    }
	    s = end;
	    my_setenv("PERL5DB", SvPV_nolen_const(sv));
	    SvREFCNT_dec(sv);
d3125 1
a3125 1
	forbid_setid('D', -1);
d3127 1
a3127 1
	PL_debug = get_debug_opts( (const char **)&s, 1) | DEBUG_TOP_FLAG;
d3143 1
a3143 1
	PL_inplace = savepvs(".bak");
d3147 3
a3149 7
	{
	    const char * const start = ++s;
	    while (*s && !isSPACE(*s))
		++s;

	    PL_inplace = savepvn(start, s - start);
	}
d3151 1
a3151 1
	    ++s;
d3153 1
a3153 1
		s++;
d3157 1
a3157 1
	forbid_setid('I', -1);
d3162 1
a3162 1
	    const char *e, *p;
d3172 1
a3172 1
	    incpush(e, TRUE, TRUE, FALSE, FALSE);
d3186 1
a3186 1
	    PL_ors_sv = NULL;
d3191 1
a3191 1
	    PL_ors_sv = newSVpvs("\n");
d3198 1
a3198 1
		PL_ors_sv = newSVpvs("\n\n");
d3206 1
a3206 1
	forbid_setid('M', -1);	/* XXX ? */
d3209 1
a3209 1
	forbid_setid('m', -1);	/* XXX ? */
d3211 1
a3211 2
	    const char *start;
	    const char *end;
a3221 1
	    end = s + strlen(s);
d3223 1
a3223 1
		sv_catpvn(sv, start, end - start);
d3227 1
a3227 1
		    sv_catpvs( sv, " ()");
d3234 9
a3242 8
		/* Use NUL as q''-delimiter.  */
		sv_catpvs(sv, " split(/,/,q\0");
		++s;
		sv_catpvn(sv, s, end - s);
		sv_catpvs(sv,  "\0)");
	    }
	    s = end;
	    Perl_av_create_and_push(aTHX_ &PL_preambleav, sv);
d3256 1
a3256 1
	forbid_setid('s', -1);
a3281 2
	if (!sv_derived_from(PL_patchlevel, "version"))
	    upg_version(PL_patchlevel, TRUE);
d3284 2
a3285 7
		Perl_form(aTHX_ "\nThis is perl, %"SVf
#ifdef PERL_PATCHNUM
			  " DEVEL" STRINGIFY(PERL_PATCHNUM)
#endif
			  " built for %s",
			  SVfARG(vstringify(PL_patchlevel)),
			  ARCHNAME));
d3289 1
a3289 2
		Perl_form(aTHX_ "\nThis is perl, %"SVf"\n",
		    SVfARG(vstringify(PL_patchlevel))));
d3303 1
a3303 1
			  LOCAL_PATCH_COUNT,
d3308 1
a3308 1
		      "\n\nCopyright 1987-2007, Larry Wall\n");
a3368 4
#ifdef __SYMBIAN32__
	PerlIO_printf(PerlIO_stdout(),
		      "Symbian port by Nokia, 2004-2005\n");
#endif
d3381 1
a3381 1
	if (! (PL_dowarn & G_WARN_ALL_MASK)) {
a3382 1
	}
d3388 1
a3388 1
            PerlMemShared_free(PL_compiling.cop_warnings);
d3395 1
a3395 1
            PerlMemShared_free(PL_compiling.cop_warnings);
d3423 1
a3423 1
    return NULL;
a3433 1
    PERL_UNUSED_CONTEXT;
d3435 2
a3436 2
    SV *    prog = newSVpv(BIN_EXP, 0);
    SV *    file = newSVpv(PL_origfilename, 0);
d3440 4
a3443 2
    sv_catpvs(prog, "/perl");
    sv_catpvs(file, ".perldump");
a3451 2
#  elif defined(WIN32) || defined(__CYGWIN__)
    Perl_croak(aTHX_ "dump is not supported");
d3462 1
a3462 1
    dVAR;
d3467 7
a3473 2
#    define PERLVARI(var,type,init)		aTHX->var = init;
#    define PERLVARIC(var,type,init)	aTHX->var = init;
d3479 3
d3492 3
a3500 4
    /* As these are inside a structure, PERLVARI isn't capable of initialising
       them  */
    PL_reg_oldcurpm = PL_reg_curpm = NULL;
    PL_reg_poscache = PL_reg_starttry = NULL;
a3505 1
    dVAR;
d3509 2
a3510 9
    /* We know that the string "main" will be in the global shared string
       table, so it's a small saving to use it rather than allocate another
       8 bytes.  */
    PL_curstname = newSVpvs_share("main");
    gv = gv_fetchpvs("main::", GV_ADD|GV_NOTQUAL, SVt_PVHV);
    /* If we hadn't caused another reference to "main" to be in the shared
       string table above, then it would be worth reordering these two,
       because otherwise all we do is delete "main" from it as a consequence
       of the SvREFCNT_dec, only to add it again with hv_name_set */
d3512 2
d3515 1
a3515 5
    GvHV(gv) = (HV*)SvREFCNT_inc_simple(PL_defstash);
    SvREADONLY_on(gv);
    PL_incgv = gv_HVadd(gv_AVadd(gv_fetchpvs("INC", GV_ADD|GV_NOTQUAL,
					     SVt_PVAV)));
    SvREFCNT_inc_simple_void(PL_incgv); /* Don't allow it to be freed */
d3517 1
a3517 1
    PL_hintgv = gv_fetchpvs("\010", GV_ADD|GV_NOTQUAL, SVt_PV); /* ^H */
d3519 2
a3520 4
    PL_defgv = gv_fetchpvs("_", GV_ADD|GV_NOTQUAL, SVt_PVAV);
    SvREFCNT_inc_simple_void(PL_defgv);
    PL_errgv = gv_HVadd(gv_fetchpvs("@@", GV_ADD|GV_NOTQUAL, SVt_PV));
    SvREFCNT_inc_simple_void(PL_errgv);
d3522 1
a3522 1
    PL_replgv = gv_fetchpvs("\022", GV_ADD|GV_NOTQUAL, SVt_PV); /* ^R */
d3532 3
a3534 3
    PL_debstash = GvHV(gv_fetchpvs("DB::", GV_ADDMULTI, SVt_PVHV));
    PL_globalstash = GvHV(gv_fetchpvs("CORE::GLOBAL::", GV_ADDMULTI,
				      SVt_PVHV));
d3539 3
a3541 3
STATIC int
S_open_script(pTHX_ const char *scriptname, bool dosearch, SV *sv,
	      int *suidscript, PerlIO **rsfpp)
a3548 2
    int fdscript = -1;
    dVAR;
d3550 2
a3551 1
    *suidscript = -1;
d3554 1
a3554 1
	PL_origfilename = savepvs("-e");
d3558 1
a3558 1
	scriptname = PL_origfilename = find_script(scriptname, dosearch, NULL, 1);
d3562 1
a3562 1
	    fdscript = atoi(s);
d3575 1
a3575 1
		*suidscript = 1;
d3597 2
a3598 2
    if (fdscript >= 0) {
	*rsfpp = PerlIO_fdopen(fdscript,PERL_SCRIPT_MODE);
d3600 1
a3600 1
	    if (*rsfpp)
d3602 1
a3602 1
	        fcntl(PerlIO_fileno(*rsfpp),F_SETFD,1);
d3618 1
a3618 1
    if (*suidscript != 1) {
d3623 3
a3625 3
	const char * const cpp_cfg = CPPSTDIN;
	SV * const cpp = newSVpvs("");
	SV * const cmd = newSV(0);
d3634 1
a3634 1
	    sv_catpvs(sv, "-I");
d3675 2
a3676 2
                       perl, quote, code, quote, scriptname, SVfARG(cpp),
                       cpp_discard_flag, SVfARG(sv), CPPMINUS);
d3684 1
a3684 1
	*rsfpp = PerlProc_popen((char *)SvPVX_const(cmd), (char *)"r");
d3689 2
a3690 2
	forbid_setid(0, *suidscript);
	*rsfpp = PerlIO_stdin();
d3693 1
a3693 41
#ifdef FAKE_BIT_BUCKET
	/* This hack allows one not to have /dev/null (or BIT_BUCKET as it
	 * is called) and still have the "-e" work.  (Believe it or not,
	 * a /dev/null is required for the "-e" to work because source
	 * filter magic is used to implement it. ) This is *not* a general
	 * replacement for a /dev/null.  What we do here is create a temp
	 * file (an empty file), open up that as the script, and then
	 * immediately close and unlink it.  Close enough for jazz. */ 
#define FAKE_BIT_BUCKET_PREFIX "/tmp/perlnull-"
#define FAKE_BIT_BUCKET_SUFFIX "XXXXXXXX"
#define FAKE_BIT_BUCKET_TEMPLATE FAKE_BIT_BUCKET_PREFIX FAKE_BIT_BUCKET_SUFFIX
	char tmpname[sizeof(FAKE_BIT_BUCKET_TEMPLATE)] = {
	    FAKE_BIT_BUCKET_TEMPLATE
	};
	const char * const err = "Failed to create a fake bit bucket";
	if (strEQ(scriptname, BIT_BUCKET)) {
#ifdef HAS_MKSTEMP /* Hopefully mkstemp() is safe here. */
	    int tmpfd = mkstemp(tmpname);
	    if (tmpfd > -1) {
		scriptname = tmpname;
		close(tmpfd);
	    } else
		Perl_croak(aTHX_ err);
#else
#  ifdef HAS_MKTEMP
	    scriptname = mktemp(tmpname);
	    if (!scriptname)
		Perl_croak(aTHX_ err);
#  endif
#endif
	}
#endif
	*rsfpp = PerlIO_open(scriptname,PERL_SCRIPT_MODE);
#ifdef FAKE_BIT_BUCKET
	if (memEQ(scriptname, FAKE_BIT_BUCKET_PREFIX,
		  sizeof(FAKE_BIT_BUCKET_PREFIX) - 1)
	    && strlen(scriptname) == sizeof(tmpname) - 1) {
	    unlink(scriptname);
	}
	scriptname = BIT_BUCKET;
#endif
d3695 1
a3695 1
	    if (*rsfpp)
d3697 1
a3697 1
	        fcntl(PerlIO_fileno(*rsfpp),F_SETFD,1);
d3701 1
a3701 1
    if (!*rsfpp) {
a3708 1
    return fdscript;
d3846 1
a3846 2
S_validate_suid(pTHX_ const char *validarg, const char *scriptname,
		int fdscript, int suidscript, SV *linestr_sv, PerlIO *rsfp)
a3847 1
    dVAR;
d3882 1
a3882 1
    if (PerlLIO_fstat(PerlIO_fileno(rsfp),&PL_statbuf) < 0)	/* normal stat is insecure */
a3886 1
	const char *s_end;
d3888 2
a3889 2
#  ifdef IAMSUID
	if (fdscript < 0 || suidscript != 1)
d3899 1
a3899 1
#    ifdef HAS_SETREUID
d3903 2
a3904 2
#    endif
#    ifdef HAS_SETREUID
d3908 1
a3908 1
#    endif
d3969 2
a3970 2
#    if !defined(NO_NOSUID_CHECK)
	if (fd_on_nosuid_fs(PerlIO_fileno(rsfp))) {
d3973 2
a3974 2
#    endif
#  endif /* IAMSUID */
d3984 1
a3984 1
	if (sv_gets(linestr_sv, rsfp, 0) == NULL)
d3986 1
a3986 1
	linestr = SvPV_nolen_const(linestr_sv);
d3994 1
a3994 2
	s_end = s + strlen(s);
	if (s_end == s || (s_end - s) > 4000)
d4033 1
a4033 2
	    !((s_end - s) == len+1
	      || ((s_end - s) == len+2 && isSPACE(s[len+1]))))
d4036 2
a4037 2
#  ifndef IAMSUID
	if (fdscript < 0 &&
d4043 1
a4043 1
#  endif /* IAMSUID */
d4045 1
a4045 1
	if (fdscript < 0 &&
d4058 1
a4058 1
	     * fdscript to avoid loops), and do the execs
d4061 1
a4061 1
#  ifndef IAMSUID
d4070 2
a4071 2
	    PerlIO_rewind(rsfp);
	    PerlLIO_lseek(PerlIO_fileno(rsfp),(Off_t)0,0);  /* just in case rewind didn't */
d4088 4
a4091 4
					  PerlIO_fileno(rsfp), PL_origargv[which]));
#    if defined(HAS_FCNTL) && defined(F_SETFD)
	    fcntl(PerlIO_fileno(rsfp),F_SETFD,0);	/* ensure no close-on-exec */
#    endif
d4097 1
a4097 1
#  endif /* IAMSUID */
d4108 1
a4108 1
#  ifdef HAS_SETEGID
d4110 2
a4111 2
#  else
#    ifdef HAS_SETREGID
d4113 2
a4114 2
#    else
#      ifdef HAS_SETRESGID
d4116 1
a4116 1
#      else
d4118 3
a4120 3
#      endif
#    endif
#  endif
d4126 1
a4126 1
#  ifdef HAS_SETEUID
d4128 2
a4129 2
#  else
#    ifdef HAS_SETREUID
d4131 2
a4132 2
#    else
#      ifdef HAS_SETRESUID
d4134 1
a4134 1
#      else
d4136 3
a4138 3
#      endif
#    endif
#  endif
d4143 1
a4143 1
#  ifdef HAS_SETEUID
d4145 2
a4146 2
#  else
#    ifdef HAS_SETREUID
d4148 2
a4149 2
#    else
#      ifdef HAS_SETRESUID
d4151 1
a4151 1
#      else
d4153 3
a4155 3
#      endif
#    endif
#  endif
d4163 1
a4163 1
#  ifdef IAMSUID
d4166 1
a4166 1
    else if (fdscript < 0 || suidscript != 1)
d4207 2
a4208 2
    PerlIO_rewind(rsfp);
    PerlLIO_lseek(PerlIO_fileno(rsfp),(Off_t)0,0);  /* just in case rewind didn't */
d4218 4
a4221 4
/*				  PerlIO_fileno(rsfp), PL_origargv[which]));	*/
#  if defined(HAS_FCNTL) && defined(F_SETFD)
    fcntl(PerlIO_fileno(rsfp),F_SETFD,0);	/* ensure no close-on-exec */
#  endif
d4228 1
a4228 1
#  endif /* IAMSUID */
a4229 2
    PERL_UNUSED_ARG(fdscript);
    PERL_UNUSED_ARG(suidscript);
d4231 2
a4232 4
#  ifdef SETUID_SCRIPTS_ARE_SECURE_NOW
    PERL_UNUSED_ARG(rsfp);
#  else
	PerlLIO_fstat(PerlIO_fileno(rsfp),&PL_statbuf);	/* may be either wrapped or real suid */
d4240 1
a4240 1
#  endif /* SETUID_SCRIPTS_ARE_SECURE_NOW */
d4244 2
a4245 3
    PERL_UNUSED_ARG(validarg);
    PERL_UNUSED_ARG(scriptname);
    PERL_UNUSED_ARG(linestr_sv);
d4249 1
a4249 1
S_find_beginning(pTHX_ SV* linestr_sv, PerlIO *rsfp)
d4251 1
a4251 2
    dVAR;
    const char *s;
d4259 1
d4264 1
a4264 1
	if ((s = sv_gets(linestr_sv, rsfp, 0)) == NULL) {
d4275 1
a4275 1
	    PerlIO_rewind(rsfp);
d4281 1
a4281 1
	if ((s = sv_gets(linestr_sv, rsfp, 0)) == NULL)
d4286 1
a4286 1
	    PerlIO_ungetc(rsfp, '\n');		/* to keep line count right */
d4304 1
a4304 1
		PerlIO_ungetc(rsfp, '\n');
a4319 1
    dVAR;
a4378 4
/* Passing the flag as a single char rather than a string is a slight space
   optimisation.  The only message that isn't /^-.$/ is
   "program input from stdin", which is substituted in place of '\0', which
   could never be a command line flag.  */
d4380 1
a4380 1
S_forbid_setid(pTHX_ const char flag, const int suidscript)
a4381 9
    dVAR;
    char string[3] = "-x";
    const char *message = "program input from stdin";

    if (flag) {
	string[1] = flag;
	message = string;
    }

d4384 1
a4384 1
        Perl_croak(aTHX_ "No %s allowed while running setuid", message);
d4386 1
a4386 1
        Perl_croak(aTHX_ "No %s allowed while running setgid", message);
d4410 2
a4411 2
    if (suidscript >= 0)
        Perl_croak(aTHX_ "No %s allowed with (suid) fdscript", message);
d4414 1
a4414 1
    Perl_croak(aTHX_ "No %s allowed in suidperl", message);
d4421 1
a4421 2
    dVAR;
    HV * const ostash = PL_curstash;
d4424 1
a4424 2
    PL_dbargs = GvAV(gv_AVadd((gv_fetchpvs("DB::args", GV_ADDMULTI,
					   SVt_PVAV))));
d4426 4
a4429 4
    PL_DBgv = gv_fetchpvs("DB::DB", GV_ADDMULTI, SVt_PVGV);
    PL_DBline = gv_fetchpvs("DB::dbline", GV_ADDMULTI, SVt_PVAV);
    PL_DBsub = gv_HVadd(gv_fetchpvs("DB::sub", GV_ADDMULTI, SVt_PVHV));
    PL_DBsingle = GvSV((gv_fetchpvs("DB::single", GV_ADDMULTI, SVt_PV)));
d4431 1
a4431 1
    PL_DBtrace = GvSV((gv_fetchpvs("DB::trace", GV_ADDMULTI, SVt_PV)));
d4433 1
a4433 1
    PL_DBsignal = GvSV((gv_fetchpvs("DB::signal", GV_ADDMULTI, SVt_PV)));
a4446 1
    dVAR;
d4476 4
a4486 1
    dVAR;
d4500 1
d4503 10
a4516 1
    dVAR;
d4521 1
a4521 1
    PL_stdingv = gv_fetchpvs("STDIN", GV_ADD|GV_NOTQUAL, SVt_PVIO);
d4526 1
a4526 1
    tmpgv = gv_fetchpvs("stdin", GV_ADD|GV_NOTQUAL, SVt_PV);
d4528 1
a4528 1
    GvIOp(tmpgv) = (IO*)SvREFCNT_inc_simple(io);
d4530 1
a4530 1
    tmpgv = gv_fetchpvs("STDOUT", GV_ADD|GV_NOTQUAL, SVt_PVIO);
d4536 1
a4536 1
    tmpgv = gv_fetchpvs("stdout", GV_ADD|GV_NOTQUAL, SVt_PV);
d4538 1
a4538 1
    GvIOp(tmpgv) = (IO*)SvREFCNT_inc_simple(io);
d4540 1
a4540 1
    PL_stderrgv = gv_fetchpvs("STDERR", GV_ADD|GV_NOTQUAL, SVt_PVIO);
d4545 1
a4545 1
    tmpgv = gv_fetchpvs("stderr", GV_ADD|GV_NOTQUAL, SVt_PV);
d4547 1
a4547 1
    GvIOp(tmpgv) = (IO*)SvREFCNT_inc_simple(io);
d4549 1
a4549 1
    PL_statname = newSV(0);		/* last filename we did stat on */
a4557 1
    dVAR;
d4569 2
a4570 3
		const char *const start_name = argv[0] + 1;
		sv_setpv(GvSV(gv_fetchpvn_flags(start_name, s - start_name,
						TRUE, SVt_PV)), s + 1);
d4573 1
a4573 1
		sv_setiv(GvSV(gv_fetchpv(argv[0]+1, GV_ADD, SVt_PV)),1);
d4576 1
a4576 1
    if ((PL_argvgv = gv_fetchpvs("ARGV", GV_ADD|GV_NOTQUAL, SVt_PVAV))) {
d4593 51
a4646 1
    dVAR;
d4649 2
a4650 1
    PL_toptarget = newSV_type(SVt_PVFM);
d4652 2
a4653 1
    PL_bodytarget = newSV_type(SVt_PVFM);
d4661 1
a4661 1
    if ((tmpgv = gv_fetchpvs("0", GV_ADD|GV_NOTQUAL, SVt_PV))) {
d4670 2
a4671 1
    if ((PL_envgv = gv_fetchpvs("ENV", GV_ADD|GV_NOTQUAL, SVt_PVHV))) {
a4672 1
	bool env_is_not_environ;
d4675 1
a4675 1
	hv_magic(hv, NULL, PERL_MAGIC_env);
d4685 1
a4685 2
	env_is_not_environ = env != environ;
	if (env_is_not_environ
d4691 1
a4691 1
	    environ[0] = NULL;
d4694 1
d4707 1
a4707 1
	    if (env_is_not_environ)
d4709 5
d4720 1
a4720 1
    if ((tmpgv = gv_fetchpvs("$", GV_ADD|GV_NOTQUAL, SVt_PV))) {
d4733 3
a4740 1
    dVAR;
d4755 1
a4755 1
	    incpush(s, TRUE, TRUE, TRUE, FALSE);
d4757 1
a4757 1
	    incpush(PerlEnv_getenv("PERLLIB"), FALSE, FALSE, TRUE, FALSE);
d4766 1
a4766 1
	    do { incpush(buf,TRUE,TRUE,TRUE,FALSE); } while (my_trnlnm("PERL5LIB",buf,++idx));
d4768 1
a4768 1
	    while (my_trnlnm("PERLLIB",buf,idx++)) incpush(buf,FALSE,FALSE,TRUE,FALSE);
d4776 1
a4776 1
    incpush(APPLLIB_EXP, TRUE, TRUE, TRUE, TRUE);
d4780 1
a4780 1
    incpush(ARCHLIB_EXP, FALSE, FALSE, TRUE, TRUE);
d4785 1
a4785 1
    	SV * privdir = newSV(0);
d4793 1
a4793 1
	    incpush(SvPVX(privdir), TRUE, FALSE, TRUE, FALSE);
d4796 1
a4796 1
	    incpush(SvPVX(privdir), TRUE, FALSE, TRUE, FALSE);
d4801 1
a4801 1
	incpush(":", FALSE, FALSE, TRUE, FALSE);
d4807 1
a4807 1
    incpush(PRIVLIB_EXP, TRUE, FALSE, TRUE, TRUE);
d4809 1
a4809 1
    incpush(PRIVLIB_EXP, FALSE, FALSE, TRUE, TRUE);
d4816 1
a4816 1
    incpush(SITEARCH_EXP, FALSE, FALSE, TRUE, TRUE);
d4823 1
a4823 1
    incpush(SITELIB_EXP, TRUE, FALSE, TRUE, TRUE);
d4825 1
a4825 1
    incpush(SITELIB_EXP, FALSE, FALSE, TRUE, TRUE);
d4829 2
a4830 3
#if defined(SITELIB_STEM) && defined(PERL_INC_VERSION_LIST)
    /* Search for version-specific dirs below here */
    incpush(SITELIB_STEM, FALSE, TRUE, TRUE, TRUE);
d4837 1
a4837 1
    incpush(PERL_VENDORARCH_EXP, FALSE, FALSE, TRUE, TRUE);
d4843 1
a4843 1
    incpush(PERL_VENDORLIB_EXP, TRUE, FALSE, TRUE, TRUE);	/* this picks up vendorarch as well */
d4845 1
a4845 1
    incpush(PERL_VENDORLIB_EXP, FALSE, FALSE, TRUE, TRUE);
d4850 1
a4850 1
    incpush(PERL_VENDORLIB_STEM, FALSE, TRUE, TRUE, TRUE);
d4854 1
a4854 1
    incpush(PERL_OTHERLIBDIRS, TRUE, TRUE, TRUE, TRUE);
d4858 1
a4858 1
	incpush(".", FALSE, FALSE, TRUE, FALSE);
d4862 1
a4862 1
#if defined(DOSISH) || defined(EPOC) || defined(__SYMBIAN32__)
a4884 1
    dVAR;
d4889 1
a4889 1
	dir = newSV(0);
d4895 1
a4895 2
S_incpush(pTHX_ const char *dir, bool addsubdirs, bool addoldvers, bool usesep,
	  bool canrelocate)
d4897 1
a4897 2
    dVAR;
    SV *subdir = NULL;
d4904 1
a4904 1
	subdir = newSV(0);
d4909 1
a4909 1
	SV *libdir = newSV(0);
d4916 1
a4916 1
		/* av_push(GvAVn(PL_incgv), newSVpvs(".")); */
d4921 1
a4921 1
	if ( usesep && (s = strchr(p, PERLLIB_SEP)) != NULL ) {
d4928 1
a4928 1
	    p = NULL;	/* break out */
d4937 1
a4937 1
	    sv_catpvs(libdir, ":");
a4939 98
	/* Do the if() outside the #ifdef to avoid warnings about an unused
	   parameter.  */
	if (canrelocate) {
#ifdef PERL_RELOCATABLE_INC
	/*
	 * Relocatable include entries are marked with a leading .../
	 *
	 * The algorithm is
	 * 0: Remove that leading ".../"
	 * 1: Remove trailing executable name (anything after the last '/')
	 *    from the perl path to give a perl prefix
	 * Then
	 * While the @@INC element starts "../" and the prefix ends with a real
	 * directory (ie not . or ..) chop that real directory off the prefix
	 * and the leading "../" from the @@INC element. ie a logical "../"
	 * cleanup
	 * Finally concatenate the prefix and the remainder of the @@INC element
	 * The intent is that /usr/local/bin/perl and .../../lib/perl5
	 * generates /usr/local/lib/perl5
	 */
	    const char *libpath = SvPVX(libdir);
	    STRLEN libpath_len = SvCUR(libdir);
	    if (libpath_len >= 4 && memEQ (libpath, ".../", 4)) {
		/* Game on!  */
		SV * const caret_X = get_sv("\030", 0);
		/* Going to use the SV just as a scratch buffer holding a C
		   string:  */
		SV *prefix_sv;
		char *prefix;
		char *lastslash;

		/* $^X is *the* source of taint if tainting is on, hence
		   SvPOK() won't be true.  */
		assert(caret_X);
		assert(SvPOKp(caret_X));
		prefix_sv = newSVpvn(SvPVX(caret_X), SvCUR(caret_X));
		/* Firstly take off the leading .../
		   If all else fail we'll do the paths relative to the current
		   directory.  */
		sv_chop(libdir, libpath + 4);
		/* Don't use SvPV as we're intentionally bypassing taining,
		   mortal copies that the mg_get of tainting creates, and
		   corruption that seems to come via the save stack.
		   I guess that the save stack isn't correctly set up yet.  */
		libpath = SvPVX(libdir);
		libpath_len = SvCUR(libdir);

		/* This would work more efficiently with memrchr, but as it's
		   only a GNU extension we'd need to probe for it and
		   implement our own. Not hard, but maybe not worth it?  */

		prefix = SvPVX(prefix_sv);
		lastslash = strrchr(prefix, '/');

		/* First time in with the *lastslash = '\0' we just wipe off
		   the trailing /perl from (say) /usr/foo/bin/perl
		*/
		if (lastslash) {
		    SV *tempsv;
		    while ((*lastslash = '\0'), /* Do that, come what may.  */
			   (libpath_len >= 3 && memEQ(libpath, "../", 3)
			    && (lastslash = strrchr(prefix, '/')))) {
			if (lastslash[1] == '\0'
			    || (lastslash[1] == '.'
				&& (lastslash[2] == '/' /* ends "/."  */
				    || (lastslash[2] == '/'
					&& lastslash[3] == '/' /* or "/.."  */
					)))) {
			    /* Prefix ends "/" or "/." or "/..", any of which
			       are fishy, so don't do any more logical cleanup.
			    */
			    break;
			}
			/* Remove leading "../" from path  */
			libpath += 3;
			libpath_len -= 3;
			/* Next iteration round the loop removes the last
			   directory name from prefix by writing a '\0' in
			   the while clause.  */
		    }
		    /* prefix has been terminated with a '\0' to the correct
		       length. libpath points somewhere into the libdir SV.
		       We need to join the 2 with '/' and drop the result into
		       libdir.  */
		    tempsv = Perl_newSVpvf(aTHX_ "%s/%s", prefix, libpath);
		    SvREFCNT_dec(libdir);
		    /* And this is the new libdir.  */
		    libdir = tempsv;
		    if (PL_tainting &&
			(PL_uid != PL_euid || PL_gid != PL_egid)) {
			/* Need to taint reloccated paths if running set ID  */
			SvTAINTED_on(libdir);
		    }
		}
		SvREFCNT_dec(prefix_sv);
	    }
#endif
	}
d4947 2
a4948 2
	    const char * const incverlist[] = { PERL_INC_VERSION_LIST };
	    const char * const *incver;
d4954 1
a4954 1
	    if ((unix = tounixspec_ts(SvPV(libdir,len),NULL)) != NULL) {
d4976 1
a4976 1
			       SVfARG(libdir),
d4982 1
a4982 2
		Perl_sv_setpvf(aTHX_ subdir, "%"SVf PERL_ARCH_FMT_PATH,
			       SVfARG(libdir),
d4988 1
a4988 2
		Perl_sv_setpvf(aTHX_ subdir, "%"SVf PERL_ARCH_FMT,
			       SVfARG(libdir), ARCHNAME);
d4997 1
a4997 2
		    Perl_sv_setpvf(aTHX_ subdir, "%"SVf PERL_ARCH_FMT,
				   SVfARG(libdir), *incver);
d5013 79
a5095 1
    dVAR;
d5097 1
a5097 1
    volatile const line_t oldline = PL_curcop ? CopLINE(PL_curcop) : 0;
d5108 3
a5110 1
		Perl_av_create_and_push(aTHX_ &PL_beginav_save, (SV*)cv);
d5114 3
a5116 5
		Perl_av_create_and_push(aTHX_ &PL_checkav_save, (SV*)cv);
	    }
	    else if (paramList == PL_unitcheckav) {
		/* save PL_unitcheckav for compiler */
		Perl_av_create_and_push(aTHX_ &PL_unitcheckav_save, (SV*)cv);
d5119 1
a5119 2
	    if (!PL_madskills)
		SAVEFREESV(cv);
d5121 3
d5125 1
d5128 2
a5129 8
#ifdef PERL_MAD
	    if (PL_madskills)
		PL_madskills |= 16384;
#endif
	    CALL_LIST_BODY(cv);
#ifdef PERL_MAD
	    if (PL_madskills)
		PL_madskills &= ~16384;
d5137 1
a5137 1
		    sv_catpvs(atsv, "BEGIN failed--compilation aborted");
a5142 1
				   : paramList == PL_unitcheckav ? "UNITCHECK"
d5147 1
a5147 1
		Perl_croak(aTHX_ "%"SVf"", SVfARG(atsv));
a5168 1
			       : paramList == PL_unitcheckav ? "UNITCHECK"
d5187 17
a5206 1
    dVAR;
d5208 1
a5208 1
			  (void*)thr, (unsigned long) status));
d5217 1
a5217 1
	STATUS_EXIT_SET(status);
a5225 1
    dVAR;
d5227 3
a5229 25
     /* We have been called to fall on our sword.  The desired exit code
      * should be already set in STATUS_UNIX, but could be shifted over
      * by 8 bits.  STATUS_UNIX_EXIT_SET will handle the cases where a
      * that code is set.
      *
      * If an error code has not been set, then force the issue.
      */
    if (MY_POSIX_EXIT) {

	/* In POSIX_EXIT mode follow Perl documentations and use 255 for
	 * the exit code when there isn't an error.
	 */

	if (STATUS_UNIX == 0)
	    STATUS_UNIX_EXIT_SET(255);
	else {
	    STATUS_UNIX_EXIT_SET(STATUS_UNIX);

	    /* The exit code could have been set by $? or vmsish which
	     * means that it may not be fatal.  So convert
	     * success/warning codes to fatal.
	     */
	    if ((STATUS_NATIVE & (STS$K_SEVERE|STS$K_ERROR)) == 0)
		STATUS_UNIX_EXIT_SET(255);
	}
d5232 4
a5235 25
	/* Traditionally Perl on VMS always expects a Fatal Error. */
	if (vaxc$errno & 1) {

	    /* So force success status to failure */
	    if (STATUS_NATIVE & 1)
		STATUS_ALL_FAILURE;
	}
	else {
	    if (!vaxc$errno) {
		STATUS_UNIX = EINTR; /* In case something cares */
		STATUS_ALL_FAILURE;
	    }
	    else {
		int severity;
		STATUS_NATIVE = vaxc$errno; /* Should already be this */

		/* Encode the severity code */
		severity = STATUS_NATIVE & STS$M_SEVERITY;
		STATUS_UNIX = (severity ? severity : 1) << 8;

		/* Perl expects this to be a fatal error */
		if (severity != STS$K_SEVERE)
		    STATUS_ALL_FAILURE;
	    }
	}
a5236 1

d5240 1
a5240 1
	STATUS_UNIX_SET(errno);
d5242 1
a5242 1
	exitstatus = STATUS_UNIX >> 8;
d5244 1
a5244 1
	    STATUS_UNIX_SET(exitstatus);
d5246 1
a5246 1
	    STATUS_UNIX_SET(255);
d5255 3
a5257 1
    dVAR;
d5261 1
a5261 1
	PL_e_script = NULL;
d5265 6
a5270 2
    dounwind(-1);
    LEAVE_SCOPE(0);
d5273 2
a5279 1
    dVAR;
d5292 1
a5292 1
    sv_chop(PL_e_script, nl);
@


1.1.1.12
log
@import perl 5.10.1
@
text
@d3 2
a4 2
 *    Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
 *    2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 by Larry Wall and others
d12 1
a12 5
 *      A ship then new they built for him
 *      of mithril and of elven-glass
 *              --from Bilbo's song of Eärendil
 *
 *     [p.236 of _The Lord of the Rings_, II/i: "Many Meetings"]
d128 7
d136 2
a137 15
#  ifdef IAMSUID
/* Drop scriptname */
#    define validate_suid(validarg, scriptname, fdscript, suidscript, linestr_sv, rsfp) S_validate_suid(aTHX_ validarg, fdscript, suidscript, linestr_sv, rsfp)
#  else
/* Drop suidscript */
#    define validate_suid(validarg, scriptname, fdscript, suidscript, linestr_sv, rsfp) S_validate_suid(aTHX_ validarg, scriptname, fdscript, linestr_sv, rsfp)
#  endif
#else
#  ifdef SETUID_SCRIPTS_ARE_SECURE_NOW
/* Drop everything. Heck, don't even try to call it */
#    define validate_suid(validarg, scriptname, fdscript, suidscript, linestr_sv, rsfp) NOOP
#  else
/* Drop almost everything */
#    define validate_suid(validarg, scriptname, fdscript, suidscript, linestr_sv, rsfp) S_validate_suid(aTHX_ rsfp)
#  endif
d142 1
a142 1
	PL_op = PL_ppaddr[OP_ENTEREVAL](aTHX); \
d148 1
a148 1
	PL_op = PL_ppaddr[OP_ENTERSUB](aTHX); \
d154 1
a154 1
    call_sv(MUTABLE_SV((cv)), G_EVAL|G_DISCARD);
a190 3

    PERL_ARGS_ASSERT_SYS_INIT;

a199 3

    PERL_ARGS_ASSERT_SYS_INIT3;

a224 3

    PERL_ARGS_ASSERT_PERL_ALLOC_USING;

d285 1
a285 3

    PERL_ARGS_ASSERT_PERL_CONSTRUCT;

a289 1
    PERL_UNUSED_ARG(my_perl);
d303 2
a304 3
       of caching the numeric forms. However, as &PL_sv_no doesn't contain
       a string that is a valid numer, we have to turn the public flags by
       hand:  */
a305 3
    SvIV(&PL_sv_no);
    SvIOK_on(&PL_sv_no);
    SvNOK_on(&PL_sv_no);
d310 1
a311 1
    SvIV(&PL_sv_yes);
d348 3
a350 3
    sv_setpvs(PERL_DEBUG_PAD(0), "");	/* For regex debugging. */
    sv_setpvs(PERL_DEBUG_PAD(1), "");	/* ext/re needs these */
    sv_setpvs(PERL_DEBUG_PAD(2), "");	/* even without DEBUGGING. */
d392 2
a393 1
    PL_patchlevel = newSVpvs("v" PERL_VERSION_STRING);
a436 4
    PL_registered_mros = newHV();
    /* Start with 1 bucket, for DFS.  It's unlikely we'll need more.  */
    HvMAX(PL_registered_mros) = 0;

a469 2
    PERL_ARGS_ASSERT_DUMP_SV_CHILD;

a571 2
    PERL_ARGS_ASSERT_PERL_DESTRUCT;
#ifndef MULTIPLICITY
a572 1
#endif
d637 1
a637 1
	    static const char success[sizeof(int) + 1] = {0};
a819 2
    SvREFCNT_dec(PL_registered_mros);

d878 7
a884 1
	    if(SvREPADTMP(resv)) {
d898 1
a898 1
    SvREFCNT_dec(MUTABLE_SV(PL_stashcache));
d1125 2
d1129 1
a1129 1
    while (sv_clean_all() > 2)
d1132 5
d1218 1
a1218 1
	for (sva = PL_sv_arenaroot; sva; sva = MUTABLE_SV(SvANY(sva))) {
d1226 1
a1226 2
			(void*)sv, (UV)sv->sv_flags, (UV)sv->sv_refcnt
			pTHX__VALUE,
a1259 4
#ifdef DEBUG_LEAKING_SCALARS_ABORT
    if (PL_sv_count)
	abort();
#endif
a1355 2
    PERL_ARGS_ASSERT_PERL_FREE;

a1366 1
	    const U32 old_debug = PL_debug;
a1368 5
	    if (DEBUG_m_TEST) {
		PerlIO_puts(Perl_debug_log, "Disabling memory debugging as we "
			    "free this thread's memory\n");
		PL_debug &= ~ DEBUG_m_FLAG;
	    }
a1370 1
	    PL_debug = old_debug;
a1499 2
    PERL_ARGS_ASSERT_PERL_PARSE;
#ifndef MULTIPLICITY
a1500 1
#endif
d1502 6
a1507 3
#ifdef SETUID_SCRIPTS_ARE_SECURE_NOW_AND_IAMSUID
    Perl_croak(aTHX_ "suidperl is no longer needed since the kernel can now "
	       "execute\nsetuid perl scripts securely.\n");
a1689 1
#ifdef DOSUID
a1690 1
#endif
d1701 1
a1701 1
    sv_setpvs(linestr_sv,"");
d1780 1
a1780 1
	    forbid_setid('e', FALSE);
d1804 1
a1804 1
	    forbid_setid('I', FALSE);
d1821 1
a1821 1
	    forbid_setid('P', FALSE);
d1827 1
a1827 1
	    forbid_setid('S', FALSE);
a1866 3
#  ifdef PERL_USE_DEVEL
			     " PERL_USE_DEVEL"
#  endif
a1872 3
#  ifdef USE_FAST_STDIO
			     " USE_FAST_STDIO"
#  endif	       
d1883 1
d1894 1
a1894 1
				    0, PL_localpatches[i], 0);
d1902 3
a1904 2
		    sv_catpvs(opts_prog,
			      "  Compiled at " __DATE__ " " __TIME__ "\\n\"");
d1906 2
a1907 1
		    sv_catpvs(opts_prog, "  Compiled on " __DATE__ "\\n\"");
d1974 1
d1985 1
a1985 1
	        const char *d;
d2001 3
a2003 3
			    popt_copy = SvPVX(sv_2mortal(newSVpv(d,0)));
			    s = popt_copy + (s - d);
			    d = popt_copy;
d2051 3
a2053 6
	bool suidscript = FALSE;

#ifdef DOSUID
	const int fdscript =
#endif
	    open_script(scriptname, dosearch, sv, &suidscript, &rsfp);
d2081 1
a2081 1
	    /* This will croak if suidscript is true, as -x cannot be used with
d2084 1
a2084 1
	    /* Hence you can't get here if suidscript is true */
d2092 1
a2092 1
    PL_main_cv = PL_compcv = MUTABLE_CV(newSV_type(SVt_PVCV));
d2162 1
a2162 1
			     sv_setpvs(sv, ":utf8\0:utf8");
d2164 1
a2164 1
			     sv_setpvs(sv, ":utf8\0");
d2167 1
a2167 1
			sv_setpvs(sv, "\0:utf8");
a2287 2
    PERL_ARGS_ASSERT_PERL_RUN;
#ifndef MULTIPLICITY
a2288 1
#endif
d2395 3
a2397 4
Returns the SV of the specified Perl scalar.  C<flags> are passed to
C<gv_fetchpv>. If C<GV_ADD> is set and the
Perl variable does not exist then it will be created.  If C<flags> is zero
and the variable does not exist then NULL is returned.
d2403 1
a2403 1
Perl_get_sv(pTHX_ const char *name, I32 flags)
d2406 1
a2406 4

    PERL_ARGS_ASSERT_GET_SV;

    gv = gv_fetchpv(name, flags, SVt_PV);
d2417 3
a2419 4
Returns the AV of the specified Perl array.  C<flags> are passed to
C<gv_fetchpv>. If C<GV_ADD> is set and the
Perl variable does not exist then it will be created.  If C<flags> is zero
and the variable does not exist then NULL is returned.
d2425 1
a2425 1
Perl_get_av(pTHX_ const char *name, I32 flags)
d2427 2
a2428 5
    GV* const gv = gv_fetchpv(name, flags, SVt_PVAV);

    PERL_ARGS_ASSERT_GET_AV;

    if (flags)
d2440 3
a2442 4
Returns the HV of the specified Perl hash.  C<flags> are passed to
C<gv_fetchpv>. If C<GV_ADD> is set and the
Perl variable does not exist then it will be created.  If C<flags> is zero
and the variable does not exist then NULL is returned.
d2448 1
a2448 1
Perl_get_hv(pTHX_ const char *name, I32 flags)
d2450 2
a2451 5
    GV* const gv = gv_fetchpv(name, flags, SVt_PVHV);

    PERL_ARGS_ASSERT_GET_HV;

    if (flags)
a2482 3

    PERL_ARGS_ASSERT_GET_CVN_FLAGS;

d2484 2
a2485 1
	SV *const sv = newSVpvn_flags(name, len, flags & SVf_UTF8);
a2497 2
    PERL_ARGS_ASSERT_GET_CV;

a2522 2
    PERL_ARGS_ASSERT_CALL_ARGV;

d2526 1
a2526 1
	    mXPUSHs(newSVpv(*argv,0));
d2547 1
a2547 3
    PERL_ARGS_ASSERT_CALL_PV;

    return call_sv(MUTABLE_SV(get_cv(sub_name, GV_ADD)), flags);
a2563 2
    PERL_ARGS_ASSERT_CALL_METHOD;

d2578 1
a2578 1
Perl_call_sv(pTHX_ SV *sv, VOL I32 flags)
a2591 2
    PERL_ARGS_ASSERT_CALL_SV;

d2601 3
a2603 1
    myop.op_flags |= OP_GIMME_REVERSE(flags);
d2617 1
a2617 1
	  && (SvTYPE(sv) != SVt_PVCV || CvSTASH((const CV *)sv) != PL_debstash)
a2624 1
	method_op.op_type = OP_METHOD;
a2625 1
	myop.op_type = OP_ENTERSUB;
d2648 2
a2649 3
	    if (!(flags & G_KEEPERR)) {
		CLEAR_ERRSV();
	    }
d2670 1
a2670 1
	    if ((flags & G_WANT) == G_ARRAY)
a2717 2
    PERL_ARGS_ASSERT_EVAL_SV;

d2733 3
a2735 1
    myop.op_flags |= OP_GIMME_REVERSE(flags);
d2749 2
a2750 3
	if (!(flags & G_KEEPERR)) {
	    CLEAR_ERRSV();
	}
d2771 1
a2771 1
	if ((flags & G_WANT) == G_ARRAY)
a2805 2
    PERL_ARGS_ASSERT_EVAL_PV;

d2814 1
a2814 1
	Perl_croak(aTHX_ "%s", SvPVx_nolen_const(ERRSV));
a2838 3

    PERL_ARGS_ASSERT_REQUIRE_PV;

a2851 2
    PERL_ARGS_ASSERT_MAGICNAME;

d2853 1
a2853 1
	sv_magic(GvSV(gv), MUTABLE_SV(gv), PERL_MAGIC_sv, name, namlen);
a2896 2
    PERL_ARGS_ASSERT_USAGE;

d2920 1
a2920 1
      "  m  Memory and SV allocation",
a2938 3

    PERL_ARGS_ASSERT_GET_DEBUG_OPTS;

a2975 3
    const char option = *s; /* used to remember option in -m/-M code */

    PERL_ARGS_ASSERT_MORESWITCHES;
d3017 1
a3017 1
	 sv_setsv(get_sv("/", GV_ADD), PL_rs);
d3041 1
a3041 1
	forbid_setid('d', FALSE);
d3079 1
a3079 1
	forbid_setid('D', FALSE);
d3115 1
a3115 1
	forbid_setid('I', FALSE);
d3164 1
a3164 1
	forbid_setid('M', FALSE);	/* XXX ? */
d3167 1
a3167 1
	forbid_setid('m', FALSE);	/* XXX ? */
a3172 1
	    bool colon = FALSE;
d3180 1
a3180 15
	    while(isALNUM(*s) || *s==':') {
		if( *s++ == ':' ) {
		    if( *s == ':' ) 
			s++;
		    else
			colon = TRUE;
		}
	    }
	    if (s == start)
		Perl_croak(aTHX_ "Module name required with -%c option",
				    option);
	    if (colon) 
		Perl_croak(aTHX_ "Invalid module name %.*s with -%c option: "
				    "contains single ':'",
				    (int)(s - start), start, option);
d3184 1
a3184 1
		if (option == 'm') {
d3190 3
d3204 1
a3204 1
	    Perl_croak(aTHX_ "Missing argument to -%c", option);
d3215 1
a3215 1
	forbid_setid('s', FALSE);
d3244 2
a3245 2
	{
	    SV* level= vstringify(PL_patchlevel);
d3247 5
a3251 21
#  ifdef PERL_GIT_UNCOMMITTED_CHANGES
	    SV *num = newSVpvs(PERL_PATCHNUM "*");
#  else
	    SV *num = newSVpvs(PERL_PATCHNUM);
#  endif

	    if (sv_len(num)>=sv_len(level) && strnEQ(SvPV_nolen(num),SvPV_nolen(level),sv_len(level))) {
		SvREFCNT_dec(level);
		level= num;
	    } else {
		Perl_sv_catpvf(aTHX_ level, " (%"SVf")", num);
		SvREFCNT_dec(num);
	    }
 #endif
	    PerlIO_printf(PerlIO_stdout(),
		"\nThis is perl, %"SVf
		" built for %s",
		level,
		ARCHNAME);
	    SvREFCNT_dec(level);
	}
d3264 1
d3275 1
a3275 1
		      "\n\nCopyright 1987-2009, Larry Wall\n");
d3373 2
a3374 4
        while( *s == ' ' )
          ++s;
	if (s[0] == '-')	/* Additional switches on #! line. */
	    return s+1;
d3487 1
a3487 1
    GvHV(gv) = MUTABLE_HV(SvREFCNT_inc_simple(PL_defstash));
d3507 1
a3507 1
    CLEAR_ERRSV();
d3514 1
a3514 1
    sv_setpvs(get_sv("/", GV_ADD), "\n");
d3519 1
a3519 1
	      bool *suidscript, PerlIO **rsfpp)
d3530 1
a3530 1
    PERL_ARGS_ASSERT_OPEN_SCRIPT;
d3554 1
a3554 1
		*suidscript = TRUE;
d3597 1
a3597 1
    if (!*suidscript) {
a3864 1
#ifdef DOSUID
d3866 2
a3867 9
S_validate_suid(pTHX_ const char *validarg,
#  ifndef IAMSUID
		const char *scriptname,
#  endif
		int fdscript,
#  ifdef IAMSUID
		bool suidscript,
#  endif
		SV *linestr_sv, PerlIO *rsfp)
d3870 3
a3872 3
    const char *s, *s2;

    PERL_ARGS_ASSERT_VALIDATE_SUID;
d3901 3
d3912 1
a3912 1
	if (fdscript < 0 || !suidscript)
d4118 3
a4120 1
	    PerlProc_execv(BIN_EXP "/sperl" PERL_FS_VERSION, PL_origargv);
d4191 1
a4191 1
    else if (fdscript < 0 || !suidscript)
d4237 7
d4248 3
a4250 1
    PerlProc_execv(BIN_EXP "/perl" PERL_FS_VERSION, PL_origargv);/* try again */
a4253 2
}

d4255 3
a4257 1

d4259 1
a4259 1
/* Don't even need this function.  */
a4260 8
STATIC void
S_validate_suid(pTHX_ PerlIO *rsfp)
{
    PERL_ARGS_ASSERT_VALIDATE_SUID;

    if (PL_euid != PL_uid || PL_egid != PL_gid) {	/* (suidperl doesn't exist, in fact) */
	dVAR;

d4269 1
d4272 4
a4276 2
#  endif /* SETUID_SCRIPTS_ARE_SECURE_NOW */
#endif /* DOSUID */
a4287 2
    PERL_ARGS_ASSERT_FIND_BEGINNING;

d4415 1
a4415 1
S_forbid_setid(pTHX_ const char flag, const bool suidscript) /* g */
d4454 1
a4454 1
    if (suidscript)
d4554 1
a4554 1
    sv_setpvs(get_sv("\"", GV_ADD), " ");
d4562 1
a4562 1
    GvIOp(tmpgv) = MUTABLE_IO(SvREFCNT_inc_simple(io));
d4572 1
a4572 1
    GvIOp(tmpgv) = MUTABLE_IO(SvREFCNT_inc_simple(io));
d4581 1
a4581 1
    GvIOp(tmpgv) = MUTABLE_IO(SvREFCNT_inc_simple(io));
a4592 3

    PERL_ARGS_ASSERT_INIT_ARGV_SYMBOLS;

a4634 2
    PERL_ARGS_ASSERT_INIT_POSTDUMP_SYMBOLS;

d4636 1
a4636 1
    sv_setpvs(PL_toptarget, "");
d4638 1
a4638 1
    sv_setpvs(PL_bodytarget, "");
d4679 1
a4679 1
	  char *s, *old_var;
d4682 1
a4682 3
	    old_var = *env;

	    if (!(s = strchr(old_var,'=')) || s == old_var)
a4683 1

d4686 1
a4686 1
	    (void)strupr(old_var);
d4690 1
a4690 1
	    (void)hv_store(hv, old_var, s - old_var, sv, 0);
d4710 1
a4710 1
      (void) get_av("main::F", GV_ADD | GV_ADDMULTI);
a4864 3

    PERL_ARGS_ASSERT_INCPUSH_IF_EXISTS;

d4956 1
a4956 2
		prefix_sv = newSVpvn_flags(SvPVX(caret_X), SvCUR(caret_X),
					   SvUTF8(caret_X));
d5045 3
a5047 3
#define PERL_ARCH_FMT_PREFIX	""
#define PERL_ARCH_FMT_SUFFIX	":"
#define PERL_ARCH_FMT_PATH	PERL_FS_VERSION ""
d5049 3
a5051 3
#define PERL_ARCH_FMT_PREFIX	"/"
#define PERL_ARCH_FMT_SUFFIX	""
#define PERL_ARCH_FMT_PATH	"/" PERL_FS_VERSION
d5054 4
a5057 3
		sv_setsv(subdir, libdir);
		sv_catpvs(subdir, PERL_ARCH_FMT_PATH \
			  PERL_ARCH_FMT_PREFIX ARCHNAME PERL_ARCH_FMT_SUFFIX);
d5061 4
a5064 2
		sv_setsv(subdir, libdir);
		sv_catpvs(subdir, PERL_ARCH_FMT_PATH);
d5068 2
a5069 3
		sv_setsv(subdir, libdir);
		sv_catpvs(subdir,
			  PERL_ARCH_FMT_PREFIX ARCHNAME PERL_ARCH_FMT_SUFFIX);
d5078 1
a5078 2
		    Perl_sv_setpvf(aTHX_ subdir, "%"SVf PERL_ARCH_FMT_PREFIX \
				   "%s" PERL_ARCH_FMT_SUFFIX,
a5106 2
    PERL_ARGS_ASSERT_CALL_LIST;

d5108 1
a5108 1
	cv = MUTABLE_CV(av_shift(paramList));
d5112 1
a5112 1
		Perl_av_create_and_push(aTHX_ &PL_beginav_save, MUTABLE_SV(cv));
d5116 1
a5116 1
		Perl_av_create_and_push(aTHX_ &PL_checkav_save, MUTABLE_SV(cv));
d5120 1
a5120 1
		Perl_av_create_and_push(aTHX_ &PL_unitcheckav_save, MUTABLE_SV(cv));
d5230 3
a5232 2
        /* According to the die_exit.t tests, if errno is non-zero */
        /* It should be used for the error status. */
d5234 4
a5237 3
	if (errno == EVMSERR) {
	    STATUS_NATIVE = vaxc$errno;
	} else {
d5239 5
a5243 5
            /* According to die_exit.t tests, if the child_exit code is */
            /* also zero, then we need to exit with a code of 255 */
            if ((errno != 0) && (errno < 256))
		STATUS_UNIX_EXIT_SET(errno);
            else if (STATUS_UNIX < 255) {
a5244 2
            }

a5245 12

	/* The exit code could have been set by $? or vmsish which
	 * means that it may not have fatal set.  So convert
	 * success/warning codes to fatal with out changing
	 * the POSIX status code.  The severity makes VMS native
	 * status handling work, while UNIX mode programs use the
	 * the POSIX exit codes.
	 */
	 if ((STATUS_NATIVE & (STS$K_SEVERE|STS$K_ERROR)) == 0) {
	    STATUS_NATIVE &= STS$M_COND_ID;
	    STATUS_NATIVE |= STS$K_ERROR | STS$M_INHIB_MSG;
         }
@


1.1.1.13
log
@Perl 5.12.2 from CPAN
@
text
@a0 1
#line 2 "perl.c"
d4 1
a4 2
 *    2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010 by Larry Wall
 *    and others
d25 59
a87 1
#include "XSUB.h"
d91 1
d132 10
a141 1
#ifdef SETUID_SCRIPTS_ARE_SECURE_NOW
d143 2
a144 2
#  define validate_suid(validarg, scriptname, fdscript, suidscript, linestr_sv, rsfp) NOOP
#else
d146 2
a147 1
#  define validate_suid(validarg, scriptname, fdscript, suidscript, linestr_sv, rsfp) S_validate_suid(aTHX_ rsfp)
d179 2
d378 2
a379 3
    /* First entry is a list of empty elements. It needs to be initialised
       else all hell breaks loose in S_find_uninit_var().  */
    Perl_av_create_and_push(aTHX_ &PL_regex_padav, newSVpvs(""));
a461 2
    PL_osname = Perl_savepvn(aTHX_ STR_WITH_LEN(OSNAME));

a607 2
    assert(PL_scopestack_ix == 1);

a634 1
    assert(PL_scopestack_ix == 0);
d907 16
d945 1
d970 2
a971 2
    SvREFCNT_dec(PL_ofsgv);	/* *, */
    PL_ofsgv = NULL;
d1074 1
d1094 1
d1137 1
a1137 1
    if (destruct_level >= 2) {
d1139 3
a1141 3
	    Perl_ck_warner_d(aTHX_ packWARN(WARN_INTERNAL),
			     "Unbalanced scopes: %ld more ENTERs than LEAVEs\n",
			     (long)PL_scopestack_ix);
d1143 3
a1145 3
	    Perl_ck_warner_d(aTHX_ packWARN(WARN_INTERNAL),
			     "Unbalanced saves: %ld more saves than restores\n",
			     (long)PL_savestack_ix);
d1147 2
a1148 2
	    Perl_ck_warner_d(aTHX_ packWARN(WARN_INTERNAL),"Unbalanced tmps: %ld more allocs than frees\n",
			     (long)PL_tmps_floor + 1);
d1150 2
a1151 2
	    Perl_ck_warner_d(aTHX_ packWARN(WARN_INTERNAL),"Unbalanced context: %ld more PUSHes than POPs\n",
			     (long)cxstack_ix + 1);
d1248 1
a1248 1
			"\tallocated at %s:%d %s %s%s; serial %"UVuf"\n",
d1256 1
a1256 2
			sv->sv_debug_cloned ? " (cloned)" : "",
			sv->sv_debug_serial
d1317 2
d1321 2
a1322 1
    PL_psig_ptr = (SV**)NULL;
a1324 7
    {
	/* We need to NULL PL_psig_pend first, so that
	   signal handlers know not to use it */
	int *psig_save = PL_psig_pend;
	PL_psig_pend = (int*)NULL;
	Safefree(psig_save);
    }
d1542 5
a1717 99
/* This needs to stay in perl.c, as perl.c is compiled with different flags for
   miniperl, and we need to see those flags reflected in the values here.  */

/* What this returns is subject to change.  Use the public interface in Config.
 */
static void
S_Internals_V(pTHX_ CV *cv)
{
    dXSARGS;
#ifdef LOCAL_PATCH_COUNT
    const int local_patch_count = LOCAL_PATCH_COUNT;
#else
    const int local_patch_count = 0;
#endif
    const int entries = 3 + local_patch_count;
    int i;
    static char non_bincompat_options[] = 
#  ifdef DEBUGGING
			     " DEBUGGING"
#  endif
#  ifdef NO_MATHOMS
			     " NO_MATHOMS"
#  endif
#  ifdef PERL_DISABLE_PMC
			     " PERL_DISABLE_PMC"
#  endif
#  ifdef PERL_DONT_CREATE_GVSV
			     " PERL_DONT_CREATE_GVSV"
#  endif
#  ifdef PERL_IS_MINIPERL
			     " PERL_IS_MINIPERL"
#  endif
#  ifdef PERL_MALLOC_WRAP
			     " PERL_MALLOC_WRAP"
#  endif
#  ifdef PERL_MEM_LOG
			     " PERL_MEM_LOG"
#  endif
#  ifdef PERL_MEM_LOG_NOIMPL
			     " PERL_MEM_LOG_NOIMPL"
#  endif
#  ifdef PERL_USE_DEVEL
			     " PERL_USE_DEVEL"
#  endif
#  ifdef PERL_USE_SAFE_PUTENV
			     " PERL_USE_SAFE_PUTENV"
#  endif
#  ifdef USE_ATTRIBUTES_FOR_PERLIO
			     " USE_ATTRIBUTES_FOR_PERLIO"
#  endif
#  ifdef USE_FAST_STDIO
			     " USE_FAST_STDIO"
#  endif	       
#  ifdef USE_PERL_ATOF
			     " USE_PERL_ATOF"
#  endif	       
#  ifdef USE_SITECUSTOMIZE
			     " USE_SITECUSTOMIZE"
#  endif	       
	;
    PERL_UNUSED_ARG(cv);
    PERL_UNUSED_ARG(items);

    EXTEND(SP, entries);

    PUSHs(sv_2mortal(newSVpv(PL_bincompat_options, 0)));
    PUSHs(Perl_newSVpvn_flags(aTHX_ non_bincompat_options,
			      sizeof(non_bincompat_options) - 1, SVs_TEMP));

#ifdef __DATE__
#  ifdef __TIME__
    PUSHs(Perl_newSVpvn_flags(aTHX_
			      STR_WITH_LEN("Compiled at " __DATE__ " " __TIME__),
			      SVs_TEMP));
#  else
    PUSHs(Perl_newSVpvn_flags(aTHX_ STR_WITH_LEN("Compiled on " __DATE__),
			      SVs_TEMP));
#  endif
#else
    PUSHs(&PL_sv_undef);
#endif

    for (i = 1; i <= local_patch_count; i++) {
	/* This will be an undef, if PL_localpatches[i] is NULL.  */
	PUSHs(sv_2mortal(newSVpv(PL_localpatches[i], 0)));
    }

    XSRETURN(entries);
}

#define INCPUSH_UNSHIFT			0x01
#define INCPUSH_ADD_OLD_VERS		0x02
#define INCPUSH_ADD_VERSIONED_SUB_DIRS	0x04
#define INCPUSH_ADD_ARCHONLY_SUB_DIRS	0x08
#define INCPUSH_NOT_BASEDIR		0x10
#define INCPUSH_CAN_RELOCATE		0x20
#define INCPUSH_ADD_SUB_DIRS	\
    (INCPUSH_ADD_VERSIONED_SUB_DIRS|INCPUSH_ADD_ARCHONLY_SUB_DIRS)

d1727 4
d1742 2
d1751 12
d1814 5
d1849 6
a1854 1
		incpush(s, len, INCPUSH_ADD_SUB_DIRS|INCPUSH_ADD_OLD_VERS);
d1859 6
d1874 1
d1876 86
a1961 1
		    opts_prog = newSVpvs("use Config; Config::_V()");
d1966 1
a1966 1
					      "use Config; Config::config_vars(qw%c%s%c)",
d1970 1
a1970 1
		Perl_av_create_and_push(aTHX_ &PL_preambleav, opts_prog);
d2037 1
a2037 1
		if (!strchr("CDIMUdmtwW", *s))
d2063 1
a2063 1
#if defined(USE_SITECUSTOMIZE) && !defined(PERL_IS_MINIPERL)
a2064 4
	/* SITELIB_EXP is a function call on Win32.
	   The games with local $! are to avoid setting errno if there is no
	   sitecustomize script.  */
	const char *const sitelib = SITELIB_EXP;
d2066 1
a2066 2
					     Perl_newSVpvf(aTHX_
							   "BEGIN { do {local $!; -f '%s/sitecustomize.pl'} && do '%s/sitecustomize.pl' }", sitelib, sitelib));
d2094 4
a2097 1
	open_script(scriptname, dosearch, &suidscript, &rsfp);
d2100 1
a2100 1
		      linestr_sv, rsfp);
d2110 3
a2112 2
		Perl_ck_warner(aTHX_ packWARN(WARN_SIGNAL),
			       "Can't ignore signal CHLD, forcing to default");
d2119 5
a2123 1
	if (PL_doextract) {
d2145 1
a2146 1
    newXS("Internals::V", S_Internals_V, __FILE__);
a2177 1
#  ifndef PERL_IS_MINIPERL
a2215 1
#endif
d2264 10
d2282 1
d2285 1
d2394 1
a2395 2
	if (DEBUG_x_TEST || DEBUG_B_TEST)
	    dump_all_perl(!DEBUG_B_TEST);
d2399 2
d2403 5
d2409 1
a2555 2
/* Nothing in core calls this now, but we can't replace it with a macro and
   move it to mathoms.c as a macro would evaluate name twice.  */
a2630 1
    STRLEN len;
d2633 1
a2633 4
    len = strlen(methname);

    /* XXX: sv_2mortal(newSVpvn_share(methname, len)) can be faster */
    return call_sv(newSVpvn_flags(methname, len, SVs_TEMP), flags | G_METHOD);
a2666 5
    if (!(flags & G_WANT)) {
	/* Backwards compatibility - as G_SCALAR was 0, it could be omitted.
	 */
	flags |= G_SCALAR;
    }
d2731 2
d2833 2
d2925 11
d2959 1
d3001 1
a3001 1
      "  P  Print profiling info, source file input state",
d3010 1
a3017 2
      "  M  trace smart match resolution",
      "  B  dump suBroutine definitions, including special Blocks like BEGIN",
d3026 1
a3026 1
	static const char debopts[] = "psltocPmfrxuUHXDSTRJvCAqMB";
d3217 3
a3219 2
	    incpush(s, e-s,
		    INCPUSH_ADD_SUB_DIRS|INCPUSH_ADD_OLD_VERS|INCPUSH_UNSHIFT);
d3330 3
d3362 4
a3365 5
		"\nThis is perl "	STRINGIFY(PERL_REVISION)
		", version "		STRINGIFY(PERL_VERSION)
		", subversion "		STRINGIFY(PERL_SUBVERSION)
		" (%"SVf") built for "	ARCHNAME, level
		);
d3390 6
a3395 1
		      "\n\nCopyright 1987-2010, Larry Wall\n");
d3438 4
d3505 4
d3635 1
a3635 1
S_open_script(pTHX_ const char *scriptname, bool dosearch,
d3638 6
d3701 83
d3836 1
d3855 247
d4103 267
a4369 1
#ifdef SETUID_SCRIPTS_ARE_SECURE_NOW
d4371 1
a4371 1
#else
d4391 2
a4392 1
#endif /* SETUID_SCRIPTS_ARE_SECURE_NOW */
d4400 3
d4408 20
d4431 1
d4446 14
d4550 22
d4574 4
a4577 16
}

void
Perl_init_dbargs(pTHX)
{
    AV *const args = PL_dbargs = GvAV(gv_AVadd((gv_fetchpvs("DB::args",
							    GV_ADDMULTI,
							    SVt_PVAV))));

    if (AvREAL(args)) {
	/* Someone has already created it.
	   It might have entries, and if we just turn off AvREAL(), they will
	   "leak" until global destruction.  */
	av_clear(args);
    }
    AvREAL_off(PL_dbargs);	/* XXX should be REIFY (see av.h) */
d4587 3
a4589 2

    Perl_init_dbargs(aTHX);
a4634 3
#ifdef DEBUGGING
    Newx(PL_scopestack_name,REASONABLE(32),const char*);
#endif
a4660 3
#ifdef DEBUGGING
    Safefree(PL_scopestack_name);
#endif
a4670 1
    AV *isa;
a4672 25
    PL_ofsgv = (GV*)SvREFCNT_inc(gv_fetchpvs(",", GV_ADD|GV_NOTQUAL, SVt_PV));


    /* Historically, PVIOs were blessed into IO::Handle, unless
       FileHandle was loaded, in which case they were blessed into
       that. Action at a distance.
       However, if we simply bless into IO::Handle, we break code
       that assumes that PVIOs will have (among others) a seek
       method. IO::File inherits from IO::Handle and IO::Seekable,
       and provides the needed methods. But if we simply bless into
       it, then we break code that assumed that by loading
       IO::Handle, *it* would work.
       So a compromise is to set up the correct @@IO::File::ISA,
       so that code that does C<use IO::Handle>; will still work.
    */
		   
    isa = get_av("IO::File::ISA", GV_ADD | GV_ADDMULTI);
    av_push(isa, newSVpvs("IO::Handle"));
    av_push(isa, newSVpvs("IO::Seekable"));
    av_push(isa, newSVpvs("Exporter"));
    (void) gv_fetchpvs("IO::Handle::", GV_ADD, SVt_PVGV);
    (void) gv_fetchpvs("IO::Seekable::", GV_ADD, SVt_PVGV);
    (void) gv_fetchpvs("Exporter::", GV_ADD, SVt_PVGV);


d4702 3
d4769 4
d4774 2
d4844 1
a4844 8
#ifndef VMS
    const char *perl5lib = NULL;
#endif
    const char *s;
#if defined(WIN32) && !defined(PERL_IS_MINIPERL)
    STRLEN len;
#endif

d4847 1
a4847 1
	perl5lib = PerlEnv_getenv("PERL5LIB");
d4854 1
a4854 1
	if (perl5lib && *perl5lib != '\0')
d4856 1
a4856 1
	if (perl5lib)
d4858 3
a4860 6
	    incpush_use_sep(perl5lib, 0, INCPUSH_ADD_SUB_DIRS);
	else {
	    s = PerlEnv_getenv("PERLLIB");
	    if (s)
		incpush_use_sep(s, 0, 0);
	}
d4869 3
a4871 7
	    do {
		incpush_use_sep(buf, 0, INCPUSH_ADD_SUB_DIRS);
	    } while (my_trnlnm("PERL5LIB",buf,++idx));
	else {
	    while (my_trnlnm("PERLLIB",buf,idx++))
		incpush_use_sep(buf, 0, 0);
	}
a4874 4
#ifndef PERL_IS_MINIPERL
    /* miniperl gets just -I..., the split of $ENV{PERL5LIB}, and "." in @@INC
       (and not the architecture specific directories from $ENV{PERL5LIB}) */

d4876 1
a4876 1
    SITEARCH, SITELIB, VENDORARCH, VENDORLIB, ARCHLIB and PRIVLIB
d4879 34
a4912 2
    S_incpush_use_sep(aTHX_ STR_WITH_LEN(APPLLIB_EXP),
		      INCPUSH_ADD_SUB_DIRS|INCPUSH_CAN_RELOCATE);
d4919 1
a4919 2
	S_incpush_use_sep(aTHX_ STR_WITH_LEN(SITEARCH_EXP),
			  INCPUSH_CAN_RELOCATE);
d4926 1
a4926 3
	s = win32_get_sitelib(PERL_FS_VERSION, &len);
	if (s)
	    incpush_use_sep(s, len, INCPUSH_ADD_SUB_DIRS|INCPUSH_CAN_RELOCATE);
d4928 1
a4928 1
	S_incpush_use_sep(aTHX_ STR_WITH_LEN(SITELIB_EXP), INCPUSH_CAN_RELOCATE);
d4932 5
d4941 1
a4941 2
    S_incpush_use_sep(aTHX_ STR_WITH_LEN(PERL_VENDORARCH_EXP),
		      INCPUSH_CAN_RELOCATE);
d4947 1
a4947 4
    /* this picks up vendorarch as well */
	s = win32_get_vendorlib(PERL_FS_VERSION, &len);
	if (s)
	    incpush_use_sep(s, len, INCPUSH_ADD_SUB_DIRS|INCPUSH_CAN_RELOCATE);
d4949 1
a4949 2
	S_incpush_use_sep(aTHX_ STR_WITH_LEN(PERL_VENDORLIB_EXP),
			  INCPUSH_CAN_RELOCATE);
d4953 2
a4954 18
#ifdef ARCHLIB_EXP
    S_incpush_use_sep(aTHX_ STR_WITH_LEN(ARCHLIB_EXP), INCPUSH_CAN_RELOCATE);
#endif

#ifndef PRIVLIB_EXP
#  define PRIVLIB_EXP "/usr/local/lib/perl5:/usr/local/lib/perl"
#endif

#if defined(WIN32)
    s = win32_get_privlib(PERL_FS_VERSION, &len);
    if (s)
	incpush_use_sep(s, len, INCPUSH_ADD_SUB_DIRS|INCPUSH_CAN_RELOCATE);
#else
#  ifdef NETWARE
    S_incpush_use_sep(aTHX_ PRIVLIB_EXP, 0, INCPUSH_CAN_RELOCATE);
#  else
    S_incpush_use_sep(aTHX_ STR_WITH_LEN(PRIVLIB_EXP), INCPUSH_CAN_RELOCATE);
#  endif
d4958 1
a4958 16
    S_incpush_use_sep(aTHX_ STR_WITH_LEN(PERL_OTHERLIBDIRS),
		      INCPUSH_ADD_VERSIONED_SUB_DIRS|INCPUSH_NOT_BASEDIR
		      |INCPUSH_CAN_RELOCATE);
#endif

    if (!PL_tainting) {
#ifndef VMS
/*
 * It isn't possible to delete an environment variable with
 * PERL_USE_SAFE_PUTENV set unless unsetenv() is also available, so in that
 * case we treat PERL5LIB as undefined if it has a zero-length value.
 */
#if defined(PERL_USE_SAFE_PUTENV) && ! defined(HAS_UNSETENV)
	if (perl5lib && *perl5lib != '\0')
#else
	if (perl5lib)
a4959 44
	    incpush_use_sep(perl5lib, 0,
			    INCPUSH_ADD_OLD_VERS|INCPUSH_NOT_BASEDIR);
#else /* VMS */
	/* Treat PERL5?LIB as a possible search list logical name -- the
	 * "natural" VMS idiom for a Unix path string.  We allow each
	 * element to be a set of |-separated directories for compatibility.
	 */
	char buf[256];
	int idx = 0;
	if (my_trnlnm("PERL5LIB",buf,0))
	    do {
		incpush_use_sep(buf, 0,
				INCPUSH_ADD_OLD_VERS|INCPUSH_NOT_BASEDIR);
	    } while (my_trnlnm("PERL5LIB",buf,++idx));
#endif /* VMS */
    }

/* Use the ~-expanded versions of APPLLIB (undocumented),
    SITELIB and VENDORLIB for older versions
*/
#ifdef APPLLIB_EXP
    S_incpush_use_sep(aTHX_ STR_WITH_LEN(APPLLIB_EXP), INCPUSH_ADD_OLD_VERS
		      |INCPUSH_NOT_BASEDIR|INCPUSH_CAN_RELOCATE);
#endif

#if defined(SITELIB_STEM) && defined(PERL_INC_VERSION_LIST)
    /* Search for version-specific dirs below here */
    S_incpush_use_sep(aTHX_ STR_WITH_LEN(SITELIB_STEM),
		      INCPUSH_ADD_OLD_VERS|INCPUSH_CAN_RELOCATE);
#endif


#if defined(PERL_VENDORLIB_STEM) && defined(PERL_INC_VERSION_LIST)
    /* Search for version-specific dirs below here */
    S_incpush_use_sep(aTHX_ STR_WITH_LEN(PERL_VENDORLIB_STEM),
		      INCPUSH_ADD_OLD_VERS|INCPUSH_CAN_RELOCATE);
#endif

#ifdef PERL_OTHERLIBDIRS
    S_incpush_use_sep(aTHX_ STR_WITH_LEN(PERL_OTHERLIBDIRS),
		      INCPUSH_ADD_OLD_VERS|INCPUSH_ADD_ARCHONLY_SUB_DIRS
		      |INCPUSH_CAN_RELOCATE);
#endif
#endif /* !PERL_IS_MINIPERL */
d4962 2
a4963 1
	S_incpush(aTHX_ STR_WITH_LEN("."), 0);
d4972 5
a4976 1
#    define PERLLIB_SEP ':'
d4987 1
a4987 1
S_incpush_if_exists(pTHX_ AV *const av, SV *dir, SV *const stem)
d4996 2
a4997 5
	av_push(av, dir);
	dir = newSVsv(stem);
    } else {
	/* Truncate dir back to stem.  */
	SvCUR_set(dir, SvCUR(stem));
d5003 2
a5004 1
S_incpush(pTHX_ const char *const dir, STRLEN len, U32 flags)
d5007 23
a5029 14
    const U8 using_sub_dirs
	= (U8)flags & (INCPUSH_ADD_VERSIONED_SUB_DIRS
		       |INCPUSH_ADD_ARCHONLY_SUB_DIRS|INCPUSH_ADD_OLD_VERS);
    const U8 add_versioned_sub_dirs
	= (U8)flags & INCPUSH_ADD_VERSIONED_SUB_DIRS;
    const U8 add_archonly_sub_dirs
	= (U8)flags & INCPUSH_ADD_ARCHONLY_SUB_DIRS;
#ifdef PERL_INC_VERSION_LIST
    const U8 addoldvers  = (U8)flags & INCPUSH_ADD_OLD_VERS;
#endif
    const U8 canrelocate = (U8)flags & INCPUSH_CAN_RELOCATE;
    const U8 unshift     = (U8)flags & INCPUSH_UNSHIFT;
    const U8 push_basedir = (flags & INCPUSH_NOT_BASEDIR) ? 0 : 1;
    AV *const inc = GvAVn(PL_incgv);
d5031 12
a5042 2
    PERL_ARGS_ASSERT_INCPUSH;
    assert(len > 0);
d5044 1
a5044 22
    /* Could remove this vestigial extra block, if we don't mind a lot of
       re-indenting diff noise.  */
    {
	SV *libdir;
	/* Change 20189146be79a0596543441fa369c6bf7f85103f, to fix RT#6665,
	   arranged to unshift #! line -I onto the front of @@INC. However,
	   -I can add version and architecture specific libraries, and they
	   need to go first. The old code assumed that it was always
	   pushing. Hence to make it work, need to push the architecture
	   (etc) libraries onto a temporary array, then "unshift" that onto
	   the front of @@INC.  */
	AV *const av = (using_sub_dirs) ? (unshift ? newAV() : inc) : NULL;

	if (len) {
	    /* I am not convinced that this is valid when PERLLIB_MANGLE is
	       defined to so something (in os2/os2.c), but the code has been
	       this way, ignoring any possible changed of length, since
	       760ac839baf413929cd31cc32ffd6dba6b781a81 (5.003_02) so I'll leave
	       it be.  */
	    libdir = newSVpvn(PERLLIB_MANGLE(dir, len), len);
	} else {
	    libdir = newSVpv(PERLLIB_MANGLE(dir, 0), 0);
d5046 3
d5153 1
a5153 2
	if (using_sub_dirs) {
	    SV *subdir;
a5162 1

d5173 15
d5189 4
a5192 1
	    subdir = newSVsv(libdir);
d5194 5
a5198 4
	    if (add_versioned_sub_dirs) {
		/* .../version/archname if -d .../version/archname */
		sv_catpvs(subdir, "/" PERL_FS_VERSION "/" ARCHNAME);
		subdir = S_incpush_if_exists(aTHX_ av, subdir, libdir);
a5199 3
		/* .../version if -d .../version */
		sv_catpvs(subdir, "/" PERL_FS_VERSION);
		subdir = S_incpush_if_exists(aTHX_ av, subdir, libdir);
d5206 4
a5209 2
		    Perl_sv_catpvf(aTHX_ subdir, "/%s", *incver);
		    subdir = S_incpush_if_exists(aTHX_ av, subdir, libdir);
a5212 10

	    if (add_archonly_sub_dirs) {
		/* .../archname if -d .../archname */
		sv_catpvs(subdir, "/" ARCHNAME);
		subdir = S_incpush_if_exists(aTHX_ av, subdir, libdir);

	    }

	    assert (SvREFCNT(subdir) == 1);
	    SvREFCNT_dec(subdir);
d5215 6
a5220 29
	/* finally add this lib directory at the end of @@INC */
	if (unshift) {
	    U32 extra = av_len(av) + 1;
	    av_unshift(inc, extra + push_basedir);
	    if (push_basedir)
		av_store(inc, extra, libdir);
	    while (extra--) {
		/* av owns a reference, av_store() expects to be donated a
		   reference, and av expects to be sane when it's cleared.
		   If I wanted to be naughty and wrong, I could peek inside the
		   implementation of av_clear(), realise that it uses
		   SvREFCNT_dec() too, so av's array could be a run of NULLs,
		   and so directly steal from it (with a memcpy() to inc, and
		   then memset() to NULL them out. But people copy code from the
		   core expecting it to be best practise, so let's use the API.
		   Although studious readers will note that I'm not checking any
		   return codes.  */
		av_store(inc, extra, SvREFCNT_inc(*av_fetch(av, extra, FALSE)));
	    }
	    SvREFCNT_dec(av);
	}
	else if (push_basedir) {
	    av_push(inc, libdir);
	}

	if (!push_basedir) {
	    assert (SvREFCNT(libdir) == 1);
	    SvREFCNT_dec(libdir);
	}
a5223 32
STATIC void
S_incpush_use_sep(pTHX_ const char *p, STRLEN len, U32 flags)
{
    const char *s;
    const char *end;
    /* This logic has been broken out from S_incpush(). It may be possible to
       simplify it.  */

    PERL_ARGS_ASSERT_INCPUSH_USE_SEP;

    if (!len)
	len = strlen(p);

    end = p + len;

    /* Break at all separators */
    while ((s = (const char*)memchr(p, PERLLIB_SEP, end - p))) {
	if (s == p) {
	    /* skip any consecutive separators */

	    /* Uncomment the next line for PATH semantics */
	    /* But you'll need to write tests */
	    /* av_push(GvAVn(PL_incgv), newSVpvs(".")); */
	} else {
	    incpush(p, (STRLEN)(s - p), flags);
	}
	p = s + 1;
    }
    if (p != end)
	incpush(p, (STRLEN)(end - p), flags);

}
d5301 10
d5331 2
@


1.1.1.14
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d5 2
a6 2
 *    2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012
 *     by Larry Wall and others
d16 1
a16 1
 *              --from Bilbo's song of EÃ¤rendil
a26 4
#if defined(PERL_IS_MINIPERL) && !defined(USE_SITECUSTOMIZE)
#  define USE_SITECUSTOMIZE
#endif

d37 3
a39 6
#ifdef USE_KERN_PROC_PATHNAME
#  include <sys/sysctl.h>
#endif

#ifdef USE_NSGETEXECUTABLEPATH
#  include <mach-o/dyld.h>
d43 3
d76 2
a77 1
#  define validate_suid(rsfp) NOOP
d79 2
a80 1
#  define validate_suid(rsfp) S_validate_suid(aTHX_ rsfp)
d83 6
d97 1
a97 1
    call_sv(MUTABLE_SV((cv)), G_EVAL|G_DISCARD|G_VOID);
a109 1
	OP_CHECK_MUTEX_INIT;
a350 1
    PL_apiversion = newSVpvs("v" PERL_API_VERSION_STRING);
d565 1
a565 2
        if (PL_endav && !PL_minus_c) {
	    PERL_SET_PHASE(PERL_PHASE_END);
a566 1
	}
d576 1
a576 1
    if (PL_threadhook(aTHX)) {
a752 4
    /* note that  PL_main_cv isn't usually actually freed at this point,
     * due to the CvOUTSIDE refs from subs compiled within it. It will
     * get freed once all the subs are freed in sv_clean_all(), for
     * destruct_level > 0 */
d755 1
a755 1
    PERL_SET_PHASE(PERL_PHASE_DESTRUCT);
d772 2
d835 3
d873 1
a879 1
    SvREFCNT_dec(PL_apiversion);
d908 8
d994 1
d997 1
a1011 1
    SvREFCNT_dec(PL_utf8_foldclosures);
d1013 1
d1016 1
a1030 1
    PL_utf8_foldclosures = NULL;
d1035 2
a1036 2
    cophh_free(CopHINTHASH_get(&PL_compiling));
    CopHINTHASH_set(&PL_compiling, cophh_new_empty());
a1042 2
    /* break ref loop  *:: <=> %:: */
    (void)hv_delete(hv, "main::", 6, G_DISCARD);
a1071 6
#ifdef PERL_IMPLICIT_CONTEXT
    /* the entries in this list are allocated via SV PVX's, so get freed
     * in sv_clean_all */
    Safefree(PL_my_cxt_list);
#endif

d1118 1
d1162 1
a1162 1
		if (SvTYPE(sv) != (svtype)SVTYPEMASK) {
d1166 1
a1166 2
			"\tallocated at %s:%d %s %s (parent 0x%"UVxf");"
			"serial %"UVuf"\n",
d1174 1
a1174 1
			PTR2UV(sv->sv_debug_parent),
d1239 2
d1392 35
d1432 2
a1433 3
	SV *const caret_x = GvSV(tmpgv);
#if defined(OS2)
	sv_setpv(caret_x, os2_execname(aTHX));
d1435 5
a1439 66
#  ifdef USE_KERN_PROC_PATHNAME
	size_t size = 0;
	int mib[4];
	mib[0] = CTL_KERN;
	mib[1] = KERN_PROC;
	mib[2] = KERN_PROC_PATHNAME;
	mib[3] = -1;

	if (sysctl(mib, 4, NULL, &size, NULL, 0) == 0
	    && size > 0 && size < MAXPATHLEN * MAXPATHLEN) {
	    sv_grow(caret_x, size);

	    if (sysctl(mib, 4, SvPVX(caret_x), &size, NULL, 0) == 0
		&& size > 2) {
		SvPOK_only(caret_x);
		SvCUR_set(caret_x, size - 1);
		SvTAINT(caret_x);
		return;
	    }
	}
#  elif defined(USE_NSGETEXECUTABLEPATH)
	char buf[1];
	uint32_t size = sizeof(buf);

	_NSGetExecutablePath(buf, &size);
	if (size < MAXPATHLEN * MAXPATHLEN) {
	    sv_grow(caret_x, size);
	    if (_NSGetExecutablePath(SvPVX(caret_x), &size) == 0) {
		char *const tidied = realpath(SvPVX(caret_x), NULL);
		if (tidied) {
		    sv_setpv(caret_x, tidied);
		    free(tidied);
		} else {
		    SvPOK_only(caret_x);
		    SvCUR_set(caret_x, size);
		}
		return;
	    }
	}
#  elif defined(HAS_PROCSELFEXE)
	char buf[MAXPATHLEN];
	int len = readlink(PROCSELFEXE_PATH, buf, sizeof(buf) - 1);

	/* On Playstation2 Linux V1.0 (kernel 2.2.1) readlink(/proc/self/exe)
	   includes a spurious NUL which will cause $^X to fail in system
	   or backticks (this will prevent extensions from being built and
	   many tests from working). readlink is not meant to add a NUL.
	   Normal readlink works fine.
	*/
	if (len > 0 && buf[len-1] == '\0') {
	    len--;
	}

	/* FreeBSD's implementation is acknowledged to be imperfect, sometimes
	   returning the text "unknown" from the readlink rather than the path
	   to the executable (or returning an error from the readlink). Any
	   valid path has a '/' in it somewhere, so use that to validate the
	   result. See http://www.freebsd.org/cgi/query-pr.cgi?pr=35703
	*/
	if (len > 0 && memchr(buf, '/', len)) {
	    sv_setpvn(caret_x, buf, len);
	    return;
	}
#  endif
	/* Fallback to this:  */
	sv_setpv(caret_x, PL_origargv[0]);
a1451 6
#define SET_CURSTASH(newstash)                       \
	if (PL_curstash != newstash) {                \
	    SvREFCNT_dec(PL_curstash);                 \
	    PL_curstash = (HV *)SvREFCNT_inc(newstash); \
	}

d1468 1
a1468 1
     * If you set PL_rehash_seed (and presumably also PL_rehash_seed_set)
d1606 1
a1606 1
	if (PL_unitcheckav) {
d1608 1
a1608 3
	}
	if (PL_checkav) {
	    PERL_SET_PHASE(PERL_PHASE_CHECK);
a1609 1
	}
d1620 2
a1621 2
	SET_CURSTASH(PL_defstash);
	if (PL_unitcheckav) {
d1623 1
a1623 3
	}
	if (PL_checkav) {
	    PERL_SET_PHASE(PERL_PHASE_CHECK);
a1624 1
	}
a1664 3
#  ifdef PERL_EXTERNAL_GLOB
			     " PERL_EXTERNAL_GLOB"
#  endif
a1676 6
#  ifdef PERL_PRESERVE_IVUV
			     " PERL_PRESERVE_IVUV"
#  endif
#  ifdef PERL_RELOCATABLE_INCPUSH
			     " PERL_RELOCATABLE_INCPUSH"
#  endif
a1682 3
#  ifdef UNLINK_ALL_VERSIONS
			     " UNLINK_ALL_VERSIONS"
#  endif
a1688 6
#  ifdef USE_LOCALE
			     " USE_LOCALE"
#  endif
#  ifdef USE_LOCALE_CTYPE
			     " USE_LOCALE_CTYPE"
#  endif
a1744 1
    bool doextract = FALSE;
d1749 1
a1749 1
    SV *linestr_sv = NULL;
a1750 1
    U32 lex_start_flags = 0;
d1752 2
a1753 1
    PERL_SET_PHASE(PERL_PHASE_START);
d1873 1
a1873 1
	    doextract = TRUE;
d1885 9
a1893 6
	    /* catch use of gnu style long options.
	       Both of these exit immediately.  */
	    if (strEQ(s, "version"))
		minus_v();
	    if (strEQ(s, "help"))
		usage();
d1960 1
a1960 8
    /* Set $^X early so that it can be used for relocatable paths in @@INC  */
    /* and for SITELIB_EXP in USE_SITECUSTOMIZE                            */
    assert (!PL_tainted);
    TAINT;
    S_set_caret_X(aTHX);
    TAINT_NOT;

#if defined(USE_SITECUSTOMIZE)
d1962 7
a1968 32
	/* The games with local $! are to avoid setting errno if there is no
	   sitecustomize script.  "q%c...%c", 0, ..., 0 becomes "q\0...\0",
	   ie a q() operator with a NUL byte as a the delimiter. This avoids
	   problems with pathnames containing (say) '  */
#  ifdef PERL_IS_MINIPERL
	AV *const inc = GvAV(PL_incgv);
	SV **const inc0 = inc ? av_fetch(inc, 0, FALSE) : NULL;

	if (inc0) {
	    (void)Perl_av_create_and_unshift_one(aTHX_ &PL_preambleav,
						 Perl_newSVpvf(aTHX_
							       "BEGIN { do {local $!; -f q%c%"SVf"/buildcustomize.pl%c} && do q%c%"SVf"/buildcustomize.pl%c }",
							       0, *inc0, 0,
							       0, *inc0, 0));
	}
#  else
	/* SITELIB_EXP is a function call on Win32.  */
	const char *const raw_sitelib = SITELIB_EXP;
	if (raw_sitelib) {
	    /* process .../.. if PERL_RELOCATABLE_INC is defined */
	    SV *sitelib_sv = mayberelocate(raw_sitelib, strlen(raw_sitelib),
					   INCPUSH_CAN_RELOCATE);
	    const char *const sitelib = SvPVX(sitelib_sv);
	    (void)Perl_av_create_and_unshift_one(aTHX_ &PL_preambleav,
						 Perl_newSVpvf(aTHX_
							       "BEGIN { do {local $!; -f q%c%s/sitecustomize.pl%c} && do q%c%s/sitecustomize.pl%c }",
							       0, sitelib, 0,
							       0, sitelib, 0));
	    assert (SvREFCNT(sitelib_sv) == 1);
	    SvREFCNT_dec(sitelib_sv);
	}
#  endif
d1986 1
d1988 3
d1996 1
a1996 5
	rsfp = open_script(scriptname, dosearch, &suidscript);
	if (!rsfp) {
	    rsfp = PerlIO_stdin();
	    lex_start_flags = LEX_DONT_CLOSE_RSFP;
	}
d1998 2
a1999 1
	validate_suid(rsfp);
d2017 1
a2017 1
	if (doextract) {
a2023 2
	    linestr_sv = newSV_type(SVt_PV);
	    lex_start_flags |= LEX_START_COPIED;
d2151 1
a2151 4
    lex_start(linestr_sv, rsfp, lex_start_flags);
    if(linestr_sv)
	SvREFCNT_dec(linestr_sv);

d2160 1
a2160 1
    if (yyparse(GRAMPROG) || PL_parser->error_count) {
d2169 1
a2169 1
    SET_CURSTASH(PL_defstash);
a2195 1
    PL_restartjmpenv = NULL;
d2239 1
a2239 1
	SET_CURSTASH(PL_defstash);
d2241 1
a2241 2
	    PL_endav && !PL_minus_c) {
	    PERL_SET_PHASE(PERL_PHASE_END);
a2242 1
	}
d2254 1
a2254 1
	PerlIO_printf(Perl_error_log, "panic: restartop in perl_run\n");
d2291 1
a2291 2
	if (PL_initav) {
	    PERL_SET_PHASE(PERL_PHASE_INIT);
a2292 1
	}
a2299 2
    PERL_SET_PHASE(PERL_PHASE_RUN);

a2300 1
	PL_restartjmpenv = NULL;
d2345 2
a2346 3
Returns the AV of the specified Perl global or package array with the given
name (so it won't work on lexical variables).  C<flags> are passed 
to C<gv_fetchpv>. If C<GV_ADD> is set and the
a2349 2
Perl equivalent: C<@@{"$name"}>.

d2451 1
a2451 4
Performs a callback to the specified named and package-scoped Perl subroutine 
with C<argv> (a NULL-terminated array of strings) as arguments. See L<perlcall>.

Approximate Perl equivalent: C<&{"$sub_name"}(@@$argv)>.
d2616 1
a2616 1
	    SET_CURSTASH(PL_defstash);
a2622 1
		PL_restartjmpenv = NULL;
d2657 1
a2657 2
Tells Perl to C<eval> the string in the SV. It supports the same flags
as C<call_sv>, with the obvious exception of G_EVAL. See L<perlcall>.
d2705 1
a2705 6
	if (PL_op == (OP*)(&myop)) {
	    PL_op = PL_ppaddr[OP_ENTEREVAL](aTHX);
	    if (!PL_op)
		goto fail; /* failed in compilation */
	}
	CALLRUNOPS(aTHX);
d2716 1
a2716 1
	SET_CURSTASH(PL_defstash);
a2722 1
	    PL_restartjmpenv = NULL;
a2726 1
      fail:
d2810 1
a2810 1
S_usage(pTHX)		/* XXX move this out into a module ? */
a2814 2
    /* Grouped as 6 lines per C string literal, to keep under the ANSI C 89
       minimum of 509 character string literals.  */
d2816 29
a2844 30
"  -0[octal]         specify record separator (\\0, if no argument)\n"
"  -a                autosplit mode with -n or -p (splits $_ into @@F)\n"
"  -C[number/list]   enables the listed Unicode features\n"
"  -c                check syntax only (runs BEGIN and CHECK blocks)\n"
"  -d[:debugger]     run program under debugger\n"
"  -D[number/list]   set debugging flags (argument is a bit mask or alphabets)\n",
"  -e program        one line of program (several -e's allowed, omit programfile)\n"
"  -E program        like -e, but enables all optional features\n"
"  -f                don't do $sitelib/sitecustomize.pl at startup\n"
"  -F/pattern/       split() pattern for -a switch (//'s are optional)\n"
"  -i[extension]     edit <> files in place (makes backup if extension supplied)\n"
"  -Idirectory       specify @@INC/#include directory (several -I's allowed)\n",
"  -l[octal]         enable line ending processing, specifies line terminator\n"
"  -[mM][-]module    execute \"use/no module...\" before executing program\n"
"  -n                assume \"while (<>) { ... }\" loop around program\n"
"  -p                assume loop like -n but print line also, like sed\n"
"  -s                enable rudimentary parsing for switches after programfile\n"
"  -S                look for programfile using PATH environment variable\n",
"  -t                enable tainting warnings\n"
"  -T                enable tainting checks\n"
"  -u                dump core after parsing program\n"
"  -U                allow unsafe operations\n"
"  -v                print version, patchlevel and license\n"
"  -V[:variable]     print configuration summary (or a single Config.pm variable)\n",
"  -w                enable many useful warnings\n"
"  -W                enable all warnings\n"
"  -x[directory]     ignore text before #!perl line (optionally cd to directory)\n"
"  -X                disable all warnings\n"
"  \n"
"Run 'perldoc perl' for more help with Perl.\n\n",
a2847 1
    PerlIO *out = PerlIO_stdout();
d2849 5
a2853 3
    PerlIO_printf(out,
		  "\nUsage: %s [switches] [--] [programfile] [arguments]\n",
		  PL_origargv[0]);
d2855 1
a2855 2
	PerlIO_puts(out, *p++);
    my_exit(0);
d2866 25
a2890 25
      " Debugging flag values: (see also -d)\n"
      "  p  Tokenizing and parsing (with v, displays parse stack)\n"
      "  s  Stack snapshots (with v, displays all stacks)\n"
      "  l  Context (loop) stack processing\n"
      "  t  Trace execution\n"
      "  o  Method and overloading resolution\n",
      "  c  String/numeric conversions\n"
      "  P  Print profiling info, source file input state\n"
      "  m  Memory and SV allocation\n"
      "  f  Format processing\n"
      "  r  Regular expression parsing and execution\n"
      "  x  Syntax tree dump\n",
      "  u  Tainting checks\n"
      "  H  Hash dump -- usurps values()\n"
      "  X  Scratchpad allocation\n"
      "  D  Cleaning up\n"
      "  T  Tokenising\n"
      "  R  Include reference counts of dumped variables (eg when using -Ds)\n",
      "  J  Do not s,t,P-debug (Jump over) opcodes within package DB\n"
      "  v  Verbose: use in conjunction with other flags\n"
      "  C  Copy On Write\n"
      "  A  Consistency checks on internal structures\n"
      "  q  quiet - currently only suppresses the 'EXECUTING' message\n"
      "  M  trace smart match resolution\n"
      "  B  dump suBroutine definitions, including special Blocks like BEGIN\n",
d2916 1
a2916 1
      while (*p) PerlIO_puts(PerlIO_stdout(), *p++);
d3014 3
a3016 10
	    const char *start;
	    const char *end;
	    SV *sv;

	    if (*++s == '-') {
		++s;
		sv = newSVpvs("no Devel::");
	    } else {
		sv = newSVpvs("use Devel::");
	    }
d3018 1
a3018 4
	    start = s;
	    end = s + strlen(s);

	    /* We now allow -d:Module=Foo,Bar and -d:-Module */
d3052 2
a3053 1
	usage();
a3191 1
    case 'T':
d3193 1
a3193 1
	    TOO_LATE_FOR(*s);
d3195 5
a3209 58
	minus_v();
    case 'w':
	if (! (PL_dowarn & G_WARN_ALL_MASK)) {
	    PL_dowarn |= G_WARN_ON;
	}
	s++;
	return s;
    case 'W':
	PL_dowarn = G_WARN_ALL_ON|G_WARN_ON;
        if (!specialWARN(PL_compiling.cop_warnings))
            PerlMemShared_free(PL_compiling.cop_warnings);
	PL_compiling.cop_warnings = pWARN_ALL ;
	s++;
	return s;
    case 'X':
	PL_dowarn = G_WARN_ALL_OFF;
        if (!specialWARN(PL_compiling.cop_warnings))
            PerlMemShared_free(PL_compiling.cop_warnings);
	PL_compiling.cop_warnings = pWARN_NONE ;
	s++;
	return s;
    case '*':
    case ' ':
        while( *s == ' ' )
          ++s;
	if (s[0] == '-')	/* Additional switches on #! line. */
	    return s+1;
	break;
    case '-':
    case 0:
#if defined(WIN32) || !defined(PERL_STRICT_CR)
    case '\r':
#endif
    case '\n':
    case '\t':
	break;
#ifdef ALTERNATE_SHEBANG
    case 'S':			/* OS/2 needs -S on "extproc" line. */
	break;
#endif
    case 'e': case 'f': case 'x': case 'E':
#ifndef ALTERNATE_SHEBANG
    case 'S':
#endif
    case 'V':
	Perl_croak(aTHX_ "Can't emulate -%.1s on #! line",s);
    default:
	Perl_croak(aTHX_
	    "Unrecognized switch: -%.1s  (-h will show valid options)",s
	);
    }
    return NULL;
}


STATIC void
S_minus_v(pTHX)
{
d3260 1
a3260 1
		      "\n\nCopyright 1987-2012, Larry Wall\n");
d3327 43
d3411 2
a3412 2
#  define PERLVAR(prefix,var,type)
#  define PERLVARA(prefix,var,n,type)
d3414 2
a3415 2
#    define PERLVARI(prefix,var,type,init)	aTHX->prefix##var = init;
#    define PERLVARIC(prefix,var,type,init)	aTHX->prefix##var = init;
d3417 2
a3418 2
#    define PERLVARI(prefix,var,type,init)	PERL_GET_INTERP->var = init;
#    define PERLVARIC(prefix,var,type,init)	PERL_GET_INTERP->var = init;
d3426 4
a3429 4
#  define PERLVAR(prefix,var,type)
#  define PERLVARA(prefix,var,n,type)
#  define PERLVARI(prefix,var,type,init)	PL_##var = init;
#  define PERLVARIC(prefix,var,type,init)	PL_##var = init;
d3449 1
a3449 1
    PL_curstash = PL_defstash = (HV *)SvREFCNT_inc_simple_NN(newHV());
d3482 1
a3482 1
    SET_CURSTASH(PL_defstash);
d3491 3
a3493 2
STATIC PerlIO *
S_open_script(pTHX_ const char *scriptname, bool dosearch, bool *suidscript)
a3495 1
    PerlIO *rsfp = NULL;
d3545 6
a3550 1
	rsfp = PerlIO_fdopen(fdscript,PERL_SCRIPT_MODE);
d3554 1
a3554 1
	return NULL;
d3589 1
a3589 1
	rsfp = PerlIO_open(scriptname,PERL_SCRIPT_MODE);
d3598 5
d3604 1
a3604 1
    if (!rsfp) {
d3612 1
a3612 5
#if defined(HAS_FCNTL) && defined(F_SETFD)
    /* ensure close-on-exec */
    fcntl(PerlIO_fileno(rsfp), F_SETFD, 1);
#endif
    return rsfp;
a3628 5
    const UV  my_uid = PerlProc_getuid();
    const UV my_euid = PerlProc_geteuid();
    const UV  my_gid = PerlProc_getgid();
    const UV my_egid = PerlProc_getegid();

d3631 1
a3631 1
    if (my_euid != my_uid || my_egid != my_gid) {	/* (suidperl doesn't exist, in fact) */
d3635 1
a3635 1
	if ((my_euid != my_uid && my_euid == PL_statbuf.st_uid && PL_statbuf.st_mode & S_ISUID)
d3637 1
a3637 1
	    (my_egid != my_gid && my_egid == PL_statbuf.st_gid && PL_statbuf.st_mode & S_ISGID)
d3658 1
a3658 1
    do {
d3662 14
a3675 11
    } while (!(*s == '#' && s[1] == '!' && ((s = instr(s,"perl")) || (s = instr(s2,"PERL")))));
    PerlIO_ungetc(rsfp, '\n');		/* to keep line count right */
    while (*s && !(isSPACE (*s) || *s == '#')) s++;
    s2 = s;
    while (*s == ' ' || *s == '\t') s++;
    if (*s++ == '-') {
	while (isDIGIT(s2[-1]) || s2[-1] == '-' || s2[-1] == '.'
	       || s2[-1] == '_') s2--;
	if (strnEQ(s2-4,"perl",4))
	    while ((s = moreswitches(s)))
		;
d3684 8
a3691 5
    const UV my_uid = PerlProc_getuid();
    const UV my_euid = PerlProc_geteuid();
    const UV my_gid = PerlProc_getgid();
    const UV my_egid = PerlProc_getegid();

d3693 2
a3694 2
    CHECK_MALLOC_TAINT(my_uid && (my_euid != my_uid || my_egid != my_gid));
    PL_tainting |= (my_uid && (my_euid != my_uid || my_egid != my_gid));
d3760 1
a3760 1
    if (PerlProc_getuid() != PerlProc_geteuid())
d3762 1
a3762 1
    if (PerlProc_getgid() != PerlProc_getegid())
a3780 2
	if (SvTIED_mg((const SV *)args, PERL_MAGIC_tied))
	    Perl_croak(aTHX_ "Cannot set tied @@DB::args");
d3782 1
a3782 1
    AvREIFY_only(PL_dbargs);
d3791 1
a3791 1
    PL_curstash = (HV *)SvREFCNT_inc_simple(PL_debstash);
d3798 1
a3798 2
    if (!SvIOK(PL_DBsingle))
	sv_setiv(PL_DBsingle, 0);
d3800 1
a3800 2
    if (!SvIOK(PL_DBtrace))
	sv_setiv(PL_DBtrace, 0);
d3802 1
a3802 3
    if (!SvIOK(PL_DBsignal))
	sv_setiv(PL_DBsignal, 0);
    SvREFCNT_dec(PL_curstash);
a3873 33
void
Perl_populate_isa(pTHX_ const char *name, STRLEN len, ...)
{
    GV *const gv = gv_fetchpvn(name, len, GV_ADD | GV_ADDMULTI, SVt_PVAV);
    AV *const isa = GvAVn(gv);
    va_list args;

    PERL_ARGS_ASSERT_POPULATE_ISA;

    if(AvFILLp(isa) != -1)
	return;

    /* NOTE: No support for tied ISA */

    va_start(args, len);
    do {
	const char *const parent = va_arg(args, const char*);
	size_t parent_len;

	if (!parent)
	    break;
	parent_len = va_arg(args, size_t);

	/* Arguments are supplied with a trailing ::  */
	assert(parent_len > 2);
	assert(parent[parent_len - 1] == ':');
	assert(parent[parent_len - 2] == ':');
	av_push(isa, newSVpvn(parent, parent_len - 2));
	(void) gv_fetchpvn(parent, parent_len, GV_ADD, SVt_PVGV);
    } while (1);
    va_end(args);
}

d3881 1
d3900 8
a3907 5
    Perl_populate_isa(aTHX_ STR_WITH_LEN("IO::File::ISA"),
		      STR_WITH_LEN("IO::Handle::"),
		      STR_WITH_LEN("IO::Seekable::"),
		      STR_WITH_LEN("Exporter::"),
		      NULL);
d3937 1
a3937 1
    PL_statname = newSVpvs("");		/* last filename we did stat on */
d4052 8
a4268 1
#ifndef PERL_IS_MINIPERL
a4289 1
#endif
d4291 2
a4292 2
STATIC SV *
S_mayberelocate(pTHX_ const char *const dir, STRLEN len, U32 flags)
d4294 11
d4306 3
a4308 1
    SV *libdir;
d4310 1
a4310 1
    PERL_ARGS_ASSERT_MAYBERELOCATE;
d4313 13
a4336 16
#ifdef VMS
    {
	char *unix;

	if ((unix = tounixspec_ts(SvPV(libdir,len),NULL)) != NULL) {
	    len = strlen(unix);
	    while (unix[len-1] == '/') len--;  /* Cosmetic */
	    sv_usepvn(libdir,unix,len);
	}
	else
	    PerlIO_printf(Perl_error_log,
		          "Failed to unixify @@INC element \"%s\"\n",
			  SvPV_nolen_const(libdir));
    }
#endif

d4427 2
a4428 3
			(PerlProc_getuid() != PerlProc_geteuid() ||
			 PerlProc_getgid() != PerlProc_getegid())) {
			/* Need to taint relocated paths if running set ID  */
a4435 40
    return libdir;
}

STATIC void
S_incpush(pTHX_ const char *const dir, STRLEN len, U32 flags)
{
    dVAR;
#ifndef PERL_IS_MINIPERL
    const U8 using_sub_dirs
	= (U8)flags & (INCPUSH_ADD_VERSIONED_SUB_DIRS
		       |INCPUSH_ADD_ARCHONLY_SUB_DIRS|INCPUSH_ADD_OLD_VERS);
    const U8 add_versioned_sub_dirs
	= (U8)flags & INCPUSH_ADD_VERSIONED_SUB_DIRS;
    const U8 add_archonly_sub_dirs
	= (U8)flags & INCPUSH_ADD_ARCHONLY_SUB_DIRS;
#ifdef PERL_INC_VERSION_LIST
    const U8 addoldvers  = (U8)flags & INCPUSH_ADD_OLD_VERS;
#endif
#endif
    const U8 unshift     = (U8)flags & INCPUSH_UNSHIFT;
    const U8 push_basedir = (flags & INCPUSH_NOT_BASEDIR) ? 0 : 1;
    AV *const inc = GvAVn(PL_incgv);

    PERL_ARGS_ASSERT_INCPUSH;
    assert(len > 0);

    /* Could remove this vestigial extra block, if we don't mind a lot of
       re-indenting diff noise.  */
    {
	SV *const libdir = mayberelocate(dir, len, flags);
	/* Change 20189146be79a0596543441fa369c6bf7f85103f, to fix RT#6665,
	   arranged to unshift #! line -I onto the front of @@INC. However,
	   -I can add version and architecture specific libraries, and they
	   need to go first. The old code assumed that it was always
	   pushing. Hence to make it work, need to push the architecture
	   (etc) libraries onto a temporary array, then "unshift" that onto
	   the front of @@INC.  */
#ifndef PERL_IS_MINIPERL
	AV *const av = (using_sub_dirs) ? (unshift ? newAV() : inc) : NULL;

d4441 1
a4441 1
	    SV *subdir = newSVsv(libdir);
d4447 17
d4495 1
a4495 1
#endif /* !PERL_IS_MINIPERL */
a4497 3
#ifdef PERL_IS_MINIPERL
	    const U32 extra = 0;
#else
a4498 1
#endif
a4501 1
#ifndef PERL_IS_MINIPERL
a4515 1
#endif
a4537 7
    /* perl compiled with -DPERL_RELOCATABLE_INCPUSH will ignore the len
     * argument to incpush_use_sep.  This allows creation of relocatable
     * Perl distributions that patch the binary at install time.  Those
     * distributions will have to provide their own relocation tools; this
     * is not a feature otherwise supported by core Perl.
     */
#ifndef PERL_RELOCATABLE_INCPUSH
a4538 1
#endif
d4633 1
a4633 1
	    SET_CURSTASH(PL_defstash);
d4645 1
a4645 1
	    PerlIO_printf(Perl_error_log, "panic: restartop in call_list\n");
@


1.1.1.15
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d61 4
d245 23
a267 1
    init_constants();
d270 1
a270 1
    SvREFCNT(&PL_sv_placeholder) = SvREFCNT_IMMORTAL;
a309 1
    Newxz(PL_stashpad, PL_stashpadmax, HV *);
a313 13
#if defined(USE_HASH_SEED) || defined(USE_HASH_SEED_EXPLICIT)
        /* [perl #22371] Algorimic Complexity Attack on Perl 5.6.1, 5.8.0
         * This MUST be done before any hash stores or fetches take place.
         * If you set PL_hash_seed (and presumably also PL_hash_seed_set)
         * yourself, it is your responsibility to provide a good random seed!
         * You can also define PERL_HASH_SEED in compile time, see hv.h.
         *
         * XXX: fix this comment */
    if (PL_hash_seed_set == FALSE) {
        Perl_get_hash_seed(aTHX_ PL_hash_seed);
        PL_hash_seed_set= TRUE;
    }
#endif /* #if defined(USE_HASH_SEED) || defined(USE_HASH_SEED_EXPLICIT) */
d336 1
d339 1
a339 1
#if defined(HAS_SYSCONF) && defined(_SC_CLK_TCK)
a533 1
    int i;
d546 1
a546 1
#if defined(DEBUGGING) || defined(PERL_TRACK_MEMPOOL)
d550 3
a552 8
        const int i = atoi(s);
#ifdef DEBUGGING
	    if (destruct_level < i) destruct_level = i;
#endif
#ifdef PERL_TRACK_MEMPOOL
        /* RT #114496, for perl_free */
        PL_perl_destruct_level = i;
#endif
d739 4
a742 4
    /* Set PL_curcop now, because destroying ops can cause new SVs
       to be generated in Perl_pad_swipe, and when running with
      -DDEBUG_LEAKING_SCALARS they expect PL_curcop to point to a valid
       op from which the filename structure member is copied.  */
d768 9
a776 6
    /*
     * Try to destruct global references.  We do this first so that the
     * destructors and destructees still exist.  Some sv's might remain.
     * Non-referenced objects are on their own.
     */
    sv_clean_objs();
d831 1
d843 3
a845 9
    {
	I32 i = AvFILLp(PL_regex_padav);
	SV **ary = AvARRAY(PL_regex_padav);

	for (; i; i--) {
	    SvREFCNT_dec(ary[i]);
	    ary[i] = &PL_sv_undef;
	}
    }
a847 1

d872 1
a872 3
#ifdef PERL_SAWAMPERSAND
    PL_sawampersand = 0;	/* must save all match strings */
#endif
d983 11
a993 5
    /* clear character classes  */
    for (i = 0; i < POSIX_SWASH_COUNT; i++) {
        SvREFCNT_dec(PL_utf8_swash_ptrs[i]);
        PL_utf8_swash_ptrs[i] = NULL;
    }
d1002 10
a1019 10
    for (i = 0; i < POSIX_CC_COUNT; i++) {
        SvREFCNT_dec(PL_Posix_ptrs[i]);
        PL_Posix_ptrs[i] = NULL;

        SvREFCNT_dec(PL_L1Posix_ptrs[i]);
        PL_L1Posix_ptrs[i] = NULL;

        SvREFCNT_dec(PL_XPosix_ptrs[i]);
        PL_XPosix_ptrs[i] = NULL;
    }
d1027 1
a1062 6
#ifdef USE_ITHREADS
    SvREFCNT_dec(PL_regex_padav);
    PL_regex_padav = NULL;
    PL_regex_pad = NULL;
#endif

a1074 4
#ifdef USE_ITHREADS
    Safefree(PL_stashpad); /* must come after sv_clean_all */
#endif

d1153 1
a1153 1
	SV* svend;
d1206 6
d1226 3
d1243 1
d1245 2
a1246 2
    TAINTING_set(FALSE);
    TAINT_WARN_set(FALSE);
d1313 2
a1314 1
	if (PL_perl_destruct_level == 0) {
d1492 9
a1500 1
#if defined(USE_HASH_SEED) || defined(USE_HASH_SEED_EXPLICIT) || defined(USE_HASH_SEED_DEBUG)
d1502 1
a1502 1
        const char * const s = PerlEnv_getenv("PERL_HASH_SEED_DEBUG");
d1504 2
a1505 14
        if (s && (atoi(s) == 1)) {
            unsigned char *seed= PERL_HASH_SEED;
            unsigned char *seed_end= PERL_HASH_SEED + PERL_HASH_SEED_BYTES;
            PerlIO_printf(Perl_debug_log, "HASH_FUNCTION = %s HASH_SEED = 0x", PERL_HASH_FUNC);
            while (seed < seed_end) {
                PerlIO_printf(Perl_debug_log, "%02x", *seed++);
            }
#ifdef PERL_HASH_RANDOMIZE_KEYS
            PerlIO_printf(Perl_debug_log, " PERTURB_KEYS = %d (%s)",
                    PL_HASH_RAND_BITS_ENABLED,
                    PL_HASH_RAND_BITS_ENABLED == 0 ? "NO" : PL_HASH_RAND_BITS_ENABLED == 1 ? "RANDOM" : "DETERMINISTIC");
#endif
            PerlIO_printf(Perl_debug_log, "\n");
        }
d1508 1
d1610 1
a1610 1
	assert (!TAINT_get);
d1686 1
a1686 1
    static const char non_bincompat_options[] = 
a1692 3
#  ifdef NO_HASH_SEED
			     " NO_HASH_SEED"
#  endif
a1701 24
#  ifdef PERL_HASH_FUNC_SIPHASH
			     " PERL_HASH_FUNC_SIPHASH"
#  endif
#  ifdef PERL_HASH_FUNC_SDBM
			     " PERL_HASH_FUNC_SDBM"
#  endif
#  ifdef PERL_HASH_FUNC_DJB2
			     " PERL_HASH_FUNC_DJB2"
#  endif
#  ifdef PERL_HASH_FUNC_SUPERFAST
			     " PERL_HASH_FUNC_SUPERFAST"
#  endif
#  ifdef PERL_HASH_FUNC_MURMUR3
			     " PERL_HASH_FUNC_MURMUR3"
#  endif
#  ifdef PERL_HASH_FUNC_ONE_AT_A_TIME
			     " PERL_HASH_FUNC_ONE_AT_A_TIME"
#  endif
#  ifdef PERL_HASH_FUNC_ONE_AT_A_TIME_HARD
			     " PERL_HASH_FUNC_ONE_AT_A_TIME_HARD"
#  endif
#  ifdef PERL_HASH_FUNC_ONE_AT_A_TIME_OLD
			     " PERL_HASH_FUNC_ONE_AT_A_TIME_OLD"
#  endif
a1713 12
#  ifdef PERL_NEW_COPY_ON_WRITE
			     " PERL_NEW_COPY_ON_WRITE"
#  endif
#  ifdef PERL_PERTURB_KEYS_DETERMINISTIC
			     " PERL_PERTURB_KEYS_DETERMINISTIC"
#  endif
#  ifdef PERL_PERTURB_KEYS_DISABLED
			     " PERL_PERTURB_KEYS_DISABLED"
#  endif
#  ifdef PERL_PERTURB_KEYS_RANDOM
			     " PERL_PERTURB_KEYS_RANDOM"
#  endif
a1734 3
#  ifdef USE_HASH_SEED_EXPLICIT
			     " USE_HASH_SEED_EXPLICIT"
#  endif
d1796 1
a1796 1
    char c;
a1847 6
#if SILENT_NO_TAINT_SUPPORT
            /* silently ignore */
#elif NO_TAINT_SUPPORT
            Perl_croak_nocontext("This perl was compiled without taint support. "
                       "Cowardly refusing to run with -t or -T flags");
#else
d1849 3
a1851 3
	    if( !TAINTING_get ) {
	         TAINT_WARN_set(TRUE);
	         TAINTING_set(TRUE);
a1852 1
#endif
a1855 6
#if SILENT_NO_TAINT_SUPPORT
            /* silently ignore */
#elif NO_TAINT_SUPPORT
            Perl_croak_nocontext("This perl was compiled without taint support. "
                       "Cowardly refusing to run with -t or -T flags");
#else
d1857 2
a1858 3
	    TAINTING_set(TRUE);
	    TAINT_WARN_set(FALSE);
#endif
d1959 1
a1959 1
        !TAINTING_get &&
a1965 6
#if SILENT_NO_TAINT_SUPPORT
            /* silently ignore */
#elif NO_TAINT_SUPPORT
            Perl_croak_nocontext("This perl was compiled without taint support. "
                       "Cowardly refusing to run with -t or -T flags");
#else
d1967 2
a1968 3
	    TAINTING_set(TRUE);
            TAINT_WARN_set(FALSE);
#endif
d1998 3
a2000 9
#if SILENT_NO_TAINT_SUPPORT
            /* silently ignore */
#elif NO_TAINT_SUPPORT
                    Perl_croak_nocontext("This perl was compiled without taint support. "
                               "Cowardly refusing to run with -t or -T flags");
#else
		    if( !TAINTING_get) {
		        TAINT_WARN_set(TRUE);
		        TAINTING_set(TRUE);
a2001 1
#endif
d2012 1
a2012 1
    assert (!TAINT_get);
d2068 1
a2068 1
    assert (!TAINT_get);
d2128 1
a2128 1
#if defined(VMS) || defined(WIN32) || defined(DJGPP) || defined(__CYGWIN__) || defined(SYMBIAN)
d2211 1
a2211 2
    if (!TAINTING_get &&
        (s = PerlEnv_getenv("PERL_XMLDUMP"))) {
d2235 2
a2236 1
    SvREFCNT_dec(linestr_sv);
d2357 2
a2358 3
    DEBUG_r(PerlIO_printf(Perl_debug_log, "%s $` $& $' support (0x%x).\n",
                    PL_sawampersand ? "Enabling" : "Omitting",
                    (unsigned int)(PL_sawampersand)));
d2385 1
a2385 2
	if (PL_main_root && PL_main_root->op_slabbed)
	    Slab_to_ro(OpSLAB(PL_main_root));
d2405 1
a2405 1
    assert(0); /* NOTREACHED */
d2513 3
a2518 3
    /* XXX this is probably not what they think they're getting.
     * It has the same effect as "sub name;", i.e. just a forward
     * declaration! */
d2520 4
a2523 1
    	return newSTUB(gv,0);
d2557 1
a2557 1
Perl_call_argv(pTHX_ const char *sub_name, I32 flags, char **argv)
d2657 1
d2676 1
a2676 1
	myop.op_private |= OPpENTERSUB_DB;
d2680 1
a2680 1
	method_op.op_next = (OP*)&myop;
d2720 1
a2720 1
	    assert(0); /* NOTREACHED */
d2787 1
a2787 1
    Zero(&myop, 1, UNOP);
d2793 1
a2798 3
    if (flags & G_RE_REPARSING)
	myop.op_private = (OPpEVAL_COPHH | OPpEVAL_RE_REPARSING);

d2827 1
a2827 1
	assert(0); /* NOTREACHED */
d2869 1
d2877 3
a2879 5
    {
        dSP;
        sv = POPs;
        PUTBACK;
    }
d2881 2
a2882 6
    /* just check empty string or undef? */
    if (croak_on_error) {
	SV * const errsv = ERRSV;
	if(SvTRUE_NN(errsv))
	    /* replace with croak_sv? */
	    Perl_croak_nocontext("%s", SvPV_nolen_const(errsv));
a2993 1
      "  S  Op slab allocation\n"
d3013 1
a3013 1
	for (; isWORDCHAR(**s); (*s)++) {
d3024 1
a3024 1
	for (; isWORDCHAR(**s); (*s)++) ;
d3118 1
a3118 1
	if (*s == 't' && !isWORDCHAR(s[1])) {
d3141 1
a3141 1
	    while(isWORDCHAR(*s) || *s==':') ++s;
d3169 1
a3169 1
	for (s++; isWORDCHAR(*s); s++) ;
d3262 1
a3262 1
	    while(isWORDCHAR(*s) || *s==':') {
d3314 1
a3314 7
#if SILENT_NO_TAINT_SUPPORT
            /* silently ignore */
#elif NO_TAINT_SUPPORT
        Perl_croak_nocontext("This perl was compiled without taint support. "
                   "Cowardly refusing to run with -t or -T flags");
#else
        if (!TAINTING_get)
a3315 1
#endif
a3384 1
	PerlIO * PIO_stdout;
d3396 7
a3402 12
	    {
		STRLEN level_len, num_len;
		char * level_str, * num_str;
		num_str = SvPV(num, num_len);
		level_str = SvPV(level, level_len);
		if (num_len>=level_len && strnEQ(num_str,level_str,level_len)) {
		    SvREFCNT_dec(level);
		    level= num;
		} else {
		    Perl_sv_catpvf(aTHX_ level, " (%"SVf")", num);
		    SvREFCNT_dec(num);
		}
d3405 1
a3405 2
	PIO_stdout =  PerlIO_stdout();
	    PerlIO_printf(PIO_stdout,
a3413 1
	PIO_stdout =  PerlIO_stdout();
d3415 1
a3415 1
	PerlIO_printf(PIO_stdout,
d3418 1
a3418 1
	PerlIO_printf(PIO_stdout,
d3421 1
a3421 1
	PerlIO_printf(PIO_stdout,
d3427 1
a3427 1
	    PerlIO_printf(PIO_stdout,
d3434 2
a3435 2
	PerlIO_printf(PIO_stdout,
		      "\n\nCopyright 1987-2013, Larry Wall\n");
d3437 1
a3437 1
	PerlIO_printf(PIO_stdout,
d3441 1
a3441 1
	PerlIO_printf(PIO_stdout,
d3446 1
a3446 1
	PerlIO_printf(PIO_stdout,
d3450 12
d3463 1
a3463 1
	PerlIO_printf(PIO_stdout,
d3467 6
a3472 2
	PerlIO_printf(PIO_stdout,
		      "Stratus OpenVOS port by Paul.Green@@stratus.com, 1997-2013\n");
d3475 1
a3475 1
	PerlIO_printf(PIO_stdout,
d3478 4
d3483 2
a3484 3
	PerlIO_printf(PIO_stdout,
			"WINCE port by Rainer Keuchel, 2001-2002\n"
			"Built on " __DATE__ " " __TIME__ "\n\n");
d3488 1
a3488 1
	PerlIO_printf(PIO_stdout,
d3494 1
a3494 1
	PerlIO_printf(PIO_stdout,
a3508 4
#ifdef VMS
#include <lib$routines.h>
#endif

d3527 1
a3628 1
    Stat_t tmpstatbuf;
a3737 7

    if (PerlLIO_fstat(PerlIO_fileno(rsfp), &tmpstatbuf) >= 0
        && S_ISDIR(tmpstatbuf.st_mode))
        Perl_croak(aTHX_ "Can't open perl script \"%s\": %s\n",
            CopFILE(PL_curcop),
            strerror(EISDIR));

d3783 1
a3783 1
    const char *s2;
a3810 3
    /* no need to do anything here any more if we don't
     * do tainting. */
#if !NO_TAINT_SUPPORT
d3819 1
a3819 2
    TAINTING_set( TAINTING_get | (my_uid && (my_euid != my_uid || my_egid != my_gid)) );
#endif
d4101 1
a4101 1
Perl_init_argv_symbols(pTHX_ int argc, char **argv)
a4140 5

    if (PL_inplace && (!PL_argvgv || AvFILL(GvAV(PL_argvgv)) == -1))
        Perl_ck_warner_d(aTHX_ packWARN(WARN_INPLACE),
                         "-i used with no filenames on the command line, "
                         "reading from STDIN");
d4144 1
a4144 1
S_init_postdump_symbols(pTHX_ int argc, char **argv, char **env)
d4151 1
a4151 1
    PL_toptarget = newSV_type(SVt_PVIV);
d4153 1
a4153 1
    PL_bodytarget = newSV_type(SVt_PVIV);
d4231 1
a4231 1
    if (!TAINTING_get) {
d4347 1
a4347 1
    if (!TAINTING_get) {
d4404 1
a4404 1
    if (!TAINTING_get)
d4408 1
a4408 1
#if defined(DOSISH) || defined(__SYMBIAN32__)
d4454 10
a4463 6
    /* I am not convinced that this is valid when PERLLIB_MANGLE is
       defined to so something (in os2/os2.c), but the code has been
       this way, ignoring any possible changed of length, since
       760ac839baf413929cd31cc32ffd6dba6b781a81 (5.003_02) so I'll leave
       it be.  */
    libdir = newSVpvn(PERLLIB_MANGLE(dir, len), len);
d4570 1
a4570 1
		    if (TAINTING_get &&
d4820 1
a4820 1
	    assert(0); /* NOTREACHED */
d4980 1
a4980 1
 * indent-tabs-mode: nil
d4983 1
a4983 1
 * ex: set ts=8 sts=4 sw=4 et:
@


1.1.1.16
log
@Import perl-5.20.1
@
text
@a35 1
#include "charclass_invlists.h"
d41 8
d147 1
a147 1
Perl_sys_term(void)
a240 4
#ifdef PERL_TRACE_OPS
    Zero(PL_op_exec_cnt, OP_max+2, UV);
#endif

a260 6

    /* Keep LC_NUMERIC in the C locale for backwards compatibility for XS
     * modules.  (Core operations that need the underlying locale change to it
     * temporarily).  An explicit call to POSIX::setlocale() still will cause
     * XS module failures, but this is how it has been for a long time [perl
     * #121317] */
a310 2
    Zero(PL_sv_consts, SV_CONSTS_COUNT, SV*);

a384 18
    PL_XPosix_ptrs[_CC_ASCII] = _new_invlist_C_array(ASCII_invlist);
    PL_XPosix_ptrs[_CC_ALPHANUMERIC] = _new_invlist_C_array(XPosixAlnum_invlist);
    PL_XPosix_ptrs[_CC_ALPHA] = _new_invlist_C_array(XPosixAlpha_invlist);
    PL_XPosix_ptrs[_CC_BLANK] = _new_invlist_C_array(XPosixBlank_invlist);
    PL_XPosix_ptrs[_CC_CASED] =  _new_invlist_C_array(Cased_invlist);
    PL_XPosix_ptrs[_CC_CNTRL] = _new_invlist_C_array(XPosixCntrl_invlist);
    PL_XPosix_ptrs[_CC_DIGIT] = _new_invlist_C_array(XPosixDigit_invlist);
    PL_XPosix_ptrs[_CC_GRAPH] = _new_invlist_C_array(XPosixGraph_invlist);
    PL_XPosix_ptrs[_CC_LOWER] = _new_invlist_C_array(XPosixLower_invlist);
    PL_XPosix_ptrs[_CC_PRINT] = _new_invlist_C_array(XPosixPrint_invlist);
    PL_XPosix_ptrs[_CC_PUNCT] = _new_invlist_C_array(XPosixPunct_invlist);
    PL_XPosix_ptrs[_CC_SPACE] = _new_invlist_C_array(XPerlSpace_invlist);
    PL_XPosix_ptrs[_CC_PSXSPC] = _new_invlist_C_array(XPosixSpace_invlist);
    PL_XPosix_ptrs[_CC_UPPER] = _new_invlist_C_array(XPosixUpper_invlist);
    PL_XPosix_ptrs[_CC_VERTSPACE] = _new_invlist_C_array(VertSpace_invlist);
    PL_XPosix_ptrs[_CC_WORDCHAR] = _new_invlist_C_array(XPosixWord_invlist);
    PL_XPosix_ptrs[_CC_XDIGIT] = _new_invlist_C_array(XPosixXDigit_invlist);

d499 1
a499 1
		  returned_errno, Strerror(returned_errno));
d538 1
a538 1
            const int i = atoi(s);
d543 2
a544 2
            /* RT #114496, for perl_free */
            PL_perl_destruct_level = i;
a568 14
#ifdef PERL_TRACE_OPS
    /* If we traced all Perl OP usage, report and clean up */
    PerlIO_printf(Perl_debug_log, "Trace of all OPs executed:\n");
    for (i = 0; i <= OP_max; ++i) {
        PerlIO_printf(Perl_debug_log, "  %s: %"UVuf"\n", PL_op_name[i], PL_op_exec_cnt[i]);
        PL_op_exec_cnt[i] = 0;
    }
    /* Utility slot for easily doing little tracing experiments in the runloop: */
    if (PL_op_exec_cnt[OP_max+1] != 0)
        PerlIO_printf(Perl_debug_log, "  SPECIAL: %"UVuf"\n", PL_op_exec_cnt[OP_max+1]);
    PerlIO_printf(Perl_debug_log, "\n");
#endif


d643 1
a643 1
		msg.msg_iovlen = C_ARRAY_LENGTH(vec);
a740 1
	    PL_comppad_name = PadlistNAMES(CvPADLIST(PL_main_cv));
a825 2
    /* Below, do clean up for when PERL_DESTRUCT_LEVEL is not 0 */

d929 2
d933 1
d938 4
a948 15
    SvREFCNT_dec(PL_envgv);
    SvREFCNT_dec(PL_incgv);
    SvREFCNT_dec(PL_argvgv);
    SvREFCNT_dec(PL_replgv);
    SvREFCNT_dec(PL_DBgv);
    SvREFCNT_dec(PL_DBline);
    SvREFCNT_dec(PL_DBsub);
    PL_envgv = NULL;
    PL_incgv = NULL;
    PL_argvgv = NULL;
    PL_replgv = NULL;
    PL_DBgv = NULL;
    PL_DBline = NULL;
    PL_DBsub = NULL;

a992 1
    SvREFCNT_dec(PL_utf8_foldable);
a993 5
    SvREFCNT_dec(PL_AboveLatin1);
    SvREFCNT_dec(PL_UpperLatin1);
    SvREFCNT_dec(PL_Latin1);
    SvREFCNT_dec(PL_NonL1NonFinalFold);
    SvREFCNT_dec(PL_HasMultiCharFold);
a1001 5
    PL_AboveLatin1       = NULL;
    PL_HasMultiCharFold  = NULL;
    PL_Latin1            = NULL;
    PL_NonL1NonFinalFold = NULL;
    PL_UpperLatin1       = NULL;
d1003 6
a1083 6
    /* constant strings */
    for (i = 0; i < SV_CONSTS_COUNT; i++) {
        SvREFCNT_dec(PL_sv_consts[i]);
        PL_sv_consts[i] = NULL;
    }

d1222 1
d1314 1
a1314 1
		safesysfree(PERL_MEMORY_DEBUG_HEADER_SIZE + (char *)(aTHXx->Imemory_debug_header.next));
d1325 3
d1329 1
a1331 2
	void *host = w32_internal_host;
	PerlMem_free(aTHXx);
d1360 1
a1360 5
    if (
#ifdef PERL_GLOBAL_STRUCT_PRIVATE
        my_vars &&
#endif
        PL_curinterp && !PL_veto_cleanup)
d1377 79
d1605 1
a1605 1
	set_caret_X();
a1688 6
#  ifdef NO_TAINT_SUPPORT
			     " NO_TAINT_SUPPORT"
#  endif
#  ifdef PERL_BOOL_AS_CHAR
			     " PERL_BOOL_AS_CHAR"
#  endif
d1883 1
a1883 1
#if defined(SILENT_NO_TAINT_SUPPORT)
d1885 1
a1885 1
#elif defined(NO_TAINT_SUPPORT)
d1898 1
a1898 1
#if defined(SILENT_NO_TAINT_SUPPORT)
d1900 1
a1900 1
#elif defined(NO_TAINT_SUPPORT)
d2015 1
a2015 1
#if defined(SILENT_NO_TAINT_SUPPORT)
d2017 1
a2017 1
#elif defined(NO_TAINT_SUPPORT)
d2054 1
a2054 1
#if defined(SILENT_NO_TAINT_SUPPORT)
d2056 1
a2056 1
#elif defined(NO_TAINT_SUPPORT)
d2077 1
a2077 1
    set_caret_X();
a2090 2
            /* if lib/buildcustomize.pl exists, it should not fail. If it does,
               it should be reported immediately as a build failure.  */
d2093 1
a2093 1
        "BEGIN { do {local $!; -f q%c%"SVf"/buildcustomize.pl%c} and do q%c%"SVf"/buildcustomize.pl%c || die $@@ }",
d2479 1
a2479 1
C<gv_fetchpv>.  If C<GV_ADD> is set and the
d2506 1
a2506 1
to C<gv_fetchpv>.  If C<GV_ADD> is set and the
d2535 1
a2535 1
C<gv_fetchpv>.  If C<GV_ADD> is set and the
d2562 1
a2562 1
C<gv_fetchpvn_flags>.  If C<GV_ADD> is set and the Perl subroutine does not
d2611 1
a2611 2
with C<argv> (a NULL-terminated array of strings) as arguments.  See
L<perlcall>.
a2672 1
    SV* sv;
a2675 3
    sv = flags & G_METHOD_NAMED
        ? sv_2mortal(newSVpvn_share(methname, len,0))
        : newSVpvn_flags(methname, len, SVs_TEMP);
d2677 2
a2678 1
    return call_sv(sv, flags | G_METHOD);
d2697 1
a2697 2
    UNOP method_unop;
    SVOP method_svop;
d2726 1
a2726 2
    if (!(flags & G_METHOD_NAMED))
        *++PL_stack_sp = sv;
d2739 8
a2746 18
    if (flags & (G_METHOD|G_METHOD_NAMED)) {
        if ( flags & G_METHOD_NAMED ) {
            Zero(&method_svop, 1, SVOP);
            method_svop.op_next = (OP*)&myop;
            method_svop.op_ppaddr = PL_ppaddr[OP_METHOD_NAMED];
            method_svop.op_type = OP_METHOD_NAMED;
            method_svop.op_sv = sv;
            PL_op = (OP*)&method_svop;
        } else {
            Zero(&method_unop, 1, UNOP);
            method_unop.op_next = (OP*)&myop;
            method_unop.op_ppaddr = PL_ppaddr[OP_METHOD];
            method_unop.op_type = OP_METHOD;
            PL_op = (OP*)&method_unop;
        }
        myop.op_ppaddr = PL_ppaddr[OP_ENTERSUB];
        myop.op_type = OP_ENTERSUB;

d2819 2
a2820 2
Tells Perl to C<eval> the string in the SV.  It supports the same flags
as C<call_sv>, with the obvious exception of G_EVAL.  See L<perlcall>.
d2979 1
d2982 1
a3071 1
      "  L  trace some locale setting information--for Perl core development\n",
d3080 1
a3080 1
	static const char debopts[] = "psltocPmfrxuUHXDSTRJvCAqMBL";
a3168 1
	PL_minus_a = TRUE;
a3169 1
        PL_minus_n = TRUE;
a3175 1
        PL_minus_n = TRUE;
d3383 1
a3383 1
#if defined(SILENT_NO_TAINT_SUPPORT)
d3385 1
a3385 1
#elif defined(NO_TAINT_SUPPORT)
d3462 3
d3466 1
a3466 2
	    const char * const level_str = "v" PERL_VERSION_STRING;
	    const STRLEN level_len = sizeof("v" PERL_VERSION_STRING)-1;
a3467 1
	    SV* level;
d3469 1
a3469 1
	    static const char num [] = PERL_PATCHNUM "*";
d3471 1
a3471 1
	    static const char num [] = PERL_PATCHNUM;
d3474 7
a3480 11
		const STRLEN num_len = sizeof(num)-1;
		/* A very advanced compiler would fold away the strnEQ
		   and this whole conditional, but most (all?) won't do it.
		   SV level could also be replaced by with preprocessor
		   catenation.
		*/
		if (num_len >= level_len && strnEQ(num,level_str,level_len)) {
		    /* per 46807d8e80, PERL_PATCHNUM is outside of the control
		       of the interp so it might contain format characters
		    */
		    level = newSVpvn(num, num_len);
d3482 2
a3483 1
		    level = Perl_newSVpvf_nocontext("%s (%s)", level_str, num);
d3486 1
a3486 3
#else
	SV* level = newSVpvn(level_str, level_len);
#endif /* #ifdef PERL_PATCHNUM */
d3494 1
a3494 1
	    SvREFCNT_dec_NN(level);
d3496 13
d3519 1
a3519 1
		      "\n\nCopyright 1987-2014, Larry Wall\n");
d3637 4
a3667 1
    SvREFCNT_inc_simple_void(PL_hintgv);
d3671 1
a3671 1
    PL_errgv = gv_fetchpvs("@@", GV_ADD|GV_NOTQUAL, SVt_PV);
a3674 1
    SvREFCNT_inc_simple_void(PL_replgv);
d3812 1
a3812 1
            Strerror(EISDIR));
d3831 4
a3834 4
    const Uid_t  my_uid = PerlProc_getuid();
    const Uid_t my_euid = PerlProc_geteuid();
    const Gid_t  my_gid = PerlProc_getgid();
    const Gid_t my_egid = PerlProc_getegid();
d3889 1
a3889 1
#ifndef NO_TAINT_SUPPORT
d3891 4
a3894 4
    const Uid_t my_uid = PerlProc_getuid();
    const Uid_t my_euid = PerlProc_geteuid();
    const Gid_t my_gid = PerlProc_getgid();
    const Gid_t my_egid = PerlProc_getegid();
d3926 4
a3929 4
    Uid_t uid  = PerlProc_getuid();
    Uid_t euid = PerlProc_geteuid();
    Gid_t gid  = PerlProc_getgid();
    Gid_t egid = PerlProc_getegid();
d4001 3
a4003 9
    PL_DBgv = MUTABLE_GV(
	SvREFCNT_inc(gv_fetchpvs("DB::DB", GV_ADDMULTI, SVt_PVGV))
    );
    PL_DBline = MUTABLE_GV(
	SvREFCNT_inc(gv_fetchpvs("DB::dbline", GV_ADDMULTI, SVt_PVAV))
    );
    PL_DBsub = MUTABLE_GV(SvREFCNT_inc(
	gv_HVadd(gv_fetchpvs("DB::sub", GV_ADDMULTI, SVt_PVHV))
    ));
a4018 1
#define REASONABLE_but_at_least(size,min) (size)
a4020 1
#define REASONABLE_but_at_least(size,min) (min)
d4056 1
a4056 1
    Newx(PL_savestack,REASONABLE_but_at_least(128,SS_MAXPUSH),ANY);
d4058 1
a4058 1
    PL_savestack_max = REASONABLE_but_at_least(128,SS_MAXPUSH);
a4206 1
	SvREFCNT_inc_simple_void_NN(PL_argvgv);
d4208 1
d4212 1
a4212 1
	    av_push(GvAV(PL_argvgv),sv);
a4251 1
	SvREFCNT_inc_simple_void_NN(PL_envgv);
d4552 1
a4552 1
	    while (len > 1 && unix[len-1] == '/') len--;  /* Cosmetic */
d4748 1
a4748 1
	    const Size_t extra = 0;
d4750 1
a4750 1
	    Size_t extra = av_tindex(av) + 1;
d4837 1
a4837 1
    while (av_tindex(paramList) >= 0) {
a4919 8
    if (PL_exit_flags & PERL_EXIT_ABORT) {
	abort();
    }
    if (PL_exit_flags & PERL_EXIT_WARN) {
	PL_exit_flags |= PERL_EXIT_ABORT; /* Protect against reentrant calls */
	Perl_warn(aTHX_ "Unexpected exit %lu", (unsigned long)status);
	PL_exit_flags &= ~PERL_EXIT_ABORT;
    }
a5016 8
    if (PL_exit_flags & PERL_EXIT_ABORT) {
	abort();
    }
    if (PL_exit_flags & PERL_EXIT_WARN) {
	PL_exit_flags |= PERL_EXIT_ABORT; /* Protect against reentrant calls */
	Perl_warn(aTHX_ "Unexpected exit failure %ld", (long)PL_statusvalue);
	PL_exit_flags &= ~PERL_EXIT_ABORT;
    }
@


1.1.1.17
log
@Import perl-5.20.2
@
text
@d2928 1
a2928 1
Tells Perl to C<eval> the given string in scalar context and return an SV* result.
d3517 1
a3517 1
		      "\n\nCopyright 1987-2015, Larry Wall\n");
@


