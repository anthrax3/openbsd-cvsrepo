head	1.2;
access;
symbols
	OPENBSD_6_2:1.2.0.6
	OPENBSD_6_2_BASE:1.2
	PERL_5_24_2:1.1.1.11
	OPENBSD_6_1:1.2.0.4
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.10.0.10
	OPENBSD_6_0_BASE:1.1.1.10
	OPENBSD_5_9:1.1.1.10.0.4
	OPENBSD_5_9_BASE:1.1.1.10
	OPENBSD_5_8:1.1.1.10.0.6
	OPENBSD_5_8_BASE:1.1.1.10
	PERL_5_20_2:1.1.1.10
	OPENBSD_5_7:1.1.1.10.0.2
	OPENBSD_5_7_BASE:1.1.1.10
	PERL_5_20_1:1.1.1.10
	OPENBSD_5_6:1.1.1.9.0.4
	OPENBSD_5_6_BASE:1.1.1.9
	PERL_5_18_2:1.1.1.9
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.8.0.6
	OPENBSD_5_5_BASE:1.1.1.8
	OPENBSD_5_4:1.1.1.8.0.2
	OPENBSD_5_4_BASE:1.1.1.8
	PERL_5_16_3:1.1.1.8
	OPENBSD_5_3:1.1.1.7.0.10
	OPENBSD_5_3_BASE:1.1.1.7
	OPENBSD_5_2:1.1.1.7.0.8
	OPENBSD_5_2_BASE:1.1.1.7
	OPENBSD_5_1_BASE:1.1.1.7
	OPENBSD_5_1:1.1.1.7.0.6
	OPENBSD_5_0:1.1.1.7.0.4
	OPENBSD_5_0_BASE:1.1.1.7
	OPENBSD_4_9:1.1.1.7.0.2
	OPENBSD_4_9_BASE:1.1.1.7
	PERL_5_12_2:1.1.1.7
	OPENBSD_4_8:1.1.1.6.0.4
	OPENBSD_4_8_BASE:1.1.1.6
	OPENBSD_4_7:1.1.1.6.0.2
	OPENBSD_4_7_BASE:1.1.1.6
	PERL_5_10_1:1.1.1.6
	OPENBSD_4_6:1.1.1.5.0.6
	OPENBSD_4_6_BASE:1.1.1.5
	OPENBSD_4_5:1.1.1.5.0.2
	OPENBSD_4_5_BASE:1.1.1.5
	PERL_5_10_0:1.1.1.5
	OPENBSD_4_4:1.1.1.4.0.10
	OPENBSD_4_4_BASE:1.1.1.4
	OPENBSD_4_3:1.1.1.4.0.8
	OPENBSD_4_3_BASE:1.1.1.4
	OPENBSD_4_2:1.1.1.4.0.6
	OPENBSD_4_2_BASE:1.1.1.4
	OPENBSD_4_1:1.1.1.4.0.4
	OPENBSD_4_1_BASE:1.1.1.4
	OPENBSD_4_0:1.1.1.4.0.2
	OPENBSD_4_0_BASE:1.1.1.4
	PERL_5_8_8:1.1.1.4
	OPENBSD_3_9:1.1.1.3.0.6
	OPENBSD_3_9_BASE:1.1.1.3
	OPENBSD_3_8:1.1.1.3.0.4
	OPENBSD_3_8_BASE:1.1.1.3
	OPENBSD_3_7:1.1.1.3.0.2
	OPENBSD_3_7_BASE:1.1.1.3
	PERL_5_8_6:1.1.1.3
	OPENBSD_3_6:1.1.1.2.0.4
	OPENBSD_3_6_BASE:1.1.1.2
	PERL_5_8_5:1.1.1.2
	PERL_5_8_3:1.1.1.2
	OPENBSD_3_5:1.1.1.2.0.2
	OPENBSD_3_5_BASE:1.1.1.2
	PERL_5_8_2:1.1.1.2
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	PERL_5_8_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.2
date	2017.02.05.00.31.53;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2002.10.27.22.14.47;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.27.22.14.47;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.12.03.02.43.31;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2005.01.15.21.16.27;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2006.03.28.18.47.31;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2008.09.29.17.18.06;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2009.10.12.18.10.35;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2010.09.24.14.48.27;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2013.03.25.20.06.27;	author sthen;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2014.03.24.14.58.45;	author afresh1;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2014.11.17.20.52.37;	author afresh1;	state Exp;
branches;
next	1.1.1.11;
commitid	B31cAbBIXiCqnL97;

1.1.1.11
date	2017.08.14.13.45.26;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@/*    numeric.c
 *
 *    Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
 *    2002, 2003, 2004, 2005, 2006, 2007, 2008 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

/*
 * "That only makes eleven (plus one mislaid) and not fourteen,
 *  unless wizards count differently to other people."  --Beorn
 *
 *     [p.115 of _The Hobbit_: "Queer Lodgings"]
 */

/*
=head1 Numeric functions

=cut

This file contains all the stuff needed by perl for manipulating numeric
values, including such things as replacements for the OS's atof() function

*/

#include "EXTERN.h"
#define PERL_IN_NUMERIC_C
#include "perl.h"

U32
Perl_cast_ulong(NV f)
{
  if (f < 0.0)
    return f < I32_MIN ? (U32) I32_MIN : (U32)(I32) f;
  if (f < U32_MAX_P1) {
#if CASTFLAGS & 2
    if (f < U32_MAX_P1_HALF)
      return (U32) f;
    f -= U32_MAX_P1_HALF;
    return ((U32) f) | (1 + (U32_MAX >> 1));
#else
    return (U32) f;
#endif
  }
  return f > 0 ? U32_MAX : 0 /* NaN */;
}

I32
Perl_cast_i32(NV f)
{
  if (f < I32_MAX_P1)
    return f < I32_MIN ? I32_MIN : (I32) f;
  if (f < U32_MAX_P1) {
#if CASTFLAGS & 2
    if (f < U32_MAX_P1_HALF)
      return (I32)(U32) f;
    f -= U32_MAX_P1_HALF;
    return (I32)(((U32) f) | (1 + (U32_MAX >> 1)));
#else
    return (I32)(U32) f;
#endif
  }
  return f > 0 ? (I32)U32_MAX : 0 /* NaN */;
}

IV
Perl_cast_iv(NV f)
{
  if (f < IV_MAX_P1)
    return f < IV_MIN ? IV_MIN : (IV) f;
  if (f < UV_MAX_P1) {
#if CASTFLAGS & 2
    /* For future flexibility allowing for sizeof(UV) >= sizeof(IV)  */
    if (f < UV_MAX_P1_HALF)
      return (IV)(UV) f;
    f -= UV_MAX_P1_HALF;
    return (IV)(((UV) f) | (1 + (UV_MAX >> 1)));
#else
    return (IV)(UV) f;
#endif
  }
  return f > 0 ? (IV)UV_MAX : 0 /* NaN */;
}

UV
Perl_cast_uv(NV f)
{
  if (f < 0.0)
    return f < IV_MIN ? (UV) IV_MIN : (UV)(IV) f;
  if (f < UV_MAX_P1) {
#if CASTFLAGS & 2
    if (f < UV_MAX_P1_HALF)
      return (UV) f;
    f -= UV_MAX_P1_HALF;
    return ((UV) f) | (1 + (UV_MAX >> 1));
#else
    return (UV) f;
#endif
  }
  return f > 0 ? UV_MAX : 0 /* NaN */;
}

/*
=for apidoc grok_bin

converts a string representing a binary number to numeric form.

On entry C<start> and C<*len> give the string to scan, C<*flags> gives
conversion flags, and C<result> should be C<NULL> or a pointer to an NV.
The scan stops at the end of the string, or the first invalid character.
Unless C<PERL_SCAN_SILENT_ILLDIGIT> is set in C<*flags>, encountering an
invalid character will also trigger a warning.
On return C<*len> is set to the length of the scanned string,
and C<*flags> gives output flags.

If the value is <= C<UV_MAX> it is returned as a UV, the output flags are clear,
and nothing is written to C<*result>.  If the value is > C<UV_MAX>, C<grok_bin>
returns C<UV_MAX>, sets C<PERL_SCAN_GREATER_THAN_UV_MAX> in the output flags,
and writes the value to C<*result> (or the value is discarded if C<result>
is NULL).

The binary number may optionally be prefixed with C<"0b"> or C<"b"> unless
C<PERL_SCAN_DISALLOW_PREFIX> is set in C<*flags> on entry.  If
C<PERL_SCAN_ALLOW_UNDERSCORES> is set in C<*flags> then the binary
number may use C<"_"> characters to separate digits.

=cut

Not documented yet because experimental is C<PERL_SCAN_SILENT_NON_PORTABLE
which suppresses any message for non-portable numbers that are still valid
on this platform.
 */

UV
Perl_grok_bin(pTHX_ const char *start, STRLEN *len_p, I32 *flags, NV *result)
{
    const char *s = start;
    STRLEN len = *len_p;
    UV value = 0;
    NV value_nv = 0;

    const UV max_div_2 = UV_MAX / 2;
    const bool allow_underscores = cBOOL(*flags & PERL_SCAN_ALLOW_UNDERSCORES);
    bool overflowed = FALSE;
    char bit;

    PERL_ARGS_ASSERT_GROK_BIN;

    if (!(*flags & PERL_SCAN_DISALLOW_PREFIX)) {
        /* strip off leading b or 0b.
           for compatibility silently suffer "b" and "0b" as valid binary
           numbers. */
        if (len >= 1) {
            if (isALPHA_FOLD_EQ(s[0], 'b')) {
                s++;
                len--;
            }
            else if (len >= 2 && s[0] == '0' && (isALPHA_FOLD_EQ(s[1], 'b'))) {
                s+=2;
                len-=2;
            }
        }
    }

    for (; len-- && (bit = *s); s++) {
        if (bit == '0' || bit == '1') {
            /* Write it in this wonky order with a goto to attempt to get the
               compiler to make the common case integer-only loop pretty tight.
               With gcc seems to be much straighter code than old scan_bin.  */
          redo:
            if (!overflowed) {
                if (value <= max_div_2) {
                    value = (value << 1) | (bit - '0');
                    continue;
                }
                /* Bah. We're just overflowed.  */
		/* diag_listed_as: Integer overflow in %s number */
		Perl_ck_warner_d(aTHX_ packWARN(WARN_OVERFLOW),
				 "Integer overflow in binary number");
                overflowed = TRUE;
                value_nv = (NV) value;
            }
            value_nv *= 2.0;
	    /* If an NV has not enough bits in its mantissa to
	     * represent a UV this summing of small low-order numbers
	     * is a waste of time (because the NV cannot preserve
	     * the low-order bits anyway): we could just remember when
	     * did we overflow and in the end just multiply value_nv by the
	     * right amount. */
            value_nv += (NV)(bit - '0');
            continue;
        }
        if (bit == '_' && len && allow_underscores && (bit = s[1])
            && (bit == '0' || bit == '1'))
	    {
		--len;
		++s;
                goto redo;
	    }
        if (!(*flags & PERL_SCAN_SILENT_ILLDIGIT))
            Perl_ck_warner(aTHX_ packWARN(WARN_DIGIT),
			   "Illegal binary digit '%c' ignored", *s);
        break;
    }
    
    if (   ( overflowed && value_nv > 4294967295.0)
#if UVSIZE > 4
	|| (!overflowed && value > 0xffffffff
	    && ! (*flags & PERL_SCAN_SILENT_NON_PORTABLE))
#endif
	) {
	Perl_ck_warner(aTHX_ packWARN(WARN_PORTABLE),
		       "Binary number > 0b11111111111111111111111111111111 non-portable");
    }
    *len_p = s - start;
    if (!overflowed) {
        *flags = 0;
        return value;
    }
    *flags = PERL_SCAN_GREATER_THAN_UV_MAX;
    if (result)
        *result = value_nv;
    return UV_MAX;
}

/*
=for apidoc grok_hex

converts a string representing a hex number to numeric form.

On entry C<start> and C<*len_p> give the string to scan, C<*flags> gives
conversion flags, and C<result> should be C<NULL> or a pointer to an NV.
The scan stops at the end of the string, or the first invalid character.
Unless C<PERL_SCAN_SILENT_ILLDIGIT> is set in C<*flags>, encountering an
invalid character will also trigger a warning.
On return C<*len> is set to the length of the scanned string,
and C<*flags> gives output flags.

If the value is <= C<UV_MAX> it is returned as a UV, the output flags are clear,
and nothing is written to C<*result>.  If the value is > C<UV_MAX>, C<grok_hex>
returns C<UV_MAX>, sets C<PERL_SCAN_GREATER_THAN_UV_MAX> in the output flags,
and writes the value to C<*result> (or the value is discarded if C<result>
is C<NULL>).

The hex number may optionally be prefixed with C<"0x"> or C<"x"> unless
C<PERL_SCAN_DISALLOW_PREFIX> is set in C<*flags> on entry.  If
C<PERL_SCAN_ALLOW_UNDERSCORES> is set in C<*flags> then the hex
number may use C<"_"> characters to separate digits.

=cut

Not documented yet because experimental is C<PERL_SCAN_SILENT_NON_PORTABLE
which suppresses any message for non-portable numbers, but which are valid
on this platform.
 */

UV
Perl_grok_hex(pTHX_ const char *start, STRLEN *len_p, I32 *flags, NV *result)
{
    const char *s = start;
    STRLEN len = *len_p;
    UV value = 0;
    NV value_nv = 0;
    const UV max_div_16 = UV_MAX / 16;
    const bool allow_underscores = cBOOL(*flags & PERL_SCAN_ALLOW_UNDERSCORES);
    bool overflowed = FALSE;

    PERL_ARGS_ASSERT_GROK_HEX;

    if (!(*flags & PERL_SCAN_DISALLOW_PREFIX)) {
        /* strip off leading x or 0x.
           for compatibility silently suffer "x" and "0x" as valid hex numbers.
        */
        if (len >= 1) {
            if (isALPHA_FOLD_EQ(s[0], 'x')) {
                s++;
                len--;
            }
            else if (len >= 2 && s[0] == '0' && (isALPHA_FOLD_EQ(s[1], 'x'))) {
                s+=2;
                len-=2;
            }
        }
    }

    for (; len-- && *s; s++) {
        if (isXDIGIT(*s)) {
            /* Write it in this wonky order with a goto to attempt to get the
               compiler to make the common case integer-only loop pretty tight.
               With gcc seems to be much straighter code than old scan_hex.  */
          redo:
            if (!overflowed) {
                if (value <= max_div_16) {
                    value = (value << 4) | XDIGIT_VALUE(*s);
                    continue;
                }
                /* Bah. We're just overflowed.  */
		/* diag_listed_as: Integer overflow in %s number */
		Perl_ck_warner_d(aTHX_ packWARN(WARN_OVERFLOW),
				 "Integer overflow in hexadecimal number");
                overflowed = TRUE;
                value_nv = (NV) value;
            }
            value_nv *= 16.0;
	    /* If an NV has not enough bits in its mantissa to
	     * represent a UV this summing of small low-order numbers
	     * is a waste of time (because the NV cannot preserve
	     * the low-order bits anyway): we could just remember when
	     * did we overflow and in the end just multiply value_nv by the
	     * right amount of 16-tuples. */
            value_nv += (NV) XDIGIT_VALUE(*s);
            continue;
        }
        if (*s == '_' && len && allow_underscores && s[1]
		&& isXDIGIT(s[1]))
	    {
		--len;
		++s;
                goto redo;
	    }
        if (!(*flags & PERL_SCAN_SILENT_ILLDIGIT))
            Perl_ck_warner(aTHX_ packWARN(WARN_DIGIT),
                        "Illegal hexadecimal digit '%c' ignored", *s);
        break;
    }
    
    if (   ( overflowed && value_nv > 4294967295.0)
#if UVSIZE > 4
	|| (!overflowed && value > 0xffffffff
	    && ! (*flags & PERL_SCAN_SILENT_NON_PORTABLE))
#endif
	) {
	Perl_ck_warner(aTHX_ packWARN(WARN_PORTABLE),
		       "Hexadecimal number > 0xffffffff non-portable");
    }
    *len_p = s - start;
    if (!overflowed) {
        *flags = 0;
        return value;
    }
    *flags = PERL_SCAN_GREATER_THAN_UV_MAX;
    if (result)
        *result = value_nv;
    return UV_MAX;
}

/*
=for apidoc grok_oct

converts a string representing an octal number to numeric form.

On entry C<start> and C<*len> give the string to scan, C<*flags> gives
conversion flags, and C<result> should be C<NULL> or a pointer to an NV.
The scan stops at the end of the string, or the first invalid character.
Unless C<PERL_SCAN_SILENT_ILLDIGIT> is set in C<*flags>, encountering an
8 or 9 will also trigger a warning.
On return C<*len> is set to the length of the scanned string,
and C<*flags> gives output flags.

If the value is <= C<UV_MAX> it is returned as a UV, the output flags are clear,
and nothing is written to C<*result>.  If the value is > C<UV_MAX>, C<grok_oct>
returns C<UV_MAX>, sets C<PERL_SCAN_GREATER_THAN_UV_MAX> in the output flags,
and writes the value to C<*result> (or the value is discarded if C<result>
is C<NULL>).

If C<PERL_SCAN_ALLOW_UNDERSCORES> is set in C<*flags> then the octal
number may use C<"_"> characters to separate digits.

=cut

Not documented yet because experimental is C<PERL_SCAN_SILENT_NON_PORTABLE>
which suppresses any message for non-portable numbers, but which are valid
on this platform.
 */

UV
Perl_grok_oct(pTHX_ const char *start, STRLEN *len_p, I32 *flags, NV *result)
{
    const char *s = start;
    STRLEN len = *len_p;
    UV value = 0;
    NV value_nv = 0;
    const UV max_div_8 = UV_MAX / 8;
    const bool allow_underscores = cBOOL(*flags & PERL_SCAN_ALLOW_UNDERSCORES);
    bool overflowed = FALSE;

    PERL_ARGS_ASSERT_GROK_OCT;

    for (; len-- && *s; s++) {
        if (isOCTAL(*s)) {
            /* Write it in this wonky order with a goto to attempt to get the
               compiler to make the common case integer-only loop pretty tight.
            */
          redo:
            if (!overflowed) {
                if (value <= max_div_8) {
                    value = (value << 3) | OCTAL_VALUE(*s);
                    continue;
                }
                /* Bah. We're just overflowed.  */
		/* diag_listed_as: Integer overflow in %s number */
		Perl_ck_warner_d(aTHX_ packWARN(WARN_OVERFLOW),
			       "Integer overflow in octal number");
                overflowed = TRUE;
                value_nv = (NV) value;
            }
            value_nv *= 8.0;
	    /* If an NV has not enough bits in its mantissa to
	     * represent a UV this summing of small low-order numbers
	     * is a waste of time (because the NV cannot preserve
	     * the low-order bits anyway): we could just remember when
	     * did we overflow and in the end just multiply value_nv by the
	     * right amount of 8-tuples. */
            value_nv += (NV) OCTAL_VALUE(*s);
            continue;
        }
        if (*s == '_' && len && allow_underscores && isOCTAL(s[1])) {
            --len;
            ++s;
            goto redo;
        }
        /* Allow \octal to work the DWIM way (that is, stop scanning
         * as soon as non-octal characters are seen, complain only if
         * someone seems to want to use the digits eight and nine.  Since we
         * know it is not octal, then if isDIGIT, must be an 8 or 9). */
        if (isDIGIT(*s)) {
            if (!(*flags & PERL_SCAN_SILENT_ILLDIGIT))
                Perl_ck_warner(aTHX_ packWARN(WARN_DIGIT),
			       "Illegal octal digit '%c' ignored", *s);
        }
        break;
    }
    
    if (   ( overflowed && value_nv > 4294967295.0)
#if UVSIZE > 4
	|| (!overflowed && value > 0xffffffff
	    && ! (*flags & PERL_SCAN_SILENT_NON_PORTABLE))
#endif
	) {
	Perl_ck_warner(aTHX_ packWARN(WARN_PORTABLE),
		       "Octal number > 037777777777 non-portable");
    }
    *len_p = s - start;
    if (!overflowed) {
        *flags = 0;
        return value;
    }
    *flags = PERL_SCAN_GREATER_THAN_UV_MAX;
    if (result)
        *result = value_nv;
    return UV_MAX;
}

/*
=for apidoc scan_bin

For backwards compatibility.  Use C<grok_bin> instead.

=for apidoc scan_hex

For backwards compatibility.  Use C<grok_hex> instead.

=for apidoc scan_oct

For backwards compatibility.  Use C<grok_oct> instead.

=cut
 */

NV
Perl_scan_bin(pTHX_ const char *start, STRLEN len, STRLEN *retlen)
{
    NV rnv;
    I32 flags = *retlen ? PERL_SCAN_ALLOW_UNDERSCORES : 0;
    const UV ruv = grok_bin (start, &len, &flags, &rnv);

    PERL_ARGS_ASSERT_SCAN_BIN;

    *retlen = len;
    return (flags & PERL_SCAN_GREATER_THAN_UV_MAX) ? rnv : (NV)ruv;
}

NV
Perl_scan_oct(pTHX_ const char *start, STRLEN len, STRLEN *retlen)
{
    NV rnv;
    I32 flags = *retlen ? PERL_SCAN_ALLOW_UNDERSCORES : 0;
    const UV ruv = grok_oct (start, &len, &flags, &rnv);

    PERL_ARGS_ASSERT_SCAN_OCT;

    *retlen = len;
    return (flags & PERL_SCAN_GREATER_THAN_UV_MAX) ? rnv : (NV)ruv;
}

NV
Perl_scan_hex(pTHX_ const char *start, STRLEN len, STRLEN *retlen)
{
    NV rnv;
    I32 flags = *retlen ? PERL_SCAN_ALLOW_UNDERSCORES : 0;
    const UV ruv = grok_hex (start, &len, &flags, &rnv);

    PERL_ARGS_ASSERT_SCAN_HEX;

    *retlen = len;
    return (flags & PERL_SCAN_GREATER_THAN_UV_MAX) ? rnv : (NV)ruv;
}

/*
=for apidoc grok_numeric_radix

Scan and skip for a numeric decimal separator (radix).

=cut
 */
bool
Perl_grok_numeric_radix(pTHX_ const char **sp, const char *send)
{
#ifdef USE_LOCALE_NUMERIC
    PERL_ARGS_ASSERT_GROK_NUMERIC_RADIX;

    if (IN_LC(LC_NUMERIC)) {
        DECLARATION_FOR_LC_NUMERIC_MANIPULATION;
        STORE_LC_NUMERIC_SET_TO_NEEDED();
        if (PL_numeric_radix_sv) {
            STRLEN len;
            const char * const radix = SvPV(PL_numeric_radix_sv, len);
            if (*sp + len <= send && memEQ(*sp, radix, len)) {
                *sp += len;
                RESTORE_LC_NUMERIC();
                return TRUE;
            }
        }
        RESTORE_LC_NUMERIC();
    }
    /* always try "." if numeric radix didn't match because
     * we may have data from different locales mixed */
#endif

    PERL_ARGS_ASSERT_GROK_NUMERIC_RADIX;

    if (*sp < send && **sp == '.') {
        ++*sp;
        return TRUE;
    }
    return FALSE;
}

/*
=for apidoc grok_infnan

Helper for C<grok_number()>, accepts various ways of spelling "infinity"
or "not a number", and returns one of the following flag combinations:

  IS_NUMBER_INFINITE
  IS_NUMBER_NAN
  IS_NUMBER_INFINITE | IS_NUMBER_NEG
  IS_NUMBER_NAN | IS_NUMBER_NEG
  0

possibly |-ed with C<IS_NUMBER_TRAILING>.

If an infinity or a not-a-number is recognized, C<*sp> will point to
one byte past the end of the recognized string.  If the recognition fails,
zero is returned, and C<*sp> will not move.

=cut
*/

int
Perl_grok_infnan(pTHX_ const char** sp, const char* send)
{
    const char* s = *sp;
    int flags = 0;
    bool odh = FALSE; /* one-dot-hash: 1.#INF */

    PERL_ARGS_ASSERT_GROK_INFNAN;

    if (*s == '+') {
        s++; if (s == send) return 0;
    }
    else if (*s == '-') {
        flags |= IS_NUMBER_NEG; /* Yes, -NaN happens. Incorrect but happens. */
        s++; if (s == send) return 0;
    }

    if (*s == '1') {
        /* Visual C: 1.#SNAN, -1.#QNAN, 1#INF, 1.#IND (maybe also 1.#NAN)
         * Let's keep the dot optional. */
        s++; if (s == send) return 0;
        if (*s == '.') {
            s++; if (s == send) return 0;
        }
        if (*s == '#') {
            s++; if (s == send) return 0;
        } else
            return 0;
        odh = TRUE;
    }

    if (isALPHA_FOLD_EQ(*s, 'I')) {
        /* INF or IND (1.#IND is "indeterminate", a certain type of NAN) */

        s++; if (s == send || isALPHA_FOLD_NE(*s, 'N')) return 0;
        s++; if (s == send) return 0;
        if (isALPHA_FOLD_EQ(*s, 'F')) {
            s++;
            if (s < send && (isALPHA_FOLD_EQ(*s, 'I'))) {
                int fail =
                    flags | IS_NUMBER_INFINITY | IS_NUMBER_NOT_INT | IS_NUMBER_TRAILING;
                s++; if (s == send || isALPHA_FOLD_NE(*s, 'N')) return fail;
                s++; if (s == send || isALPHA_FOLD_NE(*s, 'I')) return fail;
                s++; if (s == send || isALPHA_FOLD_NE(*s, 'T')) return fail;
                s++; if (s == send || isALPHA_FOLD_NE(*s, 'Y')) return fail;
                s++;
            } else if (odh) {
                while (*s == '0') { /* 1.#INF00 */
                    s++;
                }
            }
            while (s < send && isSPACE(*s))
                s++;
            if (s < send && *s) {
                flags |= IS_NUMBER_TRAILING;
            }
            flags |= IS_NUMBER_INFINITY | IS_NUMBER_NOT_INT;
        }
        else if (isALPHA_FOLD_EQ(*s, 'D') && odh) { /* 1.#IND */
            s++;
            flags |= IS_NUMBER_NAN | IS_NUMBER_NOT_INT;
            while (*s == '0') { /* 1.#IND00 */
                s++;
            }
            if (*s) {
                flags |= IS_NUMBER_TRAILING;
            }
        } else
            return 0;
    }
    else {
        /* Maybe NAN of some sort */

        if (isALPHA_FOLD_EQ(*s, 'S') || isALPHA_FOLD_EQ(*s, 'Q')) {
            /* snan, qNaN */
            /* XXX do something with the snan/qnan difference */
            s++; if (s == send) return 0;
        }

        if (isALPHA_FOLD_EQ(*s, 'N')) {
            s++; if (s == send || isALPHA_FOLD_NE(*s, 'A')) return 0;
            s++; if (s == send || isALPHA_FOLD_NE(*s, 'N')) return 0;
            s++;

            flags |= IS_NUMBER_NAN | IS_NUMBER_NOT_INT;

            /* NaN can be followed by various stuff (NaNQ, NaNS), but
             * there are also multiple different NaN values, and some
             * implementations output the "payload" values,
             * e.g. NaN123, NAN(abc), while some legacy implementations
             * have weird stuff like NaN%. */
            if (isALPHA_FOLD_EQ(*s, 'q') ||
                isALPHA_FOLD_EQ(*s, 's')) {
                /* "nanq" or "nans" are ok, though generating
                 * these portably is tricky. */
                s++;
            }
            if (*s == '(') {
                /* C99 style "nan(123)" or Perlish equivalent "nan($uv)". */
                const char *t;
                s++;
                if (s == send) {
                    return flags | IS_NUMBER_TRAILING;
                }
                t = s + 1;
                while (t < send && *t && *t != ')') {
                    t++;
                }
                if (t == send) {
                    return flags | IS_NUMBER_TRAILING;
                }
                if (*t == ')') {
                    int nantype;
                    UV nanval;
                    if (s[0] == '0' && s + 2 < t &&
                        isALPHA_FOLD_EQ(s[1], 'x') &&
                        isXDIGIT(s[2])) {
                        STRLEN len = t - s;
                        I32 flags = PERL_SCAN_ALLOW_UNDERSCORES;
                        nanval = grok_hex(s, &len, &flags, NULL);
                        if ((flags & PERL_SCAN_GREATER_THAN_UV_MAX)) {
                            nantype = 0;
                        } else {
                            nantype = IS_NUMBER_IN_UV;
                        }
                        s += len;
                    } else if (s[0] == '0' && s + 2 < t &&
                               isALPHA_FOLD_EQ(s[1], 'b') &&
                               (s[2] == '0' || s[2] == '1')) {
                        STRLEN len = t - s;
                        I32 flags = PERL_SCAN_ALLOW_UNDERSCORES;
                        nanval = grok_bin(s, &len, &flags, NULL);
                        if ((flags & PERL_SCAN_GREATER_THAN_UV_MAX)) {
                            nantype = 0;
                        } else {
                            nantype = IS_NUMBER_IN_UV;
                        }
                        s += len;
                    } else {
                        const char *u;
                        nantype =
                            grok_number_flags(s, t - s, &nanval,
                                              PERL_SCAN_TRAILING |
                                              PERL_SCAN_ALLOW_UNDERSCORES);
                        /* Unfortunately grok_number_flags() doesn't
                         * tell how far we got and the ')' will always
                         * be "trailing", so we need to double-check
                         * whether we had something dubious. */
                        for (u = s; u < t; u++) {
                            if (!isDIGIT(*u)) {
                                flags |= IS_NUMBER_TRAILING;
                                break;
                            }
                        }
                        s = u;
                    }

                    /* XXX Doesn't do octal: nan("0123").
                     * Probably not a big loss. */

                    if ((nantype & IS_NUMBER_NOT_INT) ||
                        !(nantype && IS_NUMBER_IN_UV)) {
                        /* XXX the nanval is currently unused, that is,
                         * not inserted as the NaN payload of the NV.
                         * But the above code already parses the C99
                         * nan(...)  format.  See below, and see also
                         * the nan() in POSIX.xs.
                         *
                         * Certain configuration combinations where
                         * NVSIZE is greater than UVSIZE mean that
                         * a single UV cannot contain all the possible
                         * NaN payload bits.  There would need to be
                         * some more generic syntax than "nan($uv)".
                         *
                         * Issues to keep in mind:
                         *
                         * (1) In most common cases there would
                         * not be an integral number of bytes that
                         * could be set, only a certain number of bits.
                         * For example for the common case of
                         * NVSIZE == UVSIZE == 8 there is room for 52
                         * bits in the payload, but the most significant
                         * bit is commonly reserved for the
                         * signaling/quiet bit, leaving 51 bits.
                         * Furthermore, the C99 nan() is supposed
                         * to generate quiet NaNs, so it is doubtful
                         * whether it should be able to generate
                         * signaling NaNs.  For the x86 80-bit doubles
                         * (if building a long double Perl) there would
                         * be 62 bits (s/q bit being the 63rd).
                         *
                         * (2) Endianness of the payload bits. If the
                         * payload is specified as an UV, the low-order
                         * bits of the UV are naturally little-endianed
                         * (rightmost) bits of the payload.  The endianness
                         * of UVs and NVs can be different. */
                        return 0;
                    }
                    if (s < t) {
                        flags |= IS_NUMBER_TRAILING;
                    }
                } else {
                    /* Looked like nan(...), but no close paren. */
                    flags |= IS_NUMBER_TRAILING;
                }
            } else {
                while (s < send && isSPACE(*s))
                    s++;
                if (s < send && *s) {
                    /* Note that we here implicitly accept (parse as
                     * "nan", but with warnings) also any other weird
                     * trailing stuff for "nan".  In the above we just
                     * check that if we got the C99-style "nan(...)",
                     * the "..."  looks sane.
                     * If in future we accept more ways of specifying
                     * the nan payload, the accepting would happen around
                     * here. */
                    flags |= IS_NUMBER_TRAILING;
                }
            }
            s = send;
        }
        else
            return 0;
    }

    while (s < send && isSPACE(*s))
        s++;

    *sp = s;
    return flags;
}

/*
=for apidoc grok_number_flags

Recognise (or not) a number.  The type of the number is returned
(0 if unrecognised), otherwise it is a bit-ORed combination of
C<IS_NUMBER_IN_UV>, C<IS_NUMBER_GREATER_THAN_UV_MAX>, C<IS_NUMBER_NOT_INT>,
C<IS_NUMBER_NEG>, C<IS_NUMBER_INFINITY>, C<IS_NUMBER_NAN> (defined in perl.h).

If the value of the number can fit in a UV, it is returned in C<*valuep>.
C<IS_NUMBER_IN_UV> will be set to indicate that C<*valuep> is valid, C<IS_NUMBER_IN_UV>
will never be set unless C<*valuep> is valid, but C<*valuep> may have been assigned
to during processing even though C<IS_NUMBER_IN_UV> is not set on return.
If C<valuep> is C<NULL>, C<IS_NUMBER_IN_UV> will be set for the same cases as when
C<valuep> is non-C<NULL>, but no actual assignment (or SEGV) will occur.

C<IS_NUMBER_NOT_INT> will be set with C<IS_NUMBER_IN_UV> if trailing decimals were
seen (in which case C<*valuep> gives the true value truncated to an integer), and
C<IS_NUMBER_NEG> if the number is negative (in which case C<*valuep> holds the
absolute value).  C<IS_NUMBER_IN_UV> is not set if e notation was used or the
number is larger than a UV.

C<flags> allows only C<PERL_SCAN_TRAILING>, which allows for trailing
non-numeric text on an otherwise successful I<grok>, setting
C<IS_NUMBER_TRAILING> on the result.

=for apidoc grok_number

Identical to C<grok_number_flags()> with C<flags> set to zero.

=cut
 */
int
Perl_grok_number(pTHX_ const char *pv, STRLEN len, UV *valuep)
{
    PERL_ARGS_ASSERT_GROK_NUMBER;

    return grok_number_flags(pv, len, valuep, 0);
}

static const UV uv_max_div_10 = UV_MAX / 10;
static const U8 uv_max_mod_10 = UV_MAX % 10;

int
Perl_grok_number_flags(pTHX_ const char *pv, STRLEN len, UV *valuep, U32 flags)
{
  const char *s = pv;
  const char * const send = pv + len;
  const char *d;
  int numtype = 0;

  PERL_ARGS_ASSERT_GROK_NUMBER_FLAGS;

  while (s < send && isSPACE(*s))
    s++;
  if (s == send) {
    return 0;
  } else if (*s == '-') {
    s++;
    numtype = IS_NUMBER_NEG;
  }
  else if (*s == '+')
    s++;

  if (s == send)
    return 0;

  /* The first digit (after optional sign): note that might
   * also point to "infinity" or "nan", or "1.#INF". */
  d = s;

  /* next must be digit or the radix separator or beginning of infinity/nan */
  if (isDIGIT(*s)) {
    /* UVs are at least 32 bits, so the first 9 decimal digits cannot
       overflow.  */
    UV value = *s - '0';
    /* This construction seems to be more optimiser friendly.
       (without it gcc does the isDIGIT test and the *s - '0' separately)
       With it gcc on arm is managing 6 instructions (6 cycles) per digit.
       In theory the optimiser could deduce how far to unroll the loop
       before checking for overflow.  */
    if (++s < send) {
      int digit = *s - '0';
      if (digit >= 0 && digit <= 9) {
        value = value * 10 + digit;
        if (++s < send) {
          digit = *s - '0';
          if (digit >= 0 && digit <= 9) {
            value = value * 10 + digit;
            if (++s < send) {
              digit = *s - '0';
              if (digit >= 0 && digit <= 9) {
                value = value * 10 + digit;
		if (++s < send) {
                  digit = *s - '0';
                  if (digit >= 0 && digit <= 9) {
                    value = value * 10 + digit;
                    if (++s < send) {
                      digit = *s - '0';
                      if (digit >= 0 && digit <= 9) {
                        value = value * 10 + digit;
                        if (++s < send) {
                          digit = *s - '0';
                          if (digit >= 0 && digit <= 9) {
                            value = value * 10 + digit;
                            if (++s < send) {
                              digit = *s - '0';
                              if (digit >= 0 && digit <= 9) {
                                value = value * 10 + digit;
                                if (++s < send) {
                                  digit = *s - '0';
                                  if (digit >= 0 && digit <= 9) {
                                    value = value * 10 + digit;
                                    if (++s < send) {
                                      /* Now got 9 digits, so need to check
                                         each time for overflow.  */
                                      digit = *s - '0';
                                      while (digit >= 0 && digit <= 9
                                             && (value < uv_max_div_10
                                                 || (value == uv_max_div_10
                                                     && digit <= uv_max_mod_10))) {
                                        value = value * 10 + digit;
                                        if (++s < send)
                                          digit = *s - '0';
                                        else
                                          break;
                                      }
                                      if (digit >= 0 && digit <= 9
                                          && (s < send)) {
                                        /* value overflowed.
                                           skip the remaining digits, don't
                                           worry about setting *valuep.  */
                                        do {
                                          s++;
                                        } while (s < send && isDIGIT(*s));
                                        numtype |=
                                          IS_NUMBER_GREATER_THAN_UV_MAX;
                                        goto skip_value;
                                      }
                                    }
                                  }
				}
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
	}
      }
    }
    numtype |= IS_NUMBER_IN_UV;
    if (valuep)
      *valuep = value;

  skip_value:
    if (GROK_NUMERIC_RADIX(&s, send)) {
      numtype |= IS_NUMBER_NOT_INT;
      while (s < send && isDIGIT(*s))  /* optional digits after the radix */
        s++;
    }
  }
  else if (GROK_NUMERIC_RADIX(&s, send)) {
    numtype |= IS_NUMBER_NOT_INT | IS_NUMBER_IN_UV; /* valuep assigned below */
    /* no digits before the radix means we need digits after it */
    if (s < send && isDIGIT(*s)) {
      do {
        s++;
      } while (s < send && isDIGIT(*s));
      if (valuep) {
        /* integer approximation is valid - it's 0.  */
        *valuep = 0;
      }
    }
    else
        return 0;
  }

  if (s > d && s < send) {
    /* we can have an optional exponent part */
    if (isALPHA_FOLD_EQ(*s, 'e')) {
      s++;
      if (s < send && (*s == '-' || *s == '+'))
        s++;
      if (s < send && isDIGIT(*s)) {
        do {
          s++;
        } while (s < send && isDIGIT(*s));
      }
      else if (flags & PERL_SCAN_TRAILING)
        return numtype | IS_NUMBER_TRAILING;
      else
        return 0;

      /* The only flag we keep is sign.  Blow away any "it's UV"  */
      numtype &= IS_NUMBER_NEG;
      numtype |= IS_NUMBER_NOT_INT;
    }
  }
  while (s < send && isSPACE(*s))
    s++;
  if (s >= send)
    return numtype;
  if (len == 10 && memEQ(pv, "0 but true", 10)) {
    if (valuep)
      *valuep = 0;
    return IS_NUMBER_IN_UV;
  }
  /* We could be e.g. at "Inf" or "NaN", or at the "#" of "1.#INF". */
  if ((s + 2 < send) && strchr("inqs#", toFOLD(*s))) {
      /* Really detect inf/nan. Start at d, not s, since the above
       * code might have already consumed the "1." or "1". */
      int infnan = Perl_grok_infnan(aTHX_ &d, send);
      if ((infnan & IS_NUMBER_INFINITY)) {
          return (numtype | infnan); /* Keep sign for infinity. */
      }
      else if ((infnan & IS_NUMBER_NAN)) {
          return (numtype | infnan) & ~IS_NUMBER_NEG; /* Clear sign for nan. */
      }
  }
  else if (flags & PERL_SCAN_TRAILING) {
    return numtype | IS_NUMBER_TRAILING;
  }

  return 0;
}

/*
grok_atoUV

grok_atoUV parses a C-style zero-byte terminated string, looking for
a decimal unsigned integer.

Returns the unsigned integer, if a valid value can be parsed
from the beginning of the string.

Accepts only the decimal digits '0'..'9'.

As opposed to atoi or strtol, grok_atoUV does NOT allow optional
leading whitespace, or negative inputs.  If such features are
required, the calling code needs to explicitly implement those.

Returns true if a valid value could be parsed. In that case, valptr
is set to the parsed value, and endptr (if provided) is set to point
to the character after the last digit.

Returns false otherwise. This can happen if a) there is a leading zero
followed by another digit; b) the digits would overflow a UV; or c)
there are trailing non-digits AND endptr is not provided.

Background: atoi has severe problems with illegal inputs, it cannot be
used for incremental parsing, and therefore should be avoided
atoi and strtol are also affected by locale settings, which can also be
seen as a bug (global state controlled by user environment).

*/

bool
Perl_grok_atoUV(const char *pv, UV *valptr, const char** endptr)
{
    const char* s = pv;
    const char** eptr;
    const char* end2; /* Used in case endptr is NULL. */
    UV val = 0; /* The parsed value. */

    PERL_ARGS_ASSERT_GROK_ATOUV;

    eptr = endptr ? endptr : &end2;
    if (isDIGIT(*s)) {
        /* Single-digit inputs are quite common. */
        val = *s++ - '0';
        if (isDIGIT(*s)) {
            /* Fail on extra leading zeros. */
            if (val == 0)
                return FALSE;
            while (isDIGIT(*s)) {
                /* This could be unrolled like in grok_number(), but
                 * the expected uses of this are not speed-needy, and
                 * unlikely to need full 64-bitness. */
                U8 digit = *s++ - '0';
                if (val < uv_max_div_10 ||
                    (val == uv_max_div_10 && digit <= uv_max_mod_10)) {
                    val = val * 10 + digit;
                } else {
                    return FALSE;
                }
            }
        }
    }
    if (s == pv)
        return FALSE;
    if (endptr == NULL && *s)
        return FALSE; /* If endptr is NULL, no trailing non-digits allowed. */
    *eptr = s;
    *valptr = val;
    return TRUE;
}

#ifndef USE_QUADMATH
STATIC NV
S_mulexp10(NV value, I32 exponent)
{
    NV result = 1.0;
    NV power = 10.0;
    bool negative = 0;
    I32 bit;

    if (exponent == 0)
	return value;
    if (value == 0)
	return (NV)0;

    /* On OpenVMS VAX we by default use the D_FLOAT double format,
     * and that format does not have *easy* capabilities [1] for
     * overflowing doubles 'silently' as IEEE fp does.  We also need 
     * to support G_FLOAT on both VAX and Alpha, and though the exponent 
     * range is much larger than D_FLOAT it still doesn't do silent 
     * overflow.  Therefore we need to detect early whether we would 
     * overflow (this is the behaviour of the native string-to-float 
     * conversion routines, and therefore of native applications, too).
     *
     * [1] Trying to establish a condition handler to trap floating point
     *     exceptions is not a good idea. */

    /* In UNICOS and in certain Cray models (such as T90) there is no
     * IEEE fp, and no way at all from C to catch fp overflows gracefully.
     * There is something you can do if you are willing to use some
     * inline assembler: the instruction is called DFI-- but that will
     * disable *all* floating point interrupts, a little bit too large
     * a hammer.  Therefore we need to catch potential overflows before
     * it's too late. */

#if ((defined(VMS) && !defined(_IEEE_FP)) || defined(_UNICOS)) && defined(NV_MAX_10_EXP)
    STMT_START {
	const NV exp_v = log10(value);
	if (exponent >= NV_MAX_10_EXP || exponent + exp_v >= NV_MAX_10_EXP)
	    return NV_MAX;
	if (exponent < 0) {
	    if (-(exponent + exp_v) >= NV_MAX_10_EXP)
		return 0.0;
	    while (-exponent >= NV_MAX_10_EXP) {
		/* combination does not overflow, but 10^(-exponent) does */
		value /= 10;
		++exponent;
	    }
	}
    } STMT_END;
#endif

    if (exponent < 0) {
	negative = 1;
	exponent = -exponent;
#ifdef NV_MAX_10_EXP
        /* for something like 1234 x 10^-309, the action of calculating
         * the intermediate value 10^309 then returning 1234 / (10^309)
         * will fail, since 10^309 becomes infinity. In this case try to
         * refactor it as 123 / (10^308) etc.
         */
        while (value && exponent > NV_MAX_10_EXP) {
            exponent--;
            value /= 10;
        }
        if (value == 0.0)
            return value;
#endif
    }
#if defined(__osf__)
    /* Even with cc -ieee + ieee_set_fp_control(IEEE_TRAP_ENABLE_INV)
     * Tru64 fp behavior on inf/nan is somewhat broken. Another way
     * to do this would be ieee_set_fp_control(IEEE_TRAP_ENABLE_OVF)
     * but that breaks another set of infnan.t tests. */
#  define FP_OVERFLOWS_TO_ZERO
#endif
    for (bit = 1; exponent; bit <<= 1) {
	if (exponent & bit) {
	    exponent ^= bit;
	    result *= power;
#ifdef FP_OVERFLOWS_TO_ZERO
            if (result == 0)
                return value < 0 ? -NV_INF : NV_INF;
#endif
	    /* Floating point exceptions are supposed to be turned off,
	     *  but if we're obviously done, don't risk another iteration.  
	     */
	     if (exponent == 0) break;
	}
	power *= power;
    }
    return negative ? value / result : value * result;
}
#endif /* #ifndef USE_QUADMATH */

NV
Perl_my_atof(pTHX_ const char* s)
{
    NV x = 0.0;
#ifdef USE_QUADMATH
    Perl_my_atof2(aTHX_ s, &x);
    return x;
#else
#  ifdef USE_LOCALE_NUMERIC
    PERL_ARGS_ASSERT_MY_ATOF;

    {
        DECLARATION_FOR_LC_NUMERIC_MANIPULATION;
        STORE_LC_NUMERIC_SET_TO_NEEDED();
        if (PL_numeric_radix_sv && IN_LC(LC_NUMERIC)) {
            const char *standard = NULL, *local = NULL;
            bool use_standard_radix;

            /* Look through the string for the first thing that looks like a
             * decimal point: either the value in the current locale or the
             * standard fallback of '.'. The one which appears earliest in the
             * input string is the one that we should have atof look for. Note
             * that we have to determine this beforehand because on some
             * systems, Perl_atof2 is just a wrapper around the system's atof.
             * */
            standard = strchr(s, '.');
            local = strstr(s, SvPV_nolen(PL_numeric_radix_sv));

            use_standard_radix = standard && (!local || standard < local);

            if (use_standard_radix)
                SET_NUMERIC_STANDARD();

            Perl_atof2(s, x);

            if (use_standard_radix)
                SET_NUMERIC_UNDERLYING();
        }
        else
            Perl_atof2(s, x);
        RESTORE_LC_NUMERIC();
    }
#  else
    Perl_atof2(s, x);
#  endif
#endif
    return x;
}


#ifdef USING_MSVC6
#  pragma warning(push)
#  pragma warning(disable:4756;disable:4056)
#endif
static char*
S_my_atof_infnan(pTHX_ const char* s, bool negative, const char* send, NV* value)
{
    const char *p0 = negative ? s - 1 : s;
    const char *p = p0;
    int infnan = grok_infnan(&p, send);
    if (infnan && p != p0) {
        /* If we can generate inf/nan directly, let's do so. */
#ifdef NV_INF
        if ((infnan & IS_NUMBER_INFINITY)) {
            *value = (infnan & IS_NUMBER_NEG) ? -NV_INF: NV_INF;
            return (char*)p;
        }
#endif
#ifdef NV_NAN
        if ((infnan & IS_NUMBER_NAN)) {
            *value = NV_NAN;
            return (char*)p;
        }
#endif
#ifdef Perl_strtod
        /* If still here, we didn't have either NV_INF or NV_NAN,
         * and can try falling back to native strtod/strtold.
         *
         * (Though, are our NV_INF or NV_NAN ever not defined?)
         *
         * The native interface might not recognize all the possible
         * inf/nan strings Perl recognizes.  What we can try
         * is to try faking the input.  We will try inf/-inf/nan
         * as the most promising/portable input. */
        {
            const char* fake = NULL;
            char* endp;
            NV nv;
            if ((infnan & IS_NUMBER_INFINITY)) {
                fake = ((infnan & IS_NUMBER_NEG)) ? "-inf" : "inf";
            }
            else if ((infnan & IS_NUMBER_NAN)) {
                fake = "nan";
            }
            assert(fake);
            nv = Perl_strtod(fake, &endp);
            if (fake != endp) {
                if ((infnan & IS_NUMBER_INFINITY)) {
#ifdef Perl_isinf
                    if (Perl_isinf(nv))
                        *value = nv;
#else
                    /* last resort, may generate SIGFPE */
                    *value = Perl_exp((NV)1e9);
                    if ((infnan & IS_NUMBER_NEG))
                        *value = -*value;
#endif
                    return (char*)p; /* p, not endp */
                }
                else if ((infnan & IS_NUMBER_NAN)) {
#ifdef Perl_isnan
                    if (Perl_isnan(nv))
                        *value = nv;
#else
                    /* last resort, may generate SIGFPE */
                    *value = Perl_log((NV)-1.0);
#endif
                    return (char*)p; /* p, not endp */
                }
            }
        }
#endif /* #ifdef Perl_strtod */
    }
    return NULL;
}
#ifdef USING_MSVC6
#  pragma warning(pop)
#endif

char*
Perl_my_atof2(pTHX_ const char* orig, NV* value)
{
    const char* s = orig;
    NV result[3] = {0.0, 0.0, 0.0};
#if defined(USE_PERL_ATOF) || defined(USE_QUADMATH)
    const char* send = s + strlen(orig); /* one past the last */
    bool negative = 0;
#endif
#if defined(USE_PERL_ATOF) && !defined(USE_QUADMATH)
    UV accumulator[2] = {0,0};	/* before/after dp */
    bool seen_digit = 0;
    I32 exp_adjust[2] = {0,0};
    I32 exp_acc[2] = {-1, -1};
    /* the current exponent adjust for the accumulators */
    I32 exponent = 0;
    I32	seen_dp  = 0;
    I32 digit = 0;
    I32 old_digit = 0;
    I32 sig_digits = 0; /* noof significant digits seen so far */
#endif

#if defined(USE_PERL_ATOF) || defined(USE_QUADMATH)
    PERL_ARGS_ASSERT_MY_ATOF2;

    /* leading whitespace */
    while (isSPACE(*s))
	++s;

    /* sign */
    switch (*s) {
	case '-':
	    negative = 1;
	    /* FALLTHROUGH */
	case '+':
	    ++s;
    }
#endif

#ifdef USE_QUADMATH
    {
        char* endp;
        if ((endp = S_my_atof_infnan(aTHX_ s, negative, send, value)))
            return endp;
        result[2] = strtoflt128(s, &endp);
        if (s != endp) {
            *value = negative ? -result[2] : result[2];
            return endp;
        }
        return NULL;
    }
#elif defined(USE_PERL_ATOF)

/* There is no point in processing more significant digits
 * than the NV can hold. Note that NV_DIG is a lower-bound value,
 * while we need an upper-bound value. We add 2 to account for this;
 * since it will have been conservative on both the first and last digit.
 * For example a 32-bit mantissa with an exponent of 4 would have
 * exact values in the set
 *               4
 *               8
 *              ..
 *     17179869172
 *     17179869176
 *     17179869180
 *
 * where for the purposes of calculating NV_DIG we would have to discount
 * both the first and last digit, since neither can hold all values from
 * 0..9; but for calculating the value we must examine those two digits.
 */
#ifdef MAX_SIG_DIG_PLUS
    /* It is not necessarily the case that adding 2 to NV_DIG gets all the
       possible digits in a NV, especially if NVs are not IEEE compliant
       (e.g., long doubles on IRIX) - Allen <allens@@cpan.org> */
# define MAX_SIG_DIGITS (NV_DIG+MAX_SIG_DIG_PLUS)
#else
# define MAX_SIG_DIGITS (NV_DIG+2)
#endif

/* the max number we can accumulate in a UV, and still safely do 10*N+9 */
#define MAX_ACCUMULATE ( (UV) ((UV_MAX - 9)/10))

    {
        const char* endp;
        if ((endp = S_my_atof_infnan(aTHX_ s, negative, send, value)))
            return (char*)endp;
    }

    /* we accumulate digits into an integer; when this becomes too
     * large, we add the total to NV and start again */

    while (1) {
	if (isDIGIT(*s)) {
	    seen_digit = 1;
	    old_digit = digit;
	    digit = *s++ - '0';
	    if (seen_dp)
		exp_adjust[1]++;

	    /* don't start counting until we see the first significant
	     * digit, eg the 5 in 0.00005... */
	    if (!sig_digits && digit == 0)
		continue;

	    if (++sig_digits > MAX_SIG_DIGITS) {
		/* limits of precision reached */
	        if (digit > 5) {
		    ++accumulator[seen_dp];
		} else if (digit == 5) {
		    if (old_digit % 2) { /* round to even - Allen */
			++accumulator[seen_dp];
		    }
		}
		if (seen_dp) {
		    exp_adjust[1]--;
		} else {
		    exp_adjust[0]++;
		}
		/* skip remaining digits */
		while (isDIGIT(*s)) {
		    ++s;
		    if (! seen_dp) {
			exp_adjust[0]++;
		    }
		}
		/* warn of loss of precision? */
	    }
	    else {
		if (accumulator[seen_dp] > MAX_ACCUMULATE) {
		    /* add accumulator to result and start again */
		    result[seen_dp] = S_mulexp10(result[seen_dp],
						 exp_acc[seen_dp])
			+ (NV)accumulator[seen_dp];
		    accumulator[seen_dp] = 0;
		    exp_acc[seen_dp] = 0;
		}
		accumulator[seen_dp] = accumulator[seen_dp] * 10 + digit;
		++exp_acc[seen_dp];
	    }
	}
	else if (!seen_dp && GROK_NUMERIC_RADIX(&s, send)) {
	    seen_dp = 1;
	    if (sig_digits > MAX_SIG_DIGITS) {
		do {
		    ++s;
		} while (isDIGIT(*s));
		break;
	    }
	}
	else {
	    break;
	}
    }

    result[0] = S_mulexp10(result[0], exp_acc[0]) + (NV)accumulator[0];
    if (seen_dp) {
	result[1] = S_mulexp10(result[1], exp_acc[1]) + (NV)accumulator[1];
    }

    if (seen_digit && (isALPHA_FOLD_EQ(*s, 'e'))) {
	bool expnegative = 0;

	++s;
	switch (*s) {
	    case '-':
		expnegative = 1;
		/* FALLTHROUGH */
	    case '+':
		++s;
	}
	while (isDIGIT(*s))
	    exponent = exponent * 10 + (*s++ - '0');
	if (expnegative)
	    exponent = -exponent;
    }



    /* now apply the exponent */

    if (seen_dp) {
	result[2] = S_mulexp10(result[0],exponent+exp_adjust[0])
		+ S_mulexp10(result[1],exponent-exp_adjust[1]);
    } else {
	result[2] = S_mulexp10(result[0],exponent+exp_adjust[0]);
    }

    /* now apply the sign */
    if (negative)
	result[2] = -result[2];
#endif /* USE_PERL_ATOF */
    *value = result[2];
    return (char *)s;
}

/*
=for apidoc isinfnan

C<Perl_isinfnan()> is utility function that returns true if the NV
argument is either an infinity or a C<NaN>, false otherwise.  To test
in more detail, use C<Perl_isinf()> and C<Perl_isnan()>.

This is also the logical inverse of Perl_isfinite().

=cut
*/
bool
Perl_isinfnan(NV nv)
{
#ifdef Perl_isinf
    if (Perl_isinf(nv))
        return TRUE;
#endif
#ifdef Perl_isnan
    if (Perl_isnan(nv))
        return TRUE;
#endif
    return FALSE;
}

/*
=for apidoc

Checks whether the argument would be either an infinity or C<NaN> when used
as a number, but is careful not to trigger non-numeric or uninitialized
warnings.  it assumes the caller has done C<SvGETMAGIC(sv)> already.

=cut
*/

bool
Perl_isinfnansv(pTHX_ SV *sv)
{
    PERL_ARGS_ASSERT_ISINFNANSV;
    if (!SvOK(sv))
        return FALSE;
    if (SvNOKp(sv))
        return Perl_isinfnan(SvNVX(sv));
    if (SvIOKp(sv))
        return FALSE;
    {
        STRLEN len;
        const char *s = SvPV_nomg_const(sv, len);
        return cBOOL(grok_infnan(&s, s+len));
    }
}

#ifndef HAS_MODFL
/* C99 has truncl, pre-C99 Solaris had aintl.  We can use either with
 * copysignl to emulate modfl, which is in some platforms missing or
 * broken. */
#  if defined(HAS_TRUNCL) && defined(HAS_COPYSIGNL)
long double
Perl_my_modfl(long double x, long double *ip)
{
    *ip = truncl(x);
    return (x == *ip ? copysignl(0.0L, x) : x - *ip);
}
#  elif defined(HAS_AINTL) && defined(HAS_COPYSIGNL)
long double
Perl_my_modfl(long double x, long double *ip)
{
    *ip = aintl(x);
    return (x == *ip ? copysignl(0.0L, x) : x - *ip);
}
#  endif
#endif

/* Similarly, with ilogbl and scalbnl we can emulate frexpl. */
#if ! defined(HAS_FREXPL) && defined(HAS_ILOGBL) && defined(HAS_SCALBNL)
long double
Perl_my_frexpl(long double x, int *e) {
    *e = x == 0.0L ? 0 : ilogbl(x) + 1;
    return (scalbnl(x, -*e));
}
#endif

/*
=for apidoc Perl_signbit

Return a non-zero integer if the sign bit on an NV is set, and 0 if
it is not.  

If F<Configure> detects this system has a C<signbit()> that will work with
our NVs, then we just use it via the C<#define> in F<perl.h>.  Otherwise,
fall back on this implementation.  The main use of this function
is catching C<-0.0>.

C<Configure> notes:  This function is called C<'Perl_signbit'> instead of a
plain C<'signbit'> because it is easy to imagine a system having a C<signbit()>
function or macro that doesn't happen to work with our particular choice
of NVs.  We shouldn't just re-C<#define> C<signbit> as C<Perl_signbit> and expect
the standard system headers to be happy.  Also, this is a no-context
function (no C<pTHX_>) because C<Perl_signbit()> is usually re-C<#defined> in
F<perl.h> as a simple macro call to the system's C<signbit()>.
Users should just always call C<Perl_signbit()>.

=cut
*/
#if !defined(HAS_SIGNBIT)
int
Perl_signbit(NV x) {
#  ifdef Perl_fp_class_nzero
    return Perl_fp_class_nzero(x);
    /* Try finding the high byte, and assume it's highest bit
     * is the sign.  This assumption is probably wrong somewhere. */
#  elif defined(USE_LONG_DOUBLE) && LONG_DOUBLEKIND == LONG_DOUBLE_IS_X86_80_BIT_LITTLE_ENDIAN
    return (((unsigned char *)&x)[9] & 0x80);
#  elif defined(NV_LITTLE_ENDIAN)
    /* Note that NVSIZE is sizeof(NV), which would make the below be
     * wrong if the end bytes are unused, which happens with the x86
     * 80-bit long doubles, which is why take care of that above. */
    return (((unsigned char *)&x)[NVSIZE - 1] & 0x80);
#  elif defined(NV_BIG_ENDIAN)
    return (((unsigned char *)&x)[0] & 0x80);
#  else
    /* This last resort fallback is wrong for the negative zero. */
    return (x < 0.0) ? 1 : 0;
#  endif
}
#endif

/*
 * ex: set ts=8 sts=4 sw=4 et:
 */
@


1.1
log
@Initial revision
@
text
@d3 2
a4 1
 *    Copyright (c) 2001-2002, Larry Wall
d12 4
a15 2
 * "That only makes eleven (plus one mislaid) and not fourteen, unless
 * wizards count differently to other people."
d20 6
d33 1
a33 1
Perl_cast_ulong(pTHX_ NV f)
d42 1
a42 1
    return ((U32) f) | (1 + U32_MAX >> 1);
d51 1
a51 1
Perl_cast_i32(pTHX_ NV f)
d60 1
a60 1
    return (I32)(((U32) f) | (1 + U32_MAX >> 1));
d69 1
a69 1
Perl_cast_iv(pTHX_ NV f)
d79 1
a79 1
    return (IV)(((UV) f) | (1 + UV_MAX >> 1));
d88 1
a88 1
Perl_cast_uv(pTHX_ NV f)
d97 1
a97 1
    return ((UV) f) | (1 + UV_MAX >> 1);
a104 16
#if defined(HUGE_VAL) || (defined(USE_LONG_DOUBLE) && defined(HUGE_VALL))
/*
 * This hack is to force load of "huge" support from libm.a
 * So it is in perl for (say) POSIX to use.
 * Needed for SunOS with Sun's 'acc' for example.
 */
NV
Perl_huge(void)
{
#   if defined(USE_LONG_DOUBLE) && defined(HUGE_VALL)
    return HUGE_VALL;
#   endif
    return HUGE_VAL;
}
#endif

d110 2
a111 2
On entry I<start> and I<*len> give the string to scan, I<*flags> gives
conversion flags, and I<result> should be NULL or a pointer to an NV.
d113 9
a121 7
On return I<*len> is set to the length scanned string, and I<*flags> gives
output flags.

If the value is <= UV_MAX it is returned as a UV, the output flags are clear,
and nothing is written to I<*result>. If the value is > UV_MAX C<grok_bin>
returns UV_MAX, sets C<PERL_SCAN_GREATER_THAN_UV_MAX> in the output flags,
and writes the value to I<*result> (or the value is discarded if I<result>
d124 4
a127 4
The hex number may optionally be prefixed with "0b" or "b" unless
C<PERL_SCAN_DISALLOW_PREFIX> is set in I<*flags> on entry. If
C<PERL_SCAN_ALLOW_UNDERSCORES> is set in I<*flags> then the binary
number may use '_' characters to separate digits.
d130 4
d137 2
a138 1
Perl_grok_bin(pTHX_ char *start, STRLEN *len_p, I32 *flags, NV *result) {
d145 1
a145 1
    bool allow_underscores = *flags & PERL_SCAN_ALLOW_UNDERSCORES;
d147 3
d156 1
a156 1
            if (s[0] == 'b') {
d160 1
a160 1
            else if (len >= 2 && s[0] == '0' && s[1] == 'b') {
d167 1
a167 2
    for (; len-- && *s; s++) {
        char bit = *s;
d179 3
a181 3
                if (ckWARN_d(WARN_OVERFLOW))
                    Perl_warner(aTHX_ packWARN(WARN_OVERFLOW),
                                "Integer overflow in binary number");
d202 3
a204 3
        if (ckWARN(WARN_DIGIT))
            Perl_warner(aTHX_ packWARN(WARN_DIGIT),
                        "Illegal binary digit '%c' ignored", *s);
d210 2
a211 1
	|| (!overflowed && value > 0xffffffff  )
d214 2
a215 3
	if (ckWARN(WARN_PORTABLE))
	    Perl_warner(aTHX_ packWARN(WARN_PORTABLE),
			"Binary number > 0b11111111111111111111111111111111 non-portable");
d233 18
a250 11
On entry I<start> and I<*len> give the string to scan, I<*flags> gives
conversion flags, and I<result> should be NULL or a pointer to an NV.
The scan stops at the end of the string, or the first non-hex-digit character.
On return I<*len> is set to the length scanned string, and I<*flags> gives
output flags.

If the value is <= UV_MAX it is returned as a UV, the output flags are clear,
and nothing is written to I<*result>. If the value is > UV_MAX C<grok_hex>
returns UV_MAX, sets C<PERL_SCAN_GREATER_THAN_UV_MAX> in the output flags,
and writes the value to I<*result> (or the value is discarded if I<result>
is NULL).
d252 1
a252 4
The hex number may optionally be prefixed with "0x" or "x" unless
C<PERL_SCAN_DISALLOW_PREFIX> is set in I<*flags> on entry. If
C<PERL_SCAN_ALLOW_UNDERSCORES> is set in I<*flags> then the hex
number may use '_' characters to separate digits.
d254 3
a256 1
=cut
d260 2
a261 1
Perl_grok_hex(pTHX_ char *start, STRLEN *len_p, I32 *flags, NV *result) {
a265 1

d267 1
a267 1
    bool allow_underscores = *flags & PERL_SCAN_ALLOW_UNDERSCORES;
d269 2
a270 1
    const char *hexdigit;
d277 1
a277 1
            if (s[0] == 'x') {
d281 1
a281 1
            else if (len >= 2 && s[0] == '0' && s[1] == 'x') {
d289 1
a289 2
	hexdigit = strchr((char *) PL_hexdigit, *s);
        if (hexdigit) {
d296 1
a296 1
                    value = (value << 4) | ((hexdigit - PL_hexdigit) & 15);
d300 3
a302 3
                if (ckWARN_d(WARN_OVERFLOW))
                    Perl_warner(aTHX_ packWARN(WARN_OVERFLOW),
                                "Integer overflow in hexadecimal number");
d313 1
a313 1
            value_nv += (NV)((hexdigit - PL_hexdigit) & 15);
d317 1
a317 1
		&& (hexdigit = strchr((char *) PL_hexdigit, s[1])))
d323 2
a324 2
        if (ckWARN(WARN_DIGIT))
            Perl_warner(aTHX_ packWARN(WARN_DIGIT),
d331 2
a332 1
	|| (!overflowed && value > 0xffffffff  )
d335 2
a336 3
	if (ckWARN(WARN_PORTABLE))
	    Perl_warner(aTHX_ packWARN(WARN_PORTABLE),
			"Hexadecimal number > 0xffffffff non-portable");
d352 18
d372 4
d379 2
a380 1
Perl_grok_oct(pTHX_ char *start, STRLEN *len_p, I32 *flags, NV *result) {
a384 1

d386 1
a386 1
    bool allow_underscores = *flags & PERL_SCAN_ALLOW_UNDERSCORES;
d389 2
d392 1
a392 4
         /* gcc 2.95 optimiser not smart enough to figure that this subtraction
            out front allows slicker code.  */
        int digit = *s - '0';
        if (digit >= 0 && digit <= 7) {
d399 1
a399 1
                    value = (value << 3) | digit;
d403 3
a405 3
                if (ckWARN_d(WARN_OVERFLOW))
                    Perl_warner(aTHX_ packWARN(WARN_OVERFLOW),
                                "Integer overflow in octal number");
d416 1
a416 1
            value_nv += (NV)digit;
d419 5
a423 7
        if (digit == ('_' - '0') && len && allow_underscores
            && (digit = s[1] - '0') && (digit >= 0 && digit <= 7))
	    {
		--len;
		++s;
                goto redo;
	    }
d425 7
a431 6
         * as soon as non-octal characters are seen, complain only iff
         * someone seems to want to use the digits eight and nine). */
        if (digit == 8 || digit == 9) {
            if (ckWARN(WARN_DIGIT))
                Perl_warner(aTHX_ packWARN(WARN_DIGIT),
                            "Illegal octal digit '%c' ignored", *s);
d438 2
a439 1
	|| (!overflowed && value > 0xffffffff  )
d442 2
a443 3
	if (ckWARN(WARN_PORTABLE))
	    Perl_warner(aTHX_ packWARN(WARN_PORTABLE),
			"Octal number > 037777777777 non-portable");
d459 1
a459 1
For backwards compatibility. Use C<grok_bin> instead.
d463 1
a463 1
For backwards compatibility. Use C<grok_hex> instead.
d467 1
a467 1
For backwards compatibility. Use C<grok_oct> instead.
d473 1
a473 1
Perl_scan_bin(pTHX_ char *start, STRLEN len, STRLEN *retlen)
d477 3
a479 1
    UV ruv = grok_bin (start, &len, &flags, &rnv);
d486 1
a486 1
Perl_scan_oct(pTHX_ char *start, STRLEN len, STRLEN *retlen)
d490 3
a492 1
    UV ruv = grok_oct (start, &len, &flags, &rnv);
d499 1
a499 1
Perl_scan_hex(pTHX_ char *start, STRLEN len, STRLEN *retlen)
d503 3
a505 1
    UV ruv = grok_hex (start, &len, &flags, &rnv);
d522 13
a534 6
    if (PL_numeric_radix_sv && IN_LOCALE) { 
        STRLEN len;
        char* radix = SvPV(PL_numeric_radix_sv, len);
        if (*sp + len <= send && memEQ(*sp, radix, len)) {
            *sp += len;
            return TRUE; 
d536 1
d541 3
d552 255
a806 1
=for apidoc grok_number
d810 2
a811 2
IS_NUMBER_IN_UV, IS_NUMBER_GREATER_THAN_UV_MAX, IS_NUMBER_NOT_INT,
IS_NUMBER_NEG, IS_NUMBER_INFINITY, IS_NUMBER_NAN (defined in perl.h).
d813 11
a823 11
If the value of the number can fit an in UV, it is returned in the *valuep
IS_NUMBER_IN_UV will be set to indicate that *valuep is valid, IS_NUMBER_IN_UV
will never be set unless *valuep is valid, but *valuep may have been assigned
to during processing even though IS_NUMBER_IN_UV is not set on return.
If valuep is NULL, IS_NUMBER_IN_UV will be set for the same cases as when
valuep is non-NULL, but no actual assignment (or SEGV) will occur.

IS_NUMBER_NOT_INT will be set with IS_NUMBER_IN_UV if trailing decimals were
seen (in which case *valuep gives the true value truncated to an integer), and
IS_NUMBER_NEG if the number is negative (in which case *valuep holds the
absolute value).  IS_NUMBER_IN_UV is not set if e notation was used or the
d826 8
d839 11
d851 2
a852 3
  const char *send = pv + len;
  const UV max_div_10 = UV_MAX / 10;
  const char max_mod_10 = UV_MAX % 10;
d854 2
a855 2
  int sawinf = 0;
  int sawnan = 0;
d866 1
a866 1
  s++;
d871 5
a875 1
  /* next must be digit or the radix separator or beginning of infinity */
d922 3
a924 3
                                             && (value < max_div_10
                                                 || (value == max_div_10
                                                     && digit <= max_mod_10))) {
d984 2
a985 20
      return 0;
  } else if (*s == 'I' || *s == 'i') {
    s++; if (s == send || (*s != 'N' && *s != 'n')) return 0;
    s++; if (s == send || (*s != 'F' && *s != 'f')) return 0;
    s++; if (s < send && (*s == 'I' || *s == 'i')) {
      s++; if (s == send || (*s != 'N' && *s != 'n')) return 0;
      s++; if (s == send || (*s != 'I' && *s != 'i')) return 0;
      s++; if (s == send || (*s != 'T' && *s != 't')) return 0;
      s++; if (s == send || (*s != 'Y' && *s != 'y')) return 0;
      s++;
    }
    sawinf = 1;
  } else if (*s == 'N' || *s == 'n') {
    /* XXX TODO: There are signaling NaNs and quiet NaNs. */
    s++; if (s == send || (*s != 'A' && *s != 'a')) return 0;
    s++; if (s == send || (*s != 'N' && *s != 'n')) return 0;
    s++;
    sawnan = 1;
  } else
    return 0;
d987 1
a987 7
  if (sawinf) {
    numtype &= IS_NUMBER_NEG; /* Keep track of sign  */
    numtype |= IS_NUMBER_INFINITY | IS_NUMBER_NOT_INT;
  } else if (sawnan) {
    numtype &= IS_NUMBER_NEG; /* Keep track of sign  */
    numtype |= IS_NUMBER_NAN | IS_NUMBER_NOT_INT;
  } else if (s < send) {
d989 1
a989 4
    if (*s == 'e' || *s == 'E') {
      /* The only flag we keep is sign.  Blow away any "it's UV"  */
      numtype &= IS_NUMBER_NEG;
      numtype |= IS_NUMBER_NOT_INT;
d998 2
d1001 5
a1005 1
      return 0;
d1017 16
d1036 73
a1108 1
NV
d1118 2
d1141 1
a1141 1
#if ((defined(VMS) && !defined(__IEEE_FP)) || defined(_UNICOS)) && defined(NV_MAX_10_EXP)
d1143 1
a1143 1
	NV exp_v = log10(value);
d1161 13
d1175 7
d1186 4
d1199 1
d1205 30
a1234 3
#ifdef USE_LOCALE_NUMERIC
    if (PL_numeric_local && IN_LOCALE) {
	NV y;
d1236 6
a1241 8
	/* Scan the number twice; once using locale and once without;
	 * choose the larger result (in absolute value). */
	Perl_atof2(s, x);
	SET_NUMERIC_STANDARD();
	Perl_atof2(s, y);
	SET_NUMERIC_LOCAL();
	if ((y < 0.0 && y < x) || (y > 0.0 && y > x))
	    return y;
d1243 1
a1243 3
    else
	Perl_atof2(s, x);
#else
d1245 1
d1250 80
d1333 4
a1336 3
    NV result = 0.0;
    char* s = (char*)orig;
#ifdef USE_PERL_ATOF
d1338 7
a1344 3
    char* send = s + strlen(orig) - 1;
    bool seendigit = 0;
    I32 expextra = 0;
d1346 4
a1349 10
    I32 i;
/* this is arbitrary */
#define PARTLIM 6
/* we want the largest integers we can usefully use */
#if defined(HAS_QUAD) && defined(USE_64_BIT_INT)
#   define PARTSIZE ((int)TYPE_DIGITS(U64)-1)
    U64 part[PARTLIM];
#else
#   define PARTSIZE ((int)TYPE_DIGITS(U32)-1)
    U32 part[PARTLIM];
d1351 3
a1353 2
    I32 ipart = 0;	/* index into part[] */
    I32 offcount;	/* number of digits in least significant part */
d1363 1
a1363 1
	    /* fall through */
d1367 41
d1409 2
a1410 3
    part[0] = offcount = 0;
    if (isDIGIT(*s)) {
	seendigit = 1;	/* get this over with */
d1412 21
a1432 4
	/* skip leading zeros */
	while (*s == '0')
	    ++s;
    }
d1434 1
a1434 8
    /* integer digits */
    while (isDIGIT(*s)) {
	if (++offcount > PARTSIZE) {
	    if (++ipart < PARTLIM) {
		part[ipart] = 0;
		offcount = 1;	/* ++0 */
	    }
	    else {
d1436 13
a1448 4
		--ipart;
		--offcount;
		if (*s >= '5')
		    ++part[ipart];
a1449 1
		    ++expextra;
d1451 3
d1456 20
d1479 3
a1481 1
	part[ipart] = part[ipart] * 10 + (*s++ - '0');
d1484 3
a1486 27
    /* decimal point */
    if (GROK_NUMERIC_RADIX((const char **)&s, send)) {
	if (isDIGIT(*s))
	    seendigit = 1;	/* get this over with */

	/* decimal digits */
	while (isDIGIT(*s)) {
	    if (++offcount > PARTSIZE) {
		if (++ipart < PARTLIM) {
		    part[ipart] = 0;
		    offcount = 1;	/* ++0 */
		}
		else {
		    /* limits of precision reached */
		    --ipart;
		    --offcount;
		    if (*s >= '5')
			++part[ipart];
		    while (isDIGIT(*s))
			++s;
		    /* warn of loss of precision? */
		    break;
		}
	    }
	    --expextra;
	    part[ipart] = part[ipart] * 10 + (*s++ - '0');
	}
d1489 1
a1489 6
    /* combine components of mantissa */
    for (i = 0; i <= ipart; ++i)
	result += S_mulexp10((NV)part[ipart - i],
		i ? offcount + (i - 1) * PARTSIZE : 0);

    if (seendigit && (*s == 'e' || *s == 'E')) {
d1496 1
a1496 1
		/* fall through */
d1506 2
d1509 7
a1515 2
    exponent += expextra;
    result = S_mulexp10(result, exponent);
d1519 1
a1519 1
	result = -result;
d1521 27
a1547 2
    *value = result;
    return s;
d1550 105
@


1.1.1.1
log
@stock perl 5.8.0 from CPAN
@
text
@@


1.1.1.2
log
@perl 5.8.2 from CPAN
@
text
@d3 1
a3 2
 *    Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999,
 *    2000, 2001, 2002, 2003, by Larry Wall and others
d200 1
a200 1
        if (!(*flags & PERL_SCAN_SILENT_ILLDIGIT) && ckWARN(WARN_DIGIT))
d315 1
a315 1
        if (!(*flags & PERL_SCAN_SILENT_ILLDIGIT) && ckWARN(WARN_DIGIT))
d401 1
a401 1
            if (!(*flags & PERL_SCAN_SILENT_ILLDIGIT) && ckWARN(WARN_DIGIT))
d720 1
a720 1
STATIC NV
a729 2
    if (value == 0)
	return 0;
d814 1
a814 1
    NV result[3] = {0.0, 0.0, 0.0};
a816 1
    UV accumulator[2] = {0,0};	/* before/after dp */
d819 2
a820 4
    bool seen_digit = 0;
    I32 exp_adjust[2] = {0,0};
    I32 exp_acc[2] = {-1, -1};
    /* the current exponent adjust for the accumulators */
d822 13
a834 26
    I32	seen_dp  = 0;
    I32 digit = 0;
    I32 old_digit = 0;
    I32 sig_digits = 0; /* noof significant digits seen so far */

/* There is no point in processing more significant digits
 * than the NV can hold. Note that NV_DIG is a lower-bound value,
 * while we need an upper-bound value. We add 2 to account for this;
 * since it will have been conservative on both the first and last digit.
 * For example a 32-bit mantissa with an exponent of 4 would have
 * exact values in the set
 *               4
 *               8
 *              ..
 *     17179869172
 *     17179869176
 *     17179869180
 *
 * where for the purposes of calculating NV_DIG we would have to discount
 * both the first and last digit, since neither can hold all values from
 * 0..9; but for calculating the value we must examine those two digits.
 */
#define MAX_SIG_DIGITS (NV_DIG+2)

/* the max number we can accumulate in a UV, and still safely do 10*N+9 */
#define MAX_ACCUMULATE ( (UV) ((UV_MAX - 9)/10))
d849 3
a851 2
    /* we accumulate digits into an integer; when this becomes too
     * large, we add the total to NV and start again */
d853 4
a856 12
    while (1) {
	if (isDIGIT(*s)) {
	    seen_digit = 1;
	    old_digit = digit;
	    digit = *s++ - '0';
	    if (seen_dp)
		exp_adjust[1]++;

	    /* don't start counting until we see the first significant
	     * digit, eg the 5 in 0.00005... */
	    if (!sig_digits && digit == 0)
		continue;
d858 8
a865 1
	    if (++sig_digits > MAX_SIG_DIGITS) {
d867 4
a870 13
	        if (digit > 5) {
		    ++accumulator[seen_dp];
		} else if (digit == 5) {
		    if (old_digit % 2) { /* round to even - Allen */
			++accumulator[seen_dp];
		    }
		}
		if (seen_dp) {
		    exp_adjust[1]--;
		} else {
		    exp_adjust[0]++;
		}
		/* skip remaining digits */
d872 1
a873 3
		    if (! seen_dp) {
			exp_adjust[0]++;
		    }
d876 1
d878 15
a892 8
	    else {
		if (accumulator[seen_dp] > MAX_ACCUMULATE) {
		    /* add accumulator to result and start again */
		    result[seen_dp] = S_mulexp10(result[seen_dp],
						 exp_acc[seen_dp])
			+ (NV)accumulator[seen_dp];
		    accumulator[seen_dp] = 0;
		    exp_acc[seen_dp] = 0;
d894 10
a903 10
		accumulator[seen_dp] = accumulator[seen_dp] * 10 + digit;
		++exp_acc[seen_dp];
	    }
	}
	else if (!seen_dp && GROK_NUMERIC_RADIX((const char **)&s, send)) {
	    seen_dp = 1;
	    if (sig_digits > MAX_SIG_DIGITS) {
		++s;
		while (isDIGIT(*s)) {
		    ++s;
a904 1
		break;
d906 2
a907 3
	}
	else {
	    break;
d911 4
a914 4
    result[0] = S_mulexp10(result[0], exp_acc[0]) + (NV)accumulator[0];
    if (seen_dp) {
	result[1] = S_mulexp10(result[1], exp_acc[1]) + (NV)accumulator[1];
    }
d916 1
a916 1
    if (seen_digit && (*s == 'e' || *s == 'E')) {
a932 2


d934 2
a935 7

    if (seen_dp) {
	result[2] = S_mulexp10(result[0],exponent+exp_adjust[0])
		+ S_mulexp10(result[1],exponent-exp_adjust[1]);
    } else {
	result[2] = S_mulexp10(result[0],exponent+exp_adjust[0]);
    }
d939 1
a939 1
	result[2] = -result[2];
d941 1
a941 1
    *value = result[2];
a944 16
#if ! defined(HAS_MODFL) && defined(HAS_AINTL) && defined(HAS_COPYSIGNL)
long double
Perl_my_modfl(long double x, long double *ip)
{
	*ip = aintl(x);
	return (x == *ip ? copysignl(0.0L, x) : x - *ip);
}
#endif

#if ! defined(HAS_FREXPL) && defined(HAS_ILOGBL) && defined(HAS_SCALBNL)
long double
Perl_my_frexpl(long double x, int *e) {
	*e = x == 0.0L ? 0 : ilogbl(x) + 1;
	return (scalbnl(x, -*e));
}
#endif
@


1.1.1.3
log
@perl 5.8.6 from CPAN
@
text
@a17 6

This file contains all the stuff needed by perl for manipulating numeric
values, including such things as replacements for the OS's atof() function

=cut

d121 2
a122 4
Unless C<PERL_SCAN_SILENT_ILLDIGIT> is set in I<*flags>, encountering an
invalid character will also trigger a warning.
On return I<*len> is set to the length of the scanned string,
and I<*flags> gives output flags.
d130 1
a130 1
The binary number may optionally be prefixed with "0b" or "b" unless
d234 3
a236 5
The scan stops at the end of the string, or the first invalid character.
Unless C<PERL_SCAN_SILENT_ILLDIGIT> is set in I<*flags>, encountering an
invalid character will also trigger a warning.
On return I<*len> is set to the length of the scanned string,
and I<*flags> gives output flags.
a344 18
converts a string representing an octal number to numeric form.

On entry I<start> and I<*len> give the string to scan, I<*flags> gives
conversion flags, and I<result> should be NULL or a pointer to an NV.
The scan stops at the end of the string, or the first invalid character.
Unless C<PERL_SCAN_SILENT_ILLDIGIT> is set in I<*flags>, encountering an
invalid character will also trigger a warning.
On return I<*len> is set to the length of the scanned string,
and I<*flags> gives output flags.

If the value is <= UV_MAX it is returned as a UV, the output flags are clear,
and nothing is written to I<*result>. If the value is > UV_MAX C<grok_oct>
returns UV_MAX, sets C<PERL_SCAN_GREATER_THAN_UV_MAX> in the output flags,
and writes the value to I<*result> (or the value is discarded if I<result>
is NULL).

If C<PERL_SCAN_ALLOW_UNDERSCORES> is set in I<*flags> then the octal
number may use '_' characters to separate digits.
d399 1
a399 1
         * as soon as non-octal characters are seen, complain only if
@


1.1.1.4
log
@perl 5.8.8 import
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006, by Larry Wall and others
d132 1
a132 1
If the value is <= C<UV_MAX> it is returned as a UV, the output flags are clear,
d154 1
a154 1
    const bool allow_underscores = (bool)(*flags & PERL_SCAN_ALLOW_UNDERSCORES);
a155 1
    char bit;
d173 2
a174 1
    for (; len-- && (bit = *s); s++) {
d270 1
a270 1
    const bool allow_underscores = (bool)(*flags & PERL_SCAN_ALLOW_UNDERSCORES);
d272 1
d291 1
a291 1
	const char *hexdigit = strchr(PL_hexdigit, *s);
d320 1
a320 1
		&& (hexdigit = strchr(PL_hexdigit, s[1])))
d385 1
a385 1
    const bool allow_underscores = (bool)(*flags & PERL_SCAN_ALLOW_UNDERSCORES);
d478 1
a478 1
    const UV ruv = grok_bin (start, &len, &flags, &rnv);
d489 1
a489 1
    const UV ruv = grok_oct (start, &len, &flags, &rnv);
d500 1
a500 1
    const UV ruv = grok_hex (start, &len, &flags, &rnv);
d519 1
a519 1
        const char* radix = SvPV(PL_numeric_radix_sv, len);
d760 1
a760 1
	return (NV)0;
d846 1
a846 1
    const char* s = orig;
d850 1
a850 1
    const char* send = s + strlen(orig) - 1;
a895 15
    /* punt to strtod for NaN/Inf; if no support for it there, tough luck */

#ifdef HAS_STRTOD
    if (*s == 'n' || *s == 'N' || *s == 'i' || *s == 'I') {
        const char *p = negative ? s - 1 : s;
        char *endp;
        NV rslt;
        rslt = strtod(p, &endp);
        if (endp != p) {
            *value = rslt;
            return (char *)endp;
        }
    }
#endif

d948 1
a948 1
	else if (!seen_dp && GROK_NUMERIC_RADIX(&s, send)) {
d1001 1
a1001 1
    return (char *)s;
a1019 10

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 noet:
 */
@


1.1.1.5
log
@import perl 5.10.0 from CPAN
@
text
@d3 2
a4 2
 *    Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
 *    2002, 2003, 2004, 2005, 2006, 2007, by Larry Wall and others
a32 1
    PERL_UNUSED_CONTEXT;
a50 1
    PERL_UNUSED_CONTEXT;
a68 1
    PERL_UNUSED_CONTEXT;
a87 1
    PERL_UNUSED_CONTEXT;
d103 16
d147 1
a147 1
Perl_grok_bin(pTHX_ const char *start, STRLEN *len_p, I32 *flags, NV *result) {
d263 1
a263 2
Perl_grok_hex(pTHX_ const char *start, STRLEN *len_p, I32 *flags, NV *result) {
    dVAR;
d377 1
a377 1
Perl_grok_oct(pTHX_ const char *start, STRLEN *len_p, I32 *flags, NV *result) {
d473 1
a473 1
Perl_scan_bin(pTHX_ const char *start, STRLEN len, STRLEN *retlen)
d484 1
a484 1
Perl_scan_oct(pTHX_ const char *start, STRLEN len, STRLEN *retlen)
d495 1
a495 1
Perl_scan_hex(pTHX_ const char *start, STRLEN len, STRLEN *retlen)
a515 1
    dVAR;
d518 1
a518 1
        const char * const radix = SvPV(PL_numeric_radix_sv, len);
d561 1
a561 1
  const char * const send = pv + len;
d783 1
a783 1
	const NV exp_v = log10(value);
a820 1
    dVAR;
d965 2
a966 1
		do {
d968 1
a968 1
		} while (isDIGIT(*s));
a1031 32
}
#endif

/*
=for apidoc Perl_signbit

Return a non-zero integer if the sign bit on an NV is set, and 0 if
it is not.  

If Configure detects this system has a signbit() that will work with
our NVs, then we just use it via the #define in perl.h.  Otherwise,
fall back on this implementation.  As a first pass, this gets everything
right except -0.0.  Alas, catching -0.0 is the main use for this function,
so this is not too helpful yet.  Still, at least we have the scaffolding
in place to support other systems, should that prove useful.


Configure notes:  This function is called 'Perl_signbit' instead of a
plain 'signbit' because it is easy to imagine a system having a signbit()
function or macro that doesn't happen to work with our particular choice
of NVs.  We shouldn't just re-#define signbit as Perl_signbit and expect
the standard system headers to be happy.  Also, this is a no-context
function (no pTHX_) because Perl_signbit() is usually re-#defined in
perl.h as a simple macro call to the system's signbit().
Users should just always call Perl_signbit().

=cut
*/
#if !defined(HAS_SIGNBIT)
int
Perl_signbit(NV x) {
    return (x < 0.0) ? 1 : 0;
@


1.1.1.6
log
@import perl 5.10.1
@
text
@d4 1
a4 1
 *    2002, 2003, 2004, 2005, 2006, 2007, 2008 by Larry Wall and others
d12 2
a13 4
 * "That only makes eleven (plus one mislaid) and not fourteen,
 *  unless wizards count differently to other people."  --Beorn
 *
 *     [p.115 of _The Hobbit_: "Queer Lodgings"]
d135 1
a135 2
Perl_grok_bin(pTHX_ const char *start, STRLEN *len_p, I32 *flags, NV *result)
{
a145 2
    PERL_ARGS_ASSERT_GROK_BIN;

d251 1
a251 2
Perl_grok_hex(pTHX_ const char *start, STRLEN *len_p, I32 *flags, NV *result)
{
d257 1
a261 2
    PERL_ARGS_ASSERT_GROK_HEX;

d366 1
a366 2
Perl_grok_oct(pTHX_ const char *start, STRLEN *len_p, I32 *flags, NV *result)
{
d371 1
a375 2
    PERL_ARGS_ASSERT_GROK_OCT;

a467 2
    PERL_ARGS_ASSERT_SCAN_BIN;

a478 2
    PERL_ARGS_ASSERT_SCAN_OCT;

a489 2
    PERL_ARGS_ASSERT_SCAN_HEX;

a505 3

    PERL_ARGS_ASSERT_GROK_NUMERIC_RADIX;

a516 3

    PERL_ARGS_ASSERT_GROK_NUMERIC_RADIX;

a557 2
  PERL_ARGS_ASSERT_GROK_NUMBER;

a811 3

    PERL_ARGS_ASSERT_MY_ATOF;

a849 2

    PERL_ARGS_ASSERT_MY_ATOF2;
@


1.1.1.7
log
@Perl 5.12.2 from CPAN
@
text
@d179 3
a181 2
		Perl_ck_warner_d(aTHX_ packWARN(WARN_OVERFLOW),
				 "Integer overflow in binary number");
d202 3
a204 3
        if (!(*flags & PERL_SCAN_SILENT_ILLDIGIT))
            Perl_ck_warner(aTHX_ packWARN(WARN_DIGIT),
			   "Illegal binary digit '%c' ignored", *s);
d213 3
a215 2
	Perl_ck_warner(aTHX_ packWARN(WARN_PORTABLE),
		       "Binary number > 0b11111111111111111111111111111111 non-portable");
d298 3
a300 2
		Perl_ck_warner_d(aTHX_ packWARN(WARN_OVERFLOW),
				 "Integer overflow in hexadecimal number");
d321 2
a322 2
        if (!(*flags & PERL_SCAN_SILENT_ILLDIGIT))
            Perl_ck_warner(aTHX_ packWARN(WARN_DIGIT),
d332 3
a334 2
	Perl_ck_warner(aTHX_ packWARN(WARN_PORTABLE),
		       "Hexadecimal number > 0xffffffff non-portable");
d400 3
a402 2
		Perl_ck_warner_d(aTHX_ packWARN(WARN_OVERFLOW),
			       "Integer overflow in octal number");
d427 3
a429 3
            if (!(*flags & PERL_SCAN_SILENT_ILLDIGIT))
                Perl_ck_warner(aTHX_ packWARN(WARN_DIGIT),
			       "Illegal octal digit '%c' ignored", *s);
d439 3
a441 2
	Perl_ck_warner(aTHX_ packWARN(WARN_PORTABLE),
		       "Octal number > 037777777777 non-portable");
@


1.1.1.8
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@a133 4

Not documented yet because experimental is C<PERL_SCAN_SILENT_NON_PORTABLE
which suppresses any message for non-portable numbers that are still valid
on this platform.
d145 1
a145 1
    const bool allow_underscores = cBOOL(*flags & PERL_SCAN_ALLOW_UNDERSCORES);
d156 1
a156 1
            if (s[0] == 'b' || s[0] == 'B') {
d160 1
a160 1
            else if (len >= 2 && s[0] == '0' && (s[1] == 'b' || s[1] == 'B')) {
a178 1
		/* diag_listed_as: Integer overflow in %s number */
d209 1
a209 2
	|| (!overflowed && value > 0xffffffff
	    && ! (*flags & PERL_SCAN_SILENT_NON_PORTABLE))
a250 4

Not documented yet because experimental is C<PERL_SCAN_SILENT_NON_PORTABLE
which suppresses any message for non-portable numbers that are still valid
on this platform.
d262 1
a262 1
    const bool allow_underscores = cBOOL(*flags & PERL_SCAN_ALLOW_UNDERSCORES);
d272 1
a272 1
            if (s[0] == 'x' || s[0] == 'X') {
d276 1
a276 1
            else if (len >= 2 && s[0] == '0' && (s[1] == 'x' || s[1] == 'X')) {
a295 1
		/* diag_listed_as: Integer overflow in %s number */
d326 1
a326 2
	|| (!overflowed && value > 0xffffffff
	    && ! (*flags & PERL_SCAN_SILENT_NON_PORTABLE))
d352 1
a352 1
8 or 9 will also trigger a warning.
a365 4

Not documented yet because experimental is C<PERL_SCAN_SILENT_NON_PORTABLE
which suppresses any message for non-portable numbers that are still valid
on this platform.
d376 1
a376 1
    const bool allow_underscores = cBOOL(*flags & PERL_SCAN_ALLOW_UNDERSCORES);
a395 1
		/* diag_listed_as: Integer overflow in %s number */
d431 1
a431 2
	|| (!overflowed && value > 0xffffffff
	    && ! (*flags & PERL_SCAN_SILENT_NON_PORTABLE))
d518 1
a518 1
    if (PL_numeric_radix_sv && IN_SOME_LOCALE_FORM) {
d832 1
a832 1
    if (PL_numeric_local && IN_SOME_LOCALE_FORM) {
d890 1
a890 8
#ifdef MAX_SIG_DIG_PLUS
    /* It is not necessarily the case that adding 2 to NV_DIG gets all the
       possible digits in a NV, especially if NVs are not IEEE compliant
       (e.g., long doubles on IRIX) - Allen <allens@@cpan.org> */
# define MAX_SIG_DIGITS (NV_DIG+MAX_SIG_DIG_PLUS)
#else
# define MAX_SIG_DIGITS (NV_DIG+2)
#endif
@


1.1.1.9
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d379 2
a380 2
Not documented yet because experimental is C<PERL_SCAN_SILENT_NON_PORTABLE>
which suppresses any message for non-portable numbers, but which are valid
d806 1
a806 1
#if ((defined(VMS) && !defined(_IEEE_FP)) || defined(_UNICOS)) && defined(NV_MAX_10_EXP)
d850 2
a851 14
    if (PL_numeric_local && PL_numeric_radix_sv && IN_SOME_LOCALE_FORM) {
        const char *standard = NULL, *local = NULL;
        bool use_standard_radix;

        /* Look through the string for the first thing that looks like a
         * decimal point: either the value in the current locale or the
         * standard fallback of '.'. The one which appears earliest in the
         * input string is the one that we should have atof look for. Note that
         * we have to determine this beforehand because on some systems,
         * Perl_atof2 is just a wrapper around the system's atof. */
        standard = strchr(s, '.');
        local = strstr(s, SvPV_nolen(PL_numeric_radix_sv));

        use_standard_radix = standard && (!local || standard < local);
d853 8
a860 7
        if (use_standard_radix)
            SET_NUMERIC_STANDARD();

        Perl_atof2(s, x);

        if (use_standard_radix)
            SET_NUMERIC_LOCAL();
d1108 1
a1108 1
 * indent-tabs-mode: nil
d1111 1
a1111 1
 * ex: set ts=8 sts=4 sw=4 et:
@


1.1.1.10
log
@Import perl-5.20.1
@
text
@d123 1
a123 1
and nothing is written to I<*result>.  If the value is > UV_MAX C<grok_bin>
d129 1
a129 1
C<PERL_SCAN_DISALLOW_PREFIX> is set in I<*flags> on entry.  If
d237 1
a237 1
On entry I<start> and I<*len_p> give the string to scan, I<*flags> gives
d246 1
a246 1
and nothing is written to I<*result>.  If the value is > UV_MAX C<grok_hex>
d252 1
a252 1
C<PERL_SCAN_DISALLOW_PREFIX> is set in I<*flags> on entry.  If
d294 2
a295 1
        if (isXDIGIT(*s)) {
d302 1
a302 1
                    value = (value << 4) | XDIGIT_VALUE(*s);
d319 1
a319 1
            value_nv += (NV) XDIGIT_VALUE(*s);
d323 1
a323 1
		&& isXDIGIT(s[1]))
d369 1
a369 1
and nothing is written to I<*result>.  If the value is > UV_MAX C<grok_oct>
d398 4
a401 1
        if (isOCTAL(*s)) {
d408 1
a408 1
                    value = (value << 3) | OCTAL_VALUE(*s);
d425 1
a425 1
            value_nv += (NV) OCTAL_VALUE(*s);
d428 7
a434 5
        if (*s == '_' && len && allow_underscores && isOCTAL(s[1])) {
            --len;
            ++s;
            goto redo;
        }
d437 2
a438 3
         * someone seems to want to use the digits eight and nine.  Since we
         * know it is not octal, then if isDIGIT, must be an 8 or 9). */
        if (isDIGIT(*s)) {
d469 1
a469 1
For backwards compatibility.  Use C<grok_bin> instead.
d473 1
a473 1
For backwards compatibility.  Use C<grok_hex> instead.
d477 1
a477 1
For backwards compatibility.  Use C<grok_oct> instead.
d565 1
a565 1
If the value of the number can fit in a UV, it is returned in the *valuep
d602 1
a602 1
    s++;
a825 11
#ifdef NV_MAX_10_EXP
        /* for something like 1234 x 10^-309, the action of calculating
         * the intermediate value 10^309 then returning 1234 / (10^309)
         * will fail, since 10^309 becomes infinity. In this case try to
         * refactor it as 123 / (10^308) etc.
         */
        while (value && exponent > NV_MAX_10_EXP) {
            exponent--;
            value /= 10;
        }
#endif
d850 14
a863 17
    {
        DECLARE_STORE_LC_NUMERIC_SET_TO_NEEDED();
        if (PL_numeric_local && PL_numeric_radix_sv && IN_SOME_LOCALE_FORM) {
            const char *standard = NULL, *local = NULL;
            bool use_standard_radix;

            /* Look through the string for the first thing that looks like a
             * decimal point: either the value in the current locale or the
             * standard fallback of '.'. The one which appears earliest in the
             * input string is the one that we should have atof look for. Note
             * that we have to determine this beforehand because on some
             * systems, Perl_atof2 is just a wrapper around the system's atof.
             * */
            standard = strchr(s, '.');
            local = strstr(s, SvPV_nolen(PL_numeric_radix_sv));

            use_standard_radix = standard && (!local || standard < local);
d865 2
a866 2
            if (use_standard_radix)
                SET_NUMERIC_STANDARD();
d868 1
a868 1
            Perl_atof2(s, x);
d870 2
a871 6
            if (use_standard_radix)
                SET_NUMERIC_LOCAL();
        }
        else
            Perl_atof2(s, x);
        RESTORE_LC_NUMERIC();
d873 2
@


1.1.1.11
log
@Import perl-5.24.2
@
text
@a20 2
=cut

d24 2
d33 1
a33 1
Perl_cast_ulong(NV f)
d35 1
d43 1
a43 1
    return ((U32) f) | (1 + (U32_MAX >> 1));
d52 1
a52 1
Perl_cast_i32(NV f)
d54 1
d62 1
a62 1
    return (I32)(((U32) f) | (1 + (U32_MAX >> 1)));
d71 1
a71 1
Perl_cast_iv(NV f)
d73 1
d82 1
a82 1
    return (IV)(((UV) f) | (1 + (UV_MAX >> 1)));
d91 1
a91 1
Perl_cast_uv(NV f)
d93 1
d101 1
a101 1
    return ((UV) f) | (1 + (UV_MAX >> 1));
d114 2
a115 2
On entry C<start> and C<*len> give the string to scan, C<*flags> gives
conversion flags, and C<result> should be C<NULL> or a pointer to an NV.
d117 1
a117 1
Unless C<PERL_SCAN_SILENT_ILLDIGIT> is set in C<*flags>, encountering an
d119 2
a120 2
On return C<*len> is set to the length of the scanned string,
and C<*flags> gives output flags.
d123 3
a125 3
and nothing is written to C<*result>.  If the value is > C<UV_MAX>, C<grok_bin>
returns C<UV_MAX>, sets C<PERL_SCAN_GREATER_THAN_UV_MAX> in the output flags,
and writes the value to C<*result> (or the value is discarded if C<result>
d128 4
a131 4
The binary number may optionally be prefixed with C<"0b"> or C<"b"> unless
C<PERL_SCAN_DISALLOW_PREFIX> is set in C<*flags> on entry.  If
C<PERL_SCAN_ALLOW_UNDERSCORES> is set in C<*flags> then the binary
number may use C<"_"> characters to separate digits.
d160 1
a160 1
            if (isALPHA_FOLD_EQ(s[0], 'b')) {
d164 1
a164 1
            else if (len >= 2 && s[0] == '0' && (isALPHA_FOLD_EQ(s[1], 'b'))) {
d237 2
a238 2
On entry C<start> and C<*len_p> give the string to scan, C<*flags> gives
conversion flags, and C<result> should be C<NULL> or a pointer to an NV.
d240 1
a240 1
Unless C<PERL_SCAN_SILENT_ILLDIGIT> is set in C<*flags>, encountering an
d242 2
a243 2
On return C<*len> is set to the length of the scanned string,
and C<*flags> gives output flags.
d245 10
a254 10
If the value is <= C<UV_MAX> it is returned as a UV, the output flags are clear,
and nothing is written to C<*result>.  If the value is > C<UV_MAX>, C<grok_hex>
returns C<UV_MAX>, sets C<PERL_SCAN_GREATER_THAN_UV_MAX> in the output flags,
and writes the value to C<*result> (or the value is discarded if C<result>
is C<NULL>).

The hex number may optionally be prefixed with C<"0x"> or C<"x"> unless
C<PERL_SCAN_DISALLOW_PREFIX> is set in C<*flags> on entry.  If
C<PERL_SCAN_ALLOW_UNDERSCORES> is set in C<*flags> then the hex
number may use C<"_"> characters to separate digits.
d259 1
a259 1
which suppresses any message for non-portable numbers, but which are valid
d266 1
d282 1
a282 1
            if (isALPHA_FOLD_EQ(s[0], 'x')) {
d286 1
a286 1
            else if (len >= 2 && s[0] == '0' && (isALPHA_FOLD_EQ(s[1], 'x'))) {
d359 2
a360 2
On entry C<start> and C<*len> give the string to scan, C<*flags> gives
conversion flags, and C<result> should be C<NULL> or a pointer to an NV.
d362 1
a362 1
Unless C<PERL_SCAN_SILENT_ILLDIGIT> is set in C<*flags>, encountering an
d364 2
a365 2
On return C<*len> is set to the length of the scanned string,
and C<*flags> gives output flags.
d367 5
a371 5
If the value is <= C<UV_MAX> it is returned as a UV, the output flags are clear,
and nothing is written to C<*result>.  If the value is > C<UV_MAX>, C<grok_oct>
returns C<UV_MAX>, sets C<PERL_SCAN_GREATER_THAN_UV_MAX> in the output flags,
and writes the value to C<*result> (or the value is discarded if C<result>
is C<NULL>).
d373 2
a374 2
If C<PERL_SCAN_ALLOW_UNDERSCORES> is set in C<*flags> then the octal
number may use C<"_"> characters to separate digits.
d527 2
d531 6
a536 11
    if (IN_LC(LC_NUMERIC)) {
        DECLARATION_FOR_LC_NUMERIC_MANIPULATION;
        STORE_LC_NUMERIC_SET_TO_NEEDED();
        if (PL_numeric_radix_sv) {
            STRLEN len;
            const char * const radix = SvPV(PL_numeric_radix_sv, len);
            if (*sp + len <= send && memEQ(*sp, radix, len)) {
                *sp += len;
                RESTORE_LC_NUMERIC();
                return TRUE;
            }
a537 1
        RESTORE_LC_NUMERIC();
d553 1
a553 255
=for apidoc grok_infnan

Helper for C<grok_number()>, accepts various ways of spelling "infinity"
or "not a number", and returns one of the following flag combinations:

  IS_NUMBER_INFINITE
  IS_NUMBER_NAN
  IS_NUMBER_INFINITE | IS_NUMBER_NEG
  IS_NUMBER_NAN | IS_NUMBER_NEG
  0

possibly |-ed with C<IS_NUMBER_TRAILING>.

If an infinity or a not-a-number is recognized, C<*sp> will point to
one byte past the end of the recognized string.  If the recognition fails,
zero is returned, and C<*sp> will not move.

=cut
*/

int
Perl_grok_infnan(pTHX_ const char** sp, const char* send)
{
    const char* s = *sp;
    int flags = 0;
    bool odh = FALSE; /* one-dot-hash: 1.#INF */

    PERL_ARGS_ASSERT_GROK_INFNAN;

    if (*s == '+') {
        s++; if (s == send) return 0;
    }
    else if (*s == '-') {
        flags |= IS_NUMBER_NEG; /* Yes, -NaN happens. Incorrect but happens. */
        s++; if (s == send) return 0;
    }

    if (*s == '1') {
        /* Visual C: 1.#SNAN, -1.#QNAN, 1#INF, 1.#IND (maybe also 1.#NAN)
         * Let's keep the dot optional. */
        s++; if (s == send) return 0;
        if (*s == '.') {
            s++; if (s == send) return 0;
        }
        if (*s == '#') {
            s++; if (s == send) return 0;
        } else
            return 0;
        odh = TRUE;
    }

    if (isALPHA_FOLD_EQ(*s, 'I')) {
        /* INF or IND (1.#IND is "indeterminate", a certain type of NAN) */

        s++; if (s == send || isALPHA_FOLD_NE(*s, 'N')) return 0;
        s++; if (s == send) return 0;
        if (isALPHA_FOLD_EQ(*s, 'F')) {
            s++;
            if (s < send && (isALPHA_FOLD_EQ(*s, 'I'))) {
                int fail =
                    flags | IS_NUMBER_INFINITY | IS_NUMBER_NOT_INT | IS_NUMBER_TRAILING;
                s++; if (s == send || isALPHA_FOLD_NE(*s, 'N')) return fail;
                s++; if (s == send || isALPHA_FOLD_NE(*s, 'I')) return fail;
                s++; if (s == send || isALPHA_FOLD_NE(*s, 'T')) return fail;
                s++; if (s == send || isALPHA_FOLD_NE(*s, 'Y')) return fail;
                s++;
            } else if (odh) {
                while (*s == '0') { /* 1.#INF00 */
                    s++;
                }
            }
            while (s < send && isSPACE(*s))
                s++;
            if (s < send && *s) {
                flags |= IS_NUMBER_TRAILING;
            }
            flags |= IS_NUMBER_INFINITY | IS_NUMBER_NOT_INT;
        }
        else if (isALPHA_FOLD_EQ(*s, 'D') && odh) { /* 1.#IND */
            s++;
            flags |= IS_NUMBER_NAN | IS_NUMBER_NOT_INT;
            while (*s == '0') { /* 1.#IND00 */
                s++;
            }
            if (*s) {
                flags |= IS_NUMBER_TRAILING;
            }
        } else
            return 0;
    }
    else {
        /* Maybe NAN of some sort */

        if (isALPHA_FOLD_EQ(*s, 'S') || isALPHA_FOLD_EQ(*s, 'Q')) {
            /* snan, qNaN */
            /* XXX do something with the snan/qnan difference */
            s++; if (s == send) return 0;
        }

        if (isALPHA_FOLD_EQ(*s, 'N')) {
            s++; if (s == send || isALPHA_FOLD_NE(*s, 'A')) return 0;
            s++; if (s == send || isALPHA_FOLD_NE(*s, 'N')) return 0;
            s++;

            flags |= IS_NUMBER_NAN | IS_NUMBER_NOT_INT;

            /* NaN can be followed by various stuff (NaNQ, NaNS), but
             * there are also multiple different NaN values, and some
             * implementations output the "payload" values,
             * e.g. NaN123, NAN(abc), while some legacy implementations
             * have weird stuff like NaN%. */
            if (isALPHA_FOLD_EQ(*s, 'q') ||
                isALPHA_FOLD_EQ(*s, 's')) {
                /* "nanq" or "nans" are ok, though generating
                 * these portably is tricky. */
                s++;
            }
            if (*s == '(') {
                /* C99 style "nan(123)" or Perlish equivalent "nan($uv)". */
                const char *t;
                s++;
                if (s == send) {
                    return flags | IS_NUMBER_TRAILING;
                }
                t = s + 1;
                while (t < send && *t && *t != ')') {
                    t++;
                }
                if (t == send) {
                    return flags | IS_NUMBER_TRAILING;
                }
                if (*t == ')') {
                    int nantype;
                    UV nanval;
                    if (s[0] == '0' && s + 2 < t &&
                        isALPHA_FOLD_EQ(s[1], 'x') &&
                        isXDIGIT(s[2])) {
                        STRLEN len = t - s;
                        I32 flags = PERL_SCAN_ALLOW_UNDERSCORES;
                        nanval = grok_hex(s, &len, &flags, NULL);
                        if ((flags & PERL_SCAN_GREATER_THAN_UV_MAX)) {
                            nantype = 0;
                        } else {
                            nantype = IS_NUMBER_IN_UV;
                        }
                        s += len;
                    } else if (s[0] == '0' && s + 2 < t &&
                               isALPHA_FOLD_EQ(s[1], 'b') &&
                               (s[2] == '0' || s[2] == '1')) {
                        STRLEN len = t - s;
                        I32 flags = PERL_SCAN_ALLOW_UNDERSCORES;
                        nanval = grok_bin(s, &len, &flags, NULL);
                        if ((flags & PERL_SCAN_GREATER_THAN_UV_MAX)) {
                            nantype = 0;
                        } else {
                            nantype = IS_NUMBER_IN_UV;
                        }
                        s += len;
                    } else {
                        const char *u;
                        nantype =
                            grok_number_flags(s, t - s, &nanval,
                                              PERL_SCAN_TRAILING |
                                              PERL_SCAN_ALLOW_UNDERSCORES);
                        /* Unfortunately grok_number_flags() doesn't
                         * tell how far we got and the ')' will always
                         * be "trailing", so we need to double-check
                         * whether we had something dubious. */
                        for (u = s; u < t; u++) {
                            if (!isDIGIT(*u)) {
                                flags |= IS_NUMBER_TRAILING;
                                break;
                            }
                        }
                        s = u;
                    }

                    /* XXX Doesn't do octal: nan("0123").
                     * Probably not a big loss. */

                    if ((nantype & IS_NUMBER_NOT_INT) ||
                        !(nantype && IS_NUMBER_IN_UV)) {
                        /* XXX the nanval is currently unused, that is,
                         * not inserted as the NaN payload of the NV.
                         * But the above code already parses the C99
                         * nan(...)  format.  See below, and see also
                         * the nan() in POSIX.xs.
                         *
                         * Certain configuration combinations where
                         * NVSIZE is greater than UVSIZE mean that
                         * a single UV cannot contain all the possible
                         * NaN payload bits.  There would need to be
                         * some more generic syntax than "nan($uv)".
                         *
                         * Issues to keep in mind:
                         *
                         * (1) In most common cases there would
                         * not be an integral number of bytes that
                         * could be set, only a certain number of bits.
                         * For example for the common case of
                         * NVSIZE == UVSIZE == 8 there is room for 52
                         * bits in the payload, but the most significant
                         * bit is commonly reserved for the
                         * signaling/quiet bit, leaving 51 bits.
                         * Furthermore, the C99 nan() is supposed
                         * to generate quiet NaNs, so it is doubtful
                         * whether it should be able to generate
                         * signaling NaNs.  For the x86 80-bit doubles
                         * (if building a long double Perl) there would
                         * be 62 bits (s/q bit being the 63rd).
                         *
                         * (2) Endianness of the payload bits. If the
                         * payload is specified as an UV, the low-order
                         * bits of the UV are naturally little-endianed
                         * (rightmost) bits of the payload.  The endianness
                         * of UVs and NVs can be different. */
                        return 0;
                    }
                    if (s < t) {
                        flags |= IS_NUMBER_TRAILING;
                    }
                } else {
                    /* Looked like nan(...), but no close paren. */
                    flags |= IS_NUMBER_TRAILING;
                }
            } else {
                while (s < send && isSPACE(*s))
                    s++;
                if (s < send && *s) {
                    /* Note that we here implicitly accept (parse as
                     * "nan", but with warnings) also any other weird
                     * trailing stuff for "nan".  In the above we just
                     * check that if we got the C99-style "nan(...)",
                     * the "..."  looks sane.
                     * If in future we accept more ways of specifying
                     * the nan payload, the accepting would happen around
                     * here. */
                    flags |= IS_NUMBER_TRAILING;
                }
            }
            s = send;
        }
        else
            return 0;
    }

    while (s < send && isSPACE(*s))
        s++;

    *sp = s;
    return flags;
}

/*
=for apidoc grok_number_flags
d557 2
a558 2
C<IS_NUMBER_IN_UV>, C<IS_NUMBER_GREATER_THAN_UV_MAX>, C<IS_NUMBER_NOT_INT>,
C<IS_NUMBER_NEG>, C<IS_NUMBER_INFINITY>, C<IS_NUMBER_NAN> (defined in perl.h).
d560 11
a570 11
If the value of the number can fit in a UV, it is returned in C<*valuep>.
C<IS_NUMBER_IN_UV> will be set to indicate that C<*valuep> is valid, C<IS_NUMBER_IN_UV>
will never be set unless C<*valuep> is valid, but C<*valuep> may have been assigned
to during processing even though C<IS_NUMBER_IN_UV> is not set on return.
If C<valuep> is C<NULL>, C<IS_NUMBER_IN_UV> will be set for the same cases as when
C<valuep> is non-C<NULL>, but no actual assignment (or SEGV) will occur.

C<IS_NUMBER_NOT_INT> will be set with C<IS_NUMBER_IN_UV> if trailing decimals were
seen (in which case C<*valuep> gives the true value truncated to an integer), and
C<IS_NUMBER_NEG> if the number is negative (in which case C<*valuep> holds the
absolute value).  C<IS_NUMBER_IN_UV> is not set if e notation was used or the
a572 8
C<flags> allows only C<PERL_SCAN_TRAILING>, which allows for trailing
non-numeric text on an otherwise successful I<grok>, setting
C<IS_NUMBER_TRAILING> on the result.

=for apidoc grok_number

Identical to C<grok_number_flags()> with C<flags> set to zero.

a577 11
    PERL_ARGS_ASSERT_GROK_NUMBER;

    return grok_number_flags(pv, len, valuep, 0);
}

static const UV uv_max_div_10 = UV_MAX / 10;
static const U8 uv_max_mod_10 = UV_MAX % 10;

int
Perl_grok_number_flags(pTHX_ const char *pv, STRLEN len, UV *valuep, U32 flags)
{
d580 2
a581 1
  const char *d;
d583 2
d586 1
a586 1
  PERL_ARGS_ASSERT_GROK_NUMBER_FLAGS;
d602 1
a602 5
  /* The first digit (after optional sign): note that might
   * also point to "infinity" or "nan", or "1.#INF". */
  d = s;

  /* next must be digit or the radix separator or beginning of infinity/nan */
d649 3
a651 3
                                             && (value < uv_max_div_10
                                                 || (value == uv_max_div_10
                                                     && digit <= uv_max_mod_10))) {
d711 20
a730 2
        return 0;
  }
d732 7
a738 1
  if (s > d && s < send) {
d740 4
a743 1
    if (isALPHA_FOLD_EQ(*s, 'e')) {
a751 2
      else if (flags & PERL_SCAN_TRAILING)
        return numtype | IS_NUMBER_TRAILING;
d753 1
a753 5
        return 0;

      /* The only flag we keep is sign.  Blow away any "it's UV"  */
      numtype &= IS_NUMBER_NEG;
      numtype |= IS_NUMBER_NOT_INT;
a764 16
  /* We could be e.g. at "Inf" or "NaN", or at the "#" of "1.#INF". */
  if ((s + 2 < send) && strchr("inqs#", toFOLD(*s))) {
      /* Really detect inf/nan. Start at d, not s, since the above
       * code might have already consumed the "1." or "1". */
      int infnan = Perl_grok_infnan(aTHX_ &d, send);
      if ((infnan & IS_NUMBER_INFINITY)) {
          return (numtype | infnan); /* Keep sign for infinity. */
      }
      else if ((infnan & IS_NUMBER_NAN)) {
          return (numtype | infnan) & ~IS_NUMBER_NEG; /* Clear sign for nan. */
      }
  }
  else if (flags & PERL_SCAN_TRAILING) {
    return numtype | IS_NUMBER_TRAILING;
  }

a767 72
/*
grok_atoUV

grok_atoUV parses a C-style zero-byte terminated string, looking for
a decimal unsigned integer.

Returns the unsigned integer, if a valid value can be parsed
from the beginning of the string.

Accepts only the decimal digits '0'..'9'.

As opposed to atoi or strtol, grok_atoUV does NOT allow optional
leading whitespace, or negative inputs.  If such features are
required, the calling code needs to explicitly implement those.

Returns true if a valid value could be parsed. In that case, valptr
is set to the parsed value, and endptr (if provided) is set to point
to the character after the last digit.

Returns false otherwise. This can happen if a) there is a leading zero
followed by another digit; b) the digits would overflow a UV; or c)
there are trailing non-digits AND endptr is not provided.

Background: atoi has severe problems with illegal inputs, it cannot be
used for incremental parsing, and therefore should be avoided
atoi and strtol are also affected by locale settings, which can also be
seen as a bug (global state controlled by user environment).

*/

bool
Perl_grok_atoUV(const char *pv, UV *valptr, const char** endptr)
{
    const char* s = pv;
    const char** eptr;
    const char* end2; /* Used in case endptr is NULL. */
    UV val = 0; /* The parsed value. */

    PERL_ARGS_ASSERT_GROK_ATOUV;

    eptr = endptr ? endptr : &end2;
    if (isDIGIT(*s)) {
        /* Single-digit inputs are quite common. */
        val = *s++ - '0';
        if (isDIGIT(*s)) {
            /* Fail on extra leading zeros. */
            if (val == 0)
                return FALSE;
            while (isDIGIT(*s)) {
                /* This could be unrolled like in grok_number(), but
                 * the expected uses of this are not speed-needy, and
                 * unlikely to need full 64-bitness. */
                U8 digit = *s++ - '0';
                if (val < uv_max_div_10 ||
                    (val == uv_max_div_10 && digit <= uv_max_mod_10)) {
                    val = val * 10 + digit;
                } else {
                    return FALSE;
                }
            }
        }
    }
    if (s == pv)
        return FALSE;
    if (endptr == NULL && *s)
        return FALSE; /* If endptr is NULL, no trailing non-digits allowed. */
    *eptr = s;
    *valptr = val;
    return TRUE;
}

#ifndef USE_QUADMATH
a830 2
        if (value == 0.0)
            return value;
a832 7
#if defined(__osf__)
    /* Even with cc -ieee + ieee_set_fp_control(IEEE_TRAP_ENABLE_INV)
     * Tru64 fp behavior on inf/nan is somewhat broken. Another way
     * to do this would be ieee_set_fp_control(IEEE_TRAP_ENABLE_OVF)
     * but that breaks another set of infnan.t tests. */
#  define FP_OVERFLOWS_TO_ZERO
#endif
a836 4
#ifdef FP_OVERFLOWS_TO_ZERO
            if (result == 0)
                return value < 0 ? -NV_INF : NV_INF;
#endif
a845 1
#endif /* #ifndef USE_QUADMATH */
d851 3
a853 5
#ifdef USE_QUADMATH
    Perl_my_atof2(aTHX_ s, &x);
    return x;
#else
#  ifdef USE_LOCALE_NUMERIC
d857 2
a858 3
        DECLARATION_FOR_LC_NUMERIC_MANIPULATION;
        STORE_LC_NUMERIC_SET_TO_NEEDED();
        if (PL_numeric_radix_sv && IN_LC(LC_NUMERIC)) {
d880 1
a880 1
                SET_NUMERIC_UNDERLYING();
d886 1
a886 1
#  else
a887 1
#  endif
a891 80

#ifdef USING_MSVC6
#  pragma warning(push)
#  pragma warning(disable:4756;disable:4056)
#endif
static char*
S_my_atof_infnan(pTHX_ const char* s, bool negative, const char* send, NV* value)
{
    const char *p0 = negative ? s - 1 : s;
    const char *p = p0;
    int infnan = grok_infnan(&p, send);
    if (infnan && p != p0) {
        /* If we can generate inf/nan directly, let's do so. */
#ifdef NV_INF
        if ((infnan & IS_NUMBER_INFINITY)) {
            *value = (infnan & IS_NUMBER_NEG) ? -NV_INF: NV_INF;
            return (char*)p;
        }
#endif
#ifdef NV_NAN
        if ((infnan & IS_NUMBER_NAN)) {
            *value = NV_NAN;
            return (char*)p;
        }
#endif
#ifdef Perl_strtod
        /* If still here, we didn't have either NV_INF or NV_NAN,
         * and can try falling back to native strtod/strtold.
         *
         * (Though, are our NV_INF or NV_NAN ever not defined?)
         *
         * The native interface might not recognize all the possible
         * inf/nan strings Perl recognizes.  What we can try
         * is to try faking the input.  We will try inf/-inf/nan
         * as the most promising/portable input. */
        {
            const char* fake = NULL;
            char* endp;
            NV nv;
            if ((infnan & IS_NUMBER_INFINITY)) {
                fake = ((infnan & IS_NUMBER_NEG)) ? "-inf" : "inf";
            }
            else if ((infnan & IS_NUMBER_NAN)) {
                fake = "nan";
            }
            assert(fake);
            nv = Perl_strtod(fake, &endp);
            if (fake != endp) {
                if ((infnan & IS_NUMBER_INFINITY)) {
#ifdef Perl_isinf
                    if (Perl_isinf(nv))
                        *value = nv;
#else
                    /* last resort, may generate SIGFPE */
                    *value = Perl_exp((NV)1e9);
                    if ((infnan & IS_NUMBER_NEG))
                        *value = -*value;
#endif
                    return (char*)p; /* p, not endp */
                }
                else if ((infnan & IS_NUMBER_NAN)) {
#ifdef Perl_isnan
                    if (Perl_isnan(nv))
                        *value = nv;
#else
                    /* last resort, may generate SIGFPE */
                    *value = Perl_log((NV)-1.0);
#endif
                    return (char*)p; /* p, not endp */
                }
            }
        }
#endif /* #ifdef Perl_strtod */
    }
    return NULL;
}
#ifdef USING_MSVC6
#  pragma warning(pop)
#endif

d895 1
d897 2
a898 3
    NV result[3] = {0.0, 0.0, 0.0};
#if defined(USE_PERL_ATOF) || defined(USE_QUADMATH)
    const char* send = s + strlen(orig); /* one past the last */
d900 1
a900 3
#endif
#if defined(USE_PERL_ATOF) && !defined(USE_QUADMATH)
    UV accumulator[2] = {0,0};	/* before/after dp */
a909 1
#endif
a910 1
#if defined(USE_PERL_ATOF) || defined(USE_QUADMATH)
a912 28
    /* leading whitespace */
    while (isSPACE(*s))
	++s;

    /* sign */
    switch (*s) {
	case '-':
	    negative = 1;
	    /* FALLTHROUGH */
	case '+':
	    ++s;
    }
#endif

#ifdef USE_QUADMATH
    {
        char* endp;
        if ((endp = S_my_atof_infnan(aTHX_ s, negative, send, value)))
            return endp;
        result[2] = strtoflt128(s, &endp);
        if (s != endp) {
            *value = negative ? -result[2] : result[2];
            return endp;
        }
        return NULL;
    }
#elif defined(USE_PERL_ATOF)

d942 25
a966 4
    {
        const char* endp;
        if ((endp = S_my_atof_infnan(aTHX_ s, negative, send, value)))
            return (char*)endp;
d968 1
d1041 1
a1041 1
    if (seen_digit && (isALPHA_FOLD_EQ(*s, 'e'))) {
d1048 1
a1048 1
		/* FALLTHROUGH */
d1077 1
a1077 57
/*
=for apidoc isinfnan

C<Perl_isinfnan()> is utility function that returns true if the NV
argument is either an infinity or a C<NaN>, false otherwise.  To test
in more detail, use C<Perl_isinf()> and C<Perl_isnan()>.

This is also the logical inverse of Perl_isfinite().

=cut
*/
bool
Perl_isinfnan(NV nv)
{
#ifdef Perl_isinf
    if (Perl_isinf(nv))
        return TRUE;
#endif
#ifdef Perl_isnan
    if (Perl_isnan(nv))
        return TRUE;
#endif
    return FALSE;
}

/*
=for apidoc

Checks whether the argument would be either an infinity or C<NaN> when used
as a number, but is careful not to trigger non-numeric or uninitialized
warnings.  it assumes the caller has done C<SvGETMAGIC(sv)> already.

=cut
*/

bool
Perl_isinfnansv(pTHX_ SV *sv)
{
    PERL_ARGS_ASSERT_ISINFNANSV;
    if (!SvOK(sv))
        return FALSE;
    if (SvNOKp(sv))
        return Perl_isinfnan(SvNVX(sv));
    if (SvIOKp(sv))
        return FALSE;
    {
        STRLEN len;
        const char *s = SvPV_nomg_const(sv, len);
        return cBOOL(grok_infnan(&s, s+len));
    }
}

#ifndef HAS_MODFL
/* C99 has truncl, pre-C99 Solaris had aintl.  We can use either with
 * copysignl to emulate modfl, which is in some platforms missing or
 * broken. */
#  if defined(HAS_TRUNCL) && defined(HAS_COPYSIGNL)
d1081 2
a1082 2
    *ip = truncl(x);
    return (x == *ip ? copysignl(0.0L, x) : x - *ip);
a1083 8
#  elif defined(HAS_AINTL) && defined(HAS_COPYSIGNL)
long double
Perl_my_modfl(long double x, long double *ip)
{
    *ip = aintl(x);
    return (x == *ip ? copysignl(0.0L, x) : x - *ip);
}
#  endif
a1085 1
/* Similarly, with ilogbl and scalbnl we can emulate frexpl. */
d1089 2
a1090 2
    *e = x == 0.0L ? 0 : ilogbl(x) + 1;
    return (scalbnl(x, -*e));
d1100 7
a1106 4
If F<Configure> detects this system has a C<signbit()> that will work with
our NVs, then we just use it via the C<#define> in F<perl.h>.  Otherwise,
fall back on this implementation.  The main use of this function
is catching C<-0.0>.
d1108 2
a1109 2
C<Configure> notes:  This function is called C<'Perl_signbit'> instead of a
plain C<'signbit'> because it is easy to imagine a system having a C<signbit()>
d1111 1
a1111 1
of NVs.  We shouldn't just re-C<#define> C<signbit> as C<Perl_signbit> and expect
d1113 3
a1115 3
function (no C<pTHX_>) because C<Perl_signbit()> is usually re-C<#defined> in
F<perl.h> as a simple macro call to the system's C<signbit()>.
Users should just always call C<Perl_signbit()>.
a1121 15
#  ifdef Perl_fp_class_nzero
    return Perl_fp_class_nzero(x);
    /* Try finding the high byte, and assume it's highest bit
     * is the sign.  This assumption is probably wrong somewhere. */
#  elif defined(USE_LONG_DOUBLE) && LONG_DOUBLEKIND == LONG_DOUBLE_IS_X86_80_BIT_LITTLE_ENDIAN
    return (((unsigned char *)&x)[9] & 0x80);
#  elif defined(NV_LITTLE_ENDIAN)
    /* Note that NVSIZE is sizeof(NV), which would make the below be
     * wrong if the end bytes are unused, which happens with the x86
     * 80-bit long doubles, which is why take care of that above. */
    return (((unsigned char *)&x)[NVSIZE - 1] & 0x80);
#  elif defined(NV_BIG_ENDIAN)
    return (((unsigned char *)&x)[0] & 0x80);
#  else
    /* This last resort fallback is wrong for the negative zero. */
a1122 1
#  endif
d1127 6
@


