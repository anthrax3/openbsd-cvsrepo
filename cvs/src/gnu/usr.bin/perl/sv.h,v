head	1.20;
access;
symbols
	OPENBSD_6_2:1.20.0.6
	OPENBSD_6_2_BASE:1.20
	PERL_5_24_2:1.1.1.18
	OPENBSD_6_1:1.20.0.4
	OPENBSD_6_1_BASE:1.20
	OPENBSD_6_0:1.19.0.4
	OPENBSD_6_0_BASE:1.19
	OPENBSD_5_9:1.18.0.2
	OPENBSD_5_9_BASE:1.18
	OPENBSD_5_8:1.18.0.4
	OPENBSD_5_8_BASE:1.18
	PERL_5_20_2:1.1.1.17
	OPENBSD_5_7:1.17.0.2
	OPENBSD_5_7_BASE:1.17
	PERL_5_20_1:1.1.1.16
	OPENBSD_5_6:1.16.0.4
	OPENBSD_5_6_BASE:1.16
	PERL_5_18_2:1.1.1.15
	PERL:1.1.1
	OPENBSD_5_5:1.15.0.6
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.15.0.2
	OPENBSD_5_4_BASE:1.15
	PERL_5_16_3:1.1.1.14
	OPENBSD_5_3:1.14.0.10
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.8
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.6
	OPENBSD_5_0:1.14.0.4
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.2
	OPENBSD_4_9_BASE:1.14
	PERL_5_12_2:1.1.1.13
	OPENBSD_4_8:1.13.0.4
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.2
	OPENBSD_4_7_BASE:1.13
	PERL_5_10_1:1.1.1.12
	OPENBSD_4_6:1.12.0.6
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.2
	OPENBSD_4_5_BASE:1.12
	PERL_5_10_0:1.1.1.11
	OPENBSD_4_4:1.11.0.10
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.8
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.6
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.4
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.2
	OPENBSD_4_0_BASE:1.11
	PERL_5_8_8:1.1.1.10
	OPENBSD_3_9:1.10.0.6
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.4
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.2
	OPENBSD_3_7_BASE:1.10
	PERL_5_8_6:1.1.1.9
	OPENBSD_3_6:1.9.0.2
	OPENBSD_3_6_BASE:1.9
	PERL_5_8_5:1.1.1.8
	PERL_5_8_3:1.1.1.7
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.20
date	2017.02.05.00.31.53;	author afresh1;	state Exp;
branches;
next	1.19;
commitid	cxJ08BvJA9Pt2PTM;

1.19
date	2016.07.03.01.07.49;	author afresh1;	state Exp;
branches;
next	1.18;
commitid	GzHqjSTnBjdF7Wcw;

1.18
date	2015.04.25.19.14.38;	author afresh1;	state Exp;
branches;
next	1.17;
commitid	XRK22kO4se3v2i2I;

1.17
date	2014.11.17.20.56.48;	author afresh1;	state Exp;
branches;
next	1.16;
commitid	QP75iYx42Uo7mMxO;

1.16
date	2014.03.24.15.05.13;	author afresh1;	state Exp;
branches;
next	1.15;

1.15
date	2013.03.25.20.40.45;	author sthen;	state Exp;
branches;
next	1.14;

1.14
date	2010.09.24.15.06.43;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2009.10.12.18.24.22;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2008.09.29.17.36.00;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2006.03.28.19.22.59;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2005.01.15.21.30.22;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2004.08.09.18.08.57;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2004.04.07.21.33.00;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.23;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.19;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.34.59;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.04.27;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.51.12;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.49.20;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.11.50;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.11.50;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.38.01;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.08.48;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.22.24;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.14.51;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.43.38;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.04.07.21.12.56;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.08.09.17.45.49;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2005.01.15.21.16.37;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2006.03.28.18.47.45;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2008.09.29.17.18.10;	author millert;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2009.10.12.18.10.33;	author millert;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2010.09.24.14.48.34;	author millert;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2013.03.25.20.06.41;	author sthen;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	2014.03.24.14.58.48;	author afresh1;	state Exp;
branches;
next	1.1.1.16;

1.1.1.16
date	2014.11.17.20.52.40;	author afresh1;	state Exp;
branches;
next	1.1.1.17;
commitid	B31cAbBIXiCqnL97;

1.1.1.17
date	2015.04.25.19.10.14;	author afresh1;	state Exp;
branches;
next	1.1.1.18;
commitid	Wpcs5S8qILgEZC7F;

1.1.1.18
date	2017.08.14.13.45.30;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.20
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@/*    sv.h
 *
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
 *    2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

#ifdef sv_flags
#undef sv_flags		/* Convex has this in <signal.h> for sigvec() */
#endif

/*
=head1 SV Flags

=for apidoc AmU||svtype
An enum of flags for Perl types.  These are found in the file F<sv.h>
in the C<svtype> enum.  Test these flags with the C<SvTYPE> macro.

The types are:

    SVt_NULL
    SVt_IV
    SVt_NV
    SVt_RV
    SVt_PV
    SVt_PVIV
    SVt_PVNV
    SVt_PVMG
    SVt_INVLIST
    SVt_REGEXP
    SVt_PVGV
    SVt_PVLV
    SVt_PVAV
    SVt_PVHV
    SVt_PVCV
    SVt_PVFM
    SVt_PVIO

These are most easily explained from the bottom up.

C<SVt_PVIO> is for I/O objects, C<SVt_PVFM> for formats, C<SVt_PVCV> for
subroutines, C<SVt_PVHV> for hashes and C<SVt_PVAV> for arrays.

All the others are scalar types, that is, things that can be bound to a
C<$> variable.  For these, the internal types are mostly orthogonal to
types in the Perl language.

Hence, checking C<< SvTYPE(sv) < SVt_PVAV >> is the best way to see whether
something is a scalar.

C<SVt_PVGV> represents a typeglob.  If C<!SvFAKE(sv)>, then it is a real,
incoercible typeglob.  If C<SvFAKE(sv)>, then it is a scalar to which a
typeglob has been assigned.  Assigning to it again will stop it from being
a typeglob.  C<SVt_PVLV> represents a scalar that delegates to another scalar
behind the scenes.  It is used, e.g., for the return value of C<substr> and
for tied hash and array elements.  It can hold any scalar value, including
a typeglob.  C<SVt_REGEXP> is for regular
expressions.  C<SVt_INVLIST> is for Perl
core internal use only.

C<SVt_PVMG> represents a "normal" scalar (not a typeglob, regular expression,
or delegate).  Since most scalars do not need all the internal fields of a
PVMG, we save memory by allocating smaller structs when possible.  All the
other types are just simpler forms of C<SVt_PVMG>, with fewer internal fields.
C<SVt_NULL> can only hold undef.  C<SVt_IV> can hold undef, an integer, or a
reference.  (C<SVt_RV> is an alias for C<SVt_IV>, which exists for backward
compatibility.)  C<SVt_NV> can hold any of those or a double.  C<SVt_PV> can only
hold C<undef> or a string.  C<SVt_PVIV> is a superset of C<SVt_PV> and C<SVt_IV>.
C<SVt_PVNV> is similar.  C<SVt_PVMG> can hold anything C<SVt_PVNV> can hold, but it
can, but does not have to, be blessed or magical.

=for apidoc AmU||SVt_NULL
Type flag for scalars.  See L</svtype>.

=for apidoc AmU||SVt_IV
Type flag for scalars.  See L</svtype>.

=for apidoc AmU||SVt_NV
Type flag for scalars.  See L</svtype>.

=for apidoc AmU||SVt_PV
Type flag for scalars.  See L</svtype>.

=for apidoc AmU||SVt_PVIV
Type flag for scalars.  See L</svtype>.

=for apidoc AmU||SVt_PVNV
Type flag for scalars.  See L</svtype>.

=for apidoc AmU||SVt_PVMG
Type flag for scalars.  See L</svtype>.

=for apidoc AmU||SVt_INVLIST
Type flag for scalars.  See L</svtype>.

=for apidoc AmU||SVt_REGEXP
Type flag for regular expressions.  See L</svtype>.

=for apidoc AmU||SVt_PVGV
Type flag for typeglobs.  See L</svtype>.

=for apidoc AmU||SVt_PVLV
Type flag for scalars.  See L</svtype>.

=for apidoc AmU||SVt_PVAV
Type flag for arrays.  See L</svtype>.

=for apidoc AmU||SVt_PVHV
Type flag for hashes.  See L</svtype>.

=for apidoc AmU||SVt_PVCV
Type flag for subroutines.  See L</svtype>.

=for apidoc AmU||SVt_PVFM
Type flag for formats.  See L</svtype>.

=for apidoc AmU||SVt_PVIO
Type flag for I/O objects.  See L</svtype>.

=cut

  These are ordered so that the simpler types have a lower value; SvUPGRADE
  doesn't allow you to upgrade from a higher numbered type to a lower numbered
  one; also there is code that assumes that anything that has as a PV component
  has a type numbered >= SVt_PV.
*/


typedef enum {
	SVt_NULL,	/* 0 */
	/* BIND was here, before INVLIST replaced it.  */
	SVt_IV,		/* 1 */
	SVt_NV,		/* 2 */
	/* RV was here, before it was merged with IV.  */
	SVt_PV,		/* 3 */
	SVt_INVLIST,	/* 4, implemented as a PV */
	SVt_PVIV,	/* 5 */
	SVt_PVNV,	/* 6 */
	SVt_PVMG,	/* 7 */
	SVt_REGEXP,	/* 8 */
	/* PVBM was here, before BIND replaced it.  */
	SVt_PVGV,	/* 9 */
	SVt_PVLV,	/* 10 */
	SVt_PVAV,	/* 11 */
	SVt_PVHV,	/* 12 */
	SVt_PVCV,	/* 13 */
	SVt_PVFM,	/* 14 */
	SVt_PVIO,	/* 15 */
	SVt_LAST	/* keep last in enum. used to size arrays */
} svtype;

/* *** any alterations to the SV types above need to be reflected in
 * SVt_MASK and the various PL_valid_types_* tables.  As of this writing those
 * tables are in perl.h.  There are also two affected names tables in dump.c,
 * one in B.xs, and 'bodies_by_type[]' in sv.c */

#define SVt_MASK 0xf	/* smallest bitmask that covers all types */

#ifndef PERL_CORE
/* Although Fast Boyer Moore tables are now being stored in PVGVs, for most
   purposes external code wanting to consider PVBM probably needs to think of
   PVMG instead.  */
#  define SVt_PVBM	SVt_PVMG
/* Anything wanting to create a reference from clean should ensure that it has
   a scalar of type SVt_IV now:  */
#  define SVt_RV	SVt_IV
#endif

/* There is collusion here with sv_clear - sv_clear exits early for SVt_NULL
   so never reaches the clause at the end that uses sv_type_details->body_size
   to determine whether to call safefree(). Hence body_size can be set
   non-zero to record the size of HEs, without fear of bogus frees.  */
#if defined(PERL_IN_HV_C) || defined(PERL_IN_XS_APITEST)
#define HE_SVSLOT	SVt_NULL
#endif
#ifdef PERL_IN_SV_C
#  define SVt_FIRST SVt_NULL	/* the type of SV that new_SV() in sv.c returns */
#endif

#define PERL_ARENA_ROOTS_SIZE	(SVt_LAST)

/* typedefs to eliminate some typing */
typedef struct he HE;
typedef struct hek HEK;

/* Using C's structural equivalence to help emulate C++ inheritance here... */

/* start with 2 sv-head building blocks */
#define _SV_HEAD(ptrtype) \
    ptrtype	sv_any;		/* pointer to body */	\
    U32		sv_refcnt;	/* how many references to us */	\
    U32		sv_flags	/* what we are */

#if NVSIZE <= IVSIZE
#  define _NV_BODYLESS_UNION NV svu_nv;
#else
#  define _NV_BODYLESS_UNION
#endif

#define _SV_HEAD_UNION \
    union {				\
	char*   svu_pv;		/* pointer to malloced string */	\
	IV      svu_iv;			\
	UV      svu_uv;			\
	_NV_BODYLESS_UNION		\
	SV*     svu_rv;		/* pointer to another SV */		\
	struct regexp* svu_rx;		\
	SV**    svu_array;		\
	HE**	svu_hash;		\
	GP*	svu_gp;			\
	PerlIO *svu_fp;			\
    }	sv_u				\
    _SV_HEAD_DEBUG

#ifdef DEBUG_LEAKING_SCALARS
#define _SV_HEAD_DEBUG ;\
    PERL_BITFIELD32 sv_debug_optype:9;	/* the type of OP that allocated us */ \
    PERL_BITFIELD32 sv_debug_inpad:1;	/* was allocated in a pad for an OP */ \
    PERL_BITFIELD32 sv_debug_line:16;	/* the line where we were allocated */ \
    UV		    sv_debug_serial;	/* serial number of sv allocation   */ \
    char *	    sv_debug_file;	/* the file where we were allocated */ \
    SV *	    sv_debug_parent	/* what we were cloned from (ithreads)*/
#else
#define _SV_HEAD_DEBUG
#endif

struct STRUCT_SV {		/* struct sv { */
    _SV_HEAD(void*);
    _SV_HEAD_UNION;
};

struct gv {
    _SV_HEAD(XPVGV*);		/* pointer to xpvgv body */
    _SV_HEAD_UNION;
};

struct cv {
    _SV_HEAD(XPVCV*);		/* pointer to xpvcv body */
    _SV_HEAD_UNION;
};

struct av {
    _SV_HEAD(XPVAV*);		/* pointer to xpvav body */
    _SV_HEAD_UNION;
};

struct hv {
    _SV_HEAD(XPVHV*);		/* pointer to xpvhv body */
    _SV_HEAD_UNION;
};

struct io {
    _SV_HEAD(XPVIO*);		/* pointer to xpvio body */
    _SV_HEAD_UNION;
};

struct p5rx {
    _SV_HEAD(struct regexp*);	/* pointer to regexp body */
    _SV_HEAD_UNION;
};

#undef _SV_HEAD
#undef _SV_HEAD_UNION		/* ensure no pollution */

/*
=head1 SV Manipulation Functions

=for apidoc Am|U32|SvREFCNT|SV* sv
Returns the value of the object's reference count.

=for apidoc Am|SV*|SvREFCNT_inc|SV* sv
Increments the reference count of the given SV, returning the SV.

All of the following C<SvREFCNT_inc>* macros are optimized versions of
C<SvREFCNT_inc>, and can be replaced with C<SvREFCNT_inc>.

=for apidoc Am|SV*|SvREFCNT_inc_NN|SV* sv
Same as C<SvREFCNT_inc>, but can only be used if you know C<sv>
is not C<NULL>.  Since we don't have to check the NULLness, it's faster
and smaller.

=for apidoc Am|void|SvREFCNT_inc_void|SV* sv
Same as C<SvREFCNT_inc>, but can only be used if you don't need the
return value.  The macro doesn't need to return a meaningful value.

=for apidoc Am|void|SvREFCNT_inc_void_NN|SV* sv
Same as C<SvREFCNT_inc>, but can only be used if you don't need the return
value, and you know that C<sv> is not C<NULL>.  The macro doesn't need
to return a meaningful value, or check for NULLness, so it's smaller
and faster.

=for apidoc Am|SV*|SvREFCNT_inc_simple|SV* sv
Same as C<SvREFCNT_inc>, but can only be used with expressions without side
effects.  Since we don't have to store a temporary value, it's faster.

=for apidoc Am|SV*|SvREFCNT_inc_simple_NN|SV* sv
Same as C<SvREFCNT_inc_simple>, but can only be used if you know C<sv>
is not C<NULL>.  Since we don't have to check the NULLness, it's faster
and smaller.

=for apidoc Am|void|SvREFCNT_inc_simple_void|SV* sv
Same as C<SvREFCNT_inc_simple>, but can only be used if you don't need the
return value.  The macro doesn't need to return a meaningful value.

=for apidoc Am|void|SvREFCNT_inc_simple_void_NN|SV* sv
Same as C<SvREFCNT_inc>, but can only be used if you don't need the return
value, and you know that C<sv> is not C<NULL>.  The macro doesn't need
to return a meaningful value, or check for NULLness, so it's smaller
and faster.

=for apidoc Am|void|SvREFCNT_dec|SV* sv
Decrements the reference count of the given SV.  C<sv> may be C<NULL>.

=for apidoc Am|void|SvREFCNT_dec_NN|SV* sv
Same as C<SvREFCNT_dec>, but can only be used if you know C<sv>
is not C<NULL>.  Since we don't have to check the NULLness, it's faster
and smaller.

=for apidoc Am|svtype|SvTYPE|SV* sv
Returns the type of the SV.  See C<L</svtype>>.

=for apidoc Am|void|SvUPGRADE|SV* sv|svtype type
Used to upgrade an SV to a more complex form.  Uses C<sv_upgrade> to
perform the upgrade if necessary.  See C<L</svtype>>.

=cut
*/

#define SvANY(sv)	(sv)->sv_any
#define SvFLAGS(sv)	(sv)->sv_flags
#define SvREFCNT(sv)	(sv)->sv_refcnt

#define SvREFCNT_inc(sv)		S_SvREFCNT_inc(MUTABLE_SV(sv))
#define SvREFCNT_inc_simple(sv)		SvREFCNT_inc(sv)
#define SvREFCNT_inc_NN(sv)		S_SvREFCNT_inc_NN(MUTABLE_SV(sv))
#define SvREFCNT_inc_void(sv)		S_SvREFCNT_inc_void(MUTABLE_SV(sv))

/* These guys don't need the curly blocks */
#define SvREFCNT_inc_simple_void(sv)	STMT_START { if (sv) SvREFCNT(sv)++; } STMT_END
#define SvREFCNT_inc_simple_NN(sv)	(++(SvREFCNT(sv)),MUTABLE_SV(sv))
#define SvREFCNT_inc_void_NN(sv)	(void)(++SvREFCNT(MUTABLE_SV(sv)))
#define SvREFCNT_inc_simple_void_NN(sv)	(void)(++SvREFCNT(MUTABLE_SV(sv)))

#define SvREFCNT_dec(sv)	S_SvREFCNT_dec(aTHX_ MUTABLE_SV(sv))
#define SvREFCNT_dec_NN(sv)	S_SvREFCNT_dec_NN(aTHX_ MUTABLE_SV(sv))

#define SVTYPEMASK	0xff
#define SvTYPE(sv)	((svtype)((sv)->sv_flags & SVTYPEMASK))

/* Sadly there are some parts of the core that have pointers to already-freed
   SV heads, and rely on being able to tell that they are now free. So mark
   them all by using a consistent macro.  */
#define SvIS_FREED(sv)	UNLIKELY(((sv)->sv_flags == SVTYPEMASK))

/* this is defined in this peculiar way to avoid compiler warnings.
 * See the <20121213131428.GD1842@@iabyn.com> thread in p5p */
#define SvUPGRADE(sv, mt) \
    ((void)(SvTYPE(sv) >= (mt) || (sv_upgrade(sv, mt),1)))

#define SVf_IOK		0x00000100  /* has valid public integer value */
#define SVf_NOK		0x00000200  /* has valid public numeric value */
#define SVf_POK		0x00000400  /* has valid public pointer value */
#define SVf_ROK		0x00000800  /* has a valid reference pointer */

#define SVp_IOK		0x00001000  /* has valid non-public integer value */
#define SVp_NOK		0x00002000  /* has valid non-public numeric value */
#define SVp_POK		0x00004000  /* has valid non-public pointer value */
#define SVp_SCREAM	0x00008000  /* method name is DOES */
                                    /* eval cx text is ref counted */
#define SVphv_CLONEABLE	SVp_SCREAM  /* PVHV (stashes) clone its objects */
#define SVpgv_GP	SVp_SCREAM  /* GV has a valid GP */
#define SVprv_PCS_IMPORTED  SVp_SCREAM  /* RV is a proxy for a constant
				       subroutine in another package. Set the
				       GvIMPORTED_CV_on() if it needs to be
				       expanded to a real GV */
#define SVf_PROTECT	0x00010000  /* very read-only */
#define SVs_PADTMP	0x00020000  /* in use as tmp */
#define SVs_PADSTALE	0x00040000  /* lexical has gone out of scope;
					only used when !PADTMP */
#define SVs_TEMP	0x00080000  /* mortal (implies string is stealable) */
#define SVs_OBJECT	0x00100000  /* is "blessed" */
#define SVs_GMG		0x00200000  /* has magical get method */
#define SVs_SMG		0x00400000  /* has magical set method */
#define SVs_RMG		0x00800000  /* has random magical methods */

#define SVf_FAKE	0x01000000  /* 0: glob is just a copy
				       1: SV head arena wasn't malloc()ed
				       2: For PVCV, whether CvUNIQUE(cv)
					  refers to an eval or once only
					  [CvEVAL(cv), CvSPECIAL(cv)]
                                       3: HV: informally reserved by DAPM
                                          for vtables */
#define SVf_OOK		0x02000000  /* has valid offset value. For a PVHV this
				       means that a hv_aux struct is present
				       after the main array */
#define SVf_BREAK	0x04000000  /* refcnt is artificially low - used by
				       SVs in final arena cleanup.
				       Set in S_regtry on PL_reg_curpm, so that
				       perl_destruct will skip it.
                                       Used for mark and sweep by OP_AASSIGN
                                       */
#define SVf_READONLY	0x08000000  /* may not be modified */




#define SVf_THINKFIRST	(SVf_READONLY|SVf_PROTECT|SVf_ROK|SVf_FAKE \
			|SVs_RMG|SVf_IsCOW)

#define SVf_OK		(SVf_IOK|SVf_NOK|SVf_POK|SVf_ROK| \
			 SVp_IOK|SVp_NOK|SVp_POK|SVpgv_GP)

#define PRIVSHIFT 4	/* (SVp_?OK >> PRIVSHIFT) == SVf_?OK */

/* Note that SVf_AMAGIC is now only set on stashes.  */
#define SVf_AMAGIC	0x10000000  /* has magical overloaded methods */
#define SVf_IsCOW	0x10000000  /* copy on write (shared hash key if
				       SvLEN == 0) */

/* Ensure this value does not clash with the GV_ADD* flags in gv.h, or the
   CV_CKPROTO_* flags in op.c, or the padadd_* flags in pad.h: */
#define SVf_UTF8        0x20000000  /* SvPV is UTF-8 encoded
				       This is also set on RVs whose overloaded
				       stringification is UTF-8. This might
				       only happen as a side effect of SvPV() */
/* PVHV */
#define SVphv_SHAREKEYS 0x20000000  /* PVHV keys live on shared string table */

/* PVAV could probably use 0x2000000 without conflict. I assume that PVFM can
   be UTF-8 encoded, and PVCVs could well have UTF-8 prototypes. PVIOs haven't
   been restructured, so sometimes get used as string buffers.  */


/* Some private flags. */


/* The SVp_SCREAM|SVpbm_VALID (0x40008000) combination is up for grabs.
   Formerly it was used for pad names, but now it is available.  The core
   is careful to avoid setting both flags.

   SVf_POK, SVp_POK also set:
   0x00004400   Normal
   0x0000C400   method name for DOES (SvSCREAM)
   0x40004400   FBM compiled (SvVALID)
   0x4000C400   *** Formerly used for pad names ***

   0x00008000   GV with GP
   0x00008800   RV with PCS imported
*/
/* PVAV */
#define SVpav_REAL	0x40000000  /* free old entries */
/* PVHV */
#define SVphv_LAZYDEL	0x40000000  /* entry in xhv_eiter must be deleted */
/* This is only set true on a PVGV when it's playing "PVBM", but is tested for
   on any regular scalar (anything <= PVLV) */
#define SVpbm_VALID	0x40000000
/* Only used in toke.c on an SV stored in PL_lex_repl */
#define SVrepl_EVAL	0x40000000  /* Replacement part of s///e */

/* IV, PVIV, PVNV, PVMG, PVGV and (I assume) PVLV  */
#define SVf_IVisUV	0x80000000  /* use XPVUV instead of XPVIV */
/* PVAV */
#define SVpav_REIFY 	0x80000000  /* can become real */
/* PVHV */
#define SVphv_HASKFLAGS	0x80000000  /* keys have flag byte after hash */
/* PVGV when SVpbm_VALID is true */
#define SVpbm_TAIL	0x80000000  /* string has a fake "\n" appended */
/* RV upwards. However, SVf_ROK and SVp_IOK are exclusive  */
#define SVprv_WEAKREF   0x80000000  /* Weak reference */
/* pad name vars only */

#define _XPV_HEAD							\
    HV*		xmg_stash;	/* class package */			\
    union _xmgu	xmg_u;							\
    STRLEN	xpv_cur;	/* length of svu_pv as a C string */    \
    union {								\
	STRLEN	xpvlenu_len; 	/* allocated size */			\
	char *	xpvlenu_pv;	/* regexp string */			\
    } xpv_len_u	

#define xpv_len	xpv_len_u.xpvlenu_len

union _xnvu {
    NV	    xnv_nv;		/* numeric value, if any */
    HV *    xgv_stash;
    struct {
	U32 xlow;
	U32 xhigh;
    }	    xpad_cop_seq;	/* used by pad.c for cop_sequence */
};

union _xivu {
    IV	    xivu_iv;		/* integer value */
    UV	    xivu_uv;
    HEK *   xivu_namehek;	/* xpvlv, xpvgv: GvNAME */
};

union _xmgu {
    MAGIC*  xmg_magic;		/* linked list of magicalness */
    STRLEN  xmg_hash_index;	/* used while freeing hash entries */
};

struct xpv {
    _XPV_HEAD;
};

struct xpviv {
    _XPV_HEAD;
    union _xivu xiv_u;
};

#define xiv_iv xiv_u.xivu_iv

struct xpvuv {
    _XPV_HEAD;
    union _xivu xuv_u;
};

#define xuv_uv xuv_u.xivu_uv

struct xpvnv {
    _XPV_HEAD;
    union _xivu xiv_u;
    union _xnvu xnv_u;
};

/* This structure must match the beginning of struct xpvhv in hv.h. */
struct xpvmg {
    _XPV_HEAD;
    union _xivu xiv_u;
    union _xnvu xnv_u;
};

struct xpvlv {
    _XPV_HEAD;
    union _xivu xiv_u;
    union _xnvu xnv_u;
    union {
	STRLEN	xlvu_targoff;
	SSize_t xlvu_stargoff;
    } xlv_targoff_u;
    STRLEN	xlv_targlen;
    SV*		xlv_targ;
    char	xlv_type;	/* k=keys .=pos x=substr v=vec /=join/re
				 * y=alem/helem/iter t=tie T=tied HE */
    char	xlv_flags;	/* 1 = negative offset  2 = negative len */
};

#define xlv_targoff xlv_targoff_u.xlvu_targoff

struct xpvinvlist {
    _XPV_HEAD;
    IV          prev_index;     /* caches result of previous invlist_search() */
    STRLEN	iterator;       /* Stores where we are in iterating */
    bool	is_offset;	/* The data structure for all inversion lists
                                   begins with an element for code point U+0000.
                                   If this bool is set, the actual list contains
                                   that 0; otherwise, the list actually begins
                                   with the following element.  Thus to invert
                                   the list, merely toggle this flag  */
};

/* This structure works in 3 ways - regular scalar, GV with GP, or fast
   Boyer-Moore.  */
struct xpvgv {
    _XPV_HEAD;
    union _xivu xiv_u;
    union _xnvu xnv_u;
};

typedef U32 cv_flags_t;

#define _XPVCV_COMMON								\
    HV *	xcv_stash;							\
    union {									\
	OP *	xcv_start;							\
	ANY	xcv_xsubany;							\
    }		xcv_start_u;					    		\
    union {									\
	OP *	xcv_root;							\
	void	(*xcv_xsub) (pTHX_ CV*);					\
    }		xcv_root_u;							\
    union {								\
	GV *	xcv_gv;							\
	HEK *	xcv_hek;						\
    }		xcv_gv_u;						\
    char *	xcv_file;							\
    union {									\
	PADLIST *	xcv_padlist;						\
	void *		xcv_hscxt;						\
    }		xcv_padlist_u;							\
    CV *	xcv_outside;							\
    U32		xcv_outside_seq; /* the COP sequence (at the point of our	\
				  * compilation) in the lexically enclosing	\
				  * sub */					\
    cv_flags_t	xcv_flags;						\
    I32	xcv_depth	/* >= 2 indicates recursive call */

/* This structure must match XPVCV in cv.h */

struct xpvfm {
    _XPV_HEAD;
    _XPVCV_COMMON;
};


struct xpvio {
    _XPV_HEAD;
    union _xivu xiv_u;
    /* ifp and ofp are normally the same, but sockets need separate streams */
    PerlIO *	xio_ofp;
    /* Cray addresses everything by word boundaries (64 bits) and
     * code and data pointers cannot be mixed (which is exactly what
     * Perl_filter_add() tries to do with the dirp), hence the
     *  following union trick (as suggested by Gurusamy Sarathy).
     * For further information see Geir Johansen's problem report
     * titled [ID 20000612.002] Perl problem on Cray system
     * The any pointer (known as IoANY()) will also be a good place
     * to hang any IO disciplines to.
     */
    union {
	DIR *	xiou_dirp;	/* for opendir, readdir, etc */
	void *	xiou_any;	/* for alignment */
    } xio_dirpu;
    /* IV xio_lines is now in IVX  $. */
    IV		xio_page;	/* $% */
    IV		xio_page_len;	/* $= */
    IV		xio_lines_left;	/* $- */
    char *	xio_top_name;	/* $^ */
    GV *	xio_top_gv;	/* $^ */
    char *	xio_fmt_name;	/* $~ */
    GV *	xio_fmt_gv;	/* $~ */
    char *	xio_bottom_name;/* $^B */
    GV *	xio_bottom_gv;	/* $^B */
    char	xio_type;
    U8		xio_flags;
};

#define xio_dirp	xio_dirpu.xiou_dirp
#define xio_any		xio_dirpu.xiou_any

#define IOf_ARGV	1	/* this fp iterates over ARGV */
#define IOf_START	2	/* check for null ARGV and substitute '-' */
#define IOf_FLUSH	4	/* this fp wants a flush after write op */
#define IOf_DIDTOP	8	/* just did top of form */
#define IOf_UNTAINT	16	/* consider this fp (and its data) "safe" */
#define IOf_NOLINE	32	/* slurped a pseudo-line from empty file */
#define IOf_FAKE_DIRP	64	/* xio_dirp is fake (source filters kludge)
				   Also, when this is set, SvPVX() is valid */

/* The following macros define implementation-independent predicates on SVs. */

/*
=for apidoc Am|U32|SvNIOK|SV* sv
Returns a U32 value indicating whether the SV contains a number, integer or
double.

=for apidoc Am|U32|SvNIOKp|SV* sv
Returns a U32 value indicating whether the SV contains a number, integer or
double.  Checks the B<private> setting.  Use C<SvNIOK> instead.

=for apidoc Am|void|SvNIOK_off|SV* sv
Unsets the NV/IV status of an SV.

=for apidoc Am|U32|SvOK|SV* sv
Returns a U32 value indicating whether the value is defined.  This is
only meaningful for scalars.

=for apidoc Am|U32|SvIOKp|SV* sv
Returns a U32 value indicating whether the SV contains an integer.  Checks
the B<private> setting.  Use C<SvIOK> instead.

=for apidoc Am|U32|SvNOKp|SV* sv
Returns a U32 value indicating whether the SV contains a double.  Checks the
B<private> setting.  Use C<SvNOK> instead.

=for apidoc Am|U32|SvPOKp|SV* sv
Returns a U32 value indicating whether the SV contains a character string.
Checks the B<private> setting.  Use C<SvPOK> instead.

=for apidoc Am|U32|SvIOK|SV* sv
Returns a U32 value indicating whether the SV contains an integer.

=for apidoc Am|void|SvIOK_on|SV* sv
Tells an SV that it is an integer.

=for apidoc Am|void|SvIOK_off|SV* sv
Unsets the IV status of an SV.

=for apidoc Am|void|SvIOK_only|SV* sv
Tells an SV that it is an integer and disables all other C<OK> bits.

=for apidoc Am|void|SvIOK_only_UV|SV* sv
Tells an SV that it is an unsigned integer and disables all other C<OK> bits.

=for apidoc Am|bool|SvIOK_UV|SV* sv
Returns a boolean indicating whether the SV contains an integer that must be
interpreted as unsigned.  A non-negative integer whose value is within the
range of both an IV and a UV may be be flagged as either C<SvUOK> or C<SVIOK>.

=for apidoc Am|bool|SvUOK|SV* sv
Returns a boolean indicating whether the SV contains an integer that must be
interpreted as unsigned.  A non-negative integer whose value is within the
range of both an IV and a UV may be be flagged as either C<SvUOK> or C<SVIOK>.

=for apidoc Am|bool|SvIOK_notUV|SV* sv
Returns a boolean indicating whether the SV contains a signed integer.

=for apidoc Am|U32|SvNOK|SV* sv
Returns a U32 value indicating whether the SV contains a double.

=for apidoc Am|void|SvNOK_on|SV* sv
Tells an SV that it is a double.

=for apidoc Am|void|SvNOK_off|SV* sv
Unsets the NV status of an SV.

=for apidoc Am|void|SvNOK_only|SV* sv
Tells an SV that it is a double and disables all other OK bits.

=for apidoc Am|U32|SvPOK|SV* sv
Returns a U32 value indicating whether the SV contains a character
string.

=for apidoc Am|void|SvPOK_on|SV* sv
Tells an SV that it is a string.

=for apidoc Am|void|SvPOK_off|SV* sv
Unsets the PV status of an SV.

=for apidoc Am|void|SvPOK_only|SV* sv
Tells an SV that it is a string and disables all other C<OK> bits.
Will also turn off the UTF-8 status.

=for apidoc Am|bool|SvVOK|SV* sv
Returns a boolean indicating whether the SV contains a v-string.

=for apidoc Am|U32|SvOOK|SV* sv
Returns a U32 indicating whether the pointer to the string buffer is offset.
This hack is used internally to speed up removal of characters from the
beginning of a C<SvPV>.  When C<SvOOK> is true, then the start of the
allocated string buffer is actually C<SvOOK_offset()> bytes before C<SvPVX>.
This offset used to be stored in C<SvIVX>, but is now stored within the spare
part of the buffer.

=for apidoc Am|U32|SvROK|SV* sv
Tests if the SV is an RV.

=for apidoc Am|void|SvROK_on|SV* sv
Tells an SV that it is an RV.

=for apidoc Am|void|SvROK_off|SV* sv
Unsets the RV status of an SV.

=for apidoc Am|SV*|SvRV|SV* sv
Dereferences an RV to return the SV.

=for apidoc Am|IV|SvIVX|SV* sv
Returns the raw value in the SV's IV slot, without checks or conversions.
Only use when you are sure C<SvIOK> is true.  See also C<L</SvIV>>.

=for apidoc Am|UV|SvUVX|SV* sv
Returns the raw value in the SV's UV slot, without checks or conversions.
Only use when you are sure C<SvIOK> is true.  See also C<L</SvUV>>.

=for apidoc Am|NV|SvNVX|SV* sv
Returns the raw value in the SV's NV slot, without checks or conversions.
Only use when you are sure C<SvNOK> is true.  See also C<L</SvNV>>.

=for apidoc Am|char*|SvPVX|SV* sv
Returns a pointer to the physical string in the SV.  The SV must contain a
string.  Prior to 5.9.3 it is not safe
to execute this macro unless the SV's
type >= C<SVt_PV>.

This is also used to store the name of an autoloaded subroutine in an XS
AUTOLOAD routine.  See L<perlguts/Autoloading with XSUBs>.

=for apidoc Am|STRLEN|SvCUR|SV* sv
Returns the length of the string which is in the SV.  See C<L</SvLEN>>.

=for apidoc Am|STRLEN|SvLEN|SV* sv
Returns the size of the string buffer in the SV, not including any part
attributable to C<SvOOK>.  See C<L</SvCUR>>.

=for apidoc Am|char*|SvEND|SV* sv
Returns a pointer to the spot just after the last character in
the string which is in the SV, where there is usually a trailing
C<NUL> character (even though Perl scalars do not strictly require it).
See C<L</SvCUR>>.  Access the character as C<*(SvEND(sv))>.

Warning: If C<SvCUR> is equal to C<SvLEN>, then C<SvEND> points to
unallocated memory.

=for apidoc Am|HV*|SvSTASH|SV* sv
Returns the stash of the SV.

=for apidoc Am|void|SvIV_set|SV* sv|IV val
Set the value of the IV pointer in sv to val.  It is possible to perform
the same function of this macro with an lvalue assignment to C<SvIVX>.
With future Perls, however, it will be more efficient to use 
C<SvIV_set> instead of the lvalue assignment to C<SvIVX>.

=for apidoc Am|void|SvNV_set|SV* sv|NV val
Set the value of the NV pointer in C<sv> to val.  See C<L</SvIV_set>>.

=for apidoc Am|void|SvPV_set|SV* sv|char* val
This is probably not what you want to use, you probably wanted
L</sv_usepvn_flags> or L</sv_setpvn> or L</sv_setpvs>.

Set the value of the PV pointer in C<sv> to the Perl allocated
C<NUL>-terminated string C<val>.  See also C<L</SvIV_set>>.

Remember to free the previous PV buffer. There are many things to check.
Beware that the existing pointer may be involved in copy-on-write or other
mischief, so do C<SvOOK_off(sv)> and use C<sv_force_normal> or
C<SvPV_force> (or check the C<SvIsCOW> flag) first to make sure this
modification is safe. Then finally, if it is not a COW, call C<SvPV_free> to
free the previous PV buffer.

=for apidoc Am|void|SvUV_set|SV* sv|UV val
Set the value of the UV pointer in C<sv> to val.  See C<L</SvIV_set>>.

=for apidoc Am|void|SvRV_set|SV* sv|SV* val
Set the value of the RV pointer in C<sv> to val.  See C<L</SvIV_set>>.

=for apidoc Am|void|SvMAGIC_set|SV* sv|MAGIC* val
Set the value of the MAGIC pointer in C<sv> to val.  See C<L</SvIV_set>>.

=for apidoc Am|void|SvSTASH_set|SV* sv|HV* val
Set the value of the STASH pointer in C<sv> to val.  See C<L</SvIV_set>>.

=for apidoc Am|void|SvCUR_set|SV* sv|STRLEN len
Set the current length of the string which is in the SV.  See C<L</SvCUR>>
and C<SvIV_set>>.

=for apidoc Am|void|SvLEN_set|SV* sv|STRLEN len
Set the size of the string buffer for the SV. See C<L</SvLEN>>.

=cut
*/

#define SvNIOK(sv)		(SvFLAGS(sv) & (SVf_IOK|SVf_NOK))
#define SvNIOKp(sv)		(SvFLAGS(sv) & (SVp_IOK|SVp_NOK))
#define SvNIOK_off(sv)		(SvFLAGS(sv) &= ~(SVf_IOK|SVf_NOK| \
						  SVp_IOK|SVp_NOK|SVf_IVisUV))

#define assert_not_ROK(sv)	assert_(!SvROK(sv) || !SvRV(sv))
#define assert_not_glob(sv)	assert_(!isGV_with_GP(sv))

#define SvOK(sv)		(SvFLAGS(sv) & SVf_OK || isREGEXP(sv))
#define SvOK_off(sv)		(assert_not_ROK(sv) assert_not_glob(sv)	\
				 SvFLAGS(sv) &=	~(SVf_OK|		\
						  SVf_IVisUV|SVf_UTF8),	\
							SvOOK_off(sv))
#define SvOK_off_exc_UV(sv)	(assert_not_ROK(sv)			\
				 SvFLAGS(sv) &=	~(SVf_OK|		\
						  SVf_UTF8),		\
							SvOOK_off(sv))

#define SvOKp(sv)		(SvFLAGS(sv) & (SVp_IOK|SVp_NOK|SVp_POK))
#define SvIOKp(sv)		(SvFLAGS(sv) & SVp_IOK)
#define SvIOKp_on(sv)		(assert_not_glob(sv)	\
				    SvFLAGS(sv) |= SVp_IOK)
#define SvNOKp(sv)		(SvFLAGS(sv) & SVp_NOK)
#define SvNOKp_on(sv)		(assert_not_glob(sv) SvFLAGS(sv) |= SVp_NOK)
#define SvPOKp(sv)		(SvFLAGS(sv) & SVp_POK)
#define SvPOKp_on(sv)		(assert_not_ROK(sv) assert_not_glob(sv)	\
				 SvFLAGS(sv) |= SVp_POK)

#define SvIOK(sv)		(SvFLAGS(sv) & SVf_IOK)
#define SvIOK_on(sv)		(assert_not_glob(sv)	\
				    SvFLAGS(sv) |= (SVf_IOK|SVp_IOK))
#define SvIOK_off(sv)		(SvFLAGS(sv) &= ~(SVf_IOK|SVp_IOK|SVf_IVisUV))
#define SvIOK_only(sv)		(SvOK_off(sv), \
				    SvFLAGS(sv) |= (SVf_IOK|SVp_IOK))
#define SvIOK_only_UV(sv)	(assert_not_glob(sv) SvOK_off_exc_UV(sv), \
				    SvFLAGS(sv) |= (SVf_IOK|SVp_IOK))

#define SvIOK_UV(sv)		((SvFLAGS(sv) & (SVf_IOK|SVf_IVisUV))	\
				 == (SVf_IOK|SVf_IVisUV))
#define SvUOK(sv)		SvIOK_UV(sv)
#define SvIOK_notUV(sv)		((SvFLAGS(sv) & (SVf_IOK|SVf_IVisUV))	\
				 == SVf_IOK)

#define SvIsUV(sv)		(SvFLAGS(sv) & SVf_IVisUV)
#define SvIsUV_on(sv)		(SvFLAGS(sv) |= SVf_IVisUV)
#define SvIsUV_off(sv)		(SvFLAGS(sv) &= ~SVf_IVisUV)

#define SvNOK(sv)		(SvFLAGS(sv) & SVf_NOK)
#define SvNOK_on(sv)		(assert_not_glob(sv) \
				 SvFLAGS(sv) |= (SVf_NOK|SVp_NOK))
#define SvNOK_off(sv)		(SvFLAGS(sv) &= ~(SVf_NOK|SVp_NOK))
#define SvNOK_only(sv)		(SvOK_off(sv), \
				    SvFLAGS(sv) |= (SVf_NOK|SVp_NOK))

/*
=for apidoc Am|U32|SvUTF8|SV* sv
Returns a U32 value indicating the UTF-8 status of an SV.  If things are set-up
properly, this indicates whether or not the SV contains UTF-8 encoded data.
You should use this I<after> a call to C<SvPV()> or one of its variants, in
case any call to string overloading updates the internal flag.

If you want to take into account the L<bytes> pragma, use C<L</DO_UTF8>>
instead.

=for apidoc Am|void|SvUTF8_on|SV *sv
Turn on the UTF-8 status of an SV (the data is not changed, just the flag).
Do not use frivolously.

=for apidoc Am|void|SvUTF8_off|SV *sv
Unsets the UTF-8 status of an SV (the data is not changed, just the flag).
Do not use frivolously.

=for apidoc Am|void|SvPOK_only_UTF8|SV* sv
Tells an SV that it is a string and disables all other C<OK> bits,
and leaves the UTF-8 status as it was.

=cut
 */

/* Ensure the return value of this macro does not clash with the GV_ADD* flags
in gv.h: */
#define SvUTF8(sv)		(SvFLAGS(sv) & SVf_UTF8)
#define SvUTF8_on(sv)		(SvFLAGS(sv) |= (SVf_UTF8))
#define SvUTF8_off(sv)		(SvFLAGS(sv) &= ~(SVf_UTF8))

#define SvPOK(sv)		(SvFLAGS(sv) & SVf_POK)
#define SvPOK_on(sv)		(assert_not_ROK(sv) assert_not_glob(sv)	\
				 SvFLAGS(sv) |= (SVf_POK|SVp_POK))
#define SvPOK_off(sv)		(SvFLAGS(sv) &= ~(SVf_POK|SVp_POK))
#define SvPOK_only(sv)		(assert_not_ROK(sv) assert_not_glob(sv)	\
				 SvFLAGS(sv) &= ~(SVf_OK|		\
						  SVf_IVisUV|SVf_UTF8),	\
				    SvFLAGS(sv) |= (SVf_POK|SVp_POK))
#define SvPOK_only_UTF8(sv)	(assert_not_ROK(sv) assert_not_glob(sv)	\
				 SvFLAGS(sv) &= ~(SVf_OK|		\
						  SVf_IVisUV),		\
				    SvFLAGS(sv) |= (SVf_POK|SVp_POK))

#define SvVOK(sv)		(SvMAGICAL(sv)				\
				 && mg_find(sv,PERL_MAGIC_vstring))
/* returns the vstring magic, if any */
#define SvVSTRING_mg(sv)	(SvMAGICAL(sv) \
				 ? mg_find(sv,PERL_MAGIC_vstring) : NULL)

#define SvOOK(sv)		(SvFLAGS(sv) & SVf_OOK)
#define SvOOK_on(sv)		(SvFLAGS(sv) |= SVf_OOK)
#define SvOOK_off(sv)		((void)(SvOOK(sv) && (sv_backoff(sv),0)))

#define SvFAKE(sv)		(SvFLAGS(sv) & SVf_FAKE)
#define SvFAKE_on(sv)		(SvFLAGS(sv) |= SVf_FAKE)
#define SvFAKE_off(sv)		(SvFLAGS(sv) &= ~SVf_FAKE)

#define SvROK(sv)		(SvFLAGS(sv) & SVf_ROK)
#define SvROK_on(sv)		(SvFLAGS(sv) |= SVf_ROK)
#define SvROK_off(sv)		(SvFLAGS(sv) &= ~(SVf_ROK))

#define SvMAGICAL(sv)		(SvFLAGS(sv) & (SVs_GMG|SVs_SMG|SVs_RMG))
#define SvMAGICAL_on(sv)	(SvFLAGS(sv) |= (SVs_GMG|SVs_SMG|SVs_RMG))
#define SvMAGICAL_off(sv)	(SvFLAGS(sv) &= ~(SVs_GMG|SVs_SMG|SVs_RMG))

#define SvGMAGICAL(sv)		(SvFLAGS(sv) & SVs_GMG)
#define SvGMAGICAL_on(sv)	(SvFLAGS(sv) |= SVs_GMG)
#define SvGMAGICAL_off(sv)	(SvFLAGS(sv) &= ~SVs_GMG)

#define SvSMAGICAL(sv)		(SvFLAGS(sv) & SVs_SMG)
#define SvSMAGICAL_on(sv)	(SvFLAGS(sv) |= SVs_SMG)
#define SvSMAGICAL_off(sv)	(SvFLAGS(sv) &= ~SVs_SMG)

#define SvRMAGICAL(sv)		(SvFLAGS(sv) & SVs_RMG)
#define SvRMAGICAL_on(sv)	(SvFLAGS(sv) |= SVs_RMG)
#define SvRMAGICAL_off(sv)	(SvFLAGS(sv) &= ~SVs_RMG)

#define SvAMAGIC(sv)		(SvROK(sv) && SvOBJECT(SvRV(sv)) &&	\
				 HvAMAGIC(SvSTASH(SvRV(sv))))

/* To be used on the stashes themselves: */
#define HvAMAGIC(hv)		(SvFLAGS(hv) & SVf_AMAGIC)
#define HvAMAGIC_on(hv)		(SvFLAGS(hv) |= SVf_AMAGIC)
#define HvAMAGIC_off(hv)	(SvFLAGS(hv) &=~ SVf_AMAGIC)


/* "nog" means "doesn't have get magic" */
#define SvPOK_nog(sv)		((SvFLAGS(sv) & (SVf_POK|SVs_GMG)) == SVf_POK)
#define SvIOK_nog(sv)		((SvFLAGS(sv) & (SVf_IOK|SVs_GMG)) == SVf_IOK)
#define SvUOK_nog(sv)		((SvFLAGS(sv) & (SVf_IOK|SVf_IVisUV|SVs_GMG)) == (SVf_IOK|SVf_IVisUV))
#define SvNOK_nog(sv)		((SvFLAGS(sv) & (SVf_NOK|SVs_GMG)) == SVf_NOK)
#define SvNIOK_nog(sv)		(SvNIOK(sv) && !(SvFLAGS(sv) & SVs_GMG))

#define SvPOK_nogthink(sv)	((SvFLAGS(sv) & (SVf_POK|SVf_THINKFIRST|SVs_GMG)) == SVf_POK)
#define SvIOK_nogthink(sv)	((SvFLAGS(sv) & (SVf_IOK|SVf_THINKFIRST|SVs_GMG)) == SVf_IOK)
#define SvUOK_nogthink(sv)	((SvFLAGS(sv) & (SVf_IOK|SVf_IVisUV|SVf_THINKFIRST|SVs_GMG)) == (SVf_IOK|SVf_IVisUV))
#define SvNOK_nogthink(sv)	((SvFLAGS(sv) & (SVf_NOK|SVf_THINKFIRST|SVs_GMG)) == SVf_NOK)
#define SvNIOK_nogthink(sv)	(SvNIOK(sv) && !(SvFLAGS(sv) & (SVf_THINKFIRST|SVs_GMG)))

#define SvPOK_utf8_nog(sv)	((SvFLAGS(sv) & (SVf_POK|SVf_UTF8|SVs_GMG)) == (SVf_POK|SVf_UTF8))
#define SvPOK_utf8_nogthink(sv)	((SvFLAGS(sv) & (SVf_POK|SVf_UTF8|SVf_THINKFIRST|SVs_GMG)) == (SVf_POK|SVf_UTF8))

#define SvPOK_byte_nog(sv)	((SvFLAGS(sv) & (SVf_POK|SVf_UTF8|SVs_GMG)) == SVf_POK)
#define SvPOK_byte_nogthink(sv)	((SvFLAGS(sv) & (SVf_POK|SVf_UTF8|SVf_THINKFIRST|SVs_GMG)) == SVf_POK)

#define SvPOK_pure_nogthink(sv) \
    ((SvFLAGS(sv) & (SVf_POK|SVf_IOK|SVf_NOK|SVf_ROK|SVpgv_GP|SVf_THINKFIRST|SVs_GMG)) == SVf_POK)
#define SvPOK_utf8_pure_nogthink(sv) \
    ((SvFLAGS(sv) & (SVf_POK|SVf_UTF8|SVf_IOK|SVf_NOK|SVf_ROK|SVpgv_GP|SVf_THINKFIRST|SVs_GMG)) == (SVf_POK|SVf_UTF8))
#define SvPOK_byte_pure_nogthink(sv) \
    ((SvFLAGS(sv) & (SVf_POK|SVf_UTF8|SVf_IOK|SVf_NOK|SVf_ROK|SVpgv_GP|SVf_THINKFIRST|SVs_GMG)) == SVf_POK)

/*
=for apidoc Am|U32|SvGAMAGIC|SV* sv

Returns true if the SV has get magic or
overloading.  If either is true then
the scalar is active data, and has the potential to return a new value every
time it is accessed.  Hence you must be careful to
only read it once per user logical operation and work
with that returned value.  If neither is true then
the scalar's value cannot change unless written to.

=cut
*/

#define SvGAMAGIC(sv)           (SvGMAGICAL(sv) || SvAMAGIC(sv))

#define Gv_AMG(stash) \
	(HvNAME(stash) && Gv_AMupdate(stash,FALSE) \
	    ? 1					    \
	    : (HvAMAGIC_off(stash), 0))

#define SvWEAKREF(sv)		((SvFLAGS(sv) & (SVf_ROK|SVprv_WEAKREF)) \
				  == (SVf_ROK|SVprv_WEAKREF))
#define SvWEAKREF_on(sv)	(SvFLAGS(sv) |=  (SVf_ROK|SVprv_WEAKREF))
#define SvWEAKREF_off(sv)	(SvFLAGS(sv) &= ~(SVf_ROK|SVprv_WEAKREF))

#define SvPCS_IMPORTED(sv)	((SvFLAGS(sv) & (SVf_ROK|SVprv_PCS_IMPORTED)) \
				 == (SVf_ROK|SVprv_PCS_IMPORTED))
#define SvPCS_IMPORTED_on(sv)	(SvFLAGS(sv) |=  (SVf_ROK|SVprv_PCS_IMPORTED))
#define SvPCS_IMPORTED_off(sv)	(SvFLAGS(sv) &= ~(SVf_ROK|SVprv_PCS_IMPORTED))

/*
=for apidoc m|U32|SvTHINKFIRST|SV *sv

A quick flag check to see whether an C<sv> should be passed to C<sv_force_normal>
to be "downgraded" before C<SvIVX> or C<SvPVX> can be modified directly.

For example, if your scalar is a reference and you want to modify the C<SvIVX>
slot, you can't just do C<SvROK_off>, as that will leak the referent.

This is used internally by various sv-modifying functions, such as
C<sv_setsv>, C<sv_setiv> and C<sv_pvn_force>.

One case that this does not handle is a gv without SvFAKE set.  After

    if (SvTHINKFIRST(gv)) sv_force_normal(gv);

it will still be a gv.

C<SvTHINKFIRST> sometimes produces false positives.  In those cases
C<sv_force_normal> does nothing.

=cut
*/

#define SvTHINKFIRST(sv)	(SvFLAGS(sv) & SVf_THINKFIRST)

#define SVs_PADMY		0
#define SvPADMY(sv)		!(SvFLAGS(sv) & SVs_PADTMP)
#ifndef PERL_CORE
# define SvPADMY_on(sv)		SvPADTMP_off(sv)
#endif

#define SvPADTMP(sv)		(SvFLAGS(sv) & (SVs_PADTMP))
#define SvPADSTALE(sv)		(SvFLAGS(sv) & (SVs_PADSTALE))

#define SvPADTMP_on(sv)		(SvFLAGS(sv) |= SVs_PADTMP)
#define SvPADTMP_off(sv)	(SvFLAGS(sv) &= ~SVs_PADTMP)
#define SvPADSTALE_on(sv)	S_SvPADSTALE_on(MUTABLE_SV(sv))
#define SvPADSTALE_off(sv)	S_SvPADSTALE_off(MUTABLE_SV(sv))

#define SvTEMP(sv)		(SvFLAGS(sv) & SVs_TEMP)
#define SvTEMP_on(sv)		(SvFLAGS(sv) |= SVs_TEMP)
#define SvTEMP_off(sv)		(SvFLAGS(sv) &= ~SVs_TEMP)

#define SvOBJECT(sv)		(SvFLAGS(sv) & SVs_OBJECT)
#define SvOBJECT_on(sv)		(SvFLAGS(sv) |= SVs_OBJECT)
#define SvOBJECT_off(sv)	(SvFLAGS(sv) &= ~SVs_OBJECT)

#define SvREADONLY(sv)		(SvFLAGS(sv) & (SVf_READONLY|SVf_PROTECT))
#ifdef PERL_CORE
# define SvREADONLY_on(sv)	(SvFLAGS(sv) |= (SVf_READONLY|SVf_PROTECT))
# define SvREADONLY_off(sv)	(SvFLAGS(sv) &=~(SVf_READONLY|SVf_PROTECT))
#else
# define SvREADONLY_on(sv)	(SvFLAGS(sv) |= SVf_READONLY)
# define SvREADONLY_off(sv)	(SvFLAGS(sv) &= ~SVf_READONLY)
#endif

#define SvSCREAM(sv) ((SvFLAGS(sv) & (SVp_SCREAM|SVp_POK)) == (SVp_SCREAM|SVp_POK))
#define SvSCREAM_on(sv)		(SvFLAGS(sv) |= SVp_SCREAM)
#define SvSCREAM_off(sv)	(SvFLAGS(sv) &= ~SVp_SCREAM)

#ifndef PERL_CORE
#  define SvCOMPILED(sv)	0
#  define SvCOMPILED_on(sv)
#  define SvCOMPILED_off(sv)
#endif

#define SvEVALED(sv)		(SvFLAGS(sv) & SVrepl_EVAL)
#define SvEVALED_on(sv)		(SvFLAGS(sv) |= SVrepl_EVAL)
#define SvEVALED_off(sv)	(SvFLAGS(sv) &= ~SVrepl_EVAL)

#if defined (DEBUGGING) && defined(__GNUC__) && !defined(PERL_GCC_BRACE_GROUPS_FORBIDDEN)
#  define SvVALID(sv)		({ const SV *const _svvalid = (const SV*)(sv); \
				   if (SvFLAGS(_svvalid) & SVpbm_VALID && !SvSCREAM(_svvalid)) \
				       assert(!isGV_with_GP(_svvalid));	\
				   (SvFLAGS(_svvalid) & SVpbm_VALID);	\
				})
#  define SvVALID_on(sv)	({ SV *const _svvalid = MUTABLE_SV(sv);	\
				   assert(!isGV_with_GP(_svvalid));	\
				   assert(!SvSCREAM(_svvalid));		\
				   (SvFLAGS(_svvalid) |= SVpbm_VALID);	\
				})
#  define SvVALID_off(sv)	({ SV *const _svvalid = MUTABLE_SV(sv);	\
				   assert(!isGV_with_GP(_svvalid));	\
				   assert(!SvSCREAM(_svvalid));		\
				   (SvFLAGS(_svvalid) &= ~SVpbm_VALID);	\
				})

#  define SvTAIL(sv)	({ const SV *const _svtail = (const SV *)(sv);	\
			    assert(SvTYPE(_svtail) != SVt_PVAV);	\
			    assert(SvTYPE(_svtail) != SVt_PVHV);	\
			    assert(!SvSCREAM(_svtail));			\
			    (SvFLAGS(sv) & (SVpbm_TAIL|SVpbm_VALID))	\
				== (SVpbm_TAIL|SVpbm_VALID);		\
			})
#else
#  define SvVALID(sv)		((SvFLAGS(sv) & SVpbm_VALID) && !SvSCREAM(sv))
#  define SvVALID_on(sv)	(SvFLAGS(sv) |= SVpbm_VALID)
#  define SvVALID_off(sv)	(SvFLAGS(sv) &= ~SVpbm_VALID)
#  define SvTAIL(sv)	    ((SvFLAGS(sv) & (SVpbm_TAIL|SVpbm_VALID))	\
			     == (SVpbm_TAIL|SVpbm_VALID))

#endif
#define SvTAIL_on(sv)		(SvFLAGS(sv) |= SVpbm_TAIL)
#define SvTAIL_off(sv)		(SvFLAGS(sv) &= ~SVpbm_TAIL)

#define SvRVx(sv) SvRV(sv)

#ifdef PERL_DEBUG_COW
/* Need -0.0 for SvNVX to preserve IEEE FP "negative zero" because
   +0.0 + -0.0 => +0.0 but -0.0 + -0.0 => -0.0 */
#  define SvIVX(sv) (0 + ((XPVIV*) SvANY(sv))->xiv_iv)
#  define SvUVX(sv) (0 + ((XPVUV*) SvANY(sv))->xuv_uv)
#  define SvNVX(sv) (-0.0 + ((XPVNV*) SvANY(sv))->xnv_u.xnv_nv)
#  define SvRV(sv) (0 + (sv)->sv_u.svu_rv)
#  define SvRV_const(sv) (0 + (sv)->sv_u.svu_rv)
/* Don't test the core XS code yet.  */
#  if defined (PERL_CORE) && PERL_DEBUG_COW > 1
#    define SvPVX(sv) (0 + (assert_(!SvREADONLY(sv)) (sv)->sv_u.svu_pv))
#  else
#  define SvPVX(sv) SvPVX_mutable(sv)
#  endif
#  define SvCUR(sv) (0 + ((XPV*) SvANY(sv))->xpv_cur)
#  define SvLEN(sv) (0 + ((XPV*) SvANY(sv))->xpv_len)
#  define SvEND(sv) ((sv)->sv_u.svu_pv + ((XPV*)SvANY(sv))->xpv_cur)

#  define SvMAGIC(sv)	(0 + *(assert_(SvTYPE(sv) >= SVt_PVMG) &((XPVMG*)  SvANY(sv))->xmg_u.xmg_magic))
#  define SvSTASH(sv)	(0 + *(assert_(SvTYPE(sv) >= SVt_PVMG) &((XPVMG*)  SvANY(sv))->xmg_stash))
#else
#  define SvLEN(sv) ((XPV*) SvANY(sv))->xpv_len
#  define SvEND(sv) ((sv)->sv_u.svu_pv + ((XPV*)SvANY(sv))->xpv_cur)

#  if defined (DEBUGGING) && defined(__GNUC__) && !defined(PERL_GCC_BRACE_GROUPS_FORBIDDEN)
/* These get expanded inside other macros that already use a variable _sv  */
#    define SvPVX(sv)							\
	(*({ SV *const _svpvx = MUTABLE_SV(sv);				\
	    assert(PL_valid_types_PVX[SvTYPE(_svpvx) & SVt_MASK]);	\
	    assert(!isGV_with_GP(_svpvx));				\
	    assert(!(SvTYPE(_svpvx) == SVt_PVIO				\
		     && !(IoFLAGS(_svpvx) & IOf_FAKE_DIRP)));		\
	    &((_svpvx)->sv_u.svu_pv);					\
	 }))
#    define SvCUR(sv)							\
	(*({ const SV *const _svcur = (const SV *)(sv);			\
	    assert(PL_valid_types_PVX[SvTYPE(_svcur) & SVt_MASK]	\
		|| SvTYPE(_svcur) == SVt_REGEXP);			\
	    assert(!isGV_with_GP(_svcur));				\
	    assert(!(SvTYPE(_svcur) == SVt_PVIO				\
		     && !(IoFLAGS(_svcur) & IOf_FAKE_DIRP)));		\
	    &(((XPV*) MUTABLE_PTR(SvANY(_svcur)))->xpv_cur);		\
	 }))
#    define SvIVX(sv)							\
	(*({ const SV *const _svivx = (const SV *)(sv);			\
	    assert(PL_valid_types_IVX[SvTYPE(_svivx) & SVt_MASK]);	\
	    assert(!isGV_with_GP(_svivx));				\
	    &(((XPVIV*) MUTABLE_PTR(SvANY(_svivx)))->xiv_iv);		\
	 }))
#    define SvUVX(sv)							\
	(*({ const SV *const _svuvx = (const SV *)(sv);			\
	    assert(PL_valid_types_IVX[SvTYPE(_svuvx) & SVt_MASK]);	\
	    assert(!isGV_with_GP(_svuvx));				\
	    &(((XPVUV*) MUTABLE_PTR(SvANY(_svuvx)))->xuv_uv);		\
	 }))
#    define SvNVX(sv)							\
	(*({ const SV *const _svnvx = (const SV *)(sv);			\
	    assert(PL_valid_types_NVX[SvTYPE(_svnvx) & SVt_MASK]);	\
	    assert(!isGV_with_GP(_svnvx));				\
	    &(((XPVNV*) MUTABLE_PTR(SvANY(_svnvx)))->xnv_u.xnv_nv);	\
	 }))
#    define SvRV(sv)							\
	(*({ SV *const _svrv = MUTABLE_SV(sv);				\
	    assert(PL_valid_types_RV[SvTYPE(_svrv) & SVt_MASK]);	\
	    assert(!isGV_with_GP(_svrv));				\
	    assert(!(SvTYPE(_svrv) == SVt_PVIO				\
		     && !(IoFLAGS(_svrv) & IOf_FAKE_DIRP)));		\
	    &((_svrv)->sv_u.svu_rv);					\
	 }))
#    define SvRV_const(sv)						\
	({ const SV *const _svrv = (const SV *)(sv);			\
	    assert(PL_valid_types_RV[SvTYPE(_svrv) & SVt_MASK]);	\
	    assert(!isGV_with_GP(_svrv));				\
	    assert(!(SvTYPE(_svrv) == SVt_PVIO				\
		     && !(IoFLAGS(_svrv) & IOf_FAKE_DIRP)));		\
	    (_svrv)->sv_u.svu_rv;					\
	 })
#    define SvMAGIC(sv)							\
	(*({ const SV *const _svmagic = (const SV *)(sv);		\
	    assert(SvTYPE(_svmagic) >= SVt_PVMG);			\
	    &(((XPVMG*) MUTABLE_PTR(SvANY(_svmagic)))->xmg_u.xmg_magic); \
	  }))
#    define SvSTASH(sv)							\
	(*({ const SV *const _svstash = (const SV *)(sv);		\
	    assert(SvTYPE(_svstash) >= SVt_PVMG);			\
	    &(((XPVMG*) MUTABLE_PTR(SvANY(_svstash)))->xmg_stash);	\
	  }))
#  else
#    define SvPVX(sv) ((sv)->sv_u.svu_pv)
#    define SvCUR(sv) ((XPV*) SvANY(sv))->xpv_cur
#    define SvIVX(sv) ((XPVIV*) SvANY(sv))->xiv_iv
#    define SvUVX(sv) ((XPVUV*) SvANY(sv))->xuv_uv
#    define SvNVX(sv) ((XPVNV*) SvANY(sv))->xnv_u.xnv_nv
#    define SvRV(sv) ((sv)->sv_u.svu_rv)
#    define SvRV_const(sv) (0 + (sv)->sv_u.svu_rv)
#    define SvMAGIC(sv)	((XPVMG*)  SvANY(sv))->xmg_u.xmg_magic
#    define SvSTASH(sv)	((XPVMG*)  SvANY(sv))->xmg_stash
#  endif
#endif

#ifndef PERL_POISON
/* Given that these two are new, there can't be any existing code using them
 *  as LVALUEs  */
#  define SvPVX_mutable(sv)	(0 + (sv)->sv_u.svu_pv)
#  define SvPVX_const(sv)	((const char*)(0 + (sv)->sv_u.svu_pv))
#else
/* Except for the poison code, which uses & to scribble over the pointer after
   free() is called.  */
#  define SvPVX_mutable(sv)	((sv)->sv_u.svu_pv)
#  define SvPVX_const(sv)	((const char*)((sv)->sv_u.svu_pv))
#endif

#define SvIVXx(sv) SvIVX(sv)
#define SvUVXx(sv) SvUVX(sv)
#define SvNVXx(sv) SvNVX(sv)
#define SvPVXx(sv) SvPVX(sv)
#define SvLENx(sv) SvLEN(sv)
#define SvENDx(sv) ((PL_Sv = (sv)), SvEND(PL_Sv))


/* Ask a scalar nicely to try to become an IV, if possible.
   Not guaranteed to stay returning void */
/* Macro won't actually call sv_2iv if already IOK */
#define SvIV_please(sv) \
	STMT_START {if (!SvIOKp(sv) && (SvFLAGS(sv) & (SVf_NOK|SVf_POK))) \
		(void) SvIV(sv); } STMT_END
#define SvIV_please_nomg(sv) \
	(!(SvFLAGS(sv) & (SVf_IOK|SVp_IOK)) && (SvFLAGS(sv) & (SVf_NOK|SVf_POK)) \
	    ? (sv_2iv_flags(sv, 0), SvIOK(sv))	  \
	    : SvIOK(sv))
#define SvIV_set(sv, val) \
	STMT_START { \
		assert(PL_valid_types_IV_set[SvTYPE(sv) & SVt_MASK]);	\
		assert(!isGV_with_GP(sv));		\
		(((XPVIV*)  SvANY(sv))->xiv_iv = (val)); } STMT_END
#define SvNV_set(sv, val) \
	STMT_START { \
		assert(PL_valid_types_NV_set[SvTYPE(sv) & SVt_MASK]);	\
		assert(!isGV_with_GP(sv));		\
		(((XPVNV*)SvANY(sv))->xnv_u.xnv_nv = (val)); } STMT_END
#define SvPV_set(sv, val) \
	STMT_START { \
		assert(PL_valid_types_PVX[SvTYPE(sv) & SVt_MASK]);	\
		assert(!isGV_with_GP(sv));		\
		assert(!(SvTYPE(sv) == SVt_PVIO		\
		     && !(IoFLAGS(sv) & IOf_FAKE_DIRP))); \
		((sv)->sv_u.svu_pv = (val)); } STMT_END
#define SvUV_set(sv, val) \
	STMT_START { \
		assert(PL_valid_types_IV_set[SvTYPE(sv) & SVt_MASK]);	\
		assert(!isGV_with_GP(sv));		\
		(((XPVUV*)SvANY(sv))->xuv_uv = (val)); } STMT_END
#define SvRV_set(sv, val) \
        STMT_START { \
		assert(PL_valid_types_RV[SvTYPE(sv) & SVt_MASK]);	\
		assert(!isGV_with_GP(sv));		\
		assert(!(SvTYPE(sv) == SVt_PVIO		\
		     && !(IoFLAGS(sv) & IOf_FAKE_DIRP))); \
                ((sv)->sv_u.svu_rv = (val)); } STMT_END
#define SvMAGIC_set(sv, val) \
        STMT_START { assert(SvTYPE(sv) >= SVt_PVMG); \
                (((XPVMG*)SvANY(sv))->xmg_u.xmg_magic = (val)); } STMT_END
#define SvSTASH_set(sv, val) \
        STMT_START { assert(SvTYPE(sv) >= SVt_PVMG); \
                (((XPVMG*)  SvANY(sv))->xmg_stash = (val)); } STMT_END
#define SvCUR_set(sv, val) \
	STMT_START { \
		assert(PL_valid_types_PVX[SvTYPE(sv) & SVt_MASK]	\
			|| SvTYPE(sv) == SVt_REGEXP);	\
		assert(!isGV_with_GP(sv));		\
		assert(!(SvTYPE(sv) == SVt_PVIO		\
		     && !(IoFLAGS(sv) & IOf_FAKE_DIRP))); \
		(((XPV*)  SvANY(sv))->xpv_cur = (val)); } STMT_END
#define SvLEN_set(sv, val) \
	STMT_START { \
		assert(PL_valid_types_PVX[SvTYPE(sv) & SVt_MASK]);	\
		assert(!isGV_with_GP(sv));	\
		assert(!(SvTYPE(sv) == SVt_PVIO		\
		     && !(IoFLAGS(sv) & IOf_FAKE_DIRP))); \
		(((XPV*)  SvANY(sv))->xpv_len = (val)); } STMT_END
#define SvEND_set(sv, val) \
	STMT_START { assert(SvTYPE(sv) >= SVt_PV); \
		SvCUR_set(sv, (val) - SvPVX(sv)); } STMT_END

#define SvPV_renew(sv,n) \
	STMT_START { SvLEN_set(sv, n); \
		SvPV_set((sv), (MEM_WRAP_CHECK_(n,char)			\
				(char*)saferealloc((Malloc_t)SvPVX(sv), \
						   (MEM_SIZE)((n)))));  \
		 } STMT_END

#define SvPV_shrink_to_cur(sv) STMT_START { \
		   const STRLEN _lEnGtH = SvCUR(sv) + 1; \
		   SvPV_renew(sv, _lEnGtH); \
		 } STMT_END

#define SvPV_free(sv)							\
    STMT_START {							\
		     assert(SvTYPE(sv) >= SVt_PV);			\
		     if (SvLEN(sv)) {					\
			 assert(!SvROK(sv));				\
			 if(UNLIKELY(SvOOK(sv))) {			\
			     STRLEN zok; 				\
			     SvOOK_offset(sv, zok);			\
			     SvPV_set(sv, SvPVX_mutable(sv) - zok);	\
			     SvFLAGS(sv) &= ~SVf_OOK;			\
			 }						\
			 Safefree(SvPVX(sv));				\
		     }							\
		 } STMT_END

#ifdef PERL_CORE
/* Code that crops up in three places to take a scalar and ready it to hold
   a reference */
#  define prepare_SV_for_RV(sv)						\
    STMT_START {							\
		    if (SvTYPE(sv) < SVt_PV && SvTYPE(sv) != SVt_IV)	\
			sv_upgrade(sv, SVt_IV);				\
		    else if (SvTYPE(sv) >= SVt_PV) {			\
			SvPV_free(sv);					\
			SvLEN_set(sv, 0);				\
                        SvCUR_set(sv, 0);				\
		    }							\
		 } STMT_END
#endif

#ifndef PERL_CORE
#  define BmFLAGS(sv)		(SvTAIL(sv) ? FBMcf_TAIL : 0)
#endif

#if defined (DEBUGGING) && defined(__GNUC__) && !defined(PERL_GCC_BRACE_GROUPS_FORBIDDEN)
#  define BmUSEFUL(sv)							\
	(*({ SV *const _bmuseful = MUTABLE_SV(sv);			\
	    assert(SvTYPE(_bmuseful) >= SVt_PVIV);			\
	    assert(SvVALID(_bmuseful));					\
	    assert(!SvIOK(_bmuseful));					\
	    &(((XPVIV*) SvANY(_bmuseful))->xiv_u.xivu_iv);              \
	 }))
#else
#  define BmUSEFUL(sv)          ((XPVIV*) SvANY(sv))->xiv_u.xivu_iv

#endif

#ifndef PERL_CORE
# define BmRARE(sv)	0
# define BmPREVIOUS(sv)	0
#endif

#define FmLINES(sv)	((XPVIV*)  SvANY(sv))->xiv_iv

#define LvTYPE(sv)	((XPVLV*)  SvANY(sv))->xlv_type
#define LvTARG(sv)	((XPVLV*)  SvANY(sv))->xlv_targ
#define LvTARGOFF(sv)	((XPVLV*)  SvANY(sv))->xlv_targoff
#define LvSTARGOFF(sv)	((XPVLV*)  SvANY(sv))->xlv_targoff_u.xlvu_stargoff
#define LvTARGLEN(sv)	((XPVLV*)  SvANY(sv))->xlv_targlen
#define LvFLAGS(sv)	((XPVLV*)  SvANY(sv))->xlv_flags

#define IoIFP(sv)	(sv)->sv_u.svu_fp
#define IoOFP(sv)	((XPVIO*)  SvANY(sv))->xio_ofp
#define IoDIRP(sv)	((XPVIO*)  SvANY(sv))->xio_dirp
#define IoANY(sv)	((XPVIO*)  SvANY(sv))->xio_any
#define IoLINES(sv)	((XPVIO*)  SvANY(sv))->xiv_u.xivu_iv
#define IoPAGE(sv)	((XPVIO*)  SvANY(sv))->xio_page
#define IoPAGE_LEN(sv)	((XPVIO*)  SvANY(sv))->xio_page_len
#define IoLINES_LEFT(sv)((XPVIO*)  SvANY(sv))->xio_lines_left
#define IoTOP_NAME(sv)	((XPVIO*)  SvANY(sv))->xio_top_name
#define IoTOP_GV(sv)	((XPVIO*)  SvANY(sv))->xio_top_gv
#define IoFMT_NAME(sv)	((XPVIO*)  SvANY(sv))->xio_fmt_name
#define IoFMT_GV(sv)	((XPVIO*)  SvANY(sv))->xio_fmt_gv
#define IoBOTTOM_NAME(sv)((XPVIO*) SvANY(sv))->xio_bottom_name
#define IoBOTTOM_GV(sv)	((XPVIO*)  SvANY(sv))->xio_bottom_gv
#define IoTYPE(sv)	((XPVIO*)  SvANY(sv))->xio_type
#define IoFLAGS(sv)	((XPVIO*)  SvANY(sv))->xio_flags

/* IoTYPE(sv) is a single character telling the type of I/O connection. */
#define IoTYPE_RDONLY		'<'
#define IoTYPE_WRONLY		'>'
#define IoTYPE_RDWR		'+'
#define IoTYPE_APPEND 		'a'
#define IoTYPE_PIPE		'|'
#define IoTYPE_STD		'-'	/* stdin or stdout */
#define IoTYPE_SOCKET		's'
#define IoTYPE_CLOSED		' '
#define IoTYPE_IMPLICIT		'I'	/* stdin or stdout or stderr */
#define IoTYPE_NUMERIC		'#'	/* fdopen */

/*
=for apidoc Am|bool|SvTAINTED|SV* sv
Checks to see if an SV is tainted.  Returns TRUE if it is, FALSE if
not.

=for apidoc Am|void|SvTAINTED_on|SV* sv
Marks an SV as tainted if tainting is enabled.

=for apidoc Am|void|SvTAINTED_off|SV* sv
Untaints an SV.  Be I<very> careful with this routine, as it short-circuits
some of Perl's fundamental security features.  XS module authors should not
use this function unless they fully understand all the implications of
unconditionally untainting the value.  Untainting should be done in the
standard perl fashion, via a carefully crafted regexp, rather than directly
untainting variables.

=for apidoc Am|void|SvTAINT|SV* sv
Taints an SV if tainting is enabled, and if some input to the current
expression is tainted--usually a variable, but possibly also implicit
inputs such as locale settings.  C<SvTAINT> propagates that taintedness to
the outputs of an expression in a pessimistic fashion; i.e., without paying
attention to precisely which outputs are influenced by which inputs.

=cut
*/

#define sv_taint(sv)	  sv_magic((sv), NULL, PERL_MAGIC_taint, NULL, 0)

#ifdef NO_TAINT_SUPPORT
#   define SvTAINTED(sv) 0
#else
#   define SvTAINTED(sv)	  (SvMAGICAL(sv) && sv_tainted(sv))
#endif
#define SvTAINTED_on(sv)  STMT_START{ if(UNLIKELY(TAINTING_get)){sv_taint(sv);}   }STMT_END
#define SvTAINTED_off(sv) STMT_START{ if(UNLIKELY(TAINTING_get)){sv_untaint(sv);} }STMT_END

#define SvTAINT(sv)			\
    STMT_START {			\
        assert(TAINTING_get || !TAINT_get); \
        if (UNLIKELY(TAINT_get))	\
            SvTAINTED_on(sv);	        \
    } STMT_END

/*
=for apidoc Am|char*|SvPV_force|SV* sv|STRLEN len
Like C<SvPV> but will force the SV into containing a string (C<SvPOK>), and
only a string (C<SvPOK_only>), by hook or by crook.  You need force if you are
going to update the C<SvPVX> directly.  Processes get magic.

Note that coercing an arbitrary scalar into a plain PV will potentially
strip useful data from it.  For example if the SV was C<SvROK>, then the
referent will have its reference count decremented, and the SV itself may
be converted to an C<SvPOK> scalar with a string buffer containing a value
such as C<"ARRAY(0x1234)">.

=for apidoc Am|char*|SvPV_force_nomg|SV* sv|STRLEN len
Like C<SvPV_force>, but doesn't process get magic.

=for apidoc Am|char*|SvPV|SV* sv|STRLEN len
Returns a pointer to the string in the SV, or a stringified form of
the SV if the SV does not contain a string.  The SV may cache the
stringified version becoming C<SvPOK>.  Handles 'get' magic.  The
C<len> variable will be set to the length of the string (this is a macro, so
don't use C<&len>).  See also C<L</SvPVx>> for a version which guarantees to
evaluate C<sv> only once.

Note that there is no guarantee that the return value of C<SvPV()> is
equal to C<SvPVX(sv)>, or that C<SvPVX(sv)> contains valid data, or that
successive calls to C<SvPV(sv)> will return the same pointer value each
time.  This is due to the way that things like overloading and
Copy-On-Write are handled.  In these cases, the return value may point to
a temporary buffer or similar.  If you absolutely need the C<SvPVX> field to
be valid (for example, if you intend to write to it), then see
C<L</SvPV_force>>.

=for apidoc Am|char*|SvPVx|SV* sv|STRLEN len
A version of C<SvPV> which guarantees to evaluate C<sv> only once.
Only use this if C<sv> is an expression with side effects, otherwise use the
more efficient C<SvPV>.

=for apidoc Am|char*|SvPV_nomg|SV* sv|STRLEN len
Like C<SvPV> but doesn't process magic.

=for apidoc Am|char*|SvPV_nolen|SV* sv
Like C<SvPV> but doesn't set a length variable.

=for apidoc Am|char*|SvPV_nomg_nolen|SV* sv
Like C<SvPV_nolen> but doesn't process magic.

=for apidoc Am|IV|SvIV|SV* sv
Coerces the given SV to an integer and returns it.  See C<L</SvIVx>> for a
version which guarantees to evaluate C<sv> only once.

=for apidoc Am|IV|SvIV_nomg|SV* sv
Like C<SvIV> but doesn't process magic.

=for apidoc Am|IV|SvIVx|SV* sv
Coerces the given SV to an integer and returns it.
Guarantees to evaluate C<sv> only once.  Only use
this if C<sv> is an expression with side effects,
otherwise use the more efficient C<SvIV>.

=for apidoc Am|NV|SvNV|SV* sv
Coerce the given SV to a double and return it.  See C<L</SvNVx>> for a version
which guarantees to evaluate C<sv> only once.

=for apidoc Am|NV|SvNV_nomg|SV* sv
Like C<SvNV> but doesn't process magic.

=for apidoc Am|NV|SvNVx|SV* sv
Coerces the given SV to a double and returns it.
Guarantees to evaluate C<sv> only once.  Only use
this if C<sv> is an expression with side effects,
otherwise use the more efficient C<SvNV>.

=for apidoc Am|UV|SvUV|SV* sv
Coerces the given SV to an unsigned integer and returns it.  See C<L</SvUVx>>
for a version which guarantees to evaluate C<sv> only once.

=for apidoc Am|UV|SvUV_nomg|SV* sv
Like C<SvUV> but doesn't process magic.

=for apidoc Am|UV|SvUVx|SV* sv
Coerces the given SV to an unsigned integer and
returns it.  Guarantees to evaluate C<sv> only once.  Only
use this if C<sv> is an expression with side effects,
otherwise use the more efficient C<SvUV>.

=for apidoc Am|bool|SvTRUE|SV* sv
Returns a boolean indicating whether Perl would evaluate the SV as true or
false.  See C<L</SvOK>> for a defined/undefined test.  Handles 'get' magic
unless the scalar is already C<SvPOK>, C<SvIOK> or C<SvNOK> (the public, not the
private flags).

=for apidoc Am|bool|SvTRUE_nomg|SV* sv
Returns a boolean indicating whether Perl would evaluate the SV as true or
false.  See C<L</SvOK>> for a defined/undefined test.  Does not handle 'get' magic.

=for apidoc Am|char*|SvPVutf8_force|SV* sv|STRLEN len
Like C<SvPV_force>, but converts C<sv> to UTF-8 first if necessary.

=for apidoc Am|char*|SvPVutf8|SV* sv|STRLEN len
Like C<SvPV>, but converts C<sv> to UTF-8 first if necessary.

=for apidoc Am|char*|SvPVutf8_nolen|SV* sv
Like C<SvPV_nolen>, but converts C<sv> to UTF-8 first if necessary.

=for apidoc Am|char*|SvPVbyte_force|SV* sv|STRLEN len
Like C<SvPV_force>, but converts C<sv> to byte representation first if necessary.

=for apidoc Am|char*|SvPVbyte|SV* sv|STRLEN len
Like C<SvPV>, but converts C<sv> to byte representation first if necessary.

=for apidoc Am|char*|SvPVbyte_nolen|SV* sv
Like C<SvPV_nolen>, but converts C<sv> to byte representation first if necessary.

=for apidoc Am|char*|SvPVutf8x_force|SV* sv|STRLEN len
Like C<SvPV_force>, but converts C<sv> to UTF-8 first if necessary.
Guarantees to evaluate C<sv> only once; use the more efficient C<SvPVutf8_force>
otherwise.

=for apidoc Am|char*|SvPVutf8x|SV* sv|STRLEN len
Like C<SvPV>, but converts C<sv> to UTF-8 first if necessary.
Guarantees to evaluate C<sv> only once; use the more efficient C<SvPVutf8>
otherwise.

=for apidoc Am|char*|SvPVbytex_force|SV* sv|STRLEN len
Like C<SvPV_force>, but converts C<sv> to byte representation first if necessary.
Guarantees to evaluate C<sv> only once; use the more efficient C<SvPVbyte_force>
otherwise.

=for apidoc Am|char*|SvPVbytex|SV* sv|STRLEN len
Like C<SvPV>, but converts C<sv> to byte representation first if necessary.
Guarantees to evaluate C<sv> only once; use the more efficient C<SvPVbyte>
otherwise.

=for apidoc Am|U32|SvIsCOW|SV* sv
Returns a U32 value indicating whether the SV is Copy-On-Write (either shared
hash key scalars, or full Copy On Write scalars if 5.9.0 is configured for
COW).

=for apidoc Am|bool|SvIsCOW_shared_hash|SV* sv
Returns a boolean indicating whether the SV is Copy-On-Write shared hash key
scalar.

=for apidoc Am|void|sv_catpvn_nomg|SV* sv|const char* ptr|STRLEN len
Like C<sv_catpvn> but doesn't process magic.

=for apidoc Am|void|sv_catpv_nomg|SV* sv|const char* ptr
Like C<sv_catpv> but doesn't process magic.

=for apidoc Am|void|sv_setsv_nomg|SV* dsv|SV* ssv
Like C<sv_setsv> but doesn't process magic.

=for apidoc Am|void|sv_catsv_nomg|SV* dsv|SV* ssv
Like C<sv_catsv> but doesn't process magic.

=for apidoc Amdb|STRLEN|sv_utf8_upgrade_nomg|NN SV *sv

Like C<sv_utf8_upgrade>, but doesn't do magic on C<sv>.

=cut
*/

/* Let us hope that bitmaps for UV and IV are the same */
#define SvIV(sv) (SvIOK_nog(sv) ? SvIVX(sv) : sv_2iv(sv))
#define SvUV(sv) (SvUOK_nog(sv) ? SvUVX(sv) : sv_2uv(sv))
#define SvNV(sv) (SvNOK_nog(sv) ? SvNVX(sv) : sv_2nv(sv))

#define SvIV_nomg(sv) (SvIOK(sv) ? SvIVX(sv) : sv_2iv_flags(sv, 0))
#define SvUV_nomg(sv) (SvIOK(sv) ? SvUVX(sv) : sv_2uv_flags(sv, 0))
#define SvNV_nomg(sv) (SvNOK(sv) ? SvNVX(sv) : sv_2nv_flags(sv, 0))

/* ----*/

#define SvPV(sv, lp)         SvPV_flags(sv, lp, SV_GMAGIC)
#define SvPV_const(sv, lp)   SvPV_flags_const(sv, lp, SV_GMAGIC)
#define SvPV_mutable(sv, lp) SvPV_flags_mutable(sv, lp, SV_GMAGIC)

#define SvPV_flags(sv, lp, flags) \
    (SvPOK_nog(sv) \
     ? ((lp = SvCUR(sv)), SvPVX(sv)) : sv_2pv_flags(sv, &lp, flags))
#define SvPV_flags_const(sv, lp, flags) \
    (SvPOK_nog(sv) \
     ? ((lp = SvCUR(sv)), SvPVX_const(sv)) : \
     (const char*) sv_2pv_flags(sv, &lp, (flags|SV_CONST_RETURN)))
#define SvPV_flags_const_nolen(sv, flags) \
    (SvPOK_nog(sv) \
     ? SvPVX_const(sv) : \
     (const char*) sv_2pv_flags(sv, 0, (flags|SV_CONST_RETURN)))
#define SvPV_flags_mutable(sv, lp, flags) \
    (SvPOK_nog(sv) \
     ? ((lp = SvCUR(sv)), SvPVX_mutable(sv)) : \
     sv_2pv_flags(sv, &lp, (flags|SV_MUTABLE_RETURN)))

#define SvPV_force(sv, lp) SvPV_force_flags(sv, lp, SV_GMAGIC)
#define SvPV_force_nolen(sv) SvPV_force_flags_nolen(sv, SV_GMAGIC)
#define SvPV_force_mutable(sv, lp) SvPV_force_flags_mutable(sv, lp, SV_GMAGIC)

#define SvPV_force_nomg(sv, lp) SvPV_force_flags(sv, lp, 0)
#define SvPV_force_nomg_nolen(sv) SvPV_force_flags_nolen(sv, 0)

#define SvPV_force_flags(sv, lp, flags) \
    (SvPOK_pure_nogthink(sv) \
     ? ((lp = SvCUR(sv)), SvPVX(sv)) : sv_pvn_force_flags(sv, &lp, flags))

#define SvPV_force_flags_nolen(sv, flags) \
    (SvPOK_pure_nogthink(sv) \
     ? SvPVX(sv) : sv_pvn_force_flags(sv, 0, flags))

#define SvPV_force_flags_mutable(sv, lp, flags) \
    (SvPOK_pure_nogthink(sv) \
     ? ((lp = SvCUR(sv)), SvPVX_mutable(sv)) \
     : sv_pvn_force_flags(sv, &lp, flags|SV_MUTABLE_RETURN))

#define SvPV_nolen(sv) \
    (SvPOK_nog(sv) \
     ? SvPVX(sv) : sv_2pv_flags(sv, 0, SV_GMAGIC))

/* "_nomg" in these defines means no mg_get() */
#define SvPV_nomg_nolen(sv) \
    (SvPOK_nog(sv) \
     ? SvPVX(sv) : sv_2pv_flags(sv, 0, 0))

#define SvPV_nolen_const(sv) \
    (SvPOK_nog(sv) \
     ? SvPVX_const(sv) : sv_2pv_flags(sv, 0, SV_GMAGIC|SV_CONST_RETURN))

#define SvPV_nomg(sv, lp) SvPV_flags(sv, lp, 0)
#define SvPV_nomg_const(sv, lp) SvPV_flags_const(sv, lp, 0)
#define SvPV_nomg_const_nolen(sv) SvPV_flags_const_nolen(sv, 0)

/* ----*/

#define SvPVutf8(sv, lp) \
    (SvPOK_utf8_nog(sv) \
     ? ((lp = SvCUR(sv)), SvPVX(sv)) : sv_2pvutf8(sv, &lp))

#define SvPVutf8_force(sv, lp) \
    (SvPOK_utf8_pure_nogthink(sv) \
     ? ((lp = SvCUR(sv)), SvPVX(sv)) : sv_pvutf8n_force(sv, &lp))

#define SvPVutf8_nolen(sv) \
    (SvPOK_utf8_nog(sv) \
     ? SvPVX(sv) : sv_2pvutf8(sv, 0))

/* ----*/

#define SvPVbyte(sv, lp) \
    (SvPOK_byte_nog(sv) \
     ? ((lp = SvCUR(sv)), SvPVX(sv)) : sv_2pvbyte(sv, &lp))

#define SvPVbyte_force(sv, lp) \
    (SvPOK_byte_pure_nogthink(sv) \
     ? ((lp = SvCUR(sv)), SvPVX(sv)) : sv_pvbyten_force(sv, &lp))

#define SvPVbyte_nolen(sv) \
    (SvPOK_byte_nog(sv) \
     ? SvPVX(sv) : sv_2pvbyte(sv, 0))

    
/* define FOOx(): idempotent versions of FOO(). If possible, use a local
 * var to evaluate the arg once; failing that, use a global if possible;
 * failing that, call a function to do the work
 */

#define SvPVx_force(sv, lp) sv_pvn_force(sv, &lp)
#define SvPVutf8x_force(sv, lp) sv_pvutf8n_force(sv, &lp)
#define SvPVbytex_force(sv, lp) sv_pvbyten_force(sv, &lp)

#define SvTRUE(sv)        (LIKELY(sv) && (UNLIKELY(SvGMAGICAL(sv)) ? sv_2bool(sv) : SvTRUE_common(sv, sv_2bool_nomg(sv))))
#define SvTRUE_nomg(sv)   (LIKELY(sv) && (                                SvTRUE_common(sv, sv_2bool_nomg(sv))))
#define SvTRUE_NN(sv)              (UNLIKELY(SvGMAGICAL(sv)) ? sv_2bool(sv) : SvTRUE_common(sv, sv_2bool_nomg(sv)))
#define SvTRUE_nomg_NN(sv) (                                        SvTRUE_common(sv, sv_2bool_nomg(sv)))
#define SvTRUE_common(sv,fallback) (			\
      !SvOK(sv)						\
	? 0						\
    : SvPOK(sv)						\
	? SvPVXtrue(sv)					\
    : (SvFLAGS(sv) & (SVf_IOK|SVf_NOK))			\
	? (   (SvIOK(sv) && SvIVX(sv) != 0)		\
	   || (SvNOK(sv) && SvNVX(sv) != 0.0))		\
    : (fallback))

#if defined(__GNUC__) && !defined(PERL_GCC_BRACE_GROUPS_FORBIDDEN)

#  define SvIVx(sv) ({SV *_sv = MUTABLE_SV(sv); SvIV(_sv); })
#  define SvUVx(sv) ({SV *_sv = MUTABLE_SV(sv); SvUV(_sv); })
#  define SvNVx(sv) ({SV *_sv = MUTABLE_SV(sv); SvNV(_sv); })
#  define SvPVx(sv, lp) ({SV *_sv = (sv); SvPV(_sv, lp); })
#  define SvPVx_const(sv, lp) ({SV *_sv = (sv); SvPV_const(_sv, lp); })
#  define SvPVx_nolen(sv) ({SV *_sv = (sv); SvPV_nolen(_sv); })
#  define SvPVx_nolen_const(sv) ({SV *_sv = (sv); SvPV_nolen_const(_sv); })
#  define SvPVutf8x(sv, lp) ({SV *_sv = (sv); SvPVutf8(_sv, lp); })
#  define SvPVbytex(sv, lp) ({SV *_sv = (sv); SvPVbyte(_sv, lp); })
#  define SvPVbytex_nolen(sv) ({SV *_sv = (sv); SvPVbyte_nolen(_sv); })
#  define SvTRUEx(sv)      ({SV *_sv = (sv); SvTRUE(_sv); })
#  define SvTRUEx_nomg(sv) ({SV *_sv = (sv); SvTRUE_nomg(_sv); })

#else /* __GNUC__ */

/* These inlined macros use globals, which will require a thread
 * declaration in user code, so we avoid them under threads */

#  define SvIVx(sv) ((PL_Sv = (sv)), SvIV(PL_Sv))
#  define SvUVx(sv) ((PL_Sv = (sv)), SvUV(PL_Sv))
#  define SvNVx(sv) ((PL_Sv = (sv)), SvNV(PL_Sv))
#  define SvPVx(sv, lp) ((PL_Sv = (sv)), SvPV(PL_Sv, lp))
#  define SvPVx_const(sv, lp) ((PL_Sv = (sv)), SvPV_const(PL_Sv, lp))
#  define SvPVx_nolen(sv) ((PL_Sv = (sv)), SvPV_nolen(PL_Sv))
#  define SvPVx_nolen_const(sv) ((PL_Sv = (sv)), SvPV_nolen_const(PL_Sv))
#  define SvPVutf8x(sv, lp) ((PL_Sv = (sv)), SvPVutf8(PL_Sv, lp))
#  define SvPVbytex(sv, lp) ((PL_Sv = (sv)), SvPVbyte(PL_Sv, lp))
#  define SvPVbytex_nolen(sv) ((PL_Sv = (sv)), SvPVbyte_nolen(PL_Sv))
#  define SvTRUEx(sv)      ((PL_Sv = (sv)), SvTRUE(PL_Sv))
#  define SvTRUEx_nomg(sv) ((PL_Sv = (sv)), SvTRUE_nomg(PL_Sv))
#endif /* __GNU__ */

#define SvPVXtrue(sv)	(					\
    ((XPV*)SvANY((sv))) 					\
     && (							\
	((XPV*)SvANY((sv)))->xpv_cur > 1			\
	|| (							\
	    ((XPV*)SvANY((sv)))->xpv_cur			\
	    && *(sv)->sv_u.svu_pv != '0'				\
	)							\
    )								\
)

#define SvIsCOW(sv)		(SvFLAGS(sv) & SVf_IsCOW)
#define SvIsCOW_on(sv)		(SvFLAGS(sv) |= SVf_IsCOW)
#define SvIsCOW_off(sv)		(SvFLAGS(sv) &= ~SVf_IsCOW)
#define SvIsCOW_shared_hash(sv)	(SvIsCOW(sv) && SvLEN(sv) == 0)

#define SvSHARED_HEK_FROM_PV(pvx) \
	((struct hek*)(pvx - STRUCT_OFFSET(struct hek, hek_key)))
#define SvSHARED_HASH(sv) (0 + SvSHARED_HEK_FROM_PV(SvPVX_const(sv))->hek_hash)

/* flag values for sv_*_flags functions */
#define SV_IMMEDIATE_UNREF	1
#define SV_GMAGIC		2
#define SV_COW_DROP_PV		4
#define SV_UTF8_NO_ENCODING	8
#define SV_NOSTEAL		16
#define SV_CONST_RETURN		32
#define SV_MUTABLE_RETURN	64
#define SV_SMAGIC		128
#define SV_HAS_TRAILING_NUL	256
#define SV_COW_SHARED_HASH_KEYS	512
/* This one is only enabled for PERL_OLD_COPY_ON_WRITE */
/* XXX This flag actually enabled for any COW.  But it appears not to do
       anything.  Can we just remove it?  Or will it serve some future
       purpose.  */
#define SV_COW_OTHER_PVS	1024
/* Make sv_2pv_flags return NULL if something is undefined.  */
#define SV_UNDEF_RETURNS_NULL	2048
/* Tell sv_utf8_upgrade() to not check to see if an upgrade is really needed.
 * This is used when the caller has already determined it is, and avoids
 * redundant work */
#define SV_FORCE_UTF8_UPGRADE	4096
/* if (after resolving magic etc), the SV is found to be overloaded,
 * don't call the overload magic, just return as-is */
#define SV_SKIP_OVERLOAD	8192
#define SV_CATBYTES		16384
#define SV_CATUTF8		32768

/* The core is safe for this COW optimisation. XS code on CPAN may not be.
   So only default to doing the COW setup if we're in the core.
 */
#ifdef PERL_CORE
#  ifndef SV_DO_COW_SVSETSV
#    define SV_DO_COW_SVSETSV	SV_COW_SHARED_HASH_KEYS|SV_COW_OTHER_PVS
#  endif
#endif

#ifndef SV_DO_COW_SVSETSV
#  define SV_DO_COW_SVSETSV	0
#endif


#define sv_unref(sv)    	sv_unref_flags(sv, 0)
#define sv_force_normal(sv)	sv_force_normal_flags(sv, 0)
#define sv_usepvn(sv, p, l)	sv_usepvn_flags(sv, p, l, 0)
#define sv_usepvn_mg(sv, p, l)	sv_usepvn_flags(sv, p, l, SV_SMAGIC)

/* We are about to replace the SV's current value. So if it's copy on write
   we need to normalise it. Use the SV_COW_DROP_PV flag hint to say that
   the value is about to get thrown away, so drop the PV rather than go to
   the effort of making a read-write copy only for it to get immediately
   discarded.  */

#define SV_CHECK_THINKFIRST_COW_DROP(sv) if (SvTHINKFIRST(sv)) \
				    sv_force_normal_flags(sv, SV_COW_DROP_PV)

#ifdef PERL_COPY_ON_WRITE
#   define SvCANCOW(sv)					    \
	(SvIsCOW(sv)					     \
	 ? SvLEN(sv) ? CowREFCNT(sv) != SV_COW_REFCNT_MAX : 1 \
	 : (SvFLAGS(sv) & CAN_COW_MASK) == CAN_COW_FLAGS       \
			    && SvCUR(sv)+1 < SvLEN(sv))
   /* Note: To allow 256 COW "copies", a refcnt of 0 means 1. */
#   define CowREFCNT(sv)	(*(U8 *)(SvPVX(sv)+SvLEN(sv)-1))
#   define SV_COW_REFCNT_MAX	((1 << sizeof(U8)*8) - 1)
#   define CAN_COW_MASK	(SVf_POK|SVf_ROK|SVp_POK|SVf_FAKE| \
			 SVf_OOK|SVf_BREAK|SVf_READONLY|SVf_PROTECT)
#endif

#define CAN_COW_FLAGS	(SVp_POK|SVf_POK)

#define SV_CHECK_THINKFIRST(sv) if (SvTHINKFIRST(sv)) \
				    sv_force_normal_flags(sv, 0)


/* all these 'functions' are now just macros */

#define sv_pv(sv) SvPV_nolen(sv)
#define sv_pvutf8(sv) SvPVutf8_nolen(sv)
#define sv_pvbyte(sv) SvPVbyte_nolen(sv)

#define sv_pvn_force_nomg(sv, lp) sv_pvn_force_flags(sv, lp, 0)
#define sv_utf8_upgrade_flags(sv, flags) sv_utf8_upgrade_flags_grow(sv, flags, 0)
#define sv_utf8_upgrade_nomg(sv) sv_utf8_upgrade_flags(sv, 0)
#define sv_catpvn_nomg(dsv, sstr, slen) sv_catpvn_flags(dsv, sstr, slen, 0)
#define sv_catpv_nomg(dsv, sstr) sv_catpv_flags(dsv, sstr, 0)
#define sv_setsv(dsv, ssv) \
	sv_setsv_flags(dsv, ssv, SV_GMAGIC|SV_DO_COW_SVSETSV)
#define sv_setsv_nomg(dsv, ssv) sv_setsv_flags(dsv, ssv, SV_DO_COW_SVSETSV)
#define sv_catsv(dsv, ssv) sv_catsv_flags(dsv, ssv, SV_GMAGIC)
#define sv_catsv_nomg(dsv, ssv) sv_catsv_flags(dsv, ssv, 0)
#define sv_catsv_mg(dsv, ssv) sv_catsv_flags(dsv, ssv, SV_GMAGIC|SV_SMAGIC)
#define sv_catpvn(dsv, sstr, slen) sv_catpvn_flags(dsv, sstr, slen, SV_GMAGIC)
#define sv_catpvn_mg(sv, sstr, slen) sv_catpvn_flags(sv, sstr, slen, SV_GMAGIC|SV_SMAGIC);
#define sv_copypv(dsv, ssv) sv_copypv_flags(dsv, ssv, SV_GMAGIC)
#define sv_copypv_nomg(dsv, ssv) sv_copypv_flags(dsv, ssv, 0)
#define sv_2pv(sv, lp) sv_2pv_flags(sv, lp, SV_GMAGIC)
#define sv_2pv_nolen(sv) sv_2pv(sv, 0)
#define sv_2pvbyte_nolen(sv) sv_2pvbyte(sv, 0)
#define sv_2pvutf8_nolen(sv) sv_2pvutf8(sv, 0)
#define sv_2pv_nomg(sv, lp) sv_2pv_flags(sv, lp, 0)
#define sv_pvn_force(sv, lp) sv_pvn_force_flags(sv, lp, SV_GMAGIC)
#define sv_utf8_upgrade(sv) sv_utf8_upgrade_flags(sv, SV_GMAGIC)
#define sv_2iv(sv) sv_2iv_flags(sv, SV_GMAGIC)
#define sv_2uv(sv) sv_2uv_flags(sv, SV_GMAGIC)
#define sv_2nv(sv) sv_2nv_flags(sv, SV_GMAGIC)
#define sv_eq(sv1, sv2) sv_eq_flags(sv1, sv2, SV_GMAGIC)
#define sv_cmp(sv1, sv2) sv_cmp_flags(sv1, sv2, SV_GMAGIC)
#define sv_cmp_locale(sv1, sv2) sv_cmp_locale_flags(sv1, sv2, SV_GMAGIC)
#define sv_collxfrm(sv, nxp) sv_cmp_flags(sv, nxp, SV_GMAGIC)
#define sv_2bool(sv) sv_2bool_flags(sv, SV_GMAGIC)
#define sv_2bool_nomg(sv) sv_2bool_flags(sv, 0)
#define sv_insert(bigstr, offset, len, little, littlelen)		\
	Perl_sv_insert_flags(aTHX_ (bigstr),(offset), (len), (little),	\
			     (littlelen), SV_GMAGIC)
#define sv_mortalcopy(sv) \
	Perl_sv_mortalcopy_flags(aTHX_ sv, SV_GMAGIC|SV_DO_COW_SVSETSV)
#define sv_cathek(sv,hek)					    \
	STMT_START {						     \
	    HEK * const bmxk = hek;				      \
	    sv_catpvn_flags(sv, HEK_KEY(bmxk), HEK_LEN(bmxk),	       \
			    HEK_UTF8(bmxk) ? SV_CATUTF8 : SV_CATBYTES); \
	} STMT_END

/* Should be named SvCatPVN_utf8_upgrade? */
#define sv_catpvn_nomg_utf8_upgrade(dsv, sstr, slen, nsv)	\
	STMT_START {					\
	    if (!(nsv))					\
		nsv = newSVpvn_flags(sstr, slen, SVs_TEMP);	\
	    else					\
		sv_setpvn(nsv, sstr, slen);		\
	    SvUTF8_off(nsv);				\
	    sv_utf8_upgrade(nsv);			\
	    sv_catsv_nomg(dsv, nsv);			\
	} STMT_END
#define sv_catpvn_nomg_maybeutf8(dsv, sstr, slen, is_utf8) \
	sv_catpvn_flags(dsv, sstr, slen, (is_utf8)?SV_CATUTF8:SV_CATBYTES)

#if defined(PERL_CORE) || defined(PERL_EXT)
# define sv_or_pv_len_utf8(sv, pv, bytelen)	      \
    (SvGAMAGIC(sv)				       \
	? utf8_length((U8 *)(pv), (U8 *)(pv)+(bytelen))	\
	: sv_len_utf8(sv))
#endif

/*
=for apidoc Am|SV*|newRV_inc|SV* sv

Creates an RV wrapper for an SV.  The reference count for the original SV is
incremented.

=cut
*/

#define newRV_inc(sv)	newRV(sv)

/* the following macros update any magic values this C<sv> is associated with */

/*
=head1 Magical Functions

=for apidoc Am|void|SvGETMAGIC|SV* sv
Invokes C<mg_get> on an SV if it has 'get' magic.  For example, this
will call C<FETCH> on a tied variable.  This macro evaluates its
argument more than once.

=for apidoc Am|void|SvSETMAGIC|SV* sv
Invokes C<mg_set> on an SV if it has 'set' magic.  This is necessary
after modifying a scalar, in case it is a magical variable like C<$|>
or a tied variable (it calls C<STORE>).  This macro evaluates its
argument more than once.

=for apidoc Am|void|SvSetSV|SV* dsv|SV* ssv
Calls C<sv_setsv> if C<dsv> is not the same as C<ssv>.  May evaluate arguments
more than once.  Does not handle 'set' magic on the destination SV.

=for apidoc Am|void|SvSetSV_nosteal|SV* dsv|SV* ssv
Calls a non-destructive version of C<sv_setsv> if C<dsv> is not the same as
C<ssv>.  May evaluate arguments more than once.

=for apidoc Am|void|SvSetMagicSV|SV* dsv|SV* ssv
Like C<SvSetSV>, but does any set magic required afterwards.

=for apidoc Am|void|SvSetMagicSV_nosteal|SV* dsv|SV* ssv
Like C<SvSetSV_nosteal>, but does any set magic required afterwards.

=for apidoc Am|void|SvSHARE|SV* sv
Arranges for C<sv> to be shared between threads if a suitable module
has been loaded.

=for apidoc Am|void|SvLOCK|SV* sv
Arranges for a mutual exclusion lock to be obtained on C<sv> if a suitable module
has been loaded.

=for apidoc Am|void|SvUNLOCK|SV* sv
Releases a mutual exclusion lock on C<sv> if a suitable module
has been loaded.

=head1 SV Manipulation Functions

=for apidoc Am|char *|SvGROW|SV* sv|STRLEN len
Expands the character buffer in the SV so that it has room for the
indicated number of bytes (remember to reserve space for an extra trailing
C<NUL> character).  Calls C<sv_grow> to perform the expansion if necessary.
Returns a pointer to the character
buffer.  SV must be of type >= C<SVt_PV>.  One
alternative is to call C<sv_grow> if you are not sure of the type of SV.

=cut
*/

#define SvSHARE(sv) PL_sharehook(aTHX_ sv)
#define SvLOCK(sv) PL_lockhook(aTHX_ sv)
#define SvUNLOCK(sv) PL_unlockhook(aTHX_ sv)
#define SvDESTROYABLE(sv) PL_destroyhook(aTHX_ sv)

#define SvGETMAGIC(x) ((void)(UNLIKELY(SvGMAGICAL(x)) && mg_get(x)))
#define SvSETMAGIC(x) STMT_START { if (UNLIKELY(SvSMAGICAL(x))) mg_set(x); } STMT_END

#define SvSetSV_and(dst,src,finally) \
	STMT_START {					\
	    if (LIKELY((dst) != (src))) {		\
		sv_setsv(dst, src);			\
		finally;				\
	    }						\
	} STMT_END
#define SvSetSV_nosteal_and(dst,src,finally) \
	STMT_START {					\
	    if (LIKELY((dst) != (src))) {			\
		sv_setsv_flags(dst, src, SV_GMAGIC | SV_NOSTEAL | SV_DO_COW_SVSETSV);	\
		finally;				\
	    }						\
	} STMT_END

#define SvSetSV(dst,src) \
		SvSetSV_and(dst,src,/*nothing*/;)
#define SvSetSV_nosteal(dst,src) \
		SvSetSV_nosteal_and(dst,src,/*nothing*/;)

#define SvSetMagicSV(dst,src) \
		SvSetSV_and(dst,src,SvSETMAGIC(dst))
#define SvSetMagicSV_nosteal(dst,src) \
		SvSetSV_nosteal_and(dst,src,SvSETMAGIC(dst))


#if !defined(SKIP_DEBUGGING)
#define SvPEEK(sv) sv_peek(sv)
#else
#define SvPEEK(sv) ""
#endif

#define SvIMMORTAL(sv) (SvREADONLY(sv) && ((sv)==&PL_sv_undef || (sv)==&PL_sv_yes || (sv)==&PL_sv_no || (sv)==&PL_sv_placeholder))

#ifdef DEBUGGING
   /* exercise the immortal resurrection code in sv_free2() */
#  define SvREFCNT_IMMORTAL 1000
#else
#  define SvREFCNT_IMMORTAL ((~(U32)0)/2)
#endif

/*
=for apidoc Am|SV *|boolSV|bool b

Returns a true SV if C<b> is a true value, or a false SV if C<b> is 0.

See also C<L</PL_sv_yes>> and C<L</PL_sv_no>>.

=cut
*/

#define boolSV(b) ((b) ? &PL_sv_yes : &PL_sv_no)

#define isGV(sv) (SvTYPE(sv) == SVt_PVGV)
/* If I give every macro argument a different name, then there won't be bugs
   where nested macros get confused. Been there, done that.  */
#define isGV_with_GP(pwadak) \
	(((SvFLAGS(pwadak) & (SVp_POK|SVpgv_GP)) == SVpgv_GP)	\
	&& (SvTYPE(pwadak) == SVt_PVGV || SvTYPE(pwadak) == SVt_PVLV))
#define isGV_with_GP_on(sv)	STMT_START {			       \
	assert (SvTYPE(sv) == SVt_PVGV || SvTYPE(sv) == SVt_PVLV); \
	assert (!SvPOKp(sv));					       \
	assert (!SvIOKp(sv));					       \
	(SvFLAGS(sv) |= SVpgv_GP);				       \
    } STMT_END
#define isGV_with_GP_off(sv)	STMT_START {			       \
	assert (SvTYPE(sv) == SVt_PVGV || SvTYPE(sv) == SVt_PVLV); \
	assert (!SvPOKp(sv));					       \
	assert (!SvIOKp(sv));					       \
	(SvFLAGS(sv) &= ~SVpgv_GP);				       \
    } STMT_END
#define isREGEXP(sv) \
    (SvTYPE(sv) == SVt_REGEXP				      \
     || (SvFLAGS(sv) & (SVTYPEMASK|SVp_POK|SVpgv_GP|SVf_FAKE)) \
	 == (SVt_PVLV|SVf_FAKE))


#ifdef PERL_ANY_COW
# define SvGROW(sv,len) \
	(SvIsCOW(sv) || SvLEN(sv) < (len) ? sv_grow(sv,len) : SvPVX(sv))
#else
# define SvGROW(sv,len) (SvLEN(sv) < (len) ? sv_grow(sv,len) : SvPVX(sv))
#endif
#define SvGROW_mutable(sv,len) \
    (SvLEN(sv) < (len) ? sv_grow(sv,len) : SvPVX_mutable(sv))
#define Sv_Grow sv_grow

#define CLONEf_COPY_STACKS 1
#define CLONEf_KEEP_PTR_TABLE 2
#define CLONEf_CLONE_HOST 4
#define CLONEf_JOIN_IN 8

struct clone_params {
  AV* stashes;
  UV  flags;
  PerlInterpreter *proto_perl;
  PerlInterpreter *new_perl;
  AV *unreferenced;
};

/*
=for apidoc Am|SV*|newSVpvn_utf8|NULLOK const char* s|STRLEN len|U32 utf8

Creates a new SV and copies a string (which may contain C<NUL> (C<\0>)
characters) into it.  If C<utf8> is true, calls
C<SvUTF8_on> on the new SV.  Implemented as a wrapper around C<newSVpvn_flags>.

=cut
*/

#define newSVpvn_utf8(s, len, u) newSVpvn_flags((s), (len), (u) ? SVf_UTF8 : 0)

/*
=for apidoc Amx|SV*|newSVpadname|PADNAME *pn

Creates a new SV containing the pad name.

=cut
*/

#define newSVpadname(pn) newSVpvn_utf8(PadnamePV(pn), PadnameLEN(pn), TRUE)

/*
=for apidoc Am|void|SvOOK_offset|NN SV*sv|STRLEN len

Reads into C<len> the offset from C<SvPVX> back to the true start of the
allocated buffer, which will be non-zero if C<sv_chop> has been used to
efficiently remove characters from start of the buffer.  Implemented as a
macro, which takes the address of C<len>, which must be of type C<STRLEN>.
Evaluates C<sv> more than once.  Sets C<len> to 0 if C<SvOOK(sv)> is false.

=cut
*/

#ifdef DEBUGGING
/* Does the bot know something I don't?
10:28 <@@Nicholas> metabatman
10:28 <+meta> Nicholas: crash
*/
#  define SvOOK_offset(sv, offset) STMT_START {				\
	assert(sizeof(offset) == sizeof(STRLEN));			\
	if (SvOOK(sv)) {						\
	    const U8 *_crash = (U8*)SvPVX_const(sv);			\
	    (offset) = *--_crash;					\
	    if (!(offset)) {						\
		_crash -= sizeof(STRLEN);				\
		Copy(_crash, (U8 *)&(offset), sizeof(STRLEN), U8);	\
	    }								\
	    {								\
		/* Validate the preceding buffer's sentinels to		\
		   verify that no-one is using it.  */			\
		const U8 *const _bonk = (U8*)SvPVX_const(sv) - (offset);\
		while (_crash > _bonk) {				\
		    --_crash;						\
		    assert (*_crash == (U8)PTR2UV(_crash));		\
		}							\
	    }								\
	} else {							\
	    (offset) = 0;						\
	}								\
    } STMT_END
#else
    /* This is the same code, but avoids using any temporary variables:  */
#  define SvOOK_offset(sv, offset) STMT_START {				\
	assert(sizeof(offset) == sizeof(STRLEN));			\
	if (SvOOK(sv)) {						\
	    (offset) = ((U8*)SvPVX_const(sv))[-1];			\
	    if (!(offset)) {						\
		Copy(SvPVX_const(sv) - 1 - sizeof(STRLEN),		\
		     (U8*)&(offset), sizeof(STRLEN), U8);		\
	    }								\
	} else {							\
	    (offset) = 0;						\
	}								\
    } STMT_END
#endif

#define newIO()	MUTABLE_IO(newSV_type(SVt_PVIO))

#define SV_CONST(name) \
	PL_sv_consts[SV_CONST_##name] \
		? PL_sv_consts[SV_CONST_##name] \
		: (PL_sv_consts[SV_CONST_##name] = newSVpv_share(#name, 0))

#define SV_CONST_TIESCALAR 0
#define SV_CONST_TIEARRAY 1
#define SV_CONST_TIEHASH 2
#define SV_CONST_TIEHANDLE 3

#define SV_CONST_FETCH 4
#define SV_CONST_FETCHSIZE 5
#define SV_CONST_STORE 6
#define SV_CONST_STORESIZE 7
#define SV_CONST_EXISTS 8

#define SV_CONST_PUSH 9
#define SV_CONST_POP 10
#define SV_CONST_SHIFT 11
#define SV_CONST_UNSHIFT 12
#define SV_CONST_SPLICE 13
#define SV_CONST_EXTEND 14

#define SV_CONST_FIRSTKEY 15
#define SV_CONST_NEXTKEY 16
#define SV_CONST_SCALAR 17

#define SV_CONST_OPEN 18
#define SV_CONST_WRITE 19
#define SV_CONST_PRINT 20
#define SV_CONST_PRINTF 21
#define SV_CONST_READ 22
#define SV_CONST_READLINE 23
#define SV_CONST_GETC 24
#define SV_CONST_SEEK 25
#define SV_CONST_TELL 26
#define SV_CONST_EOF 27
#define SV_CONST_BINMODE 28
#define SV_CONST_FILENO 29
#define SV_CONST_CLOSE 30

#define SV_CONST_DELETE 31
#define SV_CONST_CLEAR 32
#define SV_CONST_UNTIE 33
#define SV_CONST_DESTROY 34

#define SV_CONSTS_COUNT 35

/*
 * Bodyless IVs and NVs!
 *
 * Since 5.9.2, we can avoid allocating a body for SVt_IV-type SVs.
 * Since the larger IV-holding variants of SVs store their integer
 * values in their respective bodies, the family of SvIV() accessor
 * macros would  naively have to branch on the SV type to find the
 * integer value either in the HEAD or BODY. In order to avoid this
 * expensive branch, a clever soul has deployed a great hack:
 * We set up the SvANY pointer such that instead of pointing to a
 * real body, it points into the memory before the location of the
 * head. We compute this pointer such that the location of
 * the integer member of the hypothetical body struct happens to
 * be the same as the location of the integer member of the bodyless
 * SV head. This now means that the SvIV() family of accessors can
 * always read from the (hypothetical or real) body via SvANY.
 *
 * Since the 5.21 dev series, we employ the same trick for NVs
 * if the architecture can support it (NVSIZE <= IVSIZE).
 */

/* The following two macros compute the necessary offsets for the above
 * trick and store them in SvANY for SvIV() (and friends) to use. */

#ifdef PERL_CORE
#  define SET_SVANY_FOR_BODYLESS_IV(sv) \
	SvANY(sv) =   (XPVIV*)((char*)&(sv->sv_u.svu_iv) \
                    - STRUCT_OFFSET(XPVIV, xiv_iv))

#  define SET_SVANY_FOR_BODYLESS_NV(sv) \
	SvANY(sv) =   (XPVNV*)((char*)&(sv->sv_u.svu_nv) \
                    - STRUCT_OFFSET(XPVNV, xnv_u.xnv_nv))
#endif

/*
 * ex: set ts=8 sts=4 sw=4 et:
 */
@


1.19
log
@Update to perl 5.20.3

OK bluhm@@
@
text
@d19 1
a19 1
An enum of flags for Perl types.  These are found in the file B<sv.h>
d44 2
a45 2
SVt_PVIO is for I/O objects, SVt_PVFM for formats, SVt_PVCV for
subroutines, SVt_PVHV for hashes and SVt_PVAV for arrays.
d54 2
a55 2
SVt_PVGV represents a typeglob.  If !SvFAKE(sv), then it is a real,
incoercible typeglob.  If SvFAKE(sv), then it is a scalar to which a
d57 1
a57 1
a typeglob.  SVt_PVLV represents a scalar that delegates to another scalar
d60 2
a61 2
a typeglob.  SVt_REGEXP is for regular
expressions.  SVt_INVLIST is for Perl
d64 1
a64 1
SVt_PVMG represents a "normal" scalar (not a typeglob, regular expression,
d67 6
a72 6
other types are just simpler forms of SVt_PVMG, with fewer internal fields.
 SVt_NULL can only hold undef.  SVt_IV can hold undef, an integer, or a
reference.  (SVt_RV is an alias for SVt_IV, which exists for backward
compatibility.)  SVt_NV can hold any of those or a double.  SVt_PV can only
hold undef or a string.  SVt_PVIV is a superset of SVt_PV and SVt_IV.
SVt_PVNV is similar.  SVt_PVMG can hold anything SVt_PVNV can hold, but it
d179 3
d197 6
d208 1
d215 2
a216 1
    }	sv_u
d218 11
a232 8
#ifdef DEBUG_LEAKING_SCALARS
    PERL_BITFIELD32 sv_debug_optype:9;	/* the type of OP that allocated us */
    PERL_BITFIELD32 sv_debug_inpad:1;	/* was allocated in a pad for an OP */
    PERL_BITFIELD32 sv_debug_line:16;	/* the line where we were allocated */
    UV		    sv_debug_serial;	/* serial number of sv allocation   */
    char *	    sv_debug_file;	/* the file where we were allocated */
    SV *	    sv_debug_parent;	/* what we were cloned from (ithreads)*/
#endif
d277 2
a278 2
All of the following SvREFCNT_inc* macros are optimized versions of
SvREFCNT_inc, and can be replaced with SvREFCNT_inc.
d281 2
a282 2
Same as SvREFCNT_inc, but can only be used if you know I<sv>
is not NULL.  Since we don't have to check the NULLness, it's faster
d286 1
a286 1
Same as SvREFCNT_inc, but can only be used if you don't need the
d290 2
a291 2
Same as SvREFCNT_inc, but can only be used if you don't need the return
value, and you know that I<sv> is not NULL.  The macro doesn't need
d296 1
a296 1
Same as SvREFCNT_inc, but can only be used with expressions without side
d300 2
a301 2
Same as SvREFCNT_inc_simple, but can only be used if you know I<sv>
is not NULL.  Since we don't have to check the NULLness, it's faster
d305 1
a305 1
Same as SvREFCNT_inc_simple, but can only be used if you don't need the
d309 2
a310 2
Same as SvREFCNT_inc, but can only be used if you don't need the return
value, and you know that I<sv> is not NULL.  The macro doesn't need
d315 1
a315 1
Decrements the reference count of the given SV.  I<sv> may be NULL.
d318 2
a319 2
Same as SvREFCNT_dec, but can only be used if you know I<sv>
is not NULL.  Since we don't have to check the NULLness, it's faster
d323 1
a323 1
Returns the type of the SV.  See C<svtype>.
d327 1
a327 1
perform the upgrade if necessary.  See C<svtype>.
d356 1
a356 1
#define SvIS_FREED(sv)	((sv)->sv_flags == SVTYPEMASK)
d372 1
d379 5
a383 10
#define SVpad_NAMELIST	SVp_SCREAM  /* AV is a padnamelist */
#define SVf_IsCOW	0x00010000  /* copy on write (shared hash key if
				       SvLEN == 0) */
#define SVs_PADTMP	0x00020000  /* in use as tmp; only if ! SVs_PADMY */
#define SVs_PADSTALE	0x00020000  /* lexical has gone out of scope;
					only valid for SVs_PADMY */
#define SVpad_TYPED	0x00020000  /* pad name is a Typed Lexical */
#define SVs_PADMY	0x00040000  /* in use a "my" variable */
#define SVpad_OUR	0x00040000  /* pad name is "our" instead of "my" */
#define SVs_TEMP	0x00080000  /* string is stealable? */
d394 2
a395 3
				       3: On a pad name SV, that slot in the
					  frame AV is a REFCNT'ed reference
					  to a lexical from "outside". */
d402 3
a404 1
				       perl_destruct will skip it. */
d410 2
a411 1
#define SVf_THINKFIRST	(SVf_READONLY|SVf_ROK|SVf_FAKE|SVs_RMG|SVf_IsCOW)
d418 1
d420 2
d423 2
a424 4
/* note that SVf_AMAGIC is now only set on stashes, so this bit is free
 * for non-HV SVs */

/* Ensure this value does not clash with the GV_ADD* flags in gv.h: */
d440 3
a442 2
/* PVNV, PVMG only, and only used in pads. Should be safe to test on any scalar
   SV, as the core is careful to avoid setting both.
d448 1
a448 1
   0x4000C400   pad name.
a452 4
#define SVpad_NAME	(SVp_SCREAM|SVpbm_VALID)
				    /* This SV is a name in the PAD, so
				       SVpad_TYPED, SVpad_OUR and SVpad_STATE
				       apply */
d470 1
a470 1
#define SVpbm_TAIL	0x80000000
a473 1
#define SVpad_STATE	0x80000000  /* pad name is a "state" var */
a502 1
    HV*	    xmg_ourstash;	/* Stash for our (when SvPAD_OUR is true) */
d504 1
a504 1
};				/* also used by PadnamelistMAXNAMED */
d556 8
a563 3
    IV          prev_index;
    STRLEN	iterator;
    bool	is_offset;	/* */
d591 4
a594 1
    PADLIST *	xcv_padlist;							\
d694 1
a694 1
Tells an SV that it is an integer and disables all other OK bits.
d697 1
a697 1
Tells an SV that it is an unsigned integer and disables all other OK bits.
d702 1
a702 1
range of both an IV and a UV may be be flagged as either SvUOK or SVIOK.
d707 1
a707 1
range of both an IV and a UV may be be flagged as either SvUOK or SVIOK.
d735 1
a735 1
Tells an SV that it is a string and disables all other OK bits.
d744 3
a746 3
beginning of a SvPV.  When SvOOK is true, then the start of the
allocated string buffer is actually C<SvOOK_offset()> bytes before SvPVX.
This offset used to be stored in SvIVX, but is now stored within the spare
d763 1
a763 1
Only use when you are sure SvIOK is true.  See also C<SvIV()>.
d767 1
a767 1
Only use when you are sure SvIOK is true.  See also C<SvUV()>.
d771 1
a771 1
Only use when you are sure SvNOK is true.  See also C<SvNV()>.
d777 1
a777 1
type >= SVt_PV.
d783 1
a783 1
Returns the length of the string which is in the SV.  See C<SvLEN>.
d787 1
a787 1
attributable to C<SvOOK>.  See C<SvCUR>.
d793 1
a793 1
See C<SvCUR>.  Access the character as *(SvEND(sv)).
d808 1
a808 1
Set the value of the NV pointer in sv to val.  See C<SvIV_set>.
d815 1
a815 1
C<NUL>-terminated string C<val>.  See also C<SvIV_set>.
d820 1
a820 1
C<SvPV_force> (or check the SvIsCOW flag) first to make sure this
d825 1
a825 1
Set the value of the UV pointer in sv to val.  See C<SvIV_set>.
d828 1
a828 1
Set the value of the RV pointer in sv to val.  See C<SvIV_set>.
d831 1
a831 1
Set the value of the MAGIC pointer in sv to val.  See C<SvIV_set>.
d834 1
a834 1
Set the value of the STASH pointer in sv to val.  See C<SvIV_set>.
d837 2
a838 2
Set the current length of the string which is in the SV.  See C<SvCUR>
and C<SvIV_set>.
d841 1
a841 1
Set the actual length of the string which is in the SV.  See C<SvIV_set>.
d866 1
a866 1
#define SvIOKp_on(sv)		(assert_not_glob(sv) SvRELEASE_IVX_(sv)	\
d875 1
a875 1
#define SvIOK_on(sv)		(assert_not_glob(sv) SvRELEASE_IVX_(sv)	\
d904 1
a904 1
You should use this I<after> a call to SvPV() or one of its variants, in
d907 3
d919 1
a919 1
Tells an SV that it is a string and disables all other OK bits,
d952 1
a952 1
#define SvOOK_off(sv)		((void)(SvOOK(sv) && sv_backoff(sv)))
d1047 2
a1048 2
A quick flag check to see whether an sv should be passed to sv_force_normal
to be "downgraded" before SvIVX or SvPVX can be modified directly.
d1050 2
a1051 2
For example, if your scalar is a reference and you want to modify the SvIVX
slot, you can't just do SvROK_off, as that will leak the referent.
d1054 1
a1054 1
sv_setsv, sv_setiv and sv_pvn_force.
d1062 2
a1063 2
SvTHINKFIRST sometimes produces false positives.  In those cases
sv_force_normal does nothing.
d1070 5
a1074 4
#define SvPADMY(sv)		(SvFLAGS(sv) & SVs_PADMY)
#define SvPADMY_on(sv)		(SvFLAGS(sv) |= SVs_PADMY)

/* SVs_PADTMP and SVs_PADSTALE share the same bit, mediated by SVs_PADMY */
d1076 2
a1077 3
#define SvPADTMP(sv)	((SvFLAGS(sv) & (SVs_PADMY|SVs_PADTMP)) == SVs_PADTMP)
#define SvPADSTALE(sv)	((SvFLAGS(sv) & (SVs_PADMY|SVs_PADSTALE)) \
				    == (SVs_PADMY|SVs_PADSTALE))
d1079 2
a1080 2
#define SvPADTMP_on(sv)		S_SvPADTMP_on(MUTABLE_SV(sv))
#define SvPADTMP_off(sv)	S_SvPADTMP_off(MUTABLE_SV(sv))
d1092 8
a1099 3
#define SvREADONLY(sv)		(SvFLAGS(sv) & SVf_READONLY)
#define SvREADONLY_on(sv)	(SvFLAGS(sv) |= SVf_READONLY)
#define SvREADONLY_off(sv)	(SvFLAGS(sv) &= ~SVf_READONLY)
a1149 40

#define SvPAD_TYPED(sv) \
	((SvFLAGS(sv) & (SVpad_NAME|SVpad_TYPED)) == (SVpad_NAME|SVpad_TYPED))

#define SvPAD_OUR(sv)	\
	((SvFLAGS(sv) & (SVpad_NAME|SVpad_OUR)) == (SVpad_NAME|SVpad_OUR))

#define SvPAD_STATE(sv)	\
	((SvFLAGS(sv) & (SVpad_NAME|SVpad_STATE)) == (SVpad_NAME|SVpad_STATE))

#if defined (DEBUGGING) && defined(__GNUC__) && !defined(PERL_GCC_BRACE_GROUPS_FORBIDDEN)
#  define SvPAD_TYPED_on(sv)	({					\
	    SV *const _svpad = MUTABLE_SV(sv);				\
	    assert(SvTYPE(_svpad) == SVt_PVMG);				\
	    (SvFLAGS(_svpad) |= SVpad_NAME|SVpad_TYPED);		\
	})
#define SvPAD_OUR_on(sv)	({					\
	    SV *const _svpad = MUTABLE_SV(sv);				\
	    assert(SvTYPE(_svpad) == SVt_PVMG);				\
	    (SvFLAGS(_svpad) |= SVpad_NAME|SVpad_OUR);			\
	})
#define SvPAD_STATE_on(sv)	({					\
	    SV *const _svpad = MUTABLE_SV(sv);				\
	    assert(SvTYPE(_svpad) == SVt_PVNV || SvTYPE(_svpad) == SVt_PVMG); \
	    (SvFLAGS(_svpad) |= SVpad_NAME|SVpad_STATE);		\
	})
#else
#  define SvPAD_TYPED_on(sv)	(SvFLAGS(sv) |= SVpad_NAME|SVpad_TYPED)
#  define SvPAD_OUR_on(sv)	(SvFLAGS(sv) |= SVpad_NAME|SVpad_OUR)
#  define SvPAD_STATE_on(sv)	(SvFLAGS(sv) |= SVpad_NAME|SVpad_STATE)
#endif

#define SvOURSTASH(sv)	\
	(SvPAD_OUR(sv) ? ((XPVMG*) SvANY(sv))->xmg_u.xmg_ourstash : NULL)
#define SvOURSTASH_set(sv, st)					\
        STMT_START {						\
	    assert(SvTYPE(sv) == SVt_PVMG);			\
	    ((XPVMG*) SvANY(sv))->xmg_u.xmg_ourstash = st;	\
	} STMT_END

a1231 2
	    if(SvTYPE(_svmagic) == SVt_PVMG)				\
		assert(!SvPAD_OUR(_svmagic));				\
d1276 1
a1276 1
	STMT_START {if (!SvIOKp(sv) && (SvNOK(sv) || SvPOK(sv))) \
d1279 2
a1280 2
	(!SvIOKp(sv) && (SvNOK(sv) || SvPOK(sv)) \
	    ? (SvIV_nomg(sv), SvIOK(sv))	  \
d1476 3
a1478 4
	if (UNLIKELY(TAINTING_get)) {	\
	    if (UNLIKELY(TAINT_get))	\
		SvTAINTED_on(sv);	\
	}				\
d1501 2
a1502 2
don't use C<&len>).  See also C<SvPVx> for a version which guarantees to
evaluate sv only once.
d1509 1
a1509 1
a temporary buffer or similar.  If you absolutely need the SvPVX field to
d1511 1
a1511 1
L</SvPV_force>.
d1528 2
a1529 2
Coerces the given SV to an integer and returns it.  See C<SvIVx> for a
version which guarantees to evaluate sv only once.
d1541 2
a1542 2
Coerce the given SV to a double and return it.  See C<SvNVx> for a version
which guarantees to evaluate sv only once.
d1554 2
a1555 2
Coerces the given SV to an unsigned integer and returns it.  See C<SvUVx>
for a version which guarantees to evaluate sv only once.
d1568 2
a1569 2
false.  See SvOK() for a defined/undefined test.  Handles 'get' magic
unless the scalar is already SvPOK, SvIOK or SvNOK (the public, not the
d1574 1
a1574 1
false.  See SvOK() for a defined/undefined test.  Does not handle 'get' magic.
d1577 1
a1577 1
Like C<SvPV_force>, but converts sv to utf8 first if necessary.
d1580 1
a1580 1
Like C<SvPV>, but converts sv to utf8 first if necessary.
d1583 1
a1583 1
Like C<SvPV_nolen>, but converts sv to utf8 first if necessary.
d1586 1
a1586 1
Like C<SvPV_force>, but converts sv to byte representation first if necessary.
d1589 1
a1589 1
Like C<SvPV>, but converts sv to byte representation first if necessary.
d1592 1
a1592 1
Like C<SvPV_nolen>, but converts sv to byte representation first if necessary.
d1595 2
a1596 2
Like C<SvPV_force>, but converts sv to utf8 first if necessary.
Guarantees to evaluate sv only once; use the more efficient C<SvPVutf8_force>
d1600 2
a1601 2
Like C<SvPV>, but converts sv to utf8 first if necessary.
Guarantees to evaluate sv only once; use the more efficient C<SvPVutf8>
d1605 2
a1606 2
Like C<SvPV_force>, but converts sv to byte representation first if necessary.
Guarantees to evaluate sv only once; use the more efficient C<SvPVbyte_force>
d1610 2
a1611 2
Like C<SvPV>, but converts sv to byte representation first if necessary.
Guarantees to evaluate sv only once; use the more efficient C<SvPVbyte>
d1637 1
a1637 1
Like sv_utf8_upgrade, but doesn't do magic on C<sv>.
d1663 1
a1663 1
     (const char*) sv_2pv_flags(sv, &lp, flags|SV_CONST_RETURN))
d1667 1
a1667 1
     (const char*) sv_2pv_flags(sv, 0, flags|SV_CONST_RETURN))
d1671 1
a1671 1
     sv_2pv_flags(sv, &lp, flags|SV_MUTABLE_RETURN))
d1828 3
d1841 2
a1842 6
/* It is not yet clear whether we want this as an API, or what the
 * constants should be named. */
#ifdef PERL_CORE
# define SV_CATBYTES		16384
# define SV_CATUTF8		32768
#endif
d1872 1
a1872 20
#ifdef PERL_OLD_COPY_ON_WRITE
#define SvRELEASE_IVX(sv)   \
    ((SvIsCOW(sv) ? sv_force_normal_flags(sv, 0) : (void) 0), 0)
#  define SvIsCOW_normal(sv)	(SvIsCOW(sv) && SvLEN(sv))
#  define SvRELEASE_IVX_(sv)	SvRELEASE_IVX(sv),
#  define SvCANCOW(sv) \
	(SvIsCOW(sv) || (SvFLAGS(sv) & CAN_COW_MASK) == CAN_COW_FLAGS)
/* This is a pessimistic view. Scalar must be purely a read-write PV to copy-
   on-write.  */
#  define CAN_COW_MASK	(SVs_OBJECT|SVs_GMG|SVs_SMG|SVs_RMG|SVf_IOK|SVf_NOK| \
			 SVf_POK|SVf_ROK|SVp_IOK|SVp_NOK|SVp_POK|SVf_FAKE| \
			 SVf_OOK|SVf_BREAK|SVf_READONLY)
#else
#  define SvRELEASE_IVX(sv)   0
/* This little game brought to you by the need to shut this warning up:
mg.c: In function 'Perl_magic_get':
mg.c:1024: warning: left-hand operand of comma expression has no effect
*/
#  define SvRELEASE_IVX_(sv)  /**/
#  ifdef PERL_NEW_COPY_ON_WRITE
d1882 2
a1883 3
			 SVf_OOK|SVf_BREAK|SVf_READONLY)
#  endif
#endif /* PERL_OLD_COPY_ON_WRITE */
d1933 6
d1972 1
a1972 1
/* the following macros update any magic values this sv is associated with */
d1989 1
a1989 1
Calls C<sv_setsv> if dsv is not the same as ssv.  May evaluate arguments
d1993 2
a1994 2
Calls a non-destructive version of C<sv_setsv> if dsv is not the same as
ssv.  May evaluate arguments more than once.
d2003 1
a2003 1
Arranges for sv to be shared between threads if a suitable module
d2007 1
a2007 1
Arranges for a mutual exclusion lock to be obtained on sv if a suitable module
d2011 1
a2011 1
Releases a mutual exclusion lock on sv if a suitable module
d2021 1
a2021 1
buffer.  SV must be of type >= SVt_PV.  One
d2081 1
a2081 1
See also C<PL_sv_yes> and C<PL_sv_no>.
d2139 1
a2139 1
characters) into it.  If utf8 is true, calls
d2150 1
a2150 3
Creates a new SV containing the pad name.  This is currently identical
to C<newSVsv>, but pad names may cease being SVs at some point, so
C<newSVpadname> is preferable.
d2155 1
a2155 1
#define newSVpadname(pn) newSVsv(pn)
d2160 1
a2160 1
Reads into I<len> the offset from SvPVX back to the true start of the
d2163 2
a2164 2
macro, which takes the address of I<len>, which must be of type C<STRLEN>.
Evaluates I<sv> more than once.  Sets I<len> to 0 if C<SvOOK(sv)> is false.
d2263 1
a2263 5
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
d2265 32
@


1.18
log
@Fix merge issues, remove excess files - match perl-5.20.2 dist
@
text
@d795 2
a796 2
Set the value of the PV pointer in C<sv> to the C<NUL>-terminated string
C<val>.  See also C<SvIV_set>.
d798 4
d805 2
a806 1
modification is safe.
@


1.17
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d1515 1
a1515 1
don't use C<&len>). See also C<SvPVx> for a version which guarantees to
@


1.16
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@a24 1
    SVt_BIND (unused)
d32 1
d60 3
a62 1
a typeglob. SVt_REGEXP is for regular expressions.
d96 3
d124 5
d131 1
d134 3
a136 3
	SVt_BIND,	/* 1 */
	SVt_IV,		/* 2 */
	SVt_NV,		/* 3 */
d138 2
a139 1
	SVt_PV,		/* 4 */
d156 3
a158 1
 * SVt_MASK and the various PL_valid_types_* tables */
d164 1
a164 1
   purposes eternal code wanting to consider PVBM probably needs to think of
d301 1
a301 1
Decrements the reference count of the given SV. I<sv> may be NULL.
d364 1
d408 3
d416 2
a417 3
					   

/* Some private flags. */
d423 3
a425 2
/* PVHV */
#define SVphv_SHAREKEYS 0x20000000  /* PVHV keys live on shared string table */
a483 4
    struct {
	I32 xbm_useful;
	U8  xbm_rare;		/* rarest character in string */
    }	    xbm_s;		/* fields from PVBM */
d496 1
a496 1
};
d533 4
a536 1
    STRLEN	xlv_targoff;
d544 9
d561 1
a561 1
typedef U16 cv_flags_t;
d653 1
a653 1
Returns a U32 value indicating whether the value is defined. This is
d759 2
a760 1
string. Prior to 5.9.3 it is not safe to execute this macro unless the SV's
d776 1
a776 1
null (even though Perl scalars do not strictly require it).
d795 2
a796 1
Set the value of the PV pointer in sv to val.  See also C<SvIV_set>.
d963 1
d1088 1
a1088 1
				   if (SvFLAGS(_svvalid) & SVpbm_VALID)	\
d1094 1
d1099 1
d1104 3
a1106 2
			    assert(SvTYPE(_svtail) != SVt_PVAV);		\
			    assert(SvTYPE(_svtail) != SVt_PVHV);		\
d1111 1
a1111 1
#  define SvVALID(sv)		(SvFLAGS(sv) & SVpbm_VALID)
d1366 1
a1366 1
			 if(SvOOK(sv)) {				\
a1395 6
#  define BmRARE(sv)							\
	(*({ SV *const _bmrare = MUTABLE_SV(sv);			\
		assert(SvTYPE(_bmrare) == SVt_PVMG);			\
		assert(SvVALID(_bmrare));				\
	    &(((XPVMG*) SvANY(_bmrare))->xnv_u.xbm_s.xbm_rare);		\
	 }))
d1398 1
a1398 1
	    assert(SvTYPE(_bmuseful) == SVt_PVMG);			\
d1401 1
a1401 7
	    &(((XPVMG*) SvANY(_bmuseful))->xnv_u.xbm_s.xbm_useful);	\
	 }))
#  define BmPREVIOUS(sv)						\
    (*({ SV *const _bmprevious = MUTABLE_SV(sv);			\
		assert(SvTYPE(_bmprevious) == SVt_PVMG);		\
		assert(SvVALID(_bmprevious));				\
	    &(((XPVMG*) SvANY(_bmprevious))->xiv_u.xivu_uv);		\
d1404 3
a1406 3
#  define BmRARE(sv)		((XPVMG*) SvANY(sv))->xnv_u.xbm_s.xbm_rare
#  define BmUSEFUL(sv)		((XPVMG*) SvANY(sv))->xnv_u.xbm_s.xbm_useful
#  define BmPREVIOUS(sv)	((XPVMG*) SvANY(sv))->xiv_u.xivu_uv
d1408 3
d1418 1
d1463 1
a1463 1
unconditionally untainting the value. Untainting should be done in the
d1479 1
a1479 1
#if NO_TAINT_SUPPORT
d1484 2
a1485 2
#define SvTAINTED_on(sv)  STMT_START{ if(TAINTING_get){sv_taint(sv);}   }STMT_END
#define SvTAINTED_off(sv) STMT_START{ if(TAINTING_get){sv_untaint(sv);} }STMT_END
d1489 2
a1490 2
	if (TAINTING_get) {		\
	    if (TAINT_get)		\
d1502 1
a1502 1
strip useful data from it. For example if the SV was C<SvROK>, then the
d1513 4
a1516 2
stringified version becoming C<SvPOK>.  Handles 'get' magic.  See also
C<SvPVx> for a version which guarantees to evaluate sv only once.
d1520 2
a1521 2
successive calls to C<SvPV(sv)) will return the same pointer value each
time. This is due to the way that things like overloading and
d1628 2
a1629 2
=for apidoc Am|bool|SvIsCOW|SV* sv
Returns a boolean indicating whether the SV is Copy-On-Write (either shared
d1711 1
d1762 3
a1764 3
#define SvTRUE(sv)        ((sv) && (SvGMAGICAL(sv) ? sv_2bool(sv) : SvTRUE_common(sv, sv_2bool_nomg(sv))))
#define SvTRUE_nomg(sv)   ((sv) && (                                SvTRUE_common(sv, sv_2bool_nomg(sv))))
#define SvTRUE_NN(sv)              (SvGMAGICAL(sv) ? sv_2bool(sv) : SvTRUE_common(sv, sv_2bool_nomg(sv)))
a1914 6
#   ifndef SV_COW_THRESHOLD
#    define SV_COW_THRESHOLD	0	/* min string length for cow */
#   endif
#   ifndef SV_COWBUF_THRESHOLD
#    define SV_COWBUF_THRESHOLD	1250	/* min string length for cow */
#   endif				/* over existing buffer */
d1983 1
a1983 1
#ifdef PERL_CORE
a1987 1
# define sv_or_pv_pos_u2b(sv,s,p,lp) S_sv_or_pv_pos_u2b(aTHX_ sv,s,p,lp)
d2017 1
a2017 1
=for apidoc Am|void|SvSetSV|SV* dsb|SV* ssv
d2019 1
a2019 1
more than once.
d2025 1
a2025 1
=for apidoc Am|void|SvSetMagicSV|SV* dsb|SV* ssv
d2048 3
a2050 2
NUL character).  Calls C<sv_grow> to perform the expansion if necessary.
Returns a pointer to the character buffer. SV must be of type >= SVt_PV. One
d2061 2
a2062 2
#define SvGETMAGIC(x) ((void)(SvGMAGICAL(x) && mg_get(x)))
#define SvSETMAGIC(x) STMT_START { if (SvSMAGICAL(x)) mg_set(x); } STMT_END
d2066 1
a2066 1
	    if ((dst) != (src)) {			\
d2073 1
a2073 1
	    if ((dst) != (src)) {			\
d2141 1
a2141 1
#ifdef PERL_NEW_COPY_ON_WRITE
d2167 2
a2168 1
Creates a new SV and copies a string into it.  If utf8 is true, calls
d2244 48
@


1.15
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d22 53
a74 2
=for apidoc AmU||SVt_PV
Pointer type flag for scalars.  See C<svtype>.
d77 1
a77 1
Integer type flag for scalars.  See C<svtype>.
d80 10
a89 1
Double type flag for scalars.  See C<svtype>.
d92 10
a101 1
Type flag for blessed scalars.  See C<svtype>.
d104 1
a104 1
Type flag for arrays.  See C<svtype>.
d107 1
a107 1
Type flag for hashes.  See C<svtype>.
d110 7
a116 1
Type flag for code refs.  See C<svtype>.
d186 1
d247 1
a247 1
Increments the reference count of the given SV.
d287 6
a292 1
Decrements the reference count of the given SV.
d308 4
a311 36
#if defined(__GNUC__) && !defined(PERL_GCC_BRACE_GROUPS_FORBIDDEN)
#  define SvREFCNT_inc(sv)		\
    ({					\
	SV * const _sv = MUTABLE_SV(sv);	\
	if (_sv)			\
	     (SvREFCNT(_sv))++;		\
	_sv;				\
    })
#  define SvREFCNT_inc_simple(sv)	\
    ({					\
	if (sv)				\
	     (SvREFCNT(sv))++;		\
	MUTABLE_SV(sv);				\
    })
#  define SvREFCNT_inc_NN(sv)		\
    ({					\
	SV * const _sv = MUTABLE_SV(sv);	\
	SvREFCNT(_sv)++;		\
	_sv;				\
    })
#  define SvREFCNT_inc_void(sv)		\
    ({					\
	SV * const _sv = MUTABLE_SV(sv);	\
	if (_sv)			\
	    (void)(SvREFCNT(_sv)++);	\
    })
#else
#  define SvREFCNT_inc(sv)	\
	((PL_Sv=MUTABLE_SV(sv)) ? (++(SvREFCNT(PL_Sv)),PL_Sv) : NULL)
#  define SvREFCNT_inc_simple(sv) \
	((sv) ? (SvREFCNT(sv)++,MUTABLE_SV(sv)) : NULL)
#  define SvREFCNT_inc_NN(sv) \
	(PL_Sv=MUTABLE_SV(sv),++(SvREFCNT(PL_Sv)),PL_Sv)
#  define SvREFCNT_inc_void(sv) \
	(void)((PL_Sv=MUTABLE_SV(sv)) ? ++(SvREFCNT(PL_Sv)) : 0)
#endif
d319 2
a320 16
#if defined(__GNUC__) && !defined(PERL_GCC_BRACE_GROUPS_FORBIDDEN)
#  define SvREFCNT_dec(sv)		\
    ({					\
	SV * const _sv = MUTABLE_SV(sv);	\
	if (_sv) {			\
	    if (SvREFCNT(_sv)) {	\
		if (--(SvREFCNT(_sv)) == 0) \
		    Perl_sv_free2(aTHX_ _sv);	\
	    } else {			\
		sv_free(_sv);		\
	    }				\
	}				\
    })
#else
#define SvREFCNT_dec(sv)	sv_free(MUTABLE_SV(sv))
#endif
d330 4
a333 1
#define SvUPGRADE(sv, mt) (SvTYPE(sv) >= (mt) || (sv_upgrade(sv, mt), 1))
d343 1
a343 1
#define SVp_SCREAM	0x00008000  /* has been studied? */
d348 1
a348 1
				       CvIMPORTED_CV_ON() if it needs to be
d350 2
a351 1
/*                      0x00010000  *** FREE SLOT */
d366 1
a366 5
				       2: in conjunction with SVf_READONLY
					  marks a shared hash key scalar
					  (SvLEN == 0) or a copy on write
					  string (SvLEN != 0) [SvIsCOW(sv)]
				       3: For PVCV, whether CvUNIQUE(cv)
d369 1
a369 1
				       4: On a pad name SV, that slot in the
a371 2
#define SVphv_REHASH	SVf_FAKE    /* 5: On a PVHV, hash values are being
					  recalculated */
d384 1
a384 1
#define SVf_THINKFIRST	(SVf_READONLY|SVf_ROK|SVf_FAKE)
d414 1
a414 1
   0x0000C400   Studied (SvSCREAM)
d452 6
a457 1
    STRLEN	xpv_len 	/* allocated size */
a534 2
/* This structure must match XPVCV in cv.h */

d547 4
a550 1
    GV *	xcv_gv;								\
d552 1
a552 1
    AV *	xcv_padlist;							\
d557 4
a560 1
    cv_flags_t	xcv_flags
a564 1
    IV		xfm_lines;
d655 1
a655 1
Tells and SV that it is an unsigned integer and disables all other OK bits.
d658 3
a660 1
Returns a boolean indicating whether the SV contains an unsigned integer.
d663 3
a665 1
Returns a boolean indicating whether the SV contains an unsigned integer.
d733 2
a734 1
string.
d768 6
a773 1
Set the value of the PV pointer in sv to val.  See C<SvIV_set>.
d802 2
a803 7
#if defined(__GNUC__) && !defined(PERL_GCC_BRACE_GROUPS_FORBIDDEN)
#define assert_not_ROK(sv)	({assert(!SvROK(sv) || !SvRV(sv));}),
#define assert_not_glob(sv)	({assert(!isGV_with_GP(sv));}),
#else
#define assert_not_ROK(sv)	
#define assert_not_glob(sv)	
#endif
d805 1
a805 3
#define SvOK(sv)		((SvTYPE(sv) == SVt_BIND)		\
				 ? (SvFLAGS(SvRV(sv)) & SVf_OK)		\
				 : (SvFLAGS(sv) & SVf_OK))
d855 2
a856 2
Call this after SvPV() in case any call to string overloading updates the
internal flag.
d926 33
a958 15
#define SvAMAGIC(sv)		(SvROK(sv) && (SvFLAGS(SvRV(sv)) & SVf_AMAGIC))
#if defined(__GNUC__) && !defined(PERL_GCC_BRACE_GROUPS_FORBIDDEN)
#  define SvAMAGIC_on(sv)	({ SV * const kloink = sv;		\
				   assert(SvROK(kloink));		\
				   SvFLAGS(SvRV(kloink)) |= SVf_AMAGIC;	\
				})
#  define SvAMAGIC_off(sv)	({ SV * const kloink = sv;		\
				   if(SvROK(kloink))			\
					SvFLAGS(SvRV(kloink)) &= ~SVf_AMAGIC;\
				})
#else
#  define SvAMAGIC_on(sv)	(SvFLAGS(SvRV(sv)) |= SVf_AMAGIC)
#  define SvAMAGIC_off(sv) \
	(SvROK(sv) && (SvFLAGS(SvRV(sv)) &= ~SVf_AMAGIC))
#endif
d976 4
a979 1
#define Gv_AMG(stash)           (PL_amagic_generation && Gv_AMupdate(stash, FALSE))
d991 24
d1026 4
a1029 27
#if defined (DEBUGGING) && defined(__GNUC__) && !defined(PERL_GCC_BRACE_GROUPS_FORBIDDEN)
#  define SvPADTMP_on(sv)	({			\
	    SV *const _svpad = MUTABLE_SV(sv);		\
	    assert(!(SvFLAGS(_svpad) & SVs_PADMY));	\
	    SvFLAGS(_svpad) |= SVs_PADTMP;		\
	})
#  define SvPADTMP_off(sv)	({			\
	    SV *const _svpad = MUTABLE_SV(sv);		\
	    assert(!(SvFLAGS(_svpad) & SVs_PADMY));	\
	    SvFLAGS(_svpad) &= ~SVs_PADTMP;		\
	})
#  define SvPADSTALE_on(sv)	({			\
	    SV *const _svpad = MUTABLE_SV(sv);		\
	    assert(SvFLAGS(_svpad) & SVs_PADMY);	\
	    SvFLAGS(_svpad) |= SVs_PADSTALE;		\
	})
#  define SvPADSTALE_off(sv)	({			\
	    SV *const _svpad = MUTABLE_SV(sv);		\
	    assert(SvFLAGS(_svpad) & SVs_PADMY);	\
	    SvFLAGS(_svpad) &= ~SVs_PADSTALE;		\
	})
#else
#  define SvPADTMP_on(sv)	(SvFLAGS(sv) |= SVs_PADTMP)
#  define SvPADTMP_off(sv)	(SvFLAGS(sv) &= ~SVs_PADTMP)
#  define SvPADSTALE_on(sv)	(SvFLAGS(sv) |= SVs_PADSTALE)
#  define SvPADSTALE_off(sv)	(SvFLAGS(sv) &= ~SVs_PADSTALE)
#endif
d1141 1
a1141 1
#    define SvPVX(sv) (0 + (assert(!SvREADONLY(sv)), (sv)->sv_u.svu_pv))
d1149 2
a1150 7
#  ifdef DEBUGGING
#    define SvMAGIC(sv)	(0 + *(assert(SvTYPE(sv) >= SVt_PVMG), &((XPVMG*)  SvANY(sv))->xmg_u.xmg_magic))
#    define SvSTASH(sv)	(0 + *(assert(SvTYPE(sv) >= SVt_PVMG), &((XPVMG*)  SvANY(sv))->xmg_stash))
#  else
#    define SvMAGIC(sv)	(0 + ((XPVMG*)  SvANY(sv))->xmg_u.xmg_magic)
#    define SvSTASH(sv)	(0 + ((XPVMG*)  SvANY(sv))->xmg_stash)
#  endif
d1167 2
a1168 1
	    assert(PL_valid_types_PVX[SvTYPE(_svcur) & SVt_MASK]);	\
d1260 3
a1262 2
	STMT_START {if (!SvIOKp(sv) && (SvNOK(sv) || SvPOK(sv))) \
		(void) SvIV_nomg(sv); } STMT_END
d1300 2
a1301 1
		assert(PL_valid_types_PVX[SvTYPE(sv) & SVt_MASK]);	\
d1390 1
a1390 1
#define FmLINES(sv)	((XPVFM*)  SvANY(sv))->xfm_lines
d1455 7
a1461 3
#define SvTAINTED(sv)	  (SvMAGICAL(sv) && sv_tainted(sv))
#define SvTAINTED_on(sv)  STMT_START{ if(PL_tainting){sv_taint(sv);}   }STMT_END
#define SvTAINTED_off(sv) STMT_START{ if(PL_tainting){sv_untaint(sv);} }STMT_END
d1465 2
a1466 2
	if (PL_tainting) {		\
	    if (PL_tainted)		\
d1473 9
a1481 3
Like C<SvPV> but will force the SV into containing just a string
(C<SvPOK_only>).  You want force if you are going to update the C<SvPVX>
directly.
d1484 1
a1484 3
Like C<SvPV> but will force the SV into containing just a string
(C<SvPOK_only>).  You want force if you are going to update the C<SvPVX>
directly.  Doesn't process magic.
d1492 9
d1510 1
a1510 3
Returns a pointer to the string in the SV, or a stringified form of
the SV if the SV does not contain a string.  The SV may cache the
stringified form becoming C<SvPOK>.  Handles 'get' magic.
d1550 1
a1550 1
returns it.  Guarantees to C<sv> only once.  Only
d1631 3
a1633 3
#define SvIV(sv) (SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv))
#define SvUV(sv) (SvIOK(sv) ? SvUVX(sv) : sv_2uv(sv))
#define SvNV(sv) (SvNOK(sv) ? SvNVX(sv) : sv_2nv(sv))
d1641 2
a1642 2
#define SvPV(sv, lp) SvPV_flags(sv, lp, SV_GMAGIC)
#define SvPV_const(sv, lp) SvPV_flags_const(sv, lp, SV_GMAGIC)
d1646 1
a1646 1
    ((SvFLAGS(sv) & (SVf_POK)) == SVf_POK \
d1649 1
a1649 1
    ((SvFLAGS(sv) & (SVf_POK)) == SVf_POK \
d1653 1
a1653 1
    ((SvFLAGS(sv) & (SVf_POK)) == SVf_POK \
d1657 1
a1657 1
    ((SvFLAGS(sv) & (SVf_POK)) == SVf_POK \
d1669 3
a1671 2
    ((SvFLAGS(sv) & (SVf_POK|SVf_THINKFIRST)) == SVf_POK \
    ? ((lp = SvCUR(sv)), SvPVX(sv)) : sv_pvn_force_flags(sv, &lp, flags))
d1673 3
a1675 2
    ((SvFLAGS(sv) & (SVf_POK|SVf_THINKFIRST)) == SVf_POK \
    ? SvPVX(sv) : sv_pvn_force_flags(sv, 0, flags))
d1677 2
a1678 2
    ((SvFLAGS(sv) & (SVf_POK|SVf_THINKFIRST)) == SVf_POK \
    ? ((lp = SvCUR(sv)), SvPVX_mutable(sv)) \
d1682 1
a1682 1
    ((SvFLAGS(sv) & (SVf_POK)) == SVf_POK \
d1686 1
a1686 1
    ((SvFLAGS(sv) & (SVf_POK)) == SVf_POK \
d1690 1
a1690 1
    ((SvFLAGS(sv) & (SVf_POK)) == SVf_POK \
d1700 1
a1700 1
    ((SvFLAGS(sv) & (SVf_POK|SVf_UTF8)) == (SVf_POK|SVf_UTF8) \
d1704 1
a1704 1
    ((SvFLAGS(sv) & (SVf_POK|SVf_UTF8|SVf_THINKFIRST)) == (SVf_POK|SVf_UTF8) \
a1706 1

d1708 1
a1708 1
    ((SvFLAGS(sv) & (SVf_POK|SVf_UTF8)) == (SVf_POK|SVf_UTF8)\
d1714 1
a1714 1
    ((SvFLAGS(sv) & (SVf_POK|SVf_UTF8)) == (SVf_POK) \
d1718 1
a1718 1
    ((SvFLAGS(sv) & (SVf_POK|SVf_UTF8|SVf_THINKFIRST)) == (SVf_POK) \
d1722 1
a1722 1
    ((SvFLAGS(sv) & (SVf_POK|SVf_UTF8)) == (SVf_POK)\
a1724 1

d1735 14
d1761 2
a1762 33
#  define SvTRUE(sv) (						\
    !sv								\
    ? 0								\
    :    SvPOK(sv)						\
	?   (({XPV *nxpv = (XPV*)SvANY(sv);			\
	     nxpv &&						\
	     (nxpv->xpv_cur > 1 ||				\
	      (nxpv->xpv_cur && *(sv)->sv_u.svu_pv != '0')); })	\
	     ? 1						\
	     : 0)						\
	:							\
	    SvIOK(sv)						\
	    ? SvIVX(sv) != 0					\
	    :   SvNOK(sv)					\
		? SvNVX(sv) != 0.0				\
		: sv_2bool(sv) )
#  define SvTRUE_nomg(sv) (					\
    !sv								\
    ? 0								\
    :    SvPOK(sv)						\
	?   (({XPV *nxpv = (XPV*)SvANY(sv);			\
	     nxpv &&						\
	     (nxpv->xpv_cur > 1 ||				\
	      (nxpv->xpv_cur && *(sv)->sv_u.svu_pv != '0')); })	\
	     ? 1						\
	     : 0)						\
	:							\
	    SvIOK(sv)						\
	    ? SvIVX(sv) != 0					\
	    :   SvNOK(sv)					\
		? SvNVX(sv) != 0.0				\
		: sv_2bool_flags(sv,0) )
#  define SvTRUEx(sv) ({SV *_sv = (sv); SvTRUE(_sv); })
d1779 2
a1780 31
#  define SvTRUE(sv) (						\
    !sv								\
    ? 0								\
    :    SvPOK(sv)						\
	?   ((PL_Xpv = (XPV*)SvANY(PL_Sv = (sv))) &&		\
	     (PL_Xpv->xpv_cur > 1 ||				\
	      (PL_Xpv->xpv_cur && *PL_Sv->sv_u.svu_pv != '0'))	\
	     ? 1						\
	     : 0)						\
	:							\
	    SvIOK(sv)						\
	    ? SvIVX(sv) != 0					\
	    :   SvNOK(sv)					\
		? SvNVX(sv) != 0.0				\
		: sv_2bool(sv) )
#  define SvTRUE_nomg(sv) (					\
    !sv								\
    ? 0								\
    :    SvPOK(sv)						\
	?   ((PL_Xpv = (XPV*)SvANY(PL_Sv = (sv))) &&		\
	     (PL_Xpv->xpv_cur > 1 ||				\
	      (PL_Xpv->xpv_cur && *PL_Sv->sv_u.svu_pv != '0'))	\
	     ? 1						\
	     : 0)						\
	:							\
	    SvIOK(sv)						\
	    ? SvIVX(sv) != 0					\
	    :   SvNOK(sv)					\
		? SvNVX(sv) != 0.0				\
		: sv_2bool_flags(sv,0) )
#  define SvTRUEx(sv) ((PL_Sv = (sv)), SvTRUE(PL_Sv))
d1783 14
a1796 3
#define SvIsCOW(sv)	((SvFLAGS(sv) & (SVf_FAKE | SVf_READONLY)) == \
			   (SVf_FAKE | SVf_READONLY) && !isGV_with_GP(sv) \
			   && SvTYPE(sv) != SVt_REGEXP)
d1865 7
d1879 18
a1898 3
#define CAN_COW_MASK	(SVs_OBJECT|SVs_GMG|SVs_SMG|SVs_RMG|SVf_IOK|SVf_NOK| \
			 SVf_POK|SVf_ROK|SVp_IOK|SVp_NOK|SVp_POK|SVf_FAKE| \
			 SVf_OOK|SVf_BREAK|SVf_READONLY)
d1923 3
a1925 2
#define sv_catpvn_mg(sv, sstr, slen) \
	sv_catpvn_flags(sv, sstr, slen, SV_GMAGIC|SV_SMAGIC);
d1941 1
d1945 2
d1949 1
a1949 1
#define sv_catpvn_utf8_upgrade(dsv, sstr, slen, nsv)	\
d1957 1
a1957 1
	    sv_catsv(dsv, nsv);	\
d1959 10
d1987 2
a1988 1
Invokes C<mg_get> on an SV if it has 'get' magic.  This macro evaluates its
d1992 3
a1994 1
Invokes C<mg_set> on an SV if it has 'set' magic.  This macro evaluates its
d2029 2
a2030 1
Returns a pointer to the character buffer.
d2075 8
a2082 1
#define SvIMMORTAL(sv) ((sv)==&PL_sv_undef || (sv)==&PL_sv_yes || (sv)==&PL_sv_no || (sv)==&PL_sv_placeholder)
d2114 4
d2120 6
a2125 1
#define SvGROW(sv,len) (SvLEN(sv) < (len) ? sv_grow(sv,len) : SvPVX(sv))
d2155 12
d2186 5
a2190 5
	    const U8 *crash = (U8*)SvPVX_const(sv);			\
	    offset = *--crash;						\
 	    if (!offset) {						\
		crash -= sizeof(STRLEN);				\
		Copy(crash, (U8 *)&offset, sizeof(STRLEN), U8);		\
d2195 4
a2198 4
		const U8 *const bonk = (U8 *) SvPVX_const(sv) - offset;	\
		while (crash > bonk) {					\
		    --crash;						\
		    assert (*crash == (U8)PTR2UV(crash));		\
d2202 1
a2202 1
	    offset = 0;							\
d2210 2
a2211 2
	    offset = ((U8*)SvPVX_const(sv))[-1];			\
	    if (!offset) {						\
d2213 1
a2213 1
		     (U8 *)&offset, sizeof(STRLEN), U8);		\
d2216 1
a2216 1
	    offset = 0;							\
d2227 1
a2227 1
 * indent-tabs-mode: t
d2230 1
a2230 1
 * ex: set ts=8 sts=4 sw=4 noet:
@


1.14
log
@merge in perl 5.12.2 plus local changes
@
text
@d68 5
d84 3
a86 7
   and SVt_IV, so never reaches the clause at the end that uses
   sv_type_details->body_size to determine whether to call safefree(). Hence
   body_size can be set no-zero to record the size of PTEs and HEs, without
   fear of bogus frees.  */
#ifdef PERL_IN_SV_C
#define PTE_SVSLOT	SVt_IV
#endif
d114 1
a123 1
    PERL_BITFIELD32 sv_debug_cloned:1;	/* was cloned for an ithread */
d125 3
a127 2
    U32		    sv_debug_serial;	/* serial number of sv allocation   */
    char *	sv_debug_file;		/* the file where we were allocated */
d312 4
a315 4

#define SVs_PADSTALE	0x00010000  /* lexical has gone out of scope */
#define SVpad_STATE	0x00010000  /* pad name is a "state" var */
#define SVs_PADTMP	0x00020000  /* in use as tmp */
d325 1
a325 1
#define SVf_FAKE	0x01000000  /* 0: glob or lexical is just a copy
d375 15
a389 2
/* PVNV, PVMG, presumably only inside pads */
#define SVpad_NAME	0x40000000  /* This SV is a name in the PAD, so
d399 1
a399 1
/* ??? */
a402 1
/* Presumably IVs aren't stored in pads */
a407 2
/* PVFM */
#define SVpfm_COMPILED	0x80000000  /* FORMLINE is compiled */
d412 2
d415 3
a417 2
#define _XPV_HEAD	\
    union _xnvu xnv_u;	\
d429 1
a429 2
	U32 xbm_previous;	/* how many characters in string before rare? */
	U8  xbm_flags;
a435 1
				/* xpvfm: lines */
a436 2
    void *  xivu_p1;
    I32	    xivu_i32;
a437 1
    HV *    xivu_hv;		/* regexp: paren_names */
d443 1
d467 1
a469 5
#define _XPVMG_HEAD				    \
    union _xivu xiv_u;				    \
    union _xmgu	xmg_u;				    \
    HV*		xmg_stash	/* class package */

d473 2
a474 1
    _XPVMG_HEAD;
d479 2
a480 2
    _XPVMG_HEAD;

d486 1
d493 2
a494 1
    _XPVMG_HEAD;
a521 1
    _XPVMG_HEAD;
d523 1
a525 29
#define _XPVIO_TAIL							\
    PerlIO *	xio_ifp;	/* ifp and ofp are normally the same */	\
    PerlIO *	xio_ofp;	/* but sockets need separate streams */	\
    /* Cray addresses everything by word boundaries (64 bits) and	\
     * code and data pointers cannot be mixed (which is exactly what	\
     * Perl_filter_add() tries to do with the dirp), hence the		\
     *  following union trick (as suggested by Gurusamy Sarathy).	\
     * For further information see Geir Johansen's problem report	\
     * titled [ID 20000612.002] Perl problem on Cray system		\
     * The any pointer (known as IoANY()) will also be a good place	\
     * to hang any IO disciplines to.					\
     */									\
    union {								\
	DIR *	xiou_dirp;	/* for opendir, readdir, etc */		\
	void *	xiou_any;	/* for alignment */			\
    } xio_dirpu;							\
    /* IV xio_lines is now in IVX  $. */				\
    IV		xio_page;	/* $% */				\
    IV		xio_page_len;	/* $= */				\
    IV		xio_lines_left;	/* $- */				\
    char *	xio_top_name;	/* $^ */				\
    GV *	xio_top_gv;	/* $^ */				\
    char *	xio_fmt_name;	/* $~ */				\
    GV *	xio_fmt_gv;	/* $~ */				\
    char *	xio_bottom_name;/* $^B */				\
    GV *	xio_bottom_gv;	/* $^B */				\
    char	xio_type;						\
    U8		xio_flags

d529 28
a556 2
    _XPVMG_HEAD;
    _XPVIO_TAIL;
d568 2
a569 1
#define IOf_FAKE_DIRP	64	/* xio_dirp is fake (source filters kludge) */
d676 1
a676 1
Only use when you are sure SvIOK is true. See also C<SvIV()>.
d680 1
a680 1
Only use when you are sure SvIOK is true. See also C<SvUV()>.
d684 1
a684 1
Only use when you are sure SvNOK is true. See also C<SvNV()>.
d690 3
d701 3
a703 1
Returns a pointer to the last character in the string which is in the SV.
d706 3
d809 2
a810 1
Returns a U32 value indicating whether the SV contains UTF-8 encoded data.
d819 2
a820 1
Unsets the UTF-8 status of an SV.
d855 1
a855 1
#define SvOOK_on(sv)		((void)SvIOK_off(sv), SvFLAGS(sv) |= SVf_OOK)
d901 2
a902 1
Returns true if the SV has get magic or overloading. If either is true then
d904 3
a906 2
time it is accessed. Hence you must be careful to only read it once per user
logical operation and work with that returned value. If neither is true then
a927 8
#define SvPADSTALE(sv)		(SvFLAGS(sv) & SVs_PADSTALE)
#define SvPADSTALE_on(sv)	(SvFLAGS(sv) |= SVs_PADSTALE)
#define SvPADSTALE_off(sv)	(SvFLAGS(sv) &= ~SVs_PADSTALE)

#define SvPADTMP(sv)		(SvFLAGS(sv) & SVs_PADTMP)
#define SvPADTMP_on(sv)		(SvFLAGS(sv) |= SVs_PADTMP)
#define SvPADTMP_off(sv)	(SvFLAGS(sv) &= ~SVs_PADTMP)

d931 34
d981 5
a985 3
#define SvCOMPILED(sv)		(SvFLAGS(sv) & SVpfm_COMPILED)
#define SvCOMPILED_on(sv)	(SvFLAGS(sv) |= SVpfm_COMPILED)
#define SvCOMPILED_off(sv)	(SvFLAGS(sv) &= ~SVpfm_COMPILED)
a1062 3
#ifdef PERL_DEBUG_COW
#else
#endif
d1098 1
a1098 3
	    assert(SvTYPE(_svpvx) >= SVt_PV);				\
	    assert(SvTYPE(_svpvx) != SVt_PVAV);				\
	    assert(SvTYPE(_svpvx) != SVt_PVHV);				\
d1100 2
d1106 1
a1106 3
	    assert(SvTYPE(_svcur) >= SVt_PV);				\
	    assert(SvTYPE(_svcur) != SVt_PVAV);				\
	    assert(SvTYPE(_svcur) != SVt_PVHV);				\
d1108 2
d1114 1
a1114 6
	    assert(SvTYPE(_svivx) == SVt_IV || SvTYPE(_svivx) >= SVt_PVIV); \
	    assert(SvTYPE(_svivx) != SVt_PVAV);				\
	    assert(SvTYPE(_svivx) != SVt_PVHV);				\
	    assert(SvTYPE(_svivx) != SVt_PVCV);				\
	    assert(SvTYPE(_svivx) != SVt_PVFM);				\
	    assert(SvTYPE(_svivx) != SVt_PVIO);				\
d1120 1
a1120 6
	    assert(SvTYPE(_svuvx) == SVt_IV || SvTYPE(_svuvx) >= SVt_PVIV); \
	    assert(SvTYPE(_svuvx) != SVt_PVAV);				\
	    assert(SvTYPE(_svuvx) != SVt_PVHV);				\
	    assert(SvTYPE(_svuvx) != SVt_PVCV);				\
	    assert(SvTYPE(_svuvx) != SVt_PVFM);				\
	    assert(SvTYPE(_svuvx) != SVt_PVIO);				\
d1126 1
a1126 6
	    assert(SvTYPE(_svnvx) == SVt_NV || SvTYPE(_svnvx) >= SVt_PVNV); \
	    assert(SvTYPE(_svnvx) != SVt_PVAV);				\
	    assert(SvTYPE(_svnvx) != SVt_PVHV);				\
	    assert(SvTYPE(_svnvx) != SVt_PVCV);				\
	    assert(SvTYPE(_svnvx) != SVt_PVFM);				\
	    assert(SvTYPE(_svnvx) != SVt_PVIO);				\
d1132 1
a1132 5
	    assert(SvTYPE(_svrv) >= SVt_PV || SvTYPE(_svrv) == SVt_IV);	\
	    assert(SvTYPE(_svrv) != SVt_PVAV);				\
	    assert(SvTYPE(_svrv) != SVt_PVHV);				\
	    assert(SvTYPE(_svrv) != SVt_PVCV);				\
	    assert(SvTYPE(_svrv) != SVt_PVFM);				\
d1134 2
d1140 1
a1140 5
	    assert(SvTYPE(_svrv) >= SVt_PV || SvTYPE(_svrv) == SVt_IV);	\
	    assert(SvTYPE(_svrv) != SVt_PVAV);				\
	    assert(SvTYPE(_svrv) != SVt_PVHV);				\
	    assert(SvTYPE(_svrv) != SVt_PVCV);				\
	    assert(SvTYPE(_svrv) != SVt_PVFM);				\
d1142 2
d1197 3
d1201 2
a1202 4
	STMT_START { assert(SvTYPE(sv) == SVt_IV || SvTYPE(sv) >= SVt_PVIV); \
		assert(SvTYPE(sv) != SVt_PVAV);		\
		assert(SvTYPE(sv) != SVt_PVHV);		\
		assert(SvTYPE(sv) != SVt_PVCV);		\
d1206 2
a1207 4
	STMT_START { assert(SvTYPE(sv) == SVt_NV || SvTYPE(sv) >= SVt_PVNV); \
	    assert(SvTYPE(sv) != SVt_PVAV); assert(SvTYPE(sv) != SVt_PVHV); \
	    assert(SvTYPE(sv) != SVt_PVCV); assert(SvTYPE(sv) != SVt_PVFM); \
		assert(SvTYPE(sv) != SVt_PVIO);		\
d1211 2
a1212 3
	STMT_START { assert(SvTYPE(sv) >= SVt_PV); \
		assert(SvTYPE(sv) != SVt_PVAV);		\
		assert(SvTYPE(sv) != SVt_PVHV);		\
d1214 2
d1218 2
a1219 4
	STMT_START { assert(SvTYPE(sv) == SVt_IV || SvTYPE(sv) >= SVt_PVIV); \
		assert(SvTYPE(sv) != SVt_PVAV);		\
		assert(SvTYPE(sv) != SVt_PVHV);		\
		assert(SvTYPE(sv) != SVt_PVCV);		\
d1223 2
a1224 5
        STMT_START { assert(SvTYPE(sv) >=  SVt_PV || SvTYPE(sv) ==  SVt_IV); \
		assert(SvTYPE(sv) != SVt_PVAV);		\
		assert(SvTYPE(sv) != SVt_PVHV);		\
		assert(SvTYPE(sv) != SVt_PVCV);		\
		assert(SvTYPE(sv) != SVt_PVFM);		\
d1226 2
d1236 2
a1237 3
	STMT_START { assert(SvTYPE(sv) >= SVt_PV); \
		assert(SvTYPE(sv) != SVt_PVAV);		\
		assert(SvTYPE(sv) != SVt_PVHV);		\
d1239 2
d1243 2
a1244 3
	STMT_START { assert(SvTYPE(sv) >= SVt_PV); \
		assert(SvTYPE(sv) != SVt_PVAV);	\
		assert(SvTYPE(sv) != SVt_PVHV);	\
d1246 2
d1295 3
a1297 1
#define PERL_FBM_TABLE_OFFSET 1	/* Number of bytes between EOS and table */
a1298 3
/* SvPOKp not SvPOK in the assertion because the string can be tainted! eg
   perl -T -e '/$^X/'
*/
a1299 6
#  define BmFLAGS(sv)							\
	(*({ SV *const _bmflags = MUTABLE_SV(sv);			\
		assert(SvTYPE(_bmflags) == SVt_PVGV);			\
		assert(SvVALID(_bmflags));				\
	    &(((XPVGV*) SvANY(_bmflags))->xnv_u.xbm_s.xbm_flags);	\
	 }))
d1302 1
a1302 1
		assert(SvTYPE(_bmrare) == SVt_PVGV);			\
d1304 1
a1304 1
	    &(((XPVGV*) SvANY(_bmrare))->xnv_u.xbm_s.xbm_rare);		\
d1308 1
a1308 1
	    assert(SvTYPE(_bmuseful) == SVt_PVGV);			\
d1311 1
a1311 1
	    &(((XPVGV*) SvANY(_bmuseful))->xiv_u.xivu_i32);		\
d1315 1
a1315 1
		assert(SvTYPE(_bmprevious) == SVt_PVGV);		\
d1317 1
a1317 1
	    &(((XPVGV*) SvANY(_bmprevious))->xnv_u.xbm_s.xbm_previous);	\
d1320 3
a1322 4
#  define BmFLAGS(sv)		((XPVGV*) SvANY(sv))->xnv_u.xbm_s.xbm_flags
#  define BmRARE(sv)		((XPVGV*) SvANY(sv))->xnv_u.xbm_s.xbm_rare
#  define BmUSEFUL(sv)		((XPVGV*) SvANY(sv))->xiv_u.xivu_i32
#  define BmPREVIOUS(sv)	((XPVGV*) SvANY(sv))->xnv_u.xbm_s.xbm_previous
d1326 1
a1326 1
#define FmLINES(sv)	((XPVFM*)  SvANY(sv))->xiv_u.xivu_iv
d1332 1
d1334 1
a1334 1
#define IoIFP(sv)	((XPVIO*)  SvANY(sv))->xio_ifp
d1365 1
a1365 1
Checks to see if an SV is tainted. Returns TRUE if it is, FALSE if
d1372 2
a1373 2
Untaints an SV. Be I<very> careful with this routine, as it short-circuits
some of Perl's fundamental security features. XS module authors should not
d1380 5
a1384 1
Taints an SV if tainting is enabled.
d1412 1
a1412 1
directly. Doesn't process magic.
d1417 1
a1417 1
stringified version becoming C<SvPOK>.  Handles 'get' magic. See also
d1423 1
a1423 1
more efficient C<SvPVX>.
d1433 3
d1437 1
a1437 1
Coerces the given SV to an integer and returns it. See C<SvIVx> for a
d1444 3
a1446 2
Coerces the given SV to an integer and returns it. Guarantees to evaluate
C<sv> only once. Only use this if C<sv> is an expression with side effects,
d1450 1
a1450 1
Coerce the given SV to a double and return it. See C<SvNVx> for a version
d1453 3
d1457 3
a1459 2
Coerces the given SV to a double and returns it. Guarantees to evaluate
C<sv> only once. Only use this if C<sv> is an expression with side effects,
d1470 3
a1472 2
Coerces the given SV to an unsigned integer and returns it. Guarantees to
C<sv> only once. Only use this if C<sv> is an expression with side effects,
d1477 6
d1524 1
a1524 1
Returns a boolean indicating whether the SV is Copy-On-Write. (either shared
d1526 1
a1526 1
COW)
d1535 3
d1546 1
a1546 1
Like sv_utf8_upgrade, but doesn't do magic on C<sv>
d1558 1
d1604 4
d1684 16
d1732 15
d1750 3
a1752 2
#define SvIsCOW(sv)		((SvFLAGS(sv) & (SVf_FAKE | SVf_READONLY)) == \
				    (SVf_FAKE | SVf_READONLY))
d1778 9
d1824 1
a1824 1
mg.c: In function `Perl_magic_get':
d1849 1
d1868 6
d1920 1
a1920 1
ssv. May evaluate arguments more than once.
d1951 4
a1954 4
#define SvSHARE(sv) CALL_FPTR(PL_sharehook)(aTHX_ sv)
#define SvLOCK(sv) CALL_FPTR(PL_lockhook)(aTHX_ sv)
#define SvUNLOCK(sv) CALL_FPTR(PL_unlockhook)(aTHX_ sv)
#define SvDESTROYABLE(sv) CALL_FPTR(PL_destroyhook)(aTHX_ sv)
d1956 1
a1956 1
#define SvGETMAGIC(x) STMT_START { if (SvGMAGICAL(x)) mg_get(x); } STMT_END
d1993 10
d2039 2
d2059 1
a2059 1
efficiently remove characters from start of the buffer. Implemented as a
d2061 1
a2061 1
Evaluates I<sv> more than once. Sets I<len> to 0 if C<SvOOK(sv)> is false.
@


1.13
log
@Merge in perl 5.10.1
@
text
@d51 6
a56 5
	SVt_RV,		/* 4 */
	SVt_PV,		/* 5 */
	SVt_PVIV,	/* 6 */
	SVt_PVNV,	/* 7 */
	SVt_PVMG,	/* 8 */
d73 3
d106 1
a109 1
	char*   svu_pv;		/* pointer to malloced string */	\
d124 1
a124 1
    U32		sv_debug_serial;	/* serial number of sv allocation   */
d154 5
d225 1
a225 1
#if defined(__GNUC__) && !defined(__STRICT_ANSI__) && !defined(PERL_GCC_PEDANTIC)
d268 1
a268 1
#if defined(__GNUC__) && !defined(__STRICT_ANSI__) && !defined(PERL_GCC_PEDANTIC)
d332 1
a332 3
				       4: Whether the regexp pointer is in
					  fact an offset [SvREPADTMP(sv)]
				       5: On a pad name SV, that slot in the
d335 1
a335 1
#define SVphv_REHASH	SVf_FAKE    /* 6: On a PVHV, hash values are being
d401 33
d436 1
a436 15
    union {
	NV	xnv_nv;		/* numeric value, if any */
	HV *	xgv_stash;
	struct {
	    U32	xlow;
	    U32	xhigh;
	}	xpad_cop_seq;	/* used by pad.c for cop_sequence */
	struct {
	    U32 xbm_previous;	/* how many characters in string before rare? */
	    U8	xbm_flags;
	    U8	xbm_rare;	/* rarest character in string */
	}	xbm_s;		/* fields from PVBM */
    }		xnv_u;
    STRLEN	xpv_cur;	/* length of svu_pv as a C string */
    STRLEN	xpv_len;	/* allocated size */
a438 5
typedef struct {
    STRLEN	xpv_cur;	/* length of svu_pv as a C string */
    STRLEN	xpv_len;	/* allocated size */
} xpv_allocated;

d440 2
a441 22
    union {
	NV	xnv_nv;		/* numeric value, if any */
	HV *	xgv_stash;
	struct {
	    U32	xlow;
	    U32	xhigh;
	}	xpad_cop_seq;	/* used by pad.c for cop_sequence */
	struct {
	    U32 xbm_previous;	/* how many characters in string before rare? */
	    U8	xbm_flags;
	    U8	xbm_rare;	/* rarest character in string */
	}	xbm_s;		/* fields from PVBM */
    }		xnv_u;
    STRLEN	xpv_cur;	/* length of svu_pv as a C string */
    STRLEN	xpv_len;	/* allocated size */
    union {
	IV	xivu_iv;	/* integer value or pv offset */
	UV	xivu_uv;
	void *	xivu_p1;
	I32	xivu_i32;
	HEK *	xivu_namehek;
    }		xiv_u;
a443 12
typedef struct {
    STRLEN	xpv_cur;	/* length of svu_pv as a C string */
    STRLEN	xpv_len;	/* allocated size */
    union {
	IV	xivu_iv;	/* integer value or pv offset */
	UV	xivu_uv;
	void *	xivu_p1;
	I32	xivu_i32;
	HEK *	xivu_namehek;
    }		xiv_u;
} xpviv_allocated;

d447 2
a448 21
    union {
	NV	xnv_nv;		/* numeric value, if any */
	HV *	xgv_stash;
	struct {
	    U32	xlow;
	    U32	xhigh;
	}	xpad_cop_seq;	/* used by pad.c for cop_sequence */
	struct {
	    U32 xbm_previous;	/* how many characters in string before rare? */
	    U8	xbm_flags;
	    U8	xbm_rare;	/* rarest character in string */
	}	xbm_s;		/* fields from PVBM */
    }		xnv_u;
    STRLEN	xpv_cur;	/* length of svu_pv as a C string */
    STRLEN	xpv_len;	/* allocated size */
    union {
	IV	xuvu_iv;
	UV	xuvu_uv;	/* unsigned value or pv offset */
	void *	xuvu_p1;
	HEK *	xivu_namehek;
    }		xuv_u;
d451 1
a451 1
#define xuv_uv xuv_u.xuvu_uv
d454 2
a455 22
    union {
	NV	xnv_nv;		/* numeric value, if any */
	HV *	xgv_stash;
	struct {
	    U32	xlow;
	    U32	xhigh;
	}	xpad_cop_seq;	/* used by pad.c for cop_sequence */
	struct {
	    U32 xbm_previous;	/* how many characters in string before rare? */
	    U8	xbm_flags;
	    U8	xbm_rare;	/* rarest character in string */
	}	xbm_s;		/* fields from PVBM */
    }		xnv_u;
    STRLEN	xpv_cur;	/* length of svu_pv as a C string */
    STRLEN	xpv_len;	/* allocated size */
    union {
	IV	xivu_iv;	/* integer value or pv offset */
	UV	xivu_uv;
	void *	xivu_p1;
	I32	xivu_i32;
	HEK *	xivu_namehek;
    }		xiv_u;
d458 6
a463 1
/* These structure must match the beginning of struct xpvhv in hv.h. */
d465 2
a466 27
    union {
	NV	xnv_nv;		/* numeric value, if any */
	HV *	xgv_stash;
	struct {
	    U32	xlow;
	    U32	xhigh;
	}	xpad_cop_seq;	/* used by pad.c for cop_sequence */
	struct {
	    U32 xbm_previous;	/* how many characters in string before rare? */
	    U8	xbm_flags;
	    U8	xbm_rare;	/* rarest character in string */
	}	xbm_s;		/* fields from PVBM */
    }		xnv_u;
    STRLEN	xpv_cur;	/* length of svu_pv as a C string */
    STRLEN	xpv_len;	/* allocated size */
    union {
	IV	xivu_iv;	/* integer value or pv offset */
	UV	xivu_uv;
	void *	xivu_p1;
	I32	xivu_i32;
	HEK *	xivu_namehek;
    }		xiv_u;
    union {
	MAGIC*	xmg_magic;	/* linked list of magicalness */
	HV*	xmg_ourstash;	/* Stash for our (when SvPAD_OUR is true) */
    } xmg_u;
    HV*		xmg_stash;	/* class package */
d470 2
a471 27
    union {
	NV	xnv_nv;		/* numeric value, if any */
	HV *	xgv_stash;
	struct {
	    U32	xlow;
	    U32	xhigh;
	}	xpad_cop_seq;	/* used by pad.c for cop_sequence */
	struct {
	    U32 xbm_previous;	/* how many characters in string before rare? */
	    U8	xbm_flags;
	    U8	xbm_rare;	/* rarest character in string */
	}	xbm_s;		/* fields from PVBM */
    }		xnv_u;
    STRLEN	xpv_cur;	/* length of svu_pv as a C string */
    STRLEN	xpv_len;	/* allocated size */
    union {
	IV	xivu_iv;	/* integer value or pv offset */
	UV	xivu_uv;
	void *	xivu_p1;
	I32	xivu_i32;
	HEK *	xivu_namehek;	/* GvNAME */
    }		xiv_u;
    union {
	MAGIC*	xmg_magic;	/* linked list of magicalness */
	HV*	xmg_ourstash;	/* Stash for our (when SvPAD_OUR is true) */
    } xmg_u;
    HV*		xmg_stash;	/* class package */
d483 2
a484 28
    union {
	NV	xnv_nv;
	HV *	xgv_stash;	/* The stash of this GV */
	struct {
	    U32	xlow;
	    U32	xhigh;
	}	xpad_cop_seq;	/* used by pad.c for cop_sequence */
	struct {
	    U32 xbm_previous;	/* how many characters in string before rare? */
	    U8	xbm_flags;
	    U8	xbm_rare;	/* rarest character in string */
	}	xbm_s;		/* fields from PVBM */
    }		xnv_u;
    STRLEN	xpv_cur;	/* xgv_flags */
    STRLEN	xpv_len;	/* 0 */
    union {
	IV	xivu_iv;
	UV	xivu_uv;
	void *	xivu_p1;
	I32	xivu_i32;	/* is this constant pattern being useful? */
	HEK *	xivu_namehek;	/* GvNAME */
    }		xiv_u;
    union {
	MAGIC*	xmg_magic;	/* linked list of magicalness */
	HV*	xmg_ourstash;	/* Stash for our (when SvPAD_OUR is true) */
    } xmg_u;
    HV*		xmg_stash;	/* class package */

d491 19
d511 3
a513 46
    union {
	NV	xnv_nv;		/* numeric value, if any */
	HV *	xgv_stash;
	struct {
	    U32	xlow;
	    U32	xhigh;
	}	xpad_cop_seq;	/* used by pad.c for cop_sequence */
	struct {
	    U32 xbm_previous;	/* how many characters in string before rare? */
	    U8	xbm_flags;
	    U8	xbm_rare;	/* rarest character in string */
	}	xbm_s;		/* fields from PVBM */
    }		xnv_u;
    STRLEN	xpv_cur;	/* length of svu_pv as a C string */
    STRLEN	xpv_len;	/* allocated size */
    union {
	IV	xivu_iv;	/* PVFMs use the pv offset */
	UV	xivu_uv;
	void *	xivu_p1;
	I32	xivu_i32;
	HEK *	xivu_namehek;
    }		xiv_u;
    union {
	MAGIC*	xmg_magic;	/* linked list of magicalness */
	HV*	xmg_ourstash;	/* Stash for our (when SvPAD_OUR is true) */
    } xmg_u;
    HV*		xmg_stash;	/* class package */

    HV *	xcv_stash;
    union {
	OP *	xcv_start;
	ANY	xcv_xsubany;
    }		xcv_start_u;
    union {
	OP *	xcv_root;
	void	(*xcv_xsub) (pTHX_ CV*);
    }		xcv_root_u;
    GV *	xcv_gv;
    char *	xcv_file;
    AV *	xcv_padlist;
    CV *	xcv_outside;
    U32		xcv_outside_seq; /* the COP sequence (at the point of our
				  * compilation) in the lexically enclosing
				  * sub */
    cv_flags_t	xcv_flags;
    IV		xfm_lines;
d516 29
a544 35
typedef struct {
    STRLEN	xpv_cur;	/* length of svu_pv as a C string */
    STRLEN	xpv_len;	/* allocated size */
    union {
	IV	xivu_iv;	/* PVFMs use the pv offset */
	UV	xivu_uv;
	void *	xivu_p1;
	I32	xivu_i32;
	HEK *	xivu_namehek;
    }		xiv_u;
    union {
	MAGIC*	xmg_magic;	/* linked list of magicalness */
	HV*	xmg_ourstash;	/* Stash for our (when SvPAD_OUR is true) */
    } xmg_u;
    HV*		xmg_stash;	/* class package */

    HV *	xcv_stash;
    union {
	OP *	xcv_start;
	ANY	xcv_xsubany;
    }		xcv_start_u;
    union {
	OP *	xcv_root;
	void	(*xcv_xsub) (pTHX_ CV*);
    }		xcv_root_u;
    GV *	xcv_gv;
    char *	xcv_file;
    AV *	xcv_padlist;
    CV *	xcv_outside;
    U32		xcv_outside_seq; /* the COP sequence (at the point of our
				  * compilation) in the lexically enclosing
				  * sub */
    cv_flags_t	xcv_flags;
    IV		xfm_lines;
} xpvfm_allocated;
d547 3
a549 55
    union {
	NV	xnv_nv;		/* numeric value, if any */
	HV *	xgv_stash;
	struct {
	    U32	xlow;
	    U32	xhigh;
	}	xpad_cop_seq;	/* used by pad.c for cop_sequence */
	struct {
	    U32 xbm_previous;	/* how many characters in string before rare? */
	    U8	xbm_flags;
	    U8	xbm_rare;	/* rarest character in string */
	}	xbm_s;		/* fields from PVBM */
    }		xnv_u;
    STRLEN	xpv_cur;	/* length of svu_pv as a C string */
    STRLEN	xpv_len;	/* allocated size */
    union {
	IV	xivu_iv;	/* integer value or pv offset */
	UV	xivu_uv;
	void *	xivu_p1;
	I32	xivu_i32;
	HEK *	xivu_namehek;
    }		xiv_u;
    union {
	MAGIC*	xmg_magic;	/* linked list of magicalness */
	HV*	xmg_ourstash;	/* Stash for our (when SvPAD_OUR is true) */
    } xmg_u;
    HV*		xmg_stash;	/* class package */

    PerlIO *	xio_ifp;	/* ifp and ofp are normally the same */
    PerlIO *	xio_ofp;	/* but sockets need separate streams */
    /* Cray addresses everything by word boundaries (64 bits) and
     * code and data pointers cannot be mixed (which is exactly what
     * Perl_filter_add() tries to do with the dirp), hence the following
     * union trick (as suggested by Gurusamy Sarathy).
     * For further information see Geir Johansen's problem report titled
       [ID 20000612.002] Perl problem on Cray system
     * The any pointer (known as IoANY()) will also be a good place
     * to hang any IO disciplines to.
     */
    union {
	DIR *	xiou_dirp;	/* for opendir, readdir, etc */
	void *	xiou_any;	/* for alignment */
    } xio_dirpu;
    IV		xio_lines;	/* $. */
    IV		xio_page;	/* $% */
    IV		xio_page_len;	/* $= */
    IV		xio_lines_left;	/* $- */
    char *	xio_top_name;	/* $^ */
    GV *	xio_top_gv;	/* $^ */
    char *	xio_fmt_name;	/* $~ */
    GV *	xio_fmt_gv;	/* $~ */
    char *	xio_bottom_name;/* $^B */
    GV *	xio_bottom_gv;	/* $^B */
    char	xio_type;
    U8		xio_flags;
d551 1
d647 6
a652 4
Returns a U32 indicating whether the SvIVX is a valid offset value for
the SvPVX.  This hack is used internally to speed up removal of characters
from the beginning of a SvPV.  When SvOOK is true, then the start of the
allocated string buffer is really (SvPVX - SvIVX).
d757 1
a757 1
#define SvIOKp_on(sv)		(assert_not_glob(sv) SvRELEASE_IVX(sv), \
d766 1
a766 1
#define SvIOK_on(sv)		(assert_not_glob(sv) SvRELEASE_IVX(sv), \
d894 1
a894 1
#define Gv_AMG(stash)           (PL_amagic_generation && Gv_AMupdate(stash))
a975 8
#ifdef USE_ITHREADS
/* The following uses the FAKE flag to show that a regex pointer is infact
   its own offset in the regexpad for ithreads */
#define SvREPADTMP(sv)		(SvFLAGS(sv) & SVf_FAKE)
#define SvREPADTMP_on(sv)	(SvFLAGS(sv) |= SVf_FAKE)
#define SvREPADTMP_off(sv)	(SvFLAGS(sv) &= ~SVf_FAKE)
#endif

d1073 2
d1084 2
d1096 1
d1102 1
a1102 1
	    assert(SvTYPE(_svrv) >= SVt_RV);				\
d1112 1
a1112 1
	    assert(SvTYPE(_svrv) >= SVt_RV);				\
d1182 1
d1199 1
a1199 1
        STMT_START { assert(SvTYPE(sv) >=  SVt_RV); \
d1246 3
a1248 1
			     SvPV_set(sv, SvPVX_mutable(sv) - SvIVX(sv)); \
d1260 3
a1262 3
		    if (SvTYPE(sv) < SVt_RV)				\
			sv_upgrade(sv, SVt_RV);				\
		    else if (SvPVX_const(sv)) {				\
d1309 1
a1309 1
#define FmLINES(sv)	((XPVFM*)  SvANY(sv))->xfm_lines
d1320 1
a1320 1
#define IoLINES(sv)	((XPVIO*)  SvANY(sv))->xio_lines
d1695 6
d1732 1
a1732 1
    ((SvIsCOW(sv) ? sv_force_normal_flags(sv, 0) : (void) 0), SvOOK_off(sv))
d1734 1
d1736 6
a1741 1
#  define SvRELEASE_IVX(sv)   SvOOK_off(sv)
d1760 1
d1948 57
@


1.12
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d3 2
a4 2
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, by Larry Wall and others
d116 5
a120 4
    unsigned	sv_debug_optype:9;	/* the type of OP that allocated us */
    unsigned	sv_debug_inpad:1;	/* was allocated in a pad for an OP */
    unsigned	sv_debug_cloned:1;	/* was cloned for an ithread */
    unsigned	sv_debug_line:16;	/* the line where we were allocated */
d219 1
a219 1
	SV * const _sv = (SV*)(sv);	\
d228 1
a228 1
	(SV *)(sv);				\
d232 1
a232 1
	SV * const _sv = (SV*)(sv);	\
d238 1
a238 1
	SV * const _sv = (SV*)(sv);	\
d244 1
a244 1
	((PL_Sv=(SV*)(sv)) ? (++(SvREFCNT(PL_Sv)),PL_Sv) : NULL)
d246 1
a246 1
	((sv) ? (SvREFCNT(sv)++,(SV*)(sv)) : NULL)
d248 1
a248 1
	(PL_Sv=(SV*)(sv),++(SvREFCNT(PL_Sv)),PL_Sv)
d250 1
a250 1
	(void)((PL_Sv=(SV*)(sv)) ? ++(SvREFCNT(PL_Sv)) : 0)
d255 3
a257 3
#define SvREFCNT_inc_simple_NN(sv)	(++(SvREFCNT(sv)),(SV*)(sv))
#define SvREFCNT_inc_void_NN(sv)	(void)(++SvREFCNT((SV*)(sv)))
#define SvREFCNT_inc_simple_void_NN(sv)	(void)(++SvREFCNT((SV*)(sv)))
d262 1
a262 1
	SV * const _sv = (SV*)(sv);	\
d273 1
a273 1
#define SvREFCNT_dec(sv)	sv_free((SV*)(sv))
d334 3
a336 1
				       SV's in final arena cleanup */
d774 1
a774 1
double.  Checks the B<private> setting.  Use C<SvNIOK>.
d780 2
a781 2
Returns a U32 value indicating whether the value is an SV. It also tells
whether the value is defined or not.
d785 1
a785 1
the B<private> setting.  Use C<SvIOK>.
d789 1
a789 1
B<private> setting.  Use C<SvNOK>.
d793 1
a793 1
Checks the B<private> setting.  Use C<SvPOK>.
d1081 1
a1081 1
=for apidoc Am|char*|SvGAMAGIC|SV* sv
d1144 4
a1147 4
#  define SvVALID(sv)		({ SV *const thwacke = (SV *) (sv);	\
				   if (SvFLAGS(thwacke) & SVpbm_VALID)	\
				       assert(!isGV_with_GP(thwacke));	\
				   (SvFLAGS(thwacke) & SVpbm_VALID);	\
d1149 3
a1151 3
#  define SvVALID_on(sv)	({ SV *const thwacke = (SV *) (sv);	\
				   assert(!isGV_with_GP(thwacke));	\
				   (SvFLAGS(thwacke) |= SVpbm_VALID);	\
d1153 3
a1155 3
#  define SvVALID_off(sv)	({ SV *const thwacke = (SV *) (sv);	\
				   assert(!isGV_with_GP(thwacke));	\
				   (SvFLAGS(thwacke) &= ~SVpbm_VALID);	\
d1158 3
a1160 3
#  define SvTAIL(sv)	({ SV *const _svi = (SV *) (sv);		\
			    assert(SvTYPE(_svi) != SVt_PVAV);		\
			    assert(SvTYPE(_svi) != SVt_PVHV);		\
d1195 3
a1197 3
	    SV *const whap = (SV *) (sv);				\
	    assert(SvTYPE(whap) == SVt_PVMG);				\
	    (SvFLAGS(whap) |= SVpad_NAME|SVpad_TYPED);			\
d1200 3
a1202 3
	    SV *const whap = (SV *) (sv);				\
	    assert(SvTYPE(whap) == SVt_PVMG);				\
	    (SvFLAGS(whap) |= SVpad_NAME|SVpad_OUR);			\
d1205 3
a1207 3
	    SV *const whap = (SV *) (sv);				\
	    assert(SvTYPE(whap) == SVt_PVNV || SvTYPE(whap) == SVt_PVMG); \
	    (SvFLAGS(whap) |= SVpad_NAME|SVpad_STATE);			\
d1235 1
d1260 6
a1265 6
	(*({ SV *const _svi = (SV *) (sv);				\
	    assert(SvTYPE(_svi) >= SVt_PV);				\
	    assert(SvTYPE(_svi) != SVt_PVAV);				\
	    assert(SvTYPE(_svi) != SVt_PVHV);				\
	    assert(!isGV_with_GP(_svi));				\
	    &((_svi)->sv_u.svu_pv);					\
d1268 6
a1273 6
	(*({ SV *const _svi = (SV *) (sv);				\
	    assert(SvTYPE(_svi) >= SVt_PV);				\
	    assert(SvTYPE(_svi) != SVt_PVAV);				\
	    assert(SvTYPE(_svi) != SVt_PVHV);				\
	    assert(!isGV_with_GP(_svi));				\
	    &(((XPV*) SvANY(_svi))->xpv_cur);				\
d1276 7
a1282 7
	(*({ SV *const _svi = (SV *) (sv);				\
	    assert(SvTYPE(_svi) == SVt_IV || SvTYPE(_svi) >= SVt_PVIV);	\
	    assert(SvTYPE(_svi) != SVt_PVAV);				\
	    assert(SvTYPE(_svi) != SVt_PVHV);				\
	    assert(SvTYPE(_svi) != SVt_PVCV);				\
	    assert(!isGV_with_GP(_svi));				\
	    &(((XPVIV*) SvANY(_svi))->xiv_iv);				\
d1285 7
a1291 7
	(*({ SV *const _svi = (SV *) (sv);				\
	    assert(SvTYPE(_svi) == SVt_IV || SvTYPE(_svi) >= SVt_PVIV);	\
	    assert(SvTYPE(_svi) != SVt_PVAV);				\
	    assert(SvTYPE(_svi) != SVt_PVHV);				\
	    assert(SvTYPE(_svi) != SVt_PVCV);				\
	    assert(!isGV_with_GP(_svi));				\
	    &(((XPVUV*) SvANY(_svi))->xuv_uv);				\
d1294 8
a1301 8
	(*({ SV *const _svi = (SV *) (sv);				\
	    assert(SvTYPE(_svi) == SVt_NV || SvTYPE(_svi) >= SVt_PVNV);	\
	    assert(SvTYPE(_svi) != SVt_PVAV);				\
	    assert(SvTYPE(_svi) != SVt_PVHV);				\
	    assert(SvTYPE(_svi) != SVt_PVCV);				\
	    assert(SvTYPE(_svi) != SVt_PVFM);				\
	    assert(!isGV_with_GP(_svi));				\
	   &(((XPVNV*) SvANY(_svi))->xnv_u.xnv_nv);			\
d1304 8
a1311 8
	(*({ SV *const _svi = (SV *) (sv);				\
	    assert(SvTYPE(_svi) >= SVt_RV);				\
	    assert(SvTYPE(_svi) != SVt_PVAV);				\
	    assert(SvTYPE(_svi) != SVt_PVHV);				\
	    assert(SvTYPE(_svi) != SVt_PVCV);				\
	    assert(SvTYPE(_svi) != SVt_PVFM);				\
	    assert(!isGV_with_GP(_svi));				\
	    &((_svi)->sv_u.svu_rv);					\
d1313 10
d1324 5
a1328 5
	(*({ SV *const _svi = (SV *) (sv);				\
	    assert(SvTYPE(_svi) >= SVt_PVMG);				\
	    if(SvTYPE(_svi) == SVt_PVMG)				\
		assert(!SvPAD_OUR(_svi));				\
	    &(((XPVMG*) SvANY(_svi))->xmg_u.xmg_magic);			\
d1331 3
a1333 3
	(*({ SV *const _svi = (SV *) (sv);				\
	    assert(SvTYPE(_svi) >= SVt_PVMG);				\
	    &(((XPVMG*) SvANY(_svi))->xmg_stash);			\
d1342 1
d1428 1
a1428 1
		(SvCUR(sv) = (val) - SvPVX(sv)); } STMT_END
d1446 1
d1455 14
d1477 4
a1480 4
	(*({ SV *const uggh = (SV *) (sv);				\
		assert(SvTYPE(uggh) == SVt_PVGV);			\
		assert(SvVALID(uggh));					\
	    &(((XPVGV*) SvANY(uggh))->xnv_u.xbm_s.xbm_flags);		\
d1483 4
a1486 4
	(*({ SV *const uggh = (SV *) (sv);				\
		assert(SvTYPE(uggh) == SVt_PVGV);			\
		assert(SvVALID(uggh));					\
	    &(((XPVGV*) SvANY(uggh))->xnv_u.xbm_s.xbm_rare);		\
d1489 5
a1493 5
	(*({ SV *const uggh = (SV *) (sv);				\
	    assert(SvTYPE(uggh) == SVt_PVGV);				\
	    assert(SvVALID(uggh));					\
	    assert(!SvIOK(uggh));					\
	    &(((XPVGV*) SvANY(uggh))->xiv_u.xivu_i32);			\
d1496 4
a1499 4
	(*({ SV *const uggh = (SV *) (sv);				\
		assert(SvTYPE(uggh) == SVt_PVGV);			\
		assert(SvVALID(uggh));					\
	    &(((XPVGV*) SvANY(uggh))->xnv_u.xbm_s.xbm_previous);	\
d1646 1
a1646 1
false, defined or undefined.  Does not handle 'get' magic.
d1704 4
d1778 1
a1778 1
    ((SvFLAGS(sv) & (SVf_POK|SVf_THINKFIRST)) == (SVf_POK|SVf_UTF8) \
d1813 3
a1815 3
#  define SvIVx(sv) ({SV *_sv = (SV*)(sv); SvIV(_sv); })
#  define SvUVx(sv) ({SV *_sv = (SV*)(sv); SvUV(_sv); })
#  define SvNVx(sv) ({SV *_sv = (SV*)(sv); SvNV(_sv); })
d1968 3
d1976 1
a1976 1
		nsv = sv_2mortal(newSVpvn(sstr, slen));	\
d2124 11
@


1.11
log
@merge in perl 5.8.8
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006 by Larry Wall and others
d48 14
a61 13
	SVt_IV,		/* 1 */
	SVt_NV,		/* 2 */
	SVt_RV,		/* 3 */
	SVt_PV,		/* 4 */
	SVt_PVIV,	/* 5 */
	SVt_PVNV,	/* 6 */
	SVt_PVMG,	/* 7 */
	SVt_PVBM,	/* 8 */
	SVt_PVLV,	/* 9 */
	SVt_PVAV,	/* 10 */
	SVt_PVHV,	/* 11 */
	SVt_PVCV,	/* 12 */
	SVt_PVGV,	/* 13 */
d63 2
a64 1
	SVt_PVIO	/* 15 */
d67 25
d94 18
d113 9
a121 3
    void*	sv_any;		/* pointer to something */
    U32		sv_refcnt;	/* how many references to us */
    U32		sv_flags;	/* what we are */
d125 2
a126 3
    XPVGV*	sv_any;		/* pointer to something */
    U32		sv_refcnt;	/* how many references to us */
    U32		sv_flags;	/* what we are */
d130 2
a131 3
    XPVCV*	sv_any;		/* pointer to something */
    U32		sv_refcnt;	/* how many references to us */
    U32		sv_flags;	/* what we are */
d135 2
a136 3
    XPVAV*	sv_any;		/* pointer to something */
    U32		sv_refcnt;	/* how many references to us */
    U32		sv_flags;	/* what we are */
d140 2
a141 3
    XPVHV*	sv_any;		/* pointer to something */
    U32		sv_refcnt;	/* how many references to us */
    U32		sv_flags;	/* what we are */
d145 2
a146 3
    XPVIO*	sv_any;		/* pointer to something */
    U32		sv_refcnt;	/* how many references to us */
    U32		sv_flags;	/* what we are */
d149 3
d161 37
a214 27
#ifdef USE_5005THREADS

#  if defined(VMS)
#    define ATOMIC_INC(count) __ATOMIC_INCREMENT_LONG(&count)
#    define ATOMIC_DEC_AND_TEST(res,count) res=(1==__ATOMIC_DECREMENT_LONG(&count))
 #  else
#    ifdef EMULATE_ATOMIC_REFCOUNTS
 #      define ATOMIC_INC(count) STMT_START {	\
	  MUTEX_LOCK(&PL_svref_mutex);		\
	  ++count;				\
	  MUTEX_UNLOCK(&PL_svref_mutex);		\
       } STMT_END
#      define ATOMIC_DEC_AND_TEST(res,count) STMT_START {	\
	  MUTEX_LOCK(&PL_svref_mutex);			\
	  res = (--count == 0);				\
	  MUTEX_UNLOCK(&PL_svref_mutex);			\
       } STMT_END
#    else
#      define ATOMIC_INC(count) atomic_inc(&count)
#      define ATOMIC_DEC_AND_TEST(res,count) (res = atomic_dec_and_test(&count))
#    endif /* EMULATE_ATOMIC_REFCOUNTS */
#  endif /* VMS */
#else
#  define ATOMIC_INC(count) (++count)
#  define ATOMIC_DEC_AND_TEST(res, count) (res = (--count == 0))
#endif /* USE_5005THREADS */

d220 1
a220 1
	     ATOMIC_INC(SvREFCNT(_sv));	\
d223 18
d242 8
a249 11
#  ifdef USE_5005THREADS
#    if defined(VMS) && defined(__ALPHA)
#      define SvREFCNT_inc(sv) \
          (PL_Sv=(SV*)(sv), (PL_Sv && __ATOMIC_INCREMENT_LONG(&(SvREFCNT(PL_Sv)))), (SV *)PL_Sv)
#    else
#      define SvREFCNT_inc(sv) sv_newref((SV*)sv)
#    endif
#  else
#    define SvREFCNT_inc(sv)	\
	((PL_Sv=(SV*)(sv)), (PL_Sv && ATOMIC_INC(SvREFCNT(PL_Sv))), (SV*)PL_Sv)
#  endif
d252 20
d273 1
d276 59
a334 1
#define SvTYPE(sv)	((sv)->sv_flags & SVTYPEMASK)
a335 1
#define SvUPGRADE(sv, mt) (SvTYPE(sv) >= mt || sv_upgrade(sv, mt))
a336 25
#define SVs_PADBUSY	0x00000100	/* reserved for tmp or my already */
#define SVs_PADTMP	0x00000200	/* in use as tmp */
#define SVs_PADMY	0x00000400	/* in use a "my" variable */
#define SVs_TEMP	0x00000800	/* string is stealable? */
#define SVs_OBJECT	0x00001000	/* is "blessed" */
#define SVs_GMG		0x00002000	/* has magical get method */
#define SVs_SMG		0x00004000	/* has magical set method */
#define SVs_RMG		0x00008000	/* has random magical methods */

#define SVf_IOK		0x00010000	/* has valid public integer value */
#define SVf_NOK		0x00020000	/* has valid public numeric value */
#define SVf_POK		0x00040000	/* has valid public pointer value */
#define SVf_ROK		0x00080000	/* has a valid reference pointer */

#define SVf_FAKE	0x00100000	/* glob or lexical is just a copy */
#define SVf_OOK		0x00200000	/* has valid offset value */
#define SVf_BREAK	0x00400000	/* refcnt is artificially low - used
					 * by SV's in final arena  cleanup */
#define SVf_READONLY	0x00800000	/* may not be modified */


#define SVp_IOK		0x01000000	/* has valid non-public integer value */
#define SVp_NOK		0x02000000	/* has valid non-public numeric value */
#define SVp_POK		0x04000000	/* has valid non-public pointer value */
#define SVp_SCREAM	0x08000000	/* has been studied? */
a337 1
#define SVf_UTF8        0x20000000      /* SvPV is UTF-8 encoded */
d342 1
a342 1
			 SVp_IOK|SVp_NOK|SVp_POK)
d344 1
a344 1
#define SVf_AMAGIC	0x10000000      /* has magical overloaded methods */
d346 8
a353 1
#define PRIVSHIFT 8	/* (SVp_?OK >> PRIVSHIFT) == SVf_?OK */
d357 33
a389 3
/* SVpad_OUR may be set on SVt_PV{NV,MG,GV} types */
#define SVpad_OUR	0x80000000	/* pad name is "our" instead of "my" */
#define SVpad_TYPED	0x40000000	/* Typed Lexical */
a390 1
#define SVf_IVisUV	0x80000000	/* use XPVUV instead of XPVIV */
d392 16
a407 17
#define SVpfm_COMPILED	0x80000000	/* FORMLINE is compiled */

#define SVpbm_VALID	0x80000000
#define SVpbm_TAIL	0x40000000

#define SVrepl_EVAL	0x40000000	/* Replacement part of s///e */

#define SVphv_CLONEABLE	0x08000000	/* for stashes: clone its objects */
#define SVphv_REHASH	0x10000000	/* HV is recalculating hash values */
#define SVphv_SHAREKEYS 0x20000000	/* keys live on shared string table */
#define SVphv_LAZYDEL	0x40000000	/* entry in xhv_eiter must be deleted */
#define SVphv_HASKFLAGS	0x80000000	/* keys have flag byte after hash */

#define SVprv_WEAKREF   0x80000000      /* Weak reference */

struct xrv {
    SV *	xrv_rv;		/* pointer to another SV */
d410 2
a411 3
struct xpv {
    char *	xpv_pv;		/* pointer to malloced string */
    STRLEN	xpv_cur;	/* length of xpv_pv as a C string */
d413 1
a413 1
};
d416 14
a429 2
    char *	xpv_pv;		/* pointer to malloced string */
    STRLEN	xpv_cur;	/* length of xpv_pv as a C string */
d431 7
a437 1
    IV		xiv_iv;		/* integer value or pv offset */
d440 14
d455 14
a468 2
    char *	xpv_pv;		/* pointer to malloced string */
    STRLEN	xpv_cur;	/* length of xpv_pv as a C string */
d470 6
a475 1
    UV		xuv_uv;		/* unsigned value or pv offset */
d478 2
d481 14
a494 2
    char *	xpv_pv;		/* pointer to malloced string */
    STRLEN	xpv_cur;	/* length of xpv_pv as a C string */
d496 7
a502 2
    IV		xiv_iv;		/* integer value or pv offset */
    NV    	xnv_nv;		/* numeric value, if any */
d507 14
a520 2
    char *	xpv_pv;		/* pointer to malloced string */
    STRLEN	xpv_cur;	/* length of xpv_pv as a C string */
d522 11
a532 3
    IV		xiv_iv;		/* integer value or pv offset */
    NV    	xnv_nv;		/* numeric value, if any */
    MAGIC*	xmg_magic;	/* linked list of magicalness */
d537 14
a550 2
    char *	xpv_pv;		/* pointer to malloced string */
    STRLEN	xpv_cur;	/* length of xpv_pv as a C string */
d552 11
a562 3
    IV		xiv_iv;		/* integer value or pv offset */
    NV    	xnv_nv;		/* numeric value, if any */
    MAGIC*	xmg_magic;	/* linked list of magicalness */
d572 2
d575 26
a600 22
    char *	xpv_pv;		/* pointer to malloced string */
    STRLEN	xpv_cur;	/* length of xpv_pv as a C string */
    STRLEN	xpv_len;	/* allocated size */
    IV		xiv_iv;		/* integer value or pv offset */
    NV		xnv_nv;		/* numeric value, if any */
    MAGIC*	xmg_magic;	/* linked list of magicalness */
    HV*		xmg_stash;	/* class package */

    GP*		xgv_gp;
    char*	xgv_name;
    STRLEN	xgv_namelen;
    HV*		xgv_stash;
    U8		xgv_flags;
};

struct xpvbm {
    char *	xpv_pv;		/* pointer to malloced string */
    STRLEN	xpv_cur;	/* length of xpv_pv as a C string */
    STRLEN	xpv_len;	/* allocated size */
    IV		xiv_iv;		/* integer value or pv offset */
    NV		xnv_nv;		/* numeric value, if any */
    MAGIC*	xmg_magic;	/* linked list of magicalness */
a602 3
    I32		xbm_useful;	/* is this constant pattern being useful? */
    U16		xbm_previous;	/* how many characters in string before rare? */
    U8		xbm_rare;	/* rarest character in string */
d610 14
a623 2
    char *	xpv_pv;		/* pointer to malloced string */
    STRLEN	xpv_cur;	/* length of xpv_pv as a C string */
d625 11
a635 3
    IV		xiv_iv;		/* integer value or pv offset */
    NV		xnv_nv;		/* numeric value, if any */
    MAGIC*	xmg_magic;	/* linked list of magicalness */
d639 8
a646 4
    OP *	xcv_start;
    OP *	xcv_root;
    void      (*xcv_xsub)(pTHX_ CV*);
    ANY		xcv_xsubany;
a648 1
    long	xcv_depth;	/* >= 2 indicates recursive call */
d651 3
a653 4
#ifdef USE_5005THREADS
    perl_mutex *xcv_mutexp;	/* protects xcv_owner */
    struct perl_thread *xcv_owner;	/* current owner thread */
#endif /* USE_5005THREADS */
d655 32
d690 1
d692 1
a692 1
};
d695 14
a708 2
    char *	xpv_pv;		/* pointer to malloced string */
    STRLEN	xpv_cur;	/* length of xpv_pv as a C string */
d710 11
a720 3
    IV		xiv_iv;		/* integer value or pv offset */
    NV		xnv_nv;		/* numeric value, if any */
    MAGIC*	xmg_magic;	/* linked list of magicalness */
a747 1
    short	xio_subprocess;	/* -| or |- */
d749 1
a749 1
    char	xio_flags;
d765 2
a766 2
=for apidoc Am|bool|SvNIOK|SV* sv
Returns a boolean indicating whether the SV contains a number, integer or
d769 2
a770 2
=for apidoc Am|bool|SvNIOKp|SV* sv
Returns a boolean indicating whether the SV contains a number, integer or
d776 2
a777 2
=for apidoc Am|bool|SvOK|SV* sv
Returns a boolean indicating whether the value is an SV. It also tells
d780 2
a781 2
=for apidoc Am|bool|SvIOKp|SV* sv
Returns a boolean indicating whether the SV contains an integer.  Checks
d784 2
a785 2
=for apidoc Am|bool|SvNOKp|SV* sv
Returns a boolean indicating whether the SV contains a double.  Checks the
d788 2
a789 2
=for apidoc Am|bool|SvPOKp|SV* sv
Returns a boolean indicating whether the SV contains a character string.
d792 2
a793 2
=for apidoc Am|bool|SvIOK|SV* sv
Returns a boolean indicating whether the SV contains an integer.
d810 1
a810 1
=for apidoc Am|void|SvUOK|SV* sv
d816 2
a817 2
=for apidoc Am|bool|SvNOK|SV* sv
Returns a boolean indicating whether the SV contains a double.
d828 2
a829 2
=for apidoc Am|bool|SvPOK|SV* sv
Returns a boolean indicating whether the SV contains a character
d842 5
a846 2
=for apidoc Am|bool|SvOOK|SV* sv
Returns a boolean indicating whether the SvIVX is a valid offset value for
d851 1
a851 1
=for apidoc Am|bool|SvROK|SV* sv
d914 1
a914 1
=for apidoc Am|void|SvSTASH_set|SV* sv|STASH* val
d934 1
d937 1
d940 5
a944 3
#define SvOK(sv)		(SvFLAGS(sv) & SVf_OK)
#define SvOK_off(sv)		(assert_not_ROK(sv)			\
				 SvFLAGS(sv) &=	~(SVf_OK|SVf_AMAGIC|	\
d948 1
a948 1
				 SvFLAGS(sv) &=	~(SVf_OK|SVf_AMAGIC|	\
d954 2
a955 1
#define SvIOKp_on(sv)		((void)SvOOK_off(sv), SvFLAGS(sv) |= SVp_IOK)
d957 1
a957 1
#define SvNOKp_on(sv)		(SvFLAGS(sv) |= SVp_NOK)
d959 1
a959 1
#define SvPOKp_on(sv)		(assert_not_ROK(sv)			\
d963 1
a963 1
#define SvIOK_on(sv)		((void)SvOOK_off(sv), \
d968 1
a968 1
#define SvIOK_only_UV(sv)	(SvOK_off_exc_UV(sv), \
a976 1
#define SvVOK(sv)		(SvMAGICAL(sv) && mg_find(sv,'V'))
d982 2
a983 1
#define SvNOK_on(sv)		(SvFLAGS(sv) |= (SVf_NOK|SVp_NOK))
d989 4
a992 2
=for apidoc Am|bool|SvUTF8|SV* sv
Returns a boolean indicating whether the SV contains UTF-8 encoded data.
d1008 2
d1015 1
a1015 1
#define SvPOK_on(sv)		(assert_not_ROK(sv)			\
d1018 2
a1019 2
#define SvPOK_only(sv)		(assert_not_ROK(sv)			\
				 SvFLAGS(sv) &= ~(SVf_OK|SVf_AMAGIC|	\
d1022 2
a1023 2
#define SvPOK_only_UTF8(sv)	(assert_not_ROK(sv)			\
				 SvFLAGS(sv) &= ~(SVf_OK|SVf_AMAGIC|	\
d1027 6
d1043 1
a1043 1
#define SvROK_off(sv)		(SvFLAGS(sv) &= ~(SVf_ROK|SVf_AMAGIC))
d1061 15
a1075 3
#define SvAMAGIC(sv)		(SvFLAGS(sv) & SVf_AMAGIC)
#define SvAMAGIC_on(sv)		(SvFLAGS(sv) |= SVf_AMAGIC)
#define SvAMAGIC_off(sv)	(SvFLAGS(sv) &= ~SVf_AMAGIC)
d1077 2
a1078 1
#define SvGAMAGIC(sv)           (SvFLAGS(sv) & (SVs_GMG|SVf_AMAGIC))
d1080 7
a1086 4
/*
#define Gv_AMG(stash) \
        (HV_AMAGICmb(stash) && \
         ((!HV_AMAGICbad(stash) && HV_AMAGIC(stash)) || Gv_AMupdate(stash)))
d1088 3
d1098 5
d1105 3
a1107 1
#define SvPADBUSY(sv)		(SvFLAGS(sv) & SVs_PADBUSY)
d1110 1
a1110 1
#define SvPADTMP_on(sv)		(SvFLAGS(sv) |= SVs_PADTMP|SVs_PADBUSY)
d1114 1
a1114 1
#define SvPADMY_on(sv)		(SvFLAGS(sv) |= SVs_PADMY|SVs_PADBUSY)
d1128 1
a1128 1
#define SvSCREAM(sv)		(SvFLAGS(sv) & SVp_SCREAM)
d1140 29
a1168 1
#define SvTAIL(sv)		(SvFLAGS(sv) & SVpbm_TAIL)
a1171 3
#define SvVALID(sv)		(SvFLAGS(sv) & SVpbm_VALID)
#define SvVALID_on(sv)		(SvFLAGS(sv) |= SVpbm_VALID)
#define SvVALID_off(sv)		(SvFLAGS(sv) &= ~SVpbm_VALID)
d1181 42
a1222 1
#define SvRV(sv) ((XRV*)  SvANY(sv))->xrv_rv
d1225 109
a1333 4
#define SvIVX(sv) ((XPVIV*)  SvANY(sv))->xiv_iv
#define SvUVX(sv) ((XPVUV*)  SvANY(sv))->xuv_uv
#define SvNVX(sv)  ((XPVNV*)SvANY(sv))->xnv_nv
#define SvPVX(sv)  ((XPV*)  SvANY(sv))->xpv_pv
d1336 8
a1343 5
#define SvPVX_mutable(sv)	(0 + SvPVX(sv))
#define SvPVX_const(sv)	((const char*) (0 + SvPVX(sv)))
#define SvCUR(sv) ((XPV*)  SvANY(sv))->xpv_cur
#define SvLEN(sv) ((XPV*)  SvANY(sv))->xpv_len
#define SvEND(sv)(((XPV*)  SvANY(sv))->xpv_pv + ((XPV*)SvANY(sv))->xpv_cur)
d1351 1
a1351 2
#define SvMAGIC(sv)	((XPVMG*)  SvANY(sv))->xmg_magic
#define SvSTASH(sv)	((XPVMG*)  SvANY(sv))->xmg_stash
a1358 2
/* Put the asserts back at some point and figure out where they reveal bugs
*/
d1361 4
d1368 4
a1371 2
		(((XPVNV*)SvANY(sv))->xnv_nv = (val)); } STMT_END
/* assert(SvTYPE(sv) >= SVt_PV); */
d1373 5
a1377 3
	STMT_START { \
		(((XPV*)  SvANY(sv))->xpv_pv = (val)); } STMT_END
/* assert(SvTYPE(sv) == SVt_IV || SvTYPE(sv) >= SVt_PVIV); */
d1379 5
a1383 1
	STMT_START { \
a1384 1
/* assert(SvTYPE(sv) >=  SVt_RV); */
d1386 7
a1392 3
        STMT_START { \
                (((XRV*)SvANY(sv))->xrv_rv = (val)); } STMT_END
/* assert(SvTYPE(sv) >= SVt_PVMG); */
d1394 2
a1395 3
        STMT_START {  \
                (((XPVMG*)SvANY(sv))->xmg_magic = (val)); } STMT_END
/* assert(SvTYPE(sv) >= SVt_PVMG); */
d1397 1
a1397 1
        STMT_START { \
a1398 1
/* assert(SvTYPE(sv) >= SVt_PV); */
d1400 4
a1403 1
	STMT_START { \
a1404 1
/* assert(SvTYPE(sv) >= SVt_PV); */
d1406 4
a1409 1
	STMT_START { \
d1427 14
a1440 11
#define SvPV_free(sv) \
	STMT_START { assert(SvTYPE(sv) >= SVt_PV);	\
		if (SvLEN(sv)) {			\
		    if(SvOOK(sv)) {			\
		      Safefree(SvPVX(sv) - SvIVX(sv));	\
		      SvFLAGS(sv) &= ~SVf_OOK;		\
		    } else {				\
		      Safefree(SvPVX(sv));		\
		    }					\
		}					\
	} STMT_END
d1442 36
a1477 3
#define BmRARE(sv)	((XPVBM*)  SvANY(sv))->xbm_rare
#define BmUSEFUL(sv)	((XPVBM*)  SvANY(sv))->xbm_useful
#define BmPREVIOUS(sv)	((XPVBM*)  SvANY(sv))->xbm_previous
a1499 1
#define IoSUBPROCESS(sv)((XPVIO*)  SvANY(sv))->xio_subprocess
d1537 2
d1569 6
a1574 1
A version of C<SvPV> which guarantees to evaluate sv only once.
d1582 1
a1582 1
Coerces the given SV to an integer and returns it. See  C<SvIVx> for a
d1585 3
d1590 2
a1591 1
sv only once. Use the more efficient C<SvIV> otherwise.
d1594 1
a1594 1
Coerce the given SV to a double and return it. See  C<SvNVx> for a version
d1599 2
a1600 1
sv only once. Use the more efficient C<SvNV> otherwise.
d1606 3
d1611 2
a1612 1
evaluate sv only once. Use the more efficient C<SvUV> otherwise.
d1682 3
d1796 1
a1796 1
	      (nxpv->xpv_cur && *nxpv->xpv_pv != '0')); })	\
a1808 12
#  ifdef USE_5005THREADS
#    define SvIVx(sv) sv_iv(sv)
#    define SvUVx(sv) sv_uv(sv)
#    define SvNVx(sv) sv_nv(sv)
#    define SvPVx(sv, lp) sv_pvn(sv, &lp)
#    define SvPVutf8x(sv, lp) sv_pvutf8n(sv, &lp)
#    define SvPVbytex(sv, lp) sv_pvbyten(sv, &lp)
#    define SvTRUE(sv) SvTRUEx(sv)
#    define SvTRUEx(sv) sv_true(sv)

#  else /* USE_5005THREADS */

d1812 11
a1822 11
#    define SvIVx(sv) ((PL_Sv = (sv)), SvIV(PL_Sv))
#    define SvUVx(sv) ((PL_Sv = (sv)), SvUV(PL_Sv))
#    define SvNVx(sv) ((PL_Sv = (sv)), SvNV(PL_Sv))
#    define SvPVx(sv, lp) ((PL_Sv = (sv)), SvPV(PL_Sv, lp))
#    define SvPVx_const(sv, lp) ((PL_Sv = (sv)), SvPV_const(PL_Sv, lp))
#    define SvPVx_nolen(sv) ((PL_Sv = (sv)), SvPV_nolen(PL_Sv))
#    define SvPVx_nolen_const(sv) ((PL_Sv = (sv)), SvPV_nolen_const(PL_Sv))
#    define SvPVutf8x(sv, lp) ((PL_Sv = (sv)), SvPVutf8(PL_Sv, lp))
#    define SvPVbytex(sv, lp) ((PL_Sv = (sv)), SvPVbyte(PL_Sv, lp))
#    define SvPVbytex_nolen(sv) ((PL_Sv = (sv)), SvPVbyte_nolen(PL_Sv))
#    define SvTRUE(sv) (						\
d1826 1
a1826 1
	?   ((PL_Xpv = (XPV*)SvANY(sv)) &&			\
d1828 1
a1828 1
	      (PL_Xpv->xpv_cur && *PL_Xpv->xpv_pv != '0'))	\
d1837 1
a1837 2
#    define SvTRUEx(sv) ((PL_Sv = (sv)), SvTRUE(PL_Sv))
#  endif /* USE_5005THREADS */
d1844 3
a1846 1
#define SvSHARED_HASH(sv) (0 + SvUVX(sv))
d1851 1
a1851 1
#define SV_COW_DROP_PV		4	/* Unused in Perl 5.8.x */
d1856 50
d1916 3
a1918 2
#define sv_setsv(dsv, ssv) sv_setsv_flags(dsv, ssv, SV_GMAGIC)
#define sv_setsv_nomg(dsv, ssv) sv_setsv_flags(dsv, ssv, 0)
d1921 1
d1923 2
d1926 3
d1932 2
d2011 1
d2026 1
a2026 1
		sv_setsv_flags(dst, src, SV_GMAGIC | SV_NOSTEAL);	\
d2053 18
d2088 9
a2096 1
#define SV_CHECK_THINKFIRST(sv) if (SvTHINKFIRST(sv)) sv_force_normal(sv)
@


1.10
log
@sync in-tree perl with 5.8.6
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, by Larry Wall and others
d159 1
a159 1
	SV *_sv = (SV*)(sv);		\
d237 1
d545 24
d570 5
a574 1
Set the length of the string which is in the SV.  See C<SvCUR>.
a770 1
#define SvIVXx(sv) SvIVX(sv)
a771 1
#define SvUVXx(sv) SvUVX(sv)
a772 1
#define SvNVXx(sv) SvNVX(sv)
d774 4
a777 1
#define SvPVXx(sv) SvPVX(sv)
d780 6
a786 1
#define SvEND(sv)(((XPV*)  SvANY(sv))->xpv_pv + ((XPV*)SvANY(sv))->xpv_cur)
d797 2
d801 1
a801 1
		(SvIVX(sv) = (val)); } STMT_END
d804 2
a805 1
		(SvNVX(sv) = (val)); } STMT_END
d807 19
a825 2
	STMT_START { assert(SvTYPE(sv) >= SVt_PV); \
		(SvPVX(sv) = (val)); } STMT_END
d827 3
a829 2
	STMT_START { assert(SvTYPE(sv) >= SVt_PV); \
		(SvCUR(sv) = (val)); } STMT_END
d831 2
a832 2
	STMT_START { assert(SvTYPE(sv) >= SVt_PV); \
		(SvLEN(sv) = (val)); } STMT_END
d837 24
d1056 2
d1062 12
d1076 2
d1080 1
d1085 7
d1095 5
a1099 1
     ? SvPVX(sv) : sv_2pv_nolen(sv))
d1102 2
d1118 1
a1118 1
     ? SvPVX(sv) : sv_2pvutf8_nolen(sv))
d1132 1
a1132 1
     ? SvPVX(sv) : sv_2pvbyte_nolen(sv))
d1151 3
d1156 1
d1196 3
d1201 1
d1225 2
d1233 2
d1374 2
@


1.9
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d584 1
a584 1
#define SvIOK_only(sv)		((void)SvOK_off(sv), \
d586 1
a586 1
#define SvIOK_only_UV(sv)	((void)SvOK_off_exc_UV(sv), \
d603 1
a603 1
#define SvNOK_only(sv)		((void)SvOK_off(sv), \
d643 1
a643 1
#define SvOOK_off(sv)		(SvOOK(sv) && sv_backoff(sv))
d957 9
d1113 1
d1182 1
a1182 1
Like C<SvSetMagicSV>, but does any set magic required afterwards.
d1224 1
a1224 4
		U32 tMpF = SvFLAGS(src) & SVs_TEMP;	\
		SvTEMP_off(src);			\
		sv_setsv(dst, src);			\
		SvFLAGS(src) |= tMpF;			\
@


1.8
log
@merge local changes into perl-5.8.3
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, by Larry Wall and others
d431 2
a432 1
Returns a boolean indicating whether the value is an SV.
d461 1
a461 1
=for apidoc Am|void|SvIOK_UV|SV* sv
d467 1
a467 1
=for apidoc Am|void|SvIOK_notUV|SV* sv
d607 1
a607 1
=for apidoc Am|void|SvUTF8|SV* sv
d765 1
a765 1
		(((XPVIV*)  SvANY(sv))->xiv_iv = val); } STMT_END
d768 1
a768 1
		(((XPVNV*)  SvANY(sv))->xnv_nv = val); } STMT_END
d771 1
a771 1
		(((XPV*)  SvANY(sv))->xpv_pv = val); } STMT_END
d774 1
a774 1
		(((XPV*)  SvANY(sv))->xpv_cur = val); } STMT_END
d777 1
a777 1
		(((XPV*)  SvANY(sv))->xpv_len = val); } STMT_END
d780 1
a780 1
		(((XPV*)  SvANY(sv))->xpv_cur = val - SvPVX(sv)); } STMT_END
d1010 1
a1010 1
     ? ((lp = SvCUR(sv)), SvPVX(sv)) : sv_pvbyte_force(sv, &lp))
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d159 4
a162 4
	SV *nsv = (SV*)(sv);		\
	if (nsv)			\
	     ATOMIC_INC(SvREFCNT(nsv));	\
	nsv;				\
d1028 6
a1033 6
#  define SvIVx(sv) ({SV *nsv = (SV*)(sv); SvIV(nsv); })
#  define SvUVx(sv) ({SV *nsv = (SV*)(sv); SvUV(nsv); })
#  define SvNVx(sv) ({SV *nsv = (SV*)(sv); SvNV(nsv); })
#  define SvPVx(sv, lp) ({SV *nsv = (sv); SvPV(nsv, lp); })
#  define SvPVutf8x(sv, lp) ({SV *nsv = (sv); SvPVutf8(nsv, lp); })
#  define SvPVbytex(sv, lp) ({SV *nsv = (sv); SvPVbyte(nsv, lp); })
d1050 1
a1050 1
#  define SvTRUEx(sv) ({SV *nsv = (sv); SvTRUE(nsv); })
d1094 3
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d3 2
a4 1
 *    Copyright (c) 1991-2002, Larry Wall
d156 1
a156 1
#ifdef __GNUC__
d211 1
a211 1
#define SVf_UTF8        0x20000000      /* SvPVX is UTF-8 encoded */
d220 1
a220 1
#define PRIVSHIFT 8
d237 1
d299 2
a300 1
    char	xlv_type;
d333 1
a333 1
/* This structure much match XPVCV in cv.h */
d361 3
a363 1

d493 1
a493 1
Will also turn off the UTF8 status.
d554 6
d561 2
a562 1
#define SvOK_off(sv)		(SvFLAGS(sv) &=	~(SVf_OK|SVf_AMAGIC|	\
d565 2
a566 1
#define SvOK_off_exc_UV(sv)	(SvFLAGS(sv) &=	~(SVf_OK|SVf_AMAGIC|	\
d576 2
a577 1
#define SvPOKp_on(sv)		(SvFLAGS(sv) |= SVp_POK)
d594 1
d610 1
a610 1
Turn on the UTF8 status of an SV (the data is not changed, just the flag).
d614 1
a614 1
Unsets the UTF8 status of an SV.
d618 1
a618 1
and leaves the UTF8 status as it was.
d628 2
a629 1
#define SvPOK_on(sv)		(SvFLAGS(sv) |= (SVf_POK|SVp_POK))
d631 2
a632 1
#define SvPOK_only(sv)		(SvFLAGS(sv) &= ~(SVf_OK|SVf_AMAGIC|	\
d635 2
a636 1
#define SvPOK_only_UTF8(sv)	(SvFLAGS(sv) &= ~(SVf_OK|SVf_AMAGIC|	\
d811 10
a820 8
#define IoTYPE_RDONLY	'<'
#define IoTYPE_WRONLY	'>'
#define IoTYPE_RDWR	'+'
#define IoTYPE_APPEND 	'a'
#define IoTYPE_PIPE	'|'
#define IoTYPE_STD	'-'	/* stdin or stdout */
#define IoTYPE_SOCKET	's'
#define IoTYPE_CLOSED	' '
d828 1
a828 1
Marks an SV as tainted.
d839 1
a839 1
Taints an SV if tainting is enabled
d947 8
d1026 1
a1026 1
#ifdef __GNUC__
d1098 2
d1120 11
d1228 1
d1235 1
a1235 1
#define SvIMMORTAL(sv) ((sv)==&PL_sv_undef || (sv)==&PL_sv_yes || (sv)==&PL_sv_no)
d1247 1
d1254 2
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2001, Larry Wall
d15 2
d18 1
a18 1
An enum of flags for Perl types.  These are found in the file B<sv.h> 
d66 1
a66 1
struct STRUCT_SV {
d103 2
d128 1
a128 1
#ifdef USE_THREADS
d153 1
a153 1
#endif /* USE_THREADS */
d164 1
a164 1
#  if defined(CRIPPLED_CC) || defined(USE_THREADS)
d177 1
a177 1
#define SvREFCNT_dec(sv)	sv_free((SV*)sv)
d200 2
a201 1
#define SVf_BREAK	0x00400000	/* refcnt is artificially low */
d212 1
a212 1
#define SVf_THINKFIRST	(SVf_READONLY|SVf_ROK|SVf_FAKE|SVf_UTF8)
d225 1
d238 1
d346 1
a346 1
    void      (*xcv_xsub)(pTHXo_ CV*);
d353 1
a353 1
#ifdef USE_THREADS
d356 1
a356 1
#endif /* USE_THREADS */
d359 1
a359 1
    I32		xfm_lines;
d386 4
a389 4
    long	xio_lines;	/* $. */
    long	xio_page;	/* $% */
    long	xio_page_len;	/* $= */
    long	xio_lines_left;	/* $- */
d458 3
d462 1
a462 1
Returns a boolean indicating whether the SV contains an signed integer.
d488 1
d509 2
a510 2
Returns the integer which is stored in the SV, assuming SvIOK is
true.
d513 2
a514 2
Returns the unsigned integer which is stored in the SV, assuming SvIOK is
true.
d517 2
a518 2
Returns the double which is stored in the SV, assuming SvNOK is
true.
d521 1
a521 1
Returns a pointer to the string in the SV.  The SV must contain a
d576 1
d595 2
a596 1
Tells an SV that it is a string and encoded in UTF8.  Do not use frivolously.
d602 3
a604 3
Tells an SV that it is a UTF8 string (do not use frivolously)
and disables all other OK bits.
  
d654 1
a654 1
#define SvGAMAGIC(sv)           (SvFLAGS(sv) & (SVs_GMG|SVf_AMAGIC)) 
d711 8
d738 6
d838 8
a845 2
Like <SvPV> but will force the SV into becoming a string (SvPOK).  You want
force if you are going to update the SvPVX directly.
d848 7
a854 2
Returns a pointer to the string in the SV, or a stringified form of the SV
if the SV does not contain a string.  Handles 'get' magic.
d857 3
a859 2
Returns a pointer to the string in the SV, or a stringified form of the SV
if the SV does not contain a string.  Handles 'get' magic.
d862 6
a867 1
Coerces the given SV to an integer and returns it.
d870 6
a875 1
Coerce the given SV to a double and return it.
d878 6
a883 1
Coerces the given SV to an unsigned integer and returns it.
d889 5
a893 2
=cut
*/
d895 2
a896 11
#define SvPV_force(sv, lp) sv_pvn_force(sv, &lp)
#define SvPV(sv, lp) sv_pvn(sv, &lp)
#define SvPV_nolen(sv) sv_pv(sv)

#define SvPVutf8_force(sv, lp) sv_pvutf8n_force(sv, &lp)
#define SvPVutf8(sv, lp) sv_pvutf8n(sv, &lp)
#define SvPVutf8_nolen(sv) sv_pvutf8(sv)

#define SvPVbyte_force(sv, lp) sv_pvbyte_force(sv, &lp)
#define SvPVbyte(sv, lp) sv_pvbyten(sv, &lp)
#define SvPVbyte_nolen(sv) sv_pvbyte(sv)
d898 28
a925 6
#define SvPVx(sv, lp) sv_pvn(sv, &lp)
#define SvPVx_force(sv, lp) sv_pvn_force(sv, &lp)
#define SvPVutf8x(sv, lp) sv_pvutf8n(sv, &lp)
#define SvPVutf8x_force(sv, lp) sv_pvutf8n_force(sv, &lp)
#define SvPVbytex(sv, lp) sv_pvbyten(sv, &lp)
#define SvPVbytex_force(sv, lp) sv_pvbyten_force(sv, &lp)
a926 10
#define SvIVx(sv) sv_iv(sv)
#define SvUVx(sv) sv_uv(sv)
#define SvNVx(sv) sv_nv(sv)

#define SvTRUEx(sv) sv_true(sv)

#define SvIV(sv) SvIVx(sv)
#define SvNV(sv) SvNVx(sv)
#define SvUV(sv) SvUVx(sv)
#define SvTRUE(sv) SvTRUEx(sv)
d928 2
a929 2
#ifndef CRIPPLED_CC
/* redefine some things to more efficient inlined versions */
a931 1
#undef SvIV
d933 2
d936 1
a936 2
#undef SvUV
#define SvUV(sv) (SvIOK(sv) ? SvUVX(sv) : sv_2uv(sv))
d938 1
a938 2
#undef SvNV
#define SvNV(sv) (SvNOK(sv) ? SvNVX(sv) : sv_2nv(sv))
d940 1
a940 2
#undef SvPV
#define SvPV(sv, lp) \
d942 3
a944 1
     ? ((lp = SvCUR(sv)), SvPVX(sv)) : sv_2pv(sv, &lp))
d946 1
d948 1
a948 2
#undef SvPV_force
#define SvPV_force(sv, lp) \
d950 1
a950 1
     ? ((lp = SvCUR(sv)), SvPVX(sv)) : sv_pvn_force(sv, &lp))
a951 1
#undef SvPV_nolen
d956 1
a956 9
#undef SvPVutf8
#define SvPVutf8(sv, lp) \
    ((SvFLAGS(sv) & (SVf_POK|SVf_UTF8)) == (SVf_POK|SVf_UTF8) \
     ? ((lp = SvCUR(sv)), SvPVX(sv)) : sv_2pvutf8(sv, &lp))

#undef SvPVutf8_force
#define SvPVutf8_force(sv, lp) \
    ((SvFLAGS(sv) & (SVf_POK|SVf_THINKFIRST)) == (SVf_POK|SVf_UTF8) \
     ? ((lp = SvCUR(sv)), SvPVX(sv)) : sv_pvutf8n_force(sv, &lp))
d958 1
a958 4
#undef SvPVutf8_nolen
#define SvPVutf8_nolen(sv) \
    ((SvFLAGS(sv) & (SVf_POK|SVf_UTF8)) == (SVf_POK|SVf_UTF8)\
     ? SvPVX(sv) : sv_2pvutf8_nolen(sv))
a959 1
#undef SvPVutf8
a963 1
#undef SvPVutf8_force
d968 1
a968 1
#undef SvPVutf8_nolen
d973 2
a974 1
#undef SvPVbyte
a978 1
#undef SvPVbyte_force
a982 1
#undef SvPVbyte_nolen
d988 10
d999 1
a999 8
#  undef SvIVx
#  undef SvUVx
#  undef SvNVx
#  undef SvPVx
#  undef SvPVutf8x
#  undef SvPVbytex
#  undef SvTRUE
#  undef SvTRUEx
d1023 1
d1025 13
a1037 1
#ifndef USE_THREADS
d1041 7
a1047 15
#  undef SvIVx
#  undef SvUVx
#  undef SvNVx
#  undef SvPVx
#  undef SvPVutf8x
#  undef SvPVbytex
#  undef SvTRUE
#  undef SvTRUEx
#  define SvIVx(sv) ((PL_Sv = (sv)), SvIV(PL_Sv))
#  define SvUVx(sv) ((PL_Sv = (sv)), SvUV(PL_Sv))
#  define SvNVx(sv) ((PL_Sv = (sv)), SvNV(PL_Sv))
#  define SvPVx(sv, lp) ((PL_Sv = (sv)), SvPV(PL_Sv, lp))
#  define SvPVutf8x(sv, lp) ((PL_Sv = (sv)), SvPVutf8(PL_Sv, lp))
#  define SvPVbytex(sv, lp) ((PL_Sv = (sv)), SvPVbyte(PL_Sv, lp))
#  define SvTRUE(sv) (						\
d1062 28
a1089 4
#  define SvTRUEx(sv) ((PL_Sv = (sv)), SvTRUE(PL_Sv))
#endif /* !USE_THREADS */
#endif /* !__GNU__ */
#endif /* !CRIPPLED_CC */
d1105 2
d1123 21
a1143 1
=for apidoc Am|void|SvGROW|SV* sv|STRLEN len
d1146 1
a1146 1
NUL character).  Calls C<sv_grow> to perform the expansion if necessary. 
d1152 4
d1187 1
a1187 1
#ifdef DEBUGGING
d1204 1
d1206 5
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2000, Larry Wall
d64 1
a64 1
struct sv {
d126 20
a145 15
#  ifdef EMULATE_ATOMIC_REFCOUNTS
#    define ATOMIC_INC(count) STMT_START {	\
	MUTEX_LOCK(&PL_svref_mutex);		\
	++count;				\
	MUTEX_UNLOCK(&PL_svref_mutex);		\
     } STMT_END
#    define ATOMIC_DEC_AND_TEST(res,count) STMT_START {	\
	MUTEX_LOCK(&PL_svref_mutex);			\
	res = (--count == 0);				\
	MUTEX_UNLOCK(&PL_svref_mutex);			\
     } STMT_END
#  else
#    define ATOMIC_INC(count) atomic_inc(&count)
#    define ATOMIC_DEC_AND_TEST(res,count) (res = atomic_dec_and_test(&count))
#  endif /* EMULATE_ATOMIC_REFCOUNTS */
d161 6
a166 1
#    define SvREFCNT_inc(sv) sv_newref((SV*)sv)
d366 13
a378 1
    DIR *	xio_dirp;	/* for opendir, readdir, etc */
d393 2
d445 9
d517 2
a518 1
Returns the size of the string buffer in the SV.  See C<SvCUR>.
d578 17
d641 2
d750 1
d765 10
a803 1
	    dTHR;			\
d1098 4
@


1.3
log
@perl5.005_03 (stock)
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1999, Larry Wall
d14 29
d100 20
a188 1
#define SVf_THINKFIRST	(SVf_READONLY|SVf_ROK)
d195 4
d202 1
a202 5
#ifdef OVERLOAD
#define SVf_AMAGIC    0x10000000      /* has magical overloaded methods */
#else
#define SVf_AMAGIC    0               /* can be or-ed without effect */
#endif /* OVERLOAD */
d208 6
a213 1
#define SVpfm_COMPILED	0x80000000
d218 2
d223 2
d254 1
a254 1
    double	xnv_nv;		/* numeric value, if any */
d263 1
a263 1
    double	xnv_nv;		/* numeric value, if any */
d273 1
a273 1
    double	xnv_nv;		/* numeric value, if any */
d288 1
a288 1
    double	xnv_nv;		/* numeric value, if any */
d304 1
a304 1
    double	xnv_nv;		/* numeric value, if any */
d313 1
a313 1
/* This structure much match XPVCV */
d322 1
a322 1
    double	xnv_nv;		/* numeric value, if any */
d329 1
a329 1
    void      (*xcv_xsub)_((CV* _CPERLproto));
d332 2
a333 2
    GV *	xcv_filegv;
    long	xcv_depth;		/* >= 2 indicates recursive call */
d350 1
a350 1
    double	xnv_nv;		/* numeric value, if any */
d372 7
a378 6
#define IOf_ARGV 1	/* this fp iterates over ARGV */
#define IOf_START 2	/* check for null ARGV and substitute '-' */
#define IOf_FLUSH 4	/* this fp wants a flush after write op */
#define IOf_DIDTOP 8	/* just did top of form */
#define IOf_UNTAINT 16  /* consider this fp (and its data) "safe" */
#define IOf_NOLINE  32	/* slurped a pseudo-line from empty file */
d382 117
d502 1
a502 1
						  SVp_IOK|SVp_NOK))
d505 5
a509 1
#define SvOK_off(sv)		(SvFLAGS(sv) &=	~(SVf_OK|SVf_AMAGIC),	\
d514 1
a514 1
#define SvIOKp_on(sv)		(SvOOK_off(sv), SvFLAGS(sv) |= SVp_IOK)
d521 1
a521 1
#define SvIOK_on(sv)		(SvOOK_off(sv), \
d523 2
a524 2
#define SvIOK_off(sv)		(SvFLAGS(sv) &= ~(SVf_IOK|SVp_IOK))
#define SvIOK_only(sv)		(SvOK_off(sv), \
d526 11
d541 1
a541 1
#define SvNOK_only(sv)		(SvOK_off(sv), \
d544 4
d551 5
a555 1
#define SvPOK_only(sv)		(SvFLAGS(sv) &= ~(SVf_OK|SVf_AMAGIC),	\
d559 1
a559 1
#define SvOOK_on(sv)		(SvIOK_off(sv), SvFLAGS(sv) |= SVf_OOK)
d586 3
a588 4
#ifdef OVERLOAD
#define SvAMAGIC(sv)         (SvFLAGS(sv) & SVf_AMAGIC)
#define SvAMAGIC_on(sv)      (SvFLAGS(sv) |= SVf_AMAGIC)
#define SvAMAGIC_off(sv)     (SvFLAGS(sv) &= ~SVf_AMAGIC)
d596 5
a600 1
#endif /* OVERLOAD */
d633 4
d711 22
d746 29
d777 17
d797 1
a797 2
#define SvPVx(sv, lp) sv_pvn(sv, &lp)
#define SvPVx_force(sv, lp) sv_pvn_force(sv, &lp)
d802 1
a802 1
#define SvUV(sv) SvIVx(sv)
d808 1
d820 3
a822 1
    (SvPOK(sv) ? ((lp = SvCUR(sv)), SvPVX(sv)) : sv_2pv(sv, &lp))
d829 51
d885 2
d893 2
d901 1
a901 2
	     (*nxpv->xpv_pv > '0' ||				\
	      nxpv->xpv_cur > 1 ||				\
d921 2
d929 2
d936 1
a936 2
	     (*PL_Xpv->xpv_pv > '0' ||				\
	      PL_Xpv->xpv_cur > 1 ||				\
d951 9
d964 26
d1021 1
d1023 3
d1033 2
a1034 9
#ifndef DOSISH
#  define SvGROW(sv,len) (SvLEN(sv) < (len) ? sv_grow(sv,len) : SvPVX(sv))
#  define Sv_Grow sv_grow
#else
    /* extra parentheses intentionally NOT placed around "len"! */
#  define SvGROW(sv,len) ((SvLEN(sv) < (unsigned long)len) \
		? sv_grow(sv,(unsigned long)len) : SvPVX(sv))
#  define Sv_Grow(sv,len) sv_grow(sv,(unsigned long)(len))
#endif /* DOSISH */
@


1.2
log
@perl 5.004_04
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1997, Larry Wall
d73 3
d77 28
a104 4
#define SvREFCNT(sv)	(sv)->sv_refcnt
#ifdef CRIPPLED_CC
#define SvREFCNT_inc(sv)	sv_newref((SV*)sv)
#define SvREFCNT_dec(sv)	sv_free((SV*)sv)
d106 8
a113 2
#define SvREFCNT_inc(sv)	((Sv = (SV*)(sv)), \
				    (Sv && ++SvREFCNT(Sv)), (SV*)Sv)
a114 1
#endif
d152 2
d200 1
d258 2
d272 1
a272 1
    void      (*xcv_xsub)_((CV*));
d279 5
a283 1
    U8		xcv_flags;
d319 2
a320 1
#define IOf_UNTAINT 16  /* consider this fp (and it's data) "safe" */
a329 2

#ifdef OVERLOAD
a331 3
#else
#define SvOK_off(sv)		(SvFLAGS(sv) &=	~SVf_OK, SvOOK_off(sv))
#endif /* OVERLOAD */
d345 1
a345 1
#define SvIOK_only(sv)		(SvOOK_off(sv), SvOK_off(sv), \
d357 1
a357 3

#ifdef OVERLOAD
#define SvPOK_only(sv)            (SvFLAGS(sv) &= ~(SVf_OK|SVf_AMAGIC),   \
a358 4
#else
#define SvPOK_only(sv)            (SvFLAGS(sv) &= ~SVf_OK, \
				    SvFLAGS(sv) |= (SVf_POK|SVp_POK))
#endif /* OVERLOAD */
a369 2

#ifdef OVERLOAD
a370 3
#else
#define SvROK_off(sv)		(SvFLAGS(sv) &= ~SVf_ROK)
#endif /* OVERLOAD */
d398 1
a398 1
#define Gv_AMG(stash)           (amagic_generation && Gv_AMupdate(stash))
d455 1
a455 1
#define SvENDx(sv) ((Sv = (sv)), SvEND(Sv))
d507 2
a508 4
#define SvTAINTED_on(sv)  STMT_START{ if(tainting){sv_taint(sv);}   }STMT_END
#define SvTAINTED_off(sv) STMT_START{ if(tainting){sv_untaint(sv);} }STMT_END

#define SvTAINT(sv)	  STMT_START{ if(tainted){SvTAINTED_on(sv);} }STMT_END
d510 8
a517 1
#ifdef CRIPPLED_CC
a518 3
IV SvIV _((SV* sv));
UV SvUV _((SV* sv));
double SvNV _((SV* sv));
d521 3
a523 6
char *sv_pvn _((SV *, STRLEN *));
I32 SvTRUE _((SV *));

#define SvIVx(sv) SvIV(sv)
#define SvUVx(sv) SvUV(sv)
#define SvNVx(sv) SvNV(sv)
d526 6
a531 1
#define SvTRUEx(sv) SvTRUE(sv)
d533 2
a534 1
#else /* !CRIPPLED_CC */
d554 45
a598 2
#undef SvTRUE
#define SvTRUE(sv) (						\
d602 4
a605 4
	?   ((Xpv = (XPV*)SvANY(sv)) &&				\
	     (*Xpv->xpv_pv > '0' ||				\
	      Xpv->xpv_cur > 1 ||				\
	      (Xpv->xpv_cur && *Xpv->xpv_pv != '0'))		\
d614 4
a617 8

#define SvIVx(sv) ((Sv = (sv)), SvIV(Sv))
#define SvUVx(sv) ((Sv = (sv)), SvUV(Sv))
#define SvNVx(sv) ((Sv = (sv)), SvNV(Sv))
#define SvPVx(sv, lp) ((Sv = (sv)), SvPV(Sv, lp))
#define SvTRUEx(sv) ((Sv = (sv)), SvTRUE(Sv))

#endif /* CRIPPLED_CC */
a619 5
#ifdef CRIPPLED_CC
SV *newRV_noinc _((SV *));
#else
#define newRV_noinc(sv)	((Sv = newRV(sv)), --SvREFCNT(SvRV(Sv)), Sv)
#endif
d621 1
a621 1
/* the following macro updates any magic values this sv is associated with */
d623 2
a624 1
#define SvSETMAGIC(x) if (SvSMAGICAL(x)) mg_set(x)
d627 1
d631 2
a632 1
	    }
d634 1
d641 2
a642 1
	    }
d656 1
a656 1
#define SvIMMORTAL(sv) ((sv)==&sv_undef || (sv)==&sv_yes || (sv)==&sv_no)
d658 1
a658 1
#define boolSV(b) ((b) ? &sv_yes : &sv_no)
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1994, Larry Wall
d129 1
a129 2
#define SVpbm_CASEFOLD	0x40000000
#define SVpbm_TAIL	0x20000000
d131 2
a132 4
#ifdef OVERLOAD
#define SVpgv_AM        0x40000000
/* #define SVpgv_badAM     0x20000000 */
#endif /* OVERLOAD */
d151 7
d221 2
d242 2
d256 2
a257 2
    FILE *	xio_ifp;	/* ifp and ofp are normally the same */
    FILE *	xio_ofp;	/* but sockets need separate streams */
d278 1
a409 4
#define SvCASEFOLD(sv)		(SvFLAGS(sv) & SVpbm_CASEFOLD)
#define SvCASEFOLD_on(sv)	(SvFLAGS(sv) |= SVpbm_CASEFOLD)
#define SvCASEFOLD_off(sv)	(SvFLAGS(sv) &= ~SVpbm_CASEFOLD)

d419 2
d480 5
a484 1
#define SvTAINT(sv) if (tainting && tainted) sv_magic(sv, Nullsv, 't', Nullch, 0)
d489 1
d497 1
d505 1
d508 4
d514 8
a521 3
#define SvPV(sv, lp) (SvPOK(sv) ? ((lp = SvCUR(sv)), SvPVX(sv)) : sv_2pv(sv, &lp))

#define SvPV_force(sv, lp) ((SvFLAGS(sv) & (SVf_POK|SVf_THINKFIRST)) == SVf_POK ? ((lp = SvCUR(sv)), SvPVX(sv)) : sv_pvn_force(sv, &lp))
d523 1
d542 1
d549 7
d560 23
a582 1
#define SvSetSV(dst,src) if (dst != src) sv_setsv(dst,src)
d585 4
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1999, Larry Wall
d73 1
d75 3
a77 18

#ifdef USE_THREADS

#  ifdef EMULATE_ATOMIC_REFCOUNTS
#    define ATOMIC_INC(count) STMT_START {	\
	MUTEX_LOCK(&PL_svref_mutex);		\
	++count;				\
	MUTEX_UNLOCK(&PL_svref_mutex);		\
     } STMT_END
#    define ATOMIC_DEC_AND_TEST(res,count) STMT_START {	\
	MUTEX_LOCK(&PL_svref_mutex);			\
	res = (--count == 0);				\
	MUTEX_UNLOCK(&PL_svref_mutex);			\
     } STMT_END
#  else
#    define ATOMIC_INC(count) atomic_inc(&count)
#    define ATOMIC_DEC_AND_TEST(res,count) (res = atomic_dec_and_test(&count))
#  endif /* EMULATE_ATOMIC_REFCOUNTS */
d79 3
a81 19
#  define ATOMIC_INC(count) (++count)
#  define ATOMIC_DEC_AND_TEST(res, count) (res = (--count == 0))
#endif /* USE_THREADS */

#ifdef __GNUC__
#  define SvREFCNT_inc(sv)		\
    ({					\
	SV *nsv = (SV*)(sv);		\
	if (nsv)			\
	     ATOMIC_INC(SvREFCNT(nsv));	\
	nsv;				\
    })
#else
#  if defined(CRIPPLED_CC) || defined(USE_THREADS)
#    define SvREFCNT_inc(sv) sv_newref((SV*)sv)
#  else
#    define SvREFCNT_inc(sv)	\
	((PL_Sv=(SV*)(sv)), (PL_Sv && ATOMIC_INC(SvREFCNT(PL_Sv))), (SV*)PL_Sv)
#  endif
a83 2
#define SvREFCNT_dec(sv)	sv_free((SV*)sv)

a119 2
#else
#define SVf_AMAGIC    0               /* can be or-ed without effect */
d129 2
a130 1
#define SVpbm_TAIL	0x40000000
d132 4
a135 2
#define SVphv_SHAREKEYS 0x20000000	/* keys live on shared string table */
#define SVphv_LAZYDEL	0x40000000	/* entry in xhv_eiter must be deleted */
a153 7
struct xpvuv {
    char *	xpv_pv;		/* pointer to malloced string */
    STRLEN	xpv_cur;	/* length of xpv_pv as a C string */
    STRLEN	xpv_len;	/* allocated size */
    UV		xuv_uv;		/* unsigned value or pv offset */
};

a161 1
/* These structure must match the beginning of struct xpvhv in hv.h. */
a216 4
/* This structure much match XPVCV */

typedef U16 cv_flags_t;

d229 1
a229 1
    void      (*xcv_xsub)_((CV* _CPERLproto));
a235 6
#ifdef USE_THREADS
    perl_mutex *xcv_mutexp;	/* protects xcv_owner */
    struct perl_thread *xcv_owner;	/* current owner thread */
#endif /* USE_THREADS */
    cv_flags_t	xcv_flags;

d248 2
a249 2
    PerlIO *	xio_ifp;	/* ifp and ofp are normally the same */
    PerlIO *	xio_ofp;	/* but sockets need separate streams */
a269 2
#define IOf_UNTAINT 16  /* consider this fp (and its data) "safe" */
#define IOf_NOLINE  32	/* slurped a pseudo-line from empty file */
d279 2
d283 3
d299 1
a299 1
#define SvIOK_only(sv)		(SvOK_off(sv), \
d311 3
a313 1
#define SvPOK_only(sv)		(SvFLAGS(sv) &= ~(SVf_OK|SVf_AMAGIC),	\
d315 4
d330 2
d333 3
d363 1
a363 1
#define Gv_AMG(stash)           (PL_amagic_generation && Gv_AMupdate(stash))
d401 4
a413 2
#define SvUVX(sv) ((XPVUV*)  SvANY(sv))->xuv_uv
#define SvUVXx(sv) SvUVX(sv)
d422 1
a422 1
#define SvENDx(sv) ((PL_Sv = (sv)), SvEND(PL_Sv))
d473 3
a475 12
#define SvTAINTED(sv)	  (SvMAGICAL(sv) && sv_tainted(sv))
#define SvTAINTED_on(sv)  STMT_START{ if(PL_tainting){sv_taint(sv);}   }STMT_END
#define SvTAINTED_off(sv) STMT_START{ if(PL_tainting){sv_untaint(sv);} }STMT_END

#define SvTAINT(sv)			\
    STMT_START {			\
	if (PL_tainting) {		\
	    dTHR;			\
	    if (PL_tainted)		\
		SvTAINTED_on(sv);	\
	}				\
    } STMT_END
d477 2
d481 5
a485 3
#define SvIVx(sv) sv_iv(sv)
#define SvUVx(sv) sv_uv(sv)
#define SvNVx(sv) sv_nv(sv)
d488 1
a488 1
#define SvTRUEx(sv) sv_true(sv)
d490 1
a490 4
#define SvIV(sv) SvIVx(sv)
#define SvNV(sv) SvNVx(sv)
#define SvUV(sv) SvIVx(sv)
#define SvTRUE(sv) SvTRUEx(sv)
d492 1
a492 2
#ifndef CRIPPLED_CC
/* redefine some things to more efficient inlined versions */
d494 1
a494 2
#undef SvIV
#define SvIV(sv) (SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv))
d496 1
a496 2
#undef SvUV
#define SvUV(sv) (SvIOK(sv) ? SvUVX(sv) : sv_2uv(sv))
d498 1
a498 2
#undef SvNV
#define SvNV(sv) (SvNOK(sv) ? SvNVX(sv) : sv_2nv(sv))
d500 1
a500 21
#undef SvPV
#define SvPV(sv, lp) \
    (SvPOK(sv) ? ((lp = SvCUR(sv)), SvPVX(sv)) : sv_2pv(sv, &lp))

#undef SvPV_force
#define SvPV_force(sv, lp) \
    ((SvFLAGS(sv) & (SVf_POK|SVf_THINKFIRST)) == SVf_POK \
     ? ((lp = SvCUR(sv)), SvPVX(sv)) : sv_pvn_force(sv, &lp))

#ifdef __GNUC__
#  undef SvIVx
#  undef SvUVx
#  undef SvNVx
#  undef SvPVx
#  undef SvTRUE
#  undef SvTRUEx
#  define SvIVx(sv) ({SV *nsv = (SV*)(sv); SvIV(nsv); })
#  define SvUVx(sv) ({SV *nsv = (SV*)(sv); SvUV(nsv); })
#  define SvNVx(sv) ({SV *nsv = (SV*)(sv); SvNV(nsv); })
#  define SvPVx(sv, lp) ({SV *nsv = (sv); SvPV(nsv, lp); })
#  define SvTRUE(sv) (						\
d504 4
a507 5
	?   (({XPV *nxpv = (XPV*)SvANY(sv);			\
	     nxpv &&						\
	     (*nxpv->xpv_pv > '0' ||				\
	      nxpv->xpv_cur > 1 ||				\
	      (nxpv->xpv_cur && *nxpv->xpv_pv != '0')); })	\
a515 71
#  define SvTRUEx(sv) ({SV *nsv = (sv); SvTRUE(nsv); })
#else /* __GNUC__ */
#ifndef USE_THREADS
/* These inlined macros use globals, which will require a thread
 * declaration in user code, so we avoid them under threads */

#  undef SvIVx
#  undef SvUVx
#  undef SvNVx
#  undef SvPVx
#  undef SvTRUE
#  undef SvTRUEx
#  define SvIVx(sv) ((PL_Sv = (sv)), SvIV(PL_Sv))
#  define SvUVx(sv) ((PL_Sv = (sv)), SvUV(PL_Sv))
#  define SvNVx(sv) ((PL_Sv = (sv)), SvNV(PL_Sv))
#  define SvPVx(sv, lp) ((PL_Sv = (sv)), SvPV(PL_Sv, lp))
#  define SvTRUE(sv) (						\
    !sv								\
    ? 0								\
    :    SvPOK(sv)						\
	?   ((PL_Xpv = (XPV*)SvANY(sv)) &&			\
	     (*PL_Xpv->xpv_pv > '0' ||				\
	      PL_Xpv->xpv_cur > 1 ||				\
	      (PL_Xpv->xpv_cur && *PL_Xpv->xpv_pv != '0'))	\
	     ? 1						\
	     : 0)						\
	:							\
	    SvIOK(sv)						\
	    ? SvIVX(sv) != 0					\
	    :   SvNOK(sv)					\
		? SvNVX(sv) != 0.0				\
		: sv_2bool(sv) )
#  define SvTRUEx(sv) ((PL_Sv = (sv)), SvTRUE(PL_Sv))
#endif /* !USE_THREADS */
#endif /* !__GNU__ */
#endif /* !CRIPPLED_CC */

#define newRV_inc(sv)	newRV(sv)

/* the following macros update any magic values this sv is associated with */

#define SvGETMAGIC(x) STMT_START { if (SvGMAGICAL(x)) mg_get(x); } STMT_END
#define SvSETMAGIC(x) STMT_START { if (SvSMAGICAL(x)) mg_set(x); } STMT_END

#define SvSetSV_and(dst,src,finally) \
	STMT_START {					\
	    if ((dst) != (src)) {			\
		sv_setsv(dst, src);			\
		finally;				\
	    }						\
	} STMT_END
#define SvSetSV_nosteal_and(dst,src,finally) \
	STMT_START {					\
	    if ((dst) != (src)) {			\
		U32 tMpF = SvFLAGS(src) & SVs_TEMP;	\
		SvTEMP_off(src);			\
		sv_setsv(dst, src);			\
		SvFLAGS(src) |= tMpF;			\
		finally;				\
	    }						\
	} STMT_END

#define SvSetSV(dst,src) \
		SvSetSV_and(dst,src,/*nothing*/;)
#define SvSetSV_nosteal(dst,src) \
		SvSetSV_nosteal_and(dst,src,/*nothing*/;)

#define SvSetMagicSV(dst,src) \
		SvSetSV_and(dst,src,SvSETMAGIC(dst))
#define SvSetMagicSV_nosteal(dst,src) \
		SvSetSV_nosteal_and(dst,src,SvSETMAGIC(dst))
d517 10
a526 1
#define SvPEEK(sv) sv_peek(sv)
d528 1
a528 1
#define SvIMMORTAL(sv) ((sv)==&PL_sv_undef || (sv)==&PL_sv_yes || (sv)==&PL_sv_no)
d530 1
a530 1
#define boolSV(b) ((b) ? &PL_sv_yes : &PL_sv_no)
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2000, Larry Wall
a13 29
/*
=for apidoc AmU||svtype
An enum of flags for Perl types.  These are found in the file B<sv.h> 
in the C<svtype> enum.  Test these flags with the C<SvTYPE> macro.

=for apidoc AmU||SVt_PV
Pointer type flag for scalars.  See C<svtype>.

=for apidoc AmU||SVt_IV
Integer type flag for scalars.  See C<svtype>.

=for apidoc AmU||SVt_NV
Double type flag for scalars.  See C<svtype>.

=for apidoc AmU||SVt_PVMG
Type flag for blessed scalars.  See C<svtype>.

=for apidoc AmU||SVt_PVAV
Type flag for arrays.  See C<svtype>.

=for apidoc AmU||SVt_PVHV
Type flag for hashes.  See C<svtype>.

=for apidoc AmU||SVt_PVCV
Type flag for code refs.  See C<svtype>.

=cut
*/

a70 20
/*
=for apidoc Am|U32|SvREFCNT|SV* sv
Returns the value of the object's reference count.

=for apidoc Am|SV*|SvREFCNT_inc|SV* sv
Increments the reference count of the given SV.

=for apidoc Am|void|SvREFCNT_dec|SV* sv
Decrements the reference count of the given SV.

=for apidoc Am|svtype|SvTYPE|SV* sv
Returns the type of the SV.  See C<svtype>.

=for apidoc Am|void|SvUPGRADE|SV* sv|svtype type
Used to upgrade an SV to a more complex form.  Uses C<sv_upgrade> to
perform the upgrade if necessary.  See C<svtype>.

=cut
*/

d140 1
a146 4
#define SVf_UTF8        0x20000000      /* SvPVX is UTF-8 encoded */

#define SVf_THINKFIRST	(SVf_READONLY|SVf_ROK|SVf_FAKE|SVf_UTF8)

d150 5
a154 1
#define SVf_AMAGIC	0x10000000      /* has magical overloaded methods */
d160 1
a160 6
/* SVpad_OUR may be set on SVt_PV{NV,MG,GV} types */
#define SVpad_OUR	0x80000000	/* pad name is "our" instead of "my" */

#define SVf_IVisUV	0x80000000	/* use XPVUV instead of XPVIV */

#define SVpfm_COMPILED	0x80000000	/* FORMLINE is compiled */
a164 2
#define SVrepl_EVAL	0x40000000	/* Replacement part of s///e */

a167 2
#define SVprv_WEAKREF   0x80000000      /* Weak reference */

d197 1
a197 1
    NV    	xnv_nv;		/* numeric value, if any */
d206 1
a206 1
    NV    	xnv_nv;		/* numeric value, if any */
d216 1
a216 1
    NV    	xnv_nv;		/* numeric value, if any */
d231 1
a231 1
    NV		xnv_nv;		/* numeric value, if any */
d247 1
a247 1
    NV		xnv_nv;		/* numeric value, if any */
d256 1
a256 1
/* This structure much match XPVCV in cv.h */
d265 1
a265 1
    NV		xnv_nv;		/* numeric value, if any */
d272 1
a272 1
    void      (*xcv_xsub)(pTHXo_ CV*);
d275 2
a276 2
    char *	xcv_file;
    long	xcv_depth;	/* >= 2 indicates recursive call */
d293 1
a293 1
    NV		xnv_nv;		/* numeric value, if any */
d315 6
a320 7
#define IOf_ARGV	1	/* this fp iterates over ARGV */
#define IOf_START	2	/* check for null ARGV and substitute '-' */
#define IOf_FLUSH	4	/* this fp wants a flush after write op */
#define IOf_DIDTOP	8	/* just did top of form */
#define IOf_UNTAINT	16	/* consider this fp (and its data) "safe" */
#define IOf_NOLINE	32	/* slurped a pseudo-line from empty file */
#define IOf_FAKE_DIRP	64	/* xio_dirp is fake (source filters kludge) */
a323 117
/*
=for apidoc Am|bool|SvNIOK|SV* sv
Returns a boolean indicating whether the SV contains a number, integer or
double.

=for apidoc Am|bool|SvNIOKp|SV* sv
Returns a boolean indicating whether the SV contains a number, integer or
double.  Checks the B<private> setting.  Use C<SvNIOK>.

=for apidoc Am|void|SvNIOK_off|SV* sv
Unsets the NV/IV status of an SV.

=for apidoc Am|bool|SvOK|SV* sv
Returns a boolean indicating whether the value is an SV.

=for apidoc Am|bool|SvIOKp|SV* sv
Returns a boolean indicating whether the SV contains an integer.  Checks
the B<private> setting.  Use C<SvIOK>.

=for apidoc Am|bool|SvNOKp|SV* sv
Returns a boolean indicating whether the SV contains a double.  Checks the
B<private> setting.  Use C<SvNOK>.

=for apidoc Am|bool|SvPOKp|SV* sv
Returns a boolean indicating whether the SV contains a character string.
Checks the B<private> setting.  Use C<SvPOK>.

=for apidoc Am|bool|SvIOK|SV* sv
Returns a boolean indicating whether the SV contains an integer.

=for apidoc Am|void|SvIOK_on|SV* sv
Tells an SV that it is an integer.

=for apidoc Am|void|SvIOK_off|SV* sv
Unsets the IV status of an SV.

=for apidoc Am|void|SvIOK_only|SV* sv
Tells an SV that it is an integer and disables all other OK bits.

=for apidoc Am|bool|SvNOK|SV* sv
Returns a boolean indicating whether the SV contains a double.

=for apidoc Am|void|SvNOK_on|SV* sv
Tells an SV that it is a double.

=for apidoc Am|void|SvNOK_off|SV* sv
Unsets the NV status of an SV.

=for apidoc Am|void|SvNOK_only|SV* sv
Tells an SV that it is a double and disables all other OK bits.

=for apidoc Am|bool|SvPOK|SV* sv
Returns a boolean indicating whether the SV contains a character
string.

=for apidoc Am|void|SvPOK_on|SV* sv
Tells an SV that it is a string.

=for apidoc Am|void|SvPOK_off|SV* sv
Unsets the PV status of an SV.

=for apidoc Am|void|SvPOK_only|SV* sv
Tells an SV that it is a string and disables all other OK bits.

=for apidoc Am|bool|SvOOK|SV* sv
Returns a boolean indicating whether the SvIVX is a valid offset value for
the SvPVX.  This hack is used internally to speed up removal of characters
from the beginning of a SvPV.  When SvOOK is true, then the start of the
allocated string buffer is really (SvPVX - SvIVX).

=for apidoc Am|bool|SvROK|SV* sv
Tests if the SV is an RV.

=for apidoc Am|void|SvROK_on|SV* sv
Tells an SV that it is an RV.

=for apidoc Am|void|SvROK_off|SV* sv
Unsets the RV status of an SV.

=for apidoc Am|SV*|SvRV|SV* sv
Dereferences an RV to return the SV.

=for apidoc Am|IV|SvIVX|SV* sv
Returns the integer which is stored in the SV, assuming SvIOK is
true.

=for apidoc Am|UV|SvUVX|SV* sv
Returns the unsigned integer which is stored in the SV, assuming SvIOK is
true.

=for apidoc Am|NV|SvNVX|SV* sv
Returns the double which is stored in the SV, assuming SvNOK is
true.

=for apidoc Am|char*|SvPVX|SV* sv
Returns a pointer to the string in the SV.  The SV must contain a
string.

=for apidoc Am|STRLEN|SvCUR|SV* sv
Returns the length of the string which is in the SV.  See C<SvLEN>.

=for apidoc Am|STRLEN|SvLEN|SV* sv
Returns the size of the string buffer in the SV.  See C<SvCUR>.

=for apidoc Am|char*|SvEND|SV* sv
Returns a pointer to the last character in the string which is in the SV.
See C<SvCUR>.  Access the character as *(SvEND(sv)).

=for apidoc Am|HV*|SvSTASH|SV* sv
Returns the stash of the SV.

=for apidoc Am|void|SvCUR_set|SV* sv|STRLEN len
Set the length of the string which is in the SV.  See C<SvCUR>.

=cut
*/

d327 1
a327 1
						  SVp_IOK|SVp_NOK|SVf_IVisUV))
d330 1
a330 5
#define SvOK_off(sv)		(SvFLAGS(sv) &=	~(SVf_OK|SVf_AMAGIC|	\
						  SVf_IVisUV|SVf_UTF8),	\
							SvOOK_off(sv))
#define SvOK_off_exc_UV(sv)	(SvFLAGS(sv) &=	~(SVf_OK|SVf_AMAGIC|	\
						  SVf_UTF8),		\
d335 1
a335 1
#define SvIOKp_on(sv)		((void)SvOOK_off(sv), SvFLAGS(sv) |= SVp_IOK)
d342 1
a342 1
#define SvIOK_on(sv)		((void)SvOOK_off(sv), \
d344 2
a345 2
#define SvIOK_off(sv)		(SvFLAGS(sv) &= ~(SVf_IOK|SVp_IOK|SVf_IVisUV))
#define SvIOK_only(sv)		((void)SvOK_off(sv), \
a346 11
#define SvIOK_only_UV(sv)	((void)SvOK_off_exc_UV(sv), \
				    SvFLAGS(sv) |= (SVf_IOK|SVp_IOK))

#define SvIOK_UV(sv)		((SvFLAGS(sv) & (SVf_IOK|SVf_IVisUV))	\
				 == (SVf_IOK|SVf_IVisUV))
#define SvIOK_notUV(sv)		((SvFLAGS(sv) & (SVf_IOK|SVf_IVisUV))	\
				 == SVf_IOK)

#define SvIsUV(sv)		(SvFLAGS(sv) & SVf_IVisUV)
#define SvIsUV_on(sv)		(SvFLAGS(sv) |= SVf_IVisUV)
#define SvIsUV_off(sv)		(SvFLAGS(sv) &= ~SVf_IVisUV)
d351 1
a351 1
#define SvNOK_only(sv)		((void)SvOK_off(sv), \
a353 4
#define SvUTF8(sv)		(SvFLAGS(sv) & SVf_UTF8)
#define SvUTF8_on(sv)		(SvFLAGS(sv) |= (SVf_UTF8))
#define SvUTF8_off(sv)		(SvFLAGS(sv) &= ~(SVf_UTF8))

d357 1
a357 5
#define SvPOK_only(sv)		(SvFLAGS(sv) &= ~(SVf_OK|SVf_AMAGIC|	\
						  SVf_IVisUV|SVf_UTF8),	\
				    SvFLAGS(sv) |= (SVf_POK|SVp_POK))
#define SvPOK_only_UTF8(sv)	(SvFLAGS(sv) &= ~(SVf_OK|SVf_AMAGIC|	\
						  SVf_IVisUV),		\
d361 1
a361 1
#define SvOOK_on(sv)		((void)SvIOK_off(sv), SvFLAGS(sv) |= SVf_OOK)
d388 4
a391 3
#define SvAMAGIC(sv)		(SvFLAGS(sv) & SVf_AMAGIC)
#define SvAMAGIC_on(sv)		(SvFLAGS(sv) |= SVf_AMAGIC)
#define SvAMAGIC_off(sv)	(SvFLAGS(sv) &= ~SVf_AMAGIC)
d399 1
a399 5

#define SvWEAKREF(sv)		((SvFLAGS(sv) & (SVf_ROK|SVprv_WEAKREF)) \
				  == (SVf_ROK|SVprv_WEAKREF))
#define SvWEAKREF_on(sv)	(SvFLAGS(sv) |=  (SVf_ROK|SVprv_WEAKREF))
#define SvWEAKREF_off(sv)	(SvFLAGS(sv) &= ~(SVf_ROK|SVprv_WEAKREF))
a431 4
#define SvEVALED(sv)		(SvFLAGS(sv) & SVrepl_EVAL)
#define SvEVALED_on(sv)		(SvFLAGS(sv) |= SVrepl_EVAL)
#define SvEVALED_off(sv)	(SvFLAGS(sv) &= ~SVrepl_EVAL)

a505 22
/*
=for apidoc Am|bool|SvTAINTED|SV* sv
Checks to see if an SV is tainted. Returns TRUE if it is, FALSE if
not.

=for apidoc Am|void|SvTAINTED_on|SV* sv
Marks an SV as tainted.

=for apidoc Am|void|SvTAINTED_off|SV* sv
Untaints an SV. Be I<very> careful with this routine, as it short-circuits
some of Perl's fundamental security features. XS module authors should not
use this function unless they fully understand all the implications of
unconditionally untainting the value. Untainting should be done in the
standard perl fashion, via a carefully crafted regexp, rather than directly
untainting variables.

=for apidoc Am|void|SvTAINT|SV* sv
Taints an SV if tainting is enabled

=cut
*/

a518 29
/*
=for apidoc Am|char*|SvPV_force|SV* sv|STRLEN len
Like <SvPV> but will force the SV into becoming a string (SvPOK).  You want
force if you are going to update the SvPVX directly.

=for apidoc Am|char*|SvPV|SV* sv|STRLEN len
Returns a pointer to the string in the SV, or a stringified form of the SV
if the SV does not contain a string.  Handles 'get' magic.

=for apidoc Am|char*|SvPV_nolen|SV* sv
Returns a pointer to the string in the SV, or a stringified form of the SV
if the SV does not contain a string.  Handles 'get' magic.

=for apidoc Am|IV|SvIV|SV* sv
Coerces the given SV to an integer and returns it.

=for apidoc Am|NV|SvNV|SV* sv
Coerce the given SV to a double and return it.

=for apidoc Am|UV|SvUV|SV* sv
Coerces the given SV to an unsigned integer and returns it.

=for apidoc Am|bool|SvTRUE|SV* sv
Returns a boolean indicating whether Perl would evaluate the SV as true or
false, defined or undefined.  Does not handle 'get' magic.

=cut
*/

a520 17
#define SvPV_nolen(sv) sv_pv(sv)

#define SvPVutf8_force(sv, lp) sv_pvutf8n_force(sv, &lp)
#define SvPVutf8(sv, lp) sv_pvutf8n(sv, &lp)
#define SvPVutf8_nolen(sv) sv_pvutf8(sv)

#define SvPVbyte_force(sv, lp) sv_pvbyte_force(sv, &lp)
#define SvPVbyte(sv, lp) sv_pvbyten(sv, &lp)
#define SvPVbyte_nolen(sv) sv_pvbyte(sv)

#define SvPVx(sv, lp) sv_pvn(sv, &lp)
#define SvPVx_force(sv, lp) sv_pvn_force(sv, &lp)
#define SvPVutf8x(sv, lp) sv_pvutf8n(sv, &lp)
#define SvPVutf8x_force(sv, lp) sv_pvutf8n_force(sv, &lp)
#define SvPVbytex(sv, lp) sv_pvbyten(sv, &lp)
#define SvPVbytex_force(sv, lp) sv_pvbyten_force(sv, &lp)

d524 2
a525 1

d530 1
a530 1
#define SvUV(sv) SvUVx(sv)
a535 1
/* Let us hope that bitmaps for UV and IV are the same */
d547 1
a547 3
    ((SvFLAGS(sv) & (SVf_POK)) == SVf_POK \
     ? ((lp = SvCUR(sv)), SvPVX(sv)) : sv_2pv(sv, &lp))

a553 51
#undef SvPV_nolen
#define SvPV_nolen(sv) \
    ((SvFLAGS(sv) & (SVf_POK)) == SVf_POK \
     ? SvPVX(sv) : sv_2pv_nolen(sv))

#undef SvPVutf8
#define SvPVutf8(sv, lp) \
    ((SvFLAGS(sv) & (SVf_POK|SVf_UTF8)) == (SVf_POK|SVf_UTF8) \
     ? ((lp = SvCUR(sv)), SvPVX(sv)) : sv_2pvutf8(sv, &lp))

#undef SvPVutf8_force
#define SvPVutf8_force(sv, lp) \
    ((SvFLAGS(sv) & (SVf_POK|SVf_THINKFIRST)) == (SVf_POK|SVf_UTF8) \
     ? ((lp = SvCUR(sv)), SvPVX(sv)) : sv_pvutf8n_force(sv, &lp))

#undef SvPVutf8_nolen
#define SvPVutf8_nolen(sv) \
    ((SvFLAGS(sv) & (SVf_POK|SVf_UTF8)) == (SVf_POK|SVf_UTF8)\
     ? SvPVX(sv) : sv_2pvutf8_nolen(sv))

#undef SvPVutf8
#define SvPVutf8(sv, lp) \
    ((SvFLAGS(sv) & (SVf_POK|SVf_UTF8)) == (SVf_POK|SVf_UTF8) \
     ? ((lp = SvCUR(sv)), SvPVX(sv)) : sv_2pvutf8(sv, &lp))

#undef SvPVutf8_force
#define SvPVutf8_force(sv, lp) \
    ((SvFLAGS(sv) & (SVf_POK|SVf_THINKFIRST)) == (SVf_POK|SVf_UTF8) \
     ? ((lp = SvCUR(sv)), SvPVX(sv)) : sv_pvutf8n_force(sv, &lp))

#undef SvPVutf8_nolen
#define SvPVutf8_nolen(sv) \
    ((SvFLAGS(sv) & (SVf_POK|SVf_UTF8)) == (SVf_POK|SVf_UTF8)\
     ? SvPVX(sv) : sv_2pvutf8_nolen(sv))

#undef SvPVbyte
#define SvPVbyte(sv, lp) \
    ((SvFLAGS(sv) & (SVf_POK|SVf_UTF8)) == (SVf_POK) \
     ? ((lp = SvCUR(sv)), SvPVX(sv)) : sv_2pvbyte(sv, &lp))

#undef SvPVbyte_force
#define SvPVbyte_force(sv, lp) \
    ((SvFLAGS(sv) & (SVf_POK|SVf_UTF8|SVf_THINKFIRST)) == (SVf_POK) \
     ? ((lp = SvCUR(sv)), SvPVX(sv)) : sv_pvbyte_force(sv, &lp))

#undef SvPVbyte_nolen
#define SvPVbyte_nolen(sv) \
    ((SvFLAGS(sv) & (SVf_POK|SVf_UTF8)) == (SVf_POK)\
     ? SvPVX(sv) : sv_2pvbyte_nolen(sv))


a558 2
#  undef SvPVutf8x
#  undef SvPVbytex
a564 2
#  define SvPVutf8x(sv, lp) ({SV *nsv = (sv); SvPVutf8(nsv, lp); })
#  define SvPVbytex(sv, lp) ({SV *nsv = (sv); SvPVbyte(nsv, lp); })
d571 2
a572 1
	     (nxpv->xpv_cur > 1 ||				\
a591 2
#  undef SvPVutf8x
#  undef SvPVbytex
a597 2
#  define SvPVutf8x(sv, lp) ((PL_Sv = (sv)), SvPVutf8(PL_Sv, lp))
#  define SvPVbytex(sv, lp) ((PL_Sv = (sv)), SvPVbyte(PL_Sv, lp))
d603 2
a604 1
	     (PL_Xpv->xpv_cur > 1 ||				\
a618 9
/*
=for apidoc Am|SV*|newRV_inc|SV* sv

Creates an RV wrapper for an SV.  The reference count for the original SV is
incremented.

=cut
*/

a622 26
/*
=for apidoc Am|void|SvGETMAGIC|SV* sv
Invokes C<mg_get> on an SV if it has 'get' magic.  This macro evaluates its
argument more than once.

=for apidoc Am|void|SvSETMAGIC|SV* sv
Invokes C<mg_set> on an SV if it has 'set' magic.  This macro evaluates its
argument more than once.

=for apidoc Am|void|SvSetSV|SV* dsb|SV* ssv
Calls C<sv_setsv> if dsv is not the same as ssv.  May evaluate arguments
more than once.

=for apidoc Am|void|SvSetSV_nosteal|SV* dsv|SV* ssv
Calls a non-destructive version of C<sv_setsv> if dsv is not the same as
ssv. May evaluate arguments more than once.

=for apidoc Am|void|SvGROW|SV* sv|STRLEN len
Expands the character buffer in the SV so that it has room for the
indicated number of bytes (remember to reserve space for an extra trailing
NUL character).  Calls C<sv_grow> to perform the expansion if necessary. 
Returns a pointer to the character buffer.

=cut
*/

a653 1
#ifdef DEBUGGING
a654 3
#else
#define SvPEEK(sv) ""
#endif
d662 9
a670 2
#define SvGROW(sv,len) (SvLEN(sv) < (len) ? sv_grow(sv,len) : SvPVX(sv))
#define Sv_Grow sv_grow
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2001, Larry Wall
d64 1
a64 1
struct STRUCT_SV {
d126 15
a140 20
#  if defined(VMS)
#    define ATOMIC_INC(count) __ATOMIC_INCREMENT_LONG(&count)
#    define ATOMIC_DEC_AND_TEST(res,count) res=(1==__ATOMIC_DECREMENT_LONG(&count))
 #  else
#    ifdef EMULATE_ATOMIC_REFCOUNTS
 #      define ATOMIC_INC(count) STMT_START {	\
	  MUTEX_LOCK(&PL_svref_mutex);		\
	  ++count;				\
	  MUTEX_UNLOCK(&PL_svref_mutex);		\
       } STMT_END
#      define ATOMIC_DEC_AND_TEST(res,count) STMT_START {	\
	  MUTEX_LOCK(&PL_svref_mutex);			\
	  res = (--count == 0);				\
	  MUTEX_UNLOCK(&PL_svref_mutex);			\
       } STMT_END
#    else
#      define ATOMIC_INC(count) atomic_inc(&count)
#      define ATOMIC_DEC_AND_TEST(res,count) (res = atomic_dec_and_test(&count))
#    endif /* EMULATE_ATOMIC_REFCOUNTS */
#  endif /* VMS */
d156 1
a156 6
#    if defined(VMS) && defined(__ALPHA)
#      define SvREFCNT_inc(sv) \
          (PL_Sv=(SV*)(sv), (PL_Sv && __ATOMIC_INCREMENT_LONG(&(SvREFCNT(PL_Sv)))), (SV *)PL_Sv)
#    else
#      define SvREFCNT_inc(sv) sv_newref((SV*)sv)
#    endif
d356 1
a356 13
    /* Cray addresses everything by word boundaries (64 bits) and
     * code and data pointers cannot be mixed (which is exactly what
     * Perl_filter_add() tries to do with the dirp), hence the following
     * union trick (as suggested by Gurusamy Sarathy).
     * For further information see Geir Johansen's problem report titled
       [ID 20000612.002] Perl problem on Cray system
     * The any pointer (known as IoANY()) will also be a good place
     * to hang any IO disciplines to.
     */
    union {
	DIR *	xiou_dirp;	/* for opendir, readdir, etc */
	void *	xiou_any;	/* for alignment */
    } xio_dirpu;
a370 2
#define xio_dirp	xio_dirpu.xiou_dirp
#define xio_any		xio_dirpu.xiou_any
a420 9
=for apidoc Am|void|SvIOK_only_UV|SV* sv
Tells and SV that it is an unsigned integer and disables all other OK bits.

=for apidoc Am|void|SvIOK_UV|SV* sv
Returns a boolean indicating whether the SV contains an unsigned integer.

=for apidoc Am|void|SvIOK_notUV|SV* sv
Returns a boolean indicating whether the SV contains an signed integer.

d484 1
a484 2
Returns the size of the string buffer in the SV, not including any part
attributable to C<SvOOK>.  See C<SvCUR>.
a543 17
/*
=for apidoc Am|void|SvUTF8|SV* sv
Returns a boolean indicating whether the SV contains UTF-8 encoded data.

=for apidoc Am|void|SvUTF8_on|SV *sv
Tells an SV that it is a string and encoded in UTF8.  Do not use frivolously.

=for apidoc Am|void|SvUTF8_off|SV *sv
Unsets the UTF8 status of an SV.

=for apidoc Am|void|SvPOK_only_UTF8|SV* sv
Tells an SV that it is a UTF8 string (do not use frivolously)
and disables all other OK bits.
  
=cut
 */

a589 2
#define SvGAMAGIC(sv)           (SvFLAGS(sv) & (SVs_GMG|SVf_AMAGIC)) 

a696 1
#define IoANY(sv)	((XPVIO*)  SvANY(sv))->xio_any
a710 10
/* IoTYPE(sv) is a single character telling the type of I/O connection. */
#define IoTYPE_RDONLY	'<'
#define IoTYPE_WRONLY	'>'
#define IoTYPE_RDWR	'+'
#define IoTYPE_APPEND 	'a'
#define IoTYPE_PIPE	'|'
#define IoTYPE_STD	'-'	/* stdin or stdout */
#define IoTYPE_SOCKET	's'
#define IoTYPE_CLOSED	' '

d740 1
a1034 4

#define CLONEf_COPY_STACKS 1
#define CLONEf_KEEP_PTR_TABLE 2

@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2002, Larry Wall
a14 2
=head1 SV Flags

d16 1
a16 1
An enum of flags for Perl types.  These are found in the file B<sv.h>
d64 1
a64 1
struct STRUCT_SV {		/* struct sv { */
a100 2
=head1 SV Manipulation Functions

d124 1
a124 1
#ifdef USE_5005THREADS
d149 1
a149 1
#endif /* USE_5005THREADS */
d160 1
a160 1
#  ifdef USE_5005THREADS
d173 1
a173 1
#define SvREFCNT_dec(sv)	sv_free((SV*)(sv))
d196 1
a196 2
#define SVf_BREAK	0x00400000	/* refcnt is artificially low - used
					 * by SV's in final arena  cleanup */
d207 1
a207 1
#define SVf_THINKFIRST	(SVf_READONLY|SVf_ROK|SVf_FAKE)
a219 1
#define SVpad_TYPED	0x40000000	/* Typed Lexical */
a231 1
#define SVphv_HASKFLAGS	0x80000000	/* keys have flag byte after hash */
d339 1
a339 1
    void      (*xcv_xsub)(pTHX_ CV*);
d346 1
a346 1
#ifdef USE_5005THREADS
d349 1
a349 1
#endif /* USE_5005THREADS */
d352 1
a352 1
    IV		xfm_lines;
d379 4
a382 4
    IV		xio_lines;	/* $. */
    IV		xio_page;	/* $% */
    IV		xio_page_len;	/* $= */
    IV		xio_lines_left;	/* $- */
a450 3
=for apidoc Am|void|SvUOK|SV* sv
Returns a boolean indicating whether the SV contains an unsigned integer.

d452 1
a452 1
Returns a boolean indicating whether the SV contains a signed integer.
a477 1
Will also turn off the UTF8 status.
d498 2
a499 2
Returns the raw value in the SV's IV slot, without checks or conversions.
Only use when you are sure SvIOK is true. See also C<SvIV()>.
d502 2
a503 2
Returns the raw value in the SV's UV slot, without checks or conversions.
Only use when you are sure SvIOK is true. See also C<SvUV()>.
d506 2
a507 2
Returns the raw value in the SV's NV slot, without checks or conversions.
Only use when you are sure SvNOK is true. See also C<SvNV()>.
d510 1
a510 1
Returns a pointer to the physical string in the SV.  The SV must contain a
a564 1
#define SvUOK(sv)		SvIOK_UV(sv)
d583 1
a583 2
Turn on the UTF8 status of an SV (the data is not changed, just the flag).
Do not use frivolously.
d589 3
a591 3
Tells an SV that it is a string and disables all other OK bits,
and leaves the UTF8 status as it was.

d641 1
a641 1
#define SvGAMAGIC(sv)           (SvFLAGS(sv) & (SVs_GMG|SVf_AMAGIC))
a697 8
#ifdef USE_ITHREADS
/* The following uses the FAKE flag to show that a regex pointer is infact
   its own offset in the regexpad for ithreads */
#define SvREPADTMP(sv)		(SvFLAGS(sv) & SVf_FAKE)
#define SvREPADTMP_on(sv)	(SvFLAGS(sv) |= SVf_FAKE)
#define SvREPADTMP_off(sv)	(SvFLAGS(sv) &= ~SVf_FAKE)
#endif

a716 6
/* Ask a scalar nicely to try to become an IV, if possible.
   Not guaranteed to stay returning void */
/* Macro won't actually call sv_2iv if already IOK */
#define SvIV_please(sv) \
	STMT_START {if (!SvIOKp(sv) && (SvNOK(sv) || SvPOK(sv))) \
		(void) SvIV(sv); } STMT_END
d811 2
a812 8
Like C<SvPV> but will force the SV into containing just a string
(C<SvPOK_only>).  You want force if you are going to update the C<SvPVX>
directly.

=for apidoc Am|char*|SvPV_force_nomg|SV* sv|STRLEN len
Like C<SvPV> but will force the SV into containing just a string
(C<SvPOK_only>).  You want force if you are going to update the C<SvPVX>
directly. Doesn't process magic.
d815 2
a816 7
Returns a pointer to the string in the SV, or a stringified form of
the SV if the SV does not contain a string.  The SV may cache the
stringified version becoming C<SvPOK>.  Handles 'get' magic. See also
C<SvPVx> for a version which guarantees to evaluate sv only once.

=for apidoc Am|char*|SvPVx|SV* sv|STRLEN len
A version of C<SvPV> which guarantees to evaluate sv only once.
d819 2
a820 3
Returns a pointer to the string in the SV, or a stringified form of
the SV if the SV does not contain a string.  The SV may cache the
stringified form becoming C<SvPOK>.  Handles 'get' magic.
d823 1
a823 6
Coerces the given SV to an integer and returns it. See  C<SvIVx> for a
version which guarantees to evaluate sv only once.

=for apidoc Am|IV|SvIVx|SV* sv
Coerces the given SV to an integer and returns it. Guarantees to evaluate
sv only once. Use the more efficient C<SvIV> otherwise.
d826 1
a826 6
Coerce the given SV to a double and return it. See  C<SvNVx> for a version
which guarantees to evaluate sv only once.

=for apidoc Am|NV|SvNVx|SV* sv
Coerces the given SV to a double and returns it. Guarantees to evaluate
sv only once. Use the more efficient C<SvNV> otherwise.
d829 1
a829 6
Coerces the given SV to an unsigned integer and returns it.  See C<SvUVx>
for a version which guarantees to evaluate sv only once.

=for apidoc Am|UV|SvUVx|SV* sv
Coerces the given SV to an unsigned integer and returns it. Guarantees to
evaluate sv only once. Use the more efficient C<SvUV> otherwise.
d835 2
a836 2
=for apidoc Am|char*|SvPVutf8_force|SV* sv|STRLEN len
Like C<SvPV_force>, but converts sv to utf8 first if necessary.
d838 11
a848 2
=for apidoc Am|char*|SvPVutf8|SV* sv|STRLEN len
Like C<SvPV>, but converts sv to utf8 first if necessary.
d850 6
a855 31
=for apidoc Am|char*|SvPVutf8_nolen|SV* sv
Like C<SvPV_nolen>, but converts sv to utf8 first if necessary.

=for apidoc Am|char*|SvPVbyte_force|SV* sv|STRLEN len
Like C<SvPV_force>, but converts sv to byte representation first if necessary.

=for apidoc Am|char*|SvPVbyte|SV* sv|STRLEN len
Like C<SvPV>, but converts sv to byte representation first if necessary.

=for apidoc Am|char*|SvPVbyte_nolen|SV* sv
Like C<SvPV_nolen>, but converts sv to byte representation first if necessary.

=for apidoc Am|char*|SvPVutf8x_force|SV* sv|STRLEN len
Like C<SvPV_force>, but converts sv to utf8 first if necessary.
Guarantees to evaluate sv only once; use the more efficient C<SvPVutf8_force>
otherwise.

=for apidoc Am|char*|SvPVutf8x|SV* sv|STRLEN len
Like C<SvPV>, but converts sv to utf8 first if necessary.
Guarantees to evaluate sv only once; use the more efficient C<SvPVutf8>
otherwise.

=for apidoc Am|char*|SvPVbytex_force|SV* sv|STRLEN len
Like C<SvPV_force>, but converts sv to byte representation first if necessary.
Guarantees to evaluate sv only once; use the more efficient C<SvPVbyte_force>
otherwise.

=for apidoc Am|char*|SvPVbytex|SV* sv|STRLEN len
Like C<SvPV>, but converts sv to byte representation first if necessary.
Guarantees to evaluate sv only once; use the more efficient C<SvPVbyte>
otherwise.
d857 10
d868 2
a869 2
=cut
*/
d872 1
d874 2
d877 2
d881 2
a882 5
/* ----*/

#define SvPV(sv, lp) SvPV_flags(sv, lp, SV_GMAGIC)

#define SvPV_flags(sv, lp, flags) \
d884 1
a884 3
     ? ((lp = SvCUR(sv)), SvPVX(sv)) : sv_2pv_flags(sv, &lp, flags))

#define SvPV_force(sv, lp) SvPV_force_flags(sv, lp, SV_GMAGIC)
a885 1
#define SvPV_force_nomg(sv, lp) SvPV_force_flags(sv, lp, 0)
d887 2
a888 1
#define SvPV_force_flags(sv, lp, flags) \
d890 1
a890 1
    ? ((lp = SvCUR(sv)), SvPVX(sv)) : sv_pvn_force_flags(sv, &lp, flags))
d892 1
d897 9
a905 1
#define SvPV_nomg(sv, lp) SvPV_flags(sv, lp, 0)
d907 4
a910 1
/* ----*/
d912 1
d917 1
d922 1
a922 1

d927 1
a927 2
/* ----*/

d932 1
d937 1
a942 10
    
/* define FOOx(): idempotent versions of FOO(). If possible, use a local
 * var to evaluate the arg once; failing that, use a global if possible;
 * failing that, call a function to do the work
 */

#define SvPVx_force(sv, lp) sv_pvn_force(sv, &lp)
#define SvPVutf8x_force(sv, lp) sv_pvutf8n_force(sv, &lp)
#define SvPVbytex_force(sv, lp) sv_pvbyten_force(sv, &lp)

d944 8
a951 1

a974 1

d976 1
a976 13

#  ifdef USE_5005THREADS
#    define SvIVx(sv) sv_iv(sv)
#    define SvUVx(sv) sv_uv(sv)
#    define SvNVx(sv) sv_nv(sv)
#    define SvPVx(sv, lp) sv_pvn(sv, &lp)
#    define SvPVutf8x(sv, lp) sv_pvutf8n(sv, &lp)
#    define SvPVbytex(sv, lp) sv_pvbyten(sv, &lp)
#    define SvTRUE(sv) SvTRUEx(sv)
#    define SvTRUEx(sv) sv_true(sv)

#  else /* USE_5005THREADS */

d980 15
a994 7
#    define SvIVx(sv) ((PL_Sv = (sv)), SvIV(PL_Sv))
#    define SvUVx(sv) ((PL_Sv = (sv)), SvUV(PL_Sv))
#    define SvNVx(sv) ((PL_Sv = (sv)), SvNV(PL_Sv))
#    define SvPVx(sv, lp) ((PL_Sv = (sv)), SvPV(PL_Sv, lp))
#    define SvPVutf8x(sv, lp) ((PL_Sv = (sv)), SvPVutf8(PL_Sv, lp))
#    define SvPVbytex(sv, lp) ((PL_Sv = (sv)), SvPVbyte(PL_Sv, lp))
#    define SvTRUE(sv) (						\
d1009 4
a1012 28
#    define SvTRUEx(sv) ((PL_Sv = (sv)), SvTRUE(PL_Sv))
#  endif /* USE_5005THREADS */
#endif /* __GNU__ */


/* flag values for sv_*_flags functions */
#define SV_IMMEDIATE_UNREF	1
#define SV_GMAGIC		2

/* all these 'functions' are now just macros */

#define sv_pv(sv) SvPV_nolen(sv)
#define sv_pvutf8(sv) SvPVutf8_nolen(sv)
#define sv_pvbyte(sv) SvPVbyte_nolen(sv)

#define sv_pvn_force_nomg(sv, lp) sv_pvn_force_flags(sv, lp, 0)
#define sv_utf8_upgrade_nomg(sv) sv_utf8_upgrade_flags(sv, 0)
#define sv_catpvn_nomg(dsv, sstr, slen) sv_catpvn_flags(dsv, sstr, slen, 0)
#define sv_setsv(dsv, ssv) sv_setsv_flags(dsv, ssv, SV_GMAGIC)
#define sv_setsv_nomg(dsv, ssv) sv_setsv_flags(dsv, ssv, 0)
#define sv_catsv(dsv, ssv) sv_catsv_flags(dsv, ssv, SV_GMAGIC)
#define sv_catsv_nomg(dsv, ssv) sv_catsv_flags(dsv, ssv, 0)
#define sv_catpvn(dsv, sstr, slen) sv_catpvn_flags(dsv, sstr, slen, SV_GMAGIC)
#define sv_2pv(sv, lp) sv_2pv_flags(sv, lp, SV_GMAGIC)
#define sv_2pv_nomg(sv, lp) sv_2pv_flags(sv, lp, 0)
#define sv_pvn_force(sv, lp) sv_pvn_force_flags(sv, lp, SV_GMAGIC)
#define sv_utf8_upgrade(sv) sv_utf8_upgrade_flags(sv, SV_GMAGIC)

a1027 2
=head1 Magical Functions

d1044 1
a1044 21
=for apidoc Am|void|SvSetMagicSV|SV* dsb|SV* ssv
Like C<SvSetSV>, but does any set magic required afterwards.

=for apidoc Am|void|SvSetMagicSV_nosteal|SV* dsv|SV* ssv
Like C<SvSetMagicSV>, but does any set magic required afterwards.

=for apidoc Am|void|SvSHARE|SV* sv
Arranges for sv to be shared between threads if a suitable module
has been loaded.

=for apidoc Am|void|SvLOCK|SV* sv
Arranges for a mutual exclusion lock to be obtained on sv if a suitable module
has been loaded.

=for apidoc Am|void|SvUNLOCK|SV* sv
Releases a mutual exclusion lock on sv if a suitable module
has been loaded.

=head1 SV Manipulation Functions

=for apidoc Am|char *|SvGROW|SV* sv|STRLEN len
d1047 1
a1047 1
NUL character).  Calls C<sv_grow> to perform the expansion if necessary.
a1052 4
#define SvSHARE(sv) CALL_FPTR(PL_sharehook)(aTHX_ sv)
#define SvLOCK(sv) CALL_FPTR(PL_lockhook)(aTHX_ sv)
#define SvUNLOCK(sv) CALL_FPTR(PL_unlockhook)(aTHX_ sv)

d1084 1
a1084 1
#if !defined(SKIP_DEBUGGING)
a1100 1
#define CLONEf_CLONE_HOST 4
a1101 5
struct clone_params {
  AV* stashes;
  UV  flags;
  PerlInterpreter *proto_perl;
};
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@d3 1
a3 2
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
 *    2000, 2001, 2002, 2003, by Larry Wall and others
d155 1
a155 1
#if defined(__GNUC__) && !defined(__STRICT_ANSI__) && !defined(PERL_GCC_PEDANTIC)
d210 1
a210 1
#define SVf_UTF8        0x20000000      /* SvPV is UTF-8 encoded */
d219 1
a219 1
#define PRIVSHIFT 8	/* (SVp_?OK >> PRIVSHIFT) == SVf_?OK */
a235 1
#define SVphv_REHASH	0x10000000	/* HV is recalculating hash values */
d297 1
a297 2
    char	xlv_type;	/* k=keys .=pos x=substr v=vec /=join/re
				 * y=alem/helem/iter t=tie T=tied HE */
d330 1
a330 1
/* This structure must match XPVCV in cv.h */
d358 1
a358 3
    U32		xcv_outside_seq; /* the COP sequence (at the point of our
				  * compilation) in the lexically enclosing
				  * sub */
d488 1
a488 1
Will also turn off the UTF-8 status.
a548 6
#if defined(__GNUC__) && !defined(PERL_GCC_BRACE_GROUPS_FORBIDDEN)
#define assert_not_ROK(sv)	({assert(!SvROK(sv) || !SvRV(sv));}),
#else
#define assert_not_ROK(sv)	
#endif

d550 1
a550 2
#define SvOK_off(sv)		(assert_not_ROK(sv)			\
				 SvFLAGS(sv) &=	~(SVf_OK|SVf_AMAGIC|	\
d553 1
a553 2
#define SvOK_off_exc_UV(sv)	(assert_not_ROK(sv)			\
				 SvFLAGS(sv) &=	~(SVf_OK|SVf_AMAGIC|	\
d563 1
a563 2
#define SvPOKp_on(sv)		(assert_not_ROK(sv)			\
				 SvFLAGS(sv) |= SVp_POK)
a579 1
#define SvVOK(sv)		(SvMAGICAL(sv) && mg_find(sv,'V'))
d595 1
a595 1
Turn on the UTF-8 status of an SV (the data is not changed, just the flag).
d599 1
a599 1
Unsets the UTF-8 status of an SV.
d603 1
a603 1
and leaves the UTF-8 status as it was.
d613 1
a613 2
#define SvPOK_on(sv)		(assert_not_ROK(sv)			\
				 SvFLAGS(sv) |= (SVf_POK|SVp_POK))
d615 1
a615 2
#define SvPOK_only(sv)		(assert_not_ROK(sv)			\
				 SvFLAGS(sv) &= ~(SVf_OK|SVf_AMAGIC|	\
d618 1
a618 2
#define SvPOK_only_UTF8(sv)	(assert_not_ROK(sv)			\
				 SvFLAGS(sv) &= ~(SVf_OK|SVf_AMAGIC|	\
d793 8
a800 10
#define IoTYPE_RDONLY		'<'
#define IoTYPE_WRONLY		'>'
#define IoTYPE_RDWR		'+'
#define IoTYPE_APPEND 		'a'
#define IoTYPE_PIPE		'|'
#define IoTYPE_STD		'-'	/* stdin or stdout */
#define IoTYPE_SOCKET		's'
#define IoTYPE_CLOSED		' '
#define IoTYPE_IMPLICIT		'I'	/* stdin or stdout or stderr */
#define IoTYPE_NUMERIC		'#'	/* fdopen */
d808 1
a808 1
Marks an SV as tainted if tainting is enabled.
d819 1
a819 1
Taints an SV if tainting is enabled.
a926 8
=for apidoc Am|bool|SvIsCOW|SV* sv
Returns a boolean indicating whether the SV is Copy-On-Write. (either shared
hash key scalars, or full Copy On Write scalars if 5.9.0 is configured for
COW)

=for apidoc Am|bool|SvIsCOW_shared_hash|SV* sv
Returns a boolean indicating whether the SV is Copy-On-Write shared hash key
scalar.
d998 1
a998 1
#if defined(__GNUC__) && !defined(PERL_GCC_BRACE_GROUPS_FORBIDDEN)
a1069 2
#define SV_COW_DROP_PV		4	/* Unused in Perl 5.8.x */
#define SV_UTF8_NO_ENCODING	8
a1089 11
/* Should be named SvCatPVN_utf8_upgrade? */
#define sv_catpvn_utf8_upgrade(dsv, sstr, slen, nsv)	\
	STMT_START {					\
	    if (!(nsv))					\
		nsv = sv_2mortal(newSVpvn(sstr, slen));	\
	    else					\
		sv_setpvn(nsv, sstr, slen);		\
	    SvUTF8_off(nsv);				\
	    sv_utf8_upgrade(nsv);			\
	    sv_catsv(dsv, nsv);	\
	} STMT_END
a1186 1

d1193 1
a1193 1
#define SvIMMORTAL(sv) ((sv)==&PL_sv_undef || (sv)==&PL_sv_yes || (sv)==&PL_sv_no || (sv)==&PL_sv_placeholder)
a1204 1
#define CLONEf_JOIN_IN 8
a1210 2

#define SV_CHECK_THINKFIRST(sv) if (SvTHINKFIRST(sv)) sv_force_normal(sv)
@


1.1.1.7
log
@perl 5.8.3 from CPAN
@
text
@d159 4
a162 4
	SV *_sv = (SV*)(sv);		\
	if (_sv)			\
	     ATOMIC_INC(SvREFCNT(_sv));	\
	_sv;				\
d1028 6
a1033 6
#  define SvIVx(sv) ({SV *_sv = (SV*)(sv); SvIV(_sv); })
#  define SvUVx(sv) ({SV *_sv = (SV*)(sv); SvUV(_sv); })
#  define SvNVx(sv) ({SV *_sv = (SV*)(sv); SvNV(_sv); })
#  define SvPVx(sv, lp) ({SV *_sv = (sv); SvPV(_sv, lp); })
#  define SvPVutf8x(sv, lp) ({SV *_sv = (sv); SvPVutf8(_sv, lp); })
#  define SvPVbytex(sv, lp) ({SV *_sv = (sv); SvPVbyte(_sv, lp); })
d1050 1
a1050 1
#  define SvTRUEx(sv) ({SV *_sv = (sv); SvTRUE(_sv); })
a1093 3
#define SvIsCOW(sv)		((SvFLAGS(sv) & (SVf_FAKE | SVf_READONLY)) == \
				    (SVf_FAKE | SVf_READONLY))
#define SvIsCOW_shared_hash(sv)	(SvIsCOW(sv) && SvLEN(sv) == 0)
@


1.1.1.8
log
@Import of stock perl 5.8.5
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, by Larry Wall and others
d431 1
a431 2
Returns a boolean indicating whether the value is an SV. It also tells
whether the value is defined or not.
d460 1
a460 1
=for apidoc Am|bool|SvIOK_UV|SV* sv
d466 1
a466 1
=for apidoc Am|bool|SvIOK_notUV|SV* sv
d606 1
a606 1
=for apidoc Am|bool|SvUTF8|SV* sv
d764 1
a764 1
		(SvIVX(sv) = (val)); } STMT_END
d767 1
a767 1
		(SvNVX(sv) = (val)); } STMT_END
d770 1
a770 1
		(SvPVX(sv) = (val)); } STMT_END
d773 1
a773 1
		(SvCUR(sv) = (val)); } STMT_END
d776 1
a776 1
		(SvLEN(sv) = (val)); } STMT_END
d779 1
a779 1
		(SvCUR(sv) = (val) - SvPVX(sv)); } STMT_END
d1009 1
a1009 1
     ? ((lp = SvCUR(sv)), SvPVX(sv)) : sv_pvbyten_force(sv, &lp))
@


1.1.1.9
log
@perl 5.8.6 from CPAN
@
text
@d584 1
a584 1
#define SvIOK_only(sv)		(SvOK_off(sv), \
d586 1
a586 1
#define SvIOK_only_UV(sv)	(SvOK_off_exc_UV(sv), \
d603 1
a603 1
#define SvNOK_only(sv)		(SvOK_off(sv), \
d643 1
a643 1
#define SvOOK_off(sv)		((void)(SvOOK(sv) && sv_backoff(sv)))
a956 9
=for apidoc Am|void|sv_catpvn_nomg|SV* sv|const char* ptr|STRLEN len
Like C<sv_catpvn> but doesn't process magic.

=for apidoc Am|void|sv_setsv_nomg|SV* dsv|SV* ssv
Like C<sv_setsv> but doesn't process magic.

=for apidoc Am|void|sv_catsv_nomg|SV* dsv|SV* ssv
Like C<sv_catsv> but doesn't process magic.

a1103 1
#define SV_NOSTEAL		16
d1172 1
a1172 1
Like C<SvSetSV_nosteal>, but does any set magic required afterwards.
d1214 4
a1217 1
		sv_setsv_flags(dst, src, SV_GMAGIC | SV_NOSTEAL);	\
@


1.1.1.10
log
@perl 5.8.8 import
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006 by Larry Wall and others
d159 1
a159 1
	SV * const _sv = (SV*)(sv);	\
a236 1
#define SVphv_CLONEABLE	0x08000000	/* for stashes: clone its objects */
a543 24
=for apidoc Am|void|SvIV_set|SV* sv|IV val
Set the value of the IV pointer in sv to val.  It is possible to perform
the same function of this macro with an lvalue assignment to C<SvIVX>.
With future Perls, however, it will be more efficient to use 
C<SvIV_set> instead of the lvalue assignment to C<SvIVX>.

=for apidoc Am|void|SvNV_set|SV* sv|NV val
Set the value of the NV pointer in sv to val.  See C<SvIV_set>.

=for apidoc Am|void|SvPV_set|SV* sv|char* val
Set the value of the PV pointer in sv to val.  See C<SvIV_set>.

=for apidoc Am|void|SvUV_set|SV* sv|UV val
Set the value of the UV pointer in sv to val.  See C<SvIV_set>.

=for apidoc Am|void|SvRV_set|SV* sv|SV* val
Set the value of the RV pointer in sv to val.  See C<SvIV_set>.

=for apidoc Am|void|SvMAGIC_set|SV* sv|MAGIC* val
Set the value of the MAGIC pointer in sv to val.  See C<SvIV_set>.

=for apidoc Am|void|SvSTASH_set|SV* sv|STASH* val
Set the value of the STASH pointer in sv to val.  See C<SvIV_set>.

d545 1
a545 5
Set the current length of the string which is in the SV.  See C<SvCUR>
and C<SvIV_set>.

=for apidoc Am|void|SvLEN_set|SV* sv|STRLEN len
Set the actual length of the string which is in the SV.  See C<SvIV_set>.
d742 1
d744 1
d746 1
d748 1
a748 4
/* Given that these two are new, there can't be any existing code using them
 *  as LVALUEs  */
#define SvPVX_mutable(sv)	(0 + SvPVX(sv))
#define SvPVX_const(sv)	((const char*) (0 + SvPVX(sv)))
d751 1
a752 6

#define SvIVXx(sv) SvIVX(sv)
#define SvUVXx(sv) SvUVX(sv)
#define SvNVXx(sv) SvNVX(sv)
#define SvPVXx(sv) SvPVX(sv)
#define SvLENx(sv) SvLEN(sv)
a762 2
/* Put the asserts back at some point and figure out where they reveal bugs
*/
d765 1
a765 1
		(((XPVIV*)  SvANY(sv))->xiv_iv = (val)); } STMT_END
d768 1
a768 2
		(((XPVNV*)SvANY(sv))->xnv_nv = (val)); } STMT_END
/* assert(SvTYPE(sv) >= SVt_PV); */
d770 2
a771 19
	STMT_START { \
		(((XPV*)  SvANY(sv))->xpv_pv = (val)); } STMT_END
/* assert(SvTYPE(sv) == SVt_IV || SvTYPE(sv) >= SVt_PVIV); */
#define SvUV_set(sv, val) \
	STMT_START { \
		(((XPVUV*)SvANY(sv))->xuv_uv = (val)); } STMT_END
/* assert(SvTYPE(sv) >=  SVt_RV); */
#define SvRV_set(sv, val) \
        STMT_START { \
                (((XRV*)SvANY(sv))->xrv_rv = (val)); } STMT_END
/* assert(SvTYPE(sv) >= SVt_PVMG); */
#define SvMAGIC_set(sv, val) \
        STMT_START {  \
                (((XPVMG*)SvANY(sv))->xmg_magic = (val)); } STMT_END
/* assert(SvTYPE(sv) >= SVt_PVMG); */
#define SvSTASH_set(sv, val) \
        STMT_START { \
                (((XPVMG*)  SvANY(sv))->xmg_stash = (val)); } STMT_END
/* assert(SvTYPE(sv) >= SVt_PV); */
d773 2
a774 3
	STMT_START { \
		(((XPV*)  SvANY(sv))->xpv_cur = (val)); } STMT_END
/* assert(SvTYPE(sv) >= SVt_PV); */
d776 2
a777 2
	STMT_START { \
		(((XPV*)  SvANY(sv))->xpv_len = (val)); } STMT_END
a781 24
#define SvPV_renew(sv,n) \
	STMT_START { SvLEN_set(sv, n); \
		SvPV_set((sv), (MEM_WRAP_CHECK_(n,char)			\
				(char*)saferealloc((Malloc_t)SvPVX(sv), \
						   (MEM_SIZE)((n)))));  \
		 } STMT_END

#define SvPV_shrink_to_cur(sv) STMT_START { \
		   const STRLEN _lEnGtH = SvCUR(sv) + 1; \
		   SvPV_renew(sv, _lEnGtH); \
		 } STMT_END

#define SvPV_free(sv) \
	STMT_START { assert(SvTYPE(sv) >= SVt_PV);	\
		if (SvLEN(sv)) {			\
		    if(SvOOK(sv)) {			\
		      Safefree(SvPVX(sv) - SvIVX(sv));	\
		      SvFLAGS(sv) &= ~SVf_OOK;		\
		    } else {				\
		      Safefree(SvPVX(sv));		\
		    }					\
		}					\
	} STMT_END

a976 2
#define SvPV_const(sv, lp) SvPV_flags_const(sv, lp, SV_GMAGIC)
#define SvPV_mutable(sv, lp) SvPV_flags_mutable(sv, lp, SV_GMAGIC)
a980 12
#define SvPV_flags_const(sv, lp, flags) \
    ((SvFLAGS(sv) & (SVf_POK)) == SVf_POK \
     ? ((lp = SvCUR(sv)), SvPVX_const(sv)) : \
     (const char*) sv_2pv_flags(sv, &lp, flags|SV_CONST_RETURN))
#define SvPV_flags_const_nolen(sv, flags) \
    ((SvFLAGS(sv) & (SVf_POK)) == SVf_POK \
     ? SvPVX_const(sv) : \
     (const char*) sv_2pv_flags(sv, 0, flags|SV_CONST_RETURN))
#define SvPV_flags_mutable(sv, lp, flags) \
    ((SvFLAGS(sv) & (SVf_POK)) == SVf_POK \
     ? ((lp = SvCUR(sv)), SvPVX_mutable(sv)) : \
     sv_2pv_flags(sv, &lp, flags|SV_MUTABLE_RETURN))
a982 2
#define SvPV_force_nolen(sv) SvPV_force_flags_nolen(sv, SV_GMAGIC)
#define SvPV_force_mutable(sv, lp) SvPV_force_flags_mutable(sv, lp, SV_GMAGIC)
a984 1
#define SvPV_force_nomg_nolen(sv) SvPV_force_flags_nolen(sv, 0)
a988 7
#define SvPV_force_flags_nolen(sv, flags) \
    ((SvFLAGS(sv) & (SVf_POK|SVf_THINKFIRST)) == SVf_POK \
    ? SvPVX(sv) : sv_pvn_force_flags(sv, 0, flags))
#define SvPV_force_flags_mutable(sv, lp, flags) \
    ((SvFLAGS(sv) & (SVf_POK|SVf_THINKFIRST)) == SVf_POK \
    ? ((lp = SvCUR(sv)), SvPVX_mutable(sv)) \
     : sv_pvn_force_flags(sv, &lp, flags|SV_MUTABLE_RETURN))
d992 1
a992 5
     ? SvPVX(sv) : sv_2pv_flags(sv, 0, SV_GMAGIC))

#define SvPV_nolen_const(sv) \
    ((SvFLAGS(sv) & (SVf_POK)) == SVf_POK \
     ? SvPVX_const(sv) : sv_2pv_flags(sv, 0, SV_GMAGIC|SV_CONST_RETURN))
a994 2
#define SvPV_nomg_const(sv, lp) SvPV_flags_const(sv, lp, 0)
#define SvPV_nomg_const_nolen(sv) SvPV_flags_const_nolen(sv, 0)
d1009 1
a1009 1
     ? SvPVX(sv) : sv_2pvutf8(sv, 0))
d1023 1
a1023 1
     ? SvPVX(sv) : sv_2pvbyte(sv, 0))
a1041 3
#  define SvPVx_const(sv, lp) ({SV *_sv = (sv); SvPV_const(_sv, lp); })
#  define SvPVx_nolen(sv) ({SV *_sv = (sv); SvPV_nolen(_sv); })
#  define SvPVx_nolen_const(sv) ({SV *_sv = (sv); SvPV_nolen_const(_sv); })
a1043 1
#  define SvPVbytex_nolen(sv) ({SV *_sv = (sv); SvPVbyte_nolen(_sv); })
a1082 3
#    define SvPVx_const(sv, lp) ((PL_Sv = (sv)), SvPV_const(PL_Sv, lp))
#    define SvPVx_nolen(sv) ((PL_Sv = (sv)), SvPV_nolen(PL_Sv))
#    define SvPVx_nolen_const(sv) ((PL_Sv = (sv)), SvPV_nolen_const(PL_Sv))
a1084 1
#    define SvPVbytex_nolen(sv) ((PL_Sv = (sv)), SvPVbyte_nolen(PL_Sv))
a1107 2
#define SvSHARED_HASH(sv) (0 + SvUVX(sv))

a1113 2
#define SV_CONST_RETURN		32
#define SV_MUTABLE_RETURN	64
a1252 2
#define SvGROW_mutable(sv,len) \
    (SvLEN(sv) < (len) ? sv_grow(sv,len) : SvPVX_mutable(sv))
@


1.1.1.11
log
@import perl 5.10.0 from CPAN
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, by Larry Wall and others
d48 13
a60 14
	SVt_BIND,	/* 1 */
	SVt_IV,		/* 2 */
	SVt_NV,		/* 3 */
	SVt_RV,		/* 4 */
	SVt_PV,		/* 5 */
	SVt_PVIV,	/* 6 */
	SVt_PVNV,	/* 7 */
	SVt_PVMG,	/* 8 */
	/* PVBM was here, before BIND replaced it.  */
	SVt_PVGV,	/* 9 */
	SVt_PVLV,	/* 10 */
	SVt_PVAV,	/* 11 */
	SVt_PVHV,	/* 12 */
	SVt_PVCV,	/* 13 */
d62 1
a62 2
	SVt_PVIO,	/* 15 */
	SVt_LAST	/* keep last in enum. used to size arrays */
a64 25
#ifndef PERL_CORE
/* Although Fast Boyer Moore tables are now being stored in PVGVs, for most
   purposes eternal code wanting to consider PVBM probably needs to think of
   PVMG instead.  */
#  define SVt_PVBM	SVt_PVMG
#endif

/* There is collusion here with sv_clear - sv_clear exits early for SVt_NULL
   and SVt_IV, so never reaches the clause at the end that uses
   sv_type_details->body_size to determine whether to call safefree(). Hence
   body_size can be set no-zero to record the size of PTEs and HEs, without
   fear of bogus frees.  */
#ifdef PERL_IN_SV_C
#define PTE_SVSLOT	SVt_IV
#endif
#if defined(PERL_IN_HV_C) || defined(PERL_IN_XS_APITEST)
#define HE_SVSLOT	SVt_NULL
#endif

#define PERL_ARENA_ROOTS_SIZE	(SVt_LAST)

/* typedefs to eliminate some typing */
typedef struct he HE;
typedef struct hek HEK;

a66 18
/* start with 2 sv-head building blocks */
#define _SV_HEAD(ptrtype) \
    ptrtype	sv_any;		/* pointer to body */	\
    U32		sv_refcnt;	/* how many references to us */	\
    U32		sv_flags	/* what we are */

#define _SV_HEAD_UNION \
    union {				\
	IV      svu_iv;			\
	UV      svu_uv;			\
	SV*     svu_rv;		/* pointer to another SV */		\
	char*   svu_pv;		/* pointer to malloced string */	\
	SV**    svu_array;		\
	HE**	svu_hash;		\
	GP*	svu_gp;			\
    }	sv_u


d68 3
a70 9
    _SV_HEAD(void*);
    _SV_HEAD_UNION;
#ifdef DEBUG_LEAKING_SCALARS
    unsigned	sv_debug_optype:9;	/* the type of OP that allocated us */
    unsigned	sv_debug_inpad:1;	/* was allocated in a pad for an OP */
    unsigned	sv_debug_cloned:1;	/* was cloned for an ithread */
    unsigned	sv_debug_line:16;	/* the line where we were allocated */
    char *	sv_debug_file;		/* the file where we were allocated */
#endif
d74 3
a76 2
    _SV_HEAD(XPVGV*);		/* pointer to xpvgv body */
    _SV_HEAD_UNION;
d80 3
a82 2
    _SV_HEAD(XPVCV*);		/* pointer to xpvcv body */
    _SV_HEAD_UNION;
d86 3
a88 2
    _SV_HEAD(XPVAV*);		/* pointer to xpvav body */
    _SV_HEAD_UNION;
d92 3
a94 2
    _SV_HEAD(XPVHV*);		/* pointer to xpvhv body */
    _SV_HEAD_UNION;
d98 3
a100 2
    _SV_HEAD(XPVIO*);		/* pointer to xpvio body */
    _SV_HEAD_UNION;
a102 3
#undef _SV_HEAD
#undef _SV_HEAD_UNION		/* ensure no pollution */

a111 37
All of the following SvREFCNT_inc* macros are optimized versions of
SvREFCNT_inc, and can be replaced with SvREFCNT_inc.

=for apidoc Am|SV*|SvREFCNT_inc_NN|SV* sv
Same as SvREFCNT_inc, but can only be used if you know I<sv>
is not NULL.  Since we don't have to check the NULLness, it's faster
and smaller.

=for apidoc Am|void|SvREFCNT_inc_void|SV* sv
Same as SvREFCNT_inc, but can only be used if you don't need the
return value.  The macro doesn't need to return a meaningful value.

=for apidoc Am|void|SvREFCNT_inc_void_NN|SV* sv
Same as SvREFCNT_inc, but can only be used if you don't need the return
value, and you know that I<sv> is not NULL.  The macro doesn't need
to return a meaningful value, or check for NULLness, so it's smaller
and faster.

=for apidoc Am|SV*|SvREFCNT_inc_simple|SV* sv
Same as SvREFCNT_inc, but can only be used with expressions without side
effects.  Since we don't have to store a temporary value, it's faster.

=for apidoc Am|SV*|SvREFCNT_inc_simple_NN|SV* sv
Same as SvREFCNT_inc_simple, but can only be used if you know I<sv>
is not NULL.  Since we don't have to check the NULLness, it's faster
and smaller.

=for apidoc Am|void|SvREFCNT_inc_simple_void|SV* sv
Same as SvREFCNT_inc_simple, but can only be used if you don't need the
return value.  The macro doesn't need to return a meaningful value.

=for apidoc Am|void|SvREFCNT_inc_simple_void_NN|SV* sv
Same as SvREFCNT_inc, but can only be used if you don't need the return
value, and you know that I<sv> is not NULL.  The macro doesn't need
to return a meaningful value, or check for NULLness, so it's smaller
and faster.

d129 27
d161 1
a161 1
	     (SvREFCNT(_sv))++;		\
a163 18
#  define SvREFCNT_inc_simple(sv)	\
    ({					\
	if (sv)				\
	     (SvREFCNT(sv))++;		\
	(SV *)(sv);				\
    })
#  define SvREFCNT_inc_NN(sv)		\
    ({					\
	SV * const _sv = (SV*)(sv);	\
	SvREFCNT(_sv)++;		\
	_sv;				\
    })
#  define SvREFCNT_inc_void(sv)		\
    ({					\
	SV * const _sv = (SV*)(sv);	\
	if (_sv)			\
	    (void)(SvREFCNT(_sv)++);	\
    })
d165 11
a175 8
#  define SvREFCNT_inc(sv)	\
	((PL_Sv=(SV*)(sv)) ? (++(SvREFCNT(PL_Sv)),PL_Sv) : NULL)
#  define SvREFCNT_inc_simple(sv) \
	((sv) ? (SvREFCNT(sv)++,(SV*)(sv)) : NULL)
#  define SvREFCNT_inc_NN(sv) \
	(PL_Sv=(SV*)(sv),++(SvREFCNT(PL_Sv)),PL_Sv)
#  define SvREFCNT_inc_void(sv) \
	(void)((PL_Sv=(SV*)(sv)) ? ++(SvREFCNT(PL_Sv)) : 0)
a177 20
/* These guys don't need the curly blocks */
#define SvREFCNT_inc_simple_void(sv)	STMT_START { if (sv) SvREFCNT(sv)++; } STMT_END
#define SvREFCNT_inc_simple_NN(sv)	(++(SvREFCNT(sv)),(SV*)(sv))
#define SvREFCNT_inc_void_NN(sv)	(void)(++SvREFCNT((SV*)(sv)))
#define SvREFCNT_inc_simple_void_NN(sv)	(void)(++SvREFCNT((SV*)(sv)))

#if defined(__GNUC__) && !defined(__STRICT_ANSI__) && !defined(PERL_GCC_PEDANTIC)
#  define SvREFCNT_dec(sv)		\
    ({					\
	SV * const _sv = (SV*)(sv);	\
	if (_sv) {			\
	    if (SvREFCNT(_sv)) {	\
		if (--(SvREFCNT(_sv)) == 0) \
		    Perl_sv_free2(aTHX_ _sv);	\
	    } else {			\
		sv_free(_sv);		\
	    }				\
	}				\
    })
#else
a178 1
#endif
d181 1
a181 59
#define SvTYPE(sv)	((svtype)((sv)->sv_flags & SVTYPEMASK))

/* Sadly there are some parts of the core that have pointers to already-freed
   SV heads, and rely on being able to tell that they are now free. So mark
   them all by using a consistent macro.  */
#define SvIS_FREED(sv)	((sv)->sv_flags == SVTYPEMASK)

#define SvUPGRADE(sv, mt) (SvTYPE(sv) >= (mt) || (sv_upgrade(sv, mt), 1))

#define SVf_IOK		0x00000100  /* has valid public integer value */
#define SVf_NOK		0x00000200  /* has valid public numeric value */
#define SVf_POK		0x00000400  /* has valid public pointer value */
#define SVf_ROK		0x00000800  /* has a valid reference pointer */

#define SVp_IOK		0x00001000  /* has valid non-public integer value */
#define SVp_NOK		0x00002000  /* has valid non-public numeric value */
#define SVp_POK		0x00004000  /* has valid non-public pointer value */
#define SVp_SCREAM	0x00008000  /* has been studied? */
#define SVphv_CLONEABLE	SVp_SCREAM  /* PVHV (stashes) clone its objects */
#define SVpgv_GP	SVp_SCREAM  /* GV has a valid GP */
#define SVprv_PCS_IMPORTED  SVp_SCREAM  /* RV is a proxy for a constant
				       subroutine in another package. Set the
				       CvIMPORTED_CV_ON() if it needs to be
				       expanded to a real GV */

#define SVs_PADSTALE	0x00010000  /* lexical has gone out of scope */
#define SVpad_STATE	0x00010000  /* pad name is a "state" var */
#define SVs_PADTMP	0x00020000  /* in use as tmp */
#define SVpad_TYPED	0x00020000  /* pad name is a Typed Lexical */
#define SVs_PADMY	0x00040000  /* in use a "my" variable */
#define SVpad_OUR	0x00040000  /* pad name is "our" instead of "my" */
#define SVs_TEMP	0x00080000  /* string is stealable? */
#define SVs_OBJECT	0x00100000  /* is "blessed" */
#define SVs_GMG		0x00200000  /* has magical get method */
#define SVs_SMG		0x00400000  /* has magical set method */
#define SVs_RMG		0x00800000  /* has random magical methods */

#define SVf_FAKE	0x01000000  /* 0: glob or lexical is just a copy
				       1: SV head arena wasn't malloc()ed
				       2: in conjunction with SVf_READONLY
					  marks a shared hash key scalar
					  (SvLEN == 0) or a copy on write
					  string (SvLEN != 0) [SvIsCOW(sv)]
				       3: For PVCV, whether CvUNIQUE(cv)
					  refers to an eval or once only
					  [CvEVAL(cv), CvSPECIAL(cv)]
				       4: Whether the regexp pointer is in
					  fact an offset [SvREPADTMP(sv)]
				       5: On a pad name SV, that slot in the
					  frame AV is a REFCNT'ed reference
					  to a lexical from "outside". */
#define SVphv_REHASH	SVf_FAKE    /* 6: On a PVHV, hash values are being
					  recalculated */
#define SVf_OOK		0x02000000  /* has valid offset value. For a PVHV this
				       means that a hv_aux struct is present
				       after the main array */
#define SVf_BREAK	0x04000000  /* refcnt is artificially low - used by
				       SV's in final arena cleanup */
#define SVf_READONLY	0x08000000  /* may not be modified */
d183 1
d185 25
d211 1
d216 1
a216 1
			 SVp_IOK|SVp_NOK|SVp_POK|SVpgv_GP)
d218 5
a222 1
#define PRIVSHIFT 4	/* (SVp_?OK >> PRIVSHIFT) == SVf_?OK */
d224 3
a226 1
#define SVf_AMAGIC	0x10000000  /* has magical overloaded methods */
d228 1
a228 6
/* Ensure this value does not clash with the GV_ADD* flags in gv.h: */
#define SVf_UTF8        0x20000000  /* SvPV is UTF-8 encoded
				       This is also set on RVs whose overloaded
				       stringification is UTF-8. This might
				       only happen as a side effect of SvPV() */
					   
d230 12
a241 1
/* Some private flags. */
d243 1
a243 33
/* PVAV could probably use 0x2000000 without conflict. I assume that PVFM can
   be UTF-8 encoded, and PVCVs could well have UTF-8 prototypes. PVIOs haven't
   been restructured, so sometimes get used as string buffers.  */

/* PVHV */
#define SVphv_SHAREKEYS 0x20000000  /* PVHV keys live on shared string table */
/* PVNV, PVMG, presumably only inside pads */
#define SVpad_NAME	0x40000000  /* This SV is a name in the PAD, so
				       SVpad_TYPED, SVpad_OUR and SVpad_STATE
				       apply */
/* PVAV */
#define SVpav_REAL	0x40000000  /* free old entries */
/* PVHV */
#define SVphv_LAZYDEL	0x40000000  /* entry in xhv_eiter must be deleted */
/* This is only set true on a PVGV when it's playing "PVBM", but is tested for
   on any regular scalar (anything <= PVLV) */
#define SVpbm_VALID	0x40000000
/* ??? */
#define SVrepl_EVAL	0x40000000  /* Replacement part of s///e */

/* IV, PVIV, PVNV, PVMG, PVGV and (I assume) PVLV  */
/* Presumably IVs aren't stored in pads */
#define SVf_IVisUV	0x80000000  /* use XPVUV instead of XPVIV */
/* PVAV */
#define SVpav_REIFY 	0x80000000  /* can become real */
/* PVHV */
#define SVphv_HASKFLAGS	0x80000000  /* keys have flag byte after hash */
/* PVFM */
#define SVpfm_COMPILED	0x80000000  /* FORMLINE is compiled */
/* PVGV when SVpbm_VALID is true */
#define SVpbm_TAIL	0x80000000
/* RV upwards. However, SVf_ROK and SVp_IOK are exclusive  */
#define SVprv_WEAKREF   0x80000000  /* Weak reference */
d245 3
d250 2
a251 14
    union {
	NV	xnv_nv;		/* numeric value, if any */
	HV *	xgv_stash;
	struct {
	    U32	xlow;
	    U32	xhigh;
	}	xpad_cop_seq;	/* used by pad.c for cop_sequence */
	struct {
	    U32 xbm_previous;	/* how many characters in string before rare? */
	    U8	xbm_flags;
	    U8	xbm_rare;	/* rarest character in string */
	}	xbm_s;		/* fields from PVBM */
    }		xnv_u;
    STRLEN	xpv_cur;	/* length of svu_pv as a C string */
a254 5
typedef struct {
    STRLEN	xpv_cur;	/* length of svu_pv as a C string */
    STRLEN	xpv_len;	/* allocated size */
} xpv_allocated;

d256 2
a257 14
    union {
	NV	xnv_nv;		/* numeric value, if any */
	HV *	xgv_stash;
	struct {
	    U32	xlow;
	    U32	xhigh;
	}	xpad_cop_seq;	/* used by pad.c for cop_sequence */
	struct {
	    U32 xbm_previous;	/* how many characters in string before rare? */
	    U8	xbm_flags;
	    U8	xbm_rare;	/* rarest character in string */
	}	xbm_s;		/* fields from PVBM */
    }		xnv_u;
    STRLEN	xpv_cur;	/* length of svu_pv as a C string */
d259 1
a259 7
    union {
	IV	xivu_iv;	/* integer value or pv offset */
	UV	xivu_uv;
	void *	xivu_p1;
	I32	xivu_i32;
	HEK *	xivu_namehek;
    }		xiv_u;
a261 14
typedef struct {
    STRLEN	xpv_cur;	/* length of svu_pv as a C string */
    STRLEN	xpv_len;	/* allocated size */
    union {
	IV	xivu_iv;	/* integer value or pv offset */
	UV	xivu_uv;
	void *	xivu_p1;
	I32	xivu_i32;
	HEK *	xivu_namehek;
    }		xiv_u;
} xpviv_allocated;

#define xiv_iv xiv_u.xivu_iv

d263 2
a264 14
    union {
	NV	xnv_nv;		/* numeric value, if any */
	HV *	xgv_stash;
	struct {
	    U32	xlow;
	    U32	xhigh;
	}	xpad_cop_seq;	/* used by pad.c for cop_sequence */
	struct {
	    U32 xbm_previous;	/* how many characters in string before rare? */
	    U8	xbm_flags;
	    U8	xbm_rare;	/* rarest character in string */
	}	xbm_s;		/* fields from PVBM */
    }		xnv_u;
    STRLEN	xpv_cur;	/* length of svu_pv as a C string */
d266 1
a266 6
    union {
	IV	xuvu_iv;
	UV	xuvu_uv;	/* unsigned value or pv offset */
	void *	xuvu_p1;
	HEK *	xivu_namehek;
    }		xuv_u;
a268 2
#define xuv_uv xuv_u.xuvu_uv

d270 2
a271 14
    union {
	NV	xnv_nv;		/* numeric value, if any */
	HV *	xgv_stash;
	struct {
	    U32	xlow;
	    U32	xhigh;
	}	xpad_cop_seq;	/* used by pad.c for cop_sequence */
	struct {
	    U32 xbm_previous;	/* how many characters in string before rare? */
	    U8	xbm_flags;
	    U8	xbm_rare;	/* rarest character in string */
	}	xbm_s;		/* fields from PVBM */
    }		xnv_u;
    STRLEN	xpv_cur;	/* length of svu_pv as a C string */
d273 2
a274 7
    union {
	IV	xivu_iv;	/* integer value or pv offset */
	UV	xivu_uv;
	void *	xivu_p1;
	I32	xivu_i32;
	HEK *	xivu_namehek;
    }		xiv_u;
d279 2
a280 14
    union {
	NV	xnv_nv;		/* numeric value, if any */
	HV *	xgv_stash;
	struct {
	    U32	xlow;
	    U32	xhigh;
	}	xpad_cop_seq;	/* used by pad.c for cop_sequence */
	struct {
	    U32 xbm_previous;	/* how many characters in string before rare? */
	    U8	xbm_flags;
	    U8	xbm_rare;	/* rarest character in string */
	}	xbm_s;		/* fields from PVBM */
    }		xnv_u;
    STRLEN	xpv_cur;	/* length of svu_pv as a C string */
d282 3
a284 11
    union {
	IV	xivu_iv;	/* integer value or pv offset */
	UV	xivu_uv;
	void *	xivu_p1;
	I32	xivu_i32;
	HEK *	xivu_namehek;
    }		xiv_u;
    union {
	MAGIC*	xmg_magic;	/* linked list of magicalness */
	HV*	xmg_ourstash;	/* Stash for our (when SvPAD_OUR is true) */
    } xmg_u;
d289 2
a290 14
    union {
	NV	xnv_nv;		/* numeric value, if any */
	HV *	xgv_stash;
	struct {
	    U32	xlow;
	    U32	xhigh;
	}	xpad_cop_seq;	/* used by pad.c for cop_sequence */
	struct {
	    U32 xbm_previous;	/* how many characters in string before rare? */
	    U8	xbm_flags;
	    U8	xbm_rare;	/* rarest character in string */
	}	xbm_s;		/* fields from PVBM */
    }		xnv_u;
    STRLEN	xpv_cur;	/* length of svu_pv as a C string */
d292 3
a294 11
    union {
	IV	xivu_iv;	/* integer value or pv offset */
	UV	xivu_uv;
	void *	xivu_p1;
	I32	xivu_i32;
	HEK *	xivu_namehek;	/* GvNAME */
    }		xiv_u;
    union {
	MAGIC*	xmg_magic;	/* linked list of magicalness */
	HV*	xmg_ourstash;	/* Stash for our (when SvPAD_OUR is true) */
    } xmg_u;
a303 2
/* This structure works in 3 ways - regular scalar, GV with GP, or fast
   Boyer-Moore.  */
d305 22
a326 26
    union {
	NV	xnv_nv;
	HV *	xgv_stash;	/* The stash of this GV */
	struct {
	    U32	xlow;
	    U32	xhigh;
	}	xpad_cop_seq;	/* used by pad.c for cop_sequence */
	struct {
	    U32 xbm_previous;	/* how many characters in string before rare? */
	    U8	xbm_flags;
	    U8	xbm_rare;	/* rarest character in string */
	}	xbm_s;		/* fields from PVBM */
    }		xnv_u;
    STRLEN	xpv_cur;	/* xgv_flags */
    STRLEN	xpv_len;	/* 0 */
    union {
	IV	xivu_iv;
	UV	xivu_uv;
	void *	xivu_p1;
	I32	xivu_i32;	/* is this constant pattern being useful? */
	HEK *	xivu_namehek;	/* GvNAME */
    }		xiv_u;
    union {
	MAGIC*	xmg_magic;	/* linked list of magicalness */
	HV*	xmg_ourstash;	/* Stash for our (when SvPAD_OUR is true) */
    } xmg_u;
d329 3
d339 2
a340 14
    union {
	NV	xnv_nv;		/* numeric value, if any */
	HV *	xgv_stash;
	struct {
	    U32	xlow;
	    U32	xhigh;
	}	xpad_cop_seq;	/* used by pad.c for cop_sequence */
	struct {
	    U32 xbm_previous;	/* how many characters in string before rare? */
	    U8	xbm_flags;
	    U8	xbm_rare;	/* rarest character in string */
	}	xbm_s;		/* fields from PVBM */
    }		xnv_u;
    STRLEN	xpv_cur;	/* length of svu_pv as a C string */
d342 3
a344 11
    union {
	IV	xivu_iv;	/* PVFMs use the pv offset */
	UV	xivu_uv;
	void *	xivu_p1;
	I32	xivu_i32;
	HEK *	xivu_namehek;
    }		xiv_u;
    union {
	MAGIC*	xmg_magic;	/* linked list of magicalness */
	HV*	xmg_ourstash;	/* Stash for our (when SvPAD_OUR is true) */
    } xmg_u;
d348 4
a351 8
    union {
	OP *	xcv_start;
	ANY	xcv_xsubany;
    }		xcv_start_u;
    union {
	OP *	xcv_root;
	void	(*xcv_xsub) (pTHX_ CV*);
    }		xcv_root_u;
d354 1
d357 5
a364 1
    cv_flags_t	xcv_flags;
a367 36
typedef struct {
    STRLEN	xpv_cur;	/* length of svu_pv as a C string */
    STRLEN	xpv_len;	/* allocated size */
    union {
	IV	xivu_iv;	/* PVFMs use the pv offset */
	UV	xivu_uv;
	void *	xivu_p1;
	I32	xivu_i32;
	HEK *	xivu_namehek;
    }		xiv_u;
    union {
	MAGIC*	xmg_magic;	/* linked list of magicalness */
	HV*	xmg_ourstash;	/* Stash for our (when SvPAD_OUR is true) */
    } xmg_u;
    HV*		xmg_stash;	/* class package */

    HV *	xcv_stash;
    union {
	OP *	xcv_start;
	ANY	xcv_xsubany;
    }		xcv_start_u;
    union {
	OP *	xcv_root;
	void	(*xcv_xsub) (pTHX_ CV*);
    }		xcv_root_u;
    GV *	xcv_gv;
    char *	xcv_file;
    AV *	xcv_padlist;
    CV *	xcv_outside;
    U32		xcv_outside_seq; /* the COP sequence (at the point of our
				  * compilation) in the lexically enclosing
				  * sub */
    cv_flags_t	xcv_flags;
    IV		xfm_lines;
} xpvfm_allocated;

d369 2
a370 14
    union {
	NV	xnv_nv;		/* numeric value, if any */
	HV *	xgv_stash;
	struct {
	    U32	xlow;
	    U32	xhigh;
	}	xpad_cop_seq;	/* used by pad.c for cop_sequence */
	struct {
	    U32 xbm_previous;	/* how many characters in string before rare? */
	    U8	xbm_flags;
	    U8	xbm_rare;	/* rarest character in string */
	}	xbm_s;		/* fields from PVBM */
    }		xnv_u;
    STRLEN	xpv_cur;	/* length of svu_pv as a C string */
d372 3
a374 11
    union {
	IV	xivu_iv;	/* integer value or pv offset */
	UV	xivu_uv;
	void *	xivu_p1;
	I32	xivu_i32;
	HEK *	xivu_namehek;
    }		xiv_u;
    union {
	MAGIC*	xmg_magic;	/* linked list of magicalness */
	HV*	xmg_ourstash;	/* Stash for our (when SvPAD_OUR is true) */
    } xmg_u;
d402 1
d404 1
a404 1
    U8		xio_flags;
d420 2
a421 2
=for apidoc Am|U32|SvNIOK|SV* sv
Returns a U32 value indicating whether the SV contains a number, integer or
d424 2
a425 2
=for apidoc Am|U32|SvNIOKp|SV* sv
Returns a U32 value indicating whether the SV contains a number, integer or
d431 2
a432 2
=for apidoc Am|U32|SvOK|SV* sv
Returns a U32 value indicating whether the value is an SV. It also tells
d435 2
a436 2
=for apidoc Am|U32|SvIOKp|SV* sv
Returns a U32 value indicating whether the SV contains an integer.  Checks
d439 2
a440 2
=for apidoc Am|U32|SvNOKp|SV* sv
Returns a U32 value indicating whether the SV contains a double.  Checks the
d443 2
a444 2
=for apidoc Am|U32|SvPOKp|SV* sv
Returns a U32 value indicating whether the SV contains a character string.
d447 2
a448 2
=for apidoc Am|U32|SvIOK|SV* sv
Returns a U32 value indicating whether the SV contains an integer.
d465 1
a465 1
=for apidoc Am|bool|SvUOK|SV* sv
d471 2
a472 2
=for apidoc Am|U32|SvNOK|SV* sv
Returns a U32 value indicating whether the SV contains a double.
d483 2
a484 2
=for apidoc Am|U32|SvPOK|SV* sv
Returns a U32 value indicating whether the SV contains a character
d497 2
a498 5
=for apidoc Am|bool|SvVOK|SV* sv
Returns a boolean indicating whether the SV contains a v-string.

=for apidoc Am|U32|SvOOK|SV* sv
Returns a U32 indicating whether the SvIVX is a valid offset value for
d503 1
a503 1
=for apidoc Am|U32|SvROK|SV* sv
d566 1
a566 1
=for apidoc Am|void|SvSTASH_set|SV* sv|HV* val
a585 1
#define assert_not_glob(sv)	({assert(!isGV_with_GP(sv));}),
a587 1
#define assert_not_glob(sv)	
d590 3
a592 5
#define SvOK(sv)		((SvTYPE(sv) == SVt_BIND)		\
				 ? (SvFLAGS(SvRV(sv)) & SVf_OK)		\
				 : (SvFLAGS(sv) & SVf_OK))
#define SvOK_off(sv)		(assert_not_ROK(sv) assert_not_glob(sv)	\
				 SvFLAGS(sv) &=	~(SVf_OK|		\
d596 1
a596 1
				 SvFLAGS(sv) &=	~(SVf_OK|		\
d602 1
a602 2
#define SvIOKp_on(sv)		(assert_not_glob(sv) SvRELEASE_IVX(sv), \
				    SvFLAGS(sv) |= SVp_IOK)
d604 1
a604 1
#define SvNOKp_on(sv)		(assert_not_glob(sv) SvFLAGS(sv) |= SVp_NOK)
d606 1
a606 1
#define SvPOKp_on(sv)		(assert_not_ROK(sv) assert_not_glob(sv)	\
d610 1
a610 1
#define SvIOK_on(sv)		(assert_not_glob(sv) SvRELEASE_IVX(sv), \
d615 1
a615 1
#define SvIOK_only_UV(sv)	(assert_not_glob(sv) SvOK_off_exc_UV(sv), \
d624 1
d630 1
a630 2
#define SvNOK_on(sv)		(assert_not_glob(sv) \
				 SvFLAGS(sv) |= (SVf_NOK|SVp_NOK))
d636 2
a637 4
=for apidoc Am|U32|SvUTF8|SV* sv
Returns a U32 value indicating whether the SV contains UTF-8 encoded data.
Call this after SvPV() in case any call to string overloading updates the
internal flag.
a652 2
/* Ensure the return value of this macro does not clash with the GV_ADD* flags
in gv.h: */
d658 1
a658 1
#define SvPOK_on(sv)		(assert_not_ROK(sv) assert_not_glob(sv)	\
d661 2
a662 2
#define SvPOK_only(sv)		(assert_not_ROK(sv) assert_not_glob(sv)	\
				 SvFLAGS(sv) &= ~(SVf_OK|		\
d665 2
a666 2
#define SvPOK_only_UTF8(sv)	(assert_not_ROK(sv) assert_not_glob(sv)	\
				 SvFLAGS(sv) &= ~(SVf_OK|		\
a669 6
#define SvVOK(sv)		(SvMAGICAL(sv)				\
				 && mg_find(sv,PERL_MAGIC_vstring))
/* returns the vstring magic, if any */
#define SvVSTRING_mg(sv)	(SvMAGICAL(sv) \
				 ? mg_find(sv,PERL_MAGIC_vstring) : NULL)

d680 1
a680 1
#define SvROK_off(sv)		(SvFLAGS(sv) &= ~(SVf_ROK))
d698 5
a702 15
#define SvAMAGIC(sv)		(SvROK(sv) && (SvFLAGS(SvRV(sv)) & SVf_AMAGIC))
#if defined(__GNUC__) && !defined(PERL_GCC_BRACE_GROUPS_FORBIDDEN)
#  define SvAMAGIC_on(sv)	({ SV * const kloink = sv;		\
				   assert(SvROK(kloink));		\
				   SvFLAGS(SvRV(kloink)) |= SVf_AMAGIC;	\
				})
#  define SvAMAGIC_off(sv)	({ SV * const kloink = sv;		\
				   if(SvROK(kloink))			\
					SvFLAGS(SvRV(kloink)) &= ~SVf_AMAGIC;\
				})
#else
#  define SvAMAGIC_on(sv)	(SvFLAGS(SvRV(sv)) |= SVf_AMAGIC)
#  define SvAMAGIC_off(sv) \
	(SvROK(sv) && (SvFLAGS(SvRV(sv)) &= ~SVf_AMAGIC))
#endif
d705 3
a707 9
=for apidoc Am|char*|SvGAMAGIC|SV* sv

Returns true if the SV has get magic or overloading. If either is true then
the scalar is active data, and has the potential to return a new value every
time it is accessed. Hence you must be careful to only read it once per user
logical operation and work with that returned value. If neither is true then
the scalar's value cannot change unless written to.

=cut
a708 3

#define SvGAMAGIC(sv)           (SvGMAGICAL(sv) || SvAMAGIC(sv))

a715 5
#define SvPCS_IMPORTED(sv)	((SvFLAGS(sv) & (SVf_ROK|SVprv_PCS_IMPORTED)) \
				 == (SVf_ROK|SVprv_PCS_IMPORTED))
#define SvPCS_IMPORTED_on(sv)	(SvFLAGS(sv) |=  (SVf_ROK|SVprv_PCS_IMPORTED))
#define SvPCS_IMPORTED_off(sv)	(SvFLAGS(sv) &= ~(SVf_ROK|SVprv_PCS_IMPORTED))

d718 1
a718 3
#define SvPADSTALE(sv)		(SvFLAGS(sv) & SVs_PADSTALE)
#define SvPADSTALE_on(sv)	(SvFLAGS(sv) |= SVs_PADSTALE)
#define SvPADSTALE_off(sv)	(SvFLAGS(sv) &= ~SVs_PADSTALE)
d721 1
a721 1
#define SvPADTMP_on(sv)		(SvFLAGS(sv) |= SVs_PADTMP)
d725 1
a725 1
#define SvPADMY_on(sv)		(SvFLAGS(sv) |= SVs_PADMY)
d739 1
a739 1
#define SvSCREAM(sv) ((SvFLAGS(sv) & (SVp_SCREAM|SVp_POK)) == (SVp_SCREAM|SVp_POK))
d751 1
a751 29
#if defined (DEBUGGING) && defined(__GNUC__) && !defined(PERL_GCC_BRACE_GROUPS_FORBIDDEN)
#  define SvVALID(sv)		({ SV *const thwacke = (SV *) (sv);	\
				   if (SvFLAGS(thwacke) & SVpbm_VALID)	\
				       assert(!isGV_with_GP(thwacke));	\
				   (SvFLAGS(thwacke) & SVpbm_VALID);	\
				})
#  define SvVALID_on(sv)	({ SV *const thwacke = (SV *) (sv);	\
				   assert(!isGV_with_GP(thwacke));	\
				   (SvFLAGS(thwacke) |= SVpbm_VALID);	\
				})
#  define SvVALID_off(sv)	({ SV *const thwacke = (SV *) (sv);	\
				   assert(!isGV_with_GP(thwacke));	\
				   (SvFLAGS(thwacke) &= ~SVpbm_VALID);	\
				})

#  define SvTAIL(sv)	({ SV *const _svi = (SV *) (sv);		\
			    assert(SvTYPE(_svi) != SVt_PVAV);		\
			    assert(SvTYPE(_svi) != SVt_PVHV);		\
			    (SvFLAGS(sv) & (SVpbm_TAIL|SVpbm_VALID))	\
				== (SVpbm_TAIL|SVpbm_VALID);		\
			})
#else
#  define SvVALID(sv)		(SvFLAGS(sv) & SVpbm_VALID)
#  define SvVALID_on(sv)	(SvFLAGS(sv) |= SVpbm_VALID)
#  define SvVALID_off(sv)	(SvFLAGS(sv) &= ~SVpbm_VALID)
#  define SvTAIL(sv)	    ((SvFLAGS(sv) & (SVpbm_TAIL|SVpbm_VALID))	\
			     == (SVpbm_TAIL|SVpbm_VALID))

#endif
d755 3
d767 1
a767 42
#define SvPAD_TYPED(sv) \
	((SvFLAGS(sv) & (SVpad_NAME|SVpad_TYPED)) == (SVpad_NAME|SVpad_TYPED))

#define SvPAD_OUR(sv)	\
	((SvFLAGS(sv) & (SVpad_NAME|SVpad_OUR)) == (SVpad_NAME|SVpad_OUR))

#define SvPAD_STATE(sv)	\
	((SvFLAGS(sv) & (SVpad_NAME|SVpad_STATE)) == (SVpad_NAME|SVpad_STATE))

#if defined (DEBUGGING) && defined(__GNUC__) && !defined(PERL_GCC_BRACE_GROUPS_FORBIDDEN)
#  define SvPAD_TYPED_on(sv)	({					\
	    SV *const whap = (SV *) (sv);				\
	    assert(SvTYPE(whap) == SVt_PVMG);				\
	    (SvFLAGS(whap) |= SVpad_NAME|SVpad_TYPED);			\
	})
#define SvPAD_OUR_on(sv)	({					\
	    SV *const whap = (SV *) (sv);				\
	    assert(SvTYPE(whap) == SVt_PVMG);				\
	    (SvFLAGS(whap) |= SVpad_NAME|SVpad_OUR);			\
	})
#define SvPAD_STATE_on(sv)	({					\
	    SV *const whap = (SV *) (sv);				\
	    assert(SvTYPE(whap) == SVt_PVNV || SvTYPE(whap) == SVt_PVMG); \
	    (SvFLAGS(whap) |= SVpad_NAME|SVpad_STATE);			\
	})
#else
#  define SvPAD_TYPED_on(sv)	(SvFLAGS(sv) |= SVpad_NAME|SVpad_TYPED)
#  define SvPAD_OUR_on(sv)	(SvFLAGS(sv) |= SVpad_NAME|SVpad_OUR)
#  define SvPAD_STATE_on(sv)	(SvFLAGS(sv) |= SVpad_NAME|SVpad_STATE)
#endif

#define SvOURSTASH(sv)	\
	(SvPAD_OUR(sv) ? ((XPVMG*) SvANY(sv))->xmg_u.xmg_ourstash : NULL)
#define SvOURSTASH_set(sv, st)					\
        STMT_START {						\
	    assert(SvTYPE(sv) == SVt_PVMG);			\
	    ((XPVMG*) SvANY(sv))->xmg_u.xmg_ourstash = st;	\
	} STMT_END

#ifdef PERL_DEBUG_COW
#else
#endif
d770 4
a773 109
#ifdef PERL_DEBUG_COW
/* Need -0.0 for SvNVX to preserve IEEE FP "negative zero" because
   +0.0 + -0.0 => +0.0 but -0.0 + -0.0 => -0.0 */
#  define SvIVX(sv) (0 + ((XPVIV*) SvANY(sv))->xiv_iv)
#  define SvUVX(sv) (0 + ((XPVUV*) SvANY(sv))->xuv_uv)
#  define SvNVX(sv) (-0.0 + ((XPVNV*) SvANY(sv))->xnv_u.xnv_nv)
#  define SvRV(sv) (0 + (sv)->sv_u.svu_rv)
/* Don't test the core XS code yet.  */
#  if defined (PERL_CORE) && PERL_DEBUG_COW > 1
#    define SvPVX(sv) (0 + (assert(!SvREADONLY(sv)), (sv)->sv_u.svu_pv))
#  else
#  define SvPVX(sv) SvPVX_mutable(sv)
#  endif
#  define SvCUR(sv) (0 + ((XPV*) SvANY(sv))->xpv_cur)
#  define SvLEN(sv) (0 + ((XPV*) SvANY(sv))->xpv_len)
#  define SvEND(sv) ((sv)->sv_u.svu_pv + ((XPV*)SvANY(sv))->xpv_cur)

#  ifdef DEBUGGING
#    define SvMAGIC(sv)	(0 + *(assert(SvTYPE(sv) >= SVt_PVMG), &((XPVMG*)  SvANY(sv))->xmg_u.xmg_magic))
#    define SvSTASH(sv)	(0 + *(assert(SvTYPE(sv) >= SVt_PVMG), &((XPVMG*)  SvANY(sv))->xmg_stash))
#  else
#    define SvMAGIC(sv)	(0 + ((XPVMG*)  SvANY(sv))->xmg_u.xmg_magic)
#    define SvSTASH(sv)	(0 + ((XPVMG*)  SvANY(sv))->xmg_stash)
#  endif
#else
#  define SvLEN(sv) ((XPV*) SvANY(sv))->xpv_len
#  define SvEND(sv) ((sv)->sv_u.svu_pv + ((XPV*)SvANY(sv))->xpv_cur)

#  if defined (DEBUGGING) && defined(__GNUC__) && !defined(PERL_GCC_BRACE_GROUPS_FORBIDDEN)
/* These get expanded inside other macros that already use a variable _sv  */
#    define SvPVX(sv)							\
	(*({ SV *const _svi = (SV *) (sv);				\
	    assert(SvTYPE(_svi) >= SVt_PV);				\
	    assert(SvTYPE(_svi) != SVt_PVAV);				\
	    assert(SvTYPE(_svi) != SVt_PVHV);				\
	    assert(!isGV_with_GP(_svi));				\
	    &((_svi)->sv_u.svu_pv);					\
	 }))
#    define SvCUR(sv)							\
	(*({ SV *const _svi = (SV *) (sv);				\
	    assert(SvTYPE(_svi) >= SVt_PV);				\
	    assert(SvTYPE(_svi) != SVt_PVAV);				\
	    assert(SvTYPE(_svi) != SVt_PVHV);				\
	    assert(!isGV_with_GP(_svi));				\
	    &(((XPV*) SvANY(_svi))->xpv_cur);				\
	 }))
#    define SvIVX(sv)							\
	(*({ SV *const _svi = (SV *) (sv);				\
	    assert(SvTYPE(_svi) == SVt_IV || SvTYPE(_svi) >= SVt_PVIV);	\
	    assert(SvTYPE(_svi) != SVt_PVAV);				\
	    assert(SvTYPE(_svi) != SVt_PVHV);				\
	    assert(SvTYPE(_svi) != SVt_PVCV);				\
	    assert(!isGV_with_GP(_svi));				\
	    &(((XPVIV*) SvANY(_svi))->xiv_iv);				\
	 }))
#    define SvUVX(sv)							\
	(*({ SV *const _svi = (SV *) (sv);				\
	    assert(SvTYPE(_svi) == SVt_IV || SvTYPE(_svi) >= SVt_PVIV);	\
	    assert(SvTYPE(_svi) != SVt_PVAV);				\
	    assert(SvTYPE(_svi) != SVt_PVHV);				\
	    assert(SvTYPE(_svi) != SVt_PVCV);				\
	    assert(!isGV_with_GP(_svi));				\
	    &(((XPVUV*) SvANY(_svi))->xuv_uv);				\
	 }))
#    define SvNVX(sv)							\
	(*({ SV *const _svi = (SV *) (sv);				\
	    assert(SvTYPE(_svi) == SVt_NV || SvTYPE(_svi) >= SVt_PVNV);	\
	    assert(SvTYPE(_svi) != SVt_PVAV);				\
	    assert(SvTYPE(_svi) != SVt_PVHV);				\
	    assert(SvTYPE(_svi) != SVt_PVCV);				\
	    assert(SvTYPE(_svi) != SVt_PVFM);				\
	    assert(!isGV_with_GP(_svi));				\
	   &(((XPVNV*) SvANY(_svi))->xnv_u.xnv_nv);			\
	 }))
#    define SvRV(sv)							\
	(*({ SV *const _svi = (SV *) (sv);				\
	    assert(SvTYPE(_svi) >= SVt_RV);				\
	    assert(SvTYPE(_svi) != SVt_PVAV);				\
	    assert(SvTYPE(_svi) != SVt_PVHV);				\
	    assert(SvTYPE(_svi) != SVt_PVCV);				\
	    assert(SvTYPE(_svi) != SVt_PVFM);				\
	    assert(!isGV_with_GP(_svi));				\
	    &((_svi)->sv_u.svu_rv);					\
	 }))
#    define SvMAGIC(sv)							\
	(*({ SV *const _svi = (SV *) (sv);				\
	    assert(SvTYPE(_svi) >= SVt_PVMG);				\
	    if(SvTYPE(_svi) == SVt_PVMG)				\
		assert(!SvPAD_OUR(_svi));				\
	    &(((XPVMG*) SvANY(_svi))->xmg_u.xmg_magic);			\
	  }))
#    define SvSTASH(sv)							\
	(*({ SV *const _svi = (SV *) (sv);				\
	    assert(SvTYPE(_svi) >= SVt_PVMG);				\
	    &(((XPVMG*) SvANY(_svi))->xmg_stash);			\
	  }))
#  else
#    define SvPVX(sv) ((sv)->sv_u.svu_pv)
#    define SvCUR(sv) ((XPV*) SvANY(sv))->xpv_cur
#    define SvIVX(sv) ((XPVIV*) SvANY(sv))->xiv_iv
#    define SvUVX(sv) ((XPVUV*) SvANY(sv))->xuv_uv
#    define SvNVX(sv) ((XPVNV*) SvANY(sv))->xnv_u.xnv_nv
#    define SvRV(sv) ((sv)->sv_u.svu_rv)
#    define SvMAGIC(sv)	((XPVMG*)  SvANY(sv))->xmg_u.xmg_magic
#    define SvSTASH(sv)	((XPVMG*)  SvANY(sv))->xmg_stash
#  endif
#endif

#ifndef PERL_POISON
d776 5
a780 8
#  define SvPVX_mutable(sv)	(0 + (sv)->sv_u.svu_pv)
#  define SvPVX_const(sv)	((const char*)(0 + (sv)->sv_u.svu_pv))
#else
/* Except for the poison code, which uses & to scribble over the pointer after
   free() is called.  */
#  define SvPVX_mutable(sv)	((sv)->sv_u.svu_pv)
#  define SvPVX_const(sv)	((const char*)((sv)->sv_u.svu_pv))
#endif
d788 2
a789 1

d797 2
a800 4
		assert(SvTYPE(sv) != SVt_PVAV);		\
		assert(SvTYPE(sv) != SVt_PVHV);		\
		assert(SvTYPE(sv) != SVt_PVCV);		\
		assert(!isGV_with_GP(sv));		\
d804 2
a805 4
	    assert(SvTYPE(sv) != SVt_PVAV); assert(SvTYPE(sv) != SVt_PVHV); \
	    assert(SvTYPE(sv) != SVt_PVCV); assert(SvTYPE(sv) != SVt_PVFM); \
		assert(!isGV_with_GP(sv));		\
		(((XPVNV*)SvANY(sv))->xnv_u.xnv_nv = (val)); } STMT_END
d807 3
a809 5
	STMT_START { assert(SvTYPE(sv) >= SVt_PV); \
		assert(SvTYPE(sv) != SVt_PVAV);		\
		assert(SvTYPE(sv) != SVt_PVHV);		\
		assert(!isGV_with_GP(sv));		\
		((sv)->sv_u.svu_pv = (val)); } STMT_END
d811 1
a811 5
	STMT_START { assert(SvTYPE(sv) == SVt_IV || SvTYPE(sv) >= SVt_PVIV); \
		assert(SvTYPE(sv) != SVt_PVAV);		\
		assert(SvTYPE(sv) != SVt_PVHV);		\
		assert(SvTYPE(sv) != SVt_PVCV);		\
		assert(!isGV_with_GP(sv));		\
d813 1
d815 3
a817 7
        STMT_START { assert(SvTYPE(sv) >=  SVt_RV); \
		assert(SvTYPE(sv) != SVt_PVAV);		\
		assert(SvTYPE(sv) != SVt_PVHV);		\
		assert(SvTYPE(sv) != SVt_PVCV);		\
		assert(SvTYPE(sv) != SVt_PVFM);		\
		assert(!isGV_with_GP(sv));		\
                ((sv)->sv_u.svu_rv = (val)); } STMT_END
d819 3
a821 2
        STMT_START { assert(SvTYPE(sv) >= SVt_PVMG); \
                (((XPVMG*)SvANY(sv))->xmg_u.xmg_magic = (val)); } STMT_END
d823 1
a823 1
        STMT_START { assert(SvTYPE(sv) >= SVt_PVMG); \
d825 1
d827 1
a827 4
	STMT_START { assert(SvTYPE(sv) >= SVt_PV); \
		assert(SvTYPE(sv) != SVt_PVAV);		\
		assert(SvTYPE(sv) != SVt_PVHV);		\
		assert(!isGV_with_GP(sv));		\
d829 1
d831 1
a831 4
	STMT_START { assert(SvTYPE(sv) >= SVt_PV); \
		assert(SvTYPE(sv) != SVt_PVAV);	\
		assert(SvTYPE(sv) != SVt_PVHV);	\
		assert(!isGV_with_GP(sv));	\
d849 11
a859 14
#define SvPV_free(sv)							\
    STMT_START {							\
		     assert(SvTYPE(sv) >= SVt_PV);			\
		     if (SvLEN(sv)) {					\
			 if(SvOOK(sv)) {				\
			     SvPV_set(sv, SvPVX_mutable(sv) - SvIVX(sv)); \
			     SvFLAGS(sv) &= ~SVf_OOK;			\
			 }						\
			 Safefree(SvPVX(sv));				\
		     }							\
		 } STMT_END


#define PERL_FBM_TABLE_OFFSET 1	/* Number of bytes between EOS and table */
d861 3
a863 36
/* SvPOKp not SvPOK in the assertion because the string can be tainted! eg
   perl -T -e '/$^X/'
*/
#if defined (DEBUGGING) && defined(__GNUC__) && !defined(PERL_GCC_BRACE_GROUPS_FORBIDDEN)
#  define BmFLAGS(sv)							\
	(*({ SV *const uggh = (SV *) (sv);				\
		assert(SvTYPE(uggh) == SVt_PVGV);			\
		assert(SvVALID(uggh));					\
	    &(((XPVGV*) SvANY(uggh))->xnv_u.xbm_s.xbm_flags);		\
	 }))
#  define BmRARE(sv)							\
	(*({ SV *const uggh = (SV *) (sv);				\
		assert(SvTYPE(uggh) == SVt_PVGV);			\
		assert(SvVALID(uggh));					\
	    &(((XPVGV*) SvANY(uggh))->xnv_u.xbm_s.xbm_rare);		\
	 }))
#  define BmUSEFUL(sv)							\
	(*({ SV *const uggh = (SV *) (sv);				\
	    assert(SvTYPE(uggh) == SVt_PVGV);				\
	    assert(SvVALID(uggh));					\
	    assert(!SvIOK(uggh));					\
	    &(((XPVGV*) SvANY(uggh))->xiv_u.xivu_i32);			\
	 }))
#  define BmPREVIOUS(sv)						\
	(*({ SV *const uggh = (SV *) (sv);				\
		assert(SvTYPE(uggh) == SVt_PVGV);			\
		assert(SvVALID(uggh));					\
	    &(((XPVGV*) SvANY(uggh))->xnv_u.xbm_s.xbm_previous);	\
	 }))
#else
#  define BmFLAGS(sv)		((XPVGV*) SvANY(sv))->xnv_u.xbm_s.xbm_flags
#  define BmRARE(sv)		((XPVGV*) SvANY(sv))->xnv_u.xbm_s.xbm_rare
#  define BmUSEFUL(sv)		((XPVGV*) SvANY(sv))->xiv_u.xivu_i32
#  define BmPREVIOUS(sv)	((XPVGV*) SvANY(sv))->xnv_u.xbm_s.xbm_previous

#endif
d886 1
a923 2
#define sv_taint(sv)	  sv_magic((sv), NULL, PERL_MAGIC_taint, NULL, 0)

d954 1
a954 6
A version of C<SvPV> which guarantees to evaluate C<sv> only once.
Only use this if C<sv> is an expression with side effects, otherwise use the
more efficient C<SvPVX>.

=for apidoc Am|char*|SvPV_nomg|SV* sv|STRLEN len
Like C<SvPV> but doesn't process magic.
d962 1
a962 1
Coerces the given SV to an integer and returns it. See C<SvIVx> for a
a964 3
=for apidoc Am|IV|SvIV_nomg|SV* sv
Like C<SvIV> but doesn't process magic.

d967 1
a967 2
C<sv> only once. Only use this if C<sv> is an expression with side effects,
otherwise use the more efficient C<SvIV>.
d970 1
a970 1
Coerce the given SV to a double and return it. See C<SvNVx> for a version
d975 1
a975 2
C<sv> only once. Only use this if C<sv> is an expression with side effects,
otherwise use the more efficient C<SvNV>.
a980 3
=for apidoc Am|UV|SvUV_nomg|SV* sv
Like C<SvUV> but doesn't process magic.

d983 1
a983 2
C<sv> only once. Only use this if C<sv> is an expression with side effects,
otherwise use the more efficient C<SvUV>.
a1052 3
#define SvIV_nomg(sv) (SvIOK(sv) ? SvIVX(sv) : sv_2iv_flags(sv, 0))
#define SvUV_nomg(sv) (SvIOK(sv) ? SvUVX(sv) : sv_2uv_flags(sv, 0))

d1164 1
a1164 1
	      (nxpv->xpv_cur && *(sv)->sv_u.svu_pv != '0')); })	\
d1177 12
d1192 11
a1202 11
#  define SvIVx(sv) ((PL_Sv = (sv)), SvIV(PL_Sv))
#  define SvUVx(sv) ((PL_Sv = (sv)), SvUV(PL_Sv))
#  define SvNVx(sv) ((PL_Sv = (sv)), SvNV(PL_Sv))
#  define SvPVx(sv, lp) ((PL_Sv = (sv)), SvPV(PL_Sv, lp))
#  define SvPVx_const(sv, lp) ((PL_Sv = (sv)), SvPV_const(PL_Sv, lp))
#  define SvPVx_nolen(sv) ((PL_Sv = (sv)), SvPV_nolen(PL_Sv))
#  define SvPVx_nolen_const(sv) ((PL_Sv = (sv)), SvPV_nolen_const(PL_Sv))
#  define SvPVutf8x(sv, lp) ((PL_Sv = (sv)), SvPVutf8(PL_Sv, lp))
#  define SvPVbytex(sv, lp) ((PL_Sv = (sv)), SvPVbyte(PL_Sv, lp))
#  define SvPVbytex_nolen(sv) ((PL_Sv = (sv)), SvPVbyte_nolen(PL_Sv))
#  define SvTRUE(sv) (						\
d1206 1
a1206 1
	?   ((PL_Xpv = (XPV*)SvANY(PL_Sv = (sv))) &&		\
d1208 1
a1208 1
	      (PL_Xpv->xpv_cur && *PL_Sv->sv_u.svu_pv != '0'))	\
d1217 2
a1218 1
#  define SvTRUEx(sv) ((PL_Sv = (sv)), SvTRUE(PL_Sv))
d1225 1
a1225 3
#define SvSHARED_HEK_FROM_PV(pvx) \
	((struct hek*)(pvx - STRUCT_OFFSET(struct hek, hek_key)))
#define SvSHARED_HASH(sv) (0 + SvSHARED_HEK_FROM_PV(SvPVX_const(sv))->hek_hash)
d1230 1
a1230 1
#define SV_COW_DROP_PV		4
a1234 50
#define SV_SMAGIC		128
#define SV_HAS_TRAILING_NUL	256
#define SV_COW_SHARED_HASH_KEYS	512
/* This one is only enabled for PERL_OLD_COPY_ON_WRITE */
#define SV_COW_OTHER_PVS	1024

/* The core is safe for this COW optimisation. XS code on CPAN may not be.
   So only default to doing the COW setup if we're in the core.
 */
#ifdef PERL_CORE
#  ifndef SV_DO_COW_SVSETSV
#    define SV_DO_COW_SVSETSV	SV_COW_SHARED_HASH_KEYS|SV_COW_OTHER_PVS
#  endif
#endif

#ifndef SV_DO_COW_SVSETSV
#  define SV_DO_COW_SVSETSV	0
#endif


#define sv_unref(sv)    	sv_unref_flags(sv, 0)
#define sv_force_normal(sv)	sv_force_normal_flags(sv, 0)
#define sv_usepvn(sv, p, l)	sv_usepvn_flags(sv, p, l, 0)
#define sv_usepvn_mg(sv, p, l)	sv_usepvn_flags(sv, p, l, SV_SMAGIC)

/* We are about to replace the SV's current value. So if it's copy on write
   we need to normalise it. Use the SV_COW_DROP_PV flag hint to say that
   the value is about to get thrown away, so drop the PV rather than go to
   the effort of making a read-write copy only for it to get immediately
   discarded.  */

#define SV_CHECK_THINKFIRST_COW_DROP(sv) if (SvTHINKFIRST(sv)) \
				    sv_force_normal_flags(sv, SV_COW_DROP_PV)

#ifdef PERL_OLD_COPY_ON_WRITE
#define SvRELEASE_IVX(sv)   \
    ((SvIsCOW(sv) ? sv_force_normal_flags(sv, 0) : (void) 0), SvOOK_off(sv))
#  define SvIsCOW_normal(sv)	(SvIsCOW(sv) && SvLEN(sv))
#else
#  define SvRELEASE_IVX(sv)   SvOOK_off(sv)
#endif /* PERL_OLD_COPY_ON_WRITE */

#define CAN_COW_MASK	(SVs_OBJECT|SVs_GMG|SVs_SMG|SVs_RMG|SVf_IOK|SVf_NOK| \
			 SVf_POK|SVf_ROK|SVp_IOK|SVp_NOK|SVp_POK|SVf_FAKE| \
			 SVf_OOK|SVf_BREAK|SVf_READONLY)
#define CAN_COW_FLAGS	(SVp_POK|SVf_POK)

#define SV_CHECK_THINKFIRST(sv) if (SvTHINKFIRST(sv)) \
				    sv_force_normal_flags(sv, 0)

d1245 2
a1246 3
#define sv_setsv(dsv, ssv) \
	sv_setsv_flags(dsv, ssv, SV_GMAGIC|SV_DO_COW_SVSETSV)
#define sv_setsv_nomg(dsv, ssv) sv_setsv_flags(dsv, ssv, SV_DO_COW_SVSETSV)
a1248 1
#define sv_catsv_mg(dsv, ssv) sv_catsv_flags(dsv, ssv, SV_GMAGIC|SV_SMAGIC)
a1249 2
#define sv_catpvn_mg(sv, sstr, slen) \
	sv_catpvn_flags(sv, sstr, slen, SV_GMAGIC|SV_SMAGIC);
a1250 3
#define sv_2pv_nolen(sv) sv_2pv(sv, 0)
#define sv_2pvbyte_nolen(sv) sv_2pvbyte(sv, 0)
#define sv_2pvutf8_nolen(sv) sv_2pvutf8(sv, 0)
a1253 2
#define sv_2iv(sv) sv_2iv_flags(sv, SV_GMAGIC)
#define sv_2uv(sv) sv_2uv_flags(sv, SV_GMAGIC)
a1330 1
#define SvDESTROYABLE(sv) CALL_FPTR(PL_destroyhook)(aTHX_ sv)
d1345 1
a1345 1
		sv_setsv_flags(dst, src, SV_GMAGIC | SV_NOSTEAL | SV_DO_COW_SVSETSV);	\
a1371 18
/* If I give every macro argument a different name, then there won't be bugs
   where nested macros get confused. Been there, done that.  */
#define isGV_with_GP(pwadak) \
	(((SvFLAGS(pwadak) & (SVp_POK|SVpgv_GP)) == SVpgv_GP)	\
	&& (SvTYPE(pwadak) == SVt_PVGV || SvTYPE(pwadak) == SVt_PVLV))
#define isGV_with_GP_on(sv)	STMT_START {			       \
	assert (SvTYPE(sv) == SVt_PVGV || SvTYPE(sv) == SVt_PVLV); \
	assert (!SvPOKp(sv));					       \
	assert (!SvIOKp(sv));					       \
	(SvFLAGS(sv) |= SVpgv_GP);				       \
    } STMT_END
#define isGV_with_GP_off(sv)	STMT_START {			       \
	assert (SvTYPE(sv) == SVt_PVGV || SvTYPE(sv) == SVt_PVLV); \
	assert (!SvPOKp(sv));					       \
	assert (!SvIOKp(sv));					       \
	(SvFLAGS(sv) &= ~SVpgv_GP);				       \
    } STMT_END

d1389 1
a1389 9
/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 noet:
 */
@


1.1.1.12
log
@import perl 5.10.1
@
text
@d3 2
a4 2
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
 *    2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 by Larry Wall and others
d116 4
a119 5
    PERL_BITFIELD32 sv_debug_optype:9;	/* the type of OP that allocated us */
    PERL_BITFIELD32 sv_debug_inpad:1;	/* was allocated in a pad for an OP */
    PERL_BITFIELD32 sv_debug_cloned:1;	/* was cloned for an ithread */
    PERL_BITFIELD32 sv_debug_line:16;	/* the line where we were allocated */
    U32		sv_debug_serial;	/* serial number of sv allocation   */
d218 1
a218 1
	SV * const _sv = MUTABLE_SV(sv);	\
d227 1
a227 1
	MUTABLE_SV(sv);				\
d231 1
a231 1
	SV * const _sv = MUTABLE_SV(sv);	\
d237 1
a237 1
	SV * const _sv = MUTABLE_SV(sv);	\
d243 1
a243 1
	((PL_Sv=MUTABLE_SV(sv)) ? (++(SvREFCNT(PL_Sv)),PL_Sv) : NULL)
d245 1
a245 1
	((sv) ? (SvREFCNT(sv)++,MUTABLE_SV(sv)) : NULL)
d247 1
a247 1
	(PL_Sv=MUTABLE_SV(sv),++(SvREFCNT(PL_Sv)),PL_Sv)
d249 1
a249 1
	(void)((PL_Sv=MUTABLE_SV(sv)) ? ++(SvREFCNT(PL_Sv)) : 0)
d254 3
a256 3
#define SvREFCNT_inc_simple_NN(sv)	(++(SvREFCNT(sv)),MUTABLE_SV(sv))
#define SvREFCNT_inc_void_NN(sv)	(void)(++SvREFCNT(MUTABLE_SV(sv)))
#define SvREFCNT_inc_simple_void_NN(sv)	(void)(++SvREFCNT(MUTABLE_SV(sv)))
d261 1
a261 1
	SV * const _sv = MUTABLE_SV(sv);	\
d272 1
a272 1
#define SvREFCNT_dec(sv)	sv_free(MUTABLE_SV(sv))
d333 1
a333 3
				       SVs in final arena cleanup.
				       Set in S_regtry on PL_reg_curpm, so that
				       perl_destruct will skip it. */
d771 1
a771 1
double.  Checks the B<private> setting.  Use C<SvNIOK> instead.
d777 2
a778 2
Returns a U32 value indicating whether the value is defined. This is
only meaningful for scalars.
d782 1
a782 1
the B<private> setting.  Use C<SvIOK> instead.
d786 1
a786 1
B<private> setting.  Use C<SvNOK> instead.
d790 1
a790 1
Checks the B<private> setting.  Use C<SvPOK> instead.
d1078 1
a1078 1
=for apidoc Am|U32|SvGAMAGIC|SV* sv
d1141 4
a1144 4
#  define SvVALID(sv)		({ const SV *const _svvalid = (const SV*)(sv); \
				   if (SvFLAGS(_svvalid) & SVpbm_VALID)	\
				       assert(!isGV_with_GP(_svvalid));	\
				   (SvFLAGS(_svvalid) & SVpbm_VALID);	\
d1146 3
a1148 3
#  define SvVALID_on(sv)	({ SV *const _svvalid = MUTABLE_SV(sv);	\
				   assert(!isGV_with_GP(_svvalid));	\
				   (SvFLAGS(_svvalid) |= SVpbm_VALID);	\
d1150 3
a1152 3
#  define SvVALID_off(sv)	({ SV *const _svvalid = MUTABLE_SV(sv);	\
				   assert(!isGV_with_GP(_svvalid));	\
				   (SvFLAGS(_svvalid) &= ~SVpbm_VALID);	\
d1155 3
a1157 3
#  define SvTAIL(sv)	({ const SV *const _svtail = (const SV *)(sv);	\
			    assert(SvTYPE(_svtail) != SVt_PVAV);		\
			    assert(SvTYPE(_svtail) != SVt_PVHV);		\
d1192 3
a1194 3
	    SV *const _svpad = MUTABLE_SV(sv);				\
	    assert(SvTYPE(_svpad) == SVt_PVMG);				\
	    (SvFLAGS(_svpad) |= SVpad_NAME|SVpad_TYPED);		\
d1197 3
a1199 3
	    SV *const _svpad = MUTABLE_SV(sv);				\
	    assert(SvTYPE(_svpad) == SVt_PVMG);				\
	    (SvFLAGS(_svpad) |= SVpad_NAME|SVpad_OUR);			\
d1202 3
a1204 3
	    SV *const _svpad = MUTABLE_SV(sv);				\
	    assert(SvTYPE(_svpad) == SVt_PVNV || SvTYPE(_svpad) == SVt_PVMG); \
	    (SvFLAGS(_svpad) |= SVpad_NAME|SVpad_STATE);		\
a1231 1
#  define SvRV_const(sv) (0 + (sv)->sv_u.svu_rv)
d1256 6
a1261 6
	(*({ SV *const _svpvx = MUTABLE_SV(sv);				\
	    assert(SvTYPE(_svpvx) >= SVt_PV);				\
	    assert(SvTYPE(_svpvx) != SVt_PVAV);				\
	    assert(SvTYPE(_svpvx) != SVt_PVHV);				\
	    assert(!isGV_with_GP(_svpvx));				\
	    &((_svpvx)->sv_u.svu_pv);					\
d1264 6
a1269 6
	(*({ const SV *const _svcur = (const SV *)(sv);			\
	    assert(SvTYPE(_svcur) >= SVt_PV);				\
	    assert(SvTYPE(_svcur) != SVt_PVAV);				\
	    assert(SvTYPE(_svcur) != SVt_PVHV);				\
	    assert(!isGV_with_GP(_svcur));				\
	    &(((XPV*) MUTABLE_PTR(SvANY(_svcur)))->xpv_cur);		\
d1272 7
a1278 7
	(*({ const SV *const _svivx = (const SV *)(sv);			\
	    assert(SvTYPE(_svivx) == SVt_IV || SvTYPE(_svivx) >= SVt_PVIV); \
	    assert(SvTYPE(_svivx) != SVt_PVAV);				\
	    assert(SvTYPE(_svivx) != SVt_PVHV);				\
	    assert(SvTYPE(_svivx) != SVt_PVCV);				\
	    assert(!isGV_with_GP(_svivx));				\
	    &(((XPVIV*) MUTABLE_PTR(SvANY(_svivx)))->xiv_iv);		\
d1281 7
a1287 7
	(*({ const SV *const _svuvx = (const SV *)(sv);			\
	    assert(SvTYPE(_svuvx) == SVt_IV || SvTYPE(_svuvx) >= SVt_PVIV); \
	    assert(SvTYPE(_svuvx) != SVt_PVAV);				\
	    assert(SvTYPE(_svuvx) != SVt_PVHV);				\
	    assert(SvTYPE(_svuvx) != SVt_PVCV);				\
	    assert(!isGV_with_GP(_svuvx));				\
	    &(((XPVUV*) MUTABLE_PTR(SvANY(_svuvx)))->xuv_uv);		\
d1290 8
a1297 8
	(*({ const SV *const _svnvx = (const SV *)(sv);			\
	    assert(SvTYPE(_svnvx) == SVt_NV || SvTYPE(_svnvx) >= SVt_PVNV); \
	    assert(SvTYPE(_svnvx) != SVt_PVAV);				\
	    assert(SvTYPE(_svnvx) != SVt_PVHV);				\
	    assert(SvTYPE(_svnvx) != SVt_PVCV);				\
	    assert(SvTYPE(_svnvx) != SVt_PVFM);				\
	    assert(!isGV_with_GP(_svnvx));				\
	    &(((XPVNV*) MUTABLE_PTR(SvANY(_svnvx)))->xnv_u.xnv_nv);	\
d1300 8
a1307 8
	(*({ SV *const _svrv = MUTABLE_SV(sv);				\
	    assert(SvTYPE(_svrv) >= SVt_RV);				\
	    assert(SvTYPE(_svrv) != SVt_PVAV);				\
	    assert(SvTYPE(_svrv) != SVt_PVHV);				\
	    assert(SvTYPE(_svrv) != SVt_PVCV);				\
	    assert(SvTYPE(_svrv) != SVt_PVFM);				\
	    assert(!isGV_with_GP(_svrv));				\
	    &((_svrv)->sv_u.svu_rv);					\
a1308 10
#    define SvRV_const(sv)						\
	({ const SV *const _svrv = (const SV *)(sv);			\
	    assert(SvTYPE(_svrv) >= SVt_RV);				\
	    assert(SvTYPE(_svrv) != SVt_PVAV);				\
	    assert(SvTYPE(_svrv) != SVt_PVHV);				\
	    assert(SvTYPE(_svrv) != SVt_PVCV);				\
	    assert(SvTYPE(_svrv) != SVt_PVFM);				\
	    assert(!isGV_with_GP(_svrv));				\
	    (_svrv)->sv_u.svu_rv;					\
	 })
d1310 5
a1314 5
	(*({ const SV *const _svmagic = (const SV *)(sv);		\
	    assert(SvTYPE(_svmagic) >= SVt_PVMG);			\
	    if(SvTYPE(_svmagic) == SVt_PVMG)				\
		assert(!SvPAD_OUR(_svmagic));				\
	    &(((XPVMG*) MUTABLE_PTR(SvANY(_svmagic)))->xmg_u.xmg_magic); \
d1317 3
a1319 3
	(*({ const SV *const _svstash = (const SV *)(sv);		\
	    assert(SvTYPE(_svstash) >= SVt_PVMG);			\
	    &(((XPVMG*) MUTABLE_PTR(SvANY(_svstash)))->xmg_stash);	\
a1327 1
#    define SvRV_const(sv) (0 + (sv)->sv_u.svu_rv)
d1413 1
a1413 1
		SvCUR_set(sv, (val) - SvPVX(sv)); } STMT_END
a1430 1
			 assert(!SvROK(sv));				\
a1438 14
#ifdef PERL_CORE
/* Code that crops up in three places to take a scalar and ready it to hold
   a reference */
#  define prepare_SV_for_RV(sv)						\
    STMT_START {							\
		    if (SvTYPE(sv) < SVt_RV)				\
			sv_upgrade(sv, SVt_RV);				\
		    else if (SvPVX_const(sv)) {				\
			SvPV_free(sv);					\
			SvLEN_set(sv, 0);				\
                        SvCUR_set(sv, 0);				\
		    }							\
		 } STMT_END
#endif
d1447 4
a1450 4
	(*({ SV *const _bmflags = MUTABLE_SV(sv);			\
		assert(SvTYPE(_bmflags) == SVt_PVGV);			\
		assert(SvVALID(_bmflags));				\
	    &(((XPVGV*) SvANY(_bmflags))->xnv_u.xbm_s.xbm_flags);	\
d1453 4
a1456 4
	(*({ SV *const _bmrare = MUTABLE_SV(sv);			\
		assert(SvTYPE(_bmrare) == SVt_PVGV);			\
		assert(SvVALID(_bmrare));				\
	    &(((XPVGV*) SvANY(_bmrare))->xnv_u.xbm_s.xbm_rare);		\
d1459 5
a1463 5
	(*({ SV *const _bmuseful = MUTABLE_SV(sv);			\
	    assert(SvTYPE(_bmuseful) == SVt_PVGV);			\
	    assert(SvVALID(_bmuseful));					\
	    assert(!SvIOK(_bmuseful));					\
	    &(((XPVGV*) SvANY(_bmuseful))->xiv_u.xivu_i32);		\
d1466 4
a1469 4
    (*({ SV *const _bmprevious = MUTABLE_SV(sv);			\
		assert(SvTYPE(_bmprevious) == SVt_PVGV);		\
		assert(SvVALID(_bmprevious));				\
	    &(((XPVGV*) SvANY(_bmprevious))->xnv_u.xbm_s.xbm_previous);	\
d1616 1
a1616 1
false.  See SvOK() for a defined/undefined test.  Does not handle 'get' magic.
a1673 4
=for apidoc Amdb|STRLEN|sv_utf8_upgrade_nomg|NN SV *sv

Like sv_utf8_upgrade, but doesn't do magic on C<sv>

d1744 1
a1744 1
    ((SvFLAGS(sv) & (SVf_POK|SVf_UTF8|SVf_THINKFIRST)) == (SVf_POK|SVf_UTF8) \
d1779 3
a1781 3
#  define SvIVx(sv) ({SV *_sv = MUTABLE_SV(sv); SvIV(_sv); })
#  define SvUVx(sv) ({SV *_sv = MUTABLE_SV(sv); SvUV(_sv); })
#  define SvNVx(sv) ({SV *_sv = MUTABLE_SV(sv); SvNV(_sv); })
a1933 3
#define sv_insert(bigstr, offset, len, little, littlelen)		\
	Perl_sv_insert_flags(aTHX_ (bigstr),(offset), (len), (little),	\
			     (littlelen), SV_GMAGIC)
d1939 1
a1939 1
		nsv = newSVpvn_flags(sstr, slen, SVs_TEMP);	\
a2086 11

/*
=for apidoc Am|SV*|newSVpvn_utf8|NULLOK const char* s|STRLEN len|U32 utf8

Creates a new SV and copies a string into it.  If utf8 is true, calls
C<SvUTF8_on> on the new SV.  Implemented as a wrapper around C<newSVpvn_flags>.

=cut
*/

#define newSVpvn_utf8(s, len, u) newSVpvn_flags((s), (len), (u) ? SVf_UTF8 : 0)
@


1.1.1.13
log
@Perl 5.12.2 from CPAN
@
text
@d51 5
a55 6
	/* RV was here, before it was merged with IV.  */
	SVt_PV,		/* 4 */
	SVt_PVIV,	/* 5 */
	SVt_PVNV,	/* 6 */
	SVt_PVMG,	/* 7 */
	SVt_REGEXP,	/* 8 */
a71 3
/* Anything wanting to create a reference from clean should ensure that it has
   a scalar of type SVt_IV now:  */
#  define SVt_RV	SVt_IV
a101 1
	char*   svu_pv;		/* pointer to malloced string */	\
d105 1
d120 1
a120 1
    U32		    sv_debug_serial;	/* serial number of sv allocation   */
a149 5
struct p5rx {
    _SV_HEAD(struct regexp*);	/* pointer to regexp body */
    _SV_HEAD_UNION;
};

d216 1
a216 1
#if defined(__GNUC__) && !defined(PERL_GCC_BRACE_GROUPS_FORBIDDEN)
d259 1
a259 1
#if defined(__GNUC__) && !defined(PERL_GCC_BRACE_GROUPS_FORBIDDEN)
d323 3
a325 1
				       4: On a pad name SV, that slot in the
d328 1
a328 1
#define SVphv_REHASH	SVf_FAKE    /* 5: On a PVHV, hash values are being
a393 18
#define _XPV_HEAD	\
    union _xnvu xnv_u;	\
    STRLEN	xpv_cur;	/* length of svu_pv as a C string */    \
    STRLEN	xpv_len 	/* allocated size */

union _xnvu {
    NV	    xnv_nv;		/* numeric value, if any */
    HV *    xgv_stash;
    struct {
	U32 xlow;
	U32 xhigh;
    }	    xpad_cop_seq;	/* used by pad.c for cop_sequence */
    struct {
	U32 xbm_previous;	/* how many characters in string before rare? */
	U8  xbm_flags;
	U8  xbm_rare;		/* rarest character in string */
    }	    xbm_s;		/* fields from PVBM */
};
d395 16
a410 8
union _xivu {
    IV	    xivu_iv;		/* integer value */
				/* xpvfm: lines */
    UV	    xivu_uv;
    void *  xivu_p1;
    I32	    xivu_i32;
    HEK *   xivu_namehek;	/* xpvlv, xpvgv: GvNAME */
    HV *    xivu_hv;		/* regexp: paren_names */
d413 4
a416 4
union _xmgu {
    MAGIC*  xmg_magic;		/* linked list of magicalness */
    HV*	    xmg_ourstash;	/* Stash for our (when SvPAD_OUR is true) */
};
d418 23
a440 2
struct xpv {
    _XPV_HEAD;
d443 11
a453 4
struct xpviv {
    _XPV_HEAD;
    union _xivu xiv_u;
};
d458 21
a478 2
    _XPV_HEAD;
    union _xivu xuv_u;
d481 1
a481 1
#define xuv_uv xuv_u.xivu_uv
d484 22
a505 2
    _XPV_HEAD;
    union _xivu xiv_u;
d508 1
a508 6
#define _XPVMG_HEAD				    \
    union _xivu xiv_u;				    \
    union _xmgu	xmg_u;				    \
    HV*		xmg_stash	/* class package */

/* This structure must match the beginning of struct xpvhv in hv.h. */
d510 27
a536 2
    _XPV_HEAD;
    _XPVMG_HEAD;
d540 27
a566 2
    _XPV_HEAD;
    _XPVMG_HEAD;
d578 28
a605 2
    _XPV_HEAD;
    _XPVMG_HEAD;
a611 19
#define _XPVCV_COMMON								\
    HV *	xcv_stash;							\
    union {									\
	OP *	xcv_start;							\
	ANY	xcv_xsubany;							\
    }		xcv_start_u;					    		\
    union {									\
	OP *	xcv_root;							\
	void	(*xcv_xsub) (pTHX_ CV*);					\
    }		xcv_root_u;							\
    GV *	xcv_gv;								\
    char *	xcv_file;							\
    AV *	xcv_padlist;							\
    CV *	xcv_outside;							\
    U32		xcv_outside_seq; /* the COP sequence (at the point of our	\
				  * compilation) in the lexically enclosing	\
				  * sub */					\
    cv_flags_t	xcv_flags

d613 46
a658 3
    _XPV_HEAD;
    _XPVMG_HEAD;
    _XPVCV_COMMON;
d661 35
a695 29
#define _XPVIO_TAIL							\
    PerlIO *	xio_ifp;	/* ifp and ofp are normally the same */	\
    PerlIO *	xio_ofp;	/* but sockets need separate streams */	\
    /* Cray addresses everything by word boundaries (64 bits) and	\
     * code and data pointers cannot be mixed (which is exactly what	\
     * Perl_filter_add() tries to do with the dirp), hence the		\
     *  following union trick (as suggested by Gurusamy Sarathy).	\
     * For further information see Geir Johansen's problem report	\
     * titled [ID 20000612.002] Perl problem on Cray system		\
     * The any pointer (known as IoANY()) will also be a good place	\
     * to hang any IO disciplines to.					\
     */									\
    union {								\
	DIR *	xiou_dirp;	/* for opendir, readdir, etc */		\
	void *	xiou_any;	/* for alignment */			\
    } xio_dirpu;							\
    /* IV xio_lines is now in IVX  $. */				\
    IV		xio_page;	/* $% */				\
    IV		xio_page_len;	/* $= */				\
    IV		xio_lines_left;	/* $- */				\
    char *	xio_top_name;	/* $^ */				\
    GV *	xio_top_gv;	/* $^ */				\
    char *	xio_fmt_name;	/* $~ */				\
    GV *	xio_fmt_gv;	/* $~ */				\
    char *	xio_bottom_name;/* $^B */				\
    GV *	xio_bottom_gv;	/* $^B */				\
    char	xio_type;						\
    U8		xio_flags

d698 55
a752 3
    _XPV_HEAD;
    _XPVMG_HEAD;
    _XPVIO_TAIL;
a753 1

d849 4
a852 6
Returns a U32 indicating whether the pointer to the string buffer is offset.
This hack is used internally to speed up removal of characters from the
beginning of a SvPV.  When SvOOK is true, then the start of the
allocated string buffer is actually C<SvOOK_offset()> bytes before SvPVX.
This offset used to be stored in SvIVX, but is now stored within the spare
part of the buffer.
d957 1
a957 1
#define SvIOKp_on(sv)		(assert_not_glob(sv) SvRELEASE_IVX_(sv)	\
d966 1
a966 1
#define SvIOK_on(sv)		(assert_not_glob(sv) SvRELEASE_IVX_(sv)	\
d1094 1
a1094 1
#define Gv_AMG(stash)           (PL_amagic_generation && Gv_AMupdate(stash, FALSE))
d1176 8
a1280 2
	    assert(SvTYPE(_svivx) != SVt_PVFM);				\
	    assert(SvTYPE(_svivx) != SVt_PVIO);				\
a1289 2
	    assert(SvTYPE(_svuvx) != SVt_PVFM);				\
	    assert(SvTYPE(_svuvx) != SVt_PVIO);				\
a1299 1
	    assert(SvTYPE(_svnvx) != SVt_PVIO);				\
d1305 1
a1305 1
	    assert(SvTYPE(_svrv) >= SVt_PV || SvTYPE(_svrv) == SVt_IV);	\
d1315 1
a1315 1
	    assert(SvTYPE(_svrv) >= SVt_PV || SvTYPE(_svrv) == SVt_IV);	\
a1384 1
		assert(SvTYPE(sv) != SVt_PVIO);		\
d1401 1
a1401 1
        STMT_START { assert(SvTYPE(sv) >=  SVt_PV || SvTYPE(sv) ==  SVt_IV); \
d1448 1
a1448 3
			     STRLEN zok; 				\
			     SvOOK_offset(sv, zok);			\
			     SvPV_set(sv, SvPVX_mutable(sv) - zok);	\
d1460 3
a1462 3
		    if (SvTYPE(sv) < SVt_PV && SvTYPE(sv) != SVt_IV)	\
			sv_upgrade(sv, SVt_IV);				\
		    else if (SvTYPE(sv) >= SVt_PV) {			\
d1509 1
a1509 1
#define FmLINES(sv)	((XPVFM*)  SvANY(sv))->xiv_u.xivu_iv
d1520 1
a1520 1
#define IoLINES(sv)	((XPVIO*)  SvANY(sv))->xiv_u.xivu_iv
a1894 6
/* Make sv_2pv_flags return NULL if something is undefined.  */
#define SV_UNDEF_RETURNS_NULL	2048
/* Tell sv_utf8_upgrade() to not check to see if an upgrade is really needed.
 * This is used when the caller has already determined it is, and avoids
 * redundant work */
#define SV_FORCE_UTF8_UPGRADE	4096
d1926 1
a1926 1
    ((SvIsCOW(sv) ? sv_force_normal_flags(sv, 0) : (void) 0), 0)
a1927 1
#  define SvRELEASE_IVX_(sv)	SvRELEASE_IVX(sv),
d1929 1
a1929 6
#  define SvRELEASE_IVX(sv)   0
/* This little game brought to you by the need to shut this warning up:
mg.c: In function `Perl_magic_get':
mg.c:1024: warning: left-hand operand of comma expression has no effect
*/
#  define SvRELEASE_IVX_(sv)  /**/
a1947 1
#define sv_utf8_upgrade_flags(sv, flags) sv_utf8_upgrade_flags_grow(sv, flags, 0)
a2134 57

/*
=for apidoc Am|void|SvOOK_offset|NN SV*sv|STRLEN len

Reads into I<len> the offset from SvPVX back to the true start of the
allocated buffer, which will be non-zero if C<sv_chop> has been used to
efficiently remove characters from start of the buffer. Implemented as a
macro, which takes the address of I<len>, which must be of type C<STRLEN>.
Evaluates I<sv> more than once. Sets I<len> to 0 if C<SvOOK(sv)> is false.

=cut
*/

#ifdef DEBUGGING
/* Does the bot know something I don't?
10:28 <@@Nicholas> metabatman
10:28 <+meta> Nicholas: crash
*/
#  define SvOOK_offset(sv, offset) STMT_START {				\
	assert(sizeof(offset) == sizeof(STRLEN));			\
	if (SvOOK(sv)) {						\
	    const U8 *crash = (U8*)SvPVX_const(sv);			\
	    offset = *--crash;						\
 	    if (!offset) {						\
		crash -= sizeof(STRLEN);				\
		Copy(crash, (U8 *)&offset, sizeof(STRLEN), U8);		\
	    }								\
	    {								\
		/* Validate the preceding buffer's sentinels to		\
		   verify that no-one is using it.  */			\
		const U8 *const bonk = (U8 *) SvPVX_const(sv) - offset;	\
		while (crash > bonk) {					\
		    --crash;						\
		    assert (*crash == (U8)PTR2UV(crash));		\
		}							\
	    }								\
	} else {							\
	    offset = 0;							\
	}								\
    } STMT_END
#else
    /* This is the same code, but avoids using any temporary variables:  */
#  define SvOOK_offset(sv, offset) STMT_START {				\
	assert(sizeof(offset) == sizeof(STRLEN));			\
	if (SvOOK(sv)) {						\
	    offset = ((U8*)SvPVX_const(sv))[-1];			\
	    if (!offset) {						\
		Copy(SvPVX_const(sv) - 1 - sizeof(STRLEN),		\
		     (U8 *)&offset, sizeof(STRLEN), U8);		\
	    }								\
	} else {							\
	    offset = 0;							\
	}								\
    } STMT_END
#endif

#define newIO()	MUTABLE_IO(newSV_type(SVt_PVIO))
@


1.1.1.14
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@a67 5
/* *** any alterations to the SV types above need to be reflected in
 * SVt_MASK and the various PL_valid_types_* tables */

#define SVt_MASK 0xf	/* smallest bitmask that covers all types */

d79 7
a85 3
   so never reaches the clause at the end that uses sv_type_details->body_size
   to determine whether to call safefree(). Hence body_size can be set
   non-zero to record the size of HEs, without fear of bogus frees.  */
a112 1
	PerlIO *svu_fp;			\
d122 1
d124 2
a125 3
    UV		    sv_debug_serial;	/* serial number of sv allocation   */
    char *	    sv_debug_file;	/* the file where we were allocated */
    SV *	    sv_debug_parent;	/* what we were cloned from (ithreads)*/
d310 4
a313 4
/*                      0x00010000  *** FREE SLOT */
#define SVs_PADTMP	0x00020000  /* in use as tmp; only if ! SVs_PADMY */
#define SVs_PADSTALE	0x00020000  /* lexical has gone out of scope;
					only valid for SVs_PADMY */
d323 1
a323 1
#define SVf_FAKE	0x01000000  /* 0: glob is just a copy
d373 2
a374 15

/* PVNV, PVMG only, and only used in pads. Should be safe to test on any scalar
   SV, as the core is careful to avoid setting both.

   SVf_POK, SVp_POK also set:
   0x00004400   Normal
   0x0000C400   Studied (SvSCREAM)
   0x40004400   FBM compiled (SvVALID)
   0x4000C400   pad name.

   0x00008000   GV with GP
   0x00008800   RV with PCS imported
*/
#define SVpad_NAME	(SVp_SCREAM|SVpbm_VALID)
				    /* This SV is a name in the PAD, so
d384 1
a384 1
/* Only used in toke.c on an SV stored in PL_lex_repl */
d388 1
d394 2
a399 2
/* pad name vars only */
#define SVpad_STATE	0x80000000  /* pad name is a "state" var */
d401 2
a402 3
#define _XPV_HEAD							\
    HV*		xmg_stash;	/* class package */			\
    union _xmgu	xmg_u;							\
d414 2
a415 1
	I32 xbm_useful;
d422 1
d424 2
d427 1
a432 1
    STRLEN  xmg_hash_index;	/* used while freeing hash entries */
a455 1
    union _xnvu xnv_u;
d458 5
d466 1
a466 2
    union _xivu xiv_u;
    union _xnvu xnv_u;
d471 2
a472 2
    union _xivu xiv_u;
    union _xnvu xnv_u;
a477 1
    char	xlv_flags;	/* 1 = negative offset  2 = negative len */
d484 1
a484 2
    union _xivu xiv_u;
    union _xnvu xnv_u;
d512 1
a513 1
    IV		xfm_lines;
d516 29
d548 2
a549 28
    union _xivu xiv_u;
    /* ifp and ofp are normally the same, but sockets need separate streams */
    PerlIO *	xio_ofp;
    /* Cray addresses everything by word boundaries (64 bits) and
     * code and data pointers cannot be mixed (which is exactly what
     * Perl_filter_add() tries to do with the dirp), hence the
     *  following union trick (as suggested by Gurusamy Sarathy).
     * For further information see Geir Johansen's problem report
     * titled [ID 20000612.002] Perl problem on Cray system
     * The any pointer (known as IoANY()) will also be a good place
     * to hang any IO disciplines to.
     */
    union {
	DIR *	xiou_dirp;	/* for opendir, readdir, etc */
	void *	xiou_any;	/* for alignment */
    } xio_dirpu;
    /* IV xio_lines is now in IVX  $. */
    IV		xio_page;	/* $% */
    IV		xio_page_len;	/* $= */
    IV		xio_lines_left;	/* $- */
    char *	xio_top_name;	/* $^ */
    GV *	xio_top_gv;	/* $^ */
    char *	xio_fmt_name;	/* $~ */
    GV *	xio_fmt_gv;	/* $~ */
    char *	xio_bottom_name;/* $^B */
    GV *	xio_bottom_gv;	/* $^B */
    char	xio_type;
    U8		xio_flags;
d561 1
a561 2
#define IOf_FAKE_DIRP	64	/* xio_dirp is fake (source filters kludge)
				   Also, when this is set, SvPVX() is valid */
d668 1
a668 1
Only use when you are sure SvIOK is true.  See also C<SvIV()>.
d672 1
a672 1
Only use when you are sure SvIOK is true.  See also C<SvUV()>.
d676 1
a676 1
Only use when you are sure SvNOK is true.  See also C<SvNV()>.
a681 3
This is also used to store the name of an autoloaded subroutine in an XS
AUTOLOAD routine.  See L<perlguts/Autoloading with XSUBs>.

d690 1
a690 3
Returns a pointer to the spot just after the last character in
the string which is in the SV, where there is usually a trailing
null (even though Perl scalars do not strictly require it).
a692 3
Warning: If C<SvCUR> is equal to C<SvLEN>, then C<SvEND> points to
unallocated memory.

d793 1
a793 2
Returns a U32 value indicating the UTF-8 status of an SV.  If things are set-up
properly, this indicates whether or not the SV contains UTF-8 encoded data.
d802 1
a802 2
Unsets the UTF-8 status of an SV (the data is not changed, just the flag).
Do not use frivolously.
d837 1
a837 1
#define SvOOK_on(sv)		(SvFLAGS(sv) |= SVf_OOK)
d883 1
a883 2
Returns true if the SV has get magic or
overloading.  If either is true then
d885 2
a886 3
time it is accessed.  Hence you must be careful to
only read it once per user logical operation and work
with that returned value.  If neither is true then
d908 8
a918 34
/* SVs_PADTMP and SVs_PADSTALE share the same bit, mediated by SVs_PADMY */

#define SvPADTMP(sv)	((SvFLAGS(sv) & (SVs_PADMY|SVs_PADTMP)) == SVs_PADTMP)
#define SvPADSTALE(sv)	((SvFLAGS(sv) & (SVs_PADMY|SVs_PADSTALE)) \
				    == (SVs_PADMY|SVs_PADSTALE))

#if defined (DEBUGGING) && defined(__GNUC__) && !defined(PERL_GCC_BRACE_GROUPS_FORBIDDEN)
#  define SvPADTMP_on(sv)	({			\
	    SV *const _svpad = MUTABLE_SV(sv);		\
	    assert(!(SvFLAGS(_svpad) & SVs_PADMY));	\
	    SvFLAGS(_svpad) |= SVs_PADTMP;		\
	})
#  define SvPADTMP_off(sv)	({			\
	    SV *const _svpad = MUTABLE_SV(sv);		\
	    assert(!(SvFLAGS(_svpad) & SVs_PADMY));	\
	    SvFLAGS(_svpad) &= ~SVs_PADTMP;		\
	})
#  define SvPADSTALE_on(sv)	({			\
	    SV *const _svpad = MUTABLE_SV(sv);		\
	    assert(SvFLAGS(_svpad) & SVs_PADMY);	\
	    SvFLAGS(_svpad) |= SVs_PADSTALE;		\
	})
#  define SvPADSTALE_off(sv)	({			\
	    SV *const _svpad = MUTABLE_SV(sv);		\
	    assert(SvFLAGS(_svpad) & SVs_PADMY);	\
	    SvFLAGS(_svpad) &= ~SVs_PADSTALE;		\
	})
#else
#  define SvPADTMP_on(sv)	(SvFLAGS(sv) |= SVs_PADTMP)
#  define SvPADTMP_off(sv)	(SvFLAGS(sv) &= ~SVs_PADTMP)
#  define SvPADSTALE_on(sv)	(SvFLAGS(sv) |= SVs_PADSTALE)
#  define SvPADSTALE_off(sv)	(SvFLAGS(sv) &= ~SVs_PADSTALE)
#endif

d935 3
a937 5
#ifndef PERL_CORE
#  define SvCOMPILED(sv)	0
#  define SvCOMPILED_on(sv)
#  define SvCOMPILED_off(sv)
#endif
d1015 3
d1053 3
a1055 1
	    assert(PL_valid_types_PVX[SvTYPE(_svpvx) & SVt_MASK]);	\
a1056 2
	    assert(!(SvTYPE(_svpvx) == SVt_PVIO				\
		     && !(IoFLAGS(_svpvx) & IOf_FAKE_DIRP)));		\
d1061 3
a1063 1
	    assert(PL_valid_types_PVX[SvTYPE(_svcur) & SVt_MASK]);	\
a1064 2
	    assert(!(SvTYPE(_svcur) == SVt_PVIO				\
		     && !(IoFLAGS(_svcur) & IOf_FAKE_DIRP)));		\
d1069 6
a1074 1
	    assert(PL_valid_types_IVX[SvTYPE(_svivx) & SVt_MASK]);	\
d1080 6
a1085 1
	    assert(PL_valid_types_IVX[SvTYPE(_svuvx) & SVt_MASK]);	\
d1091 6
a1096 1
	    assert(PL_valid_types_NVX[SvTYPE(_svnvx) & SVt_MASK]);	\
d1102 5
a1106 1
	    assert(PL_valid_types_RV[SvTYPE(_svrv) & SVt_MASK]);	\
a1107 2
	    assert(!(SvTYPE(_svrv) == SVt_PVIO				\
		     && !(IoFLAGS(_svrv) & IOf_FAKE_DIRP)));		\
d1112 5
a1116 1
	    assert(PL_valid_types_RV[SvTYPE(_svrv) & SVt_MASK]);	\
a1117 2
	    assert(!(SvTYPE(_svrv) == SVt_PVIO				\
		     && !(IoFLAGS(_svrv) & IOf_FAKE_DIRP)));		\
a1170 3
#define SvIV_please_nomg(sv) \
	STMT_START {if (!SvIOKp(sv) && (SvNOK(sv) || SvPOK(sv))) \
		(void) SvIV_nomg(sv); } STMT_END
d1172 4
a1175 2
	STMT_START { \
		assert(PL_valid_types_IV_set[SvTYPE(sv) & SVt_MASK]);	\
d1179 4
a1182 2
	STMT_START { \
		assert(PL_valid_types_NV_set[SvTYPE(sv) & SVt_MASK]);	\
d1186 3
a1188 2
	STMT_START { \
		assert(PL_valid_types_PVX[SvTYPE(sv) & SVt_MASK]);	\
a1189 2
		assert(!(SvTYPE(sv) == SVt_PVIO		\
		     && !(IoFLAGS(sv) & IOf_FAKE_DIRP))); \
d1192 4
a1195 2
	STMT_START { \
		assert(PL_valid_types_IV_set[SvTYPE(sv) & SVt_MASK]);	\
d1199 5
a1203 2
        STMT_START { \
		assert(PL_valid_types_RV[SvTYPE(sv) & SVt_MASK]);	\
a1204 2
		assert(!(SvTYPE(sv) == SVt_PVIO		\
		     && !(IoFLAGS(sv) & IOf_FAKE_DIRP))); \
d1213 3
a1215 2
	STMT_START { \
		assert(PL_valid_types_PVX[SvTYPE(sv) & SVt_MASK]);	\
a1216 2
		assert(!(SvTYPE(sv) == SVt_PVIO		\
		     && !(IoFLAGS(sv) & IOf_FAKE_DIRP))); \
d1219 3
a1221 2
	STMT_START { \
		assert(PL_valid_types_PVX[SvTYPE(sv) & SVt_MASK]);	\
a1222 2
		assert(!(SvTYPE(sv) == SVt_PVIO		\
		     && !(IoFLAGS(sv) & IOf_FAKE_DIRP))); \
d1270 1
a1270 3
#ifndef PERL_CORE
#  define BmFLAGS(sv)		(SvTAIL(sv) ? FBMcf_TAIL : 0)
#endif
d1272 3
d1276 6
d1284 1
a1284 1
		assert(SvTYPE(_bmrare) == SVt_PVMG);			\
d1286 1
a1286 1
	    &(((XPVMG*) SvANY(_bmrare))->xnv_u.xbm_s.xbm_rare);		\
d1290 1
a1290 1
	    assert(SvTYPE(_bmuseful) == SVt_PVMG);			\
d1293 1
a1293 1
	    &(((XPVMG*) SvANY(_bmuseful))->xnv_u.xbm_s.xbm_useful);	\
d1297 1
a1297 1
		assert(SvTYPE(_bmprevious) == SVt_PVMG);		\
d1299 1
a1299 1
	    &(((XPVMG*) SvANY(_bmprevious))->xiv_u.xivu_uv);		\
d1302 4
a1305 3
#  define BmRARE(sv)		((XPVMG*) SvANY(sv))->xnv_u.xbm_s.xbm_rare
#  define BmUSEFUL(sv)		((XPVMG*) SvANY(sv))->xnv_u.xbm_s.xbm_useful
#  define BmPREVIOUS(sv)	((XPVMG*) SvANY(sv))->xiv_u.xivu_uv
d1309 1
a1309 1
#define FmLINES(sv)	((XPVFM*)  SvANY(sv))->xfm_lines
a1314 1
#define LvFLAGS(sv)	((XPVLV*)  SvANY(sv))->xlv_flags
d1316 1
a1316 1
#define IoIFP(sv)	(sv)->sv_u.svu_fp
d1347 1
a1347 1
Checks to see if an SV is tainted.  Returns TRUE if it is, FALSE if
d1354 2
a1355 2
Untaints an SV.  Be I<very> careful with this routine, as it short-circuits
some of Perl's fundamental security features.  XS module authors should not
d1362 1
a1362 5
Taints an SV if tainting is enabled, and if some input to the current
expression is tainted--usually a variable, but possibly also implicit
inputs such as locale settings.  C<SvTAINT> propagates that taintedness to
the outputs of an expression in a pessimistic fashion; i.e., without paying
attention to precisely which outputs are influenced by which inputs.
d1390 1
a1390 1
directly.  Doesn't process magic.
d1395 1
a1395 1
stringified version becoming C<SvPOK>.  Handles 'get' magic.  See also
d1401 1
a1401 1
more efficient C<SvPV>.
a1410 3
=for apidoc Am|char*|SvPV_nomg_nolen|SV* sv
Like C<SvPV_nolen> but doesn't process magic.

d1412 1
a1412 1
Coerces the given SV to an integer and returns it.  See C<SvIVx> for a
d1419 2
a1420 3
Coerces the given SV to an integer and returns it.
Guarantees to evaluate C<sv> only once.  Only use
this if C<sv> is an expression with side effects,
d1424 1
a1424 1
Coerce the given SV to a double and return it.  See C<SvNVx> for a version
a1426 3
=for apidoc Am|NV|SvNV_nomg|SV* sv
Like C<SvNV> but doesn't process magic.

d1428 2
a1429 3
Coerces the given SV to a double and returns it.
Guarantees to evaluate C<sv> only once.  Only use
this if C<sv> is an expression with side effects,
d1440 2
a1441 3
Coerces the given SV to an unsigned integer and
returns it.  Guarantees to C<sv> only once.  Only
use this if C<sv> is an expression with side effects,
a1445 6
false.  See SvOK() for a defined/undefined test.  Handles 'get' magic
unless the scalar is already SvPOK, SvIOK or SvNOK (the public, not the
private flags).

=for apidoc Am|bool|SvTRUE_nomg|SV* sv
Returns a boolean indicating whether Perl would evaluate the SV as true or
d1487 1
a1487 1
Returns a boolean indicating whether the SV is Copy-On-Write (either shared
d1489 1
a1489 1
COW).
a1497 3
=for apidoc Am|void|sv_catpv_nomg|SV* sv|const char* ptr
Like C<sv_catpv> but doesn't process magic.

d1506 1
a1506 1
Like sv_utf8_upgrade, but doesn't do magic on C<sv>.
a1517 1
#define SvNV_nomg(sv) (SvNOK(sv) ? SvNVX(sv) : sv_2nv_flags(sv, 0))
a1562 4
#define SvPV_nomg_nolen(sv) \
    ((SvFLAGS(sv) & (SVf_POK)) == SVf_POK \
     ? SvPVX(sv) : sv_2pv_flags(sv, 0, 0))

a1638 16
#  define SvTRUE_nomg(sv) (					\
    !sv								\
    ? 0								\
    :    SvPOK(sv)						\
	?   (({XPV *nxpv = (XPV*)SvANY(sv);			\
	     nxpv &&						\
	     (nxpv->xpv_cur > 1 ||				\
	      (nxpv->xpv_cur && *(sv)->sv_u.svu_pv != '0')); })	\
	     ? 1						\
	     : 0)						\
	:							\
	    SvIOK(sv)						\
	    ? SvIVX(sv) != 0					\
	    :   SvNOK(sv)					\
		? SvNVX(sv) != 0.0				\
		: sv_2bool_flags(sv,0) )
a1670 15
#  define SvTRUE_nomg(sv) (					\
    !sv								\
    ? 0								\
    :    SvPOK(sv)						\
	?   ((PL_Xpv = (XPV*)SvANY(PL_Sv = (sv))) &&		\
	     (PL_Xpv->xpv_cur > 1 ||				\
	      (PL_Xpv->xpv_cur && *PL_Sv->sv_u.svu_pv != '0'))	\
	     ? 1						\
	     : 0)						\
	:							\
	    SvIOK(sv)						\
	    ? SvIVX(sv) != 0					\
	    :   SvNOK(sv)					\
		? SvNVX(sv) != 0.0				\
		: sv_2bool_flags(sv,0) )
d1674 2
a1675 3
#define SvIsCOW(sv)	((SvFLAGS(sv) & (SVf_FAKE | SVf_READONLY)) == \
			   (SVf_FAKE | SVf_READONLY) && !isGV_with_GP(sv) \
			   && SvTYPE(sv) != SVt_REGEXP)
a1700 9
/* if (after resolving magic etc), the SV is found to be overloaded,
 * don't call the overload magic, just return as-is */
#define SV_SKIP_OVERLOAD	8192
/* It is not yet clear whether we want this as an API, or what the
 * constants should be named. */
#ifdef PERL_CORE
# define SV_CATBYTES		16384
# define SV_CATUTF8		32768
#endif
d1738 1
a1738 1
mg.c: In function 'Perl_magic_get':
a1762 1
#define sv_catpv_nomg(dsv, sstr) sv_catpv_flags(dsv, sstr, 0)
a1780 6
#define sv_2nv(sv) sv_2nv_flags(sv, SV_GMAGIC)
#define sv_eq(sv1, sv2) sv_eq_flags(sv1, sv2, SV_GMAGIC)
#define sv_cmp(sv1, sv2) sv_cmp_flags(sv1, sv2, SV_GMAGIC)
#define sv_cmp_locale(sv1, sv2) sv_cmp_locale_flags(sv1, sv2, SV_GMAGIC)
#define sv_collxfrm(sv, nxp) sv_cmp_flags(sv, nxp, SV_GMAGIC)
#define sv_2bool(sv) sv_2bool_flags(sv, SV_GMAGIC)
d1827 1
a1827 1
ssv.  May evaluate arguments more than once.
d1858 4
a1861 4
#define SvSHARE(sv) PL_sharehook(aTHX_ sv)
#define SvLOCK(sv) PL_lockhook(aTHX_ sv)
#define SvUNLOCK(sv) PL_unlockhook(aTHX_ sv)
#define SvDESTROYABLE(sv) PL_destroyhook(aTHX_ sv)
d1863 1
a1863 1
#define SvGETMAGIC(x) ((void)(SvGMAGICAL(x) && mg_get(x)))
a1899 10
/*
=for apidoc Am|SV *|boolSV|bool b

Returns a true SV if C<b> is a true value, or a false SV if C<b> is 0.

See also C<PL_sv_yes> and C<PL_sv_no>.

=cut
*/

a1935 2
  PerlInterpreter *new_perl;
  AV *unreferenced;
d1954 1
a1954 1
efficiently remove characters from start of the buffer.  Implemented as a
d1956 1
a1956 1
Evaluates I<sv> more than once.  Sets I<len> to 0 if C<SvOOK(sv)> is false.
@


1.1.1.15
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d22 2
a23 53
The types are:

    SVt_NULL
    SVt_BIND (unused)
    SVt_IV
    SVt_NV
    SVt_RV
    SVt_PV
    SVt_PVIV
    SVt_PVNV
    SVt_PVMG
    SVt_REGEXP
    SVt_PVGV
    SVt_PVLV
    SVt_PVAV
    SVt_PVHV
    SVt_PVCV
    SVt_PVFM
    SVt_PVIO

These are most easily explained from the bottom up.

SVt_PVIO is for I/O objects, SVt_PVFM for formats, SVt_PVCV for
subroutines, SVt_PVHV for hashes and SVt_PVAV for arrays.

All the others are scalar types, that is, things that can be bound to a
C<$> variable.  For these, the internal types are mostly orthogonal to
types in the Perl language.

Hence, checking C<< SvTYPE(sv) < SVt_PVAV >> is the best way to see whether
something is a scalar.

SVt_PVGV represents a typeglob.  If !SvFAKE(sv), then it is a real,
incoercible typeglob.  If SvFAKE(sv), then it is a scalar to which a
typeglob has been assigned.  Assigning to it again will stop it from being
a typeglob.  SVt_PVLV represents a scalar that delegates to another scalar
behind the scenes.  It is used, e.g., for the return value of C<substr> and
for tied hash and array elements.  It can hold any scalar value, including
a typeglob. SVt_REGEXP is for regular expressions.

SVt_PVMG represents a "normal" scalar (not a typeglob, regular expression,
or delegate).  Since most scalars do not need all the internal fields of a
PVMG, we save memory by allocating smaller structs when possible.  All the
other types are just simpler forms of SVt_PVMG, with fewer internal fields.
 SVt_NULL can only hold undef.  SVt_IV can hold undef, an integer, or a
reference.  (SVt_RV is an alias for SVt_IV, which exists for backward
compatibility.)  SVt_NV can hold any of those or a double.  SVt_PV can only
hold undef or a string.  SVt_PVIV is a superset of SVt_PV and SVt_IV.
SVt_PVNV is similar.  SVt_PVMG can hold anything SVt_PVNV can hold, but it
can, but does not have to, be blessed or magical.

=for apidoc AmU||SVt_NULL
Type flag for scalars.  See L</svtype>.
d26 1
a26 1
Type flag for scalars.  See L</svtype>.
d29 1
a29 10
Type flag for scalars.  See L</svtype>.

=for apidoc AmU||SVt_PV
Type flag for scalars.  See L</svtype>.

=for apidoc AmU||SVt_PVIV
Type flag for scalars.  See L</svtype>.

=for apidoc AmU||SVt_PVNV
Type flag for scalars.  See L</svtype>.
d32 1
a32 10
Type flag for scalars.  See L</svtype>.

=for apidoc AmU||SVt_REGEXP
Type flag for regular expressions.  See L</svtype>.

=for apidoc AmU||SVt_PVGV
Type flag for typeglobs.  See L</svtype>.

=for apidoc AmU||SVt_PVLV
Type flag for scalars.  See L</svtype>.
d35 1
a35 1
Type flag for arrays.  See L</svtype>.
d38 1
a38 1
Type flag for hashes.  See L</svtype>.
d41 1
a41 7
Type flag for subroutines.  See L</svtype>.

=for apidoc AmU||SVt_PVFM
Type flag for formats.  See L</svtype>.

=for apidoc AmU||SVt_PVIO
Type flag for I/O objects.  See L</svtype>.
a110 1
	struct regexp* svu_rx;		\
d171 1
a171 1
Increments the reference count of the given SV, returning the SV.
d211 1
a211 6
Decrements the reference count of the given SV. I<sv> may be NULL.

=for apidoc Am|void|SvREFCNT_dec_NN|SV* sv
Same as SvREFCNT_dec, but can only be used if you know I<sv>
is not NULL.  Since we don't have to check the NULLness, it's faster
and smaller.
d227 36
a262 4
#define SvREFCNT_inc(sv)		S_SvREFCNT_inc(MUTABLE_SV(sv))
#define SvREFCNT_inc_simple(sv)		SvREFCNT_inc(sv)
#define SvREFCNT_inc_NN(sv)		S_SvREFCNT_inc_NN(MUTABLE_SV(sv))
#define SvREFCNT_inc_void(sv)		S_SvREFCNT_inc_void(MUTABLE_SV(sv))
d270 16
a285 2
#define SvREFCNT_dec(sv)	S_SvREFCNT_dec(aTHX_ MUTABLE_SV(sv))
#define SvREFCNT_dec_NN(sv)	S_SvREFCNT_dec_NN(aTHX_ MUTABLE_SV(sv))
d295 1
a295 4
/* this is defined in this peculiar way to avoid compiler warnings.
 * See the <20121213131428.GD1842@@iabyn.com> thread in p5p */
#define SvUPGRADE(sv, mt) \
    ((void)(SvTYPE(sv) >= (mt) || (sv_upgrade(sv, mt),1)))
d305 1
a305 1
#define SVp_SCREAM	0x00008000  /* method name is DOES */
d310 1
a310 1
				       GvIMPORTED_CV_on() if it needs to be
d312 1
a312 2
#define SVf_IsCOW	0x00010000  /* copy on write (shared hash key if
				       SvLEN == 0) */
d327 5
a331 1
				       2: For PVCV, whether CvUNIQUE(cv)
d334 1
a334 1
				       3: On a pad name SV, that slot in the
d337 2
d351 1
a351 1
#define SVf_THINKFIRST	(SVf_READONLY|SVf_ROK|SVf_FAKE|SVs_RMG|SVf_IsCOW)
d381 1
a381 1
   0x0000C400   method name for DOES (SvSCREAM)
d419 1
a419 6
    union {								\
	STRLEN	xpvlenu_len; 	/* allocated size */			\
	char *	xpvlenu_pv;	/* regexp string */			\
    } xpv_len_u	

#define xpv_len	xpv_len_u.xpvlenu_len
d497 2
d511 1
a511 4
    union {								\
	GV *	xcv_gv;							\
	HEK *	xcv_hek;						\
    }		xcv_gv_u;						\
d513 1
a513 1
    PADLIST *	xcv_padlist;							\
d518 1
a518 4
    cv_flags_t	xcv_flags;						\
    I32	xcv_depth	/* >= 2 indicates recursive call */

/* This structure must match XPVCV in cv.h */
d523 1
d614 1
a614 1
Tells an SV that it is an unsigned integer and disables all other OK bits.
d617 1
a617 3
Returns a boolean indicating whether the SV contains an integer that must be
interpreted as unsigned.  A non-negative integer whose value is within the
range of both an IV and a UV may be be flagged as either SvUOK or SVIOK.
d620 1
a620 3
Returns a boolean indicating whether the SV contains an integer that must be
interpreted as unsigned.  A non-negative integer whose value is within the
range of both an IV and a UV may be be flagged as either SvUOK or SVIOK.
d688 1
a688 2
string. Prior to 5.9.3 it is not safe to execute this macro unless the SV's
type >= SVt_PV.
d722 1
a722 6
Set the value of the PV pointer in sv to val.  See also C<SvIV_set>.

Beware that the existing pointer may be involved in copy-on-write or other
mischief, so do C<SvOOK_off(sv)> and use C<sv_force_normal> or
C<SvPV_force> (or check the SvIsCOW flag) first to make sure this
modification is safe.
d751 7
a757 2
#define assert_not_ROK(sv)	assert_(!SvROK(sv) || !SvRV(sv))
#define assert_not_glob(sv)	assert_(!isGV_with_GP(sv))
d759 3
a761 1
#define SvOK(sv)		(SvFLAGS(sv) & SVf_OK || isREGEXP(sv))
d811 2
a812 2
You should use this I<after> a call to SvPV() or one of its variants, in
case any call to string overloading updates the internal flag.
d882 15
a896 33
#define SvAMAGIC(sv)		(SvROK(sv) && SvOBJECT(SvRV(sv)) &&	\
				 HvAMAGIC(SvSTASH(SvRV(sv))))

/* To be used on the stashes themselves: */
#define HvAMAGIC(hv)		(SvFLAGS(hv) & SVf_AMAGIC)
#define HvAMAGIC_on(hv)		(SvFLAGS(hv) |= SVf_AMAGIC)
#define HvAMAGIC_off(hv)	(SvFLAGS(hv) &=~ SVf_AMAGIC)


#define SvPOK_nog(sv)		((SvFLAGS(sv) & (SVf_POK|SVs_GMG)) == SVf_POK)
#define SvIOK_nog(sv)		((SvFLAGS(sv) & (SVf_IOK|SVs_GMG)) == SVf_IOK)
#define SvUOK_nog(sv)		((SvFLAGS(sv) & (SVf_IOK|SVf_IVisUV|SVs_GMG)) == (SVf_IOK|SVf_IVisUV))
#define SvNOK_nog(sv)		((SvFLAGS(sv) & (SVf_NOK|SVs_GMG)) == SVf_NOK)
#define SvNIOK_nog(sv)		(SvNIOK(sv) && !(SvFLAGS(sv) & SVs_GMG))

#define SvPOK_nogthink(sv)	((SvFLAGS(sv) & (SVf_POK|SVf_THINKFIRST|SVs_GMG)) == SVf_POK)
#define SvIOK_nogthink(sv)	((SvFLAGS(sv) & (SVf_IOK|SVf_THINKFIRST|SVs_GMG)) == SVf_IOK)
#define SvUOK_nogthink(sv)	((SvFLAGS(sv) & (SVf_IOK|SVf_IVisUV|SVf_THINKFIRST|SVs_GMG)) == (SVf_IOK|SVf_IVisUV))
#define SvNOK_nogthink(sv)	((SvFLAGS(sv) & (SVf_NOK|SVf_THINKFIRST|SVs_GMG)) == SVf_NOK)
#define SvNIOK_nogthink(sv)	(SvNIOK(sv) && !(SvFLAGS(sv) & (SVf_THINKFIRST|SVs_GMG)))

#define SvPOK_utf8_nog(sv)	((SvFLAGS(sv) & (SVf_POK|SVf_UTF8|SVs_GMG)) == (SVf_POK|SVf_UTF8))
#define SvPOK_utf8_nogthink(sv)	((SvFLAGS(sv) & (SVf_POK|SVf_UTF8|SVf_THINKFIRST|SVs_GMG)) == (SVf_POK|SVf_UTF8))

#define SvPOK_byte_nog(sv)	((SvFLAGS(sv) & (SVf_POK|SVf_UTF8|SVs_GMG)) == SVf_POK)
#define SvPOK_byte_nogthink(sv)	((SvFLAGS(sv) & (SVf_POK|SVf_UTF8|SVf_THINKFIRST|SVs_GMG)) == SVf_POK)

#define SvPOK_pure_nogthink(sv) \
    ((SvFLAGS(sv) & (SVf_POK|SVf_IOK|SVf_NOK|SVf_ROK|SVpgv_GP|SVf_THINKFIRST|SVs_GMG)) == SVf_POK)
#define SvPOK_utf8_pure_nogthink(sv) \
    ((SvFLAGS(sv) & (SVf_POK|SVf_UTF8|SVf_IOK|SVf_NOK|SVf_ROK|SVpgv_GP|SVf_THINKFIRST|SVs_GMG)) == (SVf_POK|SVf_UTF8))
#define SvPOK_byte_pure_nogthink(sv) \
    ((SvFLAGS(sv) & (SVf_POK|SVf_UTF8|SVf_IOK|SVf_NOK|SVf_ROK|SVpgv_GP|SVf_THINKFIRST|SVs_GMG)) == SVf_POK)
d914 1
a914 4
#define Gv_AMG(stash) \
	(HvNAME(stash) && Gv_AMupdate(stash,FALSE) \
	    ? 1					    \
	    : (HvAMAGIC_off(stash), 0))
a925 24
/*
=for apidoc m|U32|SvTHINKFIRST|SV *sv

A quick flag check to see whether an sv should be passed to sv_force_normal
to be "downgraded" before SvIVX or SvPVX can be modified directly.

For example, if your scalar is a reference and you want to modify the SvIVX
slot, you can't just do SvROK_off, as that will leak the referent.

This is used internally by various sv-modifying functions, such as
sv_setsv, sv_setiv and sv_pvn_force.

One case that this does not handle is a gv without SvFAKE set.  After

    if (SvTHINKFIRST(gv)) sv_force_normal(gv);

it will still be a gv.

SvTHINKFIRST sometimes produces false positives.  In those cases
sv_force_normal does nothing.

=cut
*/

d937 27
a963 4
#define SvPADTMP_on(sv)		S_SvPADTMP_on(MUTABLE_SV(sv))
#define SvPADTMP_off(sv)	S_SvPADTMP_off(MUTABLE_SV(sv))
#define SvPADSTALE_on(sv)	S_SvPADSTALE_on(MUTABLE_SV(sv))
#define SvPADSTALE_off(sv)	S_SvPADSTALE_off(MUTABLE_SV(sv))
d1075 1
a1075 1
#    define SvPVX(sv) (0 + (assert_(!SvREADONLY(sv)) (sv)->sv_u.svu_pv))
d1083 7
a1089 2
#  define SvMAGIC(sv)	(0 + *(assert_(SvTYPE(sv) >= SVt_PVMG) &((XPVMG*)  SvANY(sv))->xmg_u.xmg_magic))
#  define SvSTASH(sv)	(0 + *(assert_(SvTYPE(sv) >= SVt_PVMG) &((XPVMG*)  SvANY(sv))->xmg_stash))
d1106 1
a1106 2
	    assert(PL_valid_types_PVX[SvTYPE(_svcur) & SVt_MASK]	\
		|| SvTYPE(_svcur) == SVt_REGEXP);			\
d1198 2
a1199 3
	(!SvIOKp(sv) && (SvNOK(sv) || SvPOK(sv)) \
	    ? (SvIV_nomg(sv), SvIOK(sv))	  \
	    : SvIOK(sv))
d1237 1
a1237 2
		assert(PL_valid_types_PVX[SvTYPE(sv) & SVt_MASK]	\
			|| SvTYPE(sv) == SVt_REGEXP);	\
d1326 1
a1326 1
#define FmLINES(sv)	((XPVIV*)  SvANY(sv))->xiv_iv
d1391 3
a1393 7
#if NO_TAINT_SUPPORT
#   define SvTAINTED(sv) 0
#else
#   define SvTAINTED(sv)	  (SvMAGICAL(sv) && sv_tainted(sv))
#endif
#define SvTAINTED_on(sv)  STMT_START{ if(TAINTING_get){sv_taint(sv);}   }STMT_END
#define SvTAINTED_off(sv) STMT_START{ if(TAINTING_get){sv_untaint(sv);} }STMT_END
d1397 2
a1398 2
	if (TAINTING_get) {		\
	    if (TAINT_get)		\
d1405 3
a1407 9
Like C<SvPV> but will force the SV into containing a string (C<SvPOK>), and
only a string (C<SvPOK_only>), by hook or by crook.  You need force if you are
going to update the C<SvPVX> directly.  Processes get magic.

Note that coercing an arbitrary scalar into a plain PV will potentially
strip useful data from it. For example if the SV was C<SvROK>, then the
referent will have its reference count decremented, and the SV itself may
be converted to an C<SvPOK> scalar with a string buffer containing a value
such as C<"ARRAY(0x1234)">.
d1410 3
a1412 1
Like C<SvPV_force>, but doesn't process get magic.
a1419 9
Note that there is no guarantee that the return value of C<SvPV()> is
equal to C<SvPVX(sv)>, or that C<SvPVX(sv)> contains valid data, or that
successive calls to C<SvPV(sv)) will return the same pointer value each
time. This is due to the way that things like overloading and
Copy-On-Write are handled.  In these cases, the return value may point to
a temporary buffer or similar.  If you absolutely need the SvPVX field to
be valid (for example, if you intend to write to it), then see
L</SvPV_force>.

d1429 3
a1431 1
Like C<SvPV> but doesn't set a length variable.
d1471 1
a1471 1
returns it.  Guarantees to evaluate C<sv> only once.  Only
d1552 3
a1554 3
#define SvIV(sv) (SvIOK_nog(sv) ? SvIVX(sv) : sv_2iv(sv))
#define SvUV(sv) (SvUOK_nog(sv) ? SvUVX(sv) : sv_2uv(sv))
#define SvNV(sv) (SvNOK_nog(sv) ? SvNVX(sv) : sv_2nv(sv))
d1562 2
a1563 2
#define SvPV(sv, lp)         SvPV_flags(sv, lp, SV_GMAGIC)
#define SvPV_const(sv, lp)   SvPV_flags_const(sv, lp, SV_GMAGIC)
d1567 1
a1567 1
    (SvPOK_nog(sv) \
d1570 1
a1570 1
    (SvPOK_nog(sv) \
d1574 1
a1574 1
    (SvPOK_nog(sv) \
d1578 1
a1578 1
    (SvPOK_nog(sv) \
d1590 2
a1591 3
    (SvPOK_pure_nogthink(sv) \
     ? ((lp = SvCUR(sv)), SvPVX(sv)) : sv_pvn_force_flags(sv, &lp, flags))

d1593 2
a1594 3
    (SvPOK_pure_nogthink(sv) \
     ? SvPVX(sv) : sv_pvn_force_flags(sv, 0, flags))

d1596 2
a1597 2
    (SvPOK_pure_nogthink(sv) \
     ? ((lp = SvCUR(sv)), SvPVX_mutable(sv)) \
d1601 1
a1601 1
    (SvPOK_nog(sv) \
d1605 1
a1605 1
    (SvPOK_nog(sv) \
d1609 1
a1609 1
    (SvPOK_nog(sv) \
d1619 1
a1619 1
    (SvPOK_utf8_nog(sv) \
d1623 1
a1623 1
    (SvPOK_utf8_pure_nogthink(sv) \
d1626 1
d1628 1
a1628 1
    (SvPOK_utf8_nog(sv) \
d1634 1
a1634 1
    (SvPOK_byte_nog(sv) \
d1638 1
a1638 1
    (SvPOK_byte_pure_nogthink(sv) \
d1642 1
a1642 1
    (SvPOK_byte_nog(sv) \
d1645 1
a1655 14
#define SvTRUE(sv)        ((sv) && (SvGMAGICAL(sv) ? sv_2bool(sv) : SvTRUE_common(sv, sv_2bool_nomg(sv))))
#define SvTRUE_nomg(sv)   ((sv) && (                                SvTRUE_common(sv, sv_2bool_nomg(sv))))
#define SvTRUE_NN(sv)              (SvGMAGICAL(sv) ? sv_2bool(sv) : SvTRUE_common(sv, sv_2bool_nomg(sv)))
#define SvTRUE_nomg_NN(sv) (                                        SvTRUE_common(sv, sv_2bool_nomg(sv)))
#define SvTRUE_common(sv,fallback) (			\
      !SvOK(sv)						\
	? 0						\
    : SvPOK(sv)						\
	? SvPVXtrue(sv)					\
    : (SvFLAGS(sv) & (SVf_IOK|SVf_NOK))			\
	? (   (SvIOK(sv) && SvIVX(sv) != 0)		\
	   || (SvNOK(sv) && SvNVX(sv) != 0.0))		\
    : (fallback))

d1668 33
a1700 2
#  define SvTRUEx(sv)      ({SV *_sv = (sv); SvTRUE(_sv); })
#  define SvTRUEx_nomg(sv) ({SV *_sv = (sv); SvTRUE_nomg(_sv); })
d1717 31
a1747 2
#  define SvTRUEx(sv)      ((PL_Sv = (sv)), SvTRUE(PL_Sv))
#  define SvTRUEx_nomg(sv) ((PL_Sv = (sv)), SvTRUE_nomg(PL_Sv))
d1750 3
a1752 14
#define SvPVXtrue(sv)	(					\
    ((XPV*)SvANY((sv))) 					\
     && (							\
	((XPV*)SvANY((sv)))->xpv_cur > 1			\
	|| (							\
	    ((XPV*)SvANY((sv)))->xpv_cur			\
	    && *(sv)->sv_u.svu_pv != '0'				\
	)							\
    )								\
)

#define SvIsCOW(sv)		(SvFLAGS(sv) & SVf_IsCOW)
#define SvIsCOW_on(sv)		(SvFLAGS(sv) |= SVf_IsCOW)
#define SvIsCOW_off(sv)		(SvFLAGS(sv) &= ~SVf_IsCOW)
a1820 7
#  define SvCANCOW(sv) \
	(SvIsCOW(sv) || (SvFLAGS(sv) & CAN_COW_MASK) == CAN_COW_FLAGS)
/* This is a pessimistic view. Scalar must be purely a read-write PV to copy-
   on-write.  */
#  define CAN_COW_MASK	(SVs_OBJECT|SVs_GMG|SVs_SMG|SVs_RMG|SVf_IOK|SVf_NOK| \
			 SVf_POK|SVf_ROK|SVp_IOK|SVp_NOK|SVp_POK|SVf_FAKE| \
			 SVf_OOK|SVf_BREAK|SVf_READONLY)
a1827 18
#  ifdef PERL_NEW_COPY_ON_WRITE
#   define SvCANCOW(sv)					    \
	(SvIsCOW(sv)					     \
	 ? SvLEN(sv) ? CowREFCNT(sv) != SV_COW_REFCNT_MAX : 1 \
	 : (SvFLAGS(sv) & CAN_COW_MASK) == CAN_COW_FLAGS       \
			    && SvCUR(sv)+1 < SvLEN(sv))
   /* Note: To allow 256 COW "copies", a refcnt of 0 means 1. */
#   define CowREFCNT(sv)	(*(U8 *)(SvPVX(sv)+SvLEN(sv)-1))
#   define SV_COW_REFCNT_MAX	((1 << sizeof(U8)*8) - 1)
#   ifndef SV_COW_THRESHOLD
#    define SV_COW_THRESHOLD	0	/* min string length for cow */
#   endif
#   ifndef SV_COWBUF_THRESHOLD
#    define SV_COWBUF_THRESHOLD	1250	/* min string length for cow */
#   endif				/* over existing buffer */
#   define CAN_COW_MASK	(SVf_POK|SVf_ROK|SVp_POK|SVf_FAKE| \
			 SVf_OOK|SVf_BREAK|SVf_READONLY)
#  endif
d1830 3
d1857 2
a1858 3
#define sv_catpvn_mg(sv, sstr, slen) sv_catpvn_flags(sv, sstr, slen, SV_GMAGIC|SV_SMAGIC);
#define sv_copypv(dsv, ssv) sv_copypv_flags(dsv, ssv, SV_GMAGIC)
#define sv_copypv_nomg(dsv, ssv) sv_copypv_flags(dsv, ssv, 0)
a1873 1
#define sv_2bool_nomg(sv) sv_2bool_flags(sv, 0)
a1876 2
#define sv_mortalcopy(sv) \
	Perl_sv_mortalcopy_flags(aTHX_ sv, SV_GMAGIC|SV_DO_COW_SVSETSV)
d1879 1
a1879 1
#define sv_catpvn_nomg_utf8_upgrade(dsv, sstr, slen, nsv)	\
d1887 1
a1887 1
	    sv_catsv_nomg(dsv, nsv);			\
a1888 10
#define sv_catpvn_nomg_maybeutf8(dsv, sstr, slen, is_utf8) \
	sv_catpvn_flags(dsv, sstr, slen, (is_utf8)?SV_CATUTF8:SV_CATBYTES)

#ifdef PERL_CORE
# define sv_or_pv_len_utf8(sv, pv, bytelen)	      \
    (SvGAMAGIC(sv)				       \
	? utf8_length((U8 *)(pv), (U8 *)(pv)+(bytelen))	\
	: sv_len_utf8(sv))
# define sv_or_pv_pos_u2b(sv,s,p,lp) S_sv_or_pv_pos_u2b(aTHX_ sv,s,p,lp)
#endif
d1907 1
a1907 2
Invokes C<mg_get> on an SV if it has 'get' magic.  For example, this
will call C<FETCH> on a tied variable.  This macro evaluates its
d1911 1
a1911 3
Invokes C<mg_set> on an SV if it has 'set' magic.  This is necessary
after modifying a scalar, in case it is a magical variable like C<$|>
or a tied variable (it calls C<STORE>).  This macro evaluates its
d1946 1
a1946 2
Returns a pointer to the character buffer. SV must be of type >= SVt_PV. One
alternative is to call C<sv_grow> if you are not sure of the type of SV.
d1991 1
a1991 8
#define SvIMMORTAL(sv) (SvREADONLY(sv) && ((sv)==&PL_sv_undef || (sv)==&PL_sv_yes || (sv)==&PL_sv_no || (sv)==&PL_sv_placeholder))

#ifdef DEBUGGING
   /* exercise the immortal resurrection code in sv_free2() */
#  define SvREFCNT_IMMORTAL 1000
#else
#  define SvREFCNT_IMMORTAL ((~(U32)0)/2)
#endif
a2022 4
#define isREGEXP(sv) \
    (SvTYPE(sv) == SVt_REGEXP				      \
     || (SvFLAGS(sv) & (SVTYPEMASK|SVp_POK|SVpgv_GP|SVf_FAKE)) \
	 == (SVt_PVLV|SVf_FAKE))
d2025 1
a2025 6
#ifdef PERL_NEW_COPY_ON_WRITE
# define SvGROW(sv,len) \
	(SvIsCOW(sv) || SvLEN(sv) < (len) ? sv_grow(sv,len) : SvPVX(sv))
#else
# define SvGROW(sv,len) (SvLEN(sv) < (len) ? sv_grow(sv,len) : SvPVX(sv))
#endif
a2054 12
=for apidoc Amx|SV*|newSVpadname|PADNAME *pn

Creates a new SV containing the pad name.  This is currently identical
to C<newSVsv>, but pad names may cease being SVs at some point, so
C<newSVpadname> is preferable.

=cut
*/

#define newSVpadname(pn) newSVsv(pn)

/*
d2074 5
a2078 5
	    const U8 *_crash = (U8*)SvPVX_const(sv);			\
	    (offset) = *--_crash;					\
	    if (!(offset)) {						\
		_crash -= sizeof(STRLEN);				\
		Copy(_crash, (U8 *)&(offset), sizeof(STRLEN), U8);	\
d2083 4
a2086 4
		const U8 *const _bonk = (U8*)SvPVX_const(sv) - (offset);\
		while (_crash > _bonk) {				\
		    --_crash;						\
		    assert (*_crash == (U8)PTR2UV(_crash));		\
d2090 1
a2090 1
	    (offset) = 0;						\
d2098 2
a2099 2
	    (offset) = ((U8*)SvPVX_const(sv))[-1];			\
	    if (!(offset)) {						\
d2101 1
a2101 1
		     (U8*)&(offset), sizeof(STRLEN), U8);		\
d2104 1
a2104 1
	    (offset) = 0;						\
d2115 1
a2115 1
 * indent-tabs-mode: nil
d2118 1
a2118 1
 * ex: set ts=8 sts=4 sw=4 et:
@


1.1.1.16
log
@Import perl-5.20.1
@
text
@d25 1
a32 1
    SVt_INVLIST
d60 1
a60 3
a typeglob.  SVt_REGEXP is for regular
expressions.  SVt_INVLIST is for Perl
core internal use only.
a93 3
=for apidoc AmU||SVt_INVLIST
Type flag for scalars.  See L</svtype>.

a118 5

  These are ordered so that the simpler types have a lower value; SvUPGRADE
  doesn't allow you to upgrade from a higher numbered type to a lower numbered
  one; also there is code that assumes that anything that has as a PV component
  has a type numbered >= SVt_PV.
a120 1

d123 3
a125 3
	/* BIND was here, before INVLIST replaced it.  */
	SVt_IV,		/* 1 */
	SVt_NV,		/* 2 */
d127 1
a127 2
	SVt_PV,		/* 3 */
	SVt_INVLIST,	/* 4, implemented as a PV */
d144 1
a144 3
 * SVt_MASK and the various PL_valid_types_* tables.  As of this writing those
 * tables are in perl.h.  There are also two affected names tables in dump.c,
 * one in B.xs, and 'bodies_by_type[]' in sv.c */
d150 1
a150 1
   purposes external code wanting to consider PVBM probably needs to think of
d287 1
a287 1
Decrements the reference count of the given SV.  I<sv> may be NULL.
a349 1
#define SVpad_NAMELIST	SVp_SCREAM  /* AV is a padnamelist */
a392 3
/* note that SVf_AMAGIC is now only set on stashes, so this bit is free
 * for non-HV SVs */

d398 3
a400 2
/* PVHV */
#define SVphv_SHAREKEYS 0x20000000  /* PVHV keys live on shared string table */
d406 2
a407 3

/* Some private flags. */

d466 4
d482 1
a482 1
};				/* also used by PadnamelistMAXNAMED */
d519 1
a519 4
    union {
	STRLEN	xlvu_targoff;
	SSize_t xlvu_stargoff;
    } xlv_targoff_u;
a526 9
#define xlv_targoff xlv_targoff_u.xlvu_targoff

struct xpvinvlist {
    _XPV_HEAD;
    IV          prev_index;
    STRLEN	iterator;
    bool	is_offset;	/* */
};

d535 1
a535 1
typedef U32 cv_flags_t;
d627 1
a627 1
Returns a U32 value indicating whether the value is defined.  This is
d733 1
a733 2
string.  Prior to 5.9.3 it is not safe
to execute this macro unless the SV's
d749 1
a749 1
C<NUL> character (even though Perl scalars do not strictly require it).
d768 1
a768 2
Set the value of the PV pointer in C<sv> to the C<NUL>-terminated string
C<val>.  See also C<SvIV_set>.
a934 1
/* "nog" means "doesn't have get magic" */
d1059 1
a1059 1
				   if (SvFLAGS(_svvalid) & SVpbm_VALID && !SvSCREAM(_svvalid)) \
a1064 1
				   assert(!SvSCREAM(_svvalid));		\
a1068 1
				   assert(!SvSCREAM(_svvalid));		\
d1073 2
a1074 3
			    assert(SvTYPE(_svtail) != SVt_PVAV);	\
			    assert(SvTYPE(_svtail) != SVt_PVHV);	\
			    assert(!SvSCREAM(_svtail));			\
d1079 1
a1079 1
#  define SvVALID(sv)		((SvFLAGS(sv) & SVpbm_VALID) && !SvSCREAM(sv))
d1334 1
a1334 1
			 if(UNLIKELY(SvOOK(sv))) {			\
d1364 6
d1372 1
a1372 1
	    assert(SvTYPE(_bmuseful) >= SVt_PVIV);			\
d1375 7
a1381 1
	    &(((XPVIV*) SvANY(_bmuseful))->xiv_u.xivu_iv);              \
d1384 3
a1386 3
#  define BmUSEFUL(sv)          ((XPVIV*) SvANY(sv))->xiv_u.xivu_iv

#endif
a1387 3
#ifndef PERL_CORE
# define BmRARE(sv)	0
# define BmPREVIOUS(sv)	0
a1394 1
#define LvSTARGOFF(sv)	((XPVLV*)  SvANY(sv))->xlv_targoff_u.xlvu_stargoff
d1439 1
a1439 1
unconditionally untainting the value.  Untainting should be done in the
d1455 1
a1455 1
#ifdef NO_TAINT_SUPPORT
d1460 2
a1461 2
#define SvTAINTED_on(sv)  STMT_START{ if(UNLIKELY(TAINTING_get)){sv_taint(sv);}   }STMT_END
#define SvTAINTED_off(sv) STMT_START{ if(UNLIKELY(TAINTING_get)){sv_untaint(sv);} }STMT_END
d1465 2
a1466 2
	if (UNLIKELY(TAINTING_get)) {	\
	    if (UNLIKELY(TAINT_get))	\
d1478 1
a1478 1
strip useful data from it.  For example if the SV was C<SvROK>, then the
d1489 2
a1490 4
stringified version becoming C<SvPOK>.  Handles 'get' magic.  The
C<len> variable will be set to the length of the string (this is a macro, so
don't use C<&len>). See also C<SvPVx> for a version which guarantees to
evaluate sv only once.
d1494 2
a1495 2
successive calls to C<SvPV(sv)> will return the same pointer value each
time.  This is due to the way that things like overloading and
d1602 2
a1603 2
=for apidoc Am|U32|SvIsCOW|SV* sv
Returns a U32 value indicating whether the SV is Copy-On-Write (either shared
a1684 1
/* "_nomg" in these defines means no mg_get() */
d1735 3
a1737 3
#define SvTRUE(sv)        (LIKELY(sv) && (UNLIKELY(SvGMAGICAL(sv)) ? sv_2bool(sv) : SvTRUE_common(sv, sv_2bool_nomg(sv))))
#define SvTRUE_nomg(sv)   (LIKELY(sv) && (                                SvTRUE_common(sv, sv_2bool_nomg(sv))))
#define SvTRUE_NN(sv)              (UNLIKELY(SvGMAGICAL(sv)) ? sv_2bool(sv) : SvTRUE_common(sv, sv_2bool_nomg(sv)))
d1888 6
d1962 1
a1962 1
#if defined(PERL_CORE) || defined(PERL_EXT)
d1967 1
d1997 1
a1997 1
=for apidoc Am|void|SvSetSV|SV* dsv|SV* ssv
d1999 1
a1999 1
more than once.  Does not handle 'set' magic on the destination SV.
d2005 1
a2005 1
=for apidoc Am|void|SvSetMagicSV|SV* dsv|SV* ssv
d2028 2
a2029 3
C<NUL> character).  Calls C<sv_grow> to perform the expansion if necessary.
Returns a pointer to the character
buffer.  SV must be of type >= SVt_PV.  One
d2040 2
a2041 2
#define SvGETMAGIC(x) ((void)(UNLIKELY(SvGMAGICAL(x)) && mg_get(x)))
#define SvSETMAGIC(x) STMT_START { if (UNLIKELY(SvSMAGICAL(x))) mg_set(x); } STMT_END
d2045 1
a2045 1
	    if (LIKELY((dst) != (src))) {		\
d2052 1
a2052 1
	    if (LIKELY((dst) != (src))) {			\
d2120 1
a2120 1
#ifdef PERL_ANY_COW
d2146 1
a2146 2
Creates a new SV and copies a string (which may contain C<NUL> (C<\0>)
characters) into it.  If utf8 is true, calls
a2221 48

#define SV_CONST(name) \
	PL_sv_consts[SV_CONST_##name] \
		? PL_sv_consts[SV_CONST_##name] \
		: (PL_sv_consts[SV_CONST_##name] = newSVpv_share(#name, 0))

#define SV_CONST_TIESCALAR 0
#define SV_CONST_TIEARRAY 1
#define SV_CONST_TIEHASH 2
#define SV_CONST_TIEHANDLE 3

#define SV_CONST_FETCH 4
#define SV_CONST_FETCHSIZE 5
#define SV_CONST_STORE 6
#define SV_CONST_STORESIZE 7
#define SV_CONST_EXISTS 8

#define SV_CONST_PUSH 9
#define SV_CONST_POP 10
#define SV_CONST_SHIFT 11
#define SV_CONST_UNSHIFT 12
#define SV_CONST_SPLICE 13
#define SV_CONST_EXTEND 14

#define SV_CONST_FIRSTKEY 15
#define SV_CONST_NEXTKEY 16
#define SV_CONST_SCALAR 17

#define SV_CONST_OPEN 18
#define SV_CONST_WRITE 19
#define SV_CONST_PRINT 20
#define SV_CONST_PRINTF 21
#define SV_CONST_READ 22
#define SV_CONST_READLINE 23
#define SV_CONST_GETC 24
#define SV_CONST_SEEK 25
#define SV_CONST_TELL 26
#define SV_CONST_EOF 27
#define SV_CONST_BINMODE 28
#define SV_CONST_FILENO 29
#define SV_CONST_CLOSE 30

#define SV_CONST_DELETE 31
#define SV_CONST_CLEAR 32
#define SV_CONST_UNTIE 33
#define SV_CONST_DESTROY 34

#define SV_CONSTS_COUNT 35
@


1.1.1.17
log
@Import perl-5.20.2
@
text
@d1515 1
a1515 1
don't use C<&len>).  See also C<SvPVx> for a version which guarantees to
@


1.1.1.18
log
@Import perl-5.24.2
@
text
@d19 1
a19 1
An enum of flags for Perl types.  These are found in the file F<sv.h>
d44 2
a45 2
C<SVt_PVIO> is for I/O objects, C<SVt_PVFM> for formats, C<SVt_PVCV> for
subroutines, C<SVt_PVHV> for hashes and C<SVt_PVAV> for arrays.
d54 2
a55 2
C<SVt_PVGV> represents a typeglob.  If C<!SvFAKE(sv)>, then it is a real,
incoercible typeglob.  If C<SvFAKE(sv)>, then it is a scalar to which a
d57 1
a57 1
a typeglob.  C<SVt_PVLV> represents a scalar that delegates to another scalar
d60 2
a61 2
a typeglob.  C<SVt_REGEXP> is for regular
expressions.  C<SVt_INVLIST> is for Perl
d64 1
a64 1
C<SVt_PVMG> represents a "normal" scalar (not a typeglob, regular expression,
d67 6
a72 6
other types are just simpler forms of C<SVt_PVMG>, with fewer internal fields.
C<SVt_NULL> can only hold undef.  C<SVt_IV> can hold undef, an integer, or a
reference.  (C<SVt_RV> is an alias for C<SVt_IV>, which exists for backward
compatibility.)  C<SVt_NV> can hold any of those or a double.  C<SVt_PV> can only
hold C<undef> or a string.  C<SVt_PVIV> is a superset of C<SVt_PV> and C<SVt_IV>.
C<SVt_PVNV> is similar.  C<SVt_PVMG> can hold anything C<SVt_PVNV> can hold, but it
a178 3
#ifdef PERL_IN_SV_C
#  define SVt_FIRST SVt_NULL	/* the type of SV that new_SV() in sv.c returns */
#endif
a193 6
#if NVSIZE <= IVSIZE
#  define _NV_BODYLESS_UNION NV svu_nv;
#else
#  define _NV_BODYLESS_UNION
#endif

a198 1
	_NV_BODYLESS_UNION		\
d205 1
a205 2
    }	sv_u				\
    _SV_HEAD_DEBUG
a206 11
#ifdef DEBUG_LEAKING_SCALARS
#define _SV_HEAD_DEBUG ;\
    PERL_BITFIELD32 sv_debug_optype:9;	/* the type of OP that allocated us */ \
    PERL_BITFIELD32 sv_debug_inpad:1;	/* was allocated in a pad for an OP */ \
    PERL_BITFIELD32 sv_debug_line:16;	/* the line where we were allocated */ \
    UV		    sv_debug_serial;	/* serial number of sv allocation   */ \
    char *	    sv_debug_file;	/* the file where we were allocated */ \
    SV *	    sv_debug_parent	/* what we were cloned from (ithreads)*/
#else
#define _SV_HEAD_DEBUG
#endif
d211 8
d263 2
a264 2
All of the following C<SvREFCNT_inc>* macros are optimized versions of
C<SvREFCNT_inc>, and can be replaced with C<SvREFCNT_inc>.
d267 2
a268 2
Same as C<SvREFCNT_inc>, but can only be used if you know C<sv>
is not C<NULL>.  Since we don't have to check the NULLness, it's faster
d272 1
a272 1
Same as C<SvREFCNT_inc>, but can only be used if you don't need the
d276 2
a277 2
Same as C<SvREFCNT_inc>, but can only be used if you don't need the return
value, and you know that C<sv> is not C<NULL>.  The macro doesn't need
d282 1
a282 1
Same as C<SvREFCNT_inc>, but can only be used with expressions without side
d286 2
a287 2
Same as C<SvREFCNT_inc_simple>, but can only be used if you know C<sv>
is not C<NULL>.  Since we don't have to check the NULLness, it's faster
d291 1
a291 1
Same as C<SvREFCNT_inc_simple>, but can only be used if you don't need the
d295 2
a296 2
Same as C<SvREFCNT_inc>, but can only be used if you don't need the return
value, and you know that C<sv> is not C<NULL>.  The macro doesn't need
d301 1
a301 1
Decrements the reference count of the given SV.  C<sv> may be C<NULL>.
d304 2
a305 2
Same as C<SvREFCNT_dec>, but can only be used if you know C<sv>
is not C<NULL>.  Since we don't have to check the NULLness, it's faster
d309 1
a309 1
Returns the type of the SV.  See C<L</svtype>>.
d313 1
a313 1
perform the upgrade if necessary.  See C<L</svtype>>.
d342 1
a342 1
#define SvIS_FREED(sv)	UNLIKELY(((sv)->sv_flags == SVTYPEMASK))
a357 1
                                    /* eval cx text is ref counted */
d364 10
a373 5
#define SVf_PROTECT	0x00010000  /* very read-only */
#define SVs_PADTMP	0x00020000  /* in use as tmp */
#define SVs_PADSTALE	0x00040000  /* lexical has gone out of scope;
					only used when !PADTMP */
#define SVs_TEMP	0x00080000  /* mortal (implies string is stealable) */
d384 3
a386 2
                                       3: HV: informally reserved by DAPM
                                          for vtables */
d393 1
a393 3
				       perl_destruct will skip it.
                                       Used for mark and sweep by OP_AASSIGN
                                       */
d399 1
a399 2
#define SVf_THINKFIRST	(SVf_READONLY|SVf_PROTECT|SVf_ROK|SVf_FAKE \
			|SVs_RMG|SVf_IsCOW)
a405 1
/* Note that SVf_AMAGIC is now only set on stashes.  */
a406 2
#define SVf_IsCOW	0x10000000  /* copy on write (shared hash key if
				       SvLEN == 0) */
d408 4
a411 2
/* Ensure this value does not clash with the GV_ADD* flags in gv.h, or the
   CV_CKPROTO_* flags in op.c, or the padadd_* flags in pad.h: */
d427 2
a428 3
/* The SVp_SCREAM|SVpbm_VALID (0x40008000) combination is up for grabs.
   Formerly it was used for pad names, but now it is available.  The core
   is careful to avoid setting both flags.
d434 1
a434 1
   0x4000C400   *** Formerly used for pad names ***
d439 4
d460 1
a460 1
#define SVpbm_TAIL	0x80000000  /* string has a fake "\n" appended */
d464 1
d494 1
d496 1
a496 1
};
d548 3
a550 8
    IV          prev_index;     /* caches result of previous invlist_search() */
    STRLEN	iterator;       /* Stores where we are in iterating */
    bool	is_offset;	/* The data structure for all inversion lists
                                   begins with an element for code point U+0000.
                                   If this bool is set, the actual list contains
                                   that 0; otherwise, the list actually begins
                                   with the following element.  Thus to invert
                                   the list, merely toggle this flag  */
d578 1
a578 4
    union {									\
	PADLIST *	xcv_padlist;						\
	void *		xcv_hscxt;						\
    }		xcv_padlist_u;							\
d678 1
a678 1
Tells an SV that it is an integer and disables all other C<OK> bits.
d681 1
a681 1
Tells an SV that it is an unsigned integer and disables all other C<OK> bits.
d686 1
a686 1
range of both an IV and a UV may be be flagged as either C<SvUOK> or C<SVIOK>.
d691 1
a691 1
range of both an IV and a UV may be be flagged as either C<SvUOK> or C<SVIOK>.
d719 1
a719 1
Tells an SV that it is a string and disables all other C<OK> bits.
d728 3
a730 3
beginning of a C<SvPV>.  When C<SvOOK> is true, then the start of the
allocated string buffer is actually C<SvOOK_offset()> bytes before C<SvPVX>.
This offset used to be stored in C<SvIVX>, but is now stored within the spare
d747 1
a747 1
Only use when you are sure C<SvIOK> is true.  See also C<L</SvIV>>.
d751 1
a751 1
Only use when you are sure C<SvIOK> is true.  See also C<L</SvUV>>.
d755 1
a755 1
Only use when you are sure C<SvNOK> is true.  See also C<L</SvNV>>.
d761 1
a761 1
type >= C<SVt_PV>.
d767 1
a767 1
Returns the length of the string which is in the SV.  See C<L</SvLEN>>.
d771 1
a771 1
attributable to C<SvOOK>.  See C<L</SvCUR>>.
d777 1
a777 1
See C<L</SvCUR>>.  Access the character as C<*(SvEND(sv))>.
d792 1
a792 1
Set the value of the NV pointer in C<sv> to val.  See C<L</SvIV_set>>.
d795 2
a796 5
This is probably not what you want to use, you probably wanted
L</sv_usepvn_flags> or L</sv_setpvn> or L</sv_setpvs>.

Set the value of the PV pointer in C<sv> to the Perl allocated
C<NUL>-terminated string C<val>.  See also C<L</SvIV_set>>.
a797 1
Remember to free the previous PV buffer. There are many things to check.
d800 2
a801 3
C<SvPV_force> (or check the C<SvIsCOW> flag) first to make sure this
modification is safe. Then finally, if it is not a COW, call C<SvPV_free> to
free the previous PV buffer.
d804 1
a804 1
Set the value of the UV pointer in C<sv> to val.  See C<L</SvIV_set>>.
d807 1
a807 1
Set the value of the RV pointer in C<sv> to val.  See C<L</SvIV_set>>.
d810 1
a810 1
Set the value of the MAGIC pointer in C<sv> to val.  See C<L</SvIV_set>>.
d813 1
a813 1
Set the value of the STASH pointer in C<sv> to val.  See C<L</SvIV_set>>.
d816 2
a817 2
Set the current length of the string which is in the SV.  See C<L</SvCUR>>
and C<SvIV_set>>.
d820 1
a820 1
Set the size of the string buffer for the SV. See C<L</SvLEN>>.
d845 1
a845 1
#define SvIOKp_on(sv)		(assert_not_glob(sv)	\
d854 1
a854 1
#define SvIOK_on(sv)		(assert_not_glob(sv)	\
d883 1
a883 1
You should use this I<after> a call to C<SvPV()> or one of its variants, in
a885 3
If you want to take into account the L<bytes> pragma, use C<L</DO_UTF8>>
instead.

d895 1
a895 1
Tells an SV that it is a string and disables all other C<OK> bits,
d928 1
a928 1
#define SvOOK_off(sv)		((void)(SvOOK(sv) && (sv_backoff(sv),0)))
d1023 2
a1024 2
A quick flag check to see whether an C<sv> should be passed to C<sv_force_normal>
to be "downgraded" before C<SvIVX> or C<SvPVX> can be modified directly.
d1026 2
a1027 2
For example, if your scalar is a reference and you want to modify the C<SvIVX>
slot, you can't just do C<SvROK_off>, as that will leak the referent.
d1030 1
a1030 1
C<sv_setsv>, C<sv_setiv> and C<sv_pvn_force>.
d1038 2
a1039 2
C<SvTHINKFIRST> sometimes produces false positives.  In those cases
C<sv_force_normal> does nothing.
d1046 4
a1049 5
#define SVs_PADMY		0
#define SvPADMY(sv)		!(SvFLAGS(sv) & SVs_PADTMP)
#ifndef PERL_CORE
# define SvPADMY_on(sv)		SvPADTMP_off(sv)
#endif
d1051 3
a1053 2
#define SvPADTMP(sv)		(SvFLAGS(sv) & (SVs_PADTMP))
#define SvPADSTALE(sv)		(SvFLAGS(sv) & (SVs_PADSTALE))
d1055 2
a1056 2
#define SvPADTMP_on(sv)		(SvFLAGS(sv) |= SVs_PADTMP)
#define SvPADTMP_off(sv)	(SvFLAGS(sv) &= ~SVs_PADTMP)
d1068 3
a1070 8
#define SvREADONLY(sv)		(SvFLAGS(sv) & (SVf_READONLY|SVf_PROTECT))
#ifdef PERL_CORE
# define SvREADONLY_on(sv)	(SvFLAGS(sv) |= (SVf_READONLY|SVf_PROTECT))
# define SvREADONLY_off(sv)	(SvFLAGS(sv) &=~(SVf_READONLY|SVf_PROTECT))
#else
# define SvREADONLY_on(sv)	(SvFLAGS(sv) |= SVf_READONLY)
# define SvREADONLY_off(sv)	(SvFLAGS(sv) &= ~SVf_READONLY)
#endif
d1121 40
d1243 2
d1289 1
a1289 1
	STMT_START {if (!SvIOKp(sv) && (SvFLAGS(sv) & (SVf_NOK|SVf_POK))) \
d1292 2
a1293 2
	(!(SvFLAGS(sv) & (SVf_IOK|SVp_IOK)) && (SvFLAGS(sv) & (SVf_NOK|SVf_POK)) \
	    ? (sv_2iv_flags(sv, 0), SvIOK(sv))	  \
d1489 4
a1492 3
        assert(TAINTING_get || !TAINT_get); \
        if (UNLIKELY(TAINT_get))	\
            SvTAINTED_on(sv);	        \
d1515 2
a1516 2
don't use C<&len>).  See also C<L</SvPVx>> for a version which guarantees to
evaluate C<sv> only once.
d1523 1
a1523 1
a temporary buffer or similar.  If you absolutely need the C<SvPVX> field to
d1525 1
a1525 1
C<L</SvPV_force>>.
d1542 2
a1543 2
Coerces the given SV to an integer and returns it.  See C<L</SvIVx>> for a
version which guarantees to evaluate C<sv> only once.
d1555 2
a1556 2
Coerce the given SV to a double and return it.  See C<L</SvNVx>> for a version
which guarantees to evaluate C<sv> only once.
d1568 2
a1569 2
Coerces the given SV to an unsigned integer and returns it.  See C<L</SvUVx>>
for a version which guarantees to evaluate C<sv> only once.
d1582 2
a1583 2
false.  See C<L</SvOK>> for a defined/undefined test.  Handles 'get' magic
unless the scalar is already C<SvPOK>, C<SvIOK> or C<SvNOK> (the public, not the
d1588 1
a1588 1
false.  See C<L</SvOK>> for a defined/undefined test.  Does not handle 'get' magic.
d1591 1
a1591 1
Like C<SvPV_force>, but converts C<sv> to UTF-8 first if necessary.
d1594 1
a1594 1
Like C<SvPV>, but converts C<sv> to UTF-8 first if necessary.
d1597 1
a1597 1
Like C<SvPV_nolen>, but converts C<sv> to UTF-8 first if necessary.
d1600 1
a1600 1
Like C<SvPV_force>, but converts C<sv> to byte representation first if necessary.
d1603 1
a1603 1
Like C<SvPV>, but converts C<sv> to byte representation first if necessary.
d1606 1
a1606 1
Like C<SvPV_nolen>, but converts C<sv> to byte representation first if necessary.
d1609 2
a1610 2
Like C<SvPV_force>, but converts C<sv> to UTF-8 first if necessary.
Guarantees to evaluate C<sv> only once; use the more efficient C<SvPVutf8_force>
d1614 2
a1615 2
Like C<SvPV>, but converts C<sv> to UTF-8 first if necessary.
Guarantees to evaluate C<sv> only once; use the more efficient C<SvPVutf8>
d1619 2
a1620 2
Like C<SvPV_force>, but converts C<sv> to byte representation first if necessary.
Guarantees to evaluate C<sv> only once; use the more efficient C<SvPVbyte_force>
d1624 2
a1625 2
Like C<SvPV>, but converts C<sv> to byte representation first if necessary.
Guarantees to evaluate C<sv> only once; use the more efficient C<SvPVbyte>
d1651 1
a1651 1
Like C<sv_utf8_upgrade>, but doesn't do magic on C<sv>.
d1677 1
a1677 1
     (const char*) sv_2pv_flags(sv, &lp, (flags|SV_CONST_RETURN)))
d1681 1
a1681 1
     (const char*) sv_2pv_flags(sv, 0, (flags|SV_CONST_RETURN)))
d1685 1
a1685 1
     sv_2pv_flags(sv, &lp, (flags|SV_MUTABLE_RETURN)))
a1841 3
/* XXX This flag actually enabled for any COW.  But it appears not to do
       anything.  Can we just remove it?  Or will it serve some future
       purpose.  */
d1852 6
a1857 2
#define SV_CATBYTES		16384
#define SV_CATUTF8		32768
d1887 20
a1906 1
#ifdef PERL_COPY_ON_WRITE
d1916 3
a1918 2
			 SVf_OOK|SVf_BREAK|SVf_READONLY|SVf_PROTECT)
#endif
a1967 6
#define sv_cathek(sv,hek)					    \
	STMT_START {						     \
	    HEK * const bmxk = hek;				      \
	    sv_catpvn_flags(sv, HEK_KEY(bmxk), HEK_LEN(bmxk),	       \
			    HEK_UTF8(bmxk) ? SV_CATUTF8 : SV_CATBYTES); \
	} STMT_END
d2001 1
a2001 1
/* the following macros update any magic values this C<sv> is associated with */
d2018 1
a2018 1
Calls C<sv_setsv> if C<dsv> is not the same as C<ssv>.  May evaluate arguments
d2022 2
a2023 2
Calls a non-destructive version of C<sv_setsv> if C<dsv> is not the same as
C<ssv>.  May evaluate arguments more than once.
d2032 1
a2032 1
Arranges for C<sv> to be shared between threads if a suitable module
d2036 1
a2036 1
Arranges for a mutual exclusion lock to be obtained on C<sv> if a suitable module
d2040 1
a2040 1
Releases a mutual exclusion lock on C<sv> if a suitable module
d2050 1
a2050 1
buffer.  SV must be of type >= C<SVt_PV>.  One
d2110 1
a2110 1
See also C<L</PL_sv_yes>> and C<L</PL_sv_no>>.
d2168 1
a2168 1
characters) into it.  If C<utf8> is true, calls
d2179 3
a2181 1
Creates a new SV containing the pad name.
d2186 1
a2186 1
#define newSVpadname(pn) newSVpvn_utf8(PadnamePV(pn), PadnameLEN(pn), TRUE)
d2191 1
a2191 1
Reads into C<len> the offset from C<SvPVX> back to the true start of the
d2194 2
a2195 2
macro, which takes the address of C<len>, which must be of type C<STRLEN>.
Evaluates C<sv> more than once.  Sets C<len> to 0 if C<SvOOK(sv)> is false.
d2294 5
a2298 1
 * Bodyless IVs and NVs!
a2299 32
 * Since 5.9.2, we can avoid allocating a body for SVt_IV-type SVs.
 * Since the larger IV-holding variants of SVs store their integer
 * values in their respective bodies, the family of SvIV() accessor
 * macros would  naively have to branch on the SV type to find the
 * integer value either in the HEAD or BODY. In order to avoid this
 * expensive branch, a clever soul has deployed a great hack:
 * We set up the SvANY pointer such that instead of pointing to a
 * real body, it points into the memory before the location of the
 * head. We compute this pointer such that the location of
 * the integer member of the hypothetical body struct happens to
 * be the same as the location of the integer member of the bodyless
 * SV head. This now means that the SvIV() family of accessors can
 * always read from the (hypothetical or real) body via SvANY.
 *
 * Since the 5.21 dev series, we employ the same trick for NVs
 * if the architecture can support it (NVSIZE <= IVSIZE).
 */

/* The following two macros compute the necessary offsets for the above
 * trick and store them in SvANY for SvIV() (and friends) to use. */

#ifdef PERL_CORE
#  define SET_SVANY_FOR_BODYLESS_IV(sv) \
	SvANY(sv) =   (XPVIV*)((char*)&(sv->sv_u.svu_iv) \
                    - STRUCT_OFFSET(XPVIV, xiv_iv))

#  define SET_SVANY_FOR_BODYLESS_NV(sv) \
	SvANY(sv) =   (XPVNV*)((char*)&(sv->sv_u.svu_nv) \
                    - STRUCT_OFFSET(XPVNV, xnv_u.xnv_nv))
#endif

/*
@


