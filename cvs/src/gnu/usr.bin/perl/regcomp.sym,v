head	1.2;
access;
symbols
	OPENBSD_6_2:1.2.0.6
	OPENBSD_6_2_BASE:1.2
	PERL_5_24_2:1.1.1.8
	OPENBSD_6_1:1.2.0.4
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.7.0.10
	OPENBSD_6_0_BASE:1.1.1.7
	OPENBSD_5_9:1.1.1.7.0.4
	OPENBSD_5_9_BASE:1.1.1.7
	OPENBSD_5_8:1.1.1.7.0.6
	OPENBSD_5_8_BASE:1.1.1.7
	PERL_5_20_2:1.1.1.7
	OPENBSD_5_7:1.1.1.7.0.2
	OPENBSD_5_7_BASE:1.1.1.7
	PERL_5_20_1:1.1.1.7
	OPENBSD_5_6:1.1.1.6.0.4
	OPENBSD_5_6_BASE:1.1.1.6
	PERL_5_18_2:1.1.1.6
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.5.0.6
	OPENBSD_5_5_BASE:1.1.1.5
	OPENBSD_5_4:1.1.1.5.0.2
	OPENBSD_5_4_BASE:1.1.1.5
	PERL_5_16_3:1.1.1.5
	OPENBSD_5_3:1.1.1.4.0.18
	OPENBSD_5_3_BASE:1.1.1.4
	OPENBSD_5_2:1.1.1.4.0.16
	OPENBSD_5_2_BASE:1.1.1.4
	OPENBSD_5_1_BASE:1.1.1.4
	OPENBSD_5_1:1.1.1.4.0.14
	OPENBSD_5_0:1.1.1.4.0.12
	OPENBSD_5_0_BASE:1.1.1.4
	OPENBSD_4_9:1.1.1.4.0.10
	OPENBSD_4_9_BASE:1.1.1.4
	PERL_5_12_2:1.1.1.4
	OPENBSD_4_8:1.1.1.4.0.8
	OPENBSD_4_8_BASE:1.1.1.4
	OPENBSD_4_7:1.1.1.4.0.4
	OPENBSD_4_7_BASE:1.1.1.4
	PERL_5_10_1:1.1.1.4
	OPENBSD_4_6:1.1.1.4.0.6
	OPENBSD_4_6_BASE:1.1.1.4
	OPENBSD_4_5:1.1.1.4.0.2
	OPENBSD_4_5_BASE:1.1.1.4
	PERL_5_10_0:1.1.1.4
	OPENBSD_4_4:1.1.1.3.0.24
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.22
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_2:1.1.1.3.0.20
	OPENBSD_4_2_BASE:1.1.1.3
	OPENBSD_4_1:1.1.1.3.0.18
	OPENBSD_4_1_BASE:1.1.1.3
	OPENBSD_4_0:1.1.1.3.0.16
	OPENBSD_4_0_BASE:1.1.1.3
	PERL_5_8_8:1.1.1.3
	OPENBSD_3_9:1.1.1.3.0.14
	OPENBSD_3_9_BASE:1.1.1.3
	OPENBSD_3_8:1.1.1.3.0.12
	OPENBSD_3_8_BASE:1.1.1.3
	OPENBSD_3_7:1.1.1.3.0.10
	OPENBSD_3_7_BASE:1.1.1.3
	PERL_5_8_6:1.1.1.3
	OPENBSD_3_6:1.1.1.3.0.8
	OPENBSD_3_6_BASE:1.1.1.3
	PERL_5_8_5:1.1.1.3
	PERL_5_8_3:1.1.1.3
	OPENBSD_3_5:1.1.1.3.0.6
	OPENBSD_3_5_BASE:1.1.1.3
	PERL_5_8_2:1.1.1.3
	OPENBSD_3_4:1.1.1.3.0.4
	OPENBSD_3_4_BASE:1.1.1.3
	OPENBSD_3_3:1.1.1.3.0.2
	OPENBSD_3_3_BASE:1.1.1.3
	PERL_5_8_0:1.1.1.3
	OPENBSD_3_2:1.1.1.2.0.12
	OPENBSD_3_2_BASE:1.1.1.2
	OPENBSD_3_1:1.1.1.2.0.10
	OPENBSD_3_1_BASE:1.1.1.2
	OPENBSD_3_0:1.1.1.2.0.8
	OPENBSD_3_0_BASE:1.1.1.2
	PERL_5_6_1:1.1.1.2
	OPENBSD_2_9:1.1.1.2.0.6
	OPENBSD_2_9_BASE:1.1.1.2
	OPENBSD_2_8:1.1.1.2.0.4
	OPENBSD_2_8_BASE:1.1.1.2
	OPENBSD_2_7:1.1.1.2.0.2
	OPENBSD_2_7_BASE:1.1.1.2
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.1.1.1.0.2
	OPENBSD_2_6_BASE:1.1.1.1
	PERL_500503:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.31.53;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	99.04.29.22.37.52;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.29.22.37.52;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.04.06.16.08.46;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.10.27.22.14.51;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2008.09.29.17.18.10;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.03.25.20.06.39;	author sthen;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2014.03.24.14.58.47;	author afresh1;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2014.11.17.20.52.39;	author afresh1;	state Exp;
branches;
next	1.1.1.8;
commitid	B31cAbBIXiCqnL97;

1.1.1.8
date	2017.08.14.13.45.29;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@# regcomp.sym
#
# File has two sections, divided by a line of dashes '-'. 
#
# Lines beginning with # are ignored, except for those that start with #*
# which are included in pod/perldebguts.pod.  # within a line may be part
# of a description.
#
# First section is for regops, second section is for regmatch-states
#
# Note that the order in this file is important.
#
# Format for first section: 
# NAME \s+ TYPE, arg-description [num-args] [flags] [longjump-len] ; DESCRIPTION
#   flag <S> means is REGNODE_SIMPLE; flag <V> means is REGNODE_VARIES
#
#
# run perl regen.pl after editing this file



#* Exit points

END         END,        no        ; End of program.
SUCCEED     END,        no        ; Return from a subroutine, basically.

#* Line Start Anchors:
#Note flags field for SBOL indicates if it is a /^/ or a /\A/
SBOL        BOL,        no        ; Match "" at beginning of line: /^/, /\A/
MBOL        BOL,        no        ; Same, assuming multiline: /^/m

#* Line End Anchors:
SEOL        EOL,        no        ; Match "" at end of line: /$/
MEOL        EOL,        no        ; Same, assuming multiline: /$/m
EOS         EOL,        no        ; Match "" at end of string: /\z/

#* Match Start Anchors:
GPOS        GPOS,       no        ; Matches where last m//g left off.

#* Word Boundary Opcodes:
# The regops that have varieties that vary depending on the character set regex
# modifiers have to ordered thusly: /d, /l, /u, /a, /aa.  This is because code
# in regcomp.c uses the enum value of the modifier as an offset from the /d
# version.  The complements must come after the non-complements.
# BOUND, POSIX and their complements are affected, as well as EXACTF.
BOUND       BOUND,      no        ; Like BOUNDA for non-utf8, otherwise match "" between any Unicode \w\W or \W\w
BOUNDL      BOUND,      no        ; Like BOUND/BOUNDU, but \w and \W are defined by current locale
BOUNDU      BOUND,      no        ; Match "" at any boundary of a given type using Unicode rules
BOUNDA      BOUND,      no        ; Match "" at any boundary between \w\W or \W\w, where \w is [_a-zA-Z0-9]
# All NBOUND nodes are required by code in regexec.c to be greater than all BOUND ones
NBOUND      NBOUND,     no        ; Like NBOUNDA for non-utf8, otherwise match "" between any Unicode \w\w or \W\W
NBOUNDL     NBOUND,     no        ; Like NBOUND/NBOUNDU, but \w and \W are defined by current locale
NBOUNDU     NBOUND,     no        ; Match "" at any non-boundary of a given type using using Unicode rules
NBOUNDA     NBOUND,     no        ; Match "" betweeen any \w\w or \W\W, where \w is [_a-zA-Z0-9]

#* [Special] alternatives:
REG_ANY     REG_ANY,    no 0 S    ; Match any one character (except newline).
SANY        REG_ANY,    no 0 S    ; Match any one character.
ANYOF       ANYOF,      sv 1 S    ; Match character in (or not in) this class, single char match only
ANYOFD      ANYOF,      sv 1 S    ; Like ANYOF, but /d is in effect
ANYOFL      ANYOF,      sv 1 S    ; Like ANYOF, but /l is in effect

#* POSIX Character Classes:
# Order of the below is important.  See ordering comment above.
POSIXD      POSIXD,     none 0 S   ; Some [[:class:]] under /d; the FLAGS field gives which one
POSIXL      POSIXD,     none 0 S   ; Some [[:class:]] under /l; the FLAGS field gives which one
POSIXU      POSIXD,     none 0 S   ; Some [[:class:]] under /u; the FLAGS field gives which one
POSIXA      POSIXD,     none 0 S   ; Some [[:class:]] under /a; the FLAGS field gives which one
NPOSIXD     NPOSIXD,    none 0 S   ; complement of POSIXD, [[:^class:]]
NPOSIXL     NPOSIXD,    none 0 S   ; complement of POSIXL, [[:^class:]]
NPOSIXU     NPOSIXD,    none 0 S   ; complement of POSIXU, [[:^class:]]
NPOSIXA     NPOSIXD,    none 0 S   ; complement of POSIXA, [[:^class:]]
# End of order is important

CLUMP       CLUMP,      no 0 V    ; Match any extended grapheme cluster sequence

#* Alternation

#* BRANCH        The set of branches constituting a single choice are
#*               hooked together with their "next" pointers, since
#*               precedence prevents anything being concatenated to
#*               any individual branch.  The "next" pointer of the last
#*               BRANCH in a choice points to the thing following the
#*               whole choice.  This is also where the final "next"
#*               pointer of each individual branch points; each branch
#*               starts with the operand node of a BRANCH node.
#*
BRANCH      BRANCH,     node 0 V  ; Match this alternative, or the next...

#*Literals
# NOTE: the relative ordering of these types is important do not change it

EXACT       EXACT,      str       ; Match this string (preceded by length).
EXACTL      EXACT,      str       ; Like EXACT, but /l is in effect (used so locale-related warnings can be checked for).
EXACTF      EXACT,      str       ; Match this non-UTF-8 string (not guaranteed to be folded) using /id rules (w/len).
EXACTFL     EXACT,      str       ; Match this string (not guaranteed to be folded) using /il rules (w/len).
EXACTFU     EXACT,      str	  ; Match this string (folded iff in UTF-8, length in folding doesn't change if not in UTF-8) using /iu rules (w/len).
EXACTFA     EXACT,      str	  ; Match this string (not guaranteed to be folded) using /iaa rules (w/len).

# End of important relative ordering.

EXACTFU_SS  EXACT,      str	  ; Match this string (folded iff in UTF-8, length in folding may change even if not in UTF-8) using /iu rules (w/len).
EXACTFLU8   EXACT,      str	  ; Rare cirucmstances: like EXACTFU, but is under /l, UTF-8, folded, and everything in it is above 255.
EXACTFA_NO_TRIE  EXACT, str	  ; Match this string (which is not trie-able; not guaranteed to be folded) using /iaa rules (w/len).

#*Do nothing types

NOTHING     NOTHING,    no        ; Match empty string.
#*A variant of above which delimits a group, thus stops optimizations
TAIL        NOTHING,    no        ; Match empty string. Can jump here from outside.

#*Loops

#* STAR,PLUS    '?', and complex '*' and '+', are implemented as
#*               circular BRANCH structures.  Simple cases
#*               (one character per match) are implemented with STAR
#*               and PLUS for speed and to minimize recursive plunges.
#*
STAR        STAR,       node 0 V  ; Match this (simple) thing 0 or more times.
PLUS        PLUS,       node 0 V  ; Match this (simple) thing 1 or more times.

CURLY       CURLY,      sv 2 V    ; Match this simple thing {n,m} times.
CURLYN      CURLY,      no 2 V    ; Capture next-after-this simple thing 
CURLYM      CURLY,      no 2 V    ; Capture this medium-complex thing {n,m} times. 
CURLYX      CURLY,      sv 2 V    ; Match this complex thing {n,m} times.

#*This terminator creates a loop structure for CURLYX
WHILEM      WHILEM,     no 0 V    ; Do curly processing and see if rest matches.

#*Buffer related

#*OPEN,CLOSE,GROUPP     ...are numbered at compile time.
OPEN        OPEN,       num 1     ; Mark this point in input as start of #n.
CLOSE       CLOSE,      num 1     ; Analogous to OPEN.

REF         REF,        num 1 V   ; Match some already matched string
REFF        REF,        num 1 V   ; Match already matched string, folded using native charset rules for non-utf8
REFFL       REF,        num 1 V   ; Match already matched string, folded in loc.
# N?REFF[AU] could have been implemented using the FLAGS field of the
# regnode, but by having a separate node type, we can use the existing switch
# statement to avoid some tests
REFFU       REF,        num 1 V   ; Match already matched string, folded using unicode rules for non-utf8
REFFA       REF,        num 1 V   ; Match already matched string, folded using unicode rules for non-utf8, no mixing ASCII, non-ASCII

#*Named references.  Code in regcomp.c assumes that these all are after
#*the numbered references
NREF        REF,        no-sv 1 V ; Match some already matched string
NREFF       REF,        no-sv 1 V ; Match already matched string, folded using native charset rules for non-utf8
NREFFL      REF,        no-sv 1 V ; Match already matched string, folded in loc.
NREFFU      REF,        num   1 V ; Match already matched string, folded using unicode rules for non-utf8
NREFFA      REF,        num   1 V ; Match already matched string, folded using unicode rules for non-utf8, no mixing ASCII, non-ASCII

#*Support for long RE
LONGJMP     LONGJMP,    off 1 . 1 ; Jump far away.
BRANCHJ     BRANCHJ,    off 1 V 1 ; BRANCH with long offset.

#*Special Case Regops
IFMATCH     BRANCHJ,    off 1 . 2 ; Succeeds if the following matches.
UNLESSM     BRANCHJ,    off 1 . 2 ; Fails if the following matches.
SUSPEND     BRANCHJ,    off 1 V 1 ; "Independent" sub-RE.
IFTHEN      BRANCHJ,    off 1 V 1 ; Switch, should be preceded by switcher.
GROUPP      GROUPP,     num 1     ; Whether the group matched.


#*The heavy worker

EVAL        EVAL,       evl/flags 2L ; Execute some Perl code.

#*Modifiers

MINMOD      MINMOD,     no        ; Next operator is not greedy.
LOGICAL     LOGICAL,    no        ; Next opcode should set the flag only.

#*This is not used yet
RENUM       BRANCHJ,    off 1 . 1 ; Group with independently numbered parens.

#*Trie Related

#* Behave the same as A|LIST|OF|WORDS would. The '..C' variants
#* have inline charclass data (ascii only), the 'C' store it in the
#* structure.
# NOTE: the relative order of the TRIE-like regops  is significant

TRIE        TRIE,       trie 1    ; Match many EXACT(F[ALU]?)? at once. flags==type
TRIEC       TRIE,trie charclass   ; Same as TRIE, but with embedded charclass data

# For start classes, contains an added fail table.
AHOCORASICK     TRIE,   trie 1    ; Aho Corasick stclass. flags==type
AHOCORASICKC    TRIE,trie charclass   ; Same as AHOCORASICK, but with embedded charclass data

#*Regex Subroutines
GOSUB       GOSUB,      num/ofs 2L    ; recurse to paren arg1 at (signed) ofs arg2

#*Special conditionals
NGROUPP     NGROUPP,    no-sv 1   ; Whether the group matched.            
INSUBP      INSUBP,     num 1     ; Whether we are in a specific recurse.  
DEFINEP     DEFINEP,    none 1    ; Never execute directly.               

#*Backtracking Verbs
ENDLIKE     ENDLIKE,    none      ; Used only for the type field of verbs
OPFAIL      ENDLIKE,    no-sv 1   ; Same as (?!), but with verb arg
ACCEPT      ENDLIKE,    no-sv/num 2L   ; Accepts the current matched string, with verbar

#*Verbs With Arguments
VERB        VERB,       no-sv 1   ; Used only for the type field of verbs
PRUNE       VERB,       no-sv 1   ; Pattern fails at this startpoint if no-backtracking through this 
MARKPOINT   VERB,       no-sv 1   ; Push the current location for rollback by cut.
SKIP        VERB,       no-sv 1   ; On failure skip forward (to the mark) before retrying
COMMIT      VERB,       no-sv 1   ; Pattern fails outright if backtracking through this
CUTGROUP    VERB,       no-sv 1   ; On failure go to the next alternation in the group

#*Control what to keep in $&.
KEEPS       KEEPS,      no        ; $& begins here.

#*New charclass like patterns
LNBREAK     LNBREAK,    none      ; generic newline pattern

# NEW STUFF SOMEWHERE ABOVE THIS LINE

################################################################################

#*SPECIAL  REGOPS

#* This is not really a node, but an optimized away piece of a "long"
#* node.  To simplify debugging output, we mark it as if it were a node
OPTIMIZED   NOTHING,    off       ; Placeholder for dump.

#* Special opcode with the property that no opcode in a compiled program
#* will ever be of this type. Thus it can be used as a flag value that
#* no other opcode has been seen. END is used similarly, in that an END
#* node cant be optimized. So END implies "unoptimizable" and PSEUDO
#* mean "not seen anything to optimize yet".
PSEUDO      PSEUDO,     off       ; Pseudo opcode for internal use.

-------------------------------------------------------------------------------
# Format for second section:
# REGOP \t typelist [ \t typelist]
# typelist= namelist
#         = namelist:FAIL
#         = name:count

# Anything below is a state
#
#
TRIE            next:FAIL
EVAL            AB:FAIL
CURLYX          end:FAIL
WHILEM          A_pre,A_min,A_max,B_min,B_max:FAIL
BRANCH          next:FAIL
CURLYM          A,B:FAIL
IFMATCH         A:FAIL
CURLY           B_min_known,B_min,B_max:FAIL
COMMIT          next:FAIL
MARKPOINT       next:FAIL
SKIP            next:FAIL
CUTGROUP        next:FAIL
KEEPS           next:FAIL
@


1.1
log
@Initial revision
@
text
@d1 18
a18 2
# Format:
# NAME \t TYPE, arg-description [num-args] [longjump-len] \t DESCRIPTION
a19 1
# Empty rows and #-comment rows are ignored.
d21 237
a257 107
# Exit points
END		END,    no	End of program.
SUCCEED		END,    no	Return from a subroutine, basically.

# Anchors:
BOL		BOL,    no	Match "" at beginning of line.
MBOL		BOL,    no	Same, assuming multiline.
SBOL		BOL,    no	Same, assuming singleline.
EOS		EOL,    no	Match "" at end of string.
EOL		EOL,    no	Match "" at end of line.
MEOL		EOL,    no	Same, assuming multiline.
SEOL		EOL,    no	Same, assuming singleline.
BOUND		BOUND,  no	Match "" at any word boundary
BOUNDL		BOUND,  no	Match "" at any word boundary
NBOUND		NBOUND, no	Match "" at any word non-boundary
NBOUNDL		NBOUND, no	Match "" at any word non-boundary
GPOS		GPOS,   no	Matches where last m//g left off.

# [Special] alternatives
ANY		ANY,    no	Match any one character (except newline).
SANY		ANY,    no	Match any one character.
ANYOF		ANYOF,  sv	Match character in (or not in) this class.
ALNUM		ALNUM,  no	Match any alphanumeric character
ALNUML		ALNUM,  no	Match any alphanumeric char in locale
NALNUM		NALNUM, no	Match any non-alphanumeric character
NALNUML		NALNUM, no	Match any non-alphanumeric char in locale
SPACE		SPACE,  no	Match any whitespace character
SPACEL		SPACE,  no	Match any whitespace char in locale
NSPACE		NSPACE, no	Match any non-whitespace character
NSPACEL		NSPACE, no	Match any non-whitespace char in locale
DIGIT		DIGIT,  no	Match any numeric character
NDIGIT		NDIGIT, no	Match any non-numeric character

# BRANCH	The set of branches constituting a single choice are hooked
#		together with their "next" pointers, since precedence prevents
#		anything being concatenated to any individual branch.  The
#		"next" pointer of the last BRANCH in a choice points to the
#		thing following the whole choice.  This is also where the
#		final "next" pointer of each individual branch points; each
#		branch starts with the operand node of a BRANCH node.
#
BRANCH		BRANCH, node	Match this alternative, or the next...

# BACK		Normal "next" pointers all implicitly point forward; BACK
#		exists to make loop structures possible.
# not used
BACK		BACK,   no	Match "", "next" ptr points backward.

# Literals
EXACT		EXACT,  sv	Match this string (preceded by length).
EXACTF		EXACT,  sv	Match this string, folded (prec. by length).
EXACTFL		EXACT,  sv	Match this string, folded in locale (w/len).

# Do nothing
NOTHING		NOTHING,no	Match empty string.
# A variant of above which delimits a group, thus stops optimizations
TAIL		NOTHING,no	Match empty string. Can jump here from outside.

# STAR,PLUS	'?', and complex '*' and '+', are implemented as circular
#		BRANCH structures using BACK.  Simple cases (one character
#		per match) are implemented with STAR and PLUS for speed
#		and to minimize recursive plunges.
#
STAR		STAR,   node	Match this (simple) thing 0 or more times.
PLUS		PLUS,   node	Match this (simple) thing 1 or more times.

CURLY		CURLY,  sv 2	Match this simple thing {n,m} times.
CURLYN		CURLY,  no 2	Match next-after-this simple thing 
#				{n,m} times, set parenths.
CURLYM		CURLY,  no 2	Match this medium-complex thing {n,m} times.
CURLYX		CURLY,  sv 2	Match this complex thing {n,m} times.

# This terminator creates a loop structure for CURLYX
WHILEM		WHILEM, no	Do curly processing and see if rest matches.

# OPEN,CLOSE,GROUPP	...are numbered at compile time.
OPEN		OPEN,   num 1	Mark this point in input as start of #n.
CLOSE		CLOSE,  num 1	Analogous to OPEN.

REF		REF,    num 1	Match some already matched string
REFF		REF,    num 1	Match already matched string, folded
REFFL		REF,    num 1	Match already matched string, folded in loc.

# grouping assertions
IFMATCH		BRANCHJ,off 1 2	Succeeds if the following matches.
UNLESSM		BRANCHJ,off 1 2	Fails if the following matches.
SUSPEND		BRANCHJ,off 1 1	"Independent" sub-RE.
IFTHEN		BRANCHJ,off 1 1	Switch, should be preceeded by switcher .
GROUPP		GROUPP, num 1	Whether the group matched.

# Support for long RE
LONGJMP		LONGJMP,off 1 1	Jump far away.
BRANCHJ		BRANCHJ,off 1 1	BRANCH with long offset.

# The heavy worker
EVAL		EVAL,   evl 1	Execute some Perl code.

# Modifiers
MINMOD		MINMOD, no	Next operator is not greedy.
LOGICAL		LOGICAL,no	Next opcode should set the flag only.

# This is not used yet
RENUM		BRANCHJ,off 1 1	Group with independently numbered parens.

# This is not really a node, but an optimized away piece of a "long" node.
# To simplify debugging output, we mark it as if it were a node
OPTIMIZED	NOTHING,off	Placeholder for dump.
@


1.1.1.1
log
@perl5.005_03
@
text
@@


1.1.1.2
log
@virgin perl 5.6.0
@
text
@a18 1
BOUNDUTF8	BOUND,  no	Match "" at any word boundary
a19 1
BOUNDLUTF8	BOUND,  no	Match "" at any word boundary
a20 1
NBOUNDUTF8	NBOUND, no	Match "" at any word non-boundary
a21 1
NBOUNDLUTF8	NBOUND, no	Match "" at any word non-boundary
d25 2
a26 4
REG_ANY		REG_ANY,    no	Match any one character (except newline).
ANYUTF8		REG_ANY,    no	Match any one Unicode character (except newline).
SANY		REG_ANY,    no	Match any one character.
SANYUTF8	REG_ANY,    no	Match any one Unicode character.
a27 1
ANYOFUTF8	ANYOF,  sv 1	Match character in (or not in) this class.
a28 1
ALNUMUTF8	ALNUM,  no	Match any alphanumeric character in utf8
a29 1
ALNUMLUTF8	ALNUM,  no	Match any alphanumeric char in locale+utf8
a30 1
NALNUMUTF8	NALNUM, no	Match any non-alphanumeric character in utf8
a31 1
NALNUMLUTF8	NALNUM, no	Match any non-alphanumeric char in locale+utf8
a32 1
SPACEUTF8	SPACE,  no	Match any whitespace character in utf8
a33 1
SPACELUTF8	SPACE,  no	Match any whitespace char in locale+utf8
a34 1
NSPACEUTF8	NSPACE, no	Match any non-whitespace character in utf8
a35 1
NSPACELUTF8	NSPACE, no	Match any non-whitespace char in locale+utf8
a36 3
DIGITUTF8	DIGIT,  no	Match any numeric character in utf8
DIGITL		DIGIT,  no	Match any numeric character in locale
DIGITLUTF8	DIGIT,  no	Match any numeric character in locale+utf8
a37 4
NDIGITUTF8	NDIGIT, no	Match any non-numeric character in utf8
NDIGITL		NDIGIT, no	Match any non-numeric character in locale
NDIGITLUTF8	NDIGIT, no	Match any non-numeric character in locale+utf8
CLUMP		CLUMP,  no	Match any combining character sequence
@


1.1.1.3
log
@stock perl 5.8.0 from CPAN
@
text
@d19 1
d21 1
d23 1
d25 1
d30 1
d32 1
a32 1
CANY		REG_ANY,    no	Match any one byte.
d34 1
d36 1
d38 1
d40 1
d42 1
d44 1
d46 1
d48 1
d50 1
d52 1
d54 1
d56 1
d58 1
@


1.1.1.4
log
@import perl 5.10.0 from CPAN
@
text
@d1 1
a1 11
# regcomp.sym
#
# File has two sections, divided by a line of dashes '-'. 
#
# Empty rows after #-comment are removed from input are ignored
#
# First section is for regops, second sectionis for regmatch-states
#
# Note that the order in this file is important.
#
# Format for first section: 
a2 5
#
#
# run perl regen.pl after editing this file


d4 1
a4 1
#* Exit points (0,1)
d6 1
d10 1
a10 2
#* Anchors: (2..13)

d24 1
a24 2
#* [Special] alternatives: (14..30)

d43 1
a43 3
#* Alternation (31)

# BRANCH  	The set of branches constituting a single choice are hooked
a52 2
#*Back pointer (32)

d58 4
a61 7
#*Literals (33..35)

EXACT		EXACT,  str	Match this string (preceded by length).
EXACTF		EXACT,  str	Match this string, folded (prec. by length).
EXACTFL		EXACT,  str	Match this string, folded in locale (w/len).

#*Do nothing types (36..37)
d63 1
a67 2
#*Loops (38..44)

d77 3
a79 2
CURLYN		CURLY,  no 2	Capture next-after-this simple thing 
CURLYM		CURLY,  no 2	Capture this medium-complex thing {n,m} times. 
a84 2
#*Buffer related (45..49)

d93 1
a93 2
#*Grouping assertions (50..54)

d100 1
a100 2
#*Support for long RE (55..56)

d104 1
a104 2
#*The heavy worker (57..58)

d107 1
a107 2
#*Modifiers (59..60)

d111 1
a111 1
# This is not used yet (61)
a113 60
#*Trie Related (62..64)

# Behave the same as A|LIST|OF|WORDS would. The '..C' variants have  
# inline charclass data (ascii only), the 'C' store it in the structure.
# NOTE: the relative order of the TRIE-like regops  is signifigant

TRIE		TRIE,     trie 1	Match many EXACT(FL?)? at once. flags==type
TRIEC		TRIE,trie charclass	Same as TRIE, but with embedded charclass data

# For start classes, contains an added fail table.
AHOCORASICK	TRIE,        trie 1	Aho Corasick stclass. flags==type
AHOCORASICKC	TRIE,trie charclass	Same as AHOCORASICK, but with embedded charclass data

#*Regex Subroutines (65..66) 
GOSUB		GOSUB,     num/ofs 2L	recurse to paren arg1 at (signed) ofs arg2
GOSTART		GOSTART,   no   	recurse to start of pattern

#*Named references (67..69)
NREF		REF,       no-sv 1	Match some already matched string
NREFF		REF,       no-sv 1	Match already matched string, folded
NREFFL		REF,       no-sv 1	Match already matched string, folded in loc.


#*Special conditionals  (70..72)
NGROUPP		NGROUPP,   no-sv 1	Whether the group matched.            
INSUBP		INSUBP,    num 1 	Whether we are in a specific recurse.  
DEFINEP		DEFINEP,   none 1 	Never execute directly.               

#*Bactracking Verbs
ENDLIKE		ENDLIKE,   none		Used only for the type field of verbs
OPFAIL		ENDLIKE,   none 	Same as (?!)
ACCEPT		ENDLIKE,   parno 1 	Accepts the current matched string.


#*Verbs With Arguments
VERB		VERB,	   no-sv 1	Used only for the type field of verbs
PRUNE		VERB,      no-sv 1 	Pattern fails at this startpoint if no-backtracking through this 
MARKPOINT	VERB,      no-sv 1	Push the current location for rollback by cut.
SKIP		VERB,      no-sv 1	On failure skip forward (to the mark) before retrying
COMMIT		VERB,      no-sv 1	Pattern fails outright if backtracking through this
CUTGROUP	VERB,      no-sv 1	On failure go to the next alternation in the group

#*Control what to keep in $&.
KEEPS		KEEPS,  no	$& begins here.

#*New charclass like patterns
LNBREAK		LNBREAK,   none		generic newline pattern
VERTWS		VERTWS,    none		vertical whitespace         (Perl 6)
NVERTWS		NVERTWS,   none		not vertical whitespace     (Perl 6)
HORIZWS		HORIZWS,   none		horizontal whitespace       (Perl 6)
NHORIZWS	NHORIZWS,  none		not horizontal whitespace   (Perl 6)

FOLDCHAR	FOLDCHAR,  codepoint 1	codepoint with tricky case folding properties.

# NEW STUFF ABOVE THIS LINE  

################################################################################

#*SPECIAL  REGOPS

a116 31

# Special opcode with the property that no opcode in a compiled program
# will ever be of this type. Thus it can be used as a flag value that
# no other opcode has been seen. END is used similarly, in that an END
# node cant be optimized. So END implies "unoptimizable" and PSEUDO mean
# "not seen anything to optimize yet".
PSEUDO		PSEUDO,off	Pseudo opcode for internal use.

-------------------------------------------------------------------------------
# Format for second section:
# REGOP \t typelist [ \t typelist] [# Comment]
# typelist= namelist
#         = namelist:FAIL
#         = name:count

# Anything below is a state
#
#
TRIE    	next:FAIL	
EVAL    	AB:FAIL	
CURLYX  	end:FAIL	
WHILEM  	A_pre,A_min,A_max,B_min,B_max:FAIL
BRANCH  	next:FAIL	
CURLYM  	A,B:FAIL	
IFMATCH 	A:FAIL	
CURLY   	B_min_known,B_min,B_max:FAIL	
COMMIT		next:FAIL
MARKPOINT	next:FAIL
SKIP		next:FAIL
CUTGROUP	next:FAIL
KEEPS		next:FAIL
@


1.1.1.5
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d7 1
a7 1
# First section is for regops, second section is for regmatch-states
d12 1
a12 1
# NAME \s+ TYPE, arg-description [flags] [num-args] [longjump-len] ; DESCRIPTION
a15 1
# Also update perlredebguts.pod
d19 1
a19 1
#* Exit points
d21 2
a22 2
END         END,        no        ; End of program.
SUCCEED     END,        no        ; Return from a subroutine, basically.
d24 44
a67 60
#* Anchors:

BOL         BOL,        no        ; Match "" at beginning of line.
MBOL        BOL,        no        ; Same, assuming multiline.
SBOL        BOL,        no        ; Same, assuming singleline.
EOS         EOL,        no        ; Match "" at end of string.
EOL         EOL,        no        ; Match "" at end of line.
MEOL        EOL,        no        ; Same, assuming multiline.
SEOL        EOL,        no        ; Same, assuming singleline.
BOUND       BOUND,      no        ; Match "" at any word boundary using native charset semantics for non-utf8
BOUNDL      BOUND,      no        ; Match "" at any locale word boundary
BOUNDU      BOUND,      no        ; Match "" at any word boundary using Unicode semantics
BOUNDA      BOUND,      no         ; Match "" at any word boundary using ASCII semantics
# All NBOUND nodes are required by a line regexec.c to be greater than all BOUND ones
NBOUND      NBOUND,     no        ; Match "" at any word non-boundary using native charset semantics for non-utf8
NBOUNDL     NBOUND,     no        ; Match "" at any locale word non-boundary
NBOUNDU     NBOUND,     no        ; Match "" at any word non-boundary using Unicode semantics
NBOUNDA     NBOUND,     no        ; Match "" at any word non-boundary using ASCII semantics
GPOS        GPOS,       no        ; Matches where last m//g left off.

#* [Special] alternatives:

REG_ANY     REG_ANY,    no 0 S    ; Match any one character (except newline).
SANY        REG_ANY,    no 0 S    ; Match any one character.
CANY        REG_ANY,    no 0 S    ; Match any one byte.
ANYOF       ANYOF,      sv 0 S    ; Match character in (or not in) this class, single char match only
ANYOFV      ANYOF,      sv 0 V    ; Match character in (or not in) this class, can match-multiple chars
ALNUM       ALNUM,      no 0 S    ; Match any alphanumeric character using native charset semantics for non-utf8
ALNUML      ALNUM,      no 0 S    ; Match any alphanumeric char in locale
ALNUMU      ALNUM,      no 0 S    ; Match any alphanumeric char using Unicode semantics
ALNUMA      ALNUM,      no 0 S    ; Match [A-Za-z_0-9]
NALNUM      NALNUM,     no 0 S    ; Match any non-alphanumeric character using native charset semantics for non-utf8
NALNUML     NALNUM,     no 0 S    ; Match any non-alphanumeric char in locale
NALNUMU     NALNUM,     no 0 S    ; Match any non-alphanumeric char using Unicode semantics
NALNUMA     NALNUM,     no 0 S    ; Match [^A-Za-z_0-9]
SPACE       SPACE,      no 0 S    ; Match any whitespace character using native charset semantics for non-utf8
SPACEL      SPACE,      no 0 S    ; Match any whitespace char in locale
SPACEU      SPACE,      no 0 S    ; Match any whitespace char using Unicode semantics
SPACEA      SPACE,      no 0 S    ; Match [ \t\n\f\r]
NSPACE      NSPACE,     no 0 S    ; Match any non-whitespace character using native charset semantics for non-utf8
NSPACEL     NSPACE,     no 0 S    ; Match any non-whitespace char in locale
NSPACEU     NSPACE,     no 0 S    ; Match any non-whitespace char using Unicode semantics
NSPACEA     NSPACE,     no 0 S    ; Match [^ \t\n\f\r]
DIGIT       DIGIT,      no 0 S    ; Match any numeric character using native charset semantics for non-utf8
DIGITL      DIGIT,      no 0 S    ; Match any numeric character in locale
DIGITA      DIGIT,      no 0 S    ; Match [0-9]
NDIGIT      NDIGIT,     no 0 S    ; Match any non-numeric character using native charset semantics for non-utf8
NDIGITL     NDIGIT,     no 0 S    ; Match any non-numeric character in locale
NDIGITA     NDIGIT,     no 0 S    ; Match [^0-9]
CLUMP       CLUMP,      no 0 V    ; Match any extended grapheme cluster sequence

#* Alternation

# BRANCH        The set of branches constituting a single choice are hooked
#               together with their "next" pointers, since precedence prevents
#               anything being concatenated to any individual branch.  The
#               "next" pointer of the last BRANCH in a choice points to the
#               thing following the whole choice.  This is also where the
#               final "next" pointer of each individual branch points; each
#               branch starts with the operand node of a BRANCH node.
d69 1
a69 1
BRANCH      BRANCH,     node 0 V  ; Match this alternative, or the next...
d71 1
a71 1
#*Back pointer
d73 2
a74 2
# BACK          Normal "next" pointers all implicitly point forward; BACK
#               exists to make loop structures possible.
d76 1
a76 1
BACK        BACK,       no 0 V    ; Match "", "next" ptr points backward.
d78 1
a78 1
#*Literals - NOTE the relative ordering of these types is important do not change it
d80 3
a82 7
EXACT       EXACT,      str       ; Match this string (preceded by length).
EXACTF      EXACT,      str       ; Match this non-UTF-8 string (not guaranteed to be folded) using /id rules (w/len).
EXACTFL     EXACT,      str       ; Match this string (not guaranteed to be folded) using /il rules (w/len).
EXACTFU     EXACT,      str	  ; Match this string (folded iff in UTF-8, length in folding doesn't change if not in UTF-8) using /iu rules (w/len).
EXACTFU_SS  EXACT,      str	  ; Match this string (folded iff in UTF-8, length in folding may change even if not in UTF-8) using /iu rules (w/len).
EXACTFU_TRICKYFOLD EXACT,  str	  ; Match this folded UTF-8 string using /iu rules
EXACTFA     EXACT,      str	  ; Match this string (not guaranteed to be folded) using /iaa rules (w/len).
d84 1
a84 1
#*Do nothing types
d86 1
a86 1
NOTHING     NOTHING,    no        ; Match empty string.
d88 1
a88 1
TAIL        NOTHING,    no        ; Match empty string. Can jump here from outside.
d90 1
a90 1
#*Loops
d92 12
a103 12
# STAR,PLUS    '?', and complex '*' and '+', are implemented as circular
#               BRANCH structures using BACK.  Simple cases (one character
#               per match) are implemented with STAR and PLUS for speed
#               and to minimize recursive plunges.
#
STAR        STAR,       node 0 V  ; Match this (simple) thing 0 or more times.
PLUS        PLUS,       node 0 V  ; Match this (simple) thing 1 or more times.

CURLY       CURLY,      sv 2 V    ; Match this simple thing {n,m} times.
CURLYN      CURLY,      no 2 V    ; Capture next-after-this simple thing 
CURLYM      CURLY,      no 2 V    ; Capture this medium-complex thing {n,m} times. 
CURLYX      CURLY,      sv 2 V    ; Match this complex thing {n,m} times.
d106 1
a106 1
WHILEM      WHILEM,     no 0 V    ; Do curly processing and see if rest matches.
d108 1
a108 1
#*Buffer related
d110 3
a112 3
# OPEN,CLOSE,GROUPP     ...are numbered at compile time.
OPEN        OPEN,       num 1     ; Mark this point in input as start of #n.
CLOSE       CLOSE,      num 1     ; Analogous to OPEN.
d114 3
a116 8
REF         REF,        num 1 V   ; Match some already matched string
REFF        REF,        num 1 V   ; Match already matched string, folded using native charset semantics for non-utf8
REFFL       REF,        num 1 V   ; Match already matched string, folded in loc.
# N?REFF[AU] could have been implemented using the FLAGS field of the
# regnode, but by having a separate node type, we can use the existing switch
# statement to avoid some tests
REFFU       REF,        num 1 V   ; Match already matched string, folded using unicode semantics for non-utf8
REFFA       REF,        num 1 V   ; Match already matched string, folded using unicode semantics for non-utf8, no mixing ASCII, non-ASCII
d118 1
a118 6
#*Named references.  Code in regcomp.c assumes that these all are after the numbered references
NREF        REF,        no-sv 1 V ; Match some already matched string
NREFF       REF,        no-sv 1 V ; Match already matched string, folded using native charset semantics for non-utf8
NREFFL      REF,        no-sv 1 V ; Match already matched string, folded in loc.
NREFFU      REF,        num   1 V ; Match already matched string, folded using unicode semantics for non-utf8
NREFFA      REF,        num   1 V ; Match already matched string, folded using unicode semantics for non-utf8, no mixing ASCII, non-ASCII
d120 5
a124 5
IFMATCH     BRANCHJ,    off 1 . 2 ; Succeeds if the following matches.
UNLESSM     BRANCHJ,    off 1 . 2 ; Fails if the following matches.
SUSPEND     BRANCHJ,    off 1 V 1 ; "Independent" sub-RE.
IFTHEN      BRANCHJ,    off 1 V 1 ; Switch, should be preceded by switcher .
GROUPP      GROUPP,     num 1     ; Whether the group matched.
d126 1
a126 1
#*Support for long RE
d128 2
a129 2
LONGJMP     LONGJMP,    off 1 . 1 ; Jump far away.
BRANCHJ     BRANCHJ,    off 1 V 1 ; BRANCH with long offset.
d131 1
a131 1
#*The heavy worker
d133 1
a133 1
EVAL        EVAL,       evl 1     ; Execute some Perl code.
d135 1
a135 1
#*Modifiers
d137 2
a138 2
MINMOD      MINMOD,     no        ; Next operator is not greedy.
LOGICAL     LOGICAL,    no        ; Next opcode should set the flag only.
d140 2
a141 2
# This is not used yet
RENUM       BRANCHJ,    off 1 . 1 ; Group with independently numbered parens.
d143 1
a143 1
#*Trie Related
d147 1
a147 1
# NOTE: the relative order of the TRIE-like regops  is significant
d149 2
a150 2
TRIE        TRIE,       trie 1    ; Match many EXACT(F[ALU]?)? at once. flags==type
TRIEC       TRIE,trie charclass   ; Same as TRIE, but with embedded charclass data
d153 2
a154 2
AHOCORASICK     TRIE,   trie 1    ; Aho Corasick stclass. flags==type
AHOCORASICKC    TRIE,trie charclass   ; Same as AHOCORASICK, but with embedded charclass data
d156 19
a174 13
#*Regex Subroutines
GOSUB       GOSUB,      num/ofs 2L    ; recurse to paren arg1 at (signed) ofs arg2
GOSTART     GOSTART,    no        ; recurse to start of pattern

#*Special conditionals
NGROUPP     NGROUPP,    no-sv 1   ; Whether the group matched.            
INSUBP      INSUBP,     num 1     ; Whether we are in a specific recurse.  
DEFINEP     DEFINEP,    none 1    ; Never execute directly.               

#*Backtracking Verbs
ENDLIKE     ENDLIKE,    none      ; Used only for the type field of verbs
OPFAIL      ENDLIKE,    none      ; Same as (?!)
ACCEPT      ENDLIKE,    parno 1   ; Accepts the current matched string.
d178 6
a183 6
VERB        VERB,       no-sv 1   ; Used only for the type field of verbs
PRUNE       VERB,       no-sv 1   ; Pattern fails at this startpoint if no-backtracking through this 
MARKPOINT   VERB,       no-sv 1   ; Push the current location for rollback by cut.
SKIP        VERB,       no-sv 1   ; On failure skip forward (to the mark) before retrying
COMMIT      VERB,       no-sv 1   ; Pattern fails outright if backtracking through this
CUTGROUP    VERB,       no-sv 1   ; On failure go to the next alternation in the group
d186 1
a186 1
KEEPS       KEEPS,      no        ; $& begins here.
d189 5
a193 5
LNBREAK     LNBREAK,    none      ; generic newline pattern
VERTWS      VERTWS,     none 0 S  ; vertical whitespace         (Perl 6)
NVERTWS     NVERTWS,    none 0 S  ; not vertical whitespace     (Perl 6)
HORIZWS     HORIZWS,    none 0 S  ; horizontal whitespace       (Perl 6)
NHORIZWS    NHORIZWS,   none 0 S  ; not horizontal whitespace   (Perl 6)
d195 1
d197 1
a197 1
# NEW STUFF SOMEWHERE ABOVE THIS LINE
d205 1
a205 1
OPTIMIZED   NOTHING,    off       ; Placeholder for dump.
d212 1
a212 1
PSEUDO      PSEUDO,     off       ; Pseudo opcode for internal use.
d224 13
a236 13
TRIE            next:FAIL
EVAL            AB:FAIL
CURLYX          end:FAIL
WHILEM          A_pre,A_min,A_max,B_min,B_max:FAIL
BRANCH          next:FAIL
CURLYM          A,B:FAIL
IFMATCH         A:FAIL
CURLY           B_min_known,B_min,B_max:FAIL
COMMIT          next:FAIL
MARKPOINT       next:FAIL
SKIP            next:FAIL
CUTGROUP        next:FAIL
KEEPS           next:FAIL
@


1.1.1.6
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d5 1
a5 3
# Lines beginning with # are ignored, except for those that start with #*
# which are included in pod/perldebguts.pod.  # within a line may be part
# of a description.
d12 1
a12 2
# NAME \s+ TYPE, arg-description [num-args] [flags] [longjump-len] ; DESCRIPTION
#   flag <S> means is REGNODE_SIMPLE; flag <V> means is REGNODE_VARIES
d16 1
a33 5
# The regops that have varieties that vary depending on the character set regex
# modifiers have to ordered thusly: /d, /l, /u, /a, /aa.  This is because code
# in regcomp.c uses the enum value of the modifier as an offset from the /d
# version.  The complements must come after the non-complements.
# BOUND, POSIX and their complements are affected, as well as EXACTF.
d38 1
a38 1
# All NBOUND nodes are required by code in regexec.c to be greater than all BOUND ones
d51 23
a73 14
ANYOF_WARN_SUPER ANYOF, sv 0 S    ; Match character in (or not in) this class, warn (if enabled) upon matching a char above Unicode max;
ANYOF_SYNTHETIC ANYOF,  sv 0 S    ; Synthetic start class

# Order of the below is important.  See ordering comment above.
POSIXD      POSIXD,     none 0 S   ; Some [[:class:]] under /d; the FLAGS field gives which one
POSIXL      POSIXD,     none 0 S   ; Some [[:class:]] under /l; the FLAGS field gives which one
POSIXU      POSIXD,     none 0 S   ; Some [[:class:]] under /u; the FLAGS field gives which one
POSIXA      POSIXD,     none 0 S   ; Some [[:class:]] under /a; the FLAGS field gives which one
NPOSIXD     NPOSIXD,    none 0 S   ; complement of POSIXD, [[:^class:]]
NPOSIXL     NPOSIXD,    none 0 S   ; complement of POSIXL, [[:^class:]]
NPOSIXU     NPOSIXD,    none 0 S   ; complement of POSIXU, [[:^class:]]
NPOSIXA     NPOSIXD,    none 0 S   ; complement of POSIXA, [[:^class:]]
# End of order is important

d78 8
a85 9
#* BRANCH        The set of branches constituting a single choice are
#*               hooked together with their "next" pointers, since
#*               precedence prevents anything being concatenated to
#*               any individual branch.  The "next" pointer of the last
#*               BRANCH in a choice points to the thing following the
#*               whole choice.  This is also where the final "next"
#*               pointer of each individual branch points; each branch
#*               starts with the operand node of a BRANCH node.
#*
d90 3
a92 3
#* BACK          Normal "next" pointers all implicitly point forward;
#*               BACK exists to make loop structures possible.
#* not used
d95 1
a95 2
#*Literals
# NOTE: the relative ordering of these types is important do not change it
a100 1
EXACTFA     EXACT,      str	  ; Match this string (not guaranteed to be folded) using /iaa rules (w/len).
d103 1
d108 1
a108 1
#*A variant of above which delimits a group, thus stops optimizations
d113 5
a117 5
#* STAR,PLUS    '?', and complex '*' and '+', are implemented as
#*               circular BRANCH structures using BACK.  Simple cases
#*               (one character per match) are implemented with STAR
#*               and PLUS for speed and to minimize recursive plunges.
#*
d126 1
a126 1
#*This terminator creates a loop structure for CURLYX
d131 1
a131 1
#*OPEN,CLOSE,GROUPP     ...are numbered at compile time.
d144 1
a144 2
#*Named references.  Code in regcomp.c assumes that these all are after
#*the numbered references
d154 1
a154 1
IFTHEN      BRANCHJ,    off 1 V 1 ; Switch, should be preceded by switcher.
d171 1
a171 1
#*This is not used yet
d176 2
a177 3
#* Behave the same as A|LIST|OF|WORDS would. The '..C' variants
#* have inline charclass data (ascii only), the 'C' store it in the
#* structure.
d215 5
d227 2
a228 2
#* This is not really a node, but an optimized away piece of a "long"
#* node.  To simplify debugging output, we mark it as if it were a node
d231 5
a235 5
#* Special opcode with the property that no opcode in a compiled program
#* will ever be of this type. Thus it can be used as a flag value that
#* no other opcode has been seen. END is used similarly, in that an END
#* node cant be optimized. So END implies "unoptimizable" and PSEUDO
#* mean "not seen anything to optimize yet".
d240 1
a240 1
# REGOP \t typelist [ \t typelist]
@


1.1.1.7
log
@Import perl-5.20.1
@
text
@d41 1
a41 1
BOUND       BOUND,      no        ; Match "" at any word boundary using native charset rules for non-utf8
d43 2
a44 2
BOUNDU      BOUND,      no        ; Match "" at any word boundary using Unicode rules
BOUNDA      BOUND,      no         ; Match "" at any word boundary using ASCII rules
d46 1
a46 1
NBOUND      NBOUND,     no        ; Match "" at any word non-boundary using native charset rules for non-utf8
d48 2
a49 2
NBOUNDU     NBOUND,     no        ; Match "" at any word non-boundary using Unicode rules
NBOUNDA     NBOUND,     no        ; Match "" at any word non-boundary using ASCII rules
d58 2
d103 1
a103 1
EXACTFA_NO_TRIE  EXACT, str	  ; Match this string (which is not trie-able; not guaranteed to be folded) using /iaa rules (w/len).
d136 1
a136 1
REFF        REF,        num 1 V   ; Match already matched string, folded using native charset rules for non-utf8
d141 2
a142 2
REFFU       REF,        num 1 V   ; Match already matched string, folded using unicode rules for non-utf8
REFFA       REF,        num 1 V   ; Match already matched string, folded using unicode rules for non-utf8, no mixing ASCII, non-ASCII
d147 1
a147 1
NREFF       REF,        no-sv 1 V ; Match already matched string, folded using native charset rules for non-utf8
d149 2
a150 2
NREFFU      REF,        num   1 V ; Match already matched string, folded using unicode rules for non-utf8
NREFFA      REF,        num   1 V ; Match already matched string, folded using unicode rules for non-utf8, no mixing ASCII, non-ASCII
@


1.1.1.8
log
@Import perl-5.24.2
@
text
@d27 1
a27 9
#* Line Start Anchors:
#Note flags field for SBOL indicates if it is a /^/ or a /\A/
SBOL        BOL,        no        ; Match "" at beginning of line: /^/, /\A/
MBOL        BOL,        no        ; Same, assuming multiline: /^/m

#* Line End Anchors:
SEOL        EOL,        no        ; Match "" at end of line: /$/
MEOL        EOL,        no        ; Same, assuming multiline: /$/m
EOS         EOL,        no        ; Match "" at end of string: /\z/
d29 7
a35 4
#* Match Start Anchors:
GPOS        GPOS,       no        ; Matches where last m//g left off.

#* Word Boundary Opcodes:
d41 4
a44 4
BOUND       BOUND,      no        ; Like BOUNDA for non-utf8, otherwise match "" between any Unicode \w\W or \W\w
BOUNDL      BOUND,      no        ; Like BOUND/BOUNDU, but \w and \W are defined by current locale
BOUNDU      BOUND,      no        ; Match "" at any boundary of a given type using Unicode rules
BOUNDA      BOUND,      no        ; Match "" at any boundary between \w\W or \W\w, where \w is [_a-zA-Z0-9]
d46 5
a50 4
NBOUND      NBOUND,     no        ; Like NBOUNDA for non-utf8, otherwise match "" between any Unicode \w\w or \W\W
NBOUNDL     NBOUND,     no        ; Like NBOUND/NBOUNDU, but \w and \W are defined by current locale
NBOUNDU     NBOUND,     no        ; Match "" at any non-boundary of a given type using using Unicode rules
NBOUNDA     NBOUND,     no        ; Match "" betweeen any \w\w or \W\W, where \w is [_a-zA-Z0-9]
d53 1
d56 2
a57 3
ANYOF       ANYOF,      sv 1 S    ; Match character in (or not in) this class, single char match only
ANYOFD      ANYOF,      sv 1 S    ; Like ANYOF, but /d is in effect
ANYOFL      ANYOF,      sv 1 S    ; Like ANYOF, but /l is in effect
a58 1
#* POSIX Character Classes:
d85 7
a95 1
EXACTL      EXACT,      str       ; Like EXACT, but /l is in effect (used so locale-related warnings can be checked for).
a99 3

# End of important relative ordering.

a100 1
EXACTFLU8   EXACT,      str	  ; Rare cirucmstances: like EXACTFU, but is under /l, UTF-8, folded, and everything in it is above 255.
d112 1
a112 1
#*               circular BRANCH structures.  Simple cases
a149 5
#*Support for long RE
LONGJMP     LONGJMP,    off 1 . 1 ; Jump far away.
BRANCHJ     BRANCHJ,    off 1 V 1 ; BRANCH with long offset.

#*Special Case Regops
d156 4
d163 1
a163 1
EVAL        EVAL,       evl/flags 2L ; Execute some Perl code.
d189 1
d198 3
a200 2
OPFAIL      ENDLIKE,    no-sv 1   ; Same as (?!), but with verb arg
ACCEPT      ENDLIKE,    no-sv/num 2L   ; Accepts the current matched string, with verbar
@


