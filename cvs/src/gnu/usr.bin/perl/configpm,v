head	1.24;
access;
symbols
	OPENBSD_6_1:1.24.0.4
	OPENBSD_6_1_BASE:1.24
	OPENBSD_6_0:1.21.0.8
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.21.0.2
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.21.0.4
	OPENBSD_5_8_BASE:1.21
	PERL_5_20_2:1.1.1.16
	OPENBSD_5_7:1.19.0.2
	OPENBSD_5_7_BASE:1.19
	PERL_5_20_1:1.1.1.16
	OPENBSD_5_6:1.17.0.4
	OPENBSD_5_6_BASE:1.17
	PERL_5_18_2:1.1.1.15
	PERL:1.1.1
	OPENBSD_5_5:1.16.0.6
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.2
	OPENBSD_5_4_BASE:1.16
	PERL_5_16_3:1.1.1.14
	OPENBSD_5_3:1.15.0.10
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.8
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.6
	OPENBSD_5_0:1.15.0.4
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.2
	OPENBSD_4_9_BASE:1.15
	PERL_5_12_2:1.1.1.13
	OPENBSD_4_8:1.14.0.4
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.2
	OPENBSD_4_7_BASE:1.14
	PERL_5_10_1:1.1.1.12
	OPENBSD_4_6:1.13.0.6
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.2
	OPENBSD_4_5_BASE:1.13
	PERL_5_10_0:1.1.1.11
	OPENBSD_4_4:1.12.0.10
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.8
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.6
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.4
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.2
	OPENBSD_4_0_BASE:1.12
	PERL_5_8_8:1.1.1.10
	OPENBSD_3_9:1.11.0.6
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.4
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.2
	OPENBSD_3_7_BASE:1.11
	PERL_5_8_6:1.1.1.9
	OPENBSD_3_6:1.10.0.2
	OPENBSD_3_6_BASE:1.10
	PERL_5_8_5:1.1.1.8
	PERL_5_8_3:1.1.1.7
	OPENBSD_3_5:1.8.0.2
	OPENBSD_3_5_BASE:1.8
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.7.0.4
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.7.0.2
	OPENBSD_3_3_BASE:1.7
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.6.0.6
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.4
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.5.0.6
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.4
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.2
	OPENBSD_2_7_BASE:1.5
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.4.0.2
	OPENBSD_2_6_BASE:1.4
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.24
date	2017.02.05.00.33.38;	author afresh1;	state Exp;
branches;
next	1.23;
commitid	7JLVNm1wwPgqSqTa;

1.23
date	2017.02.05.00.31.52;	author afresh1;	state Exp;
branches;
next	1.22;
commitid	cxJ08BvJA9Pt2PTM;

1.22
date	2016.09.24.19.47.37;	author afresh1;	state Exp;
branches;
next	1.21;
commitid	J22IA6GBHOLqXqlb;

1.21
date	2015.04.25.19.26.15;	author afresh1;	state Exp;
branches;
next	1.20;
commitid	3qGYFVvfrExB70FB;

1.20
date	2015.04.25.19.14.37;	author afresh1;	state Exp;
branches;
next	1.19;
commitid	XRK22kO4se3v2i2I;

1.19
date	2014.11.17.21.00.55;	author afresh1;	state Exp;
branches;
next	1.18;
commitid	LnErp1MFKSuew5Fr;

1.18
date	2014.11.17.20.56.47;	author afresh1;	state Exp;
branches;
next	1.17;
commitid	QP75iYx42Uo7mMxO;

1.17
date	2014.03.24.15.05.13;	author afresh1;	state Exp;
branches;
next	1.16;

1.16
date	2013.03.25.20.40.43;	author sthen;	state Exp;
branches;
next	1.15;

1.15
date	2010.09.24.15.06.39;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2009.10.12.18.24.20;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2008.09.29.17.35.56;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2006.03.28.19.22.56;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2005.01.15.21.30.18;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2004.08.09.18.08.54;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2004.04.07.21.32.59;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2003.12.03.03.02.19;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.10.27.22.25.17;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.05.24.18.34.46;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2000.04.06.17.03.47;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	99.05.11.22.05.25;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.50.57;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.48.24;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.11.37;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.11.37;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.37.06;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.08.33;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.21.57;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.14.44;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.43.26;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.04.07.21.12.46;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.08.09.17.45.38;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2005.01.15.21.16.19;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2006.03.28.18.47.18;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2008.09.29.17.18.04;	author millert;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2009.10.12.18.10.36;	author millert;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2010.09.24.14.48.33;	author millert;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2013.03.25.20.06.16;	author sthen;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	2014.03.24.14.58.43;	author afresh1;	state Exp;
branches;
next	1.1.1.16;

1.1.1.16
date	2014.11.17.20.52.34;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.24
log
@Apply local patches - perl-5.24.1
@
text
@#!./miniperl -w
#
# configpm
#
# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
# 2002, 2003, 2004, 2005, 2006, 2007 Larry Wall and others.
#
#
# Regenerate the files
#
#    lib/Config.pm
#    lib/Config_heavy.pl
#    lib/Config.pod
#
#
# from the contents of the static files
#
#    Porting/Glossary
#    myconfig.SH
#
# and from the contents of the Configure-generated file
#
#    config.sh
#
#
# It will only update Config.pm and Config_heavy.pl if the contents of
# either file would be different. Note that *both* files are updated in
# this case, since for example an extension makefile that has a dependency
# on Config.pm should trigger even if only Config_heavy.pl has changed.

sub usage { die <<EOF }
usage: $0  [ options ]
    --no-glossary       don't include Porting/Glossary in lib/Config.pod
    --chdir=dir         change directory before writing files
EOF

use strict;
use vars qw(%Config $Config_SH_expanded);

my $how_many_common = 22;

# commonly used names to precache (and hence lookup fastest)
my %Common;

while ($how_many_common--) {
    $_ = <DATA>;
    chomp;
    /^(\S+):\s*(\d+)$/ or die "Malformed line '$_'";
    $Common{$1} = $1;
}

# Post 37589e1eefb1bd62 DynaLoader defaults to reading these at runtime.
# Ideally we're redo the data below, but Fotango's build system made it
# wonderfully easy to instrument, and no longer exists.
$Common{$_} = $_ foreach qw(dlext so);

# names of things which may need to have slashes changed to double-colons
my %Extensions = map {($_,$_)}
                 qw(dynamic_ext static_ext extensions known_extensions);

# The plan is that this information is used by ExtUtils::MakeMaker to generate
# Makefile dependencies, rather than hardcoding a list, which has become out
# of date. However, currently, MM_Unix.pm and MM_VMS.pm have *different* lists,
# *and* descrip_mms.template doesn't actually install all the headers.
# The "Unix" list seems to (attempt to) avoid the generated headers, which I'm
# not sure is the right thing to do. Also, not certain whether it would be
# easier to parse MANIFEST to get these (adding config.h, and potentially
# removing others), but for now, stick to a hard coded list.

# Could use a map to add ".h", but I suspect that it's easier to use literals,
# so that anyone using grep will find them
# This is the list from MM_VMS, plus pad.h, parser.h, utf8.h
# which it installs. It *doesn't* install perliol.h - FIXME.
my @@header_files = qw(EXTERN.h INTERN.h XSUB.h av.h config.h cop.h cv.h
		      embed.h embedvar.h form.h gv.h handy.h hv.h hv_func.h intrpvar.h
		      iperlsys.h keywords.h mg.h nostdio.h op.h opcode.h
		      pad.h parser.h patchlevel.h perl.h perlio.h perlsdio.h
		      perlvars.h perly.h pp.h pp_proto.h proto.h
		      regcomp.h regexp.h regnodes.h scope.h sv.h thread.h utf8.h
		      util.h);

push @@header_files,
    $^O eq 'VMS' ? 'vmsish.h' : qw(dosish.h perliol.h time64.h unixish.h);

my $header_files = '    return qw(' . join(' ', sort @@header_files) . ');';
$header_files =~ s/(?=.{64})   # If line is still overlength
		   (.{1,64})\  # Split at the last convenient space
		  /$1\n              /gx;

# allowed opts as well as specifies default and initial values
my %Allowed_Opts = (
    'glossary' => 1,  # --no-glossary  - no glossary file inclusion,
                      #                  for compactness
    'chdir'    => '', # --chdir=dir    - change directory before writing files
);

sub opts {
    # user specified options
    my %given_opts = (
        # --opt=smth
        (map {/^--([\-_\w]+)=(.*)$/} @@ARGV),
        # --opt --no-opt --noopt
        (map {/^no-?(.*)$/i?($1=>0):($_=>1)} map {/^--([\-_\w]+)$/} @@ARGV),
    );

    my %opts = (%Allowed_Opts, %given_opts);

    for my $opt (grep {!exists $Allowed_Opts{$_}} keys %given_opts) {
        warn "option '$opt' is not recognized";
	usage;
    }
    @@ARGV = grep {!/^--/} @@ARGV;

    return %opts;
}


my %Opts = opts();

if ($Opts{chdir}) {
    chdir $Opts{chdir} or die "$0: could not chdir $Opts{chdir}: $!"
}

my ($Config_SH, $Config_PM, $Config_heavy, $Config_POD);
my $Glossary = 'Porting/Glossary';

$Config_PM = "lib/Config.pm";
$Config_POD = "lib/Config.pod";
$Config_SH = "config.sh";

($Config_heavy = $Config_PM) =~ s/\.pm$/_heavy.pl/;
die "Can't automatically determine name for Config_heavy.pl from '$Config_PM'"
  if $Config_heavy eq $Config_PM;

my $config_txt;
my $heavy_txt;

my $export_funcs = <<'EOT';
my %Export_Cache = (myconfig => 1, config_sh => 1, config_vars => 1,
		    config_re => 1, compile_date => 1, local_patches => 1,
		    bincompat_options => 1, non_bincompat_options => 1,
		    header_files => 1);
EOT

my %export_ok = eval $export_funcs or die;

$config_txt .= sprintf << 'EOT', $], $export_funcs;
# This file was created by configpm when Perl was built. Any changes
# made to this file will be lost the next time perl is built.

# for a description of the variables, please have a look at the
# Glossary file, as written in the Porting folder, or use the url:
# http://perl5.git.perl.org/perl.git/blob/HEAD:/Porting/Glossary

package Config;
use strict;
use warnings;
use vars '%%Config', '$VERSION';

$VERSION = "%s";

# Skip @@Config::EXPORT because it only contains %%Config, which we special
# case below as it's not a function. @@Config::EXPORT won't change in the
# lifetime of Perl 5.
%s
@@Config::EXPORT = qw(%%Config);
@@Config::EXPORT_OK = keys %%Export_Cache;

# Need to stub all the functions to make code such as print Config::config_sh
# keep working

EOT

$config_txt .= "sub $_;\n" foreach sort keys %export_ok;

my $myver = sprintf "%vd", $^V;

$config_txt .= sprintf <<'ENDOFBEG', ($myver) x 3;

# Define our own import method to avoid pulling in the full Exporter:
sub import {
    shift;
    @@_ = @@Config::EXPORT unless @@_;

    my @@funcs = grep $_ ne '%%Config', @@_;
    my $export_Config = @@funcs < @@_ ? 1 : 0;

    no strict 'refs';
    my $callpkg = caller(0);
    foreach my $func (@@funcs) {
	die qq{"$func" is not exported by the Config module\n}
	    unless $Export_Cache{$func};
	*{$callpkg.'::'.$func} = \&{$func};
    }

    *{"$callpkg\::Config"} = \%%Config if $export_Config;
    return;
}

die "$0: Perl lib version (%s) doesn't match executable '$^X' version ($])"
    unless $^V;

$^V eq %s
    or die sprintf "%%s: Perl lib version (%s) doesn't match executable '$^X' version (%%vd)", $0, $^V;

ENDOFBEG


my @@non_v    = ();
my @@v_others = ();
my $in_v     = 0;
my %Data     = ();
my $quote;


my %seen_quotes;
{
  my ($name, $val);
  open(CONFIG_SH, $Config_SH) || die "Can't open $Config_SH: $!";
  while (<CONFIG_SH>) {
    next if m:^#!/bin/sh:;

    # Catch PERL_CONFIG_SH=true and PERL_VERSION=n line from Configure.
    s/^(\w+)=(true|\d+)\s*$/$1='$2'\n/ or m/^(\w+)='(.*)'$/;
    my($k, $v) = ($1, $2);

    # grandfather PATCHLEVEL and SUBVERSION and CONFIG
    if ($k) {
	if ($k eq 'PERL_VERSION') {
	    push @@v_others, "PATCHLEVEL='$v'\n";
	}
	elsif ($k eq 'PERL_SUBVERSION') {
	    push @@v_others, "SUBVERSION='$v'\n";
	}
	elsif ($k eq 'PERL_CONFIG_SH') {
	    push @@v_others, "CONFIG='$v'\n";
	}
    }

    # We can delimit things in config.sh with either ' or ". 
    unless ($in_v or m/^(\w+)=(['"])(.*\n)/){
	push(@@non_v, "#$_"); # not a name='value' line
	next;
    }
    if ($in_v) { 
        $val .= $_;
    }
    else { 
	$quote = $2;
        ($name,$val) = ($1,$3); 
    }
    $in_v = $val !~ /$quote\n/;
    next if $in_v;

    s,/,::,g if $Extensions{$name};

    $val =~ s/$quote\n?\z//;

    my $line = "$name=$quote$val$quote\n";
    push(@@v_others, $line);
    $seen_quotes{$quote}++;
  }
  close CONFIG_SH;
}

# This is somewhat grim, but I want the code for parsing config.sh here and
# now so that I can expand $Config{ivsize} and $Config{ivtype}

my $fetch_string = <<'EOT';

# Search for it in the big string
sub fetch_string {
    my($self, $key) = @@_;

EOT

if ($seen_quotes{'"'}) {
    # We need the full ' and " code

$fetch_string .= <<'EOT';
    return undef unless my ($quote_type, $value) = $Config_SH_expanded =~ /\n$key=(['"])(.*?)\1\n/s;

    # If we had a double-quote, we'd better eval it so escape
    # sequences and such can be interpolated. Since the incoming
    # value is supposed to follow shell rules and not perl rules,
    # we escape any perl variable markers

    # Historically, since " 'support' was added in change 1409, the
    # interpolation was done before the undef. Stick to this arguably buggy
    # behaviour as we're refactoring.
    if ($quote_type eq '"') {
	$value =~ s/\$/\\\$/g;
	$value =~ s/\@@/\\\@@/g;
	eval "\$value = \"$value\"";
    }

    # So we can say "if $Config{'foo'}".
    $self->{$key} = $value eq 'undef' ? undef : $value; # cache it
}
EOT

} else {
    # We only have ' delimited.

$fetch_string .= <<'EOT';
    return undef unless $Config_SH_expanded =~ /\n$key=\'(.*?)\'\n/s;
    # So we can say "if $Config{'foo'}".
    $self->{$key} = $1 eq 'undef' ? undef : $1;
}
EOT

}

eval $fetch_string;
die if $@@;

# Calculation for the keys for byteorder
# This is somewhat grim, but I need to run fetch_string here.
our $Config_SH_expanded = join "\n", '', @@v_others;

my $t = fetch_string ({}, 'ivtype');
my $s = fetch_string ({}, 'ivsize');

# byteorder does exist on its own but we overlay a virtual
# dynamically recomputed value.

# However, ivtype and ivsize will not vary for sane fat binaries

my $f = $t eq 'long' ? 'L!' : $s == 8 ? 'Q': 'I';

my $byteorder_code;
if ($s == 4 || $s == 8) {
    my $list = join ',', reverse(1..$s-1);
    my $format = 'a'x$s;
    $byteorder_code = <<"EOT";

my \$i = ord($s);
foreach my \$c ($list) { \$i <<= 8; \$i |= ord(\$c); }
our \$byteorder = join('', unpack('$format', pack('$f', \$i)));
EOT
} else {
    $byteorder_code = "our \$byteorder = '?'x$s;\n";
}

my @@need_relocation;

if (fetch_string({},'userelocatableinc')) {
    foreach my $what (qw(prefixexp

			 archlibexp
			 html1direxp
			 html3direxp
			 man1direxp
			 man3direxp
			 privlibexp
			 scriptdirexp
			 sitearchexp
			 sitebinexp
			 sitehtml1direxp
			 sitehtml3direxp
			 sitelibexp
			 siteman1direxp
			 siteman3direxp
			 sitescriptexp
			 vendorarchexp
			 vendorbinexp
			 vendorhtml1direxp
			 vendorhtml3direxp
			 vendorlibexp
			 vendorman1direxp
			 vendorman3direxp
			 vendorscriptexp

			 siteprefixexp
			 sitelib_stem
			 vendorlib_stem

			 installarchlib
			 installhtml1dir
			 installhtml3dir
			 installman1dir
			 installman3dir
			 installprefix
			 installprefixexp
			 installprivlib
			 installscript
			 installsitearch
			 installsitebin
			 installsitehtml1dir
			 installsitehtml3dir
			 installsitelib
			 installsiteman1dir
			 installsiteman3dir
			 installsitescript
			 installvendorarch
			 installvendorbin
			 installvendorhtml1dir
			 installvendorhtml3dir
			 installvendorlib
			 installvendorman1dir
			 installvendorman3dir
			 installvendorscript
			 )) {
	push @@need_relocation, $what if fetch_string({}, $what) =~ m!^\.\.\./!;
    }
}

my %need_relocation;
@@need_relocation{@@need_relocation} = @@need_relocation;

# This can have .../ anywhere:
if (fetch_string({}, 'otherlibdirs') =~ m!\.\.\./!) {
    $need_relocation{otherlibdirs} = 'otherlibdirs';
}

my $relocation_code = <<'EOT';

sub relocate_inc {
  my $libdir = shift;
  return $libdir unless $libdir =~ s!^\.\.\./!!;
  my $prefix = $^X;
  if ($prefix =~ s!/[^/]*$!!) {
    while ($libdir =~ m!^\.\./!) {
      # Loop while $libdir starts "../" and $prefix still has a trailing
      # directory
      last unless $prefix =~ s!/([^/]+)$!!;
      # but bail out if the directory we picked off the end of $prefix is .
      # or ..
      if ($1 eq '.' or $1 eq '..') {
	# Undo! This should be rare, hence code it this way rather than a
	# check each time before the s!!! above.
	$prefix = "$prefix/$1";
	last;
      }
      # Remove that leading ../ and loop again
      substr ($libdir, 0, 3, '');
    }
    $libdir = "$prefix/$libdir";
  }
  $libdir;
}
EOT

my $osname = fetch_string({}, 'osname');
my $from = $osname eq 'VMS' ? 'PERLSHR image' : 'binary (from libperl)';
my $env_cygwin = $osname eq 'cygwin'
    ? 'push @@env, "CYGWIN=\"$ENV{CYGWIN}\"" if $ENV{CYGWIN};' . "\n" : "";

$heavy_txt .= sprintf <<'ENDOFBEG', $osname, $osname, $from, $osname, $env_cygwin;
# This file was created by configpm when Perl was built. Any changes
# made to this file will be lost the next time perl is built.

package Config;
use strict;
use warnings;
use vars '%%Config';

sub bincompat_options {
    return split ' ', (Internals::V())[0];
}

sub non_bincompat_options {
    return split ' ', (Internals::V())[1];
}

sub compile_date {
    return (Internals::V())[2]
}

sub local_patches {
    my (undef, undef, undef, @@patches) = Internals::V();
    return @@patches;
}

sub _V {
    die "Perl lib was built for '%s' but is being run on '$^O'"
        unless "%s" eq $^O;

    my ($bincompat, $non_bincompat, $date, @@patches) = Internals::V();

    my $opts = join ' ', sort split ' ', "$bincompat $non_bincompat";

    # wrap at 76 columns.

    $opts =~ s/(?=.{53})(.{1,53}) /$1\n                        /mg;

    print Config::myconfig();
    print "\nCharacteristics of this %s: \n";

    print "  Compile-time options: $opts\n";

    if (@@patches) {
        print "  Locally applied patches:\n";
        print "\t$_\n" foreach @@patches;
    }

    print "  Built under %s\n";

    print "  $date\n" if defined $date;

    my @@env = map { "$_=\"$ENV{$_}\"" } sort grep {/^PERL/} keys %%ENV;
%s
    if (@@env) {
        print "  \%%ENV:\n";
        print "    $_\n" foreach @@env;
    }
    print "  \@@INC:\n";
    print "    $_\n" foreach @@INC;
}

sub header_files {
ENDOFBEG

$heavy_txt .= $header_files . "\n}\n\n";

if (%need_relocation) {
  my $relocations_in_common;
  # otherlibdirs only features in the hash
  foreach (keys %need_relocation) {
    $relocations_in_common++ if $Common{$_};
  }
  if ($relocations_in_common) {
    $config_txt .= $relocation_code;
  } else {
    $heavy_txt .= $relocation_code;
  }
}

$heavy_txt .= join('', @@non_v) . "\n";

# copy config summary format from the myconfig.SH script
$heavy_txt .= "our \$summary = <<'!END!';\n";
open(MYCONFIG,"<myconfig.SH") || die "open myconfig.SH failed: $!";
1 while defined($_ = <MYCONFIG>) && !/^Summary of/;
do { $heavy_txt .= $_ } until !defined($_ = <MYCONFIG>) || /^\s*$/;
close(MYCONFIG);

$heavy_txt .= "\n!END!\n" . <<'EOT';
my $summary_expanded;

sub myconfig {
    return $summary_expanded if $summary_expanded;
    ($summary_expanded = $summary) =~ s{\$(\w+)}
		 { 
			my $c;
			if ($1 eq 'git_ancestor_line') {
				if ($Config::Config{git_ancestor}) {
					$c= "\n  Ancestor: $Config::Config{git_ancestor}";
				} else {
					$c= "";
				}
			} else {
                     		$c = $Config::Config{$1}; 
			}
			defined($c) ? $c : 'undef' 
		}ge;
    $summary_expanded;
}

local *_ = \my $a;
$_ = <<'!END!';
EOT

$heavy_txt .= join('', sort @@v_others) . "!END!\n";

# Only need the dynamic byteorder code in Config.pm if 'byteorder' is one of
# the precached keys
if ($Common{byteorder}) {
    $config_txt .= $byteorder_code;
} else {
    $heavy_txt .= $byteorder_code;
}

if (@@need_relocation) {
$heavy_txt .= 'foreach my $what (qw(' . join (' ', @@need_relocation) .
      ")) {\n" . <<'EOT';
    s/^($what=)(['"])(.*?)\2/$1 . $2 . relocate_inc($3) . $2/me;
}
EOT
# Currently it only makes sense to do the ... relocation on Unix, so there's
# no need to emulate the "which separator for this platform" logic in perl.c -
# ':' will always be applicable
if ($need_relocation{otherlibdirs}) {
$heavy_txt .= << 'EOT';
s{^(otherlibdirs=)(['"])(.*?)\2}
 {$1 . $2 . join ':', map {relocate_inc($_)} split ':', $3 . $2}me;
EOT
}
}

$heavy_txt .= <<'EOT';
s/(byteorder=)(['"]).*?\2/$1$2$Config::byteorder$2/m;

my $config_sh_len = length $_;

our $Config_SH_expanded = "\n$_" . << 'EOVIRTUAL';
EOT

foreach my $prefix (qw(ccflags ldflags)) {
    my $value = fetch_string ({}, $prefix);
    my $withlargefiles = fetch_string ({}, $prefix . "_uselargefiles");
    if (defined $withlargefiles) {
        $value =~ s/\Q$withlargefiles\E\b//;
        $heavy_txt .= "${prefix}_nolargefiles='$value'\n";
    }
}

foreach my $prefix (qw(libs libswanted)) {
    my $value = fetch_string ({}, $prefix);
    my $withlf = fetch_string ({}, 'libswanted_uselargefiles');
    next unless defined $withlf;
    my @@lflibswanted
       = split(' ', fetch_string ({}, 'libswanted_uselargefiles'));
    if (@@lflibswanted) {
	my %lflibswanted;
	@@lflibswanted{@@lflibswanted} = ();
	if ($prefix eq 'libs') {
	    my @@libs = grep { /^-l(.+)/ &&
                            not exists $lflibswanted{$1} }
		                    split(' ', fetch_string ({}, 'libs'));
	    $value = join(' ', @@libs);
	} else {
	    my @@libswanted = grep { not exists $lflibswanted{$_} }
	                          split(' ', fetch_string ({}, 'libswanted'));
	    $value = join(' ', @@libswanted);
	}
    }
    $heavy_txt .= "${prefix}_nolargefiles='$value'\n";
}

if (open(my $fh, "cflags")) {
    my $ccwarnflags;
    my $ccstdflags;
    while (<$fh>) {
        if (/^warn="(.+)"$/) {
            $ccwarnflags = $1;
        } elsif (/^stdflags="(.+)"$/) {
            $ccstdflags = $1;
        }
    }
    if (defined $ccwarnflags) {
      $heavy_txt .= "ccwarnflags='$ccwarnflags'\n";
    }
    if (defined $ccstdflags) {
      $heavy_txt .= "ccstdflags='$ccstdflags'\n";
    }
}

$heavy_txt .= "EOVIRTUAL\n";

$heavy_txt .= <<'ENDOFGIT';
eval {
	# do not have hairy conniptions if this isnt available
	require 'Config_git.pl';
	$Config_SH_expanded .= $Config::Git_Data;
	1;
} or warn "Warning: failed to load Config_git.pl, something strange about this perl...\n";
ENDOFGIT

$heavy_txt .= $fetch_string;

$config_txt .= <<'ENDOFEND';

sub FETCH {
    my($self, $key) = @@_;

    # check for cached value (which may be undef so we use exists not defined)
    return exists $self->{$key} ? $self->{$key} : $self->fetch_string($key);
}

ENDOFEND

$heavy_txt .= <<'ENDOFEND';

my $prevpos = 0;

sub FIRSTKEY {
    $prevpos = 0;
    substr($Config_SH_expanded, 1, index($Config_SH_expanded, '=') - 1 );
}

sub NEXTKEY {
ENDOFEND
if ($seen_quotes{'"'}) {
$heavy_txt .= <<'ENDOFEND';
    # Find out how the current key's quoted so we can skip to its end.
    my $quote = substr($Config_SH_expanded,
		       index($Config_SH_expanded, "=", $prevpos)+1, 1);
    my $pos = index($Config_SH_expanded, qq($quote\n), $prevpos) + 2;
ENDOFEND
} else {
    # Just ' quotes, so it's much easier.
$heavy_txt .= <<'ENDOFEND';
    my $pos = index($Config_SH_expanded, qq('\n), $prevpos) + 2;
ENDOFEND
}
$heavy_txt .= <<'ENDOFEND';
    my $len = index($Config_SH_expanded, "=", $pos) - $pos;
    $prevpos = $pos;
    $len > 0 ? substr($Config_SH_expanded, $pos, $len) : undef;
}

sub EXISTS {
    return 1 if exists($_[0]->{$_[1]});

    return(index($Config_SH_expanded, "\n$_[1]='") != -1
ENDOFEND
if ($seen_quotes{'"'}) {
$heavy_txt .= <<'ENDOFEND';
           or index($Config_SH_expanded, "\n$_[1]=\"") != -1
ENDOFEND
}
$heavy_txt .= <<'ENDOFEND';
          );
}

sub STORE  { die "\%Config::Config is read-only\n" }
*DELETE = *CLEAR = \*STORE; # Typeglob aliasing uses less space

sub config_sh {
    substr $Config_SH_expanded, 1, $config_sh_len;
}

sub config_re {
    my $re = shift;
    return map { chomp; $_ } grep eval{ /^(?:$re)=/ }, split /^/,
    $Config_SH_expanded;
}

sub config_vars {
    # implements -V:cfgvar option (see perlrun -V:)
    foreach (@@_) {
	# find optional leading, trailing colons; and query-spec
	my ($notag,$qry,$lncont) = m/^(:)?(.*?)(:)?$/;	# flags fore and aft, 
	# map colon-flags to print decorations
	my $prfx = $notag ? '': "$qry=";		# tag-prefix for print
	my $lnend = $lncont ? ' ' : ";\n";		# line ending for print

	# all config-vars are by definition \w only, any \W means regex
	if ($qry =~ /\W/) {
	    my @@matches = config_re($qry);
	    print map "$_$lnend", @@matches ? @@matches : "$qry: not found"		if !$notag;
	    print map { s/\w+=//; "$_$lnend" } @@matches ? @@matches : "$qry: not found"	if  $notag;
	} else {
	    my $v = (exists $Config::Config{$qry}) ? $Config::Config{$qry}
						   : 'UNKNOWN';
	    $v = 'undef' unless defined $v;
	    print "${prfx}'${v}'$lnend";
	}
    }
}

# Called by the real AUTOLOAD
sub launcher {
    undef &AUTOLOAD;
    goto \&$Config::AUTOLOAD;
}

1;
ENDOFEND

if ($^O eq 'os2') {
    $config_txt .= <<'ENDOFSET';
my %preconfig;
if ($OS2::is_aout) {
    my ($value, $v) = $Config_SH_expanded =~ m/^used_aout='(.*)'\s*$/m;
    for (split ' ', $value) {
        ($v) = $Config_SH_expanded =~ m/^aout_$_='(.*)'\s*$/m;
        $preconfig{$_} = $v eq 'undef' ? undef : $v;
    }
}
$preconfig{d_fork} = undef unless $OS2::can_fork; # Some funny cases can't
sub TIEHASH { bless {%preconfig} }
ENDOFSET
    # Extract the name of the DLL from the makefile to avoid duplication
    my ($f) = grep -r, qw(GNUMakefile Makefile);
    my $dll;
    if (open my $fh, '<', $f) {
	while (<$fh>) {
	    $dll = $1, last if /^PERL_DLL_BASE\s*=\s*(\S*)\s*$/;
	}
    }
    $config_txt .= <<ENDOFSET if $dll;
\$preconfig{dll_name} = '$dll';
ENDOFSET
} else {
    $config_txt .= <<'ENDOFSET';
sub TIEHASH {
    bless $_[1], $_[0];
}
ENDOFSET
}

foreach my $key (keys %Common) {
    my $value = fetch_string ({}, $key);
    # Is it safe on the LHS of => ?
    my $qkey = $key =~ /^[A-Za-z_][A-Za-z0-9_]*$/ ? $key : "'$key'";
    if (defined $value) {
	# Quote things for a '' string
	$value =~ s!\\!\\\\!g;
	$value =~ s!'!\\'!g;
	$value = "'$value'";
	if ($key eq 'otherlibdirs') {
	    $value = "join (':', map {relocate_inc(\$_)} split (':', $value))";
	} elsif ($need_relocation{$key}) {
	    $value = "relocate_inc($value)";
	}
    } else {
	$value = "undef";
    }
    $Common{$key} = "$qkey => $value";
}

if ($Common{byteorder}) {
    $Common{byteorder} = 'byteorder => $byteorder';
}
my $fast_config = join '', map { "    $_,\n" } sort values %Common;

# Sanity check needed to stop an infinite loop if Config_heavy.pl fails to
# define &launcher for some reason (eg it got truncated)
$config_txt .= sprintf <<'ENDOFTIE', $fast_config;

sub DESTROY { }

sub AUTOLOAD {
    require 'Config_heavy.pl';
    goto \&launcher unless $Config::AUTOLOAD =~ /launcher$/;
    die "&Config::AUTOLOAD failed on $Config::AUTOLOAD";
}

# tie returns the object, so the value returned to require will be true.
tie %%Config, 'Config', {
%s};
ENDOFTIE


open(CONFIG_POD, ">$Config_POD") or die "Can't open $Config_POD: $!";
print CONFIG_POD <<'ENDOFTAIL';
=head1 NAME

Config - access Perl configuration information

=head1 SYNOPSIS

    use Config;
    if ($Config{usethreads}) {
	print "has thread support\n"
    } 

    use Config qw(myconfig config_sh config_vars config_re);

    print myconfig();

    print config_sh();

    print config_re();

    config_vars(qw(osname archname));


=head1 DESCRIPTION

The Config module contains all the information that was available to
the C<Configure> program at Perl build time (over 900 values).

Shell variables from the F<config.sh> file (written by Configure) are
stored in the readonly-variable C<%Config>, indexed by their names.

Values stored in config.sh as 'undef' are returned as undefined
values.  The perl C<exists> function can be used to check if a
named variable exists.

For a description of the variables, please have a look at the
Glossary file, as written in the Porting folder, or use the url:
http://perl5.git.perl.org/perl.git/blob/HEAD:/Porting/Glossary

=over 4

=item myconfig()

Returns a textual summary of the major perl configuration values.
See also C<-V> in L<perlrun/Command Switches>.

=item config_sh()

Returns the entire perl configuration information in the form of the
original config.sh shell variable assignment script.

=item config_re($regex)

Like config_sh() but returns, as a list, only the config entries who's
names match the $regex.

=item config_vars(@@names)

Prints to STDOUT the values of the named configuration variable. Each is
printed on a separate line in the form:

  name='value';

Names which are unknown are output as C<name='UNKNOWN';>.
See also C<-V:name> in L<perlrun/Command Switches>.

=item bincompat_options()

Returns a list of C pre-processor options used when compiling this F<perl>
binary, which affect its binary compatibility with extensions.
C<bincompat_options()> and C<non_bincompat_options()> are shown together in
the output of C<perl -V> as I<Compile-time options>.

=item non_bincompat_options()

Returns a list of C pre-processor options used when compiling this F<perl>
binary, which do not affect binary compatibility with extensions.

=item compile_date()

Returns the compile date (as a string), equivalent to what is shown by
C<perl -V>

=item local_patches()

Returns a list of the names of locally applied patches, equivalent to what
is shown by C<perl -V>.

=item header_files()

Returns a list of the header files that should be used as dependencies for
XS code, for this version of Perl on this platform.

=back

=head1 EXAMPLE

Here's a more sophisticated example of using %Config:

    use Config;
    use strict;

    my %sig_num;
    my @@sig_name;
    unless($Config{sig_name} && $Config{sig_num}) {
	die "No sigs?";
    } else {
	my @@names = split ' ', $Config{sig_name};
	@@sig_num{@@names} = split ' ', $Config{sig_num};
	foreach (@@names) {
	    $sig_name[$sig_num{$_}] ||= $_;
	}   
    }

    print "signal #17 = $sig_name[17]\n";
    if ($sig_num{ALRM}) { 
	print "SIGALRM is $sig_num{ALRM}\n";
    }   

=head1 WARNING

Because this information is not stored within the perl executable
itself it is possible (but unlikely) that the information does not
relate to the actual perl binary which is being used to access it.

The Config module is installed into the architecture and version
specific library directory ($Config{installarchlib}) and it checks the
perl version number when loaded.

The values stored in config.sh may be either single-quoted or
double-quoted. Double-quoted strings are handy for those cases where you
need to include escape sequences in the strings. To avoid runtime variable
interpolation, any C<$> and C<@@> characters are replaced by C<\$> and
C<\@@>, respectively. This isn't foolproof, of course, so don't embed C<\$>
or C<\@@> in double-quoted strings unless you're willing to deal with the
consequences. (The slashes will end up escaped and the C<$> or C<@@> will
trigger variable interpolation)

=head1 GLOSSARY

Most C<Config> variables are determined by the C<Configure> script
on platforms supported by it (which is most UNIX platforms).  Some
platforms have custom-made C<Config> variables, and may thus not have
some of the variables described below, or may have extraneous variables
specific to that particular port.  See the port specific documentation
in such cases.

=cut

ENDOFTAIL

if ($Opts{glossary}) {
  open(GLOS, "<$Glossary") or die "Can't open $Glossary: $!";
}
my %seen = ();
my $text = 0;
$/ = '';
my $errors= 0;

sub process {
  if (s/\A(\w*)\s+\(([\w.]+)\):\s*\n(\t?)/=item C<$1>\n\nFrom F<$2>:\n\n/m) {
    my $c = substr $1, 0, 1;
    unless ($seen{$c}++) {
      print CONFIG_POD <<EOF if $text;
=back

=cut

EOF
      print CONFIG_POD <<EOF;
=head2 $c

=over 4

=cut

EOF
     $text = 1;
    }
  }
  elsif (!$text || !/\A\t/) {
    warn "Expected a Configure variable header",
      ($text ? " or another paragraph of description" : () ),
      ", instead we got:\n$_";
    $errors++;
  }
  s/n't/n\00t/g;		# leave can't, won't etc untouched
  s/^\t\s+(.*)/\n$1/gm;		# Indented lines ===> new paragraph
  s/^(?<!\n\n)\t(.*)/$1/gm;	# Not indented lines ===> text
  s{([\'\"])(?=[^\'\"\s]*[./][^\'\"\s]*\1)([^\'\"\s]+)\1}(F<$2>)g; # '.o'
  s{([\'\"])([^\'\"\s]+)\1}(C<$2>)g; # "date" command
  s{\'([A-Za-z_\- *=/]+)\'}(C<$1>)g; # 'ln -s'
  s{
     (?<! [\w./<\'\"\$] )		# Only standalone file names
     (?! e \. g \. )		# Not e.g.
     (?! \. \. \. )		# Not ...
     (?! \d )			# Not 5.004
     (?! read/ )		# Not read/write
     (?! etc\. )		# Not etc.
     (?! I/O )			# Not I/O
     (
	\$ ?			# Allow leading $
	[\w./]* [./] [\w./]*	# Require . or / inside
     )
     (?<! \. (?= [\s)] ) )	# Do not include trailing dot
     (?! [\w/] )		# Include all of it
   }
   (F<$1>)xg;			# /usr/local
  s/((?<=\s)~\w*)/F<$1>/g;	# ~name
  s/(?<![.<\'\"])\b([A-Z_]{2,})\b(?![\'\"])/C<$1>/g;	# UNISTD
  s/(?<![.<\'\"])\b(?!the\b)(\w+)\s+macro\b/C<$1> macro/g; # FILE_cnt macro
  s/n[\0]t/n't/g;		# undo can't, won't damage
}

if ($Opts{glossary}) {
    <GLOS>;				# Skip the "DO NOT EDIT"
    <GLOS>;				# Skip the preamble
  while (<GLOS>) {
    process;
    print CONFIG_POD;
  }
  if ($errors) {
    die "Errors encountered while processing $Glossary. ",
        "Header lines are expected to be of the form:\n",
        "NAME (CLASS):\n",
        "Maybe there is a malformed header?\n",
    ;
  }
}

print CONFIG_POD <<'ENDOFTAIL';

=back

=head1 GIT DATA

Information on the git commit from which the current perl binary was compiled
can be found in the variable C<$Config::Git_Data>.  The variable is a
structured string that looks something like this:

  git_commit_id='ea0c2dbd5f5ac6845ecc7ec6696415bf8e27bd52'
  git_describe='GitLive-blead-1076-gea0c2db'
  git_branch='smartmatch'
  git_uncommitted_changes=''
  git_commit_id_title='Commit id:'
  git_commit_date='2009-05-09 17:47:31 +0200'

Its format is not guaranteed not to change over time.

=head1 NOTE

This module contains a good example of how to use tie to implement a
cache and an example of how to make a tied variable readonly to those
outside of it.

=cut

ENDOFTAIL

close(GLOS) if $Opts{glossary};
close(CONFIG_POD);
print "written $Config_POD\n";

my $orig_config_txt = "";
my $orig_heavy_txt = "";
{
    local $/;
    my $fh;
    $orig_config_txt = <$fh> if open $fh, "<", $Config_PM;
    $orig_heavy_txt  = <$fh> if open $fh, "<", $Config_heavy;
}

if ($orig_config_txt ne $config_txt or $orig_heavy_txt ne $heavy_txt) {
    # During the build don't look in /usr/local for libs or includes
    # but after, we want to let modules look there.
    my $install_heavy_txt = $heavy_txt;
    $install_heavy_txt =~ s,^(ccflags|cppflags)[^=]*='[^']+,$& -I/usr/local/include,gm;
    $install_heavy_txt =~ s,^(ldflags|lddlflags)[^=]*='[^']+,$& -L/usr/local/lib,gm;

    open INSTALL_CONFIG_HEAVY, ">", "$Config_heavy.install"
         or die "Can't open install $Config_heavy: $!\n";
    print INSTALL_CONFIG_HEAVY $install_heavy_txt;
    close INSTALL_CONFIG_HEAVY;
    print "updated install $Config_heavy\n";

    open CONFIG, ">", $Config_PM or die "Can't open $Config_PM: $!\n";
    open CONFIG_HEAVY, ">", $Config_heavy or die "Can't open $Config_heavy: $!\n";
    print CONFIG $config_txt;
    print CONFIG_HEAVY $heavy_txt;
    close(CONFIG_HEAVY);
    close(CONFIG);
    print "updated $Config_PM\n";
    print "updated $Config_heavy\n";
}

# Now do some simple tests on the Config.pm file we have created
unshift(@@INC,'lib');
require $Config_PM;
require $Config_heavy;
import Config;

die "$0: $Config_PM not valid"
	unless $Config{'PERL_CONFIG_SH'} eq 'true';

die "$0: error processing $Config_PM"
	if defined($Config{'an impossible name'})
	or $Config{'PERL_CONFIG_SH'} ne 'true' # test cache
	;

die "$0: error processing $Config_PM"
	if eval '$Config{"cc"} = 1'
	or eval 'delete $Config{"cc"}'
	;


exit 0;
# Popularity of various entries in %Config, based on a large build and test
# run of code in the Fotango build system:
__DATA__
path_sep:	8490
d_readlink:	7101
d_symlink:	7101
archlibexp:	4318
sitearchexp:	4305
sitelibexp:	4305
privlibexp:	4163
ldlibpthname:	4041
libpth:	2134
archname:	1591
exe_ext:	1256
scriptdir:	1155
version:	1116
useithreads:	1002
osvers:	982
osname:	851
inc_version_list:	783
dont_use_nlink:	779
intsize:	759
usevendorprefix:	642
dlsrc:	624
cc:	541
lib_ext:	520
so:	512
ld:	501
ccdlflags:	500
ldflags:	495
obj_ext:	495
cccdlflags:	493
lddlflags:	493
ar:	492
dlext:	492
libc:	492
ranlib:	492
full_ar:	491
vendorarchexp:	491
vendorlibexp:	491
installman1dir:	489
installman3dir:	489
installsitebin:	489
installsiteman1dir:	489
installsiteman3dir:	489
installvendorman1dir:	489
installvendorman3dir:	489
d_flexfnam:	474
eunicefix:	360
d_link:	347
installsitearch:	344
installscript:	341
installprivlib:	337
binexp:	336
installarchlib:	336
installprefixexp:	336
installsitelib:	336
installstyle:	336
installvendorarch:	336
installvendorbin:	336
installvendorlib:	336
man1ext:	336
man3ext:	336
sh:	336
siteprefixexp:	336
installbin:	335
usedl:	332
ccflags:	285
startperl:	232
optimize:	231
usemymalloc:	229
cpprun:	228
sharpbang:	228
perllibs:	225
usesfio:	224
usethreads:	220
perlpath:	218
extensions:	217
usesocks:	208
shellflags:	198
make:	191
d_pwage:	189
d_pwchange:	189
d_pwclass:	189
d_pwcomment:	189
d_pwexpire:	189
d_pwgecos:	189
d_pwpasswd:	189
d_pwquota:	189
gccversion:	189
libs:	186
useshrplib:	186
cppflags:	185
ptrsize:	185
shrpenv:	185
static_ext:	185
use5005threads:	185
uselargefiles:	185
alignbytes:	184
byteorder:	184
ccversion:	184
config_args:	184
cppminus:	184
@


1.23
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@d1111 12
@


1.22
log
@Build install Config_heavy.pl during build not install

Needed for noperm builds

OK natano@@
@
text
@a89 5
# libpaths that should be truncated after the first path element
my %Libpathtrunc = map {($_,$_)}
                   qw(archlib archlibexp privlib privlibexp sitearch sitearchexp
                      sitelib sitelibexp);

a254 3
    # XXX - should use PERLLIB_SEP, not hard-code ':'
    $val =~ s/^([^:]+).*${quote}\w*$/$1${quote}/ if $Libpathtrunc{$name};

d631 18
a1110 12
    # During the build don't look in /usr/local for libs or includes
    # but after, we want to let modules look there.
    my $install_heavy_txt = $heavy_txt;
    $install_heavy_txt =~ s,^(ccflags|cppflags)[^=]*='[^']+,$& -I/usr/local/include,gm;
    $install_heavy_txt =~ s,^(ldflags|lddlflags)[^=]*='[^']+,$& -L/usr/local/lib,gm;

    open INSTALL_CONFIG_HEAVY, ">", "$Config_heavy.install"
         or die "Can't open install $Config_heavy: $!\n";
    print INSTALL_CONFIG_HEAVY $install_heavy_txt;
    close INSTALL_CONFIG_HEAVY;
    print "updated install $Config_heavy\n";

@


1.21
log
@Apply local patches, remove excess files - perl-5.20.2
@
text
@d1101 12
@


1.20
log
@Fix merge issues, remove excess files - match perl-5.20.2 dist
@
text
@d90 5
d259 3
@


1.19
log
@Apply local patches to perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@a89 5
# libpaths that should be truncated after the first path element
my %Libpathtrunc = map {($_,$_)}
                   qw(archlib archlibexp privlib privlibexp sitearch sitearchexp
                      sitelib sitelibexp);

a253 3

    # XXX - should use PERLLIB_SEP, not hard-code ':'
    $val =~ s/^([^:]+).*${quote}\w*$/$1${quote}/ if $Libpathtrunc{$name};
@


1.18
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d90 5
d259 3
@


1.17
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@a13 1
#    lib/Cross.pm (optionally)
a24 1
# Note that output directory is xlib/[cross-name]/ for cross-compiling
a32 1
    --cross=PLATFORM    cross-compile for a different platform
d72 1
a72 1
# This is the list from MM_VMS, plus pad.h, parser.h, perlsfio.h utf8.h
d78 1
a78 1
		      perlsfio.h perlvars.h perly.h pp.h pp_proto.h proto.h
a81 1
# No point in adding fakethr.h, as it no longer works
a89 5
# libpaths that should be truncated after the first path element
my %Libpathtrunc = map {($_,$_)}
                   qw(archlib archlibexp privlib privlibexp sitearch sitearchexp
                      sitelib sitelibexp);

a91 1
    'cross'    => '', # --cross=PLATFORM - crosscompiling for PLATFORM
d127 4
a130 13
if ($Opts{cross}) {
  # creating cross-platform config file
  mkdir "xlib";
  mkdir "xlib/$Opts{cross}";
  $Config_PM = "xlib/$Opts{cross}/Config.pm";
  $Config_POD = "xlib/$Opts{cross}/Config.pod";
  $Config_SH = "Cross/config-$Opts{cross}.sh";
}
else {
  $Config_PM = "lib/Config.pm";
  $Config_POD = "lib/Config.pod";
  $Config_SH = "config.sh";
}
a137 70
my $from = $^O eq 'VMS' ? 'PERLSHR image' : 'binary (from libperl)';
my $env_cygwin = $^O eq 'cygwin'
    ? 'push @@env, "CYGWIN=\"$ENV{CYGWIN}\"" if $ENV{CYGWIN};' . "\n" : "";
$heavy_txt .= sprintf <<'ENDOFBEG', $^O, $^O, $from, $^O, $env_cygwin;
# This file was created by configpm when Perl was built. Any changes
# made to this file will be lost the next time perl is built.

package Config;
use strict;
use warnings;
use vars '%%Config';

sub bincompat_options {
    return split ' ', (Internals::V())[0];
}

sub non_bincompat_options {
    return split ' ', (Internals::V())[1];
}

sub compile_date {
    return (Internals::V())[2]
}

sub local_patches {
    my (undef, undef, undef, @@patches) = Internals::V();
    return @@patches;
}

sub _V {
    die "Perl lib was built for '%s' but is being run on '$^O'"
        unless "%s" eq $^O;

    my ($bincompat, $non_bincompat, $date, @@patches) = Internals::V();

    my $opts = join ' ', sort split ' ', "$bincompat $non_bincompat";

    # wrap at 76 columns.

    $opts =~ s/(?=.{53})(.{1,53}) /$1\n                        /mg;

    print Config::myconfig();
    print "\nCharacteristics of this %s: \n";

    print "  Compile-time options: $opts\n";

    if (@@patches) {
        print "  Locally applied patches:\n";
        print "\t$_\n" foreach @@patches;
    }

    print "  Built under %s\n";

    print "  $date\n" if defined $date;

    my @@env = map { "$_=\"$ENV{$_}\"" } sort grep {/^PERL/} keys %%ENV;
%s
    if (@@env) {
        print "  \%%ENV:\n";
        print "    $_\n" foreach @@env;
    }
    print "  \@@INC:\n";
    print "    $_\n" foreach @@INC;
}

sub header_files {
ENDOFBEG

$heavy_txt .= $header_files . "\n}\n\n";

d200 1
a200 1
die "Perl lib version (%s) doesn't match executable '$0' version ($])"
d204 1
a204 2
    or die "Perl lib version (%s) doesn't match executable '$0' version (" .
	sprintf("v%%vd",$^V) . ")";
a254 3
    # XXX - should use PERLLIB_SEP, not hard-code ':'
    $val =~ s/^([^:]+).*${quote}\w*$/$1${quote}/ if $Libpathtrunc{$name};

d303 1
a303 1
    # We only have ' delimted.
d444 72
d977 1
d1002 3
a1004 1
      ($text ? " or another paragraph of description" : () );
d1013 1
a1013 1
     (?<! [\w./<\'\"] )		# Only standalone file names
d1041 7
a1102 30

# Now create Cross.pm if needed
if ($Opts{cross}) {
  open CROSS, ">lib/Cross.pm" or die "Can not open >lib/Cross.pm: $!";
  my $cross = <<'EOS';
# typical invocation:
#   perl -MCross Makefile.PL
#   perl -MCross=wince -V:cc
package Cross;

sub import {
  my ($package,$platform) = @@_;
  unless (defined $platform) {
    # if $platform is not specified, then use last one when
    # 'configpm; was invoked with --cross option
    $platform = '***replace-marker***';
  }
  @@INC = map {/\blib\b/?(do{local $_=$_;s/\blib\b/xlib\/$platform/;$_},$_):($_)} @@INC;
  $::Cross::platform = $platform;
}

1;
EOS
  $cross =~ s/\*\*\*replace-marker\*\*\*/$Opts{cross}/g;
  print CROSS $cross;
  close CROSS;
  print "written lib/Cross.pm\n";
  unshift(@@INC,"xlib/$Opts{cross}");
}

a1104 1
unshift(@@INC,'xlib/symbian') if $Opts{cross};
@


1.16
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d78 1
a78 1
		      embed.h embedvar.h form.h gv.h handy.h hv.h intrpvar.h
d157 4
a160 1
$heavy_txt .= <<'ENDOFBEG';
d167 1
a167 1
use vars '%Config';
d187 3
d199 1
a199 5
    if ($^O eq 'VMS') {
        print "\nCharacteristics of this PERLSHR image: \n";
    } else {
        print "\nCharacteristics of this binary (from libperl): \n";
    }
d208 1
a208 1
    print "  Built under $^O\n";
d212 2
a213 3
    my @@env = map { "$_=\"$ENV{$_}\"" } sort grep {/^PERL/} keys %ENV;
    push @@env, "CYGWIN=\"$ENV{CYGWIN}\"" if $^O eq 'cygwin' and $ENV{CYGWIN};

d215 1
a215 1
        print "  \%ENV:\n";
d236 1
a236 1
$config_txt .= sprintf << 'EOT', $export_funcs;
d247 3
a249 1
use vars '%%Config';
d822 2
a823 2
# Sanity check needed to stop an infite loop if Config_heavy.pl fails to define
# &launcher for some reason (eg it got truncated)
@


1.15
log
@merge in perl 5.12.2 plus local changes
@
text
@d55 5
d64 30
d163 19
a181 2
# use warnings; Pulls in Carp
# use vars pulls in Carp
d211 1
a211 1
    push @@env, "CYGWIN=\"$ENV{CYGWIN}\"" if $^O eq 'cygwin';
d221 1
d224 10
a233 1
my $myver = sprintf "%vd", $^V;
d235 1
a235 1
$config_txt .= sprintf <<'ENDOFBEG', ($myver) x 3;
d245 7
a251 2
# use warnings; Pulls in Carp
# use vars pulls in Carp
d253 1
a253 1
@@Config::EXPORT_OK = qw(myconfig config_sh config_vars config_re);
d258 1
a258 4
sub myconfig;
sub config_sh;
sub config_vars;
sub config_re;
d260 1
a260 1
my %%Export_Cache = map {($_ => 1)} (@@Config::EXPORT, @@Config::EXPORT_OK);
d262 3
a264 1
our %%Config;
d268 1
a268 1
    my $pkg = shift;
d277 2
a278 2
	die sprintf qq{"%%s" is not exported by the %%s module\n},
	    $func, __PACKAGE__ unless $Export_Cache{$func};
d286 1
a286 1
die "Perl lib version (%s) doesn't match executable version ($])"
d290 1
a290 1
    or die "Perl lib version (%s) doesn't match executable version (" .
d300 1
a331 1
    my $quote = $2;
d336 1
d369 1
a369 18
    $fetch_string .= <<'EOT';
    my $quote_type = "'";
    my $marker = "$key=";

    # Check for the common case, ' delimited
    my $start = index($Config_SH_expanded, "\n$marker$quote_type");
    # If that failed, check for " delimited
    if ($start == -1) {
        $quote_type = '"';
        $start = index($Config_SH_expanded, "\n$marker$quote_type");
    }
EOT
} else {
    $fetch_string .= <<'EOT';
    # We only have ' delimted.
    my $start = index($Config_SH_expanded, "\n$key=\'");
EOT
}
d371 1
a371 19
    # Start can never be -1 now, as we've rigged the long string we're
    # searching with an initial dummy newline.
    return undef if $start == -1;

    $start += length($key) + 3;

EOT
if (!$seen_quotes{'"'}) {
    # Don't need the full ' and " code, or the eval expansion.
    $fetch_string .= <<'EOT';
    my $value = substr($Config_SH_expanded, $start,
                       index($Config_SH_expanded, "'\n", $start)
		       - $start);
EOT
} else {
    $fetch_string .= <<'EOT';
    my $value = substr($Config_SH_expanded, $start,
                       index($Config_SH_expanded, "$quote_type\n", $start)
		       - $start);
d377 4
d386 4
d391 4
a394 1
}
d396 1
d398 1
a398 2
    $value = undef if $value eq 'undef';
    $self->{$key} = $value; # cache it
d402 2
d423 1
a423 1
    my $list = join ',', reverse(2..$s);
d427 2
a428 3
my \$i = 0;
foreach my \$c ($list) { \$i |= ord(\$c); \$i <<= 8 }
\$i |= ord(1);
d668 2
a669 1
    return $self->{$key} if exists $self->{$key};
a670 2
    return $self->fetch_string($key);
}
d718 1
a718 3
*DELETE = \&STORE;
*CLEAR  = \&STORE;

d882 1
a882 1
See also C<-V> in L<perlrun/Switches>.
d902 28
a929 1
See also C<-V:name> in L<perlrun/Switches>.
@


1.14
log
@Merge in perl 5.10.1
@
text
@d37 1
d69 1
d95 4
d130 39
@


1.13
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d132 4
d473 13
a485 1
		 { my $c = $Config::Config{$1}; defined($c) ? $c : 'undef' }ge;
d562 9
d787 4
d872 2
d890 2
d898 2
d948 15
@


1.12
log
@merge in perl 5.8.8
@
text
@d2 37
d60 2
a61 2
		   qw(archlib archlibexp privlib privlibexp sitearch sitearchexp
		      sitelib sitelibexp);
a67 1
    'heavy' => '',   # pathname of the Config_heavy.pl file
d82 2
a83 1
        die "option '$opt' is not recognized";
d93 2
a94 2
my ($Config_PM, $Config_heavy);
my $Glossary = $ARGV[1] || 'Porting/Glossary';
d100 3
a102 7
  $Config_PM = $ARGV[0] || "xlib/$Opts{cross}/Config.pm";
}
else {
  $Config_PM = $ARGV[0] || 'lib/Config.pm';
}
if ($Opts{heavy}) {
  $Config_heavy = $Opts{heavy};
d105 7
a111 4
  ($Config_heavy = $Config_PM) =~ s!\.pm$!_heavy.pl!;
  die "Can't automatically determine name for Config_heavy.pl from '$Config_PM'"
    if $Config_heavy eq $Config_PM;
}
d113 2
a114 2
open CONFIG, ">$Config_PM" or die "Can't open $Config_PM: $!\n";
open CONFIG_HEAVY, ">$Config_heavy" or die "Can't open $Config_heavy: $!\n";
d116 1
a116 1
print CONFIG_HEAVY <<'ENDOFBEG';
d126 1
a126 1
my $myver = sprintf "v%vd", $^V;
d128 1
a128 1
printf CONFIG <<'ENDOFBEG', ($myver) x 3;
d190 1
a190 1
  open(CONFIG_SH, 'config.sh') || die "Can't open config.sh: $!";
d342 113
a454 1
print CONFIG_HEAVY @@non_v, "\n";
d457 1
a457 1
print CONFIG_HEAVY "our \$summary = <<'!END!';\n";
d460 1
a460 1
do { print CONFIG_HEAVY $_ } until !defined($_ = <MYCONFIG>) || /^\s*$/;
d463 1
a463 1
print CONFIG_HEAVY "\n!END!\n", <<'EOT';
d477 1
a477 1
print CONFIG_HEAVY join('', sort @@v_others), "!END!\n";
d482 1
a482 1
    print CONFIG $byteorder_code;
d484 18
a501 1
    print CONFIG_HEAVY $byteorder_code;
d504 1
a504 1
print CONFIG_HEAVY <<'EOT';
d515 4
a518 2
    $value =~ s/\Q$withlargefiles\E\b//;
    print CONFIG_HEAVY "${prefix}_nolargefiles='$value'\n";
d523 2
d541 1
a541 1
    print CONFIG_HEAVY "${prefix}_nolargefiles='$value'\n";
d544 1
a544 1
print CONFIG_HEAVY "EOVIRTUAL\n";
d546 1
a546 1
print CONFIG_HEAVY $fetch_string;
d548 1
a548 1
print CONFIG <<'ENDOFEND';
d560 1
a560 1
print CONFIG_HEAVY <<'ENDOFEND';
d572 1
a572 1
print CONFIG_HEAVY <<'ENDOFEND';
d580 1
a580 1
print CONFIG_HEAVY <<'ENDOFEND';
d584 1
a584 1
print CONFIG_HEAVY <<'ENDOFEND';
d596 1
a596 1
print CONFIG_HEAVY <<'ENDOFEND';
d600 1
a600 1
print CONFIG_HEAVY <<'ENDOFEND';
d652 1
a652 1
    print CONFIG <<'ENDOFSET';
d672 1
a672 1
    print CONFIG <<ENDOFSET if $dll;
d676 1
a676 1
    print CONFIG <<'ENDOFSET';
d692 5
d710 1
a710 1
print CONFIG sprintf <<'ENDOFTIE', $fast_config;
d726 1
a726 1
open(CONFIG_POD, ">lib/Config.pod") or die "Can't open lib/Config.pod: $!";
d924 1
a924 3
close(CONFIG_HEAVY);
close(CONFIG);
close(GLOS);
d926 22
d974 2
d980 1
@


1.11
log
@sync in-tree perl with 5.8.6
@
text
@d2 2
d5 11
a15 8
# commonly used names to put first (and hence lookup fastest)
my %Common = map {($_,$_)}
             qw(archname osname osvers prefix libs libpth
                dynamic_ext static_ext dlsrc so
                cc ccflags cppflags
                privlibexp archlibexp installprivlib installarchlib
                sharpbang startsh shsharp
               );
d23 2
a24 2
                 qw(archlib archlibexp privlib privlibexp sitearch sitearchexp
		    sitelib sitelibexp);
d28 2
a29 2
    'cross'    => '', # --cross=PALTFORM - crosscompiling for PLATFORM
    'glossary' => 1,  # --no-glossary  - no glossary file inclusion, 
d31 1
d56 1
a56 1
my $Config_PM;
d68 11
d80 3
d84 5
a88 1
open CONFIG, ">$Config_PM" or die "Can't open $Config_PM: $!\n";
d97 15
a111 2
@@EXPORT = qw(%%Config);
@@EXPORT_OK = qw(myconfig config_sh config_vars config_re);
d113 1
a113 1
my %%Export_Cache = map {($_ => 1)} (@@EXPORT, @@EXPORT_OK);
d118 1
a118 1
    @@_ = @@EXPORT unless @@_;
d123 1
a145 2
my @@v_fast   = ();
my %v_fast   = ();
a149 52
# This is somewhat grim, but I want the code for parsing config.sh here and
# now so that I can expand $Config{ivsize} and $Config{ivtype}

my $fetch_string = <<'EOT';

# Search for it in the big string 
sub fetch_string {
    my($self, $key) = @@_;

    my $quote_type = "'";
    my $marker = "$key=";

    # Check for the common case, ' delimited
    my $start = index($Config_SH, "\n$marker$quote_type");
    # If that failed, check for " delimited
    if ($start == -1) {
        $quote_type = '"';
        $start = index($Config_SH, "\n$marker$quote_type");
    }
    return undef if ( ($start == -1) &&  # in case it's first 
                      (substr($Config_SH, 0, length($marker)) ne $marker) );
    if ($start == -1) { 
        # It's the very first thing we found. Skip $start forward
        # and figure out the quote mark after the =.
        $start = length($marker) + 1;
        $quote_type = substr($Config_SH, $start - 1, 1);
    } 
    else { 
        $start += length($marker) + 2;
    }

    my $value = substr($Config_SH, $start, 
                       index($Config_SH, "$quote_type\n", $start) - $start);

    # If we had a double-quote, we'd better eval it so escape
    # sequences and such can be interpolated. Since the incoming
    # value is supposed to follow shell rules and not perl rules,
    # we escape any perl variable markers
    if ($quote_type eq '"') {
	$value =~ s/\$/\\\$/g;
	$value =~ s/\@@/\\\@@/g;
	eval "\$value = \"$value\"";
    }

    # So we can say "if $Config{'foo'}".
    $value = undef if $value eq 'undef';
    $self->{$key} = $value; # cache it
}
EOT

eval $fetch_string;
die if $@@;
d151 5
a155 2
open(CONFIG_SH, 'config.sh') || die "Can't open config.sh: $!";
while (<CONFIG_SH>) {
d180 1
a180 1
    $quote = $2;
d198 29
a226 2
    if (!$Common{$name}){
        push(@@v_others, $line);
d228 36
a263 3
    else {
        push(@@v_fast, $line);
        $v_fast{$name} = "'$name' => $quote$val$quote";
d265 1
d267 9
a275 1
close CONFIG_SH;
d279 1
a279 1
our $Config_SH = join "\n", @@v_fast, @@v_others;
d296 1
d300 1
a300 1
my \$byteorder = join('', unpack('$format', pack('$f', \$i)));
d303 1
a303 1
    $byteorder_code = "my \$byteorder = '?'x$s;\n";
d306 1
a306 1
print CONFIG @@non_v, "\n";
d309 1
a309 1
print CONFIG "our \$summary : unique = <<'!END!';\n";
d312 1
a312 1
do { print CONFIG $_ } until !defined($_ = <MYCONFIG>) || /^\s*$/;
d315 1
a315 5
# NB. as $summary is unique, we need to copy it in a lexical variable
# before expanding it, because may have been made readonly if a perl
# interpreter has been cloned.

print CONFIG "\n!END!\n", $byteorder_code, <<'EOT';
d321 1
a321 1
		 { my $c = $Config{$1}; defined($c) ? $c : 'undef' }ge;
d329 1
a329 1
print CONFIG join("", @@v_fast, sort @@v_others);
d331 7
a337 5
print CONFIG <<'EOT';
!END!
s/(byteorder=)(['"]).*?\2/$1$2$byteorder$2/m;
our $Config_SH : unique = $_;
EOT
d339 2
a340 1
print CONFIG $fetch_string;
d342 1
a342 1
print CONFIG <<'ENDOFEND';
d344 2
a345 2
sub fetch_virtual {
    my($self, $key) = @@_;
d347 23
a369 26
    my $value;

    if ($key =~ /^((?:cc|ld)flags|libs(?:wanted)?)_nolargefiles/) {
	# These are purely virtual, they do not exist, but need to
	# be computed on demand for largefile-incapable extensions.
	my $new_key = "${1}_uselargefiles";
	$value = $Config{$1};
	my $withlargefiles = $Config{$new_key};
	if ($new_key =~ /^(?:cc|ld)flags_/) {
	    $value =~ s/\Q$withlargefiles\E\b//;
	} elsif ($new_key =~ /^libs/) {
	    my @@lflibswanted = split(' ', $Config{libswanted_uselargefiles});
	    if (@@lflibswanted) {
		my %lflibswanted;
		@@lflibswanted{@@lflibswanted} = ();
		if ($new_key =~ /^libs_/) {
		    my @@libs = grep { /^-l(.+)/ &&
                                      not exists $lflibswanted{$1} }
		                    split(' ', $Config{libs});
		    $Config{libs} = join(' ', @@libs);
		} elsif ($new_key =~ /^libswanted_/) {
		    my @@libswanted = grep { not exists $lflibswanted{$_} }
		                          split(' ', $Config{libswanted});
		    $Config{libswanted} = join(' ', @@libswanted);
		}
	    }
d372 4
d377 3
a379 2
    $self->{$key} = $value;
}
d381 1
a381 1
sub FETCH { 
d387 5
a391 3
    $self->fetch_string($key);
    return $self->{$key} if exists $self->{$key};
    $self->fetch_virtual($key);
a392 4
    # Might not exist, in which undef is correct.
    return $self->{$key};
}
 
d397 1
a397 1
    substr($Config_SH, 0, index($Config_SH, '=') );
d401 3
d405 12
a416 3
    my $quote = substr($Config_SH, index($Config_SH, "=", $prevpos)+1, 1);
    my $pos = index($Config_SH, qq($quote\n), $prevpos) + 2;
    my $len = index($Config_SH, "=", $pos) - $pos;
d418 1
a418 1
    $len > 0 ? substr($Config_SH, $pos, $len) : undef;
d421 1
a421 1
sub EXISTS { 
d424 8
a431 5
    return(index($Config_SH, "\n$_[1]='") != -1 or
           substr($Config_SH, 0, length($_[1])+2) eq "$_[1]='" or
           index($Config_SH, "\n$_[1]=\"") != -1 or
           substr($Config_SH, 0, length($_[1])+2) eq "$_[1]=\"" or
           $_[1] =~ /^(?:(?:cc|ld)flags|libs(?:wanted)?)_nolargefiles$/
d441 1
a441 1
    $Config_SH
d446 2
a447 1
    return map { chomp; $_ } grep eval{ /^(?:$re)=/ }, split /^/, $Config_SH;
d465 2
a466 1
	    my $v = (exists $Config{$qry}) ? $Config{$qry} : 'UNKNOWN';
d473 7
d486 1
a486 1
    my ($value, $v) = $Config_SH =~ m/^used_aout='(.*)'\s*$/m;
d488 1
a488 1
        ($v) = $Config_SH =~ m/^aout_$_='(.*)'\s*$/m;
d514 19
a532 2
my $fast_config = join '', map { "    $_,\n" }
    sort values (%v_fast), 'byteorder => $byteorder' ;
d534 2
a537 1
# avoid Config..Exporter..UNIVERSAL search for DESTROY then AUTOLOAD
d540 7
d548 1
a548 4
%s
};

1;
d674 2
a675 2
%seen = ();
$text = 0;
d750 1
d785 1
d803 103
@


1.10
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d221 28
d262 1
a262 1
print CONFIG "\n!END!\n", <<'EOT';
d272 2
a273 1
our $Config_SH : unique = <<'!END!';
d278 7
a284 1
print CONFIG "!END!\n", $fetch_string;
d379 1
d381 1
d383 3
a385 2
	my $prfx = $notag ? '': "$qry=";		# prefix for print
	my $lnend = $lncont ? ' ' : ";\n";		# ending for print
d387 1
a433 29

# Calculation for the keys for byteorder
# This is somewhat grim, but I need to run fetch_string here.
our $Config_SH = join "\n", @@v_fast, @@v_others;

my $t = fetch_string ({}, 'ivtype');
my $s = fetch_string ({}, 'ivsize');

# byteorder does exist on its own but we overlay a virtual
# dynamically recomputed value.

# However, ivtype and ivsize will not vary for sane fat binaries

my $f = $t eq 'long' ? 'L!' : $s == 8 ? 'Q': 'I';

my $byteorder_code;
if ($s == 4 || $s == 8) {
    my $list = join ',', reverse(2..$s);
    my $format = 'a'x$s;
    $byteorder_code = <<"EOT";
my \$i = 0;
foreach my \$c ($list) { \$i |= ord(\$c); \$i <<= 8 }
\$i |= ord(1);
my \$value = join('', unpack('$format', pack('$f', \$i)));
EOT
} else {
    $byteorder_code = "\$value = '?'x$s;\n";
}

d435 1
a435 1
    sort values (%v_fast), 'byteorder => $value' ;
d437 1
a437 1
print CONFIG sprintf <<'ENDOFTIE', $byteorder_code, $fast_config;
a440 2

%s
@


1.9
log
@merge local changes into perl-5.8.3
@
text
@d340 1
a340 1
    return map { chomp; $_ } grep /^$re=/, split /^/, $Config_SH;
d345 8
a352 3
	if (/\W/) {
	    my @@matches = config_re($_);
	    print map "$_\n", @@matches ? @@matches : "$_: not found";
d354 1
a354 1
	    my $v = (exists $Config{$_}) ? $Config{$_} : 'UNKNOWN';
d356 1
a356 1
	    print "$_='$v';\n";
d451 2
a452 2
    if ($Config{'cc'} =~ /gcc/) {
	print "built by gcc\n";
@


1.8
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d230 4
d235 1
a235 1
my $summary_expanded = 0;
d238 2
a239 2
    return $summary if $summary_expanded;
    $summary =~ s{\$(\w+)}
d241 1
a241 2
    $summary_expanded = 1;
    $summary;
@


1.7
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d3 23
a25 14
# following options are recognized:
# --no-glossary  - no glossary file inclusion, for compactness
# --cross=PALTFORM - crosscompiling for PLATFORM
my %opts = (
  # %known_opts enumerates allowed opts as well as specifies default and initial values
  my %known_opts = (
     'cross' => '',
     'glossary' => 1,
  ),
  # options itself
  my %specified_opts = (
    (map {/^--([\-_\w]+)=(.*)$/} @@ARGV),                            # --opt=smth
    (map {/^no-?(.*)$/i?($1=>0):($_=>1)} map {/^--([\-_\w]+)$/} @@ARGV),  # --opt --no-opt --noopt
  ),
a26 2
die "option '$_' is not recognized" for grep {!exists $known_opts{$_}} keys %specified_opts;
@@ARGV = grep {!/^--/} @@ARGV;
d28 10
a37 2
my $config_pm;
my $glossary = $ARGV[1] || 'Porting/Glossary';
d39 15
a53 1
if ($opts{cross}) {
d56 2
a57 2
  mkdir "xlib/$opts{cross}";
  $config_pm = $ARGV[0] || "xlib/$opts{cross}/Config.pm";
d60 1
a60 1
  $config_pm = $ARGV[0] || 'lib/Config.pm';
a62 9
@@ARGV = "./config.sh";

# list names to put first (and hence lookup fastest)
@@fast = qw(archname osname osvers prefix libs libpth
	dynamic_ext static_ext extensions dlsrc so
	sig_name sig_num cc ccflags cppflags
	privlibexp archlibexp installprivlib installarchlib
	sharpbang startsh shsharp
);
d64 1
a64 2
# names of things which may need to have slashes changed to double-colons
@@extensions = qw(dynamic_ext static_ext extensions known_extensions);
d66 1
a66 3
# name of lib paths that should be truncated on ':'
@@libpathtrunc = qw(archlib archlibexp privlib privlibexp sitearch sitearchexp
	sitelib sitelibexp);
d68 3
a70 2
open CONFIG, ">$config_pm" or die "Can't open $config_pm: $!\n";
$myver = sprintf "v%vd", $^V;
a71 1
print CONFIG <<'ENDOFBEG_NOQ', <<"ENDOFBEG";
d73 4
a76 3
use Exporter ();
@@EXPORT = qw(%Config);
@@EXPORT_OK = qw(myconfig config_sh config_vars);
d80 12
a91 17
  my $pkg = shift;
  @@_ = @@EXPORT unless @@_;
  my @@func = grep {$_ ne '%Config'} @@_;
  local $Exporter::ExportLevel = 1;
  Exporter::import('Config', @@func) if @@func;
  return if @@func == @@_;
  my $callpkg = caller(0);
  *{"$callpkg\::Config"} = \%Config;
}

ENDOFBEG_NOQ
die "Perl lib version ($myver) doesn't match executable version (\$])"
    unless \$^V;

\$^V eq $myver
  or die "Perl lib version ($myver) doesn't match executable version (" .
    (sprintf "v%vd",\$^V) . ")";
d93 10
a102 2
# This file was created by configpm when Perl was built. Any changes
# made to this file will be lost the next time perl is built.
d107 50
a156 7
@@fast{@@fast} = @@fast;
@@extensions{@@extensions} = @@extensions;
@@libpathtrunc{@@libpathtrunc} = @@libpathtrunc;
@@non_v=();
@@v_fast=();
@@v_others=();
$in_v = 0;
d158 11
a168 1
while (<>) {
d170 1
d172 3
a174 2
    s/^(\w+)=(true|\d+)\s*$/$1='$2'\n/;
    my ($k,$v) = ($1,$2);
d187 1
d194 6
a199 2
    if ($in_v) { $val .= $_;             }
    else       { ($name,$val) = ($1,$3); }
d202 1
d204 14
a217 4
    if ($libpathtrunc{$name}) { $val =~ s/^([^:]+).*${quote}\w*$/$1${quote}/; }
    if ($extensions{$name}) { s,/,::,g }
    if (!$fast{$name}){ push(@@v_others, "$name=$quote$val"); next; }
    push(@@v_fast,"$name=$quote$val");
d219 1
d221 1
a221 6
foreach(@@non_v){ print CONFIG $_ }

print CONFIG "\n",
    "my \$config_sh = <<'!END!';\n",
    join("", @@v_fast, sort @@v_others),
    "!END!\n\n";
d224 1
a224 3

print CONFIG "my \$summary = <<'!END!';\n";

d234 5
a238 5
	return $summary if $summary_expanded;
	$summary =~ s{\$(\w+)}
		     { my $c = $Config{$1}; defined($c) ? $c : 'undef' }ge;
	$summary_expanded = 1;
	$summary;
d240 2
d244 3
a246 1
# ----
d250 2
a251 3
sub FETCH { 
    # check for cached value (which may be undef so we use exists not defined)
    return $_[0]->{$_[1]} if (exists $_[0]->{$_[1]});
d253 1
a253 2
    # Search for it in the big string 
    my($value, $start, $marker, $quote_type);
d255 1
a255 17
    $quote_type = "'";
    # Virtual entries.
    if ($_[1] eq 'byteorder') {
	# byteorder does exist on its own but we overlay a virtual
	# dynamically recomputed value. 
        my $t = $Config{ivtype};
        my $s = $Config{ivsize};
        my $f = $t eq 'long' ? 'L!' : $s == 8 ? 'Q': 'I';
        if ($s == 4 || $s == 8) {
	    my $i = 0;
    	    foreach my $c (reverse(2..$s)) { $i |= ord($c); $i <<= 8 }
	    $i |= ord(1);
            $value = join('', unpack('a'x$s, pack($f, $i)));
        } else {
            $value = '?'x$s;
        }
    } elsif ($_[1] =~ /^((?:cc|ld)flags|libs(?:wanted)?)_nolargefiles/) {
d258 1
a258 1
	my $key = "${1}_uselargefiles";
d260 2
a261 2
	my $withlargefiles = $Config{$key};
	if ($key =~ /^(?:cc|ld)flags_/) {
d263 1
a263 1
	} elsif ($key =~ /^libs/) {
d268 1
a268 1
		if ($key =~ /^libs_/) {
d273 1
a273 1
		} elsif ($key =~ /^libswanted_/) {
a279 23
    } else {
	$marker = "$_[1]=";
	# return undef unless (($value) = $config_sh =~ m/^$_[1]='(.*)'\s*$/m);
	# Check for the common case, ' delimeted
	$start = index($config_sh, "\n$marker$quote_type");
	# If that failed, check for " delimited
	if ($start == -1) {
	    $quote_type = '"';
	    $start = index($config_sh, "\n$marker$quote_type");
	}
	return undef if ( ($start == -1) &&  # in case it's first 
			  (substr($config_sh, 0, length($marker)) ne $marker) );
	if ($start == -1) { 
	    # It's the very first thing we found. Skip $start forward
	    # and figure out the quote mark after the =.
	    $start = length($marker) + 1;
	    $quote_type = substr($config_sh, $start - 1, 1);
	} 
	else { 
	    $start += length($marker) + 2;
	}
	$value = substr($config_sh, $start, 
			index($config_sh, "$quote_type\n", $start) - $start);
d281 16
a296 14
    # If we had a double-quote, we'd better eval it so escape
    # sequences and such can be interpolated. Since the incoming
    # value is supposed to follow shell rules and not perl rules,
    # we escape any perl variable markers
    if ($quote_type eq '"') {
	$value =~ s/\$/\\\$/g;
	$value =~ s/\@@/\\\@@/g;
	eval "\$value = \"$value\"";
    }
    #$value = sprintf($value) if $quote_type eq '"';
    # So we can say "if $Config{'foo'}".
    $value = undef if $value eq 'undef';
    $_[0]->{$_[1]} = $value; # cache it
    return $value;
d303 1
a303 3
    # my($key) = $config_sh =~ m/^(.*?)=/;
    substr($config_sh, 0, index($config_sh, '=') );
    # $key;
d308 3
a310 3
    my $quote = substr($config_sh, index($config_sh, "=", $prevpos)+1, 1);
    my $pos = index($config_sh, qq($quote\n), $prevpos) + 2;
    my $len = index($config_sh, "=", $pos) - $pos;
d312 1
a312 1
    $len > 0 ? substr($config_sh, $pos, $len) : undef;
d316 8
a323 7
    # exists($_[0]->{$_[1]})  or  $config_sh =~ m/^$_[1]=/m;
    exists($_[0]->{$_[1]}) or
    index($config_sh, "\n$_[1]='") != -1 or
    substr($config_sh, 0, length($_[1])+2) eq "$_[1]='" or
    index($config_sh, "\n$_[1]=\"") != -1 or
    substr($config_sh, 0, length($_[1])+2) eq "$_[1]=\"" or
    $_[1] =~ /^(?:(?:cc|ld)flags|libs(?:wanted)?)_nolargefiles$/;
d327 2
a328 2
sub DELETE { &STORE }
sub CLEAR  { &STORE }
d332 1
a332 1
    $config_sh
d337 1
a337 2
    my @@matches = grep /^$re=/, split /^/, $config_sh;
    @@matches ? (print @@matches) : print "$re: not found\n";
d341 9
a349 5
    foreach(@@_){
	config_re($_), next if /\W/;
	my $v=(exists $Config{$_}) ? $Config{$_} : 'UNKNOWN';
	$v='undef' unless defined $v;
	print "$_='$v';\n";
d356 1
a356 1
  print CONFIG <<'ENDOFSET';
d359 1
a359 1
    my ($value, $v) = $config_sh =~ m/^used_aout='(.*)'\s*$/m;
d361 1
a361 1
        ($v) = $config_sh =~ m/^aout_$_='(.*)'\s*$/m;
d368 7
a374 6
  # Extract the name of the DLL from the makefile to avoid duplication
  my ($f) = grep -r, qw(GNUMakefile Makefile);
  my $dll;
  if (open my $fh, '<', $f) {
    while (<$fh>) {
      $dll = $1, last if /^PERL_DLL_BASE\s*=\s*(\S*)\s*$/;
d376 1
a376 2
  }
  print CONFIG <<ENDOFSET if $dll;
d380 4
a383 2
  print CONFIG <<'ENDOFSET';
sub TIEHASH { bless {} }
d387 33
a419 1
print CONFIG <<'ENDOFTAIL';
d424 5
a428 1
tie %Config, 'Config';
d431 2
a432 1
__END__
d434 2
d447 1
a447 1
    use Config qw(myconfig config_sh config_vars);
d453 2
d482 5
d553 2
a554 2
if ($opts{glossary}) {
  open(GLOS, "<$glossary") or die "Can't open $glossary: $!";
d564 1
a564 1
      print CONFIG <<EOF if $text;
d568 1
a568 1
      print CONFIG <<EOF;
d609 1
a609 1
if ($opts{glossary}) {
d614 1
a614 1
    print CONFIG;
d618 1
a618 1
print CONFIG <<'ENDOFTAIL';
d634 1
d637 1
a637 1
if ($opts{cross}) {
d658 1
a658 1
  $cross =~ s/\*\*\*replace-marker\*\*\*/$opts{cross}/g;
a662 1

d665 1
a665 1
require $config_pm;
d668 1
a668 1
die "$0: $config_pm not valid"
d671 1
a671 1
die "$0: error processing $config_pm"
d676 1
a676 1
die "$0: error processing $config_pm"
@


1.6
log
@merge in perl 5.6.1 with our local changes
@
text
@d3 19
a21 1
my $config_pm = $ARGV[0] || 'lib/Config.pm';
d23 11
d50 1
a50 3
# name of lib paths that should be truncated on ':'
@@libpathtrunc = qw(archlib archlibexp privlib privlibexp sitearch sitearchexp
	sitelib sitelibexp);
d96 1
a96 1
    # Catch CONFIGDOTSH=true and PERL_VERSION=n line from Configure.
d107 1
a107 1
	elsif ($k eq 'CONFIGDOTSH') {
d287 1
a287 1
    my @@matches = ($config_sh =~ /^$re=.*\n/mg);
d312 1
d315 11
d452 3
a454 1
open(GLOS, "<$glossary") or die "Can't open $glossary: $!";
d460 4
a463 4
  s/\A(\w*)\s+\(([\w.]+)\):\s*\n(\t?)/=item C<$1>\n\nFrom F<$2>:\n\n/m;
  my $c = substr $1, 0, 1;
  unless ($seen{$c}++) {
    print CONFIG <<EOF if $text;
d467 1
a467 1
    print CONFIG <<EOF;
d470 1
a470 1
=over
d473 6
a478 1
    $text = 1;
d481 1
a481 1
  s/^\t\s+(.*)/\n\t$1\n/gm;	# Indented lines ===> paragraphs
d491 8
a498 2
     ( [\w./]* [./] [\w./]* )	# Require . or / inside
     (?<! \. (?= \s ) )		# Do not include trailing dot
d508 7
a514 4
<GLOS>;				# Skip the preamble
while (<GLOS>) {
  process;
  print CONFIG;
d534 28
d568 1
a568 1
	unless $Config{'CONFIGDOTSH'} eq 'true';
d572 1
a572 1
	or $Config{'CONFIGDOTSH'} ne 'true' # test cache
@


1.5
log
@perl-5.6.0 + local changes
@
text
@d139 1
a139 1
    $marker = "$_[1]=";
d141 63
a203 18
    # return undef unless (($value) = $config_sh =~ m/^$_[1]='(.*)'\s*$/m);
    # Check for the common case, ' delimeted
    $start = index($config_sh, "\n$marker$quote_type");
    # If that failed, check for " delimited
    if ($start == -1) {
      $quote_type = '"';
      $start = index($config_sh, "\n$marker$quote_type");
    }
    return undef if ( ($start == -1) &&  # in case it's first 
        (substr($config_sh, 0, length($marker)) ne $marker) );
    if ($start == -1) { 
      # It's the very first thing we found. Skip $start forward
      # and figure out the quote mark after the =.
      $start = length($marker) + 1;
      $quote_type = substr($config_sh, $start - 1, 1);
    } 
    else { 
      $start += length($marker) + 2;
a204 3
    $value = substr($config_sh, $start, 
        index($config_sh, "$quote_type\n", $start) - $start);
 
d210 3
a212 3
      $value =~ s/\$/\\\$/g;
      $value =~ s/\@@/\\\@@/g;
      eval "\$value = \"$value\"";
d215 2
a216 1
    $value = undef if $value eq 'undef'; # So we can say "if $Config{'foo'}".
d245 2
a246 1
    substr($config_sh, 0, length($_[1])+2) eq "$_[1]=\"";
@


1.4
log
@cvs missed this in the last perl commit.  Bad cvs.
@
text
@d20 4
a23 3
	     sitelib sitelibexp);


d25 1
a25 1
$myver = $];
d27 1
a27 1
print CONFIG <<"ENDOFBEG";
d30 2
a31 3
\@@ISA = (Exporter);
\@@EXPORT = qw(%Config);
\@@EXPORT_OK = qw(myconfig config_sh config_vars);
d33 19
a51 2
\$] == $myver
  or die "Perl lib version ($myver) doesn't match executable version (\$])";
d69 1
a69 1
    # Catch CONFIG=true and PATCHLEVEL=n line from Configure.
d71 13
d108 1
a108 1
# copy config summary format from the myconfig script
d112 1
a112 1
open(MYCONFIG,"<myconfig") || die "open myconfig failed: $!";
d441 1
a441 1
	unless $Config{'CONFIG'} eq 'true';
d445 1
a445 1
	or $Config{'CONFIG'} ne 'true' # test cache
@


1.3
log
@perl5.005_03 (stock)
@
text
@d18 4
d44 1
d64 2
@


1.2
log
@perl 5.004_04
@
text
@d3 2
a4 1
$config_pm = $ARGV[0] || 'lib/Config.pm';
d49 2
a50 1
    unless ($in_v or m/^(\w+)='(.*\n)/){
d54 1
d56 2
a57 2
    else       { ($name,$val) = ($1,$2); }
    $in_v = $val !~ /'\n/;
d60 2
a61 2
    if (!$fast{$name}){ push(@@v_others, "$name='$val"); next; }
    push(@@v_fast,"$name='$val");
d101 3
a103 2
    my($value, $start, $marker);
    $marker = "$_[1]='";
d105 7
a111 1
    $start = index($config_sh, "\n$marker");
d114 9
a122 2
    if ($start == -1) { $start = length($marker) } 
        else { $start += length($marker) + 1 }
d124 1
a124 1
        index($config_sh, qq('\n), $start) - $start);
d126 10
d151 3
a153 1
    my $pos = index($config_sh, qq('\n), $prevpos) + 2;
d163 3
a165 1
    substr($config_sh, 0, length($_[1])+2) eq "$_[1]='";
d312 73
d396 1
@


1.1
log
@Initial revision
@
text
@d9 1
a9 1
	sig_name cc ccflags cppflags
d29 1
a29 1
  or die "Perl lib version ($myver) doesn't match executable version (\$])\\n";
d42 1
d48 1
a48 1
    unless (m/^(\w+)='(.*)'\s*$/){
d52 4
a55 1
    $name = $1;
d57 2
a58 2
    if (!$fast{$name}){ push(@@v_others, $_); next; }
    push(@@v_fast,$_);
d73 2
a74 2
1 while( ($_=<MYCONFIG>) !~ /^Summary of/);
do { print CONFIG $_ } until ($_ = <MYCONFIG>) =~ /^\s*$/;
d82 2
a83 1
	$summary =~ s/\$(\w+)/$Config{$1}/ge;
a92 2
tie %Config, Config;
sub TIEHASH { bless {} }
d94 1
a94 1
    # check for cached value (which maybe undef so we use exists not defined)
d96 12
a107 3
 
    my($value); # search for the item in the big $config_sh string
    return undef unless (($value) = $config_sh =~ m/^$_[1]='(.*)'\s*$/m);
d118 3
a120 2
    my($key) = $config_sh =~ m/^(.*?)=/;
    $key;
d124 1
a124 1
    my $pos = index($config_sh, "\n", $prevpos) + 1;
d131 4
a134 1
     exists($_[0]->{$_[1]})  or  $config_sh =~ m/^$_[1]=/m; 
d145 7
d154 1
d161 27
d220 1
a220 1
values.  The perl C<exists> function can be used to check is a
d252 1
d254 11
a264 6
    defined $Config{sig_name} || die "No sigs?";
    foreach $name (split(' ', $Config{sig_name})) {
	$signo{$name} = $i;
	$signame[$i] = $name;
	$i++;
    }   
d266 3
a268 3
    print "signal #17 = $signame[17]\n";
    if ($signo{ALRM}) { 
	print "SIGALRM is $signo{ALRM}\n";
d289 1
a289 1
ENDOFEND
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d3 1
a3 2
my $config_pm = $ARGV[0] || 'lib/Config.pm';
my $glossary = $ARGV[1] || 'Porting/Glossary';
d9 1
a9 1
	sig_name sig_num cc ccflags cppflags
d29 1
a29 1
  or die "Perl lib version ($myver) doesn't match executable version (\$])";
a41 1
$in_v = 0;
d47 1
a47 2
    # We can delimit things in config.sh with either ' or ". 
    unless ($in_v or m/^(\w+)=(['"])(.*\n)/){
d51 1
a51 5
    $quote = $2;
    if ($in_v) { $val .= $_;             }
    else       { ($name,$val) = ($1,$3); }
    $in_v = $val !~ /$quote\n/;
    next if $in_v;
d53 2
a54 2
    if (!$fast{$name}){ push(@@v_others, "$name=$quote$val"); next; }
    push(@@v_fast,"$name=$quote$val");
d69 2
a70 2
1 while defined($_ = <MYCONFIG>) && !/^Summary of/;
do { print CONFIG $_ } until !defined($_ = <MYCONFIG>) || /^\s*$/;
d78 1
a78 2
	$summary =~ s{\$(\w+)}
		     { my $c = $Config{$1}; defined($c) ? $c : 'undef' }ge;
d88 2
d91 1
a91 1
    # check for cached value (which may be undef so we use exists not defined)
a92 26

    # Search for it in the big string 
    my($value, $start, $marker, $quote_type);
    $marker = "$_[1]=";
    $quote_type = "'";
    # return undef unless (($value) = $config_sh =~ m/^$_[1]='(.*)'\s*$/m);
    # Check for the common case, ' delimeted
    $start = index($config_sh, "\n$marker$quote_type");
    # If that failed, check for " delimited
    if ($start == -1) {
      $quote_type = '"';
      $start = index($config_sh, "\n$marker$quote_type");
    }
    return undef if ( ($start == -1) &&  # in case it's first 
        (substr($config_sh, 0, length($marker)) ne $marker) );
    if ($start == -1) { 
      # It's the very first thing we found. Skip $start forward
      # and figure out the quote mark after the =.
      $start = length($marker) + 1;
      $quote_type = substr($config_sh, $start - 1, 1);
    } 
    else { 
      $start += length($marker) + 2;
    }
    $value = substr($config_sh, $start, 
        index($config_sh, "$quote_type\n", $start) - $start);
d94 3
a96 10
    # If we had a double-quote, we'd better eval it so escape
    # sequences and such can be interpolated. Since the incoming
    # value is supposed to follow shell rules and not perl rules,
    # we escape any perl variable markers
    if ($quote_type eq '"') {
      $value =~ s/\$/\\\$/g;
      $value =~ s/\@@/\\\@@/g;
      eval "\$value = \"$value\"";
    }
    #$value = sprintf($value) if $quote_type eq '"';
d106 2
a107 3
    # my($key) = $config_sh =~ m/^(.*?)=/;
    substr($config_sh, 0, index($config_sh, '=') );
    # $key;
d111 1
a111 3
    # Find out how the current key's quoted so we can skip to its end.
    my $quote = substr($config_sh, index($config_sh, "=", $prevpos)+1, 1);
    my $pos = index($config_sh, qq($quote\n), $prevpos) + 2;
d118 1
a118 6
    # exists($_[0]->{$_[1]})  or  $config_sh =~ m/^$_[1]=/m;
    exists($_[0]->{$_[1]}) or
    index($config_sh, "\n$_[1]='") != -1 or
    substr($config_sh, 0, length($_[1])+2) eq "$_[1]='" or
    index($config_sh, "\n$_[1]=\"") != -1 or
    substr($config_sh, 0, length($_[1])+2) eq "$_[1]=\"";
a128 7

sub config_re {
    my $re = shift;
    my @@matches = ($config_sh =~ /^$re=.*\n/mg);
    @@matches ? (print @@matches) : print "$re: not found\n";
}

a130 1
	config_re($_), next if /\W/;
a136 27
ENDOFEND

if ($^O eq 'os2') {
  print CONFIG <<'ENDOFSET';
my %preconfig;
if ($OS2::is_aout) {
    my ($value, $v) = $config_sh =~ m/^used_aout='(.*)'\s*$/m;
    for (split ' ', $value) {
        ($v) = $config_sh =~ m/^aout_$_='(.*)'\s*$/m;
        $preconfig{$_} = $v eq 'undef' ? undef : $v;
    }
}
sub TIEHASH { bless {%preconfig} }
ENDOFSET
} else {
  print CONFIG <<'ENDOFSET';
sub TIEHASH { bless {} }
ENDOFSET
}

print CONFIG <<'ENDOFTAIL';

# avoid Config..Exporter..UNIVERSAL search for DESTROY then AUTOLOAD
sub DESTROY { }

tie %Config, 'Config';

d169 1
a169 1
values.  The perl C<exists> function can be used to check if a
a200 1
    use strict;
d202 6
a207 11
    my %sig_num;
    my @@sig_name;
    unless($Config{sig_name} && $Config{sig_num}) {
	die "No sigs?";
    } else {
	my @@names = split ' ', $Config{sig_name};
	@@sig_num{@@names} = split ' ', $Config{sig_num};
	foreach (@@names) {
	    $sig_name[$sig_num{$_}] ||= $_;
	}   
    }
d209 3
a211 3
    print "signal #17 = $sig_name[17]\n";
    if ($sig_num{ALRM}) { 
	print "SIGALRM is $sig_num{ALRM}\n";
a223 73
The values stored in config.sh may be either single-quoted or
double-quoted. Double-quoted strings are handy for those cases where you
need to include escape sequences in the strings. To avoid runtime variable
interpolation, any C<$> and C<@@> characters are replaced by C<\$> and
C<\@@>, respectively. This isn't foolproof, of course, so don't embed C<\$>
or C<\@@> in double-quoted strings unless you're willing to deal with the
consequences. (The slashes will end up escaped and the C<$> or C<@@> will
trigger variable interpolation)

=head1 GLOSSARY

Most C<Config> variables are determined by the C<Configure> script
on platforms supported by it (which is most UNIX platforms).  Some
platforms have custom-made C<Config> variables, and may thus not have
some of the variables described below, or may have extraneous variables
specific to that particular port.  See the port specific documentation
in such cases.

ENDOFTAIL

open(GLOS, "<$glossary") or die "Can't open $glossary: $!";
%seen = ();
$text = 0;
$/ = '';

sub process {
  s/\A(\w*)\s+\(([\w.]+)\):\s*\n(\t?)/=item C<$1>\n\nFrom F<$2>:\n\n/m;
  my $c = substr $1, 0, 1;
  unless ($seen{$c}++) {
    print CONFIG <<EOF if $text;
=back

EOF
    print CONFIG <<EOF;
=head2 $c

=over

EOF
    $text = 1;
  }
  s/n't/n\00t/g;		# leave can't, won't etc untouched
  s/^\t\s+(.*)/\n\t$1\n/gm;	# Indented lines ===> paragraphs
  s/^(?<!\n\n)\t(.*)/$1/gm;	# Not indented lines ===> text
  s{([\'\"])(?=[^\'\"\s]*[./][^\'\"\s]*\1)([^\'\"\s]+)\1}(F<$2>)g; # '.o'
  s{([\'\"])([^\'\"\s]+)\1}(C<$2>)g; # "date" command
  s{\'([A-Za-z_\- *=/]+)\'}(C<$1>)g; # 'ln -s'
  s{
     (?<! [\w./<\'\"] )		# Only standalone file names
     (?! e \. g \. )		# Not e.g.
     (?! \. \. \. )		# Not ...
     (?! \d )			# Not 5.004
     ( [\w./]* [./] [\w./]* )	# Require . or / inside
     (?<! \. (?= \s ) )		# Do not include trailing dot
     (?! [\w/] )		# Include all of it
   }
   (F<$1>)xg;			# /usr/local
  s/((?<=\s)~\w*)/F<$1>/g;	# ~name
  s/(?<![.<\'\"])\b([A-Z_]{2,})\b(?![\'\"])/C<$1>/g;	# UNISTD
  s/(?<![.<\'\"])\b(?!the\b)(\w+)\s+macro\b/C<$1> macro/g; # FILE_cnt macro
  s/n[\0]t/n't/g;		# undo can't, won't damage
}

<GLOS>;				# Skip the preamble
while (<GLOS>) {
  process;
  print CONFIG;
}

print CONFIG <<'ENDOFTAIL';

=back

d232 1
a232 1
ENDOFTAIL
a234 1
close(GLOS);
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d20 1
a20 1
$myver = sprintf "v%vd", $^V;
d22 1
a22 1
print CONFIG <<'ENDOFBEG_NOQ', <<"ENDOFBEG";
d25 3
a27 2
@@EXPORT = qw(%Config);
@@EXPORT_OK = qw(myconfig config_sh config_vars);
d29 2
a30 19
# Define our own import method to avoid pulling in the full Exporter:
sub import {
  my $pkg = shift;
  @@_ = @@EXPORT unless @@_;
  my @@func = grep {$_ ne '%Config'} @@_;
  local $Exporter::ExportLevel = 1;
  Exporter::import('Config', @@func) if @@func;
  return if @@func == @@_;
  my $callpkg = caller(0);
  *{"$callpkg\::Config"} = \%Config;
}

ENDOFBEG_NOQ
die "Perl lib version ($myver) doesn't match executable version (\$])"
    unless \$^V;

\$^V eq $myver
  or die "Perl lib version ($myver) doesn't match executable version (" .
    (sprintf "v%vd",\$^V) . ")";
d47 1
a47 1
    # Catch CONFIGDOTSH=true and PERL_VERSION=n line from Configure.
a48 13
    my ($k,$v) = ($1,$2);
    # grandfather PATCHLEVEL and SUBVERSION and CONFIG
    if ($k) {
	if ($k eq 'PERL_VERSION') {
	    push @@v_others, "PATCHLEVEL='$v'\n";
	}
	elsif ($k eq 'PERL_SUBVERSION') {
	    push @@v_others, "SUBVERSION='$v'\n";
	}
	elsif ($k eq 'CONFIGDOTSH') {
	    push @@v_others, "CONFIG='$v'\n";
	}
    }
d71 1
a71 1
# copy config summary format from the myconfig.SH script
d75 1
a75 1
open(MYCONFIG,"<myconfig.SH") || die "open myconfig.SH failed: $!";
d404 1
a404 1
	unless $Config{'CONFIGDOTSH'} eq 'true';
d408 1
a408 1
	or $Config{'CONFIGDOTSH'} ne 'true' # test cache
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d131 1
a131 1

d133 18
a150 63
    # Virtual entries.
    if ($_[1] eq 'byteorder') {
	# byteorder does exist on its own but we overlay a virtual
	# dynamically recomputed value. 
        my $t = $Config{ivtype};
        my $s = $Config{ivsize};
        my $f = $t eq 'long' ? 'L!' : $s == 8 ? 'Q': 'I';
        if ($s == 4 || $s == 8) {
	    my $i = 0;
    	    foreach my $c (reverse(2..$s)) { $i |= ord($c); $i <<= 8 }
	    $i |= ord(1);
            $value = join('', unpack('a'x$s, pack($f, $i)));
        } else {
            $value = '?'x$s;
        }
    } elsif ($_[1] =~ /^((?:cc|ld)flags|libs(?:wanted)?)_nolargefiles/) {
	# These are purely virtual, they do not exist, but need to
	# be computed on demand for largefile-incapable extensions.
	my $key = "${1}_uselargefiles";
	$value = $Config{$1};
	my $withlargefiles = $Config{$key};
	if ($key =~ /^(?:cc|ld)flags_/) {
	    $value =~ s/\Q$withlargefiles\E\b//;
	} elsif ($key =~ /^libs/) {
	    my @@lflibswanted = split(' ', $Config{libswanted_uselargefiles});
	    if (@@lflibswanted) {
		my %lflibswanted;
		@@lflibswanted{@@lflibswanted} = ();
		if ($key =~ /^libs_/) {
		    my @@libs = grep { /^-l(.+)/ &&
                                      not exists $lflibswanted{$1} }
		                    split(' ', $Config{libs});
		    $Config{libs} = join(' ', @@libs);
		} elsif ($key =~ /^libswanted_/) {
		    my @@libswanted = grep { not exists $lflibswanted{$_} }
		                          split(' ', $Config{libswanted});
		    $Config{libswanted} = join(' ', @@libswanted);
		}
	    }
	}
    } else {
	$marker = "$_[1]=";
	# return undef unless (($value) = $config_sh =~ m/^$_[1]='(.*)'\s*$/m);
	# Check for the common case, ' delimeted
	$start = index($config_sh, "\n$marker$quote_type");
	# If that failed, check for " delimited
	if ($start == -1) {
	    $quote_type = '"';
	    $start = index($config_sh, "\n$marker$quote_type");
	}
	return undef if ( ($start == -1) &&  # in case it's first 
			  (substr($config_sh, 0, length($marker)) ne $marker) );
	if ($start == -1) { 
	    # It's the very first thing we found. Skip $start forward
	    # and figure out the quote mark after the =.
	    $start = length($marker) + 1;
	    $quote_type = substr($config_sh, $start - 1, 1);
	} 
	else { 
	    $start += length($marker) + 2;
	}
	$value = substr($config_sh, $start, 
			index($config_sh, "$quote_type\n", $start) - $start);
d152 3
d160 3
a162 3
	$value =~ s/\$/\\\$/g;
	$value =~ s/\@@/\\\@@/g;
	eval "\$value = \"$value\"";
d165 1
a165 2
    # So we can say "if $Config{'foo'}".
    $value = undef if $value eq 'undef';
d194 1
a194 2
    substr($config_sh, 0, length($_[1])+2) eq "$_[1]=\"" or
    $_[1] =~ /^(?:(?:cc|ld)flags|libs(?:wanted)?)_nolargefiles$/;
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d3 1
a3 19
# following options are recognized:
# --no-glossary  - no glossary file inclusion, for compactness
# --cross=PALTFORM - crosscompiling for PLATFORM
my %opts = (
  # %known_opts enumerates allowed opts as well as specifies default and initial values
  my %known_opts = (
     'cross' => '',
     'glossary' => 1,
  ),
  # options itself
  my %specified_opts = (
    (map {/^--([\-_\w]+)=(.*)$/} @@ARGV),                            # --opt=smth
    (map {/^no-?(.*)$/i?($1=>0):($_=>1)} map {/^--([\-_\w]+)$/} @@ARGV),  # --opt --no-opt --noopt
  ),
);
die "option '$_' is not recognized" for grep {!exists $known_opts{$_}} keys %specified_opts;
@@ARGV = grep {!/^--/} @@ARGV;

my $config_pm;
a4 11

if ($opts{cross}) {
  # creating cross-platform config file
  mkdir "xlib";
  mkdir "xlib/$opts{cross}";
  $config_pm = $ARGV[0] || "xlib/$opts{cross}/Config.pm";
}
else {
  $config_pm = $ARGV[0] || 'lib/Config.pm';
}

d63 1
a63 1
    # Catch PERL_CONFIG_SH=true and PERL_VERSION=n line from Configure.
d74 1
a74 1
	elsif ($k eq 'PERL_CONFIG_SH') {
d252 1
a252 1
    my @@matches = grep /^$re=/, split /^/, $config_sh;
a276 1
$preconfig{d_fork} = undef unless $OS2::can_fork; # Some funny cases can't
a278 11
  # Extract the name of the DLL from the makefile to avoid duplication
  my ($f) = grep -r, qw(GNUMakefile Makefile);
  my $dll;
  if (open my $fh, '<', $f) {
    while (<$fh>) {
      $dll = $1, last if /^PERL_DLL_BASE\s*=\s*(\S*)\s*$/;
    }
  }
  print CONFIG <<ENDOFSET if $dll;
\$preconfig{dll_name} = '$dll';
ENDOFSET
d405 1
a405 3
if ($opts{glossary}) {
  open(GLOS, "<$glossary") or die "Can't open $glossary: $!";
}
d411 4
a414 4
  if (s/\A(\w*)\s+\(([\w.]+)\):\s*\n(\t?)/=item C<$1>\n\nFrom F<$2>:\n\n/m) {
    my $c = substr $1, 0, 1;
    unless ($seen{$c}++) {
      print CONFIG <<EOF if $text;
d418 1
a418 1
      print CONFIG <<EOF;
d421 1
a421 1
=over 4
d424 1
a424 6
     $text = 1;
    }
  }
  elsif (!$text || !/\A\t/) {
    warn "Expected a Configure variable header",
      ($text ? " or another paragraph of description" : () );
d427 1
a427 1
  s/^\t\s+(.*)/\n$1/gm;		# Indented lines ===> new paragraph
d437 2
a438 8
     (?! read/ )		# Not read/write
     (?! etc\. )		# Not etc.
     (?! I/O )			# Not I/O
     (
	\$ ?			# Allow leading $
	[\w./]* [./] [\w./]*	# Require . or / inside
     )
     (?<! \. (?= [\s)] ) )	# Do not include trailing dot
d448 4
a451 7
if ($opts{glossary}) {
    <GLOS>;				# Skip the "DO NOT EDIT"
    <GLOS>;				# Skip the preamble
  while (<GLOS>) {
    process;
    print CONFIG;
  }
a470 28
# Now create Cross.pm if needed
if ($opts{cross}) {
  open CROSS, ">lib/Cross.pm" or die "Can not open >lib/Cross.pm: $!";
  my $cross = <<'EOS';
# typical invocation:
#   perl -MCross Makefile.PL
#   perl -MCross=wince -V:cc
package Cross;

sub import {
  my ($package,$platform) = @@_;
  unless (defined $platform) {
    # if $platform is not specified, then use last one when
    # 'configpm; was invoked with --cross option
    $platform = '***replace-marker***';
  }
  @@INC = map {/\blib\b/?(do{local $_=$_;s/\blib\b/xlib\/$platform/;$_},$_):($_)} @@INC;
  $::Cross::platform = $platform;
}

1;
EOS
  $cross =~ s/\*\*\*replace-marker\*\*\*/$opts{cross}/g;
  print CROSS $cross;
  close CROSS;
}


d477 1
a477 1
	unless $Config{'PERL_CONFIG_SH'} eq 'true';
d481 1
a481 1
	or $Config{'PERL_CONFIG_SH'} ne 'true' # test cache
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@d3 14
a16 18
# commonly used names to put first (and hence lookup fastest)
my %Common = map {($_,$_)}
             qw(archname osname osvers prefix libs libpth
                dynamic_ext static_ext dlsrc so
                cc ccflags cppflags
                privlibexp archlibexp installprivlib installarchlib
                sharpbang startsh shsharp
               );

# names of things which may need to have slashes changed to double-colons
my %Extensions = map {($_,$_)}
                 qw(dynamic_ext static_ext extensions known_extensions);

# allowed opts as well as specifies default and initial values
my %Allowed_Opts = (
    'cross'    => '', # --cross=PALTFORM - crosscompiling for PLATFORM
    'glossary' => 1,  # --no-glossary  - no glossary file inclusion, 
                      #                  for compactness
d18 2
d21 2
a22 10
sub opts {
    # user specified options
    my %given_opts = (
        # --opt=smth
        (map {/^--([\-_\w]+)=(.*)$/} @@ARGV),
        # --opt --no-opt --noopt
        (map {/^no-?(.*)$/i?($1=>0):($_=>1)} map {/^--([\-_\w]+)$/} @@ARGV),
    );

    my %opts = (%Allowed_Opts, %given_opts);
d24 1
a24 15
    for my $opt (grep {!exists $Allowed_Opts{$_}} keys %given_opts) {
        die "option '$opt' is not recognized";
    }
    @@ARGV = grep {!/^--/} @@ARGV;

    return %opts;
}


my %Opts = opts();

my $Config_PM;
my $Glossary = $ARGV[1] || 'Porting/Glossary';

if ($Opts{cross}) {
d27 2
a28 2
  mkdir "xlib/$Opts{cross}";
  $Config_PM = $ARGV[0] || "xlib/$Opts{cross}/Config.pm";
d31 1
a31 1
  $Config_PM = $ARGV[0] || 'lib/Config.pm';
d34 1
d36 7
a42 1
open CONFIG, ">$Config_PM" or die "Can't open $Config_PM: $!\n";
d44 2
a45 1
my $myver = sprintf "v%vd", $^V;
a46 3
printf CONFIG <<'ENDOFBEG', ($myver) x 3;
# This file was created by configpm when Perl was built. Any changes
# made to this file will be lost the next time perl is built.
d48 4
d53 3
a55 4
@@EXPORT = qw(%%Config);
@@EXPORT_OK = qw(myconfig config_sh config_vars config_re);

my %%Export_Cache = map {($_ => 1)} (@@EXPORT, @@EXPORT_OK);
d59 17
a75 2
    my $pkg = shift;
    @@_ = @@EXPORT unless @@_;
d77 2
a78 20
    my @@funcs = grep $_ ne '%%Config', @@_;
    my $export_Config = @@funcs < @@_ ? 1 : 0;

    my $callpkg = caller(0);
    foreach my $func (@@funcs) {
	die sprintf qq{"%%s" is not exported by the %%s module\n},
	    $func, __PACKAGE__ unless $Export_Cache{$func};
	*{$callpkg.'::'.$func} = \&{$func};
    }

    *{"$callpkg\::Config"} = \%%Config if $export_Config;
    return;
}

die "Perl lib version (%s) doesn't match executable version ($])"
    unless $^V;

$^V eq %s
    or die "Perl lib version (%s) doesn't match executable version (" .
	sprintf("v%%vd",$^V) . ")";
d83 6
a88 40
my @@non_v    = ();
my @@v_fast   = ();
my %v_fast   = ();
my @@v_others = ();
my $in_v     = 0;
my %Data     = ();

# This is somewhat grim, but I want the code for parsing config.sh here and
# now so that I can expand $Config{ivsize} and $Config{ivtype}

my $fetch_string = <<'EOT';

# Search for it in the big string 
sub fetch_string {
    my($self, $key) = @@_;

    my $quote_type = "'";
    my $marker = "$key=";

    # Check for the common case, ' delimited
    my $start = index($Config_SH, "\n$marker$quote_type");
    # If that failed, check for " delimited
    if ($start == -1) {
        $quote_type = '"';
        $start = index($Config_SH, "\n$marker$quote_type");
    }
    return undef if ( ($start == -1) &&  # in case it's first 
                      (substr($Config_SH, 0, length($marker)) ne $marker) );
    if ($start == -1) { 
        # It's the very first thing we found. Skip $start forward
        # and figure out the quote mark after the =.
        $start = length($marker) + 1;
        $quote_type = substr($Config_SH, $start - 1, 1);
    } 
    else { 
        $start += length($marker) + 2;
    }

    my $value = substr($Config_SH, $start, 
                       index($Config_SH, "$quote_type\n", $start) - $start);
d90 1
a90 21
    # If we had a double-quote, we'd better eval it so escape
    # sequences and such can be interpolated. Since the incoming
    # value is supposed to follow shell rules and not perl rules,
    # we escape any perl variable markers
    if ($quote_type eq '"') {
	$value =~ s/\$/\\\$/g;
	$value =~ s/\@@/\\\@@/g;
	eval "\$value = \"$value\"";
    }

    # So we can say "if $Config{'foo'}".
    $value = undef if $value eq 'undef';
    $self->{$key} = $value; # cache it
}
EOT

eval $fetch_string;
die if $@@;

open(CONFIG_SH, 'config.sh') || die "Can't open config.sh: $!";
while (<CONFIG_SH>) {
a91 1

d93 2
a94 3
    s/^(\w+)=(true|\d+)\s*$/$1='$2'\n/ or m/^(\w+)='(.*)'$/;
    my($k, $v) = ($1, $2);

a106 1

d113 2
a114 6
    if ($in_v) { 
        $val .= $_;
    }
    else { 
        ($name,$val) = ($1,$3); 
    }
d117 4
d122 1
a122 1
    s,/,::,g if $Extensions{$name};
d124 4
a127 1
    $val =~ s/$quote\n?\z//;
d129 1
a129 10
    my $line = "$name=$quote$val$quote\n";
    if (!$Common{$name}){
        push(@@v_others, $line);
    }
    else {
        push(@@v_fast, $line);
        $v_fast{$name} = "'$name' => $quote$val$quote";
    }
}
close CONFIG_SH;
d131 1
a131 1
print CONFIG @@non_v, "\n";
a132 2
# copy config summary format from the myconfig.SH script
print CONFIG "our \$summary : unique = <<'!END!';\n";
d142 5
a146 5
    return $summary if $summary_expanded;
    $summary =~ s{\$(\w+)}
		 { my $c = $Config{$1}; defined($c) ? $c : 'undef' }ge;
    $summary_expanded = 1;
    $summary;
a147 2

our $Config_SH : unique = <<'!END!';
d150 1
a150 3
print CONFIG join("", @@v_fast, sort @@v_others);

print CONFIG "!END!\n", $fetch_string;
d154 3
a156 2
sub fetch_virtual {
    my($self, $key) = @@_;
d158 2
a159 1
    my $value;
d161 17
a177 1
    if ($key =~ /^((?:cc|ld)flags|libs(?:wanted)?)_nolargefiles/) {
d180 1
a180 1
	my $new_key = "${1}_uselargefiles";
d182 2
a183 2
	my $withlargefiles = $Config{$new_key};
	if ($new_key =~ /^(?:cc|ld)flags_/) {
d185 1
a185 1
	} elsif ($new_key =~ /^libs/) {
d190 1
a190 1
		if ($new_key =~ /^libs_/) {
d195 1
a195 1
		} elsif ($new_key =~ /^libswanted_/) {
d202 23
d226 14
a239 16

    $self->{$key} = $value;
}

sub FETCH { 
    my($self, $key) = @@_;

    # check for cached value (which may be undef so we use exists not defined)
    return $self->{$key} if exists $self->{$key};

    $self->fetch_string($key);
    return $self->{$key} if exists $self->{$key};
    $self->fetch_virtual($key);

    # Might not exist, in which undef is correct.
    return $self->{$key};
d246 3
a248 1
    substr($Config_SH, 0, index($Config_SH, '=') );
d253 3
a255 3
    my $quote = substr($Config_SH, index($Config_SH, "=", $prevpos)+1, 1);
    my $pos = index($Config_SH, qq($quote\n), $prevpos) + 2;
    my $len = index($Config_SH, "=", $pos) - $pos;
d257 1
a257 1
    $len > 0 ? substr($Config_SH, $pos, $len) : undef;
d261 7
a267 8
    return 1 if exists($_[0]->{$_[1]});

    return(index($Config_SH, "\n$_[1]='") != -1 or
           substr($Config_SH, 0, length($_[1])+2) eq "$_[1]='" or
           index($Config_SH, "\n$_[1]=\"") != -1 or
           substr($Config_SH, 0, length($_[1])+2) eq "$_[1]=\"" or
           $_[1] =~ /^(?:(?:cc|ld)flags|libs(?:wanted)?)_nolargefiles$/
          );
d271 2
a272 2
*DELETE = \&STORE;
*CLEAR  = \&STORE;
d276 1
a276 1
    $Config_SH
d281 2
a282 1
    return map { chomp; $_ } grep /^$re=/, split /^/, $Config_SH;
d286 5
a290 9
    foreach (@@_) {
	if (/\W/) {
	    my @@matches = config_re($_);
	    print map "$_\n", @@matches ? @@matches : "$_: not found";
	} else {
	    my $v = (exists $Config{$_}) ? $Config{$_} : 'UNKNOWN';
	    $v = 'undef' unless defined $v;
	    print "$_='$v';\n";
	}
d297 1
a297 1
    print CONFIG <<'ENDOFSET';
d300 1
a300 1
    my ($value, $v) = $Config_SH =~ m/^used_aout='(.*)'\s*$/m;
d302 1
a302 1
        ($v) = $Config_SH =~ m/^aout_$_='(.*)'\s*$/m;
d309 6
a314 7
    # Extract the name of the DLL from the makefile to avoid duplication
    my ($f) = grep -r, qw(GNUMakefile Makefile);
    my $dll;
    if (open my $fh, '<', $f) {
	while (<$fh>) {
	    $dll = $1, last if /^PERL_DLL_BASE\s*=\s*(\S*)\s*$/;
	}
d316 2
a317 1
    print CONFIG <<ENDOFSET if $dll;
d321 2
a322 4
    print CONFIG <<'ENDOFSET';
sub TIEHASH {
    bless $_[1], $_[0];
}
d326 1
a326 33

# Calculation for the keys for byteorder
# This is somewhat grim, but I need to run fetch_string here.
our $Config_SH = join "\n", @@v_fast, @@v_others;

my $t = fetch_string ({}, 'ivtype');
my $s = fetch_string ({}, 'ivsize');

# byteorder does exist on its own but we overlay a virtual
# dynamically recomputed value.

# However, ivtype and ivsize will not vary for sane fat binaries

my $f = $t eq 'long' ? 'L!' : $s == 8 ? 'Q': 'I';

my $byteorder_code;
if ($s == 4 || $s == 8) {
    my $list = join ',', reverse(2..$s);
    my $format = 'a'x$s;
    $byteorder_code = <<"EOT";
my \$i = 0;
foreach my \$c ($list) { \$i |= ord(\$c); \$i <<= 8 }
\$i |= ord(1);
my \$value = join('', unpack('$format', pack('$f', \$i)));
EOT
} else {
    $byteorder_code = "\$value = '?'x$s;\n";
}

my $fast_config = join '', map { "    $_,\n" }
    sort values (%v_fast), 'byteorder => $value' ;

print CONFIG sprintf <<'ENDOFTIE', $byteorder_code, $fast_config;
d331 1
a331 5
%s

tie %%Config, 'Config', {
%s
};
d334 1
a334 2
ENDOFTIE

a335 2
open(CONFIG_POD, ">lib/Config.pod") or die "Can't open lib/Config.pod: $!";
print CONFIG_POD <<'ENDOFTAIL';
d347 1
a347 1
    use Config qw(myconfig config_sh config_vars config_re);
a352 2
    print config_re();

a379 5
=item config_re($regex)

Like config_sh() but returns, as a list, only the config entries who's
names match the $regex.

d446 2
a447 2
if ($Opts{glossary}) {
  open(GLOS, "<$Glossary") or die "Can't open $Glossary: $!";
d457 1
a457 1
      print CONFIG_POD <<EOF if $text;
d461 1
a461 1
      print CONFIG_POD <<EOF;
d502 1
a502 1
if ($Opts{glossary}) {
d507 1
a507 1
    print CONFIG_POD;
d511 1
a511 1
print CONFIG_POD <<'ENDOFTAIL';
a526 1
close(CONFIG_POD);
d529 1
a529 1
if ($Opts{cross}) {
d550 1
a550 1
  $cross =~ s/\*\*\*replace-marker\*\*\*/$Opts{cross}/g;
d555 1
d558 1
a558 1
require $Config_PM;
d561 1
a561 1
die "$0: $Config_PM not valid"
d564 1
a564 1
die "$0: error processing $Config_PM"
d569 1
a569 1
die "$0: error processing $Config_PM"
@


1.1.1.7
log
@perl 5.8.3 from CPAN
@
text
@a221 4
# NB. as $summary is unique, we need to copy it in a lexical variable
# before expanding it, because may have been made readonly if a perl
# interpreter has been cloned.

d223 1
a223 1
my $summary_expanded;
d226 2
a227 2
    return $summary_expanded if $summary_expanded;
    ($summary_expanded = $summary) =~ s{\$(\w+)}
d229 2
a230 1
    $summary_expanded;
@


1.1.1.8
log
@Import of stock perl 5.8.5
@
text
@a15 5
# libpaths that should be truncated after the first path element
my %Libpathtrunc = map {($_,$_)}
                 qw(archlib archlibexp privlib privlibexp sitearch sitearchexp
		    sitelib sitelibexp);

a197 3
    # XXX - should use PERLLIB_SEP, not hard-code ':'
    $val =~ s/^([^:]+).*${quote}\w*$/$1${quote}/ if $Libpathtrunc{$name};

d332 1
a332 1
    return map { chomp; $_ } grep eval{ /^(?:$re)=/ }, split /^/, $Config_SH;
d337 3
a339 8
	my ($notag,$qry,$lncont) = m/^(:)?(.*?)(:)?$/;	# flags fore and aft, 
	my $prfx = $notag ? '': "$qry=";		# prefix for print
	my $lnend = $lncont ? ' ' : ";\n";		# ending for print

	if ($qry =~ /\W/) {
	    my @@matches = config_re($qry);
	    print map "$_$lnend", @@matches ? @@matches : "$qry: not found"		if !$notag;
	    print map { s/\w+=//; "$_$lnend" } @@matches ? @@matches : "$qry: not found"	if  $notag;
d341 1
a341 1
	    my $v = (exists $Config{$qry}) ? $Config{$qry} : 'UNKNOWN';
d343 1
a343 1
	    print "${prfx}'${v}'$lnend";
d438 2
a439 2
    if ($Config{usethreads}) {
	print "has thread support\n"
@


1.1.1.9
log
@perl 5.8.6 from CPAN
@
text
@d16 5
d203 3
a220 28
# Calculation for the keys for byteorder
# This is somewhat grim, but I need to run fetch_string here.
our $Config_SH = join "\n", @@v_fast, @@v_others;

my $t = fetch_string ({}, 'ivtype');
my $s = fetch_string ({}, 'ivsize');

# byteorder does exist on its own but we overlay a virtual
# dynamically recomputed value.

# However, ivtype and ivsize will not vary for sane fat binaries

my $f = $t eq 'long' ? 'L!' : $s == 8 ? 'Q': 'I';

my $byteorder_code;
if ($s == 4 || $s == 8) {
    my $list = join ',', reverse(2..$s);
    my $format = 'a'x$s;
    $byteorder_code = <<"EOT";
my \$i = 0;
foreach my \$c ($list) { \$i |= ord(\$c); \$i <<= 8 }
\$i |= ord(1);
my \$byteorder = join('', unpack('$format', pack('$f', \$i)));
EOT
} else {
    $byteorder_code = "my \$byteorder = '?'x$s;\n";
}

d234 1
a234 1
print CONFIG "\n!END!\n", $byteorder_code, <<'EOT';
d244 1
a244 2
local *_ = \my $a;
$_ = <<'!END!';
d249 1
a249 7
print CONFIG <<'EOT';
!END!
s/(byteorder=)(['"]).*?\2/$1$2$byteorder$2/m;
our $Config_SH : unique = $_;
EOT

print CONFIG $fetch_string;
a343 1
    # implements -V:cfgvar option (see perlrun -V:)
a344 1
	# find optional leading, trailing colons; and query-spec
d346 2
a347 3
	# map colon-flags to print decorations
	my $prfx = $notag ? '': "$qry=";		# tag-prefix for print
	my $lnend = $lncont ? ' ' : ";\n";		# line ending for print
a348 1
	# all config-vars are by definition \w only, any \W means regex
d395 29
d425 1
a425 1
    sort values (%v_fast), 'byteorder => $byteorder' ;
d427 1
a427 1
print CONFIG sprintf <<'ENDOFTIE', $fast_config;
d431 2
@


1.1.1.10
log
@perl 5.8.8 import
@
text
@a1 2
use strict;
use vars qw(%Config $Config_SH_expanded);
d3 8
a10 11
my $how_many_common = 22;

# commonly used names to precache (and hence lookup fastest)
my %Common;

while ($how_many_common--) {
    $_ = <DATA>;
    chomp;
    /^(\S+):\s*(\d+)$/ or die "Malformed line '$_'";
    $Common{$1} = $1;
}
d18 2
a19 2
    'cross'    => '', # --cross=PLATFORM - crosscompiling for PLATFORM
    'glossary' => 1,  # --no-glossary  - no glossary file inclusion,
a20 1
    'heavy' => '',   # pathname of the Config_heavy.pl file
d45 1
a45 1
my ($Config_PM, $Config_heavy);
d57 1
a57 8
if ($Opts{heavy}) {
  $Config_heavy = $Opts{heavy};
}
else {
  ($Config_heavy = $Config_PM) =~ s!\.pm$!_heavy.pl!;
  die "Can't automatically determine name for Config_heavy.pl from '$Config_PM'"
    if $Config_heavy eq $Config_PM;
}
a59 11
open CONFIG_HEAVY, ">$Config_heavy" or die "Can't open $Config_heavy: $!\n";

print CONFIG_HEAVY <<'ENDOFBEG';
# This file was created by configpm when Perl was built. Any changes
# made to this file will be lost the next time perl is built.

package Config;
use strict;
# use warnings; Pulls in Carp
# use vars pulls in Carp
ENDOFBEG
d68 2
a69 15
use strict;
# use warnings; Pulls in Carp
# use vars pulls in Carp
@@Config::EXPORT = qw(%%Config);
@@Config::EXPORT_OK = qw(myconfig config_sh config_vars config_re);

# Need to stub all the functions to make code such as print Config::config_sh
# keep working

sub myconfig;
sub config_sh;
sub config_vars;
sub config_re;

my %%Export_Cache = map {($_ => 1)} (@@Config::EXPORT, @@Config::EXPORT_OK);
d71 1
a71 1
our %%Config;
d76 1
a76 1
    @@_ = @@Config::EXPORT unless @@_;
a80 1
    no strict 'refs';
d103 2
d109 52
d162 2
a163 5
my %seen_quotes;
{
  my ($name, $val);
  open(CONFIG_SH, 'config.sh') || die "Can't open config.sh: $!";
  while (<CONFIG_SH>) {
d188 1
a188 1
    my $quote = $2;
d203 2
a204 29
    push(@@v_others, $line);
    $seen_quotes{$quote}++;
  }
  close CONFIG_SH;
}

# This is somewhat grim, but I want the code for parsing config.sh here and
# now so that I can expand $Config{ivsize} and $Config{ivtype}

my $fetch_string = <<'EOT';

# Search for it in the big string
sub fetch_string {
    my($self, $key) = @@_;

EOT

if ($seen_quotes{'"'}) {
    # We need the full ' and " code
    $fetch_string .= <<'EOT';
    my $quote_type = "'";
    my $marker = "$key=";

    # Check for the common case, ' delimited
    my $start = index($Config_SH_expanded, "\n$marker$quote_type");
    # If that failed, check for " delimited
    if ($start == -1) {
        $quote_type = '"';
        $start = index($Config_SH_expanded, "\n$marker$quote_type");
d206 3
a208 36
EOT
} else {
    $fetch_string .= <<'EOT';
    # We only have ' delimted.
    my $start = index($Config_SH_expanded, "\n$key=\'");
EOT
}
$fetch_string .= <<'EOT';
    # Start can never be -1 now, as we've rigged the long string we're
    # searching with an initial dummy newline.
    return undef if $start == -1;

    $start += length($key) + 3;

EOT
if (!$seen_quotes{'"'}) {
    # Don't need the full ' and " code, or the eval expansion.
    $fetch_string .= <<'EOT';
    my $value = substr($Config_SH_expanded, $start,
                       index($Config_SH_expanded, "'\n", $start)
		       - $start);
EOT
} else {
    $fetch_string .= <<'EOT';
    my $value = substr($Config_SH_expanded, $start,
                       index($Config_SH_expanded, "$quote_type\n", $start)
		       - $start);

    # If we had a double-quote, we'd better eval it so escape
    # sequences and such can be interpolated. Since the incoming
    # value is supposed to follow shell rules and not perl rules,
    # we escape any perl variable markers
    if ($quote_type eq '"') {
	$value =~ s/\$/\\\$/g;
	$value =~ s/\@@/\\\@@/g;
	eval "\$value = \"$value\"";
a209 1
EOT
d211 1
a211 9
$fetch_string .= <<'EOT';
    # So we can say "if $Config{'foo'}".
    $value = undef if $value eq 'undef';
    $self->{$key} = $value; # cache it
}
EOT

eval $fetch_string;
die if $@@;
d215 1
a215 1
our $Config_SH_expanded = join "\n", '', @@v_others;
a231 1

d235 1
a235 1
our \$byteorder = join('', unpack('$format', pack('$f', \$i)));
d238 1
a238 1
    $byteorder_code = "our \$byteorder = '?'x$s;\n";
d241 1
a241 1
print CONFIG_HEAVY @@non_v, "\n";
d244 1
a244 1
print CONFIG_HEAVY "our \$summary = <<'!END!';\n";
d247 1
a247 1
do { print CONFIG_HEAVY $_ } until !defined($_ = <MYCONFIG>) || /^\s*$/;
d250 5
a254 1
print CONFIG_HEAVY "\n!END!\n", <<'EOT';
d260 1
a260 1
		 { my $c = $Config::Config{$1}; defined($c) ? $c : 'undef' }ge;
d268 7
a274 1
print CONFIG_HEAVY join('', sort @@v_others), "!END!\n";
d276 1
a276 7
# Only need the dynamic byteorder code in Config.pm if 'byteorder' is one of
# the precached keys
if ($Common{byteorder}) {
    print CONFIG $byteorder_code;
} else {
    print CONFIG_HEAVY $byteorder_code;
}
d278 1
a278 2
print CONFIG_HEAVY <<'EOT';
s/(byteorder=)(['"]).*?\2/$1$2$Config::byteorder$2/m;
d280 2
a281 1
my $config_sh_len = length $_;
d283 1
a283 2
our $Config_SH_expanded = "\n$_" . << 'EOVIRTUAL';
EOT
d285 24
a308 23
foreach my $prefix (qw(ccflags ldflags)) {
    my $value = fetch_string ({}, $prefix);
    my $withlargefiles = fetch_string ({}, $prefix . "_uselargefiles");
    $value =~ s/\Q$withlargefiles\E\b//;
    print CONFIG_HEAVY "${prefix}_nolargefiles='$value'\n";
}

foreach my $prefix (qw(libs libswanted)) {
    my $value = fetch_string ({}, $prefix);
    my @@lflibswanted
       = split(' ', fetch_string ({}, 'libswanted_uselargefiles'));
    if (@@lflibswanted) {
	my %lflibswanted;
	@@lflibswanted{@@lflibswanted} = ();
	if ($prefix eq 'libs') {
	    my @@libs = grep { /^-l(.+)/ &&
                            not exists $lflibswanted{$1} }
		                    split(' ', fetch_string ({}, 'libs'));
	    $value = join(' ', @@libs);
	} else {
	    my @@libswanted = grep { not exists $lflibswanted{$_} }
	                          split(' ', fetch_string ({}, 'libswanted'));
	    $value = join(' ', @@libswanted);
d311 2
a312 1
    print CONFIG_HEAVY "${prefix}_nolargefiles='$value'\n";
d315 1
a315 7
print CONFIG_HEAVY "EOVIRTUAL\n";

print CONFIG_HEAVY $fetch_string;

print CONFIG <<'ENDOFEND';

sub FETCH {
d321 6
a326 1
    return $self->fetch_string($key);
d328 1
a328 4
ENDOFEND

print CONFIG_HEAVY <<'ENDOFEND';

d333 1
a333 1
    substr($Config_SH_expanded, 1, index($Config_SH_expanded, '=') - 1 );
a336 3
ENDOFEND
if ($seen_quotes{'"'}) {
print CONFIG_HEAVY <<'ENDOFEND';
d338 3
a340 12
    my $quote = substr($Config_SH_expanded,
		       index($Config_SH_expanded, "=", $prevpos)+1, 1);
    my $pos = index($Config_SH_expanded, qq($quote\n), $prevpos) + 2;
ENDOFEND
} else {
    # Just ' quotes, so it's much easier.
print CONFIG_HEAVY <<'ENDOFEND';
    my $pos = index($Config_SH_expanded, qq('\n), $prevpos) + 2;
ENDOFEND
}
print CONFIG_HEAVY <<'ENDOFEND';
    my $len = index($Config_SH_expanded, "=", $pos) - $pos;
d342 1
a342 1
    $len > 0 ? substr($Config_SH_expanded, $pos, $len) : undef;
d345 1
a345 1
sub EXISTS {
d348 5
a352 8
    return(index($Config_SH_expanded, "\n$_[1]='") != -1
ENDOFEND
if ($seen_quotes{'"'}) {
print CONFIG_HEAVY <<'ENDOFEND';
           or index($Config_SH_expanded, "\n$_[1]=\"") != -1
ENDOFEND
}
print CONFIG_HEAVY <<'ENDOFEND';
d362 1
a362 1
    substr $Config_SH_expanded, 1, $config_sh_len;
d367 1
a367 2
    return map { chomp; $_ } grep eval{ /^(?:$re)=/ }, split /^/,
    $Config_SH_expanded;
d385 1
a385 2
	    my $v = (exists $Config::Config{$qry}) ? $Config::Config{$qry}
						   : 'UNKNOWN';
a391 7
# Called by the real AUTOLOAD
sub launcher {
    undef &AUTOLOAD;
    goto \&$Config::AUTOLOAD;
}

1;
d398 1
a398 1
    my ($value, $v) = $Config_SH_expanded =~ m/^used_aout='(.*)'\s*$/m;
d400 1
a400 1
        ($v) = $Config_SH_expanded =~ m/^aout_$_='(.*)'\s*$/m;
d426 2
a427 19
foreach my $key (keys %Common) {
    my $value = fetch_string ({}, $key);
    # Is it safe on the LHS of => ?
    my $qkey = $key =~ /^[A-Za-z_][A-Za-z0-9_]*$/ ? $key : "'$key'";
    if (defined $value) {
	# Quote things for a '' string
	$value =~ s!\\!\\\\!g;
	$value =~ s!'!\\'!g;
	$value = "'$value'";
    } else {
	$value = "undef";
    }
    $Common{$key} = "$qkey => $value";
}

if ($Common{byteorder}) {
    $Common{byteorder} = 'byteorder => $byteorder';
}
my $fast_config = join '', map { "    $_,\n" } sort values %Common;
a428 2
# Sanity check needed to stop an infite loop if Config_heavy.pl fails to define
# &launcher for some reason (eg it got truncated)
d431 1
d434 3
a436 5
sub AUTOLOAD {
    require 'Config_heavy.pl';
    goto \&launcher unless $Config::AUTOLOAD =~ /launcher$/;
    die "&Config::AUTOLOAD failed on $Config::AUTOLOAD";
}
d438 1
a438 3
# tie returns the object, so the value returned to require will be true.
tie %%Config, 'Config', {
%s};
d564 2
a565 2
my %seen = ();
my $text = 0;
a639 1
close(CONFIG_HEAVY);
a673 1
require $Config_heavy;
a690 103
# Popularity of various entries in %Config, based on a large build and test
# run of code in the Fotango build system:
__DATA__
path_sep:	8490
d_readlink:	7101
d_symlink:	7101
archlibexp:	4318
sitearchexp:	4305
sitelibexp:	4305
privlibexp:	4163
ldlibpthname:	4041
libpth:	2134
archname:	1591
exe_ext:	1256
scriptdir:	1155
version:	1116
useithreads:	1002
osvers:	982
osname:	851
inc_version_list:	783
dont_use_nlink:	779
intsize:	759
usevendorprefix:	642
dlsrc:	624
cc:	541
lib_ext:	520
so:	512
ld:	501
ccdlflags:	500
ldflags:	495
obj_ext:	495
cccdlflags:	493
lddlflags:	493
ar:	492
dlext:	492
libc:	492
ranlib:	492
full_ar:	491
vendorarchexp:	491
vendorlibexp:	491
installman1dir:	489
installman3dir:	489
installsitebin:	489
installsiteman1dir:	489
installsiteman3dir:	489
installvendorman1dir:	489
installvendorman3dir:	489
d_flexfnam:	474
eunicefix:	360
d_link:	347
installsitearch:	344
installscript:	341
installprivlib:	337
binexp:	336
installarchlib:	336
installprefixexp:	336
installsitelib:	336
installstyle:	336
installvendorarch:	336
installvendorbin:	336
installvendorlib:	336
man1ext:	336
man3ext:	336
sh:	336
siteprefixexp:	336
installbin:	335
usedl:	332
ccflags:	285
startperl:	232
optimize:	231
usemymalloc:	229
cpprun:	228
sharpbang:	228
perllibs:	225
usesfio:	224
usethreads:	220
perlpath:	218
extensions:	217
usesocks:	208
shellflags:	198
make:	191
d_pwage:	189
d_pwchange:	189
d_pwclass:	189
d_pwcomment:	189
d_pwexpire:	189
d_pwgecos:	189
d_pwpasswd:	189
d_pwquota:	189
gccversion:	189
libs:	186
useshrplib:	186
cppflags:	185
ptrsize:	185
shrpenv:	185
static_ext:	185
use5005threads:	185
uselargefiles:	185
alignbytes:	184
byteorder:	184
ccversion:	184
config_args:	184
cppminus:	184
@


1.1.1.11
log
@import perl 5.10.0 from CPAN
@
text
@a1 37
#
# configpm
#
# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
# 2002, 2003, 2004, 2005, 2006, 2007 Larry Wall and others.
#
#
# Regenerate the files
#
#    lib/Config.pm
#    lib/Config_heavy.pl
#    lib/Config.pod
#    lib/Cross.pm (optionally)
#
#
# from the contents of the static files
#
#    Porting/Glossary
#    myconfig.SH
#
# and from the contents of the Configure-generated file
#
#    config.sh
#
# Note that output directory is xlib/[cross-name]/ for cross-compiling
#
# It will only update Config.pm and Config_heavy.pl if the contents of
# either file would be different. Note that *both* files are updated in
# this case, since for example an extension makefile that has a dependency
# on Config.pm should trigger even if only Config_heavy.pl has changed.

sub usage { die <<EOF }
usage: $0  [ options ]
    --cross=PLATFORM    cross-compile for a different platform
    --no-glossary       don't include Porting/Glossary in lib/Config.pod
EOF

d26 1
d41 1
a41 2
        warn "option '$opt' is not recognized";
	usage;
d51 2
a52 2
my ($Config_SH, $Config_PM, $Config_heavy, $Config_POD);
my $Glossary = 'Porting/Glossary';
d58 7
a64 3
  $Config_PM = "xlib/$Opts{cross}/Config.pm";
  $Config_POD = "xlib/$Opts{cross}/Config.pod";
  $Config_SH = "Cross/config-$Opts{cross}.sh";
d67 4
a70 7
  $Config_PM = "lib/Config.pm";
  $Config_POD = "lib/Config.pod";
  $Config_SH = "config.sh";
}
($Config_heavy = $Config_PM) =~ s/\.pm$/_heavy.pl/;
die "Can't automatically determine name for Config_heavy.pl from '$Config_PM'"
  if $Config_heavy eq $Config_PM;
d72 2
a73 2
my $config_txt;
my $heavy_txt;
d75 1
a75 1
$heavy_txt .= <<'ENDOFBEG';
d85 1
a85 1
my $myver = sprintf "%vd", $^V;
d87 1
a87 1
$config_txt .= sprintf <<'ENDOFBEG', ($myver) x 3;
d149 1
a149 1
  open(CONFIG_SH, $Config_SH) || die "Can't open $Config_SH: $!";
d298 1
a298 113
my @@need_relocation;

if (fetch_string({},'userelocatableinc')) {
    foreach my $what (qw(prefixexp

			 archlibexp
			 html1direxp
			 html3direxp
			 man1direxp
			 man3direxp
			 privlibexp
			 scriptdirexp
			 sitearchexp
			 sitebinexp
			 sitehtml1direxp
			 sitehtml3direxp
			 sitelibexp
			 siteman1direxp
			 siteman3direxp
			 sitescriptexp
			 vendorarchexp
			 vendorbinexp
			 vendorhtml1direxp
			 vendorhtml3direxp
			 vendorlibexp
			 vendorman1direxp
			 vendorman3direxp
			 vendorscriptexp

			 siteprefixexp
			 sitelib_stem
			 vendorlib_stem

			 installarchlib
			 installhtml1dir
			 installhtml3dir
			 installman1dir
			 installman3dir
			 installprefix
			 installprefixexp
			 installprivlib
			 installscript
			 installsitearch
			 installsitebin
			 installsitehtml1dir
			 installsitehtml3dir
			 installsitelib
			 installsiteman1dir
			 installsiteman3dir
			 installsitescript
			 installvendorarch
			 installvendorbin
			 installvendorhtml1dir
			 installvendorhtml3dir
			 installvendorlib
			 installvendorman1dir
			 installvendorman3dir
			 installvendorscript
			 )) {
	push @@need_relocation, $what if fetch_string({}, $what) =~ m!^\.\.\./!;
    }
}

my %need_relocation;
@@need_relocation{@@need_relocation} = @@need_relocation;

# This can have .../ anywhere:
if (fetch_string({}, 'otherlibdirs') =~ m!\.\.\./!) {
    $need_relocation{otherlibdirs} = 'otherlibdirs';
}

my $relocation_code = <<'EOT';

sub relocate_inc {
  my $libdir = shift;
  return $libdir unless $libdir =~ s!^\.\.\./!!;
  my $prefix = $^X;
  if ($prefix =~ s!/[^/]*$!!) {
    while ($libdir =~ m!^\.\./!) {
      # Loop while $libdir starts "../" and $prefix still has a trailing
      # directory
      last unless $prefix =~ s!/([^/]+)$!!;
      # but bail out if the directory we picked off the end of $prefix is .
      # or ..
      if ($1 eq '.' or $1 eq '..') {
	# Undo! This should be rare, hence code it this way rather than a
	# check each time before the s!!! above.
	$prefix = "$prefix/$1";
	last;
      }
      # Remove that leading ../ and loop again
      substr ($libdir, 0, 3, '');
    }
    $libdir = "$prefix/$libdir";
  }
  $libdir;
}
EOT

if (%need_relocation) {
  my $relocations_in_common;
  # otherlibdirs only features in the hash
  foreach (keys %need_relocation) {
    $relocations_in_common++ if $Common{$_};
  }
  if ($relocations_in_common) {
    $config_txt .= $relocation_code;
  } else {
    $heavy_txt .= $relocation_code;
  }
}

$heavy_txt .= join('', @@non_v) . "\n";
d301 1
a301 1
$heavy_txt .= "our \$summary = <<'!END!';\n";
d304 1
a304 1
do { $heavy_txt .= $_ } until !defined($_ = <MYCONFIG>) || /^\s*$/;
d307 1
a307 1
$heavy_txt .= "\n!END!\n" . <<'EOT';
d321 1
a321 1
$heavy_txt .= join('', sort @@v_others) . "!END!\n";
d326 1
a326 1
    $config_txt .= $byteorder_code;
d328 1
a328 18
    $heavy_txt .= $byteorder_code;
}

if (@@need_relocation) {
$heavy_txt .= 'foreach my $what (qw(' . join (' ', @@need_relocation) .
      ")) {\n" . <<'EOT';
    s/^($what=)(['"])(.*?)\2/$1 . $2 . relocate_inc($3) . $2/me;
}
EOT
# Currently it only makes sense to do the ... relocation on Unix, so there's
# no need to emulate the "which separator for this platform" logic in perl.c -
# ':' will always be applicable
if ($need_relocation{otherlibdirs}) {
$heavy_txt .= << 'EOT';
s{^(otherlibdirs=)(['"])(.*?)\2}
 {$1 . $2 . join ':', map {relocate_inc($_)} split ':', $3 . $2}me;
EOT
}
d331 1
a331 1
$heavy_txt .= <<'EOT';
d342 2
a343 4
    if (defined $withlargefiles) {
        $value =~ s/\Q$withlargefiles\E\b//;
        $heavy_txt .= "${prefix}_nolargefiles='$value'\n";
    }
a347 2
    my $withlf = fetch_string ({}, 'libswanted_uselargefiles');
    next unless defined $withlf;
d364 1
a364 1
    $heavy_txt .= "${prefix}_nolargefiles='$value'\n";
d367 1
a367 1
$heavy_txt .= "EOVIRTUAL\n";
d369 1
a369 1
$heavy_txt .= $fetch_string;
d371 1
a371 1
$config_txt .= <<'ENDOFEND';
d383 1
a383 1
$heavy_txt .= <<'ENDOFEND';
d395 1
a395 1
$heavy_txt .= <<'ENDOFEND';
d403 1
a403 1
$heavy_txt .= <<'ENDOFEND';
d407 1
a407 1
$heavy_txt .= <<'ENDOFEND';
d419 1
a419 1
$heavy_txt .= <<'ENDOFEND';
d423 1
a423 1
$heavy_txt .= <<'ENDOFEND';
d475 1
a475 1
    $config_txt .= <<'ENDOFSET';
d495 1
a495 1
    $config_txt .= <<ENDOFSET if $dll;
d499 1
a499 1
    $config_txt .= <<'ENDOFSET';
a514 5
	if ($key eq 'otherlibdirs') {
	    $value = "join (':', map {relocate_inc(\$_)} split (':', $value))";
	} elsif ($need_relocation{$key}) {
	    $value = "relocate_inc($value)";
	}
d528 1
a528 1
$config_txt .= sprintf <<'ENDOFTIE', $fast_config;
d544 1
a544 1
open(CONFIG_POD, ">$Config_POD") or die "Can't open $Config_POD: $!";
d742 3
a744 1
close(GLOS) if $Opts{glossary};
a745 22
print "written $Config_POD\n";

my $orig_config_txt = "";
my $orig_heavy_txt = "";
{
    local $/;
    my $fh;
    $orig_config_txt = <$fh> if open $fh, "<", $Config_PM;
    $orig_heavy_txt  = <$fh> if open $fh, "<", $Config_heavy;
}

if ($orig_config_txt ne $config_txt or $orig_heavy_txt ne $heavy_txt) {
    open CONFIG, ">", $Config_PM or die "Can't open $Config_PM: $!\n";
    open CONFIG_HEAVY, ">", $Config_heavy or die "Can't open $Config_heavy: $!\n";
    print CONFIG $config_txt;
    print CONFIG_HEAVY $heavy_txt;
    close(CONFIG_HEAVY);
    close(CONFIG);
    print "updated $Config_PM\n";
    print "updated $Config_heavy\n";
}

a771 2
  print "written lib/Cross.pm\n";
  unshift(@@INC,"xlib/$Opts{cross}");
a775 1
unshift(@@INC,'xlib/symbian') if $Opts{cross};
@


1.1.1.12
log
@import perl 5.10.1
@
text
@a126 4
# for a description of the variables, please have a look at the
# Glossary file, as written in the Porting folder, or use the url:
# http://perl5.git.perl.org/perl.git/blob/HEAD:/Porting/Glossary

d461 1
a461 13
		 { 
			my $c;
			if ($1 eq 'git_ancestor_line') {
				if ($Config::Config{git_ancestor}) {
					$c= "\n  Ancestor: $Config::Config{git_ancestor}";
				} else {
					$c= "";
				}
			} else {
                     		$c = $Config::Config{$1}; 
			}
			defined($c) ? $c : 'undef' 
		}ge;
a537 9
$heavy_txt .= <<'ENDOFGIT';
eval {
	# do not have hairy conniptions if this isnt available
	require 'Config_git.pl';
	$Config_SH_expanded .= $Config::Git_Data;
	1;
} or warn "Warning: failed to load Config_git.pl, something strange about this perl...\n";
ENDOFGIT

a753 4
For a description of the variables, please have a look at the
Glossary file, as written in the Porting folder, or use the url:
http://perl5.git.perl.org/perl.git/blob/HEAD:/Porting/Glossary

a834 2
=cut

a850 2
=cut

a856 2
=cut

a904 15

=head1 GIT DATA

Information on the git commit from which the current perl binary was compiled
can be found in the variable C<$Config::Git_Data>.  The variable is a
structured string that looks something like this:

  git_commit_id='ea0c2dbd5f5ac6845ecc7ec6696415bf8e27bd52'
  git_describe='GitLive-blead-1076-gea0c2db'
  git_branch='smartmatch'
  git_uncommitted_changes=''
  git_commit_id_title='Commit id:'
  git_commit_date='2009-05-09 17:47:31 +0200'

Its format is not guaranteed not to change over time.
@


1.1.1.13
log
@Perl 5.12.2 from CPAN
@
text
@a36 1
    --chdir=dir         change directory before writing files
a62 1
    'chdir'    => '', # --chdir=dir    - change directory before writing files
a87 4
if ($Opts{chdir}) {
    chdir $Opts{chdir} or die "$0: could not chdir $Opts{chdir}: $!"
}

a118 39

sub _V {
    my ($bincompat, $non_bincompat, $date, @@patches) = Internals::V();

    my $opts = join ' ', sort split ' ', "$bincompat $non_bincompat";

    # wrap at 76 columns.

    $opts =~ s/(?=.{53})(.{1,53}) /$1\n                        /mg;

    print Config::myconfig();
    if ($^O eq 'VMS') {
        print "\nCharacteristics of this PERLSHR image: \n";
    } else {
        print "\nCharacteristics of this binary (from libperl): \n";
    }

    print "  Compile-time options: $opts\n";

    if (@@patches) {
        print "  Locally applied patches:\n";
        print "\t$_\n" foreach @@patches;
    }

    print "  Built under $^O\n";

    print "  $date\n" if defined $date;

    my @@env = map { "$_=\"$ENV{$_}\"" } sort grep {/^PERL/} keys %ENV;
    push @@env, "CYGWIN=\"$ENV{CYGWIN}\"" if $^O eq 'cygwin';

    if (@@env) {
        print "  \%ENV:\n";
        print "    $_\n" foreach @@env;
    }
    print "  \@@INC:\n";
    print "    $_\n" foreach @@INC;
}

@


1.1.1.14
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@a54 5
# Post 37589e1eefb1bd62 DynaLoader defaults to reading these at runtime.
# Ideally we're redo the data below, but Fotango's build system made it
# wonderfully easy to instrument, and no longer exists.
$Common{$_} = $_ foreach qw(dlext so);

a58 30
# The plan is that this information is used by ExtUtils::MakeMaker to generate
# Makefile dependencies, rather than hardcoding a list, which has become out
# of date. However, currently, MM_Unix.pm and MM_VMS.pm have *different* lists,
# *and* descrip_mms.template doesn't actually install all the headers.
# The "Unix" list seems to (attempt to) avoid the generated headers, which I'm
# not sure is the right thing to do. Also, not certain whether it would be
# easier to parse MANIFEST to get these (adding config.h, and potentially
# removing others), but for now, stick to a hard coded list.

# Could use a map to add ".h", but I suspect that it's easier to use literals,
# so that anyone using grep will find them
# This is the list from MM_VMS, plus pad.h, parser.h, perlsfio.h utf8.h
# which it installs. It *doesn't* install perliol.h - FIXME.
my @@header_files = qw(EXTERN.h INTERN.h XSUB.h av.h config.h cop.h cv.h
		      embed.h embedvar.h form.h gv.h handy.h hv.h intrpvar.h
		      iperlsys.h keywords.h mg.h nostdio.h op.h opcode.h
		      pad.h parser.h patchlevel.h perl.h perlio.h perlsdio.h
		      perlsfio.h perlvars.h perly.h pp.h pp_proto.h proto.h
		      regcomp.h regexp.h regnodes.h scope.h sv.h thread.h utf8.h
		      util.h);

# No point in adding fakethr.h, as it no longer works
push @@header_files,
    $^O eq 'VMS' ? 'vmsish.h' : qw(dosish.h perliol.h time64.h unixish.h);

my $header_files = '    return qw(' . join(' ', sort @@header_files) . ');';
$header_files =~ s/(?=.{64})   # If line is still overlength
		   (.{1,64})\  # Split at the last convenient space
		  /$1\n              /gx;

d123 2
a124 19
use warnings;
use vars '%Config';

sub bincompat_options {
    return split ' ', (Internals::V())[0];
}

sub non_bincompat_options {
    return split ' ', (Internals::V())[1];
}

sub compile_date {
    return (Internals::V())[2]
}

sub local_patches {
    my (undef, undef, undef, @@patches) = Internals::V();
    return @@patches;
}
d154 1
a154 1
    push @@env, "CYGWIN=\"$ENV{CYGWIN}\"" if $^O eq 'cygwin' and $ENV{CYGWIN};
a163 1
sub header_files {
d166 1
a166 1
$heavy_txt .= $header_files . "\n}\n\n";
d168 1
a168 10
my $export_funcs = <<'EOT';
my %Export_Cache = (myconfig => 1, config_sh => 1, config_vars => 1,
		    config_re => 1, compile_date => 1, local_patches => 1,
		    bincompat_options => 1, non_bincompat_options => 1,
		    header_files => 1);
EOT

my %export_ok = eval $export_funcs or die;

$config_txt .= sprintf << 'EOT', $export_funcs;
d178 2
a179 7
use warnings;
use vars '%%Config';

# Skip @@Config::EXPORT because it only contains %%Config, which we special
# case below as it's not a function. @@Config::EXPORT won't change in the
# lifetime of Perl 5.
%s
d181 1
a181 1
@@Config::EXPORT_OK = keys %%Export_Cache;
d186 4
a189 1
EOT
d191 1
a191 1
$config_txt .= "sub $_;\n" foreach sort keys %export_ok;
d193 1
a193 3
my $myver = sprintf "%vd", $^V;

$config_txt .= sprintf <<'ENDOFBEG', ($myver) x 3;
d197 1
a197 1
    shift;
d206 2
a207 2
	die qq{"$func" is not exported by the Config module\n}
	    unless $Export_Cache{$func};
d215 1
a215 1
die "Perl lib version (%s) doesn't match executable '$0' version ($])"
d219 1
a219 1
    or die "Perl lib version (%s) doesn't match executable '$0' version (" .
a228 1
my $quote;
d260 1
a264 1
	$quote = $2;
d294 24
d319 13
a331 2
$fetch_string .= <<'EOT';
    return undef unless my ($quote_type, $value) = $Config_SH_expanded =~ /\n$key=(['"])(.*?)\1\n/s;
a336 4

    # Historically, since " 'support' was added in change 1409, the
    # interpolation was done before the undef. Stick to this arguably buggy
    # behaviour as we're refactoring.
d342 1
a342 3

    # So we can say "if $Config{'foo'}".
    $self->{$key} = $value eq 'undef' ? undef : $value; # cache it
a343 5
EOT

} else {
    # We only have ' delimted.

a344 1
    return undef unless $Config_SH_expanded =~ /\n$key=\'(.*?)\'\n/s;
d346 2
a347 1
    $self->{$key} = $1 eq 'undef' ? undef : $1;
a350 2
}

d370 1
a370 1
    my $list = join ',', reverse(1..$s-1);
d374 3
a376 2
my \$i = ord($s);
foreach my \$c ($list) { \$i <<= 8; \$i |= ord(\$c); }
d616 3
a618 1
    return exists $self->{$key} ? $self->{$key} : $self->fetch_string($key);
a619 1

d667 3
a669 1
*DELETE = *CLEAR = \*STORE; # Typeglob aliasing uses less space
d833 1
a833 1
See also C<-V> in L<perlrun/Command Switches>.
d853 1
a853 28
See also C<-V:name> in L<perlrun/Command Switches>.

=item bincompat_options()

Returns a list of C pre-processor options used when compiling this F<perl>
binary, which affect its binary compatibility with extensions.
C<bincompat_options()> and C<non_bincompat_options()> are shown together in
the output of C<perl -V> as I<Compile-time options>.

=item non_bincompat_options()

Returns a list of C pre-processor options used when compiling this F<perl>
binary, which do not affect binary compatibility with extensions.

=item compile_date()

Returns the compile date (as a string), equivalent to what is shown by
C<perl -V>

=item local_patches()

Returns a list of the names of locally applied patches, equivalent to what
is shown by C<perl -V>.

=item header_files()

Returns a list of the header files that should be used as dependencies for
XS code, for this version of Perl on this platform.
@


1.1.1.15
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d78 1
a78 1
		      embed.h embedvar.h form.h gv.h handy.h hv.h hv_func.h intrpvar.h
d152 1
a152 4
my $from = $^O eq 'VMS' ? 'PERLSHR image' : 'binary (from libperl)';
my $env_cygwin = $^O eq 'cygwin'
    ? 'push @@env, "CYGWIN=\"$ENV{CYGWIN}\"" if $ENV{CYGWIN};' . "\n" : "";
$heavy_txt .= sprintf <<'ENDOFBEG', $^O, $^O, $from, $^O, $env_cygwin;
d159 1
a159 1
use vars '%%Config';
a178 3
    die "Perl lib was built for '%s' but is being run on '$^O'"
        unless "%s" eq $^O;

d188 5
a192 1
    print "\nCharacteristics of this %s: \n";
d201 1
a201 1
    print "  Built under %s\n";
d205 3
a207 2
    my @@env = map { "$_=\"$ENV{$_}\"" } sort grep {/^PERL/} keys %%ENV;
%s
d209 1
a209 1
        print "  \%%ENV:\n";
d230 1
a230 1
$config_txt .= sprintf << 'EOT', $], $export_funcs;
d241 1
a241 3
use vars '%%Config', '$VERSION';

$VERSION = "%s";
d811 2
a812 2
# Sanity check needed to stop an infinite loop if Config_heavy.pl fails to
# define &launcher for some reason (eg it got truncated)
@


1.1.1.16
log
@Import perl-5.20.1
@
text
@d14 1
d26 1
d35 1
d75 1
a75 1
# This is the list from MM_VMS, plus pad.h, parser.h, utf8.h
d81 1
a81 1
		      perlvars.h perly.h pp.h pp_proto.h proto.h
d85 1
d96 1
d132 13
a144 4
$Config_PM = "lib/Config.pm";
$Config_POD = "lib/Config.pod";
$Config_SH = "config.sh";

d152 70
d284 1
a284 1
die "$0: Perl lib version (%s) doesn't match executable '$^X' version ($])"
d288 2
a289 1
    or die sprintf "%%s: Perl lib version (%s) doesn't match executable '$^X' version (%%vd)", $0, $^V;
d388 1
a388 1
    # We only have ' delimited.
a528 72
my $osname = fetch_string({}, 'osname');
my $from = $osname eq 'VMS' ? 'PERLSHR image' : 'binary (from libperl)';
my $env_cygwin = $osname eq 'cygwin'
    ? 'push @@env, "CYGWIN=\"$ENV{CYGWIN}\"" if $ENV{CYGWIN};' . "\n" : "";

$heavy_txt .= sprintf <<'ENDOFBEG', $osname, $osname, $from, $osname, $env_cygwin;
# This file was created by configpm when Perl was built. Any changes
# made to this file will be lost the next time perl is built.

package Config;
use strict;
use warnings;
use vars '%%Config';

sub bincompat_options {
    return split ' ', (Internals::V())[0];
}

sub non_bincompat_options {
    return split ' ', (Internals::V())[1];
}

sub compile_date {
    return (Internals::V())[2]
}

sub local_patches {
    my (undef, undef, undef, @@patches) = Internals::V();
    return @@patches;
}

sub _V {
    die "Perl lib was built for '%s' but is being run on '$^O'"
        unless "%s" eq $^O;

    my ($bincompat, $non_bincompat, $date, @@patches) = Internals::V();

    my $opts = join ' ', sort split ' ', "$bincompat $non_bincompat";

    # wrap at 76 columns.

    $opts =~ s/(?=.{53})(.{1,53}) /$1\n                        /mg;

    print Config::myconfig();
    print "\nCharacteristics of this %s: \n";

    print "  Compile-time options: $opts\n";

    if (@@patches) {
        print "  Locally applied patches:\n";
        print "\t$_\n" foreach @@patches;
    }

    print "  Built under %s\n";

    print "  $date\n" if defined $date;

    my @@env = map { "$_=\"$ENV{$_}\"" } sort grep {/^PERL/} keys %%ENV;
%s
    if (@@env) {
        print "  \%%ENV:\n";
        print "    $_\n" foreach @@env;
    }
    print "  \@@INC:\n";
    print "    $_\n" foreach @@INC;
}

sub header_files {
ENDOFBEG

$heavy_txt .= $header_files . "\n}\n\n";

a989 1
my $errors= 0;
d1014 1
a1014 3
      ($text ? " or another paragraph of description" : () ),
      ", instead we got:\n$_";
    $errors++;
d1023 1
a1023 1
     (?<! [\w./<\'\"\$] )		# Only standalone file names
a1050 7
  if ($errors) {
    die "Errors encountered while processing $Glossary. ",
        "Header lines are expected to be of the form:\n",
        "NAME (CLASS):\n",
        "Maybe there is a malformed header?\n",
    ;
  }
d1106 30
d1138 1
@


