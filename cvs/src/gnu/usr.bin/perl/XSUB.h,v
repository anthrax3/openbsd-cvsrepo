head	1.17;
access;
symbols
	OPENBSD_6_2:1.17.0.6
	OPENBSD_6_2_BASE:1.17
	PERL_5_24_2:1.1.1.15
	OPENBSD_6_1:1.17.0.4
	OPENBSD_6_1_BASE:1.17
	OPENBSD_6_0:1.16.0.10
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.16.0.4
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.16.0.6
	OPENBSD_5_8_BASE:1.16
	PERL_5_20_2:1.1.1.14
	OPENBSD_5_7:1.16.0.2
	OPENBSD_5_7_BASE:1.16
	PERL_5_20_1:1.1.1.14
	OPENBSD_5_6:1.15.0.4
	OPENBSD_5_6_BASE:1.15
	PERL_5_18_2:1.1.1.13
	PERL:1.1.1
	OPENBSD_5_5:1.14.0.6
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.2
	OPENBSD_5_4_BASE:1.14
	PERL_5_16_3:1.1.1.12
	OPENBSD_5_3:1.13.0.10
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.8
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.6
	OPENBSD_5_0:1.13.0.4
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.2
	OPENBSD_4_9_BASE:1.13
	PERL_5_12_2:1.1.1.11
	OPENBSD_4_8:1.12.0.4
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	PERL_5_10_1:1.1.1.10
	OPENBSD_4_6:1.11.0.6
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.2
	OPENBSD_4_5_BASE:1.11
	PERL_5_10_0:1.1.1.9
	OPENBSD_4_4:1.10.0.8
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.6
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.4
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.2
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9
	PERL_5_8_8:1.1.1.8
	OPENBSD_3_9:1.8.0.8
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.6
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.4
	OPENBSD_3_7_BASE:1.8
	PERL_5_8_6:1.1.1.7
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	PERL_5_8_5:1.1.1.7
	PERL_5_8_3:1.1.1.6
	OPENBSD_3_5:1.6.0.2
	OPENBSD_3_5_BASE:1.6
	PERL_5_8_2:1.1.1.5
	OPENBSD_3_4:1.5.0.4
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.4.0.12
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.10
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.8
	OPENBSD_3_0_BASE:1.4
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.17
date	2017.02.05.00.31.52;	author afresh1;	state Exp;
branches;
next	1.16;
commitid	cxJ08BvJA9Pt2PTM;

1.16
date	2014.11.17.20.56.47;	author afresh1;	state Exp;
branches;
next	1.15;
commitid	QP75iYx42Uo7mMxO;

1.15
date	2014.03.24.15.05.13;	author afresh1;	state Exp;
branches;
next	1.14;

1.14
date	2013.03.25.20.40.43;	author sthen;	state Exp;
branches;
next	1.13;

1.13
date	2010.09.24.15.06.39;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2009.10.12.18.24.20;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2008.09.29.17.35.56;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2007.02.01.12.00.51;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2006.03.28.19.22.56;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2004.08.09.18.08.54;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2004.04.07.21.32.59;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2003.12.03.03.02.19;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.10.27.22.25.17;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.03.42;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.50.55;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.48.17;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.11.36;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.11.36;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.37.01;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.08.32;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.27.22.14.52;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.12.03.02.43.39;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.04.07.21.12.57;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.08.09.17.45.37;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2006.03.28.18.47.49;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2008.09.29.17.18.03;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2009.10.12.18.10.33;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2010.09.24.14.48.17;	author millert;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2013.03.25.20.06.43;	author sthen;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2014.03.24.14.58.48;	author afresh1;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2014.11.17.20.52.41;	author afresh1;	state Exp;
branches;
next	1.1.1.15;
commitid	B31cAbBIXiCqnL97;

1.1.1.15
date	2017.08.14.13.45.31;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.17
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@/*    XSUB.h
 *
 *    Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
 *    2003, 2004, 2005, 2006, 2007, 2008 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

#ifndef _INC_PERL_XSUB_H
#define _INC_PERL_XSUB_H 1

/* first, some documentation for xsubpp-generated items */

/*
=head1 C<xsubpp> variables and internal functions

=for apidoc Amn|char*|CLASS
Variable which is setup by C<xsubpp> to indicate the 
class name for a C++ XS constructor.  This is always a C<char*>.  See
C<L</THIS>>.

=for apidoc Amn|(whatever)|RETVAL
Variable which is setup by C<xsubpp> to hold the return value for an 
XSUB.  This is always the proper type for the XSUB.  See 
L<perlxs/"The RETVAL Variable">.

=for apidoc Amn|(whatever)|THIS
Variable which is setup by C<xsubpp> to designate the object in a C++ 
XSUB.  This is always the proper type for the C++ object.  See C<L</CLASS>> and
L<perlxs/"Using XS With C++">.

=for apidoc Amn|I32|ax
Variable which is setup by C<xsubpp> to indicate the stack base offset,
used by the C<ST>, C<XSprePUSH> and C<XSRETURN> macros.  The C<dMARK> macro
must be called prior to setup the C<MARK> variable.

=for apidoc Amn|I32|items
Variable which is setup by C<xsubpp> to indicate the number of 
items on the stack.  See L<perlxs/"Variable-length Parameter Lists">.

=for apidoc Amn|I32|ix
Variable which is setup by C<xsubpp> to indicate which of an 
XSUB's aliases was used to invoke it.  See L<perlxs/"The ALIAS: Keyword">.

=for apidoc Am|SV*|ST|int ix
Used to access elements on the XSUB's stack.

=for apidoc AmU||XS
Macro to declare an XSUB and its C parameter list.  This is handled by
C<xsubpp>.  It is the same as using the more explicit C<XS_EXTERNAL> macro.

=for apidoc AmU||XS_INTERNAL
Macro to declare an XSUB and its C parameter list without exporting the symbols.
This is handled by C<xsubpp> and generally preferable over exporting the XSUB
symbols unnecessarily.

=for apidoc AmU||XS_EXTERNAL
Macro to declare an XSUB and its C parameter list explicitly exporting the symbols.

=for apidoc Ams||dAX
Sets up the C<ax> variable.
This is usually handled automatically by C<xsubpp> by calling C<dXSARGS>.

=for apidoc Ams||dAXMARK
Sets up the C<ax> variable and stack marker variable C<mark>.
This is usually handled automatically by C<xsubpp> by calling C<dXSARGS>.

=for apidoc Ams||dITEMS
Sets up the C<items> variable.
This is usually handled automatically by C<xsubpp> by calling C<dXSARGS>.

=for apidoc Ams||dXSARGS
Sets up stack and mark pointers for an XSUB, calling C<dSP> and C<dMARK>.
Sets up the C<ax> and C<items> variables by calling C<dAX> and C<dITEMS>.
This is usually handled automatically by C<xsubpp>.

=for apidoc Ams||dXSI32
Sets up the C<ix> variable for an XSUB which has aliases.  This is usually
handled automatically by C<xsubpp>.

=for apidoc Ams||dUNDERBAR
Sets up any variable needed by the C<UNDERBAR> macro.  It used to define
C<padoff_du>, but it is currently a noop.  However, it is strongly advised
to still use it for ensuring past and future compatibility.

=for apidoc AmU||UNDERBAR
The SV* corresponding to the C<$_> variable.  Works even if there
is a lexical C<$_> in scope.

=cut
*/

#ifndef PERL_UNUSED_ARG
#  if defined(lint) && defined(S_SPLINT_S) /* www.splint.org */
#    include <note.h>
#    define PERL_UNUSED_ARG(x) NOTE(ARGUNUSED(x))
#  else
#    define PERL_UNUSED_ARG(x) ((void)x)
#  endif
#endif
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(x) ((void)x)
#endif

#define ST(off) PL_stack_base[ax + (off)]

/* XSPROTO() is also used by SWIG like this:
 *
 *     typedef XSPROTO(SwigPerlWrapper);
 *     typedef SwigPerlWrapper *SwigPerlWrapperPtr;
 *
 * This code needs to be compilable under both C and C++.
 *
 * Don't forget to change the __attribute__unused__ version of XS()
 * below too if you change XSPROTO() here.
 */

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that.
 */

#define XSPROTO(name) void name(pTHX_ CV* cv)

#undef XS
#undef XS_EXTERNAL
#undef XS_INTERNAL
#if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#  define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#  define XS_INTERNAL(name) STATIC XSPROTO(name)
#endif
#if defined(__SYMBIAN32__)
#  define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#  define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#endif
#ifndef XS_EXTERNAL
#  if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#    define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#    define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#  else
#    ifdef __cplusplus
#      define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#      define XS_INTERNAL(name) static XSPROTO(name)
#    else
#      define XS_EXTERNAL(name) XSPROTO(name)
#      define XS_INTERNAL(name) STATIC XSPROTO(name)
#    endif
#  endif
#endif

/* We do export xsub symbols by default for the public XS macro.
 * Try explicitly using XS_INTERNAL/XS_EXTERNAL instead, please. */
#define XS(name) XS_EXTERNAL(name)

#define dAX const I32 ax = (I32)(MARK - PL_stack_base + 1)

#define dAXMARK				\
	I32 ax = POPMARK;	\
	SV **mark = PL_stack_base + ax++

#define dITEMS I32 items = (I32)(SP - MARK)

#if defined(lint) && defined(S_SPLINT_S) /* www.splint.org */
#  define dXSARGS \
	NOTE(ARGUNUSED(cv)) \
	dSP; dAXMARK; dITEMS
#else
#  define dXSARGS \
	dSP; dAXMARK; dITEMS
/* These 3 macros are replacements for dXSARGS macro only in bootstrap.
   They factor out common code in every BOOT XSUB. Computation of vars mark
   and items will optimize away in most BOOT functions. Var ax can never be
   optimized away since BOOT must return &PL_sv_yes by default from xsubpp.
   Note these macros are not drop in replacements for dXSARGS since they set
   PL_xsubfilename. */
#  define dXSBOOTARGSXSAPIVERCHK  \
	I32 ax = XS_BOTHVERSION_SETXSUBFN_POPMARK_BOOTCHECK;	\
	SV **mark = PL_stack_base + ax; dSP; dITEMS
#  define dXSBOOTARGSAPIVERCHK  \
	I32 ax = XS_APIVERSION_SETXSUBFN_POPMARK_BOOTCHECK;	\
	SV **mark = PL_stack_base + ax; dSP; dITEMS
/* dXSBOOTARGSNOVERCHK has no API in xsubpp to choose it so do
#undef dXSBOOTARGSXSAPIVERCHK
#define dXSBOOTARGSXSAPIVERCHK dXSBOOTARGSNOVERCHK */
#  define dXSBOOTARGSNOVERCHK  \
	I32 ax = XS_SETXSUBFN_POPMARK;  \
	SV **mark = PL_stack_base + ax; dSP; dITEMS
#endif

#define dXSTARG SV * const targ = ((PL_op->op_private & OPpENTERSUB_HASTARG) \
			     ? PAD_SV(PL_op->op_targ) : sv_newmortal())

/* Should be used before final PUSHi etc. if not in PPCODE section. */
#define XSprePUSH (sp = PL_stack_base + ax - 1)

#define XSANY CvXSUBANY(cv)

#define dXSI32 I32 ix = XSANY.any_i32

#ifdef __cplusplus
#  define XSINTERFACE_CVT(ret,name) ret (*name)(...)
#  define XSINTERFACE_CVT_ANON(ret) ret (*)(...)
#else
#  define XSINTERFACE_CVT(ret,name) ret (*name)()
#  define XSINTERFACE_CVT_ANON(ret) ret (*)()
#endif
#define dXSFUNCTION(ret)		XSINTERFACE_CVT(ret,XSFUNCTION)
#define XSINTERFACE_FUNC(ret,cv,f)     ((XSINTERFACE_CVT_ANON(ret))(f))
#define XSINTERFACE_FUNC_SET(cv,f)	\
		CvXSUBANY(cv).any_dxptr = (void (*) (pTHX_ void*))(f)

#define dUNDERBAR dNOOP
#define UNDERBAR  find_rundefsv()

/* Simple macros to put new mortal values onto the stack.   */
/* Typically used to return values from XS functions.       */

/*
=head1 Stack Manipulation Macros

=for apidoc Am|void|XST_mIV|int pos|IV iv
Place an integer into the specified position C<pos> on the stack.  The
value is stored in a new mortal SV.

=for apidoc Am|void|XST_mNV|int pos|NV nv
Place a double into the specified position C<pos> on the stack.  The value
is stored in a new mortal SV.

=for apidoc Am|void|XST_mPV|int pos|char* str
Place a copy of a string into the specified position C<pos> on the stack. 
The value is stored in a new mortal SV.

=for apidoc Am|void|XST_mNO|int pos
Place C<&PL_sv_no> into the specified position C<pos> on the
stack.

=for apidoc Am|void|XST_mYES|int pos
Place C<&PL_sv_yes> into the specified position C<pos> on the
stack.

=for apidoc Am|void|XST_mUNDEF|int pos
Place C<&PL_sv_undef> into the specified position C<pos> on the
stack.

=for apidoc Am|void|XSRETURN|int nitems
Return from XSUB, indicating number of items on the stack.  This is usually
handled by C<xsubpp>.

=for apidoc Am|void|XSRETURN_IV|IV iv
Return an integer from an XSUB immediately.  Uses C<XST_mIV>.

=for apidoc Am|void|XSRETURN_UV|IV uv
Return an integer from an XSUB immediately.  Uses C<XST_mUV>.

=for apidoc Am|void|XSRETURN_NV|NV nv
Return a double from an XSUB immediately.  Uses C<XST_mNV>.

=for apidoc Am|void|XSRETURN_PV|char* str
Return a copy of a string from an XSUB immediately.  Uses C<XST_mPV>.

=for apidoc Ams||XSRETURN_NO
Return C<&PL_sv_no> from an XSUB immediately.  Uses C<XST_mNO>.

=for apidoc Ams||XSRETURN_YES
Return C<&PL_sv_yes> from an XSUB immediately.  Uses C<XST_mYES>.

=for apidoc Ams||XSRETURN_UNDEF
Return C<&PL_sv_undef> from an XSUB immediately.  Uses C<XST_mUNDEF>.

=for apidoc Ams||XSRETURN_EMPTY
Return an empty list from an XSUB immediately.

=head1 Variables created by C<xsubpp> and C<xsubpp> internal functions

=for apidoc AmU||newXSproto|char* name|XSUBADDR_t f|char* filename|const char *proto
Used by C<xsubpp> to hook up XSUBs as Perl subs.  Adds Perl prototypes to
the subs.

=for apidoc AmU||XS_VERSION
The version identifier for an XS module.  This is usually
handled automatically by C<ExtUtils::MakeMaker>.  See
C<L</XS_VERSION_BOOTCHECK>>.

=for apidoc Ams||XS_VERSION_BOOTCHECK
Macro to verify that a PM module's C<$VERSION> variable matches the XS
module's C<XS_VERSION> variable.  This is usually handled automatically by
C<xsubpp>.  See L<perlxs/"The VERSIONCHECK: Keyword">.

=for apidoc Ams||XS_APIVERSION_BOOTCHECK
Macro to verify that the perl api version an XS module has been compiled against
matches the api version of the perl interpreter it's being loaded into.

=head1 Exception Handling (simple) Macros

=for apidoc Ams||dXCPT
Set up necessary local variables for exception handling.
See L<perlguts/"Exception Handling">.

=for apidoc AmU||XCPT_TRY_START
Starts a try block.  See L<perlguts/"Exception Handling">.

=for apidoc AmU||XCPT_TRY_END
Ends a try block.  See L<perlguts/"Exception Handling">.

=for apidoc AmU||XCPT_CATCH
Introduces a catch block.  See L<perlguts/"Exception Handling">.

=for apidoc Ams||XCPT_RETHROW
Rethrows a previously caught exception.  See L<perlguts/"Exception Handling">.

=cut
*/

#define XST_mIV(i,v)  (ST(i) = sv_2mortal(newSViv(v))  )
#define XST_mUV(i,v)  (ST(i) = sv_2mortal(newSVuv(v))  )
#define XST_mNV(i,v)  (ST(i) = sv_2mortal(newSVnv(v))  )
#define XST_mPV(i,v)  (ST(i) = sv_2mortal(newSVpv(v,0)))
#define XST_mPVN(i,v,n)  (ST(i) = newSVpvn_flags(v,n, SVs_TEMP))
#define XST_mNO(i)    (ST(i) = &PL_sv_no   )
#define XST_mYES(i)   (ST(i) = &PL_sv_yes  )
#define XST_mUNDEF(i) (ST(i) = &PL_sv_undef)

#define XSRETURN(off)					\
    STMT_START {					\
	const IV tmpXSoff = (off);			\
	assert(tmpXSoff >= 0);\
	PL_stack_sp = PL_stack_base + ax + (tmpXSoff - 1);	\
	return;						\
    } STMT_END

#define XSRETURN_IV(v) STMT_START { XST_mIV(0,v);  XSRETURN(1); } STMT_END
#define XSRETURN_UV(v) STMT_START { XST_mUV(0,v);  XSRETURN(1); } STMT_END
#define XSRETURN_NV(v) STMT_START { XST_mNV(0,v);  XSRETURN(1); } STMT_END
#define XSRETURN_PV(v) STMT_START { XST_mPV(0,v);  XSRETURN(1); } STMT_END
#define XSRETURN_PVN(v,n) STMT_START { XST_mPVN(0,v,n);  XSRETURN(1); } STMT_END
#define XSRETURN_NO    STMT_START { XST_mNO(0);    XSRETURN(1); } STMT_END
#define XSRETURN_YES   STMT_START { XST_mYES(0);   XSRETURN(1); } STMT_END
#define XSRETURN_UNDEF STMT_START { XST_mUNDEF(0); XSRETURN(1); } STMT_END
#define XSRETURN_EMPTY STMT_START {                XSRETURN(0); } STMT_END

#define newXSproto(a,b,c,d)	newXS_flags(a,b,c,d,0)

#ifdef XS_VERSION
#  define XS_VERSION_BOOTCHECK						\
    Perl_xs_handshake(HS_KEY(FALSE, FALSE, "", XS_VERSION), HS_CXT, __FILE__,	\
        items, ax, XS_VERSION)
#else
#  define XS_VERSION_BOOTCHECK
#endif

#define XS_APIVERSION_BOOTCHECK						\
    Perl_xs_handshake(HS_KEY(FALSE, FALSE, "v" PERL_API_VERSION_STRING, ""),	\
        HS_CXT, __FILE__, items, ax, "v" PERL_API_VERSION_STRING)
/* public API, this is a combination of XS_VERSION_BOOTCHECK and
   XS_APIVERSION_BOOTCHECK in 1, and is backportable */
#ifdef XS_VERSION
#  define XS_BOTHVERSION_BOOTCHECK						\
    Perl_xs_handshake(HS_KEY(FALSE, FALSE, "v" PERL_API_VERSION_STRING, XS_VERSION),	\
        HS_CXT, __FILE__, items, ax, "v" PERL_API_VERSION_STRING, XS_VERSION)
#else
/* should this be a #error? if you want both checked, you better supply XS_VERSION right? */
#  define XS_BOTHVERSION_BOOTCHECK XS_APIVERSION_BOOTCHECK
#endif

/* private API */
#define XS_APIVERSION_POPMARK_BOOTCHECK					\
    Perl_xs_handshake(HS_KEY(FALSE, TRUE, "v" PERL_API_VERSION_STRING, ""),	\
        HS_CXT, __FILE__, "v" PERL_API_VERSION_STRING)
#ifdef XS_VERSION
#  define XS_BOTHVERSION_POPMARK_BOOTCHECK					\
    Perl_xs_handshake(HS_KEY(FALSE, TRUE, "v" PERL_API_VERSION_STRING, XS_VERSION),	\
        HS_CXT, __FILE__, "v" PERL_API_VERSION_STRING, XS_VERSION)
#else
/* should this be a #error? if you want both checked, you better supply XS_VERSION right? */
#  define XS_BOTHVERSION_POPMARK_BOOTCHECK XS_APIVERSION_POPMARK_BOOTCHECK
#endif

#define XS_APIVERSION_SETXSUBFN_POPMARK_BOOTCHECK				\
    Perl_xs_handshake(HS_KEY(TRUE, TRUE, "v" PERL_API_VERSION_STRING, ""),	\
        HS_CXT, __FILE__, "v" PERL_API_VERSION_STRING)
#ifdef XS_VERSION
#  define XS_BOTHVERSION_SETXSUBFN_POPMARK_BOOTCHECK				  \
    Perl_xs_handshake(HS_KEY(TRUE, TRUE, "v" PERL_API_VERSION_STRING, XS_VERSION),\
        HS_CXT, __FILE__, "v" PERL_API_VERSION_STRING, XS_VERSION)
#else
/* should this be a #error? if you want both checked, you better supply XS_VERSION right? */
#  define XS_BOTHVERSION_SETXSUBFN_POPMARK_BOOTCHECK XS_APIVERSION_SETXSUBFN_POPMARK_BOOTCHECK
#endif

/* For a normal bootstrap without API or XS version checking.
   Useful for static XS modules or debugging/testing scenarios.
   If this macro gets heavily used in the future, it should separated into
   a separate function independent of Perl_xs_handshake for efficiency */
#define XS_SETXSUBFN_POPMARK \
    Perl_xs_handshake(HS_KEY(TRUE, TRUE, "", "") | HSf_NOCHK, HS_CXT, __FILE__)

#ifdef NO_XSLOCKS
#  define dXCPT             dJMPENV; int rEtV = 0
#  define XCPT_TRY_START    JMPENV_PUSH(rEtV); if (rEtV == 0)
#  define XCPT_TRY_END      JMPENV_POP;
#  define XCPT_CATCH        if (rEtV != 0)
#  define XCPT_RETHROW      JMPENV_JUMP(rEtV)
#endif

/*
   The DBM_setFilter & DBM_ckFilter macros are only used by
   the *DB*_File modules
*/

#define DBM_setFilter(db_type,code)				\
	STMT_START {						\
	    if (db_type)					\
	        RETVAL = sv_mortalcopy(db_type) ;		\
	    ST(0) = RETVAL ;					\
	    if (db_type && (code == &PL_sv_undef)) {		\
	        SvREFCNT_dec_NN(db_type) ;			\
	        db_type = NULL ;				\
	    }							\
	    else if (code) {					\
	        if (db_type)					\
	            sv_setsv(db_type, code) ;			\
	        else						\
	            db_type = newSVsv(code) ;			\
	    }	    						\
	} STMT_END

#define DBM_ckFilter(arg,type,name)				\
        STMT_START {						\
	if (db->type) {						\
	    if (db->filtering) {				\
	        croak("recursion detected in %s", name) ;	\
	    }                     				\
	    ENTER ;						\
	    SAVETMPS ;						\
	    SAVEINT(db->filtering) ;				\
	    db->filtering = TRUE ;				\
	    SAVE_DEFSV ;					\
            if (name[7] == 's')                                 \
                arg = newSVsv(arg);                             \
	    DEFSV_set(arg) ;					\
	    SvTEMP_off(arg) ;					\
	    PUSHMARK(SP) ;					\
	    PUTBACK ;						\
	    (void) perl_call_sv(db->type, G_DISCARD); 		\
	    SPAGAIN ;						\
	    PUTBACK ;						\
	    FREETMPS ;						\
	    LEAVE ;						\
            if (name[7] == 's'){                                \
                arg = sv_2mortal(arg);                          \
            }                                                   \
	} } STMT_END                                                     

#if 1		/* for compatibility */
#  define VTBL_sv		&PL_vtbl_sv
#  define VTBL_env		&PL_vtbl_env
#  define VTBL_envelem		&PL_vtbl_envelem
#  define VTBL_sigelem		&PL_vtbl_sigelem
#  define VTBL_pack		&PL_vtbl_pack
#  define VTBL_packelem		&PL_vtbl_packelem
#  define VTBL_dbline		&PL_vtbl_dbline
#  define VTBL_isa		&PL_vtbl_isa
#  define VTBL_isaelem		&PL_vtbl_isaelem
#  define VTBL_arylen		&PL_vtbl_arylen
#  define VTBL_glob		&PL_vtbl_glob
#  define VTBL_mglob		&PL_vtbl_mglob
#  define VTBL_nkeys		&PL_vtbl_nkeys
#  define VTBL_taint		&PL_vtbl_taint
#  define VTBL_substr		&PL_vtbl_substr
#  define VTBL_vec		&PL_vtbl_vec
#  define VTBL_pos		&PL_vtbl_pos
#  define VTBL_bm		&PL_vtbl_bm
#  define VTBL_fm		&PL_vtbl_fm
#  define VTBL_uvar		&PL_vtbl_uvar
#  define VTBL_defelem		&PL_vtbl_defelem
#  define VTBL_regexp		&PL_vtbl_regexp
#  define VTBL_regdata		&PL_vtbl_regdata
#  define VTBL_regdatum		&PL_vtbl_regdatum
#  ifdef USE_LOCALE_COLLATE
#    define VTBL_collxfrm	&PL_vtbl_collxfrm
#  endif
#  define VTBL_amagic		&PL_vtbl_amagic
#  define VTBL_amagicelem	&PL_vtbl_amagicelem
#endif

#include "perlapi.h"

#if defined(PERL_IMPLICIT_CONTEXT) && !defined(PERL_NO_GET_CONTEXT) && !defined(PERL_CORE)
#  undef aTHX
#  undef aTHX_
#  define aTHX		PERL_GET_THX
#  define aTHX_		aTHX,
#endif

#if defined(PERL_IMPLICIT_SYS) && !defined(PERL_CORE)
#  ifndef NO_XSLOCKS
# if defined (NETWARE) && defined (USE_STDIO)
#    define times		PerlProc_times
#    define setuid		PerlProc_setuid
#    define setgid		PerlProc_setgid
#    define getpid		PerlProc_getpid
#    define pause		PerlProc_pause
#    define exit		PerlProc_exit
#    define _exit		PerlProc__exit
# else
#    undef closedir
#    undef opendir
#    undef stdin
#    undef stdout
#    undef stderr
#    undef feof
#    undef ferror
#    undef fgetpos
#    undef ioctl
#    undef getlogin
#    undef setjmp
#    undef getc
#    undef ungetc
#    undef fileno

/* Following symbols were giving redefinition errors while building extensions - sgp 17th Oct 2000 */
#ifdef NETWARE
#	undef readdir
#	undef fstat
#	undef stat
#	undef longjmp
#	undef endhostent
#	undef endnetent
#	undef endprotoent
#	undef endservent
#	undef gethostbyaddr
#	undef gethostbyname
#	undef gethostent
#	undef getnetbyaddr
#	undef getnetbyname
#	undef getnetent
#	undef getprotobyname
#	undef getprotobynumber
#	undef getprotoent
#	undef getservbyname
#	undef getservbyport
#	undef getservent
#	undef inet_ntoa
#	undef sethostent
#	undef setnetent
#	undef setprotoent
#	undef setservent
#endif	/* NETWARE */

/* to avoid warnings: "xyz" redefined */
#ifdef WIN32
#    undef  popen
#    undef  pclose
#endif /* WIN32 */

#    undef  socketpair

#    define mkdir		PerlDir_mkdir
#    define chdir		PerlDir_chdir
#    define rmdir		PerlDir_rmdir
#    define closedir		PerlDir_close
#    define opendir		PerlDir_open
#    define readdir		PerlDir_read
#    define rewinddir		PerlDir_rewind
#    define seekdir		PerlDir_seek
#    define telldir		PerlDir_tell
#    define putenv		PerlEnv_putenv
#    define getenv		PerlEnv_getenv
#    define uname		PerlEnv_uname
#    define stdin		PerlSIO_stdin
#    define stdout		PerlSIO_stdout
#    define stderr		PerlSIO_stderr
#    define fopen		PerlSIO_fopen
#    define fclose		PerlSIO_fclose
#    define feof		PerlSIO_feof
#    define ferror		PerlSIO_ferror
#    define clearerr		PerlSIO_clearerr
#    define getc		PerlSIO_getc
#    define fgets		PerlSIO_fgets
#    define fputc		PerlSIO_fputc
#    define fputs		PerlSIO_fputs
#    define fflush		PerlSIO_fflush
#    define ungetc		PerlSIO_ungetc
#    define fileno		PerlSIO_fileno
#    define fdopen		PerlSIO_fdopen
#    define freopen		PerlSIO_freopen
#    define fread		PerlSIO_fread
#    define fwrite		PerlSIO_fwrite
#    define setbuf		PerlSIO_setbuf
#    define setvbuf		PerlSIO_setvbuf
#    define setlinebuf		PerlSIO_setlinebuf
#    define stdoutf		PerlSIO_stdoutf
#    define vfprintf		PerlSIO_vprintf
#    define ftell		PerlSIO_ftell
#    define fseek		PerlSIO_fseek
#    define fgetpos		PerlSIO_fgetpos
#    define fsetpos		PerlSIO_fsetpos
#    define frewind		PerlSIO_rewind
#    define tmpfile		PerlSIO_tmpfile
#    define access		PerlLIO_access
#    define chmod		PerlLIO_chmod
#    define chsize		PerlLIO_chsize
#    define close		PerlLIO_close
#    define dup			PerlLIO_dup
#    define dup2		PerlLIO_dup2
#    define flock		PerlLIO_flock
#    define fstat		PerlLIO_fstat
#    define ioctl		PerlLIO_ioctl
#    define isatty		PerlLIO_isatty
#    define link                PerlLIO_link
#    define lseek		PerlLIO_lseek
#    define lstat		PerlLIO_lstat
#    define mktemp		PerlLIO_mktemp
#    define open		PerlLIO_open
#    define read		PerlLIO_read
#    define rename		PerlLIO_rename
#    define setmode		PerlLIO_setmode
#    define stat(buf,sb)	PerlLIO_stat(buf,sb)
#    define tmpnam		PerlLIO_tmpnam
#    define umask		PerlLIO_umask
#    define unlink		PerlLIO_unlink
#    define utime		PerlLIO_utime
#    define write		PerlLIO_write
#    define malloc		PerlMem_malloc
#    define realloc		PerlMem_realloc
#    define free		PerlMem_free
#    define abort		PerlProc_abort
#    define exit		PerlProc_exit
#    define _exit		PerlProc__exit
#    define execl		PerlProc_execl
#    define execv		PerlProc_execv
#    define execvp		PerlProc_execvp
#    define getuid		PerlProc_getuid
#    define geteuid		PerlProc_geteuid
#    define getgid		PerlProc_getgid
#    define getegid		PerlProc_getegid
#    define getlogin		PerlProc_getlogin
#    define kill		PerlProc_kill
#    define killpg		PerlProc_killpg
#    define pause		PerlProc_pause
#    define popen		PerlProc_popen
#    define pclose		PerlProc_pclose
#    define pipe		PerlProc_pipe
#    define setuid		PerlProc_setuid
#    define setgid		PerlProc_setgid
#    define sleep		PerlProc_sleep
#    define times		PerlProc_times
#    define wait		PerlProc_wait
#    define setjmp		PerlProc_setjmp
#    define longjmp		PerlProc_longjmp
#    define signal		PerlProc_signal
#    define getpid		PerlProc_getpid
#    define gettimeofday	PerlProc_gettimeofday
#    define htonl		PerlSock_htonl
#    define htons		PerlSock_htons
#    define ntohl		PerlSock_ntohl
#    define ntohs		PerlSock_ntohs
#    define accept		PerlSock_accept
#    define bind		PerlSock_bind
#    define connect		PerlSock_connect
#    define endhostent		PerlSock_endhostent
#    define endnetent		PerlSock_endnetent
#    define endprotoent		PerlSock_endprotoent
#    define endservent		PerlSock_endservent
#    define gethostbyaddr	PerlSock_gethostbyaddr
#    define gethostbyname	PerlSock_gethostbyname
#    define gethostent		PerlSock_gethostent
#    define gethostname		PerlSock_gethostname
#    define getnetbyaddr	PerlSock_getnetbyaddr
#    define getnetbyname	PerlSock_getnetbyname
#    define getnetent		PerlSock_getnetent
#    define getpeername		PerlSock_getpeername
#    define getprotobyname	PerlSock_getprotobyname
#    define getprotobynumber	PerlSock_getprotobynumber
#    define getprotoent		PerlSock_getprotoent
#    define getservbyname	PerlSock_getservbyname
#    define getservbyport	PerlSock_getservbyport
#    define getservent		PerlSock_getservent
#    define getsockname		PerlSock_getsockname
#    define getsockopt		PerlSock_getsockopt
#    define inet_addr		PerlSock_inet_addr
#    define inet_ntoa		PerlSock_inet_ntoa
#    define listen		PerlSock_listen
#    define recv		PerlSock_recv
#    define recvfrom		PerlSock_recvfrom
#    define select		PerlSock_select
#    define send		PerlSock_send
#    define sendto		PerlSock_sendto
#    define sethostent		PerlSock_sethostent
#    define setnetent		PerlSock_setnetent
#    define setprotoent		PerlSock_setprotoent
#    define setservent		PerlSock_setservent
#    define setsockopt		PerlSock_setsockopt
#    define shutdown		PerlSock_shutdown
#    define socket		PerlSock_socket
#    define socketpair		PerlSock_socketpair
#	endif	/* NETWARE && USE_STDIO */

#    undef fd_set
#    undef FD_SET
#    undef FD_CLR
#    undef FD_ISSET
#    undef FD_ZERO
#    define fd_set		Perl_fd_set
#    define FD_SET(n,p)		PERL_FD_SET(n,p)
#    define FD_CLR(n,p)		PERL_FD_CLR(n,p)
#    define FD_ISSET(n,p)	PERL_FD_ISSET(n,p)
#    define FD_ZERO(p)		PERL_FD_ZERO(p)

#  endif  /* NO_XSLOCKS */
#endif  /* PERL_IMPLICIT_SYS && !PERL_CORE */

#endif /* _INC_PERL_XSUB_H */		/* include guard */

/*
 * ex: set ts=8 sts=4 sw=4 et:
 */
@


1.16
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d17 1
a17 1
=head1 Variables created by C<xsubpp> and C<xsubpp> internal functions
d21 2
a22 1
class name for a C++ XS constructor.  This is always a C<char*>.  See C<THIS>.
d31 1
a31 1
XSUB.  This is always the proper type for the C++ object.  See C<CLASS> and 
d52 1
a52 1
C<xsubpp>.  It is the same as using the more explicit XS_EXTERNAL macro.
d75 1
a75 1
Sets up stack and mark pointers for an XSUB, calling dSP and dMARK.
d89 2
a90 2
The SV* corresponding to the $_ variable.  Works even if there
is a lexical $_ in scope.
d174 18
d285 2
a286 1
handled automatically by C<ExtUtils::MakeMaker>.  See C<XS_VERSION_BOOTCHECK>.
d289 1
a289 1
Macro to verify that a PM module's $VERSION variable matches the XS
d297 1
a297 1
=head1 Simple Exception Handling Macros
d330 1
d349 2
a350 1
    Perl_xs_version_bootcheck(aTHX_ items, ax, STR_WITH_LEN(XS_VERSION))
d356 44
a399 1
    Perl_xs_apiversion_bootcheck(aTHX_ ST(0), STR_WITH_LEN("v" PERL_API_VERSION_STRING))
d420 1
a420 1
                SvREFCNT_dec(db_type) ;				\
a719 6
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
@


1.15
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d25 1
a25 1
XSUB. This is always the proper type for the XSUB. See 
d51 1
a51 1
C<xsubpp>. It is the same as using the more explicit XS_EXTERNAL macro.
d83 2
a84 2
Sets up any variable needed by the C<UNDERBAR> macro. It used to define
C<padoff_du>, but it is currently a noop. However, it is strongly advised
d88 1
a88 1
The SV* corresponding to the $_ variable. Works even if there
@


1.14
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d162 1
a162 1
	register SV **mark = PL_stack_base + ax++
d638 10
a647 12
#    ifdef USE_SOCKETS_AS_HANDLES
#      undef fd_set
#      undef FD_SET
#      undef FD_CLR
#      undef FD_ISSET
#      undef FD_ZERO
#      define fd_set		Perl_fd_set
#      define FD_SET(n,p)	PERL_FD_SET(n,p)
#      define FD_CLR(n,p)	PERL_FD_CLR(n,p)
#      define FD_ISSET(n,p)	PERL_FD_ISSET(n,p)
#      define FD_ZERO(p)	PERL_FD_ZERO(p)
#    endif	/* USE_SOCKETS_AS_HANDLES */
d658 1
a658 1
 * indent-tabs-mode: t
d661 1
a661 1
 * ex: set ts=8 sts=4 sw=4 noet:
@


1.13
log
@merge in perl 5.12.2 plus local changes
@
text
@d51 9
a59 1
C<xsubpp>.
d83 3
a85 2
Sets up the C<padoff_du> variable for an XSUB that wishes to use
C<UNDERBAR>.
d118 8
d129 2
d132 2
a133 1
#  define XS(name) __declspec(dllexport) XSPROTO(name)
d136 2
a137 1
#  define XS(name) EXPORT_C XSPROTO(name)
d139 1
a139 1
#ifndef XS
d141 2
a142 1
#    define XS(name) void name(pTHX_ CV* cv __attribute__unused__)
d145 2
a146 1
#      define XS(name) extern "C" XSPROTO(name)
d148 2
a149 1
#      define XS(name) XSPROTO(name)
d154 4
d197 2
a198 4
#define dUNDERBAR PADOFFSET padoff_du = find_rundefsvoffset()
#define UNDERBAR ((padoff_du == NOT_IN_PAD \
	    || PAD_COMPNAME_FLAGS_isOUR(padoff_du)) \
	? DEFSV : PAD_SVl(padoff_du))
d273 4
d328 1
a328 37
    STMT_START {							\
	SV *_sv;							\
	const char *vn = NULL, *module = SvPV_nolen_const(ST(0));	\
	if (items >= 2)	 /* version supplied as bootstrap arg */	\
	    _sv = ST(1);						\
	else {								\
	    /* XXX GV_ADDWARN */					\
	    _sv = get_sv(Perl_form(aTHX_ "%s::%s", module,		\
				vn = "XS_VERSION"), FALSE);		\
	    if (!_sv || !SvOK(_sv))					\
		_sv = get_sv(Perl_form(aTHX_ "%s::%s", module,		\
				    vn = "VERSION"), FALSE);		\
	}								\
	if (_sv) {							\
	    SV *xpt = NULL;						\
	    SV *xssv = Perl_newSVpvn(aTHX_ STR_WITH_LEN(XS_VERSION));	\
	    SV *pmsv = sv_derived_from(_sv, "version")			\
		? SvREFCNT_inc_simple_NN(_sv)				\
		: new_version(_sv);					\
	    xssv = upg_version(xssv, 0);				\
	    if ( vcmp(pmsv,xssv) ) {	 				\
		xpt = Perl_newSVpvf(aTHX_ "%s object version %"SVf	\
				    " does not match %s%s%s%s %"SVf,	\
				    module,				\
				    SVfARG(Perl_sv_2mortal(aTHX_ vstringify(xssv))), \
				    vn ? "$" : "", vn ? module : "",	\
				    vn ? "::" : "",			\
				    vn ? vn : "bootstrap parameter",	\
				    SVfARG(Perl_sv_2mortal(aTHX_ vstringify(pmsv)))); \
		Perl_sv_2mortal(aTHX_ xpt);				\
	    }								\
	    SvREFCNT_dec(xssv);						\
	    SvREFCNT_dec(pmsv);						\
	    if (xpt)							\
		Perl_croak(aTHX_ "%s", SvPVX(xpt));			\
	}                                                               \
    } STMT_END
d333 3
d344 3
a346 3
/* 
   The DBM_setFilter & DBM_ckFilter macros are only used by 
   the *DB*_File modules 
a396 1
#  define VTBL_sig		&PL_vtbl_sig
@


1.12
log
@Merge in perl 5.10.1
@
text
@d297 1
a297 1
#  define XS_VERSION_BOOTCHECK \
d308 1
a308 1
		_sv = get_sv(Perl_form(aTHX_ "%s::%s", module,	\
d312 21
a332 9
	    SV *xssv = Perl_newSVpv(aTHX_ XS_VERSION, 0);		\
	    xssv = new_version(xssv);					\
	    if ( !sv_derived_from(_sv, "version") )			\
		_sv = new_version(_sv);				\
	    if ( vcmp(_sv,xssv) )					\
		Perl_croak(aTHX_ "%s object version %"SVf" does not match %s%s%s%s %"SVf,\
		      module, SVfARG(vstringify(xssv)),			\
		      vn ? "$" : "", vn ? module : "", vn ? "::" : "",	\
		      vn ? vn : "bootstrap parameter", SVfARG(vstringify(_sv)));\
d493 6
d522 1
@


1.11
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d4 1
a4 1
 *    2003, 2004, 2005, 2006, 2007 by Larry Wall and others
d272 1
a272 1
#define XST_mPVN(i,v,n)  (ST(i) = sv_2mortal(newSVpvn(v,n)))
d367 1
a367 1
	    SAVESPTR(DEFSV) ;					\
d370 1
a370 1
	    DEFSV = arg ;					\
a417 6
#ifndef PERL_MAD
#  undef PL_madskills
#  undef PL_xmlfp
#  define PL_madskills 0
#  define PL_xmlfp 0
#endif
@


1.10
log
@Ignore HASATTRIBUTE_UNUSED for C++ as our g++ does not grok
the __unused__  attribute.  Also give XS functions C linkage.
Patch taken from perl-current.
@
text
@d3 2
a4 2
 *    Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999,
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006 by Larry Wall and others
d74 8
d86 1
a86 1
#  ifdef lint
d99 13
d113 6
a118 2
#  define XS(name) __declspec(dllexport) void name(pTHX_ CV* cv)
#else
d123 1
a123 1
#      define XS(name) extern "C" void name(pTHX_ CV* cv)
d125 1
a125 1
#      define XS(name) void name(pTHX_ CV* cv)
d130 1
a130 1
#define dAX const I32 ax = MARK - PL_stack_base + 1
d136 1
a136 1
#define dITEMS I32 items = SP - MARK
d138 1
a138 1
#ifdef lint
d159 1
d162 1
d165 1
a165 1
#define XSINTERFACE_FUNC(ret,cv,f)     ((XSINTERFACE_CVT(ret,))(f))
d169 5
d247 18
d279 1
a279 1
	IV tmpXSoff = (off);				\
d294 1
a294 1
#define newXSproto(a,b,c,d)	sv_setpv((SV*)newXS(a,b,c), d)
d300 1
a300 1
	const char *vn = Nullch, *module = SvPV_nolen_const(ST(0));	\
d311 11
a321 5
	if (_sv && (!SvOK(_sv) || strNE(XS_VERSION, SvPV_nolen_const(_sv))))	\
	    Perl_croak(aTHX_ "%s object version %s does not match %s%s%s%s %"SVf,\
		  module, XS_VERSION,					\
		  vn ? "$" : "", vn ? module : "", vn ? "::" : "",	\
		  vn ? vn : "bootstrap parameter", _sv);		\
d327 8
d341 1
a341 1
	{							\
d355 1
a355 1
	}
d358 1
d382 1
a382 2
            SvOKp(arg);                                         \
	}
d418 6
@


1.9
log
@merge in perl 5.8.8
@
text
@d94 1
a94 1
#  ifdef HASATTRIBUTE_UNUSED
d97 5
a101 1
#    define XS(name) void name(pTHX_ CV* cv)
@


1.8
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, by Larry Wall and others
d57 4
d77 12
d94 5
a98 1
#  define XS(name) void name(pTHX_ CV* cv)
d101 5
a105 1
#define dAX I32 ax = MARK - PL_stack_base + 1
d109 8
a116 3
#define dXSARGS				\
	dSP; dMARK;			\
	dAX; dITEMS
d118 1
a118 1
#define dXSTARG SV * targ = ((PL_op->op_private & OPpENTERSUB_HASTARG) \
d245 2
a246 2
	SV *_sv; STRLEN n_a;						\
	char *vn = Nullch, *module = SvPV(ST(0),n_a);			\
d257 1
a257 1
	if (_sv && (!SvOK(_sv) || strNE(XS_VERSION, SvPV(_sv, n_a))))	\
d572 10
@


1.7
log
@merge local changes into perl-5.8.3
@
text
@d169 1
a169 1
=for apidoc AmU||newXSproto
@


1.6
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d196 2
a197 1
	PL_stack_sp = PL_stack_base + ax + ((off) - 1);	\
d216 1
a216 1
	SV *tmpsv; STRLEN n_a;						\
d219 1
a219 1
	    tmpsv = ST(1);						\
d222 1
a222 1
	    tmpsv = get_sv(Perl_form(aTHX_ "%s::%s", module,		\
d224 2
a225 2
	    if (!tmpsv || !SvOK(tmpsv))					\
		tmpsv = get_sv(Perl_form(aTHX_ "%s::%s", module,	\
d228 1
a228 1
	if (tmpsv && (!SvOK(tmpsv) || strNE(XS_VERSION, SvPV(tmpsv, n_a))))	\
d232 1
a232 1
		  vn ? vn : "bootstrap parameter", tmpsv);		\
d270 2
d281 4
@


1.5
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d3 2
a4 1
 *    Copyright (c) 1997-2002, Larry Wall
d107 1
a107 1
		CvXSUBANY(cv).any_dptr = (void (*) (pTHX_ void*))(f)
d146 3
d186 1
d201 1
d237 43
d391 18
a408 18
#    define stdin		PerlSIO_stdin()
#    define stdout		PerlSIO_stdout()
#    define stderr		PerlSIO_stderr()
#    define fopen		PerlIO_open
#    define fclose		PerlIO_close
#    define feof		PerlIO_eof
#    define ferror		PerlIO_error
#    define fclearerr		PerlIO_clearerr
#    define getc		PerlIO_getc
#    define fputc(c, f)		PerlIO_putc(f,c)
#    define fputs(s, f)		PerlIO_puts(f,s)
#    define fflush		PerlIO_flush
#    define ungetc(c, f)	PerlIO_ungetc((f),(c))
#    define fileno		PerlIO_fileno
#    define fdopen		PerlIO_fdopen
#    define freopen		PerlIO_reopen
#    define fread(b,s,c,f)	PerlIO_read((f),(b),(s*c))
#    define fwrite(b,s,c,f)	PerlIO_write((f),(b),(s*c))
d412 8
a419 8
#    define stdoutf		PerlIO_stdoutf
#    define vfprintf		PerlIO_vprintf
#    define ftell		PerlIO_tell
#    define fseek		PerlIO_seek
#    define fgetpos		PerlIO_getpos
#    define fsetpos		PerlIO_setpos
#    define frewind		PerlIO_rewind
#    define tmpfile		PerlIO_tmpfile
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d1 9
d16 2
d32 5
d52 8
d61 3
a63 3
Sets up stack and mark pointers for an XSUB, calling dSP and dMARK.  This
is usually handled automatically by C<xsubpp>.  Declares the C<items>
variable to indicate the number of items on the stack.
d75 1
a75 1
#  define XS(name) __declspec(dllexport) void name(pTHXo_ CV* cv)
d77 1
a77 1
#  define XS(name) void name(pTHXo_ CV* cv)
d80 4
d86 1
a86 2
	I32 ax = mark - PL_stack_base + 1;	\
	I32 items = sp - mark
d104 1
a104 1
#define XSINTERFACE_FUNC(ret,cv,f)	((XSINTERFACE_CVT(ret,cv))(f))
d106 1
a106 1
		CvXSUBANY(cv).any_dptr = (void (*) (pTHXo_ void*))(f)
d112 2
d146 1
a146 1
Return an double from an XSUB immediately.  Uses C<XST_mNV>.
d163 2
a264 1
#include "objXSUB.h"
d273 1
a273 1
#if (defined(PERL_CAPI) || defined(PERL_IMPLICIT_SYS)) && !defined(PERL_CORE)
d275 9
d299 31
d342 3
a344 3
#    define stdin		PerlIO_stdin()
#    define stdout		PerlIO_stdout()
#    define stderr		PerlIO_stderr()
d360 3
a362 3
#    define setbuf		PerlIO_setbuf
#    define setvbuf		PerlIO_setvbuf
#    define setlinebuf		PerlIO_setlinebuf
d424 1
d468 15
d484 1
a484 1
#endif  /* PERL_CAPI */
@


1.3
log
@perl5.005_03 (stock)
@
text
@d1 47
d50 2
a51 3
#ifdef CAN_PROTOTYPE
#ifdef PERL_OBJECT
#define XS(name) void name(CV* cv, CPerlObj* pPerl)
d53 1
a53 4
#define XS(name) void name(CV* cv)
#endif
#else
#define XS(name) void name(cv) CV* cv;
d61 6
d77 1
a77 1
#define XSINTERFACE_FUNC(ret,cv,f)	((XSINTERFACE_CVT(ret,))(f))
d79 1
a79 7
		CvXSUBANY(cv).any_dptr = (void (*) _((void*)))(f)

#define XSRETURN(off)					\
    STMT_START {					\
	PL_stack_sp = PL_stack_base + ax + ((off) - 1);	\
	return;						\
    } STMT_END
d83 67
d153 1
d157 7
a163 1
 
d167 1
d176 1
a176 1
# define XS_VERSION_BOOTCHECK \
d184 2
a185 2
	    tmpsv = perl_get_sv(form("%s::%s", module,			\
				  vn = "XS_VERSION"), FALSE);		\
d187 2
a188 2
		tmpsv = perl_get_sv(form("%s::%s", module,		\
				      vn = "VERSION"), FALSE);		\
d191 1
a191 1
	    croak("%s object version %s does not match %s%s%s%s %_",	\
d197 1
a197 1
# define XS_VERSION_BOOTCHECK
d200 26
a225 55
#ifdef PERL_CAPI
#  define VTBL_sv		get_vtbl(want_vtbl_sv)
#  define VTBL_env		get_vtbl(want_vtbl_env)
#  define VTBL_envelem		get_vtbl(want_vtbl_envelem)
#  define VTBL_sig		get_vtbl(want_vtbl_sig)
#  define VTBL_sigelem		get_vtbl(want_vtbl_sigelem)
#  define VTBL_pack		get_vtbl(want_vtbl_pack)
#  define VTBL_packelem		get_vtbl(want_vtbl_packelem)
#  define VTBL_dbline		get_vtbl(want_vtbl_dbline)
#  define VTBL_isa		get_vtbl(want_vtbl_isa)
#  define VTBL_isaelem		get_vtbl(want_vtbl_isaelem)
#  define VTBL_arylen		get_vtbl(want_vtbl_arylen)
#  define VTBL_glob		get_vtbl(want_vtbl_glob)
#  define VTBL_mglob		get_vtbl(want_vtbl_mglob)
#  define VTBL_nkeys		get_vtbl(want_vtbl_nkeys)
#  define VTBL_taint		get_vtbl(want_vtbl_taint)
#  define VTBL_substr		get_vtbl(want_vtbl_substr)
#  define VTBL_vec		get_vtbl(want_vtbl_vec)
#  define VTBL_pos		get_vtbl(want_vtbl_pos)
#  define VTBL_bm		get_vtbl(want_vtbl_bm)
#  define VTBL_fm		get_vtbl(want_vtbl_fm)
#  define VTBL_uvar		get_vtbl(want_vtbl_uvar)
#  define VTBL_defelem		get_vtbl(want_vtbl_defelem)
#  define VTBL_regexp		get_vtbl(want_vtbl_regexp)
#  ifdef USE_LOCALE_COLLATE
#    define VTBL_collxfrm	get_vtbl(want_vtbl_collxfrm)
#  endif
#  ifdef OVERLOAD
#    define VTBL_amagic		get_vtbl(want_vtbl_amagic)
#    define VTBL_amagicelem	get_vtbl(want_vtbl_amagicelem)
#  endif
#else
#  define VTBL_sv		&vtbl_sv
#  define VTBL_env		&vtbl_env
#  define VTBL_envelem		&vtbl_envelem
#  define VTBL_sig		&vtbl_sig
#  define VTBL_sigelem		&vtbl_sigelem
#  define VTBL_pack		&vtbl_pack
#  define VTBL_packelem		&vtbl_packelem
#  define VTBL_dbline		&vtbl_dbline
#  define VTBL_isa		&vtbl_isa
#  define VTBL_isaelem		&vtbl_isaelem
#  define VTBL_arylen		&vtbl_arylen
#  define VTBL_glob		&vtbl_glob
#  define VTBL_mglob		&vtbl_mglob
#  define VTBL_nkeys		&vtbl_nkeys
#  define VTBL_taint		&vtbl_taint
#  define VTBL_substr		&vtbl_substr
#  define VTBL_vec		&vtbl_vec
#  define VTBL_pos		&vtbl_pos
#  define VTBL_bm		&vtbl_bm
#  define VTBL_fm		&vtbl_fm
#  define VTBL_uvar		&vtbl_uvar
#  define VTBL_defelem		&vtbl_defelem
#  define VTBL_regexp		&vtbl_regexp
d227 1
a227 5
#    define VTBL_collxfrm	&vtbl_collxfrm
#  endif
#  ifdef OVERLOAD
#    define VTBL_amagic		&vtbl_amagic
#    define VTBL_amagicelem	&vtbl_amagicelem
d229 2
d233 1
a233 1
#ifdef PERL_OBJECT
d235 6
a240 8
#ifndef NO_XSLOCKS
#ifdef WIN32
#include "XSlock.h"
#endif  /* WIN32 */
#endif  /* NO_XSLOCKS */
#else
#ifdef PERL_CAPI
#include "perlCAPI.h"
d242 159
a400 1
#endif	/* PERL_OBJECT */
@


1.2
log
@perl 5.004_04
@
text
@d1 1
a1 1
#define ST(off) stack_base[ax + (off)]
d4 3
d8 1
d15 1
a15 1
	I32 ax = mark - stack_base + 1;	\
d22 15
a36 1
#define XSRETURN(off) stack_sp = stack_base + ax + ((off) - 1); return
d43 3
a45 3
#define XST_mNO(i)    (ST(i) = &sv_no   )
#define XST_mYES(i)   (ST(i) = &sv_yes  )
#define XST_mUNDEF(i) (ST(i) = &sv_undef)
d60 2
a61 1
	char *vn = "", *module = SvPV(ST(0),na);			\
d63 1
a63 1
	    Sv = ST(1);							\
d66 1
a66 1
	    Sv = perl_get_sv(form("%s::%s", module,			\
d68 2
a69 2
	    if (!Sv || !SvOK(Sv))					\
		Sv = perl_get_sv(form("%s::%s", module,			\
d72 5
a76 3
	if (Sv && (!SvOK(Sv) || strNE(XS_VERSION, SvPV(Sv, na))))	\
	    croak("%s object version %s does not match $%s::%s %_",	\
		  module, XS_VERSION, module, vn, Sv);			\
d81 77
@


1.1
log
@Initial revision
@
text
@d41 15
a55 11
    STMT_START {                                                                      \
        char vn[255], *module = SvPV(ST(0),na);                               \
        if (items >= 2)         /* version supplied as bootstrap arg */       \
            Sv=ST(1);                                                         \
        else {                  /* read version from module::VERSION */       \
            sprintf(vn,"%s::VERSION", module);                                \
            Sv = perl_get_sv(vn, FALSE);   /* XXX GV_ADDWARN */               \
        }                                                                     \
        if (Sv && (!SvOK(Sv) || strNE(XS_VERSION, SvPV(Sv,na))) )             \
            croak("%s object version %s does not match %s.pm $VERSION %s",    \
              module,XS_VERSION, module,(Sv && SvOK(Sv))?SvPV(Sv,na):"(undef)");\
a59 1

@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d1 1
a1 1
#define ST(off) PL_stack_base[ax + (off)]
a3 3
#ifdef PERL_OBJECT
#define XS(name) void name(CV* cv, CPerlObj* pPerl)
#else
a4 1
#endif
d11 1
a11 1
	I32 ax = mark - PL_stack_base + 1;	\
d18 1
a18 15
#ifdef __cplusplus
#  define XSINTERFACE_CVT(ret,name) ret (*name)(...)
#else
#  define XSINTERFACE_CVT(ret,name) ret (*name)()
#endif
#define dXSFUNCTION(ret)		XSINTERFACE_CVT(ret,XSFUNCTION)
#define XSINTERFACE_FUNC(ret,cv,f)	((XSINTERFACE_CVT(ret,))(f))
#define XSINTERFACE_FUNC_SET(cv,f)	\
		CvXSUBANY(cv).any_dptr = (void (*) _((void*)))(f)

#define XSRETURN(off)					\
    STMT_START {					\
	PL_stack_sp = PL_stack_base + ax + ((off) - 1);	\
	return;						\
    } STMT_END
d25 3
a27 3
#define XST_mNO(i)    (ST(i) = &PL_sv_no   )
#define XST_mYES(i)   (ST(i) = &PL_sv_yes  )
#define XST_mUNDEF(i) (ST(i) = &PL_sv_undef)
d41 11
a51 18
    STMT_START {							\
	SV *tmpsv; STRLEN n_a;						\
	char *vn = Nullch, *module = SvPV(ST(0),n_a);			\
	if (items >= 2)	 /* version supplied as bootstrap arg */	\
	    tmpsv = ST(1);						\
	else {								\
	    /* XXX GV_ADDWARN */					\
	    tmpsv = perl_get_sv(form("%s::%s", module,			\
				  vn = "XS_VERSION"), FALSE);		\
	    if (!tmpsv || !SvOK(tmpsv))					\
		tmpsv = perl_get_sv(form("%s::%s", module,		\
				      vn = "VERSION"), FALSE);		\
	}								\
	if (tmpsv && (!SvOK(tmpsv) || strNE(XS_VERSION, SvPV(tmpsv, n_a))))	\
	    croak("%s object version %s does not match %s%s%s%s %_",	\
		  module, XS_VERSION,					\
		  vn ? "$" : "", vn ? module : "", vn ? "::" : "",	\
		  vn ? vn : "bootstrap parameter", tmpsv);		\
a56 76
#ifdef PERL_CAPI
#  define VTBL_sv		get_vtbl(want_vtbl_sv)
#  define VTBL_env		get_vtbl(want_vtbl_env)
#  define VTBL_envelem		get_vtbl(want_vtbl_envelem)
#  define VTBL_sig		get_vtbl(want_vtbl_sig)
#  define VTBL_sigelem		get_vtbl(want_vtbl_sigelem)
#  define VTBL_pack		get_vtbl(want_vtbl_pack)
#  define VTBL_packelem		get_vtbl(want_vtbl_packelem)
#  define VTBL_dbline		get_vtbl(want_vtbl_dbline)
#  define VTBL_isa		get_vtbl(want_vtbl_isa)
#  define VTBL_isaelem		get_vtbl(want_vtbl_isaelem)
#  define VTBL_arylen		get_vtbl(want_vtbl_arylen)
#  define VTBL_glob		get_vtbl(want_vtbl_glob)
#  define VTBL_mglob		get_vtbl(want_vtbl_mglob)
#  define VTBL_nkeys		get_vtbl(want_vtbl_nkeys)
#  define VTBL_taint		get_vtbl(want_vtbl_taint)
#  define VTBL_substr		get_vtbl(want_vtbl_substr)
#  define VTBL_vec		get_vtbl(want_vtbl_vec)
#  define VTBL_pos		get_vtbl(want_vtbl_pos)
#  define VTBL_bm		get_vtbl(want_vtbl_bm)
#  define VTBL_fm		get_vtbl(want_vtbl_fm)
#  define VTBL_uvar		get_vtbl(want_vtbl_uvar)
#  define VTBL_defelem		get_vtbl(want_vtbl_defelem)
#  define VTBL_regexp		get_vtbl(want_vtbl_regexp)
#  ifdef USE_LOCALE_COLLATE
#    define VTBL_collxfrm	get_vtbl(want_vtbl_collxfrm)
#  endif
#  ifdef OVERLOAD
#    define VTBL_amagic		get_vtbl(want_vtbl_amagic)
#    define VTBL_amagicelem	get_vtbl(want_vtbl_amagicelem)
#  endif
#else
#  define VTBL_sv		&vtbl_sv
#  define VTBL_env		&vtbl_env
#  define VTBL_envelem		&vtbl_envelem
#  define VTBL_sig		&vtbl_sig
#  define VTBL_sigelem		&vtbl_sigelem
#  define VTBL_pack		&vtbl_pack
#  define VTBL_packelem		&vtbl_packelem
#  define VTBL_dbline		&vtbl_dbline
#  define VTBL_isa		&vtbl_isa
#  define VTBL_isaelem		&vtbl_isaelem
#  define VTBL_arylen		&vtbl_arylen
#  define VTBL_glob		&vtbl_glob
#  define VTBL_mglob		&vtbl_mglob
#  define VTBL_nkeys		&vtbl_nkeys
#  define VTBL_taint		&vtbl_taint
#  define VTBL_substr		&vtbl_substr
#  define VTBL_vec		&vtbl_vec
#  define VTBL_pos		&vtbl_pos
#  define VTBL_bm		&vtbl_bm
#  define VTBL_fm		&vtbl_fm
#  define VTBL_uvar		&vtbl_uvar
#  define VTBL_defelem		&vtbl_defelem
#  define VTBL_regexp		&vtbl_regexp
#  ifdef USE_LOCALE_COLLATE
#    define VTBL_collxfrm	&vtbl_collxfrm
#  endif
#  ifdef OVERLOAD
#    define VTBL_amagic		&vtbl_amagic
#    define VTBL_amagicelem	&vtbl_amagicelem
#  endif
#endif

#ifdef PERL_OBJECT
#include "objXSUB.h"
#ifndef NO_XSLOCKS
#ifdef WIN32
#include "XSlock.h"
#endif  /* WIN32 */
#endif  /* NO_XSLOCKS */
#else
#ifdef PERL_CAPI
#include "perlCAPI.h"
#endif
#endif	/* PERL_OBJECT */
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@a0 47
#ifndef _INC_PERL_XSUB_H
#define _INC_PERL_XSUB_H 1

/* first, some documentation for xsubpp-generated items */

/*
=for apidoc Amn|char*|CLASS
Variable which is setup by C<xsubpp> to indicate the 
class name for a C++ XS constructor.  This is always a C<char*>.  See C<THIS>.

=for apidoc Amn|(whatever)|RETVAL
Variable which is setup by C<xsubpp> to hold the return value for an 
XSUB. This is always the proper type for the XSUB. See 
L<perlxs/"The RETVAL Variable">.

=for apidoc Amn|(whatever)|THIS
Variable which is setup by C<xsubpp> to designate the object in a C++ 
XSUB.  This is always the proper type for the C++ object.  See C<CLASS> and 
L<perlxs/"Using XS With C++">.

=for apidoc Amn|I32|items
Variable which is setup by C<xsubpp> to indicate the number of 
items on the stack.  See L<perlxs/"Variable-length Parameter Lists">.

=for apidoc Amn|I32|ix
Variable which is setup by C<xsubpp> to indicate which of an 
XSUB's aliases was used to invoke it.  See L<perlxs/"The ALIAS: Keyword">.

=for apidoc Am|SV*|ST|int ix
Used to access elements on the XSUB's stack.

=for apidoc AmU||XS
Macro to declare an XSUB and its C parameter list.  This is handled by
C<xsubpp>.

=for apidoc Ams||dXSARGS
Sets up stack and mark pointers for an XSUB, calling dSP and dMARK.  This
is usually handled automatically by C<xsubpp>.  Declares the C<items>
variable to indicate the number of items on the stack.

=for apidoc Ams||dXSI32
Sets up the C<ix> variable for an XSUB which has aliases.  This is usually
handled automatically by C<xsubpp>.

=cut
*/

d3 3
a5 2
#if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#  define XS(name) __declspec(dllexport) void name(pTHXo_ CV* cv)
d7 4
a10 1
#  define XS(name) void name(pTHXo_ CV* cv)
a17 6
#define dXSTARG SV * targ = ((PL_op->op_private & OPpENTERSUB_HASTARG) \
			     ? PAD_SV(PL_op->op_targ) : sv_newmortal())

/* Should be used before final PUSHi etc. if not in PPCODE section. */
#define XSprePUSH (sp = PL_stack_base + ax - 1)

d28 1
a28 1
#define XSINTERFACE_FUNC(ret,cv,f)	((XSINTERFACE_CVT(ret,cv))(f))
d30 7
a36 1
		CvXSUBANY(cv).any_dptr = (void (*) (pTHXo_ void*))(f)
a39 67

/*
=for apidoc Am|void|XST_mIV|int pos|IV iv
Place an integer into the specified position C<pos> on the stack.  The
value is stored in a new mortal SV.

=for apidoc Am|void|XST_mNV|int pos|NV nv
Place a double into the specified position C<pos> on the stack.  The value
is stored in a new mortal SV.

=for apidoc Am|void|XST_mPV|int pos|char* str
Place a copy of a string into the specified position C<pos> on the stack. 
The value is stored in a new mortal SV.

=for apidoc Am|void|XST_mNO|int pos
Place C<&PL_sv_no> into the specified position C<pos> on the
stack.

=for apidoc Am|void|XST_mYES|int pos
Place C<&PL_sv_yes> into the specified position C<pos> on the
stack.

=for apidoc Am|void|XST_mUNDEF|int pos
Place C<&PL_sv_undef> into the specified position C<pos> on the
stack.

=for apidoc Am|void|XSRETURN|int nitems
Return from XSUB, indicating number of items on the stack.  This is usually
handled by C<xsubpp>.

=for apidoc Am|void|XSRETURN_IV|IV iv
Return an integer from an XSUB immediately.  Uses C<XST_mIV>.

=for apidoc Am|void|XSRETURN_NV|NV nv
Return an double from an XSUB immediately.  Uses C<XST_mNV>.

=for apidoc Am|void|XSRETURN_PV|char* str
Return a copy of a string from an XSUB immediately.  Uses C<XST_mPV>.

=for apidoc Ams||XSRETURN_NO
Return C<&PL_sv_no> from an XSUB immediately.  Uses C<XST_mNO>.

=for apidoc Ams||XSRETURN_YES
Return C<&PL_sv_yes> from an XSUB immediately.  Uses C<XST_mYES>.

=for apidoc Ams||XSRETURN_UNDEF
Return C<&PL_sv_undef> from an XSUB immediately.  Uses C<XST_mUNDEF>.

=for apidoc Ams||XSRETURN_EMPTY
Return an empty list from an XSUB immediately.

=for apidoc AmU||newXSproto
Used by C<xsubpp> to hook up XSUBs as Perl subs.  Adds Perl prototypes to
the subs.

=for apidoc AmU||XS_VERSION
The version identifier for an XS module.  This is usually
handled automatically by C<ExtUtils::MakeMaker>.  See C<XS_VERSION_BOOTCHECK>.

=for apidoc Ams||XS_VERSION_BOOTCHECK
Macro to verify that a PM module's $VERSION variable matches the XS
module's C<XS_VERSION> variable.  This is usually handled automatically by
C<xsubpp>.  See L<perlxs/"The VERSIONCHECK: Keyword">.

=cut
*/

a42 1
#define XST_mPVN(i,v,n)  (ST(i) = sv_2mortal(newSVpvn(v,n)))
d46 1
a46 7

#define XSRETURN(off)					\
    STMT_START {					\
	PL_stack_sp = PL_stack_base + ax + ((off) - 1);	\
	return;						\
    } STMT_END

a49 1
#define XSRETURN_PVN(v,n) STMT_START { XST_mPVN(0,v,n);  XSRETURN(1); } STMT_END
d58 1
a58 1
#  define XS_VERSION_BOOTCHECK \
d66 2
a67 2
	    tmpsv = get_sv(Perl_form(aTHX_ "%s::%s", module,		\
				vn = "XS_VERSION"), FALSE);		\
d69 2
a70 2
		tmpsv = get_sv(Perl_form(aTHX_ "%s::%s", module,	\
				    vn = "VERSION"), FALSE);		\
d73 1
a73 1
	    Perl_croak(aTHX_ "%s object version %s does not match %s%s%s%s %"SVf,\
d79 1
a79 1
#  define XS_VERSION_BOOTCHECK
d82 55
a136 26
#if 1		/* for compatibility */
#  define VTBL_sv		&PL_vtbl_sv
#  define VTBL_env		&PL_vtbl_env
#  define VTBL_envelem		&PL_vtbl_envelem
#  define VTBL_sig		&PL_vtbl_sig
#  define VTBL_sigelem		&PL_vtbl_sigelem
#  define VTBL_pack		&PL_vtbl_pack
#  define VTBL_packelem		&PL_vtbl_packelem
#  define VTBL_dbline		&PL_vtbl_dbline
#  define VTBL_isa		&PL_vtbl_isa
#  define VTBL_isaelem		&PL_vtbl_isaelem
#  define VTBL_arylen		&PL_vtbl_arylen
#  define VTBL_glob		&PL_vtbl_glob
#  define VTBL_mglob		&PL_vtbl_mglob
#  define VTBL_nkeys		&PL_vtbl_nkeys
#  define VTBL_taint		&PL_vtbl_taint
#  define VTBL_substr		&PL_vtbl_substr
#  define VTBL_vec		&PL_vtbl_vec
#  define VTBL_pos		&PL_vtbl_pos
#  define VTBL_bm		&PL_vtbl_bm
#  define VTBL_fm		&PL_vtbl_fm
#  define VTBL_uvar		&PL_vtbl_uvar
#  define VTBL_defelem		&PL_vtbl_defelem
#  define VTBL_regexp		&PL_vtbl_regexp
#  define VTBL_regdata		&PL_vtbl_regdata
#  define VTBL_regdatum		&PL_vtbl_regdatum
d138 5
a142 1
#    define VTBL_collxfrm	&PL_vtbl_collxfrm
a143 2
#  define VTBL_amagic		&PL_vtbl_amagic
#  define VTBL_amagicelem	&PL_vtbl_amagicelem
d146 1
a146 1
#include "perlapi.h"
d148 8
a155 6

#if defined(PERL_IMPLICIT_CONTEXT) && !defined(PERL_NO_GET_CONTEXT) && !defined(PERL_CORE)
#  undef aTHX
#  undef aTHX_
#  define aTHX		PERL_GET_THX
#  define aTHX_		aTHX,
d157 1
a157 159

#if (defined(PERL_CAPI) || defined(PERL_IMPLICIT_SYS)) && !defined(PERL_CORE)
#  ifndef NO_XSLOCKS
#    undef closedir
#    undef opendir
#    undef stdin
#    undef stdout
#    undef stderr
#    undef feof
#    undef ferror
#    undef fgetpos
#    undef ioctl
#    undef getlogin
#    undef setjmp
#    undef getc
#    undef ungetc
#    undef fileno

#    define mkdir		PerlDir_mkdir
#    define chdir		PerlDir_chdir
#    define rmdir		PerlDir_rmdir
#    define closedir		PerlDir_close
#    define opendir		PerlDir_open
#    define readdir		PerlDir_read
#    define rewinddir		PerlDir_rewind
#    define seekdir		PerlDir_seek
#    define telldir		PerlDir_tell
#    define putenv		PerlEnv_putenv
#    define getenv		PerlEnv_getenv
#    define uname		PerlEnv_uname
#    define stdin		PerlIO_stdin()
#    define stdout		PerlIO_stdout()
#    define stderr		PerlIO_stderr()
#    define fopen		PerlIO_open
#    define fclose		PerlIO_close
#    define feof		PerlIO_eof
#    define ferror		PerlIO_error
#    define fclearerr		PerlIO_clearerr
#    define getc		PerlIO_getc
#    define fputc(c, f)		PerlIO_putc(f,c)
#    define fputs(s, f)		PerlIO_puts(f,s)
#    define fflush		PerlIO_flush
#    define ungetc(c, f)	PerlIO_ungetc((f),(c))
#    define fileno		PerlIO_fileno
#    define fdopen		PerlIO_fdopen
#    define freopen		PerlIO_reopen
#    define fread(b,s,c,f)	PerlIO_read((f),(b),(s*c))
#    define fwrite(b,s,c,f)	PerlIO_write((f),(b),(s*c))
#    define setbuf		PerlIO_setbuf
#    define setvbuf		PerlIO_setvbuf
#    define setlinebuf		PerlIO_setlinebuf
#    define stdoutf		PerlIO_stdoutf
#    define vfprintf		PerlIO_vprintf
#    define ftell		PerlIO_tell
#    define fseek		PerlIO_seek
#    define fgetpos		PerlIO_getpos
#    define fsetpos		PerlIO_setpos
#    define frewind		PerlIO_rewind
#    define tmpfile		PerlIO_tmpfile
#    define access		PerlLIO_access
#    define chmod		PerlLIO_chmod
#    define chsize		PerlLIO_chsize
#    define close		PerlLIO_close
#    define dup			PerlLIO_dup
#    define dup2		PerlLIO_dup2
#    define flock		PerlLIO_flock
#    define fstat		PerlLIO_fstat
#    define ioctl		PerlLIO_ioctl
#    define isatty		PerlLIO_isatty
#    define link                PerlLIO_link
#    define lseek		PerlLIO_lseek
#    define lstat		PerlLIO_lstat
#    define mktemp		PerlLIO_mktemp
#    define open		PerlLIO_open
#    define read		PerlLIO_read
#    define rename		PerlLIO_rename
#    define setmode		PerlLIO_setmode
#    define stat(buf,sb)	PerlLIO_stat(buf,sb)
#    define tmpnam		PerlLIO_tmpnam
#    define umask		PerlLIO_umask
#    define unlink		PerlLIO_unlink
#    define utime		PerlLIO_utime
#    define write		PerlLIO_write
#    define malloc		PerlMem_malloc
#    define realloc		PerlMem_realloc
#    define free		PerlMem_free
#    define abort		PerlProc_abort
#    define exit		PerlProc_exit
#    define _exit		PerlProc__exit
#    define execl		PerlProc_execl
#    define execv		PerlProc_execv
#    define execvp		PerlProc_execvp
#    define getuid		PerlProc_getuid
#    define geteuid		PerlProc_geteuid
#    define getgid		PerlProc_getgid
#    define getegid		PerlProc_getegid
#    define getlogin		PerlProc_getlogin
#    define kill		PerlProc_kill
#    define killpg		PerlProc_killpg
#    define pause		PerlProc_pause
#    define popen		PerlProc_popen
#    define pclose		PerlProc_pclose
#    define pipe		PerlProc_pipe
#    define setuid		PerlProc_setuid
#    define setgid		PerlProc_setgid
#    define sleep		PerlProc_sleep
#    define times		PerlProc_times
#    define wait		PerlProc_wait
#    define setjmp		PerlProc_setjmp
#    define longjmp		PerlProc_longjmp
#    define signal		PerlProc_signal
#    define getpid		PerlProc_getpid
#    define htonl		PerlSock_htonl
#    define htons		PerlSock_htons
#    define ntohl		PerlSock_ntohl
#    define ntohs		PerlSock_ntohs
#    define accept		PerlSock_accept
#    define bind		PerlSock_bind
#    define connect		PerlSock_connect
#    define endhostent		PerlSock_endhostent
#    define endnetent		PerlSock_endnetent
#    define endprotoent		PerlSock_endprotoent
#    define endservent		PerlSock_endservent
#    define gethostbyaddr	PerlSock_gethostbyaddr
#    define gethostbyname	PerlSock_gethostbyname
#    define gethostent		PerlSock_gethostent
#    define gethostname		PerlSock_gethostname
#    define getnetbyaddr	PerlSock_getnetbyaddr
#    define getnetbyname	PerlSock_getnetbyname
#    define getnetent		PerlSock_getnetent
#    define getpeername		PerlSock_getpeername
#    define getprotobyname	PerlSock_getprotobyname
#    define getprotobynumber	PerlSock_getprotobynumber
#    define getprotoent		PerlSock_getprotoent
#    define getservbyname	PerlSock_getservbyname
#    define getservbyport	PerlSock_getservbyport
#    define getservent		PerlSock_getservent
#    define getsockname		PerlSock_getsockname
#    define getsockopt		PerlSock_getsockopt
#    define inet_addr		PerlSock_inet_addr
#    define inet_ntoa		PerlSock_inet_ntoa
#    define listen		PerlSock_listen
#    define recv		PerlSock_recv
#    define recvfrom		PerlSock_recvfrom
#    define select		PerlSock_select
#    define send		PerlSock_send
#    define sendto		PerlSock_sendto
#    define sethostent		PerlSock_sethostent
#    define setnetent		PerlSock_setnetent
#    define setprotoent		PerlSock_setprotoent
#    define setservent		PerlSock_setservent
#    define setsockopt		PerlSock_setsockopt
#    define shutdown		PerlSock_shutdown
#    define socket		PerlSock_socket
#    define socketpair		PerlSock_socketpair
#  endif  /* NO_XSLOCKS */
#endif  /* PERL_CAPI */

#endif /* _INC_PERL_XSUB_H */		/* include guard */
@


1.1.1.4
log
@stock perl 5.8.0 from CPAN
@
text
@a0 9
/*    XSUB.h
 *
 *    Copyright (c) 1997-2002, Larry Wall
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

a6 2
=head1 Variables created by C<xsubpp> and C<xsubpp> internal functions

a20 5
=for apidoc Amn|I32|ax
Variable which is setup by C<xsubpp> to indicate the stack base offset,
used by the C<ST>, C<XSprePUSH> and C<XSRETURN> macros.  The C<dMARK> macro
must be called prior to setup the C<MARK> variable.

a35 8
=for apidoc Ams||dAX
Sets up the C<ax> variable.
This is usually handled automatically by C<xsubpp> by calling C<dXSARGS>.

=for apidoc Ams||dITEMS
Sets up the C<items> variable.
This is usually handled automatically by C<xsubpp> by calling C<dXSARGS>.

d37 3
a39 3
Sets up stack and mark pointers for an XSUB, calling dSP and dMARK.
Sets up the C<ax> and C<items> variables by calling C<dAX> and C<dITEMS>.
This is usually handled automatically by C<xsubpp>.
d51 1
a51 1
#  define XS(name) __declspec(dllexport) void name(pTHX_ CV* cv)
d53 1
a53 1
#  define XS(name) void name(pTHX_ CV* cv)
a55 4
#define dAX I32 ax = MARK - PL_stack_base + 1

#define dITEMS I32 items = SP - MARK

d58 2
a59 1
	dAX; dITEMS
d77 1
a77 1
#define XSINTERFACE_FUNC(ret,cv,f)     ((XSINTERFACE_CVT(ret,))(f))
d79 1
a79 1
		CvXSUBANY(cv).any_dptr = (void (*) (pTHX_ void*))(f)
a84 2
=head1 Stack Manipulation Macros

d117 1
a117 1
Return a double from an XSUB immediately.  Uses C<XST_mNV>.
a133 2
=head1 Variables created by C<xsubpp> and C<xsubpp> internal functions

d234 1
d243 1
a243 1
#if defined(PERL_IMPLICIT_SYS) && !defined(PERL_CORE)
a244 9
# if defined (NETWARE) && defined (USE_STDIO)
#    define times		PerlProc_times
#    define setuid		PerlProc_setuid
#    define setgid		PerlProc_setgid
#    define getpid		PerlProc_getpid
#    define pause		PerlProc_pause
#    define exit		PerlProc_exit
#    define _exit		PerlProc__exit
# else
a259 31
/* Following symbols were giving redefinition errors while building extensions - sgp 17th Oct 2000 */
#ifdef NETWARE
#	undef readdir
#	undef fstat
#	undef stat
#	undef longjmp
#	undef endhostent
#	undef endnetent
#	undef endprotoent
#	undef endservent
#	undef gethostbyaddr
#	undef gethostbyname
#	undef gethostent
#	undef getnetbyaddr
#	undef getnetbyname
#	undef getnetent
#	undef getprotobyname
#	undef getprotobynumber
#	undef getprotoent
#	undef getservbyname
#	undef getservbyport
#	undef getservent
#	undef inet_ntoa
#	undef sethostent
#	undef setnetent
#	undef setprotoent
#	undef setservent
#endif	/* NETWARE */

#    undef  socketpair

d272 3
a274 3
#    define stdin		PerlSIO_stdin()
#    define stdout		PerlSIO_stdout()
#    define stderr		PerlSIO_stderr()
d290 3
a292 3
#    define setbuf		PerlSIO_setbuf
#    define setvbuf		PerlSIO_setvbuf
#    define setlinebuf		PerlSIO_setlinebuf
a353 1
#    define gettimeofday	PerlProc_gettimeofday
a396 15
#	endif	/* NETWARE && USE_STDIO */

#    ifdef USE_SOCKETS_AS_HANDLES
#      undef fd_set
#      undef FD_SET
#      undef FD_CLR
#      undef FD_ISSET
#      undef FD_ZERO
#      define fd_set		Perl_fd_set
#      define FD_SET(n,p)	PERL_FD_SET(n,p)
#      define FD_CLR(n,p)	PERL_FD_CLR(n,p)
#      define FD_ISSET(n,p)	PERL_FD_ISSET(n,p)
#      define FD_ZERO(p)	PERL_FD_ZERO(p)
#    endif	/* USE_SOCKETS_AS_HANDLES */

d398 1
a398 1
#endif  /* PERL_IMPLICIT_SYS && !PERL_CORE */
@


1.1.1.5
log
@perl 5.8.2 from CPAN
@
text
@d3 1
a3 2
 *    Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999,
 *    2000, 2001, 2002, 2003, by Larry Wall and others
d106 1
a106 1
		CvXSUBANY(cv).any_dxptr = (void (*) (pTHX_ void*))(f)
a144 3
=for apidoc Am|void|XSRETURN_UV|IV uv
Return an integer from an XSUB immediately.  Uses C<XST_mUV>.

a181 1
#define XST_mUV(i,v)  (ST(i) = sv_2mortal(newSVuv(v))  )
a195 1
#define XSRETURN_UV(v) STMT_START { XST_mUV(0,v);  XSRETURN(1); } STMT_END
a230 43
/* 
   The DBM_setFilter & DBM_ckFilter macros are only used by 
   the *DB*_File modules 
*/

#define DBM_setFilter(db_type,code)				\
	{							\
	    if (db_type)					\
	        RETVAL = sv_mortalcopy(db_type) ;		\
	    ST(0) = RETVAL ;					\
	    if (db_type && (code == &PL_sv_undef)) {		\
                SvREFCNT_dec(db_type) ;				\
	        db_type = NULL ;				\
	    }							\
	    else if (code) {					\
	        if (db_type)					\
	            sv_setsv(db_type, code) ;			\
	        else						\
	            db_type = newSVsv(code) ;			\
	    }	    						\
	}

#define DBM_ckFilter(arg,type,name)				\
	if (db->type) {						\
	    if (db->filtering) {				\
	        croak("recursion detected in %s", name) ;	\
	    }                     				\
	    ENTER ;						\
	    SAVETMPS ;						\
	    SAVEINT(db->filtering) ;				\
	    db->filtering = TRUE ;				\
	    SAVESPTR(DEFSV) ;					\
	    DEFSV = arg ;					\
	    SvTEMP_off(arg) ;					\
	    PUSHMARK(SP) ;					\
	    PUTBACK ;						\
	    (void) perl_call_sv(db->type, G_DISCARD); 		\
	    SPAGAIN ;						\
	    PUTBACK ;						\
	    FREETMPS ;						\
	    LEAVE ;						\
	}

d342 18
a359 18
#    define stdin		PerlSIO_stdin
#    define stdout		PerlSIO_stdout
#    define stderr		PerlSIO_stderr
#    define fopen		PerlSIO_fopen
#    define fclose		PerlSIO_fclose
#    define feof		PerlSIO_feof
#    define ferror		PerlSIO_ferror
#    define clearerr		PerlSIO_clearerr
#    define getc		PerlSIO_getc
#    define fputc		PerlSIO_fputc
#    define fputs		PerlSIO_fputs
#    define fflush		PerlSIO_fflush
#    define ungetc		PerlSIO_ungetc
#    define fileno		PerlSIO_fileno
#    define fdopen		PerlSIO_fdopen
#    define freopen		PerlSIO_freopen
#    define fread		PerlSIO_fread
#    define fwrite		PerlSIO_fwrite
d363 8
a370 8
#    define stdoutf		PerlSIO_stdoutf
#    define vfprintf		PerlSIO_vprintf
#    define ftell		PerlSIO_ftell
#    define fseek		PerlSIO_fseek
#    define fgetpos		PerlSIO_fgetpos
#    define fsetpos		PerlSIO_fsetpos
#    define frewind		PerlSIO_rewind
#    define tmpfile		PerlSIO_tmpfile
@


1.1.1.6
log
@perl 5.8.3 from CPAN
@
text
@d196 1
a196 2
	IV tmpXSoff = (off);				\
	PL_stack_sp = PL_stack_base + ax + (tmpXSoff - 1);	\
d215 1
a215 1
	SV *_sv; STRLEN n_a;						\
d218 1
a218 1
	    _sv = ST(1);						\
d221 1
a221 1
	    _sv = get_sv(Perl_form(aTHX_ "%s::%s", module,		\
d223 2
a224 2
	    if (!_sv || !SvOK(_sv))					\
		_sv = get_sv(Perl_form(aTHX_ "%s::%s", module,	\
d227 1
a227 1
	if (_sv && (!SvOK(_sv) || strNE(XS_VERSION, SvPV(_sv, n_a))))	\
d231 1
a231 1
		  vn ? vn : "bootstrap parameter", _sv);		\
a268 2
            if (name[7] == 's')                                 \
                arg = newSVsv(arg);                             \
a277 4
            if (name[7] == 's'){                                \
                arg = sv_2mortal(arg);                          \
            }                                                   \
            SvOKp(arg);                                         \
@


1.1.1.7
log
@Import of stock perl 5.8.5
@
text
@d169 1
a169 1
=for apidoc AmU||newXSproto|char* name|XSUBADDR_t f|char* filename|const char *proto
@


1.1.1.8
log
@perl 5.8.8 import
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006 by Larry Wall and others
a56 4
=for apidoc Ams||dAXMARK
Sets up the C<ax> variable and stack marker variable C<mark>.
This is usually handled automatically by C<xsubpp> by calling C<dXSARGS>.

a72 12
#ifndef PERL_UNUSED_ARG
#  ifdef lint
#    include <note.h>
#    define PERL_UNUSED_ARG(x) NOTE(ARGUNUSED(x))
#  else
#    define PERL_UNUSED_ARG(x) ((void)x)
#  endif
#endif
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(x) ((void)x)
#endif

d78 1
a78 5
#  ifdef HASATTRIBUTE_UNUSED
#    define XS(name) void name(pTHX_ CV* cv __attribute__unused__)
#  else
#    define XS(name) void name(pTHX_ CV* cv)
#  endif
d81 1
a81 5
#define dAX const I32 ax = MARK - PL_stack_base + 1

#define dAXMARK				\
	I32 ax = POPMARK;	\
	register SV **mark = PL_stack_base + ax++
d85 3
a87 8
#ifdef lint
#  define dXSARGS \
	NOTE(ARGUNUSED(cv)) \
	dSP; dAXMARK; dITEMS
#else
#  define dXSARGS \
	dSP; dAXMARK; dITEMS
#endif
d89 1
a89 1
#define dXSTARG SV * const targ = ((PL_op->op_private & OPpENTERSUB_HASTARG) \
d216 2
a217 2
	SV *_sv;							\
	const char *vn = Nullch, *module = SvPV_nolen_const(ST(0));	\
d228 1
a228 1
	if (_sv && (!SvOK(_sv) || strNE(XS_VERSION, SvPV_nolen_const(_sv))))	\
a542 10

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 noet:
 */
@


1.1.1.9
log
@import perl 5.10.0 from CPAN
@
text
@d3 2
a4 2
 *    Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
 *    2003, 2004, 2005, 2006, 2007 by Larry Wall and others
a73 8
=for apidoc Ams||dUNDERBAR
Sets up the C<padoff_du> variable for an XSUB that wishes to use
C<UNDERBAR>.

=for apidoc AmU||UNDERBAR
The SV* corresponding to the $_ variable. Works even if there
is a lexical $_ in scope.

d78 1
a78 1
#  if defined(lint) && defined(S_SPLINT_S) /* www.splint.org */
a90 13
/* XSPROTO() is also used by SWIG like this:
 *
 *     typedef XSPROTO(SwigPerlWrapper);
 *     typedef SwigPerlWrapper *SwigPerlWrapperPtr;
 *
 * This code needs to be compilable under both C and C++.
 *
 * Don't forget to change the __attribute__unused__ version of XS()
 * below too if you change XSPROTO() here.
 */
#define XSPROTO(name) void name(pTHX_ CV* cv)

#undef XS
d92 3
a94 7
#  define XS(name) __declspec(dllexport) XSPROTO(name)
#endif
#if defined(__SYMBIAN32__)
#  define XS(name) EXPORT_C XSPROTO(name)
#endif
#ifndef XS
#  if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
d97 1
a97 5
#    ifdef __cplusplus
#      define XS(name) extern "C" XSPROTO(name)
#    else
#      define XS(name) XSPROTO(name)
#    endif
d101 1
a101 1
#define dAX const I32 ax = (I32)(MARK - PL_stack_base + 1)
d107 1
a107 1
#define dITEMS I32 items = (I32)(SP - MARK)
d109 1
a109 1
#if defined(lint) && defined(S_SPLINT_S) /* www.splint.org */
a129 1
#  define XSINTERFACE_CVT_ANON(ret) ret (*)(...)
a131 1
#  define XSINTERFACE_CVT_ANON(ret) ret (*)()
d134 1
a134 1
#define XSINTERFACE_FUNC(ret,cv,f)     ((XSINTERFACE_CVT_ANON(ret))(f))
a137 5
#define dUNDERBAR PADOFFSET padoff_du = find_rundefsvoffset()
#define UNDERBAR ((padoff_du == NOT_IN_PAD \
	    || PAD_COMPNAME_FLAGS_isOUR(padoff_du)) \
	? DEFSV : PAD_SVl(padoff_du))

a210 18
=head1 Simple Exception Handling Macros

=for apidoc Ams||dXCPT
Set up necessary local variables for exception handling.
See L<perlguts/"Exception Handling">.

=for apidoc AmU||XCPT_TRY_START
Starts a try block.  See L<perlguts/"Exception Handling">.

=for apidoc AmU||XCPT_TRY_END
Ends a try block.  See L<perlguts/"Exception Handling">.

=for apidoc AmU||XCPT_CATCH
Introduces a catch block.  See L<perlguts/"Exception Handling">.

=for apidoc Ams||XCPT_RETHROW
Rethrows a previously caught exception.  See L<perlguts/"Exception Handling">.

d225 1
a225 1
	const IV tmpXSoff = (off);			\
d240 1
a240 1
#define newXSproto(a,b,c,d)	newXS_flags(a,b,c,d,0)
d246 1
a246 1
	const char *vn = NULL, *module = SvPV_nolen_const(ST(0));	\
d257 5
a261 11
	if (_sv) {							\
	    SV *xssv = Perl_newSVpv(aTHX_ XS_VERSION, 0);		\
	    xssv = new_version(xssv);					\
	    if ( !sv_derived_from(_sv, "version") )			\
		_sv = new_version(_sv);				\
	    if ( vcmp(_sv,xssv) )					\
		Perl_croak(aTHX_ "%s object version %"SVf" does not match %s%s%s%s %"SVf,\
		      module, SVfARG(vstringify(xssv)),			\
		      vn ? "$" : "", vn ? module : "", vn ? "::" : "",	\
		      vn ? vn : "bootstrap parameter", SVfARG(vstringify(_sv)));\
	}                                                               \
a266 8
#ifdef NO_XSLOCKS
#  define dXCPT             dJMPENV; int rEtV = 0
#  define XCPT_TRY_START    JMPENV_PUSH(rEtV); if (rEtV == 0)
#  define XCPT_TRY_END      JMPENV_POP;
#  define XCPT_CATCH        if (rEtV != 0)
#  define XCPT_RETHROW      JMPENV_JUMP(rEtV)
#endif

d273 1
a273 1
	STMT_START {						\
d287 1
a287 1
	} STMT_END
a289 1
        STMT_START {						\
d313 2
a314 1
	} } STMT_END                                                     
a349 6
#ifndef PERL_MAD
#  undef PL_madskills
#  undef PL_xmlfp
#  define PL_madskills 0
#  define PL_xmlfp 0
#endif
@


1.1.1.10
log
@import perl 5.10.1
@
text
@d4 1
a4 1
 *    2003, 2004, 2005, 2006, 2007, 2008 by Larry Wall and others
d272 1
a272 1
#define XST_mPVN(i,v,n)  (ST(i) = newSVpvn_flags(v,n, SVs_TEMP))
d367 1
a367 1
	    SAVE_DEFSV ;					\
d370 1
a370 1
	    DEFSV_set(arg) ;					\
d418 6
@


1.1.1.11
log
@Perl 5.12.2 from CPAN
@
text
@d297 1
a297 1
#  define XS_VERSION_BOOTCHECK						\
d308 1
a308 1
		_sv = get_sv(Perl_form(aTHX_ "%s::%s", module,		\
d312 9
a320 21
	    SV *xpt = NULL;						\
	    SV *xssv = Perl_newSVpvn(aTHX_ STR_WITH_LEN(XS_VERSION));	\
	    SV *pmsv = sv_derived_from(_sv, "version")			\
		? SvREFCNT_inc_simple_NN(_sv)				\
		: new_version(_sv);					\
	    xssv = upg_version(xssv, 0);				\
	    if ( vcmp(pmsv,xssv) ) {	 				\
		xpt = Perl_newSVpvf(aTHX_ "%s object version %"SVf	\
				    " does not match %s%s%s%s %"SVf,	\
				    module,				\
				    SVfARG(Perl_sv_2mortal(aTHX_ vstringify(xssv))), \
				    vn ? "$" : "", vn ? module : "",	\
				    vn ? "::" : "",			\
				    vn ? vn : "bootstrap parameter",	\
				    SVfARG(Perl_sv_2mortal(aTHX_ vstringify(pmsv)))); \
		Perl_sv_2mortal(aTHX_ xpt);				\
	    }								\
	    SvREFCNT_dec(xssv);						\
	    SvREFCNT_dec(pmsv);						\
	    if (xpt)							\
		Perl_croak(aTHX_ "%s", SvPVX(xpt));			\
a480 6
/* to avoid warnings: "xyz" redefined */
#ifdef WIN32
#    undef  popen
#    undef  pclose
#endif /* WIN32 */

a503 1
#    define fgets		PerlSIO_fgets
@


1.1.1.12
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d51 1
a51 9
C<xsubpp>. It is the same as using the more explicit XS_EXTERNAL macro.

=for apidoc AmU||XS_INTERNAL
Macro to declare an XSUB and its C parameter list without exporting the symbols.
This is handled by C<xsubpp> and generally preferable over exporting the XSUB
symbols unnecessarily.

=for apidoc AmU||XS_EXTERNAL
Macro to declare an XSUB and its C parameter list explicitly exporting the symbols.
d75 2
a76 3
Sets up any variable needed by the C<UNDERBAR> macro. It used to define
C<padoff_du>, but it is currently a noop. However, it is strongly advised
to still use it for ensuring past and future compatibility.
a108 8

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that.
 */

a111 2
#undef XS_EXTERNAL
#undef XS_INTERNAL
d113 1
a113 2
#  define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#  define XS_INTERNAL(name) STATIC XSPROTO(name)
d116 1
a116 2
#  define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#  define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
d118 1
a118 1
#ifndef XS_EXTERNAL
d120 1
a120 2
#    define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#    define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
d123 1
a123 2
#      define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#      define XS_INTERNAL(name) static XSPROTO(name)
d125 1
a125 2
#      define XS_EXTERNAL(name) XSPROTO(name)
#      define XS_INTERNAL(name) STATIC XSPROTO(name)
a129 4
/* We do export xsub symbols by default for the public XS macro.
 * Try explicitly using XS_INTERNAL/XS_EXTERNAL instead, please. */
#define XS(name) XS_EXTERNAL(name)

d169 4
a172 2
#define dUNDERBAR dNOOP
#define UNDERBAR  find_rundefsv()
a246 4
=for apidoc Ams||XS_APIVERSION_BOOTCHECK
Macro to verify that the perl api version an XS module has been compiled against
matches the api version of the perl interpreter it's being loaded into.

d298 37
a334 1
    Perl_xs_version_bootcheck(aTHX_ items, ax, STR_WITH_LEN(XS_VERSION))
a338 3
#define XS_APIVERSION_BOOTCHECK						\
    Perl_xs_apiversion_bootcheck(aTHX_ ST(0), STR_WITH_LEN("v" PERL_API_VERSION_STRING))

d347 3
a349 3
/*
   The DBM_setFilter & DBM_ckFilter macros are only used by
   the *DB*_File modules
d400 1
@


1.1.1.13
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d162 1
a162 1
	SV **mark = PL_stack_base + ax++
d638 12
a649 10
#    undef fd_set
#    undef FD_SET
#    undef FD_CLR
#    undef FD_ISSET
#    undef FD_ZERO
#    define fd_set		Perl_fd_set
#    define FD_SET(n,p)		PERL_FD_SET(n,p)
#    define FD_CLR(n,p)		PERL_FD_CLR(n,p)
#    define FD_ISSET(n,p)	PERL_FD_ISSET(n,p)
#    define FD_ZERO(p)		PERL_FD_ZERO(p)
d660 1
a660 1
 * indent-tabs-mode: nil
d663 1
a663 1
 * ex: set ts=8 sts=4 sw=4 et:
@


1.1.1.14
log
@Import perl-5.20.1
@
text
@d25 1
a25 1
XSUB.  This is always the proper type for the XSUB.  See 
d51 1
a51 1
C<xsubpp>.  It is the same as using the more explicit XS_EXTERNAL macro.
d83 2
a84 2
Sets up any variable needed by the C<UNDERBAR> macro.  It used to define
C<padoff_du>, but it is currently a noop.  However, it is strongly advised
d88 1
a88 1
The SV* corresponding to the $_ variable.  Works even if there
@


1.1.1.15
log
@Import perl-5.24.2
@
text
@d17 1
a17 1
=head1 C<xsubpp> variables and internal functions
d21 1
a21 2
class name for a C++ XS constructor.  This is always a C<char*>.  See
C<L</THIS>>.
d30 1
a30 1
XSUB.  This is always the proper type for the C++ object.  See C<L</CLASS>> and
d51 1
a51 1
C<xsubpp>.  It is the same as using the more explicit C<XS_EXTERNAL> macro.
d74 1
a74 1
Sets up stack and mark pointers for an XSUB, calling C<dSP> and C<dMARK>.
d88 2
a89 2
The SV* corresponding to the C<$_> variable.  Works even if there
is a lexical C<$_> in scope.
a172 18
/* These 3 macros are replacements for dXSARGS macro only in bootstrap.
   They factor out common code in every BOOT XSUB. Computation of vars mark
   and items will optimize away in most BOOT functions. Var ax can never be
   optimized away since BOOT must return &PL_sv_yes by default from xsubpp.
   Note these macros are not drop in replacements for dXSARGS since they set
   PL_xsubfilename. */
#  define dXSBOOTARGSXSAPIVERCHK  \
	I32 ax = XS_BOTHVERSION_SETXSUBFN_POPMARK_BOOTCHECK;	\
	SV **mark = PL_stack_base + ax; dSP; dITEMS
#  define dXSBOOTARGSAPIVERCHK  \
	I32 ax = XS_APIVERSION_SETXSUBFN_POPMARK_BOOTCHECK;	\
	SV **mark = PL_stack_base + ax; dSP; dITEMS
/* dXSBOOTARGSNOVERCHK has no API in xsubpp to choose it so do
#undef dXSBOOTARGSXSAPIVERCHK
#define dXSBOOTARGSXSAPIVERCHK dXSBOOTARGSNOVERCHK */
#  define dXSBOOTARGSNOVERCHK  \
	I32 ax = XS_SETXSUBFN_POPMARK;  \
	SV **mark = PL_stack_base + ax; dSP; dITEMS
d266 1
a266 2
handled automatically by C<ExtUtils::MakeMaker>.  See
C<L</XS_VERSION_BOOTCHECK>>.
d269 1
a269 1
Macro to verify that a PM module's C<$VERSION> variable matches the XS
d277 1
a277 1
=head1 Exception Handling (simple) Macros
a309 1
	assert(tmpXSoff >= 0);\
d328 1
a328 2
    Perl_xs_handshake(HS_KEY(FALSE, FALSE, "", XS_VERSION), HS_CXT, __FILE__,	\
        items, ax, XS_VERSION)
d334 1
a334 44
    Perl_xs_handshake(HS_KEY(FALSE, FALSE, "v" PERL_API_VERSION_STRING, ""),	\
        HS_CXT, __FILE__, items, ax, "v" PERL_API_VERSION_STRING)
/* public API, this is a combination of XS_VERSION_BOOTCHECK and
   XS_APIVERSION_BOOTCHECK in 1, and is backportable */
#ifdef XS_VERSION
#  define XS_BOTHVERSION_BOOTCHECK						\
    Perl_xs_handshake(HS_KEY(FALSE, FALSE, "v" PERL_API_VERSION_STRING, XS_VERSION),	\
        HS_CXT, __FILE__, items, ax, "v" PERL_API_VERSION_STRING, XS_VERSION)
#else
/* should this be a #error? if you want both checked, you better supply XS_VERSION right? */
#  define XS_BOTHVERSION_BOOTCHECK XS_APIVERSION_BOOTCHECK
#endif

/* private API */
#define XS_APIVERSION_POPMARK_BOOTCHECK					\
    Perl_xs_handshake(HS_KEY(FALSE, TRUE, "v" PERL_API_VERSION_STRING, ""),	\
        HS_CXT, __FILE__, "v" PERL_API_VERSION_STRING)
#ifdef XS_VERSION
#  define XS_BOTHVERSION_POPMARK_BOOTCHECK					\
    Perl_xs_handshake(HS_KEY(FALSE, TRUE, "v" PERL_API_VERSION_STRING, XS_VERSION),	\
        HS_CXT, __FILE__, "v" PERL_API_VERSION_STRING, XS_VERSION)
#else
/* should this be a #error? if you want both checked, you better supply XS_VERSION right? */
#  define XS_BOTHVERSION_POPMARK_BOOTCHECK XS_APIVERSION_POPMARK_BOOTCHECK
#endif

#define XS_APIVERSION_SETXSUBFN_POPMARK_BOOTCHECK				\
    Perl_xs_handshake(HS_KEY(TRUE, TRUE, "v" PERL_API_VERSION_STRING, ""),	\
        HS_CXT, __FILE__, "v" PERL_API_VERSION_STRING)
#ifdef XS_VERSION
#  define XS_BOTHVERSION_SETXSUBFN_POPMARK_BOOTCHECK				  \
    Perl_xs_handshake(HS_KEY(TRUE, TRUE, "v" PERL_API_VERSION_STRING, XS_VERSION),\
        HS_CXT, __FILE__, "v" PERL_API_VERSION_STRING, XS_VERSION)
#else
/* should this be a #error? if you want both checked, you better supply XS_VERSION right? */
#  define XS_BOTHVERSION_SETXSUBFN_POPMARK_BOOTCHECK XS_APIVERSION_SETXSUBFN_POPMARK_BOOTCHECK
#endif

/* For a normal bootstrap without API or XS version checking.
   Useful for static XS modules or debugging/testing scenarios.
   If this macro gets heavily used in the future, it should separated into
   a separate function independent of Perl_xs_handshake for efficiency */
#define XS_SETXSUBFN_POPMARK \
    Perl_xs_handshake(HS_KEY(TRUE, TRUE, "", "") | HSf_NOCHK, HS_CXT, __FILE__)
d355 1
a355 1
	        SvREFCNT_dec_NN(db_type) ;			\
d655 6
@


