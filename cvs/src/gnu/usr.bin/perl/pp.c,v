head	1.24;
access;
symbols
	OPENBSD_6_1:1.24.0.2
	OPENBSD_6_1_BASE:1.24
	OPENBSD_6_0:1.22.0.8
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.22.0.2
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.22.0.4
	OPENBSD_5_8_BASE:1.22
	PERL_5_20_2:1.1.1.16
	OPENBSD_5_7:1.19.0.2
	OPENBSD_5_7_BASE:1.19
	PERL_5_20_1:1.1.1.16
	OPENBSD_5_6:1.17.0.4
	OPENBSD_5_6_BASE:1.17
	PERL_5_18_2:1.1.1.15
	PERL:1.1.1
	OPENBSD_5_5:1.16.0.6
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.2
	OPENBSD_5_4_BASE:1.16
	PERL_5_16_3:1.1.1.14
	OPENBSD_5_3:1.15.0.8
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.6
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.4
	OPENBSD_5_0:1.15.0.2
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.14.0.2
	OPENBSD_4_9_BASE:1.14
	PERL_5_12_2:1.1.1.13
	OPENBSD_4_8:1.13.0.4
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.2
	OPENBSD_4_7_BASE:1.13
	PERL_5_10_1:1.1.1.12
	OPENBSD_4_6:1.12.0.6
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.2
	OPENBSD_4_5_BASE:1.12
	PERL_5_10_0:1.1.1.11
	OPENBSD_4_4:1.11.0.10
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.8
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.6
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.4
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.2
	OPENBSD_4_0_BASE:1.11
	PERL_5_8_8:1.1.1.10
	OPENBSD_3_9:1.10.0.6
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.4
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.2
	OPENBSD_3_7_BASE:1.10
	PERL_5_8_6:1.1.1.9
	OPENBSD_3_6:1.9.0.2
	OPENBSD_3_6_BASE:1.9
	PERL_5_8_5:1.1.1.8
	PERL_5_8_3:1.1.1.7
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.24
date	2017.02.05.00.33.38;	author afresh1;	state Exp;
branches;
next	1.23;
commitid	7JLVNm1wwPgqSqTa;

1.23
date	2017.02.05.00.31.53;	author afresh1;	state Exp;
branches;
next	1.22;
commitid	cxJ08BvJA9Pt2PTM;

1.22
date	2015.07.16.15.19.55;	author bluhm;	state Exp;
branches;
next	1.21;
commitid	crgyVc2z53mvqmGP;

1.21
date	2015.04.25.19.26.15;	author afresh1;	state Exp;
branches;
next	1.20;
commitid	3qGYFVvfrExB70FB;

1.20
date	2015.04.25.19.14.37;	author afresh1;	state Exp;
branches;
next	1.19;
commitid	XRK22kO4se3v2i2I;

1.19
date	2014.12.30.20.46.45;	author afresh1;	state Exp;
branches;
next	1.18;
commitid	ij0neLKXNMN90mY6;

1.18
date	2014.11.17.20.56.47;	author afresh1;	state Exp;
branches;
next	1.17;
commitid	QP75iYx42Uo7mMxO;

1.17
date	2014.03.24.15.05.13;	author afresh1;	state Exp;
branches;
next	1.16;

1.16
date	2013.03.25.20.40.45;	author sthen;	state Exp;
branches;
next	1.15;

1.15
date	2011.04.18.21.29.51;	author bluhm;	state Exp;
branches;
next	1.14;

1.14
date	2010.09.24.15.06.41;	author millert;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	2009.10.12.18.24.21;	author millert;	state Exp;
branches
	1.13.4.1;
next	1.12;

1.12
date	2008.09.29.17.35.58;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2006.03.28.19.22.58;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2005.01.15.21.30.21;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2004.08.09.18.08.56;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2004.04.07.21.33.00;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.22;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.18;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.34.54;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.04.16;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.51.07;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.49.08;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.11.46;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.11.46;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.37.41;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.08.44;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.22.16;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.14.49;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.43.33;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.04.07.21.12.53;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.08.09.17.45.44;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2005.01.15.21.16.31;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2006.03.28.18.47.36;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2008.09.29.17.18.08;	author millert;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2009.10.12.18.10.35;	author millert;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2010.09.24.14.48.18;	author millert;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2013.03.25.20.06.31;	author sthen;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	2014.03.24.14.58.46;	author afresh1;	state Exp;
branches;
next	1.1.1.16;

1.1.1.16
date	2014.11.17.20.52.38;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;

1.13.4.1
date	2011.04.20.13.58.54;	author bluhm;	state Exp;
branches;
next	;

1.14.2.1
date	2011.04.20.13.53.38;	author bluhm;	state Exp;
branches;
next	;


desc
@@


1.24
log
@Apply local patches - perl-5.24.1
@
text
@/*    pp.c
 *
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
 *    2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

/*
 * 'It's a big house this, and very peculiar.  Always a bit more
 *  to discover, and no knowing what you'll find round a corner.
 *  And Elves, sir!'                            --Samwise Gamgee
 *
 *     [p.225 of _The Lord of the Rings_, II/i: "Many Meetings"]
 */

/* This file contains general pp ("push/pop") functions that execute the
 * opcodes that make up a perl program. A typical pp function expects to
 * find its arguments on the stack, and usually pushes its results onto
 * the stack, hence the 'pp' terminology. Each OP structure contains
 * a pointer to the relevant pp_foo() function.
 */

#include "EXTERN.h"
#define PERL_IN_PP_C
#include "perl.h"
#include "keywords.h"

#include "reentr.h"
#include "regcharclass.h"

/* XXX I can't imagine anyone who doesn't have this actually _needs_
   it, since pid_t is an integral type.
   --AD  2/20/1998
*/
#ifdef NEED_GETPID_PROTO
extern Pid_t getpid (void);
#endif

/*
 * Some BSDs and Cygwin default to POSIX math instead of IEEE.
 * This switches them over to IEEE.
 */
#if defined(LIBM_LIB_VERSION)
    _LIB_VERSION_TYPE _LIB_VERSION = _IEEE_;
#endif

static const STRLEN small_mu_len = sizeof(GREEK_SMALL_LETTER_MU_UTF8) - 1;
static const STRLEN capital_iota_len = sizeof(GREEK_CAPITAL_LETTER_IOTA_UTF8) - 1;

/* variations on pp_null */

PP(pp_stub)
{
    dSP;
    if (GIMME_V == G_SCALAR)
	XPUSHs(&PL_sv_undef);
    RETURN;
}

/* Pushy stuff. */

/* This is also called directly by pp_lvavref.  */
PP(pp_padav)
{
    dSP; dTARGET;
    U8 gimme;
    assert(SvTYPE(TARG) == SVt_PVAV);
    if (UNLIKELY( PL_op->op_private & OPpLVAL_INTRO ))
	if (LIKELY( !(PL_op->op_private & OPpPAD_STATE) ))
	    SAVECLEARSV(PAD_SVl(PL_op->op_targ));
    EXTEND(SP, 1);

    if (PL_op->op_flags & OPf_REF) {
	PUSHs(TARG);
	RETURN;
    }
    else if (PL_op->op_private & OPpMAYBE_LVSUB) {
        const I32 flags = is_lvalue_sub();
        if (flags && !(flags & OPpENTERSUB_INARGS)) {
	    if (GIMME_V == G_SCALAR)
                /* diag_listed_as: Can't return %s to lvalue scalar context */
                Perl_croak(aTHX_ "Can't return array to lvalue scalar context");
            PUSHs(TARG);
            RETURN;
       }
    }

    gimme = GIMME_V;
    if (gimme == G_ARRAY) {
        /* XXX see also S_pushav in pp_hot.c */
	const SSize_t maxarg = AvFILL(MUTABLE_AV(TARG)) + 1;
	EXTEND(SP, maxarg);
	if (SvMAGICAL(TARG)) {
	    SSize_t i;
	    for (i=0; i < maxarg; i++) {
		SV * const * const svp = av_fetch(MUTABLE_AV(TARG), i, FALSE);
		SP[i+1] = (svp) ? *svp : &PL_sv_undef;
	    }
	}
	else {
	    SSize_t i;
	    for (i=0; i < maxarg; i++) {
		SV * const sv = AvARRAY((const AV *)TARG)[i];
		SP[i+1] = sv ? sv : &PL_sv_undef;
	    }
	}
	SP += maxarg;
    }
    else if (gimme == G_SCALAR) {
	SV* const sv = sv_newmortal();
	const SSize_t maxarg = AvFILL(MUTABLE_AV(TARG)) + 1;
	sv_setiv(sv, maxarg);
	PUSHs(sv);
    }
    RETURN;
}

PP(pp_padhv)
{
    dSP; dTARGET;
    U8 gimme;

    assert(SvTYPE(TARG) == SVt_PVHV);
    XPUSHs(TARG);
    if (UNLIKELY( PL_op->op_private & OPpLVAL_INTRO ))
	if (LIKELY( !(PL_op->op_private & OPpPAD_STATE) ))
	    SAVECLEARSV(PAD_SVl(PL_op->op_targ));

    if (PL_op->op_flags & OPf_REF)
	RETURN;
    else if (PL_op->op_private & OPpMAYBE_LVSUB) {
        const I32 flags = is_lvalue_sub();
        if (flags && !(flags & OPpENTERSUB_INARGS)) {
            if (GIMME_V == G_SCALAR)
                /* diag_listed_as: Can't return %s to lvalue scalar context */
                Perl_croak(aTHX_ "Can't return hash to lvalue scalar context");
            RETURN;
        }
    }

    gimme = GIMME_V;
    if (gimme == G_ARRAY) {
	RETURNOP(Perl_do_kv(aTHX));
    }
    else if ((PL_op->op_private & OPpTRUEBOOL
	  || (  PL_op->op_private & OPpMAYBE_TRUEBOOL
	     && block_gimme() == G_VOID  ))
	  && (!SvRMAGICAL(TARG) || !mg_find(TARG, PERL_MAGIC_tied))
    )
	SETs(HvUSEDKEYS(TARG) ? &PL_sv_yes : sv_2mortal(newSViv(0)));
    else if (gimme == G_SCALAR) {
	SV* const sv = Perl_hv_scalar(aTHX_ MUTABLE_HV(TARG));
	SETs(sv);
    }
    RETURN;
}

PP(pp_padcv)
{
    dSP; dTARGET;
    assert(SvTYPE(TARG) == SVt_PVCV);
    XPUSHs(TARG);
    RETURN;
}

PP(pp_introcv)
{
    dTARGET;
    SvPADSTALE_off(TARG);
    return NORMAL;
}

PP(pp_clonecv)
{
    dTARGET;
    CV * const protocv = PadnamePROTOCV(
	PadlistNAMESARRAY(CvPADLIST(find_runcv(NULL)))[ARGTARG]
    );
    assert(SvTYPE(TARG) == SVt_PVCV);
    assert(protocv);
    if (CvISXSUB(protocv)) { /* constant */
	/* XXX Should we clone it here? */
	/* If this changes to use SAVECLEARSV, we can move the SAVECLEARSV
	   to introcv and remove the SvPADSTALE_off. */
	SAVEPADSVANDMORTALIZE(ARGTARG);
	PAD_SVl(ARGTARG) = SvREFCNT_inc_simple_NN(protocv);
    }
    else {
	if (CvROOT(protocv)) {
	    assert(CvCLONE(protocv));
	    assert(!CvCLONED(protocv));
	}
	cv_clone_into(protocv,(CV *)TARG);
	SAVECLEARSV(PAD_SVl(ARGTARG));
    }
    return NORMAL;
}

/* Translations. */

/* In some cases this function inspects PL_op.  If this function is called
   for new op types, more bool parameters may need to be added in place of
   the checks.

   When noinit is true, the absence of a gv will cause a retval of undef.
   This is unrelated to the cv-to-gv assignment case.
*/

static SV *
S_rv2gv(pTHX_ SV *sv, const bool vivify_sv, const bool strict,
              const bool noinit)
{
    if (!isGV(sv) || SvFAKE(sv)) SvGETMAGIC(sv);
    if (SvROK(sv)) {
	if (SvAMAGIC(sv)) {
	    sv = amagic_deref_call(sv, to_gv_amg);
	}
      wasref:
	sv = SvRV(sv);
	if (SvTYPE(sv) == SVt_PVIO) {
	    GV * const gv = MUTABLE_GV(sv_newmortal());
	    gv_init(gv, 0, "__ANONIO__", 10, 0);
	    GvIOp(gv) = MUTABLE_IO(sv);
	    SvREFCNT_inc_void_NN(sv);
	    sv = MUTABLE_SV(gv);
	}
	else if (!isGV_with_GP(sv)) {
	    Perl_die(aTHX_ "Not a GLOB reference");
        }
    }
    else {
	if (!isGV_with_GP(sv)) {
	    if (!SvOK(sv)) {
		/* If this is a 'my' scalar and flag is set then vivify
		 * NI-S 1999/05/07
		 */
		if (vivify_sv && sv != &PL_sv_undef) {
		    GV *gv;
		    if (SvREADONLY(sv))
			Perl_croak_no_modify();
		    if (cUNOP->op_targ) {
			SV * const namesv = PAD_SV(cUNOP->op_targ);
			HV *stash = CopSTASH(PL_curcop);
			if (SvTYPE(stash) != SVt_PVHV) stash = NULL;
			gv = MUTABLE_GV(newSV(0));
			gv_init_sv(gv, stash, namesv, 0);
		    }
		    else {
			const char * const name = CopSTASHPV(PL_curcop);
			gv = newGVgen_flags(name,
                                HvNAMEUTF8(CopSTASH(PL_curcop)) ? SVf_UTF8 : 0 );
			SvREFCNT_inc_simple_void_NN(gv);
		    }
		    prepare_SV_for_RV(sv);
		    SvRV_set(sv, MUTABLE_SV(gv));
		    SvROK_on(sv);
		    SvSETMAGIC(sv);
		    goto wasref;
		}
		if (PL_op->op_flags & OPf_REF || strict) {
		    Perl_die(aTHX_ PL_no_usym, "a symbol");
                }
		if (ckWARN(WARN_UNINITIALIZED))
		    report_uninit(sv);
		return &PL_sv_undef;
	    }
	    if (noinit)
	    {
		if (!(sv = MUTABLE_SV(gv_fetchsv_nomg(
		           sv, GV_ADDMG, SVt_PVGV
		   ))))
		    return &PL_sv_undef;
	    }
	    else {
		if (strict) {
                    Perl_die(aTHX_
                             PL_no_symref_sv,
                             sv,
                             (SvPOKp(sv) && SvCUR(sv)>32 ? "..." : ""),
                             "a symbol"
                             );
                }
		if ((PL_op->op_private & (OPpLVAL_INTRO|OPpDONT_INIT_GV))
		    == OPpDONT_INIT_GV) {
		    /* We are the target of a coderef assignment.  Return
		       the scalar unchanged, and let pp_sasssign deal with
		       things.  */
		    return sv;
		}
		sv = MUTABLE_SV(gv_fetchsv_nomg(sv, GV_ADD, SVt_PVGV));
	    }
	    /* FAKE globs in the symbol table cause weird bugs (#77810) */
	    SvFAKE_off(sv);
	}
    }
    if (SvFAKE(sv) && !(PL_op->op_private & OPpALLOW_FAKE)) {
	SV *newsv = sv_newmortal();
	sv_setsv_flags(newsv, sv, 0);
	SvFAKE_off(newsv);
	sv = newsv;
    }
    return sv;
}

PP(pp_rv2gv)
{
    dSP; dTOPss;

    sv = S_rv2gv(aTHX_
          sv, PL_op->op_private & OPpDEREF,
          PL_op->op_private & HINT_STRICT_REFS,
          ((PL_op->op_flags & OPf_SPECIAL) && !(PL_op->op_flags & OPf_MOD))
             || PL_op->op_type == OP_READLINE
         );
    if (PL_op->op_private & OPpLVAL_INTRO)
	save_gp(MUTABLE_GV(sv), !(PL_op->op_flags & OPf_SPECIAL));
    SETs(sv);
    RETURN;
}

/* Helper function for pp_rv2sv and pp_rv2av  */
GV *
Perl_softref2xv(pTHX_ SV *const sv, const char *const what,
		const svtype type, SV ***spp)
{
    GV *gv;

    PERL_ARGS_ASSERT_SOFTREF2XV;

    if (PL_op->op_private & HINT_STRICT_REFS) {
	if (SvOK(sv))
	    Perl_die(aTHX_ PL_no_symref_sv, sv,
		     (SvPOKp(sv) && SvCUR(sv)>32 ? "..." : ""), what);
	else
	    Perl_die(aTHX_ PL_no_usym, what);
    }
    if (!SvOK(sv)) {
	if (
	  PL_op->op_flags & OPf_REF
	)
	    Perl_die(aTHX_ PL_no_usym, what);
	if (ckWARN(WARN_UNINITIALIZED))
	    report_uninit(sv);
	if (type != SVt_PV && GIMME_V == G_ARRAY) {
	    (*spp)--;
	    return NULL;
	}
	**spp = &PL_sv_undef;
	return NULL;
    }
    if ((PL_op->op_flags & OPf_SPECIAL) &&
	!(PL_op->op_flags & OPf_MOD))
	{
	    if (!(gv = gv_fetchsv_nomg(sv, GV_ADDMG, type)))
		{
		    **spp = &PL_sv_undef;
		    return NULL;
		}
	}
    else {
	gv = gv_fetchsv_nomg(sv, GV_ADD, type);
    }
    return gv;
}

PP(pp_rv2sv)
{
    dSP; dTOPss;
    GV *gv = NULL;

    SvGETMAGIC(sv);
    if (SvROK(sv)) {
	if (SvAMAGIC(sv)) {
	    sv = amagic_deref_call(sv, to_sv_amg);
	}

	sv = SvRV(sv);
	if (SvTYPE(sv) >= SVt_PVAV)
	    DIE(aTHX_ "Not a SCALAR reference");
    }
    else {
	gv = MUTABLE_GV(sv);

	if (!isGV_with_GP(gv)) {
	    gv = Perl_softref2xv(aTHX_ sv, "a SCALAR", SVt_PV, &sp);
	    if (!gv)
		RETURN;
	}
	sv = GvSVn(gv);
    }
    if (PL_op->op_flags & OPf_MOD) {
	if (PL_op->op_private & OPpLVAL_INTRO) {
	    if (cUNOP->op_first->op_type == OP_NULL)
		sv = save_scalar(MUTABLE_GV(TOPs));
	    else if (gv)
		sv = save_scalar(gv);
	    else
		Perl_croak(aTHX_ "%s", PL_no_localize_ref);
	}
	else if (PL_op->op_private & OPpDEREF)
	    sv = vivify_ref(sv, PL_op->op_private & OPpDEREF);
    }
    SETs(sv);
    RETURN;
}

PP(pp_av2arylen)
{
    dSP;
    AV * const av = MUTABLE_AV(TOPs);
    const I32 lvalue = PL_op->op_flags & OPf_MOD || LVRET;
    if (lvalue) {
	SV ** const svp = Perl_av_arylen_p(aTHX_ MUTABLE_AV(av));
	if (!*svp) {
	    *svp = newSV_type(SVt_PVMG);
	    sv_magic(*svp, MUTABLE_SV(av), PERL_MAGIC_arylen, NULL, 0);
	}
	SETs(*svp);
    } else {
	SETs(sv_2mortal(newSViv(AvFILL(MUTABLE_AV(av)))));
    }
    RETURN;
}

PP(pp_pos)
{
    dSP; dTOPss;

    if (PL_op->op_flags & OPf_MOD || LVRET) {
	SV * const ret = sv_2mortal(newSV_type(SVt_PVLV));/* Not TARG RT#67838 */
	sv_magic(ret, NULL, PERL_MAGIC_pos, NULL, 0);
	LvTYPE(ret) = '.';
	LvTARG(ret) = SvREFCNT_inc_simple(sv);
	SETs(ret);    /* no SvSETMAGIC */
    }
    else {
	    const MAGIC * const mg = mg_find_mglob(sv);
	    if (mg && mg->mg_len != -1) {
		dTARGET;
		STRLEN i = mg->mg_len;
		if (mg->mg_flags & MGf_BYTES && DO_UTF8(sv))
		    i = sv_pos_b2u_flags(sv, i, SV_GMAGIC|SV_CONST_RETURN);
		SETu(i);
		return NORMAL;
	    }
	    SETs(&PL_sv_undef);
    }
    return NORMAL;
}

PP(pp_rv2cv)
{
    dSP;
    GV *gv;
    HV *stash_unused;
    const I32 flags = (PL_op->op_flags & OPf_SPECIAL)
	? GV_ADDMG
	: ((PL_op->op_private & (OPpLVAL_INTRO|OPpMAY_RETURN_CONSTANT))
                                                    == OPpMAY_RETURN_CONSTANT)
	    ? GV_ADD|GV_NOEXPAND
	    : GV_ADD;
    /* We usually try to add a non-existent subroutine in case of AUTOLOAD. */
    /* (But not in defined().) */

    CV *cv = sv_2cv(TOPs, &stash_unused, &gv, flags);
    if (cv) NOOP;
    else if ((flags == (GV_ADD|GV_NOEXPAND)) && gv && SvROK(gv)) {
	cv = SvTYPE(SvRV(gv)) == SVt_PVCV
	    ? MUTABLE_CV(SvRV(gv))
	    : MUTABLE_CV(gv);
    }    
    else
	cv = MUTABLE_CV(&PL_sv_undef);
    SETs(MUTABLE_SV(cv));
    return NORMAL;
}

PP(pp_prototype)
{
    dSP;
    CV *cv;
    HV *stash;
    GV *gv;
    SV *ret = &PL_sv_undef;

    if (SvGMAGICAL(TOPs)) SETs(sv_mortalcopy(TOPs));
    if (SvPOK(TOPs) && SvCUR(TOPs) >= 7) {
	const char * s = SvPVX_const(TOPs);
	if (strnEQ(s, "CORE::", 6)) {
	    const int code = keyword(s + 6, SvCUR(TOPs) - 6, 1);
	    if (!code)
		DIE(aTHX_ "Can't find an opnumber for \"%"UTF8f"\"",
		   UTF8fARG(SvFLAGS(TOPs) & SVf_UTF8, SvCUR(TOPs)-6, s+6));
	    {
		SV * const sv = core_prototype(NULL, s + 6, code, NULL);
		if (sv) ret = sv;
	    }
	    goto set;
	}
    }
    cv = sv_2cv(TOPs, &stash, &gv, 0);
    if (cv && SvPOK(cv))
	ret = newSVpvn_flags(
	    CvPROTO(cv), CvPROTOLEN(cv), SVs_TEMP | SvUTF8(cv)
	);
  set:
    SETs(ret);
    RETURN;
}

PP(pp_anoncode)
{
    dSP;
    CV *cv = MUTABLE_CV(PAD_SV(PL_op->op_targ));
    if (CvCLONE(cv))
	cv = MUTABLE_CV(sv_2mortal(MUTABLE_SV(cv_clone(cv))));
    EXTEND(SP,1);
    PUSHs(MUTABLE_SV(cv));
    RETURN;
}

PP(pp_srefgen)
{
    dSP;
    *SP = refto(*SP);
    return NORMAL;
}

PP(pp_refgen)
{
    dSP; dMARK;
    if (GIMME_V != G_ARRAY) {
	if (++MARK <= SP)
	    *MARK = *SP;
	else
	{
	    MEXTEND(SP, 1);
	    *MARK = &PL_sv_undef;
	}
	*MARK = refto(*MARK);
	SP = MARK;
	RETURN;
    }
    EXTEND_MORTAL(SP - MARK);
    while (++MARK <= SP)
	*MARK = refto(*MARK);
    RETURN;
}

STATIC SV*
S_refto(pTHX_ SV *sv)
{
    SV* rv;

    PERL_ARGS_ASSERT_REFTO;

    if (SvTYPE(sv) == SVt_PVLV && LvTYPE(sv) == 'y') {
	if (LvTARGLEN(sv))
	    vivify_defelem(sv);
	if (!(sv = LvTARG(sv)))
	    sv = &PL_sv_undef;
	else
	    SvREFCNT_inc_void_NN(sv);
    }
    else if (SvTYPE(sv) == SVt_PVAV) {
	if (!AvREAL((const AV *)sv) && AvREIFY((const AV *)sv))
	    av_reify(MUTABLE_AV(sv));
	SvTEMP_off(sv);
	SvREFCNT_inc_void_NN(sv);
    }
    else if (SvPADTMP(sv)) {
        sv = newSVsv(sv);
    }
    else {
	SvTEMP_off(sv);
	SvREFCNT_inc_void_NN(sv);
    }
    rv = sv_newmortal();
    sv_upgrade(rv, SVt_IV);
    SvRV_set(rv, sv);
    SvROK_on(rv);
    return rv;
}

PP(pp_ref)
{
    dSP;
    SV * const sv = TOPs;

    SvGETMAGIC(sv);
    if (!SvROK(sv))
	SETs(&PL_sv_no);
    else {
	dTARGET;
	SETs(TARG);
	/* use the return value that is in a register, its the same as TARG */
	TARG = sv_ref(TARG,SvRV(sv),TRUE);
	SvSETMAGIC(TARG);
    }

    return NORMAL;
}

PP(pp_bless)
{
    dSP;
    HV *stash;

    if (MAXARG == 1)
    {
      curstash:
	stash = CopSTASH(PL_curcop);
	if (SvTYPE(stash) != SVt_PVHV)
	    Perl_croak(aTHX_ "Attempt to bless into a freed package");
    }
    else {
	SV * const ssv = POPs;
	STRLEN len;
	const char *ptr;

	if (!ssv) goto curstash;
	SvGETMAGIC(ssv);
	if (SvROK(ssv)) {
	  if (!SvAMAGIC(ssv)) {
	   frog:
	    Perl_croak(aTHX_ "Attempt to bless into a reference");
	  }
	  /* SvAMAGIC is on here, but it only means potentially overloaded,
	     so after stringification: */
	  ptr = SvPV_nomg_const(ssv,len);
	  /* We need to check the flag again: */
	  if (!SvAMAGIC(ssv)) goto frog;
	}
	else ptr = SvPV_nomg_const(ssv,len);
	if (len == 0)
	    Perl_ck_warner(aTHX_ packWARN(WARN_MISC),
			   "Explicit blessing to '' (assuming package main)");
	stash = gv_stashpvn(ptr, len, GV_ADD|SvUTF8(ssv));
    }

    (void)sv_bless(TOPs, stash);
    RETURN;
}

PP(pp_gelem)
{
    dSP;

    SV *sv = POPs;
    STRLEN len;
    const char * const elem = SvPV_const(sv, len);
    GV * const gv = MUTABLE_GV(TOPs);
    SV * tmpRef = NULL;

    sv = NULL;
    if (elem) {
	/* elem will always be NUL terminated.  */
	const char * const second_letter = elem + 1;
	switch (*elem) {
	case 'A':
	    if (len == 5 && strEQ(second_letter, "RRAY"))
	    {
		tmpRef = MUTABLE_SV(GvAV(gv));
		if (tmpRef && !AvREAL((const AV *)tmpRef)
		 && AvREIFY((const AV *)tmpRef))
		    av_reify(MUTABLE_AV(tmpRef));
	    }
	    break;
	case 'C':
	    if (len == 4 && strEQ(second_letter, "ODE"))
		tmpRef = MUTABLE_SV(GvCVu(gv));
	    break;
	case 'F':
	    if (len == 10 && strEQ(second_letter, "ILEHANDLE")) {
		tmpRef = MUTABLE_SV(GvIOp(gv));
	    }
	    else
		if (len == 6 && strEQ(second_letter, "ORMAT"))
		    tmpRef = MUTABLE_SV(GvFORM(gv));
	    break;
	case 'G':
	    if (len == 4 && strEQ(second_letter, "LOB"))
		tmpRef = MUTABLE_SV(gv);
	    break;
	case 'H':
	    if (len == 4 && strEQ(second_letter, "ASH"))
		tmpRef = MUTABLE_SV(GvHV(gv));
	    break;
	case 'I':
	    if (*second_letter == 'O' && !elem[2] && len == 2)
		tmpRef = MUTABLE_SV(GvIOp(gv));
	    break;
	case 'N':
	    if (len == 4 && strEQ(second_letter, "AME"))
		sv = newSVhek(GvNAME_HEK(gv));
	    break;
	case 'P':
	    if (len == 7 && strEQ(second_letter, "ACKAGE")) {
		const HV * const stash = GvSTASH(gv);
		const HEK * const hek = stash ? HvNAME_HEK(stash) : NULL;
		sv = hek ? newSVhek(hek) : newSVpvs("__ANON__");
	    }
	    break;
	case 'S':
	    if (len == 6 && strEQ(second_letter, "CALAR"))
		tmpRef = GvSVn(gv);
	    break;
	}
    }
    if (tmpRef)
	sv = newRV(tmpRef);
    if (sv)
	sv_2mortal(sv);
    else
	sv = &PL_sv_undef;
    SETs(sv);
    RETURN;
}

/* Pattern matching */

PP(pp_study)
{
    dSP; dTOPss;
    STRLEN len;

    (void)SvPV(sv, len);
    if (len == 0 || len > I32_MAX || !SvPOK(sv) || SvUTF8(sv) || SvVALID(sv)) {
	/* Historically, study was skipped in these cases. */
	SETs(&PL_sv_no);
	return NORMAL;
    }

    /* Make study a no-op. It's no longer useful and its existence
       complicates matters elsewhere. */
    SETs(&PL_sv_yes);
    return NORMAL;
}


/* also used for: pp_transr() */

PP(pp_trans)
{
    dSP; 
    SV *sv;

    if (PL_op->op_flags & OPf_STACKED)
	sv = POPs;
    else {
	EXTEND(SP,1);
	if (ARGTARG)
	    sv = PAD_SV(ARGTARG);
	else {
	    sv = DEFSV;
	}
    }
    if(PL_op->op_type == OP_TRANSR) {
	STRLEN len;
	const char * const pv = SvPV(sv,len);
	SV * const newsv = newSVpvn_flags(pv, len, SVs_TEMP|SvUTF8(sv));
	do_trans(newsv);
	PUSHs(newsv);
    }
    else {
	I32 i = do_trans(sv);
	mPUSHi(i);
    }
    RETURN;
}

/* Lvalue operators. */

static size_t
S_do_chomp(pTHX_ SV *retval, SV *sv, bool chomping)
{
    STRLEN len;
    char *s;
    size_t count = 0;

    PERL_ARGS_ASSERT_DO_CHOMP;

    if (chomping && (RsSNARF(PL_rs) || RsRECORD(PL_rs)))
	return 0;
    if (SvTYPE(sv) == SVt_PVAV) {
	I32 i;
	AV *const av = MUTABLE_AV(sv);
	const I32 max = AvFILL(av);

	for (i = 0; i <= max; i++) {
	    sv = MUTABLE_SV(av_fetch(av, i, FALSE));
	    if (sv && ((sv = *(SV**)sv), sv != &PL_sv_undef))
		count += do_chomp(retval, sv, chomping);
	}
        return count;
    }
    else if (SvTYPE(sv) == SVt_PVHV) {
	HV* const hv = MUTABLE_HV(sv);
	HE* entry;
        (void)hv_iterinit(hv);
        while ((entry = hv_iternext(hv)))
            count += do_chomp(retval, hv_iterval(hv,entry), chomping);
	return count;
    }
    else if (SvREADONLY(sv)) {
            Perl_croak_no_modify();
    }

    if (IN_ENCODING) {
	if (!SvUTF8(sv)) {
	    /* XXX, here sv is utf8-ized as a side-effect!
	       If encoding.pm is used properly, almost string-generating
	       operations, including literal strings, chr(), input data, etc.
	       should have been utf8-ized already, right?
	    */
	    sv_recode_to_utf8(sv, _get_encoding());
	}
    }

    s = SvPV(sv, len);
    if (chomping) {
	if (s && len) {
	    char *temp_buffer = NULL;
	    SV *svrecode = NULL;
	    s += --len;
	    if (RsPARA(PL_rs)) {
		if (*s != '\n')
		    goto nope_free_nothing;
		++count;
		while (len && s[-1] == '\n') {
		    --len;
		    --s;
		    ++count;
		}
	    }
	    else {
		STRLEN rslen, rs_charlen;
		const char *rsptr = SvPV_const(PL_rs, rslen);

		rs_charlen = SvUTF8(PL_rs)
		    ? sv_len_utf8(PL_rs)
		    : rslen;

		if (SvUTF8(PL_rs) != SvUTF8(sv)) {
		    /* Assumption is that rs is shorter than the scalar.  */
		    if (SvUTF8(PL_rs)) {
			/* RS is utf8, scalar is 8 bit.  */
			bool is_utf8 = TRUE;
			temp_buffer = (char*)bytes_from_utf8((U8*)rsptr,
							     &rslen, &is_utf8);
			if (is_utf8) {
			    /* Cannot downgrade, therefore cannot possibly match.
			       At this point, temp_buffer is not alloced, and
			       is the buffer inside PL_rs, so dont free it.
			     */
			    assert (temp_buffer == rsptr);
			    goto nope_free_sv;
			}
			rsptr = temp_buffer;
		    }
		    else if (IN_ENCODING) {
			/* RS is 8 bit, encoding.pm is used.
			 * Do not recode PL_rs as a side-effect. */
			svrecode = newSVpvn(rsptr, rslen);
			sv_recode_to_utf8(svrecode, _get_encoding());
			rsptr = SvPV_const(svrecode, rslen);
			rs_charlen = sv_len_utf8(svrecode);
		    }
		    else {
			/* RS is 8 bit, scalar is utf8.  */
			temp_buffer = (char*)bytes_to_utf8((U8*)rsptr, &rslen);
			rsptr = temp_buffer;
		    }
		}
		if (rslen == 1) {
		    if (*s != *rsptr)
			goto nope_free_all;
		    ++count;
		}
		else {
		    if (len < rslen - 1)
			goto nope_free_all;
		    len -= rslen - 1;
		    s -= rslen - 1;
		    if (memNE(s, rsptr, rslen))
			goto nope_free_all;
		    count += rs_charlen;
		}
	    }
	    SvPV_force_nomg_nolen(sv);
	    SvCUR_set(sv, len);
	    *SvEND(sv) = '\0';
	    SvNIOK_off(sv);
	    SvSETMAGIC(sv);

	    nope_free_all:
	    Safefree(temp_buffer);
	    nope_free_sv:
	    SvREFCNT_dec(svrecode);
	    nope_free_nothing: ;
	}
    } else {
	if (len && (!SvPOK(sv) || SvIsCOW(sv)))
	    s = SvPV_force_nomg(sv, len);
	if (DO_UTF8(sv)) {
	    if (s && len) {
		char * const send = s + len;
		char * const start = s;
		s = send - 1;
		while (s > start && UTF8_IS_CONTINUATION(*s))
		    s--;
		if (is_utf8_string((U8*)s, send - s)) {
		    sv_setpvn(retval, s, send - s);
		    *s = '\0';
		    SvCUR_set(sv, s - start);
		    SvNIOK_off(sv);
		    SvUTF8_on(retval);
		}
	    }
	    else
		sv_setpvs(retval, "");
	}
	else if (s && len) {
	    s += --len;
	    sv_setpvn(retval, s, 1);
	    *s = '\0';
	    SvCUR_set(sv, len);
	    SvUTF8_off(sv);
	    SvNIOK_off(sv);
	}
	else
	    sv_setpvs(retval, "");
	SvSETMAGIC(sv);
    }
    return count;
}


/* also used for: pp_schomp() */

PP(pp_schop)
{
    dSP; dTARGET;
    const bool chomping = PL_op->op_type == OP_SCHOMP;

    const size_t count = do_chomp(TARG, TOPs, chomping);
    if (chomping)
	sv_setiv(TARG, count);
    SETTARG;
    return NORMAL;
}


/* also used for: pp_chomp() */

PP(pp_chop)
{
    dSP; dMARK; dTARGET; dORIGMARK;
    const bool chomping = PL_op->op_type == OP_CHOMP;
    size_t count = 0;

    while (MARK < SP)
	count += do_chomp(TARG, *++MARK, chomping);
    if (chomping)
	sv_setiv(TARG, count);
    SP = ORIGMARK;
    XPUSHTARG;
    RETURN;
}

PP(pp_undef)
{
    dSP;
    SV *sv;

    if (!PL_op->op_private) {
	EXTEND(SP, 1);
	RETPUSHUNDEF;
    }

    sv = TOPs;
    if (!sv)
    {
	SETs(&PL_sv_undef);
	return NORMAL;
    }

    if (SvTHINKFIRST(sv))
	sv_force_normal_flags(sv, SV_COW_DROP_PV|SV_IMMEDIATE_UNREF);

    switch (SvTYPE(sv)) {
    case SVt_NULL:
	break;
    case SVt_PVAV:
	av_undef(MUTABLE_AV(sv));
	break;
    case SVt_PVHV:
	hv_undef(MUTABLE_HV(sv));
	break;
    case SVt_PVCV:
	if (cv_const_sv((const CV *)sv))
	    Perl_ck_warner(aTHX_ packWARN(WARN_MISC),
                          "Constant subroutine %"SVf" undefined",
			   SVfARG(CvANON((const CV *)sv)
                             ? newSVpvs_flags("(anonymous)", SVs_TEMP)
                             : sv_2mortal(newSVhek(
                                CvNAMED(sv)
                                 ? CvNAME_HEK((CV *)sv)
                                 : GvENAME_HEK(CvGV((const CV *)sv))
                               ))
                           ));
	/* FALLTHROUGH */
    case SVt_PVFM:
	    /* let user-undef'd sub keep its identity */
	cv_undef_flags(MUTABLE_CV(sv), CV_UNDEF_KEEP_NAME);
	break;
    case SVt_PVGV:
	assert(isGV_with_GP(sv));
	assert(!SvFAKE(sv));
	{
	    GP *gp;
            HV *stash;

            /* undef *Pkg::meth_name ... */
            bool method_changed
             =   GvCVu((const GV *)sv) && (stash = GvSTASH((const GV *)sv))
	      && HvENAME_get(stash);
            /* undef *Foo:: */
            if((stash = GvHV((const GV *)sv))) {
                if(HvENAME_get(stash))
                    SvREFCNT_inc_simple_void_NN(sv_2mortal((SV *)stash));
                else stash = NULL;
            }

	    SvREFCNT_inc_simple_void_NN(sv_2mortal(sv));
	    gp_free(MUTABLE_GV(sv));
	    Newxz(gp, 1, GP);
	    GvGP_set(sv, gp_ref(gp));
#ifndef PERL_DONT_CREATE_GVSV
	    GvSV(sv) = newSV(0);
#endif
	    GvLINE(sv) = CopLINE(PL_curcop);
	    GvEGV(sv) = MUTABLE_GV(sv);
	    GvMULTI_on(sv);

            if(stash)
                mro_package_moved(NULL, stash, (const GV *)sv, 0);
            stash = NULL;
            /* undef *Foo::ISA */
            if( strEQ(GvNAME((const GV *)sv), "ISA")
             && (stash = GvSTASH((const GV *)sv))
             && (method_changed || HvENAME(stash)) )
                mro_isa_changed_in(stash);
            else if(method_changed)
                mro_method_changed_in(
                 GvSTASH((const GV *)sv)
                );

	    break;
	}
    default:
	if (SvTYPE(sv) >= SVt_PV && SvPVX_const(sv) && SvLEN(sv)) {
	    SvPV_free(sv);
	    SvPV_set(sv, NULL);
	    SvLEN_set(sv, 0);
	}
	SvOK_off(sv);
	SvSETMAGIC(sv);
    }

    SETs(&PL_sv_undef);
    return NORMAL;
}


/* common "slow" code for pp_postinc and pp_postdec */

static OP *
S_postincdec_common(pTHX_ SV *sv, SV *targ)
{
    dSP;
    const bool inc =
	PL_op->op_type == OP_POSTINC || PL_op->op_type == OP_I_POSTINC;

    if (SvROK(sv))
	TARG = sv_newmortal();
    sv_setsv(TARG, sv);
    if (inc)
	sv_inc_nomg(sv);
    else
        sv_dec_nomg(sv);
    SvSETMAGIC(sv);
    /* special case for undef: see thread at 2003-03/msg00536.html in archive */
    if (inc && !SvOK(TARG))
	sv_setiv(TARG, 0);
    SETTARG;
    return NORMAL;
}


/* also used for: pp_i_postinc() */

PP(pp_postinc)
{
    dSP; dTARGET;
    SV *sv = TOPs;

    /* special-case sv being a simple integer */
    if (LIKELY(((sv->sv_flags &
                        (SVf_THINKFIRST|SVs_GMG|SVf_IVisUV|
                         SVf_IOK|SVf_NOK|SVf_POK|SVp_NOK|SVp_POK|SVf_ROK))
                == SVf_IOK))
        && SvIVX(sv) != IV_MAX)
    {
        IV iv = SvIVX(sv);
	SvIV_set(sv,  iv + 1);
        TARGi(iv, 0); /* arg not GMG, so can't be tainted */
        SETs(TARG);
        return NORMAL;
    }

    return S_postincdec_common(aTHX_ sv, TARG);
}


/* also used for: pp_i_postdec() */

PP(pp_postdec)
{
    dSP; dTARGET;
    SV *sv = TOPs;

    /* special-case sv being a simple integer */
    if (LIKELY(((sv->sv_flags &
                        (SVf_THINKFIRST|SVs_GMG|SVf_IVisUV|
                         SVf_IOK|SVf_NOK|SVf_POK|SVp_NOK|SVp_POK|SVf_ROK))
                == SVf_IOK))
        && SvIVX(sv) != IV_MIN)
    {
        IV iv = SvIVX(sv);
	SvIV_set(sv,  iv - 1);
        TARGi(iv, 0); /* arg not GMG, so can't be tainted */
        SETs(TARG);
        return NORMAL;
    }

    return S_postincdec_common(aTHX_ sv, TARG);
}


/* Ordinary operators. */

PP(pp_pow)
{
    dSP; dATARGET; SV *svl, *svr;
#ifdef PERL_PRESERVE_IVUV
    bool is_int = 0;
#endif
    tryAMAGICbin_MG(pow_amg, AMGf_assign|AMGf_numeric);
    svr = TOPs;
    svl = TOPm1s;
#ifdef PERL_PRESERVE_IVUV
    /* For integer to integer power, we do the calculation by hand wherever
       we're sure it is safe; otherwise we call pow() and try to convert to
       integer afterwards. */
    if (SvIV_please_nomg(svr) && SvIV_please_nomg(svl)) {
		UV power;
		bool baseuok;
		UV baseuv;

		if (SvUOK(svr)) {
		    power = SvUVX(svr);
		} else {
		    const IV iv = SvIVX(svr);
		    if (iv >= 0) {
			power = iv;
		    } else {
			goto float_it; /* Can't do negative powers this way.  */
		    }
		}

		baseuok = SvUOK(svl);
		if (baseuok) {
		    baseuv = SvUVX(svl);
		} else {
		    const IV iv = SvIVX(svl);
		    if (iv >= 0) {
			baseuv = iv;
			baseuok = TRUE; /* effectively it's a UV now */
		    } else {
			baseuv = -iv; /* abs, baseuok == false records sign */
		    }
		}
                /* now we have integer ** positive integer. */
                is_int = 1;

                /* foo & (foo - 1) is zero only for a power of 2.  */
                if (!(baseuv & (baseuv - 1))) {
                    /* We are raising power-of-2 to a positive integer.
                       The logic here will work for any base (even non-integer
                       bases) but it can be less accurate than
                       pow (base,power) or exp (power * log (base)) when the
                       intermediate values start to spill out of the mantissa.
                       With powers of 2 we know this can't happen.
                       And powers of 2 are the favourite thing for perl
                       programmers to notice ** not doing what they mean. */
                    NV result = 1.0;
                    NV base = baseuok ? baseuv : -(NV)baseuv;

		    if (power & 1) {
			result *= base;
		    }
		    while (power >>= 1) {
			base *= base;
			if (power & 1) {
			    result *= base;
			}
		    }
                    SP--;
                    SETn( result );
                    SvIV_please_nomg(svr);
                    RETURN;
		} else {
		    unsigned int highbit = 8 * sizeof(UV);
		    unsigned int diff = 8 * sizeof(UV);
		    while (diff >>= 1) {
			highbit -= diff;
			if (baseuv >> highbit) {
			    highbit += diff;
			}
		    }
		    /* we now have baseuv < 2 ** highbit */
		    if (power * highbit <= 8 * sizeof(UV)) {
			/* result will definitely fit in UV, so use UV math
			   on same algorithm as above */
			UV result = 1;
			UV base = baseuv;
			const bool odd_power = cBOOL(power & 1);
			if (odd_power) {
			    result *= base;
			}
			while (power >>= 1) {
			    base *= base;
			    if (power & 1) {
				result *= base;
			    }
			}
			SP--;
			if (baseuok || !odd_power)
			    /* answer is positive */
			    SETu( result );
			else if (result <= (UV)IV_MAX)
			    /* answer negative, fits in IV */
			    SETi( -(IV)result );
			else if (result == (UV)IV_MIN) 
			    /* 2's complement assumption: special case IV_MIN */
			    SETi( IV_MIN );
			else
			    /* answer negative, doesn't fit */
			    SETn( -(NV)result );
			RETURN;
		    } 
		}
    }
  float_it:
#endif    
    {
	NV right = SvNV_nomg(svr);
	NV left  = SvNV_nomg(svl);
	(void)POPs;

#if defined(USE_LONG_DOUBLE) && defined(HAS_AIX_POWL_NEG_BASE_BUG)
    /*
    We are building perl with long double support and are on an AIX OS
    afflicted with a powl() function that wrongly returns NaNQ for any
    negative base.  This was reported to IBM as PMR #23047-379 on
    03/06/2006.  The problem exists in at least the following versions
    of AIX and the libm fileset, and no doubt others as well:

	AIX 4.3.3-ML10      bos.adt.libm 4.3.3.50
	AIX 5.1.0-ML04      bos.adt.libm 5.1.0.29
	AIX 5.2.0           bos.adt.libm 5.2.0.85

    So, until IBM fixes powl(), we provide the following workaround to
    handle the problem ourselves.  Our logic is as follows: for
    negative bases (left), we use fmod(right, 2) to check if the
    exponent is an odd or even integer:

	- if odd,  powl(left, right) == -powl(-left, right)
	- if even, powl(left, right) ==  powl(-left, right)

    If the exponent is not an integer, the result is rightly NaNQ, so
    we just return that (as NV_NAN).
    */

	if (left < 0.0) {
	    NV mod2 = Perl_fmod( right, 2.0 );
	    if (mod2 == 1.0 || mod2 == -1.0) {	/* odd integer */
		SETn( -Perl_pow( -left, right) );
	    } else if (mod2 == 0.0) {		/* even integer */
		SETn( Perl_pow( -left, right) );
	    } else {				/* fractional power */
		SETn( NV_NAN );
	    }
	} else {
	    SETn( Perl_pow( left, right) );
	}
#else
	SETn( Perl_pow( left, right) );
#endif  /* HAS_AIX_POWL_NEG_BASE_BUG */

#ifdef PERL_PRESERVE_IVUV
	if (is_int)
	    SvIV_please_nomg(svr);
#endif
	RETURN;
    }
}

PP(pp_multiply)
{
    dSP; dATARGET; SV *svl, *svr;
    tryAMAGICbin_MG(mult_amg, AMGf_assign|AMGf_numeric);
    svr = TOPs;
    svl = TOPm1s;

#ifdef PERL_PRESERVE_IVUV

    /* special-case some simple common cases */
    if (!((svl->sv_flags|svr->sv_flags) & (SVf_IVisUV|SVs_GMG))) {
        IV il, ir;
        U32 flags = (svl->sv_flags & svr->sv_flags);
        if (flags & SVf_IOK) {
            /* both args are simple IVs */
            UV topl, topr;
            il = SvIVX(svl);
            ir = SvIVX(svr);
          do_iv:
            topl = ((UV)il) >> (UVSIZE * 4 - 1);
            topr = ((UV)ir) >> (UVSIZE * 4 - 1);

            /* if both are in a range that can't under/overflow, do a
             * simple integer multiply: if the top halves(*) of both numbers
             * are 00...00  or 11...11, then it's safe.
             * (*) for 32-bits, the "top half" is the top 17 bits,
             *     for 64-bits, its 33 bits */
            if (!(
                      ((topl+1) | (topr+1))
                    & ( (((UV)1) << (UVSIZE * 4 + 1)) - 2) /* 11..110 */
            )) {
                SP--;
                TARGi(il * ir, 0); /* args not GMG, so can't be tainted */
                SETs(TARG);
                RETURN;
            }
            goto generic;
        }
        else if (flags & SVf_NOK) {
            /* both args are NVs */
            NV nl = SvNVX(svl);
            NV nr = SvNVX(svr);
            NV result;

            if (
#if defined(NAN_COMPARE_BROKEN) && defined(Perl_isnan)
                !Perl_isnan(nl) && nl == (NV)(il = (IV)nl)
                && !Perl_isnan(nr) && nr == (NV)(ir = (IV)nr)
#else
                nl == (NV)(il = (IV)nl) && nr == (NV)(ir = (IV)nr)
#endif
                )
                /* nothing was lost by converting to IVs */
                goto do_iv;
            SP--;
            result = nl * nr;
#  if defined(__sgi) && defined(USE_LONG_DOUBLE) && LONG_DOUBLEKIND == LONG_DOUBLE_IS_DOUBLEDOUBLE_128_BIT_BE_BE && NVSIZE == 16
            if (Perl_isinf(result)) {
                Zero((U8*)&result + 8, 8, U8);
            }
#  endif
            TARGn(result, 0); /* args not GMG, so can't be tainted */
            SETs(TARG);
            RETURN;
        }
    }

  generic:

    if (SvIV_please_nomg(svr)) {
	/* Unless the left argument is integer in range we are going to have to
	   use NV maths. Hence only attempt to coerce the right argument if
	   we know the left is integer.  */
	/* Left operand is defined, so is it IV? */
	if (SvIV_please_nomg(svl)) {
	    bool auvok = SvUOK(svl);
	    bool buvok = SvUOK(svr);
	    const UV topmask = (~ (UV)0) << (4 * sizeof (UV));
	    const UV botmask = ~((~ (UV)0) << (4 * sizeof (UV)));
	    UV alow;
	    UV ahigh;
	    UV blow;
	    UV bhigh;

	    if (auvok) {
		alow = SvUVX(svl);
	    } else {
		const IV aiv = SvIVX(svl);
		if (aiv >= 0) {
		    alow = aiv;
		    auvok = TRUE; /* effectively it's a UV now */
		} else {
                    /* abs, auvok == false records sign */
		    alow = (aiv == IV_MIN) ? (UV)aiv : (UV)(-aiv);
		}
	    }
	    if (buvok) {
		blow = SvUVX(svr);
	    } else {
		const IV biv = SvIVX(svr);
		if (biv >= 0) {
		    blow = biv;
		    buvok = TRUE; /* effectively it's a UV now */
		} else {
                    /* abs, buvok == false records sign */
		    blow = (biv == IV_MIN) ? (UV)biv : (UV)(-biv);
		}
	    }

	    /* If this does sign extension on unsigned it's time for plan B  */
	    ahigh = alow >> (4 * sizeof (UV));
	    alow &= botmask;
	    bhigh = blow >> (4 * sizeof (UV));
	    blow &= botmask;
	    if (ahigh && bhigh) {
		NOOP;
		/* eg 32 bit is at least 0x10000 * 0x10000 == 0x100000000
		   which is overflow. Drop to NVs below.  */
	    } else if (!ahigh && !bhigh) {
		/* eg 32 bit is at most 0xFFFF * 0xFFFF == 0xFFFE0001
		   so the unsigned multiply cannot overflow.  */
		const UV product = alow * blow;
		if (auvok == buvok) {
		    /* -ve * -ve or +ve * +ve gives a +ve result.  */
		    SP--;
		    SETu( product );
		    RETURN;
		} else if (product <= (UV)IV_MIN) {
		    /* 2s complement assumption that (UV)-IV_MIN is correct.  */
		    /* -ve result, which could overflow an IV  */
		    SP--;
                    /* can't negate IV_MIN, but there are aren't two
                     * integers such that !ahigh && !bhigh, where the
                     * product equals 0x800....000 */
                    assert(product != (UV)IV_MIN);
		    SETi( -(IV)product );
		    RETURN;
		} /* else drop to NVs below. */
	    } else {
		/* One operand is large, 1 small */
		UV product_middle;
		if (bhigh) {
		    /* swap the operands */
		    ahigh = bhigh;
		    bhigh = blow; /* bhigh now the temp var for the swap */
		    blow = alow;
		    alow = bhigh;
		}
		/* now, ((ahigh * blow) << half_UV_len) + (alow * blow)
		   multiplies can't overflow. shift can, add can, -ve can.  */
		product_middle = ahigh * blow;
		if (!(product_middle & topmask)) {
		    /* OK, (ahigh * blow) won't lose bits when we shift it.  */
		    UV product_low;
		    product_middle <<= (4 * sizeof (UV));
		    product_low = alow * blow;

		    /* as for pp_add, UV + something mustn't get smaller.
		       IIRC ANSI mandates this wrapping *behaviour* for
		       unsigned whatever the actual representation*/
		    product_low += product_middle;
		    if (product_low >= product_middle) {
			/* didn't overflow */
			if (auvok == buvok) {
			    /* -ve * -ve or +ve * +ve gives a +ve result.  */
			    SP--;
			    SETu( product_low );
			    RETURN;
			} else if (product_low <= (UV)IV_MIN) {
			    /* 2s complement assumption again  */
			    /* -ve result, which could overflow an IV  */
			    SP--;
			    SETi(product_low == (UV)IV_MIN
                                    ? IV_MIN : -(IV)product_low);
			    RETURN;
			} /* else drop to NVs below. */
		    }
		} /* product_middle too large */
	    } /* ahigh && bhigh */
	} /* SvIOK(svl) */
    } /* SvIOK(svr) */
#endif
    {
      NV right = SvNV_nomg(svr);
      NV left  = SvNV_nomg(svl);
      NV result = left * right;

      (void)POPs;
#if defined(__sgi) && defined(USE_LONG_DOUBLE) && LONG_DOUBLEKIND == LONG_DOUBLE_IS_DOUBLEDOUBLE_128_BIT_BE_BE && NVSIZE == 16
      if (Perl_isinf(result)) {
          Zero((U8*)&result + 8, 8, U8);
      }
#endif
      SETn(result);
      RETURN;
    }
}

PP(pp_divide)
{
    dSP; dATARGET; SV *svl, *svr;
    tryAMAGICbin_MG(div_amg, AMGf_assign|AMGf_numeric);
    svr = TOPs;
    svl = TOPm1s;
    /* Only try to do UV divide first
       if ((SLOPPYDIVIDE is true) or
           (PERL_PRESERVE_IVUV is true and one or both SV is a UV too large
            to preserve))
       The assumption is that it is better to use floating point divide
       whenever possible, only doing integer divide first if we can't be sure.
       If NV_PRESERVES_UV is true then we know at compile time that no UV
       can be too large to preserve, so don't need to compile the code to
       test the size of UVs.  */

#ifdef SLOPPYDIVIDE
#  define PERL_TRY_UV_DIVIDE
    /* ensure that 20./5. == 4. */
#else
#  ifdef PERL_PRESERVE_IVUV
#    ifndef NV_PRESERVES_UV
#      define PERL_TRY_UV_DIVIDE
#    endif
#  endif
#endif

#ifdef PERL_TRY_UV_DIVIDE
    if (SvIV_please_nomg(svr) && SvIV_please_nomg(svl)) {
            bool left_non_neg = SvUOK(svl);
            bool right_non_neg = SvUOK(svr);
            UV left;
            UV right;

            if (right_non_neg) {
                right = SvUVX(svr);
            }
	    else {
		const IV biv = SvIVX(svr);
                if (biv >= 0) {
                    right = biv;
                    right_non_neg = TRUE; /* effectively it's a UV now */
                }
		else {
                    right = (biv == IV_MIN) ? (UV)biv : (UV)(-biv);
                }
            }
            /* historically undef()/0 gives a "Use of uninitialized value"
               warning before dieing, hence this test goes here.
               If it were immediately before the second SvIV_please, then
               DIE() would be invoked before left was even inspected, so
               no inspection would give no warning.  */
            if (right == 0)
                DIE(aTHX_ "Illegal division by zero");

            if (left_non_neg) {
                left = SvUVX(svl);
            }
	    else {
		const IV aiv = SvIVX(svl);
                if (aiv >= 0) {
                    left = aiv;
                    left_non_neg = TRUE; /* effectively it's a UV now */
                }
		else {
                    left = (aiv == IV_MIN) ? (UV)aiv : (UV)(-aiv);
                }
            }

            if (left >= right
#ifdef SLOPPYDIVIDE
                /* For sloppy divide we always attempt integer division.  */
#else
                /* Otherwise we only attempt it if either or both operands
                   would not be preserved by an NV.  If both fit in NVs
                   we fall through to the NV divide code below.  However,
                   as left >= right to ensure integer result here, we know that
                   we can skip the test on the right operand - right big
                   enough not to be preserved can't get here unless left is
                   also too big.  */

                && (left > ((UV)1 << NV_PRESERVES_UV_BITS))
#endif
                ) {
                /* Integer division can't overflow, but it can be imprecise.  */
		const UV result = left / right;
                if (result * right == left) {
                    SP--; /* result is valid */
                    if (left_non_neg == right_non_neg) {
                        /* signs identical, result is positive.  */
                        SETu( result );
                        RETURN;
                    }
                    /* 2s complement assumption */
                    if (result <= (UV)IV_MIN)
                        SETi(result == (UV)IV_MIN ? IV_MIN : -(IV)result);
                    else {
                        /* It's exact but too negative for IV. */
                        SETn( -(NV)result );
                    }
                    RETURN;
                } /* tried integer divide but it was not an integer result */
            } /* else (PERL_ABS(result) < 1.0) or (both UVs in range for NV) */
    } /* one operand wasn't SvIOK */
#endif /* PERL_TRY_UV_DIVIDE */
    {
	NV right = SvNV_nomg(svr);
	NV left  = SvNV_nomg(svl);
	(void)POPs;(void)POPs;
#if defined(NAN_COMPARE_BROKEN) && defined(Perl_isnan)
	if (! Perl_isnan(right) && right == 0.0)
#else
	if (right == 0.0)
#endif
	    DIE(aTHX_ "Illegal division by zero");
	PUSHn( left / right );
	RETURN;
    }
}

PP(pp_modulo)
{
    dSP; dATARGET;
    tryAMAGICbin_MG(modulo_amg, AMGf_assign|AMGf_numeric);
    {
	UV left  = 0;
	UV right = 0;
	bool left_neg = FALSE;
	bool right_neg = FALSE;
	bool use_double = FALSE;
	bool dright_valid = FALSE;
	NV dright = 0.0;
	NV dleft  = 0.0;
	SV * const svr = TOPs;
	SV * const svl = TOPm1s;
        if (SvIV_please_nomg(svr)) {
            right_neg = !SvUOK(svr);
            if (!right_neg) {
                right = SvUVX(svr);
            } else {
		const IV biv = SvIVX(svr);
                if (biv >= 0) {
                    right = biv;
                    right_neg = FALSE; /* effectively it's a UV now */
                } else {
                    right = (biv == IV_MIN) ? (UV)biv : (UV)(-biv);
                }
            }
        }
        else {
	    dright = SvNV_nomg(svr);
	    right_neg = dright < 0;
	    if (right_neg)
		dright = -dright;
            if (dright < UV_MAX_P1) {
                right = U_V(dright);
                dright_valid = TRUE; /* In case we need to use double below.  */
            } else {
                use_double = TRUE;
            }
	}

        /* At this point use_double is only true if right is out of range for
           a UV.  In range NV has been rounded down to nearest UV and
           use_double false.  */
	if (!use_double && SvIV_please_nomg(svl)) {
                left_neg = !SvUOK(svl);
                if (!left_neg) {
                    left = SvUVX(svl);
                } else {
		    const IV aiv = SvIVX(svl);
                    if (aiv >= 0) {
                        left = aiv;
                        left_neg = FALSE; /* effectively it's a UV now */
                    } else {
                        left = (aiv == IV_MIN) ? (UV)aiv : (UV)(-aiv);
                    }
                }
        }
	else {
	    dleft = SvNV_nomg(svl);
	    left_neg = dleft < 0;
	    if (left_neg)
		dleft = -dleft;

            /* This should be exactly the 5.6 behaviour - if left and right are
               both in range for UV then use U_V() rather than floor.  */
	    if (!use_double) {
                if (dleft < UV_MAX_P1) {
                    /* right was in range, so is dleft, so use UVs not double.
                     */
                    left = U_V(dleft);
                }
                /* left is out of range for UV, right was in range, so promote
                   right (back) to double.  */
                else {
                    /* The +0.5 is used in 5.6 even though it is not strictly
                       consistent with the implicit +0 floor in the U_V()
                       inside the #if 1. */
                    dleft = Perl_floor(dleft + 0.5);
                    use_double = TRUE;
                    if (dright_valid)
                        dright = Perl_floor(dright + 0.5);
                    else
                        dright = right;
                }
            }
        }
	sp -= 2;
	if (use_double) {
	    NV dans;

	    if (!dright)
		DIE(aTHX_ "Illegal modulus zero");

	    dans = Perl_fmod(dleft, dright);
	    if ((left_neg != right_neg) && dans)
		dans = dright - dans;
	    if (right_neg)
		dans = -dans;
	    sv_setnv(TARG, dans);
	}
	else {
	    UV ans;

	    if (!right)
		DIE(aTHX_ "Illegal modulus zero");

	    ans = left % right;
	    if ((left_neg != right_neg) && ans)
		ans = right - ans;
	    if (right_neg) {
		/* XXX may warn: unary minus operator applied to unsigned type */
		/* could change -foo to be (~foo)+1 instead	*/
		if (ans <= ~((UV)IV_MAX)+1)
		    sv_setiv(TARG, ~ans+1);
		else
		    sv_setnv(TARG, -(NV)ans);
	    }
	    else
		sv_setuv(TARG, ans);
	}
	PUSHTARG;
	RETURN;
    }
}

PP(pp_repeat)
{
    dSP; dATARGET;
    IV count;
    SV *sv;
    bool infnan = FALSE;

    if (GIMME_V == G_ARRAY && PL_op->op_private & OPpREPEAT_DOLIST) {
	/* TODO: think of some way of doing list-repeat overloading ??? */
	sv = POPs;
	SvGETMAGIC(sv);
    }
    else {
	if (UNLIKELY(PL_op->op_private & OPpREPEAT_DOLIST)) {
	    /* The parser saw this as a list repeat, and there
	       are probably several items on the stack. But we're
	       in scalar/void context, and there's no pp_list to save us
	       now. So drop the rest of the items -- robin@@kitsite.com
	     */
	    dMARK;
	    if (MARK + 1 < SP) {
		MARK[1] = TOPm1s;
		MARK[2] = TOPs;
	    }
	    else {
		dTOPss;
		ASSUME(MARK + 1 == SP);
		XPUSHs(sv);
		MARK[1] = &PL_sv_undef;
	    }
	    SP = MARK + 2;
	}
	tryAMAGICbin_MG(repeat_amg, AMGf_assign);
	sv = POPs;
    }

    if (SvIOKp(sv)) {
	 if (SvUOK(sv)) {
	      const UV uv = SvUV_nomg(sv);
	      if (uv > IV_MAX)
		   count = IV_MAX; /* The best we can do? */
	      else
		   count = uv;
	 } else {
	      count = SvIV_nomg(sv);
	 }
    }
    else if (SvNOKp(sv)) {
        const NV nv = SvNV_nomg(sv);
        infnan = Perl_isinfnan(nv);
        if (UNLIKELY(infnan)) {
            count = 0;
        } else {
            if (nv < 0.0)
                count = -1;   /* An arbitrary negative integer */
            else
                count = (IV)nv;
        }
    }
    else
	count = SvIV_nomg(sv);

    if (infnan) {
        Perl_ck_warner(aTHX_ packWARN(WARN_NUMERIC),
                       "Non-finite repeat count does nothing");
    } else if (count < 0) {
        count = 0;
        Perl_ck_warner(aTHX_ packWARN(WARN_NUMERIC),
                       "Negative repeat count does nothing");
    }

    if (GIMME_V == G_ARRAY && PL_op->op_private & OPpREPEAT_DOLIST) {
	dMARK;
	const SSize_t items = SP - MARK;
	const U8 mod = PL_op->op_flags & OPf_MOD;

	if (count > 1) {
	    SSize_t max;

            if (  items > SSize_t_MAX / count   /* max would overflow */
                                                /* repeatcpy would overflow */
               || items > I32_MAX / (I32)sizeof(SV *)
            )
               Perl_croak(aTHX_ "%s","Out of memory during list extend");
            max = items * count;
            MEXTEND(MARK, max);

	    while (SP > MARK) {
                if (*SP) {
                   if (mod && SvPADTMP(*SP)) {
                       *SP = sv_mortalcopy(*SP);
                   }
		   SvTEMP_off((*SP));
		}
		SP--;
	    }
	    MARK++;
	    repeatcpy((char*)(MARK + items), (char*)MARK,
		items * sizeof(const SV *), count - 1);
	    SP += max;
	}
	else if (count <= 0)
	    SP = MARK;
    }
    else {	/* Note: mark already snarfed by pp_list */
	SV * const tmpstr = POPs;
	STRLEN len;
	bool isutf;

	if (TARG != tmpstr)
	    sv_setsv_nomg(TARG, tmpstr);
	SvPV_force_nomg(TARG, len);
	isutf = DO_UTF8(TARG);
	if (count != 1) {
	    if (count < 1)
		SvCUR_set(TARG, 0);
	    else {
		STRLEN max;

		if (   len > (MEM_SIZE_MAX-1) / (UV)count /* max would overflow */
		    || len > (U32)I32_MAX  /* repeatcpy would overflow */
                )
		     Perl_croak(aTHX_ "%s",
                                        "Out of memory during string extend");
		max = (UV)count * len + 1;
		SvGROW(TARG, max);

		repeatcpy(SvPVX(TARG) + len, SvPVX(TARG), len, count - 1);
		SvCUR_set(TARG, SvCUR(TARG) * count);
	    }
	    *SvEND(TARG) = '\0';
	}
	if (isutf)
	    (void)SvPOK_only_UTF8(TARG);
	else
	    (void)SvPOK_only(TARG);

	PUSHTARG;
    }
    RETURN;
}

PP(pp_subtract)
{
    dSP; dATARGET; bool useleft; SV *svl, *svr;
    tryAMAGICbin_MG(subtr_amg, AMGf_assign|AMGf_numeric);
    svr = TOPs;
    svl = TOPm1s;

#ifdef PERL_PRESERVE_IVUV

    /* special-case some simple common cases */
    if (!((svl->sv_flags|svr->sv_flags) & (SVf_IVisUV|SVs_GMG))) {
        IV il, ir;
        U32 flags = (svl->sv_flags & svr->sv_flags);
        if (flags & SVf_IOK) {
            /* both args are simple IVs */
            UV topl, topr;
            il = SvIVX(svl);
            ir = SvIVX(svr);
          do_iv:
            topl = ((UV)il) >> (UVSIZE * 8 - 2);
            topr = ((UV)ir) >> (UVSIZE * 8 - 2);

            /* if both are in a range that can't under/overflow, do a
             * simple integer subtract: if the top of both numbers
             * are 00  or 11, then it's safe */
            if (!( ((topl+1) | (topr+1)) & 2)) {
                SP--;
                TARGi(il - ir, 0); /* args not GMG, so can't be tainted */
                SETs(TARG);
                RETURN;
            }
            goto generic;
        }
        else if (flags & SVf_NOK) {
            /* both args are NVs */
            NV nl = SvNVX(svl);
            NV nr = SvNVX(svr);

            if (
#if defined(NAN_COMPARE_BROKEN) && defined(Perl_isnan)
                !Perl_isnan(nl) && nl == (NV)(il = (IV)nl)
                && !Perl_isnan(nr) && nr == (NV)(ir = (IV)nr)
#else
                nl == (NV)(il = (IV)nl) && nr == (NV)(ir = (IV)nr)
#endif
                )
                /* nothing was lost by converting to IVs */
                goto do_iv;
            SP--;
            TARGn(nl - nr, 0); /* args not GMG, so can't be tainted */
            SETs(TARG);
            RETURN;
        }
    }

  generic:

    useleft = USE_LEFT(svl);
    /* See comments in pp_add (in pp_hot.c) about Overflow, and how
       "bad things" happen if you rely on signed integers wrapping.  */
    if (SvIV_please_nomg(svr)) {
	/* Unless the left argument is integer in range we are going to have to
	   use NV maths. Hence only attempt to coerce the right argument if
	   we know the left is integer.  */
	UV auv = 0;
	bool auvok = FALSE;
	bool a_valid = 0;

	if (!useleft) {
	    auv = 0;
	    a_valid = auvok = 1;
	    /* left operand is undef, treat as zero.  */
	} else {
	    /* Left operand is defined, so is it IV? */
	    if (SvIV_please_nomg(svl)) {
		if ((auvok = SvUOK(svl)))
		    auv = SvUVX(svl);
		else {
		    const IV aiv = SvIVX(svl);
		    if (aiv >= 0) {
			auv = aiv;
			auvok = 1;	/* Now acting as a sign flag.  */
		    } else { /* 2s complement assumption for IV_MIN */
			auv = (aiv == IV_MIN) ? (UV)aiv : (UV)-aiv;
		    }
		}
		a_valid = 1;
	    }
	}
	if (a_valid) {
	    bool result_good = 0;
	    UV result;
	    UV buv;
	    bool buvok = SvUOK(svr);
	
	    if (buvok)
		buv = SvUVX(svr);
	    else {
		const IV biv = SvIVX(svr);
		if (biv >= 0) {
		    buv = biv;
		    buvok = 1;
		} else
                    buv = (biv == IV_MIN) ? (UV)biv : (UV)-biv;
	    }
	    /* ?uvok if value is >= 0. basically, flagged as UV if it's +ve,
	       else "IV" now, independent of how it came in.
	       if a, b represents positive, A, B negative, a maps to -A etc
	       a - b =>  (a - b)
	       A - b => -(a + b)
	       a - B =>  (a + b)
	       A - B => -(a - b)
	       all UV maths. negate result if A negative.
	       subtract if signs same, add if signs differ. */

	    if (auvok ^ buvok) {
		/* Signs differ.  */
		result = auv + buv;
		if (result >= auv)
		    result_good = 1;
	    } else {
		/* Signs same */
		if (auv >= buv) {
		    result = auv - buv;
		    /* Must get smaller */
		    if (result <= auv)
			result_good = 1;
		} else {
		    result = buv - auv;
		    if (result <= buv) {
			/* result really should be -(auv-buv). as its negation
			   of true value, need to swap our result flag  */
			auvok = !auvok;
			result_good = 1;
		    }
		}
	    }
	    if (result_good) {
		SP--;
		if (auvok)
		    SETu( result );
		else {
		    /* Negate result */
		    if (result <= (UV)IV_MIN)
                        SETi(result == (UV)IV_MIN
                                ? IV_MIN : -(IV)result);
		    else {
			/* result valid, but out of range for IV.  */
			SETn( -(NV)result );
		    }
		}
		RETURN;
	    } /* Overflow, drop through to NVs.  */
	}
    }
#else
    useleft = USE_LEFT(svl);
#endif
    {
	NV value = SvNV_nomg(svr);
	(void)POPs;

	if (!useleft) {
	    /* left operand is undef, treat as zero - value */
	    SETn(-value);
	    RETURN;
	}
	SETn( SvNV_nomg(svl) - value );
	RETURN;
    }
}

#define IV_BITS (IVSIZE * 8)

static UV S_uv_shift(UV uv, int shift, bool left)
{
   if (shift < 0) {
       shift = -shift;
       left = !left;
   }
   if (shift >= IV_BITS) {
       return 0;
   }
   return left ? uv << shift : uv >> shift;
}

static IV S_iv_shift(IV iv, int shift, bool left)
{
   if (shift < 0) {
       shift = -shift;
       left = !left;
   }
   if (shift >= IV_BITS) {
       return iv < 0 && !left ? -1 : 0;
   }
   return left ? iv << shift : iv >> shift;
}

#define UV_LEFT_SHIFT(uv, shift) S_uv_shift(uv, shift, TRUE)
#define UV_RIGHT_SHIFT(uv, shift) S_uv_shift(uv, shift, FALSE)
#define IV_LEFT_SHIFT(iv, shift) S_iv_shift(iv, shift, TRUE)
#define IV_RIGHT_SHIFT(iv, shift) S_iv_shift(iv, shift, FALSE)

PP(pp_left_shift)
{
    dSP; dATARGET; SV *svl, *svr;
    tryAMAGICbin_MG(lshift_amg, AMGf_assign|AMGf_numeric);
    svr = POPs;
    svl = TOPs;
    {
      const IV shift = SvIV_nomg(svr);
      if (PL_op->op_private & HINT_INTEGER) {
          SETi(IV_LEFT_SHIFT(SvIV_nomg(svl), shift));
      }
      else {
	  SETu(UV_LEFT_SHIFT(SvUV_nomg(svl), shift));
      }
      RETURN;
    }
}

PP(pp_right_shift)
{
    dSP; dATARGET; SV *svl, *svr;
    tryAMAGICbin_MG(rshift_amg, AMGf_assign|AMGf_numeric);
    svr = POPs;
    svl = TOPs;
    {
      const IV shift = SvIV_nomg(svr);
      if (PL_op->op_private & HINT_INTEGER) {
	  SETi(IV_RIGHT_SHIFT(SvIV_nomg(svl), shift));
      }
      else {
          SETu(UV_RIGHT_SHIFT(SvUV_nomg(svl), shift));
      }
      RETURN;
    }
}

PP(pp_lt)
{
    dSP;
    SV *left, *right;

    tryAMAGICbin_MG(lt_amg, AMGf_set|AMGf_numeric);
    right = POPs;
    left  = TOPs;
    SETs(boolSV(
	(SvIOK_notUV(left) && SvIOK_notUV(right))
	? (SvIVX(left) < SvIVX(right))
	: (do_ncmp(left, right) == -1)
    ));
    RETURN;
}

PP(pp_gt)
{
    dSP;
    SV *left, *right;

    tryAMAGICbin_MG(gt_amg, AMGf_set|AMGf_numeric);
    right = POPs;
    left  = TOPs;
    SETs(boolSV(
	(SvIOK_notUV(left) && SvIOK_notUV(right))
	? (SvIVX(left) > SvIVX(right))
	: (do_ncmp(left, right) == 1)
    ));
    RETURN;
}

PP(pp_le)
{
    dSP;
    SV *left, *right;

    tryAMAGICbin_MG(le_amg, AMGf_set|AMGf_numeric);
    right = POPs;
    left  = TOPs;
    SETs(boolSV(
	(SvIOK_notUV(left) && SvIOK_notUV(right))
	? (SvIVX(left) <= SvIVX(right))
	: (do_ncmp(left, right) <= 0)
    ));
    RETURN;
}

PP(pp_ge)
{
    dSP;
    SV *left, *right;

    tryAMAGICbin_MG(ge_amg, AMGf_set|AMGf_numeric);
    right = POPs;
    left  = TOPs;
    SETs(boolSV(
	(SvIOK_notUV(left) && SvIOK_notUV(right))
	? (SvIVX(left) >= SvIVX(right))
	: ( (do_ncmp(left, right) & 2) == 0)
    ));
    RETURN;
}

PP(pp_ne)
{
    dSP;
    SV *left, *right;

    tryAMAGICbin_MG(ne_amg, AMGf_set|AMGf_numeric);
    right = POPs;
    left  = TOPs;
    SETs(boolSV(
	(SvIOK_notUV(left) && SvIOK_notUV(right))
	? (SvIVX(left) != SvIVX(right))
	: (do_ncmp(left, right) != 0)
    ));
    RETURN;
}

/* compare left and right SVs. Returns:
 * -1: <
 *  0: ==
 *  1: >
 *  2: left or right was a NaN
 */
I32
Perl_do_ncmp(pTHX_ SV* const left, SV * const right)
{
    PERL_ARGS_ASSERT_DO_NCMP;
#ifdef PERL_PRESERVE_IVUV
    /* Fortunately it seems NaN isn't IOK */
    if (SvIV_please_nomg(right) && SvIV_please_nomg(left)) {
	    if (!SvUOK(left)) {
		const IV leftiv = SvIVX(left);
		if (!SvUOK(right)) {
		    /* ## IV <=> IV ## */
		    const IV rightiv = SvIVX(right);
		    return (leftiv > rightiv) - (leftiv < rightiv);
		}
		/* ## IV <=> UV ## */
		if (leftiv < 0)
		    /* As (b) is a UV, it's >=0, so it must be < */
		    return -1;
		{
		    const UV rightuv = SvUVX(right);
		    return ((UV)leftiv > rightuv) - ((UV)leftiv < rightuv);
		}
	    }

	    if (SvUOK(right)) {
		/* ## UV <=> UV ## */
		const UV leftuv = SvUVX(left);
		const UV rightuv = SvUVX(right);
		return (leftuv > rightuv) - (leftuv < rightuv);
	    }
	    /* ## UV <=> IV ## */
	    {
		const IV rightiv = SvIVX(right);
		if (rightiv < 0)
		    /* As (a) is a UV, it's >=0, so it cannot be < */
		    return 1;
		{
		    const UV leftuv = SvUVX(left);
		    return (leftuv > (UV)rightiv) - (leftuv < (UV)rightiv);
		}
	    }
	    NOT_REACHED; /* NOTREACHED */
    }
#endif
    {
      NV const rnv = SvNV_nomg(right);
      NV const lnv = SvNV_nomg(left);

#if defined(NAN_COMPARE_BROKEN) && defined(Perl_isnan)
      if (Perl_isnan(lnv) || Perl_isnan(rnv)) {
	  return 2;
       }
      return (lnv > rnv) - (lnv < rnv);
#else
      if (lnv < rnv)
	return -1;
      if (lnv > rnv)
	return 1;
      if (lnv == rnv)
	return 0;
      return 2;
#endif
    }
}


PP(pp_ncmp)
{
    dSP;
    SV *left, *right;
    I32 value;
    tryAMAGICbin_MG(ncmp_amg, AMGf_numeric);
    right = POPs;
    left  = TOPs;
    value = do_ncmp(left, right);
    if (value == 2) {
	SETs(&PL_sv_undef);
    }
    else {
	dTARGET;
	SETi(value);
    }
    RETURN;
}


/* also used for: pp_sge() pp_sgt() pp_slt() */

PP(pp_sle)
{
    dSP;

    int amg_type = sle_amg;
    int multiplier = 1;
    int rhs = 1;

    switch (PL_op->op_type) {
    case OP_SLT:
	amg_type = slt_amg;
	/* cmp < 0 */
	rhs = 0;
	break;
    case OP_SGT:
	amg_type = sgt_amg;
	/* cmp > 0 */
	multiplier = -1;
	rhs = 0;
	break;
    case OP_SGE:
	amg_type = sge_amg;
	/* cmp >= 0 */
	multiplier = -1;
	break;
    }

    tryAMAGICbin_MG(amg_type, AMGf_set);
    {
      dPOPTOPssrl;
      const int cmp =
#ifdef USE_LOCALE_COLLATE
                      (IN_LC_RUNTIME(LC_COLLATE))
		      ? sv_cmp_locale_flags(left, right, 0)
                      :
#endif
		        sv_cmp_flags(left, right, 0);
      SETs(boolSV(cmp * multiplier < rhs));
      RETURN;
    }
}

PP(pp_seq)
{
    dSP;
    tryAMAGICbin_MG(seq_amg, AMGf_set);
    {
      dPOPTOPssrl;
      SETs(boolSV(sv_eq_flags(left, right, 0)));
      RETURN;
    }
}

PP(pp_sne)
{
    dSP;
    tryAMAGICbin_MG(sne_amg, AMGf_set);
    {
      dPOPTOPssrl;
      SETs(boolSV(!sv_eq_flags(left, right, 0)));
      RETURN;
    }
}

PP(pp_scmp)
{
    dSP; dTARGET;
    tryAMAGICbin_MG(scmp_amg, 0);
    {
      dPOPTOPssrl;
      const int cmp =
#ifdef USE_LOCALE_COLLATE
                      (IN_LC_RUNTIME(LC_COLLATE))
		      ? sv_cmp_locale_flags(left, right, 0)
		      :
#endif
                        sv_cmp_flags(left, right, 0);
      SETi( cmp );
      RETURN;
    }
}

PP(pp_bit_and)
{
    dSP; dATARGET;
    tryAMAGICbin_MG(band_amg, AMGf_assign);
    {
      dPOPTOPssrl;
      if (SvNIOKp(left) || SvNIOKp(right)) {
	const bool left_ro_nonnum  = !SvNIOKp(left) && SvREADONLY(left);
	const bool right_ro_nonnum = !SvNIOKp(right) && SvREADONLY(right);
	if (PL_op->op_private & HINT_INTEGER) {
	  const IV i = SvIV_nomg(left) & SvIV_nomg(right);
	  SETi(i);
	}
	else {
	  const UV u = SvUV_nomg(left) & SvUV_nomg(right);
	  SETu(u);
	}
	if (left_ro_nonnum && left != TARG) SvNIOK_off(left);
	if (right_ro_nonnum) SvNIOK_off(right);
      }
      else {
	do_vop(PL_op->op_type, TARG, left, right);
	SETTARG;
      }
      RETURN;
    }
}

PP(pp_nbit_and)
{
    dSP;
    tryAMAGICbin_MG(band_amg, AMGf_assign|AMGf_numarg);
    {
	dATARGET; dPOPTOPssrl;
	if (PL_op->op_private & HINT_INTEGER) {
	  const IV i = SvIV_nomg(left) & SvIV_nomg(right);
	  SETi(i);
	}
	else {
	  const UV u = SvUV_nomg(left) & SvUV_nomg(right);
	  SETu(u);
	}
    }
    RETURN;
}

PP(pp_sbit_and)
{
    dSP;
    tryAMAGICbin_MG(sband_amg, AMGf_assign);
    {
	dATARGET; dPOPTOPssrl;
	do_vop(OP_BIT_AND, TARG, left, right);
	RETSETTARG;
    }
}

/* also used for: pp_bit_xor() */

PP(pp_bit_or)
{
    dSP; dATARGET;
    const int op_type = PL_op->op_type;

    tryAMAGICbin_MG((op_type == OP_BIT_OR ? bor_amg : bxor_amg), AMGf_assign);
    {
      dPOPTOPssrl;
      if (SvNIOKp(left) || SvNIOKp(right)) {
	const bool left_ro_nonnum  = !SvNIOKp(left) && SvREADONLY(left);
	const bool right_ro_nonnum = !SvNIOKp(right) && SvREADONLY(right);
	if (PL_op->op_private & HINT_INTEGER) {
	  const IV l = (USE_LEFT(left) ? SvIV_nomg(left) : 0);
	  const IV r = SvIV_nomg(right);
	  const IV result = op_type == OP_BIT_OR ? (l | r) : (l ^ r);
	  SETi(result);
	}
	else {
	  const UV l = (USE_LEFT(left) ? SvUV_nomg(left) : 0);
	  const UV r = SvUV_nomg(right);
	  const UV result = op_type == OP_BIT_OR ? (l | r) : (l ^ r);
	  SETu(result);
	}
	if (left_ro_nonnum && left != TARG) SvNIOK_off(left);
	if (right_ro_nonnum) SvNIOK_off(right);
      }
      else {
	do_vop(op_type, TARG, left, right);
	SETTARG;
      }
      RETURN;
    }
}

/* also used for: pp_nbit_xor() */

PP(pp_nbit_or)
{
    dSP;
    const int op_type = PL_op->op_type;

    tryAMAGICbin_MG((op_type == OP_NBIT_OR ? bor_amg : bxor_amg),
		    AMGf_assign|AMGf_numarg);
    {
	dATARGET; dPOPTOPssrl;
	if (PL_op->op_private & HINT_INTEGER) {
	  const IV l = (USE_LEFT(left) ? SvIV_nomg(left) : 0);
	  const IV r = SvIV_nomg(right);
	  const IV result = op_type == OP_NBIT_OR ? (l | r) : (l ^ r);
	  SETi(result);
	}
	else {
	  const UV l = (USE_LEFT(left) ? SvUV_nomg(left) : 0);
	  const UV r = SvUV_nomg(right);
	  const UV result = op_type == OP_NBIT_OR ? (l | r) : (l ^ r);
	  SETu(result);
	}
    }
    RETURN;
}

/* also used for: pp_sbit_xor() */

PP(pp_sbit_or)
{
    dSP;
    const int op_type = PL_op->op_type;

    tryAMAGICbin_MG((op_type == OP_SBIT_OR ? sbor_amg : sbxor_amg),
		    AMGf_assign);
    {
	dATARGET; dPOPTOPssrl;
	do_vop(op_type == OP_SBIT_OR ? OP_BIT_OR : OP_BIT_XOR, TARG, left,
	       right);
	RETSETTARG;
    }
}

PERL_STATIC_INLINE bool
S_negate_string(pTHX)
{
    dTARGET; dSP;
    STRLEN len;
    const char *s;
    SV * const sv = TOPs;
    if (!SvPOKp(sv) || SvNIOK(sv) || (!SvPOK(sv) && SvNIOKp(sv)))
	return FALSE;
    s = SvPV_nomg_const(sv, len);
    if (isIDFIRST(*s)) {
	sv_setpvs(TARG, "-");
	sv_catsv(TARG, sv);
    }
    else if (*s == '+' || (*s == '-' && !looks_like_number(sv))) {
	sv_setsv_nomg(TARG, sv);
	*SvPV_force_nomg(TARG, len) = *s == '-' ? '+' : '-';
    }
    else return FALSE;
    SETTARG;
    return TRUE;
}

PP(pp_negate)
{
    dSP; dTARGET;
    tryAMAGICun_MG(neg_amg, AMGf_numeric);
    if (S_negate_string(aTHX)) return NORMAL;
    {
	SV * const sv = TOPs;

	if (SvIOK(sv)) {
	    /* It's publicly an integer */
	oops_its_an_int:
	    if (SvIsUV(sv)) {
		if (SvIVX(sv) == IV_MIN) {
		    /* 2s complement assumption. */
                    SETi(SvIVX(sv));	/* special case: -((UV)IV_MAX+1) ==
                                           IV_MIN */
                    return NORMAL;
		}
		else if (SvUVX(sv) <= IV_MAX) {
		    SETi(-SvIVX(sv));
		    return NORMAL;
		}
	    }
	    else if (SvIVX(sv) != IV_MIN) {
		SETi(-SvIVX(sv));
		return NORMAL;
	    }
#ifdef PERL_PRESERVE_IVUV
	    else {
		SETu((UV)IV_MIN);
		return NORMAL;
	    }
#endif
	}
	if (SvNIOKp(sv) && (SvNIOK(sv) || !SvPOK(sv)))
	    SETn(-SvNV_nomg(sv));
	else if (SvPOKp(sv) && SvIV_please_nomg(sv))
		  goto oops_its_an_int;
	else
	    SETn(-SvNV_nomg(sv));
    }
    return NORMAL;
}

PP(pp_not)
{
    dSP;
    tryAMAGICun_MG(not_amg, AMGf_set);
    *PL_stack_sp = boolSV(!SvTRUE_nomg(*PL_stack_sp));
    return NORMAL;
}

static void
S_scomplement(pTHX_ SV *targ, SV *sv)
{
	U8 *tmps;
	I32 anum;
	STRLEN len;

	sv_copypv_nomg(TARG, sv);
	tmps = (U8*)SvPV_nomg(TARG, len);
	anum = len;
	if (SvUTF8(TARG)) {
	  /* Calculate exact length, let's not estimate. */
	  STRLEN targlen = 0;
	  STRLEN l;
	  UV nchar = 0;
	  UV nwide = 0;
	  U8 * const send = tmps + len;
	  U8 * const origtmps = tmps;
	  const UV utf8flags = UTF8_ALLOW_ANYUV;

	  while (tmps < send) {
	    const UV c = utf8n_to_uvchr(tmps, send-tmps, &l, utf8flags);
	    tmps += l;
	    targlen += UVCHR_SKIP(~c);
	    nchar++;
	    if (c > 0xff)
		nwide++;
	  }

	  /* Now rewind strings and write them. */
	  tmps = origtmps;

	  if (nwide) {
	      U8 *result;
	      U8 *p;

              Perl_ck_warner_d(aTHX_ packWARN(WARN_DEPRECATED),
                        deprecated_above_ff_msg, PL_op_desc[PL_op->op_type]);
	      Newx(result, targlen + 1, U8);
	      p = result;
	      while (tmps < send) {
		  const UV c = utf8n_to_uvchr(tmps, send-tmps, &l, utf8flags);
		  tmps += l;
		  p = uvchr_to_utf8_flags(p, ~c, UNICODE_ALLOW_ANY);
	      }
	      *p = '\0';
	      sv_usepvn_flags(TARG, (char*)result, targlen,
			      SV_HAS_TRAILING_NUL);
	      SvUTF8_on(TARG);
	  }
	  else {
	      U8 *result;
	      U8 *p;

	      Newx(result, nchar + 1, U8);
	      p = result;
	      while (tmps < send) {
		  const U8 c = (U8)utf8n_to_uvchr(tmps, send-tmps, &l, utf8flags);
		  tmps += l;
		  *p++ = ~c;
	      }
	      *p = '\0';
	      sv_usepvn_flags(TARG, (char*)result, nchar, SV_HAS_TRAILING_NUL);
	      SvUTF8_off(TARG);
	  }
	  return;
	}
#ifdef LIBERAL
	{
	    long *tmpl;
	    for ( ; anum && (unsigned long)tmps % sizeof(long); anum--, tmps++)
		*tmps = ~*tmps;
	    tmpl = (long*)tmps;
	    for ( ; anum >= (I32)sizeof(long); anum -= (I32)sizeof(long), tmpl++)
		*tmpl = ~*tmpl;
	    tmps = (U8*)tmpl;
	}
#endif
	for ( ; anum > 0; anum--, tmps++)
	    *tmps = ~*tmps;
}

PP(pp_complement)
{
    dSP; dTARGET;
    tryAMAGICun_MG(compl_amg, AMGf_numeric);
    {
      dTOPss;
      if (SvNIOKp(sv)) {
	if (PL_op->op_private & HINT_INTEGER) {
	  const IV i = ~SvIV_nomg(sv);
	  SETi(i);
	}
	else {
	  const UV u = ~SvUV_nomg(sv);
	  SETu(u);
	}
      }
      else {
	S_scomplement(aTHX_ TARG, sv);
	SETTARG;
      }
      return NORMAL;
    }
}

PP(pp_ncomplement)
{
    dSP;
    tryAMAGICun_MG(compl_amg, AMGf_numeric|AMGf_numarg);
    {
	dTARGET; dTOPss;
	if (PL_op->op_private & HINT_INTEGER) {
	  const IV i = ~SvIV_nomg(sv);
	  SETi(i);
	}
	else {
	  const UV u = ~SvUV_nomg(sv);
	  SETu(u);
	}
    }
    return NORMAL;
}

PP(pp_scomplement)
{
    dSP;
    tryAMAGICun_MG(scompl_amg, AMGf_numeric);
    {
	dTARGET; dTOPss;
	S_scomplement(aTHX_ TARG, sv);
	SETTARG;
	return NORMAL;
    }
}

/* integer versions of some of the above */

PP(pp_i_multiply)
{
    dSP; dATARGET;
    tryAMAGICbin_MG(mult_amg, AMGf_assign);
    {
      dPOPTOPiirl_nomg;
      SETi( left * right );
      RETURN;
    }
}

PP(pp_i_divide)
{
    IV num;
    dSP; dATARGET;
    tryAMAGICbin_MG(div_amg, AMGf_assign);
    {
      dPOPTOPssrl;
      IV value = SvIV_nomg(right);
      if (value == 0)
	  DIE(aTHX_ "Illegal division by zero");
      num = SvIV_nomg(left);

      /* avoid FPE_INTOVF on some platforms when num is IV_MIN */
      if (value == -1)
          value = - num;
      else
          value = num / value;
      SETi(value);
      RETURN;
    }
}

#if defined(__GLIBC__) && IVSIZE == 8 && !defined(PERL_DEBUG_READONLY_OPS) \
    && ( __GLIBC__ < 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ < 8))
STATIC
PP(pp_i_modulo_0)
#else
PP(pp_i_modulo)
#endif
{
     /* This is the vanilla old i_modulo. */
     dSP; dATARGET;
     tryAMAGICbin_MG(modulo_amg, AMGf_assign);
     {
	  dPOPTOPiirl_nomg;
	  if (!right)
	       DIE(aTHX_ "Illegal modulus zero");
	  /* avoid FPE_INTOVF on some platforms when left is IV_MIN */
	  if (right == -1)
	      SETi( 0 );
	  else
	      SETi( left % right );
	  RETURN;
     }
}

#if defined(__GLIBC__) && IVSIZE == 8 && !defined(PERL_DEBUG_READONLY_OPS) \
    && ( __GLIBC__ < 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ < 8))
STATIC
PP(pp_i_modulo_1)

{
     /* This is the i_modulo with the workaround for the _moddi3 bug
      * in (at least) glibc 2.2.5 (the PERL_ABS() the workaround).
      * See below for pp_i_modulo. */
     dSP; dATARGET;
     tryAMAGICbin_MG(modulo_amg, AMGf_assign);
     {
	  dPOPTOPiirl_nomg;
	  if (!right)
	       DIE(aTHX_ "Illegal modulus zero");
	  /* avoid FPE_INTOVF on some platforms when left is IV_MIN */
	  if (right == -1)
	      SETi( 0 );
	  else
	      SETi( left % PERL_ABS(right) );
	  RETURN;
     }
}

PP(pp_i_modulo)
{
     dVAR; dSP; dATARGET;
     tryAMAGICbin_MG(modulo_amg, AMGf_assign);
     {
	  dPOPTOPiirl_nomg;
	  if (!right)
	       DIE(aTHX_ "Illegal modulus zero");
	  /* The assumption is to use hereafter the old vanilla version... */
	  PL_op->op_ppaddr =
	       PL_ppaddr[OP_I_MODULO] =
	           Perl_pp_i_modulo_0;
	  /* .. but if we have glibc, we might have a buggy _moddi3
	   * (at least glibc 2.2.5 is known to have this bug), in other
	   * words our integer modulus with negative quad as the second
	   * argument might be broken.  Test for this and re-patch the
	   * opcode dispatch table if that is the case, remembering to
	   * also apply the workaround so that this first round works
	   * right, too.  See [perl #9402] for more information. */
	  {
	       IV l =   3;
	       IV r = -10;
	       /* Cannot do this check with inlined IV constants since
		* that seems to work correctly even with the buggy glibc. */
	       if (l % r == -3) {
		    /* Yikes, we have the bug.
		     * Patch in the workaround version. */
		    PL_op->op_ppaddr =
			 PL_ppaddr[OP_I_MODULO] =
			     &Perl_pp_i_modulo_1;
		    /* Make certain we work right this time, too. */
		    right = PERL_ABS(right);
	       }
	  }
	  /* avoid FPE_INTOVF on some platforms when left is IV_MIN */
	  if (right == -1)
	      SETi( 0 );
	  else
	      SETi( left % right );
	  RETURN;
     }
}
#endif

PP(pp_i_add)
{
    dSP; dATARGET;
    tryAMAGICbin_MG(add_amg, AMGf_assign);
    {
      dPOPTOPiirl_ul_nomg;
      SETi( left + right );
      RETURN;
    }
}

PP(pp_i_subtract)
{
    dSP; dATARGET;
    tryAMAGICbin_MG(subtr_amg, AMGf_assign);
    {
      dPOPTOPiirl_ul_nomg;
      SETi( left - right );
      RETURN;
    }
}

PP(pp_i_lt)
{
    dSP;
    tryAMAGICbin_MG(lt_amg, AMGf_set);
    {
      dPOPTOPiirl_nomg;
      SETs(boolSV(left < right));
      RETURN;
    }
}

PP(pp_i_gt)
{
    dSP;
    tryAMAGICbin_MG(gt_amg, AMGf_set);
    {
      dPOPTOPiirl_nomg;
      SETs(boolSV(left > right));
      RETURN;
    }
}

PP(pp_i_le)
{
    dSP;
    tryAMAGICbin_MG(le_amg, AMGf_set);
    {
      dPOPTOPiirl_nomg;
      SETs(boolSV(left <= right));
      RETURN;
    }
}

PP(pp_i_ge)
{
    dSP;
    tryAMAGICbin_MG(ge_amg, AMGf_set);
    {
      dPOPTOPiirl_nomg;
      SETs(boolSV(left >= right));
      RETURN;
    }
}

PP(pp_i_eq)
{
    dSP;
    tryAMAGICbin_MG(eq_amg, AMGf_set);
    {
      dPOPTOPiirl_nomg;
      SETs(boolSV(left == right));
      RETURN;
    }
}

PP(pp_i_ne)
{
    dSP;
    tryAMAGICbin_MG(ne_amg, AMGf_set);
    {
      dPOPTOPiirl_nomg;
      SETs(boolSV(left != right));
      RETURN;
    }
}

PP(pp_i_ncmp)
{
    dSP; dTARGET;
    tryAMAGICbin_MG(ncmp_amg, 0);
    {
      dPOPTOPiirl_nomg;
      I32 value;

      if (left > right)
	value = 1;
      else if (left < right)
	value = -1;
      else
	value = 0;
      SETi(value);
      RETURN;
    }
}

PP(pp_i_negate)
{
    dSP; dTARGET;
    tryAMAGICun_MG(neg_amg, 0);
    if (S_negate_string(aTHX)) return NORMAL;
    {
	SV * const sv = TOPs;
	IV const i = SvIV_nomg(sv);
	SETi(-i);
	return NORMAL;
    }
}

/* High falutin' math. */

PP(pp_atan2)
{
    dSP; dTARGET;
    tryAMAGICbin_MG(atan2_amg, 0);
    {
      dPOPTOPnnrl_nomg;
      SETn(Perl_atan2(left, right));
      RETURN;
    }
}


/* also used for: pp_cos() pp_exp() pp_log() pp_sqrt() */

PP(pp_sin)
{
    dSP; dTARGET;
    int amg_type = fallback_amg;
    const char *neg_report = NULL;
    const int op_type = PL_op->op_type;

    switch (op_type) {
    case OP_SIN:  amg_type = sin_amg; break;
    case OP_COS:  amg_type = cos_amg; break;
    case OP_EXP:  amg_type = exp_amg; break;
    case OP_LOG:  amg_type = log_amg;  neg_report = "log";  break;
    case OP_SQRT: amg_type = sqrt_amg; neg_report = "sqrt"; break;
    }

    assert(amg_type != fallback_amg);

    tryAMAGICun_MG(amg_type, 0);
    {
      SV * const arg = TOPs;
      const NV value = SvNV_nomg(arg);
      NV result = NV_NAN;
      if (neg_report) { /* log or sqrt */
	  if (
#if defined(NAN_COMPARE_BROKEN) && defined(Perl_isnan)
	      ! Perl_isnan(value) &&
#endif
	      (op_type == OP_LOG ? (value <= 0.0) : (value < 0.0))) {
	      SET_NUMERIC_STANDARD();
	      /* diag_listed_as: Can't take log of %g */
	      DIE(aTHX_ "Can't take %s of %"NVgf, neg_report, value);
	  }
      }
      switch (op_type) {
      default:
      case OP_SIN:  result = Perl_sin(value);  break;
      case OP_COS:  result = Perl_cos(value);  break;
      case OP_EXP:  result = Perl_exp(value);  break;
      case OP_LOG:  result = Perl_log(value);  break;
      case OP_SQRT: result = Perl_sqrt(value); break;
      }
      SETn(result);
      return NORMAL;
    }
}

/* Support Configure command-line overrides for rand() functions.
   After 5.005, perhaps we should replace this by Configure support
   for drand48(), random(), or rand().  For 5.005, though, maintain
   compatibility by calling rand() but allow the user to override it.
   See INSTALL for details.  --Andy Dougherty  15 July 1998
*/
/* Now it's after 5.005, and Configure supports drand48() and random(),
   in addition to rand().  So the overrides should not be needed any more.
   --Jarkko Hietaniemi	27 September 1998
 */

PP(pp_rand)
{
    if (!PL_srand_called) {
	(void)seedDrand01((Rand_seed_t)seed());
	PL_srand_called = TRUE;
    }
    {
	dSP;
	NV value;
    
	if (MAXARG < 1)
	{
	    EXTEND(SP, 1);
	    value = 1.0;
	}
	else {
	    SV * const sv = POPs;
	    if(!sv)
		value = 1.0;
	    else
		value = SvNV(sv);
	}
    /* 1 of 2 things can be carried through SvNV, SP or TARG, SP was carried */
#if defined(NAN_COMPARE_BROKEN) && defined(Perl_isnan)
	if (! Perl_isnan(value) && value == 0.0)
#else
	if (value == 0.0)
#endif
	    value = 1.0;
	{
	    dTARGET;
	    PUSHs(TARG);
	    PUTBACK;
	    value *= Drand01();
	    sv_setnv_mg(TARG, value);
	}
    }
    return NORMAL;
}

PP(pp_srand)
{
    dSP; dTARGET;
    UV anum;

    if (MAXARG >= 1 && (TOPs || POPs)) {
        SV *top;
        char *pv;
        STRLEN len;
        int flags;

        top = POPs;
        pv = SvPV(top, len);
        flags = grok_number(pv, len, &anum);

        if (!(flags & IS_NUMBER_IN_UV)) {
            Perl_ck_warner_d(aTHX_ packWARN(WARN_OVERFLOW),
                             "Integer overflow in srand");
            anum = UV_MAX;
        }
        (void)srand48_deterministic((Rand_seed_t)anum);
    }
    else {
        anum = seed();
        (void)seedDrand01((Rand_seed_t)anum);
    }

    PL_srand_called = TRUE;
    if (anum)
	XPUSHu(anum);
    else {
	/* Historically srand always returned true. We can avoid breaking
	   that like this:  */
	sv_setpvs(TARG, "0 but true");
	XPUSHTARG;
    }
    RETURN;
}

PP(pp_int)
{
    dSP; dTARGET;
    tryAMAGICun_MG(int_amg, AMGf_numeric);
    {
      SV * const sv = TOPs;
      const IV iv = SvIV_nomg(sv);
      /* XXX it's arguable that compiler casting to IV might be subtly
	 different from modf (for numbers inside (IV_MIN,UV_MAX)) in which
	 else preferring IV has introduced a subtle behaviour change bug. OTOH
	 relying on floating point to be accurate is a bug.  */

      if (!SvOK(sv)) {
        SETu(0);
      }
      else if (SvIOK(sv)) {
	if (SvIsUV(sv))
	    SETu(SvUV_nomg(sv));
	else
	    SETi(iv);
      }
      else {
	  const NV value = SvNV_nomg(sv);
	  if (UNLIKELY(Perl_isinfnan(value)))
	      SETn(value);
	  else if (value >= 0.0) {
	      if (value < (NV)UV_MAX + 0.5) {
		  SETu(U_V(value));
	      } else {
		  SETn(Perl_floor(value));
	      }
	  }
	  else {
	      if (value > (NV)IV_MIN - 0.5) {
		  SETi(I_V(value));
	      } else {
		  SETn(Perl_ceil(value));
	      }
	  }
      }
    }
    return NORMAL;
}

PP(pp_abs)
{
    dSP; dTARGET;
    tryAMAGICun_MG(abs_amg, AMGf_numeric);
    {
      SV * const sv = TOPs;
      /* This will cache the NV value if string isn't actually integer  */
      const IV iv = SvIV_nomg(sv);

      if (!SvOK(sv)) {
        SETu(0);
      }
      else if (SvIOK(sv)) {
	/* IVX is precise  */
	if (SvIsUV(sv)) {
	  SETu(SvUV_nomg(sv));	/* force it to be numeric only */
	} else {
	  if (iv >= 0) {
	    SETi(iv);
	  } else {
	    if (iv != IV_MIN) {
	      SETi(-iv);
	    } else {
	      /* 2s complement assumption. Also, not really needed as
		 IV_MIN and -IV_MIN should both be %100...00 and NV-able  */
	      SETu((UV)IV_MIN);
	    }
	  }
	}
      } else{
	const NV value = SvNV_nomg(sv);
	if (value < 0.0)
	  SETn(-value);
	else
	  SETn(value);
      }
    }
    return NORMAL;
}


/* also used for: pp_hex() */

PP(pp_oct)
{
    dSP; dTARGET;
    const char *tmps;
    I32 flags = PERL_SCAN_ALLOW_UNDERSCORES;
    STRLEN len;
    NV result_nv;
    UV result_uv;
    SV* const sv = TOPs;

    tmps = (SvPV_const(sv, len));
    if (DO_UTF8(sv)) {
	 /* If Unicode, try to downgrade
	  * If not possible, croak. */
	 SV* const tsv = sv_2mortal(newSVsv(sv));
	
	 SvUTF8_on(tsv);
	 sv_utf8_downgrade(tsv, FALSE);
	 tmps = SvPV_const(tsv, len);
    }
    if (PL_op->op_type == OP_HEX)
	goto hex;

    while (*tmps && len && isSPACE(*tmps))
        tmps++, len--;
    if (*tmps == '0')
        tmps++, len--;
    if (isALPHA_FOLD_EQ(*tmps, 'x')) {
    hex:
        result_uv = grok_hex (tmps, &len, &flags, &result_nv);
    }
    else if (isALPHA_FOLD_EQ(*tmps, 'b'))
        result_uv = grok_bin (tmps, &len, &flags, &result_nv);
    else
        result_uv = grok_oct (tmps, &len, &flags, &result_nv);

    if (flags & PERL_SCAN_GREATER_THAN_UV_MAX) {
        SETn(result_nv);
    }
    else {
        SETu(result_uv);
    }
    return NORMAL;
}

/* String stuff. */

PP(pp_length)
{
    dSP; dTARGET;
    SV * const sv = TOPs;

    U32 in_bytes = IN_BYTES;
    /* simplest case shortcut */
    /* turn off SVf_UTF8 in tmp flags if HINT_BYTES on*/
    U32 svflags = (SvFLAGS(sv) ^ (in_bytes << 26)) & (SVf_POK|SVs_GMG|SVf_UTF8);
    STATIC_ASSERT_STMT(HINT_BYTES == 0x00000008 && SVf_UTF8 == 0x20000000 && (SVf_UTF8 == HINT_BYTES << 26));
    SETs(TARG);

    if(LIKELY(svflags == SVf_POK))
        goto simple_pv;
    if(svflags & SVs_GMG)
        mg_get(sv);
    if (SvOK(sv)) {
	if (!IN_BYTES) /* reread to avoid using an C auto/register */
	    sv_setiv(TARG, (IV)sv_len_utf8_nomg(sv));
	else
	{
	    STRLEN len;
            /* unrolled SvPV_nomg_const(sv,len) */
            if(SvPOK_nog(sv)){
                simple_pv:
                len = SvCUR(sv);
            } else  {
                (void)sv_2pv_flags(sv, &len, 0|SV_CONST_RETURN);
            }
	    sv_setiv(TARG, (IV)(len));
	}
    } else {
	if (!SvPADTMP(TARG)) {
	    sv_setsv_nomg(TARG, &PL_sv_undef);
	} else { /* TARG is on stack at this point and is overwriten by SETs.
                   This branch is the odd one out, so put TARG by default on
                   stack earlier to let local SP go out of liveness sooner */
            SETs(&PL_sv_undef);
            goto no_set_magic;
        }
    }
    SvSETMAGIC(TARG);
    no_set_magic:
    return NORMAL; /* no putback, SP didn't move in this opcode */
}

/* Returns false if substring is completely outside original string.
   No length is indicated by len_iv = 0 and len_is_uv = 0.  len_is_uv must
   always be true for an explicit 0.
*/
bool
Perl_translate_substr_offsets( STRLEN curlen, IV pos1_iv,
				bool pos1_is_uv, IV len_iv,
				bool len_is_uv, STRLEN *posp,
				STRLEN *lenp)
{
    IV pos2_iv;
    int    pos2_is_uv;

    PERL_ARGS_ASSERT_TRANSLATE_SUBSTR_OFFSETS;

    if (!pos1_is_uv && pos1_iv < 0 && curlen) {
	pos1_is_uv = curlen-1 > ~(UV)pos1_iv;
	pos1_iv += curlen;
    }
    if ((pos1_is_uv || pos1_iv > 0) && (UV)pos1_iv > curlen)
	return FALSE;

    if (len_iv || len_is_uv) {
	if (!len_is_uv && len_iv < 0) {
	    pos2_iv = curlen + len_iv;
	    if (curlen)
		pos2_is_uv = curlen-1 > ~(UV)len_iv;
	    else
		pos2_is_uv = 0;
	} else {  /* len_iv >= 0 */
	    if (!pos1_is_uv && pos1_iv < 0) {
		pos2_iv = pos1_iv + len_iv;
		pos2_is_uv = (UV)len_iv > (UV)IV_MAX;
	    } else {
		if ((UV)len_iv > curlen-(UV)pos1_iv)
		    pos2_iv = curlen;
		else
		    pos2_iv = pos1_iv+len_iv;
		pos2_is_uv = 1;
	    }
	}
    }
    else {
	pos2_iv = curlen;
	pos2_is_uv = 1;
    }

    if (!pos2_is_uv && pos2_iv < 0) {
	if (!pos1_is_uv && pos1_iv < 0)
	    return FALSE;
	pos2_iv = 0;
    }
    else if (!pos1_is_uv && pos1_iv < 0)
	pos1_iv = 0;

    if ((UV)pos2_iv < (UV)pos1_iv)
	pos2_iv = pos1_iv;
    if ((UV)pos2_iv > curlen)
	pos2_iv = curlen;

    /* pos1_iv and pos2_iv both in 0..curlen, so the cast is safe */
    *posp = (STRLEN)( (UV)pos1_iv );
    *lenp = (STRLEN)( (UV)pos2_iv - (UV)pos1_iv );

    return TRUE;
}

PP(pp_substr)
{
    dSP; dTARGET;
    SV *sv;
    STRLEN curlen;
    STRLEN utf8_curlen;
    SV *   pos_sv;
    IV     pos1_iv;
    int    pos1_is_uv;
    SV *   len_sv;
    IV     len_iv = 0;
    int    len_is_uv = 0;
    I32 lvalue = PL_op->op_flags & OPf_MOD || LVRET;
    const bool rvalue = (GIMME_V != G_VOID);
    const char *tmps;
    SV *repl_sv = NULL;
    const char *repl = NULL;
    STRLEN repl_len;
    int num_args = PL_op->op_private & 7;
    bool repl_need_utf8_upgrade = FALSE;

    if (num_args > 2) {
	if (num_args > 3) {
	  if(!(repl_sv = POPs)) num_args--;
	}
	if ((len_sv = POPs)) {
	    len_iv    = SvIV(len_sv);
	    len_is_uv = len_iv ? SvIOK_UV(len_sv) : 1;
	}
	else num_args--;
    }
    pos_sv     = POPs;
    pos1_iv    = SvIV(pos_sv);
    pos1_is_uv = SvIOK_UV(pos_sv);
    sv = POPs;
    if (PL_op->op_private & OPpSUBSTR_REPL_FIRST) {
	assert(!repl_sv);
	repl_sv = POPs;
    }
    if (lvalue && !repl_sv) {
	SV * ret;
	ret = sv_2mortal(newSV_type(SVt_PVLV));  /* Not TARG RT#67838 */
	sv_magic(ret, NULL, PERL_MAGIC_substr, NULL, 0);
	LvTYPE(ret) = 'x';
	LvTARG(ret) = SvREFCNT_inc_simple(sv);
	LvTARGOFF(ret) =
	    pos1_is_uv || pos1_iv >= 0
		? (STRLEN)(UV)pos1_iv
		: (LvFLAGS(ret) |= 1, (STRLEN)(UV)-pos1_iv);
	LvTARGLEN(ret) =
	    len_is_uv || len_iv > 0
		? (STRLEN)(UV)len_iv
		: (LvFLAGS(ret) |= 2, (STRLEN)(UV)-len_iv);

	PUSHs(ret);    /* avoid SvSETMAGIC here */
	RETURN;
    }
    if (repl_sv) {
	repl = SvPV_const(repl_sv, repl_len);
	SvGETMAGIC(sv);
	if (SvROK(sv))
	    Perl_ck_warner(aTHX_ packWARN(WARN_SUBSTR),
			    "Attempt to use reference as lvalue in substr"
	    );
	tmps = SvPV_force_nomg(sv, curlen);
	if (DO_UTF8(repl_sv) && repl_len) {
	    if (!DO_UTF8(sv)) {
		sv_utf8_upgrade_nomg(sv);
		curlen = SvCUR(sv);
	    }
	}
	else if (DO_UTF8(sv))
	    repl_need_utf8_upgrade = TRUE;
    }
    else tmps = SvPV_const(sv, curlen);
    if (DO_UTF8(sv)) {
        utf8_curlen = sv_or_pv_len_utf8(sv, tmps, curlen);
	if (utf8_curlen == curlen)
	    utf8_curlen = 0;
	else
	    curlen = utf8_curlen;
    }
    else
	utf8_curlen = 0;

    {
	STRLEN pos, len, byte_len, byte_pos;

	if (!translate_substr_offsets(
		curlen, pos1_iv, pos1_is_uv, len_iv, len_is_uv, &pos, &len
	)) goto bound_fail;

	byte_len = len;
	byte_pos = utf8_curlen
	    ? sv_or_pv_pos_u2b(sv, tmps, pos, &byte_len) : pos;

	tmps += byte_pos;

	if (rvalue) {
	    SvTAINTED_off(TARG);			/* decontaminate */
	    SvUTF8_off(TARG);			/* decontaminate */
	    sv_setpvn(TARG, tmps, byte_len);
#ifdef USE_LOCALE_COLLATE
	    sv_unmagic(TARG, PERL_MAGIC_collxfrm);
#endif
	    if (utf8_curlen)
		SvUTF8_on(TARG);
	}

	if (repl) {
	    SV* repl_sv_copy = NULL;

	    if (repl_need_utf8_upgrade) {
		repl_sv_copy = newSVsv(repl_sv);
		sv_utf8_upgrade(repl_sv_copy);
		repl = SvPV_const(repl_sv_copy, repl_len);
	    }
	    if (!SvOK(sv))
		sv_setpvs(sv, "");
	    sv_insert_flags(sv, byte_pos, byte_len, repl, repl_len, 0);
	    SvREFCNT_dec(repl_sv_copy);
	}
    }
    if (PL_op->op_private & OPpSUBSTR_REPL_FIRST)
	SP++;
    else if (rvalue) {
	SvSETMAGIC(TARG);
	PUSHs(TARG);
    }
    RETURN;

  bound_fail:
    if (repl)
	Perl_croak(aTHX_ "substr outside of string");
    Perl_ck_warner(aTHX_ packWARN(WARN_SUBSTR), "substr outside of string");
    RETPUSHUNDEF;
}

PP(pp_vec)
{
    dSP;
    const IV size   = POPi;
    const IV offset = POPi;
    SV * const src = POPs;
    const I32 lvalue = PL_op->op_flags & OPf_MOD || LVRET;
    SV * ret;

    if (lvalue) {			/* it's an lvalue! */
	ret = sv_2mortal(newSV_type(SVt_PVLV));  /* Not TARG RT#67838 */
	sv_magic(ret, NULL, PERL_MAGIC_vec, NULL, 0);
	LvTYPE(ret) = 'v';
	LvTARG(ret) = SvREFCNT_inc_simple(src);
	LvTARGOFF(ret) = offset;
	LvTARGLEN(ret) = size;
    }
    else {
	dTARGET;
	SvTAINTED_off(TARG);		/* decontaminate */
	ret = TARG;
    }

    sv_setuv(ret, do_vecget(src, offset, size));
    if (!lvalue)
	SvSETMAGIC(ret);
    PUSHs(ret);
    RETURN;
}


/* also used for: pp_rindex() */

PP(pp_index)
{
    dSP; dTARGET;
    SV *big;
    SV *little;
    SV *temp = NULL;
    STRLEN biglen;
    STRLEN llen = 0;
    SSize_t offset = 0;
    SSize_t retval;
    const char *big_p;
    const char *little_p;
    bool big_utf8;
    bool little_utf8;
    const bool is_index = PL_op->op_type == OP_INDEX;
    const bool threeargs = MAXARG >= 3 && (TOPs || ((void)POPs,0));

    if (threeargs)
	offset = POPi;
    little = POPs;
    big = POPs;
    big_p = SvPV_const(big, biglen);
    little_p = SvPV_const(little, llen);

    big_utf8 = DO_UTF8(big);
    little_utf8 = DO_UTF8(little);
    if (big_utf8 ^ little_utf8) {
	/* One needs to be upgraded.  */
	if (little_utf8 && !IN_ENCODING) {
	    /* Well, maybe instead we might be able to downgrade the small
	       string?  */
	    char * const pv = (char*)bytes_from_utf8((U8 *)little_p, &llen,
						     &little_utf8);
	    if (little_utf8) {
		/* If the large string is ISO-8859-1, and it's not possible to
		   convert the small string to ISO-8859-1, then there is no
		   way that it could be found anywhere by index.  */
		retval = -1;
		goto fail;
	    }

	    /* At this point, pv is a malloc()ed string. So donate it to temp
	       to ensure it will get free()d  */
	    little = temp = newSV(0);
	    sv_usepvn(temp, pv, llen);
	    little_p = SvPVX(little);
	} else {
	    temp = little_utf8
		? newSVpvn(big_p, biglen) : newSVpvn(little_p, llen);

	    if (IN_ENCODING) {
		sv_recode_to_utf8(temp, _get_encoding());
	    } else {
		sv_utf8_upgrade(temp);
	    }
	    if (little_utf8) {
		big = temp;
		big_utf8 = TRUE;
		big_p = SvPV_const(big, biglen);
	    } else {
		little = temp;
		little_p = SvPV_const(little, llen);
	    }
	}
    }
    if (SvGAMAGIC(big)) {
	/* Life just becomes a lot easier if I use a temporary here.
	   Otherwise I need to avoid calls to sv_pos_u2b(), which (dangerously)
	   will trigger magic and overloading again, as will fbm_instr()
	*/
	big = newSVpvn_flags(big_p, biglen,
			     SVs_TEMP | (big_utf8 ? SVf_UTF8 : 0));
	big_p = SvPVX(big);
    }
    if (SvGAMAGIC(little) || (is_index && !SvOK(little))) {
	/* index && SvOK() is a hack. fbm_instr() calls SvPV_const, which will
	   warn on undef, and we've already triggered a warning with the
	   SvPV_const some lines above. We can't remove that, as we need to
	   call some SvPV to trigger overloading early and find out if the
	   string is UTF-8.
	   This is all getting too messy. The API isn't quite clean enough,
	   because data access has side effects.
	*/
	little = newSVpvn_flags(little_p, llen,
				SVs_TEMP | (little_utf8 ? SVf_UTF8 : 0));
	little_p = SvPVX(little);
    }

    if (!threeargs)
	offset = is_index ? 0 : biglen;
    else {
	if (big_utf8 && offset > 0)
	    offset = sv_pos_u2b_flags(big, offset, 0, SV_CONST_RETURN);
	if (!is_index)
	    offset += llen;
    }
    if (offset < 0)
	offset = 0;
    else if (offset > (SSize_t)biglen)
	offset = biglen;
    if (!(little_p = is_index
	  ? fbm_instr((unsigned char*)big_p + offset,
		      (unsigned char*)big_p + biglen, little, 0)
	  : rninstr(big_p,  big_p  + offset,
		    little_p, little_p + llen)))
	retval = -1;
    else {
	retval = little_p - big_p;
	if (retval > 1 && big_utf8)
	    retval = sv_pos_b2u_flags(big, retval, SV_CONST_RETURN);
    }
    SvREFCNT_dec(temp);
 fail:
    PUSHi(retval);
    RETURN;
}

PP(pp_sprintf)
{
    dSP; dMARK; dORIGMARK; dTARGET;
    SvTAINTED_off(TARG);
    do_sprintf(TARG, SP-MARK, MARK+1);
    TAINT_IF(SvTAINTED(TARG));
    SP = ORIGMARK;
    PUSHTARG;
    RETURN;
}

PP(pp_ord)
{
    dSP; dTARGET;

    SV *argsv = TOPs;
    STRLEN len;
    const U8 *s = (U8*)SvPV_const(argsv, len);

    if (IN_ENCODING && SvPOK(argsv) && !DO_UTF8(argsv)) {
        SV * const tmpsv = sv_2mortal(newSVsv(argsv));
        s = (U8*)sv_recode_to_utf8(tmpsv, _get_encoding());
        len = UTF8SKIP(s);  /* Should be well-formed; so this is its length */
        argsv = tmpsv;
    }

    SETu(DO_UTF8(argsv)
           ? utf8n_to_uvchr(s, len, 0, UTF8_ALLOW_ANYUV)
           : (UV)(*s));

    return NORMAL;
}

PP(pp_chr)
{
    dSP; dTARGET;
    char *tmps;
    UV value;
    SV *top = TOPs;

    SvGETMAGIC(top);
    if (UNLIKELY(SvAMAGIC(top)))
	top = sv_2num(top);
    if (UNLIKELY(isinfnansv(top)))
        Perl_croak(aTHX_ "Cannot chr %"NVgf, SvNV(top));
    else {
        if (!IN_BYTES /* under bytes, chr(-1) eq chr(0xff), etc. */
            && ((SvIOKp(top) && !SvIsUV(top) && SvIV_nomg(top) < 0)
                ||
                ((SvNOKp(top) || (SvOK(top) && !SvIsUV(top)))
                 && SvNV_nomg(top) < 0.0)))
        {
	    if (ckWARN(WARN_UTF8)) {
		if (SvGMAGICAL(top)) {
		    SV *top2 = sv_newmortal();
		    sv_setsv_nomg(top2, top);
		    top = top2;
		}
                Perl_warner(aTHX_ packWARN(WARN_UTF8),
                            "Invalid negative number (%"SVf") in chr", SVfARG(top));
            }
            value = UNICODE_REPLACEMENT;
        } else {
            value = SvUV_nomg(top);
        }
    }

    SvUPGRADE(TARG,SVt_PV);

    if (value > 255 && !IN_BYTES) {
	SvGROW(TARG, (STRLEN)UVCHR_SKIP(value)+1);
	tmps = (char*)uvchr_to_utf8_flags((U8*)SvPVX(TARG), value, 0);
	SvCUR_set(TARG, tmps - SvPVX_const(TARG));
	*tmps = '\0';
	(void)SvPOK_only(TARG);
	SvUTF8_on(TARG);
	SETTARG;
	return NORMAL;
    }

    SvGROW(TARG,2);
    SvCUR_set(TARG, 1);
    tmps = SvPVX(TARG);
    *tmps++ = (char)value;
    *tmps = '\0';
    (void)SvPOK_only(TARG);

    if (IN_ENCODING && !IN_BYTES) {
        sv_recode_to_utf8(TARG, _get_encoding());
	tmps = SvPVX(TARG);
	if (SvCUR(TARG) == 0
	    || ! is_utf8_string((U8*)tmps, SvCUR(TARG))
	    || UTF8_IS_REPLACEMENT((U8*) tmps, (U8*) tmps + SvCUR(TARG)))
	{
	    SvGROW(TARG, 2);
	    tmps = SvPVX(TARG);
	    SvCUR_set(TARG, 1);
	    *tmps++ = (char)value;
	    *tmps = '\0';
	    SvUTF8_off(TARG);
	}
    }

    SETTARG;
    return NORMAL;
}

PP(pp_crypt)
{
#ifdef HAS_CRYPT
    dSP; dTARGET;
    dPOPTOPssrl;
    STRLEN len;
    const char *tmps = SvPV_const(left, len);

    if (DO_UTF8(left)) {
         /* If Unicode, try to downgrade.
	  * If not possible, croak.
	  * Yes, we made this up.  */
	 SV* const tsv = newSVpvn_flags(tmps, len, SVf_UTF8|SVs_TEMP);

	 sv_utf8_downgrade(tsv, FALSE);
	 tmps = SvPV_const(tsv, len);
    }
#   ifdef USE_ITHREADS
#     ifdef HAS_CRYPT_R
    if (!PL_reentrant_buffer->_crypt_struct_buffer) {
      /* This should be threadsafe because in ithreads there is only
       * one thread per interpreter.  If this would not be true,
       * we would need a mutex to protect this malloc. */
        PL_reentrant_buffer->_crypt_struct_buffer =
	  (struct crypt_data *)safemalloc(sizeof(struct crypt_data));
#if defined(__GLIBC__) || defined(__EMX__)
	if (PL_reentrant_buffer->_crypt_struct_buffer) {
	    PL_reentrant_buffer->_crypt_struct_buffer->initialized = 0;
	    /* work around glibc-2.2.5 bug */
	    PL_reentrant_buffer->_crypt_struct_buffer->current_saltbits = 0;
	}
#endif
    }
#     endif /* HAS_CRYPT_R */
#   endif /* USE_ITHREADS */
#   ifdef FCRYPT
    sv_setpv(TARG, fcrypt(tmps, SvPV_nolen_const(right)));
#   else
    sv_setpv(TARG, PerlProc_crypt(tmps, SvPV_nolen_const(right)));
#   endif
    SvUTF8_off(TARG);
    SETTARG;
    RETURN;
#else
    DIE(aTHX_
      "The crypt() function is unimplemented due to excessive paranoia.");
#endif
}

/* Generally UTF-8 and UTF-EBCDIC are indistinguishable at this level.  So 
 * most comments below say UTF-8, when in fact they mean UTF-EBCDIC as well */


/* also used for: pp_lcfirst() */

PP(pp_ucfirst)
{
    /* Actually is both lcfirst() and ucfirst().  Only the first character
     * changes.  This means that possibly we can change in-place, ie., just
     * take the source and change that one character and store it back, but not
     * if read-only etc, or if the length changes */

    dSP;
    SV *source = TOPs;
    STRLEN slen; /* slen is the byte length of the whole SV. */
    STRLEN need;
    SV *dest;
    bool inplace;   /* ? Convert first char only, in-place */
    bool doing_utf8 = FALSE;		   /* ? using utf8 */
    bool convert_source_to_utf8 = FALSE;   /* ? need to convert */
    const int op_type = PL_op->op_type;
    const U8 *s;
    U8 *d;
    U8 tmpbuf[UTF8_MAXBYTES_CASE+1];
    STRLEN ulen;    /* ulen is the byte length of the original Unicode character
		     * stored as UTF-8 at s. */
    STRLEN tculen;  /* tculen is the byte length of the freshly titlecased (or
		     * lowercased) character stored in tmpbuf.  May be either
		     * UTF-8 or not, but in either case is the number of bytes */

    s = (const U8*)SvPV_const(source, slen);

    /* We may be able to get away with changing only the first character, in
     * place, but not if read-only, etc.  Later we may discover more reasons to
     * not convert in-place. */
    inplace = !SvREADONLY(source) && SvPADTMP(source);

    /* First calculate what the changed first character should be.  This affects
     * whether we can just swap it out, leaving the rest of the string unchanged,
     * or even if have to convert the dest to UTF-8 when the source isn't */

    if (! slen) {   /* If empty */
	need = 1; /* still need a trailing NUL */
	ulen = 0;
    }
    else if (DO_UTF8(source)) {	/* Is the source utf8? */
	doing_utf8 = TRUE;
        ulen = UTF8SKIP(s);
        if (op_type == OP_UCFIRST) {
#ifdef USE_LOCALE_CTYPE
	    _to_utf8_title_flags(s, tmpbuf, &tculen, IN_LC_RUNTIME(LC_CTYPE));
#else
	    _to_utf8_title_flags(s, tmpbuf, &tculen, 0);
#endif
	}
        else {
#ifdef USE_LOCALE_CTYPE
	    _to_utf8_lower_flags(s, tmpbuf, &tculen, IN_LC_RUNTIME(LC_CTYPE));
#else
	    _to_utf8_lower_flags(s, tmpbuf, &tculen, 0);
#endif
	}

        /* we can't do in-place if the length changes.  */
        if (ulen != tculen) inplace = FALSE;
        need = slen + 1 - ulen + tculen;
    }
    else { /* Non-zero length, non-UTF-8,  Need to consider locale and if
	    * latin1 is treated as caseless.  Note that a locale takes
	    * precedence */ 
	ulen = 1;	/* Original character is 1 byte */
	tculen = 1;	/* Most characters will require one byte, but this will
			 * need to be overridden for the tricky ones */
	need = slen + 1;

	if (op_type == OP_LCFIRST) {

	    /* lower case the first letter: no trickiness for any character */
#ifdef USE_LOCALE_CTYPE
            if (IN_LC_RUNTIME(LC_CTYPE)) {
                _CHECK_AND_WARN_PROBLEMATIC_LOCALE;
                *tmpbuf = toLOWER_LC(*s);
            }
            else
#endif
            {
                *tmpbuf = (IN_UNI_8_BIT)
                          ? toLOWER_LATIN1(*s)
                          : toLOWER(*s);
            }
	}
#ifdef USE_LOCALE_CTYPE
	/* is ucfirst() */
	else if (IN_LC_RUNTIME(LC_CTYPE)) {
            if (IN_UTF8_CTYPE_LOCALE) {
                goto do_uni_rules;
            }

            _CHECK_AND_WARN_PROBLEMATIC_LOCALE;
            *tmpbuf = (U8) toUPPER_LC(*s); /* This would be a bug if any
                                              locales have upper and title case
                                              different */
	}
#endif
	else if (! IN_UNI_8_BIT) {
	    *tmpbuf = toUPPER(*s);	/* Returns caseless for non-ascii, or
					 * on EBCDIC machines whatever the
					 * native function does */
	}
        else {
            /* Here, is ucfirst non-UTF-8, not in locale (unless that locale is
             * UTF-8, which we treat as not in locale), and cased latin1 */
	    UV title_ord;
#ifdef USE_LOCALE_CTYPE
      do_uni_rules:
#endif

	    title_ord = _to_upper_title_latin1(*s, tmpbuf, &tculen, 's');
	    if (tculen > 1) {
		assert(tculen == 2);

                /* If the result is an upper Latin1-range character, it can
                 * still be represented in one byte, which is its ordinal */
		if (UTF8_IS_DOWNGRADEABLE_START(*tmpbuf)) {
		    *tmpbuf = (U8) title_ord;
		    tculen = 1;
		}
		else {
                    /* Otherwise it became more than one ASCII character (in
                     * the case of LATIN_SMALL_LETTER_SHARP_S) or changed to
                     * beyond Latin1, so the number of bytes changed, so can't
                     * replace just the first character in place. */
		    inplace = FALSE;

                    /* If the result won't fit in a byte, the entire result
                     * will have to be in UTF-8.  Assume worst case sizing in
                     * conversion. (all latin1 characters occupy at most two
                     * bytes in utf8) */
		    if (title_ord > 255) {
			doing_utf8 = TRUE;
			convert_source_to_utf8 = TRUE;
			need = slen * 2 + 1;

                        /* The (converted) UTF-8 and UTF-EBCDIC lengths of all
                         * (both) characters whose title case is above 255 is
                         * 2. */
			ulen = 2;
		    }
                    else { /* LATIN_SMALL_LETTER_SHARP_S expands by 1 byte */
			need = slen + 1 + 1;
		    }
		}
	    }
	} /* End of use Unicode (Latin1) semantics */
    } /* End of changing the case of the first character */

    /* Here, have the first character's changed case stored in tmpbuf.  Ready to
     * generate the result */
    if (inplace) {

	/* We can convert in place.  This means we change just the first
	 * character without disturbing the rest; no need to grow */
	dest = source;
	s = d = (U8*)SvPV_force_nomg(source, slen);
    } else {
	dTARGET;

	dest = TARG;

	/* Here, we can't convert in place; we earlier calculated how much
	 * space we will need, so grow to accommodate that */
	SvUPGRADE(dest, SVt_PV);
	d = (U8*)SvGROW(dest, need);
	(void)SvPOK_only(dest);

	SETs(dest);
    }

    if (doing_utf8) {
	if (! inplace) {
	    if (! convert_source_to_utf8) {

		/* Here  both source and dest are in UTF-8, but have to create
		 * the entire output.  We initialize the result to be the
		 * title/lower cased first character, and then append the rest
		 * of the string. */
		sv_setpvn(dest, (char*)tmpbuf, tculen);
		if (slen > ulen) {
		    sv_catpvn(dest, (char*)(s + ulen), slen - ulen);
		}
	    }
	    else {
		const U8 *const send = s + slen;

		/* Here the dest needs to be in UTF-8, but the source isn't,
		 * except we earlier UTF-8'd the first character of the source
		 * into tmpbuf.  First put that into dest, and then append the
		 * rest of the source, converting it to UTF-8 as we go. */

		/* Assert tculen is 2 here because the only two characters that
		 * get to this part of the code have 2-byte UTF-8 equivalents */
		*d++ = *tmpbuf;
		*d++ = *(tmpbuf + 1);
		s++;	/* We have just processed the 1st char */

		for (; s < send; s++) {
		    d = uvchr_to_utf8(d, *s);
		}
		*d = '\0';
		SvCUR_set(dest, d - (U8*)SvPVX_const(dest));
	    }
	    SvUTF8_on(dest);
	}
	else {   /* in-place UTF-8.  Just overwrite the first character */
	    Copy(tmpbuf, d, tculen, U8);
	    SvCUR_set(dest, need - 1);
	}

    }
    else {  /* Neither source nor dest are in or need to be UTF-8 */
	if (slen) {
	    if (inplace) {  /* in-place, only need to change the 1st char */
		*d = *tmpbuf;
	    }
	    else {	/* Not in-place */

		/* Copy the case-changed character(s) from tmpbuf */
		Copy(tmpbuf, d, tculen, U8);
		d += tculen - 1; /* Code below expects d to point to final
				  * character stored */
	    }
	}
	else {	/* empty source */
	    /* See bug #39028: Don't taint if empty  */
	    *d = *s;
	}

	/* In a "use bytes" we don't treat the source as UTF-8, but, still want
	 * the destination to retain that flag */
	if (SvUTF8(source) && ! IN_BYTES)
	    SvUTF8_on(dest);

	if (!inplace) {	/* Finish the rest of the string, unchanged */
	    /* This will copy the trailing NUL  */
	    Copy(s + 1, d + 1, slen, U8);
	    SvCUR_set(dest, need - 1);
	}
    }
#ifdef USE_LOCALE_CTYPE
    if (IN_LC_RUNTIME(LC_CTYPE)) {
        TAINT;
        SvTAINTED_on(dest);
    }
#endif
    if (dest != source && SvTAINTED(source))
	SvTAINT(dest);
    SvSETMAGIC(dest);
    return NORMAL;
}

/* There's so much setup/teardown code common between uc and lc, I wonder if
   it would be worth merging the two, and just having a switch outside each
   of the three tight loops.  There is less and less commonality though */
PP(pp_uc)
{
    dSP;
    SV *source = TOPs;
    STRLEN len;
    STRLEN min;
    SV *dest;
    const U8 *s;
    U8 *d;

    SvGETMAGIC(source);

    if (   SvPADTMP(source)
	&& !SvREADONLY(source) && SvPOK(source)
	&& !DO_UTF8(source)
	&& (
#ifdef USE_LOCALE_CTYPE
            (IN_LC_RUNTIME(LC_CTYPE))
            ? ! IN_UTF8_CTYPE_LOCALE
            :
#endif
              ! IN_UNI_8_BIT))
    {

        /* We can convert in place.  The reason we can't if in UNI_8_BIT is to
         * make the loop tight, so we overwrite the source with the dest before
         * looking at it, and we need to look at the original source
         * afterwards.  There would also need to be code added to handle
         * switching to not in-place in midstream if we run into characters
         * that change the length.  Since being in locale overrides UNI_8_BIT,
         * that latter becomes irrelevant in the above test; instead for
         * locale, the size can't normally change, except if the locale is a
         * UTF-8 one */
	dest = source;
	s = d = (U8*)SvPV_force_nomg(source, len);
	min = len + 1;
    } else {
	dTARGET;

	dest = TARG;

	s = (const U8*)SvPV_nomg_const(source, len);
	min = len + 1;

	SvUPGRADE(dest, SVt_PV);
	d = (U8*)SvGROW(dest, min);
	(void)SvPOK_only(dest);

	SETs(dest);
    }

    /* Overloaded values may have toggled the UTF-8 flag on source, so we need
       to check DO_UTF8 again here.  */

    if (DO_UTF8(source)) {
	const U8 *const send = s + len;
	U8 tmpbuf[UTF8_MAXBYTES_CASE+1];

	/* All occurrences of these are to be moved to follow any other marks.
	 * This is context-dependent.  We may not be passed enough context to
	 * move the iota subscript beyond all of them, but we do the best we can
	 * with what we're given.  The result is always better than if we
	 * hadn't done this.  And, the problem would only arise if we are
	 * passed a character without all its combining marks, which would be
	 * the caller's mistake.  The information this is based on comes from a
	 * comment in Unicode SpecialCasing.txt, (and the Standard's text
	 * itself) and so can't be checked properly to see if it ever gets
	 * revised.  But the likelihood of it changing is remote */
	bool in_iota_subscript = FALSE;

	while (s < send) {
	    STRLEN u;
	    STRLEN ulen;
	    UV uv;
	    if (in_iota_subscript && ! _is_utf8_mark(s)) {

		/* A non-mark.  Time to output the iota subscript */
		Copy(GREEK_CAPITAL_LETTER_IOTA_UTF8, d, capital_iota_len, U8);
                d += capital_iota_len;
		in_iota_subscript = FALSE;
            }

            /* Then handle the current character.  Get the changed case value
             * and copy it to the output buffer */

            u = UTF8SKIP(s);
#ifdef USE_LOCALE_CTYPE
            uv = _to_utf8_upper_flags(s, tmpbuf, &ulen, IN_LC_RUNTIME(LC_CTYPE));
#else
            uv = _to_utf8_upper_flags(s, tmpbuf, &ulen, 0);
#endif
#define GREEK_CAPITAL_LETTER_IOTA 0x0399
#define COMBINING_GREEK_YPOGEGRAMMENI 0x0345
            if (uv == GREEK_CAPITAL_LETTER_IOTA
                && utf8_to_uvchr_buf(s, send, 0) == COMBINING_GREEK_YPOGEGRAMMENI)
            {
                in_iota_subscript = TRUE;
            }
            else {
                if (ulen > u && (SvLEN(dest) < (min += ulen - u))) {
                    /* If the eventually required minimum size outgrows the
                     * available space, we need to grow. */
                    const UV o = d - (U8*)SvPVX_const(dest);

                    /* If someone uppercases one million U+03B0s we SvGROW()
                     * one million times.  Or we could try guessing how much to
                     * allocate without allocating too much.  Such is life.
                     * See corresponding comment in lc code for another option
                     * */
                    SvGROW(dest, min);
                    d = (U8*)SvPVX(dest) + o;
                }
                Copy(tmpbuf, d, ulen, U8);
                d += ulen;
            }
            s += u;
	}
	if (in_iota_subscript) {
            Copy(GREEK_CAPITAL_LETTER_IOTA_UTF8, d, capital_iota_len, U8);
            d += capital_iota_len;
	}
	SvUTF8_on(dest);
	*d = '\0';

	SvCUR_set(dest, d - (U8*)SvPVX_const(dest));
    }
    else {	/* Not UTF-8 */
	if (len) {
	    const U8 *const send = s + len;

	    /* Use locale casing if in locale; regular style if not treating
	     * latin1 as having case; otherwise the latin1 casing.  Do the
	     * whole thing in a tight loop, for speed, */
#ifdef USE_LOCALE_CTYPE
	    if (IN_LC_RUNTIME(LC_CTYPE)) {
                if (IN_UTF8_CTYPE_LOCALE) {
                    goto do_uni_rules;
                }
                _CHECK_AND_WARN_PROBLEMATIC_LOCALE;
		for (; s < send; d++, s++)
                    *d = (U8) toUPPER_LC(*s);
	    }
	    else
#endif
                 if (! IN_UNI_8_BIT) {
		for (; s < send; d++, s++) {
		    *d = toUPPER(*s);
		}
	    }
	    else {
#ifdef USE_LOCALE_CTYPE
          do_uni_rules:
#endif
		for (; s < send; d++, s++) {
		    *d = toUPPER_LATIN1_MOD(*s);
		    if (LIKELY(*d != LATIN_SMALL_LETTER_Y_WITH_DIAERESIS)) {
                        continue;
                    }

		    /* The mainstream case is the tight loop above.  To avoid
		     * extra tests in that, all three characters that require
		     * special handling are mapped by the MOD to the one tested
		     * just above.  
		     * Use the source to distinguish between the three cases */

#if    UNICODE_MAJOR_VERSION > 2                                        \
   || (UNICODE_MAJOR_VERSION == 2 && UNICODE_DOT_VERSION >= 1		\
                                  && UNICODE_DOT_DOT_VERSION >= 8)
		    if (*s == LATIN_SMALL_LETTER_SHARP_S) {

			/* uc() of this requires 2 characters, but they are
			 * ASCII.  If not enough room, grow the string */
			if (SvLEN(dest) < ++min) {	
			    const UV o = d - (U8*)SvPVX_const(dest);
			    SvGROW(dest, min);
			    d = (U8*)SvPVX(dest) + o;
			}
			*d++ = 'S'; *d = 'S'; /* upper case is 'SS' */
			continue;   /* Back to the tight loop; still in ASCII */
		    }
#endif

		    /* The other two special handling characters have their
		     * upper cases outside the latin1 range, hence need to be
		     * in UTF-8, so the whole result needs to be in UTF-8.  So,
		     * here we are somewhere in the middle of processing a
		     * non-UTF-8 string, and realize that we will have to convert
		     * the whole thing to UTF-8.  What to do?  There are
		     * several possibilities.  The simplest to code is to
		     * convert what we have so far, set a flag, and continue on
		     * in the loop.  The flag would be tested each time through
		     * the loop, and if set, the next character would be
		     * converted to UTF-8 and stored.  But, I (khw) didn't want
		     * to slow down the mainstream case at all for this fairly
		     * rare case, so I didn't want to add a test that didn't
		     * absolutely have to be there in the loop, besides the
		     * possibility that it would get too complicated for
		     * optimizers to deal with.  Another possibility is to just
		     * give up, convert the source to UTF-8, and restart the
		     * function that way.  Another possibility is to convert
		     * both what has already been processed and what is yet to
		     * come separately to UTF-8, then jump into the loop that
		     * handles UTF-8.  But the most efficient time-wise of the
		     * ones I could think of is what follows, and turned out to
		     * not require much extra code.  */

		    /* Convert what we have so far into UTF-8, telling the
		     * function that we know it should be converted, and to
		     * allow extra space for what we haven't processed yet.
		     * Assume the worst case space requirements for converting
		     * what we haven't processed so far: that it will require
		     * two bytes for each remaining source character, plus the
		     * NUL at the end.  This may cause the string pointer to
		     * move, so re-find it. */

		    len = d - (U8*)SvPVX_const(dest);
		    SvCUR_set(dest, len);
		    len = sv_utf8_upgrade_flags_grow(dest,
						SV_GMAGIC|SV_FORCE_UTF8_UPGRADE,
						(send -s) * 2 + 1);
		    d = (U8*)SvPVX(dest) + len;

		    /* Now process the remainder of the source, converting to
		     * upper and UTF-8.  If a resulting byte is invariant in
		     * UTF-8, output it as-is, otherwise convert to UTF-8 and
		     * append it to the output. */
		    for (; s < send; s++) {
			(void) _to_upper_title_latin1(*s, d, &len, 'S');
			d += len;
		    }

		    /* Here have processed the whole source; no need to continue
		     * with the outer loop.  Each character has been converted
		     * to upper case and converted to UTF-8 */

		    break;
		} /* End of processing all latin1-style chars */
	    } /* End of processing all chars */
	} /* End of source is not empty */

	if (source != dest) {
	    *d = '\0';  /* Here d points to 1 after last char, add NUL */
	    SvCUR_set(dest, d - (U8*)SvPVX_const(dest));
	}
    } /* End of isn't utf8 */
#ifdef USE_LOCALE_CTYPE
    if (IN_LC_RUNTIME(LC_CTYPE)) {
        TAINT;
        SvTAINTED_on(dest);
    }
#endif
    if (dest != source && SvTAINTED(source))
	SvTAINT(dest);
    SvSETMAGIC(dest);
    return NORMAL;
}

PP(pp_lc)
{
    dSP;
    SV *source = TOPs;
    STRLEN len;
    STRLEN min;
    SV *dest;
    const U8 *s;
    U8 *d;

    SvGETMAGIC(source);

    if (   SvPADTMP(source)
	&& !SvREADONLY(source) && SvPOK(source)
	&& !DO_UTF8(source)) {

	/* We can convert in place, as lowercasing anything in the latin1 range
	 * (or else DO_UTF8 would have been on) doesn't lengthen it */
	dest = source;
	s = d = (U8*)SvPV_force_nomg(source, len);
	min = len + 1;
    } else {
	dTARGET;

	dest = TARG;

	s = (const U8*)SvPV_nomg_const(source, len);
	min = len + 1;

	SvUPGRADE(dest, SVt_PV);
	d = (U8*)SvGROW(dest, min);
	(void)SvPOK_only(dest);

	SETs(dest);
    }

    /* Overloaded values may have toggled the UTF-8 flag on source, so we need
       to check DO_UTF8 again here.  */

    if (DO_UTF8(source)) {
	const U8 *const send = s + len;
	U8 tmpbuf[UTF8_MAXBYTES_CASE+1];

	while (s < send) {
	    const STRLEN u = UTF8SKIP(s);
	    STRLEN ulen;

#ifdef USE_LOCALE_CTYPE
	    _to_utf8_lower_flags(s, tmpbuf, &ulen, IN_LC_RUNTIME(LC_CTYPE));
#else
	    _to_utf8_lower_flags(s, tmpbuf, &ulen, 0);
#endif

	    /* Here is where we would do context-sensitive actions.  See the
	     * commit message for 86510fb15 for why there isn't any */

	    if (ulen > u && (SvLEN(dest) < (min += ulen - u))) {

		/* If the eventually required minimum size outgrows the
		 * available space, we need to grow. */
		const UV o = d - (U8*)SvPVX_const(dest);

		/* If someone lowercases one million U+0130s we SvGROW() one
		 * million times.  Or we could try guessing how much to
		 * allocate without allocating too much.  Such is life.
		 * Another option would be to grow an extra byte or two more
		 * each time we need to grow, which would cut down the million
		 * to 500K, with little waste */
		SvGROW(dest, min);
		d = (U8*)SvPVX(dest) + o;
	    }

	    /* Copy the newly lowercased letter to the output buffer we're
	     * building */
	    Copy(tmpbuf, d, ulen, U8);
	    d += ulen;
	    s += u;
	}   /* End of looping through the source string */
	SvUTF8_on(dest);
	*d = '\0';
	SvCUR_set(dest, d - (U8*)SvPVX_const(dest));
    } else {	/* Not utf8 */
	if (len) {
	    const U8 *const send = s + len;

	    /* Use locale casing if in locale; regular style if not treating
	     * latin1 as having case; otherwise the latin1 casing.  Do the
	     * whole thing in a tight loop, for speed, */
#ifdef USE_LOCALE_CTYPE
            if (IN_LC_RUNTIME(LC_CTYPE)) {
                _CHECK_AND_WARN_PROBLEMATIC_LOCALE;
		for (; s < send; d++, s++)
		    *d = toLOWER_LC(*s);
            }
	    else
#endif
            if (! IN_UNI_8_BIT) {
		for (; s < send; d++, s++) {
		    *d = toLOWER(*s);
		}
	    }
	    else {
		for (; s < send; d++, s++) {
		    *d = toLOWER_LATIN1(*s);
		}
	    }
	}
	if (source != dest) {
	    *d = '\0';
	    SvCUR_set(dest, d - (U8*)SvPVX_const(dest));
	}
    }
#ifdef USE_LOCALE_CTYPE
    if (IN_LC_RUNTIME(LC_CTYPE)) {
        TAINT;
        SvTAINTED_on(dest);
    }
#endif
    if (dest != source && SvTAINTED(source))
	SvTAINT(dest);
    SvSETMAGIC(dest);
    return NORMAL;
}

PP(pp_quotemeta)
{
    dSP; dTARGET;
    SV * const sv = TOPs;
    STRLEN len;
    const char *s = SvPV_const(sv,len);

    SvUTF8_off(TARG);				/* decontaminate */
    if (len) {
	char *d;
	SvUPGRADE(TARG, SVt_PV);
	SvGROW(TARG, (len * 2) + 1);
	d = SvPVX(TARG);
	if (DO_UTF8(sv)) {
	    while (len) {
		STRLEN ulen = UTF8SKIP(s);
		bool to_quote = FALSE;

		if (UTF8_IS_INVARIANT(*s)) {
		    if (_isQUOTEMETA(*s)) {
			to_quote = TRUE;
		    }
		}
		else if (UTF8_IS_DOWNGRADEABLE_START(*s)) {
		    if (
#ifdef USE_LOCALE_CTYPE
		    /* In locale, we quote all non-ASCII Latin1 chars.
		     * Otherwise use the quoting rules */
		    
		    IN_LC_RUNTIME(LC_CTYPE)
			||
#endif
			_isQUOTEMETA(EIGHT_BIT_UTF8_TO_NATIVE(*s, *(s + 1))))
		    {
			to_quote = TRUE;
		    }
		}
		else if (is_QUOTEMETA_high(s)) {
		    to_quote = TRUE;
		}

		if (to_quote) {
		    *d++ = '\\';
		}
		if (ulen > len)
		    ulen = len;
		len -= ulen;
		while (ulen--)
		    *d++ = *s++;
	    }
	    SvUTF8_on(TARG);
	}
	else if (IN_UNI_8_BIT) {
	    while (len--) {
		if (_isQUOTEMETA(*s))
		    *d++ = '\\';
		*d++ = *s++;
	    }
	}
	else {
	    /* For non UNI_8_BIT (and hence in locale) just quote all \W
	     * including everything above ASCII */
	    while (len--) {
		if (!isWORDCHAR_A(*s))
		    *d++ = '\\';
		*d++ = *s++;
	    }
	}
	*d = '\0';
	SvCUR_set(TARG, d - SvPVX_const(TARG));
	(void)SvPOK_only_UTF8(TARG);
    }
    else
	sv_setpvn(TARG, s, len);
    SETTARG;
    return NORMAL;
}

PP(pp_fc)
{
    dTARGET;
    dSP;
    SV *source = TOPs;
    STRLEN len;
    STRLEN min;
    SV *dest;
    const U8 *s;
    const U8 *send;
    U8 *d;
    U8 tmpbuf[UTF8_MAXBYTES_CASE + 1];
#if    UNICODE_MAJOR_VERSION > 3 /* no multifolds in early Unicode */   \
   || (UNICODE_MAJOR_VERSION == 3 && (   UNICODE_DOT_VERSION > 0)       \
                                      || UNICODE_DOT_DOT_VERSION > 0)
    const bool full_folding = TRUE; /* This variable is here so we can easily
                                       move to more generality later */
#else
    const bool full_folding = FALSE;
#endif
    const U8 flags = ( full_folding      ? FOLD_FLAGS_FULL   : 0 )
#ifdef USE_LOCALE_CTYPE
                   | ( IN_LC_RUNTIME(LC_CTYPE) ? FOLD_FLAGS_LOCALE : 0 )
#endif
    ;

    /* This is a facsimile of pp_lc, but with a thousand bugs thanks to me.
     * You are welcome(?) -Hugmeir
     */

    SvGETMAGIC(source);

    dest = TARG;

    if (SvOK(source)) {
        s = (const U8*)SvPV_nomg_const(source, len);
    } else {
        if (ckWARN(WARN_UNINITIALIZED))
	    report_uninit(source);
	s = (const U8*)"";
	len = 0;
    }

    min = len + 1;

    SvUPGRADE(dest, SVt_PV);
    d = (U8*)SvGROW(dest, min);
    (void)SvPOK_only(dest);

    SETs(dest);

    send = s + len;
    if (DO_UTF8(source)) { /* UTF-8 flagged string. */
        while (s < send) {
            const STRLEN u = UTF8SKIP(s);
            STRLEN ulen;

            _to_utf8_fold_flags(s, tmpbuf, &ulen, flags);

            if (ulen > u && (SvLEN(dest) < (min += ulen - u))) {
                const UV o = d - (U8*)SvPVX_const(dest);
                SvGROW(dest, min);
                d = (U8*)SvPVX(dest) + o;
            }

            Copy(tmpbuf, d, ulen, U8);
            d += ulen;
            s += u;
        }
        SvUTF8_on(dest);
    } /* Unflagged string */
    else if (len) {
#ifdef USE_LOCALE_CTYPE
        if ( IN_LC_RUNTIME(LC_CTYPE) ) { /* Under locale */
            if (IN_UTF8_CTYPE_LOCALE) {
                goto do_uni_folding;
            }
            _CHECK_AND_WARN_PROBLEMATIC_LOCALE;
            for (; s < send; d++, s++)
                *d = (U8) toFOLD_LC(*s);
        }
        else
#endif
        if ( !IN_UNI_8_BIT ) { /* Under nothing, or bytes */
            for (; s < send; d++, s++)
                *d = toFOLD(*s);
        }
        else {
#ifdef USE_LOCALE_CTYPE
      do_uni_folding:
#endif
            /* For ASCII and the Latin-1 range, there's only two troublesome
             * folds, \x{DF} (\N{LATIN SMALL LETTER SHARP S}), which under full
             * casefolding becomes 'ss'; and \x{B5} (\N{MICRO SIGN}), which
             * under any fold becomes \x{3BC} (\N{GREEK SMALL LETTER MU}) --
             * For the rest, the casefold is their lowercase.  */
            for (; s < send; d++, s++) {
                if (*s == MICRO_SIGN) {
                    /* \N{MICRO SIGN}'s casefold is \N{GREEK SMALL LETTER MU},
                     * which is outside of the latin-1 range. There's a couple
                     * of ways to deal with this -- khw discusses them in
                     * pp_lc/uc, so go there :) What we do here is upgrade what
                     * we had already casefolded, then enter an inner loop that
                     * appends the rest of the characters as UTF-8. */
                    len = d - (U8*)SvPVX_const(dest);
                    SvCUR_set(dest, len);
                    len = sv_utf8_upgrade_flags_grow(dest,
                                                SV_GMAGIC|SV_FORCE_UTF8_UPGRADE,
						/* The max expansion for latin1
						 * chars is 1 byte becomes 2 */
                                                (send -s) * 2 + 1);
                    d = (U8*)SvPVX(dest) + len;

                    Copy(GREEK_SMALL_LETTER_MU_UTF8, d, small_mu_len, U8);
                    d += small_mu_len;
                    s++;
                    for (; s < send; s++) {
                        STRLEN ulen;
                        UV fc = _to_uni_fold_flags(*s, tmpbuf, &ulen, flags);
                        if UVCHR_IS_INVARIANT(fc) {
                            if (full_folding
                                && *s == LATIN_SMALL_LETTER_SHARP_S)
                            {
                                *d++ = 's';
                                *d++ = 's';
                            }
                            else
                                *d++ = (U8)fc;
                        }
                        else {
                            Copy(tmpbuf, d, ulen, U8);
                            d += ulen;
                        }
                    }
                    break;
                }
                else if (full_folding && *s == LATIN_SMALL_LETTER_SHARP_S) {
                    /* Under full casefolding, LATIN SMALL LETTER SHARP S
                     * becomes "ss", which may require growing the SV. */
                    if (SvLEN(dest) < ++min) {
                        const UV o = d - (U8*)SvPVX_const(dest);
                        SvGROW(dest, min);
                        d = (U8*)SvPVX(dest) + o;
                     }
                    *(d)++ = 's';
                    *d = 's';
                }
                else { /* If it's not one of those two, the fold is their lower
                          case */
                    *d = toLOWER_LATIN1(*s);
                }
             }
        }
    }
    *d = '\0';
    SvCUR_set(dest, d - (U8*)SvPVX_const(dest));

#ifdef USE_LOCALE_CTYPE
    if (IN_LC_RUNTIME(LC_CTYPE)) {
        TAINT;
        SvTAINTED_on(dest);
    }
#endif
    if (SvTAINTED(source))
	SvTAINT(dest);
    SvSETMAGIC(dest);
    RETURN;
}

/* Arrays. */

PP(pp_aslice)
{
    dSP; dMARK; dORIGMARK;
    AV *const av = MUTABLE_AV(POPs);
    const I32 lval = (PL_op->op_flags & OPf_MOD || LVRET);

    if (SvTYPE(av) == SVt_PVAV) {
	const bool localizing = PL_op->op_private & OPpLVAL_INTRO;
	bool can_preserve = FALSE;

	if (localizing) {
	    MAGIC *mg;
	    HV *stash;

	    can_preserve = SvCANEXISTDELETE(av);
	}

	if (lval && localizing) {
	    SV **svp;
	    SSize_t max = -1;
	    for (svp = MARK + 1; svp <= SP; svp++) {
		const SSize_t elem = SvIV(*svp);
		if (elem > max)
		    max = elem;
	    }
	    if (max > AvMAX(av))
		av_extend(av, max);
	}

	while (++MARK <= SP) {
	    SV **svp;
	    SSize_t elem = SvIV(*MARK);
	    bool preeminent = TRUE;

	    if (localizing && can_preserve) {
		/* If we can determine whether the element exist,
		 * Try to preserve the existenceness of a tied array
		 * element by using EXISTS and DELETE if possible.
		 * Fallback to FETCH and STORE otherwise. */
		preeminent = av_exists(av, elem);
	    }

	    svp = av_fetch(av, elem, lval);
	    if (lval) {
		if (!svp || !*svp)
		    DIE(aTHX_ PL_no_aelem, elem);
		if (localizing) {
		    if (preeminent)
			save_aelem(av, elem, svp);
		    else
			SAVEADELETE(av, elem);
		}
	    }
	    *MARK = svp ? *svp : &PL_sv_undef;
	}
    }
    if (GIMME_V != G_ARRAY) {
	MARK = ORIGMARK;
	*++MARK = SP > ORIGMARK ? *SP : &PL_sv_undef;
	SP = MARK;
    }
    RETURN;
}

PP(pp_kvaslice)
{
    dSP; dMARK;
    AV *const av = MUTABLE_AV(POPs);
    I32 lval = (PL_op->op_flags & OPf_MOD);
    SSize_t items = SP - MARK;

    if (PL_op->op_private & OPpMAYBE_LVSUB) {
       const I32 flags = is_lvalue_sub();
       if (flags) {
           if (!(flags & OPpENTERSUB_INARGS))
               /* diag_listed_as: Can't modify %s in %s */
	       Perl_croak(aTHX_ "Can't modify index/value array slice in list assignment");
	   lval = flags;
       }
    }

    MEXTEND(SP,items);
    while (items > 1) {
	*(MARK+items*2-1) = *(MARK+items);
	items--;
    }
    items = SP-MARK;
    SP += items;

    while (++MARK <= SP) {
        SV **svp;

	svp = av_fetch(av, SvIV(*MARK), lval);
        if (lval) {
            if (!svp || !*svp || *svp == &PL_sv_undef) {
                DIE(aTHX_ PL_no_aelem, SvIV(*MARK));
            }
	    *MARK = sv_mortalcopy(*MARK);
        }
	*++MARK = svp ? *svp : &PL_sv_undef;
    }
    if (GIMME_V != G_ARRAY) {
	MARK = SP - items*2;
	*++MARK = items > 0 ? *SP : &PL_sv_undef;
	SP = MARK;
    }
    RETURN;
}


PP(pp_aeach)
{
    dSP;
    AV *array = MUTABLE_AV(POPs);
    const U8 gimme = GIMME_V;
    IV *iterp = Perl_av_iter_p(aTHX_ array);
    const IV current = (*iterp)++;

    if (current > av_tindex(array)) {
	*iterp = 0;
	if (gimme == G_SCALAR)
	    RETPUSHUNDEF;
	else
	    RETURN;
    }

    EXTEND(SP, 2);
    mPUSHi(current);
    if (gimme == G_ARRAY) {
	SV **const element = av_fetch(array, current, 0);
        PUSHs(element ? *element : &PL_sv_undef);
    }
    RETURN;
}

/* also used for: pp_avalues()*/
PP(pp_akeys)
{
    dSP;
    AV *array = MUTABLE_AV(POPs);
    const U8 gimme = GIMME_V;

    *Perl_av_iter_p(aTHX_ array) = 0;

    if (gimme == G_SCALAR) {
	dTARGET;
	PUSHi(av_tindex(array) + 1);
    }
    else if (gimme == G_ARRAY) {
        IV n = Perl_av_len(aTHX_ array);
        IV i;

        EXTEND(SP, n + 1);

	if (PL_op->op_type == OP_AKEYS) {
	    for (i = 0;  i <= n;  i++) {
		mPUSHi(i);
	    }
	}
	else {
	    for (i = 0;  i <= n;  i++) {
		SV *const *const elem = Perl_av_fetch(aTHX_ array, i, 0);
		PUSHs(elem ? *elem : &PL_sv_undef);
	    }
	}
    }
    RETURN;
}

/* Associative arrays. */

PP(pp_each)
{
    dSP;
    HV * hash = MUTABLE_HV(POPs);
    HE *entry;
    const U8 gimme = GIMME_V;

    entry = hv_iternext(hash);

    EXTEND(SP, 2);
    if (entry) {
	SV* const sv = hv_iterkeysv(entry);
	PUSHs(sv);
	if (gimme == G_ARRAY) {
	    SV *val;
	    val = hv_iterval(hash, entry);
	    PUSHs(val);
	}
    }
    else if (gimme == G_SCALAR)
	RETPUSHUNDEF;

    RETURN;
}

STATIC OP *
S_do_delete_local(pTHX)
{
    dSP;
    const U8 gimme = GIMME_V;
    const MAGIC *mg;
    HV *stash;
    const bool sliced = !!(PL_op->op_private & OPpSLICE);
    SV **unsliced_keysv = sliced ? NULL : sp--;
    SV * const osv = POPs;
    SV **mark = sliced ? PL_stack_base + POPMARK : unsliced_keysv-1;
    dORIGMARK;
    const bool tied = SvRMAGICAL(osv)
			    && mg_find((const SV *)osv, PERL_MAGIC_tied);
    const bool can_preserve = SvCANEXISTDELETE(osv);
    const U32 type = SvTYPE(osv);
    SV ** const end = sliced ? SP : unsliced_keysv;

    if (type == SVt_PVHV) {			/* hash element */
	    HV * const hv = MUTABLE_HV(osv);
	    while (++MARK <= end) {
		SV * const keysv = *MARK;
		SV *sv = NULL;
		bool preeminent = TRUE;
		if (can_preserve)
		    preeminent = hv_exists_ent(hv, keysv, 0);
		if (tied) {
		    HE *he = hv_fetch_ent(hv, keysv, 1, 0);
		    if (he)
			sv = HeVAL(he);
		    else
			preeminent = FALSE;
		}
		else {
		    sv = hv_delete_ent(hv, keysv, 0, 0);
		    if (preeminent)
			SvREFCNT_inc_simple_void(sv); /* De-mortalize */
		}
		if (preeminent) {
		    if (!sv) DIE(aTHX_ PL_no_helem_sv, SVfARG(keysv));
		    save_helem_flags(hv, keysv, &sv, SAVEf_KEEPOLDELEM);
		    if (tied) {
			*MARK = sv_mortalcopy(sv);
			mg_clear(sv);
		    } else
			*MARK = sv;
		}
		else {
		    SAVEHDELETE(hv, keysv);
		    *MARK = &PL_sv_undef;
		}
	    }
    }
    else if (type == SVt_PVAV) {                  /* array element */
	    if (PL_op->op_flags & OPf_SPECIAL) {
		AV * const av = MUTABLE_AV(osv);
		while (++MARK <= end) {
		    SSize_t idx = SvIV(*MARK);
		    SV *sv = NULL;
		    bool preeminent = TRUE;
		    if (can_preserve)
			preeminent = av_exists(av, idx);
		    if (tied) {
			SV **svp = av_fetch(av, idx, 1);
			if (svp)
			    sv = *svp;
			else
			    preeminent = FALSE;
		    }
		    else {
			sv = av_delete(av, idx, 0);
			if (preeminent)
			   SvREFCNT_inc_simple_void(sv); /* De-mortalize */
		    }
		    if (preeminent) {
		        save_aelem_flags(av, idx, &sv, SAVEf_KEEPOLDELEM);
			if (tied) {
			    *MARK = sv_mortalcopy(sv);
			    mg_clear(sv);
			} else
			    *MARK = sv;
		    }
		    else {
		        SAVEADELETE(av, idx);
		        *MARK = &PL_sv_undef;
		    }
		}
	    }
	    else
		DIE(aTHX_ "panic: avhv_delete no longer supported");
    }
    else
	    DIE(aTHX_ "Not a HASH reference");
    if (sliced) {
	if (gimme == G_VOID)
	    SP = ORIGMARK;
	else if (gimme == G_SCALAR) {
	    MARK = ORIGMARK;
	    if (SP > MARK)
		*++MARK = *SP;
	    else
		*++MARK = &PL_sv_undef;
	    SP = MARK;
	}
    }
    else if (gimme != G_VOID)
	PUSHs(*unsliced_keysv);

    RETURN;
}

PP(pp_delete)
{
    dSP;
    U8 gimme;
    I32 discard;

    if (PL_op->op_private & OPpLVAL_INTRO)
	return do_delete_local();

    gimme = GIMME_V;
    discard = (gimme == G_VOID) ? G_DISCARD : 0;

    if (PL_op->op_private & OPpSLICE) {
	dMARK; dORIGMARK;
	HV * const hv = MUTABLE_HV(POPs);
	const U32 hvtype = SvTYPE(hv);
	if (hvtype == SVt_PVHV) {			/* hash element */
	    while (++MARK <= SP) {
		SV * const sv = hv_delete_ent(hv, *MARK, discard, 0);
		*MARK = sv ? sv : &PL_sv_undef;
	    }
	}
	else if (hvtype == SVt_PVAV) {                  /* array element */
            if (PL_op->op_flags & OPf_SPECIAL) {
                while (++MARK <= SP) {
                    SV * const sv = av_delete(MUTABLE_AV(hv), SvIV(*MARK), discard);
                    *MARK = sv ? sv : &PL_sv_undef;
                }
            }
	}
	else
	    DIE(aTHX_ "Not a HASH reference");
	if (discard)
	    SP = ORIGMARK;
	else if (gimme == G_SCALAR) {
	    MARK = ORIGMARK;
	    if (SP > MARK)
		*++MARK = *SP;
	    else
		*++MARK = &PL_sv_undef;
	    SP = MARK;
	}
    }
    else {
	SV *keysv = POPs;
	HV * const hv = MUTABLE_HV(POPs);
	SV *sv = NULL;
	if (SvTYPE(hv) == SVt_PVHV)
	    sv = hv_delete_ent(hv, keysv, discard, 0);
	else if (SvTYPE(hv) == SVt_PVAV) {
	    if (PL_op->op_flags & OPf_SPECIAL)
		sv = av_delete(MUTABLE_AV(hv), SvIV(keysv), discard);
	    else
		DIE(aTHX_ "panic: avhv_delete no longer supported");
	}
	else
	    DIE(aTHX_ "Not a HASH reference");
	if (!sv)
	    sv = &PL_sv_undef;
	if (!discard)
	    PUSHs(sv);
    }
    RETURN;
}

PP(pp_exists)
{
    dSP;
    SV *tmpsv;
    HV *hv;

    if (UNLIKELY( PL_op->op_private & OPpEXISTS_SUB )) {
	GV *gv;
	SV * const sv = POPs;
	CV * const cv = sv_2cv(sv, &hv, &gv, 0);
	if (cv)
	    RETPUSHYES;
	if (gv && isGV(gv) && GvCV(gv) && !GvCVGEN(gv))
	    RETPUSHYES;
	RETPUSHNO;
    }
    tmpsv = POPs;
    hv = MUTABLE_HV(POPs);
    if (LIKELY( SvTYPE(hv) == SVt_PVHV )) {
	if (hv_exists_ent(hv, tmpsv, 0))
	    RETPUSHYES;
    }
    else if (SvTYPE(hv) == SVt_PVAV) {
	if (PL_op->op_flags & OPf_SPECIAL) {		/* array element */
	    if (av_exists(MUTABLE_AV(hv), SvIV(tmpsv)))
		RETPUSHYES;
	}
    }
    else {
	DIE(aTHX_ "Not a HASH reference");
    }
    RETPUSHNO;
}

PP(pp_hslice)
{
    dSP; dMARK; dORIGMARK;
    HV * const hv = MUTABLE_HV(POPs);
    const I32 lval = (PL_op->op_flags & OPf_MOD || LVRET);
    const bool localizing = PL_op->op_private & OPpLVAL_INTRO;
    bool can_preserve = FALSE;

    if (localizing) {
        MAGIC *mg;
        HV *stash;

	if (SvCANEXISTDELETE(hv))
	    can_preserve = TRUE;
    }

    while (++MARK <= SP) {
        SV * const keysv = *MARK;
        SV **svp;
        HE *he;
        bool preeminent = TRUE;

        if (localizing && can_preserve) {
	    /* If we can determine whether the element exist,
             * try to preserve the existenceness of a tied hash
             * element by using EXISTS and DELETE if possible.
             * Fallback to FETCH and STORE otherwise. */
            preeminent = hv_exists_ent(hv, keysv, 0);
        }

        he = hv_fetch_ent(hv, keysv, lval, 0);
        svp = he ? &HeVAL(he) : NULL;

        if (lval) {
            if (!svp || !*svp || *svp == &PL_sv_undef) {
                DIE(aTHX_ PL_no_helem_sv, SVfARG(keysv));
            }
            if (localizing) {
		if (HvNAME_get(hv) && isGV(*svp))
		    save_gp(MUTABLE_GV(*svp), !(PL_op->op_flags & OPf_SPECIAL));
		else if (preeminent)
		    save_helem_flags(hv, keysv, svp,
			 (PL_op->op_flags & OPf_SPECIAL) ? 0 : SAVEf_SETMAGIC);
		else
		    SAVEHDELETE(hv, keysv);
            }
        }
        *MARK = svp && *svp ? *svp : &PL_sv_undef;
    }
    if (GIMME_V != G_ARRAY) {
	MARK = ORIGMARK;
	*++MARK = SP > ORIGMARK ? *SP : &PL_sv_undef;
	SP = MARK;
    }
    RETURN;
}

PP(pp_kvhslice)
{
    dSP; dMARK;
    HV * const hv = MUTABLE_HV(POPs);
    I32 lval = (PL_op->op_flags & OPf_MOD);
    SSize_t items = SP - MARK;

    if (PL_op->op_private & OPpMAYBE_LVSUB) {
       const I32 flags = is_lvalue_sub();
       if (flags) {
           if (!(flags & OPpENTERSUB_INARGS))
               /* diag_listed_as: Can't modify %s in %s */
	       Perl_croak(aTHX_ "Can't modify key/value hash slice in list assignment");
	   lval = flags;
       }
    }

    MEXTEND(SP,items);
    while (items > 1) {
	*(MARK+items*2-1) = *(MARK+items);
	items--;
    }
    items = SP-MARK;
    SP += items;

    while (++MARK <= SP) {
        SV * const keysv = *MARK;
        SV **svp;
        HE *he;

        he = hv_fetch_ent(hv, keysv, lval, 0);
        svp = he ? &HeVAL(he) : NULL;

        if (lval) {
            if (!svp || !*svp || *svp == &PL_sv_undef) {
                DIE(aTHX_ PL_no_helem_sv, SVfARG(keysv));
            }
	    *MARK = sv_mortalcopy(*MARK);
        }
        *++MARK = svp && *svp ? *svp : &PL_sv_undef;
    }
    if (GIMME_V != G_ARRAY) {
	MARK = SP - items*2;
	*++MARK = items > 0 ? *SP : &PL_sv_undef;
	SP = MARK;
    }
    RETURN;
}

/* List operators. */

PP(pp_list)
{
    I32 markidx = POPMARK;
    if (GIMME_V != G_ARRAY) {
	SV **mark = PL_stack_base + markidx;
	dSP;
	if (++MARK <= SP)
	    *MARK = *SP;		/* unwanted list, return last item */
	else
	    *MARK = &PL_sv_undef;
	SP = MARK;
	PUTBACK;
    }
    return NORMAL;
}

PP(pp_lslice)
{
    dSP;
    SV ** const lastrelem = PL_stack_sp;
    SV ** const lastlelem = PL_stack_base + POPMARK;
    SV ** const firstlelem = PL_stack_base + POPMARK + 1;
    SV ** const firstrelem = lastlelem + 1;
    const U8 mod = PL_op->op_flags & OPf_MOD;

    const I32 max = lastrelem - lastlelem;
    SV **lelem;

    if (GIMME_V != G_ARRAY) {
        if (lastlelem < firstlelem) {
            *firstlelem = &PL_sv_undef;
        }
        else {
            I32 ix = SvIV(*lastlelem);
            if (ix < 0)
                ix += max;
            if (ix < 0 || ix >= max)
                *firstlelem = &PL_sv_undef;
            else
                *firstlelem = firstrelem[ix];
        }
        SP = firstlelem;
        RETURN;
    }

    if (max == 0) {
	SP = firstlelem - 1;
	RETURN;
    }

    for (lelem = firstlelem; lelem <= lastlelem; lelem++) {
	I32 ix = SvIV(*lelem);
	if (ix < 0)
	    ix += max;
	if (ix < 0 || ix >= max)
	    *lelem = &PL_sv_undef;
	else {
	    if (!(*lelem = firstrelem[ix]))
		*lelem = &PL_sv_undef;
	    else if (mod && SvPADTMP(*lelem)) {
		*lelem = firstrelem[ix] = sv_mortalcopy(*lelem);
            }
	}
    }
    SP = lastlelem;
    RETURN;
}

PP(pp_anonlist)
{
    dSP; dMARK;
    const I32 items = SP - MARK;
    SV * const av = MUTABLE_SV(av_make(items, MARK+1));
    SP = MARK;
    mXPUSHs((PL_op->op_flags & OPf_SPECIAL)
	    ? newRV_noinc(av) : av);
    RETURN;
}

PP(pp_anonhash)
{
    dSP; dMARK; dORIGMARK;
    HV* const hv = newHV();
    SV* const retval = sv_2mortal( PL_op->op_flags & OPf_SPECIAL
                                    ? newRV_noinc(MUTABLE_SV(hv))
                                    : MUTABLE_SV(hv) );

    while (MARK < SP) {
	SV * const key =
	    (MARK++, SvGMAGICAL(*MARK) ? sv_mortalcopy(*MARK) : *MARK);
	SV *val;
	if (MARK < SP)
	{
	    MARK++;
	    SvGETMAGIC(*MARK);
	    val = newSV(0);
	    sv_setsv_nomg(val, *MARK);
	}
	else
	{
	    Perl_ck_warner(aTHX_ packWARN(WARN_MISC), "Odd number of elements in anonymous hash");
	    val = newSV(0);
	}
	(void)hv_store_ent(hv,key,val,0);
    }
    SP = ORIGMARK;
    XPUSHs(retval);
    RETURN;
}

static AV *
S_deref_plain_array(pTHX_ AV *ary)
{
    if (SvTYPE(ary) == SVt_PVAV) return ary;
    SvGETMAGIC((SV *)ary);
    if (!SvROK(ary) || SvTYPE(SvRV(ary)) != SVt_PVAV)
	Perl_die(aTHX_ "Not an ARRAY reference");
    else if (SvOBJECT(SvRV(ary)))
	Perl_die(aTHX_ "Not an unblessed ARRAY reference");
    return (AV *)SvRV(ary);
}

#if defined(__GNUC__) && !defined(PERL_GCC_BRACE_GROUPS_FORBIDDEN)
# define DEREF_PLAIN_ARRAY(ary)       \
   ({                                  \
     AV *aRrRay = ary;                  \
     SvTYPE(aRrRay) == SVt_PVAV          \
      ? aRrRay                            \
      : S_deref_plain_array(aTHX_ aRrRay); \
   })
#else
# define DEREF_PLAIN_ARRAY(ary)            \
   (                                        \
     PL_Sv = (SV *)(ary),                    \
     SvTYPE(PL_Sv) == SVt_PVAV                \
      ? (AV *)PL_Sv                            \
      : S_deref_plain_array(aTHX_ (AV *)PL_Sv)  \
   )
#endif

PP(pp_splice)
{
    dSP; dMARK; dORIGMARK;
    int num_args = (SP - MARK);
    AV *ary = DEREF_PLAIN_ARRAY(MUTABLE_AV(*++MARK));
    SV **src;
    SV **dst;
    SSize_t i;
    SSize_t offset;
    SSize_t length;
    SSize_t newlen;
    SSize_t after;
    SSize_t diff;
    const MAGIC * const mg = SvTIED_mg((const SV *)ary, PERL_MAGIC_tied);

    if (mg) {
	return Perl_tied_method(aTHX_ SV_CONST(SPLICE), mark - 1, MUTABLE_SV(ary), mg,
				    GIMME_V | TIED_METHOD_ARGUMENTS_ON_STACK,
				    sp - mark);
    }

    SP++;

    if (++MARK < SP) {
	offset = i = SvIV(*MARK);
	if (offset < 0)
	    offset += AvFILLp(ary) + 1;
	if (offset < 0)
	    DIE(aTHX_ PL_no_aelem, i);
	if (++MARK < SP) {
	    length = SvIVx(*MARK++);
	    if (length < 0) {
		length += AvFILLp(ary) - offset + 1;
		if (length < 0)
		    length = 0;
	    }
	}
	else
	    length = AvMAX(ary) + 1;		/* close enough to infinity */
    }
    else {
	offset = 0;
	length = AvMAX(ary) + 1;
    }
    if (offset > AvFILLp(ary) + 1) {
	if (num_args > 2)
	    Perl_ck_warner(aTHX_ packWARN(WARN_MISC), "splice() offset past end of array" );
	offset = AvFILLp(ary) + 1;
    }
    after = AvFILLp(ary) + 1 - (offset + length);
    if (after < 0) {				/* not that much array */
	length += after;			/* offset+length now in array */
	after = 0;
	if (!AvALLOC(ary))
	    av_extend(ary, 0);
    }

    /* At this point, MARK .. SP-1 is our new LIST */

    newlen = SP - MARK;
    diff = newlen - length;
    if (newlen && !AvREAL(ary) && AvREIFY(ary))
	av_reify(ary);

    /* make new elements SVs now: avoid problems if they're from the array */
    for (dst = MARK, i = newlen; i; i--) {
        SV * const h = *dst;
	*dst++ = newSVsv(h);
    }

    if (diff < 0) {				/* shrinking the area */
	SV **tmparyval = NULL;
	if (newlen) {
	    Newx(tmparyval, newlen, SV*);	/* so remember insertion */
	    Copy(MARK, tmparyval, newlen, SV*);
	}

	MARK = ORIGMARK + 1;
	if (GIMME_V == G_ARRAY) {		/* copy return vals to stack */
	    const bool real = cBOOL(AvREAL(ary));
	    MEXTEND(MARK, length);
	    if (real)
		EXTEND_MORTAL(length);
	    for (i = 0, dst = MARK; i < length; i++) {
		if ((*dst = AvARRAY(ary)[i+offset])) {
		  if (real)
		    sv_2mortal(*dst);	/* free them eventually */
		}
		else
		    *dst = &PL_sv_undef;
		dst++;
	    }
	    MARK += length - 1;
	}
	else {
	    *MARK = AvARRAY(ary)[offset+length-1];
	    if (AvREAL(ary)) {
		sv_2mortal(*MARK);
		for (i = length - 1, dst = &AvARRAY(ary)[offset]; i > 0; i--)
		    SvREFCNT_dec(*dst++);	/* free them now */
	    }
	}
	AvFILLp(ary) += diff;

	/* pull up or down? */

	if (offset < after) {			/* easier to pull up */
	    if (offset) {			/* esp. if nothing to pull */
		src = &AvARRAY(ary)[offset-1];
		dst = src - diff;		/* diff is negative */
		for (i = offset; i > 0; i--)	/* can't trust Copy */
		    *dst-- = *src--;
	    }
	    dst = AvARRAY(ary);
	    AvARRAY(ary) = AvARRAY(ary) - diff; /* diff is negative */
	    AvMAX(ary) += diff;
	}
	else {
	    if (after) {			/* anything to pull down? */
		src = AvARRAY(ary) + offset + length;
		dst = src + diff;		/* diff is negative */
		Move(src, dst, after, SV*);
	    }
	    dst = &AvARRAY(ary)[AvFILLp(ary)+1];
						/* avoid later double free */
	}
	i = -diff;
	while (i)
	    dst[--i] = NULL;
	
	if (newlen) {
 	    Copy( tmparyval, AvARRAY(ary) + offset, newlen, SV* );
	    Safefree(tmparyval);
	}
    }
    else {					/* no, expanding (or same) */
	SV** tmparyval = NULL;
	if (length) {
	    Newx(tmparyval, length, SV*);	/* so remember deletion */
	    Copy(AvARRAY(ary)+offset, tmparyval, length, SV*);
	}

	if (diff > 0) {				/* expanding */
	    /* push up or down? */
	    if (offset < after && diff <= AvARRAY(ary) - AvALLOC(ary)) {
		if (offset) {
		    src = AvARRAY(ary);
		    dst = src - diff;
		    Move(src, dst, offset, SV*);
		}
		AvARRAY(ary) = AvARRAY(ary) - diff;/* diff is positive */
		AvMAX(ary) += diff;
		AvFILLp(ary) += diff;
	    }
	    else {
		if (AvFILLp(ary) + diff >= AvMAX(ary))	/* oh, well */
		    av_extend(ary, AvFILLp(ary) + diff);
		AvFILLp(ary) += diff;

		if (after) {
		    dst = AvARRAY(ary) + AvFILLp(ary);
		    src = dst - diff;
		    for (i = after; i; i--) {
			*dst-- = *src--;
		    }
		}
	    }
	}

	if (newlen) {
	    Copy( MARK, AvARRAY(ary) + offset, newlen, SV* );
	}

	MARK = ORIGMARK + 1;
	if (GIMME_V == G_ARRAY) {		/* copy return vals to stack */
	    if (length) {
		const bool real = cBOOL(AvREAL(ary));
		if (real)
		    EXTEND_MORTAL(length);
		for (i = 0, dst = MARK; i < length; i++) {
		    if ((*dst = tmparyval[i])) {
		      if (real)
			sv_2mortal(*dst);	/* free them eventually */
		    }
		    else *dst = &PL_sv_undef;
		    dst++;
		}
	    }
	    MARK += length - 1;
	}
	else if (length--) {
	    *MARK = tmparyval[length];
	    if (AvREAL(ary)) {
		sv_2mortal(*MARK);
		while (length-- > 0)
		    SvREFCNT_dec(tmparyval[length]);
	    }
	}
	else
	    *MARK = &PL_sv_undef;
	Safefree(tmparyval);
    }

    if (SvMAGICAL(ary))
	mg_set(MUTABLE_SV(ary));

    SP = MARK;
    RETURN;
}

PP(pp_push)
{
    dSP; dMARK; dORIGMARK; dTARGET;
    AV * const ary = DEREF_PLAIN_ARRAY(MUTABLE_AV(*++MARK));
    const MAGIC * const mg = SvTIED_mg((const SV *)ary, PERL_MAGIC_tied);

    if (mg) {
	*MARK-- = SvTIED_obj(MUTABLE_SV(ary), mg);
	PUSHMARK(MARK);
	PUTBACK;
	ENTER_with_name("call_PUSH");
	call_sv(SV_CONST(PUSH),G_SCALAR|G_DISCARD|G_METHOD_NAMED);
	LEAVE_with_name("call_PUSH");
	/* SPAGAIN; not needed: SP is assigned to immediately below */
    }
    else {
        /* PL_delaymagic is restored by JUMPENV_POP on dieing, so we
         * only need to save locally, not on the save stack */
        U16 old_delaymagic = PL_delaymagic;

	if (SvREADONLY(ary) && MARK < SP) Perl_croak_no_modify();
	PL_delaymagic = DM_DELAY;
	for (++MARK; MARK <= SP; MARK++) {
	    SV *sv;
	    if (*MARK) SvGETMAGIC(*MARK);
	    sv = newSV(0);
	    if (*MARK)
		sv_setsv_nomg(sv, *MARK);
	    av_store(ary, AvFILLp(ary)+1, sv);
	}
	if (PL_delaymagic & DM_ARRAY_ISA)
	    mg_set(MUTABLE_SV(ary));
        PL_delaymagic = old_delaymagic;
    }
    SP = ORIGMARK;
    if (OP_GIMME(PL_op, 0) != G_VOID) {
	PUSHi( AvFILL(ary) + 1 );
    }
    RETURN;
}

/* also used for: pp_pop()*/
PP(pp_shift)
{
    dSP;
    AV * const av = PL_op->op_flags & OPf_SPECIAL
	? MUTABLE_AV(GvAV(PL_defgv)) : DEREF_PLAIN_ARRAY(MUTABLE_AV(POPs));
    SV * const sv = PL_op->op_type == OP_SHIFT ? av_shift(av) : av_pop(av);
    EXTEND(SP, 1);
    assert (sv);
    if (AvREAL(av))
	(void)sv_2mortal(sv);
    PUSHs(sv);
    RETURN;
}

PP(pp_unshift)
{
    dSP; dMARK; dORIGMARK; dTARGET;
    AV *ary = DEREF_PLAIN_ARRAY(MUTABLE_AV(*++MARK));
    const MAGIC * const mg = SvTIED_mg((const SV *)ary, PERL_MAGIC_tied);

    if (mg) {
	*MARK-- = SvTIED_obj(MUTABLE_SV(ary), mg);
	PUSHMARK(MARK);
	PUTBACK;
	ENTER_with_name("call_UNSHIFT");
	call_sv(SV_CONST(UNSHIFT),G_SCALAR|G_DISCARD|G_METHOD_NAMED);
	LEAVE_with_name("call_UNSHIFT");
	/* SPAGAIN; not needed: SP is assigned to immediately below */
    }
    else {
        /* PL_delaymagic is restored by JUMPENV_POP on dieing, so we
         * only need to save locally, not on the save stack */
        U16 old_delaymagic = PL_delaymagic;
	SSize_t i = 0;

	av_unshift(ary, SP - MARK);
        PL_delaymagic = DM_DELAY;
	while (MARK < SP) {
	    SV * const sv = newSVsv(*++MARK);
	    (void)av_store(ary, i++, sv);
	}
        if (PL_delaymagic & DM_ARRAY_ISA)
            mg_set(MUTABLE_SV(ary));
        PL_delaymagic = old_delaymagic;
    }
    SP = ORIGMARK;
    if (OP_GIMME(PL_op, 0) != G_VOID) {
	PUSHi( AvFILL(ary) + 1 );
    }
    RETURN;
}

PP(pp_reverse)
{
    dSP; dMARK;

    if (GIMME_V == G_ARRAY) {
	if (PL_op->op_private & OPpREVERSE_INPLACE) {
	    AV *av;

	    /* See pp_sort() */
	    assert( MARK+1 == SP && *SP && SvTYPE(*SP) == SVt_PVAV);
	    (void)POPMARK; /* remove mark associated with ex-OP_AASSIGN */
	    av = MUTABLE_AV((*SP));
	    /* In-place reversing only happens in void context for the array
	     * assignment. We don't need to push anything on the stack. */
	    SP = MARK;

	    if (SvMAGICAL(av)) {
		SSize_t i, j;
		SV *tmp = sv_newmortal();
		/* For SvCANEXISTDELETE */
		HV *stash;
		const MAGIC *mg;
		bool can_preserve = SvCANEXISTDELETE(av);

		for (i = 0, j = av_tindex(av); i < j; ++i, --j) {
		    SV *begin, *end;

		    if (can_preserve) {
			if (!av_exists(av, i)) {
			    if (av_exists(av, j)) {
				SV *sv = av_delete(av, j, 0);
				begin = *av_fetch(av, i, TRUE);
				sv_setsv_mg(begin, sv);
			    }
			    continue;
			}
			else if (!av_exists(av, j)) {
			    SV *sv = av_delete(av, i, 0);
			    end = *av_fetch(av, j, TRUE);
			    sv_setsv_mg(end, sv);
			    continue;
			}
		    }

		    begin = *av_fetch(av, i, TRUE);
		    end   = *av_fetch(av, j, TRUE);
		    sv_setsv(tmp,      begin);
		    sv_setsv_mg(begin, end);
		    sv_setsv_mg(end,   tmp);
		}
	    }
	    else {
		SV **begin = AvARRAY(av);

		if (begin) {
		    SV **end   = begin + AvFILLp(av);

		    while (begin < end) {
			SV * const tmp = *begin;
			*begin++ = *end;
			*end--   = tmp;
		    }
		}
	    }
	}
	else {
	    SV **oldsp = SP;
	    MARK++;
	    while (MARK < SP) {
		SV * const tmp = *MARK;
		*MARK++ = *SP;
		*SP--   = tmp;
	    }
	    /* safe as long as stack cannot get extended in the above */
	    SP = oldsp;
	}
    }
    else {
	char *up;
	char *down;
	I32 tmp;
	dTARGET;
	STRLEN len;

	SvUTF8_off(TARG);				/* decontaminate */
	if (SP - MARK > 1)
	    do_join(TARG, &PL_sv_no, MARK, SP);
	else {
	    sv_setsv(TARG, SP > MARK ? *SP : DEFSV);
	}

	up = SvPV_force(TARG, len);
	if (len > 1) {
	    if (DO_UTF8(TARG)) {	/* first reverse each character */
		U8* s = (U8*)SvPVX(TARG);
		const U8* send = (U8*)(s + len);
		while (s < send) {
		    if (UTF8_IS_INVARIANT(*s)) {
			s++;
			continue;
		    }
		    else {
			if (!utf8_to_uvchr_buf(s, send, 0))
			    break;
			up = (char*)s;
			s += UTF8SKIP(s);
			down = (char*)(s - 1);
			/* reverse this character */
			while (down > up) {
			    tmp = *up;
			    *up++ = *down;
			    *down-- = (char)tmp;
			}
		    }
		}
		up = SvPVX(TARG);
	    }
	    down = SvPVX(TARG) + len - 1;
	    while (down > up) {
		tmp = *up;
		*up++ = *down;
		*down-- = (char)tmp;
	    }
	    (void)SvPOK_only_UTF8(TARG);
	}
	SP = MARK + 1;
	SETTARG;
    }
    RETURN;
}

PP(pp_split)
{
    dSP; dTARG;
    AV *ary = PL_op->op_flags & OPf_STACKED ? (AV *)POPs : NULL;
    IV limit = POPi;			/* note, negative is forever */
    SV * const sv = POPs;
    STRLEN len;
    const char *s = SvPV_const(sv, len);
    const bool do_utf8 = DO_UTF8(sv);
    const char *strend = s + len;
    PMOP *pm;
    REGEXP *rx;
    SV *dstr;
    const char *m;
    SSize_t iters = 0;
    const STRLEN slen = do_utf8
                        ? utf8_length((U8*)s, (U8*)strend)
                        : (STRLEN)(strend - s);
    SSize_t maxiters = slen + 10;
    I32 trailing_empty = 0;
    const char *orig;
    const IV origlimit = limit;
    I32 realarray = 0;
    I32 base;
    const U8 gimme = GIMME_V;
    bool gimme_scalar;
    const I32 oldsave = PL_savestack_ix;
    U32 make_mortal = SVs_TEMP;
    bool multiline = 0;
    MAGIC *mg = NULL;

#ifdef DEBUGGING
    Copy(&LvTARGOFF(POPs), &pm, 1, PMOP*);
#else
    pm = (PMOP*)POPs;
#endif
    if (!pm)
	DIE(aTHX_ "panic: pp_split, pm=%p, s=%p", pm, s);
    rx = PM_GETRE(pm);

    TAINT_IF(get_regex_charset(RX_EXTFLAGS(rx)) == REGEX_LOCALE_CHARSET &&
             (RX_EXTFLAGS(rx) & (RXf_WHITE | RXf_SKIPWHITE)));

#ifdef USE_ITHREADS
    if (pm->op_pmreplrootu.op_pmtargetoff) {
	ary = GvAVn(MUTABLE_GV(PAD_SVl(pm->op_pmreplrootu.op_pmtargetoff)));
	goto have_av;
    }
#else
    if (pm->op_pmreplrootu.op_pmtargetgv) {
	ary = GvAVn(pm->op_pmreplrootu.op_pmtargetgv);
	goto have_av;
    }
#endif
    else if (pm->op_targ)
	ary = (AV *)PAD_SVl(pm->op_targ);
    if (ary) {
	have_av:
	realarray = 1;
	PUTBACK;
	av_extend(ary,0);
	(void)sv_2mortal(SvREFCNT_inc_simple_NN(sv));
	av_clear(ary);
	SPAGAIN;
	if ((mg = SvTIED_mg((const SV *)ary, PERL_MAGIC_tied))) {
	    PUSHMARK(SP);
	    XPUSHs(SvTIED_obj(MUTABLE_SV(ary), mg));
	}
	else {
	    if (!AvREAL(ary)) {
		I32 i;
		AvREAL_on(ary);
		AvREIFY_off(ary);
		for (i = AvFILLp(ary); i >= 0; i--)
		    AvARRAY(ary)[i] = &PL_sv_undef; /* don't free mere refs */
	    }
	    /* temporarily switch stacks */
	    SAVESWITCHSTACK(PL_curstack, ary);
	    make_mortal = 0;
	}
    }
    base = SP - PL_stack_base;
    orig = s;
    if (RX_EXTFLAGS(rx) & RXf_SKIPWHITE) {
	if (do_utf8) {
	    while (isSPACE_utf8(s))
		s += UTF8SKIP(s);
	}
	else if (get_regex_charset(RX_EXTFLAGS(rx)) == REGEX_LOCALE_CHARSET) {
	    while (isSPACE_LC(*s))
		s++;
	}
	else {
	    while (isSPACE(*s))
		s++;
	}
    }
    if (RX_EXTFLAGS(rx) & RXf_PMf_MULTILINE) {
	multiline = 1;
    }

    gimme_scalar = gimme == G_SCALAR && !ary;

    if (!limit)
	limit = maxiters + 2;
    if (RX_EXTFLAGS(rx) & RXf_WHITE) {
	while (--limit) {
	    m = s;
	    /* this one uses 'm' and is a negative test */
	    if (do_utf8) {
		while (m < strend && ! isSPACE_utf8(m) ) {
		    const int t = UTF8SKIP(m);
		    /* isSPACE_utf8 returns FALSE for malform utf8 */
		    if (strend - m < t)
			m = strend;
		    else
			m += t;
		}
	    }
	    else if (get_regex_charset(RX_EXTFLAGS(rx)) == REGEX_LOCALE_CHARSET)
            {
	        while (m < strend && !isSPACE_LC(*m))
		    ++m;
            } else {
                while (m < strend && !isSPACE(*m))
                    ++m;
            }  
	    if (m >= strend)
		break;

	    if (gimme_scalar) {
		iters++;
		if (m-s == 0)
		    trailing_empty++;
		else
		    trailing_empty = 0;
	    } else {
		dstr = newSVpvn_flags(s, m-s,
				      (do_utf8 ? SVf_UTF8 : 0) | make_mortal);
		XPUSHs(dstr);
	    }

	    /* skip the whitespace found last */
	    if (do_utf8)
		s = m + UTF8SKIP(m);
	    else
		s = m + 1;

	    /* this one uses 's' and is a positive test */
	    if (do_utf8) {
		while (s < strend && isSPACE_utf8(s) )
	            s +=  UTF8SKIP(s);
	    }
	    else if (get_regex_charset(RX_EXTFLAGS(rx)) == REGEX_LOCALE_CHARSET)
            {
	        while (s < strend && isSPACE_LC(*s))
		    ++s;
            } else {
                while (s < strend && isSPACE(*s))
                    ++s;
            } 	    
	}
    }
    else if (RX_EXTFLAGS(rx) & RXf_START_ONLY) {
	while (--limit) {
	    for (m = s; m < strend && *m != '\n'; m++)
		;
	    m++;
	    if (m >= strend)
		break;

	    if (gimme_scalar) {
		iters++;
		if (m-s == 0)
		    trailing_empty++;
		else
		    trailing_empty = 0;
	    } else {
		dstr = newSVpvn_flags(s, m-s,
				      (do_utf8 ? SVf_UTF8 : 0) | make_mortal);
		XPUSHs(dstr);
	    }
	    s = m;
	}
    }
    else if (RX_EXTFLAGS(rx) & RXf_NULL && !(s >= strend)) {
        /*
          Pre-extend the stack, either the number of bytes or
          characters in the string or a limited amount, triggered by:

          my ($x, $y) = split //, $str;
            or
          split //, $str, $i;
        */
	if (!gimme_scalar) {
	    const IV items = limit - 1;
            /* setting it to -1 will trigger a panic in EXTEND() */
            const SSize_t sslen = slen > SSize_t_MAX ?  -1 : (SSize_t)slen;
	    if (items >=0 && items < sslen)
		EXTEND(SP, items);
	    else
		EXTEND(SP, sslen);
	}

        if (do_utf8) {
            while (--limit) {
                /* keep track of how many bytes we skip over */
                m = s;
                s += UTF8SKIP(s);
		if (gimme_scalar) {
		    iters++;
		    if (s-m == 0)
			trailing_empty++;
		    else
			trailing_empty = 0;
		} else {
		    dstr = newSVpvn_flags(m, s-m, SVf_UTF8 | make_mortal);

		    PUSHs(dstr);
		}

                if (s >= strend)
                    break;
            }
        } else {
            while (--limit) {
	        if (gimme_scalar) {
		    iters++;
		} else {
		    dstr = newSVpvn(s, 1);


		    if (make_mortal)
			sv_2mortal(dstr);

		    PUSHs(dstr);
		}

                s++;

                if (s >= strend)
                    break;
            }
        }
    }
    else if (do_utf8 == (RX_UTF8(rx) != 0) &&
	     (RX_EXTFLAGS(rx) & RXf_USE_INTUIT) && !RX_NPARENS(rx)
	     && (RX_EXTFLAGS(rx) & RXf_CHECK_ALL)
             && !(RX_EXTFLAGS(rx) & RXf_IS_ANCHORED)) {
	const int tail = (RX_EXTFLAGS(rx) & RXf_INTUIT_TAIL);
	SV * const csv = CALLREG_INTUIT_STRING(rx);

	len = RX_MINLENRET(rx);
	if (len == 1 && !RX_UTF8(rx) && !tail) {
	    const char c = *SvPV_nolen_const(csv);
	    while (--limit) {
		for (m = s; m < strend && *m != c; m++)
		    ;
		if (m >= strend)
		    break;
		if (gimme_scalar) {
		    iters++;
		    if (m-s == 0)
			trailing_empty++;
		    else
			trailing_empty = 0;
		} else {
		    dstr = newSVpvn_flags(s, m-s,
					 (do_utf8 ? SVf_UTF8 : 0) | make_mortal);
		    XPUSHs(dstr);
		}
		/* The rx->minlen is in characters but we want to step
		 * s ahead by bytes. */
 		if (do_utf8)
		    s = (char*)utf8_hop((U8*)m, len);
 		else
		    s = m + len; /* Fake \n at the end */
	    }
	}
	else {
	    while (s < strend && --limit &&
	      (m = fbm_instr((unsigned char*)s, (unsigned char*)strend,
			     csv, multiline ? FBMrf_MULTILINE : 0)) )
	    {
		if (gimme_scalar) {
		    iters++;
		    if (m-s == 0)
			trailing_empty++;
		    else
			trailing_empty = 0;
		} else {
		    dstr = newSVpvn_flags(s, m-s,
					 (do_utf8 ? SVf_UTF8 : 0) | make_mortal);
		    XPUSHs(dstr);
		}
		/* The rx->minlen is in characters but we want to step
		 * s ahead by bytes. */
 		if (do_utf8)
		    s = (char*)utf8_hop((U8*)m, len);
 		else
		    s = m + len; /* Fake \n at the end */
	    }
	}
    }
    else {
	maxiters += slen * RX_NPARENS(rx);
	while (s < strend && --limit)
	{
	    I32 rex_return;
	    PUTBACK;
	    rex_return = CALLREGEXEC(rx, (char*)s, (char*)strend, (char*)orig, 1,
				     sv, NULL, 0);
	    SPAGAIN;
	    if (rex_return == 0)
		break;
	    TAINT_IF(RX_MATCH_TAINTED(rx));
            /* we never pass the REXEC_COPY_STR flag, so it should
             * never get copied */
            assert(!RX_MATCH_COPIED(rx));
	    m = RX_OFFS(rx)[0].start + orig;

	    if (gimme_scalar) {
		iters++;
		if (m-s == 0)
		    trailing_empty++;
		else
		    trailing_empty = 0;
	    } else {
		dstr = newSVpvn_flags(s, m-s,
				      (do_utf8 ? SVf_UTF8 : 0) | make_mortal);
		XPUSHs(dstr);
	    }
	    if (RX_NPARENS(rx)) {
		I32 i;
		for (i = 1; i <= (I32)RX_NPARENS(rx); i++) {
		    s = RX_OFFS(rx)[i].start + orig;
		    m = RX_OFFS(rx)[i].end + orig;

		    /* japhy (07/27/01) -- the (m && s) test doesn't catch
		       parens that didn't match -- they should be set to
		       undef, not the empty string */
		    if (gimme_scalar) {
			iters++;
			if (m-s == 0)
			    trailing_empty++;
			else
			    trailing_empty = 0;
		    } else {
			if (m >= orig && s >= orig) {
			    dstr = newSVpvn_flags(s, m-s,
						 (do_utf8 ? SVf_UTF8 : 0)
						  | make_mortal);
			}
			else
			    dstr = &PL_sv_undef;  /* undef, not "" */
			XPUSHs(dstr);
		    }

		}
	    }
	    s = RX_OFFS(rx)[0].end + orig;
	}
    }

    if (!gimme_scalar) {
	iters = (SP - PL_stack_base) - base;
    }
    if (iters > maxiters)
	DIE(aTHX_ "Split loop");

    /* keep field after final delim? */
    if (s < strend || (iters && origlimit)) {
	if (!gimme_scalar) {
	    const STRLEN l = strend - s;
	    dstr = newSVpvn_flags(s, l, (do_utf8 ? SVf_UTF8 : 0) | make_mortal);
	    XPUSHs(dstr);
	}
	iters++;
    }
    else if (!origlimit) {
	if (gimme_scalar) {
	    iters -= trailing_empty;
	} else {
	    while (iters > 0 && (!TOPs || !SvANY(TOPs) || SvCUR(TOPs) == 0)) {
		if (TOPs && !make_mortal)
		    sv_2mortal(TOPs);
		*SP-- = &PL_sv_undef;
		iters--;
	    }
	}
    }

    PUTBACK;
    LEAVE_SCOPE(oldsave); /* may undo an earlier SWITCHSTACK */
    SPAGAIN;
    if (realarray) {
	if (!mg) {
	    if (SvSMAGICAL(ary)) {
		PUTBACK;
		mg_set(MUTABLE_SV(ary));
		SPAGAIN;
	    }
	    if (gimme == G_ARRAY) {
		EXTEND(SP, iters);
		Copy(AvARRAY(ary), SP + 1, iters, SV*);
		SP += iters;
		RETURN;
	    }
	}
	else {
	    PUTBACK;
	    ENTER_with_name("call_PUSH");
	    call_sv(SV_CONST(PUSH),G_SCALAR|G_DISCARD|G_METHOD_NAMED);
	    LEAVE_with_name("call_PUSH");
	    SPAGAIN;
	    if (gimme == G_ARRAY) {
		SSize_t i;
		/* EXTEND should not be needed - we just popped them */
		EXTEND(SP, iters);
		for (i=0; i < iters; i++) {
		    SV **svp = av_fetch(ary, i, FALSE);
		    PUSHs((svp) ? *svp : &PL_sv_undef);
		}
		RETURN;
	    }
	}
    }
    else {
	if (gimme == G_ARRAY)
	    RETURN;
    }

    GETTARGET;
    PUSHi(iters);
    RETURN;
}

PP(pp_once)
{
    dSP;
    SV *const sv = PAD_SVl(PL_op->op_targ);

    if (SvPADSTALE(sv)) {
	/* First time. */
	SvPADSTALE_off(sv);
	RETURNOP(cLOGOP->op_other);
    }
    RETURNOP(cLOGOP->op_next);
}

PP(pp_lock)
{
    dSP;
    dTOPss;
    SV *retsv = sv;
    SvLOCK(sv);
    if (SvTYPE(retsv) == SVt_PVAV || SvTYPE(retsv) == SVt_PVHV
     || SvTYPE(retsv) == SVt_PVCV) {
	retsv = refto(retsv);
    }
    SETs(retsv);
    RETURN;
}


/* used for: pp_padany(), pp_mapstart(), pp_custom(); plus any system ops
 * that aren't implemented on a particular platform */

PP(unimplemented_op)
{
    const Optype op_type = PL_op->op_type;
    /* Using OP_NAME() isn't going to be helpful here. Firstly, it doesn't cope
       with out of range op numbers - it only "special" cases op_custom.
       Secondly, as the three ops we "panic" on are padmy, mapstart and custom,
       if we get here for a custom op then that means that the custom op didn't
       have an implementation. Given that OP_NAME() looks up the custom op
       by its pp_addr, likely it will return NULL, unless someone (unhelpfully)
       registers &PL_unimplemented_op as the address of their custom op.
       NULL doesn't generate a useful error message. "custom" does. */
    const char *const name = op_type >= OP_max
	? "[out of range]" : PL_op_name[PL_op->op_type];
    if(OP_IS_SOCKET(op_type))
	DIE(aTHX_ PL_no_sock_func, name);
    DIE(aTHX_ "panic: unimplemented op %s (#%d) called", name,	op_type);
}

/* For sorting out arguments passed to a &CORE:: subroutine */
PP(pp_coreargs)
{
    dSP;
    int opnum = SvIOK(cSVOP_sv) ? (int)SvUV(cSVOP_sv) : 0;
    int defgv = PL_opargs[opnum] & OA_DEFGV ||opnum==OP_GLOB, whicharg = 0;
    AV * const at_ = GvAV(PL_defgv);
    SV **svp = at_ ? AvARRAY(at_) : NULL;
    I32 minargs = 0, maxargs = 0, numargs = at_ ? AvFILLp(at_)+1 : 0;
    I32 oa = opnum ? PL_opargs[opnum] >> OASHIFT : 0;
    bool seen_question = 0;
    const char *err = NULL;
    const bool pushmark = PL_op->op_private & OPpCOREARGS_PUSHMARK;

    /* Count how many args there are first, to get some idea how far to
       extend the stack. */
    while (oa) {
	if ((oa & 7) == OA_LIST) { maxargs = I32_MAX; break; }
	maxargs++;
	if (oa & OA_OPTIONAL) seen_question = 1;
	if (!seen_question) minargs++;
	oa >>= 4;
    }

    if(numargs < minargs) err = "Not enough";
    else if(numargs > maxargs) err = "Too many";
    if (err)
	/* diag_listed_as: Too many arguments for %s */
	Perl_croak(aTHX_
	  "%s arguments for %s", err,
	   opnum ? PL_op_desc[opnum] : SvPV_nolen_const(cSVOP_sv)
	);

    /* Reset the stack pointer.  Without this, we end up returning our own
       arguments in list context, in addition to the values we are supposed
       to return.  nextstate usually does this on sub entry, but we need
       to run the next op with the caller's hints, so we cannot have a
       nextstate. */
    SP = PL_stack_base + CX_CUR()->blk_oldsp;

    if(!maxargs) RETURN;

    /* We do this here, rather than with a separate pushmark op, as it has
       to come in between two things this function does (stack reset and
       arg pushing).  This seems the easiest way to do it. */
    if (pushmark) {
	PUTBACK;
	(void)Perl_pp_pushmark(aTHX);
    }

    EXTEND(SP, maxargs == I32_MAX ? numargs : maxargs);
    PUTBACK; /* The code below can die in various places. */

    oa = PL_opargs[opnum] >> OASHIFT;
    for (; oa&&(numargs||!pushmark); (void)(numargs&&(++svp,--numargs))) {
	whicharg++;
	switch (oa & 7) {
	case OA_SCALAR:
	  try_defsv:
	    if (!numargs && defgv && whicharg == minargs + 1) {
		PUSHs(DEFSV);
	    }
	    else PUSHs(numargs ? svp && *svp ? *svp : &PL_sv_undef : NULL);
	    break;
	case OA_LIST:
	    while (numargs--) {
		PUSHs(svp && *svp ? *svp : &PL_sv_undef);
		svp++;
	    }
	    RETURN;
	case OA_HVREF:
	    if (!svp || !*svp || !SvROK(*svp)
	     || SvTYPE(SvRV(*svp)) != SVt_PVHV)
		DIE(aTHX_
		/* diag_listed_as: Type of arg %d to &CORE::%s must be %s*/
		 "Type of arg %d to &CORE::%s must be hash reference",
		  whicharg, OP_DESC(PL_op->op_next)
		);
	    PUSHs(SvRV(*svp));
	    break;
	case OA_FILEREF:
	    if (!numargs) PUSHs(NULL);
	    else if(svp && *svp && SvROK(*svp) && isGV_with_GP(SvRV(*svp)))
		/* no magic here, as the prototype will have added an extra
		   refgen and we just want what was there before that */
		PUSHs(SvRV(*svp));
	    else {
		const bool constr = PL_op->op_private & whicharg;
		PUSHs(S_rv2gv(aTHX_
		    svp && *svp ? *svp : &PL_sv_undef,
		    constr, cBOOL(CopHINTS_get(PL_curcop) & HINT_STRICT_REFS),
		    !constr
		));
	    }
	    break;
	case OA_SCALARREF:
	  if (!numargs) goto try_defsv;
	  else {
	    const bool wantscalar =
		PL_op->op_private & OPpCOREARGS_SCALARMOD;
	    if (!svp || !*svp || !SvROK(*svp)
	        /* We have to permit globrefs even for the \$ proto, as
	           *foo is indistinguishable from ${\*foo}, and the proto-
	           type permits the latter. */
	     || SvTYPE(SvRV(*svp)) > (
	             wantscalar       ? SVt_PVLV
	           : opnum == OP_LOCK || opnum == OP_UNDEF
	                              ? SVt_PVCV
	           :                    SVt_PVHV
	        )
	       )
		DIE(aTHX_
		 "Type of arg %d to &CORE::%s must be %s",
		  whicharg, PL_op_name[opnum],
		  wantscalar
		    ? "scalar reference"
		    : opnum == OP_LOCK || opnum == OP_UNDEF
		       ? "reference to one of [$@@%&*]"
		       : "reference to one of [$@@%*]"
		);
	    PUSHs(SvRV(*svp));
	    if (opnum == OP_UNDEF && SvRV(*svp) == (SV *)PL_defgv
	     && CX_CUR()->cx_type & CXp_HASARGS) {
		/* Undo @@_ localisation, so that sub exit does not undo
		   part of our undeffing. */
		PERL_CONTEXT *cx = CX_CUR();

                assert(CxHASARGS(cx));
                cx_popsub_args(cx);;
		cx->cx_type &= ~CXp_HASARGS;
	    }
	  }
	  break;
	default:
	    DIE(aTHX_ "panic: unknown OA_*: %x", (unsigned)(oa&7));
	}
	oa = oa >> 4;
    }

    RETURN;
}

PP(pp_runcv)
{
    dSP;
    CV *cv;
    if (PL_op->op_private & OPpOFFBYONE) {
	cv = find_runcv_where(FIND_RUNCV_level_eq, 1, NULL);
    }
    else cv = find_runcv(NULL);
    XPUSHs(CvEVAL(cv) ? &PL_sv_undef : sv_2mortal(newRV((SV *)cv)));
    RETURN;
}

static void
S_localise_aelem_lval(pTHX_ AV * const av, SV * const keysv,
			    const bool can_preserve)
{
    const SSize_t ix = SvIV(keysv);
    if (can_preserve ? av_exists(av, ix) : TRUE) {
	SV ** const svp = av_fetch(av, ix, 1);
	if (!svp || !*svp)
	    Perl_croak(aTHX_ PL_no_aelem, ix);
	save_aelem(av, ix, svp);
    }
    else
	SAVEADELETE(av, ix);
}

static void
S_localise_helem_lval(pTHX_ HV * const hv, SV * const keysv,
			    const bool can_preserve)
{
    if (can_preserve ? hv_exists_ent(hv, keysv, 0) : TRUE) {
	HE * const he = hv_fetch_ent(hv, keysv, 1, 0);
	SV ** const svp = he ? &HeVAL(he) : NULL;
	if (!svp || !*svp)
	    Perl_croak(aTHX_ PL_no_helem_sv, SVfARG(keysv));
	save_helem_flags(hv, keysv, svp, 0);
    }
    else
	SAVEHDELETE(hv, keysv);
}

static void
S_localise_gv_slot(pTHX_ GV *gv, U8 type)
{
    if (type == OPpLVREF_SV) {
	save_pushptrptr(gv, SvREFCNT_inc_simple(GvSV(gv)), SAVEt_GVSV);
	GvSV(gv) = 0;
    }
    else if (type == OPpLVREF_AV)
	/* XXX Inefficient, as it creates a new AV, which we are
	       about to clobber.  */
	save_ary(gv);
    else {
	assert(type == OPpLVREF_HV);
	/* XXX Likewise inefficient.  */
	save_hash(gv);
    }
}


PP(pp_refassign)
{
    dSP;
    SV * const key = PL_op->op_private & OPpLVREF_ELEM ? POPs : NULL;
    SV * const left = PL_op->op_flags & OPf_STACKED ? POPs : NULL;
    dTOPss;
    const char *bad = NULL;
    const U8 type = PL_op->op_private & OPpLVREF_TYPE;
    if (!SvROK(sv)) DIE(aTHX_ "Assigned value is not a reference");
    switch (type) {
    case OPpLVREF_SV:
	if (SvTYPE(SvRV(sv)) > SVt_PVLV)
	    bad = " SCALAR";
	break;
    case OPpLVREF_AV:
	if (SvTYPE(SvRV(sv)) != SVt_PVAV)
	    bad = "n ARRAY";
	break;
    case OPpLVREF_HV:
	if (SvTYPE(SvRV(sv)) != SVt_PVHV)
	    bad = " HASH";
	break;
    case OPpLVREF_CV:
	if (SvTYPE(SvRV(sv)) != SVt_PVCV)
	    bad = " CODE";
    }
    if (bad)
	/* diag_listed_as: Assigned value is not %s reference */
	DIE(aTHX_ "Assigned value is not a%s reference", bad);
    {
    MAGIC *mg;
    HV *stash;
    switch (left ? SvTYPE(left) : 0) {
    case 0:
    {
	SV * const old = PAD_SV(ARGTARG);
	PAD_SETSV(ARGTARG, SvREFCNT_inc_NN(SvRV(sv)));
	SvREFCNT_dec(old);
	if ((PL_op->op_private & (OPpLVAL_INTRO|OPpPAD_STATE))
		== OPpLVAL_INTRO)
	    SAVECLEARSV(PAD_SVl(ARGTARG));
	break;
    }
    case SVt_PVGV:
	if (PL_op->op_private & OPpLVAL_INTRO) {
	    S_localise_gv_slot(aTHX_ (GV *)left, type);
	}
	gv_setref(left, sv);
	SvSETMAGIC(left);
	break;
    case SVt_PVAV:
        assert(key);
	if (UNLIKELY(PL_op->op_private & OPpLVAL_INTRO)) {
	    S_localise_aelem_lval(aTHX_ (AV *)left, key,
					SvCANEXISTDELETE(left));
	}
	av_store((AV *)left, SvIV(key), SvREFCNT_inc_simple_NN(SvRV(sv)));
	break;
    case SVt_PVHV:
        if (UNLIKELY(PL_op->op_private & OPpLVAL_INTRO)) {
            assert(key);
	    S_localise_helem_lval(aTHX_ (HV *)left, key,
					SvCANEXISTDELETE(left));
        }
	(void)hv_store_ent((HV *)left, key, SvREFCNT_inc_simple_NN(SvRV(sv)), 0);
    }
    if (PL_op->op_flags & OPf_MOD)
	SETs(sv_2mortal(newSVsv(sv)));
    /* XXX else can weak references go stale before they are read, e.g.,
       in leavesub?  */
    RETURN;
    }
}

PP(pp_lvref)
{
    dSP;
    SV * const ret = sv_2mortal(newSV_type(SVt_PVMG));
    SV * const elem = PL_op->op_private & OPpLVREF_ELEM ? POPs : NULL;
    SV * const arg = PL_op->op_flags & OPf_STACKED ? POPs : NULL;
    MAGIC * const mg = sv_magicext(ret, arg, PERL_MAGIC_lvref,
				   &PL_vtbl_lvref, (char *)elem,
				   elem ? HEf_SVKEY : (I32)ARGTARG);
    mg->mg_private = PL_op->op_private;
    if (PL_op->op_private & OPpLVREF_ITER)
	mg->mg_flags |= MGf_PERSIST;
    if (UNLIKELY(PL_op->op_private & OPpLVAL_INTRO)) {
      if (elem) {
        MAGIC *mg;
        HV *stash;
        assert(arg);
        {
            const bool can_preserve = SvCANEXISTDELETE(arg);
            if (SvTYPE(arg) == SVt_PVAV)
              S_localise_aelem_lval(aTHX_ (AV *)arg, elem, can_preserve);
            else
              S_localise_helem_lval(aTHX_ (HV *)arg, elem, can_preserve);
        }
      }
      else if (arg) {
	S_localise_gv_slot(aTHX_ (GV *)arg, 
				 PL_op->op_private & OPpLVREF_TYPE);
      }
      else if (!(PL_op->op_private & OPpPAD_STATE))
	SAVECLEARSV(PAD_SVl(ARGTARG));
    }
    XPUSHs(ret);
    RETURN;
}

PP(pp_lvrefslice)
{
    dSP; dMARK;
    AV * const av = (AV *)POPs;
    const bool localizing = PL_op->op_private & OPpLVAL_INTRO;
    bool can_preserve = FALSE;

    if (UNLIKELY(localizing)) {
	MAGIC *mg;
	HV *stash;
	SV **svp;

	can_preserve = SvCANEXISTDELETE(av);

	if (SvTYPE(av) == SVt_PVAV) {
	    SSize_t max = -1;

	    for (svp = MARK + 1; svp <= SP; svp++) {
		const SSize_t elem = SvIV(*svp);
		if (elem > max)
		    max = elem;
	    }
	    if (max > AvMAX(av))
		av_extend(av, max);
	}
    }

    while (++MARK <= SP) {
	SV * const elemsv = *MARK;
	if (SvTYPE(av) == SVt_PVAV)
	    S_localise_aelem_lval(aTHX_ av, elemsv, can_preserve);
	else
	    S_localise_helem_lval(aTHX_ (HV *)av, elemsv, can_preserve);
	*MARK = sv_2mortal(newSV_type(SVt_PVMG));
	sv_magic(*MARK,(SV *)av,PERL_MAGIC_lvref,(char *)elemsv,HEf_SVKEY);
    }
    RETURN;
}

PP(pp_lvavref)
{
    if (PL_op->op_flags & OPf_STACKED)
	Perl_pp_rv2av(aTHX);
    else
	Perl_pp_padav(aTHX);
    {
	dSP;
	dTOPss;
	SETs(0); /* special alias marker that aassign recognises */
	XPUSHs(sv);
	RETURN;
    }
}

PP(pp_anonconst)
{
    dSP;
    dTOPss;
    SETs(sv_2mortal((SV *)newCONSTSUB(SvTYPE(CopSTASH(PL_curcop))==SVt_PVHV
					? CopSTASH(PL_curcop)
					: NULL,
				      NULL, SvREFCNT_inc_simple_NN(sv))));
    RETURN;
}

/*
 * ex: set ts=8 sts=4 sw=4 et:
 */
@


1.23
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@d3133 1
d3137 1
a3139 1
    (void)seedDrand01((Rand_seed_t)anum);
@


1.22
log
@The expected behavior of Perl srand(0) is a deterministic pseudo
random stream.  Only srand() should give real random values.  Make
our pimped Perl more compatible with the rest of the world.
OK afresh1@@ millert@@
@
text
@a56 1
    dVAR;
d65 1
d68 2
a69 2
    dVAR; dSP; dTARGET;
    I32 gimme;
d75 1
d79 9
a87 8
    } else if (PL_op->op_private & OPpMAYBE_LVSUB) {
       const I32 flags = is_lvalue_sub();
       if (flags && !(flags & OPpENTERSUB_INARGS)) {
	if (GIMME == G_SCALAR)
	    /* diag_listed_as: Can't return %s to lvalue scalar context */
	    Perl_croak(aTHX_ "Can't return array to lvalue scalar context");
	PUSHs(TARG);
	RETURN;
d90 1
d94 1
a94 1
	const Size_t maxarg = AvFILL(MUTABLE_AV(TARG)) + 1;
d97 1
a97 1
	    Size_t i;
d104 2
a105 2
	    PADOFFSET i;
	    for (i=0; i < (PADOFFSET)maxarg; i++) {
d123 2
a124 2
    dVAR; dSP; dTARGET;
    I32 gimme;
d131 1
d135 7
a141 7
      const I32 flags = is_lvalue_sub();
      if (flags && !(flags & OPpENTERSUB_INARGS)) {
	if (GIMME == G_SCALAR)
	    /* diag_listed_as: Can't return %s to lvalue scalar context */
	    Perl_croak(aTHX_ "Can't return hash to lvalue scalar context");
	RETURN;
      }
d143 1
d151 2
a152 1
	  && (!SvRMAGICAL(TARG) || !mg_find(TARG, PERL_MAGIC_tied)))
d163 1
a163 1
    dVAR; dSP; dTARGET;
d171 1
a171 1
    dVAR; dTARGET;
d178 4
a181 4
    dVAR; dTARGET;
    MAGIC * const mg =
	mg_find(PadlistNAMESARRAY(CvPADLIST(find_runcv(NULL)))[ARGTARG],
		PERL_MAGIC_proto);
d183 2
a184 3
    assert(mg);
    assert(mg->mg_obj);
    if (CvISXSUB(mg->mg_obj)) { /* constant */
d189 1
a189 1
	PAD_SVl(ARGTARG) = SvREFCNT_inc_simple_NN(mg->mg_obj);
d192 3
a194 3
	if (CvROOT(mg->mg_obj)) {
	    assert(CvCLONE(mg->mg_obj));
	    assert(!CvCLONED(mg->mg_obj));
d196 1
a196 1
	cv_clone_into((CV *)mg->mg_obj,(CV *)TARG);
a203 3
static const char S_no_symref_sv[] =
    "Can't use string (\"%" SVf32 "\"%s) as %s ref while \"strict refs\" in use";

a215 1
    dVAR;
d230 3
a232 2
	else if (!isGV_with_GP(sv))
	    return (SV *)Perl_die(aTHX_ "Not a GLOB reference");
d255 1
d263 3
a265 2
		if (PL_op->op_flags & OPf_REF || strict)
		    return (SV *)Perl_die(aTHX_ PL_no_usym, "a symbol");
d278 8
a285 8
		if (strict)
		    return
		     (SV *)Perl_die(aTHX_
		            S_no_symref_sv,
		            sv,
		            (SvPOKp(sv) && SvCUR(sv)>32 ? "..." : ""),
		            "a symbol"
		           );
d310 1
a310 1
    dVAR; dSP; dTOPss;
a328 1
    dVAR;
d335 1
a335 1
	    Perl_die(aTHX_ S_no_symref_sv, sv,
d371 1
a371 1
    dVAR; dSP; dTOPss;
d381 1
a381 6
	switch (SvTYPE(sv)) {
	case SVt_PVAV:
	case SVt_PVHV:
	case SVt_PVCV:
	case SVt_PVFM:
	case SVt_PVIO:
a382 2
	default: NOOP;
	}
d412 1
a412 1
    dVAR; dSP;
d416 4
a419 4
	SV ** const sv = Perl_av_arylen_p(aTHX_ MUTABLE_AV(av));
	if (!*sv) {
	    *sv = newSV_type(SVt_PVMG);
	    sv_magic(*sv, MUTABLE_SV(av), PERL_MAGIC_arylen, NULL, 0);
d421 1
a421 1
	SETs(*sv);
d430 1
a430 1
    dVAR; dSP; dPOPss;
d437 1
a437 2
	PUSHs(ret);    /* no SvSETMAGIC */
	RETURN;
d446 2
a447 2
		PUSHu(i);
		RETURN;
d449 1
a449 1
	    RETPUSHUNDEF;
d451 1
d456 1
a456 1
    dVAR; dSP;
d471 3
a473 1
	cv = MUTABLE_CV(gv);
d478 1
a478 1
    RETURN;
d483 1
a483 1
    dVAR; dSP;
d516 1
a516 1
    dVAR; dSP;
d527 1
a527 1
    dVAR; dSP;
d529 1
a529 1
    RETURN;
d534 2
a535 2
    dVAR; dSP; dMARK;
    if (GIMME != G_ARRAY) {
d539 2
d542 1
a555 1
    dVAR;
a574 1
        assert(!IS_PADGV(sv));
d590 2
a591 2
    dVAR; dSP; dTARGET;
    SV * const sv = POPs;
d595 8
a602 1
	RETPUSHNO;
d604 1
a604 3
    (void)sv_ref(TARG,SvRV(sv),TRUE);
    PUSHTARG;
    RETURN;
d609 1
a609 1
    dVAR; dSP;
d650 1
a650 1
    dVAR; dSP;
d655 1
a655 1
    GV * const gv = MUTABLE_GV(POPs);
a677 2
		/* finally deprecated in 5.8.0 */
		deprecate("*glob{FILEHANDLE}");
d719 1
a719 1
    XPUSHs(sv);
d727 1
a727 1
    dVAR; dSP; dPOPss;
d733 2
a734 1
	RETPUSHNO;
d739 2
a740 1
    RETPUSHYES;
d743 3
d748 1
a748 1
    dVAR; dSP; dTARG;
a752 2
    else if (PL_op->op_private & OPpTARGET_MY)
	sv = GETTARGET;
a753 1
	sv = DEFSV;
d755 5
d769 2
a770 2
	TARG = sv_newmortal();
	PUSHi(do_trans(sv));
d777 1
a777 1
static void
a779 1
    dVAR;
d782 1
d787 1
a787 1
	return;
d796 1
a796 1
		do_chomp(retval, sv, chomping);
d798 1
a798 1
        return;
d805 2
a806 2
            do_chomp(retval, hv_iterval(hv,entry), chomping);
	return;
a810 3
    else if (SvIsCOW(sv)) {
	sv_force_normal_flags(sv, 0);
    }
d812 1
a812 1
    if (PL_encoding) {
d819 1
a819 1
	    sv_recode_to_utf8(sv, PL_encoding);
a824 3
	char *temp_buffer = NULL;
	SV *svrecode = NULL;

d826 2
d831 2
a832 2
		    goto nope;
		++SvIVX(retval);
d836 1
a836 1
		    ++SvIVX(retval);
d855 3
a857 1
			    /* Cannot downgrade, therefore cannot possibly match
d860 1
a860 2
			    temp_buffer = NULL;
			    goto nope;
d864 1
a864 1
		    else if (PL_encoding) {
d868 1
a868 1
			sv_recode_to_utf8(svrecode, PL_encoding);
d880 2
a881 2
			goto nope;
		    ++SvIVX(retval);
d885 1
a885 1
			goto nope;
d889 2
a890 2
			goto nope;
		    SvIVX(retval) += rs_charlen;
d893 1
a893 1
	    s = SvPV_force_nomg_nolen(sv);
d898 6
a904 5
    nope:

	SvREFCNT_dec(svrecode);

	Safefree(temp_buffer);
d906 1
a906 1
	if (len && !SvPOK(sv))
d938 1
d941 3
d946 1
a946 1
    dVAR; dSP; dTARGET;
d949 1
d951 1
a951 2
	sv_setiv(TARG, 0);
    do_chomp(TARG, TOPs, chomping);
d953 1
a953 1
    RETURN;
d956 3
d961 1
a961 1
    dVAR; dSP; dMARK; dTARGET; dORIGMARK;
d963 1
d965 2
d968 1
a968 3
	sv_setiv(TARG, 0);
    while (MARK < SP)
	do_chomp(TARG, *++MARK, chomping);
d976 1
a976 1
    dVAR; dSP;
d984 1
a984 1
    sv = POPs;
d986 4
a989 1
	RETPUSHUNDEF;
d991 2
a992 1
    SV_CHECK_THINKFIRST_COW_DROP(sv);
a1016 1
	{
d1018 1
a1018 10
	    GV* const gv = CvGV((const CV *)sv);
	    HEK * const hek = CvNAME_HEK((CV *)sv);
	    if (hek) share_hek_hek(hek);
	    cv_undef(MUTABLE_CV(sv));
	    if (gv) CvGV_set(MUTABLE_CV(sv), gv);
	    else if (hek) {
		SvANY((CV *)sv)->xcv_gv_u.xcv_hek = hek;
		CvNAMED_on(sv);
	    }
	}
d1074 2
a1075 1
    RETPUSHUNDEF;
d1078 5
a1082 1
PP(pp_postinc)
d1084 1
a1084 1
    dVAR; dSP; dTARGET;
d1087 2
a1088 3
    if (SvTYPE(TOPs) >= SVt_PVAV || (isGV_with_GP(TOPs) && !SvFAKE(TOPs)))
	Perl_croak_no_modify();
    if (SvROK(TOPs))
d1090 6
a1095 11
    sv_setsv(TARG, TOPs);
    if (!SvREADONLY(TOPs) && !SvGMAGICAL(TOPs) && SvIOK_notUV(TOPs) && !SvNOK(TOPs) && !SvPOK(TOPs)
        && SvIVX(TOPs) != (inc ? IV_MAX : IV_MIN))
    {
	SvIV_set(TOPs, SvIVX(TOPs) + (inc ? 1 : -1));
	SvFLAGS(TOPs) &= ~(SVp_NOK|SVp_POK);
    }
    else if (inc)
	sv_inc_nomg(TOPs);
    else sv_dec_nomg(TOPs);
    SvSETMAGIC(TOPs);
d1099 1
a1099 1
    SETs(TARG);
d1103 51
d1158 1
a1158 1
    dVAR; dSP; dATARGET; SV *svl, *svr;
d1325 1
a1325 1
    dVAR; dSP; dATARGET; SV *svl, *svr;
d1329 1
d1331 61
d1415 2
a1416 1
		    alow = -aiv; /* abs, auvok == false records sign */
d1427 2
a1428 1
		    blow = -biv; /* abs, buvok == false records sign */
d1454 4
d1495 2
a1496 1
			    SETi( -(IV)product_low );
d1508 2
d1511 6
a1516 1
      SETn( left * right );
d1523 1
a1523 1
    dVAR; dSP; dATARGET; SV *svl, *svr;
d1565 1
a1565 1
                    right = -biv;
d1586 1
a1586 1
                    left = -aiv;
d1616 1
a1616 1
                        SETi( -(IV)result );
d1643 1
a1643 1
    dVAR; dSP; dATARGET;
d1666 1
a1666 1
                    right = -biv;
d1696 1
a1696 1
                        left = -aiv;
d1770 1
a1770 1
    dVAR; dSP; dATARGET;
d1773 1
d1775 1
a1775 1
    if (GIMME == G_ARRAY && PL_op->op_private & OPpREPEAT_DOLIST) {
d1781 19
d1812 1
a1812 5
	      const IV iv = SvIV_nomg(sv);
	      if (iv < 0)
		   count = 0;
	      else
		   count = iv;
d1816 10
a1825 5
	 const NV nv = SvNV_nomg(sv);
	 if (nv < 0.0)
	      count = 0;
	 else
	      count = (IV)nv;
d1828 10
a1837 1
	 count = SvIV_nomg(sv);
d1839 1
a1839 1
    if (GIMME == G_ARRAY && PL_op->op_private & OPpREPEAT_DOLIST) {
d1841 1
a1841 3
	static const char* const oom_list_extend = "Out of memory during list extend";
	const I32 items = SP - MARK;
	const I32 max = items * count;
a1843 5
	MEM_WRAP_CHECK_1(max, SV*, oom_list_extend);
	/* Did the max computation overflow? */
	if (items > 0 && max > 0 && (max < items || max < count))
	   Perl_croak(aTHX_ "%s", oom_list_extend);
	MEXTEND(MARK, max);
d1845 10
a1855 24
#if 0
	      /* This code was intended to fix 20010809.028:

	         $x = 'abcd';
		 for (($x =~ /./g) x 2) {
		     print chop; # "abcdabcd" expected as output.
		 }

	       * but that change (#11635) broke this code:

	       $x = [("foo")x2]; # only one "foo" ended up in the anonlist.

	       * I can't think of a better fix that doesn't introduce
	       * an efficiency hit by copying the SVs. The stack isn't
	       * refcounted, and mortalisation obviously doesn't
	       * Do The Right Thing when the stack has more than
	       * one pointer to the same mortal value.
	       * .robin.
	       */
		if (*SP) {
		    *SP = sv_2mortal(newSVsv(*SP));
		    SvREADONLY_on(*SP);
		}
#else
a1857 1
                       assert(!IS_PADGV(*SP));
a1861 1
#endif
d1870 1
a1870 1
	    SP -= items;
a1875 2
	static const char* const oom_string_extend =
	  "Out of memory during string extend";
d1885 10
a1894 5
		const STRLEN max = (UV)count * len;
		if (len > MEM_SIZE_MAX / count)
		     Perl_croak(aTHX_ "%s", oom_string_extend);
	        MEM_WRAP_CHECK_1(max, char, oom_string_extend);
		SvGROW(TARG, max + 1);
a1904 9
	if (PL_op->op_private & OPpREPEAT_DOLIST) {
	    /* The parser saw this as a list repeat, and there
	       are probably several items on the stack. But we're
	       in scalar context, and there's no pp_list to save us
	       now. So drop the rest of the items -- robin@@kitsite.com
	     */
	    dMARK;
	    SP = MARK;
	}
d1912 1
a1912 1
    dVAR; dSP; dATARGET; bool useleft; SV *svl, *svr;
d1916 51
a1967 1
#ifdef PERL_PRESERVE_IVUV
d1993 1
a1993 1
			auv = (UV)-aiv;
d2013 1
a2013 1
		    buv = (UV)-biv;
d2054 2
a2055 1
			SETi( -(IV)result );
d2065 2
d2082 31
d2115 1
a2115 1
    dVAR; dSP; dATARGET; SV *svl, *svr;
d2122 1
a2122 2
	const IV i = SvIV_nomg(svl);
	SETi(i << shift);
d2125 1
a2125 2
	const UV u = SvUV_nomg(svl);
	SETu(u << shift);
d2133 1
a2133 1
    dVAR; dSP; dATARGET; SV *svl, *svr;
d2140 1
a2140 2
	const IV i = SvIV_nomg(svl);
	SETi(i >> shift);
d2143 1
a2143 2
	const UV u = SvUV_nomg(svl);
	SETu(u >> shift);
d2151 1
a2151 1
    dVAR; dSP;
d2167 1
a2167 1
    dVAR; dSP;
d2183 1
a2183 1
    dVAR; dSP;
d2199 1
a2199 1
    dVAR; dSP;
d2215 1
a2215 1
    dVAR; dSP;
a2237 2
    dVAR;

d2276 1
a2276 1
	    assert(0); /* NOTREACHED */
d2303 1
a2303 1
    dVAR; dSP;
d2320 3
d2325 1
a2325 1
    dVAR; dSP;
d2353 7
a2359 3
      const int cmp = (IN_LOCALE_RUNTIME
		 ? sv_cmp_locale_flags(left, right, 0)
		 : sv_cmp_flags(left, right, 0));
d2367 1
a2367 1
    dVAR; dSP;
d2378 1
a2378 1
    dVAR; dSP;
d2389 1
a2389 1
    dVAR; dSP; dTARGET;
d2393 7
a2399 3
      const int cmp = (IN_LOCALE_RUNTIME
		 ? sv_cmp_locale_flags(left, right, 0)
		 : sv_cmp_flags(left, right, 0));
d2407 1
a2407 1
    dVAR; dSP; dATARGET;
d2433 31
d2466 1
a2466 1
    dVAR; dSP; dATARGET;
d2498 44
d2561 1
a2561 1
    SETTARG; PUTBACK;
d2567 1
a2567 1
    dVAR; dSP; dTARGET;
d2581 1
a2581 1
		    RETURN;
d2585 1
a2585 1
		    RETURN;
d2590 1
a2590 1
		RETURN;
d2595 1
a2595 1
		RETURN;
d2606 1
a2606 1
    RETURN;
d2611 1
a2611 1
    dVAR; dSP;
d2617 2
a2618 1
PP(pp_complement)
a2619 15
    dVAR; dSP; dTARGET;
    tryAMAGICun_MG(compl_amg, AMGf_numeric);
    {
      dTOPss;
      if (SvNIOKp(sv)) {
	if (PL_op->op_private & HINT_INTEGER) {
	  const IV i = ~SvIV_nomg(sv);
	  SETi(i);
	}
	else {
	  const UV u = ~SvUV_nomg(sv);
	  SETu(u);
	}
      }
      else {
d2640 1
a2640 1
	    targlen += UNISKIP(~c);
d2653 2
d2682 1
a2682 2
	  SETTARG;
	  RETURN;
d2688 48
a2735 5
		*tmps = ~*tmps;
	    tmpl = (long*)tmps;
	    for ( ; anum >= (I32)sizeof(long); anum -= (I32)sizeof(long), tmpl++)
		*tmpl = ~*tmpl;
	    tmps = (U8*)tmpl;
d2737 11
a2747 3
#endif
	for ( ; anum > 0; anum--, tmps++)
	    *tmps = ~*tmps;
d2749 1
a2749 2
      }
      RETURN;
d2757 1
a2757 1
    dVAR; dSP; dATARGET;
d2769 1
a2769 1
    dVAR; dSP; dATARGET;
d2788 2
a2789 1
#if defined(__GLIBC__) && IVSIZE == 8 && !defined(PERL_DEBUG_READONLY_OPS)
d2797 1
a2797 1
     dVAR; dSP; dATARGET;
d2812 2
a2813 1
#if defined(__GLIBC__) && IVSIZE == 8 && !defined(PERL_DEBUG_READONLY_OPS)
d2821 1
a2821 1
     dVAR; dSP; dATARGET;
d2849 1
a2849 1
	   * (at least glicb 2.2.5 is known to have this bug), in other
d2882 1
a2882 1
    dVAR; dSP; dATARGET;
d2893 1
a2893 1
    dVAR; dSP; dATARGET;
d2904 1
a2904 1
    dVAR; dSP;
d2915 1
a2915 1
    dVAR; dSP;
d2926 1
a2926 1
    dVAR; dSP;
d2937 1
a2937 1
    dVAR; dSP;
d2948 1
a2948 1
    dVAR; dSP;
d2959 1
a2959 1
    dVAR; dSP;
d2970 1
a2970 1
    dVAR; dSP; dTARGET;
d2989 1
a2989 1
    dVAR; dSP; dTARGET;
d2996 1
a2996 1
	RETURN;
d3004 1
a3004 1
    dVAR; dSP; dTARGET;
d3013 3
d3018 2
a3019 2
    dVAR; dSP; dTARGET;
    int amg_type = sin_amg;
a3020 1
    NV (*func)(NV) = Perl_sin;
d3024 5
a3028 18
    case OP_COS:
	amg_type = cos_amg;
	func = Perl_cos;
	break;
    case OP_EXP:
	amg_type = exp_amg;
	func = Perl_exp;
	break;
    case OP_LOG:
	amg_type = log_amg;
	func = Perl_log;
	neg_report = "log";
	break;
    case OP_SQRT:
	amg_type = sqrt_amg;
	func = Perl_sqrt;
	neg_report = "sqrt";
	break;
d3031 1
d3035 1
a3035 1
      SV * const arg = POPs;
d3037 7
a3043 2
      if (neg_report) {
	  if (op_type == OP_LOG ? (value <= 0.0) : (value < 0.0)) {
d3049 10
a3058 2
      XPUSHn(func(value));
      RETURN;
a3074 1
    dVAR;
a3081 1
	EXTEND(SP, 1);
d3084 2
d3087 1
d3096 3
d3100 1
d3115 1
a3115 1
    dVAR; dSP; dTARGET;
a3132 1
        (void)srand48_deterministic((Rand_seed_t)anum);
a3135 1
        (void)seedDrand01((Rand_seed_t)anum);
d3138 1
d3153 1
a3153 1
    dVAR; dSP; dTARGET;
d3174 3
a3176 1
	  if (value >= 0.0) {
d3192 1
a3192 1
    RETURN;
d3197 1
a3197 1
    dVAR; dSP; dTARGET;
d3220 1
a3220 1
	      SETu(IV_MIN);
d3232 1
a3232 1
    RETURN;
d3235 3
d3240 1
a3240 1
    dVAR; dSP; dTARGET;
d3246 1
a3246 1
    SV* const sv = POPs;
d3265 1
a3265 1
    if (*tmps == 'x' || *tmps == 'X') {
d3269 1
a3269 1
    else if (*tmps == 'b' || *tmps == 'B')
d3275 1
a3275 1
        XPUSHn(result_nv);
d3278 1
a3278 1
        XPUSHu(result_uv);
d3280 1
a3280 1
    RETURN;
d3287 1
a3287 1
    dVAR; dSP; dTARGET;
d3290 11
a3300 1
    SvGETMAGIC(sv);
d3302 2
a3303 2
	if (!IN_BYTES)
	    SETi(sv_len_utf8_nomg(sv));
d3307 8
a3314 2
	    (void)SvPV_nomg_const(sv,len);
	    SETi(len);
d3319 6
a3324 3
	    SETTARG;
	}
	SETs(&PL_sv_undef);
d3326 3
a3328 1
    RETURN;
d3336 4
a3339 4
Perl_translate_substr_offsets(pTHX_ STRLEN curlen, IV pos1_iv,
				    bool pos1_is_uv, IV len_iv,
				    bool len_is_uv, STRLEN *posp,
				    STRLEN *lenp)
d3400 1
a3400 1
    dVAR; dSP; dTARGET;
a3436 1
    PUTBACK;
a3451 1
	SPAGAIN;
d3521 3
a3523 2
    SPAGAIN;
    if (rvalue) {
d3529 1
a3529 1
bound_fail:
d3538 1
a3538 1
    dVAR; dSP;
d3560 2
d3566 3
d3571 1
a3571 1
    dVAR; dSP; dTARGET;
d3577 2
a3578 2
    I32 offset;
    I32 retval;
d3597 1
a3597 1
	if (little_utf8 && !PL_encoding) {
d3619 2
a3620 2
	    if (PL_encoding) {
		sv_recode_to_utf8(temp, PL_encoding);
d3649 1
a3649 1
	   This is all getting to messy. The API isn't quite clean enough,
d3661 1
a3661 1
	    sv_pos_u2b(big, &offset, 0);
d3667 1
a3667 1
    else if (offset > (I32)biglen)
d3677 2
a3678 2
	if (retval > 0 && big_utf8)
	    sv_pos_b2u(big, &retval);
d3688 1
a3688 1
    dVAR; dSP; dMARK; dORIGMARK; dTARGET;
d3699 1
a3699 1
    dVAR; dSP; dTARGET;
d3701 1
a3701 1
    SV *argsv = POPs;
d3705 1
a3705 1
    if (PL_encoding && SvPOK(argsv) && !DO_UTF8(argsv)) {
d3707 1
a3707 1
        s = (U8*)sv_recode_to_utf8(tmpsv, PL_encoding);
d3712 1
a3712 1
    XPUSHu(DO_UTF8(argsv)
d3716 1
a3716 1
    RETURN;
d3721 1
a3721 1
    dVAR; dSP; dTARGET;
d3724 1
a3724 1
    SV *top = POPs;
d3727 11
a3737 5
    if (!IN_BYTES /* under bytes, chr(-1) eq chr(0xff), etc. */
     && ((SvIOKp(top) && !SvIsUV(top) && SvIV_nomg(top) < 0)
	 ||
	 ((SvNOKp(top) || (SvOK(top) && !SvIsUV(top)))
	  && SvNV_nomg(top) < 0.0))) {
d3744 7
a3750 6
		Perl_warner(aTHX_ packWARN(WARN_UTF8),
			   "Invalid negative number (%"SVf") in chr", top);
	    }
	    value = UNICODE_REPLACEMENT;
    } else {
	value = SvUV_nomg(top);
d3756 1
a3756 1
	SvGROW(TARG, (STRLEN)UNISKIP(value)+1);
d3762 2
a3763 2
	XPUSHs(TARG);
	RETURN;
d3773 2
a3774 2
    if (PL_encoding && !IN_BYTES) {
        sv_recode_to_utf8(TARG, PL_encoding);
d3789 2
a3790 2
    XPUSHs(TARG);
    RETURN;
d3796 1
a3796 1
    dVAR; dSP; dTARGET;
d3805 1
a3805 1
	 SV* const tsv = sv_2mortal(newSVsv(left));
a3806 1
	 SvUTF8_on(tsv);
d3833 1
d3845 3
a3854 1
    dVAR;
d3878 1
a3878 4
    inplace = !SvREADONLY(source)
	   && (  SvPADTMP(source)
	      || (  SvTEMP(source) && !SvSMAGICAL(source)
		 && SvREFCNT(source) == 1));
d3892 5
a3896 1
	    _to_utf8_title_flags(s, tmpbuf, &tculen, IN_LOCALE_RUNTIME);
d3899 5
a3903 1
	    _to_utf8_lower_flags(s, tmpbuf, &tculen, IN_LOCALE_RUNTIME);
d3921 12
a3932 2
	    *tmpbuf = (IN_LOCALE_RUNTIME) ? toLOWER_LC(*s) :
			((IN_UNI_8_BIT) ? toLOWER_LATIN1(*s) : toLOWER(*s));
d3934 1
d3936 1
a3936 1
	else if (IN_LOCALE_RUNTIME) {
d3941 1
d3946 1
d3956 1
a3956 1

d3958 1
d4091 2
a4092 1
    if (IN_LOCALE_RUNTIME) {
d4096 1
d4100 1
a4100 1
    RETURN;
a4107 1
    dVAR;
d4118 1
a4118 3
    if ((SvPADTMP(source)
	 ||
	(SvTEMP(source) && !SvSMAGICAL(source) && SvREFCNT(source) == 1))
d4121 3
a4123 1
	&& ((IN_LOCALE_RUNTIME)
d4125 3
a4127 1
            : ! IN_UNI_8_BIT))
d4192 5
a4196 1
            uv = _to_utf8_upper_flags(s, tmpbuf, &ulen, IN_LOCALE_RUNTIME);
d4239 2
a4240 1
	    if (IN_LOCALE_RUNTIME) {
d4244 1
d4248 3
a4250 1
	    else if (! IN_UNI_8_BIT) {
d4256 1
d4258 1
d4271 3
d4286 1
d4351 2
a4352 1
    if (IN_LOCALE_RUNTIME) {
d4356 1
d4360 1
a4360 1
    RETURN;
a4364 1
    dVAR;
d4375 1
a4375 4
    if (   (  SvPADTMP(source)
	   || (  SvTEMP(source) && !SvSMAGICAL(source)
	      && SvREFCNT(source) == 1  )
	   )
d4410 5
a4414 1
	    _to_utf8_lower_flags(s, tmpbuf, &ulen, IN_LOCALE_RUNTIME);
d4451 3
a4453 1
            if (IN_LOCALE_RUNTIME) {
d4457 3
a4459 1
	    else if (! IN_UNI_8_BIT) {
d4475 2
a4476 1
    if (IN_LOCALE_RUNTIME) {
d4480 1
d4484 1
a4484 1
    RETURN;
d4489 1
a4489 1
    dVAR; dSP; dTARGET;
d4511 2
a4512 1

d4515 5
a4519 2
		    if (IN_LOCALE_RUNTIME
			|| _isQUOTEMETA(TWO_BYTE_UTF8_TO_NATIVE(*s, *(s + 1))))
d4562 1
a4562 1
    RETURN;
a4566 1
    dVAR;
d4577 8
a4584 1
    const bool full_folding = TRUE;
d4586 4
a4589 1
                   | ( IN_LOCALE_RUNTIME ? FOLD_FLAGS_LOCALE : 0 );
d4637 2
a4638 1
        if ( IN_LOCALE_RUNTIME ) { /* Under locale */
d4642 1
d4646 3
a4648 1
        else if ( !IN_UNI_8_BIT ) { /* Under nothing, or bytes */
d4653 1
d4655 1
d4722 2
a4723 1
    if (IN_LOCALE_RUNTIME) {
d4727 1
d4738 1
a4738 1
    dVAR; dSP; dMARK; dORIGMARK;
d4792 1
a4792 1
    if (GIMME != G_ARRAY) {
d4802 1
a4802 1
    dVAR; dSP; dMARK;
d4837 1
a4837 1
    if (GIMME != G_ARRAY) {
a4844 38
/* Smart dereferencing for keys, values and each */
PP(pp_rkeys)
{
    dVAR;
    dSP;
    dPOPss;

    SvGETMAGIC(sv);

    if (
         !SvROK(sv)
      || (sv = SvRV(sv),
            (SvTYPE(sv) != SVt_PVHV && SvTYPE(sv) != SVt_PVAV)
          || SvOBJECT(sv)
         )
    ) {
	DIE(aTHX_
	   "Type of argument to %s must be unblessed hashref or arrayref",
	    PL_op_desc[PL_op->op_type] );
    }

    if (PL_op->op_flags & OPf_SPECIAL && SvTYPE(sv) == SVt_PVAV)
	DIE(aTHX_
	   "Can't modify %s in %s",
	    PL_op_desc[PL_op->op_type], PL_op_desc[PL_op->op_next->op_type]
	);

    /* Delegate to correct function for op type */
    PUSHs(sv);
    if (PL_op->op_type == OP_RKEYS || PL_op->op_type == OP_RVALUES) {
	return (SvTYPE(sv) == SVt_PVHV) ? Perl_do_kv(aTHX) : Perl_pp_akeys(aTHX);
    }
    else {
	return (SvTYPE(sv) == SVt_PVHV)
               ? Perl_pp_each(aTHX)
               : Perl_pp_aeach(aTHX);
    }
}
a4847 1
    dVAR;
d4850 1
a4850 1
    const I32 gimme = GIMME_V;
d4871 1
a4873 1
    dVAR;
d4876 1
a4876 1
    const I32 gimme = GIMME_V;
d4890 1
a4890 1
	if (PL_op->op_type == OP_AKEYS || PL_op->op_type == OP_RKEYS) {
a4908 1
    dVAR;
d4912 1
a4912 1
    const I32 gimme = GIMME_V;
a4913 2
    PUTBACK;
    /* might clobber stack_sp */
a4914 1
    SPAGAIN;
d4919 1
a4919 1
	PUSHs(sv);	/* won't clobber stack_sp */
a4921 2
	    PUTBACK;
	    /* might clobber stack_sp */
a4922 1
	    SPAGAIN;
a4934 1
    dVAR;
d4936 1
a4936 1
    const I32 gimme = GIMME_V;
d4940 1
a4940 1
    SV *unsliced_keysv = sliced ? NULL : POPs;
d4942 1
a4942 1
    SV **mark = sliced ? PL_stack_base + POPMARK : &unsliced_keysv-1;
d4948 1
a4948 1
    SV ** const end = sliced ? SP : &unsliced_keysv;
d5038 1
a5038 1
	PUSHs(unsliced_keysv);
a5044 1
    dVAR;
d5046 1
a5046 1
    I32 gimme;
a5109 1
    dVAR;
d5144 1
a5144 1
    dVAR; dSP; dMARK; dORIGMARK;
d5191 1
a5191 1
    if (GIMME != G_ARRAY) {
d5201 1
a5201 1
    dVAR; dSP; dMARK;
d5240 1
a5240 1
    if (GIMME != G_ARRAY) {
d5252 4
a5255 2
    dVAR; dSP; dMARK;
    if (GIMME != G_ARRAY) {
d5261 1
d5263 1
a5263 1
    RETURN;
a5267 1
    dVAR;
a5272 1
    I32 is_something_there = FALSE;
d5278 15
a5292 10
    if (GIMME != G_ARRAY) {
	I32 ix = SvIV(*lastlelem);
	if (ix < 0)
	    ix += max;
	if (ix < 0 || ix >= max)
	    *firstlelem = &PL_sv_undef;
	else
	    *firstlelem = firstrelem[ix];
	SP = firstlelem;
	RETURN;
a5306 1
	    is_something_there = TRUE;
a5309 1
                assert(!IS_PADGV(*lelem));
d5314 1
a5314 4
    if (is_something_there)
	SP = lastlelem;
    else
	SP = firstlelem - 1;
d5320 1
a5320 1
    dVAR; dSP; dMARK;
d5331 1
a5331 1
    dVAR; dSP; dMARK; dORIGMARK;
d5346 1
a5346 1
	    sv_setsv(val, *MARK);
d5392 1
a5392 1
    dVAR; dSP; dMARK; dORIGMARK;
d5468 1
a5468 1
	if (GIMME == G_ARRAY) {			/* copy return vals to stack */
d5564 1
a5564 1
	if (GIMME == G_ARRAY) {			/* copy return vals to stack */
d5602 1
a5602 1
    dVAR; dSP; dMARK; dORIGMARK; dTARGET;
d5613 1
a5613 1
	SPAGAIN;
d5616 4
d5632 1
a5632 2

	PL_delaymagic = 0;
d5641 1
a5643 1
    dVAR;
d5658 1
a5658 1
    dVAR; dSP; dMARK; dORIGMARK; dTARGET;
d5669 1
a5669 1
	SPAGAIN;
d5672 3
d5676 1
d5678 1
d5683 3
d5696 1
a5696 1
    dVAR; dSP; dMARK;
d5698 1
a5698 1
    if (GIMME == G_ARRAY) {
d5782 1
a5782 1
	    sv_setsv(TARG, SP > MARK ? *SP : find_rundefsv());
d5827 2
a5828 2
    dVAR; dSP; dTARG;
    AV *ary;
d5846 1
a5846 1
    const I32 origlimit = limit;
d5849 1
a5849 1
    const I32 gimme = GIMME_V;
d5861 1
a5861 1
    if (!pm || !s)
d5871 1
d5876 1
d5879 2
a5880 2
    else
	ary = NULL;
d5882 1
d5886 1
d6020 4
a6023 2
	    const U32 items = limit - 1;
	    if (items < slen)
d6026 1
a6026 1
		EXTEND(SP, slen);
a6276 1
    dVAR;
d6290 3
a6294 1
    dVAR;
d6349 1
a6349 1
    SP = PL_stack_base + cxstack[cxstack_ix].blk_oldsp;
d6371 1
a6371 4
		PUSHs(find_rundefsv2(
		    find_runcv_where(FIND_RUNCV_level_eq, 1, NULL),
		    cxstack[cxstack_ix].blk_oldcop->cop_seq
		));
d6433 1
a6433 1
	     && cxstack[cxstack_ix].cx_type & CXp_HASARGS) {
d6436 5
a6440 4
		PERL_CONTEXT *cx = &cxstack[cxstack_ix];
		POP_SAVEARRAY();
		cx->cx_type &= ~ CXp_HASARGS;
		assert(!AvREAL(cx->blk_sub.argarray));
d6465 223
a6689 6
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
@


1.21
log
@Apply local patches, remove excess files - perl-5.20.2
@
text
@d2786 1
d2789 2
a2790 1
        anum = 0;
a2792 4
    if (anum)
        (void)srand48_deterministic((Rand_seed_t)anum);
    else
    (void)seedDrand01((Rand_seed_t)anum);
@


1.20
log
@Fix merge issues, remove excess files - match perl-5.20.2 dist
@
text
@d2788 1
a2788 1
        anum = seed();
d2791 3
@


1.19
log
@Make perl use our (arc4random backed) drand48 when unseeded
uses srand48_deterministic if a seed is provided.

seems fine millert@@
@
text
@d2788 1
a2788 1
        anum = 0;
a2790 3
    if (anum)
        (void)srand48_deterministic((Rand_seed_t)anum);
    else
@


1.18
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d2788 1
a2788 1
        anum = seed();
d2791 3
@


1.17
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d50 3
d71 2
a72 2
    if (PL_op->op_private & OPpLVAL_INTRO)
	if (!(PL_op->op_private & OPpPAD_STATE))
d91 1
a91 1
	const I32 maxarg = AvFILL(MUTABLE_AV(TARG)) + 1;
d94 2
a95 2
	    U32 i;
	    for (i=0; i < (U32)maxarg; i++) {
d101 5
a105 1
	    Copy(AvARRAY((const AV *)TARG), SP+1, maxarg, SV*);
d111 1
a111 1
	const I32 maxarg = AvFILL(MUTABLE_AV(TARG)) + 1;
d125 2
a126 2
    if (PL_op->op_private & OPpLVAL_INTRO)
	if (!(PL_op->op_private & OPpPAD_STATE))
d244 2
d247 1
a247 1
			gv_init_sv(gv, CopSTASH(PL_curcop), namesv, 0);
d445 2
a446 3
	if (SvTYPE(sv) >= SVt_PVMG && SvMAGIC(sv)) {
	    const MAGIC * const mg = mg_find(sv, PERL_MAGIC_regex_global);
	    if (mg && mg->mg_len >= 0) {
d448 4
a451 4
		I32 i = mg->mg_len;
		if (DO_UTF8(sv))
		    sv_pos_b2u(sv, &i);
		PUSHi(i);
d454 1
a454 2
	}
	RETPUSHUNDEF;
d496 3
a498 6
	    if (!code || code == -KEY_CORE)
		DIE(aTHX_ "Can't find an opnumber for \"%"SVf"\"",
		    SVfARG(newSVpvn_flags(
			s+6, SvCUR(TOPs)-6,
			(SvFLAGS(TOPs) & SVf_UTF8)|SVs_TEMP
		    )));
d574 2
a575 1
    else if (SvPADTMP(sv) && !IS_PADGV(sv))
d577 1
d594 2
a595 4
    if (sv)
	SvGETMAGIC(sv);

    if (!sv || !SvROK(sv))
d609 1
d612 3
d621 4
a624 1
	if (!SvGMAGICAL(ssv) && !SvAMAGIC(ssv) && SvROK(ssv))
d626 8
a633 1
	ptr = SvPV_const(ssv,len);
d1029 1
d1033 1
d1035 1
d1679 1
d1712 5
a1716 1
               if (*SP)
d1718 1
d2338 2
a2339 3
	(void)SvPV_nomg_const(sv,len); /* force check for uninit var */
	sv_setsv_nomg(TARG, sv);
	tmps = (U8*)SvPV_force_nomg(TARG, len);
a2730 4
#ifndef HAS_DRAND48_PROTO
extern double drand48 (void);
#endif

d3331 1
d3335 3
a3337 3
    XPUSHu(DO_UTF8(argsv) ?
	   utf8n_to_uvchr(s, UTF8_MAXBYTES, 0, UTF8_ALLOW_ANYUV) :
	   (UV)(*s & 0xff));
a3460 9
/* Generates code to store a unicode codepoint c that is known to occupy
 * exactly two UTF-8 and UTF-EBCDIC bytes; it is stored into p and p+1,
 * and p is advanced to point to the next available byte after the two bytes */
#define CAT_UNI_TO_UTF8_TWO_BYTE(p, c)					    \
    STMT_START {							    \
	*(p)++ = UTF8_TWO_BYTE_HI(c);					    \
	*((p)++) = UTF8_TWO_BYTE_LO(c);					    \
    } STMT_END

a3485 1
    bool tainted = FALSE;
d3487 1
a3487 9
    SvGETMAGIC(source);
    if (SvOK(source)) {
	s = (const U8*)SvPV_nomg_const(source, slen);
    } else {
	if (ckWARN(WARN_UNINITIALIZED))
	    report_uninit(source);
	s = (const U8*)"";
	slen = 0;
    }
d3492 4
a3495 1
    inplace = SvPADTMP(source) && !SvREADONLY(source) && SvTEMP(source);
d3509 1
a3509 2
	    _to_utf8_title_flags(s, tmpbuf, &tculen,
				 cBOOL(IN_LOCALE_RUNTIME), &tainted);
d3512 1
a3512 2
	    _to_utf8_lower_flags(s, tmpbuf, &tculen,
				 cBOOL(IN_LOCALE_RUNTIME), &tainted);
d3535 7
a3541 3
	    *tmpbuf = toUPPER_LC(*s);	/* This would be a bug if any locales
					 * have upper and title case different
					 */
d3548 8
a3555 2
	else { /* is ucfirst non-UTF-8, not in locale, and cased latin1 */
	    UV title_ord = _to_upper_title_latin1(*s, tmpbuf, &tculen, 's');
a3655 4
	if (tainted) {
	    TAINT;
	    SvTAINTED_on(dest);
	}
a3658 4
	    if (IN_LOCALE_RUNTIME) {
		TAINT;
		SvTAINTED_on(dest);
	    }
d3677 1
a3677 1
	if (SvUTF8(source))
d3686 4
d3712 19
a3730 11
    if (SvPADTMP(source) && !SvREADONLY(source) && !SvAMAGIC(source)
	&& SvTEMP(source) && !DO_UTF8(source)
	&& (IN_LOCALE_RUNTIME || ! IN_UNI_8_BIT)) {

	/* We can convert in place.  The reason we can't if in UNI_8_BIT is to
	 * make the loop tight, so we overwrite the source with the dest before
	 * looking at it, and we need to look at the original source
	 * afterwards.  There would also need to be code added to handle
	 * switching to not in-place in midstream if we run into characters
	 * that change the length.
	 */
d3739 1
a3739 15
	/* The old implementation would copy source into TARG at this point.
	   This had the side effect that if source was undef, TARG was now
	   an undefined SV with PADTMP set, and they don't warn inside
	   sv_2pv_flags(). However, we're now getting the PV direct from
	   source, which doesn't have PADTMP set, so it would warn. Hence the
	   little games.  */

	if (SvOK(source)) {
	    s = (const U8*)SvPV_nomg_const(source, len);
	} else {
	    if (ckWARN(WARN_UNINITIALIZED))
		report_uninit(source);
	    s = (const U8*)"";
	    len = 0;
	}
d3754 1
a3754 2
	U8 tmpbuf[UTF8_MAXBYTES+1];
	bool tainted = FALSE;
d3775 2
a3776 4
#define GREEK_CAPITAL_LETTER_IOTA 0x0399
#define COMBINING_GREEK_YPOGEGRAMMENI 0x0345

		CAT_UNI_TO_UTF8_TWO_BYTE(d, GREEK_CAPITAL_LETTER_IOTA);
d3784 3
a3786 2
            uv = _to_utf8_upper_flags(s, tmpbuf, &ulen,
				      cBOOL(IN_LOCALE_RUNTIME), &tainted);
d3812 2
a3813 1
	    CAT_UNI_TO_UTF8_TWO_BYTE(d, GREEK_CAPITAL_LETTER_IOTA);
a3818 4
	if (tainted) {
	    TAINT;
	    SvTAINTED_on(dest);
	}
d3828 3
a3830 2
		TAINT;
		SvTAINTED_on(dest);
d3832 1
a3832 1
		    *d = toUPPER_LC(*s);
d3840 1
d3929 4
d3952 6
a3957 2
    if (SvPADTMP(source) && !SvREADONLY(source) && !SvAMAGIC(source)
	&& SvTEMP(source) && !DO_UTF8(source)) {
d3969 1
a3969 15
	/* The old implementation would copy source into TARG at this point.
	   This had the side effect that if source was undef, TARG was now
	   an undefined SV with PADTMP set, and they don't warn inside
	   sv_2pv_flags(). However, we're now getting the PV direct from
	   source, which doesn't have PADTMP set, so it would warn. Hence the
	   little games.  */

	if (SvOK(source)) {
	    s = (const U8*)SvPV_nomg_const(source, len);
	} else {
	    if (ckWARN(WARN_UNINITIALIZED))
		report_uninit(source);
	    s = (const U8*)"";
	    len = 0;
	}
a3984 1
	bool tainted = FALSE;
d3990 1
a3990 2
	    _to_utf8_lower_flags(s, tmpbuf, &ulen,
				 cBOOL(IN_LOCALE_RUNTIME), &tainted);
d3993 1
a3993 1
	     * commit message for this comment for why there isn't any */
a4019 4
	if (tainted) {
	    TAINT;
	    SvTAINTED_on(dest);
	}
d4027 1
a4027 3
	    if (IN_LOCALE_RUNTIME) {
		TAINT;
		SvTAINTED_on(dest);
d4030 1
a4030 1
	    }
d4047 4
d4085 1
a4085 1
			|| _isQUOTEMETA(TWO_BYTE_UTF8_TO_UNI(*s, *(s + 1))))
d4143 1
a4143 1
    U8 tmpbuf[UTF8_MAXBYTES * UTF8_MAX_FOLD_CHAR_EXPAND + 1];
a4174 1
        bool tainted = FALSE;
d4179 1
a4179 1
            _to_utf8_fold_flags(s, tmpbuf, &ulen, flags, &tainted);
a4191 4
	if (tainted) {
	    TAINT;
	    SvTAINTED_on(dest);
	}
a4193 3
        /* For locale, bytes, and nothing, the behavior is supposed to be the
         * same as lc().
         */
d4195 3
a4197 2
            TAINT;
            SvTAINTED_on(dest);
d4199 1
a4199 1
                *d = toLOWER_LC(*s);
d4203 1
a4203 1
                *d = toLOWER(*s);
d4206 1
d4209 1
a4209 1
             * casefolding becomes 'ss', and \x{B5} (\N{MICRO SIGN}), which
d4229 2
a4230 1
                    CAT_UNI_TO_UTF8_TWO_BYTE(d, GREEK_SMALL_LETTER_MU);
d4235 1
a4235 1
                        if UNI_IS_INVARIANT(fc) {
d4273 4
d4304 1
a4304 1
	    I32 max = -1;
d4306 1
a4306 1
		const I32 elem = SvIV(*svp);
d4316 1
a4316 1
	    I32 elem = SvIV(*MARK);
d4329 1
a4329 1
		if (!svp || *svp == &PL_sv_undef)
d4349 45
d4442 1
a4442 1
    if (current > av_len(array)) {
d4470 1
a4470 1
	PUSHi(av_len(array) + 1);
d4563 2
a4564 1
		    SvREFCNT_inc_simple_void(sv); /* De-mortalize */
d4585 1
a4585 1
		    I32 idx = SvIV(*MARK);
d4599 2
a4600 1
		        SvREFCNT_inc_simple_void(sv); /* De-mortalize */
d4712 1
a4712 1
    if (PL_op->op_private & OPpEXISTS_SUB) {
d4724 1
a4724 1
    if (SvTYPE(hv) == SVt_PVHV) {
d4797 49
d4870 1
d4902 4
d4917 1
a4917 1
    dVAR; dSP; dMARK; dORIGMARK;
d4920 1
a4920 1
    SP = ORIGMARK;		/* av_make() might realloc stack_sp */
d4929 4
a4932 1
    HV* const hv = (HV *)sv_2mortal((SV *)newHV());
d4953 1
a4953 3
    if (PL_op->op_flags & OPf_SPECIAL)
	mXPUSHs(newRV_inc(MUTABLE_SV(hv)));
    else XPUSHs(MUTABLE_SV(hv));
d4994 6
a4999 6
    I32 i;
    I32 offset;
    I32 length;
    I32 newlen;
    I32 after;
    I32 diff;
d5003 1
a5003 1
	return Perl_tied_method(aTHX_ "SPLICE", mark - 1, MUTABLE_SV(ary), mg,
d5066 1
d5068 1
a5068 2
	    Copy(AvARRAY(ary)+offset, MARK, length, SV*);
	    if (AvREAL(ary)) {
d5070 3
a5072 1
		for (i = length, dst = MARK; i; i--) {
a5073 1
		    dst++;
d5075 3
d5115 1
a5115 1
	    dst[--i] = &PL_sv_undef;
d5163 2
a5164 2
		Copy(tmparyval, MARK, length, SV*);
		if (AvREAL(ary)) {
d5166 3
a5168 1
		    for (i = length, dst = MARK; i; i--) {
a5169 1
			dst++;
d5171 2
d5208 1
a5208 1
	call_method("PUSH",G_SCALAR|G_DISCARD);
d5261 1
a5261 1
	call_method("UNSHIFT",G_SCALAR|G_DISCARD);
d5266 1
a5266 1
	I32 i = 0;
d5297 1
a5297 1
		I32 i, j;
d5304 1
a5304 1
		for (i = 0, j = av_len(av); i < j; ++i, --j) {
a5368 2
	    if (! SvOK(TARG) && ckWARN(WARN_UNINITIALIZED))
		report_uninit(TARG);
d5425 1
a5425 1
    I32 iters = 0;
d5429 1
a5429 1
    I32 maxiters = slen + 10;
a5453 2
    RX_MATCH_UTF8_set(rx, do_utf8);

d5653 1
a5653 1
	     && !(RX_EXTFLAGS(rx) & RXf_ANCH)) {
d5817 1
a5817 1
	    call_method("PUSH",G_SCALAR|G_DISCARD);
d5821 1
a5821 1
		I32 i;
d5983 1
a5983 1
		    constr, CopHINTS_get(PL_curcop) & HINT_STRICT_REFS,
a6004 1
		/* diag_listed_as: Type of arg %d to &CORE::%s must be %s*/
@


1.16
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d32 1
d87 1
d136 5
d148 42
d234 1
a234 1
			Perl_croak_no_modify(aTHX);
d243 1
a243 1
                                        HvNAMEUTF8(CopSTASH(PL_curcop)) ? SVf_UTF8 : 0 );
d270 1
a270 1
		            (SvPOK(sv) && SvCUR(sv)>32 ? "..." : ""),
d323 2
a324 1
	    Perl_die(aTHX_ S_no_symref_sv, sv, (SvPOK(sv) && SvCUR(sv)>32 ? "..." : ""), what);
d330 1
a330 2
	  PL_op->op_flags & OPf_REF &&
	  PL_op->op_next->op_type != OP_BOOLKEYS
d428 1
a428 1
	SV * const ret = sv_2mortal(newSV_type(SVt_PVLV));  /* Not TARG RT#67838 */
d458 2
a459 1
	: ((PL_op->op_private & (OPpLVAL_INTRO|OPpMAY_RETURN_CONSTANT)) == OPpMAY_RETURN_CONSTANT)
d466 1
a466 4
    if (cv) {
	if (CvCLONE(cv))
	    cv = MUTABLE_CV(sv_2mortal(MUTABLE_SV(cv_clone(cv))));
    }
d484 1
d490 6
a495 2
		DIE(aTHX_ "Can't find an opnumber for \"%s\"", s+6);
	    if (code < 0) {	/* Overridable. */
d643 1
d645 4
a707 2
    register unsigned char *s;
    char *sfirst_raw;
a708 3
    MAGIC *mg = SvMAGICAL(sv) ? mg_find(sv, PERL_MAGIC_study) : NULL;
    U8 quanta;
    STRLEN size;
d710 1
a710 4
    if (mg && SvSCREAM(sv))
	RETPUSHYES;

    s = (unsigned char*)(SvPV(sv, len));
d712 1
a712 10
	/* No point in studying a zero length string, and not safe to study
	   anything that doesn't appear to be a simple scalar (and hence might
	   change between now and when the regexp engine runs without our set
	   magic ever running) such as a reference to an object with overloaded
	   stringification.  Also refuse to study an FBM scalar, as this gives
	   more flexibility in SV flag usage.  No real-world code would ever
	   end up studying an FBM scalar, so this isn't a real pessimisation.
	   Endemic use of I32 in Perl_screaminstr makes it hard to safely push
	   the study length limit from I32_MAX to U32_MAX - 1.
	*/
d717 1
a717 58
       complicates matters elsewhere. This is a low-impact band-aid.
       The relevant code will be neatly removed in a future release. */
    RETPUSHYES;

    if (len < 0xFF) {
	quanta = 1;
    } else if (len < 0xFFFF) {
	quanta = 2;
    } else
	quanta = 4;

    size = (256 + len) * quanta;
    sfirst_raw = (char *)safemalloc(size);

    if (!sfirst_raw)
	DIE(aTHX_ "do_study: out of memory");

    SvSCREAM_on(sv);
    if (!mg)
	mg = sv_magicext(sv, NULL, PERL_MAGIC_study, &PL_vtbl_regexp, NULL, 0);
    mg->mg_ptr = sfirst_raw;
    mg->mg_len = size;
    mg->mg_private = quanta;

    memset(sfirst_raw, ~0, 256 * quanta);

    /* The assumption here is that most studied strings are fairly short, hence
       the pain of the extra code is worth it, given the memory savings.
       80 character string, 336 bytes as U8, down from 1344 as U32
       800 character string, 2112 bytes as U16, down from 4224 as U32
    */
       
    if (quanta == 1) {
	U8 *const sfirst = (U8 *)sfirst_raw;
	U8 *const snext = sfirst + 256;
	while (len-- > 0) {
	    const U8 ch = s[len];
	    snext[len] = sfirst[ch];
	    sfirst[ch] = len;
	}
    } else if (quanta == 2) {
	U16 *const sfirst = (U16 *)sfirst_raw;
	U16 *const snext = sfirst + 256;
	while (len-- > 0) {
	    const U8 ch = s[len];
	    snext[len] = sfirst[ch];
	    sfirst[ch] = len;
	}
    } else  {
	U32 *const sfirst = (U32 *)sfirst_raw;
	U32 *const snext = sfirst + 256;
	while (len-- > 0) {
	    const U8 ch = s[len];
	    snext[len] = sfirst[ch];
	    sfirst[ch] = len;
	}
    }

a733 1
    TARG = sv_newmortal();
d741 4
a744 1
    else PUSHi(do_trans(sv));
d782 4
a785 6
        if (SvFAKE(sv)) {
            /* SV is copy-on-write */
	    sv_force_normal_flags(sv, 0);
        }
        else
            Perl_croak_no_modify(aTHX);
d972 6
a977 1
                             : sv_2mortal(newSVhek(GvENAME_HEK(CvGV((const CV *)sv))))));
d983 2
d986 5
a990 1
	    CvGV_set(MUTABLE_CV(sv), gv);
d994 3
a996 5
	if (SvFAKE(sv)) {
	    SvSetMagicSV(sv, &PL_sv_undef);
	    break;
	}
	else if (isGV_with_GP(sv)) {
a1033 1
	/* FALL THROUGH */
d1053 1
a1053 1
	Perl_croak_no_modify(aTHX);
d1057 1
a1057 1
    if (!SvREADONLY(TOPs) && SvIOK_notUV(TOPs) && !SvNOK(TOPs) && !SvPOK(TOPs)
d1089 1
a1089 5
    {
	SvIV_please_nomg(svr);
	if (SvIOK(svr)) {
	    SvIV_please_nomg(svl);
	    if (SvIOK(svl)) {
d1147 2
a1148 2
		    register unsigned int highbit = 8 * sizeof(UV);
		    register unsigned int diff = 8 * sizeof(UV);
d1159 2
a1160 2
			register UV result = 1;
			register UV base = baseuv;
a1186 2
	    }
	}
d1250 1
a1250 2
    SvIV_please_nomg(svr);
    if (SvIOK(svr)) {
d1255 1
a1255 2
	SvIV_please_nomg(svl);
	if (SvIOK(svl)) {
d1393 1
a1393 4
    SvIV_please_nomg(svr);
    if (SvIOK(svr)) {
        SvIV_please_nomg(svl);
        if (SvIOK(svl)) {
d1468 1
a1468 2
        } /* left wasn't SvIOK */
    } /* right wasn't SvIOK */
d1500 1
a1500 2
	SvIV_please_nomg(svr);
        if (SvIOK(svr)) {
d1530 1
a1530 3
        SvIV_please_nomg(svl);
	if (!use_double && SvIOK(svl)) {
            if (SvIOK(svl)) {
a1542 1
            }
d1615 1
a1615 1
    register IV count;
d1655 1
a1655 1
	static const char oom_list_extend[] = "Out of memory during list extend";
d1662 1
a1662 1
	   Perl_croak(aTHX_ oom_list_extend);
d1707 1
a1707 1
	static const char oom_string_extend[] =
d1720 1
a1720 1
		     Perl_croak(aTHX_ oom_string_extend);
d1757 1
a1757 2
    SvIV_please_nomg(svr);
    if (SvIOK(svr)) {
d1761 1
a1761 1
	register UV auv = 0;
d1771 1
a1771 2
	    SvIV_please_nomg(svl);
	    if (SvIOK(svl)) {
d1775 1
a1775 1
		    register const IV aiv = SvIVX(svl);
d1789 1
a1789 1
	    register UV buv;
d1795 1
a1795 1
		register const IV biv = SvIVX(svr);
a1998 1
    SvIV_please_nomg(right);
d2000 1
a2000 3
    if (SvIOK(right)) {
	SvIV_please_nomg(left);
	if (SvIOK(left)) {
d2035 1
a2035 2
	    /* NOTREACHED */
	}
d2215 23
d2242 1
a2244 5
	const int flags = SvFLAGS(sv);

        if( !SvNIOK( sv ) && looks_like_number( sv ) ){
           SvIV_please( sv );
        }   
d2246 2
a2247 2
	if ((flags & SVf_IOK) || ((flags & (SVp_IOK | SVp_NOK)) == SVp_IOK)) {
	    /* It's publicly an integer, or privately an integer-not-float */
d2252 2
a2253 1
		    SETi(SvIVX(sv));	/* special case: -((UV)IV_MAX+1) == IV_MIN */
d2272 1
a2272 1
	if (SvNIOKp(sv))
d2274 1
a2274 25
	else if (SvPOKp(sv)) {
	    STRLEN len;
	    const char * const s = SvPV_nomg_const(sv, len);
	    if (isIDFIRST(*s)) {
		sv_setpvs(TARG, "-");
		sv_catsv(TARG, sv);
	    }
	    else if (*s == '+' || *s == '-') {
		sv_setsv_nomg(TARG, sv);
		*SvPV_force_nomg(TARG, len) = *s == '-' ? '+' : '-';
	    }
	    else if (DO_UTF8(sv)) {
		SvIV_please_nomg(sv);
		if (SvIOK(sv))
		    goto oops_its_an_int;
		if (SvNOK(sv))
		    sv_setnv(TARG, -SvNV_nomg(sv));
		else {
		    sv_setpvs(TARG, "-");
		    sv_catsv(TARG, sv);
		}
	    }
	    else {
		SvIV_please_nomg(sv);
		if (SvIOK(sv))
a2275 4
		sv_setnv(TARG, -SvNV_nomg(sv));
	    }
	    SETTARG;
	}
d2307 2
a2308 2
	register U8 *tmps;
	register I32 anum;
d2373 1
a2373 1
	    register long *tmpl;
d2425 1
a2425 1
#if defined(__GLIBC__) && IVSIZE == 8
d2448 1
a2448 1
#if defined(__GLIBC__) && IVSIZE == 8
d2626 1
d2711 1
a2711 11
    dVAR; dSP; dTARGET;
    NV value;
    if (MAXARG < 1)
	value = 1.0;
    else if (!TOPs) {
	value = 1.0; (void)POPs;
    }
    else
	value = POPn;
    if (value == 0.0)
	value = 1.0;
d2716 26
a2741 3
    value *= Drand01();
    XPUSHn(value);
    RETURN;
d2747 22
a2768 1
    const UV anum = (MAXARG < 1 || (!TOPs && !POPs)) ? seed() : POPu;
d2916 4
a2919 21
    if (SvGAMAGIC(sv)) {
	/* For an overloaded or magic scalar, we can't know in advance if
	   it's going to be UTF-8 or not. Also, we can't call sv_len_utf8 as
	   it likes to cache the length. Maybe that should be a documented
	   feature of it.
	*/
	STRLEN len;
	const char *const p
	    = sv_2pv_flags(sv, &len,
			   SV_UNDEF_RETURNS_NULL|SV_CONST_RETURN|SV_GMAGIC);

	if (!p) {
	    if (!SvPADTMP(TARG)) {
		sv_setsv(TARG, &PL_sv_undef);
		SETTARG;
	    }
	    SETs(&PL_sv_undef);
	}
	else if (DO_UTF8(sv)) {
	    SETi(utf8_length((U8*)p, (U8*)p + len));
	}
d2921 3
d2925 1
a2925 6
    } else if (SvOK(sv)) {
	/* Neither magic nor overloaded.  */
	if (DO_UTF8(sv))
	    SETi(sv_len_utf8(sv));
	else
	    SETi(sv_len(sv));
a3022 1
    bool repl_is_utf8 = FALSE;
d3043 1
a3043 11
    if (repl_sv) {
	repl = SvPV_const(repl_sv, repl_len);
	repl_is_utf8 = DO_UTF8(repl_sv) && repl_len;
	if (repl_is_utf8) {
	    if (!DO_UTF8(sv))
		sv_utf8_upgrade(sv);
	}
	else if (DO_UTF8(sv))
	    repl_need_utf8_upgrade = TRUE;
    }
    else if (lvalue) {
d3062 18
a3079 1
    tmps = SvPV_const(sv, curlen);
d3081 1
a3081 1
        utf8_curlen = sv_len_utf8(sv);
d3099 1
a3099 1
	    ? sv_pos_u2b_flags(sv, pos, &byte_len, SV_CONST_RETURN) : pos;
a3120 1
		repl_is_utf8 = DO_UTF8(repl_sv_copy) && repl_len;
a3121 4
	    if (SvROK(sv))
		Perl_ck_warner(aTHX_ packWARN(WARN_SUBSTR),
			    "Attempt to use reference as lvalue in substr"
		);
a3124 2
	    if (repl_is_utf8)
		SvUTF8_on(sv);
d3145 3
a3147 3
    register const IV size   = POPi;
    register const IV offset = POPi;
    register SV * const src = POPs;
d3324 1
d3326 3
a3328 1
    if (((SvIOK_notUV(TOPs) && SvIV(TOPs) < 0)
d3330 11
a3340 5
	 (SvNOK(TOPs) && SvNV(TOPs) < 0.0))) {
	if (IN_BYTES) {
	    value = POPu; /* chr(-1) eq chr(0xff), etc. */
	} else {
	    (void) POPs; /* Ignore the argument value. */
a3341 1
	}
d3343 1
a3343 1
	value = POPu;
d3369 4
a3372 2
	if (SvCUR(TARG) == 0 || !is_utf8_string((U8*)tmps, SvCUR(TARG)) ||
	    UNICODE_IS_REPLACEMENT(utf8_to_uvchr_buf((U8*)tmps, (U8*) tmps + SvCUR(TARG), NULL))) {
d3556 4
a3559 4
		    /* If the result won't fit in a byte, the entire result will
		     * have to be in UTF-8.  Assume worst case sizing in
		     * conversion. (all latin1 characters occupy at most two bytes
		     * in utf8) */
d3767 1
a3767 1
	    if (in_iota_subscript && ! is_utf8_mark(s)) {
d3840 3
a3842 1
		    if (LIKELY(*d != LATIN_SMALL_LETTER_Y_WITH_DIAERESIS)) continue;
d4069 1
a4069 1
    register const char *s = SvPV_const(sv,len);
d4073 1
a4073 1
	register char *d;
d4097 1
a4097 1
		else if (_is_utf8_quotemeta((U8 *) s)) {
d4220 5
a4224 6
            /* For ASCII and the Latin-1 range, there's only two troublesome folds,
            * \x{DF} (\N{LATIN SMALL LETTER SHARP S}), which under full casefolding
            * becomes 'ss', and \x{B5} (\N{MICRO SIGN}), which under any fold becomes
            * \x{3BC} (\N{GREEK SMALL LETTER MU}) -- For the rest, the casefold is
            * their lowercase.
            */
d4227 6
a4232 7
                    /* \N{MICRO SIGN}'s casefold is \N{GREEK SMALL LETTER MU}, which
                    * is outside of the latin-1 range. There's a couple of ways to
                    * deal with this -- khw discusses them in pp_lc/uc, so go there :)
                    * What we do here is upgrade what we had already casefolded,
                    * then enter an inner loop that appends the rest of the characters
                    * as UTF-8.
                    */
d4248 3
a4250 1
                            if ( full_folding && *s == LATIN_SMALL_LETTER_SHARP_S) {
d4265 2
a4266 3
                    /* Under full casefolding, LATIN SMALL LETTER SHARP S becomes "ss",
                    * which may require growing the SV.
                    */
d4275 2
a4276 1
                else { /* If it's not one of those two, the fold is their lower case */
d4296 2
a4297 2
    register AV *const av = MUTABLE_AV(POPs);
    register const I32 lval = (PL_op->op_flags & OPf_MOD || LVRET);
d4311 1
a4311 1
	    register SV **svp;
d4323 1
a4323 1
	    register SV **svp;
d4390 3
a4392 1
	return (SvTYPE(sv) == SVt_PVHV) ? Perl_pp_each(aTHX) : Perl_pp_aeach(aTHX);
d4498 10
d4509 1
a4509 9
    if (PL_op->op_private & OPpSLICE) {
	dMARK; dORIGMARK;
	SV * const osv = POPs;
	const bool tied = SvRMAGICAL(osv)
			    && mg_find((const SV *)osv, PERL_MAGIC_tied);
	const bool can_preserve = SvCANEXISTDELETE(osv)
				    || mg_find((const SV *)osv, PERL_MAGIC_env);
	const U32 type = SvTYPE(osv);
	if (type == SVt_PVHV) {			/* hash element */
d4511 1
a4511 1
	    while (++MARK <= SP) {
d4529 1
d4542 2
a4543 2
	}
	else if (type == SVt_PVAV) {                  /* array element */
d4546 1
a4546 1
		while (++MARK <= SP) {
d4577 4
a4580 2
	}
	else
d4582 1
d4594 2
a4595 75
    else {
	SV * const keysv = POPs;
	SV * const osv   = POPs;
	const bool tied = SvRMAGICAL(osv)
			    && mg_find((const SV *)osv, PERL_MAGIC_tied);
	const bool can_preserve = SvCANEXISTDELETE(osv)
				    || mg_find((const SV *)osv, PERL_MAGIC_env);
	const U32 type = SvTYPE(osv);
	SV *sv = NULL;
	if (type == SVt_PVHV) {
	    HV * const hv = MUTABLE_HV(osv);
	    bool preeminent = TRUE;
	    if (can_preserve)
		preeminent = hv_exists_ent(hv, keysv, 0);
	    if (tied) {
		HE *he = hv_fetch_ent(hv, keysv, 1, 0);
		if (he)
		    sv = HeVAL(he);
		else
		    preeminent = FALSE;
	    }
	    else {
		sv = hv_delete_ent(hv, keysv, 0, 0);
		SvREFCNT_inc_simple_void(sv); /* De-mortalize */
	    }
	    if (preeminent) {
		save_helem_flags(hv, keysv, &sv, SAVEf_KEEPOLDELEM);
		if (tied) {
		    SV *nsv = sv_mortalcopy(sv);
		    mg_clear(sv);
		    sv = nsv;
		}
	    }
	    else
		SAVEHDELETE(hv, keysv);
	}
	else if (type == SVt_PVAV) {
	    if (PL_op->op_flags & OPf_SPECIAL) {
		AV * const av = MUTABLE_AV(osv);
		I32 idx = SvIV(keysv);
		bool preeminent = TRUE;
		if (can_preserve)
		    preeminent = av_exists(av, idx);
		if (tied) {
		    SV **svp = av_fetch(av, idx, 1);
		    if (svp)
			sv = *svp;
		    else
			preeminent = FALSE;
		}
		else {
		    sv = av_delete(av, idx, 0);
		    SvREFCNT_inc_simple_void(sv); /* De-mortalize */
		}
		if (preeminent) {
		    save_aelem_flags(av, idx, &sv, SAVEf_KEEPOLDELEM);
		    if (tied) {
			SV *nsv = sv_mortalcopy(sv);
			mg_clear(sv);
			sv = nsv;
		    }
		}
		else
		    SAVEADELETE(av, idx);
	    }
	    else
		DIE(aTHX_ "panic: avhv_delete no longer supported");
	}
	else
	    DIE(aTHX_ "Not a HASH reference");
	if (!sv)
	    sv = &PL_sv_undef;
	if (gimme != G_VOID)
	    PUSHs(sv);
    }
d4704 2
a4705 2
    register HV * const hv = MUTABLE_HV(POPs);
    register const I32 lval = (PL_op->op_flags & OPf_MOD || LVRET);
d4713 1
a4713 1
	if (SvCANEXISTDELETE(hv) || mg_find((const SV *)hv, PERL_MAGIC_env))
d4780 1
a4780 1
    register SV ** const firstrelem = lastlelem + 1;
d4783 2
a4784 2
    register const I32 max = lastrelem - lastlelem;
    register SV **lelem;
d4836 1
a4836 1
    HV* const hv = newHV();
d4839 3
a4841 2
	SV * const key = *++MARK;
	SV * const val = newSV(0);
d4843 6
a4848 1
	    sv_setsv(val, *++MARK);
d4850 1
d4852 2
d4857 3
a4859 2
    mXPUSHs((PL_op->op_flags & OPf_SPECIAL)
	    ? newRV_noinc(MUTABLE_SV(hv)) : MUTABLE_SV(hv));
d4897 6
a4902 6
    register AV *ary = DEREF_PLAIN_ARRAY(MUTABLE_AV(*++MARK));
    register SV **src;
    register SV **dst;
    register I32 i;
    register I32 offset;
    register I32 length;
d5099 1
a5099 1
    register AV * const ary = DEREF_PLAIN_ARRAY(MUTABLE_AV(*++MARK));
d5112 1
d5115 3
a5117 1
	    SV * const sv = newSV(0);
d5119 1
a5119 1
		sv_setsv(sv, *MARK);
d5152 1
a5152 1
    register AV *ary = DEREF_PLAIN_ARRAY(MUTABLE_AV(*++MARK));
d5165 1
a5165 1
	register I32 i = 0;
d5197 1
a5197 1
		register SV *tmp = sv_newmortal();
d5204 1
a5204 1
		    register SV *begin, *end;
d5209 1
a5209 1
				register SV *sv = av_delete(av, j, 0);
d5216 1
a5216 1
			    register SV *sv = av_delete(av, i, 0);
d5237 1
a5237 1
			register SV * const tmp = *begin;
d5248 1
a5248 1
		register SV * const tmp = *MARK;
d5257 3
a5259 3
	register char *up;
	register char *down;
	register I32 tmp;
d5316 1
a5316 1
    register IV limit = POPi;			/* note, negative is forever */
d5319 1
a5319 1
    register const char *s = SvPV_const(sv, len);
d5322 4
a5325 4
    register PMOP *pm;
    register REGEXP *rx;
    register SV *dstr;
    register const char *m;
d5327 3
a5329 1
    const STRLEN slen = do_utf8 ? utf8_length((U8*)s, (U8*)strend) : (STRLEN)(strend - s);
d5353 1
a5353 1
	     (RX_EXTFLAGS(rx) & (RXf_WHITE | RXf_SKIPWHITE)));
d5368 1
a5368 1
    if (ary && (gimme != G_ARRAY || (pm->op_pmflags & PMf_ONCE))) {
d5384 1
a5384 1
		    AvARRAY(ary)[i] = &PL_sv_undef;	/* don't free mere refs */
d5395 1
a5395 1
	    while (*s == ' ' || is_utf8_space((U8*)s))
d5420 1
a5420 1
		while (m < strend && !( *m == ' ' || is_utf8_space((U8*)m) )) {
d5422 1
a5422 1
		    /* is_utf8_space returns FALSE for malform utf8 */
d5429 2
a5430 1
	    else if (get_regex_charset(RX_EXTFLAGS(rx)) == REGEX_LOCALE_CHARSET) {
d5460 1
a5460 1
		while (s < strend && ( *s == ' ' || is_utf8_space((U8*)s) ))
d5463 2
a5464 1
	    else if (get_regex_charset(RX_EXTFLAGS(rx)) == REGEX_LOCALE_CHARSET) {
d5576 1
a5576 1
					  (do_utf8 ? SVf_UTF8 : 0) | make_mortal);
d5600 1
a5600 1
					  (do_utf8 ? SVf_UTF8 : 0) | make_mortal);
d5618 2
a5619 2
	    rex_return = CALLREGEXEC(rx, (char*)s, (char*)strend, (char*)orig, 1 ,
				     sv, NULL, SvSCREAM(sv) ? REXEC_SCREAM : 0);
d5624 3
a5626 7
	    if (RX_MATCH_COPIED(rx) && RX_SUBBEG(rx) != orig) {
		m = s;
		s = orig;
		orig = RX_SUBBEG(rx);
		s = orig + (m - s);
		strend = s + (strend - m);
	    }
a5792 20
PP(pp_boolkeys)
{
    dVAR;
    dSP;
    HV * const hv = (HV*)POPs;
    
    if (SvTYPE(hv) != SVt_PVHV) { XPUSHs(&PL_sv_no); RETURN; }

    if (SvRMAGICAL(hv)) {
	MAGIC * const mg = mg_find((SV*)hv, PERL_MAGIC_tied);
	if (mg) {
            XPUSHs(magic_scalarpack(hv, mg));
	    RETURN;
        }	    
    }

    XPUSHs(boolSV(HvUSEDKEYS(hv) != 0));
    RETURN;
}

d5798 1
a5798 1
    int defgv = PL_opargs[opnum] & OA_DEFGV, whicharg = 0;
d5800 2
a5801 2
    SV **svp = AvARRAY(at_);
    I32 minargs = 0, maxargs = 0, numargs = AvFILLp(at_)+1;
d5823 1
a5823 1
	   opnum ? OP_DESC(PL_op->op_next) : SvPV_nolen_const(cSVOP_sv)
d5851 1
a5852 8
		PERL_SI * const oldsi = PL_curstackinfo;
		I32 const oldcxix = oldsi->si_cxix;
		CV *caller;
		if (oldcxix) oldsi->si_cxix--;
		else PL_curstackinfo = oldsi->si_prev;
		caller = find_runcv(NULL);
		PL_curstackinfo = oldsi;
		oldsi->si_cxix = oldcxix;
d5854 2
a5855 1
		    caller,cxstack[cxstack_ix].blk_oldcop->cop_seq
d5892 2
a5893 1
	  {
d5902 2
a5903 1
	           : opnum == OP_LOCK ? SVt_PVCV
d5910 1
a5910 1
		  whicharg, OP_DESC(PL_op->op_next),
d5913 1
a5913 1
		    : opnum == OP_LOCK
d5918 9
a5926 1
	    break;
d5928 1
d5943 1
a5943 7
	PERL_SI * const oldsi = PL_curstackinfo;
	I32 const oldcxix = oldsi->si_cxix;
	if (oldcxix) oldsi->si_cxix--;
	else PL_curstackinfo = oldsi->si_prev;
	cv = find_runcv(NULL);
	PL_curstackinfo = oldsi;
	oldsi->si_cxix = oldcxix;
d5955 1
a5955 1
 * indent-tabs-mode: t
d5958 1
a5958 1
 * ex: set ts=8 sts=4 sw=4 noet:
@


1.15
log
@Perl security fix for CVE-2011-1487:
ucfirst(), uc() and lc() forget to set the tainted flag if input
was marked as tainted.

http://rt.perl.org/rt3/Public/Bug/Display.html?id=87336
http://perl5.git.perl.org/perl.git/commitdiff/539689e74a3bcb04d29e4cd9396de91a81045b99

ok millert@@
@
text
@d74 3
a76 1
    } else if (LVRET) {
d78 1
d82 1
d121 3
a123 1
    else if (LVRET) {
d125 1
d128 1
d132 1
a132 1
	RETURNOP(do_kv());
d146 11
a156 1
PP(pp_rv2gv)
d158 2
a159 2
    dVAR; dSP; dTOPss;

d161 3
a164 2
	tryAMAGICunDEREF(to_gv);

d168 1
a168 1
	    gv_init(gv, 0, "", 0, 0);
d174 1
a174 1
	    DIE(aTHX_ "Not a GLOB reference");
d178 1
a178 6
	    if (SvGMAGICAL(sv)) {
		mg_get(sv);
		if (SvROK(sv))
		    goto wasref;
	    }
	    if (!SvOK(sv) && sv != &PL_sv_undef) {
d182 1
a182 3
		if (SvREADONLY(sv))
		    Perl_croak(aTHX_ "%s", PL_no_modify);
		if (PL_op->op_private & OPpDEREF) {
d184 2
a186 1
			STRLEN len;
a187 1
			const char * const name = SvPV(namesv, len);
d189 1
a189 1
			gv_init(gv, CopSTASH(PL_curcop), name, len, 0);
d193 2
a194 1
			gv = newGVgen(name);
d202 2
a203 3
		if (PL_op->op_flags & OPf_REF ||
		    PL_op->op_private & HINT_STRICT_REFS)
		    DIE(aTHX_ PL_no_usym, "a symbol");
d206 1
a206 1
		RETSETUNDEF;
d208 1
a208 2
	    if ((PL_op->op_flags & OPf_SPECIAL) &&
		!(PL_op->op_flags & OPf_MOD))
d210 4
a213 8
		SV * const temp = MUTABLE_SV(gv_fetchsv(sv, 0, SVt_PVGV));
		if (!temp
		    && (!is_gv_magical_sv(sv,0)
			|| !(sv = MUTABLE_SV(gv_fetchsv(sv, GV_ADD,
							SVt_PVGV))))) {
		    RETSETUNDEF;
		}
		sv = temp;
d216 8
a223 2
		if (PL_op->op_private & HINT_STRICT_REFS)
		    DIE(aTHX_ S_no_symref_sv, sv, (SvPOK(sv) && SvCUR(sv)>32 ? "..." : ""), "a symbol");
d229 1
a229 1
		    RETURN;
d231 1
a231 1
		sv = MUTABLE_SV(gv_fetchsv(sv, GV_ADD, SVt_PVGV));
d233 2
d237 19
d279 4
a282 1
	if (PL_op->op_flags & OPf_REF)
d296 1
a296 4
	    gv = gv_fetchsv(sv, 0, type);
	    if (!gv
		&& (!is_gv_magical_sv(sv,0)
		    || !(gv = gv_fetchsv(sv, GV_ADD, type))))
d303 1
a303 1
	gv = gv_fetchsv(sv, GV_ADD, type);
d313 1
d315 3
a317 2
      wasref:
	tryAMAGICunDEREF(to_sv);
a333 5
	    if (SvGMAGICAL(sv)) {
		mg_get(sv);
		if (SvROK(sv))
		    goto wasref;
	    }
d350 1
a350 1
	    vivify_ref(sv, PL_op->op_private & OPpDEREF);
d369 1
a369 3
	SETs(sv_2mortal(newSViv(
	    AvFILL(MUTABLE_AV(av)) + CopARYBASE_get(PL_curcop)
	)));
d376 1
a376 1
    dVAR; dSP; dTARGET; dPOPss;
d379 5
a383 11
	if (SvTYPE(TARG) < SVt_PVLV) {
	    sv_upgrade(TARG, SVt_PVLV);
	    sv_magic(TARG, NULL, PERL_MAGIC_pos, NULL, 0);
	}

	LvTYPE(TARG) = '.';
	if (LvTARG(TARG) != sv) {
	    SvREFCNT_dec(LvTARG(TARG));
	    LvTARG(TARG) = SvREFCNT_inc_simple(sv);
	}
	PUSHs(TARG);	/* no SvSETMAGIC */
d390 1
d394 1
a394 1
		PUSHi(i + CopARYBASE_get(PL_curcop));
d408 1
a408 1
	? 0
a418 6
	if ((PL_op->op_private & OPpLVAL_INTRO)) {
	    if (gv && GvCV(gv) == cv && (gv = gv_autoload4(GvSTASH(gv), GvNAME(gv), GvNAMELEN(gv), FALSE)))
		cv = GvCV(gv);
	    if (!CvLVALUE(cv))
		DIE(aTHX_ "Can't modify non-lvalue subroutine call");
	}
d441 2
d444 2
a445 56
#define MAX_ARGS_OP ((sizeof(I32) - 1) * 2)
		int i = 0, n = 0, seen_question = 0, defgv = 0;
		I32 oa;
		char str[ MAX_ARGS_OP * 2 + 2 ]; /* One ';', one '\0' */

		if (code == -KEY_chop || code == -KEY_chomp
			|| code == -KEY_exec || code == -KEY_system)
		    goto set;
		if (code == -KEY_mkdir) {
		    ret = newSVpvs_flags("_;$", SVs_TEMP);
		    goto set;
		}
		if (code == -KEY_keys || code == -KEY_values || code == -KEY_each) {
		    ret = newSVpvs_flags("\\[@@%]", SVs_TEMP);
		    goto set;
		}
		if (code == -KEY_readpipe) {
		    s = "CORE::backtick";
		}
		while (i < MAXO) {	/* The slow way. */
		    if (strEQ(s + 6, PL_op_name[i])
			|| strEQ(s + 6, PL_op_desc[i]))
		    {
			goto found;
		    }
		    i++;
		}
		goto nonesuch;		/* Should not happen... */
	      found:
		defgv = PL_opargs[i] & OA_DEFGV;
		oa = PL_opargs[i] >> OASHIFT;
		while (oa) {
		    if (oa & OA_OPTIONAL && !seen_question && !defgv) {
			seen_question = 1;
			str[n++] = ';';
		    }
		    if ((oa & (OA_OPTIONAL - 1)) >= OA_AVREF
			&& (oa & (OA_OPTIONAL - 1)) <= OA_SCALARREF
			/* But globs are already references (kinda) */
			&& (oa & (OA_OPTIONAL - 1)) != OA_FILEREF
		    ) {
			str[n++] = '\\';
		    }
		    str[n++] = ("?$@@@@%&*$")[oa & (OA_OPTIONAL - 1)];
		    oa = oa >> 4;
		}
		if (defgv && str[n - 1] == '$')
		    str[n - 1] = '_';
		str[n++] = '\0';
		ret = newSVpvn_flags(str, n - 1, SVs_TEMP);
	    }
	    else if (code)		/* Non-Overridable */
		goto set;
	    else {			/* None such */
	      nonesuch:
		DIE(aTHX_ "Can't find an opnumber for \"%s\"", s+6);
d447 1
d452 3
a454 1
	ret = newSVpvn_flags(SvPVX_const(cv), SvCUR(cv), SVs_TEMP);
a533 1
    const char *pv;
d542 2
a543 2
    pv = sv_reftype(SvRV(sv),TRUE);
    PUSHp(pv, strlen(pv));
d553 1
d560 2
a561 1
	if (ssv && !SvGMAGICAL(ssv) && !SvAMAGIC(ssv) && SvROK(ssv))
d567 1
a567 1
	stash = gv_stashpvn(ptr, len, GV_ADD);
d579 2
a580 1
    const char * const elem = SvPV_nolen_const(sv);
d590 1
a590 1
	    if (strEQ(second_letter, "RRAY"))
d594 1
a594 1
	    if (strEQ(second_letter, "ODE"))
d598 1
a598 1
	    if (strEQ(second_letter, "ILEHANDLE")) {
d604 1
a604 1
		if (strEQ(second_letter, "ORMAT"))
d608 1
a608 1
	    if (strEQ(second_letter, "LOB"))
d612 1
a612 1
	    if (strEQ(second_letter, "ASH"))
d616 1
a616 1
	    if (*second_letter == 'O' && !elem[2])
d620 1
a620 1
	    if (strEQ(second_letter, "AME"))
d624 1
a624 1
	    if (strEQ(second_letter, "ACKAGE")) {
d631 1
a631 1
	    if (strEQ(second_letter, "CALAR"))
d652 1
a652 4
    register I32 pos;
    register I32 ch;
    register I32 *sfirst;
    register I32 *snext;
d654 6
a660 4
    if (sv == PL_lastscream) {
	if (SvSCREAM(sv))
	    RETPUSHYES;
    }
d662 1
a662 2
    pos = len;
    if (pos <= 0 || !SvPOK(sv) || SvUTF8(sv)) {
d667 6
a672 1
	   stringification.  */
d676 4
a679 5
    if (PL_lastscream) {
	SvSCREAM_off(PL_lastscream);
	SvREFCNT_dec(PL_lastscream);
    }
    PL_lastscream = SvREFCNT_inc_simple(sv);
d681 6
a686 15
    s = (unsigned char*)(SvPV(sv, len));
    pos = len;
    if (pos <= 0)
	RETPUSHNO;
    if (pos > PL_maxscream) {
	if (PL_maxscream < 0) {
	    PL_maxscream = pos + 80;
	    Newx(PL_screamfirst, 256, I32);
	    Newx(PL_screamnext, PL_maxscream, I32);
	}
	else {
	    PL_maxscream = pos + pos / 4;
	    Renew(PL_screamnext, PL_maxscream, I32);
	}
    }
d688 2
a689 2
    sfirst = PL_screamfirst;
    snext = PL_screamnext;
d691 1
a691 1
    if (!sfirst || !snext)
d694 39
a732 11
    for (ch = 256; ch; --ch)
	*sfirst++ = -1;
    sfirst -= 256;

    while (--pos >= 0) {
	register const I32 ch = s[pos];
	if (sfirst[ch] >= 0)
	    snext[pos] = sfirst[ch] - pos;
	else
	    snext[pos] = -pos;
	sfirst[ch] = pos;
a734 3
    SvSCREAM_on(sv);
    /* piggyback on m//g magic */
    sv_magic(sv, NULL, PERL_MAGIC_regex_global, NULL, 0);
d752 8
a759 1
    PUSHi(do_trans(sv));
d765 167
d935 5
a939 1
    do_chop(TARG, TOPs);
d947 4
d952 1
a952 1
	do_chop(TARG, *++MARK);
a957 18
PP(pp_schomp)
{
    dVAR; dSP; dTARGET;
    SETi(do_chomp(TOPs));
    RETURN;
}

PP(pp_chomp)
{
    dVAR; dSP; dMARK; dTARGET;
    register I32 count = 0;

    while (SP > MARK)
	count += do_chomp(POPs);
    XPUSHi(count);
    RETURN;
}

d985 5
a989 3
	    Perl_ck_warner(aTHX_ packWARN(WARN_MISC), "Constant subroutine %s undefined",
			   CvANON((const CV *)sv) ? "(anonymous)"
			   : GvENAME(CvGV((const CV *)sv)));
d996 1
a996 1
	    CvGV((const CV *)sv) = gv;
d1008 4
d1013 5
a1017 6
            if((stash = GvHV((const GV *)sv)) && HvNAME_get(stash))
                mro_isa_changed_in(stash);
            /* undef *Pkg::meth_name ... */
            else if(GvCVu((const GV *)sv) && (stash = GvSTASH((const GV *)sv))
		    && HvNAME_get(stash))
                mro_method_changed_in(stash);
d1021 1
a1021 1
	    GvGP(sv) = gp_ref(gp);
d1026 14
a1055 17
PP(pp_predec)
{
    dVAR; dSP;
    if (SvTYPE(TOPs) >= SVt_PVAV || isGV_with_GP(TOPs))
	DIE(aTHX_ "%s", PL_no_modify);
    if (!SvREADONLY(TOPs) && SvIOK_notUV(TOPs) && !SvNOK(TOPs) && !SvPOK(TOPs)
        && SvIVX(TOPs) != IV_MIN)
    {
	SvIV_set(TOPs, SvIVX(TOPs) - 1);
	SvFLAGS(TOPs) &= ~(SVp_NOK|SVp_POK);
    }
    else
	sv_dec(TOPs);
    SvSETMAGIC(TOPs);
    return NORMAL;
}

d1059 6
a1064 2
    if (SvTYPE(TOPs) >= SVt_PVAV || isGV_with_GP(TOPs))
	DIE(aTHX_ "%s", PL_no_modify);
d1067 1
a1067 1
        && SvIVX(TOPs) != IV_MAX)
d1069 1
a1069 1
	SvIV_set(TOPs, SvIVX(TOPs) + 1);
d1072 3
a1074 2
    else
	sv_inc(TOPs);
d1077 1
a1077 1
    if (!SvOK(TARG))
a1082 19
PP(pp_postdec)
{
    dVAR; dSP; dTARGET;
    if (SvTYPE(TOPs) >= SVt_PVAV || isGV_with_GP(TOPs))
	DIE(aTHX_ "%s", PL_no_modify);
    sv_setsv(TARG, TOPs);
    if (!SvREADONLY(TOPs) && SvIOK_notUV(TOPs) && !SvNOK(TOPs) && !SvPOK(TOPs)
        && SvIVX(TOPs) != IV_MIN)
    {
	SvIV_set(TOPs, SvIVX(TOPs) - 1);
	SvFLAGS(TOPs) &= ~(SVp_NOK|SVp_POK);
    }
    else
	sv_dec(TOPs);
    SvSETMAGIC(TOPs);
    SETs(TARG);
    return NORMAL;
}

d1091 3
a1093 3
    tryAMAGICbin(pow,opASSIGN);
    svl = sv_2num(TOPm1s);
    svr = sv_2num(TOPs);
d1099 1
a1099 1
	SvIV_please(svr);
d1101 1
a1101 1
	    SvIV_please(svl);
d1157 1
a1157 1
                    SvIV_please(svr);
d1174 1
a1174 1
			const bool odd_power = (bool)(power & 1);
d1206 2
a1207 2
	NV right = SvNV(svr);
	NV left  = SvNV(svl);
d1252 1
a1252 1
	    SvIV_please(svr);
d1261 3
a1263 3
    tryAMAGICbin(mult,opASSIGN);
    svl = sv_2num(TOPm1s);
    svr = sv_2num(TOPs);
d1265 1
a1265 1
    SvIV_please(svr);
d1271 1
a1271 1
	SvIV_please(svl);
d1374 2
a1375 2
      NV right = SvNV(svr);
      NV left  = SvNV(svl);
d1385 3
a1387 3
    tryAMAGICbin(div,opASSIGN);
    svl = sv_2num(TOPm1s);
    svr = sv_2num(TOPs);
d1410 1
a1410 1
    SvIV_please(svr);
d1412 1
a1412 1
        SvIV_please(svl);
d1436 1
a1436 1
               no inpsection would give no warning.  */
d1492 2
a1493 2
	NV right = SvNV(svr);
	NV left  = SvNV(svl);
d1508 2
a1509 1
    dVAR; dSP; dATARGET; tryAMAGICbin(modulo,opASSIGN);
d1519 3
a1521 3
        SV * svl;
        SV * const svr = sv_2num(TOPs);
        SvIV_please(svr);
d1537 1
a1537 1
	    dright = SvNV(svr);
a1547 1
	sp--;
d1552 1
a1552 2
        svl = sv_2num(TOPs);
        SvIV_please(svl);
d1570 1
a1570 1
	    dleft = SvNV(svl);
d1598 1
a1598 1
	sp--;
d1639 1
a1639 2
  dVAR; dSP; dATARGET; tryAMAGICbin(repeat,opASSIGN);
  {
d1641 12
a1652 2
    dPOPss;
    SvGETMAGIC(sv);
d1655 1
a1655 1
	      const UV uv = SvUV(sv);
d1661 1
a1661 1
	      const IV iv = SvIV(sv);
d1669 1
a1669 1
	 const NV nv = SvNV(sv);
d1676 2
a1677 1
	 count = SvIV(sv);
d1735 3
a1737 2
	SvSetSV(TARG, tmpstr);
	SvPV_force(TARG, len);
a1769 1
  }
d1775 3
a1777 3
    tryAMAGICbin(subtr,opASSIGN);
    svl = sv_2num(TOPm1s);
    svr = sv_2num(TOPs);
d1782 1
a1782 1
    SvIV_please(svr);
d1797 1
a1797 1
	    SvIV_please(svl);
d1880 1
a1880 1
	NV value = SvNV(svr);
d1888 1
a1888 1
	SETn( SvNV(svl) - value );
d1895 4
a1898 1
    dVAR; dSP; dATARGET; tryAMAGICbin(lshift,opASSIGN);
d1900 1
a1900 1
      const IV shift = POPi;
d1902 1
a1902 1
	const IV i = TOPi;
d1906 1
a1906 1
	const UV u = TOPu;
d1915 4
a1918 1
    dVAR; dSP; dATARGET; tryAMAGICbin(rshift,opASSIGN);
d1920 1
a1920 1
      const IV shift = POPi;
d1922 1
a1922 1
	const IV i = TOPi;
d1926 1
a1926 1
	const UV u = TOPu;
d1935 90
a2024 1
    dVAR; dSP; tryAMAGICbinSET(lt,0);
d2026 20
a2045 14
    SvIV_please(TOPs);
    if (SvIOK(TOPs)) {
	SvIV_please(TOPm1s);
	if (SvIOK(TOPm1s)) {
	    bool auvok = SvUOK(TOPm1s);
	    bool buvok = SvUOK(TOPs);
	
	    if (!auvok && !buvok) { /* ## IV < IV ## */
		const IV aiv = SvIVX(TOPm1s);
		const IV biv = SvIVX(TOPs);
		
		SP--;
		SETs(boolSV(aiv < biv));
		RETURN;
d2047 6
a2052 7
	    if (auvok && buvok) { /* ## UV < UV ## */
		const UV auv = SvUVX(TOPm1s);
		const UV buv = SvUVX(TOPs);
		
		SP--;
		SETs(boolSV(auv < buv));
		RETURN;
d2054 4
a2057 5
	    if (auvok) { /* ## UV < IV ## */
		UV auv;
		const IV biv = SvIVX(TOPs);
		SP--;
		if (biv < 0) {
d2059 4
a2062 16
		    SETs(&PL_sv_no);
		    RETURN;
		}
		auv = SvUVX(TOPs);
		SETs(boolSV(auv < (UV)biv));
		RETURN;
	    }
	    { /* ## IV < UV ## */
		const IV aiv = SvIVX(TOPm1s);
		UV buv;
		
		if (aiv < 0) {
		    /* As (b) is a UV, it's >=0, so it must be < */
		    SP--;
		    SETs(&PL_sv_yes);
		    RETURN;
a2063 4
		buv = SvUVX(TOPs);
		SP--;
		SETs(boolSV((UV)aiv < buv));
		RETURN;
d2065 1
a2068 10
#ifndef NV_PRESERVES_UV
#ifdef PERL_PRESERVE_IVUV
    else
#endif
    if (SvROK(TOPs) && !SvAMAGIC(TOPs) && SvROK(TOPm1s) && !SvAMAGIC(TOPm1s)) {
	SP--;
	SETs(boolSV(SvRV(TOPs) < SvRV(TOPp1s)));
	RETURN;
    }
#endif
d2070 3
d2074 4
a2077 4
      dPOPTOPnnrl;
      if (Perl_isnan(left) || Perl_isnan(right))
	  RETSETNO;
      SETs(boolSV(left < right));
d2079 7
a2085 2
      dPOPnv;
      SETs(boolSV(TOPn < value));
a2086 1
      RETURN;
d2090 2
a2091 1
PP(pp_gt)
d2093 16
a2108 12
    dVAR; dSP; tryAMAGICbinSET(gt,0);
#ifdef PERL_PRESERVE_IVUV
    SvIV_please(TOPs);
    if (SvIOK(TOPs)) {
	SvIV_please(TOPm1s);
	if (SvIOK(TOPm1s)) {
	    bool auvok = SvUOK(TOPm1s);
	    bool buvok = SvUOK(TOPs);
	
	    if (!auvok && !buvok) { /* ## IV > IV ## */
		const IV aiv = SvIVX(TOPm1s);
		const IV biv = SvIVX(TOPs);
d2110 3
a2112 15
		SP--;
		SETs(boolSV(aiv > biv));
		RETURN;
	    }
	    if (auvok && buvok) { /* ## UV > UV ## */
		const UV auv = SvUVX(TOPm1s);
		const UV buv = SvUVX(TOPs);
		
		SP--;
		SETs(boolSV(auv > buv));
		RETURN;
	    }
	    if (auvok) { /* ## UV > IV ## */
		UV auv;
		const IV biv = SvIVX(TOPs);
d2114 1
a2114 403
		SP--;
		if (biv < 0) {
		    /* As (a) is a UV, it's >=0, so it must be > */
		    SETs(&PL_sv_yes);
		    RETURN;
		}
		auv = SvUVX(TOPs);
		SETs(boolSV(auv > (UV)biv));
		RETURN;
	    }
	    { /* ## IV > UV ## */
		const IV aiv = SvIVX(TOPm1s);
		UV buv;
		
		if (aiv < 0) {
		    /* As (b) is a UV, it's >=0, so it cannot be > */
		    SP--;
		    SETs(&PL_sv_no);
		    RETURN;
		}
		buv = SvUVX(TOPs);
		SP--;
		SETs(boolSV((UV)aiv > buv));
		RETURN;
	    }
	}
    }
#endif
#ifndef NV_PRESERVES_UV
#ifdef PERL_PRESERVE_IVUV
    else
#endif
    if (SvROK(TOPs) && !SvAMAGIC(TOPs) && SvROK(TOPm1s) && !SvAMAGIC(TOPm1s)) {
        SP--;
        SETs(boolSV(SvRV(TOPs) > SvRV(TOPp1s)));
        RETURN;
    }
#endif
    {
#if defined(NAN_COMPARE_BROKEN) && defined(Perl_isnan)
      dPOPTOPnnrl;
      if (Perl_isnan(left) || Perl_isnan(right))
	  RETSETNO;
      SETs(boolSV(left > right));
#else
      dPOPnv;
      SETs(boolSV(TOPn > value));
#endif
      RETURN;
    }
}

PP(pp_le)
{
    dVAR; dSP; tryAMAGICbinSET(le,0);
#ifdef PERL_PRESERVE_IVUV
    SvIV_please(TOPs);
    if (SvIOK(TOPs)) {
	SvIV_please(TOPm1s);
	if (SvIOK(TOPm1s)) {
	    bool auvok = SvUOK(TOPm1s);
	    bool buvok = SvUOK(TOPs);
	
	    if (!auvok && !buvok) { /* ## IV <= IV ## */
		const IV aiv = SvIVX(TOPm1s);
		const IV biv = SvIVX(TOPs);
		
		SP--;
		SETs(boolSV(aiv <= biv));
		RETURN;
	    }
	    if (auvok && buvok) { /* ## UV <= UV ## */
		UV auv = SvUVX(TOPm1s);
		UV buv = SvUVX(TOPs);
		
		SP--;
		SETs(boolSV(auv <= buv));
		RETURN;
	    }
	    if (auvok) { /* ## UV <= IV ## */
		UV auv;
		const IV biv = SvIVX(TOPs);

		SP--;
		if (biv < 0) {
		    /* As (a) is a UV, it's >=0, so a cannot be <= */
		    SETs(&PL_sv_no);
		    RETURN;
		}
		auv = SvUVX(TOPs);
		SETs(boolSV(auv <= (UV)biv));
		RETURN;
	    }
	    { /* ## IV <= UV ## */
		const IV aiv = SvIVX(TOPm1s);
		UV buv;

		if (aiv < 0) {
		    /* As (b) is a UV, it's >=0, so a must be <= */
		    SP--;
		    SETs(&PL_sv_yes);
		    RETURN;
		}
		buv = SvUVX(TOPs);
		SP--;
		SETs(boolSV((UV)aiv <= buv));
		RETURN;
	    }
	}
    }
#endif
#ifndef NV_PRESERVES_UV
#ifdef PERL_PRESERVE_IVUV
    else
#endif
    if (SvROK(TOPs) && !SvAMAGIC(TOPs) && SvROK(TOPm1s) && !SvAMAGIC(TOPm1s)) {
        SP--;
        SETs(boolSV(SvRV(TOPs) <= SvRV(TOPp1s)));
        RETURN;
    }
#endif
    {
#if defined(NAN_COMPARE_BROKEN) && defined(Perl_isnan)
      dPOPTOPnnrl;
      if (Perl_isnan(left) || Perl_isnan(right))
	  RETSETNO;
      SETs(boolSV(left <= right));
#else
      dPOPnv;
      SETs(boolSV(TOPn <= value));
#endif
      RETURN;
    }
}

PP(pp_ge)
{
    dVAR; dSP; tryAMAGICbinSET(ge,0);
#ifdef PERL_PRESERVE_IVUV
    SvIV_please(TOPs);
    if (SvIOK(TOPs)) {
	SvIV_please(TOPm1s);
	if (SvIOK(TOPm1s)) {
	    bool auvok = SvUOK(TOPm1s);
	    bool buvok = SvUOK(TOPs);
	
	    if (!auvok && !buvok) { /* ## IV >= IV ## */
		const IV aiv = SvIVX(TOPm1s);
		const IV biv = SvIVX(TOPs);

		SP--;
		SETs(boolSV(aiv >= biv));
		RETURN;
	    }
	    if (auvok && buvok) { /* ## UV >= UV ## */
		const UV auv = SvUVX(TOPm1s);
		const UV buv = SvUVX(TOPs);

		SP--;
		SETs(boolSV(auv >= buv));
		RETURN;
	    }
	    if (auvok) { /* ## UV >= IV ## */
		UV auv;
		const IV biv = SvIVX(TOPs);

		SP--;
		if (biv < 0) {
		    /* As (a) is a UV, it's >=0, so it must be >= */
		    SETs(&PL_sv_yes);
		    RETURN;
		}
		auv = SvUVX(TOPs);
		SETs(boolSV(auv >= (UV)biv));
		RETURN;
	    }
	    { /* ## IV >= UV ## */
		const IV aiv = SvIVX(TOPm1s);
		UV buv;

		if (aiv < 0) {
		    /* As (b) is a UV, it's >=0, so a cannot be >= */
		    SP--;
		    SETs(&PL_sv_no);
		    RETURN;
		}
		buv = SvUVX(TOPs);
		SP--;
		SETs(boolSV((UV)aiv >= buv));
		RETURN;
	    }
	}
    }
#endif
#ifndef NV_PRESERVES_UV
#ifdef PERL_PRESERVE_IVUV
    else
#endif
    if (SvROK(TOPs) && !SvAMAGIC(TOPs) && SvROK(TOPm1s) && !SvAMAGIC(TOPm1s)) {
        SP--;
        SETs(boolSV(SvRV(TOPs) >= SvRV(TOPp1s)));
        RETURN;
    }
#endif
    {
#if defined(NAN_COMPARE_BROKEN) && defined(Perl_isnan)
      dPOPTOPnnrl;
      if (Perl_isnan(left) || Perl_isnan(right))
	  RETSETNO;
      SETs(boolSV(left >= right));
#else
      dPOPnv;
      SETs(boolSV(TOPn >= value));
#endif
      RETURN;
    }
}

PP(pp_ne)
{
    dVAR; dSP; tryAMAGICbinSET(ne,0);
#ifndef NV_PRESERVES_UV
    if (SvROK(TOPs) && !SvAMAGIC(TOPs) && SvROK(TOPm1s) && !SvAMAGIC(TOPm1s)) {
        SP--;
	SETs(boolSV(SvRV(TOPs) != SvRV(TOPp1s)));
	RETURN;
    }
#endif
#ifdef PERL_PRESERVE_IVUV
    SvIV_please(TOPs);
    if (SvIOK(TOPs)) {
	SvIV_please(TOPm1s);
	if (SvIOK(TOPm1s)) {
	    const bool auvok = SvUOK(TOPm1s);
	    const bool buvok = SvUOK(TOPs);
	
	    if (auvok == buvok) { /* ## IV == IV or UV == UV ## */
                /* Casting IV to UV before comparison isn't going to matter
                   on 2s complement. On 1s complement or sign&magnitude
                   (if we have any of them) it could make negative zero
                   differ from normal zero. As I understand it. (Need to
                   check - is negative zero implementation defined behaviour
                   anyway?). NWC  */
		const UV buv = SvUVX(POPs);
		const UV auv = SvUVX(TOPs);

		SETs(boolSV(auv != buv));
		RETURN;
	    }
	    {			/* ## Mixed IV,UV ## */
		IV iv;
		UV uv;
		
		/* != is commutative so swap if needed (save code) */
		if (auvok) {
		    /* swap. top of stack (b) is the iv */
		    iv = SvIVX(TOPs);
		    SP--;
		    if (iv < 0) {
			/* As (a) is a UV, it's >0, so it cannot be == */
			SETs(&PL_sv_yes);
			RETURN;
		    }
		    uv = SvUVX(TOPs);
		} else {
		    iv = SvIVX(TOPm1s);
		    SP--;
		    if (iv < 0) {
			/* As (b) is a UV, it's >0, so it cannot be == */
			SETs(&PL_sv_yes);
			RETURN;
		    }
		    uv = SvUVX(*(SP+1)); /* Do I want TOPp1s() ? */
		}
		SETs(boolSV((UV)iv != uv));
		RETURN;
	    }
	}
    }
#endif
    {
#if defined(NAN_COMPARE_BROKEN) && defined(Perl_isnan)
      dPOPTOPnnrl;
      if (Perl_isnan(left) || Perl_isnan(right))
	  RETSETYES;
      SETs(boolSV(left != right));
#else
      dPOPnv;
      SETs(boolSV(TOPn != value));
#endif
      RETURN;
    }
}

PP(pp_ncmp)
{
    dVAR; dSP; dTARGET; tryAMAGICbin(ncmp,0);
#ifndef NV_PRESERVES_UV
    if (SvROK(TOPs) && !SvAMAGIC(TOPs) && SvROK(TOPm1s) && !SvAMAGIC(TOPm1s)) {
	const UV right = PTR2UV(SvRV(POPs));
	const UV left = PTR2UV(SvRV(TOPs));
	SETi((left > right) - (left < right));
	RETURN;
    }
#endif
#ifdef PERL_PRESERVE_IVUV
    /* Fortunately it seems NaN isn't IOK */
    SvIV_please(TOPs);
    if (SvIOK(TOPs)) {
	SvIV_please(TOPm1s);
	if (SvIOK(TOPm1s)) {
	    const bool leftuvok = SvUOK(TOPm1s);
	    const bool rightuvok = SvUOK(TOPs);
	    I32 value;
	    if (!leftuvok && !rightuvok) { /* ## IV <=> IV ## */
		const IV leftiv = SvIVX(TOPm1s);
		const IV rightiv = SvIVX(TOPs);
		
		if (leftiv > rightiv)
		    value = 1;
		else if (leftiv < rightiv)
		    value = -1;
		else
		    value = 0;
	    } else if (leftuvok && rightuvok) { /* ## UV <=> UV ## */
		const UV leftuv = SvUVX(TOPm1s);
		const UV rightuv = SvUVX(TOPs);
		
		if (leftuv > rightuv)
		    value = 1;
		else if (leftuv < rightuv)
		    value = -1;
		else
		    value = 0;
	    } else if (leftuvok) { /* ## UV <=> IV ## */
		const IV rightiv = SvIVX(TOPs);
		if (rightiv < 0) {
		    /* As (a) is a UV, it's >=0, so it cannot be < */
		    value = 1;
		} else {
		    const UV leftuv = SvUVX(TOPm1s);
		    if (leftuv > (UV)rightiv) {
			value = 1;
		    } else if (leftuv < (UV)rightiv) {
			value = -1;
		    } else {
			value = 0;
		    }
		}
	    } else { /* ## IV <=> UV ## */
		const IV leftiv = SvIVX(TOPm1s);
		if (leftiv < 0) {
		    /* As (b) is a UV, it's >=0, so it must be < */
		    value = -1;
		} else {
		    const UV rightuv = SvUVX(TOPs);
		    if ((UV)leftiv > rightuv) {
			value = 1;
		    } else if ((UV)leftiv < rightuv) {
			value = -1;
		    } else {
			value = 0;
		    }
		}
	    }
	    SP--;
	    SETi(value);
	    RETURN;
	}
    }
#endif
    {
      dPOPTOPnnrl;
      I32 value;

#ifdef Perl_isnan
      if (Perl_isnan(left) || Perl_isnan(right)) {
	  SETs(&PL_sv_undef);
	  RETURN;
       }
      value = (left > right) - (left < right);
#else
      if (left == right)
	value = 0;
      else if (left < right)
	value = -1;
      else if (left > right)
	value = 1;
      else {
	SETs(&PL_sv_undef);
	RETURN;
      }
#endif
      SETi(value);
      RETURN;
    }
}

PP(pp_sle)
{
    dVAR; dSP;

    int amg_type = sle_amg;
d2137 1
a2137 1
    tryAMAGICbinSET_var(amg_type,0);
d2141 2
a2142 2
		 ? sv_cmp_locale(left, right)
		 : sv_cmp(left, right));
d2150 2
a2151 1
    dVAR; dSP; tryAMAGICbinSET(seq,0);
d2154 1
a2154 1
      SETs(boolSV(sv_eq(left, right)));
d2161 2
a2162 1
    dVAR; dSP; tryAMAGICbinSET(sne,0);
d2165 1
a2165 1
      SETs(boolSV(!sv_eq(left, right)));
d2172 2
a2173 1
    dVAR; dSP; dTARGET;  tryAMAGICbin(scmp,0);
d2177 2
a2178 2
		 ? sv_cmp_locale(left, right)
		 : sv_cmp(left, right));
d2186 2
a2187 1
    dVAR; dSP; dATARGET; tryAMAGICbin(band,opASSIGN);
a2189 2
      SvGETMAGIC(left);
      SvGETMAGIC(right);
d2191 2
d2201 2
d2217 1
a2217 1
    tryAMAGICbin_var((op_type == OP_BIT_OR ? bor_amg : bxor_amg), opASSIGN);
a2219 2
      SvGETMAGIC(left);
      SvGETMAGIC(right);
d2221 2
d2235 2
d2248 2
a2249 1
    dVAR; dSP; dTARGET; tryAMAGICun(neg);
d2251 1
a2251 1
	SV * const sv = sv_2num(TOPs);
d2253 5
a2257 1
	SvGETMAGIC(sv);
d2284 1
a2284 1
	    SETn(-SvNV(sv));
d2287 1
a2287 1
	    const char * const s = SvPV_const(sv, len);
d2293 2
a2294 2
		sv_setsv(TARG, sv);
		*SvPV_force(TARG, len) = *s == '-' ? '+' : '-';
d2297 1
a2297 1
		SvIV_please(sv);
d2301 1
a2301 1
		    sv_setnv(TARG, -SvNV(sv));
d2308 1
a2308 1
		SvIV_please(sv);
d2311 1
a2311 1
		sv_setnv(TARG, -SvNV(sv));
d2316 1
a2316 1
	    SETn(-SvNV(sv));
d2323 3
a2325 2
    dVAR; dSP; tryAMAGICunSET(not);
    *PL_stack_sp = boolSV(!SvTRUE(*PL_stack_sp));
d2331 2
a2332 1
    dVAR; dSP; dTARGET; tryAMAGICun(compl);
a2334 1
      SvGETMAGIC(sv);
d2352 1
a2352 1
	tmps = (U8*)SvPV_force(TARG, len);
d2433 2
a2434 1
    dVAR; dSP; dATARGET; tryAMAGICbin(mult,opASSIGN);
d2436 1
a2436 1
      dPOPTOPiirl;
d2445 2
a2446 1
    dVAR; dSP; dATARGET; tryAMAGICbin(div,opASSIGN);
d2448 2
a2449 1
      dPOPiv;
d2452 1
a2452 1
      num = POPi;
d2459 1
a2459 1
      PUSHi( value );
d2472 2
a2473 1
     dVAR; dSP; dATARGET; tryAMAGICbin(modulo,opASSIGN);
d2475 1
a2475 1
	  dPOPTOPiirl;
d2495 2
a2496 1
     dVAR; dSP; dATARGET; tryAMAGICbin(modulo,opASSIGN);
d2498 1
a2498 1
	  dPOPTOPiirl;
d2512 2
a2513 1
     dVAR; dSP; dATARGET; tryAMAGICbin(modulo,opASSIGN);
d2515 1
a2515 1
	  dPOPTOPiirl;
d2556 2
a2557 1
    dVAR; dSP; dATARGET; tryAMAGICbin(add,opASSIGN);
d2559 1
a2559 1
      dPOPTOPiirl_ul;
d2567 2
a2568 1
    dVAR; dSP; dATARGET; tryAMAGICbin(subtr,opASSIGN);
d2570 1
a2570 1
      dPOPTOPiirl_ul;
d2578 2
a2579 1
    dVAR; dSP; tryAMAGICbinSET(lt,0);
d2581 1
a2581 1
      dPOPTOPiirl;
d2589 2
a2590 1
    dVAR; dSP; tryAMAGICbinSET(gt,0);
d2592 1
a2592 1
      dPOPTOPiirl;
d2600 2
a2601 1
    dVAR; dSP; tryAMAGICbinSET(le,0);
d2603 1
a2603 1
      dPOPTOPiirl;
d2611 2
a2612 1
    dVAR; dSP; tryAMAGICbinSET(ge,0);
d2614 1
a2614 1
      dPOPTOPiirl;
d2622 2
a2623 1
    dVAR; dSP; tryAMAGICbinSET(eq,0);
d2625 1
a2625 1
      dPOPTOPiirl;
d2633 2
a2634 1
    dVAR; dSP; tryAMAGICbinSET(ne,0);
d2636 1
a2636 1
      dPOPTOPiirl;
d2644 2
a2645 1
    dVAR; dSP; dTARGET; tryAMAGICbin(ncmp,0);
d2647 1
a2647 1
      dPOPTOPiirl;
d2663 8
a2670 3
    dVAR; dSP; dTARGET; tryAMAGICun(neg);
    SETi(-TOPi);
    RETURN;
d2677 2
a2678 1
    dVAR; dSP; dTARGET; tryAMAGICbin(atan2,0);
d2680 1
a2680 1
      dPOPTOPnnrl;
d2715 2
a2716 1
    tryAMAGICun_var(amg_type);
d2718 2
a2719 1
      const NV value = POPn;
d2723 1
d2753 3
d2771 2
a2772 2
    dVAR; dSP;
    const UV anum = (MAXARG < 1) ? seed() : POPu;
d2775 9
a2783 2
    EXTEND(SP, 1);
    RETPUSHYES;
d2788 2
a2789 1
    dVAR; dSP; dTARGET; tryAMAGICun(int);
d2791 2
a2792 2
      SV * const sv = sv_2num(TOPs);
      const IV iv = SvIV(sv);
d2803 1
a2803 1
	    SETu(SvUV(sv));
d2808 1
a2808 1
	  const NV value = SvNV(sv);
d2830 2
a2831 1
    dVAR; dSP; dTARGET; tryAMAGICun(abs);
d2833 1
a2833 1
      SV * const sv = sv_2num(TOPs);
d2835 1
a2835 1
      const IV iv = SvIV(sv);
d2843 1
a2843 1
	  SETu(SvUV(sv));	/* force it to be numeric only */
d2858 1
a2858 1
	const NV value = SvNV(sv);
d2895 1
a2895 1
    if (*tmps == 'x') {
d2899 1
a2899 1
    else if (*tmps == 'b')
d2932 5
a2936 2
	    sv_setsv(TARG, &PL_sv_undef);
	    SETTARG;
d2950 5
a2954 2
	sv_setsv_nomg(TARG, &PL_sv_undef);
	SETTARG;
d2959 67
a3034 2
    IV     pos2_iv;
    int    pos2_is_uv;
d3037 3
a3039 2
    int    len_is_uv = 1;
    const I32 lvalue = PL_op->op_flags & OPf_MOD || LVRET;
a3040 1
    const IV arybase = CopARYBASE_get(PL_curcop);
d3044 1
a3044 1
    const int num_args = PL_op->op_private & 7;
a3047 2
    SvTAINTED_off(TARG);			/* decontaminate */
    SvUTF8_off(TARG);				/* decontaminate */
d3050 7
a3056 7
	    repl_sv = POPs;
	    repl = SvPV_const(repl_sv, repl_len);
	    repl_is_utf8 = DO_UTF8(repl_sv) && SvCUR(repl_sv);
	}
	len_sv    = POPs;
	len_iv    = SvIV(len_sv);
	len_is_uv = SvIOK_UV(len_sv);
d3062 4
d3068 2
d3077 14
a3090 10
    tmps = SvPV_const(sv, curlen);
    if (DO_UTF8(sv)) {
        utf8_curlen = sv_len_utf8(sv);
	if (utf8_curlen == curlen)
	    utf8_curlen = 0;
	else
	    curlen = utf8_curlen;
    }
    else
	utf8_curlen = 0;
d3092 3
a3094 46
    if ( (pos1_is_uv && arybase < 0) || (pos1_iv >= arybase) ) { /* pos >= $[ */
	UV pos1_uv = pos1_iv-arybase;
	/* Overflow can occur when $[ < 0 */
	if (arybase < 0 && pos1_uv < (UV)pos1_iv)
	    goto bound_fail;
	pos1_iv = pos1_uv;
	pos1_is_uv = 1;
    }
    else if (pos1_is_uv ? (UV)pos1_iv > 0 : pos1_iv > 0) {
	goto bound_fail;  /* $[=3; substr($_,2,...) */
    }
    else { /* pos < $[ */
	if (pos1_iv == 0) { /* $[=1; substr($_,0,...) */
	    pos1_iv = curlen;
	    pos1_is_uv = 1;
	} else {
	    if (curlen) {
		pos1_is_uv = curlen-1 > ~(UV)pos1_iv;
		pos1_iv += curlen;
	   }
	}
    }
    if (pos1_is_uv || pos1_iv > 0) {
	if ((UV)pos1_iv > curlen)
	    goto bound_fail;
    }

    if (num_args > 2) {
	if (!len_is_uv && len_iv < 0) {
	    pos2_iv = curlen + len_iv;
	    if (curlen)
		pos2_is_uv = curlen-1 > ~(UV)len_iv;
	    else
		pos2_is_uv = 0;
	} else {  /* len_iv >= 0 */
	    if (!pos1_is_uv && pos1_iv < 0) {
		pos2_iv = pos1_iv + len_iv;
		pos2_is_uv = (UV)len_iv > (UV)IV_MAX;
	    } else {
		if ((UV)len_iv > curlen-(UV)pos1_iv)
		    pos2_iv = curlen;
		else
		    pos2_iv = pos1_iv+len_iv;
		pos2_is_uv = 1;
	    }
	}
d3096 7
a3102 3
    else {
	pos2_iv = curlen;
	pos2_is_uv = 1;
d3104 2
d3107 2
a3108 7
    if (!pos2_is_uv && pos2_iv < 0) {
	if (!pos1_is_uv && pos1_iv < 0)
	    goto bound_fail;
	pos2_iv = 0;
    }
    else if (!pos1_is_uv && pos1_iv < 0)
	pos1_iv = 0;
d3110 3
a3112 4
    if ((UV)pos2_iv < (UV)pos1_iv)
	pos2_iv = pos1_iv;
    if ((UV)pos2_iv > curlen)
	pos2_iv = curlen;
d3114 2
a3115 6
    {
	/* pos1_iv and pos2_iv both in 0..curlen, so the cast is safe */
	const STRLEN pos = (STRLEN)( (UV)pos1_iv );
	const STRLEN len = (STRLEN)( (UV)pos2_iv - (UV)pos1_iv );
	STRLEN byte_len = len;
	STRLEN byte_pos = utf8_curlen
a3118 12
	/* we either return a PV or an LV. If the TARG hasn't been used
	 * before, or is of that type, reuse it; otherwise use a mortal
	 * instead. Note that LVs can have an extended lifetime, so also
	 * dont reuse if refcount > 1 (bug #20933) */
	if (SvTYPE(TARG) > SVt_NULL) {
	    if ( (SvTYPE(TARG) == SVt_PVLV)
		    ? (!lvalue || SvREFCNT(TARG) > 1)
		    : lvalue)
	    {
		TARG = sv_newmortal();
	    }
	}
d3120 4
a3123 1
	sv_setpvn(TARG, tmps, byte_len);
d3125 1
a3125 1
	sv_unmagic(TARG, PERL_MAGIC_collxfrm);
d3127 4
a3130 2
	if (utf8_curlen)
	    SvUTF8_on(TARG);
d3138 1
a3138 1
		repl_is_utf8 = DO_UTF8(repl_sv_copy) && SvCUR(sv);
d3140 4
a3150 28
	else if (lvalue) {		/* it's an lvalue! */
	    if (!SvGMAGICAL(sv)) {
		if (SvROK(sv)) {
		    SvPV_force_nolen(sv);
		    Perl_ck_warner(aTHX_ packWARN(WARN_SUBSTR),
				   "Attempt to use reference as lvalue in substr");
		}
		if (isGV_with_GP(sv))
		    SvPV_force_nolen(sv);
		else if (SvOK(sv))	/* is it defined ? */
		    (void)SvPOK_only_UTF8(sv);
		else
		    sv_setpvs(sv, ""); /* avoid lexical reincarnation */
	    }

	    if (SvTYPE(TARG) < SVt_PVLV) {
		sv_upgrade(TARG, SVt_PVLV);
		sv_magic(TARG, NULL, PERL_MAGIC_substr, NULL, 0);
	    }

	    LvTYPE(TARG) = 'x';
	    if (LvTARG(TARG) != sv) {
		SvREFCNT_dec(LvTARG(TARG));
		LvTARG(TARG) = SvREFCNT_inc_simple(sv);
	    }
	    LvTARGOFF(TARG) = pos;
	    LvTARGLEN(TARG) = len;
	}
d3153 4
a3156 1
    PUSHs(TARG);		/* avoid SvSETMAGIC here */
d3160 1
a3160 1
    if (lvalue || repl)
d3168 1
a3168 1
    dVAR; dSP; dTARGET;
d3173 1
a3174 1
    SvTAINTED_off(TARG);		/* decontaminate */
d3176 11
a3186 13
	if (SvREFCNT(TARG) > 1)	/* don't share the TARG (#20933) */
	    TARG = sv_newmortal();
	if (SvTYPE(TARG) < SVt_PVLV) {
	    sv_upgrade(TARG, SVt_PVLV);
	    sv_magic(TARG, NULL, PERL_MAGIC_vec, NULL, 0);
	}
	LvTYPE(TARG) = 'v';
	if (LvTARG(TARG) != src) {
	    SvREFCNT_dec(LvTARG(TARG));
	    LvTARG(TARG) = SvREFCNT_inc_simple(src);
	}
	LvTARGOFF(TARG) = offset;
	LvTARGLEN(TARG) = size;
d3189 2
a3190 2
    sv_setuv(TARG, do_vecget(src, offset, size));
    PUSHs(TARG);
a3205 1
    const I32 arybase = CopARYBASE_get(PL_curcop);
d3209 1
d3211 2
a3212 5
    if (MAXARG >= 3) {
	/* arybase is in characters, like offset, so combine prior to the
	   UTF-8 to bytes calculation.  */
	offset = POPi - arybase;
    }
d3282 1
a3282 1
    if (MAXARG < 3)
d3307 1
a3307 1
    PUSHi(retval + arybase);
d3314 1
a3314 2
    if (SvTAINTED(MARK[1]))
	TAINT_PROPER("sprintf");
d3386 1
a3386 1
	    UNICODE_IS_REPLACEMENT(utf8_to_uvchr((U8*)tmps, NULL))) {
a3445 1
    return NORMAL;
a3451 7
/* Both the characters below can be stored in two UTF-8 bytes.  In UTF-8 the max
 * character that 2 bytes can hold is U+07FF, and in UTF-EBCDIC it is U+03FF.
 * See http://www.unicode.org/unicode/reports/tr16 */
#define LATIN_CAPITAL_LETTER_Y_WITH_DIAERESIS 0x0178	/* Also is title case */
#define GREEK_CAPITAL_LETTER_MU 0x039C	/* Upper and title case of MICRON */

/* Below are several macros that generate code */
d3453 2
a3454 9
 * exactly two UTF-8 and UTF-EBCDIC bytes; it is stored into p and p+1. */
#define STORE_UNI_TO_UTF8_TWO_BYTE(p, c)				    \
    STMT_START {							    \
	*(p) = UTF8_TWO_BYTE_HI(c);					    \
	*((p)+1) = UTF8_TWO_BYTE_LO(c);					    \
    } STMT_END

/* Like STORE_UNI_TO_UTF8_TWO_BYTE, but advances p to point to the next
 * available byte after the two bytes */
a3460 40
/* Generates code to store the upper case of latin1 character l which is known
 * to have its upper case be non-latin1 into the two bytes p and p+1.  There
 * are only two characters that fit this description, and this macro knows
 * about them, and that the upper case values fit into two UTF-8 or UTF-EBCDIC
 * bytes */
#define STORE_NON_LATIN1_UC(p, l)					    \
STMT_START {								    \
    if ((l) == LATIN_SMALL_LETTER_Y_WITH_DIAERESIS) {			    \
	STORE_UNI_TO_UTF8_TWO_BYTE((p), LATIN_CAPITAL_LETTER_Y_WITH_DIAERESIS);  \
    } else { /* Must be the following letter */								    \
	STORE_UNI_TO_UTF8_TWO_BYTE((p), GREEK_CAPITAL_LETTER_MU);	    \
    }									    \
} STMT_END

/* Like STORE_NON_LATIN1_UC, but advances p to point to the next available byte
 * after the character stored */
#define CAT_NON_LATIN1_UC(p, l)						    \
STMT_START {								    \
    if ((l) == LATIN_SMALL_LETTER_Y_WITH_DIAERESIS) {			    \
	CAT_UNI_TO_UTF8_TWO_BYTE((p), LATIN_CAPITAL_LETTER_Y_WITH_DIAERESIS);    \
    } else {								    \
	CAT_UNI_TO_UTF8_TWO_BYTE((p), GREEK_CAPITAL_LETTER_MU);		    \
    }									    \
} STMT_END

/* Generates code to add the two UTF-8 bytes (probably u) that are the upper
 * case of l into p and p+1.  u must be the result of toUPPER_LATIN1_MOD(l),
 * and must require two bytes to store it.  Advances p to point to the next
 * available position */
#define CAT_TWO_BYTE_UNI_UPPER_MOD(p, l, u)				    \
STMT_START {								    \
    if ((u) != LATIN_SMALL_LETTER_Y_WITH_DIAERESIS) {			    \
	CAT_UNI_TO_UTF8_TWO_BYTE((p), (u)); /* not special, just save it */ \
    } else if (l == LATIN_SMALL_LETTER_SHARP_S) {			    \
	*(p)++ = 'S'; *(p)++ = 'S'; /* upper case is 'SS' */		    \
    } else {/* else is one of the other two special cases */		    \
	CAT_NON_LATIN1_UC((p), (l));					    \
    }									    \
} STMT_END

d3486 1
d3509 1
d3513 8
a3520 78

/* TODO: This is #ifdefd out because it has hard-coded the standard mappings,
 * and doesn't allow for the user to specify their own.  When code is added to
 * detect if there is a user-defined mapping in force here, and if so to use
 * that, then the code below can be compiled.  The detection would be a good
 * thing anyway, as currently the user-defined mappings only work on utf8
 * strings, and thus depend on the chosen internal storage method, which is a
 * bad thing */
#ifdef GO_AHEAD_AND_BREAK_USER_DEFINED_CASE_MAPPINGS
	if (UTF8_IS_INVARIANT(*s)) {

	    /* An invariant source character is either ASCII or, in EBCDIC, an
	     * ASCII equivalent or a caseless C1 control.  In both these cases,
	     * the lower and upper cases of any character are also invariants
	     * (and title case is the same as upper case).  So it is safe to
	     * use the simple case change macros which avoid the overhead of
	     * the general functions.  Note that if perl were to be extended to
	     * do locale handling in UTF-8 strings, this wouldn't be true in,
	     * for example, Lithuanian or Turkic.  */
	    *tmpbuf = (op_type == OP_LCFIRST) ? toLOWER(*s) : toUPPER(*s);
	    tculen = ulen = 1;
	    need = slen + 1;
	}
	else if (UTF8_IS_DOWNGRADEABLE_START(*s)) {
	    U8 chr;

	    /* Similarly, if the source character isn't invariant but is in the
	     * latin1 range (or EBCDIC equivalent thereof), we have the case
	     * changes compiled into perl, and can avoid the overhead of the
	     * general functions.  In this range, the characters are stored as
	     * two UTF-8 bytes, and it so happens that any changed-case version
	     * is also two bytes (in both ASCIIish and EBCDIC machines). */
	    tculen = ulen = 2;
	    need = slen + 1;

	    /* Convert the two source bytes to a single Unicode code point
	     * value, change case and save for below */
	    chr = UTF8_ACCUMULATE(*s, *(s+1));
	    if (op_type == OP_LCFIRST) {    /* lower casing is easy */
		U8 lower = toLOWER_LATIN1(chr);
		STORE_UNI_TO_UTF8_TWO_BYTE(tmpbuf, lower);
	    }
	    else {	/* ucfirst */
		U8 upper = toUPPER_LATIN1_MOD(chr);

		/* Most of the latin1 range characters are well-behaved.  Their
		 * title and upper cases are the same, and are also in the
		 * latin1 range.  The macro above returns their upper (hence
		 * title) case, and all that need be done is to save the result
		 * for below.  However, several characters are problematic, and
		 * have to be handled specially.  The MOD in the macro name
		 * above means that these tricky characters all get mapped to
		 * the single character LATIN_SMALL_LETTER_Y_WITH_DIAERESIS.
		 * This mapping saves some tests for the majority of the
		 * characters */

		if (upper != LATIN_SMALL_LETTER_Y_WITH_DIAERESIS) {

		    /* Not tricky.  Just save it. */
		    STORE_UNI_TO_UTF8_TWO_BYTE(tmpbuf, upper);
		}
		else if (chr == LATIN_SMALL_LETTER_SHARP_S) {

		    /* This one is tricky because it is two characters long,
		     * though the UTF-8 is still two bytes, so the stored
		     * length doesn't change */
		    *tmpbuf = 'S';  /* The UTF-8 is 'Ss' */
		    *(tmpbuf + 1) = 's';
		}
		else {

		    /* The other two have their title and upper cases the same,
		     * but are tricky because the changed-case characters
		     * aren't in the latin1 range.  They, however, do fit into
		     * two UTF-8 bytes */
		    STORE_NON_LATIN1_UC(tmpbuf, chr);    
		}
	    }
a3521 4
	else {
#endif	/* end of dont want to break user-defined casing */

	    /* Here, can't short-cut the general case */
d3523 3
a3525 10
	    utf8_to_uvchr(s, &ulen);
	    if (op_type == OP_UCFIRST) toTITLE_utf8(s, tmpbuf, &tculen);
	    else toLOWER_utf8(s, tmpbuf, &tculen);

	    /* we can't do in-place if the length changes.  */
	    if (ulen != tculen) inplace = FALSE;
	    need = slen + 1 - ulen + tculen;
#ifdef GO_AHEAD_AND_BREAK_USER_DEFINED_CASE_MAPPINGS
	}
#endif
d3530 1
d3553 9
a3561 19
	    *tmpbuf = toUPPER_LATIN1_MOD(*s);

	    /* tmpbuf now has the correct title case for all latin1 characters
	     * except for the several ones that have tricky handling.  All
	     * of these are mapped by the MOD to the letter below. */
	    if (*tmpbuf == LATIN_SMALL_LETTER_Y_WITH_DIAERESIS) {

		/* The length is going to change, with all three of these, so
		 * can't replace just the first character */
		inplace = FALSE;

		/* We use the original to distinguish between these tricky
		 * cases */
		if (*s == LATIN_SMALL_LETTER_SHARP_S) {
		    /* Two character title case 'Ss', but can remain non-UTF-8 */
		    need = slen + 2;
		    *tmpbuf = 'S';
		    *(tmpbuf + 1) = 's';   /* Assert: length(tmpbuf) >= 2 */
		    tculen = 2;
d3564 23
a3586 15

		    /* The other two tricky ones have their title case outside
		     * latin1.  It is the same as their upper case. */
		    doing_utf8 = TRUE;
		    STORE_NON_LATIN1_UC(tmpbuf, *s);

		    /* The UTF-8 and UTF-EBCDIC lengths of both these characters
		     * and their upper cases is 2. */
		    tculen = ulen = 2;

		    /* The entire result will have to be in UTF-8.  Assume worst
		     * case sizing in conversion. (all latin1 characters occupy
		     * at most two bytes in utf8) */
		    convert_source_to_utf8 = TRUE;
		    need = slen * 2 + 1;
d3588 1
a3588 1
	    } /* End of is one of the three special chars */
d3653 5
d3763 1
d3765 10
a3774 7
/* This is ifdefd out because it needs more work and thought.  It isn't clear
 * that we should do it.  These are hard-coded rules from the Unicode standard,
 * and may change.  5.2 gives new guidance on the iota subscript, for example,
 * which has not been checked against this; and secondly it may be that we are
 * passed a subset of the context, via a \U...\E, for example, and its not
 * clear what the best approach is to that */
#ifdef CONTEXT_DEPENDENT_CASING
a3775 1
#endif
d3778 3
a3780 1
#ifdef CONTEXT_DEPENDENT_CASING
d3782 1
d3789 1
a3789 2
	    }
#endif
d3791 2
d3794 29
a3822 58
/* See comments at the first instance in this file of this ifdef */
#ifdef GO_AHEAD_AND_BREAK_USER_DEFINED_CASE_MAPPINGS

	    /* If the UTF-8 character is invariant, then it is in the range
	     * known by the standard macro; result is only one byte long */
	    if (UTF8_IS_INVARIANT(*s)) {
		*d++ = toUPPER(*s);
		s++;
	    }
	    else if (UTF8_IS_DOWNGRADEABLE_START(*s)) {

		/* Likewise, if it fits in a byte, its case change is in our
		 * table */
		U8 orig = UTF8_ACCUMULATE(*s, *(s+1));
		U8 upper = toUPPER_LATIN1_MOD(orig);
		CAT_TWO_BYTE_UNI_UPPER_MOD(d, orig, upper);
		s += 2;
	    }
	    else {
#else
	    {
#endif

		/* Otherwise, need the general UTF-8 case.  Get the changed
		 * case value and copy it to the output buffer */

		const STRLEN u = UTF8SKIP(s);
		STRLEN ulen;

#ifndef CONTEXT_DEPENDENT_CASING
		toUPPER_utf8(s, tmpbuf, &ulen);
#else
		const UV uv = toUPPER_utf8(s, tmpbuf, &ulen);
		if (uv == GREEK_CAPITAL_LETTER_IOTA && utf8_to_uvchr(s, 0) == COMBINING_GREEK_YPOGEGRAMMENI) {
		    in_iota_subscript = TRUE;
		}
		else {
#endif
		    if (ulen > u && (SvLEN(dest) < (min += ulen - u))) {
			/* If the eventually required minimum size outgrows
			 * the available space, we need to grow. */
			const UV o = d - (U8*)SvPVX_const(dest);

			/* If someone uppercases one million U+03B0s we
			 * SvGROW() one million times.  Or we could try
			 * guessing how much to allocate without allocating too
			 * much.  Such is life.  See corresponding comment in lc code
			 * for another option */
			SvGROW(dest, min);
			d = (U8*)SvPVX(dest) + o;
		    }
		    Copy(tmpbuf, d, ulen, U8);
		    d += ulen;
#ifdef CONTEXT_DEPENDENT_CASING
		}
#endif
		s += u;
	    }
a3823 3
#ifdef CONTEXT_DEPENDENT_CASING
	if (in_iota_subscript) CAT_UNI_TO_UTF8_TWO_BYTE(d, GREEK_CAPITAL_LETTER_IOTA);
#endif
d3826 1
d3828 6
a3833 1
    } else {	/* Not UTF-8 */
d3854 1
a3854 1
		    if (*d != LATIN_SMALL_LETTER_Y_WITH_DIAERESIS) continue;
a3914 3
		    /* And append the current character's upper case in UTF-8 */
		    CAT_NON_LATIN1_UC(d, *s);

a3918 2

		    s++;
d3920 2
a3921 7
			U8 upper = toUPPER_LATIN1_MOD(*s);
			if UTF8_IS_INVARIANT(upper) {
			    *d++ = upper;
			}
			else {
			    CAT_TWO_BYTE_UNI_UPPER_MOD(d, *s, upper);
			}
d4000 1
d4003 2
a4004 10
/* See comments at the first instance in this file of this ifdef */
#ifdef GO_AHEAD_AND_BREAK_USER_DEFINED_CASE_MAPPINGS
	    if (UTF8_IS_INVARIANT(*s)) {

		/* Invariant characters use the standard mappings compiled in.
		 */
		*d++ = toLOWER(*s);
		s++;
	    }
	    else if (UTF8_IS_DOWNGRADEABLE_START(*s)) {
d4006 2
a4007 47
		/* As do the ones in the Latin1 range */
		U8 lower = toLOWER_LATIN1(UTF8_ACCUMULATE(*s, *(s+1)));
		CAT_UNI_TO_UTF8_TWO_BYTE(d, lower);
		s += 2;
	    }
	    else {
#endif
		/* Here, is utf8 not in Latin-1 range, have to go out and get
		 * the mappings from the tables. */

		const STRLEN u = UTF8SKIP(s);
		STRLEN ulen;

/* See comments at the first instance in this file of this ifdef */
#ifndef CONTEXT_DEPENDENT_CASING
		toLOWER_utf8(s, tmpbuf, &ulen);
#else
		/* Here is context dependent casing, not compiled in currently;
		 * needs more thought and work */

		const UV uv = toLOWER_utf8(s, tmpbuf, &ulen);

		/* If the lower case is a small sigma, it may be that we need
		 * to change it to a final sigma.  This happens at the end of 
		 * a word that contains more than just this character, and only
		 * when we started with a capital sigma. */
		if (uv == UNICODE_GREEK_SMALL_LETTER_SIGMA &&
		    s > send - len &&	/* Makes sure not the first letter */
		    utf8_to_uvchr(s, 0) == UNICODE_GREEK_CAPITAL_LETTER_SIGMA
		) {

		    /* We use the algorithm in:
		     * http://www.unicode.org/versions/Unicode5.0.0/ch03.pdf (C
		     * is a CAPITAL SIGMA): If C is preceded by a sequence
		     * consisting of a cased letter and a case-ignorable
		     * sequence, and C is not followed by a sequence consisting
		     * of a case ignorable sequence and then a cased letter,
		     * then when lowercasing C, C becomes a final sigma */

		    /* To determine if this is the end of a word, need to peek
		     * ahead.  Look at the next character */
		    const U8 *peek = s + u;

		    /* Skip any case ignorable characters */
		    while (peek < send && is_utf8_case_ignorable(peek)) {
			peek += UTF8SKIP(peek);
		    }
d4009 2
a4010 16
		    /* If we reached the end of the string without finding any
		     * non-case ignorable characters, or if the next such one
		     * is not-cased, then we have met the conditions for it
		     * being a final sigma with regards to peek ahead, and so
		     * must do peek behind for the remaining conditions. (We
		     * know there is stuff behind to look at since we tested
		     * above that this isn't the first letter) */
		    if (peek >= send || ! is_utf8_cased(peek)) {
			peek = utf8_hop(s, -1);

			/* Here are at the beginning of the first character
			 * before the original upper case sigma.  Keep backing
			 * up, skipping any case ignorable characters */
			while (is_utf8_case_ignorable(peek)) {
			    peek = utf8_hop(peek, -1);
			}
d4012 21
a4032 40
			/* Here peek points to the first byte of the closest
			 * non-case-ignorable character before the capital
			 * sigma.  If it is cased, then by the Unicode
			 * algorithm, we should use a small final sigma instead
			 * of what we have */
			if (is_utf8_cased(peek)) {
			    STORE_UNI_TO_UTF8_TWO_BYTE(tmpbuf,
					UNICODE_GREEK_SMALL_LETTER_FINAL_SIGMA);
			}
		    }
		}
		else {	/* Not a context sensitive mapping */
#endif	/* End of commented out context sensitive */
		    if (ulen > u && (SvLEN(dest) < (min += ulen - u))) {

			/* If the eventually required minimum size outgrows
			 * the available space, we need to grow. */
			const UV o = d - (U8*)SvPVX_const(dest);

			/* If someone lowercases one million U+0130s we
			 * SvGROW() one million times.  Or we could try
			 * guessing how much to allocate without allocating too
			 * much.  Such is life.  Another option would be to
			 * grow an extra byte or two more each time we need to
			 * grow, which would cut down the million to 500K, with
			 * little waste */
			SvGROW(dest, min);
			d = (U8*)SvPVX(dest) + o;
		    }
#ifdef CONTEXT_DEPENDENT_CASING
		}
#endif
		/* Copy the newly lowercased letter to the output buffer we're
		 * building */
		Copy(tmpbuf, d, ulen, U8);
		d += ulen;
		s += u;
#ifdef GO_AHEAD_AND_BREAK_USER_DEFINED_CASE_MAPPINGS
	    }
#endif
d4037 4
d4091 24
a4114 7
		if (UTF8_IS_CONTINUED(*s)) {
		    STRLEN ulen = UTF8SKIP(s);
		    if (ulen > len)
			ulen = len;
		    len -= ulen;
		    while (ulen--)
			*d++ = *s++;
d4116 4
a4119 3
		else {
		    if (!isALNUM(*s))
			*d++ = '\\';
a4120 2
		    len--;
		}
d4124 7
d4132 2
d4135 1
a4135 1
		if (!isALNUM(*s))
d4150 153
a4311 1
	const I32 arybase = CopARYBASE_get(PL_curcop);
a4338 2
	    if (elem > 0)
		elem -= arybase;
d4369 37
d4424 1
a4424 1
    mPUSHi(CopARYBASE_get(PL_curcop) + current);
d4447 1
a4447 1
        IV i = CopARYBASE_get(PL_curcop);
d4451 2
a4452 3
	if (PL_op->op_type == OP_AKEYS) {
	    n += i;
	    for (;  i <= n;  i++) {
d4812 1
a4812 1
            if (!svp || *svp == &PL_sv_undef) {
d4825 1
a4825 1
        *MARK = svp ? *svp : &PL_sv_undef;
a4857 1
    const I32 arybase = CopARYBASE_get(PL_curcop);
a4866 2
	else
	    ix -= arybase;
a4883 2
	else
	    ix -= arybase;
d4930 30
d4963 2
a4964 1
    register AV *ary = MUTABLE_AV(*++MARK);
d4976 3
a4978 8
	*MARK-- = SvTIED_obj(MUTABLE_SV(ary), mg);
	PUSHMARK(MARK);
	PUTBACK;
	ENTER_with_name("call_SPLICE");
	call_method("SPLICE",GIMME_V);
	LEAVE_with_name("call_SPLICE");
	SPAGAIN;
	RETURN;
a4986 2
	else
	    offset -= CopARYBASE_get(PL_curcop);
d5005 2
a5006 1
	Perl_ck_warner(aTHX_ packWARN(WARN_MISC), "splice() offset past end of array" );
d5044 1
a5044 1
		    sv_2mortal(*dst);	/* free them eventualy */
d5136 1
a5136 1
			sv_2mortal(*dst);	/* free them eventualy */
d5155 4
d5166 1
a5166 1
    register AV * const ary = MUTABLE_AV(*++MARK);
d5186 1
a5186 1
	if (PL_delaymagic & DM_ARRAY)
d5202 2
a5203 1
    AV * const av = MUTABLE_AV(POPs);
d5216 1
a5216 1
    register AV *ary = MUTABLE_AV(*++MARK);
a5325 1
	PADOFFSET padoff_du;
d5331 1
a5331 7
	    sv_setsv(TARG, (SP > MARK)
		    ? *SP
		    : (padoff_du = find_rundefsvoffset(),
			(padoff_du == NOT_IN_PAD
			 || PAD_COMPNAME_FLAGS_isOUR(padoff_du))
			? DEFSV : PAD_SVl(padoff_du)));

d5347 1
a5347 1
			if (!utf8_to_uvchr(s, 0))
d5411 1
a5411 1
	DIE(aTHX_ "panic: pp_split");
d5414 1
a5414 1
    TAINT_IF((RX_EXTFLAGS(rx) & RXf_PMf_LOCALE) &&
d5460 1
a5460 1
	else if (RX_EXTFLAGS(rx) & RXf_PMf_LOCALE) {
d5469 1
a5469 1
    if (RX_EXTFLAGS(rx) & PMf_MULTILINE) {
d5490 2
a5491 1
            } else if (RX_EXTFLAGS(rx) & RXf_PMf_LOCALE) {
d5523 2
a5524 1
            } else if (RX_EXTFLAGS(rx) & RXf_PMf_LOCALE) {
d5679 1
a5679 1
			    sv, NULL, 0);
a5827 1
    assert(SvTYPE(retsv) != SVt_PVCV);
d5829 2
a5830 1
    if (SvTYPE(retsv) == SVt_PVAV || SvTYPE(retsv) == SVt_PVHV) {
d5841 14
a5854 3
    DIE(aTHX_ "panic: unimplemented op %s (#%d) called", OP_NAME(PL_op),
	PL_op->op_type);
    return NORMAL;
d5863 2
d5873 141
a6013 1
    XPUSHs(boolSV(HvKEYS(hv) != 0));
d6016 19
@


1.14
log
@merge in perl 5.12.2 plus local changes
@
text
@d3952 2
d4227 2
d4440 2
@


1.14.2.1
log
@Perl security fix for CVE-2011-1487.
ok sthen@@ jasper@@
@
text
@a3951 2
    if (dest != source && SvTAINTED(source))
	SvTAINT(dest);
a4224 2
    if (dest != source && SvTAINTED(source))
	SvTAINT(dest);
a4435 2
    if (dest != source && SvTAINTED(source))
	SvTAINT(dest);
@


1.13
log
@Merge in perl 5.10.1
@
text
@d66 1
d110 1
d135 3
d210 1
a210 1
		    DIE(aTHX_ PL_no_symref_sv, sv, "a symbol");
d230 2
a231 2
Perl_softref2xv(pTHX_ SV *const sv, const char *const what, const U32 type,
		SV ***spp)
d240 1
a240 1
	    Perl_die(aTHX_ PL_no_symref_sv, sv, what);
d329 12
a340 4
    SV ** const sv = Perl_av_arylen_p(aTHX_ MUTABLE_AV(av));
    if (!*sv) {
	*sv = newSV_type(SVt_PVMG);
	sv_magic(*sv, MUTABLE_SV(av), PERL_MAGIC_arylen, NULL, 0);
a341 1
    SETs(*sv);
d357 1
a357 2
	    if (LvTARG(TARG))
		SvREFCNT_dec(LvTARG(TARG));
d436 4
d556 1
a556 1
    sv_upgrade(rv, SVt_RV);
d594 3
a596 3
	if (len == 0 && ckWARN(WARN_MISC))
	    Perl_warner(aTHX_ packWARN(WARN_MISC),
		   "Explicit blessing to '' (assuming package main)");
d831 4
a834 4
	if (cv_const_sv((CV*)sv) && ckWARN(WARN_MISC))
	    Perl_warner(aTHX_ packWARN(WARN_MISC), "Constant subroutine %s undefined",
		 CvANON((const CV *)sv) ? "(anonymous)"
			: GvENAME(CvGV((const CV *)sv)));
d3048 5
a3052 4
    if (SvAMAGIC(sv)) {
	/* For an overloaded scalar, we can't know in advance if it's going to
	   be UTF-8 or not. Also, we can't call sv_len_utf8 as it likes to
	   cache the length. Maybe that should be a documented feature of it.
d3055 3
a3057 1
	const char *const p = SvPV_const(sv, len);
d3059 5
a3063 1
	if (DO_UTF8(sv)) {
d3068 9
a3076 1

a3077 4
    else if (DO_UTF8(sv))
	SETi(sv_len_utf8(sv));
    else
	SETi(sv_len(sv));
a3084 1
    I32 len = 0;
d3087 8
a3094 3
    I32 pos;
    I32 rem;
    I32 fail;
d3097 1
a3097 1
    const I32 arybase = CopARYBASE_get(PL_curcop);
d3113 7
a3119 3
	len = POPi;
    }
    pos = POPi;
d3141 44
a3184 9
    if (pos >= arybase) {
	pos -= arybase;
	rem = curlen-pos;
	fail = rem;
	if (num_args > 2) {
	    if (len < 0) {
		rem += len;
		if (rem < 0)
		    rem = 0;
a3185 2
	    else if (rem > len)
		     rem = len;
d3189 2
a3190 24
	pos += curlen;
	if (num_args < 3)
	    rem = curlen;
	else if (len >= 0) {
	    rem = pos+len;
	    if (rem > (I32)curlen)
		rem = curlen;
	}
	else {
	    rem = curlen+len;
	    if (rem < pos)
		rem = pos;
	}
	if (pos < 0)
	    pos = 0;
	fail = rem;
	rem -= pos;
    }
    if (fail < 0) {
	if (lvalue || repl)
	    Perl_croak(aTHX_ "substr outside of string");
	if (ckWARN(WARN_SUBSTR))
	    Perl_warner(aTHX_ packWARN(WARN_SUBSTR), "substr outside of string");
	RETPUSHUNDEF;
d3192 23
a3214 6
    else {
	const I32 upos = pos;
	const I32 urem = rem;
	if (utf8_curlen)
	    sv_pos_u2b(sv, &pos, &rem);
	tmps += pos;
d3228 1
a3228 1
	sv_setpvn(TARG, tmps, rem);
d3245 1
a3245 1
	    sv_insert_flags(sv, pos, rem, repl, repl_len, 0);
d3248 1
a3248 2
	    if (repl_sv_copy)
		SvREFCNT_dec(repl_sv_copy);
d3254 2
a3255 3
		    if (ckWARN(WARN_SUBSTR))
			Perl_warner(aTHX_ packWARN(WARN_SUBSTR),
				"Attempt to use reference as lvalue in substr");
d3272 1
a3272 2
		if (LvTARG(TARG))
		    SvREFCNT_dec(LvTARG(TARG));
d3275 2
a3276 2
	    LvTARGOFF(TARG) = upos;
	    LvTARGLEN(TARG) = urem;
d3282 6
d3308 1
a3308 2
	    if (LvTARG(TARG))
		SvREFCNT_dec(LvTARG(TARG));
d3434 1
a3434 2
    if (temp)
	SvREFCNT_dec(temp);
d3576 1
d3580 66
d3648 5
d3656 1
a3656 1
    STRLEN slen;
d3659 3
a3661 2
    bool inplace = TRUE;
    bool doing_utf8;
d3666 5
a3670 2
    STRLEN ulen;
    STRLEN tculen;
d3676 2
d3682 13
a3694 1
    if (slen && DO_UTF8(source) && UTF8_IS_START(*s)) {
d3696 92
a3787 5
	utf8_to_uvchr(s, &ulen);
	if (op_type == OP_UCFIRST) {
	    toTITLE_utf8(s, tmpbuf, &tculen);
	} else {
	    toLOWER_utf8(s, tmpbuf, &tculen);
d3789 7
a3795 5
	/* If the two differ, we definately cannot do inplace.  */
	inplace = (ulen == tculen);
	need = slen + 1 - ulen + tculen;
    } else {
	doing_utf8 = FALSE;
a3796 1
    }
d3798 62
a3859 2
    if (SvPADTMP(source) && !SvREADONLY(source) && inplace && SvTEMP(source)) {
	/* We can convert in place.  */
d3861 2
d3870 2
a3876 2

	inplace = FALSE;
d3880 32
a3911 11
	if(!inplace) {
	    /* slen is the byte length of the whole SV.
	     * ulen is the byte length of the original Unicode character
	     * stored as UTF-8 at s.
	     * tculen is the byte length of the freshly titlecased (or
	     * lowercased) Unicode character stored as UTF-8 at tmpbuf.
	     * We first set the result to be the titlecased (/lowercased)
	     * character, and then append the rest of the SV data. */
	    sv_setpvn(dest, (char*)tmpbuf, tculen);
	    if (slen > ulen)
	        sv_catpvn(dest, (char*)(s + ulen), slen - ulen);
d3914 1
a3914 1
	else {
d3919 2
a3920 2
    else {
	if (*s) {
a3923 2
		*d = (op_type == OP_UCFIRST)
		    ? toUPPER_LC(*s) : toLOWER_LC(*s);
d3925 13
a3937 4
	    else
		*d = (op_type == OP_UCFIRST) ? toUPPER(*s) : toLOWER(*s);
	} else {
	    /* See bug #39028  */
d3941 2
d3946 1
a3946 1
	if (!inplace) {
d3958 1
a3958 1
   of the three tight loops.  */
d3973 2
a3974 2
	&& SvTEMP(source) && !DO_UTF8(source)) {
	/* We can convert in place.  */
d3976 7
d4001 2
d4022 10
d4033 40
a4072 2
	    const STRLEN u = UTF8SKIP(s);
	    STRLEN ulen;
d4074 29
a4102 15
	    toUPPER_utf8(s, tmpbuf, &ulen);
	    if (ulen > u && (SvLEN(dest) < (min += ulen - u))) {
		/* If the eventually required minimum size outgrows
		 * the available space, we need to grow. */
		const UV o = d - (U8*)SvPVX_const(dest);

		/* If someone uppercases one million U+03B0s we SvGROW() one
		 * million times.  Or we could try guessing how much to
		 allocate without allocating too much.  Such is life. */
		SvGROW(dest, min);
		d = (U8*)SvPVX(dest) + o;
	    }
	    Copy(tmpbuf, d, ulen, U8);
	    d += ulen;
	    s += u;
d4104 3
d4110 1
a4110 1
    } else {
d4113 4
d4123 2
a4124 2
	    else {
		for (; s < send; d++, s++)
d4126 1
d4128 92
a4219 1
	}
d4221 1
a4221 1
	    *d = '\0';
d4224 1
a4224 1
    }
a4243 1
	/* We can convert in place.  */
d4245 2
d4265 2
d4287 3
a4289 3
	    const STRLEN u = UTF8SKIP(s);
	    STRLEN ulen;
	    const UV uv = toLOWER_utf8(s, tmpbuf, &ulen);
d4291 1
a4291 14
#define GREEK_CAPITAL_LETTER_SIGMA 0x03A3 /* Unicode U+03A3 */
	    if (uv == GREEK_CAPITAL_LETTER_SIGMA) {
		NOOP;
		/*
		 * Now if the sigma is NOT followed by
		 * /$ignorable_sequence$cased_letter/;
		 * and it IS preceded by /$cased_letter$ignorable_sequence/;
		 * where $ignorable_sequence is [\x{2010}\x{AD}\p{Mn}]*
		 * and $cased_letter is [\p{Ll}\p{Lo}\p{Lt}]
		 * then it should be mapped to 0x03C2,
		 * (GREEK SMALL LETTER FINAL SIGMA),
		 * instead of staying 0x03A3.
		 * "should be": in other words, this is not implemented yet.
		 * See lib/unicore/SpecialCasing.txt.
d4293 2
d4296 108
a4403 15
	    if (ulen > u && (SvLEN(dest) < (min += ulen - u))) {
		/* If the eventually required minimum size outgrows
		 * the available space, we need to grow. */
		const UV o = d - (U8*)SvPVX_const(dest);

		/* If someone lowercases one million U+0130s we SvGROW() one
		 * million times.  Or we could try guessing how much to
		 allocate without allocating too much.  Such is life. */
		SvGROW(dest, min);
		d = (U8*)SvPVX(dest) + o;
	    }
	    Copy(tmpbuf, d, ulen, U8);
	    d += ulen;
	    s += u;
	}
d4407 1
a4407 1
    } else {
d4410 4
d4420 5
d4426 3
a4428 2
		for (; s < send; d++, s++)
		    *d = toLOWER(*s);
d4499 11
a4509 1
	if (lval && PL_op->op_private & OPpLVAL_INTRO) {
d4520 1
d4524 1
d4528 8
d4540 6
a4545 2
		if (PL_op->op_private & OPpLVAL_INTRO)
		    save_aelem(av, elem, svp);
d4558 61
d4653 177
d4834 8
a4841 2
    const I32 gimme = GIMME_V;
    const I32 discard = (gimme == G_VOID) ? G_DISCARD : 0;
d4877 1
a4877 1
	SV *sv;
d4937 1
a4937 1
    bool other_magic = FALSE;
d4943 2
a4944 8
        other_magic = mg_find((const SV *)hv, PERL_MAGIC_env) ||
            ((mg = mg_find((const SV *)hv, PERL_MAGIC_tied))
             /* Try to preserve the existenceness of a tied hash
              * element by using EXISTS and DELETE if possible.
              * Fallback to FETCH and STORE otherwise */
             && (stash = SvSTASH(SvRV(SvTIED_obj(MUTABLE_SV(hv), mg))))
             && gv_fetchmethod_autoload(stash, "EXISTS", TRUE)
             && gv_fetchmethod_autoload(stash, "DELETE", TRUE));
d4951 1
a4951 1
        bool preeminent = FALSE;
d4953 6
a4958 3
        if (localizing) {
            preeminent = SvRMAGICAL(hv) && !other_magic ? 1 :
                hv_exists_ent(hv, keysv, 0);
d4971 5
a4975 10
		else {
		    if (preeminent)
			save_helem(hv, keysv, svp);
		    else {
			STRLEN keylen;
			const char * const key = SvPV_const(keysv, keylen);
			SAVEDELETE(hv, savepvn(key,keylen),
				   SvUTF8(keysv) ? -(I32)keylen : (I32)keylen);
		    }
		}
d5078 2
a5079 2
	else if (ckWARN(WARN_MISC))
	    Perl_warner(aTHX_ packWARN(WARN_MISC), "Odd number of elements in anonymous hash");
d5106 1
a5106 1
	ENTER;
d5108 1
a5108 1
	LEAVE;
d5139 1
a5139 2
	if (ckWARN(WARN_MISC))
	    Perl_warner(aTHX_ packWARN(WARN_MISC), "splice() offset past end of array" );
d5302 1
a5302 1
	ENTER;
d5304 1
a5304 1
	LEAVE;
a5305 2
	SP = ORIGMARK;
	PUSHi( AvFILL(ary) + 1 );
d5319 4
a5322 2
	SP = ORIGMARK;
	PUSHi( AvFILLp(ary) + 1 );
d5351 1
a5351 1
	ENTER;
d5353 1
a5353 1
	LEAVE;
d5365 3
a5367 1
    PUSHi( AvFILL(ary) + 1 );
a5373 1
    SV ** const oldsp = SP;
d5376 70
a5445 5
	MARK++;
	while (MARK < SP) {
	    register SV * const tmp = *MARK;
	    *MARK++ = *SP;
	    *SP-- = tmp;
a5446 2
	/* safe as long as stack cannot get extended in the above */
	SP = oldsp;
d5459 1
a5459 1
	else
d5466 5
d5528 1
d5534 1
a5562 2
    else if (gimme != G_ARRAY)
	ary = GvAVn(PL_defgv);
d5608 2
d5635 11
a5645 3
	    dstr = newSVpvn_flags(s, m-s,
				  (do_utf8 ? SVf_UTF8 : 0) | make_mortal);
	    XPUSHs(dstr);
d5673 12
a5684 3
	    dstr = newSVpvn_flags(s, m-s,
				  (do_utf8 ? SVf_UTF8 : 0) | make_mortal);
	    XPUSHs(dstr);
d5697 7
a5703 5
        const U32 items = limit - 1; 
        if (items < slen)
            EXTEND(SP, items);
        else
            EXTEND(SP, slen);
d5710 8
a5717 1
                dstr = newSVpvn_flags(m, s-m, SVf_UTF8 | make_mortal);
d5719 2
a5720 1
                PUSHs(dstr);
d5727 4
a5730 1
                dstr = newSVpvn(s, 1);
a5731 1
                s++;
d5733 5
a5737 2
                if (make_mortal)
                    sv_2mortal(dstr);
d5739 1
a5739 1
                PUSHs(dstr);
d5761 11
a5771 3
		dstr = newSVpvn_flags(s, m-s,
				      (do_utf8 ? SVf_UTF8 : 0) | make_mortal);
		XPUSHs(dstr);
d5785 11
a5795 3
		dstr = newSVpvn_flags(s, m-s,
				      (do_utf8 ? SVf_UTF8 : 0) | make_mortal);
		XPUSHs(dstr);
d5825 12
a5836 3
	    dstr = newSVpvn_flags(s, m-s,
				  (do_utf8 ? SVf_UTF8 : 0) | make_mortal);
	    XPUSHs(dstr);
d5846 15
a5860 4
		    if (m >= orig && s >= orig) {
			dstr = newSVpvn_flags(s, m-s,
					     (do_utf8 ? SVf_UTF8 : 0)
					      | make_mortal);
d5862 1
a5862 3
		    else
			dstr = &PL_sv_undef;  /* undef, not "" */
		    XPUSHs(dstr);
d5869 3
a5871 1
    iters = (SP - PL_stack_base) - base;
d5877 5
a5881 3
        const STRLEN l = strend - s;
	dstr = newSVpvn_flags(s, l, (do_utf8 ? SVf_UTF8 : 0) | make_mortal);
	XPUSHs(dstr);
d5885 9
a5893 5
	while (iters > 0 && (!TOPs || !SvANY(TOPs) || SvCUR(TOPs) == 0)) {
	    if (TOPs && !make_mortal)
		sv_2mortal(TOPs);
	    iters--;
	    *SP-- = &PL_sv_undef;
d5916 1
a5916 1
	    ENTER;
d5918 1
a5918 1
	    LEAVE;
d5961 1
d5963 1
a5963 2
    if (SvTYPE(retsv) == SVt_PVAV || SvTYPE(retsv) == SVt_PVHV
	|| SvTYPE(retsv) == SVt_PVCV) {
d5976 19
@


1.13.4.1
log
@Perl security fix for CVE-2011-1487.
ok sthen@@ jasper@@
@
text
@a3618 2
    if (dest != source && SvTAINTED(source))
	SvTAINT(dest);
a3721 2
    if (dest != source && SvTAINTED(source))
	SvTAINT(dest);
a3837 2
    if (dest != source && SvTAINTED(source))
	SvTAINT(dest);
@


1.12
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d3 2
a4 2
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007 by Larry Wall and others
d12 5
a16 2
 * "It's a big house this, and very peculiar.  Always a bit more to discover,
 * and no knowing what you'll find around a corner.  And Elves, sir!" --Samwise
d81 1
a81 1
	const I32 maxarg = AvFILL((AV*)TARG) + 1;
d86 1
a86 1
		SV * const * const svp = av_fetch((AV*)TARG, i, FALSE);
d91 1
a91 1
	    Copy(AvARRAY((AV*)TARG), SP+1, maxarg, SV*);
d97 1
a97 1
	const I32 maxarg = AvFILL((AV*)TARG) + 1;
d125 1
a125 1
	SV* const sv = Perl_hv_scalar(aTHX_ (HV*)TARG);
d143 1
a143 1
	    GV * const gv = (GV*) sv_newmortal();
d145 1
a145 1
	    GvIOp(gv) = (IO *)sv;
d147 1
a147 1
	    sv = (SV*) gv;
d149 1
a149 1
	else if (SvTYPE(sv) != SVt_PVGV)
d153 1
a153 1
	if (SvTYPE(sv) != SVt_PVGV) {
d164 1
a164 1
		    Perl_croak(aTHX_ PL_no_modify);
d171 1
a171 1
			gv = (GV*)newSV(0);
d178 2
a179 8
		    if (SvTYPE(sv) < SVt_RV)
			sv_upgrade(sv, SVt_RV);
		    else if (SvPVX_const(sv)) {
			SvPV_free(sv);
			SvLEN_set(sv, 0);
                        SvCUR_set(sv, 0);
		    }
		    SvRV_set(sv, (SV*)gv);
d194 1
a194 1
		SV * const temp = (SV*)gv_fetchsv(sv, 0, SVt_PVGV);
d197 2
a198 1
			|| !(sv = (SV*)gv_fetchsv(sv, GV_ADD, SVt_PVGV)))) {
d213 1
a213 1
		sv = (SV*)gv_fetchsv(sv, GV_ADD, SVt_PVGV);
d218 1
a218 1
	save_gp((GV*)sv, !(PL_op->op_flags & OPf_SPECIAL));
d231 2
d290 1
a290 1
	gv = (GV*)sv;
d292 1
a292 1
	if (SvTYPE(gv) != SVt_PVGV) {
d307 1
a307 1
		sv = save_scalar((GV*)TOPs);
d311 1
a311 1
		Perl_croak(aTHX_ PL_no_localize_ref);
d323 2
a324 2
    AV * const av = (AV*)TOPs;
    SV ** const sv = Perl_av_arylen_p(aTHX_ (AV*)av);
d327 1
a327 1
	sv_magic(*sv, (SV*)av, PERL_MAGIC_arylen, NULL, 0);
d383 1
a383 1
	    cv = (CV*)sv_2mortal((SV*)cv_clone(cv));
d392 1
a392 1
	cv = (CV*)gv;
d395 2
a396 2
	cv = (CV*)&PL_sv_undef;
    SETs((SV*)cv);
d422 1
a422 1
		    ret = sv_2mortal(newSVpvs("_;$"));
d458 1
a458 1
		ret = sv_2mortal(newSVpvn(str, n - 1));
d470 1
a470 1
	ret = sv_2mortal(newSVpvn(SvPVX_const(cv), SvCUR(cv)));
d479 1
a479 1
    CV* cv = (CV*)PAD_SV(PL_op->op_targ);
d481 1
a481 1
	cv = (CV*)sv_2mortal((SV*)cv_clone(cv));
d483 1
a483 1
    PUSHs((SV*)cv);
d518 2
d529 2
a530 2
	if (!AvREAL((AV*)sv) && AvREIFY((AV*)sv))
	    av_reify((AV*)sv);
d595 1
a595 1
    GV * const gv = (GV*)POPs;
d605 1
a605 1
		tmpRef = (SV*)GvAV(gv);
d609 1
a609 1
		tmpRef = (SV*)GvCVu(gv);
d615 1
a615 1
		tmpRef = (SV*)GvIOp(gv);
d619 1
a619 1
		    tmpRef = (SV*)GvFORM(gv);
d623 1
a623 1
		tmpRef = (SV*)gv;
d627 1
a627 1
		tmpRef = (SV*)GvHV(gv);
d631 1
a631 1
		tmpRef = (SV*)GvIOp(gv);
d635 1
a635 1
		sv = newSVpvn(GvNAME(gv), GvNAMELEN(gv));
d810 1
a810 1
	av_undef((AV*)sv);
d813 1
a813 1
	hv_undef((HV*)sv);
d818 2
a819 1
		 CvANON((CV*)sv) ? "(anonymous)" : GvENAME(CvGV((CV*)sv)));
d824 3
a826 3
	    GV* const gv = CvGV((CV*)sv);
	    cv_undef((CV*)sv);
	    CvGV((CV*)sv) = gv;
d830 1
a830 1
	if (SvFAKE(sv))
d832 3
a834 1
	else {
d839 1
a839 1
            if((stash = GvHV((GV*)sv)) && HvNAME_get(stash))
d842 2
a843 1
            else if(GvCVu((GV*)sv) && (stash = GvSTASH((GV*)sv)) && HvNAME_get(stash))
d846 1
a846 1
	    gp_free((GV*)sv);
d851 1
a851 1
	    GvEGV(sv) = (GV*)sv;
d853 1
d855 1
a855 1
	break;
d872 2
a873 2
    if (SvTYPE(TOPs) >= SVt_PVGV && SvTYPE(TOPs) != SVt_PVLV)
	DIE(aTHX_ PL_no_modify);
d889 2
a890 2
    if (SvTYPE(TOPs) >= SVt_PVGV && SvTYPE(TOPs) != SVt_PVLV)
	DIE(aTHX_ PL_no_modify);
d911 2
a912 2
    if (SvTYPE(TOPs) >= SVt_PVGV && SvTYPE(TOPs) != SVt_PVLV)
	DIE(aTHX_ PL_no_modify);
d1557 1
a1557 1
		items * sizeof(SV*), count - 1);
d2439 1
a2439 1
		sv_setpvn(TARG, "-", 1);
d2453 1
a2453 1
		    sv_setpvn(TARG, "-", 1);
d2556 1
a2556 1
	  SETs(TARG);
d2572 1
a2572 2

	SETs(TARG);
d2640 1
a2640 1
     dVAR; dVAR; dSP; dATARGET; tryAMAGICbin(modulo,opASSIGN);
d3181 3
a3183 1
	    sv_insert(sv, pos, rem, repl, repl_len);
d3202 1
a3202 1
		    sv_setpvn(sv,"",0);	/* avoid lexical reincarnation */
d3329 2
a3330 3
	big = sv_2mortal(newSVpvn(big_p, biglen));
	if (big_utf8)
	    SvUTF8_on(big);
d3342 2
a3343 3
	little = sv_2mortal(newSVpvn(little_p, llen));
	if (little_utf8)
	    SvUTF8_on(little);
d3508 1
a3508 1
    SETs(TARG);
d3887 1
a3887 3
    SETs(TARG);
    if (SvSMAGICAL(TARG))
	mg_set(TARG);
d3896 1
a3896 1
    register AV* const av = (AV*)POPs;
d3942 1
a3942 1
    HV * hash = (HV*)POPs;
d3979 1
a3979 1
	HV * const hv = (HV*)POPs;
d3990 1
a3990 1
                    SV * const sv = av_delete((AV*)hv, SvIV(*MARK), discard);
d4010 1
a4010 1
	HV * const hv = (HV*)POPs;
d4016 1
a4016 1
		sv = av_delete((AV*)hv, SvIV(keysv), discard);
d4048 1
a4048 1
    hv = (HV*)POPs;
d4055 1
a4055 1
	    if (av_exists((AV*)hv, SvIV(tmpsv)))
d4068 1
a4068 1
    register HV * const hv = (HV*)POPs;
d4077 2
a4078 2
        other_magic = mg_find((SV*)hv, PERL_MAGIC_env) ||
            ((mg = mg_find((SV*)hv, PERL_MAGIC_tied))
d4082 1
a4082 1
             && (stash = SvSTASH(SvRV(SvTIED_obj((SV*)hv, mg))))
d4107 1
a4107 1
		    save_gp((GV*)*svp, !(PL_op->op_flags & OPf_SPECIAL));
d4203 1
a4203 1
    SV * const av = (SV *) av_make(items, MARK+1);
d4205 2
a4206 2
    XPUSHs(sv_2mortal((PL_op->op_flags & OPf_SPECIAL)
		      ? newRV_noinc(av) : av));
d4225 2
a4226 2
    XPUSHs(sv_2mortal((PL_op->op_flags & OPf_SPECIAL)
		      ? newRV_noinc((SV*) hv) : (SV*)hv));
d4233 1
a4233 1
    register AV *ary = (AV*)*++MARK;
d4242 1
a4242 1
    const MAGIC * const mg = SvTIED_mg((SV*)ary, PERL_MAGIC_tied);
d4245 1
a4245 1
	*MARK-- = SvTIED_obj((SV*)ary, mg);
d4438 2
a4439 2
    register AV * const ary = (AV*)*++MARK;
    const MAGIC * const mg = SvTIED_mg((SV*)ary, PERL_MAGIC_tied);
d4442 1
a4442 1
	*MARK-- = SvTIED_obj((SV*)ary, mg);
d4461 1
a4461 1
	    mg_set((SV*)ary);
d4474 1
a4474 1
    AV * const av = (AV*)POPs;
d4487 2
a4488 2
    register AV *ary = (AV*)*++MARK;
    const MAGIC * const mg = SvTIED_mg((SV*)ary, PERL_MAGIC_tied);
d4491 1
a4491 1
	*MARK-- = SvTIED_obj((SV*)ary, mg);
d4608 1
a4608 1
    I32 make_mortal = 1;
d4621 2
a4622 2
    TAINT_IF((rx->extflags & RXf_PMf_LOCALE) &&
	     (rx->extflags & (RXf_WHITE | RXf_SKIPWHITE)));
d4628 1
a4628 1
	ary = GvAVn((GV*)PAD_SVl(pm->op_pmreplrootu.op_pmtargetoff));
d4645 1
a4645 1
	if ((mg = SvTIED_mg((SV*)ary, PERL_MAGIC_tied))) {
d4647 1
a4647 1
	    XPUSHs(SvTIED_obj((SV*)ary, mg));
d4664 1
a4664 1
    if (rx->extflags & RXf_SKIPWHITE) {
d4669 1
a4669 1
	else if (rx->extflags & RXf_PMf_LOCALE) {
d4678 1
a4678 1
    if (rx->extflags & PMf_MULTILINE) {
d4684 1
a4684 1
    if (rx->extflags & RXf_WHITE) {
d4697 1
a4697 1
            } else if (rx->extflags & RXf_PMf_LOCALE) {
d4707 2
a4708 5
	    dstr = newSVpvn(s, m-s);
	    if (make_mortal)
		sv_2mortal(dstr);
	    if (do_utf8)
		(void)SvUTF8_on(dstr);
d4721 1
a4721 1
            } else if (rx->extflags & RXf_PMf_LOCALE) {
d4730 1
a4730 1
    else if (rx->extflags & RXf_START_ONLY) {
d4737 2
a4738 5
	    dstr = newSVpvn(s, m-s);
	    if (make_mortal)
		sv_2mortal(dstr);
	    if (do_utf8)
		(void)SvUTF8_on(dstr);
d4743 1
a4743 1
    else if (rx->extflags & RXf_NULL && !(s >= strend)) {
d4763 1
a4763 1
                dstr = newSVpvn(m, s-m);
a4764 4
                if (make_mortal)
                    sv_2mortal(dstr);

                (void)SvUTF8_on(dstr);
d4786 5
a4790 5
    else if (do_utf8 == ((rx->extflags & RXf_UTF8) != 0) &&
	     (rx->extflags & RXf_USE_INTUIT) && !rx->nparens
	     && (rx->extflags & RXf_CHECK_ALL)
	     && !(rx->extflags & RXf_ANCH)) {
	const int tail = (rx->extflags & RXf_INTUIT_TAIL);
d4793 2
a4794 2
	len = rx->minlenret;
	if (len == 1 && !(rx->extflags & RXf_UTF8) && !tail) {
d4801 2
a4802 5
		dstr = newSVpvn(s, m-s);
		if (make_mortal)
		    sv_2mortal(dstr);
		if (do_utf8)
		    (void)SvUTF8_on(dstr);
d4817 2
a4818 5
		dstr = newSVpvn(s, m-s);
		if (make_mortal)
		    sv_2mortal(dstr);
		if (do_utf8)
		    (void)SvUTF8_on(dstr);
d4830 1
a4830 1
	maxiters += slen * rx->nparens;
d4841 1
a4841 1
	    if (RX_MATCH_COPIED(rx) && rx->subbeg != orig) {
d4844 1
a4844 1
		orig = rx->subbeg;
d4848 3
a4850 6
	    m = rx->offs[0].start + orig;
	    dstr = newSVpvn(s, m-s);
	    if (make_mortal)
		sv_2mortal(dstr);
	    if (do_utf8)
		(void)SvUTF8_on(dstr);
d4852 1
a4852 1
	    if (rx->nparens) {
d4854 3
a4856 3
		for (i = 1; i <= (I32)rx->nparens; i++) {
		    s = rx->offs[i].start + orig;
		    m = rx->offs[i].end + orig;
d4862 3
a4864 1
			dstr = newSVpvn(s, m-s);
a4867 4
		    if (make_mortal)
			sv_2mortal(dstr);
		    if (do_utf8)
			(void)SvUTF8_on(dstr);
d4871 1
a4871 1
	    s = rx->offs[0].end + orig;
d4882 1
a4882 5
	dstr = newSVpvn(s, l);
	if (make_mortal)
	    sv_2mortal(dstr);
	if (do_utf8)
	    (void)SvUTF8_on(dstr);
d4902 1
a4902 1
		mg_set((SV*)ary);
@


1.11
log
@merge in perl 5.8.8
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006, by Larry Wall and others
d50 1
a56 5
PP(pp_scalar)
{
    return NORMAL;
}

d61 1
a61 1
    dSP; dTARGET;
d64 2
a65 1
	SAVECLEARSV(PAD_SVl(PL_op->op_targ));
d83 1
a83 1
		SV ** const svp = av_fetch((AV*)TARG, i, FALSE);
d103 1
a103 1
    dSP; dTARGET;
d108 2
a109 1
	SAVECLEARSV(PAD_SVl(PL_op->op_targ));
a127 5
PP(pp_padany)
{
    DIE(aTHX_ "NOT IMPL LINE %d",__LINE__);
}

d132 1
a132 1
    dSP; dTOPss;
d143 1
a143 1
	    (void)SvREFCNT_inc(sv);
a150 3
	    char *sym;
	    STRLEN len;

d166 3
a168 3
			SV *namesv = PAD_SV(cUNOP->op_targ);
			const char *name = SvPV(namesv, len);
			gv = (GV*)NEWSV(0,0);
d172 2
a173 2
			const char *name = CopSTASHPV(PL_curcop);
			gv = newGVgen((char *)name);
d177 1
a177 1
		    if (SvPVX_const(sv)) {
d191 1
a191 1
		    report_uninit();
a193 1
	    sym = SvPV(sv,len);
d197 4
a200 5
		sv = (SV*)gv_fetchpv(sym, FALSE, SVt_PVGV);
		if (!sv
		    && (!is_gv_magical(sym,len,0)
			|| !(sv = (SV*)gv_fetchpv(sym, TRUE, SVt_PVGV))))
		{
d203 1
d207 9
a215 2
		    DIE(aTHX_ PL_no_symref, sym, "a symbol");
		sv = (SV*)gv_fetchpv(sym, TRUE, SVt_PVGV);
d225 44
d271 2
a272 2
    GV *gv = Nullgv;
    dSP; dTOPss;
d283 2
d286 1
a289 2
	char *sym;
	STRLEN len;
d298 3
a300 25
	    if (!SvOK(sv)) {
		if (PL_op->op_flags & OPf_REF ||
		    PL_op->op_private & HINT_STRICT_REFS)
		    DIE(aTHX_ PL_no_usym, "a SCALAR");
		if (ckWARN(WARN_UNINITIALIZED))
		    report_uninit();
		RETSETUNDEF;
	    }
	    sym = SvPV(sv, len);
	    if ((PL_op->op_flags & OPf_SPECIAL) &&
		!(PL_op->op_flags & OPf_MOD))
	    {
		gv = (GV*)gv_fetchpv(sym, FALSE, SVt_PV);
		if (!gv
		    && (!is_gv_magical(sym,len,0)
			|| !(gv = (GV*)gv_fetchpv(sym, TRUE, SVt_PV))))
		{
		    RETSETUNDEF;
		}
	    }
	    else {
		if (PL_op->op_private & HINT_STRICT_REFS)
		    DIE(aTHX_ PL_no_symref, sym, "a SCALAR");
		gv = (GV*)gv_fetchpv(sym, TRUE, SVt_PV);
	    }
d322 6
a327 7
    dSP;
    AV *const av = (AV*)TOPs;
    SV *sv = AvARYLEN(av);
    if (!sv) {
	AvARYLEN(av) = sv = NEWSV(0,0);
	sv_upgrade(sv, SVt_IV);
	sv_magic(sv, (SV*)av, PERL_MAGIC_arylen, Nullch, 0);
d329 1
a329 1
    SETs(sv);
d335 1
a335 1
    dSP; dTARGET; dPOPss;
d340 1
a340 1
	    sv_magic(TARG, Nullsv, PERL_MAGIC_pos, Nullch, 0);
d347 1
a347 1
	    LvTARG(TARG) = SvREFCNT_inc(sv);
d359 1
a359 1
		PUSHi(i + PL_curcop->cop_arybase);
d369 1
a369 1
    dSP;
d371 6
a376 2
    HV *stash;

d379 2
a380 1
    CV *cv = sv_2cv(TOPs, &stash, &gv, !(PL_op->op_flags & OPf_SPECIAL));
d391 3
d402 1
a402 1
    dSP;
d406 1
a406 1
    SV *ret;
a407 1
    ret = &PL_sv_undef;
d409 1
a409 1
	const char *s = SvPVX_const(TOPs);
d411 1
a411 1
	    const int code = keyword((char *)s + 6, SvCUR(TOPs) - 6);
d414 1
a414 1
		int i = 0, n = 0, seen_question = 0;
d421 7
d438 1
d441 1
a441 1
		    if (oa & OA_OPTIONAL && !seen_question) {
d455 2
d468 1
a468 1
    cv = sv_2cv(TOPs, &stash, &gv, FALSE);
d478 1
a478 1
    dSP;
d489 1
a489 1
    dSP;
d496 1
a496 1
    dSP; dMARK;
d515 1
d524 1
a524 1
	    (void)SvREFCNT_inc(sv);
d530 1
a530 1
	(void)SvREFCNT_inc(sv);
d536 1
a536 1
	(void)SvREFCNT_inc(sv);
d547 1
a547 1
    dSP; dTARGET;
d551 2
a552 2
    if (sv && SvGMAGICAL(sv))
	mg_get(sv);
d564 1
a564 1
    dSP;
d580 1
a580 1
	stash = gv_stashpvn(ptr, len, TRUE);
d589 1
a589 1
    dSP;
d594 1
a594 1
    SV * tmpRef = Nullsv;
d596 1
a596 1
    sv = Nullsv;
d637 3
a639 2
		const char *name = HvNAME_get(GvSTASH(gv));
		sv = newSVpv(name ? name : "__ANON__", 0);
d644 1
a644 1
		tmpRef = GvSV(gv);
d662 1
a662 1
    dSP; dPOPss;
d674 14
a687 6
    else {
	if (PL_lastscream) {
	    SvSCREAM_off(PL_lastscream);
	    SvREFCNT_dec(PL_lastscream);
	}
	PL_lastscream = SvREFCNT_inc(sv);
d689 1
d728 1
a728 1
    sv_magic(sv, Nullsv, PERL_MAGIC_regex_global, Nullch, 0);
d734 1
a734 1
    dSP; dTARG;
d739 2
d754 1
a754 1
    dSP; dTARGET;
d762 1
a762 1
    dSP; dMARK; dTARGET; dORIGMARK;
d772 1
a772 1
    dSP; dTARGET;
d779 1
a779 1
    dSP; dMARK; dTARGET;
a787 31
PP(pp_defined)
{
    dSP;
    register SV* const sv = POPs;

    if (!sv || !SvANY(sv))
	RETPUSHNO;
    switch (SvTYPE(sv)) {
    case SVt_PVAV:
	if (AvMAX(sv) >= 0 || SvGMAGICAL(sv)
		|| (SvRMAGICAL(sv) && mg_find(sv, PERL_MAGIC_tied)))
	    RETPUSHYES;
	break;
    case SVt_PVHV:
	if (HvARRAY(sv) || SvGMAGICAL(sv)
		|| (SvRMAGICAL(sv) && mg_find(sv, PERL_MAGIC_tied)))
	    RETPUSHYES;
	break;
    case SVt_PVCV:
	if (CvROOT(sv) || CvXSUB(sv))
	    RETPUSHYES;
	break;
    default:
	if (SvGMAGICAL(sv))
	    mg_get(sv);
	if (SvOK(sv))
	    RETPUSHYES;
    }
    RETPUSHNO;
}

d790 1
a790 1
    dSP;
d802 1
a802 2
    if (SvTHINKFIRST(sv))
	sv_force_normal(sv);
d817 1
a817 1
	/* FALL THROUGH */
d821 1
a821 1
	    GV* gv = CvGV((CV*)sv);
d831 9
d843 1
a843 1
	    GvSV(sv) = NEWSV(72,0);
d852 1
a852 1
	    SvPV_set(sv, Nullch);
d864 2
a865 2
    dSP;
    if (SvTYPE(TOPs) > SVt_PVLV)
d881 2
a882 2
    dSP; dTARGET;
    if (SvTYPE(TOPs) > SVt_PVLV)
d903 2
a904 2
    dSP; dTARGET;
    if (SvTYPE(TOPs) > SVt_PVLV)
d924 1
a924 1
    dSP; dATARGET;
d929 2
d936 4
a939 4
	SvIV_please(TOPs);
	if (SvIOK(TOPs)) {
	    SvIV_please(TOPm1s);
	    if (SvIOK(TOPm1s)) {
d944 2
a945 2
		if (SvUOK(TOPs)) {
		    power = SvUVX(TOPs);
d947 1
a947 1
		    const IV iv = SvIVX(TOPs);
d955 1
a955 1
		baseuok = SvUOK(TOPm1s);
d957 1
a957 1
		    baseuv = SvUVX(TOPm1s);
d959 1
a959 1
		    const IV iv = SvIVX(TOPm1s);
d994 1
a994 1
                    SvIV_please(TOPs);
d1043 41
a1083 1
	dPOPTOPnnrl;
d1085 2
d1089 1
a1089 1
	    SvIV_please(TOPs);
d1097 4
a1100 1
    dSP; dATARGET; tryAMAGICbin(mult,opASSIGN);
d1102 2
a1103 2
    SvIV_please(TOPs);
    if (SvIOK(TOPs)) {
d1108 4
a1111 4
	SvIV_please(TOPm1s);
	if (SvIOK(TOPm1s)) {
	    bool auvok = SvUOK(TOPm1s);
	    bool buvok = SvUOK(TOPs);
d1120 1
a1120 1
		alow = SvUVX(TOPm1s);
d1122 1
a1122 1
		const IV aiv = SvIVX(TOPm1s);
d1131 1
a1131 1
		blow = SvUVX(TOPs);
d1133 1
a1133 1
		const IV biv = SvIVX(TOPs);
d1148 1
d1154 1
a1154 1
		UV product = alow * blow;
d1207 2
a1208 2
	} /* SvIOK(TOPm1s) */
    } /* SvIOK(TOPs) */
d1211 3
a1213 1
      dPOPTOPnnrl;
d1221 4
a1224 1
    dSP; dATARGET; tryAMAGICbin(div,opASSIGN);
d1247 6
a1252 6
    SvIV_please(TOPs);
    if (SvIOK(TOPs)) {
        SvIV_please(TOPm1s);
        if (SvIOK(TOPm1s)) {
            bool left_non_neg = SvUOK(TOPm1s);
            bool right_non_neg = SvUOK(TOPs);
d1257 1
a1257 1
                right = SvUVX(TOPs);
d1260 1
a1260 1
		const IV biv = SvIVX(TOPs);
d1278 1
a1278 1
                left = SvUVX(TOPm1s);
d1281 1
a1281 1
		const IV aiv = SvIVX(TOPm1s);
d1329 6
a1334 1
	dPOPPOPnnrl;
d1336 1
d1345 1
a1345 1
    dSP; dATARGET; tryAMAGICbin(modulo,opASSIGN);
d1355 5
a1359 4

        SvIV_please(TOPs);
        if (SvIOK(TOPs)) {
            right_neg = !SvUOK(TOPs);
d1361 1
a1361 1
                right = SvUVX(POPs);
d1363 1
a1363 1
		const IV biv = SvIVX(POPs);
d1373 1
a1373 1
	    dright = POPn;
d1384 1
d1389 5
a1393 4
        SvIV_please(TOPs);
	if (!use_double && SvIOK(TOPs)) {
            if (SvIOK(TOPs)) {
                left_neg = !SvUOK(TOPs);
d1395 1
a1395 1
                    left = SvUVX(POPs);
d1397 1
a1397 1
                    IV aiv = SvIVX(POPs);
d1408 1
a1408 1
	    dleft = POPn;
d1436 1
d1477 1
a1477 1
  dSP; dATARGET; tryAMAGICbin(repeat,opASSIGN);
d1481 1
a1481 2
    if (SvGMAGICAL(sv))
	 mg_get(sv);
d1490 1
a1490 1
	      IV iv = SvIV(sv);
d1505 1
a1505 1
	 count = SvIVx(sv);
d1508 3
a1510 4
	I32 items = SP - MARK;
	I32 max;
	static const char oom_list_extend[] =
	  "Out of memory during list extend";
a1511 1
	max = items * count;
d1557 1
a1557 1
	SV *tmpstr = POPs;
d1570 2
a1571 2
		STRLEN max = (UV)count * len;
		if (len > ((MEM_SIZE)~0)/count)
d1602 5
a1606 2
    dSP; dATARGET; bool useleft; tryAMAGICbin(subtr,opASSIGN);
    useleft = USE_LEFT(TOPm1s);
d1610 2
a1611 2
    SvIV_please(TOPs);
    if (SvIOK(TOPs)) {
d1625 4
a1628 4
	    SvIV_please(TOPm1s);
	    if (SvIOK(TOPm1s)) {
		if ((auvok = SvUOK(TOPm1s)))
		    auv = SvUVX(TOPm1s);
d1630 1
a1630 1
		    register const IV aiv = SvIVX(TOPm1s);
d1645 1
a1645 1
	    bool buvok = SvUOK(TOPs);
d1648 1
a1648 1
		buv = SvUVX(TOPs);
d1650 1
a1650 1
		register const IV biv = SvIVX(TOPs);
a1706 1
    useleft = USE_LEFT(TOPm1s);
d1708 3
a1710 1
	dPOPnv;
d1716 1
a1716 1
	SETn( TOPn - value );
d1723 1
a1723 1
    dSP; dATARGET; tryAMAGICbin(lshift,opASSIGN);
d1727 1
a1727 1
	IV i = TOPi;
d1731 1
a1731 1
	UV u = TOPu;
d1740 1
a1740 1
    dSP; dATARGET; tryAMAGICbin(rshift,opASSIGN);
d1744 1
a1744 1
	IV i = TOPi;
d1748 1
a1748 1
	UV u = TOPu;
d1757 1
a1757 1
    dSP; tryAMAGICbinSET(lt,0);
d1824 6
d1832 1
d1839 1
a1839 1
    dSP; tryAMAGICbinSET(gt,0);
d1907 6
d1915 1
d1922 1
a1922 1
    dSP; tryAMAGICbinSET(le,0);
d1990 6
d1998 1
d2005 1
a2005 1
    dSP; tryAMAGICbinSET(ge,0);
d2073 6
d2081 1
d2088 1
a2088 1
    dSP; tryAMAGICbinSET(ne,0);
d2101 2
a2102 2
	    bool auvok = SvUOK(TOPm1s);
	    bool buvok = SvUOK(TOPs);
d2149 6
d2157 1
d2164 1
a2164 1
    dSP; dTARGET; tryAMAGICbin(ncmp,0);
d2167 2
a2168 2
        UV right = PTR2UV(SvRV(POPs));
        UV left = PTR2UV(SvRV(TOPs));
d2266 1
a2266 1
PP(pp_slt)
d2268 1
a2268 10
    dSP; tryAMAGICbinSET(slt,0);
    {
      dPOPTOPssrl;
      const int cmp = (IN_LOCALE_RUNTIME
		 ? sv_cmp_locale(left, right)
		 : sv_cmp(left, right));
      SETs(boolSV(cmp < 0));
      RETURN;
    }
}
d2270 21
a2290 10
PP(pp_sgt)
{
    dSP; tryAMAGICbinSET(sgt,0);
    {
      dPOPTOPssrl;
      const int cmp = (IN_LOCALE_RUNTIME
		 ? sv_cmp_locale(left, right)
		 : sv_cmp(left, right));
      SETs(boolSV(cmp > 0));
      RETURN;
a2291 14
}

PP(pp_sle)
{
    dSP; tryAMAGICbinSET(sle,0);
    {
      dPOPTOPssrl;
      const int cmp = (IN_LOCALE_RUNTIME
		 ? sv_cmp_locale(left, right)
		 : sv_cmp(left, right));
      SETs(boolSV(cmp <= 0));
      RETURN;
    }
}
d2293 1
a2293 3
PP(pp_sge)
{
    dSP; tryAMAGICbinSET(sge,0);
d2299 1
a2299 1
      SETs(boolSV(cmp >= 0));
d2306 1
a2306 1
    dSP; tryAMAGICbinSET(seq,0);
d2316 1
a2316 1
    dSP; tryAMAGICbinSET(sne,0);
d2326 1
a2326 1
    dSP; dTARGET;  tryAMAGICbin(scmp,0);
d2339 1
a2339 1
    dSP; dATARGET; tryAMAGICbin(band,opASSIGN);
d2342 2
d2346 1
a2346 1
	  const IV i = SvIV(left) & SvIV(right);
d2350 1
a2350 1
	  const UV u = SvUV(left) & SvUV(right);
d2362 1
a2362 1
PP(pp_bit_xor)
d2364 2
a2365 20
    dSP; dATARGET; tryAMAGICbin(bxor,opASSIGN);
    {
      dPOPTOPssrl;
      if (SvNIOKp(left) || SvNIOKp(right)) {
	if (PL_op->op_private & HINT_INTEGER) {
	  const IV i = (USE_LEFT(left) ? SvIV(left) : 0) ^ SvIV(right);
	  SETi(i);
	}
	else {
	  const UV u = (USE_LEFT(left) ? SvUV(left) : 0) ^ SvUV(right);
	  SETu(u);
	}
      }
      else {
	do_vop(PL_op->op_type, TARG, left, right);
	SETTARG;
      }
      RETURN;
    }
}
d2367 1
a2367 3
PP(pp_bit_or)
{
    dSP; dATARGET; tryAMAGICbin(bor,opASSIGN);
d2370 2
d2374 4
a2377 2
	  const IV i = (USE_LEFT(left) ? SvIV(left) : 0) | SvIV(right);
	  SETi(i);
d2380 4
a2383 2
	  const UV u = (USE_LEFT(left) ? SvUV(left) : 0) | SvUV(right);
	  SETu(u);
d2387 1
a2387 1
	do_vop(PL_op->op_type, TARG, left, right);
d2396 1
a2396 1
    dSP; dTARGET; tryAMAGICun(neg);
d2398 1
a2398 1
	dTOPss;
d2400 1
a2400 2
	if (SvGMAGICAL(sv))
	    mg_get(sv);
d2430 1
a2430 1
	    const char *s = SvPV_const(sv, len);
d2466 1
a2466 1
    dSP; tryAMAGICunSET(not);
d2473 1
a2473 1
    dSP; dTARGET; tryAMAGICun(compl);
d2476 1
d2479 1
a2479 1
	  const IV i = ~SvIV(sv);
d2483 1
a2483 1
	  const UV u = ~SvUV(sv);
d2493 1
a2493 1
	SvSetSV(TARG, sv);
a2498 2
	  U8 *result;
	  U8 *send;
d2502 3
a2505 1
	  send = tmps + len;
d2507 2
a2508 2
	    const UV c = utf8n_to_uvchr(tmps, send-tmps, &l, UTF8_ALLOW_ANYUV);
	    tmps += UTF8SKIP(tmps);
d2516 1
a2516 1
	  tmps -= len;
d2519 5
a2523 1
	      Newxz(result, targlen + 1, U8);
d2525 3
a2527 3
		  const UV c = utf8n_to_uvchr(tmps, send-tmps, &l, UTF8_ALLOW_ANYUV);
		  tmps += UTF8SKIP(tmps);
		  result = uvchr_to_utf8_flags(result, ~c, UNICODE_ALLOW_ANY);
d2529 3
a2531 3
	      *result = '\0';
	      result -= targlen;
	      sv_setpvn(TARG, (char*)result, targlen);
d2535 5
a2539 1
	      Newxz(result, nchar + 1, U8);
d2541 3
a2543 3
		  const U8 c = (U8)utf8n_to_uvchr(tmps, 0, &l, UTF8_ALLOW_ANY);
		  tmps += UTF8SKIP(tmps);
		  *result++ = ~c;
d2545 2
a2546 3
	      *result = '\0';
	      result -= nchar;
	      sv_setpvn(TARG, (char*)result, nchar);
a2548 1
	  Safefree(result);
d2558 1
a2558 1
	    for ( ; anum >= sizeof(long); anum -= sizeof(long), tmpl++)
d2576 1
a2576 1
    dSP; dATARGET; tryAMAGICbin(mult,opASSIGN);
d2586 2
a2587 1
    dSP; dATARGET; tryAMAGICbin(div,opASSIGN);
d2591 8
a2598 2
	DIE(aTHX_ "Illegal division by zero");
      value = POPi / value;
d2604 1
d2607 3
d2612 1
a2612 1
     dSP; dATARGET; tryAMAGICbin(modulo,opASSIGN);
d2617 5
a2621 1
	  SETi( left % right );
d2629 1
d2634 1
a2634 1
     dSP; dATARGET; tryAMAGICbin(modulo,opASSIGN);
d2639 5
a2643 1
	  SETi( left % PERL_ABS(right) );
a2646 1
#endif
d2650 1
a2650 1
     dSP; dATARGET; tryAMAGICbin(modulo,opASSIGN);
a2665 1
#if defined(__GLIBC__) && IVSIZE == 8
d2681 5
a2685 2
#endif
	  SETi( left % right );
d2689 1
d2693 1
a2693 1
    dSP; dATARGET; tryAMAGICbin(add,opASSIGN);
d2703 1
a2703 1
    dSP; dATARGET; tryAMAGICbin(subtr,opASSIGN);
d2713 1
a2713 1
    dSP; tryAMAGICbinSET(lt,0);
d2723 1
a2723 1
    dSP; tryAMAGICbinSET(gt,0);
d2733 1
a2733 1
    dSP; tryAMAGICbinSET(le,0);
d2743 1
a2743 1
    dSP; tryAMAGICbinSET(ge,0);
d2753 1
a2753 1
    dSP; tryAMAGICbinSET(eq,0);
d2763 1
a2763 1
    dSP; tryAMAGICbinSET(ne,0);
d2773 1
a2773 1
    dSP; dTARGET; tryAMAGICbin(ncmp,0);
d2791 1
a2791 1
    dSP; dTARGET; tryAMAGICun(neg);
d2800 1
a2800 1
    dSP; dTARGET; tryAMAGICbin(atan2,0);
d2810 25
a2834 5
    dSP; dTARGET; tryAMAGICun(sin);
    {
      const NV value = POPn;
      XPUSHn(Perl_sin(value));
      RETURN;
a2835 1
}
d2837 1
a2837 3
PP(pp_cos)
{
    dSP; dTARGET; tryAMAGICun(cos);
d2840 7
a2846 1
      XPUSHn(Perl_cos(value));
d2868 1
a2868 1
    dSP; dTARGET;
d2887 2
a2888 6
    dSP;
    UV anum;
    if (MAXARG < 1)
	anum = seed();
    else
	anum = POPu;
a2894 40
PP(pp_exp)
{
    dSP; dTARGET; tryAMAGICun(exp);
    {
      NV value;
      value = POPn;
      value = Perl_exp(value);
      XPUSHn(value);
      RETURN;
    }
}

PP(pp_log)
{
    dSP; dTARGET; tryAMAGICun(log);
    {
      const NV value = POPn;
      if (value <= 0.0) {
	SET_NUMERIC_STANDARD();
	DIE(aTHX_ "Can't take log of %"NVgf, value);
      }
      XPUSHn(Perl_log(value));
      RETURN;
    }
}

PP(pp_sqrt)
{
    dSP; dTARGET; tryAMAGICun(sqrt);
    {
      const NV value = POPn;
      if (value < 0.0) {
	SET_NUMERIC_STANDARD();
	DIE(aTHX_ "Can't take sqrt of %"NVgf, value);
      }
      XPUSHn(Perl_sqrt(value));
      RETURN;
    }
}

d2897 1
a2897 1
    dSP; dTARGET; tryAMAGICun(int);
d2899 2
a2900 1
      const IV iv = TOPi; /* attempt to convert to IV if possible. */
d2906 1
a2906 1
      if (!SvOK(TOPs))
d2908 5
a2912 5
      else if (SvIOK(TOPs)) {
	if (SvIsUV(TOPs)) {
	    const UV uv = TOPu;
	    SETu(uv);
	} else
d2914 3
a2916 2
      } else {
	  const NV value = TOPn;
d2938 1
a2938 1
    dSP; dTARGET; tryAMAGICun(abs);
d2940 1
d2942 1
a2942 1
      const IV iv = TOPi;
d2944 1
a2944 1
      if (!SvOK(TOPs))
d2946 2
a2947 1
      else if (SvIOK(TOPs)) {
d2949 2
a2950 2
	if (SvIsUV(TOPs)) {
	  SETu(TOPu);	/* force it to be numeric only */
d2965 1
a2965 1
	const NV value = TOPn;
d2975 1
a2975 2

PP(pp_hex)
d2977 1
a2977 1
    dSP; dTARGET;
d2995 10
a3004 3
    result_uv = grok_hex ((char *)tmps, &len, &flags, &result_nv);
    if (flags & PERL_SCAN_GREATER_THAN_UV_MAX) {
        XPUSHn(result_nv);
a3005 32
    else {
        XPUSHu(result_uv);
    }
    RETURN;
}

PP(pp_oct)
{
    dSP; dTARGET;
    const char *tmps;
    I32 flags = PERL_SCAN_ALLOW_UNDERSCORES;
    STRLEN len;
    NV result_nv;
    UV result_uv;
    SV* const sv = POPs;

    tmps = (SvPV_const(sv, len));
    if (DO_UTF8(sv)) {
	 /* If Unicode, try to downgrade
	  * If not possible, croak. */
	 SV* const tsv = sv_2mortal(newSVsv(sv));
	
	 SvUTF8_on(tsv);
	 sv_utf8_downgrade(tsv, FALSE);
	 tmps = SvPV_const(tsv, len);
    }
    while (*tmps && len && isSPACE(*tmps))
        tmps++, len--;
    if (*tmps == '0')
        tmps++, len--;
    if (*tmps == 'x')
        result_uv = grok_hex ((char *)tmps, &len, &flags, &result_nv);
d3007 1
a3007 1
        result_uv = grok_bin ((char *)tmps, &len, &flags, &result_nv);
d3009 1
a3009 1
        result_uv = grok_oct ((char *)tmps, &len, &flags, &result_nv);
d3024 10
a3033 2
    dSP; dTARGET;
    SV *sv = TOPs;
d3035 8
a3042 1
    if (DO_UTF8(sv))
d3051 1
a3051 1
    dSP; dTARGET;
d3061 1
a3061 1
    const I32 arybase = PL_curcop->cop_arybase;
d3063 1
a3063 1
    const char *repl = 0;
d3175 1
a3175 1
	    sv_insert(sv, pos, rem, (char *)repl, repl_len);
d3189 3
a3191 1
		if (SvOK(sv))		/* is it defined ? */
d3199 1
a3199 1
		sv_magic(TARG, Nullsv, PERL_MAGIC_substr, Nullch, 0);
a3200 2
	    else
		SvOK_off(TARG);
d3206 1
a3206 1
		LvTARG(TARG) = SvREFCNT_inc(sv);
d3219 1
a3219 1
    dSP; dTARGET;
d3231 1
a3231 1
	    sv_magic(TARG, Nullsv, PERL_MAGIC_vec, Nullch, 0);
d3237 1
a3237 1
	    LvTARG(TARG) = SvREFCNT_inc(src);
d3250 1
a3250 1
    dSP; dTARGET;
d3253 3
a3255 1
    SV *temp = Nullsv;
d3258 10
a3267 10
    const char *tmps;
    const char *tmps2;
    STRLEN biglen;
    const I32 arybase = PL_curcop->cop_arybase;
    int big_utf8;
    int little_utf8;

    if (MAXARG < 3)
	offset = 0;
    else
d3269 1
d3272 3
d3279 21
a3299 3
	SV * const bytes = little_utf8 ? big : little;
	STRLEN len;
	const char * const p = SvPV_const(bytes, len);
d3301 13
a3313 12
	temp = newSVpvn(p, len);

	if (PL_encoding) {
	    sv_recode_to_utf8(temp, PL_encoding);
	} else {
	    sv_utf8_upgrade(temp);
	}
	if (little_utf8) {
	    big = temp;
	    big_utf8 = TRUE;
	} else {
	    little = temp;
d3316 23
a3338 61
    if (big_utf8 && offset > 0)
	sv_pos_u2b(big, &offset, 0);
    tmps = SvPV_const(big, biglen);
    if (offset < 0)
	offset = 0;
    else if (offset > (I32)biglen)
	offset = biglen;
    if (!(tmps2 = fbm_instr((unsigned char*)tmps + offset,
      (unsigned char*)tmps + biglen, little, 0)))
	retval = -1;
    else
	retval = tmps2 - tmps;
    if (retval > 0 && big_utf8)
	sv_pos_b2u(big, &retval);
    if (temp)
	SvREFCNT_dec(temp);
    PUSHi(retval + arybase);
    RETURN;
}

PP(pp_rindex)
{
    dSP; dTARGET;
    SV *big;
    SV *little;
    SV *temp = Nullsv;
    STRLEN blen;
    STRLEN llen;
    I32 offset;
    I32 retval;
    const char *tmps;
    const char *tmps2;
    const I32 arybase = PL_curcop->cop_arybase;
    int big_utf8;
    int little_utf8;

    if (MAXARG >= 3)
	offset = POPi;
    little = POPs;
    big = POPs;
    big_utf8 = DO_UTF8(big);
    little_utf8 = DO_UTF8(little);
    if (big_utf8 ^ little_utf8) {
	/* One needs to be upgraded.  */
	SV * const bytes = little_utf8 ? big : little;
	STRLEN len;
	const char *p = SvPV_const(bytes, len);

	temp = newSVpvn(p, len);

	if (PL_encoding) {
	    sv_recode_to_utf8(temp, PL_encoding);
	} else {
	    sv_utf8_upgrade(temp);
	}
	if (little_utf8) {
	    big = temp;
	    big_utf8 = TRUE;
	} else {
	    little = temp;
	}
a3339 2
    tmps2 = SvPV_const(little, llen);
    tmps = SvPV_const(big, blen);
d3342 1
a3342 1
	offset = blen;
d3344 1
a3344 1
	if (offset > 0 && big_utf8)
d3346 2
a3347 1
	offset = offset - arybase + llen;
d3351 7
a3357 4
    else if (offset > (I32)blen)
	offset = blen;
    if (!(tmps2 = rninstr(tmps,  tmps  + offset,
			  tmps2, tmps2 + llen)))
d3359 5
a3363 4
    else
	retval = tmps2 - tmps;
    if (retval > 0 && big_utf8)
	sv_pos_b2u(big, &retval);
d3366 1
d3373 3
a3375 1
    dSP; dMARK; dORIGMARK; dTARGET;
a3377 2
    if (DO_UTF8(*(MARK+1)))
	SvUTF8_on(TARG);
d3385 2
a3386 1
    dSP; dTARGET;
a3389 1
    SV *tmpsv;
d3392 1
a3392 1
        tmpsv = sv_2mortal(newSVsv(argsv));
d3398 2
a3399 2
	   utf8n_to_uvchr((U8 *)s, UTF8_MAXBYTES, 0, UTF8_ALLOW_ANYUV) :
	   (*s & 0xff));
d3406 1
a3406 1
    dSP; dTARGET;
d3408 14
a3421 1
    UV value = POPu;
d3423 1
a3423 1
    (void)SvUPGRADE(TARG,SVt_PV);
d3442 1
d3447 2
a3448 2
	    memEQ(tmps, "\xef\xbf\xbd\0", 4)) {
	    SvGROW(TARG, 3);
d3450 2
a3451 3
	    SvCUR_set(TARG, 2);
	    *tmps++ = (U8)UTF8_EIGHT_BIT_HI(value);
	    *tmps++ = (U8)UTF8_EIGHT_BIT_LO(value);
d3453 1
a3453 1
	    SvUTF8_on(TARG);
d3456 1
d3464 1
a3464 1
    dSP; dTARGET;
d3512 1
d3514 7
a3520 1
    SV *sv = TOPs;
d3522 42
a3563 1
    STRLEN slen;
d3565 1
a3565 7
    SvGETMAGIC(sv);
    if (DO_UTF8(sv) &&
	(s = (const U8*)SvPV_nomg_const(sv, slen)) && slen &&
	UTF8_IS_START(*s)) {
	U8 tmpbuf[UTF8_MAXBYTES_CASE+1];
	STRLEN ulen;
	STRLEN tculen;
d3567 2
a3568 2
	utf8_to_uvchr((U8 *)s, &ulen);
	toTITLE_utf8((U8 *)s, tmpbuf, &tculen);
d3570 2
a3571 2
	if (!SvPADTMP(sv) || SvREADONLY(sv) || ulen != tculen) {
	    dTARGET;
d3575 5
a3579 5
	     * tculen is the byte length of the freshly titlecased
	     * Unicode character stored as UTF-8 at tmpbuf.
	     * We first set the result to be the titlecased character,
	     * and then append the rest of the SV data. */
	    sv_setpvn(TARG, (char*)tmpbuf, tculen);
d3581 2
a3582 3
	        sv_catpvn(TARG, (char*)(s + ulen), slen - ulen);
	    SvUTF8_on(TARG);
	    SETs(TARG);
d3585 2
a3586 2
	    s = (U8*)SvPV_force_nomg(sv, slen);
	    Copy(tmpbuf, s, tculen, U8);
d3590 1
a3590 10
	U8 *s1;
	if (!SvPADTMP(sv) || SvREADONLY(sv)) {
	    dTARGET;
	    SvUTF8_off(TARG);				/* decontaminate */
	    sv_setsv_nomg(TARG, sv);
	    sv = TARG;
	    SETs(sv);
	}
	s1 = (U8*)SvPV_force_nomg(sv, slen);
	if (*s1) {
d3593 3
a3595 2
		SvTAINTED_on(sv);
		*s1 = toUPPER_LC(*s1);
d3598 4
a3601 1
		*s1 = toUPPER(*s1);
a3602 4
    }
    SvSETMAGIC(sv);
    RETURN;
}
d3604 2
a3605 14
PP(pp_lcfirst)
{
    dSP;
    SV *sv = TOPs;
    const U8 *s;
    STRLEN slen;

    SvGETMAGIC(sv);
    if (DO_UTF8(sv) &&
	(s = (const U8*)SvPV_nomg_const(sv, slen)) && slen &&
	UTF8_IS_START(*s)) {
	STRLEN ulen;
	STRLEN lculen;
	U8 tmpbuf[UTF8_MAXBYTES_CASE+1];
d3607 4
a3610 34
	utf8_to_uvchr((U8 *)s, &ulen);
	toLOWER_utf8((U8 *)s, tmpbuf, &lculen);

	if (!SvPADTMP(sv) || SvREADONLY(sv) || ulen != lculen) {
	    dTARGET;
	    sv_setpvn(TARG, (char*)tmpbuf, lculen);
	    if (slen > ulen)
	        sv_catpvn(TARG, (char*)(s + ulen), slen - ulen);
	    SvUTF8_on(TARG);
	    SETs(TARG);
	}
	else {
	    s = (U8*)SvPV_force_nomg(sv, slen);
	    Copy(tmpbuf, s, ulen, U8);
	}
    }
    else {
	U8 *s1;
	if (!SvPADTMP(sv) || SvREADONLY(sv)) {
	    dTARGET;
	    SvUTF8_off(TARG);				/* decontaminate */
	    sv_setsv_nomg(TARG, sv);
	    sv = TARG;
	    SETs(sv);
	}
	s1 = (U8*)SvPV_force_nomg(sv, slen);
	if (*s1) {
	    if (IN_LOCALE_RUNTIME) {
		TAINT;
		SvTAINTED_on(sv);
		*s1 = toLOWER_LC(*s1);
	    }
	    else
		*s1 = toLOWER(*s1);
d3613 1
a3613 1
    SvSETMAGIC(sv);
d3617 3
d3622 1
d3624 1
a3624 1
    SV *sv = TOPs;
d3626 6
d3633 8
a3640 2
    SvGETMAGIC(sv);
    if (DO_UTF8(sv)) {
a3641 5
	STRLEN ulen;
	register U8 *d;
	const U8 *s;
	const U8 *send;
	U8 tmpbuf[UTF8_MAXBYTES+1];
d3643 14
a3656 5
	s = (const U8*)SvPV_nomg_const(sv,len);
	if (!len) {
	    SvUTF8_off(TARG);				/* decontaminate */
	    sv_setpvn(TARG, "", 0);
	    SETs(TARG);
d3658 5
a3662 2
	else {
	    STRLEN min = len + 1;
d3664 1
a3664 30
	    (void)SvUPGRADE(TARG, SVt_PV);
	    SvGROW(TARG, min);
	    (void)SvPOK_only(TARG);
	    d = (U8*)SvPVX(TARG);
	    send = s + len;
	    while (s < send) {
		STRLEN u = UTF8SKIP(s);

		toUPPER_utf8((U8 *)s, tmpbuf, &ulen);
		if (ulen > u && (SvLEN(TARG) < (min += ulen - u))) {
		    /* If the eventually required minimum size outgrows
		     * the available space, we need to grow. */
		    UV o = d - (U8*)SvPVX_const(TARG);

		    /* If someone uppercases one million U+03B0s we
		     * SvGROW() one million times.  Or we could try
		     * guessing how much to allocate without allocating
		     * too much. Such is life. */
		    SvGROW(TARG, min);
		    d = (U8*)SvPVX(TARG) + o;
		}
		Copy(tmpbuf, d, ulen, U8);
		d += ulen;
		s += u;
	    }
	    *d = '\0';
	    SvUTF8_on(TARG);
	    SvCUR_set(TARG, d - (U8*)SvPVX_const(TARG));
	    SETs(TARG);
	}
d3666 27
a3692 8
    else {
	U8 *s;
	if (!SvPADTMP(sv) || SvREADONLY(sv)) {
	    dTARGET;
	    SvUTF8_off(TARG);				/* decontaminate */
	    sv_setsv_nomg(TARG, sv);
	    sv = TARG;
	    SETs(sv);
d3694 4
a3697 1
	s = (U8*)SvPV_force_nomg(sv, len);
d3699 1
a3699 2
	    register const U8 *send = s + len;

d3702 3
a3704 3
		SvTAINTED_on(sv);
		for (; s < send; s++)
		    *s = toUPPER_LC(*s);
d3707 2
a3708 2
		for (; s < send; s++)
		    *s = toUPPER(*s);
d3711 4
d3716 1
a3716 1
    SvSETMAGIC(sv);
d3722 1
d3724 1
a3724 1
    SV *sv = TOPs;
d3726 6
d3733 8
a3740 2
    SvGETMAGIC(sv);
    if (DO_UTF8(sv)) {
a3741 5
	const U8 *s;
	STRLEN ulen;
	register U8 *d;
	const U8 *send;
	U8 tmpbuf[UTF8_MAXBYTES_CASE+1];
d3743 14
a3756 5
	s = (const U8*)SvPV_nomg_const(sv,len);
	if (!len) {
	    SvUTF8_off(TARG);				/* decontaminate */
	    sv_setpvn(TARG, "", 0);
	    SETs(TARG);
d3758 15
a3772 2
	else {
	    STRLEN min = len + 1;
d3774 4
a3777 8
	    (void)SvUPGRADE(TARG, SVt_PV);
	    SvGROW(TARG, min);
	    (void)SvPOK_only(TARG);
	    d = (U8*)SvPVX(TARG);
	    send = s + len;
	    while (s < send) {
		const STRLEN u = UTF8SKIP(s);
		const UV uv = toLOWER_utf8((U8 *)s, tmpbuf, &ulen);
d3780 14
a3793 33
		if (uv == GREEK_CAPITAL_LETTER_SIGMA) {
		     /*
		      * Now if the sigma is NOT followed by
		      * /$ignorable_sequence$cased_letter/;
		      * and it IS preceded by
		      * /$cased_letter$ignorable_sequence/;
		      * where $ignorable_sequence is
		      * [\x{2010}\x{AD}\p{Mn}]*
		      * and $cased_letter is
		      * [\p{Ll}\p{Lo}\p{Lt}]
		      * then it should be mapped to 0x03C2,
		      * (GREEK SMALL LETTER FINAL SIGMA),
		      * instead of staying 0x03A3.
		      * "should be": in other words,
		      * this is not implemented yet.
		      * See lib/unicore/SpecialCasing.txt.
		      */
		}
		if (ulen > u && (SvLEN(TARG) < (min += ulen - u))) {
		    /* If the eventually required minimum size outgrows
		     * the available space, we need to grow. */
		    UV o = d - (U8*)SvPVX_const(TARG);

		    /* If someone lowercases one million U+0130s we
		     * SvGROW() one million times.  Or we could try
		     * guessing how much to allocate without allocating.
		     * too much.  Such is life. */
		    SvGROW(TARG, min);
		    d = (U8*)SvPVX(TARG) + o;
		}
		Copy(tmpbuf, d, ulen, U8);
		d += ulen;
		s += u;
d3795 14
a3808 4
	    *d = '\0';
	    SvUTF8_on(TARG);
	    SvCUR_set(TARG, d - (U8*)SvPVX_const(TARG));
	    SETs(TARG);
d3810 4
a3813 12
    }
    else {
	U8 *s;
	if (!SvPADTMP(sv) || SvREADONLY(sv)) {
	    dTARGET;
	    SvUTF8_off(TARG);				/* decontaminate */
	    sv_setsv_nomg(TARG, sv);
	    sv = TARG;
	    SETs(sv);
	}

	s = (U8*)SvPV_force_nomg(sv, len);
d3815 1
a3815 2
	    register const U8 * const send = s + len;

d3818 3
a3820 3
		SvTAINTED_on(sv);
		for (; s < send; s++)
		    *s = toLOWER_LC(*s);
d3823 2
a3824 2
		for (; s < send; s++)
		    *s = toLOWER(*s);
d3827 4
d3832 1
a3832 1
    SvSETMAGIC(sv);
d3838 1
a3838 1
    dSP; dTARGET;
d3846 1
a3846 1
	(void)SvUPGRADE(TARG, SVt_PV);
d3891 1
a3891 1
    dSP; dMARK; dORIGMARK;
d3896 1
a3896 1
	const I32 arybase = PL_curcop->cop_arybase;
d3901 1
a3901 1
		const I32 elem = SvIVx(*svp);
d3910 1
a3910 1
	    I32 elem = SvIVx(*MARK);
d3936 1
d3938 1
a3938 1
    HV * const hash = (HV*)POPs;
a3940 1
    I32 realhv = (SvTYPE(hash) == SVt_PVHV);
d3944 1
a3944 1
    entry = realhv ? hv_iternext(hash) : avhv_iternext((AV*)hash);
d3955 1
a3955 2
	    val = realhv ?
		  hv_iterval(hash, entry) : avhv_iterval((AV*)hash, entry);
a3965 10
PP(pp_values)
{
    return do_kv();
}

PP(pp_keys)
{
    return do_kv();
}

d3968 1
d3983 7
a3989 13
	else if (hvtype == SVt_PVAV) {
	    if (PL_op->op_flags & OPf_SPECIAL) {	/* array element */
		while (++MARK <= SP) {
		    SV * const sv = av_delete((AV*)hv, SvIV(*MARK), discard);
		    *MARK = sv ? sv : &PL_sv_undef;
		}
	    }
	    else {					/* pseudo-hash element */
		while (++MARK <= SP) {
		    SV * const sv = avhv_delete_ent((AV*)hv, *MARK, discard, 0);
		    *MARK = sv ? sv : &PL_sv_undef;
		}
	    }
d4014 1
a4014 1
		sv = avhv_delete_ent((AV*)hv, keysv, discard, 0);
d4028 1
d4035 2
a4036 2
	SV *sv = POPs;
	CV * const cv = sv_2cv(sv, &hv, &gv, FALSE);
a4053 2
	else if (avhv_exists_ent((AV*)hv, tmpsv, 0))	/* pseudo-hash element */
	    RETPUSHYES;
d4063 1
a4063 1
    dSP; dMARK; dORIGMARK;
d4066 1
a4066 2
    I32 realhv = (SvTYPE(hv) == SVt_PVHV);
    const bool localizing = PL_op->op_private & OPpLVAL_INTRO ? TRUE : FALSE;
d4083 10
a4092 2
    if (!realhv && localizing)
	DIE(aTHX_ "Can't localize pseudo-hash element");
d4094 2
a4095 5
    if (realhv || SvTYPE(hv) == SVt_PVAV) {
	while (++MARK <= SP) {
	    SV *keysv = *MARK;
	    SV **svp;
	    bool preeminent = FALSE;
d4097 4
d4102 3
a4104 17
                preeminent = SvRMAGICAL(hv) && !other_magic ? 1 :
                    realhv ? hv_exists_ent(hv, keysv, 0)
                    : avhv_exists_ent((AV*)hv, keysv, 0);
            }

	    if (realhv) {
		HE *he = hv_fetch_ent(hv, keysv, lval, 0);
		svp = he ? &HeVAL(he) : 0;
	    }
	    else {
		svp = avhv_fetch_ent((AV*)hv, keysv, lval, 0);
	    }
	    if (lval) {
		if (!svp || *svp == &PL_sv_undef) {
		    DIE(aTHX_ PL_no_helem_sv, keysv);
		}
		if (localizing) {
d4106 1
a4106 1
		        save_helem(hv, keysv, svp);
d4109 3
a4111 2
			const char *key = SvPV_const(keysv, keylen);
			SAVEDELETE(hv, savepvn(key,keylen), keylen);
d4113 4
a4116 4
                }
	    }
	    *MARK = svp ? *svp : &PL_sv_undef;
	}
d4130 1
a4130 1
    dSP; dMARK;
d4143 1
d4149 2
a4150 2
    const I32 arybase = PL_curcop->cop_arybase;
    I32 is_something_there = PL_op->op_flags & OPf_MOD;
d4156 1
a4156 1
	I32 ix = SvIVx(*lastlelem);
d4175 1
a4175 1
	I32 ix = SvIVx(*lelem);
d4197 1
a4197 1
    dSP; dMARK; dORIGMARK;
d4199 1
a4199 1
    SV * const av = sv_2mortal((SV*)av_make(items, MARK+1));
d4201 2
a4202 1
    XPUSHs(av);
d4208 2
a4209 2
    dSP; dMARK; dORIGMARK;
    HV* const hv = (HV*)sv_2mortal((SV*)newHV());
d4213 1
a4213 1
	SV * const val = NEWSV(46, 0);
d4221 2
a4222 1
    XPUSHs((SV*)hv);
d4228 1
a4228 1
    dSP; dMARK; dORIGMARK;
a4237 1
    SV **tmparyval = 0;
d4254 1
a4254 1
	offset = i = SvIVx(*MARK);
d4258 1
a4258 1
	    offset -= PL_curcop->cop_arybase;
d4303 1
d4342 1
a4342 1
	    SvPV_set(ary, (char*)(AvARRAY(ary) - diff)); /* diff is negative */
d4364 1
a4370 1

a4371 1

d4378 1
a4378 1
		SvPV_set(ary, (char*)(AvARRAY(ary) - diff));/* diff is positive */
a4411 1
		Safefree(tmparyval);
a4421 1
	    Safefree(tmparyval);
d4425 1
d4433 2
a4434 2
    dSP; dMARK; dORIGMARK; dTARGET;
    register AV *ary = (AV*)*++MARK;
d4445 2
d4449 1
a4449 1
	/* Why no pre-extend of ary here ? */
d4451 1
a4451 1
	    SV * const sv = NEWSV(51, 0);
d4454 1
a4454 1
	    av_push(ary, sv);
d4456 6
a4462 13
    SP = ORIGMARK;
    PUSHi( AvFILL(ary) + 1 );
    RETURN;
}

PP(pp_pop)
{
    dSP;
    AV * const av = (AV*)POPs;
    SV * const sv = av_pop(av);
    if (AvREAL(av))
	(void)sv_2mortal(sv);
    PUSHs(sv);
d4468 1
d4471 1
a4471 1
    SV * const sv = av_shift(av);
d4473 1
a4473 2
    if (!sv)
	RETPUSHUNDEF;
d4482 1
a4482 1
    dSP; dMARK; dORIGMARK; dTARGET;
d4510 1
a4510 1
    dSP; dMARK;
d4529 1
d4535 6
a4540 1
	    sv_setsv(TARG, (SP > MARK) ? *SP : DEFSV);
d4583 1
a4583 1
    dSP; dTARG;
d4596 1
a4596 1
    const STRLEN slen = do_utf8 ? utf8_length((U8*)s, (U8*)strend) : (strend - s);
d4605 2
a4606 1
    MAGIC *mg = (MAGIC *) NULL;
d4617 2
a4618 2
    TAINT_IF((pm->op_pmflags & PMf_LOCALE) &&
	     (pm->op_pmflags & (PMf_WHITE | PMf_SKIPWHITE)));
a4621 1
    if (pm->op_pmreplroot) {
d4623 3
a4625 1
	ary = GvAVn((GV*)PAD_SVl(INT2PTR(PADOFFSET, pm->op_pmreplroot)));
d4627 3
a4629 1
	ary = GvAVn((GV*)pm->op_pmreplroot);
a4630 1
    }
a4631 3
#ifdef USE_5005THREADS
	ary = (AV*)PAD_SVl(0);
#else
a4632 1
#endif /* USE_5005THREADS */
d4634 1
a4634 1
	ary = Nullav;
d4660 6
a4665 2
    if (pm->op_pmflags & PMf_SKIPWHITE) {
	if (pm->op_pmflags & PMf_LOCALE) {
d4674 2
a4675 3
    if (pm->op_pmflags & (PMf_MULTILINE|PMf_SINGLELINE)) {
	SAVEINT(PL_multiline);
	PL_multiline = pm->op_pmflags & PMf_MULTILINE;
d4680 1
a4680 1
    if (pm->op_pmflags & PMf_WHITE) {
d4683 17
a4699 4
	    while (m < strend &&
		   !((pm->op_pmflags & PMf_LOCALE)
		     ? isSPACE_LC(*m) : isSPACE(*m)))
		++m;
d4710 17
a4726 5
	    s = m + 1;
	    while (s < strend &&
		   ((pm->op_pmflags & PMf_LOCALE)
		    ? isSPACE_LC(*s) : isSPACE(*s)))
		++s;
d4729 1
a4729 1
    else if (rx->precomp[0] == '^' && rx->precomp[1] == '\0') {
d4745 53
a4797 6
    else if (do_utf8 == ((rx->reganch & ROPT_UTF8) != 0) &&
	     (rx->reganch & RE_USE_INTUIT) && !rx->nparens
	     && (rx->reganch & ROPT_CHECK_ALL)
	     && !(rx->reganch & ROPT_ANCH)) {
	const int tail = (rx->reganch & RE_INTUIT_TAIL);
	SV * const csv = CALLREG_INTUIT_STRING(aTHX_ rx);
d4799 2
a4800 2
	len = rx->minlen;
	if (len == 1 && !(rx->reganch & ROPT_UTF8) && !tail) {
d4824 1
a4824 1
			     csv, PL_multiline ? FBMrf_MULTILINE : 0)) )
d4847 1
a4847 1
	    rex_return = CALLREGEXEC(aTHX_ rx, (char*)s, (char*)strend, (char*)orig, 1 ,
d4860 1
a4860 1
	    m = rx->startp[0] + orig;
d4870 2
a4871 2
		    s = rx->startp[i] + orig;
		    m = rx->endp[i] + orig;
d4888 1
a4888 1
	    s = rx->endp[0] + orig;
d4961 11
a4971 16
#ifdef USE_5005THREADS
void
Perl_unlock_condpair(pTHX_ void *svv)
{
    MAGIC *mg = mg_find((SV*)svv, PERL_MAGIC_mutex);

    if (!mg)
	Perl_croak(aTHX_ "panic: unlock_condpair unlocking non-mutex");
    MUTEX_LOCK(MgMUTEXP(mg));
    if (MgOWNER(mg) != thr)
	Perl_croak(aTHX_ "panic: unlock_condpair unlocking mutex that we don't own");
    MgOWNER(mg) = 0;
    COND_SIGNAL(MgOWNERCONDP(mg));
    DEBUG_S(PerlIO_printf(Perl_debug_log, "0x%"UVxf": unlock 0x%"UVxf"\n",
			  PTR2UV(thr), PTR2UV(svv)));
    MUTEX_UNLOCK(MgMUTEXP(mg));
a4972 1
#endif /* USE_5005THREADS */
d4976 1
d4989 2
a4990 1
PP(pp_threadsv)
d4992 3
a4994 11
#ifdef USE_5005THREADS
    dSP;
    EXTEND(SP, 1);
    if (PL_op->op_private & OPpLVAL_INTRO)
	PUSHs(*save_threadsv(PL_op->op_targ));
    else
	PUSHs(THREADSV(PL_op->op_targ));
    RETURN;
#else
    DIE(aTHX_ "tried to access per-thread data in non-threaded perl");
#endif /* USE_5005THREADS */
@


1.10
log
@sync in-tree perl with 5.8.6
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, by Larry Wall and others
d38 8
d81 1
a81 1
	I32 maxarg = AvFILL((AV*)TARG) + 1;
d86 1
a86 1
		SV **svp = av_fetch((AV*)TARG, i, FALSE);
d96 2
a97 2
	SV* sv = sv_newmortal();
	I32 maxarg = AvFILL((AV*)TARG) + 1;
d124 1
a124 1
	SV* sv = Perl_hv_scalar(aTHX_ (HV*)TARG);
d147 1
a147 1
	    GV *gv = (GV*) sv_newmortal();
a172 1
		    char *name;
d177 1
a177 1
			name = SvPV(namesv, len);
d182 2
a183 2
			name = CopSTASHPV(PL_curcop);
			gv = newGVgen(name);
d187 4
a190 5
		    if (SvPVX(sv)) {
			SvOOK_off(sv);		/* backoff */
			if (SvLEN(sv))
			    Safefree(SvPVX(sv));
			SvLEN(sv)=SvCUR(sv)=0;
d192 1
a192 1
		    SvRV(sv) = (SV*)gv;
d283 1
a283 1
	sv = GvSV(gv);
d304 1
a304 1
    AV *av = (AV*)TOPs;
a334 2
	MAGIC* mg;

d336 1
a336 1
	    mg = mg_find(sv, PERL_MAGIC_regex_global);
d384 1
a384 1
	char *s = SvPVX(TOPs);
d386 1
a386 3
	    int code;
	
	    code = keyword(s + 6, SvCUR(TOPs) - 6);
d393 2
a394 1
		if (code == -KEY_chop || code == -KEY_chomp)
a411 2
		    else if (n && str[0] == ';' && seen_question)
			goto set;	/* XXXX system, exec */
d435 1
a435 1
	ret = sv_2mortal(newSVpvn(SvPVX(cv), SvCUR(cv)));
d504 1
a504 1
    SvRV(rv) = sv;
d512 2
a513 4
    SV *sv;
    char *pv;

    sv = POPs;
d521 1
a521 2
    sv = SvRV(sv);
    pv = sv_reftype(sv,TRUE);
d534 1
a534 1
	SV *ssv = POPs;
d536 1
a536 1
	char *ptr;
d540 2
a541 2
	ptr = SvPV(ssv,len);
	if (ckWARN(WARN_MISC) && len == 0)
a552 4
    GV *gv;
    SV *sv;
    SV *tmpRef;
    char *elem;
a553 1
    STRLEN n_a;
d555 5
a559 4
    sv = POPs;
    elem = SvPV(sv, n_a);
    gv = (GV*)POPs;
    tmpRef = Nullsv;
d561 48
a608 15
    switch (elem ? *elem : '\0')
    {
    case 'A':
	if (strEQ(elem, "ARRAY"))
	    tmpRef = (SV*)GvAV(gv);
	break;
    case 'C':
	if (strEQ(elem, "CODE"))
	    tmpRef = (SV*)GvCVu(gv);
	break;
    case 'F':
	if (strEQ(elem, "FILEHANDLE")) {
	    /* finally deprecated in 5.8.0 */
	    deprecate("*glob{FILEHANDLE}");
	    tmpRef = (SV*)GvIOp(gv);
a609 28
	else
	if (strEQ(elem, "FORMAT"))
	    tmpRef = (SV*)GvFORM(gv);
	break;
    case 'G':
	if (strEQ(elem, "GLOB"))
	    tmpRef = (SV*)gv;
	break;
    case 'H':
	if (strEQ(elem, "HASH"))
	    tmpRef = (SV*)GvHV(gv);
	break;
    case 'I':
	if (strEQ(elem, "IO"))
	    tmpRef = (SV*)GvIOp(gv);
	break;
    case 'N':
	if (strEQ(elem, "NAME"))
	    sv = newSVpvn(GvNAME(gv), GvNAMELEN(gv));
	break;
    case 'P':
	if (strEQ(elem, "PACKAGE"))
	    sv = newSVpv(HvNAME(GvSTASH(gv)), 0);
	break;
    case 'S':
	if (strEQ(elem, "SCALAR"))
	    tmpRef = GvSV(gv);
	break;
d652 2
a653 2
	    New(301, PL_screamfirst, 256, I32);
	    New(302, PL_screamnext, PL_maxscream, I32);
d672 1
a672 1
	ch = s[pos];
d718 1
a718 1
    PUSHTARG;
d736 1
a736 1
    PUSHi(count);
d743 1
a743 1
    register SV* sv;
a744 1
    sv = POPs;
d798 1
a798 1
	if (ckWARN(WARN_MISC) && cv_const_sv((CV*)sv))
d816 1
a816 1
	    Newz(602, gp, 1, GP);
d825 2
a826 3
	if (SvTYPE(sv) >= SVt_PV && SvPVX(sv) && SvLEN(sv)) {
	    SvOOK_off(sv);
	    Safefree(SvPVX(sv));
d845 1
a845 1
	--SvIVX(TOPs);
d863 1
a863 1
	++SvIVX(TOPs);
d885 1
a885 1
	--SvIVX(TOPs);
d909 7
a915 4
        SvIV_please(TOPm1s);
        if (SvIOK(TOPm1s)) {
            bool baseuok = SvUOK(TOPm1s);
            UV baseuv;
d917 10
a926 14
            if (baseuok) {
                baseuv = SvUVX(TOPm1s);
            } else {
                IV iv = SvIVX(TOPm1s);
                if (iv >= 0) {
                    baseuv = iv;
                    baseuok = TRUE; /* effectively it's a UV now */
                } else {
                    baseuv = -iv; /* abs, baseuok == false records sign */
                }
            }
            SvIV_please(TOPs);
            if (SvIOK(TOPs)) {
                UV power;
d928 12
a939 10
                if (SvUOK(TOPs)) {
                    power = SvUVX(TOPs);
                } else {
                    IV iv = SvIVX(TOPs);
                    if (iv >= 0) {
                        power = iv;
                    } else {
                        goto float_it; /* Can't do negative powers this way.  */
                    }
                }
a954 1
                    int n = 0;
d956 9
a964 12
                    for (; power; base *= base, n++) {
                        /* Do I look like I trust gcc with long longs here?
                           Do I hell.  */
                        UV bit = (UV)1 << (UV)n;
                        if (power & bit) {
                            result *= base;
                            /* Only bother to clear the bit if it is set.  */
                            power -= bit;
                           /* Avoid squaring base again if we're done. */
                           if (power == 0) break;
                        }
                    }
d971 6
a976 8
		    register unsigned int lowbit = 0;
		    register unsigned int diff;
		    bool odd_power = (bool)(power & 1);
		    while ((diff = (highbit - lowbit) >> 1)) {
			if (baseuv & ~((1 << (lowbit + diff)) - 1))
			    lowbit += diff;
			else 
			    highbit -= diff;
d984 7
a990 4
			register int n = 0;
			for (; power; base *= base, n++) {
			    register UV bit = (UV)1 << (UV)n;
			    if (power & bit) {
a991 2
				power -= bit;
				if (power == 0) break;
d1050 1
a1050 1
		IV aiv = SvIVX(TOPm1s);
d1061 1
a1061 1
		IV biv = SvIVX(TOPs);
d1182 1
a1182 1
                IV biv = SvIVX(TOPs);
d1203 1
a1203 1
                IV aiv = SvIVX(TOPm1s);
d1229 1
a1229 1
                UV result = left / right;
d1278 1
a1278 1
                IV biv = SvIVX(POPs);
d1397 1
a1397 1
	      UV uv = SvUV(sv);
d1411 1
a1411 1
	 NV nv = SvNV(sv);
d1485 1
a1485 1
		IV max = count * len;
d1489 1
a1489 1
		SvGROW(TARG, (count * len) + 1);
d1491 1
a1491 1
		SvCUR(TARG) *= count;
d1542 1
a1542 1
		    register IV aiv = SvIVX(TOPm1s);
d1562 1
a1562 1
		register IV biv = SvIVX(TOPs);
d1636 1
a1636 1
      IV shift = POPi;
d1653 1
a1653 1
      IV shift = POPi;
d1678 2
a1679 2
		IV aiv = SvIVX(TOPm1s);
		IV biv = SvIVX(TOPs);
d1686 2
a1687 2
		UV auv = SvUVX(TOPm1s);
		UV buv = SvUVX(TOPs);
d1695 1
a1695 3
		IV biv;
		
		biv = SvIVX(TOPs);
d1707 1
a1707 1
		IV aiv;
a1709 1
		aiv = SvIVX(TOPm1s);
d1753 3
a1755 3
		IV aiv = SvIVX(TOPm1s);
		IV biv = SvIVX(TOPs);
		
d1761 2
a1762 2
		UV auv = SvUVX(TOPm1s);
		UV buv = SvUVX(TOPs);
d1770 2
a1771 3
		IV biv;
		
		biv = SvIVX(TOPs);
d1783 1
a1783 1
		IV aiv;
a1785 1
		aiv = SvIVX(TOPm1s);
d1829 2
a1830 2
		IV aiv = SvIVX(TOPm1s);
		IV biv = SvIVX(TOPs);
d1846 2
a1847 3
		IV biv;
		
		biv = SvIVX(TOPs);
d1859 1
a1859 1
		IV aiv;
d1861 1
a1861 2
		
		aiv = SvIVX(TOPm1s);
d1905 3
a1907 3
		IV aiv = SvIVX(TOPm1s);
		IV biv = SvIVX(TOPs);
		
d1913 3
a1915 3
		UV auv = SvUVX(TOPm1s);
		UV buv = SvUVX(TOPs);
		
d1922 2
a1923 3
		IV biv;
		
		biv = SvIVX(TOPs);
d1935 1
a1935 1
		IV aiv;
d1937 1
a1937 2
		
		aiv = SvIVX(TOPm1s);
d1994 3
a1996 3
		UV buv = SvUVX(POPs);
		UV auv = SvUVX(TOPs);
		
d2055 2
a2056 2
	    bool leftuvok = SvUOK(TOPm1s);
	    bool rightuvok = SvUOK(TOPs);
d2059 2
a2060 2
		IV leftiv = SvIVX(TOPm1s);
		IV rightiv = SvIVX(TOPs);
d2069 2
a2070 2
		UV leftuv = SvUVX(TOPm1s);
		UV rightuv = SvUVX(TOPs);
d2079 1
a2079 4
		UV leftuv;
		IV rightiv;
		
		rightiv = SvIVX(TOPs);
d2084 1
a2084 1
		    leftuv = SvUVX(TOPm1s);
d2094 1
a2094 4
		IV leftiv;
		UV rightuv;
		
		leftiv = SvIVX(TOPm1s);
d2099 1
a2099 1
		    rightuv = SvUVX(TOPs);
d2147 1
a2147 1
      int cmp = (IN_LOCALE_RUNTIME
d2160 1
a2160 1
      int cmp = (IN_LOCALE_RUNTIME
d2173 1
a2173 1
      int cmp = (IN_LOCALE_RUNTIME
d2186 1
a2186 1
      int cmp = (IN_LOCALE_RUNTIME
d2219 1
a2219 1
      int cmp = (IN_LOCALE_RUNTIME
d2234 1
a2234 1
	  IV i = SvIV(left) & SvIV(right);
d2238 1
a2238 1
	  UV u = SvUV(left) & SvUV(right);
d2257 1
a2257 1
	  IV i = (USE_LEFT(left) ? SvIV(left) : 0) ^ SvIV(right);
d2261 1
a2261 1
	  UV u = (USE_LEFT(left) ? SvUV(left) : 0) ^ SvUV(right);
d2280 1
a2280 1
	  IV i = (USE_LEFT(left) ? SvIV(left) : 0) | SvIV(right);
d2284 1
a2284 1
	  UV u = (USE_LEFT(left) ? SvUV(left) : 0) | SvUV(right);
d2301 1
a2301 1
	int flags = SvFLAGS(sv);
d2333 1
a2333 1
	    char *s = SvPV(sv, len);
d2381 1
a2381 1
	  IV i = ~SvIV(sv);
d2385 1
a2385 1
	  UV u = ~SvUV(sv);
d2394 1
a2394 1
	(void)SvPV_nomg(sv,len); /* force check for uninit var */
d2409 1
a2409 1
	    UV c = utf8n_to_uvchr(tmps, send-tmps, &l, UTF8_ALLOW_ANYUV);
d2421 1
a2421 1
	      Newz(0, result, targlen + 1, U8);
d2423 1
a2423 1
		  UV c = utf8n_to_uvchr(tmps, send-tmps, &l, UTF8_ALLOW_ANYUV);
d2433 1
a2433 1
	      Newz(0, result, nchar + 1, U8);
d2435 1
a2435 1
		  U8 c = (U8)utf8n_to_uvchr(tmps, 0, &l, UTF8_ALLOW_ANY);
d2535 1
a2535 1
	           &Perl_pp_i_modulo_0;
d2686 2
a2687 4
      NV value;
      value = POPn;
      value = Perl_sin(value);
      XPUSHn(value);
d2696 2
a2697 4
      NV value;
      value = POPn;
      value = Perl_cos(value);
      XPUSHn(value);
d2766 1
a2766 2
      NV value;
      value = POPn;
d2771 1
a2771 2
      value = Perl_log(value);
      XPUSHn(value);
d2780 1
a2780 2
      NV value;
      value = POPn;
d2785 1
a2785 2
      value = Perl_sqrt(value);
      XPUSHn(value);
d2794 1
a2794 2
      NV value;
      IV iv = TOPi; /* attempt to convert to IV if possible. */
d2804 1
a2804 1
	    UV uv = TOPu;
d2809 1
a2809 1
	  value = TOPn;
d2834 1
a2834 1
      IV iv = TOPi;
d2856 1
a2856 1
	NV value = TOPn;
d2858 3
a2860 2
	  value = -value;
	SETn(value);
d2870 1
a2870 1
    char *tmps;
d2875 1
a2875 1
    SV* sv = POPs;
d2877 1
a2877 1
    tmps = (SvPVx(sv, len));
d2881 1
a2881 1
         SV* tsv = sv_2mortal(newSVsv(sv));
d2885 1
a2885 1
	 tmps = SvPVX(tsv);
d2887 1
a2887 1
    result_uv = grok_hex (tmps, &len, &flags, &result_nv);
d2900 1
a2900 1
    char *tmps;
d2905 1
a2905 1
    SV* sv = POPs;
d2907 1
a2907 1
    tmps = (SvPVx(sv, len));
d2911 1
a2911 1
         SV* tsv = sv_2mortal(newSVsv(sv));
d2915 1
a2915 1
	 tmps = SvPVX(tsv);
d2922 1
a2922 1
        result_uv = grok_hex (tmps, &len, &flags, &result_nv);
d2924 1
a2924 1
        result_uv = grok_bin (tmps, &len, &flags, &result_nv);
d2926 1
a2926 1
        result_uv = grok_oct (tmps, &len, &flags, &result_nv);
d2961 3
a2963 3
    I32 lvalue = PL_op->op_flags & OPf_MOD || LVRET;
    char *tmps;
    I32 arybase = PL_curcop->cop_arybase;
d2965 1
a2965 1
    char *repl = 0;
d2967 1
a2967 1
    int num_args = PL_op->op_private & 7;
d2976 1
a2976 1
	    repl = SvPV(repl_sv, repl_len);
d2992 1
a2992 1
    tmps = SvPV(sv, curlen);
d3044 2
a3045 2
	I32 upos = pos;
	I32 urem = rem;
d3074 1
a3074 1
		repl = SvPV(repl_sv_copy, repl_len);
d3077 1
a3077 1
	    sv_insert(sv, pos, rem, repl, repl_len);
d3086 1
a3086 2
		    STRLEN n_a;
		    SvPV_force(sv,n_a);
d3122 4
a3125 4
    register IV size   = POPi;
    register IV offset = POPi;
    register SV *src = POPs;
    I32 lvalue = PL_op->op_flags & OPf_MOD || LVRET;
d3155 1
d3158 2
a3159 2
    char *tmps;
    char *tmps2;
d3161 3
a3163 1
    I32 arybase = PL_curcop->cop_arybase;
d3171 23
a3193 2
    tmps = SvPV(big, biglen);
    if (offset > 0 && DO_UTF8(big))
d3195 1
d3205 1
a3205 1
    if (retval > 0 && DO_UTF8(big))
d3207 2
d3218 1
d3223 5
a3227 3
    char *tmps;
    char *tmps2;
    I32 arybase = PL_curcop->cop_arybase;
d3233 25
a3257 2
    tmps2 = SvPV(little, llen);
    tmps = SvPV(big, blen);
d3261 1
a3261 1
	if (offset > 0 && DO_UTF8(big))
d3274 1
a3274 1
    if (retval > 0 && DO_UTF8(big))
d3276 2
d3299 1
a3299 1
    U8 *s = (U8*)SvPVx(argsv, len);
d3309 1
a3309 1
	   utf8n_to_uvchr(s, UTF8_MAXLEN, 0, UTF8_ALLOW_ANYUV) :
d3326 1
a3326 1
	SvCUR_set(TARG, tmps - SvPVX(TARG));
d3360 1
a3361 1
#ifdef HAS_CRYPT
a3362 1
    STRLEN n_a;
d3364 1
a3364 1
    char *tmps = SvPV(left, len);
d3370 1
a3370 1
         SV* tsv = sv_2mortal(newSVsv(left));
d3374 1
a3374 1
	 tmps = SvPVX(tsv);
d3395 1
a3395 1
    sv_setpv(TARG, fcrypt(tmps, SvPV(right, n_a)));
d3397 1
a3397 1
    sv_setpv(TARG, PerlProc_crypt(tmps, SvPV(right, n_a)));
d3411 1
a3411 1
    register U8 *s;
d3416 1
a3416 1
	(s = (U8*)SvPV_nomg(sv, slen)) && slen &&
d3418 1
a3418 1
	U8 tmpbuf[UTF8_MAXLEN_UCLC+1];
d3422 2
a3423 3
	utf8_to_uvchr(s, &ulen);
	toTITLE_utf8(s, tmpbuf, &tculen);
	utf8_to_uvchr(tmpbuf, 0);
d3425 1
a3425 1
	if (!SvPADTMP(sv) || SvREADONLY(sv)) {
d3446 1
d3454 2
a3455 2
	s = (U8*)SvPV_force_nomg(sv, slen);
	if (*s) {
d3459 1
a3459 1
		*s = toUPPER_LC(*s);
d3462 1
a3462 1
		*s = toUPPER(*s);
d3473 1
a3473 1
    register U8 *s;
d3478 1
a3478 1
	(s = (U8*)SvPV_nomg(sv, slen)) && slen &&
d3481 2
a3482 7
	U8 tmpbuf[UTF8_MAXLEN_UCLC+1];
	U8 *tend;
	UV uv;

	toLOWER_utf8(s, tmpbuf, &ulen);
	uv = utf8_to_uvchr(tmpbuf, 0);
	tend = uvchr_to_utf8(tmpbuf, uv);
d3484 4
a3487 1
	if (!SvPADTMP(sv) || (STRLEN)(tend - tmpbuf) != ulen || SvREADONLY(sv)) {
d3489 1
a3489 1
	    sv_setpvn(TARG, (char*)tmpbuf, tend - tmpbuf);
d3501 1
d3509 2
a3510 2
	s = (U8*)SvPV_force_nomg(sv, slen);
	if (*s) {
d3514 1
a3514 1
		*s = toLOWER_LC(*s);
d3517 1
a3517 1
		*s = toLOWER(*s);
a3527 1
    register U8 *s;
d3535 3
a3537 2
	U8 *send;
	U8 tmpbuf[UTF8_MAXLEN_UCLC+1];
d3539 1
a3539 1
	s = (U8*)SvPV_nomg(sv,len);
d3546 1
a3546 1
	    STRLEN nchar = utf8_length(s, s + len);
d3549 1
a3549 1
	    SvGROW(TARG, (nchar * UTF8_MAXLEN_UCLC) + 1);
d3554 15
a3568 1
		toUPPER_utf8(s, tmpbuf, &ulen);
d3571 1
a3571 1
		s += UTF8SKIP(s);
d3575 1
a3575 1
	    SvCUR_set(TARG, d - (U8*)SvPVX(TARG));
d3580 1
d3590 1
a3590 1
	    register U8 *send = s + len;
a3611 1
    register U8 *s;
d3617 1
d3620 2
a3621 2
	U8 *send;
	U8 tmpbuf[UTF8_MAXLEN_UCLC+1];
d3623 1
a3623 1
	s = (U8*)SvPV_nomg(sv,len);
d3630 1
a3630 1
	    STRLEN nchar = utf8_length(s, s + len);
d3633 1
a3633 1
	    SvGROW(TARG, (nchar * UTF8_MAXLEN_UCLC) + 1);
d3638 4
a3641 2
		UV uv = toLOWER_utf8(s, tmpbuf, &ulen);
#define GREEK_CAPITAL_LETTER_SIGMA 0x03A3 /* Unicode */
d3655 3
a3657 1
		      * See lib/unicore/SpecCase.txt.
d3660 12
d3674 1
a3674 1
		s += UTF8SKIP(s);
d3678 1
a3678 1
	    SvCUR_set(TARG, d - (U8*)SvPVX(TARG));
d3683 1
d3694 1
a3694 1
	    register U8 *send = s + len;
d3715 1
a3715 1
    SV *sv = TOPs;
d3717 1
a3717 2
    register char *s = SvPV(sv,len);
    register char *d;
d3721 1
d3752 1
a3752 1
	SvCUR_set(TARG, d - SvPVX(TARG));
d3768 2
a3769 5
    register SV** svp;
    register AV* av = (AV*)POPs;
    register I32 lval = (PL_op->op_flags & OPf_MOD || LVRET);
    I32 arybase = PL_curcop->cop_arybase;
    I32 elem;
d3772 1
d3774 1
d3777 1
a3777 1
		elem = SvIVx(*svp);
d3785 2
a3786 1
	    elem = SvIVx(*MARK);
d3813 1
a3813 1
    HV *hash = (HV*)POPs;
d3815 1
a3815 1
    I32 gimme = GIMME_V;
d3825 1
a3825 1
        SV* sv = hv_iterkeysv(entry);
d3856 2
a3857 4
    I32 gimme = GIMME_V;
    I32 discard = (gimme == G_VOID) ? G_DISCARD : 0;
    SV *sv;
    HV *hv;
d3861 2
a3862 3
	U32 hvtype;
	hv = (HV*)POPs;
	hvtype = SvTYPE(hv);
d3865 1
a3865 1
		sv = hv_delete_ent(hv, *MARK, discard, 0);
d3872 1
a3872 1
		    sv = av_delete((AV*)hv, SvIV(*MARK), discard);
d3878 1
a3878 1
		    sv = avhv_delete_ent((AV*)hv, *MARK, discard, 0);
d3898 2
a3899 1
	hv = (HV*)POPs;
a3925 1
	CV *cv;
d3927 1
a3927 1
	cv = sv_2cv(sv, &hv, &gv, FALSE);
d3957 2
a3958 2
    register HV *hv = (HV*)POPs;
    register I32 lval = (PL_op->op_flags & OPf_MOD || LVRET);
d3960 1
a3960 1
    bool localizing = PL_op->op_private & OPpLVAL_INTRO ? TRUE : FALSE;
d4001 1
a4001 2
		    STRLEN n_a;
		    DIE(aTHX_ PL_no_helem, SvPV(keysv, n_a));
d4008 1
a4008 1
			char *key = SvPV(keysv, keylen);
d4042 6
a4047 7
    SV **lastrelem = PL_stack_sp;
    SV **lastlelem = PL_stack_base + POPMARK;
    SV **firstlelem = PL_stack_base + POPMARK + 1;
    register SV **firstrelem = lastlelem + 1;
    I32 arybase = PL_curcop->cop_arybase;
    I32 lval = PL_op->op_flags & OPf_MOD;
    I32 is_something_there = lval;
d4049 1
a4049 1
    register I32 max = lastrelem - lastlelem;
a4050 1
    register I32 ix;
d4053 1
a4053 1
	ix = SvIVx(*lastlelem);
d4072 1
a4072 1
	ix = SvIVx(*lelem);
d4095 2
a4096 2
    I32 items = SP - MARK;
    SV *av = sv_2mortal((SV*)av_make(items, MARK+1));
d4105 1
a4105 1
    HV* hv = (HV*)sv_2mortal((SV*)newHV());
d4108 2
a4109 2
	SV* key = *++MARK;
	SV *val = NEWSV(46, 0);
d4134 1
a4134 1
    MAGIC *mg;
d4136 1
a4136 1
    if ((mg = SvTIED_mg((SV*)ary, PERL_MAGIC_tied))) {
d4194 2
a4195 3
        SV *h = *dst;
	*dst = NEWSV(46, 0);
	sv_setsv(*dst++, h);
d4200 1
a4200 1
	    New(451, tmparyval, newlen, SV*);	/* so remember insertion */
d4237 1
a4237 1
	    SvPVX(ary) = (char*)(AvARRAY(ary) - diff); /* diff is negative */
d4260 1
a4260 1
	    New(452, tmparyval, length, SV*);	/* so remember deletion */
d4274 1
a4274 1
		SvPVX(ary) = (char*)(AvARRAY(ary) - diff);/* diff is positive */
d4332 1
a4332 2
    register SV *sv = &PL_sv_undef;
    MAGIC *mg;
d4334 1
a4334 1
    if ((mg = SvTIED_mg((SV*)ary, PERL_MAGIC_tied))) {
d4346 1
a4346 1
	    sv = NEWSV(51, 0);
d4360 2
a4361 2
    AV *av = (AV*)POPs;
    SV *sv = av_pop(av);
d4371 2
a4372 2
    AV *av = (AV*)POPs;
    SV *sv = av_shift(av);
d4386 1
a4386 3
    register SV *sv;
    register I32 i = 0;
    MAGIC *mg;
d4388 1
a4388 1
    if ((mg = SvTIED_mg((SV*)ary, PERL_MAGIC_tied))) {
d4398 1
d4401 1
a4401 2
	    sv = NEWSV(27, 0);
	    sv_setsv(sv, *++MARK);
d4413 1
a4413 2
    register SV *tmp;
    SV **oldsp = SP;
d4418 1
a4418 1
	    tmp = *MARK;
d4441 1
a4441 1
		U8* send = (U8*)(s + len);
d4482 1
a4482 1
    SV *sv = POPs;
d4484 3
a4486 3
    register char *s = SvPV(sv, len);
    bool do_utf8 = DO_UTF8(sv);
    char *strend = s + len;
d4490 1
a4490 1
    register char *m;
d4492 1
a4492 1
    STRLEN slen = do_utf8 ? utf8_length((U8*)s, (U8*)strend) : (strend - s);
d4494 2
a4495 3
    I32 i;
    char *orig;
    I32 origlimit = limit;
d4498 2
a4499 2
    I32 gimme = GIMME_V;
    I32 oldsave = PL_savestack_ix;
d4544 1
d4584 1
a4584 2
	    dstr = NEWSV(30, m-s);
	    sv_setpvn(dstr, s, m-s);
d4598 1
a4598 1
    else if (strEQ("^", rx->precomp)) {
d4600 2
a4601 2
	    /*SUPPRESS 530*/
	    for (m = s; m < strend && *m != '\n'; m++) ;
d4605 1
a4605 2
	    dstr = NEWSV(30, m-s);
	    sv_setpvn(dstr, s, m-s);
d4618 2
a4619 2
	int tail = (rx->reganch & RE_INTUIT_TAIL);
	SV *csv = CALLREG_INTUIT_STRING(aTHX_ rx);
d4623 1
a4623 2
	    STRLEN n_a;
	    char c = *SvPV(csv, n_a);
d4625 2
a4626 2
		/*SUPPRESS 530*/
		for (m = s; m < strend && *m != c; m++) ;
d4629 1
a4629 2
		dstr = NEWSV(30, m-s);
		sv_setpvn(dstr, s, m-s);
a4643 1
#ifndef lint
a4646 1
#endif
d4648 1
a4648 2
		dstr = NEWSV(31, m-s);
		sv_setpvn(dstr, s, m-s);
d4667 1
d4669 2
a4670 1
	    i = CALLREGEXEC(aTHX_ rx, s, strend, orig, 1 , sv, NULL, 0);
d4672 1
a4672 1
	    if (i == 0)
d4683 1
a4683 2
	    dstr = NEWSV(32, m-s);
	    sv_setpvn(dstr, s, m-s);
d4690 1
d4699 1
a4699 2
			dstr = NEWSV(33, m-s);
			sv_setpvn(dstr, s, m-s);
d4720 2
a4721 3
        STRLEN l = strend - s;
	dstr = NEWSV(34, l);
	sv_setpvn(dstr, s, l);
d4762 1
d4830 10
@


1.9
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d16 7
d162 2
d181 1
a181 1
			(void)SvOOK_off(sv);		/* backoff */
d828 1
a828 1
	    (void)SvOOK_off(sv);
d833 1
a833 1
	(void)SvOK_off(sv);
d1738 5
a1742 5
        if (SvROK(TOPs) && SvROK(TOPm1s)) {
            SP--;
            SETs(boolSV(SvRV(TOPs) < SvRV(TOPp1s)));
            RETURN;
        }
d1816 1
a1816 1
        if (SvROK(TOPs) && SvROK(TOPm1s)) {
d1894 1
a1894 1
        if (SvROK(TOPs) && SvROK(TOPm1s)) {
d1972 1
a1972 1
        if (SvROK(TOPs) && SvROK(TOPm1s)) {
d1989 1
a1989 1
    if (SvROK(TOPs) && SvROK(TOPm1s)) {
d2058 1
a2058 1
    if (SvROK(TOPs) && SvROK(TOPm1s)) {
d3133 1
a3133 1
		(void)SvOK_off(TARG);
d3748 1
a3748 1
	*++MARK = *SP;
d3968 1
a3968 1
	*++MARK = *SP;
d4144 7
d4207 1
a4207 5
	    for (src = tmparyval, dst = AvARRAY(ary) + offset;
	      newlen; newlen--) {
		*dst = NEWSV(46, 0);
		sv_setsv(*dst++, *src++);
	    }
d4246 2
a4247 3
	for (src = MARK, dst = AvARRAY(ary) + offset; newlen; newlen--) {
	    *dst = NEWSV(46, 0);
	    sv_setsv(*dst++, *src++);
d4249 1
a4455 1
    AV *oldstack = PL_curstack;
d4508 1
a4508 2
	    SWITCHSTACK(PL_curstack, ary);
	    PL_curstackinfo->si_stack = ary;
a4676 1
    LEAVE_SCOPE(oldsave);
d4702 3
a4706 2
	    SWITCHSTACK(ary, oldstack);
	    PL_curstackinfo->si_stack = oldstack;
@


1.8
log
@merge local changes into perl-5.8.3
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, by Larry Wall and others
d171 6
d1389 28
a1416 1
    register IV count = POPi;
d1421 2
d1425 4
d1473 2
d1483 4
d2407 1
d2455 1
d2822 3
a2824 1
      if (SvIOK(TOPs)) {
d2858 3
a2860 1
      if (SvIOK(TOPs)) {
d3070 13
a3118 2
	    if (SvREFCNT(TARG) > 1)	/* don't share the TARG (#20933) */
		TARG = sv_newmortal();
d3829 4
a3832 1
	    *++MARK = *SP;
d4689 1
a4689 1
	    SP--;
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d109 1
a109 6
	SV* sv = sv_newmortal();
	if (HvFILL((HV*)TARG))
	    Perl_sv_setpvf(aTHX_ sv, "%ld/%ld",
		      (long)HvFILL((HV*)TARG), (long)HvMAX((HV*)TARG) + 1);
	else
	    sv_setiv(sv, 0);
d2794 1
a2794 2
		/* This is maint, and we don't have Perl_ceil in perl.h  */
		  SETn(-Perl_floor(-value));
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d3 2
a4 1
 *    Copyright (c) 1991-2002, Larry Wall
a22 2
/* variations on pp_null */

d31 2
d51 1
d53 1
a53 1
	SAVECLEARSV(PL_curpad[PL_op->op_targ]);
d64 2
a65 1
    if (GIMME == G_ARRAY) {
d80 1
a80 1
    else {
d96 1
a96 1
	SAVECLEARSV(PL_curpad[PL_op->op_targ]);
d165 1
a165 1
			SV *namesv = PL_curpad[cUNOP->op_targ];
d215 1
a230 1
	GV *gv = (GV*)sv;
d233 1
d270 8
a277 2
	if (PL_op->op_private & OPpLVAL_INTRO)
	    sv = save_scalar((GV*)TOPs);
d433 1
a433 1
    CV* cv = (CV*)PL_curpad[PL_op->op_targ];
d862 1
d892 5
a896 1
    dSP; dATARGET; tryAMAGICbin(pow,opASSIGN);
d898 3
a900 8
    /* ** is implemented with pow. pow is floating point. Perl programmers
       write 2 ** 31 and expect it to be 2147483648
       pow never made any guarantee to deliver a result to 53 (or whatever)
       bits of accuracy. Which is unfortunate, as perl programmers expect it
       to, and on some platforms (eg Irix with long doubles) it doesn't in
       a very visible case. (2 ** 31, which a regression test uses)
       So we'll implement power-of-2 ** +ve integer with multiplies, to avoid
       these problems.  */
d932 4
a935 2
                /* now we have integer ** positive integer.
                   foo & (foo - 1) is zero only for a power of 2.  */
d937 1
a937 1
                    /* We are raising power-of-2 to postive integer.
a948 14
                    /* The logic is this.
                       x ** n === x ** m1 * x ** m2 where n = m1 + m2
                       so as 42 is 32 + 8 + 2
                       x ** 42 can be written as
                       x ** 32 * x ** 8 * x ** 2
                       I can calculate x ** 2, x ** 4, x ** 8 etc trivially:
                       x ** 2n is x ** n * x ** n
                       So I loop round, squaring x each time
                       (x, x ** 2, x ** 4, x ** 8) and multiply the result
                       by the x-value whenever that bit is set in the power.
                       To finish as soon as possible I zero bits in the power
                       when I've done them, so that power becomes zero when
                       I clear the last bit (no more to do), and the loop
                       terminates.  */
d956 1
a956 1
                            power &= ~bit;
d963 1
d965 44
a1008 3
                }
            }
        }
d1010 1
a1010 1
      float_it:
d1013 7
a1019 3
        dPOPTOPnnrl;
        SETn( Perl_pow( left, right) );
        RETURN;
d1243 1
a1243 1
            } /* else (abs(result) < 1.0) or (both UVs in range for NV) */
d2464 32
d2498 36
a2533 8
    dSP; dATARGET; tryAMAGICbin(modulo,opASSIGN);
    {
      dPOPTOPiirl;
      if (!right)
	DIE(aTHX_ "Illegal modulus zero");
      SETi( left % right );
      RETURN;
    }
a2724 81
STATIC U32
S_seed(pTHX)
{
    /*
     * This is really just a quick hack which grabs various garbage
     * values.  It really should be a real hash algorithm which
     * spreads the effect of every input bit onto every output bit,
     * if someone who knows about such things would bother to write it.
     * Might be a good idea to add that function to CORE as well.
     * No numbers below come from careful analysis or anything here,
     * except they are primes and SEED_C1 > 1E6 to get a full-width
     * value from (tv_sec * SEED_C1 + tv_usec).  The multipliers should
     * probably be bigger too.
     */
#if RANDBITS > 16
#  define SEED_C1	1000003
#define   SEED_C4	73819
#else
#  define SEED_C1	25747
#define   SEED_C4	20639
#endif
#define   SEED_C2	3
#define   SEED_C3	269
#define   SEED_C5	26107

#ifndef PERL_NO_DEV_RANDOM
    int fd;
#endif
    U32 u;
#ifdef VMS
#  include <starlet.h>
    /* when[] = (low 32 bits, high 32 bits) of time since epoch
     * in 100-ns units, typically incremented ever 10 ms.        */
    unsigned int when[2];
#else
#  ifdef HAS_GETTIMEOFDAY
    struct timeval when;
#  else
    Time_t when;
#  endif
#endif

/* This test is an escape hatch, this symbol isn't set by Configure. */
#ifndef PERL_NO_DEV_RANDOM
#ifndef PERL_RANDOM_DEVICE
   /* /dev/random isn't used by default because reads from it will block
    * if there isn't enough entropy available.  You can compile with
    * PERL_RANDOM_DEVICE to it if you'd prefer Perl to block until there
    * is enough real entropy to fill the seed. */
#  define PERL_RANDOM_DEVICE "/dev/urandom"
#endif
    fd = PerlLIO_open(PERL_RANDOM_DEVICE, 0);
    if (fd != -1) {
    	if (PerlLIO_read(fd, &u, sizeof u) != sizeof u)
	    u = 0;
	PerlLIO_close(fd);
	if (u)
	    return u;
    }
#endif

#ifdef VMS
    _ckvmssts(sys$gettim(when));
    u = (U32)SEED_C1 * when[0] + (U32)SEED_C2 * when[1];
#else
#  ifdef HAS_GETTIMEOFDAY
    PerlProc_gettimeofday(&when,NULL);
    u = (U32)SEED_C1 * when.tv_sec + (U32)SEED_C2 * when.tv_usec;
#  else
    (void)time(&when);
    u = (U32)SEED_C1 * when;
#  endif
#endif
    u += SEED_C3 * (U32)PerlProc_getpid();
    u += SEED_C4 * (U32)PTR2UV(PL_stack_sp);
#ifndef PLAN9           /* XXX Plan9 assembler chokes on this; fix needed  */
    u += SEED_C5 * (U32)PTR2UV(&when);
#endif
    return u;
}

a2768 22
/*
 * There are strange code-generation bugs caused on sparc64 by gcc-2.95.2.
 * These need to be revisited when a newer toolchain becomes available.
 */
#if defined(__sparc64__) && defined(__GNUC__)
#   if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 96)
#       undef  SPARC64_MODF_WORKAROUND
#       define SPARC64_MODF_WORKAROUND 1
#   endif
#endif

#if defined(SPARC64_MODF_WORKAROUND)
static NV
sparc64_workaround_modf(NV theVal, NV *theIntRes)
{
    NV res, ret;
    ret = Perl_modf(theVal, &res);
    *theIntRes = res;
    return ret;
}
#endif

d2792 1
a2792 21
#if defined(SPARC64_MODF_WORKAROUND)
		(void)sparc64_workaround_modf(value, &value);
#else
#   if defined(HAS_MODFL) || defined(LONG_DOUBLE_EQUALS_DOUBLE)
#       ifdef HAS_MODFL_POW32_BUG
/* some versions of glibc split (i + d) into (i-1, d+1) for 2^32 <= i < 2^64 */
                {
                    NV offset = Perl_modf(value, &value);
                    (void)Perl_modf(offset, &offset);
                    value += offset;
                }
#       else
		  (void)Perl_modf(value, &value);
#       endif
#   else
		  double tmp = (double)value;
		  (void)Perl_modf(tmp, &tmp);
		  value = (NV)tmp;
#   endif
#endif
		  SETn(value);
d2799 2
a2800 18
#if defined(HAS_MODFL) || defined(LONG_DOUBLE_EQUALS_DOUBLE)
#   ifdef HAS_MODFL_POW32_BUG
/* some versions of glibc split (i + d) into (i-1, d+1) for 2^32 <= i < 2^64 */
                 {
                     NV offset = Perl_modf(-value, &value);
                     (void)Perl_modf(offset, &offset);
                     value += offset;
                 }
#   else
		  (void)Perl_modf(-value, &value);
#   endif
		  value = -value;
#else
		  double tmp = (double)value;
		  (void)Perl_modf(-tmp, &tmp);
		  value = -(NV)tmp;
#endif
		  SETn(value);
d3061 2
d3067 2
d3095 2
d3251 1
a3251 1
    if (PL_encoding)
d3253 12
d3288 18
d3326 4
a3329 1
    if (DO_UTF8(sv)) {
a3333 1
	s = (U8*)SvPV(sv, slen);
a3334 1

d3340 7
d3348 2
a3349 1
	    sv_catpvn(TARG, (char*)(s + ulen), slen - ulen);
d3354 1
a3354 1
	    s = (U8*)SvPV_force(sv, slen);
d3362 1
a3362 1
	    sv_setsv(TARG, sv);
d3366 1
a3366 1
	s = (U8*)SvPV_force(sv, slen);
d3377 1
a3377 2
    if (SvSMAGICAL(sv))
	mg_set(sv);
d3388 4
a3391 1
    if (DO_UTF8(sv) && (s = (U8*)SvPV(sv, slen)) && slen && UTF8_IS_START(*s)) {
a3398 1
	
d3404 2
a3405 1
	    sv_catpvn(TARG, (char*)(s + ulen), slen - ulen);
d3410 1
a3410 1
	    s = (U8*)SvPV_force(sv, slen);
d3418 1
a3418 1
	    sv_setsv(TARG, sv);
d3422 1
a3422 1
	s = (U8*)SvPV_force(sv, slen);
d3433 1
a3433 2
    if (SvSMAGICAL(sv))
	mg_set(sv);
d3444 1
d3452 1
a3452 1
	s = (U8*)SvPV(sv,len);
d3482 1
a3482 1
	    sv_setsv(TARG, sv);
d3486 1
a3486 1
	s = (U8*)SvPV_force(sv, len);
d3502 1
a3502 2
    if (SvSMAGICAL(sv))
	mg_set(sv);
d3513 1
d3521 1
a3521 1
	s = (U8*)SvPV(sv,len);
d3568 1
a3568 1
	    sv_setsv(TARG, sv);
d3573 1
a3573 1
	s = (U8*)SvPV_force(sv, len);
d3589 1
a3589 2
    if (SvSMAGICAL(sv))
	mg_set(sv);
d4403 1
a4403 1
    PL_reg_match_utf8 = do_utf8;
d4407 1
a4407 1
	ary = GvAVn((GV*)PL_curpad[INT2PTR(PADOFFSET, pm->op_pmreplroot)]);
d4414 1
a4414 1
	ary = (AV*)PL_curpad[0];
d4439 1
d4560 1
a4560 6
	while (s < strend && --limit
/*	       && (!rx->check_substr
		   || ((s = CALLREG_INTUIT_START(aTHX_ rx, sv, s, strend,
						 0, NULL))))
*/	       && CALLREGEXEC(aTHX_ rx, s, strend, orig,
			      1 /* minend */, sv, NULL, 0))
d4562 5
d4626 6
a4631 2
	while (iters > 0 && (!TOPs || !SvANY(TOPs) || SvCUR(TOPs) == 0))
	    iters--, SP--;
d4637 1
d4671 4
a4674 6
    if (iters || !pm->op_pmreplroot) {
	GETTARGET;
	PUSHi(iters);
	RETURN;
    }
    RETPUSHUNDEF;
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2001, Larry Wall
d18 1
d20 1
a20 63
/*
 * The compiler on Concurrent CX/UX systems has a subtle bug which only
 * seems to show up when compiling pp.c - it generates the wrong double
 * precision constant value for (double)UV_MAX when used inline in the body
 * of the code below, so this makes a static variable up front (which the
 * compiler seems to get correct) and uses it in place of UV_MAX below.
 */
#ifdef CXUX_BROKEN_CONSTANT_CONVERT
static double UV_MAX_cxux = ((double)UV_MAX);
#endif

/*
 * Offset for integer pack/unpack.
 *
 * On architectures where I16 and I32 aren't really 16 and 32 bits,
 * which for now are all Crays, pack and unpack have to play games.
 */

/*
 * These values are required for portability of pack() output.
 * If they're not right on your machine, then pack() and unpack()
 * wouldn't work right anyway; you'll need to apply the Cray hack.
 * (I'd like to check them with #if, but you can't use sizeof() in
 * the preprocessor.)  --???
 */
/*
    The appropriate SHORTSIZE, INTSIZE, LONGSIZE, and LONGLONGSIZE
    defines are now in config.h.  --Andy Dougherty  April 1998
 */
#define SIZE16 2
#define SIZE32 4

/* CROSSCOMPILE and MULTIARCH are going to affect pp_pack() and pp_unpack().
   --jhi Feb 1999 */

#if SHORTSIZE != SIZE16 || LONGSIZE != SIZE32
#   define PERL_NATINT_PACK
#endif

#if LONGSIZE > 4 && defined(_CRAY)
#  if BYTEORDER == 0x12345678
#    define OFF16(p)	(char*)(p)
#    define OFF32(p)	(char*)(p)
#  else
#    if BYTEORDER == 0x87654321
#      define OFF16(p)	((char*)(p) + (sizeof(U16) - SIZE16))
#      define OFF32(p)	((char*)(p) + (sizeof(U32) - SIZE32))
#    else
       }}}} bad cray byte order
#    endif
#  endif
#  define COPY16(s,p)  (*(p) = 0, Copy(s, OFF16(p), SIZE16, char))
#  define COPY32(s,p)  (*(p) = 0, Copy(s, OFF32(p), SIZE32, char))
#  define COPYNN(s,p,n) (*(p) = 0, Copy(s, (char *)(p), n, char))
#  define CAT16(sv,p)  sv_catpvn(sv, OFF16(p), SIZE16)
#  define CAT32(sv,p)  sv_catpvn(sv, OFF32(p), SIZE32)
#else
#  define COPY16(s,p)  Copy(s, p, SIZE16, char)
#  define COPY32(s,p)  Copy(s, p, SIZE32, char)
#  define COPYNN(s,p,n) Copy(s, (char *)(p), n, char)
#  define CAT16(sv,p)  sv_catpvn(sv, (char*)(p), SIZE16)
#  define CAT32(sv,p)  sv_catpvn(sv, (char*)(p), SIZE32)
#endif
d67 1
a67 1
	    for (i=0; i < maxarg; i++) {
d154 1
a154 1
		/* If this is a 'my' scalar and flag is set then vivify 
d156 1
a156 1
		 */ 
d171 2
a172 1
		    sv_upgrade(sv, SVt_RV);
d283 1
a283 1
	sv_magic(sv, (SV*)av, '#', Nullch, 0);
d296 1
a296 1
	    sv_magic(TARG, Nullsv, '.', Nullch, 0);
d312 1
a312 1
	    mg = mg_find(sv, 'g');
d363 1
a363 1
	    
d371 2
d385 1
a385 1
		    if (oa & OA_OPTIONAL) {
d389 1
a389 1
		    else if (n && str[0] == ';' && seen_question) 
d391 5
a395 2
		    if ((oa & (OA_OPTIONAL - 1)) >= OA_AVREF 
			&& (oa & (OA_OPTIONAL - 1)) <= OA_HVREF) {
a397 1
		    /* What to do with R ((un)tie, tied, (sys)read, recv)? */
d475 2
a476 2
    else if (SvPADTMP(sv))
	sv = newSVsv(sv);
d518 5
a522 1
	char *ptr = SvPV(ssv,len);
d524 1
a524 1
	    Perl_warner(aTHX_ WARN_MISC, 
d541 1
a541 1
 
d558 3
a560 1
	if (strEQ(elem, "FILEHANDLE")) /* XXX deprecate in 5.005 */
d562 4
d662 2
a663 1
    sv_magic(sv, Nullsv, 'g', Nullch, 0);	/* piggyback on m//g magic */
d731 2
a732 1
	if (AvMAX(sv) >= 0 || SvGMAGICAL(sv) || (SvRMAGICAL(sv) && mg_find(sv,'P')))
d736 2
a737 1
	if (HvARRAY(sv) || SvGMAGICAL(sv) || (SvRMAGICAL(sv) && mg_find(sv,'P')))
d781 1
a781 1
	    Perl_warner(aTHX_ WARN_MISC, "Constant subroutine %s undefined",
d823 1
a823 1
    if (SvREADONLY(TOPs) || SvTYPE(TOPs) > SVt_PVLV)
d825 2
a826 2
    if (SvIOK_notUV(TOPs) && !SvNOK(TOPs) && !SvPOK(TOPs) &&
    	SvIVX(TOPs) != IV_MIN)
d840 1
a840 1
    if (SvREADONLY(TOPs) || SvTYPE(TOPs) > SVt_PVLV)
d843 2
a844 2
    if (SvIOK_notUV(TOPs) && !SvNOK(TOPs) && !SvPOK(TOPs) &&
    	SvIVX(TOPs) != IV_MAX)
d861 1
a861 1
    if (SvREADONLY(TOPs) || SvTYPE(TOPs) > SVt_PVLV)
d864 2
a865 2
    if (SvIOK_notUV(TOPs) && !SvNOK(TOPs) && !SvPOK(TOPs) &&
    	SvIVX(TOPs) != IV_MIN)
d882 90
d973 3
a975 3
      dPOPTOPnnrl;
      SETn( Perl_pow( left, right) );
      RETURN;
d982 108
d1100 10
a1109 5
    {
      dPOPPOPnnrl;
      NV value;
      if (right == 0.0)
	DIE(aTHX_ "Illegal division by zero");
d1111 2
a1112 12
      /* insure that 20./5. == 4. */
      {
	IV k;
	if ((NV)I_V(left)  == left &&
	    (NV)I_V(right) == right &&
	    (k = I_V(left)/I_V(right))*I_V(right) == I_V(left)) {
	    value = k;
	}
	else {
	    value = left / right;
	}
      }
d1114 5
a1118 1
      value = left / right;
d1120 89
a1208 2
      PUSHn( value );
      RETURN;
d1216 25
a1240 13
	UV left;
	UV right;
	bool left_neg;
	bool right_neg;
	bool use_double = 0;
	NV dright;
	NV dleft;

	if (SvIOK_notUV(TOPs) && !SvNOK(TOPs) && !SvPOK(TOPs)) {
	    IV i = SvIVX(POPs);
	    right = (right_neg = (i < 0)) ? -i : i;
	}
	else {
a1241 1
	    use_double = 1;
d1245 6
d1253 20
a1272 4
	if (!use_double && SvIOK_notUV(TOPs) && !SvNOK(TOPs) && !SvPOK(TOPs)) {
	    IV i = SvIVX(POPs);
	    left = (left_neg = (i < 0)) ? -i : i;
	}
a1274 4
	    if (!use_double) {
		use_double = 1;
		dright = right;
	    }
a1277 1
	}
d1279 23
a1304 22
#if 1
/* Somehow U_V is pessimized even if CASTFLAGS is 0 */
#  if CASTFLAGS & 2
#    define CAST_D2UV(d) U_V(d)
#  else
#    define CAST_D2UV(d) ((UV)(d))
#  endif
	    /* Tried to do this only in the case DOUBLESIZE <= UV_SIZE,
	     * or, in other words, precision of UV more than of NV.
	     * But in fact the approach below turned out to be an
	     * optimization - floor() may be slow */
	    if (dright <= UV_MAX && dleft <= UV_MAX) {
		right = CAST_D2UV(dright);
		left  = CAST_D2UV(dleft);
		goto do_uv;
	    }
#endif

	    /* Backward-compatibility clause: */
	    dright = Perl_floor(dright + 0.5);
	    dleft  = Perl_floor(dleft + 0.5);

a1317 1
	do_uv:
d1354 27
a1380 2
		if (*SP)
		    SvTEMP_off((*SP));
d1413 10
d1431 103
a1533 1
    dSP; dATARGET; tryAMAGICbin(subtr,opASSIGN);
d1535 8
a1542 3
      dPOPTOPnnrl_ul;
      SETn( left - right );
      RETURN;
d1583 68
d1661 68
d1739 68
d1817 68
d1895 59
d1964 80
d2076 1
a2076 1
      int cmp = ((PL_op->op_private & OPpLOCALE)
d2089 1
a2089 1
      int cmp = ((PL_op->op_private & OPpLOCALE)
d2102 1
a2102 1
      int cmp = ((PL_op->op_private & OPpLOCALE)
d2115 1
a2115 1
      int cmp = ((PL_op->op_private & OPpLOCALE)
d2148 1
a2148 1
      int cmp = ((PL_op->op_private & OPpLOCALE)
d2230 1
d2233 3
a2235 1
	if (SvIOKp(sv) && !SvNOKp(sv) && !SvPOKp(sv)) {
d2238 1
d2251 6
d2271 10
a2280 3
	    else if (DO_UTF8(sv) && UTF8_IS_START(*s) && isIDFIRST_utf8((U8*)s)) {
		sv_setpvn(TARG, "-", 1);
		sv_catsv(TARG, sv);
d2282 4
a2285 1
	    else
d2287 1
d2337 1
a2337 1
	    UV c = utf8_to_uv(tmps, send-tmps, &l, UTF8_ALLOW_ANYUV);
d2351 1
a2351 1
		  UV c = utf8_to_uv(tmps, send-tmps, &l, UTF8_ALLOW_ANYUV);
d2353 1
a2353 1
		  result = uv_to_utf8(result, ~c);
d2363 1
a2363 1
		  U8 c = (U8)utf8_to_uv(tmps, 0, &l, UTF8_ALLOW_ANY);
d2687 1
a2687 1
    gettimeofday(&when,(struct timezone *) 0);
d2722 1
a2722 1
	DIE(aTHX_ "Can't take log of %g", value);
d2738 1
a2738 1
	DIE(aTHX_ "Can't take sqrt of %g", value);
d2746 22
d2770 1
a2770 1
    dSP; dTARGET;
d2772 15
a2786 8
      NV value = TOPn;
      IV iv;

      if (SvIOKp(TOPs) && !SvNOKp(TOPs) && !SvPOKp(TOPs)) {
	iv = SvIVX(TOPs);
	SETi(iv);
      }
      else {
d2788 5
a2792 2
#if defined(HAS_MODFL) || defined(LONG_DOUBLE_EQUALS_DOUBLE)
	      (void)Perl_modf(value, &value);
d2794 16
a2809 3
	      double tmp = (double)value;
	      (void)Perl_modf(tmp, &tmp);
	      value = (NV)tmp;
d2811 2
d2814 4
a2817 1
	else {
d2819 11
a2829 2
	    (void)Perl_modf(-value, &value);
	    value = -value;
d2831 3
a2833 3
	    double tmp = (double)value;
	    (void)Perl_modf(-tmp, &tmp);
	    value = -(NV)tmp;
d2835 3
a2837 6
	}
	iv = I_V(value);
	if (iv == value)
	  SETi(iv);
	else
	  SETn(value);
d2847 2
a2848 2
      NV value = TOPn;
      IV iv;
d2850 19
a2868 7
      if (SvIOKp(TOPs) && !SvNOKp(TOPs) && !SvPOKp(TOPs) &&
	  (iv = SvIVX(TOPs)) != IV_MIN) {
	if (iv < 0)
	  iv = -iv;
	SETi(iv);
      }
      else {
d2870 1
a2870 1
	    value = -value;
d2877 1
d2882 1
a2882 1
    STRLEN argtype;
d2884 3
d2888 17
a2904 3
    tmps = (SvPVx(POPs, len));
    argtype = 1;		/* allow underscores */
    XPUSHn(scan_hex(tmps, len, &argtype));
a2910 2
    NV value;
    STRLEN argtype;
d2912 1
d2914 3
d2918 10
a2927 1
    tmps = (SvPVx(POPs, len));
d2929 1
a2929 1
       tmps++, len--;
d2931 1
a2931 2
       tmps++, len--;
    argtype = 1;		/* allow underscores */
d2933 1
a2933 1
       value = scan_hex(++tmps, --len, &argtype);
d2935 1
a2935 1
       value = scan_bin(++tmps, --len, &argtype);
d2937 8
a2944 2
       value = scan_oct(tmps, len, &argtype);
    XPUSHn(value);
d2966 1
a2966 1
    I32 len;
d3051 1
a3051 1
	    Perl_warner(aTHX_ WARN_SUBSTR, "substr outside of string");
d3061 3
d3087 1
a3087 1
			Perl_warner(aTHX_ WARN_SUBSTR,
d3098 1
a3098 1
		sv_magic(TARG, Nullsv, 'x', Nullch, 0);
d3128 1
a3128 1
	    sv_magic(TARG, Nullsv, 'v', Nullch, 0);
d3168 1
a3168 1
    else if (offset > biglen)
d3209 1
a3209 1
    else if (offset > blen)
d3227 2
d3240 11
a3251 1
    XPUSHu(DO_UTF8(argsv) ? utf8_to_uv_simple(s, 0) : (*s & 0xff));
d3263 3
a3265 4
    if (value > 255 && !IN_BYTE) {
	SvGROW(TARG, UTF8_MAXLEN+1);
	tmps = SvPVX(TARG);
	tmps = (char*)uv_to_utf8((U8*)tmps, (UV)value);
d3277 1
a3277 1
    *tmps++ = value;
d3280 2
d3288 3
a3290 1
    dSP; dTARGET; dPOPTOPssrl;
d3292 14
a3305 3
#ifdef HAS_CRYPT
    char *tmps = SvPV(left, n_a);
#ifdef FCRYPT
d3307 1
a3307 1
#else
d3309 3
a3311 1
#endif
d3313 1
a3313 1
    DIE(aTHX_ 
a3315 2
    SETs(TARG);
    RETURN;
d3325 2
a3326 1
    if (DO_UTF8(sv) && (s = (U8*)SvPV(sv, slen)) && slen && UTF8_IS_START(*s)) {
d3328 4
a3331 3
	U8 tmpbuf[UTF8_MAXLEN+1];
	U8 *tend;
	UV uv = utf8_to_uv(s, slen, &ulen, 0);
d3333 2
a3334 9
	if (PL_op->op_private & OPpLOCALE) {
	    TAINT;
	    SvTAINTED_on(sv);
	    uv = toTITLE_LC_uni(uv);
	}
	else
	    uv = toTITLE_utf8(s);
	
	tend = uv_to_utf8(tmpbuf, uv);
d3336 1
a3336 1
	if (!SvPADTMP(sv) || tend - tmpbuf != ulen || SvREADONLY(sv)) {
d3338 1
a3338 1
	    sv_setpvn(TARG, (char*)tmpbuf, tend - tmpbuf);
d3345 1
a3345 1
	    Copy(tmpbuf, s, ulen, U8);
d3358 1
a3358 1
	    if (PL_op->op_private & OPpLOCALE) {
d3381 1
a3381 1
	U8 tmpbuf[UTF8_MAXLEN+1];
d3383 1
a3383 1
	UV uv = utf8_to_uv(s, slen, &ulen, 0);
d3385 2
a3386 7
	if (PL_op->op_private & OPpLOCALE) {
	    TAINT;
	    SvTAINTED_on(sv);
	    uv = toLOWER_LC_uni(uv);
	}
	else
	    uv = toLOWER_utf8(s);
d3388 1
a3388 1
	tend = uv_to_utf8(tmpbuf, uv);
d3390 1
a3390 1
	if (!SvPADTMP(sv) || tend - tmpbuf != ulen || SvREADONLY(sv)) {
d3412 1
a3412 1
	    if (PL_op->op_private & OPpLOCALE) {
d3438 1
d3447 2
d3450 1
a3450 1
	    SvGROW(TARG, (len * 2) + 1);
d3454 5
a3458 13
	    if (PL_op->op_private & OPpLOCALE) {
		TAINT;
		SvTAINTED_on(TARG);
		while (s < send) {
		    d = uv_to_utf8(d, toUPPER_LC_uni( utf8_to_uv(s, len, &ulen, 0)));
		    s += ulen;
		}
	    }
	    else {
		while (s < send) {
		    d = uv_to_utf8(d, toUPPER_utf8( s ));
		    s += UTF8SKIP(s);
		}
d3478 1
a3478 1
	    if (PL_op->op_private & OPpLOCALE) {
d3507 1
d3516 2
d3519 1
a3519 1
	    SvGROW(TARG, (len * 2) + 1);
d3523 22
a3544 13
	    if (PL_op->op_private & OPpLOCALE) {
		TAINT;
		SvTAINTED_on(TARG);
		while (s < send) {
		    d = uv_to_utf8(d, toLOWER_LC_uni( utf8_to_uv(s, len, &ulen, 0)));
		    s += ulen;
		}
	    }
	    else {
		while (s < send) {
		    d = uv_to_utf8(d, toLOWER_utf8(s));
		    s += UTF8SKIP(s);
		}
d3565 1
a3565 1
	    if (PL_op->op_private & OPpLOCALE) {
d3695 2
a3696 1
	PUSHs(hv_iterkeysv(entry));	/* won't clobber stack_sp */
d3830 2
d3833 15
a3847 1
    if (!realhv && PL_op->op_private & OPpLVAL_INTRO)
d3854 8
d3874 9
a3882 2
		if (PL_op->op_private & OPpLVAL_INTRO)
		    save_helem(hv, keysv, svp);
d3948 1
a3948 1
	else 
d3986 1
a3986 1
	    Perl_warner(aTHX_ WARN_MISC, "Odd number of elements in hash assignment");
d4009 1
a4009 1
    if ((mg = SvTIED_mg((SV*)ary, 'P'))) {
d4045 3
a4047 1
    if (offset > AvFILLp(ary) + 1)
d4049 1
d4206 1
a4206 1
    if ((mg = SvTIED_mg((SV*)ary, 'P'))) {
d4262 1
a4262 1
    if ((mg = SvTIED_mg((SV*)ary, 'P'))) {
d4318 1
a4318 1
		    if (UTF8_IS_ASCII(*s)) {
d4323 1
a4323 1
			if (!utf8_to_uv_simple(s, 0))
d4332 1
a4332 1
			    *down-- = tmp;
d4342 1
a4342 1
		*down-- = tmp;
a4351 1721
STATIC SV *
S_mul128(pTHX_ SV *sv, U8 m)
{
  STRLEN          len;
  char           *s = SvPV(sv, len);
  char           *t;
  U32             i = 0;

  if (!strnEQ(s, "0000", 4)) {  /* need to grow sv */
    SV             *tmpNew = newSVpvn("0000000000", 10);

    sv_catsv(tmpNew, sv);
    SvREFCNT_dec(sv);		/* free old sv */
    sv = tmpNew;
    s = SvPV(sv, len);
  }
  t = s + len - 1;
  while (!*t)                   /* trailing '\0'? */
    t--;
  while (t > s) {
    i = ((*t - '0') << 7) + m;
    *(t--) = '0' + (i % 10);
    m = i / 10;
  }
  return (sv);
}

/* Explosives and implosives. */

#if 'I' == 73 && 'J' == 74
/* On an ASCII/ISO kind of system */
#define ISUUCHAR(ch)    ((ch) >= ' ' && (ch) < 'a')
#else
/*
  Some other sort of character set - use memchr() so we don't match
  the null byte.
 */
#define ISUUCHAR(ch)    (memchr(PL_uuemap, (ch), sizeof(PL_uuemap)-1) || (ch) == ' ')
#endif

PP(pp_unpack)
{
    dSP;
    dPOPPOPssrl;
    I32 start_sp_offset = SP - PL_stack_base;
    I32 gimme = GIMME_V;
    SV *sv;
    STRLEN llen;
    STRLEN rlen;
    register char *pat = SvPV(left, llen);
    register char *s = SvPV(right, rlen);
    char *strend = s + rlen;
    char *strbeg = s;
    register char *patend = pat + llen;
    I32 datumtype;
    register I32 len;
    register I32 bits;
    register char *str;

    /* These must not be in registers: */
    short ashort;
    int aint;
    long along;
#ifdef HAS_QUAD
    Quad_t aquad;
#endif
    U16 aushort;
    unsigned int auint;
    U32 aulong;
#ifdef HAS_QUAD
    Uquad_t auquad;
#endif
    char *aptr;
    float afloat;
    double adouble;
    I32 checksum = 0;
    register U32 culong;
    NV cdouble;
    int commas = 0;
    int star;
#ifdef PERL_NATINT_PACK
    int natint;		/* native integer */
    int unatint;	/* unsigned native integer */
#endif

    if (gimme != G_ARRAY) {		/* arrange to do first one only */
	/*SUPPRESS 530*/
	for (patend = pat; !isALPHA(*patend) || *patend == 'x'; patend++) ;
	if (strchr("aAZbBhHP", *patend) || *pat == '%') {
	    patend++;
	    while (isDIGIT(*patend) || *patend == '*')
		patend++;
	}
	else
	    patend++;
    }
    while (pat < patend) {
      reparse:
	datumtype = *pat++ & 0xFF;
#ifdef PERL_NATINT_PACK
	natint = 0;
#endif
	if (isSPACE(datumtype))
	    continue;
	if (datumtype == '#') {
	    while (pat < patend && *pat != '\n')
		pat++;
	    continue;
	}
	if (*pat == '!') {
	    char *natstr = "sSiIlL";

	    if (strchr(natstr, datumtype)) {
#ifdef PERL_NATINT_PACK
		natint = 1;
#endif
		pat++;
	    }
	    else
		DIE(aTHX_ "'!' allowed only after types %s", natstr);
	}
	star = 0;
	if (pat >= patend)
	    len = 1;
	else if (*pat == '*') {
	    len = strend - strbeg;	/* long enough */
	    pat++;
	    star = 1;
	}
	else if (isDIGIT(*pat)) {
	    len = *pat++ - '0';
	    while (isDIGIT(*pat)) {
		len = (len * 10) + (*pat++ - '0');
		if (len < 0)
		    DIE(aTHX_ "Repeat count in unpack overflows");
	    }
	}
	else
	    len = (datumtype != '@@');
      redo_switch:
	switch(datumtype) {
	default:
	    DIE(aTHX_ "Invalid type in unpack: '%c'", (int)datumtype);
	case ',': /* grandfather in commas but with a warning */
	    if (commas++ == 0 && ckWARN(WARN_UNPACK))
		Perl_warner(aTHX_ WARN_UNPACK,
			    "Invalid type in unpack: '%c'", (int)datumtype);
	    break;
	case '%':
	    if (len == 1 && pat[-1] != '1')
		len = 16;
	    checksum = len;
	    culong = 0;
	    cdouble = 0;
	    if (pat < patend)
		goto reparse;
	    break;
	case '@@':
	    if (len > strend - strbeg)
		DIE(aTHX_ "@@ outside of string");
	    s = strbeg + len;
	    break;
	case 'X':
	    if (len > s - strbeg)
		DIE(aTHX_ "X outside of string");
	    s -= len;
	    break;
	case 'x':
	    if (len > strend - s)
		DIE(aTHX_ "x outside of string");
	    s += len;
	    break;
	case '/':
	    if (start_sp_offset >= SP - PL_stack_base)
		DIE(aTHX_ "/ must follow a numeric type");
	    datumtype = *pat++;
	    if (*pat == '*')
		pat++;		/* ignore '*' for compatibility with pack */
	    if (isDIGIT(*pat))
		DIE(aTHX_ "/ cannot take a count" );
	    len = POPi;
	    star = 0;
	    goto redo_switch;
	case 'A':
	case 'Z':
	case 'a':
	    if (len > strend - s)
		len = strend - s;
	    if (checksum)
		goto uchar_checksum;
	    sv = NEWSV(35, len);
	    sv_setpvn(sv, s, len);
	    s += len;
	    if (datumtype == 'A' || datumtype == 'Z') {
		aptr = s;	/* borrow register */
		if (datumtype == 'Z') {	/* 'Z' strips stuff after first null */
		    s = SvPVX(sv);
		    while (*s)
			s++;
		}
		else {		/* 'A' strips both nulls and spaces */
		    s = SvPVX(sv) + len - 1;
		    while (s >= SvPVX(sv) && (!*s || isSPACE(*s)))
			s--;
		    *++s = '\0';
		}
		SvCUR_set(sv, s - SvPVX(sv));
		s = aptr;	/* unborrow register */
	    }
	    XPUSHs(sv_2mortal(sv));
	    break;
	case 'B':
	case 'b':
	    if (star || len > (strend - s) * 8)
		len = (strend - s) * 8;
	    if (checksum) {
		if (!PL_bitcount) {
		    Newz(601, PL_bitcount, 256, char);
		    for (bits = 1; bits < 256; bits++) {
			if (bits & 1)	PL_bitcount[bits]++;
			if (bits & 2)	PL_bitcount[bits]++;
			if (bits & 4)	PL_bitcount[bits]++;
			if (bits & 8)	PL_bitcount[bits]++;
			if (bits & 16)	PL_bitcount[bits]++;
			if (bits & 32)	PL_bitcount[bits]++;
			if (bits & 64)	PL_bitcount[bits]++;
			if (bits & 128)	PL_bitcount[bits]++;
		    }
		}
		while (len >= 8) {
		    culong += PL_bitcount[*(unsigned char*)s++];
		    len -= 8;
		}
		if (len) {
		    bits = *s;
		    if (datumtype == 'b') {
			while (len-- > 0) {
			    if (bits & 1) culong++;
			    bits >>= 1;
			}
		    }
		    else {
			while (len-- > 0) {
			    if (bits & 128) culong++;
			    bits <<= 1;
			}
		    }
		}
		break;
	    }
	    sv = NEWSV(35, len + 1);
	    SvCUR_set(sv, len);
	    SvPOK_on(sv);
	    str = SvPVX(sv);
	    if (datumtype == 'b') {
		aint = len;
		for (len = 0; len < aint; len++) {
		    if (len & 7)		/*SUPPRESS 595*/
			bits >>= 1;
		    else
			bits = *s++;
		    *str++ = '0' + (bits & 1);
		}
	    }
	    else {
		aint = len;
		for (len = 0; len < aint; len++) {
		    if (len & 7)
			bits <<= 1;
		    else
			bits = *s++;
		    *str++ = '0' + ((bits & 128) != 0);
		}
	    }
	    *str = '\0';
	    XPUSHs(sv_2mortal(sv));
	    break;
	case 'H':
	case 'h':
	    if (star || len > (strend - s) * 2)
		len = (strend - s) * 2;
	    sv = NEWSV(35, len + 1);
	    SvCUR_set(sv, len);
	    SvPOK_on(sv);
	    str = SvPVX(sv);
	    if (datumtype == 'h') {
		aint = len;
		for (len = 0; len < aint; len++) {
		    if (len & 1)
			bits >>= 4;
		    else
			bits = *s++;
		    *str++ = PL_hexdigit[bits & 15];
		}
	    }
	    else {
		aint = len;
		for (len = 0; len < aint; len++) {
		    if (len & 1)
			bits <<= 4;
		    else
			bits = *s++;
		    *str++ = PL_hexdigit[(bits >> 4) & 15];
		}
	    }
	    *str = '\0';
	    XPUSHs(sv_2mortal(sv));
	    break;
	case 'c':
	    if (len > strend - s)
		len = strend - s;
	    if (checksum) {
		while (len-- > 0) {
		    aint = *s++;
		    if (aint >= 128)	/* fake up signed chars */
			aint -= 256;
		    culong += aint;
		}
	    }
	    else {
		EXTEND(SP, len);
		EXTEND_MORTAL(len);
		while (len-- > 0) {
		    aint = *s++;
		    if (aint >= 128)	/* fake up signed chars */
			aint -= 256;
		    sv = NEWSV(36, 0);
		    sv_setiv(sv, (IV)aint);
		    PUSHs(sv_2mortal(sv));
		}
	    }
	    break;
	case 'C':
	    if (len > strend - s)
		len = strend - s;
	    if (checksum) {
	      uchar_checksum:
		while (len-- > 0) {
		    auint = *s++ & 255;
		    culong += auint;
		}
	    }
	    else {
		EXTEND(SP, len);
		EXTEND_MORTAL(len);
		while (len-- > 0) {
		    auint = *s++ & 255;
		    sv = NEWSV(37, 0);
		    sv_setiv(sv, (IV)auint);
		    PUSHs(sv_2mortal(sv));
		}
	    }
	    break;
	case 'U':
	    if (len > strend - s)
		len = strend - s;
	    if (checksum) {
		while (len-- > 0 && s < strend) {
		    STRLEN alen;
		    auint = utf8_to_uv((U8*)s, strend - s, &alen, 0);
		    along = alen;
		    s += along;
		    if (checksum > 32)
			cdouble += (NV)auint;
		    else
			culong += auint;
		}
	    }
	    else {
		EXTEND(SP, len);
		EXTEND_MORTAL(len);
		while (len-- > 0 && s < strend) {
		    STRLEN alen;
		    auint = utf8_to_uv((U8*)s, strend - s, &alen, 0);
		    along = alen;
		    s += along;
		    sv = NEWSV(37, 0);
		    sv_setuv(sv, (UV)auint);
		    PUSHs(sv_2mortal(sv));
		}
	    }
	    break;
	case 's':
#if SHORTSIZE == SIZE16
	    along = (strend - s) / SIZE16;
#else
	    along = (strend - s) / (natint ? sizeof(short) : SIZE16);
#endif
	    if (len > along)
		len = along;
	    if (checksum) {
#if SHORTSIZE != SIZE16
		if (natint) {
		    short ashort;
		    while (len-- > 0) {
			COPYNN(s, &ashort, sizeof(short));
			s += sizeof(short);
			culong += ashort;

		    }
		}
		else
#endif
                {
		    while (len-- > 0) {
			COPY16(s, &ashort);
#if SHORTSIZE > SIZE16
			if (ashort > 32767)
			  ashort -= 65536;
#endif
			s += SIZE16;
			culong += ashort;
		    }
		}
	    }
	    else {
		EXTEND(SP, len);
		EXTEND_MORTAL(len);
#if SHORTSIZE != SIZE16
		if (natint) {
		    short ashort;
		    while (len-- > 0) {
			COPYNN(s, &ashort, sizeof(short));
			s += sizeof(short);
			sv = NEWSV(38, 0);
			sv_setiv(sv, (IV)ashort);
			PUSHs(sv_2mortal(sv));
		    }
		}
		else
#endif
                {
		    while (len-- > 0) {
			COPY16(s, &ashort);
#if SHORTSIZE > SIZE16
			if (ashort > 32767)
			  ashort -= 65536;
#endif
			s += SIZE16;
			sv = NEWSV(38, 0);
			sv_setiv(sv, (IV)ashort);
			PUSHs(sv_2mortal(sv));
		    }
		}
	    }
	    break;
	case 'v':
	case 'n':
	case 'S':
#if SHORTSIZE == SIZE16
	    along = (strend - s) / SIZE16;
#else
	    unatint = natint && datumtype == 'S';
	    along = (strend - s) / (unatint ? sizeof(unsigned short) : SIZE16);
#endif
	    if (len > along)
		len = along;
	    if (checksum) {
#if SHORTSIZE != SIZE16
		if (unatint) {
		    unsigned short aushort;
		    while (len-- > 0) {
			COPYNN(s, &aushort, sizeof(unsigned short));
			s += sizeof(unsigned short);
			culong += aushort;
		    }
		}
		else
#endif
                {
		    while (len-- > 0) {
			COPY16(s, &aushort);
			s += SIZE16;
#ifdef HAS_NTOHS
			if (datumtype == 'n')
			    aushort = PerlSock_ntohs(aushort);
#endif
#ifdef HAS_VTOHS
			if (datumtype == 'v')
			    aushort = vtohs(aushort);
#endif
			culong += aushort;
		    }
		}
	    }
	    else {
		EXTEND(SP, len);
		EXTEND_MORTAL(len);
#if SHORTSIZE != SIZE16
		if (unatint) {
		    unsigned short aushort;
		    while (len-- > 0) {
			COPYNN(s, &aushort, sizeof(unsigned short));
			s += sizeof(unsigned short);
			sv = NEWSV(39, 0);
			sv_setiv(sv, (UV)aushort);
			PUSHs(sv_2mortal(sv));
		    }
		}
		else
#endif
                {
		    while (len-- > 0) {
			COPY16(s, &aushort);
			s += SIZE16;
			sv = NEWSV(39, 0);
#ifdef HAS_NTOHS
			if (datumtype == 'n')
			    aushort = PerlSock_ntohs(aushort);
#endif
#ifdef HAS_VTOHS
			if (datumtype == 'v')
			    aushort = vtohs(aushort);
#endif
			sv_setiv(sv, (UV)aushort);
			PUSHs(sv_2mortal(sv));
		    }
		}
	    }
	    break;
	case 'i':
	    along = (strend - s) / sizeof(int);
	    if (len > along)
		len = along;
	    if (checksum) {
		while (len-- > 0) {
		    Copy(s, &aint, 1, int);
		    s += sizeof(int);
		    if (checksum > 32)
			cdouble += (NV)aint;
		    else
			culong += aint;
		}
	    }
	    else {
		EXTEND(SP, len);
		EXTEND_MORTAL(len);
		while (len-- > 0) {
		    Copy(s, &aint, 1, int);
		    s += sizeof(int);
		    sv = NEWSV(40, 0);
#ifdef __osf__
                    /* Without the dummy below unpack("i", pack("i",-1))
                     * return 0xFFffFFff instead of -1 for Digital Unix V4.0
                     * cc with optimization turned on.
		     *
		     * The bug was detected in
		     * DEC C V5.8-009 on Digital UNIX V4.0 (Rev. 1091) (V4.0E)
		     * with optimization (-O4) turned on.
		     * DEC C V5.2-040 on Digital UNIX V4.0 (Rev. 564) (V4.0B)
		     * does not have this problem even with -O4.
		     *
		     * This bug was reported as DECC_BUGS 1431
		     * and tracked internally as GEM_BUGS 7775.
		     *
		     * The bug is fixed in
		     * Tru64 UNIX V5.0:      Compaq C V6.1-006 or later
		     * UNIX V4.0F support:   DEC C V5.9-006 or later
		     * UNIX V4.0E support:   DEC C V5.8-011 or later
		     * and also in DTK.
		     *
		     * See also few lines later for the same bug.
		     */
                    (aint) ?
		    	sv_setiv(sv, (IV)aint) :
#endif
		    sv_setiv(sv, (IV)aint);
		    PUSHs(sv_2mortal(sv));
		}
	    }
	    break;
	case 'I':
	    along = (strend - s) / sizeof(unsigned int);
	    if (len > along)
		len = along;
	    if (checksum) {
		while (len-- > 0) {
		    Copy(s, &auint, 1, unsigned int);
		    s += sizeof(unsigned int);
		    if (checksum > 32)
			cdouble += (NV)auint;
		    else
			culong += auint;
		}
	    }
	    else {
		EXTEND(SP, len);
		EXTEND_MORTAL(len);
		while (len-- > 0) {
		    Copy(s, &auint, 1, unsigned int);
		    s += sizeof(unsigned int);
		    sv = NEWSV(41, 0);
#ifdef __osf__
                    /* Without the dummy below unpack("I", pack("I",0xFFFFFFFF))
                     * returns 1.84467440737096e+19 instead of 0xFFFFFFFF.
		     * See details few lines earlier. */
                    (auint) ?
		        sv_setuv(sv, (UV)auint) :
#endif
		    sv_setuv(sv, (UV)auint);
		    PUSHs(sv_2mortal(sv));
		}
	    }
	    break;
	case 'l':
#if LONGSIZE == SIZE32
	    along = (strend - s) / SIZE32;
#else
	    along = (strend - s) / (natint ? sizeof(long) : SIZE32);
#endif
	    if (len > along)
		len = along;
	    if (checksum) {
#if LONGSIZE != SIZE32
		if (natint) {
		    while (len-- > 0) {
			COPYNN(s, &along, sizeof(long));
			s += sizeof(long);
			if (checksum > 32)
			    cdouble += (NV)along;
			else
			    culong += along;
		    }
		}
		else
#endif
                {
		    while (len-- > 0) {
#if LONGSIZE > SIZE32 && INTSIZE == SIZE32
			I32 along;
#endif
			COPY32(s, &along);
#if LONGSIZE > SIZE32
			if (along > 2147483647)
			  along -= 4294967296;
#endif
			s += SIZE32;
			if (checksum > 32)
			    cdouble += (NV)along;
			else
			    culong += along;
		    }
		}
	    }
	    else {
		EXTEND(SP, len);
		EXTEND_MORTAL(len);
#if LONGSIZE != SIZE32
		if (natint) {
		    while (len-- > 0) {
			COPYNN(s, &along, sizeof(long));
			s += sizeof(long);
			sv = NEWSV(42, 0);
			sv_setiv(sv, (IV)along);
			PUSHs(sv_2mortal(sv));
		    }
		}
		else
#endif
                {
		    while (len-- > 0) {
#if LONGSIZE > SIZE32 && INTSIZE == SIZE32
			I32 along;
#endif
			COPY32(s, &along);
#if LONGSIZE > SIZE32
			if (along > 2147483647)
			  along -= 4294967296;
#endif
			s += SIZE32;
			sv = NEWSV(42, 0);
			sv_setiv(sv, (IV)along);
			PUSHs(sv_2mortal(sv));
		    }
		}
	    }
	    break;
	case 'V':
	case 'N':
	case 'L':
#if LONGSIZE == SIZE32
	    along = (strend - s) / SIZE32;
#else
	    unatint = natint && datumtype == 'L';
	    along = (strend - s) / (unatint ? sizeof(unsigned long) : SIZE32);
#endif
	    if (len > along)
		len = along;
	    if (checksum) {
#if LONGSIZE != SIZE32
		if (unatint) {
		    unsigned long aulong;
		    while (len-- > 0) {
			COPYNN(s, &aulong, sizeof(unsigned long));
			s += sizeof(unsigned long);
			if (checksum > 32)
			    cdouble += (NV)aulong;
			else
			    culong += aulong;
		    }
		}
		else
#endif
                {
		    while (len-- > 0) {
			COPY32(s, &aulong);
			s += SIZE32;
#ifdef HAS_NTOHL
			if (datumtype == 'N')
			    aulong = PerlSock_ntohl(aulong);
#endif
#ifdef HAS_VTOHL
			if (datumtype == 'V')
			    aulong = vtohl(aulong);
#endif
			if (checksum > 32)
			    cdouble += (NV)aulong;
			else
			    culong += aulong;
		    }
		}
	    }
	    else {
		EXTEND(SP, len);
		EXTEND_MORTAL(len);
#if LONGSIZE != SIZE32
		if (unatint) {
		    unsigned long aulong;
		    while (len-- > 0) {
			COPYNN(s, &aulong, sizeof(unsigned long));
			s += sizeof(unsigned long);
			sv = NEWSV(43, 0);
			sv_setuv(sv, (UV)aulong);
			PUSHs(sv_2mortal(sv));
		    }
		}
		else
#endif
                {
		    while (len-- > 0) {
			COPY32(s, &aulong);
			s += SIZE32;
#ifdef HAS_NTOHL
			if (datumtype == 'N')
			    aulong = PerlSock_ntohl(aulong);
#endif
#ifdef HAS_VTOHL
			if (datumtype == 'V')
			    aulong = vtohl(aulong);
#endif
			sv = NEWSV(43, 0);
			sv_setuv(sv, (UV)aulong);
			PUSHs(sv_2mortal(sv));
		    }
		}
	    }
	    break;
	case 'p':
	    along = (strend - s) / sizeof(char*);
	    if (len > along)
		len = along;
	    EXTEND(SP, len);
	    EXTEND_MORTAL(len);
	    while (len-- > 0) {
		if (sizeof(char*) > strend - s)
		    break;
		else {
		    Copy(s, &aptr, 1, char*);
		    s += sizeof(char*);
		}
		sv = NEWSV(44, 0);
		if (aptr)
		    sv_setpv(sv, aptr);
		PUSHs(sv_2mortal(sv));
	    }
	    break;
	case 'w':
	    EXTEND(SP, len);
	    EXTEND_MORTAL(len);
	    {
		UV auv = 0;
		U32 bytes = 0;
		
		while ((len > 0) && (s < strend)) {
		    auv = (auv << 7) | (*s & 0x7f);
		    if (UTF8_IS_ASCII(*s++)) {
			bytes = 0;
			sv = NEWSV(40, 0);
			sv_setuv(sv, auv);
			PUSHs(sv_2mortal(sv));
			len--;
			auv = 0;
		    }
		    else if (++bytes >= sizeof(UV)) {	/* promote to string */
			char *t;
			STRLEN n_a;

			sv = Perl_newSVpvf(aTHX_ "%.*"UVf, (int)TYPE_DIGITS(UV), auv);
			while (s < strend) {
			    sv = mul128(sv, *s & 0x7f);
			    if (!(*s++ & 0x80)) {
				bytes = 0;
				break;
			    }
			}
			t = SvPV(sv, n_a);
			while (*t == '0')
			    t++;
			sv_chop(sv, t);
			PUSHs(sv_2mortal(sv));
			len--;
			auv = 0;
		    }
		}
		if ((s >= strend) && bytes)
		    DIE(aTHX_ "Unterminated compressed integer");
	    }
	    break;
	case 'P':
	    EXTEND(SP, 1);
	    if (sizeof(char*) > strend - s)
		break;
	    else {
		Copy(s, &aptr, 1, char*);
		s += sizeof(char*);
	    }
	    sv = NEWSV(44, 0);
	    if (aptr)
		sv_setpvn(sv, aptr, len);
	    PUSHs(sv_2mortal(sv));
	    break;
#ifdef HAS_QUAD
	case 'q':
	    along = (strend - s) / sizeof(Quad_t);
	    if (len > along)
		len = along;
	    EXTEND(SP, len);
	    EXTEND_MORTAL(len);
	    while (len-- > 0) {
		if (s + sizeof(Quad_t) > strend)
		    aquad = 0;
		else {
		    Copy(s, &aquad, 1, Quad_t);
		    s += sizeof(Quad_t);
		}
		sv = NEWSV(42, 0);
		if (aquad >= IV_MIN && aquad <= IV_MAX)
		    sv_setiv(sv, (IV)aquad);
		else
		    sv_setnv(sv, (NV)aquad);
		PUSHs(sv_2mortal(sv));
	    }
	    break;
	case 'Q':
	    along = (strend - s) / sizeof(Quad_t);
	    if (len > along)
		len = along;
	    EXTEND(SP, len);
	    EXTEND_MORTAL(len);
	    while (len-- > 0) {
		if (s + sizeof(Uquad_t) > strend)
		    auquad = 0;
		else {
		    Copy(s, &auquad, 1, Uquad_t);
		    s += sizeof(Uquad_t);
		}
		sv = NEWSV(43, 0);
		if (auquad <= UV_MAX)
		    sv_setuv(sv, (UV)auquad);
		else
		    sv_setnv(sv, (NV)auquad);
		PUSHs(sv_2mortal(sv));
	    }
	    break;
#endif
	/* float and double added gnb@@melba.bby.oz.au 22/11/89 */
	case 'f':
	case 'F':
	    along = (strend - s) / sizeof(float);
	    if (len > along)
		len = along;
	    if (checksum) {
		while (len-- > 0) {
		    Copy(s, &afloat, 1, float);
		    s += sizeof(float);
		    cdouble += afloat;
		}
	    }
	    else {
		EXTEND(SP, len);
		EXTEND_MORTAL(len);
		while (len-- > 0) {
		    Copy(s, &afloat, 1, float);
		    s += sizeof(float);
		    sv = NEWSV(47, 0);
		    sv_setnv(sv, (NV)afloat);
		    PUSHs(sv_2mortal(sv));
		}
	    }
	    break;
	case 'd':
	case 'D':
	    along = (strend - s) / sizeof(double);
	    if (len > along)
		len = along;
	    if (checksum) {
		while (len-- > 0) {
		    Copy(s, &adouble, 1, double);
		    s += sizeof(double);
		    cdouble += adouble;
		}
	    }
	    else {
		EXTEND(SP, len);
		EXTEND_MORTAL(len);
		while (len-- > 0) {
		    Copy(s, &adouble, 1, double);
		    s += sizeof(double);
		    sv = NEWSV(48, 0);
		    sv_setnv(sv, (NV)adouble);
		    PUSHs(sv_2mortal(sv));
		}
	    }
	    break;
	case 'u':
	    /* MKS:
	     * Initialise the decode mapping.  By using a table driven
             * algorithm, the code will be character-set independent
             * (and just as fast as doing character arithmetic)
             */
            if (PL_uudmap['M'] == 0) {
                int i;
 
                for (i = 0; i < sizeof(PL_uuemap); i += 1)
                    PL_uudmap[(U8)PL_uuemap[i]] = i;
                /*
                 * Because ' ' and '`' map to the same value,
                 * we need to decode them both the same.
                 */
                PL_uudmap[' '] = 0;
            }

	    along = (strend - s) * 3 / 4;
	    sv = NEWSV(42, along);
	    if (along)
		SvPOK_on(sv);
	    while (s < strend && *s > ' ' && ISUUCHAR(*s)) {
		I32 a, b, c, d;
		char hunk[4];

		hunk[3] = '\0';
		len = PL_uudmap[*(U8*)s++] & 077;
		while (len > 0) {
		    if (s < strend && ISUUCHAR(*s))
			a = PL_uudmap[*(U8*)s++] & 077;
 		    else
 			a = 0;
		    if (s < strend && ISUUCHAR(*s))
			b = PL_uudmap[*(U8*)s++] & 077;
 		    else
 			b = 0;
		    if (s < strend && ISUUCHAR(*s))
			c = PL_uudmap[*(U8*)s++] & 077;
 		    else
 			c = 0;
		    if (s < strend && ISUUCHAR(*s))
			d = PL_uudmap[*(U8*)s++] & 077;
		    else
			d = 0;
		    hunk[0] = (a << 2) | (b >> 4);
		    hunk[1] = (b << 4) | (c >> 2);
		    hunk[2] = (c << 6) | d;
		    sv_catpvn(sv, hunk, (len > 3) ? 3 : len);
		    len -= 3;
		}
		if (*s == '\n')
		    s++;
		else if (s[1] == '\n')		/* possible checksum byte */
		    s += 2;
	    }
	    XPUSHs(sv_2mortal(sv));
	    break;
	}
	if (checksum) {
	    sv = NEWSV(42, 0);
	    if (strchr("fFdD", datumtype) ||
	      (checksum > 32 && strchr("iIlLNU", datumtype)) ) {
		NV trouble;

		adouble = 1.0;
		while (checksum >= 16) {
		    checksum -= 16;
		    adouble *= 65536.0;
		}
		while (checksum >= 4) {
		    checksum -= 4;
		    adouble *= 16.0;
		}
		while (checksum--)
		    adouble *= 2.0;
		along = (1 << checksum) - 1;
		while (cdouble < 0.0)
		    cdouble += adouble;
		cdouble = Perl_modf(cdouble / adouble, &trouble) * adouble;
		sv_setnv(sv, cdouble);
	    }
	    else {
		if (checksum < 32) {
		    aulong = (1 << checksum) - 1;
		    culong &= aulong;
		}
		sv_setuv(sv, (UV)culong);
	    }
	    XPUSHs(sv_2mortal(sv));
	    checksum = 0;
	}
    }
    if (SP - PL_stack_base == start_sp_offset && gimme == G_SCALAR)
	PUSHs(&PL_sv_undef);
    RETURN;
}

STATIC void
S_doencodes(pTHX_ register SV *sv, register char *s, register I32 len)
{
    char hunk[5];

    *hunk = PL_uuemap[len];
    sv_catpvn(sv, hunk, 1);
    hunk[4] = '\0';
    while (len > 2) {
	hunk[0] = PL_uuemap[(077 & (*s >> 2))];
	hunk[1] = PL_uuemap[(077 & (((*s << 4) & 060) | ((s[1] >> 4) & 017)))];
	hunk[2] = PL_uuemap[(077 & (((s[1] << 2) & 074) | ((s[2] >> 6) & 03)))];
	hunk[3] = PL_uuemap[(077 & (s[2] & 077))];
	sv_catpvn(sv, hunk, 4);
	s += 3;
	len -= 3;
    }
    if (len > 0) {
	char r = (len > 1 ? s[1] : '\0');
	hunk[0] = PL_uuemap[(077 & (*s >> 2))];
	hunk[1] = PL_uuemap[(077 & (((*s << 4) & 060) | ((r >> 4) & 017)))];
	hunk[2] = PL_uuemap[(077 & ((r << 2) & 074))];
	hunk[3] = PL_uuemap[0];
	sv_catpvn(sv, hunk, 4);
    }
    sv_catpvn(sv, "\n", 1);
}

STATIC SV *
S_is_an_int(pTHX_ char *s, STRLEN l)
{
  STRLEN	 n_a;
  SV             *result = newSVpvn(s, l);
  char           *result_c = SvPV(result, n_a);	/* convenience */
  char           *out = result_c;
  bool            skip = 1;
  bool            ignore = 0;

  while (*s) {
    switch (*s) {
    case ' ':
      break;
    case '+':
      if (!skip) {
	SvREFCNT_dec(result);
	return (NULL);
      }
      break;
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
      skip = 0;
      if (!ignore) {
	*(out++) = *s;
      }
      break;
    case '.':
      ignore = 1;
      break;
    default:
      SvREFCNT_dec(result);
      return (NULL);
    }
    s++;
  }
  *(out++) = '\0';
  SvCUR_set(result, out - result_c);
  return (result);
}

/* pnum must be '\0' terminated */
STATIC int
S_div128(pTHX_ SV *pnum, bool *done)
{
  STRLEN          len;
  char           *s = SvPV(pnum, len);
  int             m = 0;
  int             r = 0;
  char           *t = s;

  *done = 1;
  while (*t) {
    int             i;

    i = m * 10 + (*t - '0');
    m = i & 0x7F;
    r = (i >> 7);		/* r < 10 */
    if (r) {
      *done = 0;
    }
    *(t++) = '0' + r;
  }
  *(t++) = '\0';
  SvCUR_set(pnum, (STRLEN) (t - s));
  return (m);
}


PP(pp_pack)
{
    dSP; dMARK; dORIGMARK; dTARGET;
    register SV *cat = TARG;
    register I32 items;
    STRLEN fromlen;
    register char *pat = SvPVx(*++MARK, fromlen);
    char *patcopy;
    register char *patend = pat + fromlen;
    register I32 len;
    I32 datumtype;
    SV *fromstr;
    /*SUPPRESS 442*/
    static char null10[] = {0,0,0,0,0,0,0,0,0,0};
    static char *space10 = "          ";

    /* These must not be in registers: */
    char achar;
    I16 ashort;
    int aint;
    unsigned int auint;
    I32 along;
    U32 aulong;
#ifdef HAS_QUAD
    Quad_t aquad;
    Uquad_t auquad;
#endif
    char *aptr;
    float afloat;
    double adouble;
    int commas = 0;
#ifdef PERL_NATINT_PACK
    int natint;		/* native integer */
#endif

    items = SP - MARK;
    MARK++;
    sv_setpvn(cat, "", 0);
    patcopy = pat;
    while (pat < patend) {
	SV *lengthcode = Nullsv;
#define NEXTFROM ( lengthcode ? lengthcode : items-- > 0 ? *MARK++ : &PL_sv_no)
	datumtype = *pat++ & 0xFF;
#ifdef PERL_NATINT_PACK
	natint = 0;
#endif
	if (isSPACE(datumtype)) {
	    patcopy++;
	    continue;
        }
	if (datumtype == 'U' && pat == patcopy+1) 
	    SvUTF8_on(cat);
	if (datumtype == '#') {
	    while (pat < patend && *pat != '\n')
		pat++;
	    continue;
	}
        if (*pat == '!') {
	    char *natstr = "sSiIlL";

	    if (strchr(natstr, datumtype)) {
#ifdef PERL_NATINT_PACK
		natint = 1;
#endif
		pat++;
	    }
	    else
		DIE(aTHX_ "'!' allowed only after types %s", natstr);
	}
	if (*pat == '*') {
	    len = strchr("@@Xxu", datumtype) ? 0 : items;
	    pat++;
	}
	else if (isDIGIT(*pat)) {
	    len = *pat++ - '0';
	    while (isDIGIT(*pat)) {
		len = (len * 10) + (*pat++ - '0');
		if (len < 0)
		    DIE(aTHX_ "Repeat count in pack overflows");
	    }
	}
	else
	    len = 1;
	if (*pat == '/') {
	    ++pat;
	    if ((*pat != 'a' && *pat != 'A' && *pat != 'Z') || pat[1] != '*')
		DIE(aTHX_ "/ must be followed by a*, A* or Z*");
	    lengthcode = sv_2mortal(newSViv(sv_len(items > 0
						   ? *MARK : &PL_sv_no)
                                            + (*pat == 'Z' ? 1 : 0)));
	}
	switch(datumtype) {
	default:
	    DIE(aTHX_ "Invalid type in pack: '%c'", (int)datumtype);
	case ',': /* grandfather in commas but with a warning */
	    if (commas++ == 0 && ckWARN(WARN_PACK))
		Perl_warner(aTHX_ WARN_PACK,
			    "Invalid type in pack: '%c'", (int)datumtype);
	    break;
	case '%':
	    DIE(aTHX_ "%% may only be used in unpack");
	case '@@':
	    len -= SvCUR(cat);
	    if (len > 0)
		goto grow;
	    len = -len;
	    if (len > 0)
		goto shrink;
	    break;
	case 'X':
	  shrink:
	    if (SvCUR(cat) < len)
		DIE(aTHX_ "X outside of string");
	    SvCUR(cat) -= len;
	    *SvEND(cat) = '\0';
	    break;
	case 'x':
	  grow:
	    while (len >= 10) {
		sv_catpvn(cat, null10, 10);
		len -= 10;
	    }
	    sv_catpvn(cat, null10, len);
	    break;
	case 'A':
	case 'Z':
	case 'a':
	    fromstr = NEXTFROM;
	    aptr = SvPV(fromstr, fromlen);
	    if (pat[-1] == '*') {
		len = fromlen;
		if (datumtype == 'Z')
		    ++len;
	    }
	    if (fromlen >= len) {
		sv_catpvn(cat, aptr, len);
		if (datumtype == 'Z')
		    *(SvEND(cat)-1) = '\0';
	    }
	    else {
		sv_catpvn(cat, aptr, fromlen);
		len -= fromlen;
		if (datumtype == 'A') {
		    while (len >= 10) {
			sv_catpvn(cat, space10, 10);
			len -= 10;
		    }
		    sv_catpvn(cat, space10, len);
		}
		else {
		    while (len >= 10) {
			sv_catpvn(cat, null10, 10);
			len -= 10;
		    }
		    sv_catpvn(cat, null10, len);
		}
	    }
	    break;
	case 'B':
	case 'b':
	    {
		register char *str;
		I32 saveitems;

		fromstr = NEXTFROM;
		saveitems = items;
		str = SvPV(fromstr, fromlen);
		if (pat[-1] == '*')
		    len = fromlen;
		aint = SvCUR(cat);
		SvCUR(cat) += (len+7)/8;
		SvGROW(cat, SvCUR(cat) + 1);
		aptr = SvPVX(cat) + aint;
		if (len > fromlen)
		    len = fromlen;
		aint = len;
		items = 0;
		if (datumtype == 'B') {
		    for (len = 0; len++ < aint;) {
			items |= *str++ & 1;
			if (len & 7)
			    items <<= 1;
			else {
			    *aptr++ = items & 0xff;
			    items = 0;
			}
		    }
		}
		else {
		    for (len = 0; len++ < aint;) {
			if (*str++ & 1)
			    items |= 128;
			if (len & 7)
			    items >>= 1;
			else {
			    *aptr++ = items & 0xff;
			    items = 0;
			}
		    }
		}
		if (aint & 7) {
		    if (datumtype == 'B')
			items <<= 7 - (aint & 7);
		    else
			items >>= 7 - (aint & 7);
		    *aptr++ = items & 0xff;
		}
		str = SvPVX(cat) + SvCUR(cat);
		while (aptr <= str)
		    *aptr++ = '\0';

		items = saveitems;
	    }
	    break;
	case 'H':
	case 'h':
	    {
		register char *str;
		I32 saveitems;

		fromstr = NEXTFROM;
		saveitems = items;
		str = SvPV(fromstr, fromlen);
		if (pat[-1] == '*')
		    len = fromlen;
		aint = SvCUR(cat);
		SvCUR(cat) += (len+1)/2;
		SvGROW(cat, SvCUR(cat) + 1);
		aptr = SvPVX(cat) + aint;
		if (len > fromlen)
		    len = fromlen;
		aint = len;
		items = 0;
		if (datumtype == 'H') {
		    for (len = 0; len++ < aint;) {
			if (isALPHA(*str))
			    items |= ((*str++ & 15) + 9) & 15;
			else
			    items |= *str++ & 15;
			if (len & 1)
			    items <<= 4;
			else {
			    *aptr++ = items & 0xff;
			    items = 0;
			}
		    }
		}
		else {
		    for (len = 0; len++ < aint;) {
			if (isALPHA(*str))
			    items |= (((*str++ & 15) + 9) & 15) << 4;
			else
			    items |= (*str++ & 15) << 4;
			if (len & 1)
			    items >>= 4;
			else {
			    *aptr++ = items & 0xff;
			    items = 0;
			}
		    }
		}
		if (aint & 1)
		    *aptr++ = items & 0xff;
		str = SvPVX(cat) + SvCUR(cat);
		while (aptr <= str)
		    *aptr++ = '\0';

		items = saveitems;
	    }
	    break;
	case 'C':
	case 'c':
	    while (len-- > 0) {
		fromstr = NEXTFROM;
		aint = SvIV(fromstr);
		achar = aint;
		sv_catpvn(cat, &achar, sizeof(char));
	    }
	    break;
	case 'U':
	    while (len-- > 0) {
		fromstr = NEXTFROM;
		auint = SvUV(fromstr);
		SvGROW(cat, SvCUR(cat) + UTF8_MAXLEN + 1);
		SvCUR_set(cat, (char*)uv_to_utf8((U8*)SvEND(cat),auint)
			       - SvPVX(cat));
	    }
	    *SvEND(cat) = '\0';
	    break;
	/* Float and double added by gnb@@melba.bby.oz.au  22/11/89 */
	case 'f':
	case 'F':
	    while (len-- > 0) {
		fromstr = NEXTFROM;
		afloat = (float)SvNV(fromstr);
		sv_catpvn(cat, (char *)&afloat, sizeof (float));
	    }
	    break;
	case 'd':
	case 'D':
	    while (len-- > 0) {
		fromstr = NEXTFROM;
		adouble = (double)SvNV(fromstr);
		sv_catpvn(cat, (char *)&adouble, sizeof (double));
	    }
	    break;
	case 'n':
	    while (len-- > 0) {
		fromstr = NEXTFROM;
		ashort = (I16)SvIV(fromstr);
#ifdef HAS_HTONS
		ashort = PerlSock_htons(ashort);
#endif
		CAT16(cat, &ashort);
	    }
	    break;
	case 'v':
	    while (len-- > 0) {
		fromstr = NEXTFROM;
		ashort = (I16)SvIV(fromstr);
#ifdef HAS_HTOVS
		ashort = htovs(ashort);
#endif
		CAT16(cat, &ashort);
	    }
	    break;
	case 'S':
#if SHORTSIZE != SIZE16
	    if (natint) {
		unsigned short aushort;

		while (len-- > 0) {
		    fromstr = NEXTFROM;
		    aushort = SvUV(fromstr);
		    sv_catpvn(cat, (char *)&aushort, sizeof(unsigned short));
		}
	    }
	    else
#endif
            {
		U16 aushort;

		while (len-- > 0) {
		    fromstr = NEXTFROM;
		    aushort = (U16)SvUV(fromstr);
		    CAT16(cat, &aushort);
		}

	    }
	    break;
	case 's':
#if SHORTSIZE != SIZE16
	    if (natint) {
		short ashort;

		while (len-- > 0) {
		    fromstr = NEXTFROM;
		    ashort = SvIV(fromstr);
		    sv_catpvn(cat, (char *)&ashort, sizeof(short));
		}
	    }
	    else
#endif
            {
		while (len-- > 0) {
		    fromstr = NEXTFROM;
		    ashort = (I16)SvIV(fromstr);
		    CAT16(cat, &ashort);
		}
	    }
	    break;
	case 'I':
	    while (len-- > 0) {
		fromstr = NEXTFROM;
		auint = SvUV(fromstr);
		sv_catpvn(cat, (char*)&auint, sizeof(unsigned int));
	    }
	    break;
	case 'w':
            while (len-- > 0) {
		fromstr = NEXTFROM;
		adouble = Perl_floor(SvNV(fromstr));

		if (adouble < 0)
		    DIE(aTHX_ "Cannot compress negative numbers");

		if (
#if UVSIZE > 4 && UVSIZE >= NVSIZE
		    adouble <= 0xffffffff
#else
#   ifdef CXUX_BROKEN_CONSTANT_CONVERT
		    adouble <= UV_MAX_cxux
#   else
		    adouble <= UV_MAX
#   endif
#endif
		    )
		{
		    char   buf[1 + sizeof(UV)];
		    char  *in = buf + sizeof(buf);
		    UV     auv = U_V(adouble);

		    do {
			*--in = (auv & 0x7f) | 0x80;
			auv >>= 7;
		    } while (auv);
		    buf[sizeof(buf) - 1] &= 0x7f; /* clear continue bit */
		    sv_catpvn(cat, in, (buf + sizeof(buf)) - in);
		}
		else if (SvPOKp(fromstr)) {  /* decimal string arithmetics */
		    char           *from, *result, *in;
		    SV             *norm;
		    STRLEN          len;
		    bool            done;

		    /* Copy string and check for compliance */
		    from = SvPV(fromstr, len);
		    if ((norm = is_an_int(from, len)) == NULL)
			DIE(aTHX_ "can compress only unsigned integer");

		    New('w', result, len, char);
		    in = result + len;
		    done = FALSE;
		    while (!done)
			*--in = div128(norm, &done) | 0x80;
		    result[len - 1] &= 0x7F; /* clear continue bit */
		    sv_catpvn(cat, in, (result + len) - in);
		    Safefree(result);
		    SvREFCNT_dec(norm);	/* free norm */
                }
		else if (SvNOKp(fromstr)) {
		    char   buf[sizeof(double) * 2];	/* 8/7 <= 2 */
		    char  *in = buf + sizeof(buf);

		    do {
			double next = floor(adouble / 128);
			*--in = (unsigned char)(adouble - (next * 128)) | 0x80;
			if (in <= buf)  /* this cannot happen ;-) */
			    DIE(aTHX_ "Cannot compress integer");
			in--;
			adouble = next;
		    } while (adouble > 0);
		    buf[sizeof(buf) - 1] &= 0x7f; /* clear continue bit */
		    sv_catpvn(cat, in, (buf + sizeof(buf)) - in);
		}
		else
		    DIE(aTHX_ "Cannot compress non integer");
	    }
            break;
	case 'i':
	    while (len-- > 0) {
		fromstr = NEXTFROM;
		aint = SvIV(fromstr);
		sv_catpvn(cat, (char*)&aint, sizeof(int));
	    }
	    break;
	case 'N':
	    while (len-- > 0) {
		fromstr = NEXTFROM;
		aulong = SvUV(fromstr);
#ifdef HAS_HTONL
		aulong = PerlSock_htonl(aulong);
#endif
		CAT32(cat, &aulong);
	    }
	    break;
	case 'V':
	    while (len-- > 0) {
		fromstr = NEXTFROM;
		aulong = SvUV(fromstr);
#ifdef HAS_HTOVL
		aulong = htovl(aulong);
#endif
		CAT32(cat, &aulong);
	    }
	    break;
	case 'L':
#if LONGSIZE != SIZE32
	    if (natint) {
		unsigned long aulong;

		while (len-- > 0) {
		    fromstr = NEXTFROM;
		    aulong = SvUV(fromstr);
		    sv_catpvn(cat, (char *)&aulong, sizeof(unsigned long));
		}
	    }
	    else
#endif
            {
		while (len-- > 0) {
		    fromstr = NEXTFROM;
		    aulong = SvUV(fromstr);
		    CAT32(cat, &aulong);
		}
	    }
	    break;
	case 'l':
#if LONGSIZE != SIZE32
	    if (natint) {
		long along;

		while (len-- > 0) {
		    fromstr = NEXTFROM;
		    along = SvIV(fromstr);
		    sv_catpvn(cat, (char *)&along, sizeof(long));
		}
	    }
	    else
#endif
            {
		while (len-- > 0) {
		    fromstr = NEXTFROM;
		    along = SvIV(fromstr);
		    CAT32(cat, &along);
		}
	    }
	    break;
#ifdef HAS_QUAD
	case 'Q':
	    while (len-- > 0) {
		fromstr = NEXTFROM;
		auquad = (Uquad_t)SvUV(fromstr);
		sv_catpvn(cat, (char*)&auquad, sizeof(Uquad_t));
	    }
	    break;
	case 'q':
	    while (len-- > 0) {
		fromstr = NEXTFROM;
		aquad = (Quad_t)SvIV(fromstr);
		sv_catpvn(cat, (char*)&aquad, sizeof(Quad_t));
	    }
	    break;
#endif
	case 'P':
	    len = 1;		/* assume SV is correct length */
	    /* FALL THROUGH */
	case 'p':
	    while (len-- > 0) {
		fromstr = NEXTFROM;
		if (fromstr == &PL_sv_undef)
		    aptr = NULL;
		else {
		    STRLEN n_a;
		    /* XXX better yet, could spirit away the string to
		     * a safe spot and hang on to it until the result
		     * of pack() (and all copies of the result) are
		     * gone.
		     */
		    if (ckWARN(WARN_PACK) && (SvTEMP(fromstr)
						|| (SvPADTMP(fromstr)
						    && !SvREADONLY(fromstr))))
		    {
			Perl_warner(aTHX_ WARN_PACK,
				"Attempt to pack pointer to temporary value");
		    }
		    if (SvPOK(fromstr) || SvNIOK(fromstr))
			aptr = SvPV(fromstr,n_a);
		    else
			aptr = SvPV_force(fromstr,n_a);
		}
		sv_catpvn(cat, (char*)&aptr, sizeof(char*));
	    }
	    break;
	case 'u':
	    fromstr = NEXTFROM;
	    aptr = SvPV(fromstr, fromlen);
	    SvGROW(cat, fromlen * 4 / 3);
	    if (len <= 1)
		len = 45;
	    else
		len = len / 3 * 3;
	    while (fromlen > 0) {
		I32 todo;

		if (fromlen > len)
		    todo = len;
		else
		    todo = fromlen;
		doencodes(cat, aptr, todo);
		fromlen -= todo;
		aptr += todo;
	    }
	    break;
	}
    }
    SvSETMAGIC(cat);
    SP = ORIGMARK;
    PUSHs(cat);
    RETURN;
}
#undef NEXTFROM


d4387 1
a4387 1
    rx = pm->op_pmregexp;
d4392 2
d4396 1
a4396 1
	ary = GvAVn((GV*)PL_curpad[(PADOFFSET)pm->op_pmreplroot]);
d4402 1
a4402 1
#ifdef USE_THREADS
d4406 1
a4406 1
#endif /* USE_THREADS */
d4415 1
a4415 1
	if ((mg = SvTIED_mg((SV*)ary, 'P'))) {
d4492 2
a4493 1
    else if ((rx->reganch & RE_USE_INTUIT) && !rx->nparens
d4549 1
a4549 1
/*	       && (!rx->check_substr 
d4572 1
a4572 1
		for (i = 1; i <= rx->nparens; i++) {
d4575 5
a4579 1
		    if (m && s) {
d4584 1
a4584 1
			dstr = NEWSV(33, 0);
d4662 1
a4662 1
#ifdef USE_THREADS
d4666 1
a4666 1
    MAGIC *mg = mg_find((SV*)svv, 'm');
d4676 1
a4676 1
			  PTR2UV(thr), PTR2UV(svv));)
d4679 1
a4679 1
#endif /* USE_THREADS */
d4686 1
a4686 3
#ifdef USE_THREADS
    sv_lock(sv);
#endif /* USE_THREADS */
d4697 1
a4697 1
#ifdef USE_THREADS
d4707 1
a4707 1
#endif /* USE_THREADS */
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2000, Larry Wall
a84 4
#ifdef I_UNISTD
#include <unistd.h>
#endif

d95 1
a95 1
    djSP;
d110 1
a110 1
    djSP; dTARGET;
d117 5
d149 1
a149 1
    djSP; dTARGET;
d157 5
d187 1
a187 1
    djSP; dTOPss;  
d207 1
a207 1
	    STRLEN n_a;
d245 1
a245 1
	    sym = SvPV(sv, n_a);
d250 4
a253 1
		if (!sv)
d255 1
d272 1
a272 1
    djSP; dTOPss;
d289 1
a289 1
	STRLEN n_a;
d305 1
a305 1
	    sym = SvPV(sv, n_a);
d310 4
a313 1
		if (!gv)
d315 1
d337 1
a337 1
    djSP;
d351 1
a351 1
    djSP; dTARGET; dPOPss;
d353 1
a353 1
    if (PL_op->op_flags & OPf_MOD) {
d387 1
a387 1
    djSP;
d397 6
a402 2
	if ((PL_op->op_private & OPpLVAL_INTRO) && !CvLVALUE(cv))
	    DIE(aTHX_ "Can't modify non-lvalue subroutine call");
d412 1
a412 1
    djSP;
d478 1
a478 1
    djSP;
d489 1
a489 1
    djSP;
d496 1
a496 1
    djSP; dMARK;
d546 1
a546 1
    djSP; dTARGET;
d566 1
a566 1
    djSP;
d591 1
a591 1
    djSP;
d652 1
a652 1
    djSP; dPOPss;
d714 1
a714 1
    djSP; dTARG;
d732 1
a732 1
    djSP; dTARGET;
d740 4
a743 3
    djSP; dMARK; dTARGET;
    while (SP > MARK)
	do_chop(TARG, POPs);
d750 1
a750 1
    djSP; dTARGET;
d757 1
a757 1
    djSP; dMARK; dTARGET;
d768 1
a768 1
    djSP;
d798 1
a798 1
    djSP;
d830 1
a830 1
	    GV* gv = (GV*)SvREFCNT_inc(CvGV((CV*)sv));
d865 1
a865 1
    djSP;
d882 1
a882 1
    djSP; dTARGET;
d903 1
a903 1
    djSP; dTARGET;
d924 1
a924 1
    djSP; dATARGET; tryAMAGICbin(pow,opASSIGN);
d934 1
a934 1
    djSP; dATARGET; tryAMAGICbin(mult,opASSIGN);
d944 1
a944 1
    djSP; dATARGET; tryAMAGICbin(div,opASSIGN);
d973 1
a973 1
    djSP; dATARGET; tryAMAGICbin(modulo,opASSIGN);
d983 1
a983 1
	if (SvIOK(TOPs) && !SvNOK(TOPs) && !SvPOK(TOPs)) {
d995 1
a995 1
	if (!use_double && SvIOK(TOPs) && !SvNOK(TOPs) && !SvPOK(TOPs)) {
d1073 1
a1073 1
  djSP; dATARGET; tryAMAGICbin(repeat,opASSIGN);
d1075 1
a1075 1
    register I32 count = POPi;
d1098 1
a1098 1
	SV *tmpstr;
d1100 1
a1101 1
	tmpstr = POPs;
d1104 1
d1115 4
a1118 1
	(void)SvPOK_only(TARG);
d1127 1
a1127 1
    djSP; dATARGET; tryAMAGICbin(subtr,opASSIGN);
d1137 1
a1137 1
    djSP; dATARGET; tryAMAGICbin(lshift,opASSIGN);
d1154 1
a1154 1
    djSP; dATARGET; tryAMAGICbin(rshift,opASSIGN);
d1171 1
a1171 1
    djSP; tryAMAGICbinSET(lt,0);
d1181 1
a1181 1
    djSP; tryAMAGICbinSET(gt,0);
d1191 1
a1191 1
    djSP; tryAMAGICbinSET(le,0);
d1201 1
a1201 1
    djSP; tryAMAGICbinSET(ge,0);
d1211 1
a1211 1
    djSP; tryAMAGICbinSET(ne,0);
d1221 1
a1221 1
    djSP; dTARGET; tryAMAGICbin(ncmp,0);
a1224 7
#ifdef __osf__ /* XXX Configure probe for isnan and isnanl needed XXX */
#if defined(USE_LONG_DOUBLE) && defined(HAS_LONG_DOUBLE)
#define Perl_isnan isnanl
#else
#define Perl_isnan isnan
#endif
#endif
d1226 1
a1226 1
#ifdef __osf__ /* XXX fix in 5.6.1 --jhi */
d1251 1
a1251 1
    djSP; tryAMAGICbinSET(slt,0);
d1264 1
a1264 1
    djSP; tryAMAGICbinSET(sgt,0);
d1277 1
a1277 1
    djSP; tryAMAGICbinSET(sle,0);
d1290 1
a1290 1
    djSP; tryAMAGICbinSET(sge,0);
d1303 1
a1303 1
    djSP; tryAMAGICbinSET(seq,0);
d1313 1
a1313 1
    djSP; tryAMAGICbinSET(sne,0);
d1323 1
a1323 1
    djSP; dTARGET;  tryAMAGICbin(scmp,0);
d1336 1
a1336 1
    djSP; dATARGET; tryAMAGICbin(band,opASSIGN);
d1359 1
a1359 1
    djSP; dATARGET; tryAMAGICbin(bxor,opASSIGN);
d1382 1
a1382 1
    djSP; dATARGET; tryAMAGICbin(bor,opASSIGN);
d1405 1
a1405 1
    djSP; dTARGET; tryAMAGICun(neg);
d1439 1
a1439 1
	    else if (DO_UTF8(sv) && *(U8*)s >= 0xc0 && isIDFIRST_utf8((U8*)s)) {
d1455 1
a1455 1
    djSP; tryAMAGICunSET(not);
d1462 1
a1462 1
    djSP; dTARGET; tryAMAGICun(compl);
d1476 1
a1476 2
	register char *tmps;
	register long *tmpl;
d1481 1
a1481 1
	tmps = SvPV_force(TARG, len);
d1483 49
d1533 9
a1541 6
	for ( ; anum && (unsigned long)tmps % sizeof(long); anum--, tmps++)
	    *tmps = ~*tmps;
	tmpl = (long*)tmps;
	for ( ; anum >= sizeof(long); anum -= sizeof(long), tmpl++)
	    *tmpl = ~*tmpl;
	tmps = (char*)tmpl;
d1556 1
a1556 1
    djSP; dATARGET; tryAMAGICbin(mult,opASSIGN);
d1566 1
a1566 1
    djSP; dATARGET; tryAMAGICbin(div,opASSIGN);
d1579 1
a1579 1
    djSP; dATARGET; tryAMAGICbin(modulo,opASSIGN); 
d1591 1
a1591 1
    djSP; dATARGET; tryAMAGICbin(add,opASSIGN);
d1593 1
a1593 1
      dPOPTOPiirl;
d1601 1
a1601 1
    djSP; dATARGET; tryAMAGICbin(subtr,opASSIGN);
d1603 1
a1603 1
      dPOPTOPiirl;
d1611 1
a1611 1
    djSP; tryAMAGICbinSET(lt,0);
d1621 1
a1621 1
    djSP; tryAMAGICbinSET(gt,0);
d1631 1
a1631 1
    djSP; tryAMAGICbinSET(le,0);
d1641 1
a1641 1
    djSP; tryAMAGICbinSET(ge,0);
d1651 1
a1651 1
    djSP; tryAMAGICbinSET(eq,0);
d1661 1
a1661 1
    djSP; tryAMAGICbinSET(ne,0);
d1671 1
a1671 1
    djSP; dTARGET; tryAMAGICbin(ncmp,0);
d1689 1
a1689 1
    djSP; dTARGET; tryAMAGICun(neg);
d1698 1
a1698 1
    djSP; dTARGET; tryAMAGICbin(atan2,0);
d1708 1
a1708 1
    djSP; dTARGET; tryAMAGICun(sin);
d1720 1
a1720 1
    djSP; dTARGET; tryAMAGICun(cos);
d1747 1
a1747 1
    djSP; dTARGET;
d1766 1
a1766 1
    djSP;
a1802 1
    dTHR;
d1861 1
a1861 1
    djSP; dTARGET; tryAMAGICun(exp);
d1873 1
a1873 1
    djSP; dTARGET; tryAMAGICun(log);
d1878 1
a1878 1
	RESTORE_NUMERIC_STANDARD();
d1889 1
a1889 1
    djSP; dTARGET; tryAMAGICun(sqrt);
d1894 1
a1894 1
	RESTORE_NUMERIC_STANDARD();
d1905 1
a1905 1
    djSP; dTARGET;
d1915 9
a1923 2
	if (value >= 0.0)
	  (void)Perl_modf(value, &value);
d1925 8
a1932 2
	  (void)Perl_modf(-value, &value);
	  value = -value;
d1946 1
a1946 1
    djSP; dTARGET; tryAMAGICun(abs);
d1968 1
a1968 1
    djSP; dTARGET;
d1970 2
a1971 2
    I32 argtype;
    STRLEN n_a;
d1973 3
a1975 2
    tmps = POPpx;
    XPUSHn(scan_hex(tmps, 99, &argtype));
d1981 1
a1981 1
    djSP; dTARGET;
d1983 1
a1983 1
    I32 argtype;
d1985 1
a1985 1
    STRLEN n_a;
d1987 3
a1989 3
    tmps = POPpx;
    while (*tmps && isSPACE(*tmps))
	tmps++;
d1991 2
a1992 1
	tmps++;
d1994 1
a1994 1
	value = scan_hex(++tmps, 99, &argtype);
d1996 1
a1996 1
	value = scan_bin(++tmps, 99, &argtype);
d1998 1
a1998 1
	value = scan_oct(tmps, 99, &argtype);
d2007 1
a2007 1
    djSP; dTARGET;
d2019 1
a2019 1
    djSP; dTARGET;
d2023 1
a2023 1
    STRLEN utfcurlen;
d2027 1
a2027 1
    I32 lvalue = PL_op->op_flags & OPf_MOD;
d2030 1
d2033 3
d2039 5
a2043 4
    if (MAXARG > 2) {
	if (MAXARG > 3) {
	    sv = POPs;
	    repl = SvPV(sv, repl_len);
d2050 8
d2060 3
a2062 3
        utfcurlen = sv_len_utf8(sv);
	if (utfcurlen == curlen)
	    utfcurlen = 0;
d2064 1
a2064 1
	    curlen = utfcurlen;
d2067 1
a2067 1
	utfcurlen = 0;
d2073 1
a2073 1
	if (MAXARG > 2) {
d2085 1
a2085 1
	if (MAXARG < 3)
d2110 3
a2112 1
        if (utfcurlen) {
a2113 2
	    SvUTF8_on(TARG);
	}
d2116 11
a2126 1
	if (repl)
d2128 5
d2143 1
a2143 1
		    (void)SvPOK_only(sv);
d2159 2
a2160 2
	    LvTARGOFF(TARG) = pos;
	    LvTARGLEN(TARG) = rem;
d2170 3
a2172 3
    djSP; dTARGET;
    register I32 size = POPi;
    register I32 offset = POPi;
d2174 1
a2174 1
    I32 lvalue = PL_op->op_flags & OPf_MOD;
d2199 1
a2199 1
    djSP; dTARGET;
d2235 1
a2235 1
    djSP; dTARGET;
d2276 1
a2276 1
    djSP; dMARK; dORIGMARK; dTARGET;
d2286 4
a2289 6
    djSP; dTARGET;
    UV value;
    STRLEN n_a;
    SV *tmpsv = POPs;
    U8 *tmps = (U8*)SvPVx(tmpsv,n_a);
    I32 retlen;
d2291 1
a2291 5
    if ((*tmps & 0x80) && DO_UTF8(tmpsv))
	value = utf8_to_uv(tmps, &retlen);
    else
	value = (UV)(*tmps & 255);
    XPUSHu(value);
d2297 1
a2297 1
    djSP; dTARGET;
d2299 1
a2299 1
    U32 value = POPu;
a2319 1
    SvUTF8_off(TARG);				/* decontaminate */
d2327 1
a2327 1
    djSP; dTARGET; dPOPTOPssrl;
d2346 1
a2346 1
    djSP;
d2351 3
a2353 3
    if (DO_UTF8(sv) && (s = (U8*)SvPV(sv, slen)) && slen && (*s & 0xc0) == 0xc0) {
	I32 ulen;
	U8 tmpbuf[UTF8_MAXLEN];
d2355 1
a2355 1
	UV uv = utf8_to_uv(s, &ulen);
d2405 1
a2405 1
    djSP;
d2410 3
a2412 3
    if (DO_UTF8(sv) && (s = (U8*)SvPV(sv, slen)) && slen && (*s & 0xc0) == 0xc0) {
	I32 ulen;
	U8 tmpbuf[UTF8_MAXLEN];
d2414 1
a2414 1
	UV uv = utf8_to_uv(s, &ulen);
d2464 1
a2464 1
    djSP;
d2471 1
a2471 1
	I32 ulen;
d2491 1
a2491 1
		    d = uv_to_utf8(d, toUPPER_LC_uni( utf8_to_uv(s, &ulen)));
d2538 1
a2538 1
    djSP;
d2545 1
a2545 1
	I32 ulen;
d2565 1
a2565 1
		    d = uv_to_utf8(d, toLOWER_LC_uni( utf8_to_uv(s, &ulen)));
d2613 1
a2613 1
    djSP; dTARGET;
d2626 1
a2626 1
		if (*s & 0x80) {
d2652 1
a2652 1
	(void)SvPOK_only(TARG);
d2666 1
a2666 1
    djSP; dMARK; dORIGMARK;
d2669 1
a2669 1
    register I32 lval = PL_op->op_flags & OPf_MOD;
d2711 1
a2711 1
    djSP;
d2753 1
a2753 1
    djSP;
d2817 1
a2817 1
    djSP;
d2854 1
a2854 1
    djSP; dMARK; dORIGMARK;
d2856 1
a2856 1
    register I32 lval = PL_op->op_flags & OPf_MOD;
d2896 1
a2896 1
    djSP; dMARK;
d2909 1
a2909 1
    djSP;
d2964 1
a2964 1
    djSP; dMARK; dORIGMARK;
d2974 1
a2974 1
    djSP; dMARK; dORIGMARK;
d2993 1
a2993 1
    djSP; dMARK; dORIGMARK;
d3195 1
a3195 1
    djSP; dMARK; dORIGMARK; dTARGET;
d3225 1
a3225 1
    djSP;
d3236 1
a3236 1
    djSP;
d3250 1
a3250 1
    djSP; dMARK; dORIGMARK; dTARGET;
d3280 1
a3280 1
    djSP; dMARK;
d3312 1
a3312 1
		    if (*s < 0x80) {
d3317 2
d3322 1
a3322 6
			if (s > send || !((*down & 0xc0) == 0x80)) {
			    if (ckWARN_d(WARN_UTF8))
				Perl_warner(aTHX_ WARN_UTF8,
					    "Malformed UTF-8 character");
			    break;
			}
d3338 1
a3338 1
	    (void)SvPOK_only(TARG);
d3388 1
a3388 1
    djSP;
d3406 1
a3406 1
    I16 ashort;
d3408 1
a3408 1
    I32 along;
d3704 3
a3706 1
		    auint = utf8_to_uv((U8*)s, &along);
d3718 3
a3720 1
		    auint = utf8_to_uv((U8*)s, &along);
a3960 1
		    long along;
d3974 3
a3994 1
		    long along;
d4007 3
d4131 1
a4131 1
		    if (!(*s++ & 0x80)) {
d4143 1
a4143 1
			sv = Perl_newSVpvf(aTHX_ "%.*Vu", (int)TYPE_DIGITS(UV), auv);
d4475 1
a4475 1
    djSP; dMARK; dORIGMARK; dTARGET;
d4480 1
d4511 1
d4519 2
a4520 1
	if (isSPACE(datumtype))
d4522 3
d4561 2
a4562 1
						   ? *MARK : &PL_sv_no)));
d4756 1
a4756 1
		SvGROW(cat, SvCUR(cat) + UTF8_MAXLEN);
d4860 4
a4863 1
#ifdef CXUX_BROKEN_CONSTANT_CONVERT
d4865 1
a4865 1
#else
d4867 1
d4910 1
a4910 1
			if (--in < buf)  /* this cannot happen ;-) */
d4912 1
d5069 1
a5069 1
    djSP; dTARG;
d5071 1
a5071 1
    register I32 limit = POPi;			/* note, negative is forever */
d5075 1
d5082 2
a5083 1
    I32 maxiters = (strend - s) + 10;
d5101 1
a5101 1
	DIE(aTHX_ "panic: do_split");
d5177 2
d5199 2
a5209 1
	char c;
d5212 3
a5214 2
	if (len == 1 && !tail) {
	    c = *SvPV(csv,len);
d5224 2
d5227 6
a5232 1
		s = m + 1;
d5246 2
d5249 6
a5254 1
		s = m + len;		/* Fake \n at the end */
d5259 1
a5259 1
	maxiters += (strend - s) * rx->nparens;
d5280 2
d5295 2
d5311 3
a5313 2
	dstr = NEWSV(34, strend-s);
	sv_setpvn(dstr, s, strend-s);
d5316 2
a5373 1
    dTHR;
d5391 1
a5391 1
    djSP;
d5395 1
a5395 18
    MAGIC *mg;

    if (SvROK(sv))
	sv = SvRV(sv);

    mg = condpair_magic(sv);
    MUTEX_LOCK(MgMUTEXP(mg));
    if (MgOWNER(mg) == thr)
	MUTEX_UNLOCK(MgMUTEXP(mg));
    else {
	while (MgOWNER(mg))
	    COND_WAIT(MgOWNERCONDP(mg), MgMUTEXP(mg));
	MgOWNER(mg) = thr;
	DEBUG_S(PerlIO_printf(Perl_debug_log, "0x%"UVxf": pp_lock lock 0x%"UVxf"\n",
			      PTR2UV(thr), PTR2UV(sv));)
	MUTEX_UNLOCK(MgMUTEXP(mg));
	SAVEDESTRUCTOR_X(Perl_unlock_condpair, sv);
    }
d5408 1
a5408 1
    djSP;
@


1.3
log
@perl5.005_03 (stock)
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1999, Larry Wall
d16 1
a30 31
 * Types used in bitwise operations.
 *
 * Normally we'd just use IV and UV.  However, some hardware and
 * software combinations (e.g. Alpha and current OSF/1) don't have a
 * floating-point type to use for NV that has adequate bits to fully
 * hold an IV/UV.  (In other words, sizeof(long) == sizeof(double).)
 *
 * It just so happens that "int" is the right size almost everywhere.
 */
typedef int IBW;
typedef unsigned UBW;

/*
 * Mask used after bitwise operations.
 *
 * There is at least one realm (Cray word machines) that doesn't
 * have an integral type (except char) small enough to be represented
 * in a double without loss; that is, it has no 32-bit type.
 */
#if LONGSIZE > 4  && defined(_CRAY) && !defined(_CRAYMPP)
#  define BW_BITS  32
#  define BW_MASK  ((1 << BW_BITS) - 1)
#  define BW_SIGN  (1 << (BW_BITS - 1))
#  define BWi(i)  (((i) & BW_SIGN) ? ((i) | ~BW_MASK) : ((i) & BW_MASK))
#  define BWu(u)  ((u) & BW_MASK)
#else
#  define BWi(i)  (i)
#  define BWu(u)  (u)
#endif

/*
d51 8
a58 1
#if BYTEORDER > 0xFFFF && defined(_CRAY) && !defined(_CRAYMPP)
d72 1
d78 1
a82 8
#ifndef PERL_OBJECT
static void doencodes _((SV* sv, char* s, I32 len));
static SV* refto _((SV* sv));
static U32 seed _((void));
static bool srand_called = FALSE;
#endif


d158 1
a158 1
	RETURNOP(do_kv(ARGS));
d163 1
a163 1
	    sv_setpvf(sv, "%ld/%ld",
d174 1
a174 1
    DIE("NOT IMPL LINE %d",__LINE__);
d181 1
a181 1
    djSP; dTOPss;
d185 2
d194 3
a196 2
	} else if (SvTYPE(sv) != SVt_PVGV)
	    DIE("Not a GLOB reference");
d208 24
a231 1
	    if (!SvOK(sv)) {
d234 3
a236 3
		    DIE(no_usym, "a symbol");
		if (PL_dowarn)
		    warn(warn_uninit);
d240 12
a251 3
	    if (PL_op->op_private & HINT_STRICT_REFS)
		DIE(no_symref, sym, "a symbol");
	    sv = (SV*)gv_fetchpv(sym, TRUE, SVt_PVGV);
d266 2
d273 1
a273 1
	    DIE("Not a SCALAR reference");
d290 3
a292 3
		    DIE(no_usym, "a SCALAR");
		if (PL_dowarn)
		    warn(warn_uninit);
d296 12
a307 3
	    if (PL_op->op_private & HINT_STRICT_REFS)
		DIE(no_symref, sym, "a SCALAR");
	    gv = (GV*)gv_fetchpv(sym, TRUE, SVt_PV);
d360 4
a363 1
		PUSHi(mg->mg_len + PL_curcop->cop_arybase);
d383 2
d414 3
a416 1
		    if (strEQ(s + 6, op_name[i]) || strEQ(s + 6, op_desc[i]))
d418 1
d423 1
a423 1
		oa = opargs[i] >> OASHIFT;
d428 2
a429 1
		    } else if (seen_question) 
d440 3
a442 2
		ret = sv_2mortal(newSVpv(str, n - 1));
	    } else if (code)		/* Non-Overridable */
d446 1
a446 1
		croak("Cannot find an opnumber for \"%s\"", s+6);
d452 1
a452 1
	ret = sv_2mortal(newSVpv(SvPVX(cv), SvCUR(cv)));
d495 1
a495 1
refto(SV *sv)
d504 8
d552 1
a552 1
	stash = PL_curcop->cop_stash;
d557 3
a559 2
	if (PL_dowarn && len == 0)
	    warn("Explicit blessing to '' (assuming package main)");
d575 1
a575 1

d609 1
a609 1
	    sv = newSVpv(GvNAME(gv), GvNAMELEN(gv));
a634 1
    register UNOP *unop = cUNOP;
d674 1
a674 1
	DIE("do_study: out of memory");
d706 1
a706 1
    PUSHi(do_trans(sv, PL_op));
d791 2
a792 9
    if (SvTHINKFIRST(sv)) {
	if (SvREADONLY(sv)) {
	    dTHR;
	    if (PL_curcop != &PL_compiling)
		croak(no_modify);
	}
	if (SvROK(sv))
	    sv_unref(sv);
    }
d804 2
a805 2
	if (PL_dowarn && cv_const_sv((CV*)sv))
	    warn("Constant subroutine %s undefined",
d809 6
a814 3
	{ GV* gv = (GV*)SvREFCNT_inc(CvGV((CV*)sv));
	  cv_undef((CV*)sv);
	  CvGV((CV*)sv) = gv; }   /* let user-undef'd sub keep its identity */
d825 1
a825 1
	    GvLINE(sv) = PL_curcop->cop_line;
d848 2
a849 2
	croak(no_modify);
    if (SvIOK(TOPs) && !SvNOK(TOPs) && !SvPOK(TOPs) &&
d865 1
a865 1
	croak(no_modify);
d867 1
a867 1
    if (SvIOK(TOPs) && !SvNOK(TOPs) && !SvPOK(TOPs) &&
d885 2
a886 2
    if(SvREADONLY(TOPs) || SvTYPE(TOPs) > SVt_PVLV)
	croak(no_modify);
d888 1
a888 1
    if (SvIOK(TOPs) && !SvNOK(TOPs) && !SvPOK(TOPs) &&
d908 1
a908 1
      SETn( pow( left, right) );
d928 1
a928 1
      double value;
d930 1
a930 1
	DIE("Illegal division by zero");
d935 2
a936 2
	if ((double)I_V(left)  == left &&
	    (double)I_V(right) == right &&
d939 2
a940 1
	} else {
d956 19
a974 14
      UV left;
      UV right;
      bool left_neg;
      bool right_neg;
      UV ans;

      if (SvIOK(TOPs) && !SvNOK(TOPs) && !SvPOK(TOPs)) {
	IV i = SvIVX(POPs);
	right = (right_neg = (i < 0)) ? -i : i;
      }
      else {
	double n = POPn;
	right = U_V((right_neg = (n < 0)) ? -n : n);
      }
d976 35
a1010 8
      if (SvIOK(TOPs) && !SvNOK(TOPs) && !SvPOK(TOPs)) {
	IV i = SvIVX(POPs);
	left = (left_neg = (i < 0)) ? -i : i;
      }
      else {
	double n = POPn;
	left = U_V((left_neg = (n < 0)) ? -n : n);
      }
d1012 16
a1027 2
      if (!right)
	DIE("Illegal modulus zero");
d1029 20
a1048 15
      ans = left % right;
      if ((left_neg != right_neg) && ans)
	ans = right - ans;
      if (right_neg) {
	/* XXX may warn: unary minus operator applied to unsigned type */
	/* could change -foo to be (~foo)+1 instead	*/
	if (ans <= ~((UV)IV_MAX)+1)
	  sv_setiv(TARG, ~ans+1);
	else
	  sv_setnv(TARG, -(double)ans);
      }
      else
	sv_setuv(TARG, ans);
      PUSHTARG;
      RETURN;
a1082 6
	if (TARG == tmpstr && SvTHINKFIRST(tmpstr)) {
	    if (SvREADONLY(tmpstr) && PL_curcop != &PL_compiling)
		DIE("Can't x= to readonly value");
	    if (SvROK(tmpstr))
		sv_unref(tmpstr);
	}
d1116 1
a1116 1
      IBW shift = POPi;
d1118 2
a1119 3
	IBW i = TOPi;
	i = BWi(i) << shift;
	SETi(BWi(i));
d1122 2
a1123 3
	UBW u = TOPu;
	u <<= shift;
	SETu(BWu(u));
d1133 1
a1133 1
      IBW shift = POPi;
d1135 2
a1136 3
	IBW i = TOPi;
	i = BWi(i) >> shift;
	SETi(BWi(i));
d1139 2
a1140 3
	UBW u = TOPu;
	u >>= shift;
	SETu(BWu(u));
d1202 7
d1210 7
d1227 1
d1325 2
a1326 2
	  IBW value = SvIV(left) & SvIV(right);
	  SETi(BWi(value));
d1329 2
a1330 2
	  UBW value = SvUV(left) & SvUV(right);
	  SETu(BWu(value));
d1348 2
a1349 2
	  IBW value = (USE_LEFT(left) ? SvIV(left) : 0) ^ SvIV(right);
	  SETi(BWi(value));
d1352 2
a1353 2
	  UBW value = (USE_LEFT(left) ? SvUV(left) : 0) ^ SvUV(right);
	  SETu(BWu(value));
d1371 2
a1372 2
	  IBW value = (USE_LEFT(left) ? SvIV(left) : 0) | SvIV(right);
	  SETi(BWi(value));
d1375 2
a1376 2
	  UBW value = (USE_LEFT(left) ? SvUV(left) : 0) | SvUV(right);
	  SETu(BWu(value));
d1394 17
a1410 3
	if (SvIOKp(sv) && !SvNOKp(sv) && !SvPOKp(sv) && SvIVX(sv) != IV_MIN)
	    SETi(-SvIVX(sv));
	else if (SvNIOKp(sv))
d1423 4
a1438 1
#ifdef OVERLOAD
a1439 1
#endif /* OVERLOAD */
d1451 2
a1452 2
	  IBW value = ~SvIV(sv);
	  SETi(BWi(value));
d1455 2
a1456 2
	  UBW value = ~SvUV(sv);
	  SETu(BWu(value));
d1503 1
a1503 1
	DIE("Illegal division by zero");
d1516 1
a1516 1
	DIE("Illegal modulus zero");
d1634 1
a1634 1
      SETn(atan2(left, right));
d1643 1
a1643 1
      double value;
d1645 1
a1645 1
      value = sin(value);
d1655 1
a1655 1
      double value;
d1657 1
a1657 1
      value = cos(value);
d1669 7
a1675 5
#ifndef my_rand
#  define my_rand	rand
#endif
#ifndef my_srand
#  define my_srand	srand
d1681 1
a1681 1
    double value;
d1688 3
a1690 3
    if (!srand_called) {
	(void)my_srand((unsigned)seed());
	srand_called = TRUE;
d1692 1
a1692 13
#if RANDBITS == 31
    value = my_rand() * value / 2147483648.0;
#else
#if RANDBITS == 16
    value = my_rand() * value / 65536.0;
#else
#if RANDBITS == 15
    value = my_rand() * value / 32768.0;
#else
    value = my_rand() * value / (double)(((unsigned long)1) << RANDBITS);
#endif
#endif
#endif
d1705 2
a1706 2
    (void)my_srand((unsigned)anum);
    srand_called = TRUE;
d1712 1
a1712 1
seed(void)
d1718 1
a1718 1
     * if someone who knows about such tings would bother to write it.
d1720 1
a1720 1
     * No numbers below come from careful analysis or anyting here,
d1785 2
a1786 2
    u += SEED_C3 * (U32)getpid();
    u += SEED_C4 * (U32)(UV)PL_stack_sp;
d1788 1
a1788 1
    u += SEED_C5 * (U32)(UV)&when;
d1797 1
a1797 1
      double value;
d1799 1
a1799 1
      value = exp(value);
d1809 1
a1809 1
      double value;
d1812 2
a1813 2
	SET_NUMERIC_STANDARD();
	DIE("Can't take log of %g", value);
d1815 1
a1815 1
      value = log(value);
d1825 1
a1825 1
      double value;
d1828 2
a1829 2
	SET_NUMERIC_STANDARD();
	DIE("Can't take sqrt of %g", value);
d1831 1
a1831 1
      value = sqrt(value);
d1841 1
a1841 1
      double value = TOPn;
d1850 1
a1850 1
	  (void)modf(value, &value);
d1852 1
a1852 1
	  (void)modf(-value, &value);
d1869 1
a1869 1
      double value = TOPn;
d1895 1
a1895 1
    XPUSHu(scan_hex(tmps, 99, &argtype));
d1902 1
a1902 1
    UV value;
d1914 2
d1918 1
a1918 1
    XPUSHu(value);
d1927 6
a1932 1
    SETi( sv_len(TOPs) );
d1942 1
d1953 1
d1965 10
d2009 4
a2012 2
	if (PL_dowarn || lvalue || repl)
	    warn("substr outside of string");
d2016 4
d2022 3
a2024 1
	if (lvalue) {			/* it's an lvalue! */
d2029 3
a2031 2
		    if (PL_dowarn)
			warn("Attempt to use reference as lvalue in substr");
a2052 2
	else if (repl)
	    sv_insert(sv, pos, rem, repl, repl_len);
a2065 4
    STRLEN srclen;
    unsigned char *s = (unsigned char*)SvPV(src, srclen);
    unsigned long retnum;
    I32 len;
d2067 5
a2071 20
    SvTAINTED_off(TARG);			/* decontaminate */
    offset *= size;		/* turn into bit offset */
    len = (offset + size + 7) / 8;
    if (offset < 0 || size < 1)
	retnum = 0;
    else {
	if (lvalue) {                      /* it's an lvalue! */
	    if (SvTYPE(TARG) < SVt_PVLV) {
		sv_upgrade(TARG, SVt_PVLV);
		sv_magic(TARG, Nullsv, 'v', Nullch, 0);
	    }

	    LvTYPE(TARG) = 'v';
	    if (LvTARG(TARG) != src) {
		if (LvTARG(TARG))
		    SvREFCNT_dec(LvTARG(TARG));
		LvTARG(TARG) = SvREFCNT_inc(src);
	    }
	    LvTARGOFF(TARG) = offset;
	    LvTARGLEN(TARG) = size;
d2073 5
a2077 38
	if (len > srclen) {
	    if (size <= 8)
		retnum = 0;
	    else {
		offset >>= 3;
		if (size == 16) {
		    if (offset >= srclen)
			retnum = 0;
		    else
			retnum = (unsigned long) s[offset] << 8;
		}
		else if (size == 32) {
		    if (offset >= srclen)
			retnum = 0;
		    else if (offset + 1 >= srclen)
			retnum = (unsigned long) s[offset] << 24;
		    else if (offset + 2 >= srclen)
			retnum = ((unsigned long) s[offset] << 24) +
			    ((unsigned long) s[offset + 1] << 16);
		    else
			retnum = ((unsigned long) s[offset] << 24) +
			    ((unsigned long) s[offset + 1] << 16) +
			    (s[offset + 2] << 8);
		}
	    }
	}
	else if (size < 8)
	    retnum = (s[offset >> 3] >> (offset & 7)) & ((1 << size) - 1);
	else {
	    offset >>= 3;
	    if (size == 8)
		retnum = s[offset];
	    else if (size == 16)
		retnum = ((unsigned long) s[offset] << 8) + s[offset+1];
	    else if (size == 32)
		retnum = ((unsigned long) s[offset] << 24) +
			((unsigned long) s[offset + 1] << 16) +
			(s[offset + 2] << 8) + s[offset+3];
d2079 2
d2083 1
a2083 1
    sv_setuv(TARG, (UV)retnum);
d2107 2
d2115 1
a2115 1
	retval = -1 + arybase;
d2117 4
a2120 2
	retval = tmps2 - tmps + arybase;
    PUSHi(retval);
a2130 1
    SV *offstr;
d2138 1
a2138 1
	offstr = POPs;
d2145 5
a2149 2
    else
	offset = SvIV(offstr) - arybase + llen;
d2156 1
a2156 1
	retval = -1 + arybase;
d2158 4
a2161 2
	retval = tmps2 - tmps + arybase;
    PUSHi(retval);
a2167 6
#ifdef USE_LOCALE_NUMERIC
    if (PL_op->op_private & OPpLOCALE)
	SET_NUMERIC_LOCAL();
    else
	SET_NUMERIC_STANDARD();
#endif
d2178 1
a2178 2
    I32 value;
    char *tmps;
d2180 3
d2184 5
a2188 10
#ifndef I286
    tmps = POPpx;
    value = (I32) (*tmps & 255);
#else
    I32 anum;
    tmps = POPpx;
    anum = (I32) *tmps;
    value = (I32) (anum & 255);
#endif
    XPUSHi(value);
d2196 1
d2199 13
d2215 1
a2215 1
    *tmps++ = POPi;
d2217 1
d2235 1
a2235 1
    DIE(
d2246 8
a2253 2
    register char *s;
    STRLEN n_a;
a2254 8
    if (!SvPADTMP(sv)) {
	dTARGET;
	sv_setsv(TARG, sv);
	sv = TARG;
	SETs(sv);
    }
    s = SvPV_force(sv, n_a);
    if (*s) {
d2258 1
a2258 1
	    *s = toUPPER_LC(*s);
d2261 34
a2294 1
	    *s = toUPPER(*s);
d2296 2
a2297 1

d2305 8
a2312 2
    register char *s;
    STRLEN n_a;
a2313 8
    if (!SvPADTMP(sv)) {
	dTARGET;
	sv_setsv(TARG, sv);
	sv = TARG;
	SETs(sv);
    }
    s = SvPV_force(sv, n_a);
    if (*s) {
d2317 1
a2317 1
	    *s = toLOWER_LC(*s);
d2320 15
a2334 1
	    *s = toLOWER(*s);
d2336 21
a2356 2

    SETs(sv);
d2364 1
a2364 1
    register char *s;
d2367 1
a2367 1
    if (!SvPADTMP(sv)) {
d2369 9
a2377 14
	sv_setsv(TARG, sv);
	sv = TARG;
	SETs(sv);
    }

    s = SvPV_force(sv, len);
    if (len) {
	register char *send = s + len;

	if (PL_op->op_private & OPpLOCALE) {
	    TAINT;
	    SvTAINTED_on(sv);
	    for (; s < send; s++)
		*s = toUPPER_LC(*s);
d2380 47
a2426 2
	    for (; s < send; s++)
		*s = toUPPER(*s);
d2429 2
d2438 1
a2438 1
    register char *s;
d2441 1
a2441 1
    if (!SvPADTMP(sv)) {
d2443 9
a2451 14
	sv_setsv(TARG, sv);
	sv = TARG;
	SETs(sv);
    }

    s = SvPV_force(sv, len);
    if (len) {
	register char *send = s + len;

	if (PL_op->op_private & OPpLOCALE) {
	    TAINT;
	    SvTAINTED_on(sv);
	    for (; s < send; s++)
		*s = toLOWER_LC(*s);
d2454 48
a2501 2
	    for (; s < send; s++)
		*s = toLOWER(*s);
d2504 2
d2517 1
d2522 25
a2546 4
	while (len--) {
	    if (!isALNUM(*s))
		*d++ = '\\';
	    *d++ = *s++;
d2555 2
d2590 1
a2590 1
		    DIE(no_aelem, elem);
d2609 1
a2609 1
    djSP; dTARGET;
d2624 1
d2627 2
a2628 2
	    sv_setsv(TARG, realhv ?
		     hv_iterval(hash, entry) : avhv_iterval((AV*)hash, entry));
d2630 1
a2630 1
	    PUSHs(TARG);
d2641 1
a2641 1
    return do_kv(ARGS);
d2646 1
a2646 1
    return do_kv(ARGS);
d2662 2
a2663 2
	while (++MARK <= SP) {
	    if (hvtype == SVt_PVHV)
d2665 16
a2680 3
	    else
		DIE("Not a HASH reference");
	    *MARK = sv ? sv : &PL_sv_undef;
d2682 2
d2697 6
d2704 1
a2704 1
	    DIE("Not a HASH reference");
d2716 16
a2731 2
    SV *tmpsv = POPs;
    HV *hv = (HV*)POPs;
d2735 7
a2741 2
    } else if (SvTYPE(hv) == SVt_PVAV) {
	if (avhv_exists_ent((AV*)hv, tmpsv, 0))
d2743 3
a2745 2
    } else {
	DIE("Not a HASH reference");
d2758 1
a2758 1
	DIE("Can't localize pseudo-hash element");
d2767 2
a2768 1
	    } else {
d2774 1
a2774 1
		    DIE(no_helem, SvPV(keysv, n_a));
d2841 1
a2841 1
	if (ix < 0) {
d2843 4
a2846 5
	    if (ix < 0)
		*lelem = &PL_sv_undef;
	    else if (!(*lelem = firstrelem[ix]))
		*lelem = &PL_sv_undef;
	}
d2848 2
a2849 2
	    ix -= arybase;
	    if (ix >= max || !(*lelem = firstrelem[ix]))
a2851 2
	if (!is_something_there && (SvOK(*lelem) || SvGMAGICAL(*lelem)))
	    is_something_there = TRUE;
d2880 2
a2881 2
	else if (PL_dowarn)
	    warn("Odd number of elements in hash assignment");
d2904 1
a2904 1
    if (mg = SvTIED_mg((SV*)ary, 'P')) {
d2909 1
a2909 1
	perl_call_method("SPLICE",GIMME_V);
d2924 1
a2924 1
	    DIE(no_aelem, i);
d2954 2
a2955 6
    if (newlen && !AvREAL(ary)) {
	if (AvREIFY(ary))
	    av_reify(ary);
	else
	    assert(AvREAL(ary));		/* would leak, so croak */
    }
d3098 1
a3098 1
    if (mg = SvTIED_mg((SV*)ary, 'P')) {
d3103 1
a3103 1
	perl_call_method("PUSH",G_SCALAR|G_DISCARD);
d3154 1
a3154 1
    if (mg = SvTIED_mg((SV*)ary, 'P')) {
d3159 1
a3159 1
	perl_call_method("UNSHIFT",G_SCALAR|G_DISCARD);
d3189 1
d3199 1
d3206 27
d3247 2
a3248 2
STATIC SV      *
mul128(SV *sv, U8 m)
d3256 1
a3256 1
    SV             *tmpNew = newSVpv("0000000000", 10);
a3275 5
static const char uuemap[] =
    "`!\"#$%&'()*+,-./0123456789:;<=>?@@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_";
#ifndef PERL_OBJECT
static char uudmap[256];        /* Initialised on first use */
#endif
d3284 1
a3284 1
#define ISUUCHAR(ch)    (memchr(uuemap, (ch), sizeof(uuemap)-1) || (ch) == ' ')
d3291 1
a3291 1
    SV **oldsp = SP;
d3304 1
d3317 1
a3317 1
    unsigned Quad_t auquad;
d3324 6
a3329 3
    double cdouble;
#ifndef PERL_OBJECT
    static char* bitcount = 0;
a3330 1
    int commas = 0;
d3346 3
d3351 18
d3374 1
d3378 1
a3378 1
	    while (isDIGIT(*pat))
d3380 3
d3386 1
d3389 1
a3389 1
	    croak("Invalid type in unpack: '%c'", (int)datumtype);
d3391 3
a3393 2
	    if (commas++ == 0 && PL_dowarn)
		warn("Invalid type in unpack: '%c'", (int)datumtype);
d3406 1
a3406 1
		DIE("@@ outside of string");
d3411 1
a3411 1
		DIE("X outside of string");
d3416 1
a3416 1
		DIE("x outside of string");
d3419 11
d3460 1
a3460 1
	    if (pat[-1] == '*' || len > (strend - s) * 8)
d3463 2
a3464 2
		if (!bitcount) {
		    Newz(601, bitcount, 256, char);
d3466 8
a3473 8
			if (bits & 1)	bitcount[bits]++;
			if (bits & 2)	bitcount[bits]++;
			if (bits & 4)	bitcount[bits]++;
			if (bits & 8)	bitcount[bits]++;
			if (bits & 16)	bitcount[bits]++;
			if (bits & 32)	bitcount[bits]++;
			if (bits & 64)	bitcount[bits]++;
			if (bits & 128)	bitcount[bits]++;
d3477 1
a3477 1
		    culong += bitcount[*(unsigned char*)s++];
d3500 1
a3500 2
	    aptr = pat;			/* borrow register */
	    pat = SvPVX(sv);
d3508 1
a3508 1
		    *pat++ = '0' + (bits & 1);
d3518 1
a3518 1
		    *pat++ = '0' + ((bits & 128) != 0);
d3521 1
a3521 2
	    *pat = '\0';
	    pat = aptr;			/* unborrow register */
d3526 1
a3526 1
	    if (pat[-1] == '*' || len > (strend - s) * 2)
d3531 1
a3531 2
	    aptr = pat;			/* borrow register */
	    pat = SvPVX(sv);
d3539 1
a3539 1
		    *pat++ = PL_hexdigit[bits & 15];
d3549 1
a3549 1
		    *pat++ = PL_hexdigit[(bits >> 4) & 15];
d3552 1
a3552 2
	    *pat = '\0';
	    pat = aptr;			/* unborrow register */
d3600 25
d3626 1
d3628 3
d3634 15
a3648 2
		while (len-- > 0) {
		    COPY16(s, &ashort);
d3650 2
a3651 2
		    if (ashort > 32767)
			ashort -= 65536;
d3653 3
a3655 2
		    s += SIZE16;
		    culong += ashort;
d3661 16
a3676 2
		while (len-- > 0) {
		    COPY16(s, &ashort);
d3678 2
a3679 2
		    if (ashort > 32767)
			ashort -= 65536;
d3681 5
a3685 4
		    s += SIZE16;
		    sv = NEWSV(38, 0);
		    sv_setiv(sv, (IV)ashort);
		    PUSHs(sv_2mortal(sv));
d3692 1
d3694 4
d3701 15
a3715 3
		while (len-- > 0) {
		    COPY16(s, &aushort);
		    s += SIZE16;
d3717 2
a3718 2
		    if (datumtype == 'n')
			aushort = PerlSock_ntohs(aushort);
d3721 2
a3722 2
		    if (datumtype == 'v')
			aushort = vtohs(aushort);
d3724 2
a3725 1
		    culong += aushort;
d3731 18
a3748 4
		while (len-- > 0) {
		    COPY16(s, &aushort);
		    s += SIZE16;
		    sv = NEWSV(39, 0);
d3750 2
a3751 2
		    if (datumtype == 'n')
			aushort = PerlSock_ntohs(aushort);
d3754 2
a3755 2
		    if (datumtype == 'v')
			aushort = vtohs(aushort);
d3757 3
a3759 2
		    sv_setiv(sv, (IV)aushort);
		    PUSHs(sv_2mortal(sv));
d3772 1
a3772 1
			cdouble += (double)aint;
d3787 19
a3805 1
                     * cc with optimization turned on */
d3823 1
a3823 1
			cdouble += (double)auint;
d3837 2
a3838 6
                     * returns 1.84467440737096e+19 instead of 0xFFFFFFFF for
		     * DEC C V5.8-009 on Digital UNIX V4.0 (Rev. 1091) (aka V4.0D)
		     * with optimization turned on.
		     * (DEC C V5.2-040 on Digital UNIX V4.0 (Rev. 564) (aka V4.0B)
		     * does not have this problem even with -O4)
		     */
d3848 1
d3850 3
d3856 17
a3872 2
		while (len-- > 0) {
		    COPY32(s, &along);
d3874 2
a3875 2
		    if (along > 2147483647)
			along -= 4294967296;
d3877 6
a3882 5
		    s += SIZE32;
		    if (checksum > 32)
			cdouble += (double)along;
		    else
			culong += along;
d3888 16
a3903 2
		while (len-- > 0) {
		    COPY32(s, &along);
d3905 2
a3906 2
		    if (along > 2147483647)
			along -= 4294967296;
d3908 5
a3912 4
		    s += SIZE32;
		    sv = NEWSV(42, 0);
		    sv_setiv(sv, (IV)along);
		    PUSHs(sv_2mortal(sv));
d3919 1
d3921 4
d3928 18
a3945 3
		while (len-- > 0) {
		    COPY32(s, &aulong);
		    s += SIZE32;
d3947 2
a3948 2
		    if (datumtype == 'N')
			aulong = PerlSock_ntohl(aulong);
d3951 2
a3952 2
		    if (datumtype == 'V')
			aulong = vtohl(aulong);
d3954 5
a3958 4
		    if (checksum > 32)
			cdouble += (double)aulong;
		    else
			culong += aulong;
d3964 17
a3980 3
		while (len-- > 0) {
		    COPY32(s, &aulong);
		    s += SIZE32;
d3982 2
a3983 2
		    if (datumtype == 'N')
			aulong = PerlSock_ntohl(aulong);
d3986 2
a3987 2
		    if (datumtype == 'V')
			aulong = vtohl(aulong);
d3989 4
a3992 3
		    sv = NEWSV(43, 0);
		    sv_setuv(sv, (UV)aulong);
		    PUSHs(sv_2mortal(sv));
d4036 1
a4036 1
			sv = newSVpvf("%.*Vu", (int)TYPE_DIGITS(UV), auv);
d4054 1
a4054 1
		    croak("Unterminated compressed integer");
d4088 1
a4088 1
		    sv_setnv(sv, (double)aquad);
d4099 1
a4099 1
		if (s + sizeof(unsigned Quad_t) > strend)
d4102 2
a4103 2
		    Copy(s, &auquad, 1, unsigned Quad_t);
		    s += sizeof(unsigned Quad_t);
d4109 1
a4109 1
		    sv_setnv(sv, (double)auquad);
d4134 1
a4134 1
		    sv_setnv(sv, (double)afloat);
d4158 1
a4158 1
		    sv_setnv(sv, (double)adouble);
d4169 1
a4169 1
            if (uudmap['M'] == 0) {
d4172 2
a4173 2
                for (i = 0; i < sizeof(uuemap); i += 1)
                    uudmap[uuemap[i]] = i;
d4178 1
a4178 1
                uudmap[' '] = 0;
d4190 1
a4190 1
		len = uudmap[*s++] & 077;
d4193 1
a4193 1
			a = uudmap[*s++] & 077;
d4197 1
a4197 1
			b = uudmap[*s++] & 077;
d4201 1
a4201 1
			c = uudmap[*s++] & 077;
d4205 1
a4205 1
			d = uudmap[*s++] & 077;
d4225 2
a4226 2
	      (checksum > 32 && strchr("iIlLN", datumtype)) ) {
		double trouble;
d4242 1
a4242 1
		cdouble = modf(cdouble / adouble, &trouble) * adouble;
d4256 1
a4256 1
    if (SP == oldsp && gimme == G_SCALAR)
d4262 1
a4262 1
doencodes(register SV *sv, register char *s, register I32 len)
d4266 1
a4266 1
    *hunk = uuemap[len];
d4270 4
a4273 4
	hunk[0] = uuemap[(077 & (*s >> 2))];
	hunk[1] = uuemap[(077 & (((*s << 4) & 060) | ((s[1] >> 4) & 017)))];
	hunk[2] = uuemap[(077 & (((s[1] << 2) & 074) | ((s[2] >> 6) & 03)))];
	hunk[3] = uuemap[(077 & (s[2] & 077))];
d4280 4
a4283 4
	hunk[0] = uuemap[(077 & (*s >> 2))];
	hunk[1] = uuemap[(077 & (((*s << 4) & 060) | ((r >> 4) & 017)))];
	hunk[2] = uuemap[(077 & ((r << 2) & 074))];
	hunk[3] = uuemap[0];
d4289 2
a4290 2
STATIC SV      *
is_an_int(char *s, STRLEN l)
d4292 2
a4293 2
  STRLEN          n_a;
  SV             *result = newSVpv("", l);
d4338 1
d4340 1
a4340 3
div128(SV *pnum, bool *done)
                          		    /* must be '\0' terminated */

d4390 1
a4390 1
    unsigned Quad_t auquad;
d4396 3
d4404 2
a4405 1
#define NEXTFROM (items-- > 0 ? *MARK++ : &PL_sv_no)
d4407 3
d4412 17
d4435 1
a4435 1
	    while (isDIGIT(*pat))
d4437 3
d4443 7
d4452 1
a4452 1
	    croak("Invalid type in pack: '%c'", (int)datumtype);
d4454 3
a4456 2
	    if (commas++ == 0 && PL_dowarn)
		warn("Invalid type in pack: '%c'", (int)datumtype);
d4459 1
a4459 1
	    DIE("%% may only be used in unpack");
d4471 1
a4471 1
		DIE("X outside of string");
d4488 1
a4488 1
	    if (pat[-1] == '*')
d4490 4
a4493 1
	    if (fromlen > len)
d4495 3
d4520 1
a4520 1
		char *savepat = pat;
d4525 1
a4525 1
		aptr = SvPV(fromstr, fromlen);
a4527 1
		pat = aptr;
d4538 1
a4538 1
			items |= *pat++ & 1;
d4549 1
a4549 1
			if (*pat++ & 1)
d4566 2
a4567 2
		pat = SvPVX(cat) + SvCUR(cat);
		while (aptr <= pat)
a4569 1
		pat = savepat;
d4576 1
a4576 1
		char *savepat = pat;
d4581 1
a4581 1
		aptr = SvPV(fromstr, fromlen);
a4583 1
		pat = aptr;
d4594 2
a4595 2
			if (isALPHA(*pat))
			    items |= ((*pat++ & 15) + 9) & 15;
d4597 1
a4597 1
			    items |= *pat++ & 15;
d4608 2
a4609 2
			if (isALPHA(*pat))
			    items |= (((*pat++ & 15) + 9) & 15) << 4;
d4611 1
a4611 1
			    items |= (*pat++ & 15) << 4;
d4622 2
a4623 2
		pat = SvPVX(cat) + SvCUR(cat);
		while (aptr <= pat)
a4625 1
		pat = savepat;
d4638 10
d4686 23
d4710 18
a4727 4
	    while (len-- > 0) {
		fromstr = NEXTFROM;
		ashort = (I16)SvIV(fromstr);
		CAT16(cat, &ashort);
d4740 1
a4740 1
		adouble = floor(SvNV(fromstr));
d4743 1
a4743 1
		    croak("Cannot compress negative numbers");
a4745 3
#ifdef BW_BITS
		    adouble <= BW_MASK
#else
a4750 1
#endif
d4755 1
a4755 1
		    UV     auv = U_V(adouble);;
d4773 1
a4773 1
			croak("can compress only unsigned integer");
d4793 1
a4793 1
			    croak ("Cannot compress integer");
d4800 1
a4800 1
		    croak("Cannot compress non integer");
d4831 18
a4848 4
	    while (len-- > 0) {
		fromstr = NEXTFROM;
		aulong = SvUV(fromstr);
		CAT32(cat, &aulong);
d4852 18
a4869 4
	    while (len-- > 0) {
		fromstr = NEXTFROM;
		along = SvIV(fromstr);
		CAT32(cat, &along);
d4876 2
a4877 2
		auquad = (unsigned Quad_t)SvIV(fromstr);
		sv_catpvn(cat, (char*)&auquad, sizeof(unsigned Quad_t));
d4887 1
a4887 1
#endif /* HAS_QUAD */
d4903 7
a4909 2
		    if (PL_dowarn && (SvTEMP(fromstr) || SvPADTMP(fromstr)))
			warn("Attempt to pack pointer to temporary value");
d4980 1
a4980 1
	DIE("panic: do_split");
d4986 4
a4989 1
    if (pm->op_pmreplroot)
d4991 2
d5007 1
a5007 1
	if (mg = SvTIED_mg((SV*)ary, 'P')) {
d5014 1
d5080 1
a5080 1
    else if (rx->check_substr && !rx->nparens
d5083 7
a5089 3
	i = SvCUR(rx->check_substr);
	if (i == 1 && !SvTAIL(rx->check_substr)) {
	    i = *SvPVX(rx->check_substr);
d5092 1
a5092 1
		for (m = s; m < strend && *m != i; m++) ;
d5106 2
a5107 2
	      (m=fbm_instr((unsigned char*)s, (unsigned char*)strend,
		    rx->check_substr, 0)) )
d5115 1
a5115 1
		s = m + i;
d5121 6
a5126 2
	while (s < strend && --limit &&
	       CALLREGEXEC(rx, s, strend, orig, 1, Nullsv, NULL, 0))
d5129 1
a5129 2
	    if (rx->subbase
	      && rx->subbase != orig) {
d5132 1
a5132 1
		orig = rx->subbase;
d5136 1
a5136 1
	    m = rx->startp[0];
d5144 2
a5145 2
		    s = rx->startp[i];
		    m = rx->endp[i];
d5157 1
a5157 1
	    s = rx->endp[0];
d5164 1
a5164 1
	DIE("Split loop");
d5198 1
a5198 1
	    perl_call_method("PUSH",G_SCALAR|G_DISCARD);
d5226 1
a5226 1
unlock_condpair(void *svv)
d5232 1
a5232 1
	croak("panic: unlock_condpair unlocking non-mutex");
d5235 1
a5235 1
	croak("panic: unlock_condpair unlocking mutex that we don't own");
d5238 2
a5239 2
    DEBUG_S(PerlIO_printf(PerlIO_stderr(), "0x%lx: unlock 0x%lx\n",
			  (unsigned long)thr, (unsigned long)svv);)
d5263 2
a5264 2
	DEBUG_S(PerlIO_printf(PerlIO_stderr(), "0x%lx: pp_lock lock 0x%lx\n",
			      (unsigned long)thr, (unsigned long)sv);)
d5266 1
a5266 1
	save_destructor(unlock_condpair, sv);
d5279 1
a5280 1
#ifdef USE_THREADS
d5288 1
a5288 1
    DIE("tried to access per-thread data in non-threaded perl");
@


1.2
log
@perl 5.004_04
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1997, Larry Wall
d49 1
a49 1
#if BYTEORDER > 0xFFFF && defined(_CRAY) && !defined(_CRAYMPP)
d72 5
a76 1
 * the preprocessor.)
d104 1
d108 2
a110 1
static bool srand_called = FALSE;
d114 12
d128 1
a128 1
    dSP;
d130 1
a130 1
	XPUSHs(&sv_undef);
d143 3
a145 3
    dSP; dTARGET;
    if (op->op_private & OPpLVAL_INTRO)
	SAVECLEARSV(curpad[op->op_targ]);
d147 1
a147 1
    if (op->op_flags & OPf_REF) {
d154 10
a163 1
	Copy(AvARRAY((AV*)TARG), SP+1, maxarg, SV*);
d177 1
a177 1
    dSP; dTARGET;
d181 3
a183 3
    if (op->op_private & OPpLVAL_INTRO)
	SAVECLEARSV(curpad[op->op_targ]);
    if (op->op_flags & OPf_REF)
d210 2
a211 2
    dSP; dTOPss;
    
d227 1
d235 2
a236 2
		if (op->op_flags & OPf_REF ||
		    op->op_private & HINT_STRICT_REFS)
d238 1
a238 1
		if (dowarn)
d242 2
a243 2
	    sym = SvPV(sv, na);
	    if (op->op_private & HINT_STRICT_REFS)
d248 2
a249 2
    if (op->op_private & OPpLVAL_INTRO)
	save_gp((GV*)sv, !(op->op_flags & OPf_SPECIAL));
d256 1
a256 1
    dSP; dTOPss;
d271 1
d280 2
a281 2
		if (op->op_flags & OPf_REF ||
		    op->op_private & HINT_STRICT_REFS)
d283 1
a283 1
		if (dowarn)
d287 2
a288 2
	    sym = SvPV(sv, na);
	    if (op->op_private & HINT_STRICT_REFS)
d294 2
a295 2
    if (op->op_flags & OPf_MOD) {
	if (op->op_private & OPpLVAL_INTRO)
d297 2
a298 2
	else if (op->op_private & OPpDEREF)
	    vivify_ref(sv, op->op_private & OPpDEREF);
d306 1
a306 1
    dSP;
d320 3
a322 3
    dSP; dTARGET; dPOPss;
    
    if (op->op_flags & OPf_MOD) {
d329 5
a333 1
	LvTARG(TARG) = sv;
d338 1
a338 1
	MAGIC* mg; 
d343 1
a343 1
		PUSHi(mg->mg_len + curcop->cop_arybase);
d353 1
a353 1
    dSP;
d359 1
a359 1
    CV *cv = sv_2cv(TOPs, &stash, &gv, !(op->op_flags & OPf_SPECIAL));
d365 1
a365 1
	cv = (CV*)&sv_undef;
d372 1
a372 1
    dSP;
d378 45
a422 1
    ret = &sv_undef;
d426 1
d433 2
a434 2
    dSP;
    CV* cv = (CV*)curpad[op->op_targ];
d444 1
a444 1
    dSP;
d447 1
a447 1
} 
d451 1
a451 1
    dSP; dMARK;
d453 7
a459 2
	MARK[1] = *SP;
	SP = MARK + 1;
d467 2
a468 3
static SV*
refto(sv)
SV* sv;
d476 1
a476 1
	    sv = &sv_undef;
d493 1
a493 1
    dSP; dTARGET;
d500 1
a500 1
	mg_get(sv);     
d513 1
a513 1
    dSP;
d517 9
a525 3
	stash = curcop->cop_stash;
    else
	stash = gv_stashsv(POPs, TRUE);
d535 1
a535 1
    SV *ref;
d537 2
a538 1
    dSP;
d541 1
a541 1
    elem = SvPV(sv, na);
d543 1
a543 1
    ref = Nullsv;
d549 1
a549 1
	    ref = (SV*)GvAV(gv);
d553 1
a553 1
	    ref = (SV*)GvCVu(gv);
d557 1
a557 1
	    ref = (SV*)GvIOp(gv);
d561 1
a561 1
	    ref = (SV*)gv;
d565 1
a565 1
	    ref = (SV*)GvHV(gv);
d569 1
a569 1
	    ref = (SV*)GvIOp(gv);
d581 1
a581 1
	    ref = GvSV(gv);
d584 2
a585 2
    if (ref)
	sv = newRV(ref);
d589 1
a589 1
	sv = &sv_undef;
d598 2
a599 1
    dSP; dPOPss;
d607 1
a607 1
    if (sv == lastscream) {
d612 3
a614 3
	if (lastscream) {
	    SvSCREAM_off(lastscream);
	    SvREFCNT_dec(lastscream);
d616 1
a616 1
	lastscream = SvREFCNT_inc(sv);
d623 5
a627 5
    if (pos > maxscream) {
	if (maxscream < 0) {
	    maxscream = pos + 80;
	    New(301, screamfirst, 256, I32);
	    New(302, screamnext, maxscream, I32);
d630 2
a631 2
	    maxscream = pos + pos / 4;
	    Renew(screamnext, maxscream, I32);
d635 2
a636 2
    sfirst = screamfirst;
    snext = screamnext;
d661 1
a661 1
    dSP; dTARG;
d664 1
a664 1
    if (op->op_flags & OPf_STACKED)
d667 1
a667 1
	sv = GvSV(defgv);
d671 1
a671 1
    PUSHi(do_trans(sv, op));
d679 1
a679 1
    dSP; dTARGET;
d687 1
a687 1
    dSP; dMARK; dTARGET;
d696 1
a696 1
    dSP; dTARGET;
d703 1
a703 1
    dSP; dMARK; dTARGET;
d705 1
a705 1
    
d714 1
a714 1
    dSP;
d722 1
a722 1
	if (AvMAX(sv) >= 0 || SvGMAGICAL(sv))
d726 1
a726 1
	if (HvARRAY(sv) || SvGMAGICAL(sv))
d744 1
a744 1
    dSP;
d747 1
a747 1
    if (!op->op_private) {
d757 5
a761 2
	if (SvREADONLY(sv))
	    RETPUSHUNDEF;
d776 1
a776 1
	if (cv_const_sv((CV*)sv))
d787 11
a797 1
	    sv_setsv(sv, &sv_undef);
d815 1
a815 1
    dSP;
d832 1
a832 1
    dSP; dTARGET;
d853 1
a853 1
    dSP; dTARGET;
d874 1
a874 1
    dSP; dATARGET; tryAMAGICbin(pow,opASSIGN); 
d884 1
a884 1
    dSP; dATARGET; tryAMAGICbin(mult,opASSIGN); 
d894 1
a894 1
    dSP; dATARGET; tryAMAGICbin(div,opASSIGN); 
d922 1
a922 1
    dSP; dATARGET; tryAMAGICbin(mod,opASSIGN);
d957 2
a958 2
	if (ans <= -(UV)IV_MAX)
	  sv_setiv(TARG, (IV) -ans);
d971 1
a971 1
  dSP; dATARGET; tryAMAGICbin(repeat,opASSIGN);
d974 1
a974 1
    if (GIMME == G_ARRAY && op->op_private & OPpREPEAT_DOLIST) {
d1001 1
a1001 1
	    if (SvREADONLY(tmpstr) && curcop != &compiling)
d1027 1
a1027 1
    dSP; dATARGET; tryAMAGICbin(subtr,opASSIGN); 
d1037 1
a1037 1
    dSP; dATARGET; tryAMAGICbin(lshift,opASSIGN); 
d1040 1
a1040 1
      if (op->op_private & HINT_INTEGER) {
d1056 1
a1056 1
    dSP; dATARGET; tryAMAGICbin(rshift,opASSIGN); 
d1059 1
a1059 1
      if (op->op_private & HINT_INTEGER) {
d1075 1
a1075 1
    dSP; tryAMAGICbinSET(lt,0); 
d1085 1
a1085 1
    dSP; tryAMAGICbinSET(gt,0); 
d1095 1
a1095 1
    dSP; tryAMAGICbinSET(le,0); 
d1105 1
a1105 1
    dSP; tryAMAGICbinSET(ge,0); 
d1115 1
a1115 1
    dSP; tryAMAGICbinSET(ne,0); 
d1125 1
a1125 1
    dSP; dTARGET; tryAMAGICbin(ncmp,0); 
d1137 1
a1137 1
	SETs(&sv_undef);
d1147 1
a1147 1
    dSP; tryAMAGICbinSET(slt,0); 
d1150 1
a1150 1
      int cmp = ((op->op_private & OPpLOCALE)
d1160 1
a1160 1
    dSP; tryAMAGICbinSET(sgt,0); 
d1163 1
a1163 1
      int cmp = ((op->op_private & OPpLOCALE)
d1173 1
a1173 1
    dSP; tryAMAGICbinSET(sle,0); 
d1176 1
a1176 1
      int cmp = ((op->op_private & OPpLOCALE)
d1186 1
a1186 1
    dSP; tryAMAGICbinSET(sge,0); 
d1189 1
a1189 1
      int cmp = ((op->op_private & OPpLOCALE)
d1199 1
a1199 1
    dSP; tryAMAGICbinSET(seq,0); 
d1209 1
a1209 1
    dSP; tryAMAGICbinSET(sne,0); 
d1219 1
a1219 1
    dSP; dTARGET;  tryAMAGICbin(scmp,0);
d1222 1
a1222 1
      int cmp = ((op->op_private & OPpLOCALE)
d1232 1
a1232 1
    dSP; dATARGET; tryAMAGICbin(band,opASSIGN); 
d1236 2
a1237 2
	if (op->op_private & HINT_INTEGER) {
	  IBW value = SvIV(left) & SvIV(right); 
d1241 1
a1241 1
	  UBW value = SvUV(left) & SvUV(right); 
d1246 1
a1246 1
	do_vop(op->op_type, TARG, left, right);
d1255 1
a1255 1
    dSP; dATARGET; tryAMAGICbin(bxor,opASSIGN); 
d1259 2
a1260 2
	if (op->op_private & HINT_INTEGER) {
	  IBW value = (USE_LEFT(left) ? SvIV(left) : 0) ^ SvIV(right); 
d1264 1
a1264 1
	  UBW value = (USE_LEFT(left) ? SvUV(left) : 0) ^ SvUV(right); 
d1269 1
a1269 1
	do_vop(op->op_type, TARG, left, right);
d1278 1
a1278 1
    dSP; dATARGET; tryAMAGICbin(bor,opASSIGN); 
d1282 2
a1283 2
	if (op->op_private & HINT_INTEGER) {
	  IBW value = (USE_LEFT(left) ? SvIV(left) : 0) | SvIV(right); 
d1287 1
a1287 1
	  UBW value = (USE_LEFT(left) ? SvUV(left) : 0) | SvUV(right); 
d1292 1
a1292 1
	do_vop(op->op_type, TARG, left, right);
d1301 1
a1301 1
    dSP; dTARGET; tryAMAGICun(neg);
d1334 1
a1334 1
    dSP; tryAMAGICunSET(not);
d1336 1
a1336 1
    *stack_sp = boolSV(!SvTRUE(*stack_sp));
d1342 1
a1342 1
    dSP; dTARGET; tryAMAGICun(compl); 
d1346 1
a1346 1
	if (op->op_private & HINT_INTEGER) {
d1385 1
a1385 1
    dSP; dATARGET; tryAMAGICbin(mult,opASSIGN); 
d1395 1
a1395 1
    dSP; dATARGET; tryAMAGICbin(div,opASSIGN); 
d1408 1
a1408 1
    dSP; dATARGET; tryAMAGICbin(mod,opASSIGN); 
d1420 1
a1420 1
    dSP; dATARGET; tryAMAGICbin(add,opASSIGN); 
d1430 1
a1430 1
    dSP; dATARGET; tryAMAGICbin(subtr,opASSIGN); 
d1440 1
a1440 1
    dSP; tryAMAGICbinSET(lt,0); 
d1450 1
a1450 1
    dSP; tryAMAGICbinSET(gt,0); 
d1460 1
a1460 1
    dSP; tryAMAGICbinSET(le,0); 
d1470 1
a1470 1
    dSP; tryAMAGICbinSET(ge,0); 
d1480 1
a1480 1
    dSP; tryAMAGICbinSET(eq,0); 
d1490 1
a1490 1
    dSP; tryAMAGICbinSET(ne,0); 
d1500 1
a1500 1
    dSP; dTARGET; tryAMAGICbin(ncmp,0); 
d1518 1
a1518 1
    dSP; dTARGET; tryAMAGICun(neg);
d1527 1
a1527 1
    dSP; dTARGET; tryAMAGICbin(atan2,0); 
d1537 1
a1537 1
    dSP; dTARGET; tryAMAGICun(sin);
d1549 1
a1549 1
    dSP; dTARGET; tryAMAGICun(cos);
d1559 13
d1574 1
a1574 1
    dSP; dTARGET;
d1583 1
a1583 1
	(void)srand((unsigned)seed());
d1587 1
a1587 1
    value = rand() * value / 2147483648.0;
d1590 1
a1590 1
    value = rand() * value / 65536.0;
d1593 1
a1593 1
    value = rand() * value / 32768.0;
d1595 1
a1595 1
    value = rand() * value / (double)(((unsigned long)1) << RANDBITS);
d1605 1
a1605 1
    dSP;
d1611 1
a1611 1
    (void)srand((unsigned)anum);
d1617 2
a1618 2
static U32
seed()
d1642 4
d1652 28
a1683 1
    struct timeval when;
a1686 1
    Time_t when;
d1692 1
a1692 1
    u += SEED_C4 * (U32)(UV)stack_sp;
d1701 1
a1701 1
    dSP; dTARGET; tryAMAGICun(exp);
d1713 1
a1713 1
    dSP; dTARGET; tryAMAGICun(log);
d1729 1
a1729 1
    dSP; dTARGET; tryAMAGICun(sqrt);
d1745 1
a1745 1
    dSP; dTARGET;
d1773 1
a1773 1
    dSP; dTARGET; tryAMAGICun(abs);
d1795 1
a1795 1
    dSP; dTARGET;
d1798 1
d1800 1
a1800 1
    tmps = POPp;
d1807 1
a1807 1
    dSP; dTARGET;
d1811 1
d1813 1
a1813 1
    tmps = POPp;
d1830 1
a1830 1
    dSP; dTARGET;
d1837 1
a1837 1
    dSP; dTARGET;
d1844 1
a1844 1
    I32 lvalue = op->op_flags & OPf_MOD;
d1846 10
a1855 3
    I32 arybase = curcop->cop_arybase;

    if (MAXARG > 2)
d1857 1
d1860 1
d1866 9
a1874 9
        if (MAXARG > 2) {
            if (len < 0) {
	        rem += len;
                if (rem < 0)
                    rem = 0;
            }
            else if (rem > len)
                     rem = len;
        }
d1877 17
a1893 17
        pos += curlen;
        if (MAXARG < 3)
            rem = curlen;
        else if (len >= 0) {
            rem = pos+len;
            if (rem > (I32)curlen)
                rem = curlen;
        }
        else {
            rem = curlen+len;
            if (rem < pos)
                rem = pos;
        }
        if (pos < 0)
            pos = 0;
        fail = rem;
        rem -= pos;
d1896 1
a1896 1
	if (dowarn || lvalue) 
d1906 3
a1908 2
		    SvPV_force(sv,na);
		    if (dowarn)
d1923 5
a1927 1
	    LvTARG(TARG) = sv;
d1929 1
a1929 1
	    LvTARGLEN(TARG) = rem; 
d1931 2
d1934 1
d1941 1
a1941 1
    dSP; dTARGET;
d1945 1
a1945 1
    I32 lvalue = op->op_flags & OPf_MOD;
d1951 1
d1964 7
a1970 3
	    LvTARG(TARG) = src;
	    LvTARGOFF(TARG) = offset; 
	    LvTARGLEN(TARG) = size; 
d2013 1
a2013 1
    sv_setiv(TARG, (IV)retnum);
d2020 1
a2020 1
    dSP; dTARGET;
d2028 1
a2028 1
    I32 arybase = curcop->cop_arybase;
d2042 1
a2042 1
      (unsigned char*)tmps + biglen, little)))
d2052 1
a2052 1
    dSP; dTARGET;
d2062 1
a2062 1
    I32 arybase = curcop->cop_arybase;
d2089 1
a2089 1
    dSP; dMARK; dORIGMARK; dTARGET;
d2091 1
a2091 1
    if (op->op_private & OPpLOCALE)
d2105 1
a2105 1
    dSP; dTARGET;
d2108 1
d2111 1
a2111 1
    tmps = POPp;
d2115 1
a2115 1
    tmps = POPp;
d2125 1
a2125 1
    dSP; dTARGET;
d2141 2
a2142 1
    dSP; dTARGET; dPOPTOPssrl;
d2144 1
a2144 1
    char *tmps = SvPV(left, na);
d2146 1
a2146 1
    sv_setpv(TARG, fcrypt(tmps, SvPV(right, na)));
d2148 1
a2148 1
    sv_setpv(TARG, crypt(tmps, SvPV(right, na)));
d2160 1
a2160 1
    dSP;
d2163 1
d2171 1
a2171 1
    s = SvPV_force(sv, na);
d2173 1
a2173 1
	if (op->op_private & OPpLOCALE) {
d2187 1
a2187 1
    dSP;
d2190 1
d2198 1
a2198 1
    s = SvPV_force(sv, na);
d2200 1
a2200 1
	if (op->op_private & OPpLOCALE) {
d2215 1
a2215 1
    dSP;
d2231 1
a2231 1
	if (op->op_private & OPpLOCALE) {
d2247 1
a2247 1
    dSP;
d2263 1
a2263 1
	if (op->op_private & OPpLOCALE) {
d2279 1
a2279 1
    dSP; dTARGET;
d2308 1
a2308 1
    dSP; dMARK; dORIGMARK;
d2311 2
a2312 2
    register I32 lval = op->op_flags & OPf_MOD;
    I32 arybase = curcop->cop_arybase;
d2316 1
a2316 1
	if (lval && op->op_private & OPpLVAL_INTRO) {
d2318 1
a2318 1
	    for (svp = mark + 1; svp <= sp; svp++) {
d2333 1
a2333 1
		if (!svp || *svp == &sv_undef)
d2335 2
a2336 2
		if (op->op_private & OPpLVAL_INTRO)
		    save_svref(svp);
d2338 1
a2338 1
	    *MARK = svp ? *svp : &sv_undef;
d2353 1
a2353 1
    dSP; dTARGET;
d2357 2
a2358 1
    
d2360 2
a2361 1
    entry = hv_iternext(hash);		/* might clobber stack_sp */
d2369 3
a2371 1
	    sv_setsv(TARG, hv_iterval(hash, entry));  /* might hit stack_sp */
d2394 1
a2394 1
    dSP;
d2400 1
a2400 1
    if (op->op_private & OPpSLICE) {
d2402 1
d2404 1
a2404 2
	if (SvTYPE(hv) != SVt_PVHV)
	    DIE("Not a HASH reference");
d2406 5
a2410 2
	    sv = hv_delete_ent(hv, *MARK, discard, 0);
	    *MARK = sv ? sv : &sv_undef;
d2423 3
a2425 1
	if (SvTYPE(hv) != SVt_PVHV)
a2426 1
	sv = hv_delete_ent(hv, keysv, discard, 0);
d2428 1
a2428 1
	    sv = &sv_undef;
d2437 1
a2437 1
    dSP;
d2440 7
a2446 2
    STRLEN len;
    if (SvTYPE(hv) != SVt_PVHV) {
a2448 2
    if (hv_exists_ent(hv, tmpsv, 0))
	RETPUSHYES;
d2454 1
a2454 2
    dSP; dMARK; dORIGMARK;
    register HE *he;
d2456 5
a2460 1
    register I32 lval = op->op_flags & OPf_MOD;
d2462 1
a2462 1
    if (SvTYPE(hv) == SVt_PVHV) {
d2465 7
a2471 2

	    he = hv_fetch_ent(hv, keysv, lval, 0);
d2473 6
a2478 4
		if (!he || HeVAL(he) == &sv_undef)
		    DIE(no_helem, SvPV(keysv, na));
		if (op->op_private & OPpLVAL_INTRO)
		    save_svref(&HeVAL(he));
d2480 1
a2480 1
	    *MARK = he ? HeVAL(he) : &sv_undef;
d2495 1
a2495 1
    dSP; dMARK;
d2500 1
a2500 1
	    *MARK = &sv_undef;
d2508 4
a2511 4
    dSP;
    SV **lastrelem = stack_sp;
    SV **lastlelem = stack_base + POPMARK;
    SV **firstlelem = stack_base + POPMARK + 1;
d2513 2
a2514 2
    I32 arybase = curcop->cop_arybase;
    I32 lval = op->op_flags & OPf_MOD;
d2528 1
a2528 1
	    *firstlelem = &sv_undef;
d2545 1
a2545 1
		*lelem = &sv_undef;
d2547 1
a2547 1
		*lelem = &sv_undef;
d2552 1
a2552 1
		*lelem = &sv_undef;
d2566 1
a2566 1
    dSP; dMARK; dORIGMARK;
d2576 1
a2576 1
    dSP; dMARK; dORIGMARK;
d2584 2
a2585 2
	else if (dowarn)
	    warn("Odd number of elements in hash list");
d2595 1
a2595 1
    dSP; dMARK; dORIGMARK;
d2606 12
d2624 1
a2624 1
	    offset += AvFILL(ary) + 1;
d2626 1
a2626 1
	    offset -= curcop->cop_arybase;
d2631 5
a2635 2
	    if (length < 0)
		length = 0;
d2644 3
a2646 3
    if (offset > AvFILL(ary) + 1)
	offset = AvFILL(ary) + 1;
    after = AvFILL(ary) + 1 - (offset + length);
d2678 1
a2678 2
		    if (!SvIMMORTAL(*dst))
			sv_2mortal(*dst);	/* free them eventualy */
d2687 1
a2687 2
		if (!SvIMMORTAL(*MARK))
		    sv_2mortal(*MARK);
d2692 1
a2692 1
	AvFILL(ary) += diff;
d2713 1
a2713 1
	    dst = &AvARRAY(ary)[AvFILL(ary)+1];
d2718 1
a2718 1
	    dst[--i] = &sv_undef;
d2747 1
a2747 1
		AvFILL(ary) += diff;
d2750 3
a2752 3
		if (AvFILL(ary) + diff >= AvMAX(ary))	/* oh, well */
		    av_extend(ary, AvFILL(ary) + diff);
		AvFILL(ary) += diff;
d2755 1
a2755 1
		    dst = AvARRAY(ary) + AvFILL(ary);
d2775 1
a2775 2
			if (!SvIMMORTAL(*dst))
			    sv_2mortal(*dst);	/* free them eventualy */
d2786 1
a2786 2
		if (!SvIMMORTAL(*MARK))
		    sv_2mortal(*MARK);
d2793 1
a2793 1
	    *MARK = &sv_undef;
d2801 1
a2801 1
    dSP; dMARK; dORIGMARK; dTARGET;
d2803 2
a2804 1
    register SV *sv = &sv_undef;
d2806 17
a2822 5
    for (++MARK; MARK <= SP; MARK++) {
	sv = NEWSV(51, 0);
	if (*MARK)
	    sv_setsv(sv, *MARK);
	av_push(ary, sv);
d2831 1
a2831 1
    dSP;
d2834 1
a2834 1
    if (!SvIMMORTAL(sv) && AvREAL(av))
d2842 1
a2842 1
    dSP;
d2848 1
a2848 1
    if (!SvIMMORTAL(sv) && AvREAL(av))
d2856 1
a2856 1
    dSP; dMARK; dORIGMARK; dTARGET;
d2860 1
d2862 16
a2877 5
    av_unshift(ary, SP - MARK);
    while (MARK < SP) {
	sv = NEWSV(27, 0);
	sv_setsv(sv, *++MARK);
	(void)av_store(ary, i++, sv);
a2878 1

d2886 1
a2886 1
    dSP; dMARK;
d2907 1
a2907 1
	    do_join(TARG, &sv_no, MARK, SP);
d2909 1
a2909 1
	    sv_setsv(TARG, (SP > MARK) ? *SP : GvSV(defgv));
d2926 2
a2927 4
static SV      *
mul128(sv, m)
     SV             *sv;
     U8              m;
d2935 1
a2935 1
    SV             *new = newSVpv("0000000000", 10);
d2937 1
a2937 1
    sv_catsv(new, sv);
d2939 1
a2939 1
    sv = new;
d2955 16
d2973 1
a2973 1
    dSP;
d2975 1
a2975 1
    SV **oldsp = sp;
d3008 1
d3010 1
d3016 1
a3016 1
	if (strchr("aAbBhHP", *patend) || *pat == '%') {
d3046 1
a3046 1
	    if (commas++ == 0 && dowarn)
d3074 1
d3083 1
a3083 1
	    if (datumtype == 'A') {
d3085 11
a3095 4
		s = SvPVX(sv) + len - 1;
		while (s >= SvPVX(sv) && (!*s || isSPACE(*s)))
		    s--;
		*++s = '\0';
d3185 1
a3185 1
		    *pat++ = hexdigit[bits & 15];
d3195 1
a3195 1
		    *pat++ = hexdigit[(bits >> 4) & 15];
d3254 4
d3267 4
d3290 1
a3290 1
			aushort = ntohs(aushort);
d3308 1
a3308 1
			aushort = ntohs(aushort);
d3340 7
d3373 11
d3396 4
d3412 4
d3435 1
a3435 1
			aulong = ntohl(aulong);
d3455 1
a3455 1
			aulong = ntohl(aulong);
d3489 1
a3489 1
	    { 
d3505 1
d3515 1
a3515 1
			t = SvPV(sv, na);
d3543 3
d3564 3
d3577 1
a3577 1
		if (aquad <= UV_MAX)
d3635 17
d3656 1
a3656 1
	    while (s < strend && *s > ' ' && *s < 'a') {
d3661 1
a3661 1
		len = (*s++ - ' ') & 077;
d3663 14
a3676 14
		    if (s < strend && *s >= ' ')
			a = (*s++ - ' ') & 077;
		    else
			a = 0;
		    if (s < strend && *s >= ' ')
			b = (*s++ - ' ') & 077;
		    else
			b = 0;
		    if (s < strend && *s >= ' ')
			c = (*s++ - ' ') & 077;
		    else
			c = 0;
		    if (s < strend && *s >= ' ')
			d = (*s++ - ' ') & 077;
d3679 4
a3682 4
		    hunk[0] = a << 2 | b >> 4;
		    hunk[1] = b << 4 | c >> 2;
		    hunk[2] = c << 6 | d;
		    sv_catpvn(sv, hunk, len > 3 ? 3 : len);
d3727 2
a3728 2
    if (sp == oldsp && gimme == G_SCALAR)
	PUSHs(&sv_undef);
d3732 2
a3733 5
static void
doencodes(sv, s, len)
register SV *sv;
register char *s;
register I32 len;
d3737 1
a3737 1
    *hunk = len + ' ';
d3740 5
a3744 5
    while (len > 0) {
	hunk[0] = ' ' + (077 & (*s >> 2));
	hunk[1] = ' ' + (077 & ((*s << 4) & 060 | (s[1] >> 4) & 017));
	hunk[2] = ' ' + (077 & ((s[1] << 2) & 074 | (s[2] >> 6) & 03));
	hunk[3] = ' ' + (077 & (s[2] & 077));
d3749 7
a3755 3
    for (s = SvPVX(sv); *s; s++) {
	if (*s == ' ')
	    *s = '`';
d3760 2
a3761 4
static SV      *
is_an_int(s, l)
     char           *s;
     STRLEN          l;
d3763 1
d3765 1
a3765 1
  char           *result_c = SvPV(result, na);	/* convenience */
d3809 4
a3812 4
static int
div128(pnum, done)
     SV             *pnum;		    /* must be '\0' terminated */
     bool           *done;
d3840 1
a3840 1
    dSP; dMARK; dORIGMARK; dTARGET;
d3873 1
a3873 1
#define NEXTFROM (items-- > 0 ? *MARK++ : &sv_no)
d3892 1
a3892 1
	    if (commas++ == 0 && dowarn)
d3921 1
d4095 1
a4095 1
		ashort = htons(ashort);
d4161 1
a4161 1
            
d4207 1
a4207 1
		aulong = htonl(aulong);
d4258 1
a4258 1
		if (fromstr == &sv_undef)
d4261 1
d4267 1
a4267 1
		    if (dowarn && (SvTEMP(fromstr) || SvPADTMP(fromstr)))
d4270 1
a4270 1
			aptr = SvPV(fromstr,na);
d4272 1
a4272 1
			aptr = SvPV_force(fromstr,na);
d4306 1
d4309 1
a4309 1
    dSP; dTARG;
d4327 1
a4327 1
    AV *oldstack = curstack;
d4329 3
a4331 1
    I32 oldsave = savestack_ix;
d4348 5
a4352 1
	ary = GvAVn(defgv);
d4357 1
a4357 5
	if (!AvREAL(ary)) {
	    AvREAL_on(ary);
	    for (i = AvFILL(ary); i >= 0; i--)
		AvARRAY(ary)[i] = &sv_undef;	/* don't free mere refs */
	}
d4360 15
a4374 2
	/* temporarily switch stacks */
	SWITCHSTACK(curstack, ary);
d4376 1
a4376 1
    base = SP - stack_base;
d4389 2
a4390 2
	SAVEINT(multiline);
	multiline = pm->op_pmflags & PMf_MULTILINE;
d4407 1
a4407 1
	    if (!realarray)
d4427 1
a4427 1
	    if (!realarray)
d4433 6
a4438 4
    else if (pm->op_pmshort && !rx->nparens) {
	i = SvCUR(pm->op_pmshort);
	if (i == 1) {
	    i = *SvPVX(pm->op_pmshort);
d4446 1
a4446 1
		if (!realarray)
d4456 1
a4456 1
		    pm->op_pmshort)) )
d4461 1
a4461 1
		if (!realarray)
d4471 1
a4471 1
	       pregexec(rx, s, strend, orig, 1, Nullsv, TRUE))
d4473 1
a4473 1
	    TAINT_IF(rx->exec_tainted);
d4485 1
a4485 1
	    if (!realarray)
d4498 1
a4498 1
		    if (!realarray)
d4506 1
d4508 1
a4508 1
    iters = (SP - stack_base) - base;
d4511 1
a4511 1
    
d4516 1
a4516 1
	if (!realarray)
d4525 1
d4527 15
a4541 2
	SWITCHSTACK(ary, oldstack);
	if (SvSMAGICAL(ary)) {
d4543 3
a4545 1
	    mg_set((SV*)ary);
d4547 9
a4555 6
	}
	if (gimme == G_ARRAY) {
	    EXTEND(SP, iters);
	    Copy(AvARRAY(ary), SP + 1, iters, SV*);
	    SP += iters;
	    RETURN;
d4570 67
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1994, Larry Wall
d18 87
a104 1
static void doencodes _((SV *sv, char *s, I32 len));
d111 1
a111 1
    if (GIMME != G_ARRAY) {
a112 1
    }
d151 2
d158 2
a159 1
    if (GIMME == G_ARRAY) { /* array wanted */
d162 1
a162 1
    else {
d164 3
a166 4
	if (HvFILL((HV*)TARG)) {
	    sprintf(buf, "%d/%d", HvFILL((HV*)TARG), HvMAX((HV*)TARG)+1);
	    sv_setpv(sv, buf);
	}
a169 1
	RETURN;
d171 1
d188 7
a194 1
	if (SvTYPE(sv) != SVt_PVGV)
d210 2
d220 2
a221 22
    if (op->op_private & OPpLVAL_INTRO) {
	GP *ogp = GvGP(sv);

	SSCHECK(3);
	SSPUSHPTR(SvREFCNT_inc(sv));
	SSPUSHPTR(ogp);
	SSPUSHINT(SAVEt_GP);

	if (op->op_flags & OPf_SPECIAL) {
	    GvGP(sv)->gp_refcnt++;		/* will soon be assigned */
	    GvINTRO_on(sv);
	}
	else {
	    GP *gp;
	    Newz(602,gp, 1, GP);
	    GvGP(sv) = gp;
	    GvREFCNT(sv) = 1;
	    GvSV(sv) = NEWSV(72,0);
	    GvLINE(sv) = curcop->cop_line;
	    GvEGV(sv) = sv;
	}
    }
d241 1
a241 1
	GV *gv = sv;
d254 2
d261 1
a261 1
	    gv = (SV*)gv_fetchpv(sym, TRUE, SVt_PV);
d268 2
a269 2
	else if (op->op_private & (OPpDEREF_HV|OPpDEREF_AV))
	    provide_ref(op, sv);
d294 6
a299 1
	LvTYPE(TARG) = '<';
d327 5
a331 2

    if (!cv)
d347 2
a348 4
    if (cv && SvPOK(cv)) {
	char *p = SvPVX(cv);
	ret = sv_2mortal(newSVpv(p ? p : "", SvLEN(cv)));
    }
d356 1
a356 3
    CV* cv = (CV*)cSVOP->op_sv;
    EXTEND(SP,1);

d359 1
a359 1

d366 2
a367 13
    dSP; dTOPss;
    SV* rv;
    rv = sv_newmortal();
    sv_upgrade(rv, SVt_RV);
    if (SvPADTMP(sv))
	sv = newSVsv(sv);
    else {
	SvTEMP_off(sv);
	(void)SvREFCNT_inc(sv);
    }
    SvRV(rv) = sv;
    SvROK_on(rv);
    SETs(rv);
a373 2
    SV* sv;
    SV* rv;
d378 23
a400 13
    while (MARK < SP) {
	sv = *++MARK;
	rv = sv_newmortal();
	sv_upgrade(rv, SVt_RV);
	if (SvPADTMP(sv))
	    sv = newSVsv(sv);
	else {
	    SvTEMP_off(sv);
	    (void)SvREFCNT_inc(sv);
	}
	SvRV(rv) = sv;
	SvROK_on(rv);
	*MARK = rv;
d402 5
a406 1
    RETURN;
d416 4
d443 62
a514 1
    I32 retval;
d517 4
a520 4
    s = (unsigned char*)(SvPV(sv, len));
    pos = len;
    if (sv == lastscream)
	SvSCREAM_off(sv);
d528 5
a532 4
    if (pos <= 0) {
	retval = 0;
	goto ret;
    }
a561 7

	/* If there were any case insensitive searches, we must assume they
	 * all are.  This speeds up insensitive searches much more than
	 * it slows down sensitive ones.
	 */
	if (sawi)
	    sfirst[fold[ch]] = pos;
d566 1
a566 4
    retval = 1;
  ret:
    XPUSHs(sv_2mortal(newSViv((I32)retval)));
    RETURN;
d632 1
a632 1
	if (AvMAX(sv) >= 0 || SvRMAGICAL(sv))
d636 1
a636 1
	if (HvARRAY(sv) || SvRMAGICAL(sv))
d657 2
a658 1
    if (!op->op_private)
d660 1
d683 8
a690 2
	cv_undef((CV*)sv);
	sub_generation++;
d693 3
a695 4
        if (SvFAKE(sv)) {
            sv_setsv(sv, &sv_undef);
            break;
        }
d697 1
a697 1
	if (SvPOK(sv) && SvLEN(sv)) {
d713 5
a717 1
    if (SvIOK(TOPs)) {
d719 1
a719 1
	SvFLAGS(TOPs) &= ~(SVf_NOK|SVf_POK|SVp_NOK|SVp_POK);
d730 2
d733 3
a735 1
    if (SvIOK(TOPs)) {
d737 1
a737 1
	SvFLAGS(TOPs) &= ~(SVf_NOK|SVf_POK|SVp_NOK|SVp_POK);
d751 2
d754 3
a756 1
    if (SvIOK(TOPs)) {
d758 1
a758 1
	SvFLAGS(TOPs) &= ~(SVf_NOK|SVf_POK|SVp_NOK|SVp_POK);
d793 3
a795 2
      dPOPnv;
      if (value == 0.0)
d800 4
a803 6
	double x;
	I32    k;
	x =  POPn;
	if ((double)I_32(x)     == x &&
	    (double)I_32(value) == value &&
	    (k = I_32(x)/I_32(value))*I_32(value) == I_32(x)) {
d806 1
a806 1
	    value = x/value;
d810 1
a810 1
      value = POPn / value;
d821 23
a843 3
      register unsigned long tmpulong;
      register long tmplong;
      I32 value;
d845 1
a845 2
      tmpulong = (unsigned long) POPn;
      if (tmpulong == 0L)
d847 11
a857 6
      value = TOPn;
      if (value >= 0.0)
	value = (I32)(((unsigned long)value) % tmpulong);
      else {
	tmplong = (long)value;
	value = (I32)(tmpulong - ((-tmplong - 1) % tmpulong)) - 1;
d859 3
a861 1
      SETi(value);
d905 5
a909 3
	if (count >= 1) {
	    SvGROW(TARG, (count * len) + 1);
	    if (count > 1)
d911 2
a912 1
	    SvCUR(TARG) *= count;
a913 1
	    (void)SvPOK_only(TARG);
d915 1
a915 2
	else
	    sv_setsv(TARG, &sv_no);
d926 1
a926 1
      dPOPTOPnnrl;
d936 12
a947 3
        dPOPTOPiirl;
        SETi( left << right );
        RETURN;
d955 11
a965 2
      dPOPTOPiirl;
      SETi( left >> right );
d975 1
a975 1
      SETs((TOPn < value) ? &sv_yes : &sv_no);
d985 1
a985 1
      SETs((TOPn > value) ? &sv_yes : &sv_no);
d995 1
a995 1
      SETs((TOPn <= value) ? &sv_yes : &sv_no);
d1005 1
a1005 1
      SETs((TOPn >= value) ? &sv_yes : &sv_no);
d1015 1
a1015 1
      SETs((TOPn != value) ? &sv_yes : &sv_no);
d1027 2
a1028 2
      if (left > right)
	value = 1;
d1031 6
a1036 2
      else
	value = 0;
d1047 4
a1050 1
      SETs( sv_cmp(left, right) < 0 ? &sv_yes : &sv_no );
d1060 4
a1063 1
      SETs( sv_cmp(left, right) > 0 ? &sv_yes : &sv_no );
d1073 4
a1076 1
      SETs( sv_cmp(left, right) <= 0 ? &sv_yes : &sv_no );
d1086 14
a1099 1
      SETs( sv_cmp(left, right) >= 0 ? &sv_yes : &sv_no );
d1109 1
a1109 1
      SETs( !sv_eq(left, right) ? &sv_yes : &sv_no );
d1119 4
a1122 1
      SETi( sv_cmp(left, right) );
d1127 2
a1128 1
PP(pp_bit_and) {
d1133 8
a1140 3
	unsigned long value = U_L(SvNV(left));
	value = value & U_L(SvNV(right));
	SETn((double)value);
d1156 8
a1163 3
	unsigned long value = U_L(SvNV(left));
	value = value ^ U_L(SvNV(right));
	SETn((double)value);
d1179 8
a1186 3
	unsigned long value = U_L(SvNV(left));
	value = value | U_L(SvNV(right));
	SETn((double)value);
d1203 3
a1205 1
	if (SvNIOKp(sv))
d1210 1
a1210 1
	    if (isALPHA(*s) || *s == '_') {
d1233 1
a1233 1
    *stack_sp = SvTRUE(*stack_sp) ? &sv_no : &sv_yes;
a1241 2
      register I32 anum;

d1243 8
a1250 5
	IV iv = ~SvIV(sv);
	if (iv < 0)
	    SETn( (double) ~U_L(SvNV(sv)) );
	else
	    SETi( iv );
d1255 1
d1308 2
d1340 1
a1340 1
      SETs((left < right) ? &sv_yes : &sv_no);
d1350 1
a1350 1
      SETs((left > right) ? &sv_yes : &sv_no);
d1360 1
a1360 1
      SETs((left <= right) ? &sv_yes : &sv_no);
d1370 1
a1370 1
      SETs((left >= right) ? &sv_yes : &sv_no);
d1380 1
a1380 1
      SETs((left == right) ? &sv_yes : &sv_no);
d1390 1
a1390 1
      SETs((left != right) ? &sv_yes : &sv_no);
d1466 4
d1490 3
a1492 7
    I32 anum;
    Time_t when;

    if (MAXARG < 1) {
	(void)time(&when);
	anum = when;
    }
d1494 3
a1496 2
	anum = POPi;
    (void)srand(anum);
d1501 52
d1571 2
a1572 1
      if (value <= 0.0)
d1574 1
d1587 2
a1588 1
      if (value < 0.0)
d1590 1
d1600 21
a1620 7
    double value;
    value = POPn;
    if (value >= 0.0)
	(void)modf(value, &value);
    else {
	(void)modf(-value, &value);
	value = -value;
a1621 1
    XPUSHn(value);
d1629 2
a1630 2
      double value;
      value = POPn;
d1632 11
a1642 5
      if (value < 0.0)
	value = -value;

      XPUSHn(value);
      RETURN;
d1644 1
a1650 1
    unsigned long value;
d1654 1
a1654 5
    value = scan_hex(tmps, 99, &argtype);
    if ((IV)value >= 0)
	XPUSHi(value);
    else
	XPUSHn(U_V(value));
d1661 1
a1661 1
    unsigned long value;
d1674 1
a1674 4
    if ((IV)value >= 0)
	XPUSHi(value);
    else
	XPUSHn(U_V(value));
d1695 1
d1702 1
a1702 1
    pos = POPi - arybase;
d1705 35
a1739 4
    if (pos < 0)
	pos += curlen + arybase;
    if (pos < 0 || pos > curlen) {
	if (dowarn || lvalue)
a1743 7
	if (MAXARG < 3)
	    len = curlen;
	else if (len < 0) {
	    len += curlen - pos;
	    if (len < 0)
		len = 0;
	}
a1744 3
	rem = curlen - pos;	/* rem=how many bytes left*/
	if (rem > len)
	    rem = len;
d1747 12
a1758 2
	    if (!SvGMAGICAL(sv))
		(void)SvPOK_only(sv);
d1764 1
a1764 1
	    LvTYPE(TARG) = 's';
d1843 1
a1843 1
    sv_setiv(TARG, (I32)retnum);
d1920 6
d1927 1
d1999 9
a2007 2
    if (isLOWER(*s))
	*s = toUPPER(*s);
d2025 9
a2033 2
    if (isUPPER(*s))
	*s = toLOWER(*s);
a2043 1
    register char *send;
d2052 1
d2054 13
a2066 5
    send = s + len;
    while (s < send) {
	if (isLOWER(*s))
	    *s = toUPPER(*s);
	s++;
a2075 1
    register char *send;
d2084 1
d2086 13
a2098 5
    send = s + len;
    while (s < send) {
	if (isUPPER(*s))
	    *s = toLOWER(*s);
	s++;
d2182 1
a2182 2
    I32 i;
    char *tmps;
d2185 1
a2185 1
    entry = hv_iternext(hash);                        /* might clobber stack_sp */
d2190 2
a2191 5
	tmps = hv_iterkey(entry, &i);	              /* won't clobber stack_sp */
	if (!i)
	    tmps = "";
	PUSHs(sv_2mortal(newSVpv(tmps, i)));
	if (GIMME == G_ARRAY) {
d2193 1
a2193 1
	    sv_setsv(TARG, hv_iterval(hash, entry));  /* might clobber stack_sp */
d2198 1
a2198 1
    else if (GIMME == G_SCALAR)
d2217 2
d2220 29
a2248 6
    SV *tmpsv = POPs;
    HV *hv = (HV*)POPs;
    char *tmps;
    STRLEN len;
    if (SvTYPE(hv) != SVt_PVHV) {
	DIE("Not a HASH reference");
a2249 6
    tmps = SvPV(tmpsv, len);
    sv = hv_delete(hv, tmps, len,
	op->op_private & OPpLEAVE_VOID ? G_DISCARD : 0);
    if (!sv)
	RETPUSHUNDEF;
    PUSHs(sv);
a2257 1
    char *tmps;
d2262 1
a2262 2
    tmps = SvPV(tmpsv, len);
    if (hv_exists(hv, tmps, len))
d2270 1
a2270 1
    register SV **svp;
d2276 1
a2276 2
	    STRLEN keylen;
	    char *key = SvPV(*MARK, keylen);
d2278 1
a2278 1
	    svp = hv_fetch(hv, key, keylen, lval);
d2280 2
a2281 2
		if (!svp || *svp == &sv_undef)
		    DIE(no_helem, key);
d2283 1
a2283 1
		    save_svref(svp);
d2285 1
a2285 1
	    *MARK = svp ? *svp : &sv_undef;
d2359 1
a2359 1
	if (!is_something_there && (SvOKp(*lelem) || SvGMAGICAL(*lelem)))
d2371 1
a2371 1
    dSP; dMARK;
d2373 3
a2375 2
    SP = MARK;
    XPUSHs((SV*)sv_2mortal((SV*)av_make(items, MARK+1)));
a2381 1
    STRLEN len;
a2385 1
	char *tmps;
d2389 1
a2389 1
	else
d2391 1
a2391 2
	tmps = SvPV(key,len);
	(void)hv_store(hv,tmps,len,val,0);
d2415 1
a2415 1
	offset = SvIVx(*MARK);
d2420 2
a2433 6
    if (offset < 0) {
	length += offset;
	offset = 0;
	if (length < 0)
	    length = 0;
    }
d2448 6
d2466 6
a2471 2
		for (i = length, dst = MARK; i; i--)
		    sv_2mortal(*dst++);	/* free them eventualy */
d2478 2
a2479 1
		sv_2mortal(*MARK);
d2565 6
a2570 2
		    for (i = length, dst = MARK; i; i--)
			sv_2mortal(*dst++);	/* free them eventualy */
d2579 2
a2580 1
		sv_2mortal(*MARK);
d2615 1
a2615 1
    if (sv != &sv_undef && AvREAL(av))
d2629 1
a2629 1
    if (sv != &sv_undef && AvREAL(av))
d2679 1
a2679 1
	    sv_setsv(TARG, *SP);
d2696 29
d2731 2
d2765 1
d2767 1
a2767 1
    if (GIMME != G_ARRAY) {		/* arrange to do first one only */
d2780 3
a2782 1
	datumtype = *pat++;
d2798 4
d2961 1
d2967 1
a2967 1
		    sv_setiv(sv, (I32)aint);
d2984 1
d2988 1
a2988 1
		    sv_setiv(sv, (I32)auint);
d2994 1
a2994 1
	    along = (strend - s) / sizeof(I16);
d2999 2
a3000 2
		    Copy(s, &ashort, 1, I16);
		    s += sizeof(I16);
d3006 1
d3008 2
a3009 2
		    Copy(s, &ashort, 1, I16);
		    s += sizeof(I16);
d3011 1
a3011 1
		    sv_setiv(sv, (I32)ashort);
d3019 1
a3019 1
	    along = (strend - s) / sizeof(U16);
d3024 2
a3025 2
		    Copy(s, &aushort, 1, U16);
		    s += sizeof(U16);
d3039 1
d3041 2
a3042 2
		    Copy(s, &aushort, 1, U16);
		    s += sizeof(U16);
d3052 1
a3052 1
		    sv_setiv(sv, (I32)aushort);
d3073 1
d3078 1
a3078 1
		    sv_setiv(sv, (I32)aint);
d3099 1
d3104 1
a3104 1
		    sv_setiv(sv, (I32)auint);
d3110 1
a3110 1
	    along = (strend - s) / sizeof(I32);
d3115 2
a3116 2
		    Copy(s, &along, 1, I32);
		    s += sizeof(I32);
d3125 1
d3127 2
a3128 2
		    Copy(s, &along, 1, I32);
		    s += sizeof(I32);
d3130 1
a3130 1
		    sv_setiv(sv, (I32)along);
d3138 1
a3138 1
	    along = (strend - s) / sizeof(U32);
d3143 2
a3144 2
		    Copy(s, &aulong, 1, U32);
		    s += sizeof(U32);
d3161 1
d3163 2
a3164 3
		    Copy(s, &aulong, 1, U32);
		    s += sizeof(U32);
		    sv = NEWSV(43, 0);
d3173 2
a3174 1
		    sv_setnv(sv, (double)aulong);
d3184 1
d3198 41
d3255 1
d3264 4
a3267 1
		sv_setiv(sv, (IV)aquad);
d3273 1
d3282 4
a3285 1
		sv_setiv(sv, (IV)auquad);
d3305 1
d3329 1
d3342 2
d3406 2
a3407 2
		    along = (1 << checksum) - 1;
		    culong &= (U32)along;
d3409 1
a3409 1
		sv_setnv(sv, (double)culong);
d3415 2
d3447 79
d3555 1
d3562 3
a3564 1
	datumtype = *pat++;
d3578 4
d3784 1
a3784 1
		sv_catpvn(cat, (char*)&ashort, sizeof(I16));
d3794 1
a3794 1
		sv_catpvn(cat, (char*)&ashort, sizeof(I16));
d3802 1
a3802 1
		sv_catpvn(cat, (char*)&ashort, sizeof(I16));
d3808 1
a3808 1
		auint = U_I(SvNV(fromstr));
d3812 70
d3892 1
a3892 1
		aulong = U_L(SvNV(fromstr));
d3896 1
a3896 1
		sv_catpvn(cat, (char*)&aulong, sizeof(U32));
d3902 1
a3902 1
		aulong = U_L(SvNV(fromstr));
d3906 1
a3906 1
		sv_catpvn(cat, (char*)&aulong, sizeof(U32));
d3912 2
a3913 2
		aulong = U_L(SvNV(fromstr));
		sv_catpvn(cat, (char*)&aulong, sizeof(U32));
d3920 1
a3920 1
		sv_catpvn(cat, (char*)&along, sizeof(I32));
d3945 15
a3959 1
		aptr = SvPV_force(fromstr, na);	/* XXX Error if TEMP? */
d4001 2
a4002 1
    register PMOP *pm = (PMOP*)POPs;
d4012 2
a4013 3
    AV *oldstack = stack;
    register REGEXP *rx = pm->op_pmregexp;
    I32 gimme = GIMME;
d4016 5
d4023 5
d4044 1
a4044 1
	SWITCHSTACK(stack, ary);
d4049 8
a4056 2
	while (isSPACE(*s))
	    s++;
d4067 5
a4071 2
	    /*SUPPRESS 530*/
	    for (m = s; m < strend && !isSPACE(*m); m++) ;
d4074 1
d4080 6
a4085 2
	    /*SUPPRESS 530*/
	    for (s = m + 1; s < strend && isSPACE(*s); s++) ;
d4103 1
a4103 1
    else if (pm->op_pmshort) {
a4105 1
	    I32 fold = (pm->op_pmflags & PMf_FOLD);
a4106 2
	    if (fold && isUPPER(i))
		i = toLOWER(i);
d4108 2
a4109 9
		if (fold) {
		    for ( m = s;
			  m < strend && *m != i &&
			    (!isUPPER(*m) || toLOWER(*m) != i);
			  m++)			/*SUPPRESS 530*/
			;
		}
		else				/*SUPPRESS 530*/
		    for (m = s; m < strend && *m != i; m++) ;
d4139 3
a4141 1
	    pregexec(rx, s, strend, orig, 1, Nullsv, TRUE) ) {
d4189 1
a4189 1
	while (iters > 0 && SvCUR(TOPs) == 0)
d4194 5
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1999, Larry Wall
d18 1
a18 93
/*
 * The compiler on Concurrent CX/UX systems has a subtle bug which only
 * seems to show up when compiling pp.c - it generates the wrong double
 * precision constant value for (double)UV_MAX when used inline in the body
 * of the code below, so this makes a static variable up front (which the
 * compiler seems to get correct) and uses it in place of UV_MAX below.
 */
#ifdef CXUX_BROKEN_CONSTANT_CONVERT
static double UV_MAX_cxux = ((double)UV_MAX);
#endif

/*
 * Types used in bitwise operations.
 *
 * Normally we'd just use IV and UV.  However, some hardware and
 * software combinations (e.g. Alpha and current OSF/1) don't have a
 * floating-point type to use for NV that has adequate bits to fully
 * hold an IV/UV.  (In other words, sizeof(long) == sizeof(double).)
 *
 * It just so happens that "int" is the right size almost everywhere.
 */
typedef int IBW;
typedef unsigned UBW;

/*
 * Mask used after bitwise operations.
 *
 * There is at least one realm (Cray word machines) that doesn't
 * have an integral type (except char) small enough to be represented
 * in a double without loss; that is, it has no 32-bit type.
 */
#if LONGSIZE > 4  && defined(_CRAY) && !defined(_CRAYMPP)
#  define BW_BITS  32
#  define BW_MASK  ((1 << BW_BITS) - 1)
#  define BW_SIGN  (1 << (BW_BITS - 1))
#  define BWi(i)  (((i) & BW_SIGN) ? ((i) | ~BW_MASK) : ((i) & BW_MASK))
#  define BWu(u)  ((u) & BW_MASK)
#else
#  define BWi(i)  (i)
#  define BWu(u)  (u)
#endif

/*
 * Offset for integer pack/unpack.
 *
 * On architectures where I16 and I32 aren't really 16 and 32 bits,
 * which for now are all Crays, pack and unpack have to play games.
 */

/*
 * These values are required for portability of pack() output.
 * If they're not right on your machine, then pack() and unpack()
 * wouldn't work right anyway; you'll need to apply the Cray hack.
 * (I'd like to check them with #if, but you can't use sizeof() in
 * the preprocessor.)  --???
 */
/*
    The appropriate SHORTSIZE, INTSIZE, LONGSIZE, and LONGLONGSIZE
    defines are now in config.h.  --Andy Dougherty  April 1998
 */
#define SIZE16 2
#define SIZE32 4

#if BYTEORDER > 0xFFFF && defined(_CRAY) && !defined(_CRAYMPP)
#  if BYTEORDER == 0x12345678
#    define OFF16(p)	(char*)(p)
#    define OFF32(p)	(char*)(p)
#  else
#    if BYTEORDER == 0x87654321
#      define OFF16(p)	((char*)(p) + (sizeof(U16) - SIZE16))
#      define OFF32(p)	((char*)(p) + (sizeof(U32) - SIZE32))
#    else
       }}}} bad cray byte order
#    endif
#  endif
#  define COPY16(s,p)  (*(p) = 0, Copy(s, OFF16(p), SIZE16, char))
#  define COPY32(s,p)  (*(p) = 0, Copy(s, OFF32(p), SIZE32, char))
#  define CAT16(sv,p)  sv_catpvn(sv, OFF16(p), SIZE16)
#  define CAT32(sv,p)  sv_catpvn(sv, OFF32(p), SIZE32)
#else
#  define COPY16(s,p)  Copy(s, p, SIZE16, char)
#  define COPY32(s,p)  Copy(s, p, SIZE32, char)
#  define CAT16(sv,p)  sv_catpvn(sv, (char*)(p), SIZE16)
#  define CAT32(sv,p)  sv_catpvn(sv, (char*)(p), SIZE32)
#endif

#ifndef PERL_OBJECT
static void doencodes _((SV* sv, char* s, I32 len));
static SV* refto _((SV* sv));
static U32 seed _((void));
static bool srand_called = FALSE;
#endif

a21 12
#ifdef I_UNISTD
#include <unistd.h>
#endif

/* XXX I can't imagine anyone who doesn't have this actually _needs_
   it, since pid_t is an integral type.
   --AD  2/20/1998
*/
#ifdef NEED_GETPID_PROTO
extern Pid_t getpid (void);
#endif

d24 4
a27 3
    djSP;
    if (GIMME_V == G_SCALAR)
	XPUSHs(&PL_sv_undef);
d40 3
a42 3
    djSP; dTARGET;
    if (PL_op->op_private & OPpLVAL_INTRO)
	SAVECLEARSV(PL_curpad[PL_op->op_targ]);
d44 1
a44 1
    if (PL_op->op_flags & OPf_REF) {
d51 1
a51 10
	if (SvMAGICAL(TARG)) {
	    U32 i;
	    for (i=0; i < maxarg; i++) {
		SV **svp = av_fetch((AV*)TARG, i, FALSE);
		SP[i+1] = (svp) ? *svp : &PL_sv_undef;
	    }
	}
	else {
	    Copy(AvARRAY((AV*)TARG), SP+1, maxarg, SV*);
	}
d65 1
a65 3
    djSP; dTARGET;
    I32 gimme;

d67 3
a69 3
    if (PL_op->op_private & OPpLVAL_INTRO)
	SAVECLEARSV(PL_curpad[PL_op->op_targ]);
    if (PL_op->op_flags & OPf_REF)
d71 1
a71 2
    gimme = GIMME_V;
    if (gimme == G_ARRAY) {
d74 1
a74 1
    else if (gimme == G_SCALAR) {
d76 4
a79 3
	if (HvFILL((HV*)TARG))
	    sv_setpvf(sv, "%ld/%ld",
		      (long)HvFILL((HV*)TARG), (long)HvMAX((HV*)TARG) + 1);
d83 1
a84 1
    RETURN;
d96 2
a97 2
    djSP; dTOPss;

d101 1
a101 7
	if (SvTYPE(sv) == SVt_PVIO) {
	    GV *gv = (GV*) sv_newmortal();
	    gv_init(gv, 0, "", 0, 0);
	    GvIOp(gv) = (IO *)sv;
	    (void)SvREFCNT_inc(sv);
	    sv = (SV*) gv;
	} else if (SvTYPE(sv) != SVt_PVGV)
a106 1
	    STRLEN n_a;
d114 2
a115 2
		if (PL_op->op_flags & OPf_REF ||
		    PL_op->op_private & HINT_STRICT_REFS)
a116 2
		if (PL_dowarn)
		    warn(warn_uninit);
d119 2
a120 2
	    sym = SvPV(sv, n_a);
	    if (PL_op->op_private & HINT_STRICT_REFS)
d125 22
a146 2
    if (PL_op->op_private & OPpLVAL_INTRO)
	save_gp((GV*)sv, !(PL_op->op_flags & OPf_SPECIAL));
d153 1
a153 1
    djSP; dTOPss;
d166 1
a166 1
	GV *gv = (GV*)sv;
a167 1
	STRLEN n_a;
d176 2
a177 2
		if (PL_op->op_flags & OPf_REF ||
		    PL_op->op_private & HINT_STRICT_REFS)
a178 2
		if (PL_dowarn)
		    warn(warn_uninit);
d181 2
a182 2
	    sym = SvPV(sv, n_a);
	    if (PL_op->op_private & HINT_STRICT_REFS)
d184 1
a184 1
	    gv = (GV*)gv_fetchpv(sym, TRUE, SVt_PV);
d188 2
a189 2
    if (PL_op->op_flags & OPf_MOD) {
	if (PL_op->op_private & OPpLVAL_INTRO)
d191 2
a192 2
	else if (PL_op->op_private & OPpDEREF)
	    vivify_ref(sv, PL_op->op_private & OPpDEREF);
d200 1
a200 1
    djSP;
d214 5
a218 14
    djSP; dTARGET; dPOPss;

    if (PL_op->op_flags & OPf_MOD) {
	if (SvTYPE(TARG) < SVt_PVLV) {
	    sv_upgrade(TARG, SVt_PVLV);
	    sv_magic(TARG, Nullsv, '.', Nullch, 0);
	}

	LvTYPE(TARG) = '.';
	if (LvTARG(TARG) != sv) {
	    if (LvTARG(TARG))
		SvREFCNT_dec(LvTARG(TARG));
	    LvTARG(TARG) = SvREFCNT_inc(sv);
	}
d223 1
a223 1
	MAGIC* mg;
d228 1
a228 1
		PUSHi(mg->mg_len + PL_curcop->cop_arybase);
d238 1
a238 1
    djSP;
d244 4
a247 7
    CV *cv = sv_2cv(TOPs, &stash, &gv, !(PL_op->op_flags & OPf_SPECIAL));
    if (cv) {
	if (CvCLONE(cv))
	    cv = (CV*)sv_2mortal((SV*)cv_clone(cv));
    }
    else
	cv = (CV*)&PL_sv_undef;
d254 1
a254 1
    djSP;
d260 5
a264 44
    ret = &PL_sv_undef;
    if (SvPOK(TOPs) && SvCUR(TOPs) >= 7) {
	char *s = SvPVX(TOPs);
	if (strnEQ(s, "CORE::", 6)) {
	    int code;
	    
	    code = keyword(s + 6, SvCUR(TOPs) - 6);
	    if (code < 0) {	/* Overridable. */
#define MAX_ARGS_OP ((sizeof(I32) - 1) * 2)
		int i = 0, n = 0, seen_question = 0;
		I32 oa;
		char str[ MAX_ARGS_OP * 2 + 2 ]; /* One ';', one '\0' */

		while (i < MAXO) {	/* The slow way. */
		    if (strEQ(s + 6, op_name[i]) || strEQ(s + 6, op_desc[i]))
			goto found;
		    i++;
		}
		goto nonesuch;		/* Should not happen... */
	      found:
		oa = opargs[i] >> OASHIFT;
		while (oa) {
		    if (oa & OA_OPTIONAL) {
			seen_question = 1;
			str[n++] = ';';
		    } else if (seen_question) 
			goto set;	/* XXXX system, exec */
		    if ((oa & (OA_OPTIONAL - 1)) >= OA_AVREF 
			&& (oa & (OA_OPTIONAL - 1)) <= OA_HVREF) {
			str[n++] = '\\';
		    }
		    /* What to do with R ((un)tie, tied, (sys)read, recv)? */
		    str[n++] = ("?$@@@@%&*$")[oa & (OA_OPTIONAL - 1)];
		    oa = oa >> 4;
		}
		str[n++] = '\0';
		ret = sv_2mortal(newSVpv(str, n - 1));
	    } else if (code)		/* Non-Overridable */
		goto set;
	    else {			/* None such */
	      nonesuch:
		croak("Cannot find an opnumber for \"%s\"", s+6);
	    }
	}
a265 4
    cv = sv_2cv(TOPs, &stash, &gv, FALSE);
    if (cv && SvPOK(cv))
	ret = sv_2mortal(newSVpv(SvPVX(cv), SvCUR(cv)));
  set:
d272 4
a275 2
    djSP;
    CV* cv = (CV*)PL_curpad[PL_op->op_targ];
d278 1
a278 1
    EXTEND(SP,1);
d285 1
a285 26
    djSP;
    *SP = refto(*SP);
    RETURN;
}

PP(pp_refgen)
{
    djSP; dMARK;
    if (GIMME != G_ARRAY) {
	if (++MARK <= SP)
	    *MARK = *SP;
	else
	    *MARK = &PL_sv_undef;
	*MARK = refto(*MARK);
	SP = MARK;
	RETURN;
    }
    EXTEND_MORTAL(SP - MARK);
    while (++MARK <= SP)
	*MARK = refto(*MARK);
    RETURN;
}

STATIC SV*
refto(SV *sv)
{
d287 3
a289 8

    if (SvTYPE(sv) == SVt_PVLV && LvTYPE(sv) == 'y') {
	if (LvTARGLEN(sv))
	    vivify_defelem(sv);
	if (!(sv = LvTARG(sv)))
	    sv = &PL_sv_undef;
    }
    else if (SvPADTMP(sv))
a294 2
    rv = sv_newmortal();
    sv_upgrade(rv, SVt_RV);
d297 28
a324 1
    return rv;
d329 1
a329 1
    djSP; dTARGET;
a333 4

    if (sv && SvGMAGICAL(sv))
	mg_get(sv);

d345 1
a345 1
    djSP;
d349 3
a351 9
	stash = PL_curcop->cop_stash;
    else {
	SV *ssv = POPs;
	STRLEN len;
	char *ptr = SvPV(ssv,len);
	if (PL_dowarn && len == 0)
	    warn("Explicit blessing to '' (assuming package main)");
	stash = gv_stashpvn(ptr, len, TRUE);
    }
a356 63
PP(pp_gelem)
{
    GV *gv;
    SV *sv;
    SV *tmpRef;
    char *elem;
    djSP;
    STRLEN n_a;

    sv = POPs;
    elem = SvPV(sv, n_a);
    gv = (GV*)POPs;
    tmpRef = Nullsv;
    sv = Nullsv;
    switch (elem ? *elem : '\0')
    {
    case 'A':
	if (strEQ(elem, "ARRAY"))
	    tmpRef = (SV*)GvAV(gv);
	break;
    case 'C':
	if (strEQ(elem, "CODE"))
	    tmpRef = (SV*)GvCVu(gv);
	break;
    case 'F':
	if (strEQ(elem, "FILEHANDLE")) /* XXX deprecate in 5.005 */
	    tmpRef = (SV*)GvIOp(gv);
	break;
    case 'G':
	if (strEQ(elem, "GLOB"))
	    tmpRef = (SV*)gv;
	break;
    case 'H':
	if (strEQ(elem, "HASH"))
	    tmpRef = (SV*)GvHV(gv);
	break;
    case 'I':
	if (strEQ(elem, "IO"))
	    tmpRef = (SV*)GvIOp(gv);
	break;
    case 'N':
	if (strEQ(elem, "NAME"))
	    sv = newSVpv(GvNAME(gv), GvNAMELEN(gv));
	break;
    case 'P':
	if (strEQ(elem, "PACKAGE"))
	    sv = newSVpv(HvNAME(GvSTASH(gv)), 0);
	break;
    case 'S':
	if (strEQ(elem, "SCALAR"))
	    tmpRef = GvSV(gv);
	break;
    }
    if (tmpRef)
	sv = newRV(tmpRef);
    if (sv)
	sv_2mortal(sv);
    else
	sv = &PL_sv_undef;
    XPUSHs(sv);
    RETURN;
}

d361 1
a361 2
    djSP; dPOPss;
    register UNOP *unop = cUNOP;
d367 1
a369 12
    if (sv == PL_lastscream) {
	if (SvSCREAM(sv))
	    RETPUSHYES;
    }
    else {
	if (PL_lastscream) {
	    SvSCREAM_off(PL_lastscream);
	    SvREFCNT_dec(PL_lastscream);
	}
	PL_lastscream = SvREFCNT_inc(sv);
    }

d372 18
a389 7
    if (pos <= 0)
	RETPUSHNO;
    if (pos > PL_maxscream) {
	if (PL_maxscream < 0) {
	    PL_maxscream = pos + 80;
	    New(301, PL_screamfirst, 256, I32);
	    New(302, PL_screamnext, PL_maxscream, I32);
d392 2
a393 2
	    PL_maxscream = pos + pos / 4;
	    Renew(PL_screamnext, PL_maxscream, I32);
d397 2
a398 2
    sfirst = PL_screamfirst;
    snext = PL_screamnext;
d414 7
d425 4
a428 1
    RETPUSHYES;
d433 1
a433 1
    djSP; dTARG;
d436 1
a436 1
    if (PL_op->op_flags & OPf_STACKED)
d439 1
a439 1
	sv = DEFSV;
d443 1
a443 1
    PUSHi(do_trans(sv, PL_op));
d451 1
a451 1
    djSP; dTARGET;
d459 1
a459 1
    djSP; dMARK; dTARGET;
d468 1
a468 1
    djSP; dTARGET;
d475 1
a475 1
    djSP; dMARK; dTARGET;
d477 1
a477 1

d486 1
a486 1
    djSP;
d494 1
a494 1
	if (AvMAX(sv) >= 0 || SvGMAGICAL(sv) || (SvRMAGICAL(sv) && mg_find(sv,'P')))
d498 1
a498 1
	if (HvARRAY(sv) || SvGMAGICAL(sv) || (SvRMAGICAL(sv) && mg_find(sv,'P')))
d516 1
a516 1
    djSP;
d519 1
a519 2
    if (!PL_op->op_private) {
	EXTEND(SP, 1);
a520 1
    }
d527 2
a528 5
	if (SvREADONLY(sv)) {
	    dTHR;
	    if (PL_curcop != &PL_compiling)
		croak(no_modify);
	}
d543 2
a544 8
	if (PL_dowarn && cv_const_sv((CV*)sv))
	    warn("Constant subroutine %s undefined",
		 CvANON((CV*)sv) ? "(anonymous)" : GvENAME(CvGV((CV*)sv)));
	/* FALL THROUGH */
    case SVt_PVFM:
	{ GV* gv = (GV*)SvREFCNT_inc(CvGV((CV*)sv));
	  cv_undef((CV*)sv);
	  CvGV((CV*)sv) = gv; }   /* let user-undef'd sub keep its identity */
d547 4
a550 13
	if (SvFAKE(sv))
	    SvSetMagicSV(sv, &PL_sv_undef);
	else {
	    GP *gp;
	    gp_free((GV*)sv);
	    Newz(602, gp, 1, GP);
	    GvGP(sv) = gp_ref(gp);
	    GvSV(sv) = NEWSV(72,0);
	    GvLINE(sv) = PL_curcop->cop_line;
	    GvEGV(sv) = (GV*)sv;
	    GvMULTI_on(sv);
	}
	break;
d552 1
a552 1
	if (SvTYPE(sv) >= SVt_PV && SvPVX(sv) && SvLEN(sv)) {
d567 2
a568 6
    djSP;
    if (SvREADONLY(TOPs) || SvTYPE(TOPs) > SVt_PVLV)
	croak(no_modify);
    if (SvIOK(TOPs) && !SvNOK(TOPs) && !SvPOK(TOPs) &&
    	SvIVX(TOPs) != IV_MIN)
    {
d570 1
a570 1
	SvFLAGS(TOPs) &= ~(SVp_NOK|SVp_POK);
d580 1
a580 3
    djSP; dTARGET;
    if (SvREADONLY(TOPs) || SvTYPE(TOPs) > SVt_PVLV)
	croak(no_modify);
d582 1
a582 3
    if (SvIOK(TOPs) && !SvNOK(TOPs) && !SvPOK(TOPs) &&
    	SvIVX(TOPs) != IV_MAX)
    {
d584 1
a584 1
	SvFLAGS(TOPs) &= ~(SVp_NOK|SVp_POK);
d597 1
a597 3
    djSP; dTARGET;
    if(SvREADONLY(TOPs) || SvTYPE(TOPs) > SVt_PVLV)
	croak(no_modify);
d599 1
a599 3
    if (SvIOK(TOPs) && !SvNOK(TOPs) && !SvPOK(TOPs) &&
    	SvIVX(TOPs) != IV_MIN)
    {
d601 1
a601 1
	SvFLAGS(TOPs) &= ~(SVp_NOK|SVp_POK);
d614 1
a614 1
    djSP; dATARGET; tryAMAGICbin(pow,opASSIGN);
d624 1
a624 1
    djSP; dATARGET; tryAMAGICbin(mult,opASSIGN);
d634 1
a634 1
    djSP; dATARGET; tryAMAGICbin(div,opASSIGN);
d636 2
a637 3
      dPOPPOPnnrl;
      double value;
      if (right == 0.0)
d642 6
a647 4
	IV k;
	if ((double)I_V(left)  == left &&
	    (double)I_V(right) == right &&
	    (k = I_V(left)/I_V(right))*I_V(right) == I_V(left)) {
d650 1
a650 1
	    value = left / right;
d654 1
a654 1
      value = left / right;
d663 1
a663 1
    djSP; dATARGET; tryAMAGICbin(modulo,opASSIGN);
d665 3
a667 14
      UV left;
      UV right;
      bool left_neg;
      bool right_neg;
      UV ans;

      if (SvIOK(TOPs) && !SvNOK(TOPs) && !SvPOK(TOPs)) {
	IV i = SvIVX(POPs);
	right = (right_neg = (i < 0)) ? -i : i;
      }
      else {
	double n = POPn;
	right = U_V((right_neg = (n < 0)) ? -n : n);
      }
d669 6
a674 4
      if (SvIOK(TOPs) && !SvNOK(TOPs) && !SvPOK(TOPs)) {
	IV i = SvIVX(POPs);
	left = (left_neg = (i < 0)) ? -i : i;
      }
d676 2
a677 2
	double n = POPn;
	left = U_V((left_neg = (n < 0)) ? -n : n);
d679 1
a679 18

      if (!right)
	DIE("Illegal modulus zero");

      ans = left % right;
      if ((left_neg != right_neg) && ans)
	ans = right - ans;
      if (right_neg) {
	/* XXX may warn: unary minus operator applied to unsigned type */
	/* could change -foo to be (~foo)+1 instead	*/
	if (ans <= ~((UV)IV_MAX)+1)
	  sv_setiv(TARG, ~ans+1);
	else
	  sv_setnv(TARG, -(double)ans);
      }
      else
	sv_setuv(TARG, ans);
      PUSHTARG;
d686 1
a686 1
  djSP; dATARGET; tryAMAGICbin(repeat,opASSIGN);
d689 1
a689 1
    if (GIMME == G_ARRAY && PL_op->op_private & OPpREPEAT_DOLIST) {
d716 1
a716 1
	    if (SvREADONLY(tmpstr) && PL_curcop != &PL_compiling)
d723 3
a725 5
	if (count != 1) {
	    if (count < 1)
		SvCUR_set(TARG, 0);
	    else {
		SvGROW(TARG, (count * len) + 1);
d727 1
a727 2
		SvCUR(TARG) *= count;
	    }
d729 1
d731 2
a732 1
	(void)SvPOK_only(TARG);
d741 1
a741 1
    djSP; dATARGET; tryAMAGICbin(subtr,opASSIGN);
d743 1
a743 1
      dPOPTOPnnrl_ul;
d751 1
a751 1
    djSP; dATARGET; tryAMAGICbin(lshift,opASSIGN);
d753 3
a755 12
      IBW shift = POPi;
      if (PL_op->op_private & HINT_INTEGER) {
	IBW i = TOPi;
	i = BWi(i) << shift;
	SETi(BWi(i));
      }
      else {
	UBW u = TOPu;
	u <<= shift;
	SETu(BWu(u));
      }
      RETURN;
d761 1
a761 1
    djSP; dATARGET; tryAMAGICbin(rshift,opASSIGN);
d763 2
a764 11
      IBW shift = POPi;
      if (PL_op->op_private & HINT_INTEGER) {
	IBW i = TOPi;
	i = BWi(i) >> shift;
	SETi(BWi(i));
      }
      else {
	UBW u = TOPu;
	u >>= shift;
	SETu(BWu(u));
      }
d771 1
a771 1
    djSP; tryAMAGICbinSET(lt,0);
d774 1
a774 1
      SETs(boolSV(TOPn < value));
d781 1
a781 1
    djSP; tryAMAGICbinSET(gt,0);
d784 1
a784 1
      SETs(boolSV(TOPn > value));
d791 1
a791 1
    djSP; tryAMAGICbinSET(le,0);
d794 1
a794 1
      SETs(boolSV(TOPn <= value));
d801 1
a801 1
    djSP; tryAMAGICbinSET(ge,0);
d804 1
a804 1
      SETs(boolSV(TOPn >= value));
d811 1
a811 1
    djSP; tryAMAGICbinSET(ne,0);
d814 1
a814 1
      SETs(boolSV(TOPn != value));
d821 1
a821 1
    djSP; dTARGET; tryAMAGICbin(ncmp,0);
d826 2
a827 2
      if (left == right)
	value = 0;
d830 2
a831 6
      else if (left > right)
	value = 1;
      else {
	SETs(&PL_sv_undef);
	RETURN;
      }
d839 1
a839 1
    djSP; tryAMAGICbinSET(slt,0);
d842 1
a842 4
      int cmp = ((PL_op->op_private & OPpLOCALE)
		 ? sv_cmp_locale(left, right)
		 : sv_cmp(left, right));
      SETs(boolSV(cmp < 0));
d849 1
a849 1
    djSP; tryAMAGICbinSET(sgt,0);
d852 1
a852 4
      int cmp = ((PL_op->op_private & OPpLOCALE)
		 ? sv_cmp_locale(left, right)
		 : sv_cmp(left, right));
      SETs(boolSV(cmp > 0));
d859 1
a859 1
    djSP; tryAMAGICbinSET(sle,0);
d862 1
a862 4
      int cmp = ((PL_op->op_private & OPpLOCALE)
		 ? sv_cmp_locale(left, right)
		 : sv_cmp(left, right));
      SETs(boolSV(cmp <= 0));
d869 1
a869 14
    djSP; tryAMAGICbinSET(sge,0);
    {
      dPOPTOPssrl;
      int cmp = ((PL_op->op_private & OPpLOCALE)
		 ? sv_cmp_locale(left, right)
		 : sv_cmp(left, right));
      SETs(boolSV(cmp >= 0));
      RETURN;
    }
}

PP(pp_seq)
{
    djSP; tryAMAGICbinSET(seq,0);
d872 1
a872 1
      SETs(boolSV(sv_eq(left, right)));
d879 1
a879 1
    djSP; tryAMAGICbinSET(sne,0);
d882 1
a882 1
      SETs(boolSV(!sv_eq(left, right)));
d889 1
a889 1
    djSP; dTARGET;  tryAMAGICbin(scmp,0);
d892 1
a892 4
      int cmp = ((PL_op->op_private & OPpLOCALE)
		 ? sv_cmp_locale(left, right)
		 : sv_cmp(left, right));
      SETi( cmp );
d897 2
a898 3
PP(pp_bit_and)
{
    djSP; dATARGET; tryAMAGICbin(band,opASSIGN);
d902 3
a904 8
	if (PL_op->op_private & HINT_INTEGER) {
	  IBW value = SvIV(left) & SvIV(right);
	  SETi(BWi(value));
	}
	else {
	  UBW value = SvUV(left) & SvUV(right);
	  SETu(BWu(value));
	}
d907 1
a907 1
	do_vop(PL_op->op_type, TARG, left, right);
d916 1
a916 1
    djSP; dATARGET; tryAMAGICbin(bxor,opASSIGN);
d920 3
a922 8
	if (PL_op->op_private & HINT_INTEGER) {
	  IBW value = (USE_LEFT(left) ? SvIV(left) : 0) ^ SvIV(right);
	  SETi(BWi(value));
	}
	else {
	  UBW value = (USE_LEFT(left) ? SvUV(left) : 0) ^ SvUV(right);
	  SETu(BWu(value));
	}
d925 1
a925 1
	do_vop(PL_op->op_type, TARG, left, right);
d934 1
a934 1
    djSP; dATARGET; tryAMAGICbin(bor,opASSIGN);
d938 3
a940 8
	if (PL_op->op_private & HINT_INTEGER) {
	  IBW value = (USE_LEFT(left) ? SvIV(left) : 0) | SvIV(right);
	  SETi(BWi(value));
	}
	else {
	  UBW value = (USE_LEFT(left) ? SvUV(left) : 0) | SvUV(right);
	  SETu(BWu(value));
	}
d943 1
a943 1
	do_vop(PL_op->op_type, TARG, left, right);
d952 1
a952 1
    djSP; dTARGET; tryAMAGICun(neg);
d957 1
a957 3
	if (SvIOKp(sv) && !SvNOKp(sv) && !SvPOKp(sv) && SvIVX(sv) != IV_MIN)
	    SETi(-SvIVX(sv));
	else if (SvNIOKp(sv))
d962 1
a962 1
	    if (isIDFIRST(*s)) {
d983 1
a983 1
    djSP; tryAMAGICunSET(not);
d985 1
a985 1
    *PL_stack_sp = boolSV(!SvTRUE(*PL_stack_sp));
d991 1
a991 1
    djSP; dTARGET; tryAMAGICun(compl);
d994 2
d997 5
a1001 8
	if (PL_op->op_private & HINT_INTEGER) {
	  IBW value = ~SvIV(sv);
	  SETi(BWi(value));
	}
	else {
	  UBW value = ~SvUV(sv);
	  SETu(BWu(value));
	}
a1005 1
	register I32 anum;
d1032 1
a1032 1
    djSP; dATARGET; tryAMAGICbin(mult,opASSIGN);
d1042 1
a1042 1
    djSP; dATARGET; tryAMAGICbin(div,opASSIGN);
d1055 1
a1055 1
    djSP; dATARGET; tryAMAGICbin(modulo,opASSIGN); 
a1057 2
      if (!right)
	DIE("Illegal modulus zero");
d1065 1
a1065 1
    djSP; dATARGET; tryAMAGICbin(add,opASSIGN);
d1075 1
a1075 1
    djSP; dATARGET; tryAMAGICbin(subtr,opASSIGN);
d1085 1
a1085 1
    djSP; tryAMAGICbinSET(lt,0);
d1088 1
a1088 1
      SETs(boolSV(left < right));
d1095 1
a1095 1
    djSP; tryAMAGICbinSET(gt,0);
d1098 1
a1098 1
      SETs(boolSV(left > right));
d1105 1
a1105 1
    djSP; tryAMAGICbinSET(le,0);
d1108 1
a1108 1
      SETs(boolSV(left <= right));
d1115 1
a1115 1
    djSP; tryAMAGICbinSET(ge,0);
d1118 1
a1118 1
      SETs(boolSV(left >= right));
d1125 1
a1125 1
    djSP; tryAMAGICbinSET(eq,0);
d1128 1
a1128 1
      SETs(boolSV(left == right));
d1135 1
a1135 1
    djSP; tryAMAGICbinSET(ne,0);
d1138 1
a1138 1
      SETs(boolSV(left != right));
d1145 1
a1145 1
    djSP; dTARGET; tryAMAGICbin(ncmp,0);
d1163 1
a1163 1
    djSP; dTARGET; tryAMAGICun(neg);
d1172 1
a1172 1
    djSP; dTARGET; tryAMAGICbin(atan2,0);
d1182 1
a1182 1
    djSP; dTARGET; tryAMAGICun(sin);
d1194 1
a1194 1
    djSP; dTARGET; tryAMAGICun(cos);
a1203 13
/* Support Configure command-line overrides for rand() functions.
   After 5.005, perhaps we should replace this by Configure support
   for drand48(), random(), or rand().  For 5.005, though, maintain
   compatibility by calling rand() but allow the user to override it.
   See INSTALL for details.  --Andy Dougherty  15 July 1998
*/
#ifndef my_rand
#  define my_rand	rand
#endif
#ifndef my_srand
#  define my_srand	srand
#endif

d1206 1
a1206 1
    djSP; dTARGET;
a1213 4
    if (!srand_called) {
	(void)my_srand((unsigned)seed());
	srand_called = TRUE;
    }
d1215 1
a1215 1
    value = my_rand() * value / 2147483648.0;
d1218 1
a1218 1
    value = my_rand() * value / 65536.0;
d1221 1
a1221 1
    value = my_rand() * value / 32768.0;
d1223 1
a1223 1
    value = my_rand() * value / (double)(((unsigned long)1) << RANDBITS);
d1233 8
a1240 4
    djSP;
    UV anum;
    if (MAXARG < 1)
	anum = seed();
d1242 2
a1243 3
	anum = POPu;
    (void)my_srand((unsigned)anum);
    srand_called = TRUE;
a1247 82
STATIC U32
seed(void)
{
    /*
     * This is really just a quick hack which grabs various garbage
     * values.  It really should be a real hash algorithm which
     * spreads the effect of every input bit onto every output bit,
     * if someone who knows about such tings would bother to write it.
     * Might be a good idea to add that function to CORE as well.
     * No numbers below come from careful analysis or anyting here,
     * except they are primes and SEED_C1 > 1E6 to get a full-width
     * value from (tv_sec * SEED_C1 + tv_usec).  The multipliers should
     * probably be bigger too.
     */
#if RANDBITS > 16
#  define SEED_C1	1000003
#define   SEED_C4	73819
#else
#  define SEED_C1	25747
#define   SEED_C4	20639
#endif
#define   SEED_C2	3
#define   SEED_C3	269
#define   SEED_C5	26107

    dTHR;
#ifndef PERL_NO_DEV_RANDOM
    int fd;
#endif
    U32 u;
#ifdef VMS
#  include <starlet.h>
    /* when[] = (low 32 bits, high 32 bits) of time since epoch
     * in 100-ns units, typically incremented ever 10 ms.        */
    unsigned int when[2];
#else
#  ifdef HAS_GETTIMEOFDAY
    struct timeval when;
#  else
    Time_t when;
#  endif
#endif

/* This test is an escape hatch, this symbol isn't set by Configure. */
#ifndef PERL_NO_DEV_RANDOM
#ifndef PERL_RANDOM_DEVICE
   /* /dev/random isn't used by default because reads from it will block
    * if there isn't enough entropy available.  You can compile with
    * PERL_RANDOM_DEVICE to it if you'd prefer Perl to block until there
    * is enough real entropy to fill the seed. */
#  define PERL_RANDOM_DEVICE "/dev/urandom"
#endif
    fd = PerlLIO_open(PERL_RANDOM_DEVICE, 0);
    if (fd != -1) {
    	if (PerlLIO_read(fd, &u, sizeof u) != sizeof u)
	    u = 0;
	PerlLIO_close(fd);
	if (u)
	    return u;
    }
#endif

#ifdef VMS
    _ckvmssts(sys$gettim(when));
    u = (U32)SEED_C1 * when[0] + (U32)SEED_C2 * when[1];
#else
#  ifdef HAS_GETTIMEOFDAY
    gettimeofday(&when,(struct timezone *) 0);
    u = (U32)SEED_C1 * when.tv_sec + (U32)SEED_C2 * when.tv_usec;
#  else
    (void)time(&when);
    u = (U32)SEED_C1 * when;
#  endif
#endif
    u += SEED_C3 * (U32)getpid();
    u += SEED_C4 * (U32)(UV)PL_stack_sp;
#ifndef PLAN9           /* XXX Plan9 assembler chokes on this; fix needed  */
    u += SEED_C5 * (U32)(UV)&when;
#endif
    return u;
}

d1250 1
a1250 1
    djSP; dTARGET; tryAMAGICun(exp);
d1262 1
a1262 1
    djSP; dTARGET; tryAMAGICun(log);
d1266 1
a1266 2
      if (value <= 0.0) {
	SET_NUMERIC_STANDARD();
a1267 1
      }
d1276 1
a1276 1
    djSP; dTARGET; tryAMAGICun(sqrt);
d1280 1
a1280 2
      if (value < 0.0) {
	SET_NUMERIC_STANDARD();
a1281 1
      }
d1290 8
a1297 22
    djSP; dTARGET;
    {
      double value = TOPn;
      IV iv;

      if (SvIOKp(TOPs) && !SvNOKp(TOPs) && !SvPOKp(TOPs)) {
	iv = SvIVX(TOPs);
	SETi(iv);
      }
      else {
	if (value >= 0.0)
	  (void)modf(value, &value);
	else {
	  (void)modf(-value, &value);
	  value = -value;
	}
	iv = I_V(value);
	if (iv == value)
	  SETi(iv);
	else
	  SETn(value);
      }
d1299 1
d1305 1
a1305 1
    djSP; dTARGET; tryAMAGICun(abs);
d1307 2
a1308 2
      double value = TOPn;
      IV iv;
d1310 5
a1314 11
      if (SvIOKp(TOPs) && !SvNOKp(TOPs) && !SvPOKp(TOPs) &&
	  (iv = SvIVX(TOPs)) != IV_MIN) {
	if (iv < 0)
	  iv = -iv;
	SETi(iv);
      }
      else {
	if (value < 0.0)
	    value = -value;
	SETn(value);
      }
a1315 1
    RETURN;
d1320 1
a1320 1
    djSP; dTARGET;
d1322 1
a1323 1
    STRLEN n_a;
d1325 6
a1330 2
    tmps = POPpx;
    XPUSHu(scan_hex(tmps, 99, &argtype));
d1336 2
a1337 2
    djSP; dTARGET;
    UV value;
a1339 1
    STRLEN n_a;
d1341 1
a1341 1
    tmps = POPpx;
d1350 4
a1353 1
    XPUSHu(value);
d1361 1
a1361 1
    djSP; dTARGET;
d1368 1
a1368 1
    djSP; dTARGET;
d1374 1
a1374 2
    I32 fail;
    I32 lvalue = PL_op->op_flags & OPf_MOD;
d1376 3
a1378 10
    I32 arybase = PL_curcop->cop_arybase;
    char *repl = 0;
    STRLEN repl_len;

    SvTAINTED_off(TARG);			/* decontaminate */
    if (MAXARG > 2) {
	if (MAXARG > 3) {
	    sv = POPs;
	    repl = SvPV(sv, repl_len);
	}
d1380 1
a1380 2
    }
    pos = POPi;
a1381 1
    PUTBACK;
d1383 6
a1388 13
    if (pos >= arybase) {
	pos -= arybase;
	rem = curlen-pos;
	fail = rem;
	if (MAXARG > 2) {
	    if (len < 0) {
		rem += len;
		if (rem < 0)
		    rem = 0;
	    }
	    else if (rem > len)
		     rem = len;
	}
a1390 1
	pos += curlen;
d1392 5
a1396 5
	    rem = curlen;
	else if (len >= 0) {
	    rem = pos+len;
	    if (rem > (I32)curlen)
		rem = curlen;
a1397 16
	else {
	    rem = curlen+len;
	    if (rem < pos)
		rem = pos;
	}
	if (pos < 0)
	    pos = 0;
	fail = rem;
	rem -= pos;
    }
    if (fail < 0) {
	if (PL_dowarn || lvalue || repl)
	    warn("substr outside of string");
	RETPUSHUNDEF;
    }
    else {
d1399 3
d1404 2
a1405 13
	    if (!SvGMAGICAL(sv)) {
		if (SvROK(sv)) {
		    STRLEN n_a;
		    SvPV_force(sv,n_a);
		    if (PL_dowarn)
			warn("Attempt to use reference as lvalue in substr");
		}
		if (SvOK(sv))		/* is it defined ? */
		    (void)SvPOK_only(sv);
		else
		    sv_setpvn(sv,"",0);	/* avoid lexical reincarnation */
	    }

d1411 2
a1412 6
	    LvTYPE(TARG) = 'x';
	    if (LvTARG(TARG) != sv) {
		if (LvTARG(TARG))
		    SvREFCNT_dec(LvTARG(TARG));
		LvTARG(TARG) = SvREFCNT_inc(sv);
	    }
d1414 1
a1414 1
	    LvTARGLEN(TARG) = rem;
a1415 2
	else if (repl)
	    sv_insert(sv, pos, rem, repl, repl_len);
a1416 1
    SPAGAIN;
d1423 1
a1423 1
    djSP; dTARGET;
d1427 1
a1427 1
    I32 lvalue = PL_op->op_flags & OPf_MOD;
a1432 1
    SvTAINTED_off(TARG);			/* decontaminate */
d1445 3
a1447 7
	    if (LvTARG(TARG) != src) {
		if (LvTARG(TARG))
		    SvREFCNT_dec(LvTARG(TARG));
		LvTARG(TARG) = SvREFCNT_inc(src);
	    }
	    LvTARGOFF(TARG) = offset;
	    LvTARGLEN(TARG) = size;
d1490 1
a1490 1
    sv_setuv(TARG, (UV)retnum);
d1497 1
a1497 1
    djSP; dTARGET;
d1505 1
a1505 1
    I32 arybase = PL_curcop->cop_arybase;
d1519 1
a1519 1
      (unsigned char*)tmps + biglen, little, 0)))
d1529 1
a1529 1
    djSP; dTARGET;
d1539 1
a1539 1
    I32 arybase = PL_curcop->cop_arybase;
d1566 1
a1566 7
    djSP; dMARK; dORIGMARK; dTARGET;
#ifdef USE_LOCALE_NUMERIC
    if (PL_op->op_private & OPpLOCALE)
	SET_NUMERIC_LOCAL();
    else
	SET_NUMERIC_STANDARD();
#endif
a1567 1
    TAINT_IF(SvTAINTED(TARG));
d1575 1
a1575 1
    djSP; dTARGET;
a1577 1
    STRLEN n_a;
d1580 1
a1580 1
    tmps = POPpx;
d1584 1
a1584 1
    tmps = POPpx;
d1594 1
a1594 1
    djSP; dTARGET;
d1610 1
a1610 2
    djSP; dTARGET; dPOPTOPssrl;
    STRLEN n_a;
d1612 1
a1612 1
    char *tmps = SvPV(left, n_a);
d1614 1
a1614 1
    sv_setpv(TARG, fcrypt(tmps, SvPV(right, n_a)));
d1616 1
a1616 1
    sv_setpv(TARG, PerlProc_crypt(tmps, SvPV(right, n_a)));
d1628 1
a1628 1
    djSP;
a1630 1
    STRLEN n_a;
d1638 3
a1640 10
    s = SvPV_force(sv, n_a);
    if (*s) {
	if (PL_op->op_private & OPpLOCALE) {
	    TAINT;
	    SvTAINTED_on(sv);
	    *s = toUPPER_LC(*s);
	}
	else
	    *s = toUPPER(*s);
    }
d1647 1
a1647 1
    djSP;
a1649 1
    STRLEN n_a;
d1657 3
a1659 10
    s = SvPV_force(sv, n_a);
    if (*s) {
	if (PL_op->op_private & OPpLOCALE) {
	    TAINT;
	    SvTAINTED_on(sv);
	    *s = toLOWER_LC(*s);
	}
	else
	    *s = toLOWER(*s);
    }
d1667 1
a1667 1
    djSP;
d1670 1
a1678 1

d1680 5
a1684 13
    if (len) {
	register char *send = s + len;

	if (PL_op->op_private & OPpLOCALE) {
	    TAINT;
	    SvTAINTED_on(sv);
	    for (; s < send; s++)
		*s = toUPPER_LC(*s);
	}
	else {
	    for (; s < send; s++)
		*s = toUPPER(*s);
	}
d1691 1
a1691 1
    djSP;
d1694 1
a1702 1

d1704 5
a1708 13
    if (len) {
	register char *send = s + len;

	if (PL_op->op_private & OPpLOCALE) {
	    TAINT;
	    SvTAINTED_on(sv);
	    for (; s < send; s++)
		*s = toLOWER_LC(*s);
	}
	else {
	    for (; s < send; s++)
		*s = toLOWER(*s);
	}
d1715 1
a1715 1
    djSP; dTARGET;
d1744 1
a1744 1
    djSP; dMARK; dORIGMARK;
d1747 2
a1748 2
    register I32 lval = PL_op->op_flags & OPf_MOD;
    I32 arybase = PL_curcop->cop_arybase;
d1752 1
a1752 1
	if (lval && PL_op->op_private & OPpLVAL_INTRO) {
d1754 1
a1754 1
	    for (svp = MARK + 1; svp <= SP; svp++) {
d1769 1
a1769 1
		if (!svp || *svp == &PL_sv_undef)
d1771 2
a1772 2
		if (PL_op->op_private & OPpLVAL_INTRO)
		    save_aelem(av, elem, svp);
d1774 1
a1774 1
	    *MARK = svp ? *svp : &PL_sv_undef;
d1789 1
a1789 1
    djSP; dTARGET;
d1792 3
a1794 3
    I32 gimme = GIMME_V;
    I32 realhv = (SvTYPE(hash) == SVt_PVHV);

d1796 1
a1796 2
    /* might clobber stack_sp */
    entry = realhv ? hv_iternext(hash) : avhv_iternext((AV*)hash);
d1801 5
a1805 2
	PUSHs(hv_iterkeysv(entry));	/* won't clobber stack_sp */
	if (gimme == G_ARRAY) {
d1807 1
a1807 3
	    /* might clobber stack_sp */
	    sv_setsv(TARG, realhv ?
		     hv_iterval(hash, entry) : avhv_iterval((AV*)hash, entry));
d1812 1
a1812 1
    else if (gimme == G_SCALAR)
d1830 1
a1830 3
    djSP;
    I32 gimme = GIMME_V;
    I32 discard = (gimme == G_VOID) ? G_DISCARD : 0;
d1832 6
a1837 33
    HV *hv;

    if (PL_op->op_private & OPpSLICE) {
	dMARK; dORIGMARK;
	U32 hvtype;
	hv = (HV*)POPs;
	hvtype = SvTYPE(hv);
	while (++MARK <= SP) {
	    if (hvtype == SVt_PVHV)
		sv = hv_delete_ent(hv, *MARK, discard, 0);
	    else
		DIE("Not a HASH reference");
	    *MARK = sv ? sv : &PL_sv_undef;
	}
	if (discard)
	    SP = ORIGMARK;
	else if (gimme == G_SCALAR) {
	    MARK = ORIGMARK;
	    *++MARK = *SP;
	    SP = MARK;
	}
    }
    else {
	SV *keysv = POPs;
	hv = (HV*)POPs;
	if (SvTYPE(hv) == SVt_PVHV)
	    sv = hv_delete_ent(hv, keysv, discard, 0);
	else
	    DIE("Not a HASH reference");
	if (!sv)
	    sv = &PL_sv_undef;
	if (!discard)
	    PUSHs(sv);
d1839 6
d1850 1
a1850 1
    djSP;
d1853 3
a1855 7
    if (SvTYPE(hv) == SVt_PVHV) {
	if (hv_exists_ent(hv, tmpsv, 0))
	    RETPUSHYES;
    } else if (SvTYPE(hv) == SVt_PVAV) {
	if (avhv_exists_ent((AV*)hv, tmpsv, 0))
	    RETPUSHYES;
    } else {
d1858 3
d1866 2
a1867 1
    djSP; dMARK; dORIGMARK;
d1869 1
a1869 2
    register I32 lval = PL_op->op_flags & OPf_MOD;
    I32 realhv = (SvTYPE(hv) == SVt_PVHV);
d1871 4
a1874 2
    if (!realhv && PL_op->op_private & OPpLVAL_INTRO)
	DIE("Can't localize pseudo-hash element");
d1876 1
a1876 10
    if (realhv || SvTYPE(hv) == SVt_PVAV) {
	while (++MARK <= SP) {
	    SV *keysv = *MARK;
	    SV **svp;
	    if (realhv) {
		HE *he = hv_fetch_ent(hv, keysv, lval, 0);
		svp = he ? &HeVAL(he) : 0;
	    } else {
		svp = avhv_fetch_ent((AV*)hv, keysv, lval, 0);
	    }
d1878 4
a1881 6
		if (!svp || *svp == &PL_sv_undef) {
		    STRLEN n_a;
		    DIE(no_helem, SvPV(keysv, n_a));
		}
		if (PL_op->op_private & OPpLVAL_INTRO)
		    save_helem(hv, keysv, svp);
d1883 1
a1883 1
	    *MARK = svp ? *svp : &PL_sv_undef;
d1898 1
a1898 1
    djSP; dMARK;
d1903 1
a1903 1
	    *MARK = &PL_sv_undef;
d1911 4
a1914 4
    djSP;
    SV **lastrelem = PL_stack_sp;
    SV **lastlelem = PL_stack_base + POPMARK;
    SV **firstlelem = PL_stack_base + POPMARK + 1;
d1916 2
a1917 2
    I32 arybase = PL_curcop->cop_arybase;
    I32 lval = PL_op->op_flags & OPf_MOD;
d1931 1
a1931 1
	    *firstlelem = &PL_sv_undef;
d1948 1
a1948 1
		*lelem = &PL_sv_undef;
d1950 1
a1950 1
		*lelem = &PL_sv_undef;
d1955 1
a1955 1
		*lelem = &PL_sv_undef;
d1957 1
a1957 1
	if (!is_something_there && (SvOK(*lelem) || SvGMAGICAL(*lelem)))
d1969 1
a1969 1
    djSP; dMARK; dORIGMARK;
d1971 2
a1972 3
    SV *av = sv_2mortal((SV*)av_make(items, MARK+1));
    SP = ORIGMARK;		/* av_make() might realloc stack_sp */
    XPUSHs(av);
d1978 2
a1979 1
    djSP; dMARK; dORIGMARK;
d1984 1
d1988 4
a1991 3
	else if (PL_dowarn)
	    warn("Odd number of elements in hash assignment");
	(void)hv_store_ent(hv,key,val,0);
d2000 1
a2000 1
    djSP; dMARK; dORIGMARK;
a2010 12
    MAGIC *mg;

    if (mg = SvTIED_mg((SV*)ary, 'P')) {
	*MARK-- = SvTIED_obj((SV*)ary, mg);
	PUSHMARK(MARK);
	PUTBACK;
	ENTER;
	perl_call_method("SPLICE",GIMME_V);
	LEAVE;
	SPAGAIN;
	RETURN;
    }
d2015 1
a2015 1
	offset = i = SvIVx(*MARK);
d2017 1
a2017 1
	    offset += AvFILLp(ary) + 1;
d2019 1
a2019 3
	    offset -= PL_curcop->cop_arybase;
	if (offset < 0)
	    DIE(no_aelem, i);
d2022 2
a2023 5
	    if (length < 0) {
		length += AvFILLp(ary) - offset + 1;
		if (length < 0)
		    length = 0;
	    }
d2032 9
a2040 3
    if (offset > AvFILLp(ary) + 1)
	offset = AvFILLp(ary) + 1;
    after = AvFILLp(ary) + 1 - (offset + length);
a2051 6
    if (newlen && !AvREAL(ary)) {
	if (AvREIFY(ary))
	    av_reify(ary);
	else
	    assert(AvREAL(ary));		/* would leak, so croak */
    }
d2064 2
a2065 5
		EXTEND_MORTAL(length);
		for (i = length, dst = MARK; i; i--) {
		    sv_2mortal(*dst);	/* free them eventualy */
		    dst++;
		}
d2077 1
a2077 1
	AvFILLp(ary) += diff;
d2098 1
a2098 1
	    dst = &AvARRAY(ary)[AvFILLp(ary)+1];
d2103 1
a2103 1
	    dst[--i] = &PL_sv_undef;
d2132 1
a2132 1
		AvFILLp(ary) += diff;
d2135 3
a2137 3
		if (AvFILLp(ary) + diff >= AvMAX(ary))	/* oh, well */
		    av_extend(ary, AvFILLp(ary) + diff);
		AvFILLp(ary) += diff;
d2140 1
a2140 1
		    dst = AvARRAY(ary) + AvFILLp(ary);
d2158 2
a2159 5
		    EXTEND_MORTAL(length);
		    for (i = length, dst = MARK; i; i--) {
			sv_2mortal(*dst);	/* free them eventualy */
			dst++;
		    }
d2175 1
a2175 1
	    *MARK = &PL_sv_undef;
d2183 1
a2183 1
    djSP; dMARK; dORIGMARK; dTARGET;
d2185 1
a2185 2
    register SV *sv = &PL_sv_undef;
    MAGIC *mg;
d2187 5
a2191 17
    if (mg = SvTIED_mg((SV*)ary, 'P')) {
	*MARK-- = SvTIED_obj((SV*)ary, mg);
	PUSHMARK(MARK);
	PUTBACK;
	ENTER;
	perl_call_method("PUSH",G_SCALAR|G_DISCARD);
	LEAVE;
	SPAGAIN;
    }
    else {
	/* Why no pre-extend of ary here ? */
	for (++MARK; MARK <= SP; MARK++) {
	    sv = NEWSV(51, 0);
	    if (*MARK)
		sv_setsv(sv, *MARK);
	    av_push(ary, sv);
	}
d2200 1
a2200 1
    djSP;
d2203 1
a2203 1
    if (AvREAL(av))
d2211 1
a2211 1
    djSP;
d2217 1
a2217 1
    if (AvREAL(av))
d2225 1
a2225 1
    djSP; dMARK; dORIGMARK; dTARGET;
a2228 1
    MAGIC *mg;
d2230 5
a2234 16
    if (mg = SvTIED_mg((SV*)ary, 'P')) {
	*MARK-- = SvTIED_obj((SV*)ary, mg);
	PUSHMARK(MARK);
	PUTBACK;
	ENTER;
	perl_call_method("UNSHIFT",G_SCALAR|G_DISCARD);
	LEAVE;
	SPAGAIN;
    }
    else {
	av_unshift(ary, SP - MARK);
	while (MARK < SP) {
	    sv = NEWSV(27, 0);
	    sv_setsv(sv, *++MARK);
	    (void)av_store(ary, i++, sv);
	}
d2236 1
d2244 1
a2244 1
    djSP; dMARK;
d2265 1
a2265 1
	    do_join(TARG, &PL_sv_no, MARK, SP);
d2267 1
a2267 1
	    sv_setsv(TARG, (SP > MARK) ? *SP : DEFSV);
a2283 27
STATIC SV      *
mul128(SV *sv, U8 m)
{
  STRLEN          len;
  char           *s = SvPV(sv, len);
  char           *t;
  U32             i = 0;

  if (!strnEQ(s, "0000", 4)) {  /* need to grow sv */
    SV             *tmpNew = newSVpv("0000000000", 10);

    sv_catsv(tmpNew, sv);
    SvREFCNT_dec(sv);		/* free old sv */
    sv = tmpNew;
    s = SvPV(sv, len);
  }
  t = s + len - 1;
  while (!*t)                   /* trailing '\0'? */
    t--;
  while (t > s) {
    i = ((*t - '0') << 7) + m;
    *(t--) = '0' + (i % 10);
    m = i / 10;
  }
  return (sv);
}

a2285 16
static const char uuemap[] =
    "`!\"#$%&'()*+,-./0123456789:;<=>?@@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_";
#ifndef PERL_OBJECT
static char uudmap[256];        /* Initialised on first use */
#endif
#if 'I' == 73 && 'J' == 74
/* On an ASCII/ISO kind of system */
#define ISUUCHAR(ch)    ((ch) >= ' ' && (ch) < 'a')
#else
/*
  Some other sort of character set - use memchr() so we don't match
  the null byte.
 */
#define ISUUCHAR(ch)    (memchr(uuemap, (ch), sizeof(uuemap)-1) || (ch) == ' ')
#endif

d2288 1
a2288 1
    djSP;
a2289 2
    SV **oldsp = SP;
    I32 gimme = GIMME_V;
a2320 1
#ifndef PERL_OBJECT
a2321 2
#endif
    int commas = 0;
d2323 1
a2323 1
    if (gimme != G_ARRAY) {		/* arrange to do first one only */
d2326 1
a2326 1
	if (strchr("aAZbBhHP", *patend) || *pat == '%') {
d2336 1
a2336 3
	datumtype = *pat++ & 0xFF;
	if (isSPACE(datumtype))
	    continue;
a2351 4
	    croak("Invalid type in unpack: '%c'", (int)datumtype);
	case ',': /* grandfather in commas but with a warning */
	    if (commas++ == 0 && PL_dowarn)
		warn("Invalid type in unpack: '%c'", (int)datumtype);
a2377 1
	case 'Z':
d2386 1
a2386 1
	    if (datumtype == 'A' || datumtype == 'Z') {
d2388 4
a2391 11
		if (datumtype == 'Z') {	/* 'Z' strips stuff after first null */
		    s = SvPVX(sv);
		    while (*s)
			s++;
		}
		else {		/* 'A' strips both nulls and spaces */
		    s = SvPVX(sv) + len - 1;
		    while (s >= SvPVX(sv) && (!*s || isSPACE(*s)))
			s--;
		    *++s = '\0';
		}
d2481 1
a2481 1
		    *pat++ = PL_hexdigit[bits & 15];
d2491 1
a2491 1
		    *pat++ = PL_hexdigit[(bits >> 4) & 15];
a2510 1
		EXTEND_MORTAL(len);
d2516 1
a2516 1
		    sv_setiv(sv, (IV)aint);
a2532 1
		EXTEND_MORTAL(len);
d2536 1
a2536 1
		    sv_setiv(sv, (IV)auint);
d2542 1
a2542 1
	    along = (strend - s) / SIZE16;
d2547 2
a2548 6
		    COPY16(s, &ashort);
#if SHORTSIZE > SIZE16
		    if (ashort > 32767)
			ashort -= 65536;
#endif
		    s += SIZE16;
a2553 1
		EXTEND_MORTAL(len);
d2555 2
a2556 6
		    COPY16(s, &ashort);
#if SHORTSIZE > SIZE16
		    if (ashort > 32767)
			ashort -= 65536;
#endif
		    s += SIZE16;
d2558 1
a2558 1
		    sv_setiv(sv, (IV)ashort);
d2566 1
a2566 1
	    along = (strend - s) / SIZE16;
d2571 2
a2572 2
		    COPY16(s, &aushort);
		    s += SIZE16;
d2575 1
a2575 1
			aushort = PerlSock_ntohs(aushort);
a2585 1
		EXTEND_MORTAL(len);
d2587 2
a2588 2
		    COPY16(s, &aushort);
		    s += SIZE16;
d2592 1
a2592 1
			aushort = PerlSock_ntohs(aushort);
d2598 1
a2598 1
		    sv_setiv(sv, (IV)aushort);
a2618 1
		EXTEND_MORTAL(len);
d2623 1
a2623 8
#ifdef __osf__
                    /* Without the dummy below unpack("i", pack("i",-1))
                     * return 0xFFffFFff instead of -1 for Digital Unix V4.0
                     * cc with optimization turned on */
                    (aint) ?
		    	sv_setiv(sv, (IV)aint) :
#endif
		    sv_setiv(sv, (IV)aint);
a2643 1
		EXTEND_MORTAL(len);
d2648 1
a2648 12
#ifdef __osf__
                    /* Without the dummy below unpack("I", pack("I",0xFFFFFFFF))
                     * returns 1.84467440737096e+19 instead of 0xFFFFFFFF for
		     * DEC C V5.8-009 on Digital UNIX V4.0 (Rev. 1091) (aka V4.0D)
		     * with optimization turned on.
		     * (DEC C V5.2-040 on Digital UNIX V4.0 (Rev. 564) (aka V4.0B)
		     * does not have this problem even with -O4)
		     */
                    (auint) ?
		        sv_setuv(sv, (UV)auint) :
#endif
		    sv_setuv(sv, (UV)auint);
d2654 1
a2654 1
	    along = (strend - s) / SIZE32;
d2659 2
a2660 6
		    COPY32(s, &along);
#if LONGSIZE > SIZE32
		    if (along > 2147483647)
			along -= 4294967296;
#endif
		    s += SIZE32;
a2668 1
		EXTEND_MORTAL(len);
d2670 2
a2671 6
		    COPY32(s, &along);
#if LONGSIZE > SIZE32
		    if (along > 2147483647)
			along -= 4294967296;
#endif
		    s += SIZE32;
d2673 1
a2673 1
		    sv_setiv(sv, (IV)along);
d2681 1
a2681 1
	    along = (strend - s) / SIZE32;
d2686 2
a2687 2
		    COPY32(s, &aulong);
		    s += SIZE32;
d2690 1
a2690 1
			aulong = PerlSock_ntohl(aulong);
a2703 1
		EXTEND_MORTAL(len);
d2705 3
a2707 2
		    COPY32(s, &aulong);
		    s += SIZE32;
d2710 1
a2710 1
			aulong = PerlSock_ntohl(aulong);
d2716 1
a2716 2
		    sv = NEWSV(43, 0);
		    sv_setuv(sv, (UV)aulong);
a2725 1
	    EXTEND_MORTAL(len);
a2738 42
	case 'w':
	    EXTEND(SP, len);
	    EXTEND_MORTAL(len);
	    {
		UV auv = 0;
		U32 bytes = 0;
		
		while ((len > 0) && (s < strend)) {
		    auv = (auv << 7) | (*s & 0x7f);
		    if (!(*s++ & 0x80)) {
			bytes = 0;
			sv = NEWSV(40, 0);
			sv_setuv(sv, auv);
			PUSHs(sv_2mortal(sv));
			len--;
			auv = 0;
		    }
		    else if (++bytes >= sizeof(UV)) {	/* promote to string */
			char *t;
			STRLEN n_a;

			sv = newSVpvf("%.*Vu", (int)TYPE_DIGITS(UV), auv);
			while (s < strend) {
			    sv = mul128(sv, *s & 0x7f);
			    if (!(*s++ & 0x80)) {
				bytes = 0;
				break;
			    }
			}
			t = SvPV(sv, n_a);
			while (*t == '0')
			    t++;
			sv_chop(sv, t);
			PUSHs(sv_2mortal(sv));
			len--;
			auv = 0;
		    }
		}
		if ((s >= strend) && bytes)
		    croak("Unterminated compressed integer");
	    }
	    break;
a2753 3
	    along = (strend - s) / sizeof(Quad_t);
	    if (len > along)
		len = along;
a2754 1
	    EXTEND_MORTAL(len);
d2763 1
a2763 4
		if (aquad >= IV_MIN && aquad <= IV_MAX)
		    sv_setiv(sv, (IV)aquad);
		else
		    sv_setnv(sv, (double)aquad);
a2767 3
	    along = (strend - s) / sizeof(Quad_t);
	    if (len > along)
		len = along;
a2768 1
	    EXTEND_MORTAL(len);
d2777 1
a2777 4
		if (auquad <= UV_MAX)
		    sv_setuv(sv, (UV)auquad);
		else
		    sv_setnv(sv, (double)auquad);
a2796 1
		EXTEND_MORTAL(len);
a2819 1
		EXTEND_MORTAL(len);
a2829 17
	    /* MKS:
	     * Initialise the decode mapping.  By using a table driven
             * algorithm, the code will be character-set independent
             * (and just as fast as doing character arithmetic)
             */
            if (uudmap['M'] == 0) {
                int i;
 
                for (i = 0; i < sizeof(uuemap); i += 1)
                    uudmap[uuemap[i]] = i;
                /*
                 * Because ' ' and '`' map to the same value,
                 * we need to decode them both the same.
                 */
                uudmap[' '] = 0;
            }

d2832 1
a2832 3
	    if (along)
		SvPOK_on(sv);
	    while (s < strend && *s > ' ' && ISUUCHAR(*s)) {
d2837 1
a2837 1
		len = uudmap[*s++] & 077;
d2839 14
a2852 14
		    if (s < strend && ISUUCHAR(*s))
			a = uudmap[*s++] & 077;
 		    else
 			a = 0;
		    if (s < strend && ISUUCHAR(*s))
			b = uudmap[*s++] & 077;
 		    else
 			b = 0;
		    if (s < strend && ISUUCHAR(*s))
			c = uudmap[*s++] & 077;
 		    else
 			c = 0;
		    if (s < strend && ISUUCHAR(*s))
			d = uudmap[*s++] & 077;
d2855 4
a2858 4
		    hunk[0] = (a << 2) | (b >> 4);
		    hunk[1] = (b << 4) | (c >> 2);
		    hunk[2] = (c << 6) | d;
		    sv_catpvn(sv, hunk, (len > 3) ? 3 : len);
d2894 2
a2895 2
		    aulong = (1 << checksum) - 1;
		    culong &= aulong;
d2897 1
a2897 1
		sv_setuv(sv, (UV)culong);
a2902 2
    if (SP == oldsp && gimme == G_SCALAR)
	PUSHs(&PL_sv_undef);
d2906 5
a2910 2
STATIC void
doencodes(register SV *sv, register char *s, register I32 len)
d2914 1
a2914 1
    *hunk = uuemap[len];
d2917 5
a2921 5
    while (len > 2) {
	hunk[0] = uuemap[(077 & (*s >> 2))];
	hunk[1] = uuemap[(077 & (((*s << 4) & 060) | ((s[1] >> 4) & 017)))];
	hunk[2] = uuemap[(077 & (((s[1] << 2) & 074) | ((s[2] >> 6) & 03)))];
	hunk[3] = uuemap[(077 & (s[2] & 077))];
d2926 3
a2928 7
    if (len > 0) {
	char r = (len > 1 ? s[1] : '\0');
	hunk[0] = uuemap[(077 & (*s >> 2))];
	hunk[1] = uuemap[(077 & (((*s << 4) & 060) | ((r >> 4) & 017)))];
	hunk[2] = uuemap[(077 & ((r << 2) & 074))];
	hunk[3] = uuemap[0];
	sv_catpvn(sv, hunk, 4);
a2932 78
STATIC SV      *
is_an_int(char *s, STRLEN l)
{
  STRLEN          n_a;
  SV             *result = newSVpv("", l);
  char           *result_c = SvPV(result, n_a);	/* convenience */
  char           *out = result_c;
  bool            skip = 1;
  bool            ignore = 0;

  while (*s) {
    switch (*s) {
    case ' ':
      break;
    case '+':
      if (!skip) {
	SvREFCNT_dec(result);
	return (NULL);
      }
      break;
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
      skip = 0;
      if (!ignore) {
	*(out++) = *s;
      }
      break;
    case '.':
      ignore = 1;
      break;
    default:
      SvREFCNT_dec(result);
      return (NULL);
    }
    s++;
  }
  *(out++) = '\0';
  SvCUR_set(result, out - result_c);
  return (result);
}

STATIC int
div128(SV *pnum, bool *done)
                          		    /* must be '\0' terminated */

{
  STRLEN          len;
  char           *s = SvPV(pnum, len);
  int             m = 0;
  int             r = 0;
  char           *t = s;

  *done = 1;
  while (*t) {
    int             i;

    i = m * 10 + (*t - '0');
    m = i & 0x7F;
    r = (i >> 7);		/* r < 10 */
    if (r) {
      *done = 0;
    }
    *(t++) = '0' + r;
  }
  *(t++) = '\0';
  SvCUR_set(pnum, (STRLEN) (t - s));
  return (m);
}


d2935 1
a2935 1
    djSP; dMARK; dORIGMARK; dTARGET;
a2961 1
    int commas = 0;
d2967 2
a2968 4
#define NEXTFROM (items-- > 0 ? *MARK++ : &PL_sv_no)
	datumtype = *pat++ & 0xFF;
	if (isSPACE(datumtype))
	    continue;
a2981 4
	    croak("Invalid type in pack: '%c'", (int)datumtype);
	case ',': /* grandfather in commas but with a warning */
	    if (commas++ == 0 && PL_dowarn)
		warn("Invalid type in pack: '%c'", (int)datumtype);
a3008 1
	case 'Z':
d3182 1
a3182 1
		ashort = PerlSock_htons(ashort);
d3184 1
a3184 1
		CAT16(cat, &ashort);
d3194 1
a3194 1
		CAT16(cat, &ashort);
d3202 1
a3202 1
		CAT16(cat, &ashort);
d3208 1
a3208 1
		auint = SvUV(fromstr);
a3211 70
	case 'w':
            while (len-- > 0) {
		fromstr = NEXTFROM;
		adouble = floor(SvNV(fromstr));

		if (adouble < 0)
		    croak("Cannot compress negative numbers");

		if (
#ifdef BW_BITS
		    adouble <= BW_MASK
#else
#ifdef CXUX_BROKEN_CONSTANT_CONVERT
		    adouble <= UV_MAX_cxux
#else
		    adouble <= UV_MAX
#endif
#endif
		    )
		{
		    char   buf[1 + sizeof(UV)];
		    char  *in = buf + sizeof(buf);
		    UV     auv = U_V(adouble);;

		    do {
			*--in = (auv & 0x7f) | 0x80;
			auv >>= 7;
		    } while (auv);
		    buf[sizeof(buf) - 1] &= 0x7f; /* clear continue bit */
		    sv_catpvn(cat, in, (buf + sizeof(buf)) - in);
		}
		else if (SvPOKp(fromstr)) {  /* decimal string arithmetics */
		    char           *from, *result, *in;
		    SV             *norm;
		    STRLEN          len;
		    bool            done;

		    /* Copy string and check for compliance */
		    from = SvPV(fromstr, len);
		    if ((norm = is_an_int(from, len)) == NULL)
			croak("can compress only unsigned integer");

		    New('w', result, len, char);
		    in = result + len;
		    done = FALSE;
		    while (!done)
			*--in = div128(norm, &done) | 0x80;
		    result[len - 1] &= 0x7F; /* clear continue bit */
		    sv_catpvn(cat, in, (result + len) - in);
		    Safefree(result);
		    SvREFCNT_dec(norm);	/* free norm */
                }
		else if (SvNOKp(fromstr)) {
		    char   buf[sizeof(double) * 2];	/* 8/7 <= 2 */
		    char  *in = buf + sizeof(buf);

		    do {
			double next = floor(adouble / 128);
			*--in = (unsigned char)(adouble - (next * 128)) | 0x80;
			if (--in < buf)  /* this cannot happen ;-) */
			    croak ("Cannot compress integer");
			adouble = next;
		    } while (adouble > 0);
		    buf[sizeof(buf) - 1] &= 0x7f; /* clear continue bit */
		    sv_catpvn(cat, in, (buf + sizeof(buf)) - in);
		}
		else
		    croak("Cannot compress non integer");
	    }
            break;
d3222 1
a3222 1
		aulong = SvUV(fromstr);
d3224 1
a3224 1
		aulong = PerlSock_htonl(aulong);
d3226 1
a3226 1
		CAT32(cat, &aulong);
d3232 1
a3232 1
		aulong = SvUV(fromstr);
d3236 1
a3236 1
		CAT32(cat, &aulong);
d3242 2
a3243 2
		aulong = SvUV(fromstr);
		CAT32(cat, &aulong);
d3250 1
a3250 1
		CAT32(cat, &along);
d3275 1
a3275 16
		if (fromstr == &PL_sv_undef)
		    aptr = NULL;
		else {
		    STRLEN n_a;
		    /* XXX better yet, could spirit away the string to
		     * a safe spot and hang on to it until the result
		     * of pack() (and all copies of the result) are
		     * gone.
		     */
		    if (PL_dowarn && (SvTEMP(fromstr) || SvPADTMP(fromstr)))
			warn("Attempt to pack pointer to temporary value");
		    if (SvPOK(fromstr) || SvNIOK(fromstr))
			aptr = SvPV(fromstr,n_a);
		    else
			aptr = SvPV_force(fromstr,n_a);
		}
a3307 1

d3310 1
a3310 1
    djSP; dTARG;
d3317 1
a3317 2
    register PMOP *pm;
    register REGEXP *rx;
d3327 4
a3330 5
    AV *oldstack = PL_curstack;
    I32 gimme = GIMME_V;
    I32 oldsave = PL_savestack_ix;
    I32 make_mortal = 1;
    MAGIC *mg = (MAGIC *) NULL;
a3331 5
#ifdef DEBUGGING
    Copy(&LvTARGOFF(POPs), &pm, 1, PMOP*);
#else
    pm = (PMOP*)POPs;
#endif
a3333 5
    rx = pm->op_pmregexp;

    TAINT_IF((pm->op_pmflags & PMf_LOCALE) &&
	     (pm->op_pmflags & (PMf_WHITE | PMf_SKIPWHITE)));

d3337 1
a3337 5
#ifdef USE_THREADS
	ary = (AV*)PL_curpad[0];
#else
	ary = GvAVn(PL_defgv);
#endif /* USE_THREADS */
d3342 5
a3346 1
	PUTBACK;
d3349 2
a3350 15
	SPAGAIN;
	if (mg = SvTIED_mg((SV*)ary, 'P')) {
	    PUSHMARK(SP);
	    XPUSHs(SvTIED_obj((SV*)ary, mg));
	}
	else {
	    if (!AvREAL(ary)) {
		AvREAL_on(ary);
		for (i = AvFILLp(ary); i >= 0; i--)
		    AvARRAY(ary)[i] = &PL_sv_undef;	/* don't free mere refs */
	    }
	    /* temporarily switch stacks */
	    SWITCHSTACK(PL_curstack, ary);
	    make_mortal = 0;
	}
d3352 1
a3352 1
    base = SP - PL_stack_base;
d3355 2
a3356 8
	if (pm->op_pmflags & PMf_LOCALE) {
	    while (isSPACE_LC(*s))
		s++;
	}
	else {
	    while (isSPACE(*s))
		s++;
	}
d3359 2
a3360 2
	SAVEINT(PL_multiline);
	PL_multiline = pm->op_pmflags & PMf_MULTILINE;
d3367 2
a3368 5
	    m = s;
	    while (m < strend &&
		   !((pm->op_pmflags & PMf_LOCALE)
		     ? isSPACE_LC(*m) : isSPACE(*m)))
		++m;
a3370 1

d3373 1
a3373 1
	    if (make_mortal)
d3376 2
a3377 6

	    s = m + 1;
	    while (s < strend &&
		   ((pm->op_pmflags & PMf_LOCALE)
		    ? isSPACE_LC(*s) : isSPACE(*s)))
		++s;
d3389 1
a3389 1
	    if (make_mortal)
d3395 7
a3401 6
    else if (rx->check_substr && !rx->nparens
	     && (rx->reganch & ROPT_CHECK_ALL)
	     && !(rx->reganch & ROPT_ANCH)) {
	i = SvCUR(rx->check_substr);
	if (i == 1 && !SvTAIL(rx->check_substr)) {
	    i = *SvPVX(rx->check_substr);
d3403 9
a3411 2
		/*SUPPRESS 530*/
		for (m = s; m < strend && *m != i; m++) ;
d3416 1
a3416 1
		if (make_mortal)
d3426 1
a3426 1
		    rx->check_substr, 0)) )
d3431 1
a3431 1
		if (make_mortal)
d3441 1
a3441 3
	       CALLREGEXEC(rx, s, strend, orig, 1, Nullsv, NULL, 0))
	{
	    TAINT_IF(RX_MATCH_TAINTED(rx));
d3453 1
a3453 1
	    if (make_mortal)
d3466 1
a3466 1
		    if (make_mortal)
a3473 1

d3475 1
a3475 1
    iters = (SP - PL_stack_base) - base;
d3478 1
a3478 1

d3483 1
a3483 1
	if (make_mortal)
d3489 1
a3489 1
	while (iters > 0 && (!TOPs || !SvANY(TOPs) || SvCUR(TOPs) == 0))
a3491 1

d3493 6
a3498 29
	if (!mg) {
	    SWITCHSTACK(ary, oldstack);
	    if (SvSMAGICAL(ary)) {
		PUTBACK;
		mg_set((SV*)ary);
		SPAGAIN;
	    }
	    if (gimme == G_ARRAY) {
		EXTEND(SP, iters);
		Copy(AvARRAY(ary), SP + 1, iters, SV*);
		SP += iters;
		RETURN;
	    }
	}
	else {
	    PUTBACK;
	    ENTER;
	    perl_call_method("PUSH",G_SCALAR|G_DISCARD);
	    LEAVE;
	    SPAGAIN;
	    if (gimme == G_ARRAY) {
		/* EXTEND should not be needed - we just popped them */
		EXTEND(SP, iters);
		for (i=0; i < iters; i++) {
		    SV **svp = av_fetch(ary, i, FALSE);
		    PUSHs((svp) ? *svp : &PL_sv_undef);
		}
		RETURN;
	    }
a3512 67
#ifdef USE_THREADS
void
unlock_condpair(void *svv)
{
    dTHR;
    MAGIC *mg = mg_find((SV*)svv, 'm');

    if (!mg)
	croak("panic: unlock_condpair unlocking non-mutex");
    MUTEX_LOCK(MgMUTEXP(mg));
    if (MgOWNER(mg) != thr)
	croak("panic: unlock_condpair unlocking mutex that we don't own");
    MgOWNER(mg) = 0;
    COND_SIGNAL(MgOWNERCONDP(mg));
    DEBUG_S(PerlIO_printf(PerlIO_stderr(), "0x%lx: unlock 0x%lx\n",
			  (unsigned long)thr, (unsigned long)svv);)
    MUTEX_UNLOCK(MgMUTEXP(mg));
}
#endif /* USE_THREADS */

PP(pp_lock)
{
    djSP;
    dTOPss;
    SV *retsv = sv;
#ifdef USE_THREADS
    MAGIC *mg;

    if (SvROK(sv))
	sv = SvRV(sv);

    mg = condpair_magic(sv);
    MUTEX_LOCK(MgMUTEXP(mg));
    if (MgOWNER(mg) == thr)
	MUTEX_UNLOCK(MgMUTEXP(mg));
    else {
	while (MgOWNER(mg))
	    COND_WAIT(MgOWNERCONDP(mg), MgMUTEXP(mg));
	MgOWNER(mg) = thr;
	DEBUG_S(PerlIO_printf(PerlIO_stderr(), "0x%lx: pp_lock lock 0x%lx\n",
			      (unsigned long)thr, (unsigned long)sv);)
	MUTEX_UNLOCK(MgMUTEXP(mg));
	save_destructor(unlock_condpair, sv);
    }
#endif /* USE_THREADS */
    if (SvTYPE(retsv) == SVt_PVAV || SvTYPE(retsv) == SVt_PVHV
	|| SvTYPE(retsv) == SVt_PVCV) {
	retsv = refto(retsv);
    }
    SETs(retsv);
    RETURN;
}

PP(pp_threadsv)
{
    djSP;
#ifdef USE_THREADS
    EXTEND(SP, 1);
    if (PL_op->op_private & OPpLVAL_INTRO)
	PUSHs(*save_threadsv(PL_op->op_targ));
    else
	PUSHs(THREADSV(PL_op->op_targ));
    RETURN;
#else
    DIE("tried to access per-thread data in non-threaded perl");
#endif /* USE_THREADS */
}
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2000, Larry Wall
a15 1
#define PERL_IN_PP_C
d30 31
d81 1
a81 8
/* CROSSCOMPILE and MULTIARCH are going to affect pp_pack() and pp_unpack().
   --jhi Feb 1999 */

#if SHORTSIZE != SIZE16 || LONGSIZE != SIZE32
#   define PERL_NATINT_PACK
#endif

#if LONGSIZE > 4 && defined(_CRAY)
a94 1
#  define COPYNN(s,p,n) (*(p) = 0, Copy(s, (char *)(p), n, char))
a99 1
#  define COPYNN(s,p,n) Copy(s, (char *)(p), n, char)
d104 8
d187 1
a187 1
	RETURNOP(do_kv());
d192 1
a192 1
	    Perl_sv_setpvf(aTHX_ sv, "%ld/%ld",
d203 1
a203 1
    DIE(aTHX_ "NOT IMPL LINE %d",__LINE__);
d210 1
a210 1
    djSP; dTOPss;  
a213 2
	tryAMAGICunDEREF(to_gv);

d221 2
a222 3
	}
	else if (SvTYPE(sv) != SVt_PVGV)
	    DIE(aTHX_ "Not a GLOB reference");
d234 1
a234 24
	    if (!SvOK(sv) && sv != &PL_sv_undef) {
		/* If this is a 'my' scalar and flag is set then vivify 
		 * NI-S 1999/05/07
		 */ 
		if (PL_op->op_private & OPpDEREF) {
		    char *name;
		    GV *gv;
		    if (cUNOP->op_targ) {
			STRLEN len;
			SV *namesv = PL_curpad[cUNOP->op_targ];
			name = SvPV(namesv, len);
			gv = (GV*)NEWSV(0,0);
			gv_init(gv, CopSTASH(PL_curcop), name, len, 0);
		    }
		    else {
			name = CopSTASHPV(PL_curcop);
			gv = newGVgen(name);
		    }
		    sv_upgrade(sv, SVt_RV);
		    SvRV(sv) = (SV*)gv;
		    SvROK_on(sv);
		    SvSETMAGIC(sv);
		    goto wasref;
		}
d237 3
a239 3
		    DIE(aTHX_ PL_no_usym, "a symbol");
		if (ckWARN(WARN_UNINITIALIZED))
		    report_uninit();
d243 3
a245 12
	    if ((PL_op->op_flags & OPf_SPECIAL) &&
		!(PL_op->op_flags & OPf_MOD))
	    {
		sv = (SV*)gv_fetchpv(sym, FALSE, SVt_PVGV);
		if (!sv)
		    RETSETUNDEF;
	    }
	    else {
		if (PL_op->op_private & HINT_STRICT_REFS)
		    DIE(aTHX_ PL_no_symref, sym, "a symbol");
		sv = (SV*)gv_fetchpv(sym, TRUE, SVt_PVGV);
	    }
a259 2
	tryAMAGICunDEREF(to_sv);

d265 1
a265 1
	    DIE(aTHX_ "Not a SCALAR reference");
d282 3
a284 3
		    DIE(aTHX_ PL_no_usym, "a SCALAR");
		if (ckWARN(WARN_UNINITIALIZED))
		    report_uninit();
d288 3
a290 12
	    if ((PL_op->op_flags & OPf_SPECIAL) &&
		!(PL_op->op_flags & OPf_MOD))
	    {
		gv = (GV*)gv_fetchpv(sym, FALSE, SVt_PV);
		if (!gv)
		    RETSETUNDEF;
	    }
	    else {
		if (PL_op->op_private & HINT_STRICT_REFS)
		    DIE(aTHX_ PL_no_symref, sym, "a SCALAR");
		gv = (GV*)gv_fetchpv(sym, TRUE, SVt_PV);
	    }
d343 1
a343 4
		I32 i = mg->mg_len;
		if (DO_UTF8(sv))
		    sv_pos_b2u(sv, &i);
		PUSHi(i + PL_curcop->cop_arybase);
a362 2
	if ((PL_op->op_private & OPpLVAL_INTRO) && !CvLVALUE(cv))
	    DIE(aTHX_ "Can't modify non-lvalue subroutine call");
d392 1
a392 3
		    if (strEQ(s + 6, PL_op_name[i])
			|| strEQ(s + 6, PL_op_desc[i]))
		    {
a393 1
		    }
d398 1
a398 1
		oa = PL_opargs[i] >> OASHIFT;
d403 1
a403 2
		    }
		    else if (n && str[0] == ';' && seen_question) 
d414 2
a415 3
		ret = sv_2mortal(newSVpvn(str, n - 1));
	    }
	    else if (code)		/* Non-Overridable */
d419 1
a419 1
		DIE(aTHX_ "Can't find an opnumber for \"%s\"", s+6);
d425 1
a425 1
	ret = sv_2mortal(newSVpvn(SvPVX(cv), SvCUR(cv)));
d468 1
a468 1
S_refto(pTHX_ SV *sv)
a476 8
	else
	    (void)SvREFCNT_inc(sv);
    }
    else if (SvTYPE(sv) == SVt_PVAV) {
	if (!AvREAL((AV*)sv) && AvREIFY((AV*)sv))
	    av_reify((AV*)sv);
	SvTEMP_off(sv);
	(void)SvREFCNT_inc(sv);
d517 1
a517 1
	stash = CopSTASH(PL_curcop);
d522 2
a523 3
	if (ckWARN(WARN_MISC) && len == 0)
	    Perl_warner(aTHX_ WARN_MISC, 
		   "Explicit blessing to '' (assuming package main)");
d539 1
a539 1
 
d573 1
a573 1
	    sv = newSVpvn(GvNAME(gv), GvNAMELEN(gv));
d599 1
d639 1
a639 1
	DIE(aTHX_ "do_study: out of memory");
d671 1
a671 1
    PUSHi(do_trans(sv));
d756 9
a764 2
    if (SvTHINKFIRST(sv))
	sv_force_normal(sv);
d776 2
a777 2
	if (ckWARN(WARN_MISC) && cv_const_sv((CV*)sv))
	    Perl_warner(aTHX_ WARN_MISC, "Constant subroutine %s undefined",
d781 3
a783 6
	{
	    /* let user-undef'd sub keep its identity */
	    GV* gv = (GV*)SvREFCNT_inc(CvGV((CV*)sv));
	    cv_undef((CV*)sv);
	    CvGV((CV*)sv) = gv;
	}
d794 1
a794 1
	    GvLINE(sv) = CopLINE(PL_curcop);
d817 2
a818 2
	DIE(aTHX_ PL_no_modify);
    if (SvIOK_notUV(TOPs) && !SvNOK(TOPs) && !SvPOK(TOPs) &&
d834 1
a834 1
	DIE(aTHX_ PL_no_modify);
d836 1
a836 1
    if (SvIOK_notUV(TOPs) && !SvNOK(TOPs) && !SvPOK(TOPs) &&
d854 2
a855 2
    if (SvREADONLY(TOPs) || SvTYPE(TOPs) > SVt_PVLV)
	DIE(aTHX_ PL_no_modify);
d857 1
a857 1
    if (SvIOK_notUV(TOPs) && !SvNOK(TOPs) && !SvPOK(TOPs) &&
d877 1
a877 1
      SETn( Perl_pow( left, right) );
d897 1
a897 1
      NV value;
d899 1
a899 1
	DIE(aTHX_ "Illegal division by zero");
d904 2
a905 2
	if ((NV)I_V(left)  == left &&
	    (NV)I_V(right) == right &&
d908 1
a908 2
	}
	else {
d924 14
a937 19
	UV left;
	UV right;
	bool left_neg;
	bool right_neg;
	bool use_double = 0;
	NV dright;
	NV dleft;

	if (SvIOK(TOPs) && !SvNOK(TOPs) && !SvPOK(TOPs)) {
	    IV i = SvIVX(POPs);
	    right = (right_neg = (i < 0)) ? -i : i;
	}
	else {
	    dright = POPn;
	    use_double = 1;
	    right_neg = dright < 0;
	    if (right_neg)
		dright = -dright;
	}
d939 8
a946 35
	if (!use_double && SvIOK(TOPs) && !SvNOK(TOPs) && !SvPOK(TOPs)) {
	    IV i = SvIVX(POPs);
	    left = (left_neg = (i < 0)) ? -i : i;
	}
	else {
	    dleft = POPn;
	    if (!use_double) {
		use_double = 1;
		dright = right;
	    }
	    left_neg = dleft < 0;
	    if (left_neg)
		dleft = -dleft;
	}

	if (use_double) {
	    NV dans;

#if 1
/* Somehow U_V is pessimized even if CASTFLAGS is 0 */
#  if CASTFLAGS & 2
#    define CAST_D2UV(d) U_V(d)
#  else
#    define CAST_D2UV(d) ((UV)(d))
#  endif
	    /* Tried to do this only in the case DOUBLESIZE <= UV_SIZE,
	     * or, in other words, precision of UV more than of NV.
	     * But in fact the approach below turned out to be an
	     * optimization - floor() may be slow */
	    if (dright <= UV_MAX && dleft <= UV_MAX) {
		right = CAST_D2UV(dright);
		left  = CAST_D2UV(dleft);
		goto do_uv;
	    }
#endif
d948 2
a949 16
	    /* Backward-compatibility clause: */
	    dright = Perl_floor(dright + 0.5);
	    dleft  = Perl_floor(dleft + 0.5);

	    if (!dright)
		DIE(aTHX_ "Illegal modulus zero");

	    dans = Perl_fmod(dleft, dright);
	    if ((left_neg != right_neg) && dans)
		dans = dright - dans;
	    if (right_neg)
		dans = -dans;
	    sv_setnv(TARG, dans);
	}
	else {
	    UV ans;
d951 15
a965 20
	do_uv:
	    if (!right)
		DIE(aTHX_ "Illegal modulus zero");

	    ans = left % right;
	    if ((left_neg != right_neg) && ans)
		ans = right - ans;
	    if (right_neg) {
		/* XXX may warn: unary minus operator applied to unsigned type */
		/* could change -foo to be (~foo)+1 instead	*/
		if (ans <= ~((UV)IV_MAX)+1)
		    sv_setiv(TARG, ~ans+1);
		else
		    sv_setnv(TARG, -(NV)ans);
	    }
	    else
		sv_setuv(TARG, ans);
	}
	PUSHTARG;
	RETURN;
d1000 6
d1039 1
a1039 1
      IV shift = POPi;
d1041 3
a1043 2
	IV i = TOPi;
	SETi(i << shift);
d1046 3
a1048 2
	UV u = TOPu;
	SETu(u << shift);
d1058 1
a1058 1
      IV shift = POPi;
d1060 3
a1062 2
	IV i = TOPi;
	SETi(i >> shift);
d1065 3
a1067 2
	UV u = TOPu;
	SETu(u >> shift);
a1128 7
#ifdef __osf__ /* XXX Configure probe for isnan and isnanl needed XXX */
#if defined(USE_LONG_DOUBLE) && defined(HAS_LONG_DOUBLE)
#define Perl_isnan isnanl
#else
#define Perl_isnan isnan
#endif
#endif
a1129 7
#ifdef __osf__ /* XXX fix in 5.6.1 --jhi */
      if (Perl_isnan(left) || Perl_isnan(right)) {
	  SETs(&PL_sv_undef);
	  RETURN;
       }
      value = (left > right) - (left < right);
#else
a1139 1
#endif
d1237 2
a1238 2
	  IV i = SvIV(left) & SvIV(right);
	  SETi(i);
d1241 2
a1242 2
	  UV u = SvUV(left) & SvUV(right);
	  SETu(u);
d1260 2
a1261 2
	  IV i = (USE_LEFT(left) ? SvIV(left) : 0) ^ SvIV(right);
	  SETi(i);
d1264 2
a1265 2
	  UV u = (USE_LEFT(left) ? SvUV(left) : 0) ^ SvUV(right);
	  SETu(u);
d1283 2
a1284 2
	  IV i = (USE_LEFT(left) ? SvIV(left) : 0) | SvIV(right);
	  SETi(i);
d1287 2
a1288 2
	  UV u = (USE_LEFT(left) ? SvUV(left) : 0) | SvUV(right);
	  SETu(u);
d1306 3
a1308 17
	if (SvIOKp(sv) && !SvNOKp(sv) && !SvPOKp(sv)) {
	    if (SvIsUV(sv)) {
		if (SvIVX(sv) == IV_MIN) {
		    SETi(SvIVX(sv));	/* special case: -((UV)IV_MAX+1) == IV_MIN */
		    RETURN;
		}
		else if (SvUVX(sv) <= IV_MAX) {
		    SETi(-SvIVX(sv));
		    RETURN;
		}
	    }
	    else if (SvIVX(sv) != IV_MIN) {
		SETi(-SvIVX(sv));
		RETURN;
	    }
	}
	if (SvNIOKp(sv))
a1320 4
	    else if (DO_UTF8(sv) && *(U8*)s >= 0xc0 && isIDFIRST_utf8((U8*)s)) {
		sv_setpvn(TARG, "-", 1);
		sv_catsv(TARG, sv);
	    }
d1333 1
d1335 1
d1347 2
a1348 2
	  IV i = ~SvIV(sv);
	  SETi(i);
d1351 2
a1352 2
	  UV u = ~SvUV(sv);
	  SETu(u);
d1399 1
a1399 1
	DIE(aTHX_ "Illegal division by zero");
d1412 1
a1412 1
	DIE(aTHX_ "Illegal modulus zero");
d1530 1
a1530 1
      SETn(Perl_atan2(left, right));
d1539 1
a1539 1
      NV value;
d1541 1
a1541 1
      value = Perl_sin(value);
d1551 1
a1551 1
      NV value;
d1553 1
a1553 1
      value = Perl_cos(value);
d1565 5
a1569 7
/* Now it's after 5.005, and Configure supports drand48() and random(),
   in addition to rand().  So the overrides should not be needed any more.
   --Jarkko Hietaniemi	27 September 1998
 */

#ifndef HAS_DRAND48_PROTO
extern double drand48 (void);
d1575 1
a1575 1
    NV value;
d1582 3
a1584 3
    if (!PL_srand_called) {
	(void)seedDrand01((Rand_seed_t)seed());
	PL_srand_called = TRUE;
d1586 13
a1598 1
    value *= Drand01();
d1611 2
a1612 2
    (void)seedDrand01((Rand_seed_t)anum);
    PL_srand_called = TRUE;
d1618 1
a1618 1
S_seed(pTHX)
d1624 1
a1624 1
     * if someone who knows about such things would bother to write it.
d1626 1
a1626 1
     * No numbers below come from careful analysis or anything here,
d1691 2
a1692 2
    u += SEED_C3 * (U32)PerlProc_getpid();
    u += SEED_C4 * (U32)PTR2UV(PL_stack_sp);
d1694 1
a1694 1
    u += SEED_C5 * (U32)PTR2UV(&when);
d1703 1
a1703 1
      NV value;
d1705 1
a1705 1
      value = Perl_exp(value);
d1715 1
a1715 1
      NV value;
d1718 2
a1719 2
	RESTORE_NUMERIC_STANDARD();
	DIE(aTHX_ "Can't take log of %g", value);
d1721 1
a1721 1
      value = Perl_log(value);
d1731 1
a1731 1
      NV value;
d1734 2
a1735 2
	RESTORE_NUMERIC_STANDARD();
	DIE(aTHX_ "Can't take sqrt of %g", value);
d1737 1
a1737 1
      value = Perl_sqrt(value);
d1747 1
a1747 1
      NV value = TOPn;
d1756 1
a1756 1
	  (void)Perl_modf(value, &value);
d1758 1
a1758 1
	  (void)Perl_modf(-value, &value);
d1775 1
a1775 1
      NV value = TOPn;
d1801 1
a1801 1
    XPUSHn(scan_hex(tmps, 99, &argtype));
d1808 1
a1808 1
    NV value;
a1819 2
    else if (*tmps == 'b')
	value = scan_bin(++tmps, 99, &argtype);
d1822 1
a1822 1
    XPUSHn(value);
d1831 1
a1831 6
    SV *sv = TOPs;

    if (DO_UTF8(sv))
	SETi(sv_len_utf8(sv));
    else
	SETi(sv_len(sv));
a1840 1
    STRLEN utfcurlen;
a1850 1
    SvUTF8_off(TARG);				/* decontaminate */
a1861 10
    if (DO_UTF8(sv)) {
        utfcurlen = sv_len_utf8(sv);
	if (utfcurlen == curlen)
	    utfcurlen = 0;
	else
	    curlen = utfcurlen;
    }
    else
	utfcurlen = 0;

d1896 2
a1897 4
	if (lvalue || repl)
	    Perl_croak(aTHX_ "substr outside of string");
	if (ckWARN(WARN_SUBSTR))
	    Perl_warner(aTHX_ WARN_SUBSTR, "substr outside of string");
a1900 4
        if (utfcurlen) {
	    sv_pos_u2b(sv, &pos, &rem);
	    SvUTF8_on(TARG);
	}
d1903 1
a1903 3
	if (repl)
	    sv_insert(sv, pos, rem, repl, repl_len);
	else if (lvalue) {		/* it's an lvalue! */
d1908 2
a1909 3
		    if (ckWARN(WARN_SUBSTR))
			Perl_warner(aTHX_ WARN_SUBSTR,
				"Attempt to use reference as lvalue in substr");
d1931 2
d1946 4
d1951 46
a1996 5
    SvTAINTED_off(TARG);		/* decontaminate */
    if (lvalue) {			/* it's an lvalue! */
	if (SvTYPE(TARG) < SVt_PVLV) {
	    sv_upgrade(TARG, SVt_PVLV);
	    sv_magic(TARG, Nullsv, 'v', Nullch, 0);
d1998 12
a2009 5
	LvTYPE(TARG) = 'v';
	if (LvTARG(TARG) != src) {
	    if (LvTARG(TARG))
		SvREFCNT_dec(LvTARG(TARG));
	    LvTARG(TARG) = SvREFCNT_inc(src);
a2010 2
	LvTARGOFF(TARG) = offset;
	LvTARGLEN(TARG) = size;
d2013 1
a2013 1
    sv_setuv(TARG, do_vecget(src, offset, size));
a2036 2
    if (offset > 0 && DO_UTF8(big))
	sv_pos_u2b(big, &offset, 0);
d2043 1
a2043 1
	retval = -1;
d2045 2
a2046 4
	retval = tmps2 - tmps;
    if (retval > 0 && DO_UTF8(big))
	sv_pos_b2u(big, &retval);
    PUSHi(retval + arybase);
d2057 1
d2065 1
a2065 1
	offset = POPi;
d2072 2
a2073 5
    else {
	if (offset > 0 && DO_UTF8(big))
	    sv_pos_u2b(big, &offset, 0);
	offset = offset - arybase + llen;
    }
d2080 1
a2080 1
	retval = -1;
d2082 2
a2083 4
	retval = tmps2 - tmps;
    if (retval > 0 && DO_UTF8(big))
	sv_pos_b2u(big, &retval);
    PUSHi(retval + arybase);
d2090 6
d2106 2
a2107 1
    UV value;
a2108 3
    SV *tmpsv = POPs;
    U8 *tmps = (U8*)SvPVx(tmpsv,n_a);
    I32 retlen;
d2110 10
a2119 5
    if ((*tmps & 0x80) && DO_UTF8(tmpsv))
	value = utf8_to_uv(tmps, &retlen);
    else
	value = (UV)(*tmps & 255);
    XPUSHu(value);
a2126 1
    U32 value = POPu;
a2128 13

    if (value > 255 && !IN_BYTE) {
	SvGROW(TARG, UTF8_MAXLEN+1);
	tmps = SvPVX(TARG);
	tmps = (char*)uv_to_utf8((U8*)tmps, (UV)value);
	SvCUR_set(TARG, tmps - SvPVX(TARG));
	*tmps = '\0';
	(void)SvPOK_only(TARG);
	SvUTF8_on(TARG);
	XPUSHs(TARG);
	RETURN;
    }

d2132 1
a2132 1
    *tmps++ = value;
a2133 1
    SvUTF8_off(TARG);				/* decontaminate */
d2151 1
a2151 1
    DIE(aTHX_ 
d2162 2
a2163 8
    register U8 *s;
    STRLEN slen;

    if (DO_UTF8(sv) && (s = (U8*)SvPV(sv, slen)) && slen && (*s & 0xc0) == 0xc0) {
	I32 ulen;
	U8 tmpbuf[UTF8_MAXLEN];
	U8 *tend;
	UV uv = utf8_to_uv(s, &ulen);
d2165 8
d2176 1
a2176 1
	    uv = toTITLE_LC_uni(uv);
d2179 2
a2180 3
	    uv = toTITLE_utf8(s);
	
	tend = uv_to_utf8(tmpbuf, uv);
a2181 33
	if (!SvPADTMP(sv) || tend - tmpbuf != ulen || SvREADONLY(sv)) {
	    dTARGET;
	    sv_setpvn(TARG, (char*)tmpbuf, tend - tmpbuf);
	    sv_catpvn(TARG, (char*)(s + ulen), slen - ulen);
	    SvUTF8_on(TARG);
	    SETs(TARG);
	}
	else {
	    s = (U8*)SvPV_force(sv, slen);
	    Copy(tmpbuf, s, ulen, U8);
	}
    }
    else {
	if (!SvPADTMP(sv) || SvREADONLY(sv)) {
	    dTARGET;
	    SvUTF8_off(TARG);				/* decontaminate */
	    sv_setsv(TARG, sv);
	    sv = TARG;
	    SETs(sv);
	}
	s = (U8*)SvPV_force(sv, slen);
	if (*s) {
	    if (PL_op->op_private & OPpLOCALE) {
		TAINT;
		SvTAINTED_on(sv);
		*s = toUPPER_LC(*s);
	    }
	    else
		*s = toUPPER(*s);
	}
    }
    if (SvSMAGICAL(sv))
	mg_set(sv);
d2189 2
a2190 8
    register U8 *s;
    STRLEN slen;

    if (DO_UTF8(sv) && (s = (U8*)SvPV(sv, slen)) && slen && (*s & 0xc0) == 0xc0) {
	I32 ulen;
	U8 tmpbuf[UTF8_MAXLEN];
	U8 *tend;
	UV uv = utf8_to_uv(s, &ulen);
d2192 8
d2203 1
a2203 1
	    uv = toLOWER_LC_uni(uv);
d2206 2
a2207 3
	    uv = toLOWER_utf8(s);
	
	tend = uv_to_utf8(tmpbuf, uv);
d2209 1
a2209 33
	if (!SvPADTMP(sv) || tend - tmpbuf != ulen || SvREADONLY(sv)) {
	    dTARGET;
	    sv_setpvn(TARG, (char*)tmpbuf, tend - tmpbuf);
	    sv_catpvn(TARG, (char*)(s + ulen), slen - ulen);
	    SvUTF8_on(TARG);
	    SETs(TARG);
	}
	else {
	    s = (U8*)SvPV_force(sv, slen);
	    Copy(tmpbuf, s, ulen, U8);
	}
    }
    else {
	if (!SvPADTMP(sv) || SvREADONLY(sv)) {
	    dTARGET;
	    SvUTF8_off(TARG);				/* decontaminate */
	    sv_setsv(TARG, sv);
	    sv = TARG;
	    SETs(sv);
	}
	s = (U8*)SvPV_force(sv, slen);
	if (*s) {
	    if (PL_op->op_private & OPpLOCALE) {
		TAINT;
		SvTAINTED_on(sv);
		*s = toLOWER_LC(*s);
	    }
	    else
		*s = toLOWER(*s);
	}
    }
    if (SvSMAGICAL(sv))
	mg_set(sv);
d2217 1
a2217 1
    register U8 *s;
d2220 1
a2220 1
    if (DO_UTF8(sv)) {
d2222 14
a2235 9
	I32 ulen;
	register U8 *d;
	U8 *send;

	s = (U8*)SvPV(sv,len);
	if (!len) {
	    SvUTF8_off(TARG);				/* decontaminate */
	    sv_setpvn(TARG, "", 0);
	    SETs(TARG);
d2238 2
a2239 47
	    (void)SvUPGRADE(TARG, SVt_PV);
	    SvGROW(TARG, (len * 2) + 1);
	    (void)SvPOK_only(TARG);
	    d = (U8*)SvPVX(TARG);
	    send = s + len;
	    if (PL_op->op_private & OPpLOCALE) {
		TAINT;
		SvTAINTED_on(TARG);
		while (s < send) {
		    d = uv_to_utf8(d, toUPPER_LC_uni( utf8_to_uv(s, &ulen)));
		    s += ulen;
		}
	    }
	    else {
		while (s < send) {
		    d = uv_to_utf8(d, toUPPER_utf8( s ));
		    s += UTF8SKIP(s);
		}
	    }
	    *d = '\0';
	    SvUTF8_on(TARG);
	    SvCUR_set(TARG, d - (U8*)SvPVX(TARG));
	    SETs(TARG);
	}
    }
    else {
	if (!SvPADTMP(sv) || SvREADONLY(sv)) {
	    dTARGET;
	    SvUTF8_off(TARG);				/* decontaminate */
	    sv_setsv(TARG, sv);
	    sv = TARG;
	    SETs(sv);
	}
	s = (U8*)SvPV_force(sv, len);
	if (len) {
	    register U8 *send = s + len;

	    if (PL_op->op_private & OPpLOCALE) {
		TAINT;
		SvTAINTED_on(sv);
		for (; s < send; s++)
		    *s = toUPPER_LC(*s);
	    }
	    else {
		for (; s < send; s++)
		    *s = toUPPER(*s);
	    }
a2241 2
    if (SvSMAGICAL(sv))
	mg_set(sv);
d2249 1
a2249 1
    register U8 *s;
d2252 1
a2252 1
    if (DO_UTF8(sv)) {
d2254 14
a2267 9
	I32 ulen;
	register U8 *d;
	U8 *send;

	s = (U8*)SvPV(sv,len);
	if (!len) {
	    SvUTF8_off(TARG);				/* decontaminate */
	    sv_setpvn(TARG, "", 0);
	    SETs(TARG);
d2270 2
a2271 48
	    (void)SvUPGRADE(TARG, SVt_PV);
	    SvGROW(TARG, (len * 2) + 1);
	    (void)SvPOK_only(TARG);
	    d = (U8*)SvPVX(TARG);
	    send = s + len;
	    if (PL_op->op_private & OPpLOCALE) {
		TAINT;
		SvTAINTED_on(TARG);
		while (s < send) {
		    d = uv_to_utf8(d, toLOWER_LC_uni( utf8_to_uv(s, &ulen)));
		    s += ulen;
		}
	    }
	    else {
		while (s < send) {
		    d = uv_to_utf8(d, toLOWER_utf8(s));
		    s += UTF8SKIP(s);
		}
	    }
	    *d = '\0';
	    SvUTF8_on(TARG);
	    SvCUR_set(TARG, d - (U8*)SvPVX(TARG));
	    SETs(TARG);
	}
    }
    else {
	if (!SvPADTMP(sv) || SvREADONLY(sv)) {
	    dTARGET;
	    SvUTF8_off(TARG);				/* decontaminate */
	    sv_setsv(TARG, sv);
	    sv = TARG;
	    SETs(sv);
	}

	s = (U8*)SvPV_force(sv, len);
	if (len) {
	    register U8 *send = s + len;

	    if (PL_op->op_private & OPpLOCALE) {
		TAINT;
		SvTAINTED_on(sv);
		for (; s < send; s++)
		    *s = toLOWER_LC(*s);
	    }
	    else {
		for (; s < send; s++)
		    *s = toLOWER(*s);
	    }
a2273 2
    if (SvSMAGICAL(sv))
	mg_set(sv);
a2284 1
    SvUTF8_off(TARG);				/* decontaminate */
d2289 4
a2292 25
	if (DO_UTF8(sv)) {
	    while (len) {
		if (*s & 0x80) {
		    STRLEN ulen = UTF8SKIP(s);
		    if (ulen > len)
			ulen = len;
		    len -= ulen;
		    while (ulen--)
			*d++ = *s++;
		}
		else {
		    if (!isALNUM(*s))
			*d++ = '\\';
		    *d++ = *s++;
		    len--;
		}
	    }
	    SvUTF8_on(TARG);
	}
	else {
	    while (len--) {
		if (!isALNUM(*s))
		    *d++ = '\\';
		*d++ = *s++;
	    }
a2300 2
    if (SvSMAGICAL(TARG))
	mg_set(TARG);
d2334 1
a2334 1
		    DIE(aTHX_ PL_no_aelem, elem);
d2353 1
a2353 1
    djSP;
a2367 1
	    SV *val;
d2370 2
a2371 2
	    val = realhv ?
		  hv_iterval(hash, entry) : avhv_iterval((AV*)hash, entry);
d2373 1
a2373 1
	    PUSHs(val);
d2384 1
a2384 1
    return do_kv();
d2389 1
a2389 1
    return do_kv();
d2405 2
a2406 2
	if (hvtype == SVt_PVHV) {			/* hash element */
	    while (++MARK <= SP) {
d2408 3
a2410 16
		*MARK = sv ? sv : &PL_sv_undef;
	    }
	}
	else if (hvtype == SVt_PVAV) {
	    if (PL_op->op_flags & OPf_SPECIAL) {	/* array element */
		while (++MARK <= SP) {
		    sv = av_delete((AV*)hv, SvIV(*MARK), discard);
		    *MARK = sv ? sv : &PL_sv_undef;
		}
	    }
	    else {					/* pseudo-hash element */
		while (++MARK <= SP) {
		    sv = avhv_delete_ent((AV*)hv, *MARK, discard, 0);
		    *MARK = sv ? sv : &PL_sv_undef;
		}
	    }
a2411 2
	else
	    DIE(aTHX_ "Not a HASH reference");
a2424 6
	else if (SvTYPE(hv) == SVt_PVAV) {
	    if (PL_op->op_flags & OPf_SPECIAL)
		sv = av_delete((AV*)hv, SvIV(keysv), discard);
	    else
		sv = avhv_delete_ent((AV*)hv, keysv, discard, 0);
	}
d2426 1
a2426 1
	    DIE(aTHX_ "Not a HASH reference");
d2438 2
a2439 16
    SV *tmpsv;
    HV *hv;

    if (PL_op->op_private & OPpEXISTS_SUB) {
	GV *gv;
	CV *cv;
	SV *sv = POPs;
	cv = sv_2cv(sv, &hv, &gv, FALSE);
	if (cv)
	    RETPUSHYES;
	if (gv && isGV(gv) && GvCV(gv) && !GvCVGEN(gv))
	    RETPUSHYES;
	RETPUSHNO;
    }
    tmpsv = POPs;
    hv = (HV*)POPs;
d2443 2
a2444 7
    }
    else if (SvTYPE(hv) == SVt_PVAV) {
	if (PL_op->op_flags & OPf_SPECIAL) {		/* array element */
	    if (av_exists((AV*)hv, SvIV(tmpsv)))
		RETPUSHYES;
	}
	else if (avhv_exists_ent((AV*)hv, tmpsv, 0))	/* pseudo-hash element */
d2446 2
a2447 3
    }
    else {
	DIE(aTHX_ "Not a HASH reference");
d2460 1
a2460 1
	DIE(aTHX_ "Can't localize pseudo-hash element");
d2469 1
a2469 2
	    }
	    else {
d2475 1
a2475 1
		    DIE(aTHX_ PL_no_helem, SvPV(keysv, n_a));
d2542 1
a2542 1
	if (ix < 0)
d2544 6
a2549 1
	else 
d2551 1
a2551 5
	if (ix < 0 || ix >= max)
	    *lelem = &PL_sv_undef;
	else {
	    is_something_there = TRUE;
	    if (!(*lelem = firstrelem[ix]))
d2554 2
d2584 2
a2585 2
	else if (ckWARN(WARN_MISC))
	    Perl_warner(aTHX_ WARN_MISC, "Odd number of elements in hash assignment");
d2608 1
a2608 1
    if ((mg = SvTIED_mg((SV*)ary, 'P'))) {
d2613 1
a2613 1
	call_method("SPLICE",GIMME_V);
d2628 1
a2628 1
	    DIE(aTHX_ PL_no_aelem, i);
d2658 6
a2663 2
    if (newlen && !AvREAL(ary) && AvREIFY(ary))
	av_reify(ary);
d2806 1
a2806 1
    if ((mg = SvTIED_mg((SV*)ary, 'P'))) {
d2811 1
a2811 1
	call_method("PUSH",G_SCALAR|G_DISCARD);
d2862 1
a2862 1
    if ((mg = SvTIED_mg((SV*)ary, 'P'))) {
d2867 1
a2867 1
	call_method("UNSHIFT",G_SCALAR|G_DISCARD);
a2896 1
	/* safe as long as stack cannot get extended in the above */
a2905 1
	SvUTF8_off(TARG);				/* decontaminate */
a2911 27
	    if (DO_UTF8(TARG)) {	/* first reverse each character */
		U8* s = (U8*)SvPVX(TARG);
		U8* send = (U8*)(s + len);
		while (s < send) {
		    if (*s < 0x80) {
			s++;
			continue;
		    }
		    else {
			up = (char*)s;
			s += UTF8SKIP(s);
			down = (char*)(s - 1);
			if (s > send || !((*down & 0xc0) == 0x80)) {
			    if (ckWARN_d(WARN_UTF8))
				Perl_warner(aTHX_ WARN_UTF8,
					    "Malformed UTF-8 character");
			    break;
			}
			while (down > up) {
			    tmp = *up;
			    *up++ = *down;
			    *down-- = tmp;
			}
		    }
		}
		up = SvPVX(TARG);
	    }
d2926 2
a2927 2
STATIC SV *
S_mul128(pTHX_ SV *sv, U8 m)
d2935 1
a2935 1
    SV             *tmpNew = newSVpvn("0000000000", 10);
d2955 5
d2968 1
a2968 1
#define ISUUCHAR(ch)    (memchr(PL_uuemap, (ch), sizeof(PL_uuemap)-1) || (ch) == ' ')
d2975 1
a2975 1
    I32 start_sp_offset = SP - PL_stack_base;
a2987 1
    register char *str;
d3000 1
a3000 1
    Uquad_t auquad;
d3007 4
a3010 1
    NV cdouble;
a3011 5
    int star;
#ifdef PERL_NATINT_PACK
    int natint;		/* native integer */
    int unatint;	/* unsigned native integer */
#endif
a3026 3
#ifdef PERL_NATINT_PACK
	natint = 0;
#endif
a3028 18
	if (datumtype == '#') {
	    while (pat < patend && *pat != '\n')
		pat++;
	    continue;
	}
	if (*pat == '!') {
	    char *natstr = "sSiIlL";

	    if (strchr(natstr, datumtype)) {
#ifdef PERL_NATINT_PACK
		natint = 1;
#endif
		pat++;
	    }
	    else
		DIE(aTHX_ "'!' allowed only after types %s", natstr);
	}
	star = 0;
a3033 1
	    star = 1;
d3037 1
a3037 1
	    while (isDIGIT(*pat)) {
a3038 3
		if (len < 0)
		    DIE(aTHX_ "Repeat count in unpack overflows");
	    }
a3041 1
      redo_switch:
d3044 1
a3044 1
	    DIE(aTHX_ "Invalid type in unpack: '%c'", (int)datumtype);
d3046 2
a3047 3
	    if (commas++ == 0 && ckWARN(WARN_UNPACK))
		Perl_warner(aTHX_ WARN_UNPACK,
			    "Invalid type in unpack: '%c'", (int)datumtype);
d3060 1
a3060 1
		DIE(aTHX_ "@@ outside of string");
d3065 1
a3065 1
		DIE(aTHX_ "X outside of string");
d3070 1
a3070 1
		DIE(aTHX_ "x outside of string");
a3072 11
	case '/':
	    if (start_sp_offset >= SP - PL_stack_base)
		DIE(aTHX_ "/ must follow a numeric type");
	    datumtype = *pat++;
	    if (*pat == '*')
		pat++;		/* ignore '*' for compatibility with pack */
	    if (isDIGIT(*pat))
		DIE(aTHX_ "/ cannot take a count" );
	    len = POPi;
	    star = 0;
	    goto redo_switch;
d3103 1
a3103 1
	    if (star || len > (strend - s) * 8)
d3106 2
a3107 2
		if (!PL_bitcount) {
		    Newz(601, PL_bitcount, 256, char);
d3109 8
a3116 8
			if (bits & 1)	PL_bitcount[bits]++;
			if (bits & 2)	PL_bitcount[bits]++;
			if (bits & 4)	PL_bitcount[bits]++;
			if (bits & 8)	PL_bitcount[bits]++;
			if (bits & 16)	PL_bitcount[bits]++;
			if (bits & 32)	PL_bitcount[bits]++;
			if (bits & 64)	PL_bitcount[bits]++;
			if (bits & 128)	PL_bitcount[bits]++;
d3120 1
a3120 1
		    culong += PL_bitcount[*(unsigned char*)s++];
d3143 2
a3144 1
	    str = SvPVX(sv);
d3152 1
a3152 1
		    *str++ = '0' + (bits & 1);
d3162 1
a3162 1
		    *str++ = '0' + ((bits & 128) != 0);
d3165 2
a3166 1
	    *str = '\0';
d3171 1
a3171 1
	    if (star || len > (strend - s) * 2)
d3176 2
a3177 1
	    str = SvPVX(sv);
d3185 1
a3185 1
		    *str++ = PL_hexdigit[bits & 15];
d3195 1
a3195 1
		    *str++ = PL_hexdigit[(bits >> 4) & 15];
d3198 2
a3199 1
	    *str = '\0';
a3246 25
	case 'U':
	    if (len > strend - s)
		len = strend - s;
	    if (checksum) {
		while (len-- > 0 && s < strend) {
		    auint = utf8_to_uv((U8*)s, &along);
		    s += along;
		    if (checksum > 32)
			cdouble += (NV)auint;
		    else
			culong += auint;
		}
	    }
	    else {
		EXTEND(SP, len);
		EXTEND_MORTAL(len);
		while (len-- > 0 && s < strend) {
		    auint = utf8_to_uv((U8*)s, &along);
		    s += along;
		    sv = NEWSV(37, 0);
		    sv_setuv(sv, (UV)auint);
		    PUSHs(sv_2mortal(sv));
		}
	    }
	    break;
a3247 1
#if SHORTSIZE == SIZE16
a3248 3
#else
	    along = (strend - s) / (natint ? sizeof(short) : SIZE16);
#endif
d3252 2
a3253 15
#if SHORTSIZE != SIZE16
		if (natint) {
		    short ashort;
		    while (len-- > 0) {
			COPYNN(s, &ashort, sizeof(short));
			s += sizeof(short);
			culong += ashort;

		    }
		}
		else
#endif
                {
		    while (len-- > 0) {
			COPY16(s, &ashort);
d3255 2
a3256 2
			if (ashort > 32767)
			  ashort -= 65536;
d3258 2
a3259 3
			s += SIZE16;
			culong += ashort;
		    }
d3265 2
a3266 16
#if SHORTSIZE != SIZE16
		if (natint) {
		    short ashort;
		    while (len-- > 0) {
			COPYNN(s, &ashort, sizeof(short));
			s += sizeof(short);
			sv = NEWSV(38, 0);
			sv_setiv(sv, (IV)ashort);
			PUSHs(sv_2mortal(sv));
		    }
		}
		else
#endif
                {
		    while (len-- > 0) {
			COPY16(s, &ashort);
d3268 2
a3269 2
			if (ashort > 32767)
			  ashort -= 65536;
d3271 4
a3274 5
			s += SIZE16;
			sv = NEWSV(38, 0);
			sv_setiv(sv, (IV)ashort);
			PUSHs(sv_2mortal(sv));
		    }
a3280 1
#if SHORTSIZE == SIZE16
a3281 4
#else
	    unatint = natint && datumtype == 'S';
	    along = (strend - s) / (unatint ? sizeof(unsigned short) : SIZE16);
#endif
d3285 3
a3287 15
#if SHORTSIZE != SIZE16
		if (unatint) {
		    unsigned short aushort;
		    while (len-- > 0) {
			COPYNN(s, &aushort, sizeof(unsigned short));
			s += sizeof(unsigned short);
			culong += aushort;
		    }
		}
		else
#endif
                {
		    while (len-- > 0) {
			COPY16(s, &aushort);
			s += SIZE16;
d3289 2
a3290 2
			if (datumtype == 'n')
			    aushort = PerlSock_ntohs(aushort);
d3293 2
a3294 2
			if (datumtype == 'v')
			    aushort = vtohs(aushort);
d3296 1
a3296 2
			culong += aushort;
		    }
d3302 4
a3305 18
#if SHORTSIZE != SIZE16
		if (unatint) {
		    unsigned short aushort;
		    while (len-- > 0) {
			COPYNN(s, &aushort, sizeof(unsigned short));
			s += sizeof(unsigned short);
			sv = NEWSV(39, 0);
			sv_setiv(sv, (UV)aushort);
			PUSHs(sv_2mortal(sv));
		    }
		}
		else
#endif
                {
		    while (len-- > 0) {
			COPY16(s, &aushort);
			s += SIZE16;
			sv = NEWSV(39, 0);
d3307 2
a3308 2
			if (datumtype == 'n')
			    aushort = PerlSock_ntohs(aushort);
d3311 2
a3312 2
			if (datumtype == 'v')
			    aushort = vtohs(aushort);
d3314 2
a3315 3
			sv_setiv(sv, (UV)aushort);
			PUSHs(sv_2mortal(sv));
		    }
d3328 1
a3328 1
			cdouble += (NV)aint;
d3343 1
a3343 19
                     * cc with optimization turned on.
		     *
		     * The bug was detected in
		     * DEC C V5.8-009 on Digital UNIX V4.0 (Rev. 1091) (V4.0E)
		     * with optimization (-O4) turned on.
		     * DEC C V5.2-040 on Digital UNIX V4.0 (Rev. 564) (V4.0B)
		     * does not have this problem even with -O4.
		     *
		     * This bug was reported as DECC_BUGS 1431
		     * and tracked internally as GEM_BUGS 7775.
		     *
		     * The bug is fixed in
		     * Tru64 UNIX V5.0:      Compaq C V6.1-006 or later
		     * UNIX V4.0F support:   DEC C V5.9-006 or later
		     * UNIX V4.0E support:   DEC C V5.8-011 or later
		     * and also in DTK.
		     *
		     * See also few lines later for the same bug.
		     */
d3361 1
a3361 1
			cdouble += (NV)auint;
d3375 6
a3380 2
                     * returns 1.84467440737096e+19 instead of 0xFFFFFFFF.
		     * See details few lines earlier. */
a3389 1
#if LONGSIZE == SIZE32
a3390 3
#else
	    along = (strend - s) / (natint ? sizeof(long) : SIZE32);
#endif
d3394 2
a3395 17
#if LONGSIZE != SIZE32
		if (natint) {
		    long along;
		    while (len-- > 0) {
			COPYNN(s, &along, sizeof(long));
			s += sizeof(long);
			if (checksum > 32)
			    cdouble += (NV)along;
			else
			    culong += along;
		    }
		}
		else
#endif
                {
		    while (len-- > 0) {
			COPY32(s, &along);
d3397 2
a3398 2
			if (along > 2147483647)
			  along -= 4294967296;
d3400 5
a3404 6
			s += SIZE32;
			if (checksum > 32)
			    cdouble += (NV)along;
			else
			    culong += along;
		    }
d3410 2
a3411 16
#if LONGSIZE != SIZE32
		if (natint) {
		    long along;
		    while (len-- > 0) {
			COPYNN(s, &along, sizeof(long));
			s += sizeof(long);
			sv = NEWSV(42, 0);
			sv_setiv(sv, (IV)along);
			PUSHs(sv_2mortal(sv));
		    }
		}
		else
#endif
                {
		    while (len-- > 0) {
			COPY32(s, &along);
d3413 2
a3414 2
			if (along > 2147483647)
			  along -= 4294967296;
d3416 4
a3419 5
			s += SIZE32;
			sv = NEWSV(42, 0);
			sv_setiv(sv, (IV)along);
			PUSHs(sv_2mortal(sv));
		    }
a3425 1
#if LONGSIZE == SIZE32
a3426 4
#else
	    unatint = natint && datumtype == 'L';
	    along = (strend - s) / (unatint ? sizeof(unsigned long) : SIZE32);
#endif
d3430 3
a3432 18
#if LONGSIZE != SIZE32
		if (unatint) {
		    unsigned long aulong;
		    while (len-- > 0) {
			COPYNN(s, &aulong, sizeof(unsigned long));
			s += sizeof(unsigned long);
			if (checksum > 32)
			    cdouble += (NV)aulong;
			else
			    culong += aulong;
		    }
		}
		else
#endif
                {
		    while (len-- > 0) {
			COPY32(s, &aulong);
			s += SIZE32;
d3434 2
a3435 2
			if (datumtype == 'N')
			    aulong = PerlSock_ntohl(aulong);
d3438 2
a3439 2
			if (datumtype == 'V')
			    aulong = vtohl(aulong);
d3441 4
a3444 5
			if (checksum > 32)
			    cdouble += (NV)aulong;
			else
			    culong += aulong;
		    }
d3450 3
a3452 17
#if LONGSIZE != SIZE32
		if (unatint) {
		    unsigned long aulong;
		    while (len-- > 0) {
			COPYNN(s, &aulong, sizeof(unsigned long));
			s += sizeof(unsigned long);
			sv = NEWSV(43, 0);
			sv_setuv(sv, (UV)aulong);
			PUSHs(sv_2mortal(sv));
		    }
		}
		else
#endif
                {
		    while (len-- > 0) {
			COPY32(s, &aulong);
			s += SIZE32;
d3454 2
a3455 2
			if (datumtype == 'N')
			    aulong = PerlSock_ntohl(aulong);
d3458 2
a3459 2
			if (datumtype == 'V')
			    aulong = vtohl(aulong);
d3461 3
a3463 4
			sv = NEWSV(43, 0);
			sv_setuv(sv, (UV)aulong);
			PUSHs(sv_2mortal(sv));
		    }
d3507 1
a3507 1
			sv = Perl_newSVpvf(aTHX_ "%.*Vu", (int)TYPE_DIGITS(UV), auv);
d3525 1
a3525 1
		    DIE(aTHX_ "Unterminated compressed integer");
d3559 1
a3559 1
		    sv_setnv(sv, (NV)aquad);
d3570 1
a3570 1
		if (s + sizeof(Uquad_t) > strend)
d3573 2
a3574 2
		    Copy(s, &auquad, 1, Uquad_t);
		    s += sizeof(Uquad_t);
d3580 1
a3580 1
		    sv_setnv(sv, (NV)auquad);
d3605 1
a3605 1
		    sv_setnv(sv, (NV)afloat);
d3629 1
a3629 1
		    sv_setnv(sv, (NV)adouble);
d3640 1
a3640 1
            if (PL_uudmap['M'] == 0) {
d3643 2
a3644 2
                for (i = 0; i < sizeof(PL_uuemap); i += 1)
                    PL_uudmap[(U8)PL_uuemap[i]] = i;
d3649 1
a3649 1
                PL_uudmap[' '] = 0;
d3661 1
a3661 1
		len = PL_uudmap[*(U8*)s++] & 077;
d3664 1
a3664 1
			a = PL_uudmap[*(U8*)s++] & 077;
d3668 1
a3668 1
			b = PL_uudmap[*(U8*)s++] & 077;
d3672 1
a3672 1
			c = PL_uudmap[*(U8*)s++] & 077;
d3676 1
a3676 1
			d = PL_uudmap[*(U8*)s++] & 077;
d3696 2
a3697 2
	      (checksum > 32 && strchr("iIlLNU", datumtype)) ) {
		NV trouble;
d3713 1
a3713 1
		cdouble = Perl_modf(cdouble / adouble, &trouble) * adouble;
d3727 1
a3727 1
    if (SP - PL_stack_base == start_sp_offset && gimme == G_SCALAR)
d3733 1
a3733 1
S_doencodes(pTHX_ register SV *sv, register char *s, register I32 len)
d3737 1
a3737 1
    *hunk = PL_uuemap[len];
d3741 4
a3744 4
	hunk[0] = PL_uuemap[(077 & (*s >> 2))];
	hunk[1] = PL_uuemap[(077 & (((*s << 4) & 060) | ((s[1] >> 4) & 017)))];
	hunk[2] = PL_uuemap[(077 & (((s[1] << 2) & 074) | ((s[2] >> 6) & 03)))];
	hunk[3] = PL_uuemap[(077 & (s[2] & 077))];
d3751 4
a3754 4
	hunk[0] = PL_uuemap[(077 & (*s >> 2))];
	hunk[1] = PL_uuemap[(077 & (((*s << 4) & 060) | ((r >> 4) & 017)))];
	hunk[2] = PL_uuemap[(077 & ((r << 2) & 074))];
	hunk[3] = PL_uuemap[0];
d3760 2
a3761 2
STATIC SV *
S_is_an_int(pTHX_ char *s, STRLEN l)
d3763 2
a3764 2
  STRLEN	 n_a;
  SV             *result = newSVpvn(s, l);
a3808 1
/* pnum must be '\0' terminated */
d3810 3
a3812 1
S_div128(pTHX_ SV *pnum, bool *done)
d3862 1
a3862 1
    Uquad_t auquad;
a3867 3
#ifdef PERL_NATINT_PACK
    int natint;		/* native integer */
#endif
d3873 1
a3873 2
	SV *lengthcode = Nullsv;
#define NEXTFROM ( lengthcode ? lengthcode : items-- > 0 ? *MARK++ : &PL_sv_no)
a3874 3
#ifdef PERL_NATINT_PACK
	natint = 0;
#endif
a3876 17
	if (datumtype == '#') {
	    while (pat < patend && *pat != '\n')
		pat++;
	    continue;
	}
        if (*pat == '!') {
	    char *natstr = "sSiIlL";

	    if (strchr(natstr, datumtype)) {
#ifdef PERL_NATINT_PACK
		natint = 1;
#endif
		pat++;
	    }
	    else
		DIE(aTHX_ "'!' allowed only after types %s", natstr);
	}
d3883 1
a3883 1
	    while (isDIGIT(*pat)) {
a3884 3
		if (len < 0)
		    DIE(aTHX_ "Repeat count in pack overflows");
	    }
a3887 7
	if (*pat == '/') {
	    ++pat;
	    if ((*pat != 'a' && *pat != 'A' && *pat != 'Z') || pat[1] != '*')
		DIE(aTHX_ "/ must be followed by a*, A* or Z*");
	    lengthcode = sv_2mortal(newSViv(sv_len(items > 0
						   ? *MARK : &PL_sv_no)));
	}
d3890 1
a3890 1
	    DIE(aTHX_ "Invalid type in pack: '%c'", (int)datumtype);
d3892 2
a3893 3
	    if (commas++ == 0 && ckWARN(WARN_PACK))
		Perl_warner(aTHX_ WARN_PACK,
			    "Invalid type in pack: '%c'", (int)datumtype);
d3896 1
a3896 1
	    DIE(aTHX_ "%% may only be used in unpack");
d3908 1
a3908 1
		DIE(aTHX_ "X outside of string");
d3925 1
a3925 1
	    if (pat[-1] == '*') {
d3927 1
a3927 4
		if (datumtype == 'Z')
		    ++len;
	    }
	    if (fromlen >= len) {
a3928 3
		if (datumtype == 'Z')
		    *(SvEND(cat)-1) = '\0';
	    }
d3951 1
a3951 1
		register char *str;
d3956 1
a3956 1
		str = SvPV(fromstr, fromlen);
d3959 1
d3970 1
a3970 1
			items |= *str++ & 1;
d3981 1
a3981 1
			if (*str++ & 1)
d3998 2
a3999 2
		str = SvPVX(cat) + SvCUR(cat);
		while (aptr <= str)
d4002 1
d4009 1
a4009 1
		register char *str;
d4014 1
a4014 1
		str = SvPV(fromstr, fromlen);
d4017 1
d4028 2
a4029 2
			if (isALPHA(*str))
			    items |= ((*str++ & 15) + 9) & 15;
d4031 1
a4031 1
			    items |= *str++ & 15;
d4042 2
a4043 2
			if (isALPHA(*str))
			    items |= (((*str++ & 15) + 9) & 15) << 4;
d4045 1
a4045 1
			    items |= (*str++ & 15) << 4;
d4056 2
a4057 2
		str = SvPVX(cat) + SvCUR(cat);
		while (aptr <= str)
d4060 1
a4072 10
	case 'U':
	    while (len-- > 0) {
		fromstr = NEXTFROM;
		auint = SvUV(fromstr);
		SvGROW(cat, SvCUR(cat) + UTF8_MAXLEN);
		SvCUR_set(cat, (char*)uv_to_utf8((U8*)SvEND(cat),auint)
			       - SvPVX(cat));
	    }
	    *SvEND(cat) = '\0';
	    break;
a4110 23
#if SHORTSIZE != SIZE16
	    if (natint) {
		unsigned short aushort;

		while (len-- > 0) {
		    fromstr = NEXTFROM;
		    aushort = SvUV(fromstr);
		    sv_catpvn(cat, (char *)&aushort, sizeof(unsigned short));
		}
	    }
	    else
#endif
            {
		U16 aushort;

		while (len-- > 0) {
		    fromstr = NEXTFROM;
		    aushort = (U16)SvUV(fromstr);
		    CAT16(cat, &aushort);
		}

	    }
	    break;
d4112 4
a4115 18
#if SHORTSIZE != SIZE16
	    if (natint) {
		short ashort;

		while (len-- > 0) {
		    fromstr = NEXTFROM;
		    ashort = SvIV(fromstr);
		    sv_catpvn(cat, (char *)&ashort, sizeof(short));
		}
	    }
	    else
#endif
            {
		while (len-- > 0) {
		    fromstr = NEXTFROM;
		    ashort = (I16)SvIV(fromstr);
		    CAT16(cat, &ashort);
		}
d4128 1
a4128 1
		adouble = Perl_floor(SvNV(fromstr));
d4131 1
a4131 1
		    DIE(aTHX_ "Cannot compress negative numbers");
d4134 3
d4142 1
d4147 1
a4147 1
		    UV     auv = U_V(adouble);
d4165 1
a4165 1
			DIE(aTHX_ "can compress only unsigned integer");
d4185 1
a4185 1
			    DIE(aTHX_ "Cannot compress integer");
d4192 1
a4192 1
		    DIE(aTHX_ "Cannot compress non integer");
d4223 4
a4226 18
#if LONGSIZE != SIZE32
	    if (natint) {
		unsigned long aulong;

		while (len-- > 0) {
		    fromstr = NEXTFROM;
		    aulong = SvUV(fromstr);
		    sv_catpvn(cat, (char *)&aulong, sizeof(unsigned long));
		}
	    }
	    else
#endif
            {
		while (len-- > 0) {
		    fromstr = NEXTFROM;
		    aulong = SvUV(fromstr);
		    CAT32(cat, &aulong);
		}
d4230 4
a4233 18
#if LONGSIZE != SIZE32
	    if (natint) {
		long along;

		while (len-- > 0) {
		    fromstr = NEXTFROM;
		    along = SvIV(fromstr);
		    sv_catpvn(cat, (char *)&along, sizeof(long));
		}
	    }
	    else
#endif
            {
		while (len-- > 0) {
		    fromstr = NEXTFROM;
		    along = SvIV(fromstr);
		    CAT32(cat, &along);
		}
d4240 2
a4241 2
		auquad = (Uquad_t)SvUV(fromstr);
		sv_catpvn(cat, (char*)&auquad, sizeof(Uquad_t));
d4251 1
a4251 1
#endif
d4267 2
a4268 7
		    if (ckWARN(WARN_PACK) && (SvTEMP(fromstr)
						|| (SvPADTMP(fromstr)
						    && !SvREADONLY(fromstr))))
		    {
			Perl_warner(aTHX_ WARN_PACK,
				"Attempt to pack pointer to temporary value");
		    }
d4339 1
a4339 1
	DIE(aTHX_ "panic: do_split");
d4345 1
a4345 4
    if (pm->op_pmreplroot) {
#ifdef USE_ITHREADS
	ary = GvAVn((GV*)PL_curpad[(PADOFFSET)pm->op_pmreplroot]);
#else
a4346 2
#endif
    }
d4361 1
a4361 1
	if ((mg = SvTIED_mg((SV*)ary, 'P'))) {
a4367 1
		AvREIFY_off(ary);
d4433 1
a4433 1
    else if ((rx->reganch & RE_USE_INTUIT) && !rx->nparens
d4436 3
a4438 7
	int tail = (rx->reganch & RE_INTUIT_TAIL);
	SV *csv = CALLREG_INTUIT_STRING(aTHX_ rx);
	char c;

	len = rx->minlen;
	if (len == 1 && !tail) {
	    c = *SvPV(csv,len);
d4441 1
a4441 1
		for (m = s; m < strend && *m != c; m++) ;
d4455 2
a4456 2
	      (m = fbm_instr((unsigned char*)s, (unsigned char*)strend,
			     csv, PL_multiline ? FBMrf_MULTILINE : 0)) )
d4464 1
a4464 1
		s = m + len;		/* Fake \n at the end */
d4470 2
a4471 6
	while (s < strend && --limit
/*	       && (!rx->check_substr 
		   || ((s = CALLREG_INTUIT_START(aTHX_ rx, sv, s, strend,
						 0, NULL))))
*/	       && CALLREGEXEC(aTHX_ rx, s, strend, orig,
			      1 /* minend */, sv, NULL, 0))
d4474 2
a4475 1
	    if (RX_MATCH_COPIED(rx) && rx->subbeg != orig) {
d4478 1
a4478 1
		orig = rx->subbeg;
d4482 1
a4482 1
	    m = rx->startp[0] + orig;
d4490 2
a4491 2
		    s = rx->startp[i] + orig;
		    m = rx->endp[i] + orig;
d4503 1
a4503 1
	    s = rx->endp[0] + orig;
d4510 1
a4510 1
	DIE(aTHX_ "Split loop");
d4544 1
a4544 1
	    call_method("PUSH",G_SCALAR|G_DISCARD);
d4572 1
a4572 1
Perl_unlock_condpair(pTHX_ void *svv)
d4578 1
a4578 1
	Perl_croak(aTHX_ "panic: unlock_condpair unlocking non-mutex");
d4581 1
a4581 1
	Perl_croak(aTHX_ "panic: unlock_condpair unlocking mutex that we don't own");
d4584 2
a4585 2
    DEBUG_S(PerlIO_printf(Perl_debug_log, "0x%"UVxf": unlock 0x%"UVxf"\n",
			  PTR2UV(thr), PTR2UV(svv));)
d4609 2
a4610 2
	DEBUG_S(PerlIO_printf(Perl_debug_log, "0x%"UVxf": pp_lock lock 0x%"UVxf"\n",
			      PTR2UV(thr), PTR2UV(sv));)
d4612 1
a4612 1
	SAVEDESTRUCTOR_X(Perl_unlock_condpair, sv);
d4625 1
a4626 1
    djSP;
d4634 1
a4634 1
    DIE(aTHX_ "tried to access per-thread data in non-threaded perl");
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2001, Larry Wall
d85 4
d99 1
a99 1
    dSP;
d114 1
a114 1
    dSP; dTARGET;
a120 5
    } else if (LVRET) {
	if (GIMME == G_SCALAR)
	    Perl_croak(aTHX_ "Can't return array to lvalue scalar context");
	PUSHs(TARG);
	RETURN;
d148 1
a148 1
    dSP; dTARGET;
a155 5
    else if (LVRET) {
	if (GIMME == G_SCALAR)
	    Perl_croak(aTHX_ "Can't return hash to lvalue scalar context");
	RETURN;
    }
d181 1
a181 1
    dSP; dTOPss;
d201 1
a201 1
	    STRLEN len;
d239 1
a239 1
	    sym = SvPV(sv,len);
d244 1
a244 4
		if (!sv
		    && (!is_gv_magical(sym,len,0)
			|| !(sv = (SV*)gv_fetchpv(sym, TRUE, SVt_PVGV))))
		{
a245 1
		}
d262 1
a262 1
    dSP; dTOPss;
d279 1
a279 1
	STRLEN len;
d295 1
a295 1
	    sym = SvPV(sv, len);
d300 1
a300 4
		if (!gv
		    && (!is_gv_magical(sym,len,0)
			|| !(gv = (GV*)gv_fetchpv(sym, TRUE, SVt_PV))))
		{
a301 1
		}
d323 1
a323 1
    dSP;
d337 1
a337 1
    dSP; dTARGET; dPOPss;
d339 1
a339 1
    if (PL_op->op_flags & OPf_MOD || LVRET) {
d373 1
a373 1
    dSP;
d383 2
a384 6
	if ((PL_op->op_private & OPpLVAL_INTRO)) {
	    if (gv && GvCV(gv) == cv && (gv = gv_autoload4(GvSTASH(gv), GvNAME(gv), GvNAMELEN(gv), FALSE)))
		cv = GvCV(gv);
	    if (!CvLVALUE(cv))
		DIE(aTHX_ "Can't modify non-lvalue subroutine call");
	}
d394 1
a394 1
    dSP;
d460 1
a460 1
    dSP;
d471 1
a471 1
    dSP;
d478 1
a478 1
    dSP; dMARK;
d528 1
a528 1
    dSP; dTARGET;
d548 1
a548 1
    dSP;
d573 1
a573 1
    dSP;
d634 1
a634 1
    dSP; dPOPss;
d696 1
a696 1
    dSP; dTARG;
d714 1
a714 1
    dSP; dTARGET;
d722 3
a724 4
    dSP; dMARK; dTARGET; dORIGMARK;
    while (MARK < SP)
	do_chop(TARG, *++MARK);
    SP = ORIGMARK;
d731 1
a731 1
    dSP; dTARGET;
d738 1
a738 1
    dSP; dMARK; dTARGET;
d749 1
a749 1
    dSP;
d779 1
a779 1
    dSP;
d811 1
a811 1
	    GV* gv = CvGV((CV*)sv);
d846 1
a846 1
    dSP;
d863 1
a863 1
    dSP; dTARGET;
d884 1
a884 1
    dSP; dTARGET;
d905 1
a905 1
    dSP; dATARGET; tryAMAGICbin(pow,opASSIGN);
d915 1
a915 1
    dSP; dATARGET; tryAMAGICbin(mult,opASSIGN);
d925 1
a925 1
    dSP; dATARGET; tryAMAGICbin(div,opASSIGN);
d954 1
a954 1
    dSP; dATARGET; tryAMAGICbin(modulo,opASSIGN);
d964 1
a964 1
	if (SvIOK_notUV(TOPs) && !SvNOK(TOPs) && !SvPOK(TOPs)) {
d976 1
a976 1
	if (!use_double && SvIOK_notUV(TOPs) && !SvNOK(TOPs) && !SvPOK(TOPs)) {
d1054 1
a1054 1
  dSP; dATARGET; tryAMAGICbin(repeat,opASSIGN);
d1056 1
a1056 1
    register IV count = POPi;
d1079 1
a1079 1
	SV *tmpstr = POPs;
a1080 1
	bool isutf;
d1082 1
a1084 1
	isutf = DO_UTF8(TARG);
d1095 1
a1095 4
	if (isutf)
	    (void)SvPOK_only_UTF8(TARG);
	else
	    (void)SvPOK_only(TARG);
d1104 1
a1104 1
    dSP; dATARGET; tryAMAGICbin(subtr,opASSIGN);
d1114 1
a1114 1
    dSP; dATARGET; tryAMAGICbin(lshift,opASSIGN);
d1131 1
a1131 1
    dSP; dATARGET; tryAMAGICbin(rshift,opASSIGN);
d1148 1
a1148 1
    dSP; tryAMAGICbinSET(lt,0);
d1158 1
a1158 1
    dSP; tryAMAGICbinSET(gt,0);
d1168 1
a1168 1
    dSP; tryAMAGICbinSET(le,0);
d1178 1
a1178 1
    dSP; tryAMAGICbinSET(ge,0);
d1188 1
a1188 1
    dSP; tryAMAGICbinSET(ne,0);
d1198 1
a1198 1
    dSP; dTARGET; tryAMAGICbin(ncmp,0);
d1202 7
d1210 1
a1210 1
#ifdef Perl_isnan
d1235 1
a1235 1
    dSP; tryAMAGICbinSET(slt,0);
d1248 1
a1248 1
    dSP; tryAMAGICbinSET(sgt,0);
d1261 1
a1261 1
    dSP; tryAMAGICbinSET(sle,0);
d1274 1
a1274 1
    dSP; tryAMAGICbinSET(sge,0);
d1287 1
a1287 1
    dSP; tryAMAGICbinSET(seq,0);
d1297 1
a1297 1
    dSP; tryAMAGICbinSET(sne,0);
d1307 1
a1307 1
    dSP; dTARGET;  tryAMAGICbin(scmp,0);
d1320 1
a1320 1
    dSP; dATARGET; tryAMAGICbin(band,opASSIGN);
d1343 1
a1343 1
    dSP; dATARGET; tryAMAGICbin(bxor,opASSIGN);
d1366 1
a1366 1
    dSP; dATARGET; tryAMAGICbin(bor,opASSIGN);
d1389 1
a1389 1
    dSP; dTARGET; tryAMAGICun(neg);
d1423 1
a1423 1
	    else if (DO_UTF8(sv) && UTF8_IS_START(*s) && isIDFIRST_utf8((U8*)s)) {
d1439 1
a1439 1
    dSP; tryAMAGICunSET(not);
d1446 1
a1446 1
    dSP; dTARGET; tryAMAGICun(compl);
d1460 2
a1461 1
	register U8 *tmps;
d1466 1
a1466 1
	tmps = (U8*)SvPV_force(TARG, len);
a1467 49
	if (SvUTF8(TARG)) {
	  /* Calculate exact length, let's not estimate. */
	  STRLEN targlen = 0;
	  U8 *result;
	  U8 *send;
	  STRLEN l;
	  UV nchar = 0;
	  UV nwide = 0;

	  send = tmps + len;
	  while (tmps < send) {
	    UV c = utf8_to_uv(tmps, send-tmps, &l, UTF8_ALLOW_ANYUV);
	    tmps += UTF8SKIP(tmps);
	    targlen += UNISKIP(~c);
	    nchar++;
	    if (c > 0xff)
		nwide++;
	  }

	  /* Now rewind strings and write them. */
	  tmps -= len;

	  if (nwide) {
	      Newz(0, result, targlen + 1, U8);
	      while (tmps < send) {
		  UV c = utf8_to_uv(tmps, send-tmps, &l, UTF8_ALLOW_ANYUV);
		  tmps += UTF8SKIP(tmps);
		  result = uv_to_utf8(result, ~c);
	      }
	      *result = '\0';
	      result -= targlen;
	      sv_setpvn(TARG, (char*)result, targlen);
	      SvUTF8_on(TARG);
	  }
	  else {
	      Newz(0, result, nchar + 1, U8);
	      while (tmps < send) {
		  U8 c = (U8)utf8_to_uv(tmps, 0, &l, UTF8_ALLOW_ANY);
		  tmps += UTF8SKIP(tmps);
		  *result++ = ~c;
	      }
	      *result = '\0';
	      result -= nchar;
	      sv_setpvn(TARG, (char*)result, nchar);
	  }
	  Safefree(result);
	  SETs(TARG);
	  RETURN;
	}
d1469 6
a1474 9
	{
	    register long *tmpl;
	    for ( ; anum && (unsigned long)tmps % sizeof(long); anum--, tmps++)
		*tmps = ~*tmps;
	    tmpl = (long*)tmps;
	    for ( ; anum >= sizeof(long); anum -= sizeof(long), tmpl++)
		*tmpl = ~*tmpl;
	    tmps = (U8*)tmpl;
	}
d1489 1
a1489 1
    dSP; dATARGET; tryAMAGICbin(mult,opASSIGN);
d1499 1
a1499 1
    dSP; dATARGET; tryAMAGICbin(div,opASSIGN);
d1512 1
a1512 1
    dSP; dATARGET; tryAMAGICbin(modulo,opASSIGN);
d1524 1
a1524 1
    dSP; dATARGET; tryAMAGICbin(add,opASSIGN);
d1526 1
a1526 1
      dPOPTOPiirl_ul;
d1534 1
a1534 1
    dSP; dATARGET; tryAMAGICbin(subtr,opASSIGN);
d1536 1
a1536 1
      dPOPTOPiirl_ul;
d1544 1
a1544 1
    dSP; tryAMAGICbinSET(lt,0);
d1554 1
a1554 1
    dSP; tryAMAGICbinSET(gt,0);
d1564 1
a1564 1
    dSP; tryAMAGICbinSET(le,0);
d1574 1
a1574 1
    dSP; tryAMAGICbinSET(ge,0);
d1584 1
a1584 1
    dSP; tryAMAGICbinSET(eq,0);
d1594 1
a1594 1
    dSP; tryAMAGICbinSET(ne,0);
d1604 1
a1604 1
    dSP; dTARGET; tryAMAGICbin(ncmp,0);
d1622 1
a1622 1
    dSP; dTARGET; tryAMAGICun(neg);
d1631 1
a1631 1
    dSP; dTARGET; tryAMAGICbin(atan2,0);
d1641 1
a1641 1
    dSP; dTARGET; tryAMAGICun(sin);
d1653 1
a1653 1
    dSP; dTARGET; tryAMAGICun(cos);
d1680 1
a1680 1
    dSP; dTARGET;
d1699 1
a1699 1
    dSP;
d1736 1
d1795 1
a1795 1
    dSP; dTARGET; tryAMAGICun(exp);
d1807 1
a1807 1
    dSP; dTARGET; tryAMAGICun(log);
d1812 1
a1812 1
	SET_NUMERIC_STANDARD();
d1823 1
a1823 1
    dSP; dTARGET; tryAMAGICun(sqrt);
d1828 1
a1828 1
	SET_NUMERIC_STANDARD();
d1839 1
a1839 1
    dSP; dTARGET;
d1849 2
a1850 9
	  if (value >= 0.0) {
#if defined(HAS_MODFL) || defined(LONG_DOUBLE_EQUALS_DOUBLE)
	      (void)Perl_modf(value, &value);
#else
	      double tmp = (double)value;
	      (void)Perl_modf(tmp, &tmp);
	      value = (NV)tmp;
#endif
	  }
d1852 2
a1853 8
#if defined(HAS_MODFL) || defined(LONG_DOUBLE_EQUALS_DOUBLE)
	    (void)Perl_modf(-value, &value);
	    value = -value;
#else
	    double tmp = (double)value;
	    (void)Perl_modf(-tmp, &tmp);
	    value = -(NV)tmp;
#endif
d1867 1
a1867 1
    dSP; dTARGET; tryAMAGICun(abs);
d1889 1
a1889 1
    dSP; dTARGET;
d1891 2
a1892 2
    STRLEN argtype;
    STRLEN len;
d1894 2
a1895 3
    tmps = (SvPVx(POPs, len));
    argtype = 1;		/* allow underscores */
    XPUSHn(scan_hex(tmps, len, &argtype));
d1901 1
a1901 1
    dSP; dTARGET;
d1903 1
a1903 1
    STRLEN argtype;
d1905 1
a1905 1
    STRLEN len;
d1907 3
a1909 3
    tmps = (SvPVx(POPs, len));
    while (*tmps && len && isSPACE(*tmps))
       tmps++, len--;
d1911 1
a1911 2
       tmps++, len--;
    argtype = 1;		/* allow underscores */
d1913 1
a1913 1
       value = scan_hex(++tmps, --len, &argtype);
d1915 1
a1915 1
       value = scan_bin(++tmps, --len, &argtype);
d1917 1
a1917 1
       value = scan_oct(tmps, len, &argtype);
d1926 1
a1926 1
    dSP; dTARGET;
d1938 1
a1938 1
    dSP; dTARGET;
d1942 1
a1942 1
    STRLEN utf8_curlen;
d1946 1
a1946 1
    I32 lvalue = PL_op->op_flags & OPf_MOD || LVRET;
a1948 1
    SV *repl_sv = NULL;
a1950 3
    int num_args = PL_op->op_private & 7;
    bool repl_need_utf8_upgrade = FALSE;
    bool repl_is_utf8 = FALSE;
d1954 4
a1957 5
    if (num_args > 2) {
	if (num_args > 3) {
	    repl_sv = POPs;
	    repl = SvPV(repl_sv, repl_len);
	    repl_is_utf8 = DO_UTF8(repl_sv) && SvCUR(repl_sv);
a1963 8
    if (repl_sv) {
	if (repl_is_utf8) {
	    if (!DO_UTF8(sv))
		sv_utf8_upgrade(sv);
	}
	else if (DO_UTF8(sv))
	    repl_need_utf8_upgrade = TRUE;
    }
d1966 3
a1968 3
        utf8_curlen = sv_len_utf8(sv);
	if (utf8_curlen == curlen)
	    utf8_curlen = 0;
d1970 1
a1970 1
	    curlen = utf8_curlen;
d1973 1
a1973 1
	utf8_curlen = 0;
d1979 1
a1979 1
	if (num_args > 2) {
d1991 1
a1991 1
	if (num_args < 3)
d2016 1
a2016 3
	I32 upos = pos;
	I32 urem = rem;
	if (utf8_curlen)
d2018 2
d2022 1
a2022 11
	if (utf8_curlen)
	    SvUTF8_on(TARG);
	if (repl) {
	    SV* repl_sv_copy = NULL;

	    if (repl_need_utf8_upgrade) {
		repl_sv_copy = newSVsv(repl_sv);
		sv_utf8_upgrade(repl_sv_copy);
		repl = SvPV(repl_sv_copy, repl_len);
		repl_is_utf8 = DO_UTF8(repl_sv_copy) && SvCUR(sv);
	    }
a2023 5
	    if (repl_is_utf8)
		SvUTF8_on(sv);
	    if (repl_sv_copy)
		SvREFCNT_dec(repl_sv_copy);
	}
d2034 1
a2034 1
		    (void)SvPOK_only_UTF8(sv);
d2050 2
a2051 2
	    LvTARGOFF(TARG) = upos;
	    LvTARGLEN(TARG) = urem;
d2061 3
a2063 3
    dSP; dTARGET;
    register IV size   = POPi;
    register IV offset = POPi;
d2065 1
a2065 1
    I32 lvalue = PL_op->op_flags & OPf_MOD || LVRET;
d2090 1
a2090 1
    dSP; dTARGET;
d2126 1
a2126 1
    dSP; dTARGET;
d2167 1
a2167 1
    dSP; dMARK; dORIGMARK; dTARGET;
d2177 6
a2182 4
    dSP; dTARGET;
    SV *argsv = POPs;
    STRLEN len;
    U8 *s = (U8*)SvPVx(argsv, len);
d2184 5
a2188 1
    XPUSHu(DO_UTF8(argsv) ? utf8_to_uv_simple(s, 0) : (*s & 0xff));
d2194 1
a2194 1
    dSP; dTARGET;
d2196 1
a2196 1
    UV value = POPu;
d2217 1
d2225 1
a2225 1
    dSP; dTARGET; dPOPTOPssrl;
d2244 1
a2244 1
    dSP;
d2249 3
a2251 3
    if (DO_UTF8(sv) && (s = (U8*)SvPV(sv, slen)) && slen && UTF8_IS_START(*s)) {
	STRLEN ulen;
	U8 tmpbuf[UTF8_MAXLEN+1];
d2253 1
a2253 1
	UV uv = utf8_to_uv(s, slen, &ulen, 0);
d2303 1
a2303 1
    dSP;
d2308 3
a2310 3
    if (DO_UTF8(sv) && (s = (U8*)SvPV(sv, slen)) && slen && UTF8_IS_START(*s)) {
	STRLEN ulen;
	U8 tmpbuf[UTF8_MAXLEN+1];
d2312 1
a2312 1
	UV uv = utf8_to_uv(s, slen, &ulen, 0);
d2362 1
a2362 1
    dSP;
d2369 1
a2369 1
	STRLEN ulen;
d2389 1
a2389 1
		    d = uv_to_utf8(d, toUPPER_LC_uni( utf8_to_uv(s, len, &ulen, 0)));
d2436 1
a2436 1
    dSP;
d2443 1
a2443 1
	STRLEN ulen;
d2463 1
a2463 1
		    d = uv_to_utf8(d, toLOWER_LC_uni( utf8_to_uv(s, len, &ulen, 0)));
d2511 1
a2511 1
    dSP; dTARGET;
d2524 1
a2524 1
		if (UTF8_IS_CONTINUED(*s)) {
d2550 1
a2550 1
	(void)SvPOK_only_UTF8(TARG);
d2564 1
a2564 1
    dSP; dMARK; dORIGMARK;
d2567 1
a2567 1
    register I32 lval = (PL_op->op_flags & OPf_MOD || LVRET);
d2609 1
a2609 1
    dSP;
d2651 1
a2651 1
    dSP;
d2715 1
a2715 1
    dSP;
d2752 1
a2752 1
    dSP; dMARK; dORIGMARK;
d2754 1
a2754 1
    register I32 lval = (PL_op->op_flags & OPf_MOD || LVRET);
d2794 1
a2794 1
    dSP; dMARK;
d2807 1
a2807 1
    dSP;
d2862 1
a2862 1
    dSP; dMARK; dORIGMARK;
d2872 1
a2872 1
    dSP; dMARK; dORIGMARK;
d2891 1
a2891 1
    dSP; dMARK; dORIGMARK;
d3093 1
a3093 1
    dSP; dMARK; dORIGMARK; dTARGET;
d3123 1
a3123 1
    dSP;
d3134 1
a3134 1
    dSP;
d3148 1
a3148 1
    dSP; dMARK; dORIGMARK; dTARGET;
d3178 1
a3178 1
    dSP; dMARK;
d3210 1
a3210 1
		    if (UTF8_IS_ASCII(*s)) {
a3214 2
			if (!utf8_to_uv_simple(s, 0))
			    break;
d3218 6
a3223 1
			/* reverse this character */
d3239 1
a3239 1
	    (void)SvPOK_only_UTF8(TARG);
d3289 1
a3289 1
    dSP;
d3307 1
a3307 1
    short ashort;
d3309 1
a3309 1
    long along;
d3605 1
a3605 3
		    STRLEN alen;
		    auint = utf8_to_uv((U8*)s, strend - s, &alen, 0);
		    along = alen;
d3617 1
a3617 3
		    STRLEN alen;
		    auint = utf8_to_uv((U8*)s, strend - s, &alen, 0);
		    along = alen;
d3858 1
a3871 3
#if LONGSIZE > SIZE32 && INTSIZE == SIZE32
			I32 along;
#endif
d3890 1
a3902 3
#if LONGSIZE > SIZE32 && INTSIZE == SIZE32
			I32 along;
#endif
d4024 1
a4024 1
		    if (UTF8_IS_ASCII(*s++)) {
d4036 1
a4036 1
			sv = Perl_newSVpvf(aTHX_ "%.*"UVf, (int)TYPE_DIGITS(UV), auv);
d4368 1
a4368 1
    dSP; dMARK; dORIGMARK; dTARGET;
a4372 1
    char *patcopy;
a4402 1
    patcopy = pat;
d4410 1
a4410 2
	if (isSPACE(datumtype)) {
	    patcopy++;
a4411 3
        }
	if (datumtype == 'U' && pat == patcopy+1) 
	    SvUTF8_on(cat);
d4448 1
a4448 2
						   ? *MARK : &PL_sv_no)
                                            + (*pat == 'Z' ? 1 : 0)));
d4642 1
a4642 1
		SvGROW(cat, SvCUR(cat) + UTF8_MAXLEN + 1);
d4746 2
a4747 2
#if UVSIZE > 4 && UVSIZE >= NVSIZE
		    adouble <= 0xffffffff
a4748 3
#   ifdef CXUX_BROKEN_CONSTANT_CONVERT
		    adouble <= UV_MAX_cxux
#   else
a4749 1
#   endif
d4792 1
a4792 1
			if (in <= buf)  /* this cannot happen ;-) */
a4793 1
			in--;
d4950 1
a4950 1
    dSP; dTARG;
d4952 1
a4952 1
    register IV limit = POPi;			/* note, negative is forever */
a4955 1
    bool do_utf8 = DO_UTF8(sv);
d4962 1
a4962 2
    STRLEN slen = do_utf8 ? utf8_length((U8*)s, (U8*)strend) : (strend - s);
    I32 maxiters = slen + 10;
d4980 1
a4980 1
	DIE(aTHX_ "panic: pp_split");
a5055 2
	    if (do_utf8)
		(void)SvUTF8_on(dstr);
a5075 2
	    if (do_utf8)
		(void)SvUTF8_on(dstr);
d5085 1
d5088 2
a5089 3
	if (len == 1 && !(rx->reganch & ROPT_UTF8) && !tail) {
	    STRLEN n_a;
	    char c = *SvPV(csv, n_a);
a5098 2
		if (do_utf8)
		    (void)SvUTF8_on(dstr);
d5100 1
a5100 6
		/* The rx->minlen is in characters but we want to step
		 * s ahead by bytes. */
 		if (do_utf8)
		    s = (char*)utf8_hop((U8*)m, len);
 		else
		    s = m + len; /* Fake \n at the end */
a5113 2
		if (do_utf8)
		    (void)SvUTF8_on(dstr);
d5115 1
a5115 6
		/* The rx->minlen is in characters but we want to step
		 * s ahead by bytes. */
 		if (do_utf8)
		    s = (char*)utf8_hop((U8*)m, len);
 		else
		    s = m + len; /* Fake \n at the end */
d5120 1
a5120 1
	maxiters += slen * rx->nparens;
a5140 2
	    if (do_utf8)
		(void)SvUTF8_on(dstr);
a5153 2
		    if (do_utf8)
			(void)SvUTF8_on(dstr);
d5168 2
a5169 3
        STRLEN l = strend - s;
	dstr = NEWSV(34, l);
	sv_setpvn(dstr, s, l);
a5171 2
	if (do_utf8)
	    (void)SvUTF8_on(dstr);
d5228 1
d5246 1
a5246 1
    dSP;
d5250 18
a5267 1
    sv_lock(sv);
d5280 1
a5280 1
    dSP;
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2002, Larry Wall
a17 1
#include "keywords.h"
d19 63
a81 1
#include "reentr.h"
d128 1
a128 1
	    for (i=0; i < (U32)maxarg; i++) {
d215 1
a215 1
		/* If this is a 'my' scalar and flag is set then vivify
d217 1
a217 1
		 */
d232 1
a232 2
		    if (SvTYPE(sv) < SVt_RV)
			sv_upgrade(sv, SVt_RV);
d343 1
a343 1
	sv_magic(sv, (SV*)av, PERL_MAGIC_arylen, Nullch, 0);
d356 1
a356 1
	    sv_magic(TARG, Nullsv, PERL_MAGIC_pos, Nullch, 0);
d372 1
a372 1
	    mg = mg_find(sv, PERL_MAGIC_regex_global);
d423 1
a423 1
	
a430 2
		if (code == -KEY_chop || code == -KEY_chomp)
		    goto set;
d443 1
a443 1
		    if (oa & OA_OPTIONAL && !seen_question) {
d447 1
a447 1
		    else if (n && str[0] == ';' && seen_question)
d449 2
a450 5
		    if ((oa & (OA_OPTIONAL - 1)) >= OA_AVREF
			&& (oa & (OA_OPTIONAL - 1)) <= OA_SCALARREF
			/* But globs are already references (kinda) */
			&& (oa & (OA_OPTIONAL - 1)) != OA_FILEREF
		    ) {
d453 1
d531 2
a532 2
    else if (SvPADTMP(sv) && !IS_PADGV(sv))
        sv = newSVsv(sv);
d574 1
a574 5
	char *ptr;

	if (ssv && !SvGMAGICAL(ssv) && !SvAMAGIC(ssv) && SvROK(ssv))
	    Perl_croak(aTHX_ "Attempt to bless into a reference");
	ptr = SvPV(ssv,len);
d576 1
a576 1
	    Perl_warner(aTHX_ packWARN(WARN_MISC),
d593 1
a593 1

d610 1
a610 3
	if (strEQ(elem, "FILEHANDLE")) {
	    /* finally deprecated in 5.8.0 */
	    deprecate("*glob{FILEHANDLE}");
a611 4
	}
	else
	if (strEQ(elem, "FORMAT"))
	    tmpRef = (SV*)GvFORM(gv);
d708 1
a708 2
    /* piggyback on m//g magic */
    sv_magic(sv, Nullsv, PERL_MAGIC_regex_global, Nullch, 0);
d776 1
a776 2
	if (AvMAX(sv) >= 0 || SvGMAGICAL(sv)
		|| (SvRMAGICAL(sv) && mg_find(sv, PERL_MAGIC_tied)))
d780 1
a780 2
	if (HvARRAY(sv) || SvGMAGICAL(sv)
		|| (SvRMAGICAL(sv) && mg_find(sv, PERL_MAGIC_tied)))
d824 1
a824 1
	    Perl_warner(aTHX_ packWARN(WARN_MISC), "Constant subroutine %s undefined",
d866 1
a866 1
    if (SvTYPE(TOPs) > SVt_PVLV)
d868 2
a869 2
    if (!SvREADONLY(TOPs) && SvIOK_notUV(TOPs) && !SvNOK(TOPs) && !SvPOK(TOPs)
        && SvIVX(TOPs) != IV_MIN)
d883 1
a883 1
    if (SvTYPE(TOPs) > SVt_PVLV)
d886 2
a887 2
    if (!SvREADONLY(TOPs) && SvIOK_notUV(TOPs) && !SvNOK(TOPs) && !SvPOK(TOPs)
        && SvIVX(TOPs) != IV_MAX)
d904 1
a904 1
    if (SvTYPE(TOPs) > SVt_PVLV)
d907 2
a908 2
    if (!SvREADONLY(TOPs) && SvIOK_notUV(TOPs) && !SvNOK(TOPs) && !SvPOK(TOPs)
        && SvIVX(TOPs) != IV_MIN)
a924 90
#ifdef PERL_PRESERVE_IVUV
    /* ** is implemented with pow. pow is floating point. Perl programmers
       write 2 ** 31 and expect it to be 2147483648
       pow never made any guarantee to deliver a result to 53 (or whatever)
       bits of accuracy. Which is unfortunate, as perl programmers expect it
       to, and on some platforms (eg Irix with long doubles) it doesn't in
       a very visible case. (2 ** 31, which a regression test uses)
       So we'll implement power-of-2 ** +ve integer with multiplies, to avoid
       these problems.  */
    {
        SvIV_please(TOPm1s);
        if (SvIOK(TOPm1s)) {
            bool baseuok = SvUOK(TOPm1s);
            UV baseuv;

            if (baseuok) {
                baseuv = SvUVX(TOPm1s);
            } else {
                IV iv = SvIVX(TOPm1s);
                if (iv >= 0) {
                    baseuv = iv;
                    baseuok = TRUE; /* effectively it's a UV now */
                } else {
                    baseuv = -iv; /* abs, baseuok == false records sign */
                }
            }
            SvIV_please(TOPs);
            if (SvIOK(TOPs)) {
                UV power;

                if (SvUOK(TOPs)) {
                    power = SvUVX(TOPs);
                } else {
                    IV iv = SvIVX(TOPs);
                    if (iv >= 0) {
                        power = iv;
                    } else {
                        goto float_it; /* Can't do negative powers this way.  */
                    }
                }
                /* now we have integer ** positive integer.
                   foo & (foo - 1) is zero only for a power of 2.  */
                if (!(baseuv & (baseuv - 1))) {
                    /* We are raising power-of-2 to postive integer.
                       The logic here will work for any base (even non-integer
                       bases) but it can be less accurate than
                       pow (base,power) or exp (power * log (base)) when the
                       intermediate values start to spill out of the mantissa.
                       With powers of 2 we know this can't happen.
                       And powers of 2 are the favourite thing for perl
                       programmers to notice ** not doing what they mean. */
                    NV result = 1.0;
                    NV base = baseuok ? baseuv : -(NV)baseuv;
                    int n = 0;

                    /* The logic is this.
                       x ** n === x ** m1 * x ** m2 where n = m1 + m2
                       so as 42 is 32 + 8 + 2
                       x ** 42 can be written as
                       x ** 32 * x ** 8 * x ** 2
                       I can calculate x ** 2, x ** 4, x ** 8 etc trivially:
                       x ** 2n is x ** n * x ** n
                       So I loop round, squaring x each time
                       (x, x ** 2, x ** 4, x ** 8) and multiply the result
                       by the x-value whenever that bit is set in the power.
                       To finish as soon as possible I zero bits in the power
                       when I've done them, so that power becomes zero when
                       I clear the last bit (no more to do), and the loop
                       terminates.  */
                    for (; power; base *= base, n++) {
                        /* Do I look like I trust gcc with long longs here?
                           Do I hell.  */
                        UV bit = (UV)1 << (UV)n;
                        if (power & bit) {
                            result *= base;
                            /* Only bother to clear the bit if it is set.  */
                            power &= ~bit;
                           /* Avoid squaring base again if we're done. */
                           if (power == 0) break;
                        }
                    }
                    SP--;
                    SETn( result );
                    RETURN;
                }
            }
        }
    }
      float_it:
#endif    
d926 3
a928 3
        dPOPTOPnnrl;
        SETn( Perl_pow( left, right) );
        RETURN;
a934 108
#ifdef PERL_PRESERVE_IVUV
    SvIV_please(TOPs);
    if (SvIOK(TOPs)) {
	/* Unless the left argument is integer in range we are going to have to
	   use NV maths. Hence only attempt to coerce the right argument if
	   we know the left is integer.  */
	/* Left operand is defined, so is it IV? */
	SvIV_please(TOPm1s);
	if (SvIOK(TOPm1s)) {
	    bool auvok = SvUOK(TOPm1s);
	    bool buvok = SvUOK(TOPs);
	    const UV topmask = (~ (UV)0) << (4 * sizeof (UV));
	    const UV botmask = ~((~ (UV)0) << (4 * sizeof (UV)));
	    UV alow;
	    UV ahigh;
	    UV blow;
	    UV bhigh;

	    if (auvok) {
		alow = SvUVX(TOPm1s);
	    } else {
		IV aiv = SvIVX(TOPm1s);
		if (aiv >= 0) {
		    alow = aiv;
		    auvok = TRUE; /* effectively it's a UV now */
		} else {
		    alow = -aiv; /* abs, auvok == false records sign */
		}
	    }
	    if (buvok) {
		blow = SvUVX(TOPs);
	    } else {
		IV biv = SvIVX(TOPs);
		if (biv >= 0) {
		    blow = biv;
		    buvok = TRUE; /* effectively it's a UV now */
		} else {
		    blow = -biv; /* abs, buvok == false records sign */
		}
	    }

	    /* If this does sign extension on unsigned it's time for plan B  */
	    ahigh = alow >> (4 * sizeof (UV));
	    alow &= botmask;
	    bhigh = blow >> (4 * sizeof (UV));
	    blow &= botmask;
	    if (ahigh && bhigh) {
		/* eg 32 bit is at least 0x10000 * 0x10000 == 0x100000000
		   which is overflow. Drop to NVs below.  */
	    } else if (!ahigh && !bhigh) {
		/* eg 32 bit is at most 0xFFFF * 0xFFFF == 0xFFFE0001
		   so the unsigned multiply cannot overflow.  */
		UV product = alow * blow;
		if (auvok == buvok) {
		    /* -ve * -ve or +ve * +ve gives a +ve result.  */
		    SP--;
		    SETu( product );
		    RETURN;
		} else if (product <= (UV)IV_MIN) {
		    /* 2s complement assumption that (UV)-IV_MIN is correct.  */
		    /* -ve result, which could overflow an IV  */
		    SP--;
		    SETi( -(IV)product );
		    RETURN;
		} /* else drop to NVs below. */
	    } else {
		/* One operand is large, 1 small */
		UV product_middle;
		if (bhigh) {
		    /* swap the operands */
		    ahigh = bhigh;
		    bhigh = blow; /* bhigh now the temp var for the swap */
		    blow = alow;
		    alow = bhigh;
		}
		/* now, ((ahigh * blow) << half_UV_len) + (alow * blow)
		   multiplies can't overflow. shift can, add can, -ve can.  */
		product_middle = ahigh * blow;
		if (!(product_middle & topmask)) {
		    /* OK, (ahigh * blow) won't lose bits when we shift it.  */
		    UV product_low;
		    product_middle <<= (4 * sizeof (UV));
		    product_low = alow * blow;

		    /* as for pp_add, UV + something mustn't get smaller.
		       IIRC ANSI mandates this wrapping *behaviour* for
		       unsigned whatever the actual representation*/
		    product_low += product_middle;
		    if (product_low >= product_middle) {
			/* didn't overflow */
			if (auvok == buvok) {
			    /* -ve * -ve or +ve * +ve gives a +ve result.  */
			    SP--;
			    SETu( product_low );
			    RETURN;
			} else if (product_low <= (UV)IV_MIN) {
			    /* 2s complement assumption again  */
			    /* -ve result, which could overflow an IV  */
			    SP--;
			    SETi( -(IV)product_low );
			    RETURN;
			} /* else drop to NVs below. */
		    }
		} /* product_middle too large */
	    } /* ahigh && bhigh */
	} /* SvIOK(TOPm1s) */
    } /* SvIOK(TOPs) */
#endif
d945 5
a949 10
    /* Only try to do UV divide first
       if ((SLOPPYDIVIDE is true) or
           (PERL_PRESERVE_IVUV is true and one or both SV is a UV too large
            to preserve))
       The assumption is that it is better to use floating point divide
       whenever possible, only doing integer divide first if we can't be sure.
       If NV_PRESERVES_UV is true then we know at compile time that no UV
       can be too large to preserve, so don't need to compile the code to
       test the size of UVs.  */

d951 12
a962 2
#  define PERL_TRY_UV_DIVIDE
    /* ensure that 20./5. == 4. */
d964 1
a964 5
#  ifdef PERL_PRESERVE_IVUV
#    ifndef NV_PRESERVES_UV
#      define PERL_TRY_UV_DIVIDE
#    endif
#  endif
d966 2
a967 89

#ifdef PERL_TRY_UV_DIVIDE
    SvIV_please(TOPs);
    if (SvIOK(TOPs)) {
        SvIV_please(TOPm1s);
        if (SvIOK(TOPm1s)) {
            bool left_non_neg = SvUOK(TOPm1s);
            bool right_non_neg = SvUOK(TOPs);
            UV left;
            UV right;

            if (right_non_neg) {
                right = SvUVX(TOPs);
            }
	    else {
                IV biv = SvIVX(TOPs);
                if (biv >= 0) {
                    right = biv;
                    right_non_neg = TRUE; /* effectively it's a UV now */
                }
		else {
                    right = -biv;
                }
            }
            /* historically undef()/0 gives a "Use of uninitialized value"
               warning before dieing, hence this test goes here.
               If it were immediately before the second SvIV_please, then
               DIE() would be invoked before left was even inspected, so
               no inpsection would give no warning.  */
            if (right == 0)
                DIE(aTHX_ "Illegal division by zero");

            if (left_non_neg) {
                left = SvUVX(TOPm1s);
            }
	    else {
                IV aiv = SvIVX(TOPm1s);
                if (aiv >= 0) {
                    left = aiv;
                    left_non_neg = TRUE; /* effectively it's a UV now */
                }
		else {
                    left = -aiv;
                }
            }

            if (left >= right
#ifdef SLOPPYDIVIDE
                /* For sloppy divide we always attempt integer division.  */
#else
                /* Otherwise we only attempt it if either or both operands
                   would not be preserved by an NV.  If both fit in NVs
                   we fall through to the NV divide code below.  However,
                   as left >= right to ensure integer result here, we know that
                   we can skip the test on the right operand - right big
                   enough not to be preserved can't get here unless left is
                   also too big.  */

                && (left > ((UV)1 << NV_PRESERVES_UV_BITS))
#endif
                ) {
                /* Integer division can't overflow, but it can be imprecise.  */
                UV result = left / right;
                if (result * right == left) {
                    SP--; /* result is valid */
                    if (left_non_neg == right_non_neg) {
                        /* signs identical, result is positive.  */
                        SETu( result );
                        RETURN;
                    }
                    /* 2s complement assumption */
                    if (result <= (UV)IV_MIN)
                        SETi( -(IV)result );
                    else {
                        /* It's exact but too negative for IV. */
                        SETn( -(NV)result );
                    }
                    RETURN;
                } /* tried integer divide but it was not an integer result */
            } /* else (abs(result) < 1.0) or (both UVs in range for NV) */
        } /* left wasn't SvIOK */
    } /* right wasn't SvIOK */
#endif /* PERL_TRY_UV_DIVIDE */
    {
	dPOPPOPnnrl;
	if (right == 0.0)
	    DIE(aTHX_ "Illegal division by zero");
	PUSHn( left / right );
	RETURN;
d975 13
a987 25
	UV left  = 0;
	UV right = 0;
	bool left_neg = FALSE;
	bool right_neg = FALSE;
	bool use_double = FALSE;
	bool dright_valid = FALSE;
	NV dright = 0.0;
	NV dleft  = 0.0;

        SvIV_please(TOPs);
        if (SvIOK(TOPs)) {
            right_neg = !SvUOK(TOPs);
            if (!right_neg) {
                right = SvUVX(POPs);
            } else {
                IV biv = SvIVX(POPs);
                if (biv >= 0) {
                    right = biv;
                    right_neg = FALSE; /* effectively it's a UV now */
                } else {
                    right = -biv;
                }
            }
        }
        else {
d989 1
a992 6
            if (dright < UV_MAX_P1) {
                right = U_V(dright);
                dright_valid = TRUE; /* In case we need to use double below.  */
            } else {
                use_double = TRUE;
            }
d995 4
a998 20
        /* At this point use_double is only true if right is out of range for
           a UV.  In range NV has been rounded down to nearest UV and
           use_double false.  */
        SvIV_please(TOPs);
	if (!use_double && SvIOK(TOPs)) {
            if (SvIOK(TOPs)) {
                left_neg = !SvUOK(TOPs);
                if (!left_neg) {
                    left = SvUVX(POPs);
                } else {
                    IV aiv = SvIVX(POPs);
                    if (aiv >= 0) {
                        left = aiv;
                        left_neg = FALSE; /* effectively it's a UV now */
                    } else {
                        left = -aiv;
                    }
                }
            }
        }
d1001 4
d1008 1
a1009 23
            /* This should be exactly the 5.6 behaviour - if left and right are
               both in range for UV then use U_V() rather than floor.  */
	    if (!use_double) {
                if (dleft < UV_MAX_P1) {
                    /* right was in range, so is dleft, so use UVs not double.
                     */
                    left = U_V(dleft);
                }
                /* left is out of range for UV, right was in range, so promote
                   right (back) to double.  */
                else {
                    /* The +0.5 is used in 5.6 even though it is not strictly
                       consistent with the implicit +0 floor in the U_V()
                       inside the #if 1. */
                    dleft = Perl_floor(dleft + 0.5);
                    use_double = TRUE;
                    if (dright_valid)
                        dright = Perl_floor(dright + 0.5);
                    else
                        dright = right;
                }
            }
        }
d1013 22
d1048 1
d1085 2
a1086 27
#if 0
	      /* This code was intended to fix 20010809.028:

	         $x = 'abcd';
		 for (($x =~ /./g) x 2) {
		     print chop; # "abcdabcd" expected as output.
		 }

	       * but that change (#11635) broke this code:

	       $x = [("foo")x2]; # only one "foo" ended up in the anonlist.

	       * I can't think of a better fix that doesn't introduce
	       * an efficiency hit by copying the SVs. The stack isn't
	       * refcounted, and mortalisation obviously doesn't
	       * Do The Right Thing when the stack has more than
	       * one pointer to the same mortal value.
	       * .robin.
	       */
		if (*SP) {
		    *SP = sv_2mortal(newSVsv(*SP));
		    SvREADONLY_on(*SP);
		}
#else
               if (*SP)
		   SvTEMP_off((*SP));
#endif
a1118 10

	if (PL_op->op_private & OPpREPEAT_DOLIST) {
	    /* The parser saw this as a list repeat, and there
	       are probably several items on the stack. But we're
	       in scalar context, and there's no pp_list to save us
	       now. So drop the rest of the items -- robin@@kitsite.com
	     */
	    dMARK;
	    SP = MARK;
	}
d1127 1
a1127 103
    dSP; dATARGET; bool useleft; tryAMAGICbin(subtr,opASSIGN);
    useleft = USE_LEFT(TOPm1s);
#ifdef PERL_PRESERVE_IVUV
    /* See comments in pp_add (in pp_hot.c) about Overflow, and how
       "bad things" happen if you rely on signed integers wrapping.  */
    SvIV_please(TOPs);
    if (SvIOK(TOPs)) {
	/* Unless the left argument is integer in range we are going to have to
	   use NV maths. Hence only attempt to coerce the right argument if
	   we know the left is integer.  */
	register UV auv = 0;
	bool auvok = FALSE;
	bool a_valid = 0;

	if (!useleft) {
	    auv = 0;
	    a_valid = auvok = 1;
	    /* left operand is undef, treat as zero.  */
	} else {
	    /* Left operand is defined, so is it IV? */
	    SvIV_please(TOPm1s);
	    if (SvIOK(TOPm1s)) {
		if ((auvok = SvUOK(TOPm1s)))
		    auv = SvUVX(TOPm1s);
		else {
		    register IV aiv = SvIVX(TOPm1s);
		    if (aiv >= 0) {
			auv = aiv;
			auvok = 1;	/* Now acting as a sign flag.  */
		    } else { /* 2s complement assumption for IV_MIN */
			auv = (UV)-aiv;
		    }
		}
		a_valid = 1;
	    }
	}
	if (a_valid) {
	    bool result_good = 0;
	    UV result;
	    register UV buv;
	    bool buvok = SvUOK(TOPs);
	
	    if (buvok)
		buv = SvUVX(TOPs);
	    else {
		register IV biv = SvIVX(TOPs);
		if (biv >= 0) {
		    buv = biv;
		    buvok = 1;
		} else
		    buv = (UV)-biv;
	    }
	    /* ?uvok if value is >= 0. basically, flagged as UV if it's +ve,
	       else "IV" now, independent of how it came in.
	       if a, b represents positive, A, B negative, a maps to -A etc
	       a - b =>  (a - b)
	       A - b => -(a + b)
	       a - B =>  (a + b)
	       A - B => -(a - b)
	       all UV maths. negate result if A negative.
	       subtract if signs same, add if signs differ. */

	    if (auvok ^ buvok) {
		/* Signs differ.  */
		result = auv + buv;
		if (result >= auv)
		    result_good = 1;
	    } else {
		/* Signs same */
		if (auv >= buv) {
		    result = auv - buv;
		    /* Must get smaller */
		    if (result <= auv)
			result_good = 1;
		} else {
		    result = buv - auv;
		    if (result <= buv) {
			/* result really should be -(auv-buv). as its negation
			   of true value, need to swap our result flag  */
			auvok = !auvok;
			result_good = 1;
		    }
		}
	    }
	    if (result_good) {
		SP--;
		if (auvok)
		    SETu( result );
		else {
		    /* Negate result */
		    if (result <= (UV)IV_MIN)
			SETi( -(IV)result );
		    else {
			/* result valid, but out of range for IV.  */
			SETn( -(NV)result );
		    }
		}
		RETURN;
	    } /* Overflow, drop through to NVs.  */
	}
    }
#endif
    useleft = USE_LEFT(TOPm1s);
d1129 3
a1131 8
	dPOPnv;
	if (!useleft) {
	    /* left operand is undef, treat as zero - value */
	    SETn(-value);
	    RETURN;
	}
	SETn( TOPn - value );
	RETURN;
a1171 68
#ifdef PERL_PRESERVE_IVUV
    SvIV_please(TOPs);
    if (SvIOK(TOPs)) {
	SvIV_please(TOPm1s);
	if (SvIOK(TOPm1s)) {
	    bool auvok = SvUOK(TOPm1s);
	    bool buvok = SvUOK(TOPs);
	
	    if (!auvok && !buvok) { /* ## IV < IV ## */
		IV aiv = SvIVX(TOPm1s);
		IV biv = SvIVX(TOPs);
		
		SP--;
		SETs(boolSV(aiv < biv));
		RETURN;
	    }
	    if (auvok && buvok) { /* ## UV < UV ## */
		UV auv = SvUVX(TOPm1s);
		UV buv = SvUVX(TOPs);
		
		SP--;
		SETs(boolSV(auv < buv));
		RETURN;
	    }
	    if (auvok) { /* ## UV < IV ## */
		UV auv;
		IV biv;
		
		biv = SvIVX(TOPs);
		SP--;
		if (biv < 0) {
		    /* As (a) is a UV, it's >=0, so it cannot be < */
		    SETs(&PL_sv_no);
		    RETURN;
		}
		auv = SvUVX(TOPs);
		SETs(boolSV(auv < (UV)biv));
		RETURN;
	    }
	    { /* ## IV < UV ## */
		IV aiv;
		UV buv;
		
		aiv = SvIVX(TOPm1s);
		if (aiv < 0) {
		    /* As (b) is a UV, it's >=0, so it must be < */
		    SP--;
		    SETs(&PL_sv_yes);
		    RETURN;
		}
		buv = SvUVX(TOPs);
		SP--;
		SETs(boolSV((UV)aiv < buv));
		RETURN;
	    }
	}
    }
#endif
#ifndef NV_PRESERVES_UV
#ifdef PERL_PRESERVE_IVUV
    else
#endif
        if (SvROK(TOPs) && SvROK(TOPm1s)) {
            SP--;
            SETs(boolSV(SvRV(TOPs) < SvRV(TOPp1s)));
            RETURN;
        }
#endif
a1181 68
#ifdef PERL_PRESERVE_IVUV
    SvIV_please(TOPs);
    if (SvIOK(TOPs)) {
	SvIV_please(TOPm1s);
	if (SvIOK(TOPm1s)) {
	    bool auvok = SvUOK(TOPm1s);
	    bool buvok = SvUOK(TOPs);
	
	    if (!auvok && !buvok) { /* ## IV > IV ## */
		IV aiv = SvIVX(TOPm1s);
		IV biv = SvIVX(TOPs);
		
		SP--;
		SETs(boolSV(aiv > biv));
		RETURN;
	    }
	    if (auvok && buvok) { /* ## UV > UV ## */
		UV auv = SvUVX(TOPm1s);
		UV buv = SvUVX(TOPs);
		
		SP--;
		SETs(boolSV(auv > buv));
		RETURN;
	    }
	    if (auvok) { /* ## UV > IV ## */
		UV auv;
		IV biv;
		
		biv = SvIVX(TOPs);
		SP--;
		if (biv < 0) {
		    /* As (a) is a UV, it's >=0, so it must be > */
		    SETs(&PL_sv_yes);
		    RETURN;
		}
		auv = SvUVX(TOPs);
		SETs(boolSV(auv > (UV)biv));
		RETURN;
	    }
	    { /* ## IV > UV ## */
		IV aiv;
		UV buv;
		
		aiv = SvIVX(TOPm1s);
		if (aiv < 0) {
		    /* As (b) is a UV, it's >=0, so it cannot be > */
		    SP--;
		    SETs(&PL_sv_no);
		    RETURN;
		}
		buv = SvUVX(TOPs);
		SP--;
		SETs(boolSV((UV)aiv > buv));
		RETURN;
	    }
	}
    }
#endif
#ifndef NV_PRESERVES_UV
#ifdef PERL_PRESERVE_IVUV
    else
#endif
        if (SvROK(TOPs) && SvROK(TOPm1s)) {
        SP--;
        SETs(boolSV(SvRV(TOPs) > SvRV(TOPp1s)));
        RETURN;
    }
#endif
a1191 68
#ifdef PERL_PRESERVE_IVUV
    SvIV_please(TOPs);
    if (SvIOK(TOPs)) {
	SvIV_please(TOPm1s);
	if (SvIOK(TOPm1s)) {
	    bool auvok = SvUOK(TOPm1s);
	    bool buvok = SvUOK(TOPs);
	
	    if (!auvok && !buvok) { /* ## IV <= IV ## */
		IV aiv = SvIVX(TOPm1s);
		IV biv = SvIVX(TOPs);
		
		SP--;
		SETs(boolSV(aiv <= biv));
		RETURN;
	    }
	    if (auvok && buvok) { /* ## UV <= UV ## */
		UV auv = SvUVX(TOPm1s);
		UV buv = SvUVX(TOPs);
		
		SP--;
		SETs(boolSV(auv <= buv));
		RETURN;
	    }
	    if (auvok) { /* ## UV <= IV ## */
		UV auv;
		IV biv;
		
		biv = SvIVX(TOPs);
		SP--;
		if (biv < 0) {
		    /* As (a) is a UV, it's >=0, so a cannot be <= */
		    SETs(&PL_sv_no);
		    RETURN;
		}
		auv = SvUVX(TOPs);
		SETs(boolSV(auv <= (UV)biv));
		RETURN;
	    }
	    { /* ## IV <= UV ## */
		IV aiv;
		UV buv;
		
		aiv = SvIVX(TOPm1s);
		if (aiv < 0) {
		    /* As (b) is a UV, it's >=0, so a must be <= */
		    SP--;
		    SETs(&PL_sv_yes);
		    RETURN;
		}
		buv = SvUVX(TOPs);
		SP--;
		SETs(boolSV((UV)aiv <= buv));
		RETURN;
	    }
	}
    }
#endif
#ifndef NV_PRESERVES_UV
#ifdef PERL_PRESERVE_IVUV
    else
#endif
        if (SvROK(TOPs) && SvROK(TOPm1s)) {
        SP--;
        SETs(boolSV(SvRV(TOPs) <= SvRV(TOPp1s)));
        RETURN;
    }
#endif
a1201 68
#ifdef PERL_PRESERVE_IVUV
    SvIV_please(TOPs);
    if (SvIOK(TOPs)) {
	SvIV_please(TOPm1s);
	if (SvIOK(TOPm1s)) {
	    bool auvok = SvUOK(TOPm1s);
	    bool buvok = SvUOK(TOPs);
	
	    if (!auvok && !buvok) { /* ## IV >= IV ## */
		IV aiv = SvIVX(TOPm1s);
		IV biv = SvIVX(TOPs);
		
		SP--;
		SETs(boolSV(aiv >= biv));
		RETURN;
	    }
	    if (auvok && buvok) { /* ## UV >= UV ## */
		UV auv = SvUVX(TOPm1s);
		UV buv = SvUVX(TOPs);
		
		SP--;
		SETs(boolSV(auv >= buv));
		RETURN;
	    }
	    if (auvok) { /* ## UV >= IV ## */
		UV auv;
		IV biv;
		
		biv = SvIVX(TOPs);
		SP--;
		if (biv < 0) {
		    /* As (a) is a UV, it's >=0, so it must be >= */
		    SETs(&PL_sv_yes);
		    RETURN;
		}
		auv = SvUVX(TOPs);
		SETs(boolSV(auv >= (UV)biv));
		RETURN;
	    }
	    { /* ## IV >= UV ## */
		IV aiv;
		UV buv;
		
		aiv = SvIVX(TOPm1s);
		if (aiv < 0) {
		    /* As (b) is a UV, it's >=0, so a cannot be >= */
		    SP--;
		    SETs(&PL_sv_no);
		    RETURN;
		}
		buv = SvUVX(TOPs);
		SP--;
		SETs(boolSV((UV)aiv >= buv));
		RETURN;
	    }
	}
    }
#endif
#ifndef NV_PRESERVES_UV
#ifdef PERL_PRESERVE_IVUV
    else
#endif
        if (SvROK(TOPs) && SvROK(TOPm1s)) {
        SP--;
        SETs(boolSV(SvRV(TOPs) >= SvRV(TOPp1s)));
        RETURN;
    }
#endif
a1211 59
#ifndef NV_PRESERVES_UV
    if (SvROK(TOPs) && SvROK(TOPm1s)) {
        SP--;
	SETs(boolSV(SvRV(TOPs) != SvRV(TOPp1s)));
	RETURN;
    }
#endif
#ifdef PERL_PRESERVE_IVUV
    SvIV_please(TOPs);
    if (SvIOK(TOPs)) {
	SvIV_please(TOPm1s);
	if (SvIOK(TOPm1s)) {
	    bool auvok = SvUOK(TOPm1s);
	    bool buvok = SvUOK(TOPs);
	
	    if (auvok == buvok) { /* ## IV == IV or UV == UV ## */
                /* Casting IV to UV before comparison isn't going to matter
                   on 2s complement. On 1s complement or sign&magnitude
                   (if we have any of them) it could make negative zero
                   differ from normal zero. As I understand it. (Need to
                   check - is negative zero implementation defined behaviour
                   anyway?). NWC  */
		UV buv = SvUVX(POPs);
		UV auv = SvUVX(TOPs);
		
		SETs(boolSV(auv != buv));
		RETURN;
	    }
	    {			/* ## Mixed IV,UV ## */
		IV iv;
		UV uv;
		
		/* != is commutative so swap if needed (save code) */
		if (auvok) {
		    /* swap. top of stack (b) is the iv */
		    iv = SvIVX(TOPs);
		    SP--;
		    if (iv < 0) {
			/* As (a) is a UV, it's >0, so it cannot be == */
			SETs(&PL_sv_yes);
			RETURN;
		    }
		    uv = SvUVX(TOPs);
		} else {
		    iv = SvIVX(TOPm1s);
		    SP--;
		    if (iv < 0) {
			/* As (b) is a UV, it's >0, so it cannot be == */
			SETs(&PL_sv_yes);
			RETURN;
		    }
		    uv = SvUVX(*(SP+1)); /* Do I want TOPp1s() ? */
		}
		SETs(boolSV((UV)iv != uv));
		RETURN;
	    }
	}
    }
#endif
d1222 1
a1222 81
#ifndef NV_PRESERVES_UV
    if (SvROK(TOPs) && SvROK(TOPm1s)) {
        UV right = PTR2UV(SvRV(POPs));
        UV left = PTR2UV(SvRV(TOPs));
	SETi((left > right) - (left < right));
	RETURN;
    }
#endif
#ifdef PERL_PRESERVE_IVUV
    /* Fortunately it seems NaN isn't IOK */
    SvIV_please(TOPs);
    if (SvIOK(TOPs)) {
	SvIV_please(TOPm1s);
	if (SvIOK(TOPm1s)) {
	    bool leftuvok = SvUOK(TOPm1s);
	    bool rightuvok = SvUOK(TOPs);
	    I32 value;
	    if (!leftuvok && !rightuvok) { /* ## IV <=> IV ## */
		IV leftiv = SvIVX(TOPm1s);
		IV rightiv = SvIVX(TOPs);
		
		if (leftiv > rightiv)
		    value = 1;
		else if (leftiv < rightiv)
		    value = -1;
		else
		    value = 0;
	    } else if (leftuvok && rightuvok) { /* ## UV <=> UV ## */
		UV leftuv = SvUVX(TOPm1s);
		UV rightuv = SvUVX(TOPs);
		
		if (leftuv > rightuv)
		    value = 1;
		else if (leftuv < rightuv)
		    value = -1;
		else
		    value = 0;
	    } else if (leftuvok) { /* ## UV <=> IV ## */
		UV leftuv;
		IV rightiv;
		
		rightiv = SvIVX(TOPs);
		if (rightiv < 0) {
		    /* As (a) is a UV, it's >=0, so it cannot be < */
		    value = 1;
		} else {
		    leftuv = SvUVX(TOPm1s);
		    if (leftuv > (UV)rightiv) {
			value = 1;
		    } else if (leftuv < (UV)rightiv) {
			value = -1;
		    } else {
			value = 0;
		    }
		}
	    } else { /* ## IV <=> UV ## */
		IV leftiv;
		UV rightuv;
		
		leftiv = SvIVX(TOPm1s);
		if (leftiv < 0) {
		    /* As (b) is a UV, it's >=0, so it must be < */
		    value = -1;
		} else {
		    rightuv = SvUVX(TOPs);
		    if ((UV)leftiv > rightuv) {
			value = 1;
		    } else if ((UV)leftiv < rightuv) {
			value = -1;
		    } else {
			value = 0;
		    }
		}
	    }
	    SP--;
	    SETi(value);
	    RETURN;
	}
    }
#endif
    {
d1254 1
a1254 1
      int cmp = (IN_LOCALE_RUNTIME
d1267 1
a1267 1
      int cmp = (IN_LOCALE_RUNTIME
d1280 1
a1280 1
      int cmp = (IN_LOCALE_RUNTIME
d1293 1
a1293 1
      int cmp = (IN_LOCALE_RUNTIME
d1326 1
a1326 1
      int cmp = (IN_LOCALE_RUNTIME
a1407 1
	int flags = SvFLAGS(sv);
d1410 1
a1410 3
	if ((flags & SVf_IOK) || ((flags & (SVp_IOK | SVp_NOK)) == SVp_IOK)) {
	    /* It's publicly an integer, or privately an integer-not-float */
	oops_its_an_int:
a1412 1
		    /* 2s complement assumption. */
a1424 6
#ifdef PERL_PRESERVE_IVUV
	    else {
		SETu((UV)IV_MIN);
		RETURN;
	    }
#endif
d1439 3
a1441 10
	    else if (DO_UTF8(sv)) {
		SvIV_please(sv);
		if (SvIOK(sv))
		    goto oops_its_an_int;
		if (SvNOK(sv))
		    sv_setnv(TARG, -SvNV(sv));
		else {
		    sv_setpvn(TARG, "-", 1);
		    sv_catsv(TARG, sv);
		}
d1443 1
a1443 4
	    else {
		SvIV_please(sv);
		if (SvIOK(sv))
		  goto oops_its_an_int;
a1444 1
	    }
d1494 1
a1494 1
	    UV c = utf8n_to_uvchr(tmps, send-tmps, &l, UTF8_ALLOW_ANYUV);
d1508 1
a1508 1
		  UV c = utf8n_to_uvchr(tmps, send-tmps, &l, UTF8_ALLOW_ANYUV);
d1510 1
a1510 1
		  result = uvchr_to_utf8_flags(result, ~c, UNICODE_ALLOW_ANY);
d1520 1
a1520 1
		  U8 c = (U8)utf8n_to_uvchr(tmps, 0, &l, UTF8_ALLOW_ANY);
d1844 1
a1844 1
    PerlProc_gettimeofday(&when,NULL);
d1879 1
a1879 1
	DIE(aTHX_ "Can't take log of %"NVgf, value);
d1895 1
a1895 1
	DIE(aTHX_ "Can't take sqrt of %"NVgf, value);
a1902 22
/*
 * There are strange code-generation bugs caused on sparc64 by gcc-2.95.2.
 * These need to be revisited when a newer toolchain becomes available.
 */
#if defined(__sparc64__) && defined(__GNUC__)
#   if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 96)
#       undef  SPARC64_MODF_WORKAROUND
#       define SPARC64_MODF_WORKAROUND 1
#   endif
#endif

#if defined(SPARC64_MODF_WORKAROUND)
static NV
sparc64_workaround_modf(NV theVal, NV *theIntRes)
{
    NV res, ret;
    ret = Perl_modf(theVal, &res);
    *theIntRes = res;
    return ret;
}
#endif

d1905 1
a1905 1
    dSP; dTARGET; tryAMAGICun(int);
d1907 8
a1914 15
      NV value;
      IV iv = TOPi; /* attempt to convert to IV if possible. */
      /* XXX it's arguable that compiler casting to IV might be subtly
	 different from modf (for numbers inside (IV_MIN,UV_MAX)) in which
	 else preferring IV has introduced a subtle behaviour change bug. OTOH
	 relying on floating point to be accurate is a bug.  */

      if (SvIOK(TOPs)) {
	if (SvIsUV(TOPs)) {
	    UV uv = TOPu;
	    SETu(uv);
	} else
	    SETi(iv);
      } else {
	  value = TOPn;
d1916 2
a1917 5
	      if (value < (NV)UV_MAX + 0.5) {
		  SETu(U_V(value));
	      } else {
#if defined(SPARC64_MODF_WORKAROUND)
		(void)sparc64_workaround_modf(value, &value);
d1919 3
a1921 16
#   if defined(HAS_MODFL) || defined(LONG_DOUBLE_EQUALS_DOUBLE)
#       ifdef HAS_MODFL_POW32_BUG
/* some versions of glibc split (i + d) into (i-1, d+1) for 2^32 <= i < 2^64 */
                {
                    NV offset = Perl_modf(value, &value);
                    (void)Perl_modf(offset, &offset);
                    value += offset;
                }
#       else
		  (void)Perl_modf(value, &value);
#       endif
#   else
		  double tmp = (double)value;
		  (void)Perl_modf(tmp, &tmp);
		  value = (NV)tmp;
#   endif
a1922 2
		  SETn(value);
	      }
d1924 1
a1924 4
	  else {
	      if (value > (NV)IV_MIN - 0.5) {
		  SETi(I_V(value));
	      } else {
d1926 2
a1927 11
#   ifdef HAS_MODFL_POW32_BUG
/* some versions of glibc split (i + d) into (i-1, d+1) for 2^32 <= i < 2^64 */
                 {
                     NV offset = Perl_modf(-value, &value);
                     (void)Perl_modf(offset, &offset);
                     value += offset;
                 }
#   else
		  (void)Perl_modf(-value, &value);
#   endif
		  value = -value;
d1929 3
a1931 3
		  double tmp = (double)value;
		  (void)Perl_modf(-tmp, &tmp);
		  value = -(NV)tmp;
d1933 6
a1938 3
		  SETn(value);
	      }
	  }
d1948 2
a1949 2
      /* This will cache the NV value if string isn't actually integer  */
      IV iv = TOPi;
d1951 7
a1957 19
      if (SvIOK(TOPs)) {
	/* IVX is precise  */
	if (SvIsUV(TOPs)) {
	  SETu(TOPu);	/* force it to be numeric only */
	} else {
	  if (iv >= 0) {
	    SETi(iv);
	  } else {
	    if (iv != IV_MIN) {
	      SETi(-iv);
	    } else {
	      /* 2s complement assumption. Also, not really needed as
		 IV_MIN and -IV_MIN should both be %100...00 and NV-able  */
	      SETu(IV_MIN);
	    }
	  }
	}
      } else{
	NV value = TOPn;
d1959 1
a1959 1
	  value = -value;
a1965 1

d1970 1
a1970 1
    I32 flags = PERL_SCAN_ALLOW_UNDERSCORES;
a1971 3
    NV result_nv;
    UV result_uv;
    SV* sv = POPs;
d1973 3
a1975 17
    tmps = (SvPVx(sv, len));
    if (DO_UTF8(sv)) {
	 /* If Unicode, try to downgrade
	  * If not possible, croak. */
         SV* tsv = sv_2mortal(newSVsv(sv));
	
	 SvUTF8_on(tsv);
	 sv_utf8_downgrade(tsv, FALSE);
	 tmps = SvPVX(tsv);
    }
    result_uv = grok_hex (tmps, &len, &flags, &result_nv);
    if (flags & PERL_SCAN_GREATER_THAN_UV_MAX) {
        XPUSHn(result_nv);
    }
    else {
        XPUSHu(result_uv);
    }
d1982 2
a1984 1
    I32 flags = PERL_SCAN_ALLOW_UNDERSCORES;
a1985 3
    NV result_nv;
    UV result_uv;
    SV* sv = POPs;
d1987 1
a1987 10
    tmps = (SvPVx(sv, len));
    if (DO_UTF8(sv)) {
	 /* If Unicode, try to downgrade
	  * If not possible, croak. */
         SV* tsv = sv_2mortal(newSVsv(sv));
	
	 SvUTF8_on(tsv);
	 sv_utf8_downgrade(tsv, FALSE);
	 tmps = SvPVX(tsv);
    }
d1989 1
a1989 1
        tmps++, len--;
d1991 2
a1992 1
        tmps++, len--;
d1994 1
a1994 1
        result_uv = grok_hex (tmps, &len, &flags, &result_nv);
d1996 1
a1996 1
        result_uv = grok_bin (tmps, &len, &flags, &result_nv);
d1998 2
a1999 8
        result_uv = grok_oct (tmps, &len, &flags, &result_nv);

    if (flags & PERL_SCAN_GREATER_THAN_UV_MAX) {
        XPUSHn(result_nv);
    }
    else {
        XPUSHu(result_uv);
    }
d2021 1
a2021 1
    I32 len = 0;
d2106 1
a2106 1
	    Perl_warner(aTHX_ packWARN(WARN_SUBSTR), "substr outside of string");
a2115 3
#ifdef USE_LOCALE_COLLATE
	sv_unmagic(TARG, PERL_MAGIC_collxfrm);
#endif
d2139 1
a2139 1
			Perl_warner(aTHX_ packWARN(WARN_SUBSTR),
d2150 1
a2150 1
		sv_magic(TARG, Nullsv, PERL_MAGIC_substr, Nullch, 0);
d2180 1
a2180 1
	    sv_magic(TARG, Nullsv, PERL_MAGIC_vec, Nullch, 0);
d2220 1
a2220 1
    else if (offset > (I32)biglen)
d2261 1
a2261 1
    else if (offset > (I32)blen)
a2278 2
    if (DO_UTF8(*(MARK+1)))
	SvUTF8_on(TARG);
a2289 11
    SV *tmpsv;

    if (PL_encoding && SvPOK(argsv) && !DO_UTF8(argsv)) {
        tmpsv = sv_2mortal(newSVsv(argsv));
        s = (U8*)sv_recode_to_utf8(tmpsv, PL_encoding);
        argsv = tmpsv;
    }

    XPUSHu(DO_UTF8(argsv) ?
	   utf8n_to_uvchr(s, UTF8_MAXLEN, 0, UTF8_ALLOW_ANYUV) :
	   (*s & 0xff));
d2291 1
d2303 4
a2306 3
    if (value > 255 && !IN_BYTES) {
	SvGROW(TARG, (STRLEN)UNISKIP(value)+1);
	tmps = (char*)uvchr_to_utf8_flags((U8*)SvPVX(TARG), value, 0);
d2318 1
a2318 1
    *tmps++ = (char)value;
a2320 2
    if (PL_encoding)
        sv_recode_to_utf8(TARG, PL_encoding);
d2327 2
a2328 1
    dSP; dTARGET;
d2330 2
a2331 16
    dPOPTOPssrl;
    STRLEN n_a;
    STRLEN len;
    char *tmps = SvPV(left, len);

    if (DO_UTF8(left)) {
         /* If Unicode, try to downgrade.
	  * If not possible, croak.
	  * Yes, we made this up.  */
         SV* tsv = sv_2mortal(newSVsv(left));

	 SvUTF8_on(tsv);
	 sv_utf8_downgrade(tsv, FALSE);
	 tmps = SvPVX(tsv);
    }
#   ifdef FCRYPT
d2333 1
a2333 1
#   else
d2335 1
a2335 3
#   endif
    SETs(TARG);
    RETURN;
d2337 1
a2337 1
    DIE(aTHX_
d2340 2
d2351 1
a2351 2
    if (DO_UTF8(sv)) {
	U8 tmpbuf[UTF8_MAXLEN_UCLC+1];
d2353 3
a2355 1
	STRLEN tculen;
d2357 9
a2365 2
	s = (U8*)SvPV(sv, slen);
	utf8_to_uvchr(s, &ulen);
d2367 1
a2367 4
	toTITLE_utf8(s, tmpbuf, &tculen);
	utf8_to_uvchr(tmpbuf, 0);

	if (!SvPADTMP(sv) || SvREADONLY(sv)) {
d2369 1
a2369 1
	    sv_setpvn(TARG, (char*)tmpbuf, tculen);
d2376 1
a2376 1
	    Copy(tmpbuf, s, tculen, U8);
d2389 1
a2389 1
	    if (IN_LOCALE_RUNTIME) {
d2412 1
a2412 1
	U8 tmpbuf[UTF8_MAXLEN_UCLC+1];
d2414 1
a2414 1
	UV uv;
d2416 7
a2422 2
	toLOWER_utf8(s, tmpbuf, &ulen);
	uv = utf8_to_uvchr(tmpbuf, 0);
d2424 1
a2424 1
	tend = uvchr_to_utf8(tmpbuf, uv);
d2426 1
a2426 1
	if (!SvPADTMP(sv) || (STRLEN)(tend - tmpbuf) != ulen || SvREADONLY(sv)) {
d2448 1
a2448 1
	    if (IN_LOCALE_RUNTIME) {
a2473 1
	U8 tmpbuf[UTF8_MAXLEN_UCLC+1];
a2481 2
	    STRLEN nchar = utf8_length(s, s + len);

d2483 1
a2483 1
	    SvGROW(TARG, (nchar * UTF8_MAXLEN_UCLC) + 1);
d2487 13
a2499 5
	    while (s < send) {
		toUPPER_utf8(s, tmpbuf, &ulen);
		Copy(tmpbuf, d, ulen, U8);
		d += ulen;
		s += UTF8SKIP(s);
d2519 1
a2519 1
	    if (IN_LOCALE_RUNTIME) {
a2547 1
	U8 tmpbuf[UTF8_MAXLEN_UCLC+1];
a2555 2
	    STRLEN nchar = utf8_length(s, s + len);

d2557 1
a2557 1
	    SvGROW(TARG, (nchar * UTF8_MAXLEN_UCLC) + 1);
d2561 13
a2573 22
	    while (s < send) {
		UV uv = toLOWER_utf8(s, tmpbuf, &ulen);
#define GREEK_CAPITAL_LETTER_SIGMA 0x03A3 /* Unicode */
		if (uv == GREEK_CAPITAL_LETTER_SIGMA) {
		     /*
		      * Now if the sigma is NOT followed by
		      * /$ignorable_sequence$cased_letter/;
		      * and it IS preceded by
		      * /$cased_letter$ignorable_sequence/;
		      * where $ignorable_sequence is
		      * [\x{2010}\x{AD}\p{Mn}]*
		      * and $cased_letter is
		      * [\p{Ll}\p{Lo}\p{Lt}]
		      * then it should be mapped to 0x03C2,
		      * (GREEK SMALL LETTER FINAL SIGMA),
		      * instead of staying 0x03A3.
		      * See lib/unicore/SpecCase.txt.
		      */
		}
		Copy(tmpbuf, d, ulen, U8);
		d += ulen;
		s += UTF8SKIP(s);
d2594 1
a2594 1
	    if (IN_LOCALE_RUNTIME) {
d2724 1
a2724 2
        SV* sv = hv_iterkeysv(entry);
	PUSHs(sv);	/* won't clobber stack_sp */
a2857 2
    bool localizing = PL_op->op_private & OPpLVAL_INTRO ? TRUE : FALSE;
    bool other_magic = FALSE;
d2859 1
a2859 15
    if (localizing) {
        MAGIC *mg;
        HV *stash;

        other_magic = mg_find((SV*)hv, PERL_MAGIC_env) ||
            ((mg = mg_find((SV*)hv, PERL_MAGIC_tied))
             /* Try to preserve the existenceness of a tied hash
              * element by using EXISTS and DELETE if possible.
              * Fallback to FETCH and STORE otherwise */
             && (stash = SvSTASH(SvRV(SvTIED_obj((SV*)hv, mg))))
             && gv_fetchmethod_autoload(stash, "EXISTS", TRUE)
             && gv_fetchmethod_autoload(stash, "DELETE", TRUE));
    }

    if (!realhv && localizing)
a2865 8
	    bool preeminent = FALSE;

            if (localizing) {
                preeminent = SvRMAGICAL(hv) && !other_magic ? 1 :
                    realhv ? hv_exists_ent(hv, keysv, 0)
                    : avhv_exists_ent((AV*)hv, keysv, 0);
            }

d2878 2
a2879 9
		if (localizing) {
		    if (preeminent)
		        save_helem(hv, keysv, svp);
		    else {
			STRLEN keylen;
			char *key = SvPV(keysv, keylen);
			SAVEDELETE(hv, savepvn(key,keylen), keylen);
		    }
                }
d2945 1
a2945 1
	else
d2983 1
a2983 1
	    Perl_warner(aTHX_ packWARN(WARN_MISC), "Odd number of elements in anonymous hash");
d3006 1
a3006 1
    if ((mg = SvTIED_mg((SV*)ary, PERL_MAGIC_tied))) {
d3042 1
a3042 3
    if (offset > AvFILLp(ary) + 1) {
	if (ckWARN(WARN_MISC))
	    Perl_warner(aTHX_ packWARN(WARN_MISC), "splice() offset past end of array" );
a3043 1
    }
d3200 1
a3200 1
    if ((mg = SvTIED_mg((SV*)ary, PERL_MAGIC_tied))) {
d3256 1
a3256 1
    if ((mg = SvTIED_mg((SV*)ary, PERL_MAGIC_tied))) {
d3312 1
a3312 1
		    if (UTF8_IS_INVARIANT(*s)) {
d3317 1
a3317 1
			if (!utf8_to_uvchr(s, 0))
d3326 1
a3326 1
			    *down-- = (char)tmp;
d3336 1
a3336 1
		*down-- = (char)tmp;
d3346 1721
d5102 1
a5102 1
    rx = PM_GETRE(pm);
a5106 2
    PL_reg_match_utf8 = do_utf8;

d5109 1
a5109 1
	ary = GvAVn((GV*)PL_curpad[INT2PTR(PADOFFSET, pm->op_pmreplroot)]);
d5115 1
a5115 1
#ifdef USE_5005THREADS
d5119 1
a5119 1
#endif /* USE_5005THREADS */
d5128 1
a5128 1
	if ((mg = SvTIED_mg((SV*)ary, PERL_MAGIC_tied))) {
d5205 1
a5205 2
    else if (do_utf8 == ((rx->reganch & ROPT_UTF8) != 0) &&
	     (rx->reganch & RE_USE_INTUIT) && !rx->nparens
d5261 1
a5261 1
/*	       && (!rx->check_substr
d5284 1
a5284 1
		for (i = 1; i <= (I32)rx->nparens; i++) {
d5287 1
a5287 5

		    /* japhy (07/27/01) -- the (m && s) test doesn't catch
		       parens that didn't match -- they should be set to
		       undef, not the empty string */
		    if (m >= orig && s >= orig) {
d5292 1
a5292 1
			dstr = &PL_sv_undef;  /* undef, not "" */
d5370 1
a5370 1
#ifdef USE_5005THREADS
d5374 1
a5374 1
    MAGIC *mg = mg_find((SV*)svv, PERL_MAGIC_mutex);
d5384 1
a5384 1
			  PTR2UV(thr), PTR2UV(svv)));
d5387 1
a5387 1
#endif /* USE_5005THREADS */
d5394 3
a5396 1
    SvLOCK(sv);
d5407 1
a5407 1
#ifdef USE_5005THREADS
d5417 1
a5417 1
#endif /* USE_5005THREADS */
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@d3 1
a3 2
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
 *    2000, 2001, 2002, 2003, by Larry Wall and others
d22 2
a31 2
/* variations on pp_null */

a49 1
    I32 gimme;
d51 1
a51 1
	SAVECLEARSV(PAD_SVl(PL_op->op_targ));
d62 1
a62 2
    gimme = GIMME_V;
    if (gimme == G_ARRAY) {
d77 1
a77 1
    else if (gimme == G_SCALAR) {
d93 1
a93 1
	SAVECLEARSV(PAD_SVl(PL_op->op_targ));
d162 1
a162 1
			SV *namesv = PAD_SV(cUNOP->op_targ);
a211 1
    GV *gv = Nullgv;
d227 1
a229 1
	gv = (GV*)sv;
d266 2
a267 8
	if (PL_op->op_private & OPpLVAL_INTRO) {
	    if (cUNOP->op_first->op_type == OP_NULL)
		sv = save_scalar((GV*)TOPs);
	    else if (gv)
		sv = save_scalar(gv);
	    else
		Perl_croak(aTHX_ PL_no_localize_ref);
	}
d423 1
a423 1
    CV* cv = (CV*)PAD_SV(PL_op->op_targ);
a851 1
    /* special case for undef: see thread at 2003-03/msg00536.html in archive */
d881 1
a881 5
    dSP; dATARGET;
#ifdef PERL_PRESERVE_IVUV
    bool is_int = 0;
#endif
    tryAMAGICbin(pow,opASSIGN);
d883 8
a890 3
    /* For integer to integer power, we do the calculation by hand wherever
       we're sure it is safe; otherwise we call pow() and try to convert to
       integer afterwards. */
d922 2
a923 4
                /* now we have integer ** positive integer. */
                is_int = 1;

                /* foo & (foo - 1) is zero only for a power of 2.  */
d925 1
a925 1
                    /* We are raising power-of-2 to a positive integer.
d937 14
d958 1
a958 1
                            power -= bit;
a964 1
                    SvIV_please(TOPs);
d966 3
a968 44
		} else {
		    register unsigned int highbit = 8 * sizeof(UV);
		    register unsigned int lowbit = 0;
		    register unsigned int diff;
		    bool odd_power = (bool)(power & 1);
		    while ((diff = (highbit - lowbit) >> 1)) {
			if (baseuv & ~((1 << (lowbit + diff)) - 1))
			    lowbit += diff;
			else 
			    highbit -= diff;
		    }
		    /* we now have baseuv < 2 ** highbit */
		    if (power * highbit <= 8 * sizeof(UV)) {
			/* result will definitely fit in UV, so use UV math
			   on same algorithm as above */
			register UV result = 1;
			register UV base = baseuv;
			register int n = 0;
			for (; power; base *= base, n++) {
			    register UV bit = (UV)1 << (UV)n;
			    if (power & bit) {
				result *= base;
				power -= bit;
				if (power == 0) break;
			    }
			}
			SP--;
			if (baseuok || !odd_power)
			    /* answer is positive */
			    SETu( result );
			else if (result <= (UV)IV_MAX)
			    /* answer negative, fits in IV */
			    SETi( -(IV)result );
			else if (result == (UV)IV_MIN) 
			    /* 2's complement assumption: special case IV_MIN */
			    SETi( IV_MIN );
			else
			    /* answer negative, doesn't fit */
			    SETn( -(NV)result );
			RETURN;
		    } 
		}
	    }
	}
d970 1
a970 1
  float_it:
d973 3
a975 7
	dPOPTOPnnrl;
	SETn( Perl_pow( left, right) );
#ifdef PERL_PRESERVE_IVUV
	if (is_int)
	    SvIV_please(TOPs);
#endif
	RETURN;
d1199 1
a1199 1
            } /* else (PERL_ABS(result) < 1.0) or (both UVs in range for NV) */
a2419 32
STATIC
PP(pp_i_modulo_0)
{
     /* This is the vanilla old i_modulo. */
     dSP; dATARGET; tryAMAGICbin(modulo,opASSIGN);
     {
	  dPOPTOPiirl;
	  if (!right)
	       DIE(aTHX_ "Illegal modulus zero");
	  SETi( left % right );
	  RETURN;
     }
}

#if defined(__GLIBC__) && IVSIZE == 8
STATIC
PP(pp_i_modulo_1)
{
     /* This is the i_modulo with the workaround for the _moddi3 bug
      * in (at least) glibc 2.2.5 (the PERL_ABS() the workaround).
      * See below for pp_i_modulo. */
     dSP; dATARGET; tryAMAGICbin(modulo,opASSIGN);
     {
	  dPOPTOPiirl;
	  if (!right)
	       DIE(aTHX_ "Illegal modulus zero");
	  SETi( left % PERL_ABS(right) );
	  RETURN;
     }
}
#endif

d2422 8
a2429 36
     dSP; dATARGET; tryAMAGICbin(modulo,opASSIGN);
     {
	  dPOPTOPiirl;
	  if (!right)
	       DIE(aTHX_ "Illegal modulus zero");
	  /* The assumption is to use hereafter the old vanilla version... */
	  PL_op->op_ppaddr =
	       PL_ppaddr[OP_I_MODULO] =
	           &Perl_pp_i_modulo_0;
	  /* .. but if we have glibc, we might have a buggy _moddi3
	   * (at least glicb 2.2.5 is known to have this bug), in other
	   * words our integer modulus with negative quad as the second
	   * argument might be broken.  Test for this and re-patch the
	   * opcode dispatch table if that is the case, remembering to
	   * also apply the workaround so that this first round works
	   * right, too.  See [perl #9402] for more information. */
#if defined(__GLIBC__) && IVSIZE == 8
	  {
	       IV l =   3;
	       IV r = -10;
	       /* Cannot do this check with inlined IV constants since
		* that seems to work correctly even with the buggy glibc. */
	       if (l % r == -3) {
		    /* Yikes, we have the bug.
		     * Patch in the workaround version. */
		    PL_op->op_ppaddr =
			 PL_ppaddr[OP_I_MODULO] =
			     &Perl_pp_i_modulo_1;
		    /* Make certain we work right this time, too. */
		    right = PERL_ABS(right);
	       }
	  }
#endif
	  SETi( left % right );
	  RETURN;
     }
d2621 81
d2746 22
d2791 21
a2811 1
		  SETn(Perl_floor(value));
d2818 18
a2835 2
		/* This is maint, and we don't have Perl_ceil in perl.h  */
		  SETn(-Perl_floor(-value));
a3095 2
	    if (SvREFCNT(TARG) > 1)	/* don't share the TARG (#20933) */
		TARG = sv_newmortal();
a3099 2
	    else
		(void)SvOK_off(TARG);
a3125 2
	if (SvREFCNT(TARG) > 1)	/* don't share the TARG (#20933) */
	    TARG = sv_newmortal();
d3280 1
a3280 1
    if (PL_encoding && !IN_BYTES) {
a3281 12
	tmps = SvPVX(TARG);
	if (SvCUR(TARG) == 0 || !is_utf8_string((U8*)tmps, SvCUR(TARG)) ||
	    memEQ(tmps, "\xef\xbf\xbd\0", 4)) {
	    SvGROW(TARG, 3);
	    tmps = SvPVX(TARG);
	    SvCUR_set(TARG, 2);
	    *tmps++ = (U8)UTF8_EIGHT_BIT_HI(value);
	    *tmps++ = (U8)UTF8_EIGHT_BIT_LO(value);
	    *tmps = '\0';
	    SvUTF8_on(TARG);
	}
    }
a3304 18
#   ifdef USE_ITHREADS
#     ifdef HAS_CRYPT_R
    if (!PL_reentrant_buffer->_crypt_struct_buffer) {
      /* This should be threadsafe because in ithreads there is only
       * one thread per interpreter.  If this would not be true,
       * we would need a mutex to protect this malloc. */
        PL_reentrant_buffer->_crypt_struct_buffer =
	  (struct crypt_data *)safemalloc(sizeof(struct crypt_data));
#if defined(__GLIBC__) || defined(__EMX__)
	if (PL_reentrant_buffer->_crypt_struct_buffer) {
	    PL_reentrant_buffer->_crypt_struct_buffer->initialized = 0;
	    /* work around glibc-2.2.5 bug */
	    PL_reentrant_buffer->_crypt_struct_buffer->current_saltbits = 0;
	}
#endif
    }
#     endif /* HAS_CRYPT_R */
#   endif /* USE_ITHREADS */
d3325 1
a3325 4
    SvGETMAGIC(sv);
    if (DO_UTF8(sv) &&
	(s = (U8*)SvPV_nomg(sv, slen)) && slen &&
	UTF8_IS_START(*s)) {
d3330 1
d3332 1
a3337 7
	    /* slen is the byte length of the whole SV.
	     * ulen is the byte length of the original Unicode character
	     * stored as UTF-8 at s.
	     * tculen is the byte length of the freshly titlecased
	     * Unicode character stored as UTF-8 at tmpbuf.
	     * We first set the result to be the titlecased character,
	     * and then append the rest of the SV data. */
d3339 1
a3339 2
	    if (slen > ulen)
	        sv_catpvn(TARG, (char*)(s + ulen), slen - ulen);
d3344 1
a3344 1
	    s = (U8*)SvPV_force_nomg(sv, slen);
d3352 1
a3352 1
	    sv_setsv_nomg(TARG, sv);
d3356 1
a3356 1
	s = (U8*)SvPV_force_nomg(sv, slen);
d3367 2
a3368 1
    SvSETMAGIC(sv);
d3379 1
a3379 4
    SvGETMAGIC(sv);
    if (DO_UTF8(sv) &&
	(s = (U8*)SvPV_nomg(sv, slen)) && slen &&
	UTF8_IS_START(*s)) {
d3387 1
d3393 1
a3393 2
	    if (slen > ulen)
	        sv_catpvn(TARG, (char*)(s + ulen), slen - ulen);
d3398 1
a3398 1
	    s = (U8*)SvPV_force_nomg(sv, slen);
d3406 1
a3406 1
	    sv_setsv_nomg(TARG, sv);
d3410 1
a3410 1
	s = (U8*)SvPV_force_nomg(sv, slen);
d3421 2
a3422 1
    SvSETMAGIC(sv);
a3432 1
    SvGETMAGIC(sv);
d3440 1
a3440 1
	s = (U8*)SvPV_nomg(sv,len);
d3470 1
a3470 1
	    sv_setsv_nomg(TARG, sv);
d3474 1
a3474 1
	s = (U8*)SvPV_force_nomg(sv, len);
d3490 2
a3491 1
    SvSETMAGIC(sv);
a3501 1
    SvGETMAGIC(sv);
d3509 1
a3509 1
	s = (U8*)SvPV_nomg(sv,len);
d3556 1
a3556 1
	    sv_setsv_nomg(TARG, sv);
d3561 1
a3561 1
	s = (U8*)SvPV_force_nomg(sv, len);
d3577 2
a3578 1
    SvSETMAGIC(sv);
d4392 1
a4392 1
    RX_MATCH_UTF8_set(rx, do_utf8);
d4396 1
a4396 1
	ary = GvAVn((GV*)PAD_SVl(INT2PTR(PADOFFSET, pm->op_pmreplroot)));
d4403 1
a4403 1
	ary = (AV*)PAD_SVl(0);
a4427 1
	    PL_curstackinfo->si_stack = ary;
d4548 6
a4553 1
	while (s < strend && --limit)
a4554 5
	    PUTBACK;
	    i = CALLREGEXEC(aTHX_ rx, s, strend, orig, 1 , sv, NULL, 0);
	    SPAGAIN;
	    if (i == 0)
		break;
d4614 2
a4615 6
	while (iters > 0 && (!TOPs || !SvANY(TOPs) || SvCUR(TOPs) == 0)) {
	    if (TOPs && !make_mortal)
		sv_2mortal(TOPs);
	    iters--;
	    SP--;
	}
a4620 1
	    PL_curstackinfo->si_stack = oldstack;
d4654 6
a4659 4

    GETTARGET;
    PUSHi(iters);
    RETURN;
@


1.1.1.7
log
@perl 5.8.3 from CPAN
@
text
@d109 6
a114 1
	SV* sv = Perl_hv_scalar(aTHX_ (HV*)TARG);
d2799 2
a2800 1
		  SETn(Perl_ceil(value));
@


1.1.1.8
log
@Import of stock perl 5.8.5
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, by Larry Wall and others
a170 6
		    if (SvPVX(sv)) {
			(void)SvOOK_off(sv);		/* backoff */
			if (SvLEN(sv))
			    Safefree(SvPVX(sv));
			SvLEN(sv)=SvCUR(sv)=0;
		    }
d1383 1
a1383 28
    register IV count;
    dPOPss;
    if (SvGMAGICAL(sv))
	 mg_get(sv);
    if (SvIOKp(sv)) {
	 if (SvUOK(sv)) {
	      UV uv = SvUV(sv);
	      if (uv > IV_MAX)
		   count = IV_MAX; /* The best we can do? */
	      else
		   count = uv;
	 } else {
	      IV iv = SvIV(sv);
	      if (iv < 0)
		   count = 0;
	      else
		   count = iv;
	 }
    }
    else if (SvNOKp(sv)) {
	 NV nv = SvNV(sv);
	 if (nv < 0.0)
	      count = 0;
	 else
	      count = (IV)nv;
    }
    else
	 count = SvIVx(sv);
a1387 2
	static const char oom_list_extend[] =
	  "Out of memory during list extend";
a1389 4
	MEM_WRAP_CHECK_1(max, SV*, oom_list_extend);
	/* Did the max computation overflow? */
	if (items > 0 && max > 0 && (max < items || max < count))
	   Perl_croak(aTHX_ oom_list_extend);
a1433 2
	static const char oom_string_extend[] =
	  "Out of memory during string extend";
a1441 4
		IV max = count * len;
		if (len > ((MEM_SIZE)~0)/count)
		     Perl_croak(aTHX_ oom_string_extend);
	        MEM_WRAP_CHECK_1(max, char, oom_string_extend);
a2361 1
	(void)SvPV_nomg(sv,len); /* force check for uninit var */
a2408 1
	      SvUTF8_off(TARG);
d2775 1
a2775 3
      if (!SvOK(TOPs))
        SETu(0);
      else if (SvIOK(TOPs)) {
d2809 1
a2809 3
      if (!SvOK(TOPs))
        SETu(0);
      else if (SvIOK(TOPs)) {
a3018 13
	/* we either return a PV or an LV. If the TARG hasn't been used
	 * before, or is of that type, reuse it; otherwise use a mortal
	 * instead. Note that LVs can have an extended lifetime, so also
	 * dont reuse if refcount > 1 (bug #20933) */
	if (SvTYPE(TARG) > SVt_NULL) {
	    if ( (SvTYPE(TARG) == SVt_PVLV)
		    ? (!lvalue || SvREFCNT(TARG) > 1)
		    : lvalue)
	    {
		TARG = sv_newmortal();
	    }
	}

d3055 2
d3767 1
a3767 4
	    if (SP > MARK)
		*++MARK = *SP;
	    else
		*++MARK = &PL_sv_undef;
d4624 1
a4624 1
	    *SP-- = &PL_sv_undef;
@


1.1.1.9
log
@perl 5.8.6 from CPAN
@
text
@a15 7
/* This file contains general pp ("push/pop") functions that execute the
 * opcodes that make up a perl program. A typical pp function expects to
 * find its arguments on the stack, and usually pushes its results onto
 * the stack, hence the 'pp' terminology. Each OP structure contains
 * a pointer to the relevant pp_foo() function.
 */

a154 2
		if (SvREADONLY(sv))
		    Perl_croak(aTHX_ PL_no_modify);
d172 1
a172 1
			SvOOK_off(sv);		/* backoff */
d819 1
a819 1
	    SvOOK_off(sv);
d824 1
a824 1
	SvOK_off(sv);
d1729 5
a1733 5
    if (SvROK(TOPs) && !SvAMAGIC(TOPs) && SvROK(TOPm1s) && !SvAMAGIC(TOPm1s)) {
	SP--;
	SETs(boolSV(SvRV(TOPs) < SvRV(TOPp1s)));
	RETURN;
    }
d1807 1
a1807 1
    if (SvROK(TOPs) && !SvAMAGIC(TOPs) && SvROK(TOPm1s) && !SvAMAGIC(TOPm1s)) {
d1885 1
a1885 1
    if (SvROK(TOPs) && !SvAMAGIC(TOPs) && SvROK(TOPm1s) && !SvAMAGIC(TOPm1s)) {
d1963 1
a1963 1
    if (SvROK(TOPs) && !SvAMAGIC(TOPs) && SvROK(TOPm1s) && !SvAMAGIC(TOPm1s)) {
d1980 1
a1980 1
    if (SvROK(TOPs) && !SvAMAGIC(TOPs) && SvROK(TOPm1s) && !SvAMAGIC(TOPm1s)) {
d2049 1
a2049 1
    if (SvROK(TOPs) && !SvAMAGIC(TOPs) && SvROK(TOPm1s) && !SvAMAGIC(TOPm1s)) {
d3124 1
a3124 1
		SvOK_off(TARG);
d3739 1
a3739 1
	*++MARK = SP > ORIGMARK ? *SP : &PL_sv_undef;
d3959 1
a3959 1
	*++MARK = SP > ORIGMARK ? *SP : &PL_sv_undef;
a4134 7
    /* make new elements SVs now: avoid problems if they're from the array */
    for (dst = MARK, i = newlen; i; i--) {
        SV *h = *dst;
	*dst = NEWSV(46, 0);
	sv_setsv(*dst++, h);
    }

d4191 5
a4195 1
 	    Copy( tmparyval, AvARRAY(ary) + offset, newlen, SV* );
d4234 3
a4236 2
	if (newlen) {
	    Copy( MARK, AvARRAY(ary) + offset, newlen, SV* );
a4237 1

d4444 1
d4497 2
a4498 1
	    SAVESWITCHSTACK(PL_curstack, ary);
d4667 1
a4692 3
    PUTBACK;
    LEAVE_SCOPE(oldsave); /* may undo an earlier SWITCHSTACK */
    SPAGAIN;
d4695 2
@


1.1.1.10
log
@perl 5.8.8 import
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006, by Larry Wall and others
a37 8
/*
 * Some BSDs and Cygwin default to POSIX math instead of IEEE.
 * This switches them over to IEEE.
 */
#if defined(LIBM_LIB_VERSION)
    _LIB_VERSION_TYPE _LIB_VERSION = _IEEE_;
#endif

d73 1
a73 1
	const I32 maxarg = AvFILL((AV*)TARG) + 1;
d78 1
a78 1
		SV ** const svp = av_fetch((AV*)TARG, i, FALSE);
d88 2
a89 2
	SV* const sv = sv_newmortal();
	const I32 maxarg = AvFILL((AV*)TARG) + 1;
d116 1
a116 1
	SV* const sv = Perl_hv_scalar(aTHX_ (HV*)TARG);
d139 1
a139 1
	    GV * const gv = (GV*) sv_newmortal();
d165 1
d170 1
a170 1
			const char *name = SvPV(namesv, len);
d175 2
a176 2
			const char *name = CopSTASHPV(PL_curcop);
			gv = newGVgen((char *)name);
d180 5
a184 4
		    if (SvPVX_const(sv)) {
			SvPV_free(sv);
			SvLEN_set(sv, 0);
                        SvCUR_set(sv, 0);
d186 1
a186 1
		    SvRV_set(sv, (SV*)gv);
d277 1
a277 1
	sv = GvSVn(gv);
d298 1
a298 1
    AV *const av = (AV*)TOPs;
d329 2
d332 1
a332 1
	    const MAGIC * const mg = mg_find(sv, PERL_MAGIC_regex_global);
d380 1
a380 1
	const char *s = SvPVX_const(TOPs);
d382 3
a384 1
	    const int code = keyword((char *)s + 6, SvCUR(TOPs) - 6);
d391 1
a391 2
		if (code == -KEY_chop || code == -KEY_chomp
			|| code == -KEY_exec || code == -KEY_system)
d409 2
d434 1
a434 1
	ret = sv_2mortal(newSVpvn(SvPVX_const(cv), SvCUR(cv)));
d503 1
a503 1
    SvRV_set(rv, sv);
d511 4
a514 2
    const char *pv;
    SV * const sv = POPs;
d522 2
a523 1
    pv = sv_reftype(SvRV(sv),TRUE);
d536 1
a536 1
	SV * const ssv = POPs;
d538 1
a538 1
	const char *ptr;
d542 2
a543 2
	ptr = SvPV_const(ssv,len);
	if (len == 0 && ckWARN(WARN_MISC))
d555 4
d560 1
d562 4
a565 5
    SV *sv = POPs;
    const char * const elem = SvPV_nolen_const(sv);
    GV * const gv = (GV*)POPs;
    SV * tmpRef = Nullsv;

d567 15
a581 48
    if (elem) {
	/* elem will always be NUL terminated.  */
	const char * const second_letter = elem + 1;
	switch (*elem) {
	case 'A':
	    if (strEQ(second_letter, "RRAY"))
		tmpRef = (SV*)GvAV(gv);
	    break;
	case 'C':
	    if (strEQ(second_letter, "ODE"))
		tmpRef = (SV*)GvCVu(gv);
	    break;
	case 'F':
	    if (strEQ(second_letter, "ILEHANDLE")) {
		/* finally deprecated in 5.8.0 */
		deprecate("*glob{FILEHANDLE}");
		tmpRef = (SV*)GvIOp(gv);
	    }
	    else
		if (strEQ(second_letter, "ORMAT"))
		    tmpRef = (SV*)GvFORM(gv);
	    break;
	case 'G':
	    if (strEQ(second_letter, "LOB"))
		tmpRef = (SV*)gv;
	    break;
	case 'H':
	    if (strEQ(second_letter, "ASH"))
		tmpRef = (SV*)GvHV(gv);
	    break;
	case 'I':
	    if (*second_letter == 'O' && !elem[2])
		tmpRef = (SV*)GvIOp(gv);
	    break;
	case 'N':
	    if (strEQ(second_letter, "AME"))
		sv = newSVpvn(GvNAME(gv), GvNAMELEN(gv));
	    break;
	case 'P':
	    if (strEQ(second_letter, "ACKAGE")) {
		const char *name = HvNAME_get(GvSTASH(gv));
		sv = newSVpv(name ? name : "__ANON__", 0);
	    }
	    break;
	case 'S':
	    if (strEQ(second_letter, "CALAR"))
		tmpRef = GvSV(gv);
	    break;
d583 28
d653 2
a654 2
	    Newx(PL_screamfirst, 256, I32);
	    Newx(PL_screamnext, PL_maxscream, I32);
d673 1
a673 1
	register const I32 ch = s[pos];
d719 1
a719 1
    XPUSHTARG;
d737 1
a737 1
    XPUSHi(count);
d744 1
a744 1
    register SV* const sv = POPs;
d746 1
d800 1
a800 1
	if (cv_const_sv((CV*)sv) && ckWARN(WARN_MISC))
d818 1
a818 1
	    Newxz(gp, 1, GP);
d827 3
a829 2
	if (SvTYPE(sv) >= SVt_PV && SvPVX_const(sv) && SvLEN(sv)) {
	    SvPV_free(sv);
d848 1
a848 1
	SvIV_set(TOPs, SvIVX(TOPs) - 1);
d866 1
a866 1
	SvIV_set(TOPs, SvIVX(TOPs) + 1);
d888 1
a888 1
	SvIV_set(TOPs, SvIVX(TOPs) - 1);
d912 4
a915 7
	SvIV_please(TOPs);
	if (SvIOK(TOPs)) {
	    SvIV_please(TOPm1s);
	    if (SvIOK(TOPm1s)) {
		UV power;
		bool baseuok;
		UV baseuv;
d917 14
a930 10
		if (SvUOK(TOPs)) {
		    power = SvUVX(TOPs);
		} else {
		    const IV iv = SvIVX(TOPs);
		    if (iv >= 0) {
			power = iv;
		    } else {
			goto float_it; /* Can't do negative powers this way.  */
		    }
		}
d932 10
a941 12
		baseuok = SvUOK(TOPm1s);
		if (baseuok) {
		    baseuv = SvUVX(TOPm1s);
		} else {
		    const IV iv = SvIVX(TOPm1s);
		    if (iv >= 0) {
			baseuv = iv;
			baseuok = TRUE; /* effectively it's a UV now */
		    } else {
			baseuv = -iv; /* abs, baseuok == false records sign */
		    }
		}
d957 1
d959 12
a970 9
		    if (power & 1) {
			result *= base;
		    }
		    while (power >>= 1) {
			base *= base;
			if (power & 1) {
			    result *= base;
			}
		    }
d977 8
a984 6
		    register unsigned int diff = 8 * sizeof(UV);
		    while (diff >>= 1) {
			highbit -= diff;
			if (baseuv >> highbit) {
			    highbit += diff;
			}
d992 4
a995 7
			const bool odd_power = (bool)(power & 1);
			if (odd_power) {
			    result *= base;
			}
			while (power >>= 1) {
			    base *= base;
			    if (power & 1) {
d997 2
d1057 1
a1057 1
		const IV aiv = SvIVX(TOPm1s);
d1068 1
a1068 1
		const IV biv = SvIVX(TOPs);
d1189 1
a1189 1
		const IV biv = SvIVX(TOPs);
d1210 1
a1210 1
		const IV aiv = SvIVX(TOPm1s);
d1236 1
a1236 1
		const UV result = left / right;
d1285 1
a1285 1
		const IV biv = SvIVX(POPs);
d1404 1
a1404 1
	      const UV uv = SvUV(sv);
d1418 1
a1418 1
	 const NV nv = SvNV(sv);
d1492 1
a1492 1
		STRLEN max = (UV)count * len;
d1496 1
a1496 1
		SvGROW(TARG, max + 1);
d1498 1
a1498 1
		SvCUR_set(TARG, SvCUR(TARG) * count);
d1549 1
a1549 1
		    register const IV aiv = SvIVX(TOPm1s);
d1569 1
a1569 1
		register const IV biv = SvIVX(TOPs);
d1643 1
a1643 1
      const IV shift = POPi;
d1660 1
a1660 1
      const IV shift = POPi;
d1685 2
a1686 2
		const IV aiv = SvIVX(TOPm1s);
		const IV biv = SvIVX(TOPs);
d1693 2
a1694 2
		const UV auv = SvUVX(TOPm1s);
		const UV buv = SvUVX(TOPs);
d1702 3
a1704 1
		const IV biv = SvIVX(TOPs);
d1716 1
a1716 1
		const IV aiv = SvIVX(TOPm1s);
d1719 1
d1763 3
a1765 3
		const IV aiv = SvIVX(TOPm1s);
		const IV biv = SvIVX(TOPs);

d1771 2
a1772 2
		const UV auv = SvUVX(TOPm1s);
		const UV buv = SvUVX(TOPs);
d1780 3
a1782 2
		const IV biv = SvIVX(TOPs);

d1794 1
a1794 1
		const IV aiv = SvIVX(TOPm1s);
d1797 1
d1841 2
a1842 2
		const IV aiv = SvIVX(TOPm1s);
		const IV biv = SvIVX(TOPs);
d1858 3
a1860 2
		const IV biv = SvIVX(TOPs);

d1872 1
a1872 1
		const IV aiv = SvIVX(TOPm1s);
d1874 2
a1875 1

d1919 3
a1921 3
		const IV aiv = SvIVX(TOPm1s);
		const IV biv = SvIVX(TOPs);

d1927 3
a1929 3
		const UV auv = SvUVX(TOPm1s);
		const UV buv = SvUVX(TOPs);

d1936 3
a1938 2
		const IV biv = SvIVX(TOPs);

d1950 1
a1950 1
		const IV aiv = SvIVX(TOPm1s);
d1952 2
a1953 1

d2010 3
a2012 3
		const UV buv = SvUVX(POPs);
		const UV auv = SvUVX(TOPs);

d2071 2
a2072 2
	    const bool leftuvok = SvUOK(TOPm1s);
	    const bool rightuvok = SvUOK(TOPs);
d2075 2
a2076 2
		const IV leftiv = SvIVX(TOPm1s);
		const IV rightiv = SvIVX(TOPs);
d2085 2
a2086 2
		const UV leftuv = SvUVX(TOPm1s);
		const UV rightuv = SvUVX(TOPs);
d2095 4
a2098 1
		const IV rightiv = SvIVX(TOPs);
d2103 1
a2103 1
		    const UV leftuv = SvUVX(TOPm1s);
d2113 4
a2116 1
		const IV leftiv = SvIVX(TOPm1s);
d2121 1
a2121 1
		    const UV rightuv = SvUVX(TOPs);
d2169 1
a2169 1
      const int cmp = (IN_LOCALE_RUNTIME
d2182 1
a2182 1
      const int cmp = (IN_LOCALE_RUNTIME
d2195 1
a2195 1
      const int cmp = (IN_LOCALE_RUNTIME
d2208 1
a2208 1
      const int cmp = (IN_LOCALE_RUNTIME
d2241 1
a2241 1
      const int cmp = (IN_LOCALE_RUNTIME
d2256 1
a2256 1
	  const IV i = SvIV(left) & SvIV(right);
d2260 1
a2260 1
	  const UV u = SvUV(left) & SvUV(right);
d2279 1
a2279 1
	  const IV i = (USE_LEFT(left) ? SvIV(left) : 0) ^ SvIV(right);
d2283 1
a2283 1
	  const UV u = (USE_LEFT(left) ? SvUV(left) : 0) ^ SvUV(right);
d2302 1
a2302 1
	  const IV i = (USE_LEFT(left) ? SvIV(left) : 0) | SvIV(right);
d2306 1
a2306 1
	  const UV u = (USE_LEFT(left) ? SvUV(left) : 0) | SvUV(right);
d2323 1
a2323 1
	const int flags = SvFLAGS(sv);
d2355 1
a2355 1
	    const char *s = SvPV_const(sv, len);
d2403 1
a2403 1
	  const IV i = ~SvIV(sv);
d2407 1
a2407 1
	  const UV u = ~SvUV(sv);
d2416 1
a2416 1
	(void)SvPV_nomg_const(sv,len); /* force check for uninit var */
d2431 1
a2431 1
	    const UV c = utf8n_to_uvchr(tmps, send-tmps, &l, UTF8_ALLOW_ANYUV);
d2443 1
a2443 1
	      Newxz(result, targlen + 1, U8);
d2445 1
a2445 1
		  const UV c = utf8n_to_uvchr(tmps, send-tmps, &l, UTF8_ALLOW_ANYUV);
d2455 1
a2455 1
	      Newxz(result, nchar + 1, U8);
d2457 1
a2457 1
		  const U8 c = (U8)utf8n_to_uvchr(tmps, 0, &l, UTF8_ALLOW_ANY);
d2557 1
a2557 1
	           Perl_pp_i_modulo_0;
d2708 4
a2711 2
      const NV value = POPn;
      XPUSHn(Perl_sin(value));
d2720 4
a2723 2
      const NV value = POPn;
      XPUSHn(Perl_cos(value));
d2792 2
a2793 1
      const NV value = POPn;
d2798 2
a2799 1
      XPUSHn(Perl_log(value));
d2808 2
a2809 1
      const NV value = POPn;
d2814 2
a2815 1
      XPUSHn(Perl_sqrt(value));
d2824 2
a2825 1
      const IV iv = TOPi; /* attempt to convert to IV if possible. */
d2835 1
a2835 1
	    const UV uv = TOPu;
d2840 1
a2840 1
	  const NV value = TOPn;
d2865 1
a2865 1
      const IV iv = TOPi;
d2887 1
a2887 1
	const NV value = TOPn;
d2889 2
a2890 3
	  SETn(-value);
	else
	  SETn(value);
d2900 1
a2900 1
    const char *tmps;
d2905 1
a2905 1
    SV* const sv = POPs;
d2907 1
a2907 1
    tmps = (SvPV_const(sv, len));
d2911 1
a2911 1
	 SV* const tsv = sv_2mortal(newSVsv(sv));
d2915 1
a2915 1
	 tmps = SvPV_const(tsv, len);
d2917 1
a2917 1
    result_uv = grok_hex ((char *)tmps, &len, &flags, &result_nv);
d2930 1
a2930 1
    const char *tmps;
d2935 1
a2935 1
    SV* const sv = POPs;
d2937 1
a2937 1
    tmps = (SvPV_const(sv, len));
d2941 1
a2941 1
	 SV* const tsv = sv_2mortal(newSVsv(sv));
d2945 1
a2945 1
	 tmps = SvPV_const(tsv, len);
d2952 1
a2952 1
        result_uv = grok_hex ((char *)tmps, &len, &flags, &result_nv);
d2954 1
a2954 1
        result_uv = grok_bin ((char *)tmps, &len, &flags, &result_nv);
d2956 1
a2956 1
        result_uv = grok_oct ((char *)tmps, &len, &flags, &result_nv);
d2991 3
a2993 3
    const I32 lvalue = PL_op->op_flags & OPf_MOD || LVRET;
    const char *tmps;
    const I32 arybase = PL_curcop->cop_arybase;
d2995 1
a2995 1
    const char *repl = 0;
d2997 1
a2997 1
    const int num_args = PL_op->op_private & 7;
d3006 1
a3006 1
	    repl = SvPV_const(repl_sv, repl_len);
d3022 1
a3022 1
    tmps = SvPV_const(sv, curlen);
d3074 2
a3075 2
	const I32 upos = pos;
	const I32 urem = rem;
d3104 1
a3104 1
		repl = SvPV_const(repl_sv_copy, repl_len);
d3107 1
a3107 1
	    sv_insert(sv, pos, rem, (char *)repl, repl_len);
d3116 2
a3117 1
		    SvPV_force_nolen(sv);
d3153 4
a3156 4
    register const IV size   = POPi;
    register const IV offset = POPi;
    register SV * const src = POPs;
    const I32 lvalue = PL_op->op_flags & OPf_MOD || LVRET;
a3185 1
    SV *temp = Nullsv;
d3188 2
a3189 2
    const char *tmps;
    const char *tmps2;
d3191 1
a3191 3
    const I32 arybase = PL_curcop->cop_arybase;
    int big_utf8;
    int little_utf8;
d3199 2
a3200 23
    big_utf8 = DO_UTF8(big);
    little_utf8 = DO_UTF8(little);
    if (big_utf8 ^ little_utf8) {
	/* One needs to be upgraded.  */
	SV * const bytes = little_utf8 ? big : little;
	STRLEN len;
	const char * const p = SvPV_const(bytes, len);

	temp = newSVpvn(p, len);

	if (PL_encoding) {
	    sv_recode_to_utf8(temp, PL_encoding);
	} else {
	    sv_utf8_upgrade(temp);
	}
	if (little_utf8) {
	    big = temp;
	    big_utf8 = TRUE;
	} else {
	    little = temp;
	}
    }
    if (big_utf8 && offset > 0)
a3201 1
    tmps = SvPV_const(big, biglen);
d3211 1
a3211 1
    if (retval > 0 && big_utf8)
a3212 2
    if (temp)
	SvREFCNT_dec(temp);
a3221 1
    SV *temp = Nullsv;
d3226 3
a3228 5
    const char *tmps;
    const char *tmps2;
    const I32 arybase = PL_curcop->cop_arybase;
    int big_utf8;
    int little_utf8;
d3234 2
a3235 25
    big_utf8 = DO_UTF8(big);
    little_utf8 = DO_UTF8(little);
    if (big_utf8 ^ little_utf8) {
	/* One needs to be upgraded.  */
	SV * const bytes = little_utf8 ? big : little;
	STRLEN len;
	const char *p = SvPV_const(bytes, len);

	temp = newSVpvn(p, len);

	if (PL_encoding) {
	    sv_recode_to_utf8(temp, PL_encoding);
	} else {
	    sv_utf8_upgrade(temp);
	}
	if (little_utf8) {
	    big = temp;
	    big_utf8 = TRUE;
	} else {
	    little = temp;
	}
    }
    tmps2 = SvPV_const(little, llen);
    tmps = SvPV_const(big, blen);

d3239 1
a3239 1
	if (offset > 0 && big_utf8)
d3252 1
a3252 1
    if (retval > 0 && big_utf8)
a3253 2
    if (temp)
	SvREFCNT_dec(temp);
d3275 1
a3275 1
    const U8 *s = (U8*)SvPV_const(argsv, len);
d3285 1
a3285 1
	   utf8n_to_uvchr((U8 *)s, UTF8_MAXBYTES, 0, UTF8_ALLOW_ANYUV) :
d3302 1
a3302 1
	SvCUR_set(TARG, tmps - SvPVX_const(TARG));
d3336 1
a3337 1
    dSP; dTARGET;
d3339 1
d3341 1
a3341 1
    const char *tmps = SvPV_const(left, len);
d3347 1
a3347 1
	 SV* const tsv = sv_2mortal(newSVsv(left));
d3351 1
a3351 1
	 tmps = SvPV_const(tsv, len);
d3372 1
a3372 1
    sv_setpv(TARG, fcrypt(tmps, SvPV_nolen_const(right)));
d3374 1
a3374 1
    sv_setpv(TARG, PerlProc_crypt(tmps, SvPV_nolen_const(right)));
d3388 1
a3388 1
    const U8 *s;
d3393 1
a3393 1
	(s = (const U8*)SvPV_nomg_const(sv, slen)) && slen &&
d3395 1
a3395 1
	U8 tmpbuf[UTF8_MAXBYTES_CASE+1];
d3399 3
a3401 2
	utf8_to_uvchr((U8 *)s, &ulen);
	toTITLE_utf8((U8 *)s, tmpbuf, &tculen);
d3403 1
a3403 1
	if (!SvPADTMP(sv) || SvREADONLY(sv) || ulen != tculen) {
a3423 1
	U8 *s1;
d3431 2
a3432 2
	s1 = (U8*)SvPV_force_nomg(sv, slen);
	if (*s1) {
d3436 1
a3436 1
		*s1 = toUPPER_LC(*s1);
d3439 1
a3439 1
		*s1 = toUPPER(*s1);
d3450 1
a3450 1
    const U8 *s;
d3455 1
a3455 1
	(s = (const U8*)SvPV_nomg_const(sv, slen)) && slen &&
d3458 7
a3464 2
	STRLEN lculen;
	U8 tmpbuf[UTF8_MAXBYTES_CASE+1];
d3466 1
a3466 4
	utf8_to_uvchr((U8 *)s, &ulen);
	toLOWER_utf8((U8 *)s, tmpbuf, &lculen);

	if (!SvPADTMP(sv) || SvREADONLY(sv) || ulen != lculen) {
d3468 1
a3468 1
	    sv_setpvn(TARG, (char*)tmpbuf, lculen);
a3479 1
	U8 *s1;
d3487 2
a3488 2
	s1 = (U8*)SvPV_force_nomg(sv, slen);
	if (*s1) {
d3492 1
a3492 1
		*s1 = toLOWER_LC(*s1);
d3495 1
a3495 1
		*s1 = toLOWER(*s1);
d3506 1
d3514 2
a3515 3
	const U8 *s;
	const U8 *send;
	U8 tmpbuf[UTF8_MAXBYTES+1];
d3517 1
a3517 1
	s = (const U8*)SvPV_nomg_const(sv,len);
d3524 1
a3524 1
	    STRLEN min = len + 1;
d3527 1
a3527 1
	    SvGROW(TARG, min);
d3532 1
a3532 15
		STRLEN u = UTF8SKIP(s);

		toUPPER_utf8((U8 *)s, tmpbuf, &ulen);
		if (ulen > u && (SvLEN(TARG) < (min += ulen - u))) {
		    /* If the eventually required minimum size outgrows
		     * the available space, we need to grow. */
		    UV o = d - (U8*)SvPVX_const(TARG);

		    /* If someone uppercases one million U+03B0s we
		     * SvGROW() one million times.  Or we could try
		     * guessing how much to allocate without allocating
		     * too much. Such is life. */
		    SvGROW(TARG, min);
		    d = (U8*)SvPVX(TARG) + o;
		}
d3535 1
a3535 1
		s += u;
d3539 1
a3539 1
	    SvCUR_set(TARG, d - (U8*)SvPVX_const(TARG));
a3543 1
	U8 *s;
d3553 1
a3553 1
	    register const U8 *send = s + len;
d3575 1
a3580 1
	const U8 *s;
d3583 2
a3584 2
	const U8 *send;
	U8 tmpbuf[UTF8_MAXBYTES_CASE+1];
d3586 1
a3586 1
	s = (const U8*)SvPV_nomg_const(sv,len);
d3593 1
a3593 1
	    STRLEN min = len + 1;
d3596 1
a3596 1
	    SvGROW(TARG, min);
d3601 2
a3602 4
		const STRLEN u = UTF8SKIP(s);
		const UV uv = toLOWER_utf8((U8 *)s, tmpbuf, &ulen);

#define GREEK_CAPITAL_LETTER_SIGMA 0x03A3 /* Unicode U+03A3 */
d3616 1
a3616 3
		      * "should be": in other words,
		      * this is not implemented yet.
		      * See lib/unicore/SpecialCasing.txt.
a3618 12
		if (ulen > u && (SvLEN(TARG) < (min += ulen - u))) {
		    /* If the eventually required minimum size outgrows
		     * the available space, we need to grow. */
		    UV o = d - (U8*)SvPVX_const(TARG);

		    /* If someone lowercases one million U+0130s we
		     * SvGROW() one million times.  Or we could try
		     * guessing how much to allocate without allocating.
		     * too much.  Such is life. */
		    SvGROW(TARG, min);
		    d = (U8*)SvPVX(TARG) + o;
		}
d3621 1
a3621 1
		s += u;
d3625 1
a3625 1
	    SvCUR_set(TARG, d - (U8*)SvPVX_const(TARG));
a3629 1
	U8 *s;
d3640 1
a3640 1
	    register const U8 * const send = s + len;
d3661 1
a3661 1
    SV * const sv = TOPs;
d3663 2
a3664 1
    register const char *s = SvPV_const(sv,len);
a3667 1
	register char *d;
d3698 1
a3698 1
	SvCUR_set(TARG, d - SvPVX_const(TARG));
d3714 5
a3718 2
    register AV* const av = (AV*)POPs;
    register const I32 lval = (PL_op->op_flags & OPf_MOD || LVRET);
a3720 1
	const I32 arybase = PL_curcop->cop_arybase;
a3721 1
	    register SV **svp;
d3724 1
a3724 1
		const I32 elem = SvIVx(*svp);
d3732 1
a3732 2
	    register SV **svp;
	    I32 elem = SvIVx(*MARK);
d3759 1
a3759 1
    HV * const hash = (HV*)POPs;
d3761 1
a3761 1
    const I32 gimme = GIMME_V;
d3771 1
a3771 1
	SV* const sv = hv_iterkeysv(entry);
d3802 4
a3805 2
    const I32 gimme = GIMME_V;
    const I32 discard = (gimme == G_VOID) ? G_DISCARD : 0;
d3809 3
a3811 2
	HV * const hv = (HV*)POPs;
	const U32 hvtype = SvTYPE(hv);
d3814 1
a3814 1
		SV * const sv = hv_delete_ent(hv, *MARK, discard, 0);
d3821 1
a3821 1
		    SV * const sv = av_delete((AV*)hv, SvIV(*MARK), discard);
d3827 1
a3827 1
		    SV * const sv = avhv_delete_ent((AV*)hv, *MARK, discard, 0);
d3847 1
a3847 2
	HV * const hv = (HV*)POPs;
	SV *sv;
d3874 1
d3876 1
a3876 1
	CV * const cv = sv_2cv(sv, &hv, &gv, FALSE);
d3906 2
a3907 2
    register HV * const hv = (HV*)POPs;
    register const I32 lval = (PL_op->op_flags & OPf_MOD || LVRET);
d3909 1
a3909 1
    const bool localizing = PL_op->op_private & OPpLVAL_INTRO ? TRUE : FALSE;
d3950 2
a3951 1
		    DIE(aTHX_ PL_no_helem_sv, keysv);
d3958 1
a3958 1
			const char *key = SvPV_const(keysv, keylen);
d3992 7
a3998 6
    SV ** const lastrelem = PL_stack_sp;
    SV ** const lastlelem = PL_stack_base + POPMARK;
    SV ** const firstlelem = PL_stack_base + POPMARK + 1;
    register SV ** const firstrelem = lastlelem + 1;
    const I32 arybase = PL_curcop->cop_arybase;
    I32 is_something_there = PL_op->op_flags & OPf_MOD;
d4000 1
a4000 1
    register const I32 max = lastrelem - lastlelem;
d4002 1
d4005 1
a4005 1
	I32 ix = SvIVx(*lastlelem);
d4024 1
a4024 1
	I32 ix = SvIVx(*lelem);
d4047 2
a4048 2
    const I32 items = SP - MARK;
    SV * const av = sv_2mortal((SV*)av_make(items, MARK+1));
d4057 1
a4057 1
    HV* const hv = (HV*)sv_2mortal((SV*)newHV());
d4060 2
a4061 2
	SV * const key = *++MARK;
	SV * const val = NEWSV(46, 0);
d4086 1
a4086 1
    const MAGIC * const mg = SvTIED_mg((SV*)ary, PERL_MAGIC_tied);
d4088 1
a4088 1
    if (mg) {
d4146 3
a4148 2
        SV * const h = *dst;
	*dst++ = newSVsv(h);
d4153 1
a4153 1
	    Newx(tmparyval, newlen, SV*);	/* so remember insertion */
d4190 1
a4190 1
	    SvPV_set(ary, (char*)(AvARRAY(ary) - diff)); /* diff is negative */
d4213 1
a4213 1
	    Newx(tmparyval, length, SV*);	/* so remember deletion */
d4227 1
a4227 1
		SvPV_set(ary, (char*)(AvARRAY(ary) - diff));/* diff is positive */
d4285 2
a4286 1
    const MAGIC * const mg = SvTIED_mg((SV*)ary, PERL_MAGIC_tied);
d4288 1
a4288 1
    if (mg) {
d4300 1
a4300 1
	    SV * const sv = NEWSV(51, 0);
d4314 2
a4315 2
    AV * const av = (AV*)POPs;
    SV * const sv = av_pop(av);
d4325 2
a4326 2
    AV * const av = (AV*)POPs;
    SV * const sv = av_shift(av);
d4340 3
a4342 1
    const MAGIC * const mg = SvTIED_mg((SV*)ary, PERL_MAGIC_tied);
d4344 1
a4344 1
    if (mg) {
a4353 1
	register I32 i = 0;
d4356 2
a4357 1
	    SV * const sv = newSVsv(*++MARK);
d4369 2
a4370 1
    SV ** const oldsp = SP;
d4375 1
a4375 1
	    register SV * const tmp = *MARK;
d4398 1
a4398 1
		const U8* send = (U8*)(s + len);
d4439 1
a4439 1
    SV * const sv = POPs;
d4441 3
a4443 3
    register const char *s = SvPV_const(sv, len);
    const bool do_utf8 = DO_UTF8(sv);
    const char *strend = s + len;
d4447 1
a4447 1
    register const char *m;
d4449 1
a4449 1
    const STRLEN slen = do_utf8 ? utf8_length((U8*)s, (U8*)strend) : (strend - s);
d4451 3
a4453 2
    const char *orig;
    const I32 origlimit = limit;
d4456 2
a4457 2
    const I32 gimme = GIMME_V;
    const I32 oldsave = PL_savestack_ix;
a4501 1
		I32 i;
d4541 2
a4542 1
	    dstr = newSVpvn(s, m-s);
d4556 1
a4556 1
    else if (rx->precomp[0] == '^' && rx->precomp[1] == '\0') {
d4558 2
a4559 2
	    for (m = s; m < strend && *m != '\n'; m++)
		;
d4563 2
a4564 1
	    dstr = newSVpvn(s, m-s);
d4577 2
a4578 2
	const int tail = (rx->reganch & RE_INTUIT_TAIL);
	SV * const csv = CALLREG_INTUIT_STRING(aTHX_ rx);
d4582 2
a4583 1
	    const char c = *SvPV_nolen_const(csv);
d4585 2
a4586 2
		for (m = s; m < strend && *m != c; m++)
		    ;
d4589 2
a4590 1
		dstr = newSVpvn(s, m-s);
d4605 1
d4609 1
d4611 2
a4612 1
		dstr = newSVpvn(s, m-s);
a4630 1
	    I32 rex_return;
d4632 1
a4632 2
	    rex_return = CALLREGEXEC(aTHX_ rx, (char*)s, (char*)strend, (char*)orig, 1 ,
			    sv, NULL, 0);
d4634 1
a4634 1
	    if (rex_return == 0)
d4645 2
a4646 1
	    dstr = newSVpvn(s, m-s);
a4652 1
		I32 i;
d4661 2
a4662 1
			dstr = newSVpvn(s, m-s);
d4683 3
a4685 2
        const STRLEN l = strend - s;
	dstr = newSVpvn(s, l);
a4725 1
		I32 i;
a4792 10

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 noet:
 */
@


1.1.1.11
log
@import perl 5.10.0 from CPAN
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007 by Larry Wall and others
a49 1
    dVAR;
d56 5
d65 1
a65 1
    dVAR; dSP; dTARGET;
d68 1
a68 2
	if (!(PL_op->op_private & OPpPAD_STATE))
	    SAVECLEARSV(PAD_SVl(PL_op->op_targ));
d86 1
a86 1
		SV * const * const svp = av_fetch((AV*)TARG, i, FALSE);
d106 1
a106 1
    dVAR; dSP; dTARGET;
d111 1
a111 2
	if (!(PL_op->op_private & OPpPAD_STATE))
	    SAVECLEARSV(PAD_SVl(PL_op->op_targ));
d130 5
d139 1
a139 1
    dVAR; dSP; dTOPss;
d150 1
a150 1
	    SvREFCNT_inc_void_NN(sv);
d158 3
d176 3
a178 3
			SV * const namesv = PAD_SV(cUNOP->op_targ);
			const char * const name = SvPV(namesv, len);
			gv = (GV*)newSV(0);
d182 2
a183 2
			const char * const name = CopSTASHPV(PL_curcop);
			gv = newGVgen(name);
d187 1
a187 1
		    else if (SvPVX_const(sv)) {
d201 1
a201 1
		    report_uninit(sv);
d204 1
d208 5
a212 4
		SV * const temp = (SV*)gv_fetchsv(sv, 0, SVt_PVGV);
		if (!temp
		    && (!is_gv_magical_sv(sv,0)
			|| !(sv = (SV*)gv_fetchsv(sv, GV_ADD, SVt_PVGV)))) {
a214 1
		sv = temp;
d218 2
a219 9
		    DIE(aTHX_ PL_no_symref_sv, sv, "a symbol");
		if ((PL_op->op_private & (OPpLVAL_INTRO|OPpDONT_INIT_GV))
		    == OPpDONT_INIT_GV) {
		    /* We are the target of a coderef assignment.  Return
		       the scalar unchanged, and let pp_sasssign deal with
		       things.  */
		    RETURN;
		}
		sv = (SV*)gv_fetchsv(sv, GV_ADD, SVt_PVGV);
a228 44
/* Helper function for pp_rv2sv and pp_rv2av  */
GV *
Perl_softref2xv(pTHX_ SV *const sv, const char *const what, const U32 type,
		SV ***spp)
{
    dVAR;
    GV *gv;

    if (PL_op->op_private & HINT_STRICT_REFS) {
	if (SvOK(sv))
	    Perl_die(aTHX_ PL_no_symref_sv, sv, what);
	else
	    Perl_die(aTHX_ PL_no_usym, what);
    }
    if (!SvOK(sv)) {
	if (PL_op->op_flags & OPf_REF)
	    Perl_die(aTHX_ PL_no_usym, what);
	if (ckWARN(WARN_UNINITIALIZED))
	    report_uninit(sv);
	if (type != SVt_PV && GIMME_V == G_ARRAY) {
	    (*spp)--;
	    return NULL;
	}
	**spp = &PL_sv_undef;
	return NULL;
    }
    if ((PL_op->op_flags & OPf_SPECIAL) &&
	!(PL_op->op_flags & OPf_MOD))
	{
	    gv = gv_fetchsv(sv, 0, type);
	    if (!gv
		&& (!is_gv_magical_sv(sv,0)
		    || !(gv = gv_fetchsv(sv, GV_ADD, type))))
		{
		    **spp = &PL_sv_undef;
		    return NULL;
		}
	}
    else {
	gv = gv_fetchsv(sv, GV_ADD, type);
    }
    return gv;
}

d231 2
a232 2
    dVAR; dSP; dTOPss;
    GV *gv = NULL;
a242 2
	case SVt_PVFM:
	case SVt_PVIO:
a243 1
	default: NOOP;
d247 2
d257 25
a281 3
	    gv = Perl_softref2xv(aTHX_ sv, "a SCALAR", SVt_PV, &sp);
	    if (!gv)
		RETURN;
d303 7
a309 6
    dVAR; dSP;
    AV * const av = (AV*)TOPs;
    SV ** const sv = Perl_av_arylen_p(aTHX_ (AV*)av);
    if (!*sv) {
	*sv = newSV_type(SVt_PVMG);
	sv_magic(*sv, (SV*)av, PERL_MAGIC_arylen, NULL, 0);
d311 1
a311 1
    SETs(*sv);
d317 1
a317 1
    dVAR; dSP; dTARGET; dPOPss;
d322 1
a322 1
	    sv_magic(TARG, NULL, PERL_MAGIC_pos, NULL, 0);
d329 1
a329 1
	    LvTARG(TARG) = SvREFCNT_inc_simple(sv);
d341 1
a341 1
		PUSHi(i + CopARYBASE_get(PL_curcop));
d351 1
a351 1
    dVAR; dSP;
d353 2
a354 6
    HV *stash_unused;
    const I32 flags = (PL_op->op_flags & OPf_SPECIAL)
	? 0
	: ((PL_op->op_private & (OPpLVAL_INTRO|OPpMAY_RETURN_CONSTANT)) == OPpMAY_RETURN_CONSTANT)
	    ? GV_ADD|GV_NOEXPAND
	    : GV_ADD;
d357 1
a357 2

    CV *cv = sv_2cv(TOPs, &stash_unused, &gv, flags);
a367 3
    else if ((flags == (GV_ADD|GV_NOEXPAND)) && gv && SvROK(gv)) {
	cv = (CV*)gv;
    }    
d376 1
a376 1
    dVAR; dSP;
d380 1
a380 1
    SV *ret = &PL_sv_undef;
d382 1
d384 1
a384 1
	const char * s = SvPVX_const(TOPs);
d386 1
a386 1
	    const int code = keyword(s + 6, SvCUR(TOPs) - 6, 1);
d389 1
a389 1
		int i = 0, n = 0, seen_question = 0, defgv = 0;
a395 7
		if (code == -KEY_mkdir) {
		    ret = sv_2mortal(newSVpvs("_;$"));
		    goto set;
		}
		if (code == -KEY_readpipe) {
		    s = "CORE::backtick";
		}
a405 1
		defgv = PL_opargs[i] & OA_DEFGV;
d408 1
a408 1
		    if (oa & OA_OPTIONAL && !seen_question && !defgv) {
a421 2
		if (defgv && str[n - 1] == '$')
		    str[n - 1] = '_';
d433 1
a433 1
    cv = sv_2cv(TOPs, &stash, &gv, 0);
d443 1
a443 1
    dVAR; dSP;
d454 1
a454 1
    dVAR; dSP;
d461 1
a461 1
    dVAR; dSP; dMARK;
a479 1
    dVAR;
d488 1
a488 1
	    SvREFCNT_inc_void_NN(sv);
d494 1
a494 1
	SvREFCNT_inc_void_NN(sv);
d500 1
a500 1
	SvREFCNT_inc_void_NN(sv);
d511 1
a511 1
    dVAR; dSP; dTARGET;
d515 2
a516 2
    if (sv)
	SvGETMAGIC(sv);
d528 1
a528 1
    dVAR; dSP;
d544 1
a544 1
	stash = gv_stashpvn(ptr, len, GV_ADD);
d553 1
a553 1
    dVAR; dSP;
d558 1
a558 1
    SV * tmpRef = NULL;
d560 1
a560 1
    sv = NULL;
d601 2
a602 3
		const HV * const stash = GvSTASH(gv);
		const HEK * const hek = stash ? HvNAME_HEK(stash) : NULL;
		sv = hek ? newSVhek(hek) : newSVpvs("__ANON__");
d607 1
a607 1
		tmpRef = GvSVn(gv);
d625 1
a625 1
    dVAR; dSP; dPOPss;
d637 6
a642 14
    s = (unsigned char*)(SvPV(sv, len));
    pos = len;
    if (pos <= 0 || !SvPOK(sv) || SvUTF8(sv)) {
	/* No point in studying a zero length string, and not safe to study
	   anything that doesn't appear to be a simple scalar (and hence might
	   change between now and when the regexp engine runs without our set
	   magic ever running) such as a reference to an object with overloaded
	   stringification.  */
	RETPUSHNO;
    }

    if (PL_lastscream) {
	SvSCREAM_off(PL_lastscream);
	SvREFCNT_dec(PL_lastscream);
a643 1
    PL_lastscream = SvREFCNT_inc_simple(sv);
d682 1
a682 1
    sv_magic(sv, NULL, PERL_MAGIC_regex_global, NULL, 0);
d688 1
a688 1
    dVAR; dSP; dTARG;
a692 2
    else if (PL_op->op_private & OPpTARGET_MY)
	sv = GETTARGET;
d706 1
a706 1
    dVAR; dSP; dTARGET;
d714 1
a714 1
    dVAR; dSP; dMARK; dTARGET; dORIGMARK;
d724 1
a724 1
    dVAR; dSP; dTARGET;
d731 1
a731 1
    dVAR; dSP; dMARK; dTARGET;
d740 31
d773 1
a773 1
    dVAR; dSP;
d785 2
a786 1
    SV_CHECK_THINKFIRST_COW_DROP(sv);
d801 1
a801 1
	/* FALLTHROUGH */
d805 1
a805 1
	    GV* const gv = CvGV((CV*)sv);
a814 9
            HV *stash;

            /* undef *Foo:: */
            if((stash = GvHV((GV*)sv)) && HvNAME_get(stash))
                mro_isa_changed_in(stash);
            /* undef *Pkg::meth_name ... */
            else if(GvCVu((GV*)sv) && (stash = GvSTASH((GV*)sv)) && HvNAME_get(stash))
                mro_method_changed_in(stash);

d818 1
a818 1
	    GvSV(sv) = newSV(0);
d827 1
a827 1
	    SvPV_set(sv, NULL);
d839 2
a840 2
    dVAR; dSP;
    if (SvTYPE(TOPs) >= SVt_PVGV && SvTYPE(TOPs) != SVt_PVLV)
d856 2
a857 2
    dVAR; dSP; dTARGET;
    if (SvTYPE(TOPs) >= SVt_PVGV && SvTYPE(TOPs) != SVt_PVLV)
d878 2
a879 2
    dVAR; dSP; dTARGET;
    if (SvTYPE(TOPs) >= SVt_PVGV && SvTYPE(TOPs) != SVt_PVLV)
d899 1
a899 1
    dVAR; dSP; dATARGET; SV *svl, *svr;
a903 2
    svl = sv_2num(TOPm1s);
    svr = sv_2num(TOPs);
d909 4
a912 4
	SvIV_please(svr);
	if (SvIOK(svr)) {
	    SvIV_please(svl);
	    if (SvIOK(svl)) {
d917 2
a918 2
		if (SvUOK(svr)) {
		    power = SvUVX(svr);
d920 1
a920 1
		    const IV iv = SvIVX(svr);
d928 1
a928 1
		baseuok = SvUOK(svl);
d930 1
a930 1
		    baseuv = SvUVX(svl);
d932 1
a932 1
		    const IV iv = SvIVX(svl);
d967 1
a967 1
                    SvIV_please(svr);
d1016 1
a1016 41
	NV right = SvNV(svr);
	NV left  = SvNV(svl);
	(void)POPs;

#if defined(USE_LONG_DOUBLE) && defined(HAS_AIX_POWL_NEG_BASE_BUG)
    /*
    We are building perl with long double support and are on an AIX OS
    afflicted with a powl() function that wrongly returns NaNQ for any
    negative base.  This was reported to IBM as PMR #23047-379 on
    03/06/2006.  The problem exists in at least the following versions
    of AIX and the libm fileset, and no doubt others as well:

	AIX 4.3.3-ML10      bos.adt.libm 4.3.3.50
	AIX 5.1.0-ML04      bos.adt.libm 5.1.0.29
	AIX 5.2.0           bos.adt.libm 5.2.0.85

    So, until IBM fixes powl(), we provide the following workaround to
    handle the problem ourselves.  Our logic is as follows: for
    negative bases (left), we use fmod(right, 2) to check if the
    exponent is an odd or even integer:

	- if odd,  powl(left, right) == -powl(-left, right)
	- if even, powl(left, right) ==  powl(-left, right)

    If the exponent is not an integer, the result is rightly NaNQ, so
    we just return that (as NV_NAN).
    */

	if (left < 0.0) {
	    NV mod2 = Perl_fmod( right, 2.0 );
	    if (mod2 == 1.0 || mod2 == -1.0) {	/* odd integer */
		SETn( -Perl_pow( -left, right) );
	    } else if (mod2 == 0.0) {		/* even integer */
		SETn( Perl_pow( -left, right) );
	    } else {				/* fractional power */
		SETn( NV_NAN );
	    }
	} else {
	    SETn( Perl_pow( left, right) );
	}
#else
a1017 2
#endif  /* HAS_AIX_POWL_NEG_BASE_BUG */

d1020 1
a1020 1
	    SvIV_please(svr);
d1028 1
a1028 4
    dVAR; dSP; dATARGET; SV *svl, *svr;
    tryAMAGICbin(mult,opASSIGN);
    svl = sv_2num(TOPm1s);
    svr = sv_2num(TOPs);
d1030 2
a1031 2
    SvIV_please(svr);
    if (SvIOK(svr)) {
d1036 4
a1039 4
	SvIV_please(svl);
	if (SvIOK(svl)) {
	    bool auvok = SvUOK(svl);
	    bool buvok = SvUOK(svr);
d1048 1
a1048 1
		alow = SvUVX(svl);
d1050 1
a1050 1
		const IV aiv = SvIVX(svl);
d1059 1
a1059 1
		blow = SvUVX(svr);
d1061 1
a1061 1
		const IV biv = SvIVX(svr);
a1075 1
		NOOP;
d1081 1
a1081 1
		const UV product = alow * blow;
d1134 2
a1135 2
	} /* SvIOK(svl) */
    } /* SvIOK(svr) */
d1138 1
a1138 3
      NV right = SvNV(svr);
      NV left  = SvNV(svl);
      (void)POPs;
d1146 1
a1146 4
    dVAR; dSP; dATARGET; SV *svl, *svr;
    tryAMAGICbin(div,opASSIGN);
    svl = sv_2num(TOPm1s);
    svr = sv_2num(TOPs);
d1169 6
a1174 6
    SvIV_please(svr);
    if (SvIOK(svr)) {
        SvIV_please(svl);
        if (SvIOK(svl)) {
            bool left_non_neg = SvUOK(svl);
            bool right_non_neg = SvUOK(svr);
d1179 1
a1179 1
                right = SvUVX(svr);
d1182 1
a1182 1
		const IV biv = SvIVX(svr);
d1200 1
a1200 1
                left = SvUVX(svl);
d1203 1
a1203 1
		const IV aiv = SvIVX(svl);
d1251 1
a1251 6
	NV right = SvNV(svr);
	NV left  = SvNV(svl);
	(void)POPs;(void)POPs;
#if defined(NAN_COMPARE_BROKEN) && defined(Perl_isnan)
	if (! Perl_isnan(right) && right == 0.0)
#else
a1252 1
#endif
d1261 1
a1261 1
    dVAR; dSP; dATARGET; tryAMAGICbin(modulo,opASSIGN);
d1271 4
a1274 5
        SV * svl;
        SV * const svr = sv_2num(TOPs);
        SvIV_please(svr);
        if (SvIOK(svr)) {
            right_neg = !SvUOK(svr);
d1276 1
a1276 1
                right = SvUVX(svr);
d1278 1
a1278 1
		const IV biv = SvIVX(svr);
d1288 1
a1288 1
	    dright = SvNV(svr);
a1298 1
	sp--;
d1303 4
a1306 5
        svl = sv_2num(TOPs);
        SvIV_please(svl);
	if (!use_double && SvIOK(svl)) {
            if (SvIOK(svl)) {
                left_neg = !SvUOK(svl);
d1308 1
a1308 1
                    left = SvUVX(svl);
d1310 1
a1310 1
		    const IV aiv = SvIVX(svl);
d1321 1
a1321 1
	    dleft = SvNV(svl);
a1348 1
	sp--;
d1389 1
a1389 1
  dVAR; dSP; dATARGET; tryAMAGICbin(repeat,opASSIGN);
d1393 2
a1394 1
    SvGETMAGIC(sv);
d1403 1
a1403 1
	      const IV iv = SvIV(sv);
d1418 1
a1418 1
	 count = SvIV(sv);
d1421 4
a1424 3
	static const char oom_list_extend[] = "Out of memory during list extend";
	const I32 items = SP - MARK;
	const I32 max = items * count;
d1426 1
d1472 1
a1472 1
	SV * const tmpstr = POPs;
d1485 2
a1486 2
		const STRLEN max = (UV)count * len;
		if (len > MEM_SIZE_MAX / count)
d1517 2
a1518 5
    dVAR; dSP; dATARGET; bool useleft; SV *svl, *svr;
    tryAMAGICbin(subtr,opASSIGN);
    svl = sv_2num(TOPm1s);
    svr = sv_2num(TOPs);
    useleft = USE_LEFT(svl);
d1522 2
a1523 2
    SvIV_please(svr);
    if (SvIOK(svr)) {
d1537 4
a1540 4
	    SvIV_please(svl);
	    if (SvIOK(svl)) {
		if ((auvok = SvUOK(svl)))
		    auv = SvUVX(svl);
d1542 1
a1542 1
		    register const IV aiv = SvIVX(svl);
d1557 1
a1557 1
	    bool buvok = SvUOK(svr);
d1560 1
a1560 1
		buv = SvUVX(svr);
d1562 1
a1562 1
		register const IV biv = SvIVX(svr);
d1619 1
d1621 1
a1621 3
	NV value = SvNV(svr);
	(void)POPs;

d1627 1
a1627 1
	SETn( SvNV(svl) - value );
d1634 1
a1634 1
    dVAR; dSP; dATARGET; tryAMAGICbin(lshift,opASSIGN);
d1638 1
a1638 1
	const IV i = TOPi;
d1642 1
a1642 1
	const UV u = TOPu;
d1651 1
a1651 1
    dVAR; dSP; dATARGET; tryAMAGICbin(rshift,opASSIGN);
d1655 1
a1655 1
	const IV i = TOPi;
d1659 1
a1659 1
	const UV u = TOPu;
d1668 1
a1668 1
    dVAR; dSP; tryAMAGICbinSET(lt,0);
a1734 6
#if defined(NAN_COMPARE_BROKEN) && defined(Perl_isnan)
      dPOPTOPnnrl;
      if (Perl_isnan(left) || Perl_isnan(right))
	  RETSETNO;
      SETs(boolSV(left < right));
#else
a1736 1
#endif
d1743 1
a1743 1
    dVAR; dSP; tryAMAGICbinSET(gt,0);
a1810 6
#if defined(NAN_COMPARE_BROKEN) && defined(Perl_isnan)
      dPOPTOPnnrl;
      if (Perl_isnan(left) || Perl_isnan(right))
	  RETSETNO;
      SETs(boolSV(left > right));
#else
a1812 1
#endif
d1819 1
a1819 1
    dVAR; dSP; tryAMAGICbinSET(le,0);
a1886 6
#if defined(NAN_COMPARE_BROKEN) && defined(Perl_isnan)
      dPOPTOPnnrl;
      if (Perl_isnan(left) || Perl_isnan(right))
	  RETSETNO;
      SETs(boolSV(left <= right));
#else
a1888 1
#endif
d1895 1
a1895 1
    dVAR; dSP; tryAMAGICbinSET(ge,0);
a1962 6
#if defined(NAN_COMPARE_BROKEN) && defined(Perl_isnan)
      dPOPTOPnnrl;
      if (Perl_isnan(left) || Perl_isnan(right))
	  RETSETNO;
      SETs(boolSV(left >= right));
#else
a1964 1
#endif
d1971 1
a1971 1
    dVAR; dSP; tryAMAGICbinSET(ne,0);
d1984 2
a1985 2
	    const bool auvok = SvUOK(TOPm1s);
	    const bool buvok = SvUOK(TOPs);
a2031 6
#if defined(NAN_COMPARE_BROKEN) && defined(Perl_isnan)
      dPOPTOPnnrl;
      if (Perl_isnan(left) || Perl_isnan(right))
	  RETSETYES;
      SETs(boolSV(left != right));
#else
a2033 1
#endif
d2040 1
a2040 1
    dVAR; dSP; dTARGET; tryAMAGICbin(ncmp,0);
d2043 2
a2044 2
	const UV right = PTR2UV(SvRV(POPs));
	const UV left = PTR2UV(SvRV(TOPs));
d2142 26
d2170 8
a2177 23
    dVAR; dSP;

    int amg_type = sle_amg;
    int multiplier = 1;
    int rhs = 1;

    switch (PL_op->op_type) {
    case OP_SLT:
	amg_type = slt_amg;
	/* cmp < 0 */
	rhs = 0;
	break;
    case OP_SGT:
	amg_type = sgt_amg;
	/* cmp > 0 */
	multiplier = -1;
	rhs = 0;
	break;
    case OP_SGE:
	amg_type = sge_amg;
	/* cmp >= 0 */
	multiplier = -1;
	break;
d2179 1
d2181 3
a2183 1
    tryAMAGICbinSET_var(amg_type,0);
d2189 1
a2189 1
      SETs(boolSV(cmp * multiplier < rhs));
d2196 1
a2196 1
    dVAR; dSP; tryAMAGICbinSET(seq,0);
d2206 1
a2206 1
    dVAR; dSP; tryAMAGICbinSET(sne,0);
d2216 1
a2216 1
    dVAR; dSP; dTARGET;  tryAMAGICbin(scmp,0);
d2229 24
a2252 1
    dVAR; dSP; dATARGET; tryAMAGICbin(band,opASSIGN);
a2254 2
      SvGETMAGIC(left);
      SvGETMAGIC(right);
d2257 1
a2257 1
	  const IV i = SvIV_nomg(left) & SvIV_nomg(right);
d2261 1
a2261 1
	  const UV u = SvUV_nomg(left) & SvUV_nomg(right);
d2275 1
a2275 4
    dVAR; dSP; dATARGET;
    const int op_type = PL_op->op_type;

    tryAMAGICbin_var((op_type == OP_BIT_OR ? bor_amg : bxor_amg), opASSIGN);
a2277 2
      SvGETMAGIC(left);
      SvGETMAGIC(right);
d2280 2
a2281 4
	  const IV l = (USE_LEFT(left) ? SvIV_nomg(left) : 0);
	  const IV r = SvIV_nomg(right);
	  const IV result = op_type == OP_BIT_OR ? (l | r) : (l ^ r);
	  SETi(result);
d2284 2
a2285 4
	  const UV l = (USE_LEFT(left) ? SvUV_nomg(left) : 0);
	  const UV r = SvUV_nomg(right);
	  const UV result = op_type == OP_BIT_OR ? (l | r) : (l ^ r);
	  SETu(result);
d2289 1
a2289 1
	do_vop(op_type, TARG, left, right);
d2298 1
a2298 1
    dVAR; dSP; dTARGET; tryAMAGICun(neg);
d2300 1
a2300 1
	SV * const sv = sv_2num(TOPs);
d2302 2
a2303 1
	SvGETMAGIC(sv);
d2333 1
a2333 1
	    const char * const s = SvPV_const(sv, len);
d2369 1
a2369 1
    dVAR; dSP; tryAMAGICunSET(not);
d2376 1
a2376 1
    dVAR; dSP; dTARGET; tryAMAGICun(compl);
a2378 1
      SvGETMAGIC(sv);
d2381 1
a2381 1
	  const IV i = ~SvIV_nomg(sv);
d2385 1
a2385 1
	  const UV u = ~SvUV_nomg(sv);
d2395 1
a2395 1
	sv_setsv_nomg(TARG, sv);
d2401 2
a2405 3
	  U8 * const send = tmps + len;
	  U8 * const origtmps = tmps;
	  const UV utf8flags = UTF8_ALLOW_ANYUV;
d2407 1
d2409 2
a2410 2
	    const UV c = utf8n_to_uvchr(tmps, send-tmps, &l, utf8flags);
	    tmps += l;
d2418 1
a2418 1
	  tmps = origtmps;
d2421 1
a2421 5
	      U8 *result;
	      U8 *p;

	      Newx(result, targlen + 1, U8);
	      p = result;
d2423 3
a2425 3
		  const UV c = utf8n_to_uvchr(tmps, send-tmps, &l, utf8flags);
		  tmps += l;
		  p = uvchr_to_utf8_flags(p, ~c, UNICODE_ALLOW_ANY);
d2427 3
a2429 3
	      *p = '\0';
	      sv_usepvn_flags(TARG, (char*)result, targlen,
			      SV_HAS_TRAILING_NUL);
d2433 1
a2433 5
	      U8 *result;
	      U8 *p;

	      Newx(result, nchar + 1, U8);
	      p = result;
d2435 3
a2437 3
		  const U8 c = (U8)utf8n_to_uvchr(tmps, send-tmps, &l, utf8flags);
		  tmps += l;
		  *p++ = ~c;
d2439 3
a2441 2
	      *p = '\0';
	      sv_usepvn_flags(TARG, (char*)result, nchar, SV_HAS_TRAILING_NUL);
d2444 1
d2454 1
a2454 1
	    for ( ; anum >= (I32)sizeof(long); anum -= (I32)sizeof(long), tmpl++)
d2472 1
a2472 1
    dVAR; dSP; dATARGET; tryAMAGICbin(mult,opASSIGN);
d2482 1
a2482 2
    IV num;
    dVAR; dSP; dATARGET; tryAMAGICbin(div,opASSIGN);
d2486 2
a2487 8
	  DIE(aTHX_ "Illegal division by zero");
      num = POPi;

      /* avoid FPE_INTOVF on some platforms when num is IV_MIN */
      if (value == -1)
          value = - num;
      else
          value = num / value;
a2492 1
#if defined(__GLIBC__) && IVSIZE == 8
a2494 3
#else
PP(pp_i_modulo)
#endif
d2497 1
a2497 1
     dVAR; dSP; dATARGET; tryAMAGICbin(modulo,opASSIGN);
d2502 1
a2502 5
	  /* avoid FPE_INTOVF on some platforms when left is IV_MIN */
	  if (right == -1)
	      SETi( 0 );
	  else
	      SETi( left % right );
a2509 1

d2514 1
a2514 1
     dVAR; dVAR; dSP; dATARGET; tryAMAGICbin(modulo,opASSIGN);
d2519 1
a2519 5
	  /* avoid FPE_INTOVF on some platforms when left is IV_MIN */
	  if (right == -1)
	      SETi( 0 );
	  else
	      SETi( left % PERL_ABS(right) );
d2523 1
d2527 1
a2527 1
     dVAR; dSP; dATARGET; tryAMAGICbin(modulo,opASSIGN);
d2543 1
d2559 2
a2560 5
	  /* avoid FPE_INTOVF on some platforms when left is IV_MIN */
	  if (right == -1)
	      SETi( 0 );
	  else
	      SETi( left % right );
a2563 1
#endif
d2567 1
a2567 1
    dVAR; dSP; dATARGET; tryAMAGICbin(add,opASSIGN);
d2577 1
a2577 1
    dVAR; dSP; dATARGET; tryAMAGICbin(subtr,opASSIGN);
d2587 1
a2587 1
    dVAR; dSP; tryAMAGICbinSET(lt,0);
d2597 1
a2597 1
    dVAR; dSP; tryAMAGICbinSET(gt,0);
d2607 1
a2607 1
    dVAR; dSP; tryAMAGICbinSET(le,0);
d2617 1
a2617 1
    dVAR; dSP; tryAMAGICbinSET(ge,0);
d2627 1
a2627 1
    dVAR; dSP; tryAMAGICbinSET(eq,0);
d2637 1
a2637 1
    dVAR; dSP; tryAMAGICbinSET(ne,0);
d2647 1
a2647 1
    dVAR; dSP; dTARGET; tryAMAGICbin(ncmp,0);
d2665 1
a2665 1
    dVAR; dSP; dTARGET; tryAMAGICun(neg);
d2674 1
a2674 1
    dVAR; dSP; dTARGET; tryAMAGICbin(atan2,0);
d2684 5
a2688 25
    dVAR; dSP; dTARGET;
    int amg_type = sin_amg;
    const char *neg_report = NULL;
    NV (*func)(NV) = Perl_sin;
    const int op_type = PL_op->op_type;

    switch (op_type) {
    case OP_COS:
	amg_type = cos_amg;
	func = Perl_cos;
	break;
    case OP_EXP:
	amg_type = exp_amg;
	func = Perl_exp;
	break;
    case OP_LOG:
	amg_type = log_amg;
	func = Perl_log;
	neg_report = "log";
	break;
    case OP_SQRT:
	amg_type = sqrt_amg;
	func = Perl_sqrt;
	neg_report = "sqrt";
	break;
d2690 1
d2692 3
a2694 1
    tryAMAGICun_var(amg_type);
d2697 1
a2697 7
      if (neg_report) {
	  if (op_type == OP_LOG ? (value <= 0.0) : (value < 0.0)) {
	      SET_NUMERIC_STANDARD();
	      DIE(aTHX_ "Can't take %s of %"NVgf, neg_report, value);
	  }
      }
      XPUSHn(func(value));
d2719 1
a2719 1
    dVAR; dSP; dTARGET;
d2738 6
a2743 2
    dVAR; dSP;
    const UV anum = (MAXARG < 1) ? seed() : POPu;
d2750 40
d2792 1
a2792 1
    dVAR; dSP; dTARGET; tryAMAGICun(int);
d2794 1
a2794 2
      SV * const sv = sv_2num(TOPs);
      const IV iv = SvIV(sv);
d2800 1
a2800 1
      if (!SvOK(sv)) {
d2802 5
a2806 5
      }
      else if (SvIOK(sv)) {
	if (SvIsUV(sv))
	    SETu(SvUV(sv));
	else
d2808 2
a2809 3
      }
      else {
	  const NV value = SvNV(sv);
d2831 1
a2831 1
    dVAR; dSP; dTARGET; tryAMAGICun(abs);
a2832 1
      SV * const sv = sv_2num(TOPs);
d2834 1
a2834 1
      const IV iv = SvIV(sv);
d2836 1
a2836 1
      if (!SvOK(sv)) {
d2838 1
a2838 2
      }
      else if (SvIOK(sv)) {
d2840 2
a2841 2
	if (SvIsUV(sv)) {
	  SETu(SvUV(sv));	/* force it to be numeric only */
d2856 1
a2856 1
	const NV value = SvNV(sv);
d2866 2
a2867 1
PP(pp_oct)
d2869 1
a2869 1
    dVAR; dSP; dTARGET;
d2887 9
a2895 2
    if (PL_op->op_type == OP_HEX)
	goto hex;
d2897 20
d2921 2
a2922 4
    if (*tmps == 'x') {
    hex:
        result_uv = grok_hex (tmps, &len, &flags, &result_nv);
    }
d2924 1
a2924 1
        result_uv = grok_bin (tmps, &len, &flags, &result_nv);
d2926 1
a2926 1
        result_uv = grok_oct (tmps, &len, &flags, &result_nv);
d2941 2
a2942 2
    dVAR; dSP; dTARGET;
    SV * const sv = TOPs;
d2944 1
a2944 16
    if (SvAMAGIC(sv)) {
	/* For an overloaded scalar, we can't know in advance if it's going to
	   be UTF-8 or not. Also, we can't call sv_len_utf8 as it likes to
	   cache the length. Maybe that should be a documented feature of it.
	*/
	STRLEN len;
	const char *const p = SvPV_const(sv, len);

	if (DO_UTF8(sv)) {
	    SETi(utf8_length((U8*)p, (U8*)p + len));
	}
	else
	    SETi(len);

    }
    else if (DO_UTF8(sv))
d2953 1
a2953 1
    dVAR; dSP; dTARGET;
d2963 1
a2963 1
    const I32 arybase = CopARYBASE_get(PL_curcop);
d2965 1
a2965 1
    const char *repl = NULL;
d3077 1
a3077 1
	    sv_insert(sv, pos, rem, repl, repl_len);
d3091 1
a3091 3
		if (isGV_with_GP(sv))
		    SvPV_force_nolen(sv);
		else if (SvOK(sv))	/* is it defined ? */
d3099 1
a3099 1
		sv_magic(TARG, NULL, PERL_MAGIC_substr, NULL, 0);
d3101 2
d3108 1
a3108 1
		LvTARG(TARG) = SvREFCNT_inc_simple(sv);
d3121 1
a3121 1
    dVAR; dSP; dTARGET;
d3133 1
a3133 1
	    sv_magic(TARG, NULL, PERL_MAGIC_vec, NULL, 0);
d3139 1
a3139 1
	    LvTARG(TARG) = SvREFCNT_inc_simple(src);
d3152 1
a3152 1
    dVAR; dSP; dTARGET;
d3155 1
a3155 3
    SV *temp = NULL;
    STRLEN biglen;
    STRLEN llen = 0;
d3158 10
a3167 10
    const char *big_p;
    const char *little_p;
    const I32 arybase = CopARYBASE_get(PL_curcop);
    bool big_utf8;
    bool little_utf8;
    const bool is_index = PL_op->op_type == OP_INDEX;

    if (MAXARG >= 3) {
	/* arybase is in characters, like offset, so combine prior to the
	   UTF-8 to bytes calculation.  */
d3169 23
d3193 38
a3232 3
    big_p = SvPV_const(big, biglen);
    little_p = SvPV_const(little, llen);

d3237 8
a3244 18
	if (little_utf8 && !PL_encoding) {
	    /* Well, maybe instead we might be able to downgrade the small
	       string?  */
	    char * const pv = (char*)bytes_from_utf8((U8 *)little_p, &llen,
						     &little_utf8);
	    if (little_utf8) {
		/* If the large string is ISO-8859-1, and it's not possible to
		   convert the small string to ISO-8859-1, then there is no
		   way that it could be found anywhere by index.  */
		retval = -1;
		goto fail;
	    }

	    /* At this point, pv is a malloc()ed string. So donate it to temp
	       to ensure it will get free()d  */
	    little = temp = newSV(0);
	    sv_usepvn(temp, pv, llen);
	    little_p = SvPVX(little);
d3246 7
a3252 16
	    temp = little_utf8
		? newSVpvn(big_p, biglen) : newSVpvn(little_p, llen);

	    if (PL_encoding) {
		sv_recode_to_utf8(temp, PL_encoding);
	    } else {
		sv_utf8_upgrade(temp);
	    }
	    if (little_utf8) {
		big = temp;
		big_utf8 = TRUE;
		big_p = SvPV_const(big, biglen);
	    } else {
		little = temp;
		little_p = SvPV_const(little, llen);
	    }
d3255 2
a3256 24
    if (SvGAMAGIC(big)) {
	/* Life just becomes a lot easier if I use a temporary here.
	   Otherwise I need to avoid calls to sv_pos_u2b(), which (dangerously)
	   will trigger magic and overloading again, as will fbm_instr()
	*/
	big = sv_2mortal(newSVpvn(big_p, biglen));
	if (big_utf8)
	    SvUTF8_on(big);
	big_p = SvPVX(big);
    }
    if (SvGAMAGIC(little) || (is_index && !SvOK(little))) {
	/* index && SvOK() is a hack. fbm_instr() calls SvPV_const, which will
	   warn on undef, and we've already triggered a warning with the
	   SvPV_const some lines above. We can't remove that, as we need to
	   call some SvPV to trigger overloading early and find out if the
	   string is UTF-8.
	   This is all getting to messy. The API isn't quite clean enough,
	   because data access has side effects.
	*/
	little = sv_2mortal(newSVpvn(little_p, llen));
	if (little_utf8)
	    SvUTF8_on(little);
	little_p = SvPVX(little);
    }
d3259 1
a3259 1
	offset = is_index ? 0 : biglen;
d3261 1
a3261 1
	if (big_utf8 && offset > 0)
d3263 1
a3263 2
	if (!is_index)
	    offset += llen;
d3267 4
a3270 7
    else if (offset > (I32)biglen)
	offset = biglen;
    if (!(little_p = is_index
	  ? fbm_instr((unsigned char*)big_p + offset,
		      (unsigned char*)big_p + biglen, little, 0)
	  : rninstr(big_p,  big_p  + offset,
		    little_p, little_p + llen)))
d3272 4
a3275 5
    else {
	retval = little_p - big_p;
	if (retval > 0 && big_utf8)
	    sv_pos_b2u(big, &retval);
    }
a3277 1
 fail:
d3284 1
a3284 3
    dVAR; dSP; dMARK; dORIGMARK; dTARGET;
    if (SvTAINTED(MARK[1]))
	TAINT_PROPER("sprintf");
d3287 2
d3296 1
a3296 2
    dVAR; dSP; dTARGET;

d3300 1
d3303 1
a3303 1
        SV * const tmpsv = sv_2mortal(newSVsv(argsv));
d3309 2
a3310 2
	   utf8n_to_uvchr(s, UTF8_MAXBYTES, 0, UTF8_ALLOW_ANYUV) :
	   (UV)(*s & 0xff));
d3317 1
a3317 1
    dVAR; dSP; dTARGET;
d3319 1
a3319 1
    UV value;
d3321 1
a3321 14
    if (((SvIOK_notUV(TOPs) && SvIV(TOPs) < 0)
	 ||
	 (SvNOK(TOPs) && SvNV(TOPs) < 0.0))) {
	if (IN_BYTES) {
	    value = POPu; /* chr(-1) eq chr(0xff), etc. */
	} else {
	    (void) POPs; /* Ignore the argument value. */
	    value = UNICODE_REPLACEMENT;
	}
    } else {
	value = POPu;
    }

    SvUPGRADE(TARG,SVt_PV);
a3339 1

d3344 2
a3345 2
	    UNICODE_IS_REPLACEMENT(utf8_to_uvchr((U8*)tmps, NULL))) {
	    SvGROW(TARG, 2);
d3347 3
a3349 2
	    SvCUR_set(TARG, 1);
	    *tmps++ = (char)value;
d3351 1
a3351 1
	    SvUTF8_off(TARG);
a3353 1

d3361 1
a3361 1
    dVAR; dSP; dTARGET;
a3408 1
    dVAR;
d3410 2
a3411 1
    SV *source = TOPs;
a3412 42
    STRLEN need;
    SV *dest;
    bool inplace = TRUE;
    bool doing_utf8;
    const int op_type = PL_op->op_type;
    const U8 *s;
    U8 *d;
    U8 tmpbuf[UTF8_MAXBYTES_CASE+1];
    STRLEN ulen;
    STRLEN tculen;

    SvGETMAGIC(source);
    if (SvOK(source)) {
	s = (const U8*)SvPV_nomg_const(source, slen);
    } else {
	s = (const U8*)"";
	slen = 0;
    }

    if (slen && DO_UTF8(source) && UTF8_IS_START(*s)) {
	doing_utf8 = TRUE;
	utf8_to_uvchr(s, &ulen);
	if (op_type == OP_UCFIRST) {
	    toTITLE_utf8(s, tmpbuf, &tculen);
	} else {
	    toLOWER_utf8(s, tmpbuf, &tculen);
	}
	/* If the two differ, we definately cannot do inplace.  */
	inplace = (ulen == tculen);
	need = slen + 1 - ulen + tculen;
    } else {
	doing_utf8 = FALSE;
	need = slen + 1;
    }

    if (SvPADTMP(source) && !SvREADONLY(source) && inplace && SvTEMP(source)) {
	/* We can convert in place.  */

	dest = source;
	s = d = (U8*)SvPV_force_nomg(source, slen);
    } else {
	dTARGET;
d3414 7
a3420 1
	dest = TARG;
d3422 2
a3423 3
	SvUPGRADE(dest, SVt_PV);
	d = (U8*)SvGROW(dest, need);
	(void)SvPOK_only(dest);
d3425 2
a3426 7
	SETs(dest);

	inplace = FALSE;
    }

    if (doing_utf8) {
	if(!inplace) {
d3430 5
a3434 5
	     * tculen is the byte length of the freshly titlecased (or
	     * lowercased) Unicode character stored as UTF-8 at tmpbuf.
	     * We first set the result to be the titlecased (/lowercased)
	     * character, and then append the rest of the SV data. */
	    sv_setpvn(dest, (char*)tmpbuf, tculen);
d3436 3
a3438 2
	        sv_catpvn(dest, (char*)(s + ulen), slen - ulen);
	    SvUTF8_on(dest);
d3441 2
a3442 2
	    Copy(tmpbuf, d, tculen, U8);
	    SvCUR_set(dest, need - 1);
d3446 10
a3455 1
	if (*s) {
d3458 2
a3459 3
		SvTAINTED_on(dest);
		*d = (op_type == OP_UCFIRST)
		    ? toUPPER_LC(*s) : toLOWER_LC(*s);
d3462 1
a3462 4
		*d = (op_type == OP_UCFIRST) ? toUPPER(*s) : toLOWER(*s);
	} else {
	    /* See bug #39028  */
	    *d = *s;
d3464 4
d3469 14
a3482 2
	if (SvUTF8(source))
	    SvUTF8_on(dest);
d3484 34
a3517 4
	if (!inplace) {
	    /* This will copy the trailing NUL  */
	    Copy(s + 1, d + 1, slen, U8);
	    SvCUR_set(dest, need - 1);
d3520 1
a3520 1
    SvSETMAGIC(dest);
a3523 3
/* There's so much setup/teardown code common between uc and lc, I wonder if
   it would be worth merging the two, and just having a switch outside each
   of the three tight loops.  */
a3525 1
    dVAR;
d3527 1
a3527 1
    SV *source = TOPs;
a3528 4
    STRLEN min;
    SV *dest;
    const U8 *s;
    U8 *d;
d3530 2
a3531 10
    SvGETMAGIC(source);

    if (SvPADTMP(source) && !SvREADONLY(source) && !SvAMAGIC(source)
	&& SvTEMP(source) && !DO_UTF8(source)) {
	/* We can convert in place.  */

	dest = source;
	s = d = (U8*)SvPV_force_nomg(source, len);
	min = len + 1;
    } else {
d3533 5
d3539 8
a3546 1
	dest = TARG;
d3548 29
a3576 12
	/* The old implementation would copy source into TARG at this point.
	   This had the side effect that if source was undef, TARG was now
	   an undefined SV with PADTMP set, and they don't warn inside
	   sv_2pv_flags(). However, we're now getting the PV direct from
	   source, which doesn't have PADTMP set, so it would warn. Hence the
	   little games.  */

	if (SvOK(source)) {
	    s = (const U8*)SvPV_nomg_const(source, len);
	} else {
	    s = (const U8*)"";
	    len = 0;
a3577 7
	min = len + 1;

	SvUPGRADE(dest, SVt_PV);
	d = (U8*)SvGROW(dest, min);
	(void)SvPOK_only(dest);

	SETs(dest);
d3579 8
a3586 27

    /* Overloaded values may have toggled the UTF-8 flag on source, so we need
       to check DO_UTF8 again here.  */

    if (DO_UTF8(source)) {
	const U8 *const send = s + len;
	U8 tmpbuf[UTF8_MAXBYTES+1];

	while (s < send) {
	    const STRLEN u = UTF8SKIP(s);
	    STRLEN ulen;

	    toUPPER_utf8(s, tmpbuf, &ulen);
	    if (ulen > u && (SvLEN(dest) < (min += ulen - u))) {
		/* If the eventually required minimum size outgrows
		 * the available space, we need to grow. */
		const UV o = d - (U8*)SvPVX_const(dest);

		/* If someone uppercases one million U+03B0s we SvGROW() one
		 * million times.  Or we could try guessing how much to
		 allocate without allocating too much.  Such is life. */
		SvGROW(dest, min);
		d = (U8*)SvPVX(dest) + o;
	    }
	    Copy(tmpbuf, d, ulen, U8);
	    d += ulen;
	    s += u;
d3588 1
a3588 4
	SvUTF8_on(dest);
	*d = '\0';
	SvCUR_set(dest, d - (U8*)SvPVX_const(dest));
    } else {
d3590 2
a3591 1
	    const U8 *const send = s + len;
d3594 3
a3596 3
		SvTAINTED_on(dest);
		for (; s < send; d++, s++)
		    *d = toUPPER_LC(*s);
d3599 2
a3600 2
		for (; s < send; d++, s++)
		    *d = toUPPER(*s);
a3602 4
	if (source != dest) {
	    *d = '\0';
	    SvCUR_set(dest, d - (U8*)SvPVX_const(dest));
	}
d3604 1
a3604 1
    SvSETMAGIC(dest);
a3609 1
    dVAR;
d3611 1
a3611 1
    SV *source = TOPs;
a3612 4
    STRLEN min;
    SV *dest;
    const U8 *s;
    U8 *d;
d3614 2
a3615 10
    SvGETMAGIC(source);

    if (SvPADTMP(source) && !SvREADONLY(source) && !SvAMAGIC(source)
	&& SvTEMP(source) && !DO_UTF8(source)) {
	/* We can convert in place.  */

	dest = source;
	s = d = (U8*)SvPV_force_nomg(source, len);
	min = len + 1;
    } else {
d3617 5
d3623 5
a3627 14
	dest = TARG;

	/* The old implementation would copy source into TARG at this point.
	   This had the side effect that if source was undef, TARG was now
	   an undefined SV with PADTMP set, and they don't warn inside
	   sv_2pv_flags(). However, we're now getting the PV direct from
	   source, which doesn't have PADTMP set, so it would warn. Hence the
	   little games.  */

	if (SvOK(source)) {
	    s = (const U8*)SvPV_nomg_const(source, len);
	} else {
	    s = (const U8*)"";
	    len = 0;
d3629 2
a3630 1
	min = len + 1;
d3632 8
a3639 18
	SvUPGRADE(dest, SVt_PV);
	d = (U8*)SvGROW(dest, min);
	(void)SvPOK_only(dest);

	SETs(dest);
    }

    /* Overloaded values may have toggled the UTF-8 flag on source, so we need
       to check DO_UTF8 again here.  */

    if (DO_UTF8(source)) {
	const U8 *const send = s + len;
	U8 tmpbuf[UTF8_MAXBYTES_CASE+1];

	while (s < send) {
	    const STRLEN u = UTF8SKIP(s);
	    STRLEN ulen;
	    const UV uv = toLOWER_utf8(s, tmpbuf, &ulen);
d3642 33
a3674 14
	    if (uv == GREEK_CAPITAL_LETTER_SIGMA) {
		NOOP;
		/*
		 * Now if the sigma is NOT followed by
		 * /$ignorable_sequence$cased_letter/;
		 * and it IS preceded by /$cased_letter$ignorable_sequence/;
		 * where $ignorable_sequence is [\x{2010}\x{AD}\p{Mn}]*
		 * and $cased_letter is [\p{Ll}\p{Lo}\p{Lt}]
		 * then it should be mapped to 0x03C2,
		 * (GREEK SMALL LETTER FINAL SIGMA),
		 * instead of staying 0x03A3.
		 * "should be": in other words, this is not implemented yet.
		 * See lib/unicore/SpecialCasing.txt.
		 */
d3676 14
a3689 14
	    if (ulen > u && (SvLEN(dest) < (min += ulen - u))) {
		/* If the eventually required minimum size outgrows
		 * the available space, we need to grow. */
		const UV o = d - (U8*)SvPVX_const(dest);

		/* If someone lowercases one million U+0130s we SvGROW() one
		 * million times.  Or we could try guessing how much to
		 allocate without allocating too much.  Such is life. */
		SvGROW(dest, min);
		d = (U8*)SvPVX(dest) + o;
	    }
	    Copy(tmpbuf, d, ulen, U8);
	    d += ulen;
	    s += u;
d3691 2
a3692 4
	SvUTF8_on(dest);
	*d = '\0';
	SvCUR_set(dest, d - (U8*)SvPVX_const(dest));
    } else {
d3694 2
a3695 1
	    const U8 *const send = s + len;
d3698 3
a3700 3
		SvTAINTED_on(dest);
		for (; s < send; d++, s++)
		    *d = toLOWER_LC(*s);
d3703 2
a3704 2
		for (; s < send; d++, s++)
		    *d = toLOWER(*s);
a3706 4
	if (source != dest) {
	    *d = '\0';
	    SvCUR_set(dest, d - (U8*)SvPVX_const(dest));
	}
d3708 1
a3708 1
    SvSETMAGIC(dest);
d3714 1
a3714 1
    dVAR; dSP; dTARGET;
d3722 1
a3722 1
	SvUPGRADE(TARG, SVt_PV);
d3767 1
a3767 1
    dVAR; dSP; dMARK; dORIGMARK;
d3772 1
a3772 1
	const I32 arybase = CopARYBASE_get(PL_curcop);
d3777 1
a3777 1
		const I32 elem = SvIV(*svp);
d3786 1
a3786 1
	    I32 elem = SvIV(*MARK);
a3811 1
    dVAR;
d3813 1
a3813 1
    HV * hash = (HV*)POPs;
d3816 1
d3820 1
a3820 1
    entry = hv_iternext(hash);
d3831 2
a3832 1
	    val = hv_iterval(hash, entry);
d3843 10
a3854 1
    dVAR;
d3869 13
a3881 7
	else if (hvtype == SVt_PVAV) {                  /* array element */
            if (PL_op->op_flags & OPf_SPECIAL) {
                while (++MARK <= SP) {
                    SV * const sv = av_delete((AV*)hv, SvIV(*MARK), discard);
                    *MARK = sv ? sv : &PL_sv_undef;
                }
            }
d3906 1
a3906 1
		DIE(aTHX_ "panic: avhv_delete no longer supported");
a3919 1
    dVAR;
d3926 2
a3927 2
	SV * const sv = POPs;
	CV * const cv = sv_2cv(sv, &hv, &gv, 0);
d3945 2
d3956 1
a3956 1
    dVAR; dSP; dMARK; dORIGMARK;
d3959 2
a3960 1
    const bool localizing = PL_op->op_private & OPpLVAL_INTRO;
d3977 2
a3978 10
    while (++MARK <= SP) {
        SV * const keysv = *MARK;
        SV **svp;
        HE *he;
        bool preeminent = FALSE;

        if (localizing) {
            preeminent = SvRMAGICAL(hv) && !other_magic ? 1 :
                hv_exists_ent(hv, keysv, 0);
        }
d3980 5
a3984 2
        he = hv_fetch_ent(hv, keysv, lval, 0);
        svp = he ? &HeVAL(he) : NULL;
d3986 4
a3989 3
        if (lval) {
            if (!svp || *svp == &PL_sv_undef) {
                DIE(aTHX_ PL_no_helem_sv, SVfARG(keysv));
d3991 13
a4003 4
            if (localizing) {
		if (HvNAME_get(hv) && isGV(*svp))
		    save_gp((GV*)*svp, !(PL_op->op_flags & OPf_SPECIAL));
		else {
d4005 1
a4005 1
			save_helem(hv, keysv, svp);
d4008 2
a4009 3
			const char * const key = SvPV_const(keysv, keylen);
			SAVEDELETE(hv, savepvn(key,keylen),
				   SvUTF8(keysv) ? -(I32)keylen : (I32)keylen);
d4011 4
a4014 4
		}
            }
        }
        *MARK = svp ? *svp : &PL_sv_undef;
d4028 1
a4028 1
    dVAR; dSP; dMARK;
a4040 1
    dVAR;
d4046 2
a4047 2
    const I32 arybase = CopARYBASE_get(PL_curcop);
    I32 is_something_there = FALSE;
d4053 1
a4053 1
	I32 ix = SvIV(*lastlelem);
d4072 1
a4072 1
	I32 ix = SvIV(*lelem);
d4094 1
a4094 1
    dVAR; dSP; dMARK; dORIGMARK;
d4096 1
a4096 1
    SV * const av = (SV *) av_make(items, MARK+1);
d4098 1
a4098 2
    XPUSHs(sv_2mortal((PL_op->op_flags & OPf_SPECIAL)
		      ? newRV_noinc(av) : av));
d4104 2
a4105 2
    dVAR; dSP; dMARK; dORIGMARK;
    HV* const hv = newHV();
d4109 1
a4109 1
	SV * const val = newSV(0);
d4117 1
a4117 2
    XPUSHs(sv_2mortal((PL_op->op_flags & OPf_SPECIAL)
		      ? newRV_noinc((SV*) hv) : (SV*)hv));
d4123 1
a4123 1
    dVAR; dSP; dMARK; dORIGMARK;
d4133 1
d4150 1
a4150 1
	offset = i = SvIV(*MARK);
d4154 1
a4154 1
	    offset -= CopARYBASE_get(PL_curcop);
a4198 1
	SV **tmparyval = NULL;
d4237 1
a4237 1
	    AvARRAY(ary) = AvARRAY(ary) - diff; /* diff is negative */
a4258 1
	SV** tmparyval = NULL;
d4265 1
d4267 1
d4274 1
a4274 1
		AvARRAY(ary) = AvARRAY(ary) - diff;/* diff is positive */
d4308 1
d4319 1
a4322 1
	Safefree(tmparyval);
d4330 2
a4331 2
    dVAR; dSP; dMARK; dORIGMARK; dTARGET;
    register AV * const ary = (AV*)*++MARK;
a4341 2
	SP = ORIGMARK;
	PUSHi( AvFILL(ary) + 1 );
d4344 1
a4344 1
	PL_delaymagic = DM_DELAY;
d4346 1
a4346 1
	    SV * const sv = newSV(0);
d4349 1
a4349 1
	    av_store(ary, AvFILLp(ary)+1, sv);
d4351 5
a4355 2
	if (PL_delaymagic & DM_ARRAY)
	    mg_set((SV*)ary);
d4357 8
a4364 4
	PL_delaymagic = 0;
	SP = ORIGMARK;
	PUSHi( AvFILLp(ary) + 1 );
    }
a4369 1
    dVAR;
d4372 1
a4372 1
    SV * const sv = PL_op->op_type == OP_SHIFT ? av_shift(av) : av_pop(av);
d4374 2
a4375 1
    assert (sv);
d4384 1
a4384 1
    dVAR; dSP; dMARK; dORIGMARK; dTARGET;
d4412 1
a4412 1
    dVAR; dSP; dMARK;
a4430 1
	PADOFFSET padoff_du;
d4436 1
a4436 6
	    sv_setsv(TARG, (SP > MARK)
		    ? *SP
		    : (padoff_du = find_rundefsvoffset(),
			(padoff_du == NOT_IN_PAD
			 || PAD_COMPNAME_FLAGS_isOUR(padoff_du))
			? DEFSV : PAD_SVl(padoff_du)));
d4479 1
a4479 1
    dVAR; dSP; dTARG;
d4492 1
a4492 1
    const STRLEN slen = do_utf8 ? utf8_length((U8*)s, (U8*)strend) : (STRLEN)(strend - s);
d4501 1
a4501 2
    bool multiline = 0;
    MAGIC *mg = NULL;
d4512 2
a4513 2
    TAINT_IF((rx->extflags & RXf_PMf_LOCALE) &&
	     (rx->extflags & (RXf_WHITE | RXf_SKIPWHITE)));
d4517 1
d4519 1
a4519 3
    if (pm->op_pmreplrootu.op_pmtargetoff) {
	ary = GvAVn((GV*)PAD_SVl(pm->op_pmreplrootu.op_pmtargetoff));
    }
d4521 2
a4522 2
    if (pm->op_pmreplrootu.op_pmtargetgv) {
	ary = GvAVn(pm->op_pmreplrootu.op_pmtargetgv);
a4523 1
#endif
d4525 3
d4529 1
d4531 1
a4531 1
	ary = NULL;
d4557 2
a4558 6
    if (rx->extflags & RXf_SKIPWHITE) {
	if (do_utf8) {
	    while (*s == ' ' || is_utf8_space((U8*)s))
		s += UTF8SKIP(s);
	}
	else if (rx->extflags & RXf_PMf_LOCALE) {
d4567 3
a4569 2
    if (rx->extflags & PMf_MULTILINE) {
	multiline = 1;
d4574 1
a4574 1
    if (rx->extflags & RXf_WHITE) {
d4577 4
a4580 17
	    /* this one uses 'm' and is a negative test */
	    if (do_utf8) {
		while (m < strend && !( *m == ' ' || is_utf8_space((U8*)m) )) {
		    const int t = UTF8SKIP(m);
		    /* is_utf8_space returns FALSE for malform utf8 */
		    if (strend - m < t)
			m = strend;
		    else
			m += t;
		}
            } else if (rx->extflags & RXf_PMf_LOCALE) {
	        while (m < strend && !isSPACE_LC(*m))
		    ++m;
            } else {
                while (m < strend && !isSPACE(*m))
                    ++m;
            }  
d4591 5
a4595 17
	    /* skip the whitespace found last */
	    if (do_utf8)
		s = m + UTF8SKIP(m);
	    else
		s = m + 1;

	    /* this one uses 's' and is a positive test */
	    if (do_utf8) {
		while (s < strend && ( *s == ' ' || is_utf8_space((U8*)s) ))
	            s +=  UTF8SKIP(s);
            } else if (rx->extflags & RXf_PMf_LOCALE) {
	        while (s < strend && isSPACE_LC(*s))
		    ++s;
            } else {
                while (s < strend && isSPACE(*s))
                    ++s;
            } 	    
d4598 1
a4598 1
    else if (rx->extflags & RXf_START_ONLY) {
d4614 6
a4619 39
    else if (rx->extflags & RXf_NULL && !(s >= strend)) {
        /*
          Pre-extend the stack, either the number of bytes or
          characters in the string or a limited amount, triggered by:

          my ($x, $y) = split //, $str;
            or
          split //, $str, $i;
        */
        const U32 items = limit - 1; 
        if (items < slen)
            EXTEND(SP, items);
        else
            EXTEND(SP, slen);

        if (do_utf8) {
            while (--limit) {
                /* keep track of how many bytes we skip over */
                m = s;
                s += UTF8SKIP(s);
                dstr = newSVpvn(m, s-m);

                if (make_mortal)
                    sv_2mortal(dstr);

                (void)SvUTF8_on(dstr);
                PUSHs(dstr);

                if (s >= strend)
                    break;
            }
        } else {
            while (--limit) {
                dstr = newSVpvn(s, 1);

                s++;

                if (make_mortal)
                    sv_2mortal(dstr);
d4621 2
a4622 16
                PUSHs(dstr);

                if (s >= strend)
                    break;
            }
        }
    }
    else if (do_utf8 == ((rx->extflags & RXf_UTF8) != 0) &&
	     (rx->extflags & RXf_USE_INTUIT) && !rx->nparens
	     && (rx->extflags & RXf_CHECK_ALL)
	     && !(rx->extflags & RXf_ANCH)) {
	const int tail = (rx->extflags & RXf_INTUIT_TAIL);
	SV * const csv = CALLREG_INTUIT_STRING(rx);

	len = rx->minlenret;
	if (len == 1 && !(rx->extflags & RXf_UTF8) && !tail) {
d4646 1
a4646 1
			     csv, multiline ? FBMrf_MULTILINE : 0)) )
d4669 1
a4669 1
	    rex_return = CALLREGEXEC(rx, (char*)s, (char*)strend, (char*)orig, 1 ,
d4682 1
a4682 1
	    m = rx->offs[0].start + orig;
d4692 2
a4693 2
		    s = rx->offs[i].start + orig;
		    m = rx->offs[i].end + orig;
d4710 1
a4710 1
	    s = rx->offs[0].end + orig;
d4783 16
a4798 11
PP(pp_once)
{
    dSP;
    SV *const sv = PAD_SVl(PL_op->op_targ);

    if (SvPADSTALE(sv)) {
	/* First time. */
	SvPADSTALE_off(sv);
	RETURNOP(cLOGOP->op_other);
    }
    RETURNOP(cLOGOP->op_next);
d4800 1
a4803 1
    dVAR;
d4816 1
a4816 2

PP(unimplemented_op)
d4818 11
a4828 3
    dVAR;
    DIE(aTHX_ "panic: unimplemented op %s (#%d) called", OP_NAME(PL_op),
	PL_op->op_type);
@


1.1.1.12
log
@import perl 5.10.1
@
text
@d3 2
a4 2
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
 *    2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 by Larry Wall and others
d12 2
a13 5
 * 'It's a big house this, and very peculiar.  Always a bit more
 *  to discover, and no knowing what you'll find round a corner.
 *  And Elves, sir!'                            --Samwise Gamgee
 *
 *     [p.225 of _The Lord of the Rings_, II/i: "Many Meetings"]
d78 1
a78 1
	const I32 maxarg = AvFILL(MUTABLE_AV(TARG)) + 1;
d83 1
a83 1
		SV * const * const svp = av_fetch(MUTABLE_AV(TARG), i, FALSE);
d88 1
a88 1
	    Copy(AvARRAY((const AV *)TARG), SP+1, maxarg, SV*);
d94 1
a94 1
	const I32 maxarg = AvFILL(MUTABLE_AV(TARG)) + 1;
d122 1
a122 1
	SV* const sv = Perl_hv_scalar(aTHX_ MUTABLE_HV(TARG));
d140 1
a140 1
	    GV * const gv = MUTABLE_GV(sv_newmortal());
d142 1
a142 1
	    GvIOp(gv) = MUTABLE_IO(sv);
d144 1
a144 1
	    sv = MUTABLE_SV(gv);
d146 1
a146 1
	else if (!isGV_with_GP(sv))
d150 1
a150 1
	if (!isGV_with_GP(sv)) {
d161 1
a161 1
		    Perl_croak(aTHX_ "%s", PL_no_modify);
d168 1
a168 1
			gv = MUTABLE_GV(newSV(0));
d175 8
a182 2
		    prepare_SV_for_RV(sv);
		    SvRV_set(sv, MUTABLE_SV(gv));
d197 1
a197 1
		SV * const temp = MUTABLE_SV(gv_fetchsv(sv, 0, SVt_PVGV));
d200 1
a200 2
			|| !(sv = MUTABLE_SV(gv_fetchsv(sv, GV_ADD,
							SVt_PVGV))))) {
d215 1
a215 1
		sv = MUTABLE_SV(gv_fetchsv(sv, GV_ADD, SVt_PVGV));
d220 1
a220 1
	save_gp(MUTABLE_GV(sv), !(PL_op->op_flags & OPf_SPECIAL));
a232 2
    PERL_ARGS_ASSERT_SOFTREF2XV;

d290 1
a290 1
	gv = MUTABLE_GV(sv);
d292 1
a292 1
	if (!isGV_with_GP(gv)) {
d307 1
a307 1
		sv = save_scalar(MUTABLE_GV(TOPs));
d311 1
a311 1
		Perl_croak(aTHX_ "%s", PL_no_localize_ref);
d323 2
a324 2
    AV * const av = MUTABLE_AV(TOPs);
    SV ** const sv = Perl_av_arylen_p(aTHX_ MUTABLE_AV(av));
d327 1
a327 1
	sv_magic(*sv, MUTABLE_SV(av), PERL_MAGIC_arylen, NULL, 0);
d383 1
a383 1
	    cv = MUTABLE_CV(sv_2mortal(MUTABLE_SV(cv_clone(cv))));
d392 1
a392 1
	cv = MUTABLE_CV(gv);
d395 2
a396 2
	cv = MUTABLE_CV(&PL_sv_undef);
    SETs(MUTABLE_SV(cv));
d422 1
a422 1
		    ret = newSVpvs_flags("_;$", SVs_TEMP);
d458 1
a458 1
		ret = newSVpvn_flags(str, n - 1, SVs_TEMP);
d470 1
a470 1
	ret = newSVpvn_flags(SvPVX_const(cv), SvCUR(cv), SVs_TEMP);
d479 1
a479 1
    CV *cv = MUTABLE_CV(PAD_SV(PL_op->op_targ));
d481 1
a481 1
	cv = MUTABLE_CV(sv_2mortal(MUTABLE_SV(cv_clone(cv))));
d483 1
a483 1
    PUSHs(MUTABLE_SV(cv));
a517 2
    PERL_ARGS_ASSERT_REFTO;

d527 2
a528 2
	if (!AvREAL((const AV *)sv) && AvREIFY((const AV *)sv))
	    av_reify(MUTABLE_AV(sv));
d593 1
a593 1
    GV * const gv = MUTABLE_GV(POPs);
d603 1
a603 1
		tmpRef = MUTABLE_SV(GvAV(gv));
d607 1
a607 1
		tmpRef = MUTABLE_SV(GvCVu(gv));
d613 1
a613 1
		tmpRef = MUTABLE_SV(GvIOp(gv));
d617 1
a617 1
		    tmpRef = MUTABLE_SV(GvFORM(gv));
d621 1
a621 1
		tmpRef = MUTABLE_SV(gv);
d625 1
a625 1
		tmpRef = MUTABLE_SV(GvHV(gv));
d629 1
a629 1
		tmpRef = MUTABLE_SV(GvIOp(gv));
d633 1
a633 1
		sv = newSVhek(GvNAME_HEK(gv));
d808 1
a808 1
	av_undef(MUTABLE_AV(sv));
d811 1
a811 1
	hv_undef(MUTABLE_HV(sv));
d816 1
a816 2
		 CvANON((const CV *)sv) ? "(anonymous)"
			: GvENAME(CvGV((const CV *)sv)));
d821 3
a823 3
	    GV* const gv = CvGV((const CV *)sv);
	    cv_undef(MUTABLE_CV(sv));
	    CvGV((const CV *)sv) = gv;
d827 1
a827 1
	if (SvFAKE(sv)) {
d829 1
a829 3
	    break;
	}
	else if (isGV_with_GP(sv)) {
d834 1
a834 1
            if((stash = GvHV((const GV *)sv)) && HvNAME_get(stash))
d837 1
a837 2
            else if(GvCVu((const GV *)sv) && (stash = GvSTASH((const GV *)sv))
		    && HvNAME_get(stash))
d840 1
a840 1
	    gp_free(MUTABLE_GV(sv));
d845 1
a845 1
	    GvEGV(sv) = MUTABLE_GV(sv);
a846 1
	    break;
d848 1
a848 1
	/* FALL THROUGH */
d865 2
a866 2
    if (SvTYPE(TOPs) >= SVt_PVAV || isGV_with_GP(TOPs))
	DIE(aTHX_ "%s", PL_no_modify);
d882 2
a883 2
    if (SvTYPE(TOPs) >= SVt_PVAV || isGV_with_GP(TOPs))
	DIE(aTHX_ "%s", PL_no_modify);
d904 2
a905 2
    if (SvTYPE(TOPs) >= SVt_PVAV || isGV_with_GP(TOPs))
	DIE(aTHX_ "%s", PL_no_modify);
d1550 1
a1550 1
		items * sizeof(const SV *), count - 1);
d2432 1
a2432 1
		sv_setpvs(TARG, "-");
d2446 1
a2446 1
		    sv_setpvs(TARG, "-");
d2549 1
a2549 1
	  SETTARG;
d2565 2
a2566 1
	SETTARG;
d2634 1
a2634 1
     dVAR; dSP; dATARGET; tryAMAGICbin(modulo,opASSIGN);
d3175 1
a3175 3
	    if (!SvOK(sv))
		sv_setpvs(sv, "");
	    sv_insert_flags(sv, pos, rem, repl, repl_len, 0);
d3194 1
a3194 1
		    sv_setpvs(sv, ""); /* avoid lexical reincarnation */
d3321 3
a3323 2
	big = newSVpvn_flags(big_p, biglen,
			     SVs_TEMP | (big_utf8 ? SVf_UTF8 : 0));
d3335 3
a3337 2
	little = newSVpvn_flags(little_p, llen,
				SVs_TEMP | (little_utf8 ? SVf_UTF8 : 0));
d3502 1
a3502 1
    SETTARG;
d3881 3
a3883 1
    SETTARG;
d3892 1
a3892 1
    register AV *const av = MUTABLE_AV(POPs);
d3938 1
a3938 1
    HV * hash = MUTABLE_HV(POPs);
d3975 1
a3975 1
	HV * const hv = MUTABLE_HV(POPs);
d3986 1
a3986 1
                    SV * const sv = av_delete(MUTABLE_AV(hv), SvIV(*MARK), discard);
d4006 1
a4006 1
	HV * const hv = MUTABLE_HV(POPs);
d4012 1
a4012 1
		sv = av_delete(MUTABLE_AV(hv), SvIV(keysv), discard);
d4044 1
a4044 1
    hv = MUTABLE_HV(POPs);
d4051 1
a4051 1
	    if (av_exists(MUTABLE_AV(hv), SvIV(tmpsv)))
d4064 1
a4064 1
    register HV * const hv = MUTABLE_HV(POPs);
d4073 2
a4074 2
        other_magic = mg_find((const SV *)hv, PERL_MAGIC_env) ||
            ((mg = mg_find((const SV *)hv, PERL_MAGIC_tied))
d4078 1
a4078 1
             && (stash = SvSTASH(SvRV(SvTIED_obj(MUTABLE_SV(hv), mg))))
d4103 1
a4103 1
		    save_gp(MUTABLE_GV(*svp), !(PL_op->op_flags & OPf_SPECIAL));
d4199 1
a4199 1
    SV * const av = MUTABLE_SV(av_make(items, MARK+1));
d4201 2
a4202 2
    mXPUSHs((PL_op->op_flags & OPf_SPECIAL)
	    ? newRV_noinc(av) : av);
d4221 2
a4222 2
    mXPUSHs((PL_op->op_flags & OPf_SPECIAL)
	    ? newRV_noinc(MUTABLE_SV(hv)) : MUTABLE_SV(hv));
d4229 1
a4229 1
    register AV *ary = MUTABLE_AV(*++MARK);
d4238 1
a4238 1
    const MAGIC * const mg = SvTIED_mg((const SV *)ary, PERL_MAGIC_tied);
d4241 1
a4241 1
	*MARK-- = SvTIED_obj(MUTABLE_SV(ary), mg);
d4434 2
a4435 2
    register AV * const ary = MUTABLE_AV(*++MARK);
    const MAGIC * const mg = SvTIED_mg((const SV *)ary, PERL_MAGIC_tied);
d4438 1
a4438 1
	*MARK-- = SvTIED_obj(MUTABLE_SV(ary), mg);
d4457 1
a4457 1
	    mg_set(MUTABLE_SV(ary));
d4470 1
a4470 1
    AV * const av = MUTABLE_AV(POPs);
d4483 2
a4484 2
    register AV *ary = MUTABLE_AV(*++MARK);
    const MAGIC * const mg = SvTIED_mg((const SV *)ary, PERL_MAGIC_tied);
d4487 1
a4487 1
	*MARK-- = SvTIED_obj(MUTABLE_SV(ary), mg);
d4604 1
a4604 1
    U32 make_mortal = SVs_TEMP;
d4617 2
a4618 2
    TAINT_IF((RX_EXTFLAGS(rx) & RXf_PMf_LOCALE) &&
	     (RX_EXTFLAGS(rx) & (RXf_WHITE | RXf_SKIPWHITE)));
d4624 1
a4624 1
	ary = GvAVn(MUTABLE_GV(PAD_SVl(pm->op_pmreplrootu.op_pmtargetoff)));
d4641 1
a4641 1
	if ((mg = SvTIED_mg((const SV *)ary, PERL_MAGIC_tied))) {
d4643 1
a4643 1
	    XPUSHs(SvTIED_obj(MUTABLE_SV(ary), mg));
d4660 1
a4660 1
    if (RX_EXTFLAGS(rx) & RXf_SKIPWHITE) {
d4665 1
a4665 1
	else if (RX_EXTFLAGS(rx) & RXf_PMf_LOCALE) {
d4674 1
a4674 1
    if (RX_EXTFLAGS(rx) & PMf_MULTILINE) {
d4680 1
a4680 1
    if (RX_EXTFLAGS(rx) & RXf_WHITE) {
d4693 1
a4693 1
            } else if (RX_EXTFLAGS(rx) & RXf_PMf_LOCALE) {
d4703 5
a4707 2
	    dstr = newSVpvn_flags(s, m-s,
				  (do_utf8 ? SVf_UTF8 : 0) | make_mortal);
d4720 1
a4720 1
            } else if (RX_EXTFLAGS(rx) & RXf_PMf_LOCALE) {
d4729 1
a4729 1
    else if (RX_EXTFLAGS(rx) & RXf_START_ONLY) {
d4736 5
a4740 2
	    dstr = newSVpvn_flags(s, m-s,
				  (do_utf8 ? SVf_UTF8 : 0) | make_mortal);
d4745 1
a4745 1
    else if (RX_EXTFLAGS(rx) & RXf_NULL && !(s >= strend)) {
d4765 1
a4765 1
                dstr = newSVpvn_flags(m, s-m, SVf_UTF8 | make_mortal);
d4767 4
d4792 5
a4796 5
    else if (do_utf8 == (RX_UTF8(rx) != 0) &&
	     (RX_EXTFLAGS(rx) & RXf_USE_INTUIT) && !RX_NPARENS(rx)
	     && (RX_EXTFLAGS(rx) & RXf_CHECK_ALL)
	     && !(RX_EXTFLAGS(rx) & RXf_ANCH)) {
	const int tail = (RX_EXTFLAGS(rx) & RXf_INTUIT_TAIL);
d4799 2
a4800 2
	len = RX_MINLENRET(rx);
	if (len == 1 && !RX_UTF8(rx) && !tail) {
d4807 5
a4811 2
		dstr = newSVpvn_flags(s, m-s,
				      (do_utf8 ? SVf_UTF8 : 0) | make_mortal);
d4826 5
a4830 2
		dstr = newSVpvn_flags(s, m-s,
				      (do_utf8 ? SVf_UTF8 : 0) | make_mortal);
d4842 1
a4842 1
	maxiters += slen * RX_NPARENS(rx);
d4853 1
a4853 1
	    if (RX_MATCH_COPIED(rx) && RX_SUBBEG(rx) != orig) {
d4856 1
a4856 1
		orig = RX_SUBBEG(rx);
d4860 6
a4865 3
	    m = RX_OFFS(rx)[0].start + orig;
	    dstr = newSVpvn_flags(s, m-s,
				  (do_utf8 ? SVf_UTF8 : 0) | make_mortal);
d4867 1
a4867 1
	    if (RX_NPARENS(rx)) {
d4869 3
a4871 3
		for (i = 1; i <= (I32)RX_NPARENS(rx); i++) {
		    s = RX_OFFS(rx)[i].start + orig;
		    m = RX_OFFS(rx)[i].end + orig;
d4877 1
a4877 3
			dstr = newSVpvn_flags(s, m-s,
					     (do_utf8 ? SVf_UTF8 : 0)
					      | make_mortal);
d4881 4
d4888 1
a4888 1
	    s = RX_OFFS(rx)[0].end + orig;
d4899 5
a4903 1
	dstr = newSVpvn_flags(s, l, (do_utf8 ? SVf_UTF8 : 0) | make_mortal);
d4923 1
a4923 1
		mg_set(MUTABLE_SV(ary));
@


1.1.1.13
log
@Perl 5.12.2 from CPAN
@
text
@a65 1
    assert(SvTYPE(TARG) == SVt_PVAV);
a108 1
    assert(SvTYPE(TARG) == SVt_PVHV);
a132 3
static const char S_no_symref_sv[] =
    "Can't use string (\"%" SVf32 "\"%s) as %s ref while \"strict refs\" in use";

d205 1
a205 1
		    DIE(aTHX_ S_no_symref_sv, sv, (SvPOK(sv) && SvCUR(sv)>32 ? "..." : ""), "a symbol");
d225 2
a226 2
Perl_softref2xv(pTHX_ SV *const sv, const char *const what,
		const svtype type, SV ***spp)
d235 1
a235 1
	    Perl_die(aTHX_ S_no_symref_sv, sv, (SvPOK(sv) && SvCUR(sv)>32 ? "..." : ""), what);
d324 4
a327 12
    const I32 lvalue = PL_op->op_flags & OPf_MOD || LVRET;
    if (lvalue) {
	SV ** const sv = Perl_av_arylen_p(aTHX_ MUTABLE_AV(av));
	if (!*sv) {
	    *sv = newSV_type(SVt_PVMG);
	    sv_magic(*sv, MUTABLE_SV(av), PERL_MAGIC_arylen, NULL, 0);
	}
	SETs(*sv);
    } else {
	SETs(sv_2mortal(newSViv(
	    AvFILL(MUTABLE_AV(av)) + CopARYBASE_get(PL_curcop)
	)));
d329 1
d345 2
a346 1
	    SvREFCNT_dec(LvTARG(TARG));
a424 4
		if (code == -KEY_keys || code == -KEY_values || code == -KEY_each) {
		    ret = newSVpvs_flags("\\[@@%]", SVs_TEMP);
		    goto set;
		}
d541 1
a541 1
    sv_upgrade(rv, SVt_IV);
d579 3
a581 3
	if (len == 0)
	    Perl_ck_warner(aTHX_ packWARN(WARN_MISC),
			   "Explicit blessing to '' (assuming package main)");
d816 4
a819 4
	if (cv_const_sv((const CV *)sv))
	    Perl_ck_warner(aTHX_ packWARN(WARN_MISC), "Constant subroutine %s undefined",
			   CvANON((const CV *)sv) ? "(anonymous)"
			   : GvENAME(CvGV((const CV *)sv)));
d3033 4
a3036 5
    if (SvGAMAGIC(sv)) {
	/* For an overloaded or magic scalar, we can't know in advance if
	   it's going to be UTF-8 or not. Also, we can't call sv_len_utf8 as
	   it likes to cache the length. Maybe that should be a documented
	   feature of it.
d3039 1
a3039 3
	const char *const p
	    = sv_2pv_flags(sv, &len,
			   SV_UNDEF_RETURNS_NULL|SV_CONST_RETURN|SV_GMAGIC);
d3041 1
a3041 5
	if (!p) {
	    sv_setsv(TARG, &PL_sv_undef);
	    SETTARG;
	}
	else if (DO_UTF8(sv)) {
d3046 1
a3046 9
    } else if (SvOK(sv)) {
	/* Neither magic nor overloaded.  */
	if (DO_UTF8(sv))
	    SETi(sv_len_utf8(sv));
	else
	    SETi(sv_len(sv));
    } else {
	sv_setsv_nomg(TARG, &PL_sv_undef);
	SETTARG;
d3048 4
d3059 1
d3062 3
a3064 8
    SV *   pos_sv;
    IV     pos1_iv;
    int    pos1_is_uv;
    IV     pos2_iv;
    int    pos2_is_uv;
    SV *   len_sv;
    IV     len_iv = 0;
    int    len_is_uv = 1;
d3067 1
a3067 1
    const IV arybase = CopARYBASE_get(PL_curcop);
d3083 3
a3085 7
	len_sv    = POPs;
	len_iv    = SvIV(len_sv);
	len_is_uv = SvIOK_UV(len_sv);
    }
    pos_sv     = POPs;
    pos1_iv    = SvIV(pos_sv);
    pos1_is_uv = SvIOK_UV(pos_sv);
d3107 12
a3118 20
    if ( (pos1_is_uv && arybase < 0) || (pos1_iv >= arybase) ) { /* pos >= $[ */
	UV pos1_uv = pos1_iv-arybase;
	/* Overflow can occur when $[ < 0 */
	if (arybase < 0 && pos1_uv < (UV)pos1_iv)
	    goto bound_fail;
	pos1_iv = pos1_uv;
	pos1_is_uv = 1;
    }
    else if (pos1_is_uv ? (UV)pos1_iv > 0 : pos1_iv > 0) {
	goto bound_fail;  /* $[=3; substr($_,2,...) */
    }
    else { /* pos < $[ */
	if (pos1_iv == 0) { /* $[=1; substr($_,0,...) */
	    pos1_iv = curlen;
	    pos1_is_uv = 1;
	} else {
	    if (curlen) {
		pos1_is_uv = curlen-1 > ~(UV)pos1_iv;
		pos1_iv += curlen;
	   }
d3121 8
a3128 23
    if (pos1_is_uv || pos1_iv > 0) {
	if ((UV)pos1_iv > curlen)
	    goto bound_fail;
    }

    if (num_args > 2) {
	if (!len_is_uv && len_iv < 0) {
	    pos2_iv = curlen + len_iv;
	    if (curlen)
		pos2_is_uv = curlen-1 > ~(UV)len_iv;
	    else
		pos2_is_uv = 0;
	} else {  /* len_iv >= 0 */
	    if (!pos1_is_uv && pos1_iv < 0) {
		pos2_iv = pos1_iv + len_iv;
		pos2_is_uv = (UV)len_iv > (UV)IV_MAX;
	    } else {
		if ((UV)len_iv > curlen-(UV)pos1_iv)
		    pos2_iv = curlen;
		else
		    pos2_iv = pos1_iv+len_iv;
		pos2_is_uv = 1;
	    }
d3130 16
d3148 5
a3152 26
	pos2_iv = curlen;
	pos2_is_uv = 1;
    }

    if (!pos2_is_uv && pos2_iv < 0) {
	if (!pos1_is_uv && pos1_iv < 0)
	    goto bound_fail;
	pos2_iv = 0;
    }
    else if (!pos1_is_uv && pos1_iv < 0)
	pos1_iv = 0;

    if ((UV)pos2_iv < (UV)pos1_iv)
	pos2_iv = pos1_iv;
    if ((UV)pos2_iv > curlen)
	pos2_iv = curlen;

    {
	/* pos1_iv and pos2_iv both in 0..curlen, so the cast is safe */
	const STRLEN pos = (STRLEN)( (UV)pos1_iv );
	const STRLEN len = (STRLEN)( (UV)pos2_iv - (UV)pos1_iv );
	STRLEN byte_len = len;
	STRLEN byte_pos = utf8_curlen
	    ? sv_pos_u2b_flags(sv, pos, &byte_len, SV_CONST_RETURN) : pos;

	tmps += byte_pos;
d3166 1
a3166 1
	sv_setpvn(TARG, tmps, byte_len);
d3183 1
a3183 1
	    sv_insert_flags(sv, byte_pos, byte_len, repl, repl_len, 0);
d3186 2
a3187 1
	    SvREFCNT_dec(repl_sv_copy);
d3193 3
a3195 2
		    Perl_ck_warner(aTHX_ packWARN(WARN_SUBSTR),
				   "Attempt to use reference as lvalue in substr");
d3212 2
a3213 1
		SvREFCNT_dec(LvTARG(TARG));
d3216 2
a3217 2
	    LvTARGOFF(TARG) = pos;
	    LvTARGLEN(TARG) = len;
a3222 6

bound_fail:
    if (lvalue || repl)
	Perl_croak(aTHX_ "substr outside of string");
    Perl_ck_warner(aTHX_ packWARN(WARN_SUBSTR), "substr outside of string");
    RETPUSHUNDEF;
d3243 2
a3244 1
	    SvREFCNT_dec(LvTARG(TARG));
d3370 2
a3371 1
    SvREFCNT_dec(temp);
a3512 1
    return NORMAL;
a3515 66
/* Generally UTF-8 and UTF-EBCDIC are indistinguishable at this level.  So 
 * most comments below say UTF-8, when in fact they mean UTF-EBCDIC as well */

/* Both the characters below can be stored in two UTF-8 bytes.  In UTF-8 the max
 * character that 2 bytes can hold is U+07FF, and in UTF-EBCDIC it is U+03FF.
 * See http://www.unicode.org/unicode/reports/tr16 */
#define LATIN_CAPITAL_LETTER_Y_WITH_DIAERESIS 0x0178	/* Also is title case */
#define GREEK_CAPITAL_LETTER_MU 0x039C	/* Upper and title case of MICRON */

/* Below are several macros that generate code */
/* Generates code to store a unicode codepoint c that is known to occupy
 * exactly two UTF-8 and UTF-EBCDIC bytes; it is stored into p and p+1. */
#define STORE_UNI_TO_UTF8_TWO_BYTE(p, c)				    \
    STMT_START {							    \
	*(p) = UTF8_TWO_BYTE_HI(c);					    \
	*((p)+1) = UTF8_TWO_BYTE_LO(c);					    \
    } STMT_END

/* Like STORE_UNI_TO_UTF8_TWO_BYTE, but advances p to point to the next
 * available byte after the two bytes */
#define CAT_UNI_TO_UTF8_TWO_BYTE(p, c)					    \
    STMT_START {							    \
	*(p)++ = UTF8_TWO_BYTE_HI(c);					    \
	*((p)++) = UTF8_TWO_BYTE_LO(c);					    \
    } STMT_END

/* Generates code to store the upper case of latin1 character l which is known
 * to have its upper case be non-latin1 into the two bytes p and p+1.  There
 * are only two characters that fit this description, and this macro knows
 * about them, and that the upper case values fit into two UTF-8 or UTF-EBCDIC
 * bytes */
#define STORE_NON_LATIN1_UC(p, l)					    \
STMT_START {								    \
    if ((l) == LATIN_SMALL_LETTER_Y_WITH_DIAERESIS) {			    \
	STORE_UNI_TO_UTF8_TWO_BYTE((p), LATIN_CAPITAL_LETTER_Y_WITH_DIAERESIS);  \
    } else { /* Must be the following letter */								    \
	STORE_UNI_TO_UTF8_TWO_BYTE((p), GREEK_CAPITAL_LETTER_MU);	    \
    }									    \
} STMT_END

/* Like STORE_NON_LATIN1_UC, but advances p to point to the next available byte
 * after the character stored */
#define CAT_NON_LATIN1_UC(p, l)						    \
STMT_START {								    \
    if ((l) == LATIN_SMALL_LETTER_Y_WITH_DIAERESIS) {			    \
	CAT_UNI_TO_UTF8_TWO_BYTE((p), LATIN_CAPITAL_LETTER_Y_WITH_DIAERESIS);    \
    } else {								    \
	CAT_UNI_TO_UTF8_TWO_BYTE((p), GREEK_CAPITAL_LETTER_MU);		    \
    }									    \
} STMT_END

/* Generates code to add the two UTF-8 bytes (probably u) that are the upper
 * case of l into p and p+1.  u must be the result of toUPPER_LATIN1_MOD(l),
 * and must require two bytes to store it.  Advances p to point to the next
 * available position */
#define CAT_TWO_BYTE_UNI_UPPER_MOD(p, l, u)				    \
STMT_START {								    \
    if ((u) != LATIN_SMALL_LETTER_Y_WITH_DIAERESIS) {			    \
	CAT_UNI_TO_UTF8_TWO_BYTE((p), (u)); /* not special, just save it */ \
    } else if (l == LATIN_SMALL_LETTER_SHARP_S) {			    \
	*(p)++ = 'S'; *(p)++ = 'S'; /* upper case is 'SS' */		    \
    } else {/* else is one of the other two special cases */		    \
	CAT_NON_LATIN1_UC((p), (l));					    \
    }									    \
} STMT_END

a3517 5
    /* Actually is both lcfirst() and ucfirst().  Only the first character
     * changes.  This means that possibly we can change in-place, ie., just
     * take the source and change that one character and store it back, but not
     * if read-only etc, or if the length changes */

d3521 1
a3521 1
    STRLEN slen; /* slen is the byte length of the whole SV. */
d3524 2
a3525 3
    bool inplace;   /* ? Convert first char only, in-place */
    bool doing_utf8 = FALSE;		   /* ? using utf8 */
    bool convert_source_to_utf8 = FALSE;   /* ? need to convert */
d3530 2
a3531 5
    STRLEN ulen;    /* ulen is the byte length of the original Unicode character
		     * stored as UTF-8 at s. */
    STRLEN tculen;  /* tculen is the byte length of the freshly titlecased (or
		     * lowercased) character stored in tmpbuf.  May be either
		     * UTF-8 or not, but in either case is the number of bytes */
a3536 2
	if (ckWARN(WARN_UNINITIALIZED))
	    report_uninit(source);
d3541 1
a3541 13
    /* We may be able to get away with changing only the first character, in
     * place, but not if read-only, etc.  Later we may discover more reasons to
     * not convert in-place. */
    inplace = SvPADTMP(source) && !SvREADONLY(source) && SvTEMP(source);

    /* First calculate what the changed first character should be.  This affects
     * whether we can just swap it out, leaving the rest of the string unchanged,
     * or even if have to convert the dest to UTF-8 when the source isn't */

    if (! slen) {   /* If empty */
	need = 1; /* still need a trailing NUL */
    }
    else if (DO_UTF8(source)) {	/* Is the source utf8? */
d3543 5
a3547 78

/* TODO: This is #ifdefd out because it has hard-coded the standard mappings,
 * and doesn't allow for the user to specify their own.  When code is added to
 * detect if there is a user-defined mapping in force here, and if so to use
 * that, then the code below can be compiled.  The detection would be a good
 * thing anyway, as currently the user-defined mappings only work on utf8
 * strings, and thus depend on the chosen internal storage method, which is a
 * bad thing */
#ifdef GO_AHEAD_AND_BREAK_USER_DEFINED_CASE_MAPPINGS
	if (UTF8_IS_INVARIANT(*s)) {

	    /* An invariant source character is either ASCII or, in EBCDIC, an
	     * ASCII equivalent or a caseless C1 control.  In both these cases,
	     * the lower and upper cases of any character are also invariants
	     * (and title case is the same as upper case).  So it is safe to
	     * use the simple case change macros which avoid the overhead of
	     * the general functions.  Note that if perl were to be extended to
	     * do locale handling in UTF-8 strings, this wouldn't be true in,
	     * for example, Lithuanian or Turkic.  */
	    *tmpbuf = (op_type == OP_LCFIRST) ? toLOWER(*s) : toUPPER(*s);
	    tculen = ulen = 1;
	    need = slen + 1;
	}
	else if (UTF8_IS_DOWNGRADEABLE_START(*s)) {
	    U8 chr;

	    /* Similarly, if the source character isn't invariant but is in the
	     * latin1 range (or EBCDIC equivalent thereof), we have the case
	     * changes compiled into perl, and can avoid the overhead of the
	     * general functions.  In this range, the characters are stored as
	     * two UTF-8 bytes, and it so happens that any changed-case version
	     * is also two bytes (in both ASCIIish and EBCDIC machines). */
	    tculen = ulen = 2;
	    need = slen + 1;

	    /* Convert the two source bytes to a single Unicode code point
	     * value, change case and save for below */
	    chr = UTF8_ACCUMULATE(*s, *(s+1));
	    if (op_type == OP_LCFIRST) {    /* lower casing is easy */
		U8 lower = toLOWER_LATIN1(chr);
		STORE_UNI_TO_UTF8_TWO_BYTE(tmpbuf, lower);
	    }
	    else {	/* ucfirst */
		U8 upper = toUPPER_LATIN1_MOD(chr);

		/* Most of the latin1 range characters are well-behaved.  Their
		 * title and upper cases are the same, and are also in the
		 * latin1 range.  The macro above returns their upper (hence
		 * title) case, and all that need be done is to save the result
		 * for below.  However, several characters are problematic, and
		 * have to be handled specially.  The MOD in the macro name
		 * above means that these tricky characters all get mapped to
		 * the single character LATIN_SMALL_LETTER_Y_WITH_DIAERESIS.
		 * This mapping saves some tests for the majority of the
		 * characters */

		if (upper != LATIN_SMALL_LETTER_Y_WITH_DIAERESIS) {

		    /* Not tricky.  Just save it. */
		    STORE_UNI_TO_UTF8_TWO_BYTE(tmpbuf, upper);
		}
		else if (chr == LATIN_SMALL_LETTER_SHARP_S) {

		    /* This one is tricky because it is two characters long,
		     * though the UTF-8 is still two bytes, so the stored
		     * length doesn't change */
		    *tmpbuf = 'S';  /* The UTF-8 is 'Ss' */
		    *(tmpbuf + 1) = 's';
		}
		else {

		    /* The other two have their title and upper cases the same,
		     * but are tricky because the changed-case characters
		     * aren't in the latin1 range.  They, however, do fit into
		     * two UTF-8 bytes */
		    STORE_NON_LATIN1_UC(tmpbuf, chr);    
		}
	    }
d3549 6
a3554 15
	else {
#endif	/* end of dont want to break user-defined casing */

	    /* Here, can't short-cut the general case */

	    utf8_to_uvchr(s, &ulen);
	    if (op_type == OP_UCFIRST) toTITLE_utf8(s, tmpbuf, &tculen);
	    else toLOWER_utf8(s, tmpbuf, &tculen);

	    /* we can't do in-place if the length changes.  */
	    if (ulen != tculen) inplace = FALSE;
	    need = slen + 1 - ulen + tculen;
#ifdef GO_AHEAD_AND_BREAK_USER_DEFINED_CASE_MAPPINGS
	}
#endif
a3555 6
    else { /* Non-zero length, non-UTF-8,  Need to consider locale and if
	    * latin1 is treated as caseless.  Note that a locale takes
	    * precedence */ 
	tculen = 1;	/* Most characters will require one byte, but this will
			 * need to be overridden for the tricky ones */
	need = slen + 1;
d3557 2
a3558 1
	if (op_type == OP_LCFIRST) {
a3559 63
	    /* lower case the first letter: no trickiness for any character */
	    *tmpbuf = (IN_LOCALE_RUNTIME) ? toLOWER_LC(*s) :
			((IN_UNI_8_BIT) ? toLOWER_LATIN1(*s) : toLOWER(*s));
	}
	/* is ucfirst() */
	else if (IN_LOCALE_RUNTIME) {
	    *tmpbuf = toUPPER_LC(*s);	/* This would be a bug if any locales
					 * have upper and title case different
					 */
	}
	else if (! IN_UNI_8_BIT) {
	    *tmpbuf = toUPPER(*s);	/* Returns caseless for non-ascii, or
					 * on EBCDIC machines whatever the
					 * native function does */
	}
	else { /* is ucfirst non-UTF-8, not in locale, and cased latin1 */
	    *tmpbuf = toUPPER_LATIN1_MOD(*s);

	    /* tmpbuf now has the correct title case for all latin1 characters
	     * except for the several ones that have tricky handling.  All
	     * of these are mapped by the MOD to the letter below. */
	    if (*tmpbuf == LATIN_SMALL_LETTER_Y_WITH_DIAERESIS) {

		/* The length is going to change, with all three of these, so
		 * can't replace just the first character */
		inplace = FALSE;

		/* We use the original to distinguish between these tricky
		 * cases */
		if (*s == LATIN_SMALL_LETTER_SHARP_S) {
		    /* Two character title case 'Ss', but can remain non-UTF-8 */
		    need = slen + 2;
		    *tmpbuf = 'S';
		    *(tmpbuf + 1) = 's';   /* Assert: length(tmpbuf) >= 2 */
		    tculen = 2;
		}
		else {

		    /* The other two tricky ones have their title case outside
		     * latin1.  It is the same as their upper case. */
		    doing_utf8 = TRUE;
		    STORE_NON_LATIN1_UC(tmpbuf, *s);

		    /* The UTF-8 and UTF-EBCDIC lengths of both these characters
		     * and their upper cases is 2. */
		    tculen = ulen = 2;

		    /* The entire result will have to be in UTF-8.  Assume worst
		     * case sizing in conversion. (all latin1 characters occupy
		     * at most two bytes in utf8) */
		    convert_source_to_utf8 = TRUE;
		    need = slen * 2 + 1;
		}
	    } /* End of is one of the three special chars */
	} /* End of use Unicode (Latin1) semantics */
    } /* End of changing the case of the first character */

    /* Here, have the first character's changed case stored in tmpbuf.  Ready to
     * generate the result */
    if (inplace) {

	/* We can convert in place.  This means we change just the first
	 * character without disturbing the rest; no need to grow */
a3566 2
	/* Here, we can't convert in place; we earlier calculated how much
	 * space we will need, so grow to accommodate that */
d3572 2
d3577 11
a3587 32
	if (! inplace) {
	    if (! convert_source_to_utf8) {

		/* Here  both source and dest are in UTF-8, but have to create
		 * the entire output.  We initialize the result to be the
		 * title/lower cased first character, and then append the rest
		 * of the string. */
		sv_setpvn(dest, (char*)tmpbuf, tculen);
		if (slen > ulen) {
		    sv_catpvn(dest, (char*)(s + ulen), slen - ulen);
		}
	    }
	    else {
		const U8 *const send = s + slen;

		/* Here the dest needs to be in UTF-8, but the source isn't,
		 * except we earlier UTF-8'd the first character of the source
		 * into tmpbuf.  First put that into dest, and then append the
		 * rest of the source, converting it to UTF-8 as we go. */

		/* Assert tculen is 2 here because the only two characters that
		 * get to this part of the code have 2-byte UTF-8 equivalents */
		*d++ = *tmpbuf;
		*d++ = *(tmpbuf + 1);
		s++;	/* We have just processed the 1st char */

		for (; s < send; s++) {
		    d = uvchr_to_utf8(d, *s);
		}
		*d = '\0';
		SvCUR_set(dest, d - (U8*)SvPVX_const(dest));
	    }
d3590 1
a3590 1
	else {   /* in-place UTF-8.  Just overwrite the first character */
d3595 2
a3596 2
    else {  /* Neither source nor dest are in or need to be UTF-8 */
	if (slen) {
d3600 2
d3603 4
a3606 13
	    if (inplace) {  /* in-place, only need to change the 1st char */
		*d = *tmpbuf;
	    }
	    else {	/* Not in-place */

		/* Copy the case-changed character(s) from tmpbuf */
		Copy(tmpbuf, d, tculen, U8);
		d += tculen - 1; /* Code below expects d to point to final
				  * character stored */
	    }
	}
	else {	/* empty source */
	    /* See bug #39028: Don't taint if empty  */
a3609 2
	/* In a "use bytes" we don't treat the source as UTF-8, but, still want
	 * the destination to retain that flag */
d3613 1
a3613 1
	if (!inplace) {	/* Finish the rest of the string, unchanged */
d3625 1
a3625 1
   of the three tight loops.  There is less and less commonality though */
d3640 2
a3641 2
	&& SvTEMP(source) && !DO_UTF8(source)
	&& (IN_LOCALE_RUNTIME || ! IN_UNI_8_BIT)) {
a3642 7
	/* We can convert in place.  The reason we can't if in UNI_8_BIT is to
	 * make the loop tight, so we overwrite the source with the dest before
	 * looking at it, and we need to look at the original source
	 * afterwards.  There would also need to be code added to handle
	 * switching to not in-place in midstream if we run into characters
	 * that change the length.
	 */
a3660 2
	    if (ckWARN(WARN_UNINITIALIZED))
		report_uninit(source);
a3679 10
/* This is ifdefd out because it needs more work and thought.  It isn't clear
 * that we should do it.  These are hard-coded rules from the Unicode standard,
 * and may change.  5.2 gives new guidance on the iota subscript, for example,
 * which has not been checked against this; and secondly it may be that we are
 * passed a subset of the context, via a \U...\E, for example, and its not
 * clear what the best approach is to that */
#ifdef CONTEXT_DEPENDENT_CASING
	bool in_iota_subscript = FALSE;
#endif

d3681 2
a3682 40
#ifdef CONTEXT_DEPENDENT_CASING
	    if (in_iota_subscript && ! is_utf8_mark(s)) {
		/* A non-mark.  Time to output the iota subscript */
#define GREEK_CAPITAL_LETTER_IOTA 0x0399
#define COMBINING_GREEK_YPOGEGRAMMENI 0x0345

		CAT_UNI_TO_UTF8_TWO_BYTE(d, GREEK_CAPITAL_LETTER_IOTA);
		in_iota_subscript = FALSE;
	    }
#endif


/* See comments at the first instance in this file of this ifdef */
#ifdef GO_AHEAD_AND_BREAK_USER_DEFINED_CASE_MAPPINGS

	    /* If the UTF-8 character is invariant, then it is in the range
	     * known by the standard macro; result is only one byte long */
	    if (UTF8_IS_INVARIANT(*s)) {
		*d++ = toUPPER(*s);
		s++;
	    }
	    else if (UTF8_IS_DOWNGRADEABLE_START(*s)) {

		/* Likewise, if it fits in a byte, its case change is in our
		 * table */
		U8 orig = UTF8_ACCUMULATE(*s, *(s+1));
		U8 upper = toUPPER_LATIN1_MOD(orig);
		CAT_TWO_BYTE_UNI_UPPER_MOD(d, orig, upper);
		s += 2;
	    }
	    else {
#else
	    {
#endif

		/* Otherwise, need the general UTF-8 case.  Get the changed
		 * case value and copy it to the output buffer */

		const STRLEN u = UTF8SKIP(s);
		STRLEN ulen;
d3684 15
a3698 29
#ifndef CONTEXT_DEPENDENT_CASING
		toUPPER_utf8(s, tmpbuf, &ulen);
#else
		const UV uv = toUPPER_utf8(s, tmpbuf, &ulen);
		if (uv == GREEK_CAPITAL_LETTER_IOTA && utf8_to_uvchr(s, 0) == COMBINING_GREEK_YPOGEGRAMMENI) {
		    in_iota_subscript = TRUE;
		}
		else {
#endif
		    if (ulen > u && (SvLEN(dest) < (min += ulen - u))) {
			/* If the eventually required minimum size outgrows
			 * the available space, we need to grow. */
			const UV o = d - (U8*)SvPVX_const(dest);

			/* If someone uppercases one million U+03B0s we
			 * SvGROW() one million times.  Or we could try
			 * guessing how much to allocate without allocating too
			 * much.  Such is life.  See corresponding comment in lc code
			 * for another option */
			SvGROW(dest, min);
			d = (U8*)SvPVX(dest) + o;
		    }
		    Copy(tmpbuf, d, ulen, U8);
		    d += ulen;
#ifdef CONTEXT_DEPENDENT_CASING
		}
#endif
		s += u;
	    }
a3699 3
#ifdef CONTEXT_DEPENDENT_CASING
	if (in_iota_subscript) CAT_UNI_TO_UTF8_TWO_BYTE(d, GREEK_CAPITAL_LETTER_IOTA);
#endif
d3703 1
a3703 1
    } else {	/* Not UTF-8 */
a3705 4

	    /* Use locale casing if in locale; regular style if not treating
	     * latin1 as having case; otherwise the latin1 casing.  Do the
	     * whole thing in a tight loop, for speed, */
d3712 2
a3713 2
	    else if (! IN_UNI_8_BIT) {
		for (; s < send; d++, s++) {
a3714 1
		}
d3716 1
a3716 92
	    else {
		for (; s < send; d++, s++) {
		    *d = toUPPER_LATIN1_MOD(*s);
		    if (*d != LATIN_SMALL_LETTER_Y_WITH_DIAERESIS) continue;

		    /* The mainstream case is the tight loop above.  To avoid
		     * extra tests in that, all three characters that require
		     * special handling are mapped by the MOD to the one tested
		     * just above.  
		     * Use the source to distinguish between the three cases */

		    if (*s == LATIN_SMALL_LETTER_SHARP_S) {

			/* uc() of this requires 2 characters, but they are
			 * ASCII.  If not enough room, grow the string */
			if (SvLEN(dest) < ++min) {	
			    const UV o = d - (U8*)SvPVX_const(dest);
			    SvGROW(dest, min);
			    d = (U8*)SvPVX(dest) + o;
			}
			*d++ = 'S'; *d = 'S'; /* upper case is 'SS' */
			continue;   /* Back to the tight loop; still in ASCII */
		    }

		    /* The other two special handling characters have their
		     * upper cases outside the latin1 range, hence need to be
		     * in UTF-8, so the whole result needs to be in UTF-8.  So,
		     * here we are somewhere in the middle of processing a
		     * non-UTF-8 string, and realize that we will have to convert
		     * the whole thing to UTF-8.  What to do?  There are
		     * several possibilities.  The simplest to code is to
		     * convert what we have so far, set a flag, and continue on
		     * in the loop.  The flag would be tested each time through
		     * the loop, and if set, the next character would be
		     * converted to UTF-8 and stored.  But, I (khw) didn't want
		     * to slow down the mainstream case at all for this fairly
		     * rare case, so I didn't want to add a test that didn't
		     * absolutely have to be there in the loop, besides the
		     * possibility that it would get too complicated for
		     * optimizers to deal with.  Another possibility is to just
		     * give up, convert the source to UTF-8, and restart the
		     * function that way.  Another possibility is to convert
		     * both what has already been processed and what is yet to
		     * come separately to UTF-8, then jump into the loop that
		     * handles UTF-8.  But the most efficient time-wise of the
		     * ones I could think of is what follows, and turned out to
		     * not require much extra code.  */

		    /* Convert what we have so far into UTF-8, telling the
		     * function that we know it should be converted, and to
		     * allow extra space for what we haven't processed yet.
		     * Assume the worst case space requirements for converting
		     * what we haven't processed so far: that it will require
		     * two bytes for each remaining source character, plus the
		     * NUL at the end.  This may cause the string pointer to
		     * move, so re-find it. */

		    len = d - (U8*)SvPVX_const(dest);
		    SvCUR_set(dest, len);
		    len = sv_utf8_upgrade_flags_grow(dest,
						SV_GMAGIC|SV_FORCE_UTF8_UPGRADE,
						(send -s) * 2 + 1);
		    d = (U8*)SvPVX(dest) + len;

		    /* And append the current character's upper case in UTF-8 */
		    CAT_NON_LATIN1_UC(d, *s);

		    /* Now process the remainder of the source, converting to
		     * upper and UTF-8.  If a resulting byte is invariant in
		     * UTF-8, output it as-is, otherwise convert to UTF-8 and
		     * append it to the output. */

		    s++;
		    for (; s < send; s++) {
			U8 upper = toUPPER_LATIN1_MOD(*s);
			if UTF8_IS_INVARIANT(upper) {
			    *d++ = upper;
			}
			else {
			    CAT_TWO_BYTE_UNI_UPPER_MOD(d, *s, upper);
			}
		    }

		    /* Here have processed the whole source; no need to continue
		     * with the outer loop.  Each character has been converted
		     * to upper case and converted to UTF-8 */

		    break;
		} /* End of processing all latin1-style chars */
	    } /* End of processing all chars */
	} /* End of source is not empty */

d3718 1
a3718 1
	    *d = '\0';  /* Here d points to 1 after last char, add NUL */
d3721 1
a3721 1
    } /* End of isn't utf8 */
d3741 1
a3742 2
	/* We can convert in place, as lowercasing anything in the latin1 range
	 * (or else DO_UTF8 would have been on) doesn't lengthen it */
a3760 2
	    if (ckWARN(WARN_UNINITIALIZED))
		report_uninit(source);
d3781 3
a3783 3
/* See comments at the first instance in this file of this ifdef */
#ifdef GO_AHEAD_AND_BREAK_USER_DEFINED_CASE_MAPPINGS
	    if (UTF8_IS_INVARIANT(*s)) {
d3785 14
a3798 1
		/* Invariant characters use the standard mappings compiled in.
a3799 2
		*d++ = toLOWER(*s);
		s++;
d3801 15
a3815 108
	    else if (UTF8_IS_DOWNGRADEABLE_START(*s)) {

		/* As do the ones in the Latin1 range */
		U8 lower = toLOWER_LATIN1(UTF8_ACCUMULATE(*s, *(s+1)));
		CAT_UNI_TO_UTF8_TWO_BYTE(d, lower);
		s += 2;
	    }
	    else {
#endif
		/* Here, is utf8 not in Latin-1 range, have to go out and get
		 * the mappings from the tables. */

		const STRLEN u = UTF8SKIP(s);
		STRLEN ulen;

/* See comments at the first instance in this file of this ifdef */
#ifndef CONTEXT_DEPENDENT_CASING
		toLOWER_utf8(s, tmpbuf, &ulen);
#else
		/* Here is context dependent casing, not compiled in currently;
		 * needs more thought and work */

		const UV uv = toLOWER_utf8(s, tmpbuf, &ulen);

		/* If the lower case is a small sigma, it may be that we need
		 * to change it to a final sigma.  This happens at the end of 
		 * a word that contains more than just this character, and only
		 * when we started with a capital sigma. */
		if (uv == UNICODE_GREEK_SMALL_LETTER_SIGMA &&
		    s > send - len &&	/* Makes sure not the first letter */
		    utf8_to_uvchr(s, 0) == UNICODE_GREEK_CAPITAL_LETTER_SIGMA
		) {

		    /* We use the algorithm in:
		     * http://www.unicode.org/versions/Unicode5.0.0/ch03.pdf (C
		     * is a CAPITAL SIGMA): If C is preceded by a sequence
		     * consisting of a cased letter and a case-ignorable
		     * sequence, and C is not followed by a sequence consisting
		     * of a case ignorable sequence and then a cased letter,
		     * then when lowercasing C, C becomes a final sigma */

		    /* To determine if this is the end of a word, need to peek
		     * ahead.  Look at the next character */
		    const U8 *peek = s + u;

		    /* Skip any case ignorable characters */
		    while (peek < send && is_utf8_case_ignorable(peek)) {
			peek += UTF8SKIP(peek);
		    }

		    /* If we reached the end of the string without finding any
		     * non-case ignorable characters, or if the next such one
		     * is not-cased, then we have met the conditions for it
		     * being a final sigma with regards to peek ahead, and so
		     * must do peek behind for the remaining conditions. (We
		     * know there is stuff behind to look at since we tested
		     * above that this isn't the first letter) */
		    if (peek >= send || ! is_utf8_cased(peek)) {
			peek = utf8_hop(s, -1);

			/* Here are at the beginning of the first character
			 * before the original upper case sigma.  Keep backing
			 * up, skipping any case ignorable characters */
			while (is_utf8_case_ignorable(peek)) {
			    peek = utf8_hop(peek, -1);
			}

			/* Here peek points to the first byte of the closest
			 * non-case-ignorable character before the capital
			 * sigma.  If it is cased, then by the Unicode
			 * algorithm, we should use a small final sigma instead
			 * of what we have */
			if (is_utf8_cased(peek)) {
			    STORE_UNI_TO_UTF8_TWO_BYTE(tmpbuf,
					UNICODE_GREEK_SMALL_LETTER_FINAL_SIGMA);
			}
		    }
		}
		else {	/* Not a context sensitive mapping */
#endif	/* End of commented out context sensitive */
		    if (ulen > u && (SvLEN(dest) < (min += ulen - u))) {

			/* If the eventually required minimum size outgrows
			 * the available space, we need to grow. */
			const UV o = d - (U8*)SvPVX_const(dest);

			/* If someone lowercases one million U+0130s we
			 * SvGROW() one million times.  Or we could try
			 * guessing how much to allocate without allocating too
			 * much.  Such is life.  Another option would be to
			 * grow an extra byte or two more each time we need to
			 * grow, which would cut down the million to 500K, with
			 * little waste */
			SvGROW(dest, min);
			d = (U8*)SvPVX(dest) + o;
		    }
#ifdef CONTEXT_DEPENDENT_CASING
		}
#endif
		/* Copy the newly lowercased letter to the output buffer we're
		 * building */
		Copy(tmpbuf, d, ulen, U8);
		d += ulen;
		s += u;
#ifdef GO_AHEAD_AND_BREAK_USER_DEFINED_CASE_MAPPINGS
	    }
#endif
	}   /* End of looping through the source string */
d3819 1
a3819 1
    } else {	/* Not utf8 */
a3821 4

	    /* Use locale casing if in locale; regular style if not treating
	     * latin1 as having case; otherwise the latin1 casing.  Do the
	     * whole thing in a tight loop, for speed, */
d3828 2
a3829 2
	    else if (! IN_UNI_8_BIT) {
		for (; s < send; d++, s++) {
a3830 6
		}
	    }
	    else {
		for (; s < send; d++, s++) {
		    *d = toLOWER_LATIN1(*s);
		}
d3901 1
a3901 11
	const bool localizing = PL_op->op_private & OPpLVAL_INTRO;
	bool can_preserve = FALSE;

	if (localizing) {
	    MAGIC *mg;
	    HV *stash;

	    can_preserve = SvCANEXISTDELETE(av);
	}

	if (lval && localizing) {
a3911 1

a3914 1
	    bool preeminent = TRUE;
a3917 8
	    if (localizing && can_preserve) {
		/* If we can determine whether the element exist,
		 * Try to preserve the existenceness of a tied array
		 * element by using EXISTS and DELETE if possible.
		 * Fallback to FETCH and STORE otherwise. */
		preeminent = av_exists(av, elem);
	    }

d3922 2
a3923 6
		if (localizing) {
		    if (preeminent)
			save_aelem(av, elem, svp);
		    else
			SAVEADELETE(av, elem);
		}
a3935 61
PP(pp_aeach)
{
    dVAR;
    dSP;
    AV *array = MUTABLE_AV(POPs);
    const I32 gimme = GIMME_V;
    IV *iterp = Perl_av_iter_p(aTHX_ array);
    const IV current = (*iterp)++;

    if (current > av_len(array)) {
	*iterp = 0;
	if (gimme == G_SCALAR)
	    RETPUSHUNDEF;
	else
	    RETURN;
    }

    EXTEND(SP, 2);
    mPUSHi(CopARYBASE_get(PL_curcop) + current);
    if (gimme == G_ARRAY) {
	SV **const element = av_fetch(array, current, 0);
        PUSHs(element ? *element : &PL_sv_undef);
    }
    RETURN;
}

PP(pp_akeys)
{
    dVAR;
    dSP;
    AV *array = MUTABLE_AV(POPs);
    const I32 gimme = GIMME_V;

    *Perl_av_iter_p(aTHX_ array) = 0;

    if (gimme == G_SCALAR) {
	dTARGET;
	PUSHi(av_len(array) + 1);
    }
    else if (gimme == G_ARRAY) {
        IV n = Perl_av_len(aTHX_ array);
        IV i = CopARYBASE_get(PL_curcop);

        EXTEND(SP, n + 1);

	if (PL_op->op_type == OP_AKEYS) {
	    n += i;
	    for (;  i <= n;  i++) {
		mPUSHi(i);
	    }
	}
	else {
	    for (i = 0;  i <= n;  i++) {
		SV *const *const elem = Perl_av_fetch(aTHX_ array, i, 0);
		PUSHs(elem ? *elem : &PL_sv_undef);
	    }
	}
    }
    RETURN;
}

d3970 1
a3970 2
STATIC OP *
S_do_delete_local(pTHX)
d3975 1
a3975 183
    const MAGIC *mg;
    HV *stash;

    if (PL_op->op_private & OPpSLICE) {
	dMARK; dORIGMARK;
	SV * const osv = POPs;
	const bool tied = SvRMAGICAL(osv)
			    && mg_find((const SV *)osv, PERL_MAGIC_tied);
	const bool can_preserve = SvCANEXISTDELETE(osv)
				    || mg_find((const SV *)osv, PERL_MAGIC_env);
	const U32 type = SvTYPE(osv);
	if (type == SVt_PVHV) {			/* hash element */
	    HV * const hv = MUTABLE_HV(osv);
	    while (++MARK <= SP) {
		SV * const keysv = *MARK;
		SV *sv = NULL;
		bool preeminent = TRUE;
		if (can_preserve)
		    preeminent = hv_exists_ent(hv, keysv, 0);
		if (tied) {
		    HE *he = hv_fetch_ent(hv, keysv, 1, 0);
		    if (he)
			sv = HeVAL(he);
		    else
			preeminent = FALSE;
		}
		else {
		    sv = hv_delete_ent(hv, keysv, 0, 0);
		    SvREFCNT_inc_simple_void(sv); /* De-mortalize */
		}
		if (preeminent) {
		    save_helem_flags(hv, keysv, &sv, SAVEf_KEEPOLDELEM);
		    if (tied) {
			*MARK = sv_mortalcopy(sv);
			mg_clear(sv);
		    } else
			*MARK = sv;
		}
		else {
		    SAVEHDELETE(hv, keysv);
		    *MARK = &PL_sv_undef;
		}
	    }
	}
	else if (type == SVt_PVAV) {                  /* array element */
	    if (PL_op->op_flags & OPf_SPECIAL) {
		AV * const av = MUTABLE_AV(osv);
		while (++MARK <= SP) {
		    I32 idx = SvIV(*MARK);
		    SV *sv = NULL;
		    bool preeminent = TRUE;
		    if (can_preserve)
			preeminent = av_exists(av, idx);
		    if (tied) {
			SV **svp = av_fetch(av, idx, 1);
			if (svp)
			    sv = *svp;
			else
			    preeminent = FALSE;
		    }
		    else {
			sv = av_delete(av, idx, 0);
		        SvREFCNT_inc_simple_void(sv); /* De-mortalize */
		    }
		    if (preeminent) {
		        save_aelem_flags(av, idx, &sv, SAVEf_KEEPOLDELEM);
			if (tied) {
			    *MARK = sv_mortalcopy(sv);
			    mg_clear(sv);
			} else
			    *MARK = sv;
		    }
		    else {
		        SAVEADELETE(av, idx);
		        *MARK = &PL_sv_undef;
		    }
		}
	    }
	}
	else
	    DIE(aTHX_ "Not a HASH reference");
	if (gimme == G_VOID)
	    SP = ORIGMARK;
	else if (gimme == G_SCALAR) {
	    MARK = ORIGMARK;
	    if (SP > MARK)
		*++MARK = *SP;
	    else
		*++MARK = &PL_sv_undef;
	    SP = MARK;
	}
    }
    else {
	SV * const keysv = POPs;
	SV * const osv   = POPs;
	const bool tied = SvRMAGICAL(osv)
			    && mg_find((const SV *)osv, PERL_MAGIC_tied);
	const bool can_preserve = SvCANEXISTDELETE(osv)
				    || mg_find((const SV *)osv, PERL_MAGIC_env);
	const U32 type = SvTYPE(osv);
	SV *sv = NULL;
	if (type == SVt_PVHV) {
	    HV * const hv = MUTABLE_HV(osv);
	    bool preeminent = TRUE;
	    if (can_preserve)
		preeminent = hv_exists_ent(hv, keysv, 0);
	    if (tied) {
		HE *he = hv_fetch_ent(hv, keysv, 1, 0);
		if (he)
		    sv = HeVAL(he);
		else
		    preeminent = FALSE;
	    }
	    else {
		sv = hv_delete_ent(hv, keysv, 0, 0);
		SvREFCNT_inc_simple_void(sv); /* De-mortalize */
	    }
	    if (preeminent) {
		save_helem_flags(hv, keysv, &sv, SAVEf_KEEPOLDELEM);
		if (tied) {
		    SV *nsv = sv_mortalcopy(sv);
		    mg_clear(sv);
		    sv = nsv;
		}
	    }
	    else
		SAVEHDELETE(hv, keysv);
	}
	else if (type == SVt_PVAV) {
	    if (PL_op->op_flags & OPf_SPECIAL) {
		AV * const av = MUTABLE_AV(osv);
		I32 idx = SvIV(keysv);
		bool preeminent = TRUE;
		if (can_preserve)
		    preeminent = av_exists(av, idx);
		if (tied) {
		    SV **svp = av_fetch(av, idx, 1);
		    if (svp)
			sv = *svp;
		    else
			preeminent = FALSE;
		}
		else {
		    sv = av_delete(av, idx, 0);
		    SvREFCNT_inc_simple_void(sv); /* De-mortalize */
		}
		if (preeminent) {
		    save_aelem_flags(av, idx, &sv, SAVEf_KEEPOLDELEM);
		    if (tied) {
			SV *nsv = sv_mortalcopy(sv);
			mg_clear(sv);
			sv = nsv;
		    }
		}
		else
		    SAVEADELETE(av, idx);
	    }
	    else
		DIE(aTHX_ "panic: avhv_delete no longer supported");
	}
	else
	    DIE(aTHX_ "Not a HASH reference");
	if (!sv)
	    sv = &PL_sv_undef;
	if (gimme != G_VOID)
	    PUSHs(sv);
    }

    RETURN;
}

PP(pp_delete)
{
    dVAR;
    dSP;
    I32 gimme;
    I32 discard;

    if (PL_op->op_private & OPpLVAL_INTRO)
	return do_delete_local();

    gimme = GIMME_V;
    discard = (gimme == G_VOID) ? G_DISCARD : 0;
d4011 1
a4011 1
	SV *sv = NULL;
d4071 1
a4071 1
    bool can_preserve = FALSE;
d4077 8
a4084 2
	if (SvCANEXISTDELETE(hv) || mg_find((const SV *)hv, PERL_MAGIC_env))
	    can_preserve = TRUE;
d4091 1
a4091 1
        bool preeminent = TRUE;
d4093 3
a4095 6
        if (localizing && can_preserve) {
	    /* If we can determine whether the element exist,
             * try to preserve the existenceness of a tied hash
             * element by using EXISTS and DELETE if possible.
             * Fallback to FETCH and STORE otherwise. */
            preeminent = hv_exists_ent(hv, keysv, 0);
d4108 10
a4117 5
		else if (preeminent)
		    save_helem_flags(hv, keysv, svp,
			 (PL_op->op_flags & OPf_SPECIAL) ? 0 : SAVEf_SETMAGIC);
		else
		    SAVEHDELETE(hv, keysv);
d4220 2
a4221 2
	else
	    Perl_ck_warner(aTHX_ packWARN(WARN_MISC), "Odd number of elements in anonymous hash");
d4248 1
a4248 1
	ENTER_with_name("call_SPLICE");
d4250 1
a4250 1
	LEAVE_with_name("call_SPLICE");
d4281 2
a4282 1
	Perl_ck_warner(aTHX_ packWARN(WARN_MISC), "splice() offset past end of array" );
d4445 1
a4445 1
	ENTER_with_name("call_PUSH");
d4447 1
a4447 1
	LEAVE_with_name("call_PUSH");
d4449 2
d4464 2
a4465 4
    }
    SP = ORIGMARK;
    if (OP_GIMME(PL_op, 0) != G_VOID) {
	PUSHi( AvFILL(ary) + 1 );
d4494 1
a4494 1
	ENTER_with_name("call_UNSHIFT");
d4496 1
a4496 1
	LEAVE_with_name("call_UNSHIFT");
d4508 1
a4508 3
    if (OP_GIMME(PL_op, 0) != G_VOID) {
	PUSHi( AvFILL(ary) + 1 );
    }
d4515 1
d4518 5
a4522 70
	if (PL_op->op_private & OPpREVERSE_INPLACE) {
	    AV *av;

	    /* See pp_sort() */
	    assert( MARK+1 == SP && *SP && SvTYPE(*SP) == SVt_PVAV);
	    (void)POPMARK; /* remove mark associated with ex-OP_AASSIGN */
	    av = MUTABLE_AV((*SP));
	    /* In-place reversing only happens in void context for the array
	     * assignment. We don't need to push anything on the stack. */
	    SP = MARK;

	    if (SvMAGICAL(av)) {
		I32 i, j;
		register SV *tmp = sv_newmortal();
		/* For SvCANEXISTDELETE */
		HV *stash;
		const MAGIC *mg;
		bool can_preserve = SvCANEXISTDELETE(av);

		for (i = 0, j = av_len(av); i < j; ++i, --j) {
		    register SV *begin, *end;

		    if (can_preserve) {
			if (!av_exists(av, i)) {
			    if (av_exists(av, j)) {
				register SV *sv = av_delete(av, j, 0);
				begin = *av_fetch(av, i, TRUE);
				sv_setsv_mg(begin, sv);
			    }
			    continue;
			}
			else if (!av_exists(av, j)) {
			    register SV *sv = av_delete(av, i, 0);
			    end = *av_fetch(av, j, TRUE);
			    sv_setsv_mg(end, sv);
			    continue;
			}
		    }

		    begin = *av_fetch(av, i, TRUE);
		    end   = *av_fetch(av, j, TRUE);
		    sv_setsv(tmp,      begin);
		    sv_setsv_mg(begin, end);
		    sv_setsv_mg(end,   tmp);
		}
	    }
	    else {
		SV **begin = AvARRAY(av);

		if (begin) {
		    SV **end   = begin + AvFILLp(av);

		    while (begin < end) {
			register SV * const tmp = *begin;
			*begin++ = *end;
			*end--   = tmp;
		    }
		}
	    }
	}
	else {
	    SV **oldsp = SP;
	    MARK++;
	    while (MARK < SP) {
		register SV * const tmp = *MARK;
		*MARK++ = *SP;
		*SP--   = tmp;
	    }
	    /* safe as long as stack cannot get extended in the above */
	    SP = oldsp;
d4524 2
d4538 1
a4538 1
	else {
a4544 5

	    if (! SvOK(TARG) && ckWARN(WARN_UNINITIALIZED))
		report_uninit(TARG);
	}

a4601 1
    I32 trailing_empty = 0;
a4606 1
    bool gimme_scalar;
d4635 2
a4681 2
    gimme_scalar = gimme == G_SCALAR && !ary;

d4707 3
a4709 11
	    if (gimme_scalar) {
		iters++;
		if (m-s == 0)
		    trailing_empty++;
		else
		    trailing_empty = 0;
	    } else {
		dstr = newSVpvn_flags(s, m-s,
				      (do_utf8 ? SVf_UTF8 : 0) | make_mortal);
		XPUSHs(dstr);
	    }
d4737 3
a4739 12

	    if (gimme_scalar) {
		iters++;
		if (m-s == 0)
		    trailing_empty++;
		else
		    trailing_empty = 0;
	    } else {
		dstr = newSVpvn_flags(s, m-s,
				      (do_utf8 ? SVf_UTF8 : 0) | make_mortal);
		XPUSHs(dstr);
	    }
d4752 5
a4756 7
	if (!gimme_scalar) {
	    const U32 items = limit - 1;
	    if (items < slen)
		EXTEND(SP, items);
	    else
		EXTEND(SP, slen);
	}
d4763 1
a4763 8
		if (gimme_scalar) {
		    iters++;
		    if (s-m == 0)
			trailing_empty++;
		    else
			trailing_empty = 0;
		} else {
		    dstr = newSVpvn_flags(m, s-m, SVf_UTF8 | make_mortal);
d4765 1
a4765 2
		    PUSHs(dstr);
		}
d4772 1
a4772 4
	        if (gimme_scalar) {
		    iters++;
		} else {
		    dstr = newSVpvn(s, 1);
d4774 1
d4776 2
a4777 5
		    if (make_mortal)
			sv_2mortal(dstr);

		    PUSHs(dstr);
		}
d4779 1
a4779 1
                s++;
d4801 3
a4803 11
		if (gimme_scalar) {
		    iters++;
		    if (m-s == 0)
			trailing_empty++;
		    else
			trailing_empty = 0;
		} else {
		    dstr = newSVpvn_flags(s, m-s,
					  (do_utf8 ? SVf_UTF8 : 0) | make_mortal);
		    XPUSHs(dstr);
		}
d4817 3
a4819 11
		if (gimme_scalar) {
		    iters++;
		    if (m-s == 0)
			trailing_empty++;
		    else
			trailing_empty = 0;
		} else {
		    dstr = newSVpvn_flags(s, m-s,
					  (do_utf8 ? SVf_UTF8 : 0) | make_mortal);
		    XPUSHs(dstr);
		}
d4849 3
a4851 12

	    if (gimme_scalar) {
		iters++;
		if (m-s == 0)
		    trailing_empty++;
		else
		    trailing_empty = 0;
	    } else {
		dstr = newSVpvn_flags(s, m-s,
				      (do_utf8 ? SVf_UTF8 : 0) | make_mortal);
		XPUSHs(dstr);
	    }
d4861 4
a4864 15
		    if (gimme_scalar) {
			iters++;
			if (m-s == 0)
			    trailing_empty++;
			else
			    trailing_empty = 0;
		    } else {
			if (m >= orig && s >= orig) {
			    dstr = newSVpvn_flags(s, m-s,
						 (do_utf8 ? SVf_UTF8 : 0)
						  | make_mortal);
			}
			else
			    dstr = &PL_sv_undef;  /* undef, not "" */
			XPUSHs(dstr);
d4866 3
a4868 1

d4875 1
a4875 3
    if (!gimme_scalar) {
	iters = (SP - PL_stack_base) - base;
    }
d4881 3
a4883 5
	if (!gimme_scalar) {
	    const STRLEN l = strend - s;
	    dstr = newSVpvn_flags(s, l, (do_utf8 ? SVf_UTF8 : 0) | make_mortal);
	    XPUSHs(dstr);
	}
d4887 5
a4891 9
	if (gimme_scalar) {
	    iters -= trailing_empty;
	} else {
	    while (iters > 0 && (!TOPs || !SvANY(TOPs) || SvCUR(TOPs) == 0)) {
		if (TOPs && !make_mortal)
		    sv_2mortal(TOPs);
		*SP-- = &PL_sv_undef;
		iters--;
	    }
d4914 1
a4914 1
	    ENTER_with_name("call_PUSH");
d4916 1
a4916 1
	    LEAVE_with_name("call_PUSH");
a4958 1
    assert(SvTYPE(retsv) != SVt_PVCV);
d4960 2
a4961 1
    if (SvTYPE(retsv) == SVt_PVAV || SvTYPE(retsv) == SVt_PVHV) {
a4973 19
    return NORMAL;
}

PP(pp_boolkeys)
{
    dVAR;
    dSP;
    HV * const hv = (HV*)POPs;
    
    if (SvRMAGICAL(hv)) {
	MAGIC * const mg = mg_find((SV*)hv, PERL_MAGIC_tied);
	if (mg) {
            XPUSHs(magic_scalarpack(hv, mg));
	    RETURN;
        }	    
    }

    XPUSHs(boolSV(HvKEYS(hv) != 0));
    RETURN;
@


1.1.1.14
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d74 1
a74 3
    } else if (PL_op->op_private & OPpMAYBE_LVSUB) {
       const I32 flags = is_lvalue_sub();
       if (flags && !(flags & OPpENTERSUB_INARGS)) {
a75 1
	    /* diag_listed_as: Can't return %s to lvalue scalar context */
a78 1
       }
d117 1
a117 3
    else if (PL_op->op_private & OPpMAYBE_LVSUB) {
      const I32 flags = is_lvalue_sub();
      if (flags && !(flags & OPpENTERSUB_INARGS)) {
a118 1
	    /* diag_listed_as: Can't return %s to lvalue scalar context */
a120 1
      }
d124 1
a124 1
	RETURNOP(Perl_do_kv(aTHX));
d138 3
a140 7
/* In some cases this function inspects PL_op.  If this function is called
   for new op types, more bool parameters may need to be added in place of
   the checks.

   When noinit is true, the absence of a gv will cause a retval of undef.
   This is unrelated to the cv-to-gv assignment case.
*/
a141 6
static SV *
S_rv2gv(pTHX_ SV *sv, const bool vivify_sv, const bool strict,
              const bool noinit)
{
    dVAR;
    if (!isGV(sv) || SvFAKE(sv)) SvGETMAGIC(sv);
a142 3
	if (SvAMAGIC(sv)) {
	    sv = amagic_deref_call(sv, to_gv_amg);
	}
d144 2
d149 1
a149 1
	    gv_init(gv, 0, "__ANONIO__", 10, 0);
d155 1
a155 1
	    return (SV *)Perl_die(aTHX_ "Not a GLOB reference");
d159 6
a164 1
	    if (!SvOK(sv)) {
d168 3
a170 1
		if (vivify_sv && sv != &PL_sv_undef) {
a171 2
		    if (SvREADONLY(sv))
			Perl_croak_no_modify(aTHX);
d173 1
d175 1
d177 1
a177 1
			gv_init_sv(gv, CopSTASH(PL_curcop), namesv, 0);
d181 1
a181 2
			gv = newGVgen_flags(name,
                                        HvNAMEUTF8(CopSTASH(PL_curcop)) ? SVf_UTF8 : 0 );
d189 3
a191 2
		if (PL_op->op_flags & OPf_REF || strict)
		    return (SV *)Perl_die(aTHX_ PL_no_usym, "a symbol");
d194 1
a194 1
		return &PL_sv_undef;
d196 2
a197 1
	    if (noinit)
d199 8
a206 4
		if (!(sv = MUTABLE_SV(gv_fetchsv_nomg(
		           sv, GV_ADDMG, SVt_PVGV
		   ))))
		    return &PL_sv_undef;
d209 2
a210 8
		if (strict)
		    return
		     (SV *)Perl_die(aTHX_
		            S_no_symref_sv,
		            sv,
		            (SvPOK(sv) && SvCUR(sv)>32 ? "..." : ""),
		            "a symbol"
		           );
d216 1
a216 1
		    return sv;
d218 1
a218 1
		sv = MUTABLE_SV(gv_fetchsv_nomg(sv, GV_ADD, SVt_PVGV));
a219 2
	    /* FAKE globs in the symbol table cause weird bugs (#77810) */
	    SvFAKE_off(sv);
a221 19
    if (SvFAKE(sv) && !(PL_op->op_private & OPpALLOW_FAKE)) {
	SV *newsv = sv_newmortal();
	sv_setsv_flags(newsv, sv, 0);
	SvFAKE_off(newsv);
	sv = newsv;
    }
    return sv;
}

PP(pp_rv2gv)
{
    dVAR; dSP; dTOPss;

    sv = S_rv2gv(aTHX_
          sv, PL_op->op_private & OPpDEREF,
          PL_op->op_private & HINT_STRICT_REFS,
          ((PL_op->op_flags & OPf_SPECIAL) && !(PL_op->op_flags & OPf_MOD))
             || PL_op->op_type == OP_READLINE
         );
d245 1
a245 4
	if (
	  PL_op->op_flags & OPf_REF &&
	  PL_op->op_next->op_type != OP_BOOLKEYS
	)
d259 4
a262 1
	    if (!(gv = gv_fetchsv_nomg(sv, GV_ADDMG, type)))
d269 1
a269 1
	gv = gv_fetchsv_nomg(sv, GV_ADD, type);
a278 1
    SvGETMAGIC(sv);
d280 2
a281 3
	if (SvAMAGIC(sv)) {
	    sv = amagic_deref_call(sv, to_sv_amg);
	}
d298 5
d319 1
a319 1
	    sv = vivify_ref(sv, PL_op->op_private & OPpDEREF);
d338 3
a340 1
	SETs(sv_2mortal(newSViv(AvFILL(MUTABLE_AV(av)))));
d347 1
a347 1
    dVAR; dSP; dPOPss;
d350 11
a360 5
	SV * const ret = sv_2mortal(newSV_type(SVt_PVLV));  /* Not TARG RT#67838 */
	sv_magic(ret, NULL, PERL_MAGIC_pos, NULL, 0);
	LvTYPE(ret) = '.';
	LvTARG(ret) = SvREFCNT_inc_simple(sv);
	PUSHs(ret);    /* no SvSETMAGIC */
a366 1
		dTARGET;
d370 1
a370 1
		PUSHi(i);
d384 1
a384 1
	? GV_ADDMG
d395 6
d423 56
a478 1
	    if (!code || code == -KEY_CORE)
a479 3
	    if (code < 0) {	/* Overridable. */
		SV * const sv = core_prototype(NULL, s + 6, code, NULL);
		if (sv) ret = sv;
a480 1
	    goto set;
d485 1
a485 3
	ret = newSVpvn_flags(
	    CvPROTO(cv), CvPROTOLEN(cv), SVs_TEMP | SvUTF8(cv)
	);
d565 1
d574 2
a575 2
    (void)sv_ref(TARG,SvRV(sv),TRUE);
    PUSHTARG;
a584 1
      curstash:
d591 1
a591 2
	if (!ssv) goto curstash;
	if (!SvGMAGICAL(ssv) && !SvAMAGIC(ssv) && SvROK(ssv))
d597 1
a597 1
	stash = gv_stashpvn(ptr, len, GV_ADD|SvUTF8(ssv));
d609 1
a609 2
    STRLEN len;
    const char * const elem = SvPV_const(sv, len);
d619 1
a619 1
	    if (len == 5 && strEQ(second_letter, "RRAY"))
d623 1
a623 1
	    if (len == 4 && strEQ(second_letter, "ODE"))
d627 1
a627 1
	    if (len == 10 && strEQ(second_letter, "ILEHANDLE")) {
d633 1
a633 1
		if (len == 6 && strEQ(second_letter, "ORMAT"))
d637 1
a637 1
	    if (len == 4 && strEQ(second_letter, "LOB"))
d641 1
a641 1
	    if (len == 4 && strEQ(second_letter, "ASH"))
d645 1
a645 1
	    if (*second_letter == 'O' && !elem[2] && len == 2)
d649 1
a649 1
	    if (len == 4 && strEQ(second_letter, "AME"))
d653 1
a653 1
	    if (len == 7 && strEQ(second_letter, "ACKAGE")) {
d660 1
a660 1
	    if (len == 6 && strEQ(second_letter, "CALAR"))
d681 4
a684 1
    char *sfirst_raw;
a685 6
    MAGIC *mg = SvMAGICAL(sv) ? mg_find(sv, PERL_MAGIC_study) : NULL;
    U8 quanta;
    STRLEN size;

    if (mg && SvSCREAM(sv))
	RETPUSHYES;
d687 4
d692 2
a693 1
    if (len == 0 || len > I32_MAX || !SvPOK(sv) || SvUTF8(sv) || SvVALID(sv)) {
d698 1
a698 6
	   stringification.  Also refuse to study an FBM scalar, as this gives
	   more flexibility in SV flag usage.  No real-world code would ever
	   end up studying an FBM scalar, so this isn't a real pessimisation.
	   Endemic use of I32 in Perl_screaminstr makes it hard to safely push
	   the study length limit from I32_MAX to U32_MAX - 1.
	*/
d702 5
a706 4
    /* Make study a no-op. It's no longer useful and its existence
       complicates matters elsewhere. This is a low-impact band-aid.
       The relevant code will be neatly removed in a future release. */
    RETPUSHYES;
d708 15
a722 6
    if (len < 0xFF) {
	quanta = 1;
    } else if (len < 0xFFFF) {
	quanta = 2;
    } else
	quanta = 4;
d724 2
a725 2
    size = (256 + len) * quanta;
    sfirst_raw = (char *)safemalloc(size);
d727 1
a727 1
    if (!sfirst_raw)
d730 11
a740 39
    SvSCREAM_on(sv);
    if (!mg)
	mg = sv_magicext(sv, NULL, PERL_MAGIC_study, &PL_vtbl_regexp, NULL, 0);
    mg->mg_ptr = sfirst_raw;
    mg->mg_len = size;
    mg->mg_private = quanta;

    memset(sfirst_raw, ~0, 256 * quanta);

    /* The assumption here is that most studied strings are fairly short, hence
       the pain of the extra code is worth it, given the memory savings.
       80 character string, 336 bytes as U8, down from 1344 as U32
       800 character string, 2112 bytes as U16, down from 4224 as U32
    */
       
    if (quanta == 1) {
	U8 *const sfirst = (U8 *)sfirst_raw;
	U8 *const snext = sfirst + 256;
	while (len-- > 0) {
	    const U8 ch = s[len];
	    snext[len] = sfirst[ch];
	    sfirst[ch] = len;
	}
    } else if (quanta == 2) {
	U16 *const sfirst = (U16 *)sfirst_raw;
	U16 *const snext = sfirst + 256;
	while (len-- > 0) {
	    const U8 ch = s[len];
	    snext[len] = sfirst[ch];
	    sfirst[ch] = len;
	}
    } else  {
	U32 *const sfirst = (U32 *)sfirst_raw;
	U32 *const snext = sfirst + 256;
	while (len-- > 0) {
	    const U8 ch = s[len];
	    snext[len] = sfirst[ch];
	    sfirst[ch] = len;
	}
d743 3
d763 1
a763 8
    if(PL_op->op_type == OP_TRANSR) {
	STRLEN len;
	const char * const pv = SvPV(sv,len);
	SV * const newsv = newSVpvn_flags(pv, len, SVs_TEMP|SvUTF8(sv));
	do_trans(newsv);
	PUSHs(newsv);
    }
    else PUSHi(do_trans(sv));
a768 167
static void
S_do_chomp(pTHX_ SV *retval, SV *sv, bool chomping)
{
    dVAR;
    STRLEN len;
    char *s;

    PERL_ARGS_ASSERT_DO_CHOMP;

    if (chomping && (RsSNARF(PL_rs) || RsRECORD(PL_rs)))
	return;
    if (SvTYPE(sv) == SVt_PVAV) {
	I32 i;
	AV *const av = MUTABLE_AV(sv);
	const I32 max = AvFILL(av);

	for (i = 0; i <= max; i++) {
	    sv = MUTABLE_SV(av_fetch(av, i, FALSE));
	    if (sv && ((sv = *(SV**)sv), sv != &PL_sv_undef))
		do_chomp(retval, sv, chomping);
	}
        return;
    }
    else if (SvTYPE(sv) == SVt_PVHV) {
	HV* const hv = MUTABLE_HV(sv);
	HE* entry;
        (void)hv_iterinit(hv);
        while ((entry = hv_iternext(hv)))
            do_chomp(retval, hv_iterval(hv,entry), chomping);
	return;
    }
    else if (SvREADONLY(sv)) {
        if (SvFAKE(sv)) {
            /* SV is copy-on-write */
	    sv_force_normal_flags(sv, 0);
        }
        else
            Perl_croak_no_modify(aTHX);
    }

    if (PL_encoding) {
	if (!SvUTF8(sv)) {
	    /* XXX, here sv is utf8-ized as a side-effect!
	       If encoding.pm is used properly, almost string-generating
	       operations, including literal strings, chr(), input data, etc.
	       should have been utf8-ized already, right?
	    */
	    sv_recode_to_utf8(sv, PL_encoding);
	}
    }

    s = SvPV(sv, len);
    if (chomping) {
	char *temp_buffer = NULL;
	SV *svrecode = NULL;

	if (s && len) {
	    s += --len;
	    if (RsPARA(PL_rs)) {
		if (*s != '\n')
		    goto nope;
		++SvIVX(retval);
		while (len && s[-1] == '\n') {
		    --len;
		    --s;
		    ++SvIVX(retval);
		}
	    }
	    else {
		STRLEN rslen, rs_charlen;
		const char *rsptr = SvPV_const(PL_rs, rslen);

		rs_charlen = SvUTF8(PL_rs)
		    ? sv_len_utf8(PL_rs)
		    : rslen;

		if (SvUTF8(PL_rs) != SvUTF8(sv)) {
		    /* Assumption is that rs is shorter than the scalar.  */
		    if (SvUTF8(PL_rs)) {
			/* RS is utf8, scalar is 8 bit.  */
			bool is_utf8 = TRUE;
			temp_buffer = (char*)bytes_from_utf8((U8*)rsptr,
							     &rslen, &is_utf8);
			if (is_utf8) {
			    /* Cannot downgrade, therefore cannot possibly match
			     */
			    assert (temp_buffer == rsptr);
			    temp_buffer = NULL;
			    goto nope;
			}
			rsptr = temp_buffer;
		    }
		    else if (PL_encoding) {
			/* RS is 8 bit, encoding.pm is used.
			 * Do not recode PL_rs as a side-effect. */
			svrecode = newSVpvn(rsptr, rslen);
			sv_recode_to_utf8(svrecode, PL_encoding);
			rsptr = SvPV_const(svrecode, rslen);
			rs_charlen = sv_len_utf8(svrecode);
		    }
		    else {
			/* RS is 8 bit, scalar is utf8.  */
			temp_buffer = (char*)bytes_to_utf8((U8*)rsptr, &rslen);
			rsptr = temp_buffer;
		    }
		}
		if (rslen == 1) {
		    if (*s != *rsptr)
			goto nope;
		    ++SvIVX(retval);
		}
		else {
		    if (len < rslen - 1)
			goto nope;
		    len -= rslen - 1;
		    s -= rslen - 1;
		    if (memNE(s, rsptr, rslen))
			goto nope;
		    SvIVX(retval) += rs_charlen;
		}
	    }
	    s = SvPV_force_nomg_nolen(sv);
	    SvCUR_set(sv, len);
	    *SvEND(sv) = '\0';
	    SvNIOK_off(sv);
	    SvSETMAGIC(sv);
	}
    nope:

	SvREFCNT_dec(svrecode);

	Safefree(temp_buffer);
    } else {
	if (len && !SvPOK(sv))
	    s = SvPV_force_nomg(sv, len);
	if (DO_UTF8(sv)) {
	    if (s && len) {
		char * const send = s + len;
		char * const start = s;
		s = send - 1;
		while (s > start && UTF8_IS_CONTINUATION(*s))
		    s--;
		if (is_utf8_string((U8*)s, send - s)) {
		    sv_setpvn(retval, s, send - s);
		    *s = '\0';
		    SvCUR_set(sv, s - start);
		    SvNIOK_off(sv);
		    SvUTF8_on(retval);
		}
	    }
	    else
		sv_setpvs(retval, "");
	}
	else if (s && len) {
	    s += --len;
	    sv_setpvn(retval, s, 1);
	    *s = '\0';
	    SvCUR_set(sv, len);
	    SvUTF8_off(sv);
	    SvNIOK_off(sv);
	}
	else
	    sv_setpvs(retval, "");
	SvSETMAGIC(sv);
    }
}

d772 1
a772 5
    const bool chomping = PL_op->op_type == OP_SCHOMP;

    if (chomping)
	sv_setiv(TARG, 0);
    do_chomp(TARG, TOPs, chomping);
a779 4
    const bool chomping = PL_op->op_type == OP_CHOMP;

    if (chomping)
	sv_setiv(TARG, 0);
d781 1
a781 1
	do_chomp(TARG, *++MARK, chomping);
d787 18
d832 3
a834 5
	    Perl_ck_warner(aTHX_ packWARN(WARN_MISC),
                          "Constant subroutine %"SVf" undefined",
			   SVfARG(CvANON((const CV *)sv)
                             ? newSVpvs_flags("(anonymous)", SVs_TEMP)
                             : sv_2mortal(newSVhek(GvENAME_HEK(CvGV((const CV *)sv))))));
d841 1
a841 1
	    CvGV_set(MUTABLE_CV(sv), gv);
d853 3
d857 3
a859 9
            bool method_changed
             =   GvCVu((const GV *)sv) && (stash = GvSTASH((const GV *)sv))
	      && HvENAME_get(stash);
            /* undef *Foo:: */
            if((stash = GvHV((const GV *)sv))) {
                if(HvENAME_get(stash))
                    SvREFCNT_inc_simple_void_NN(sv_2mortal((SV *)stash));
                else stash = NULL;
            }
d863 1
a863 1
	    GvGP_set(sv, gp_ref(gp));
a867 14

            if(stash)
                mro_package_moved(NULL, stash, (const GV *)sv, 0);
            stash = NULL;
            /* undef *Foo::ISA */
            if( strEQ(GvNAME((const GV *)sv), "ISA")
             && (stash = GvSTASH((const GV *)sv))
             && (method_changed || HvENAME(stash)) )
                mro_isa_changed_in(stash);
            else if(method_changed)
                mro_method_changed_in(
                 GvSTASH((const GV *)sv)
                );

d884 17
d904 2
a905 6
    const bool inc =
	PL_op->op_type == OP_POSTINC || PL_op->op_type == OP_I_POSTINC;
    if (SvTYPE(TOPs) >= SVt_PVAV || (isGV_with_GP(TOPs) && !SvFAKE(TOPs)))
	Perl_croak_no_modify(aTHX);
    if (SvROK(TOPs))
	TARG = sv_newmortal();
d908 1
a908 1
        && SvIVX(TOPs) != (inc ? IV_MAX : IV_MIN))
d910 1
a910 1
	SvIV_set(TOPs, SvIVX(TOPs) + (inc ? 1 : -1));
d913 2
a914 3
    else if (inc)
	sv_inc_nomg(TOPs);
    else sv_dec_nomg(TOPs);
d917 1
a917 1
    if (inc && !SvOK(TARG))
d923 19
d950 3
a952 3
    tryAMAGICbin_MG(pow_amg, AMGf_assign|AMGf_numeric);
    svr = TOPs;
    svl = TOPm1s;
d958 1
a958 1
	SvIV_please_nomg(svr);
d960 1
a960 1
	    SvIV_please_nomg(svl);
d1016 1
a1016 1
                    SvIV_please_nomg(svr);
d1033 1
a1033 1
			const bool odd_power = cBOOL(power & 1);
d1065 2
a1066 2
	NV right = SvNV_nomg(svr);
	NV left  = SvNV_nomg(svl);
d1111 1
a1111 1
	    SvIV_please_nomg(svr);
d1120 3
a1122 3
    tryAMAGICbin_MG(mult_amg, AMGf_assign|AMGf_numeric);
    svr = TOPs;
    svl = TOPm1s;
d1124 1
a1124 1
    SvIV_please_nomg(svr);
d1130 1
a1130 1
	SvIV_please_nomg(svl);
d1233 2
a1234 2
      NV right = SvNV_nomg(svr);
      NV left  = SvNV_nomg(svl);
d1244 3
a1246 3
    tryAMAGICbin_MG(div_amg, AMGf_assign|AMGf_numeric);
    svr = TOPs;
    svl = TOPm1s;
d1269 1
a1269 1
    SvIV_please_nomg(svr);
d1271 1
a1271 1
        SvIV_please_nomg(svl);
d1295 1
a1295 1
               no inspection would give no warning.  */
d1351 2
a1352 2
	NV right = SvNV_nomg(svr);
	NV left  = SvNV_nomg(svl);
d1367 1
a1367 2
    dVAR; dSP; dATARGET;
    tryAMAGICbin_MG(modulo_amg, AMGf_assign|AMGf_numeric);
d1377 3
a1379 3
	SV * const svr = TOPs;
	SV * const svl = TOPm1s;
	SvIV_please_nomg(svr);
d1395 1
a1395 1
	    dright = SvNV_nomg(svr);
d1406 1
d1411 2
a1412 1
        SvIV_please_nomg(svl);
d1430 1
a1430 1
	    dleft = SvNV_nomg(svl);
d1458 1
a1458 1
	sp -= 2;
d1499 2
a1500 1
    dVAR; dSP; dATARGET;
d1502 2
a1503 12
    SV *sv;

    if (GIMME == G_ARRAY && PL_op->op_private & OPpREPEAT_DOLIST) {
	/* TODO: think of some way of doing list-repeat overloading ??? */
	sv = POPs;
	SvGETMAGIC(sv);
    }
    else {
	tryAMAGICbin_MG(repeat_amg, AMGf_assign);
	sv = POPs;
    }

d1506 1
a1506 1
	      const UV uv = SvUV_nomg(sv);
d1512 1
a1512 1
	      const IV iv = SvIV_nomg(sv);
d1520 1
a1520 1
	 const NV nv = SvNV_nomg(sv);
d1527 1
a1527 2
	 count = SvIV_nomg(sv);

d1585 2
a1586 3
	if (TARG != tmpstr)
	    sv_setsv_nomg(TARG, tmpstr);
	SvPV_force_nomg(TARG, len);
d1619 1
d1625 3
a1627 3
    tryAMAGICbin_MG(subtr_amg, AMGf_assign|AMGf_numeric);
    svr = TOPs;
    svl = TOPm1s;
d1632 1
a1632 1
    SvIV_please_nomg(svr);
d1647 1
a1647 1
	    SvIV_please_nomg(svl);
d1730 1
a1730 1
	NV value = SvNV_nomg(svr);
d1738 1
a1738 1
	SETn( SvNV_nomg(svl) - value );
d1745 1
a1745 4
    dVAR; dSP; dATARGET; SV *svl, *svr;
    tryAMAGICbin_MG(lshift_amg, AMGf_assign|AMGf_numeric);
    svr = POPs;
    svl = TOPs;
d1747 1
a1747 1
      const IV shift = SvIV_nomg(svr);
d1749 1
a1749 1
	const IV i = SvIV_nomg(svl);
d1753 1
a1753 1
	const UV u = SvUV_nomg(svl);
d1762 1
a1762 4
    dVAR; dSP; dATARGET; SV *svl, *svr;
    tryAMAGICbin_MG(rshift_amg, AMGf_assign|AMGf_numeric);
    svr = POPs;
    svl = TOPs;
d1764 1
a1764 1
      const IV shift = SvIV_nomg(svr);
d1766 1
a1766 1
	const IV i = SvIV_nomg(svl);
d1770 1
a1770 1
	const UV u = SvUV_nomg(svl);
d1779 1
a1779 90
    dVAR; dSP;
    SV *left, *right;

    tryAMAGICbin_MG(lt_amg, AMGf_set|AMGf_numeric);
    right = POPs;
    left  = TOPs;
    SETs(boolSV(
	(SvIOK_notUV(left) && SvIOK_notUV(right))
	? (SvIVX(left) < SvIVX(right))
	: (do_ncmp(left, right) == -1)
    ));
    RETURN;
}

PP(pp_gt)
{
    dVAR; dSP;
    SV *left, *right;

    tryAMAGICbin_MG(gt_amg, AMGf_set|AMGf_numeric);
    right = POPs;
    left  = TOPs;
    SETs(boolSV(
	(SvIOK_notUV(left) && SvIOK_notUV(right))
	? (SvIVX(left) > SvIVX(right))
	: (do_ncmp(left, right) == 1)
    ));
    RETURN;
}

PP(pp_le)
{
    dVAR; dSP;
    SV *left, *right;

    tryAMAGICbin_MG(le_amg, AMGf_set|AMGf_numeric);
    right = POPs;
    left  = TOPs;
    SETs(boolSV(
	(SvIOK_notUV(left) && SvIOK_notUV(right))
	? (SvIVX(left) <= SvIVX(right))
	: (do_ncmp(left, right) <= 0)
    ));
    RETURN;
}

PP(pp_ge)
{
    dVAR; dSP;
    SV *left, *right;

    tryAMAGICbin_MG(ge_amg, AMGf_set|AMGf_numeric);
    right = POPs;
    left  = TOPs;
    SETs(boolSV(
	(SvIOK_notUV(left) && SvIOK_notUV(right))
	? (SvIVX(left) >= SvIVX(right))
	: ( (do_ncmp(left, right) & 2) == 0)
    ));
    RETURN;
}

PP(pp_ne)
{
    dVAR; dSP;
    SV *left, *right;

    tryAMAGICbin_MG(ne_amg, AMGf_set|AMGf_numeric);
    right = POPs;
    left  = TOPs;
    SETs(boolSV(
	(SvIOK_notUV(left) && SvIOK_notUV(right))
	? (SvIVX(left) != SvIVX(right))
	: (do_ncmp(left, right) != 0)
    ));
    RETURN;
}

/* compare left and right SVs. Returns:
 * -1: <
 *  0: ==
 *  1: >
 *  2: left or right was a NaN
 */
I32
Perl_do_ncmp(pTHX_ SV* const left, SV * const right)
{
    dVAR;

    PERL_ARGS_ASSERT_DO_NCMP;
d1781 14
a1794 20
    SvIV_please_nomg(right);
    /* Fortunately it seems NaN isn't IOK */
    if (SvIOK(right)) {
	SvIV_please_nomg(left);
	if (SvIOK(left)) {
	    if (!SvUOK(left)) {
		const IV leftiv = SvIVX(left);
		if (!SvUOK(right)) {
		    /* ## IV <=> IV ## */
		    const IV rightiv = SvIVX(right);
		    return (leftiv > rightiv) - (leftiv < rightiv);
		}
		/* ## IV <=> UV ## */
		if (leftiv < 0)
		    /* As (b) is a UV, it's >=0, so it must be < */
		    return -1;
		{
		    const UV rightuv = SvUVX(right);
		    return ((UV)leftiv > rightuv) - ((UV)leftiv < rightuv);
		}
d1796 7
a1802 6

	    if (SvUOK(right)) {
		/* ## UV <=> UV ## */
		const UV leftuv = SvUVX(left);
		const UV rightuv = SvUVX(right);
		return (leftuv > rightuv) - (leftuv < rightuv);
d1804 5
a1808 4
	    /* ## UV <=> IV ## */
	    {
		const IV rightiv = SvIVX(right);
		if (rightiv < 0)
d1810 16
a1825 4
		    return 1;
		{
		    const UV leftuv = SvUVX(left);
		    return (leftuv > (UV)rightiv) - (leftuv < (UV)rightiv);
d1827 4
a1831 1
	    /* NOTREACHED */
d1835 10
a1845 3
      NV const rnv = SvNV_nomg(right);
      NV const lnv = SvNV_nomg(left);

d1847 4
a1850 4
      if (Perl_isnan(lnv) || Perl_isnan(rnv)) {
	  return 2;
       }
      return (lnv > rnv) - (lnv < rnv);
d1852 2
a1853 7
      if (lnv < rnv)
	return -1;
      if (lnv > rnv)
	return 1;
      if (lnv == rnv)
	return 0;
      return 2;
d1855 1
d1859 1
a1859 2

PP(pp_ncmp)
d1861 12
a1872 16
    dVAR; dSP;
    SV *left, *right;
    I32 value;
    tryAMAGICbin_MG(ncmp_amg, AMGf_numeric);
    right = POPs;
    left  = TOPs;
    value = do_ncmp(left, right);
    if (value == 2) {
	SETs(&PL_sv_undef);
    }
    else {
	dTARGET;
	SETi(value);
    }
    RETURN;
}
d1874 417
a2290 3
PP(pp_sle)
{
    dVAR; dSP;
d2315 1
a2315 1
    tryAMAGICbin_MG(amg_type, AMGf_set);
d2319 2
a2320 2
		 ? sv_cmp_locale_flags(left, right, 0)
		 : sv_cmp_flags(left, right, 0));
d2328 1
a2328 2
    dVAR; dSP;
    tryAMAGICbin_MG(seq_amg, AMGf_set);
d2331 1
a2331 1
      SETs(boolSV(sv_eq_flags(left, right, 0)));
d2338 1
a2338 2
    dVAR; dSP;
    tryAMAGICbin_MG(sne_amg, AMGf_set);
d2341 1
a2341 1
      SETs(boolSV(!sv_eq_flags(left, right, 0)));
d2348 1
a2348 2
    dVAR; dSP; dTARGET;
    tryAMAGICbin_MG(scmp_amg, 0);
d2352 2
a2353 2
		 ? sv_cmp_locale_flags(left, right, 0)
		 : sv_cmp_flags(left, right, 0));
d2361 1
a2361 2
    dVAR; dSP; dATARGET;
    tryAMAGICbin_MG(band_amg, AMGf_assign);
d2364 2
a2366 2
	const bool left_ro_nonnum  = !SvNIOKp(left) && SvREADONLY(left);
	const bool right_ro_nonnum = !SvNIOKp(right) && SvREADONLY(right);
a2374 2
	if (left_ro_nonnum && left != TARG) SvNIOK_off(left);
	if (right_ro_nonnum) SvNIOK_off(right);
d2389 1
a2389 1
    tryAMAGICbin_MG((op_type == OP_BIT_OR ? bor_amg : bxor_amg), AMGf_assign);
d2392 2
a2394 2
	const bool left_ro_nonnum  = !SvNIOKp(left) && SvREADONLY(left);
	const bool right_ro_nonnum = !SvNIOKp(right) && SvREADONLY(right);
a2406 2
	if (left_ro_nonnum && left != TARG) SvNIOK_off(left);
	if (right_ro_nonnum) SvNIOK_off(right);
d2418 1
a2418 2
    dVAR; dSP; dTARGET;
    tryAMAGICun_MG(neg_amg, AMGf_numeric);
d2420 1
a2420 1
	SV * const sv = TOPs;
d2422 1
a2422 5

        if( !SvNIOK( sv ) && looks_like_number( sv ) ){
           SvIV_please( sv );
        }   

d2449 1
a2449 1
	    SETn(-SvNV_nomg(sv));
d2452 1
a2452 1
	    const char * const s = SvPV_nomg_const(sv, len);
d2458 2
a2459 2
		sv_setsv_nomg(TARG, sv);
		*SvPV_force_nomg(TARG, len) = *s == '-' ? '+' : '-';
d2462 1
a2462 1
		SvIV_please_nomg(sv);
d2466 1
a2466 1
		    sv_setnv(TARG, -SvNV_nomg(sv));
d2473 1
a2473 1
		SvIV_please_nomg(sv);
d2476 1
a2476 1
		sv_setnv(TARG, -SvNV_nomg(sv));
d2481 1
a2481 1
	    SETn(-SvNV_nomg(sv));
d2488 2
a2489 3
    dVAR; dSP;
    tryAMAGICun_MG(not_amg, AMGf_set);
    *PL_stack_sp = boolSV(!SvTRUE_nomg(*PL_stack_sp));
d2495 1
a2495 2
    dVAR; dSP; dTARGET;
    tryAMAGICun_MG(compl_amg, AMGf_numeric);
d2498 1
d2516 1
a2516 1
	tmps = (U8*)SvPV_force_nomg(TARG, len);
d2597 1
a2597 2
    dVAR; dSP; dATARGET;
    tryAMAGICbin_MG(mult_amg, AMGf_assign);
d2599 1
a2599 1
      dPOPTOPiirl_nomg;
d2608 1
a2608 2
    dVAR; dSP; dATARGET;
    tryAMAGICbin_MG(div_amg, AMGf_assign);
d2610 1
a2610 2
      dPOPTOPssrl;
      IV value = SvIV_nomg(right);
d2613 1
a2613 1
      num = SvIV_nomg(left);
d2620 1
a2620 1
      SETi(value);
d2633 1
a2633 2
     dVAR; dSP; dATARGET;
     tryAMAGICbin_MG(modulo_amg, AMGf_assign);
d2635 1
a2635 1
	  dPOPTOPiirl_nomg;
d2655 1
a2655 2
     dVAR; dSP; dATARGET;
     tryAMAGICbin_MG(modulo_amg, AMGf_assign);
d2657 1
a2657 1
	  dPOPTOPiirl_nomg;
d2671 1
a2671 2
     dVAR; dSP; dATARGET;
     tryAMAGICbin_MG(modulo_amg, AMGf_assign);
d2673 1
a2673 1
	  dPOPTOPiirl_nomg;
d2714 1
a2714 2
    dVAR; dSP; dATARGET;
    tryAMAGICbin_MG(add_amg, AMGf_assign);
d2716 1
a2716 1
      dPOPTOPiirl_ul_nomg;
d2724 1
a2724 2
    dVAR; dSP; dATARGET;
    tryAMAGICbin_MG(subtr_amg, AMGf_assign);
d2726 1
a2726 1
      dPOPTOPiirl_ul_nomg;
d2734 1
a2734 2
    dVAR; dSP;
    tryAMAGICbin_MG(lt_amg, AMGf_set);
d2736 1
a2736 1
      dPOPTOPiirl_nomg;
d2744 1
a2744 2
    dVAR; dSP;
    tryAMAGICbin_MG(gt_amg, AMGf_set);
d2746 1
a2746 1
      dPOPTOPiirl_nomg;
d2754 1
a2754 2
    dVAR; dSP;
    tryAMAGICbin_MG(le_amg, AMGf_set);
d2756 1
a2756 1
      dPOPTOPiirl_nomg;
d2764 1
a2764 2
    dVAR; dSP;
    tryAMAGICbin_MG(ge_amg, AMGf_set);
d2766 1
a2766 1
      dPOPTOPiirl_nomg;
d2774 1
a2774 2
    dVAR; dSP;
    tryAMAGICbin_MG(eq_amg, AMGf_set);
d2776 1
a2776 1
      dPOPTOPiirl_nomg;
d2784 1
a2784 2
    dVAR; dSP;
    tryAMAGICbin_MG(ne_amg, AMGf_set);
d2786 1
a2786 1
      dPOPTOPiirl_nomg;
d2794 1
a2794 2
    dVAR; dSP; dTARGET;
    tryAMAGICbin_MG(ncmp_amg, 0);
d2796 1
a2796 1
      dPOPTOPiirl_nomg;
d2812 3
a2814 8
    dVAR; dSP; dTARGET;
    tryAMAGICun_MG(neg_amg, 0);
    {
	SV * const sv = TOPs;
	IV const i = SvIV_nomg(sv);
	SETi(-i);
	RETURN;
    }
d2821 1
a2821 2
    dVAR; dSP; dTARGET;
    tryAMAGICbin_MG(atan2_amg, 0);
d2823 1
a2823 1
      dPOPTOPnnrl_nomg;
d2858 1
a2858 2

    tryAMAGICun_MG(amg_type, 0);
d2860 1
a2860 2
      SV * const arg = POPs;
      const NV value = SvNV_nomg(arg);
a2863 1
	      /* diag_listed_as: Can't take log of %g */
a2892 3
    else if (!TOPs) {
	value = 1.0; (void)POPs;
    }
d2908 2
a2909 2
    dVAR; dSP; dTARGET;
    const UV anum = (MAXARG < 1 || (!TOPs && !POPs)) ? seed() : POPu;
d2912 2
a2913 9
    if (anum)
	XPUSHu(anum);
    else {
	/* Historically srand always returned true. We can avoid breaking
	   that like this:  */
	sv_setpvs(TARG, "0 but true");
	XPUSHTARG;
    }
    RETURN;
d2918 1
a2918 2
    dVAR; dSP; dTARGET;
    tryAMAGICun_MG(int_amg, AMGf_numeric);
d2920 2
a2921 2
      SV * const sv = TOPs;
      const IV iv = SvIV_nomg(sv);
d2932 1
a2932 1
	    SETu(SvUV_nomg(sv));
d2937 1
a2937 1
	  const NV value = SvNV_nomg(sv);
d2959 1
a2959 2
    dVAR; dSP; dTARGET;
    tryAMAGICun_MG(abs_amg, AMGf_numeric);
d2961 1
a2961 1
      SV * const sv = TOPs;
d2963 1
a2963 1
      const IV iv = SvIV_nomg(sv);
d2971 1
a2971 1
	  SETu(SvUV_nomg(sv));	/* force it to be numeric only */
d2986 1
a2986 1
	const NV value = SvNV_nomg(sv);
d3023 1
a3023 1
    if (*tmps == 'x' || *tmps == 'X') {
d3027 1
a3027 1
    else if (*tmps == 'b' || *tmps == 'B')
d3060 2
a3061 5
	    if (!SvPADTMP(TARG)) {
		sv_setsv(TARG, &PL_sv_undef);
		SETTARG;
	    }
	    SETs(&PL_sv_undef);
d3075 2
a3076 5
	if (!SvPADTMP(TARG)) {
	    sv_setsv_nomg(TARG, &PL_sv_undef);
	    SETTARG;
	}
	SETs(&PL_sv_undef);
a3080 67
/* Returns false if substring is completely outside original string.
   No length is indicated by len_iv = 0 and len_is_uv = 0.  len_is_uv must
   always be true for an explicit 0.
*/
bool
Perl_translate_substr_offsets(pTHX_ STRLEN curlen, IV pos1_iv,
				    bool pos1_is_uv, IV len_iv,
				    bool len_is_uv, STRLEN *posp,
				    STRLEN *lenp)
{
    IV pos2_iv;
    int    pos2_is_uv;

    PERL_ARGS_ASSERT_TRANSLATE_SUBSTR_OFFSETS;

    if (!pos1_is_uv && pos1_iv < 0 && curlen) {
	pos1_is_uv = curlen-1 > ~(UV)pos1_iv;
	pos1_iv += curlen;
    }
    if ((pos1_is_uv || pos1_iv > 0) && (UV)pos1_iv > curlen)
	return FALSE;

    if (len_iv || len_is_uv) {
	if (!len_is_uv && len_iv < 0) {
	    pos2_iv = curlen + len_iv;
	    if (curlen)
		pos2_is_uv = curlen-1 > ~(UV)len_iv;
	    else
		pos2_is_uv = 0;
	} else {  /* len_iv >= 0 */
	    if (!pos1_is_uv && pos1_iv < 0) {
		pos2_iv = pos1_iv + len_iv;
		pos2_is_uv = (UV)len_iv > (UV)IV_MAX;
	    } else {
		if ((UV)len_iv > curlen-(UV)pos1_iv)
		    pos2_iv = curlen;
		else
		    pos2_iv = pos1_iv+len_iv;
		pos2_is_uv = 1;
	    }
	}
    }
    else {
	pos2_iv = curlen;
	pos2_is_uv = 1;
    }

    if (!pos2_is_uv && pos2_iv < 0) {
	if (!pos1_is_uv && pos1_iv < 0)
	    return FALSE;
	pos2_iv = 0;
    }
    else if (!pos1_is_uv && pos1_iv < 0)
	pos1_iv = 0;

    if ((UV)pos2_iv < (UV)pos1_iv)
	pos2_iv = pos1_iv;
    if ((UV)pos2_iv > curlen)
	pos2_iv = curlen;

    /* pos1_iv and pos2_iv both in 0..curlen, so the cast is safe */
    *posp = (STRLEN)( (UV)pos1_iv );
    *lenp = (STRLEN)( (UV)pos2_iv - (UV)pos1_iv );

    return TRUE;
}

d3090 2
d3094 2
a3095 3
    int    len_is_uv = 0;
    I32 lvalue = PL_op->op_flags & OPf_MOD || LVRET;
    const bool rvalue = (GIMME_V != G_VOID);
d3097 1
d3101 1
a3101 1
    int num_args = PL_op->op_private & 7;
d3105 2
d3109 7
a3115 7
	  if(!(repl_sv = POPs)) num_args--;
	}
	if ((len_sv = POPs)) {
	    len_iv    = SvIV(len_sv);
	    len_is_uv = len_iv ? SvIOK_UV(len_sv) : 1;
	}
	else num_args--;
a3120 4
    if (PL_op->op_private & OPpSUBSTR_REPL_FIRST) {
	assert(!repl_sv);
	repl_sv = POPs;
    }
a3122 2
	repl = SvPV_const(repl_sv, repl_len);
	repl_is_utf8 = DO_UTF8(repl_sv) && repl_len;
d3128 63
a3190 1
	    repl_need_utf8_upgrade = TRUE;
a3191 14
    else if (lvalue) {
	SV * ret;
	ret = sv_2mortal(newSV_type(SVt_PVLV));  /* Not TARG RT#67838 */
	sv_magic(ret, NULL, PERL_MAGIC_substr, NULL, 0);
	LvTYPE(ret) = 'x';
	LvTARG(ret) = SvREFCNT_inc_simple(sv);
	LvTARGOFF(ret) =
	    pos1_is_uv || pos1_iv >= 0
		? (STRLEN)(UV)pos1_iv
		: (LvFLAGS(ret) |= 1, (STRLEN)(UV)-pos1_iv);
	LvTARGLEN(ret) =
	    len_is_uv || len_iv > 0
		? (STRLEN)(UV)len_iv
		: (LvFLAGS(ret) |= 2, (STRLEN)(UV)-len_iv);
d3193 4
a3196 3
	SPAGAIN;
	PUSHs(ret);    /* avoid SvSETMAGIC here */
	RETURN;
d3198 7
a3204 10
    tmps = SvPV_const(sv, curlen);
    if (DO_UTF8(sv)) {
        utf8_curlen = sv_len_utf8(sv);
	if (utf8_curlen == curlen)
	    utf8_curlen = 0;
	else
	    curlen = utf8_curlen;
    }
    else
	utf8_curlen = 0;
d3207 5
a3211 8
	STRLEN pos, len, byte_len, byte_pos;

	if (!translate_substr_offsets(
		curlen, pos1_iv, pos1_is_uv, len_iv, len_is_uv, &pos, &len
	)) goto bound_fail;

	byte_len = len;
	byte_pos = utf8_curlen
d3215 12
d3228 1
a3228 4
	if (rvalue) {
	    SvTAINTED_off(TARG);			/* decontaminate */
	    SvUTF8_off(TARG);			/* decontaminate */
	    sv_setpvn(TARG, tmps, byte_len);
d3230 1
a3230 1
	    sv_unmagic(TARG, PERL_MAGIC_collxfrm);
d3232 2
a3233 4
	    if (utf8_curlen)
		SvUTF8_on(TARG);
	}

d3241 1
a3241 1
		repl_is_utf8 = DO_UTF8(repl_sv_copy) && repl_len;
a3242 4
	    if (SvROK(sv))
		Perl_ck_warner(aTHX_ packWARN(WARN_SUBSTR),
			    "Attempt to use reference as lvalue in substr"
		);
d3250 28
d3280 1
a3280 4
    if (rvalue) {
	SvSETMAGIC(TARG);
	PUSHs(TARG);
    }
d3284 1
a3284 1
    if (repl)
d3292 1
a3292 1
    dVAR; dSP;
a3296 1
    SV * ret;
d3298 1
d3300 13
a3312 11
	ret = sv_2mortal(newSV_type(SVt_PVLV));  /* Not TARG RT#67838 */
	sv_magic(ret, NULL, PERL_MAGIC_vec, NULL, 0);
	LvTYPE(ret) = 'v';
	LvTARG(ret) = SvREFCNT_inc_simple(src);
	LvTARGOFF(ret) = offset;
	LvTARGLEN(ret) = size;
    }
    else {
	dTARGET;
	SvTAINTED_off(TARG);		/* decontaminate */
	ret = TARG;
d3315 2
a3316 2
    sv_setuv(ret, do_vecget(src, offset, size));
    PUSHs(ret);
d3332 1
a3335 1
    const bool threeargs = MAXARG >= 3 && (TOPs || ((void)POPs,0));
d3337 5
a3341 2
    if (threeargs)
	offset = POPi;
d3411 1
a3411 1
    if (!threeargs)
d3436 1
a3436 1
    PUSHi(retval);
d3443 2
a3444 1
    SvTAINTED_off(TARG);
d3516 1
a3516 1
	    UNICODE_IS_REPLACEMENT(utf8_to_uvchr_buf((U8*)tmps, (U8*) tmps + SvCUR(TARG), NULL))) {
d3576 1
d3583 7
d3591 9
a3599 2
 * exactly two UTF-8 and UTF-EBCDIC bytes; it is stored into p and p+1,
 * and p is advanced to point to the next available byte after the two bytes */
d3606 40
a3670 1
    bool tainted = FALSE;
a3692 1
	ulen = 0;
d3696 78
a3773 4
        ulen = UTF8SKIP(s);
        if (op_type == OP_UCFIRST) {
	    _to_utf8_title_flags(s, tmpbuf, &tculen,
				 cBOOL(IN_LOCALE_RUNTIME), &tainted);
d3775 13
a3787 3
        else {
	    _to_utf8_lower_flags(s, tmpbuf, &tculen,
				 cBOOL(IN_LOCALE_RUNTIME), &tainted);
d3789 1
a3789 4

        /* we can't do in-place if the length changes.  */
        if (ulen != tculen) inplace = FALSE;
        need = slen + 1 - ulen + tculen;
a3793 1
	ulen = 1;	/* Original character is 1 byte */
d3816 19
a3834 9
	    UV title_ord = _to_upper_title_latin1(*s, tmpbuf, &tculen, 's');
	    if (tculen > 1) {
		assert(tculen == 2);

                /* If the result is an upper Latin1-range character, it can
                 * still be represented in one byte, which is its ordinal */
		if (UTF8_IS_DOWNGRADEABLE_START(*tmpbuf)) {
		    *tmpbuf = (U8) title_ord;
		    tculen = 1;
d3837 15
a3851 23
                    /* Otherwise it became more than one ASCII character (in
                     * the case of LATIN_SMALL_LETTER_SHARP_S) or changed to
                     * beyond Latin1, so the number of bytes changed, so can't
                     * replace just the first character in place. */
		    inplace = FALSE;

		    /* If the result won't fit in a byte, the entire result will
		     * have to be in UTF-8.  Assume worst case sizing in
		     * conversion. (all latin1 characters occupy at most two bytes
		     * in utf8) */
		    if (title_ord > 255) {
			doing_utf8 = TRUE;
			convert_source_to_utf8 = TRUE;
			need = slen * 2 + 1;

                        /* The (converted) UTF-8 and UTF-EBCDIC lengths of all
                         * (both) characters whose title case is above 255 is
                         * 2. */
			ulen = 2;
		    }
                    else { /* LATIN_SMALL_LETTER_SHARP_S expands by 1 byte */
			need = slen + 1 + 1;
		    }
d3853 1
a3853 1
	    }
a3917 5

	if (tainted) {
	    TAINT;
	    SvTAINTED_on(dest);
	}
a3951 2
    if (dest != source && SvTAINTED(source))
	SvTAINT(dest);
a4020 1
	bool tainted = FALSE;
d4022 7
a4028 10
	/* All occurrences of these are to be moved to follow any other marks.
	 * This is context-dependent.  We may not be passed enough context to
	 * move the iota subscript beyond all of them, but we do the best we can
	 * with what we're given.  The result is always better than if we
	 * hadn't done this.  And, the problem would only arise if we are
	 * passed a character without all its combining marks, which would be
	 * the caller's mistake.  The information this is based on comes from a
	 * comment in Unicode SpecialCasing.txt, (and the Standard's text
	 * itself) and so can't be checked properly to see if it ever gets
	 * revised.  But the likelihood of it changing is remote */
d4030 1
d4033 1
a4033 3
	    STRLEN u;
	    STRLEN ulen;
	    UV uv;
a4034 1

d4041 29
a4069 1
            }
d4071 2
a4072 2
            /* Then handle the current character.  Get the changed case value
             * and copy it to the output buffer */
d4074 29
a4102 29
            u = UTF8SKIP(s);
            uv = _to_utf8_upper_flags(s, tmpbuf, &ulen,
				      cBOOL(IN_LOCALE_RUNTIME), &tainted);
            if (uv == GREEK_CAPITAL_LETTER_IOTA
                && utf8_to_uvchr_buf(s, send, 0) == COMBINING_GREEK_YPOGEGRAMMENI)
            {
                in_iota_subscript = TRUE;
            }
            else {
                if (ulen > u && (SvLEN(dest) < (min += ulen - u))) {
                    /* If the eventually required minimum size outgrows the
                     * available space, we need to grow. */
                    const UV o = d - (U8*)SvPVX_const(dest);

                    /* If someone uppercases one million U+03B0s we SvGROW()
                     * one million times.  Or we could try guessing how much to
                     * allocate without allocating too much.  Such is life.
                     * See corresponding comment in lc code for another option
                     * */
                    SvGROW(dest, min);
                    d = (U8*)SvPVX(dest) + o;
                }
                Copy(tmpbuf, d, ulen, U8);
                d += ulen;
            }
            s += u;
	}
	if (in_iota_subscript) {
	    CAT_UNI_TO_UTF8_TWO_BYTE(d, GREEK_CAPITAL_LETTER_IOTA);
d4104 3
a4108 1

d4110 1
a4110 6
	if (tainted) {
	    TAINT;
	    SvTAINTED_on(dest);
	}
    }
    else {	/* Not UTF-8 */
d4131 1
a4131 1
		    if (LIKELY(*d != LATIN_SMALL_LETTER_Y_WITH_DIAERESIS)) continue;
d4192 3
d4199 2
d4202 7
a4208 2
			(void) _to_upper_title_latin1(*s, d, &len, 'S');
			d += len;
a4224 2
    if (dest != source && SvTAINTED(source))
	SvTAINT(dest);
a4284 1
	bool tainted = FALSE;
d4287 30
a4316 2
	    const STRLEN u = UTF8SKIP(s);
	    STRLEN ulen;
d4318 1
a4318 2
	    _to_utf8_lower_flags(s, tmpbuf, &ulen,
				 cBOOL(IN_LOCALE_RUNTIME), &tainted);
d4320 42
a4361 2
	    /* Here is where we would do context-sensitive actions.  See the
	     * commit message for this comment for why there isn't any */
d4363 40
a4402 21
	    if (ulen > u && (SvLEN(dest) < (min += ulen - u))) {

		/* If the eventually required minimum size outgrows the
		 * available space, we need to grow. */
		const UV o = d - (U8*)SvPVX_const(dest);

		/* If someone lowercases one million U+0130s we SvGROW() one
		 * million times.  Or we could try guessing how much to
		 * allocate without allocating too much.  Such is life.
		 * Another option would be to grow an extra byte or two more
		 * each time we need to grow, which would cut down the million
		 * to 500K, with little waste */
		SvGROW(dest, min);
		d = (U8*)SvPVX(dest) + o;
	    }

	    /* Copy the newly lowercased letter to the output buffer we're
	     * building */
	    Copy(tmpbuf, d, ulen, U8);
	    d += ulen;
	    s += u;
a4406 4
	if (tainted) {
	    TAINT;
	    SvTAINTED_on(dest);
	}
a4435 2
    if (dest != source && SvTAINTED(source))
	SvTAINT(dest);
d4455 7
a4461 7
		STRLEN ulen = UTF8SKIP(s);
		bool to_quote = FALSE;

		if (UTF8_IS_INVARIANT(*s)) {
		    if (_isQUOTEMETA(*s)) {
			to_quote = TRUE;
		    }
d4463 5
a4467 12
		else if (UTF8_IS_DOWNGRADEABLE_START(*s)) {

		    /* In locale, we quote all non-ASCII Latin1 chars.
		     * Otherwise use the quoting rules */
		    if (IN_LOCALE_RUNTIME
			|| _isQUOTEMETA(TWO_BYTE_UTF8_TO_UNI(*s, *(s + 1))))
		    {
			to_quote = TRUE;
		    }
		}
		else if (_is_utf8_quotemeta((U8 *) s)) {
		    to_quote = TRUE;
a4468 9

		if (to_quote) {
		    *d++ = '\\';
		}
		if (ulen > len)
		    ulen = len;
		len -= ulen;
		while (ulen--)
		    *d++ = *s++;
a4471 7
	else if (IN_UNI_8_BIT) {
	    while (len--) {
		if (_isQUOTEMETA(*s))
		    *d++ = '\\';
		*d++ = *s++;
	    }
	}
a4472 2
	    /* For non UNI_8_BIT (and hence in locale) just quote all \W
	     * including everything above ASCII */
d4474 1
a4474 1
		if (!isWORDCHAR_A(*s))
a4488 153
PP(pp_fc)
{
    dVAR;
    dTARGET;
    dSP;
    SV *source = TOPs;
    STRLEN len;
    STRLEN min;
    SV *dest;
    const U8 *s;
    const U8 *send;
    U8 *d;
    U8 tmpbuf[UTF8_MAXBYTES * UTF8_MAX_FOLD_CHAR_EXPAND + 1];
    const bool full_folding = TRUE;
    const U8 flags = ( full_folding      ? FOLD_FLAGS_FULL   : 0 )
                   | ( IN_LOCALE_RUNTIME ? FOLD_FLAGS_LOCALE : 0 );

    /* This is a facsimile of pp_lc, but with a thousand bugs thanks to me.
     * You are welcome(?) -Hugmeir
     */

    SvGETMAGIC(source);

    dest = TARG;

    if (SvOK(source)) {
        s = (const U8*)SvPV_nomg_const(source, len);
    } else {
        if (ckWARN(WARN_UNINITIALIZED))
	    report_uninit(source);
	s = (const U8*)"";
	len = 0;
    }

    min = len + 1;

    SvUPGRADE(dest, SVt_PV);
    d = (U8*)SvGROW(dest, min);
    (void)SvPOK_only(dest);

    SETs(dest);

    send = s + len;
    if (DO_UTF8(source)) { /* UTF-8 flagged string. */
        bool tainted = FALSE;
        while (s < send) {
            const STRLEN u = UTF8SKIP(s);
            STRLEN ulen;

            _to_utf8_fold_flags(s, tmpbuf, &ulen, flags, &tainted);

            if (ulen > u && (SvLEN(dest) < (min += ulen - u))) {
                const UV o = d - (U8*)SvPVX_const(dest);
                SvGROW(dest, min);
                d = (U8*)SvPVX(dest) + o;
            }

            Copy(tmpbuf, d, ulen, U8);
            d += ulen;
            s += u;
        }
        SvUTF8_on(dest);
	if (tainted) {
	    TAINT;
	    SvTAINTED_on(dest);
	}
    } /* Unflagged string */
    else if (len) {
        /* For locale, bytes, and nothing, the behavior is supposed to be the
         * same as lc().
         */
        if ( IN_LOCALE_RUNTIME ) { /* Under locale */
            TAINT;
            SvTAINTED_on(dest);
            for (; s < send; d++, s++)
                *d = toLOWER_LC(*s);
        }
        else if ( !IN_UNI_8_BIT ) { /* Under nothing, or bytes */
            for (; s < send; d++, s++)
                *d = toLOWER(*s);
        }
        else {
            /* For ASCII and the Latin-1 range, there's only two troublesome folds,
            * \x{DF} (\N{LATIN SMALL LETTER SHARP S}), which under full casefolding
            * becomes 'ss', and \x{B5} (\N{MICRO SIGN}), which under any fold becomes
            * \x{3BC} (\N{GREEK SMALL LETTER MU}) -- For the rest, the casefold is
            * their lowercase.
            */
            for (; s < send; d++, s++) {
                if (*s == MICRO_SIGN) {
                    /* \N{MICRO SIGN}'s casefold is \N{GREEK SMALL LETTER MU}, which
                    * is outside of the latin-1 range. There's a couple of ways to
                    * deal with this -- khw discusses them in pp_lc/uc, so go there :)
                    * What we do here is upgrade what we had already casefolded,
                    * then enter an inner loop that appends the rest of the characters
                    * as UTF-8.
                    */
                    len = d - (U8*)SvPVX_const(dest);
                    SvCUR_set(dest, len);
                    len = sv_utf8_upgrade_flags_grow(dest,
                                                SV_GMAGIC|SV_FORCE_UTF8_UPGRADE,
						/* The max expansion for latin1
						 * chars is 1 byte becomes 2 */
                                                (send -s) * 2 + 1);
                    d = (U8*)SvPVX(dest) + len;

                    CAT_UNI_TO_UTF8_TWO_BYTE(d, GREEK_SMALL_LETTER_MU);
                    s++;
                    for (; s < send; s++) {
                        STRLEN ulen;
                        UV fc = _to_uni_fold_flags(*s, tmpbuf, &ulen, flags);
                        if UNI_IS_INVARIANT(fc) {
                            if ( full_folding && *s == LATIN_SMALL_LETTER_SHARP_S) {
                                *d++ = 's';
                                *d++ = 's';
                            }
                            else
                                *d++ = (U8)fc;
                        }
                        else {
                            Copy(tmpbuf, d, ulen, U8);
                            d += ulen;
                        }
                    }
                    break;
                }
                else if (full_folding && *s == LATIN_SMALL_LETTER_SHARP_S) {
                    /* Under full casefolding, LATIN SMALL LETTER SHARP S becomes "ss",
                    * which may require growing the SV.
                    */
                    if (SvLEN(dest) < ++min) {
                        const UV o = d - (U8*)SvPVX_const(dest);
                        SvGROW(dest, min);
                        d = (U8*)SvPVX(dest) + o;
                     }
                    *(d)++ = 's';
                    *d = 's';
                }
                else { /* If it's not one of those two, the fold is their lower case */
                    *d = toLOWER_LATIN1(*s);
                }
             }
        }
    }
    *d = '\0';
    SvCUR_set(dest, d - (U8*)SvPVX_const(dest));

    if (SvTAINTED(source))
	SvTAINT(dest);
    SvSETMAGIC(dest);
    RETURN;
}

d4498 1
d4526 2
a4557 37
/* Smart dereferencing for keys, values and each */
PP(pp_rkeys)
{
    dVAR;
    dSP;
    dPOPss;

    SvGETMAGIC(sv);

    if (
         !SvROK(sv)
      || (sv = SvRV(sv),
            (SvTYPE(sv) != SVt_PVHV && SvTYPE(sv) != SVt_PVAV)
          || SvOBJECT(sv)
         )
    ) {
	DIE(aTHX_
	   "Type of argument to %s must be unblessed hashref or arrayref",
	    PL_op_desc[PL_op->op_type] );
    }

    if (PL_op->op_flags & OPf_SPECIAL && SvTYPE(sv) == SVt_PVAV)
	DIE(aTHX_
	   "Can't modify %s in %s",
	    PL_op_desc[PL_op->op_type], PL_op_desc[PL_op->op_next->op_type]
	);

    /* Delegate to correct function for op type */
    PUSHs(sv);
    if (PL_op->op_type == OP_RKEYS || PL_op->op_type == OP_RVALUES) {
	return (SvTYPE(sv) == SVt_PVHV) ? Perl_do_kv(aTHX) : Perl_pp_akeys(aTHX);
    }
    else {
	return (SvTYPE(sv) == SVt_PVHV) ? Perl_pp_each(aTHX) : Perl_pp_aeach(aTHX);
    }
}

d4576 1
a4576 1
    mPUSHi(current);
d4599 1
a4599 1
        IV i;
d4603 3
a4605 2
	if (PL_op->op_type == OP_AKEYS || PL_op->op_type == OP_RKEYS) {
	    for (i = 0;  i <= n;  i++) {
d4965 1
a4965 1
            if (!svp || !*svp || *svp == &PL_sv_undef) {
d4978 1
a4978 1
        *MARK = svp && *svp ? *svp : &PL_sv_undef;
d5011 1
d5021 2
d5040 2
a5087 30
static AV *
S_deref_plain_array(pTHX_ AV *ary)
{
    if (SvTYPE(ary) == SVt_PVAV) return ary;
    SvGETMAGIC((SV *)ary);
    if (!SvROK(ary) || SvTYPE(SvRV(ary)) != SVt_PVAV)
	Perl_die(aTHX_ "Not an ARRAY reference");
    else if (SvOBJECT(SvRV(ary)))
	Perl_die(aTHX_ "Not an unblessed ARRAY reference");
    return (AV *)SvRV(ary);
}

#if defined(__GNUC__) && !defined(PERL_GCC_BRACE_GROUPS_FORBIDDEN)
# define DEREF_PLAIN_ARRAY(ary)       \
   ({                                  \
     AV *aRrRay = ary;                  \
     SvTYPE(aRrRay) == SVt_PVAV          \
      ? aRrRay                            \
      : S_deref_plain_array(aTHX_ aRrRay); \
   })
#else
# define DEREF_PLAIN_ARRAY(ary)            \
   (                                        \
     PL_Sv = (SV *)(ary),                    \
     SvTYPE(PL_Sv) == SVt_PVAV                \
      ? (AV *)PL_Sv                            \
      : S_deref_plain_array(aTHX_ (AV *)PL_Sv)  \
   )
#endif

d5091 1
a5091 2
    int num_args = (SP - MARK);
    register AV *ary = DEREF_PLAIN_ARRAY(MUTABLE_AV(*++MARK));
d5103 8
a5110 3
	return Perl_tied_method(aTHX_ "SPLICE", mark - 1, MUTABLE_SV(ary), mg,
				    GIMME_V | TIED_METHOD_ARGUMENTS_ON_STACK,
				    sp - mark);
d5119 2
d5139 1
a5139 2
	if (num_args > 2)
	    Perl_ck_warner(aTHX_ packWARN(WARN_MISC), "splice() offset past end of array" );
d5177 1
a5177 1
		    sv_2mortal(*dst);	/* free them eventually */
d5269 1
a5269 1
			sv_2mortal(*dst);	/* free them eventually */
a5287 4

    if (SvMAGICAL(ary))
	mg_set(MUTABLE_SV(ary));

d5295 1
a5295 1
    register AV * const ary = DEREF_PLAIN_ARRAY(MUTABLE_AV(*++MARK));
d5315 1
a5315 1
	if (PL_delaymagic & DM_ARRAY_ISA)
d5331 1
a5331 2
    AV * const av = PL_op->op_flags & OPf_SPECIAL
	? MUTABLE_AV(GvAV(PL_defgv)) : DEREF_PLAIN_ARRAY(MUTABLE_AV(POPs));
d5344 1
a5344 1
    register AV *ary = DEREF_PLAIN_ARRAY(MUTABLE_AV(*++MARK));
d5454 1
d5460 7
a5466 1
	    sv_setsv(TARG, SP > MARK ? *SP : find_rundefsv());
d5482 1
a5482 1
			if (!utf8_to_uvchr_buf(s, send, 0))
d5546 1
a5546 1
	DIE(aTHX_ "panic: pp_split, pm=%p, s=%p", pm, s);
d5549 1
a5549 1
    TAINT_IF(get_regex_charset(RX_EXTFLAGS(rx)) == REGEX_LOCALE_CHARSET &&
d5595 1
a5595 1
	else if (get_regex_charset(RX_EXTFLAGS(rx)) == REGEX_LOCALE_CHARSET) {
d5604 1
a5604 1
    if (RX_EXTFLAGS(rx) & RXf_PMf_MULTILINE) {
d5625 1
a5625 2
	    }
	    else if (get_regex_charset(RX_EXTFLAGS(rx)) == REGEX_LOCALE_CHARSET) {
d5657 1
a5657 2
	    }
	    else if (get_regex_charset(RX_EXTFLAGS(rx)) == REGEX_LOCALE_CHARSET) {
d5812 1
a5812 1
				     sv, NULL, SvSCREAM(sv) ? REXEC_SCREAM : 0);
d5961 1
d5963 1
a5963 2
    if (SvTYPE(retsv) == SVt_PVAV || SvTYPE(retsv) == SVt_PVHV
     || SvTYPE(retsv) == SVt_PVCV) {
d5974 3
a5976 14
    const Optype op_type = PL_op->op_type;
    /* Using OP_NAME() isn't going to be helpful here. Firstly, it doesn't cope
       with out of range op numbers - it only "special" cases op_custom.
       Secondly, as the three ops we "panic" on are padmy, mapstart and custom,
       if we get here for a custom op then that means that the custom op didn't
       have an implementation. Given that OP_NAME() looks up the custom op
       by its pp_addr, likely it will return NULL, unless someone (unhelpfully)
       registers &PL_unimplemented_op as the address of their custom op.
       NULL doesn't generate a useful error message. "custom" does. */
    const char *const name = op_type >= OP_max
	? "[out of range]" : PL_op_name[PL_op->op_type];
    if(OP_IS_SOCKET(op_type))
	DIE(aTHX_ PL_no_sock_func, name);
    DIE(aTHX_ "panic: unimplemented op %s (#%d) called", name,	op_type);
a5984 2
    if (SvTYPE(hv) != SVt_PVHV) { XPUSHs(&PL_sv_no); RETURN; }

d5993 1
a5993 141
    XPUSHs(boolSV(HvUSEDKEYS(hv) != 0));
    RETURN;
}

/* For sorting out arguments passed to a &CORE:: subroutine */
PP(pp_coreargs)
{
    dSP;
    int opnum = SvIOK(cSVOP_sv) ? (int)SvUV(cSVOP_sv) : 0;
    int defgv = PL_opargs[opnum] & OA_DEFGV, whicharg = 0;
    AV * const at_ = GvAV(PL_defgv);
    SV **svp = AvARRAY(at_);
    I32 minargs = 0, maxargs = 0, numargs = AvFILLp(at_)+1;
    I32 oa = opnum ? PL_opargs[opnum] >> OASHIFT : 0;
    bool seen_question = 0;
    const char *err = NULL;
    const bool pushmark = PL_op->op_private & OPpCOREARGS_PUSHMARK;

    /* Count how many args there are first, to get some idea how far to
       extend the stack. */
    while (oa) {
	if ((oa & 7) == OA_LIST) { maxargs = I32_MAX; break; }
	maxargs++;
	if (oa & OA_OPTIONAL) seen_question = 1;
	if (!seen_question) minargs++;
	oa >>= 4;
    }

    if(numargs < minargs) err = "Not enough";
    else if(numargs > maxargs) err = "Too many";
    if (err)
	/* diag_listed_as: Too many arguments for %s */
	Perl_croak(aTHX_
	  "%s arguments for %s", err,
	   opnum ? OP_DESC(PL_op->op_next) : SvPV_nolen_const(cSVOP_sv)
	);

    /* Reset the stack pointer.  Without this, we end up returning our own
       arguments in list context, in addition to the values we are supposed
       to return.  nextstate usually does this on sub entry, but we need
       to run the next op with the caller's hints, so we cannot have a
       nextstate. */
    SP = PL_stack_base + cxstack[cxstack_ix].blk_oldsp;

    if(!maxargs) RETURN;

    /* We do this here, rather than with a separate pushmark op, as it has
       to come in between two things this function does (stack reset and
       arg pushing).  This seems the easiest way to do it. */
    if (pushmark) {
	PUTBACK;
	(void)Perl_pp_pushmark(aTHX);
    }

    EXTEND(SP, maxargs == I32_MAX ? numargs : maxargs);
    PUTBACK; /* The code below can die in various places. */

    oa = PL_opargs[opnum] >> OASHIFT;
    for (; oa&&(numargs||!pushmark); (void)(numargs&&(++svp,--numargs))) {
	whicharg++;
	switch (oa & 7) {
	case OA_SCALAR:
	    if (!numargs && defgv && whicharg == minargs + 1) {
		PERL_SI * const oldsi = PL_curstackinfo;
		I32 const oldcxix = oldsi->si_cxix;
		CV *caller;
		if (oldcxix) oldsi->si_cxix--;
		else PL_curstackinfo = oldsi->si_prev;
		caller = find_runcv(NULL);
		PL_curstackinfo = oldsi;
		oldsi->si_cxix = oldcxix;
		PUSHs(find_rundefsv2(
		    caller,cxstack[cxstack_ix].blk_oldcop->cop_seq
		));
	    }
	    else PUSHs(numargs ? svp && *svp ? *svp : &PL_sv_undef : NULL);
	    break;
	case OA_LIST:
	    while (numargs--) {
		PUSHs(svp && *svp ? *svp : &PL_sv_undef);
		svp++;
	    }
	    RETURN;
	case OA_HVREF:
	    if (!svp || !*svp || !SvROK(*svp)
	     || SvTYPE(SvRV(*svp)) != SVt_PVHV)
		DIE(aTHX_
		/* diag_listed_as: Type of arg %d to &CORE::%s must be %s*/
		 "Type of arg %d to &CORE::%s must be hash reference",
		  whicharg, OP_DESC(PL_op->op_next)
		);
	    PUSHs(SvRV(*svp));
	    break;
	case OA_FILEREF:
	    if (!numargs) PUSHs(NULL);
	    else if(svp && *svp && SvROK(*svp) && isGV_with_GP(SvRV(*svp)))
		/* no magic here, as the prototype will have added an extra
		   refgen and we just want what was there before that */
		PUSHs(SvRV(*svp));
	    else {
		const bool constr = PL_op->op_private & whicharg;
		PUSHs(S_rv2gv(aTHX_
		    svp && *svp ? *svp : &PL_sv_undef,
		    constr, CopHINTS_get(PL_curcop) & HINT_STRICT_REFS,
		    !constr
		));
	    }
	    break;
	case OA_SCALARREF:
	  {
	    const bool wantscalar =
		PL_op->op_private & OPpCOREARGS_SCALARMOD;
	    if (!svp || !*svp || !SvROK(*svp)
	        /* We have to permit globrefs even for the \$ proto, as
	           *foo is indistinguishable from ${\*foo}, and the proto-
	           type permits the latter. */
	     || SvTYPE(SvRV(*svp)) > (
	             wantscalar       ? SVt_PVLV
	           : opnum == OP_LOCK ? SVt_PVCV
	           :                    SVt_PVHV
	        )
	       )
		DIE(aTHX_
		/* diag_listed_as: Type of arg %d to &CORE::%s must be %s*/
		 "Type of arg %d to &CORE::%s must be %s",
		  whicharg, OP_DESC(PL_op->op_next),
		  wantscalar
		    ? "scalar reference"
		    : opnum == OP_LOCK
		       ? "reference to one of [$@@%&*]"
		       : "reference to one of [$@@%*]"
		);
	    PUSHs(SvRV(*svp));
	    break;
	  }
	default:
	    DIE(aTHX_ "panic: unknown OA_*: %x", (unsigned)(oa&7));
	}
	oa = oa >> 4;
    }

a5995 19

PP(pp_runcv)
{
    dSP;
    CV *cv;
    if (PL_op->op_private & OPpOFFBYONE) {
	PERL_SI * const oldsi = PL_curstackinfo;
	I32 const oldcxix = oldsi->si_cxix;
	if (oldcxix) oldsi->si_cxix--;
	else PL_curstackinfo = oldsi->si_prev;
	cv = find_runcv(NULL);
	PL_curstackinfo = oldsi;
	oldsi->si_cxix = oldcxix;
    }
    else cv = find_runcv(NULL);
    XPUSHs(CvEVAL(cv) ? &PL_sv_undef : sv_2mortal(newRV((SV *)cv)));
    RETURN;
}

@


1.1.1.15
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@a31 1
#include "regcharclass.h"
a85 1
        /* XXX see also S_pushav in pp_hot.c */
a133 5
    else if ((PL_op->op_private & OPpTRUEBOOL
	  || (  PL_op->op_private & OPpMAYBE_TRUEBOOL
	     && block_gimme() == G_VOID  ))
	  && (!SvRMAGICAL(TARG) || !mg_find(TARG, PERL_MAGIC_tied)))
	SETs(HvUSEDKEYS(TARG) ? &PL_sv_yes : sv_2mortal(newSViv(0)));
a140 42
PP(pp_padcv)
{
    dVAR; dSP; dTARGET;
    assert(SvTYPE(TARG) == SVt_PVCV);
    XPUSHs(TARG);
    RETURN;
}

PP(pp_introcv)
{
    dVAR; dTARGET;
    SvPADSTALE_off(TARG);
    return NORMAL;
}

PP(pp_clonecv)
{
    dVAR; dTARGET;
    MAGIC * const mg =
	mg_find(PadlistNAMESARRAY(CvPADLIST(find_runcv(NULL)))[ARGTARG],
		PERL_MAGIC_proto);
    assert(SvTYPE(TARG) == SVt_PVCV);
    assert(mg);
    assert(mg->mg_obj);
    if (CvISXSUB(mg->mg_obj)) { /* constant */
	/* XXX Should we clone it here? */
	/* If this changes to use SAVECLEARSV, we can move the SAVECLEARSV
	   to introcv and remove the SvPADSTALE_off. */
	SAVEPADSVANDMORTALIZE(ARGTARG);
	PAD_SVl(ARGTARG) = SvREFCNT_inc_simple_NN(mg->mg_obj);
    }
    else {
	if (CvROOT(mg->mg_obj)) {
	    assert(CvCLONE(mg->mg_obj));
	    assert(!CvCLONED(mg->mg_obj));
	}
	cv_clone_into((CV *)mg->mg_obj,(CV *)TARG);
	SAVECLEARSV(PAD_SVl(ARGTARG));
    }
    return NORMAL;
}

d185 1
a185 1
			Perl_croak_no_modify();
d194 1
a194 1
                                HvNAMEUTF8(CopSTASH(PL_curcop)) ? SVf_UTF8 : 0 );
d221 1
a221 1
		            (SvPOKp(sv) && SvCUR(sv)>32 ? "..." : ""),
d274 1
a274 2
	    Perl_die(aTHX_ S_no_symref_sv, sv,
		     (SvPOKp(sv) && SvCUR(sv)>32 ? "..." : ""), what);
d280 2
a281 1
	  PL_op->op_flags & OPf_REF
d379 1
a379 1
	SV * const ret = sv_2mortal(newSV_type(SVt_PVLV));/* Not TARG RT#67838 */
d409 1
a409 2
	: ((PL_op->op_private & (OPpLVAL_INTRO|OPpMAY_RETURN_CONSTANT))
                                                    == OPpMAY_RETURN_CONSTANT)
d416 4
a419 1
    if (cv) NOOP;
a436 1
    if (SvGMAGICAL(TOPs)) SETs(sv_mortalcopy(TOPs));
d442 2
a443 6
		DIE(aTHX_ "Can't find an opnumber for \"%"SVf"\"",
		    SVfARG(newSVpvn_flags(
			s+6, SvCUR(TOPs)-6,
			(SvFLAGS(TOPs) & SVf_UTF8)|SVs_TEMP
		    )));
	    {
a590 1
	    {
a591 4
		if (tmpRef && !AvREAL((const AV *)tmpRef)
		 && AvREIFY((const AV *)tmpRef))
		    av_reify(MUTABLE_AV(tmpRef));
	    }
d651 2
d654 3
d658 4
a661 1
    (void)SvPV(sv, len);
d663 10
a672 1
	/* Historically, study was skipped in these cases. */
d677 58
a734 1
       complicates matters elsewhere. */
d751 1
d759 1
a759 4
    else {
	TARG = sv_newmortal();
	PUSHi(do_trans(sv));
    }
d797 6
a802 4
            Perl_croak_no_modify();
    }
    else if (SvIsCOW(sv)) {
	sv_force_normal_flags(sv, 0);
d989 1
a989 6
                             : sv_2mortal(newSVhek(
                                CvNAMED(sv)
                                 ? CvNAME_HEK((CV *)sv)
                                 : GvENAME_HEK(CvGV((const CV *)sv))
                               ))
                           ));
a994 2
	    HEK * const hek = CvNAME_HEK((CV *)sv);
	    if (hek) share_hek_hek(hek);
d996 1
a996 5
	    if (gv) CvGV_set(MUTABLE_CV(sv), gv);
	    else if (hek) {
		SvANY((CV *)sv)->xcv_gv_u.xcv_hek = hek;
		CvNAMED_on(sv);
	    }
d1000 5
a1004 3
	assert(isGV_with_GP(sv));
	assert(!SvFAKE(sv));
	{
d1042 1
d1062 1
a1062 1
	Perl_croak_no_modify();
d1066 1
a1066 1
    if (!SvREADONLY(TOPs) && !SvGMAGICAL(TOPs) && SvIOK_notUV(TOPs) && !SvNOK(TOPs) && !SvPOK(TOPs)
d1098 5
a1102 1
    if (SvIV_please_nomg(svr) && SvIV_please_nomg(svl)) {
d1160 2
a1161 2
		    unsigned int highbit = 8 * sizeof(UV);
		    unsigned int diff = 8 * sizeof(UV);
d1172 2
a1173 2
			UV result = 1;
			UV base = baseuv;
d1200 2
d1265 2
a1266 1
    if (SvIV_please_nomg(svr)) {
d1271 2
a1272 1
	if (SvIV_please_nomg(svl)) {
d1410 4
a1413 1
    if (SvIV_please_nomg(svr) && SvIV_please_nomg(svl)) {
d1488 2
a1489 1
    } /* one operand wasn't SvIOK */
d1521 2
a1522 1
        if (SvIV_please_nomg(svr)) {
d1552 3
a1554 1
	if (!use_double && SvIV_please_nomg(svl)) {
d1567 1
d1640 1
a1640 1
    IV count;
d1680 1
a1680 1
	static const char* const oom_list_extend = "Out of memory during list extend";
d1687 1
a1687 1
	   Perl_croak(aTHX_ "%s", oom_list_extend);
d1732 1
a1732 1
	static const char* const oom_string_extend =
d1745 1
a1745 1
		     Perl_croak(aTHX_ "%s", oom_string_extend);
d1782 2
a1783 1
    if (SvIV_please_nomg(svr)) {
d1787 1
a1787 1
	UV auv = 0;
d1797 2
a1798 1
	    if (SvIV_please_nomg(svl)) {
d1802 1
a1802 1
		    const IV aiv = SvIVX(svl);
d1816 1
a1816 1
	    UV buv;
d1822 1
a1822 1
		const IV biv = SvIVX(svr);
d2026 1
d2028 3
a2030 1
    if (SvIV_please_nomg(right) && SvIV_please_nomg(left)) {
d2065 2
a2066 1
	    assert(0); /* NOTREACHED */
a2245 23
PERL_STATIC_INLINE bool
S_negate_string(pTHX)
{
    dTARGET; dSP;
    STRLEN len;
    const char *s;
    SV * const sv = TOPs;
    if (!SvPOKp(sv) || SvNIOK(sv) || (!SvPOK(sv) && SvNIOKp(sv)))
	return FALSE;
    s = SvPV_nomg_const(sv, len);
    if (isIDFIRST(*s)) {
	sv_setpvs(TARG, "-");
	sv_catsv(TARG, sv);
    }
    else if (*s == '+' || (*s == '-' && !looks_like_number(sv))) {
	sv_setsv_nomg(TARG, sv);
	*SvPV_force_nomg(TARG, len) = *s == '-' ? '+' : '-';
    }
    else return FALSE;
    SETTARG; PUTBACK;
    return TRUE;
}

a2249 1
    if (S_negate_string(aTHX)) return NORMAL;
d2252 5
d2258 2
a2259 2
	if (SvIOK(sv)) {
	    /* It's publicly an integer */
d2264 1
a2264 2
                    SETi(SvIVX(sv));	/* special case: -((UV)IV_MAX+1) ==
                                           IV_MIN */
d2283 1
a2283 1
	if (SvNIOKp(sv) && (SvNIOK(sv) || !SvPOK(sv)))
d2285 25
a2309 1
	else if (SvPOKp(sv) && SvIV_please_nomg(sv))
d2311 4
d2346 2
a2347 2
	U8 *tmps;
	I32 anum;
d2412 1
a2412 1
	    long *tmpl;
d2464 1
a2464 1
#if defined(__GLIBC__) && IVSIZE == 8 && !defined(PERL_DEBUG_READONLY_OPS)
d2487 1
a2487 1
#if defined(__GLIBC__) && IVSIZE == 8 && !defined(PERL_DEBUG_READONLY_OPS)
a2664 1
    if (S_negate_string(aTHX)) return NORMAL;
d2749 11
a2759 1
    dVAR;
d2764 3
a2766 26
    {
	dSP;
	NV value;
	EXTEND(SP, 1);
    
	if (MAXARG < 1)
	    value = 1.0;
	else {
	    SV * const sv = POPs;
	    if(!sv)
		value = 1.0;
	    else
		value = SvNV(sv);
	}
    /* 1 of 2 things can be carried through SvNV, SP or TARG, SP was carried */
	if (value == 0.0)
	    value = 1.0;
	{
	    dTARGET;
	    PUSHs(TARG);
	    PUTBACK;
	    value *= Drand01();
	    sv_setnv_mg(TARG, value);
	}
    }
    return NORMAL;
d2772 1
a2772 22
    UV anum;

    if (MAXARG >= 1 && (TOPs || POPs)) {
        SV *top;
        char *pv;
        STRLEN len;
        int flags;

        top = POPs;
        pv = SvPV(top, len);
        flags = grok_number(pv, len, &anum);

        if (!(flags & IS_NUMBER_IN_UV)) {
            Perl_ck_warner_d(aTHX_ packWARN(WARN_OVERFLOW),
                             "Integer overflow in srand");
            anum = UV_MAX;
        }
    }
    else {
        anum = seed();
    }

d2920 21
a2940 4
    SvGETMAGIC(sv);
    if (SvOK(sv)) {
	if (!IN_BYTES)
	    SETi(sv_len_utf8_nomg(sv));
a2941 3
	{
	    STRLEN len;
	    (void)SvPV_nomg_const(sv,len);
d2943 6
a2948 1
	}
d3046 1
d3067 11
a3077 1
    if (lvalue && !repl_sv) {
d3096 1
a3096 18
    if (repl_sv) {
	repl = SvPV_const(repl_sv, repl_len);
	SvGETMAGIC(sv);
	if (SvROK(sv))
	    Perl_ck_warner(aTHX_ packWARN(WARN_SUBSTR),
			    "Attempt to use reference as lvalue in substr"
	    );
	tmps = SvPV_force_nomg(sv, curlen);
	if (DO_UTF8(repl_sv) && repl_len) {
	    if (!DO_UTF8(sv)) {
		sv_utf8_upgrade_nomg(sv);
		curlen = SvCUR(sv);
	    }
	}
	else if (DO_UTF8(sv))
	    repl_need_utf8_upgrade = TRUE;
    }
    else tmps = SvPV_const(sv, curlen);
d3098 1
a3098 1
        utf8_curlen = sv_or_pv_len_utf8(sv, tmps, curlen);
d3116 1
a3116 1
	    ? sv_or_pv_pos_u2b(sv, tmps, pos, &byte_len) : pos;
d3138 1
d3140 4
d3147 2
d3169 3
a3171 3
    const IV size   = POPi;
    const IV offset = POPi;
    SV * const src = POPs;
a3347 1
    SV *top = POPs;
d3349 1
a3349 3
    SvGETMAGIC(top);
    if (!IN_BYTES /* under bytes, chr(-1) eq chr(0xff), etc. */
     && ((SvIOKp(top) && !SvIsUV(top) && SvIV_nomg(top) < 0)
d3351 5
a3355 11
	 ((SvNOKp(top) || (SvOK(top) && !SvIsUV(top)))
	  && SvNV_nomg(top) < 0.0))) {
	    if (ckWARN(WARN_UTF8)) {
		if (SvGMAGICAL(top)) {
		    SV *top2 = sv_newmortal();
		    sv_setsv_nomg(top2, top);
		    top = top2;
		}
		Perl_warner(aTHX_ packWARN(WARN_UTF8),
			   "Invalid negative number (%"SVf") in chr", top);
	    }
d3357 1
d3359 1
a3359 1
	value = SvUV_nomg(top);
d3385 2
a3386 4
	if (SvCUR(TARG) == 0
	    || ! is_utf8_string((U8*)tmps, SvCUR(TARG))
	    || UTF8_IS_REPLACEMENT((U8*) tmps, (U8*) tmps + SvCUR(TARG)))
	{
d3570 4
a3573 4
                    /* If the result won't fit in a byte, the entire result
                     * will have to be in UTF-8.  Assume worst case sizing in
                     * conversion. (all latin1 characters occupy at most two
                     * bytes in utf8) */
d3781 1
a3781 1
	    if (in_iota_subscript && ! _is_utf8_mark(s)) {
d3854 1
a3854 3
		    if (LIKELY(*d != LATIN_SMALL_LETTER_Y_WITH_DIAERESIS)) {
                        continue;
                    }
d4081 1
a4081 1
    const char *s = SvPV_const(sv,len);
d4085 1
a4085 1
	char *d;
d4109 1
a4109 1
		else if (is_QUOTEMETA_high(s)) {
d4232 6
a4237 5
            /* For ASCII and the Latin-1 range, there's only two troublesome
             * folds, \x{DF} (\N{LATIN SMALL LETTER SHARP S}), which under full
             * casefolding becomes 'ss', and \x{B5} (\N{MICRO SIGN}), which
             * under any fold becomes \x{3BC} (\N{GREEK SMALL LETTER MU}) --
             * For the rest, the casefold is their lowercase.  */
d4240 7
a4246 6
                    /* \N{MICRO SIGN}'s casefold is \N{GREEK SMALL LETTER MU},
                     * which is outside of the latin-1 range. There's a couple
                     * of ways to deal with this -- khw discusses them in
                     * pp_lc/uc, so go there :) What we do here is upgrade what
                     * we had already casefolded, then enter an inner loop that
                     * appends the rest of the characters as UTF-8. */
d4262 1
a4262 3
                            if (full_folding
                                && *s == LATIN_SMALL_LETTER_SHARP_S)
                            {
d4277 3
a4279 2
                    /* Under full casefolding, LATIN SMALL LETTER SHARP S
                     * becomes "ss", which may require growing the SV. */
d4288 1
a4288 2
                else { /* If it's not one of those two, the fold is their lower
                          case */
d4308 2
a4309 2
    AV *const av = MUTABLE_AV(POPs);
    const I32 lval = (PL_op->op_flags & OPf_MOD || LVRET);
d4323 1
a4323 1
	    SV **svp;
d4335 1
a4335 1
	    SV **svp;
d4402 1
a4402 3
	return (SvTYPE(sv) == SVt_PVHV)
               ? Perl_pp_each(aTHX)
               : Perl_pp_aeach(aTHX);
d4508 5
a4512 6
    const bool sliced = !!(PL_op->op_private & OPpSLICE);
    SV *unsliced_keysv = sliced ? NULL : POPs;
    SV * const osv = POPs;
    SV **mark = sliced ? PL_stack_base + POPMARK : &unsliced_keysv-1;
    dORIGMARK;
    const bool tied = SvRMAGICAL(osv)
d4514 4
a4517 5
    const bool can_preserve = SvCANEXISTDELETE(osv);
    const U32 type = SvTYPE(osv);
    SV ** const end = sliced ? SP : &unsliced_keysv;

    if (type == SVt_PVHV) {			/* hash element */
d4519 1
a4519 1
	    while (++MARK <= end) {
a4536 1
		    if (!sv) DIE(aTHX_ PL_no_helem_sv, SVfARG(keysv));
d4549 2
a4550 2
    }
    else if (type == SVt_PVAV) {                  /* array element */
d4553 1
a4553 1
		while (++MARK <= end) {
d4584 2
a4585 4
	    else
		DIE(aTHX_ "panic: avhv_delete no longer supported");
    }
    else
a4586 1
    if (sliced) {
d4598 75
a4672 2
    else if (gimme != G_VOID)
	PUSHs(unsliced_keysv);
d4781 2
a4782 2
    HV * const hv = MUTABLE_HV(POPs);
    const I32 lval = (PL_op->op_flags & OPf_MOD || LVRET);
d4790 1
a4790 1
	if (SvCANEXISTDELETE(hv))
d4857 1
a4857 1
    SV ** const firstrelem = lastlelem + 1;
d4860 2
a4861 2
    const I32 max = lastrelem - lastlelem;
    SV **lelem;
d4913 1
a4913 1
    HV* const hv = (HV *)sv_2mortal((SV *)newHV());
d4916 2
a4917 3
	SV * const key =
	    (MARK++, SvGMAGICAL(*MARK) ? sv_mortalcopy(*MARK) : *MARK);
	SV *val;
d4919 1
a4919 6
	{
	    MARK++;
	    SvGETMAGIC(*MARK);
	    val = newSV(0);
	    sv_setsv(val, *MARK);
	}
a4920 1
	{
a4921 2
	    val = newSV(0);
	}
d4925 2
a4926 3
    if (PL_op->op_flags & OPf_SPECIAL)
	mXPUSHs(newRV_inc(MUTABLE_SV(hv)));
    else XPUSHs(MUTABLE_SV(hv));
d4964 6
a4969 6
    AV *ary = DEREF_PLAIN_ARRAY(MUTABLE_AV(*++MARK));
    SV **src;
    SV **dst;
    I32 i;
    I32 offset;
    I32 length;
d5166 1
a5166 1
    AV * const ary = DEREF_PLAIN_ARRAY(MUTABLE_AV(*++MARK));
a5178 1
	if (SvREADONLY(ary) && MARK < SP) Perl_croak_no_modify();
d5181 1
a5181 3
	    SV *sv;
	    if (*MARK) SvGETMAGIC(*MARK);
	    sv = newSV(0);
d5183 1
a5183 1
		sv_setsv_nomg(sv, *MARK);
d5216 1
a5216 1
    AV *ary = DEREF_PLAIN_ARRAY(MUTABLE_AV(*++MARK));
d5229 1
a5229 1
	I32 i = 0;
d5261 1
a5261 1
		SV *tmp = sv_newmortal();
d5268 1
a5268 1
		    SV *begin, *end;
d5273 1
a5273 1
				SV *sv = av_delete(av, j, 0);
d5280 1
a5280 1
			    SV *sv = av_delete(av, i, 0);
d5301 1
a5301 1
			SV * const tmp = *begin;
d5312 1
a5312 1
		SV * const tmp = *MARK;
d5321 3
a5323 3
	char *up;
	char *down;
	I32 tmp;
d5380 1
a5380 1
    IV limit = POPi;			/* note, negative is forever */
d5383 1
a5383 1
    const char *s = SvPV_const(sv, len);
d5386 4
a5389 4
    PMOP *pm;
    REGEXP *rx;
    SV *dstr;
    const char *m;
d5391 1
a5391 3
    const STRLEN slen = do_utf8
                        ? utf8_length((U8*)s, (U8*)strend)
                        : (STRLEN)(strend - s);
d5415 1
a5415 1
             (RX_EXTFLAGS(rx) & (RXf_WHITE | RXf_SKIPWHITE)));
d5430 1
a5430 1
    if (ary) {
d5446 1
a5446 1
		    AvARRAY(ary)[i] = &PL_sv_undef; /* don't free mere refs */
d5457 1
a5457 1
	    while (isSPACE_utf8(s))
d5482 1
a5482 1
		while (m < strend && ! isSPACE_utf8(m) ) {
d5484 1
a5484 1
		    /* isSPACE_utf8 returns FALSE for malform utf8 */
d5491 1
a5491 2
	    else if (get_regex_charset(RX_EXTFLAGS(rx)) == REGEX_LOCALE_CHARSET)
            {
d5521 1
a5521 1
		while (s < strend && isSPACE_utf8(s) )
d5524 1
a5524 2
	    else if (get_regex_charset(RX_EXTFLAGS(rx)) == REGEX_LOCALE_CHARSET)
            {
d5636 1
a5636 1
					 (do_utf8 ? SVf_UTF8 : 0) | make_mortal);
d5660 1
a5660 1
					 (do_utf8 ? SVf_UTF8 : 0) | make_mortal);
d5678 2
a5679 2
	    rex_return = CALLREGEXEC(rx, (char*)s, (char*)strend, (char*)orig, 1,
				     sv, NULL, 0);
d5684 7
a5690 3
            /* we never pass the REXEC_COPY_STR flag, so it should
             * never get copied */
            assert(!RX_MATCH_COPIED(rx));
d5857 20
d5882 1
a5882 1
    int defgv = PL_opargs[opnum] & OA_DEFGV ||opnum==OP_GLOB, whicharg = 0;
d5884 2
a5885 2
    SV **svp = at_ ? AvARRAY(at_) : NULL;
    I32 minargs = 0, maxargs = 0, numargs = at_ ? AvFILLp(at_)+1 : 0;
d5907 1
a5907 1
	   opnum ? PL_op_desc[opnum] : SvPV_nolen_const(cSVOP_sv)
a5934 1
	  try_defsv:
d5936 8
d5945 1
a5945 2
		    find_runcv_where(FIND_RUNCV_level_eq, 1, NULL),
		    cxstack[cxstack_ix].blk_oldcop->cop_seq
d5982 1
a5982 2
	  if (!numargs) goto try_defsv;
	  else {
d5991 1
a5991 2
	           : opnum == OP_LOCK || opnum == OP_UNDEF
	                              ? SVt_PVCV
d5998 1
a5998 1
		  whicharg, PL_op_name[opnum],
d6001 1
a6001 1
		    : opnum == OP_LOCK || opnum == OP_UNDEF
d6006 1
a6006 9
	    if (opnum == OP_UNDEF && SvRV(*svp) == (SV *)PL_defgv
	     && cxstack[cxstack_ix].cx_type & CXp_HASARGS) {
		/* Undo @@_ localisation, so that sub exit does not undo
		   part of our undeffing. */
		PERL_CONTEXT *cx = &cxstack[cxstack_ix];
		POP_SAVEARRAY();
		cx->cx_type &= ~ CXp_HASARGS;
		assert(!AvREAL(cx->blk_sub.argarray));
	    }
a6007 1
	  break;
d6022 7
a6028 1
	cv = find_runcv_where(FIND_RUNCV_level_eq, 1, NULL);
d6040 1
a6040 1
 * indent-tabs-mode: nil
d6043 1
a6043 1
 * ex: set ts=8 sts=4 sw=4 et:
@


1.1.1.16
log
@Import perl-5.20.1
@
text
@a49 3
static const STRLEN small_mu_len = sizeof(GREEK_SMALL_LETTER_MU_UTF8) - 1;
static const STRLEN capital_iota_len = sizeof(GREEK_CAPITAL_LETTER_IOTA_UTF8) - 1;

d68 2
a69 2
    if (UNLIKELY( PL_op->op_private & OPpLVAL_INTRO ))
	if (LIKELY( !(PL_op->op_private & OPpPAD_STATE) ))
d88 1
a88 1
	const Size_t maxarg = AvFILL(MUTABLE_AV(TARG)) + 1;
d91 2
a92 2
	    Size_t i;
	    for (i=0; i < maxarg; i++) {
d98 1
a98 5
	    PADOFFSET i;
	    for (i=0; i < (PADOFFSET)maxarg; i++) {
		SV * const sv = AvARRAY((const AV *)TARG)[i];
		SP[i+1] = sv ? sv : &PL_sv_undef;
	    }
d104 1
a104 1
	const SSize_t maxarg = AvFILL(MUTABLE_AV(TARG)) + 1;
d118 2
a119 2
    if (UNLIKELY( PL_op->op_private & OPpLVAL_INTRO ))
	if (LIKELY( !(PL_op->op_private & OPpPAD_STATE) ))
a236 2
			HV *stash = CopSTASH(PL_curcop);
			if (SvTYPE(stash) != SVt_PVHV) stash = NULL;
d238 1
a238 1
			gv_init_sv(gv, stash, namesv, 0);
d436 3
a438 2
	    const MAGIC * const mg = mg_find_mglob(sv);
	    if (mg && mg->mg_len != -1) {
d440 4
a443 4
		STRLEN i = mg->mg_len;
		if (mg->mg_flags & MGf_BYTES && DO_UTF8(sv))
		    i = sv_pos_b2u_flags(sv, i, SV_GMAGIC|SV_CONST_RETURN);
		PUSHu(i);
d446 2
a447 1
	    RETPUSHUNDEF;
d489 6
a494 3
	    if (!code)
		DIE(aTHX_ "Can't find an opnumber for \"%"UTF8f"\"",
		   UTF8fARG(SvFLAGS(TOPs) & SVf_UTF8, SvCUR(TOPs)-6, s+6));
d570 1
a570 2
    else if (SvPADTMP(sv)) {
        assert(!IS_PADGV(sv));
a571 1
    }
d588 4
a591 2
    SvGETMAGIC(sv);
    if (!SvROK(sv))
a604 1
    {
a606 3
	if (SvTYPE(stash) != SVt_PVHV)
	    Perl_croak(aTHX_ "Attempt to bless into a freed package");
    }
d613 1
a613 4
	SvGETMAGIC(ssv);
	if (SvROK(ssv)) {
	  if (!SvAMAGIC(ssv)) {
	   frog:
d615 1
a615 8
	  }
	  /* SvAMAGIC is on here, but it only means potentially overloaded,
	     so after stringification: */
	  ptr = SvPV_nomg_const(ssv,len);
	  /* We need to check the flag again: */
	  if (!SvAMAGIC(ssv)) goto frog;
	}
	else ptr = SvPV_nomg_const(ssv,len);
a1010 1
	    SvREFCNT_inc_simple_void_NN(sv_2mortal(sv));
a1013 1
#ifndef PERL_DONT_CREATE_GVSV
a1014 1
#endif
a1657 1
	const U8 mod = PL_op->op_flags & OPf_MOD;
d1690 1
a1690 5
                if (*SP) {
                   if (mod && SvPADTMP(*SP)) {
                       assert(!IS_PADGV(*SP));
                       *SP = sv_mortalcopy(*SP);
                   }
a1691 1
		}
d2311 3
a2313 2
	sv_copypv_nomg(TARG, sv);
	tmps = (U8*)SvPV_nomg(TARG, len);
d2705 4
a3308 1
        len = UTF8SKIP(s);  /* Should be well-formed; so this is its length */
d3312 3
a3314 3
    XPUSHu(DO_UTF8(argsv)
           ? utf8n_to_uvchr(s, len, 0, UTF8_ALLOW_ANYUV)
           : (UV)(*s));
d3438 9
d3472 1
d3474 9
a3482 1
    s = (const U8*)SvPV_const(source, slen);
d3487 1
a3487 4
    inplace = !SvREADONLY(source)
	   && (  SvPADTMP(source)
	      || (  SvTEMP(source) && !SvSMAGICAL(source)
		 && SvREFCNT(source) == 1));
d3501 2
a3502 1
	    _to_utf8_title_flags(s, tmpbuf, &tculen, IN_LOCALE_RUNTIME);
d3505 2
a3506 1
	    _to_utf8_lower_flags(s, tmpbuf, &tculen, IN_LOCALE_RUNTIME);
d3529 3
a3531 7
            if (IN_UTF8_CTYPE_LOCALE) {
                goto do_uni_rules;
            }

            *tmpbuf = (U8) toUPPER_LC(*s); /* This would be a bug if any
                                              locales have upper and title case
                                              different */
d3538 2
a3539 8
        else {
            /* Here, is ucfirst non-UTF-8, not in locale (unless that locale is
             * UTF-8, which we treat as not in locale), and cased latin1 */
	    UV title_ord;

      do_uni_rules:

	    title_ord = _to_upper_title_latin1(*s, tmpbuf, &tculen, 's');
d3640 4
d3647 4
d3669 1
a3669 1
	if (SvUTF8(source) && ! IN_BYTES)
a3677 4
    if (IN_LOCALE_RUNTIME) {
        TAINT;
        SvTAINTED_on(dest);
    }
d3700 11
a3710 19
    if ((SvPADTMP(source)
	 ||
	(SvTEMP(source) && !SvSMAGICAL(source) && SvREFCNT(source) == 1))
	&& !SvREADONLY(source) && SvPOK(source)
	&& !DO_UTF8(source)
	&& ((IN_LOCALE_RUNTIME)
            ? ! IN_UTF8_CTYPE_LOCALE
            : ! IN_UNI_8_BIT))
    {

        /* We can convert in place.  The reason we can't if in UNI_8_BIT is to
         * make the loop tight, so we overwrite the source with the dest before
         * looking at it, and we need to look at the original source
         * afterwards.  There would also need to be code added to handle
         * switching to not in-place in midstream if we run into characters
         * that change the length.  Since being in locale overrides UNI_8_BIT,
         * that latter becomes irrelevant in the above test; instead for
         * locale, the size can't normally change, except if the locale is a
         * UTF-8 one */
d3719 15
a3733 1
	s = (const U8*)SvPV_nomg_const(source, len);
d3748 2
a3749 1
	U8 tmpbuf[UTF8_MAXBYTES_CASE+1];
d3770 4
a3773 2
		Copy(GREEK_CAPITAL_LETTER_IOTA_UTF8, d, capital_iota_len, U8);
                d += capital_iota_len;
d3781 2
a3782 3
            uv = _to_utf8_upper_flags(s, tmpbuf, &ulen, IN_LOCALE_RUNTIME);
#define GREEK_CAPITAL_LETTER_IOTA 0x0399
#define COMBINING_GREEK_YPOGEGRAMMENI 0x0345
d3808 1
a3808 2
            Copy(GREEK_CAPITAL_LETTER_IOTA_UTF8, d, capital_iota_len, U8);
            d += capital_iota_len;
d3814 4
d3827 2
a3828 3
                if (IN_UTF8_CTYPE_LOCALE) {
                    goto do_uni_rules;
                }
d3830 1
a3830 1
                    *d = (U8) toUPPER_LC(*s);
a3837 1
          do_uni_rules:
a3925 4
    if (IN_LOCALE_RUNTIME) {
        TAINT;
        SvTAINTED_on(dest);
    }
d3945 2
a3946 6
    if (   (  SvPADTMP(source)
	   || (  SvTEMP(source) && !SvSMAGICAL(source)
	      && SvREFCNT(source) == 1  )
	   )
	&& !SvREADONLY(source) && SvPOK(source)
	&& !DO_UTF8(source)) {
d3958 15
a3972 1
	s = (const U8*)SvPV_nomg_const(source, len);
d3988 1
d3994 2
a3995 1
	    _to_utf8_lower_flags(s, tmpbuf, &ulen, IN_LOCALE_RUNTIME);
d3998 1
a3998 1
	     * commit message for 86510fb15 for why there isn't any */
d4025 4
d4036 3
a4038 1
            if (IN_LOCALE_RUNTIME) {
d4041 1
a4041 1
            }
a4057 4
    if (IN_LOCALE_RUNTIME) {
        TAINT;
        SvTAINTED_on(dest);
    }
d4092 1
a4092 1
			|| _isQUOTEMETA(TWO_BYTE_UTF8_TO_NATIVE(*s, *(s + 1))))
d4150 1
a4150 1
    U8 tmpbuf[UTF8_MAXBYTES_CASE + 1];
d4182 1
d4187 1
a4187 1
            _to_utf8_fold_flags(s, tmpbuf, &ulen, flags);
d4200 4
d4206 3
d4210 2
a4211 3
            if (IN_UTF8_CTYPE_LOCALE) {
                goto do_uni_folding;
            }
d4213 1
a4213 1
                *d = (U8) toFOLD_LC(*s);
d4217 1
a4217 1
                *d = toFOLD(*s);
a4219 1
      do_uni_folding:
d4222 1
a4222 1
             * casefolding becomes 'ss'; and \x{B5} (\N{MICRO SIGN}), which
d4242 1
a4242 2
                    Copy(GREEK_SMALL_LETTER_MU_UTF8, d, small_mu_len, U8);
                    d += small_mu_len;
d4247 1
a4247 1
                        if UVCHR_IS_INVARIANT(fc) {
a4284 4
    if (IN_LOCALE_RUNTIME) {
        TAINT;
        SvTAINTED_on(dest);
    }
d4312 1
a4312 1
	    SSize_t max = -1;
d4314 1
a4314 1
		const SSize_t elem = SvIV(*svp);
d4324 1
a4324 1
	    SSize_t elem = SvIV(*MARK);
d4337 1
a4337 1
		if (!svp || !*svp)
a4356 45
PP(pp_kvaslice)
{
    dVAR; dSP; dMARK;
    AV *const av = MUTABLE_AV(POPs);
    I32 lval = (PL_op->op_flags & OPf_MOD);
    SSize_t items = SP - MARK;

    if (PL_op->op_private & OPpMAYBE_LVSUB) {
       const I32 flags = is_lvalue_sub();
       if (flags) {
           if (!(flags & OPpENTERSUB_INARGS))
               /* diag_listed_as: Can't modify %s in %s */
	       Perl_croak(aTHX_ "Can't modify index/value array slice in list assignment");
	   lval = flags;
       }
    }

    MEXTEND(SP,items);
    while (items > 1) {
	*(MARK+items*2-1) = *(MARK+items);
	items--;
    }
    items = SP-MARK;
    SP += items;

    while (++MARK <= SP) {
        SV **svp;

	svp = av_fetch(av, SvIV(*MARK), lval);
        if (lval) {
            if (!svp || !*svp || *svp == &PL_sv_undef) {
                DIE(aTHX_ PL_no_aelem, SvIV(*MARK));
            }
	    *MARK = sv_mortalcopy(*MARK);
        }
	*++MARK = svp ? *svp : &PL_sv_undef;
    }
    if (GIMME != G_ARRAY) {
	MARK = SP - items*2;
	*++MARK = items > 0 ? *SP : &PL_sv_undef;
	SP = MARK;
    }
    RETURN;
}

d4405 1
a4405 1
    if (current > av_tindex(array)) {
d4433 1
a4433 1
	PUSHi(av_tindex(array) + 1);
d4526 1
a4526 2
		    if (preeminent)
			SvREFCNT_inc_simple_void(sv); /* De-mortalize */
d4547 1
a4547 1
		    SSize_t idx = SvIV(*MARK);
d4561 1
a4561 2
			if (preeminent)
			   SvREFCNT_inc_simple_void(sv); /* De-mortalize */
d4673 1
a4673 1
    if (UNLIKELY( PL_op->op_private & OPpEXISTS_SUB )) {
d4685 1
a4685 1
    if (LIKELY( SvTYPE(hv) == SVt_PVHV )) {
a4757 49
PP(pp_kvhslice)
{
    dVAR; dSP; dMARK;
    HV * const hv = MUTABLE_HV(POPs);
    I32 lval = (PL_op->op_flags & OPf_MOD);
    SSize_t items = SP - MARK;

    if (PL_op->op_private & OPpMAYBE_LVSUB) {
       const I32 flags = is_lvalue_sub();
       if (flags) {
           if (!(flags & OPpENTERSUB_INARGS))
               /* diag_listed_as: Can't modify %s in %s */
	       Perl_croak(aTHX_ "Can't modify key/value hash slice in list assignment");
	   lval = flags;
       }
    }

    MEXTEND(SP,items);
    while (items > 1) {
	*(MARK+items*2-1) = *(MARK+items);
	items--;
    }
    items = SP-MARK;
    SP += items;

    while (++MARK <= SP) {
        SV * const keysv = *MARK;
        SV **svp;
        HE *he;

        he = hv_fetch_ent(hv, keysv, lval, 0);
        svp = he ? &HeVAL(he) : NULL;

        if (lval) {
            if (!svp || !*svp || *svp == &PL_sv_undef) {
                DIE(aTHX_ PL_no_helem_sv, SVfARG(keysv));
            }
	    *MARK = sv_mortalcopy(*MARK);
        }
        *++MARK = svp && *svp ? *svp : &PL_sv_undef;
    }
    if (GIMME != G_ARRAY) {
	MARK = SP - items*2;
	*++MARK = items > 0 ? *SP : &PL_sv_undef;
	SP = MARK;
    }
    RETURN;
}

a4781 1
    const U8 mod = PL_op->op_flags & OPf_MOD;
a4812 4
	    else if (mod && SvPADTMP(*lelem)) {
                assert(!IS_PADGV(*lelem));
		*lelem = firstrelem[ix] = sv_mortalcopy(*lelem);
            }
d4824 1
a4824 1
    dVAR; dSP; dMARK;
d4827 1
a4827 1
    SP = MARK;
d4836 1
a4836 4
    HV* const hv = newHV();
    SV* const retval = sv_2mortal( PL_op->op_flags & OPf_SPECIAL
                                    ? newRV_noinc(MUTABLE_SV(hv))
                                    : MUTABLE_SV(hv) );
d4857 3
a4859 1
    XPUSHs(retval);
d4900 6
a4905 6
    SSize_t i;
    SSize_t offset;
    SSize_t length;
    SSize_t newlen;
    SSize_t after;
    SSize_t diff;
d4909 1
a4909 1
	return Perl_tied_method(aTHX_ SV_CONST(SPLICE), mark - 1, MUTABLE_SV(ary), mg,
a4971 1
	    const bool real = cBOOL(AvREAL(ary));
d4973 2
a4974 1
	    if (real)
d4976 1
a4976 3
	    for (i = 0, dst = MARK; i < length; i++) {
		if ((*dst = AvARRAY(ary)[i+offset])) {
		  if (real)
d4978 1
a4979 3
		else
		    *dst = &PL_sv_undef;
		dst++;
d5017 1
a5017 1
	    dst[--i] = NULL;
d5065 2
a5066 2
		const bool real = cBOOL(AvREAL(ary));
		if (real)
d5068 1
a5068 3
		for (i = 0, dst = MARK; i < length; i++) {
		    if ((*dst = tmparyval[i])) {
		      if (real)
d5070 1
a5071 2
		    else *dst = &PL_sv_undef;
		    dst++;
d5107 1
a5107 1
	call_sv(SV_CONST(PUSH),G_SCALAR|G_DISCARD|G_METHOD_NAMED);
d5160 1
a5160 1
	call_sv(SV_CONST(UNSHIFT),G_SCALAR|G_DISCARD|G_METHOD_NAMED);
d5165 1
a5165 1
	SSize_t i = 0;
d5196 1
a5196 1
		SSize_t i, j;
d5203 1
a5203 1
		for (i = 0, j = av_tindex(av); i < j; ++i, --j) {
d5268 2
d5326 1
a5326 1
    SSize_t iters = 0;
d5330 1
a5330 1
    SSize_t maxiters = slen + 10;
d5355 2
d5556 1
a5556 1
             && !(RX_EXTFLAGS(rx) & RXf_IS_ANCHORED)) {
d5720 1
a5720 1
	    call_sv(SV_CONST(PUSH),G_SCALAR|G_DISCARD|G_METHOD_NAMED);
d5724 1
a5724 1
		SSize_t i;
d5886 1
a5886 1
		    constr, cBOOL(CopHINTS_get(PL_curcop) & HINT_STRICT_REFS),
d5908 1
@


