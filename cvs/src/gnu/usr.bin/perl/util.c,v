head	1.28;
access;
symbols
	OPENBSD_6_2:1.28.0.2
	OPENBSD_6_2_BASE:1.28
	PERL_5_24_2:1.1.1.18
	OPENBSD_6_1:1.26.0.4
	OPENBSD_6_1_BASE:1.26
	OPENBSD_6_0:1.24.0.4
	OPENBSD_6_0_BASE:1.24
	OPENBSD_5_9:1.23.0.2
	OPENBSD_5_9_BASE:1.23
	OPENBSD_5_8:1.23.0.4
	OPENBSD_5_8_BASE:1.23
	PERL_5_20_2:1.1.1.17
	OPENBSD_5_7:1.21.0.2
	OPENBSD_5_7_BASE:1.21
	PERL_5_20_1:1.1.1.16
	OPENBSD_5_6:1.19.0.4
	OPENBSD_5_6_BASE:1.19
	PERL_5_18_2:1.1.1.15
	PERL:1.1.1
	OPENBSD_5_5:1.17.0.6
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.17.0.2
	OPENBSD_5_4_BASE:1.17
	PERL_5_16_3:1.1.1.14
	OPENBSD_5_3:1.15.0.2
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.14.0.8
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.6
	OPENBSD_5_0:1.14.0.4
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.2
	OPENBSD_4_9_BASE:1.14
	PERL_5_12_2:1.1.1.13
	OPENBSD_4_8:1.13.0.4
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.2
	OPENBSD_4_7_BASE:1.13
	PERL_5_10_1:1.1.1.12
	OPENBSD_4_6:1.12.0.6
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.2
	OPENBSD_4_5_BASE:1.12
	PERL_5_10_0:1.1.1.11
	OPENBSD_4_4:1.11.0.10
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.8
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.6
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.4
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.2
	OPENBSD_4_0_BASE:1.11
	PERL_5_8_8:1.1.1.10
	OPENBSD_3_9:1.10.0.6
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.4
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.2
	OPENBSD_3_7_BASE:1.10
	PERL_5_8_6:1.1.1.9
	OPENBSD_3_6:1.9.0.2
	OPENBSD_3_6_BASE:1.9
	PERL_5_8_5:1.1.1.8
	PERL_5_8_3:1.1.1.7
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.28
date	2017.08.14.13.49.43;	author afresh1;	state Exp;
branches;
next	1.27;
commitid	AOpGtCFzbfdujI88;

1.27
date	2017.08.14.13.48.45;	author afresh1;	state Exp;
branches;
next	1.26;
commitid	CrMEpTqBUsxCMTjx;

1.26
date	2017.02.05.00.33.38;	author afresh1;	state Exp;
branches;
next	1.25;
commitid	7JLVNm1wwPgqSqTa;

1.25
date	2017.02.05.00.31.54;	author afresh1;	state Exp;
branches;
next	1.24;
commitid	cxJ08BvJA9Pt2PTM;

1.24
date	2016.07.03.01.07.49;	author afresh1;	state Exp;
branches;
next	1.23;
commitid	GzHqjSTnBjdF7Wcw;

1.23
date	2015.04.25.19.26.15;	author afresh1;	state Exp;
branches;
next	1.22;
commitid	3qGYFVvfrExB70FB;

1.22
date	2015.04.25.19.14.38;	author afresh1;	state Exp;
branches;
next	1.21;
commitid	XRK22kO4se3v2i2I;

1.21
date	2014.11.17.21.00.55;	author afresh1;	state Exp;
branches;
next	1.20;
commitid	LnErp1MFKSuew5Fr;

1.20
date	2014.11.17.20.56.48;	author afresh1;	state Exp;
branches;
next	1.19;
commitid	QP75iYx42Uo7mMxO;

1.19
date	2014.05.29.04.57.47;	author guenther;	state Exp;
branches;
next	1.18;

1.18
date	2014.03.24.15.05.13;	author afresh1;	state Exp;
branches;
next	1.17;

1.17
date	2013.07.13.10.21.54;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2013.03.25.20.40.45;	author sthen;	state Exp;
branches;
next	1.15;

1.15
date	2012.10.26.18.56.49;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2010.09.24.15.06.43;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2009.10.12.18.24.22;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2008.09.29.17.36.00;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2006.03.28.19.22.59;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2005.01.15.21.30.23;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2004.08.09.18.08.57;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2004.04.07.21.33.01;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.23;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.19;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.35.00;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.04.31;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.51.13;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.49.25;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.11.51;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.11.51;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.38.07;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.08.50;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.22.27;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.14.52;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.43.39;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.04.07.21.12.57;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.08.09.17.45.51;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2005.01.15.21.16.39;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2006.03.28.18.47.48;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2008.09.29.17.18.10;	author millert;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2009.10.12.18.10.33;	author millert;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2010.09.24.14.48.17;	author millert;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2013.03.25.20.06.43;	author sthen;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	2014.03.24.14.58.48;	author afresh1;	state Exp;
branches;
next	1.1.1.16;

1.1.1.16
date	2014.11.17.20.52.40;	author afresh1;	state Exp;
branches;
next	1.1.1.17;
commitid	B31cAbBIXiCqnL97;

1.1.1.17
date	2015.04.25.19.10.15;	author afresh1;	state Exp;
branches;
next	1.1.1.18;
commitid	Wpcs5S8qILgEZC7F;

1.1.1.18
date	2017.08.14.13.45.31;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.28
log
@Apply local patches - perl-5.24.2

OK bluhm@@, Reads ok sthen@@
@
text
@/*    util.c
 *
 *    Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
 *    2002, 2003, 2004, 2005, 2006, 2007, 2008 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

/*
 * 'Very useful, no doubt, that was to Saruman; yet it seems that he was
 *  not content.'                                    --Gandalf to Pippin
 *
 *     [p.598 of _The Lord of the Rings_, III/xi: "The Palant√≠r"]
 */

/* This file contains assorted utility routines.
 * Which is a polite way of saying any stuff that people couldn't think of
 * a better place for. Amongst other things, it includes the warning and
 * dieing stuff, plus wrappers for malloc code.
 */

#include "EXTERN.h"
#define PERL_IN_UTIL_C
#include "perl.h"
#include "reentr.h"

#if defined(USE_PERLIO)
#include "perliol.h" /* For PerlIOUnix_refcnt */
#endif

#ifndef PERL_MICRO
#include <signal.h>
#ifndef SIG_ERR
# define SIG_ERR ((Sighandler_t) -1)
#endif
#endif

#include <math.h>
#include <stdlib.h>

#ifdef __Lynx__
/* Missing protos on LynxOS */
int putenv(char *);
#endif

#ifdef __amigaos__
# include "amigaos4/amigaio.h"
#endif

#ifdef HAS_SELECT
# ifdef I_SYS_SELECT
#  include <sys/select.h>
# endif
#endif

#ifdef USE_C_BACKTRACE
#  ifdef I_BFD
#    define USE_BFD
#    ifdef PERL_DARWIN
#      undef USE_BFD /* BFD is useless in OS X. */
#    endif
#    ifdef USE_BFD
#      include <bfd.h>
#    endif
#  endif
#  ifdef I_DLFCN
#    include <dlfcn.h>
#  endif
#  ifdef I_EXECINFO
#    include <execinfo.h>
#  endif
#endif

#ifdef PERL_DEBUG_READONLY_COW
# include <sys/mman.h>
#endif

#define FLUSH

/* NOTE:  Do not call the next three routines directly.  Use the macros
 * in handy.h, so that we can easily redefine everything to do tracking of
 * allocated hunks back to the original New to track down any memory leaks.
 * XXX This advice seems to be widely ignored :-(   --AD  August 1996.
 */

#if defined (DEBUGGING) || defined(PERL_IMPLICIT_SYS) || defined (PERL_TRACK_MEMPOOL)
#  define ALWAYS_NEED_THX
#endif

#if defined(PERL_TRACK_MEMPOOL) && defined(PERL_DEBUG_READONLY_COW)
static void
S_maybe_protect_rw(pTHX_ struct perl_memory_debug_header *header)
{
    if (header->readonly
     && mprotect(header, header->size, PROT_READ|PROT_WRITE))
	Perl_warn(aTHX_ "mprotect for COW string %p %lu failed with %d",
			 header, header->size, errno);
}

static void
S_maybe_protect_ro(pTHX_ struct perl_memory_debug_header *header)
{
    if (header->readonly
     && mprotect(header, header->size, PROT_READ))
	Perl_warn(aTHX_ "mprotect RW for COW string %p %lu failed with %d",
			 header, header->size, errno);
}
# define maybe_protect_rw(foo) S_maybe_protect_rw(aTHX_ foo)
# define maybe_protect_ro(foo) S_maybe_protect_ro(aTHX_ foo)
#else
# define maybe_protect_rw(foo) NOOP
# define maybe_protect_ro(foo) NOOP
#endif

#if defined(PERL_TRACK_MEMPOOL) || defined(PERL_DEBUG_READONLY_COW)
 /* Use memory_debug_header */
# define USE_MDH
# if (defined(PERL_POISON) && defined(PERL_TRACK_MEMPOOL)) \
   || defined(PERL_DEBUG_READONLY_COW)
#  define MDH_HAS_SIZE
# endif
#endif

/* paranoid version of system's malloc() */

Malloc_t
Perl_safesysmalloc(MEM_SIZE size)
{
#ifdef ALWAYS_NEED_THX
    dTHX;
#endif
    Malloc_t ptr;

#ifdef USE_MDH
    if (size + PERL_MEMORY_DEBUG_HEADER_SIZE < size)
        goto out_of_memory;
    size += PERL_MEMORY_DEBUG_HEADER_SIZE;
#endif
#ifdef DEBUGGING
    if ((SSize_t)size < 0)
	Perl_croak_nocontext("panic: malloc, size=%"UVuf, (UV) size);
#endif
    if (!size) size = 1;	/* malloc(0) is NASTY on our system */
#ifdef PERL_DEBUG_READONLY_COW
    if ((ptr = mmap(0, size, PROT_READ|PROT_WRITE,
		    MAP_ANON|MAP_PRIVATE, -1, 0)) == MAP_FAILED) {
	perror("mmap failed");
	abort();
    }
#else
    ptr = (Malloc_t)PerlMem_malloc(size?size:1);
#endif
    PERL_ALLOC_CHECK(ptr);
    if (ptr != NULL) {
#ifdef USE_MDH
	struct perl_memory_debug_header *const header
	    = (struct perl_memory_debug_header *)ptr;
#endif

#ifdef PERL_POISON
	PoisonNew(((char *)ptr), size, char);
#endif

#ifdef PERL_TRACK_MEMPOOL
	header->interpreter = aTHX;
	/* Link us into the list.  */
	header->prev = &PL_memory_debug_header;
	header->next = PL_memory_debug_header.next;
	PL_memory_debug_header.next = header;
	maybe_protect_rw(header->next);
	header->next->prev = header;
	maybe_protect_ro(header->next);
#  ifdef PERL_DEBUG_READONLY_COW
	header->readonly = 0;
#  endif
#endif
#ifdef MDH_HAS_SIZE
	header->size = size;
#endif
	ptr = (Malloc_t)((char*)ptr+PERL_MEMORY_DEBUG_HEADER_SIZE);
	DEBUG_m(PerlIO_printf(Perl_debug_log, "0x%"UVxf": (%05ld) malloc %ld bytes\n",PTR2UV(ptr),(long)PL_an++,(long)size));

    }
    else {
#ifdef USE_MDH
      out_of_memory:
#endif
        {
#ifndef ALWAYS_NEED_THX
            dTHX;
#endif
            if (PL_nomemok)
                ptr =  NULL;
            else
                croak_no_mem();
        }
    }
    return ptr;
}

/* paranoid version of system's realloc() */

Malloc_t
Perl_safesysrealloc(Malloc_t where,MEM_SIZE size)
{
#ifdef ALWAYS_NEED_THX
    dTHX;
#endif
    Malloc_t ptr;
#ifdef PERL_DEBUG_READONLY_COW
    const MEM_SIZE oldsize = where
	? ((struct perl_memory_debug_header *)((char *)where - PERL_MEMORY_DEBUG_HEADER_SIZE))->size
	: 0;
#endif
#if !defined(STANDARD_C) && !defined(HAS_REALLOC_PROTOTYPE) && !defined(PERL_MICRO)
    Malloc_t PerlMem_realloc();
#endif /* !defined(STANDARD_C) && !defined(HAS_REALLOC_PROTOTYPE) */

    if (!size) {
	safesysfree(where);
	ptr = NULL;
    }
    else if (!where) {
	ptr = safesysmalloc(size);
    }
    else {
#ifdef USE_MDH
	where = (Malloc_t)((char*)where-PERL_MEMORY_DEBUG_HEADER_SIZE);
        if (size + PERL_MEMORY_DEBUG_HEADER_SIZE < size)
            goto out_of_memory;
	size += PERL_MEMORY_DEBUG_HEADER_SIZE;
	{
	    struct perl_memory_debug_header *const header
		= (struct perl_memory_debug_header *)where;

# ifdef PERL_TRACK_MEMPOOL
	    if (header->interpreter != aTHX) {
		Perl_croak_nocontext("panic: realloc from wrong pool, %p!=%p",
				     header->interpreter, aTHX);
	    }
	    assert(header->next->prev == header);
	    assert(header->prev->next == header);
#  ifdef PERL_POISON
	    if (header->size > size) {
		const MEM_SIZE freed_up = header->size - size;
		char *start_of_freed = ((char *)where) + size;
		PoisonFree(start_of_freed, freed_up, char);
	    }
#  endif
# endif
# ifdef MDH_HAS_SIZE
	    header->size = size;
# endif
	}
#endif
#ifdef DEBUGGING
	if ((SSize_t)size < 0)
	    Perl_croak_nocontext("panic: realloc, size=%"UVuf, (UV)size);
#endif
#ifdef PERL_DEBUG_READONLY_COW
	if ((ptr = mmap(0, size, PROT_READ|PROT_WRITE,
			MAP_ANON|MAP_PRIVATE, -1, 0)) == MAP_FAILED) {
	    perror("mmap failed");
	    abort();
	}
	Copy(where,ptr,oldsize < size ? oldsize : size,char);
	if (munmap(where, oldsize)) {
	    perror("munmap failed");
	    abort();
	}
#else
	ptr = (Malloc_t)PerlMem_realloc(where,size);
#endif
	PERL_ALLOC_CHECK(ptr);

    /* MUST do this fixup first, before doing ANYTHING else, as anything else
       might allocate memory/free/move memory, and until we do the fixup, it
       may well be chasing (and writing to) free memory.  */
	if (ptr != NULL) {
#ifdef PERL_TRACK_MEMPOOL
	    struct perl_memory_debug_header *const header
		= (struct perl_memory_debug_header *)ptr;

#  ifdef PERL_POISON
	    if (header->size < size) {
		const MEM_SIZE fresh = size - header->size;
		char *start_of_fresh = ((char *)ptr) + size;
		PoisonNew(start_of_fresh, fresh, char);
	    }
#  endif

	    maybe_protect_rw(header->next);
	    header->next->prev = header;
	    maybe_protect_ro(header->next);
	    maybe_protect_rw(header->prev);
	    header->prev->next = header;
	    maybe_protect_ro(header->prev);
#endif
	    ptr = (Malloc_t)((char*)ptr+PERL_MEMORY_DEBUG_HEADER_SIZE);
	}

    /* In particular, must do that fixup above before logging anything via
     *printf(), as it can reallocate memory, which can cause SEGVs.  */

	DEBUG_m(PerlIO_printf(Perl_debug_log, "0x%"UVxf": (%05ld) rfree\n",PTR2UV(where),(long)PL_an++));
	DEBUG_m(PerlIO_printf(Perl_debug_log, "0x%"UVxf": (%05ld) realloc %ld bytes\n",PTR2UV(ptr),(long)PL_an++,(long)size));

	if (ptr == NULL) {
#ifdef USE_MDH
          out_of_memory:
#endif
            {
#ifndef ALWAYS_NEED_THX
                dTHX;
#endif
                if (PL_nomemok)
                    ptr = NULL;
                else
                    croak_no_mem();
            }
	}
    }
    return ptr;
}

/* safe version of system's free() */

Free_t
Perl_safesysfree(Malloc_t where)
{
#ifdef ALWAYS_NEED_THX
    dTHX;
#endif
    DEBUG_m( PerlIO_printf(Perl_debug_log, "0x%"UVxf": (%05ld) free\n",PTR2UV(where),(long)PL_an++));
    if (where) {
#ifdef USE_MDH
	Malloc_t where_intrn = (Malloc_t)((char*)where-PERL_MEMORY_DEBUG_HEADER_SIZE);
	{
	    struct perl_memory_debug_header *const header
		= (struct perl_memory_debug_header *)where_intrn;

# ifdef MDH_HAS_SIZE
	    const MEM_SIZE size = header->size;
# endif
# ifdef PERL_TRACK_MEMPOOL
	    if (header->interpreter != aTHX) {
		Perl_croak_nocontext("panic: free from wrong pool, %p!=%p",
				     header->interpreter, aTHX);
	    }
	    if (!header->prev) {
		Perl_croak_nocontext("panic: duplicate free");
	    }
	    if (!(header->next))
		Perl_croak_nocontext("panic: bad free, header->next==NULL");
	    if (header->next->prev != header || header->prev->next != header) {
		Perl_croak_nocontext("panic: bad free, ->next->prev=%p, "
				     "header=%p, ->prev->next=%p",
				     header->next->prev, header,
				     header->prev->next);
	    }
	    /* Unlink us from the chain.  */
	    maybe_protect_rw(header->next);
	    header->next->prev = header->prev;
	    maybe_protect_ro(header->next);
	    maybe_protect_rw(header->prev);
	    header->prev->next = header->next;
	    maybe_protect_ro(header->prev);
	    maybe_protect_rw(header);
#  ifdef PERL_POISON
	    PoisonNew(where_intrn, size, char);
#  endif
	    /* Trigger the duplicate free warning.  */
	    header->next = NULL;
# endif
# ifdef PERL_DEBUG_READONLY_COW
	    if (munmap(where_intrn, size)) {
		perror("munmap failed");
		abort();
	    }	
# endif
	}
#else
	Malloc_t where_intrn = where;
#endif /* USE_MDH */
#ifndef PERL_DEBUG_READONLY_COW
	PerlMem_free(where_intrn);
#endif
    }
}

/* safe version of system's calloc() */

Malloc_t
Perl_safesyscalloc(MEM_SIZE count, MEM_SIZE size)
{
#ifdef ALWAYS_NEED_THX
    dTHX;
#endif
    Malloc_t ptr;
#if defined(USE_MDH) || defined(DEBUGGING)
    MEM_SIZE total_size = 0;
#endif

    /* Even though calloc() for zero bytes is strange, be robust. */
    if (size && (count <= MEM_SIZE_MAX / size)) {
#if defined(USE_MDH) || defined(DEBUGGING)
	total_size = size * count;
#endif
    }
    else
	croak_memory_wrap();
#ifdef USE_MDH
    if (PERL_MEMORY_DEBUG_HEADER_SIZE <= MEM_SIZE_MAX - (MEM_SIZE)total_size)
	total_size += PERL_MEMORY_DEBUG_HEADER_SIZE;
    else
	croak_memory_wrap();
#endif
#ifdef DEBUGGING
    if ((SSize_t)size < 0 || (SSize_t)count < 0)
	Perl_croak_nocontext("panic: calloc, size=%"UVuf", count=%"UVuf,
			     (UV)size, (UV)count);
#endif
#ifdef PERL_DEBUG_READONLY_COW
    if ((ptr = mmap(0, total_size ? total_size : 1, PROT_READ|PROT_WRITE,
		    MAP_ANON|MAP_PRIVATE, -1, 0)) == MAP_FAILED) {
	perror("mmap failed");
	abort();
    }
#elif defined(PERL_TRACK_MEMPOOL)
    /* Have to use malloc() because we've added some space for our tracking
       header.  */
    /* malloc(0) is non-portable. */
    ptr = (Malloc_t)PerlMem_malloc(total_size ? total_size : 1);
#else
    /* Use calloc() because it might save a memset() if the memory is fresh
       and clean from the OS.  */
    if (count && size)
	ptr = (Malloc_t)PerlMem_calloc(count, size);
    else /* calloc(0) is non-portable. */
	ptr = (Malloc_t)PerlMem_calloc(count ? count : 1, size ? size : 1);
#endif
    PERL_ALLOC_CHECK(ptr);
    DEBUG_m(PerlIO_printf(Perl_debug_log, "0x%"UVxf": (%05ld) calloc %ld x %ld bytes\n",PTR2UV(ptr),(long)PL_an++,(long)count,(long)total_size));
    if (ptr != NULL) {
#ifdef USE_MDH
	{
	    struct perl_memory_debug_header *const header
		= (struct perl_memory_debug_header *)ptr;

#  ifndef PERL_DEBUG_READONLY_COW
	    memset((void*)ptr, 0, total_size);
#  endif
#  ifdef PERL_TRACK_MEMPOOL
	    header->interpreter = aTHX;
	    /* Link us into the list.  */
	    header->prev = &PL_memory_debug_header;
	    header->next = PL_memory_debug_header.next;
	    PL_memory_debug_header.next = header;
	    maybe_protect_rw(header->next);
	    header->next->prev = header;
	    maybe_protect_ro(header->next);
#    ifdef PERL_DEBUG_READONLY_COW
	    header->readonly = 0;
#    endif
#  endif
#  ifdef MDH_HAS_SIZE
	    header->size = total_size;
#  endif
	    ptr = (Malloc_t)((char*)ptr+PERL_MEMORY_DEBUG_HEADER_SIZE);
	}
#endif
	return ptr;
    }
    else {
#ifndef ALWAYS_NEED_THX
	dTHX;
#endif
	if (PL_nomemok)
	    return NULL;
	croak_no_mem();
    }
}

/* These must be defined when not using Perl's malloc for binary
 * compatibility */

#ifndef MYMALLOC

Malloc_t Perl_malloc (MEM_SIZE nbytes)
{
#ifdef PERL_IMPLICIT_SYS
    dTHX;
#endif
    return (Malloc_t)PerlMem_malloc(nbytes);
}

Malloc_t Perl_calloc (MEM_SIZE elements, MEM_SIZE size)
{
#ifdef PERL_IMPLICIT_SYS
    dTHX;
#endif
    return (Malloc_t)PerlMem_calloc(elements, size);
}

Malloc_t Perl_realloc (Malloc_t where, MEM_SIZE nbytes)
{
#ifdef PERL_IMPLICIT_SYS
    dTHX;
#endif
    return (Malloc_t)PerlMem_realloc(where, nbytes);
}

Free_t   Perl_mfree (Malloc_t where)
{
#ifdef PERL_IMPLICIT_SYS
    dTHX;
#endif
    PerlMem_free(where);
}

#endif

/* copy a string up to some (non-backslashed) delimiter, if any */

static char *
S_delimcpy(char *to, const char *toend, const char *from,
	   const char *fromend, int delim, I32 *retlen,
	   const bool allow_escape)
{
    I32 tolen;

    PERL_ARGS_ASSERT_DELIMCPY;

    for (tolen = 0; from < fromend; from++, tolen++) {
	if (allow_escape && *from == '\\') {
	    if (from[1] != delim) {
		if (to < toend)
		    *to++ = *from;
		tolen++;
	    }
	    from++;
	}
	else if (*from == delim)
	    break;
	if (to < toend)
	    *to++ = *from;
    }
    if (to < toend)
	*to = '\0';
    *retlen = tolen;
    return (char *)from;
}

char *
Perl_delimcpy(char *to, const char *toend, const char *from, const char *fromend, int delim, I32 *retlen)
{
    PERL_ARGS_ASSERT_DELIMCPY;

    return S_delimcpy(to, toend, from, fromend, delim, retlen, 1);
}

char *
Perl_delimcpy_no_escape(char *to, const char *toend, const char *from,
			const char *fromend, int delim, I32 *retlen)
{
    PERL_ARGS_ASSERT_DELIMCPY_NO_ESCAPE;

    return S_delimcpy(to, toend, from, fromend, delim, retlen, 0);
}

/* return ptr to little string in big string, NULL if not found */
/* This routine was donated by Corey Satten. */

char *
Perl_instr(const char *big, const char *little)
{

    PERL_ARGS_ASSERT_INSTR;

    return strstr((char*)big, (char*)little);
}

/*
=head1 Miscellaneous Functions

=for apidoc Am|char *|ninstr|char * big|char * bigend|char * little|char * little_end

Find the first (leftmost) occurrence of a sequence of bytes within another
sequence.  This is the Perl version of C<strstr()>, extended to handle
arbitrary sequences, potentially containing embedded C<NUL> characters (C<NUL>
is what the initial C<n> in the function name stands for; some systems have an
equivalent, C<memmem()>, but with a somewhat different API).

Another way of thinking about this function is finding a needle in a haystack.
C<big> points to the first byte in the haystack.  C<big_end> points to one byte
beyond the final byte in the haystack.  C<little> points to the first byte in
the needle.  C<little_end> points to one byte beyond the final byte in the
needle.  All the parameters must be non-C<NULL>.

The function returns C<NULL> if there is no occurrence of C<little> within
C<big>.  If C<little> is the empty string, C<big> is returned.

Because this function operates at the byte level, and because of the inherent
characteristics of UTF-8 (or UTF-EBCDIC), it will work properly if both the
needle and the haystack are strings with the same UTF-8ness, but not if the
UTF-8ness differs.

=cut

*/

char *
Perl_ninstr(const char *big, const char *bigend, const char *little, const char *lend)
{
    PERL_ARGS_ASSERT_NINSTR;
    if (little >= lend)
        return (char*)big;
    {
        const char first = *little;
        const char *s, *x;
        bigend -= lend - little++;
    OUTER:
        while (big <= bigend) {
            if (*big++ == first) {
                for (x=big,s=little; s < lend; x++,s++) {
                    if (*s != *x)
                        goto OUTER;
                }
                return (char*)(big-1);
            }
        }
    }
    return NULL;
}

/*
=head1 Miscellaneous Functions

=for apidoc Am|char *|rninstr|char * big|char * bigend|char * little|char * little_end

Like C<L</ninstr>>, but instead finds the final (rightmost) occurrence of a
sequence of bytes within another sequence, returning C<NULL> if there is no
such occurrence.

=cut

*/

char *
Perl_rninstr(const char *big, const char *bigend, const char *little, const char *lend)
{
    const char *bigbeg;
    const I32 first = *little;
    const char * const littleend = lend;

    PERL_ARGS_ASSERT_RNINSTR;

    if (little >= littleend)
	return (char*)bigend;
    bigbeg = big;
    big = bigend - (littleend - little++);
    while (big >= bigbeg) {
	const char *s, *x;
	if (*big-- != first)
	    continue;
	for (x=big+2,s=little; s < littleend; /**/ ) {
	    if (*s != *x)
		break;
	    else {
		x++;
		s++;
	    }
	}
	if (s >= littleend)
	    return (char*)(big+1);
    }
    return NULL;
}

/* As a space optimization, we do not compile tables for strings of length
   0 and 1, and for strings of length 2 unless FBMcf_TAIL.  These are
   special-cased in fbm_instr().

   If FBMcf_TAIL, the table is created as if the string has a trailing \n. */

/*
=head1 Miscellaneous Functions

=for apidoc fbm_compile

Analyses the string in order to make fast searches on it using C<fbm_instr()>
-- the Boyer-Moore algorithm.

=cut
*/

void
Perl_fbm_compile(pTHX_ SV *sv, U32 flags)
{
    const U8 *s;
    STRLEN i;
    STRLEN len;
    U32 frequency = 256;
    MAGIC *mg;
    PERL_DEB( STRLEN rarest = 0 );

    PERL_ARGS_ASSERT_FBM_COMPILE;

    if (isGV_with_GP(sv) || SvROK(sv))
	return;

    if (SvVALID(sv))
	return;

    if (flags & FBMcf_TAIL) {
	MAGIC * const mg = SvUTF8(sv) && SvMAGICAL(sv) ? mg_find(sv, PERL_MAGIC_utf8) : NULL;
	sv_catpvs(sv, "\n");		/* Taken into account in fbm_instr() */
	if (mg && mg->mg_len >= 0)
	    mg->mg_len++;
    }
    if (!SvPOK(sv) || SvNIOKp(sv))
	s = (U8*)SvPV_force_mutable(sv, len);
    else s = (U8 *)SvPV_mutable(sv, len);
    if (len == 0)		/* TAIL might be on a zero-length string. */
	return;
    SvUPGRADE(sv, SVt_PVMG);
    SvIOK_off(sv);
    SvNOK_off(sv);
    SvVALID_on(sv);

    /* "deep magic", the comment used to add. The use of MAGIC itself isn't
       really. MAGIC was originally added in 79072805bf63abe5 (perl 5.0 alpha 2)
       to call SvVALID_off() if the scalar was assigned to.

       The comment itself (and "deeper magic" below) date back to
       378cc40b38293ffc (perl 2.0). "deep magic" was an annotation on
       str->str_pok |= 2;
       where the magic (presumably) was that the scalar had a BM table hidden
       inside itself.

       As MAGIC is always present on BMs [in Perl 5 :-)], we can use it to store
       the table instead of the previous (somewhat hacky) approach of co-opting
       the string buffer and storing it after the string.  */

    assert(!mg_find(sv, PERL_MAGIC_bm));
    mg = sv_magicext(sv, NULL, PERL_MAGIC_bm, &PL_vtbl_bm, NULL, 0);
    assert(mg);

    if (len > 2) {
	/* Shorter strings are special-cased in Perl_fbm_instr(), and don't use
	   the BM table.  */
	const U8 mlen = (len>255) ? 255 : (U8)len;
	const unsigned char *const sb = s + len - mlen; /* first char (maybe) */
	U8 *table;

	Newx(table, 256, U8);
	memset((void*)table, mlen, 256);
	mg->mg_ptr = (char *)table;
	mg->mg_len = 256;

	s += len - 1; /* last char */
	i = 0;
	while (s >= sb) {
	    if (table[*s] == mlen)
		table[*s] = (U8)i;
	    s--, i++;
	}
    }

    s = (const unsigned char*)(SvPVX_const(sv));	/* deeper magic */
    for (i = 0; i < len; i++) {
	if (PL_freq[s[i]] < frequency) {
	    PERL_DEB( rarest = i );
	    frequency = PL_freq[s[i]];
	}
    }
    BmUSEFUL(sv) = 100;			/* Initial value */
    if (flags & FBMcf_TAIL)
	SvTAIL_on(sv);
    DEBUG_r(PerlIO_printf(Perl_debug_log, "rarest char %c at %"UVuf"\n",
			  s[rarest], (UV)rarest));
}


/*
=for apidoc fbm_instr

Returns the location of the SV in the string delimited by C<big> and
C<bigend> (C<bigend>) is the char following the last char).
It returns C<NULL> if the string can't be found.  The C<sv>
does not have to be C<fbm_compiled>, but the search will not be as fast
then.

=cut

If SvTAIL(littlestr) is true, a fake "\n" was appended to to the string
during FBM compilation due to FBMcf_TAIL in flags. It indicates that
the littlestr must be anchored to the end of bigstr (or to any \n if
FBMrf_MULTILINE).

E.g. The regex compiler would compile /abc/ to a littlestr of "abc",
while /abc$/ compiles to "abc\n" with SvTAIL() true.

A littlestr of "abc", !SvTAIL matches as /abc/;
a littlestr of "ab\n", SvTAIL matches as:
   without FBMrf_MULTILINE: /ab\n?\z/
   with    FBMrf_MULTILINE: /ab\n/ || /ab\z/;

(According to Ilya from 1999; I don't know if this is still true, DAPM 2015):
  "If SvTAIL is actually due to \Z or \z, this gives false positives
  if multiline".
*/


char *
Perl_fbm_instr(pTHX_ unsigned char *big, unsigned char *bigend, SV *littlestr, U32 flags)
{
    unsigned char *s;
    STRLEN l;
    const unsigned char *little = (const unsigned char *)SvPV_const(littlestr,l);
    STRLEN littlelen = l;
    const I32 multiline = flags & FBMrf_MULTILINE;

    PERL_ARGS_ASSERT_FBM_INSTR;

    if ((STRLEN)(bigend - big) < littlelen) {
	if ( SvTAIL(littlestr)
	     && ((STRLEN)(bigend - big) == littlelen - 1)
	     && (littlelen == 1
		 || (*big == *little &&
		     memEQ((char *)big, (char *)little, littlelen - 1))))
	    return (char*)big;
	return NULL;
    }

    switch (littlelen) { /* Special cases for 0, 1 and 2  */
    case 0:
	return (char*)big;		/* Cannot be SvTAIL! */

    case 1:
	    if (SvTAIL(littlestr) && !multiline) /* Anchor only! */
		/* [-1] is safe because we know that bigend != big.  */
		return (char *) (bigend - (bigend[-1] == '\n'));

	    s = (unsigned char *)memchr((void*)big, *little, bigend-big);
            if (s)
                return (char *)s;
	    if (SvTAIL(littlestr))
		return (char *) bigend;
	    return NULL;

    case 2:
	if (SvTAIL(littlestr) && !multiline) {
            /* a littlestr with SvTAIL must be of the form "X\n" (where X
             * is a single char). It is anchored, and can only match
             * "....X\n"  or  "....X" */
            if (bigend[-2] == *little && bigend[-1] == '\n')
		return (char*)bigend - 2;
	    if (bigend[-1] == *little)
		return (char*)bigend - 1;
	    return NULL;
	}

	{
            /* memchr() is likely to be very fast, possibly using whatever
             * hardware support is available, such as checking a whole
             * cache line in one instruction.
             * So for a 2 char pattern, calling memchr() is likely to be
             * faster than running FBM, or rolling our own. The previous
             * version of this code was roll-your-own which typically
             * only needed to read every 2nd char, which was good back in
             * the day, but no longer.
             */
	    unsigned char c1 = little[0];
	    unsigned char c2 = little[1];

            /* *** for all this case, bigend points to the last char,
             * not the trailing \0: this makes the conditions slightly
             * simpler */
            bigend--;
	    s = big;
            if (c1 != c2) {
                while (s < bigend) {
                    /* do a quick test for c1 before calling memchr();
                     * this avoids the expensive fn call overhead when
                     * there are lots of c1's */
                    if (LIKELY(*s != c1)) {
                        s++;
                        s = (unsigned char *)memchr((void*)s, c1, bigend - s);
                        if (!s)
                            break;
                    }
                    if (s[1] == c2)
                        return (char*)s;

                    /* failed; try searching for c2 this time; that way
                     * we don't go pathologically slow when the string
                     * consists mostly of c1's or vice versa.
                     */
                    s += 2;
                    if (s > bigend)
                        break;
                    s = (unsigned char *)memchr((void*)s, c2, bigend - s + 1);
                    if (!s)
                        break;
                    if (s[-1] == c1)
                        return (char*)s - 1;
                }
            }
            else {
                /* c1, c2 the same */
                while (s < bigend) {
                    if (s[0] == c1) {
                      got_1char:
                        if (s[1] == c1)
                            return (char*)s;
                        s += 2;
                    }
                    else {
                        s++;
                        s = (unsigned char *)memchr((void*)s, c1, bigend - s);
                        if (!s || s >= bigend)
                            break;
                        goto got_1char;
                    }
                }
            }

            /* failed to find 2 chars; try anchored match at end without
             * the \n */
            if (SvTAIL(littlestr) && bigend[0] == little[0])
                return (char *)bigend;
            return NULL;
        }

    default:
	break; /* Only lengths 0 1 and 2 have special-case code.  */
    }

    if (SvTAIL(littlestr) && !multiline) {	/* tail anchored? */
	s = bigend - littlelen;
	if (s >= big && bigend[-1] == '\n' && *s == *little
	    /* Automatically of length > 2 */
	    && memEQ((char*)s + 1, (char*)little + 1, littlelen - 2))
	{
	    return (char*)s;		/* how sweet it is */
	}
	if (s[1] == *little
	    && memEQ((char*)s + 2, (char*)little + 1, littlelen - 2))
	{
	    return (char*)s + 1;	/* how sweet it is */
	}
	return NULL;
    }

    if (!SvVALID(littlestr)) {
        /* not compiled; use Perl_ninstr() instead */
	char * const b = ninstr((char*)big,(char*)bigend,
			 (char*)little, (char*)little + littlelen);

	if (!b && SvTAIL(littlestr)) {	/* Automatically multiline!  */
	    /* Chop \n from littlestr: */
	    s = bigend - littlelen + 1;
	    if (*s == *little
		&& memEQ((char*)s + 1, (char*)little + 1, littlelen - 2))
	    {
		return (char*)s;
	    }
	    return NULL;
	}
	return b;
    }

    /* Do actual FBM.  */
    if (littlelen > (STRLEN)(bigend - big))
	return NULL;

    {
	const MAGIC *const mg = mg_find(littlestr, PERL_MAGIC_bm);
	const unsigned char *oldlittle;

	assert(mg);

	--littlelen;			/* Last char found by table lookup */

	s = big + littlelen;
	little += littlelen;		/* last char */
	oldlittle = little;
	if (s < bigend) {
	    const unsigned char * const table = (const unsigned char *) mg->mg_ptr;
            const unsigned char lastc = *little;
	    I32 tmp;

	  top2:
	    if ((tmp = table[*s])) {
                /* *s != lastc; earliest position it could match now is
                 * tmp slots further on */
		if ((s += tmp) >= bigend)
                    goto check_end;
                if (LIKELY(*s != lastc)) {
                    s++;
                    s = (unsigned char *)memchr((void*)s, lastc, bigend - s);
                    if (!s) {
                        s = bigend;
                        goto check_end;
                    }
                    goto top2;
                }
	    }


            /* hand-rolled strncmp(): less expensive than calling the
             * real function (maybe???) */
	    {
		unsigned char * const olds = s;

		tmp = littlelen;

		while (tmp--) {
		    if (*--s == *--little)
			continue;
		    s = olds + 1;	/* here we pay the price for failure */
		    little = oldlittle;
		    if (s < bigend)	/* fake up continue to outer loop */
			goto top2;
		    goto check_end;
		}
		return (char *)s;
	    }
	}
      check_end:
	if ( s == bigend
	     && SvTAIL(littlestr)
	     && memEQ((char *)(bigend - littlelen),
		      (char *)(oldlittle - littlelen), littlelen) )
	    return (char*)bigend - littlelen;
	return NULL;
    }
}


/*
=for apidoc foldEQ

Returns true if the leading C<len> bytes of the strings C<s1> and C<s2> are the
same
case-insensitively; false otherwise.  Uppercase and lowercase ASCII range bytes
match themselves and their opposite case counterparts.  Non-cased and non-ASCII
range bytes match only themselves.

=cut
*/


I32
Perl_foldEQ(const char *s1, const char *s2, I32 len)
{
    const U8 *a = (const U8 *)s1;
    const U8 *b = (const U8 *)s2;

    PERL_ARGS_ASSERT_FOLDEQ;

    assert(len >= 0);

    while (len--) {
	if (*a != *b && *a != PL_fold[*b])
	    return 0;
	a++,b++;
    }
    return 1;
}
I32
Perl_foldEQ_latin1(const char *s1, const char *s2, I32 len)
{
    /* Compare non-utf8 using Unicode (Latin1) semantics.  Does not work on
     * MICRO_SIGN, LATIN_SMALL_LETTER_SHARP_S, nor
     * LATIN_SMALL_LETTER_Y_WITH_DIAERESIS, and does not check for these.  Nor
     * does it check that the strings each have at least 'len' characters */

    const U8 *a = (const U8 *)s1;
    const U8 *b = (const U8 *)s2;

    PERL_ARGS_ASSERT_FOLDEQ_LATIN1;

    assert(len >= 0);

    while (len--) {
	if (*a != *b && *a != PL_fold_latin1[*b]) {
	    return 0;
	}
	a++, b++;
    }
    return 1;
}

/*
=for apidoc foldEQ_locale

Returns true if the leading C<len> bytes of the strings C<s1> and C<s2> are the
same case-insensitively in the current locale; false otherwise.

=cut
*/

I32
Perl_foldEQ_locale(const char *s1, const char *s2, I32 len)
{
    dVAR;
    const U8 *a = (const U8 *)s1;
    const U8 *b = (const U8 *)s2;

    PERL_ARGS_ASSERT_FOLDEQ_LOCALE;

    assert(len >= 0);

    while (len--) {
	if (*a != *b && *a != PL_fold_locale[*b])
	    return 0;
	a++,b++;
    }
    return 1;
}

/* copy a string to a safe spot */

/*
=head1 Memory Management

=for apidoc savepv

Perl's version of C<strdup()>.  Returns a pointer to a newly allocated
string which is a duplicate of C<pv>.  The size of the string is
determined by C<strlen()>, which means it may not contain embedded C<NUL>
characters and must have a trailing C<NUL>.  The memory allocated for the new
string can be freed with the C<Safefree()> function.

On some platforms, Windows for example, all allocated memory owned by a thread
is deallocated when that thread ends.  So if you need that not to happen, you
need to use the shared memory functions, such as C<L</savesharedpv>>.

=cut
*/

char *
Perl_savepv(pTHX_ const char *pv)
{
    PERL_UNUSED_CONTEXT;
    if (!pv)
	return NULL;
    else {
	char *newaddr;
	const STRLEN pvlen = strlen(pv)+1;
	Newx(newaddr, pvlen, char);
	return (char*)memcpy(newaddr, pv, pvlen);
    }
}

/* same thing but with a known length */

/*
=for apidoc savepvn

Perl's version of what C<strndup()> would be if it existed.  Returns a
pointer to a newly allocated string which is a duplicate of the first
C<len> bytes from C<pv>, plus a trailing
C<NUL> byte.  The memory allocated for
the new string can be freed with the C<Safefree()> function.

On some platforms, Windows for example, all allocated memory owned by a thread
is deallocated when that thread ends.  So if you need that not to happen, you
need to use the shared memory functions, such as C<L</savesharedpvn>>.

=cut
*/

char *
Perl_savepvn(pTHX_ const char *pv, I32 len)
{
    char *newaddr;
    PERL_UNUSED_CONTEXT;

    assert(len >= 0);

    Newx(newaddr,len+1,char);
    /* Give a meaning to NULL pointer mainly for the use in sv_magic() */
    if (pv) {
	/* might not be null terminated */
    	newaddr[len] = '\0';
    	return (char *) CopyD(pv,newaddr,len,char);
    }
    else {
	return (char *) ZeroD(newaddr,len+1,char);
    }
}

/*
=for apidoc savesharedpv

A version of C<savepv()> which allocates the duplicate string in memory
which is shared between threads.

=cut
*/
char *
Perl_savesharedpv(pTHX_ const char *pv)
{
    char *newaddr;
    STRLEN pvlen;

    PERL_UNUSED_CONTEXT;

    if (!pv)
	return NULL;

    pvlen = strlen(pv)+1;
    newaddr = (char*)PerlMemShared_malloc(pvlen);
    if (!newaddr) {
	croak_no_mem();
    }
    return (char*)memcpy(newaddr, pv, pvlen);
}

/*
=for apidoc savesharedpvn

A version of C<savepvn()> which allocates the duplicate string in memory
which is shared between threads.  (With the specific difference that a C<NULL>
pointer is not acceptable)

=cut
*/
char *
Perl_savesharedpvn(pTHX_ const char *const pv, const STRLEN len)
{
    char *const newaddr = (char*)PerlMemShared_malloc(len + 1);

    PERL_UNUSED_CONTEXT;
    /* PERL_ARGS_ASSERT_SAVESHAREDPVN; */

    if (!newaddr) {
	croak_no_mem();
    }
    newaddr[len] = '\0';
    return (char*)memcpy(newaddr, pv, len);
}

/*
=for apidoc savesvpv

A version of C<savepv()>/C<savepvn()> which gets the string to duplicate from
the passed in SV using C<SvPV()>

On some platforms, Windows for example, all allocated memory owned by a thread
is deallocated when that thread ends.  So if you need that not to happen, you
need to use the shared memory functions, such as C<L</savesharedsvpv>>.

=cut
*/

char *
Perl_savesvpv(pTHX_ SV *sv)
{
    STRLEN len;
    const char * const pv = SvPV_const(sv, len);
    char *newaddr;

    PERL_ARGS_ASSERT_SAVESVPV;

    ++len;
    Newx(newaddr,len,char);
    return (char *) CopyD(pv,newaddr,len,char);
}

/*
=for apidoc savesharedsvpv

A version of C<savesharedpv()> which allocates the duplicate string in
memory which is shared between threads.

=cut
*/

char *
Perl_savesharedsvpv(pTHX_ SV *sv)
{
    STRLEN len;
    const char * const pv = SvPV_const(sv, len);

    PERL_ARGS_ASSERT_SAVESHAREDSVPV;

    return savesharedpvn(pv, len);
}

/* the SV for Perl_form() and mess() is not kept in an arena */

STATIC SV *
S_mess_alloc(pTHX)
{
    SV *sv;
    XPVMG *any;

    if (PL_phase != PERL_PHASE_DESTRUCT)
	return newSVpvs_flags("", SVs_TEMP);

    if (PL_mess_sv)
	return PL_mess_sv;

    /* Create as PVMG now, to avoid any upgrading later */
    Newx(sv, 1, SV);
    Newxz(any, 1, XPVMG);
    SvFLAGS(sv) = SVt_PVMG;
    SvANY(sv) = (void*)any;
    SvPV_set(sv, NULL);
    SvREFCNT(sv) = 1 << 30; /* practically infinite */
    PL_mess_sv = sv;
    return sv;
}

#if defined(PERL_IMPLICIT_CONTEXT)
char *
Perl_form_nocontext(const char* pat, ...)
{
    dTHX;
    char *retval;
    va_list args;
    PERL_ARGS_ASSERT_FORM_NOCONTEXT;
    va_start(args, pat);
    retval = vform(pat, &args);
    va_end(args);
    return retval;
}
#endif /* PERL_IMPLICIT_CONTEXT */

/*
=head1 Miscellaneous Functions
=for apidoc form

Takes a sprintf-style format pattern and conventional
(non-SV) arguments and returns the formatted string.

    (char *) Perl_form(pTHX_ const char* pat, ...)

can be used any place a string (char *) is required:

    char * s = Perl_form("%d.%d",major,minor);

Uses a single private buffer so if you want to format several strings you
must explicitly copy the earlier strings away (and free the copies when you
are done).

=cut
*/

char *
Perl_form(pTHX_ const char* pat, ...)
{
    char *retval;
    va_list args;
    PERL_ARGS_ASSERT_FORM;
    va_start(args, pat);
    retval = vform(pat, &args);
    va_end(args);
    return retval;
}

char *
Perl_vform(pTHX_ const char *pat, va_list *args)
{
    SV * const sv = mess_alloc();
    PERL_ARGS_ASSERT_VFORM;
    sv_vsetpvfn(sv, pat, strlen(pat), args, NULL, 0, NULL);
    return SvPVX(sv);
}

/*
=for apidoc Am|SV *|mess|const char *pat|...

Take a sprintf-style format pattern and argument list.  These are used to
generate a string message.  If the message does not end with a newline,
then it will be extended with some indication of the current location
in the code, as described for L</mess_sv>.

Normally, the resulting message is returned in a new mortal SV.
During global destruction a single SV may be shared between uses of
this function.

=cut
*/

#if defined(PERL_IMPLICIT_CONTEXT)
SV *
Perl_mess_nocontext(const char *pat, ...)
{
    dTHX;
    SV *retval;
    va_list args;
    PERL_ARGS_ASSERT_MESS_NOCONTEXT;
    va_start(args, pat);
    retval = vmess(pat, &args);
    va_end(args);
    return retval;
}
#endif /* PERL_IMPLICIT_CONTEXT */

SV *
Perl_mess(pTHX_ const char *pat, ...)
{
    SV *retval;
    va_list args;
    PERL_ARGS_ASSERT_MESS;
    va_start(args, pat);
    retval = vmess(pat, &args);
    va_end(args);
    return retval;
}

const COP*
Perl_closest_cop(pTHX_ const COP *cop, const OP *o, const OP *curop,
		       bool opnext)
{
    /* Look for curop starting from o.  cop is the last COP we've seen. */
    /* opnext means that curop is actually the ->op_next of the op we are
       seeking. */

    PERL_ARGS_ASSERT_CLOSEST_COP;

    if (!o || !curop || (
	opnext ? o->op_next == curop && o->op_type != OP_SCOPE : o == curop
    ))
	return cop;

    if (o->op_flags & OPf_KIDS) {
	const OP *kid;
	for (kid = cUNOPo->op_first; kid; kid = OpSIBLING(kid)) {
	    const COP *new_cop;

	    /* If the OP_NEXTSTATE has been optimised away we can still use it
	     * the get the file and line number. */

	    if (kid->op_type == OP_NULL && kid->op_targ == OP_NEXTSTATE)
		cop = (const COP *)kid;

	    /* Keep searching, and return when we've found something. */

	    new_cop = closest_cop(cop, kid, curop, opnext);
	    if (new_cop)
		return new_cop;
	}
    }

    /* Nothing found. */

    return NULL;
}

/*
=for apidoc Am|SV *|mess_sv|SV *basemsg|bool consume

Expands a message, intended for the user, to include an indication of
the current location in the code, if the message does not already appear
to be complete.

C<basemsg> is the initial message or object.  If it is a reference, it
will be used as-is and will be the result of this function.  Otherwise it
is used as a string, and if it already ends with a newline, it is taken
to be complete, and the result of this function will be the same string.
If the message does not end with a newline, then a segment such as C<at
foo.pl line 37> will be appended, and possibly other clauses indicating
the current state of execution.  The resulting message will end with a
dot and a newline.

Normally, the resulting message is returned in a new mortal SV.
During global destruction a single SV may be shared between uses of this
function.  If C<consume> is true, then the function is permitted (but not
required) to modify and return C<basemsg> instead of allocating a new SV.

=cut
*/

SV *
Perl_mess_sv(pTHX_ SV *basemsg, bool consume)
{
    SV *sv;

#if defined(USE_C_BACKTRACE) && defined(USE_C_BACKTRACE_ON_ERROR)
    {
        char *ws;
        UV wi;
        /* The PERL_C_BACKTRACE_ON_WARN must be an integer of one or more. */
        if ((ws = PerlEnv_getenv("PERL_C_BACKTRACE_ON_ERROR"))
            && grok_atoUV(ws, &wi, NULL)
            && wi <= PERL_INT_MAX
        ) {
            Perl_dump_c_backtrace(aTHX_ Perl_debug_log, (int)wi, 1);
        }
    }
#endif

    PERL_ARGS_ASSERT_MESS_SV;

    if (SvROK(basemsg)) {
	if (consume) {
	    sv = basemsg;
	}
	else {
	    sv = mess_alloc();
	    sv_setsv(sv, basemsg);
	}
	return sv;
    }

    if (SvPOK(basemsg) && consume) {
	sv = basemsg;
    }
    else {
	sv = mess_alloc();
	sv_copypv(sv, basemsg);
    }

    if (!SvCUR(sv) || *(SvEND(sv) - 1) != '\n') {
	/*
	 * Try and find the file and line for PL_op.  This will usually be
	 * PL_curcop, but it might be a cop that has been optimised away.  We
	 * can try to find such a cop by searching through the optree starting
	 * from the sibling of PL_curcop.
	 */

	const COP *cop =
	    closest_cop(PL_curcop, OpSIBLING(PL_curcop), PL_op, FALSE);
	if (!cop)
	    cop = PL_curcop;

	if (CopLINE(cop))
	    Perl_sv_catpvf(aTHX_ sv, " at %s line %"IVdf,
	    OutCopFILE(cop), (IV)CopLINE(cop));
	/* Seems that GvIO() can be untrustworthy during global destruction. */
	if (GvIO(PL_last_in_gv) && (SvTYPE(GvIOp(PL_last_in_gv)) == SVt_PVIO)
		&& IoLINES(GvIOp(PL_last_in_gv)))
	{
	    STRLEN l;
	    const bool line_mode = (RsSIMPLE(PL_rs) &&
				   *SvPV_const(PL_rs,l) == '\n' && l == 1);
	    Perl_sv_catpvf(aTHX_ sv, ", <%"SVf"> %s %"IVdf,
			   SVfARG(PL_last_in_gv == PL_argvgv
                                 ? &PL_sv_no
                                 : sv_2mortal(newSVhek(GvNAME_HEK(PL_last_in_gv)))),
			   line_mode ? "line" : "chunk",
			   (IV)IoLINES(GvIOp(PL_last_in_gv)));
	}
	if (PL_phase == PERL_PHASE_DESTRUCT)
	    sv_catpvs(sv, " during global destruction");
	sv_catpvs(sv, ".\n");
    }
    return sv;
}

/*
=for apidoc Am|SV *|vmess|const char *pat|va_list *args

C<pat> and C<args> are a sprintf-style format pattern and encapsulated
argument list, respectively.  These are used to generate a string message.  If
the
message does not end with a newline, then it will be extended with
some indication of the current location in the code, as described for
L</mess_sv>.

Normally, the resulting message is returned in a new mortal SV.
During global destruction a single SV may be shared between uses of
this function.

=cut
*/

SV *
Perl_vmess(pTHX_ const char *pat, va_list *args)
{
    SV * const sv = mess_alloc();

    PERL_ARGS_ASSERT_VMESS;

    sv_vsetpvfn(sv, pat, strlen(pat), args, NULL, 0, NULL);
    return mess_sv(sv, 1);
}

void
Perl_write_to_stderr(pTHX_ SV* msv)
{
    IO *io;
    MAGIC *mg;

    PERL_ARGS_ASSERT_WRITE_TO_STDERR;

    if (PL_stderrgv && SvREFCNT(PL_stderrgv) 
	&& (io = GvIO(PL_stderrgv))
	&& (mg = SvTIED_mg((const SV *)io, PERL_MAGIC_tiedscalar))) 
	Perl_magic_methcall(aTHX_ MUTABLE_SV(io), mg, SV_CONST(PRINT),
			    G_SCALAR | G_DISCARD | G_WRITING_TO_STDERR, 1, msv);
    else {
	PerlIO * const serr = Perl_error_log;

	do_print(msv, serr);
	(void)PerlIO_flush(serr);
    }
}

/*
=head1 Warning and Dieing
*/

/* Common code used in dieing and warning */

STATIC SV *
S_with_queued_errors(pTHX_ SV *ex)
{
    PERL_ARGS_ASSERT_WITH_QUEUED_ERRORS;
    if (PL_errors && SvCUR(PL_errors) && !SvROK(ex)) {
	sv_catsv(PL_errors, ex);
	ex = sv_mortalcopy(PL_errors);
	SvCUR_set(PL_errors, 0);
    }
    return ex;
}

STATIC bool
S_invoke_exception_hook(pTHX_ SV *ex, bool warn)
{
    HV *stash;
    GV *gv;
    CV *cv;
    SV **const hook = warn ? &PL_warnhook : &PL_diehook;
    /* sv_2cv might call Perl_croak() or Perl_warner() */
    SV * const oldhook = *hook;

    if (!oldhook)
	return FALSE;

    ENTER;
    SAVESPTR(*hook);
    *hook = NULL;
    cv = sv_2cv(oldhook, &stash, &gv, 0);
    LEAVE;
    if (cv && !CvDEPTH(cv) && (CvROOT(cv) || CvXSUB(cv))) {
	dSP;
	SV *exarg;

	ENTER;
	save_re_context();
	if (warn) {
	    SAVESPTR(*hook);
	    *hook = NULL;
	}
	exarg = newSVsv(ex);
	SvREADONLY_on(exarg);
	SAVEFREESV(exarg);

	PUSHSTACKi(warn ? PERLSI_WARNHOOK : PERLSI_DIEHOOK);
	PUSHMARK(SP);
	XPUSHs(exarg);
	PUTBACK;
	call_sv(MUTABLE_SV(cv), G_DISCARD);
	POPSTACK;
	LEAVE;
	return TRUE;
    }
    return FALSE;
}

/*
=for apidoc Am|OP *|die_sv|SV *baseex

Behaves the same as L</croak_sv>, except for the return type.
It should be used only where the C<OP *> return type is required.
The function never actually returns.

=cut
*/

#ifdef _MSC_VER
#  pragma warning( push )
#  pragma warning( disable : 4646 ) /* warning C4646: function declared with
    __declspec(noreturn) has non-void return type */
#  pragma warning( disable : 4645 ) /* warning C4645: function declared with
__declspec(noreturn) has a return statement */
#endif
OP *
Perl_die_sv(pTHX_ SV *baseex)
{
    PERL_ARGS_ASSERT_DIE_SV;
    croak_sv(baseex);
    /* NOTREACHED */
    NORETURN_FUNCTION_END;
}
#ifdef _MSC_VER
#  pragma warning( pop )
#endif

/*
=for apidoc Am|OP *|die|const char *pat|...

Behaves the same as L</croak>, except for the return type.
It should be used only where the C<OP *> return type is required.
The function never actually returns.

=cut
*/

#if defined(PERL_IMPLICIT_CONTEXT)
#ifdef _MSC_VER
#  pragma warning( push )
#  pragma warning( disable : 4646 ) /* warning C4646: function declared with
    __declspec(noreturn) has non-void return type */
#  pragma warning( disable : 4645 ) /* warning C4645: function declared with
__declspec(noreturn) has a return statement */
#endif
OP *
Perl_die_nocontext(const char* pat, ...)
{
    dTHX;
    va_list args;
    va_start(args, pat);
    vcroak(pat, &args);
    NOT_REACHED; /* NOTREACHED */
    va_end(args);
    NORETURN_FUNCTION_END;
}
#ifdef _MSC_VER
#  pragma warning( pop )
#endif
#endif /* PERL_IMPLICIT_CONTEXT */

#ifdef _MSC_VER
#  pragma warning( push )
#  pragma warning( disable : 4646 ) /* warning C4646: function declared with
    __declspec(noreturn) has non-void return type */
#  pragma warning( disable : 4645 ) /* warning C4645: function declared with
__declspec(noreturn) has a return statement */
#endif
OP *
Perl_die(pTHX_ const char* pat, ...)
{
    va_list args;
    va_start(args, pat);
    vcroak(pat, &args);
    NOT_REACHED; /* NOTREACHED */
    va_end(args);
    NORETURN_FUNCTION_END;
}
#ifdef _MSC_VER
#  pragma warning( pop )
#endif

/*
=for apidoc Am|void|croak_sv|SV *baseex

This is an XS interface to Perl's C<die> function.

C<baseex> is the error message or object.  If it is a reference, it
will be used as-is.  Otherwise it is used as a string, and if it does
not end with a newline then it will be extended with some indication of
the current location in the code, as described for L</mess_sv>.

The error message or object will be used as an exception, by default
returning control to the nearest enclosing C<eval>, but subject to
modification by a C<$SIG{__DIE__}> handler.  In any case, the C<croak_sv>
function never returns normally.

To die with a simple string message, the L</croak> function may be
more convenient.

=cut
*/

void
Perl_croak_sv(pTHX_ SV *baseex)
{
    SV *ex = with_queued_errors(mess_sv(baseex, 0));
    PERL_ARGS_ASSERT_CROAK_SV;
    invoke_exception_hook(ex, FALSE);
    die_unwind(ex);
}

/*
=for apidoc Am|void|vcroak|const char *pat|va_list *args

This is an XS interface to Perl's C<die> function.

C<pat> and C<args> are a sprintf-style format pattern and encapsulated
argument list.  These are used to generate a string message.  If the
message does not end with a newline, then it will be extended with
some indication of the current location in the code, as described for
L</mess_sv>.

The error message will be used as an exception, by default
returning control to the nearest enclosing C<eval>, but subject to
modification by a C<$SIG{__DIE__}> handler.  In any case, the C<croak>
function never returns normally.

For historical reasons, if C<pat> is null then the contents of C<ERRSV>
(C<$@@>) will be used as an error message or object instead of building an
error message from arguments.  If you want to throw a non-string object,
or build an error message in an SV yourself, it is preferable to use
the L</croak_sv> function, which does not involve clobbering C<ERRSV>.

=cut
*/

void
Perl_vcroak(pTHX_ const char* pat, va_list *args)
{
    SV *ex = with_queued_errors(pat ? vmess(pat, args) : mess_sv(ERRSV, 0));
    invoke_exception_hook(ex, FALSE);
    die_unwind(ex);
}

/*
=for apidoc Am|void|croak|const char *pat|...

This is an XS interface to Perl's C<die> function.

Take a sprintf-style format pattern and argument list.  These are used to
generate a string message.  If the message does not end with a newline,
then it will be extended with some indication of the current location
in the code, as described for L</mess_sv>.

The error message will be used as an exception, by default
returning control to the nearest enclosing C<eval>, but subject to
modification by a C<$SIG{__DIE__}> handler.  In any case, the C<croak>
function never returns normally.

For historical reasons, if C<pat> is null then the contents of C<ERRSV>
(C<$@@>) will be used as an error message or object instead of building an
error message from arguments.  If you want to throw a non-string object,
or build an error message in an SV yourself, it is preferable to use
the L</croak_sv> function, which does not involve clobbering C<ERRSV>.

=cut
*/

#if defined(PERL_IMPLICIT_CONTEXT)
void
Perl_croak_nocontext(const char *pat, ...)
{
    dTHX;
    va_list args;
    va_start(args, pat);
    vcroak(pat, &args);
    NOT_REACHED; /* NOTREACHED */
    va_end(args);
}
#endif /* PERL_IMPLICIT_CONTEXT */

void
Perl_croak(pTHX_ const char *pat, ...)
{
    va_list args;
    va_start(args, pat);
    vcroak(pat, &args);
    NOT_REACHED; /* NOTREACHED */
    va_end(args);
}

/*
=for apidoc Am|void|croak_no_modify

Exactly equivalent to C<Perl_croak(aTHX_ "%s", PL_no_modify)>, but generates
terser object code than using C<Perl_croak>.  Less code used on exception code
paths reduces CPU cache pressure.

=cut
*/

void
Perl_croak_no_modify(void)
{
    Perl_croak_nocontext( "%s", PL_no_modify);
}

/* does not return, used in util.c perlio.c and win32.c
   This is typically called when malloc returns NULL.
*/
void
Perl_croak_no_mem(void)
{
    dTHX;

    int fd = PerlIO_fileno(Perl_error_log);
    if (fd < 0)
        SETERRNO(EBADF,RMS_IFI);
    else {
        /* Can't use PerlIO to write as it allocates memory */
        PERL_UNUSED_RESULT(PerlLIO_write(fd, PL_no_mem, sizeof(PL_no_mem)-1));
    }
    my_exit(1);
}

/* does not return, used only in POPSTACK */
void
Perl_croak_popstack(void)
{
    dTHX;
    PerlIO_printf(Perl_error_log, "panic: POPSTACK\n");
    my_exit(1);
}

/*
=for apidoc Am|void|warn_sv|SV *baseex

This is an XS interface to Perl's C<warn> function.

C<baseex> is the error message or object.  If it is a reference, it
will be used as-is.  Otherwise it is used as a string, and if it does
not end with a newline then it will be extended with some indication of
the current location in the code, as described for L</mess_sv>.

The error message or object will by default be written to standard error,
but this is subject to modification by a C<$SIG{__WARN__}> handler.

To warn with a simple string message, the L</warn> function may be
more convenient.

=cut
*/

void
Perl_warn_sv(pTHX_ SV *baseex)
{
    SV *ex = mess_sv(baseex, 0);
    PERL_ARGS_ASSERT_WARN_SV;
    if (!invoke_exception_hook(ex, TRUE))
	write_to_stderr(ex);
}

/*
=for apidoc Am|void|vwarn|const char *pat|va_list *args

This is an XS interface to Perl's C<warn> function.

C<pat> and C<args> are a sprintf-style format pattern and encapsulated
argument list.  These are used to generate a string message.  If the
message does not end with a newline, then it will be extended with
some indication of the current location in the code, as described for
L</mess_sv>.

The error message or object will by default be written to standard error,
but this is subject to modification by a C<$SIG{__WARN__}> handler.

Unlike with L</vcroak>, C<pat> is not permitted to be null.

=cut
*/

void
Perl_vwarn(pTHX_ const char* pat, va_list *args)
{
    SV *ex = vmess(pat, args);
    PERL_ARGS_ASSERT_VWARN;
    if (!invoke_exception_hook(ex, TRUE))
	write_to_stderr(ex);
}

/*
=for apidoc Am|void|warn|const char *pat|...

This is an XS interface to Perl's C<warn> function.

Take a sprintf-style format pattern and argument list.  These are used to
generate a string message.  If the message does not end with a newline,
then it will be extended with some indication of the current location
in the code, as described for L</mess_sv>.

The error message or object will by default be written to standard error,
but this is subject to modification by a C<$SIG{__WARN__}> handler.

Unlike with L</croak>, C<pat> is not permitted to be null.

=cut
*/

#if defined(PERL_IMPLICIT_CONTEXT)
void
Perl_warn_nocontext(const char *pat, ...)
{
    dTHX;
    va_list args;
    PERL_ARGS_ASSERT_WARN_NOCONTEXT;
    va_start(args, pat);
    vwarn(pat, &args);
    va_end(args);
}
#endif /* PERL_IMPLICIT_CONTEXT */

void
Perl_warn(pTHX_ const char *pat, ...)
{
    va_list args;
    PERL_ARGS_ASSERT_WARN;
    va_start(args, pat);
    vwarn(pat, &args);
    va_end(args);
}

#if defined(PERL_IMPLICIT_CONTEXT)
void
Perl_warner_nocontext(U32 err, const char *pat, ...)
{
    dTHX; 
    va_list args;
    PERL_ARGS_ASSERT_WARNER_NOCONTEXT;
    va_start(args, pat);
    vwarner(err, pat, &args);
    va_end(args);
}
#endif /* PERL_IMPLICIT_CONTEXT */

void
Perl_ck_warner_d(pTHX_ U32 err, const char* pat, ...)
{
    PERL_ARGS_ASSERT_CK_WARNER_D;

    if (Perl_ckwarn_d(aTHX_ err)) {
	va_list args;
	va_start(args, pat);
	vwarner(err, pat, &args);
	va_end(args);
    }
}

void
Perl_ck_warner(pTHX_ U32 err, const char* pat, ...)
{
    PERL_ARGS_ASSERT_CK_WARNER;

    if (Perl_ckwarn(aTHX_ err)) {
	va_list args;
	va_start(args, pat);
	vwarner(err, pat, &args);
	va_end(args);
    }
}

void
Perl_warner(pTHX_ U32  err, const char* pat,...)
{
    va_list args;
    PERL_ARGS_ASSERT_WARNER;
    va_start(args, pat);
    vwarner(err, pat, &args);
    va_end(args);
}

void
Perl_vwarner(pTHX_ U32  err, const char* pat, va_list* args)
{
    dVAR;
    PERL_ARGS_ASSERT_VWARNER;
    if (
        (PL_warnhook == PERL_WARNHOOK_FATAL || ckDEAD(err)) &&
        !(PL_in_eval & EVAL_KEEPERR)
    ) {
	SV * const msv = vmess(pat, args);

	if (PL_parser && PL_parser->error_count) {
	    qerror(msv);
	}
	else {
	    invoke_exception_hook(msv, FALSE);
	    die_unwind(msv);
	}
    }
    else {
	Perl_vwarn(aTHX_ pat, args);
    }
}

/* implements the ckWARN? macros */

bool
Perl_ckwarn(pTHX_ U32 w)
{
    /* If lexical warnings have not been set, use $^W.  */
    if (isLEXWARN_off)
	return PL_dowarn & G_WARN_ON;

    return ckwarn_common(w);
}

/* implements the ckWARN?_d macro */

bool
Perl_ckwarn_d(pTHX_ U32 w)
{
    /* If lexical warnings have not been set then default classes warn.  */
    if (isLEXWARN_off)
	return TRUE;

    return ckwarn_common(w);
}

static bool
S_ckwarn_common(pTHX_ U32 w)
{
    if (PL_curcop->cop_warnings == pWARN_ALL)
	return TRUE;

    if (PL_curcop->cop_warnings == pWARN_NONE)
	return FALSE;

    /* Check the assumption that at least the first slot is non-zero.  */
    assert(unpackWARN1(w));

    /* Check the assumption that it is valid to stop as soon as a zero slot is
       seen.  */
    if (!unpackWARN2(w)) {
	assert(!unpackWARN3(w));
	assert(!unpackWARN4(w));
    } else if (!unpackWARN3(w)) {
	assert(!unpackWARN4(w));
    }
	
    /* Right, dealt with all the special cases, which are implemented as non-
       pointers, so there is a pointer to a real warnings mask.  */
    do {
	if (isWARN_on(PL_curcop->cop_warnings, unpackWARN1(w)))
	    return TRUE;
    } while (w >>= WARNshift);

    return FALSE;
}

/* Set buffer=NULL to get a new one.  */
STRLEN *
Perl_new_warnings_bitfield(pTHX_ STRLEN *buffer, const char *const bits,
			   STRLEN size) {
    const MEM_SIZE len_wanted =
	sizeof(STRLEN) + (size > WARNsize ? size : WARNsize);
    PERL_UNUSED_CONTEXT;
    PERL_ARGS_ASSERT_NEW_WARNINGS_BITFIELD;

    buffer = (STRLEN*)
	(specialWARN(buffer) ?
	 PerlMemShared_malloc(len_wanted) :
	 PerlMemShared_realloc(buffer, len_wanted));
    buffer[0] = size;
    Copy(bits, (buffer + 1), size, char);
    if (size < WARNsize)
	Zero((char *)(buffer + 1) + size, WARNsize - size, char);
    return buffer;
}

/* since we've already done strlen() for both nam and val
 * we can use that info to make things faster than
 * sprintf(s, "%s=%s", nam, val)
 */
#define my_setenv_format(s, nam, nlen, val, vlen) \
   Copy(nam, s, nlen, char); \
   *(s+nlen) = '='; \
   Copy(val, s+(nlen+1), vlen, char); \
   *(s+(nlen+1+vlen)) = '\0'

#ifdef USE_ENVIRON_ARRAY
       /* VMS' my_setenv() is in vms.c */
#if !defined(WIN32) && !defined(NETWARE)
void
Perl_my_setenv(pTHX_ const char *nam, const char *val)
{
  dVAR;
#ifdef __amigaos4__
  amigaos4_obtain_environ(__FUNCTION__);
#endif
#ifdef USE_ITHREADS
  /* only parent thread can modify process environment */
  if (PL_curinterp == aTHX)
#endif
  {
#ifndef PERL_USE_SAFE_PUTENV
    if (!PL_use_safe_putenv) {
        /* most putenv()s leak, so we manipulate environ directly */
        I32 i;
        const I32 len = strlen(nam);
        int nlen, vlen;

        /* where does it go? */
        for (i = 0; environ[i]; i++) {
            if (strnEQ(environ[i],nam,len) && environ[i][len] == '=')
                break;
        }

        if (environ == PL_origenviron) {   /* need we copy environment? */
            I32 j;
            I32 max;
            char **tmpenv;

            max = i;
            while (environ[max])
                max++;
            tmpenv = (char**)safesysmalloc((max+2) * sizeof(char*));
            for (j=0; j<max; j++) {         /* copy environment */
                const int len = strlen(environ[j]);
                tmpenv[j] = (char*)safesysmalloc((len+1)*sizeof(char));
                Copy(environ[j], tmpenv[j], len+1, char);
            }
            tmpenv[max] = NULL;
            environ = tmpenv;               /* tell exec where it is now */
        }
        if (!val) {
            safesysfree(environ[i]);
            while (environ[i]) {
                environ[i] = environ[i+1];
                i++;
            }
#ifdef __amigaos4__
            goto my_setenv_out;
#else
            return;
#endif
        }
        if (!environ[i]) {                 /* does not exist yet */
            environ = (char**)safesysrealloc(environ, (i+2) * sizeof(char*));
            environ[i+1] = NULL;    /* make sure it's null terminated */
        }
        else
            safesysfree(environ[i]);
        nlen = strlen(nam);
        vlen = strlen(val);

        environ[i] = (char*)safesysmalloc((nlen+vlen+2) * sizeof(char));
        /* all that work just for this */
        my_setenv_format(environ[i], nam, nlen, val, vlen);
    } else {
# endif
    /* This next branch should only be called #if defined(HAS_SETENV), but
       Configure doesn't test for that yet.  For Solaris, setenv() and unsetenv()
       were introduced in Solaris 9, so testing for HAS UNSETENV is sufficient.
    */
#   if defined(__CYGWIN__)|| defined(__SYMBIAN32__) || defined(__riscos__) || (defined(__sun) && defined(HAS_UNSETENV)) || defined(PERL_DARWIN)
#       if defined(HAS_UNSETENV)
        if (val == NULL) {
            (void)unsetenv(nam);
        } else {
            (void)setenv(nam, val, 1);
        }
#       else /* ! HAS_UNSETENV */
        (void)setenv(nam, val, 1);
#       endif /* HAS_UNSETENV */
#   else
#       if defined(HAS_UNSETENV)
        if (val == NULL) {
            if (environ) /* old glibc can crash with null environ */
                (void)unsetenv(nam);
        } else {
	    const int nlen = strlen(nam);
	    const int vlen = strlen(val);
	    char * const new_env =
                (char*)safesysmalloc((nlen + vlen + 2) * sizeof(char));
            my_setenv_format(new_env, nam, nlen, val, vlen);
            (void)putenv(new_env);
        }
#       else /* ! HAS_UNSETENV */
        char *new_env;
	const int nlen = strlen(nam);
	int vlen;
        if (!val) {
	   val = "";
        }
        vlen = strlen(val);
        new_env = (char*)safesysmalloc((nlen + vlen + 2) * sizeof(char));
        /* all that work just for this */
        my_setenv_format(new_env, nam, nlen, val, vlen);
        (void)putenv(new_env);
#       endif /* HAS_UNSETENV */
#   endif /* __CYGWIN__ */
#ifndef PERL_USE_SAFE_PUTENV
    }
#endif
  }
#ifdef __amigaos4__
my_setenv_out:
  amigaos4_release_environ(__FUNCTION__);
#endif
}

#else /* WIN32 || NETWARE */

void
Perl_my_setenv(pTHX_ const char *nam, const char *val)
{
    dVAR;
    char *envstr;
    const int nlen = strlen(nam);
    int vlen;

    if (!val) {
       val = "";
    }
    vlen = strlen(val);
    Newx(envstr, nlen+vlen+2, char);
    my_setenv_format(envstr, nam, nlen, val, vlen);
    (void)PerlEnv_putenv(envstr);
    Safefree(envstr);
}

#endif /* WIN32 || NETWARE */

#endif /* !VMS */

#ifdef UNLINK_ALL_VERSIONS
I32
Perl_unlnk(pTHX_ const char *f)	/* unlink all versions of a file */
{
    I32 retries = 0;

    PERL_ARGS_ASSERT_UNLNK;

    while (PerlLIO_unlink(f) >= 0)
	retries++;
    return retries ? 0 : -1;
}
#endif

/* this is a drop-in replacement for bcopy(), except for the return
 * value, which we need to be able to emulate memcpy()  */
#if !defined(HAS_MEMCPY) || (!defined(HAS_MEMMOVE) && !defined(HAS_SAFE_MEMCPY))
void *
Perl_my_bcopy(const void *vfrom, void *vto, size_t len)
{
#if defined(HAS_BCOPY) && defined(HAS_SAFE_BCOPY)
    bcopy(vfrom, vto, len);
#else
    const unsigned char *from = (const unsigned char *)vfrom;
    unsigned char *to = (unsigned char *)vto;

    PERL_ARGS_ASSERT_MY_BCOPY;

    if (from - to >= 0) {
	while (len--)
	    *to++ = *from++;
    }
    else {
	to += len;
	from += len;
	while (len--)
	    *(--to) = *(--from);
    }
#endif

    return vto;
}
#endif

/* this is a drop-in replacement for memset() */
#ifndef HAS_MEMSET
void *
Perl_my_memset(void *vloc, int ch, size_t len)
{
    unsigned char *loc = (unsigned char *)vloc;

    PERL_ARGS_ASSERT_MY_MEMSET;

    while (len--)
	*loc++ = ch;
    return vloc;
}
#endif

/* this is a drop-in replacement for bzero() */
#if !defined(HAS_BZERO) && !defined(HAS_MEMSET)
void *
Perl_my_bzero(void *vloc, size_t len)
{
    unsigned char *loc = (unsigned char *)vloc;

    PERL_ARGS_ASSERT_MY_BZERO;

    while (len--)
	*loc++ = 0;
    return vloc;
}
#endif

/* this is a drop-in replacement for memcmp() */
#if !defined(HAS_MEMCMP) || !defined(HAS_SANE_MEMCMP)
int
Perl_my_memcmp(const void *vs1, const void *vs2, size_t len)
{
    const U8 *a = (const U8 *)vs1;
    const U8 *b = (const U8 *)vs2;
    int tmp;

    PERL_ARGS_ASSERT_MY_MEMCMP;

    while (len--) {
        if ((tmp = *a++ - *b++))
	    return tmp;
    }
    return 0;
}
#endif /* !HAS_MEMCMP || !HAS_SANE_MEMCMP */

#ifndef HAS_VPRINTF
/* This vsprintf replacement should generally never get used, since
   vsprintf was available in both System V and BSD 2.11.  (There may
   be some cross-compilation or embedded set-ups where it is needed,
   however.)

   If you encounter a problem in this function, it's probably a symptom
   that Configure failed to detect your system's vprintf() function.
   See the section on "item vsprintf" in the INSTALL file.

   This version may compile on systems with BSD-ish <stdio.h>,
   but probably won't on others.
*/

#ifdef USE_CHAR_VSPRINTF
char *
#else
int
#endif
vsprintf(char *dest, const char *pat, void *args)
{
    FILE fakebuf;

#if defined(STDIO_PTR_LVALUE) && defined(STDIO_CNT_LVALUE)
    FILE_ptr(&fakebuf) = (STDCHAR *) dest;
    FILE_cnt(&fakebuf) = 32767;
#else
    /* These probably won't compile -- If you really need
       this, you'll have to figure out some other method. */
    fakebuf._ptr = dest;
    fakebuf._cnt = 32767;
#endif
#ifndef _IOSTRG
#define _IOSTRG 0
#endif
    fakebuf._flag = _IOWRT|_IOSTRG;
    _doprnt(pat, args, &fakebuf);	/* what a kludge */
#if defined(STDIO_PTR_LVALUE)
    *(FILE_ptr(&fakebuf)++) = '\0';
#else
    /* PerlIO has probably #defined away fputc, but we want it here. */
#  ifdef fputc
#    undef fputc  /* XXX Should really restore it later */
#  endif
    (void)fputc('\0', &fakebuf);
#endif
#ifdef USE_CHAR_VSPRINTF
    return(dest);
#else
    return 0;		/* perl doesn't use return value */
#endif
}

#endif /* HAS_VPRINTF */

PerlIO *
Perl_my_popen_list(pTHX_ const char *mode, int n, SV **args)
{
#if (!defined(DOSISH) || defined(HAS_FORK)) && !defined(OS2) && !defined(VMS) && !defined(NETWARE) && !defined(__LIBCATAMOUNT__) && !defined(__amigaos4__)
    int p[2];
    I32 This, that;
    Pid_t pid;
    SV *sv;
    I32 did_pipes = 0;
    int pp[2];

    PERL_ARGS_ASSERT_MY_POPEN_LIST;

    PERL_FLUSHALL_FOR_CHILD;
    This = (*mode == 'w');
    that = !This;
    if (TAINTING_get) {
	taint_env();
	taint_proper("Insecure %s%s", "EXEC");
    }
    if (PerlProc_pipe(p) < 0)
	return NULL;
    /* Try for another pipe pair for error return */
    if (PerlProc_pipe(pp) >= 0)
	did_pipes = 1;
    while ((pid = PerlProc_fork()) < 0) {
	if (errno != EAGAIN) {
	    PerlLIO_close(p[This]);
	    PerlLIO_close(p[that]);
	    if (did_pipes) {
		PerlLIO_close(pp[0]);
		PerlLIO_close(pp[1]);
	    }
	    return NULL;
	}
	Perl_ck_warner(aTHX_ packWARN(WARN_PIPE), "Can't fork, trying again in 5 seconds");
	sleep(5);
    }
    if (pid == 0) {
	/* Child */
#undef THIS
#undef THAT
#define THIS that
#define THAT This
	/* Close parent's end of error status pipe (if any) */
	if (did_pipes) {
	    PerlLIO_close(pp[0]);
#if defined(HAS_FCNTL) && defined(F_SETFD) && defined(FD_CLOEXEC)
	    /* Close error pipe automatically if exec works */
	    if (fcntl(pp[1], F_SETFD, FD_CLOEXEC) < 0)
                return NULL;
#endif
	}
	/* Now dup our end of _the_ pipe to right position */
	if (p[THIS] != (*mode == 'r')) {
	    PerlLIO_dup2(p[THIS], *mode == 'r');
	    PerlLIO_close(p[THIS]);
	    if (p[THAT] != (*mode == 'r'))	/* if dup2() didn't close it */
		PerlLIO_close(p[THAT]);	/* close parent's end of _the_ pipe */
	}
	else
	    PerlLIO_close(p[THAT]);	/* close parent's end of _the_ pipe */
#if !defined(HAS_FCNTL) || !defined(F_SETFD)
	/* No automatic close - do it by hand */
#  ifndef NOFILE
#  define NOFILE 20
#  endif
	{
	    int fd;

	    for (fd = PL_maxsysfd + 1; fd < NOFILE; fd++) {
		if (fd != pp[1])
		    PerlLIO_close(fd);
	    }
	}
#endif
	do_aexec5(NULL, args-1, args-1+n, pp[1], did_pipes);
	PerlProc__exit(1);
#undef THIS
#undef THAT
    }
    /* Parent */
    do_execfree();	/* free any memory malloced by child on fork */
    if (did_pipes)
	PerlLIO_close(pp[1]);
    /* Keep the lower of the two fd numbers */
    if (p[that] < p[This]) {
	PerlLIO_dup2(p[This], p[that]);
	PerlLIO_close(p[This]);
	p[This] = p[that];
    }
    else
	PerlLIO_close(p[that]);		/* close child's end of pipe */

    sv = *av_fetch(PL_fdpid,p[This],TRUE);
    SvUPGRADE(sv,SVt_IV);
    SvIV_set(sv, pid);
    PL_forkprocess = pid;
    /* If we managed to get status pipe check for exec fail */
    if (did_pipes && pid > 0) {
	int errkid;
	unsigned n = 0;
	SSize_t n1;

	while (n < sizeof(int)) {
	    n1 = PerlLIO_read(pp[0],
			      (void*)(((char*)&errkid)+n),
			      (sizeof(int)) - n);
	    if (n1 <= 0)
		break;
	    n += n1;
	}
	PerlLIO_close(pp[0]);
	did_pipes = 0;
	if (n) {			/* Error */
	    int pid2, status;
	    PerlLIO_close(p[This]);
	    if (n != sizeof(int))
		Perl_croak(aTHX_ "panic: kid popen errno read, n=%u", n);
	    do {
		pid2 = wait4pid(pid, &status, 0);
	    } while (pid2 == -1 && errno == EINTR);
	    errno = errkid;		/* Propagate errno from kid */
	    return NULL;
	}
    }
    if (did_pipes)
	 PerlLIO_close(pp[0]);
    return PerlIO_fdopen(p[This], mode);
#else
#  if defined(OS2)	/* Same, without fork()ing and all extra overhead... */
    return my_syspopen4(aTHX_ NULL, mode, n, args);
#  elif defined(WIN32)
    return win32_popenlist(mode, n, args);
#  else
    Perl_croak(aTHX_ "List form of piped open not implemented");
    return (PerlIO *) NULL;
#  endif
#endif
}

    /* VMS' my_popen() is in VMS.c, same with OS/2 and AmigaOS 4. */
#if (!defined(DOSISH) || defined(HAS_FORK)) && !defined(VMS) && !defined(__LIBCATAMOUNT__) && !defined(__amigaos4__)
PerlIO *
Perl_my_popen(pTHX_ const char *cmd, const char *mode)
{
    int p[2];
    I32 This, that;
    Pid_t pid;
    SV *sv;
    const I32 doexec = !(*cmd == '-' && cmd[1] == '\0');
    I32 did_pipes = 0;
    int pp[2];

    PERL_ARGS_ASSERT_MY_POPEN;

    PERL_FLUSHALL_FOR_CHILD;
#ifdef OS2
    if (doexec) {
	return my_syspopen(aTHX_ cmd,mode);
    }
#endif
    This = (*mode == 'w');
    that = !This;
    if (doexec && TAINTING_get) {
	taint_env();
	taint_proper("Insecure %s%s", "EXEC");
    }
    if (PerlProc_pipe(p) < 0)
	return NULL;
    if (doexec && PerlProc_pipe(pp) >= 0)
	did_pipes = 1;
    while ((pid = PerlProc_fork()) < 0) {
	if (errno != EAGAIN) {
	    PerlLIO_close(p[This]);
	    PerlLIO_close(p[that]);
	    if (did_pipes) {
		PerlLIO_close(pp[0]);
		PerlLIO_close(pp[1]);
	    }
	    if (!doexec)
		Perl_croak(aTHX_ "Can't fork: %s", Strerror(errno));
	    return NULL;
	}
	Perl_ck_warner(aTHX_ packWARN(WARN_PIPE), "Can't fork, trying again in 5 seconds");
	sleep(5);
    }
    if (pid == 0) {

#undef THIS
#undef THAT
#define THIS that
#define THAT This
	if (did_pipes) {
	    PerlLIO_close(pp[0]);
#if defined(HAS_FCNTL) && defined(F_SETFD)
            if (fcntl(pp[1], F_SETFD, FD_CLOEXEC) < 0)
                return NULL;
#endif
	}
	if (p[THIS] != (*mode == 'r')) {
	    PerlLIO_dup2(p[THIS], *mode == 'r');
	    PerlLIO_close(p[THIS]);
	    if (p[THAT] != (*mode == 'r'))	/* if dup2() didn't close it */
		PerlLIO_close(p[THAT]);
	}
	else
	    PerlLIO_close(p[THAT]);
#ifndef OS2
	if (doexec) {
#if !defined(HAS_FCNTL) || !defined(F_SETFD)
#ifndef NOFILE
#define NOFILE 20
#endif
	    {
		int fd;

		for (fd = PL_maxsysfd + 1; fd < NOFILE; fd++)
		    if (fd != pp[1])
			PerlLIO_close(fd);
	    }
#endif
	    /* may or may not use the shell */
	    do_exec3(cmd, pp[1], did_pipes);
	    PerlProc__exit(1);
	}
#endif	/* defined OS2 */

#ifdef PERLIO_USING_CRLF
   /* Since we circumvent IO layers when we manipulate low-level
      filedescriptors directly, need to manually switch to the
      default, binary, low-level mode; see PerlIOBuf_open(). */
   PerlLIO_setmode((*mode == 'r'), O_BINARY);
#endif 
	PL_forkprocess = 0;
#ifdef PERL_USES_PL_PIDSTATUS
	hv_clear(PL_pidstatus);	/* we have no children */
#endif
	return NULL;
#undef THIS
#undef THAT
    }
    do_execfree();	/* free any memory malloced by child on vfork */
    if (did_pipes)
	PerlLIO_close(pp[1]);
    if (p[that] < p[This]) {
	PerlLIO_dup2(p[This], p[that]);
	PerlLIO_close(p[This]);
	p[This] = p[that];
    }
    else
	PerlLIO_close(p[that]);

    sv = *av_fetch(PL_fdpid,p[This],TRUE);
    SvUPGRADE(sv,SVt_IV);
    SvIV_set(sv, pid);
    PL_forkprocess = pid;
    if (did_pipes && pid > 0) {
	int errkid;
	unsigned n = 0;
	SSize_t n1;

	while (n < sizeof(int)) {
	    n1 = PerlLIO_read(pp[0],
			      (void*)(((char*)&errkid)+n),
			      (sizeof(int)) - n);
	    if (n1 <= 0)
		break;
	    n += n1;
	}
	PerlLIO_close(pp[0]);
	did_pipes = 0;
	if (n) {			/* Error */
	    int pid2, status;
	    PerlLIO_close(p[This]);
	    if (n != sizeof(int))
		Perl_croak(aTHX_ "panic: kid popen errno read, n=%u", n);
	    do {
		pid2 = wait4pid(pid, &status, 0);
	    } while (pid2 == -1 && errno == EINTR);
	    errno = errkid;		/* Propagate errno from kid */
	    return NULL;
	}
    }
    if (did_pipes)
	 PerlLIO_close(pp[0]);
    return PerlIO_fdopen(p[This], mode);
}
#else
#if defined(DJGPP)
FILE *djgpp_popen();
PerlIO *
Perl_my_popen(pTHX_ const char *cmd, const char *mode)
{
    PERL_FLUSHALL_FOR_CHILD;
    /* Call system's popen() to get a FILE *, then import it.
       used 0 for 2nd parameter to PerlIO_importFILE;
       apparently not used
    */
    return PerlIO_importFILE(djgpp_popen(cmd, mode), 0);
}
#else
#if defined(__LIBCATAMOUNT__)
PerlIO *
Perl_my_popen(pTHX_ const char *cmd, const char *mode)
{
    return NULL;
}
#endif
#endif

#endif /* !DOSISH */

/* this is called in parent before the fork() */
void
Perl_atfork_lock(void)
#if defined(USE_ITHREADS)
#  ifdef USE_PERLIO
  PERL_TSA_ACQUIRE(PL_perlio_mutex)
#  endif
#  ifdef MYMALLOC
  PERL_TSA_ACQUIRE(PL_malloc_mutex)
#  endif
  PERL_TSA_ACQUIRE(PL_op_mutex)
#endif
{
#if defined(USE_ITHREADS)
    dVAR;
    /* locks must be held in locking order (if any) */
#  ifdef USE_PERLIO
    MUTEX_LOCK(&PL_perlio_mutex);
#  endif
#  ifdef MYMALLOC
    MUTEX_LOCK(&PL_malloc_mutex);
#  endif
    OP_REFCNT_LOCK;
#endif
}

/* this is called in both parent and child after the fork() */
void
Perl_atfork_unlock(void)
#if defined(USE_ITHREADS)
#  ifdef USE_PERLIO
  PERL_TSA_RELEASE(PL_perlio_mutex)
#  endif
#  ifdef MYMALLOC
  PERL_TSA_RELEASE(PL_malloc_mutex)
#  endif
  PERL_TSA_RELEASE(PL_op_mutex)
#endif
{
#if defined(USE_ITHREADS)
    dVAR;
    /* locks must be released in same order as in atfork_lock() */
#  ifdef USE_PERLIO
    MUTEX_UNLOCK(&PL_perlio_mutex);
#  endif
#  ifdef MYMALLOC
    MUTEX_UNLOCK(&PL_malloc_mutex);
#  endif
    OP_REFCNT_UNLOCK;
#endif
}

Pid_t
Perl_my_fork(void)
{
#if defined(HAS_FORK)
    Pid_t pid;
#if defined(USE_ITHREADS) && !defined(HAS_PTHREAD_ATFORK)
    atfork_lock();
    pid = fork();
    atfork_unlock();
#else
    /* atfork_lock() and atfork_unlock() are installed as pthread_atfork()
     * handlers elsewhere in the code */
    pid = fork();
#endif
    return pid;
#elif defined(__amigaos4__)
    return amigaos_fork();
#else
    /* this "canna happen" since nothing should be calling here if !HAS_FORK */
    Perl_croak_nocontext("fork() not available");
    return 0;
#endif /* HAS_FORK */
}

#ifndef HAS_DUP2
int
dup2(int oldfd, int newfd)
{
#if defined(HAS_FCNTL) && defined(F_DUPFD)
    if (oldfd == newfd)
	return oldfd;
    PerlLIO_close(newfd);
    return fcntl(oldfd, F_DUPFD, newfd);
#else
#define DUP2_MAX_FDS 256
    int fdtmp[DUP2_MAX_FDS];
    I32 fdx = 0;
    int fd;

    if (oldfd == newfd)
	return oldfd;
    PerlLIO_close(newfd);
    /* good enough for low fd's... */
    while ((fd = PerlLIO_dup(oldfd)) != newfd && fd >= 0) {
	if (fdx >= DUP2_MAX_FDS) {
	    PerlLIO_close(fd);
	    fd = -1;
	    break;
	}
	fdtmp[fdx++] = fd;
    }
    while (fdx > 0)
	PerlLIO_close(fdtmp[--fdx]);
    return fd;
#endif
}
#endif

#ifndef PERL_MICRO
#ifdef HAS_SIGACTION

Sighandler_t
Perl_rsignal(pTHX_ int signo, Sighandler_t handler)
{
    struct sigaction act, oact;

#ifdef USE_ITHREADS
    dVAR;
    /* only "parent" interpreter can diddle signals */
    if (PL_curinterp != aTHX)
	return (Sighandler_t) SIG_ERR;
#endif

    act.sa_handler = (void(*)(int))handler;
    sigemptyset(&act.sa_mask);
    act.sa_flags = 0;
#ifdef SA_RESTART
    if (PL_signals & PERL_SIGNALS_UNSAFE_FLAG)
        act.sa_flags |= SA_RESTART;	/* SVR4, 4.3+BSD */
#endif
#if defined(SA_NOCLDWAIT) && !defined(BSDish) /* See [perl #18849] */
    if (signo == SIGCHLD && handler == (Sighandler_t) SIG_IGN)
	act.sa_flags |= SA_NOCLDWAIT;
#endif
    if (sigaction(signo, &act, &oact) == -1)
    	return (Sighandler_t) SIG_ERR;
    else
    	return (Sighandler_t) oact.sa_handler;
}

Sighandler_t
Perl_rsignal_state(pTHX_ int signo)
{
    struct sigaction oact;
    PERL_UNUSED_CONTEXT;

    if (sigaction(signo, (struct sigaction *)NULL, &oact) == -1)
	return (Sighandler_t) SIG_ERR;
    else
	return (Sighandler_t) oact.sa_handler;
}

int
Perl_rsignal_save(pTHX_ int signo, Sighandler_t handler, Sigsave_t *save)
{
#ifdef USE_ITHREADS
    dVAR;
#endif
    struct sigaction act;

    PERL_ARGS_ASSERT_RSIGNAL_SAVE;

#ifdef USE_ITHREADS
    /* only "parent" interpreter can diddle signals */
    if (PL_curinterp != aTHX)
	return -1;
#endif

    act.sa_handler = (void(*)(int))handler;
    sigemptyset(&act.sa_mask);
    act.sa_flags = 0;
#ifdef SA_RESTART
    if (PL_signals & PERL_SIGNALS_UNSAFE_FLAG)
        act.sa_flags |= SA_RESTART;	/* SVR4, 4.3+BSD */
#endif
#if defined(SA_NOCLDWAIT) && !defined(BSDish) /* See [perl #18849] */
    if (signo == SIGCHLD && handler == (Sighandler_t) SIG_IGN)
	act.sa_flags |= SA_NOCLDWAIT;
#endif
    return sigaction(signo, &act, save);
}

int
Perl_rsignal_restore(pTHX_ int signo, Sigsave_t *save)
{
#ifdef USE_ITHREADS
    dVAR;
#endif
    PERL_UNUSED_CONTEXT;
#ifdef USE_ITHREADS
    /* only "parent" interpreter can diddle signals */
    if (PL_curinterp != aTHX)
	return -1;
#endif

    return sigaction(signo, save, (struct sigaction *)NULL);
}

#else /* !HAS_SIGACTION */

Sighandler_t
Perl_rsignal(pTHX_ int signo, Sighandler_t handler)
{
#if defined(USE_ITHREADS) && !defined(WIN32)
    /* only "parent" interpreter can diddle signals */
    if (PL_curinterp != aTHX)
	return (Sighandler_t) SIG_ERR;
#endif

    return PerlProc_signal(signo, handler);
}

static Signal_t
sig_trap(int signo)
{
    dVAR;
    PL_sig_trapped++;
}

Sighandler_t
Perl_rsignal_state(pTHX_ int signo)
{
    dVAR;
    Sighandler_t oldsig;

#if defined(USE_ITHREADS) && !defined(WIN32)
    /* only "parent" interpreter can diddle signals */
    if (PL_curinterp != aTHX)
	return (Sighandler_t) SIG_ERR;
#endif

    PL_sig_trapped = 0;
    oldsig = PerlProc_signal(signo, sig_trap);
    PerlProc_signal(signo, oldsig);
    if (PL_sig_trapped)
	PerlProc_kill(PerlProc_getpid(), signo);
    return oldsig;
}

int
Perl_rsignal_save(pTHX_ int signo, Sighandler_t handler, Sigsave_t *save)
{
#if defined(USE_ITHREADS) && !defined(WIN32)
    /* only "parent" interpreter can diddle signals */
    if (PL_curinterp != aTHX)
	return -1;
#endif
    *save = PerlProc_signal(signo, handler);
    return (*save == (Sighandler_t) SIG_ERR) ? -1 : 0;
}

int
Perl_rsignal_restore(pTHX_ int signo, Sigsave_t *save)
{
#if defined(USE_ITHREADS) && !defined(WIN32)
    /* only "parent" interpreter can diddle signals */
    if (PL_curinterp != aTHX)
	return -1;
#endif
    return (PerlProc_signal(signo, *save) == (Sighandler_t) SIG_ERR) ? -1 : 0;
}

#endif /* !HAS_SIGACTION */
#endif /* !PERL_MICRO */

    /* VMS' my_pclose() is in VMS.c; same with OS/2 */
#if (!defined(DOSISH) || defined(HAS_FORK)) && !defined(VMS) && !defined(__LIBCATAMOUNT__) && !defined(__amigaos4__)
I32
Perl_my_pclose(pTHX_ PerlIO *ptr)
{
    int status;
    SV **svp;
    Pid_t pid;
    Pid_t pid2 = 0;
    bool close_failed;
    dSAVEDERRNO;
    const int fd = PerlIO_fileno(ptr);
    bool should_wait;

    svp = av_fetch(PL_fdpid,fd,TRUE);
    pid = (SvTYPE(*svp) == SVt_IV) ? SvIVX(*svp) : -1;
    SvREFCNT_dec(*svp);
    *svp = NULL;

#if defined(USE_PERLIO)
    /* Find out whether the refcount is low enough for us to wait for the
       child proc without blocking. */
    should_wait = PerlIOUnix_refcnt(fd) == 1 && pid > 0;
#else
    should_wait = pid > 0;
#endif

#ifdef OS2
    if (pid == -1) {			/* Opened by popen. */
	return my_syspclose(ptr);
    }
#endif
    close_failed = (PerlIO_close(ptr) == EOF);
    SAVE_ERRNO;
    if (should_wait) do {
	pid2 = wait4pid(pid, &status, 0);
    } while (pid2 == -1 && errno == EINTR);
    if (close_failed) {
	RESTORE_ERRNO;
	return -1;
    }
    return(
      should_wait
       ? pid2 < 0 ? pid2 : status == 0 ? 0 : (errno = 0, status)
       : 0
    );
}
#else
#if defined(__LIBCATAMOUNT__)
I32
Perl_my_pclose(pTHX_ PerlIO *ptr)
{
    return -1;
}
#endif
#endif /* !DOSISH */

#if  (!defined(DOSISH) || defined(OS2) || defined(WIN32) || defined(NETWARE)) && !defined(__LIBCATAMOUNT__)
I32
Perl_wait4pid(pTHX_ Pid_t pid, int *statusp, int flags)
{
    I32 result = 0;
    PERL_ARGS_ASSERT_WAIT4PID;
#ifdef PERL_USES_PL_PIDSTATUS
    if (!pid) {
        /* PERL_USES_PL_PIDSTATUS is only defined when neither
           waitpid() nor wait4() is available, or on OS/2, which
           doesn't appear to support waiting for a progress group
           member, so we can only treat a 0 pid as an unknown child.
        */
        errno = ECHILD;
        return -1;
    }
    {
	if (pid > 0) {
	    /* The keys in PL_pidstatus are now the raw 4 (or 8) bytes of the
	       pid, rather than a string form.  */
	    SV * const * const svp = hv_fetch(PL_pidstatus,(const char*) &pid,sizeof(Pid_t),FALSE);
	    if (svp && *svp != &PL_sv_undef) {
		*statusp = SvIVX(*svp);
		(void)hv_delete(PL_pidstatus,(const char*) &pid,sizeof(Pid_t),
				G_DISCARD);
		return pid;
	    }
	}
	else {
	    HE *entry;

	    hv_iterinit(PL_pidstatus);
	    if ((entry = hv_iternext(PL_pidstatus))) {
		SV * const sv = hv_iterval(PL_pidstatus,entry);
		I32 len;
		const char * const spid = hv_iterkey(entry,&len);

		assert (len == sizeof(Pid_t));
		memcpy((char *)&pid, spid, len);
		*statusp = SvIVX(sv);
		/* The hash iterator is currently on this entry, so simply
		   calling hv_delete would trigger the lazy delete, which on
		   aggregate does more work, because next call to hv_iterinit()
		   would spot the flag, and have to call the delete routine,
		   while in the meantime any new entries can't re-use that
		   memory.  */
		hv_iterinit(PL_pidstatus);
		(void)hv_delete(PL_pidstatus,spid,len,G_DISCARD);
		return pid;
	    }
	}
    }
#endif
#ifdef HAS_WAITPID
#  ifdef HAS_WAITPID_RUNTIME
    if (!HAS_WAITPID_RUNTIME)
	goto hard_way;
#  endif
    result = PerlProc_waitpid(pid,statusp,flags);
    goto finish;
#endif
#if !defined(HAS_WAITPID) && defined(HAS_WAIT4)
    result = wait4(pid,statusp,flags,NULL);
    goto finish;
#endif
#ifdef PERL_USES_PL_PIDSTATUS
#if defined(HAS_WAITPID) && defined(HAS_WAITPID_RUNTIME)
  hard_way:
#endif
    {
	if (flags)
	    Perl_croak(aTHX_ "Can't do waitpid with flags");
	else {
	    while ((result = PerlProc_wait(statusp)) != pid && pid > 0 && result >= 0)
		pidgone(result,*statusp);
	    if (result < 0)
		*statusp = -1;
	}
    }
#endif
#if defined(HAS_WAITPID) || defined(HAS_WAIT4)
  finish:
#endif
    if (result < 0 && errno == EINTR) {
	PERL_ASYNC_CHECK();
	errno = EINTR; /* reset in case a signal handler changed $! */
    }
    return result;
}
#endif /* !DOSISH || OS2 || WIN32 || NETWARE */

#ifdef PERL_USES_PL_PIDSTATUS
void
S_pidgone(pTHX_ Pid_t pid, int status)
{
    SV *sv;

    sv = *hv_fetch(PL_pidstatus,(const char*)&pid,sizeof(Pid_t),TRUE);
    SvUPGRADE(sv,SVt_IV);
    SvIV_set(sv, status);
    return;
}
#endif

#if defined(OS2)
int pclose();
#ifdef HAS_FORK
int					/* Cannot prototype with I32
					   in os2ish.h. */
my_syspclose(PerlIO *ptr)
#else
I32
Perl_my_pclose(pTHX_ PerlIO *ptr)
#endif
{
    /* Needs work for PerlIO ! */
    FILE * const f = PerlIO_findFILE(ptr);
    const I32 result = pclose(f);
    PerlIO_releaseFILE(ptr,f);
    return result;
}
#endif

#if defined(DJGPP)
int djgpp_pclose();
I32
Perl_my_pclose(pTHX_ PerlIO *ptr)
{
    /* Needs work for PerlIO ! */
    FILE * const f = PerlIO_findFILE(ptr);
    I32 result = djgpp_pclose(f);
    result = (result << 8) & 0xff00;
    PerlIO_releaseFILE(ptr,f);
    return result;
}
#endif

#define PERL_REPEATCPY_LINEAR 4
void
Perl_repeatcpy(char *to, const char *from, I32 len, IV count)
{
    PERL_ARGS_ASSERT_REPEATCPY;

    assert(len >= 0);

    if (count < 0)
	croak_memory_wrap();

    if (len == 1)
	memset(to, *from, count);
    else if (count) {
	char *p = to;
	IV items, linear, half;

	linear = count < PERL_REPEATCPY_LINEAR ? count : PERL_REPEATCPY_LINEAR;
	for (items = 0; items < linear; ++items) {
	    const char *q = from;
	    IV todo;
	    for (todo = len; todo > 0; todo--)
		*p++ = *q++;
        }

	half = count / 2;
	while (items <= half) {
	    IV size = items * len;
	    memcpy(p, to, size);
	    p     += size;
	    items *= 2;
	}

	if (count > items)
	    memcpy(p, to, (count - items) * len);
    }
}

#ifndef HAS_RENAME
I32
Perl_same_dirent(pTHX_ const char *a, const char *b)
{
    char *fa = strrchr(a,'/');
    char *fb = strrchr(b,'/');
    Stat_t tmpstatbuf1;
    Stat_t tmpstatbuf2;
    SV * const tmpsv = sv_newmortal();

    PERL_ARGS_ASSERT_SAME_DIRENT;

    if (fa)
	fa++;
    else
	fa = a;
    if (fb)
	fb++;
    else
	fb = b;
    if (strNE(a,b))
	return FALSE;
    if (fa == a)
	sv_setpvs(tmpsv, ".");
    else
	sv_setpvn(tmpsv, a, fa - a);
    if (PerlLIO_stat(SvPVX_const(tmpsv), &tmpstatbuf1) < 0)
	return FALSE;
    if (fb == b)
	sv_setpvs(tmpsv, ".");
    else
	sv_setpvn(tmpsv, b, fb - b);
    if (PerlLIO_stat(SvPVX_const(tmpsv), &tmpstatbuf2) < 0)
	return FALSE;
    return tmpstatbuf1.st_dev == tmpstatbuf2.st_dev &&
	   tmpstatbuf1.st_ino == tmpstatbuf2.st_ino;
}
#endif /* !HAS_RENAME */

char*
Perl_find_script(pTHX_ const char *scriptname, bool dosearch,
		 const char *const *const search_ext, I32 flags)
{
    const char *xfound = NULL;
    char *xfailed = NULL;
    char tmpbuf[MAXPATHLEN];
    char *s;
    I32 len = 0;
    int retval;
    char *bufend;
#if defined(DOSISH) && !defined(OS2)
#  define SEARCH_EXTS ".bat", ".cmd", NULL
#  define MAX_EXT_LEN 4
#endif
#ifdef OS2
#  define SEARCH_EXTS ".cmd", ".btm", ".bat", ".pl", NULL
#  define MAX_EXT_LEN 4
#endif
#ifdef VMS
#  define SEARCH_EXTS ".pl", ".com", NULL
#  define MAX_EXT_LEN 4
#endif
    /* additional extensions to try in each dir if scriptname not found */
#ifdef SEARCH_EXTS
    static const char *const exts[] = { SEARCH_EXTS };
    const char *const *const ext = search_ext ? search_ext : exts;
    int extidx = 0, i = 0;
    const char *curext = NULL;
#else
    PERL_UNUSED_ARG(search_ext);
#  define MAX_EXT_LEN 0
#endif

    PERL_ARGS_ASSERT_FIND_SCRIPT;

    /*
     * If dosearch is true and if scriptname does not contain path
     * delimiters, search the PATH for scriptname.
     *
     * If SEARCH_EXTS is also defined, will look for each
     * scriptname{SEARCH_EXTS} whenever scriptname is not found
     * while searching the PATH.
     *
     * Assuming SEARCH_EXTS is C<".foo",".bar",NULL>, PATH search
     * proceeds as follows:
     *   If DOSISH or VMSISH:
     *     + look for ./scriptname{,.foo,.bar}
     *     + search the PATH for scriptname{,.foo,.bar}
     *
     *   If !DOSISH:
     *     + look *only* in the PATH for scriptname{,.foo,.bar} (note
     *       this will not look in '.' if it's not in the PATH)
     */
    tmpbuf[0] = '\0';

#ifdef VMS
#  ifdef ALWAYS_DEFTYPES
    len = strlen(scriptname);
    if (!(len == 1 && *scriptname == '-') && scriptname[len-1] != ':') {
	int idx = 0, deftypes = 1;
	bool seen_dot = 1;

	const int hasdir = !dosearch || (strpbrk(scriptname,":[</") != NULL);
#  else
    if (dosearch) {
	int idx = 0, deftypes = 1;
	bool seen_dot = 1;

	const int hasdir = (strpbrk(scriptname,":[</") != NULL);
#  endif
	/* The first time through, just add SEARCH_EXTS to whatever we
	 * already have, so we can check for default file types. */
	while (deftypes ||
	       (!hasdir && my_trnlnm("DCL$PATH",tmpbuf,idx++)) )
	{
	    Stat_t statbuf;
	    if (deftypes) {
		deftypes = 0;
		*tmpbuf = '\0';
	    }
	    if ((strlen(tmpbuf) + strlen(scriptname)
		 + MAX_EXT_LEN) >= sizeof tmpbuf)
		continue;	/* don't search dir with too-long name */
	    my_strlcat(tmpbuf, scriptname, sizeof(tmpbuf));
#else  /* !VMS */

#ifdef DOSISH
    if (strEQ(scriptname, "-"))
 	dosearch = 0;
    if (dosearch) {		/* Look in '.' first. */
	const char *cur = scriptname;
#ifdef SEARCH_EXTS
	if ((curext = strrchr(scriptname,'.')))	/* possible current ext */
	    while (ext[i])
		if (strEQ(ext[i++],curext)) {
		    extidx = -1;		/* already has an ext */
		    break;
		}
	do {
#endif
	    DEBUG_p(PerlIO_printf(Perl_debug_log,
				  "Looking for %s\n",cur));
	    {
		Stat_t statbuf;
		if (PerlLIO_stat(cur,&statbuf) >= 0
		    && !S_ISDIR(statbuf.st_mode)) {
		    dosearch = 0;
		    scriptname = cur;
#ifdef SEARCH_EXTS
		    break;
#endif
		}
	    }
#ifdef SEARCH_EXTS
	    if (cur == scriptname) {
		len = strlen(scriptname);
		if (len+MAX_EXT_LEN+1 >= sizeof(tmpbuf))
		    break;
		my_strlcpy(tmpbuf, scriptname, sizeof(tmpbuf));
		cur = tmpbuf;
	    }
	} while (extidx >= 0 && ext[extidx]	/* try an extension? */
		 && my_strlcpy(tmpbuf+len, ext[extidx++], sizeof(tmpbuf) - len));
#endif
    }
#endif

    if (dosearch && !strchr(scriptname, '/')
#ifdef DOSISH
		 && !strchr(scriptname, '\\')
#endif
		 && (s = PerlEnv_getenv("PATH")))
    {
	bool seen_dot = 0;

	bufend = s + strlen(s);
	while (s < bufend) {
	    Stat_t statbuf;
#  ifdef DOSISH
	    for (len = 0; *s
		    && *s != ';'; len++, s++) {
		if (len < sizeof tmpbuf)
		    tmpbuf[len] = *s;
	    }
	    if (len < sizeof tmpbuf)
		tmpbuf[len] = '\0';
#  else
	    s = delimcpy(tmpbuf, tmpbuf + sizeof tmpbuf, s, bufend,
			':',
			&len);
#  endif
	    if (s < bufend)
		s++;
	    if (len + 1 + strlen(scriptname) + MAX_EXT_LEN >= sizeof tmpbuf)
		continue;	/* don't search dir with too-long name */
	    if (len
#  ifdef DOSISH
		&& tmpbuf[len - 1] != '/'
		&& tmpbuf[len - 1] != '\\'
#  endif
	       )
		tmpbuf[len++] = '/';
	    if (len == 2 && tmpbuf[0] == '.')
		seen_dot = 1;
	    (void)my_strlcpy(tmpbuf + len, scriptname, sizeof(tmpbuf) - len);
#endif  /* !VMS */

#ifdef SEARCH_EXTS
	    len = strlen(tmpbuf);
	    if (extidx > 0)	/* reset after previous loop */
		extidx = 0;
	    do {
#endif
	    	DEBUG_p(PerlIO_printf(Perl_debug_log, "Looking for %s\n",tmpbuf));
		retval = PerlLIO_stat(tmpbuf,&statbuf);
		if (S_ISDIR(statbuf.st_mode)) {
		    retval = -1;
		}
#ifdef SEARCH_EXTS
	    } while (  retval < 0		/* not there */
		    && extidx>=0 && ext[extidx]	/* try an extension? */
		    && my_strlcpy(tmpbuf+len, ext[extidx++], sizeof(tmpbuf) - len)
		);
#endif
	    if (retval < 0)
		continue;
	    if (S_ISREG(statbuf.st_mode)
		&& cando(S_IRUSR,TRUE,&statbuf)
#if !defined(DOSISH)
		&& cando(S_IXUSR,TRUE,&statbuf)
#endif
		)
	    {
		xfound = tmpbuf;		/* bingo! */
		break;
	    }
	    if (!xfailed)
		xfailed = savepv(tmpbuf);
	}
#ifndef DOSISH
	{
	    Stat_t statbuf;
	    if (!xfound && !seen_dot && !xfailed &&
		(PerlLIO_stat(scriptname,&statbuf) < 0
		 || S_ISDIR(statbuf.st_mode)))
#endif
		seen_dot = 1;			/* Disable message. */
#ifndef DOSISH
	}
#endif
	if (!xfound) {
	    if (flags & 1) {			/* do or die? */
		/* diag_listed_as: Can't execute %s */
		Perl_croak(aTHX_ "Can't %s %s%s%s",
		      (xfailed ? "execute" : "find"),
		      (xfailed ? xfailed : scriptname),
		      (xfailed ? "" : " on PATH"),
		      (xfailed || seen_dot) ? "" : ", '.' not in PATH");
	    }
	    scriptname = NULL;
	}
	Safefree(xfailed);
	scriptname = xfound;
    }
    return (scriptname ? savepv(scriptname) : NULL);
}

#ifndef PERL_GET_CONTEXT_DEFINED

void *
Perl_get_context(void)
{
#if defined(USE_ITHREADS)
    dVAR;
#  ifdef OLD_PTHREADS_API
    pthread_addr_t t;
    int error = pthread_getspecific(PL_thr_key, &t)
    if (error)
	Perl_croak_nocontext("panic: pthread_getspecific, error=%d", error);
    return (void*)t;
#  else
#    ifdef I_MACH_CTHREADS
    return (void*)cthread_data(cthread_self());
#    else
    return (void*)PTHREAD_GETSPECIFIC(PL_thr_key);
#    endif
#  endif
#else
    return (void*)NULL;
#endif
}

void
Perl_set_context(void *t)
{
#if defined(USE_ITHREADS)
    dVAR;
#endif
    PERL_ARGS_ASSERT_SET_CONTEXT;
#if defined(USE_ITHREADS)
#  ifdef I_MACH_CTHREADS
    cthread_set_data(cthread_self(), t);
#  else
    {
	const int error = pthread_setspecific(PL_thr_key, t);
	if (error)
	    Perl_croak_nocontext("panic: pthread_setspecific, error=%d", error);
    }
#  endif
#else
    PERL_UNUSED_ARG(t);
#endif
}

#endif /* !PERL_GET_CONTEXT_DEFINED */

#if defined(PERL_GLOBAL_STRUCT) && !defined(PERL_GLOBAL_STRUCT_PRIVATE)
struct perl_vars *
Perl_GetVars(pTHX)
{
    PERL_UNUSED_CONTEXT;
    return &PL_Vars;
}
#endif

char **
Perl_get_op_names(pTHX)
{
    PERL_UNUSED_CONTEXT;
    return (char **)PL_op_name;
}

char **
Perl_get_op_descs(pTHX)
{
    PERL_UNUSED_CONTEXT;
    return (char **)PL_op_desc;
}

const char *
Perl_get_no_modify(pTHX)
{
    PERL_UNUSED_CONTEXT;
    return PL_no_modify;
}

U32 *
Perl_get_opargs(pTHX)
{
    PERL_UNUSED_CONTEXT;
    return (U32 *)PL_opargs;
}

PPADDR_t*
Perl_get_ppaddr(pTHX)
{
    dVAR;
    PERL_UNUSED_CONTEXT;
    return (PPADDR_t*)PL_ppaddr;
}

#ifndef HAS_GETENV_LEN
char *
Perl_getenv_len(pTHX_ const char *env_elem, unsigned long *len)
{
    char * const env_trans = PerlEnv_getenv(env_elem);
    PERL_UNUSED_CONTEXT;
    PERL_ARGS_ASSERT_GETENV_LEN;
    if (env_trans)
	*len = strlen(env_trans);
    return env_trans;
}
#endif


MGVTBL*
Perl_get_vtbl(pTHX_ int vtbl_id)
{
    PERL_UNUSED_CONTEXT;

    return (vtbl_id < 0 || vtbl_id >= magic_vtable_max)
	? NULL : (MGVTBL*)PL_magic_vtables + vtbl_id;
}

I32
Perl_my_fflush_all(pTHX)
{
#if defined(USE_PERLIO) || defined(FFLUSH_NULL)
    return PerlIO_flush(NULL);
#else
# if defined(HAS__FWALK)
    extern int fflush(FILE *);
    /* undocumented, unprototyped, but very useful BSDism */
    extern void _fwalk(int (*)(FILE *));
    _fwalk(&fflush);
    return 0;
# else
#  if defined(FFLUSH_ALL) && defined(HAS_STDIO_STREAM_ARRAY)
    long open_max = -1;
#   ifdef PERL_FFLUSH_ALL_FOPEN_MAX
    open_max = PERL_FFLUSH_ALL_FOPEN_MAX;
#   else
#    if defined(HAS_SYSCONF) && defined(_SC_OPEN_MAX)
    open_max = sysconf(_SC_OPEN_MAX);
#     else
#      ifdef FOPEN_MAX
    open_max = FOPEN_MAX;
#      else
#       ifdef OPEN_MAX
    open_max = OPEN_MAX;
#       else
#        ifdef _NFILE
    open_max = _NFILE;
#        endif
#       endif
#      endif
#     endif
#    endif
    if (open_max > 0) {
      long i;
      for (i = 0; i < open_max; i++)
	    if (STDIO_STREAM_ARRAY[i]._file >= 0 &&
		STDIO_STREAM_ARRAY[i]._file < open_max &&
		STDIO_STREAM_ARRAY[i]._flag)
		PerlIO_flush(&STDIO_STREAM_ARRAY[i]);
      return 0;
    }
#  endif
    SETERRNO(EBADF,RMS_IFI);
    return EOF;
# endif
#endif
}

void
Perl_report_wrongway_fh(pTHX_ const GV *gv, const char have)
{
    if (ckWARN(WARN_IO)) {
        HEK * const name
           = gv && (isGV_with_GP(gv))
                ? GvENAME_HEK((gv))
                : NULL;
	const char * const direction = have == '>' ? "out" : "in";

	if (name && HEK_LEN(name))
	    Perl_warner(aTHX_ packWARN(WARN_IO),
			"Filehandle %"HEKf" opened only for %sput",
			HEKfARG(name), direction);
	else
	    Perl_warner(aTHX_ packWARN(WARN_IO),
			"Filehandle opened only for %sput", direction);
    }
}

void
Perl_report_evil_fh(pTHX_ const GV *gv)
{
    const IO *io = gv ? GvIO(gv) : NULL;
    const PERL_BITFIELD16 op = PL_op->op_type;
    const char *vile;
    I32 warn_type;

    if (io && IoTYPE(io) == IoTYPE_CLOSED) {
	vile = "closed";
	warn_type = WARN_CLOSED;
    }
    else {
	vile = "unopened";
	warn_type = WARN_UNOPENED;
    }

    if (ckWARN(warn_type)) {
        SV * const name
            = gv && isGV_with_GP(gv) && GvENAMELEN(gv) ?
                                     sv_2mortal(newSVhek(GvENAME_HEK(gv))) : NULL;
	const char * const pars =
	    (const char *)(OP_IS_FILETEST(op) ? "" : "()");
	const char * const func =
	    (const char *)
	    (op == OP_READLINE || op == OP_RCATLINE
				 ? "readline"  :	/* "<HANDLE>" not nice */
	     op == OP_LEAVEWRITE ? "write" :		/* "write exit" not nice */
	     PL_op_desc[op]);
	const char * const type =
	    (const char *)
	    (OP_IS_SOCKET(op) || (io && IoTYPE(io) == IoTYPE_SOCKET)
	     ? "socket" : "filehandle");
	const bool have_name = name && SvCUR(name);
	Perl_warner(aTHX_ packWARN(warn_type),
		   "%s%s on %s %s%s%"SVf, func, pars, vile, type,
		    have_name ? " " : "",
		    SVfARG(have_name ? name : &PL_sv_no));
	if (io && IoDIRP(io) && !(IoFLAGS(io) & IOf_FAKE_DIRP))
		Perl_warner(
			    aTHX_ packWARN(warn_type),
			"\t(Are you trying to call %s%s on dirhandle%s%"SVf"?)\n",
			func, pars, have_name ? " " : "",
			SVfARG(have_name ? name : &PL_sv_no)
			    );
    }
}

/* To workaround core dumps from the uninitialised tm_zone we get the
 * system to give us a reasonable struct to copy.  This fix means that
 * strftime uses the tm_zone and tm_gmtoff values returned by
 * localtime(time()). That should give the desired result most of the
 * time. But probably not always!
 *
 * This does not address tzname aspects of NETaa14816.
 *
 */

#ifdef __GLIBC__
# ifndef STRUCT_TM_HASZONE
#    define STRUCT_TM_HASZONE
# endif
#endif

#ifdef STRUCT_TM_HASZONE /* Backward compat */
# ifndef HAS_TM_TM_ZONE
#    define HAS_TM_TM_ZONE
# endif
#endif

void
Perl_init_tm(pTHX_ struct tm *ptm)	/* see mktime, strftime and asctime */
{
#ifdef HAS_TM_TM_ZONE
    Time_t now;
    const struct tm* my_tm;
    PERL_UNUSED_CONTEXT;
    PERL_ARGS_ASSERT_INIT_TM;
    (void)time(&now);
    my_tm = localtime(&now);
    if (my_tm)
        Copy(my_tm, ptm, 1, struct tm);
#else
    PERL_UNUSED_CONTEXT;
    PERL_ARGS_ASSERT_INIT_TM;
    PERL_UNUSED_ARG(ptm);
#endif
}

/*
 * mini_mktime - normalise struct tm values without the localtime()
 * semantics (and overhead) of mktime().
 */
void
Perl_mini_mktime(struct tm *ptm)
{
    int yearday;
    int secs;
    int month, mday, year, jday;
    int odd_cent, odd_year;

    PERL_ARGS_ASSERT_MINI_MKTIME;

#define	DAYS_PER_YEAR	365
#define	DAYS_PER_QYEAR	(4*DAYS_PER_YEAR+1)
#define	DAYS_PER_CENT	(25*DAYS_PER_QYEAR-1)
#define	DAYS_PER_QCENT	(4*DAYS_PER_CENT+1)
#define	SECS_PER_HOUR	(60*60)
#define	SECS_PER_DAY	(24*SECS_PER_HOUR)
/* parentheses deliberately absent on these two, otherwise they don't work */
#define	MONTH_TO_DAYS	153/5
#define	DAYS_TO_MONTH	5/153
/* offset to bias by March (month 4) 1st between month/mday & year finding */
#define	YEAR_ADJUST	(4*MONTH_TO_DAYS+1)
/* as used here, the algorithm leaves Sunday as day 1 unless we adjust it */
#define	WEEKDAY_BIAS	6	/* (1+6)%7 makes Sunday 0 again */

/*
 * Year/day algorithm notes:
 *
 * With a suitable offset for numeric value of the month, one can find
 * an offset into the year by considering months to have 30.6 (153/5) days,
 * using integer arithmetic (i.e., with truncation).  To avoid too much
 * messing about with leap days, we consider January and February to be
 * the 13th and 14th month of the previous year.  After that transformation,
 * we need the month index we use to be high by 1 from 'normal human' usage,
 * so the month index values we use run from 4 through 15.
 *
 * Given that, and the rules for the Gregorian calendar (leap years are those
 * divisible by 4 unless also divisible by 100, when they must be divisible
 * by 400 instead), we can simply calculate the number of days since some
 * arbitrary 'beginning of time' by futzing with the (adjusted) year number,
 * the days we derive from our month index, and adding in the day of the
 * month.  The value used here is not adjusted for the actual origin which
 * it normally would use (1 January A.D. 1), since we're not exposing it.
 * We're only building the value so we can turn around and get the
 * normalised values for the year, month, day-of-month, and day-of-year.
 *
 * For going backward, we need to bias the value we're using so that we find
 * the right year value.  (Basically, we don't want the contribution of
 * March 1st to the number to apply while deriving the year).  Having done
 * that, we 'count up' the contribution to the year number by accounting for
 * full quadracenturies (400-year periods) with their extra leap days, plus
 * the contribution from full centuries (to avoid counting in the lost leap
 * days), plus the contribution from full quad-years (to count in the normal
 * leap days), plus the leftover contribution from any non-leap years.
 * At this point, if we were working with an actual leap day, we'll have 0
 * days left over.  This is also true for March 1st, however.  So, we have
 * to special-case that result, and (earlier) keep track of the 'odd'
 * century and year contributions.  If we got 4 extra centuries in a qcent,
 * or 4 extra years in a qyear, then it's a leap day and we call it 29 Feb.
 * Otherwise, we add back in the earlier bias we removed (the 123 from
 * figuring in March 1st), find the month index (integer division by 30.6),
 * and the remainder is the day-of-month.  We then have to convert back to
 * 'real' months (including fixing January and February from being 14/15 in
 * the previous year to being in the proper year).  After that, to get
 * tm_yday, we work with the normalised year and get a new yearday value for
 * January 1st, which we subtract from the yearday value we had earlier,
 * representing the date we've re-built.  This is done from January 1
 * because tm_yday is 0-origin.
 *
 * Since POSIX time routines are only guaranteed to work for times since the
 * UNIX epoch (00:00:00 1 Jan 1970 UTC), the fact that this algorithm
 * applies Gregorian calendar rules even to dates before the 16th century
 * doesn't bother me.  Besides, you'd need cultural context for a given
 * date to know whether it was Julian or Gregorian calendar, and that's
 * outside the scope for this routine.  Since we convert back based on the
 * same rules we used to build the yearday, you'll only get strange results
 * for input which needed normalising, or for the 'odd' century years which
 * were leap years in the Julian calendar but not in the Gregorian one.
 * I can live with that.
 *
 * This algorithm also fails to handle years before A.D. 1 gracefully, but
 * that's still outside the scope for POSIX time manipulation, so I don't
 * care.
 */

    year = 1900 + ptm->tm_year;
    month = ptm->tm_mon;
    mday = ptm->tm_mday;
    jday = 0;
    if (month >= 2)
	month+=2;
    else
	month+=14, year--;
    yearday = DAYS_PER_YEAR * year + year/4 - year/100 + year/400;
    yearday += month*MONTH_TO_DAYS + mday + jday;
    /*
     * Note that we don't know when leap-seconds were or will be,
     * so we have to trust the user if we get something which looks
     * like a sensible leap-second.  Wild values for seconds will
     * be rationalised, however.
     */
    if ((unsigned) ptm->tm_sec <= 60) {
	secs = 0;
    }
    else {
	secs = ptm->tm_sec;
	ptm->tm_sec = 0;
    }
    secs += 60 * ptm->tm_min;
    secs += SECS_PER_HOUR * ptm->tm_hour;
    if (secs < 0) {
	if (secs-(secs/SECS_PER_DAY*SECS_PER_DAY) < 0) {
	    /* got negative remainder, but need positive time */
	    /* back off an extra day to compensate */
	    yearday += (secs/SECS_PER_DAY)-1;
	    secs -= SECS_PER_DAY * (secs/SECS_PER_DAY - 1);
	}
	else {
	    yearday += (secs/SECS_PER_DAY);
	    secs -= SECS_PER_DAY * (secs/SECS_PER_DAY);
	}
    }
    else if (secs >= SECS_PER_DAY) {
	yearday += (secs/SECS_PER_DAY);
	secs %= SECS_PER_DAY;
    }
    ptm->tm_hour = secs/SECS_PER_HOUR;
    secs %= SECS_PER_HOUR;
    ptm->tm_min = secs/60;
    secs %= 60;
    ptm->tm_sec += secs;
    /* done with time of day effects */
    /*
     * The algorithm for yearday has (so far) left it high by 428.
     * To avoid mistaking a legitimate Feb 29 as Mar 1, we need to
     * bias it by 123 while trying to figure out what year it
     * really represents.  Even with this tweak, the reverse
     * translation fails for years before A.D. 0001.
     * It would still fail for Feb 29, but we catch that one below.
     */
    jday = yearday;	/* save for later fixup vis-a-vis Jan 1 */
    yearday -= YEAR_ADJUST;
    year = (yearday / DAYS_PER_QCENT) * 400;
    yearday %= DAYS_PER_QCENT;
    odd_cent = yearday / DAYS_PER_CENT;
    year += odd_cent * 100;
    yearday %= DAYS_PER_CENT;
    year += (yearday / DAYS_PER_QYEAR) * 4;
    yearday %= DAYS_PER_QYEAR;
    odd_year = yearday / DAYS_PER_YEAR;
    year += odd_year;
    yearday %= DAYS_PER_YEAR;
    if (!yearday && (odd_cent==4 || odd_year==4)) { /* catch Feb 29 */
	month = 1;
	yearday = 29;
    }
    else {
	yearday += YEAR_ADJUST;	/* recover March 1st crock */
	month = yearday*DAYS_TO_MONTH;
	yearday -= month*MONTH_TO_DAYS;
	/* recover other leap-year adjustment */
	if (month > 13) {
	    month-=14;
	    year++;
	}
	else {
	    month-=2;
	}
    }
    ptm->tm_year = year - 1900;
    if (yearday) {
      ptm->tm_mday = yearday;
      ptm->tm_mon = month;
    }
    else {
      ptm->tm_mday = 31;
      ptm->tm_mon = month - 1;
    }
    /* re-build yearday based on Jan 1 to get tm_yday */
    year--;
    yearday = year*DAYS_PER_YEAR + year/4 - year/100 + year/400;
    yearday += 14*MONTH_TO_DAYS + 1;
    ptm->tm_yday = jday - yearday;
    ptm->tm_wday = (jday + WEEKDAY_BIAS) % 7;
}

char *
Perl_my_strftime(pTHX_ const char *fmt, int sec, int min, int hour, int mday, int mon, int year, int wday, int yday, int isdst)
{
#ifdef HAS_STRFTIME

  /* Note that yday and wday effectively are ignored by this function, as mini_mktime() overwrites them */

  char *buf;
  int buflen;
  struct tm mytm;
  int len;

  PERL_ARGS_ASSERT_MY_STRFTIME;

  init_tm(&mytm);	/* XXX workaround - see init_tm() above */
  mytm.tm_sec = sec;
  mytm.tm_min = min;
  mytm.tm_hour = hour;
  mytm.tm_mday = mday;
  mytm.tm_mon = mon;
  mytm.tm_year = year;
  mytm.tm_wday = wday;
  mytm.tm_yday = yday;
  mytm.tm_isdst = isdst;
  mini_mktime(&mytm);
  /* use libc to get the values for tm_gmtoff and tm_zone [perl #18238] */
#if defined(HAS_MKTIME) && (defined(HAS_TM_TM_GMTOFF) || defined(HAS_TM_TM_ZONE))
  STMT_START {
    struct tm mytm2;
    mytm2 = mytm;
    mktime(&mytm2);
#ifdef HAS_TM_TM_GMTOFF
    mytm.tm_gmtoff = mytm2.tm_gmtoff;
#endif
#ifdef HAS_TM_TM_ZONE
    mytm.tm_zone = mytm2.tm_zone;
#endif
  } STMT_END;
#endif
  buflen = 64;
  Newx(buf, buflen, char);

  GCC_DIAG_IGNORE(-Wformat-nonliteral); /* fmt checked by caller */
  len = strftime(buf, buflen, fmt, &mytm);
  GCC_DIAG_RESTORE;

  /*
  ** The following is needed to handle to the situation where
  ** tmpbuf overflows.  Basically we want to allocate a buffer
  ** and try repeatedly.  The reason why it is so complicated
  ** is that getting a return value of 0 from strftime can indicate
  ** one of the following:
  ** 1. buffer overflowed,
  ** 2. illegal conversion specifier, or
  ** 3. the format string specifies nothing to be returned(not
  **	  an error).  This could be because format is an empty string
  **    or it specifies %p that yields an empty string in some locale.
  ** If there is a better way to make it portable, go ahead by
  ** all means.
  */
  if ((len > 0 && len < buflen) || (len == 0 && *fmt == '\0'))
    return buf;
  else {
    /* Possibly buf overflowed - try again with a bigger buf */
    const int fmtlen = strlen(fmt);
    int bufsize = fmtlen + buflen;

    Renew(buf, bufsize, char);
    while (buf) {

      GCC_DIAG_IGNORE(-Wformat-nonliteral); /* fmt checked by caller */
      buflen = strftime(buf, bufsize, fmt, &mytm);
      GCC_DIAG_RESTORE;

      if (buflen > 0 && buflen < bufsize)
	break;
      /* heuristic to prevent out-of-memory errors */
      if (bufsize > 100*fmtlen) {
	Safefree(buf);
	buf = NULL;
	break;
      }
      bufsize *= 2;
      Renew(buf, bufsize, char);
    }
    return buf;
  }
#else
  Perl_croak(aTHX_ "panic: no strftime");
  return NULL;
#endif
}


#define SV_CWD_RETURN_UNDEF \
sv_setsv(sv, &PL_sv_undef); \
return FALSE

#define SV_CWD_ISDOT(dp) \
    (dp->d_name[0] == '.' && (dp->d_name[1] == '\0' || \
	(dp->d_name[1] == '.' && dp->d_name[2] == '\0')))

/*
=head1 Miscellaneous Functions

=for apidoc getcwd_sv

Fill C<sv> with current working directory

=cut
*/

/* Originally written in Perl by John Bazik; rewritten in C by Ben Sugars.
 * rewritten again by dougm, optimized for use with xs TARG, and to prefer
 * getcwd(3) if available
 * Comments from the original:
 *     This is a faster version of getcwd.  It's also more dangerous
 *     because you might chdir out of a directory that you can't chdir
 *     back into. */

int
Perl_getcwd_sv(pTHX_ SV *sv)
{
#ifndef PERL_MICRO
    SvTAINTED_on(sv);

    PERL_ARGS_ASSERT_GETCWD_SV;

#ifdef HAS_GETCWD
    {
	char buf[MAXPATHLEN];

	/* Some getcwd()s automatically allocate a buffer of the given
	 * size from the heap if they are given a NULL buffer pointer.
	 * The problem is that this behaviour is not portable. */
	if (getcwd(buf, sizeof(buf) - 1)) {
	    sv_setpv(sv, buf);
	    return TRUE;
	}
	else {
	    sv_setsv(sv, &PL_sv_undef);
	    return FALSE;
	}
    }

#else

    Stat_t statbuf;
    int orig_cdev, orig_cino, cdev, cino, odev, oino, tdev, tino;
    int pathlen=0;
    Direntry_t *dp;

    SvUPGRADE(sv, SVt_PV);

    if (PerlLIO_lstat(".", &statbuf) < 0) {
	SV_CWD_RETURN_UNDEF;
    }

    orig_cdev = statbuf.st_dev;
    orig_cino = statbuf.st_ino;
    cdev = orig_cdev;
    cino = orig_cino;

    for (;;) {
	DIR *dir;
	int namelen;
	odev = cdev;
	oino = cino;

	if (PerlDir_chdir("..") < 0) {
	    SV_CWD_RETURN_UNDEF;
	}
	if (PerlLIO_stat(".", &statbuf) < 0) {
	    SV_CWD_RETURN_UNDEF;
	}

	cdev = statbuf.st_dev;
	cino = statbuf.st_ino;

	if (odev == cdev && oino == cino) {
	    break;
	}
	if (!(dir = PerlDir_open("."))) {
	    SV_CWD_RETURN_UNDEF;
	}

	while ((dp = PerlDir_read(dir)) != NULL) {
#ifdef DIRNAMLEN
	    namelen = dp->d_namlen;
#else
	    namelen = strlen(dp->d_name);
#endif
	    /* skip . and .. */
	    if (SV_CWD_ISDOT(dp)) {
		continue;
	    }

	    if (PerlLIO_lstat(dp->d_name, &statbuf) < 0) {
		SV_CWD_RETURN_UNDEF;
	    }

	    tdev = statbuf.st_dev;
	    tino = statbuf.st_ino;
	    if (tino == oino && tdev == odev) {
		break;
	    }
	}

	if (!dp) {
	    SV_CWD_RETURN_UNDEF;
	}

	if (pathlen + namelen + 1 >= MAXPATHLEN) {
	    SV_CWD_RETURN_UNDEF;
	}

	SvGROW(sv, pathlen + namelen + 1);

	if (pathlen) {
	    /* shift down */
	    Move(SvPVX_const(sv), SvPVX(sv) + namelen + 1, pathlen, char);
	}

	/* prepend current directory to the front */
	*SvPVX(sv) = '/';
	Move(dp->d_name, SvPVX(sv)+1, namelen, char);
	pathlen += (namelen + 1);

#ifdef VOID_CLOSEDIR
	PerlDir_close(dir);
#else
	if (PerlDir_close(dir) < 0) {
	    SV_CWD_RETURN_UNDEF;
	}
#endif
    }

    if (pathlen) {
	SvCUR_set(sv, pathlen);
	*SvEND(sv) = '\0';
	SvPOK_only(sv);

	if (PerlDir_chdir(SvPVX_const(sv)) < 0) {
	    SV_CWD_RETURN_UNDEF;
	}
    }
    if (PerlLIO_stat(".", &statbuf) < 0) {
	SV_CWD_RETURN_UNDEF;
    }

    cdev = statbuf.st_dev;
    cino = statbuf.st_ino;

    if (cdev != orig_cdev || cino != orig_cino) {
	Perl_croak(aTHX_ "Unstable directory path, "
		   "current directory changed unexpectedly");
    }

    return TRUE;
#endif

#else
    return FALSE;
#endif
}

#include "vutil.c"

#if !defined(HAS_SOCKETPAIR) && defined(HAS_SOCKET) && defined(AF_INET) && defined(PF_INET) && defined(SOCK_DGRAM) && defined(HAS_SELECT)
#   define EMULATE_SOCKETPAIR_UDP
#endif

#ifdef EMULATE_SOCKETPAIR_UDP
static int
S_socketpair_udp (int fd[2]) {
    dTHX;
    /* Fake a datagram socketpair using UDP to localhost.  */
    int sockets[2] = {-1, -1};
    struct sockaddr_in addresses[2];
    int i;
    Sock_size_t size = sizeof(struct sockaddr_in);
    unsigned short port;
    int got;

    memset(&addresses, 0, sizeof(addresses));
    i = 1;
    do {
	sockets[i] = PerlSock_socket(AF_INET, SOCK_DGRAM, PF_INET);
	if (sockets[i] == -1)
	    goto tidy_up_and_fail;

	addresses[i].sin_family = AF_INET;
	addresses[i].sin_addr.s_addr = htonl(INADDR_LOOPBACK);
	addresses[i].sin_port = 0;	/* kernel choses port.  */
	if (PerlSock_bind(sockets[i], (struct sockaddr *) &addresses[i],
		sizeof(struct sockaddr_in)) == -1)
	    goto tidy_up_and_fail;
    } while (i--);

    /* Now have 2 UDP sockets. Find out which port each is connected to, and
       for each connect the other socket to it.  */
    i = 1;
    do {
	if (PerlSock_getsockname(sockets[i], (struct sockaddr *) &addresses[i],
		&size) == -1)
	    goto tidy_up_and_fail;
	if (size != sizeof(struct sockaddr_in))
	    goto abort_tidy_up_and_fail;
	/* !1 is 0, !0 is 1 */
	if (PerlSock_connect(sockets[!i], (struct sockaddr *) &addresses[i],
		sizeof(struct sockaddr_in)) == -1)
	    goto tidy_up_and_fail;
    } while (i--);

    /* Now we have 2 sockets connected to each other. I don't trust some other
       process not to have already sent a packet to us (by random) so send
       a packet from each to the other.  */
    i = 1;
    do {
	/* I'm going to send my own port number.  As a short.
	   (Who knows if someone somewhere has sin_port as a bitfield and needs
	   this routine. (I'm assuming crays have socketpair)) */
	port = addresses[i].sin_port;
	got = PerlLIO_write(sockets[i], &port, sizeof(port));
	if (got != sizeof(port)) {
	    if (got == -1)
		goto tidy_up_and_fail;
	    goto abort_tidy_up_and_fail;
	}
    } while (i--);

    /* Packets sent. I don't trust them to have arrived though.
       (As I understand it Solaris TCP stack is multithreaded. Non-blocking
       connect to localhost will use a second kernel thread. In 2.6 the
       first thread running the connect() returns before the second completes,
       so EINPROGRESS> In 2.7 the improved stack is faster and connect()
       returns 0. Poor programs have tripped up. One poor program's authors'
       had a 50-1 reverse stock split. Not sure how connected these were.)
       So I don't trust someone not to have an unpredictable UDP stack.
    */

    {
	struct timeval waitfor = {0, 100000}; /* You have 0.1 seconds */
	int max = sockets[1] > sockets[0] ? sockets[1] : sockets[0];
	fd_set rset;

	FD_ZERO(&rset);
	FD_SET((unsigned int)sockets[0], &rset);
	FD_SET((unsigned int)sockets[1], &rset);

	got = PerlSock_select(max + 1, &rset, NULL, NULL, &waitfor);
	if (got != 2 || !FD_ISSET(sockets[0], &rset)
		|| !FD_ISSET(sockets[1], &rset)) {
	    /* I hope this is portable and appropriate.  */
	    if (got == -1)
		goto tidy_up_and_fail;
	    goto abort_tidy_up_and_fail;
	}
    }

    /* And the paranoia department even now doesn't trust it to have arrive
       (hence MSG_DONTWAIT). Or that what arrives was sent by us.  */
    {
	struct sockaddr_in readfrom;
	unsigned short buffer[2];

	i = 1;
	do {
#ifdef MSG_DONTWAIT
	    got = PerlSock_recvfrom(sockets[i], (char *) &buffer,
		    sizeof(buffer), MSG_DONTWAIT,
		    (struct sockaddr *) &readfrom, &size);
#else
	    got = PerlSock_recvfrom(sockets[i], (char *) &buffer,
		    sizeof(buffer), 0,
		    (struct sockaddr *) &readfrom, &size);
#endif

	    if (got == -1)
		goto tidy_up_and_fail;
	    if (got != sizeof(port)
		    || size != sizeof(struct sockaddr_in)
		    /* Check other socket sent us its port.  */
		    || buffer[0] != (unsigned short) addresses[!i].sin_port
		    /* Check kernel says we got the datagram from that socket */
		    || readfrom.sin_family != addresses[!i].sin_family
		    || readfrom.sin_addr.s_addr != addresses[!i].sin_addr.s_addr
		    || readfrom.sin_port != addresses[!i].sin_port)
		goto abort_tidy_up_and_fail;
	} while (i--);
    }
    /* My caller (my_socketpair) has validated that this is non-NULL  */
    fd[0] = sockets[0];
    fd[1] = sockets[1];
    /* I hereby declare this connection open.  May God bless all who cross
       her.  */
    return 0;

  abort_tidy_up_and_fail:
    errno = ECONNABORTED;
  tidy_up_and_fail:
    {
	dSAVE_ERRNO;
	if (sockets[0] != -1)
	    PerlLIO_close(sockets[0]);
	if (sockets[1] != -1)
	    PerlLIO_close(sockets[1]);
	RESTORE_ERRNO;
	return -1;
    }
}
#endif /*  EMULATE_SOCKETPAIR_UDP */

#if !defined(HAS_SOCKETPAIR) && defined(HAS_SOCKET) && defined(AF_INET) && defined(PF_INET)
int
Perl_my_socketpair (int family, int type, int protocol, int fd[2]) {
    /* Stevens says that family must be AF_LOCAL, protocol 0.
       I'm going to enforce that, then ignore it, and use TCP (or UDP).  */
    dTHXa(NULL);
    int listener = -1;
    int connector = -1;
    int acceptor = -1;
    struct sockaddr_in listen_addr;
    struct sockaddr_in connect_addr;
    Sock_size_t size;

    if (protocol
#ifdef AF_UNIX
	|| family != AF_UNIX
#endif
    ) {
	errno = EAFNOSUPPORT;
	return -1;
    }
    if (!fd) {
	errno = EINVAL;
	return -1;
    }

#ifdef EMULATE_SOCKETPAIR_UDP
    if (type == SOCK_DGRAM)
	return S_socketpair_udp(fd);
#endif

    aTHXa(PERL_GET_THX);
    listener = PerlSock_socket(AF_INET, type, 0);
    if (listener == -1)
	return -1;
    memset(&listen_addr, 0, sizeof(listen_addr));
    listen_addr.sin_family = AF_INET;
    listen_addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
    listen_addr.sin_port = 0;	/* kernel choses port.  */
    if (PerlSock_bind(listener, (struct sockaddr *) &listen_addr,
	    sizeof(listen_addr)) == -1)
	goto tidy_up_and_fail;
    if (PerlSock_listen(listener, 1) == -1)
	goto tidy_up_and_fail;

    connector = PerlSock_socket(AF_INET, type, 0);
    if (connector == -1)
	goto tidy_up_and_fail;
    /* We want to find out the port number to connect to.  */
    size = sizeof(connect_addr);
    if (PerlSock_getsockname(listener, (struct sockaddr *) &connect_addr,
	    &size) == -1)
	goto tidy_up_and_fail;
    if (size != sizeof(connect_addr))
	goto abort_tidy_up_and_fail;
    if (PerlSock_connect(connector, (struct sockaddr *) &connect_addr,
	    sizeof(connect_addr)) == -1)
	goto tidy_up_and_fail;

    size = sizeof(listen_addr);
    acceptor = PerlSock_accept(listener, (struct sockaddr *) &listen_addr,
	    &size);
    if (acceptor == -1)
	goto tidy_up_and_fail;
    if (size != sizeof(listen_addr))
	goto abort_tidy_up_and_fail;
    PerlLIO_close(listener);
    /* Now check we are talking to ourself by matching port and host on the
       two sockets.  */
    if (PerlSock_getsockname(connector, (struct sockaddr *) &connect_addr,
	    &size) == -1)
	goto tidy_up_and_fail;
    if (size != sizeof(connect_addr)
	    || listen_addr.sin_family != connect_addr.sin_family
	    || listen_addr.sin_addr.s_addr != connect_addr.sin_addr.s_addr
	    || listen_addr.sin_port != connect_addr.sin_port) {
	goto abort_tidy_up_and_fail;
    }
    fd[0] = connector;
    fd[1] = acceptor;
    return 0;

  abort_tidy_up_and_fail:
#ifdef ECONNABORTED
  errno = ECONNABORTED;	/* This would be the standard thing to do. */
#else
#  ifdef ECONNREFUSED
  errno = ECONNREFUSED;	/* E.g. Symbian does not have ECONNABORTED. */
#  else
  errno = ETIMEDOUT;	/* Desperation time. */
#  endif
#endif
  tidy_up_and_fail:
    {
	dSAVE_ERRNO;
	if (listener != -1)
	    PerlLIO_close(listener);
	if (connector != -1)
	    PerlLIO_close(connector);
	if (acceptor != -1)
	    PerlLIO_close(acceptor);
	RESTORE_ERRNO;
	return -1;
    }
}
#else
/* In any case have a stub so that there's code corresponding
 * to the my_socketpair in embed.fnc. */
int
Perl_my_socketpair (int family, int type, int protocol, int fd[2]) {
#ifdef HAS_SOCKETPAIR
    return socketpair(family, type, protocol, fd);
#else
    return -1;
#endif
}
#endif

/*

=for apidoc sv_nosharing

Dummy routine which "shares" an SV when there is no sharing module present.
Or "locks" it.  Or "unlocks" it.  In other
words, ignores its single SV argument.
Exists to avoid test for a C<NULL> function pointer and because it could
potentially warn under some level of strict-ness.

=cut
*/

void
Perl_sv_nosharing(pTHX_ SV *sv)
{
    PERL_UNUSED_CONTEXT;
    PERL_UNUSED_ARG(sv);
}

/*

=for apidoc sv_destroyable

Dummy routine which reports that object can be destroyed when there is no
sharing module present.  It ignores its single SV argument, and returns
'true'.  Exists to avoid test for a C<NULL> function pointer and because it
could potentially warn under some level of strict-ness.

=cut
*/

bool
Perl_sv_destroyable(pTHX_ SV *sv)
{
    PERL_UNUSED_CONTEXT;
    PERL_UNUSED_ARG(sv);
    return TRUE;
}

U32
Perl_parse_unicode_opts(pTHX_ const char **popt)
{
  const char *p = *popt;
  U32 opt = 0;

  PERL_ARGS_ASSERT_PARSE_UNICODE_OPTS;

  if (*p) {
       if (isDIGIT(*p)) {
            const char* endptr;
            UV uv;
            if (grok_atoUV(p, &uv, &endptr) && uv <= U32_MAX) {
                opt = (U32)uv;
                p = endptr;
                if (p && *p && *p != '\n' && *p != '\r') {
                    if (isSPACE(*p))
                        goto the_end_of_the_opts_parser;
                    else
                        Perl_croak(aTHX_ "Unknown Unicode option letter '%c'", *p);
                }
            }
            else {
                Perl_croak(aTHX_ "Invalid number '%s' for -C option.\n", p);
            }
        }
        else {
	    for (; *p; p++) {
		 switch (*p) {
		 case PERL_UNICODE_STDIN:
		      opt |= PERL_UNICODE_STDIN_FLAG;	break;
		 case PERL_UNICODE_STDOUT:
		      opt |= PERL_UNICODE_STDOUT_FLAG;	break;
		 case PERL_UNICODE_STDERR:
		      opt |= PERL_UNICODE_STDERR_FLAG;	break;
		 case PERL_UNICODE_STD:
		      opt |= PERL_UNICODE_STD_FLAG;    	break;
		 case PERL_UNICODE_IN:
		      opt |= PERL_UNICODE_IN_FLAG;	break;
		 case PERL_UNICODE_OUT:
		      opt |= PERL_UNICODE_OUT_FLAG;	break;
		 case PERL_UNICODE_INOUT:
		      opt |= PERL_UNICODE_INOUT_FLAG;	break;
		 case PERL_UNICODE_LOCALE:
		      opt |= PERL_UNICODE_LOCALE_FLAG;	break;
		 case PERL_UNICODE_ARGV:
		      opt |= PERL_UNICODE_ARGV_FLAG;	break;
		 case PERL_UNICODE_UTF8CACHEASSERT:
		      opt |= PERL_UNICODE_UTF8CACHEASSERT_FLAG; break;
		 default:
		      if (*p != '\n' && *p != '\r') {
			if(isSPACE(*p)) goto the_end_of_the_opts_parser;
			else
			  Perl_croak(aTHX_
				     "Unknown Unicode option letter '%c'", *p);
		      }
		 }
	    }
       }
  }
  else
       opt = PERL_UNICODE_DEFAULT_FLAGS;

  the_end_of_the_opts_parser:

  if (opt & ~PERL_UNICODE_ALL_FLAGS)
       Perl_croak(aTHX_ "Unknown Unicode option value %"UVuf,
		  (UV) (opt & ~PERL_UNICODE_ALL_FLAGS));

  *popt = p;

  return opt;
}

#ifdef VMS
#  include <starlet.h>
#endif

U32
Perl_seed(pTHX)
{
#if defined(__OpenBSD__)
	return arc4random();
#else
    /*
     * This is really just a quick hack which grabs various garbage
     * values.  It really should be a real hash algorithm which
     * spreads the effect of every input bit onto every output bit,
     * if someone who knows about such things would bother to write it.
     * Might be a good idea to add that function to CORE as well.
     * No numbers below come from careful analysis or anything here,
     * except they are primes and SEED_C1 > 1E6 to get a full-width
     * value from (tv_sec * SEED_C1 + tv_usec).  The multipliers should
     * probably be bigger too.
     */
#if RANDBITS > 16
#  define SEED_C1	1000003
#define   SEED_C4	73819
#else
#  define SEED_C1	25747
#define   SEED_C4	20639
#endif
#define   SEED_C2	3
#define   SEED_C3	269
#define   SEED_C5	26107

#ifndef PERL_NO_DEV_RANDOM
    int fd;
#endif
    U32 u;
#ifdef HAS_GETTIMEOFDAY
    struct timeval when;
#else
    Time_t when;
#endif

/* This test is an escape hatch, this symbol isn't set by Configure. */
#ifndef PERL_NO_DEV_RANDOM
#ifndef PERL_RANDOM_DEVICE
   /* /dev/random isn't used by default because reads from it will block
    * if there isn't enough entropy available.  You can compile with
    * PERL_RANDOM_DEVICE to it if you'd prefer Perl to block until there
    * is enough real entropy to fill the seed. */
#  ifdef __amigaos4__
#    define PERL_RANDOM_DEVICE "RANDOM:SIZE=4"
#  else
#    define PERL_RANDOM_DEVICE "/dev/urandom"
#  endif
#endif
    fd = PerlLIO_open(PERL_RANDOM_DEVICE, 0);
    if (fd != -1) {
    	if (PerlLIO_read(fd, (void*)&u, sizeof u) != sizeof u)
	    u = 0;
	PerlLIO_close(fd);
	if (u)
	    return u;
    }
#endif

#ifdef HAS_GETTIMEOFDAY
    PerlProc_gettimeofday(&when,NULL);
    u = (U32)SEED_C1 * when.tv_sec + (U32)SEED_C2 * when.tv_usec;
#else
    (void)time(&when);
    u = (U32)SEED_C1 * when;
#endif
    u += SEED_C3 * (U32)PerlProc_getpid();
    u += SEED_C4 * (U32)PTR2UV(PL_stack_sp);
#ifndef PLAN9           /* XXX Plan9 assembler chokes on this; fix needed  */
    u += SEED_C5 * (U32)PTR2UV(&when);
#endif
    return u;
#endif
}

void
Perl_get_hash_seed(pTHX_ unsigned char * const seed_buffer)
{
    const char *env_pv;
    unsigned long i;

    PERL_ARGS_ASSERT_GET_HASH_SEED;

    env_pv= PerlEnv_getenv("PERL_HASH_SEED");

    if ( env_pv )
#ifndef USE_HASH_SEED_EXPLICIT
    {
        /* ignore leading spaces */
        while (isSPACE(*env_pv))
            env_pv++;
#ifdef USE_PERL_PERTURB_KEYS
        /* if they set it to "0" we disable key traversal randomization completely */
        if (strEQ(env_pv,"0")) {
            PL_hash_rand_bits_enabled= 0;
        } else {
            /* otherwise switch to deterministic mode */
            PL_hash_rand_bits_enabled= 2;
        }
#endif
        /* ignore a leading 0x... if it is there */
        if (env_pv[0] == '0' && env_pv[1] == 'x')
            env_pv += 2;

        for( i = 0; isXDIGIT(*env_pv) && i < PERL_HASH_SEED_BYTES; i++ ) {
            seed_buffer[i] = READ_XDIGIT(env_pv) << 4;
            if ( isXDIGIT(*env_pv)) {
                seed_buffer[i] |= READ_XDIGIT(env_pv);
            }
        }
        while (isSPACE(*env_pv))
            env_pv++;

        if (*env_pv && !isXDIGIT(*env_pv)) {
            Perl_warn(aTHX_ "perl: warning: Non hex character in '$ENV{PERL_HASH_SEED}', seed only partially set\n");
        }
        /* should we check for unparsed crap? */
        /* should we warn about unused hex? */
        /* should we warn about insufficient hex? */
    }
    else
#endif
    {
        (void)seedDrand01((Rand_seed_t)seed());

        for( i = 0; i < PERL_HASH_SEED_BYTES; i++ ) {
            seed_buffer[i] = (unsigned char)(Drand01() * (U8_MAX+1));
        }
    }
#ifdef USE_PERL_PERTURB_KEYS
    {   /* initialize PL_hash_rand_bits from the hash seed.
         * This value is highly volatile, it is updated every
         * hash insert, and is used as part of hash bucket chain
         * randomization and hash iterator randomization. */
        PL_hash_rand_bits= 0xbe49d17f; /* I just picked a number */
        for( i = 0; i < sizeof(UV) ; i++ ) {
            PL_hash_rand_bits += seed_buffer[i % PERL_HASH_SEED_BYTES];
            PL_hash_rand_bits = ROTL_UV(PL_hash_rand_bits,8);
        }
    }
    env_pv= PerlEnv_getenv("PERL_PERTURB_KEYS");
    if (env_pv) {
        if (strEQ(env_pv,"0") || strEQ(env_pv,"NO")) {
            PL_hash_rand_bits_enabled= 0;
        } else if (strEQ(env_pv,"1") || strEQ(env_pv,"RANDOM")) {
            PL_hash_rand_bits_enabled= 1;
        } else if (strEQ(env_pv,"2") || strEQ(env_pv,"DETERMINISTIC")) {
            PL_hash_rand_bits_enabled= 2;
        } else {
            Perl_warn(aTHX_ "perl: warning: strange setting in '$ENV{PERL_PERTURB_KEYS}': '%s'\n", env_pv);
        }
    }
#endif
}

#ifdef PERL_GLOBAL_STRUCT

#define PERL_GLOBAL_STRUCT_INIT
#include "opcode.h" /* the ppaddr and check */

struct perl_vars *
Perl_init_global_struct(pTHX)
{
    struct perl_vars *plvarsp = NULL;
# ifdef PERL_GLOBAL_STRUCT
    const IV nppaddr = C_ARRAY_LENGTH(Gppaddr);
    const IV ncheck  = C_ARRAY_LENGTH(Gcheck);
    PERL_UNUSED_CONTEXT;
#  ifdef PERL_GLOBAL_STRUCT_PRIVATE
    /* PerlMem_malloc() because can't use even safesysmalloc() this early. */
    plvarsp = (struct perl_vars*)PerlMem_malloc(sizeof(struct perl_vars));
    if (!plvarsp)
        exit(1);
#  else
    plvarsp = PL_VarsPtr;
#  endif /* PERL_GLOBAL_STRUCT_PRIVATE */
#  undef PERLVAR
#  undef PERLVARA
#  undef PERLVARI
#  undef PERLVARIC
#  define PERLVAR(prefix,var,type) /**/
#  define PERLVARA(prefix,var,n,type) /**/
#  define PERLVARI(prefix,var,type,init) plvarsp->prefix##var = init;
#  define PERLVARIC(prefix,var,type,init) plvarsp->prefix##var = init;
#  include "perlvars.h"
#  undef PERLVAR
#  undef PERLVARA
#  undef PERLVARI
#  undef PERLVARIC
#  ifdef PERL_GLOBAL_STRUCT
    plvarsp->Gppaddr =
	(Perl_ppaddr_t*)
	PerlMem_malloc(nppaddr * sizeof(Perl_ppaddr_t));
    if (!plvarsp->Gppaddr)
        exit(1);
    plvarsp->Gcheck  =
	(Perl_check_t*)
	PerlMem_malloc(ncheck  * sizeof(Perl_check_t));
    if (!plvarsp->Gcheck)
        exit(1);
    Copy(Gppaddr, plvarsp->Gppaddr, nppaddr, Perl_ppaddr_t); 
    Copy(Gcheck,  plvarsp->Gcheck,  ncheck,  Perl_check_t); 
#  endif
#  ifdef PERL_SET_VARS
    PERL_SET_VARS(plvarsp);
#  endif
#  ifdef PERL_GLOBAL_STRUCT_PRIVATE
    plvarsp->Gsv_placeholder.sv_flags = 0;
    memset(plvarsp->Ghash_seed, 0, sizeof(plvarsp->Ghash_seed));
#  endif
# undef PERL_GLOBAL_STRUCT_INIT
# endif
    return plvarsp;
}

#endif /* PERL_GLOBAL_STRUCT */

#ifdef PERL_GLOBAL_STRUCT

void
Perl_free_global_struct(pTHX_ struct perl_vars *plvarsp)
{
    int veto = plvarsp->Gveto_cleanup;

    PERL_ARGS_ASSERT_FREE_GLOBAL_STRUCT;
    PERL_UNUSED_CONTEXT;
# ifdef PERL_GLOBAL_STRUCT
#  ifdef PERL_UNSET_VARS
    PERL_UNSET_VARS(plvarsp);
#  endif
    if (veto)
        return;
    free(plvarsp->Gppaddr);
    free(plvarsp->Gcheck);
#  ifdef PERL_GLOBAL_STRUCT_PRIVATE
    free(plvarsp);
#  endif
# endif
}

#endif /* PERL_GLOBAL_STRUCT */

#ifdef PERL_MEM_LOG

/* -DPERL_MEM_LOG: the Perl_mem_log_..() is compiled, including
 * the default implementation, unless -DPERL_MEM_LOG_NOIMPL is also
 * given, and you supply your own implementation.
 *
 * The default implementation reads a single env var, PERL_MEM_LOG,
 * expecting one or more of the following:
 *
 *    \d+ - fd		fd to write to		: must be 1st (grok_atoUV)
 *    'm' - memlog	was PERL_MEM_LOG=1
 *    's' - svlog	was PERL_SV_LOG=1
 *    't' - timestamp	was PERL_MEM_LOG_TIMESTAMP=1
 *
 * This makes the logger controllable enough that it can reasonably be
 * added to the system perl.
 */

/* -DPERL_MEM_LOG_SPRINTF_BUF_SIZE=X: size of a (stack-allocated) buffer
 * the Perl_mem_log_...() will use (either via sprintf or snprintf).
 */
#define PERL_MEM_LOG_SPRINTF_BUF_SIZE 128

/* -DPERL_MEM_LOG_FD=N: the file descriptor the Perl_mem_log_...()
 * writes to.  In the default logger, this is settable at runtime.
 */
#ifndef PERL_MEM_LOG_FD
#  define PERL_MEM_LOG_FD 2 /* If STDERR is too boring for you. */
#endif

#ifndef PERL_MEM_LOG_NOIMPL

# ifdef DEBUG_LEAKING_SCALARS
#   define SV_LOG_SERIAL_FMT	    " [%lu]"
#   define _SV_LOG_SERIAL_ARG(sv)   , (unsigned long) (sv)->sv_debug_serial
# else
#   define SV_LOG_SERIAL_FMT
#   define _SV_LOG_SERIAL_ARG(sv)
# endif

static void
S_mem_log_common(enum mem_log_type mlt, const UV n, 
		 const UV typesize, const char *type_name, const SV *sv,
		 Malloc_t oldalloc, Malloc_t newalloc,
		 const char *filename, const int linenumber,
		 const char *funcname)
{
    const char *pmlenv;

    PERL_ARGS_ASSERT_MEM_LOG_COMMON;

    pmlenv = PerlEnv_getenv("PERL_MEM_LOG");
    if (!pmlenv)
	return;
    if (mlt < MLT_NEW_SV ? strchr(pmlenv,'m') : strchr(pmlenv,'s'))
    {
	/* We can't use SVs or PerlIO for obvious reasons,
	 * so we'll use stdio and low-level IO instead. */
	char buf[PERL_MEM_LOG_SPRINTF_BUF_SIZE];

#   ifdef HAS_GETTIMEOFDAY
#     define MEM_LOG_TIME_FMT	"%10d.%06d: "
#     define MEM_LOG_TIME_ARG	(int)tv.tv_sec, (int)tv.tv_usec
	struct timeval tv;
	gettimeofday(&tv, 0);
#   else
#     define MEM_LOG_TIME_FMT	"%10d: "
#     define MEM_LOG_TIME_ARG	(int)when
        Time_t when;
        (void)time(&when);
#   endif
	/* If there are other OS specific ways of hires time than
	 * gettimeofday() (see dist/Time-HiRes), the easiest way is
	 * probably that they would be used to fill in the struct
	 * timeval. */
	{
	    STRLEN len;
            const char* endptr;
	    int fd;
            UV uv;
            if (grok_atoUV(pmlenv, &uv, &endptr) /* Ignore endptr. */
                && uv && uv <= PERL_INT_MAX
            ) {
                fd = (int)uv;
            } else {
		fd = PERL_MEM_LOG_FD;
            }

	    if (strchr(pmlenv, 't')) {
		len = my_snprintf(buf, sizeof(buf),
				MEM_LOG_TIME_FMT, MEM_LOG_TIME_ARG);
		PERL_UNUSED_RESULT(PerlLIO_write(fd, buf, len));
	    }
	    switch (mlt) {
	    case MLT_ALLOC:
		len = my_snprintf(buf, sizeof(buf),
			"alloc: %s:%d:%s: %"IVdf" %"UVuf
			" %s = %"IVdf": %"UVxf"\n",
			filename, linenumber, funcname, n, typesize,
			type_name, n * typesize, PTR2UV(newalloc));
		break;
	    case MLT_REALLOC:
		len = my_snprintf(buf, sizeof(buf),
			"realloc: %s:%d:%s: %"IVdf" %"UVuf
			" %s = %"IVdf": %"UVxf" -> %"UVxf"\n",
			filename, linenumber, funcname, n, typesize,
			type_name, n * typesize, PTR2UV(oldalloc),
			PTR2UV(newalloc));
		break;
	    case MLT_FREE:
		len = my_snprintf(buf, sizeof(buf),
			"free: %s:%d:%s: %"UVxf"\n",
			filename, linenumber, funcname,
			PTR2UV(oldalloc));
		break;
	    case MLT_NEW_SV:
	    case MLT_DEL_SV:
		len = my_snprintf(buf, sizeof(buf),
			"%s_SV: %s:%d:%s: %"UVxf SV_LOG_SERIAL_FMT "\n",
			mlt == MLT_NEW_SV ? "new" : "del",
			filename, linenumber, funcname,
			PTR2UV(sv) _SV_LOG_SERIAL_ARG(sv));
		break;
	    default:
		len = 0;
	    }
	    PERL_UNUSED_RESULT(PerlLIO_write(fd, buf, len));
	}
    }
}
#endif /* !PERL_MEM_LOG_NOIMPL */

#ifndef PERL_MEM_LOG_NOIMPL
# define \
    mem_log_common_if(alty, num, tysz, tynm, sv, oal, nal, flnm, ln, fnnm) \
    mem_log_common   (alty, num, tysz, tynm, sv, oal, nal, flnm, ln, fnnm)
#else
/* this is suboptimal, but bug compatible.  User is providing their
   own implementation, but is getting these functions anyway, and they
   do nothing. But _NOIMPL users should be able to cope or fix */
# define \
    mem_log_common_if(alty, num, tysz, tynm, u, oal, nal, flnm, ln, fnnm) \
    /* mem_log_common_if_PERL_MEM_LOG_NOIMPL */
#endif

Malloc_t
Perl_mem_log_alloc(const UV n, const UV typesize, const char *type_name,
		   Malloc_t newalloc, 
		   const char *filename, const int linenumber,
		   const char *funcname)
{
    PERL_ARGS_ASSERT_MEM_LOG_ALLOC;

    mem_log_common_if(MLT_ALLOC, n, typesize, type_name,
		      NULL, NULL, newalloc,
		      filename, linenumber, funcname);
    return newalloc;
}

Malloc_t
Perl_mem_log_realloc(const UV n, const UV typesize, const char *type_name,
		     Malloc_t oldalloc, Malloc_t newalloc, 
		     const char *filename, const int linenumber, 
		     const char *funcname)
{
    PERL_ARGS_ASSERT_MEM_LOG_REALLOC;

    mem_log_common_if(MLT_REALLOC, n, typesize, type_name,
		      NULL, oldalloc, newalloc, 
		      filename, linenumber, funcname);
    return newalloc;
}

Malloc_t
Perl_mem_log_free(Malloc_t oldalloc, 
		  const char *filename, const int linenumber, 
		  const char *funcname)
{
    PERL_ARGS_ASSERT_MEM_LOG_FREE;

    mem_log_common_if(MLT_FREE, 0, 0, "", NULL, oldalloc, NULL, 
		      filename, linenumber, funcname);
    return oldalloc;
}

void
Perl_mem_log_new_sv(const SV *sv, 
		    const char *filename, const int linenumber,
		    const char *funcname)
{
    mem_log_common_if(MLT_NEW_SV, 0, 0, "", sv, NULL, NULL,
		      filename, linenumber, funcname);
}

void
Perl_mem_log_del_sv(const SV *sv,
		    const char *filename, const int linenumber, 
		    const char *funcname)
{
    mem_log_common_if(MLT_DEL_SV, 0, 0, "", sv, NULL, NULL, 
		      filename, linenumber, funcname);
}

#endif /* PERL_MEM_LOG */

/*
=for apidoc my_sprintf

The C library C<sprintf>, wrapped if necessary, to ensure that it will return
the length of the string written to the buffer.  Only rare pre-ANSI systems
need the wrapper function - usually this is a direct call to C<sprintf>.

=cut
*/
#ifndef SPRINTF_RETURNS_STRLEN
int
Perl_my_sprintf(char *buffer, const char* pat, ...)
{
    va_list args;
    PERL_ARGS_ASSERT_MY_SPRINTF;
    va_start(args, pat);
    vsprintf(buffer, pat, args);
    va_end(args);
    return strlen(buffer);
}
#endif

/*
=for apidoc quadmath_format_single

C<quadmath_snprintf()> is very strict about its C<format> string and will
fail, returning -1, if the format is invalid.  It accepts exactly
one format spec.

C<quadmath_format_single()> checks that the intended single spec looks
sane: begins with C<%>, has only one C<%>, ends with C<[efgaEFGA]>,
and has C<Q> before it.  This is not a full "printf syntax check",
just the basics.

Returns the format if it is valid, NULL if not.

C<quadmath_format_single()> can and will actually patch in the missing
C<Q>, if necessary.  In this case it will return the modified copy of
the format, B<which the caller will need to free.>

See also L</quadmath_format_needed>.

=cut
*/
#ifdef USE_QUADMATH
const char*
Perl_quadmath_format_single(const char* format)
{
    STRLEN len;

    PERL_ARGS_ASSERT_QUADMATH_FORMAT_SINGLE;

    if (format[0] != '%' || strchr(format + 1, '%'))
        return NULL;
    len = strlen(format);
    /* minimum length three: %Qg */
    if (len < 3 || strchr("efgaEFGA", format[len - 1]) == NULL)
        return NULL;
    if (format[len - 2] != 'Q') {
        char* fixed;
        Newx(fixed, len + 1, char);
        memcpy(fixed, format, len - 1);
        fixed[len - 1] = 'Q';
        fixed[len    ] = format[len - 1];
        fixed[len + 1] = 0;
        return (const char*)fixed;
    }
    return format;
}
#endif

/*
=for apidoc quadmath_format_needed

C<quadmath_format_needed()> returns true if the C<format> string seems to
contain at least one non-Q-prefixed C<%[efgaEFGA]> format specifier,
or returns false otherwise.

The format specifier detection is not complete printf-syntax detection,
but it should catch most common cases.

If true is returned, those arguments B<should> in theory be processed
with C<quadmath_snprintf()>, but in case there is more than one such
format specifier (see L</quadmath_format_single>), and if there is
anything else beyond that one (even just a single byte), they
B<cannot> be processed because C<quadmath_snprintf()> is very strict,
accepting only one format spec, and nothing else.
In this case, the code should probably fail.

=cut
*/
#ifdef USE_QUADMATH
bool
Perl_quadmath_format_needed(const char* format)
{
  const char *p = format;
  const char *q;

  PERL_ARGS_ASSERT_QUADMATH_FORMAT_NEEDED;

  while ((q = strchr(p, '%'))) {
    q++;
    if (*q == '+') /* plus */
      q++;
    if (*q == '#') /* alt */
      q++;
    if (*q == '*') /* width */
      q++;
    else {
      if (isDIGIT(*q)) {
        while (isDIGIT(*q)) q++;
      }
    }
    if (*q == '.' && (q[1] == '*' || isDIGIT(q[1]))) { /* prec */
      q++;
      if (*q == '*')
        q++;
      else
        while (isDIGIT(*q)) q++;
    }
    if (strchr("efgaEFGA", *q)) /* Would have needed 'Q' in front. */
      return TRUE;
    p = q + 1;
  }
  return FALSE;
}
#endif

/*
=for apidoc my_snprintf

The C library C<snprintf> functionality, if available and
standards-compliant (uses C<vsnprintf>, actually).  However, if the
C<vsnprintf> is not available, will unfortunately use the unsafe
C<vsprintf> which can overrun the buffer (there is an overrun check,
but that may be too late).  Consider using C<sv_vcatpvf> instead, or
getting C<vsnprintf>.

=cut
*/
int
Perl_my_snprintf(char *buffer, const Size_t len, const char *format, ...)
{
    int retval = -1;
    va_list ap;
    PERL_ARGS_ASSERT_MY_SNPRINTF;
#ifndef HAS_VSNPRINTF
    PERL_UNUSED_VAR(len);
#endif
    va_start(ap, format);
#ifdef USE_QUADMATH
    {
        const char* qfmt = quadmath_format_single(format);
        bool quadmath_valid = FALSE;
        if (qfmt) {
            /* If the format looked promising, use it as quadmath. */
            retval = quadmath_snprintf(buffer, len, qfmt, va_arg(ap, NV));
            if (retval == -1)
                Perl_croak_nocontext("panic: quadmath_snprintf failed, format \"%s\"", qfmt);
            quadmath_valid = TRUE;
            if (qfmt != format)
                Safefree(qfmt);
            qfmt = NULL;
        }
        assert(qfmt == NULL);
        /* quadmath_format_single() will return false for example for
         * "foo = %g", or simply "%g".  We could handle the %g by
         * using quadmath for the NV args.  More complex cases of
         * course exist: "foo = %g, bar = %g", or "foo=%Qg" (otherwise
         * quadmath-valid but has stuff in front).
         *
         * Handling the "Q-less" cases right would require walking
         * through the va_list and rewriting the format, calling
         * quadmath for the NVs, building a new va_list, and then
         * letting vsnprintf/vsprintf to take care of the other
         * arguments.  This may be doable.
         *
         * We do not attempt that now.  But for paranoia, we here try
         * to detect some common (but not all) cases where the
         * "Q-less" %[efgaEFGA] formats are present, and die if
         * detected.  This doesn't fix the problem, but it stops the
         * vsnprintf/vsprintf pulling doubles off the va_list when
         * __float128 NVs should be pulled off instead.
         *
         * If quadmath_format_needed() returns false, we are reasonably
         * certain that we can call vnsprintf() or vsprintf() safely. */
        if (!quadmath_valid && quadmath_format_needed(format))
          Perl_croak_nocontext("panic: quadmath_snprintf failed, format \"%s\"", format);

    }
#endif
    if (retval == -1)
#ifdef HAS_VSNPRINTF
        retval = vsnprintf(buffer, len, format, ap);
#else
        retval = vsprintf(buffer, format, ap);
#endif
    va_end(ap);
    /* vsprintf() shows failure with < 0 */
    if (retval < 0
#ifdef HAS_VSNPRINTF
    /* vsnprintf() shows failure with >= len */
        ||
        (len > 0 && (Size_t)retval >= len) 
#endif
    )
	Perl_croak_nocontext("panic: my_snprintf buffer overflow");
    return retval;
}

/*
=for apidoc my_vsnprintf

The C library C<vsnprintf> if available and standards-compliant.
However, if if the C<vsnprintf> is not available, will unfortunately
use the unsafe C<vsprintf> which can overrun the buffer (there is an
overrun check, but that may be too late).  Consider using
C<sv_vcatpvf> instead, or getting C<vsnprintf>.

=cut
*/
int
Perl_my_vsnprintf(char *buffer, const Size_t len, const char *format, va_list ap)
{
#ifdef USE_QUADMATH
    PERL_UNUSED_ARG(buffer);
    PERL_UNUSED_ARG(len);
    PERL_UNUSED_ARG(format);
    PERL_UNUSED_ARG(ap);
    Perl_croak_nocontext("panic: my_vsnprintf not available with quadmath");
    return 0;
#else
    int retval;
#ifdef NEED_VA_COPY
    va_list apc;

    PERL_ARGS_ASSERT_MY_VSNPRINTF;
    Perl_va_copy(ap, apc);
# ifdef HAS_VSNPRINTF
    retval = vsnprintf(buffer, len, format, apc);
# else
    PERL_UNUSED_ARG(len);
    retval = vsprintf(buffer, format, apc);
# endif
    va_end(apc);
#else
# ifdef HAS_VSNPRINTF
    retval = vsnprintf(buffer, len, format, ap);
# else
    PERL_UNUSED_ARG(len);
    retval = vsprintf(buffer, format, ap);
# endif
#endif /* #ifdef NEED_VA_COPY */
    /* vsprintf() shows failure with < 0 */
    if (retval < 0
#ifdef HAS_VSNPRINTF
    /* vsnprintf() shows failure with >= len */
        ||
        (len > 0 && (Size_t)retval >= len) 
#endif
    )
	Perl_croak_nocontext("panic: my_vsnprintf buffer overflow");
    return retval;
#endif
}

void
Perl_my_clearenv(pTHX)
{
    dVAR;
#if ! defined(PERL_MICRO)
#  if defined(PERL_IMPLICIT_SYS) || defined(WIN32)
    PerlEnv_clearenv();
#  else /* ! (PERL_IMPLICIT_SYS || WIN32) */
#    if defined(USE_ENVIRON_ARRAY)
#      if defined(USE_ITHREADS)
    /* only the parent thread can clobber the process environment */
    if (PL_curinterp == aTHX)
#      endif /* USE_ITHREADS */
    {
#      if ! defined(PERL_USE_SAFE_PUTENV)
    if ( !PL_use_safe_putenv) {
      I32 i;
      if (environ == PL_origenviron)
        environ = (char**)safesysmalloc(sizeof(char*));
      else
        for (i = 0; environ[i]; i++)
          (void)safesysfree(environ[i]);
    }
    environ[0] = NULL;
#      else /* PERL_USE_SAFE_PUTENV */
#        if defined(HAS_CLEARENV)
    (void)clearenv();
#        elif defined(HAS_UNSETENV)
    int bsiz = 80; /* Most envvar names will be shorter than this. */
    char *buf = (char*)safesysmalloc(bsiz);
    while (*environ != NULL) {
      char *e = strchr(*environ, '=');
      int l = e ? e - *environ : (int)strlen(*environ);
      if (bsiz < l + 1) {
        (void)safesysfree(buf);
        bsiz = l + 1; /* + 1 for the \0. */
        buf = (char*)safesysmalloc(bsiz);
      } 
      memcpy(buf, *environ, l);
      buf[l] = '\0';
      (void)unsetenv(buf);
    }
    (void)safesysfree(buf);
#        else /* ! HAS_CLEARENV && ! HAS_UNSETENV */
    /* Just null environ and accept the leakage. */
    *environ = NULL;
#        endif /* HAS_CLEARENV || HAS_UNSETENV */
#      endif /* ! PERL_USE_SAFE_PUTENV */
    }
#    endif /* USE_ENVIRON_ARRAY */
#  endif /* PERL_IMPLICIT_SYS || WIN32 */
#endif /* PERL_MICRO */
}

#ifdef PERL_IMPLICIT_CONTEXT

/* Implements the MY_CXT_INIT macro. The first time a module is loaded,
the global PL_my_cxt_index is incremented, and that value is assigned to
that module's static my_cxt_index (who's address is passed as an arg).
Then, for each interpreter this function is called for, it makes sure a
void* slot is available to hang the static data off, by allocating or
extending the interpreter's PL_my_cxt_list array */

#ifndef PERL_GLOBAL_STRUCT_PRIVATE
void *
Perl_my_cxt_init(pTHX_ int *index, size_t size)
{
    dVAR;
    void *p;
    PERL_ARGS_ASSERT_MY_CXT_INIT;
    if (*index == -1) {
	/* this module hasn't been allocated an index yet */
#if defined(USE_ITHREADS)
	MUTEX_LOCK(&PL_my_ctx_mutex);
#endif
	*index = PL_my_cxt_index++;
#if defined(USE_ITHREADS)
	MUTEX_UNLOCK(&PL_my_ctx_mutex);
#endif
    }
    
    /* make sure the array is big enough */
    if (PL_my_cxt_size <= *index) {
	if (PL_my_cxt_size) {
	    while (PL_my_cxt_size <= *index)
		PL_my_cxt_size *= 2;
	    Renew(PL_my_cxt_list, PL_my_cxt_size, void *);
	}
	else {
	    PL_my_cxt_size = 16;
	    Newx(PL_my_cxt_list, PL_my_cxt_size, void *);
	}
    }
    /* newSV() allocates one more than needed */
    p = (void*)SvPVX(newSV(size-1));
    PL_my_cxt_list[*index] = p;
    Zero(p, size, char);
    return p;
}

#else /* #ifndef PERL_GLOBAL_STRUCT_PRIVATE */

int
Perl_my_cxt_index(pTHX_ const char *my_cxt_key)
{
    dVAR;
    int index;

    PERL_ARGS_ASSERT_MY_CXT_INDEX;

    for (index = 0; index < PL_my_cxt_index; index++) {
	const char *key = PL_my_cxt_keys[index];
	/* try direct pointer compare first - there are chances to success,
	 * and it's much faster.
	 */
	if ((key == my_cxt_key) || strEQ(key, my_cxt_key))
	    return index;
    }
    return -1;
}

void *
Perl_my_cxt_init(pTHX_ const char *my_cxt_key, size_t size)
{
    dVAR;
    void *p;
    int index;

    PERL_ARGS_ASSERT_MY_CXT_INIT;

    index = Perl_my_cxt_index(aTHX_ my_cxt_key);
    if (index == -1) {
	/* this module hasn't been allocated an index yet */
#if defined(USE_ITHREADS)
	MUTEX_LOCK(&PL_my_ctx_mutex);
#endif
	index = PL_my_cxt_index++;
#if defined(USE_ITHREADS)
	MUTEX_UNLOCK(&PL_my_ctx_mutex);
#endif
    }

    /* make sure the array is big enough */
    if (PL_my_cxt_size <= index) {
	int old_size = PL_my_cxt_size;
	int i;
	if (PL_my_cxt_size) {
	    while (PL_my_cxt_size <= index)
		PL_my_cxt_size *= 2;
	    Renew(PL_my_cxt_list, PL_my_cxt_size, void *);
	    Renew(PL_my_cxt_keys, PL_my_cxt_size, const char *);
	}
	else {
	    PL_my_cxt_size = 16;
	    Newx(PL_my_cxt_list, PL_my_cxt_size, void *);
	    Newx(PL_my_cxt_keys, PL_my_cxt_size, const char *);
	}
	for (i = old_size; i < PL_my_cxt_size; i++) {
	    PL_my_cxt_keys[i] = 0;
	    PL_my_cxt_list[i] = 0;
	}
    }
    PL_my_cxt_keys[index] = my_cxt_key;
    /* newSV() allocates one more than needed */
    p = (void*)SvPVX(newSV(size-1));
    PL_my_cxt_list[index] = p;
    Zero(p, size, char);
    return p;
}
#endif /* #ifndef PERL_GLOBAL_STRUCT_PRIVATE */
#endif /* PERL_IMPLICIT_CONTEXT */


/* Perl_xs_handshake():
   implement the various XS_*_BOOTCHECK macros, which are added to .c
   files by ExtUtils::ParseXS, to check that the perl the module was built
   with is binary compatible with the running perl.

   usage:
       Perl_xs_handshake(U32 key, void * v_my_perl, const char * file,
            [U32 items, U32 ax], [char * api_version], [char * xs_version])

   The meaning of the varargs is determined the U32 key arg (which is not
   a format string). The fields of key are assembled by using HS_KEY().

   Under PERL_IMPLICIT_CONTEX, the v_my_perl arg is of type
   "PerlInterpreter *" and represents the callers context; otherwise it is
   of type "CV *", and is the boot xsub's CV.

   v_my_perl will catch where a threaded future perl526.dll calling IO.dll
   for example, and IO.dll was linked with threaded perl524.dll, and both
   perl526.dll and perl524.dll are in %PATH and the Win32 DLL loader
   successfully can load IO.dll into the process but simultaneously it
   loaded an interpreter of a different version into the process, and XS
   code will naturally pass SV*s created by perl524.dll for perl526.dll to
   use through perl526.dll's my_perl->Istack_base.

   v_my_perl cannot be the first arg, since then 'key' will be out of
   place in a threaded vs non-threaded mixup; and analyzing the key
   number's bitfields won't reveal the problem, since it will be a valid
   key (unthreaded perl) on interp side, but croak will report the XS mod's
   key as gibberish (it is really a my_perl ptr) (threaded XS mod); or if
   it's a threaded perl and an unthreaded XS module, threaded perl will
   look at an uninit C stack or an uninit register to get 'key'
   (remember that it assumes that the 1st arg is the interp cxt).

   'file' is the source filename of the caller.
*/

I32
Perl_xs_handshake(const U32 key, void * v_my_perl, const char * file, ...)
{
    va_list args;
    U32 items, ax;
    void * got;
    void * need;
#ifdef PERL_IMPLICIT_CONTEXT
    dTHX;
    tTHX xs_interp;
#else
    CV* cv;
    SV *** xs_spp;
#endif
    PERL_ARGS_ASSERT_XS_HANDSHAKE;
    va_start(args, file);

    got = INT2PTR(void*, (UV)(key & HSm_KEY_MATCH));
    need = (void *)(HS_KEY(FALSE, FALSE, "", "") & HSm_KEY_MATCH);
    if (UNLIKELY(got != need))
	goto bad_handshake;
/* try to catch where a 2nd threaded perl interp DLL is loaded into a process
   by a XS DLL compiled against the wrong interl DLL b/c of bad @@INC, and the
   2nd threaded perl interp DLL never initialized its TLS/PERL_SYS_INIT3 so
   dTHX call from 2nd interp DLL can't return the my_perl that pp_entersub
   passed to the XS DLL */
#ifdef PERL_IMPLICIT_CONTEXT
    xs_interp = (tTHX)v_my_perl;
    got = xs_interp;
    need = my_perl;
#else
/* try to catch where an unthreaded perl interp DLL (for ex. perl522.dll) is
   loaded into a process by a XS DLL built by an unthreaded perl522.dll perl,
   but the DynaLoder/Perl that started the process and loaded the XS DLL is
   unthreaded perl524.dll, since unthreadeds don't pass my_perl (a unique *)
   through pp_entersub, use a unique value (which is a pointer to PL_stack_sp's
   location in the unthreaded perl binary) stored in CV * to figure out if this
   Perl_xs_handshake was called by the same pp_entersub */
    cv = (CV*)v_my_perl;
    xs_spp = (SV***)CvHSCXT(cv);
    got = xs_spp;
    need = &PL_stack_sp;
#endif
    if(UNLIKELY(got != need)) {
	bad_handshake:/* recycle branch and string from above */
	if(got != (void *)HSf_NOCHK)
	    noperl_die("%s: loadable library and perl binaries are mismatched"
                       " (got handshake key %p, needed %p)\n",
		file, got, need);
    }

    if(key & HSf_SETXSUBFN) {     /* this might be called from a module bootstrap */
	SAVEPPTR(PL_xsubfilename);/* which was require'd from a XSUB BEGIN */
	PL_xsubfilename = file;   /* so the old name must be restored for
				     additional XSUBs to register themselves */
	/* XSUBs can't be perl lang/perl5db.pl debugged
	if (PERLDB_LINE_OR_SAVESRC)
	    (void)gv_fetchfile(file); */
    }

    if(key & HSf_POPMARK) {
	ax = POPMARK;
	{   SV **mark = PL_stack_base + ax++;
	    {   dSP;
		items = (I32)(SP - MARK);
	    }
	}
    } else {
	items = va_arg(args, U32);
	ax = va_arg(args, U32);
    }
    {
	U32 apiverlen;
	assert(HS_GETAPIVERLEN(key) <= UCHAR_MAX);
	if((apiverlen = HS_GETAPIVERLEN(key))) {
	    char * api_p = va_arg(args, char*);
	    if(apiverlen != sizeof("v" PERL_API_VERSION_STRING)-1
		|| memNE(api_p, "v" PERL_API_VERSION_STRING,
			 sizeof("v" PERL_API_VERSION_STRING)-1))
		Perl_croak_nocontext("Perl API version %s of %"SVf" does not match %s",
				    api_p, SVfARG(PL_stack_base[ax + 0]),
				    "v" PERL_API_VERSION_STRING);
	}
    }
    {
	U32 xsverlen;
	assert(HS_GETXSVERLEN(key) <= UCHAR_MAX && HS_GETXSVERLEN(key) <= HS_APIVERLEN_MAX);
	if((xsverlen = HS_GETXSVERLEN(key)))
	    S_xs_version_bootcheck(aTHX_
		items, ax, va_arg(args, char*), xsverlen);
    }
    va_end(args);
    return ax;
}


STATIC void
S_xs_version_bootcheck(pTHX_ U32 items, U32 ax, const char *xs_p,
			  STRLEN xs_len)
{
    SV *sv;
    const char *vn = NULL;
    SV *const module = PL_stack_base[ax];

    PERL_ARGS_ASSERT_XS_VERSION_BOOTCHECK;

    if (items >= 2)	 /* version supplied as bootstrap arg */
	sv = PL_stack_base[ax + 1];
    else {
	/* XXX GV_ADDWARN */
	vn = "XS_VERSION";
	sv = get_sv(Perl_form(aTHX_ "%"SVf"::%s", SVfARG(module), vn), 0);
	if (!sv || !SvOK(sv)) {
	    vn = "VERSION";
	    sv = get_sv(Perl_form(aTHX_ "%"SVf"::%s", SVfARG(module), vn), 0);
	}
    }
    if (sv) {
	SV *xssv = Perl_newSVpvn_flags(aTHX_ xs_p, xs_len, SVs_TEMP);
	SV *pmsv = sv_isobject(sv) && sv_derived_from(sv, "version")
	    ? sv : sv_2mortal(new_version(sv));
	xssv = upg_version(xssv, 0);
	if ( vcmp(pmsv,xssv) ) {
	    SV *string = vstringify(xssv);
	    SV *xpt = Perl_newSVpvf(aTHX_ "%"SVf" object version %"SVf
				    " does not match ", SVfARG(module), SVfARG(string));

	    SvREFCNT_dec(string);
	    string = vstringify(pmsv);

	    if (vn) {
		Perl_sv_catpvf(aTHX_ xpt, "$%"SVf"::%s %"SVf, SVfARG(module), vn,
			       SVfARG(string));
	    } else {
		Perl_sv_catpvf(aTHX_ xpt, "bootstrap parameter %"SVf, SVfARG(string));
	    }
	    SvREFCNT_dec(string);

	    Perl_sv_2mortal(aTHX_ xpt);
	    Perl_croak_sv(aTHX_ xpt);
	}
    }
}

/*
=for apidoc my_strlcat

The C library C<strlcat> if available, or a Perl implementation of it.
This operates on C C<NUL>-terminated strings.

C<my_strlcat()> appends string C<src> to the end of C<dst>.  It will append at
most S<C<size - strlen(dst) - 1>> characters.  It will then C<NUL>-terminate,
unless C<size> is 0 or the original C<dst> string was longer than C<size> (in
practice this should not happen as it means that either C<size> is incorrect or
that C<dst> is not a proper C<NUL>-terminated string).

Note that C<size> is the full size of the destination buffer and
the result is guaranteed to be C<NUL>-terminated if there is room.  Note that
room for the C<NUL> should be included in C<size>.

=cut

Description stolen from http://www.openbsd.org/cgi-bin/man.cgi?query=strlcat
*/
#ifndef HAS_STRLCAT
Size_t
Perl_my_strlcat(char *dst, const char *src, Size_t size)
{
    Size_t used, length, copy;

    used = strlen(dst);
    length = strlen(src);
    if (size > 0 && used < size - 1) {
        copy = (length >= size - used) ? size - used - 1 : length;
        memcpy(dst + used, src, copy);
        dst[used + copy] = '\0';
    }
    return used + length;
}
#endif


/*
=for apidoc my_strlcpy

The C library C<strlcpy> if available, or a Perl implementation of it.
This operates on C C<NUL>-terminated strings.

C<my_strlcpy()> copies up to S<C<size - 1>> characters from the string C<src>
to C<dst>, C<NUL>-terminating the result if C<size> is not 0.

=cut

Description stolen from http://www.openbsd.org/cgi-bin/man.cgi?query=strlcpy
*/
#ifndef HAS_STRLCPY
Size_t
Perl_my_strlcpy(char *dst, const char *src, Size_t size)
{
    Size_t length, copy;

    length = strlen(src);
    if (size > 0) {
        copy = (length >= size) ? size - 1 : length;
        memcpy(dst, src, copy);
        dst[copy] = '\0';
    }
    return length;
}
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1300) && (_MSC_VER < 1400) && (WINVER < 0x0500)
/* VC7 or 7.1, building with pre-VC7 runtime libraries. */
long _ftol( double ); /* Defined by VC6 C libs. */
long _ftol2( double dblSource ) { return _ftol( dblSource ); }
#endif

PERL_STATIC_INLINE bool
S_gv_has_usable_name(pTHX_ GV *gv)
{
    GV **gvp;
    return GvSTASH(gv)
	&& HvENAME(GvSTASH(gv))
	&& (gvp = (GV **)hv_fetchhek(
			GvSTASH(gv), GvNAME_HEK(gv), 0
	   ))
	&& *gvp == gv;
}

void
Perl_get_db_sub(pTHX_ SV **svp, CV *cv)
{
    SV * const dbsv = GvSVn(PL_DBsub);
    const bool save_taint = TAINT_get;

    /* When we are called from pp_goto (svp is null),
     * we do not care about using dbsv to call CV;
     * it's for informational purposes only.
     */

    PERL_ARGS_ASSERT_GET_DB_SUB;

    TAINT_set(FALSE);
    save_item(dbsv);
    if (!PERLDB_SUB_NN) {
	GV *gv = CvGV(cv);

	if (!svp && !CvLEXICAL(cv)) {
	    gv_efullname3(dbsv, gv, NULL);
	}
	else if ( (CvFLAGS(cv) & (CVf_ANON | CVf_CLONED)) || CvLEXICAL(cv)
	     || strEQ(GvNAME(gv), "END")
	     || ( /* Could be imported, and old sub redefined. */
		 (GvCV(gv) != cv || !S_gv_has_usable_name(aTHX_ gv))
		 &&
		 !( (SvTYPE(*svp) == SVt_PVGV)
		    && (GvCV((const GV *)*svp) == cv)
		    /* Use GV from the stack as a fallback. */
		    && S_gv_has_usable_name(aTHX_ gv = (GV *)*svp) 
		  )
		)
	) {
	    /* GV is potentially non-unique, or contain different CV. */
	    SV * const tmp = newRV(MUTABLE_SV(cv));
	    sv_setsv(dbsv, tmp);
	    SvREFCNT_dec(tmp);
	}
	else {
	    sv_sethek(dbsv, HvENAME_HEK(GvSTASH(gv)));
	    sv_catpvs(dbsv, "::");
	    sv_cathek(dbsv, GvNAME_HEK(gv));
	}
    }
    else {
	const int type = SvTYPE(dbsv);
	if (type < SVt_PVIV && type != SVt_IV)
	    sv_upgrade(dbsv, SVt_PVIV);
	(void)SvIOK_on(dbsv);
	SvIV_set(dbsv, PTR2IV(cv));	/* Do it the quickest way  */
    }
    SvSETMAGIC(dbsv);
    TAINT_IF(save_taint);
#ifdef NO_TAINT_SUPPORT
    PERL_UNUSED_VAR(save_taint);
#endif
}

int
Perl_my_dirfd(DIR * dir) {

    /* Most dirfd implementations have problems when passed NULL. */
    if(!dir)
        return -1;
#ifdef HAS_DIRFD
    return dirfd(dir);
#elif defined(HAS_DIR_DD_FD)
    return dir->dd_fd;
#else
    Perl_croak_nocontext(PL_no_func, "dirfd");
    NOT_REACHED; /* NOTREACHED */
    return 0;
#endif 
}

REGEXP *
Perl_get_re_arg(pTHX_ SV *sv) {

    if (sv) {
        if (SvMAGICAL(sv))
            mg_get(sv);
        if (SvROK(sv))
	    sv = MUTABLE_SV(SvRV(sv));
        if (SvTYPE(sv) == SVt_REGEXP)
            return (REGEXP*) sv;
    }
 
    return NULL;
}

/*
 * This code is derived from drand48() implementation from FreeBSD,
 * found in lib/libc/gen/_rand48.c.
 *
 * The U64 implementation is original, based on the POSIX
 * specification for drand48().
 */

/*
* Copyright (c) 1993 Martin Birgmeier
* All rights reserved.
*
* You may redistribute unmodified or modified versions of this source
* code provided that the above copyright notice and this and the
* following conditions are retained.
*
* This software is provided ``as is'', and comes with no warranties
* of any kind. I shall in no event be liable for anything that happens
* to anyone/anything when using this software.
*/

#define FREEBSD_DRAND48_SEED_0   (0x330e)

#ifdef PERL_DRAND48_QUAD

#define DRAND48_MULT U64_CONST(0x5deece66d)
#define DRAND48_ADD  0xb
#define DRAND48_MASK U64_CONST(0xffffffffffff)

#else

#define FREEBSD_DRAND48_SEED_1   (0xabcd)
#define FREEBSD_DRAND48_SEED_2   (0x1234)
#define FREEBSD_DRAND48_MULT_0   (0xe66d)
#define FREEBSD_DRAND48_MULT_1   (0xdeec)
#define FREEBSD_DRAND48_MULT_2   (0x0005)
#define FREEBSD_DRAND48_ADD      (0x000b)

const unsigned short _rand48_mult[3] = {
                FREEBSD_DRAND48_MULT_0,
                FREEBSD_DRAND48_MULT_1,
                FREEBSD_DRAND48_MULT_2
};
const unsigned short _rand48_add = FREEBSD_DRAND48_ADD;

#endif

void
Perl_drand48_init_r(perl_drand48_t *random_state, U32 seed)
{
    PERL_ARGS_ASSERT_DRAND48_INIT_R;

#ifdef PERL_DRAND48_QUAD
    *random_state = FREEBSD_DRAND48_SEED_0 + ((U64)seed << 16);
#else
    random_state->seed[0] = FREEBSD_DRAND48_SEED_0;
    random_state->seed[1] = (U16) seed;
    random_state->seed[2] = (U16) (seed >> 16);
#endif
}

double
Perl_drand48_r(perl_drand48_t *random_state)
{
    PERL_ARGS_ASSERT_DRAND48_R;

#ifdef PERL_DRAND48_QUAD
    *random_state = (*random_state * DRAND48_MULT + DRAND48_ADD)
        & DRAND48_MASK;

    return ldexp((double)*random_state, -48);
#else
    {
    U32 accu;
    U16 temp[2];

    accu = (U32) _rand48_mult[0] * (U32) random_state->seed[0]
         + (U32) _rand48_add;
    temp[0] = (U16) accu;        /* lower 16 bits */
    accu >>= sizeof(U16) * 8;
    accu += (U32) _rand48_mult[0] * (U32) random_state->seed[1]
          + (U32) _rand48_mult[1] * (U32) random_state->seed[0];
    temp[1] = (U16) accu;        /* middle 16 bits */
    accu >>= sizeof(U16) * 8;
    accu += _rand48_mult[0] * random_state->seed[2]
          + _rand48_mult[1] * random_state->seed[1]
          + _rand48_mult[2] * random_state->seed[0];
    random_state->seed[0] = temp[0];
    random_state->seed[1] = temp[1];
    random_state->seed[2] = (U16) accu;

    return ldexp((double) random_state->seed[0], -48) +
           ldexp((double) random_state->seed[1], -32) +
           ldexp((double) random_state->seed[2], -16);
    }
#endif
}

#ifdef USE_C_BACKTRACE

/* Possibly move all this USE_C_BACKTRACE code into a new file. */

#ifdef USE_BFD

typedef struct {
    /* abfd is the BFD handle. */
    bfd* abfd;
    /* bfd_syms is the BFD symbol table. */
    asymbol** bfd_syms;
    /* bfd_text is handle to the the ".text" section of the object file. */
    asection* bfd_text;
    /* Since opening the executable and scanning its symbols is quite
     * heavy operation, we remember the filename we used the last time,
     * and do the opening and scanning only if the filename changes.
     * This removes most (but not all) open+scan cycles. */
    const char* fname_prev;
} bfd_context;

/* Given a dl_info, update the BFD context if necessary. */
static void bfd_update(bfd_context* ctx, Dl_info* dl_info)
{
    /* BFD open and scan only if the filename changed. */
    if (ctx->fname_prev == NULL ||
        strNE(dl_info->dli_fname, ctx->fname_prev)) {
        if (ctx->abfd) {
            bfd_close(ctx->abfd);
        }
        ctx->abfd = bfd_openr(dl_info->dli_fname, 0);
        if (ctx->abfd) {
            if (bfd_check_format(ctx->abfd, bfd_object)) {
                IV symbol_size = bfd_get_symtab_upper_bound(ctx->abfd);
                if (symbol_size > 0) {
                    Safefree(ctx->bfd_syms);
                    Newx(ctx->bfd_syms, symbol_size, asymbol*);
                    ctx->bfd_text =
                        bfd_get_section_by_name(ctx->abfd, ".text");
                }
                else
                    ctx->abfd = NULL;
            }
            else
                ctx->abfd = NULL;
        }
        ctx->fname_prev = dl_info->dli_fname;
    }
}

/* Given a raw frame, try to symbolize it and store
 * symbol information (source file, line number) away. */
static void bfd_symbolize(bfd_context* ctx,
                          void* raw_frame,
                          char** symbol_name,
                          STRLEN* symbol_name_size,
                          char** source_name,
                          STRLEN* source_name_size,
                          STRLEN* source_line)
{
    *symbol_name = NULL;
    *symbol_name_size = 0;
    if (ctx->abfd) {
        IV offset = PTR2IV(raw_frame) - PTR2IV(ctx->bfd_text->vma);
        if (offset > 0 &&
            bfd_canonicalize_symtab(ctx->abfd, ctx->bfd_syms) > 0) {
            const char *file;
            const char *func;
            unsigned int line = 0;
            if (bfd_find_nearest_line(ctx->abfd, ctx->bfd_text,
                                      ctx->bfd_syms, offset,
                                      &file, &func, &line) &&
                file && func && line > 0) {
                /* Size and copy the source file, use only
                 * the basename of the source file.
                 *
                 * NOTE: the basenames are fine for the
                 * Perl source files, but may not always
                 * be the best idea for XS files. */
                const char *p, *b = NULL;
                /* Look for the last slash. */
                for (p = file; *p; p++) {
                    if (*p == '/')
                        b = p + 1;
                }
                if (b == NULL || *b == 0) {
                    b = file;
                }
                *source_name_size = p - b + 1;
                Newx(*source_name, *source_name_size + 1, char);
                Copy(b, *source_name, *source_name_size + 1, char);

                *symbol_name_size = strlen(func);
                Newx(*symbol_name, *symbol_name_size + 1, char);
                Copy(func, *symbol_name, *symbol_name_size + 1, char);

                *source_line = line;
            }
        }
    }
}

#endif /* #ifdef USE_BFD */

#ifdef PERL_DARWIN

/* OS X has no public API for for 'symbolicating' (Apple official term)
 * stack addresses to {function_name, source_file, line_number}.
 * Good news: there is command line utility atos(1) which does that.
 * Bad news 1: it's a command line utility.
 * Bad news 2: one needs to have the Developer Tools installed.
 * Bad news 3: in newer releases it needs to be run as 'xcrun atos'.
 *
 * To recap: we need to open a pipe for reading for a utility which
 * might not exist, or exists in different locations, and then parse
 * the output.  And since this is all for a low-level API, we cannot
 * use high-level stuff.  Thanks, Apple. */

typedef struct {
    /* tool is set to the absolute pathname of the tool to use:
     * xcrun or atos. */
    const char* tool;
    /* format is set to a printf format string used for building
     * the external command to run. */
    const char* format;
    /* unavail is set if e.g. xcrun cannot be found, or something
     * else happens that makes getting the backtrace dubious.  Note,
     * however, that the context isn't persistent, the next call to
     * get_c_backtrace() will start from scratch. */
    bool unavail;
    /* fname is the current object file name. */
    const char* fname;
    /* object_base_addr is the base address of the shared object. */
    void* object_base_addr;
} atos_context;

/* Given |dl_info|, updates the context.  If the context has been
 * marked unavailable, return immediately.  If not but the tool has
 * not been set, set it to either "xcrun atos" or "atos" (also set the
 * format to use for creating commands for piping), or if neither is
 * unavailable (one needs the Developer Tools installed), mark the context
 * an unavailable.  Finally, update the filename (object name),
 * and its base address. */

static void atos_update(atos_context* ctx,
                        Dl_info* dl_info)
{
    if (ctx->unavail)
        return;
    if (ctx->tool == NULL) {
        const char* tools[] = {
            "/usr/bin/xcrun",
            "/usr/bin/atos"
        };
        const char* formats[] = {
            "/usr/bin/xcrun atos -o '%s' -l %08x %08x 2>&1",
            "/usr/bin/atos -d -o '%s' -l %08x %08x 2>&1"
        };
        struct stat st;
        UV i;
        for (i = 0; i < C_ARRAY_LENGTH(tools); i++) {
            if (stat(tools[i], &st) == 0 && S_ISREG(st.st_mode)) {
                ctx->tool = tools[i];
                ctx->format = formats[i];
                break;
            }
        }
        if (ctx->tool == NULL) {
            ctx->unavail = TRUE;
            return;
        }
    }
    if (ctx->fname == NULL ||
        strNE(dl_info->dli_fname, ctx->fname)) {
        ctx->fname = dl_info->dli_fname;
        ctx->object_base_addr = dl_info->dli_fbase;
    }
}

/* Given an output buffer end |p| and its |start|, matches
 * for the atos output, extracting the source code location
 * and returning non-NULL if possible, returning NULL otherwise. */
static const char* atos_parse(const char* p,
                              const char* start,
                              STRLEN* source_name_size,
                              STRLEN* source_line) {
    /* atos() output is something like:
     * perl_parse (in miniperl) (perl.c:2314)\n\n".
     * We cannot use Perl regular expressions, because we need to
     * stay low-level.  Therefore here we have a rolled-out version
     * of a state machine which matches _backwards_from_the_end_ and
     * if there's a success, returns the starts of the filename,
     * also setting the filename size and the source line number.
     * The matched regular expression is roughly "\(.*:\d+\)\s*$" */
    const char* source_number_start;
    const char* source_name_end;
    const char* source_line_end;
    const char* close_paren;
    UV uv;

    /* Skip trailing whitespace. */
    while (p > start && isspace(*p)) p--;
    /* Now we should be at the close paren. */
    if (p == start || *p != ')')
        return NULL;
    close_paren = p;
    p--;
    /* Now we should be in the line number. */
    if (p == start || !isdigit(*p))
        return NULL;
    /* Skip over the digits. */
    while (p > start && isdigit(*p))
        p--;
    /* Now we should be at the colon. */
    if (p == start || *p != ':')
        return NULL;
    source_number_start = p + 1;
    source_name_end = p; /* Just beyond the end. */
    p--;
    /* Look for the open paren. */
    while (p > start && *p != '(')
        p--;
    if (p == start)
        return NULL;
    p++;
    *source_name_size = source_name_end - p;
    if (grok_atoUV(source_number_start, &uv,  &source_line_end)
        && source_line_end == close_paren
        && uv <= PERL_INT_MAX
    ) {
        *source_line = (STRLEN)uv;
        return p;
    }
    return NULL;
}

/* Given a raw frame, read a pipe from the symbolicator (that's the
 * technical term) atos, reads the result, and parses the source code
 * location.  We must stay low-level, so we use snprintf(), pipe(),
 * and fread(), and then also parse the output ourselves. */
static void atos_symbolize(atos_context* ctx,
                           void* raw_frame,
                           char** source_name,
                           STRLEN* source_name_size,
                           STRLEN* source_line)
{
    char cmd[1024];
    const char* p;
    Size_t cnt;

    if (ctx->unavail)
        return;
    /* Simple security measure: if there's any funny business with
     * the object name (used as "-o '%s'" ), leave since at least
     * partially the user controls it. */
    for (p = ctx->fname; *p; p++) {
        if (*p == '\'' || iscntrl(*p)) {
            ctx->unavail = TRUE;
            return;
        }
    }
    cnt = snprintf(cmd, sizeof(cmd), ctx->format,
                   ctx->fname, ctx->object_base_addr, raw_frame);
    if (cnt < sizeof(cmd)) {
        /* Undo nostdio.h #defines that disable stdio.
         * This is somewhat naughty, but is used elsewhere
         * in the core, and affects only OS X. */
#undef FILE
#undef popen
#undef fread
#undef pclose
        FILE* fp = popen(cmd, "r");
        /* At the moment we open a new pipe for each stack frame.
         * This is naturally somewhat slow, but hopefully generating
         * stack traces is never going to in a performance critical path.
         *
         * We could play tricks with atos by batching the stack
         * addresses to be resolved: atos can either take multiple
         * addresses from the command line, or read addresses from
         * a file (though the mess of creating temporary files would
         * probably negate much of any possible speedup).
         *
         * Normally there are only two objects present in the backtrace:
         * perl itself, and the libdyld.dylib.  (Note that the object
         * filenames contain the full pathname, so perl may not always
         * be in the same place.)  Whenever the object in the
         * backtrace changes, the base address also changes.
         *
         * The problem with batching the addresses, though, would be
         * matching the results with the addresses: the parsing of
         * the results is already painful enough with a single address. */
        if (fp) {
            char out[1024];
            UV cnt = fread(out, 1, sizeof(out), fp);
            if (cnt < sizeof(out)) {
                const char* p = atos_parse(out + cnt - 1, out,
                                           source_name_size,
                                           source_line);
                if (p) {
                    Newx(*source_name,
                         *source_name_size, char);
                    Copy(p, *source_name,
                         *source_name_size,  char);
                }
            }
            pclose(fp);
        }
    }
}

#endif /* #ifdef PERL_DARWIN */

/*
=for apidoc get_c_backtrace

Collects the backtrace (aka "stacktrace") into a single linear
malloced buffer, which the caller B<must> C<Perl_free_c_backtrace()>.

Scans the frames back by S<C<depth + skip>>, then drops the C<skip> innermost,
returning at most C<depth> frames.

=cut
*/

Perl_c_backtrace*
Perl_get_c_backtrace(pTHX_ int depth, int skip)
{
    /* Note that here we must stay as low-level as possible: Newx(),
     * Copy(), Safefree(); since we may be called from anywhere,
     * so we should avoid higher level constructs like SVs or AVs.
     *
     * Since we are using safesysmalloc() via Newx(), don't try
     * getting backtrace() there, unless you like deep recursion. */

    /* Currently only implemented with backtrace() and dladdr(),
     * for other platforms NULL is returned. */

#if defined(HAS_BACKTRACE) && defined(HAS_DLADDR)
    /* backtrace() is available via <execinfo.h> in glibc and in most
     * modern BSDs; dladdr() is available via <dlfcn.h>. */

    /* We try fetching this many frames total, but then discard
     * the |skip| first ones.  For the remaining ones we will try
     * retrieving more information with dladdr(). */
    int try_depth = skip +  depth;

    /* The addresses (program counters) returned by backtrace(). */
    void** raw_frames;

    /* Retrieved with dladdr() from the addresses returned by backtrace(). */
    Dl_info* dl_infos;

    /* Sizes _including_ the terminating \0 of the object name
     * and symbol name strings. */
    STRLEN* object_name_sizes;
    STRLEN* symbol_name_sizes;

#ifdef USE_BFD
    /* The symbol names comes either from dli_sname,
     * or if using BFD, they can come from BFD. */
    char** symbol_names;
#endif

    /* The source code location information.  Dug out with e.g. BFD. */
    char** source_names;
    STRLEN* source_name_sizes;
    STRLEN* source_lines;

    Perl_c_backtrace* bt = NULL;  /* This is what will be returned. */
    int got_depth; /* How many frames were returned from backtrace(). */
    UV frame_count = 0; /* How many frames we return. */
    UV total_bytes = 0; /* The size of the whole returned backtrace. */

#ifdef USE_BFD
    bfd_context bfd_ctx;
#endif
#ifdef PERL_DARWIN
    atos_context atos_ctx;
#endif

    /* Here are probably possibilities for optimizing.  We could for
     * example have a struct that contains most of these and then
     * allocate |try_depth| of them, saving a bunch of malloc calls.
     * Note, however, that |frames| could not be part of that struct
     * because backtrace() will want an array of just them.  Also be
     * careful about the name strings. */
    Newx(raw_frames, try_depth, void*);
    Newx(dl_infos, try_depth, Dl_info);
    Newx(object_name_sizes, try_depth, STRLEN);
    Newx(symbol_name_sizes, try_depth, STRLEN);
    Newx(source_names, try_depth, char*);
    Newx(source_name_sizes, try_depth, STRLEN);
    Newx(source_lines, try_depth, STRLEN);
#ifdef USE_BFD
    Newx(symbol_names, try_depth, char*);
#endif

    /* Get the raw frames. */
    got_depth = (int)backtrace(raw_frames, try_depth);

    /* We use dladdr() instead of backtrace_symbols() because we want
     * the full details instead of opaque strings.  This is useful for
     * two reasons: () the details are needed for further symbolic
     * digging, for example in OS X (2) by having the details we fully
     * control the output, which in turn is useful when more platforms
     * are added: we can keep out output "portable". */

    /* We want a single linear allocation, which can then be freed
     * with a single swoop.  We will do the usual trick of first
     * walking over the structure and seeing how much we need to
     * allocate, then allocating, and then walking over the structure
     * the second time and populating it. */

    /* First we must compute the total size of the buffer. */
    total_bytes = sizeof(Perl_c_backtrace_header);
    if (got_depth > skip) {
        int i;
#ifdef USE_BFD
        bfd_init(); /* Is this safe to call multiple times? */
        Zero(&bfd_ctx, 1, bfd_context);
#endif
#ifdef PERL_DARWIN
        Zero(&atos_ctx, 1, atos_context);
#endif
        for (i = skip; i < try_depth; i++) {
            Dl_info* dl_info = &dl_infos[i];

            object_name_sizes[i] = 0;
            source_names[i] = NULL;
            source_name_sizes[i] = 0;
            source_lines[i] = 0;

            /* Yes, zero from dladdr() is failure. */
            if (dladdr(raw_frames[i], dl_info)) {
                total_bytes += sizeof(Perl_c_backtrace_frame);

                object_name_sizes[i] =
                    dl_info->dli_fname ? strlen(dl_info->dli_fname) : 0;
                symbol_name_sizes[i] =
                    dl_info->dli_sname ? strlen(dl_info->dli_sname) : 0;
#ifdef USE_BFD
                bfd_update(&bfd_ctx, dl_info);
                bfd_symbolize(&bfd_ctx, raw_frames[i],
                              &symbol_names[i],
                              &symbol_name_sizes[i],
                              &source_names[i],
                              &source_name_sizes[i],
                              &source_lines[i]);
#endif
#if PERL_DARWIN
                atos_update(&atos_ctx, dl_info);
                atos_symbolize(&atos_ctx,
                               raw_frames[i],
                               &source_names[i],
                               &source_name_sizes[i],
                               &source_lines[i]);
#endif

                /* Plus ones for the terminating \0. */
                total_bytes += object_name_sizes[i] + 1;
                total_bytes += symbol_name_sizes[i] + 1;
                total_bytes += source_name_sizes[i] + 1;

                frame_count++;
            } else {
                break;
            }
        }
#ifdef USE_BFD
        Safefree(bfd_ctx.bfd_syms);
#endif
    }

    /* Now we can allocate and populate the result buffer. */
    Newxc(bt, total_bytes, char, Perl_c_backtrace);
    Zero(bt, total_bytes, char);
    bt->header.frame_count = frame_count;
    bt->header.total_bytes = total_bytes;
    if (frame_count > 0) {
        Perl_c_backtrace_frame* frame = bt->frame_info;
        char* name_base = (char *)(frame + frame_count);
        char* name_curr = name_base; /* Outputting the name strings here. */
        UV i;
        for (i = skip; i < skip + frame_count; i++) {
            Dl_info* dl_info = &dl_infos[i];

            frame->addr = raw_frames[i];
            frame->object_base_addr = dl_info->dli_fbase;
            frame->symbol_addr = dl_info->dli_saddr;

            /* Copies a string, including the \0, and advances the name_curr.
             * Also copies the start and the size to the frame. */
#define PERL_C_BACKTRACE_STRCPY(frame, doffset, src, dsize, size) \
            if (size && src) \
                Copy(src, name_curr, size, char); \
            frame->doffset = name_curr - (char*)bt; \
            frame->dsize = size; \
            name_curr += size; \
            *name_curr++ = 0;

            PERL_C_BACKTRACE_STRCPY(frame, object_name_offset,
                                    dl_info->dli_fname,
                                    object_name_size, object_name_sizes[i]);

#ifdef USE_BFD
            PERL_C_BACKTRACE_STRCPY(frame, symbol_name_offset,
                                    symbol_names[i],
                                    symbol_name_size, symbol_name_sizes[i]);
            Safefree(symbol_names[i]);
#else
            PERL_C_BACKTRACE_STRCPY(frame, symbol_name_offset,
                                    dl_info->dli_sname,
                                    symbol_name_size, symbol_name_sizes[i]);
#endif

            PERL_C_BACKTRACE_STRCPY(frame, source_name_offset,
                                    source_names[i],
                                    source_name_size, source_name_sizes[i]);
            Safefree(source_names[i]);

#undef PERL_C_BACKTRACE_STRCPY

            frame->source_line_number = source_lines[i];

            frame++;
        }
        assert(total_bytes ==
               (UV)(sizeof(Perl_c_backtrace_header) +
                    frame_count * sizeof(Perl_c_backtrace_frame) +
                    name_curr - name_base));
    }
#ifdef USE_BFD
    Safefree(symbol_names);
    if (bfd_ctx.abfd) {
        bfd_close(bfd_ctx.abfd);
    }
#endif
    Safefree(source_lines);
    Safefree(source_name_sizes);
    Safefree(source_names);
    Safefree(symbol_name_sizes);
    Safefree(object_name_sizes);
    /* Assuming the strings returned by dladdr() are pointers
     * to read-only static memory (the object file), so that
     * they do not need freeing (and cannot be). */
    Safefree(dl_infos);
    Safefree(raw_frames);
    return bt;
#else
    PERL_UNUSED_ARGV(depth);
    PERL_UNUSED_ARGV(skip);
    return NULL;
#endif
}

/*
=for apidoc free_c_backtrace

Deallocates a backtrace received from get_c_bracktrace.

=cut
*/

/*
=for apidoc get_c_backtrace_dump

Returns a SV containing a dump of C<depth> frames of the call stack, skipping
the C<skip> innermost ones.  C<depth> of 20 is usually enough.

The appended output looks like:

...
1   10e004812:0082   Perl_croak   util.c:1716    /usr/bin/perl
2   10df8d6d2:1d72   perl_parse   perl.c:3975    /usr/bin/perl
...

The fields are tab-separated.  The first column is the depth (zero
being the innermost non-skipped frame).  In the hex:offset, the hex is
where the program counter was in C<S_parse_body>, and the :offset (might
be missing) tells how much inside the C<S_parse_body> the program counter was.

The C<util.c:1716> is the source code file and line number.

The F</usr/bin/perl> is obvious (hopefully).

Unknowns are C<"-">.  Unknowns can happen unfortunately quite easily:
if the platform doesn't support retrieving the information;
if the binary is missing the debug information;
if the optimizer has transformed the code by for example inlining.

=cut
*/

SV*
Perl_get_c_backtrace_dump(pTHX_ int depth, int skip)
{
    Perl_c_backtrace* bt;

    bt = get_c_backtrace(depth, skip + 1 /* Hide ourselves. */);
    if (bt) {
        Perl_c_backtrace_frame* frame;
        SV* dsv = newSVpvs("");
        UV i;
        for (i = 0, frame = bt->frame_info;
             i < bt->header.frame_count; i++, frame++) {
            Perl_sv_catpvf(aTHX_ dsv, "%d", (int)i);
            Perl_sv_catpvf(aTHX_ dsv, "\t%p", frame->addr ? frame->addr : "-");
            /* Symbol (function) names might disappear without debug info.
             *
             * The source code location might disappear in case of the
             * optimizer inlining or otherwise rearranging the code. */
            if (frame->symbol_addr) {
                Perl_sv_catpvf(aTHX_ dsv, ":%04x",
                               (int)
                               ((char*)frame->addr - (char*)frame->symbol_addr));
            }
            Perl_sv_catpvf(aTHX_ dsv, "\t%s",
                           frame->symbol_name_size &&
                           frame->symbol_name_offset ?
                           (char*)bt + frame->symbol_name_offset : "-");
            if (frame->source_name_size &&
                frame->source_name_offset &&
                frame->source_line_number) {
                Perl_sv_catpvf(aTHX_ dsv, "\t%s:%"UVuf,
                               (char*)bt + frame->source_name_offset,
                               (UV)frame->source_line_number);
            } else {
                Perl_sv_catpvf(aTHX_ dsv, "\t-");
            }
            Perl_sv_catpvf(aTHX_ dsv, "\t%s",
                           frame->object_name_size &&
                           frame->object_name_offset ?
                           (char*)bt + frame->object_name_offset : "-");
            /* The frame->object_base_addr is not output,
             * but it is used for symbolizing/symbolicating. */
            sv_catpvs(dsv, "\n");
        }

        Perl_free_c_backtrace(aTHX_ bt);

        return dsv;
    }

    return NULL;
}

/*
=for apidoc dump_c_backtrace

Dumps the C backtrace to the given C<fp>.

Returns true if a backtrace could be retrieved, false if not.

=cut
*/

bool
Perl_dump_c_backtrace(pTHX_ PerlIO* fp, int depth, int skip)
{
    SV* sv;

    PERL_ARGS_ASSERT_DUMP_C_BACKTRACE;

    sv = Perl_get_c_backtrace_dump(aTHX_ depth, skip);
    if (sv) {
        sv_2mortal(sv);
        PerlIO_printf(fp, "%s", SvPV_nolen(sv));
        return TRUE;
    }
    return FALSE;
}

#endif /* #ifdef USE_C_BACKTRACE */

#ifdef PERL_TSA_ACTIVE

/* pthread_mutex_t and perl_mutex are typedef equivalent
 * so casting the pointers is fine. */

int perl_tsa_mutex_lock(perl_mutex* mutex)
{
    return pthread_mutex_lock((pthread_mutex_t *) mutex);
}

int perl_tsa_mutex_unlock(perl_mutex* mutex)
{
    return pthread_mutex_unlock((pthread_mutex_t *) mutex);
}

int perl_tsa_mutex_destroy(perl_mutex* mutex)
{
    return pthread_mutex_destroy((pthread_mutex_t *) mutex);
}

#endif


#ifdef USE_DTRACE

/* log a sub call or return */

void
Perl_dtrace_probe_call(pTHX_ CV *cv, bool is_call)
{
    const char *func;
    const char *file;
    const char *stash;
    const COP  *start;
    line_t      line;

    PERL_ARGS_ASSERT_DTRACE_PROBE_CALL;

    if (CvNAMED(cv)) {
        HEK *hek = CvNAME_HEK(cv);
        func = HEK_KEY(hek);
    }
    else {
        GV  *gv = CvGV(cv);
        func = GvENAME(gv);
    }
    start = (const COP *)CvSTART(cv);
    file  = CopFILE(start);
    line  = CopLINE(start);
    stash = CopSTASHPV(start);

    if (is_call) {
        PERL_SUB_ENTRY(func, file, line, stash);
    }
    else {
        PERL_SUB_RETURN(func, file, line, stash);
    }
}


/* log a require file loading/loaded  */

void
Perl_dtrace_probe_load(pTHX_ const char *name, bool is_loading)
{
    PERL_ARGS_ASSERT_DTRACE_PROBE_LOAD;

    if (is_loading) {
	PERL_LOADING_FILE(name);
    }
    else {
	PERL_LOADED_FILE(name);
    }
}


/* log an op execution */

void
Perl_dtrace_probe_op(pTHX_ const OP *op)
{
    PERL_ARGS_ASSERT_DTRACE_PROBE_OP;

    PERL_OP_ENTRY(OP_NAME(op));
}


/* log a compile/run phase change */

void
Perl_dtrace_probe_phase(pTHX_ enum perl_phase phase)
{
    const char *ph_old = PL_phase_names[PL_phase];
    const char *ph_new = PL_phase_names[phase];

    PERL_PHASE_CHANGE(ph_new, ph_old);
}

#endif

/*
 * ex: set ts=8 sts=4 sw=4 et:
 */
@


1.27
log
@Fix merge issues, remove excess files - match perl-5.24.2 dist

OK bluhm@@, Reads ok sthen@@
@
text
@d4652 3
d4723 1
@


1.26
log
@Apply local patches - perl-5.24.1
@
text
@d527 4
a530 2
char *
Perl_delimcpy(char *to, const char *toend, const char *from, const char *fromend, int delim, I32 *retlen)
d537 1
a537 1
	if (*from == '\\') {
d556 17
a4651 3
#if defined(__OpenBSD__)
	return arc4random();
#else
a4719 1
#endif
@


1.25
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@d4633 3
d4704 1
@


1.24
log
@Update to perl 5.20.3

OK bluhm@@
@
text
@d48 4
d58 18
a81 4
#if defined(HAS_FCNTL) && defined(F_SETFD) && !defined(FD_CLOEXEC)
#  define FD_CLOEXEC 1			/* NeXT needs this */
#endif

d135 4
d140 1
d182 1
a182 1
        ptr = (Malloc_t)((char*)ptr+PERL_MEMORY_DEBUG_HEADER_SIZE);
d184 2
a185 2
	return ptr;
}
d187 4
d192 1
a192 1
	dTHX;
d194 5
a198 5
	if (PL_nomemok)
	    return NULL;
	else {
	    croak_no_mem();
	}
d200 1
a200 1
    /*NOTREACHED*/
d223 4
a226 1
	return NULL;
d228 1
a228 3

    if (!where)
	return safesysmalloc(size);
d230 7
a236 5
    where = (Malloc_t)((char*)where-PERL_MEMORY_DEBUG_HEADER_SIZE);
    size += PERL_MEMORY_DEBUG_HEADER_SIZE;
    {
	struct perl_memory_debug_header *const header
	    = (struct perl_memory_debug_header *)where;
d239 6
a244 6
	if (header->interpreter != aTHX) {
	    Perl_croak_nocontext("panic: realloc from wrong pool, %p!=%p",
				 header->interpreter, aTHX);
	}
	assert(header->next->prev == header);
	assert(header->prev->next == header);
d246 5
a250 5
	if (header->size > size) {
	    const MEM_SIZE freed_up = header->size - size;
	    char *start_of_freed = ((char *)where) + size;
	    PoisonFree(start_of_freed, freed_up, char);
	}
d254 1
a254 1
	header->size = size;
d256 1
a256 1
    }
d259 2
a260 2
    if ((SSize_t)size < 0)
	Perl_croak_nocontext("panic: realloc, size=%"UVuf, (UV)size);
d263 10
a272 10
    if ((ptr = mmap(0, size, PROT_READ|PROT_WRITE,
		    MAP_ANON|MAP_PRIVATE, -1, 0)) == MAP_FAILED) {
	perror("mmap failed");
	abort();
    }
    Copy(where,ptr,oldsize < size ? oldsize : size,char);
    if (munmap(where, oldsize)) {
	perror("munmap failed");
	abort();
    }
d274 1
a274 1
    ptr = (Malloc_t)PerlMem_realloc(where,size);
d276 1
a276 1
    PERL_ALLOC_CHECK(ptr);
d281 1
a281 1
    if (ptr != NULL) {
d283 2
a284 2
	struct perl_memory_debug_header *const header
	    = (struct perl_memory_debug_header *)ptr;
d287 5
a291 5
	if (header->size < size) {
	    const MEM_SIZE fresh = size - header->size;
	    char *start_of_fresh = ((char *)ptr) + size;
	    PoisonNew(start_of_fresh, fresh, char);
	}
d294 6
a299 6
	maybe_protect_rw(header->next);
	header->next->prev = header;
	maybe_protect_ro(header->next);
	maybe_protect_rw(header->prev);
	header->prev->next = header;
	maybe_protect_ro(header->prev);
d301 2
a302 2
        ptr = (Malloc_t)((char*)ptr+PERL_MEMORY_DEBUG_HEADER_SIZE);
    }
d307 2
a308 2
    DEBUG_m(PerlIO_printf(Perl_debug_log, "0x%"UVxf": (%05ld) rfree\n",PTR2UV(where),(long)PL_an++));
    DEBUG_m(PerlIO_printf(Perl_debug_log, "0x%"UVxf": (%05ld) realloc %ld bytes\n",PTR2UV(ptr),(long)PL_an++,(long)size));
d310 5
a314 5

    if (ptr != NULL) {
	return ptr;
    }
    else {
d316 1
a316 1
	dTHX;
d318 5
a322 4
	if (PL_nomemok)
	    return NULL;
	else {
	    croak_no_mem();
d325 1
a325 1
    /*NOTREACHED*/
a334 2
#else
    dVAR;
d339 1
a339 1
        where = (Malloc_t)((char*)where-PERL_MEMORY_DEBUG_HEADER_SIZE);
d342 1
a342 1
		= (struct perl_memory_debug_header *)where;
d372 1
a372 1
	    PoisonNew(where, size, char);
d378 1
a378 1
	    if (munmap(where, size)) {
d384 3
a386 1
#endif
d388 1
a388 1
	PerlMem_free(where);
d493 3
a495 1
    dTHXs;
d501 3
a503 1
    dTHXs;
d509 3
a511 1
    dTHXs;
d517 3
a519 1
    dTHXs;
a562 4
    /* libc prior to 4.6.27 (late 1994) did not work properly on a NULL
     * 'little' */
    if (!little)
	return (char*)big;
d566 28
a593 2
/* same as instr but allow embedded nulls.  The end pointers point to 1 beyond
 * the final character desired to be checked */
d619 12
a630 1
/* reverse of the above--find last substring */
d674 1
a674 1
Analyses the string in order to make fast searches on it using fbm_instr()
a682 1
    dVAR;
a766 3
/* If SvTAIL(littlestr), it has a fake '\n' at end. */
/* If SvTAIL is actually due to \Z or \z, this gives false positives
   if multiline */
d772 3
a774 2
C<bigend>.  It returns C<NULL> if the string can't be found.  The C<sv>
does not have to be fbm_compiled, but the search will not be as fast
d778 17
d797 1
d822 1
d824 7
a830 12
	    if (SvTAIL(littlestr) && !multiline) { /* Anchor only! */
		/* Know that bigend != big.  */
		if (bigend[-1] == '\n')
		    return (char *)(bigend - 1);
		return (char *) bigend;
	    }
	    s = big;
	    while (s < bigend) {
		if (*s == *little)
		    return (char *)s;
		s++;
	    }
d834 1
d837 4
a840 1
	    if (bigend[-1] == '\n' && bigend[-2] == *little)
d846 1
d848 71
a918 51
	    /* This should be better than FBM if c1 == c2, and almost
	       as good otherwise: maybe better since we do less indirection.
	       And we save a lot of memory by caching no table. */
	    const unsigned char c1 = little[0];
	    const unsigned char c2 = little[1];

	    s = big + 1;
	    bigend--;
	    if (c1 != c2) {
		while (s <= bigend) {
		    if (s[0] == c2) {
			if (s[-1] == c1)
			    return (char*)s - 1;
			s += 2;
			continue;
		    }
		  next_chars:
		    if (s[0] == c1) {
			if (s == bigend)
			    goto check_1char_anchor;
			if (s[1] == c2)
			    return (char*)s;
			else {
			    s++;
			    goto next_chars;
			}
		    }
		    else
			s += 2;
		}
		goto check_1char_anchor;
	    }
	    /* Now c1 == c2 */
	    while (s <= bigend) {
		if (s[0] == c1) {
		    if (s[-1] == c1)
			return (char*)s - 1;
		    if (s == bigend)
			goto check_1char_anchor;
		    if (s[1] == c1)
			return (char*)s;
		    s += 3;
		}
		else
		    s += 2;
	    }
	}
      check_1char_anchor:		/* One char and anchor! */
	if (SvTAIL(littlestr) && (*bigend == *little))
	    return (char *)bigend;	/* bigend is already decremented. */
	return NULL;
d938 1
d940 1
a962 1
	const unsigned char * const table = (const unsigned char *) mg->mg_ptr;
d965 2
d973 2
d979 13
a991 3
		if ((s += tmp) < bigend)
		    goto top2;
		goto check_end;
d993 5
a997 1
	    else {		/* less expensive than calling strncmp() */
a1023 17
char *
Perl_screaminstr(pTHX_ SV *bigstr, SV *littlestr, I32 start_shift, I32 end_shift, I32 *old_posp, I32 last)
{
    dVAR;
    PERL_ARGS_ASSERT_SCREAMINSTR;
    PERL_UNUSED_ARG(bigstr);
    PERL_UNUSED_ARG(littlestr);
    PERL_UNUSED_ARG(start_shift);
    PERL_UNUSED_ARG(end_shift);
    PERL_UNUSED_ARG(old_posp);
    PERL_UNUSED_ARG(last);

    /* This function must only ever be called on a scalar with study magic,
       but those do not happen any more. */
    Perl_croak(aTHX_ "panic: screaminstr");
    return NULL;
}
d1028 2
a1029 1
Returns true if the leading len bytes of the strings s1 and s2 are the same
d1082 2
a1083 2
Returns true if the leading len bytes of the strings s1 and s2 are the same
case-insensitively in the current locale; false otherwise.
d1192 3
d1210 1
a1210 1
which is shared between threads.  (With the specific difference that a NULL
d1220 1
a1281 1
    dVAR;
a1403 1
    dVAR;
d1417 1
a1417 1
	for (kid = cUNOPo->op_first; kid; kid = kid->op_sibling) {
a1465 1
    dVAR;
d1468 14
d1512 1
a1512 1
	    closest_cop(PL_curcop, PL_curcop->op_sibling, PL_op, FALSE);
d1544 2
a1545 1
argument list.  These are used to generate a string message.  If the
a1559 1
    dVAR;
a1570 1
    dVAR;
a1609 1
    dVAR;
d1661 7
d1673 2
a1674 2
    assert(0); /* NOTREACHED */
    return NULL;
d1676 3
d1691 7
d1705 1
a1705 1
    assert(0); /* NOTREACHED */
d1707 1
a1707 1
    return NULL;
d1709 3
d1714 7
d1727 1
a1727 1
    assert(0); /* NOTREACHED */
d1729 1
a1729 1
    return NULL;
d1731 3
d1830 1
a1830 1
    assert(0); /* NOTREACHED */
d1841 1
a1841 1
    assert(0); /* NOTREACHED */
d1868 8
a1875 3
    /* Can't use PerlIO to write as it allocates memory */
    PERL_UNUSED_RESULT(PerlLIO_write(PerlIO_fileno(Perl_error_log),
		  PL_no_mem, sizeof(PL_no_mem)-1));
d2045 7
a2051 2
	invoke_exception_hook(msv, FALSE);
	die_unwind(msv);
a2062 1
    dVAR;
a2074 1
    dVAR;
d2150 3
d2160 52
a2211 48
    /* most putenv()s leak, so we manipulate environ directly */
    I32 i;
    const I32 len = strlen(nam);
    int nlen, vlen;

    /* where does it go? */
    for (i = 0; environ[i]; i++) {
        if (strnEQ(environ[i],nam,len) && environ[i][len] == '=')
            break;
    }

    if (environ == PL_origenviron) {   /* need we copy environment? */
       I32 j;
       I32 max;
       char **tmpenv;

       max = i;
       while (environ[max])
           max++;
       tmpenv = (char**)safesysmalloc((max+2) * sizeof(char*));
       for (j=0; j<max; j++) {         /* copy environment */
           const int len = strlen(environ[j]);
           tmpenv[j] = (char*)safesysmalloc((len+1)*sizeof(char));
           Copy(environ[j], tmpenv[j], len+1, char);
       }
       tmpenv[max] = NULL;
       environ = tmpenv;               /* tell exec where it is now */
    }
    if (!val) {
       safesysfree(environ[i]);
       while (environ[i]) {
           environ[i] = environ[i+1];
           i++;
	}
       return;
    }
    if (!environ[i]) {                 /* does not exist yet */
       environ = (char**)safesysrealloc(environ, (i+2) * sizeof(char*));
       environ[i+1] = NULL;    /* make sure it's null terminated */
    }
    else
       safesysfree(environ[i]);
       nlen = strlen(nam);
       vlen = strlen(val);

       environ[i] = (char*)safesysmalloc((nlen+vlen+2) * sizeof(char));
       /* all that work just for this */
       my_setenv_format(environ[i], nam, nlen, val, vlen);
d2218 1
a2218 1
#   if defined(__CYGWIN__)|| defined(__SYMBIAN32__) || defined(__riscos__) || (defined(__sun) && defined(HAS_UNSETENV))
d2259 4
d2303 5
a2307 4
/* this is a drop-in replacement for bcopy() */
#if (!defined(HAS_MEMCPY) && !defined(HAS_BCOPY)) || (!defined(HAS_MEMMOVE) && !defined(HAS_SAFE_MEMCPY) && !defined(HAS_SAFE_BCOPY))
char *
Perl_my_bcopy(const char *from, char *to, I32 len)
d2309 5
a2313 1
    char * const retval = to;
a2316 2
    assert(len >= 0);

d2327 3
a2329 1
    return retval;
d2336 1
a2336 1
Perl_my_memset(char *loc, I32 ch, I32 len)
d2338 1
a2338 1
    char * const retval = loc;
a2341 2
    assert(len >= 0);

d2344 1
a2344 1
    return retval;
d2350 2
a2351 2
char *
Perl_my_bzero(char *loc, I32 len)
d2353 1
a2353 1
    char * const retval = loc;
a2356 2
    assert(len >= 0);

d2359 1
a2359 1
    return retval;
d2365 2
a2366 2
I32
Perl_my_memcmp(const char *s1, const char *s2, I32 len)
d2368 3
a2370 3
    const U8 *a = (const U8 *)s1;
    const U8 *b = (const U8 *)s2;
    I32 tmp;
a2373 2
    assert(len >= 0);

d2440 1
a2440 2
#if (!defined(DOSISH) || defined(HAS_FORK) || defined(AMIGAOS)) && !defined(OS2) && !defined(VMS) && !defined(NETWARE) && !defined(__LIBCATAMOUNT__)
    dVAR;
d2484 1
a2484 1
#if defined(HAS_FCNTL) && defined(F_SETFD)
d2486 2
a2487 1
	    fcntl(pp[1], F_SETFD, FD_CLOEXEC);
d2567 1
a2567 1
#  ifdef OS2	/* Same, without fork()ing and all extra overhead... */
d2569 2
d2578 2
a2579 2
    /* VMS' my_popen() is in VMS.c, same with OS/2. */
#if (!defined(DOSISH) || defined(HAS_FORK) || defined(AMIGAOS)) && !defined(VMS) && !defined(__LIBCATAMOUNT__)
a2582 1
    dVAR;
d2633 2
a2634 1
	    fcntl(pp[1], F_SETFD, FD_CLOEXEC);
d2753 9
a2762 1
   dVAR;
d2764 1
d2779 9
d2789 1
a2790 1
#if defined(USE_ITHREADS)
d2817 2
a2865 1
    dVAR;
d2869 1
d2907 1
d2909 1
d2937 1
d2939 2
d3018 1
a3018 1
#if (!defined(DOSISH) || defined(HAS_FORK) || defined(AMIGAOS)) && !defined(VMS) && !defined(__LIBCATAMOUNT__)
a3021 1
    dVAR;
a3077 1
    dVAR;
d3116 1
a3116 1
		   aggregate does more work, beacuse next call to hv_iterinit()
a3291 1
    dVAR;
d3364 1
d3391 6
a3396 4
	    if (PerlLIO_stat(cur,&PL_statbuf) >= 0
		&& !S_ISDIR(PL_statbuf.st_mode)) {
		dosearch = 0;
		scriptname = cur;
d3398 1
a3398 1
		break;
d3400 1
d3426 1
d3463 2
a3464 2
		retval = PerlLIO_stat(tmpbuf,&PL_statbuf);
		if (S_ISDIR(PL_statbuf.st_mode)) {
d3475 2
a3476 2
	    if (S_ISREG(PL_statbuf.st_mode)
		&& cando(S_IRUSR,TRUE,&PL_statbuf)
d3478 1
a3478 1
		&& cando(S_IXUSR,TRUE,&PL_statbuf)
d3489 9
a3497 3
	if (!xfound && !seen_dot && !xfailed &&
	    (PerlLIO_stat(scriptname,&PL_statbuf) < 0
	     || S_ISDIR(PL_statbuf.st_mode)))
a3498 1
	    seen_dot = 1;			/* Disable message. */
d3521 1
a3522 1
#if defined(USE_ITHREADS)
d3544 1
d3546 1
d3569 2
a3570 1
 return &PL_Vars;
d3696 1
a3696 1
			name, direction);
d3779 1
d3786 1
d3797 1
a3797 1
Perl_mini_mktime(pTHX_ struct tm *ptm)
a3802 1
    PERL_UNUSED_CONTEXT;
d3985 3
d4088 1
a4088 1
Fill the sv with current working directory
d4096 1
a4096 1
 * Comments from the orignal:
a4104 1
    dVAR;
d4519 1
a4519 1
Exists to avoid test for a NULL function pointer and because it could
d4538 1
a4538 1
'true'.  Exists to avoid test for a NULL function pointer and because it
d4562 17
a4578 10
	    opt = (U32) atoi(p);
	    while (isDIGIT(*p))
		p++;
	    if (*p && *p != '\n' && *p != '\r') {
	     if(isSPACE(*p)) goto the_end_of_the_opts_parser;
	     else
		 Perl_croak(aTHX_ "Unknown Unicode option letter '%c'", *p);
	    }
       }
       else {
a4632 4
#if defined(__OpenBSD__)
	return arc4random();
#else
    dVAR;
d4659 2
a4660 4
#ifdef VMS
    /* when[] = (low 32 bits, high 32 bits) of time since epoch
     * in 100-ns units, typically incremented ever 10 ms.        */
    unsigned int when[2];
a4661 3
#  ifdef HAS_GETTIMEOFDAY
    struct timeval when;
#  else
a4662 1
#  endif
d4672 5
a4676 1
#  define PERL_RANDOM_DEVICE "/dev/urandom"
d4688 1
a4688 5
#ifdef VMS
    _ckvmssts(sys$gettim(when));
    u = (U32)SEED_C1 * when[0] + (U32)SEED_C2 * when[1];
#else
#  ifdef HAS_GETTIMEOFDAY
d4691 1
a4691 1
#  else
a4693 1
#  endif
a4700 1
#endif
a4705 1
    dVAR;
d4795 1
d4853 1
d4872 1
a4872 1
/* -DPERL_MEM_LOG: the Perl_mem_log_..() is compiled, including the
d4879 1
a4879 1
 *    \d+ - fd		fd to write to		: must be 1st (atoi)
d4942 1
a4942 1
	 * gettimeofday() (see ext/Time-HiRes), the easiest way is
d4947 8
a4954 2
	    int fd = atoi(pmlenv);
	    if (!fd)
d4956 1
d4961 1
a4961 1
		PerlLIO_write(fd, buf, len);
d4996 1
a4996 1
	    PerlLIO_write(fd, buf, len);
d5021 2
d5035 2
d5048 2
d5098 106
d5218 1
a5218 1
    int retval;
d5221 3
d5225 42
d5268 1
a5268 1
    retval = vsnprintf(buffer, len, format, ap);
d5270 1
a5270 1
    retval = vsprintf(buffer, format, ap);
d5299 8
a5311 1

d5316 1
d5324 1
d5338 1
d5513 135
a5647 2
void
Perl_xs_version_bootcheck(pTHX_ U32 items, U32 ax, const char *xs_p,
d5661 1
a5661 1
	sv = get_sv(Perl_form(aTHX_ "%"SVf"::%s", module, vn), 0);
d5664 1
a5664 1
	    sv = get_sv(Perl_form(aTHX_ "%"SVf"::%s", module, vn), 0);
d5675 1
a5675 1
				    " does not match ", module, string);
d5681 2
a5682 2
		Perl_sv_catpvf(aTHX_ xpt, "$%"SVf"::%s %"SVf, module, vn,
			       string);
d5684 1
a5684 1
		Perl_sv_catpvf(aTHX_ xpt, "bootstrap parameter %"SVf, string);
a5693 30
void
Perl_xs_apiversion_bootcheck(pTHX_ SV *module, const char *api_p,
			     STRLEN api_len)
{
    SV *xpt = NULL;
    SV *compver = Perl_newSVpvn_flags(aTHX_ api_p, api_len, SVs_TEMP);
    SV *runver;

    PERL_ARGS_ASSERT_XS_APIVERSION_BOOTCHECK;

    /* This might croak  */
    compver = upg_version(compver, 0);
    /* This should never croak */
    runver = new_version(PL_apiversion);
    if (vcmp(compver, runver)) {
	SV *compver_string = vstringify(compver);
	SV *runver_string = vstringify(runver);
	xpt = Perl_newSVpvf(aTHX_ "Perl API version %"SVf
			    " of %"SVf" does not match %"SVf,
			    compver_string, module, runver_string);
	Perl_sv_2mortal(aTHX_ xpt);

	SvREFCNT_dec(compver_string);
	SvREFCNT_dec(runver_string);
    }
    SvREFCNT_dec(runver);
    if (xpt)
	Perl_croak_sv(aTHX_ xpt);
}

a5781 1
    dVAR;
d5797 1
a5797 1
	if (gv && !svp) {
d5800 1
a5800 1
	else if ( (CvFLAGS(cv) & (CVf_ANON | CVf_CLONED)) || !gv
d5820 1
a5820 4
	    sv_catpvn_flags(
	      dbsv, GvNAME(gv), GvNAMELEN(gv),
	      GvNAMEUTF8(gv) ? SV_CATUTF8 : SV_CATBYTES
	    );
d5838 1
a5838 1
Perl_my_dirfd(pTHX_ DIR * dir) {
d5848 2
a5849 2
    Perl_die(aTHX_ PL_no_func, "dirfd");
    assert(0); /* NOT REACHED */
d5922 1
a5922 1
    *random_state = FREEBSD_DRAND48_SEED_0 + ((U64TYPE)seed << 16);
d5966 773
a6738 1
 
a6740 6
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
@


1.23
log
@Apply local patches, remove excess files - perl-5.20.2
@
text
@d1880 4
a1883 1
    if (PL_warnhook == PERL_WARNHOOK_FATAL || ckDEAD(err)) {
@


1.22
log
@Fix merge issues, remove excess files - match perl-5.20.2 dist
@
text
@d4411 3
d4490 1
@


1.21
log
@Apply local patches to perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@a4410 3
#if defined(__OpenBSD__)
	return arc4random();
#else
a4486 1
#endif
d5306 1
a5306 1
	if (!svp) {
d5309 1
a5309 1
	else if ( (CvFLAGS(cv) & (CVf_ANON | CVf_CLONED))
@


1.20
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d4411 3
d4490 1
@


1.19
log
@To get a random seed, just call arc4random() instead of reading a
word from the (deprecated) /dev/arandom.  This also makes it work
in chroot environments.

ok deraadt@@ afresh@@
@
text
@d29 1
a29 1
#ifdef USE_PERLIO
d40 3
d54 4
d74 34
d117 1
a117 10
#ifdef HAS_64K_LIMIT
	if (size > 0xffff) {
	    PerlIO_printf(Perl_error_log,
			  "Allocation too large: %lx\n", size) FLUSH;
	    my_exit(1);
	}
#endif /* HAS_64K_LIMIT */
#ifdef PERL_TRACK_MEMPOOL
    size += sTHX;
#endif
d122 10
a131 1
    ptr = (Malloc_t)PerlMem_malloc(size?size:1);	/* malloc(0) is NASTY on our system */
d134 1
a134 1
#ifdef PERL_TRACK_MEMPOOL
d149 1
d151 6
a156 1
#  ifdef PERL_POISON
a157 2
#  endif
        ptr = (Malloc_t)((char*)ptr+sTHX);
d159 1
d185 5
a193 7
#ifdef HAS_64K_LIMIT
    if (size > 0xffff) {
	PerlIO_printf(Perl_error_log,
		      "Reallocation too large: %lx\n", size) FLUSH;
	my_exit(1);
    }
#endif /* HAS_64K_LIMIT */
d201 3
a203 3
#ifdef PERL_TRACK_MEMPOOL
    where = (Malloc_t)((char*)where-sTHX);
    size += sTHX;
d208 1
d221 3
d225 1
a225 1
#  endif
d232 12
d245 1
d251 1
a252 1
    if (ptr != NULL) {
d264 1
d266 2
d269 3
a271 2

        ptr = (Malloc_t)((char*)ptr+sTHX);
a272 1
#endif
d309 2
a310 2
#ifdef PERL_TRACK_MEMPOOL
        where = (Malloc_t)((char*)where-sTHX);
d315 4
d335 1
d337 2
d340 2
d343 1
a343 1
	    PoisonNew(where, header->size, char);
d347 7
d356 1
d358 1
d371 1
a371 1
#if defined(PERL_TRACK_MEMPOOL) || defined(HAS_64K_LIMIT) || defined(DEBUGGING)
d377 1
a377 1
#if defined(PERL_TRACK_MEMPOOL) || defined(HAS_64K_LIMIT) || defined(DEBUGGING)
d382 4
a385 4
	Perl_croak_memory_wrap();
#ifdef PERL_TRACK_MEMPOOL
    if (sTHX <= MEM_SIZE_MAX - (MEM_SIZE)total_size)
	total_size += sTHX;
d387 1
a387 1
	Perl_croak_memory_wrap();
a388 7
#ifdef HAS_64K_LIMIT
    if (total_size > 0xffff) {
	PerlIO_printf(Perl_error_log,
		      "Allocation too large: %lx\n", total_size) FLUSH;
	my_exit(1);
    }
#endif /* HAS_64K_LIMIT */
d394 7
a400 1
#ifdef PERL_TRACK_MEMPOOL
d416 1
a416 1
#ifdef PERL_TRACK_MEMPOOL
d421 1
d423 2
d430 1
d432 6
a437 1
#  ifdef PERL_POISON
d440 1
a440 1
	    ptr = (Malloc_t)((char*)ptr+sTHX);
d524 2
a525 1
    /* libc prior to 4.6.27 did not work properly on a NULL 'little' */
a614 1
    STRLEN rarest = 0;
d617 1
d621 1
a621 1
    if (isGV_with_GP(sv))
d633 3
a635 1
    s = (U8*)SvPV_force_mutable(sv, len);
d685 1
a685 1
	    rarest = i;
a688 2
    BmRARE(sv) = s[rarest];
    BmPREVIOUS(sv) = rarest;
d693 1
a693 1
			  BmRARE(sv), BmPREVIOUS(sv)));
d1003 9
a1011 4
Perl's version of C<strdup()>. Returns a pointer to a newly allocated
string which is a duplicate of C<pv>. The size of the string is
determined by C<strlen()>. The memory allocated for the new string can
be freed with the C<Safefree()> function.
d1035 1
a1035 1
Perl's version of what C<strndup()> would be if it existed. Returns a
d1037 2
a1038 1
C<len> bytes from C<pv>, plus a trailing NUL byte. The memory allocated for
d1041 4
d1096 1
a1096 1
which is shared between threads. (With the specific difference that a NULL
d1121 4
d1286 3
a1288 2
STATIC const COP*
S_closest_cop(pTHX_ const COP *cop, const OP *o)
d1291 3
a1293 1
    /* Look for PL_op starting from o.  cop is the last COP we've seen. */
d1297 3
a1299 1
    if (!o || o == PL_op)
d1315 1
a1315 1
	    new_cop = closest_cop(cop, kid);
d1385 2
a1386 1
	const COP *cop = closest_cop(PL_curcop, PL_curcop->op_sibling);
d1454 1
a1454 1
	Perl_magic_methcall(aTHX_ MUTABLE_SV(io), mg, "PRINT",
a1456 4
#ifdef USE_SFIO
	/* SFIO can really mess with your errno */
	dSAVED_ERRNO;
#endif
a1460 3
#ifdef USE_SFIO
	RESTORE_ERRNO;
#endif
d1695 1
a1695 1
terser object code than using C<Perl_croak>. Less code used on exception code
d1702 1
a1702 1
Perl_croak_no_modify()
d1711 1
a1711 1
Perl_croak_no_mem()
a1713 1

d1715 2
a1716 2
    PerlLIO_write(PerlIO_fileno(Perl_error_log),
		  PL_no_mem, sizeof(PL_no_mem)-1);
a1719 8
/* saves machine code for a common noreturn idiom typically used in Newx*() */
void
Perl_croak_memory_wrap(void)
{
    Perl_croak_nocontext("%s",PL_memory_wrap);
}


d2042 5
a2046 1
#   if defined(__CYGWIN__)|| defined(__SYMBIAN32__) || defined(__riscos__)
a2261 329
#ifdef MYSWAP
#if BYTEORDER != 0x4321
short
Perl_my_swap(pTHX_ short s)
{
#if (BYTEORDER & 1) == 0
    short result;

    result = ((s & 255) << 8) + ((s >> 8) & 255);
    return result;
#else
    return s;
#endif
}

long
Perl_my_htonl(pTHX_ long l)
{
    union {
	long result;
	char c[sizeof(long)];
    } u;

#if BYTEORDER == 0x1234 || BYTEORDER == 0x12345678
#if BYTEORDER == 0x12345678
    u.result = 0; 
#endif 
    u.c[0] = (l >> 24) & 255;
    u.c[1] = (l >> 16) & 255;
    u.c[2] = (l >> 8) & 255;
    u.c[3] = l & 255;
    return u.result;
#else
#if ((BYTEORDER - 0x1111) & 0x444) || !(BYTEORDER & 0xf)
    Perl_croak(aTHX_ "Unknown BYTEORDER\n");
#else
    I32 o;
    I32 s;

    for (o = BYTEORDER - 0x1111, s = 0; s < (sizeof(long)*8); o >>= 4, s += 8) {
	u.c[o & 0xf] = (l >> s) & 255;
    }
    return u.result;
#endif
#endif
}

long
Perl_my_ntohl(pTHX_ long l)
{
    union {
	long l;
	char c[sizeof(long)];
    } u;

#if BYTEORDER == 0x1234
    u.c[0] = (l >> 24) & 255;
    u.c[1] = (l >> 16) & 255;
    u.c[2] = (l >> 8) & 255;
    u.c[3] = l & 255;
    return u.l;
#else
#if ((BYTEORDER - 0x1111) & 0x444) || !(BYTEORDER & 0xf)
    Perl_croak(aTHX_ "Unknown BYTEORDER\n");
#else
    I32 o;
    I32 s;

    u.l = l;
    l = 0;
    for (o = BYTEORDER - 0x1111, s = 0; s < (sizeof(long)*8); o >>= 4, s += 8) {
	l |= (u.c[o & 0xf] & 255) << s;
    }
    return l;
#endif
#endif
}

#endif /* BYTEORDER != 0x4321 */
#endif /* MYSWAP */

/*
 * Little-endian byte order functions - 'v' for 'VAX', or 'reVerse'.
 * If these functions are defined,
 * the BYTEORDER is neither 0x1234 nor 0x4321.
 * However, this is not assumed.
 * -DWS
 */

#define HTOLE(name,type)					\
	type							\
	name (type n)					        \
	{							\
	    union {						\
		type value;					\
		char c[sizeof(type)];				\
	    } u;						\
	    U32 i;					        \
	    U32 s = 0;					        \
	    for (i = 0; i < sizeof(u.c); i++, s += 8) {		\
		u.c[i] = (n >> s) & 0xFF;			\
	    }							\
	    return u.value;					\
	}

#define LETOH(name,type)					\
	type							\
	name (type n)					        \
	{							\
	    union {						\
		type value;					\
		char c[sizeof(type)];				\
	    } u;						\
	    U32 i;					        \
	    U32 s = 0;					        \
	    u.value = n;					\
	    n = 0;						\
	    for (i = 0; i < sizeof(u.c); i++, s += 8) {		\
		n |= ((type)(u.c[i] & 0xFF)) << s;		\
	    }							\
	    return n;						\
	}

/*
 * Big-endian byte order functions.
 */

#define HTOBE(name,type)					\
	type							\
	name (type n)					        \
	{							\
	    union {						\
		type value;					\
		char c[sizeof(type)];				\
	    } u;						\
	    U32 i;					        \
	    U32 s = 8*(sizeof(u.c)-1);			        \
	    for (i = 0; i < sizeof(u.c); i++, s -= 8) {		\
		u.c[i] = (n >> s) & 0xFF;			\
	    }							\
	    return u.value;					\
	}

#define BETOH(name,type)					\
	type							\
	name (type n)					        \
	{							\
	    union {						\
		type value;					\
		char c[sizeof(type)];				\
	    } u;						\
	    U32 i;					        \
	    U32 s = 8*(sizeof(u.c)-1);			        \
	    u.value = n;					\
	    n = 0;						\
	    for (i = 0; i < sizeof(u.c); i++, s -= 8) {		\
		n |= ((type)(u.c[i] & 0xFF)) << s;		\
	    }							\
	    return n;						\
	}

/*
 * If we just can't do it...
 */

#define NOT_AVAIL(name,type)                                    \
        type                                                    \
        name (type n)                                           \
        {                                                       \
            Perl_croak_nocontext(#name "() not available");     \
            return n; /* not reached */                         \
        }


#if defined(HAS_HTOVS) && !defined(htovs)
HTOLE(htovs,short)
#endif
#if defined(HAS_HTOVL) && !defined(htovl)
HTOLE(htovl,long)
#endif
#if defined(HAS_VTOHS) && !defined(vtohs)
LETOH(vtohs,short)
#endif
#if defined(HAS_VTOHL) && !defined(vtohl)
LETOH(vtohl,long)
#endif

#ifdef PERL_NEED_MY_HTOLE16
# if U16SIZE == 2
HTOLE(Perl_my_htole16,U16)
# else
NOT_AVAIL(Perl_my_htole16,U16)
# endif
#endif
#ifdef PERL_NEED_MY_LETOH16
# if U16SIZE == 2
LETOH(Perl_my_letoh16,U16)
# else
NOT_AVAIL(Perl_my_letoh16,U16)
# endif
#endif
#ifdef PERL_NEED_MY_HTOBE16
# if U16SIZE == 2
HTOBE(Perl_my_htobe16,U16)
# else
NOT_AVAIL(Perl_my_htobe16,U16)
# endif
#endif
#ifdef PERL_NEED_MY_BETOH16
# if U16SIZE == 2
BETOH(Perl_my_betoh16,U16)
# else
NOT_AVAIL(Perl_my_betoh16,U16)
# endif
#endif

#ifdef PERL_NEED_MY_HTOLE32
# if U32SIZE == 4
HTOLE(Perl_my_htole32,U32)
# else
NOT_AVAIL(Perl_my_htole32,U32)
# endif
#endif
#ifdef PERL_NEED_MY_LETOH32
# if U32SIZE == 4
LETOH(Perl_my_letoh32,U32)
# else
NOT_AVAIL(Perl_my_letoh32,U32)
# endif
#endif
#ifdef PERL_NEED_MY_HTOBE32
# if U32SIZE == 4
HTOBE(Perl_my_htobe32,U32)
# else
NOT_AVAIL(Perl_my_htobe32,U32)
# endif
#endif
#ifdef PERL_NEED_MY_BETOH32
# if U32SIZE == 4
BETOH(Perl_my_betoh32,U32)
# else
NOT_AVAIL(Perl_my_betoh32,U32)
# endif
#endif

#ifdef PERL_NEED_MY_HTOLE64
# if U64SIZE == 8
HTOLE(Perl_my_htole64,U64)
# else
NOT_AVAIL(Perl_my_htole64,U64)
# endif
#endif
#ifdef PERL_NEED_MY_LETOH64
# if U64SIZE == 8
LETOH(Perl_my_letoh64,U64)
# else
NOT_AVAIL(Perl_my_letoh64,U64)
# endif
#endif
#ifdef PERL_NEED_MY_HTOBE64
# if U64SIZE == 8
HTOBE(Perl_my_htobe64,U64)
# else
NOT_AVAIL(Perl_my_htobe64,U64)
# endif
#endif
#ifdef PERL_NEED_MY_BETOH64
# if U64SIZE == 8
BETOH(Perl_my_betoh64,U64)
# else
NOT_AVAIL(Perl_my_betoh64,U64)
# endif
#endif

#ifdef PERL_NEED_MY_HTOLES
HTOLE(Perl_my_htoles,short)
#endif
#ifdef PERL_NEED_MY_LETOHS
LETOH(Perl_my_letohs,short)
#endif
#ifdef PERL_NEED_MY_HTOBES
HTOBE(Perl_my_htobes,short)
#endif
#ifdef PERL_NEED_MY_BETOHS
BETOH(Perl_my_betohs,short)
#endif

#ifdef PERL_NEED_MY_HTOLEI
HTOLE(Perl_my_htolei,int)
#endif
#ifdef PERL_NEED_MY_LETOHI
LETOH(Perl_my_letohi,int)
#endif
#ifdef PERL_NEED_MY_HTOBEI
HTOBE(Perl_my_htobei,int)
#endif
#ifdef PERL_NEED_MY_BETOHI
BETOH(Perl_my_betohi,int)
#endif

#ifdef PERL_NEED_MY_HTOLEL
HTOLE(Perl_my_htolel,long)
#endif
#ifdef PERL_NEED_MY_LETOHL
LETOH(Perl_my_letohl,long)
#endif
#ifdef PERL_NEED_MY_HTOBEL
HTOBE(Perl_my_htobel,long)
#endif
#ifdef PERL_NEED_MY_BETOHL
BETOH(Perl_my_betohl,long)
#endif

void
Perl_my_swabn(void *ptr, int n)
{
    char *s = (char *)ptr;
    char *e = s + (n-1);
    char tc;

    PERL_ARGS_ASSERT_MY_SWABN;

    for (n /= 2; n > 0; s++, e--, n--) {
      tc = *s;
      *s = *e;
      *e = tc;
    }
}

a2628 19
#ifdef DUMP_FDS
void
Perl_dump_fds(pTHX_ const char *const s)
{
    int fd;
    Stat_t tmpstatbuf;

    PERL_ARGS_ASSERT_DUMP_FDS;

    PerlIO_printf(Perl_debug_log,"%s", s);
    for (fd = 0; fd < 32; fd++) {
	if (PerlLIO_fstat(fd,&tmpstatbuf) >= 0)
	    PerlIO_printf(Perl_debug_log," %d",fd);
    }
    PerlIO_printf(Perl_debug_log,"\n");
    return;
}
#endif	/* DUMP_FDS */

a2820 1
    Sigsave_t hstat, istat, qstat;
d2828 6
d2835 1
a2835 1
#ifdef USE_PERLIO
d2838 1
a2838 1
    const bool should_wait = PerlIOUnix_refcnt(fd) == 1;
d2840 1
a2840 1
    const bool should_wait = 1;
a2842 4
    svp = av_fetch(PL_fdpid,fd,TRUE);
    pid = (SvTYPE(*svp) == SVt_IV) ? SvIVX(*svp) : -1;
    SvREFCNT_dec(*svp);
    *svp = &PL_sv_undef;
a2849 5
#ifndef PERL_MICRO
    rsignal_save(SIGHUP,  (Sighandler_t) SIG_IGN, &hstat);
    rsignal_save(SIGINT,  (Sighandler_t) SIG_IGN, &istat);
    rsignal_save(SIGQUIT, (Sighandler_t) SIG_IGN, &qstat);
#endif
a2852 5
#ifndef PERL_MICRO
    rsignal_restore(SIGHUP, &hstat);
    rsignal_restore(SIGINT, &istat);
    rsignal_restore(SIGQUIT, &qstat);
#endif
a2879 2
    if (!pid)
	return -1;
d2881 9
d2936 1
a2936 1
    result = wait4((pid==-1)?0:pid,statusp,flags,NULL);
d3020 1
a3020 1
	Perl_croak_memory_wrap();
d3418 1
a3418 1
	? NULL : PL_magic_vtables + vtbl_id;
d3424 1
a3424 1
#if defined(USE_PERLIO) || defined(FFLUSH_NULL) || defined(USE_SFIO)
d3516 2
a3517 1
	    (op == OP_READLINE   ? "readline"  :	/* "<HANDLE>" not nice */
d3549 1
a3549 1
#ifdef HAS_GNULIBC
d3806 2
d3809 2
d3834 2
d3837 2
a3889 1
#ifndef INCOMPLETE_TAINTS
a3890 1
#endif
d4032 1
a4032 1
#define VERSION_MAX 0x7FFFFFFF
d4034 3
a4036 2
/*
=for apidoc prescan_version
d4038 11
a4048 4
Validate that a given string can be parsed as a version object, but doesn't
actually perform the parsing.  Can use either strict or lax validation rules.
Can optionally set a number of hint variables to save the parsing code
some time when tokenizing.
d4050 6
a4055 11
=cut
*/
const char *
Perl_prescan_version(pTHX_ const char *s, bool strict,
		     const char **errstr,
		     bool *sqv, int *ssaw_decimal, int *swidth, bool *salpha) {
    bool qv = (sqv ? *sqv : FALSE);
    int width = 3;
    int saw_decimal = 0;
    bool alpha = FALSE;
    const char *d = s;
d4057 7
a4063 1
    PERL_ARGS_ASSERT_PRESCAN_VERSION;
d4065 14
a4078 2
    if (qv && isDIGIT(*d))
	goto dotted_decimal_version;
d4080 10
a4089 966
    if (*d == 'v') { /* explicit v-string */
	d++;
	if (isDIGIT(*d)) {
	    qv = TRUE;
	}
	else { /* degenerate v-string */
	    /* requires v1.2.3 */
	    BADVERSION(s,errstr,"Invalid version format (dotted-decimal versions require at least three parts)");
	}

dotted_decimal_version:
	if (strict && d[0] == '0' && isDIGIT(d[1])) {
	    /* no leading zeros allowed */
	    BADVERSION(s,errstr,"Invalid version format (no leading zeros)");
	}

	while (isDIGIT(*d)) 	/* integer part */
	    d++;

	if (*d == '.')
	{
	    saw_decimal++;
	    d++; 		/* decimal point */
	}
	else
	{
	    if (strict) {
		/* require v1.2.3 */
		BADVERSION(s,errstr,"Invalid version format (dotted-decimal versions require at least three parts)");
	    }
	    else {
		goto version_prescan_finish;
	    }
	}

	{
	    int i = 0;
	    int j = 0;
	    while (isDIGIT(*d)) {	/* just keep reading */
		i++;
		while (isDIGIT(*d)) {
		    d++; j++;
		    /* maximum 3 digits between decimal */
		    if (strict && j > 3) {
			BADVERSION(s,errstr,"Invalid version format (maximum 3 digits between decimals)");
		    }
		}
		if (*d == '_') {
		    if (strict) {
			BADVERSION(s,errstr,"Invalid version format (no underscores)");
		    }
		    if ( alpha ) {
			BADVERSION(s,errstr,"Invalid version format (multiple underscores)");
		    }
		    d++;
		    alpha = TRUE;
		}
		else if (*d == '.') {
		    if (alpha) {
			BADVERSION(s,errstr,"Invalid version format (underscores before decimal)");
		    }
		    saw_decimal++;
		    d++;
		}
		else if (!isDIGIT(*d)) {
		    break;
		}
		j = 0;
	    }

	    if (strict && i < 2) {
		/* requires v1.2.3 */
		BADVERSION(s,errstr,"Invalid version format (dotted-decimal versions require at least three parts)");
	    }
	}
    } 					/* end if dotted-decimal */
    else
    {					/* decimal versions */
	int j = 0;			/* may need this later */
	/* special strict case for leading '.' or '0' */
	if (strict) {
	    if (*d == '.') {
		BADVERSION(s,errstr,"Invalid version format (0 before decimal required)");
	    }
	    if (*d == '0' && isDIGIT(d[1])) {
		BADVERSION(s,errstr,"Invalid version format (no leading zeros)");
	    }
	}

	/* and we never support negative versions */
	if ( *d == '-') {
	    BADVERSION(s,errstr,"Invalid version format (negative version number)");
	}

	/* consume all of the integer part */
	while (isDIGIT(*d))
	    d++;

	/* look for a fractional part */
	if (*d == '.') {
	    /* we found it, so consume it */
	    saw_decimal++;
	    d++;
	}
	else if (!*d || *d == ';' || isSPACE(*d) || *d == '{' || *d == '}') {
	    if ( d == s ) {
		/* found nothing */
		BADVERSION(s,errstr,"Invalid version format (version required)");
	    }
	    /* found just an integer */
	    goto version_prescan_finish;
	}
	else if ( d == s ) {
	    /* didn't find either integer or period */
	    BADVERSION(s,errstr,"Invalid version format (non-numeric data)");
	}
	else if (*d == '_') {
	    /* underscore can't come after integer part */
	    if (strict) {
		BADVERSION(s,errstr,"Invalid version format (no underscores)");
	    }
	    else if (isDIGIT(d[1])) {
		BADVERSION(s,errstr,"Invalid version format (alpha without decimal)");
	    }
	    else {
		BADVERSION(s,errstr,"Invalid version format (misplaced underscore)");
	    }
	}
	else {
	    /* anything else after integer part is just invalid data */
	    BADVERSION(s,errstr,"Invalid version format (non-numeric data)");
	}

	/* scan the fractional part after the decimal point*/

	if (!isDIGIT(*d) && (strict || ! (!*d || *d == ';' || isSPACE(*d) || *d == '{' || *d == '}') )) {
		/* strict or lax-but-not-the-end */
		BADVERSION(s,errstr,"Invalid version format (fractional part required)");
	}

	while (isDIGIT(*d)) {
	    d++; j++;
	    if (*d == '.' && isDIGIT(d[-1])) {
		if (alpha) {
		    BADVERSION(s,errstr,"Invalid version format (underscores before decimal)");
		}
		if (strict) {
		    BADVERSION(s,errstr,"Invalid version format (dotted-decimal versions must begin with 'v')");
		}
		d = (char *)s; 		/* start all over again */
		qv = TRUE;
		goto dotted_decimal_version;
	    }
	    if (*d == '_') {
		if (strict) {
		    BADVERSION(s,errstr,"Invalid version format (no underscores)");
		}
		if ( alpha ) {
		    BADVERSION(s,errstr,"Invalid version format (multiple underscores)");
		}
		if ( ! isDIGIT(d[1]) ) {
		    BADVERSION(s,errstr,"Invalid version format (misplaced underscore)");
		}
		width = j;
		d++;
		alpha = TRUE;
	    }
	}
    }

version_prescan_finish:
    while (isSPACE(*d))
	d++;

    if (!isDIGIT(*d) && (! (!*d || *d == ';' || *d == '{' || *d == '}') )) {
	/* trailing non-numeric data */
	BADVERSION(s,errstr,"Invalid version format (non-numeric data)");
    }

    if (sqv)
	*sqv = qv;
    if (swidth)
	*swidth = width;
    if (ssaw_decimal)
	*ssaw_decimal = saw_decimal;
    if (salpha)
	*salpha = alpha;
    return d;
}

/*
=for apidoc scan_version

Returns a pointer to the next character after the parsed
version string, as well as upgrading the passed in SV to
an RV.

Function must be called with an already existing SV like

    sv = newSV(0);
    s = scan_version(s, SV *sv, bool qv);

Performs some preprocessing to the string to ensure that
it has the correct characteristics of a version.  Flags the
object if it contains an underscore (which denotes this
is an alpha version).  The boolean qv denotes that the version
should be interpreted as if it had multiple decimals, even if
it doesn't.

=cut
*/

const char *
Perl_scan_version(pTHX_ const char *s, SV *rv, bool qv)
{
    const char *start = s;
    const char *pos;
    const char *last;
    const char *errstr = NULL;
    int saw_decimal = 0;
    int width = 3;
    bool alpha = FALSE;
    bool vinf = FALSE;
    AV * av;
    SV * hv;

    PERL_ARGS_ASSERT_SCAN_VERSION;

    while (isSPACE(*s)) /* leading whitespace is OK */
	s++;

    last = prescan_version(s, FALSE, &errstr, &qv, &saw_decimal, &width, &alpha);
    if (errstr) {
	/* "undef" is a special case and not an error */
	if ( ! ( *s == 'u' && strEQ(s,"undef")) ) {
	    Safefree(start);
	    Perl_croak(aTHX_ "%s", errstr);
	}
    }

    start = s;
    if (*s == 'v')
	s++;
    pos = s;

    /* Now that we are through the prescan, start creating the object */
    av = newAV();
    hv = newSVrv(rv, "version"); /* create an SV and upgrade the RV */
    (void)sv_upgrade(hv, SVt_PVHV); /* needs to be an HV type */

#ifndef NODEFAULT_SHAREKEYS
    HvSHAREKEYS_on(hv);         /* key-sharing on by default */
#endif

    if ( qv )
	(void)hv_stores(MUTABLE_HV(hv), "qv", newSViv(qv));
    if ( alpha )
	(void)hv_stores(MUTABLE_HV(hv), "alpha", newSViv(alpha));
    if ( !qv && width < 3 )
	(void)hv_stores(MUTABLE_HV(hv), "width", newSViv(width));

    while (isDIGIT(*pos))
	pos++;
    if (!isALPHA(*pos)) {
	I32 rev;

	for (;;) {
	    rev = 0;
	    {
  		/* this is atoi() that delimits on underscores */
  		const char *end = pos;
  		I32 mult = 1;
		I32 orev;

		/* the following if() will only be true after the decimal
		 * point of a version originally created with a bare
		 * floating point number, i.e. not quoted in any way
		 */
		if ( !qv && s > start && saw_decimal == 1 ) {
		    mult *= 100;
 		    while ( s < end ) {
			orev = rev;
 			rev += (*s - '0') * mult;
 			mult /= 10;
			if (   (PERL_ABS(orev) > PERL_ABS(rev)) 
			    || (PERL_ABS(rev) > VERSION_MAX )) {
			    Perl_ck_warner(aTHX_ packWARN(WARN_OVERFLOW), 
					   "Integer overflow in version %d",VERSION_MAX);
			    s = end - 1;
			    rev = VERSION_MAX;
			    vinf = 1;
			}
 			s++;
			if ( *s == '_' )
			    s++;
 		    }
  		}
 		else {
 		    while (--end >= s) {
			orev = rev;
 			rev += (*end - '0') * mult;
 			mult *= 10;
			if (   (PERL_ABS(orev) > PERL_ABS(rev)) 
			    || (PERL_ABS(rev) > VERSION_MAX )) {
			    Perl_ck_warner(aTHX_ packWARN(WARN_OVERFLOW), 
					   "Integer overflow in version");
			    end = s - 1;
			    rev = VERSION_MAX;
			    vinf = 1;
			}
 		    }
 		} 
  	    }

  	    /* Append revision */
	    av_push(av, newSViv(rev));
	    if ( vinf ) {
		s = last;
		break;
	    }
	    else if ( *pos == '.' )
		s = ++pos;
	    else if ( *pos == '_' && isDIGIT(pos[1]) )
		s = ++pos;
	    else if ( *pos == ',' && isDIGIT(pos[1]) )
		s = ++pos;
	    else if ( isDIGIT(*pos) )
		s = pos;
	    else {
		s = pos;
		break;
	    }
	    if ( qv ) {
		while ( isDIGIT(*pos) )
		    pos++;
	    }
	    else {
		int digits = 0;
		while ( ( isDIGIT(*pos) || *pos == '_' ) && digits < 3 ) {
		    if ( *pos != '_' )
			digits++;
		    pos++;
		}
	    }
	}
    }
    if ( qv ) { /* quoted versions always get at least three terms*/
	I32 len = av_len(av);
	/* This for loop appears to trigger a compiler bug on OS X, as it
	   loops infinitely. Yes, len is negative. No, it makes no sense.
	   Compiler in question is:
	   gcc version 3.3 20030304 (Apple Computer, Inc. build 1640)
	   for ( len = 2 - len; len > 0; len-- )
	   av_push(MUTABLE_AV(sv), newSViv(0));
	*/
	len = 2 - len;
	while (len-- > 0)
	    av_push(av, newSViv(0));
    }

    /* need to save off the current version string for later */
    if ( vinf ) {
	SV * orig = newSVpvn("v.Inf", sizeof("v.Inf")-1);
	(void)hv_stores(MUTABLE_HV(hv), "original", orig);
	(void)hv_stores(MUTABLE_HV(hv), "vinf", newSViv(1));
    }
    else if ( s > start ) {
	SV * orig = newSVpvn(start,s-start);
	if ( qv && saw_decimal == 1 && *start != 'v' ) {
	    /* need to insert a v to be consistent */
	    sv_insert(orig, 0, 0, "v", 1);
	}
	(void)hv_stores(MUTABLE_HV(hv), "original", orig);
    }
    else {
	(void)hv_stores(MUTABLE_HV(hv), "original", newSVpvs("0"));
	av_push(av, newSViv(0));
    }

    /* And finally, store the AV in the hash */
    (void)hv_stores(MUTABLE_HV(hv), "version", newRV_noinc(MUTABLE_SV(av)));

    /* fix RT#19517 - special case 'undef' as string */
    if ( *s == 'u' && strEQ(s,"undef") ) {
	s += 5;
    }

    return s;
}

/*
=for apidoc new_version

Returns a new version object based on the passed in SV:

    SV *sv = new_version(SV *ver);

Does not alter the passed in ver SV.  See "upg_version" if you
want to upgrade the SV.

=cut
*/

SV *
Perl_new_version(pTHX_ SV *ver)
{
    dVAR;
    SV * const rv = newSV(0);
    PERL_ARGS_ASSERT_NEW_VERSION;
    if ( sv_isobject(ver) && sv_derived_from(ver, "version") )
	 /* can just copy directly */
    {
	I32 key;
	AV * const av = newAV();
	AV *sav;
	/* This will get reblessed later if a derived class*/
	SV * const hv = newSVrv(rv, "version"); 
	(void)sv_upgrade(hv, SVt_PVHV); /* needs to be an HV type */
#ifndef NODEFAULT_SHAREKEYS
	HvSHAREKEYS_on(hv);         /* key-sharing on by default */
#endif

	if ( SvROK(ver) )
	    ver = SvRV(ver);

	/* Begin copying all of the elements */
	if ( hv_exists(MUTABLE_HV(ver), "qv", 2) )
	    (void)hv_stores(MUTABLE_HV(hv), "qv", newSViv(1));

	if ( hv_exists(MUTABLE_HV(ver), "alpha", 5) )
	    (void)hv_stores(MUTABLE_HV(hv), "alpha", newSViv(1));

	if ( hv_exists(MUTABLE_HV(ver), "width", 5 ) )
	{
	    const I32 width = SvIV(*hv_fetchs(MUTABLE_HV(ver), "width", FALSE));
	    (void)hv_stores(MUTABLE_HV(hv), "width", newSViv(width));
	}

	if ( hv_exists(MUTABLE_HV(ver), "original", 8 ) )
	{
	    SV * pv = *hv_fetchs(MUTABLE_HV(ver), "original", FALSE);
	    (void)hv_stores(MUTABLE_HV(hv), "original", newSVsv(pv));
	}

	sav = MUTABLE_AV(SvRV(*hv_fetchs(MUTABLE_HV(ver), "version", FALSE)));
	/* This will get reblessed later if a derived class*/
	for ( key = 0; key <= av_len(sav); key++ )
	{
	    const I32 rev = SvIV(*av_fetch(sav, key, FALSE));
	    av_push(av, newSViv(rev));
	}

	(void)hv_stores(MUTABLE_HV(hv), "version", newRV_noinc(MUTABLE_SV(av)));
	return rv;
    }
#ifdef SvVOK
    {
	const MAGIC* const mg = SvVSTRING_mg(ver);
	if ( mg ) { /* already a v-string */
	    const STRLEN len = mg->mg_len;
	    char * const version = savepvn( (const char*)mg->mg_ptr, len);
	    sv_setpvn(rv,version,len);
	    /* this is for consistency with the pure Perl class */
	    if ( isDIGIT(*version) )
		sv_insert(rv, 0, 0, "v", 1);
	    Safefree(version);
	}
	else {
#endif
	sv_setsv(rv,ver); /* make a duplicate */
#ifdef SvVOK
	}
    }
#endif
    return upg_version(rv, FALSE);
}

/*
=for apidoc upg_version

In-place upgrade of the supplied SV to a version object.

    SV *sv = upg_version(SV *sv, bool qv);

Returns a pointer to the upgraded SV.  Set the boolean qv if you want
to force this SV to be interpreted as an "extended" version.

=cut
*/

SV *
Perl_upg_version(pTHX_ SV *ver, bool qv)
{
    const char *version, *s;
#ifdef SvVOK
    const MAGIC *mg;
#endif

    PERL_ARGS_ASSERT_UPG_VERSION;

    if ( SvNOK(ver) && !( SvPOK(ver) && sv_len(ver) == 3 ) )
    {
	STRLEN len;

	/* may get too much accuracy */ 
	char tbuf[64];
#ifdef __vax__
	SV *sv = SvNVX(ver) > 10e37 ? newSV(64) : 0;
#else
	SV *sv = SvNVX(ver) > 10e50 ? newSV(64) : 0;
#endif
	char *buf;
#ifdef USE_LOCALE_NUMERIC
	char *loc = savepv(setlocale(LC_NUMERIC, NULL));
	setlocale(LC_NUMERIC, "C");
#endif
	if (sv) {
	    Perl_sv_setpvf(aTHX_ sv, "%.9"NVff, SvNVX(ver));
	    buf = SvPV(sv, len);
	}
	else {
	    len = my_snprintf(tbuf, sizeof(tbuf), "%.9"NVff, SvNVX(ver));
	    buf = tbuf;
	}
#ifdef USE_LOCALE_NUMERIC
	setlocale(LC_NUMERIC, loc);
	Safefree(loc);
#endif
	while (buf[len-1] == '0' && len > 0) len--;
	if ( buf[len-1] == '.' ) len--; /* eat the trailing decimal */
	version = savepvn(buf, len);
	SvREFCNT_dec(sv);
    }
#ifdef SvVOK
    else if ( (mg = SvVSTRING_mg(ver)) ) { /* already a v-string */
	version = savepvn( (const char*)mg->mg_ptr,mg->mg_len );
	qv = TRUE;
    }
#endif
    else /* must be a string or something like a string */
    {
	STRLEN len;
	version = savepv(SvPV(ver,len));
#ifndef SvVOK
#  if PERL_VERSION > 5
	/* This will only be executed for 5.6.0 - 5.8.0 inclusive */
	if ( len >= 3 && !instr(version,".") && !instr(version,"_")) {
	    /* may be a v-string */
	    char *testv = (char *)version;
	    STRLEN tlen = len;
	    for (tlen=0; tlen < len; tlen++, testv++) {
		/* if one of the characters is non-text assume v-string */
		if (testv[0] < ' ') {
		    SV * const nsv = sv_newmortal();
		    const char *nver;
		    const char *pos;
		    int saw_decimal = 0;
		    sv_setpvf(nsv,"v%vd",ver);
		    pos = nver = savepv(SvPV_nolen(nsv));

		    /* scan the resulting formatted string */
		    pos++; /* skip the leading 'v' */
		    while ( *pos == '.' || isDIGIT(*pos) ) {
			if ( *pos == '.' )
			    saw_decimal++ ;
			pos++;
		    }

		    /* is definitely a v-string */
		    if ( saw_decimal >= 2 ) {
			Safefree(version);
			version = nver;
		    }
		    break;
		}
	    }
	}
#  endif
#endif
    }

    s = scan_version(version, ver, qv);
    if ( *s != '\0' ) 
	Perl_ck_warner(aTHX_ packWARN(WARN_MISC), 
		       "Version string '%s' contains invalid data; "
		       "ignoring: '%s'", version, s);
    Safefree(version);
    return ver;
}

/*
=for apidoc vverify

Validates that the SV contains valid internal structure for a version object.
It may be passed either the version object (RV) or the hash itself (HV).  If
the structure is valid, it returns the HV.  If the structure is invalid,
it returns NULL.

    SV *hv = vverify(sv);

Note that it only confirms the bare minimum structure (so as not to get
confused by derived classes which may contain additional hash entries):

=over 4

=item * The SV is an HV or a reference to an HV

=item * The hash contains a "version" key

=item * The "version" key has a reference to an AV as its value

=back

=cut
*/

SV *
Perl_vverify(pTHX_ SV *vs)
{
    SV *sv;

    PERL_ARGS_ASSERT_VVERIFY;

    if ( SvROK(vs) )
	vs = SvRV(vs);

    /* see if the appropriate elements exist */
    if ( SvTYPE(vs) == SVt_PVHV
	 && hv_exists(MUTABLE_HV(vs), "version", 7)
	 && (sv = SvRV(*hv_fetchs(MUTABLE_HV(vs), "version", FALSE)))
	 && SvTYPE(sv) == SVt_PVAV )
	return vs;
    else
	return NULL;
}

/*
=for apidoc vnumify

Accepts a version object and returns the normalized floating
point representation.  Call like:

    sv = vnumify(rv);

NOTE: you can pass either the object directly or the SV
contained within the RV.

The SV returned has a refcount of 1.

=cut
*/

SV *
Perl_vnumify(pTHX_ SV *vs)
{
    I32 i, len, digit;
    int width;
    bool alpha = FALSE;
    SV *sv;
    AV *av;

    PERL_ARGS_ASSERT_VNUMIFY;

    /* extract the HV from the object */
    vs = vverify(vs);
    if ( ! vs )
	Perl_croak(aTHX_ "Invalid version object");

    /* see if various flags exist */
    if ( hv_exists(MUTABLE_HV(vs), "alpha", 5 ) )
	alpha = TRUE;
    if ( hv_exists(MUTABLE_HV(vs), "width", 5 ) )
	width = SvIV(*hv_fetchs(MUTABLE_HV(vs), "width", FALSE));
    else
	width = 3;


    /* attempt to retrieve the version array */
    if ( !(av = MUTABLE_AV(SvRV(*hv_fetchs(MUTABLE_HV(vs), "version", FALSE))) ) ) {
	return newSVpvs("0");
    }

    len = av_len(av);
    if ( len == -1 )
    {
	return newSVpvs("0");
    }

    digit = SvIV(*av_fetch(av, 0, 0));
    sv = Perl_newSVpvf(aTHX_ "%d.", (int)PERL_ABS(digit));
    for ( i = 1 ; i < len ; i++ )
    {
	digit = SvIV(*av_fetch(av, i, 0));
	if ( width < 3 ) {
	    const int denom = (width == 2 ? 10 : 100);
	    const div_t term = div((int)PERL_ABS(digit),denom);
	    Perl_sv_catpvf(aTHX_ sv, "%0*d_%d", width, term.quot, term.rem);
	}
	else {
	    Perl_sv_catpvf(aTHX_ sv, "%0*d", width, (int)digit);
	}
    }

    if ( len > 0 )
    {
	digit = SvIV(*av_fetch(av, len, 0));
	if ( alpha && width == 3 ) /* alpha version */
	    sv_catpvs(sv,"_");
	Perl_sv_catpvf(aTHX_ sv, "%0*d", width, (int)digit);
    }
    else /* len == 0 */
    {
	sv_catpvs(sv, "000");
    }
    return sv;
}

/*
=for apidoc vnormal

Accepts a version object and returns the normalized string
representation.  Call like:

    sv = vnormal(rv);

NOTE: you can pass either the object directly or the SV
contained within the RV.

The SV returned has a refcount of 1.

=cut
*/

SV *
Perl_vnormal(pTHX_ SV *vs)
{
    I32 i, len, digit;
    bool alpha = FALSE;
    SV *sv;
    AV *av;

    PERL_ARGS_ASSERT_VNORMAL;

    /* extract the HV from the object */
    vs = vverify(vs);
    if ( ! vs )
	Perl_croak(aTHX_ "Invalid version object");

    if ( hv_exists(MUTABLE_HV(vs), "alpha", 5 ) )
	alpha = TRUE;
    av = MUTABLE_AV(SvRV(*hv_fetchs(MUTABLE_HV(vs), "version", FALSE)));

    len = av_len(av);
    if ( len == -1 )
    {
	return newSVpvs("");
    }
    digit = SvIV(*av_fetch(av, 0, 0));
    sv = Perl_newSVpvf(aTHX_ "v%"IVdf, (IV)digit);
    for ( i = 1 ; i < len ; i++ ) {
	digit = SvIV(*av_fetch(av, i, 0));
	Perl_sv_catpvf(aTHX_ sv, ".%"IVdf, (IV)digit);
    }

    if ( len > 0 )
    {
	/* handle last digit specially */
	digit = SvIV(*av_fetch(av, len, 0));
	if ( alpha )
	    Perl_sv_catpvf(aTHX_ sv, "_%"IVdf, (IV)digit);
	else
	    Perl_sv_catpvf(aTHX_ sv, ".%"IVdf, (IV)digit);
    }

    if ( len <= 2 ) { /* short version, must be at least three */
	for ( len = 2 - len; len != 0; len-- )
	    sv_catpvs(sv,".0");
    }
    return sv;
}

/*
=for apidoc vstringify

In order to maintain maximum compatibility with earlier versions
of Perl, this function will return either the floating point
notation or the multiple dotted notation, depending on whether
the original version contained 1 or more dots, respectively.

The SV returned has a refcount of 1.

=cut
*/

SV *
Perl_vstringify(pTHX_ SV *vs)
{
    PERL_ARGS_ASSERT_VSTRINGIFY;

    /* extract the HV from the object */
    vs = vverify(vs);
    if ( ! vs )
	Perl_croak(aTHX_ "Invalid version object");

    if (hv_exists(MUTABLE_HV(vs), "original",  sizeof("original") - 1)) {
	SV *pv;
	pv = *hv_fetchs(MUTABLE_HV(vs), "original", FALSE);
	if ( SvPOK(pv) )
	    return newSVsv(pv);
	else
	    return &PL_sv_undef;
    }
    else {
	if ( hv_exists(MUTABLE_HV(vs), "qv", 2) )
	    return vnormal(vs);
	else
	    return vnumify(vs);
    }
}

/*
=for apidoc vcmp

Version object aware cmp.  Both operands must already have been 
converted into version objects.

=cut
*/

int
Perl_vcmp(pTHX_ SV *lhv, SV *rhv)
{
    I32 i,l,m,r,retval;
    bool lalpha = FALSE;
    bool ralpha = FALSE;
    I32 left = 0;
    I32 right = 0;
    AV *lav, *rav;

    PERL_ARGS_ASSERT_VCMP;

    /* extract the HVs from the objects */
    lhv = vverify(lhv);
    rhv = vverify(rhv);
    if ( ! ( lhv && rhv ) )
	Perl_croak(aTHX_ "Invalid version object");

    /* get the left hand term */
    lav = MUTABLE_AV(SvRV(*hv_fetchs(MUTABLE_HV(lhv), "version", FALSE)));
    if ( hv_exists(MUTABLE_HV(lhv), "alpha", 5 ) )
	lalpha = TRUE;

    /* and the right hand term */
    rav = MUTABLE_AV(SvRV(*hv_fetchs(MUTABLE_HV(rhv), "version", FALSE)));
    if ( hv_exists(MUTABLE_HV(rhv), "alpha", 5 ) )
	ralpha = TRUE;

    l = av_len(lav);
    r = av_len(rav);
    m = l < r ? l : r;
    retval = 0;
    i = 0;
    while ( i <= m && retval == 0 )
    {
	left  = SvIV(*av_fetch(lav,i,0));
	right = SvIV(*av_fetch(rav,i,0));
	if ( left < right  )
	    retval = -1;
	if ( left > right )
	    retval = +1;
	i++;
    }

    /* tiebreaker for alpha with identical terms */
    if ( retval == 0 && l == r && left == right && ( lalpha || ralpha ) )
    {
	if ( lalpha && !ralpha )
	{
	    retval = -1;
	}
	else if ( ralpha && !lalpha)
	{
	    retval = +1;
	}
    }

    if ( l != r && retval == 0 ) /* possible match except for trailing 0's */
    {
	if ( l < r )
	{
	    while ( i <= r && retval == 0 )
	    {
		if ( SvIV(*av_fetch(rav,i,0)) != 0 )
		    retval = -1; /* not a match after all */
		i++;
	    }
	}
	else
	{
	    while ( i <= l && retval == 0 )
	    {
		if ( SvIV(*av_fetch(lav,i,0)) != 0 )
		    retval = +1; /* not a match after all */
		i++;
	    }
	}
    }
    return retval;
}

#if !defined(HAS_SOCKETPAIR) && defined(HAS_SOCKET) && defined(AF_INET) && defined(PF_INET) && defined(SOCK_DGRAM) && defined(HAS_SELECT)
#   define EMULATE_SOCKETPAIR_UDP
#endif

#ifdef EMULATE_SOCKETPAIR_UDP
static int
S_socketpair_udp (int fd[2]) {
    dTHX;
    /* Fake a datagram socketpair using UDP to localhost.  */
    int sockets[2] = {-1, -1};
    struct sockaddr_in addresses[2];
    int i;
    Sock_size_t size = sizeof(struct sockaddr_in);
    unsigned short port;
    int got;

    memset(&addresses, 0, sizeof(addresses));
    i = 1;
    do {
	sockets[i] = PerlSock_socket(AF_INET, SOCK_DGRAM, PF_INET);
	if (sockets[i] == -1)
	    goto tidy_up_and_fail;

	addresses[i].sin_family = AF_INET;
	addresses[i].sin_addr.s_addr = htonl(INADDR_LOOPBACK);
	addresses[i].sin_port = 0;	/* kernel choses port.  */
	if (PerlSock_bind(sockets[i], (struct sockaddr *) &addresses[i],
		sizeof(struct sockaddr_in)) == -1)
	    goto tidy_up_and_fail;
    } while (i--);

    /* Now have 2 UDP sockets. Find out which port each is connected to, and
       for each connect the other socket to it.  */
    i = 1;
    do {
	if (PerlSock_getsockname(sockets[i], (struct sockaddr *) &addresses[i],
		&size) == -1)
	    goto tidy_up_and_fail;
	if (size != sizeof(struct sockaddr_in))
	    goto abort_tidy_up_and_fail;
	/* !1 is 0, !0 is 1 */
	if (PerlSock_connect(sockets[!i], (struct sockaddr *) &addresses[i],
		sizeof(struct sockaddr_in)) == -1)
	    goto tidy_up_and_fail;
    } while (i--);

    /* Now we have 2 sockets connected to each other. I don't trust some other
       process not to have already sent a packet to us (by random) so send
       a packet from each to the other.  */
    i = 1;
    do {
	/* I'm going to send my own port number.  As a short.
	   (Who knows if someone somewhere has sin_port as a bitfield and needs
	   this routine. (I'm assuming crays have socketpair)) */
	port = addresses[i].sin_port;
	got = PerlLIO_write(sockets[i], &port, sizeof(port));
d4302 2
a4303 1
Or "locks" it. Or "unlocks" it. In other words, ignores its single SV argument.
a4410 3
#if defined(__OpenBSD__)
	return arc4random();
#else
a4486 1
#endif
d4580 2
a4581 2
    const IV nppaddr = sizeof(Gppaddr)/sizeof(Perl_ppaddr_t);
    const IV ncheck  = sizeof(Gcheck) /sizeof(Perl_check_t);
d4620 4
d4636 2
d4643 2
d4851 1
a4851 1
the length of the string written to the buffer. Only rare pre-ANSI systems
d4932 1
d4981 1
a4981 2
    int bufsiz = bsiz * sizeof(char); /* sizeof(char) paranoid? */
    char *buf = (char*)safesysmalloc(bufsiz);
d4988 1
a4988 2
        bufsiz = bsiz * sizeof(char); /* keep bsiz and bufsiz in sync */
        buf = (char*)safesysmalloc(bufsiz);
d5202 20
d5239 14
d5281 2
a5282 3
	&& (gvp = (GV **)hv_fetch(
			GvSTASH(gv), GvNAME(gv),
			GvNAMEUTF8(gv) ? -GvNAMELEN(gv) : GvNAMELEN(gv), 0
d5342 1
d5380 99
@


1.18
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d5589 3
d5668 1
@


1.17
log
@In Perl_upg_version(), do not compare double against 10e50 on vax, for this
value can not be represented by a double (unless compiling with -mg); instead,
use a lower limit value. This does not impact the behaviour since both sides
of the test are supposed to produce the same result, albeit in different ways.

ok millert@@ espie@@
@
text
@d27 1
a62 11
static char *
S_write_no_mem(pTHX)
{
    dVAR;
    /* Can't use PerlIO to write as it allocates memory */
    PerlLIO_write(PerlIO_fileno(Perl_error_log),
		  PL_no_mem, strlen(PL_no_mem));
    my_exit(1);
    NORETURN_FUNCTION_END;
}

d124 1
a124 1
	    return write_no_mem();
d227 1
a227 1
	    return write_no_mem();
d300 1
a300 1
	Perl_croak_nocontext("%s", PL_memory_wrap);
d305 1
a305 1
	Perl_croak_nocontext("%s", PL_memory_wrap);
d361 1
a361 1
	return write_no_mem();
d399 1
a399 1
Perl_delimcpy(register char *to, register const char *toend, register const char *from, register const char *fromend, register int delim, I32 *retlen)
d401 1
a401 1
    register I32 tolen;
d429 1
a429 1
Perl_instr(register const char *big, register const char *little)
a430 1
    register I32 first;
d434 1
d437 1
a437 21
    first = *little++;
    if (!first)
	return (char*)big;
    while (*big) {
	register const char *s, *x;
	if (*big++ != first)
	    continue;
	for (x=big,s=little; *s; /**/ ) {
	    if (!*x)
		return NULL;
	    if (*s != *x)
		break;
	    else {
		s++;
		x++;
	    }
	}
	if (!*s)
	    return (char*)(big-1);
    }
    return NULL;
d470 1
a470 1
Perl_rninstr(register const char *big, const char *bigend, const char *little, const char *lend)
d472 3
a474 3
    register const char *bigbeg;
    register const I32 first = *little;
    register const char * const littleend = lend;
d483 1
a483 1
	register const char *s, *x;
d521 1
a521 1
    register const U8 *s;
d530 1
a530 5
    /* Refuse to fbm_compile a studied scalar, as this gives more flexibility in
       SV flag usage.  No real-world code would ever end up using a studied
       scalar as a compile-time second argument to index, so this isn't a real
       pessimisation.  */
    if (SvSCREAM(sv))
d573 1
a573 1
	register U8 *table;
d612 2
a613 2
Returns the location of the SV in the string delimited by C<str> and
C<strend>.  It returns C<NULL> if the string can't be found.  The C<sv>
d621 1
a621 1
Perl_fbm_instr(pTHX_ unsigned char *big, register unsigned char *bigend, SV *littlestr, U32 flags)
d623 1
a623 1
    register unsigned char *s;
d625 3
a627 4
    register const unsigned char *little
	= (const unsigned char *)SvPV_const(littlestr,l);
    register STRLEN littlelen = l;
    register const I32 multiline = flags & FBMrf_MULTILINE;
d763 1
a763 1
	register const unsigned char *oldlittle;
d771 1
a771 1
	    register I32 tmp;
d780 1
a780 1
		register unsigned char * const olds = s;
a805 15
/* start_shift, end_shift are positive quantities which give offsets
   of ends of some substring of bigstr.
   If "last" we want the last occurrence.
   old_posp is the way of communication between consequent calls if
   the next call needs to find the .
   The initial *old_posp should be -1.

   Note that we take into account SvTAIL, so one can get extra
   optimizations if _ALL flag is set.
 */

/* If SvTAIL is actually due to \Z or \z, this gives false positives
   if PL_multiline.  In fact if !PL_multiline the authoritative answer
   is not supported yet. */

a809 12
    register const unsigned char *big;
    U32 pos = 0; /* hush a gcc warning */
    register I32 previous;
    register I32 first;
    register const unsigned char *little;
    register I32 stop_pos;
    register const unsigned char *littleend;
    bool found = FALSE;
    const MAGIC * mg;
    const void *screamnext_raw = NULL; /* hush a gcc warning */
    bool cant_find = FALSE; /* hush a gcc warning */

d811 10
a820 136

    assert(SvMAGICAL(bigstr));
    mg = mg_find(bigstr, PERL_MAGIC_study);
    assert(mg);
    assert(SvTYPE(littlestr) == SVt_PVMG);
    assert(SvVALID(littlestr));

    if (mg->mg_private == 1) {
	const U8 *const screamfirst = (U8 *)mg->mg_ptr;
	const U8 *const screamnext = screamfirst + 256;

	screamnext_raw = (const void *)screamnext;

	pos = *old_posp == -1
	    ? screamfirst[BmRARE(littlestr)] : screamnext[*old_posp];
	cant_find = pos == (U8)~0;
    } else if (mg->mg_private == 2) {
	const U16 *const screamfirst = (U16 *)mg->mg_ptr;
	const U16 *const screamnext = screamfirst + 256;

	screamnext_raw = (const void *)screamnext;

	pos = *old_posp == -1
	    ? screamfirst[BmRARE(littlestr)] : screamnext[*old_posp];
	cant_find = pos == (U16)~0;
    } else if (mg->mg_private == 4) {
	const U32 *const screamfirst = (U32 *)mg->mg_ptr;
	const U32 *const screamnext = screamfirst + 256;

	screamnext_raw = (const void *)screamnext;

	pos = *old_posp == -1
	    ? screamfirst[BmRARE(littlestr)] : screamnext[*old_posp];
	cant_find = pos == (U32)~0;
    } else
	Perl_croak(aTHX_ "panic: unknown study size %u", mg->mg_private);

    if (cant_find) {
      cant_find:
	if ( BmRARE(littlestr) == '\n'
	     && BmPREVIOUS(littlestr) == SvCUR(littlestr) - 1) {
	    little = (const unsigned char *)(SvPVX_const(littlestr));
	    littleend = little + SvCUR(littlestr);
	    first = *little++;
	    goto check_tail;
	}
	return NULL;
    }

    little = (const unsigned char *)(SvPVX_const(littlestr));
    littleend = little + SvCUR(littlestr);
    first = *little++;
    /* The value of pos we can start at: */
    previous = BmPREVIOUS(littlestr);
    big = (const unsigned char *)(SvPVX_const(bigstr));
    /* The value of pos we can stop at: */
    stop_pos = SvCUR(bigstr) - end_shift - (SvCUR(littlestr) - 1 - previous);
    if (previous + start_shift > stop_pos) {
/*
  stop_pos does not include SvTAIL in the count, so this check is incorrect
  (I think) - see [ID 20010618.006] and t/op/study.t. HVDS 2001/06/19
*/
#if 0
	if (previous + start_shift == stop_pos + 1) /* A fake '\n'? */
	    goto check_tail;
#endif
	return NULL;
    }
    if (mg->mg_private == 1) {
	const U8 *const screamnext = (const U8 *const) screamnext_raw;
	while ((I32)pos < previous + start_shift) {
	    pos = screamnext[pos];
	    if (pos == (U8)~0)
		goto cant_find;
	}
    } else if (mg->mg_private == 2) {
	const U16 *const screamnext = (const U16 *const) screamnext_raw;
	while ((I32)pos < previous + start_shift) {
	    pos = screamnext[pos];
	    if (pos == (U16)~0)
		goto cant_find;
	}
    } else if (mg->mg_private == 4) {
	const U32 *const screamnext = (const U32 *const) screamnext_raw;
	while ((I32)pos < previous + start_shift) {
	    pos = screamnext[pos];
	    if (pos == (U32)~0)
		goto cant_find;
	}
    }
    big -= previous;
    while (1) {
	if ((I32)pos >= stop_pos) break;
	if (big[pos] == first) {
	    const unsigned char *s = little;
	    const unsigned char *x = big + pos + 1;
	    while (s < littleend) {
		if (*s != *x++)
		    break;
		++s;
	    }
	    if (s == littleend) {
		*old_posp = (I32)pos;
		if (!last) return (char *)(big+pos);
		found = TRUE;
	    }
	}
	if (mg->mg_private == 1) {
	    pos = ((const U8 *const)screamnext_raw)[pos];
	    if (pos == (U8)~0)
		break;
	} else if (mg->mg_private == 2) {
	    pos = ((const U16 *const)screamnext_raw)[pos];
	    if (pos == (U16)~0)
		break;
	} else if (mg->mg_private == 4) {
	    pos = ((const U32 *const)screamnext_raw)[pos];
	    if (pos == (U32)~0)
		break;
	}
    };
    if (last && found)
	return (char *)(big+(*old_posp));
  check_tail:
    if (!SvTAIL(littlestr) || (end_shift > 0))
	return NULL;
    /* Ignore the trailing "\n".  This code is not microoptimized */
    big = (const unsigned char *)(SvPVX_const(bigstr) + SvCUR(bigstr));
    stop_pos = littleend - little;	/* Actual littlestr len */
    if (stop_pos == 0)
	return (char*)big;
    big -= stop_pos;
    if (*big == first
	&& ((stop_pos == 1) ||
	    memEQ((char *)(big + 1), (char *)little, stop_pos - 1)))
	return (char*)big;
d837 1
a837 1
Perl_foldEQ(const char *s1, const char *s2, register I32 len)
d839 2
a840 2
    register const U8 *a = (const U8 *)s1;
    register const U8 *b = (const U8 *)s2;
d844 2
d854 1
a854 1
Perl_foldEQ_latin1(const char *s1, const char *s2, register I32 len)
d861 2
a862 2
    register const U8 *a = (const U8 *)s1;
    register const U8 *b = (const U8 *)s2;
d866 2
d887 1
a887 1
Perl_foldEQ_locale(const char *s1, const char *s2, register I32 len)
d890 2
a891 2
    register const U8 *a = (const U8 *)s1;
    register const U8 *b = (const U8 *)s2;
d895 2
d948 1
a948 1
Perl_savepvn(pTHX_ const char *pv, register I32 len)
d950 1
a950 1
    register char *newaddr;
d953 2
d978 1
a978 1
    register char *newaddr;
d986 1
a986 1
	return write_no_mem();
d1008 1
a1008 1
	return write_no_mem();
d1028 1
a1028 1
    register char *newaddr;
d1286 1
d1288 1
a1288 1
			      SvCUR(PL_rs) == 1 && *SvPVX_const(PL_rs) == '\n');
d1438 1
a1438 1
    /* NOTREACHED */
d1460 1
a1460 1
    /* NOTREACHED */
d1472 1
a1472 1
    /* NOTREACHED */
d1572 1
a1572 1
    /* NOTREACHED */
d1583 1
a1583 1
    /* NOTREACHED */
d1598 22
a1619 1
Perl_croak_no_modify(pTHX)
d1621 11
a1631 1
    Perl_croak(aTHX_ "%s", PL_no_modify);
d1898 2
a1899 2
    register I32 i;
    register const I32 len = strlen(nam);
d1947 1
a1947 1
#   if defined(__CYGWIN__) || defined(EPOC) || defined(__SYMBIAN32__) || defined(__riscos__)
d1960 2
a1961 1
            (void)unsetenv(nam);
d1996 1
a1996 1
    register char *envstr;
d2012 1
a2012 1
#endif /* !VMS && !EPOC*/
d2031 1
a2031 1
Perl_my_bcopy(register const char *from,register char *to,register I32 len)
d2037 2
d2056 1
a2056 1
Perl_my_memset(register char *loc, register I32 ch, register I32 len)
d2062 2
d2073 1
a2073 1
Perl_my_bzero(register char *loc, register I32 len)
d2079 2
d2090 1
a2090 1
Perl_my_memcmp(const char *s1, const char *s2, register I32 len)
d2092 3
a2094 3
    register const U8 *a = (const U8 *)s1;
    register const U8 *b = (const U8 *)s2;
    register I32 tmp;
d2098 2
d2199 2
a2200 2
    register I32 o;
    register I32 s;
d2228 2
a2229 2
    register I32 o;
    register I32 s;
d2254 1
a2254 1
	name (register type n)					\
d2260 2
a2261 2
	    register U32 i;					\
	    register U32 s = 0;					\
d2270 1
a2270 1
	name (register type n)					\
d2276 2
a2277 2
	    register U32 i;					\
	    register U32 s = 0;					\
d2292 1
a2292 1
	name (register type n)					\
d2298 2
a2299 2
	    register U32 i;					\
	    register U32 s = 8*(sizeof(u.c)-1);			\
d2308 1
a2308 1
	name (register type n)					\
d2314 2
a2315 2
	    register U32 i;					\
	    register U32 s = 8*(sizeof(u.c)-1);			\
d2330 1
a2330 1
        name (register type n)                                  \
d2479 3
a2481 3
    register char *s = (char *)ptr;
    register char *e = s + (n-1);
    register char tc;
d2495 1
a2495 1
#if (!defined(DOSISH) || defined(HAS_FORK) || defined(AMIGAOS)) && !defined(OS2) && !defined(VMS) && !defined(__OPEN_VM) && !defined(EPOC) && !defined(NETWARE) && !defined(__LIBCATAMOUNT__)
d2498 2
a2499 2
    register I32 This, that;
    register Pid_t pid;
d2509 1
a2509 1
    if (PL_tainting) {
d2632 1
a2632 1
#if (!defined(DOSISH) || defined(HAS_FORK) || defined(AMIGAOS)) && !defined(VMS) && !defined(__OPEN_VM) && !defined(EPOC) && !defined(__LIBCATAMOUNT__)
d2638 2
a2639 2
    register I32 This, that;
    register Pid_t pid;
d2655 1
a2655 1
    if (doexec && PL_tainting) {
a2778 14
#if defined(atarist) || defined(EPOC)
FILE *popen();
PerlIO *
Perl_my_popen(pTHX_ const char *cmd, const char *mode)
{
    PERL_ARGS_ASSERT_MY_POPEN;
    PERL_FLUSHALL_FOR_CHILD;
    /* Call system's popen() to get a FILE *, then import it.
       used 0 for 2nd parameter to PerlIO_importFILE;
       apparently not used
    */
    return PerlIO_importFILE(popen(cmd, mode), 0);
}
#else
a2799 1
#endif
d2810 3
d2827 3
d3065 1
a3065 1
#if (!defined(DOSISH) || defined(HAS_FORK) || defined(AMIGAOS)) && !defined(VMS) && !defined(__OPEN_VM) && !defined(EPOC) && !defined(__LIBCATAMOUNT__)
a3097 3
#ifdef UTS
    if(PerlProc_kill(pid, 0) < 0) { return(pid); }   /* HOM 12/23/91 */
#endif
d3220 1
a3220 1
    register SV *sv;
d3229 1
a3229 1
#if defined(atarist) || defined(OS2) || defined(EPOC)
d3264 1
a3264 1
Perl_repeatcpy(register char *to, register const char *from, I32 len, register IV count)
d3268 2
d3271 1
a3271 1
	Perl_croak_nocontext("%s",PL_memory_wrap);
d3276 1
a3276 1
	register char *p = to;
d3281 1
a3281 1
	    register const char *q = from;
d3347 1
a3347 1
    register char *s;
d3351 1
a3351 1
#if defined(DOSISH) && !defined(OS2) && !defined(atarist)
d3474 1
a3474 1
#if defined(atarist) || defined(DOSISH)
a3475 3
#  ifdef atarist
		    && *s != ','
#  endif
d3482 1
a3482 1
#else  /* ! (atarist || DOSISH) */
d3486 1
a3486 1
#endif /* ! (atarist || DOSISH) */
d3492 1
a3492 1
#  if defined(atarist) || defined(DOSISH)
d3726 3
a3728 3
        SV * const name
           = gv && (isGV(gv) || isGV_with_GP(gv))
                ? sv_2mortal(newSVhek(GvENAME_HEK((gv))))
d3732 1
a3732 1
	if (name && SvPOK(name) && *SvPV_nolen(name))
d3734 1
a3734 1
			"Filehandle %"SVf" opened only for %sput",
d3761 1
a3761 1
            = gv && (isGV(gv) || isGV_with_GP(gv)) && GvENAMELEN(gv) ?
d3774 1
a3774 1
	const bool have_name = name && SvPOK(name) && *SvPV_nolen(name);
d3920 1
a3920 9
    /* allow given yday with no month & mday to dominate the result */
    if (ptm->tm_yday >= 0 && mday <= 0 && month <= 0) {
	month = 0;
	mday = 0;
	jday = 1 + ptm->tm_yday;
    }
    else {
	jday = 0;
    }
d4015 1
a4015 3
    /* fix tm_wday if not overridden by caller */
    if ((unsigned)ptm->tm_wday > 6)
	ptm->tm_wday = (jday + WEEKDAY_BIAS) % 7;
d4128 1
a4128 1
Perl_getcwd_sv(pTHX_ register SV *sv)
d4381 1
d4444 1
a4444 1
	    d++;
d4466 1
d4518 1
a4518 1
    const char *start;
d4526 2
a4527 2
    AV * const av = newAV();
    SV * const hv = newSVrv(rv, "version"); /* create an SV and upgrade the RV */
a4530 6
    (void)sv_upgrade(hv, SVt_PVHV); /* needs to be an HV type */

#ifndef NODEFAULT_SHAREKEYS
    HvSHAREKEYS_on(hv);         /* key-sharing on by default */
#endif

d4538 1
d4548 9
d4563 1
a4563 1
    
d4734 1
a4734 1
	
d4872 1
a4872 1
		    if ( saw_decimal >= 2 ) {	
d5363 1
a5363 1
    dTHX;
d5389 1
d5582 4
a5616 1
#  include <starlet.h>
d5667 2
a5668 2
UV
Perl_get_hash_seed(pTHX)
d5671 2
a5672 2
     const char *s = PerlEnv_getenv("PERL_HASH_SEED");
     UV myseed = 0;
d5674 1
a5674 28
     if (s)
	while (isSPACE(*s))
	    s++;
     if (s && isDIGIT(*s))
	  myseed = (UV)Atoul(s);
     else
#ifdef USE_HASH_SEED_EXPLICIT
     if (s)
#endif
     {
	  /* Compute a random seed */
	  (void)seedDrand01((Rand_seed_t)seed());
	  myseed = (UV)(Drand01() * (NV)UV_MAX);
#if RANDBITS < (UVSIZE * 8)
	  /* Since there are not enough randbits to to reach all
	   * the bits of a UV, the low bits might need extra
	   * help.  Sum in another random number that will
	   * fill in the low bits. */
	  myseed +=
	       (UV)(Drand01() * (NV)((((UV)1) << ((UVSIZE * 8 - RANDBITS))) - 1));
#endif /* RANDBITS < (UVSIZE * 8) */
	  if (myseed == 0) { /* Superparanoia. */
	      myseed = (UV)(Drand01() * (NV)UV_MAX); /* One more chance. */
	      if (myseed == 0)
		  Perl_croak(aTHX_ "Your random numbers are not that random");
	  }
     }
     PL_rehash_seed_set = TRUE;
d5676 1
a5676 2
     return myseed;
}
d5678 27
a5704 10
#ifdef USE_ITHREADS
bool
Perl_stashpv_hvname_match(pTHX_ const COP *c, const HV *hv)
{
    const char * stashpv = CopSTASHPV(c);
    const char * name    = HvNAME_get(hv);
    const bool utf8 = CopSTASH_len(c) < 0;
    const I32  len  = utf8 ? -CopSTASH_len(c) : CopSTASH_len(c);
    PERL_UNUSED_CONTEXT;
    PERL_ARGS_ASSERT_STASHPV_HVNAME_MATCH;
d5706 2
a5707 11
    if (!stashpv || !name)
	return stashpv == name;
    if ( !HvNAMEUTF8(hv) != !utf8 ) {
        if (utf8) {
            return (bytes_cmp_utf8(
                        (const U8*)stashpv, len,
                        (const U8*)name, HEK_LEN(HvNAME_HEK(hv))) == 0);
        } else {
            return (bytes_cmp_utf8(
                        (const U8*)name, HEK_LEN(HvNAME_HEK(hv)),
                        (const U8*)stashpv, len) == 0);
d5709 3
a5713 6
        return (stashpv == name
                    || (HEK_LEN(HvNAME_HEK(hv)) == len
			 && memEQ(stashpv, name, len)));
    /*NOTREACHED*/
    return FALSE;
}
d5715 2
d5718 29
a6053 1
    dTHX;
d6072 1
a6072 1
	Perl_croak(aTHX_ "panic: my_snprintf buffer overflow");
a6089 1
    dTHX;
d6117 1
a6117 1
	Perl_croak(aTHX_ "panic: my_vsnprintf buffer overflow");
d6158 1
d6430 1
a6430 1
    const bool save_taint = PL_tainted;
d6439 1
a6439 1
    PL_tainted = FALSE;
d6481 3
d6498 1
a6498 1
   /* NOT REACHED */
d6522 1
a6522 1
 * indent-tabs-mode: t
d6525 1
a6525 1
 * ex: set ts=8 sts=4 sw=4 noet:
@


1.16
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d4965 3
d4969 1
@


1.15
log
@Fix for CVE-2012-5195; ok miod@@
@
text
@d15 1
a15 1
 *     [p.598 of _The Lord of the Rings_, III/xi: "The PalantÌr"]
d28 4
a43 4
#ifdef I_SYS_WAIT
#  include <sys/wait.h>
#endif

d73 4
d82 1
d84 1
d97 2
a98 2
    if ((long)size < 0)
	Perl_croak_nocontext("panic: malloc");
a101 1
    DEBUG_m(PerlIO_printf(Perl_debug_log, "0x%"UVxf": (%05ld) malloc %ld bytes\n",PTR2UV(ptr),(long)PL_an++,(long)size));
d124 1
a126 2
    else if (PL_nomemok)
	return NULL;
d128 8
a135 1
	return write_no_mem();
d145 1
d147 1
d175 2
a176 1
	    Perl_croak_nocontext("panic: realloc from wrong pool");
d191 2
a192 2
    if ((long)size < 0)
	Perl_croak_nocontext("panic: realloc");
a229 2
    else if (PL_nomemok)
	return NULL;
d231 8
a238 1
	return write_no_mem();
d248 1
a248 1
#if defined(PERL_IMPLICIT_SYS) || defined(PERL_TRACK_MEMPOOL)
d262 2
a263 1
		Perl_croak_nocontext("panic: free from wrong pool");
d268 7
a274 3
	    if (!(header->next) || header->next->prev != header
		|| header->prev->next != header) {
		Perl_croak_nocontext("panic: bad free");
d295 1
d297 1
d299 1
d301 1
d304 2
a305 1
    if (size && (count <= MEM_SIZE_MAX / size))
d307 2
d325 3
a327 2
    if ((long)size < 0 || (long)count < 0)
	Perl_croak_nocontext("panic: calloc");
d365 8
a372 3
    else if (PL_nomemok)
	return NULL;
    return write_no_mem();
d470 2
a471 1
/* same as instr but allow embedded nulls */
d552 1
a552 1
    register U32 i;
d554 1
a554 1
    U32 rarest = 0;
d556 1
d560 10
d579 1
a579 1
    SvUPGRADE(sv, SVt_PVGV);
d583 19
d603 2
a604 1
	const unsigned char *sb;
d606 1
d609 1
a609 4
	Sv_Grow(sv, len + 256 + PERL_FBM_TABLE_OFFSET);
	table
	    = (unsigned char*)(SvPVX_mutable(sv) + len + PERL_FBM_TABLE_OFFSET);
	s = table - 1 - PERL_FBM_TABLE_OFFSET;	/* last char */
d611 4
a615 1
	sb = s - mlen + 1;			/* first char (maybe) */
a620 2
    } else {
	Sv_Grow(sv, len + PERL_FBM_TABLE_OFFSET);
a621 1
    sv_magic(sv, NULL, PERL_MAGIC_bm, NULL, 0);	/* deep magic */
a629 1
    BmFLAGS(sv) = (U8)flags;
d635 2
a636 2
    DEBUG_r(PerlIO_printf(Perl_debug_log, "rarest char %c at %lu\n",
			  BmRARE(sv),(unsigned long)BmPREVIOUS(sv)));
d676 4
a679 3
    if (littlelen <= 2) {		/* Special-cased */

	if (littlelen == 1) {
d695 1
a695 5
	}
	if (!littlelen)
	    return (char*)big;		/* Cannot be SvTAIL! */

	/* littlelen is 2 */
d755 2
d758 1
d796 2
a797 2
	register const unsigned char * const table
	    = little + littlelen + PERL_FBM_TABLE_OFFSET;
d833 1
a833 1
	     && (BmFLAGS(littlestr) & FBMcf_TAIL)
d861 1
a861 1
    register I32 pos;
d867 4
a870 1
    I32 found = 0;
d874 4
a877 1
    assert(SvTYPE(littlestr) == SVt_PVGV);
d880 31
a910 3
    if (*old_posp == -1
	? (pos = PL_screamfirst[BmRARE(littlestr)]) < 0
	: (((pos = *old_posp), pos += PL_screamnext[pos]) == 0)) {
d941 21
a961 3
    while (pos < previous + start_shift) {
	if (!(pos += PL_screamnext[pos]))
	    goto cant_find;
d964 14
a977 9
    do {
	register const unsigned char *s, *x;
	if (pos >= stop_pos) break;
	if (big[pos] != first)
	    continue;
	for (x=big+pos+1,s=little; s < littleend; /**/ ) {
	    if (*s++ != *x++) {
		s--;
		break;
d980 12
a991 4
	if (s == littleend) {
	    *old_posp = pos;
	    if (!last) return (char *)(big+pos);
	    found = 1;
d993 1
a993 1
    } while ( pos += PL_screamnext[pos] );
d1012 12
d1025 1
a1025 1
Perl_ibcmp(const char *s1, const char *s2, register I32 len)
d1030 1
a1030 1
    PERL_ARGS_ASSERT_IBCMP;
d1034 1
a1034 1
	    return 1;
d1037 22
a1058 1
    return 0;
d1061 9
d1071 1
a1071 1
Perl_ibcmp_locale(const char *s1, const char *s2, register I32 len)
d1077 1
a1077 1
    PERL_ARGS_ASSERT_IBCMP_LOCALE;
d1081 1
a1081 1
	    return 1;
d1084 1
a1084 1
    return 0;
d1185 1
a1185 1
    PERL_ARGS_ASSERT_SAVESHAREDPVN;
d1217 19
d1246 1
a1246 1
    if (!PL_dirty)
d1319 15
d1396 24
d1421 1
a1421 1
Perl_vmess(pTHX_ const char *pat, va_list *args)
d1424 14
a1437 1
    SV * const sv = mess_alloc();
d1439 7
a1445 1
    PERL_ARGS_ASSERT_VMESS;
a1446 1
    sv_vsetpvfn(sv, pat, strlen(pat), args, NULL, 0, NULL);
d1468 4
a1471 2
	    Perl_sv_catpvf(aTHX_ sv, ", <%s> %s %"IVdf,
			   PL_last_in_gv == PL_argvgv ? "" : GvNAME(PL_last_in_gv),
d1475 1
a1475 1
	if (PL_dirty)
d1482 28
d1522 2
a1523 22
    {
	dSP;
	ENTER;
	SAVETMPS;

	save_re_context();
	SAVESPTR(PL_stderrgv);
	PL_stderrgv = NULL;

	PUSHSTACKi(PERLSI_MAGIC);

	PUSHMARK(SP);
	EXTEND(SP,2);
	PUSHs(SvTIED_obj(MUTABLE_SV(io), mg));
	PUSHs(msv);
	PUTBACK;
	call_method("PRINT", G_SCALAR);

	POPSTACK;
	FREETMPS;
	LEAVE;
    }
a1529 2
	STRLEN msglen;
	const char* message = SvPVx_const(msv, msglen);
d1531 1
a1531 1
	PERL_WRITE_MSG_TO_CONSOLE(serr, message, msglen);
d1539 17
a1555 1
/* Common code used by vcroak, vdie, vwarn and vwarner  */
d1558 1
a1558 1
S_vdie_common(pTHX_ SV *message, bool warn)
d1568 2
a1569 1
    assert(oldhook);
d1578 1
a1578 1
	SV *msg;
d1586 3
a1588 8
	if (warn || message) {
	    msg = newSVsv(message);
	    SvREADONLY_on(msg);
	    SAVEFREESV(msg);
	}
	else {
	    msg = ERRSV;
	}
d1592 1
a1592 1
	XPUSHs(msg);
d1602 2
a1603 5
STATIC SV *
S_vdie_croak_common(pTHX_ const char* pat, va_list* args)
{
    dVAR;
    SV *message;
d1605 3
a1607 13
    if (pat) {
	SV * const msv = vmess(pat, args);
	if (PL_errors && SvCUR(PL_errors)) {
	    sv_catsv(PL_errors, msv);
	    message = sv_mortalcopy(PL_errors);
	    SvCUR_set(PL_errors, 0);
	}
	else
	    message = msv;
    }
    else {
	message = NULL;
    }
d1609 2
a1610 5
    if (PL_diehook) {
	S_vdie_common(aTHX_ message, FALSE);
    }
    return message;
}
d1612 2
a1613 2
static OP *
S_vdie(pTHX_ const char* pat, va_list *args)
d1615 2
a1616 6
    dVAR;
    SV *message;

    message = vdie_croak_common(pat, args);

    die_where(message);
d1621 10
a1635 1
    OP *o;
d1638 2
a1639 1
    o = vdie(pat, &args);
d1641 1
a1641 1
    return o;
a1647 1
    OP *o;
d1650 2
a1651 1
    o = vdie(pat, &args);
d1653 1
a1653 1
    return o;
d1656 55
d1714 9
a1722 2
    dVAR;
    SV *msv;
d1724 15
a1738 1
    msv = S_vdie_croak_common(aTHX_ pat, args);
d1740 2
a1741 2
    die_where(msv);
}
d1756 26
d1783 8
a1790 1
=head1 Warning and Dieing
d1792 2
a1793 1
=for apidoc croak
d1795 2
a1796 11
This is the XSUB-writer's interface to Perl's C<die> function.
Normally call this function the same way you call the C C<printf>
function.  Calling C<croak> returns control directly to Perl,
sidestepping the normal C order of execution. See C<warn>.

If you want to throw an exception object, assign the object to
C<$@@> and then pass C<NULL> to croak():

   errsv = get_sv("@@", GV_ADD);
   sv_setsv(errsv, exception_object);
   croak(NULL);
d1802 1
a1802 1
Perl_croak(pTHX_ const char *pat, ...)
d1804 4
a1807 5
    va_list args;
    va_start(args, pat);
    vcroak(pat, &args);
    /* NOTREACHED */
    va_end(args);
d1810 19
d1832 15
a1846 2
    dVAR;
    SV * const msv = vmess(pat, args);
d1848 2
a1849 1
    PERL_ARGS_ASSERT_VWARN;
d1851 1
a1851 4
    if (PL_warnhook) {
	if (vdie_common(msv, TRUE))
	    return;
    }
d1853 2
a1854 2
    write_to_stderr(msv);
}
a1868 9
/*
=for apidoc warn

This is the XSUB-writer's interface to Perl's C<warn> function.  Call this
function the same way you call the C C<printf> function.  See C<croak>.

=cut
*/

d1936 2
a1937 5
	if (PL_diehook) {
	    assert(msv);
	    S_vdie_common(aTHX_ msv, FALSE);
	}
	die_where(msv);
d2005 2
a2006 1
    const MEM_SIZE len_wanted = sizeof(STRLEN) + size;
d2016 2
d2749 1
a2749 1
		Perl_croak(aTHX_ "panic: kid popen errno read");
a2817 1
	GV* tmpgv;
a2862 9

	if ((tmpgv = gv_fetchpvs("$", GV_ADD|GV_NOTQUAL, SVt_PV))) {
	    SvREADONLY_off(GvSV(tmpgv));
	    sv_setiv(GvSV(tmpgv), PerlProc_getpid());
	    SvREADONLY_on(GvSV(tmpgv));
	}
#ifdef THREADS_HAVE_PIDS
	PL_ppid = (IV)getppid();
#endif
d2905 1
a2905 1
		Perl_croak(aTHX_ "panic: kid popen errno read");
d3222 1
a3222 1
    Pid_t pid2;
d3225 1
d3227 9
a3235 1
    svp = av_fetch(PL_fdpid,PerlIO_fileno(ptr),TRUE);
d3254 1
a3254 1
    do {
d3266 5
a3270 1
    return(pid2 < 0 ? pid2 : status == 0 ? 0 : (errno = 0, status));
d3415 1
a3415 1
Perl_repeatcpy(register char *to, register const char *from, I32 len, register I32 count)
d3426 1
a3426 1
	I32 items, linear, half;
d3431 1
a3431 1
	    I32 todo;
d3438 1
a3438 1
	    I32 size = items * len;
d3695 1
d3719 3
a3721 2
    if (pthread_getspecific(PL_thr_key, &t))
	Perl_croak_nocontext("panic: pthread_getspecific");
d3744 5
a3748 2
    if (pthread_setspecific(PL_thr_key, t))
	Perl_croak_nocontext("panic: pthread_setspecific");
a3817 1
    const MGVTBL* result;
d3820 2
a3821 95
    switch(vtbl_id) {
    case want_vtbl_sv:
	result = &PL_vtbl_sv;
	break;
    case want_vtbl_env:
	result = &PL_vtbl_env;
	break;
    case want_vtbl_envelem:
	result = &PL_vtbl_envelem;
	break;
    case want_vtbl_sig:
	result = &PL_vtbl_sig;
	break;
    case want_vtbl_sigelem:
	result = &PL_vtbl_sigelem;
	break;
    case want_vtbl_pack:
	result = &PL_vtbl_pack;
	break;
    case want_vtbl_packelem:
	result = &PL_vtbl_packelem;
	break;
    case want_vtbl_dbline:
	result = &PL_vtbl_dbline;
	break;
    case want_vtbl_isa:
	result = &PL_vtbl_isa;
	break;
    case want_vtbl_isaelem:
	result = &PL_vtbl_isaelem;
	break;
    case want_vtbl_arylen:
	result = &PL_vtbl_arylen;
	break;
    case want_vtbl_mglob:
	result = &PL_vtbl_mglob;
	break;
    case want_vtbl_nkeys:
	result = &PL_vtbl_nkeys;
	break;
    case want_vtbl_taint:
	result = &PL_vtbl_taint;
	break;
    case want_vtbl_substr:
	result = &PL_vtbl_substr;
	break;
    case want_vtbl_vec:
	result = &PL_vtbl_vec;
	break;
    case want_vtbl_pos:
	result = &PL_vtbl_pos;
	break;
    case want_vtbl_bm:
	result = &PL_vtbl_bm;
	break;
    case want_vtbl_fm:
	result = &PL_vtbl_fm;
	break;
    case want_vtbl_uvar:
	result = &PL_vtbl_uvar;
	break;
    case want_vtbl_defelem:
	result = &PL_vtbl_defelem;
	break;
    case want_vtbl_regexp:
	result = &PL_vtbl_regexp;
	break;
    case want_vtbl_regdata:
	result = &PL_vtbl_regdata;
	break;
    case want_vtbl_regdatum:
	result = &PL_vtbl_regdatum;
	break;
#ifdef USE_LOCALE_COLLATE
    case want_vtbl_collxfrm:
	result = &PL_vtbl_collxfrm;
	break;
#endif
    case want_vtbl_amagic:
	result = &PL_vtbl_amagic;
	break;
    case want_vtbl_amagicelem:
	result = &PL_vtbl_amagicelem;
	break;
    case want_vtbl_backref:
	result = &PL_vtbl_backref;
	break;
    case want_vtbl_utf8:
	result = &PL_vtbl_utf8;
	break;
    default:
	result = NULL;
	break;
    }
    return (MGVTBL*)result;
d3875 1
a3875 1
Perl_report_evil_fh(pTHX_ const GV *gv, const IO *io, I32 op)
d3877 16
a3892 1
    const char * const name = gv && isGV(gv) ? GvENAME(gv) : NULL;
d3894 11
a3904 12
    if (op == OP_phoney_OUTPUT_ONLY || op == OP_phoney_INPUT_ONLY) {
	if (ckWARN(WARN_IO)) {
	    const char * const direction =
		(const char *)((op == OP_phoney_INPUT_ONLY) ? "in" : "out");
	    if (name && *name)
		Perl_warner(aTHX_ packWARN(WARN_IO),
			    "Filehandle %s opened only for %sput",
			    name, direction);
	    else
		Perl_warner(aTHX_ packWARN(WARN_IO),
			    "Filehandle opened only for %sput", direction);
	}
d3907 2
a3908 47
        const char *vile;
	I32   warn_type;

	if (gv && io && IoTYPE(io) == IoTYPE_CLOSED) {
	    vile = "closed";
	    warn_type = WARN_CLOSED;
	}
	else {
	    vile = "unopened";
	    warn_type = WARN_UNOPENED;
	}

	if (ckWARN(warn_type)) {
	    const char * const pars =
		(const char *)(OP_IS_FILETEST(op) ? "" : "()");
	    const char * const func =
		(const char *)
		(op == OP_READLINE   ? "readline"  :	/* "<HANDLE>" not nice */
		 op == OP_LEAVEWRITE ? "write" :		/* "write exit" not nice */
		 op < 0              ? "" :              /* handle phoney cases */
		 PL_op_desc[op]);
	    const char * const type =
		(const char *)
		(OP_IS_SOCKET(op) ||
		 (gv && io && IoTYPE(io) == IoTYPE_SOCKET) ?
		 "socket" : "filehandle");
	    if (name && *name) {
		Perl_warner(aTHX_ packWARN(warn_type),
			    "%s%s on %s %s %s", func, pars, vile, type, name);
		if (io && IoDIRP(io) && !(IoFLAGS(io) & IOf_FAKE_DIRP))
		    Perl_warner(
			aTHX_ packWARN(warn_type),
			"\t(Are you trying to call %s%s on dirhandle %s?)\n",
			func, pars, name
		    );
	    }
	    else {
		Perl_warner(aTHX_ packWARN(warn_type),
			    "%s%s on %s %s", func, pars, vile, type);
		if (gv && io && IoDIRP(io) && !(IoFLAGS(io) & IOf_FAKE_DIRP))
		    Perl_warner(
			aTHX_ packWARN(warn_type),
			"\t(Are you trying to call %s%s on dirhandle?)\n",
			func, pars
		    );
	    }
	}
a3909 18
}

#ifdef EBCDIC
/* in ASCII order, not that it matters */
static const char controllablechars[] = "?@@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_";

int
Perl_ebcdic_control(pTHX_ int ch)
{
    if (ch > 'a') {
	const char *ctlp;

	if (islower(ch))
	    ch = toupper(ch);

	if ((ctlp = strchr(controllablechars, ch)) == 0) {
	    Perl_die(aTHX_ "unrecognised control character '%c'\n", ch);
	}
d3911 27
a3937 19
	if (ctlp == controllablechars)
	    return('\177'); /* DEL */
	else
	    return((unsigned char)(ctlp - controllablechars - 1));
    } else { /* Want uncontrol */
	if (ch == '\177' || ch == -1)
	    return('?');
	else if (ch == '\157')
	    return('\177');
	else if (ch == '\174')
	    return('\000');
	else if (ch == '^')    /* '\137' in 1047, '\260' in 819 */
	    return('\036');
	else if (ch == '\155')
	    return('\037');
	else if (0 < ch && ch < (sizeof(controllablechars) - 1))
	    return(controllablechars[ch+1]);
	else
	    Perl_die(aTHX_ "invalid control request: '\\%03o'\n", ch & 0xFF);
a3939 1
#endif
d4061 1
a4061 1
 * were leap years in the Julian calander but not in the Gregorian one.
d4240 1
a4240 1
    Newx(buf, bufsize, char);
d4443 5
d4553 5
d4568 1
a4568 1
	else if (!*d || *d == ';' || isSPACE(*d) || *d == '}') {
d4599 1
a4599 1
	if (!isDIGIT(*d) && (strict || ! (!*d || *d == ';' || isSPACE(*d) || *d == '}') )) {
d4637 1
a4637 1
    if (!isDIGIT(*d) && (! (!*d || *d == ';' || *d == '}') )) {
d4868 2
a4869 1
    if ( sv_derived_from(ver,"version") ) /* can just copy directly */
d4961 2
d4965 2
d4968 2
a4969 1
	char *loc = setlocale(LC_NUMERIC, "C");
d4971 8
a4978 1
	STRLEN len = my_snprintf(tbuf, sizeof(tbuf), "%.9"NVff, SvNVX(ver));
d4981 1
d4983 4
a4986 3
	while (tbuf[len-1] == '0' && len > 0) len--;
	if ( tbuf[len-1] == '.' ) len--; /* eat the trailing decimal */
	version = savepvn(tbuf, len);
d5001 1
a5001 3
	if ( len >= 3 && !instr(version,".") && !instr(version,"_")
	    && !(*version == 'u' && strEQ(version, "undef"))
	    && (*version < '0' || *version > '9') ) {
d5003 27
a5029 19
	    SV * const nsv = sv_newmortal();
	    const char *nver;
	    const char *pos;
	    int saw_decimal = 0;
	    sv_setpvf(nsv,"v%vd",ver);
	    pos = nver = savepv(SvPV_nolen(nsv));

	    /* scan the resulting formatted string */
	    pos++; /* skip the leading 'v' */
	    while ( *pos == '.' || isDIGIT(*pos) ) {
		if ( *pos == '.' )
		    saw_decimal++ ;
		pos++;
	    }

	    /* is definitely a v-string */
	    if ( saw_decimal >= 2 ) {
		Safefree(version);
		version = nver;
d5048 4
a5051 1
Validates that the SV contains a valid version object.
d5053 1
a5053 1
    bool vverify(SV *vobj);
d5060 1
a5060 1
=item * The SV contains a [reference to a] hash
d5064 1
a5064 1
=item * The "version" key has [a reference to] an AV as its value
d5071 1
a5071 1
bool
d5086 1
a5086 1
	return TRUE;
d5088 1
a5088 1
	return FALSE;
d5102 2
d5118 3
a5120 4
    if ( SvROK(vs) )
	vs = SvRV(vs);

    if ( !vverify(vs) )
d5183 2
d5198 3
a5200 4
    if ( SvROK(vs) )
	vs = SvRV(vs);

    if ( !vverify(vs) )
d5242 3
a5244 1
the original version contained 1 or more dots, respectively
d5254 3
a5256 4
    if ( SvROK(vs) )
	vs = SvRV(vs);

    if ( !vverify(vs) )
d5296 4
a5299 9
    if ( SvROK(lhv) )
	lhv = SvRV(lhv);
    if ( SvROK(rhv) )
	rhv = SvRV(rhv);

    if ( !vverify(lhv) )
	Perl_croak(aTHX_ "Invalid version object");

    if ( !vverify(rhv) )
d5616 1
a5616 1
 * to the my_socketpair in global.sym. */
d5679 3
a5681 1
	    if (*p && *p != '\n' && *p != '\r')
d5683 1
d5709 3
a5711 1
		      if (*p != '\n' && *p != '\r')
d5714 1
d5722 2
d5858 4
a5861 2
    const char * const stashpv = CopSTASHPV(c);
    const char * const name = HvNAME_get(hv);
d5865 18
a5882 5
    if (stashpv == name)
	return TRUE;
    if (stashpv && name)
	if (strEQ(stashpv, name))
	    return TRUE;
d5912 4
a5915 6
#  undef PERLVARISC
#  define PERLVAR(var,type) /**/
#  define PERLVARA(var,n,type) /**/
#  define PERLVARI(var,type,init) plvarsp->var = init;
#  define PERLVARIC(var,type,init) plvarsp->var = init;
#  define PERLVARISC(var,init) Copy(init, plvarsp->var, sizeof(init), char);
a5920 1
#  undef PERLVARISC
d6096 1
a6096 1
   own implemenation, but is getting these functions anyway, and they
d6205 8
a6212 2
    /* vsnprintf() shows failure with >= len, vsprintf() with < 0 */
    if (retval < 0 || (len > 0 && (Size_t)retval >= len))
d6251 8
a6258 2
    /* vsnprintf() shows failure with >= len, vsprintf() with < 0 */
    if (retval < 0 || (len > 0 && (Size_t)retval >= len))
d6436 78
d6553 13
d6571 4
a6574 1
    /* We do not care about using sv to call CV;
d6580 1
d6583 1
a6583 1
	GV * const gv = CvGV(cv);
d6585 4
a6588 1
	if ( svp && ((CvFLAGS(cv) & (CVf_ANON | CVf_CLONED))
d6590 3
a6592 1
	     || ((GvCV(gv) != cv) && /* Could be imported, and old sub redefined. */
d6594 6
a6599 2
		    && (GvCV((const GV *)*svp) == cv) )))) {
	    /* Use GV from the stack as a fallback. */
d6606 6
a6611 1
	    gv_efullname3(dbsv, gv, NULL);
d6621 1
@


1.14
log
@merge in perl 5.12.2 plus local changes
@
text
@d3036 3
@


1.13
log
@Merge in perl 5.10.1
@
text
@d372 1
a372 1
Perl_delimcpy(pTHX_ register char *to, register const char *toend, register const char *from, register const char *fromend, register int delim, I32 *retlen)
a374 1
    PERL_UNUSED_CONTEXT;
d402 1
a402 1
Perl_instr(pTHX_ register const char *big, register const char *little)
a404 1
    PERL_UNUSED_CONTEXT;
d436 1
a436 1
Perl_ninstr(pTHX_ const char *big, const char *bigend, const char *little, const char *lend)
a438 1
    PERL_UNUSED_CONTEXT;
d442 1
a442 1
        char first = *little;
d462 1
a462 1
Perl_rninstr(pTHX_ register const char *big, const char *bigend, const char *little, const char *lend)
a466 1
    PERL_UNUSED_CONTEXT;
d882 1
a882 1
Perl_ibcmp(pTHX_ const char *s1, const char *s2, register I32 len)
a885 1
    PERL_UNUSED_CONTEXT;
d898 1
a898 1
Perl_ibcmp_locale(pTHX_ const char *s1, const char *s2, register I32 len)
a902 1
    PERL_UNUSED_CONTEXT;
d1232 1
a1232 1
Perl_write_to_stderr(pTHX_ const char* message, int msglen)
d1257 1
a1257 1
	mPUSHp(message, msglen);
d1271 2
d1285 1
a1285 1
S_vdie_common(pTHX_ const char *message, STRLEN msglen, I32 utf8, bool warn)
d1313 1
a1313 1
	    msg = newSVpvn_flags(message, msglen, utf8);
d1333 2
a1334 3
STATIC const char *
S_vdie_croak_common(pTHX_ const char* pat, va_list* args, STRLEN* msglen,
		    I32* utf8)
d1337 1
a1337 1
    const char *message;
d1343 1
a1343 1
	    message = SvPV_const(PL_errors, *msglen);
d1347 1
a1347 2
	    message = SvPV_const(msv,*msglen);
	*utf8 = SvUTF8(msv);
a1352 3
    DEBUG_S(PerlIO_printf(Perl_debug_log,
			  "%p: die/croak: message = %s\ndiehook = %p\n",
			  (void*)thr, message, (void*)PL_diehook));
d1354 1
a1354 1
	S_vdie_common(aTHX_ message, *msglen, *utf8, FALSE);
d1359 2
a1360 2
OP *
Perl_vdie(pTHX_ const char* pat, va_list *args)
d1363 7
a1369 19
    const char *message;
    const int was_in_eval = PL_in_eval;
    STRLEN msglen;
    I32 utf8 = 0;

    DEBUG_S(PerlIO_printf(Perl_debug_log,
			  "%p: die: curstack = %p, mainstack = %p\n",
			  (void*)thr, (void*)PL_curstack, (void*)PL_mainstack));

    message = vdie_croak_common(pat, args, &msglen, &utf8);

    PL_restartop = die_where(message, msglen);
    SvFLAGS(ERRSV) |= utf8;
    DEBUG_S(PerlIO_printf(Perl_debug_log,
	  "%p: die: restartop = %p, was_in_eval = %d, top_env = %p\n",
	  (void*)thr, (void*)PL_restartop, was_in_eval, (void*)PL_top_env));
    if ((!PL_restartop && was_in_eval) || PL_top_env->je_prev)
	JMPENV_JUMP(3);
    return PL_restartop;
d1401 3
a1403 13
    const char *message;
    STRLEN msglen;
    I32 utf8 = 0;

    message = S_vdie_croak_common(aTHX_ pat, args, &msglen, &utf8);

    if (PL_in_eval) {
	PL_restartop = die_where(message, msglen);
	SvFLAGS(ERRSV) |= utf8;
	JMPENV_JUMP(3);
    }
    else if (!message)
	message = SvPVx_const(ERRSV, msglen);
d1405 1
a1405 2
    write_to_stderr(message, msglen);
    my_failure_exit();
a1454 1
    STRLEN msglen;
a1455 2
    const I32 utf8 = SvUTF8(msv);
    const char * const message = SvPV_const(msv, msglen);
d1460 1
a1460 1
	if (vdie_common(message, msglen, utf8, TRUE))
d1464 1
a1464 1
    write_to_stderr(message, msglen);
d1513 26
a1554 3
	STRLEN msglen;
	const char * const message = SvPV_const(msv, msglen);
	const I32 utf8 = SvUTF8(msv);
d1557 2
a1558 2
	    assert(message);
	    S_vdie_common(aTHX_ message, msglen, utf8, FALSE);
d1560 1
a1560 7
	if (PL_in_eval) {
	    PL_restartop = die_where(message, msglen);
	    SvFLAGS(ERRSV) |= utf8;
	    JMPENV_JUMP(3);
	}
	write_to_stderr(message, msglen);
	my_failure_exit();
d1573 5
a1577 20
    return
	(
	       isLEXWARN_on
	    && PL_curcop->cop_warnings != pWARN_NONE
	    && (
		   PL_curcop->cop_warnings == pWARN_ALL
		|| isWARN_on(PL_curcop->cop_warnings, unpackWARN1(w))
		|| (unpackWARN2(w) &&
		     isWARN_on(PL_curcop->cop_warnings, unpackWARN2(w)))
		|| (unpackWARN3(w) &&
		     isWARN_on(PL_curcop->cop_warnings, unpackWARN3(w)))
		|| (unpackWARN4(w) &&
		     isWARN_on(PL_curcop->cop_warnings, unpackWARN4(w)))
		)
	)
	||
	(
	    isLEXWARN_off && PL_dowarn & G_WARN_ON
	)
	;
d1586 36
a1621 16
    return
	   isLEXWARN_off
	|| PL_curcop->cop_warnings == pWARN_ALL
	|| (
	      PL_curcop->cop_warnings != pWARN_NONE 
	   && (
		   isWARN_on(PL_curcop->cop_warnings, unpackWARN1(w))
	      || (unpackWARN2(w) &&
		   isWARN_on(PL_curcop->cop_warnings, unpackWARN2(w)))
	      || (unpackWARN3(w) &&
		   isWARN_on(PL_curcop->cop_warnings, unpackWARN3(w)))
	      || (unpackWARN4(w) &&
		   isWARN_on(PL_curcop->cop_warnings, unpackWARN4(w)))
	      )
	   )
	;
d1666 2
a1667 1
    register I32 i=setenv_getix(nam);          /* where does it go? */
d1670 6
a1778 24
#ifndef PERL_MICRO
I32
Perl_setenv_getix(pTHX_ const char *nam)
{
    register I32 i;
    register const I32 len = strlen(nam);

    PERL_ARGS_ASSERT_SETENV_GETIX;
    PERL_UNUSED_CONTEXT;

    for (i = 0; environ[i]; i++) {
	if (
#ifdef WIN32
	    strnicmp(environ[i],nam,len) == 0
#else
	    strnEQ(environ[i],nam,len)
#endif
	    && environ[i][len] == '=')
	    break;			/* strnEQ must come first to avoid */
    }					/* potential SEGV's */
    return i;
}
#endif /* !PERL_MICRO */

d2252 1
a2252 1
Perl_my_popen_list(pTHX_ char *mode, int n, SV **args)
d2254 1
a2254 1
#if (!defined(DOSISH) || defined(HAS_FORK) || defined(AMIGAOS)) && !defined(OS2) && !defined(VMS) && !defined(__OPEN_VM) && !defined(EPOC) && !defined(MACOS_TRADITIONAL) && !defined(NETWARE) && !defined(__LIBCATAMOUNT__)
d2287 1
a2344 1
    LOCK_FDPID_MUTEX;
a2345 1
    UNLOCK_FDPID_MUTEX;
d2391 1
a2391 1
#if (!defined(DOSISH) || defined(HAS_FORK) || defined(AMIGAOS)) && !defined(VMS) && !defined(__OPEN_VM) && !defined(EPOC) && !defined(MACOS_TRADITIONAL) && !defined(__LIBCATAMOUNT__)
d2431 1
a2431 1
		Perl_croak(aTHX_ "Can't fork");
d2434 1
a2511 1
    LOCK_FDPID_MUTEX;
a2512 1
    UNLOCK_FDPID_MUTEX;
d2639 1
a2639 1
Perl_dump_fds(pTHX_ char *s)
a2692 5
#ifdef MACOS_TRADITIONAL
/* We don't want restart behavior on MacOS */
#undef SA_RESTART
#endif

d2843 1
a2843 1
#if (!defined(DOSISH) || defined(HAS_FORK) || defined(AMIGAOS)) && !defined(VMS) && !defined(__OPEN_VM) && !defined(EPOC) && !defined(MACOS_TRADITIONAL) && !defined(__LIBCATAMOUNT__)
a2855 1
    LOCK_FDPID_MUTEX;
a2856 1
    UNLOCK_FDPID_MUTEX;
d2899 1
a2899 1
#if  (!defined(DOSISH) || defined(OS2) || defined(WIN32) || defined(NETWARE)) && !defined(MACOS_TRADITIONAL) && !defined(__LIBCATAMOUNT__)
d2986 1
a2986 1
Perl_pidgone(pTHX_ Pid_t pid, int status)
d3030 1
d3032 1
a3032 1
Perl_repeatcpy(pTHX_ register char *to, register const char *from, I32 len, register I32 count)
d3034 1
a3034 3
    register I32 todo;
    register const char * const frombase = from;
    PERL_UNUSED_CONTEXT;
d3036 13
a3048 1
    PERL_ARGS_ASSERT_REPEATCPY;
d3050 6
a3055 9
    if (len == 1) {
	register const char c = *from;
	while (count-- > 0)
	    *to++ = c;
	return;
    }
    while (count-- > 0) {
	for (todo = len; todo > 0; todo--) {
	    *to++ = *from++;
d3057 3
a3059 1
	from = frombase;
a3226 4
#ifdef MACOS_TRADITIONAL
    if (dosearch && !strchr(scriptname, ':') &&
	(s = PerlEnv_getenv("Commands")))
#else
a3231 1
#endif
a3236 5
#ifdef MACOS_TRADITIONAL
	    s = delimcpy(tmpbuf, tmpbuf + sizeof tmpbuf, s, bufend,
			',',
			&len);
#else
a3252 1
#endif /* MACOS_TRADITIONAL */
a3256 4
#ifdef MACOS_TRADITIONAL
	    if (len && tmpbuf[len - 1] != ':')
	    	tmpbuf[len++] = ':';
#else
d3258 1
a3258 1
#  if defined(atarist) || defined(__MINT__) || defined(DOSISH)
a3265 1
#endif
d3290 1
a3290 1
#if !defined(DOSISH) && !defined(MACOS_TRADITIONAL)
d4184 204
d4416 2
a4417 2
    int saw_period = 0;
    int alpha = 0;
d4419 1
d4428 4
d4435 5
a4439 25
    start = last = s;

    if (*s == 'v') {
	s++;  /* get past 'v' */
	qv = 1; /* force quoted version processing */
    }

    pos = s;

    /* pre-scan the input string to check for decimals/underbars */
    while ( *pos == '.' || *pos == '_' || *pos == ',' || isDIGIT(*pos) )
    {
	if ( *pos == '.' )
	{
	    if ( alpha )
		Perl_croak(aTHX_ "Invalid version format (underscores before decimal)");
	    saw_period++ ;
	    last = pos;
	}
	else if ( *pos == '_' )
	{
	    if ( alpha )
		Perl_croak(aTHX_ "Invalid version format (multiple underscores)");
	    alpha = 1;
	    width = pos - last - 1; /* natural width of sub-version */
a4440 7
	else if ( *pos == ',' && isDIGIT(pos[1]) )
	{
	    saw_period++ ;
	    last = pos;
	}

	pos++;
d4443 3
a4445 10
    if ( alpha && !saw_period )
	Perl_croak(aTHX_ "Invalid version format (alpha without decimal)");

    if ( alpha && saw_period && width == 0 )
	Perl_croak(aTHX_ "Invalid version format (misplaced _ in number)");

    if ( saw_period > 1 )
	qv = 1; /* force quoted version processing */

    last = pos;
d4472 1
a4472 1
 		if ( !qv && s > start && saw_period == 1 ) {
d4480 2
a4481 3
			    if(ckWARN(WARN_OVERFLOW))
				Perl_warner(aTHX_ packWARN(WARN_OVERFLOW), 
				"Integer overflow in version %d",VERSION_MAX);
d4498 2
a4499 3
			    if(ckWARN(WARN_OVERFLOW))
				Perl_warner(aTHX_ packWARN(WARN_OVERFLOW), 
				"Integer overflow in version");
d4562 1
a4562 1
	if ( qv && saw_period == 1 && *start != 'v' ) {
d4611 3
d4656 1
a4656 1
	    if ( *version != 'v' ) 
d4711 1
a4711 1
	qv = 1;
d4721 3
a4723 1
	if ( len == 3 && !instr(version,".") && !instr(version,"_") ) {
d4728 1
a4728 1
	    int saw_period = 0;
d4736 1
a4736 1
		    saw_period++ ;
d4741 1
a4741 1
	    if ( saw_period == 2 ) {	
d4752 3
a4754 4
	if(ckWARN(WARN_MISC))
	    Perl_warner(aTHX_ packWARN(WARN_MISC), 
		"Version string '%s' contains invalid data; "
		"ignoring: '%s'", version, s);
d4822 1
a4822 1
    SV * const sv = newSV(0);
d4844 1
a4844 2
	sv_catpvs(sv,"0");
	return sv;
d4850 1
a4850 2
	sv_catpvs(sv,"0");
	return sv;
d4854 1
a4854 1
    Perl_sv_setpvf(aTHX_ sv, "%d.", (int)PERL_ABS(digit));
d4901 1
a4901 1
    SV * const sv = newSV(0);
d4919 1
a4919 2
	sv_catpvs(sv,"");
	return sv;
d4922 1
a4922 1
    Perl_sv_setpvf(aTHX_ sv, "v%"IVdf, (IV)digit);
a4958 1

d5546 1
a5546 1
	       (UV)(Drand01() * (NV)((1 << ((UVSIZE * 8 - RANDBITS))) - 1));
d5660 6
a5665 2
/*
 * PERL_MEM_LOG: the Perl_mem_log_..() will be compiled.
d5667 4
a5670 5
 * PERL_MEM_LOG_ENV: if defined, during run time the environment
 * variables PERL_MEM_LOG and PERL_SV_LOG will be consulted, and
 * if the integer value of that is true, the logging will happen.
 * (The default is to always log if the PERL_MEM_LOG define was
 * in effect.)
d5672 2
a5673 4
 * PERL_MEM_LOG_TIMESTAMP: if defined, a timestamp will be logged
 * before every memory logging entry. This can be turned off at run
 * time by setting the environment variable PERL_MEM_LOG_TIMESTAMP
 * to zero.
d5676 1
a5676 2
/*
 * PERL_MEM_LOG_SPRINTF_BUF_SIZE: size of a (stack-allocated) buffer
d5681 2
a5682 5
/*
 * PERL_MEM_LOG_FD: the file descriptor the Perl_mem_log_...() will
 * log to.  You can also define in compile time PERL_MEM_LOG_ENV_FD,
 * in which case the environment variable PERL_MEM_LOG_FD will be
 * consulted for the file descriptor number to use.
d5688 1
a5688 1
#ifdef PERL_MEM_LOG_STDERR
d5699 5
a5703 1
S_mem_log_common(enum mem_log_type mlt, const UV n, const UV typesize, const char *type_name, const SV *sv, Malloc_t oldalloc, Malloc_t newalloc, const char *filename, const int linenumber, const char *funcname)
d5705 1
a5705 3
# if defined(PERL_MEM_LOG_ENV) || defined(PERL_MEM_LOG_ENV_FD)
    const char *s;
# endif
d5709 4
a5712 4
# ifdef PERL_MEM_LOG_ENV
    s = PerlEnv_getenv(mlt < MLT_NEW_SV ? "PERL_MEM_LOG" : "PERL_SV_LOG");
    if (s ? atoi(s) : 0)
# endif
d5717 1
a5717 1
# ifdef PERL_MEM_LOG_TIMESTAMP
a5732 1
# endif
a5733 1
	    int fd = PERL_MEM_LOG_FD;
d5735 3
d5739 1
a5739 8
# ifdef PERL_MEM_LOG_ENV_FD
	    if ((s = PerlEnv_getenv("PERL_MEM_LOG_FD"))) {
		fd = atoi(s);
	    }
# endif
# ifdef PERL_MEM_LOG_TIMESTAMP
	    s = PerlEnv_getenv("PERL_MEM_LOG_TIMESTAMP");
	    if (!s || atoi(s)) {
a5743 1
# endif
d5774 2
d5781 13
d5797 8
a5804 5
Perl_mem_log_alloc(const UV n, const UV typesize, const char *type_name, Malloc_t newalloc, const char *filename, const int linenumber, const char *funcname)
{
#ifdef PERL_MEM_LOG_STDERR
    mem_log_common(MLT_ALLOC, n, typesize, type_name, NULL, NULL, newalloc, filename, linenumber, funcname);
#endif
d5809 8
a5816 5
Perl_mem_log_realloc(const UV n, const UV typesize, const char *type_name, Malloc_t oldalloc, Malloc_t newalloc, const char *filename, const int linenumber, const char *funcname)
{
#ifdef PERL_MEM_LOG_STDERR
    mem_log_common(MLT_REALLOC, n, typesize, type_name, NULL, oldalloc, newalloc, filename, linenumber, funcname);
#endif
d5821 3
a5823 1
Perl_mem_log_free(Malloc_t oldalloc, const char *filename, const int linenumber, const char *funcname)
d5825 2
a5826 3
#ifdef PERL_MEM_LOG_STDERR
    mem_log_common(MLT_FREE, 0, 0, "", NULL, oldalloc, NULL, filename, linenumber, funcname);
#endif
d5831 3
a5833 1
Perl_mem_log_new_sv(const SV *sv, const char *filename, const int linenumber, const char *funcname)
d5835 2
a5836 3
#ifdef PERL_MEM_LOG_STDERR
    mem_log_common(MLT_NEW_SV, 0, 0, "", sv, NULL, NULL, filename, linenumber, funcname);
#endif
d5840 3
a5842 1
Perl_mem_log_del_sv(const SV *sv, const char *filename, const int linenumber, const char *funcname)
d5844 2
a5845 3
#ifdef PERL_MEM_LOG_STDERR
    mem_log_common(MLT_DEL_SV, 0, 0, "", sv, NULL, NULL, filename, linenumber, funcname);
#endif
d6017 1
d6019 1
d6021 1
d6023 1
d6078 1
d6080 1
d6082 1
d6084 1
a6213 2
    SV    *tmpsv;
    MAGIC *mg;
d6218 4
a6221 7
        if (SvROK(sv) &&
            (tmpsv = MUTABLE_SV(SvRV(sv))) &&            /* assign deliberate */
            SvTYPE(tmpsv) == SVt_PVMG &&
            (mg = mg_find(tmpsv, PERL_MAGIC_qr))) /* assign deliberate */
        {
            return (REGEXP *)mg->mg_obj;
        }
@


1.12
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d3 2
a4 2
 *    Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999,
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, by Larry Wall and others
d12 4
a15 2
 * "Very useful, no doubt, that was to Saruman; yet it seems that he was
 * not content."  --Gandalf
d183 4
a186 3
    DEBUG_m(PerlIO_printf(Perl_debug_log, "0x%"UVxf": (%05ld) rfree\n",PTR2UV(where),(long)PL_an++));
    DEBUG_m(PerlIO_printf(Perl_debug_log, "0x%"UVxf": (%05ld) realloc %ld bytes\n",PTR2UV(ptr),(long)PL_an++,(long)size));

a187 1
#ifdef PERL_TRACK_MEMPOOL
d203 1
d205 9
d279 1
a279 1
	Perl_croak_nocontext(PL_memory_wrap);
d284 1
a284 1
	Perl_croak_nocontext(PL_memory_wrap);
d377 2
d408 2
d440 1
d445 1
a445 1
        char first = *little++;
d447 1
a447 1
        bigend -= lend - little;
d472 2
d523 2
d602 2
d807 2
d892 2
d910 2
d1017 3
a1019 1
    assert(pv);
d1043 2
d1061 1
a1061 1
	return sv_2mortal(newSVpvs(""));
d1084 1
d1117 1
d1128 1
d1140 1
d1153 1
d1166 2
d1201 2
d1244 2
d1248 1
a1248 1
	&& (mg = SvTIED_mg((SV*)io, PERL_MAGIC_tiedscalar))) 
d1262 2
a1263 2
	PUSHs(SvTIED_obj((SV*)io, mg));
	PUSHs(sv_2mortal(newSVpvn(message, msglen)));
d1274 1
a1274 1
	const int e = errno;
d1281 1
a1281 1
	errno = e;
d1317 1
a1317 2
	    msg = newSVpvn(message, msglen);
	    SvFLAGS(msg) |= utf8;
d1329 1
a1329 1
	call_sv((SV*)cv, G_DISCARD);
d1466 1
a1466 1
   errsv = get_sv("@@", TRUE);
d1492 2
d1508 1
d1528 1
d1540 1
d1551 1
d1561 1
d1643 1
d1791 2
d1817 2
d1832 2
d1855 2
d1870 2
d1887 2
d2272 2
d2293 2
d2413 1
a2413 1
    return my_syspopen4(aTHX_ Nullch, mode, n, args);
d2435 2
d2585 1
d2676 2
d2777 2
d2891 1
a2891 4
    int saved_errno = 0;
#ifdef WIN32
    int saved_win32_errno;
#endif
d2904 2
a2905 6
    if ((close_failed = (PerlIO_close(ptr) == EOF))) {
	saved_errno = errno;
#ifdef WIN32
	saved_win32_errno = GetLastError();
#endif
    }
d2923 1
a2923 1
	SETERRNO(saved_errno, 0);
d2944 1
d3017 1
d3076 2
d3102 2
d3115 1
a3115 1
	sv_setpvn(tmpsv, ".", 1);
d3121 1
a3121 1
	sv_setpvn(tmpsv, ".", 1);
d3166 2
d3396 1
d3461 1
d3759 1
d3765 1
d3783 2
d3979 2
d4088 2
d4127 1
d4150 1
a4150 1
	    const int namelen = dp->d_namlen;
d4152 1
a4152 1
	    const int namelen = strlen(dp->d_name);
d4263 3
a4267 4
#ifndef NODEFAULT_SHAREKEYS
    HvSHAREKEYS_on(hv);         /* key-sharing on by default */
#endif

d4281 1
a4281 1
    while ( *pos == '.' || *pos == '_' || isDIGIT(*pos) )
d4297 6
d4319 1
a4319 1
	(void)hv_stores((HV *)hv, "qv", newSViv(qv));
d4321 1
a4321 1
	(void)hv_stores((HV *)hv, "alpha", newSViv(alpha));
d4323 1
a4323 1
	(void)hv_stores((HV *)hv, "width", newSViv(width));
d4390 2
d4419 1
a4419 1
	   av_push((AV *)sv, newSViv(0));
d4429 2
a4430 2
	(void)hv_stores((HV *)hv, "original", orig);
	(void)hv_stores((HV *)hv, "vinf", newSViv(1));
d4438 1
a4438 1
	(void)hv_stores((HV *)hv, "original", orig);
d4441 1
a4441 1
	(void)hv_stores((HV *)hv, "original", newSVpvn("0",1));
d4446 1
a4446 1
    (void)hv_stores((HV *)hv, "version", newRV_noinc((SV *)av));
d4474 1
a4482 3
#ifndef NODEFAULT_SHAREKEYS
	HvSHAREKEYS_on(hv);         /* key-sharing on by default */
#endif
d4488 2
a4489 2
	if ( hv_exists((HV *)ver, "qv", 2) )
	    (void)hv_stores((HV *)hv, "qv", newSViv(1));
d4491 2
a4492 2
	if ( hv_exists((HV *)ver, "alpha", 5) )
	    (void)hv_stores((HV *)hv, "alpha", newSViv(1));
d4494 1
a4494 1
	if ( hv_exists((HV*)ver, "width", 5 ) )
d4496 2
a4497 2
	    const I32 width = SvIV(*hv_fetchs((HV*)ver, "width", FALSE));
	    (void)hv_stores((HV *)hv, "width", newSViv(width));
d4500 1
a4500 1
	if ( hv_exists((HV*)ver, "original", 8 ) )
d4502 2
a4503 2
	    SV * pv = *hv_fetchs((HV*)ver, "original", FALSE);
	    (void)hv_stores((HV *)hv, "original", newSVsv(pv));
d4506 1
a4506 1
	sav = (AV *)SvRV(*hv_fetchs((HV*)ver, "version", FALSE));
d4514 1
a4514 1
	(void)hv_stores((HV *)hv, "version", newRV_noinc((SV *)av));
d4560 2
d4654 3
d4662 2
a4663 2
	 && hv_exists((HV*)vs, "version", 7)
	 && (sv = SvRV(*hv_fetchs((HV*)vs, "version", FALSE)))
d4692 3
d4702 1
a4702 1
    if ( hv_exists((HV*)vs, "alpha", 5 ) )
d4704 2
a4705 2
    if ( hv_exists((HV*)vs, "width", 5 ) )
	width = SvIV(*hv_fetchs((HV*)vs, "width", FALSE));
d4711 1
a4711 1
    if ( !(av = (AV *)SvRV(*hv_fetchs((HV*)vs, "version", FALSE)) ) ) {
d4773 3
d4782 1
a4782 1
    if ( hv_exists((HV*)vs, "alpha", 5 ) )
d4784 1
a4784 1
    av = (AV *)SvRV(*hv_fetchs((HV*)vs, "version", FALSE));
d4830 3
a4832 1
    SV *pv;
d4835 1
a4835 1
    
d4839 14
a4852 5
    pv = *hv_fetchs((HV*)vs, "original", FALSE);
    if ( SvPOK(pv) ) 
	return newSVsv(pv);
    else
	return &PL_sv_undef;
d4873 3
d4888 2
a4889 2
    lav = (AV *)SvRV(*hv_fetchs((HV*)lhv, "version", FALSE));
    if ( hv_exists((HV*)lhv, "alpha", 5 ) )
d4893 2
a4894 2
    rav = (AV *)SvRV(*hv_fetchs((HV*)rhv, "version", FALSE));
    if ( hv_exists((HV*)rhv, "alpha", 5 ) )
d5084 1
a5084 1
	const int save_errno = errno;
d5089 1
a5089 1
	errno = save_errno;
d5188 1
a5188 1
	const int save_errno = errno;
d5195 1
a5195 1
	errno = save_errno;
d5257 2
d5438 1
d5515 1
d5536 9
a5544 3
 * variable PERL_MEM_LOG will be consulted, and if the integer value
 * of that is true, the logging will happen.  (The default is to
 * always log if the PERL_MEM_LOG define was in effect.)
d5563 12
a5574 2
Malloc_t
Perl_mem_log_alloc(const UV n, const UV typesize, const char *typename, Malloc_t newalloc, const char *filename, const int linenumber, const char *funcname)
a5575 1
#ifdef PERL_MEM_LOG_STDERR
d5577 1
a5577 1
    char *s;
d5579 3
d5583 1
a5583 1
    s = getenv("PERL_MEM_LOG");
d5591 3
a5594 1
#   ifdef HAS_GETTIMEOFDAY
d5596 5
d5603 1
a5603 1
	 * gettimeofday() (see ext/Time/HiRes), the easiest way is
d5608 7
a5614 5
	    const STRLEN len =
		my_snprintf(buf,
			    sizeof(buf),
#  ifdef PERL_MEM_LOG_TIMESTAMP
			    "%10d.%06d: "
d5616 7
a5622 4
			    "alloc: %s:%d:%s: %"IVdf" %"UVuf
			    " %s = %"IVdf": %"UVxf"\n",
#  ifdef PERL_MEM_LOG_TIMESTAMP
			    (int)tv.tv_sec, (int)tv.tv_usec,
d5624 32
a5655 8
			    filename, linenumber, funcname, n, typesize,
			    typename, n * typesize, PTR2UV(newalloc));
# ifdef PERL_MEM_LOG_ENV_FD
	    s = PerlEnv_getenv("PERL_MEM_LOG_FD");
	    PerlLIO_write(s ? atoi(s) : PERL_MEM_LOG_FD, buf, len);
# else
	    PerlLIO_write(PERL_MEM_LOG_FD, buf, len);
#endif
d5658 8
d5671 1
a5671 1
Perl_mem_log_realloc(const UV n, const UV typesize, const char *typename, Malloc_t oldalloc, Malloc_t newalloc, const char *filename, const int linenumber, const char *funcname)
d5674 1
a5674 38
# if defined(PERL_MEM_LOG_ENV) || defined(PERL_MEM_LOG_ENV_FD)
    char *s;
# endif
# ifdef PERL_MEM_LOG_ENV
    s = PerlEnv_getenv("PERL_MEM_LOG");
    if (s ? atoi(s) : 0)
# endif
    {
	/* We can't use SVs or PerlIO for obvious reasons,
	 * so we'll use stdio and low-level IO instead. */
	char buf[PERL_MEM_LOG_SPRINTF_BUF_SIZE];
#  ifdef PERL_MEM_LOG_TIMESTAMP
	struct timeval tv;
	gettimeofday(&tv, 0);
# endif
	{
	    const STRLEN len =
		my_snprintf(buf,
			    sizeof(buf),
#  ifdef PERL_MEM_LOG_TIMESTAMP
			    "%10d.%06d: "
# endif
			    "realloc: %s:%d:%s: %"IVdf" %"UVuf
			    " %s = %"IVdf": %"UVxf" -> %"UVxf"\n",
#  ifdef PERL_MEM_LOG_TIMESTAMP
			    (int)tv.tv_sec, (int)tv.tv_usec,
# endif
			    filename, linenumber, funcname, n, typesize,
			    typename, n * typesize, PTR2UV(oldalloc),
			    PTR2UV(newalloc));
# ifdef PERL_MEM_LOG_ENV_FD
	    s = PerlEnv_getenv("PERL_MEM_LOG_FD");
	    PerlLIO_write(s ? atoi(s) : PERL_MEM_LOG_FD, buf, len);
# else
	    PerlLIO_write(PERL_MEM_LOG_FD, buf, len);
# endif
	}
    }
d5683 1
a5683 36
# if defined(PERL_MEM_LOG_ENV) || defined(PERL_MEM_LOG_ENV_FD)
    char *s;
# endif
# ifdef PERL_MEM_LOG_ENV
    s = PerlEnv_getenv("PERL_MEM_LOG");
    if (s ? atoi(s) : 0)
# endif
    {
	/* We can't use SVs or PerlIO for obvious reasons,
	 * so we'll use stdio and low-level IO instead. */
	char buf[PERL_MEM_LOG_SPRINTF_BUF_SIZE];
#  ifdef PERL_MEM_LOG_TIMESTAMP
	struct timeval tv;
	gettimeofday(&tv, 0);
# endif
	{
	    const STRLEN len =
		my_snprintf(buf,
			    sizeof(buf),
#  ifdef PERL_MEM_LOG_TIMESTAMP
			    "%10d.%06d: "
# endif
			    "free: %s:%d:%s: %"UVxf"\n",
#  ifdef PERL_MEM_LOG_TIMESTAMP
			    (int)tv.tv_sec, (int)tv.tv_usec,
# endif
			    filename, linenumber, funcname,
			    PTR2UV(oldalloc));
# ifdef PERL_MEM_LOG_ENV_FD
	    s = PerlEnv_getenv("PERL_MEM_LOG_FD");
	    PerlLIO_write(s ? atoi(s) : PERL_MEM_LOG_FD, buf, len);
# else
	    PerlLIO_write(PERL_MEM_LOG_FD, buf, len);
# endif
	}
    }
d5688 16
d5720 1
d5746 1
d5778 3
d5870 1
d5905 2
d5925 2
d6013 2
d6022 2
a6023 1
		 !( (SvTYPE(*svp) == SVt_PVGV) && (GvCV((GV*)*svp) == cv) )))) {
d6026 1
a6026 1
	    SV * const tmp = newRV((SV*)cv);
d6069 1
a6069 1
            (tmpsv = (SV*)SvRV(sv)) &&            /* assign deliberate */
@


1.11
log
@merge in perl 5.8.8
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006, by Larry Wall and others
d60 11
d85 3
d95 22
a116 1
    if (ptr != Nullch)
d118 1
d120 1
a120 1
	return Nullch;
d122 1
a122 5
	/* Can't use PerlIO to write as it allocates memory */
	PerlLIO_write(PerlIO_fileno(Perl_error_log),
		      PL_no_mem, strlen(PL_no_mem));
	my_exit(1);
	return Nullch;
d152 22
d184 18
a201 1
    if (ptr != Nullch)
d203 1
d205 1
a205 1
	return Nullch;
d207 1
a207 5
	/* Can't use PerlIO to write as it allocates memory */
	PerlLIO_write(PerlIO_fileno(Perl_error_log),
		      PL_no_mem, strlen(PL_no_mem));
	my_exit(1);
	return Nullch;
d217 1
a217 1
#ifdef PERL_IMPLICIT_SYS
d219 2
d224 26
d261 1
d263 11
d275 1
a275 1
    if (size * count > 0xffff) {
d277 1
a277 1
		      "Allocation too large: %lx\n", size * count) FLUSH;
d285 13
a297 2
    size *= count;
    ptr = (Malloc_t)PerlMem_malloc(size?size:1);	/* malloc(0) is NASTY on our system */
d299 20
a318 3
    DEBUG_m(PerlIO_printf(Perl_debug_log, "0x%"UVxf": (%05ld) calloc %ld x %ld bytes\n",PTR2UV(ptr),(long)PL_an++,(long)count,(long)size));
    if (ptr != Nullch) {
	memset((void*)ptr, 0, size);
d322 2
a323 9
	return Nullch;
    else {
	/* Can't use PerlIO to write as it allocates memory */
	PerlLIO_write(PerlIO_fileno(Perl_error_log),
		      PL_no_mem, strlen(PL_no_mem));
	my_exit(1);
	return Nullch;
    }
    /*NOTREACHED*/
d360 1
a360 1
Perl_delimcpy(pTHX_ register char *to, register char *toend, register char *from, register char *fromend, register int delim, I32 *retlen)
d363 2
d367 1
a367 3
	    if (from[1] == delim)
		from++;
	    else {
a370 1
		from++;
d372 1
d392 1
d405 2
a406 3
		return Nullch;
	    if (*s++ != *x++) {
		s--;
d408 3
d416 1
a416 1
    return Nullch;
d422 1
a422 1
Perl_ninstr(pTHX_ register const char *big, register const char *bigend, const char *little, const char *lend)
d424 17
a440 20
    register const I32 first = *little;
    register const char *littleend = lend;

    if (!first && little >= littleend)
	return (char*)big;
    if (bigend - big < littleend - little)
	return Nullch;
    bigend -= littleend - little++;
    while (big <= bigend) {
	register const char *s, *x;
	if (*big++ != first)
	    continue;
	for (x=big,s=little; s < littleend; /**/ ) {
	    if (*s++ != *x++) {
		s--;
		break;
	    }
	}
	if (s >= littleend)
	    return (char*)(big-1);
d442 1
a442 1
    return Nullch;
d452 2
a453 1
    register const char *littleend = lend;
d455 1
a455 1
    if (!first && little >= littleend)
d464 1
a464 2
	    if (*s++ != *x++) {
		s--;
d466 3
d474 1
a474 1
    return Nullch;
a476 2
#define FBM_TABLE_OFFSET 2	/* Number of bytes between EOS and table*/

d497 1
d501 1
a501 1
    I32 rarest = 0;
d506 1
a506 1
	sv_catpvn(sv, "\n", 1);		/* Taken into account in fbm_instr() */
a510 1
    (void)SvUPGRADE(sv, SVt_PVBM);
d513 4
d522 4
a525 3
	Sv_Grow(sv, len + 256 + FBM_TABLE_OFFSET);
	table = (unsigned char*)(SvPVX_mutable(sv) + len + FBM_TABLE_OFFSET);
	s = table - 1 - FBM_TABLE_OFFSET;	/* last char */
a526 1
	table[-1] = (U8)flags;
d534 2
d537 1
a537 2
    sv_magic(sv, Nullsv, PERL_MAGIC_bm, Nullch, 0);	/* deep magic */
    SvVALID_on(sv);
d546 1
d548 1
a548 1
    BmPREVIOUS(sv) = (U16)rarest;
d552 2
a553 2
    DEBUG_r(PerlIO_printf(Perl_debug_log, "rarest char %c at %d\n",
			  BmRARE(sv),BmPREVIOUS(sv)));
d564 1
a564 1
C<strend>.  It returns C<Nullch> if the string can't be found.  The C<sv>
d588 1
a588 1
	return Nullch;
d608 1
a608 1
	    return Nullch;
d619 1
a619 1
	    return Nullch;
d672 1
a672 1
	return Nullch;
d687 1
a687 1
	return Nullch;
d689 2
a690 2
    if (SvTYPE(littlestr) != SVt_PVBM || !SvVALID(littlestr)) {
	char *b = ninstr((char*)big,(char*)bigend,
d701 1
a701 1
	    return Nullch;
d706 7
a712 2
    {	/* Do actual FBM.  */
	register const unsigned char *table = little + littlelen + FBM_TABLE_OFFSET;
a714 2
	if (littlelen > (STRLEN)(bigend - big))
	    return Nullch;
d747 2
a748 1
	if ( s == bigend && (table[-1] & FBMcf_TAIL)
d752 1
a752 1
	return Nullch;
d774 1
d784 3
d798 1
a798 1
	return Nullch;
d818 1
a818 1
	return Nullch;
d846 1
a846 1
	return Nullch;
d857 1
a857 1
    return Nullch;
d865 2
d878 1
d881 2
d909 1
d911 1
a911 1
	return Nullch;
d915 2
a916 2
	Newx(newaddr,pvlen,char);
	return memcpy(newaddr,pv,pvlen);
a917 1

d927 2
a928 2
C<len> bytes from C<pv>. The memory allocated for the new string can be
freed with the C<Safefree()> function.
d937 1
d965 1
a965 1
	return Nullch;
d970 21
a990 3
	PerlLIO_write(PerlIO_fileno(Perl_error_log),
		      PL_no_mem, strlen(PL_no_mem));
	my_exit(1);
d992 2
a993 1
    return memcpy(newaddr,pv,pvlen);
d1009 1
a1009 1
    const char *pv = SvPV_const(sv, len);
d1023 1
d1028 1
a1028 1
	return sv_2mortal(newSVpvn("",0));
d1038 1
d1093 1
a1093 1
    sv_vsetpvfn(sv, pat, strlen(pat), args, Null(SV**), 0, Null(bool*));
d1122 2
a1123 2
STATIC COP*
S_closest_cop(pTHX_ COP *cop, const OP *o)
d1125 1
d1128 2
a1129 1
    if (!o || o == PL_op) return cop;
d1132 3
a1134 4
	OP *kid;
	for (kid = cUNOPo->op_first; kid; kid = kid->op_sibling)
	{
	    COP *new_cop;
d1140 1
a1140 1
		cop = (COP *)kid;
d1145 2
a1146 1
	    if (new_cop) return new_cop;
d1152 1
a1152 1
    return Null(COP *);
d1158 2
a1159 2
    SV *sv = mess_alloc();
    static const char dgd[] = " during global destruction.\n";
d1161 1
a1161 1
    sv_vsetpvfn(sv, pat, strlen(pat), args, Null(SV**), 0, Null(bool*));
a1162 1

d1171 2
a1172 1
	if (!cop) cop = PL_curcop;
d1177 4
a1180 1
	if (GvIO(PL_last_in_gv) && IoLINES(GvIOp(PL_last_in_gv))) {
d1184 1
a1184 2
			   PL_last_in_gv == PL_argvgv ?
			   "" : GvNAME(PL_last_in_gv),
d1188 3
a1190 5
#ifdef USE_5005THREADS
	if (thr->tid)
	    Perl_sv_catpvf(aTHX_ sv, " thread %ld", thr->tid);
#endif
	sv_catpv(sv, PL_dirty ? dgd : ".\n");
d1198 1
d1212 1
a1212 1
	PL_stderrgv = Nullgv;
d1242 1
a1242 1
/* Common code used by vcroak, vdie and vwarner  */
d1244 2
a1245 4
/* Whilst this should really be STATIC, it was not in 5.8.7, hence something
   may have linked against it.  */
void
S_vdie_common(pTHX_ const char *message, STRLEN msglen, I32 utf8)
d1247 1
d1251 5
a1255 2
    /* sv_2cv might call Perl_croak() */
    SV * const olddiehook = PL_diehook;
a1256 1
    assert(PL_diehook);
d1258 3
a1260 3
    SAVESPTR(PL_diehook);
    PL_diehook = Nullsv;
    cv = sv_2cv(olddiehook, &stash, &gv, 0);
d1268 5
a1272 1
	if (message) {
d1282 1
a1282 1
	PUSHSTACKi(PERLSI_DIEHOOK);
d1289 1
d1291 1
d1294 1
a1294 3
/* Whilst this should really be STATIC, it was not in 5.8.7, hence something
   may have linked against it.  */
char *
d1298 1
d1313 1
a1313 1
	message = Nullch;
d1318 1
a1318 1
			  thr, message, PL_diehook));
d1320 1
a1320 1
	S_vdie_common(aTHX_ message, *msglen, *utf8);
d1322 1
a1322 3
    /* Cast because we're not changing function prototypes in maint, and this
       function isn't actually static.  */
    return (char *)  message;
d1328 1
d1336 1
a1336 1
			  thr, PL_curstack, PL_mainstack));
d1338 1
a1338 1
    message = S_vdie_croak_common(aTHX_ pat, args, &msglen, &utf8);
d1340 1
a1340 1
    PL_restartop = die_where((char *)message, msglen);
d1344 1
a1344 1
	  thr, PL_restartop, was_in_eval, PL_top_env));
d1378 1
d1386 1
a1386 1
	PL_restartop = die_where((char *) message, msglen);
d1421 1
a1421 1
C<$@@> and then pass C<Nullch> to croak():
d1425 1
a1425 1
   croak(Nullch);
d1443 1
d1450 1
a1450 31
	/* sv_2cv might call Perl_warn() */
	SV * const oldwarnhook = PL_warnhook;
	CV * cv;
	HV * stash;
	GV * gv;

	ENTER;
	SAVESPTR(PL_warnhook);
	PL_warnhook = Nullsv;
	cv = sv_2cv(oldwarnhook, &stash, &gv, 0);
	LEAVE;
	if (cv && !CvDEPTH(cv) && (CvROOT(cv) || CvXSUB(cv))) {
	    dSP;
	    SV *msg;

	    ENTER;
	    SAVESPTR(PL_warnhook);
	    PL_warnhook = Nullsv;
	    save_re_context();
	    msg = newSVpvn(message, msglen);
	    SvFLAGS(msg) |= utf8;
	    SvREADONLY_on(msg);
	    SAVEFREESV(msg);

	    PUSHSTACKi(PERLSI_WARNHOOK);
	    PUSHMARK(SP);
	    XPUSHs(msg);
	    PUTBACK;
	    call_sv((SV*)cv, G_DISCARD);
	    POPSTACK;
	    LEAVE;
a1451 1
	}
d1511 2
a1512 1
    if (ckDEAD(err)) {
d1515 1
a1515 1
	const char *message = SvPV_const(msv, msglen);
a1517 3
#ifdef USE_5005THREADS
	DEBUG_S(PerlIO_printf(Perl_debug_log, "croak: 0x%"UVxf" %s", PTR2UV(thr), message));
#endif /* USE_5005THREADS */
d1520 1
a1520 1
	    S_vdie_common(aTHX_ message, msglen, utf8);
d1523 1
a1523 1
	    PL_restartop = die_where((char *) message, msglen);
d1540 1
d1568 1
d1587 15
a1601 1

d1617 1
a1617 1
Perl_my_setenv(pTHX_ char *nam, char *val)
d1619 1
d1628 1
a1628 1
    register I32 i=setenv_getix(nam);		/* where does it go? */
d1631 16
a1646 14
    if (environ == PL_origenviron) {	/* need we copy environment? */
	I32 j;
	I32 max;
	char **tmpenv;

	for (max = i; environ[max]; max++) ;
	tmpenv = (char**)safesysmalloc((max+2) * sizeof(char*));
	for (j=0; j<max; j++) {		/* copy environment */
	    const int len = strlen(environ[j]);
	    tmpenv[j] = (char*)safesysmalloc((len+1)*sizeof(char));
	    Copy(environ[j], tmpenv[j], len+1, char);
	}
	tmpenv[max] = Nullch;
	environ = tmpenv;		/* tell exec where it is now */
d1649 10
a1658 10
	safesysfree(environ[i]);
	while (environ[i]) {
	    environ[i] = environ[i+1];
	    i++;
	}
	return;
    }
    if (!environ[i]) {			/* does not exist yet */
	environ = (char**)safesysrealloc(environ, (i+2) * sizeof(char*));
	environ[i+1] = Nullch;	/* make sure it's null terminated */
d1661 7
a1667 7
	safesysfree(environ[i]);
    nlen = strlen(nam);
    vlen = strlen(val);

    environ[i] = (char*)safesysmalloc((nlen+vlen+2) * sizeof(char));
    /* all that work just for this */
    my_setenv_format(environ[i], nam, nlen, val, vlen);
d1670 1
a1670 1
#   if defined(__CYGWIN__) || defined(EPOC) || defined(SYMBIAN) 
d1685 3
a1687 3
            int nlen = strlen(nam);
            int vlen = strlen(val);
            char *new_env =
d1694 2
a1695 1
        int nlen = strlen(nam), vlen;
d1715 1
a1715 1
Perl_my_setenv(pTHX_ char *nam, char *val)
d1717 1
d1723 1
a1723 1
	val = "";
d1736 1
a1736 1
Perl_setenv_getix(pTHX_ char *nam)
d1740 1
d1760 1
a1760 1
Perl_unlnk(pTHX_ char *f)	/* unlink all versions of a file */
d1762 1
a1762 1
    I32 i;
d1764 3
a1766 2
    for (i = 0; PerlLIO_unlink(f) >= 0; i++) ;
    return i ? 0 : -1;
d1835 12
d1853 1
a1853 1
vsprintf(char *dest, const char *pat, char *args)
d1857 6
d1865 1
d1871 9
a1879 1
    (void)putc('\0', &fakebuf);
d1912 4
a1915 1
#if BYTEORDER == 0x1234
d1986 2
a1987 2
	    register I32 i;					\
	    register I32 s = 0;					\
d2002 2
a2003 2
	    register I32 i;					\
	    register I32 s = 0;					\
d2024 2
a2025 2
	    register I32 i;					\
	    register I32 s = 8*(sizeof(u.c)-1);			\
d2040 2
a2041 2
	    register I32 i;					\
	    register I32 s = 8*(sizeof(u.c)-1);			\
d2219 2
a2220 1
#if (!defined(DOSISH) || defined(HAS_FORK) || defined(AMIGAOS)) && !defined(OS2) && !defined(VMS) && !defined(__OPEN_VM) && !defined(EPOC) && !defined(MACOS_TRADITIONAL) && !defined(NETWARE)
d2236 1
a2236 1
	return Nullfp;
d2248 1
a2248 1
	    return Nullfp;
d2289 1
a2289 1
	do_aexec5(Nullsv, args-1, args-1+n, pp[1], did_pipes);
d2310 1
a2310 1
    (void)SvUPGRADE(sv,SVt_IV);
d2316 2
a2317 1
	int n = 0, n1;
d2338 1
a2338 1
	    return Nullfp;
d2345 3
d2350 1
d2355 1
a2355 1
#if (!defined(DOSISH) || defined(HAS_FORK) || defined(AMIGAOS)) && !defined(VMS) && !defined(__OPEN_VM) && !defined(EPOC) && !defined(MACOS_TRADITIONAL)
d2357 1
a2357 1
Perl_my_popen(pTHX_ char *cmd, char *mode)
d2359 1
d2381 1
a2381 1
	return Nullfp;
d2394 1
a2394 1
	    return Nullfp;
d2438 9
a2446 1
	if ((tmpgv = gv_fetchpv("$",TRUE, SVt_PV))) {
d2455 1
d2457 2
a2458 1
	return Nullfp;
d2476 1
a2476 1
    (void)SvUPGRADE(sv,SVt_IV);
d2481 2
a2482 1
	int n = 0, n1;
d2503 1
a2503 1
	    return Nullfp;
d2514 1
a2514 1
Perl_my_popen(pTHX_ char *cmd, char *mode)
d2527 1
a2527 1
Perl_my_popen(pTHX_ char *cmd, char *mode)
d2536 8
d2553 2
a2554 1
#if defined(USE_5005THREADS) || defined(USE_ITHREADS)
d2567 2
a2568 1
#if defined(USE_5005THREADS) || defined(USE_ITHREADS)
d2582 1
a2582 1
#if (defined(USE_5005THREADS) || defined(USE_ITHREADS)) && !defined(HAS_PTHREAD_ATFORK)
d2661 1
d2667 1
a2667 1
	return SIG_ERR;
d2670 1
a2670 1
    act.sa_handler = handler;
d2678 1
a2678 1
    if (signo == SIGCHLD && handler == (Sighandler_t)SIG_IGN)
d2682 1
a2682 1
    	return SIG_ERR;
d2684 1
a2684 1
    	return oact.sa_handler;
d2691 1
d2694 1
a2694 1
	return SIG_ERR;
d2696 1
a2696 1
	return oact.sa_handler;
d2702 1
d2711 1
a2711 1
    act.sa_handler = handler;
d2719 1
a2719 1
    if (signo == SIGCHLD && handler == (Sighandler_t)SIG_IGN)
d2728 1
d2746 1
a2746 1
	return SIG_ERR;
d2752 1
a2752 5
static int PL_sig_trapped; /* XXX signals are process-wide anyway, so we
			      ignore the implications of this for threading */

static
Signal_t
d2755 1
d2762 1
d2768 1
a2768 1
	return SIG_ERR;
d2788 1
a2788 1
    return (*save == SIG_ERR) ? -1 : 0;
d2799 1
a2799 1
    return (PerlProc_signal(signo, *save) == SIG_ERR) ? -1 : 0;
d2806 1
a2806 1
#if (!defined(DOSISH) || defined(HAS_FORK) || defined(AMIGAOS)) && !defined(VMS) && !defined(__OPEN_VM) && !defined(EPOC) && !defined(MACOS_TRADITIONAL)
d2810 1
a2817 3
#ifdef VMS
    int saved_vaxc_errno;
#endif
a2834 3
#ifdef VMS
	saved_vaxc_errno = vaxc$errno;
#endif
d2843 3
a2845 3
    rsignal_save(SIGHUP, SIG_IGN, &hstat);
    rsignal_save(SIGINT, SIG_IGN, &istat);
    rsignal_save(SIGQUIT, SIG_IGN, &qstat);
d2856 1
a2856 1
	SETERRNO(saved_errno, saved_vaxc_errno);
d2861 8
d2871 1
a2871 1
#if  (!defined(DOSISH) || defined(OS2) || defined(WIN32) || defined(NETWARE)) && !defined(MACOS_TRADITIONAL)
d2875 1
d2879 1
a2879 1
#if !defined(HAS_WAITPID) && !defined(HAS_WAIT4) || defined(HAS_WAITPID_RUNTIME)
a2880 2
	char spid[TYPE_CHARS(IV)];

d2882 3
a2884 3
	    SV** svp;
	    sprintf(spid, "%"IVdf, (IV)pid);
	    svp = hv_fetch(PL_pidstatus,spid,strlen(spid),FALSE);
d2887 2
a2888 1
		(void)hv_delete(PL_pidstatus,spid,strlen(spid),G_DISCARD);
d2897 3
a2899 1
		SV *sv = hv_iterval(PL_pidstatus,entry);
d2901 2
a2902 1
		pid = atoi(hv_iterkey(entry,(I32*)statusp));
d2904 8
a2911 2
		sprintf(spid, "%"IVdf, (IV)pid);
		(void)hv_delete(PL_pidstatus,spid,strlen(spid),G_DISCARD);
d2926 1
a2926 1
    result = wait4((pid==-1)?0:pid,statusp,flags,Null(struct rusage *));
d2929 1
a2929 1
#if !defined(HAS_WAITPID) && !defined(HAS_WAIT4) || defined(HAS_WAITPID_RUNTIME)
d2954 1
a2958 1
    char spid[TYPE_CHARS(IV)];
d2960 2
a2961 3
    sprintf(spid, "%"IVdf, (IV)pid);
    sv = *hv_fetch(PL_pidstatus,spid,strlen(spid),TRUE);
    (void)SvUPGRADE(sv,SVt_IV);
d2965 1
d2979 2
a2980 2
    FILE *f = PerlIO_findFILE(ptr);
    I32 result = pclose(f);
d2992 1
a2992 1
    FILE *f = PerlIO_findFILE(ptr);
d3004 2
a3005 1
    register const char *frombase = from;
d3023 1
a3023 1
Perl_same_dirent(pTHX_ char *a, char *b)
d3029 1
a3029 1
    SV *tmpsv = sv_newmortal();
d3059 2
a3060 2
Perl_find_script(pTHX_ char *scriptname, bool dosearch, char **search_ext,
		 I32 flags)
d3062 3
a3064 2
    const char *xfound = Nullch;
    char *xfailed = Nullch;
d3069 1
d3084 2
a3085 3
    const char *const exts[] = { SEARCH_EXTS };
    const char *const *const ext =
	search_ext ? (const char *const *const)search_ext : exts;
d3087 1
a3087 1
    const char *curext = Nullch;
d3117 1
a3117 1
	int hasdir, idx = 0, deftypes = 1;
d3120 1
a3120 1
	hasdir = !dosearch || (strpbrk(scriptname,":[</") != Nullch) ;
d3123 1
a3123 1
	int hasdir, idx = 0, deftypes = 1;
d3126 1
a3126 1
	hasdir = (strpbrk(scriptname,":[</") != Nullch) ;
d3140 1
a3140 1
	    strcat(tmpbuf, scriptname);
d3147 1
a3147 1
	char *cur = scriptname;
d3172 2
a3173 2
		/* FIXME? Convert to memcpy  */
		cur = strcpy(tmpbuf, scriptname);
d3176 1
a3176 1
		 && strcpy(tmpbuf+len, ext[extidx++]));
d3193 3
a3195 3
	
	PL_bufend = s + strlen(s);
	while (s < PL_bufend) {
d3197 1
a3197 1
	    s = delimcpy(tmpbuf, tmpbuf + sizeof tmpbuf, s, PL_bufend,
d3213 1
a3213 1
	    s = delimcpy(tmpbuf, tmpbuf + sizeof tmpbuf, s, PL_bufend,
d3218 1
a3218 1
	    if (s < PL_bufend)
d3236 1
a3236 3
	    /* FIXME? Convert to memcpy by storing previous strlen(scriptname)
	     */
	    (void)strcpy(tmpbuf + len, scriptname);
d3253 1
a3253 1
		    && strcpy(tmpbuf+len, ext[extidx++])
d3285 1
a3285 1
	    scriptname = Nullch;
d3288 1
a3288 2
	/* Cast because we're not changing function prototypes in maint.  */
	scriptname = (char *) xfound;
d3290 1
a3290 1
    return (scriptname ? savepv(scriptname) : Nullch);
d3298 2
a3299 1
#if defined(USE_5005THREADS) || defined(USE_ITHREADS)
d3320 2
a3321 1
#if defined(USE_5005THREADS) || defined(USE_ITHREADS)
a3334 278
#ifdef USE_5005THREADS

#ifdef FAKE_THREADS
/* Very simplistic scheduler for now */
void
schedule(void)
{
    thr = thr->i.next_run;
}

void
Perl_cond_init(pTHX_ perl_cond *cp)
{
    *cp = 0;
}

void
Perl_cond_signal(pTHX_ perl_cond *cp)
{
    perl_os_thread t;
    perl_cond cond = *cp;

    if (!cond)
	return;
    t = cond->thread;
    /* Insert t in the runnable queue just ahead of us */
    t->i.next_run = thr->i.next_run;
    thr->i.next_run->i.prev_run = t;
    t->i.prev_run = thr;
    thr->i.next_run = t;
    thr->i.wait_queue = 0;
    /* Remove from the wait queue */
    *cp = cond->next;
    Safefree(cond);
}

void
Perl_cond_broadcast(pTHX_ perl_cond *cp)
{
    perl_os_thread t;
    perl_cond cond, cond_next;

    for (cond = *cp; cond; cond = cond_next) {
	t = cond->thread;
	/* Insert t in the runnable queue just ahead of us */
	t->i.next_run = thr->i.next_run;
	thr->i.next_run->i.prev_run = t;
	t->i.prev_run = thr;
	thr->i.next_run = t;
	thr->i.wait_queue = 0;
	/* Remove from the wait queue */
	cond_next = cond->next;
	Safefree(cond);
    }
    *cp = 0;
}

void
Perl_cond_wait(pTHX_ perl_cond *cp)
{
    perl_cond cond;

    if (thr->i.next_run == thr)
	Perl_croak(aTHX_ "panic: perl_cond_wait called by last runnable thread");

    New(666, cond, 1, struct perl_wait_queue);
    cond->thread = thr;
    cond->next = *cp;
    *cp = cond;
    thr->i.wait_queue = cond;
    /* Remove ourselves from runnable queue */
    thr->i.next_run->i.prev_run = thr->i.prev_run;
    thr->i.prev_run->i.next_run = thr->i.next_run;
}
#endif /* FAKE_THREADS */

MAGIC *
Perl_condpair_magic(pTHX_ SV *sv)
{
    MAGIC *mg;

    (void)SvUPGRADE(sv, SVt_PVMG);
    mg = mg_find(sv, PERL_MAGIC_mutex);
    if (!mg) {
	condpair_t *cp;

	New(53, cp, 1, condpair_t);
	MUTEX_INIT(&cp->mutex);
	COND_INIT(&cp->owner_cond);
	COND_INIT(&cp->cond);
	cp->owner = 0;
	LOCK_CRED_MUTEX;		/* XXX need separate mutex? */
	mg = mg_find(sv, PERL_MAGIC_mutex);
	if (mg) {
	    /* someone else beat us to initialising it */
	    UNLOCK_CRED_MUTEX;		/* XXX need separate mutex? */
	    MUTEX_DESTROY(&cp->mutex);
	    COND_DESTROY(&cp->owner_cond);
	    COND_DESTROY(&cp->cond);
	    Safefree(cp);
	}
	else {
	    sv_magic(sv, Nullsv, PERL_MAGIC_mutex, 0, 0);
	    mg = SvMAGIC(sv);
	    mg->mg_ptr = (char *)cp;
	    mg->mg_len = sizeof(cp);
	    UNLOCK_CRED_MUTEX;		/* XXX need separate mutex? */
	    DEBUG_S(WITH_THR(PerlIO_printf(Perl_debug_log,
					   "%p: condpair_magic %p\n", thr, sv)));
	}
    }
    return mg;
}

SV *
Perl_sv_lock(pTHX_ SV *osv)
{
    MAGIC *mg;
    SV *sv = osv;

    LOCK_SV_LOCK_MUTEX;
    if (SvROK(sv)) {
	sv = SvRV(sv);
    }

    mg = condpair_magic(sv);
    MUTEX_LOCK(MgMUTEXP(mg));
    if (MgOWNER(mg) == thr)
	MUTEX_UNLOCK(MgMUTEXP(mg));
    else {
	while (MgOWNER(mg))
	    COND_WAIT(MgOWNERCONDP(mg), MgMUTEXP(mg));
	MgOWNER(mg) = thr;
	DEBUG_S(PerlIO_printf(Perl_debug_log,
			      "0x%"UVxf": Perl_lock lock 0x%"UVxf"\n",
			      PTR2UV(thr), PTR2UV(sv)));
	MUTEX_UNLOCK(MgMUTEXP(mg));
	SAVEDESTRUCTOR_X(Perl_unlock_condpair, sv);
    }
    UNLOCK_SV_LOCK_MUTEX;
    return sv;
}

/*
 * Make a new perl thread structure using t as a prototype. Some of the
 * fields for the new thread are copied from the prototype thread, t,
 * so t should not be running in perl at the time this function is
 * called. The use by ext/Thread/Thread.xs in core perl (where t is the
 * thread calling new_struct_thread) clearly satisfies this constraint.
 */
struct perl_thread *
Perl_new_struct_thread(pTHX_ struct perl_thread *t)
{
#if !defined(PERL_IMPLICIT_CONTEXT)
    struct perl_thread *thr;
#endif
    SV *sv;
    SV **svp;
    I32 i;

    sv = newSVpvn("", 0);
    SvGROW(sv, sizeof(struct perl_thread) + 1);
    SvCUR_set(sv, sizeof(struct perl_thread));
    thr = (Thread) SvPVX(sv);
#ifdef DEBUGGING
    Poison(thr, 1, struct perl_thread);
    PL_markstack = 0;
    PL_scopestack = 0;
    PL_savestack = 0;
    PL_retstack = 0;
    PL_dirty = 0;
    PL_localizing = 0;
    Zero(&PL_hv_fetch_ent_mh, 1, HE);
    PL_efloatbuf = (char*)NULL;
    PL_efloatsize = 0;
#else
    Zero(thr, 1, struct perl_thread);
#endif

    thr->oursv = sv;
    init_stacks();

    PL_curcop = &PL_compiling;
    thr->interp = t->interp;
    thr->cvcache = newHV();
    thr->threadsv = newAV();
    thr->specific = newAV();
    thr->errsv = newSVpvn("", 0);
    thr->flags = THRf_R_JOINABLE;
    thr->thr_done = 0;
    MUTEX_INIT(&thr->mutex);

    JMPENV_BOOTSTRAP;

    PL_in_eval = EVAL_NULL;	/* ~(EVAL_INEVAL|EVAL_WARNONLY|EVAL_KEEPERR|EVAL_INREQUIRE) */
    PL_restartop = 0;

    PL_statname = NEWSV(66,0);
    PL_errors = newSVpvn("", 0);
    PL_maxscream = -1;
    PL_regcompp = MEMBER_TO_FPTR(Perl_pregcomp);
    PL_regexecp = MEMBER_TO_FPTR(Perl_regexec_flags);
    PL_regint_start = MEMBER_TO_FPTR(Perl_re_intuit_start);
    PL_regint_string = MEMBER_TO_FPTR(Perl_re_intuit_string);
    PL_regfree = MEMBER_TO_FPTR(Perl_pregfree);
    PL_regindent = 0;
    PL_reginterp_cnt = 0;
    PL_lastscream = Nullsv;
    PL_screamfirst = 0;
    PL_screamnext = 0;
    PL_reg_start_tmp = 0;
    PL_reg_start_tmpl = 0;
    PL_reg_poscache = Nullch;

    PL_peepp = MEMBER_TO_FPTR(Perl_peep);

    /* parent thread's data needs to be locked while we make copy */
    MUTEX_LOCK(&t->mutex);

#ifdef PERL_FLEXIBLE_EXCEPTIONS
    PL_protect = t->Tprotect;
#endif

    PL_curcop = t->Tcurcop;       /* XXX As good a guess as any? */
    PL_defstash = t->Tdefstash;   /* XXX maybe these should */
    PL_curstash = t->Tcurstash;   /* always be set to main? */

    PL_tainted = t->Ttainted;
    PL_curpm = t->Tcurpm;	/* XXX No PMOP ref count */
    PL_rs = newSVsv(t->Trs);
    PL_last_in_gv = Nullgv;
    PL_ofs_sv = t->Tofs_sv ? SvREFCNT_inc(PL_ofs_sv) : Nullsv;
    PL_defoutgv = (GV*)SvREFCNT_inc(t->Tdefoutgv);
    PL_chopset = t->Tchopset;
    PL_bodytarget = newSVsv(t->Tbodytarget);
    PL_toptarget = newSVsv(t->Ttoptarget);
    if (t->Tformtarget == t->Ttoptarget)
	PL_formtarget = PL_toptarget;
    else
	PL_formtarget = PL_bodytarget;
    PL_watchaddr = 0; /* XXX */
    PL_watchok = 0; /* XXX */
    PL_comppad = 0;
    PL_curpad = 0;

    /* Initialise all per-thread SVs that the template thread used */
    svp = AvARRAY(t->threadsv);
    for (i = 0; i <= AvFILLp(t->threadsv); i++, svp++) {
	if (*svp && *svp != &PL_sv_undef) {
	    SV *sv = newSVsv(*svp);
	    av_store(thr->threadsv, i, sv);
	    sv_magic(sv, 0, PERL_MAGIC_sv, &PL_threadsv_names[i], 1);
	    DEBUG_S(PerlIO_printf(Perl_debug_log,
		"new_struct_thread: copied threadsv %"IVdf" %p->%p\n",
				  (IV)i, t, thr));
	}
    }
    thr->threadsvp = AvARRAY(thr->threadsv);

    MUTEX_LOCK(&PL_threads_mutex);
    PL_nthreads++;
    thr->tid = ++PL_threadnum;
    thr->next = t->next;
    thr->prev = t;
    t->next = thr;
    thr->next->prev = thr;
    MUTEX_UNLOCK(&PL_threads_mutex);

    /* done copying parent's state */
    MUTEX_UNLOCK(&t->mutex);

#ifdef HAVE_THREAD_INTERN
    Perl_init_thread_intern(thr);
#endif /* HAVE_THREAD_INTERN */
    return thr;
}
#endif /* USE_5005THREADS */

d3346 2
a3347 1
 return (char **)PL_op_name;
d3353 2
a3354 1
 return (char **)PL_op_desc;
d3357 1
a3357 1
char *
d3360 2
a3361 2
    /* Cast because we're not changing function prototypes in maint.  */
    return (char *) PL_no_modify;
d3367 2
a3368 1
 return (U32 *)PL_opargs;
d3374 3
a3376 1
 return (PPADDR_t*)PL_ppaddr;
d3384 1
d3395 2
a3396 1
    const MGVTBL* result = Null(MGVTBL*);
a3431 3
    case want_vtbl_glob:
	result = &PL_vtbl_glob;
	break;
a3458 5
#ifdef USE_5005THREADS
    case want_vtbl_mutex:
	result = &PL_vtbl_mutex;
	break;
#endif
d3488 3
d3546 1
a3546 1
Perl_report_evil_fh(pTHX_ GV *gv, IO *io, I32 op)
a3547 8
    const char * const func =
	op == OP_READLINE   ? "readline"  :	/* "<HANDLE>" not nice */
	op == OP_LEAVEWRITE ? "write" :		/* "write exit" not nice */
	PL_op_desc[op];
    const char * const pars = OP_IS_FILETEST(op) ? "" : "()";
    const char * const type = OP_IS_SOCKET(op)
	    || (gv && io && IoTYPE(io) == IoTYPE_SOCKET)
		?  "socket" : "filehandle";
d3552 2
a3553 1
	    const char * const direction = (op == OP_phoney_INPUT_ONLY) ? "in" : "out";
d3577 13
d3702 1
d3890 1
a3890 1
Perl_my_strftime(pTHX_ char *fmt, int sec, int min, int hour, int mday, int mon, int year, int wday, int yday, int isdst)
d3945 1
a3945 1
    const int bufsize = fmtlen + buflen;
d3958 2
a3959 1
      Renew(buf, bufsize*2, char);
d4000 1
a4000 1

d4013 1
a4013 1
	    sv_setpvn(sv, buf, strlen(buf));
d4029 1
a4029 1
    (void)SvUPGRADE(sv, SVt_PV);
d4142 694
a4835 2
#if !defined(HAS_SOCKETPAIR) && defined(HAS_SOCKET) && defined(AF_INET) && defined(PF_INET) && defined(SOCK_DGRAM) && defined(HAS_SELECT)
#   define EMULATE_SOCKETPAIR_UDP
d4913 2
a4914 2
	FD_SET(sockets[0], &rset);
	FD_SET(sockets[1], &rset);
d5072 1
a5072 1
	int save_errno = errno;
d5101 3
a5103 2
Exists to avoid test for a NULL function pointer and because it could potentially warn under
some level of strict-ness.
d5111 1
a5115 1
=for apidoc sv_nolocking
d5117 1
a5117 16
Dummy routine which "locks" an SV when there is no locking module present.
Exists to avoid test for a NULL function pointer and because it could potentially warn under
some level of strict-ness.

=cut
*/

void
Perl_sv_nolocking(pTHX_ SV *sv)
{
    PERL_UNUSED_ARG(sv);
}


/*
=for apidoc sv_nounlocking
d5119 4
a5122 3
Dummy routine which "unlocks" an SV when there is no locking module present.
Exists to avoid test for a NULL function pointer and because it could potentially warn under
some level of strict-ness.
d5127 2
a5128 2
void
Perl_sv_nounlocking(pTHX_ SV *sv)
d5130 1
d5132 1
d5136 1
a5136 1
Perl_parse_unicode_opts(pTHX_ char **popt)
d5144 2
a5145 1
	    while (isDIGIT(*p)) p++;
d5170 2
d5187 1
a5187 2
  /* Cast because we're not changing function prototypes in maint.  */
  *popt = (char *) p;
d5195 1
d5277 1
d5282 2
a5283 1
	  while (isSPACE(*s)) s++;
d5319 1
d5330 339
d5672 1
d5698 2
a5699 1
    char *buf = (char*)safesysmalloc(bsiz * sizeof(char));
d5702 1
a5702 1
      int l = e ? e - *environ : strlen(*environ);
d5705 2
a5706 2
        bsiz = l + 1;
        buf = (char*)safesysmalloc(bsiz * sizeof(char));
d5708 2
a5709 2
      strncpy(buf, *environ, l);
      *(buf + l) = '\0';
d5722 217
@


1.10
log
@sync in-tree perl with 5.8.6
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, by Larry Wall and others
d33 5
a153 1
	/*SUPPRESS 701*/
d253 1
a253 1
    return from;
a261 1
    register const char *s, *x;
d270 1
d292 1
a292 2
    register const char *s, *x;
    register I32 first = *little;
d301 1
d322 1
a322 2
    register const char *s, *x;
    register I32 first = *little;
d330 1
d367 1
a367 2
    register U8 *s;
    register U8 *table;
d374 1
a374 1
	MAGIC *mg = SvUTF8(sv) && SvMAGICAL(sv) ? mg_find(sv, PERL_MAGIC_utf8) : NULL;
d379 1
a379 1
    s = (U8*)SvPV_force(sv, len);
d384 3
a386 2
	U8 mlen;
	unsigned char *sb;
a387 4
	if (len > 255)
	    mlen = 255;
	else
	    mlen = (U8)len;
d389 1
a389 1
	table = (unsigned char*)(SvPVX(sv) + len + FBM_TABLE_OFFSET);
d404 1
a404 1
    s = (unsigned char*)(SvPVX(sv));		/* deeper magic */
d440 2
a441 1
    register unsigned char *little = (unsigned char *)SvPV(littlestr,l);
d443 1
a443 1
    register I32 multiline = flags & FBMrf_MULTILINE;
d489 2
a490 2
	    register unsigned char c1 = little[0];
	    register unsigned char c2 = little[1];
d571 2
a572 2
	register unsigned char *table = little + littlelen + FBM_TABLE_OFFSET;
	register unsigned char *oldlittle;
a584 1
	    /*SUPPRESS 560*/
d591 1
a591 1
		register unsigned char *olds = s;
d618 1
a618 1
   If `last' we want the last occurrence.
d634 1
a634 2
    register unsigned char *s, *x;
    register unsigned char *big;
d638 1
a638 1
    register unsigned char *little;
d640 1
a640 1
    register unsigned char *littleend;
d649 1
a649 1
	    little = (unsigned char *)(SvPVX(littlestr));
d657 1
a657 1
    little = (unsigned char *)(SvPVX(littlestr));
d662 1
a662 1
    big = (unsigned char *)(SvPVX(bigstr));
d682 1
d704 1
a704 1
    big = (unsigned char *)(SvPVX(bigstr) + SvCUR(bigstr));
d719 2
a720 2
    register U8 *a = (U8 *)s1;
    register U8 *b = (U8 *)s2;
d732 2
a733 2
    register U8 *a = (U8 *)s1;
    register U8 *b = (U8 *)s2;
a759 1
    register char *newaddr;
d762 6
a768 2
    New(902,newaddr,strlen(pv)+1,char);
    return strcpy(newaddr,pv);
d789 1
a789 1
    New(903,newaddr,len+1,char);
d794 1
a794 1
    	return CopyD(pv,newaddr,len,char);
d797 1
a797 1
	return ZeroD(newaddr,len+1,char);
d813 1
d817 2
a818 1
    newaddr = (char*)PerlMemShared_malloc(strlen(pv)+1);
d824 1
a824 1
    return strcpy(newaddr,pv);
d827 20
d864 2
a865 2
    New(905, sv, 1, SV);
    Newz(905, any, 1, XPVMG);
d921 1
a921 1
    SV *sv = mess_alloc();
d952 1
a952 1
S_closest_cop(pTHX_ COP *cop, OP *o)
d979 1
a979 1
    return 0;
d986 1
a986 2
    static char dgd[] = " during global destruction.\n";
    COP *cop;
d998 1
a998 1
	cop = closest_cop(PL_curcop, PL_curcop->op_sibling);
d1005 2
a1006 2
	    bool line_mode = (RsSIMPLE(PL_rs) &&
			      SvCUR(PL_rs) == 1 && *SvPVX(PL_rs) == '\n');
d1056 1
a1056 1
	int e = errno;
d1058 1
a1058 1
	PerlIO *serr = Perl_error_log;
d1070 2
a1071 32
void S_vdie_common(pTHX_ const char *message, STRLEN msglen, I32 utf8);

char *
S_vdie_croak_common(pTHX_ const char* pat, va_list* args, STRLEN* msglen,
		    I32* utf8)
{
    char *message;

    if (pat) {
	SV *msv = vmess(pat, args);
	if (PL_errors && SvCUR(PL_errors)) {
	    sv_catsv(PL_errors, msv);
	    message = SvPV(PL_errors, *msglen);
	    SvCUR_set(PL_errors, 0);
	}
	else
	    message = SvPV(msv,*msglen);
	*utf8 = SvUTF8(msv);
    }
    else {
	message = Nullch;
    }

    DEBUG_S(PerlIO_printf(Perl_debug_log,
			  "%p: die/croak: message = %s\ndiehook = %p\n",
			  thr, message, PL_diehook));
    if (PL_diehook) {
	S_vdie_common(aTHX_ message, *msglen, *utf8);
    }
    return message;
}

d1079 1
a1079 1
    SV *olddiehook = PL_diehook;
d1113 34
d1150 2
a1151 2
    char *message;
    int was_in_eval = PL_in_eval;
d1161 1
a1161 1
    PL_restartop = die_where(message, msglen);
d1199 1
a1199 1
    char *message;
d1206 1
a1206 1
	PL_restartop = die_where(message, msglen);
d1211 1
a1211 1
	message = SvPVx(ERRSV, msglen);
a1262 5
    char *message;
    HV *stash;
    GV *gv;
    CV *cv;
    SV *msv;
d1264 3
a1266 5
    I32 utf8 = 0;

    msv = vmess(pat, args);
    utf8 = SvUTF8(msv);
    message = SvPV(msv, msglen);
d1270 5
a1274 1
	SV *oldwarnhook = PL_warnhook;
d1285 2
d1341 1
a1341 1
    dTHX;
d1362 1
a1362 1
	SV *msv = vmess(pat, args);
d1364 2
a1365 2
	char *message = SvPV(msv, msglen);
	I32 utf8 = SvUTF8(msv);
d1375 1
a1375 1
	    PL_restartop = die_where(message, msglen);
d1387 52
a1470 1
	/*SUPPRESS 530*/
d1474 1
a1474 1
	    int len = strlen(environ[j]);
d1503 10
a1512 2
#   if defined(__CYGWIN__) || defined( EPOC)
    setenv(nam, val, 1);
d1514 23
a1536 10
    char *new_env;
    int nlen = strlen(nam), vlen;
    if (!val) {
	val = "";
    }
    vlen = strlen(val);
    new_env = (char*)safesysmalloc((nlen + vlen + 2) * sizeof(char));
    /* all that work just for this */
    my_setenv_format(new_env, nam, nlen, val, vlen);
    (void)putenv(new_env);
d1547 1
a1547 1
Perl_my_setenv(pTHX_ char *nam,char *val)
d1550 2
a1551 1
    int nlen = strlen(nam), vlen;
d1557 1
a1557 1
    New(904, envstr, nlen+vlen+2, char);
d1569 2
a1570 1
    register I32 i, len = strlen(nam);
d1604 1
a1604 1
    char *retval = to;
d1625 1
a1625 1
    char *retval = loc;
d1638 1
a1638 1
    char *retval = loc;
d1651 2
a1652 2
    register U8 *a = (U8 *)s1;
    register U8 *b = (U8 *)s2;
d1656 1
a1656 1
	if (tmp = *a++ - *b++)
d1777 1
a1777 1
#define HTOV(name,type)						\
d1786 2
a1787 2
	    register I32 s;					\
	    for (i = 0, s = 0; i < sizeof(u.c); i++, s += 8) {	\
d1793 1
a1793 1
#define VTOH(name,type)						\
d1802 1
a1802 1
	    register I32 s;					\
d1805 2
a1806 2
	    for (i = 0, s = 0; i < sizeof(u.c); i++, s += 8) {	\
		n += (u.c[i] & 0xFF) << s;			\
d1811 51
d1863 1
a1863 1
HTOV(htovs,short)
d1866 1
a1866 1
HTOV(htovl,long)
d1869 1
a1869 1
VTOH(vtohs,short)
d1872 88
a1959 1
VTOH(vtohl,long)
d1962 53
d2109 1
a2109 1
    SvIVX(sv) = pid;
d2156 1
a2156 1
    I32 doexec = strNE(cmd,"-");
a2213 2
	    int fd;

a2229 1
	/*SUPPRESS 560*/
d2259 1
a2259 1
    SvIVX(sv) = pid;
d2383 1
d2519 2
a2520 2
static int sig_trapped;	/* XXX signals are process-wide anyway, so we
			   ignore the implications of this for threading */
d2526 1
a2526 1
    sig_trapped++;
d2540 1
a2540 1
    sig_trapped = 0;
d2543 1
a2543 1
    if (sig_trapped)
d2641 1
a2641 1
    I32 result;
d2646 1
a2646 3
	SV *sv;
	SV** svp;
	char spid[TYPE_CHARS(int)];
d2649 1
d2663 1
a2663 2
		SV *sv;
		char spid[TYPE_CHARS(int)];
a2665 1
		sv = hv_iterval(PL_pidstatus,entry);
d2687 1
d2689 1
d2701 1
d2703 1
a2711 1
/*SUPPRESS 590*/
d2715 1
a2715 1
    char spid[TYPE_CHARS(int)];
d2720 1
a2720 1
    SvIVX(sv) = status;
d2798 1
a2798 1
	sv_setpv(tmpsv, ".");
d2801 1
a2801 1
    if (PerlLIO_stat(SvPVX(tmpsv), &tmpstatbuf1) < 0)
d2804 1
a2804 1
	sv_setpv(tmpsv, ".");
d2807 1
a2807 1
    if (PerlLIO_stat(SvPVX(tmpsv), &tmpstatbuf2) < 0)
d2815 2
a2816 1
Perl_find_script(pTHX_ char *scriptname, bool dosearch, char **search_ext, I32 flags)
d2818 1
a2818 1
    char *xfound = Nullch;
d2838 3
a2840 2
    char *exts[] = { SEARCH_EXTS };
    char **ext = search_ext ? search_ext : exts;
d2842 1
a2842 1
    char *curext = Nullch;
d2844 1
d2927 1
d2982 1
a2982 1
#if defined(atarist) || defined(__MINT__) || defined(DOSISH)
d2985 1
a2985 1
#endif
d2991 2
d3044 3
a3046 3
	if (xfailed)
	    Safefree(xfailed);
	scriptname = xfound;
d3084 2
d3369 1
a3369 1
#ifdef PERL_GLOBAL_STRUCT
d3380 1
a3380 1
 return PL_op_name;
d3386 1
a3386 1
 return PL_op_desc;
d3392 2
a3393 1
 return (char*)PL_no_modify;
d3399 1
a3399 1
 return PL_opargs;
d3412 1
a3412 1
    char *env_trans = PerlEnv_getenv(env_elem);
d3423 1
a3423 1
    MGVTBL* result = Null(MGVTBL*);
d3524 1
a3524 1
    return result;
d3580 1
a3580 1
    char *func =
d3584 2
a3585 2
    char *pars = OP_IS_FILETEST(op) ? "" : "()";
    char *type = OP_IS_SOCKET(op)
d3588 1
a3588 5
    char *name = NULL;

    if (gv && isGV(gv)) {
	name = GvENAME(gv);
    }
d3592 1
a3592 1
	    const char *direction = (op == OP_phoney_INPUT_ONLY) ? "in" : "out";
d3603 1
a3603 1
	char *vile;
d3648 1
a3648 1
	char *ctlp;
d3707 1
d3709 5
a3713 1
    Copy(localtime(&now), ptm, 1, struct tm);
d3949 1
a3949 1
  New(0, buf, buflen, char);
d3969 2
a3970 2
    int     fmtlen = strlen(fmt);
    int	    bufsize = fmtlen + buflen;
d3972 1
a3972 1
    New(0, buf, bufsize, char);
d3983 1
a3983 2
      bufsize *= 2;
      Renew(buf, bufsize, char);
d3989 1
d4037 1
a4037 2
	    STRLEN len = strlen(buf);
	    sv_setpvn(sv, buf, len);
d4050 1
a4050 2
    int namelen, pathlen=0;
    DIR *dir;
d4065 1
d4088 1
a4088 1
	    namelen = dp->d_namlen;
d4090 1
a4090 1
	    namelen = strlen(dp->d_name);
d4120 1
a4120 1
	    Move(SvPVX(sv), SvPVX(sv) + namelen + 1, pathlen, char);
d4142 1
a4142 1
	if (PerlDir_chdir(SvPVX(sv)) < 0) {
d4300 1
a4300 1
	int save_errno = errno;
d4393 9
a4401 1
  errno = ECONNABORTED; /* I hope this is portable and appropriate.  */
d4442 1
d4458 1
d4475 1
d4481 1
a4481 1
  char *p = *popt;
d4527 2
a4528 1
  *popt = p;
d4586 1
a4586 1
    	if (PerlLIO_read(fd, &u, sizeof u) != sizeof u)
d4617 1
a4617 1
     char *s = PerlEnv_getenv("PERL_HASH_SEED");
d4650 79
@


1.9
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d16 6
d760 6
a765 6
    register char *newaddr = Nullch;
    if (pv) {
	New(902,newaddr,strlen(pv)+1,char);
	(void)strcpy(newaddr,pv);
    }
    return newaddr;
d789 3
a791 2
    	Copy(pv,newaddr,len,char);	/* might not be null terminated */
    	newaddr[len] = '\0';		/* is now */
d794 1
a794 1
	Zero(newaddr,len+1,char);
a795 1
    return newaddr;
d809 9
a817 4
    register char *newaddr = Nullch;
    if (pv) {
	newaddr = (char*)PerlMemShared_malloc(strlen(pv)+1);
    	(void)strcpy(newaddr,pv);
d819 1
a819 1
    return newaddr;
d1044 7
a1050 2
OP *
Perl_vdie(pTHX_ const char* pat, va_list *args)
a1052 11
    int was_in_eval = PL_in_eval;
    HV *stash;
    GV *gv;
    CV *cv;
    SV *msv;
    STRLEN msglen;
    I32 utf8 = 0;

    DEBUG_S(PerlIO_printf(Perl_debug_log,
			  "%p: die: curstack = %p, mainstack = %p\n",
			  thr, PL_curstack, PL_mainstack));
d1055 1
a1055 1
	msv = vmess(pat, args);
d1058 1
a1058 1
	    message = SvPV(PL_errors, msglen);
d1062 2
a1063 2
	    message = SvPV(msv,msglen);
	utf8 = SvUTF8(msv);
a1066 1
	msglen = 0;
d1070 1
a1070 1
			  "%p: die: message = %s\ndiehook = %p\n",
d1073 24
a1096 2
	/* sv_2cv might call Perl_croak() */
	SV *olddiehook = PL_diehook;
d1098 17
a1114 3
	SAVESPTR(PL_diehook);
	PL_diehook = Nullsv;
	cv = sv_2cv(olddiehook, &stash, &gv, 0);
d1116 10
a1125 3
	if (cv && !CvDEPTH(cv) && (CvROOT(cv) || CvXSUB(cv))) {
	    dSP;
	    SV *msg;
d1127 3
a1129 11
	    ENTER;
	    save_re_context();
	    if (message) {
		msg = newSVpvn(message, msglen);
		SvFLAGS(msg) |= utf8;
		SvREADONLY_on(msg);
		SAVEFREESV(msg);
	    }
	    else {
		msg = ERRSV;
	    }
d1131 1
a1131 9
	    PUSHSTACKi(PERLSI_DIEHOOK);
	    PUSHMARK(SP);
	    XPUSHs(msg);
	    PUTBACK;
	    call_sv((SV*)cv, G_DISCARD);
	    POPSTACK;
	    LEAVE;
	}
    }
a1171 4
    HV *stash;
    GV *gv;
    CV *cv;
    SV *msv;
d1175 1
a1175 30
    if (pat) {
	msv = vmess(pat, args);
	if (PL_errors && SvCUR(PL_errors)) {
	    sv_catsv(PL_errors, msv);
	    message = SvPV(PL_errors, msglen);
	    SvCUR_set(PL_errors, 0);
	}
	else
	    message = SvPV(msv,msglen);
	utf8 = SvUTF8(msv);
    }
    else {
	message = Nullch;
	msglen = 0;
    }

    DEBUG_S(PerlIO_printf(Perl_debug_log, "croak: 0x%"UVxf" %s",
			  PTR2UV(thr), message));

    if (PL_diehook) {
	/* sv_2cv might call Perl_croak() */
	SV *olddiehook = PL_diehook;
	ENTER;
	SAVESPTR(PL_diehook);
	PL_diehook = Nullsv;
	cv = sv_2cv(olddiehook, &stash, &gv, 0);
	LEAVE;
	if (cv && !CvDEPTH(cv) && (CvROOT(cv) || CvXSUB(cv))) {
	    dSP;
	    SV *msg;
a1176 21
	    ENTER;
	    save_re_context();
	    if (message) {
		msg = newSVpvn(message, msglen);
		SvFLAGS(msg) |= utf8;
		SvREADONLY_on(msg);
		SAVEFREESV(msg);
	    }
	    else {
		msg = ERRSV;
	    }

	    PUSHSTACKi(PERLSI_DIEHOOK);
	    PUSHMARK(SP);
	    XPUSHs(msg);
	    PUTBACK;
	    call_sv((SV*)cv, G_DISCARD);
	    POPSTACK;
	    LEAVE;
	}
    }
d1334 5
a1338 7
    char *message;
    HV *stash;
    GV *gv;
    CV *cv;
    SV *msv;
    STRLEN msglen;
    I32 utf8 = 0;
a1339 5
    msv = vmess(pat, args);
    message = SvPV(msv, msglen);
    utf8 = SvUTF8(msv);

    if (ckDEAD(err)) {
d1344 2
a1345 26
	    /* sv_2cv might call Perl_croak() */
	    SV *olddiehook = PL_diehook;
	    ENTER;
	    SAVESPTR(PL_diehook);
	    PL_diehook = Nullsv;
	    cv = sv_2cv(olddiehook, &stash, &gv, 0);
	    LEAVE;
	    if (cv && !CvDEPTH(cv) && (CvROOT(cv) || CvXSUB(cv))) {
		dSP;
		SV *msg;

		ENTER;
		save_re_context();
		msg = newSVpvn(message, msglen);
		SvFLAGS(msg) |= utf8;
		SvREADONLY_on(msg);
		SAVEFREESV(msg);

		PUSHSTACKi(PERLSI_DIEHOOK);
		PUSHMARK(sp);
		XPUSHs(msg);
		PUTBACK;
		call_sv((SV*)cv, G_DISCARD);
		POPSTACK;
		LEAVE;
	    }
d1356 1
a1356 30
	if (PL_warnhook) {
	    /* sv_2cv might call Perl_warn() */
	    SV *oldwarnhook = PL_warnhook;
	    ENTER;
	    SAVESPTR(PL_warnhook);
	    PL_warnhook = Nullsv;
	    cv = sv_2cv(oldwarnhook, &stash, &gv, 0);
	    LEAVE;
	    if (cv && !CvDEPTH(cv) && (CvROOT(cv) || CvXSUB(cv))) {
		dSP;
		SV *msg;

		ENTER;
		save_re_context();
		msg = newSVpvn(message, msglen);
		SvFLAGS(msg) |= utf8;
		SvREADONLY_on(msg);
		SAVEFREESV(msg);

		PUSHSTACKi(PERLSI_WARNHOOK);
		PUSHMARK(sp);
		XPUSHs(msg);
		PUTBACK;
		call_sv((SV*)cv, G_DISCARD);
		POPSTACK;
		LEAVE;
		return;
	    }
	}
	write_to_stderr(message, msglen);
d1382 1
d1423 2
a1424 2

#else   /* PERL_USE_SAFE_PUTENV */
d1439 3
a1441 1
#endif  /* PERL_USE_SAFE_PUTENV */
@


1.8
log
@merge local changes into perl-5.8.3
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, by Larry Wall and others
d75 3
a77 1
	PerlIO_puts(Perl_error_log,PL_no_mem) FLUSH;
d124 3
a126 1
	PerlIO_puts(Perl_error_log,PL_no_mem) FLUSH;
d178 3
a180 1
	PerlIO_puts(Perl_error_log,PL_no_mem) FLUSH;
d1231 3
a1233 2
Normally use this function the same way you use the C C<printf>
function.  See C<warn>.
d1318 2
a1319 3
This is the XSUB-writer's interface to Perl's C<warn> function.  Use this
function the same way you use the C C<printf> function.  See
C<croak>.
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@a20 1
#if !defined(NSIG) || defined(M_UNIX) || defined(M_XENIX)
a21 2
#endif

@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d3 2
a4 1
 *    Copyright (c) 1991-2002, Larry Wall
a41 9
#ifdef LEAKTEST

long xcount[MAXXCOUNT];
long lastxcount[MAXXCOUNT];
long xycount[MAXXCOUNT][MAXYCOUNT];
long lastxycount[MAXXCOUNT][MAXYCOUNT];

#endif

d80 1
a80 1
        return Nullch;
a183 142
#ifdef LEAKTEST

struct mem_test_strut {
    union {
	long type;
	char c[2];
    } u;
    long size;
};

#    define ALIGN sizeof(struct mem_test_strut)

#    define sizeof_chunk(ch) (((struct mem_test_strut*) (ch))->size)
#    define typeof_chunk(ch) \
	(((struct mem_test_strut*) (ch))->u.c[0] + ((struct mem_test_strut*) (ch))->u.c[1]*100)
#    define set_typeof_chunk(ch,t) \
	(((struct mem_test_strut*) (ch))->u.c[0] = t % 100, ((struct mem_test_strut*) (ch))->u.c[1] = t / 100)
#define SIZE_TO_Y(size) ( (size) > MAXY_SIZE				\
			  ? MAXYCOUNT - 1 				\
			  : ( (size) > 40 				\
			      ? ((size) - 1)/8 + 5			\
			      : ((size) - 1)/4))

Malloc_t
Perl_safexmalloc(I32 x, MEM_SIZE size)
{
    register char* where = (char*)safemalloc(size + ALIGN);

    xcount[x] += size;
    xycount[x][SIZE_TO_Y(size)]++;
    set_typeof_chunk(where, x);
    sizeof_chunk(where) = size;
    return (Malloc_t)(where + ALIGN);
}

Malloc_t
Perl_safexrealloc(Malloc_t wh, MEM_SIZE size)
{
    char *where = (char*)wh;

    if (!wh)
	return safexmalloc(0,size);

    {
	MEM_SIZE old = sizeof_chunk(where - ALIGN);
	int t = typeof_chunk(where - ALIGN);
	register char* new = (char*)saferealloc(where - ALIGN, size + ALIGN);

	xycount[t][SIZE_TO_Y(old)]--;
	xycount[t][SIZE_TO_Y(size)]++;
	xcount[t] += size - old;
	sizeof_chunk(new) = size;
	return (Malloc_t)(new + ALIGN);
    }
}

void
Perl_safexfree(Malloc_t wh)
{
    I32 x;
    char *where = (char*)wh;
    MEM_SIZE size;

    if (!where)
	return;
    where -= ALIGN;
    size = sizeof_chunk(where);
    x = where[0] + 100 * where[1];
    xcount[x] -= size;
    xycount[x][SIZE_TO_Y(size)]--;
    safefree(where);
}

Malloc_t
Perl_safexcalloc(I32 x,MEM_SIZE count, MEM_SIZE size)
{
    register char * where = (char*)safexmalloc(x, size * count + ALIGN);
    xcount[x] += size;
    xycount[x][SIZE_TO_Y(size)]++;
    memset((void*)(where + ALIGN), 0, size * count);
    set_typeof_chunk(where, x);
    sizeof_chunk(where) = size;
    return (Malloc_t)(where + ALIGN);
}

STATIC void
S_xstat(pTHX_ int flag)
{
    register I32 i, j, total = 0;
    I32 subtot[MAXYCOUNT];

    for (j = 0; j < MAXYCOUNT; j++) {
	subtot[j] = 0;
    }

    PerlIO_printf(Perl_debug_log, "   Id  subtot   4   8  12  16  20  24  28  32  36  40  48  56  64  72  80 80+\n", total);
    for (i = 0; i < MAXXCOUNT; i++) {
	total += xcount[i];
	for (j = 0; j < MAXYCOUNT; j++) {
	    subtot[j] += xycount[i][j];
	}
	if (flag == 0
	    ? xcount[i]			/* Have something */
	    : (flag == 2
	       ? xcount[i] != lastxcount[i] /* Changed */
	       : xcount[i] > lastxcount[i])) { /* Growed */
	    PerlIO_printf(Perl_debug_log,"%2d %02d %7ld ", i / 100, i % 100,
			  flag == 2 ? xcount[i] - lastxcount[i] : xcount[i]);
	    lastxcount[i] = xcount[i];
	    for (j = 0; j < MAXYCOUNT; j++) {
		if ( flag == 0
		     ? xycount[i][j]	/* Have something */
		     : (flag == 2
			? xycount[i][j] != lastxycount[i][j] /* Changed */
			: xycount[i][j] > lastxycount[i][j])) {	/* Growed */
		    PerlIO_printf(Perl_debug_log,"%3ld ",
				  flag == 2
				  ? xycount[i][j] - lastxycount[i][j]
				  : xycount[i][j]);
		    lastxycount[i][j] = xycount[i][j];
		} else {
		    PerlIO_printf(Perl_debug_log, "  . ", xycount[i][j]);
		}
	    }
	    PerlIO_printf(Perl_debug_log, "\n");
	}
    }
    if (flag != 2) {
	PerlIO_printf(Perl_debug_log, "Total %7ld ", total);
	for (j = 0; j < MAXYCOUNT; j++) {
	    if (subtot[j]) {
		PerlIO_printf(Perl_debug_log, "%3ld ", subtot[j]);
	    } else {
		PerlIO_printf(Perl_debug_log, "  . ");
	    }
	}
	PerlIO_printf(Perl_debug_log, "\n");	
    }
}

#endif /* LEAKTEST */

d361 2
a362 1
    if (flags & FBMcf_TAIL)
d364 3
d965 1
a965 1
           OutCopFILE(cop), (IV)CopLINE(cop));
d984 46
d1040 1
d1055 1
d1081 1
d1100 1
d1143 1
d1154 1
d1180 1
d1199 1
d1205 1
a1205 13
    {
#ifdef USE_SFIO
	/* SFIO can really mess with your errno */
	int e = errno;
#endif
	PerlIO *serr = Perl_error_log;

	PERL_WRITE_MSG_TO_CONSOLE(serr, message, msglen);
	(void)PerlIO_flush(serr);
#ifdef USE_SFIO
	errno = e;
#endif
    }
d1260 1
a1260 2
    IO *io;
    MAGIC *mg;
d1263 1
d1281 1
d1296 1
a1296 27
    /* if STDERR is tied, use it instead */
    if (PL_stderrgv && (io = GvIOp(PL_stderrgv))
	&& (mg = SvTIED_mg((SV*)io, PERL_MAGIC_tiedscalar))) {
	dSP; ENTER;
	PUSHMARK(SP);
	XPUSHs(SvTIED_obj((SV*)io, mg));
	XPUSHs(sv_2mortal(newSVpvn(message, msglen)));
	PUTBACK;
	call_method("PRINT", G_SCALAR);
	LEAVE;
	return;
    }

    {
	PerlIO *serr = Perl_error_log;

	PERL_WRITE_MSG_TO_CONSOLE(serr, message, msglen);
#ifdef LEAKTEST
	DEBUG_L(*message == '!'
		? (xstat(message[1]=='!'
			 ? (message[2]=='!' ? 2 : 1)
			 : 0)
		   , 0)
		: 0);
#endif
	(void)PerlIO_flush(serr);
    }
d1360 1
d1364 1
d1368 1
a1368 1
        DEBUG_S(PerlIO_printf(Perl_debug_log, "croak: 0x%"UVxf" %s", PTR2UV(thr), message));
d1370 11
a1380 11
        if (PL_diehook) {
            /* sv_2cv might call Perl_croak() */
            SV *olddiehook = PL_diehook;
            ENTER;
            SAVESPTR(PL_diehook);
            PL_diehook = Nullsv;
            cv = sv_2cv(olddiehook, &stash, &gv, 0);
            LEAVE;
            if (cv && !CvDEPTH(cv) && (CvROOT(cv) || CvXSUB(cv))) {
                dSP;
                SV *msg;
d1382 1
a1382 1
                ENTER;
d1384 4
a1387 3
                msg = newSVpvn(message, msglen);
                SvREADONLY_on(msg);
                SAVEFREESV(msg);
d1390 4
a1393 4
                PUSHMARK(sp);
                XPUSHs(msg);
                PUTBACK;
                call_sv((SV*)cv, G_DISCARD);
d1395 7
a1401 11
                LEAVE;
            }
        }
        if (PL_in_eval) {
            PL_restartop = die_where(message, msglen);
            JMPENV_JUMP(3);
        }
	{
	    PerlIO *serr = Perl_error_log;
	    PERL_WRITE_MSG_TO_CONSOLE(serr, message, msglen);
	    (void)PerlIO_flush(serr);
d1403 2
a1404 2
        my_failure_exit();

d1407 7
a1413 7
        if (PL_warnhook) {
            /* sv_2cv might call Perl_warn() */
            SV *oldwarnhook = PL_warnhook;
            ENTER;
            SAVESPTR(PL_warnhook);
            PL_warnhook = Nullsv;
            cv = sv_2cv(oldwarnhook, &stash, &gv, 0);
d1415 3
a1417 3
            if (cv && !CvDEPTH(cv) && (CvROOT(cv) || CvXSUB(cv))) {
                dSP;
                SV *msg;
d1419 1
a1419 1
                ENTER;
d1421 4
a1424 3
                msg = newSVpvn(message, msglen);
                SvREADONLY_on(msg);
                SAVEFREESV(msg);
d1427 4
a1430 4
                PUSHMARK(sp);
                XPUSHs(msg);
                PUTBACK;
                call_sv((SV*)cv, G_DISCARD);
d1432 3
a1434 16
                LEAVE;
                return;
            }
        }
	{
	    PerlIO *serr = Perl_error_log;
	    PERL_WRITE_MSG_TO_CONSOLE(serr, message, msglen);
#ifdef LEAKTEST
	    DEBUG_L(*message == '!'
		? (xstat(message[1]=='!'
			 ? (message[2]=='!' ? 2 : 1)
			 : 0)
		   , 0)
		: 0);
#endif
	    (void)PerlIO_flush(serr);
d1436 1
d1475 3
a1477 3
            int len = strlen(environ[j]);
            tmpenv[j] = (char*)safesysmalloc((len+1)*sizeof(char));
            Copy(environ[j], tmpenv[j], len+1, char);
d1510 1
a1510 1
        val = "";
d1542 1
d1560 1
d1867 1
a1867 1
	        if (fd != pp[1])
d2005 1
a2005 1
	        int fd;
d2009 1
a2009 1
		        PerlLIO_close(fd);
d2019 1
a2019 1
        SvREADONLY_off(GvSV(tmpgv));
d2021 5
a2025 2
        SvREADONLY_on(GvSV(tmpgv));
    }
d2211 5
d2231 2
a2232 3
#if defined(PERL_OLD_SIGNALS)
    act.sa_flags |= SA_RESTART;	/* SVR4, 4.3+BSD */
#endif
d2234 1
a2234 1
#ifdef SA_NOCLDWAIT
d2250 1
a2250 1
        return SIG_ERR;
d2252 1
a2252 1
        return oact.sa_handler;
d2270 2
a2271 3
#if defined(PERL_OLD_SIGNALS)
    act.sa_flags |= SA_RESTART;	/* SVR4, 4.3+BSD */
#endif
d2273 1
a2273 1
#ifdef SA_NOCLDWAIT
d2331 1
a2331 1
        PerlProc_kill(PerlProc_getpid(), signo);
d2433 3
a2435 3
    SV *sv;
    SV** svp;
    char spid[TYPE_CHARS(int)];
d2437 8
a2444 7
    if (pid > 0) {
	sprintf(spid, "%"IVdf, (IV)pid);
	svp = hv_fetch(PL_pidstatus,spid,strlen(spid),FALSE);
	if (svp && *svp != &PL_sv_undef) {
	    *statusp = SvIVX(*svp);
	    (void)hv_delete(PL_pidstatus,spid,strlen(spid),G_DISCARD);
	    return pid;
d2446 2
a2447 3
    }
    else {
	HE *entry;
d2449 12
a2460 11
	hv_iterinit(PL_pidstatus);
	if ((entry = hv_iternext(PL_pidstatus))) {
	    SV *sv;
	    char spid[TYPE_CHARS(int)];

	    pid = atoi(hv_iterkey(entry,(I32*)statusp));
	    sv = hv_iterval(PL_pidstatus,entry);
	    *statusp = SvIVX(sv);
	    sprintf(spid, "%"IVdf, (IV)pid);
	    (void)hv_delete(PL_pidstatus,spid,strlen(spid),G_DISCARD);
	    return pid;
a2461 1
        }
d2803 1
a2803 1
		xfound = tmpbuf;              /* bingo! */
d2817 1
a2817 1
	        Perl_croak(aTHX_ "Can't %s %s%s%s",
d3098 1
a3098 1
    PL_curpm = t->Tcurpm;         /* XXX No PMOP ref count */
d3110 4
d3298 3
d3308 1
a3308 1
#if defined(FFLUSH_NULL)
d3349 1
a3349 1
    SETERRNO(EBADF,RMS$_IFI);
a3357 2
    char *vile;
    I32   warn_type;
d3363 3
a3365 3
    char *type = OP_IS_SOCKET(op) ||
                 (gv && io && IoTYPE(io) == IoTYPE_SOCKET) ?
                     "socket" : "filehandle";
a3367 9
    if (gv && io && IoTYPE(io) == IoTYPE_CLOSED) {
	vile = "closed";
	warn_type = WARN_CLOSED;
    }
    else {
	vile = "unopened";
	warn_type = WARN_UNOPENED;
    }

d3373 10
a3382 14
	if (name && *name)
	    Perl_warner(aTHX_ packWARN(WARN_IO), "Filehandle %s opened only for %sput",
			name,
			(op == OP_phoney_INPUT_ONLY ? "in" : "out"));
	else
	    Perl_warner(aTHX_ packWARN(WARN_IO), "Filehandle opened only for %sput",
			(op == OP_phoney_INPUT_ONLY ? "in" : "out"));
    } else if (name && *name) {
	Perl_warner(aTHX_ packWARN(warn_type),
		    "%s%s on %s %s %s", func, pars, vile, type, name);
	if (io && IoDIRP(io) && !(IoFLAGS(io) & IOf_FAKE_DIRP))
	    Perl_warner(aTHX_ packWARN(warn_type),
			"\t(Are you trying to call %s%s on dirhandle %s?)\n",
			func, pars, name);
d3385 29
a3413 4
	Perl_warner(aTHX_ packWARN(warn_type),
		    "%s%s on %s %s", func, pars, vile, type);
	if (gv && io && IoDIRP(io) && !(IoFLAGS(io) & IOf_FAKE_DIRP))
	    Perl_warner(aTHX_ packWARN(warn_type),
d3415 4
a3418 1
			func, pars);
d3429 2
a3430 2
    	if (ch > 'a') {
	        char *ctlp;
d3432 2
a3433 2
 	       if (islower(ch))
  	              ch = toupper(ch);
d3435 2
a3436 23
 	       if ((ctlp = strchr(controllablechars, ch)) == 0) {
  	              Perl_die(aTHX_ "unrecognised control character '%c'\n", ch);
     	       }

        	if (ctlp == controllablechars)
         	       return('\177'); /* DEL */
        	else
         	       return((unsigned char)(ctlp - controllablechars - 1));
	} else { /* Want uncontrol */
        	if (ch == '\177' || ch == -1)
                	return('?');
        	else if (ch == '\157')
                	return('\177');
        	else if (ch == '\174')
                	return('\000');
        	else if (ch == '^')    /* '\137' in 1047, '\260' in 819 */
                	return('\036');
        	else if (ch == '\155')
                	return('\037');
        	else if (0 < ch && ch < (sizeof(controllablechars) - 1))
                	return(controllablechars[ch+1]);
        	else
                	Perl_die(aTHX_ "invalid control request: '\\%03o'\n", ch & 0xFF);
d3438 21
d3711 14
d3777 1
a3777 1
        (dp->d_name[1] == '.' && dp->d_name[2] == '\0')))
d3810 1
a3810 1
        /* Some getcwd()s automatically allocate a buffer of the given
d3813 9
a3821 9
        if (getcwd(buf, sizeof(buf) - 1)) {
            STRLEN len = strlen(buf);
            sv_setpvn(sv, buf, len);
            return TRUE;
        }
        else {
            sv_setsv(sv, &PL_sv_undef);
            return FALSE;
        }
d3835 1
a3835 1
        SV_CWD_RETURN_UNDEF;
d3844 2
a3845 2
        odev = cdev;
        oino = cino;
d3847 9
a3855 16
        if (PerlDir_chdir("..") < 0) {
            SV_CWD_RETURN_UNDEF;
        }
        if (PerlLIO_stat(".", &statbuf) < 0) {
            SV_CWD_RETURN_UNDEF;
        }

        cdev = statbuf.st_dev;
        cino = statbuf.st_ino;

        if (odev == cdev && oino == cino) {
            break;
        }
        if (!(dir = PerlDir_open("."))) {
            SV_CWD_RETURN_UNDEF;
        }
d3857 8
a3864 1
        while ((dp = PerlDir_read(dir)) != NULL) {
d3866 1
a3866 1
            namelen = dp->d_namlen;
d3868 1
a3868 1
            namelen = strlen(dp->d_name);
d3870 35
a3904 35
            /* skip . and .. */
            if (SV_CWD_ISDOT(dp)) {
                continue;
            }

            if (PerlLIO_lstat(dp->d_name, &statbuf) < 0) {
                SV_CWD_RETURN_UNDEF;
            }

            tdev = statbuf.st_dev;
            tino = statbuf.st_ino;
            if (tino == oino && tdev == odev) {
                break;
            }
        }

        if (!dp) {
            SV_CWD_RETURN_UNDEF;
        }

        if (pathlen + namelen + 1 >= MAXPATHLEN) {
            SV_CWD_RETURN_UNDEF;
	}

        SvGROW(sv, pathlen + namelen + 1);

        if (pathlen) {
            /* shift down */
            Move(SvPVX(sv), SvPVX(sv) + namelen + 1, pathlen, char);
        }

        /* prepend current directory to the front */
        *SvPVX(sv) = '/';
        Move(dp->d_name, SvPVX(sv)+1, namelen, char);
        pathlen += (namelen + 1);
d3907 1
a3907 1
        PerlDir_close(dir);
d3909 3
a3911 3
        if (PerlDir_close(dir) < 0) {
            SV_CWD_RETURN_UNDEF;
        }
d3916 3
a3918 3
        SvCUR_set(sv, pathlen);
        *SvEND(sv) = '\0';
        SvPOK_only(sv);
d3921 2
a3922 2
            SV_CWD_RETURN_UNDEF;
        }
d3925 1
a3925 1
        SV_CWD_RETURN_UNDEF;
d3932 2
a3933 2
        Perl_croak(aTHX_ "Unstable directory path, "
                   "current directory changed unexpectedly");
a3943 78
/*
=head1 SV Manipulation Functions

=for apidoc new_vstring

Returns a pointer to the next character after the parsed
vstring, as well as updating the passed in sv.

Function must be called like

        sv = NEWSV(92,5);
	s = new_vstring(s,sv);

The sv must already be large enough to store the vstring
passed in.

=cut
*/

char *
Perl_new_vstring(pTHX_ char *s, SV *sv)
{
    char *pos = s;
    if (*pos == 'v') pos++;  /* get past 'v' */
    while (isDIGIT(*pos) || *pos == '_')
    pos++;
    if (!isALPHA(*pos)) {
	UV rev;
	U8 tmpbuf[UTF8_MAXLEN+1];
	U8 *tmpend;

	if (*s == 'v') s++;  /* get past 'v' */

	sv_setpvn(sv, "", 0);

	for (;;) {
	    rev = 0;
	    {
		 /* this is atoi() that tolerates underscores */
		 char *end = pos;
		 UV mult = 1;
		 if ( s > pos && *(s-1) == '_') {
		      mult = 10;
		 }
		 while (--end >= s) {
		      UV orev;
		      orev = rev;
		      rev += (*end - '0') * mult;
		      mult *= 10;
		      if (orev > rev && ckWARN_d(WARN_OVERFLOW))
			   Perl_warner(aTHX_ packWARN(WARN_OVERFLOW),
				       "Integer overflow in decimal number");
		 }
	    }
#ifdef EBCDIC
	    if (rev > 0x7FFFFFFF)
		 Perl_croak(aTHX "In EBCDIC the v-string components cannot exceed 2147483647");
#endif
	    /* Append native character for the rev point */
	    tmpend = uvchr_to_utf8(tmpbuf, rev);
	    sv_catpvn(sv, (const char*)tmpbuf, tmpend - tmpbuf);
	    if (!UNI_IS_INVARIANT(NATIVE_TO_UNI(rev)))
		 SvUTF8_on(sv);
	    if ( (*pos == '.' || *pos == '_') && isDIGIT(pos[1]))
		 s = ++pos;
	    else {
		 s = pos;
		 break;
	    }
	    while (isDIGIT(*pos) )
		 pos++;
	}
	SvPOK_on(sv);
	SvREADONLY_on(sv);
    }
    return s;
}

d3956 1
a3956 1
    Sock_size_t size = sizeof (struct sockaddr_in);
d3960 1
a3960 1
    memset (&addresses, 0, sizeof (addresses));
d3963 10
a3972 11
        sockets[i] = PerlSock_socket (AF_INET, SOCK_DGRAM, PF_INET);
        if (sockets[i] == -1)
            goto tidy_up_and_fail;

        addresses[i].sin_family = AF_INET;
        addresses[i].sin_addr.s_addr = htonl (INADDR_LOOPBACK);
        addresses[i].sin_port = 0;	/* kernel choses port.  */
        if (PerlSock_bind (sockets[i], (struct sockaddr *) &addresses[i],
                  sizeof (struct sockaddr_in))
            == -1)
            goto tidy_up_and_fail;
d3979 9
a3987 9
        if (PerlSock_getsockname (sockets[i], (struct sockaddr *) &addresses[i], &size)
            == -1)
            goto tidy_up_and_fail;
        if (size != sizeof (struct sockaddr_in))
            goto abort_tidy_up_and_fail;
        /* !1 is 0, !0 is 1 */
        if (PerlSock_connect(sockets[!i], (struct sockaddr *) &addresses[i],
                    sizeof (struct sockaddr_in)) == -1)
            goto tidy_up_and_fail;
d3995 10
a4004 10
        /* I'm going to send my own port number.  As a short.
           (Who knows if someone somewhere has sin_port as a bitfield and needs
           this routine. (I'm assuming crays have socketpair)) */
        port = addresses[i].sin_port;
        got = PerlLIO_write (sockets[i], &port, sizeof(port));
        if (got != sizeof(port)) {
            if (got == -1)
                goto tidy_up_and_fail;
            goto abort_tidy_up_and_fail;
        }
d4018 16
a4033 16
        struct timeval waitfor = {0, 100000}; /* You have 0.1 seconds */
        int max = sockets[1] > sockets[0] ? sockets[1] : sockets[0];
        fd_set rset;

        FD_ZERO (&rset);
        FD_SET (sockets[0], &rset);
        FD_SET (sockets[1], &rset);

        got = PerlSock_select (max + 1, &rset, NULL, NULL, &waitfor);
        if (got != 2 || !FD_ISSET (sockets[0], &rset)
            || !FD_ISSET (sockets[1], &rset)) {
             /* I hope this is portable and appropriate.  */
            if (got == -1)
                goto tidy_up_and_fail;
            goto abort_tidy_up_and_fail;
        }
d4039 2
a4040 2
        struct sockaddr_in readfrom;
        unsigned short buffer[2];
d4042 2
a4043 2
        i = 1;
        do {
d4045 3
a4047 3
            got = PerlSock_recvfrom (sockets[i], (char *) &buffer, sizeof(buffer),
                            MSG_DONTWAIT,
                            (struct sockaddr *) &readfrom, &size);
d4049 17
a4065 17
            got = PerlSock_recvfrom (sockets[i], (char *) &buffer, sizeof(buffer),
                            0,
                            (struct sockaddr *) &readfrom, &size);
#endif

            if (got == -1)
                    goto tidy_up_and_fail;
            if (got != sizeof(port)
                || size != sizeof (struct sockaddr_in)
                /* Check other socket sent us its port.  */
                || buffer[0] != (unsigned short) addresses[!i].sin_port
                /* Check kernel says we got the datagram from that socket.  */
                || readfrom.sin_family != addresses[!i].sin_family
                || readfrom.sin_addr.s_addr != addresses[!i].sin_addr.s_addr
                || readfrom.sin_port != addresses[!i].sin_port)
                goto abort_tidy_up_and_fail;
        } while (i--);
d4078 7
a4084 7
        int save_errno = errno;
        if (sockets[0] != -1)
            PerlLIO_close (sockets[0]);
        if (sockets[1] != -1)
            PerlLIO_close (sockets[1]);
        errno = save_errno;
        return -1;
d4106 3
a4108 3
	) {
        errno = EAFNOSUPPORT;
        return -1;
d4111 2
a4112 2
        errno = EINVAL;
        return -1;
d4117 1
a4117 1
        return S_socketpair_udp (fd);
d4120 1
a4120 1
    listener = PerlSock_socket (AF_INET, type, 0);
d4122 2
a4123 2
        return -1;
    memset (&listen_addr, 0, sizeof (listen_addr));
d4125 1
a4125 1
    listen_addr.sin_addr.s_addr = htonl (INADDR_LOOPBACK);
d4127 3
a4129 3
    if (PerlSock_bind (listener, (struct sockaddr *) &listen_addr, sizeof (listen_addr))
        == -1)
        goto tidy_up_and_fail;
d4131 1
a4131 1
        goto tidy_up_and_fail;
d4133 1
a4133 1
    connector = PerlSock_socket (AF_INET, type, 0);
d4135 1
a4135 1
        goto tidy_up_and_fail;
d4137 6
a4142 5
    size = sizeof (connect_addr);
    if (PerlSock_getsockname (listener, (struct sockaddr *) &connect_addr, &size) == -1)
        goto tidy_up_and_fail;
    if (size != sizeof (connect_addr))
        goto abort_tidy_up_and_fail;
d4144 2
a4145 2
                sizeof (connect_addr)) == -1)
        goto tidy_up_and_fail;
d4147 3
a4149 2
    size = sizeof (listen_addr);
    acceptor = PerlSock_accept (listener, (struct sockaddr *) &listen_addr, &size);
d4151 4
a4154 4
        goto tidy_up_and_fail;
    if (size != sizeof (listen_addr))
        goto abort_tidy_up_and_fail;
    PerlLIO_close (listener);
d4157 8
a4164 7
    if (PerlSock_getsockname (connector, (struct sockaddr *) &connect_addr, &size) == -1)
        goto tidy_up_and_fail;
    if (size != sizeof (connect_addr)
        || listen_addr.sin_family != connect_addr.sin_family
        || listen_addr.sin_addr.s_addr != connect_addr.sin_addr.s_addr
        || listen_addr.sin_port != connect_addr.sin_port) {
        goto abort_tidy_up_and_fail;
d4174 9
a4182 9
        int save_errno = errno;
        if (listener != -1)
            PerlLIO_close (listener);
        if (connector != -1)
            PerlLIO_close (connector);
        if (acceptor != -1)
            PerlLIO_close (acceptor);
        errno = save_errno;
        return -1;
d4245 171
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2001, Larry Wall
d19 1
a26 10

#ifdef I_VFORK
#  include <vfork.h>
#endif

/* Put this after #includes because fork and vfork prototypes may
   conflict.
*/
#ifndef HAS_VFORK
#   define vfork fork
d33 4
a36 2
#ifdef I_LOCALE
#  include <locale.h>
a53 2
/* paranoid version of system's malloc() */

d60 2
d78 1
a78 1
    ptr = PerlMem_malloc(size?size:1);	/* malloc(0) is NASTY on our system */
d104 1
a104 1
#ifdef HAS_64K_LIMIT 
d122 1
a122 1
    ptr = PerlMem_realloc(where,size);
d124 1
a124 1
 
d175 1
a175 1
    ptr = PerlMem_malloc(size?size:1);	/* malloc(0) is NASTY on our system */
d234 1
a234 1
    
d239 1
a239 1
    
d254 1
a254 1
    
d286 1
a286 1
    
d295 1
a295 1
	    : (flag == 2 
d298 1
a298 1
	    PerlIO_printf(Perl_debug_log,"%2d %02d %7ld ", i / 100, i % 100, 
d302 1
a302 1
		if ( flag == 0 
d304 1
a304 1
		     : (flag == 2 
d307 3
a309 3
		    PerlIO_printf(Perl_debug_log,"%3ld ", 
				  flag == 2 
				  ? xycount[i][j] - lastxycount[i][j] 
d334 31
a481 522
/*
 * Set up for a new ctype locale.
 */
void
Perl_new_ctype(pTHX_ char *newctype)
{
#ifdef USE_LOCALE_CTYPE

    int i;

    for (i = 0; i < 256; i++) {
	if (isUPPER_LC(i))
	    PL_fold_locale[i] = toLOWER_LC(i);
	else if (isLOWER_LC(i))
	    PL_fold_locale[i] = toUPPER_LC(i);
	else
	    PL_fold_locale[i] = i;
    }

#endif /* USE_LOCALE_CTYPE */
}

/*
 * Standardize the locale name from a string returned by 'setlocale'.
 *
 * The standard return value of setlocale() is either
 * (1) "xx_YY" if the first argument of setlocale() is not LC_ALL
 * (2) "xa_YY xb_YY ..." if the first argument of setlocale() is LC_ALL
 *     (the space-separated values represent the various sublocales,
 *      in some unspecificed order)
 *
 * In some platforms it has a form like "LC_SOMETHING=Lang_Country.866\n",
 * which is harmful for further use of the string in setlocale().
 *
 */
STATIC char *
S_stdize_locale(pTHX_ char *locs)
{
    char *s;
    bool okay = TRUE;

    if ((s = strchr(locs, '='))) {
	char *t;

	okay = FALSE;
	if ((t = strchr(s, '.'))) {
	    char *u;

	    if ((u = strchr(t, '\n'))) {

		if (u[1] == 0) {
		    STRLEN len = u - s;
		    Move(s + 1, locs, len, char);
		    locs[len] = 0;
		    okay = TRUE;
		}
	    }
	}
    }

    if (!okay)
	Perl_croak(aTHX_ "Can't fix broken locale name \"%s\"", locs);

    return locs;
}

/*
 * Set up for a new collation locale.
 */
void
Perl_new_collate(pTHX_ char *newcoll)
{
#ifdef USE_LOCALE_COLLATE

    if (! newcoll) {
	if (PL_collation_name) {
	    ++PL_collation_ix;
	    Safefree(PL_collation_name);
	    PL_collation_name = NULL;
	}
	PL_collation_standard = TRUE;
	PL_collxfrm_base = 0;
	PL_collxfrm_mult = 2;
	return;
    }

    if (! PL_collation_name || strNE(PL_collation_name, newcoll)) {
	++PL_collation_ix;
	Safefree(PL_collation_name);
	PL_collation_name = stdize_locale(savepv(newcoll));
	PL_collation_standard = (strEQ(newcoll, "C") || strEQ(newcoll, "POSIX"));

	{
	  /*  2: at most so many chars ('a', 'b'). */
	  /* 50: surely no system expands a char more. */
#define XFRMBUFSIZE  (2 * 50)
	  char xbuf[XFRMBUFSIZE];
	  Size_t fa = strxfrm(xbuf, "a",  XFRMBUFSIZE);
	  Size_t fb = strxfrm(xbuf, "ab", XFRMBUFSIZE);
	  SSize_t mult = fb - fa;
	  if (mult < 1)
	      Perl_croak(aTHX_ "strxfrm() gets absurd");
	  PL_collxfrm_base = (fa > mult) ? (fa - mult) : 0;
	  PL_collxfrm_mult = mult;
	}
    }

#endif /* USE_LOCALE_COLLATE */
}

void
Perl_set_numeric_radix(pTHX)
{
#ifdef USE_LOCALE_NUMERIC
# ifdef HAS_LOCALECONV
    struct lconv* lc;

    lc = localeconv();
    if (lc && lc->decimal_point) {
	if (lc->decimal_point[0] == '.' && lc->decimal_point[1] == 0) {
	    SvREFCNT_dec(PL_numeric_radix_sv);
	    PL_numeric_radix_sv = 0;
	}
	else {
	    if (PL_numeric_radix_sv)
		sv_setpv(PL_numeric_radix_sv, lc->decimal_point);
	    else
		PL_numeric_radix_sv = newSVpv(lc->decimal_point, 0);
	}
    }
    else
	PL_numeric_radix_sv = 0;
# endif /* HAS_LOCALECONV */
#endif /* USE_LOCALE_NUMERIC */
}

/*
 * Set up for a new numeric locale.
 */
void
Perl_new_numeric(pTHX_ char *newnum)
{
#ifdef USE_LOCALE_NUMERIC

    if (! newnum) {
	if (PL_numeric_name) {
	    Safefree(PL_numeric_name);
	    PL_numeric_name = NULL;
	}
	PL_numeric_standard = TRUE;
	PL_numeric_local = TRUE;
	return;
    }

    if (! PL_numeric_name || strNE(PL_numeric_name, newnum)) {
	Safefree(PL_numeric_name);
	PL_numeric_name = stdize_locale(savepv(newnum));
	PL_numeric_standard = (strEQ(newnum, "C") || strEQ(newnum, "POSIX"));
	PL_numeric_local = TRUE;
	set_numeric_radix();
    }

#endif /* USE_LOCALE_NUMERIC */
}

void
Perl_set_numeric_standard(pTHX)
{
#ifdef USE_LOCALE_NUMERIC

    if (! PL_numeric_standard) {
	setlocale(LC_NUMERIC, "C");
	PL_numeric_standard = TRUE;
	PL_numeric_local = FALSE;
	set_numeric_radix();
    }

#endif /* USE_LOCALE_NUMERIC */
}

void
Perl_set_numeric_local(pTHX)
{
#ifdef USE_LOCALE_NUMERIC

    if (! PL_numeric_local) {
	setlocale(LC_NUMERIC, PL_numeric_name);
	PL_numeric_standard = FALSE;
	PL_numeric_local = TRUE;
	set_numeric_radix();
    }

#endif /* USE_LOCALE_NUMERIC */
}

/*
 * Initialize locale awareness.
 */
int
Perl_init_i18nl10n(pTHX_ int printwarn)
{
    int ok = 1;
    /* returns
     *    1 = set ok or not applicable,
     *    0 = fallback to C locale,
     *   -1 = fallback to C locale failed
     */

#if defined(USE_LOCALE)

#ifdef USE_LOCALE_CTYPE
    char *curctype   = NULL;
#endif /* USE_LOCALE_CTYPE */
#ifdef USE_LOCALE_COLLATE
    char *curcoll    = NULL;
#endif /* USE_LOCALE_COLLATE */
#ifdef USE_LOCALE_NUMERIC
    char *curnum     = NULL;
#endif /* USE_LOCALE_NUMERIC */
#ifdef __GLIBC__
    char *language   = PerlEnv_getenv("LANGUAGE");
#endif
    char *lc_all     = PerlEnv_getenv("LC_ALL");
    char *lang       = PerlEnv_getenv("LANG");
    bool setlocale_failure = FALSE;

#ifdef LOCALE_ENVIRON_REQUIRED

    /*
     * Ultrix setlocale(..., "") fails if there are no environment
     * variables from which to get a locale name.
     */

    bool done = FALSE;

#ifdef LC_ALL
    if (lang) {
	if (setlocale(LC_ALL, ""))
	    done = TRUE;
	else
	    setlocale_failure = TRUE;
    }
    if (!setlocale_failure) {
#ifdef USE_LOCALE_CTYPE
	if (! (curctype =
	       setlocale(LC_CTYPE,
			 (!done && (lang || PerlEnv_getenv("LC_CTYPE")))
				    ? "" : Nullch)))
	    setlocale_failure = TRUE;
	else
	    curctype = savepv(curctype);
#endif /* USE_LOCALE_CTYPE */
#ifdef USE_LOCALE_COLLATE
	if (! (curcoll =
	       setlocale(LC_COLLATE,
			 (!done && (lang || PerlEnv_getenv("LC_COLLATE")))
				   ? "" : Nullch)))
	    setlocale_failure = TRUE;
	else
	    curcoll = savepv(curcoll);
#endif /* USE_LOCALE_COLLATE */
#ifdef USE_LOCALE_NUMERIC
	if (! (curnum =
	       setlocale(LC_NUMERIC,
			 (!done && (lang || PerlEnv_getenv("LC_NUMERIC")))
				  ? "" : Nullch)))
	    setlocale_failure = TRUE;
	else
	    curnum = savepv(curnum);
#endif /* USE_LOCALE_NUMERIC */
    }

#endif /* LC_ALL */

#endif /* !LOCALE_ENVIRON_REQUIRED */

#ifdef LC_ALL
    if (! setlocale(LC_ALL, ""))
	setlocale_failure = TRUE;
#endif /* LC_ALL */

    if (!setlocale_failure) {
#ifdef USE_LOCALE_CTYPE
	if (! (curctype = setlocale(LC_CTYPE, "")))
	    setlocale_failure = TRUE;
	else
	    curctype = savepv(curctype);
#endif /* USE_LOCALE_CTYPE */
#ifdef USE_LOCALE_COLLATE
	if (! (curcoll = setlocale(LC_COLLATE, "")))
	    setlocale_failure = TRUE;
	else
	    curcoll = savepv(curcoll);
#endif /* USE_LOCALE_COLLATE */
#ifdef USE_LOCALE_NUMERIC
	if (! (curnum = setlocale(LC_NUMERIC, "")))
	    setlocale_failure = TRUE;
	else
	    curnum = savepv(curnum);
#endif /* USE_LOCALE_NUMERIC */
    }

    if (setlocale_failure) {
	char *p;
	bool locwarn = (printwarn > 1 || 
			(printwarn &&
			 (!(p = PerlEnv_getenv("PERL_BADLANG")) || atoi(p))));

	if (locwarn) {
#ifdef LC_ALL
  
	    PerlIO_printf(Perl_error_log,
	       "perl: warning: Setting locale failed.\n");

#else /* !LC_ALL */
  
	    PerlIO_printf(Perl_error_log,
	       "perl: warning: Setting locale failed for the categories:\n\t");
#ifdef USE_LOCALE_CTYPE
	    if (! curctype)
		PerlIO_printf(Perl_error_log, "LC_CTYPE ");
#endif /* USE_LOCALE_CTYPE */
#ifdef USE_LOCALE_COLLATE
	    if (! curcoll)
		PerlIO_printf(Perl_error_log, "LC_COLLATE ");
#endif /* USE_LOCALE_COLLATE */
#ifdef USE_LOCALE_NUMERIC
	    if (! curnum)
		PerlIO_printf(Perl_error_log, "LC_NUMERIC ");
#endif /* USE_LOCALE_NUMERIC */
	    PerlIO_printf(Perl_error_log, "\n");

#endif /* LC_ALL */

	    PerlIO_printf(Perl_error_log,
		"perl: warning: Please check that your locale settings:\n");

#ifdef __GLIBC__
	    PerlIO_printf(Perl_error_log,
			  "\tLANGUAGE = %c%s%c,\n",
			  language ? '"' : '(',
			  language ? language : "unset",
			  language ? '"' : ')');
#endif

	    PerlIO_printf(Perl_error_log,
			  "\tLC_ALL = %c%s%c,\n",
			  lc_all ? '"' : '(',
			  lc_all ? lc_all : "unset",
			  lc_all ? '"' : ')');

#if defined(USE_ENVIRON_ARRAY)
	    {
	      char **e;
	      for (e = environ; *e; e++) {
		  if (strnEQ(*e, "LC_", 3)
			&& strnNE(*e, "LC_ALL=", 7)
			&& (p = strchr(*e, '=')))
		      PerlIO_printf(Perl_error_log, "\t%.*s = \"%s\",\n",
				    (int)(p - *e), *e, p + 1);
	      }
	    }
#else
	    PerlIO_printf(Perl_error_log,
			  "\t(possibly more locale environment variables)\n");
#endif

	    PerlIO_printf(Perl_error_log,
			  "\tLANG = %c%s%c\n",
			  lang ? '"' : '(',
			  lang ? lang : "unset",
			  lang ? '"' : ')');

	    PerlIO_printf(Perl_error_log,
			  "    are supported and installed on your system.\n");
	}

#ifdef LC_ALL

	if (setlocale(LC_ALL, "C")) {
	    if (locwarn)
		PerlIO_printf(Perl_error_log,
      "perl: warning: Falling back to the standard locale (\"C\").\n");
	    ok = 0;
	}
	else {
	    if (locwarn)
		PerlIO_printf(Perl_error_log,
      "perl: warning: Failed to fall back to the standard locale (\"C\").\n");
	    ok = -1;
	}

#else /* ! LC_ALL */

	if (0
#ifdef USE_LOCALE_CTYPE
	    || !(curctype || setlocale(LC_CTYPE, "C"))
#endif /* USE_LOCALE_CTYPE */
#ifdef USE_LOCALE_COLLATE
	    || !(curcoll || setlocale(LC_COLLATE, "C"))
#endif /* USE_LOCALE_COLLATE */
#ifdef USE_LOCALE_NUMERIC
	    || !(curnum || setlocale(LC_NUMERIC, "C"))
#endif /* USE_LOCALE_NUMERIC */
	    )
	{
	    if (locwarn)
		PerlIO_printf(Perl_error_log,
      "perl: warning: Cannot fall back to the standard locale (\"C\").\n");
	    ok = -1;
	}

#endif /* ! LC_ALL */

#ifdef USE_LOCALE_CTYPE
	curctype = savepv(setlocale(LC_CTYPE, Nullch));
#endif /* USE_LOCALE_CTYPE */
#ifdef USE_LOCALE_COLLATE
	curcoll = savepv(setlocale(LC_COLLATE, Nullch));
#endif /* USE_LOCALE_COLLATE */
#ifdef USE_LOCALE_NUMERIC
	curnum = savepv(setlocale(LC_NUMERIC, Nullch));
#endif /* USE_LOCALE_NUMERIC */
    }
    else {

#ifdef USE_LOCALE_CTYPE
    new_ctype(curctype);
#endif /* USE_LOCALE_CTYPE */

#ifdef USE_LOCALE_COLLATE
    new_collate(curcoll);
#endif /* USE_LOCALE_COLLATE */

#ifdef USE_LOCALE_NUMERIC
    new_numeric(curnum);
#endif /* USE_LOCALE_NUMERIC */
    }

#endif /* USE_LOCALE */

#ifdef USE_LOCALE_CTYPE
    if (curctype != NULL)
	Safefree(curctype);
#endif /* USE_LOCALE_CTYPE */
#ifdef USE_LOCALE_COLLATE
    if (curcoll != NULL)
	Safefree(curcoll);
#endif /* USE_LOCALE_COLLATE */
#ifdef USE_LOCALE_NUMERIC
    if (curnum != NULL)
	Safefree(curnum);
#endif /* USE_LOCALE_NUMERIC */
    return ok;
}

/* Backwards compatibility. */
int
Perl_init_i18nl14n(pTHX_ int printwarn)
{
    return init_i18nl10n(printwarn);
}

#ifdef USE_LOCALE_COLLATE

/*
 * mem_collxfrm() is a bit like strxfrm() but with two important
 * differences. First, it handles embedded NULs. Second, it allocates
 * a bit more memory than needed for the transformed data itself.
 * The real transformed data begins at offset sizeof(collationix).
 * Please see sv_collxfrm() to see how this is used.
 */
char *
Perl_mem_collxfrm(pTHX_ const char *s, STRLEN len, STRLEN *xlen)
{
    char *xbuf;
    STRLEN xAlloc, xin, xout; /* xalloc is a reserved word in VC */

    /* the first sizeof(collationix) bytes are used by sv_collxfrm(). */
    /* the +1 is for the terminating NUL. */

    xAlloc = sizeof(PL_collation_ix) + PL_collxfrm_base + (PL_collxfrm_mult * len) + 1;
    New(171, xbuf, xAlloc, char);
    if (! xbuf)
	goto bad;

    *(U32*)xbuf = PL_collation_ix;
    xout = sizeof(PL_collation_ix);
    for (xin = 0; xin < len; ) {
	SSize_t xused;

	for (;;) {
	    xused = strxfrm(xbuf + xout, s + xin, xAlloc - xout);
	    if (xused == -1)
		goto bad;
	    if (xused < xAlloc - xout)
		break;
	    xAlloc = (2 * xAlloc) + 1;
	    Renew(xbuf, xAlloc, char);
	    if (! xbuf)
		goto bad;
	}

	xin += strlen(s + xin) + 1;
	xout += xused;

	/* Embedded NULs are understood but silently skipped
	 * because they make no sense in locale collation. */
    }

    xbuf[xout] = '\0';
    *xlen = xout - sizeof(PL_collation_ix);
    return xbuf;

  bad:
    Safefree(xbuf);
    *xlen = 0;
    return NULL;
}

#endif /* USE_LOCALE_COLLATE */

d491 2
d515 1
a515 1
    if (len == 0)		/* TAIL might be on on a zero-length string. */
d538 1
a538 1
    sv_magic(sv, Nullsv, 'B', Nullch, 0);	/* deep magic */
d549 1
a549 1
    BmPREVIOUS(sv) = rarest;
d581 6
a586 5
    if (bigend - big < littlelen) {
	if ( SvTAIL(littlestr) 
	     && (bigend - big == littlelen - 1)
	     && (littlelen == 1 
		 || (*big == *little && memEQ(big, little, littlelen - 1))))
d676 1
a676 1
	if (s >= big && bigend[-1] == '\n' && *s == *little 
d705 1
a705 1
    
d710 1
a710 1
	if (littlelen > bigend - big)
a722 7
#ifdef POINTERRIGOR
		if (bigend - s > tmp) {
		    s += tmp;
		    goto top2;
		}
		s += tmp;
#else
a724 1
#endif
d746 2
a747 1
	     && memEQ(bigend - littlelen, oldlittle - littlelen, littlelen) )
d755 1
a755 1
   If `last' we want the last occurence.
d757 1
a757 1
   the next call needs to find the . 
d765 1
a765 1
   if PL_multiline.  In fact if !PL_multiline the autoritative answer
d785 1
a785 1
	if ( BmRARE(littlestr) == '\n' 
d804 5
d811 1
a817 19
#ifdef POINTERRIGOR
    do {
	if (pos >= stop_pos) break;
	if (big[pos-previous] != first)
	    continue;
	for (x=big+pos+1-previous,s=little; s < littleend; /**/ ) {
	    if (*s++ != *x++) {
		s--;
		break;
	    }
	}
	if (s == littleend) {
	    *old_posp = pos;
	    if (!last) return (char *)(big+pos-previous);
	    found = 1;
	}
    } while ( pos += PL_screamnext[pos] );
    return (last && found) ? (char *)(big+(*old_posp)-previous) : Nullch;
#else /* !POINTERRIGOR */
d835 1
a835 1
    if (last && found) 
a836 1
#endif /* POINTERRIGOR */
d847 2
a848 1
	&& ((stop_pos == 1) || memEQ(big + 1, little, stop_pos - 1)))
d882 2
d886 4
a889 1
Copy a string to a safe spot.  This does not use an SV.
d895 1
a895 1
Perl_savepv(pTHX_ const char *sv)
d897 5
a901 4
    register char *newaddr;

    New(902,newaddr,strlen(sv)+1,char);
    (void)strcpy(newaddr,sv);
d910 4
a913 2
Copy a string to a safe spot.  The C<len> indicates number of bytes to
copy.  This does not use an SV.
d919 1
a919 1
Perl_savepvn(pTHX_ const char *sv, register I32 len)
d924 27
a950 2
    Copy(sv,newaddr,len,char);		/* might not be null terminated */
    newaddr[len] = '\0';		/* is now */
d954 2
d994 20
d1058 31
d1094 1
d1098 12
a1109 1
	if (CopLINE(PL_curcop))
d1111 1
a1111 1
			   CopFILE(PL_curcop), (IV)CopLINE(PL_curcop));
d1116 4
a1119 3
		      PL_last_in_gv == PL_argvgv ? "" : GvNAME(PL_last_in_gv),
		      line_mode ? "line" : "chunk", 
		      (IV)IoLINES(GvIOp(PL_last_in_gv)));
d1121 1
a1121 1
#ifdef USE_THREADS
d1294 3
d1304 1
a1304 1
	PerlIO_write(serr, message, msglen);
d1327 2
d1364 2
d1398 14
d1415 1
a1415 1
	PerlIO_write(serr, message, msglen);
d1417 1
a1417 1
	DEBUG_L(*message == '!' 
d1494 1
a1494 1
#ifdef USE_THREADS
d1496 1
a1496 1
#endif /* USE_THREADS */
d1508 1
a1508 1
 
d1514 1
a1514 1
 
d1530 1
a1530 1
	    PerlIO_write(serr, message, msglen);
d1548 1
a1548 1
 
d1554 1
a1554 1
 
d1567 1
a1567 1
	    PerlIO_write(serr, message, msglen);
d1569 1
a1569 1
	    DEBUG_L(*message == '!' 
d1581 10
d1592 2
a1593 2
       /* VMS' and EPOC's my_setenv() is in vms.c and epoc.c */
#if !defined(WIN32)
d1597 5
d1605 1
d1616 3
a1618 2
	    tmpenv[j] = (char*)safesysmalloc((strlen(environ[j])+1)*sizeof(char));
	    strcpy(tmpenv[j], environ[j]);
d1637 2
a1638 1
    environ[i] = (char*)safesysmalloc((strlen(nam)+strlen(val)+2) * sizeof(char));
d1640 3
a1642 1
    (void)sprintf(environ[i],"%s=%s",nam,val);/* all that work just for this */
d1645 1
a1645 1
#   if defined(__CYGWIN__)
d1649 8
a1656 3

    new_env = (char*)safesysmalloc((strlen(nam) + strlen(val) + 2) * sizeof(char));
    (void)sprintf(new_env,"%s=%s",nam,val);/* all that work just for this */
d1660 1
d1663 1
a1663 1
#else /* WIN32 */
d1669 2
a1670 1
    STRLEN len = strlen(nam) + 3;
d1674 3
a1676 3
    len += strlen(val);
    New(904, envstr, len, char);
    (void)sprintf(envstr,"%s=%s",nam,val);
d1681 1
a1681 1
#endif /* WIN32 */
d1715 1
a1715 1
#if !defined(HAS_BCOPY) || !defined(HAS_SAFE_BCOPY)
d1939 132
d2089 1
a2089 1
#endif 
d2100 1
a2100 1
    while ((pid = (doexec?vfork():fork())) < 0) {
d2103 1
a2120 1
	PerlLIO_close(p[THAT]);
d2130 2
d2133 2
d2143 7
a2149 3
	    for (fd = PL_maxsysfd + 1; fd < NOFILE; fd++)
		if (fd != pp[1])
		    PerlLIO_close(fd);
d2151 2
a2152 1
	    do_exec3(cmd,pp[1],did_pipes);	/* may or may not use the shell */
d2157 2
a2158 1
	if ((tmpgv = gv_fetchpv("$",TRUE, SVt_PV)))
d2160 2
a2168 1
    PerlLIO_close(p[that]);
d2176 3
d2200 2
d2204 3
d2216 1
a2216 1
#if defined(atarist) || defined(DJGPP)
a2220 2
    /* Needs work for PerlIO ! */
    /* used 0 for 2nd parameter to PerlIO-exportFILE; apparently not used */
d2222 18
a2239 1
    return popen(PerlIO_exportFILE(cmd, 0), mode);
d2242 1
d2246 48
d2299 1
a2299 1
    struct stat tmpstatbuf;
d2344 1
a2344 1

d2352 6
d2362 1
d2365 1
d2392 6
d2402 1
d2405 1
d2416 6
d2430 6
d2439 2
a2440 1
static int sig_trapped;
d2454 6
d2471 5
d2483 5
d2492 1
d2505 1
a2505 1
    int saved_errno;
d2516 1
a2516 1
    pid = SvIVX(*svp);
d2523 1
a2523 1
#endif 
d2536 1
d2540 1
d2544 1
d2548 1
d2557 1
a2557 1
#if  (!defined(DOSISH) || defined(OS2) || defined(WIN32)) && !defined(MACOS_TRADITIONAL)
d2561 5
a2569 3
    if (!pid)
	return -1;
#if !defined(HAS_WAITPID) && !defined(HAS_WAIT4) || defined(HAS_WAITPID_RUNTIME)
d2584 3
d2594 1
d2602 2
a2603 1
    return PerlProc_waitpid(pid,statusp,flags);
d2606 2
a2607 1
    return wait4((pid==-1)?0:pid,statusp,flags,Null(struct rusage *));
a2611 1
	I32 result;
a2619 1
	return result;
d2622 5
d2628 1
a2628 1
#endif /* !DOSISH || OS2 || WIN32 */
d2644 1
a2644 1
#if defined(atarist) || defined(OS2) || defined(DJGPP)
d2653 1
a2653 1
#endif 
d2658 5
d2664 7
a2671 1
#endif
a2696 79
U32
Perl_cast_ulong(pTHX_ NV f)
{
    long along;

#if CASTFLAGS & 2
#   define BIGDOUBLE 2147483648.0
    if (f >= BIGDOUBLE)
	return (unsigned long)(f-(long)(f/BIGDOUBLE)*BIGDOUBLE)|0x80000000;
#endif
    if (f >= 0.0)
	return (unsigned long)f;
    along = (long)f;
    return (unsigned long)along;
}
# undef BIGDOUBLE

/* Unfortunately, on some systems the cast_uv() function doesn't
   work with the system-supplied definition of ULONG_MAX.  The
   comparison  (f >= ULONG_MAX) always comes out true.  It must be a
   problem with the compiler constant folding.

   In any case, this workaround should be fine on any two's complement
   system.  If it's not, supply a '-DMY_ULONG_MAX=whatever' in your
   ccflags.
	       --Andy Dougherty      <doughera@@lafcol.lafayette.edu>
*/

/* Code modified to prefer proper named type ranges, I32, IV, or UV, instead
   of LONG_(MIN/MAX).
                           -- Kenneth Albanowski <kjahds@@kjahds.com>
*/                                      

#ifndef MY_UV_MAX
#  define MY_UV_MAX ((UV)IV_MAX * (UV)2 + (UV)1)
#endif

I32
Perl_cast_i32(pTHX_ NV f)
{
    if (f >= I32_MAX)
	return (I32) I32_MAX;
    if (f <= I32_MIN)
	return (I32) I32_MIN;
    return (I32) f;
}

IV
Perl_cast_iv(pTHX_ NV f)
{
    if (f >= IV_MAX) {
	UV uv;
	
	if (f >= (NV)UV_MAX)
	    return (IV) UV_MAX;	
	uv = (UV) f;
	return (IV)uv;
    }
    if (f <= IV_MIN)
	return (IV) IV_MIN;
    return (IV) f;
}

UV
Perl_cast_uv(pTHX_ NV f)
{
    if (f >= MY_UV_MAX)
	return (UV) MY_UV_MAX;
    if (f < 0) {
	IV iv;
	
	if (f < IV_MIN)
	    return (UV)IV_MIN;
	iv = (IV) f;
	return (UV) iv;
    }
    return (UV) f;
}

d2703 2
a2704 2
    struct stat tmpstatbuf1;
    struct stat tmpstatbuf2;
d2734 2
a2735 2
NV
Perl_scan_bin(pTHX_ char *start, STRLEN len, STRLEN *retlen)
d2737 5
a2741 210
    register char *s = start;
    register NV rnv = 0.0;
    register UV ruv = 0;
    register bool seenb = FALSE;
    register bool overflowed = FALSE;

    for (; len-- && *s; s++) {
	if (!(*s == '0' || *s == '1')) {
	    if (*s == '_' && len && *retlen
		&& (s[1] == '0' || s[1] == '1'))
	    {
		--len;
		++s;
	    }
	    else if (seenb == FALSE && *s == 'b' && ruv == 0) {
		/* Disallow 0bbb0b0bbb... */
		seenb = TRUE;
		continue;
	    }
	    else {
		if (ckWARN(WARN_DIGIT))
		    Perl_warner(aTHX_ WARN_DIGIT,
				"Illegal binary digit '%c' ignored", *s);
		break;
	    }
	}
	if (!overflowed) {
	    register UV xuv = ruv << 1;

	    if ((xuv >> 1) != ruv) {
		overflowed = TRUE;
		rnv = (NV) ruv;
		if (ckWARN_d(WARN_OVERFLOW))
		    Perl_warner(aTHX_ WARN_OVERFLOW,
				"Integer overflow in binary number");
	    }
	    else
		ruv = xuv | (*s - '0');
	}
	if (overflowed) {
	    rnv *= 2;
	    /* If an NV has not enough bits in its mantissa to
	     * represent an UV this summing of small low-order numbers
	     * is a waste of time (because the NV cannot preserve
	     * the low-order bits anyway): we could just remember when
	     * did we overflow and in the end just multiply rnv by the
	     * right amount. */
	    rnv += (*s - '0');
	}
    }
    if (!overflowed)
	rnv = (NV) ruv;
    if (   ( overflowed && rnv > 4294967295.0)
#if UVSIZE > 4
	|| (!overflowed && ruv > 0xffffffff  )
#endif
	) { 
	if (ckWARN(WARN_PORTABLE))
	    Perl_warner(aTHX_ WARN_PORTABLE,
			"Binary number > 0b11111111111111111111111111111111 non-portable");
    }
    *retlen = s - start;
    return rnv;
}

NV
Perl_scan_oct(pTHX_ char *start, STRLEN len, STRLEN *retlen)
{
    register char *s = start;
    register NV rnv = 0.0;
    register UV ruv = 0;
    register bool overflowed = FALSE;

    for (; len-- && *s; s++) {
	if (!(*s >= '0' && *s <= '7')) {
	    if (*s == '_' && len && *retlen
		&& (s[1] >= '0' && s[1] <= '7'))
	    {
		--len;
		++s;
	    }
	    else {
		/* Allow \octal to work the DWIM way (that is, stop scanning
		 * as soon as non-octal characters are seen, complain only iff
		 * someone seems to want to use the digits eight and nine). */
		if (*s == '8' || *s == '9') {
		    if (ckWARN(WARN_DIGIT))
			Perl_warner(aTHX_ WARN_DIGIT,
				    "Illegal octal digit '%c' ignored", *s);
		}
		break;
	    }
	}
	if (!overflowed) {
	    register UV xuv = ruv << 3;

	    if ((xuv >> 3) != ruv) {
		overflowed = TRUE;
		rnv = (NV) ruv;
		if (ckWARN_d(WARN_OVERFLOW))
		    Perl_warner(aTHX_ WARN_OVERFLOW,
				"Integer overflow in octal number");
	    }
	    else
		ruv = xuv | (*s - '0');
	}
	if (overflowed) {
	    rnv *= 8.0;
	    /* If an NV has not enough bits in its mantissa to
	     * represent an UV this summing of small low-order numbers
	     * is a waste of time (because the NV cannot preserve
	     * the low-order bits anyway): we could just remember when
	     * did we overflow and in the end just multiply rnv by the
	     * right amount of 8-tuples. */
	    rnv += (NV)(*s - '0');
	}
    }
    if (!overflowed)
	rnv = (NV) ruv;
    if (   ( overflowed && rnv > 4294967295.0)
#if UVSIZE > 4
	|| (!overflowed && ruv > 0xffffffff  )
#endif
	) {
	if (ckWARN(WARN_PORTABLE))
	    Perl_warner(aTHX_ WARN_PORTABLE,
			"Octal number > 037777777777 non-portable");
    }
    *retlen = s - start;
    return rnv;
}

NV
Perl_scan_hex(pTHX_ char *start, STRLEN len, STRLEN *retlen)
{
    register char *s = start;
    register NV rnv = 0.0;
    register UV ruv = 0;
    register bool seenx = FALSE;
    register bool overflowed = FALSE;
    char *hexdigit;

    for (; len-- && *s; s++) {
	hexdigit = strchr((char *) PL_hexdigit, *s);
	if (!hexdigit) {
	    if (*s == '_' && len && *retlen && s[1]
		&& (hexdigit = strchr((char *) PL_hexdigit, s[1])))
	    {
		--len;
		++s;
	    }
	    else if (seenx == FALSE && *s == 'x' && ruv == 0) {
		/* Disallow 0xxx0x0xxx... */
		seenx = TRUE;
		continue;
	    }
	    else {
		if (ckWARN(WARN_DIGIT))
		    Perl_warner(aTHX_ WARN_DIGIT,
				"Illegal hexadecimal digit '%c' ignored", *s);
		break;
	    }
	}
	if (!overflowed) {
	    register UV xuv = ruv << 4;

	    if ((xuv >> 4) != ruv) {
		overflowed = TRUE;
		rnv = (NV) ruv;
		if (ckWARN_d(WARN_OVERFLOW))
		    Perl_warner(aTHX_ WARN_OVERFLOW,
				"Integer overflow in hexadecimal number");
	    }
	    else
		ruv = xuv | ((hexdigit - PL_hexdigit) & 15);
	}
	if (overflowed) {
	    rnv *= 16.0;
	    /* If an NV has not enough bits in its mantissa to
	     * represent an UV this summing of small low-order numbers
	     * is a waste of time (because the NV cannot preserve
	     * the low-order bits anyway): we could just remember when
	     * did we overflow and in the end just multiply rnv by the
	     * right amount of 16-tuples. */
	    rnv += (NV)((hexdigit - PL_hexdigit) & 15);
	}
    }
    if (!overflowed)
	rnv = (NV) ruv;
    if (   ( overflowed && rnv > 4294967295.0)
#if UVSIZE > 4
	|| (!overflowed && ruv > 0xffffffff  )
#endif
	) { 
	if (ckWARN(WARN_PORTABLE))
	    Perl_warner(aTHX_ WARN_PORTABLE,
			"Hexadecimal number > 0xffffffff non-portable");
    }
    *retlen = s - start;
    return rnv;
}

char*
Perl_find_script(pTHX_ char *scriptname, bool dosearch, char **search_ext, I32 flags)
{
    char *xfound = Nullch;
    char *xfailed = Nullch;
    char tmpbuf[MAXPATHLEN];
    register char *s;
    I32 len;
d2944 1
a2944 1
	    (PerlLIO_stat(scriptname,&PL_statbuf) < 0 
d2970 1
a2970 1
#if defined(USE_THREADS) || defined(USE_ITHREADS)
d2977 1
a2977 1
#  ifdef I_MACH_CTHREADS
d2979 3
a2981 3
#  else
    return (void*)pthread_getspecific(PL_thr_key);
#  endif
d2991 1
a2991 1
#if defined(USE_THREADS) || defined(USE_ITHREADS)
d3003 1
a3003 1
#ifdef USE_THREADS
d3024 1
a3024 1
    
d3044 1
a3044 1
    
d3067 1
a3067 1
    
d3083 3
a3085 3
    
    SvUPGRADE(sv, SVt_PVMG);
    mg = mg_find(sv, 'm');
d3095 1
a3095 1
	mg = mg_find(sv, 'm');
d3105 1
a3105 1
	    sv_magic(sv, Nullsv, 'm', 0, 0);
d3111 1
a3111 1
					   "%p: condpair_magic %p\n", thr, sv));)
d3138 1
a3138 1
			      PTR2UV(thr), PTR2UV(sv));)
d3168 1
a3168 1
    memset(thr, 0xab, sizeof(struct perl_thread));
d3192 1
d3217 2
d3232 1
a3232 2
    PL_nrs = newSVsv(t->Tnrs);
    PL_rs = t->Tnrs ? SvREFCNT_inc(PL_nrs) : Nullsv;
d3234 1
a3234 2
    PL_ofslen = t->Tofslen;
    PL_ofs = savepvn(t->Tofs, PL_ofslen);
d3250 1
a3250 1
	    sv_magic(sv, 0, 0, &PL_threadsv_names[i], 1);
d3255 1
a3255 1
    } 
d3275 1
a3275 17
#endif /* USE_THREADS */

#if defined(HUGE_VAL) || (defined(USE_LONG_DOUBLE) && defined(HUGE_VALL))
/*
 * This hack is to force load of "huge" support from libm.a
 * So it is in perl for (say) POSIX to use. 
 * Needed for SunOS with Sun's 'acc' for example.
 */
NV 
Perl_huge(void)
{
#   if defined(USE_LONG_DOUBLE) && defined(HUGE_VALL)
    return HUGE_VALL;
#   endif
    return HUGE_VAL;
}
#endif
d3312 1
a3312 1
 return &PL_ppaddr;
d3396 1
a3396 1
#ifdef USE_THREADS
a3430 10
#if !defined(FFLUSH_NULL) && defined(HAS__FWALK)
static int S_fflush(FILE *fp);

static int
S_fflush(FILE *fp)
{
    return fflush(fp);
}
#endif

d3438 1
d3441 1
a3441 1
    _fwalk(&S_fflush);
d3443 2
a3444 1
#   else
a3445 1
#  if defined(FFLUSH_ALL) && defined(HAS_STDIO_STREAM_ARRAY)
d3449 1
a3449 1
#   if defined(HAS_SYSCONF) && defined(_SC_OPEN_MAX)
d3451 2
a3452 2
#   else
#    ifdef FOPEN_MAX
d3454 2
a3455 2
#    else
#     ifdef OPEN_MAX
d3457 2
a3458 2
#     else
#      ifdef _NFILE
d3460 2
a3464 2
#   endif
#   endif
a3480 23
NV
Perl_my_atof(pTHX_ const char* s)
{
    NV x = 0.0;
#ifdef USE_LOCALE_NUMERIC
    if ((PL_hints & HINT_LOCALE) && PL_numeric_local) {
	NV y;

	Perl_atof2(s, x);
	SET_NUMERIC_STANDARD();
	Perl_atof2(s, y);
	SET_NUMERIC_LOCAL();
	if ((y < 0.0 && y < x) || (y > 0.0 && y > x))
	    return y;
    }
    else
	Perl_atof2(s, x);
#else
    Perl_atof2(s, x);
#endif
    return x;
}

d3491 2
a3492 1
    char *type = OP_IS_SOCKET(op) || (io && IoTYPE(io) == IoTYPE_SOCKET) ?
d3496 1
a3496 1
    if (io && IoTYPE(io) == IoTYPE_CLOSED) {
d3506 1
a3506 3
	SV *sv = sv_newmortal();
	gv_efullname4(sv, gv, Nullch, FALSE);
	name = SvPVX(sv);
d3509 10
a3518 2
    if (name && *name) {
	Perl_warner(aTHX_ warn_type,
d3521 1
a3521 1
	    Perl_warner(aTHX_ warn_type,
d3526 1
a3526 1
	Perl_warner(aTHX_ warn_type,
d3528 2
a3529 2
	if (io && IoDIRP(io) && !(IoFLAGS(io) & IOf_FAKE_DIRP))
	    Perl_warner(aTHX_ warn_type,
d3544 1
a3544 1
 
d3547 1
a3547 1
 
d3551 1
a3551 1
 
d3574 846
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2000, Larry Wall
a26 5
/* XXX If this causes problems, set i_unistd=undef in the hint file.  */
#ifdef I_UNISTD
#  include <unistd.h>
#endif

d462 1
a462 1
Perl_new_ctype(pTHX_ const char *newctype)
d481 44
d528 1
a528 1
Perl_new_collate(pTHX_ const char *newcoll)
a536 3
	    PL_collation_standard = TRUE;
	    PL_collxfrm_base = 0;
	    PL_collxfrm_mult = 2;
d538 3
d547 1
a547 1
	PL_collation_name = savepv(newcoll);
d576 12
a587 5
    if (lc && lc->decimal_point)
	/* We assume that decimal separator aka the radix
	 * character is always a single character.  If it
	 * ever is a string, this needs to be rethunk. */
	PL_numeric_radix = *lc->decimal_point;
d589 1
a589 1
	PL_numeric_radix = 0;
d598 1
a598 1
Perl_new_numeric(pTHX_ const char *newnum)
a605 2
	    PL_numeric_standard = TRUE;
	    PL_numeric_local = TRUE;
d607 2
d614 1
a614 1
	PL_numeric_name = savepv(newnum);
d632 1
d666 1
a666 1
#ifdef USE_LOCALE
d707 2
d716 2
d725 2
d743 2
d749 2
d755 2
d809 1
d820 4
d873 1
a873 1
	curctype = setlocale(LC_CTYPE, Nullch);
d876 1
a876 1
	curcoll = setlocale(LC_COLLATE, Nullch);
d879 1
a879 1
	curnum = setlocale(LC_NUMERIC, Nullch);
d882 1
d895 1
d899 12
a1272 1
    dTHR;
a1440 1
    dTHR;
a1525 1
	dTHR;
a1548 1
    dTHR;
a1648 1
    dTHR;
d1656 13
a1668 5
    msv = vmess(pat, args);
    if (PL_errors && SvCUR(PL_errors)) {
	sv_catsv(PL_errors, msv);
	message = SvPV(PL_errors, msglen);
	SvCUR_set(PL_errors, 0);
a1669 2
    else
	message = SvPV(msv,msglen);
d1688 8
a1695 3
	    msg = newSVpvn(message, msglen);
	    SvREADONLY_on(msg);
	    SAVEFREESV(msg);
d1742 10
a1751 3
This is the XSUB-writer's interface to Perl's C<die> function.  Use this
function the same way you use the C C<printf> function.  See
C<warn>.
a1780 1
	dTHR;
a1877 1
    dTHR;
a1933 1
            dTHR;
d1964 6
a1969 1
	    DEBUG_L(xstat());
d1976 3
a1978 2
#ifndef VMS  /* VMS' my_setenv() is in VMS.c */
#if !defined(WIN32) && !defined(__CYGWIN__)
d2020 3
d2028 1
d2032 1
a2032 36
#else /* WIN32 || __CYGWIN__ */
#if defined(__CYGWIN__)
/*
 * Save environ of perl.exe, currently Cygwin links in separate environ's
 * for each exe/dll.  Probably should be a member of impure_ptr.
 */
static char ***Perl_main_environ;

EXTERN_C void
Perl_my_setenv_init(char ***penviron)
{
    Perl_main_environ = penviron;
}

void
Perl_my_setenv(pTHX_ char *nam, char *val)
{
    /* You can not directly manipulate the environ[] array because
     * the routines do some additional work that syncs the Cygwin
     * environment with the Windows environment.
     */
    char *oldstr = environ[setenv_getix(nam)];

    if (!val) {
       if (!oldstr)
           return;
       unsetenv(nam);
       safesysfree(oldstr);
       return;
    }
    setenv(nam, val, 1);
    environ = *Perl_main_environ; /* environ realloc can occur in setenv */
    if(oldstr && environ[setenv_getix(nam)] != oldstr)
       safesysfree(oldstr);
}
#else /* if WIN32 */
a2036 41

#ifdef USE_WIN32_RTL_ENV

    register char *envstr;
    STRLEN namlen = strlen(nam);
    STRLEN vallen;
    char *oldstr = environ[setenv_getix(nam)];

    /* putenv() has totally broken semantics in both the Borland
     * and Microsoft CRTLs.  They either store the passed pointer in
     * the environment without making a copy, or make a copy and don't
     * free it. And on top of that, they dont free() old entries that
     * are being replaced/deleted.  This means the caller must
     * free any old entries somehow, or we end up with a memory
     * leak every time my_setenv() is called.  One might think
     * one could directly manipulate environ[], like the UNIX code
     * above, but direct changes to environ are not allowed when
     * calling putenv(), since the RTLs maintain an internal
     * *copy* of environ[]. Bad, bad, *bad* stink.
     * GSAR 97-06-07
     */

    if (!val) {
	if (!oldstr)
	    return;
	val = "";
	vallen = 0;
    }
    else
	vallen = strlen(val);
    envstr = (char*)safesysmalloc((namlen + vallen + 3) * sizeof(char));
    (void)sprintf(envstr,"%s=%s",nam,val);
    (void)PerlEnv_putenv(envstr);
    if (oldstr)
	safesysfree(oldstr);
#ifdef _MSC_VER
    safesysfree(envstr);	/* MSVCRT leaks without this */
#endif

#else /* !USE_WIN32_RTL_ENV */

a2046 2

#endif
a2049 1
#endif
d2069 1
a2069 1
#endif /* !VMS */
d2323 1
a2323 1
	return my_syspopen(cmd,mode);
d2401 1
d2403 1
d2620 1
d2622 1
d2670 1
d2693 1
d2895 1
a2895 1
Perl_scan_bin(pTHX_ char *start, I32 len, I32 *retlen)
d2905 7
a2911 3
	    if (*s == '_')
		continue; /* Note: does not check for __ and the like. */
	    if (seenb == FALSE && *s == 'b' && ruv == 0) {
a2916 1
		dTHR;
a2926 1
		dTHR;
d2932 2
a2933 1
	    } else
a2953 1
	dTHR;
d2963 1
a2963 1
Perl_scan_oct(pTHX_ char *start, I32 len, I32 *retlen)
d2972 6
a2977 2
	    if (*s == '_')
		continue; /* Note: does not check for __ and the like. */
a2982 1
		    dTHR;
a2993 1
		dTHR;
d2999 2
a3000 1
	    } else
a3020 1
	dTHR;
d3030 1
a3030 1
Perl_scan_hex(pTHX_ char *start, I32 len, I32 *retlen)
d3042 7
a3048 3
	    if (*s == '_')
		continue; /* Note: does not check for __ and the like. */
	    if (seenx == FALSE && *s == 'x' && ruv == 0) {
a3053 1
		dTHR;
a3063 1
		dTHR;
d3069 2
a3070 1
	    } else
a3090 1
	dTHR;
a3101 1
    dTHR;
d3482 29
d3541 2
d3561 1
a3561 1
    PL_in_eval = EVAL_NULL;	/* ~(EVAL_INEVAL|EVAL_WARNONLY|EVAL_KEEPERR) */
d3595 1
a3595 1
    PL_rs = SvREFCNT_inc(PL_nrs);
d3641 1
a3641 1
#ifdef HUGE_VAL
d3650 4
a3653 1
 return HUGE_VAL;
d3697 1
a3697 1
Perl_getenv_len(pTHX_ char *env_elem, unsigned long *len)
d3811 10
d3824 1
a3824 1
#ifdef FFLUSH_NULL
d3827 6
d3834 2
a3835 2
# if defined(FFLUSH_ALL) && defined(HAS_STDIO_STREAM_ARRAY)
#  ifdef PERL_FFLUSH_ALL_FOPEN_MAX
d3837 2
a3838 2
#  else
#  if defined(HAS_SYSCONF) && defined(_SC_OPEN_MAX)
d3840 2
a3841 2
#  else
#   ifdef FOPEN_MAX
d3843 2
a3844 2
#   else
#    ifdef OPEN_MAX
d3846 2
a3847 2
#    else
#     ifdef _NFILE
d3849 1
d3853 1
a3853 2
#  endif
#  endif
d3863 1
a3863 1
# endif
d3866 1
d3873 1
d3876 1
a3876 1
	NV x, y;
d3878 1
a3878 1
	x = Perl_atof(s);
d3880 1
a3880 1
	y = Perl_atof(s);
a3883 1
	return x;
d3886 1
a3886 1
	return Perl_atof(s);
d3888 1
a3888 1
    return Perl_atof(s);
d3890 1
d3894 1
a3894 1
Perl_report_closed_fh(pTHX_ GV *gv, IO *io, const char *func, const char *obj)
d3896 10
a3905 2
    SV *sv;
    char *name;
d3907 8
a3914 1
    assert(gv);
d3916 23
a3938 3
    sv = sv_newmortal();
    gv_efullname3(sv, gv, Nullch);
    name = SvPVX(sv);
d3940 3
a3942 1
    Perl_warner(aTHX_ WARN_CLOSED, "%s() on closed %s %s", func, obj, name);
d3944 33
a3976 4
    if (io && IoDIRP(io))
	Perl_warner(aTHX_ WARN_CLOSED,
		    "\t(Are you trying to call %s() on dirhandle %s?)\n",
		    func, name);
d3978 1
@


1.3
log
@perl5.005_03 (stock)
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1999, Larry Wall
d16 1
d43 2
a44 5
#ifdef I_FCNTL
#  include <fcntl.h>
#endif
#ifdef I_SYS_FILE
#  include <sys/file.h>
d47 2
a48 2
#ifdef I_SYS_WAIT
#  include <sys/wait.h>
a54 1
static void xstat _((int));
d62 3
a64 1
#ifndef MYMALLOC
d66 1
a66 1
/* paranoid version of malloc */
d75 1
a75 1
safemalloc(MEM_SIZE size)
d77 1
d81 3
a83 2
		PerlIO_printf(PerlIO_stderr(), "Allocation too large: %lx\n", size) FLUSH;
		my_exit(1);
d88 1
a88 1
	croak("panic: malloc");
d91 2
a92 5
#if !(defined(I286) || defined(atarist))
    DEBUG_m(PerlIO_printf(Perl_debug_log, "0x%x: (%05d) malloc %ld bytes\n",ptr,PL_an++,(long)size));
#else
    DEBUG_m(PerlIO_printf(Perl_debug_log, "0x%lx: (%05d) malloc %ld bytes\n",ptr,PL_an++,(long)size));
#endif
d98 1
a98 1
	PerlIO_puts(PerlIO_stderr(),no_mem) FLUSH;
d105 1
a105 1
/* paranoid version of realloc */
d108 1
a108 1
saferealloc(Malloc_t where,MEM_SIZE size)
d110 1
d112 1
a112 1
#if !defined(STANDARD_C) && !defined(HAS_REALLOC_PROTOTYPE)
d118 1
a118 1
	PerlIO_printf(PerlIO_stderr(),
d124 1
a124 1
	safefree(where);
d129 1
a129 1
	return safemalloc(size);
d132 1
a132 1
	croak("panic: realloc");
d135 4
a138 12

#if !(defined(I286) || defined(atarist))
    DEBUG_m( {
	PerlIO_printf(Perl_debug_log, "0x%x: (%05d) rfree\n",where,PL_an++);
	PerlIO_printf(Perl_debug_log, "0x%x: (%05d) realloc %ld bytes\n",ptr,PL_an++,(long)size);
    } )
#else
    DEBUG_m( {
	PerlIO_printf(Perl_debug_log, "0x%lx: (%05d) rfree\n",where,PL_an++);
	PerlIO_printf(Perl_debug_log, "0x%lx: (%05d) realloc %ld bytes\n",ptr,PL_an++,(long)size);
    } )
#endif
d145 1
a145 1
	PerlIO_puts(PerlIO_stderr(),no_mem) FLUSH;
d152 1
a152 1
/* safe version of free */
d155 1
a155 1
safefree(Malloc_t where)
d157 2
a158 4
#if !(defined(I286) || defined(atarist))
    DEBUG_m( PerlIO_printf(Perl_debug_log, "0x%x: (%05d) free\n",(char *) where,PL_an++));
#else
    DEBUG_m( PerlIO_printf(Perl_debug_log, "0x%lx: (%05d) free\n",(char *) where,PL_an++));
d160 1
d167 1
a167 1
/* safe version of calloc */
d170 1
a170 1
safecalloc(MEM_SIZE count, MEM_SIZE size)
d172 1
d177 1
a177 1
	PerlIO_printf(PerlIO_stderr(),
d184 1
a184 1
	croak("panic: calloc");
d188 2
a189 5
#if !(defined(I286) || defined(atarist))
    DEBUG_m(PerlIO_printf(Perl_debug_log, "0x%x: (%05d) calloc %ld  x %ld bytes\n",ptr,PL_an++,(long)count,(long)size));
#else
    DEBUG_m(PerlIO_printf(Perl_debug_log, "0x%lx: (%05d) calloc %ld x %ld bytes\n",ptr,PL_an++,(long)count,(long)size));
#endif
d197 1
a197 1
	PerlIO_puts(PerlIO_stderr(),no_mem) FLUSH;
a203 2
#endif /* !MYMALLOC */

d228 1
a228 1
safexmalloc(I32 x, MEM_SIZE size)
d240 1
a240 1
safexrealloc(Malloc_t wh, MEM_SIZE size)
d261 1
a261 1
safexfree(Malloc_t wh)
d278 1
a278 1
safexcalloc(I32 x,MEM_SIZE count, MEM_SIZE size)
d289 2
a290 2
static void
xstat(int flag)
d299 1
a299 1
    PerlIO_printf(PerlIO_stderr(), "   Id  subtot   4   8  12  16  20  24  28  32  36  40  48  56  64  72  80 80+\n", total);
d310 1
a310 1
	    PerlIO_printf(PerlIO_stderr(),"%2d %02d %7ld ", i / 100, i % 100, 
d319 1
a319 1
		    PerlIO_printf(PerlIO_stderr(),"%3ld ", 
d325 1
a325 1
		    PerlIO_printf(PerlIO_stderr(), "  . ", xycount[i][j]);
d328 1
a328 1
	    PerlIO_printf(PerlIO_stderr(), "\n");
d332 1
a332 1
	PerlIO_printf(PerlIO_stderr(), "Total %7ld ", total);
d335 1
a335 1
		PerlIO_printf(PerlIO_stderr(), "%3ld ", subtot[j]);
d337 1
a337 1
		PerlIO_printf(PerlIO_stderr(), "  . ");
d340 1
a340 1
	PerlIO_printf(PerlIO_stderr(), "\n");	
d349 1
a349 1
delimcpy(register char *to, register char *toend, register char *from, register char *fromend, register int delim, I32 *retlen)
d378 1
a378 1
instr(register char *big, register char *little)
d380 1
a380 1
    register char *s, *x;
d384 1
a384 1
	return big;
d387 1
a387 1
	return big;
d400 1
a400 1
	    return big-1;
d408 1
a408 1
ninstr(register char *big, register char *bigend, char *little, char *lend)
d410 1
a410 1
    register char *s, *x;
d412 1
a412 1
    register char *littleend = lend;
d415 1
a415 1
	return big;
d429 1
a429 1
	    return big-1;
d437 1
a437 1
rninstr(register char *big, char *bigend, char *little, char *lend)
d439 2
a440 2
    register char *bigbeg;
    register char *s, *x;
d442 1
a442 1
    register char *littleend = lend;
d445 1
a445 1
	return bigend;
d458 1
a458 1
	    return big+1;
d467 1
a467 1
perl_new_ctype(char *newctype)
d475 1
a475 1
	    fold_locale[i] = toLOWER_LC(i);
d477 1
a477 1
	    fold_locale[i] = toUPPER_LC(i);
d479 1
a479 1
	    fold_locale[i] = i;
d489 1
a489 1
perl_new_collate(char *newcoll)
d520 1
a520 1
	      croak("strxfrm() gets absurd");
d529 19
d552 1
a552 1
perl_new_numeric(char *newnum)
d571 1
d578 1
a578 1
perl_set_numeric_standard(void)
d592 1
a592 1
perl_set_numeric_local(void)
d600 1
a605 1

d610 1
a610 1
perl_init_i18nl10n(int printwarn)
d704 2
a705 2
			printwarn &&
			(!(p = PerlEnv_getenv("PERL_BADLANG")) || atoi(p)));
d710 1
a710 1
	    PerlIO_printf(PerlIO_stderr(),
d715 1
a715 1
	    PerlIO_printf(PerlIO_stderr(),
d719 1
a719 1
		PerlIO_printf(PerlIO_stderr(), "LC_CTYPE ");
d723 1
a723 1
		PerlIO_printf(PerlIO_stderr(), "LC_COLLATE ");
d727 1
a727 1
		PerlIO_printf(PerlIO_stderr(), "LC_NUMERIC ");
d729 1
a729 1
	    PerlIO_printf(PerlIO_stderr(), "\n");
d733 1
a733 1
	    PerlIO_printf(PerlIO_stderr(),
d737 1
a737 1
	    PerlIO_printf(PerlIO_stderr(),
d744 1
a744 1
	    PerlIO_printf(PerlIO_stderr(),
d756 1
a756 1
		      PerlIO_printf(PerlIO_stderr(), "\t%.*s = \"%s\",\n",
d761 1
a761 1
	    PerlIO_printf(PerlIO_stderr(),
d767 1
a767 1
	    PerlIO_printf(PerlIO_stderr(),
d775 1
a775 1
		PerlIO_printf(PerlIO_stderr(),
d781 1
a781 1
		PerlIO_printf(PerlIO_stderr(),
d801 1
a801 1
		PerlIO_printf(PerlIO_stderr(),
d820 1
a820 1
    perl_new_ctype(curctype);
d824 1
a824 1
    perl_new_collate(curcoll);
d828 1
a828 1
    perl_new_numeric(curnum);
d838 1
a838 1
perl_init_i18nl14n(int printwarn)
d840 1
a840 1
    return perl_init_i18nl10n(printwarn);
d853 1
a853 1
mem_collxfrm(const char *s, STRLEN len, STRLEN *xlen)
d902 17
d920 1
a920 1
fbm_compile(SV *sv, U32 flags /* not used yet */)
d929 2
d933 2
a934 2
    if (len > 255 || len == 0)	/* TAIL might be on on a zero-length string. */
	return;			/* can't have offsets that big */
d936 18
a953 5
	Sv_Grow(sv,len + 258);
	table = (unsigned char*)(SvPVX(sv) + len + 1);
	s = table - 2;
	for (i = 0; i < 256; i++) {
	    table[i] = len;
a954 7
	i = 0;
	while (s >= (unsigned char*)(SvPVX(sv)))
	    {
		if (table[*s] == len)
		    table[*s] = i;
		s--,i++;
	    }
d961 1
a961 1
	if (freq[s[i]] < frequency) {
d963 1
a963 1
	    frequency = freq[s[i]];
d968 5
a972 1
    DEBUG_r(PerlIO_printf(Perl_debug_log, "rarest char %c at %d\n",BmRARE(sv),BmPREVIOUS(sv)));
d975 15
d991 1
a991 1
fbm_instr(unsigned char *big, register unsigned char *bigend, SV *littlestr, U32 flags)
d994 35
a1028 6
    register I32 tmp;
    register I32 littlelen;
    register unsigned char *little;
    register unsigned char *table;
    register unsigned char *olds;
    register unsigned char *oldlittle;
d1030 49
a1078 10
    if (SvTYPE(littlestr) != SVt_PVBM || !SvVALID(littlestr)) {
	STRLEN len;
	char *l = SvPV(littlestr,len);
	if (!len) {
	    if (SvTAIL(littlestr)) {	/* Can be only 0-len constant
					   substr => we can ignore SvVALID */
		if (PL_multiline) {
		    char *t = "\n";
		    if ((s = (unsigned char*)ninstr((char*)big, (char*)bigend,
			 			    t, t + len))) {
d1080 1
a1080 1
		    }
a1081 2
		if (bigend > big && bigend[-1] == '\n')
		    return (char *)(bigend - 1);
d1083 1
a1083 1
		    return (char *) bigend;
a1084 1
	    return (char*)big;
d1086 4
a1089 1
	return ninstr((char*)big,(char*)bigend, l, l + len);
d1091 1
a1091 6

    littlelen = SvCUR(littlestr);
    if (SvTAIL(littlestr) && !PL_multiline) {	/* tail anchored? */
	if (littlelen > bigend - big)
	    return Nullch;
	little = (unsigned char*)SvPVX(littlestr);
d1093 4
a1096 5
	if (s > big
	    && bigend[-1] == '\n' 
	    && s[-1] == *little && memEQ((char*)s - 1,(char*)little,littlelen))
	    return (char*)s - 1;	/* how sweet it is */
	else if (*s == *little && memEQ((char*)s,(char*)little,littlelen))
d1098 6
d1106 9
a1114 14
    if (littlelen <= 2) {
	unsigned char c1 = (unsigned char)SvPVX(littlestr)[0];
	unsigned char c2 = (unsigned char)SvPVX(littlestr)[1];
	/* This may do extra comparisons if littlelen == 2, but this
	   should be hidden in the noise since we do less indirection. */
	
	s = big;
	bigend -= littlelen;
	while (s <= bigend) {
	    if (s[0] == c1 
		&& (littlelen == 1 || s[1] == c2)
		&& (!SvTAIL(littlestr)
		    || s == bigend
		    || s[littlelen] == '\n')) /* Automatically multiline */
d1118 1
a1118 1
	    s++;
d1120 1
a1120 1
	return Nullch;
d1122 18
a1139 9
    table = (unsigned char*)(SvPVX(littlestr) + littlelen + 1);
    if (--littlelen >= bigend - big)
	return Nullch;
    s = big + littlelen;
    oldlittle = little = table - 2;
    if (s < bigend) {
      top2:
	/*SUPPRESS 560*/
	if (tmp = table[*s]) {
d1141 4
a1144 1
	    if (bigend - s > tmp) {
a1145 2
		goto top2;
	    }
d1147 2
a1148 2
	    if ((s += tmp) < bigend)
		goto top2;
d1150 17
a1166 14
	    return Nullch;
	}
	else {
	    tmp = littlelen;	/* less expensive than calling strncmp() */
	    olds = s;
	    while (tmp--) {
		if (*--s == *--little)
		    continue;
	      differ:
		s = olds + 1;	/* here we pay the price for failure */
		little = oldlittle;
		if (s < bigend)	/* fake up continue to outer loop */
		    goto top2;
		return Nullch;
a1167 5
	    if (SvTAIL(littlestr)	/* automatically multiline */
		&& olds + 1 != bigend
		&& olds[1] != '\n') 
		goto differ;
	    return (char *)s;
d1169 5
a1174 1
    return Nullch;
d1183 3
a1185 2
   Note that we do not take into account SvTAIL, so it may give wrong
   positives if _ALL flag is set.
d1188 4
d1193 1
a1193 1
screaminstr(SV *bigstr, SV *littlestr, I32 start_shift, I32 end_shift, I32 *old_posp, I32 last)
d1208 9
a1216 1
	: (((pos = *old_posp), pos += PL_screamnext[pos]) == 0))
d1218 2
d1228 5
a1232 1
    if (previous + start_shift > stop_pos) return Nullch;
d1235 1
a1235 1
	    return Nullch;
d1273 2
a1274 1
    return (last && found) ? (char *)(big+(*old_posp)) : Nullch;
d1276 13
d1292 1
a1292 1
ibcmp(char *s1, char *s2, register I32 len)
d1297 1
a1297 1
	if (*a != *b && *a != fold[*b])
d1305 1
a1305 1
ibcmp_locale(char *s1, char *s2, register I32 len)
d1310 1
a1310 1
	if (*a != *b && *a != fold_locale[*b])
d1319 8
d1328 1
a1328 1
savepv(char *sv)
d1339 9
d1349 1
a1349 1
savepvn(char *sv, register I32 len)
d1359 1
a1359 1
/* the SV for form() and mess() is not kept in an arena */
d1362 1
a1362 1
mess_alloc(void)
d1364 1
d1368 6
d1380 1
d1384 1
d1386 1
a1386 1
form(const char* pat, ...)
d1388 2
d1392 1
a1392 3
    if (!PL_mess_sv)
	PL_mess_sv = mess_alloc();
    sv_vsetpvfn(PL_mess_sv, pat, strlen(pat), &args, Null(SV**), 0, Null(bool*));
d1394 1
a1394 1
    return SvPVX(PL_mess_sv);
d1396 1
d1399 1
a1399 1
mess(const char *pat, va_list *args)
d1401 45
a1445 1
    SV *sv;
a1447 3
    if (!PL_mess_sv)
	PL_mess_sv = mess_alloc();
    sv = PL_mess_sv;
d1451 10
a1460 15
	if (PL_dirty)
	    sv_catpv(sv, dgd);
	else {
	    if (PL_curcop->cop_line)
		sv_catpvf(sv, " at %_ line %ld",
			  GvSV(PL_curcop->cop_filegv), (long)PL_curcop->cop_line);
	    if (GvIO(PL_last_in_gv) && IoLINES(GvIOp(PL_last_in_gv))) {
		bool line_mode = (RsSIMPLE(PL_rs) &&
				  SvLEN(PL_rs) == 1 && *SvPVX(PL_rs) == '\n');
		sv_catpvf(sv, ", <%s> %s %ld",
			  PL_last_in_gv == PL_argvgv ? "" : GvNAME(PL_last_in_gv),
			  line_mode ? "line" : "chunk", 
			  (long)IoLINES(GvIOp(PL_last_in_gv)));
	    }
	    sv_catpv(sv, ".\n");
d1462 5
d1468 1
a1468 1
    return SvPVX(sv);
d1472 1
a1472 1
die(const char* pat, ...)
a1474 1
    va_list args;
d1480 2
d1483 1
a1483 1
    DEBUG_S(PerlIO_printf(PerlIO_stderr(),
d1487 14
a1500 3
    va_start(args, pat);
    message = pat ? mess(pat, &args) : Nullch;
    va_end(args);
d1502 1
a1502 1
    DEBUG_S(PerlIO_printf(PerlIO_stderr(),
d1506 1
a1506 1
	/* sv_2cv might call croak() */
d1518 3
a1520 2
	    if(message) {
		msg = newSVpv(message, 0);
d1532 1
a1532 1
	    perl_call_sv((SV*)cv, G_DISCARD);
d1538 2
a1539 2
    PL_restartop = die_where(message);
    DEBUG_S(PerlIO_printf(PerlIO_stderr(),
d1547 25
d1573 1
a1573 1
croak(const char* pat, ...)
a1575 1
    va_list args;
d1580 14
a1594 4
    va_start(args, pat);
    message = mess(pat, &args);
    va_end(args);
    DEBUG_S(PerlIO_printf(PerlIO_stderr(), "croak: 0x%lx %s", (unsigned long) thr, message));
d1596 1
a1596 1
	/* sv_2cv might call croak() */
d1608 2
a1609 1
	    msg = newSVpv(message, 0);
d1617 1
a1617 1
	    perl_call_sv((SV*)cv, G_DISCARD);
d1623 1
a1623 1
	PL_restartop = die_where(message);
d1626 13
a1638 2
    PerlIO_puts(PerlIO_stderr(),message);
    (void)PerlIO_flush(PerlIO_stderr());
d1642 23
d1666 1
a1666 1
warn(const char* pat,...)
d1669 9
d1682 2
d1685 2
a1686 3
    va_start(args, pat);
    message = mess(pat, &args);
    va_end(args);
d1689 1
a1689 1
	/* sv_2cv might call warn() */
d1702 2
a1703 1
	    msg = newSVpv(message, 0);
d1711 1
a1711 1
	    perl_call_sv((SV*)cv, G_DISCARD);
d1717 4
a1720 1
    PerlIO_puts(PerlIO_stderr(),message);
d1722 6
a1727 6
    DEBUG_L(*message == '!' 
	    ? (xstat(message[1]=='!'
		     ? (message[2]=='!' ? 2 : 1)
		     : 0)
	       , 0)
	    : 0);
d1729 152
a1880 1
    (void)PerlIO_flush(PerlIO_stderr());
d1884 1
a1884 1
#ifndef WIN32
d1886 1
a1886 1
my_setenv(char *nam, char *val)
d1888 2
d1899 5
a1903 3
	New(901,tmpenv, max+2, char*);
	for (j=0; j<max; j++)		/* copy environment */
	    tmpenv[j] = savepv(environ[j]);
d1908 1
a1908 1
	Safefree(environ[i]);
d1916 1
a1916 1
	Renew(environ, i+2, char*);	/* just expand it a bit */
d1920 3
a1922 3
	Safefree(environ[i]);
    New(904, environ[i], strlen(nam) + strlen(val) + 2, char);
#ifndef MSDOS
d1924 30
a1953 5
#else
    /* MS-DOS requires environment variable names to be in uppercase */
    /* [Tom Dinger, 27 August 1990: Well, it doesn't _require_ it, but
     * some utilities and applications may break because they only look
     * for upper case strings. (Fixed strupr() bug here.)]
d1955 13
a1967 3
    strcpy(environ[i],nam); strupr(environ[i]);
    (void)sprintf(environ[i] + strlen(nam),"=%s",val);
#endif /* MSDOS */
a1968 1

d1972 1
a1972 1
my_setenv(char *nam,char *val)
d2004 1
a2004 1
    New(904, envstr, namlen + vallen + 3, char);
d2008 1
a2008 1
	Safefree(oldstr);
d2010 1
a2010 1
    Safefree(envstr);		/* MSVCRT leaks without this */
d2030 1
d2033 1
a2033 1
setenv_getix(char *nam)
d2054 1
a2054 2
unlnk(f)	/* unlink all versions of a file */
char *f;
d2063 1
d2066 1
a2066 1
my_bcopy(register char *from,register char *to,register I32 len)
d2084 1
d2087 1
a2087 4
my_memset(loc,ch,len)
register char *loc;
register I32 ch;
register I32 len;
d2097 1
d2100 1
a2100 3
my_bzero(loc,len)
register char *loc;
register I32 len;
d2110 1
d2113 1
a2113 4
my_memcmp(s1,s2,len)
char *s1;
char *s2;
register I32 len;
d2134 1
a2134 4
vsprintf(dest, pat, args)
char *dest;
const char *pat;
char *args;
d2158 1
a2158 1
my_swap(short s)
d2171 1
a2171 1
my_htonl(long l)
d2186 1
a2186 1
    croak("Unknown BYTEORDER\n");
d2200 1
a2200 1
my_ntohl(long l)
d2215 1
a2215 1
    croak("Unknown BYTEORDER\n");
d2243 1
a2243 2
	name (n)						\
	register type n;					\
d2259 1
a2259 2
	name (n)						\
	register type n;					\
d2289 1
a2289 1
#if (!defined(DOSISH) || defined(HAS_FORK) || defined(AMIGAOS)) && !defined(VMS)
d2291 1
a2291 1
my_popen(char *cmd, char *mode)
d2295 1
a2295 1
    register I32 pid;
d2298 2
d2301 1
d2315 2
d2320 4
d2325 1
a2325 1
		croak("Can't fork");
d2338 6
d2348 1
d2357 2
a2358 1
		PerlLIO_close(fd);
d2360 1
a2360 1
	    do_exec(cmd);	/* may or may not use the shell */
d2363 1
d2365 2
a2366 2
	if (tmpgv = gv_fetchpv("$",TRUE, SVt_PV))
	    sv_setiv(GvSV(tmpgv), (IV)getpid());
d2375 2
d2386 23
d2415 1
a2415 3
my_popen(cmd,mode)
char	*cmd;
char	*mode;
d2419 1
d2428 1
a2428 1
dump_fds(char *s)
d2433 1
a2433 1
    PerlIO_printf(PerlIO_stderr(),"%s", s);
d2436 1
a2436 1
	    PerlIO_printf(PerlIO_stderr()," %d",fd);
d2438 1
a2438 1
    PerlIO_printf(PerlIO_stderr(),"\n");
d2444 1
a2444 3
dup2(oldfd,newfd)
int oldfd;
int newfd;
d2480 1
a2480 1
rsignal(int signo, Sighandler_t handler)
d2501 1
a2501 1
rsignal_state(int signo)
d2512 1
a2512 1
rsignal_save(int signo, Sighandler_t handler, Sigsave_t *save)
d2530 1
a2530 1
rsignal_restore(int signo, Sigsave_t *save)
d2538 1
a2538 1
rsignal(int signo, Sighandler_t handler)
d2553 1
a2553 1
rsignal_state(int signo)
d2561 1
a2561 1
        PerlProc_kill(getpid(), signo);
d2566 1
a2566 1
rsignal_save(int signo, Sighandler_t handler, Sigsave_t *save)
d2573 1
a2573 1
rsignal_restore(int signo, Sigsave_t *save)
d2581 1
a2581 1
#if (!defined(DOSISH) || defined(HAS_FORK) || defined(AMIGAOS)) && !defined(VMS)
d2583 1
a2583 1
my_pclose(PerlIO *ptr)
d2588 2
a2589 2
    int pid;
    int pid2;
d2600 1
a2600 1
    pid = (int)SvIVX(*svp);
d2637 1
a2637 1
#if  !defined(DOSISH) || defined(OS2) || defined(WIN32)
d2639 1
a2639 1
wait4pid(int pid, int *statusp, int flags)
d2648 1
a2648 1
	sprintf(spid, "%d", pid);
d2660 1
a2660 1
	if (entry = hv_iternext(PL_pidstatus)) {
d2664 1
a2664 1
	    sprintf(spid, "%d", pid);
d2684 1
a2684 1
	    croak("Can't do waitpid with flags");
d2699 1
a2699 1
pidgone(int pid, int status)
d2704 1
a2704 1
    sprintf(spid, "%d", pid);
d2716 1
a2716 1
my_syspclose(ptr)
d2719 1
a2719 1
my_pclose(ptr)
a2720 1
PerlIO *ptr;
d2725 3
d2734 1
a2734 1
repeatcpy(register char *to, register char *from, I32 len, register I32 count)
d2737 1
a2737 1
    register char *frombase = from;
d2740 1
a2740 1
	register char c = *from;
a2752 1
#ifndef CASTNEGFLOAT
d2754 1
a2754 2
cast_ulong(f)
double f;
a2768 3
#endif

#ifndef CASTI32
d2791 1
a2791 2
cast_i32(f)
double f;
d2801 1
a2801 2
cast_iv(f)
double f;
d2803 8
a2810 2
    if (f >= IV_MAX)
	return (IV) IV_MAX;
d2817 1
a2817 2
cast_uv(f)
double f;
d2821 8
a2831 2
#endif

d2834 1
a2834 3
same_dirent(a,b)
char *a;
char *b;
d2869 2
a2870 2
UV
scan_oct(char *start, I32 len, I32 *retlen)
d2873 24
a2896 2
    register UV retval = 0;
    bool overflowed = FALSE;
d2898 61
a2958 5
    while (len && *s >= '0' && *s <= '7') {
	register UV n = retval << 3;
	if (!overflowed && (n >> 3) != retval) {
	    warn("Integer overflow in octal number");
	    overflowed = TRUE;
d2960 35
a2994 2
	retval = n | (*s++ - '0');
	len--;
a2995 2
    if (PL_dowarn && len && (*s == '8' || *s == '9'))
	warn("Illegal octal digit ignored");
d2997 1
a2997 1
    return retval;
d3000 2
a3001 2
UV
scan_hex(char *start, I32 len, I32 *retlen)
d3004 14
a3017 9
    register UV retval = 0;
    bool overflowed = FALSE;
    char *tmp = s;
    register UV n;

    while (len-- && *s) {
	tmp = strchr((char *) PL_hexdigit, *s++);
	if (!tmp) {
	    if (*(s-1) == '_' || (*(s-1) == 'x' && retval == 0))
d3019 1
d3021 4
a3024 3
		--s;
		if (PL_dowarn)
		    warn("Illegal hex digit ignored");
d3028 35
a3062 6
	n = retval << 4;
	if (!overflowed && (n >> 4) != retval) {
	    warn("Integer overflow in hex number");
	    overflowed = TRUE;
	}
	retval = n | ((tmp - PL_hexdigit) & 15);
d3065 1
a3065 1
    return retval;
d3069 1
a3069 1
find_script(char *scriptname, bool dosearch, char **search_ext, I32 flags)
d3074 1
a3074 1
    char tmpbuf[512];
d3187 4
d3195 3
a3197 1
		 && (s = PerlEnv_getenv("PATH"))) {
d3202 5
d3223 1
d3228 4
d3233 1
a3233 1
#if defined(atarist) || defined(DOSISH)
d3241 1
d3266 1
a3266 1
#ifndef DOSISH
d3285 1
a3285 1
	        croak("Can't %s %s%s%s",
d3300 37
d3339 1
d3349 1
a3349 2
perl_cond_init(cp)
perl_cond *cp;
d3355 1
a3355 2
perl_cond_signal(cp)
perl_cond *cp;
d3375 1
a3375 2
perl_cond_broadcast(cp)
perl_cond *cp;
d3396 1
a3396 2
perl_cond_wait(cp)
perl_cond *cp;
d3401 1
a3401 1
	croak("panic: perl_cond_wait called by last runnable thread");
a3413 12
#ifdef OLD_PTHREADS_API
struct perl_thread *
getTHR _((void))
{
    pthread_addr_t t;

    if (pthread_getspecific(PL_thr_key, &t))
	croak("panic: pthread_getspecific");
    return (struct perl_thread *) t;
}
#endif /* OLD_PTHREADS_API */

d3415 1
a3415 1
condpair_magic(SV *sv)
d3429 1
a3429 1
	LOCK_SV_MUTEX;
d3433 1
a3433 1
	    UNLOCK_SV_MUTEX;
d3444 2
a3445 2
	    UNLOCK_SV_MUTEX;
	    DEBUG_S(WITH_THR(PerlIO_printf(PerlIO_stderr(),
d3460 1
a3460 1
new_struct_thread(struct perl_thread *t)
d3462 1
d3464 1
d3469 1
a3469 1
    sv = newSVpv("", 0);
d3487 1
a3487 1
    init_stacks(ARGS);
d3490 1
d3494 1
a3494 2
    thr->errsv = newSVpv("", 0);
    thr->errhv = newHV();
d3498 1
d3500 1
a3500 14
    /* top_env needs to be non-zero. It points to an area
       in which longjmp() stuff is stored, as C callstack
       info there at least is thread specific this has to
       be per-thread. Otherwise a 'die' in a thread gives
       that thread the C stack of last thread to do an eval {}!
       See comments in scope.h    
       Initialize top entry (as in perl.c for main thread)
     */
    PL_start_env.je_prev = NULL;
    PL_start_env.je_ret = -1;
    PL_start_env.je_mustcatch = TRUE;
    PL_top_env  = &PL_start_env;

    PL_in_eval = FALSE;
d3504 1
d3506 5
a3510 2
    PL_regcompp = FUNC_NAME_TO_PTR(pregcomp);
    PL_regexecp = FUNC_NAME_TO_PTR(regexec_flags);
d3518 1
d3523 4
a3539 1
    PL_formtarget = newSVsv(t->Tformtarget);
d3542 4
d3554 3
a3556 2
	    DEBUG_S(PerlIO_printf(PerlIO_stderr(),
		"new_struct_thread: copied threadsv %d %p->%p\n",i, t, thr));
d3574 1
a3574 1
    init_thread_intern(thr);
d3586 1
a3586 1
double 
d3595 1
a3595 1
Perl_GetVars(void)
d3602 1
a3602 1
get_op_names(void)
d3604 1
a3604 1
 return op_name;
d3608 1
a3608 1
get_op_descs(void)
d3610 1
a3610 1
 return op_desc;
d3614 1
a3614 1
get_no_modify(void)
d3616 1
a3616 1
 return (char*)no_modify;
d3620 1
a3620 1
get_opargs(void)
d3622 1
a3622 1
 return opargs;
d3625 5
d3631 3
a3633 2
SV **
get_specialsv_list(void)
d3635 4
a3638 1
 return PL_specialsv_list;
d3640 1
d3644 1
a3644 1
get_vtbl(int vtbl_id)
d3650 1
a3650 1
	result = &vtbl_sv;
d3653 1
a3653 1
	result = &vtbl_env;
d3656 1
a3656 1
	result = &vtbl_envelem;
d3659 1
a3659 1
	result = &vtbl_sig;
d3662 1
a3662 1
	result = &vtbl_sigelem;
d3665 1
a3665 1
	result = &vtbl_pack;
d3668 1
a3668 1
	result = &vtbl_packelem;
d3671 1
a3671 1
	result = &vtbl_dbline;
d3674 1
a3674 1
	result = &vtbl_isa;
d3677 1
a3677 1
	result = &vtbl_isaelem;
d3680 1
a3680 1
	result = &vtbl_arylen;
d3683 1
a3683 1
	result = &vtbl_glob;
d3686 1
a3686 1
	result = &vtbl_mglob;
d3689 1
a3689 1
	result = &vtbl_nkeys;
d3692 1
a3692 1
	result = &vtbl_taint;
d3695 1
a3695 1
	result = &vtbl_substr;
d3698 1
a3698 1
	result = &vtbl_vec;
d3701 1
a3701 1
	result = &vtbl_pos;
d3704 1
a3704 1
	result = &vtbl_bm;
d3707 1
a3707 1
	result = &vtbl_fm;
d3710 1
a3710 1
	result = &vtbl_uvar;
d3714 1
a3714 1
	result = &vtbl_mutex;
d3718 1
a3718 1
	result = &vtbl_defelem;
d3721 7
a3727 1
	result = &vtbl_regexp;
d3731 1
a3731 1
	result = &vtbl_collxfrm;
d3735 1
a3735 1
	result = &vtbl_amagic;
d3738 4
a3741 1
	result = &vtbl_amagicelem;
d3747 83
@


1.2
log
@perl 5.004_04
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1997, Larry Wall
d56 7
a62 1
static void xstat _((void));
d76 1
a76 2
safemalloc(size)
MEM_SIZE size;
d89 1
a89 1
    ptr = malloc(size?size:1);	/* malloc(0) is NASTY on our system */
d91 1
a91 1
    DEBUG_m(PerlIO_printf(Perl_debug_log, "0x%x: (%05d) malloc %ld bytes\n",ptr,an++,(long)size));
d93 1
a93 1
    DEBUG_m(PerlIO_printf(Perl_debug_log, "0x%lx: (%05d) malloc %ld bytes\n",ptr,an++,(long)size));
d97 1
a97 1
    else if (nomemok)
d102 1
d110 1
a110 3
saferealloc(where,size)
Malloc_t where;
MEM_SIZE size;
d114 1
a114 1
    Malloc_t realloc();
d124 5
d130 1
a130 1
	croak("Null realloc");
d135 1
a135 1
    ptr = realloc(where,size?size:1);	/* realloc(0) is NASTY on our system */
d139 2
a140 2
	PerlIO_printf(Perl_debug_log, "0x%x: (%05d) rfree\n",where,an++);
	PerlIO_printf(Perl_debug_log, "0x%x: (%05d) realloc %ld bytes\n",ptr,an++,(long)size);
d144 2
a145 2
	PerlIO_printf(Perl_debug_log, "0x%lx: (%05d) rfree\n",where,an++);
	PerlIO_printf(Perl_debug_log, "0x%lx: (%05d) realloc %ld bytes\n",ptr,an++,(long)size);
d151 1
a151 1
    else if (nomemok)
d156 1
d164 1
a164 2
safefree(where)
Malloc_t where;
d167 1
a167 1
    DEBUG_m( PerlIO_printf(Perl_debug_log, "0x%x: (%05d) free\n",where,an++));
d169 1
a169 1
    DEBUG_m( PerlIO_printf(Perl_debug_log, "0x%lx: (%05d) free\n",where,an++));
d173 1
a173 1
	free(where);
d180 1
a180 3
safecalloc(count, size)
MEM_SIZE count;
MEM_SIZE size;
d196 1
a196 1
    ptr = malloc(size?size:1);	/* malloc(0) is NASTY on our system */
d198 1
a198 1
    DEBUG_m(PerlIO_printf(Perl_debug_log, "0x%x: (%05d) calloc %ld  x %ld bytes\n",ptr,an++,(long)count,(long)size));
d200 1
a200 1
    DEBUG_m(PerlIO_printf(Perl_debug_log, "0x%lx: (%05d) calloc %ld x %ld bytes\n",ptr,an++,(long)count,(long)size));
d206 1
a206 1
    else if (nomemok)
d211 1
d220 20
a239 1
#define ALIGN sizeof(long)
d242 9
a250 11
safexmalloc(x,size)
I32 x;
MEM_SIZE size;
{
    register Malloc_t where;

    where = safemalloc(size + ALIGN);
    xcount[x]++;
    where[0] = x % 100;
    where[1] = x / 100;
    return where + ALIGN;
d254 1
a254 3
safexrealloc(where,size)
Malloc_t where;
MEM_SIZE size;
d256 16
a271 2
    register Malloc_t new = saferealloc(where - ALIGN, size + ALIGN);
    return new + ALIGN;
d275 1
a275 2
safexfree(where)
Malloc_t where;
d278 3
a280 1

d284 1
d286 2
a287 1
    xcount[x]--;
d292 9
a300 13
safexcalloc(x,count,size)
I32 x;
MEM_SIZE count;
MEM_SIZE size;
{
    register Malloc_t where;

    where = safexmalloc(x, size * count + ALIGN);
    xcount[x]++;
    memset((void*)where + ALIGN, 0, size * count);
    where[0] = x % 100;
    where[1] = x / 100;
    return where + ALIGN;
d304 1
a304 1
xstat()
d306 2
a307 1
    register I32 i;
d309 5
d315 11
a325 2
	if (xcount[i] > lastxcount[i]) {
	    PerlIO_printf(PerlIO_stderr(),"%2d %2d\t%ld\n", i / 100, i % 100, xcount[i]);
d327 16
d345 11
d363 1
a363 7
delimcpy(to, toend, from, fromend, delim, retlen)
register char *to;
register char *toend;
register char *from;
register char *fromend;
register int delim;
I32 *retlen;
d392 1
a392 3
instr(big, little)
register char *big;
register char *little;
d422 1
a422 5
ninstr(big, bigend, little, lend)
register char *big;
register char *bigend;
char *little;
char *lend;
d451 1
a451 5
rninstr(big, bigend, little, lend)
register char *big;
char *bigend;
char *little;
char *lend;
d481 1
a481 2
perl_new_ctype(newctype)
    char *newctype;
d503 1
a503 2
perl_new_collate(newcoll)
    char *newcoll;
d508 7
a514 7
	if (collation_name) {
	    ++collation_ix;
	    Safefree(collation_name);
	    collation_name = NULL;
	    collation_standard = TRUE;
	    collxfrm_base = 0;
	    collxfrm_mult = 2;
d519 5
a523 5
    if (! collation_name || strNE(collation_name, newcoll)) {
	++collation_ix;
	Safefree(collation_name);
	collation_name = savepv(newcoll);
	collation_standard = (strEQ(newcoll, "C") || strEQ(newcoll, "POSIX"));
d535 2
a536 2
	  collxfrm_base = (fa > mult) ? (fa - mult) : 0;
	  collxfrm_mult = mult;
d547 1
a547 2
perl_new_numeric(newnum)
    char *newnum;
d552 5
a556 5
	if (numeric_name) {
	    Safefree(numeric_name);
	    numeric_name = NULL;
	    numeric_standard = TRUE;
	    numeric_local = TRUE;
d561 5
a565 5
    if (! numeric_name || strNE(numeric_name, newnum)) {
	Safefree(numeric_name);
	numeric_name = savepv(newnum);
	numeric_standard = (strEQ(newnum, "C") || strEQ(newnum, "POSIX"));
	numeric_local = TRUE;
d572 1
a572 1
perl_set_numeric_standard()
d576 1
a576 1
    if (! numeric_standard) {
d578 2
a579 2
	numeric_standard = TRUE;
	numeric_local = FALSE;
d586 1
a586 1
perl_set_numeric_local()
d590 4
a593 4
    if (! numeric_local) {
	setlocale(LC_NUMERIC, numeric_name);
	numeric_standard = FALSE;
	numeric_local = TRUE;
d604 1
a604 2
perl_init_i18nl10n(printwarn)	
    int printwarn;
d624 5
a628 2
    char *lc_all     = getenv("LC_ALL");
    char *lang       = getenv("LANG");
d647 1
a647 3
    if (!setlocale_failure)
#endif /* LC_ALL */
    {
d649 3
a651 2
	if (! (curctype = setlocale(LC_CTYPE,
				    (!done && (lang || getenv("LC_CTYPE")))
d656 3
a658 2
	if (! (curcoll = setlocale(LC_COLLATE,
				   (!done && (lang || getenv("LC_COLLATE")))
d663 3
a665 2
	if (! (curnum = setlocale(LC_NUMERIC,
				  (!done && (lang || getenv("LC_NUMERIC")))
d671 3
a673 1
#else /* !LOCALE_ENVIRON_REQUIRED */
a675 1

d678 3
a680 1
    else {
d682 2
a683 1
	curctype = setlocale(LC_CTYPE, Nullch);
d686 2
a687 1
	curcoll = setlocale(LC_COLLATE, Nullch);
d690 2
a691 1
	curnum = setlocale(LC_NUMERIC, Nullch);
a694 19
#else /* !LC_ALL */

#ifdef USE_LOCALE_CTYPE
    if (! (curctype = setlocale(LC_CTYPE, "")))
	setlocale_failure = TRUE;
#endif /* USE_LOCALE_CTYPE */
#ifdef USE_LOCALE_COLLATE
    if (! (curcoll = setlocale(LC_COLLATE, "")))
	setlocale_failure = TRUE;
#endif /* USE_LOCALE_COLLATE */
#ifdef USE_LOCALE_NUMERIC
    if (! (curnum = setlocale(LC_NUMERIC, "")))
	setlocale_failure = TRUE;
#endif /* USE_LOCALE_NUMERIC */

#endif /* LC_ALL */

#endif /* !LOCALE_ENVIRON_REQUIRED */

d699 1
a699 1
			(!(p = getenv("PERL_BADLANG")) || atoi(p)));
d730 8
d832 1
a832 2
perl_init_i18nl14n(printwarn)	
    int printwarn;
d847 1
a847 4
mem_collxfrm(s, len, xlen)
     const char *s;
     STRLEN len;
     STRLEN *xlen;
d850 1
a850 1
    STRLEN xalloc, xin, xout;
d855 2
a856 2
    xalloc = sizeof(collation_ix) + collxfrm_base + (collxfrm_mult * len) + 1;
    New(171, xbuf, xalloc, char);
d860 2
a861 2
    *(U32*)xbuf = collation_ix;
    xout = sizeof(collation_ix);
d866 1
a866 1
	    xused = strxfrm(xbuf + xout, s + xin, xalloc - xout);
d869 1
a869 1
	    if (xused < xalloc - xout)
d871 2
a872 2
	    xalloc = (2 * xalloc) + 1;
	    Renew(xbuf, xalloc, char);
d885 1
a885 1
    *xlen = xout - sizeof(collation_ix);
d897 1
a897 2
fbm_compile(sv)
SV *sv;
d899 2
a900 2
    register unsigned char *s;
    register unsigned char *table;
d902 1
a902 1
    register U32 len = SvCUR(sv);
d906 3
a908 1
    if (len > 255)
d910 14
a923 12
    Sv_Grow(sv,len+258);
    table = (unsigned char*)(SvPVX(sv) + len + 1);
    s = table - 2;
    for (i = 0; i < 256; i++) {
	table[i] = len;
    }
    i = 0;
    while (s >= (unsigned char*)(SvPVX(sv)))
    {
	if (table[*s] == len)
	    table[*s] = i;
	s--,i++;
a924 1
    sv_upgrade(sv, SVt_PVBM);
d941 1
a941 4
fbm_instr(big, bigend, littlestr)
unsigned char *big;
register unsigned char *bigend;
SV *littlestr;
d954 15
a968 1
	if (!len)
d970 1
d975 1
a975 1
    if (SvTAIL(littlestr) && !multiline) {	/* tail anchored? */
d980 5
a984 1
	if (*s == *little && memEQ((char*)s,(char*)little,littlelen))
d986 17
a1002 4
	else if (bigend[-1] == '\n' && little[littlelen-1] != '\n'
		 && s > big) {
	    s--;
	    if (*s == *little && memEQ((char*)s,(char*)little,littlelen))
d1004 2
d1035 1
d1042 4
d1052 10
d1063 1
a1063 3
screaminstr(bigstr, littlestr)
SV *bigstr;
SV *littlestr;
d1065 1
d1072 1
a1072 1
    register unsigned char *bigend;
d1074 1
d1076 3
a1078 1
    if ((pos = screamfirst[BmRARE(littlestr)]) < 0) 
d1083 1
d1086 5
a1090 3
    bigend = big + SvCUR(bigstr);
    while (pos < previous) {
	if (!(pos += screamnext[pos]))
d1095 1
a1098 2
	    if (x >= bigend)
		return Nullch;
d1104 7
a1110 3
	if (s == littleend)
	    return (char *)(big+pos-previous);
    } while ( pos += screamnext[pos] );
d1114 1
a1117 2
	    if (x >= bigend)
		return Nullch;
d1123 7
a1129 3
	if (s == littleend)
	    return (char *)(big+pos);
    } while ( pos += screamnext[pos] );
a1130 1
    return Nullch;
d1134 1
a1134 3
ibcmp(s1, s2, len)
char *s1, *s2;
register I32 len;
d1147 1
a1147 3
ibcmp_locale(s1, s2, len)
char *s1, *s2;
register I32 len;
d1162 1
a1162 2
savepv(sv)
char *sv;
d1174 1
a1174 3
savepvn(sv, len)
char *sv;
register I32 len;
d1186 2
a1187 2
static SV *
mess_alloc()
a1200 1
#ifdef I_STDARG
a1202 7
#else
/*VARARGS0*/
char *
form(pat, va_alist)
    const char *pat;
    va_dcl
#endif
a1204 1
#ifdef I_STDARG
d1206 3
a1208 6
#else
    va_start(args);
#endif
    if (!mess_sv)
	mess_sv = mess_alloc();
    sv_vsetpvfn(mess_sv, pat, strlen(pat), &args, Null(SV**), 0, Null(bool*));
d1210 1
a1210 1
    return SvPVX(mess_sv);
d1214 1
a1214 3
mess(pat, args)
    const char *pat;
    va_list *args;
d1219 3
a1221 3
    if (!mess_sv)
	mess_sv = mess_alloc();
    sv = mess_sv;
d1224 2
a1225 1
	if (dirty)
d1228 1
a1228 1
	    if (curcop->cop_line)
d1230 4
a1233 4
			  GvSV(curcop->cop_filegv), (long)curcop->cop_line);
	    if (GvIO(last_in_gv) && IoLINES(GvIOp(last_in_gv))) {
		bool line_mode = (RsSIMPLE(rs) &&
				  SvLEN(rs) == 1 && *SvPVX(rs) == '\n');
d1235 1
a1235 1
			  last_in_gv == argvgv ? "" : GvNAME(last_in_gv),
d1237 1
a1237 1
			  (long)IoLINES(GvIOp(last_in_gv)));
a1244 1
#ifdef I_STDARG
a1246 7
#else
/*VARARGS0*/
OP *
die(pat, va_alist)
    const char *pat;
    va_dcl
#endif
d1248 1
d1251 1
a1251 2
    I32 oldrunlevel = runlevel;
    int was_in_eval = in_eval;
d1256 3
a1258 7
    /* We have to switch back to mainstack or die_where may try to pop
     * the eval block from the wrong stack if die is being called from a
     * signal handler.  - dkindred@@cs.cmu.edu */
    if (curstack != mainstack) {
        dSP;
        SWITCHSTACK(curstack, mainstack);
    }
a1259 1
#ifdef I_STDARG
d1261 1
a1261 4
#else
    va_start(args);
#endif
    message = mess(pat, &args);
d1264 4
a1267 1
    if (diehook) {
d1269 1
a1269 1
	SV *olddiehook = diehook;
d1271 2
a1272 2
	SAVESPTR(diehook);
	diehook = Nullsv;
d1280 8
a1287 3
	    msg = newSVpv(message, 0);
	    SvREADONLY_on(msg);
	    SAVEFREESV(msg);
d1289 2
a1290 1
	    PUSHMARK(sp);
d1294 1
a1294 1

d1299 5
a1303 2
    restartop = die_where(message);
    if ((!restartop && was_in_eval) || oldrunlevel > 1)
d1305 1
a1305 1
    return restartop;
a1307 1
#ifdef I_STDARG
a1309 7
#else
/*VARARGS0*/
void
croak(pat, va_alist)
    char *pat;
    va_dcl
#endif
d1311 1
a1317 1
#ifdef I_STDARG
a1318 3
#else
    va_start(args);
#endif
d1321 2
a1322 1
    if (diehook) {
d1324 1
a1324 1
	SV *olddiehook = diehook;
d1326 2
a1327 2
	SAVESPTR(diehook);
	diehook = Nullsv;
d1339 2
a1340 1
	    PUSHMARK(sp);
d1344 1
a1344 1

d1348 2
a1349 2
    if (in_eval) {
	restartop = die_where(message);
a1357 1
#ifdef I_STDARG
a1358 6
#else
/*VARARGS0*/
warn(pat,va_alist)
    const char *pat;
    va_dcl
#endif
a1365 1
#ifdef I_STDARG
a1366 3
#else
    va_start(args);
#endif
d1370 1
a1370 1
    if (warnhook) {
d1372 2
a1373 1
	SV *oldwarnhook = warnhook;
d1375 2
a1376 2
	SAVESPTR(warnhook);
	warnhook = Nullsv;
d1388 2
a1389 1
	    PUSHMARK(sp);
d1393 1
a1393 1

d1400 6
a1405 1
    DEBUG_L(xstat());
d1413 1
a1413 2
my_setenv(nam,val)
char *nam, *val;
d1417 1
a1417 1
    if (environ == origenviron) {	/* need we copy environment? */
d1461 1
a1461 2
my_setenv(nam,val)
char *nam, *val;
d1495 1
a1495 1
    (void)putenv(envstr);
d1504 10
a1513 15
    /* The sane way to deal with the environment.
     * Has these advantages over putenv() & co.:
     *  * enables us to store a truly empty value in the
     *    environment (like in UNIX).
     *  * we don't have to deal with RTL globals, bugs and leaks.
     *  * Much faster.
     * Why you may want to enable USE_WIN32_RTL_ENV:
     *  * environ[] and RTL functions will not reflect changes,
     *    which might be an issue if extensions want to access
     *    the env. via RTL.  This cuts both ways, since RTL will
     *    not see changes made by extensions that call the Win32
     *    functions directly, either.
     * GSAR 97-06-07
     */
    SetEnvironmentVariable(nam,val);
d1521 1
a1521 2
setenv_getix(nam)
char *nam;
d1547 1
a1547 1
    for (i = 0; unlink(f) >= 0; i++) ;
d1554 1
a1554 4
my_bcopy(from,to,len)
register char *from;
register char *to;
register I32 len;
a1619 1
#if defined(I_STDARG) || defined(I_VARARGS)
a1649 1
#endif /* I_VARARGS || I_STDARGS */
a1653 4
#ifndef CAN_PROTOTYPE
my_swap(s)
short s;
#else
a1654 1
#endif
a1666 4
#ifndef CAN_PROTOTYPE
my_htonl(l)
register long l;
#else
a1667 1
#endif
a1695 4
#ifndef CAN_PROTOTYPE
my_ntohl(l)
register long l;
#else
a1696 1
#endif
d1789 1
a1789 3
my_popen(cmd,mode)
char	*cmd;
char	*mode;
d1792 1
a1792 1
    register I32 this, that;
d1802 3
a1804 5
    if (pipe(p) < 0)
	return Nullfp;
    this = (*mode == 'w');
    that = !this;
    if (doexec && tainting) {
d1808 2
d1812 1
a1812 1
	    close(p[this]);
d1822 2
d1825 2
a1826 2
#define THAT this
	close(p[THAT]);
d1828 2
a1829 2
	    dup2(p[THIS], *mode == 'r');
	    close(p[THIS]);
d1838 2
a1839 2
	    for (fd = maxsysfd + 1; fd < NOFILE; fd++)
		close(fd);
d1842 1
a1842 1
	    _exit(1);
d1847 2
a1848 2
	forkprocess = 0;
	hv_clear(pidstatus);	/* we have no children */
d1854 5
a1858 5
    close(p[that]);
    if (p[that] < p[this]) {
	dup2(p[this], p[that]);
	close(p[this]);
	p[this] = p[that];
d1860 1
a1860 1
    sv = *av_fetch(fdpid,p[this],TRUE);
d1863 2
a1864 2
    forkprocess = pid;
    return PerlIO_fdopen(p[this], mode);
d1883 2
a1884 2
dump_fds(s)
char *s;
d1891 1
a1891 1
	if (Fstat(fd,&tmpstatbuf) >= 0)
d1896 1
a1896 1
#endif
d1907 1
a1907 1
    close(newfd);
d1917 1
a1917 1
    close(newfd);
d1919 1
a1919 1
    while ((fd = dup(oldfd)) != newfd && fd >= 0) {
d1921 1
a1921 1
	    close(fd);
d1928 1
a1928 1
	close(fdtmp[--fdx]);
d1938 1
a1938 3
rsignal(signo, handler)
int signo;
Sighandler_t handler;
d1948 4
d1959 1
a1959 2
rsignal_state(signo)
int signo;
d1970 1
a1970 4
rsignal_save(signo, handler, save)
int signo;
Sighandler_t handler;
Sigsave_t *save;
d1980 4
d1988 1
a1988 3
rsignal_restore(signo, save)
int signo;
Sigsave_t *save;
d1996 1
a1996 3
rsignal(signo, handler)
int signo;
Sighandler_t handler;
d1998 1
a1998 1
    return signal(signo, handler);
d2005 1
a2005 2
sig_trap(signo)
int signo;
d2011 1
a2011 2
rsignal_state(signo)
int signo;
d2016 2
a2017 2
    oldsig = signal(signo, sig_trap);
    signal(signo, oldsig);
d2019 1
a2019 1
        kill(getpid(), signo);
d2024 1
a2024 4
rsignal_save(signo, handler, save)
int signo;
Sighandler_t handler;
Sigsave_t *save;
d2026 1
a2026 1
    *save = signal(signo, handler);
d2031 1
a2031 3
rsignal_restore(signo, save)
int signo;
Sigsave_t *save;
d2033 1
a2033 1
    return (signal(signo, *save) == SIG_ERR) ? -1 : 0;
d2041 1
a2041 2
my_pclose(ptr)
PerlIO *ptr;
d2047 1
d2053 3
d2057 1
a2057 1
    svp = av_fetch(fdpid,PerlIO_fileno(ptr),TRUE);
d2060 1
a2060 1
    *svp = &sv_undef;
d2071 3
d2076 1
a2076 1
    if(kill(pid, 0) < 0) { return(pid); }   /* HOM 12/23/91 */
d2082 2
a2083 2
	pid = wait4pid(pid, &status, 0);
    } while (pid == -1 && errno == EINTR);
d2091 1
a2091 1
    return(pid < 0 ? pid : status == 0 ? 0 : (errno = 0, status));
d2095 1
a2095 1
#if  !defined(DOSISH) || defined(OS2)
d2097 1
a2097 4
wait4pid(pid,statusp,flags)
int pid;
int *statusp;
int flags;
d2107 2
a2108 2
	svp = hv_fetch(pidstatus,spid,strlen(spid),FALSE);
	if (svp && *svp != &sv_undef) {
d2110 1
a2110 1
	    (void)hv_delete(pidstatus,spid,strlen(spid),G_DISCARD);
d2117 2
a2118 2
	hv_iterinit(pidstatus);
	if (entry = hv_iternext(pidstatus)) {
d2120 1
a2120 1
	    sv = hv_iterval(pidstatus,entry);
d2123 1
a2123 1
	    (void)hv_delete(pidstatus,spid,strlen(spid),G_DISCARD);
d2132 1
a2132 1
    return waitpid(pid,statusp,flags);
d2144 1
a2144 1
	    while ((result = wait(statusp)) != pid && pid > 0 && result >= 0)
d2153 1
a2153 1
#endif /* !DOSISH */
d2157 1
a2157 3
pidgone(pid,status)
int pid;
int status;
d2163 1
a2163 1
    sv = *hv_fetch(pidstatus,spid,strlen(spid),TRUE);
d2190 1
a2190 5
repeatcpy(to,from,len,count)
register char *to;
register char *from;
I32 len;
register I32 count;
d2196 1
a2196 1
	todo = *from;
d2198 1
a2198 1
	    *to++ = todo;
d2310 1
a2310 1
    if (Stat(SvPVX(tmpsv), &tmpstatbuf1) < 0)
d2316 1
a2316 1
    if (Stat(SvPVX(tmpsv), &tmpstatbuf2) < 0)
d2324 1
a2324 4
scan_oct(start, len, retlen)
char *start;
I32 len;
I32 *retlen;
d2339 1
a2339 1
    if (dowarn && len && (*s == '8' || *s == '9'))
d2346 1
a2346 4
scan_hex(start, len, retlen)
char *start;
I32 len;
I32 *retlen;
d2351 2
a2352 1
    char *tmp;
d2354 13
a2366 2
    while (len-- && *s && (tmp = strchr(hexdigit, *s))) {
	register UV n = retval << 4;
d2371 1
a2371 2
	retval = n | (tmp - hexdigit) & 15;
	s++;
d2377 469
d2854 1
a2854 1
Perl_huge()
d2859 136
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1994, Larry Wall
d22 5
a26 1
/* Omit this -- it causes too much grief on mixed systems.
a29 1
*/
a34 4
#ifdef I_LIMITS  /* Needed for cast_xxx() functions below. */
#  include <limits.h>
#endif

d49 4
d59 1
a59 1
#ifndef safemalloc
d66 1
d69 1
a69 1
char *
a70 3
#ifdef MSDOS
unsigned long size;
#else
a71 1
#endif /* MSDOS */
d73 2
a74 2
    char  *ptr;
#ifdef MSDOS
d76 1
a76 1
		fprintf(stderr, "Allocation too large: %lx\n", size) FLUSH;
d79 1
a79 1
#endif /* MSDOS */
d86 1
a86 1
    DEBUG_m(fprintf(stderr,"0x%x: (%05d) malloc %ld bytes\n",ptr,an++,(long)size));
d88 1
a88 1
    DEBUG_m(fprintf(stderr,"0x%lx: (%05d) malloc %ld bytes\n",ptr,an++,(long)size));
d95 1
a95 1
	fputs(no_mem,stderr) FLUSH;
d103 1
a103 1
char *
d105 1
a105 2
char *where;
#ifndef MSDOS
a106 3
#else
unsigned long size;
#endif /* MSDOS */
d108 1
a108 1
    char *ptr;
d110 1
a110 1
    char *realloc();
d113 7
a119 6
#ifdef MSDOS
	if (size > 0xffff) {
		fprintf(stderr, "Reallocation too large: %lx\n", size) FLUSH;
		my_exit(1);
	}
#endif /* MSDOS */
d130 2
a131 2
	fprintf(stderr,"0x%x: (%05d) rfree\n",where,an++);
	fprintf(stderr,"0x%x: (%05d) realloc %ld bytes\n",ptr,an++,(long)size);
d135 2
a136 2
	fprintf(stderr,"0x%lx: (%05d) rfree\n",where,an++);
	fprintf(stderr,"0x%lx: (%05d) realloc %ld bytes\n",ptr,an++,(long)size);
d145 1
a145 1
	fputs(no_mem,stderr) FLUSH;
d153 1
a153 1
void
d155 1
a155 1
char *where;
d158 1
a158 1
    DEBUG_m( fprintf(stderr,"0x%x: (%05d) free\n",where,an++));
d160 1
a160 1
    DEBUG_m( fprintf(stderr,"0x%lx: (%05d) free\n",where,an++));
d168 41
a208 1
#endif /* !safemalloc */
d214 1
a214 1
char *
d219 1
a219 1
    register char *where;
d228 1
a228 1
char *
d230 1
a230 1
char *where;
d233 1
a233 1
    register char *new = saferealloc(where - ALIGN, size + ALIGN);
d239 1
a239 1
char *where;
d251 16
d274 1
a274 1
	    fprintf(stderr,"%2d %2d\t%ld\n", i / 100, i % 100, xcount[i]);
d285 1
a285 1
cpytill(to,from,fromend,delim,retlen)
d287 1
d293 2
a294 3
    char *origto = to;

    for (; from < fromend; from++,to++) {
d298 6
a303 2
	    else if (from[1] == '\\')
		*to++ = *from++;
d307 2
a308 1
	*to = *from;
d310 3
a312 2
    *to = '\0';
    *retlen = to - origto;
d415 129
a543 1
/* Initialize locale (and the fold[] array).*/
d545 1
a545 1
perl_init_i18nl14n(printwarn)	
a553 5
#if defined(HAS_SETLOCALE) && defined(LC_CTYPE)
    char * lang     = getenv("LANG");
    char * lc_all   = getenv("LC_ALL");
    char * lc_ctype = getenv("LC_CTYPE");
    int i;
d555 166
a720 10
    if (setlocale(LC_CTYPE, "") == NULL && (lc_all || lc_ctype || lang)) {
	if (printwarn) {
	    fprintf(stderr, "warning: setlocale(LC_CTYPE, \"\") failed.\n");
	    fprintf(stderr,
	      "warning: LC_ALL = \"%s\", LC_CTYPE = \"%s\", LANG = \"%s\",\n",
	      lc_all   ? lc_all   : "(null)",
	      lc_ctype ? lc_ctype : "(null)",
	      lang     ? lang     : "(null)"
	      );
	    fprintf(stderr, "warning: falling back to the \"C\" locale.\n");
d722 18
a739 2
	ok = 0;
	if (setlocale(LC_CTYPE, "C") == NULL)
d741 88
d831 8
a838 7
    for (i = 0; i < 256; i++) {
	if (isUPPER(i)) fold[i] = toLOWER(i);
	else if (isLOWER(i)) fold[i] = toUPPER(i);
	else fold[i] = i;
    }
#endif
    return ok;
d841 2
d844 1
a844 1
fbm_compile(sv, iflag)
a845 1
I32 iflag;
d865 2
a866 15
	if (table[*s] == len) {
#ifndef pdp11
	    if (iflag)
		table[*s] = table[fold[*s]] = i;
#else
	    if (iflag) {
		I32 j;
		j = fold[*s];
		table[j] = i;
		table[*s] = i;
	    }
#endif /* pdp11 */
	    else
		table[*s] = i;
	}
d870 1
a870 1
    sv_magic(sv, Nullsv, 'B', Nullch, 0);			/* deep magic */
d874 4
a877 19
    if (iflag) {
	register U32 tmp, foldtmp;
	SvCASEFOLD_on(sv);
	for (i = 0; i < len; i++) {
	    tmp=freq[s[i]];
	    foldtmp=freq[fold[s[i]]];
	    if (tmp < frequency && foldtmp < frequency) {
		rarest = i;
		/* choose most frequent among the two */
		frequency = (tmp > foldtmp) ? tmp : foldtmp;
	    }
	}
    }
    else {
	for (i = 0; i < len; i++) {
	    if (freq[s[i]] < frequency) {
		rarest = i;
		frequency = freq[s[i]];
	    }
d882 1
a882 1
    DEBUG_r(fprintf(stderr,"rarest char %c at %d\n",BmRARE(sv),BmPREVIOUS(sv)));
d912 8
a919 16
	if (SvCASEFOLD(littlestr)) {	/* oops, fake it */
	    big = bigend - littlelen;		/* just start near end */
	    if (bigend[-1] == '\n' && little[littlelen-1] != '\n')
		big--;
	}
	else {
	    s = bigend - littlelen;
	    if (*s == *little && bcmp((char*)s,(char*)little,littlelen)==0)
		return (char*)s;		/* how sweet it is */
	    else if (bigend[-1] == '\n' && little[littlelen-1] != '\n'
	      && s > big) {
		    s--;
		if (*s == *little && bcmp((char*)s,(char*)little,littlelen)==0)
		    return (char*)s;
	    }
	    return Nullch;
d921 1
d928 4
a931 5
    if (SvCASEFOLD(littlestr)) {	/* case insensitive? */
	if (s < bigend) {
	  top1:
	    /*SUPPRESS 560*/
	    if (tmp = table[*s]) {
d933 4
a936 4
		if (bigend - s > tmp) {
		    s += tmp;
		    goto top1;
		}
d938 2
a939 2
		if ((s += tmp) < bigend)
		    goto top1;
d941 1
a941 16
		return Nullch;
	    }
	    else {
		tmp = littlelen;	/* less expensive than calling strncmp() */
		olds = s;
		while (tmp--) {
		    if (*--s == *--little || fold[*s] == *little)
			continue;
		    s = olds + 1;	/* here we pay the price for failure */
		    little = oldlittle;
		    if (s < bigend)	/* fake up continue to outer loop */
			goto top1;
		    return Nullch;
		}
		return (char *)s;
	    }
d943 9
a951 13
    }
    else {
	if (s < bigend) {
	  top2:
	    /*SUPPRESS 560*/
	    if (tmp = table[*s]) {
#ifdef POINTERRIGOR
		if (bigend - s > tmp) {
		    s += tmp;
		    goto top2;
		}
#else
		if ((s += tmp) < bigend)
a952 1
#endif
d955 1
a955 14
	    else {
		tmp = littlelen;	/* less expensive than calling strncmp() */
		olds = s;
		while (tmp--) {
		    if (*--s == *--little)
			continue;
		    s = olds + 1;	/* here we pay the price for failure */
		    little = oldlittle;
		    if (s < bigend)	/* fake up continue to outer loop */
			goto top2;
		    return Nullch;
		}
		return (char *)s;
	    }
d988 9
a996 11
    if (SvCASEFOLD(littlestr)) {	/* case insignificant? */
	do {
	    if (big[pos-previous] != first && big[pos-previous] != fold[first])
		continue;
	    for (x=big+pos+1-previous,s=little; s < littleend; /**/ ) {
		if (x >= bigend)
		    return Nullch;
		if (*s++ != *x++ && fold[*(s-1)] != *(x-1)) {
		    s--;
		    break;
		}
d998 4
a1001 22
	    if (s == littleend)
		return (char *)(big+pos-previous);
	} while (
		pos += screamnext[pos]	/* does this goof up anywhere? */
	    );
    }
    else {
	do {
	    if (big[pos-previous] != first)
		continue;
	    for (x=big+pos+1-previous,s=little; s < littleend; /**/ ) {
		if (x >= bigend)
		    return Nullch;
		if (*s++ != *x++) {
		    s--;
		    break;
		}
	    }
	    if (s == littleend)
		return (char *)(big+pos-previous);
	} while ( pos += screamnext[pos] );
    }
d1004 9
a1012 11
    if (SvCASEFOLD(littlestr)) {	/* case insignificant? */
	do {
	    if (big[pos] != first && big[pos] != fold[first])
		continue;
	    for (x=big+pos+1,s=little; s < littleend; /**/ ) {
		if (x >= bigend)
		    return Nullch;
		if (*s++ != *x++ && fold[*(s-1)] != *(x-1)) {
		    s--;
		    break;
		}
d1014 4
a1017 24
	    if (s == littleend)
		return (char *)(big+pos);
	} while (
		pos += screamnext[pos]	/* does this goof up anywhere? */
	    );
    }
    else {
	do {
	    if (big[pos] != first)
		continue;
	    for (x=big+pos+1,s=little; s < littleend; /**/ ) {
		if (x >= bigend)
		    return Nullch;
		if (*s++ != *x++) {
		    s--;
		    break;
		}
	    }
	    if (s == littleend)
		return (char *)(big+pos);
	} while (
		pos += screamnext[pos]
	    );
    }
d1023 17
a1039 3
ibcmp(a,b,len)
register U8 *a;
register U8 *b;
d1042 2
d1045 3
a1047 7
	if (*a == *b) {
	    a++,b++;
	    continue;
	}
	if (fold[*a++] == *b++)
	    continue;
	return 1;
d1080 16
a1095 1
#if !defined(I_STDARG) && !defined(I_VARARGS)
d1097 23
a1119 3
/*
 * Fallback on the old hackers way of doing varargs
 */
a1120 1
/*VARARGS1*/
d1122 6
a1127 19
mess(pat,a1,a2,a3,a4)
char *pat;
long a1, a2, a3, a4;
{
    char *s;
    char *s_start;
    I32 usermess = strEQ(pat,"%s");
    SV *tmpstr;

    s = s_start = buf;
    if (usermess) {
	tmpstr = sv_newmortal();
	sv_setpv(tmpstr, (char*)a1);
	*s++ = SvPVX(tmpstr)[SvCUR(tmpstr)-1];
    }
    else {
	(void)sprintf(s,pat,a1,a2,a3,a4);
	s += strlen(s);
    }
d1129 5
a1133 1
    if (s[-1] != '\n') {
d1135 1
a1135 1
	    strcpy(s, " during global destruction.\n");
d1137 10
a1146 12
	    if (curcop->cop_line) {
		(void)sprintf(s," at %s line %ld",
		  SvPVX(GvSV(curcop->cop_filegv)), (long)curcop->cop_line);
		s += strlen(s);
	    }
	    if (GvIO(last_in_gv) &&
		IoLINES(GvIOp(last_in_gv)) ) {
		(void)sprintf(s,", <%s> %s %ld",
		  last_in_gv == argvgv ? "" : GvENAME(last_in_gv),
		  strEQ(rs,"\n") ? "line" : "chunk", 
		  (long)IoLINES(GvIOp(last_in_gv)));
		s += strlen(s);
d1148 1
a1148 2
	    (void)strcpy(s,".\n");
	    s += 2;
a1149 2
	if (usermess)
	    sv_catpv(tmpstr,buf+1);
d1151 1
a1151 13

    if (s - s_start >= sizeof(buf)) {	/* Ooops! */
	if (usermess)
	    fputs(SvPVX(tmpstr), stderr);
	else
	    fputs(buf, stderr);
	fputs("panic: message overflow - memory corrupted!\n",stderr);
	my_exit(1);
    }
    if (usermess)
	return SvPVX(tmpstr);
    else
	return buf;
d1154 3
a1156 39
/*VARARGS1*/
void croak(pat,a1,a2,a3,a4)
char *pat;
long a1, a2, a3, a4;
{
    char *tmps;
    char *message;
    HV *stash;
    GV *gv;
    CV *cv;

    message = mess(pat,a1,a2,a3,a4);
    if (diehook && (cv = sv_2cv(diehook, &stash, &gv, 0)) && !CvDEPTH(cv)) {
	dSP;

	PUSHMARK(sp);
	EXTEND(sp, 1);
	PUSHs(sv_2mortal(newSVpv(message,0)));
	PUTBACK;
	perl_call_sv((SV*)cv, G_DISCARD);
    }
    if (in_eval) {
	restartop = die_where(message);
	Siglongjmp(top_env, 3);
    }
    fputs(message,stderr);
    (void)Fflush(stderr);
    if (e_tmpname) {
	if (e_fp) {
	    fclose(e_fp);
	    e_fp = Nullfp;
	}
	(void)UNLINK(e_tmpname);
	Safefree(e_tmpname);
	e_tmpname = Nullch;
    }
    statusvalue = SHIFTSTATUS(statusvalue);
#ifdef VMS
    my_exit((U32)vaxc$errno?vaxc$errno:errno?errno:statusvalue?statusvalue:SS$_ABORT);
d1158 5
a1162 1
    my_exit((U32)((errno&255)?errno:((statusvalue&255)?statusvalue:255)));
a1163 6
}

/*VARARGS1*/
void warn(pat,a1,a2,a3,a4)
char *pat;
long a1, a2, a3, a4;
d1165 1
d1167 2
a1168 1
    SV *sv;
d1173 6
a1178 16
    message = mess(pat,a1,a2,a3,a4);
    if (warnhook && (cv = sv_2cv(warnhook, &stash, &gv, 0)) && !CvDEPTH(cv)) {
	dSP;

	PUSHMARK(sp);
	EXTEND(sp, 1);
	PUSHs(sv_2mortal(newSVpv(message,0)));
	PUTBACK;
	perl_call_sv((SV*)cv, G_DISCARD);
    }
    else {
	fputs(message,stderr);
#ifdef LEAKTEST
	DEBUG_L(xstat());
#endif
	(void)Fflush(stderr);
a1179 3
}

#else /* !defined(I_STDARG) && !defined(I_VARARGS) */
d1182 1
a1182 2
char *
mess(char *pat, va_list *args)
d1184 1
a1184 5
/*VARARGS0*/
char *
mess(pat, args)
    char *pat;
    va_list *args;
d1186 2
a1187 25
{
    char *s;
    char *s_start;
    SV *tmpstr;
    I32 usermess;
#ifndef HAS_VPRINTF
#ifdef USE_CHAR_VSPRINTF
    char *vsprintf();
#else
    I32 vsprintf();
#endif
#endif

    s = s_start = buf;
    usermess = strEQ(pat, "%s");
    if (usermess) {
	tmpstr = sv_newmortal();
	sv_setpv(tmpstr, va_arg(*args, char *));
	*s++ = SvPVX(tmpstr)[SvCUR(tmpstr)-1];
    }
    else {
	(void) vsprintf(s,pat,*args);
	s += strlen(s);
    }
    va_end(*args);
d1189 23
a1211 20
    if (s[-1] != '\n') {
	if (dirty)
	    strcpy(s, " during global destruction.\n");
	else {
	    if (curcop->cop_line) {
		(void)sprintf(s," at %s line %ld",
		  SvPVX(GvSV(curcop->cop_filegv)), (long)curcop->cop_line);
		s += strlen(s);
	    }
	    if (GvIO(last_in_gv) && IoLINES(GvIOp(last_in_gv))) {
		bool line_mode = (RsSIMPLE(rs) &&
				  SvLEN(rs) == 1 && *SvPVX(rs) == '\n');
		(void)sprintf(s,", <%s> %s %ld",
		  last_in_gv == argvgv ? "" : GvNAME(last_in_gv),
		  line_mode ? "line" : "chunk", 
		  (long)IoLINES(GvIOp(last_in_gv)));
		s += strlen(s);
	    }
	    (void)strcpy(s,".\n");
	    s += 2;
a1212 2
	if (usermess)
	    sv_catpv(tmpstr,buf+1);
d1215 4
a1218 12
    if (s - s_start >= sizeof(buf)) {	/* Ooops! */
	if (usermess)
	    fputs(SvPVX(tmpstr), stderr);
	else
	    fputs(buf, stderr);
	fputs("panic: message overflow - memory corrupted!\n",stderr);
	my_exit(1);
    }
    if (usermess)
	return SvPVX(tmpstr);
    else
	return buf;
d1223 1
a1223 1
croak(char* pat, ...)
d1245 21
a1265 2
    if (diehook && (cv = sv_2cv(diehook, &stash, &gv, 0)) && !CvDEPTH(cv)) {
	dSP;
d1267 2
a1268 5
	PUSHMARK(sp);
	EXTEND(sp, 1);
	PUSHs(sv_2mortal(newSVpv(message,0)));
	PUTBACK;
	perl_call_sv((SV*)cv, G_DISCARD);
d1272 1
a1272 12
	Siglongjmp(top_env, 3);
    }
    fputs(message,stderr);
    (void)Fflush(stderr);
    if (e_tmpname) {
	if (e_fp) {
	    fclose(e_fp);
	    e_fp = Nullfp;
	}
	(void)UNLINK(e_tmpname);
	Safefree(e_tmpname);
	e_tmpname = Nullch;
d1274 3
a1276 6
    statusvalue = SHIFTSTATUS(statusvalue);
#ifdef VMS
    my_exit((U32)(vaxc$errno?vaxc$errno:(statusvalue?statusvalue:44)));
#else
    my_exit((U32)((errno&255)?errno:((statusvalue&255)?statusvalue:255)));
#endif
d1281 1
a1281 1
warn(char* pat,...)
d1285 1
a1285 1
    char *pat;
d1303 21
a1323 2
    if (warnhook && (cv = sv_2cv(warnhook, &stash, &gv, 0)) && !CvDEPTH(cv)) {
	dSP;
d1325 3
a1327 5
	PUSHMARK(sp);
	EXTEND(sp, 1);
	PUSHs(sv_2mortal(newSVpv(message,0)));
	PUTBACK;
	perl_call_sv((SV*)cv, G_DISCARD);
d1329 1
a1329 2
    else {
	fputs(message,stderr);
d1331 1
a1331 1
	DEBUG_L(xstat());
d1333 1
a1333 2
	(void)Fflush(stderr);
    }
a1334 1
#endif /* !defined(I_STDARG) && !defined(I_VARARGS) */
d1337 1
d1358 1
d1385 68
d1460 7
a1466 1
	if (strnEQ(environ[i],nam,len) && environ[i][len] == '=')
d1471 1
d1509 15
d1538 1
a1538 1
#ifndef HAS_MEMCMP
d1541 2
a1542 2
register unsigned char *s1;
register unsigned char *s2;
d1545 2
d1550 1
a1550 1
	if (tmp = *s1++ - *s2++)
d1555 1
a1555 1
#endif /* HAS_MEMCMP */
d1566 3
a1568 1
char *dest, *pat, *args;
a1586 8
int
vfprintf(fd, pat, args)
FILE *fd;
char *pat, *args;
{
    _doprnt(pat, args, fd);
    return 0;		/* wrong, but perl doesn't use the return value */
}
d1740 3
a1742 3
#if  !defined(DOSISH) && !defined(VMS)  /* VMS' my_popen() is in
					   VMS.c, same with OS/2. */
FILE *
d1753 5
d1762 3
a1764 5
    if (tainting) {
	if (doexec) {
	    taint_env();
	    taint_proper("Insecure %s%s", "EXEC");
	}
d1800 1
a1800 1
	    sv_setiv(GvSV(tmpgv),(I32)getpid());
d1818 1
a1818 1
    return fdopen(p[this], mode);
d1821 1
a1821 1
#if defined(atarist)
d1823 1
a1823 1
FILE *
d1828 3
a1830 1
    return popen(cmd, mode);
d1843 1
a1843 1
    fprintf(stderr,"%s", s);
d1846 1
a1846 1
	    fprintf(stderr," %d",fd);
d1848 1
a1848 1
    fprintf(stderr,"\n");
d1864 2
a1865 1
    int fdtmp[256];
d1872 7
a1878 1
    while ((fd = dup(oldfd)) != newfd && fd >= 0) /* good enough for low fd's */
d1880 1
d1888 115
a2002 1
#if  !defined(DOSISH) && !defined(VMS)  /* VMS' my_popen() is in VMS.c */
d2005 1
a2005 1
FILE *ptr;
d2007 1
a2007 1
    Signal_t (*hstat)(), (*istat)(), (*qstat)();
d2011 5
d2017 1
a2017 1
    svp = av_fetch(fdpid,fileno(ptr),TRUE);
d2021 11
a2031 1
    fclose(ptr);
d2035 3
a2037 3
    hstat = signal(SIGHUP, SIG_IGN);
    istat = signal(SIGINT, SIG_IGN);
    qstat = signal(SIGQUIT, SIG_IGN);
d2041 8
a2048 4
    signal(SIGHUP, hstat);
    signal(SIGINT, istat);
    signal(SIGQUIT, qstat);
    return(pid < 0 ? pid : status);
d2061 1
a2061 1
    char spid[16];
d2088 4
d2093 2
a2094 2
#else
#ifdef HAS_WAIT4
d2096 3
a2098 1
#else
a2111 1
#endif
d2122 1
a2122 1
    char spid[16];
d2131 1
a2131 1
#if defined(atarist) || defined(OS2)
d2133 5
d2140 2
a2141 1
FILE *ptr;
d2143 5
a2147 1
    return pclose(ptr);
a2196 23
/* Look for MAX and MIN integral values.  If we can't find them,
   we'll use 32-bit two's complement defaults.
*/
#ifndef LONG_MAX
#  ifdef MAXLONG    /* Often used in <values.h> */
#    define LONG_MAX MAXLONG
#  else
#    define LONG_MAX        2147483647L
#  endif
#endif

#ifndef LONG_MIN
#    define LONG_MIN        (-LONG_MAX - 1)
#endif

#ifndef ULONG_MAX
#  ifdef MAXULONG 
#    define LONG_MAX MAXULONG
#  else
#    define ULONG_MAX       4294967295L
#  endif
#endif

d2207 8
a2214 2
#ifndef MY_ULONG_MAX
#  define MY_ULONG_MAX ((UV)LONG_MAX * (UV)2 + (UV)1)
d2221 4
a2224 4
    if (f >= LONG_MAX)
	return (I32) LONG_MAX;
    if (f <= LONG_MIN)
	return (I32) LONG_MIN;
d2232 4
a2235 4
    if (f >= LONG_MAX)
	return (IV) LONG_MAX;
    if (f <= LONG_MIN)
	return (IV) LONG_MIN;
d2243 2
a2244 2
    if (f >= MY_ULONG_MAX)
	return (UV) MY_ULONG_MAX;
d2260 1
a2260 4
#ifndef MAXPATHLEN
#define MAXPATHLEN 1024
#endif
    char tmpbuf[MAXPATHLEN+1];
d2273 1
a2273 1
	strcpy(tmpbuf,".");
d2275 2
a2276 2
	strncpy(tmpbuf, a, fa - a);
    if (Stat(tmpbuf, &tmpstatbuf1) < 0)
d2279 1
a2279 1
	strcpy(tmpbuf,".");
d2281 2
a2282 2
	strncpy(tmpbuf, b, fb - b);
    if (Stat(tmpbuf, &tmpstatbuf2) < 0)
d2289 1
a2289 1
unsigned long
d2296 2
a2297 1
    register unsigned long retval = 0;
d2300 6
a2305 2
	retval <<= 3;
	retval |= *s++ - '0';
d2314 1
a2314 1
unsigned long
d2321 2
a2322 1
    register unsigned long retval = 0;
d2326 6
a2331 2
	retval <<= 4;
	retval |= (tmp - hexdigit) & 15;
d2337 14
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1999, Larry Wall
d22 1
a22 5
#ifndef SIG_ERR
# define SIG_ERR ((Sighandler_t) -1)
#endif

/* XXX If this causes problems, set i_unistd=undef in the hint file.  */
d26 1
d32 4
a49 4
#ifdef I_SYS_WAIT
#  include <sys/wait.h>
#endif

d53 1
a53 7

static void xstat _((int));
long xcount[MAXXCOUNT];
long lastxcount[MAXXCOUNT];
long xycount[MAXXCOUNT][MAXYCOUNT];
long lastxycount[MAXXCOUNT][MAXYCOUNT];

d56 1
a56 1
#ifndef MYMALLOC
a62 1
 * XXX This advice seems to be widely ignored :-(   --AD  August 1996.
d65 7
a71 2
Malloc_t
safemalloc(MEM_SIZE size)
d73 2
a74 2
    Malloc_t ptr;
#ifdef HAS_64K_LIMIT
d76 1
a76 1
		PerlIO_printf(PerlIO_stderr(), "Allocation too large: %lx\n", size) FLUSH;
d79 1
a79 1
#endif /* HAS_64K_LIMIT */
d84 1
a84 1
    ptr = PerlMem_malloc(size?size:1);	/* malloc(0) is NASTY on our system */
d86 1
a86 1
    DEBUG_m(PerlIO_printf(Perl_debug_log, "0x%x: (%05d) malloc %ld bytes\n",ptr,PL_an++,(long)size));
d88 1
a88 1
    DEBUG_m(PerlIO_printf(Perl_debug_log, "0x%lx: (%05d) malloc %ld bytes\n",ptr,PL_an++,(long)size));
d92 1
a92 1
    else if (PL_nomemok)
d95 1
a95 1
	PerlIO_puts(PerlIO_stderr(),no_mem) FLUSH;
a96 1
        return Nullch;
d103 8
a110 2
Malloc_t
saferealloc(Malloc_t where,MEM_SIZE size)
d112 1
a112 1
    Malloc_t ptr;
d114 1
a114 1
    Malloc_t PerlMem_realloc();
d117 6
a122 12
#ifdef HAS_64K_LIMIT 
    if (size > 0xffff) {
	PerlIO_printf(PerlIO_stderr(),
		      "Reallocation too large: %lx\n", size) FLUSH;
	my_exit(1);
    }
#endif /* HAS_64K_LIMIT */
    if (!size) {
	safefree(where);
	return NULL;
    }

d124 1
a124 1
	return safemalloc(size);
d129 1
a129 1
    ptr = PerlMem_realloc(where,size);
d133 2
a134 2
	PerlIO_printf(Perl_debug_log, "0x%x: (%05d) rfree\n",where,PL_an++);
	PerlIO_printf(Perl_debug_log, "0x%x: (%05d) realloc %ld bytes\n",ptr,PL_an++,(long)size);
d138 2
a139 2
	PerlIO_printf(Perl_debug_log, "0x%lx: (%05d) rfree\n",where,PL_an++);
	PerlIO_printf(Perl_debug_log, "0x%lx: (%05d) realloc %ld bytes\n",ptr,PL_an++,(long)size);
d145 1
a145 1
    else if (PL_nomemok)
d148 1
a148 1
	PerlIO_puts(PerlIO_stderr(),no_mem) FLUSH;
a149 1
	return Nullch;
d156 3
a158 2
Free_t
safefree(Malloc_t where)
d161 1
a161 1
    DEBUG_m( PerlIO_printf(Perl_debug_log, "0x%x: (%05d) free\n",(char *) where,PL_an++));
d163 1
a163 1
    DEBUG_m( PerlIO_printf(Perl_debug_log, "0x%lx: (%05d) free\n",(char *) where,PL_an++));
d167 1
a167 39
	PerlMem_free(where);
    }
}

/* safe version of calloc */

Malloc_t
safecalloc(MEM_SIZE count, MEM_SIZE size)
{
    Malloc_t ptr;

#ifdef HAS_64K_LIMIT
    if (size * count > 0xffff) {
	PerlIO_printf(PerlIO_stderr(),
		      "Allocation too large: %lx\n", size * count) FLUSH;
	my_exit(1);
    }
#endif /* HAS_64K_LIMIT */
#ifdef DEBUGGING
    if ((long)size < 0 || (long)count < 0)
	croak("panic: calloc");
#endif
    size *= count;
    ptr = PerlMem_malloc(size?size:1);	/* malloc(0) is NASTY on our system */
#if !(defined(I286) || defined(atarist))
    DEBUG_m(PerlIO_printf(Perl_debug_log, "0x%x: (%05d) calloc %ld  x %ld bytes\n",ptr,PL_an++,(long)count,(long)size));
#else
    DEBUG_m(PerlIO_printf(Perl_debug_log, "0x%lx: (%05d) calloc %ld x %ld bytes\n",ptr,PL_an++,(long)count,(long)size));
#endif
    if (ptr != Nullch) {
	memset((void*)ptr, 0, size);
	return ptr;
    }
    else if (PL_nomemok)
	return Nullch;
    else {
	PerlIO_puts(PerlIO_stderr(),no_mem) FLUSH;
	my_exit(1);
	return Nullch;
a168 1
    /*NOTREACHED*/
d171 1
a171 1
#endif /* !MYMALLOC */
d175 1
a175 7
struct mem_test_strut {
    union {
	long type;
	char c[2];
    } u;
    long size;
};
d177 13
a189 1
#    define ALIGN sizeof(struct mem_test_strut)
d191 7
a197 42
#    define sizeof_chunk(ch) (((struct mem_test_strut*) (ch))->size)
#    define typeof_chunk(ch) \
	(((struct mem_test_strut*) (ch))->u.c[0] + ((struct mem_test_strut*) (ch))->u.c[1]*100)
#    define set_typeof_chunk(ch,t) \
	(((struct mem_test_strut*) (ch))->u.c[0] = t % 100, ((struct mem_test_strut*) (ch))->u.c[1] = t / 100)
#define SIZE_TO_Y(size) ( (size) > MAXY_SIZE				\
			  ? MAXYCOUNT - 1 				\
			  : ( (size) > 40 				\
			      ? ((size) - 1)/8 + 5			\
			      : ((size) - 1)/4))

Malloc_t
safexmalloc(I32 x, MEM_SIZE size)
{
    register char* where = (char*)safemalloc(size + ALIGN);

    xcount[x] += size;
    xycount[x][SIZE_TO_Y(size)]++;
    set_typeof_chunk(where, x);
    sizeof_chunk(where) = size;
    return (Malloc_t)(where + ALIGN);
}

Malloc_t
safexrealloc(Malloc_t wh, MEM_SIZE size)
{
    char *where = (char*)wh;

    if (!wh)
	return safexmalloc(0,size);
    
    {
	MEM_SIZE old = sizeof_chunk(where - ALIGN);
	int t = typeof_chunk(where - ALIGN);
	register char* new = (char*)saferealloc(where - ALIGN, size + ALIGN);
    
	xycount[t][SIZE_TO_Y(old)]--;
	xycount[t][SIZE_TO_Y(size)]++;
	xcount[t] += size - old;
	sizeof_chunk(new) = size;
	return (Malloc_t)(new + ALIGN);
    }
d201 2
a202 1
safexfree(Malloc_t wh)
d205 1
a205 3
    char *where = (char*)wh;
    MEM_SIZE size;
    
a208 1
    size = sizeof_chunk(where);
d210 1
a210 2
    xcount[x] -= size;
    xycount[x][SIZE_TO_Y(size)]--;
a213 12
Malloc_t
safexcalloc(I32 x,MEM_SIZE count, MEM_SIZE size)
{
    register char * where = (char*)safexmalloc(x, size * count + ALIGN);
    xcount[x] += size;
    xycount[x][SIZE_TO_Y(size)]++;
    memset((void*)(where + ALIGN), 0, size * count);
    set_typeof_chunk(where, x);
    sizeof_chunk(where) = size;
    return (Malloc_t)(where + ALIGN);
}

d215 1
a215 1
xstat(int flag)
d217 1
a217 2
    register I32 i, j, total = 0;
    I32 subtot[MAXYCOUNT];
a218 5
    for (j = 0; j < MAXYCOUNT; j++) {
	subtot[j] = 0;
    }
    
    PerlIO_printf(PerlIO_stderr(), "   Id  subtot   4   8  12  16  20  24  28  32  36  40  48  56  64  72  80 80+\n", total);
d220 2
a221 11
	total += xcount[i];
	for (j = 0; j < MAXYCOUNT; j++) {
	    subtot[j] += xycount[i][j];
	}
	if (flag == 0
	    ? xcount[i]			/* Have something */
	    : (flag == 2 
	       ? xcount[i] != lastxcount[i] /* Changed */
	       : xcount[i] > lastxcount[i])) { /* Growed */
	    PerlIO_printf(PerlIO_stderr(),"%2d %02d %7ld ", i / 100, i % 100, 
			  flag == 2 ? xcount[i] - lastxcount[i] : xcount[i]);
a222 26
	    for (j = 0; j < MAXYCOUNT; j++) {
		if ( flag == 0 
		     ? xycount[i][j]	/* Have something */
		     : (flag == 2 
			? xycount[i][j] != lastxycount[i][j] /* Changed */
			: xycount[i][j] > lastxycount[i][j])) {	/* Growed */
		    PerlIO_printf(PerlIO_stderr(),"%3ld ", 
				  flag == 2 
				  ? xycount[i][j] - lastxycount[i][j] 
				  : xycount[i][j]);
		    lastxycount[i][j] = xycount[i][j];
		} else {
		    PerlIO_printf(PerlIO_stderr(), "  . ", xycount[i][j]);
		}
	    }
	    PerlIO_printf(PerlIO_stderr(), "\n");
	}
    }
    if (flag != 2) {
	PerlIO_printf(PerlIO_stderr(), "Total %7ld ", total);
	for (j = 0; j < MAXYCOUNT; j++) {
	    if (subtot[j]) {
		PerlIO_printf(PerlIO_stderr(), "%3ld ", subtot[j]);
	    } else {
		PerlIO_printf(PerlIO_stderr(), "  . ");
	    }
a223 1
	PerlIO_printf(PerlIO_stderr(), "\n");	
d232 6
a237 1
delimcpy(register char *to, register char *toend, register char *from, register char *fromend, register int delim, I32 *retlen)
d239 3
a241 2
    register I32 tolen;
    for (tolen = 0; from < fromend; from++, tolen++) {
d245 2
a246 6
	    else {
		if (to < toend)
		    *to++ = *from;
		tolen++;
		from++;
	    }
d250 1
a250 2
	if (to < toend)
	    *to++ = *from;
d252 2
a253 3
    if (to < toend)
	*to = '\0';
    *retlen = tolen;
d261 3
a263 1
instr(register char *big, register char *little)
d293 5
a297 1
ninstr(register char *big, register char *bigend, char *little, char *lend)
d326 5
a330 1
rninstr(register char *big, char *bigend, char *little, char *lend)
d356 1
a356 126
/*
 * Set up for a new ctype locale.
 */
void
perl_new_ctype(char *newctype)
{
#ifdef USE_LOCALE_CTYPE

    int i;

    for (i = 0; i < 256; i++) {
	if (isUPPER_LC(i))
	    fold_locale[i] = toLOWER_LC(i);
	else if (isLOWER_LC(i))
	    fold_locale[i] = toUPPER_LC(i);
	else
	    fold_locale[i] = i;
    }

#endif /* USE_LOCALE_CTYPE */
}

/*
 * Set up for a new collation locale.
 */
void
perl_new_collate(char *newcoll)
{
#ifdef USE_LOCALE_COLLATE

    if (! newcoll) {
	if (PL_collation_name) {
	    ++PL_collation_ix;
	    Safefree(PL_collation_name);
	    PL_collation_name = NULL;
	    PL_collation_standard = TRUE;
	    PL_collxfrm_base = 0;
	    PL_collxfrm_mult = 2;
	}
	return;
    }

    if (! PL_collation_name || strNE(PL_collation_name, newcoll)) {
	++PL_collation_ix;
	Safefree(PL_collation_name);
	PL_collation_name = savepv(newcoll);
	PL_collation_standard = (strEQ(newcoll, "C") || strEQ(newcoll, "POSIX"));

	{
	  /*  2: at most so many chars ('a', 'b'). */
	  /* 50: surely no system expands a char more. */
#define XFRMBUFSIZE  (2 * 50)
	  char xbuf[XFRMBUFSIZE];
	  Size_t fa = strxfrm(xbuf, "a",  XFRMBUFSIZE);
	  Size_t fb = strxfrm(xbuf, "ab", XFRMBUFSIZE);
	  SSize_t mult = fb - fa;
	  if (mult < 1)
	      croak("strxfrm() gets absurd");
	  PL_collxfrm_base = (fa > mult) ? (fa - mult) : 0;
	  PL_collxfrm_mult = mult;
	}
    }

#endif /* USE_LOCALE_COLLATE */
}

/*
 * Set up for a new numeric locale.
 */
void
perl_new_numeric(char *newnum)
{
#ifdef USE_LOCALE_NUMERIC

    if (! newnum) {
	if (PL_numeric_name) {
	    Safefree(PL_numeric_name);
	    PL_numeric_name = NULL;
	    PL_numeric_standard = TRUE;
	    PL_numeric_local = TRUE;
	}
	return;
    }

    if (! PL_numeric_name || strNE(PL_numeric_name, newnum)) {
	Safefree(PL_numeric_name);
	PL_numeric_name = savepv(newnum);
	PL_numeric_standard = (strEQ(newnum, "C") || strEQ(newnum, "POSIX"));
	PL_numeric_local = TRUE;
    }

#endif /* USE_LOCALE_NUMERIC */
}

void
perl_set_numeric_standard(void)
{
#ifdef USE_LOCALE_NUMERIC

    if (! PL_numeric_standard) {
	setlocale(LC_NUMERIC, "C");
	PL_numeric_standard = TRUE;
	PL_numeric_local = FALSE;
    }

#endif /* USE_LOCALE_NUMERIC */
}

void
perl_set_numeric_local(void)
{
#ifdef USE_LOCALE_NUMERIC

    if (! PL_numeric_local) {
	setlocale(LC_NUMERIC, PL_numeric_name);
	PL_numeric_standard = FALSE;
	PL_numeric_local = TRUE;
    }

#endif /* USE_LOCALE_NUMERIC */
}


/*
 * Initialize locale awareness.
 */
d358 2
a359 1
perl_init_i18nl10n(int printwarn)
d367 5
d373 10
a382 159
#ifdef USE_LOCALE

#ifdef USE_LOCALE_CTYPE
    char *curctype   = NULL;
#endif /* USE_LOCALE_CTYPE */
#ifdef USE_LOCALE_COLLATE
    char *curcoll    = NULL;
#endif /* USE_LOCALE_COLLATE */
#ifdef USE_LOCALE_NUMERIC
    char *curnum     = NULL;
#endif /* USE_LOCALE_NUMERIC */
#ifdef __GLIBC__
    char *language   = PerlEnv_getenv("LANGUAGE");
#endif
    char *lc_all     = PerlEnv_getenv("LC_ALL");
    char *lang       = PerlEnv_getenv("LANG");
    bool setlocale_failure = FALSE;

#ifdef LOCALE_ENVIRON_REQUIRED

    /*
     * Ultrix setlocale(..., "") fails if there are no environment
     * variables from which to get a locale name.
     */

    bool done = FALSE;

#ifdef LC_ALL
    if (lang) {
	if (setlocale(LC_ALL, ""))
	    done = TRUE;
	else
	    setlocale_failure = TRUE;
    }
    if (!setlocale_failure) {
#ifdef USE_LOCALE_CTYPE
	if (! (curctype =
	       setlocale(LC_CTYPE,
			 (!done && (lang || PerlEnv_getenv("LC_CTYPE")))
				    ? "" : Nullch)))
	    setlocale_failure = TRUE;
#endif /* USE_LOCALE_CTYPE */
#ifdef USE_LOCALE_COLLATE
	if (! (curcoll =
	       setlocale(LC_COLLATE,
			 (!done && (lang || PerlEnv_getenv("LC_COLLATE")))
				   ? "" : Nullch)))
	    setlocale_failure = TRUE;
#endif /* USE_LOCALE_COLLATE */
#ifdef USE_LOCALE_NUMERIC
	if (! (curnum =
	       setlocale(LC_NUMERIC,
			 (!done && (lang || PerlEnv_getenv("LC_NUMERIC")))
				  ? "" : Nullch)))
	    setlocale_failure = TRUE;
#endif /* USE_LOCALE_NUMERIC */
    }

#endif /* LC_ALL */

#endif /* !LOCALE_ENVIRON_REQUIRED */

#ifdef LC_ALL
    if (! setlocale(LC_ALL, ""))
	setlocale_failure = TRUE;
#endif /* LC_ALL */

    if (!setlocale_failure) {
#ifdef USE_LOCALE_CTYPE
	if (! (curctype = setlocale(LC_CTYPE, "")))
	    setlocale_failure = TRUE;
#endif /* USE_LOCALE_CTYPE */
#ifdef USE_LOCALE_COLLATE
	if (! (curcoll = setlocale(LC_COLLATE, "")))
	    setlocale_failure = TRUE;
#endif /* USE_LOCALE_COLLATE */
#ifdef USE_LOCALE_NUMERIC
	if (! (curnum = setlocale(LC_NUMERIC, "")))
	    setlocale_failure = TRUE;
#endif /* USE_LOCALE_NUMERIC */
    }

    if (setlocale_failure) {
	char *p;
	bool locwarn = (printwarn > 1 || 
			printwarn &&
			(!(p = PerlEnv_getenv("PERL_BADLANG")) || atoi(p)));

	if (locwarn) {
#ifdef LC_ALL
  
	    PerlIO_printf(PerlIO_stderr(),
	       "perl: warning: Setting locale failed.\n");

#else /* !LC_ALL */
  
	    PerlIO_printf(PerlIO_stderr(),
	       "perl: warning: Setting locale failed for the categories:\n\t");
#ifdef USE_LOCALE_CTYPE
	    if (! curctype)
		PerlIO_printf(PerlIO_stderr(), "LC_CTYPE ");
#endif /* USE_LOCALE_CTYPE */
#ifdef USE_LOCALE_COLLATE
	    if (! curcoll)
		PerlIO_printf(PerlIO_stderr(), "LC_COLLATE ");
#endif /* USE_LOCALE_COLLATE */
#ifdef USE_LOCALE_NUMERIC
	    if (! curnum)
		PerlIO_printf(PerlIO_stderr(), "LC_NUMERIC ");
#endif /* USE_LOCALE_NUMERIC */
	    PerlIO_printf(PerlIO_stderr(), "\n");

#endif /* LC_ALL */

	    PerlIO_printf(PerlIO_stderr(),
		"perl: warning: Please check that your locale settings:\n");

#ifdef __GLIBC__
	    PerlIO_printf(PerlIO_stderr(),
			  "\tLANGUAGE = %c%s%c,\n",
			  language ? '"' : '(',
			  language ? language : "unset",
			  language ? '"' : ')');
#endif

	    PerlIO_printf(PerlIO_stderr(),
			  "\tLC_ALL = %c%s%c,\n",
			  lc_all ? '"' : '(',
			  lc_all ? lc_all : "unset",
			  lc_all ? '"' : ')');

	    {
	      char **e;
	      for (e = environ; *e; e++) {
		  if (strnEQ(*e, "LC_", 3)
			&& strnNE(*e, "LC_ALL=", 7)
			&& (p = strchr(*e, '=')))
		      PerlIO_printf(PerlIO_stderr(), "\t%.*s = \"%s\",\n",
				    (int)(p - *e), *e, p + 1);
	      }
	    }

	    PerlIO_printf(PerlIO_stderr(),
			  "\tLANG = %c%s%c\n",
			  lang ? '"' : '(',
			  lang ? lang : "unset",
			  lang ? '"' : ')');

	    PerlIO_printf(PerlIO_stderr(),
			  "    are supported and installed on your system.\n");
	}

#ifdef LC_ALL

	if (setlocale(LC_ALL, "C")) {
	    if (locwarn)
		PerlIO_printf(PerlIO_stderr(),
      "perl: warning: Falling back to the standard locale (\"C\").\n");
	    ok = 0;
d384 2
a385 4
	else {
	    if (locwarn)
		PerlIO_printf(PerlIO_stderr(),
      "perl: warning: Failed to fall back to the standard locale (\"C\").\n");
d387 1
a387 48
	}

#else /* ! LC_ALL */

	if (0
#ifdef USE_LOCALE_CTYPE
	    || !(curctype || setlocale(LC_CTYPE, "C"))
#endif /* USE_LOCALE_CTYPE */
#ifdef USE_LOCALE_COLLATE
	    || !(curcoll || setlocale(LC_COLLATE, "C"))
#endif /* USE_LOCALE_COLLATE */
#ifdef USE_LOCALE_NUMERIC
	    || !(curnum || setlocale(LC_NUMERIC, "C"))
#endif /* USE_LOCALE_NUMERIC */
	    )
	{
	    if (locwarn)
		PerlIO_printf(PerlIO_stderr(),
      "perl: warning: Cannot fall back to the standard locale (\"C\").\n");
	    ok = -1;
	}

#endif /* ! LC_ALL */

#ifdef USE_LOCALE_CTYPE
	curctype = setlocale(LC_CTYPE, Nullch);
#endif /* USE_LOCALE_CTYPE */
#ifdef USE_LOCALE_COLLATE
	curcoll = setlocale(LC_COLLATE, Nullch);
#endif /* USE_LOCALE_COLLATE */
#ifdef USE_LOCALE_NUMERIC
	curnum = setlocale(LC_NUMERIC, Nullch);
#endif /* USE_LOCALE_NUMERIC */
    }

#ifdef USE_LOCALE_CTYPE
    perl_new_ctype(curctype);
#endif /* USE_LOCALE_CTYPE */

#ifdef USE_LOCALE_COLLATE
    perl_new_collate(curcoll);
#endif /* USE_LOCALE_COLLATE */

#ifdef USE_LOCALE_NUMERIC
    perl_new_numeric(curnum);
#endif /* USE_LOCALE_NUMERIC */

#endif /* USE_LOCALE */
d389 6
a397 66
/* Backwards compatibility. */
int
perl_init_i18nl14n(int printwarn)
{
    return perl_init_i18nl10n(printwarn);
}

#ifdef USE_LOCALE_COLLATE

/*
 * mem_collxfrm() is a bit like strxfrm() but with two important
 * differences. First, it handles embedded NULs. Second, it allocates
 * a bit more memory than needed for the transformed data itself.
 * The real transformed data begins at offset sizeof(collationix).
 * Please see sv_collxfrm() to see how this is used.
 */
char *
mem_collxfrm(const char *s, STRLEN len, STRLEN *xlen)
{
    char *xbuf;
    STRLEN xAlloc, xin, xout; /* xalloc is a reserved word in VC */

    /* the first sizeof(collationix) bytes are used by sv_collxfrm(). */
    /* the +1 is for the terminating NUL. */

    xAlloc = sizeof(PL_collation_ix) + PL_collxfrm_base + (PL_collxfrm_mult * len) + 1;
    New(171, xbuf, xAlloc, char);
    if (! xbuf)
	goto bad;

    *(U32*)xbuf = PL_collation_ix;
    xout = sizeof(PL_collation_ix);
    for (xin = 0; xin < len; ) {
	SSize_t xused;

	for (;;) {
	    xused = strxfrm(xbuf + xout, s + xin, xAlloc - xout);
	    if (xused == -1)
		goto bad;
	    if (xused < xAlloc - xout)
		break;
	    xAlloc = (2 * xAlloc) + 1;
	    Renew(xbuf, xAlloc, char);
	    if (! xbuf)
		goto bad;
	}

	xin += strlen(s + xin) + 1;
	xout += xused;

	/* Embedded NULs are understood but silently skipped
	 * because they make no sense in locale collation. */
    }

    xbuf[xout] = '\0';
    *xlen = xout - sizeof(PL_collation_ix);
    return xbuf;

  bad:
    Safefree(xbuf);
    *xlen = 0;
    return NULL;
}

#endif /* USE_LOCALE_COLLATE */

d399 3
a401 1
fbm_compile(SV *sv, U32 flags /* not used yet */)
d403 2
a404 2
    register U8 *s;
    register U8 *table;
d406 1
a406 1
    STRLEN len;
d410 1
a410 3
    s = (U8*)SvPV_force(sv, len);
    (void)SvUPGRADE(sv, SVt_PVBM);
    if (len > 255 || len == 0)	/* TAIL might be on on a zero-length string. */
d412 25
a436 14
    if (len > 2) {
	Sv_Grow(sv,len + 258);
	table = (unsigned char*)(SvPVX(sv) + len + 1);
	s = table - 2;
	for (i = 0; i < 256; i++) {
	    table[i] = len;
	}
	i = 0;
	while (s >= (unsigned char*)(SvPVX(sv)))
	    {
		if (table[*s] == len)
		    table[*s] = i;
		s--,i++;
	    }
d438 2
a439 1
    sv_magic(sv, Nullsv, 'B', Nullch, 0);	/* deep magic */
d443 19
a461 4
    for (i = 0; i < len; i++) {
	if (freq[s[i]] < frequency) {
	    rarest = i;
	    frequency = freq[s[i]];
d466 1
a466 1
    DEBUG_r(PerlIO_printf(Perl_debug_log, "rarest char %c at %d\n",BmRARE(sv),BmPREVIOUS(sv)));
d470 4
a473 1
fbm_instr(unsigned char *big, register unsigned char *bigend, SV *littlestr, U32 flags)
d486 1
a486 15
	if (!len) {
	    if (SvTAIL(littlestr)) {	/* Can be only 0-len constant
					   substr => we can ignore SvVALID */
		if (PL_multiline) {
		    char *t = "\n";
		    if ((s = (unsigned char*)ninstr((char*)big, (char*)bigend,
			 			    t, t + len))) {
			return (char*)s;
		    }
		}
		if (bigend > big && bigend[-1] == '\n')
		    return (char *)(bigend - 1);
		else
		    return (char *) bigend;
	    }
a487 1
	}
d492 1
a492 1
    if (SvTAIL(littlestr) && !PL_multiline) {	/* tail anchored? */
d496 14
a509 25
	s = bigend - littlelen;
	if (s > big
	    && bigend[-1] == '\n' 
	    && s[-1] == *little && memEQ((char*)s - 1,(char*)little,littlelen))
	    return (char*)s - 1;	/* how sweet it is */
	else if (*s == *little && memEQ((char*)s,(char*)little,littlelen))
	    return (char*)s;		/* how sweet it is */
	return Nullch;
    }
    if (littlelen <= 2) {
	unsigned char c1 = (unsigned char)SvPVX(littlestr)[0];
	unsigned char c2 = (unsigned char)SvPVX(littlestr)[1];
	/* This may do extra comparisons if littlelen == 2, but this
	   should be hidden in the noise since we do less indirection. */
	
	s = big;
	bigend -= littlelen;
	while (s <= bigend) {
	    if (s[0] == c1 
		&& (littlelen == 1 || s[1] == c2)
		&& (!SvTAIL(littlestr)
		    || s == bigend
		    || s[littlelen] == '\n')) /* Automatically multiline */
	    {
		return (char*)s;
d511 1
a511 1
	    s++;
a512 1
	return Nullch;
d519 5
a523 4
    if (s < bigend) {
      top2:
	/*SUPPRESS 560*/
	if (tmp = table[*s]) {
d525 4
a528 4
	    if (bigend - s > tmp) {
		s += tmp;
		goto top2;
	    }
d530 2
a531 2
	    if ((s += tmp) < bigend)
		goto top2;
d533 16
a548 1
	    return Nullch;
d550 13
a562 10
	else {
	    tmp = littlelen;	/* less expensive than calling strncmp() */
	    olds = s;
	    while (tmp--) {
		if (*--s == *--little)
		    continue;
	      differ:
		s = olds + 1;	/* here we pay the price for failure */
		little = oldlittle;
		if (s < bigend)	/* fake up continue to outer loop */
d564 1
d567 14
a580 5
	    if (SvTAIL(littlestr)	/* automatically multiline */
		&& olds + 1 != bigend
		&& olds[1] != '\n') 
		goto differ;
	    return (char *)s;
a585 10
/* start_shift, end_shift are positive quantities which give offsets
   of ends of some substring of bigstr.
   If `last' we want the last occurence.
   old_posp is the way of communication between consequent calls if
   the next call needs to find the . 
   The initial *old_posp should be -1.
   Note that we do not take into account SvTAIL, so it may give wrong
   positives if _ALL flag is set.
 */

d587 3
a589 1
screaminstr(SV *bigstr, SV *littlestr, I32 start_shift, I32 end_shift, I32 *old_posp, I32 last)
a590 1
    dTHR;
d597 1
a597 1
    register I32 stop_pos;
a598 1
    I32 found = 0;
d600 1
a600 3
    if (*old_posp == -1
	? (pos = PL_screamfirst[BmRARE(littlestr)]) < 0
	: (((pos = *old_posp), pos += PL_screamnext[pos]) == 0))
a604 1
    /* The value of pos we can start at: */
d607 3
a609 5
    /* The value of pos we can stop at: */
    stop_pos = SvCUR(bigstr) - end_shift - (SvCUR(littlestr) - 1 - previous);
    if (previous + start_shift > stop_pos) return Nullch;
    while (pos < previous + start_shift) {
	if (!(pos += PL_screamnext[pos]))
d613 29
a641 8
    do {
	if (pos >= stop_pos) break;
	if (big[pos-previous] != first)
	    continue;
	for (x=big+pos+1-previous,s=little; s < littleend; /**/ ) {
	    if (*s++ != *x++) {
		s--;
		break;
d643 4
a646 8
	}
	if (s == littleend) {
	    *old_posp = pos;
	    if (!last) return (char *)(big+pos-previous);
	    found = 1;
	}
    } while ( pos += PL_screamnext[pos] );
    return (last && found) ? (char *)(big+(*old_posp)-previous) : Nullch;
d649 29
a677 8
    do {
	if (pos >= stop_pos) break;
	if (big[pos] != first)
	    continue;
	for (x=big+pos+1,s=little; s < littleend; /**/ ) {
	    if (*s++ != *x++) {
		s--;
		break;
d679 6
a684 8
	}
	if (s == littleend) {
	    *old_posp = pos;
	    if (!last) return (char *)(big+pos);
	    found = 1;
	}
    } while ( pos += PL_screamnext[pos] );
    return (last && found) ? (char *)(big+(*old_posp)) : Nullch;
d686 1
d690 4
a693 1
ibcmp(char *s1, char *s2, register I32 len)
a694 2
    register U8 *a = (U8 *)s1;
    register U8 *b = (U8 *)s2;
d696 7
a702 16
	if (*a != *b && *a != fold[*b])
	    return 1;
	a++,b++;
    }
    return 0;
}

I32
ibcmp_locale(char *s1, char *s2, register I32 len)
{
    register U8 *a = (U8 *)s1;
    register U8 *b = (U8 *)s2;
    while (len--) {
	if (*a != *b && *a != fold_locale[*b])
	    return 1;
	a++,b++;
d710 2
a711 1
savepv(char *sv)
d723 3
a725 1
savepvn(char *sv, register I32 len)
d735 1
a735 1
/* the SV for form() and mess() is not kept in an arena */
d737 3
a739 5
STATIC SV *
mess_alloc(void)
{
    SV *sv;
    XPVMG *any;
d741 21
a761 8
    /* Create as PVMG now, to avoid any upgrading later */
    New(905, sv, 1, SV);
    Newz(905, any, 1, XPVMG);
    SvFLAGS(sv) = SVt_PVMG;
    SvANY(sv) = (void*)any;
    SvREFCNT(sv) = 1 << 30; /* practically infinite */
    return sv;
}
d763 36
a798 10
char *
form(const char* pat, ...)
{
    va_list args;
    va_start(args, pat);
    if (!PL_mess_sv)
	PL_mess_sv = mess_alloc();
    sv_vsetpvfn(PL_mess_sv, pat, strlen(pat), &args, Null(SV**), 0, Null(bool*));
    va_end(args);
    return SvPVX(PL_mess_sv);
d801 4
a804 2
char *
mess(const char *pat, va_list *args)
d806 5
a810 2
    SV *sv;
    static char dgd[] = " during global destruction.\n";
d812 24
a835 22
    if (!PL_mess_sv)
	PL_mess_sv = mess_alloc();
    sv = PL_mess_sv;
    sv_vsetpvfn(sv, pat, strlen(pat), args, Null(SV**), 0, Null(bool*));
    if (!SvCUR(sv) || *(SvEND(sv) - 1) != '\n') {
	dTHR;
	if (PL_dirty)
	    sv_catpv(sv, dgd);
	else {
	    if (PL_curcop->cop_line)
		sv_catpvf(sv, " at %_ line %ld",
			  GvSV(PL_curcop->cop_filegv), (long)PL_curcop->cop_line);
	    if (GvIO(PL_last_in_gv) && IoLINES(GvIOp(PL_last_in_gv))) {
		bool line_mode = (RsSIMPLE(PL_rs) &&
				  SvLEN(PL_rs) == 1 && *SvPVX(PL_rs) == '\n');
		sv_catpvf(sv, ", <%s> %s %ld",
			  PL_last_in_gv == PL_argvgv ? "" : GvNAME(PL_last_in_gv),
			  line_mode ? "line" : "chunk", 
			  (long)IoLINES(GvIOp(PL_last_in_gv)));
	    }
	    sv_catpv(sv, ".\n");
	}
d837 6
a842 1
    return SvPVX(sv);
d845 4
a848 2
OP *
die(const char* pat, ...)
a849 2
    dTHR;
    va_list args;
d851 1
a851 1
    int was_in_eval = PL_in_eval;
d856 18
a873 3
    DEBUG_S(PerlIO_printf(PerlIO_stderr(),
			  "%p: die: curstack = %p, mainstack = %p\n",
			  thr, PL_curstack, PL_mainstack));
d875 1
a875 3
    va_start(args, pat);
    message = pat ? mess(pat, &args) : Nullch;
    va_end(args);
d877 22
a898 24
    DEBUG_S(PerlIO_printf(PerlIO_stderr(),
			  "%p: die: message = %s\ndiehook = %p\n",
			  thr, message, PL_diehook));
    if (PL_diehook) {
	/* sv_2cv might call croak() */
	SV *olddiehook = PL_diehook;
	ENTER;
	SAVESPTR(PL_diehook);
	PL_diehook = Nullsv;
	cv = sv_2cv(olddiehook, &stash, &gv, 0);
	LEAVE;
	if (cv && !CvDEPTH(cv) && (CvROOT(cv) || CvXSUB(cv))) {
	    dSP;
	    SV *msg;

	    ENTER;
	    if(message) {
		msg = newSVpv(message, 0);
		SvREADONLY_on(msg);
		SAVEFREESV(msg);
	    }
	    else {
		msg = ERRSV;
	    }
d900 10
a909 8
	    PUSHSTACKi(PERLSI_DIEHOOK);
	    PUSHMARK(SP);
	    XPUSHs(msg);
	    PUTBACK;
	    perl_call_sv((SV*)cv, G_DISCARD);
	    POPSTACK;
	    LEAVE;
	}
d911 1
d913 37
a949 7
    PL_restartop = die_where(message);
    DEBUG_S(PerlIO_printf(PerlIO_stderr(),
	  "%p: die: restartop = %p, was_in_eval = %d, top_env = %p\n",
	  thr, PL_restartop, was_in_eval, PL_top_env));
    if ((!PL_restartop && was_in_eval) || PL_top_env->je_prev)
	JMPENV_JUMP(3);
    return PL_restartop;
d952 1
d954 8
a961 1
croak(const char* pat, ...)
a962 1
    dTHR;
d969 1
d971 3
d976 30
a1005 34
    DEBUG_S(PerlIO_printf(PerlIO_stderr(), "croak: 0x%lx %s", (unsigned long) thr, message));
    if (PL_diehook) {
	/* sv_2cv might call croak() */
	SV *olddiehook = PL_diehook;
	ENTER;
	SAVESPTR(PL_diehook);
	PL_diehook = Nullsv;
	cv = sv_2cv(olddiehook, &stash, &gv, 0);
	LEAVE;
	if (cv && !CvDEPTH(cv) && (CvROOT(cv) || CvXSUB(cv))) {
	    dSP;
	    SV *msg;

	    ENTER;
	    msg = newSVpv(message, 0);
	    SvREADONLY_on(msg);
	    SAVEFREESV(msg);

	    PUSHSTACKi(PERLSI_DIEHOOK);
	    PUSHMARK(SP);
	    XPUSHs(msg);
	    PUTBACK;
	    perl_call_sv((SV*)cv, G_DISCARD);
	    POPSTACK;
	    LEAVE;
	}
    }
    if (PL_in_eval) {
	PL_restartop = die_where(message);
	JMPENV_JUMP(3);
    }
    PerlIO_puts(PerlIO_stderr(),message);
    (void)PerlIO_flush(PerlIO_stderr());
    my_failure_exit();
d1009 8
a1016 1
warn(const char* pat,...)
d1024 5
a1028 1
    va_start(args, pat);
d1032 8
a1039 27
    if (PL_warnhook) {
	/* sv_2cv might call warn() */
	dTHR;
	SV *oldwarnhook = PL_warnhook;
	ENTER;
	SAVESPTR(PL_warnhook);
	PL_warnhook = Nullsv;
	cv = sv_2cv(oldwarnhook, &stash, &gv, 0);
	LEAVE;
	if (cv && !CvDEPTH(cv) && (CvROOT(cv) || CvXSUB(cv))) {
	    dSP;
	    SV *msg;

	    ENTER;
	    msg = newSVpv(message, 0);
	    SvREADONLY_on(msg);
	    SAVEFREESV(msg);

	    PUSHSTACKi(PERLSI_WARNHOOK);
	    PUSHMARK(SP);
	    XPUSHs(msg);
	    PUTBACK;
	    perl_call_sv((SV*)cv, G_DISCARD);
	    POPSTACK;
	    LEAVE;
	    return;
	}
d1041 2
a1042 1
    PerlIO_puts(PerlIO_stderr(),message);
d1044 1
a1044 6
    DEBUG_L(*message == '!' 
	    ? (xstat(message[1]=='!'
		     ? (message[2]=='!' ? 2 : 1)
		     : 0)
	       , 0)
	    : 0);
d1046 2
a1047 1
    (void)PerlIO_flush(PerlIO_stderr());
d1049 1
a1051 1
#ifndef WIN32
d1053 2
a1054 1
my_setenv(char *nam, char *val)
d1058 1
a1058 1
    if (environ == PL_origenviron) {	/* need we copy environment? */
a1071 1
	Safefree(environ[i]);
a1097 62
#else /* if WIN32 */

void
my_setenv(char *nam,char *val)
{

#ifdef USE_WIN32_RTL_ENV

    register char *envstr;
    STRLEN namlen = strlen(nam);
    STRLEN vallen;
    char *oldstr = environ[setenv_getix(nam)];

    /* putenv() has totally broken semantics in both the Borland
     * and Microsoft CRTLs.  They either store the passed pointer in
     * the environment without making a copy, or make a copy and don't
     * free it. And on top of that, they dont free() old entries that
     * are being replaced/deleted.  This means the caller must
     * free any old entries somehow, or we end up with a memory
     * leak every time my_setenv() is called.  One might think
     * one could directly manipulate environ[], like the UNIX code
     * above, but direct changes to environ are not allowed when
     * calling putenv(), since the RTLs maintain an internal
     * *copy* of environ[]. Bad, bad, *bad* stink.
     * GSAR 97-06-07
     */

    if (!val) {
	if (!oldstr)
	    return;
	val = "";
	vallen = 0;
    }
    else
	vallen = strlen(val);
    New(904, envstr, namlen + vallen + 3, char);
    (void)sprintf(envstr,"%s=%s",nam,val);
    (void)PerlEnv_putenv(envstr);
    if (oldstr)
	Safefree(oldstr);
#ifdef _MSC_VER
    Safefree(envstr);		/* MSVCRT leaks without this */
#endif

#else /* !USE_WIN32_RTL_ENV */

    register char *envstr;
    STRLEN len = strlen(nam) + 3;
    if (!val) {
	val = "";
    }
    len += strlen(val);
    New(904, envstr, len, char);
    (void)sprintf(envstr,"%s=%s",nam,val);
    (void)PerlEnv_putenv(envstr);
    Safefree(envstr);

#endif
}

#endif /* WIN32 */

d1099 2
a1100 1
setenv_getix(char *nam)
d1105 1
a1105 7
	if (
#ifdef WIN32
	    strnicmp(environ[i],nam,len) == 0
#else
	    strnEQ(environ[i],nam,len)
#endif
	    && environ[i][len] == '=')
a1109 1

d1119 1
a1119 1
    for (i = 0; PerlLIO_unlink(f) >= 0; i++) ;
d1126 4
a1129 1
my_bcopy(register char *from,register char *to,register I32 len)
a1146 15
#ifndef HAS_MEMSET
void *
my_memset(loc,ch,len)
register char *loc;
register I32 ch;
register I32 len;
{
    char *retval = loc;

    while (len--)
	*loc++ = ch;
    return retval;
}
#endif

d1161 1
a1161 1
#if !defined(HAS_MEMCMP) || !defined(HAS_SANE_MEMCMP)
d1164 2
a1165 2
char *s1;
char *s2;
a1167 2
    register U8 *a = (U8 *)s1;
    register U8 *b = (U8 *)s2;
d1171 1
a1171 1
	if (tmp = *a++ - *b++)
d1176 1
a1176 1
#endif /* !HAS_MEMCMP || !HAS_SANE_MEMCMP */
d1178 1
d1187 1
a1187 3
char *dest;
const char *pat;
char *args;
d1206 8
d1215 1
d1220 4
d1225 1
d1238 4
d1243 1
d1272 4
d1277 1
d1367 6
a1372 4
    /* VMS' my_popen() is in VMS.c, same with OS/2. */
#if (!defined(DOSISH) || defined(HAS_FORK) || defined(AMIGAOS)) && !defined(VMS)
PerlIO *
my_popen(char *cmd, char *mode)
d1375 1
a1375 1
    register I32 This, that;
d1380 9
a1388 10
#ifdef OS2
    if (doexec) {
	return my_syspopen(cmd,mode);
    }
#endif 
    This = (*mode == 'w');
    that = !This;
    if (doexec && PL_tainting) {
	taint_env();
	taint_proper("Insecure %s%s", "EXEC");
a1389 2
    if (PerlProc_pipe(p) < 0)
	return Nullfp;
d1392 1
a1392 1
	    PerlLIO_close(p[This]);
a1401 2
#undef THIS
#undef THAT
d1403 2
a1404 2
#define THAT This
	PerlLIO_close(p[THAT]);
d1406 2
a1407 2
	    PerlLIO_dup2(p[THIS], *mode == 'r');
	    PerlLIO_close(p[THIS]);
d1416 2
a1417 2
	    for (fd = PL_maxsysfd + 1; fd < NOFILE; fd++)
		PerlLIO_close(fd);
d1420 1
a1420 1
	    PerlProc__exit(1);
d1424 3
a1426 3
	    sv_setiv(GvSV(tmpgv), (IV)getpid());
	PL_forkprocess = 0;
	hv_clear(PL_pidstatus);	/* we have no children */
d1432 5
a1436 5
    PerlLIO_close(p[that]);
    if (p[that] < p[This]) {
	PerlLIO_dup2(p[This], p[that]);
	PerlLIO_close(p[This]);
	p[This] = p[that];
d1438 1
a1438 1
    sv = *av_fetch(PL_fdpid,p[This],TRUE);
d1441 2
a1442 2
    PL_forkprocess = pid;
    return PerlIO_fdopen(p[This], mode);
d1445 1
a1445 1
#if defined(atarist) || defined(DJGPP)
d1447 1
a1447 1
PerlIO *
d1452 1
a1452 3
    /* Needs work for PerlIO ! */
    /* used 0 for 2nd parameter to PerlIO-exportFILE; apparently not used */
    return popen(PerlIO_exportFILE(cmd, 0), mode);
d1459 2
a1460 2
void
dump_fds(char *s)
d1465 1
a1465 1
    PerlIO_printf(PerlIO_stderr(),"%s", s);
d1467 2
a1468 2
	if (PerlLIO_fstat(fd,&tmpstatbuf) >= 0)
	    PerlIO_printf(PerlIO_stderr()," %d",fd);
d1470 1
a1470 1
    PerlIO_printf(PerlIO_stderr(),"\n");
d1472 1
a1472 1
#endif	/* DUMP_FDS */
d1483 1
a1483 1
    PerlLIO_close(newfd);
d1486 1
a1486 2
#define DUP2_MAX_FDS 256
    int fdtmp[DUP2_MAX_FDS];
d1492 2
a1493 8
    PerlLIO_close(newfd);
    /* good enough for low fd's... */
    while ((fd = PerlLIO_dup(oldfd)) != newfd && fd >= 0) {
	if (fdx >= DUP2_MAX_FDS) {
	    PerlLIO_close(fd);
	    fd = -1;
	    break;
	}
a1494 1
    }
d1496 1
a1496 1
	PerlLIO_close(fdtmp[--fdx]);
d1502 1
a1502 106

#ifdef HAS_SIGACTION

Sighandler_t
rsignal(int signo, Sighandler_t handler)
{
    struct sigaction act, oact;

    act.sa_handler = handler;
    sigemptyset(&act.sa_mask);
    act.sa_flags = 0;
#ifdef SA_RESTART
    act.sa_flags |= SA_RESTART;	/* SVR4, 4.3+BSD */
#endif
#ifdef SA_NOCLDWAIT
    if (signo == SIGCHLD && handler == (Sighandler_t)SIG_IGN)
	act.sa_flags |= SA_NOCLDWAIT;
#endif
    if (sigaction(signo, &act, &oact) == -1)
    	return SIG_ERR;
    else
    	return oact.sa_handler;
}

Sighandler_t
rsignal_state(int signo)
{
    struct sigaction oact;

    if (sigaction(signo, (struct sigaction *)NULL, &oact) == -1)
        return SIG_ERR;
    else
        return oact.sa_handler;
}

int
rsignal_save(int signo, Sighandler_t handler, Sigsave_t *save)
{
    struct sigaction act;

    act.sa_handler = handler;
    sigemptyset(&act.sa_mask);
    act.sa_flags = 0;
#ifdef SA_RESTART
    act.sa_flags |= SA_RESTART;	/* SVR4, 4.3+BSD */
#endif
#ifdef SA_NOCLDWAIT
    if (signo == SIGCHLD && handler == (Sighandler_t)SIG_IGN)
	act.sa_flags |= SA_NOCLDWAIT;
#endif
    return sigaction(signo, &act, save);
}

int
rsignal_restore(int signo, Sigsave_t *save)
{
    return sigaction(signo, save, (struct sigaction *)NULL);
}

#else /* !HAS_SIGACTION */

Sighandler_t
rsignal(int signo, Sighandler_t handler)
{
    return PerlProc_signal(signo, handler);
}

static int sig_trapped;

static
Signal_t
sig_trap(int signo)
{
    sig_trapped++;
}

Sighandler_t
rsignal_state(int signo)
{
    Sighandler_t oldsig;

    sig_trapped = 0;
    oldsig = PerlProc_signal(signo, sig_trap);
    PerlProc_signal(signo, oldsig);
    if (sig_trapped)
        PerlProc_kill(getpid(), signo);
    return oldsig;
}

int
rsignal_save(int signo, Sighandler_t handler, Sigsave_t *save)
{
    *save = PerlProc_signal(signo, handler);
    return (*save == SIG_ERR) ? -1 : 0;
}

int
rsignal_restore(int signo, Sigsave_t *save)
{
    return (PerlProc_signal(signo, *save) == SIG_ERR) ? -1 : 0;
}

#endif /* !HAS_SIGACTION */

    /* VMS' my_pclose() is in VMS.c; same with OS/2 */
#if (!defined(DOSISH) || defined(HAS_FORK) || defined(AMIGAOS)) && !defined(VMS)
d1504 2
a1505 1
my_pclose(PerlIO *ptr)
d1507 1
a1507 1
    Sigsave_t hstat, istat, qstat;
a1510 9
    int pid2;
    bool close_failed;
    int saved_errno;
#ifdef VMS
    int saved_vaxc_errno;
#endif
#ifdef WIN32
    int saved_win32_errno;
#endif
d1512 1
a1512 1
    svp = av_fetch(PL_fdpid,PerlIO_fileno(ptr),TRUE);
d1515 2
a1516 15
    *svp = &PL_sv_undef;
#ifdef OS2
    if (pid == -1) {			/* Opened by popen. */
	return my_syspclose(ptr);
    }
#endif 
    if ((close_failed = (PerlIO_close(ptr) == EOF))) {
	saved_errno = errno;
#ifdef VMS
	saved_vaxc_errno = vaxc$errno;
#endif
#ifdef WIN32
	saved_win32_errno = GetLastError();
#endif
    }
d1518 1
a1518 1
    if(PerlProc_kill(pid, 0) < 0) { return(pid); }   /* HOM 12/23/91 */
d1520 3
a1522 3
    rsignal_save(SIGHUP, SIG_IGN, &hstat);
    rsignal_save(SIGINT, SIG_IGN, &istat);
    rsignal_save(SIGQUIT, SIG_IGN, &qstat);
d1524 6
a1529 10
	pid2 = wait4pid(pid, &status, 0);
    } while (pid2 == -1 && errno == EINTR);
    rsignal_restore(SIGHUP, &hstat);
    rsignal_restore(SIGINT, &istat);
    rsignal_restore(SIGQUIT, &qstat);
    if (close_failed) {
	SETERRNO(saved_errno, saved_vaxc_errno);
	return -1;
    }
    return(pid2 < 0 ? pid2 : status == 0 ? 0 : (errno = 0, status));
d1533 1
a1533 1
#if  !defined(DOSISH) || defined(OS2) || defined(WIN32)
d1535 4
a1538 1
wait4pid(int pid, int *statusp, int flags)
d1542 1
a1542 1
    char spid[TYPE_CHARS(int)];
d1548 2
a1549 2
	svp = hv_fetch(PL_pidstatus,spid,strlen(spid),FALSE);
	if (svp && *svp != &PL_sv_undef) {
d1551 1
a1551 1
	    (void)hv_delete(PL_pidstatus,spid,strlen(spid),G_DISCARD);
d1558 2
a1559 2
	hv_iterinit(PL_pidstatus);
	if (entry = hv_iternext(PL_pidstatus)) {
d1561 1
a1561 1
	    sv = hv_iterval(PL_pidstatus,entry);
d1564 1
a1564 1
	    (void)hv_delete(PL_pidstatus,spid,strlen(spid),G_DISCARD);
d1569 3
a1571 7
#  ifdef HAS_WAITPID_RUNTIME
    if (!HAS_WAITPID_RUNTIME)
	goto hard_way;
#  endif
    return PerlProc_waitpid(pid,statusp,flags);
#endif
#if !defined(HAS_WAITPID) && defined(HAS_WAIT4)
d1573 1
a1573 3
#endif
#if !defined(HAS_WAITPID) && !defined(HAS_WAIT4) || defined(HAS_WAITPID_RUNTIME)
  hard_way:
d1579 1
a1579 1
	    while ((result = PerlProc_wait(statusp)) != pid && pid > 0 && result >= 0)
d1587 1
d1589 1
a1589 1
#endif /* !DOSISH || OS2 || WIN32 */
d1593 3
a1595 1
pidgone(int pid, int status)
d1598 1
a1598 1
    char spid[TYPE_CHARS(int)];
d1601 1
a1601 1
    sv = *hv_fetch(PL_pidstatus,spid,strlen(spid),TRUE);
d1607 1
a1607 1
#if defined(atarist) || defined(OS2) || defined(DJGPP)
a1608 5
#ifdef HAS_FORK
int					/* Cannot prototype with I32
					   in os2ish.h. */
my_syspclose(ptr)
#else
d1611 1
a1611 2
#endif 
PerlIO *ptr;
d1613 1
a1613 5
    /* Needs work for PerlIO ! */
    FILE *f = PerlIO_findFILE(ptr);
    I32 result = pclose(f);
    PerlIO_releaseFILE(ptr,f);
    return result;
d1618 5
a1622 1
repeatcpy(register char *to, register char *from, I32 len, register I32 count)
d1628 1
a1628 1
	register char c = *from;
d1630 1
a1630 1
	    *to++ = c;
d1663 23
d1696 2
a1697 8

/* Code modified to prefer proper named type ranges, I32, IV, or UV, instead
   of LONG_(MIN/MAX).
                           -- Kenneth Albanowski <kjahds@@kjahds.com>
*/                                      

#ifndef MY_UV_MAX
#  define MY_UV_MAX ((UV)IV_MAX * (UV)2 + (UV)1)
d1704 4
a1707 4
    if (f >= I32_MAX)
	return (I32) I32_MAX;
    if (f <= I32_MIN)
	return (I32) I32_MIN;
d1715 4
a1718 4
    if (f >= IV_MAX)
	return (IV) IV_MAX;
    if (f <= IV_MIN)
	return (IV) IV_MIN;
d1726 2
a1727 2
    if (f >= MY_UV_MAX)
	return (UV) MY_UV_MAX;
d1743 4
a1746 1
    SV *tmpsv = sv_newmortal();
d1759 1
a1759 1
	sv_setpv(tmpsv, ".");
d1761 2
a1762 2
	sv_setpvn(tmpsv, a, fa - a);
    if (PerlLIO_stat(SvPVX(tmpsv), &tmpstatbuf1) < 0)
d1765 1
a1765 1
	sv_setpv(tmpsv, ".");
d1767 2
a1768 2
	sv_setpvn(tmpsv, b, fb - b);
    if (PerlLIO_stat(SvPVX(tmpsv), &tmpstatbuf2) < 0)
d1775 5
a1779 2
UV
scan_oct(char *start, I32 len, I32 *retlen)
d1782 1
a1782 2
    register UV retval = 0;
    bool overflowed = FALSE;
d1785 2
a1786 6
	register UV n = retval << 3;
	if (!overflowed && (n >> 3) != retval) {
	    warn("Integer overflow in octal number");
	    overflowed = TRUE;
	}
	retval = n | (*s++ - '0');
d1789 1
a1789 1
    if (PL_dowarn && len && (*s == '8' || *s == '9'))
d1795 5
a1799 2
UV
scan_hex(char *start, I32 len, I32 *retlen)
d1802 7
a1808 23
    register UV retval = 0;
    bool overflowed = FALSE;
    char *tmp = s;
    register UV n;

    while (len-- && *s) {
	tmp = strchr((char *) PL_hexdigit, *s++);
	if (!tmp) {
	    if (*(s-1) == '_' || (*(s-1) == 'x' && retval == 0))
		continue;
	    else {
		--s;
		if (PL_dowarn)
		    warn("Illegal hex digit ignored");
		break;
	    }
	}
	n = retval << 4;
	if (!overflowed && (n >> 4) != retval) {
	    warn("Integer overflow in hex number");
	    overflowed = TRUE;
	}
	retval = n | ((tmp - PL_hexdigit) & 15);
a1812 619

char*
find_script(char *scriptname, bool dosearch, char **search_ext, I32 flags)
{
    dTHR;
    char *xfound = Nullch;
    char *xfailed = Nullch;
    char tmpbuf[512];
    register char *s;
    I32 len;
    int retval;
#if defined(DOSISH) && !defined(OS2) && !defined(atarist)
#  define SEARCH_EXTS ".bat", ".cmd", NULL
#  define MAX_EXT_LEN 4
#endif
#ifdef OS2
#  define SEARCH_EXTS ".cmd", ".btm", ".bat", ".pl", NULL
#  define MAX_EXT_LEN 4
#endif
#ifdef VMS
#  define SEARCH_EXTS ".pl", ".com", NULL
#  define MAX_EXT_LEN 4
#endif
    /* additional extensions to try in each dir if scriptname not found */
#ifdef SEARCH_EXTS
    char *exts[] = { SEARCH_EXTS };
    char **ext = search_ext ? search_ext : exts;
    int extidx = 0, i = 0;
    char *curext = Nullch;
#else
#  define MAX_EXT_LEN 0
#endif

    /*
     * If dosearch is true and if scriptname does not contain path
     * delimiters, search the PATH for scriptname.
     *
     * If SEARCH_EXTS is also defined, will look for each
     * scriptname{SEARCH_EXTS} whenever scriptname is not found
     * while searching the PATH.
     *
     * Assuming SEARCH_EXTS is C<".foo",".bar",NULL>, PATH search
     * proceeds as follows:
     *   If DOSISH or VMSISH:
     *     + look for ./scriptname{,.foo,.bar}
     *     + search the PATH for scriptname{,.foo,.bar}
     *
     *   If !DOSISH:
     *     + look *only* in the PATH for scriptname{,.foo,.bar} (note
     *       this will not look in '.' if it's not in the PATH)
     */
    tmpbuf[0] = '\0';

#ifdef VMS
#  ifdef ALWAYS_DEFTYPES
    len = strlen(scriptname);
    if (!(len == 1 && *scriptname == '-') && scriptname[len-1] != ':') {
	int hasdir, idx = 0, deftypes = 1;
	bool seen_dot = 1;

	hasdir = !dosearch || (strpbrk(scriptname,":[</") != Nullch) ;
#  else
    if (dosearch) {
	int hasdir, idx = 0, deftypes = 1;
	bool seen_dot = 1;

	hasdir = (strpbrk(scriptname,":[</") != Nullch) ;
#  endif
	/* The first time through, just add SEARCH_EXTS to whatever we
	 * already have, so we can check for default file types. */
	while (deftypes ||
	       (!hasdir && my_trnlnm("DCL$PATH",tmpbuf,idx++)) )
	{
	    if (deftypes) {
		deftypes = 0;
		*tmpbuf = '\0';
	    }
	    if ((strlen(tmpbuf) + strlen(scriptname)
		 + MAX_EXT_LEN) >= sizeof tmpbuf)
		continue;	/* don't search dir with too-long name */
	    strcat(tmpbuf, scriptname);
#else  /* !VMS */

#ifdef DOSISH
    if (strEQ(scriptname, "-"))
 	dosearch = 0;
    if (dosearch) {		/* Look in '.' first. */
	char *cur = scriptname;
#ifdef SEARCH_EXTS
	if ((curext = strrchr(scriptname,'.')))	/* possible current ext */
	    while (ext[i])
		if (strEQ(ext[i++],curext)) {
		    extidx = -1;		/* already has an ext */
		    break;
		}
	do {
#endif
	    DEBUG_p(PerlIO_printf(Perl_debug_log,
				  "Looking for %s\n",cur));
	    if (PerlLIO_stat(cur,&PL_statbuf) >= 0
		&& !S_ISDIR(PL_statbuf.st_mode)) {
		dosearch = 0;
		scriptname = cur;
#ifdef SEARCH_EXTS
		break;
#endif
	    }
#ifdef SEARCH_EXTS
	    if (cur == scriptname) {
		len = strlen(scriptname);
		if (len+MAX_EXT_LEN+1 >= sizeof(tmpbuf))
		    break;
		cur = strcpy(tmpbuf, scriptname);
	    }
	} while (extidx >= 0 && ext[extidx]	/* try an extension? */
		 && strcpy(tmpbuf+len, ext[extidx++]));
#endif
    }
#endif

    if (dosearch && !strchr(scriptname, '/')
#ifdef DOSISH
		 && !strchr(scriptname, '\\')
#endif
		 && (s = PerlEnv_getenv("PATH"))) {
	bool seen_dot = 0;
	
	PL_bufend = s + strlen(s);
	while (s < PL_bufend) {
#if defined(atarist) || defined(DOSISH)
	    for (len = 0; *s
#  ifdef atarist
		    && *s != ','
#  endif
		    && *s != ';'; len++, s++) {
		if (len < sizeof tmpbuf)
		    tmpbuf[len] = *s;
	    }
	    if (len < sizeof tmpbuf)
		tmpbuf[len] = '\0';
#else  /* ! (atarist || DOSISH) */
	    s = delimcpy(tmpbuf, tmpbuf + sizeof tmpbuf, s, PL_bufend,
			':',
			&len);
#endif /* ! (atarist || DOSISH) */
	    if (s < PL_bufend)
		s++;
	    if (len + 1 + strlen(scriptname) + MAX_EXT_LEN >= sizeof tmpbuf)
		continue;	/* don't search dir with too-long name */
	    if (len
#if defined(atarist) || defined(DOSISH)
		&& tmpbuf[len - 1] != '/'
		&& tmpbuf[len - 1] != '\\'
#endif
	       )
		tmpbuf[len++] = '/';
	    if (len == 2 && tmpbuf[0] == '.')
		seen_dot = 1;
	    (void)strcpy(tmpbuf + len, scriptname);
#endif  /* !VMS */

#ifdef SEARCH_EXTS
	    len = strlen(tmpbuf);
	    if (extidx > 0)	/* reset after previous loop */
		extidx = 0;
	    do {
#endif
	    	DEBUG_p(PerlIO_printf(Perl_debug_log, "Looking for %s\n",tmpbuf));
		retval = PerlLIO_stat(tmpbuf,&PL_statbuf);
		if (S_ISDIR(PL_statbuf.st_mode)) {
		    retval = -1;
		}
#ifdef SEARCH_EXTS
	    } while (  retval < 0		/* not there */
		    && extidx>=0 && ext[extidx]	/* try an extension? */
		    && strcpy(tmpbuf+len, ext[extidx++])
		);
#endif
	    if (retval < 0)
		continue;
	    if (S_ISREG(PL_statbuf.st_mode)
		&& cando(S_IRUSR,TRUE,&PL_statbuf)
#ifndef DOSISH
		&& cando(S_IXUSR,TRUE,&PL_statbuf)
#endif
		)
	    {
		xfound = tmpbuf;              /* bingo! */
		break;
	    }
	    if (!xfailed)
		xfailed = savepv(tmpbuf);
	}
#ifndef DOSISH
	if (!xfound && !seen_dot && !xfailed &&
	    (PerlLIO_stat(scriptname,&PL_statbuf) < 0 
	     || S_ISDIR(PL_statbuf.st_mode)))
#endif
	    seen_dot = 1;			/* Disable message. */
	if (!xfound) {
	    if (flags & 1) {			/* do or die? */
	        croak("Can't %s %s%s%s",
		      (xfailed ? "execute" : "find"),
		      (xfailed ? xfailed : scriptname),
		      (xfailed ? "" : " on PATH"),
		      (xfailed || seen_dot) ? "" : ", '.' not in PATH");
	    }
	    scriptname = Nullch;
	}
	if (xfailed)
	    Safefree(xfailed);
	scriptname = xfound;
    }
    return (scriptname ? savepv(scriptname) : Nullch);
}


#ifdef USE_THREADS
#ifdef FAKE_THREADS
/* Very simplistic scheduler for now */
void
schedule(void)
{
    thr = thr->i.next_run;
}

void
perl_cond_init(cp)
perl_cond *cp;
{
    *cp = 0;
}

void
perl_cond_signal(cp)
perl_cond *cp;
{
    perl_os_thread t;
    perl_cond cond = *cp;
    
    if (!cond)
	return;
    t = cond->thread;
    /* Insert t in the runnable queue just ahead of us */
    t->i.next_run = thr->i.next_run;
    thr->i.next_run->i.prev_run = t;
    t->i.prev_run = thr;
    thr->i.next_run = t;
    thr->i.wait_queue = 0;
    /* Remove from the wait queue */
    *cp = cond->next;
    Safefree(cond);
}

void
perl_cond_broadcast(cp)
perl_cond *cp;
{
    perl_os_thread t;
    perl_cond cond, cond_next;
    
    for (cond = *cp; cond; cond = cond_next) {
	t = cond->thread;
	/* Insert t in the runnable queue just ahead of us */
	t->i.next_run = thr->i.next_run;
	thr->i.next_run->i.prev_run = t;
	t->i.prev_run = thr;
	thr->i.next_run = t;
	thr->i.wait_queue = 0;
	/* Remove from the wait queue */
	cond_next = cond->next;
	Safefree(cond);
    }
    *cp = 0;
}

void
perl_cond_wait(cp)
perl_cond *cp;
{
    perl_cond cond;

    if (thr->i.next_run == thr)
	croak("panic: perl_cond_wait called by last runnable thread");
    
    New(666, cond, 1, struct perl_wait_queue);
    cond->thread = thr;
    cond->next = *cp;
    *cp = cond;
    thr->i.wait_queue = cond;
    /* Remove ourselves from runnable queue */
    thr->i.next_run->i.prev_run = thr->i.prev_run;
    thr->i.prev_run->i.next_run = thr->i.next_run;
}
#endif /* FAKE_THREADS */

#ifdef OLD_PTHREADS_API
struct perl_thread *
getTHR _((void))
{
    pthread_addr_t t;

    if (pthread_getspecific(PL_thr_key, &t))
	croak("panic: pthread_getspecific");
    return (struct perl_thread *) t;
}
#endif /* OLD_PTHREADS_API */

MAGIC *
condpair_magic(SV *sv)
{
    MAGIC *mg;
    
    SvUPGRADE(sv, SVt_PVMG);
    mg = mg_find(sv, 'm');
    if (!mg) {
	condpair_t *cp;

	New(53, cp, 1, condpair_t);
	MUTEX_INIT(&cp->mutex);
	COND_INIT(&cp->owner_cond);
	COND_INIT(&cp->cond);
	cp->owner = 0;
	LOCK_SV_MUTEX;
	mg = mg_find(sv, 'm');
	if (mg) {
	    /* someone else beat us to initialising it */
	    UNLOCK_SV_MUTEX;
	    MUTEX_DESTROY(&cp->mutex);
	    COND_DESTROY(&cp->owner_cond);
	    COND_DESTROY(&cp->cond);
	    Safefree(cp);
	}
	else {
	    sv_magic(sv, Nullsv, 'm', 0, 0);
	    mg = SvMAGIC(sv);
	    mg->mg_ptr = (char *)cp;
	    mg->mg_len = sizeof(cp);
	    UNLOCK_SV_MUTEX;
	    DEBUG_S(WITH_THR(PerlIO_printf(PerlIO_stderr(),
					   "%p: condpair_magic %p\n", thr, sv));)
	}
    }
    return mg;
}

/*
 * Make a new perl thread structure using t as a prototype. Some of the
 * fields for the new thread are copied from the prototype thread, t,
 * so t should not be running in perl at the time this function is
 * called. The use by ext/Thread/Thread.xs in core perl (where t is the
 * thread calling new_struct_thread) clearly satisfies this constraint.
 */
struct perl_thread *
new_struct_thread(struct perl_thread *t)
{
    struct perl_thread *thr;
    SV *sv;
    SV **svp;
    I32 i;

    sv = newSVpv("", 0);
    SvGROW(sv, sizeof(struct perl_thread) + 1);
    SvCUR_set(sv, sizeof(struct perl_thread));
    thr = (Thread) SvPVX(sv);
#ifdef DEBUGGING
    memset(thr, 0xab, sizeof(struct perl_thread));
    PL_markstack = 0;
    PL_scopestack = 0;
    PL_savestack = 0;
    PL_retstack = 0;
    PL_dirty = 0;
    PL_localizing = 0;
    Zero(&PL_hv_fetch_ent_mh, 1, HE);
#else
    Zero(thr, 1, struct perl_thread);
#endif

    thr->oursv = sv;
    init_stacks(ARGS);

    PL_curcop = &PL_compiling;
    thr->cvcache = newHV();
    thr->threadsv = newAV();
    thr->specific = newAV();
    thr->errsv = newSVpv("", 0);
    thr->errhv = newHV();
    thr->flags = THRf_R_JOINABLE;
    MUTEX_INIT(&thr->mutex);


    /* top_env needs to be non-zero. It points to an area
       in which longjmp() stuff is stored, as C callstack
       info there at least is thread specific this has to
       be per-thread. Otherwise a 'die' in a thread gives
       that thread the C stack of last thread to do an eval {}!
       See comments in scope.h    
       Initialize top entry (as in perl.c for main thread)
     */
    PL_start_env.je_prev = NULL;
    PL_start_env.je_ret = -1;
    PL_start_env.je_mustcatch = TRUE;
    PL_top_env  = &PL_start_env;

    PL_in_eval = FALSE;
    PL_restartop = 0;

    PL_statname = NEWSV(66,0);
    PL_maxscream = -1;
    PL_regcompp = FUNC_NAME_TO_PTR(pregcomp);
    PL_regexecp = FUNC_NAME_TO_PTR(regexec_flags);
    PL_regindent = 0;
    PL_reginterp_cnt = 0;
    PL_lastscream = Nullsv;
    PL_screamfirst = 0;
    PL_screamnext = 0;
    PL_reg_start_tmp = 0;
    PL_reg_start_tmpl = 0;

    /* parent thread's data needs to be locked while we make copy */
    MUTEX_LOCK(&t->mutex);

    PL_curcop = t->Tcurcop;       /* XXX As good a guess as any? */
    PL_defstash = t->Tdefstash;   /* XXX maybe these should */
    PL_curstash = t->Tcurstash;   /* always be set to main? */

    PL_tainted = t->Ttainted;
    PL_curpm = t->Tcurpm;         /* XXX No PMOP ref count */
    PL_nrs = newSVsv(t->Tnrs);
    PL_rs = SvREFCNT_inc(PL_nrs);
    PL_last_in_gv = Nullgv;
    PL_ofslen = t->Tofslen;
    PL_ofs = savepvn(t->Tofs, PL_ofslen);
    PL_defoutgv = (GV*)SvREFCNT_inc(t->Tdefoutgv);
    PL_chopset = t->Tchopset;
    PL_formtarget = newSVsv(t->Tformtarget);
    PL_bodytarget = newSVsv(t->Tbodytarget);
    PL_toptarget = newSVsv(t->Ttoptarget);

    /* Initialise all per-thread SVs that the template thread used */
    svp = AvARRAY(t->threadsv);
    for (i = 0; i <= AvFILLp(t->threadsv); i++, svp++) {
	if (*svp && *svp != &PL_sv_undef) {
	    SV *sv = newSVsv(*svp);
	    av_store(thr->threadsv, i, sv);
	    sv_magic(sv, 0, 0, &PL_threadsv_names[i], 1);
	    DEBUG_S(PerlIO_printf(PerlIO_stderr(),
		"new_struct_thread: copied threadsv %d %p->%p\n",i, t, thr));
	}
    } 
    thr->threadsvp = AvARRAY(thr->threadsv);

    MUTEX_LOCK(&PL_threads_mutex);
    PL_nthreads++;
    thr->tid = ++PL_threadnum;
    thr->next = t->next;
    thr->prev = t;
    t->next = thr;
    thr->next->prev = thr;
    MUTEX_UNLOCK(&PL_threads_mutex);

    /* done copying parent's state */
    MUTEX_UNLOCK(&t->mutex);

#ifdef HAVE_THREAD_INTERN
    init_thread_intern(thr);
#endif /* HAVE_THREAD_INTERN */
    return thr;
}
#endif /* USE_THREADS */

#ifdef HUGE_VAL
/*
 * This hack is to force load of "huge" support from libm.a
 * So it is in perl for (say) POSIX to use. 
 * Needed for SunOS with Sun's 'acc' for example.
 */
double 
Perl_huge(void)
{
 return HUGE_VAL;
}
#endif

#ifdef PERL_GLOBAL_STRUCT
struct perl_vars *
Perl_GetVars(void)
{
 return &PL_Vars;
}
#endif

char **
get_op_names(void)
{
 return op_name;
}

char **
get_op_descs(void)
{
 return op_desc;
}

char *
get_no_modify(void)
{
 return (char*)no_modify;
}

U32 *
get_opargs(void)
{
 return opargs;
}


SV **
get_specialsv_list(void)
{
 return PL_specialsv_list;
}


MGVTBL*
get_vtbl(int vtbl_id)
{
    MGVTBL* result = Null(MGVTBL*);

    switch(vtbl_id) {
    case want_vtbl_sv:
	result = &vtbl_sv;
	break;
    case want_vtbl_env:
	result = &vtbl_env;
	break;
    case want_vtbl_envelem:
	result = &vtbl_envelem;
	break;
    case want_vtbl_sig:
	result = &vtbl_sig;
	break;
    case want_vtbl_sigelem:
	result = &vtbl_sigelem;
	break;
    case want_vtbl_pack:
	result = &vtbl_pack;
	break;
    case want_vtbl_packelem:
	result = &vtbl_packelem;
	break;
    case want_vtbl_dbline:
	result = &vtbl_dbline;
	break;
    case want_vtbl_isa:
	result = &vtbl_isa;
	break;
    case want_vtbl_isaelem:
	result = &vtbl_isaelem;
	break;
    case want_vtbl_arylen:
	result = &vtbl_arylen;
	break;
    case want_vtbl_glob:
	result = &vtbl_glob;
	break;
    case want_vtbl_mglob:
	result = &vtbl_mglob;
	break;
    case want_vtbl_nkeys:
	result = &vtbl_nkeys;
	break;
    case want_vtbl_taint:
	result = &vtbl_taint;
	break;
    case want_vtbl_substr:
	result = &vtbl_substr;
	break;
    case want_vtbl_vec:
	result = &vtbl_vec;
	break;
    case want_vtbl_pos:
	result = &vtbl_pos;
	break;
    case want_vtbl_bm:
	result = &vtbl_bm;
	break;
    case want_vtbl_fm:
	result = &vtbl_fm;
	break;
    case want_vtbl_uvar:
	result = &vtbl_uvar;
	break;
#ifdef USE_THREADS
    case want_vtbl_mutex:
	result = &vtbl_mutex;
	break;
#endif
    case want_vtbl_defelem:
	result = &vtbl_defelem;
	break;
    case want_vtbl_regexp:
	result = &vtbl_regexp;
	break;
#ifdef USE_LOCALE_COLLATE
    case want_vtbl_collxfrm:
	result = &vtbl_collxfrm;
	break;
#endif
    case want_vtbl_amagic:
	result = &vtbl_amagic;
	break;
    case want_vtbl_amagicelem:
	result = &vtbl_amagicelem;
	break;
    }
    return result;
}

@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2000, Larry Wall
a15 1
#define PERL_IN_UTIL_C
d42 7
a52 4
#ifdef I_LOCALE
#  include <locale.h>
#endif

d57 1
d65 1
a65 3
#if defined(HAS_FCNTL) && defined(F_SETFD) && !defined(FD_CLOEXEC)
#  define FD_CLOEXEC 1			/* NeXT needs this */
#endif
d67 1
a67 1
/* paranoid version of system's malloc() */
d76 1
a76 1
Perl_safesysmalloc(MEM_SIZE size)
a77 1
    dTHX;
d81 2
a82 3
	    PerlIO_printf(Perl_error_log,
			  "Allocation too large: %lx\n", size) FLUSH;
	    my_exit(1);
d87 1
a87 1
	Perl_croak_nocontext("panic: malloc");
d90 5
a94 2
    PERL_ALLOC_CHECK(ptr);
    DEBUG_m(PerlIO_printf(Perl_debug_log, "0x%"UVxf": (%05ld) malloc %ld bytes\n",PTR2UV(ptr),(long)PL_an++,(long)size));
d100 1
a100 1
	PerlIO_puts(Perl_error_log,PL_no_mem) FLUSH;
d107 1
a107 1
/* paranoid version of system's realloc() */
d110 1
a110 1
Perl_safesysrealloc(Malloc_t where,MEM_SIZE size)
a111 1
    dTHX;
d113 1
a113 1
#if !defined(STANDARD_C) && !defined(HAS_REALLOC_PROTOTYPE) && !defined(PERL_MICRO)
d119 1
a119 1
	PerlIO_printf(Perl_error_log,
d125 1
a125 1
	safesysfree(where);
d130 1
a130 1
	return safesysmalloc(size);
d133 1
a133 1
	Perl_croak_nocontext("panic: realloc");
d136 12
a147 4
    PERL_ALLOC_CHECK(ptr);
 
    DEBUG_m(PerlIO_printf(Perl_debug_log, "0x%"UVxf": (%05ld) rfree\n",PTR2UV(where),(long)PL_an++));
    DEBUG_m(PerlIO_printf(Perl_debug_log, "0x%"UVxf": (%05ld) realloc %ld bytes\n",PTR2UV(ptr),(long)PL_an++,(long)size));
d154 1
a154 1
	PerlIO_puts(Perl_error_log,PL_no_mem) FLUSH;
d161 1
a161 1
/* safe version of system's free() */
d164 1
a164 1
Perl_safesysfree(Malloc_t where)
d166 4
a169 2
#ifdef PERL_IMPLICIT_SYS
    dTHX;
a170 1
    DEBUG_m( PerlIO_printf(Perl_debug_log, "0x%"UVxf": (%05ld) free\n",PTR2UV(where),(long)PL_an++));
d177 1
a177 1
/* safe version of system's calloc() */
d180 1
a180 1
Perl_safesyscalloc(MEM_SIZE count, MEM_SIZE size)
a181 1
    dTHX;
d186 1
a186 1
	PerlIO_printf(Perl_error_log,
d193 1
a193 1
	Perl_croak_nocontext("panic: calloc");
d197 5
a201 2
    PERL_ALLOC_CHECK(ptr);
    DEBUG_m(PerlIO_printf(Perl_debug_log, "0x%"UVxf": (%05ld) calloc %ld x %ld bytes\n",PTR2UV(ptr),(long)PL_an++,(long)count,(long)size));
d209 1
a209 1
	PerlIO_puts(Perl_error_log,PL_no_mem) FLUSH;
d216 2
d242 1
a242 1
Perl_safexmalloc(I32 x, MEM_SIZE size)
d254 1
a254 1
Perl_safexrealloc(Malloc_t wh, MEM_SIZE size)
d275 1
a275 1
Perl_safexfree(Malloc_t wh)
d292 1
a292 1
Perl_safexcalloc(I32 x,MEM_SIZE count, MEM_SIZE size)
d303 2
a304 2
STATIC void
S_xstat(pTHX_ int flag)
d313 1
a313 1
    PerlIO_printf(Perl_debug_log, "   Id  subtot   4   8  12  16  20  24  28  32  36  40  48  56  64  72  80 80+\n", total);
d324 1
a324 1
	    PerlIO_printf(Perl_debug_log,"%2d %02d %7ld ", i / 100, i % 100, 
d333 1
a333 1
		    PerlIO_printf(Perl_debug_log,"%3ld ", 
d339 1
a339 1
		    PerlIO_printf(Perl_debug_log, "  . ", xycount[i][j]);
d342 1
a342 1
	    PerlIO_printf(Perl_debug_log, "\n");
d346 1
a346 1
	PerlIO_printf(Perl_debug_log, "Total %7ld ", total);
d349 1
a349 1
		PerlIO_printf(Perl_debug_log, "%3ld ", subtot[j]);
d351 1
a351 1
		PerlIO_printf(Perl_debug_log, "  . ");
d354 1
a354 1
	PerlIO_printf(Perl_debug_log, "\n");	
d363 1
a363 1
Perl_delimcpy(pTHX_ register char *to, register char *toend, register char *from, register char *fromend, register int delim, I32 *retlen)
d392 1
a392 1
Perl_instr(pTHX_ register const char *big, register const char *little)
d394 1
a394 1
    register const char *s, *x;
d398 1
a398 1
	return (char*)big;
d401 1
a401 1
	return (char*)big;
d414 1
a414 1
	    return (char*)(big-1);
d422 1
a422 1
Perl_ninstr(pTHX_ register const char *big, register const char *bigend, const char *little, const char *lend)
d424 1
a424 1
    register const char *s, *x;
d426 1
a426 1
    register const char *littleend = lend;
d429 1
a429 1
	return (char*)big;
d443 1
a443 1
	    return (char*)(big-1);
d451 1
a451 1
Perl_rninstr(pTHX_ register const char *big, const char *bigend, const char *little, const char *lend)
d453 2
a454 2
    register const char *bigbeg;
    register const char *s, *x;
d456 1
a456 1
    register const char *littleend = lend;
d459 1
a459 1
	return (char*)bigend;
d472 1
a472 1
	    return (char*)(big+1);
d481 1
a481 1
Perl_new_ctype(pTHX_ const char *newctype)
d489 1
a489 1
	    PL_fold_locale[i] = toLOWER_LC(i);
d491 1
a491 1
	    PL_fold_locale[i] = toUPPER_LC(i);
d493 1
a493 1
	    PL_fold_locale[i] = i;
d503 1
a503 1
Perl_new_collate(pTHX_ const char *newcoll)
d534 1
a534 1
	      Perl_croak(aTHX_ "strxfrm() gets absurd");
a542 19
void
Perl_set_numeric_radix(pTHX)
{
#ifdef USE_LOCALE_NUMERIC
# ifdef HAS_LOCALECONV
    struct lconv* lc;

    lc = localeconv();
    if (lc && lc->decimal_point)
	/* We assume that decimal separator aka the radix
	 * character is always a single character.  If it
	 * ever is a string, this needs to be rethunk. */
	PL_numeric_radix = *lc->decimal_point;
    else
	PL_numeric_radix = 0;
# endif /* HAS_LOCALECONV */
#endif /* USE_LOCALE_NUMERIC */
}

d547 1
a547 1
Perl_new_numeric(pTHX_ const char *newnum)
a565 1
	set_numeric_radix();
d572 1
a572 1
Perl_set_numeric_standard(pTHX)
d586 1
a586 1
Perl_set_numeric_local(pTHX)
a593 1
	set_numeric_radix();
d599 1
d604 1
a604 1
Perl_init_i18nl10n(pTHX_ int printwarn)
d698 2
a699 2
			(printwarn &&
			 (!(p = PerlEnv_getenv("PERL_BADLANG")) || atoi(p))));
d704 1
a704 1
	    PerlIO_printf(Perl_error_log,
d709 1
a709 1
	    PerlIO_printf(Perl_error_log,
d713 1
a713 1
		PerlIO_printf(Perl_error_log, "LC_CTYPE ");
d717 1
a717 1
		PerlIO_printf(Perl_error_log, "LC_COLLATE ");
d721 1
a721 1
		PerlIO_printf(Perl_error_log, "LC_NUMERIC ");
d723 1
a723 1
	    PerlIO_printf(Perl_error_log, "\n");
d727 1
a727 1
	    PerlIO_printf(Perl_error_log,
d731 1
a731 1
	    PerlIO_printf(Perl_error_log,
d738 1
a738 1
	    PerlIO_printf(Perl_error_log,
d750 1
a750 1
		      PerlIO_printf(Perl_error_log, "\t%.*s = \"%s\",\n",
d755 1
a755 1
	    PerlIO_printf(Perl_error_log,
d761 1
a761 1
	    PerlIO_printf(Perl_error_log,
d769 1
a769 1
		PerlIO_printf(Perl_error_log,
d775 1
a775 1
		PerlIO_printf(Perl_error_log,
d795 1
a795 1
		PerlIO_printf(Perl_error_log,
d814 1
a814 1
    new_ctype(curctype);
d818 1
a818 1
    new_collate(curcoll);
d822 1
a822 1
    new_numeric(curnum);
d832 1
a832 1
Perl_init_i18nl14n(pTHX_ int printwarn)
d834 1
a834 1
    return init_i18nl10n(printwarn);
d847 1
a847 1
Perl_mem_collxfrm(pTHX_ const char *s, STRLEN len, STRLEN *xlen)
a895 17
#define FBM_TABLE_OFFSET 2	/* Number of bytes between EOS and table*/

/* As a space optimization, we do not compile tables for strings of length
   0 and 1, and for strings of length 2 unless FBMcf_TAIL.  These are
   special-cased in fbm_instr().

   If FBMcf_TAIL, the table is created as if the string has a trailing \n. */

/*
=for apidoc fbm_compile

Analyses the string in order to make fast searches on it using fbm_instr()
-- the Boyer-Moore algorithm.

=cut
*/

d897 1
a897 1
Perl_fbm_compile(pTHX_ SV *sv, U32 flags)
a905 2
    if (flags & FBMcf_TAIL)
	sv_catpvn(sv, "\n", 1);		/* Taken into account in fbm_instr() */
d908 2
a909 2
    if (len == 0)		/* TAIL might be on on a zero-length string. */
	return;
d911 6
a916 12
	U8 mlen;
	unsigned char *sb;

	if (len > 255)
	    mlen = 255;
	else
	    mlen = (U8)len;
	Sv_Grow(sv, len + 256 + FBM_TABLE_OFFSET);
	table = (unsigned char*)(SvPVX(sv) + len + FBM_TABLE_OFFSET);
	s = table - 1 - FBM_TABLE_OFFSET;	/* last char */
	memset((void*)table, mlen, 256);
	table[-1] = (U8)flags;
d918 6
a923 6
	sb = s - mlen + 1;			/* first char (maybe) */
	while (s >= sb) {
	    if (table[*s] == mlen)
		table[*s] = (U8)i;
	    s--, i++;
	}
d930 1
a930 1
	if (PL_freq[s[i]] < frequency) {
d932 1
a932 1
	    frequency = PL_freq[s[i]];
d937 1
a937 5
    BmUSEFUL(sv) = 100;			/* Initial value */
    if (flags & FBMcf_TAIL)
	SvTAIL_on(sv);
    DEBUG_r(PerlIO_printf(Perl_debug_log, "rarest char %c at %d\n",
			  BmRARE(sv),BmPREVIOUS(sv)));
a939 15
/* If SvTAIL(littlestr), it has a fake '\n' at end. */
/* If SvTAIL is actually due to \Z or \z, this gives false positives
   if multiline */

/*
=for apidoc fbm_instr

Returns the location of the SV in the string delimited by C<str> and
C<strend>.  It returns C<Nullch> if the string can't be found.  The C<sv>
does not have to be fbm_compiled, but the search will not be as fast
then.

=cut
*/

d941 1
a941 1
Perl_fbm_instr(pTHX_ unsigned char *big, register unsigned char *bigend, SV *littlestr, U32 flags)
d944 6
a949 13
    STRLEN l;
    register unsigned char *little = (unsigned char *)SvPV(littlestr,l);
    register STRLEN littlelen = l;
    register I32 multiline = flags & FBMrf_MULTILINE;

    if (bigend - big < littlelen) {
	if ( SvTAIL(littlestr) 
	     && (bigend - big == littlelen - 1)
	     && (littlelen == 1 
		 || (*big == *little && memEQ(big, little, littlelen - 1))))
	    return (char*)big;
	return Nullch;
    }
d951 11
a961 46
    if (littlelen <= 2) {		/* Special-cased */

	if (littlelen == 1) {
	    if (SvTAIL(littlestr) && !multiline) { /* Anchor only! */
		/* Know that bigend != big.  */
		if (bigend[-1] == '\n')
		    return (char *)(bigend - 1);
		return (char *) bigend;
	    }
	    s = big;
	    while (s < bigend) {
		if (*s == *little)
		    return (char *)s;
		s++;
	    }
	    if (SvTAIL(littlestr))
		return (char *) bigend;
	    return Nullch;
	}
	if (!littlelen)
	    return (char*)big;		/* Cannot be SvTAIL! */

	/* littlelen is 2 */
	if (SvTAIL(littlestr) && !multiline) {
	    if (bigend[-1] == '\n' && bigend[-2] == *little)
		return (char*)bigend - 2;
	    if (bigend[-1] == *little)
		return (char*)bigend - 1;
	    return Nullch;
	}
	{
	    /* This should be better than FBM if c1 == c2, and almost
	       as good otherwise: maybe better since we do less indirection.
	       And we save a lot of memory by caching no table. */
	    register unsigned char c1 = little[0];
	    register unsigned char c2 = little[1];

	    s = big + 1;
	    bigend--;
	    if (c1 != c2) {
		while (s <= bigend) {
		    if (s[0] == c2) {
			if (s[-1] == c1)
			    return (char*)s - 1;
			s += 2;
			continue;
a962 26
		  next_chars:
		    if (s[0] == c1) {
			if (s == bigend)
			    goto check_1char_anchor;
			if (s[1] == c2)
			    return (char*)s;
			else {
			    s++;
			    goto next_chars;
			}
		    }
		    else
			s += 2;
		}
		goto check_1char_anchor;
	    }
	    /* Now c1 == c2 */
	    while (s <= bigend) {
		if (s[0] == c1) {
		    if (s[-1] == c1)
			return (char*)s - 1;
		    if (s == bigend)
			goto check_1char_anchor;
		    if (s[1] == c1)
			return (char*)s;
		    s += 3;
d964 2
d967 1
a967 1
		    s += 2;
d969 1
d971 1
a971 4
      check_1char_anchor:		/* One char and anchor! */
	if (SvTAIL(littlestr) && (*bigend == *little))
	    return (char *)bigend;	/* bigend is already decremented. */
	return Nullch;
d973 6
a978 1
    if (SvTAIL(littlestr) && !multiline) {	/* tail anchored? */
d980 5
a984 4
	if (s >= big && bigend[-1] == '\n' && *s == *little 
	    /* Automatically of length > 2 */
	    && memEQ((char*)s + 1, (char*)little + 1, littlelen - 2))
	{
a985 6
	}
	if (s[1] == *little
	    && memEQ((char*)s + 2, (char*)little + 1, littlelen - 2))
	{
	    return (char*)s + 1;	/* how sweet it is */
	}
d988 14
a1001 9
    if (SvTYPE(littlestr) != SVt_PVBM || !SvVALID(littlestr)) {
	char *b = ninstr((char*)big,(char*)bigend,
			 (char*)little, (char*)little + littlelen);

	if (!b && SvTAIL(littlestr)) {	/* Automatically multiline!  */
	    /* Chop \n from littlestr: */
	    s = bigend - littlelen + 1;
	    if (*s == *little
		&& memEQ((char*)s + 1, (char*)little + 1, littlelen - 2))
d1005 1
a1005 1
	    return Nullch;
d1007 1
a1007 1
	return b;
d1009 9
a1017 18
    
    {	/* Do actual FBM.  */
	register unsigned char *table = little + littlelen + FBM_TABLE_OFFSET;
	register unsigned char *oldlittle;

	if (littlelen > bigend - big)
	    return Nullch;
	--littlelen;			/* Last char found by table lookup */

	s = big + littlelen;
	little += littlelen;		/* last char */
	oldlittle = little;
	if (s < bigend) {
	    register I32 tmp;

	  top2:
	    /*SUPPRESS 560*/
	    if ((tmp = table[*s])) {
d1019 1
a1019 4
		if (bigend - s > tmp) {
		    s += tmp;
		    goto top2;
		}
d1021 2
d1024 15
a1038 1
		if ((s += tmp) < bigend)
d1040 1
a1040 18
#endif
		goto check_end;
	    }
	    else {		/* less expensive than calling strncmp() */
		register unsigned char *olds = s;

		tmp = littlelen;

		while (tmp--) {
		    if (*--s == *--little)
			continue;
		    s = olds + 1;	/* here we pay the price for failure */
		    little = oldlittle;
		    if (s < bigend)	/* fake up continue to outer loop */
			goto top2;
		    goto check_end;
		}
		return (char *)s;
d1042 5
a1047 5
      check_end:
	if ( s == bigend && (table[-1] & FBMcf_TAIL)
	     && memEQ(bigend - littlelen, oldlittle - littlelen, littlelen) )
	    return (char*)bigend - littlelen;
	return Nullch;
d1049 1
d1058 2
a1059 3

   Note that we take into account SvTAIL, so one can get extra
   optimizations if _ALL flag is set.
a1061 4
/* If SvTAIL is actually due to \Z or \z, this gives false positives
   if PL_multiline.  In fact if !PL_multiline the autoritative answer
   is not supported yet. */

d1063 1
a1063 1
Perl_screaminstr(pTHX_ SV *bigstr, SV *littlestr, I32 start_shift, I32 end_shift, I32 *old_posp, I32 last)
d1078 1
a1078 9
	: (((pos = *old_posp), pos += PL_screamnext[pos]) == 0)) {
      cant_find:
	if ( BmRARE(littlestr) == '\n' 
	     && BmPREVIOUS(littlestr) == SvCUR(littlestr) - 1) {
	    little = (unsigned char *)(SvPVX(littlestr));
	    littleend = little + SvCUR(littlestr);
	    first = *little++;
	    goto check_tail;
	}
a1079 2
    }

d1088 1
a1088 5
    if (previous + start_shift > stop_pos) {
	if (previous + start_shift == stop_pos + 1) /* A fake '\n'? */
	    goto check_tail;
	return Nullch;
    }
d1091 1
a1091 1
	    goto cant_find;
d1129 1
a1129 2
    if (last && found) 
	return (char *)(big+(*old_posp));
a1130 13
  check_tail:
    if (!SvTAIL(littlestr) || (end_shift > 0))
	return Nullch;
    /* Ignore the trailing "\n".  This code is not microoptimized */
    big = (unsigned char *)(SvPVX(bigstr) + SvCUR(bigstr));
    stop_pos = littleend - little;	/* Actual littlestr len */
    if (stop_pos == 0)
	return (char*)big;
    big -= stop_pos;
    if (*big == first
	&& ((stop_pos == 1) || memEQ(big + 1, little, stop_pos - 1)))
	return (char*)big;
    return Nullch;
d1134 1
a1134 1
Perl_ibcmp(pTHX_ const char *s1, const char *s2, register I32 len)
d1139 1
a1139 1
	if (*a != *b && *a != PL_fold[*b])
d1147 1
a1147 1
Perl_ibcmp_locale(pTHX_ const char *s1, const char *s2, register I32 len)
d1152 1
a1152 1
	if (*a != *b && *a != PL_fold_locale[*b])
a1160 8
/*
=for apidoc savepv

Copy a string to a safe spot.  This does not use an SV.

=cut
*/

d1162 1
a1162 1
Perl_savepv(pTHX_ const char *sv)
a1172 9
/*
=for apidoc savepvn

Copy a string to a safe spot.  The C<len> indicates number of bytes to
copy.  This does not use an SV.

=cut
*/

d1174 1
a1174 1
Perl_savepvn(pTHX_ const char *sv, register I32 len)
d1184 1
a1184 1
/* the SV for Perl_form() and mess() is not kept in an arena */
d1187 1
a1187 1
S_mess_alloc(pTHX)
a1188 1
    dTHR;
a1191 6
    if (!PL_dirty)
	return sv_2mortal(newSVpvn("",0));

    if (PL_mess_sv)
	return PL_mess_sv;

a1197 1
    PL_mess_sv = sv;
a1200 1
#if defined(PERL_IMPLICIT_CONTEXT)
d1202 1
a1202 1
Perl_form_nocontext(const char* pat, ...)
a1203 2
    dTHX;
    char *retval;
d1206 3
a1208 1
    retval = vform(pat, &args);
d1210 1
a1210 1
    return retval;
a1211 1
#endif /* PERL_IMPLICIT_CONTEXT */
d1214 1
a1214 1
Perl_form(pTHX_ const char* pat, ...)
d1216 1
a1216 45
    char *retval;
    va_list args;
    va_start(args, pat);
    retval = vform(pat, &args);
    va_end(args);
    return retval;
}

char *
Perl_vform(pTHX_ const char *pat, va_list *args)
{
    SV *sv = mess_alloc();
    sv_vsetpvfn(sv, pat, strlen(pat), args, Null(SV**), 0, Null(bool*));
    return SvPVX(sv);
}

#if defined(PERL_IMPLICIT_CONTEXT)
SV *
Perl_mess_nocontext(const char *pat, ...)
{
    dTHX;
    SV *retval;
    va_list args;
    va_start(args, pat);
    retval = vmess(pat, &args);
    va_end(args);
    return retval;
}
#endif /* PERL_IMPLICIT_CONTEXT */

SV *
Perl_mess(pTHX_ const char *pat, ...)
{
    SV *retval;
    va_list args;
    va_start(args, pat);
    retval = vmess(pat, &args);
    va_end(args);
    return retval;
}

SV *
Perl_vmess(pTHX_ const char *pat, va_list *args)
{
    SV *sv = mess_alloc();
d1219 3
d1225 15
a1239 10
	if (CopLINE(PL_curcop))
	    Perl_sv_catpvf(aTHX_ sv, " at %s line %"IVdf,
			   CopFILE(PL_curcop), (IV)CopLINE(PL_curcop));
	if (GvIO(PL_last_in_gv) && IoLINES(GvIOp(PL_last_in_gv))) {
	    bool line_mode = (RsSIMPLE(PL_rs) &&
			      SvCUR(PL_rs) == 1 && *SvPVX(PL_rs) == '\n');
	    Perl_sv_catpvf(aTHX_ sv, ", <%s> %s %"IVdf,
		      PL_last_in_gv == PL_argvgv ? "" : GvNAME(PL_last_in_gv),
		      line_mode ? "line" : "chunk", 
		      (IV)IoLINES(GvIOp(PL_last_in_gv)));
a1240 5
#ifdef USE_THREADS
	if (thr->tid)
	    Perl_sv_catpvf(aTHX_ sv, " thread %ld", thr->tid);
#endif
	sv_catpv(sv, PL_dirty ? dgd : ".\n");
d1242 1
a1242 1
    return sv;
d1246 1
a1246 1
Perl_vdie(pTHX_ const char* pat, va_list *args)
d1249 1
a1254 2
    SV *msv;
    STRLEN msglen;
d1256 1
a1256 1
    DEBUG_S(PerlIO_printf(Perl_debug_log,
d1260 3
a1262 14
    if (pat) {
	msv = vmess(pat, args);
	if (PL_errors && SvCUR(PL_errors)) {
	    sv_catsv(PL_errors, msv);
	    message = SvPV(PL_errors, msglen);
	    SvCUR_set(PL_errors, 0);
	}
	else
	    message = SvPV(msv,msglen);
    }
    else {
	message = Nullch;
	msglen = 0;
    }
d1264 1
a1264 1
    DEBUG_S(PerlIO_printf(Perl_debug_log,
d1268 1
a1268 1
	/* sv_2cv might call Perl_croak() */
d1280 2
a1281 3
	    save_re_context();
	    if (message) {
		msg = newSVpvn(message, msglen);
d1293 1
a1293 1
	    call_sv((SV*)cv, G_DISCARD);
d1299 2
a1300 2
    PL_restartop = die_where(message, msglen);
    DEBUG_S(PerlIO_printf(Perl_debug_log,
a1307 25
#if defined(PERL_IMPLICIT_CONTEXT)
OP *
Perl_die_nocontext(const char* pat, ...)
{
    dTHX;
    OP *o;
    va_list args;
    va_start(args, pat);
    o = vdie(pat, &args);
    va_end(args);
    return o;
}
#endif /* PERL_IMPLICIT_CONTEXT */

OP *
Perl_die(pTHX_ const char* pat, ...)
{
    OP *o;
    va_list args;
    va_start(args, pat);
    o = vdie(pat, &args);
    va_end(args);
    return o;
}

d1309 1
a1309 1
Perl_vcroak(pTHX_ const char* pat, va_list *args)
d1312 1
a1316 14
    SV *msv;
    STRLEN msglen;

    msv = vmess(pat, args);
    if (PL_errors && SvCUR(PL_errors)) {
	sv_catsv(PL_errors, msv);
	message = SvPV(PL_errors, msglen);
	SvCUR_set(PL_errors, 0);
    }
    else
	message = SvPV(msv,msglen);

    DEBUG_S(PerlIO_printf(Perl_debug_log, "croak: 0x%"UVxf" %s",
			  PTR2UV(thr), message));
d1318 4
d1323 1
a1323 1
	/* sv_2cv might call Perl_croak() */
d1335 1
a1335 2
	    save_re_context();
	    msg = newSVpvn(message, msglen);
d1343 1
a1343 1
	    call_sv((SV*)cv, G_DISCARD);
d1349 1
a1349 1
	PL_restartop = die_where(message, msglen);
d1352 2
a1353 13
    {
#ifdef USE_SFIO
	/* SFIO can really mess with your errno */
	int e = errno;
#endif
	PerlIO *serr = Perl_error_log;

	PerlIO_write(serr, message, msglen);
	(void)PerlIO_flush(serr);
#ifdef USE_SFIO
	errno = e;
#endif
    }
a1356 23
#if defined(PERL_IMPLICIT_CONTEXT)
void
Perl_croak_nocontext(const char *pat, ...)
{
    dTHX;
    va_list args;
    va_start(args, pat);
    vcroak(pat, &args);
    /* NOTREACHED */
    va_end(args);
}
#endif /* PERL_IMPLICIT_CONTEXT */

/*
=for apidoc croak

This is the XSUB-writer's interface to Perl's C<die> function.  Use this
function the same way you use the C C<printf> function.  See
C<warn>.

=cut
*/

d1358 1
a1358 1
Perl_croak(pTHX_ const char *pat, ...)
a1360 9
    va_start(args, pat);
    vcroak(pat, &args);
    /* NOTREACHED */
    va_end(args);
}

void
Perl_vwarn(pTHX_ const char* pat, va_list *args)
{
a1364 2
    SV *msv;
    STRLEN msglen;
d1366 3
a1368 2
    msv = vmess(pat, args);
    message = SvPV(msv, msglen);
d1371 1
a1371 1
	/* sv_2cv might call Perl_warn() */
d1384 1
a1384 2
	    save_re_context();
	    msg = newSVpvn(message, msglen);
d1392 1
a1392 1
	    call_sv((SV*)cv, G_DISCARD);
d1398 1
a1398 4
    {
	PerlIO *serr = Perl_error_log;

	PerlIO_write(serr, message, msglen);
d1400 6
a1405 6
	DEBUG_L(*message == '!' 
		? (xstat(message[1]=='!'
			 ? (message[2]=='!' ? 2 : 1)
			 : 0)
		   , 0)
		: 0);
d1407 1
a1407 152
	(void)PerlIO_flush(serr);
    }
}

#if defined(PERL_IMPLICIT_CONTEXT)
void
Perl_warn_nocontext(const char *pat, ...)
{
    dTHX;
    va_list args;
    va_start(args, pat);
    vwarn(pat, &args);
    va_end(args);
}
#endif /* PERL_IMPLICIT_CONTEXT */

/*
=for apidoc warn

This is the XSUB-writer's interface to Perl's C<warn> function.  Use this
function the same way you use the C C<printf> function.  See
C<croak>.

=cut
*/

void
Perl_warn(pTHX_ const char *pat, ...)
{
    va_list args;
    va_start(args, pat);
    vwarn(pat, &args);
    va_end(args);
}

#if defined(PERL_IMPLICIT_CONTEXT)
void
Perl_warner_nocontext(U32 err, const char *pat, ...)
{
    dTHX;
    va_list args;
    va_start(args, pat);
    vwarner(err, pat, &args);
    va_end(args);
}
#endif /* PERL_IMPLICIT_CONTEXT */

void
Perl_warner(pTHX_ U32  err, const char* pat,...)
{
    va_list args;
    va_start(args, pat);
    vwarner(err, pat, &args);
    va_end(args);
}

void
Perl_vwarner(pTHX_ U32  err, const char* pat, va_list* args)
{
    dTHR;
    char *message;
    HV *stash;
    GV *gv;
    CV *cv;
    SV *msv;
    STRLEN msglen;

    msv = vmess(pat, args);
    message = SvPV(msv, msglen);

    if (ckDEAD(err)) {
#ifdef USE_THREADS
        DEBUG_S(PerlIO_printf(Perl_debug_log, "croak: 0x%"UVxf" %s", PTR2UV(thr), message));
#endif /* USE_THREADS */
        if (PL_diehook) {
            /* sv_2cv might call Perl_croak() */
            SV *olddiehook = PL_diehook;
            ENTER;
            SAVESPTR(PL_diehook);
            PL_diehook = Nullsv;
            cv = sv_2cv(olddiehook, &stash, &gv, 0);
            LEAVE;
            if (cv && !CvDEPTH(cv) && (CvROOT(cv) || CvXSUB(cv))) {
                dSP;
                SV *msg;
 
                ENTER;
		save_re_context();
                msg = newSVpvn(message, msglen);
                SvREADONLY_on(msg);
                SAVEFREESV(msg);
 
		PUSHSTACKi(PERLSI_DIEHOOK);
                PUSHMARK(sp);
                XPUSHs(msg);
                PUTBACK;
                call_sv((SV*)cv, G_DISCARD);
		POPSTACK;
                LEAVE;
            }
        }
        if (PL_in_eval) {
            PL_restartop = die_where(message, msglen);
            JMPENV_JUMP(3);
        }
	{
	    PerlIO *serr = Perl_error_log;
	    PerlIO_write(serr, message, msglen);
	    (void)PerlIO_flush(serr);
	}
        my_failure_exit();

    }
    else {
        if (PL_warnhook) {
            /* sv_2cv might call Perl_warn() */
            dTHR;
            SV *oldwarnhook = PL_warnhook;
            ENTER;
            SAVESPTR(PL_warnhook);
            PL_warnhook = Nullsv;
            cv = sv_2cv(oldwarnhook, &stash, &gv, 0);
	    LEAVE;
            if (cv && !CvDEPTH(cv) && (CvROOT(cv) || CvXSUB(cv))) {
                dSP;
                SV *msg;
 
                ENTER;
		save_re_context();
                msg = newSVpvn(message, msglen);
                SvREADONLY_on(msg);
                SAVEFREESV(msg);
 
		PUSHSTACKi(PERLSI_WARNHOOK);
                PUSHMARK(sp);
                XPUSHs(msg);
                PUTBACK;
                call_sv((SV*)cv, G_DISCARD);
		POPSTACK;
                LEAVE;
                return;
            }
        }
	{
	    PerlIO *serr = Perl_error_log;
	    PerlIO_write(serr, message, msglen);
#ifdef LEAKTEST
	    DEBUG_L(xstat());
#endif
	    (void)PerlIO_flush(serr);
	}
    }
d1411 1
a1411 1
#if !defined(WIN32) && !defined(__CYGWIN__)
d1413 1
a1413 1
Perl_my_setenv(pTHX_ char *nam, char *val)
a1414 2
#ifndef PERL_USE_SAFE_PUTENV
    /* most putenv()s leak, so we manipulate environ directly */
d1424 3
a1426 5
	tmpenv = (char**)safesysmalloc((max+2) * sizeof(char*));
	for (j=0; j<max; j++) {		/* copy environment */
	    tmpenv[j] = (char*)safesysmalloc((strlen(environ[j])+1)*sizeof(char));
	    strcpy(tmpenv[j], environ[j]);
	}
d1431 1
a1431 1
	safesysfree(environ[i]);
d1439 1
a1439 1
	environ = (char**)safesysrealloc(environ, (i+2) * sizeof(char*));
d1443 3
a1445 3
	safesysfree(environ[i]);
    environ[i] = (char*)safesysmalloc((strlen(nam)+strlen(val)+2) * sizeof(char));

d1447 9
a1455 8

#else   /* PERL_USE_SAFE_PUTENV */
    char *new_env;

    new_env = (char*)safesysmalloc((strlen(nam) + strlen(val) + 2) * sizeof(char));
    (void)sprintf(new_env,"%s=%s",nam,val);/* all that work just for this */
    (void)putenv(new_env);
#endif  /* PERL_USE_SAFE_PUTENV */
a1457 35
#else /* WIN32 || __CYGWIN__ */
#if defined(__CYGWIN__)
/*
 * Save environ of perl.exe, currently Cygwin links in separate environ's
 * for each exe/dll.  Probably should be a member of impure_ptr.
 */
static char ***Perl_main_environ;

EXTERN_C void
Perl_my_setenv_init(char ***penviron)
{
    Perl_main_environ = penviron;
}

void
Perl_my_setenv(pTHX_ char *nam, char *val)
{
    /* You can not directly manipulate the environ[] array because
     * the routines do some additional work that syncs the Cygwin
     * environment with the Windows environment.
     */
    char *oldstr = environ[setenv_getix(nam)];

    if (!val) {
       if (!oldstr)
           return;
       unsetenv(nam);
       safesysfree(oldstr);
       return;
    }
    setenv(nam, val, 1);
    environ = *Perl_main_environ; /* environ realloc can occur in setenv */
    if(oldstr && environ[setenv_getix(nam)] != oldstr)
       safesysfree(oldstr);
}
d1461 1
a1461 1
Perl_my_setenv(pTHX_ char *nam,char *val)
d1493 1
a1493 1
    envstr = (char*)safesysmalloc((namlen + vallen + 3) * sizeof(char));
d1497 1
a1497 1
	safesysfree(oldstr);
d1499 1
a1499 1
    safesysfree(envstr);	/* MSVCRT leaks without this */
a1518 1
#endif
d1521 1
a1521 1
Perl_setenv_getix(pTHX_ char *nam)
d1542 2
a1543 1
Perl_unlnk(pTHX_ char *f)	/* unlink all versions of a file */
a1551 1
/* this is a drop-in replacement for bcopy() */
d1554 1
a1554 1
Perl_my_bcopy(register const char *from,register char *to,register I32 len)
a1571 1
/* this is a drop-in replacement for memset() */
d1574 4
a1577 1
Perl_my_memset(register char *loc, register I32 ch, register I32 len)
a1586 1
/* this is a drop-in replacement for bzero() */
d1589 3
a1591 1
Perl_my_bzero(register char *loc, register I32 len)
a1600 1
/* this is a drop-in replacement for memcmp() */
d1603 4
a1606 1
Perl_my_memcmp(const char *s1, const char *s2, register I32 len)
d1627 4
a1630 1
vsprintf(char *dest, const char *pat, char *args)
d1654 1
a1654 1
Perl_my_swap(pTHX_ short s)
d1667 1
a1667 1
Perl_my_htonl(pTHX_ long l)
d1682 1
a1682 1
    Perl_croak(aTHX_ "Unknown BYTEORDER\n");
d1696 1
a1696 1
Perl_my_ntohl(pTHX_ long l)
d1711 1
a1711 1
    Perl_croak(aTHX_ "Unknown BYTEORDER\n");
d1739 2
a1740 1
	name (register type n)					\
d1756 2
a1757 1
	name (register type n)					\
d1787 1
a1787 1
#if (!defined(DOSISH) || defined(HAS_FORK) || defined(AMIGAOS)) && !defined(VMS) && !defined(__OPEN_VM) && !defined(EPOC) && !defined(MACOS_TRADITIONAL)
d1789 1
a1789 1
Perl_my_popen(pTHX_ char *cmd, char *mode)
d1793 1
a1793 1
    register Pid_t pid;
a1795 2
    I32 did_pipes = 0;
    int pp[2];
a1796 1
    PERL_FLUSHALL_FOR_CHILD;
a1809 2
    if (doexec && PerlProc_pipe(pp) >= 0)
	did_pipes = 1;
a1812 4
	    if (did_pipes) {
		PerlLIO_close(pp[0]);
		PerlLIO_close(pp[1]);
	    }
d1814 1
a1814 1
		Perl_croak(aTHX_ "Can't fork");
a1826 6
	if (did_pipes) {
	    PerlLIO_close(pp[0]);
#if defined(HAS_FCNTL) && defined(F_SETFD)
	    fcntl(pp[1], F_SETFD, FD_CLOEXEC);
#endif
	}
a1830 1
#ifndef OS2
d1839 1
a1839 2
		if (fd != pp[1])
		    PerlLIO_close(fd);
d1841 1
a1841 1
	    do_exec3(cmd,pp[1],did_pipes);	/* may or may not use the shell */
a1843 1
#endif	/* defined OS2 */
d1845 2
a1846 2
	if ((tmpgv = gv_fetchpv("$",TRUE, SVt_PV)))
	    sv_setiv(GvSV(tmpgv), PerlProc_getpid());
a1854 2
    if (did_pipes)
	PerlLIO_close(pp[1]);
a1863 23
    if (did_pipes && pid > 0) {
	int errkid;
	int n = 0, n1;

	while (n < sizeof(int)) {
	    n1 = PerlLIO_read(pp[0],
			      (void*)(((char*)&errkid)+n),
			      (sizeof(int)) - n);
	    if (n1 <= 0)
		break;
	    n += n1;
	}
	PerlLIO_close(pp[0]);
	did_pipes = 0;
	if (n) {			/* Error */
	    if (n != sizeof(int))
		Perl_croak(aTHX_ "panic: kid popen errno read");
	    errno = errkid;		/* Propagate errno from kid */
	    return Nullfp;
	}
    }
    if (did_pipes)
	 PerlLIO_close(pp[0]);
d1870 3
a1872 1
Perl_my_popen(pTHX_ char *cmd, char *mode)
a1875 1
    PERL_FLUSHALL_FOR_CHILD;
d1884 1
a1884 1
Perl_dump_fds(pTHX_ char *s)
d1889 1
a1889 1
    PerlIO_printf(Perl_debug_log,"%s", s);
d1892 1
a1892 1
	    PerlIO_printf(Perl_debug_log," %d",fd);
d1894 1
a1894 1
    PerlIO_printf(Perl_debug_log,"\n");
d1900 3
a1902 1
dup2(int oldfd, int newfd)
d1938 1
a1938 1
Perl_rsignal(pTHX_ int signo, Sighandler_t handler)
d1959 1
a1959 1
Perl_rsignal_state(pTHX_ int signo)
d1970 1
a1970 1
Perl_rsignal_save(pTHX_ int signo, Sighandler_t handler, Sigsave_t *save)
d1988 1
a1988 1
Perl_rsignal_restore(pTHX_ int signo, Sigsave_t *save)
d1996 1
a1996 1
Perl_rsignal(pTHX_ int signo, Sighandler_t handler)
d2011 1
a2011 1
Perl_rsignal_state(pTHX_ int signo)
d2019 1
a2019 1
        PerlProc_kill(PerlProc_getpid(), signo);
d2024 1
a2024 1
Perl_rsignal_save(pTHX_ int signo, Sighandler_t handler, Sigsave_t *save)
d2031 1
a2031 1
Perl_rsignal_restore(pTHX_ int signo, Sigsave_t *save)
d2039 1
a2039 1
#if (!defined(DOSISH) || defined(HAS_FORK) || defined(AMIGAOS)) && !defined(VMS) && !defined(__OPEN_VM) && !defined(EPOC) && !defined(MACOS_TRADITIONAL)
d2041 1
a2041 1
Perl_my_pclose(pTHX_ PerlIO *ptr)
d2046 2
a2047 2
    Pid_t pid;
    Pid_t pid2;
d2058 1
a2058 1
    pid = SvIVX(*svp);
d2095 1
a2095 1
#if  (!defined(DOSISH) || defined(OS2) || defined(WIN32)) && !defined(MACOS_TRADITIONAL)
d2097 1
a2097 1
Perl_wait4pid(pTHX_ Pid_t pid, int *statusp, int flags)
d2106 1
a2106 1
	sprintf(spid, "%"IVdf, (IV)pid);
d2118 1
a2118 1
	if ((entry = hv_iternext(PL_pidstatus))) {
d2122 1
a2122 1
	    sprintf(spid, "%"IVdf, (IV)pid);
d2142 1
a2142 1
	    Perl_croak(aTHX_ "Can't do waitpid with flags");
d2157 1
a2157 1
Perl_pidgone(pTHX_ Pid_t pid, int status)
d2162 1
a2162 1
    sprintf(spid, "%"IVdf, (IV)pid);
d2174 1
a2174 1
my_syspclose(PerlIO *ptr)
d2177 1
a2177 1
Perl_my_pclose(pTHX_ PerlIO *ptr)
d2179 1
a2183 3
#if defined(DJGPP)
    result = (result << 8) & 0xff00;
#endif
d2190 1
a2190 1
Perl_repeatcpy(pTHX_ register char *to, register const char *from, I32 len, register I32 count)
d2193 1
a2193 1
    register const char *frombase = from;
d2196 1
a2196 1
	register const char c = *from;
d2209 1
d2211 2
a2212 1
Perl_cast_ulong(pTHX_ NV f)
d2227 3
d2252 2
a2253 1
Perl_cast_i32(pTHX_ NV f)
d2263 2
a2264 1
Perl_cast_iv(pTHX_ NV f)
d2266 2
a2267 8
    if (f >= IV_MAX) {
	UV uv;
	
	if (f >= (NV)UV_MAX)
	    return (IV) UV_MAX;	
	uv = (UV) f;
	return (IV)uv;
    }
d2274 2
a2275 1
Perl_cast_uv(pTHX_ NV f)
a2278 8
    if (f < 0) {
	IV iv;
	
	if (f < IV_MIN)
	    return (UV)IV_MIN;
	iv = (IV) f;
	return (UV) iv;
    }
d2282 2
d2286 3
a2288 1
Perl_same_dirent(pTHX_ char *a, char *b)
d2323 2
a2324 2
NV
Perl_scan_bin(pTHX_ char *start, I32 len, I32 *retlen)
d2327 2
a2328 24
    register NV rnv = 0.0;
    register UV ruv = 0;
    register bool seenb = FALSE;
    register bool overflowed = FALSE;

    for (; len-- && *s; s++) {
	if (!(*s == '0' || *s == '1')) {
	    if (*s == '_')
		continue; /* Note: does not check for __ and the like. */
	    if (seenb == FALSE && *s == 'b' && ruv == 0) {
		/* Disallow 0bbb0b0bbb... */
		seenb = TRUE;
		continue;
	    }
	    else {
		dTHR;
		if (ckWARN(WARN_DIGIT))
		    Perl_warner(aTHX_ WARN_DIGIT,
				"Illegal binary digit '%c' ignored", *s);
		break;
	    }
	}
	if (!overflowed) {
	    register UV xuv = ruv << 1;
d2330 5
a2334 61
	    if ((xuv >> 1) != ruv) {
		dTHR;
		overflowed = TRUE;
		rnv = (NV) ruv;
		if (ckWARN_d(WARN_OVERFLOW))
		    Perl_warner(aTHX_ WARN_OVERFLOW,
				"Integer overflow in binary number");
	    } else
		ruv = xuv | (*s - '0');
	}
	if (overflowed) {
	    rnv *= 2;
	    /* If an NV has not enough bits in its mantissa to
	     * represent an UV this summing of small low-order numbers
	     * is a waste of time (because the NV cannot preserve
	     * the low-order bits anyway): we could just remember when
	     * did we overflow and in the end just multiply rnv by the
	     * right amount. */
	    rnv += (*s - '0');
	}
    }
    if (!overflowed)
	rnv = (NV) ruv;
    if (   ( overflowed && rnv > 4294967295.0)
#if UVSIZE > 4
	|| (!overflowed && ruv > 0xffffffff  )
#endif
	) { 
	dTHR;
	if (ckWARN(WARN_PORTABLE))
	    Perl_warner(aTHX_ WARN_PORTABLE,
			"Binary number > 0b11111111111111111111111111111111 non-portable");
    }
    *retlen = s - start;
    return rnv;
}

NV
Perl_scan_oct(pTHX_ char *start, I32 len, I32 *retlen)
{
    register char *s = start;
    register NV rnv = 0.0;
    register UV ruv = 0;
    register bool overflowed = FALSE;

    for (; len-- && *s; s++) {
	if (!(*s >= '0' && *s <= '7')) {
	    if (*s == '_')
		continue; /* Note: does not check for __ and the like. */
	    else {
		/* Allow \octal to work the DWIM way (that is, stop scanning
		 * as soon as non-octal characters are seen, complain only iff
		 * someone seems to want to use the digits eight and nine). */
		if (*s == '8' || *s == '9') {
		    dTHR;
		    if (ckWARN(WARN_DIGIT))
			Perl_warner(aTHX_ WARN_DIGIT,
				    "Illegal octal digit '%c' ignored", *s);
		}
		break;
	    }
d2336 2
a2337 35
	if (!overflowed) {
	    register UV xuv = ruv << 3;

	    if ((xuv >> 3) != ruv) {
		dTHR;
		overflowed = TRUE;
		rnv = (NV) ruv;
		if (ckWARN_d(WARN_OVERFLOW))
		    Perl_warner(aTHX_ WARN_OVERFLOW,
				"Integer overflow in octal number");
	    } else
		ruv = xuv | (*s - '0');
	}
	if (overflowed) {
	    rnv *= 8.0;
	    /* If an NV has not enough bits in its mantissa to
	     * represent an UV this summing of small low-order numbers
	     * is a waste of time (because the NV cannot preserve
	     * the low-order bits anyway): we could just remember when
	     * did we overflow and in the end just multiply rnv by the
	     * right amount of 8-tuples. */
	    rnv += (NV)(*s - '0');
	}
    }
    if (!overflowed)
	rnv = (NV) ruv;
    if (   ( overflowed && rnv > 4294967295.0)
#if UVSIZE > 4
	|| (!overflowed && ruv > 0xffffffff  )
#endif
	) {
	dTHR;
	if (ckWARN(WARN_PORTABLE))
	    Perl_warner(aTHX_ WARN_PORTABLE,
			"Octal number > 037777777777 non-portable");
d2339 2
d2342 1
a2342 1
    return rnv;
d2345 2
a2346 2
NV
Perl_scan_hex(pTHX_ char *start, I32 len, I32 *retlen)
d2349 9
a2357 14
    register NV rnv = 0.0;
    register UV ruv = 0;
    register bool seenx = FALSE;
    register bool overflowed = FALSE;
    char *hexdigit;

    for (; len-- && *s; s++) {
	hexdigit = strchr((char *) PL_hexdigit, *s);
	if (!hexdigit) {
	    if (*s == '_')
		continue; /* Note: does not check for __ and the like. */
	    if (seenx == FALSE && *s == 'x' && ruv == 0) {
		/* Disallow 0xxx0x0xxx... */
		seenx = TRUE;
a2358 1
	    }
d2360 3
a2362 4
		dTHR;
		if (ckWARN(WARN_DIGIT))
		    Perl_warner(aTHX_ WARN_DIGIT,
				"Illegal hexadecimal digit '%c' ignored", *s);
d2366 6
a2371 35
	if (!overflowed) {
	    register UV xuv = ruv << 4;

	    if ((xuv >> 4) != ruv) {
		dTHR;
		overflowed = TRUE;
		rnv = (NV) ruv;
		if (ckWARN_d(WARN_OVERFLOW))
		    Perl_warner(aTHX_ WARN_OVERFLOW,
				"Integer overflow in hexadecimal number");
	    } else
		ruv = xuv | ((hexdigit - PL_hexdigit) & 15);
	}
	if (overflowed) {
	    rnv *= 16.0;
	    /* If an NV has not enough bits in its mantissa to
	     * represent an UV this summing of small low-order numbers
	     * is a waste of time (because the NV cannot preserve
	     * the low-order bits anyway): we could just remember when
	     * did we overflow and in the end just multiply rnv by the
	     * right amount of 16-tuples. */
	    rnv += (NV)((hexdigit - PL_hexdigit) & 15);
	}
    }
    if (!overflowed)
	rnv = (NV) ruv;
    if (   ( overflowed && rnv > 4294967295.0)
#if UVSIZE > 4
	|| (!overflowed && ruv > 0xffffffff  )
#endif
	) { 
	dTHR;
	if (ckWARN(WARN_PORTABLE))
	    Perl_warner(aTHX_ WARN_PORTABLE,
			"Hexadecimal number > 0xffffffff non-portable");
d2374 1
a2374 1
    return rnv;
d2378 1
a2378 1
Perl_find_script(pTHX_ char *scriptname, bool dosearch, char **search_ext, I32 flags)
d2383 1
a2383 1
    char tmpbuf[MAXPATHLEN];
a2495 4
#ifdef MACOS_TRADITIONAL
    if (dosearch && !strchr(scriptname, ':') &&
	(s = PerlEnv_getenv("Commands")))
#else
d2500 1
a2500 3
		 && (s = PerlEnv_getenv("PATH")))
#endif
    {
a2504 5
#ifdef MACOS_TRADITIONAL
	    s = delimcpy(tmpbuf, tmpbuf + sizeof tmpbuf, s, PL_bufend,
			',',
			&len);
#else
a2520 1
#endif /* MACOS_TRADITIONAL */
a2524 4
#ifdef MACOS_TRADITIONAL
	    if (len && tmpbuf[len - 1] != ':')
	    	tmpbuf[len++] = ':';
#else
d2526 1
a2526 1
#if defined(atarist) || defined(__MINT__) || defined(DOSISH)
a2533 1
#endif
d2558 1
a2558 1
#if !defined(DOSISH) && !defined(MACOS_TRADITIONAL)
d2577 1
a2577 1
	        Perl_croak(aTHX_ "Can't %s %s%s%s",
a2591 37
#ifndef PERL_GET_CONTEXT_DEFINED

void *
Perl_get_context(void)
{
#if defined(USE_THREADS) || defined(USE_ITHREADS)
#  ifdef OLD_PTHREADS_API
    pthread_addr_t t;
    if (pthread_getspecific(PL_thr_key, &t))
	Perl_croak_nocontext("panic: pthread_getspecific");
    return (void*)t;
#  else
#  ifdef I_MACH_CTHREADS
    return (void*)cthread_data(cthread_self());
#  else
    return (void*)pthread_getspecific(PL_thr_key);
#  endif
#  endif
#else
    return (void*)NULL;
#endif
}

void
Perl_set_context(void *t)
{
#if defined(USE_THREADS) || defined(USE_ITHREADS)
#  ifdef I_MACH_CTHREADS
    cthread_set_data(cthread_self(), t);
#  else
    if (pthread_setspecific(PL_thr_key, t))
	Perl_croak_nocontext("panic: pthread_setspecific");
#  endif
#endif
}

#endif /* !PERL_GET_CONTEXT_DEFINED */
a2593 1

d2603 2
a2604 1
Perl_cond_init(pTHX_ perl_cond *cp)
d2610 2
a2611 1
Perl_cond_signal(pTHX_ perl_cond *cp)
d2631 2
a2632 1
Perl_cond_broadcast(pTHX_ perl_cond *cp)
d2653 2
a2654 1
Perl_cond_wait(pTHX_ perl_cond *cp)
d2659 1
a2659 1
	Perl_croak(aTHX_ "panic: perl_cond_wait called by last runnable thread");
d2672 12
d2685 1
a2685 1
Perl_condpair_magic(pTHX_ SV *sv)
d2699 1
a2699 1
	LOCK_CRED_MUTEX;		/* XXX need separate mutex? */
d2703 1
a2703 1
	    UNLOCK_CRED_MUTEX;		/* XXX need separate mutex? */
d2714 2
a2715 2
	    UNLOCK_CRED_MUTEX;		/* XXX need separate mutex? */
	    DEBUG_S(WITH_THR(PerlIO_printf(Perl_debug_log,
d2730 1
a2730 1
Perl_new_struct_thread(pTHX_ struct perl_thread *t)
a2731 1
#if !defined(PERL_IMPLICIT_CONTEXT)
a2732 1
#endif
d2737 1
a2737 1
    sv = newSVpvn("", 0);
d2755 1
a2755 1
    init_stacks();
a2757 1
    thr->interp = t->interp;
d2761 2
a2762 1
    thr->errsv = newSVpvn("", 0);
a2765 1
    JMPENV_BOOTSTRAP;
d2767 14
a2780 1
    PL_in_eval = EVAL_NULL;	/* ~(EVAL_INEVAL|EVAL_WARNONLY|EVAL_KEEPERR) */
a2783 1
    PL_errors = newSVpvn("", 0);
d2785 2
a2786 5
    PL_regcompp = MEMBER_TO_FPTR(Perl_pregcomp);
    PL_regexecp = MEMBER_TO_FPTR(Perl_regexec_flags);
    PL_regint_start = MEMBER_TO_FPTR(Perl_re_intuit_start);
    PL_regint_string = MEMBER_TO_FPTR(Perl_re_intuit_string);
    PL_regfree = MEMBER_TO_FPTR(Perl_pregfree);
a2793 1
    PL_reg_poscache = Nullch;
a2797 4
#ifdef PERL_FLEXIBLE_EXCEPTIONS
    PL_protect = t->Tprotect;
#endif

d2811 1
a2813 4
    if (t->Tformtarget == t->Ttoptarget)
	PL_formtarget = PL_toptarget;
    else
	PL_formtarget = PL_bodytarget;
d2822 2
a2823 3
	    DEBUG_S(PerlIO_printf(Perl_debug_log,
		"new_struct_thread: copied threadsv %"IVdf" %p->%p\n",
				  (IV)i, t, thr));
d2841 1
a2841 1
    Perl_init_thread_intern(thr);
d2853 1
a2853 1
NV 
d2862 1
a2862 1
Perl_GetVars(pTHX)
d2869 1
a2869 1
Perl_get_op_names(pTHX)
d2871 1
a2871 1
 return PL_op_name;
d2875 1
a2875 1
Perl_get_op_descs(pTHX)
d2877 1
a2877 1
 return PL_op_desc;
d2881 1
a2881 1
Perl_get_no_modify(pTHX)
d2883 1
a2883 1
 return (char*)PL_no_modify;
d2887 1
a2887 1
Perl_get_opargs(pTHX)
d2889 1
a2889 1
 return PL_opargs;
a2891 5
PPADDR_t*
Perl_get_ppaddr(pTHX)
{
 return &PL_ppaddr;
}
d2893 2
a2894 3
#ifndef HAS_GETENV_LEN
char *
Perl_getenv_len(pTHX_ char *env_elem, unsigned long *len)
d2896 1
a2896 4
    char *env_trans = PerlEnv_getenv(env_elem);
    if (env_trans)
	*len = strlen(env_trans);
    return env_trans;
a2897 1
#endif
d2901 1
a2901 1
Perl_get_vtbl(pTHX_ int vtbl_id)
d2907 1
a2907 1
	result = &PL_vtbl_sv;
d2910 1
a2910 1
	result = &PL_vtbl_env;
d2913 1
a2913 1
	result = &PL_vtbl_envelem;
d2916 1
a2916 1
	result = &PL_vtbl_sig;
d2919 1
a2919 1
	result = &PL_vtbl_sigelem;
d2922 1
a2922 1
	result = &PL_vtbl_pack;
d2925 1
a2925 1
	result = &PL_vtbl_packelem;
d2928 1
a2928 1
	result = &PL_vtbl_dbline;
d2931 1
a2931 1
	result = &PL_vtbl_isa;
d2934 1
a2934 1
	result = &PL_vtbl_isaelem;
d2937 1
a2937 1
	result = &PL_vtbl_arylen;
d2940 1
a2940 1
	result = &PL_vtbl_glob;
d2943 1
a2943 1
	result = &PL_vtbl_mglob;
d2946 1
a2946 1
	result = &PL_vtbl_nkeys;
d2949 1
a2949 1
	result = &PL_vtbl_taint;
d2952 1
a2952 1
	result = &PL_vtbl_substr;
d2955 1
a2955 1
	result = &PL_vtbl_vec;
d2958 1
a2958 1
	result = &PL_vtbl_pos;
d2961 1
a2961 1
	result = &PL_vtbl_bm;
d2964 1
a2964 1
	result = &PL_vtbl_fm;
d2967 1
a2967 1
	result = &PL_vtbl_uvar;
d2971 1
a2971 1
	result = &PL_vtbl_mutex;
d2975 1
a2975 1
	result = &PL_vtbl_defelem;
d2978 1
a2978 7
	result = &PL_vtbl_regexp;
	break;
    case want_vtbl_regdata:
	result = &PL_vtbl_regdata;
	break;
    case want_vtbl_regdatum:
	result = &PL_vtbl_regdatum;
d2982 1
a2982 1
	result = &PL_vtbl_collxfrm;
d2986 1
a2986 1
	result = &PL_vtbl_amagic;
d2989 1
a2989 4
	result = &PL_vtbl_amagicelem;
	break;
    case want_vtbl_backref:
	result = &PL_vtbl_backref;
a2994 83
I32
Perl_my_fflush_all(pTHX)
{
#ifdef FFLUSH_NULL
    return PerlIO_flush(NULL);
#else
    long open_max = -1;
# if defined(FFLUSH_ALL) && defined(HAS_STDIO_STREAM_ARRAY)
#  ifdef PERL_FFLUSH_ALL_FOPEN_MAX
    open_max = PERL_FFLUSH_ALL_FOPEN_MAX;
#  else
#  if defined(HAS_SYSCONF) && defined(_SC_OPEN_MAX)
    open_max = sysconf(_SC_OPEN_MAX);
#  else
#   ifdef FOPEN_MAX
    open_max = FOPEN_MAX;
#   else
#    ifdef OPEN_MAX
    open_max = OPEN_MAX;
#    else
#     ifdef _NFILE
    open_max = _NFILE;
#     endif
#    endif
#   endif
#  endif
#  endif
    if (open_max > 0) {
      long i;
      for (i = 0; i < open_max; i++)
	    if (STDIO_STREAM_ARRAY[i]._file >= 0 &&
		STDIO_STREAM_ARRAY[i]._file < open_max &&
		STDIO_STREAM_ARRAY[i]._flag)
		PerlIO_flush(&STDIO_STREAM_ARRAY[i]);
      return 0;
    }
# endif
    SETERRNO(EBADF,RMS$_IFI);
    return EOF;
#endif
}

NV
Perl_my_atof(pTHX_ const char* s)
{
#ifdef USE_LOCALE_NUMERIC
    if ((PL_hints & HINT_LOCALE) && PL_numeric_local) {
	NV x, y;

	x = Perl_atof(s);
	SET_NUMERIC_STANDARD();
	y = Perl_atof(s);
	SET_NUMERIC_LOCAL();
	if ((y < 0.0 && y < x) || (y > 0.0 && y > x))
	    return y;
	return x;
    }
    else
	return Perl_atof(s);
#else
    return Perl_atof(s);
#endif
}

void
Perl_report_closed_fh(pTHX_ GV *gv, IO *io, const char *func, const char *obj)
{
    SV *sv;
    char *name;

    assert(gv);

    sv = sv_newmortal();
    gv_efullname3(sv, gv, Nullch);
    name = SvPVX(sv);

    Perl_warner(aTHX_ WARN_CLOSED, "%s() on closed %s %s", func, obj, name);

    if (io && IoDIRP(io))
	Perl_warner(aTHX_ WARN_CLOSED,
		    "\t(Are you trying to call %s() on dirhandle %s?)\n",
		    func, name);
}
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2001, Larry Wall
d27 5
d467 1
a467 1
Perl_new_ctype(pTHX_ char *newctype)
a485 44
 * Standardize the locale name from a string returned by 'setlocale'.
 *
 * The standard return value of setlocale() is either
 * (1) "xx_YY" if the first argument of setlocale() is not LC_ALL
 * (2) "xa_YY xb_YY ..." if the first argument of setlocale() is LC_ALL
 *     (the space-separated values represent the various sublocales,
 *      in some unspecificed order)
 *
 * In some platforms it has a form like "LC_SOMETHING=Lang_Country.866\n",
 * which is harmful for further use of the string in setlocale().
 *
 */
STATIC char *
S_stdize_locale(pTHX_ char *locs)
{
    char *s;
    bool okay = TRUE;

    if ((s = strchr(locs, '='))) {
	char *t;

	okay = FALSE;
	if ((t = strchr(s, '.'))) {
	    char *u;

	    if ((u = strchr(t, '\n'))) {

		if (u[1] == 0) {
		    STRLEN len = u - s;
		    Move(s + 1, locs, len, char);
		    locs[len] = 0;
		    okay = TRUE;
		}
	    }
	}
    }

    if (!okay)
	Perl_croak(aTHX_ "Can't fix broken locale name \"%s\"", locs);

    return locs;
}

/*
d489 1
a489 1
Perl_new_collate(pTHX_ char *newcoll)
d498 3
a501 3
	PL_collation_standard = TRUE;
	PL_collxfrm_base = 0;
	PL_collxfrm_mult = 2;
d508 1
a508 1
	PL_collation_name = stdize_locale(savepv(newcoll));
d537 5
a541 12
    if (lc && lc->decimal_point) {
	if (lc->decimal_point[0] == '.' && lc->decimal_point[1] == 0) {
	    SvREFCNT_dec(PL_numeric_radix_sv);
	    PL_numeric_radix_sv = 0;
	}
	else {
	    if (PL_numeric_radix_sv)
		sv_setpv(PL_numeric_radix_sv, lc->decimal_point);
	    else
		PL_numeric_radix_sv = newSVpv(lc->decimal_point, 0);
	}
    }
d543 1
a543 1
	PL_numeric_radix_sv = 0;
d552 1
a552 1
Perl_new_numeric(pTHX_ char *newnum)
d560 2
a562 2
	PL_numeric_standard = TRUE;
	PL_numeric_local = TRUE;
d568 1
a568 1
	PL_numeric_name = stdize_locale(savepv(newnum));
a585 1
	set_numeric_radix();
d619 1
a619 1
#if defined(USE_LOCALE)
a659 2
	else
	    curctype = savepv(curctype);
a666 2
	else
	    curcoll = savepv(curcoll);
a673 2
	else
	    curnum = savepv(curnum);
a689 2
	else
	    curctype = savepv(curctype);
a693 2
	else
	    curcoll = savepv(curcoll);
a697 2
	else
	    curnum = savepv(curnum);
a749 1
#if defined(USE_ENVIRON_ARRAY)
a759 4
#else
	    PerlIO_printf(Perl_error_log,
			  "\t(possibly more locale environment variables)\n");
#endif
d809 1
a809 1
	curctype = savepv(setlocale(LC_CTYPE, Nullch));
d812 1
a812 1
	curcoll = savepv(setlocale(LC_COLLATE, Nullch));
d815 1
a815 1
	curnum = savepv(setlocale(LC_NUMERIC, Nullch));
a817 1
    else {
a829 1
    }
a832 12
#ifdef USE_LOCALE_CTYPE
    if (curctype != NULL)
	Safefree(curctype);
#endif /* USE_LOCALE_CTYPE */
#ifdef USE_LOCALE_COLLATE
    if (curcoll != NULL)
	Safefree(curcoll);
#endif /* USE_LOCALE_COLLATE */
#ifdef USE_LOCALE_NUMERIC
    if (curnum != NULL)
	Safefree(curnum);
#endif /* USE_LOCALE_NUMERIC */
d1195 1
d1364 1
d1450 1
d1474 1
d1575 1
d1583 5
a1587 13
    if (pat) {
	msv = vmess(pat, args);
	if (PL_errors && SvCUR(PL_errors)) {
	    sv_catsv(PL_errors, msv);
	    message = SvPV(PL_errors, msglen);
	    SvCUR_set(PL_errors, 0);
	}
	else
	    message = SvPV(msv,msglen);
    }
    else {
	message = Nullch;
	msglen = 0;
d1589 2
d1609 3
a1611 8
	    if (message) {
		msg = newSVpvn(message, msglen);
		SvREADONLY_on(msg);
		SAVEFREESV(msg);
	    }
	    else {
		msg = ERRSV;
	    }
d1658 3
a1660 10
This is the XSUB-writer's interface to Perl's C<die> function.
Normally use this function the same way you use the C C<printf>
function.  See C<warn>.

If you want to throw an exception object, assign the object to
C<$@@> and then pass C<Nullch> to croak():

   errsv = get_sv("@@", TRUE);
   sv_setsv(errsv, exception_object);
   croak(Nullch);
d1690 1
d1788 1
d1845 1
d1876 1
a1876 6
	    DEBUG_L(*message == '!' 
		? (xstat(message[1]=='!'
			 ? (message[2]=='!' ? 2 : 1)
			 : 0)
		   , 0)
		: 0);
d1883 2
a1884 3
#ifdef USE_ENVIRON_ARRAY
       /* VMS' and EPOC's my_setenv() is in vms.c and epoc.c */
#if !defined(WIN32)
a1925 3
#   if defined(__CYGWIN__)
    setenv(nam, val, 1);
#   else
a1930 1
#   endif /* __CYGWIN__ */
d1934 36
a1969 1
#else /* WIN32 */
d1974 41
d2025 2
d2030 1
d2050 1
a2050 1
#endif /* !VMS && !EPOC*/
d2304 1
a2304 1
	return my_syspopen(aTHX_ cmd,mode);
a2381 1
    LOCK_FDPID_MUTEX;
a2382 1
    UNLOCK_FDPID_MUTEX;
a2598 1
    LOCK_FDPID_MUTEX;
a2599 1
    UNLOCK_FDPID_MUTEX;
a2646 1
#if !defined(HAS_WAITPID) && !defined(HAS_WAIT4) || defined(HAS_WAITPID_RUNTIME)
a2668 1
#endif
d2870 1
a2870 1
Perl_scan_bin(pTHX_ char *start, STRLEN len, STRLEN *retlen)
d2880 3
a2882 7
	    if (*s == '_' && len && *retlen
		&& (s[1] == '0' || s[1] == '1'))
	    {
		--len;
		++s;
	    }
	    else if (seenb == FALSE && *s == 'b' && ruv == 0) {
d2888 1
d2899 1
d2905 1
a2905 2
	    }
	    else
d2926 1
d2936 1
a2936 1
Perl_scan_oct(pTHX_ char *start, STRLEN len, STRLEN *retlen)
d2945 2
a2946 6
	    if (*s == '_' && len && *retlen
		&& (s[1] >= '0' && s[1] <= '7'))
	    {
		--len;
		++s;
	    }
d2952 1
d2964 1
d2970 1
a2970 2
	    }
	    else
d2991 1
d3001 1
a3001 1
Perl_scan_hex(pTHX_ char *start, STRLEN len, STRLEN *retlen)
d3013 3
a3015 7
	    if (*s == '_' && len && *retlen && s[1]
		&& (hexdigit = strchr((char *) PL_hexdigit, s[1])))
	    {
		--len;
		++s;
	    }
	    else if (seenx == FALSE && *s == 'x' && ruv == 0) {
d3021 1
d3032 1
d3038 1
a3038 2
	    }
	    else
d3059 1
d3071 1
a3451 29
SV *
Perl_sv_lock(pTHX_ SV *osv)
{
    MAGIC *mg;
    SV *sv = osv;

    LOCK_SV_LOCK_MUTEX;
    if (SvROK(sv)) {
	sv = SvRV(sv);
    }

    mg = condpair_magic(sv);
    MUTEX_LOCK(MgMUTEXP(mg));
    if (MgOWNER(mg) == thr)
	MUTEX_UNLOCK(MgMUTEXP(mg));
    else {
	while (MgOWNER(mg))
	    COND_WAIT(MgOWNERCONDP(mg), MgMUTEXP(mg));
	MgOWNER(mg) = thr;
	DEBUG_S(PerlIO_printf(Perl_debug_log,
			      "0x%"UVxf": Perl_lock lock 0x%"UVxf"\n",
			      PTR2UV(thr), PTR2UV(sv));)
	MUTEX_UNLOCK(MgMUTEXP(mg));
	SAVEDESTRUCTOR_X(Perl_unlock_condpair, sv);
    }
    UNLOCK_SV_LOCK_MUTEX;
    return sv;
}

a3481 2
    PL_efloatbuf = (char*)NULL;
    PL_efloatsize = 0;
d3500 1
a3500 1
    PL_in_eval = EVAL_NULL;	/* ~(EVAL_INEVAL|EVAL_WARNONLY|EVAL_KEEPERR|EVAL_INREQUIRE) */
d3534 1
a3534 1
    PL_rs = t->Tnrs ? SvREFCNT_inc(PL_nrs) : Nullsv;
d3580 1
a3580 1
#if defined(HUGE_VAL) || (defined(USE_LONG_DOUBLE) && defined(HUGE_VALL))
d3589 1
a3589 4
#   if defined(USE_LONG_DOUBLE) && defined(HUGE_VALL)
    return HUGE_VALL;
#   endif
    return HUGE_VAL;
d3633 1
a3633 1
Perl_getenv_len(pTHX_ const char *env_elem, unsigned long *len)
a3746 10
#if !defined(FFLUSH_NULL) && defined(HAS__FWALK)
static int S_fflush(FILE *fp);

static int
S_fflush(FILE *fp)
{
    return fflush(fp);
}
#endif

d3750 1
a3750 1
#if defined(FFLUSH_NULL)
a3752 6
# if defined(HAS__FWALK)
    /* undocumented, unprototyped, but very useful BSDism */
    extern void _fwalk(int (*)(FILE *));
    _fwalk(&S_fflush);
    return 0;
#   else
d3754 2
a3755 2
#  if defined(FFLUSH_ALL) && defined(HAS_STDIO_STREAM_ARRAY)
#   ifdef PERL_FFLUSH_ALL_FOPEN_MAX
d3757 2
a3758 2
#   else
#   if defined(HAS_SYSCONF) && defined(_SC_OPEN_MAX)
d3760 3
d3764 2
a3765 2
#    ifdef FOPEN_MAX
    open_max = FOPEN_MAX;
d3767 1
a3767 4
#     ifdef OPEN_MAX
    open_max = OPEN_MAX;
#     else
#      ifdef _NFILE
a3768 1
#      endif
d3772 2
a3773 1
#   endif
d3783 1
a3783 1
#  endif
a3785 1
# endif
a3791 1
    NV x = 0.0;
d3794 1
a3794 1
	NV y;
d3796 1
a3796 1
	Perl_atof2(s, x);
d3798 1
a3798 1
	Perl_atof2(s, y);
d3802 1
d3805 1
a3805 1
	Perl_atof2(s, x);
d3807 1
a3807 1
    Perl_atof2(s, x);
a3808 1
    return x;
d3812 1
a3812 1
Perl_report_evil_fh(pTHX_ GV *gv, IO *io, I32 op)
d3814 2
a3815 10
    char *vile;
    I32   warn_type;
    char *func =
	op == OP_READLINE   ? "readline"  :	/* "<HANDLE>" not nice */
	op == OP_LEAVEWRITE ? "write" :		/* "write exit" not nice */
	PL_op_desc[op];
    char *pars = OP_IS_FILETEST(op) ? "" : "()";
    char *type = OP_IS_SOCKET(op) || (io && IoTYPE(io) == IoTYPE_SOCKET) ?
                     "socket" : "filehandle";
    char *name = NULL;
d3817 1
a3817 8
    if (io && IoTYPE(io) == IoTYPE_CLOSED) {
	vile = "closed";
	warn_type = WARN_CLOSED;
    }
    else {
	vile = "unopened";
	warn_type = WARN_UNOPENED;
    }
d3819 3
a3821 23
    if (gv && isGV(gv)) {
	SV *sv = sv_newmortal();
	gv_efullname4(sv, gv, Nullch, FALSE);
	name = SvPVX(sv);
    }

    if (name && *name) {
	Perl_warner(aTHX_ warn_type,
		    "%s%s on %s %s %s", func, pars, vile, type, name);
	if (io && IoDIRP(io) && !(IoFLAGS(io) & IOf_FAKE_DIRP))
	    Perl_warner(aTHX_ warn_type,
			"\t(Are you trying to call %s%s on dirhandle %s?)\n",
			func, pars, name);
    }
    else {
	Perl_warner(aTHX_ warn_type,
		    "%s%s on %s %s", func, pars, vile, type);
	if (io && IoDIRP(io) && !(IoFLAGS(io) & IOf_FAKE_DIRP))
	    Perl_warner(aTHX_ warn_type,
			"\t(Are you trying to call %s%s on dirhandle?)\n",
			func, pars);
    }
}
d3823 1
a3823 3
#ifdef EBCDIC
/* in ASCII order, not that it matters */
static const char controllablechars[] = "?@@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_";
d3825 4
a3828 33
int
Perl_ebcdic_control(pTHX_ int ch)
{
    	if (ch > 'a') {
	        char *ctlp;
 
 	       if (islower(ch))
  	              ch = toupper(ch);
 
 	       if ((ctlp = strchr(controllablechars, ch)) == 0) {
  	              Perl_die(aTHX_ "unrecognised control character '%c'\n", ch);
     	       }
 
        	if (ctlp == controllablechars)
         	       return('\177'); /* DEL */
        	else
         	       return((unsigned char)(ctlp - controllablechars - 1));
	} else { /* Want uncontrol */
        	if (ch == '\177' || ch == -1)
                	return('?');
        	else if (ch == '\157')
                	return('\177');
        	else if (ch == '\174')
                	return('\000');
        	else if (ch == '^')    /* '\137' in 1047, '\260' in 819 */
                	return('\036');
        	else if (ch == '\155')
                	return('\037');
        	else if (0 < ch && ch < (sizeof(controllablechars) - 1))
                	return(controllablechars[ch+1]);
        	else
                	Perl_die(aTHX_ "invalid control request: '\\%03o'\n", ch & 0xFF);
	}
a3829 1
#endif
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2002, Larry Wall
a18 1
#ifndef PERL_MICRO
d26 10
d42 2
a43 4
#ifdef HAS_SELECT
# ifdef I_SYS_SELECT
#  include <sys/select.h>
# endif
d61 2
a68 2
/* paranoid version of system's malloc() */

d85 1
a85 1
    ptr = (Malloc_t)PerlMem_malloc(size?size:1);	/* malloc(0) is NASTY on our system */
d111 1
a111 1
#ifdef HAS_64K_LIMIT
d129 1
a129 1
    ptr = (Malloc_t)PerlMem_realloc(where,size);
d131 1
a131 1

d182 1
a182 1
    ptr = (Malloc_t)PerlMem_malloc(size?size:1);	/* malloc(0) is NASTY on our system */
d241 1
a241 1

d246 1
a246 1

d261 1
a261 1

d293 1
a293 1

d302 1
a302 1
	    : (flag == 2
d305 1
a305 1
	    PerlIO_printf(Perl_debug_log,"%2d %02d %7ld ", i / 100, i % 100,
d309 1
a309 1
		if ( flag == 0
d311 1
a311 1
		     : (flag == 2
d314 3
a316 3
		    PerlIO_printf(Perl_debug_log,"%3ld ",
				  flag == 2
				  ? xycount[i][j] - lastxycount[i][j]
a340 31
/* These must be defined when not using Perl's malloc for binary
 * compatibility */

#ifndef MYMALLOC

Malloc_t Perl_malloc (MEM_SIZE nbytes)
{
    dTHXs;
    return (Malloc_t)PerlMem_malloc(nbytes);
}

Malloc_t Perl_calloc (MEM_SIZE elements, MEM_SIZE size)
{
    dTHXs;
    return (Malloc_t)PerlMem_calloc(elements, size);
}

Malloc_t Perl_realloc (Malloc_t where, MEM_SIZE nbytes)
{
    dTHXs;
    return (Malloc_t)PerlMem_realloc(where, nbytes);
}

Free_t   Perl_mfree (Malloc_t where)
{
    dTHXs;
    PerlMem_free(where);
}

#endif

d458 522
a988 2
=head1 Miscellaneous Functions

d1011 1
a1011 1
    if (len == 0)		/* TAIL might be on a zero-length string. */
d1034 1
a1034 1
    sv_magic(sv, Nullsv, PERL_MAGIC_bm, Nullch, 0);	/* deep magic */
d1045 1
a1045 1
    BmPREVIOUS(sv) = (U16)rarest;
d1077 5
a1081 6
    if ((STRLEN)(bigend - big) < littlelen) {
	if ( SvTAIL(littlestr)
	     && ((STRLEN)(bigend - big) == littlelen - 1)
	     && (littlelen == 1
		 || (*big == *little &&
		     memEQ((char *)big, (char *)little, littlelen - 1))))
d1171 1
a1171 1
	if (s >= big && bigend[-1] == '\n' && *s == *little
d1200 1
a1200 1

d1205 1
a1205 1
	if (littlelen > (STRLEN)(bigend - big))
d1218 7
d1227 1
d1249 1
a1249 2
	     && memEQ((char *)(bigend - littlelen),
		      (char *)(oldlittle - littlelen), littlelen) )
d1257 1
a1257 1
   If `last' we want the last occurrence.
d1259 1
a1259 1
   the next call needs to find the .
d1267 1
a1267 1
   if PL_multiline.  In fact if !PL_multiline the authoritative answer
d1287 1
a1287 1
	if ( BmRARE(littlestr) == '\n'
a1305 5
/*
  stop_pos does not include SvTAIL in the count, so this check is incorrect
  (I think) - see [ID 20010618.006] and t/op/study.t. HVDS 2001/06/19
*/
#if 0
a1307 1
#endif
d1314 19
d1350 1
a1350 1
    if (last && found)
d1352 1
d1363 1
a1363 2
	&& ((stop_pos == 1) ||
	    memEQ((char *)(big + 1), (char *)little, stop_pos - 1)))
a1396 2
=head1 Memory Management

d1399 1
a1399 4
Perl's version of C<strdup()>. Returns a pointer to a newly allocated
string which is a duplicate of C<pv>. The size of the string is
determined by C<strlen()>. The memory allocated for the new string can
be freed with the C<Safefree()> function.
d1405 1
a1405 1
Perl_savepv(pTHX_ const char *pv)
d1407 4
a1410 5
    register char *newaddr = Nullch;
    if (pv) {
	New(902,newaddr,strlen(pv)+1,char);
	(void)strcpy(newaddr,pv);
    }
d1419 2
a1420 4
Perl's version of what C<strndup()> would be if it existed. Returns a
pointer to a newly allocated string which is a duplicate of the first
C<len> bytes from C<pv>. The memory allocated for the new string can be
freed with the C<Safefree()> function.
d1426 1
a1426 1
Perl_savepvn(pTHX_ const char *pv, register I32 len)
d1431 2
a1432 27
    /* Give a meaning to NULL pointer mainly for the use in sv_magic() */
    if (pv) {
    	Copy(pv,newaddr,len,char);	/* might not be null terminated */
    	newaddr[len] = '\0';		/* is now */
    }
    else {
	Zero(newaddr,len+1,char);
    }
    return newaddr;
}

/*
=for apidoc savesharedpv

A version of C<savepv()> which allocates the duplicate string in memory
which is shared between threads.

=cut
*/
char *
Perl_savesharedpv(pTHX_ const char *pv)
{
    register char *newaddr = Nullch;
    if (pv) {
	newaddr = (char*)PerlMemShared_malloc(strlen(pv)+1);
    	(void)strcpy(newaddr,pv);
    }
a1435 2


a1473 20
/*
=head1 Miscellaneous Functions
=for apidoc form

Takes a sprintf-style format pattern and conventional
(non-SV) arguments and returns the formatted string.

    (char *) Perl_form(pTHX_ const char* pat, ...)

can be used any place a string (char *) is required:

    char * s = Perl_form("%d.%d",major,minor);

Uses a single private buffer so if you want to format several strings you
must explicitly copy the earlier strings away (and free the copies when you
are done).

=cut
*/

a1517 31
STATIC COP*
S_closest_cop(pTHX_ COP *cop, OP *o)
{
    /* Look for PL_op starting from o.  cop is the last COP we've seen. */

    if (!o || o == PL_op) return cop;

    if (o->op_flags & OPf_KIDS) {
	OP *kid;
	for (kid = cUNOPo->op_first; kid; kid = kid->op_sibling)
	{
	    COP *new_cop;

	    /* If the OP_NEXTSTATE has been optimised away we can still use it
	     * the get the file and line number. */

	    if (kid->op_type == OP_NULL && kid->op_targ == OP_NEXTSTATE)
		cop = (COP *)kid;

	    /* Keep searching, and return when we've found something. */

	    new_cop = closest_cop(cop, kid);
	    if (new_cop) return new_cop;
	}
    }

    /* Nothing found. */

    return 0;
}

a1522 1
    COP *cop;
d1526 1
a1526 12

	/*
	 * Try and find the file and line for PL_op.  This will usually be
	 * PL_curcop, but it might be a cop that has been optimised away.  We
	 * can try to find such a cop by searching through the optree starting
	 * from the sibling of PL_curcop.
	 */

	cop = closest_cop(PL_curcop, PL_curcop->op_sibling);
	if (!cop) cop = PL_curcop;

	if (CopLINE(cop))
d1528 1
a1528 1
           OutCopFILE(cop), (IV)CopLINE(cop));
d1533 3
a1535 4
			   PL_last_in_gv == PL_argvgv ?
			   "" : GvNAME(PL_last_in_gv),
			   line_mode ? "line" : "chunk",
			   (IV)IoLINES(GvIOp(PL_last_in_gv)));
d1537 1
a1537 1
#ifdef USE_5005THREADS
a1709 3
    else if (!message)
	message = SvPVx(ERRSV, msglen);

d1717 1
a1717 1
	PERL_WRITE_MSG_TO_CONSOLE(serr, message, msglen);
a1739 2
=head1 Warning and Dieing

a1774 2
    IO *io;
    MAGIC *mg;
a1806 14

    /* if STDERR is tied, use it instead */
    if (PL_stderrgv && (io = GvIOp(PL_stderrgv))
	&& (mg = SvTIED_mg((SV*)io, PERL_MAGIC_tiedscalar))) {
	dSP; ENTER;
	PUSHMARK(SP);
	XPUSHs(SvTIED_obj((SV*)io, mg));
	XPUSHs(sv_2mortal(newSVpvn(message, msglen)));
	PUTBACK;
	call_method("PRINT", G_SCALAR);
	LEAVE;
	return;
    }

d1810 1
a1810 1
	PERL_WRITE_MSG_TO_CONSOLE(serr, message, msglen);
d1812 1
a1812 1
	DEBUG_L(*message == '!'
d1889 1
a1889 1
#ifdef USE_5005THREADS
d1891 1
a1891 1
#endif /* USE_5005THREADS */
d1903 1
a1903 1

d1909 1
a1909 1

d1925 1
a1925 1
	    PERL_WRITE_MSG_TO_CONSOLE(serr, message, msglen);
d1943 1
a1943 1

d1949 1
a1949 1

d1962 1
a1962 1
	    PERL_WRITE_MSG_TO_CONSOLE(serr, message, msglen);
d1964 1
a1964 1
	    DEBUG_L(*message == '!'
a1975 10
/* since we've already done strlen() for both nam and val
 * we can use that info to make things faster than
 * sprintf(s, "%s=%s", nam, val)
 */
#define my_setenv_format(s, nam, nlen, val, vlen) \
   Copy(nam, s, nlen, char); \
   *(s+nlen) = '='; \
   Copy(val, s+(nlen+1), vlen, char); \
   *(s+(nlen+1+vlen)) = '\0'

d1977 2
a1978 2
       /* VMS' my_setenv() is in vms.c */
#if !defined(WIN32) && !defined(NETWARE)
a1981 5
#ifdef USE_ITHREADS
  /* only parent thread can modify process environment */
  if (PL_curinterp == aTHX)
#endif
  {
a1984 1
    int nlen, vlen;
d1995 2
a1996 3
            int len = strlen(environ[j]);
            tmpenv[j] = (char*)safesysmalloc((len+1)*sizeof(char));
            Copy(environ[j], tmpenv[j], len+1, char);
d2015 1
a2015 2
    nlen = strlen(nam);
    vlen = strlen(val);
d2017 1
a2017 3
    environ[i] = (char*)safesysmalloc((nlen+vlen+2) * sizeof(char));
    /* all that work just for this */
    my_setenv_format(environ[i], nam, nlen, val, vlen);
d2020 1
a2020 1
#   if defined(__CYGWIN__) || defined( EPOC)
d2024 3
a2026 8
    int nlen = strlen(nam), vlen;
    if (!val) {
        val = "";
    }
    vlen = strlen(val);
    new_env = (char*)safesysmalloc((nlen + vlen + 2) * sizeof(char));
    /* all that work just for this */
    my_setenv_format(new_env, nam, nlen, val, vlen);
a2029 1
  }
d2032 1
a2032 1
#else /* WIN32 || NETWARE */
d2038 1
a2038 2
    int nlen = strlen(nam), vlen;

d2042 3
a2044 3
    vlen = strlen(val);
    New(904, envstr, nlen+vlen+2, char);
    my_setenv_format(envstr, nam, nlen, val, vlen);
d2049 1
a2049 1
#endif /* WIN32 || NETWARE */
d2083 1
a2083 1
#if (!defined(HAS_MEMCPY) && !defined(HAS_BCOPY)) || (!defined(HAS_MEMMOVE) && !defined(HAS_SAFE_MEMCPY) && !defined(HAS_SAFE_BCOPY))
a2306 132
PerlIO *
Perl_my_popen_list(pTHX_ char *mode, int n, SV **args)
{
#if (!defined(DOSISH) || defined(HAS_FORK) || defined(AMIGAOS)) && !defined(OS2) && !defined(VMS) && !defined(__OPEN_VM) && !defined(EPOC) && !defined(MACOS_TRADITIONAL) && !defined(NETWARE)
    int p[2];
    register I32 This, that;
    register Pid_t pid;
    SV *sv;
    I32 did_pipes = 0;
    int pp[2];

    PERL_FLUSHALL_FOR_CHILD;
    This = (*mode == 'w');
    that = !This;
    if (PL_tainting) {
	taint_env();
	taint_proper("Insecure %s%s", "EXEC");
    }
    if (PerlProc_pipe(p) < 0)
	return Nullfp;
    /* Try for another pipe pair for error return */
    if (PerlProc_pipe(pp) >= 0)
	did_pipes = 1;
    while ((pid = PerlProc_fork()) < 0) {
	if (errno != EAGAIN) {
	    PerlLIO_close(p[This]);
	    PerlLIO_close(p[that]);
	    if (did_pipes) {
		PerlLIO_close(pp[0]);
		PerlLIO_close(pp[1]);
	    }
	    return Nullfp;
	}
	sleep(5);
    }
    if (pid == 0) {
	/* Child */
#undef THIS
#undef THAT
#define THIS that
#define THAT This
	/* Close parent's end of error status pipe (if any) */
	if (did_pipes) {
	    PerlLIO_close(pp[0]);
#if defined(HAS_FCNTL) && defined(F_SETFD)
	    /* Close error pipe automatically if exec works */
	    fcntl(pp[1], F_SETFD, FD_CLOEXEC);
#endif
	}
	/* Now dup our end of _the_ pipe to right position */
	if (p[THIS] != (*mode == 'r')) {
	    PerlLIO_dup2(p[THIS], *mode == 'r');
	    PerlLIO_close(p[THIS]);
	    if (p[THAT] != (*mode == 'r'))	/* if dup2() didn't close it */
		PerlLIO_close(p[THAT]);	/* close parent's end of _the_ pipe */
	}
	else
	    PerlLIO_close(p[THAT]);	/* close parent's end of _the_ pipe */
#if !defined(HAS_FCNTL) || !defined(F_SETFD)
	/* No automatic close - do it by hand */
#  ifndef NOFILE
#  define NOFILE 20
#  endif
	{
	    int fd;

	    for (fd = PL_maxsysfd + 1; fd < NOFILE; fd++) {
	        if (fd != pp[1])
		    PerlLIO_close(fd);
	    }
	}
#endif
	do_aexec5(Nullsv, args-1, args-1+n, pp[1], did_pipes);
	PerlProc__exit(1);
#undef THIS
#undef THAT
    }
    /* Parent */
    do_execfree();	/* free any memory malloced by child on fork */
    if (did_pipes)
	PerlLIO_close(pp[1]);
    /* Keep the lower of the two fd numbers */
    if (p[that] < p[This]) {
	PerlLIO_dup2(p[This], p[that]);
	PerlLIO_close(p[This]);
	p[This] = p[that];
    }
    else
	PerlLIO_close(p[that]);		/* close child's end of pipe */

    LOCK_FDPID_MUTEX;
    sv = *av_fetch(PL_fdpid,p[This],TRUE);
    UNLOCK_FDPID_MUTEX;
    (void)SvUPGRADE(sv,SVt_IV);
    SvIVX(sv) = pid;
    PL_forkprocess = pid;
    /* If we managed to get status pipe check for exec fail */
    if (did_pipes && pid > 0) {
	int errkid;
	int n = 0, n1;

	while (n < sizeof(int)) {
	    n1 = PerlLIO_read(pp[0],
			      (void*)(((char*)&errkid)+n),
			      (sizeof(int)) - n);
	    if (n1 <= 0)
		break;
	    n += n1;
	}
	PerlLIO_close(pp[0]);
	did_pipes = 0;
	if (n) {			/* Error */
	    int pid2, status;
	    PerlLIO_close(p[This]);
	    if (n != sizeof(int))
		Perl_croak(aTHX_ "panic: kid popen errno read");
	    do {
		pid2 = wait4pid(pid, &status, 0);
	    } while (pid2 == -1 && errno == EINTR);
	    errno = errkid;		/* Propagate errno from kid */
	    return Nullfp;
	}
    }
    if (did_pipes)
	 PerlLIO_close(pp[0]);
    return PerlIO_fdopen(p[This], mode);
#else
    Perl_croak(aTHX_ "List form of piped open not implemented");
    return (PerlIO *) NULL;
#endif
}

d2325 1
a2325 1
#endif
d2336 1
a2336 1
    while ((pid = PerlProc_fork()) < 0) {
a2338 1
	    PerlLIO_close(p[that]);
d2356 1
a2365 2
	    if (p[THAT] != (*mode == 'r'))	/* if dup2() didn't close it */
		PerlLIO_close(p[THAT]);
a2366 2
	else
	    PerlLIO_close(p[THAT]);
d2375 3
a2377 7
	    {
	        int fd;

		for (fd = PL_maxsysfd + 1; fd < NOFILE; fd++)
		    if (fd != pp[1])
		        PerlLIO_close(fd);
	    }
d2379 1
a2379 2
	    /* may or may not use the shell */
	    do_exec3(cmd, pp[1], did_pipes);
d2384 1
a2384 2
	if ((tmpgv = gv_fetchpv("$",TRUE, SVt_PV))) {
        SvREADONLY_off(GvSV(tmpgv));
a2385 2
        SvREADONLY_on(GvSV(tmpgv));
    }
d2393 1
a2400 3
    else
	PerlLIO_close(p[that]);

a2421 2
	    int pid2, status;
	    PerlLIO_close(p[This]);
a2423 3
	    do {
		pid2 = wait4pid(pid, &status, 0);
	    } while (pid2 == -1 && errno == EINTR);
d2433 1
a2433 1
#if defined(atarist) || defined(EPOC)
d2438 2
d2441 1
a2441 5
    /* Call system's popen() to get a FILE *, then import it.
       used 0 for 2nd parameter to PerlIO_importFILE;
       apparently not used
    */
    return PerlIO_importFILE(popen(cmd, mode), 0);
a2442 14
#else
#if defined(DJGPP)
FILE *djgpp_popen();
PerlIO *
Perl_my_popen(pTHX_ char *cmd, char *mode)
{
    PERL_FLUSHALL_FOR_CHILD;
    /* Call system's popen() to get a FILE *, then import it.
       used 0 for 2nd parameter to PerlIO_importFILE;
       apparently not used
    */
    return PerlIO_importFILE(djgpp_popen(cmd, mode), 0);
}
#endif
a2446 48
/* this is called in parent before the fork() */
void
Perl_atfork_lock(void)
{
#if defined(USE_5005THREADS) || defined(USE_ITHREADS)
    /* locks must be held in locking order (if any) */
#  ifdef MYMALLOC
    MUTEX_LOCK(&PL_malloc_mutex);
#  endif
    OP_REFCNT_LOCK;
#endif
}

/* this is called in both parent and child after the fork() */
void
Perl_atfork_unlock(void)
{
#if defined(USE_5005THREADS) || defined(USE_ITHREADS)
    /* locks must be released in same order as in atfork_lock() */
#  ifdef MYMALLOC
    MUTEX_UNLOCK(&PL_malloc_mutex);
#  endif
    OP_REFCNT_UNLOCK;
#endif
}

Pid_t
Perl_my_fork(void)
{
#if defined(HAS_FORK)
    Pid_t pid;
#if (defined(USE_5005THREADS) || defined(USE_ITHREADS)) && !defined(HAS_PTHREAD_ATFORK)
    atfork_lock();
    pid = fork();
    atfork_unlock();
#else
    /* atfork_lock() and atfork_unlock() are installed as pthread_atfork()
     * handlers elsewhere in the code */
    pid = fork();
#endif
    return pid;
#else
    /* this "canna happen" since nothing should be calling here if !HAS_FORK */
    Perl_croak_nocontext("fork() not available");
    return 0;
#endif /* HAS_FORK */
}

d2452 1
a2452 1
    Stat_t tmpstatbuf;
d2497 1
a2497 1
#ifndef PERL_MICRO
a2504 6
#ifdef USE_ITHREADS
    /* only "parent" interpreter can diddle signals */
    if (PL_curinterp != aTHX)
	return SIG_ERR;
#endif

a2508 1
#if defined(PERL_OLD_SIGNALS)
a2510 1
#endif
a2536 6
#ifdef USE_ITHREADS
    /* only "parent" interpreter can diddle signals */
    if (PL_curinterp != aTHX)
	return -1;
#endif

a2540 1
#if defined(PERL_OLD_SIGNALS)
a2542 1
#endif
a2552 6
#ifdef USE_ITHREADS
    /* only "parent" interpreter can diddle signals */
    if (PL_curinterp != aTHX)
	return -1;
#endif

a2560 6
#if defined(USE_ITHREADS) && !defined(WIN32)
    /* only "parent" interpreter can diddle signals */
    if (PL_curinterp != aTHX)
	return SIG_ERR;
#endif

d2564 1
a2564 2
static int sig_trapped;	/* XXX signals are process-wide anyway, so we
			   ignore the implications of this for threading */
a2577 6
#if defined(USE_ITHREADS) && !defined(WIN32)
    /* only "parent" interpreter can diddle signals */
    if (PL_curinterp != aTHX)
	return SIG_ERR;
#endif

a2588 5
#if defined(USE_ITHREADS) && !defined(WIN32)
    /* only "parent" interpreter can diddle signals */
    if (PL_curinterp != aTHX)
	return -1;
#endif
a2595 5
#if defined(USE_ITHREADS) && !defined(WIN32)
    /* only "parent" interpreter can diddle signals */
    if (PL_curinterp != aTHX)
	return -1;
#endif
a2599 1
#endif /* !PERL_MICRO */
d2612 1
a2612 1
    int saved_errno = 0;
d2623 1
a2623 1
    pid = (SvTYPE(*svp) == SVt_IV) ? SvIVX(*svp) : -1;
d2630 1
a2630 1
#endif
a2642 1
#ifndef PERL_MICRO
a2645 1
#endif
a2648 1
#ifndef PERL_MICRO
a2651 1
#endif
d2660 1
a2660 1
#if  (!defined(DOSISH) || defined(OS2) || defined(WIN32) || defined(NETWARE)) && !defined(MACOS_TRADITIONAL)
a2663 5
    I32 result;
    if (!pid)
	return -1;
#if !defined(HAS_WAITPID) && !defined(HAS_WAIT4) || defined(HAS_WAITPID_RUNTIME)
    {
d2668 3
a2684 3
	    SV *sv;
	    char spid[TYPE_CHARS(int)];

a2691 1
        }
d2699 1
a2699 2
    result = PerlProc_waitpid(pid,statusp,flags);
    goto finish;
d2702 1
a2702 2
    result = wait4((pid==-1)?0:pid,statusp,flags,Null(struct rusage *));
    goto finish;
d2707 1
d2716 1
a2718 5
  finish:
    if (result < 0 && errno == EINTR) {
	PERL_ASYNC_CHECK();
    }
    return result;
d2720 1
a2720 1
#endif /* !DOSISH || OS2 || WIN32 || NETWARE */
d2736 1
a2736 1
#if defined(atarist) || defined(OS2) || defined(EPOC)
d2745 1
a2745 1
#endif
a2749 5
    PerlIO_releaseFILE(ptr,f);
    return result;
}
#endif

a2750 7
int djgpp_pclose();
I32
Perl_my_pclose(pTHX_ PerlIO *ptr)
{
    /* Needs work for PerlIO ! */
    FILE *f = PerlIO_findFILE(ptr);
    I32 result = djgpp_pclose(f);
d2752 1
d2778 79
d2863 2
a2864 2
    Stat_t tmpstatbuf1;
    Stat_t tmpstatbuf2;
d2894 207
a3100 2
char*
Perl_find_script(pTHX_ char *scriptname, bool dosearch, char **search_ext, I32 flags)
d3106 1
a3106 1
    I32 len = 0;
d3309 1
a3309 1
	    (PerlLIO_stat(scriptname,&PL_statbuf) < 0
d3335 1
a3335 1
#if defined(USE_5005THREADS) || defined(USE_ITHREADS)
d3342 1
a3342 1
#    ifdef I_MACH_CTHREADS
d3344 3
a3346 3
#    else
    return (void*)PTHREAD_GETSPECIFIC(PL_thr_key);
#    endif
d3356 1
a3356 1
#if defined(USE_5005THREADS) || defined(USE_ITHREADS)
d3368 1
a3368 1
#ifdef USE_5005THREADS
d3389 1
a3389 1

d3409 1
a3409 1

d3432 1
a3432 1

d3448 3
a3450 3

    (void)SvUPGRADE(sv, SVt_PVMG);
    mg = mg_find(sv, PERL_MAGIC_mutex);
d3460 1
a3460 1
	mg = mg_find(sv, PERL_MAGIC_mutex);
d3470 1
a3470 1
	    sv_magic(sv, Nullsv, PERL_MAGIC_mutex, 0, 0);
d3476 1
a3476 1
					   "%p: condpair_magic %p\n", thr, sv)));
d3503 1
a3503 1
			      PTR2UV(thr), PTR2UV(sv)));
d3533 1
a3533 1
    Poison(thr, 1, struct perl_thread);
a3556 1
    thr->thr_done = 0;
a3580 2
    PL_peepp = MEMBER_TO_FPTR(Perl_peep);

d3594 2
a3595 1
    PL_rs = newSVsv(t->Trs);
d3597 2
a3598 1
    PL_ofs_sv = t->Tofs_sv ? SvREFCNT_inc(PL_ofs_sv) : Nullsv;
d3614 1
a3614 1
	    sv_magic(sv, 0, PERL_MAGIC_sv, &PL_threadsv_names[i], 1);
d3619 1
a3619 1
    }
d3639 17
a3655 1
#endif /* USE_5005THREADS */
d3692 1
a3692 1
 return (PPADDR_t*)PL_ppaddr;
d3776 1
a3776 1
#ifdef USE_5005THREADS
d3811 10
a3827 1
    extern int fflush(FILE *);
d3830 1
a3830 1
    _fwalk(&fflush);
d3832 2
a3833 1
# else
a3834 1
    long open_max = -1;
d3838 1
a3838 1
#    if defined(HAS_SYSCONF) && defined(_SC_OPEN_MAX)
d3840 2
a3841 2
#     else
#      ifdef FOPEN_MAX
d3843 2
a3844 2
#      else
#       ifdef OPEN_MAX
d3846 2
a3847 2
#       else
#        ifdef _NFILE
a3848 2
#        endif
#       endif
d3852 2
d3870 23
d3903 1
a3903 2
    char *type = OP_IS_SOCKET(op) ||
                 (gv && io && IoTYPE(io) == IoTYPE_SOCKET) ?
d3907 1
a3907 1
    if (gv && io && IoTYPE(io) == IoTYPE_CLOSED) {
d3917 3
a3919 1
	name = GvENAME(gv);
d3922 2
a3923 10
    if (op == OP_phoney_OUTPUT_ONLY || op == OP_phoney_INPUT_ONLY) {
	if (name && *name)
	    Perl_warner(aTHX_ packWARN(WARN_IO), "Filehandle %s opened only for %sput",
			name,
			(op == OP_phoney_INPUT_ONLY ? "in" : "out"));
	else
	    Perl_warner(aTHX_ packWARN(WARN_IO), "Filehandle opened only for %sput",
			(op == OP_phoney_INPUT_ONLY ? "in" : "out"));
    } else if (name && *name) {
	Perl_warner(aTHX_ packWARN(warn_type),
d3926 1
a3926 1
	    Perl_warner(aTHX_ packWARN(warn_type),
d3931 1
a3931 1
	Perl_warner(aTHX_ packWARN(warn_type),
d3933 2
a3934 2
	if (gv && io && IoDIRP(io) && !(IoFLAGS(io) & IOf_FAKE_DIRP))
	    Perl_warner(aTHX_ packWARN(warn_type),
d3949 1
a3949 1

d3952 1
a3952 1

d3956 1
a3956 1

a3978 846

/* To workaround core dumps from the uninitialised tm_zone we get the
 * system to give us a reasonable struct to copy.  This fix means that
 * strftime uses the tm_zone and tm_gmtoff values returned by
 * localtime(time()). That should give the desired result most of the
 * time. But probably not always!
 *
 * This does not address tzname aspects of NETaa14816.
 *
 */

#ifdef HAS_GNULIBC
# ifndef STRUCT_TM_HASZONE
#    define STRUCT_TM_HASZONE
# endif
#endif

#ifdef STRUCT_TM_HASZONE /* Backward compat */
# ifndef HAS_TM_TM_ZONE
#    define HAS_TM_TM_ZONE
# endif
#endif

void
Perl_init_tm(pTHX_ struct tm *ptm)	/* see mktime, strftime and asctime */
{
#ifdef HAS_TM_TM_ZONE
    Time_t now;
    (void)time(&now);
    Copy(localtime(&now), ptm, 1, struct tm);
#endif
}

/*
 * mini_mktime - normalise struct tm values without the localtime()
 * semantics (and overhead) of mktime().
 */
void
Perl_mini_mktime(pTHX_ struct tm *ptm)
{
    int yearday;
    int secs;
    int month, mday, year, jday;
    int odd_cent, odd_year;

#define	DAYS_PER_YEAR	365
#define	DAYS_PER_QYEAR	(4*DAYS_PER_YEAR+1)
#define	DAYS_PER_CENT	(25*DAYS_PER_QYEAR-1)
#define	DAYS_PER_QCENT	(4*DAYS_PER_CENT+1)
#define	SECS_PER_HOUR	(60*60)
#define	SECS_PER_DAY	(24*SECS_PER_HOUR)
/* parentheses deliberately absent on these two, otherwise they don't work */
#define	MONTH_TO_DAYS	153/5
#define	DAYS_TO_MONTH	5/153
/* offset to bias by March (month 4) 1st between month/mday & year finding */
#define	YEAR_ADJUST	(4*MONTH_TO_DAYS+1)
/* as used here, the algorithm leaves Sunday as day 1 unless we adjust it */
#define	WEEKDAY_BIAS	6	/* (1+6)%7 makes Sunday 0 again */

/*
 * Year/day algorithm notes:
 *
 * With a suitable offset for numeric value of the month, one can find
 * an offset into the year by considering months to have 30.6 (153/5) days,
 * using integer arithmetic (i.e., with truncation).  To avoid too much
 * messing about with leap days, we consider January and February to be
 * the 13th and 14th month of the previous year.  After that transformation,
 * we need the month index we use to be high by 1 from 'normal human' usage,
 * so the month index values we use run from 4 through 15.
 *
 * Given that, and the rules for the Gregorian calendar (leap years are those
 * divisible by 4 unless also divisible by 100, when they must be divisible
 * by 400 instead), we can simply calculate the number of days since some
 * arbitrary 'beginning of time' by futzing with the (adjusted) year number,
 * the days we derive from our month index, and adding in the day of the
 * month.  The value used here is not adjusted for the actual origin which
 * it normally would use (1 January A.D. 1), since we're not exposing it.
 * We're only building the value so we can turn around and get the
 * normalised values for the year, month, day-of-month, and day-of-year.
 *
 * For going backward, we need to bias the value we're using so that we find
 * the right year value.  (Basically, we don't want the contribution of
 * March 1st to the number to apply while deriving the year).  Having done
 * that, we 'count up' the contribution to the year number by accounting for
 * full quadracenturies (400-year periods) with their extra leap days, plus
 * the contribution from full centuries (to avoid counting in the lost leap
 * days), plus the contribution from full quad-years (to count in the normal
 * leap days), plus the leftover contribution from any non-leap years.
 * At this point, if we were working with an actual leap day, we'll have 0
 * days left over.  This is also true for March 1st, however.  So, we have
 * to special-case that result, and (earlier) keep track of the 'odd'
 * century and year contributions.  If we got 4 extra centuries in a qcent,
 * or 4 extra years in a qyear, then it's a leap day and we call it 29 Feb.
 * Otherwise, we add back in the earlier bias we removed (the 123 from
 * figuring in March 1st), find the month index (integer division by 30.6),
 * and the remainder is the day-of-month.  We then have to convert back to
 * 'real' months (including fixing January and February from being 14/15 in
 * the previous year to being in the proper year).  After that, to get
 * tm_yday, we work with the normalised year and get a new yearday value for
 * January 1st, which we subtract from the yearday value we had earlier,
 * representing the date we've re-built.  This is done from January 1
 * because tm_yday is 0-origin.
 *
 * Since POSIX time routines are only guaranteed to work for times since the
 * UNIX epoch (00:00:00 1 Jan 1970 UTC), the fact that this algorithm
 * applies Gregorian calendar rules even to dates before the 16th century
 * doesn't bother me.  Besides, you'd need cultural context for a given
 * date to know whether it was Julian or Gregorian calendar, and that's
 * outside the scope for this routine.  Since we convert back based on the
 * same rules we used to build the yearday, you'll only get strange results
 * for input which needed normalising, or for the 'odd' century years which
 * were leap years in the Julian calander but not in the Gregorian one.
 * I can live with that.
 *
 * This algorithm also fails to handle years before A.D. 1 gracefully, but
 * that's still outside the scope for POSIX time manipulation, so I don't
 * care.
 */

    year = 1900 + ptm->tm_year;
    month = ptm->tm_mon;
    mday = ptm->tm_mday;
    /* allow given yday with no month & mday to dominate the result */
    if (ptm->tm_yday >= 0 && mday <= 0 && month <= 0) {
	month = 0;
	mday = 0;
	jday = 1 + ptm->tm_yday;
    }
    else {
	jday = 0;
    }
    if (month >= 2)
	month+=2;
    else
	month+=14, year--;
    yearday = DAYS_PER_YEAR * year + year/4 - year/100 + year/400;
    yearday += month*MONTH_TO_DAYS + mday + jday;
    /*
     * Note that we don't know when leap-seconds were or will be,
     * so we have to trust the user if we get something which looks
     * like a sensible leap-second.  Wild values for seconds will
     * be rationalised, however.
     */
    if ((unsigned) ptm->tm_sec <= 60) {
	secs = 0;
    }
    else {
	secs = ptm->tm_sec;
	ptm->tm_sec = 0;
    }
    secs += 60 * ptm->tm_min;
    secs += SECS_PER_HOUR * ptm->tm_hour;
    if (secs < 0) {
	if (secs-(secs/SECS_PER_DAY*SECS_PER_DAY) < 0) {
	    /* got negative remainder, but need positive time */
	    /* back off an extra day to compensate */
	    yearday += (secs/SECS_PER_DAY)-1;
	    secs -= SECS_PER_DAY * (secs/SECS_PER_DAY - 1);
	}
	else {
	    yearday += (secs/SECS_PER_DAY);
	    secs -= SECS_PER_DAY * (secs/SECS_PER_DAY);
	}
    }
    else if (secs >= SECS_PER_DAY) {
	yearday += (secs/SECS_PER_DAY);
	secs %= SECS_PER_DAY;
    }
    ptm->tm_hour = secs/SECS_PER_HOUR;
    secs %= SECS_PER_HOUR;
    ptm->tm_min = secs/60;
    secs %= 60;
    ptm->tm_sec += secs;
    /* done with time of day effects */
    /*
     * The algorithm for yearday has (so far) left it high by 428.
     * To avoid mistaking a legitimate Feb 29 as Mar 1, we need to
     * bias it by 123 while trying to figure out what year it
     * really represents.  Even with this tweak, the reverse
     * translation fails for years before A.D. 0001.
     * It would still fail for Feb 29, but we catch that one below.
     */
    jday = yearday;	/* save for later fixup vis-a-vis Jan 1 */
    yearday -= YEAR_ADJUST;
    year = (yearday / DAYS_PER_QCENT) * 400;
    yearday %= DAYS_PER_QCENT;
    odd_cent = yearday / DAYS_PER_CENT;
    year += odd_cent * 100;
    yearday %= DAYS_PER_CENT;
    year += (yearday / DAYS_PER_QYEAR) * 4;
    yearday %= DAYS_PER_QYEAR;
    odd_year = yearday / DAYS_PER_YEAR;
    year += odd_year;
    yearday %= DAYS_PER_YEAR;
    if (!yearday && (odd_cent==4 || odd_year==4)) { /* catch Feb 29 */
	month = 1;
	yearday = 29;
    }
    else {
	yearday += YEAR_ADJUST;	/* recover March 1st crock */
	month = yearday*DAYS_TO_MONTH;
	yearday -= month*MONTH_TO_DAYS;
	/* recover other leap-year adjustment */
	if (month > 13) {
	    month-=14;
	    year++;
	}
	else {
	    month-=2;
	}
    }
    ptm->tm_year = year - 1900;
    if (yearday) {
      ptm->tm_mday = yearday;
      ptm->tm_mon = month;
    }
    else {
      ptm->tm_mday = 31;
      ptm->tm_mon = month - 1;
    }
    /* re-build yearday based on Jan 1 to get tm_yday */
    year--;
    yearday = year*DAYS_PER_YEAR + year/4 - year/100 + year/400;
    yearday += 14*MONTH_TO_DAYS + 1;
    ptm->tm_yday = jday - yearday;
    /* fix tm_wday if not overridden by caller */
    if ((unsigned)ptm->tm_wday > 6)
	ptm->tm_wday = (jday + WEEKDAY_BIAS) % 7;
}

char *
Perl_my_strftime(pTHX_ char *fmt, int sec, int min, int hour, int mday, int mon, int year, int wday, int yday, int isdst)
{
#ifdef HAS_STRFTIME
  char *buf;
  int buflen;
  struct tm mytm;
  int len;

  init_tm(&mytm);	/* XXX workaround - see init_tm() above */
  mytm.tm_sec = sec;
  mytm.tm_min = min;
  mytm.tm_hour = hour;
  mytm.tm_mday = mday;
  mytm.tm_mon = mon;
  mytm.tm_year = year;
  mytm.tm_wday = wday;
  mytm.tm_yday = yday;
  mytm.tm_isdst = isdst;
  mini_mktime(&mytm);
  buflen = 64;
  New(0, buf, buflen, char);
  len = strftime(buf, buflen, fmt, &mytm);
  /*
  ** The following is needed to handle to the situation where
  ** tmpbuf overflows.  Basically we want to allocate a buffer
  ** and try repeatedly.  The reason why it is so complicated
  ** is that getting a return value of 0 from strftime can indicate
  ** one of the following:
  ** 1. buffer overflowed,
  ** 2. illegal conversion specifier, or
  ** 3. the format string specifies nothing to be returned(not
  **	  an error).  This could be because format is an empty string
  **    or it specifies %p that yields an empty string in some locale.
  ** If there is a better way to make it portable, go ahead by
  ** all means.
  */
  if ((len > 0 && len < buflen) || (len == 0 && *fmt == '\0'))
    return buf;
  else {
    /* Possibly buf overflowed - try again with a bigger buf */
    int     fmtlen = strlen(fmt);
    int	    bufsize = fmtlen + buflen;

    New(0, buf, bufsize, char);
    while (buf) {
      buflen = strftime(buf, bufsize, fmt, &mytm);
      if (buflen > 0 && buflen < bufsize)
	break;
      /* heuristic to prevent out-of-memory errors */
      if (bufsize > 100*fmtlen) {
	Safefree(buf);
	buf = NULL;
	break;
      }
      bufsize *= 2;
      Renew(buf, bufsize, char);
    }
    return buf;
  }
#else
  Perl_croak(aTHX_ "panic: no strftime");
#endif
}


#define SV_CWD_RETURN_UNDEF \
sv_setsv(sv, &PL_sv_undef); \
return FALSE

#define SV_CWD_ISDOT(dp) \
    (dp->d_name[0] == '.' && (dp->d_name[1] == '\0' || \
        (dp->d_name[1] == '.' && dp->d_name[2] == '\0')))

/*
=head1 Miscellaneous Functions

=for apidoc getcwd_sv

Fill the sv with current working directory

=cut
*/

/* Originally written in Perl by John Bazik; rewritten in C by Ben Sugars.
 * rewritten again by dougm, optimized for use with xs TARG, and to prefer
 * getcwd(3) if available
 * Comments from the orignal:
 *     This is a faster version of getcwd.  It's also more dangerous
 *     because you might chdir out of a directory that you can't chdir
 *     back into. */

int
Perl_getcwd_sv(pTHX_ register SV *sv)
{
#ifndef PERL_MICRO

#ifndef INCOMPLETE_TAINTS
    SvTAINTED_on(sv);
#endif

#ifdef HAS_GETCWD
    {
	char buf[MAXPATHLEN];

        /* Some getcwd()s automatically allocate a buffer of the given
	 * size from the heap if they are given a NULL buffer pointer.
	 * The problem is that this behaviour is not portable. */
        if (getcwd(buf, sizeof(buf) - 1)) {
            STRLEN len = strlen(buf);
            sv_setpvn(sv, buf, len);
            return TRUE;
        }
        else {
            sv_setsv(sv, &PL_sv_undef);
            return FALSE;
        }
    }

#else

    Stat_t statbuf;
    int orig_cdev, orig_cino, cdev, cino, odev, oino, tdev, tino;
    int namelen, pathlen=0;
    DIR *dir;
    Direntry_t *dp;

    (void)SvUPGRADE(sv, SVt_PV);

    if (PerlLIO_lstat(".", &statbuf) < 0) {
        SV_CWD_RETURN_UNDEF;
    }

    orig_cdev = statbuf.st_dev;
    orig_cino = statbuf.st_ino;
    cdev = orig_cdev;
    cino = orig_cino;

    for (;;) {
        odev = cdev;
        oino = cino;

        if (PerlDir_chdir("..") < 0) {
            SV_CWD_RETURN_UNDEF;
        }
        if (PerlLIO_stat(".", &statbuf) < 0) {
            SV_CWD_RETURN_UNDEF;
        }

        cdev = statbuf.st_dev;
        cino = statbuf.st_ino;

        if (odev == cdev && oino == cino) {
            break;
        }
        if (!(dir = PerlDir_open("."))) {
            SV_CWD_RETURN_UNDEF;
        }

        while ((dp = PerlDir_read(dir)) != NULL) {
#ifdef DIRNAMLEN
            namelen = dp->d_namlen;
#else
            namelen = strlen(dp->d_name);
#endif
            /* skip . and .. */
            if (SV_CWD_ISDOT(dp)) {
                continue;
            }

            if (PerlLIO_lstat(dp->d_name, &statbuf) < 0) {
                SV_CWD_RETURN_UNDEF;
            }

            tdev = statbuf.st_dev;
            tino = statbuf.st_ino;
            if (tino == oino && tdev == odev) {
                break;
            }
        }

        if (!dp) {
            SV_CWD_RETURN_UNDEF;
        }

        if (pathlen + namelen + 1 >= MAXPATHLEN) {
            SV_CWD_RETURN_UNDEF;
	}

        SvGROW(sv, pathlen + namelen + 1);

        if (pathlen) {
            /* shift down */
            Move(SvPVX(sv), SvPVX(sv) + namelen + 1, pathlen, char);
        }

        /* prepend current directory to the front */
        *SvPVX(sv) = '/';
        Move(dp->d_name, SvPVX(sv)+1, namelen, char);
        pathlen += (namelen + 1);

#ifdef VOID_CLOSEDIR
        PerlDir_close(dir);
#else
        if (PerlDir_close(dir) < 0) {
            SV_CWD_RETURN_UNDEF;
        }
#endif
    }

    if (pathlen) {
        SvCUR_set(sv, pathlen);
        *SvEND(sv) = '\0';
        SvPOK_only(sv);

	if (PerlDir_chdir(SvPVX(sv)) < 0) {
            SV_CWD_RETURN_UNDEF;
        }
    }
    if (PerlLIO_stat(".", &statbuf) < 0) {
        SV_CWD_RETURN_UNDEF;
    }

    cdev = statbuf.st_dev;
    cino = statbuf.st_ino;

    if (cdev != orig_cdev || cino != orig_cino) {
        Perl_croak(aTHX_ "Unstable directory path, "
                   "current directory changed unexpectedly");
    }

    return TRUE;
#endif

#else
    return FALSE;
#endif
}

/*
=head1 SV Manipulation Functions

=for apidoc new_vstring

Returns a pointer to the next character after the parsed
vstring, as well as updating the passed in sv.

Function must be called like

        sv = NEWSV(92,5);
	s = new_vstring(s,sv);

The sv must already be large enough to store the vstring
passed in.

=cut
*/

char *
Perl_new_vstring(pTHX_ char *s, SV *sv)
{
    char *pos = s;
    if (*pos == 'v') pos++;  /* get past 'v' */
    while (isDIGIT(*pos) || *pos == '_')
    pos++;
    if (!isALPHA(*pos)) {
	UV rev;
	U8 tmpbuf[UTF8_MAXLEN+1];
	U8 *tmpend;

	if (*s == 'v') s++;  /* get past 'v' */

	sv_setpvn(sv, "", 0);

	for (;;) {
	    rev = 0;
	    {
		 /* this is atoi() that tolerates underscores */
		 char *end = pos;
		 UV mult = 1;
		 if ( s > pos && *(s-1) == '_') {
		      mult = 10;
		 }
		 while (--end >= s) {
		      UV orev;
		      orev = rev;
		      rev += (*end - '0') * mult;
		      mult *= 10;
		      if (orev > rev && ckWARN_d(WARN_OVERFLOW))
			   Perl_warner(aTHX_ packWARN(WARN_OVERFLOW),
				       "Integer overflow in decimal number");
		 }
	    }
#ifdef EBCDIC
	    if (rev > 0x7FFFFFFF)
		 Perl_croak(aTHX "In EBCDIC the v-string components cannot exceed 2147483647");
#endif
	    /* Append native character for the rev point */
	    tmpend = uvchr_to_utf8(tmpbuf, rev);
	    sv_catpvn(sv, (const char*)tmpbuf, tmpend - tmpbuf);
	    if (!UNI_IS_INVARIANT(NATIVE_TO_UNI(rev)))
		 SvUTF8_on(sv);
	    if ( (*pos == '.' || *pos == '_') && isDIGIT(pos[1]))
		 s = ++pos;
	    else {
		 s = pos;
		 break;
	    }
	    while (isDIGIT(*pos) )
		 pos++;
	}
	SvPOK_on(sv);
	SvREADONLY_on(sv);
    }
    return s;
}

#if !defined(HAS_SOCKETPAIR) && defined(HAS_SOCKET) && defined(AF_INET) && defined(PF_INET) && defined(SOCK_DGRAM) && defined(HAS_SELECT)
#   define EMULATE_SOCKETPAIR_UDP
#endif

#ifdef EMULATE_SOCKETPAIR_UDP
static int
S_socketpair_udp (int fd[2]) {
    dTHX;
    /* Fake a datagram socketpair using UDP to localhost.  */
    int sockets[2] = {-1, -1};
    struct sockaddr_in addresses[2];
    int i;
    Sock_size_t size = sizeof (struct sockaddr_in);
    unsigned short port;
    int got;

    memset (&addresses, 0, sizeof (addresses));
    i = 1;
    do {
        sockets[i] = PerlSock_socket (AF_INET, SOCK_DGRAM, PF_INET);
        if (sockets[i] == -1)
            goto tidy_up_and_fail;

        addresses[i].sin_family = AF_INET;
        addresses[i].sin_addr.s_addr = htonl (INADDR_LOOPBACK);
        addresses[i].sin_port = 0;	/* kernel choses port.  */
        if (PerlSock_bind (sockets[i], (struct sockaddr *) &addresses[i],
                  sizeof (struct sockaddr_in))
            == -1)
            goto tidy_up_and_fail;
    } while (i--);

    /* Now have 2 UDP sockets. Find out which port each is connected to, and
       for each connect the other socket to it.  */
    i = 1;
    do {
        if (PerlSock_getsockname (sockets[i], (struct sockaddr *) &addresses[i], &size)
            == -1)
            goto tidy_up_and_fail;
        if (size != sizeof (struct sockaddr_in))
            goto abort_tidy_up_and_fail;
        /* !1 is 0, !0 is 1 */
        if (PerlSock_connect(sockets[!i], (struct sockaddr *) &addresses[i],
                    sizeof (struct sockaddr_in)) == -1)
            goto tidy_up_and_fail;
    } while (i--);

    /* Now we have 2 sockets connected to each other. I don't trust some other
       process not to have already sent a packet to us (by random) so send
       a packet from each to the other.  */
    i = 1;
    do {
        /* I'm going to send my own port number.  As a short.
           (Who knows if someone somewhere has sin_port as a bitfield and needs
           this routine. (I'm assuming crays have socketpair)) */
        port = addresses[i].sin_port;
        got = PerlLIO_write (sockets[i], &port, sizeof(port));
        if (got != sizeof(port)) {
            if (got == -1)
                goto tidy_up_and_fail;
            goto abort_tidy_up_and_fail;
        }
    } while (i--);

    /* Packets sent. I don't trust them to have arrived though.
       (As I understand it Solaris TCP stack is multithreaded. Non-blocking
       connect to localhost will use a second kernel thread. In 2.6 the
       first thread running the connect() returns before the second completes,
       so EINPROGRESS> In 2.7 the improved stack is faster and connect()
       returns 0. Poor programs have tripped up. One poor program's authors'
       had a 50-1 reverse stock split. Not sure how connected these were.)
       So I don't trust someone not to have an unpredictable UDP stack.
    */

    {
        struct timeval waitfor = {0, 100000}; /* You have 0.1 seconds */
        int max = sockets[1] > sockets[0] ? sockets[1] : sockets[0];
        fd_set rset;

        FD_ZERO (&rset);
        FD_SET (sockets[0], &rset);
        FD_SET (sockets[1], &rset);

        got = PerlSock_select (max + 1, &rset, NULL, NULL, &waitfor);
        if (got != 2 || !FD_ISSET (sockets[0], &rset)
            || !FD_ISSET (sockets[1], &rset)) {
             /* I hope this is portable and appropriate.  */
            if (got == -1)
                goto tidy_up_and_fail;
            goto abort_tidy_up_and_fail;
        }
    }

    /* And the paranoia department even now doesn't trust it to have arrive
       (hence MSG_DONTWAIT). Or that what arrives was sent by us.  */
    {
        struct sockaddr_in readfrom;
        unsigned short buffer[2];

        i = 1;
        do {
#ifdef MSG_DONTWAIT
            got = PerlSock_recvfrom (sockets[i], (char *) &buffer, sizeof(buffer),
                            MSG_DONTWAIT,
                            (struct sockaddr *) &readfrom, &size);
#else
            got = PerlSock_recvfrom (sockets[i], (char *) &buffer, sizeof(buffer),
                            0,
                            (struct sockaddr *) &readfrom, &size);
#endif

            if (got == -1)
                    goto tidy_up_and_fail;
            if (got != sizeof(port)
                || size != sizeof (struct sockaddr_in)
                /* Check other socket sent us its port.  */
                || buffer[0] != (unsigned short) addresses[!i].sin_port
                /* Check kernel says we got the datagram from that socket.  */
                || readfrom.sin_family != addresses[!i].sin_family
                || readfrom.sin_addr.s_addr != addresses[!i].sin_addr.s_addr
                || readfrom.sin_port != addresses[!i].sin_port)
                goto abort_tidy_up_and_fail;
        } while (i--);
    }
    /* My caller (my_socketpair) has validated that this is non-NULL  */
    fd[0] = sockets[0];
    fd[1] = sockets[1];
    /* I hereby declare this connection open.  May God bless all who cross
       her.  */
    return 0;

  abort_tidy_up_and_fail:
    errno = ECONNABORTED;
  tidy_up_and_fail:
    {
        int save_errno = errno;
        if (sockets[0] != -1)
            PerlLIO_close (sockets[0]);
        if (sockets[1] != -1)
            PerlLIO_close (sockets[1]);
        errno = save_errno;
        return -1;
    }
}
#endif /*  EMULATE_SOCKETPAIR_UDP */

#if !defined(HAS_SOCKETPAIR) && defined(HAS_SOCKET) && defined(AF_INET) && defined(PF_INET)
int
Perl_my_socketpair (int family, int type, int protocol, int fd[2]) {
    /* Stevens says that family must be AF_LOCAL, protocol 0.
       I'm going to enforce that, then ignore it, and use TCP (or UDP).  */
    dTHX;
    int listener = -1;
    int connector = -1;
    int acceptor = -1;
    struct sockaddr_in listen_addr;
    struct sockaddr_in connect_addr;
    Sock_size_t size;

    if (protocol
#ifdef AF_UNIX
	|| family != AF_UNIX
#endif
	) {
        errno = EAFNOSUPPORT;
        return -1;
    }
    if (!fd) {
        errno = EINVAL;
        return -1;
    }

#ifdef EMULATE_SOCKETPAIR_UDP
    if (type == SOCK_DGRAM)
        return S_socketpair_udp (fd);
#endif

    listener = PerlSock_socket (AF_INET, type, 0);
    if (listener == -1)
        return -1;
    memset (&listen_addr, 0, sizeof (listen_addr));
    listen_addr.sin_family = AF_INET;
    listen_addr.sin_addr.s_addr = htonl (INADDR_LOOPBACK);
    listen_addr.sin_port = 0;	/* kernel choses port.  */
    if (PerlSock_bind (listener, (struct sockaddr *) &listen_addr, sizeof (listen_addr))
        == -1)
        goto tidy_up_and_fail;
    if (PerlSock_listen(listener, 1) == -1)
        goto tidy_up_and_fail;

    connector = PerlSock_socket (AF_INET, type, 0);
    if (connector == -1)
        goto tidy_up_and_fail;
    /* We want to find out the port number to connect to.  */
    size = sizeof (connect_addr);
    if (PerlSock_getsockname (listener, (struct sockaddr *) &connect_addr, &size) == -1)
        goto tidy_up_and_fail;
    if (size != sizeof (connect_addr))
        goto abort_tidy_up_and_fail;
    if (PerlSock_connect(connector, (struct sockaddr *) &connect_addr,
                sizeof (connect_addr)) == -1)
        goto tidy_up_and_fail;

    size = sizeof (listen_addr);
    acceptor = PerlSock_accept (listener, (struct sockaddr *) &listen_addr, &size);
    if (acceptor == -1)
        goto tidy_up_and_fail;
    if (size != sizeof (listen_addr))
        goto abort_tidy_up_and_fail;
    PerlLIO_close (listener);
    /* Now check we are talking to ourself by matching port and host on the
       two sockets.  */
    if (PerlSock_getsockname (connector, (struct sockaddr *) &connect_addr, &size) == -1)
        goto tidy_up_and_fail;
    if (size != sizeof (connect_addr)
        || listen_addr.sin_family != connect_addr.sin_family
        || listen_addr.sin_addr.s_addr != connect_addr.sin_addr.s_addr
        || listen_addr.sin_port != connect_addr.sin_port) {
        goto abort_tidy_up_and_fail;
    }
    fd[0] = connector;
    fd[1] = acceptor;
    return 0;

  abort_tidy_up_and_fail:
  errno = ECONNABORTED; /* I hope this is portable and appropriate.  */
  tidy_up_and_fail:
    {
        int save_errno = errno;
        if (listener != -1)
            PerlLIO_close (listener);
        if (connector != -1)
            PerlLIO_close (connector);
        if (acceptor != -1)
            PerlLIO_close (acceptor);
        errno = save_errno;
        return -1;
    }
}
#else
/* In any case have a stub so that there's code corresponding
 * to the my_socketpair in global.sym. */
int
Perl_my_socketpair (int family, int type, int protocol, int fd[2]) {
#ifdef HAS_SOCKETPAIR
    return socketpair(family, type, protocol, fd);
#else
    return -1;
#endif
}
#endif

/*

=for apidoc sv_nosharing

Dummy routine which "shares" an SV when there is no sharing module present.
Exists to avoid test for a NULL function pointer and because it could potentially warn under
some level of strict-ness.

=cut
*/

void
Perl_sv_nosharing(pTHX_ SV *sv)
{
}

/*
=for apidoc sv_nolocking

Dummy routine which "locks" an SV when there is no locking module present.
Exists to avoid test for a NULL function pointer and because it could potentially warn under
some level of strict-ness.

=cut
*/

void
Perl_sv_nolocking(pTHX_ SV *sv)
{
}


/*
=for apidoc sv_nounlocking

Dummy routine which "unlocks" an SV when there is no locking module present.
Exists to avoid test for a NULL function pointer and because it could potentially warn under
some level of strict-ness.

=cut
*/

void
Perl_sv_nounlocking(pTHX_ SV *sv)
{
}

@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@d3 1
a3 2
 *    Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999,
 *    2000, 2001, 2002, 2003, by Larry Wall and others
d41 9
d88 1
a88 1
	return Nullch;
d192 142
d511 1
a511 2
    if (flags & FBMcf_TAIL) {
	MAGIC *mg = SvUTF8(sv) && SvMAGICAL(sv) ? mg_find(sv, PERL_MAGIC_utf8) : NULL;
a512 3
	if (mg && mg->mg_len >= 0)
	    mg->mg_len++;
    }
d1111 1
a1111 1
	    OutCopFILE(cop), (IV)CopLINE(cop));
a1129 46
void
Perl_write_to_stderr(pTHX_ const char* message, int msglen)
{
    IO *io;
    MAGIC *mg;

    if (PL_stderrgv && SvREFCNT(PL_stderrgv) 
	&& (io = GvIO(PL_stderrgv))
	&& (mg = SvTIED_mg((SV*)io, PERL_MAGIC_tiedscalar))) 
    {
	dSP;
	ENTER;
	SAVETMPS;

	save_re_context();
	SAVESPTR(PL_stderrgv);
	PL_stderrgv = Nullgv;

	PUSHSTACKi(PERLSI_MAGIC);

	PUSHMARK(SP);
	EXTEND(SP,2);
	PUSHs(SvTIED_obj((SV*)io, mg));
	PUSHs(sv_2mortal(newSVpvn(message, msglen)));
	PUTBACK;
	call_method("PRINT", G_SCALAR);

	POPSTACK;
	FREETMPS;
	LEAVE;
    }
    else {
#ifdef USE_SFIO
	/* SFIO can really mess with your errno */
	int e = errno;
#endif
	PerlIO *serr = Perl_error_log;

	PERL_WRITE_MSG_TO_CONSOLE(serr, message, msglen);
	(void)PerlIO_flush(serr);
#ifdef USE_SFIO
	errno = e;
#endif
    }
}

a1139 1
    I32 utf8 = 0;
a1153 1
	utf8 = SvUTF8(msv);
a1178 1
		SvFLAGS(msg) |= utf8;
a1196 1
    SvFLAGS(ERRSV) |= utf8;
a1238 1
    I32 utf8 = 0;
a1248 1
	utf8 = SvUTF8(msv);
a1273 1
		SvFLAGS(msg) |= utf8;
a1291 1
	SvFLAGS(ERRSV) |= utf8;
d1297 13
a1309 1
    write_to_stderr(message, msglen);
d1364 2
a1365 1
    I32 utf8 = 0;
a1367 1
    utf8 = SvUTF8(msv);
a1384 1
	    SvFLAGS(msg) |= utf8;
d1399 27
a1425 1
    write_to_stderr(message, msglen);
a1488 1
    I32 utf8 = 0;
a1491 1
    utf8 = SvUTF8(msv);
d1495 1
a1495 1
	DEBUG_S(PerlIO_printf(Perl_debug_log, "croak: 0x%"UVxf" %s", PTR2UV(thr), message));
d1497 11
a1507 11
	if (PL_diehook) {
	    /* sv_2cv might call Perl_croak() */
	    SV *olddiehook = PL_diehook;
	    ENTER;
	    SAVESPTR(PL_diehook);
	    PL_diehook = Nullsv;
	    cv = sv_2cv(olddiehook, &stash, &gv, 0);
	    LEAVE;
	    if (cv && !CvDEPTH(cv) && (CvROOT(cv) || CvXSUB(cv))) {
		dSP;
		SV *msg;
d1509 1
a1509 1
		ENTER;
d1511 3
a1513 4
		msg = newSVpvn(message, msglen);
		SvFLAGS(msg) |= utf8;
		SvREADONLY_on(msg);
		SAVEFREESV(msg);
d1516 4
a1519 4
		PUSHMARK(sp);
		XPUSHs(msg);
		PUTBACK;
		call_sv((SV*)cv, G_DISCARD);
d1521 11
a1531 2
		LEAVE;
	    }
d1533 2
a1534 7
	if (PL_in_eval) {
	    PL_restartop = die_where(message, msglen);
	    SvFLAGS(ERRSV) |= utf8;
	    JMPENV_JUMP(3);
	}
	write_to_stderr(message, msglen);
	my_failure_exit();
d1537 7
a1543 7
	if (PL_warnhook) {
	    /* sv_2cv might call Perl_warn() */
	    SV *oldwarnhook = PL_warnhook;
	    ENTER;
	    SAVESPTR(PL_warnhook);
	    PL_warnhook = Nullsv;
	    cv = sv_2cv(oldwarnhook, &stash, &gv, 0);
d1545 3
a1547 3
	    if (cv && !CvDEPTH(cv) && (CvROOT(cv) || CvXSUB(cv))) {
		dSP;
		SV *msg;
d1549 1
a1549 1
		ENTER;
d1551 3
a1553 4
		msg = newSVpvn(message, msglen);
		SvFLAGS(msg) |= utf8;
		SvREADONLY_on(msg);
		SAVEFREESV(msg);
d1556 4
a1559 4
		PUSHMARK(sp);
		XPUSHs(msg);
		PUTBACK;
		call_sv((SV*)cv, G_DISCARD);
d1561 16
a1576 3
		LEAVE;
		return;
	    }
a1577 1
	write_to_stderr(message, msglen);
d1616 3
a1618 3
	    int len = strlen(environ[j]);
	    tmpenv[j] = (char*)safesysmalloc((len+1)*sizeof(char));
	    Copy(environ[j], tmpenv[j], len+1, char);
d1651 1
a1651 1
	val = "";
a1682 1
#ifndef PERL_MICRO
a1699 1
#endif /* !PERL_MICRO */
d2006 1
a2006 1
		if (fd != pp[1])
d2144 1
a2144 1
		int fd;
d2148 1
a2148 1
			PerlLIO_close(fd);
d2158 1
a2158 1
	    SvREADONLY_off(GvSV(tmpgv));
d2160 2
a2161 5
	    SvREADONLY_on(GvSV(tmpgv));
	}
#ifdef THREADS_HAVE_PIDS
	PL_ppid = (IV)getppid();
#endif
a2346 5
#ifdef MACOS_TRADITIONAL
/* We don't want restart behavior on MacOS */
#undef SA_RESTART
#endif

d2362 3
a2364 2
    if (PL_signals & PERL_SIGNALS_UNSAFE_FLAG)
        act.sa_flags |= SA_RESTART;	/* SVR4, 4.3+BSD */
d2366 1
a2366 1
#if defined(SA_NOCLDWAIT) && !defined(BSDish) /* See [perl #18849] */
d2382 1
a2382 1
	return SIG_ERR;
d2384 1
a2384 1
	return oact.sa_handler;
d2402 3
a2404 2
    if (PL_signals & PERL_SIGNALS_UNSAFE_FLAG)
        act.sa_flags |= SA_RESTART;	/* SVR4, 4.3+BSD */
d2406 1
a2406 1
#if defined(SA_NOCLDWAIT) && !defined(BSDish) /* See [perl #18849] */
d2464 1
a2464 1
	PerlProc_kill(PerlProc_getpid(), signo);
d2566 3
a2568 3
	SV *sv;
	SV** svp;
	char spid[TYPE_CHARS(int)];
d2570 7
a2576 8
	if (pid > 0) {
	    sprintf(spid, "%"IVdf, (IV)pid);
	    svp = hv_fetch(PL_pidstatus,spid,strlen(spid),FALSE);
	    if (svp && *svp != &PL_sv_undef) {
		*statusp = SvIVX(*svp);
		(void)hv_delete(PL_pidstatus,spid,strlen(spid),G_DISCARD);
		return pid;
	    }
d2578 3
a2580 2
	else {
	    HE *entry;
d2582 11
a2592 12
	    hv_iterinit(PL_pidstatus);
	    if ((entry = hv_iternext(PL_pidstatus))) {
		SV *sv;
		char spid[TYPE_CHARS(int)];

		pid = atoi(hv_iterkey(entry,(I32*)statusp));
		sv = hv_iterval(PL_pidstatus,entry);
		*statusp = SvIVX(sv);
		sprintf(spid, "%"IVdf, (IV)pid);
		(void)hv_delete(PL_pidstatus,spid,strlen(spid),G_DISCARD);
		return pid;
	    }
d2594 1
d2936 1
a2936 1
		xfound = tmpbuf;		/* bingo! */
d2950 1
a2950 1
		Perl_croak(aTHX_ "Can't %s %s%s%s",
d3231 1
a3231 1
    PL_curpm = t->Tcurpm;	/* XXX No PMOP ref count */
a3242 4
    PL_watchaddr = 0; /* XXX */
    PL_watchok = 0; /* XXX */
    PL_comppad = 0;
    PL_curpad = 0;
a3426 3
    case want_vtbl_utf8:
	result = &PL_vtbl_utf8;
	break;
d3434 1
a3434 1
#if defined(USE_PERLIO) || defined(FFLUSH_NULL) || defined(USE_SFIO)
d3475 1
a3475 1
    SETERRNO(EBADF,RMS_IFI);
d3484 2
d3491 3
a3493 3
    char *type = OP_IS_SOCKET(op)
	    || (gv && io && IoTYPE(io) == IoTYPE_SOCKET)
		?  "socket" : "filehandle";
d3496 9
d3510 14
a3523 10
	if (ckWARN(WARN_IO)) {
	    const char *direction = (op == OP_phoney_INPUT_ONLY) ? "in" : "out";
	    if (name && *name)
		Perl_warner(aTHX_ packWARN(WARN_IO),
			    "Filehandle %s opened only for %sput",
			    name, direction);
	    else
		Perl_warner(aTHX_ packWARN(WARN_IO),
			    "Filehandle opened only for %sput", direction);
	}
d3526 4
a3529 29
	char *vile;
	I32   warn_type;

	if (gv && io && IoTYPE(io) == IoTYPE_CLOSED) {
	    vile = "closed";
	    warn_type = WARN_CLOSED;
	}
	else {
	    vile = "unopened";
	    warn_type = WARN_UNOPENED;
	}

	if (ckWARN(warn_type)) {
	    if (name && *name) {
		Perl_warner(aTHX_ packWARN(warn_type),
			    "%s%s on %s %s %s", func, pars, vile, type, name);
		if (io && IoDIRP(io) && !(IoFLAGS(io) & IOf_FAKE_DIRP))
		    Perl_warner(
			aTHX_ packWARN(warn_type),
			"\t(Are you trying to call %s%s on dirhandle %s?)\n",
			func, pars, name
		    );
	    }
	    else {
		Perl_warner(aTHX_ packWARN(warn_type),
			    "%s%s on %s %s", func, pars, vile, type);
		if (gv && io && IoDIRP(io) && !(IoFLAGS(io) & IOf_FAKE_DIRP))
		    Perl_warner(
			aTHX_ packWARN(warn_type),
d3531 1
a3531 4
			func, pars
		    );
	    }
	}
d3542 2
a3543 2
    if (ch > 'a') {
	char *ctlp;
d3545 2
a3546 2
	if (islower(ch))
	    ch = toupper(ch);
d3548 23
a3570 2
	if ((ctlp = strchr(controllablechars, ch)) == 0) {
	    Perl_die(aTHX_ "unrecognised control character '%c'\n", ch);
a3571 21

	if (ctlp == controllablechars)
	    return('\177'); /* DEL */
	else
	    return((unsigned char)(ctlp - controllablechars - 1));
    } else { /* Want uncontrol */
	if (ch == '\177' || ch == -1)
	    return('?');
	else if (ch == '\157')
	    return('\177');
	else if (ch == '\174')
	    return('\000');
	else if (ch == '^')    /* '\137' in 1047, '\260' in 819 */
	    return('\036');
	else if (ch == '\155')
	    return('\037');
	else if (0 < ch && ch < (sizeof(controllablechars) - 1))
	    return(controllablechars[ch+1]);
	else
	    Perl_die(aTHX_ "invalid control request: '\\%03o'\n", ch & 0xFF);
    }
a3823 14
  /* use libc to get the values for tm_gmtoff and tm_zone [perl #18238] */
#if defined(HAS_MKTIME) && (defined(HAS_TM_TM_GMTOFF) || defined(HAS_TM_TM_ZONE))
  STMT_START {
    struct tm mytm2;
    mytm2 = mytm;
    mktime(&mytm2);
#ifdef HAS_TM_TM_GMTOFF
    mytm.tm_gmtoff = mytm2.tm_gmtoff;
#endif
#ifdef HAS_TM_TM_ZONE
    mytm.tm_zone = mytm2.tm_zone;
#endif
  } STMT_END;
#endif
d3876 1
a3876 1
	(dp->d_name[1] == '.' && dp->d_name[2] == '\0')))
d3909 1
a3909 1
	/* Some getcwd()s automatically allocate a buffer of the given
d3912 9
a3920 9
	if (getcwd(buf, sizeof(buf) - 1)) {
	    STRLEN len = strlen(buf);
	    sv_setpvn(sv, buf, len);
	    return TRUE;
	}
	else {
	    sv_setsv(sv, &PL_sv_undef);
	    return FALSE;
	}
d3934 1
a3934 1
	SV_CWD_RETURN_UNDEF;
d3943 2
a3944 2
	odev = cdev;
	oino = cino;
d3946 16
a3961 9
	if (PerlDir_chdir("..") < 0) {
	    SV_CWD_RETURN_UNDEF;
	}
	if (PerlLIO_stat(".", &statbuf) < 0) {
	    SV_CWD_RETURN_UNDEF;
	}

	cdev = statbuf.st_dev;
	cino = statbuf.st_ino;
d3963 1
a3963 8
	if (odev == cdev && oino == cino) {
	    break;
	}
	if (!(dir = PerlDir_open("."))) {
	    SV_CWD_RETURN_UNDEF;
	}

	while ((dp = PerlDir_read(dir)) != NULL) {
d3965 1
a3965 1
	    namelen = dp->d_namlen;
d3967 1
a3967 1
	    namelen = strlen(dp->d_name);
d3969 35
a4003 35
	    /* skip . and .. */
	    if (SV_CWD_ISDOT(dp)) {
		continue;
	    }

	    if (PerlLIO_lstat(dp->d_name, &statbuf) < 0) {
		SV_CWD_RETURN_UNDEF;
	    }

	    tdev = statbuf.st_dev;
	    tino = statbuf.st_ino;
	    if (tino == oino && tdev == odev) {
		break;
	    }
	}

	if (!dp) {
	    SV_CWD_RETURN_UNDEF;
	}

	if (pathlen + namelen + 1 >= MAXPATHLEN) {
	    SV_CWD_RETURN_UNDEF;
	}

	SvGROW(sv, pathlen + namelen + 1);

	if (pathlen) {
	    /* shift down */
	    Move(SvPVX(sv), SvPVX(sv) + namelen + 1, pathlen, char);
	}

	/* prepend current directory to the front */
	*SvPVX(sv) = '/';
	Move(dp->d_name, SvPVX(sv)+1, namelen, char);
	pathlen += (namelen + 1);
d4006 1
a4006 1
	PerlDir_close(dir);
d4008 3
a4010 3
	if (PerlDir_close(dir) < 0) {
	    SV_CWD_RETURN_UNDEF;
	}
d4015 3
a4017 3
	SvCUR_set(sv, pathlen);
	*SvEND(sv) = '\0';
	SvPOK_only(sv);
d4020 2
a4021 2
	    SV_CWD_RETURN_UNDEF;
	}
d4024 1
a4024 1
	SV_CWD_RETURN_UNDEF;
d4031 2
a4032 2
	Perl_croak(aTHX_ "Unstable directory path, "
		   "current directory changed unexpectedly");
d4043 78
d4133 1
a4133 1
    Sock_size_t size = sizeof(struct sockaddr_in);
d4137 1
a4137 1
    memset(&addresses, 0, sizeof(addresses));
d4140 11
a4150 10
	sockets[i] = PerlSock_socket(AF_INET, SOCK_DGRAM, PF_INET);
	if (sockets[i] == -1)
	    goto tidy_up_and_fail;

	addresses[i].sin_family = AF_INET;
	addresses[i].sin_addr.s_addr = htonl(INADDR_LOOPBACK);
	addresses[i].sin_port = 0;	/* kernel choses port.  */
	if (PerlSock_bind(sockets[i], (struct sockaddr *) &addresses[i],
		sizeof(struct sockaddr_in)) == -1)
	    goto tidy_up_and_fail;
d4157 9
a4165 9
	if (PerlSock_getsockname(sockets[i], (struct sockaddr *) &addresses[i],
		&size) == -1)
	    goto tidy_up_and_fail;
	if (size != sizeof(struct sockaddr_in))
	    goto abort_tidy_up_and_fail;
	/* !1 is 0, !0 is 1 */
	if (PerlSock_connect(sockets[!i], (struct sockaddr *) &addresses[i],
		sizeof(struct sockaddr_in)) == -1)
	    goto tidy_up_and_fail;
d4173 10
a4182 10
	/* I'm going to send my own port number.  As a short.
	   (Who knows if someone somewhere has sin_port as a bitfield and needs
	   this routine. (I'm assuming crays have socketpair)) */
	port = addresses[i].sin_port;
	got = PerlLIO_write(sockets[i], &port, sizeof(port));
	if (got != sizeof(port)) {
	    if (got == -1)
		goto tidy_up_and_fail;
	    goto abort_tidy_up_and_fail;
	}
d4196 16
a4211 16
	struct timeval waitfor = {0, 100000}; /* You have 0.1 seconds */
	int max = sockets[1] > sockets[0] ? sockets[1] : sockets[0];
	fd_set rset;

	FD_ZERO(&rset);
	FD_SET(sockets[0], &rset);
	FD_SET(sockets[1], &rset);

	got = PerlSock_select(max + 1, &rset, NULL, NULL, &waitfor);
	if (got != 2 || !FD_ISSET(sockets[0], &rset)
		|| !FD_ISSET(sockets[1], &rset)) {
	    /* I hope this is portable and appropriate.  */
	    if (got == -1)
		goto tidy_up_and_fail;
	    goto abort_tidy_up_and_fail;
	}
d4217 2
a4218 2
	struct sockaddr_in readfrom;
	unsigned short buffer[2];
d4220 2
a4221 2
	i = 1;
	do {
d4223 3
a4225 3
	    got = PerlSock_recvfrom(sockets[i], (char *) &buffer,
		    sizeof(buffer), MSG_DONTWAIT,
		    (struct sockaddr *) &readfrom, &size);
d4227 17
a4243 17
	    got = PerlSock_recvfrom(sockets[i], (char *) &buffer,
		    sizeof(buffer), 0,
		    (struct sockaddr *) &readfrom, &size);
#endif

	    if (got == -1)
		goto tidy_up_and_fail;
	    if (got != sizeof(port)
		    || size != sizeof(struct sockaddr_in)
		    /* Check other socket sent us its port.  */
		    || buffer[0] != (unsigned short) addresses[!i].sin_port
		    /* Check kernel says we got the datagram from that socket */
		    || readfrom.sin_family != addresses[!i].sin_family
		    || readfrom.sin_addr.s_addr != addresses[!i].sin_addr.s_addr
		    || readfrom.sin_port != addresses[!i].sin_port)
		goto abort_tidy_up_and_fail;
	} while (i--);
d4256 7
a4262 7
	int save_errno = errno;
	if (sockets[0] != -1)
	    PerlLIO_close(sockets[0]);
	if (sockets[1] != -1)
	    PerlLIO_close(sockets[1]);
	errno = save_errno;
	return -1;
d4284 3
a4286 3
    ) {
	errno = EAFNOSUPPORT;
	return -1;
d4289 2
a4290 2
	errno = EINVAL;
	return -1;
d4295 1
a4295 1
	return S_socketpair_udp(fd);
d4298 1
a4298 1
    listener = PerlSock_socket(AF_INET, type, 0);
d4300 2
a4301 2
	return -1;
    memset(&listen_addr, 0, sizeof(listen_addr));
d4303 1
a4303 1
    listen_addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
d4305 3
a4307 3
    if (PerlSock_bind(listener, (struct sockaddr *) &listen_addr,
	    sizeof(listen_addr)) == -1)
	goto tidy_up_and_fail;
d4309 1
a4309 1
	goto tidy_up_and_fail;
d4311 1
a4311 1
    connector = PerlSock_socket(AF_INET, type, 0);
d4313 1
a4313 1
	goto tidy_up_and_fail;
d4315 5
a4319 6
    size = sizeof(connect_addr);
    if (PerlSock_getsockname(listener, (struct sockaddr *) &connect_addr,
	    &size) == -1)
	goto tidy_up_and_fail;
    if (size != sizeof(connect_addr))
	goto abort_tidy_up_and_fail;
d4321 2
a4322 2
	    sizeof(connect_addr)) == -1)
	goto tidy_up_and_fail;
d4324 2
a4325 3
    size = sizeof(listen_addr);
    acceptor = PerlSock_accept(listener, (struct sockaddr *) &listen_addr,
	    &size);
d4327 4
a4330 4
	goto tidy_up_and_fail;
    if (size != sizeof(listen_addr))
	goto abort_tidy_up_and_fail;
    PerlLIO_close(listener);
d4333 7
a4339 8
    if (PerlSock_getsockname(connector, (struct sockaddr *) &connect_addr,
	    &size) == -1)
	goto tidy_up_and_fail;
    if (size != sizeof(connect_addr)
	    || listen_addr.sin_family != connect_addr.sin_family
	    || listen_addr.sin_addr.s_addr != connect_addr.sin_addr.s_addr
	    || listen_addr.sin_port != connect_addr.sin_port) {
	goto abort_tidy_up_and_fail;
d4349 9
a4357 9
	int save_errno = errno;
	if (listener != -1)
	    PerlLIO_close(listener);
	if (connector != -1)
	    PerlLIO_close(connector);
	if (acceptor != -1)
	    PerlLIO_close(acceptor);
	errno = save_errno;
	return -1;
a4419 171
U32
Perl_parse_unicode_opts(pTHX_ char **popt)
{
  char *p = *popt;
  U32 opt = 0;

  if (*p) {
       if (isDIGIT(*p)) {
	    opt = (U32) atoi(p);
	    while (isDIGIT(*p)) p++;
	    if (*p && *p != '\n' && *p != '\r')
		 Perl_croak(aTHX_ "Unknown Unicode option letter '%c'", *p);
       }
       else {
	    for (; *p; p++) {
		 switch (*p) {
		 case PERL_UNICODE_STDIN:
		      opt |= PERL_UNICODE_STDIN_FLAG;	break;
		 case PERL_UNICODE_STDOUT:
		      opt |= PERL_UNICODE_STDOUT_FLAG;	break;
		 case PERL_UNICODE_STDERR:
		      opt |= PERL_UNICODE_STDERR_FLAG;	break;
		 case PERL_UNICODE_STD:
		      opt |= PERL_UNICODE_STD_FLAG;    	break;
		 case PERL_UNICODE_IN:
		      opt |= PERL_UNICODE_IN_FLAG;	break;
		 case PERL_UNICODE_OUT:
		      opt |= PERL_UNICODE_OUT_FLAG;	break;
		 case PERL_UNICODE_INOUT:
		      opt |= PERL_UNICODE_INOUT_FLAG;	break;
		 case PERL_UNICODE_LOCALE:
		      opt |= PERL_UNICODE_LOCALE_FLAG;	break;
		 case PERL_UNICODE_ARGV:
		      opt |= PERL_UNICODE_ARGV_FLAG;	break;
		 default:
		      if (*p != '\n' && *p != '\r')
			  Perl_croak(aTHX_
				     "Unknown Unicode option letter '%c'", *p);
		 }
	    }
       }
  }
  else
       opt = PERL_UNICODE_DEFAULT_FLAGS;

  if (opt & ~PERL_UNICODE_ALL_FLAGS)
       Perl_croak(aTHX_ "Unknown Unicode option value %"UVuf,
		  (UV) (opt & ~PERL_UNICODE_ALL_FLAGS));

  *popt = p;

  return opt;
}

U32
Perl_seed(pTHX)
{
    /*
     * This is really just a quick hack which grabs various garbage
     * values.  It really should be a real hash algorithm which
     * spreads the effect of every input bit onto every output bit,
     * if someone who knows about such things would bother to write it.
     * Might be a good idea to add that function to CORE as well.
     * No numbers below come from careful analysis or anything here,
     * except they are primes and SEED_C1 > 1E6 to get a full-width
     * value from (tv_sec * SEED_C1 + tv_usec).  The multipliers should
     * probably be bigger too.
     */
#if RANDBITS > 16
#  define SEED_C1	1000003
#define   SEED_C4	73819
#else
#  define SEED_C1	25747
#define   SEED_C4	20639
#endif
#define   SEED_C2	3
#define   SEED_C3	269
#define   SEED_C5	26107

#ifndef PERL_NO_DEV_RANDOM
    int fd;
#endif
    U32 u;
#ifdef VMS
#  include <starlet.h>
    /* when[] = (low 32 bits, high 32 bits) of time since epoch
     * in 100-ns units, typically incremented ever 10 ms.        */
    unsigned int when[2];
#else
#  ifdef HAS_GETTIMEOFDAY
    struct timeval when;
#  else
    Time_t when;
#  endif
#endif

/* This test is an escape hatch, this symbol isn't set by Configure. */
#ifndef PERL_NO_DEV_RANDOM
#ifndef PERL_RANDOM_DEVICE
   /* /dev/random isn't used by default because reads from it will block
    * if there isn't enough entropy available.  You can compile with
    * PERL_RANDOM_DEVICE to it if you'd prefer Perl to block until there
    * is enough real entropy to fill the seed. */
#  define PERL_RANDOM_DEVICE "/dev/urandom"
#endif
    fd = PerlLIO_open(PERL_RANDOM_DEVICE, 0);
    if (fd != -1) {
    	if (PerlLIO_read(fd, &u, sizeof u) != sizeof u)
	    u = 0;
	PerlLIO_close(fd);
	if (u)
	    return u;
    }
#endif

#ifdef VMS
    _ckvmssts(sys$gettim(when));
    u = (U32)SEED_C1 * when[0] + (U32)SEED_C2 * when[1];
#else
#  ifdef HAS_GETTIMEOFDAY
    PerlProc_gettimeofday(&when,NULL);
    u = (U32)SEED_C1 * when.tv_sec + (U32)SEED_C2 * when.tv_usec;
#  else
    (void)time(&when);
    u = (U32)SEED_C1 * when;
#  endif
#endif
    u += SEED_C3 * (U32)PerlProc_getpid();
    u += SEED_C4 * (U32)PTR2UV(PL_stack_sp);
#ifndef PLAN9           /* XXX Plan9 assembler chokes on this; fix needed  */
    u += SEED_C5 * (U32)PTR2UV(&when);
#endif
    return u;
}

UV
Perl_get_hash_seed(pTHX)
{
     char *s = PerlEnv_getenv("PERL_HASH_SEED");
     UV myseed = 0;

     if (s)
	  while (isSPACE(*s)) s++;
     if (s && isDIGIT(*s))
	  myseed = (UV)Atoul(s);
     else
#ifdef USE_HASH_SEED_EXPLICIT
     if (s)
#endif
     {
	  /* Compute a random seed */
	  (void)seedDrand01((Rand_seed_t)seed());
	  myseed = (UV)(Drand01() * (NV)UV_MAX);
#if RANDBITS < (UVSIZE * 8)
	  /* Since there are not enough randbits to to reach all
	   * the bits of a UV, the low bits might need extra
	   * help.  Sum in another random number that will
	   * fill in the low bits. */
	  myseed +=
	       (UV)(Drand01() * (NV)((1 << ((UVSIZE * 8 - RANDBITS))) - 1));
#endif /* RANDBITS < (UVSIZE * 8) */
	  if (myseed == 0) { /* Superparanoia. */
	      myseed = (UV)(Drand01() * (NV)UV_MAX); /* One more chance. */
	      if (myseed == 0)
		  Perl_croak(aTHX_ "Your random numbers are not that random");
	  }
     }
     PL_rehash_seed_set = TRUE;

     return myseed;
}
@


1.1.1.7
log
@perl 5.8.3 from CPAN
@
text
@d21 1
d23 2
@


1.1.1.8
log
@Import of stock perl 5.8.5
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, by Larry Wall and others
d75 1
a75 3
	/* Can't use PerlIO to write as it allocates memory */
	PerlLIO_write(PerlIO_fileno(Perl_error_log),
		      PL_no_mem, strlen(PL_no_mem));
d122 1
a122 3
	/* Can't use PerlIO to write as it allocates memory */
	PerlLIO_write(PerlIO_fileno(Perl_error_log),
		      PL_no_mem, strlen(PL_no_mem));
d174 1
a174 3
	/* Can't use PerlIO to write as it allocates memory */
	PerlLIO_write(PerlIO_fileno(Perl_error_log),
		      PL_no_mem, strlen(PL_no_mem));
d1225 2
a1226 3
Normally call this function the same way you call the C C<printf>
function.  Calling C<croak> returns control directly to Perl,
sidestepping the normal C order of execution. See C<warn>.
d1311 3
a1313 2
This is the XSUB-writer's interface to Perl's C<warn> function.  Call this
function the same way you call the C C<printf> function.  See C<croak>.
@


1.1.1.9
log
@perl 5.8.6 from CPAN
@
text
@a15 6
/* This file contains assorted utility routines.
 * Which is a polite way of saying any stuff that people couldn't think of
 * a better place for. Amongst other things, it includes the warning and
 * dieing stuff, plus wrappers for malloc code.
 */

d754 6
a759 6
    register char *newaddr;
    if (!pv)
	return Nullch;

    New(902,newaddr,strlen(pv)+1,char);
    return strcpy(newaddr,pv);
d783 2
a784 3
	/* might not be null terminated */
    	newaddr[len] = '\0';
    	return CopyD(pv,newaddr,len,char);
d787 1
a787 1
	return ZeroD(newaddr,len+1,char);
d789 1
d803 4
a806 9
    register char *newaddr;
    if (!pv)
	return Nullch;

    newaddr = (char*)PerlMemShared_malloc(strlen(pv)+1);
    if (!newaddr) {
	PerlLIO_write(PerlIO_fileno(Perl_error_log),
		      PL_no_mem, strlen(PL_no_mem));
	my_exit(1);
d808 1
a808 1
    return strcpy(newaddr,pv);
d1033 2
a1034 7
/* Common code used by vcroak, vdie and vwarner  */

void S_vdie_common(pTHX_ const char *message, STRLEN msglen, I32 utf8);

char *
S_vdie_croak_common(pTHX_ const char* pat, va_list* args, STRLEN* msglen,
		    I32* utf8)
d1037 11
d1050 1
a1050 1
	SV *msv = vmess(pat, args);
d1053 1
a1053 1
	    message = SvPV(PL_errors, *msglen);
d1057 2
a1058 2
	    message = SvPV(msv,*msglen);
	*utf8 = SvUTF8(msv);
d1062 1
d1066 1
a1066 1
			  "%p: die/croak: message = %s\ndiehook = %p\n",
d1069 10
a1078 4
	S_vdie_common(aTHX_ message, *msglen, *utf8);
    }
    return message;
}
d1080 11
a1090 8
void
S_vdie_common(pTHX_ const char *message, STRLEN msglen, I32 utf8)
{
    HV *stash;
    GV *gv;
    CV *cv;
    /* sv_2cv might call Perl_croak() */
    SV *olddiehook = PL_diehook;
d1092 7
a1098 17
    assert(PL_diehook);
    ENTER;
    SAVESPTR(PL_diehook);
    PL_diehook = Nullsv;
    cv = sv_2cv(olddiehook, &stash, &gv, 0);
    LEAVE;
    if (cv && !CvDEPTH(cv) && (CvROOT(cv) || CvXSUB(cv))) {
	dSP;
	SV *msg;

	ENTER;
	save_re_context();
	if (message) {
	    msg = newSVpvn(message, msglen);
	    SvFLAGS(msg) |= utf8;
	    SvREADONLY_on(msg);
	    SAVEFREESV(msg);
a1099 11
	else {
	    msg = ERRSV;
	}

	PUSHSTACKi(PERLSI_DIEHOOK);
	PUSHMARK(SP);
	XPUSHs(msg);
	PUTBACK;
	call_sv((SV*)cv, G_DISCARD);
	POPSTACK;
	LEAVE;
a1100 15
}

OP *
Perl_vdie(pTHX_ const char* pat, va_list *args)
{
    char *message;
    int was_in_eval = PL_in_eval;
    STRLEN msglen;
    I32 utf8 = 0;

    DEBUG_S(PerlIO_printf(Perl_debug_log,
			  "%p: die: curstack = %p, mainstack = %p\n",
			  thr, PL_curstack, PL_mainstack));

    message = S_vdie_croak_common(aTHX_ pat, args, &msglen, &utf8);
d1141 4
d1148 30
a1177 1
    message = S_vdie_croak_common(aTHX_ pat, args, &msglen, &utf8);
d1179 21
d1357 12
a1369 5
	SV *msv = vmess(pat, args);
	STRLEN msglen;
	char *message = SvPV(msv, msglen);
	I32 utf8 = SvUTF8(msv);

d1374 26
a1399 2
	    assert(message);
	    S_vdie_common(aTHX_ message, msglen, utf8);
d1410 30
a1439 1
	Perl_vwarn(aTHX_ pat, args);
a1464 1
    if (!PL_use_safe_putenv) {
d1505 2
a1506 2
    } else {
# endif
d1521 1
a1521 3
#ifndef PERL_USE_SAFE_PUTENV
    }
#endif
@


1.1.1.10
log
@perl 5.8.8 import
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006, by Larry Wall and others
a32 5
#ifdef __Lynx__
/* Missing protos on LynxOS */
int putenv(char *);
#endif

d149 1
d249 1
a249 1
    return (char *)from;
d258 1
a266 1
	register const char *s, *x;
d288 2
a289 1
    register const I32 first = *little;
a297 1
	register const char *s, *x;
d318 2
a319 1
    register const I32 first = *little;
a326 1
	register const char *s, *x;
d363 2
a364 1
    register const U8 *s;
d371 1
a371 1
	MAGIC * const mg = SvUTF8(sv) && SvMAGICAL(sv) ? mg_find(sv, PERL_MAGIC_utf8) : NULL;
d376 1
a376 1
    s = (U8*)SvPV_force_mutable(sv, len);
d381 2
a382 3
	const unsigned char *sb;
	const U8 mlen = (len>255) ? 255 : (U8)len;
	register U8 *table;
d384 4
d389 1
a389 1
	table = (unsigned char*)(SvPVX_mutable(sv) + len + FBM_TABLE_OFFSET);
d404 1
a404 1
    s = (const unsigned char*)(SvPVX_const(sv));	/* deeper magic */
d440 1
a440 2
    register const unsigned char *little
	= (const unsigned char *)SvPV_const(littlestr,l);
d442 1
a442 1
    register const I32 multiline = flags & FBMrf_MULTILINE;
d488 2
a489 2
	    const unsigned char c1 = little[0];
	    const unsigned char c2 = little[1];
d570 2
a571 2
	register const unsigned char *table = little + littlelen + FBM_TABLE_OFFSET;
	register const unsigned char *oldlittle;
d584 1
d591 1
a591 1
		register unsigned char * const olds = s;
d618 1
a618 1
   If "last" we want the last occurrence.
d634 2
a635 1
    register const unsigned char *big;
d639 1
a639 1
    register const unsigned char *little;
d641 1
a641 1
    register const unsigned char *littleend;
d650 1
a650 1
	    little = (const unsigned char *)(SvPVX_const(littlestr));
d658 1
a658 1
    little = (const unsigned char *)(SvPVX_const(littlestr));
d663 1
a663 1
    big = (const unsigned char *)(SvPVX_const(bigstr));
a682 1
	register const unsigned char *s, *x;
d704 1
a704 1
    big = (const unsigned char *)(SvPVX_const(bigstr) + SvCUR(bigstr));
d719 2
a720 2
    register const U8 *a = (const U8 *)s1;
    register const U8 *b = (const U8 *)s2;
d732 2
a733 2
    register const U8 *a = (const U8 *)s1;
    register const U8 *b = (const U8 *)s2;
d760 1
a762 6
    else {
	char *newaddr;
	const STRLEN pvlen = strlen(pv)+1;
	Newx(newaddr,pvlen,char);
	return memcpy(newaddr,pv,pvlen);
    }
d764 2
d786 1
a786 1
    Newx(newaddr,len+1,char);
d791 1
a791 1
    	return (char *) CopyD(pv,newaddr,len,char);
d794 1
a794 1
	return (char *) ZeroD(newaddr,len+1,char);
a809 1
    STRLEN pvlen;
d813 1
a813 2
    pvlen = strlen(pv)+1;
    newaddr = (char*)PerlMemShared_malloc(pvlen);
d819 1
a819 1
    return memcpy(newaddr,pv,pvlen);
a821 20
/*
=for apidoc savesvpv

A version of C<savepv()>/C<savepvn()> which gets the string to duplicate from
the passed in SV using C<SvPV()>

=cut
*/

char *
Perl_savesvpv(pTHX_ SV *sv)
{
    STRLEN len;
    const char *pv = SvPV_const(sv, len);
    register char *newaddr;

    ++len;
    Newx(newaddr,len,char);
    return (char *) CopyD(pv,newaddr,len,char);
}
d839 2
a840 2
    Newx(sv, 1, SV);
    Newxz(any, 1, XPVMG);
d896 1
a896 1
    SV * const sv = mess_alloc();
d927 1
a927 1
S_closest_cop(pTHX_ COP *cop, const OP *o)
d954 1
a954 1
    return Null(COP *);
d961 2
a962 1
    static const char dgd[] = " during global destruction.\n";
d974 1
a974 1
	const COP *cop = closest_cop(PL_curcop, PL_curcop->op_sibling);
d981 2
a982 2
	    const bool line_mode = (RsSIMPLE(PL_rs) &&
			      SvCUR(PL_rs) == 1 && *SvPVX_const(PL_rs) == '\n');
d1032 1
a1032 1
	const int e = errno;
d1034 1
a1034 1
	PerlIO * const serr = Perl_error_log;
d1046 32
a1077 2
/* Whilst this should really be STATIC, it was not in 5.8.7, hence something
   may have linked against it.  */
d1085 1
a1085 1
    SV * const olddiehook = PL_diehook;
a1118 34
/* Whilst this should really be STATIC, it was not in 5.8.7, hence something
   may have linked against it.  */
char *
S_vdie_croak_common(pTHX_ const char* pat, va_list* args, STRLEN* msglen,
		    I32* utf8)
{
    const char *message;

    if (pat) {
	SV * const msv = vmess(pat, args);
	if (PL_errors && SvCUR(PL_errors)) {
	    sv_catsv(PL_errors, msv);
	    message = SvPV_const(PL_errors, *msglen);
	    SvCUR_set(PL_errors, 0);
	}
	else
	    message = SvPV_const(msv,*msglen);
	*utf8 = SvUTF8(msv);
    }
    else {
	message = Nullch;
    }

    DEBUG_S(PerlIO_printf(Perl_debug_log,
			  "%p: die/croak: message = %s\ndiehook = %p\n",
			  thr, message, PL_diehook));
    if (PL_diehook) {
	S_vdie_common(aTHX_ message, *msglen, *utf8);
    }
    /* Cast because we're not changing function prototypes in maint, and this
       function isn't actually static.  */
    return (char *)  message;
}

d1122 2
a1123 2
    const char *message;
    const int was_in_eval = PL_in_eval;
d1133 1
a1133 1
    PL_restartop = die_where((char *)message, msglen);
d1171 1
a1171 1
    const char *message;
d1178 1
a1178 1
	PL_restartop = die_where((char *) message, msglen);
d1183 1
a1183 1
	message = SvPVx_const(ERRSV, msglen);
d1235 5
d1241 5
a1245 3
    SV * const msv = vmess(pat, args);
    const I32 utf8 = SvUTF8(msv);
    const char * const message = SvPV_const(msv, msglen);
d1249 1
a1249 5
	SV * const oldwarnhook = PL_warnhook;
	CV * cv;
	HV * stash;
	GV * gv;

a1259 2
	    SAVESPTR(PL_warnhook);
	    PL_warnhook = Nullsv;
d1314 1
a1314 1
    dTHX; 
d1335 1
a1335 1
	SV * const msv = vmess(pat, args);
d1337 2
a1338 2
	const char *message = SvPV_const(msv, msglen);
	const I32 utf8 = SvUTF8(msv);
d1348 1
a1348 1
	    PL_restartop = die_where((char *) message, msglen);
a1359 52
/* implements the ckWARN? macros */

bool
Perl_ckwarn(pTHX_ U32 w)
{
    return
	(
	       isLEXWARN_on
	    && PL_curcop->cop_warnings != pWARN_NONE
	    && (
		   PL_curcop->cop_warnings == pWARN_ALL
		|| isWARN_on(PL_curcop->cop_warnings, unpackWARN1(w))
		|| (unpackWARN2(w) &&
		     isWARN_on(PL_curcop->cop_warnings, unpackWARN2(w)))
		|| (unpackWARN3(w) &&
		     isWARN_on(PL_curcop->cop_warnings, unpackWARN3(w)))
		|| (unpackWARN4(w) &&
		     isWARN_on(PL_curcop->cop_warnings, unpackWARN4(w)))
		)
	)
	||
	(
	    isLEXWARN_off && PL_dowarn & G_WARN_ON
	)
	;
}

/* implements the ckWARN?_d macro */

bool
Perl_ckwarn_d(pTHX_ U32 w)
{
    return
	   isLEXWARN_off
	|| PL_curcop->cop_warnings == pWARN_ALL
	|| (
	      PL_curcop->cop_warnings != pWARN_NONE 
	   && (
		   isWARN_on(PL_curcop->cop_warnings, unpackWARN1(w))
	      || (unpackWARN2(w) &&
		   isWARN_on(PL_curcop->cop_warnings, unpackWARN2(w)))
	      || (unpackWARN3(w) &&
		   isWARN_on(PL_curcop->cop_warnings, unpackWARN3(w)))
	      || (unpackWARN4(w) &&
		   isWARN_on(PL_curcop->cop_warnings, unpackWARN4(w)))
	      )
	   )
	;
}



d1392 1
d1396 1
a1396 1
	    const int len = strlen(environ[j]);
d1425 2
a1426 10
#   if defined(__CYGWIN__) || defined(EPOC) || defined(SYMBIAN) 
#       if defined(HAS_UNSETENV)
        if (val == NULL) {
            (void)unsetenv(nam);
        } else {
            (void)setenv(nam, val, 1);
        }
#       else /* ! HAS_UNSETENV */
        (void)setenv(nam, val, 1);
#       endif /* HAS_UNSETENV */
d1428 10
a1437 23
#       if defined(HAS_UNSETENV)
        if (val == NULL) {
            (void)unsetenv(nam);
        } else {
            int nlen = strlen(nam);
            int vlen = strlen(val);
            char *new_env =
                (char*)safesysmalloc((nlen + vlen + 2) * sizeof(char));
            my_setenv_format(new_env, nam, nlen, val, vlen);
            (void)putenv(new_env);
        }
#       else /* ! HAS_UNSETENV */
        char *new_env;
        int nlen = strlen(nam), vlen;
        if (!val) {
	   val = "";
        }
        vlen = strlen(val);
        new_env = (char*)safesysmalloc((nlen + vlen + 2) * sizeof(char));
        /* all that work just for this */
        my_setenv_format(new_env, nam, nlen, val, vlen);
        (void)putenv(new_env);
#       endif /* HAS_UNSETENV */
d1448 1
a1448 1
Perl_my_setenv(pTHX_ char *nam, char *val)
d1451 1
a1451 2
    const int nlen = strlen(nam);
    int vlen;
d1457 1
a1457 1
    Newx(envstr, nlen+vlen+2, char);
d1469 1
a1469 2
    register I32 i;
    register const I32 len = strlen(nam);
d1503 1
a1503 1
    char * const retval = to;
d1524 1
a1524 1
    char * const retval = loc;
d1537 1
a1537 1
    char * const retval = loc;
d1550 2
a1551 2
    register const U8 *a = (const U8 *)s1;
    register const U8 *b = (const U8 *)s2;
d1555 1
a1555 1
        if ((tmp = *a++ - *b++))
d1676 1
a1676 1
#define HTOLE(name,type)					\
d1685 2
a1686 2
	    register I32 s = 0;					\
	    for (i = 0; i < sizeof(u.c); i++, s += 8) {		\
d1692 1
a1692 1
#define LETOH(name,type)					\
d1701 1
a1701 1
	    register I32 s = 0;					\
d1704 2
a1705 2
	    for (i = 0; i < sizeof(u.c); i++, s += 8) {		\
		n |= ((type)(u.c[i] & 0xFF)) << s;		\
a1709 51
/*
 * Big-endian byte order functions.
 */

#define HTOBE(name,type)					\
	type							\
	name (register type n)					\
	{							\
	    union {						\
		type value;					\
		char c[sizeof(type)];				\
	    } u;						\
	    register I32 i;					\
	    register I32 s = 8*(sizeof(u.c)-1);			\
	    for (i = 0; i < sizeof(u.c); i++, s -= 8) {		\
		u.c[i] = (n >> s) & 0xFF;			\
	    }							\
	    return u.value;					\
	}

#define BETOH(name,type)					\
	type							\
	name (register type n)					\
	{							\
	    union {						\
		type value;					\
		char c[sizeof(type)];				\
	    } u;						\
	    register I32 i;					\
	    register I32 s = 8*(sizeof(u.c)-1);			\
	    u.value = n;					\
	    n = 0;						\
	    for (i = 0; i < sizeof(u.c); i++, s -= 8) {		\
		n |= ((type)(u.c[i] & 0xFF)) << s;		\
	    }							\
	    return n;						\
	}

/*
 * If we just can't do it...
 */

#define NOT_AVAIL(name,type)                                    \
        type                                                    \
        name (register type n)                                  \
        {                                                       \
            Perl_croak_nocontext(#name "() not available");     \
            return n; /* not reached */                         \
        }


d1711 1
a1711 1
HTOLE(htovs,short)
d1714 1
a1714 1
HTOLE(htovl,long)
d1717 1
a1717 1
LETOH(vtohs,short)
d1720 1
a1720 88
LETOH(vtohl,long)
#endif

#ifdef PERL_NEED_MY_HTOLE16
# if U16SIZE == 2
HTOLE(Perl_my_htole16,U16)
# else
NOT_AVAIL(Perl_my_htole16,U16)
# endif
#endif
#ifdef PERL_NEED_MY_LETOH16
# if U16SIZE == 2
LETOH(Perl_my_letoh16,U16)
# else
NOT_AVAIL(Perl_my_letoh16,U16)
# endif
#endif
#ifdef PERL_NEED_MY_HTOBE16
# if U16SIZE == 2
HTOBE(Perl_my_htobe16,U16)
# else
NOT_AVAIL(Perl_my_htobe16,U16)
# endif
#endif
#ifdef PERL_NEED_MY_BETOH16
# if U16SIZE == 2
BETOH(Perl_my_betoh16,U16)
# else
NOT_AVAIL(Perl_my_betoh16,U16)
# endif
#endif

#ifdef PERL_NEED_MY_HTOLE32
# if U32SIZE == 4
HTOLE(Perl_my_htole32,U32)
# else
NOT_AVAIL(Perl_my_htole32,U32)
# endif
#endif
#ifdef PERL_NEED_MY_LETOH32
# if U32SIZE == 4
LETOH(Perl_my_letoh32,U32)
# else
NOT_AVAIL(Perl_my_letoh32,U32)
# endif
#endif
#ifdef PERL_NEED_MY_HTOBE32
# if U32SIZE == 4
HTOBE(Perl_my_htobe32,U32)
# else
NOT_AVAIL(Perl_my_htobe32,U32)
# endif
#endif
#ifdef PERL_NEED_MY_BETOH32
# if U32SIZE == 4
BETOH(Perl_my_betoh32,U32)
# else
NOT_AVAIL(Perl_my_betoh32,U32)
# endif
#endif

#ifdef PERL_NEED_MY_HTOLE64
# if U64SIZE == 8
HTOLE(Perl_my_htole64,U64)
# else
NOT_AVAIL(Perl_my_htole64,U64)
# endif
#endif
#ifdef PERL_NEED_MY_LETOH64
# if U64SIZE == 8
LETOH(Perl_my_letoh64,U64)
# else
NOT_AVAIL(Perl_my_letoh64,U64)
# endif
#endif
#ifdef PERL_NEED_MY_HTOBE64
# if U64SIZE == 8
HTOBE(Perl_my_htobe64,U64)
# else
NOT_AVAIL(Perl_my_htobe64,U64)
# endif
#endif
#ifdef PERL_NEED_MY_BETOH64
# if U64SIZE == 8
BETOH(Perl_my_betoh64,U64)
# else
NOT_AVAIL(Perl_my_betoh64,U64)
# endif
a1722 53
#ifdef PERL_NEED_MY_HTOLES
HTOLE(Perl_my_htoles,short)
#endif
#ifdef PERL_NEED_MY_LETOHS
LETOH(Perl_my_letohs,short)
#endif
#ifdef PERL_NEED_MY_HTOBES
HTOBE(Perl_my_htobes,short)
#endif
#ifdef PERL_NEED_MY_BETOHS
BETOH(Perl_my_betohs,short)
#endif

#ifdef PERL_NEED_MY_HTOLEI
HTOLE(Perl_my_htolei,int)
#endif
#ifdef PERL_NEED_MY_LETOHI
LETOH(Perl_my_letohi,int)
#endif
#ifdef PERL_NEED_MY_HTOBEI
HTOBE(Perl_my_htobei,int)
#endif
#ifdef PERL_NEED_MY_BETOHI
BETOH(Perl_my_betohi,int)
#endif

#ifdef PERL_NEED_MY_HTOLEL
HTOLE(Perl_my_htolel,long)
#endif
#ifdef PERL_NEED_MY_LETOHL
LETOH(Perl_my_letohl,long)
#endif
#ifdef PERL_NEED_MY_HTOBEL
HTOBE(Perl_my_htobel,long)
#endif
#ifdef PERL_NEED_MY_BETOHL
BETOH(Perl_my_betohl,long)
#endif

void
Perl_my_swabn(void *ptr, int n)
{
    register char *s = (char *)ptr;
    register char *e = s + (n-1);
    register char tc;

    for (n /= 2; n > 0; s++, e--, n--) {
      tc = *s;
      *s = *e;
      *e = tc;
    }
}

d1817 1
a1817 1
    SvIV_set(sv, pid);
d1864 1
a1864 1
    const I32 doexec = !(*cmd == '-' && cmd[1] == '\0');
d1922 2
d1940 1
d1970 1
a1970 1
    SvIV_set(sv, pid);
a2093 1
    return;
d2229 2
a2230 2
static int PL_sig_trapped; /* XXX signals are process-wide anyway, so we
			      ignore the implications of this for threading */
d2236 1
a2236 1
    PL_sig_trapped++;
d2250 1
a2250 1
    PL_sig_trapped = 0;
d2253 1
a2253 1
    if (PL_sig_trapped)
d2351 1
a2351 1
    I32 result = 0;
d2356 3
a2358 1
	char spid[TYPE_CHARS(IV)];
a2360 1
	    SV** svp;
d2374 2
a2375 1
		SV *sv = hv_iterval(PL_pidstatus,entry);
d2378 1
a2399 1
#if defined(HAS_WAITPID) && defined(HAS_WAITPID_RUNTIME)
a2400 1
#endif
a2411 1
#if defined(HAS_WAITPID) || defined(HAS_WAIT4)
a2412 1
#endif
d2421 1
d2425 1
a2425 1
    char spid[TYPE_CHARS(IV)];
d2430 1
a2430 1
    SvIV_set(sv, status);
d2508 1
a2508 1
	sv_setpvn(tmpsv, ".", 1);
d2511 1
a2511 1
    if (PerlLIO_stat(SvPVX_const(tmpsv), &tmpstatbuf1) < 0)
d2514 1
a2514 1
	sv_setpvn(tmpsv, ".", 1);
d2517 1
a2517 1
    if (PerlLIO_stat(SvPVX_const(tmpsv), &tmpstatbuf2) < 0)
d2525 1
a2525 2
Perl_find_script(pTHX_ char *scriptname, bool dosearch, char **search_ext,
		 I32 flags)
d2527 1
a2527 1
    const char *xfound = Nullch;
d2547 2
a2548 3
    const char *const exts[] = { SEARCH_EXTS };
    const char *const *const ext =
	search_ext ? (const char *const *const)search_ext : exts;
d2550 1
a2550 1
    const char *curext = Nullch;
a2551 1
    PERL_UNUSED_ARG(search_ext);
a2633 1
		/* FIXME? Convert to memcpy  */
d2688 1
a2688 1
#  if defined(atarist) || defined(__MINT__) || defined(DOSISH)
d2691 1
a2691 1
#  endif
a2696 2
	    /* FIXME? Convert to memcpy by storing previous strlen(scriptname)
	     */
d2748 3
a2750 3
	Safefree(xfailed);
	/* Cast because we're not changing function prototypes in maint.  */
	scriptname = (char *) xfound;
a2787 2
#else
    PERL_UNUSED_ARG(t);
d3071 1
a3071 1
#if defined(PERL_GLOBAL_STRUCT) && !defined(PERL_GLOBAL_STRUCT_PRIVATE)
d3082 1
a3082 1
 return (char **)PL_op_name;
d3088 1
a3088 1
 return (char **)PL_op_desc;
d3094 1
a3094 2
    /* Cast because we're not changing function prototypes in maint.  */
    return (char *) PL_no_modify;
d3100 1
a3100 1
 return (U32 *)PL_opargs;
d3113 1
a3113 1
    char * const env_trans = PerlEnv_getenv(env_elem);
d3124 1
a3124 1
    const MGVTBL* result = Null(MGVTBL*);
d3225 1
a3225 1
    return (MGVTBL*)result;
d3281 1
a3281 1
    const char * const func =
d3285 2
a3286 2
    const char * const pars = OP_IS_FILETEST(op) ? "" : "()";
    const char * const type = OP_IS_SOCKET(op)
d3289 5
a3293 1
    const char * const name = gv && isGV(gv) ? GvENAME(gv) : NULL;
d3297 1
a3297 1
	    const char * const direction = (op == OP_phoney_INPUT_ONLY) ? "in" : "out";
d3308 1
a3308 1
        const char *vile;
d3353 1
a3353 1
	const char *ctlp;
a3411 1
    const struct tm* my_tm;
d3413 1
a3413 5
    my_tm = localtime(&now);
    if (my_tm)
        Copy(my_tm, ptm, 1, struct tm);
#else
    PERL_UNUSED_ARG(ptm);
d3649 1
a3649 1
  Newx(buf, buflen, char);
d3669 2
a3670 2
    const int fmtlen = strlen(fmt);
    const int bufsize = fmtlen + buflen;
d3672 1
a3672 1
    Newx(buf, bufsize, char);
d3683 2
a3684 1
      Renew(buf, bufsize*2, char);
a3689 1
  return NULL;
d3737 2
a3738 1
	    sv_setpvn(sv, buf, strlen(buf));
d3751 2
a3752 1
    int pathlen=0;
a3766 1
	DIR *dir;
d3789 1
a3789 1
	    const int namelen = dp->d_namlen;
d3791 1
a3791 1
	    const int namelen = strlen(dp->d_name);
d3821 1
a3821 1
	    Move(SvPVX_const(sv), SvPVX(sv) + namelen + 1, pathlen, char);
d3843 1
a3843 1
	if (PerlDir_chdir(SvPVX_const(sv)) < 0) {
d4001 1
a4001 1
	const int save_errno = errno;
d4094 1
a4094 9
#ifdef ECONNABORTED
  errno = ECONNABORTED;	/* This would be the standard thing to do. */
#else
#  ifdef ECONNREFUSED
  errno = ECONNREFUSED;	/* E.g. Symbian does not have ECONNABORTED. */
#  else
  errno = ETIMEDOUT;	/* Desperation time. */
#  endif
#endif
a4134 1
    PERL_UNUSED_ARG(sv);
a4149 1
    PERL_UNUSED_ARG(sv);
a4165 1
    PERL_UNUSED_ARG(sv);
d4171 1
a4171 1
  const char *p = *popt;
d4217 1
a4217 2
  /* Cast because we're not changing function prototypes in maint.  */
  *popt = (char *) p;
d4275 1
a4275 1
    	if (PerlLIO_read(fd, (void*)&u, sizeof u) != sizeof u)
d4306 1
a4306 1
     const char *s = PerlEnv_getenv("PERL_HASH_SEED");
a4338 79

#ifdef USE_ITHREADS
bool
Perl_stashpv_hvname_match(pTHX_ const COP *c, const HV *hv)
{
    const char * const stashpv = CopSTASHPV(c);
    const char * const name = HvNAME_get(hv);

    if (stashpv == name)
	return TRUE;
    if (stashpv && name)
	if (strEQ(stashpv, name))
	    return TRUE;
    return FALSE;
}
#endif

void
Perl_my_clearenv(pTHX)
{
#if ! defined(PERL_MICRO)
#  if defined(PERL_IMPLICIT_SYS) || defined(WIN32)
    PerlEnv_clearenv();
#  else /* ! (PERL_IMPLICIT_SYS || WIN32) */
#    if defined(USE_ENVIRON_ARRAY)
#      if defined(USE_ITHREADS)
    /* only the parent thread can clobber the process environment */
    if (PL_curinterp == aTHX)
#      endif /* USE_ITHREADS */
    {
#      if ! defined(PERL_USE_SAFE_PUTENV)
    if ( !PL_use_safe_putenv) {
      I32 i;
      if (environ == PL_origenviron)
        environ = (char**)safesysmalloc(sizeof(char*));
      else
        for (i = 0; environ[i]; i++)
          (void)safesysfree(environ[i]);
    }
    environ[0] = NULL;
#      else /* PERL_USE_SAFE_PUTENV */
#        if defined(HAS_CLEARENV)
    (void)clearenv();
#        elif defined(HAS_UNSETENV)
    int bsiz = 80; /* Most envvar names will be shorter than this. */
    char *buf = (char*)safesysmalloc(bsiz * sizeof(char));
    while (*environ != NULL) {
      char *e = strchr(*environ, '=');
      int l = e ? e - *environ : strlen(*environ);
      if (bsiz < l + 1) {
        (void)safesysfree(buf);
        bsiz = l + 1;
        buf = (char*)safesysmalloc(bsiz * sizeof(char));
      } 
      strncpy(buf, *environ, l);
      *(buf + l) = '\0';
      (void)unsetenv(buf);
    }
    (void)safesysfree(buf);
#        else /* ! HAS_CLEARENV && ! HAS_UNSETENV */
    /* Just null environ and accept the leakage. */
    *environ = NULL;
#        endif /* HAS_CLEARENV || HAS_UNSETENV */
#      endif /* ! PERL_USE_SAFE_PUTENV */
    }
#    endif /* USE_ENVIRON_ARRAY */
#  endif /* PERL_IMPLICIT_SYS || WIN32 */
#endif /* PERL_MICRO */
}

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 noet:
 */
@


1.1.1.11
log
@import perl 5.10.0 from CPAN
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, by Larry Wall and others
a59 11
static char *
S_write_no_mem(pTHX)
{
    dVAR;
    /* Can't use PerlIO to write as it allocates memory */
    PerlLIO_write(PerlIO_fileno(Perl_error_log),
		  PL_no_mem, strlen(PL_no_mem));
    my_exit(1);
    NORETURN_FUNCTION_END;
}

a73 3
#ifdef PERL_TRACK_MEMPOOL
    size += sTHX;
#endif
d81 1
a81 22
    if (ptr != NULL) {
#ifdef PERL_TRACK_MEMPOOL
	struct perl_memory_debug_header *const header
	    = (struct perl_memory_debug_header *)ptr;
#endif

#ifdef PERL_POISON
	PoisonNew(((char *)ptr), size, char);
#endif

#ifdef PERL_TRACK_MEMPOOL
	header->interpreter = aTHX;
	/* Link us into the list.  */
	header->prev = &PL_memory_debug_header;
	header->next = PL_memory_debug_header.next;
	PL_memory_debug_header.next = header;
	header->next->prev = header;
#  ifdef PERL_POISON
	header->size = size;
#  endif
        ptr = (Malloc_t)((char*)ptr+sTHX);
#endif
a82 1
}
d84 1
a84 1
	return NULL;
d86 5
a90 1
	return write_no_mem();
a119 22
#ifdef PERL_TRACK_MEMPOOL
    where = (Malloc_t)((char*)where-sTHX);
    size += sTHX;
    {
	struct perl_memory_debug_header *const header
	    = (struct perl_memory_debug_header *)where;

	if (header->interpreter != aTHX) {
	    Perl_croak_nocontext("panic: realloc from wrong pool");
	}
	assert(header->next->prev == header);
	assert(header->prev->next == header);
#  ifdef PERL_POISON
	if (header->size > size) {
	    const MEM_SIZE freed_up = header->size - size;
	    char *start_of_freed = ((char *)where) + size;
	    PoisonFree(start_of_freed, freed_up, char);
	}
	header->size = size;
#  endif
    }
#endif
d130 1
a130 18
    if (ptr != NULL) {
#ifdef PERL_TRACK_MEMPOOL
	struct perl_memory_debug_header *const header
	    = (struct perl_memory_debug_header *)ptr;

#  ifdef PERL_POISON
	if (header->size < size) {
	    const MEM_SIZE fresh = size - header->size;
	    char *start_of_fresh = ((char *)ptr) + size;
	    PoisonNew(start_of_fresh, fresh, char);
	}
#  endif

	header->next->prev = header;
	header->prev->next = header;

        ptr = (Malloc_t)((char*)ptr+sTHX);
#endif
a131 1
    }
d133 1
a133 1
	return NULL;
d135 5
a139 1
	return write_no_mem();
d149 1
a149 1
#if defined(PERL_IMPLICIT_SYS) || defined(PERL_TRACK_MEMPOOL)
a150 2
#else
    dVAR;
a153 26
#ifdef PERL_TRACK_MEMPOOL
        where = (Malloc_t)((char*)where-sTHX);
	{
	    struct perl_memory_debug_header *const header
		= (struct perl_memory_debug_header *)where;

	    if (header->interpreter != aTHX) {
		Perl_croak_nocontext("panic: free from wrong pool");
	    }
	    if (!header->prev) {
		Perl_croak_nocontext("panic: duplicate free");
	    }
	    if (!(header->next) || header->next->prev != header
		|| header->prev->next != header) {
		Perl_croak_nocontext("panic: bad free");
	    }
	    /* Unlink us from the chain.  */
	    header->next->prev = header->prev;
	    header->prev->next = header->next;
#  ifdef PERL_POISON
	    PoisonNew(where, header->size, char);
#  endif
	    /* Trigger the duplicate free warning.  */
	    header->next = NULL;
	}
#endif
a164 1
    MEM_SIZE total_size = 0;
a165 11
    /* Even though calloc() for zero bytes is strange, be robust. */
    if (size && (count <= MEM_SIZE_MAX / size))
	total_size = size * count;
    else
	Perl_croak_nocontext(PL_memory_wrap);
#ifdef PERL_TRACK_MEMPOOL
    if (sTHX <= MEM_SIZE_MAX - (MEM_SIZE)total_size)
	total_size += sTHX;
    else
	Perl_croak_nocontext(PL_memory_wrap);
#endif
d167 1
a167 1
    if (total_size > 0xffff) {
d169 1
a169 1
		      "Allocation too large: %lx\n", total_size) FLUSH;
d177 2
a178 13
#ifdef PERL_TRACK_MEMPOOL
    /* Have to use malloc() because we've added some space for our tracking
       header.  */
    /* malloc(0) is non-portable. */
    ptr = (Malloc_t)PerlMem_malloc(total_size ? total_size : 1);
#else
    /* Use calloc() because it might save a memset() if the memory is fresh
       and clean from the OS.  */
    if (count && size)
	ptr = (Malloc_t)PerlMem_calloc(count, size);
    else /* calloc(0) is non-portable. */
	ptr = (Malloc_t)PerlMem_calloc(count ? count : 1, size ? size : 1);
#endif
d180 3
a182 20
    DEBUG_m(PerlIO_printf(Perl_debug_log, "0x%"UVxf": (%05ld) calloc %ld x %ld bytes\n",PTR2UV(ptr),(long)PL_an++,(long)count,(long)total_size));
    if (ptr != NULL) {
#ifdef PERL_TRACK_MEMPOOL
	{
	    struct perl_memory_debug_header *const header
		= (struct perl_memory_debug_header *)ptr;

	    memset((void*)ptr, 0, total_size);
	    header->interpreter = aTHX;
	    /* Link us into the list.  */
	    header->prev = &PL_memory_debug_header;
	    header->next = PL_memory_debug_header.next;
	    PL_memory_debug_header.next = header;
	    header->next->prev = header;
#  ifdef PERL_POISON
	    header->size = total_size;
#  endif
	    ptr = (Malloc_t)((char*)ptr+sTHX);
	}
#endif
d186 9
a194 2
	return NULL;
    return write_no_mem();
d231 1
a231 1
Perl_delimcpy(pTHX_ register char *to, register const char *toend, register const char *from, register const char *fromend, register int delim, I32 *retlen)
a233 2
    PERL_UNUSED_CONTEXT;

d236 3
a238 1
	    if (from[1] != delim) {
d242 1
a243 1
	    from++;
a262 1
    PERL_UNUSED_CONTEXT;
d275 3
a277 2
		return NULL;
	    if (*s != *x)
a278 3
	    else {
		s++;
		x++;
d284 1
a284 1
    return NULL;
d290 1
a290 1
Perl_ninstr(pTHX_ const char *big, const char *bigend, const char *little, const char *lend)
d292 20
a311 17
    PERL_UNUSED_CONTEXT;
    if (little >= lend)
        return (char*)big;
    {
        char first = *little++;
        const char *s, *x;
        bigend -= lend - little;
    OUTER:
        while (big <= bigend) {
            if (*big++ == first) {
                for (x=big,s=little; s < lend; x++,s++) {
                    if (*s != *x)
                        goto OUTER;
                }
                return (char*)(big-1);
            }
        }
d313 1
a313 1
    return NULL;
d323 1
a323 2
    register const char * const littleend = lend;
    PERL_UNUSED_CONTEXT;
d325 1
a325 1
    if (little >= littleend)
d334 2
a335 1
	    if (*s != *x)
a336 3
	    else {
		x++;
		s++;
d342 1
a342 1
    return NULL;
d345 2
a366 1
    dVAR;
d370 1
a370 1
    U32 rarest = 0;
d375 1
a375 1
	sv_catpvs(sv, "\n");		/* Taken into account in fbm_instr() */
d380 1
a382 4
    SvUPGRADE(sv, SVt_PVGV);
    SvIOK_off(sv);
    SvNOK_off(sv);
    SvVALID_on(sv);
d388 3
a390 4
	Sv_Grow(sv, len + 256 + PERL_FBM_TABLE_OFFSET);
	table
	    = (unsigned char*)(SvPVX_mutable(sv) + len + PERL_FBM_TABLE_OFFSET);
	s = table - 1 - PERL_FBM_TABLE_OFFSET;	/* last char */
d392 1
a399 2
    } else {
	Sv_Grow(sv, len + PERL_FBM_TABLE_OFFSET);
d401 2
a402 1
    sv_magic(sv, NULL, PERL_MAGIC_bm, NULL, 0);	/* deep magic */
a410 1
    BmFLAGS(sv) = (U8)flags;
d412 1
a412 1
    BmPREVIOUS(sv) = rarest;
d416 2
a417 2
    DEBUG_r(PerlIO_printf(Perl_debug_log, "rarest char %c at %lu\n",
			  BmRARE(sv),(unsigned long)BmPREVIOUS(sv)));
d428 1
a428 1
C<strend>.  It returns C<NULL> if the string can't be found.  The C<sv>
d452 1
a452 1
	return NULL;
d472 1
a472 1
	    return NULL;
d483 1
a483 1
	    return NULL;
d536 1
a536 1
	return NULL;
d551 1
a551 1
	return NULL;
d553 2
a554 2
    if (!SvVALID(littlestr)) {
	char * const b = ninstr((char*)big,(char*)bigend,
d565 1
a565 1
	    return NULL;
d570 2
a571 7
    /* Do actual FBM.  */
    if (littlelen > (STRLEN)(bigend - big))
	return NULL;

    {
	register const unsigned char * const table
	    = little + littlelen + PERL_FBM_TABLE_OFFSET;
d574 2
d608 1
a608 2
	if ( s == bigend
	     && (BmFLAGS(littlestr) & FBMcf_TAIL)
d612 1
a612 1
	return NULL;
a633 1
    dVAR;
a642 3
    assert(SvTYPE(littlestr) == SVt_PVGV);
    assert(SvVALID(littlestr));

d654 1
a654 1
	return NULL;
d674 1
a674 1
	return NULL;
d702 1
a702 1
	return NULL;
d713 1
a713 1
    return NULL;
a720 2
    PERL_UNUSED_CONTEXT;

a731 1
    dVAR;
a733 2
    PERL_UNUSED_CONTEXT;

a759 1
    PERL_UNUSED_CONTEXT;
d761 1
a761 1
	return NULL;
d765 2
a766 2
	Newx(newaddr, pvlen, char);
	return (char*)memcpy(newaddr, pv, pvlen);
d768 1
d778 2
a779 2
C<len> bytes from C<pv>, plus a trailing NUL byte. The memory allocated for
the new string can be freed with the C<Safefree()> function.
a787 1
    PERL_UNUSED_CONTEXT;
d815 1
a815 1
	return NULL;
d820 3
a822 21
	return write_no_mem();
    }
    return (char*)memcpy(newaddr, pv, pvlen);
}

/*
=for apidoc savesharedpvn

A version of C<savepvn()> which allocates the duplicate string in memory
which is shared between threads. (With the specific difference that a NULL
pointer is not acceptable)

=cut
*/
char *
Perl_savesharedpvn(pTHX_ const char *const pv, const STRLEN len)
{
    char *const newaddr = (char*)PerlMemShared_malloc(len + 1);
    assert(pv);
    if (!newaddr) {
	return write_no_mem();
d824 1
a824 2
    newaddr[len] = '\0';
    return (char*)memcpy(newaddr, pv, len);
d840 1
a840 1
    const char * const pv = SvPV_const(sv, len);
a853 1
    dVAR;
d858 1
a858 1
	return sv_2mortal(newSVpvs(""));
a867 1
    SvPV_set(sv, NULL);
d922 1
a922 1
    sv_vsetpvfn(sv, pat, strlen(pat), args, NULL, 0, NULL);
d951 2
a952 2
STATIC const COP*
S_closest_cop(pTHX_ const COP *cop, const OP *o)
a953 1
    dVAR;
d956 1
a956 2
    if (!o || o == PL_op)
	return cop;
d959 4
a962 3
	const OP *kid;
	for (kid = cUNOPo->op_first; kid; kid = kid->op_sibling) {
	    const COP *new_cop;
d968 1
a968 1
		cop = (const COP *)kid;
d973 1
a973 2
	    if (new_cop)
		return new_cop;
d979 1
a979 1
    return NULL;
d985 2
a986 2
    dVAR;
    SV * const sv = mess_alloc();
d988 1
a988 1
    sv_vsetpvfn(sv, pat, strlen(pat), args, NULL, 0, NULL);
d990 1
d999 1
a999 2
	if (!cop)
	    cop = PL_curcop;
d1004 1
a1004 4
	/* Seems that GvIO() can be untrustworthy during global destruction. */
	if (GvIO(PL_last_in_gv) && (SvTYPE(GvIOp(PL_last_in_gv)) == SVt_PVIO)
		&& IoLINES(GvIOp(PL_last_in_gv)))
	{
d1008 2
a1009 1
			   PL_last_in_gv == PL_argvgv ? "" : GvNAME(PL_last_in_gv),
d1013 5
a1017 3
	if (PL_dirty)
	    sv_catpvs(sv, " during global destruction");
	sv_catpvs(sv, ".\n");
a1024 1
    dVAR;
d1038 1
a1038 1
	PL_stderrgv = NULL;
d1068 1
a1068 1
/* Common code used by vcroak, vdie, vwarn and vwarner  */
d1070 4
a1073 2
STATIC bool
S_vdie_common(pTHX_ const char *message, STRLEN msglen, I32 utf8, bool warn)
a1074 1
    dVAR;
d1078 2
a1079 5
    SV **const hook = warn ? &PL_warnhook : &PL_diehook;
    /* sv_2cv might call Perl_croak() or Perl_warner() */
    SV * const oldhook = *hook;

    assert(oldhook);
d1081 1
d1083 3
a1085 3
    SAVESPTR(*hook);
    *hook = NULL;
    cv = sv_2cv(oldhook, &stash, &gv, 0);
d1093 1
a1093 5
	if (warn) {
	    SAVESPTR(*hook);
	    *hook = NULL;
	}
	if (warn || message) {
d1103 1
a1103 1
	PUSHSTACKi(warn ? PERLSI_WARNHOOK : PERLSI_DIEHOOK);
a1109 1
	return TRUE;
a1110 1
    return FALSE;
d1113 3
a1115 1
STATIC const char *
a1118 1
    dVAR;
d1133 1
a1133 1
	message = NULL;
d1138 1
a1138 1
			  (void*)thr, message, (void*)PL_diehook));
d1140 1
a1140 1
	S_vdie_common(aTHX_ message, *msglen, *utf8, FALSE);
d1142 3
a1144 1
    return message;
a1149 1
    dVAR;
d1157 1
a1157 1
			  (void*)thr, (void*)PL_curstack, (void*)PL_mainstack));
d1159 1
a1159 1
    message = vdie_croak_common(pat, args, &msglen, &utf8);
d1161 1
a1161 1
    PL_restartop = die_where(message, msglen);
d1165 1
a1165 1
	  (void*)thr, (void*)PL_restartop, was_in_eval, (void*)PL_top_env));
a1198 1
    dVAR;
d1206 1
a1206 1
	PL_restartop = die_where(message, msglen);
d1241 1
a1241 1
C<$@@> and then pass C<NULL> to croak():
d1245 1
a1245 1
   croak(NULL);
a1262 1
    dVAR;
d1269 31
a1299 1
	if (vdie_common(message, msglen, utf8, TRUE))
d1301 1
d1361 1
a1361 2
    dVAR;
    if (PL_warnhook == PERL_WARNHOOK_FATAL || ckDEAD(err)) {
d1364 1
a1364 1
	const char * const message = SvPV_const(msv, msglen);
d1367 3
d1372 1
a1372 1
	    S_vdie_common(aTHX_ message, msglen, utf8, FALSE);
d1375 1
a1375 1
	    PL_restartop = die_where(message, msglen);
a1391 1
    dVAR;
a1418 1
    dVAR;
d1437 1
a1437 15
/* Set buffer=NULL to get a new one.  */
STRLEN *
Perl_new_warnings_bitfield(pTHX_ STRLEN *buffer, const char *const bits,
			   STRLEN size) {
    const MEM_SIZE len_wanted = sizeof(STRLEN) + size;
    PERL_UNUSED_CONTEXT;

    buffer = (STRLEN*)
	(specialWARN(buffer) ?
	 PerlMemShared_malloc(len_wanted) :
	 PerlMemShared_realloc(buffer, len_wanted));
    buffer[0] = size;
    Copy(bits, (buffer + 1), size, char);
    return buffer;
}
d1453 1
a1453 1
Perl_my_setenv(pTHX_ const char *nam, const char *val)
a1454 1
  dVAR;
d1463 1
a1463 1
    register I32 i=setenv_getix(nam);          /* where does it go? */
d1466 14
a1479 16
    if (environ == PL_origenviron) {   /* need we copy environment? */
       I32 j;
       I32 max;
       char **tmpenv;

       max = i;
       while (environ[max])
           max++;
       tmpenv = (char**)safesysmalloc((max+2) * sizeof(char*));
       for (j=0; j<max; j++) {         /* copy environment */
           const int len = strlen(environ[j]);
           tmpenv[j] = (char*)safesysmalloc((len+1)*sizeof(char));
           Copy(environ[j], tmpenv[j], len+1, char);
       }
       tmpenv[max] = NULL;
       environ = tmpenv;               /* tell exec where it is now */
d1482 10
a1491 10
       safesysfree(environ[i]);
       while (environ[i]) {
           environ[i] = environ[i+1];
           i++;
	}
       return;
    }
    if (!environ[i]) {                 /* does not exist yet */
       environ = (char**)safesysrealloc(environ, (i+2) * sizeof(char*));
       environ[i+1] = NULL;    /* make sure it's null terminated */
d1494 7
a1500 7
       safesysfree(environ[i]);
       nlen = strlen(nam);
       vlen = strlen(val);

       environ[i] = (char*)safesysmalloc((nlen+vlen+2) * sizeof(char));
       /* all that work just for this */
       my_setenv_format(environ[i], nam, nlen, val, vlen);
d1503 1
a1503 1
#   if defined(__CYGWIN__) || defined(EPOC) || defined(__SYMBIAN32__) || defined(__riscos__)
d1518 3
a1520 3
	    const int nlen = strlen(nam);
	    const int vlen = strlen(val);
	    char * const new_env =
d1527 1
a1527 2
	const int nlen = strlen(nam);
	int vlen;
d1547 1
a1547 1
Perl_my_setenv(pTHX_ const char *nam, const char *val)
a1548 1
    dVAR;
d1554 1
a1554 1
       val = "";
d1567 1
a1567 1
Perl_setenv_getix(pTHX_ const char *nam)
a1570 1
    PERL_UNUSED_CONTEXT;
d1590 1
a1590 1
Perl_unlnk(pTHX_ const char *f)	/* unlink all versions of a file */
d1592 1
a1592 1
    I32 retries = 0;
d1594 2
a1595 3
    while (PerlLIO_unlink(f) >= 0)
	retries++;
    return retries ? 0 : -1;
a1663 12
/* This vsprintf replacement should generally never get used, since
   vsprintf was available in both System V and BSD 2.11.  (There may
   be some cross-compilation or embedded set-ups where it is needed,
   however.)

   If you encounter a problem in this function, it's probably a symptom
   that Configure failed to detect your system's vprintf() function.
   See the section on "item vsprintf" in the INSTALL file.

   This version may compile on systems with BSD-ish <stdio.h>,
   but probably won't on others.
*/
d1670 1
a1670 1
vsprintf(char *dest, const char *pat, void *args)
a1673 6
#if defined(STDIO_PTR_LVALUE) && defined(STDIO_CNT_LVALUE)
    FILE_ptr(&fakebuf) = (STDCHAR *) dest;
    FILE_cnt(&fakebuf) = 32767;
#else
    /* These probably won't compile -- If you really need
       this, you'll have to figure out some other method. */
a1675 1
#endif
d1681 1
a1681 9
#if defined(STDIO_PTR_LVALUE)
    *(FILE_ptr(&fakebuf)++) = '\0';
#else
    /* PerlIO has probably #defined away fputc, but we want it here. */
#  ifdef fputc
#    undef fputc  /* XXX Should really restore it later */
#  endif
    (void)fputc('\0', &fakebuf);
#endif
d1714 1
a1714 4
#if BYTEORDER == 0x1234 || BYTEORDER == 0x12345678
#if BYTEORDER == 0x12345678
    u.result = 0; 
#endif 
d1785 2
a1786 2
	    register U32 i;					\
	    register U32 s = 0;					\
d1801 2
a1802 2
	    register U32 i;					\
	    register U32 s = 0;					\
d1823 2
a1824 2
	    register U32 i;					\
	    register U32 s = 8*(sizeof(u.c)-1);			\
d1839 2
a1840 2
	    register U32 i;					\
	    register U32 s = 8*(sizeof(u.c)-1);			\
d2018 1
a2018 2
#if (!defined(DOSISH) || defined(HAS_FORK) || defined(AMIGAOS)) && !defined(OS2) && !defined(VMS) && !defined(__OPEN_VM) && !defined(EPOC) && !defined(MACOS_TRADITIONAL) && !defined(NETWARE) && !defined(__LIBCATAMOUNT__)
    dVAR;
d2034 1
a2034 1
	return NULL;
d2046 1
a2046 1
	    return NULL;
d2087 1
a2087 1
	do_aexec5(NULL, args-1, args-1+n, pp[1], did_pipes);
d2108 1
a2108 1
    SvUPGRADE(sv,SVt_IV);
d2114 1
a2114 2
	unsigned n = 0;
	SSize_t n1;
d2135 1
a2135 1
	    return NULL;
a2141 3
#  ifdef OS2	/* Same, without fork()ing and all extra overhead... */
    return my_syspopen4(aTHX_ Nullch, mode, n, args);
#  else
a2143 1
#  endif
d2148 1
a2148 1
#if (!defined(DOSISH) || defined(HAS_FORK) || defined(AMIGAOS)) && !defined(VMS) && !defined(__OPEN_VM) && !defined(EPOC) && !defined(MACOS_TRADITIONAL) && !defined(__LIBCATAMOUNT__)
d2150 1
a2150 1
Perl_my_popen(pTHX_ const char *cmd, const char *mode)
a2151 1
    dVAR;
d2173 1
a2173 1
	return NULL;
d2186 1
a2186 1
	    return NULL;
d2230 1
a2230 9

#ifdef PERLIO_USING_CRLF
   /* Since we circumvent IO layers when we manipulate low-level
      filedescriptors directly, need to manually switch to the
      default, binary, low-level mode; see PerlIOBuf_open(). */
   PerlLIO_setmode((*mode == 'r'), O_BINARY);
#endif 

	if ((tmpgv = gv_fetchpvs("$", GV_ADD|GV_NOTQUAL, SVt_PV))) {
a2238 1
#ifdef PERL_USES_PL_PIDSTATUS
d2240 1
a2240 2
#endif
	return NULL;
d2258 1
a2258 1
    SvUPGRADE(sv,SVt_IV);
d2263 1
a2263 2
	unsigned n = 0;
	SSize_t n1;
d2284 1
a2284 1
	    return NULL;
d2295 1
a2295 1
Perl_my_popen(pTHX_ const char *cmd, const char *mode)
d2308 1
a2308 1
Perl_my_popen(pTHX_ const char *cmd, const char *mode)
a2316 8
#else
#if defined(__LIBCATAMOUNT__)
PerlIO *
Perl_my_popen(pTHX_ const char *cmd, const char *mode)
{
    return NULL;
}
#endif
d2326 1
a2326 2
   dVAR;
#if defined(USE_ITHREADS)
d2339 1
a2339 2
    dVAR;
#if defined(USE_ITHREADS)
d2353 1
a2353 1
#if defined(USE_ITHREADS) && !defined(HAS_PTHREAD_ATFORK)
a2431 1
    dVAR;
d2437 1
a2437 1
	return (Sighandler_t) SIG_ERR;
d2440 1
a2440 1
    act.sa_handler = (void(*)(int))handler;
d2448 1
a2448 1
    if (signo == SIGCHLD && handler == (Sighandler_t) SIG_IGN)
d2452 1
a2452 1
    	return (Sighandler_t) SIG_ERR;
d2454 1
a2454 1
    	return (Sighandler_t) oact.sa_handler;
a2460 1
    PERL_UNUSED_CONTEXT;
d2463 1
a2463 1
	return (Sighandler_t) SIG_ERR;
d2465 1
a2465 1
	return (Sighandler_t) oact.sa_handler;
a2470 1
    dVAR;
d2479 1
a2479 1
    act.sa_handler = (void(*)(int))handler;
d2487 1
a2487 1
    if (signo == SIGCHLD && handler == (Sighandler_t) SIG_IGN)
a2495 1
    dVAR;
d2513 1
a2513 1
	return (Sighandler_t) SIG_ERR;
d2519 5
a2523 1
static Signal_t
a2525 1
    dVAR;
a2531 1
    dVAR;
d2537 1
a2537 1
	return (Sighandler_t) SIG_ERR;
d2557 1
a2557 1
    return (*save == (Sighandler_t) SIG_ERR) ? -1 : 0;
d2568 1
a2568 1
    return (PerlProc_signal(signo, *save) == (Sighandler_t) SIG_ERR) ? -1 : 0;
d2575 1
a2575 1
#if (!defined(DOSISH) || defined(HAS_FORK) || defined(AMIGAOS)) && !defined(VMS) && !defined(__OPEN_VM) && !defined(EPOC) && !defined(MACOS_TRADITIONAL) && !defined(__LIBCATAMOUNT__)
a2578 1
    dVAR;
d2586 3
d2606 3
d2617 3
a2619 3
    rsignal_save(SIGHUP,  (Sighandler_t) SIG_IGN, &hstat);
    rsignal_save(SIGINT,  (Sighandler_t) SIG_IGN, &istat);
    rsignal_save(SIGQUIT, (Sighandler_t) SIG_IGN, &qstat);
d2630 1
a2630 1
	SETERRNO(saved_errno, 0);
a2634 8
#else
#if defined(__LIBCATAMOUNT__)
I32
Perl_my_pclose(pTHX_ PerlIO *ptr)
{
    return -1;
}
#endif
d2637 1
a2637 1
#if  (!defined(DOSISH) || defined(OS2) || defined(WIN32) || defined(NETWARE)) && !defined(MACOS_TRADITIONAL) && !defined(__LIBCATAMOUNT__)
a2640 1
    dVAR;
d2644 1
a2644 1
#ifdef PERL_USES_PL_PIDSTATUS
d2646 2
d2649 3
a2651 3
	    /* The keys in PL_pidstatus are now the raw 4 (or 8) bytes of the
	       pid, rather than a string form.  */
	    SV * const * const svp = hv_fetch(PL_pidstatus,(const char*) &pid,sizeof(Pid_t),FALSE);
d2654 1
a2654 2
		(void)hv_delete(PL_pidstatus,(const char*) &pid,sizeof(Pid_t),
				G_DISCARD);
d2663 1
a2663 3
		SV * const sv = hv_iterval(PL_pidstatus,entry);
		I32 len;
		const char * const spid = hv_iterkey(entry,&len);
d2665 1
a2665 2
		assert (len == sizeof(Pid_t));
		memcpy((char *)&pid, spid, len);
d2667 2
a2668 8
		/* The hash iterator is currently on this entry, so simply
		   calling hv_delete would trigger the lazy delete, which on
		   aggregate does more work, beacuse next call to hv_iterinit()
		   would spot the flag, and have to call the delete routine,
		   while in the meantime any new entries can't re-use that
		   memory.  */
		hv_iterinit(PL_pidstatus);
		(void)hv_delete(PL_pidstatus,spid,len,G_DISCARD);
d2683 1
a2683 1
    result = wait4((pid==-1)?0:pid,statusp,flags,NULL);
d2686 1
a2686 1
#ifdef PERL_USES_PL_PIDSTATUS
a2710 1
#ifdef PERL_USES_PL_PIDSTATUS
d2715 1
d2717 3
a2719 2
    sv = *hv_fetch(PL_pidstatus,(const char*)&pid,sizeof(Pid_t),TRUE);
    SvUPGRADE(sv,SVt_IV);
a2722 1
#endif
d2736 2
a2737 2
    FILE * const f = PerlIO_findFILE(ptr);
    const I32 result = pclose(f);
d2749 1
a2749 1
    FILE * const f = PerlIO_findFILE(ptr);
d2761 1
a2761 2
    register const char * const frombase = from;
    PERL_UNUSED_CONTEXT;
d2779 1
a2779 1
Perl_same_dirent(pTHX_ const char *a, const char *b)
d2785 1
a2785 1
    SV * const tmpsv = sv_newmortal();
d2815 2
a2816 2
Perl_find_script(pTHX_ const char *scriptname, bool dosearch,
		 const char *const *const search_ext, I32 flags)
d2818 2
a2819 3
    dVAR;
    const char *xfound = NULL;
    char *xfailed = NULL;
a2823 1
    char *bufend;
d2838 3
a2840 2
    static const char *const exts[] = { SEARCH_EXTS };
    const char *const *const ext = search_ext ? search_ext : exts;
d2842 1
a2842 1
    const char *curext = NULL;
d2872 1
a2872 1
	int idx = 0, deftypes = 1;
d2875 1
a2875 1
	const int hasdir = !dosearch || (strpbrk(scriptname,":[</") != NULL);
d2878 1
a2878 1
	int idx = 0, deftypes = 1;
d2881 1
a2881 1
	const int hasdir = (strpbrk(scriptname,":[</") != NULL);
d2895 1
a2895 1
	    my_strlcat(tmpbuf, scriptname, sizeof(tmpbuf));
d2902 1
a2902 1
	const char *cur = scriptname;
d2927 2
a2928 2
		my_strlcpy(tmpbuf, scriptname, sizeof(tmpbuf));
		cur = tmpbuf;
d2931 1
a2931 1
		 && my_strlcpy(tmpbuf+len, ext[extidx++], sizeof(tmpbuf) - len));
d2948 3
a2950 3

	bufend = s + strlen(s);
	while (s < bufend) {
d2952 1
a2952 1
	    s = delimcpy(tmpbuf, tmpbuf + sizeof tmpbuf, s, bufend,
d2968 1
a2968 1
	    s = delimcpy(tmpbuf, tmpbuf + sizeof tmpbuf, s, bufend,
d2973 1
a2973 1
	    if (s < bufend)
d2991 3
a2993 1
	    (void)my_strlcpy(tmpbuf + len, scriptname, sizeof(tmpbuf) - len);
d3010 1
a3010 1
		    && my_strlcpy(tmpbuf+len, ext[extidx++], sizeof(tmpbuf) - len)
d3042 1
a3042 1
	    scriptname = NULL;
d3045 2
a3046 1
	scriptname = xfound;
d3048 1
a3048 1
    return (scriptname ? savepv(scriptname) : NULL);
d3056 1
a3056 2
    dVAR;
#if defined(USE_ITHREADS)
d3077 1
a3077 2
    dVAR;
#if defined(USE_ITHREADS)
d3091 278
d3380 1
a3380 2
    PERL_UNUSED_CONTEXT;
    return (char **)PL_op_name;
d3386 1
a3386 2
    PERL_UNUSED_CONTEXT;
    return (char **)PL_op_desc;
d3389 1
a3389 1
const char *
d3392 2
a3393 2
    PERL_UNUSED_CONTEXT;
    return PL_no_modify;
d3399 1
a3399 2
    PERL_UNUSED_CONTEXT;
    return (U32 *)PL_opargs;
d3405 1
a3405 3
    dVAR;
    PERL_UNUSED_CONTEXT;
    return (PPADDR_t*)PL_ppaddr;
a3412 1
    PERL_UNUSED_CONTEXT;
d3423 1
a3423 2
    const MGVTBL* result;
    PERL_UNUSED_CONTEXT;
d3459 3
d3489 5
a3522 3
    default:
	result = NULL;
	break;
d3578 1
a3578 1
Perl_report_evil_fh(pTHX_ const GV *gv, const IO *io, I32 op)
d3580 8
d3592 1
a3592 2
	    const char * const direction =
		(const char *)((op == OP_phoney_INPUT_ONLY) ? "in" : "out");
a3615 13
	    const char * const pars =
		(const char *)(OP_IS_FILETEST(op) ? "" : "()");
	    const char * const func =
		(const char *)
		(op == OP_READLINE   ? "readline"  :	/* "<HANDLE>" not nice */
		 op == OP_LEAVEWRITE ? "write" :		/* "write exit" not nice */
		 op < 0              ? "" :              /* handle phoney cases */
		 PL_op_desc[op]);
	    const char * const type =
		(const char *)
		(OP_IS_SOCKET(op) ||
		 (gv && io && IoTYPE(io) == IoTYPE_SOCKET) ?
		 "socket" : "filehandle");
a3727 1
    PERL_UNUSED_CONTEXT;
d3915 1
a3915 1
Perl_my_strftime(pTHX_ const char *fmt, int sec, int min, int hour, int mday, int mon, int year, int wday, int yday, int isdst)
d3970 1
a3970 1
    int bufsize = fmtlen + buflen;
d3983 1
a3983 2
      bufsize *= 2;
      Renew(buf, bufsize, char);
d4024 1
a4024 1
    dVAR;
d4037 1
a4037 1
	    sv_setpv(sv, buf);
d4053 1
a4053 1
    SvUPGRADE(sv, SVt_PV);
d4166 3
a4168 3
#define VERSION_MAX 0x7FFFFFFF
/*
=for apidoc scan_version
d4170 11
a4180 15
Returns a pointer to the next character after the parsed
version string, as well as upgrading the passed in SV to
an RV.

Function must be called with an already existing SV like

    sv = newSV(0);
    s = scan_version(s, SV *sv, bool qv);

Performs some preprocessing to the string to ensure that
it has the correct characteristics of a version.  Flags the
object if it contains an underscore (which denotes this
is an alpha version).  The boolean qv denotes that the version
should be interpreted as if it had multiple decimals, even if
it doesn't.
d4182 4
a4185 692
=cut
*/

const char *
Perl_scan_version(pTHX_ const char *s, SV *rv, bool qv)
{
    const char *start;
    const char *pos;
    const char *last;
    int saw_period = 0;
    int alpha = 0;
    int width = 3;
    bool vinf = FALSE;
    AV * const av = newAV();
    SV * const hv = newSVrv(rv, "version"); /* create an SV and upgrade the RV */
    (void)sv_upgrade(hv, SVt_PVHV); /* needs to be an HV type */

#ifndef NODEFAULT_SHAREKEYS
    HvSHAREKEYS_on(hv);         /* key-sharing on by default */
#endif

    while (isSPACE(*s)) /* leading whitespace is OK */
	s++;

    start = last = s;

    if (*s == 'v') {
	s++;  /* get past 'v' */
	qv = 1; /* force quoted version processing */
    }

    pos = s;

    /* pre-scan the input string to check for decimals/underbars */
    while ( *pos == '.' || *pos == '_' || isDIGIT(*pos) )
    {
	if ( *pos == '.' )
	{
	    if ( alpha )
		Perl_croak(aTHX_ "Invalid version format (underscores before decimal)");
	    saw_period++ ;
	    last = pos;
	}
	else if ( *pos == '_' )
	{
	    if ( alpha )
		Perl_croak(aTHX_ "Invalid version format (multiple underscores)");
	    alpha = 1;
	    width = pos - last - 1; /* natural width of sub-version */
	}
	pos++;
    }

    if ( alpha && !saw_period )
	Perl_croak(aTHX_ "Invalid version format (alpha without decimal)");

    if ( alpha && saw_period && width == 0 )
	Perl_croak(aTHX_ "Invalid version format (misplaced _ in number)");

    if ( saw_period > 1 )
	qv = 1; /* force quoted version processing */

    last = pos;
    pos = s;

    if ( qv )
	(void)hv_stores((HV *)hv, "qv", newSViv(qv));
    if ( alpha )
	(void)hv_stores((HV *)hv, "alpha", newSViv(alpha));
    if ( !qv && width < 3 )
	(void)hv_stores((HV *)hv, "width", newSViv(width));
    
    while (isDIGIT(*pos))
	pos++;
    if (!isALPHA(*pos)) {
	I32 rev;

	for (;;) {
	    rev = 0;
	    {
  		/* this is atoi() that delimits on underscores */
  		const char *end = pos;
  		I32 mult = 1;
		I32 orev;

		/* the following if() will only be true after the decimal
		 * point of a version originally created with a bare
		 * floating point number, i.e. not quoted in any way
		 */
 		if ( !qv && s > start && saw_period == 1 ) {
		    mult *= 100;
 		    while ( s < end ) {
			orev = rev;
 			rev += (*s - '0') * mult;
 			mult /= 10;
			if (   (PERL_ABS(orev) > PERL_ABS(rev)) 
			    || (PERL_ABS(rev) > VERSION_MAX )) {
			    if(ckWARN(WARN_OVERFLOW))
				Perl_warner(aTHX_ packWARN(WARN_OVERFLOW), 
				"Integer overflow in version %d",VERSION_MAX);
			    s = end - 1;
			    rev = VERSION_MAX;
			    vinf = 1;
			}
 			s++;
			if ( *s == '_' )
			    s++;
 		    }
  		}
 		else {
 		    while (--end >= s) {
			orev = rev;
 			rev += (*end - '0') * mult;
 			mult *= 10;
			if (   (PERL_ABS(orev) > PERL_ABS(rev)) 
			    || (PERL_ABS(rev) > VERSION_MAX )) {
			    if(ckWARN(WARN_OVERFLOW))
				Perl_warner(aTHX_ packWARN(WARN_OVERFLOW), 
				"Integer overflow in version");
			    end = s - 1;
			    rev = VERSION_MAX;
			    vinf = 1;
			}
 		    }
 		} 
  	    }

  	    /* Append revision */
	    av_push(av, newSViv(rev));
	    if ( vinf ) {
		s = last;
		break;
	    }
	    else if ( *pos == '.' )
		s = ++pos;
	    else if ( *pos == '_' && isDIGIT(pos[1]) )
		s = ++pos;
	    else if ( isDIGIT(*pos) )
		s = pos;
	    else {
		s = pos;
		break;
	    }
	    if ( qv ) {
		while ( isDIGIT(*pos) )
		    pos++;
	    }
	    else {
		int digits = 0;
		while ( ( isDIGIT(*pos) || *pos == '_' ) && digits < 3 ) {
		    if ( *pos != '_' )
			digits++;
		    pos++;
		}
	    }
	}
    }
    if ( qv ) { /* quoted versions always get at least three terms*/
	I32 len = av_len(av);
	/* This for loop appears to trigger a compiler bug on OS X, as it
	   loops infinitely. Yes, len is negative. No, it makes no sense.
	   Compiler in question is:
	   gcc version 3.3 20030304 (Apple Computer, Inc. build 1640)
	   for ( len = 2 - len; len > 0; len-- )
	   av_push((AV *)sv, newSViv(0));
	*/
	len = 2 - len;
	while (len-- > 0)
	    av_push(av, newSViv(0));
    }

    /* need to save off the current version string for later */
    if ( vinf ) {
	SV * orig = newSVpvn("v.Inf", sizeof("v.Inf")-1);
	(void)hv_stores((HV *)hv, "original", orig);
	(void)hv_stores((HV *)hv, "vinf", newSViv(1));
    }
    else if ( s > start ) {
	SV * orig = newSVpvn(start,s-start);
	if ( qv && saw_period == 1 && *start != 'v' ) {
	    /* need to insert a v to be consistent */
	    sv_insert(orig, 0, 0, "v", 1);
	}
	(void)hv_stores((HV *)hv, "original", orig);
    }
    else {
	(void)hv_stores((HV *)hv, "original", newSVpvn("0",1));
	av_push(av, newSViv(0));
    }

    /* And finally, store the AV in the hash */
    (void)hv_stores((HV *)hv, "version", newRV_noinc((SV *)av));

    /* fix RT#19517 - special case 'undef' as string */
    if ( *s == 'u' && strEQ(s,"undef") ) {
	s += 5;
    }

    return s;
}

/*
=for apidoc new_version

Returns a new version object based on the passed in SV:

    SV *sv = new_version(SV *ver);

Does not alter the passed in ver SV.  See "upg_version" if you
want to upgrade the SV.

=cut
*/

SV *
Perl_new_version(pTHX_ SV *ver)
{
    dVAR;
    SV * const rv = newSV(0);
    if ( sv_derived_from(ver,"version") ) /* can just copy directly */
    {
	I32 key;
	AV * const av = newAV();
	AV *sav;
	/* This will get reblessed later if a derived class*/
	SV * const hv = newSVrv(rv, "version"); 
	(void)sv_upgrade(hv, SVt_PVHV); /* needs to be an HV type */
#ifndef NODEFAULT_SHAREKEYS
	HvSHAREKEYS_on(hv);         /* key-sharing on by default */
#endif

	if ( SvROK(ver) )
	    ver = SvRV(ver);

	/* Begin copying all of the elements */
	if ( hv_exists((HV *)ver, "qv", 2) )
	    (void)hv_stores((HV *)hv, "qv", newSViv(1));

	if ( hv_exists((HV *)ver, "alpha", 5) )
	    (void)hv_stores((HV *)hv, "alpha", newSViv(1));
	
	if ( hv_exists((HV*)ver, "width", 5 ) )
	{
	    const I32 width = SvIV(*hv_fetchs((HV*)ver, "width", FALSE));
	    (void)hv_stores((HV *)hv, "width", newSViv(width));
	}

	if ( hv_exists((HV*)ver, "original", 8 ) )
	{
	    SV * pv = *hv_fetchs((HV*)ver, "original", FALSE);
	    (void)hv_stores((HV *)hv, "original", newSVsv(pv));
	}

	sav = (AV *)SvRV(*hv_fetchs((HV*)ver, "version", FALSE));
	/* This will get reblessed later if a derived class*/
	for ( key = 0; key <= av_len(sav); key++ )
	{
	    const I32 rev = SvIV(*av_fetch(sav, key, FALSE));
	    av_push(av, newSViv(rev));
	}

	(void)hv_stores((HV *)hv, "version", newRV_noinc((SV *)av));
	return rv;
    }
#ifdef SvVOK
    {
	const MAGIC* const mg = SvVSTRING_mg(ver);
	if ( mg ) { /* already a v-string */
	    const STRLEN len = mg->mg_len;
	    char * const version = savepvn( (const char*)mg->mg_ptr, len);
	    sv_setpvn(rv,version,len);
	    /* this is for consistency with the pure Perl class */
	    if ( *version != 'v' ) 
		sv_insert(rv, 0, 0, "v", 1);
	    Safefree(version);
	}
	else {
#endif
	sv_setsv(rv,ver); /* make a duplicate */
#ifdef SvVOK
	}
    }
#endif
    return upg_version(rv, FALSE);
}

/*
=for apidoc upg_version

In-place upgrade of the supplied SV to a version object.

    SV *sv = upg_version(SV *sv, bool qv);

Returns a pointer to the upgraded SV.  Set the boolean qv if you want
to force this SV to be interpreted as an "extended" version.

=cut
*/

SV *
Perl_upg_version(pTHX_ SV *ver, bool qv)
{
    const char *version, *s;
#ifdef SvVOK
    const MAGIC *mg;
#endif

    if ( SvNOK(ver) && !( SvPOK(ver) && sv_len(ver) == 3 ) )
    {
	/* may get too much accuracy */ 
	char tbuf[64];
#ifdef USE_LOCALE_NUMERIC
	char *loc = setlocale(LC_NUMERIC, "C");
#endif
	STRLEN len = my_snprintf(tbuf, sizeof(tbuf), "%.9"NVff, SvNVX(ver));
#ifdef USE_LOCALE_NUMERIC
	setlocale(LC_NUMERIC, loc);
#endif
	while (tbuf[len-1] == '0' && len > 0) len--;
	if ( tbuf[len-1] == '.' ) len--; /* eat the trailing decimal */
	version = savepvn(tbuf, len);
    }
#ifdef SvVOK
    else if ( (mg = SvVSTRING_mg(ver)) ) { /* already a v-string */
	version = savepvn( (const char*)mg->mg_ptr,mg->mg_len );
	qv = 1;
    }
#endif
    else /* must be a string or something like a string */
    {
	STRLEN len;
	version = savepv(SvPV(ver,len));
#ifndef SvVOK
#  if PERL_VERSION > 5
	/* This will only be executed for 5.6.0 - 5.8.0 inclusive */
	if ( len == 3 && !instr(version,".") && !instr(version,"_") ) {
	    /* may be a v-string */
	    SV * const nsv = sv_newmortal();
	    const char *nver;
	    const char *pos;
	    int saw_period = 0;
	    sv_setpvf(nsv,"v%vd",ver);
	    pos = nver = savepv(SvPV_nolen(nsv));

	    /* scan the resulting formatted string */
	    pos++; /* skip the leading 'v' */
	    while ( *pos == '.' || isDIGIT(*pos) ) {
		if ( *pos == '.' )
		    saw_period++ ;
		pos++;
	    }

	    /* is definitely a v-string */
	    if ( saw_period == 2 ) {	
		Safefree(version);
		version = nver;
	    }
	}
#  endif
#endif
    }

    s = scan_version(version, ver, qv);
    if ( *s != '\0' ) 
	if(ckWARN(WARN_MISC))
	    Perl_warner(aTHX_ packWARN(WARN_MISC), 
		"Version string '%s' contains invalid data; "
		"ignoring: '%s'", version, s);
    Safefree(version);
    return ver;
}

/*
=for apidoc vverify

Validates that the SV contains a valid version object.

    bool vverify(SV *vobj);

Note that it only confirms the bare minimum structure (so as not to get
confused by derived classes which may contain additional hash entries):

=over 4

=item * The SV contains a [reference to a] hash

=item * The hash contains a "version" key

=item * The "version" key has [a reference to] an AV as its value

=back

=cut
*/

bool
Perl_vverify(pTHX_ SV *vs)
{
    SV *sv;
    if ( SvROK(vs) )
	vs = SvRV(vs);

    /* see if the appropriate elements exist */
    if ( SvTYPE(vs) == SVt_PVHV
	 && hv_exists((HV*)vs, "version", 7)
	 && (sv = SvRV(*hv_fetchs((HV*)vs, "version", FALSE)))
	 && SvTYPE(sv) == SVt_PVAV )
	return TRUE;
    else
	return FALSE;
}

/*
=for apidoc vnumify

Accepts a version object and returns the normalized floating
point representation.  Call like:

    sv = vnumify(rv);

NOTE: you can pass either the object directly or the SV
contained within the RV.

=cut
*/

SV *
Perl_vnumify(pTHX_ SV *vs)
{
    I32 i, len, digit;
    int width;
    bool alpha = FALSE;
    SV * const sv = newSV(0);
    AV *av;
    if ( SvROK(vs) )
	vs = SvRV(vs);

    if ( !vverify(vs) )
	Perl_croak(aTHX_ "Invalid version object");

    /* see if various flags exist */
    if ( hv_exists((HV*)vs, "alpha", 5 ) )
	alpha = TRUE;
    if ( hv_exists((HV*)vs, "width", 5 ) )
	width = SvIV(*hv_fetchs((HV*)vs, "width", FALSE));
    else
	width = 3;


    /* attempt to retrieve the version array */
    if ( !(av = (AV *)SvRV(*hv_fetchs((HV*)vs, "version", FALSE)) ) ) {
	sv_catpvs(sv,"0");
	return sv;
    }

    len = av_len(av);
    if ( len == -1 )
    {
	sv_catpvs(sv,"0");
	return sv;
    }

    digit = SvIV(*av_fetch(av, 0, 0));
    Perl_sv_setpvf(aTHX_ sv, "%d.", (int)PERL_ABS(digit));
    for ( i = 1 ; i < len ; i++ )
    {
	digit = SvIV(*av_fetch(av, i, 0));
	if ( width < 3 ) {
	    const int denom = (width == 2 ? 10 : 100);
	    const div_t term = div((int)PERL_ABS(digit),denom);
	    Perl_sv_catpvf(aTHX_ sv, "%0*d_%d", width, term.quot, term.rem);
	}
	else {
	    Perl_sv_catpvf(aTHX_ sv, "%0*d", width, (int)digit);
	}
    }

    if ( len > 0 )
    {
	digit = SvIV(*av_fetch(av, len, 0));
	if ( alpha && width == 3 ) /* alpha version */
	    sv_catpvs(sv,"_");
	Perl_sv_catpvf(aTHX_ sv, "%0*d", width, (int)digit);
    }
    else /* len == 0 */
    {
	sv_catpvs(sv, "000");
    }
    return sv;
}

/*
=for apidoc vnormal

Accepts a version object and returns the normalized string
representation.  Call like:

    sv = vnormal(rv);

NOTE: you can pass either the object directly or the SV
contained within the RV.

=cut
*/

SV *
Perl_vnormal(pTHX_ SV *vs)
{
    I32 i, len, digit;
    bool alpha = FALSE;
    SV * const sv = newSV(0);
    AV *av;
    if ( SvROK(vs) )
	vs = SvRV(vs);

    if ( !vverify(vs) )
	Perl_croak(aTHX_ "Invalid version object");

    if ( hv_exists((HV*)vs, "alpha", 5 ) )
	alpha = TRUE;
    av = (AV *)SvRV(*hv_fetchs((HV*)vs, "version", FALSE));

    len = av_len(av);
    if ( len == -1 )
    {
	sv_catpvs(sv,"");
	return sv;
    }
    digit = SvIV(*av_fetch(av, 0, 0));
    Perl_sv_setpvf(aTHX_ sv, "v%"IVdf, (IV)digit);
    for ( i = 1 ; i < len ; i++ ) {
	digit = SvIV(*av_fetch(av, i, 0));
	Perl_sv_catpvf(aTHX_ sv, ".%"IVdf, (IV)digit);
    }

    if ( len > 0 )
    {
	/* handle last digit specially */
	digit = SvIV(*av_fetch(av, len, 0));
	if ( alpha )
	    Perl_sv_catpvf(aTHX_ sv, "_%"IVdf, (IV)digit);
	else
	    Perl_sv_catpvf(aTHX_ sv, ".%"IVdf, (IV)digit);
    }

    if ( len <= 2 ) { /* short version, must be at least three */
	for ( len = 2 - len; len != 0; len-- )
	    sv_catpvs(sv,".0");
    }
    return sv;
}

/*
=for apidoc vstringify

In order to maintain maximum compatibility with earlier versions
of Perl, this function will return either the floating point
notation or the multiple dotted notation, depending on whether
the original version contained 1 or more dots, respectively

=cut
*/

SV *
Perl_vstringify(pTHX_ SV *vs)
{
    SV *pv;
    if ( SvROK(vs) )
	vs = SvRV(vs);
    
    if ( !vverify(vs) )
	Perl_croak(aTHX_ "Invalid version object");

    pv = *hv_fetchs((HV*)vs, "original", FALSE);
    if ( SvPOK(pv) ) 
	return newSVsv(pv);
    else
	return &PL_sv_undef;
}

/*
=for apidoc vcmp

Version object aware cmp.  Both operands must already have been 
converted into version objects.

=cut
*/

int
Perl_vcmp(pTHX_ SV *lhv, SV *rhv)
{
    I32 i,l,m,r,retval;
    bool lalpha = FALSE;
    bool ralpha = FALSE;
    I32 left = 0;
    I32 right = 0;
    AV *lav, *rav;
    if ( SvROK(lhv) )
	lhv = SvRV(lhv);
    if ( SvROK(rhv) )
	rhv = SvRV(rhv);

    if ( !vverify(lhv) )
	Perl_croak(aTHX_ "Invalid version object");

    if ( !vverify(rhv) )
	Perl_croak(aTHX_ "Invalid version object");

    /* get the left hand term */
    lav = (AV *)SvRV(*hv_fetchs((HV*)lhv, "version", FALSE));
    if ( hv_exists((HV*)lhv, "alpha", 5 ) )
	lalpha = TRUE;

    /* and the right hand term */
    rav = (AV *)SvRV(*hv_fetchs((HV*)rhv, "version", FALSE));
    if ( hv_exists((HV*)rhv, "alpha", 5 ) )
	ralpha = TRUE;

    l = av_len(lav);
    r = av_len(rav);
    m = l < r ? l : r;
    retval = 0;
    i = 0;
    while ( i <= m && retval == 0 )
    {
	left  = SvIV(*av_fetch(lav,i,0));
	right = SvIV(*av_fetch(rav,i,0));
	if ( left < right  )
	    retval = -1;
	if ( left > right )
	    retval = +1;
	i++;
    }

    /* tiebreaker for alpha with identical terms */
    if ( retval == 0 && l == r && left == right && ( lalpha || ralpha ) )
    {
	if ( lalpha && !ralpha )
	{
	    retval = -1;
	}
	else if ( ralpha && !lalpha)
	{
	    retval = +1;
	}
    }

    if ( l != r && retval == 0 ) /* possible match except for trailing 0's */
    {
	if ( l < r )
	{
	    while ( i <= r && retval == 0 )
	    {
		if ( SvIV(*av_fetch(rav,i,0)) != 0 )
		    retval = -1; /* not a match after all */
		i++;
	    }
	}
	else
	{
	    while ( i <= l && retval == 0 )
	    {
		if ( SvIV(*av_fetch(lav,i,0)) != 0 )
		    retval = +1; /* not a match after all */
		i++;
	    }
	}
    }
    return retval;
}

#if !defined(HAS_SOCKETPAIR) && defined(HAS_SOCKET) && defined(AF_INET) && defined(PF_INET) && defined(SOCK_DGRAM) && defined(HAS_SELECT)
#   define EMULATE_SOCKETPAIR_UDP
#endif

#ifdef EMULATE_SOCKETPAIR_UDP
static int
S_socketpair_udp (int fd[2]) {
    dTHX;
    /* Fake a datagram socketpair using UDP to localhost.  */
    int sockets[2] = {-1, -1};
    struct sockaddr_in addresses[2];
    int i;
    Sock_size_t size = sizeof(struct sockaddr_in);
    unsigned short port;
    int got;

    memset(&addresses, 0, sizeof(addresses));
    i = 1;
    do {
	sockets[i] = PerlSock_socket(AF_INET, SOCK_DGRAM, PF_INET);
d4245 2
a4246 2
	FD_SET((unsigned int)sockets[0], &rset);
	FD_SET((unsigned int)sockets[1], &rset);
d4404 1
a4404 1
	const int save_errno = errno;
d4433 2
a4434 3
Or "locks" it. Or "unlocks" it. In other words, ignores its single SV argument.
Exists to avoid test for a NULL function pointer and because it could
potentially warn under some level of strict-ness.
a4441 1
    PERL_UNUSED_CONTEXT;
d4446 15
d4462 2
a4463 1
=for apidoc sv_destroyable
d4465 3
a4467 4
Dummy routine which reports that object can be destroyed when there is no
sharing module present.  It ignores its single SV argument, and returns
'true'.  Exists to avoid test for a NULL function pointer and because it
could potentially warn under some level of strict-ness.
d4472 2
a4473 2
bool
Perl_sv_destroyable(pTHX_ SV *sv)
a4474 1
    PERL_UNUSED_CONTEXT;
a4475 1
    return TRUE;
d4479 1
a4479 1
Perl_parse_unicode_opts(pTHX_ const char **popt)
d4487 1
a4487 2
	    while (isDIGIT(*p))
		p++;
a4511 2
		 case PERL_UNICODE_UTF8CACHEASSERT:
		      opt |= PERL_UNICODE_UTF8CACHEASSERT_FLAG; break;
d4527 2
a4528 1
  *popt = p;
a4535 1
    dVAR;
a4616 1
    dVAR;
d4621 1
a4621 2
	while (isSPACE(*s))
	    s++;
a4656 1
    PERL_UNUSED_CONTEXT;
a4666 339

#ifdef PERL_GLOBAL_STRUCT

#define PERL_GLOBAL_STRUCT_INIT
#include "opcode.h" /* the ppaddr and check */

struct perl_vars *
Perl_init_global_struct(pTHX)
{
    struct perl_vars *plvarsp = NULL;
# ifdef PERL_GLOBAL_STRUCT
    const IV nppaddr = sizeof(Gppaddr)/sizeof(Perl_ppaddr_t);
    const IV ncheck  = sizeof(Gcheck) /sizeof(Perl_check_t);
#  ifdef PERL_GLOBAL_STRUCT_PRIVATE
    /* PerlMem_malloc() because can't use even safesysmalloc() this early. */
    plvarsp = (struct perl_vars*)PerlMem_malloc(sizeof(struct perl_vars));
    if (!plvarsp)
        exit(1);
#  else
    plvarsp = PL_VarsPtr;
#  endif /* PERL_GLOBAL_STRUCT_PRIVATE */
#  undef PERLVAR
#  undef PERLVARA
#  undef PERLVARI
#  undef PERLVARIC
#  undef PERLVARISC
#  define PERLVAR(var,type) /**/
#  define PERLVARA(var,n,type) /**/
#  define PERLVARI(var,type,init) plvarsp->var = init;
#  define PERLVARIC(var,type,init) plvarsp->var = init;
#  define PERLVARISC(var,init) Copy(init, plvarsp->var, sizeof(init), char);
#  include "perlvars.h"
#  undef PERLVAR
#  undef PERLVARA
#  undef PERLVARI
#  undef PERLVARIC
#  undef PERLVARISC
#  ifdef PERL_GLOBAL_STRUCT
    plvarsp->Gppaddr =
	(Perl_ppaddr_t*)
	PerlMem_malloc(nppaddr * sizeof(Perl_ppaddr_t));
    if (!plvarsp->Gppaddr)
        exit(1);
    plvarsp->Gcheck  =
	(Perl_check_t*)
	PerlMem_malloc(ncheck  * sizeof(Perl_check_t));
    if (!plvarsp->Gcheck)
        exit(1);
    Copy(Gppaddr, plvarsp->Gppaddr, nppaddr, Perl_ppaddr_t); 
    Copy(Gcheck,  plvarsp->Gcheck,  ncheck,  Perl_check_t); 
#  endif
#  ifdef PERL_SET_VARS
    PERL_SET_VARS(plvarsp);
#  endif
# undef PERL_GLOBAL_STRUCT_INIT
# endif
    return plvarsp;
}

#endif /* PERL_GLOBAL_STRUCT */

#ifdef PERL_GLOBAL_STRUCT

void
Perl_free_global_struct(pTHX_ struct perl_vars *plvarsp)
{
# ifdef PERL_GLOBAL_STRUCT
#  ifdef PERL_UNSET_VARS
    PERL_UNSET_VARS(plvarsp);
#  endif
    free(plvarsp->Gppaddr);
    free(plvarsp->Gcheck);
#  ifdef PERL_GLOBAL_STRUCT_PRIVATE
    free(plvarsp);
#  endif
# endif
}

#endif /* PERL_GLOBAL_STRUCT */

#ifdef PERL_MEM_LOG

/*
 * PERL_MEM_LOG: the Perl_mem_log_..() will be compiled.
 *
 * PERL_MEM_LOG_ENV: if defined, during run time the environment
 * variable PERL_MEM_LOG will be consulted, and if the integer value
 * of that is true, the logging will happen.  (The default is to
 * always log if the PERL_MEM_LOG define was in effect.)
 */

/*
 * PERL_MEM_LOG_SPRINTF_BUF_SIZE: size of a (stack-allocated) buffer
 * the Perl_mem_log_...() will use (either via sprintf or snprintf).
 */
#define PERL_MEM_LOG_SPRINTF_BUF_SIZE 128

/*
 * PERL_MEM_LOG_FD: the file descriptor the Perl_mem_log_...() will
 * log to.  You can also define in compile time PERL_MEM_LOG_ENV_FD,
 * in which case the environment variable PERL_MEM_LOG_FD will be
 * consulted for the file descriptor number to use.
 */
#ifndef PERL_MEM_LOG_FD
#  define PERL_MEM_LOG_FD 2 /* If STDERR is too boring for you. */
#endif

Malloc_t
Perl_mem_log_alloc(const UV n, const UV typesize, const char *typename, Malloc_t newalloc, const char *filename, const int linenumber, const char *funcname)
{
#ifdef PERL_MEM_LOG_STDERR
# if defined(PERL_MEM_LOG_ENV) || defined(PERL_MEM_LOG_ENV_FD)
    char *s;
# endif
# ifdef PERL_MEM_LOG_ENV
    s = getenv("PERL_MEM_LOG");
    if (s ? atoi(s) : 0)
# endif
    {
	/* We can't use SVs or PerlIO for obvious reasons,
	 * so we'll use stdio and low-level IO instead. */
	char buf[PERL_MEM_LOG_SPRINTF_BUF_SIZE];
# ifdef PERL_MEM_LOG_TIMESTAMP
	struct timeval tv;
#   ifdef HAS_GETTIMEOFDAY
	gettimeofday(&tv, 0);
#   endif
	/* If there are other OS specific ways of hires time than
	 * gettimeofday() (see ext/Time/HiRes), the easiest way is
	 * probably that they would be used to fill in the struct
	 * timeval. */
# endif
	{
	    const STRLEN len =
		my_snprintf(buf,
			    sizeof(buf),
#  ifdef PERL_MEM_LOG_TIMESTAMP
			    "%10d.%06d: "
# endif
			    "alloc: %s:%d:%s: %"IVdf" %"UVuf
			    " %s = %"IVdf": %"UVxf"\n",
#  ifdef PERL_MEM_LOG_TIMESTAMP
			    (int)tv.tv_sec, (int)tv.tv_usec,
# endif
			    filename, linenumber, funcname, n, typesize,
			    typename, n * typesize, PTR2UV(newalloc));
# ifdef PERL_MEM_LOG_ENV_FD
	    s = PerlEnv_getenv("PERL_MEM_LOG_FD");
	    PerlLIO_write(s ? atoi(s) : PERL_MEM_LOG_FD, buf, len);
# else
	    PerlLIO_write(PERL_MEM_LOG_FD, buf, len);
#endif
	}
    }
#endif
    return newalloc;
}

Malloc_t
Perl_mem_log_realloc(const UV n, const UV typesize, const char *typename, Malloc_t oldalloc, Malloc_t newalloc, const char *filename, const int linenumber, const char *funcname)
{
#ifdef PERL_MEM_LOG_STDERR
# if defined(PERL_MEM_LOG_ENV) || defined(PERL_MEM_LOG_ENV_FD)
    char *s;
# endif
# ifdef PERL_MEM_LOG_ENV
    s = PerlEnv_getenv("PERL_MEM_LOG");
    if (s ? atoi(s) : 0)
# endif
    {
	/* We can't use SVs or PerlIO for obvious reasons,
	 * so we'll use stdio and low-level IO instead. */
	char buf[PERL_MEM_LOG_SPRINTF_BUF_SIZE];
#  ifdef PERL_MEM_LOG_TIMESTAMP
	struct timeval tv;
	gettimeofday(&tv, 0);
# endif
	{
	    const STRLEN len =
		my_snprintf(buf,
			    sizeof(buf),
#  ifdef PERL_MEM_LOG_TIMESTAMP
			    "%10d.%06d: "
# endif
			    "realloc: %s:%d:%s: %"IVdf" %"UVuf
			    " %s = %"IVdf": %"UVxf" -> %"UVxf"\n",
#  ifdef PERL_MEM_LOG_TIMESTAMP
			    (int)tv.tv_sec, (int)tv.tv_usec,
# endif
			    filename, linenumber, funcname, n, typesize,
			    typename, n * typesize, PTR2UV(oldalloc),
			    PTR2UV(newalloc));
# ifdef PERL_MEM_LOG_ENV_FD
	    s = PerlEnv_getenv("PERL_MEM_LOG_FD");
	    PerlLIO_write(s ? atoi(s) : PERL_MEM_LOG_FD, buf, len);
# else
	    PerlLIO_write(PERL_MEM_LOG_FD, buf, len);
# endif
	}
    }
#endif
    return newalloc;
}

Malloc_t
Perl_mem_log_free(Malloc_t oldalloc, const char *filename, const int linenumber, const char *funcname)
{
#ifdef PERL_MEM_LOG_STDERR
# if defined(PERL_MEM_LOG_ENV) || defined(PERL_MEM_LOG_ENV_FD)
    char *s;
# endif
# ifdef PERL_MEM_LOG_ENV
    s = PerlEnv_getenv("PERL_MEM_LOG");
    if (s ? atoi(s) : 0)
# endif
    {
	/* We can't use SVs or PerlIO for obvious reasons,
	 * so we'll use stdio and low-level IO instead. */
	char buf[PERL_MEM_LOG_SPRINTF_BUF_SIZE];
#  ifdef PERL_MEM_LOG_TIMESTAMP
	struct timeval tv;
	gettimeofday(&tv, 0);
# endif
	{
	    const STRLEN len =
		my_snprintf(buf,
			    sizeof(buf),
#  ifdef PERL_MEM_LOG_TIMESTAMP
			    "%10d.%06d: "
# endif
			    "free: %s:%d:%s: %"UVxf"\n",
#  ifdef PERL_MEM_LOG_TIMESTAMP
			    (int)tv.tv_sec, (int)tv.tv_usec,
# endif
			    filename, linenumber, funcname,
			    PTR2UV(oldalloc));
# ifdef PERL_MEM_LOG_ENV_FD
	    s = PerlEnv_getenv("PERL_MEM_LOG_FD");
	    PerlLIO_write(s ? atoi(s) : PERL_MEM_LOG_FD, buf, len);
# else
	    PerlLIO_write(PERL_MEM_LOG_FD, buf, len);
# endif
	}
    }
#endif
    return oldalloc;
}

#endif /* PERL_MEM_LOG */

/*
=for apidoc my_sprintf

The C library C<sprintf>, wrapped if necessary, to ensure that it will return
the length of the string written to the buffer. Only rare pre-ANSI systems
need the wrapper function - usually this is a direct call to C<sprintf>.

=cut
*/
#ifndef SPRINTF_RETURNS_STRLEN
int
Perl_my_sprintf(char *buffer, const char* pat, ...)
{
    va_list args;
    va_start(args, pat);
    vsprintf(buffer, pat, args);
    va_end(args);
    return strlen(buffer);
}
#endif

/*
=for apidoc my_snprintf

The C library C<snprintf> functionality, if available and
standards-compliant (uses C<vsnprintf>, actually).  However, if the
C<vsnprintf> is not available, will unfortunately use the unsafe
C<vsprintf> which can overrun the buffer (there is an overrun check,
but that may be too late).  Consider using C<sv_vcatpvf> instead, or
getting C<vsnprintf>.

=cut
*/
int
Perl_my_snprintf(char *buffer, const Size_t len, const char *format, ...)
{
    dTHX;
    int retval;
    va_list ap;
    va_start(ap, format);
#ifdef HAS_VSNPRINTF
    retval = vsnprintf(buffer, len, format, ap);
#else
    retval = vsprintf(buffer, format, ap);
#endif
    va_end(ap);
    /* vsnprintf() shows failure with >= len, vsprintf() with < 0 */
    if (retval < 0 || (len > 0 && (Size_t)retval >= len))
	Perl_croak(aTHX_ "panic: my_snprintf buffer overflow");
    return retval;
}

/*
=for apidoc my_vsnprintf

The C library C<vsnprintf> if available and standards-compliant.
However, if if the C<vsnprintf> is not available, will unfortunately
use the unsafe C<vsprintf> which can overrun the buffer (there is an
overrun check, but that may be too late).  Consider using
C<sv_vcatpvf> instead, or getting C<vsnprintf>.

=cut
*/
int
Perl_my_vsnprintf(char *buffer, const Size_t len, const char *format, va_list ap)
{
    dTHX;
    int retval;
#ifdef NEED_VA_COPY
    va_list apc;
    Perl_va_copy(ap, apc);
# ifdef HAS_VSNPRINTF
    retval = vsnprintf(buffer, len, format, apc);
# else
    retval = vsprintf(buffer, format, apc);
# endif
#else
# ifdef HAS_VSNPRINTF
    retval = vsnprintf(buffer, len, format, ap);
# else
    retval = vsprintf(buffer, format, ap);
# endif
#endif /* #ifdef NEED_VA_COPY */
    /* vsnprintf() shows failure with >= len, vsprintf() with < 0 */
    if (retval < 0 || (len > 0 && (Size_t)retval >= len))
	Perl_croak(aTHX_ "panic: my_vsnprintf buffer overflow");
    return retval;
}

a4669 1
    dVAR;
d4695 1
a4695 2
    int bufsiz = bsiz * sizeof(char); /* sizeof(char) paranoid? */
    char *buf = (char*)safesysmalloc(bufsiz);
d4698 1
a4698 1
      int l = e ? e - *environ : (int)strlen(*environ);
d4701 2
a4702 2
        bsiz = l + 1; /* + 1 for the \0. */
        buf = (char*)safesysmalloc(bufsiz);
d4704 2
a4705 2
      memcpy(buf, *environ, l);
      buf[l] = '\0';
a4717 217
}

#ifdef PERL_IMPLICIT_CONTEXT

/* Implements the MY_CXT_INIT macro. The first time a module is loaded,
the global PL_my_cxt_index is incremented, and that value is assigned to
that module's static my_cxt_index (who's address is passed as an arg).
Then, for each interpreter this function is called for, it makes sure a
void* slot is available to hang the static data off, by allocating or
extending the interpreter's PL_my_cxt_list array */

#ifndef PERL_GLOBAL_STRUCT_PRIVATE
void *
Perl_my_cxt_init(pTHX_ int *index, size_t size)
{
    dVAR;
    void *p;
    if (*index == -1) {
	/* this module hasn't been allocated an index yet */
	MUTEX_LOCK(&PL_my_ctx_mutex);
	*index = PL_my_cxt_index++;
	MUTEX_UNLOCK(&PL_my_ctx_mutex);
    }
    
    /* make sure the array is big enough */
    if (PL_my_cxt_size <= *index) {
	if (PL_my_cxt_size) {
	    while (PL_my_cxt_size <= *index)
		PL_my_cxt_size *= 2;
	    Renew(PL_my_cxt_list, PL_my_cxt_size, void *);
	}
	else {
	    PL_my_cxt_size = 16;
	    Newx(PL_my_cxt_list, PL_my_cxt_size, void *);
	}
    }
    /* newSV() allocates one more than needed */
    p = (void*)SvPVX(newSV(size-1));
    PL_my_cxt_list[*index] = p;
    Zero(p, size, char);
    return p;
}

#else /* #ifndef PERL_GLOBAL_STRUCT_PRIVATE */

int
Perl_my_cxt_index(pTHX_ const char *my_cxt_key)
{
    dVAR;
    int index;

    for (index = 0; index < PL_my_cxt_index; index++) {
	const char *key = PL_my_cxt_keys[index];
	/* try direct pointer compare first - there are chances to success,
	 * and it's much faster.
	 */
	if ((key == my_cxt_key) || strEQ(key, my_cxt_key))
	    return index;
    }
    return -1;
}

void *
Perl_my_cxt_init(pTHX_ const char *my_cxt_key, size_t size)
{
    dVAR;
    void *p;
    int index;

    index = Perl_my_cxt_index(aTHX_ my_cxt_key);
    if (index == -1) {
	/* this module hasn't been allocated an index yet */
	MUTEX_LOCK(&PL_my_ctx_mutex);
	index = PL_my_cxt_index++;
	MUTEX_UNLOCK(&PL_my_ctx_mutex);
    }

    /* make sure the array is big enough */
    if (PL_my_cxt_size <= index) {
	int old_size = PL_my_cxt_size;
	int i;
	if (PL_my_cxt_size) {
	    while (PL_my_cxt_size <= index)
		PL_my_cxt_size *= 2;
	    Renew(PL_my_cxt_list, PL_my_cxt_size, void *);
	    Renew(PL_my_cxt_keys, PL_my_cxt_size, const char *);
	}
	else {
	    PL_my_cxt_size = 16;
	    Newx(PL_my_cxt_list, PL_my_cxt_size, void *);
	    Newx(PL_my_cxt_keys, PL_my_cxt_size, const char *);
	}
	for (i = old_size; i < PL_my_cxt_size; i++) {
	    PL_my_cxt_keys[i] = 0;
	    PL_my_cxt_list[i] = 0;
	}
    }
    PL_my_cxt_keys[index] = my_cxt_key;
    /* newSV() allocates one more than needed */
    p = (void*)SvPVX(newSV(size-1));
    PL_my_cxt_list[index] = p;
    Zero(p, size, char);
    return p;
}
#endif /* #ifndef PERL_GLOBAL_STRUCT_PRIVATE */
#endif /* PERL_IMPLICIT_CONTEXT */

#ifndef HAS_STRLCAT
Size_t
Perl_my_strlcat(char *dst, const char *src, Size_t size)
{
    Size_t used, length, copy;

    used = strlen(dst);
    length = strlen(src);
    if (size > 0 && used < size - 1) {
        copy = (length >= size - used) ? size - used - 1 : length;
        memcpy(dst + used, src, copy);
        dst[used + copy] = '\0';
    }
    return used + length;
}
#endif

#ifndef HAS_STRLCPY
Size_t
Perl_my_strlcpy(char *dst, const char *src, Size_t size)
{
    Size_t length, copy;

    length = strlen(src);
    if (size > 0) {
        copy = (length >= size) ? size - 1 : length;
        memcpy(dst, src, copy);
        dst[copy] = '\0';
    }
    return length;
}
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1300) && (_MSC_VER < 1400) && (WINVER < 0x0500)
/* VC7 or 7.1, building with pre-VC7 runtime libraries. */
long _ftol( double ); /* Defined by VC6 C libs. */
long _ftol2( double dblSource ) { return _ftol( dblSource ); }
#endif

void
Perl_get_db_sub(pTHX_ SV **svp, CV *cv)
{
    dVAR;
    SV * const dbsv = GvSVn(PL_DBsub);
    /* We do not care about using sv to call CV;
     * it's for informational purposes only.
     */

    save_item(dbsv);
    if (!PERLDB_SUB_NN) {
	GV * const gv = CvGV(cv);

	if ( svp && ((CvFLAGS(cv) & (CVf_ANON | CVf_CLONED))
	     || strEQ(GvNAME(gv), "END")
	     || ((GvCV(gv) != cv) && /* Could be imported, and old sub redefined. */
		 !( (SvTYPE(*svp) == SVt_PVGV) && (GvCV((GV*)*svp) == cv) )))) {
	    /* Use GV from the stack as a fallback. */
	    /* GV is potentially non-unique, or contain different CV. */
	    SV * const tmp = newRV((SV*)cv);
	    sv_setsv(dbsv, tmp);
	    SvREFCNT_dec(tmp);
	}
	else {
	    gv_efullname3(dbsv, gv, NULL);
	}
    }
    else {
	const int type = SvTYPE(dbsv);
	if (type < SVt_PVIV && type != SVt_IV)
	    sv_upgrade(dbsv, SVt_PVIV);
	(void)SvIOK_on(dbsv);
	SvIV_set(dbsv, PTR2IV(cv));	/* Do it the quickest way  */
    }
}

int
Perl_my_dirfd(pTHX_ DIR * dir) {

    /* Most dirfd implementations have problems when passed NULL. */
    if(!dir)
        return -1;
#ifdef HAS_DIRFD
    return dirfd(dir);
#elif defined(HAS_DIR_DD_FD)
    return dir->dd_fd;
#else
    Perl_die(aTHX_ PL_no_func, "dirfd");
   /* NOT REACHED */
    return 0;
#endif 
}

REGEXP *
Perl_get_re_arg(pTHX_ SV *sv) {
    SV    *tmpsv;
    MAGIC *mg;

    if (sv) {
        if (SvMAGICAL(sv))
            mg_get(sv);
        if (SvROK(sv) &&
            (tmpsv = (SV*)SvRV(sv)) &&            /* assign deliberate */
            SvTYPE(tmpsv) == SVt_PVMG &&
            (mg = mg_find(tmpsv, PERL_MAGIC_qr))) /* assign deliberate */
        {
            return (REGEXP *)mg->mg_obj;
        }
    }
 
    return NULL;
@


1.1.1.12
log
@import perl 5.10.1
@
text
@d3 2
a4 2
 *    Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
 *    2002, 2003, 2004, 2005, 2006, 2007, 2008 by Larry Wall and others
d12 2
a13 4
 * 'Very useful, no doubt, that was to Saruman; yet it seems that he was
 *  not content.'                                    --Gandalf to Pippin
 *
 *     [p.598 of _The Lord of the Rings_, III/xi: "The PalantÌr"]
d181 4
a184 3
    /* MUST do this fixup first, before doing ANYTHING else, as anything else
       might allocate memory/free/move memory, and until we do the fixup, it
       may well be chasing (and writing to) free memory.  */
a185 1
    if (ptr != NULL) {
a200 1
    }
a201 9

    /* In particular, must do that fixup above before logging anything via
     *printf(), as it can reallocate memory, which can cause SEGVs.  */

    DEBUG_m(PerlIO_printf(Perl_debug_log, "0x%"UVxf": (%05ld) rfree\n",PTR2UV(where),(long)PL_an++));
    DEBUG_m(PerlIO_printf(Perl_debug_log, "0x%"UVxf": (%05ld) realloc %ld bytes\n",PTR2UV(ptr),(long)PL_an++,(long)size));


    if (ptr != NULL) {
d267 1
a267 1
	Perl_croak_nocontext("%s", PL_memory_wrap);
d272 1
a272 1
	Perl_croak_nocontext("%s", PL_memory_wrap);
a364 2
    PERL_ARGS_ASSERT_DELIMCPY;

a393 2
    PERL_ARGS_ASSERT_INSTR;

a423 1
    PERL_ARGS_ASSERT_NINSTR;
d428 1
a428 1
        char first = *little;
d430 1
a430 1
        bigend -= lend - little++;
a454 2
    PERL_ARGS_ASSERT_RNINSTR;

a503 2
    PERL_ARGS_ASSERT_FBM_COMPILE;

a580 2
    PERL_ARGS_ASSERT_FBM_INSTR;

a783 2
    PERL_ARGS_ASSERT_SCREAMINSTR;

a866 2
    PERL_ARGS_ASSERT_IBCMP;

a882 2
    PERL_ARGS_ASSERT_IBCMP_LOCALE;

d988 1
a988 3

    PERL_ARGS_ASSERT_SAVESHAREDPVN;

a1011 2
    PERL_ARGS_ASSERT_SAVESVPV;

d1028 1
a1028 1
	return newSVpvs_flags("", SVs_TEMP);
a1050 1
    PERL_ARGS_ASSERT_FORM_NOCONTEXT;
a1082 1
    PERL_ARGS_ASSERT_FORM;
a1092 1
    PERL_ARGS_ASSERT_VFORM;
a1103 1
    PERL_ARGS_ASSERT_MESS_NOCONTEXT;
a1115 1
    PERL_ARGS_ASSERT_MESS;
a1127 2
    PERL_ARGS_ASSERT_CLOSEST_COP;

a1160 2
    PERL_ARGS_ASSERT_VMESS;

a1201 2
    PERL_ARGS_ASSERT_WRITE_TO_STDERR;

d1204 1
a1204 1
	&& (mg = SvTIED_mg((const SV *)io, PERL_MAGIC_tiedscalar))) 
d1218 2
a1219 2
	PUSHs(SvTIED_obj(MUTABLE_SV(io), mg));
	mPUSHp(message, msglen);
d1230 1
a1230 1
	dSAVED_ERRNO;
d1237 1
a1237 1
	RESTORE_ERRNO;
d1273 2
a1274 1
	    msg = newSVpvn_flags(message, msglen, utf8);
d1286 1
a1286 1
	call_sv(MUTABLE_SV(cv), G_DISCARD);
d1423 1
a1423 1
   errsv = get_sv("@@", GV_ADD);
a1448 2
    PERL_ARGS_ASSERT_VWARN;

a1462 1
    PERL_ARGS_ASSERT_WARN_NOCONTEXT;
a1481 1
    PERL_ARGS_ASSERT_WARN;
a1492 1
    PERL_ARGS_ASSERT_WARNER_NOCONTEXT;
a1502 1
    PERL_ARGS_ASSERT_WARNER;
a1511 1
    PERL_ARGS_ASSERT_VWARNER;
a1592 1
    PERL_ARGS_ASSERT_NEW_WARNINGS_BITFIELD;
a1739 2

    PERL_ARGS_ASSERT_SETENV_GETIX;
a1763 2
    PERL_ARGS_ASSERT_UNLNK;

a1776 2
    PERL_ARGS_ASSERT_MY_BCOPY;

a1797 2
    PERL_ARGS_ASSERT_MY_MEMSET;

a1810 2
    PERL_ARGS_ASSERT_MY_BZERO;

a1825 2
    PERL_ARGS_ASSERT_MY_MEMCMP;

a2208 2
    PERL_ARGS_ASSERT_MY_SWABN;

a2227 2
    PERL_ARGS_ASSERT_MY_POPEN_LIST;

d2346 1
a2346 1
    return my_syspopen4(aTHX_ NULL, mode, n, args);
a2367 2
    PERL_ARGS_ASSERT_MY_POPEN;

a2515 1
    PERL_ARGS_ASSERT_MY_POPEN;
a2605 2
    PERL_ARGS_ASSERT_DUMP_FDS;

a2704 2
    PERL_ARGS_ASSERT_RSIGNAL_SAVE;

d2817 4
a2820 1
    dSAVEDERRNO;
d2833 6
a2838 2
    close_failed = (PerlIO_close(ptr) == EOF);
    SAVE_ERRNO;
d2856 1
a2856 1
	RESTORE_ERRNO;
a2876 1
    PERL_ARGS_ASSERT_WAIT4PID;
a2948 1
	errno = EINTR; /* reset in case a signal handler changed $! */
a3006 2
    PERL_ARGS_ASSERT_REPEATCPY;

a3030 2
    PERL_ARGS_ASSERT_SAME_DIRENT;

d3042 1
a3042 1
	sv_setpvs(tmpsv, ".");
d3048 1
a3048 1
	sv_setpvs(tmpsv, ".");
a3092 2
    PERL_ARGS_ASSERT_FIND_SCRIPT;

a3320 1
    PERL_ARGS_ASSERT_SET_CONTEXT;
a3384 1
    PERL_ARGS_ASSERT_GETENV_LEN;
a3681 1
    PERL_ARGS_ASSERT_INIT_TM;
a3686 1
    PERL_ARGS_ASSERT_INIT_TM;
a3703 2
    PERL_ARGS_ASSERT_MINI_MKTIME;

a3897 2
  PERL_ARGS_ASSERT_MY_STRFTIME;

a4004 2
    PERL_ARGS_ASSERT_GETCWD_SV;

a4041 1
	int namelen;
d4064 1
a4064 1
	    namelen = dp->d_namlen;
d4066 1
a4066 1
	    namelen = strlen(dp->d_name);
d4177 1
d4179 3
a4181 3
    PERL_ARGS_ASSERT_SCAN_VERSION;

    (void)sv_upgrade(hv, SVt_PVHV); /* needs to be an HV type */
d4196 1
a4196 1
    while ( *pos == '.' || *pos == '_' || *pos == ',' || isDIGIT(*pos) )
a4211 6
	else if ( *pos == ',' && isDIGIT(pos[1]) )
	{
	    saw_period++ ;
	    last = pos;
	}

d4228 1
a4228 1
	(void)hv_stores(MUTABLE_HV(hv), "qv", newSViv(qv));
d4230 1
a4230 1
	(void)hv_stores(MUTABLE_HV(hv), "alpha", newSViv(alpha));
d4232 1
a4232 1
	(void)hv_stores(MUTABLE_HV(hv), "width", newSViv(width));
a4298 2
	    else if ( *pos == ',' && isDIGIT(pos[1]) )
		s = ++pos;
d4326 1
a4326 1
	   av_push(MUTABLE_AV(sv), newSViv(0));
d4336 2
a4337 2
	(void)hv_stores(MUTABLE_HV(hv), "original", orig);
	(void)hv_stores(MUTABLE_HV(hv), "vinf", newSViv(1));
d4345 1
a4345 1
	(void)hv_stores(MUTABLE_HV(hv), "original", orig);
d4348 1
a4348 1
	(void)hv_stores(MUTABLE_HV(hv), "original", newSVpvs("0"));
d4353 1
a4353 1
    (void)hv_stores(MUTABLE_HV(hv), "version", newRV_noinc(MUTABLE_SV(av)));
a4380 1
    PERL_ARGS_ASSERT_NEW_VERSION;
d4389 3
d4397 2
a4398 2
	if ( hv_exists(MUTABLE_HV(ver), "qv", 2) )
	    (void)hv_stores(MUTABLE_HV(hv), "qv", newSViv(1));
d4400 2
a4401 2
	if ( hv_exists(MUTABLE_HV(ver), "alpha", 5) )
	    (void)hv_stores(MUTABLE_HV(hv), "alpha", newSViv(1));
d4403 1
a4403 1
	if ( hv_exists(MUTABLE_HV(ver), "width", 5 ) )
d4405 2
a4406 2
	    const I32 width = SvIV(*hv_fetchs(MUTABLE_HV(ver), "width", FALSE));
	    (void)hv_stores(MUTABLE_HV(hv), "width", newSViv(width));
d4409 1
a4409 1
	if ( hv_exists(MUTABLE_HV(ver), "original", 8 ) )
d4411 2
a4412 2
	    SV * pv = *hv_fetchs(MUTABLE_HV(ver), "original", FALSE);
	    (void)hv_stores(MUTABLE_HV(hv), "original", newSVsv(pv));
d4415 1
a4415 1
	sav = MUTABLE_AV(SvRV(*hv_fetchs(MUTABLE_HV(ver), "version", FALSE)));
d4423 1
a4423 1
	(void)hv_stores(MUTABLE_HV(hv), "version", newRV_noinc(MUTABLE_SV(av)));
a4468 2
    PERL_ARGS_ASSERT_UPG_VERSION;

a4560 3

    PERL_ARGS_ASSERT_VVERIFY;

d4566 2
a4567 2
	 && hv_exists(MUTABLE_HV(vs), "version", 7)
	 && (sv = SvRV(*hv_fetchs(MUTABLE_HV(vs), "version", FALSE)))
a4595 3

    PERL_ARGS_ASSERT_VNUMIFY;

d4603 1
a4603 1
    if ( hv_exists(MUTABLE_HV(vs), "alpha", 5 ) )
d4605 2
a4606 2
    if ( hv_exists(MUTABLE_HV(vs), "width", 5 ) )
	width = SvIV(*hv_fetchs(MUTABLE_HV(vs), "width", FALSE));
d4612 1
a4612 1
    if ( !(av = MUTABLE_AV(SvRV(*hv_fetchs(MUTABLE_HV(vs), "version", FALSE))) ) ) {
a4673 3

    PERL_ARGS_ASSERT_VNORMAL;

d4680 1
a4680 1
    if ( hv_exists(MUTABLE_HV(vs), "alpha", 5 ) )
d4682 1
a4682 1
    av = MUTABLE_AV(SvRV(*hv_fetchs(MUTABLE_HV(vs), "version", FALSE)));
d4728 1
a4728 3

    PERL_ARGS_ASSERT_VSTRINGIFY;

d4731 1
a4731 1

d4735 5
a4739 14
    if (hv_exists(MUTABLE_HV(vs), "original",  sizeof("original") - 1)) {
	SV *pv;
	pv = *hv_fetchs(MUTABLE_HV(vs), "original", FALSE);
	if ( SvPOK(pv) )
	    return newSVsv(pv);
	else
	    return &PL_sv_undef;
    }
    else {
	if ( hv_exists(MUTABLE_HV(vs), "qv", 2) )
	    return vnormal(vs);
	else
	    return vnumify(vs);
    }
a4759 3

    PERL_ARGS_ASSERT_VCMP;

d4772 2
a4773 2
    lav = MUTABLE_AV(SvRV(*hv_fetchs(MUTABLE_HV(lhv), "version", FALSE)));
    if ( hv_exists(MUTABLE_HV(lhv), "alpha", 5 ) )
d4777 2
a4778 2
    rav = MUTABLE_AV(SvRV(*hv_fetchs(MUTABLE_HV(rhv), "version", FALSE)));
    if ( hv_exists(MUTABLE_HV(rhv), "alpha", 5 ) )
d4968 1
a4968 1
	dSAVE_ERRNO;
d4973 1
a4973 1
	RESTORE_ERRNO;
d5072 1
a5072 1
	dSAVE_ERRNO;
d5079 1
a5079 1
	RESTORE_ERRNO;
a5140 2
  PERL_ARGS_ASSERT_PARSE_UNICODE_OPTS;

a5319 1
    PERL_ARGS_ASSERT_STASHPV_HVNAME_MATCH;
a5395 1
    PERL_ARGS_ASSERT_FREE_GLOBAL_STRUCT;
d5416 3
a5418 9
 * variables PERL_MEM_LOG and PERL_SV_LOG will be consulted, and
 * if the integer value of that is true, the logging will happen.
 * (The default is to always log if the PERL_MEM_LOG define was
 * in effect.)
 *
 * PERL_MEM_LOG_TIMESTAMP: if defined, a timestamp will be logged
 * before every memory logging entry. This can be turned off at run
 * time by setting the environment variable PERL_MEM_LOG_TIMESTAMP
 * to zero.
d5437 3
a5440 12

# ifdef DEBUG_LEAKING_SCALARS
#   define SV_LOG_SERIAL_FMT	    " [%lu]"
#   define _SV_LOG_SERIAL_ARG(sv)   , (unsigned long) (sv)->sv_debug_serial
# else
#   define SV_LOG_SERIAL_FMT
#   define _SV_LOG_SERIAL_ARG(sv)
# endif

static void
S_mem_log_common(enum mem_log_type mlt, const UV n, const UV typesize, const char *type_name, const SV *sv, Malloc_t oldalloc, Malloc_t newalloc, const char *filename, const int linenumber, const char *funcname)
{
d5442 1
a5442 1
    const char *s;
a5443 3

    PERL_ARGS_ASSERT_MEM_LOG_COMMON;

d5445 1
a5445 1
    s = PerlEnv_getenv(mlt < MLT_NEW_SV ? "PERL_MEM_LOG" : "PERL_SV_LOG");
d5453 1
a5454 3
#     define MEM_LOG_TIME_FMT	"%10d.%06d: "
#     define MEM_LOG_TIME_ARG	(int)tv.tv_sec, (int)tv.tv_usec
	struct timeval tv;
a5455 5
#   else
#     define MEM_LOG_TIME_FMT	"%10d: "
#     define MEM_LOG_TIME_ARG	(int)when
        Time_t when;
        (void)time(&when);
d5458 1
a5458 1
	 * gettimeofday() (see ext/Time-HiRes), the easiest way is
d5463 5
a5467 7
	    int fd = PERL_MEM_LOG_FD;
	    STRLEN len;

# ifdef PERL_MEM_LOG_ENV_FD
	    if ((s = PerlEnv_getenv("PERL_MEM_LOG_FD"))) {
		fd = atoi(s);
	    }
d5469 4
a5472 7
# ifdef PERL_MEM_LOG_TIMESTAMP
	    s = PerlEnv_getenv("PERL_MEM_LOG_TIMESTAMP");
	    if (!s || atoi(s)) {
		len = my_snprintf(buf, sizeof(buf),
				MEM_LOG_TIME_FMT, MEM_LOG_TIME_ARG);
		PerlLIO_write(fd, buf, len);
	    }
d5474 8
a5481 32
	    switch (mlt) {
	    case MLT_ALLOC:
		len = my_snprintf(buf, sizeof(buf),
			"alloc: %s:%d:%s: %"IVdf" %"UVuf
			" %s = %"IVdf": %"UVxf"\n",
			filename, linenumber, funcname, n, typesize,
			type_name, n * typesize, PTR2UV(newalloc));
		break;
	    case MLT_REALLOC:
		len = my_snprintf(buf, sizeof(buf),
			"realloc: %s:%d:%s: %"IVdf" %"UVuf
			" %s = %"IVdf": %"UVxf" -> %"UVxf"\n",
			filename, linenumber, funcname, n, typesize,
			type_name, n * typesize, PTR2UV(oldalloc),
			PTR2UV(newalloc));
		break;
	    case MLT_FREE:
		len = my_snprintf(buf, sizeof(buf),
			"free: %s:%d:%s: %"UVxf"\n",
			filename, linenumber, funcname,
			PTR2UV(oldalloc));
		break;
	    case MLT_NEW_SV:
	    case MLT_DEL_SV:
		len = my_snprintf(buf, sizeof(buf),
			"%s_SV: %s:%d:%s: %"UVxf SV_LOG_SERIAL_FMT "\n",
			mlt == MLT_NEW_SV ? "new" : "del",
			filename, linenumber, funcname,
			PTR2UV(sv) _SV_LOG_SERIAL_ARG(sv));
		break;
	    }
	    PerlLIO_write(fd, buf, len);
a5483 8
}
#endif

Malloc_t
Perl_mem_log_alloc(const UV n, const UV typesize, const char *type_name, Malloc_t newalloc, const char *filename, const int linenumber, const char *funcname)
{
#ifdef PERL_MEM_LOG_STDERR
    mem_log_common(MLT_ALLOC, n, typesize, type_name, NULL, NULL, newalloc, filename, linenumber, funcname);
d5489 1
a5489 1
Perl_mem_log_realloc(const UV n, const UV typesize, const char *type_name, Malloc_t oldalloc, Malloc_t newalloc, const char *filename, const int linenumber, const char *funcname)
d5492 38
a5529 1
    mem_log_common(MLT_REALLOC, n, typesize, type_name, NULL, oldalloc, newalloc, filename, linenumber, funcname);
d5538 36
a5573 1
    mem_log_common(MLT_FREE, 0, 0, "", NULL, oldalloc, NULL, filename, linenumber, funcname);
a5577 16
void
Perl_mem_log_new_sv(const SV *sv, const char *filename, const int linenumber, const char *funcname)
{
#ifdef PERL_MEM_LOG_STDERR
    mem_log_common(MLT_NEW_SV, 0, 0, "", sv, NULL, NULL, filename, linenumber, funcname);
#endif
}

void
Perl_mem_log_del_sv(const SV *sv, const char *filename, const int linenumber, const char *funcname)
{
#ifdef PERL_MEM_LOG_STDERR
    mem_log_common(MLT_DEL_SV, 0, 0, "", sv, NULL, NULL, filename, linenumber, funcname);
#endif
}

a5593 1
    PERL_ARGS_ASSERT_MY_SPRINTF;
a5618 1
    PERL_ARGS_ASSERT_MY_SNPRINTF;
a5649 3

    PERL_ARGS_ASSERT_MY_VSNPRINTF;

a5738 1
    PERL_ARGS_ASSERT_MY_CXT_INIT;
a5772 2
    PERL_ARGS_ASSERT_MY_CXT_INDEX;

a5790 2
    PERL_ARGS_ASSERT_MY_CXT_INIT;

a5876 2
    PERL_ARGS_ASSERT_GET_DB_SUB;

d5884 1
a5884 2
		 !( (SvTYPE(*svp) == SVt_PVGV)
		    && (GvCV((const GV *)*svp) == cv) )))) {
d5887 1
a5887 1
	    SV * const tmp = newRV(MUTABLE_SV(cv));
d5930 1
a5930 1
            (tmpsv = MUTABLE_SV(SvRV(sv))) &&            /* assign deliberate */
@


1.1.1.13
log
@Perl 5.12.2 from CPAN
@
text
@d372 1
a372 1
Perl_delimcpy(register char *to, register const char *toend, register const char *from, register const char *fromend, register int delim, I32 *retlen)
d375 1
d403 1
a403 1
Perl_instr(register const char *big, register const char *little)
d406 1
d438 1
a438 1
Perl_ninstr(const char *big, const char *bigend, const char *little, const char *lend)
d441 1
d445 1
a445 1
        const char first = *little;
d465 1
a465 1
Perl_rninstr(register const char *big, const char *bigend, const char *little, const char *lend)
d470 1
d886 1
a886 1
Perl_ibcmp(const char *s1, const char *s2, register I32 len)
d890 1
d903 1
a903 1
Perl_ibcmp_locale(const char *s1, const char *s2, register I32 len)
d908 1
d1238 1
a1238 1
Perl_write_to_stderr(pTHX_ SV* msv)
d1263 1
a1263 1
	PUSHs(msv);
a1276 2
	STRLEN msglen;
	const char* message = SvPVx_const(msv, msglen);
d1289 1
a1289 1
S_vdie_common(pTHX_ SV *message, bool warn)
d1317 1
a1317 1
	    msg = newSVsv(message);
d1337 3
a1339 2
STATIC SV *
S_vdie_croak_common(pTHX_ const char* pat, va_list* args)
d1342 1
a1342 1
    SV *message;
d1348 1
a1348 1
	    message = sv_mortalcopy(PL_errors);
d1352 2
a1353 1
	    message = msv;
d1359 3
d1363 1
a1363 1
	S_vdie_common(aTHX_ message, FALSE);
d1368 2
a1369 2
static OP *
S_vdie(pTHX_ const char* pat, va_list *args)
d1372 19
a1390 7
    SV *message;

    message = vdie_croak_common(pat, args);

    die_where(message);
    /* NOTREACHED */
    return NULL;
d1422 13
a1434 3
    SV *msv;

    msv = S_vdie_croak_common(aTHX_ pat, args);
d1436 2
a1437 1
    die_where(msv);
d1487 1
d1489 2
d1495 1
a1495 1
	if (vdie_common(msv, TRUE))
d1499 1
a1499 1
    write_to_stderr(msv);
a1547 26
Perl_ck_warner_d(pTHX_ U32 err, const char* pat, ...)
{
    PERL_ARGS_ASSERT_CK_WARNER_D;

    if (Perl_ckwarn_d(aTHX_ err)) {
	va_list args;
	va_start(args, pat);
	vwarner(err, pat, &args);
	va_end(args);
    }
}

void
Perl_ck_warner(pTHX_ U32 err, const char* pat, ...)
{
    PERL_ARGS_ASSERT_CK_WARNER;

    if (Perl_ckwarn(aTHX_ err)) {
	va_list args;
	va_start(args, pat);
	vwarner(err, pat, &args);
	va_end(args);
    }
}

void
d1564 3
d1569 2
a1570 2
	    assert(msv);
	    S_vdie_common(aTHX_ msv, FALSE);
d1572 7
a1578 1
	die_where(msv);
d1591 20
a1610 5
    /* If lexical warnings have not been set, use $^W.  */
    if (isLEXWARN_off)
	return PL_dowarn & G_WARN_ON;

    return ckwarn_common(w);
d1619 16
a1634 36
    /* If lexical warnings have not been set then default classes warn.  */
    if (isLEXWARN_off)
	return TRUE;

    return ckwarn_common(w);
}

static bool
S_ckwarn_common(pTHX_ U32 w)
{
    if (PL_curcop->cop_warnings == pWARN_ALL)
	return TRUE;

    if (PL_curcop->cop_warnings == pWARN_NONE)
	return FALSE;

    /* Check the assumption that at least the first slot is non-zero.  */
    assert(unpackWARN1(w));

    /* Check the assumption that it is valid to stop as soon as a zero slot is
       seen.  */
    if (!unpackWARN2(w)) {
	assert(!unpackWARN3(w));
	assert(!unpackWARN4(w));
    } else if (!unpackWARN3(w)) {
	assert(!unpackWARN4(w));
    }
	
    /* Right, dealt with all the special cases, which are implemented as non-
       pointers, so there is a pointer to a real warnings mask.  */
    do {
	if (isWARN_on(PL_curcop->cop_warnings, unpackWARN1(w)))
	    return TRUE;
    } while (w >>= WARNshift);

    return FALSE;
d1679 1
a1679 2
    register I32 i;
    register const I32 len = strlen(nam);
a1681 6
    /* where does it go? */
    for (i = 0; environ[i]; i++) {
        if (strnEQ(environ[i],nam,len) && environ[i][len] == '=')
            break;
    }

d1785 24
d2282 1
a2282 1
Perl_my_popen_list(pTHX_ const char *mode, int n, SV **args)
d2284 1
a2284 1
#if (!defined(DOSISH) || defined(HAS_FORK) || defined(AMIGAOS)) && !defined(OS2) && !defined(VMS) && !defined(__OPEN_VM) && !defined(EPOC) && !defined(NETWARE) && !defined(__LIBCATAMOUNT__)
a2316 1
	Perl_ck_warner(aTHX_ packWARN(WARN_PIPE), "Can't fork, trying again in 5 seconds");
d2374 1
d2376 1
d2422 1
a2422 1
#if (!defined(DOSISH) || defined(HAS_FORK) || defined(AMIGAOS)) && !defined(VMS) && !defined(__OPEN_VM) && !defined(EPOC) && !defined(__LIBCATAMOUNT__)
d2462 1
a2462 1
		Perl_croak(aTHX_ "Can't fork: %s", Strerror(errno));
a2464 1
	Perl_ck_warner(aTHX_ packWARN(WARN_PIPE), "Can't fork, trying again in 5 seconds");
d2542 1
d2544 1
d2671 1
a2671 1
Perl_dump_fds(pTHX_ const char *const s)
d2725 5
d2880 1
a2880 1
#if (!defined(DOSISH) || defined(HAS_FORK) || defined(AMIGAOS)) && !defined(VMS) && !defined(__OPEN_VM) && !defined(EPOC) && !defined(__LIBCATAMOUNT__)
d2893 1
d2895 1
d2938 1
a2938 1
#if  (!defined(DOSISH) || defined(OS2) || defined(WIN32) || defined(NETWARE)) && !defined(__LIBCATAMOUNT__)
d3025 1
a3025 1
S_pidgone(pTHX_ Pid_t pid, int status)
a3068 1
#define PERL_REPEATCPY_LINEAR 4
d3070 1
a3070 1
Perl_repeatcpy(register char *to, register const char *from, I32 len, register I32 count)
d3072 4
d3078 9
a3086 20
    if (len == 1)
	memset(to, *from, count);
    else if (count) {
	register char *p = to;
	I32 items, linear, half;

	linear = count < PERL_REPEATCPY_LINEAR ? count : PERL_REPEATCPY_LINEAR;
	for (items = 0; items < linear; ++items) {
	    register const char *q = from;
	    I32 todo;
	    for (todo = len; todo > 0; todo--)
		*p++ = *q++;
        }

	half = count / 2;
	while (items <= half) {
	    I32 size = items * len;
	    memcpy(p, to, size);
	    p     += size;
	    items *= 2;
d3088 1
a3088 3

	if (count > items)
	    memcpy(p, to, (count - items) * len);
d3256 4
d3265 1
d3271 5
d3292 1
d3297 4
d3302 1
a3302 1
#  if defined(atarist) || defined(DOSISH)
d3310 1
d3335 1
a3335 1
#if !defined(DOSISH)
a4228 204

/*
=for apidoc prescan_version

=cut
*/
const char *
Perl_prescan_version(pTHX_ const char *s, bool strict,
		     const char **errstr,
		     bool *sqv, int *ssaw_decimal, int *swidth, bool *salpha) {
    bool qv = (sqv ? *sqv : FALSE);
    int width = 3;
    int saw_decimal = 0;
    bool alpha = FALSE;
    const char *d = s;

    PERL_ARGS_ASSERT_PRESCAN_VERSION;

    if (qv && isDIGIT(*d))
	goto dotted_decimal_version;

    if (*d == 'v') { /* explicit v-string */
	d++;
	if (isDIGIT(*d)) {
	    qv = TRUE;
	}
	else { /* degenerate v-string */
	    /* requires v1.2.3 */
	    BADVERSION(s,errstr,"Invalid version format (dotted-decimal versions require at least three parts)");
	}

dotted_decimal_version:
	if (strict && d[0] == '0' && isDIGIT(d[1])) {
	    /* no leading zeros allowed */
	    BADVERSION(s,errstr,"Invalid version format (no leading zeros)");
	}

	while (isDIGIT(*d)) 	/* integer part */
	    d++;

	if (*d == '.')
	{
	    saw_decimal++;
	    d++; 		/* decimal point */
	}
	else
	{
	    if (strict) {
		/* require v1.2.3 */
		BADVERSION(s,errstr,"Invalid version format (dotted-decimal versions require at least three parts)");
	    }
	    else {
		goto version_prescan_finish;
	    }
	}

	{
	    int i = 0;
	    int j = 0;
	    while (isDIGIT(*d)) {	/* just keep reading */
		i++;
		while (isDIGIT(*d)) {
		    d++; j++;
		    /* maximum 3 digits between decimal */
		    if (strict && j > 3) {
			BADVERSION(s,errstr,"Invalid version format (maximum 3 digits between decimals)");
		    }
		}
		if (*d == '_') {
		    if (strict) {
			BADVERSION(s,errstr,"Invalid version format (no underscores)");
		    }
		    if ( alpha ) {
			BADVERSION(s,errstr,"Invalid version format (multiple underscores)");
		    }
		    d++;
		    alpha = TRUE;
		}
		else if (*d == '.') {
		    if (alpha) {
			BADVERSION(s,errstr,"Invalid version format (underscores before decimal)");
		    }
		    saw_decimal++;
		    d++;
		}
		else if (!isDIGIT(*d)) {
		    break;
		}
		j = 0;
	    }

	    if (strict && i < 2) {
		/* requires v1.2.3 */
		BADVERSION(s,errstr,"Invalid version format (dotted-decimal versions require at least three parts)");
	    }
	}
    } 					/* end if dotted-decimal */
    else
    {					/* decimal versions */
	/* special strict case for leading '.' or '0' */
	if (strict) {
	    if (*d == '.') {
		BADVERSION(s,errstr,"Invalid version format (0 before decimal required)");
	    }
	    if (*d == '0' && isDIGIT(d[1])) {
		BADVERSION(s,errstr,"Invalid version format (no leading zeros)");
	    }
	}

	/* consume all of the integer part */
	while (isDIGIT(*d))
	    d++;

	/* look for a fractional part */
	if (*d == '.') {
	    /* we found it, so consume it */
	    saw_decimal++;
	    d++;
	}
	else if (!*d || *d == ';' || isSPACE(*d) || *d == '}') {
	    if ( d == s ) {
		/* found nothing */
		BADVERSION(s,errstr,"Invalid version format (version required)");
	    }
	    /* found just an integer */
	    goto version_prescan_finish;
	}
	else if ( d == s ) {
	    /* didn't find either integer or period */
	    BADVERSION(s,errstr,"Invalid version format (non-numeric data)");
	}
	else if (*d == '_') {
	    /* underscore can't come after integer part */
	    if (strict) {
		BADVERSION(s,errstr,"Invalid version format (no underscores)");
	    }
	    else if (isDIGIT(d[1])) {
		BADVERSION(s,errstr,"Invalid version format (alpha without decimal)");
	    }
	    else {
		BADVERSION(s,errstr,"Invalid version format (misplaced underscore)");
	    }
	}
	else {
	    /* anything else after integer part is just invalid data */
	    BADVERSION(s,errstr,"Invalid version format (non-numeric data)");
	}

	/* scan the fractional part after the decimal point*/

	if (!isDIGIT(*d) && (strict || ! (!*d || *d == ';' || isSPACE(*d) || *d == '}') )) {
		/* strict or lax-but-not-the-end */
		BADVERSION(s,errstr,"Invalid version format (fractional part required)");
	}

	while (isDIGIT(*d)) {
	    d++;
	    if (*d == '.' && isDIGIT(d[-1])) {
		if (alpha) {
		    BADVERSION(s,errstr,"Invalid version format (underscores before decimal)");
		}
		if (strict) {
		    BADVERSION(s,errstr,"Invalid version format (dotted-decimal versions must begin with 'v')");
		}
		d = (char *)s; 		/* start all over again */
		qv = TRUE;
		goto dotted_decimal_version;
	    }
	    if (*d == '_') {
		if (strict) {
		    BADVERSION(s,errstr,"Invalid version format (no underscores)");
		}
		if ( alpha ) {
		    BADVERSION(s,errstr,"Invalid version format (multiple underscores)");
		}
		if ( ! isDIGIT(d[1]) ) {
		    BADVERSION(s,errstr,"Invalid version format (misplaced underscore)");
		}
		d++;
		alpha = TRUE;
	    }
	}
    }

version_prescan_finish:
    while (isSPACE(*d))
	d++;

    if (!isDIGIT(*d) && (! (!*d || *d == ';' || *d == '}') )) {
	/* trailing non-numeric data */
	BADVERSION(s,errstr,"Invalid version format (non-numeric data)");
    }

    if (sqv)
	*sqv = qv;
    if (swidth)
	*swidth = width;
    if (ssaw_decimal)
	*ssaw_decimal = saw_decimal;
    if (salpha)
	*salpha = alpha;
    return d;
}

d4257 2
a4258 2
    const char *errstr = NULL;
    int saw_decimal = 0;
a4259 1
    bool alpha = FALSE;
a4267 4
#ifndef NODEFAULT_SHAREKEYS
    HvSHAREKEYS_on(hv);         /* key-sharing on by default */
#endif

d4271 25
a4295 5
    last = prescan_version(s, FALSE, &errstr, &qv, &saw_decimal, &width, &alpha);
    if (errstr) {
	/* "undef" is a special case and not an error */
	if ( ! ( *s == 'u' && strEQ(s,"undef")) ) {
	    Perl_croak(aTHX_ "%s", errstr);
d4297 7
d4306 10
a4315 3
    start = s;
    if (*s == 'v')
	s++;
d4342 1
a4342 1
		if ( !qv && s > start && saw_decimal == 1 ) {
d4350 3
a4352 2
			    Perl_ck_warner(aTHX_ packWARN(WARN_OVERFLOW), 
					   "Integer overflow in version %d",VERSION_MAX);
d4369 3
a4371 2
			    Perl_ck_warner(aTHX_ packWARN(WARN_OVERFLOW), 
					   "Integer overflow in version");
d4434 1
a4434 1
	if ( qv && saw_decimal == 1 && *start != 'v' ) {
a4482 3
#ifndef NODEFAULT_SHAREKEYS
	HvSHAREKEYS_on(hv);         /* key-sharing on by default */
#endif
d4525 1
a4525 1
	    if ( isDIGIT(*version) )
d4580 1
a4580 1
	qv = TRUE;
d4590 1
a4590 3
	if ( len >= 3 && !instr(version,".") && !instr(version,"_")
	    && !(*version == 'u' && strEQ(version, "undef"))
	    && (*version < '0' || *version > '9') ) {
d4595 1
a4595 1
	    int saw_decimal = 0;
d4603 1
a4603 1
		    saw_decimal++ ;
d4608 1
a4608 1
	    if ( saw_decimal >= 2 ) {
d4619 4
a4622 3
	Perl_ck_warner(aTHX_ packWARN(WARN_MISC), 
		       "Version string '%s' contains invalid data; "
		       "ignoring: '%s'", version, s);
d4690 1
a4690 1
    SV *sv;
d4712 2
a4713 1
	return newSVpvs("0");
d4719 2
a4720 1
	return newSVpvs("0");
d4724 1
a4724 1
    sv = Perl_newSVpvf(aTHX_ "%d.", (int)PERL_ABS(digit));
d4771 1
a4771 1
    SV *sv;
d4789 2
a4790 1
	return newSVpvs("");
d4793 1
a4793 1
    sv = Perl_newSVpvf(aTHX_ "v%"IVdf, (IV)digit);
d4830 1
d5418 1
a5418 1
	       (UV)(Drand01() * (NV)((((UV)1) << ((UVSIZE * 8 - RANDBITS))) - 1));
d5532 2
a5533 3
/* -DPERL_MEM_LOG: the Perl_mem_log_..() is compiled, including the
 * the default implementation, unless -DPERL_MEM_LOG_NOIMPL is also
 * given, and you supply your own implementation.
d5535 5
a5539 2
 * The default implementation reads a single env var, PERL_MEM_LOG,
 * expecting one or more of the following:
d5541 4
a5544 7
 *    \d+ - fd		fd to write to		: must be 1st (atoi)
 *    'm' - memlog	was PERL_MEM_LOG=1
 *    's' - svlog	was PERL_SV_LOG=1
 *    't' - timestamp	was PERL_MEM_LOG_TIMESTAMP=1
 *
 * This makes the logger controllable enough that it can reasonably be
 * added to the system perl.
d5547 2
a5548 1
/* -DPERL_MEM_LOG_SPRINTF_BUF_SIZE=X: size of a (stack-allocated) buffer
d5553 5
a5557 2
/* -DPERL_MEM_LOG_FD=N: the file descriptor the Perl_mem_log_...()
 * writes to.  In the default logger, this is settable at runtime.
d5563 1
a5563 1
#ifndef PERL_MEM_LOG_NOIMPL
d5574 1
a5574 5
S_mem_log_common(enum mem_log_type mlt, const UV n, 
		 const UV typesize, const char *type_name, const SV *sv,
		 Malloc_t oldalloc, Malloc_t newalloc,
		 const char *filename, const int linenumber,
		 const char *funcname)
d5576 3
a5578 1
    const char *pmlenv;
d5582 4
a5585 4
    pmlenv = PerlEnv_getenv("PERL_MEM_LOG");
    if (!pmlenv)
	return;
    if (mlt < MLT_NEW_SV ? strchr(pmlenv,'m') : strchr(pmlenv,'s'))
d5590 1
a5590 1

d5606 1
d5608 1
a5609 3
	    int fd = atoi(pmlenv);
	    if (!fd)
		fd = PERL_MEM_LOG_FD;
d5611 8
a5618 1
	    if (strchr(pmlenv, 't')) {
d5623 1
a5653 2
	    default:
		len = 0;
a5658 13
#endif /* !PERL_MEM_LOG_NOIMPL */

#ifndef PERL_MEM_LOG_NOIMPL
# define \
    mem_log_common_if(alty, num, tysz, tynm, sv, oal, nal, flnm, ln, fnnm) \
    mem_log_common   (alty, num, tysz, tynm, sv, oal, nal, flnm, ln, fnnm)
#else
/* this is suboptimal, but bug compatible.  User is providing their
   own implemenation, but is getting these functions anyway, and they
   do nothing. But _NOIMPL users should be able to cope or fix */
# define \
    mem_log_common_if(alty, num, tysz, tynm, u, oal, nal, flnm, ln, fnnm) \
    /* mem_log_common_if_PERL_MEM_LOG_NOIMPL */
d5662 5
a5666 8
Perl_mem_log_alloc(const UV n, const UV typesize, const char *type_name,
		   Malloc_t newalloc, 
		   const char *filename, const int linenumber,
		   const char *funcname)
{
    mem_log_common_if(MLT_ALLOC, n, typesize, type_name,
		      NULL, NULL, newalloc,
		      filename, linenumber, funcname);
d5671 5
a5675 8
Perl_mem_log_realloc(const UV n, const UV typesize, const char *type_name,
		     Malloc_t oldalloc, Malloc_t newalloc, 
		     const char *filename, const int linenumber, 
		     const char *funcname)
{
    mem_log_common_if(MLT_REALLOC, n, typesize, type_name,
		      NULL, oldalloc, newalloc, 
		      filename, linenumber, funcname);
d5680 1
a5680 3
Perl_mem_log_free(Malloc_t oldalloc, 
		  const char *filename, const int linenumber, 
		  const char *funcname)
d5682 3
a5684 2
    mem_log_common_if(MLT_FREE, 0, 0, "", NULL, oldalloc, NULL, 
		      filename, linenumber, funcname);
d5689 1
a5689 3
Perl_mem_log_new_sv(const SV *sv, 
		    const char *filename, const int linenumber,
		    const char *funcname)
d5691 3
a5693 2
    mem_log_common_if(MLT_NEW_SV, 0, 0, "", sv, NULL, NULL,
		      filename, linenumber, funcname);
d5697 1
a5697 3
Perl_mem_log_del_sv(const SV *sv,
		    const char *filename, const int linenumber, 
		    const char *funcname)
d5699 3
a5701 2
    mem_log_common_if(MLT_DEL_SV, 0, 0, "", sv, NULL, NULL, 
		      filename, linenumber, funcname);
a5872 1
#if defined(USE_ITHREADS)
a5873 1
#endif
a5874 1
#if defined(USE_ITHREADS)
a5875 1
#endif
a5929 1
#if defined(USE_ITHREADS)
a5930 1
#endif
a5931 1
#if defined(USE_ITHREADS)
a5932 1
#endif
d6062 2
d6068 7
a6074 4
        if (SvROK(sv))
	    sv = MUTABLE_SV(SvRV(sv));
        if (SvTYPE(sv) == SVt_REGEXP)
            return (REGEXP*) sv;
@


1.1.1.14
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d15 1
a15 1
 *     [p.598 of _The Lord of the Rings_, III/xi: "The Palant√≠r"]
a27 4
#ifdef USE_PERLIO
#include "perliol.h" /* For PerlIOUnix_refcnt */
#endif

d40 4
a72 4
#if defined (DEBUGGING) || defined(PERL_IMPLICIT_SYS) || defined (PERL_TRACK_MEMPOOL)
#  define ALWAYS_NEED_THX
#endif

a77 1
#ifdef ALWAYS_NEED_THX
a78 1
#endif
d91 2
a92 2
    if ((SSize_t)size < 0)
	Perl_croak_nocontext("panic: malloc, size=%"UVuf, (UV) size);
d96 1
a118 1
	DEBUG_m(PerlIO_printf(Perl_debug_log, "0x%"UVxf": (%05ld) malloc %ld bytes\n",PTR2UV(ptr),(long)PL_an++,(long)size));
d121 2
d124 1
a124 8
#ifndef ALWAYS_NEED_THX
	dTHX;
#endif
	if (PL_nomemok)
	    return NULL;
	else {
	    return write_no_mem();
	}
a133 1
#ifdef ALWAYS_NEED_THX
a134 1
#endif
d162 1
a162 2
	    Perl_croak_nocontext("panic: realloc from wrong pool, %p!=%p",
				 header->interpreter, aTHX);
d177 2
a178 2
    if ((SSize_t)size < 0)
	Perl_croak_nocontext("panic: realloc, size=%"UVuf, (UV)size);
d216 2
d219 1
a219 8
#ifndef ALWAYS_NEED_THX
	dTHX;
#endif
	if (PL_nomemok)
	    return NULL;
	else {
	    return write_no_mem();
	}
d229 1
a229 1
#ifdef ALWAYS_NEED_THX
d243 1
a243 2
		Perl_croak_nocontext("panic: free from wrong pool, %p!=%p",
				     header->interpreter, aTHX);
d248 3
a250 7
	    if (!(header->next))
		Perl_croak_nocontext("panic: bad free, header->next==NULL");
	    if (header->next->prev != header || header->prev->next != header) {
		Perl_croak_nocontext("panic: bad free, ->next->prev=%p, "
				     "header=%p, ->prev->next=%p",
				     header->next->prev, header,
				     header->prev->next);
a270 1
#ifdef ALWAYS_NEED_THX
a271 1
#endif
a272 1
#if defined(PERL_TRACK_MEMPOOL) || defined(HAS_64K_LIMIT) || defined(DEBUGGING)
a273 1
#endif
d276 1
a276 2
    if (size && (count <= MEM_SIZE_MAX / size)) {
#if defined(PERL_TRACK_MEMPOOL) || defined(HAS_64K_LIMIT) || defined(DEBUGGING)
a277 2
#endif
    }
d294 2
a295 3
    if ((SSize_t)size < 0 || (SSize_t)count < 0)
	Perl_croak_nocontext("panic: calloc, size=%"UVuf", count=%"UVuf,
			     (UV)size, (UV)count);
d333 3
a335 8
    else {
#ifndef ALWAYS_NEED_THX
	dTHX;
#endif
	if (PL_nomemok)
	    return NULL;
	return write_no_mem();
    }
d433 1
a433 2
/* same as instr but allow embedded nulls.  The end pointers point to 1 beyond
 * the final character desired to be checked */
d514 1
a514 1
    STRLEN i;
d516 1
a516 1
    STRLEN rarest = 0;
a517 1
    MAGIC *mg;
a520 10
    /* Refuse to fbm_compile a studied scalar, as this gives more flexibility in
       SV flag usage.  No real-world code would ever end up using a studied
       scalar as a compile-time second argument to index, so this isn't a real
       pessimisation.  */
    if (SvSCREAM(sv))
	return;

    if (SvVALID(sv))
	return;

d530 1
a530 1
    SvUPGRADE(sv, SVt_PVMG);
a533 19

    /* "deep magic", the comment used to add. The use of MAGIC itself isn't
       really. MAGIC was originally added in 79072805bf63abe5 (perl 5.0 alpha 2)
       to call SvVALID_off() if the scalar was assigned to.

       The comment itself (and "deeper magic" below) date back to
       378cc40b38293ffc (perl 2.0). "deep magic" was an annotation on
       str->str_pok |= 2;
       where the magic (presumably) was that the scalar had a BM table hidden
       inside itself.

       As MAGIC is always present on BMs [in Perl 5 :-)], we can use it to store
       the table instead of the previous (somewhat hacky) approach of co-opting
       the string buffer and storing it after the string.  */

    assert(!mg_find(sv, PERL_MAGIC_bm));
    mg = sv_magicext(sv, NULL, PERL_MAGIC_bm, &PL_vtbl_bm, NULL, 0);
    assert(mg);

d535 1
a535 2
	/* Shorter strings are special-cased in Perl_fbm_instr(), and don't use
	   the BM table.  */
a536 1
	const unsigned char *const sb = s + len - mlen; /* first char (maybe) */
d539 4
a542 1
	Newx(table, 256, U8);
a543 4
	mg->mg_ptr = (char *)table;
	mg->mg_len = 256;

	s += len - 1; /* last char */
d545 1
d551 2
d554 1
d563 1
d569 2
a570 2
    DEBUG_r(PerlIO_printf(Perl_debug_log, "rarest char %c at %"UVuf"\n",
			  BmRARE(sv), BmPREVIOUS(sv)));
d610 3
a612 4
    switch (littlelen) { /* Special cases for 0, 1 and 2  */
    case 0:
	return (char*)big;		/* Cannot be SvTAIL! */
    case 1:
d628 5
a632 1
    case 2:
a691 2
    default:
	break; /* Only lengths 0 1 and 2 have special-case code.  */
a692 1

d730 2
a731 2
	const MAGIC *const mg = mg_find(littlestr, PERL_MAGIC_bm);
	const unsigned char * const table = (const unsigned char *) mg->mg_ptr;
d767 1
a767 1
	     && SvTAIL(littlestr)
d795 1
a795 1
    U32 pos = 0; /* hush a gcc warning */
d801 1
a801 4
    bool found = FALSE;
    const MAGIC * mg;
    const void *screamnext_raw = NULL; /* hush a gcc warning */
    bool cant_find = FALSE; /* hush a gcc warning */
d805 1
a805 4
    assert(SvMAGICAL(bigstr));
    mg = mg_find(bigstr, PERL_MAGIC_study);
    assert(mg);
    assert(SvTYPE(littlestr) == SVt_PVMG);
d808 3
a810 31
    if (mg->mg_private == 1) {
	const U8 *const screamfirst = (U8 *)mg->mg_ptr;
	const U8 *const screamnext = screamfirst + 256;

	screamnext_raw = (const void *)screamnext;

	pos = *old_posp == -1
	    ? screamfirst[BmRARE(littlestr)] : screamnext[*old_posp];
	cant_find = pos == (U8)~0;
    } else if (mg->mg_private == 2) {
	const U16 *const screamfirst = (U16 *)mg->mg_ptr;
	const U16 *const screamnext = screamfirst + 256;

	screamnext_raw = (const void *)screamnext;

	pos = *old_posp == -1
	    ? screamfirst[BmRARE(littlestr)] : screamnext[*old_posp];
	cant_find = pos == (U16)~0;
    } else if (mg->mg_private == 4) {
	const U32 *const screamfirst = (U32 *)mg->mg_ptr;
	const U32 *const screamnext = screamfirst + 256;

	screamnext_raw = (const void *)screamnext;

	pos = *old_posp == -1
	    ? screamfirst[BmRARE(littlestr)] : screamnext[*old_posp];
	cant_find = pos == (U32)~0;
    } else
	Perl_croak(aTHX_ "panic: unknown study size %u", mg->mg_private);

    if (cant_find) {
d841 3
a843 21
    if (mg->mg_private == 1) {
	const U8 *const screamnext = (const U8 *const) screamnext_raw;
	while ((I32)pos < previous + start_shift) {
	    pos = screamnext[pos];
	    if (pos == (U8)~0)
		goto cant_find;
	}
    } else if (mg->mg_private == 2) {
	const U16 *const screamnext = (const U16 *const) screamnext_raw;
	while ((I32)pos < previous + start_shift) {
	    pos = screamnext[pos];
	    if (pos == (U16)~0)
		goto cant_find;
	}
    } else if (mg->mg_private == 4) {
	const U32 *const screamnext = (const U32 *const) screamnext_raw;
	while ((I32)pos < previous + start_shift) {
	    pos = screamnext[pos];
	    if (pos == (U32)~0)
		goto cant_find;
	}
d846 9
a854 14
    while (1) {
	if ((I32)pos >= stop_pos) break;
	if (big[pos] == first) {
	    const unsigned char *s = little;
	    const unsigned char *x = big + pos + 1;
	    while (s < littleend) {
		if (*s != *x++)
		    break;
		++s;
	    }
	    if (s == littleend) {
		*old_posp = (I32)pos;
		if (!last) return (char *)(big+pos);
		found = TRUE;
d857 4
a860 12
	if (mg->mg_private == 1) {
	    pos = ((const U8 *const)screamnext_raw)[pos];
	    if (pos == (U8)~0)
		break;
	} else if (mg->mg_private == 2) {
	    pos = ((const U16 *const)screamnext_raw)[pos];
	    if (pos == (U16)~0)
		break;
	} else if (mg->mg_private == 4) {
	    pos = ((const U32 *const)screamnext_raw)[pos];
	    if (pos == (U32)~0)
		break;
d862 1
a862 1
    };
a880 12
/*
=for apidoc foldEQ

Returns true if the leading len bytes of the strings s1 and s2 are the same
case-insensitively; false otherwise.  Uppercase and lowercase ASCII range bytes
match themselves and their opposite case counterparts.  Non-cased and non-ASCII
range bytes match only themselves.

=cut
*/


d882 1
a882 1
Perl_foldEQ(const char *s1, const char *s2, register I32 len)
d887 1
a887 1
    PERL_ARGS_ASSERT_FOLDEQ;
d891 1
a891 1
	    return 0;
d894 1
a894 22
    return 1;
}
I32
Perl_foldEQ_latin1(const char *s1, const char *s2, register I32 len)
{
    /* Compare non-utf8 using Unicode (Latin1) semantics.  Does not work on
     * MICRO_SIGN, LATIN_SMALL_LETTER_SHARP_S, nor
     * LATIN_SMALL_LETTER_Y_WITH_DIAERESIS, and does not check for these.  Nor
     * does it check that the strings each have at least 'len' characters */

    register const U8 *a = (const U8 *)s1;
    register const U8 *b = (const U8 *)s2;

    PERL_ARGS_ASSERT_FOLDEQ_LATIN1;

    while (len--) {
	if (*a != *b && *a != PL_fold_latin1[*b]) {
	    return 0;
	}
	a++, b++;
    }
    return 1;
a896 9
/*
=for apidoc foldEQ_locale

Returns true if the leading len bytes of the strings s1 and s2 are the same
case-insensitively in the current locale; false otherwise.

=cut
*/

d898 1
a898 1
Perl_foldEQ_locale(const char *s1, const char *s2, register I32 len)
d904 1
a904 1
    PERL_ARGS_ASSERT_FOLDEQ_LOCALE;
d908 1
a908 1
	    return 0;
d911 1
a911 1
    return 1;
d1012 1
a1012 1
    /* PERL_ARGS_ASSERT_SAVESHAREDPVN; */
a1043 19
/*
=for apidoc savesharedsvpv

A version of C<savesharedpv()> which allocates the duplicate string in
memory which is shared between threads.

=cut
*/

char *
Perl_savesharedsvpv(pTHX_ SV *sv)
{
    STRLEN len;
    const char * const pv = SvPV_const(sv, len);

    PERL_ARGS_ASSERT_SAVESHAREDSVPV;

    return savesharedpvn(pv, len);
}
d1054 1
a1054 1
    if (PL_phase != PERL_PHASE_DESTRUCT)
a1126 15
/*
=for apidoc Am|SV *|mess|const char *pat|...

Take a sprintf-style format pattern and argument list.  These are used to
generate a string message.  If the message does not end with a newline,
then it will be extended with some indication of the current location
in the code, as described for L</mess_sv>.

Normally, the resulting message is returned in a new mortal SV.
During global destruction a single SV may be shared between uses of
this function.

=cut
*/

a1188 24
/*
=for apidoc Am|SV *|mess_sv|SV *basemsg|bool consume

Expands a message, intended for the user, to include an indication of
the current location in the code, if the message does not already appear
to be complete.

C<basemsg> is the initial message or object.  If it is a reference, it
will be used as-is and will be the result of this function.  Otherwise it
is used as a string, and if it already ends with a newline, it is taken
to be complete, and the result of this function will be the same string.
If the message does not end with a newline, then a segment such as C<at
foo.pl line 37> will be appended, and possibly other clauses indicating
the current state of execution.  The resulting message will end with a
dot and a newline.

Normally, the resulting message is returned in a new mortal SV.
During global destruction a single SV may be shared between uses of this
function.  If C<consume> is true, then the function is permitted (but not
required) to modify and return C<basemsg> instead of allocating a new SV.

=cut
*/

d1190 1
a1190 1
Perl_mess_sv(pTHX_ SV *basemsg, bool consume)
d1193 1
a1193 1
    SV *sv;
d1195 1
a1195 20
    PERL_ARGS_ASSERT_MESS_SV;

    if (SvROK(basemsg)) {
	if (consume) {
	    sv = basemsg;
	}
	else {
	    sv = mess_alloc();
	    sv_setsv(sv, basemsg);
	}
	return sv;
    }

    if (SvPOK(basemsg) && consume) {
	sv = basemsg;
    }
    else {
	sv = mess_alloc();
	sv_copypv(sv, basemsg);
    }
d1197 1
d1219 2
a1220 4
	    Perl_sv_catpvf(aTHX_ sv, ", <%"SVf"> %s %"IVdf,
			   SVfARG(PL_last_in_gv == PL_argvgv
                                 ? &PL_sv_no
                                 : sv_2mortal(newSVhek(GvNAME_HEK(PL_last_in_gv)))),
d1224 1
a1224 1
	if (PL_phase == PERL_PHASE_DESTRUCT)
a1230 28
/*
=for apidoc Am|SV *|vmess|const char *pat|va_list *args

C<pat> and C<args> are a sprintf-style format pattern and encapsulated
argument list.  These are used to generate a string message.  If the
message does not end with a newline, then it will be extended with
some indication of the current location in the code, as described for
L</mess_sv>.

Normally, the resulting message is returned in a new mortal SV.
During global destruction a single SV may be shared between uses of
this function.

=cut
*/

SV *
Perl_vmess(pTHX_ const char *pat, va_list *args)
{
    dVAR;
    SV * const sv = mess_alloc();

    PERL_ARGS_ASSERT_VMESS;

    sv_vsetpvfn(sv, pat, strlen(pat), args, NULL, 0, NULL);
    return mess_sv(sv, 1);
}

d1243 22
a1264 2
	Perl_magic_methcall(aTHX_ MUTABLE_SV(io), mg, "PRINT",
			    G_SCALAR | G_DISCARD | G_WRITING_TO_STDERR, 1, msv);
d1271 2
d1274 1
a1274 1
	do_print(msv, serr);
d1282 1
a1282 17
/*
=head1 Warning and Dieing
*/

/* Common code used in dieing and warning */

STATIC SV *
S_with_queued_errors(pTHX_ SV *ex)
{
    PERL_ARGS_ASSERT_WITH_QUEUED_ERRORS;
    if (PL_errors && SvCUR(PL_errors) && !SvROK(ex)) {
	sv_catsv(PL_errors, ex);
	ex = sv_mortalcopy(PL_errors);
	SvCUR_set(PL_errors, 0);
    }
    return ex;
}
d1285 1
a1285 1
S_invoke_exception_hook(pTHX_ SV *ex, bool warn)
d1295 1
a1295 2
    if (!oldhook)
	return FALSE;
d1304 1
a1304 1
	SV *exarg;
d1312 8
a1319 3
	exarg = newSVsv(ex);
	SvREADONLY_on(exarg);
	SAVEFREESV(exarg);
d1323 1
a1323 1
	XPUSHs(exarg);
d1333 5
a1337 2
/*
=for apidoc Am|OP *|die_sv|SV *baseex
d1339 13
a1351 3
Behaves the same as L</croak_sv>, except for the return type.
It should be used only where the C<OP *> return type is required.
The function never actually returns.
d1353 5
a1357 2
=cut
*/
d1359 2
a1360 2
OP *
Perl_die_sv(pTHX_ SV *baseex)
d1362 6
a1367 2
    PERL_ARGS_ASSERT_DIE_SV;
    croak_sv(baseex);
a1371 10
/*
=for apidoc Am|OP *|die|const char *pat|...

Behaves the same as L</croak>, except for the return type.
It should be used only where the C<OP *> return type is required.
The function never actually returns.

=cut
*/

d1377 1
d1380 1
a1380 2
    vcroak(pat, &args);
    /* NOTREACHED */
d1382 1
a1382 1
    return NULL;
d1389 1
d1392 1
a1392 2
    vcroak(pat, &args);
    /* NOTREACHED */
d1394 1
a1394 1
    return NULL;
a1396 21
/*
=for apidoc Am|void|croak_sv|SV *baseex

This is an XS interface to Perl's C<die> function.

C<baseex> is the error message or object.  If it is a reference, it
will be used as-is.  Otherwise it is used as a string, and if it does
not end with a newline then it will be extended with some indication of
the current location in the code, as described for L</mess_sv>.

The error message or object will be used as an exception, by default
returning control to the nearest enclosing C<eval>, but subject to
modification by a C<$SIG{__DIE__}> handler.  In any case, the C<croak_sv>
function never returns normally.

To die with a simple string message, the L</croak> function may be
more convenient.

=cut
*/

d1398 1
a1398 1
Perl_croak_sv(pTHX_ SV *baseex)
d1400 2
a1401 8
    SV *ex = with_queued_errors(mess_sv(baseex, 0));
    PERL_ARGS_ASSERT_CROAK_SV;
    invoke_exception_hook(ex, FALSE);
    die_unwind(ex);
}

/*
=for apidoc Am|void|vcroak|const char *pat|va_list *args
d1403 1
a1403 1
This is an XS interface to Perl's C<die> function.
d1405 1
a1405 26
C<pat> and C<args> are a sprintf-style format pattern and encapsulated
argument list.  These are used to generate a string message.  If the
message does not end with a newline, then it will be extended with
some indication of the current location in the code, as described for
L</mess_sv>.

The error message will be used as an exception, by default
returning control to the nearest enclosing C<eval>, but subject to
modification by a C<$SIG{__DIE__}> handler.  In any case, the C<croak>
function never returns normally.

For historical reasons, if C<pat> is null then the contents of C<ERRSV>
(C<$@@>) will be used as an error message or object instead of building an
error message from arguments.  If you want to throw a non-string object,
or build an error message in an SV yourself, it is preferable to use
the L</croak_sv> function, which does not involve clobbering C<ERRSV>.

=cut
*/

void
Perl_vcroak(pTHX_ const char* pat, va_list *args)
{
    SV *ex = with_queued_errors(pat ? vmess(pat, args) : mess_sv(ERRSV, 0));
    invoke_exception_hook(ex, FALSE);
    die_unwind(ex);
a1407 24
/*
=for apidoc Am|void|croak|const char *pat|...

This is an XS interface to Perl's C<die> function.

Take a sprintf-style format pattern and argument list.  These are used to
generate a string message.  If the message does not end with a newline,
then it will be extended with some indication of the current location
in the code, as described for L</mess_sv>.

The error message will be used as an exception, by default
returning control to the nearest enclosing C<eval>, but subject to
modification by a C<$SIG{__DIE__}> handler.  In any case, the C<croak>
function never returns normally.

For historical reasons, if C<pat> is null then the contents of C<ERRSV>
(C<$@@>) will be used as an error message or object instead of building an
error message from arguments.  If you want to throw a non-string object,
or build an error message in an SV yourself, it is preferable to use
the L</croak_sv> function, which does not involve clobbering C<ERRSV>.

=cut
*/

a1420 10
void
Perl_croak(pTHX_ const char *pat, ...)
{
    va_list args;
    va_start(args, pat);
    vcroak(pat, &args);
    /* NOTREACHED */
    va_end(args);
}

d1422 1
a1422 8
=for apidoc Am|void|croak_no_modify

Exactly equivalent to C<Perl_croak(aTHX_ "%s", PL_no_modify)>, but generates
terser object code than using C<Perl_croak>. Less code used on exception code
paths reduces CPU cache pressure.

=cut
*/
d1424 1
a1424 15
void
Perl_croak_no_modify(pTHX)
{
    Perl_croak(aTHX_ "%s", PL_no_modify);
}

/*
=for apidoc Am|void|warn_sv|SV *baseex

This is an XS interface to Perl's C<warn> function.

C<baseex> is the error message or object.  If it is a reference, it
will be used as-is.  Otherwise it is used as a string, and if it does
not end with a newline then it will be extended with some indication of
the current location in the code, as described for L</mess_sv>.
d1426 11
a1436 5
The error message or object will by default be written to standard error,
but this is subject to modification by a C<$SIG{__WARN__}> handler.

To warn with a simple string message, the L</warn> function may be
more convenient.
d1442 1
a1442 1
Perl_warn_sv(pTHX_ SV *baseex)
d1444 5
a1448 4
    SV *ex = mess_sv(baseex, 0);
    PERL_ARGS_ASSERT_WARN_SV;
    if (!invoke_exception_hook(ex, TRUE))
	write_to_stderr(ex);
a1450 19
/*
=for apidoc Am|void|vwarn|const char *pat|va_list *args

This is an XS interface to Perl's C<warn> function.

C<pat> and C<args> are a sprintf-style format pattern and encapsulated
argument list.  These are used to generate a string message.  If the
message does not end with a newline, then it will be extended with
some indication of the current location in the code, as described for
L</mess_sv>.

The error message or object will by default be written to standard error,
but this is subject to modification by a C<$SIG{__WARN__}> handler.

Unlike with L</vcroak>, C<pat> is not permitted to be null.

=cut
*/

d1454 3
a1456 1
    SV *ex = vmess(pat, args);
a1457 3
    if (!invoke_exception_hook(ex, TRUE))
	write_to_stderr(ex);
}
d1459 4
a1462 2
/*
=for apidoc Am|void|warn|const char *pat|...
d1464 2
a1465 14
This is an XS interface to Perl's C<warn> function.

Take a sprintf-style format pattern and argument list.  These are used to
generate a string message.  If the message does not end with a newline,
then it will be extended with some indication of the current location
in the code, as described for L</mess_sv>.

The error message or object will by default be written to standard error,
but this is subject to modification by a C<$SIG{__WARN__}> handler.

Unlike with L</croak>, C<pat> is not permitted to be null.

=cut
*/
d1480 9
d1556 5
a1560 2
	invoke_exception_hook(msv, FALSE);
	die_unwind(msv);
d1628 1
a1628 2
    const MEM_SIZE len_wanted =
	sizeof(STRLEN) + (size > WARNsize ? size : WARNsize);
a1637 2
    if (size < WARNsize)
	Zero((char *)(buffer + 1) + size, WARNsize - size, char);
d2369 1
a2369 1
		Perl_croak(aTHX_ "panic: kid popen errno read, n=%u", n);
d2438 1
d2484 9
d2535 1
a2535 1
		Perl_croak(aTHX_ "panic: kid popen errno read, n=%u", n);
d2852 1
a2852 1
    Pid_t pid2 = 0;
a2854 1
    const int fd = PerlIO_fileno(ptr);
d2856 1
a2856 9
#ifdef USE_PERLIO
    /* Find out whether the refcount is low enough for us to wait for the
       child proc without blocking. */
    const bool should_wait = PerlIOUnix_refcnt(fd) == 1;
#else
    const bool should_wait = 1;
#endif

    svp = av_fetch(PL_fdpid,fd,TRUE);
d2875 1
a2875 1
    if (should_wait) do {
d2887 1
a2887 5
    return(
      should_wait
       ? pid2 < 0 ? pid2 : status == 0 ? 0 : (errno = 0, status)
       : 0
    );
d3032 1
a3032 1
Perl_repeatcpy(register char *to, register const char *from, I32 len, register IV count)
a3035 3
    if (count < 0)
	Perl_croak_nocontext("%s",PL_memory_wrap);

d3040 1
a3040 1
	IV items, linear, half;
d3045 1
a3045 1
	    IV todo;
d3052 1
a3052 1
	    IV size = items * len;
a3308 1
		/* diag_listed_as: Can't execute %s */
d3332 2
a3333 3
    int error = pthread_getspecific(PL_thr_key, &t)
    if (error)
	Perl_croak_nocontext("panic: pthread_getspecific, error=%d", error);
d3356 2
a3357 5
    {
	const int error = pthread_setspecific(PL_thr_key, t);
	if (error)
	    Perl_croak_nocontext("panic: pthread_setspecific, error=%d", error);
    }
d3427 1
d3430 95
a3524 2
    return (vtbl_id < 0 || vtbl_id >= magic_vtable_max)
	? NULL : PL_magic_vtables + vtbl_id;
d3578 1
a3578 1
Perl_report_wrongway_fh(pTHX_ const GV *gv, const char have)
d3580 63
a3642 14
    if (ckWARN(WARN_IO)) {
        SV * const name
           = gv && (isGV(gv) || isGV_with_GP(gv))
                ? sv_2mortal(newSVhek(GvENAME_HEK((gv))))
                : NULL;
	const char * const direction = have == '>' ? "out" : "in";

	if (name && SvPOK(name) && *SvPV_nolen(name))
	    Perl_warner(aTHX_ packWARN(WARN_IO),
			"Filehandle %"SVf" opened only for %sput",
			name, direction);
	else
	    Perl_warner(aTHX_ packWARN(WARN_IO),
			"Filehandle opened only for %sput", direction);
d3646 6
a3651 2
void
Perl_report_evil_fh(pTHX_ const GV *gv)
d3653 9
a3661 13
    const IO *io = gv ? GvIO(gv) : NULL;
    const PERL_BITFIELD16 op = PL_op->op_type;
    const char *vile;
    I32 warn_type;

    if (io && IoTYPE(io) == IoTYPE_CLOSED) {
	vile = "closed";
	warn_type = WARN_CLOSED;
    }
    else {
	vile = "unopened";
	warn_type = WARN_UNOPENED;
    }
d3663 19
a3681 27
    if (ckWARN(warn_type)) {
        SV * const name
            = gv && (isGV(gv) || isGV_with_GP(gv)) && GvENAMELEN(gv) ?
                                     sv_2mortal(newSVhek(GvENAME_HEK(gv))) : NULL;
	const char * const pars =
	    (const char *)(OP_IS_FILETEST(op) ? "" : "()");
	const char * const func =
	    (const char *)
	    (op == OP_READLINE   ? "readline"  :	/* "<HANDLE>" not nice */
	     op == OP_LEAVEWRITE ? "write" :		/* "write exit" not nice */
	     PL_op_desc[op]);
	const char * const type =
	    (const char *)
	    (OP_IS_SOCKET(op) || (io && IoTYPE(io) == IoTYPE_SOCKET)
	     ? "socket" : "filehandle");
	const bool have_name = name && SvPOK(name) && *SvPV_nolen(name);
	Perl_warner(aTHX_ packWARN(warn_type),
		   "%s%s on %s %s%s%"SVf, func, pars, vile, type,
		    have_name ? " " : "",
		    SVfARG(have_name ? name : &PL_sv_no));
	if (io && IoDIRP(io) && !(IoFLAGS(io) & IOf_FAKE_DIRP))
		Perl_warner(
			    aTHX_ packWARN(warn_type),
			"\t(Are you trying to call %s%s on dirhandle%s%"SVf"?)\n",
			func, pars, have_name ? " " : "",
			SVfARG(have_name ? name : &PL_sv_no)
			    );
d3684 1
d3806 1
a3806 1
 * were leap years in the Julian calendar but not in the Gregorian one.
d3985 1
a3985 1
    Renew(buf, bufsize, char);
a4187 5
Validate that a given string can be parsed as a version object, but doesn't
actually perform the parsing.  Can use either strict or lax validation rules.
Can optionally set a number of hint variables to save the parsing code
some time when tokenizing.

a4292 5
	/* and we never support negative versions */
	if ( *d == '-') {
	    BADVERSION(s,errstr,"Invalid version format (negative version number)");
	}

d4303 1
a4303 1
	else if (!*d || *d == ';' || isSPACE(*d) || *d == '{' || *d == '}') {
d4334 1
a4334 1
	if (!isDIGIT(*d) && (strict || ! (!*d || *d == ';' || isSPACE(*d) || *d == '{' || *d == '}') )) {
d4372 1
a4372 1
    if (!isDIGIT(*d) && (! (!*d || *d == ';' || *d == '{' || *d == '}') )) {
d4603 1
a4603 2
    if ( sv_isobject(ver) && sv_derived_from(ver, "version") )
	 /* can just copy directly */
a4694 2
	STRLEN len;

a4696 2
	SV *sv = SvNVX(ver) > 10e50 ? newSV(64) : 0;
	char *buf;
d4698 1
a4698 2
	char *loc = savepv(setlocale(LC_NUMERIC, NULL));
	setlocale(LC_NUMERIC, "C");
d4700 1
a4700 8
	if (sv) {
	    Perl_sv_setpvf(aTHX_ sv, "%.9"NVff, SvNVX(ver));
	    buf = SvPV(sv, len);
	}
	else {
	    len = my_snprintf(tbuf, sizeof(tbuf), "%.9"NVff, SvNVX(ver));
	    buf = tbuf;
	}
a4702 1
	Safefree(loc);
d4704 3
a4706 4
	while (buf[len-1] == '0' && len > 0) len--;
	if ( buf[len-1] == '.' ) len--; /* eat the trailing decimal */
	version = savepvn(buf, len);
	SvREFCNT_dec(sv);
d4721 3
a4723 1
	if ( len >= 3 && !instr(version,".") && !instr(version,"_")) {
d4725 19
a4743 27
	    char *testv = (char *)version;
	    STRLEN tlen = len;
	    for (tlen=0; tlen < len; tlen++, testv++) {
		/* if one of the characters is non-text assume v-string */
		if (testv[0] < ' ') {
		    SV * const nsv = sv_newmortal();
		    const char *nver;
		    const char *pos;
		    int saw_decimal = 0;
		    sv_setpvf(nsv,"v%vd",ver);
		    pos = nver = savepv(SvPV_nolen(nsv));

		    /* scan the resulting formatted string */
		    pos++; /* skip the leading 'v' */
		    while ( *pos == '.' || isDIGIT(*pos) ) {
			if ( *pos == '.' )
			    saw_decimal++ ;
			pos++;
		    }

		    /* is definitely a v-string */
		    if ( saw_decimal >= 2 ) {	
			Safefree(version);
			version = nver;
		    }
		    break;
		}
d4762 1
a4762 4
Validates that the SV contains valid internal structure for a version object.
It may be passed either the version object (RV) or the hash itself (HV).  If
the structure is valid, it returns the HV.  If the structure is invalid,
it returns NULL.
d4764 1
a4764 1
    SV *hv = vverify(sv);
d4771 1
a4771 1
=item * The SV is an HV or a reference to an HV
d4775 1
a4775 1
=item * The "version" key has a reference to an AV as its value
d4782 1
a4782 1
SV *
d4797 1
a4797 1
	return vs;
d4799 1
a4799 1
	return NULL;
a4812 2
The SV returned has a refcount of 1.

d4827 4
a4830 3
    /* extract the HV from the object */
    vs = vverify(vs);
    if ( ! vs )
a4892 2
The SV returned has a refcount of 1.

d4906 4
a4909 3
    /* extract the HV from the object */
    vs = vverify(vs);
    if ( ! vs )
d4951 1
a4951 3
the original version contained 1 or more dots, respectively.

The SV returned has a refcount of 1.
d4961 4
a4964 3
    /* extract the HV from the object */
    vs = vverify(vs);
    if ( ! vs )
d5004 9
a5012 4
    /* extract the HVs from the objects */
    lhv = vverify(lhv);
    rhv = vverify(rhv);
    if ( ! ( lhv && rhv ) )
d5329 1
a5329 1
 * to the my_socketpair in embed.fnc. */
d5392 1
a5392 3
	    if (*p && *p != '\n' && *p != '\r') {
	     if(isSPACE(*p)) goto the_end_of_the_opts_parser;
	     else
a5393 1
	    }
d5419 1
a5419 3
		      if (*p != '\n' && *p != '\r') {
			if(isSPACE(*p)) goto the_end_of_the_opts_parser;
			else
a5421 1
		      }
a5428 2
  the_end_of_the_opts_parser:

d5563 2
a5564 4
    const char * stashpv = CopSTASHPV(c);
    const char * name    = HvNAME_get(hv);
    const bool utf8 = CopSTASH_len(c) < 0;
    const I32  len  = utf8 ? -CopSTASH_len(c) : CopSTASH_len(c);
d5568 5
a5572 18
    if (!stashpv || !name)
	return stashpv == name;
    if ( !HvNAMEUTF8(hv) != !utf8 ) {
        if (utf8) {
            return (bytes_cmp_utf8(
                        (const U8*)stashpv, len,
                        (const U8*)name, HEK_LEN(HvNAME_HEK(hv))) == 0);
        } else {
            return (bytes_cmp_utf8(
                        (const U8*)name, HEK_LEN(HvNAME_HEK(hv)),
                        (const U8*)stashpv, len) == 0);
        }
    }
    else
        return (stashpv == name
                    || (HEK_LEN(HvNAME_HEK(hv)) == len
			 && memEQ(stashpv, name, len)));
    /*NOTREACHED*/
d5602 6
a5607 4
#  define PERLVAR(prefix,var,type) /**/
#  define PERLVARA(prefix,var,n,type) /**/
#  define PERLVARI(prefix,var,type,init) plvarsp->prefix##var = init;
#  define PERLVARIC(prefix,var,type,init) plvarsp->prefix##var = init;
d5613 1
d5789 1
a5789 1
   own implementation, but is getting these functions anyway, and they
d5898 2
a5899 8
    /* vsprintf() shows failure with < 0 */
    if (retval < 0
#ifdef HAS_VSNPRINTF
    /* vsnprintf() shows failure with >= len */
        ||
        (len > 0 && (Size_t)retval >= len) 
#endif
    )
d5938 2
a5939 8
    /* vsprintf() shows failure with < 0 */
    if (retval < 0
#ifdef HAS_VSNPRINTF
    /* vsnprintf() shows failure with >= len */
        ||
        (len > 0 && (Size_t)retval >= len) 
#endif
    )
a6116 78
void
Perl_xs_version_bootcheck(pTHX_ U32 items, U32 ax, const char *xs_p,
			  STRLEN xs_len)
{
    SV *sv;
    const char *vn = NULL;
    SV *const module = PL_stack_base[ax];

    PERL_ARGS_ASSERT_XS_VERSION_BOOTCHECK;

    if (items >= 2)	 /* version supplied as bootstrap arg */
	sv = PL_stack_base[ax + 1];
    else {
	/* XXX GV_ADDWARN */
	vn = "XS_VERSION";
	sv = get_sv(Perl_form(aTHX_ "%"SVf"::%s", module, vn), 0);
	if (!sv || !SvOK(sv)) {
	    vn = "VERSION";
	    sv = get_sv(Perl_form(aTHX_ "%"SVf"::%s", module, vn), 0);
	}
    }
    if (sv) {
	SV *xssv = Perl_newSVpvn_flags(aTHX_ xs_p, xs_len, SVs_TEMP);
	SV *pmsv = sv_isobject(sv) && sv_derived_from(sv, "version")
	    ? sv : sv_2mortal(new_version(sv));
	xssv = upg_version(xssv, 0);
	if ( vcmp(pmsv,xssv) ) {
	    SV *string = vstringify(xssv);
	    SV *xpt = Perl_newSVpvf(aTHX_ "%"SVf" object version %"SVf
				    " does not match ", module, string);

	    SvREFCNT_dec(string);
	    string = vstringify(pmsv);

	    if (vn) {
		Perl_sv_catpvf(aTHX_ xpt, "$%"SVf"::%s %"SVf, module, vn,
			       string);
	    } else {
		Perl_sv_catpvf(aTHX_ xpt, "bootstrap parameter %"SVf, string);
	    }
	    SvREFCNT_dec(string);

	    Perl_sv_2mortal(aTHX_ xpt);
	    Perl_croak_sv(aTHX_ xpt);
	}
    }
}

void
Perl_xs_apiversion_bootcheck(pTHX_ SV *module, const char *api_p,
			     STRLEN api_len)
{
    SV *xpt = NULL;
    SV *compver = Perl_newSVpvn_flags(aTHX_ api_p, api_len, SVs_TEMP);
    SV *runver;

    PERL_ARGS_ASSERT_XS_APIVERSION_BOOTCHECK;

    /* This might croak  */
    compver = upg_version(compver, 0);
    /* This should never croak */
    runver = new_version(PL_apiversion);
    if (vcmp(compver, runver)) {
	SV *compver_string = vstringify(compver);
	SV *runver_string = vstringify(runver);
	xpt = Perl_newSVpvf(aTHX_ "Perl API version %"SVf
			    " of %"SVf" does not match %"SVf,
			    compver_string, module, runver_string);
	Perl_sv_2mortal(aTHX_ xpt);

	SvREFCNT_dec(compver_string);
	SvREFCNT_dec(runver_string);
    }
    SvREFCNT_dec(runver);
    if (xpt)
	Perl_croak_sv(aTHX_ xpt);
}

a6155 13
PERL_STATIC_INLINE bool
S_gv_has_usable_name(pTHX_ GV *gv)
{
    GV **gvp;
    return GvSTASH(gv)
	&& HvENAME(GvSTASH(gv))
	&& (gvp = (GV **)hv_fetch(
			GvSTASH(gv), GvNAME(gv),
			GvNAMEUTF8(gv) ? -GvNAMELEN(gv) : GvNAMELEN(gv), 0
	   ))
	&& *gvp == gv;
}

d6161 1
a6161 4
    const bool save_taint = PL_tainted;

    /* When we are called from pp_goto (svp is null),
     * we do not care about using dbsv to call CV;
a6166 1
    PL_tainted = FALSE;
d6169 1
a6169 1
	GV *gv = CvGV(cv);
d6171 1
a6171 4
	if (!svp) {
	    gv_efullname3(dbsv, gv, NULL);
	}
	else if ( (CvFLAGS(cv) & (CVf_ANON | CVf_CLONED))
d6173 1
a6173 3
	     || ( /* Could be imported, and old sub redefined. */
		 (GvCV(gv) != cv || !S_gv_has_usable_name(aTHX_ gv))
		 &&
d6175 2
a6176 6
		    && (GvCV((const GV *)*svp) == cv)
		    /* Use GV from the stack as a fallback. */
		    && S_gv_has_usable_name(aTHX_ gv = (GV *)*svp) 
		  )
		)
	) {
d6183 1
a6183 6
	    sv_sethek(dbsv, HvENAME_HEK(GvSTASH(gv)));
	    sv_catpvs(dbsv, "::");
	    sv_catpvn_flags(
	      dbsv, GvNAME(gv), GvNAMELEN(gv),
	      GvNAMEUTF8(gv) ? SV_CATUTF8 : SV_CATBYTES
	    );
a6192 1
    TAINT_IF(save_taint);
@


1.1.1.15
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@a26 1
#include "reentr.h"
d62 11
d134 1
a134 1
	    croak_no_mem();
d237 1
a237 1
	    croak_no_mem();
d310 1
a310 1
	Perl_croak_memory_wrap();
d315 1
a315 1
	Perl_croak_memory_wrap();
d371 1
a371 1
	croak_no_mem();
d409 1
a409 1
Perl_delimcpy(char *to, const char *toend, const char *from, const char *fromend, int delim, I32 *retlen)
d411 1
a411 1
    I32 tolen;
d439 1
a439 1
Perl_instr(const char *big, const char *little)
d441 1
a444 1
    /* libc prior to 4.6.27 did not work properly on a NULL 'little' */
d447 21
a467 1
    return strstr((char*)big, (char*)little);
d500 1
a500 1
Perl_rninstr(const char *big, const char *bigend, const char *little, const char *lend)
d502 3
a504 3
    const char *bigbeg;
    const I32 first = *little;
    const char * const littleend = lend;
d513 1
a513 1
	const char *s, *x;
d551 1
a551 1
    const U8 *s;
d560 5
a564 1
    if (isGV_with_GP(sv))
d607 1
a607 1
	U8 *table;
d646 2
a647 2
Returns the location of the SV in the string delimited by C<big> and
C<bigend>.  It returns C<NULL> if the string can't be found.  The C<sv>
d655 1
a655 1
Perl_fbm_instr(pTHX_ unsigned char *big, unsigned char *bigend, SV *littlestr, U32 flags)
d657 1
a657 1
    unsigned char *s;
d659 4
a662 3
    const unsigned char *little = (const unsigned char *)SvPV_const(littlestr,l);
    STRLEN littlelen = l;
    const I32 multiline = flags & FBMrf_MULTILINE;
d798 1
a798 1
	const unsigned char *oldlittle;
d806 1
a806 1
	    I32 tmp;
d815 1
a815 1
		unsigned char * const olds = s;
d841 15
d860 12
d873 136
a1008 10
    PERL_UNUSED_ARG(bigstr);
    PERL_UNUSED_ARG(littlestr);
    PERL_UNUSED_ARG(start_shift);
    PERL_UNUSED_ARG(end_shift);
    PERL_UNUSED_ARG(old_posp);
    PERL_UNUSED_ARG(last);

    /* This function must only ever be called on a scalar with study magic,
       but those do not happen any more. */
    Perl_croak(aTHX_ "panic: screaminstr");
d1025 1
a1025 1
Perl_foldEQ(const char *s1, const char *s2, I32 len)
d1027 2
a1028 2
    const U8 *a = (const U8 *)s1;
    const U8 *b = (const U8 *)s2;
a1031 2
    assert(len >= 0);

d1040 1
a1040 1
Perl_foldEQ_latin1(const char *s1, const char *s2, I32 len)
d1047 2
a1048 2
    const U8 *a = (const U8 *)s1;
    const U8 *b = (const U8 *)s2;
a1051 2
    assert(len >= 0);

d1071 1
a1071 1
Perl_foldEQ_locale(const char *s1, const char *s2, I32 len)
d1074 2
a1075 2
    const U8 *a = (const U8 *)s1;
    const U8 *b = (const U8 *)s2;
a1078 2
    assert(len >= 0);

d1130 1
a1130 1
Perl_savepvn(pTHX_ const char *pv, I32 len)
d1132 1
a1132 1
    char *newaddr;
a1134 2
    assert(len >= 0);

d1158 1
a1158 1
    char *newaddr;
d1166 1
a1166 1
	croak_no_mem();
d1188 1
a1188 1
	croak_no_mem();
d1208 1
a1208 1
    char *newaddr;
a1465 1
	    STRLEN l;
d1467 1
a1467 1
				   *SvPV_const(PL_rs,l) == '\n' && l == 1);
d1617 1
a1617 1
    assert(0); /* NOTREACHED */
d1639 1
a1639 1
    assert(0); /* NOTREACHED */
d1651 1
a1651 1
    assert(0); /* NOTREACHED */
d1751 1
a1751 1
    assert(0); /* NOTREACHED */
d1762 1
a1762 1
    assert(0); /* NOTREACHED */
d1777 1
a1777 22
Perl_croak_no_modify()
{
    Perl_croak_nocontext( "%s", PL_no_modify);
}

/* does not return, used in util.c perlio.c and win32.c
   This is typically called when malloc returns NULL.
*/
void
Perl_croak_no_mem()
{
    dTHX;

    /* Can't use PerlIO to write as it allocates memory */
    PerlLIO_write(PerlIO_fileno(Perl_error_log),
		  PL_no_mem, sizeof(PL_no_mem)-1);
    my_exit(1);
}

/* saves machine code for a common noreturn idiom typically used in Newx*() */
void
Perl_croak_memory_wrap(void)
d1779 1
a1779 11
    Perl_croak_nocontext("%s",PL_memory_wrap);
}


/* does not return, used only in POPSTACK */
void
Perl_croak_popstack(void)
{
    dTHX;
    PerlIO_printf(Perl_error_log, "panic: POPSTACK\n");
    my_exit(1);
d2046 2
a2047 2
    I32 i;
    const I32 len = strlen(nam);
d2095 1
a2095 1
#   if defined(__CYGWIN__)|| defined(__SYMBIAN32__) || defined(__riscos__)
d2108 1
a2108 2
            if (environ) /* old glibc can crash with null environ */
                (void)unsetenv(nam);
d2143 1
a2143 1
    char *envstr;
d2159 1
a2159 1
#endif /* !VMS */
d2178 1
a2178 1
Perl_my_bcopy(const char *from, char *to, I32 len)
a2183 2
    assert(len >= 0);

d2201 1
a2201 1
Perl_my_memset(char *loc, I32 ch, I32 len)
a2206 2
    assert(len >= 0);

d2216 1
a2216 1
Perl_my_bzero(char *loc, I32 len)
a2221 2
    assert(len >= 0);

d2231 1
a2231 1
Perl_my_memcmp(const char *s1, const char *s2, I32 len)
d2233 3
a2235 3
    const U8 *a = (const U8 *)s1;
    const U8 *b = (const U8 *)s2;
    I32 tmp;
a2238 2
    assert(len >= 0);

d2338 2
a2339 2
    I32 o;
    I32 s;
d2367 2
a2368 2
    I32 o;
    I32 s;
d2393 1
a2393 1
	name (type n)					        \
d2399 2
a2400 2
	    U32 i;					        \
	    U32 s = 0;					        \
d2409 1
a2409 1
	name (type n)					        \
d2415 2
a2416 2
	    U32 i;					        \
	    U32 s = 0;					        \
d2431 1
a2431 1
	name (type n)					        \
d2437 2
a2438 2
	    U32 i;					        \
	    U32 s = 8*(sizeof(u.c)-1);			        \
d2447 1
a2447 1
	name (type n)					        \
d2453 2
a2454 2
	    U32 i;					        \
	    U32 s = 8*(sizeof(u.c)-1);			        \
d2469 1
a2469 1
        name (type n)                                           \
d2618 3
a2620 3
    char *s = (char *)ptr;
    char *e = s + (n-1);
    char tc;
d2634 1
a2634 1
#if (!defined(DOSISH) || defined(HAS_FORK) || defined(AMIGAOS)) && !defined(OS2) && !defined(VMS) && !defined(NETWARE) && !defined(__LIBCATAMOUNT__)
d2637 2
a2638 2
    I32 This, that;
    Pid_t pid;
d2648 1
a2648 1
    if (TAINTING_get) {
d2771 1
a2771 1
#if (!defined(DOSISH) || defined(HAS_FORK) || defined(AMIGAOS)) && !defined(VMS) && !defined(__LIBCATAMOUNT__)
d2777 2
a2778 2
    I32 This, that;
    Pid_t pid;
d2794 1
a2794 1
    if (doexec && TAINTING_get) {
d2918 14
d2953 1
a2963 3
#  ifdef USE_PERLIO
    MUTEX_LOCK(&PL_perlio_mutex);
#  endif
a2977 3
#  ifdef USE_PERLIO
    MUTEX_UNLOCK(&PL_perlio_mutex);
#  endif
d3213 1
a3213 1
#if (!defined(DOSISH) || defined(HAS_FORK) || defined(AMIGAOS)) && !defined(VMS) && !defined(__LIBCATAMOUNT__)
d3246 3
d3371 1
a3371 1
    SV *sv;
d3380 1
a3380 1
#if defined(OS2)
d3415 1
a3415 1
Perl_repeatcpy(char *to, const char *from, I32 len, IV count)
a3418 2
    assert(len >= 0);

d3420 1
a3420 1
	Perl_croak_memory_wrap();
d3425 1
a3425 1
	char *p = to;
d3430 1
a3430 1
	    const char *q = from;
d3496 1
a3496 1
    char *s;
d3500 1
a3500 1
#if defined(DOSISH) && !defined(OS2)
d3623 1
a3623 1
#  ifdef DOSISH
d3625 3
d3634 1
a3634 1
#  else
d3638 1
a3638 1
#  endif
d3644 1
a3644 1
#  ifdef DOSISH
d3878 3
a3880 3
        HEK * const name
           = gv && (isGV_with_GP(gv))
                ? GvENAME_HEK((gv))
d3884 1
a3884 1
	if (name && HEK_LEN(name))
d3886 1
a3886 1
			"Filehandle %"HEKf" opened only for %sput",
d3913 1
a3913 1
            = gv && isGV_with_GP(gv) && GvENAMELEN(gv) ?
d3926 1
a3926 1
	const bool have_name = name && SvCUR(name);
d4072 9
a4080 1
    jday = 0;
d4175 3
a4177 1
    ptm->tm_wday = (jday + WEEKDAY_BIAS) % 7;
d4290 1
a4290 1
Perl_getcwd_sv(pTHX_ SV *sv)
a4542 1
	int j = 0;			/* may need this later */
d4605 1
a4605 1
	    d++; j++;
a4626 1
		width = j;
d4678 1
a4678 1
    const char *start = s;
d4686 2
a4687 2
    AV * av;
    SV * hv;
d4691 6
a4703 1
	    Safefree(start);
a4712 9
    /* Now that we are through the prescan, start creating the object */
    av = newAV();
    hv = newSVrv(rv, "version"); /* create an SV and upgrade the RV */
    (void)sv_upgrade(hv, SVt_PVHV); /* needs to be an HV type */

#ifndef NODEFAULT_SHAREKEYS
    HvSHAREKEYS_on(hv);         /* key-sharing on by default */
#endif

d4719 1
a4719 1

d4890 1
a4890 1

d5024 1
a5024 1
		    if ( saw_decimal >= 2 ) {
d5515 1
a5515 1
    dTHXa(NULL);
a5540 1
    aTHXa(PERL_GET_THX);
a5732 4
#ifdef VMS
#  include <starlet.h>
#endif

d5764 1
d5815 2
a5816 2
void
Perl_get_hash_seed(pTHX_ unsigned char * const seed_buffer)
d5819 2
a5820 2
    const char *env_pv;
    unsigned long i;
d5822 28
a5849 1
    PERL_ARGS_ASSERT_GET_HASH_SEED;
d5851 2
a5852 1
    env_pv= PerlEnv_getenv("PERL_HASH_SEED");
d5854 18
a5871 10
    if ( env_pv )
#ifndef USE_HASH_SEED_EXPLICIT
    {
        /* ignore leading spaces */
        while (isSPACE(*env_pv))
            env_pv++;
#ifdef USE_PERL_PERTURB_KEYS
        /* if they set it to "0" we disable key traversal randomization completely */
        if (strEQ(env_pv,"0")) {
            PL_hash_rand_bits_enabled= 0;
d5873 3
a5875 19
            /* otherwise switch to deterministic mode */
            PL_hash_rand_bits_enabled= 2;
        }
#endif
        /* ignore a leading 0x... if it is there */
        if (env_pv[0] == '0' && env_pv[1] == 'x')
            env_pv += 2;

        for( i = 0; isXDIGIT(*env_pv) && i < PERL_HASH_SEED_BYTES; i++ ) {
            seed_buffer[i] = READ_XDIGIT(env_pv) << 4;
            if ( isXDIGIT(*env_pv)) {
                seed_buffer[i] |= READ_XDIGIT(env_pv);
            }
        }
        while (isSPACE(*env_pv))
            env_pv++;

        if (*env_pv && !isXDIGIT(*env_pv)) {
            Perl_warn(aTHX_ "perl: warning: Non hex character in '$ENV{PERL_HASH_SEED}', seed only partially set\n");
a5876 3
        /* should we check for unparsed crap? */
        /* should we warn about unused hex? */
        /* should we warn about insufficient hex? */
d5879 6
a5885 2
    {
        (void)seedDrand01((Rand_seed_t)seed());
a5886 29
        for( i = 0; i < PERL_HASH_SEED_BYTES; i++ ) {
            seed_buffer[i] = (unsigned char)(Drand01() * (U8_MAX+1));
        }
    }
#ifdef USE_PERL_PERTURB_KEYS
    {   /* initialize PL_hash_rand_bits from the hash seed.
         * This value is highly volatile, it is updated every
         * hash insert, and is used as part of hash bucket chain
         * randomization and hash iterator randomization. */
        PL_hash_rand_bits= 0xbe49d17f; /* I just picked a number */
        for( i = 0; i < sizeof(UV) ; i++ ) {
            PL_hash_rand_bits += seed_buffer[i % PERL_HASH_SEED_BYTES];
            PL_hash_rand_bits = ROTL_UV(PL_hash_rand_bits,8);
        }
    }
    env_pv= PerlEnv_getenv("PERL_PERTURB_KEYS");
    if (env_pv) {
        if (strEQ(env_pv,"0") || strEQ(env_pv,"NO")) {
            PL_hash_rand_bits_enabled= 0;
        } else if (strEQ(env_pv,"1") || strEQ(env_pv,"RANDOM")) {
            PL_hash_rand_bits_enabled= 1;
        } else if (strEQ(env_pv,"2") || strEQ(env_pv,"DETERMINISTIC")) {
            PL_hash_rand_bits_enabled= 2;
        } else {
            Perl_warn(aTHX_ "perl: warning: strange setting in '$ENV{PERL_PERTURB_KEYS}': '%s'\n", env_pv);
        }
    }
#endif
}
d6194 1
d6213 1
a6213 1
	Perl_croak_nocontext("panic: my_snprintf buffer overflow");
d6231 1
d6259 1
a6259 1
	Perl_croak_nocontext("panic: my_vsnprintf buffer overflow");
a6299 1
        bufsiz = bsiz * sizeof(char); /* keep bsiz and bufsiz in sync */
d6571 1
a6571 1
    const bool save_taint = TAINT_get;
d6580 1
a6580 1
    TAINT_set(FALSE);
a6621 3
#ifdef NO_TAINT_SUPPORT
    PERL_UNUSED_VAR(save_taint);
#endif
d6636 1
a6636 1
    assert(0); /* NOT REACHED */
d6660 1
a6660 1
 * indent-tabs-mode: nil
d6663 1
a6663 1
 * ex: set ts=8 sts=4 sw=4 et:
@


1.1.1.16
log
@Import perl-5.20.1
@
text
@d29 1
a29 1
#if defined(USE_PERLIO)
a39 3
#include <math.h>
#include <stdlib.h>

a50 4
#ifdef PERL_DEBUG_READONLY_COW
# include <sys/mman.h>
#endif

a66 34
#if defined(PERL_TRACK_MEMPOOL) && defined(PERL_DEBUG_READONLY_COW)
static void
S_maybe_protect_rw(pTHX_ struct perl_memory_debug_header *header)
{
    if (header->readonly
     && mprotect(header, header->size, PROT_READ|PROT_WRITE))
	Perl_warn(aTHX_ "mprotect for COW string %p %lu failed with %d",
			 header, header->size, errno);
}

static void
S_maybe_protect_ro(pTHX_ struct perl_memory_debug_header *header)
{
    if (header->readonly
     && mprotect(header, header->size, PROT_READ))
	Perl_warn(aTHX_ "mprotect RW for COW string %p %lu failed with %d",
			 header, header->size, errno);
}
# define maybe_protect_rw(foo) S_maybe_protect_rw(aTHX_ foo)
# define maybe_protect_ro(foo) S_maybe_protect_ro(aTHX_ foo)
#else
# define maybe_protect_rw(foo) NOOP
# define maybe_protect_ro(foo) NOOP
#endif

#if defined(PERL_TRACK_MEMPOOL) || defined(PERL_DEBUG_READONLY_COW)
 /* Use memory_debug_header */
# define USE_MDH
# if (defined(PERL_POISON) && defined(PERL_TRACK_MEMPOOL)) \
   || defined(PERL_DEBUG_READONLY_COW)
#  define MDH_HAS_SIZE
# endif
#endif

d76 10
a85 1
    size += PERL_MEMORY_DEBUG_HEADER_SIZE;
d90 1
a90 10
    if (!size) size = 1;	/* malloc(0) is NASTY on our system */
#ifdef PERL_DEBUG_READONLY_COW
    if ((ptr = mmap(0, size, PROT_READ|PROT_WRITE,
		    MAP_ANON|MAP_PRIVATE, -1, 0)) == MAP_FAILED) {
	perror("mmap failed");
	abort();
    }
#else
    ptr = (Malloc_t)PerlMem_malloc(size?size:1);
#endif
d93 1
a93 1
#ifdef USE_MDH
a107 1
	maybe_protect_rw(header->next);
d109 2
a110 3
	maybe_protect_ro(header->next);
#  ifdef PERL_DEBUG_READONLY_COW
	header->readonly = 0;
d112 1
a113 4
#ifdef MDH_HAS_SIZE
	header->size = size;
#endif
        ptr = (Malloc_t)((char*)ptr+PERL_MEMORY_DEBUG_HEADER_SIZE);
a138 5
#ifdef PERL_DEBUG_READONLY_COW
    const MEM_SIZE oldsize = where
	? ((struct perl_memory_debug_header *)((char *)where - PERL_MEMORY_DEBUG_HEADER_SIZE))->size
	: 0;
#endif
d143 7
d157 3
a159 3
#ifdef USE_MDH
    where = (Malloc_t)((char*)where-PERL_MEMORY_DEBUG_HEADER_SIZE);
    size += PERL_MEMORY_DEBUG_HEADER_SIZE;
a163 1
# ifdef PERL_TRACK_MEMPOOL
d176 1
a177 4
# endif
# ifdef MDH_HAS_SIZE
	header->size = size;
# endif
a183 12
#ifdef PERL_DEBUG_READONLY_COW
    if ((ptr = mmap(0, size, PROT_READ|PROT_WRITE,
		    MAP_ANON|MAP_PRIVATE, -1, 0)) == MAP_FAILED) {
	perror("mmap failed");
	abort();
    }
    Copy(where,ptr,oldsize < size ? oldsize : size,char);
    if (munmap(where, oldsize)) {
	perror("munmap failed");
	abort();
    }
#else
a184 1
#endif
d190 1
a191 1
#ifdef PERL_TRACK_MEMPOOL
a202 1
	maybe_protect_rw(header->next);
a203 2
	maybe_protect_ro(header->next);
	maybe_protect_rw(header->prev);
d205 3
a207 1
	maybe_protect_ro(header->prev);
a208 2
        ptr = (Malloc_t)((char*)ptr+PERL_MEMORY_DEBUG_HEADER_SIZE);
    }
d245 2
a246 2
#ifdef USE_MDH
        where = (Malloc_t)((char*)where-PERL_MEMORY_DEBUG_HEADER_SIZE);
a250 4
# ifdef MDH_HAS_SIZE
	    const MEM_SIZE size = header->size;
# endif
# ifdef PERL_TRACK_MEMPOOL
a266 1
	    maybe_protect_rw(header->next);
a267 2
	    maybe_protect_ro(header->next);
	    maybe_protect_rw(header->prev);
a268 2
	    maybe_protect_ro(header->prev);
	    maybe_protect_rw(header);
d270 1
a270 1
	    PoisonNew(where, size, char);
a273 7
# endif
# ifdef PERL_DEBUG_READONLY_COW
	    if (munmap(where, size)) {
		perror("munmap failed");
		abort();
	    }	
# endif
a275 1
#ifndef PERL_DEBUG_READONLY_COW
a276 1
#endif
d289 1
a289 1
#if defined(USE_MDH) || defined(DEBUGGING)
d295 1
a295 1
#if defined(USE_MDH) || defined(DEBUGGING)
d300 4
a303 4
	croak_memory_wrap();
#ifdef USE_MDH
    if (PERL_MEMORY_DEBUG_HEADER_SIZE <= MEM_SIZE_MAX - (MEM_SIZE)total_size)
	total_size += PERL_MEMORY_DEBUG_HEADER_SIZE;
d305 1
a305 1
	croak_memory_wrap();
d307 7
d319 1
a319 7
#ifdef PERL_DEBUG_READONLY_COW
    if ((ptr = mmap(0, total_size ? total_size : 1, PROT_READ|PROT_WRITE,
		    MAP_ANON|MAP_PRIVATE, -1, 0)) == MAP_FAILED) {
	perror("mmap failed");
	abort();
    }
#elif defined(PERL_TRACK_MEMPOOL)
d335 1
a335 1
#ifdef USE_MDH
a339 1
#  ifndef PERL_DEBUG_READONLY_COW
a340 2
#  endif
#  ifdef PERL_TRACK_MEMPOOL
a345 1
	    maybe_protect_rw(header->next);
d347 1
a347 6
	    maybe_protect_ro(header->next);
#    ifdef PERL_DEBUG_READONLY_COW
	    header->readonly = 0;
#    endif
#  endif
#  ifdef MDH_HAS_SIZE
d350 1
a350 1
	    ptr = (Malloc_t)((char*)ptr+PERL_MEMORY_DEBUG_HEADER_SIZE);
d434 1
a434 2
    /* libc prior to 4.6.27 (late 1994) did not work properly on a NULL
     * 'little' */
d524 1
a526 1
    PERL_DEB( STRLEN rarest = 0 );
d530 1
a530 1
    if (isGV_with_GP(sv) || SvROK(sv))
d542 1
a542 3
    if (!SvPOK(sv) || SvNIOKp(sv))
	s = (U8*)SvPV_force_mutable(sv, len);
    else s = (U8 *)SvPV_mutable(sv, len);
d592 1
a592 1
	    PERL_DEB( rarest = i );
d596 2
d602 1
a602 1
			  s[rarest], (UV)rarest));
d912 4
a915 9
Perl's version of C<strdup()>.  Returns a pointer to a newly allocated
string which is a duplicate of C<pv>.  The size of the string is
determined by C<strlen()>, which means it may not contain embedded C<NUL>
characters and must have a trailing C<NUL>.  The memory allocated for the new
string can be freed with the C<Safefree()> function.

On some platforms, Windows for example, all allocated memory owned by a thread
is deallocated when that thread ends.  So if you need that not to happen, you
need to use the shared memory functions, such as C<L</savesharedpv>>.
d939 1
a939 1
Perl's version of what C<strndup()> would be if it existed.  Returns a
d941 1
a941 2
C<len> bytes from C<pv>, plus a trailing
C<NUL> byte.  The memory allocated for
a943 4
On some platforms, Windows for example, all allocated memory owned by a thread
is deallocated when that thread ends.  So if you need that not to happen, you
need to use the shared memory functions, such as C<L</savesharedpvn>>.

d995 1
a995 1
which is shared between threads.  (With the specific difference that a NULL
a1019 4
On some platforms, Windows for example, all allocated memory owned by a thread
is deallocated when that thread ends.  So if you need that not to happen, you
need to use the shared memory functions, such as C<L</savesharedsvpv>>.

d1181 2
a1182 3
const COP*
Perl_closest_cop(pTHX_ const COP *cop, const OP *o, const OP *curop,
		       bool opnext)
d1185 1
a1185 3
    /* Look for curop starting from o.  cop is the last COP we've seen. */
    /* opnext means that curop is actually the ->op_next of the op we are
       seeking. */
d1189 1
a1189 3
    if (!o || !curop || (
	opnext ? o->op_next == curop && o->op_type != OP_SCOPE : o == curop
    ))
d1205 1
a1205 1
	    new_cop = closest_cop(cop, kid, curop, opnext);
d1275 1
a1275 2
	const COP *cop =
	    closest_cop(PL_curcop, PL_curcop->op_sibling, PL_op, FALSE);
d1343 1
a1343 1
	Perl_magic_methcall(aTHX_ MUTABLE_SV(io), mg, SV_CONST(PRINT),
d1346 4
d1354 3
d1591 1
a1591 1
terser object code than using C<Perl_croak>.  Less code used on exception code
d1598 1
a1598 1
Perl_croak_no_modify(void)
d1607 1
a1607 1
Perl_croak_no_mem(void)
d1610 1
d1612 2
a1613 2
    PERL_UNUSED_RESULT(PerlLIO_write(PerlIO_fileno(Perl_error_log),
		  PL_no_mem, sizeof(PL_no_mem)-1));
d1617 8
d1947 1
a1947 5
    /* This next branch should only be called #if defined(HAS_SETENV), but
       Configure doesn't test for that yet.  For Solaris, setenv() and unsetenv()
       were introduced in Solaris 9, so testing for HAS UNSETENV is sufficient.
    */
#   if defined(__CYGWIN__)|| defined(__SYMBIAN32__) || defined(__riscos__) || (defined(__sun) && defined(HAS_UNSETENV))
d2163 329
d2859 19
d3070 1
a3077 6
    bool should_wait;

    svp = av_fetch(PL_fdpid,fd,TRUE);
    pid = (SvTYPE(*svp) == SVt_IV) ? SvIVX(*svp) : -1;
    SvREFCNT_dec(*svp);
    *svp = NULL;
d3079 1
a3079 1
#if defined(USE_PERLIO)
d3082 1
a3082 1
    should_wait = PerlIOUnix_refcnt(fd) == 1 && pid > 0;
d3084 1
a3084 1
    should_wait = pid > 0;
d3087 4
d3098 5
d3106 5
d3138 2
a3140 9
    if (!pid) {
        /* PERL_USES_PL_PIDSTATUS is only defined when neither
           waitpid() nor wait4() is available, or on OS/2, which
           doesn't appear to support waiting for a progress group
           member, so we can only treat a 0 pid as an unknown child.
        */
        errno = ECHILD;
        return -1;
    }
d3187 1
a3187 1
    result = wait4(pid,statusp,flags,NULL);
d3271 1
a3271 1
	croak_memory_wrap();
d3669 1
a3669 1
	? NULL : (MGVTBL*)PL_magic_vtables + vtbl_id;
d3675 1
a3675 1
#if defined(USE_PERLIO) || defined(FFLUSH_NULL)
d3767 1
a3767 2
	    (op == OP_READLINE || op == OP_RCATLINE
				 ? "readline"  :	/* "<HANDLE>" not nice */
d3799 1
a3799 1
#ifdef __GLIBC__
a4055 2

  GCC_DIAG_IGNORE(-Wformat-nonliteral); /* fmt checked by caller */
a4056 2
  GCC_DIAG_RESTORE;

a4079 2

      GCC_DIAG_IGNORE(-Wformat-nonliteral); /* fmt checked by caller */
a4080 2
      GCC_DIAG_RESTORE;

d4132 1
d4134 1
d4276 21
a4296 1
#include "vutil.c"
d4298 1
a4298 3
#if !defined(HAS_SOCKETPAIR) && defined(HAS_SOCKET) && defined(AF_INET) && defined(PF_INET) && defined(SOCK_DGRAM) && defined(HAS_SELECT)
#   define EMULATE_SOCKETPAIR_UDP
#endif
d4300 2
a4301 11
#ifdef EMULATE_SOCKETPAIR_UDP
static int
S_socketpair_udp (int fd[2]) {
    dTHX;
    /* Fake a datagram socketpair using UDP to localhost.  */
    int sockets[2] = {-1, -1};
    struct sockaddr_in addresses[2];
    int i;
    Sock_size_t size = sizeof(struct sockaddr_in);
    unsigned short port;
    int got;
d4303 9
a4311 6
    memset(&addresses, 0, sizeof(addresses));
    i = 1;
    do {
	sockets[i] = PerlSock_socket(AF_INET, SOCK_DGRAM, PF_INET);
	if (sockets[i] == -1)
	    goto tidy_up_and_fail;
d4313 5
a4317 7
	addresses[i].sin_family = AF_INET;
	addresses[i].sin_addr.s_addr = htonl(INADDR_LOOPBACK);
	addresses[i].sin_port = 0;	/* kernel choses port.  */
	if (PerlSock_bind(sockets[i], (struct sockaddr *) &addresses[i],
		sizeof(struct sockaddr_in)) == -1)
	    goto tidy_up_and_fail;
    } while (i--);
d4319 935
a5253 14
    /* Now have 2 UDP sockets. Find out which port each is connected to, and
       for each connect the other socket to it.  */
    i = 1;
    do {
	if (PerlSock_getsockname(sockets[i], (struct sockaddr *) &addresses[i],
		&size) == -1)
	    goto tidy_up_and_fail;
	if (size != sizeof(struct sockaddr_in))
	    goto abort_tidy_up_and_fail;
	/* !1 is 0, !0 is 1 */
	if (PerlSock_connect(sockets[!i], (struct sockaddr *) &addresses[i],
		sizeof(struct sockaddr_in)) == -1)
	    goto tidy_up_and_fail;
    } while (i--);
d5477 1
a5477 2
Or "locks" it.  Or "unlocks" it.  In other
words, ignores its single SV argument.
d5754 2
a5755 2
    const IV nppaddr = C_ARRAY_LENGTH(Gppaddr);
    const IV ncheck  = C_ARRAY_LENGTH(Gcheck);
a5793 4
#  ifdef PERL_GLOBAL_STRUCT_PRIVATE
    plvarsp->Gsv_placeholder.sv_flags = 0;
    memset(plvarsp->Ghash_seed, 0, sizeof(plvarsp->Ghash_seed));
#  endif
a5805 2
    int veto = plvarsp->Gveto_cleanup;

a5810 2
    if (veto)
        return;
d6017 1
a6017 1
the length of the string written to the buffer.  Only rare pre-ANSI systems
a6097 1
    va_end(apc);
d6146 2
a6147 1
    char *buf = (char*)safesysmalloc(bsiz);
d6154 2
a6155 1
        buf = (char*)safesysmalloc(bsiz);
a6368 20
/*
=for apidoc my_strlcat

The C library C<strlcat> if available, or a Perl implementation of it.
This operates on C C<NUL>-terminated strings.

C<my_strlcat()> appends string C<src> to the end of C<dst>.  It will append at
most S<C<size - strlen(dst) - 1>> characters.  It will then C<NUL>-terminate,
unless C<size> is 0 or the original C<dst> string was longer than C<size> (in
practice this should not happen as it means that either C<size> is incorrect or
that C<dst> is not a proper C<NUL>-terminated string).

Note that C<size> is the full size of the destination buffer and
the result is guaranteed to be C<NUL>-terminated if there is room.  Note that
room for the C<NUL> should be included in C<size>.

=cut

Description stolen from http://www.openbsd.org/cgi-bin/man.cgi?query=strlcat
*/
a6385 14

/*
=for apidoc my_strlcpy

The C library C<strlcpy> if available, or a Perl implementation of it.
This operates on C C<NUL>-terminated strings.

C<my_strlcpy()> copies up to S<C<size - 1>> characters from the string C<src>
to C<dst>, C<NUL>-terminating the result if C<size> is not 0.

=cut

Description stolen from http://www.openbsd.org/cgi-bin/man.cgi?query=strlcpy
*/
d6414 3
a6416 2
	&& (gvp = (GV **)hv_fetchhek(
			GvSTASH(gv), GvNAME_HEK(gv), 0
a6475 1
    SvSETMAGIC(dbsv);
a6512 99

/*
 * This code is derived from drand48() implementation from FreeBSD,
 * found in lib/libc/gen/_rand48.c.
 *
 * The U64 implementation is original, based on the POSIX
 * specification for drand48().
 */

/*
* Copyright (c) 1993 Martin Birgmeier
* All rights reserved.
*
* You may redistribute unmodified or modified versions of this source
* code provided that the above copyright notice and this and the
* following conditions are retained.
*
* This software is provided ``as is'', and comes with no warranties
* of any kind. I shall in no event be liable for anything that happens
* to anyone/anything when using this software.
*/

#define FREEBSD_DRAND48_SEED_0   (0x330e)

#ifdef PERL_DRAND48_QUAD

#define DRAND48_MULT U64_CONST(0x5deece66d)
#define DRAND48_ADD  0xb
#define DRAND48_MASK U64_CONST(0xffffffffffff)

#else

#define FREEBSD_DRAND48_SEED_1   (0xabcd)
#define FREEBSD_DRAND48_SEED_2   (0x1234)
#define FREEBSD_DRAND48_MULT_0   (0xe66d)
#define FREEBSD_DRAND48_MULT_1   (0xdeec)
#define FREEBSD_DRAND48_MULT_2   (0x0005)
#define FREEBSD_DRAND48_ADD      (0x000b)

const unsigned short _rand48_mult[3] = {
                FREEBSD_DRAND48_MULT_0,
                FREEBSD_DRAND48_MULT_1,
                FREEBSD_DRAND48_MULT_2
};
const unsigned short _rand48_add = FREEBSD_DRAND48_ADD;

#endif

void
Perl_drand48_init_r(perl_drand48_t *random_state, U32 seed)
{
    PERL_ARGS_ASSERT_DRAND48_INIT_R;

#ifdef PERL_DRAND48_QUAD
    *random_state = FREEBSD_DRAND48_SEED_0 + ((U64TYPE)seed << 16);
#else
    random_state->seed[0] = FREEBSD_DRAND48_SEED_0;
    random_state->seed[1] = (U16) seed;
    random_state->seed[2] = (U16) (seed >> 16);
#endif
}

double
Perl_drand48_r(perl_drand48_t *random_state)
{
    PERL_ARGS_ASSERT_DRAND48_R;

#ifdef PERL_DRAND48_QUAD
    *random_state = (*random_state * DRAND48_MULT + DRAND48_ADD)
        & DRAND48_MASK;

    return ldexp((double)*random_state, -48);
#else
    {
    U32 accu;
    U16 temp[2];

    accu = (U32) _rand48_mult[0] * (U32) random_state->seed[0]
         + (U32) _rand48_add;
    temp[0] = (U16) accu;        /* lower 16 bits */
    accu >>= sizeof(U16) * 8;
    accu += (U32) _rand48_mult[0] * (U32) random_state->seed[1]
          + (U32) _rand48_mult[1] * (U32) random_state->seed[0];
    temp[1] = (U16) accu;        /* middle 16 bits */
    accu >>= sizeof(U16) * 8;
    accu += _rand48_mult[0] * random_state->seed[2]
          + _rand48_mult[1] * random_state->seed[1]
          + _rand48_mult[2] * random_state->seed[0];
    random_state->seed[0] = temp[0];
    random_state->seed[1] = temp[1];
    random_state->seed[2] = (U16) accu;

    return ldexp((double) random_state->seed[0], -48) +
           ldexp((double) random_state->seed[1], -32) +
           ldexp((double) random_state->seed[2], -16);
    }
#endif
}
 
@


1.1.1.17
log
@Import perl-5.20.2
@
text
@d5306 1
a5306 1
	if (gv && !svp) {
d5309 1
a5309 1
	else if ( (CvFLAGS(cv) & (CVf_ANON | CVf_CLONED)) || !gv
@


1.1.1.18
log
@Import perl-5.24.2
@
text
@a47 4
#ifdef __amigaos__
# include "amigaos4/amigaio.h"
#endif

a53 18
#ifdef USE_C_BACKTRACE
#  ifdef I_BFD
#    define USE_BFD
#    ifdef PERL_DARWIN
#      undef USE_BFD /* BFD is useless in OS X. */
#    endif
#    ifdef USE_BFD
#      include <bfd.h>
#    endif
#  endif
#  ifdef I_DLFCN
#    include <dlfcn.h>
#  endif
#  ifdef I_EXECINFO
#    include <execinfo.h>
#  endif
#endif

d60 4
a116 4

#ifdef USE_MDH
    if (size + PERL_MEMORY_DEBUG_HEADER_SIZE < size)
        goto out_of_memory;
a117 1
#endif
d159 1
a159 1
	ptr = (Malloc_t)((char*)ptr+PERL_MEMORY_DEBUG_HEADER_SIZE);
d161 2
a162 2

    }
a163 4
#ifdef USE_MDH
      out_of_memory:
#endif
        {
d165 1
a165 1
            dTHX;
d167 5
a171 5
            if (PL_nomemok)
                ptr =  NULL;
            else
                croak_no_mem();
        }
d173 1
a173 1
    return ptr;
d196 1
a196 1
	ptr = NULL;
d198 3
a200 4
    else if (!where) {
	ptr = safesysmalloc(size);
    }
    else {
d202 5
a206 7
	where = (Malloc_t)((char*)where-PERL_MEMORY_DEBUG_HEADER_SIZE);
        if (size + PERL_MEMORY_DEBUG_HEADER_SIZE < size)
            goto out_of_memory;
	size += PERL_MEMORY_DEBUG_HEADER_SIZE;
	{
	    struct perl_memory_debug_header *const header
		= (struct perl_memory_debug_header *)where;
d209 6
a214 6
	    if (header->interpreter != aTHX) {
		Perl_croak_nocontext("panic: realloc from wrong pool, %p!=%p",
				     header->interpreter, aTHX);
	    }
	    assert(header->next->prev == header);
	    assert(header->prev->next == header);
d216 5
a220 5
	    if (header->size > size) {
		const MEM_SIZE freed_up = header->size - size;
		char *start_of_freed = ((char *)where) + size;
		PoisonFree(start_of_freed, freed_up, char);
	    }
d224 1
a224 1
	    header->size = size;
d226 1
a226 1
	}
d229 2
a230 2
	if ((SSize_t)size < 0)
	    Perl_croak_nocontext("panic: realloc, size=%"UVuf, (UV)size);
d233 10
a242 10
	if ((ptr = mmap(0, size, PROT_READ|PROT_WRITE,
			MAP_ANON|MAP_PRIVATE, -1, 0)) == MAP_FAILED) {
	    perror("mmap failed");
	    abort();
	}
	Copy(where,ptr,oldsize < size ? oldsize : size,char);
	if (munmap(where, oldsize)) {
	    perror("munmap failed");
	    abort();
	}
d244 1
a244 1
	ptr = (Malloc_t)PerlMem_realloc(where,size);
d246 1
a246 1
	PERL_ALLOC_CHECK(ptr);
d251 1
a251 1
	if (ptr != NULL) {
d253 2
a254 2
	    struct perl_memory_debug_header *const header
		= (struct perl_memory_debug_header *)ptr;
d257 5
a261 5
	    if (header->size < size) {
		const MEM_SIZE fresh = size - header->size;
		char *start_of_fresh = ((char *)ptr) + size;
		PoisonNew(start_of_fresh, fresh, char);
	    }
d264 6
a269 6
	    maybe_protect_rw(header->next);
	    header->next->prev = header;
	    maybe_protect_ro(header->next);
	    maybe_protect_rw(header->prev);
	    header->prev->next = header;
	    maybe_protect_ro(header->prev);
d271 2
a272 2
	    ptr = (Malloc_t)((char*)ptr+PERL_MEMORY_DEBUG_HEADER_SIZE);
	}
d277 2
a278 2
	DEBUG_m(PerlIO_printf(Perl_debug_log, "0x%"UVxf": (%05ld) rfree\n",PTR2UV(where),(long)PL_an++));
	DEBUG_m(PerlIO_printf(Perl_debug_log, "0x%"UVxf": (%05ld) realloc %ld bytes\n",PTR2UV(ptr),(long)PL_an++,(long)size));
d280 5
a284 5
	if (ptr == NULL) {
#ifdef USE_MDH
          out_of_memory:
#endif
            {
d286 1
a286 1
                dTHX;
d288 4
a291 5
                if (PL_nomemok)
                    ptr = NULL;
                else
                    croak_no_mem();
            }
d294 1
a294 1
    return ptr;
d304 2
d310 1
a310 1
	Malloc_t where_intrn = (Malloc_t)((char*)where-PERL_MEMORY_DEBUG_HEADER_SIZE);
d313 1
a313 1
		= (struct perl_memory_debug_header *)where_intrn;
d343 1
a343 1
	    PoisonNew(where_intrn, size, char);
d349 1
a349 1
	    if (munmap(where_intrn, size)) {
d355 1
a355 3
#else
	Malloc_t where_intrn = where;
#endif /* USE_MDH */
d357 1
a357 1
	PerlMem_free(where_intrn);
d462 1
a462 3
#ifdef PERL_IMPLICIT_SYS
    dTHX;
#endif
d468 1
a468 3
#ifdef PERL_IMPLICIT_SYS
    dTHX;
#endif
d474 1
a474 3
#ifdef PERL_IMPLICIT_SYS
    dTHX;
#endif
d480 1
a480 3
#ifdef PERL_IMPLICIT_SYS
    dTHX;
#endif
d488 2
a489 4
static char *
S_delimcpy(char *to, const char *toend, const char *from,
	   const char *fromend, int delim, I32 *retlen,
	   const bool allow_escape)
d496 1
a496 1
	if (allow_escape && *from == '\\') {
a514 17
char *
Perl_delimcpy(char *to, const char *toend, const char *from, const char *fromend, int delim, I32 *retlen)
{
    PERL_ARGS_ASSERT_DELIMCPY;

    return S_delimcpy(to, toend, from, fromend, delim, retlen, 1);
}

char *
Perl_delimcpy_no_escape(char *to, const char *toend, const char *from,
			const char *fromend, int delim, I32 *retlen)
{
    PERL_ARGS_ASSERT_DELIMCPY_NO_ESCAPE;

    return S_delimcpy(to, toend, from, fromend, delim, retlen, 0);
}

d524 4
d531 2
a532 28
/*
=head1 Miscellaneous Functions

=for apidoc Am|char *|ninstr|char * big|char * bigend|char * little|char * little_end

Find the first (leftmost) occurrence of a sequence of bytes within another
sequence.  This is the Perl version of C<strstr()>, extended to handle
arbitrary sequences, potentially containing embedded C<NUL> characters (C<NUL>
is what the initial C<n> in the function name stands for; some systems have an
equivalent, C<memmem()>, but with a somewhat different API).

Another way of thinking about this function is finding a needle in a haystack.
C<big> points to the first byte in the haystack.  C<big_end> points to one byte
beyond the final byte in the haystack.  C<little> points to the first byte in
the needle.  C<little_end> points to one byte beyond the final byte in the
needle.  All the parameters must be non-C<NULL>.

The function returns C<NULL> if there is no occurrence of C<little> within
C<big>.  If C<little> is the empty string, C<big> is returned.

Because this function operates at the byte level, and because of the inherent
characteristics of UTF-8 (or UTF-EBCDIC), it will work properly if both the
needle and the haystack are strings with the same UTF-8ness, but not if the
UTF-8ness differs.

=cut

*/
d558 1
a558 12
/*
=head1 Miscellaneous Functions

=for apidoc Am|char *|rninstr|char * big|char * bigend|char * little|char * little_end

Like C<L</ninstr>>, but instead finds the final (rightmost) occurrence of a
sequence of bytes within another sequence, returning C<NULL> if there is no
such occurrence.

=cut

*/
d602 1
a602 1
Analyses the string in order to make fast searches on it using C<fbm_instr()>
d611 1
d696 3
d704 2
a705 3
C<bigend> (C<bigend>) is the char following the last char).
It returns C<NULL> if the string can't be found.  The C<sv>
does not have to be C<fbm_compiled>, but the search will not be as fast
a708 17

If SvTAIL(littlestr) is true, a fake "\n" was appended to to the string
during FBM compilation due to FBMcf_TAIL in flags. It indicates that
the littlestr must be anchored to the end of bigstr (or to any \n if
FBMrf_MULTILINE).

E.g. The regex compiler would compile /abc/ to a littlestr of "abc",
while /abc$/ compiles to "abc\n" with SvTAIL() true.

A littlestr of "abc", !SvTAIL matches as /abc/;
a littlestr of "ab\n", SvTAIL matches as:
   without FBMrf_MULTILINE: /ab\n?\z/
   with    FBMrf_MULTILINE: /ab\n/ || /ab\z/;

(According to Ilya from 1999; I don't know if this is still true, DAPM 2015):
  "If SvTAIL is actually due to \Z or \z, this gives false positives
  if multiline".
a710 1

a734 1

d736 12
a747 7
	    if (SvTAIL(littlestr) && !multiline) /* Anchor only! */
		/* [-1] is safe because we know that bigend != big.  */
		return (char *) (bigend - (bigend[-1] == '\n'));

	    s = (unsigned char *)memchr((void*)big, *little, bigend-big);
            if (s)
                return (char *)s;
a750 1

d753 1
a753 4
            /* a littlestr with SvTAIL must be of the form "X\n" (where X
             * is a single char). It is anchored, and can only match
             * "....X\n"  or  "....X" */
            if (bigend[-2] == *little && bigend[-1] == '\n')
a758 1

d760 51
a810 71
            /* memchr() is likely to be very fast, possibly using whatever
             * hardware support is available, such as checking a whole
             * cache line in one instruction.
             * So for a 2 char pattern, calling memchr() is likely to be
             * faster than running FBM, or rolling our own. The previous
             * version of this code was roll-your-own which typically
             * only needed to read every 2nd char, which was good back in
             * the day, but no longer.
             */
	    unsigned char c1 = little[0];
	    unsigned char c2 = little[1];

            /* *** for all this case, bigend points to the last char,
             * not the trailing \0: this makes the conditions slightly
             * simpler */
            bigend--;
	    s = big;
            if (c1 != c2) {
                while (s < bigend) {
                    /* do a quick test for c1 before calling memchr();
                     * this avoids the expensive fn call overhead when
                     * there are lots of c1's */
                    if (LIKELY(*s != c1)) {
                        s++;
                        s = (unsigned char *)memchr((void*)s, c1, bigend - s);
                        if (!s)
                            break;
                    }
                    if (s[1] == c2)
                        return (char*)s;

                    /* failed; try searching for c2 this time; that way
                     * we don't go pathologically slow when the string
                     * consists mostly of c1's or vice versa.
                     */
                    s += 2;
                    if (s > bigend)
                        break;
                    s = (unsigned char *)memchr((void*)s, c2, bigend - s + 1);
                    if (!s)
                        break;
                    if (s[-1] == c1)
                        return (char*)s - 1;
                }
            }
            else {
                /* c1, c2 the same */
                while (s < bigend) {
                    if (s[0] == c1) {
                      got_1char:
                        if (s[1] == c1)
                            return (char*)s;
                        s += 2;
                    }
                    else {
                        s++;
                        s = (unsigned char *)memchr((void*)s, c1, bigend - s);
                        if (!s || s >= bigend)
                            break;
                        goto got_1char;
                    }
                }
            }

            /* failed to find 2 chars; try anchored match at end without
             * the \n */
            if (SvTAIL(littlestr) && bigend[0] == little[0])
                return (char *)bigend;
            return NULL;
        }

a829 1

a830 1
        /* not compiled; use Perl_ninstr() instead */
d853 1
a855 2
	assert(mg);

a861 2
	    const unsigned char * const table = (const unsigned char *) mg->mg_ptr;
            const unsigned char lastc = *little;
d866 3
a868 13
                /* *s != lastc; earliest position it could match now is
                 * tmp slots further on */
		if ((s += tmp) >= bigend)
                    goto check_end;
                if (LIKELY(*s != lastc)) {
                    s++;
                    s = (unsigned char *)memchr((void*)s, lastc, bigend - s);
                    if (!s) {
                        s = bigend;
                        goto check_end;
                    }
                    goto top2;
                }
d870 1
a870 5


            /* hand-rolled strncmp(): less expensive than calling the
             * real function (maybe???) */
	    {
d897 17
d918 1
a918 2
Returns true if the leading C<len> bytes of the strings C<s1> and C<s2> are the
same
d971 2
a972 2
Returns true if the leading C<len> bytes of the strings C<s1> and C<s2> are the
same case-insensitively in the current locale; false otherwise.
a1080 3

    PERL_UNUSED_CONTEXT;

d1096 1
a1096 1
which is shared between threads.  (With the specific difference that a C<NULL>
a1105 1
    PERL_UNUSED_CONTEXT;
d1167 1
d1290 1
d1304 1
a1304 1
	for (kid = cUNOPo->op_first; kid; kid = OpSIBLING(kid)) {
d1353 1
a1355 14
#if defined(USE_C_BACKTRACE) && defined(USE_C_BACKTRACE_ON_ERROR)
    {
        char *ws;
        UV wi;
        /* The PERL_C_BACKTRACE_ON_WARN must be an integer of one or more. */
        if ((ws = PerlEnv_getenv("PERL_C_BACKTRACE_ON_ERROR"))
            && grok_atoUV(ws, &wi, NULL)
            && wi <= PERL_INT_MAX
        ) {
            Perl_dump_c_backtrace(aTHX_ Perl_debug_log, (int)wi, 1);
        }
    }
#endif

d1386 1
a1386 1
	    closest_cop(PL_curcop, OpSIBLING(PL_curcop), PL_op, FALSE);
d1418 1
a1418 2
argument list, respectively.  These are used to generate a string message.  If
the
d1433 1
d1445 1
d1485 1
a1536 7
#ifdef _MSC_VER
#  pragma warning( push )
#  pragma warning( disable : 4646 ) /* warning C4646: function declared with
    __declspec(noreturn) has non-void return type */
#  pragma warning( disable : 4645 ) /* warning C4645: function declared with
__declspec(noreturn) has a return statement */
#endif
d1542 2
a1543 2
    /* NOTREACHED */
    NORETURN_FUNCTION_END;
a1544 3
#ifdef _MSC_VER
#  pragma warning( pop )
#endif
a1556 7
#ifdef _MSC_VER
#  pragma warning( push )
#  pragma warning( disable : 4646 ) /* warning C4646: function declared with
    __declspec(noreturn) has non-void return type */
#  pragma warning( disable : 4645 ) /* warning C4645: function declared with
__declspec(noreturn) has a return statement */
#endif
d1564 1
a1564 1
    NOT_REACHED; /* NOTREACHED */
d1566 1
a1566 1
    NORETURN_FUNCTION_END;
a1567 3
#ifdef _MSC_VER
#  pragma warning( pop )
#endif
a1569 7
#ifdef _MSC_VER
#  pragma warning( push )
#  pragma warning( disable : 4646 ) /* warning C4646: function declared with
    __declspec(noreturn) has non-void return type */
#  pragma warning( disable : 4645 ) /* warning C4645: function declared with
__declspec(noreturn) has a return statement */
#endif
d1576 1
a1576 1
    NOT_REACHED; /* NOTREACHED */
d1578 1
a1578 1
    NORETURN_FUNCTION_END;
a1579 3
#ifdef _MSC_VER
#  pragma warning( pop )
#endif
d1676 1
a1676 1
    NOT_REACHED; /* NOTREACHED */
d1687 1
a1687 1
    NOT_REACHED; /* NOTREACHED */
d1714 3
a1716 8

    int fd = PerlIO_fileno(Perl_error_log);
    if (fd < 0)
        SETERRNO(EBADF,RMS_IFI);
    else {
        /* Can't use PerlIO to write as it allocates memory */
        PERL_UNUSED_RESULT(PerlLIO_write(fd, PL_no_mem, sizeof(PL_no_mem)-1));
    }
d1880 1
a1880 4
    if (
        (PL_warnhook == PERL_WARNHOOK_FATAL || ckDEAD(err)) &&
        !(PL_in_eval & EVAL_KEEPERR)
    ) {
d1883 2
a1884 7
	if (PL_parser && PL_parser->error_count) {
	    qerror(msv);
	}
	else {
	    invoke_exception_hook(msv, FALSE);
	    die_unwind(msv);
	}
d1896 1
d1909 1
a1984 3
#ifdef __amigaos4__
  amigaos4_obtain_environ(__FUNCTION__);
#endif
d1992 48
a2039 52
        /* most putenv()s leak, so we manipulate environ directly */
        I32 i;
        const I32 len = strlen(nam);
        int nlen, vlen;

        /* where does it go? */
        for (i = 0; environ[i]; i++) {
            if (strnEQ(environ[i],nam,len) && environ[i][len] == '=')
                break;
        }

        if (environ == PL_origenviron) {   /* need we copy environment? */
            I32 j;
            I32 max;
            char **tmpenv;

            max = i;
            while (environ[max])
                max++;
            tmpenv = (char**)safesysmalloc((max+2) * sizeof(char*));
            for (j=0; j<max; j++) {         /* copy environment */
                const int len = strlen(environ[j]);
                tmpenv[j] = (char*)safesysmalloc((len+1)*sizeof(char));
                Copy(environ[j], tmpenv[j], len+1, char);
            }
            tmpenv[max] = NULL;
            environ = tmpenv;               /* tell exec where it is now */
        }
        if (!val) {
            safesysfree(environ[i]);
            while (environ[i]) {
                environ[i] = environ[i+1];
                i++;
            }
#ifdef __amigaos4__
            goto my_setenv_out;
#else
            return;
#endif
        }
        if (!environ[i]) {                 /* does not exist yet */
            environ = (char**)safesysrealloc(environ, (i+2) * sizeof(char*));
            environ[i+1] = NULL;    /* make sure it's null terminated */
        }
        else
            safesysfree(environ[i]);
        nlen = strlen(nam);
        vlen = strlen(val);

        environ[i] = (char*)safesysmalloc((nlen+vlen+2) * sizeof(char));
        /* all that work just for this */
        my_setenv_format(environ[i], nam, nlen, val, vlen);
d2046 1
a2046 1
#   if defined(__CYGWIN__)|| defined(__SYMBIAN32__) || defined(__riscos__) || (defined(__sun) && defined(HAS_UNSETENV)) || defined(PERL_DARWIN)
a2086 4
#ifdef __amigaos4__
my_setenv_out:
  amigaos4_release_environ(__FUNCTION__);
#endif
d2127 4
a2130 5
/* this is a drop-in replacement for bcopy(), except for the return
 * value, which we need to be able to emulate memcpy()  */
#if !defined(HAS_MEMCPY) || (!defined(HAS_MEMMOVE) && !defined(HAS_SAFE_MEMCPY))
void *
Perl_my_bcopy(const void *vfrom, void *vto, size_t len)
d2132 1
a2132 5
#if defined(HAS_BCOPY) && defined(HAS_SAFE_BCOPY)
    bcopy(vfrom, vto, len);
#else
    const unsigned char *from = (const unsigned char *)vfrom;
    unsigned char *to = (unsigned char *)vto;
d2136 2
d2148 1
a2148 3
#endif

    return vto;
d2155 1
a2155 1
Perl_my_memset(void *vloc, int ch, size_t len)
d2157 1
a2157 1
    unsigned char *loc = (unsigned char *)vloc;
d2161 2
d2165 1
a2165 1
    return vloc;
d2171 2
a2172 2
void *
Perl_my_bzero(void *vloc, size_t len)
d2174 1
a2174 1
    unsigned char *loc = (unsigned char *)vloc;
d2178 2
d2182 1
a2182 1
    return vloc;
d2188 2
a2189 2
int
Perl_my_memcmp(const void *vs1, const void *vs2, size_t len)
d2191 3
a2193 3
    const U8 *a = (const U8 *)vs1;
    const U8 *b = (const U8 *)vs2;
    int tmp;
d2197 2
d2265 2
a2266 1
#if (!defined(DOSISH) || defined(HAS_FORK)) && !defined(OS2) && !defined(VMS) && !defined(NETWARE) && !defined(__LIBCATAMOUNT__) && !defined(__amigaos4__)
d2310 1
a2310 1
#if defined(HAS_FCNTL) && defined(F_SETFD) && defined(FD_CLOEXEC)
d2312 1
a2312 2
	    if (fcntl(pp[1], F_SETFD, FD_CLOEXEC) < 0)
                return NULL;
d2392 1
a2392 1
#  if defined(OS2)	/* Same, without fork()ing and all extra overhead... */
a2393 2
#  elif defined(WIN32)
    return win32_popenlist(mode, n, args);
d2401 2
a2402 2
    /* VMS' my_popen() is in VMS.c, same with OS/2 and AmigaOS 4. */
#if (!defined(DOSISH) || defined(HAS_FORK)) && !defined(VMS) && !defined(__LIBCATAMOUNT__) && !defined(__amigaos4__)
d2406 1
d2457 1
a2457 2
            if (fcntl(pp[1], F_SETFD, FD_CLOEXEC) < 0)
                return NULL;
a2575 9
#if defined(USE_ITHREADS)
#  ifdef USE_PERLIO
  PERL_TSA_ACQUIRE(PL_perlio_mutex)
#  endif
#  ifdef MYMALLOC
  PERL_TSA_ACQUIRE(PL_malloc_mutex)
#  endif
  PERL_TSA_ACQUIRE(PL_op_mutex)
#endif
d2577 1
a2578 1
    dVAR;
d2593 2
d2596 1
d2598 1
a2598 13
  PERL_TSA_RELEASE(PL_perlio_mutex)
#  endif
#  ifdef MYMALLOC
  PERL_TSA_RELEASE(PL_malloc_mutex)
#  endif
  PERL_TSA_RELEASE(PL_op_mutex)
#endif
{
#if defined(USE_ITHREADS)
    dVAR;
    /* locks must be released in same order as in atfork_lock() */
#  ifdef USE_PERLIO
    MUTEX_UNLOCK(&PL_perlio_mutex);
a2621 2
#elif defined(__amigaos4__)
    return amigaos_fork();
d2669 1
a2672 1
    dVAR;
a2709 1
#ifdef USE_ITHREADS
a2710 1
#endif
a2737 1
#ifdef USE_ITHREADS
a2738 2
#endif
    PERL_UNUSED_CONTEXT;
d2816 1
a2816 1
#if (!defined(DOSISH) || defined(HAS_FORK)) && !defined(VMS) && !defined(__LIBCATAMOUNT__) && !defined(__amigaos4__)
d2820 1
d2877 1
d2916 1
a2916 1
		   aggregate does more work, because next call to hv_iterinit()
d3092 1
a3164 1
	    Stat_t statbuf;
d3191 4
a3194 6
	    {
		Stat_t statbuf;
		if (PerlLIO_stat(cur,&statbuf) >= 0
		    && !S_ISDIR(statbuf.st_mode)) {
		    dosearch = 0;
		    scriptname = cur;
d3196 1
a3196 1
		    break;
a3197 1
		}
a3222 1
	    Stat_t statbuf;
d3259 2
a3260 2
		retval = PerlLIO_stat(tmpbuf,&statbuf);
		if (S_ISDIR(statbuf.st_mode)) {
d3271 2
a3272 2
	    if (S_ISREG(statbuf.st_mode)
		&& cando(S_IRUSR,TRUE,&statbuf)
d3274 1
a3274 1
		&& cando(S_IXUSR,TRUE,&statbuf)
d3285 3
a3287 9
	{
	    Stat_t statbuf;
	    if (!xfound && !seen_dot && !xfailed &&
		(PerlLIO_stat(scriptname,&statbuf) < 0
		 || S_ISDIR(statbuf.st_mode)))
#endif
		seen_dot = 1;			/* Disable message. */
#ifndef DOSISH
	}
d3289 1
d3312 1
a3313 1
    dVAR;
a3334 1
#if defined(USE_ITHREADS)
a3335 1
#endif
d3358 1
a3358 2
    PERL_UNUSED_CONTEXT;
    return &PL_Vars;
d3484 1
a3484 1
			HEKfARG(name), direction);
a3566 1
    PERL_UNUSED_CONTEXT;
a3572 1
    PERL_UNUSED_CONTEXT;
d3583 1
a3583 1
Perl_mini_mktime(struct tm *ptm)
d3589 1
a3771 3

  /* Note that yday and wday effectively are ignored by this function, as mini_mktime() overwrites them */

d3872 1
a3872 1
Fill C<sv> with current working directory
d3880 1
a3880 1
 * Comments from the original:
d3889 1
d4304 1
a4304 1
Exists to avoid test for a C<NULL> function pointer and because it could
d4323 1
a4323 1
'true'.  Exists to avoid test for a C<NULL> function pointer and because it
d4347 10
a4356 17
            const char* endptr;
            UV uv;
            if (grok_atoUV(p, &uv, &endptr) && uv <= U32_MAX) {
                opt = (U32)uv;
                p = endptr;
                if (p && *p && *p != '\n' && *p != '\r') {
                    if (isSPACE(*p))
                        goto the_end_of_the_opts_parser;
                    else
                        Perl_croak(aTHX_ "Unknown Unicode option letter '%c'", *p);
                }
            }
            else {
                Perl_croak(aTHX_ "Invalid number '%s' for -C option.\n", p);
            }
        }
        else {
d4411 1
d4438 6
a4443 1
#ifdef HAS_GETTIMEOFDAY
d4445 1
a4445 1
#else
d4447 1
d4457 1
a4457 5
#  ifdef __amigaos4__
#    define PERL_RANDOM_DEVICE "RANDOM:SIZE=4"
#  else
#    define PERL_RANDOM_DEVICE "/dev/urandom"
#  endif
d4469 5
a4473 1
#ifdef HAS_GETTIMEOFDAY
d4476 1
a4476 1
#else
d4479 1
d4492 1
a4581 1
    PERL_UNUSED_CONTEXT;
a4638 1
    PERL_UNUSED_CONTEXT;
d4657 1
a4657 1
/* -DPERL_MEM_LOG: the Perl_mem_log_..() is compiled, including
d4664 1
a4664 1
 *    \d+ - fd		fd to write to		: must be 1st (grok_atoUV)
d4727 1
a4727 1
	 * gettimeofday() (see dist/Time-HiRes), the easiest way is
d4732 2
a4733 8
            const char* endptr;
	    int fd;
            UV uv;
            if (grok_atoUV(pmlenv, &uv, &endptr) /* Ignore endptr. */
                && uv && uv <= PERL_INT_MAX
            ) {
                fd = (int)uv;
            } else {
a4734 1
            }
d4739 1
a4739 1
		PERL_UNUSED_RESULT(PerlLIO_write(fd, buf, len));
d4774 1
a4774 1
	    PERL_UNUSED_RESULT(PerlLIO_write(fd, buf, len));
a4798 2
    PERL_ARGS_ASSERT_MEM_LOG_ALLOC;

a4810 2
    PERL_ARGS_ASSERT_MEM_LOG_REALLOC;

a4821 2
    PERL_ARGS_ASSERT_MEM_LOG_FREE;

a4869 106
=for apidoc quadmath_format_single

C<quadmath_snprintf()> is very strict about its C<format> string and will
fail, returning -1, if the format is invalid.  It accepts exactly
one format spec.

C<quadmath_format_single()> checks that the intended single spec looks
sane: begins with C<%>, has only one C<%>, ends with C<[efgaEFGA]>,
and has C<Q> before it.  This is not a full "printf syntax check",
just the basics.

Returns the format if it is valid, NULL if not.

C<quadmath_format_single()> can and will actually patch in the missing
C<Q>, if necessary.  In this case it will return the modified copy of
the format, B<which the caller will need to free.>

See also L</quadmath_format_needed>.

=cut
*/
#ifdef USE_QUADMATH
const char*
Perl_quadmath_format_single(const char* format)
{
    STRLEN len;

    PERL_ARGS_ASSERT_QUADMATH_FORMAT_SINGLE;

    if (format[0] != '%' || strchr(format + 1, '%'))
        return NULL;
    len = strlen(format);
    /* minimum length three: %Qg */
    if (len < 3 || strchr("efgaEFGA", format[len - 1]) == NULL)
        return NULL;
    if (format[len - 2] != 'Q') {
        char* fixed;
        Newx(fixed, len + 1, char);
        memcpy(fixed, format, len - 1);
        fixed[len - 1] = 'Q';
        fixed[len    ] = format[len - 1];
        fixed[len + 1] = 0;
        return (const char*)fixed;
    }
    return format;
}
#endif

/*
=for apidoc quadmath_format_needed

C<quadmath_format_needed()> returns true if the C<format> string seems to
contain at least one non-Q-prefixed C<%[efgaEFGA]> format specifier,
or returns false otherwise.

The format specifier detection is not complete printf-syntax detection,
but it should catch most common cases.

If true is returned, those arguments B<should> in theory be processed
with C<quadmath_snprintf()>, but in case there is more than one such
format specifier (see L</quadmath_format_single>), and if there is
anything else beyond that one (even just a single byte), they
B<cannot> be processed because C<quadmath_snprintf()> is very strict,
accepting only one format spec, and nothing else.
In this case, the code should probably fail.

=cut
*/
#ifdef USE_QUADMATH
bool
Perl_quadmath_format_needed(const char* format)
{
  const char *p = format;
  const char *q;

  PERL_ARGS_ASSERT_QUADMATH_FORMAT_NEEDED;

  while ((q = strchr(p, '%'))) {
    q++;
    if (*q == '+') /* plus */
      q++;
    if (*q == '#') /* alt */
      q++;
    if (*q == '*') /* width */
      q++;
    else {
      if (isDIGIT(*q)) {
        while (isDIGIT(*q)) q++;
      }
    }
    if (*q == '.' && (q[1] == '*' || isDIGIT(q[1]))) { /* prec */
      q++;
      if (*q == '*')
        q++;
      else
        while (isDIGIT(*q)) q++;
    }
    if (strchr("efgaEFGA", *q)) /* Would have needed 'Q' in front. */
      return TRUE;
    p = q + 1;
  }
  return FALSE;
}
#endif

/*
d4884 1
a4884 1
    int retval = -1;
a4886 3
#ifndef HAS_VSNPRINTF
    PERL_UNUSED_VAR(len);
#endif
a4887 42
#ifdef USE_QUADMATH
    {
        const char* qfmt = quadmath_format_single(format);
        bool quadmath_valid = FALSE;
        if (qfmt) {
            /* If the format looked promising, use it as quadmath. */
            retval = quadmath_snprintf(buffer, len, qfmt, va_arg(ap, NV));
            if (retval == -1)
                Perl_croak_nocontext("panic: quadmath_snprintf failed, format \"%s\"", qfmt);
            quadmath_valid = TRUE;
            if (qfmt != format)
                Safefree(qfmt);
            qfmt = NULL;
        }
        assert(qfmt == NULL);
        /* quadmath_format_single() will return false for example for
         * "foo = %g", or simply "%g".  We could handle the %g by
         * using quadmath for the NV args.  More complex cases of
         * course exist: "foo = %g, bar = %g", or "foo=%Qg" (otherwise
         * quadmath-valid but has stuff in front).
         *
         * Handling the "Q-less" cases right would require walking
         * through the va_list and rewriting the format, calling
         * quadmath for the NVs, building a new va_list, and then
         * letting vsnprintf/vsprintf to take care of the other
         * arguments.  This may be doable.
         *
         * We do not attempt that now.  But for paranoia, we here try
         * to detect some common (but not all) cases where the
         * "Q-less" %[efgaEFGA] formats are present, and die if
         * detected.  This doesn't fix the problem, but it stops the
         * vsnprintf/vsprintf pulling doubles off the va_list when
         * __float128 NVs should be pulled off instead.
         *
         * If quadmath_format_needed() returns false, we are reasonably
         * certain that we can call vnsprintf() or vsprintf() safely. */
        if (!quadmath_valid && quadmath_format_needed(format))
          Perl_croak_nocontext("panic: quadmath_snprintf failed, format \"%s\"", format);

    }
#endif
    if (retval == -1)
d4889 1
a4889 1
        retval = vsnprintf(buffer, len, format, ap);
d4891 1
a4891 1
        retval = vsprintf(buffer, format, ap);
a4919 8
#ifdef USE_QUADMATH
    PERL_UNUSED_ARG(buffer);
    PERL_UNUSED_ARG(len);
    PERL_UNUSED_ARG(format);
    PERL_UNUSED_ARG(ap);
    Perl_croak_nocontext("panic: my_vsnprintf not available with quadmath");
    return 0;
#else
d4925 1
a4929 1
    PERL_UNUSED_ARG(len);
a4936 1
    PERL_UNUSED_ARG(len);
a4949 1
#endif
d5124 2
a5125 135

/* Perl_xs_handshake():
   implement the various XS_*_BOOTCHECK macros, which are added to .c
   files by ExtUtils::ParseXS, to check that the perl the module was built
   with is binary compatible with the running perl.

   usage:
       Perl_xs_handshake(U32 key, void * v_my_perl, const char * file,
            [U32 items, U32 ax], [char * api_version], [char * xs_version])

   The meaning of the varargs is determined the U32 key arg (which is not
   a format string). The fields of key are assembled by using HS_KEY().

   Under PERL_IMPLICIT_CONTEX, the v_my_perl arg is of type
   "PerlInterpreter *" and represents the callers context; otherwise it is
   of type "CV *", and is the boot xsub's CV.

   v_my_perl will catch where a threaded future perl526.dll calling IO.dll
   for example, and IO.dll was linked with threaded perl524.dll, and both
   perl526.dll and perl524.dll are in %PATH and the Win32 DLL loader
   successfully can load IO.dll into the process but simultaneously it
   loaded an interpreter of a different version into the process, and XS
   code will naturally pass SV*s created by perl524.dll for perl526.dll to
   use through perl526.dll's my_perl->Istack_base.

   v_my_perl cannot be the first arg, since then 'key' will be out of
   place in a threaded vs non-threaded mixup; and analyzing the key
   number's bitfields won't reveal the problem, since it will be a valid
   key (unthreaded perl) on interp side, but croak will report the XS mod's
   key as gibberish (it is really a my_perl ptr) (threaded XS mod); or if
   it's a threaded perl and an unthreaded XS module, threaded perl will
   look at an uninit C stack or an uninit register to get 'key'
   (remember that it assumes that the 1st arg is the interp cxt).

   'file' is the source filename of the caller.
*/

I32
Perl_xs_handshake(const U32 key, void * v_my_perl, const char * file, ...)
{
    va_list args;
    U32 items, ax;
    void * got;
    void * need;
#ifdef PERL_IMPLICIT_CONTEXT
    dTHX;
    tTHX xs_interp;
#else
    CV* cv;
    SV *** xs_spp;
#endif
    PERL_ARGS_ASSERT_XS_HANDSHAKE;
    va_start(args, file);

    got = INT2PTR(void*, (UV)(key & HSm_KEY_MATCH));
    need = (void *)(HS_KEY(FALSE, FALSE, "", "") & HSm_KEY_MATCH);
    if (UNLIKELY(got != need))
	goto bad_handshake;
/* try to catch where a 2nd threaded perl interp DLL is loaded into a process
   by a XS DLL compiled against the wrong interl DLL b/c of bad @@INC, and the
   2nd threaded perl interp DLL never initialized its TLS/PERL_SYS_INIT3 so
   dTHX call from 2nd interp DLL can't return the my_perl that pp_entersub
   passed to the XS DLL */
#ifdef PERL_IMPLICIT_CONTEXT
    xs_interp = (tTHX)v_my_perl;
    got = xs_interp;
    need = my_perl;
#else
/* try to catch where an unthreaded perl interp DLL (for ex. perl522.dll) is
   loaded into a process by a XS DLL built by an unthreaded perl522.dll perl,
   but the DynaLoder/Perl that started the process and loaded the XS DLL is
   unthreaded perl524.dll, since unthreadeds don't pass my_perl (a unique *)
   through pp_entersub, use a unique value (which is a pointer to PL_stack_sp's
   location in the unthreaded perl binary) stored in CV * to figure out if this
   Perl_xs_handshake was called by the same pp_entersub */
    cv = (CV*)v_my_perl;
    xs_spp = (SV***)CvHSCXT(cv);
    got = xs_spp;
    need = &PL_stack_sp;
#endif
    if(UNLIKELY(got != need)) {
	bad_handshake:/* recycle branch and string from above */
	if(got != (void *)HSf_NOCHK)
	    noperl_die("%s: loadable library and perl binaries are mismatched"
                       " (got handshake key %p, needed %p)\n",
		file, got, need);
    }

    if(key & HSf_SETXSUBFN) {     /* this might be called from a module bootstrap */
	SAVEPPTR(PL_xsubfilename);/* which was require'd from a XSUB BEGIN */
	PL_xsubfilename = file;   /* so the old name must be restored for
				     additional XSUBs to register themselves */
	/* XSUBs can't be perl lang/perl5db.pl debugged
	if (PERLDB_LINE_OR_SAVESRC)
	    (void)gv_fetchfile(file); */
    }

    if(key & HSf_POPMARK) {
	ax = POPMARK;
	{   SV **mark = PL_stack_base + ax++;
	    {   dSP;
		items = (I32)(SP - MARK);
	    }
	}
    } else {
	items = va_arg(args, U32);
	ax = va_arg(args, U32);
    }
    {
	U32 apiverlen;
	assert(HS_GETAPIVERLEN(key) <= UCHAR_MAX);
	if((apiverlen = HS_GETAPIVERLEN(key))) {
	    char * api_p = va_arg(args, char*);
	    if(apiverlen != sizeof("v" PERL_API_VERSION_STRING)-1
		|| memNE(api_p, "v" PERL_API_VERSION_STRING,
			 sizeof("v" PERL_API_VERSION_STRING)-1))
		Perl_croak_nocontext("Perl API version %s of %"SVf" does not match %s",
				    api_p, SVfARG(PL_stack_base[ax + 0]),
				    "v" PERL_API_VERSION_STRING);
	}
    }
    {
	U32 xsverlen;
	assert(HS_GETXSVERLEN(key) <= UCHAR_MAX && HS_GETXSVERLEN(key) <= HS_APIVERLEN_MAX);
	if((xsverlen = HS_GETXSVERLEN(key)))
	    S_xs_version_bootcheck(aTHX_
		items, ax, va_arg(args, char*), xsverlen);
    }
    va_end(args);
    return ax;
}


STATIC void
S_xs_version_bootcheck(pTHX_ U32 items, U32 ax, const char *xs_p,
d5139 1
a5139 1
	sv = get_sv(Perl_form(aTHX_ "%"SVf"::%s", SVfARG(module), vn), 0);
d5142 1
a5142 1
	    sv = get_sv(Perl_form(aTHX_ "%"SVf"::%s", SVfARG(module), vn), 0);
d5153 1
a5153 1
				    " does not match ", SVfARG(module), SVfARG(string));
d5159 2
a5160 2
		Perl_sv_catpvf(aTHX_ xpt, "$%"SVf"::%s %"SVf, SVfARG(module), vn,
			       SVfARG(string));
d5162 1
a5162 1
		Perl_sv_catpvf(aTHX_ xpt, "bootstrap parameter %"SVf, SVfARG(string));
d5172 30
d5290 1
d5306 1
a5306 1
	if (!svp && !CvLEXICAL(cv)) {
d5309 1
a5309 1
	else if ( (CvFLAGS(cv) & (CVf_ANON | CVf_CLONED)) || CvLEXICAL(cv)
d5329 4
a5332 1
	    sv_cathek(dbsv, GvNAME_HEK(gv));
d5350 1
a5350 1
Perl_my_dirfd(DIR * dir) {
d5360 2
a5361 2
    Perl_croak_nocontext(PL_no_func, "dirfd");
    NOT_REACHED; /* NOTREACHED */
d5434 1
a5434 1
    *random_state = FREEBSD_DRAND48_SEED_0 + ((U64)seed << 16);
d5478 1
d5480 6
a5485 111
#ifdef USE_C_BACKTRACE

/* Possibly move all this USE_C_BACKTRACE code into a new file. */

#ifdef USE_BFD

typedef struct {
    /* abfd is the BFD handle. */
    bfd* abfd;
    /* bfd_syms is the BFD symbol table. */
    asymbol** bfd_syms;
    /* bfd_text is handle to the the ".text" section of the object file. */
    asection* bfd_text;
    /* Since opening the executable and scanning its symbols is quite
     * heavy operation, we remember the filename we used the last time,
     * and do the opening and scanning only if the filename changes.
     * This removes most (but not all) open+scan cycles. */
    const char* fname_prev;
} bfd_context;

/* Given a dl_info, update the BFD context if necessary. */
static void bfd_update(bfd_context* ctx, Dl_info* dl_info)
{
    /* BFD open and scan only if the filename changed. */
    if (ctx->fname_prev == NULL ||
        strNE(dl_info->dli_fname, ctx->fname_prev)) {
        if (ctx->abfd) {
            bfd_close(ctx->abfd);
        }
        ctx->abfd = bfd_openr(dl_info->dli_fname, 0);
        if (ctx->abfd) {
            if (bfd_check_format(ctx->abfd, bfd_object)) {
                IV symbol_size = bfd_get_symtab_upper_bound(ctx->abfd);
                if (symbol_size > 0) {
                    Safefree(ctx->bfd_syms);
                    Newx(ctx->bfd_syms, symbol_size, asymbol*);
                    ctx->bfd_text =
                        bfd_get_section_by_name(ctx->abfd, ".text");
                }
                else
                    ctx->abfd = NULL;
            }
            else
                ctx->abfd = NULL;
        }
        ctx->fname_prev = dl_info->dli_fname;
    }
}

/* Given a raw frame, try to symbolize it and store
 * symbol information (source file, line number) away. */
static void bfd_symbolize(bfd_context* ctx,
                          void* raw_frame,
                          char** symbol_name,
                          STRLEN* symbol_name_size,
                          char** source_name,
                          STRLEN* source_name_size,
                          STRLEN* source_line)
{
    *symbol_name = NULL;
    *symbol_name_size = 0;
    if (ctx->abfd) {
        IV offset = PTR2IV(raw_frame) - PTR2IV(ctx->bfd_text->vma);
        if (offset > 0 &&
            bfd_canonicalize_symtab(ctx->abfd, ctx->bfd_syms) > 0) {
            const char *file;
            const char *func;
            unsigned int line = 0;
            if (bfd_find_nearest_line(ctx->abfd, ctx->bfd_text,
                                      ctx->bfd_syms, offset,
                                      &file, &func, &line) &&
                file && func && line > 0) {
                /* Size and copy the source file, use only
                 * the basename of the source file.
                 *
                 * NOTE: the basenames are fine for the
                 * Perl source files, but may not always
                 * be the best idea for XS files. */
                const char *p, *b = NULL;
                /* Look for the last slash. */
                for (p = file; *p; p++) {
                    if (*p == '/')
                        b = p + 1;
                }
                if (b == NULL || *b == 0) {
                    b = file;
                }
                *source_name_size = p - b + 1;
                Newx(*source_name, *source_name_size + 1, char);
                Copy(b, *source_name, *source_name_size + 1, char);

                *symbol_name_size = strlen(func);
                Newx(*symbol_name, *symbol_name_size + 1, char);
                Copy(func, *symbol_name, *symbol_name_size + 1, char);

                *source_line = line;
            }
        }
    }
}

#endif /* #ifdef USE_BFD */

#ifdef PERL_DARWIN

/* OS X has no public API for for 'symbolicating' (Apple official term)
 * stack addresses to {function_name, source_file, line_number}.
 * Good news: there is command line utility atos(1) which does that.
 * Bad news 1: it's a command line utility.
 * Bad news 2: one needs to have the Developer Tools installed.
 * Bad news 3: in newer releases it needs to be run as 'xcrun atos'.
a5486 662
 * To recap: we need to open a pipe for reading for a utility which
 * might not exist, or exists in different locations, and then parse
 * the output.  And since this is all for a low-level API, we cannot
 * use high-level stuff.  Thanks, Apple. */

typedef struct {
    /* tool is set to the absolute pathname of the tool to use:
     * xcrun or atos. */
    const char* tool;
    /* format is set to a printf format string used for building
     * the external command to run. */
    const char* format;
    /* unavail is set if e.g. xcrun cannot be found, or something
     * else happens that makes getting the backtrace dubious.  Note,
     * however, that the context isn't persistent, the next call to
     * get_c_backtrace() will start from scratch. */
    bool unavail;
    /* fname is the current object file name. */
    const char* fname;
    /* object_base_addr is the base address of the shared object. */
    void* object_base_addr;
} atos_context;

/* Given |dl_info|, updates the context.  If the context has been
 * marked unavailable, return immediately.  If not but the tool has
 * not been set, set it to either "xcrun atos" or "atos" (also set the
 * format to use for creating commands for piping), or if neither is
 * unavailable (one needs the Developer Tools installed), mark the context
 * an unavailable.  Finally, update the filename (object name),
 * and its base address. */

static void atos_update(atos_context* ctx,
                        Dl_info* dl_info)
{
    if (ctx->unavail)
        return;
    if (ctx->tool == NULL) {
        const char* tools[] = {
            "/usr/bin/xcrun",
            "/usr/bin/atos"
        };
        const char* formats[] = {
            "/usr/bin/xcrun atos -o '%s' -l %08x %08x 2>&1",
            "/usr/bin/atos -d -o '%s' -l %08x %08x 2>&1"
        };
        struct stat st;
        UV i;
        for (i = 0; i < C_ARRAY_LENGTH(tools); i++) {
            if (stat(tools[i], &st) == 0 && S_ISREG(st.st_mode)) {
                ctx->tool = tools[i];
                ctx->format = formats[i];
                break;
            }
        }
        if (ctx->tool == NULL) {
            ctx->unavail = TRUE;
            return;
        }
    }
    if (ctx->fname == NULL ||
        strNE(dl_info->dli_fname, ctx->fname)) {
        ctx->fname = dl_info->dli_fname;
        ctx->object_base_addr = dl_info->dli_fbase;
    }
}

/* Given an output buffer end |p| and its |start|, matches
 * for the atos output, extracting the source code location
 * and returning non-NULL if possible, returning NULL otherwise. */
static const char* atos_parse(const char* p,
                              const char* start,
                              STRLEN* source_name_size,
                              STRLEN* source_line) {
    /* atos() output is something like:
     * perl_parse (in miniperl) (perl.c:2314)\n\n".
     * We cannot use Perl regular expressions, because we need to
     * stay low-level.  Therefore here we have a rolled-out version
     * of a state machine which matches _backwards_from_the_end_ and
     * if there's a success, returns the starts of the filename,
     * also setting the filename size and the source line number.
     * The matched regular expression is roughly "\(.*:\d+\)\s*$" */
    const char* source_number_start;
    const char* source_name_end;
    const char* source_line_end;
    const char* close_paren;
    UV uv;

    /* Skip trailing whitespace. */
    while (p > start && isspace(*p)) p--;
    /* Now we should be at the close paren. */
    if (p == start || *p != ')')
        return NULL;
    close_paren = p;
    p--;
    /* Now we should be in the line number. */
    if (p == start || !isdigit(*p))
        return NULL;
    /* Skip over the digits. */
    while (p > start && isdigit(*p))
        p--;
    /* Now we should be at the colon. */
    if (p == start || *p != ':')
        return NULL;
    source_number_start = p + 1;
    source_name_end = p; /* Just beyond the end. */
    p--;
    /* Look for the open paren. */
    while (p > start && *p != '(')
        p--;
    if (p == start)
        return NULL;
    p++;
    *source_name_size = source_name_end - p;
    if (grok_atoUV(source_number_start, &uv,  &source_line_end)
        && source_line_end == close_paren
        && uv <= PERL_INT_MAX
    ) {
        *source_line = (STRLEN)uv;
        return p;
    }
    return NULL;
}

/* Given a raw frame, read a pipe from the symbolicator (that's the
 * technical term) atos, reads the result, and parses the source code
 * location.  We must stay low-level, so we use snprintf(), pipe(),
 * and fread(), and then also parse the output ourselves. */
static void atos_symbolize(atos_context* ctx,
                           void* raw_frame,
                           char** source_name,
                           STRLEN* source_name_size,
                           STRLEN* source_line)
{
    char cmd[1024];
    const char* p;
    Size_t cnt;

    if (ctx->unavail)
        return;
    /* Simple security measure: if there's any funny business with
     * the object name (used as "-o '%s'" ), leave since at least
     * partially the user controls it. */
    for (p = ctx->fname; *p; p++) {
        if (*p == '\'' || iscntrl(*p)) {
            ctx->unavail = TRUE;
            return;
        }
    }
    cnt = snprintf(cmd, sizeof(cmd), ctx->format,
                   ctx->fname, ctx->object_base_addr, raw_frame);
    if (cnt < sizeof(cmd)) {
        /* Undo nostdio.h #defines that disable stdio.
         * This is somewhat naughty, but is used elsewhere
         * in the core, and affects only OS X. */
#undef FILE
#undef popen
#undef fread
#undef pclose
        FILE* fp = popen(cmd, "r");
        /* At the moment we open a new pipe for each stack frame.
         * This is naturally somewhat slow, but hopefully generating
         * stack traces is never going to in a performance critical path.
         *
         * We could play tricks with atos by batching the stack
         * addresses to be resolved: atos can either take multiple
         * addresses from the command line, or read addresses from
         * a file (though the mess of creating temporary files would
         * probably negate much of any possible speedup).
         *
         * Normally there are only two objects present in the backtrace:
         * perl itself, and the libdyld.dylib.  (Note that the object
         * filenames contain the full pathname, so perl may not always
         * be in the same place.)  Whenever the object in the
         * backtrace changes, the base address also changes.
         *
         * The problem with batching the addresses, though, would be
         * matching the results with the addresses: the parsing of
         * the results is already painful enough with a single address. */
        if (fp) {
            char out[1024];
            UV cnt = fread(out, 1, sizeof(out), fp);
            if (cnt < sizeof(out)) {
                const char* p = atos_parse(out + cnt - 1, out,
                                           source_name_size,
                                           source_line);
                if (p) {
                    Newx(*source_name,
                         *source_name_size, char);
                    Copy(p, *source_name,
                         *source_name_size,  char);
                }
            }
            pclose(fp);
        }
    }
}

#endif /* #ifdef PERL_DARWIN */

/*
=for apidoc get_c_backtrace

Collects the backtrace (aka "stacktrace") into a single linear
malloced buffer, which the caller B<must> C<Perl_free_c_backtrace()>.

Scans the frames back by S<C<depth + skip>>, then drops the C<skip> innermost,
returning at most C<depth> frames.

=cut
*/

Perl_c_backtrace*
Perl_get_c_backtrace(pTHX_ int depth, int skip)
{
    /* Note that here we must stay as low-level as possible: Newx(),
     * Copy(), Safefree(); since we may be called from anywhere,
     * so we should avoid higher level constructs like SVs or AVs.
     *
     * Since we are using safesysmalloc() via Newx(), don't try
     * getting backtrace() there, unless you like deep recursion. */

    /* Currently only implemented with backtrace() and dladdr(),
     * for other platforms NULL is returned. */

#if defined(HAS_BACKTRACE) && defined(HAS_DLADDR)
    /* backtrace() is available via <execinfo.h> in glibc and in most
     * modern BSDs; dladdr() is available via <dlfcn.h>. */

    /* We try fetching this many frames total, but then discard
     * the |skip| first ones.  For the remaining ones we will try
     * retrieving more information with dladdr(). */
    int try_depth = skip +  depth;

    /* The addresses (program counters) returned by backtrace(). */
    void** raw_frames;

    /* Retrieved with dladdr() from the addresses returned by backtrace(). */
    Dl_info* dl_infos;

    /* Sizes _including_ the terminating \0 of the object name
     * and symbol name strings. */
    STRLEN* object_name_sizes;
    STRLEN* symbol_name_sizes;

#ifdef USE_BFD
    /* The symbol names comes either from dli_sname,
     * or if using BFD, they can come from BFD. */
    char** symbol_names;
#endif

    /* The source code location information.  Dug out with e.g. BFD. */
    char** source_names;
    STRLEN* source_name_sizes;
    STRLEN* source_lines;

    Perl_c_backtrace* bt = NULL;  /* This is what will be returned. */
    int got_depth; /* How many frames were returned from backtrace(). */
    UV frame_count = 0; /* How many frames we return. */
    UV total_bytes = 0; /* The size of the whole returned backtrace. */

#ifdef USE_BFD
    bfd_context bfd_ctx;
#endif
#ifdef PERL_DARWIN
    atos_context atos_ctx;
#endif

    /* Here are probably possibilities for optimizing.  We could for
     * example have a struct that contains most of these and then
     * allocate |try_depth| of them, saving a bunch of malloc calls.
     * Note, however, that |frames| could not be part of that struct
     * because backtrace() will want an array of just them.  Also be
     * careful about the name strings. */
    Newx(raw_frames, try_depth, void*);
    Newx(dl_infos, try_depth, Dl_info);
    Newx(object_name_sizes, try_depth, STRLEN);
    Newx(symbol_name_sizes, try_depth, STRLEN);
    Newx(source_names, try_depth, char*);
    Newx(source_name_sizes, try_depth, STRLEN);
    Newx(source_lines, try_depth, STRLEN);
#ifdef USE_BFD
    Newx(symbol_names, try_depth, char*);
#endif

    /* Get the raw frames. */
    got_depth = (int)backtrace(raw_frames, try_depth);

    /* We use dladdr() instead of backtrace_symbols() because we want
     * the full details instead of opaque strings.  This is useful for
     * two reasons: () the details are needed for further symbolic
     * digging, for example in OS X (2) by having the details we fully
     * control the output, which in turn is useful when more platforms
     * are added: we can keep out output "portable". */

    /* We want a single linear allocation, which can then be freed
     * with a single swoop.  We will do the usual trick of first
     * walking over the structure and seeing how much we need to
     * allocate, then allocating, and then walking over the structure
     * the second time and populating it. */

    /* First we must compute the total size of the buffer. */
    total_bytes = sizeof(Perl_c_backtrace_header);
    if (got_depth > skip) {
        int i;
#ifdef USE_BFD
        bfd_init(); /* Is this safe to call multiple times? */
        Zero(&bfd_ctx, 1, bfd_context);
#endif
#ifdef PERL_DARWIN
        Zero(&atos_ctx, 1, atos_context);
#endif
        for (i = skip; i < try_depth; i++) {
            Dl_info* dl_info = &dl_infos[i];

            object_name_sizes[i] = 0;
            source_names[i] = NULL;
            source_name_sizes[i] = 0;
            source_lines[i] = 0;

            /* Yes, zero from dladdr() is failure. */
            if (dladdr(raw_frames[i], dl_info)) {
                total_bytes += sizeof(Perl_c_backtrace_frame);

                object_name_sizes[i] =
                    dl_info->dli_fname ? strlen(dl_info->dli_fname) : 0;
                symbol_name_sizes[i] =
                    dl_info->dli_sname ? strlen(dl_info->dli_sname) : 0;
#ifdef USE_BFD
                bfd_update(&bfd_ctx, dl_info);
                bfd_symbolize(&bfd_ctx, raw_frames[i],
                              &symbol_names[i],
                              &symbol_name_sizes[i],
                              &source_names[i],
                              &source_name_sizes[i],
                              &source_lines[i]);
#endif
#if PERL_DARWIN
                atos_update(&atos_ctx, dl_info);
                atos_symbolize(&atos_ctx,
                               raw_frames[i],
                               &source_names[i],
                               &source_name_sizes[i],
                               &source_lines[i]);
#endif

                /* Plus ones for the terminating \0. */
                total_bytes += object_name_sizes[i] + 1;
                total_bytes += symbol_name_sizes[i] + 1;
                total_bytes += source_name_sizes[i] + 1;

                frame_count++;
            } else {
                break;
            }
        }
#ifdef USE_BFD
        Safefree(bfd_ctx.bfd_syms);
#endif
    }

    /* Now we can allocate and populate the result buffer. */
    Newxc(bt, total_bytes, char, Perl_c_backtrace);
    Zero(bt, total_bytes, char);
    bt->header.frame_count = frame_count;
    bt->header.total_bytes = total_bytes;
    if (frame_count > 0) {
        Perl_c_backtrace_frame* frame = bt->frame_info;
        char* name_base = (char *)(frame + frame_count);
        char* name_curr = name_base; /* Outputting the name strings here. */
        UV i;
        for (i = skip; i < skip + frame_count; i++) {
            Dl_info* dl_info = &dl_infos[i];

            frame->addr = raw_frames[i];
            frame->object_base_addr = dl_info->dli_fbase;
            frame->symbol_addr = dl_info->dli_saddr;

            /* Copies a string, including the \0, and advances the name_curr.
             * Also copies the start and the size to the frame. */
#define PERL_C_BACKTRACE_STRCPY(frame, doffset, src, dsize, size) \
            if (size && src) \
                Copy(src, name_curr, size, char); \
            frame->doffset = name_curr - (char*)bt; \
            frame->dsize = size; \
            name_curr += size; \
            *name_curr++ = 0;

            PERL_C_BACKTRACE_STRCPY(frame, object_name_offset,
                                    dl_info->dli_fname,
                                    object_name_size, object_name_sizes[i]);

#ifdef USE_BFD
            PERL_C_BACKTRACE_STRCPY(frame, symbol_name_offset,
                                    symbol_names[i],
                                    symbol_name_size, symbol_name_sizes[i]);
            Safefree(symbol_names[i]);
#else
            PERL_C_BACKTRACE_STRCPY(frame, symbol_name_offset,
                                    dl_info->dli_sname,
                                    symbol_name_size, symbol_name_sizes[i]);
#endif

            PERL_C_BACKTRACE_STRCPY(frame, source_name_offset,
                                    source_names[i],
                                    source_name_size, source_name_sizes[i]);
            Safefree(source_names[i]);

#undef PERL_C_BACKTRACE_STRCPY

            frame->source_line_number = source_lines[i];

            frame++;
        }
        assert(total_bytes ==
               (UV)(sizeof(Perl_c_backtrace_header) +
                    frame_count * sizeof(Perl_c_backtrace_frame) +
                    name_curr - name_base));
    }
#ifdef USE_BFD
    Safefree(symbol_names);
    if (bfd_ctx.abfd) {
        bfd_close(bfd_ctx.abfd);
    }
#endif
    Safefree(source_lines);
    Safefree(source_name_sizes);
    Safefree(source_names);
    Safefree(symbol_name_sizes);
    Safefree(object_name_sizes);
    /* Assuming the strings returned by dladdr() are pointers
     * to read-only static memory (the object file), so that
     * they do not need freeing (and cannot be). */
    Safefree(dl_infos);
    Safefree(raw_frames);
    return bt;
#else
    PERL_UNUSED_ARGV(depth);
    PERL_UNUSED_ARGV(skip);
    return NULL;
#endif
}

/*
=for apidoc free_c_backtrace

Deallocates a backtrace received from get_c_bracktrace.

=cut
*/

/*
=for apidoc get_c_backtrace_dump

Returns a SV containing a dump of C<depth> frames of the call stack, skipping
the C<skip> innermost ones.  C<depth> of 20 is usually enough.

The appended output looks like:

...
1   10e004812:0082   Perl_croak   util.c:1716    /usr/bin/perl
2   10df8d6d2:1d72   perl_parse   perl.c:3975    /usr/bin/perl
...

The fields are tab-separated.  The first column is the depth (zero
being the innermost non-skipped frame).  In the hex:offset, the hex is
where the program counter was in C<S_parse_body>, and the :offset (might
be missing) tells how much inside the C<S_parse_body> the program counter was.

The C<util.c:1716> is the source code file and line number.

The F</usr/bin/perl> is obvious (hopefully).

Unknowns are C<"-">.  Unknowns can happen unfortunately quite easily:
if the platform doesn't support retrieving the information;
if the binary is missing the debug information;
if the optimizer has transformed the code by for example inlining.

=cut
*/

SV*
Perl_get_c_backtrace_dump(pTHX_ int depth, int skip)
{
    Perl_c_backtrace* bt;

    bt = get_c_backtrace(depth, skip + 1 /* Hide ourselves. */);
    if (bt) {
        Perl_c_backtrace_frame* frame;
        SV* dsv = newSVpvs("");
        UV i;
        for (i = 0, frame = bt->frame_info;
             i < bt->header.frame_count; i++, frame++) {
            Perl_sv_catpvf(aTHX_ dsv, "%d", (int)i);
            Perl_sv_catpvf(aTHX_ dsv, "\t%p", frame->addr ? frame->addr : "-");
            /* Symbol (function) names might disappear without debug info.
             *
             * The source code location might disappear in case of the
             * optimizer inlining or otherwise rearranging the code. */
            if (frame->symbol_addr) {
                Perl_sv_catpvf(aTHX_ dsv, ":%04x",
                               (int)
                               ((char*)frame->addr - (char*)frame->symbol_addr));
            }
            Perl_sv_catpvf(aTHX_ dsv, "\t%s",
                           frame->symbol_name_size &&
                           frame->symbol_name_offset ?
                           (char*)bt + frame->symbol_name_offset : "-");
            if (frame->source_name_size &&
                frame->source_name_offset &&
                frame->source_line_number) {
                Perl_sv_catpvf(aTHX_ dsv, "\t%s:%"UVuf,
                               (char*)bt + frame->source_name_offset,
                               (UV)frame->source_line_number);
            } else {
                Perl_sv_catpvf(aTHX_ dsv, "\t-");
            }
            Perl_sv_catpvf(aTHX_ dsv, "\t%s",
                           frame->object_name_size &&
                           frame->object_name_offset ?
                           (char*)bt + frame->object_name_offset : "-");
            /* The frame->object_base_addr is not output,
             * but it is used for symbolizing/symbolicating. */
            sv_catpvs(dsv, "\n");
        }

        Perl_free_c_backtrace(aTHX_ bt);

        return dsv;
    }

    return NULL;
}

/*
=for apidoc dump_c_backtrace

Dumps the C backtrace to the given C<fp>.

Returns true if a backtrace could be retrieved, false if not.

=cut
*/

bool
Perl_dump_c_backtrace(pTHX_ PerlIO* fp, int depth, int skip)
{
    SV* sv;

    PERL_ARGS_ASSERT_DUMP_C_BACKTRACE;

    sv = Perl_get_c_backtrace_dump(aTHX_ depth, skip);
    if (sv) {
        sv_2mortal(sv);
        PerlIO_printf(fp, "%s", SvPV_nolen(sv));
        return TRUE;
    }
    return FALSE;
}

#endif /* #ifdef USE_C_BACKTRACE */

#ifdef PERL_TSA_ACTIVE

/* pthread_mutex_t and perl_mutex are typedef equivalent
 * so casting the pointers is fine. */

int perl_tsa_mutex_lock(perl_mutex* mutex)
{
    return pthread_mutex_lock((pthread_mutex_t *) mutex);
}

int perl_tsa_mutex_unlock(perl_mutex* mutex)
{
    return pthread_mutex_unlock((pthread_mutex_t *) mutex);
}

int perl_tsa_mutex_destroy(perl_mutex* mutex)
{
    return pthread_mutex_destroy((pthread_mutex_t *) mutex);
}

#endif


#ifdef USE_DTRACE

/* log a sub call or return */

void
Perl_dtrace_probe_call(pTHX_ CV *cv, bool is_call)
{
    const char *func;
    const char *file;
    const char *stash;
    const COP  *start;
    line_t      line;

    PERL_ARGS_ASSERT_DTRACE_PROBE_CALL;

    if (CvNAMED(cv)) {
        HEK *hek = CvNAME_HEK(cv);
        func = HEK_KEY(hek);
    }
    else {
        GV  *gv = CvGV(cv);
        func = GvENAME(gv);
    }
    start = (const COP *)CvSTART(cv);
    file  = CopFILE(start);
    line  = CopLINE(start);
    stash = CopSTASHPV(start);

    if (is_call) {
        PERL_SUB_ENTRY(func, file, line, stash);
    }
    else {
        PERL_SUB_RETURN(func, file, line, stash);
    }
}


/* log a require file loading/loaded  */

void
Perl_dtrace_probe_load(pTHX_ const char *name, bool is_loading)
{
    PERL_ARGS_ASSERT_DTRACE_PROBE_LOAD;

    if (is_loading) {
	PERL_LOADING_FILE(name);
    }
    else {
	PERL_LOADED_FILE(name);
    }
}


/* log an op execution */

void
Perl_dtrace_probe_op(pTHX_ const OP *op)
{
    PERL_ARGS_ASSERT_DTRACE_PROBE_OP;

    PERL_OP_ENTRY(OP_NAME(op));
}


/* log a compile/run phase change */

void
Perl_dtrace_probe_phase(pTHX_ enum perl_phase phase)
{
    const char *ph_old = PL_phase_names[PL_phase];
    const char *ph_new = PL_phase_names[phase];

    PERL_PHASE_CHANGE(ph_new, ph_old);
}

#endif

/*
@


