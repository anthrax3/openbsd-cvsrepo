head	1.21;
access;
symbols
	OPENBSD_6_1:1.21.0.2
	OPENBSD_6_1_BASE:1.21
	OPENBSD_6_0:1.20.0.4
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.19.0.4
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.19.0.6
	OPENBSD_5_8_BASE:1.19
	PERL_5_20_2:1.1.1.16
	OPENBSD_5_7:1.19.0.2
	OPENBSD_5_7_BASE:1.19
	PERL_5_20_1:1.1.1.16
	OPENBSD_5_6:1.18.0.4
	OPENBSD_5_6_BASE:1.18
	PERL_5_18_2:1.1.1.15
	PERL:1.1.1
	OPENBSD_5_5:1.16.0.6
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.2
	OPENBSD_5_4_BASE:1.16
	PERL_5_16_3:1.1.1.14
	OPENBSD_5_3:1.14.0.10
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.8
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.6
	OPENBSD_5_0:1.14.0.4
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.2
	OPENBSD_4_9_BASE:1.14
	PERL_5_12_2:1.1.1.13
	OPENBSD_4_8:1.13.0.4
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.2
	OPENBSD_4_7_BASE:1.13
	PERL_5_10_1:1.1.1.12
	OPENBSD_4_6:1.12.0.6
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.2
	OPENBSD_4_5_BASE:1.12
	PERL_5_10_0:1.1.1.11
	OPENBSD_4_4:1.11.0.10
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.8
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.6
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.4
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.2
	OPENBSD_4_0_BASE:1.11
	PERL_5_8_8:1.1.1.10
	OPENBSD_3_9:1.10.0.6
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.4
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.2
	OPENBSD_3_7_BASE:1.10
	PERL_5_8_6:1.1.1.9
	OPENBSD_3_6:1.9.0.2
	OPENBSD_3_6_BASE:1.9
	PERL_5_8_5:1.1.1.8
	PERL_5_8_3:1.1.1.7
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.21
date	2017.02.05.00.31.52;	author afresh1;	state Exp;
branches;
next	1.20;
commitid	cxJ08BvJA9Pt2PTM;

1.20
date	2016.07.03.01.07.48;	author afresh1;	state Exp;
branches;
next	1.19;
commitid	GzHqjSTnBjdF7Wcw;

1.19
date	2014.11.17.20.56.47;	author afresh1;	state Exp;
branches;
next	1.18;
commitid	QP75iYx42Uo7mMxO;

1.18
date	2014.04.10.06.50.29;	author kili;	state Exp;
branches;
next	1.17;

1.17
date	2014.03.24.15.05.13;	author afresh1;	state Exp;
branches;
next	1.16;

1.16
date	2013.03.25.20.21.01;	author sthen;	state Exp;
branches;
next	1.15;

1.15
date	2013.03.06.19.21.08;	author jasper;	state Exp;
branches;
next	1.14;

1.14
date	2010.09.24.15.06.40;	author millert;	state Exp;
branches
	1.14.8.1;
next	1.13;

1.13
date	2009.10.12.18.24.21;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2008.09.29.17.35.57;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2006.03.28.19.22.57;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2005.01.15.21.30.19;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2004.08.09.18.08.55;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2004.04.07.21.32.59;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.20;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.17;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.34.49;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.03.56;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.51.00;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.48.36;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.11.40;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.11.40;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.37.21;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.08.37;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.22.03;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.14.47;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.43.29;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.04.07.21.12.49;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.08.09.17.45.41;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2005.01.15.21.16.25;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2006.03.28.18.47.27;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2008.09.29.17.18.05;	author millert;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2009.10.12.18.10.34;	author millert;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2010.09.24.14.48.33;	author millert;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2013.03.25.20.06.24;	author sthen;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	2014.03.24.14.58.44;	author afresh1;	state Exp;
branches;
next	1.1.1.16;

1.1.1.16
date	2014.11.17.20.52.36;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;

1.14.8.1
date	2013.03.06.19.23.52;	author jasper;	state Exp;
branches;
next	;


desc
@@


1.21
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@/*    hv.c
 *
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
 *    2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

/*
 *      I sit beside the fire and think
 *          of all that I have seen.
 *                         --Bilbo
 *
 *     [p.278 of _The Lord of the Rings_, II/iii: "The Ring Goes South"]
 */

/* 
=head1 Hash Manipulation Functions
A HV structure represents a Perl hash.  It consists mainly of an array
of pointers, each of which points to a linked list of HE structures.  The
array is indexed by the hash function of the key, so each linked list
represents all the hash entries with the same hash value.  Each HE contains
a pointer to the actual value, plus a pointer to a HEK structure which
holds the key and hash value.

=cut

*/

#include "EXTERN.h"
#define PERL_IN_HV_C
#define PERL_HASH_INTERNAL_ACCESS
#include "perl.h"

#define DO_HSPLIT(xhv) ((xhv)->xhv_keys > (xhv)->xhv_max) /* HvTOTALKEYS(hv) > HvMAX(hv) */
#define HV_FILL_THRESHOLD 31

static const char S_strtab_error[]
    = "Cannot modify shared string table in hv_%s";

#ifdef PURIFY

#define new_HE() (HE*)safemalloc(sizeof(HE))
#define del_HE(p) safefree((char*)p)

#else

STATIC HE*
S_new_he(pTHX)
{
    HE* he;
    void ** const root = &PL_body_roots[HE_SVSLOT];

    if (!*root)
	Perl_more_bodies(aTHX_ HE_SVSLOT, sizeof(HE), PERL_ARENA_SIZE);
    he = (HE*) *root;
    assert(he);
    *root = HeNEXT(he);
    return he;
}

#define new_HE() new_he()
#define del_HE(p) \
    STMT_START { \
	HeNEXT(p) = (HE*)(PL_body_roots[HE_SVSLOT]);	\
	PL_body_roots[HE_SVSLOT] = p; \
    } STMT_END



#endif

STATIC HEK *
S_save_hek_flags(const char *str, I32 len, U32 hash, int flags)
{
    const int flags_masked = flags & HVhek_MASK;
    char *k;
    HEK *hek;

    PERL_ARGS_ASSERT_SAVE_HEK_FLAGS;

    Newx(k, HEK_BASESIZE + len + 2, char);
    hek = (HEK*)k;
    Copy(str, HEK_KEY(hek), len, char);
    HEK_KEY(hek)[len] = 0;
    HEK_LEN(hek) = len;
    HEK_HASH(hek) = hash;
    HEK_FLAGS(hek) = (unsigned char)flags_masked | HVhek_UNSHARED;

    if (flags & HVhek_FREEKEY)
	Safefree(str);
    return hek;
}

/* free the pool of temporary HE/HEK pairs returned by hv_fetch_ent
 * for tied hashes */

void
Perl_free_tied_hv_pool(pTHX)
{
    HE *he = PL_hv_fetch_ent_mh;
    while (he) {
	HE * const ohe = he;
	Safefree(HeKEY_hek(he));
	he = HeNEXT(he);
	del_HE(ohe);
    }
    PL_hv_fetch_ent_mh = NULL;
}

#if defined(USE_ITHREADS)
HEK *
Perl_hek_dup(pTHX_ HEK *source, CLONE_PARAMS* param)
{
    HEK *shared;

    PERL_ARGS_ASSERT_HEK_DUP;
    PERL_UNUSED_ARG(param);

    if (!source)
	return NULL;

    shared = (HEK*)ptr_table_fetch(PL_ptr_table, source);
    if (shared) {
	/* We already shared this hash key.  */
	(void)share_hek_hek(shared);
    }
    else {
	shared
	    = share_hek_flags(HEK_KEY(source), HEK_LEN(source),
			      HEK_HASH(source), HEK_FLAGS(source));
	ptr_table_store(PL_ptr_table, source, shared);
    }
    return shared;
}

HE *
Perl_he_dup(pTHX_ const HE *e, bool shared, CLONE_PARAMS* param)
{
    HE *ret;

    PERL_ARGS_ASSERT_HE_DUP;

    if (!e)
	return NULL;
    /* look for it in the table first */
    ret = (HE*)ptr_table_fetch(PL_ptr_table, e);
    if (ret)
	return ret;

    /* create anew and remember what it is */
    ret = new_HE();
    ptr_table_store(PL_ptr_table, e, ret);

    HeNEXT(ret) = he_dup(HeNEXT(e),shared, param);
    if (HeKLEN(e) == HEf_SVKEY) {
	char *k;
	Newx(k, HEK_BASESIZE + sizeof(const SV *), char);
	HeKEY_hek(ret) = (HEK*)k;
	HeKEY_sv(ret) = sv_dup_inc(HeKEY_sv(e), param);
    }
    else if (shared) {
	/* This is hek_dup inlined, which seems to be important for speed
	   reasons.  */
	HEK * const source = HeKEY_hek(e);
	HEK *shared = (HEK*)ptr_table_fetch(PL_ptr_table, source);

	if (shared) {
	    /* We already shared this hash key.  */
	    (void)share_hek_hek(shared);
	}
	else {
	    shared
		= share_hek_flags(HEK_KEY(source), HEK_LEN(source),
				  HEK_HASH(source), HEK_FLAGS(source));
	    ptr_table_store(PL_ptr_table, source, shared);
	}
	HeKEY_hek(ret) = shared;
    }
    else
	HeKEY_hek(ret) = save_hek_flags(HeKEY(e), HeKLEN(e), HeHASH(e),
                                        HeKFLAGS(e));
    HeVAL(ret) = sv_dup_inc(HeVAL(e), param);
    return ret;
}
#endif	/* USE_ITHREADS */

static void
S_hv_notallowed(pTHX_ int flags, const char *key, I32 klen,
		const char *msg)
{
    SV * const sv = sv_newmortal();

    PERL_ARGS_ASSERT_HV_NOTALLOWED;

    if (!(flags & HVhek_FREEKEY)) {
	sv_setpvn(sv, key, klen);
    }
    else {
	/* Need to free saved eventually assign to mortal SV */
	/* XXX is this line an error ???:  SV *sv = sv_newmortal(); */
	sv_usepvn(sv, (char *) key, klen);
    }
    if (flags & HVhek_UTF8) {
	SvUTF8_on(sv);
    }
    Perl_croak(aTHX_ msg, SVfARG(sv));
}

/* (klen == HEf_SVKEY) is special for MAGICAL hv entries, meaning key slot
 * contains an SV* */

/*
=for apidoc hv_store

Stores an SV in a hash.  The hash key is specified as C<key> and the
absolute value of C<klen> is the length of the key.  If C<klen> is
negative the key is assumed to be in UTF-8-encoded Unicode.  The
C<hash> parameter is the precomputed hash value; if it is zero then
Perl will compute it.

The return value will be
C<NULL> if the operation failed or if the value did not need to be actually
stored within the hash (as in the case of tied hashes).  Otherwise it can
be dereferenced to get the original C<SV*>.  Note that the caller is
responsible for suitably incrementing the reference count of C<val> before
the call, and decrementing it if the function returned C<NULL>.  Effectively
a successful C<hv_store> takes ownership of one reference to C<val>.  This is
usually what you want; a newly created SV has a reference count of one, so
if all your code does is create SVs then store them in a hash, C<hv_store>
will own the only reference to the new SV, and your code doesn't need to do
anything further to tidy up.  C<hv_store> is not implemented as a call to
C<hv_store_ent>, and does not create a temporary SV for the key, so if your
key data is not already in SV form then use C<hv_store> in preference to
C<hv_store_ent>.

See L<perlguts/"Understanding the Magic of Tied Hashes and Arrays"> for more
information on how to use this function on tied hashes.

=for apidoc hv_store_ent

Stores C<val> in a hash.  The hash key is specified as C<key>.  The C<hash>
parameter is the precomputed hash value; if it is zero then Perl will
compute it.  The return value is the new hash entry so created.  It will be
C<NULL> if the operation failed or if the value did not need to be actually
stored within the hash (as in the case of tied hashes).  Otherwise the
contents of the return value can be accessed using the C<He?> macros
described here.  Note that the caller is responsible for suitably
incrementing the reference count of C<val> before the call, and
decrementing it if the function returned NULL.  Effectively a successful
C<hv_store_ent> takes ownership of one reference to C<val>.  This is
usually what you want; a newly created SV has a reference count of one, so
if all your code does is create SVs then store them in a hash, C<hv_store>
will own the only reference to the new SV, and your code doesn't need to do
anything further to tidy up.  Note that C<hv_store_ent> only reads the C<key>;
unlike C<val> it does not take ownership of it, so maintaining the correct
reference count on C<key> is entirely the caller's responsibility.  C<hv_store>
is not implemented as a call to C<hv_store_ent>, and does not create a temporary
SV for the key, so if your key data is not already in SV form then use
C<hv_store> in preference to C<hv_store_ent>.

See L<perlguts/"Understanding the Magic of Tied Hashes and Arrays"> for more
information on how to use this function on tied hashes.

=for apidoc hv_exists

Returns a boolean indicating whether the specified hash key exists.  The
absolute value of C<klen> is the length of the key.  If C<klen> is
negative the key is assumed to be in UTF-8-encoded Unicode.

=for apidoc hv_fetch

Returns the SV which corresponds to the specified key in the hash.
The absolute value of C<klen> is the length of the key.  If C<klen> is
negative the key is assumed to be in UTF-8-encoded Unicode.  If
C<lval> is set then the fetch will be part of a store.  This means that if
there is no value in the hash associated with the given key, then one is
created and a pointer to it is returned.  The C<SV*> it points to can be
assigned to.  But always check that the
return value is non-null before dereferencing it to an C<SV*>.

See L<perlguts/"Understanding the Magic of Tied Hashes and Arrays"> for more
information on how to use this function on tied hashes.

=for apidoc hv_exists_ent

Returns a boolean indicating whether
the specified hash key exists.  C<hash>
can be a valid precomputed hash value, or 0 to ask for it to be
computed.

=cut
*/

/* returns an HE * structure with the all fields set */
/* note that hent_val will be a mortal sv for MAGICAL hashes */
/*
=for apidoc hv_fetch_ent

Returns the hash entry which corresponds to the specified key in the hash.
C<hash> must be a valid precomputed hash number for the given C<key>, or 0
if you want the function to compute it.  IF C<lval> is set then the fetch
will be part of a store.  Make sure the return value is non-null before
accessing it.  The return value when C<hv> is a tied hash is a pointer to a
static location, so be sure to make a copy of the structure if you need to
store it somewhere.

See L<perlguts/"Understanding the Magic of Tied Hashes and Arrays"> for more
information on how to use this function on tied hashes.

=cut
*/

/* Common code for hv_delete()/hv_exists()/hv_fetch()/hv_store()  */
void *
Perl_hv_common_key_len(pTHX_ HV *hv, const char *key, I32 klen_i32,
		       const int action, SV *val, const U32 hash)
{
    STRLEN klen;
    int flags;

    PERL_ARGS_ASSERT_HV_COMMON_KEY_LEN;

    if (klen_i32 < 0) {
	klen = -klen_i32;
	flags = HVhek_UTF8;
    } else {
	klen = klen_i32;
	flags = 0;
    }
    return hv_common(hv, NULL, key, klen, flags, action, val, hash);
}

void *
Perl_hv_common(pTHX_ HV *hv, SV *keysv, const char *key, STRLEN klen,
	       int flags, int action, SV *val, U32 hash)
{
    dVAR;
    XPVHV* xhv;
    HE *entry;
    HE **oentry;
    SV *sv;
    bool is_utf8;
    int masked_flags;
    const int return_svp = action & HV_FETCH_JUST_SV;
    HEK *keysv_hek = NULL;

    if (!hv)
	return NULL;
    if (SvTYPE(hv) == (svtype)SVTYPEMASK)
	return NULL;

    assert(SvTYPE(hv) == SVt_PVHV);

    if (SvSMAGICAL(hv) && SvGMAGICAL(hv) && !(action & HV_DISABLE_UVAR_XKEY)) {
	MAGIC* mg;
	if ((mg = mg_find((const SV *)hv, PERL_MAGIC_uvar))) {
	    struct ufuncs * const uf = (struct ufuncs *)mg->mg_ptr;
	    if (uf->uf_set == NULL) {
		SV* obj = mg->mg_obj;

		if (!keysv) {
		    keysv = newSVpvn_flags(key, klen, SVs_TEMP |
					   ((flags & HVhek_UTF8)
					    ? SVf_UTF8 : 0));
		}
		
		mg->mg_obj = keysv;         /* pass key */
		uf->uf_index = action;      /* pass action */
		magic_getuvar(MUTABLE_SV(hv), mg);
		keysv = mg->mg_obj;         /* may have changed */
		mg->mg_obj = obj;

		/* If the key may have changed, then we need to invalidate
		   any passed-in computed hash value.  */
		hash = 0;
	    }
	}
    }
    if (keysv) {
	if (flags & HVhek_FREEKEY)
	    Safefree(key);
	key = SvPV_const(keysv, klen);
	is_utf8 = (SvUTF8(keysv) != 0);
	if (SvIsCOW_shared_hash(keysv)) {
	    flags = HVhek_KEYCANONICAL | (is_utf8 ? HVhek_UTF8 : 0);
	} else {
	    flags = is_utf8 ? HVhek_UTF8 : 0;
	}
    } else {
	is_utf8 = ((flags & HVhek_UTF8) ? TRUE : FALSE);
    }

    if (action & HV_DELETE) {
	return (void *) hv_delete_common(hv, keysv, key, klen,
					 flags, action, hash);
    }

    xhv = (XPVHV*)SvANY(hv);
    if (SvMAGICAL(hv)) {
	if (SvRMAGICAL(hv) && !(action & (HV_FETCH_ISSTORE|HV_FETCH_ISEXISTS))) {
	    if (mg_find((const SV *)hv, PERL_MAGIC_tied)
		|| SvGMAGICAL((const SV *)hv))
	    {
		/* FIXME should be able to skimp on the HE/HEK here when
		   HV_FETCH_JUST_SV is true.  */
		if (!keysv) {
		    keysv = newSVpvn_utf8(key, klen, is_utf8);
  		} else {
		    keysv = newSVsv(keysv);
		}
                sv = sv_newmortal();
                mg_copy(MUTABLE_SV(hv), sv, (char *)keysv, HEf_SVKEY);

		/* grab a fake HE/HEK pair from the pool or make a new one */
		entry = PL_hv_fetch_ent_mh;
		if (entry)
		    PL_hv_fetch_ent_mh = HeNEXT(entry);
		else {
		    char *k;
		    entry = new_HE();
		    Newx(k, HEK_BASESIZE + sizeof(const SV *), char);
		    HeKEY_hek(entry) = (HEK*)k;
		}
		HeNEXT(entry) = NULL;
		HeSVKEY_set(entry, keysv);
		HeVAL(entry) = sv;
		sv_upgrade(sv, SVt_PVLV);
		LvTYPE(sv) = 'T';
		 /* so we can free entry when freeing sv */
		LvTARG(sv) = MUTABLE_SV(entry);

		/* XXX remove at some point? */
		if (flags & HVhek_FREEKEY)
		    Safefree(key);

		if (return_svp) {
		    return entry ? (void *) &HeVAL(entry) : NULL;
		}
		return (void *) entry;
	    }
#ifdef ENV_IS_CASELESS
	    else if (mg_find((const SV *)hv, PERL_MAGIC_env)) {
		U32 i;
		for (i = 0; i < klen; ++i)
		    if (isLOWER(key[i])) {
			/* Would be nice if we had a routine to do the
			   copy and upercase in a single pass through.  */
			const char * const nkey = strupr(savepvn(key,klen));
			/* Note that this fetch is for nkey (the uppercased
			   key) whereas the store is for key (the original)  */
			void *result = hv_common(hv, NULL, nkey, klen,
						 HVhek_FREEKEY, /* free nkey */
						 0 /* non-LVAL fetch */
						 | HV_DISABLE_UVAR_XKEY
						 | return_svp,
						 NULL /* no value */,
						 0 /* compute hash */);
			if (!result && (action & HV_FETCH_LVALUE)) {
			    /* This call will free key if necessary.
			       Do it this way to encourage compiler to tail
			       call optimise.  */
			    result = hv_common(hv, keysv, key, klen, flags,
					       HV_FETCH_ISSTORE
					       | HV_DISABLE_UVAR_XKEY
					       | return_svp,
					       newSV(0), hash);
			} else {
			    if (flags & HVhek_FREEKEY)
				Safefree(key);
			}
			return result;
		    }
	    }
#endif
	} /* ISFETCH */
	else if (SvRMAGICAL(hv) && (action & HV_FETCH_ISEXISTS)) {
	    if (mg_find((const SV *)hv, PERL_MAGIC_tied)
		|| SvGMAGICAL((const SV *)hv)) {
		/* I don't understand why hv_exists_ent has svret and sv,
		   whereas hv_exists only had one.  */
		SV * const svret = sv_newmortal();
		sv = sv_newmortal();

		if (keysv || is_utf8) {
		    if (!keysv) {
			keysv = newSVpvn_utf8(key, klen, TRUE);
		    } else {
			keysv = newSVsv(keysv);
		    }
		    mg_copy(MUTABLE_SV(hv), sv, (char *)sv_2mortal(keysv), HEf_SVKEY);
		} else {
		    mg_copy(MUTABLE_SV(hv), sv, key, klen);
		}
		if (flags & HVhek_FREEKEY)
		    Safefree(key);
		{
                  MAGIC * const mg = mg_find(sv, PERL_MAGIC_tiedelem);
                  if (mg)
                    magic_existspack(svret, mg);
		}
		/* This cast somewhat evil, but I'm merely using NULL/
		   not NULL to return the boolean exists.
		   And I know hv is not NULL.  */
		return SvTRUE(svret) ? (void *)hv : NULL;
		}
#ifdef ENV_IS_CASELESS
	    else if (mg_find((const SV *)hv, PERL_MAGIC_env)) {
		/* XXX This code isn't UTF8 clean.  */
		char * const keysave = (char * const)key;
		/* Will need to free this, so set FREEKEY flag.  */
		key = savepvn(key,klen);
		key = (const char*)strupr((char*)key);
		is_utf8 = FALSE;
		hash = 0;
		keysv = 0;

		if (flags & HVhek_FREEKEY) {
		    Safefree(keysave);
		}
		flags |= HVhek_FREEKEY;
	    }
#endif
	} /* ISEXISTS */
	else if (action & HV_FETCH_ISSTORE) {
	    bool needs_copy;
	    bool needs_store;
	    hv_magic_check (hv, &needs_copy, &needs_store);
	    if (needs_copy) {
		const bool save_taint = TAINT_get;
		if (keysv || is_utf8) {
		    if (!keysv) {
			keysv = newSVpvn_utf8(key, klen, TRUE);
		    }
		    if (TAINTING_get)
			TAINT_set(SvTAINTED(keysv));
		    keysv = sv_2mortal(newSVsv(keysv));
		    mg_copy(MUTABLE_SV(hv), val, (char*)keysv, HEf_SVKEY);
		} else {
		    mg_copy(MUTABLE_SV(hv), val, key, klen);
		}

		TAINT_IF(save_taint);
#ifdef NO_TAINT_SUPPORT
                PERL_UNUSED_VAR(save_taint);
#endif
		if (!needs_store) {
		    if (flags & HVhek_FREEKEY)
			Safefree(key);
		    return NULL;
		}
#ifdef ENV_IS_CASELESS
		else if (mg_find((const SV *)hv, PERL_MAGIC_env)) {
		    /* XXX This code isn't UTF8 clean.  */
		    const char *keysave = key;
		    /* Will need to free this, so set FREEKEY flag.  */
		    key = savepvn(key,klen);
		    key = (const char*)strupr((char*)key);
		    is_utf8 = FALSE;
		    hash = 0;
		    keysv = 0;

		    if (flags & HVhek_FREEKEY) {
			Safefree(keysave);
		    }
		    flags |= HVhek_FREEKEY;
		}
#endif
	    }
	} /* ISSTORE */
    } /* SvMAGICAL */

    if (!HvARRAY(hv)) {
	if ((action & (HV_FETCH_LVALUE | HV_FETCH_ISSTORE))
#ifdef DYNAMIC_ENV_FETCH  /* if it's an %ENV lookup, we may get it on the fly */
		 || (SvRMAGICAL((const SV *)hv)
		     && mg_find((const SV *)hv, PERL_MAGIC_env))
#endif
								  ) {
	    char *array;
	    Newxz(array,
		 PERL_HV_ARRAY_ALLOC_BYTES(xhv->xhv_max+1 /* HvMAX(hv)+1 */),
		 char);
	    HvARRAY(hv) = (HE**)array;
	}
#ifdef DYNAMIC_ENV_FETCH
	else if (action & HV_FETCH_ISEXISTS) {
	    /* for an %ENV exists, if we do an insert it's by a recursive
	       store call, so avoid creating HvARRAY(hv) right now.  */
	}
#endif
	else {
	    /* XXX remove at some point? */
            if (flags & HVhek_FREEKEY)
                Safefree(key);

	    return NULL;
	}
    }

    if (is_utf8 && !(flags & HVhek_KEYCANONICAL)) {
	char * const keysave = (char *)key;
	key = (char*)bytes_from_utf8((U8*)key, &klen, &is_utf8);
        if (is_utf8)
	    flags |= HVhek_UTF8;
	else
	    flags &= ~HVhek_UTF8;
        if (key != keysave) {
	    if (flags & HVhek_FREEKEY)
		Safefree(keysave);
            flags |= HVhek_WASUTF8 | HVhek_FREEKEY;
	    /* If the caller calculated a hash, it was on the sequence of
	       octets that are the UTF-8 form. We've now changed the sequence
	       of octets stored to that of the equivalent byte representation,
	       so the hash we need is different.  */
	    hash = 0;
	}
    }

    if (keysv && (SvIsCOW_shared_hash(keysv))) {
        if (HvSHAREKEYS(hv))
            keysv_hek  = SvSHARED_HEK_FROM_PV(SvPVX_const(keysv));
        hash = SvSHARED_HASH(keysv);
    }
    else if (!hash)
        PERL_HASH(hash, key, klen);

    masked_flags = (flags & HVhek_MASK);

#ifdef DYNAMIC_ENV_FETCH
    if (!HvARRAY(hv)) entry = NULL;
    else
#endif
    {
	entry = (HvARRAY(hv))[hash & (I32) HvMAX(hv)];
    }

    if (!entry)
        goto not_found;

    if (keysv_hek) {
        /* keysv is actually a HEK in disguise, so we can match just by
         * comparing the HEK pointers in the HE chain. There is a slight
         * caveat: on something like "\x80", which has both plain and utf8
         * representations, perl's hashes do encoding-insensitive lookups,
         * but preserve the encoding of the stored key. Thus a particular
         * key could map to two different HEKs in PL_strtab. We only
         * conclude 'not found' if all the flags are the same; otherwise
         * we fall back to a full search (this should only happen in rare
         * cases).
         */
        int keysv_flags = HEK_FLAGS(keysv_hek);
        HE  *orig_entry = entry;

        for (; entry; entry = HeNEXT(entry)) {
            HEK *hek = HeKEY_hek(entry);
            if (hek == keysv_hek)
                goto found;
            if (HEK_FLAGS(hek) != keysv_flags)
                break; /* need to do full match */
        }
        if (!entry)
            goto not_found;
        /* failed on shortcut - do full search loop */
        entry = orig_entry;
    }

    for (; entry; entry = HeNEXT(entry)) {
	if (HeHASH(entry) != hash)		/* strings can't be equal */
	    continue;
	if (HeKLEN(entry) != (I32)klen)
	    continue;
	if (memNE(HeKEY(entry),key,klen))	/* is this it? */
	    continue;
	if ((HeKFLAGS(entry) ^ masked_flags) & HVhek_UTF8)
	    continue;

      found:
        if (action & (HV_FETCH_LVALUE|HV_FETCH_ISSTORE)) {
	    if (HeKFLAGS(entry) != masked_flags) {
		/* We match if HVhek_UTF8 bit in our flags and hash key's
		   match.  But if entry was set previously with HVhek_WASUTF8
		   and key now doesn't (or vice versa) then we should change
		   the key's flag, as this is assignment.  */
		if (HvSHAREKEYS(hv)) {
		    /* Need to swap the key we have for a key with the flags we
		       need. As keys are shared we can't just write to the
		       flag, so we share the new one, unshare the old one.  */
		    HEK * const new_hek = share_hek_flags(key, klen, hash,
						   masked_flags);
		    unshare_hek (HeKEY_hek(entry));
		    HeKEY_hek(entry) = new_hek;
		}
		else if (hv == PL_strtab) {
		    /* PL_strtab is usually the only hash without HvSHAREKEYS,
		       so putting this test here is cheap  */
		    if (flags & HVhek_FREEKEY)
			Safefree(key);
		    Perl_croak(aTHX_ S_strtab_error,
			       action & HV_FETCH_LVALUE ? "fetch" : "store");
		}
		else
		    HeKFLAGS(entry) = masked_flags;
		if (masked_flags & HVhek_ENABLEHVKFLAGS)
		    HvHASKFLAGS_on(hv);
	    }
	    if (HeVAL(entry) == &PL_sv_placeholder) {
		/* yes, can store into placeholder slot */
		if (action & HV_FETCH_LVALUE) {
		    if (SvMAGICAL(hv)) {
			/* This preserves behaviour with the old hv_fetch
			   implementation which at this point would bail out
			   with a break; (at "if we find a placeholder, we
			   pretend we haven't found anything")

			   That break mean that if a placeholder were found, it
			   caused a call into hv_store, which in turn would
			   check magic, and if there is no magic end up pretty
			   much back at this point (in hv_store's code).  */
			break;
		    }
		    /* LVAL fetch which actually needs a store.  */
		    val = newSV(0);
		    HvPLACEHOLDERS(hv)--;
		} else {
		    /* store */
		    if (val != &PL_sv_placeholder)
			HvPLACEHOLDERS(hv)--;
		}
		HeVAL(entry) = val;
	    } else if (action & HV_FETCH_ISSTORE) {
		SvREFCNT_dec(HeVAL(entry));
		HeVAL(entry) = val;
	    }
	} else if (HeVAL(entry) == &PL_sv_placeholder) {
	    /* if we find a placeholder, we pretend we haven't found
	       anything */
	    break;
	}
	if (flags & HVhek_FREEKEY)
	    Safefree(key);
	if (return_svp) {
            return (void *) &HeVAL(entry);
	}
	return entry;
    }

  not_found:
#ifdef DYNAMIC_ENV_FETCH  /* %ENV lookup?  If so, try to fetch the value now */
    if (!(action & HV_FETCH_ISSTORE) 
	&& SvRMAGICAL((const SV *)hv)
	&& mg_find((const SV *)hv, PERL_MAGIC_env)) {
	unsigned long len;
	const char * const env = PerlEnv_ENVgetenv_len(key,&len);
	if (env) {
	    sv = newSVpvn(env,len);
	    SvTAINTED_on(sv);
	    return hv_common(hv, keysv, key, klen, flags,
			     HV_FETCH_ISSTORE|HV_DISABLE_UVAR_XKEY|return_svp,
			     sv, hash);
	}
    }
#endif

    if (!entry && SvREADONLY(hv) && !(action & HV_FETCH_ISEXISTS)) {
	hv_notallowed(flags, key, klen,
			"Attempt to access disallowed key '%"SVf"' in"
			" a restricted hash");
    }
    if (!(action & (HV_FETCH_LVALUE|HV_FETCH_ISSTORE))) {
	/* Not doing some form of store, so return failure.  */
	if (flags & HVhek_FREEKEY)
	    Safefree(key);
	return NULL;
    }
    if (action & HV_FETCH_LVALUE) {
	val = action & HV_FETCH_EMPTY_HE ? NULL : newSV(0);
	if (SvMAGICAL(hv)) {
	    /* At this point the old hv_fetch code would call to hv_store,
	       which in turn might do some tied magic. So we need to make that
	       magic check happen.  */
	    /* gonna assign to this, so it better be there */
	    /* If a fetch-as-store fails on the fetch, then the action is to
	       recurse once into "hv_store". If we didn't do this, then that
	       recursive call would call the key conversion routine again.
	       However, as we replace the original key with the converted
	       key, this would result in a double conversion, which would show
	       up as a bug if the conversion routine is not idempotent.
	       Hence the use of HV_DISABLE_UVAR_XKEY.  */
	    return hv_common(hv, keysv, key, klen, flags,
			     HV_FETCH_ISSTORE|HV_DISABLE_UVAR_XKEY|return_svp,
			     val, hash);
	    /* XXX Surely that could leak if the fetch-was-store fails?
	       Just like the hv_fetch.  */
	}
    }

    /* Welcome to hv_store...  */

    if (!HvARRAY(hv)) {
	/* Not sure if we can get here.  I think the only case of oentry being
	   NULL is for %ENV with dynamic env fetch.  But that should disappear
	   with magic in the previous code.  */
	char *array;
	Newxz(array,
	     PERL_HV_ARRAY_ALLOC_BYTES(xhv->xhv_max+1 /* HvMAX(hv)+1 */),
	     char);
	HvARRAY(hv) = (HE**)array;
    }

    oentry = &(HvARRAY(hv))[hash & (I32) xhv->xhv_max];

    entry = new_HE();
    /* share_hek_flags will do the free for us.  This might be considered
       bad API design.  */
    if (HvSHAREKEYS(hv))
	HeKEY_hek(entry) = share_hek_flags(key, klen, hash, flags);
    else if (hv == PL_strtab) {
	/* PL_strtab is usually the only hash without HvSHAREKEYS, so putting
	   this test here is cheap  */
	if (flags & HVhek_FREEKEY)
	    Safefree(key);
	Perl_croak(aTHX_ S_strtab_error,
		   action & HV_FETCH_LVALUE ? "fetch" : "store");
    }
    else                                       /* gotta do the real thing */
	HeKEY_hek(entry) = save_hek_flags(key, klen, hash, flags);
    HeVAL(entry) = val;

    if (!*oentry && SvOOK(hv)) {
        /* initial entry, and aux struct present.  */
        struct xpvhv_aux *const aux = HvAUX(hv);
        if (aux->xhv_fill_lazy)
            ++aux->xhv_fill_lazy;
    }

#ifdef PERL_HASH_RANDOMIZE_KEYS
    /* This logic semi-randomizes the insert order in a bucket.
     * Either we insert into the top, or the slot below the top,
     * making it harder to see if there is a collision. We also
     * reset the iterator randomizer if there is one.
     */
    if ( *oentry && PL_HASH_RAND_BITS_ENABLED) {
        PL_hash_rand_bits++;
        PL_hash_rand_bits= ROTL_UV(PL_hash_rand_bits,1);
        if ( PL_hash_rand_bits & 1 ) {
            HeNEXT(entry) = HeNEXT(*oentry);
            HeNEXT(*oentry) = entry;
        } else {
            HeNEXT(entry) = *oentry;
            *oentry = entry;
        }
    } else
#endif
    {
        HeNEXT(entry) = *oentry;
        *oentry = entry;
    }
#ifdef PERL_HASH_RANDOMIZE_KEYS
    if (SvOOK(hv)) {
        /* Currently this makes various tests warn in annoying ways.
         * So Silenced for now. - Yves | bogus end of comment =>* /
        if (HvAUX(hv)->xhv_riter != -1) {
            Perl_ck_warner_d(aTHX_ packWARN(WARN_INTERNAL),
                             "[TESTING] Inserting into a hash during each() traversal results in undefined behavior"
                             pTHX__FORMAT
                             pTHX__VALUE);
        }
        */
        if (PL_HASH_RAND_BITS_ENABLED) {
            if (PL_HASH_RAND_BITS_ENABLED == 1)
                PL_hash_rand_bits += (PTRV)entry + 1;  /* we don't bother to use ptr_hash here */
            PL_hash_rand_bits= ROTL_UV(PL_hash_rand_bits,1);
        }
        HvAUX(hv)->xhv_rand= (U32)PL_hash_rand_bits;
    }
#endif

    if (val == &PL_sv_placeholder)
	HvPLACEHOLDERS(hv)++;
    if (masked_flags & HVhek_ENABLEHVKFLAGS)
	HvHASKFLAGS_on(hv);

    xhv->xhv_keys++; /* HvTOTALKEYS(hv)++ */
    if ( DO_HSPLIT(xhv) ) {
        const STRLEN oldsize = xhv->xhv_max + 1;
        const U32 items = (U32)HvPLACEHOLDERS_get(hv);

        if (items /* hash has placeholders  */
            && !SvREADONLY(hv) /* but is not a restricted hash */) {
            /* If this hash previously was a "restricted hash" and had
               placeholders, but the "restricted" flag has been turned off,
               then the placeholders no longer serve any useful purpose.
               However, they have the downsides of taking up RAM, and adding
               extra steps when finding used values. It's safe to clear them
               at this point, even though Storable rebuilds restricted hashes by
               putting in all the placeholders (first) before turning on the
               readonly flag, because Storable always pre-splits the hash.
               If we're lucky, then we may clear sufficient placeholders to
               avoid needing to split the hash at all.  */
            clear_placeholders(hv, items);
            if (DO_HSPLIT(xhv))
                hsplit(hv, oldsize, oldsize * 2);
        } else
            hsplit(hv, oldsize, oldsize * 2);
    }

    if (return_svp) {
	return entry ? (void *) &HeVAL(entry) : NULL;
    }
    return (void *) entry;
}

STATIC void
S_hv_magic_check(HV *hv, bool *needs_copy, bool *needs_store)
{
    const MAGIC *mg = SvMAGIC(hv);

    PERL_ARGS_ASSERT_HV_MAGIC_CHECK;

    *needs_copy = FALSE;
    *needs_store = TRUE;
    while (mg) {
	if (isUPPER(mg->mg_type)) {
	    *needs_copy = TRUE;
	    if (mg->mg_type == PERL_MAGIC_tied) {
		*needs_store = FALSE;
		return; /* We've set all there is to set. */
	    }
	}
	mg = mg->mg_moremagic;
    }
}

/*
=for apidoc hv_scalar

Evaluates the hash in scalar context and returns the result.  Handles magic
when the hash is tied.

=cut
*/

SV *
Perl_hv_scalar(pTHX_ HV *hv)
{
    SV *sv;

    PERL_ARGS_ASSERT_HV_SCALAR;

    if (SvRMAGICAL(hv)) {
	MAGIC * const mg = mg_find((const SV *)hv, PERL_MAGIC_tied);
	if (mg)
	    return magic_scalarpack(hv, mg);
    }

    sv = sv_newmortal();
    if (HvTOTALKEYS((const HV *)hv)) 
        Perl_sv_setpvf(aTHX_ sv, "%ld/%ld",
                (long)HvFILL(hv), (long)HvMAX(hv) + 1);
    else
        sv_setiv(sv, 0);
    
    return sv;
}

/*
=for apidoc hv_delete

Deletes a key/value pair in the hash.  The value's SV is removed from
the hash, made mortal, and returned to the caller.  The absolute
value of C<klen> is the length of the key.  If C<klen> is negative the
key is assumed to be in UTF-8-encoded Unicode.  The C<flags> value
will normally be zero; if set to C<G_DISCARD> then C<NULL> will be returned.
C<NULL> will also be returned if the key is not found.

=for apidoc hv_delete_ent

Deletes a key/value pair in the hash.  The value SV is removed from the hash,
made mortal, and returned to the caller.  The C<flags> value will normally be
zero; if set to C<G_DISCARD> then C<NULL> will be returned.  C<NULL> will also
be returned if the key is not found.  C<hash> can be a valid precomputed hash
value, or 0 to ask for it to be computed.

=cut
*/

STATIC SV *
S_hv_delete_common(pTHX_ HV *hv, SV *keysv, const char *key, STRLEN klen,
		   int k_flags, I32 d_flags, U32 hash)
{
    dVAR;
    XPVHV* xhv;
    HE *entry;
    HE **oentry;
    HE **first_entry;
    bool is_utf8 = (k_flags & HVhek_UTF8) ? TRUE : FALSE;
    int masked_flags;
    HEK *keysv_hek = NULL;
    U8 mro_changes = 0; /* 1 = isa; 2 = package moved */
    SV *sv;
    GV *gv = NULL;
    HV *stash = NULL;

    if (SvRMAGICAL(hv)) {
	bool needs_copy;
	bool needs_store;
	hv_magic_check (hv, &needs_copy, &needs_store);

	if (needs_copy) {
	    SV *sv;
	    entry = (HE *) hv_common(hv, keysv, key, klen,
				     k_flags & ~HVhek_FREEKEY,
				     HV_FETCH_LVALUE|HV_DISABLE_UVAR_XKEY,
				     NULL, hash);
	    sv = entry ? HeVAL(entry) : NULL;
	    if (sv) {
		if (SvMAGICAL(sv)) {
		    mg_clear(sv);
		}
		if (!needs_store) {
		    if (mg_find(sv, PERL_MAGIC_tiedelem)) {
			/* No longer an element */
			sv_unmagic(sv, PERL_MAGIC_tiedelem);
			return sv;
		    }		
		    return NULL;		/* element cannot be deleted */
		}
#ifdef ENV_IS_CASELESS
		else if (mg_find((const SV *)hv, PERL_MAGIC_env)) {
		    /* XXX This code isn't UTF8 clean.  */
		    keysv = newSVpvn_flags(key, klen, SVs_TEMP);
		    if (k_flags & HVhek_FREEKEY) {
			Safefree(key);
		    }
		    key = strupr(SvPVX(keysv));
		    is_utf8 = 0;
		    k_flags = 0;
		    hash = 0;
		}
#endif
	    }
	}
    }
    xhv = (XPVHV*)SvANY(hv);
    if (!HvARRAY(hv))
	return NULL;

    if (is_utf8 && !(k_flags & HVhek_KEYCANONICAL)) {
	const char * const keysave = key;
	key = (char*)bytes_from_utf8((U8*)key, &klen, &is_utf8);

        if (is_utf8)
            k_flags |= HVhek_UTF8;
	else
            k_flags &= ~HVhek_UTF8;
        if (key != keysave) {
	    if (k_flags & HVhek_FREEKEY) {
		/* This shouldn't happen if our caller does what we expect,
		   but strictly the API allows it.  */
		Safefree(keysave);
	    }
	    k_flags |= HVhek_WASUTF8 | HVhek_FREEKEY;
	}
        HvHASKFLAGS_on(MUTABLE_SV(hv));
    }

    if (keysv && (SvIsCOW_shared_hash(keysv))) {
        if (HvSHAREKEYS(hv))
            keysv_hek  = SvSHARED_HEK_FROM_PV(SvPVX_const(keysv));
        hash = SvSHARED_HASH(keysv);
    }
    else if (!hash)
        PERL_HASH(hash, key, klen);

    masked_flags = (k_flags & HVhek_MASK);

    first_entry = oentry = &(HvARRAY(hv))[hash & (I32) HvMAX(hv)];
    entry = *oentry;

    if (!entry)
        goto not_found;

    if (keysv_hek) {
        /* keysv is actually a HEK in disguise, so we can match just by
         * comparing the HEK pointers in the HE chain. There is a slight
         * caveat: on something like "\x80", which has both plain and utf8
         * representations, perl's hashes do encoding-insensitive lookups,
         * but preserve the encoding of the stored key. Thus a particular
         * key could map to two different HEKs in PL_strtab. We only
         * conclude 'not found' if all the flags are the same; otherwise
         * we fall back to a full search (this should only happen in rare
         * cases).
         */
        int keysv_flags = HEK_FLAGS(keysv_hek);

        for (; entry; oentry = &HeNEXT(entry), entry = *oentry) {
            HEK *hek = HeKEY_hek(entry);
            if (hek == keysv_hek)
                goto found;
            if (HEK_FLAGS(hek) != keysv_flags)
                break; /* need to do full match */
        }
        if (!entry)
            goto not_found;
        /* failed on shortcut - do full search loop */
        oentry = first_entry;
        entry = *oentry;
    }

    for (; entry; oentry = &HeNEXT(entry), entry = *oentry) {
	if (HeHASH(entry) != hash)		/* strings can't be equal */
	    continue;
	if (HeKLEN(entry) != (I32)klen)
	    continue;
	if (memNE(HeKEY(entry),key,klen))	/* is this it? */
	    continue;
	if ((HeKFLAGS(entry) ^ masked_flags) & HVhek_UTF8)
	    continue;

      found:
	if (hv == PL_strtab) {
	    if (k_flags & HVhek_FREEKEY)
		Safefree(key);
	    Perl_croak(aTHX_ S_strtab_error, "delete");
	}

	/* if placeholder is here, it's already been deleted.... */
	if (HeVAL(entry) == &PL_sv_placeholder) {
	    if (k_flags & HVhek_FREEKEY)
		Safefree(key);
	    return NULL;
	}
	if (SvREADONLY(hv) && HeVAL(entry) && SvREADONLY(HeVAL(entry))) {
	    hv_notallowed(k_flags, key, klen,
			    "Attempt to delete readonly key '%"SVf"' from"
			    " a restricted hash");
	}
        if (k_flags & HVhek_FREEKEY)
            Safefree(key);

	/* If this is a stash and the key ends with ::, then someone is 
	 * deleting a package.
	 */
	if (HeVAL(entry) && HvENAME_get(hv)) {
		gv = (GV *)HeVAL(entry);
		if (keysv) key = SvPV(keysv, klen);
		if ((
		     (klen > 1 && key[klen-2] == ':' && key[klen-1] == ':')
		      ||
		     (klen == 1 && key[0] == ':')
		    )
		 && (klen != 6 || hv!=PL_defstash || memNE(key,"main::",6))
		 && SvTYPE(gv) == SVt_PVGV && (stash = GvHV((GV *)gv))
		 && HvENAME_get(stash)) {
			/* A previous version of this code checked that the
			 * GV was still in the symbol table by fetching the
			 * GV with its name. That is not necessary (and
			 * sometimes incorrect), as HvENAME cannot be set
			 * on hv if it is not in the symtab. */
			mro_changes = 2;
			/* Hang on to it for a bit. */
			SvREFCNT_inc_simple_void_NN(
			 sv_2mortal((SV *)gv)
			);
		}
		else if (klen == 3 && strnEQ(key, "ISA", 3) && GvAV(gv)) {
                    AV *isa = GvAV(gv);
                    MAGIC *mg = mg_find((SV*)isa, PERL_MAGIC_isa);

		    mro_changes = 1;
                    if (mg) {
                        if (mg->mg_obj == (SV*)gv) {
                            /* This is the only stash this ISA was used for.
                             * The isaelem magic asserts if there's no
                             * isa magic on the array, so explicitly
                             * remove the magic on both the array and its
                             * elements.  @@ISA shouldn't be /too/ large.
                             */
                            SV **svp, **end;
                        strip_magic:
                            svp = AvARRAY(isa);
                            end = svp + AvFILLp(isa)+1;
                            while (svp < end) {
                                if (*svp)
                                    mg_free_type(*svp, PERL_MAGIC_isaelem);
                                ++svp;
                            }
                            mg_free_type((SV*)GvAV(gv), PERL_MAGIC_isa);
                        }
                        else {
                            /* mg_obj is an array of stashes
                               Note that the array doesn't keep a reference
                               count on the stashes.
                             */
                            AV *av = (AV*)mg->mg_obj;
                            SV **svp, **arrayp;
                            SSize_t index;
                            SSize_t items;

                            assert(SvTYPE(mg->mg_obj) == SVt_PVAV);

                            /* remove the stash from the magic array */
                            arrayp = svp = AvARRAY(av);
                            items = AvFILLp(av) + 1;
                            if (items == 1) {
                                assert(*arrayp == (SV *)gv);
                                mg->mg_obj = NULL;
                                /* avoid a double free on the last stash */
                                AvFILLp(av) = -1;
                                /* The magic isn't MGf_REFCOUNTED, so release
                                 * the array manually.
                                 */
                                SvREFCNT_dec_NN(av);
                                goto strip_magic;
                            }
                            else {
                                while (items--) {
                                    if (*svp == (SV*)gv)
                                        break;
                                    ++svp;
                                }
                                index = svp - arrayp;
                                assert(index >= 0 && index <= AvFILLp(av));
                                if (index < AvFILLp(av)) {
                                    arrayp[index] = arrayp[AvFILLp(av)];
                                }
                                arrayp[AvFILLp(av)] = NULL;
                                --AvFILLp(av);
                            }
                        }
                    }
                }
	}

	sv = d_flags & G_DISCARD ? HeVAL(entry) : sv_2mortal(HeVAL(entry));
	HeVAL(entry) = &PL_sv_placeholder;
	if (sv) {
	    /* deletion of method from stash */
	    if (isGV(sv) && isGV_with_GP(sv) && GvCVu(sv)
	     && HvENAME_get(hv))
		mro_method_changed_in(hv);
	}

	/*
	 * If a restricted hash, rather than really deleting the entry, put
	 * a placeholder there. This marks the key as being "approved", so
	 * we can still access via not-really-existing key without raising
	 * an error.
	 */
	if (SvREADONLY(hv))
	    /* We'll be saving this slot, so the number of allocated keys
	     * doesn't go down, but the number placeholders goes up */
	    HvPLACEHOLDERS(hv)++;
	else {
	    *oentry = HeNEXT(entry);
            if(!*first_entry && SvOOK(hv)) {
                /* removed last entry, and aux struct present.  */
                struct xpvhv_aux *const aux = HvAUX(hv);
                if (aux->xhv_fill_lazy)
                    --aux->xhv_fill_lazy;
            }
	    if (SvOOK(hv) && entry == HvAUX(hv)->xhv_eiter /* HvEITER(hv) */)
		HvLAZYDEL_on(hv);
	    else {
		if (SvOOK(hv) && HvLAZYDEL(hv) &&
		    entry == HeNEXT(HvAUX(hv)->xhv_eiter))
		    HeNEXT(HvAUX(hv)->xhv_eiter) = HeNEXT(entry);
		hv_free_ent(hv, entry);
	    }
	    xhv->xhv_keys--; /* HvTOTALKEYS(hv)-- */
	    if (xhv->xhv_keys == 0)
	        HvHASKFLAGS_off(hv);
	}

	if (d_flags & G_DISCARD) {
	    SvREFCNT_dec(sv);
	    sv = NULL;
	}

	if (mro_changes == 1) mro_isa_changed_in(hv);
	else if (mro_changes == 2)
	    mro_package_moved(NULL, stash, gv, 1);

	return sv;
    }

  not_found:
    if (SvREADONLY(hv)) {
	hv_notallowed(k_flags, key, klen,
			"Attempt to delete disallowed key '%"SVf"' from"
			" a restricted hash");
    }

    if (k_flags & HVhek_FREEKEY)
	Safefree(key);
    return NULL;
}


STATIC void
S_hsplit(pTHX_ HV *hv, STRLEN const oldsize, STRLEN newsize)
{
    STRLEN i = 0;
    char *a = (char*) HvARRAY(hv);
    HE **aep;

    bool do_aux= (
        /* already have an HvAUX(hv) so we have to move it */
        SvOOK(hv) ||
        /* no HvAUX() but array we are going to allocate is large enough
         * there is no point in saving the space for the iterator, and
         * speeds up later traversals. */
        ( ( hv != PL_strtab ) && ( newsize >= PERL_HV_ALLOC_AUX_SIZE ) )
    );

    PERL_ARGS_ASSERT_HSPLIT;

    PL_nomemok = TRUE;
    Renew(a, PERL_HV_ARRAY_ALLOC_BYTES(newsize)
          + (do_aux ? sizeof(struct xpvhv_aux) : 0), char);
    PL_nomemok = FALSE;
    if (!a) {
      return;
    }

#ifdef PERL_HASH_RANDOMIZE_KEYS
    /* the idea of this is that we create a "random" value by hashing the address of
     * the array, we then use the low bit to decide if we insert at the top, or insert
     * second from top. After each such insert we rotate the hashed value. So we can
     * use the same hashed value over and over, and in normal build environments use
     * very few ops to do so. ROTL32() should produce a single machine operation. */
    if (PL_HASH_RAND_BITS_ENABLED) {
        if (PL_HASH_RAND_BITS_ENABLED == 1)
            PL_hash_rand_bits += ptr_hash((PTRV)a);
        PL_hash_rand_bits = ROTL_UV(PL_hash_rand_bits,1);
    }
#endif
    HvARRAY(hv) = (HE**) a;
    HvMAX(hv) = newsize - 1;
    /* before we zero the newly added memory, we
     * need to deal with the aux struct that may be there
     * or have been allocated by us*/
    if (do_aux) {
        struct xpvhv_aux *const dest
            = (struct xpvhv_aux*) &a[newsize * sizeof(HE*)];
        if (SvOOK(hv)) {
            /* alread have an aux, copy the old one in place. */
            Move(&a[oldsize * sizeof(HE*)], dest, 1, struct xpvhv_aux);
            /* we reset the iterator's xhv_rand as well, so they get a totally new ordering */
#ifdef PERL_HASH_RANDOMIZE_KEYS
            dest->xhv_rand = (U32)PL_hash_rand_bits;
#endif
            /* For now, just reset the lazy fill counter.
               It would be possible to update the counter in the code below
               instead.  */
            dest->xhv_fill_lazy = 0;
        } else {
            /* no existing aux structure, but we allocated space for one
             * so initialize it properly. This unrolls hv_auxinit() a bit,
             * since we have to do the realloc anyway. */
            /* first we set the iterator's xhv_rand so it can be copied into lastrand below */
#ifdef PERL_HASH_RANDOMIZE_KEYS
            dest->xhv_rand = (U32)PL_hash_rand_bits;
#endif
            /* this is the "non realloc" part of the hv_auxinit() */
            (void)hv_auxinit_internal(dest);
            /* Turn on the OOK flag */
            SvOOK_on(hv);
        }
    }
    /* now we can safely clear the second half */
    Zero(&a[oldsize * sizeof(HE*)], (newsize-oldsize) * sizeof(HE*), char);	/* zero 2nd half*/

    if (!HvTOTALKEYS(hv))       /* skip rest if no entries */
        return;

    newsize--;
    aep = (HE**)a;
    do {
	HE **oentry = aep + i;
	HE *entry = aep[i];

	if (!entry)				/* non-existent */
	    continue;
	do {
            U32 j = (HeHASH(entry) & newsize);
	    if (j != (U32)i) {
		*oentry = HeNEXT(entry);
#ifdef PERL_HASH_RANDOMIZE_KEYS
                /* if the target cell is empty or PL_HASH_RAND_BITS_ENABLED is false
                 * insert to top, otherwise rotate the bucket rand 1 bit,
                 * and use the new low bit to decide if we insert at top,
                 * or next from top. IOW, we only rotate on a collision.*/
                if (aep[j] && PL_HASH_RAND_BITS_ENABLED) {
                    PL_hash_rand_bits+= ROTL32(HeHASH(entry), 17);
                    PL_hash_rand_bits= ROTL_UV(PL_hash_rand_bits,1);
                    if (PL_hash_rand_bits & 1) {
                        HeNEXT(entry)= HeNEXT(aep[j]);
                        HeNEXT(aep[j])= entry;
                    } else {
                        /* Note, this is structured in such a way as the optimizer
                        * should eliminate the duplicated code here and below without
                        * us needing to explicitly use a goto. */
                        HeNEXT(entry) = aep[j];
                        aep[j] = entry;
                    }
                } else
#endif
                {
                    /* see comment above about duplicated code */
                    HeNEXT(entry) = aep[j];
                    aep[j] = entry;
                }
	    }
	    else {
		oentry = &HeNEXT(entry);
	    }
	    entry = *oentry;
	} while (entry);
    } while (i++ < oldsize);
}

void
Perl_hv_ksplit(pTHX_ HV *hv, IV newmax)
{
    XPVHV* xhv = (XPVHV*)SvANY(hv);
    const I32 oldsize = (I32) xhv->xhv_max+1; /* HvMAX(hv)+1 (sick) */
    I32 newsize;
    char *a;

    PERL_ARGS_ASSERT_HV_KSPLIT;

    newsize = (I32) newmax;			/* possible truncation here */
    if (newsize != newmax || newmax <= oldsize)
	return;
    while ((newsize & (1 + ~newsize)) != newsize) {
	newsize &= ~(newsize & (1 + ~newsize));	/* get proper power of 2 */
    }
    if (newsize < newmax)
	newsize *= 2;
    if (newsize < newmax)
	return;					/* overflow detection */

    a = (char *) HvARRAY(hv);
    if (a) {
        hsplit(hv, oldsize, newsize);
    } else {
        Newxz(a, PERL_HV_ARRAY_ALLOC_BYTES(newsize), char);
        xhv->xhv_max = --newsize;
        HvARRAY(hv) = (HE **) a;
    }
}

/* IMO this should also handle cases where hv_max is smaller than hv_keys
 * as tied hashes could play silly buggers and mess us around. We will
 * do the right thing during hv_store() afterwards, but still - Yves */
#define HV_SET_MAX_ADJUSTED_FOR_KEYS(hv,hv_max,hv_keys) STMT_START {\
    /* Can we use fewer buckets? (hv_max is always 2^n-1) */        \
    if (hv_max < PERL_HASH_DEFAULT_HvMAX) {                         \
        hv_max = PERL_HASH_DEFAULT_HvMAX;                           \
    } else {                                                        \
        while (hv_max > PERL_HASH_DEFAULT_HvMAX && hv_max + 1 >= hv_keys * 2) \
            hv_max = hv_max / 2;                                    \
    }                                                               \
    HvMAX(hv) = hv_max;                                             \
} STMT_END


HV *
Perl_newHVhv(pTHX_ HV *ohv)
{
    dVAR;
    HV * const hv = newHV();
    STRLEN hv_max;

    if (!ohv || (!HvTOTALKEYS(ohv) && !SvMAGICAL((const SV *)ohv)))
	return hv;
    hv_max = HvMAX(ohv);

    if (!SvMAGICAL((const SV *)ohv)) {
	/* It's an ordinary hash, so copy it fast. AMS 20010804 */
	STRLEN i;
	const bool shared = !!HvSHAREKEYS(ohv);
	HE **ents, ** const oents = (HE **)HvARRAY(ohv);
	char *a;
	Newx(a, PERL_HV_ARRAY_ALLOC_BYTES(hv_max+1), char);
	ents = (HE**)a;

	/* In each bucket... */
	for (i = 0; i <= hv_max; i++) {
	    HE *prev = NULL;
	    HE *oent = oents[i];

	    if (!oent) {
		ents[i] = NULL;
		continue;
	    }

	    /* Copy the linked list of entries. */
	    for (; oent; oent = HeNEXT(oent)) {
		const U32 hash   = HeHASH(oent);
		const char * const key = HeKEY(oent);
		const STRLEN len = HeKLEN(oent);
		const int flags  = HeKFLAGS(oent);
		HE * const ent   = new_HE();
		SV *const val    = HeVAL(oent);

		HeVAL(ent) = SvIMMORTAL(val) ? val : newSVsv(val);
		HeKEY_hek(ent)
                    = shared ? share_hek_flags(key, len, hash, flags)
                             :  save_hek_flags(key, len, hash, flags);
		if (prev)
		    HeNEXT(prev) = ent;
		else
		    ents[i] = ent;
		prev = ent;
		HeNEXT(ent) = NULL;
	    }
	}

	HvMAX(hv)   = hv_max;
	HvTOTALKEYS(hv)  = HvTOTALKEYS(ohv);
	HvARRAY(hv) = ents;
    } /* not magical */
    else {
	/* Iterate over ohv, copying keys and values one at a time. */
	HE *entry;
	const I32 riter = HvRITER_get(ohv);
	HE * const eiter = HvEITER_get(ohv);
        STRLEN hv_keys = HvTOTALKEYS(ohv);

        HV_SET_MAX_ADJUSTED_FOR_KEYS(hv,hv_max,hv_keys);

	hv_iterinit(ohv);
	while ((entry = hv_iternext_flags(ohv, 0))) {
	    SV *val = hv_iterval(ohv,entry);
	    SV * const keysv = HeSVKEY(entry);
	    val = SvIMMORTAL(val) ? val : newSVsv(val);
	    if (keysv)
		(void)hv_store_ent(hv, keysv, val, 0);
	    else
	        (void)hv_store_flags(hv, HeKEY(entry), HeKLEN(entry), val,
				 HeHASH(entry), HeKFLAGS(entry));
	}
	HvRITER_set(ohv, riter);
	HvEITER_set(ohv, eiter);
    }

    return hv;
}

/*
=for apidoc Am|HV *|hv_copy_hints_hv|HV *ohv

A specialised version of L</newHVhv> for copying C<%^H>.  C<ohv> must be
a pointer to a hash (which may have C<%^H> magic, but should be generally
non-magical), or C<NULL> (interpreted as an empty hash).  The content
of C<ohv> is copied to a new hash, which has the C<%^H>-specific magic
added to it.  A pointer to the new hash is returned.

=cut
*/

HV *
Perl_hv_copy_hints_hv(pTHX_ HV *const ohv)
{
    HV * const hv = newHV();

    if (ohv) {
	STRLEN hv_max = HvMAX(ohv);
        STRLEN hv_keys = HvTOTALKEYS(ohv);
	HE *entry;
	const I32 riter = HvRITER_get(ohv);
	HE * const eiter = HvEITER_get(ohv);

	ENTER;
	SAVEFREESV(hv);

        HV_SET_MAX_ADJUSTED_FOR_KEYS(hv,hv_max,hv_keys);

	hv_iterinit(ohv);
	while ((entry = hv_iternext_flags(ohv, 0))) {
	    SV *const sv = newSVsv(hv_iterval(ohv,entry));
	    SV *heksv = HeSVKEY(entry);
	    if (!heksv && sv) heksv = newSVhek(HeKEY_hek(entry));
	    if (sv) sv_magic(sv, NULL, PERL_MAGIC_hintselem,
		     (char *)heksv, HEf_SVKEY);
	    if (heksv == HeSVKEY(entry))
		(void)hv_store_ent(hv, heksv, sv, 0);
	    else {
		(void)hv_common(hv, heksv, HeKEY(entry), HeKLEN(entry),
				 HeKFLAGS(entry), HV_FETCH_ISSTORE|HV_FETCH_JUST_SV, sv, HeHASH(entry));
		SvREFCNT_dec_NN(heksv);
	    }
	}
	HvRITER_set(ohv, riter);
	HvEITER_set(ohv, eiter);

	SvREFCNT_inc_simple_void_NN(hv);
	LEAVE;
    }
    hv_magic(hv, NULL, PERL_MAGIC_hints);
    return hv;
}
#undef HV_SET_MAX_ADJUSTED_FOR_KEYS

/* like hv_free_ent, but returns the SV rather than freeing it */
STATIC SV*
S_hv_free_ent_ret(pTHX_ HV *hv, HE *entry)
{
    SV *val;

    PERL_ARGS_ASSERT_HV_FREE_ENT_RET;

    val = HeVAL(entry);
    if (HeKLEN(entry) == HEf_SVKEY) {
	SvREFCNT_dec(HeKEY_sv(entry));
	Safefree(HeKEY_hek(entry));
    }
    else if (HvSHAREKEYS(hv))
	unshare_hek(HeKEY_hek(entry));
    else
	Safefree(HeKEY_hek(entry));
    del_HE(entry);
    return val;
}


void
Perl_hv_free_ent(pTHX_ HV *hv, HE *entry)
{
    SV *val;

    PERL_ARGS_ASSERT_HV_FREE_ENT;

    if (!entry)
	return;
    val = hv_free_ent_ret(hv, entry);
    SvREFCNT_dec(val);
}


void
Perl_hv_delayfree_ent(pTHX_ HV *hv, HE *entry)
{
    PERL_ARGS_ASSERT_HV_DELAYFREE_ENT;

    if (!entry)
	return;
    /* SvREFCNT_inc to counter the SvREFCNT_dec in hv_free_ent  */
    sv_2mortal(SvREFCNT_inc(HeVAL(entry)));	/* free between statements */
    if (HeKLEN(entry) == HEf_SVKEY) {
	sv_2mortal(SvREFCNT_inc(HeKEY_sv(entry)));
    }
    hv_free_ent(hv, entry);
}

/*
=for apidoc hv_clear

Frees the all the elements of a hash, leaving it empty.
The XS equivalent of C<%hash = ()>.  See also L</hv_undef>.

See L</av_clear> for a note about the hash possibly being invalid on
return.

=cut
*/

void
Perl_hv_clear(pTHX_ HV *hv)
{
    dVAR;
    XPVHV* xhv;
    if (!hv)
	return;

    DEBUG_A(Perl_hv_assert(aTHX_ hv));

    xhv = (XPVHV*)SvANY(hv);

    ENTER;
    SAVEFREESV(SvREFCNT_inc_simple_NN(hv));
    if (SvREADONLY(hv) && HvARRAY(hv) != NULL) {
	/* restricted hash: convert all keys to placeholders */
	STRLEN i;
	for (i = 0; i <= xhv->xhv_max; i++) {
	    HE *entry = (HvARRAY(hv))[i];
	    for (; entry; entry = HeNEXT(entry)) {
		/* not already placeholder */
		if (HeVAL(entry) != &PL_sv_placeholder) {
		    if (HeVAL(entry)) {
			if (SvREADONLY(HeVAL(entry))) {
			    SV* const keysv = hv_iterkeysv(entry);
			    Perl_croak_nocontext(
				"Attempt to delete readonly key '%"SVf"' from a restricted hash",
				(void*)keysv);
			}
			SvREFCNT_dec_NN(HeVAL(entry));
		    }
		    HeVAL(entry) = &PL_sv_placeholder;
		    HvPLACEHOLDERS(hv)++;
		}
	    }
	}
    }
    else {
	hfreeentries(hv);
	HvPLACEHOLDERS_set(hv, 0);

	if (SvRMAGICAL(hv))
	    mg_clear(MUTABLE_SV(hv));

	HvHASKFLAGS_off(hv);
    }
    if (SvOOK(hv)) {
        if(HvENAME_get(hv))
            mro_isa_changed_in(hv);
	HvEITER_set(hv, NULL);
    }
    LEAVE;
}

/*
=for apidoc hv_clear_placeholders

Clears any placeholders from a hash.  If a restricted hash has any of its keys
marked as readonly and the key is subsequently deleted, the key is not actually
deleted but is marked by assigning it a value of C<&PL_sv_placeholder>.  This tags
it so it will be ignored by future operations such as iterating over the hash,
but will still allow the hash to have a value reassigned to the key at some
future point.  This function clears any such placeholder keys from the hash.
See C<L<Hash::Util::lock_keys()|Hash::Util/lock_keys>> for an example of its
use.

=cut
*/

void
Perl_hv_clear_placeholders(pTHX_ HV *hv)
{
    const U32 items = (U32)HvPLACEHOLDERS_get(hv);

    PERL_ARGS_ASSERT_HV_CLEAR_PLACEHOLDERS;

    if (items)
	clear_placeholders(hv, items);
}

static void
S_clear_placeholders(pTHX_ HV *hv, U32 items)
{
    dVAR;
    I32 i;

    PERL_ARGS_ASSERT_CLEAR_PLACEHOLDERS;

    if (items == 0)
	return;

    i = HvMAX(hv);
    do {
	/* Loop down the linked list heads  */
	HE **oentry = &(HvARRAY(hv))[i];
	HE *entry;

	while ((entry = *oentry)) {
	    if (HeVAL(entry) == &PL_sv_placeholder) {
		*oentry = HeNEXT(entry);
		if (entry == HvEITER_get(hv))
		    HvLAZYDEL_on(hv);
		else {
		    if (SvOOK(hv) && HvLAZYDEL(hv) &&
			entry == HeNEXT(HvAUX(hv)->xhv_eiter))
			HeNEXT(HvAUX(hv)->xhv_eiter) = HeNEXT(entry);
		    hv_free_ent(hv, entry);
		}

		if (--items == 0) {
		    /* Finished.  */
		    I32 placeholders = HvPLACEHOLDERS_get(hv);
		    HvTOTALKEYS(hv) -= (IV)placeholders;
		    /* HvUSEDKEYS expanded */
		    if ((HvTOTALKEYS(hv) - placeholders) == 0)
			HvHASKFLAGS_off(hv);
		    HvPLACEHOLDERS_set(hv, 0);
		    return;
		}
	    } else {
		oentry = &HeNEXT(entry);
	    }
	}
    } while (--i >= 0);
    /* You can't get here, hence assertion should always fail.  */
    assert (items == 0);
    NOT_REACHED; /* NOTREACHED */
}

STATIC void
S_hfreeentries(pTHX_ HV *hv)
{
    STRLEN index = 0;
    XPVHV * const xhv = (XPVHV*)SvANY(hv);
    SV *sv;

    PERL_ARGS_ASSERT_HFREEENTRIES;

    while ((sv = Perl_hfree_next_entry(aTHX_ hv, &index))||xhv->xhv_keys) {
	SvREFCNT_dec(sv);
    }
}


/* hfree_next_entry()
 * For use only by S_hfreeentries() and sv_clear().
 * Delete the next available HE from hv and return the associated SV.
 * Returns null on empty hash. Nevertheless null is not a reliable
 * indicator that the hash is empty, as the deleted entry may have a
 * null value.
 * indexp is a pointer to the current index into HvARRAY. The index should
 * initially be set to 0. hfree_next_entry() may update it.  */

SV*
Perl_hfree_next_entry(pTHX_ HV *hv, STRLEN *indexp)
{
    struct xpvhv_aux *iter;
    HE *entry;
    HE ** array;
#ifdef DEBUGGING
    STRLEN orig_index = *indexp;
#endif

    PERL_ARGS_ASSERT_HFREE_NEXT_ENTRY;

    if (SvOOK(hv) && ((iter = HvAUX(hv)))) {
	if ((entry = iter->xhv_eiter)) {
            /* the iterator may get resurrected after each
             * destructor call, so check each time */
            if (entry && HvLAZYDEL(hv)) {	/* was deleted earlier? */
                HvLAZYDEL_off(hv);
                hv_free_ent(hv, entry);
                /* warning: at this point HvARRAY may have been
                 * re-allocated, HvMAX changed etc */
            }
            iter = HvAUX(hv); /* may have been realloced */
            iter->xhv_riter = -1; 	/* HvRITER(hv) = -1 */
            iter->xhv_eiter = NULL;	/* HvEITER(hv) = NULL */
#ifdef PERL_HASH_RANDOMIZE_KEYS
            iter->xhv_last_rand = iter->xhv_rand;
#endif
        }
        /* Reset any cached HvFILL() to "unknown".  It's unlikely that anyone
           will actually call HvFILL() on a hash under destruction, so it
           seems pointless attempting to track the number of keys remaining.
           But if they do, we want to reset it again.  */
        if (iter->xhv_fill_lazy)
            iter->xhv_fill_lazy = 0;
    }

    if (!((XPVHV*)SvANY(hv))->xhv_keys)
	return NULL;

    array = HvARRAY(hv);
    assert(array);
    while ( ! ((entry = array[*indexp])) ) {
	if ((*indexp)++ >= HvMAX(hv))
	    *indexp = 0;
	assert(*indexp != orig_index);
    }
    array[*indexp] = HeNEXT(entry);
    ((XPVHV*) SvANY(hv))->xhv_keys--;

    if (   PL_phase != PERL_PHASE_DESTRUCT && HvENAME(hv)
	&& HeVAL(entry) && isGV(HeVAL(entry))
	&& GvHV(HeVAL(entry)) && HvENAME(GvHV(HeVAL(entry)))
    ) {
	STRLEN klen;
	const char * const key = HePV(entry,klen);
	if ((klen > 1 && key[klen-1]==':' && key[klen-2]==':')
	 || (klen == 1 && key[0] == ':')) {
	    mro_package_moved(
	     NULL, GvHV(HeVAL(entry)),
	     (GV *)HeVAL(entry), 0
	    );
	}
    }
    return hv_free_ent_ret(hv, entry);
}


/*
=for apidoc hv_undef

Undefines the hash.  The XS equivalent of C<undef(%hash)>.

As well as freeing all the elements of the hash (like C<hv_clear()>), this
also frees any auxiliary data and storage associated with the hash.

See L</av_clear> for a note about the hash possibly being invalid on
return.

=cut
*/

void
Perl_hv_undef_flags(pTHX_ HV *hv, U32 flags)
{
    XPVHV* xhv;
    bool save;

    if (!hv)
	return;
    save = !!SvREFCNT(hv);
    DEBUG_A(Perl_hv_assert(aTHX_ hv));
    xhv = (XPVHV*)SvANY(hv);

    /* The name must be deleted before the call to hfreeeeentries so that
       CVs are anonymised properly. But the effective name must be pre-
       served until after that call (and only deleted afterwards if the
       call originated from sv_clear). For stashes with one name that is
       both the canonical name and the effective name, hv_name_set has to
       allocate an array for storing the effective name. We can skip that
       during global destruction, as it does not matter where the CVs point
       if they will be freed anyway. */
    /* note that the code following prior to hfreeentries is duplicated
     * in sv_clear(), and changes here should be done there too */
    if (PL_phase != PERL_PHASE_DESTRUCT && HvNAME(hv)) {
        if (PL_stashcache) {
            DEBUG_o(Perl_deb(aTHX_ "hv_undef_flags clearing PL_stashcache for '%"
                             HEKf"'\n", HEKfARG(HvNAME_HEK(hv))));
	    (void)hv_deletehek(PL_stashcache, HvNAME_HEK(hv), G_DISCARD);
        }
	hv_name_set(hv, NULL, 0, 0);
    }
    if (save) {
	ENTER;
	SAVEFREESV(SvREFCNT_inc_simple_NN(hv));
    }
    hfreeentries(hv);
    if (SvOOK(hv)) {
      struct mro_meta *meta;
      const char *name;

      if (HvENAME_get(hv)) {
	if (PL_phase != PERL_PHASE_DESTRUCT)
	    mro_isa_changed_in(hv);
        if (PL_stashcache) {
            DEBUG_o(Perl_deb(aTHX_ "hv_undef_flags clearing PL_stashcache for effective name '%"
                             HEKf"'\n", HEKfARG(HvENAME_HEK(hv))));
	    (void)hv_deletehek(PL_stashcache, HvENAME_HEK(hv), G_DISCARD);
        }
      }

      /* If this call originated from sv_clear, then we must check for
       * effective names that need freeing, as well as the usual name. */
      name = HvNAME(hv);
      if (flags & HV_NAME_SETALL ? !!HvAUX(hv)->xhv_name_u.xhvnameu_name : !!name) {
        if (name && PL_stashcache) {
            DEBUG_o(Perl_deb(aTHX_ "hv_undef_flags clearing PL_stashcache for name '%"
                             HEKf"'\n", HEKfARG(HvNAME_HEK(hv))));
	    (void)hv_deletehek(PL_stashcache, HvNAME_HEK(hv), G_DISCARD);
        }
	hv_name_set(hv, NULL, 0, flags);
      }
      if((meta = HvAUX(hv)->xhv_mro_meta)) {
	if (meta->mro_linear_all) {
	    SvREFCNT_dec_NN(meta->mro_linear_all);
	    /* mro_linear_current is just acting as a shortcut pointer,
	       hence the else.  */
	}
	else
	    /* Only the current MRO is stored, so this owns the data.
	     */
	    SvREFCNT_dec(meta->mro_linear_current);
	SvREFCNT_dec(meta->mro_nextmethod);
	SvREFCNT_dec(meta->isa);
	SvREFCNT_dec(meta->super);
	Safefree(meta);
	HvAUX(hv)->xhv_mro_meta = NULL;
      }
      if (!HvAUX(hv)->xhv_name_u.xhvnameu_name && ! HvAUX(hv)->xhv_backreferences)
	SvFLAGS(hv) &= ~SVf_OOK;
    }
    if (!SvOOK(hv)) {
	Safefree(HvARRAY(hv));
        xhv->xhv_max = PERL_HASH_DEFAULT_HvMAX;        /* HvMAX(hv) = 7 (it's a normal hash) */
	HvARRAY(hv) = 0;
    }
    /* if we're freeing the HV, the SvMAGIC field has been reused for
     * other purposes, and so there can't be any placeholder magic */
    if (SvREFCNT(hv))
	HvPLACEHOLDERS_set(hv, 0);

    if (SvRMAGICAL(hv))
	mg_clear(MUTABLE_SV(hv));
    if (save) LEAVE;
}

/*
=for apidoc hv_fill

Returns the number of hash buckets that
happen to be in use.  This function is
wrapped by the macro C<HvFILL>.

Previously this value was always stored in the HV structure, which created an
overhead on every hash (and pretty much every object) for something that was
rarely used.  Now we calculate it on demand the first
time that it is needed, and cache it if that calculation
is going to be costly to repeat.  The cached
value is updated by insertions and deletions, but (currently) discarded if
the hash is split.

=cut
*/

STRLEN
Perl_hv_fill(pTHX_ HV *const hv)
{
    STRLEN count = 0;
    HE **ents = HvARRAY(hv);
    struct xpvhv_aux *aux = SvOOK(hv) ? HvAUX(hv) : NULL;

    PERL_ARGS_ASSERT_HV_FILL;

    /* No keys implies no buckets used.
       One key can only possibly mean one bucket used.  */
    if (HvTOTALKEYS(hv) < 2)
        return HvTOTALKEYS(hv);

#ifndef DEBUGGING
    if (aux && aux->xhv_fill_lazy)
        return aux->xhv_fill_lazy;
#endif

    if (ents) {
	HE *const *const last = ents + HvMAX(hv);
	count = last + 1 - ents;

	do {
	    if (!*ents)
		--count;
	} while (++ents <= last);
    }
    if (aux) {
#ifdef DEBUGGING
        if (aux->xhv_fill_lazy)
            assert(aux->xhv_fill_lazy == count);
#endif
        aux->xhv_fill_lazy = count;
    } else if (HvMAX(hv) >= HV_FILL_THRESHOLD) {
        aux = hv_auxinit(hv);
        aux->xhv_fill_lazy = count;
    }        
    return count;
}

/* hash a pointer to a U32 - Used in the hash traversal randomization
 * and bucket order randomization code
 *
 * this code was derived from Sereal, which was derived from autobox.
 */

PERL_STATIC_INLINE U32 S_ptr_hash(PTRV u) {
#if PTRSIZE == 8
    /*
     * This is one of Thomas Wang's hash functions for 64-bit integers from:
     * http://www.concentric.net/~Ttwang/tech/inthash.htm
     */
    u = (~u) + (u << 18);
    u = u ^ (u >> 31);
    u = u * 21;
    u = u ^ (u >> 11);
    u = u + (u << 6);
    u = u ^ (u >> 22);
#else
    /*
     * This is one of Bob Jenkins' hash functions for 32-bit integers
     * from: http://burtleburtle.net/bob/hash/integer.html
     */
    u = (u + 0x7ed55d16) + (u << 12);
    u = (u ^ 0xc761c23c) ^ (u >> 19);
    u = (u + 0x165667b1) + (u << 5);
    u = (u + 0xd3a2646c) ^ (u << 9);
    u = (u + 0xfd7046c5) + (u << 3);
    u = (u ^ 0xb55a4f09) ^ (u >> 16);
#endif
    return (U32)u;
}

static struct xpvhv_aux*
S_hv_auxinit_internal(struct xpvhv_aux *iter) {
    PERL_ARGS_ASSERT_HV_AUXINIT_INTERNAL;
    iter->xhv_riter = -1; 	/* HvRITER(hv) = -1 */
    iter->xhv_eiter = NULL;	/* HvEITER(hv) = NULL */
#ifdef PERL_HASH_RANDOMIZE_KEYS
    iter->xhv_last_rand = iter->xhv_rand;
#endif
    iter->xhv_fill_lazy = 0;
    iter->xhv_name_u.xhvnameu_name = 0;
    iter->xhv_name_count = 0;
    iter->xhv_backreferences = 0;
    iter->xhv_mro_meta = NULL;
    iter->xhv_aux_flags = 0;
    return iter;
}


static struct xpvhv_aux*
S_hv_auxinit(pTHX_ HV *hv) {
    struct xpvhv_aux *iter;
    char *array;

    PERL_ARGS_ASSERT_HV_AUXINIT;

    if (!SvOOK(hv)) {
        if (!HvARRAY(hv)) {
            Newxz(array, PERL_HV_ARRAY_ALLOC_BYTES(HvMAX(hv) + 1)
                + sizeof(struct xpvhv_aux), char);
        } else {
            array = (char *) HvARRAY(hv);
            Renew(array, PERL_HV_ARRAY_ALLOC_BYTES(HvMAX(hv) + 1)
                  + sizeof(struct xpvhv_aux), char);
        }
        HvARRAY(hv) = (HE**)array;
        SvOOK_on(hv);
        iter = HvAUX(hv);
#ifdef PERL_HASH_RANDOMIZE_KEYS
        if (PL_HASH_RAND_BITS_ENABLED) {
            /* mix in some new state to PL_hash_rand_bits to "randomize" the traversal order*/
            if (PL_HASH_RAND_BITS_ENABLED == 1)
                PL_hash_rand_bits += ptr_hash((PTRV)array);
            PL_hash_rand_bits = ROTL_UV(PL_hash_rand_bits,1);
        }
        iter->xhv_rand = (U32)PL_hash_rand_bits;
#endif
    } else {
        iter = HvAUX(hv);
    }

    return hv_auxinit_internal(iter);
}

/*
=for apidoc hv_iterinit

Prepares a starting point to traverse a hash table.  Returns the number of
keys in the hash (i.e. the same as C<HvUSEDKEYS(hv)>).  The return value is
currently only meaningful for hashes without tie magic.

NOTE: Before version 5.004_65, C<hv_iterinit> used to return the number of
hash buckets that happen to be in use.  If you still need that esoteric
value, you can get it through the macro C<HvFILL(hv)>.


=cut
*/

I32
Perl_hv_iterinit(pTHX_ HV *hv)
{
    PERL_ARGS_ASSERT_HV_ITERINIT;

    if (SvOOK(hv)) {
	struct xpvhv_aux * iter = HvAUX(hv);
	HE * const entry = iter->xhv_eiter; /* HvEITER(hv) */
	if (entry && HvLAZYDEL(hv)) {	/* was deleted earlier? */
	    HvLAZYDEL_off(hv);
	    hv_free_ent(hv, entry);
	}
	iter = HvAUX(hv); /* may have been reallocated */
	iter->xhv_riter = -1; 	/* HvRITER(hv) = -1 */
	iter->xhv_eiter = NULL; /* HvEITER(hv) = NULL */
#ifdef PERL_HASH_RANDOMIZE_KEYS
        iter->xhv_last_rand = iter->xhv_rand;
#endif
    } else {
	hv_auxinit(hv);
    }

    /* used to be xhv->xhv_fill before 5.004_65 */
    return HvTOTALKEYS(hv);
}

I32 *
Perl_hv_riter_p(pTHX_ HV *hv) {
    struct xpvhv_aux *iter;

    PERL_ARGS_ASSERT_HV_RITER_P;

    iter = SvOOK(hv) ? HvAUX(hv) : hv_auxinit(hv);
    return &(iter->xhv_riter);
}

HE **
Perl_hv_eiter_p(pTHX_ HV *hv) {
    struct xpvhv_aux *iter;

    PERL_ARGS_ASSERT_HV_EITER_P;

    iter = SvOOK(hv) ? HvAUX(hv) : hv_auxinit(hv);
    return &(iter->xhv_eiter);
}

void
Perl_hv_riter_set(pTHX_ HV *hv, I32 riter) {
    struct xpvhv_aux *iter;

    PERL_ARGS_ASSERT_HV_RITER_SET;

    if (SvOOK(hv)) {
	iter = HvAUX(hv);
    } else {
	if (riter == -1)
	    return;

	iter = hv_auxinit(hv);
    }
    iter->xhv_riter = riter;
}

void
Perl_hv_rand_set(pTHX_ HV *hv, U32 new_xhv_rand) {
    struct xpvhv_aux *iter;

    PERL_ARGS_ASSERT_HV_RAND_SET;

#ifdef PERL_HASH_RANDOMIZE_KEYS
    if (SvOOK(hv)) {
        iter = HvAUX(hv);
    } else {
        iter = hv_auxinit(hv);
    }
    iter->xhv_rand = new_xhv_rand;
#else
    Perl_croak(aTHX_ "This Perl has not been built with support for randomized hash key traversal but something called Perl_hv_rand_set().");
#endif
}

void
Perl_hv_eiter_set(pTHX_ HV *hv, HE *eiter) {
    struct xpvhv_aux *iter;

    PERL_ARGS_ASSERT_HV_EITER_SET;

    if (SvOOK(hv)) {
	iter = HvAUX(hv);
    } else {
	/* 0 is the default so don't go malloc()ing a new structure just to
	   hold 0.  */
	if (!eiter)
	    return;

	iter = hv_auxinit(hv);
    }
    iter->xhv_eiter = eiter;
}

void
Perl_hv_name_set(pTHX_ HV *hv, const char *name, U32 len, U32 flags)
{
    dVAR;
    struct xpvhv_aux *iter;
    U32 hash;
    HEK **spot;

    PERL_ARGS_ASSERT_HV_NAME_SET;

    if (len > I32_MAX)
	Perl_croak(aTHX_ "panic: hv name too long (%"UVuf")", (UV) len);

    if (SvOOK(hv)) {
	iter = HvAUX(hv);
	if (iter->xhv_name_u.xhvnameu_name) {
	    if(iter->xhv_name_count) {
	      if(flags & HV_NAME_SETALL) {
		HEK ** const name = HvAUX(hv)->xhv_name_u.xhvnameu_names;
		HEK **hekp = name + (
		    iter->xhv_name_count < 0
		     ? -iter->xhv_name_count
		     :  iter->xhv_name_count
		   );
		while(hekp-- > name+1) 
		    unshare_hek_or_pvn(*hekp, 0, 0, 0);
		/* The first elem may be null. */
		if(*name) unshare_hek_or_pvn(*name, 0, 0, 0);
		Safefree(name);
                iter = HvAUX(hv); /* may been realloced */
		spot = &iter->xhv_name_u.xhvnameu_name;
		iter->xhv_name_count = 0;
	      }
	      else {
		if(iter->xhv_name_count > 0) {
		    /* shift some things over */
		    Renew(
		     iter->xhv_name_u.xhvnameu_names, iter->xhv_name_count + 1, HEK *
		    );
		    spot = iter->xhv_name_u.xhvnameu_names;
		    spot[iter->xhv_name_count] = spot[1];
		    spot[1] = spot[0];
		    iter->xhv_name_count = -(iter->xhv_name_count + 1);
		}
		else if(*(spot = iter->xhv_name_u.xhvnameu_names)) {
		    unshare_hek_or_pvn(*spot, 0, 0, 0);
		}
	      }
	    }
	    else if (flags & HV_NAME_SETALL) {
		unshare_hek_or_pvn(iter->xhv_name_u.xhvnameu_name, 0, 0, 0);
                iter = HvAUX(hv); /* may been realloced */
		spot = &iter->xhv_name_u.xhvnameu_name;
	    }
	    else {
		HEK * const existing_name = iter->xhv_name_u.xhvnameu_name;
		Newx(iter->xhv_name_u.xhvnameu_names, 2, HEK *);
		iter->xhv_name_count = -2;
		spot = iter->xhv_name_u.xhvnameu_names;
		spot[1] = existing_name;
	    }
	}
	else { spot = &iter->xhv_name_u.xhvnameu_name; iter->xhv_name_count = 0; }
    } else {
	if (name == 0)
	    return;

	iter = hv_auxinit(hv);
	spot = &iter->xhv_name_u.xhvnameu_name;
    }
    PERL_HASH(hash, name, len);
    *spot = name ? share_hek(name, flags & SVf_UTF8 ? -(I32)len : (I32)len, hash) : NULL;
}

/*
This is basically sv_eq_flags() in sv.c, but we avoid the magic
and bytes checking.
*/

STATIC I32
hek_eq_pvn_flags(pTHX_ const HEK *hek, const char* pv, const I32 pvlen, const U32 flags) {
    if ( (HEK_UTF8(hek) ? 1 : 0) != (flags & SVf_UTF8 ? 1 : 0) ) {
        if (flags & SVf_UTF8)
            return (bytes_cmp_utf8(
                        (const U8*)HEK_KEY(hek), HEK_LEN(hek),
		        (const U8*)pv, pvlen) == 0);
        else
            return (bytes_cmp_utf8(
                        (const U8*)pv, pvlen,
		        (const U8*)HEK_KEY(hek), HEK_LEN(hek)) == 0);
    }
    else
        return HEK_LEN(hek) == pvlen && ((HEK_KEY(hek) == pv)
                    || memEQ(HEK_KEY(hek), pv, pvlen));
}

/*
=for apidoc hv_ename_add

Adds a name to a stash's internal list of effective names.  See
C<L</hv_ename_delete>>.

This is called when a stash is assigned to a new location in the symbol
table.

=cut
*/

void
Perl_hv_ename_add(pTHX_ HV *hv, const char *name, U32 len, U32 flags)
{
    dVAR;
    struct xpvhv_aux *aux = SvOOK(hv) ? HvAUX(hv) : hv_auxinit(hv);
    U32 hash;

    PERL_ARGS_ASSERT_HV_ENAME_ADD;

    if (len > I32_MAX)
	Perl_croak(aTHX_ "panic: hv name too long (%"UVuf")", (UV) len);

    PERL_HASH(hash, name, len);

    if (aux->xhv_name_count) {
	I32 count = aux->xhv_name_count;
	HEK ** const xhv_name = aux->xhv_name_u.xhvnameu_names + (count<0);
	HEK **hekp = xhv_name + (count < 0 ? -count - 1 : count);
	while (hekp-- > xhv_name)
	{
	    assert(*hekp);
	    if (
                 (HEK_UTF8(*hekp) || (flags & SVf_UTF8)) 
                    ? hek_eq_pvn_flags(aTHX_ *hekp, name, (I32)len, flags)
	            : (HEK_LEN(*hekp) == (I32)len && memEQ(HEK_KEY(*hekp), name, len))
               ) {
		if (hekp == xhv_name && count < 0)
		    aux->xhv_name_count = -count;
		return;
	    }
	}
	if (count < 0) aux->xhv_name_count--, count = -count;
	else aux->xhv_name_count++;
	Renew(aux->xhv_name_u.xhvnameu_names, count + 1, HEK *);
	(aux->xhv_name_u.xhvnameu_names)[count] = share_hek(name, (flags & SVf_UTF8 ? -(I32)len : (I32)len), hash);
    }
    else {
	HEK *existing_name = aux->xhv_name_u.xhvnameu_name;
	if (
	    existing_name && (
             (HEK_UTF8(existing_name) || (flags & SVf_UTF8))
                ? hek_eq_pvn_flags(aTHX_ existing_name, name, (I32)len, flags)
	        : (HEK_LEN(existing_name) == (I32)len && memEQ(HEK_KEY(existing_name), name, len))
	    )
	) return;
	Newx(aux->xhv_name_u.xhvnameu_names, 2, HEK *);
	aux->xhv_name_count = existing_name ? 2 : -2;
	*aux->xhv_name_u.xhvnameu_names = existing_name;
	(aux->xhv_name_u.xhvnameu_names)[1] = share_hek(name, (flags & SVf_UTF8 ? -(I32)len : (I32)len), hash);
    }
}

/*
=for apidoc hv_ename_delete

Removes a name from a stash's internal list of effective names.  If this is
the name returned by C<HvENAME>, then another name in the list will take
its place (C<HvENAME> will use it).

This is called when a stash is deleted from the symbol table.

=cut
*/

void
Perl_hv_ename_delete(pTHX_ HV *hv, const char *name, U32 len, U32 flags)
{
    struct xpvhv_aux *aux;

    PERL_ARGS_ASSERT_HV_ENAME_DELETE;

    if (len > I32_MAX)
	Perl_croak(aTHX_ "panic: hv name too long (%"UVuf")", (UV) len);

    if (!SvOOK(hv)) return;

    aux = HvAUX(hv);
    if (!aux->xhv_name_u.xhvnameu_name) return;

    if (aux->xhv_name_count) {
	HEK ** const namep = aux->xhv_name_u.xhvnameu_names;
	I32 const count = aux->xhv_name_count;
	HEK **victim = namep + (count < 0 ? -count : count);
	while (victim-- > namep + 1)
	    if (
             (HEK_UTF8(*victim) || (flags & SVf_UTF8)) 
                ? hek_eq_pvn_flags(aTHX_ *victim, name, (I32)len, flags)
	        : (HEK_LEN(*victim) == (I32)len && memEQ(HEK_KEY(*victim), name, len))
	    ) {
		unshare_hek_or_pvn(*victim, 0, 0, 0);
                aux = HvAUX(hv); /* may been realloced */
		if (count < 0) ++aux->xhv_name_count;
		else --aux->xhv_name_count;
		if (
		    (aux->xhv_name_count == 1 || aux->xhv_name_count == -1)
		 && !*namep
		) {  /* if there are none left */
		    Safefree(namep);
		    aux->xhv_name_u.xhvnameu_names = NULL;
		    aux->xhv_name_count = 0;
		}
		else {
		    /* Move the last one back to fill the empty slot. It
		       does not matter what order they are in. */
		    *victim = *(namep + (count < 0 ? -count : count) - 1);
		}
		return;
	    }
	if (
	    count > 0 && (HEK_UTF8(*namep) || (flags & SVf_UTF8)) 
                ? hek_eq_pvn_flags(aTHX_ *namep, name, (I32)len, flags)
	        : (HEK_LEN(*namep) == (I32)len && memEQ(HEK_KEY(*namep), name, len))
	) {
	    aux->xhv_name_count = -count;
	}
    }
    else if(
        (HEK_UTF8(aux->xhv_name_u.xhvnameu_name) || (flags & SVf_UTF8)) 
                ? hek_eq_pvn_flags(aTHX_ aux->xhv_name_u.xhvnameu_name, name, (I32)len, flags)
	        : (HEK_LEN(aux->xhv_name_u.xhvnameu_name) == (I32)len &&
                            memEQ(HEK_KEY(aux->xhv_name_u.xhvnameu_name), name, len))
    ) {
	HEK * const namehek = aux->xhv_name_u.xhvnameu_name;
	Newx(aux->xhv_name_u.xhvnameu_names, 1, HEK *);
	*aux->xhv_name_u.xhvnameu_names = namehek;
	aux->xhv_name_count = -1;
    }
}

AV **
Perl_hv_backreferences_p(pTHX_ HV *hv) {
    PERL_ARGS_ASSERT_HV_BACKREFERENCES_P;
    /* See also Perl_sv_get_backrefs in sv.c where this logic is unrolled */
    {
        struct xpvhv_aux * const iter = SvOOK(hv) ? HvAUX(hv) : hv_auxinit(hv);
        return &(iter->xhv_backreferences);
    }
}

void
Perl_hv_kill_backrefs(pTHX_ HV *hv) {
    AV *av;

    PERL_ARGS_ASSERT_HV_KILL_BACKREFS;

    if (!SvOOK(hv))
	return;

    av = HvAUX(hv)->xhv_backreferences;

    if (av) {
	HvAUX(hv)->xhv_backreferences = 0;
	Perl_sv_kill_backrefs(aTHX_ MUTABLE_SV(hv), av);
	if (SvTYPE(av) == SVt_PVAV)
	    SvREFCNT_dec_NN(av);
    }
}

/*
hv_iternext is implemented as a macro in hv.h

=for apidoc hv_iternext

Returns entries from a hash iterator.  See C<L</hv_iterinit>>.

You may call C<hv_delete> or C<hv_delete_ent> on the hash entry that the
iterator currently points to, without losing your place or invalidating your
iterator.  Note that in this case the current entry is deleted from the hash
with your iterator holding the last reference to it.  Your iterator is flagged
to free the entry on the next call to C<hv_iternext>, so you must not discard
your iterator immediately else the entry will leak - call C<hv_iternext> to
trigger the resource deallocation.

=for apidoc hv_iternext_flags

Returns entries from a hash iterator.  See C<L</hv_iterinit>> and
C<L</hv_iternext>>.
The C<flags> value will normally be zero; if C<HV_ITERNEXT_WANTPLACEHOLDERS> is
set the placeholders keys (for restricted hashes) will be returned in addition
to normal keys.  By default placeholders are automatically skipped over.
Currently a placeholder is implemented with a value that is
C<&PL_sv_placeholder>.  Note that the implementation of placeholders and
restricted hashes may change, and the implementation currently is
insufficiently abstracted for any change to be tidy.

=cut
*/

HE *
Perl_hv_iternext_flags(pTHX_ HV *hv, I32 flags)
{
    dVAR;
    XPVHV* xhv;
    HE *entry;
    HE *oldentry;
    MAGIC* mg;
    struct xpvhv_aux *iter;

    PERL_ARGS_ASSERT_HV_ITERNEXT_FLAGS;

    xhv = (XPVHV*)SvANY(hv);

    if (!SvOOK(hv)) {
	/* Too many things (well, pp_each at least) merrily assume that you can
	   call hv_iternext without calling hv_iterinit, so we'll have to deal
	   with it.  */
	hv_iterinit(hv);
    }
    iter = HvAUX(hv);

    oldentry = entry = iter->xhv_eiter; /* HvEITER(hv) */
    if (SvMAGICAL(hv) && SvRMAGICAL(hv)) {
	if ( ( mg = mg_find((const SV *)hv, PERL_MAGIC_tied) ) ) {
            SV * const key = sv_newmortal();
            if (entry) {
                sv_setsv(key, HeSVKEY_force(entry));
                SvREFCNT_dec(HeSVKEY(entry));       /* get rid of previous key */
		HeSVKEY_set(entry, NULL);
            }
            else {
                char *k;
                HEK *hek;

                /* one HE per MAGICAL hash */
                iter->xhv_eiter = entry = new_HE(); /* HvEITER(hv) = new_HE() */
		HvLAZYDEL_on(hv); /* make sure entry gets freed */
                Zero(entry, 1, HE);
                Newxz(k, HEK_BASESIZE + sizeof(const SV *), char);
                hek = (HEK*)k;
                HeKEY_hek(entry) = hek;
                HeKLEN(entry) = HEf_SVKEY;
            }
            magic_nextpack(MUTABLE_SV(hv),mg,key);
            if (SvOK(key)) {
                /* force key to stay around until next time */
                HeSVKEY_set(entry, SvREFCNT_inc_simple_NN(key));
                return entry;               /* beware, hent_val is not set */
            }
            SvREFCNT_dec(HeVAL(entry));
            Safefree(HeKEY_hek(entry));
            del_HE(entry);
            iter = HvAUX(hv); /* may been realloced */
            iter->xhv_eiter = NULL; /* HvEITER(hv) = NULL */
	    HvLAZYDEL_off(hv);
            return NULL;
        }
    }
#if defined(DYNAMIC_ENV_FETCH) && !defined(__riscos__)  /* set up %ENV for iteration */
    if (!entry && SvRMAGICAL((const SV *)hv)
	&& mg_find((const SV *)hv, PERL_MAGIC_env)) {
	prime_env_iter();
#ifdef VMS
	/* The prime_env_iter() on VMS just loaded up new hash values
	 * so the iteration count needs to be reset back to the beginning
	 */
	hv_iterinit(hv);
	iter = HvAUX(hv);
	oldentry = entry = iter->xhv_eiter; /* HvEITER(hv) */
#endif
    }
#endif

    /* hv_iterinit now ensures this.  */
    assert (HvARRAY(hv));

    /* At start of hash, entry is NULL.  */
    if (entry)
    {
	entry = HeNEXT(entry);
        if (!(flags & HV_ITERNEXT_WANTPLACEHOLDERS)) {
            /*
             * Skip past any placeholders -- don't want to include them in
             * any iteration.
             */
            while (entry && HeVAL(entry) == &PL_sv_placeholder) {
                entry = HeNEXT(entry);
            }
	}
    }

#ifdef PERL_HASH_RANDOMIZE_KEYS
    if (iter->xhv_last_rand != iter->xhv_rand) {
        if (iter->xhv_riter != -1) {
            Perl_ck_warner_d(aTHX_ packWARN(WARN_INTERNAL),
                             "Use of each() on hash after insertion without resetting hash iterator results in undefined behavior"
                             pTHX__FORMAT
                             pTHX__VALUE);
        }
        iter = HvAUX(hv); /* may been realloced */
        iter->xhv_last_rand = iter->xhv_rand;
    }
#endif

    /* Skip the entire loop if the hash is empty.   */
    if ((flags & HV_ITERNEXT_WANTPLACEHOLDERS)
	? HvTOTALKEYS(hv) : HvUSEDKEYS(hv)) {
	while (!entry) {
	    /* OK. Come to the end of the current list.  Grab the next one.  */

	    iter->xhv_riter++; /* HvRITER(hv)++ */
	    if (iter->xhv_riter > (I32)xhv->xhv_max /* HvRITER(hv) > HvMAX(hv) */) {
		/* There is no next one.  End of the hash.  */
		iter->xhv_riter = -1; /* HvRITER(hv) = -1 */
#ifdef PERL_HASH_RANDOMIZE_KEYS
                iter->xhv_last_rand = iter->xhv_rand; /* reset xhv_last_rand so we can detect inserts during traversal */
#endif
		break;
	    }
            entry = (HvARRAY(hv))[ PERL_HASH_ITER_BUCKET(iter) & xhv->xhv_max ];

	    if (!(flags & HV_ITERNEXT_WANTPLACEHOLDERS)) {
		/* If we have an entry, but it's a placeholder, don't count it.
		   Try the next.  */
		while (entry && HeVAL(entry) == &PL_sv_placeholder)
		    entry = HeNEXT(entry);
	    }
	    /* Will loop again if this linked list starts NULL
	       (for HV_ITERNEXT_WANTPLACEHOLDERS)
	       or if we run through it and find only placeholders.  */
	}
    }
    else {
        iter->xhv_riter = -1;
#ifdef PERL_HASH_RANDOMIZE_KEYS
        iter->xhv_last_rand = iter->xhv_rand;
#endif
    }

    if (oldentry && HvLAZYDEL(hv)) {		/* was deleted earlier? */
	HvLAZYDEL_off(hv);
	hv_free_ent(hv, oldentry);
    }

    iter = HvAUX(hv); /* may been realloced */
    iter->xhv_eiter = entry; /* HvEITER(hv) = entry */
    return entry;
}

/*
=for apidoc hv_iterkey

Returns the key from the current position of the hash iterator.  See
C<L</hv_iterinit>>.

=cut
*/

char *
Perl_hv_iterkey(pTHX_ HE *entry, I32 *retlen)
{
    PERL_ARGS_ASSERT_HV_ITERKEY;

    if (HeKLEN(entry) == HEf_SVKEY) {
	STRLEN len;
	char * const p = SvPV(HeKEY_sv(entry), len);
	*retlen = len;
	return p;
    }
    else {
	*retlen = HeKLEN(entry);
	return HeKEY(entry);
    }
}

/* unlike hv_iterval(), this always returns a mortal copy of the key */
/*
=for apidoc hv_iterkeysv

Returns the key as an C<SV*> from the current position of the hash
iterator.  The return value will always be a mortal copy of the key.  Also
see C<L</hv_iterinit>>.

=cut
*/

SV *
Perl_hv_iterkeysv(pTHX_ HE *entry)
{
    PERL_ARGS_ASSERT_HV_ITERKEYSV;

    return sv_2mortal(newSVhek(HeKEY_hek(entry)));
}

/*
=for apidoc hv_iterval

Returns the value from the current position of the hash iterator.  See
C<L</hv_iterkey>>.

=cut
*/

SV *
Perl_hv_iterval(pTHX_ HV *hv, HE *entry)
{
    PERL_ARGS_ASSERT_HV_ITERVAL;

    if (SvRMAGICAL(hv)) {
	if (mg_find((const SV *)hv, PERL_MAGIC_tied)) {
	    SV* const sv = sv_newmortal();
	    if (HeKLEN(entry) == HEf_SVKEY)
		mg_copy(MUTABLE_SV(hv), sv, (char*)HeKEY_sv(entry), HEf_SVKEY);
	    else
		mg_copy(MUTABLE_SV(hv), sv, HeKEY(entry), HeKLEN(entry));
	    return sv;
	}
    }
    return HeVAL(entry);
}

/*
=for apidoc hv_iternextsv

Performs an C<hv_iternext>, C<hv_iterkey>, and C<hv_iterval> in one
operation.

=cut
*/

SV *
Perl_hv_iternextsv(pTHX_ HV *hv, char **key, I32 *retlen)
{
    HE * const he = hv_iternext_flags(hv, 0);

    PERL_ARGS_ASSERT_HV_ITERNEXTSV;

    if (!he)
	return NULL;
    *key = hv_iterkey(he, retlen);
    return hv_iterval(hv, he);
}

/*

Now a macro in hv.h

=for apidoc hv_magic

Adds magic to a hash.  See C<L</sv_magic>>.

=cut
*/

/* possibly free a shared string if no one has access to it
 * len and hash must both be valid for str.
 */
void
Perl_unsharepvn(pTHX_ const char *str, I32 len, U32 hash)
{
    unshare_hek_or_pvn (NULL, str, len, hash);
}


void
Perl_unshare_hek(pTHX_ HEK *hek)
{
    assert(hek);
    unshare_hek_or_pvn(hek, NULL, 0, 0);
}

/* possibly free a shared string if no one has access to it
   hek if non-NULL takes priority over the other 3, else str, len and hash
   are used.  If so, len and hash must both be valid for str.
 */
STATIC void
S_unshare_hek_or_pvn(pTHX_ const HEK *hek, const char *str, I32 len, U32 hash)
{
    XPVHV* xhv;
    HE *entry;
    HE **oentry;
    bool is_utf8 = FALSE;
    int k_flags = 0;
    const char * const save = str;
    struct shared_he *he = NULL;

    if (hek) {
	/* Find the shared he which is just before us in memory.  */
	he = (struct shared_he *)(((char *)hek)
				  - STRUCT_OFFSET(struct shared_he,
						  shared_he_hek));

	/* Assert that the caller passed us a genuine (or at least consistent)
	   shared hek  */
	assert (he->shared_he_he.hent_hek == hek);

	if (he->shared_he_he.he_valu.hent_refcount - 1) {
	    --he->shared_he_he.he_valu.hent_refcount;
	    return;
	}

        hash = HEK_HASH(hek);
    } else if (len < 0) {
        STRLEN tmplen = -len;
        is_utf8 = TRUE;
        /* See the note in hv_fetch(). --jhi */
        str = (char*)bytes_from_utf8((U8*)str, &tmplen, &is_utf8);
        len = tmplen;
        if (is_utf8)
            k_flags = HVhek_UTF8;
        if (str != save)
            k_flags |= HVhek_WASUTF8 | HVhek_FREEKEY;
    }

    /* what follows was the moral equivalent of:
    if ((Svp = hv_fetch(PL_strtab, tmpsv, FALSE, hash))) {
	if (--*Svp == NULL)
	    hv_delete(PL_strtab, str, len, G_DISCARD, hash);
    } */
    xhv = (XPVHV*)SvANY(PL_strtab);
    /* assert(xhv_array != 0) */
    oentry = &(HvARRAY(PL_strtab))[hash & (I32) HvMAX(PL_strtab)];
    if (he) {
	const HE *const he_he = &(he->shared_he_he);
        for (entry = *oentry; entry; oentry = &HeNEXT(entry), entry = *oentry) {
            if (entry == he_he)
                break;
        }
    } else {
        const int flags_masked = k_flags & HVhek_MASK;
        for (entry = *oentry; entry; oentry = &HeNEXT(entry), entry = *oentry) {
            if (HeHASH(entry) != hash)		/* strings can't be equal */
                continue;
            if (HeKLEN(entry) != len)
                continue;
            if (HeKEY(entry) != str && memNE(HeKEY(entry),str,len))	/* is this it? */
                continue;
            if (HeKFLAGS(entry) != flags_masked)
                continue;
            break;
        }
    }

    if (entry) {
        if (--entry->he_valu.hent_refcount == 0) {
            *oentry = HeNEXT(entry);
            Safefree(entry);
            xhv->xhv_keys--; /* HvTOTALKEYS(hv)-- */
        }
    }

    if (!entry)
	Perl_ck_warner_d(aTHX_ packWARN(WARN_INTERNAL),
			 "Attempt to free nonexistent shared string '%s'%s"
			 pTHX__FORMAT,
			 hek ? HEK_KEY(hek) : str,
			 ((k_flags & HVhek_UTF8) ? " (utf8)" : "") pTHX__VALUE);
    if (k_flags & HVhek_FREEKEY)
	Safefree(str);
}

/* get a (constant) string ptr from the global string table
 * string will get added if it is not already there.
 * len and hash must both be valid for str.
 */
HEK *
Perl_share_hek(pTHX_ const char *str, I32 len, U32 hash)
{
    bool is_utf8 = FALSE;
    int flags = 0;
    const char * const save = str;

    PERL_ARGS_ASSERT_SHARE_HEK;

    if (len < 0) {
      STRLEN tmplen = -len;
      is_utf8 = TRUE;
      /* See the note in hv_fetch(). --jhi */
      str = (char*)bytes_from_utf8((U8*)str, &tmplen, &is_utf8);
      len = tmplen;
      /* If we were able to downgrade here, then than means that we were passed
         in a key which only had chars 0-255, but was utf8 encoded.  */
      if (is_utf8)
          flags = HVhek_UTF8;
      /* If we found we were able to downgrade the string to bytes, then
         we should flag that it needs upgrading on keys or each.  Also flag
         that we need share_hek_flags to free the string.  */
      if (str != save) {
          dVAR;
          PERL_HASH(hash, str, len);
          flags |= HVhek_WASUTF8 | HVhek_FREEKEY;
      }
    }

    return share_hek_flags (str, len, hash, flags);
}

STATIC HEK *
S_share_hek_flags(pTHX_ const char *str, I32 len, U32 hash, int flags)
{
    HE *entry;
    const int flags_masked = flags & HVhek_MASK;
    const U32 hindex = hash & (I32) HvMAX(PL_strtab);
    XPVHV * const xhv = (XPVHV*)SvANY(PL_strtab);

    PERL_ARGS_ASSERT_SHARE_HEK_FLAGS;

    /* what follows is the moral equivalent of:

    if (!(Svp = hv_fetch(PL_strtab, str, len, FALSE)))
	hv_store(PL_strtab, str, len, NULL, hash);

	Can't rehash the shared string table, so not sure if it's worth
	counting the number of entries in the linked list
    */

    /* assert(xhv_array != 0) */
    entry = (HvARRAY(PL_strtab))[hindex];
    for (;entry; entry = HeNEXT(entry)) {
	if (HeHASH(entry) != hash)		/* strings can't be equal */
	    continue;
	if (HeKLEN(entry) != len)
	    continue;
	if (HeKEY(entry) != str && memNE(HeKEY(entry),str,len))	/* is this it? */
	    continue;
	if (HeKFLAGS(entry) != flags_masked)
	    continue;
	break;
    }

    if (!entry) {
	/* What used to be head of the list.
	   If this is NULL, then we're the first entry for this slot, which
	   means we need to increate fill.  */
	struct shared_he *new_entry;
	HEK *hek;
	char *k;
	HE **const head = &HvARRAY(PL_strtab)[hindex];
	HE *const next = *head;

	/* We don't actually store a HE from the arena and a regular HEK.
	   Instead we allocate one chunk of memory big enough for both,
	   and put the HEK straight after the HE. This way we can find the
	   HE directly from the HEK.
	*/

	Newx(k, STRUCT_OFFSET(struct shared_he,
				shared_he_hek.hek_key[0]) + len + 2, char);
	new_entry = (struct shared_he *)k;
	entry = &(new_entry->shared_he_he);
	hek = &(new_entry->shared_he_hek);

	Copy(str, HEK_KEY(hek), len, char);
	HEK_KEY(hek)[len] = 0;
	HEK_LEN(hek) = len;
	HEK_HASH(hek) = hash;
	HEK_FLAGS(hek) = (unsigned char)flags_masked;

	/* Still "point" to the HEK, so that other code need not know what
	   we're up to.  */
	HeKEY_hek(entry) = hek;
	entry->he_valu.hent_refcount = 0;
	HeNEXT(entry) = next;
	*head = entry;

	xhv->xhv_keys++; /* HvTOTALKEYS(hv)++ */
	if (!next) {			/* initial entry? */
	} else if ( DO_HSPLIT(xhv) ) {
            const STRLEN oldsize = xhv->xhv_max + 1;
            hsplit(PL_strtab, oldsize, oldsize * 2);
	}
    }

    ++entry->he_valu.hent_refcount;

    if (flags & HVhek_FREEKEY)
	Safefree(str);

    return HeKEY_hek(entry);
}

SSize_t *
Perl_hv_placeholders_p(pTHX_ HV *hv)
{
    MAGIC *mg = mg_find((const SV *)hv, PERL_MAGIC_rhash);

    PERL_ARGS_ASSERT_HV_PLACEHOLDERS_P;

    if (!mg) {
	mg = sv_magicext(MUTABLE_SV(hv), 0, PERL_MAGIC_rhash, 0, 0, 0);

	if (!mg) {
	    Perl_die(aTHX_ "panic: hv_placeholders_p");
	}
    }
    return &(mg->mg_len);
}


I32
Perl_hv_placeholders_get(pTHX_ const HV *hv)
{
    MAGIC * const mg = mg_find((const SV *)hv, PERL_MAGIC_rhash);

    PERL_ARGS_ASSERT_HV_PLACEHOLDERS_GET;
    PERL_UNUSED_CONTEXT;

    return mg ? mg->mg_len : 0;
}

void
Perl_hv_placeholders_set(pTHX_ HV *hv, I32 ph)
{
    MAGIC * const mg = mg_find((const SV *)hv, PERL_MAGIC_rhash);

    PERL_ARGS_ASSERT_HV_PLACEHOLDERS_SET;

    if (mg) {
	mg->mg_len = ph;
    } else if (ph) {
	if (!sv_magicext(MUTABLE_SV(hv), 0, PERL_MAGIC_rhash, 0, 0, ph))
	    Perl_die(aTHX_ "panic: hv_placeholders_set");
    }
    /* else we don't need to add magic to record 0 placeholders.  */
}

STATIC SV *
S_refcounted_he_value(pTHX_ const struct refcounted_he *he)
{
    dVAR;
    SV *value;

    PERL_ARGS_ASSERT_REFCOUNTED_HE_VALUE;

    switch(he->refcounted_he_data[0] & HVrhek_typemask) {
    case HVrhek_undef:
	value = newSV(0);
	break;
    case HVrhek_delete:
	value = &PL_sv_placeholder;
	break;
    case HVrhek_IV:
	value = newSViv(he->refcounted_he_val.refcounted_he_u_iv);
	break;
    case HVrhek_UV:
	value = newSVuv(he->refcounted_he_val.refcounted_he_u_uv);
	break;
    case HVrhek_PV:
    case HVrhek_PV_UTF8:
	/* Create a string SV that directly points to the bytes in our
	   structure.  */
	value = newSV_type(SVt_PV);
	SvPV_set(value, (char *) he->refcounted_he_data + 1);
	SvCUR_set(value, he->refcounted_he_val.refcounted_he_u_len);
	/* This stops anything trying to free it  */
	SvLEN_set(value, 0);
	SvPOK_on(value);
	SvREADONLY_on(value);
	if ((he->refcounted_he_data[0] & HVrhek_typemask) == HVrhek_PV_UTF8)
	    SvUTF8_on(value);
	break;
    default:
	Perl_croak(aTHX_ "panic: refcounted_he_value bad flags %"UVxf,
		   (UV)he->refcounted_he_data[0]);
    }
    return value;
}

/*
=for apidoc m|HV *|refcounted_he_chain_2hv|const struct refcounted_he *c|U32 flags

Generates and returns a C<HV *> representing the content of a
C<refcounted_he> chain.
C<flags> is currently unused and must be zero.

=cut
*/
HV *
Perl_refcounted_he_chain_2hv(pTHX_ const struct refcounted_he *chain, U32 flags)
{
    dVAR;
    HV *hv;
    U32 placeholders, max;

    if (flags)
	Perl_croak(aTHX_ "panic: refcounted_he_chain_2hv bad flags %"UVxf,
	    (UV)flags);

    /* We could chase the chain once to get an idea of the number of keys,
       and call ksplit.  But for now we'll make a potentially inefficient
       hash with only 8 entries in its array.  */
    hv = newHV();
    max = HvMAX(hv);
    if (!HvARRAY(hv)) {
	char *array;
	Newxz(array, PERL_HV_ARRAY_ALLOC_BYTES(max + 1), char);
	HvARRAY(hv) = (HE**)array;
    }

    placeholders = 0;
    while (chain) {
#ifdef USE_ITHREADS
	U32 hash = chain->refcounted_he_hash;
#else
	U32 hash = HEK_HASH(chain->refcounted_he_hek);
#endif
	HE **oentry = &((HvARRAY(hv))[hash & max]);
	HE *entry = *oentry;
	SV *value;

	for (; entry; entry = HeNEXT(entry)) {
	    if (HeHASH(entry) == hash) {
		/* We might have a duplicate key here.  If so, entry is older
		   than the key we've already put in the hash, so if they are
		   the same, skip adding entry.  */
#ifdef USE_ITHREADS
		const STRLEN klen = HeKLEN(entry);
		const char *const key = HeKEY(entry);
		if (klen == chain->refcounted_he_keylen
		    && (!!HeKUTF8(entry)
			== !!(chain->refcounted_he_data[0] & HVhek_UTF8))
		    && memEQ(key, REF_HE_KEY(chain), klen))
		    goto next_please;
#else
		if (HeKEY_hek(entry) == chain->refcounted_he_hek)
		    goto next_please;
		if (HeKLEN(entry) == HEK_LEN(chain->refcounted_he_hek)
		    && HeKUTF8(entry) == HEK_UTF8(chain->refcounted_he_hek)
		    && memEQ(HeKEY(entry), HEK_KEY(chain->refcounted_he_hek),
			     HeKLEN(entry)))
		    goto next_please;
#endif
	    }
	}
	assert (!entry);
	entry = new_HE();

#ifdef USE_ITHREADS
	HeKEY_hek(entry)
	    = share_hek_flags(REF_HE_KEY(chain),
			      chain->refcounted_he_keylen,
			      chain->refcounted_he_hash,
			      (chain->refcounted_he_data[0]
			       & (HVhek_UTF8|HVhek_WASUTF8)));
#else
	HeKEY_hek(entry) = share_hek_hek(chain->refcounted_he_hek);
#endif
	value = refcounted_he_value(chain);
	if (value == &PL_sv_placeholder)
	    placeholders++;
	HeVAL(entry) = value;

	/* Link it into the chain.  */
	HeNEXT(entry) = *oentry;
	*oentry = entry;

	HvTOTALKEYS(hv)++;

    next_please:
	chain = chain->refcounted_he_next;
    }

    if (placeholders) {
	clear_placeholders(hv, placeholders);
	HvTOTALKEYS(hv) -= placeholders;
    }

    /* We could check in the loop to see if we encounter any keys with key
       flags, but it's probably not worth it, as this per-hash flag is only
       really meant as an optimisation for things like Storable.  */
    HvHASKFLAGS_on(hv);
    DEBUG_A(Perl_hv_assert(aTHX_ hv));

    return hv;
}

/*
=for apidoc m|SV *|refcounted_he_fetch_pvn|const struct refcounted_he *chain|const char *keypv|STRLEN keylen|U32 hash|U32 flags

Search along a C<refcounted_he> chain for an entry with the key specified
by C<keypv> and C<keylen>.  If C<flags> has the C<REFCOUNTED_HE_KEY_UTF8>
bit set, the key octets are interpreted as UTF-8, otherwise they
are interpreted as Latin-1.  C<hash> is a precomputed hash of the key
string, or zero if it has not been precomputed.  Returns a mortal scalar
representing the value associated with the key, or C<&PL_sv_placeholder>
if there is no value associated with the key.

=cut
*/

SV *
Perl_refcounted_he_fetch_pvn(pTHX_ const struct refcounted_he *chain,
			 const char *keypv, STRLEN keylen, U32 hash, U32 flags)
{
    dVAR;
    U8 utf8_flag;
    PERL_ARGS_ASSERT_REFCOUNTED_HE_FETCH_PVN;

    if (flags & ~(REFCOUNTED_HE_KEY_UTF8|REFCOUNTED_HE_EXISTS))
	Perl_croak(aTHX_ "panic: refcounted_he_fetch_pvn bad flags %"UVxf,
	    (UV)flags);
    if (!chain)
	goto ret;
    if (flags & REFCOUNTED_HE_KEY_UTF8) {
	/* For searching purposes, canonicalise to Latin-1 where possible. */
	const char *keyend = keypv + keylen, *p;
	STRLEN nonascii_count = 0;
	for (p = keypv; p != keyend; p++) {
	    if (! UTF8_IS_INVARIANT(*p)) {
		if (! UTF8_IS_NEXT_CHAR_DOWNGRADEABLE(p, keyend)) {
		    goto canonicalised_key;
                }
		nonascii_count++;
                p++;
	    }
	}
	if (nonascii_count) {
	    char *q;
	    const char *p = keypv, *keyend = keypv + keylen;
	    keylen -= nonascii_count;
	    Newx(q, keylen, char);
	    SAVEFREEPV(q);
	    keypv = q;
	    for (; p != keyend; p++, q++) {
		U8 c = (U8)*p;
                if (UTF8_IS_INVARIANT(c)) {
                    *q = (char) c;
                }
                else {
                    p++;
                    *q = (char) EIGHT_BIT_UTF8_TO_NATIVE(c, *p);
                }
	    }
	}
	flags &= ~REFCOUNTED_HE_KEY_UTF8;
	canonicalised_key: ;
    }
    utf8_flag = (flags & REFCOUNTED_HE_KEY_UTF8) ? HVhek_UTF8 : 0;
    if (!hash)
	PERL_HASH(hash, keypv, keylen);

    for (; chain; chain = chain->refcounted_he_next) {
	if (
#ifdef USE_ITHREADS
	    hash == chain->refcounted_he_hash &&
	    keylen == chain->refcounted_he_keylen &&
	    memEQ(REF_HE_KEY(chain), keypv, keylen) &&
	    utf8_flag == (chain->refcounted_he_data[0] & HVhek_UTF8)
#else
	    hash == HEK_HASH(chain->refcounted_he_hek) &&
	    keylen == (STRLEN)HEK_LEN(chain->refcounted_he_hek) &&
	    memEQ(HEK_KEY(chain->refcounted_he_hek), keypv, keylen) &&
	    utf8_flag == (HEK_FLAGS(chain->refcounted_he_hek) & HVhek_UTF8)
#endif
	) {
	    if (flags & REFCOUNTED_HE_EXISTS)
		return (chain->refcounted_he_data[0] & HVrhek_typemask)
		    == HVrhek_delete
		    ? NULL : &PL_sv_yes;
	    return sv_2mortal(refcounted_he_value(chain));
	}
    }
  ret:
    return flags & REFCOUNTED_HE_EXISTS ? NULL : &PL_sv_placeholder;
}

/*
=for apidoc m|SV *|refcounted_he_fetch_pv|const struct refcounted_he *chain|const char *key|U32 hash|U32 flags

Like L</refcounted_he_fetch_pvn>, but takes a nul-terminated string
instead of a string/length pair.

=cut
*/

SV *
Perl_refcounted_he_fetch_pv(pTHX_ const struct refcounted_he *chain,
			 const char *key, U32 hash, U32 flags)
{
    PERL_ARGS_ASSERT_REFCOUNTED_HE_FETCH_PV;
    return refcounted_he_fetch_pvn(chain, key, strlen(key), hash, flags);
}

/*
=for apidoc m|SV *|refcounted_he_fetch_sv|const struct refcounted_he *chain|SV *key|U32 hash|U32 flags

Like L</refcounted_he_fetch_pvn>, but takes a Perl scalar instead of a
string/length pair.

=cut
*/

SV *
Perl_refcounted_he_fetch_sv(pTHX_ const struct refcounted_he *chain,
			 SV *key, U32 hash, U32 flags)
{
    const char *keypv;
    STRLEN keylen;
    PERL_ARGS_ASSERT_REFCOUNTED_HE_FETCH_SV;
    if (flags & REFCOUNTED_HE_KEY_UTF8)
	Perl_croak(aTHX_ "panic: refcounted_he_fetch_sv bad flags %"UVxf,
	    (UV)flags);
    keypv = SvPV_const(key, keylen);
    if (SvUTF8(key))
	flags |= REFCOUNTED_HE_KEY_UTF8;
    if (!hash && SvIsCOW_shared_hash(key))
	hash = SvSHARED_HASH(key);
    return refcounted_he_fetch_pvn(chain, keypv, keylen, hash, flags);
}

/*
=for apidoc m|struct refcounted_he *|refcounted_he_new_pvn|struct refcounted_he *parent|const char *keypv|STRLEN keylen|U32 hash|SV *value|U32 flags

Creates a new C<refcounted_he>.  This consists of a single key/value
pair and a reference to an existing C<refcounted_he> chain (which may
be empty), and thus forms a longer chain.  When using the longer chain,
the new key/value pair takes precedence over any entry for the same key
further along the chain.

The new key is specified by C<keypv> and C<keylen>.  If C<flags> has
the C<REFCOUNTED_HE_KEY_UTF8> bit set, the key octets are interpreted
as UTF-8, otherwise they are interpreted as Latin-1.  C<hash> is
a precomputed hash of the key string, or zero if it has not been
precomputed.

C<value> is the scalar value to store for this key.  C<value> is copied
by this function, which thus does not take ownership of any reference
to it, and later changes to the scalar will not be reflected in the
value visible in the C<refcounted_he>.  Complex types of scalar will not
be stored with referential integrity, but will be coerced to strings.
C<value> may be either null or C<&PL_sv_placeholder> to indicate that no
value is to be associated with the key; this, as with any non-null value,
takes precedence over the existence of a value for the key further along
the chain.

C<parent> points to the rest of the C<refcounted_he> chain to be
attached to the new C<refcounted_he>.  This function takes ownership
of one reference to C<parent>, and returns one reference to the new
C<refcounted_he>.

=cut
*/

struct refcounted_he *
Perl_refcounted_he_new_pvn(pTHX_ struct refcounted_he *parent,
	const char *keypv, STRLEN keylen, U32 hash, SV *value, U32 flags)
{
    dVAR;
    STRLEN value_len = 0;
    const char *value_p = NULL;
    bool is_pv;
    char value_type;
    char hekflags;
    STRLEN key_offset = 1;
    struct refcounted_he *he;
    PERL_ARGS_ASSERT_REFCOUNTED_HE_NEW_PVN;

    if (!value || value == &PL_sv_placeholder) {
	value_type = HVrhek_delete;
    } else if (SvPOK(value)) {
	value_type = HVrhek_PV;
    } else if (SvIOK(value)) {
	value_type = SvUOK((const SV *)value) ? HVrhek_UV : HVrhek_IV;
    } else if (!SvOK(value)) {
	value_type = HVrhek_undef;
    } else {
	value_type = HVrhek_PV;
    }
    is_pv = value_type == HVrhek_PV;
    if (is_pv) {
	/* Do it this way so that the SvUTF8() test is after the SvPV, in case
	   the value is overloaded, and doesn't yet have the UTF-8flag set.  */
	value_p = SvPV_const(value, value_len);
	if (SvUTF8(value))
	    value_type = HVrhek_PV_UTF8;
	key_offset = value_len + 2;
    }
    hekflags = value_type;

    if (flags & REFCOUNTED_HE_KEY_UTF8) {
	/* Canonicalise to Latin-1 where possible. */
	const char *keyend = keypv + keylen, *p;
	STRLEN nonascii_count = 0;
	for (p = keypv; p != keyend; p++) {
	    if (! UTF8_IS_INVARIANT(*p)) {
		if (! UTF8_IS_NEXT_CHAR_DOWNGRADEABLE(p, keyend)) {
		    goto canonicalised_key;
                }
		nonascii_count++;
                p++;
	    }
	}
	if (nonascii_count) {
	    char *q;
	    const char *p = keypv, *keyend = keypv + keylen;
	    keylen -= nonascii_count;
	    Newx(q, keylen, char);
	    SAVEFREEPV(q);
	    keypv = q;
	    for (; p != keyend; p++, q++) {
		U8 c = (U8)*p;
                if (UTF8_IS_INVARIANT(c)) {
                    *q = (char) c;
                }
                else {
                    p++;
                    *q = (char) EIGHT_BIT_UTF8_TO_NATIVE(c, *p);
                }
	    }
	}
	flags &= ~REFCOUNTED_HE_KEY_UTF8;
	canonicalised_key: ;
    }
    if (flags & REFCOUNTED_HE_KEY_UTF8)
	hekflags |= HVhek_UTF8;
    if (!hash)
	PERL_HASH(hash, keypv, keylen);

#ifdef USE_ITHREADS
    he = (struct refcounted_he*)
	PerlMemShared_malloc(sizeof(struct refcounted_he) - 1
			     + keylen
			     + key_offset);
#else
    he = (struct refcounted_he*)
	PerlMemShared_malloc(sizeof(struct refcounted_he) - 1
			     + key_offset);
#endif

    he->refcounted_he_next = parent;

    if (is_pv) {
	Copy(value_p, he->refcounted_he_data + 1, value_len + 1, char);
	he->refcounted_he_val.refcounted_he_u_len = value_len;
    } else if (value_type == HVrhek_IV) {
	he->refcounted_he_val.refcounted_he_u_iv = SvIVX(value);
    } else if (value_type == HVrhek_UV) {
	he->refcounted_he_val.refcounted_he_u_uv = SvUVX(value);
    }

#ifdef USE_ITHREADS
    he->refcounted_he_hash = hash;
    he->refcounted_he_keylen = keylen;
    Copy(keypv, he->refcounted_he_data + key_offset, keylen, char);
#else
    he->refcounted_he_hek = share_hek_flags(keypv, keylen, hash, hekflags);
#endif

    he->refcounted_he_data[0] = hekflags;
    he->refcounted_he_refcnt = 1;

    return he;
}

/*
=for apidoc m|struct refcounted_he *|refcounted_he_new_pv|struct refcounted_he *parent|const char *key|U32 hash|SV *value|U32 flags

Like L</refcounted_he_new_pvn>, but takes a nul-terminated string instead
of a string/length pair.

=cut
*/

struct refcounted_he *
Perl_refcounted_he_new_pv(pTHX_ struct refcounted_he *parent,
	const char *key, U32 hash, SV *value, U32 flags)
{
    PERL_ARGS_ASSERT_REFCOUNTED_HE_NEW_PV;
    return refcounted_he_new_pvn(parent, key, strlen(key), hash, value, flags);
}

/*
=for apidoc m|struct refcounted_he *|refcounted_he_new_sv|struct refcounted_he *parent|SV *key|U32 hash|SV *value|U32 flags

Like L</refcounted_he_new_pvn>, but takes a Perl scalar instead of a
string/length pair.

=cut
*/

struct refcounted_he *
Perl_refcounted_he_new_sv(pTHX_ struct refcounted_he *parent,
	SV *key, U32 hash, SV *value, U32 flags)
{
    const char *keypv;
    STRLEN keylen;
    PERL_ARGS_ASSERT_REFCOUNTED_HE_NEW_SV;
    if (flags & REFCOUNTED_HE_KEY_UTF8)
	Perl_croak(aTHX_ "panic: refcounted_he_new_sv bad flags %"UVxf,
	    (UV)flags);
    keypv = SvPV_const(key, keylen);
    if (SvUTF8(key))
	flags |= REFCOUNTED_HE_KEY_UTF8;
    if (!hash && SvIsCOW_shared_hash(key))
	hash = SvSHARED_HASH(key);
    return refcounted_he_new_pvn(parent, keypv, keylen, hash, value, flags);
}

/*
=for apidoc m|void|refcounted_he_free|struct refcounted_he *he

Decrements the reference count of a C<refcounted_he> by one.  If the
reference count reaches zero the structure's memory is freed, which
(recursively) causes a reduction of its parent C<refcounted_he>'s
reference count.  It is safe to pass a null pointer to this function:
no action occurs in this case.

=cut
*/

void
Perl_refcounted_he_free(pTHX_ struct refcounted_he *he) {
#ifdef USE_ITHREADS
    dVAR;
#endif
    PERL_UNUSED_CONTEXT;

    while (he) {
	struct refcounted_he *copy;
	U32 new_count;

	HINTS_REFCNT_LOCK;
	new_count = --he->refcounted_he_refcnt;
	HINTS_REFCNT_UNLOCK;
	
	if (new_count) {
	    return;
	}

#ifndef USE_ITHREADS
	unshare_hek_or_pvn (he->refcounted_he_hek, 0, 0, 0);
#endif
	copy = he;
	he = he->refcounted_he_next;
	PerlMemShared_free(copy);
    }
}

/*
=for apidoc m|struct refcounted_he *|refcounted_he_inc|struct refcounted_he *he

Increment the reference count of a C<refcounted_he>.  The pointer to the
C<refcounted_he> is also returned.  It is safe to pass a null pointer
to this function: no action occurs and a null pointer is returned.

=cut
*/

struct refcounted_he *
Perl_refcounted_he_inc(pTHX_ struct refcounted_he *he)
{
#ifdef USE_ITHREADS
    dVAR;
#endif
    PERL_UNUSED_CONTEXT;
    if (he) {
	HINTS_REFCNT_LOCK;
	he->refcounted_he_refcnt++;
	HINTS_REFCNT_UNLOCK;
    }
    return he;
}

/*
=for apidoc cop_fetch_label

Returns the label attached to a cop.
The flags pointer may be set to C<SVf_UTF8> or 0.

=cut
*/

/* pp_entereval is aware that labels are stored with a key ':' at the top of
   the linked list.  */
const char *
Perl_cop_fetch_label(pTHX_ COP *const cop, STRLEN *len, U32 *flags) {
    struct refcounted_he *const chain = cop->cop_hints_hash;

    PERL_ARGS_ASSERT_COP_FETCH_LABEL;
    PERL_UNUSED_CONTEXT;

    if (!chain)
	return NULL;
#ifdef USE_ITHREADS
    if (chain->refcounted_he_keylen != 1)
	return NULL;
    if (*REF_HE_KEY(chain) != ':')
	return NULL;
#else
    if ((STRLEN)HEK_LEN(chain->refcounted_he_hek) != 1)
	return NULL;
    if (*HEK_KEY(chain->refcounted_he_hek) != ':')
	return NULL;
#endif
    /* Stop anyone trying to really mess us up by adding their own value for
       ':' into %^H  */
    if ((chain->refcounted_he_data[0] & HVrhek_typemask) != HVrhek_PV
	&& (chain->refcounted_he_data[0] & HVrhek_typemask) != HVrhek_PV_UTF8)
	return NULL;

    if (len)
	*len = chain->refcounted_he_val.refcounted_he_u_len;
    if (flags) {
	*flags = ((chain->refcounted_he_data[0] & HVrhek_typemask)
		  == HVrhek_PV_UTF8) ? SVf_UTF8 : 0;
    }
    return chain->refcounted_he_data + 1;
}

/*
=for apidoc cop_store_label

Save a label into a C<cop_hints_hash>.
You need to set flags to C<SVf_UTF8>
for a UTF-8 label.

=cut
*/

void
Perl_cop_store_label(pTHX_ COP *const cop, const char *label, STRLEN len,
		     U32 flags)
{
    SV *labelsv;
    PERL_ARGS_ASSERT_COP_STORE_LABEL;

    if (flags & ~(SVf_UTF8))
	Perl_croak(aTHX_ "panic: cop_store_label illegal flag bits 0x%" UVxf,
		   (UV)flags);
    labelsv = newSVpvn_flags(label, len, SVs_TEMP);
    if (flags & SVf_UTF8)
	SvUTF8_on(labelsv);
    cop->cop_hints_hash
	= refcounted_he_new_pvs(cop->cop_hints_hash, ":", labelsv, 0);
}

/*
=for apidoc hv_assert

Check that a hash is in an internally consistent state.

=cut
*/

#ifdef DEBUGGING

void
Perl_hv_assert(pTHX_ HV *hv)
{
    dVAR;
    HE* entry;
    int withflags = 0;
    int placeholders = 0;
    int real = 0;
    int bad = 0;
    const I32 riter = HvRITER_get(hv);
    HE *eiter = HvEITER_get(hv);

    PERL_ARGS_ASSERT_HV_ASSERT;

    (void)hv_iterinit(hv);

    while ((entry = hv_iternext_flags(hv, HV_ITERNEXT_WANTPLACEHOLDERS))) {
	/* sanity check the values */
	if (HeVAL(entry) == &PL_sv_placeholder)
	    placeholders++;
	else
	    real++;
	/* sanity check the keys */
	if (HeSVKEY(entry)) {
	    NOOP;   /* Don't know what to check on SV keys.  */
	} else if (HeKUTF8(entry)) {
	    withflags++;
	    if (HeKWASUTF8(entry)) {
		PerlIO_printf(Perl_debug_log,
			    "hash key has both WASUTF8 and UTF8: '%.*s'\n",
			    (int) HeKLEN(entry),  HeKEY(entry));
		bad = 1;
	    }
	} else if (HeKWASUTF8(entry))
	    withflags++;
    }
    if (!SvTIED_mg((const SV *)hv, PERL_MAGIC_tied)) {
	static const char bad_count[] = "Count %d %s(s), but hash reports %d\n";
	const int nhashkeys = HvUSEDKEYS(hv);
	const int nhashplaceholders = HvPLACEHOLDERS_get(hv);

	if (nhashkeys != real) {
	    PerlIO_printf(Perl_debug_log, bad_count, real, "keys", nhashkeys );
	    bad = 1;
	}
	if (nhashplaceholders != placeholders) {
	    PerlIO_printf(Perl_debug_log, bad_count, placeholders, "placeholder", nhashplaceholders );
	    bad = 1;
	}
    }
    if (withflags && ! HvHASKFLAGS(hv)) {
	PerlIO_printf(Perl_debug_log,
		    "Hash has HASKFLAGS off but I count %d key(s) with flags\n",
		    withflags);
	bad = 1;
    }
    if (bad) {
	sv_dump(MUTABLE_SV(hv));
    }
    HvRITER_set(hv, riter);		/* Restore hash iterator state */
    HvEITER_set(hv, eiter);
}

#endif

/*
 * ex: set ts=8 sts=4 sw=4 et:
 */
@


1.20
log
@Update to perl 5.20.3

OK bluhm@@
@
text
@a20 1

a52 1
    dVAR;
a102 1
    dVAR;
d225 1
a225 1
NULL if the operation failed or if the value did not need to be actually
d229 2
a230 2
the call, and decrementing it if the function returned NULL.  Effectively
a successful hv_store takes ownership of one reference to C<val>.  This is
d232 1
a232 1
if all your code does is create SVs then store them in a hash, hv_store
d234 4
a237 4
anything further to tidy up.  hv_store is not implemented as a call to
hv_store_ent, and does not create a temporary SV for the key, so if your
key data is not already in SV form then use hv_store in preference to
hv_store_ent.
d247 1
a247 1
NULL if the operation failed or if the value did not need to be actually
d253 1
a253 1
hv_store_ent takes ownership of one reference to C<val>.  This is
d255 1
a255 1
if all your code does is create SVs then store them in a hash, hv_store
d257 1
a257 1
anything further to tidy up.  Note that hv_store_ent only reads the C<key>;
d259 2
a260 2
reference count on C<key> is entirely the caller's responsibility.  hv_store
is not implemented as a call to hv_store_ent, and does not create a temporary
d262 1
a262 1
hv_store in preference to hv_store_ent.
d348 1
d499 5
a503 1
		magic_existspack(svret, mg_find(sv, PERL_MAGIC_tiedelem));
d622 4
a625 5
    if (!hash) {
        if (keysv && (SvIsCOW_shared_hash(keysv)))
            hash = SvSHARED_HASH(keysv);
        else
            PERL_HASH(hash, key, klen);
d627 2
d639 31
d675 1
a675 1
	if (HeKEY(entry) != key && memNE(HeKEY(entry),key,klen))	/* is this it? */
d680 1
d745 1
a745 1
	    return entry ? (void *) &HeVAL(entry) : NULL;
d749 2
d976 2
a977 2
will normally be zero; if set to G_DISCARD then NULL will be returned.
NULL will also be returned if the key is not found.
d983 2
a984 2
zero; if set to G_DISCARD then NULL will be returned.  NULL will also be
returned if the key is not found.  C<hash> can be a valid precomputed hash
d998 1
a998 1
    HE *const *first_entry;
d1001 5
d1070 4
a1073 5
    if (!hash) {
        if (keysv && (SvIsCOW_shared_hash(keysv)))
            hash = SvSHARED_HASH(keysv);
        else
            PERL_HASH(hash, key, klen);
d1075 2
d1082 31
a1113 5
	SV *sv;
	U8 mro_changes = 0; /* 1 = isa; 2 = package moved */
	GV *gv = NULL;
	HV *stash = NULL;

d1118 1
a1118 1
	if (HeKEY(entry) != key && memNE(HeKEY(entry),key,klen))	/* is this it? */
d1123 1
d1169 4
a1172 1
		else if (klen == 3 && strnEQ(key, "ISA", 3))
d1174 62
d1289 2
a1305 1
    dVAR;
d1362 1
a1362 1
             * so intialize it properly. This unrolls hv_auxinit() a bit,
d1398 1
a1398 1
                    PL_hash_rand_bits+= ROTL_UV(HeHASH(entry), 17);
a1428 1
    dVAR;
d1558 1
a1558 1
A specialised version of L</newHVhv> for copying C<%^H>.  I<ohv> must be
d1561 1
a1561 1
of I<ohv> is copied to a new hash, which has the C<%^H>-specific magic
a1613 1
    dVAR;
a1634 1
    dVAR;
a1648 2
    dVAR;

d1667 2
a1668 2
If any destructors are triggered as a result, the hv itself may
be freed.
d1732 1
a1732 1
deleted but is marked by assigning it a value of &PL_sv_placeholder.  This tags
d1736 2
a1737 1
See Hash::Util::lock_keys() for an example of its use.
a1744 1
    dVAR;
d1799 1
a1799 1
    NOT_REACHED;
d1899 1
a1899 1
As well as freeing all the elements of the hash (like hv_clear()), this
d1902 2
a1903 4
If any destructors are triggered as a result, the hv itself may
be freed.

See also L</hv_clear>.
a1910 1
    dVAR;
d1933 1
a1933 1
                             HEKf"'\n", HvNAME_HEK(hv)));
d1952 1
a1952 1
                             HEKf"'\n", HvENAME_HEK(hv)));
d1963 1
a1963 1
                             HEKf"'\n", HvNAME_HEK(hv)));
a2166 5
    /* FIXME: Are we not NULL, or do we croak? Place bets now! */

    if (!hv)
	Perl_croak(aTHX_ "Bad hash");

a2193 3
    if (!hv)
	Perl_croak(aTHX_ "Bad hash");

a2203 3
    if (!hv)
	Perl_croak(aTHX_ "Bad hash");

a2213 3
    if (!hv)
	Perl_croak(aTHX_ "Bad hash");

a2231 3
    if (!hv)
        Perl_croak(aTHX_ "Bad hash");

a2248 3
    if (!hv)
	Perl_croak(aTHX_ "Bad hash");

d2362 1
a2362 1
C<hv_ename_delete>.
a2384 1
	HEK ** const xhv_name = aux->xhv_name_u.xhvnameu_names;
d2386 2
a2387 1
	HEK **hekp = xhv_name + (count < 0 ? -count : count);
d2389 2
d2400 1
a2436 1
    dVAR;
a2500 2
    struct xpvhv_aux * const iter = SvOOK(hv) ? HvAUX(hv) : hv_auxinit(hv);

d2502 5
a2506 3
    PERL_UNUSED_CONTEXT;

    return &(iter->xhv_backreferences);
d2533 1
a2533 1
Returns entries from a hash iterator.  See C<hv_iterinit>.
d2545 3
a2547 2
Returns entries from a hash iterator.  See C<hv_iterinit> and C<hv_iternext>.
The C<flags> value will normally be zero; if HV_ITERNEXT_WANTPLACEHOLDERS is
a2569 3
    if (!hv)
	Perl_croak(aTHX_ "Bad hash");

d2712 1
a2712 1
C<hv_iterinit>.
d2740 1
a2740 1
see C<hv_iterinit>.
d2757 1
a2757 1
C<hv_iterkey>.
d2808 1
a2808 1
Adds magic to a hash.  See C<sv_magic>.
a2836 1
    dVAR;
a2958 1
    dVAR;
a3042 1
    dVAR;
a3060 1
    dVAR;
d3064 1
a3071 1
    dVAR;
d3132 1
a3132 1
I<flags> is currently unused and must be zero.
d3239 1
a3239 1
by I<keypv> and I<keylen>.  If I<flags> has the C<REFCOUNTED_HE_KEY_UTF8>
d3241 1
a3241 1
are interpreted as Latin-1.  I<hash> is a precomputed hash of the key
d3289 1
a3289 1
                    *q = (char) TWO_BYTE_UTF8_TO_NATIVE(c, *p);
d3378 1
a3378 1
The new key is specified by I<keypv> and I<keylen>.  If I<flags> has
d3380 1
a3380 1
as UTF-8, otherwise they are interpreted as Latin-1.  I<hash> is
d3384 1
a3384 1
I<value> is the scalar value to store for this key.  I<value> is copied
d3389 1
a3389 1
I<value> may be either null or C<&PL_sv_placeholder> to indicate that no
d3394 1
a3394 1
I<parent> points to the rest of the C<refcounted_he> chain to be
d3396 1
a3396 1
of one reference to I<parent>, and returns one reference to the new
d3465 1
a3465 1
                    *q = (char) TWO_BYTE_UTF8_TO_NATIVE(c, *p);
d3571 1
d3573 1
d3610 1
d3612 2
d3638 1
d3673 1
a3673 1
for a utf-8 label.
a3770 6
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
@


1.19
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d3157 1
a3157 1
	return &PL_sv_placeholder;
d3217 1
@


1.18
log
@Revive the fix for Perl RT bug 116441 (null dereference affecting
mod_perl).

ok sthen@@ millert@@
@
text
@d39 1
d753 2
a754 1
	       up as a bug if the conversion routine is not idempotent.  */
d795 7
d903 2
a904 1
Evaluates the hash in scalar context and returns the result. Handles magic when the hash is tied.
d961 1
d1037 1
a1037 1
    oentry = &(HvARRAY(hv))[hash & (I32) HvMAX(hv)];
d1066 1
a1066 2
	if (SvREADONLY(hv) && HeVAL(entry) && SvREADONLY(HeVAL(entry))
	 && !SvIsCOW(HeVAL(entry))) {
d1124 6
d1165 1
d1174 9
a1184 3
    /*PerlIO_printf(PerlIO_stderr(), "hsplit called for %p which had %d\n",
      (void*)hv, (int) oldsize);*/

d1187 2
a1188 1
	  + (SvOOK(hv) ? sizeof(struct xpvhv_aux) : 0), char);
a1189 1
      PL_nomemok = FALSE;
d1192 1
d1205 6
a1210 2

    if (SvOOK(hv)) {
d1213 16
a1228 2
        Move(&a[oldsize * sizeof(HE*)], dest, 1, struct xpvhv_aux);
        /* we reset the iterator's xhv_rand as well, so they get a totally new ordering */
d1230 1
a1230 1
        dest->xhv_rand = (U32)PL_hash_rand_bits;
d1232 5
d1238 1
a1238 2

    PL_nomemok = FALSE;
a1239 2
    HvMAX(hv) = --newsize;
    HvARRAY(hv) = (HE**) a;
d1244 1
d1565 1
a1565 1
			if (SvREADONLY(HeVAL(entry)) && !SvIsCOW(HeVAL(entry))) {
d1653 4
a1656 2
		    HvTOTALKEYS(hv) -= (IV)HvPLACEHOLDERS_get(hv);
		    if (HvUSEDKEYS(hv) == 0)
d1668 1
a1668 1
    assert (0);
d1707 13
a1719 13
    if (SvOOK(hv) && ((iter = HvAUX(hv)))
	&& ((entry = iter->xhv_eiter)) )
    {
	/* the iterator may get resurrected after each
	 * destructor call, so check each time */
	if (entry && HvLAZYDEL(hv)) {	/* was deleted earlier? */
	    HvLAZYDEL_off(hv);
	    hv_free_ent(hv, entry);
	    /* warning: at this point HvARRAY may have been
	     * re-allocated, HvMAX changed etc */
	}
	iter->xhv_riter = -1; 	/* HvRITER(hv) = -1 */
	iter->xhv_eiter = NULL;	/* HvEITER(hv) = NULL */
d1721 1
a1721 1
        iter->xhv_last_rand = iter->xhv_rand;
d1723 7
a1783 1
    const char *name;
d1788 1
a1790 1
    save = !!SvREFCNT(hv);
d1802 1
a1802 1
    if (PL_phase != PERL_PHASE_DESTRUCT && (name = HvNAME(hv))) {
d1806 1
a1806 4
	    (void)hv_delete(PL_stashcache, name,
                            HEK_UTF8(HvNAME_HEK(hv)) ? -HvNAMELEN_get(hv) : HvNAMELEN_get(hv),
                            G_DISCARD
                           );
a1815 1
      struct xpvhv_aux * const aux = HvAUX(hv);
d1817 1
d1819 1
a1819 1
      if ((name = HvENAME_get(hv))) {
d1825 1
a1825 5
	    (void)hv_delete(
	            PL_stashcache, name,
                    HEK_UTF8(HvENAME_HEK(hv)) ? -HvENAMELEN_get(hv) : HvENAMELEN_get(hv),
                    G_DISCARD
	          );
d1832 1
a1832 1
      if (flags & HV_NAME_SETALL ? !!aux->xhv_name_u.xhvnameu_name : !!name) {
d1836 1
a1836 1
	    (void)hv_delete(PL_stashcache, name, (HEK_UTF8(HvNAME_HEK(hv)) ? -HvNAMELEN_get(hv) : HvNAMELEN_get(hv)), G_DISCARD);
d1840 1
a1840 1
      if((meta = aux->xhv_mro_meta)) {
d1852 1
d1854 1
a1854 1
	aux->xhv_mro_meta = NULL;
d1856 1
a1856 2
      SvREFCNT_dec(aux->xhv_super);
      if (!aux->xhv_name_u.xhvnameu_name && ! aux->xhv_backreferences)
d1877 2
a1878 1
Returns the number of hash buckets that happen to be in use. This function is
d1881 7
a1887 2
Previously this value was stored in the HV structure, rather than being
calculated on demand.
d1893 1
a1893 1
Perl_hv_fill(pTHX_ HV const *const hv)
d1897 1
d1901 10
d1920 10
d1966 17
d2016 1
a2016 11
    iter->xhv_riter = -1; 	/* HvRITER(hv) = -1 */
    iter->xhv_eiter = NULL;	/* HvEITER(hv) = NULL */
#ifdef PERL_HASH_RANDOMIZE_KEYS
    iter->xhv_last_rand = iter->xhv_rand;
#endif
    iter->xhv_name_u.xhvnameu_name = 0;
    iter->xhv_name_count = 0;
    iter->xhv_backreferences = 0;
    iter->xhv_mro_meta = NULL;
    iter->xhv_super = NULL;
    return iter;
d2045 1
a2045 1
	struct xpvhv_aux * const iter = HvAUX(hv);
d2051 1
d2183 1
d2205 1
d2350 1
d2438 1
a2438 1
to normal keys. By default placeholders are automatically skipped over.
d2503 1
d2550 1
d2595 1
d2934 1
a2934 1
I32 *
d3163 2
a3164 4
	    U8 c = (U8)*p;
	    if (c & 0x80) {
		if (!((c & 0xfe) == 0xc2 && ++p != keyend &&
			    (((U8)*p) & 0xc0) == 0x80))
d3166 1
d3168 1
d3180 7
a3186 2
		*q = (char)
		    ((c & 0x80) ? ((c & 0x03) << 6) | (((U8)*++p) & 0x3f) : c);
d3338 2
a3339 4
	    U8 c = (U8)*p;
	    if (c & 0x80) {
		if (!((c & 0xfe) == 0xc2 && ++p != keyend &&
			    (((U8)*p) & 0xc0) == 0x80))
d3341 1
d3343 1
d3355 7
a3361 2
		*q = (char)
		    ((c & 0x80) ? ((c & 0x03) << 6) | (((U8)*++p) & 0x3f) : c);
d3560 2
a3561 1
Save a label into a C<cop_hints_hash>. You need to set flags to C<SVf_UTF8>
@


1.17
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d1731 1
a1731 1
    const bool save = !!SvREFCNT(hv);
d1737 1
@


1.16
log
@avoid null dereference affecting mod_perl, Perl RT bug 116441
@
text
@d38 1
a38 2
#define HV_MAX_LENGTH_BEFORE_REHASH 14
#define SHOULD_DO_HSPLIT(xhv) ((xhv)->xhv_keys > (xhv)->xhv_max) /* HvTOTALKEYS(hv) > HvMAX(hv) */
d81 1
a81 1
    register HEK *hek;
d280 4
a283 1
C<lval> is set then the fetch will be part of a store.  Check that the
d340 1
a340 1
	       int flags, int action, SV *val, register U32 hash)
d391 1
a391 1
	    flags = 0;
d399 1
a399 2
					 flags | (is_utf8 ? HVhek_UTF8 : 0),
					 action, hash);
d529 1
a529 1
		const bool save_taint = PL_tainted;
d534 2
a535 2
		    if (PL_tainting)
			PL_tainted = SvTAINTED(keysv);
d543 3
d600 1
a600 1
    if (is_utf8 & !(flags & HVhek_KEYCANONICAL)) {
d619 6
a624 12
    if (HvREHASH(hv) || (!hash && !(keysv && (SvIsCOW_shared_hash(keysv)))))
	PERL_HASH_INTERNAL_(hash, key, klen, HvREHASH(hv));
    else if (!hash)
	hash = SvSHARED_HASH(keysv);

    /* We don't have a pointer to the hv, so we have to replicate the
       flag into every HEK, so that hv_iterkeysv can see it.
       And yes, you do need this even though you are not "storing" because
       you can flip the flags below if doing an lval lookup.  (And that
       was put in to give the semantics Andreas was expecting.)  */
    if (HvREHASH(hv))
	flags |= HVhek_REHASH;
d792 42
a833 2
    HeNEXT(entry) = *oentry;
    *oentry = entry;
d841 21
a861 2
    if ( SHOULD_DO_HSPLIT(xhv) ) {
        hsplit(hv);
d948 3
a950 3
    register XPVHV* xhv;
    register HE *entry;
    register HE **oentry;
d998 1
a998 1
    if (is_utf8) {
d1017 6
a1022 4
    if (HvREHASH(hv) || (!hash && !(keysv && (SvIsCOW_shared_hash(keysv)))))
	PERL_HASH_INTERNAL_(hash, key, klen, HvREHASH(hv));
    else if (!hash)
	hash = SvSHARED_HASH(keysv);
d1150 1
a1150 1
S_hsplit(pTHX_ HV *hv)
d1153 1
a1153 4
    register XPVHV* const xhv = (XPVHV*)SvANY(hv);
    const I32 oldsize = (I32) xhv->xhv_max+1; /* HvMAX(hv)+1 (sick) */
    register I32 newsize = oldsize * 2;
    register I32 i;
d1155 1
a1155 3
    register HE **aep;
    int longest_chain = 0;
    int was_shared;
a1161 8
    if (HvPLACEHOLDERS_get(hv) && !SvREADONLY(hv)) {
      /* Can make this clear any placeholders first for non-restricted hashes,
	 even though Storable rebuilds restricted hashes by putting in all the
	 placeholders (first) before turning on the readonly flag, because
	 Storable always pre-splits the hash.  */
      hv_clear_placeholders(hv);
    }
	       
a1162 1
#if defined(STRANGE_MALLOC) || defined(MYMALLOC)
d1169 10
a1178 2
    if (SvOOK(hv)) {
	Move(&a[oldsize * sizeof(HE*)], &a[newsize * sizeof(HE*)], 1, struct xpvhv_aux);
d1180 2
a1181 8
#else
    Newx(a, PERL_HV_ARRAY_ALLOC_BYTES(newsize)
	+ (SvOOK(hv) ? sizeof(struct xpvhv_aux) : 0), char);
    if (!a) {
      PL_nomemok = FALSE;
      return;
    }
    Copy(HvARRAY(hv), a, oldsize * sizeof(HE*), char);
d1183 7
a1189 1
	Copy(HvAUX(hv), &a[newsize * sizeof(HE*)], 1, struct xpvhv_aux);
a1190 2
    Safefree(HvARRAY(hv));
#endif
d1194 1
a1194 1
    xhv->xhv_max = --newsize;	/* HvMAX(hv) = --newsize */
d1196 4
d1201 3
a1203 7

    for (i=0; i<oldsize; i++,aep++) {
	int left_length = 0;
	int right_length = 0;
	HE **oentry = aep;
	HE *entry = *aep;
	register HE **bep;
a1206 1
	bep = aep+oldsize;
d1208 2
a1209 1
	    if ((HeHASH(entry) & newsize) != (U32)i) {
d1211 25
a1235 3
		HeNEXT(entry) = *bep;
		*bep = entry;
		right_length++;
a1238 1
		left_length++;
d1242 1
a1242 77
	/* I think we don't actually need to keep track of the longest length,
	   merely flag if anything is too long. But for the moment while
	   developing this code I'll track it.  */
	if (left_length > longest_chain)
	    longest_chain = left_length;
	if (right_length > longest_chain)
	    longest_chain = right_length;
    }


    /* Pick your policy for "hashing isn't working" here:  */
    if (longest_chain <= HV_MAX_LENGTH_BEFORE_REHASH /* split worked?  */
	|| HvREHASH(hv)) {
	return;
    }

    if (hv == PL_strtab) {
	/* Urg. Someone is doing something nasty to the string table.
	   Can't win.  */
	return;
    }

    /* Awooga. Awooga. Pathological data.  */
    /*PerlIO_printf(PerlIO_stderr(), "%p %d of %d with %d/%d buckets\n", (void*)hv,
      longest_chain, HvTOTALKEYS(hv), HvFILL(hv),  1+HvMAX(hv));*/

    ++newsize;
    Newxz(a, PERL_HV_ARRAY_ALLOC_BYTES(newsize)
	 + (SvOOK(hv) ? sizeof(struct xpvhv_aux) : 0), char);
    if (SvOOK(hv)) {
	Copy(HvAUX(hv), &a[newsize * sizeof(HE*)], 1, struct xpvhv_aux);
    }

    was_shared = HvSHAREKEYS(hv);

    HvSHAREKEYS_off(hv);
    HvREHASH_on(hv);

    aep = HvARRAY(hv);

    for (i=0; i<newsize; i++,aep++) {
	register HE *entry = *aep;
	while (entry) {
	    /* We're going to trash this HE's next pointer when we chain it
	       into the new hash below, so store where we go next.  */
	    HE * const next = HeNEXT(entry);
	    UV hash;
	    HE **bep;

	    /* Rehash it */
	    PERL_HASH_INTERNAL(hash, HeKEY(entry), HeKLEN(entry));

	    if (was_shared) {
		/* Unshare it.  */
		HEK * const new_hek
		    = save_hek_flags(HeKEY(entry), HeKLEN(entry),
				     hash, HeKFLAGS(entry));
		unshare_hek (HeKEY_hek(entry));
		HeKEY_hek(entry) = new_hek;
	    } else {
		/* Not shared, so simply write the new hash in. */
		HeHASH(entry) = hash;
	    }
	    /*PerlIO_printf(PerlIO_stderr(), "%d ", HeKFLAGS(entry));*/
	    HEK_REHASH_on(HeKEY_hek(entry));
	    /*PerlIO_printf(PerlIO_stderr(), "%d\n", HeKFLAGS(entry));*/

	    /* Copy oentry to the correct new chain.  */
	    bep = ((HE**)a) + (hash & (I32) xhv->xhv_max);
	    HeNEXT(entry) = *bep;
	    *bep = entry;

	    entry = next;
	}
    }
    Safefree (HvARRAY(hv));
    HvARRAY(hv) = (HE **)a;
d1249 1
a1249 1
    register XPVHV* xhv = (XPVHV*)SvANY(hv);
d1251 2
a1252 4
    register I32 newsize;
    register I32 i;
    register char *a;
    register HE **aep;
d1269 5
a1273 26
	PL_nomemok = TRUE;
#if defined(STRANGE_MALLOC) || defined(MYMALLOC)
	Renew(a, PERL_HV_ARRAY_ALLOC_BYTES(newsize)
	      + (SvOOK(hv) ? sizeof(struct xpvhv_aux) : 0), char);
	if (!a) {
	  PL_nomemok = FALSE;
	  return;
	}
	if (SvOOK(hv)) {
	    Copy(&a[oldsize * sizeof(HE*)], &a[newsize * sizeof(HE*)], 1, struct xpvhv_aux);
	}
#else
	Newx(a, PERL_HV_ARRAY_ALLOC_BYTES(newsize)
	    + (SvOOK(hv) ? sizeof(struct xpvhv_aux) : 0), char);
	if (!a) {
	  PL_nomemok = FALSE;
	  return;
	}
	Copy(HvARRAY(hv), a, oldsize * sizeof(HE*), char);
	if (SvOOK(hv)) {
	    Copy(HvAUX(hv), &a[newsize * sizeof(HE*)], 1, struct xpvhv_aux);
	}
	Safefree(HvARRAY(hv));
#endif
	PL_nomemok = FALSE;
	Zero(&a[oldsize * sizeof(HE*)], (newsize-oldsize) * sizeof(HE*), char); /* zero 2nd half*/
d1275 1
a1275 7
    else {
	Newxz(a, PERL_HV_ARRAY_ALLOC_BYTES(newsize), char);
    }
    xhv->xhv_max = --newsize; 	/* HvMAX(hv) = --newsize */
    HvARRAY(hv) = (HE **) a;
    if (!xhv->xhv_keys /* !HvTOTALKEYS(hv) */)	/* skip rest if no entries */
	return;
d1277 13
a1289 4
    aep = (HE**)a;
    for (i=0; i<oldsize; i++,aep++) {
	HE **oentry = aep;
	HE *entry = *aep;
a1290 17
	if (!entry)				/* non-existent */
	    continue;
	do {
	    register I32 j = (HeHASH(entry) & newsize);

	    if (j != i) {
		j -= i;
		*oentry = HeNEXT(entry);
		HeNEXT(entry) = aep[j];
		aep[j] = entry;
	    }
	    else
		oentry = &HeNEXT(entry);
	    entry = *oentry;
	} while (entry);
    }
}
d1353 1
a1353 1
	STRLEN hv_fill = HvFILL(ohv);
d1355 1
a1355 4
	/* Can we use fewer buckets? (hv_max is always 2^n-1) */
	while (hv_max && hv_max + 1 >= hv_fill * 2)
	    hv_max = hv_max / 2;
	HvMAX(hv) = hv_max;
d1394 1
a1394 1
	STRLEN hv_fill = HvFILL(ohv);
d1399 4
a1402 3
	while (hv_max && hv_max + 1 >= hv_fill * 2)
	    hv_max = hv_max / 2;
	HvMAX(hv) = hv_max;
d1416 1
a1416 1
		SvREFCNT_dec(heksv);
d1421 3
d1428 1
d1432 1
a1432 1
S_hv_free_ent_ret(pTHX_ HV *hv, register HE *entry)
a1438 2
    if (!entry)
	return NULL;
d1454 1
a1454 1
Perl_hv_free_ent(pTHX_ HV *hv, register HE *entry)
d1469 1
a1469 1
Perl_hv_delayfree_ent(pTHX_ HV *hv, register HE *entry)
d1501 1
a1501 1
    register XPVHV* xhv;
d1519 8
a1526 6
		    if (HeVAL(entry) && SvREADONLY(HeVAL(entry))
		     && !SvIsCOW(HeVAL(entry))) {
			SV* const keysv = hv_iterkeysv(entry);
			Perl_croak(aTHX_
				   "Attempt to delete readonly key '%"SVf"' from a restricted hash",
				   (void*)keysv);
a1527 1
		    SvREFCNT_dec(HeVAL(entry));
a1541 1
	HvREHASH_off(hv);
d1673 3
d1729 1
a1729 1
    register XPVHV* xhv;
d1731 1
a1731 1
    bool save;
a1734 1
    save = !!SvREFCNT(hv);
d1749 3
a1751 1
        if (PL_stashcache)
d1756 1
d1771 3
a1773 1
        if (PL_stashcache)
d1779 1
d1786 3
a1788 1
        if (name && PL_stashcache)
d1790 1
d1795 5
a1799 5
	    SvREFCNT_dec(MUTABLE_SV(meta->mro_linear_all));
	    meta->mro_linear_all = NULL;
	    /* This is just acting as a shortcut pointer.  */
	    meta->mro_linear_current = NULL;
	} else if (meta->mro_linear_current) {
a1802 2
	    meta->mro_linear_current = NULL;
	}
d1808 1
d1814 1
a1814 1
	xhv->xhv_max   = 7;	/* HvMAX(hv) = 7 (it's a normal hash) */
d1859 34
d1894 1
a1894 1
S_hv_auxinit(HV *hv) {
d1900 21
a1920 3
    if (!HvARRAY(hv)) {
	Newxz(array, PERL_HV_ARRAY_ALLOC_BYTES(HvMAX(hv) + 1)
	    + sizeof(struct xpvhv_aux), char);
d1922 1
a1922 3
	array = (char *) HvARRAY(hv);
	Renew(array, PERL_HV_ARRAY_ALLOC_BYTES(HvMAX(hv) + 1)
	      + sizeof(struct xpvhv_aux), char);
a1923 3
    HvARRAY(hv) = (HE**) array;
    SvOOK_on(hv);
    iter = HvAUX(hv);
d1927 3
d1934 1
d1972 3
d2030 21
d2329 1
a2329 1
	    SvREFCNT_dec(av);
d2366 2
a2367 2
    register XPVHV* xhv;
    register HE *entry;
d2381 1
a2381 1
	   call iv_iternext without calling hv_iterinit, so we'll have to deal
d2394 1
d2402 1
d2419 1
d2456 12
d2478 3
d2483 1
a2483 1
	    entry = (HvARRAY(hv))[iter->xhv_riter];
d2496 6
a2501 1
    else iter->xhv_riter = -1;
a2507 3
    /*if (HvREHASH(hv) && entry && !HeKREHASH(entry))
      PerlIO_printf(PerlIO_stderr(), "Awooga %p %p\n", (void*)hv, (void*)entry);*/

d2522 1
a2522 1
Perl_hv_iterkey(pTHX_ register HE *entry, I32 *retlen)
d2550 1
a2550 1
Perl_hv_iterkeysv(pTHX_ register HE *entry)
d2567 1
a2567 1
Perl_hv_iterval(pTHX_ HV *hv, register HE *entry)
d2642 1
a2642 1
    register XPVHV* xhv;
d2644 1
a2644 1
    register HE **oentry;
d2730 1
a2730 1
Perl_share_hek(pTHX_ const char *str, I32 len, register U32 hash)
d2752 1
d2762 1
a2762 1
S_share_hek_flags(pTHX_ const char *str, I32 len, register U32 hash, int flags)
d2765 1
a2765 1
    register HE *entry;
d2768 1
a2768 1
    register XPVHV * const xhv = (XPVHV*)SvANY(PL_strtab);
d2832 3
a2834 2
	} else if ( SHOULD_DO_HSPLIT(xhv) ) {
            hsplit(PL_strtab);
d3564 1
a3564 1
 * indent-tabs-mode: t
d3567 1
a3567 1
 * ex: set ts=8 sts=4 sw=4 noet:
@


1.15
log
@Apply patch from RedHat to address CVE-2013-1667, perl: DoS in rehashing code
For more information please refer to: http://code.activestate.com/lists/perl5-porters/191311/

ok millert@@
@
text
@d22 2
a23 2
A HV structure represents a Perl hash. It consists mainly of an array
of pointers, each of which points to a linked list of HE structures. The
d25 1
a25 1
represents all the hash entries with the same hash value. Each HE contains
a43 18
STATIC void
S_more_he(pTHX)
{
    dVAR;
    /* We could generate this at compile time via (another) auxiliary C
       program?  */
    const size_t arena_size = Perl_malloc_good_size(PERL_ARENA_SIZE);
    HE* he = (HE*) Perl_get_arena(aTHX_ arena_size, HE_SVSLOT);
    HE * const heend = &he[arena_size / sizeof(HE) - 1];

    PL_body_roots[HE_SVSLOT] = he;
    while (he < heend) {
	HeNEXT(he) = (HE*)(he + 1);
	he++;
    }
    HeNEXT(he) = 0;
}

d59 1
a59 1
	S_more_he(aTHX);
d165 1
a165 1
	HeKEY_sv(ret) = SvREFCNT_inc(sv_dup(HeKEY_sv(e), param));
d188 1
a188 1
    HeVAL(ret) = SvREFCNT_inc(sv_dup(HeVAL(e), param));
d221 7
a227 3
Stores an SV in a hash.  The hash key is specified as C<key> and C<klen> is
the length of the key.  The C<hash> parameter is the precomputed hash
value; if it is zero then Perl will compute it.  The return value will be
d273 2
a274 1
C<klen> is the length of the key.
d278 5
a282 4
Returns the SV which corresponds to the specified key in the hash.  The
C<klen> is the length of the key.  If C<lval> is set then the fetch will be
part of a store.  Check that the return value is non-null before
dereferencing it to an C<SV*>.
d289 2
a290 1
Returns a boolean indicating whether the specified hash key exists. C<hash>
d306 1
a306 1
accessing it.  The return value when C<tb> is a tied hash is a pointer to a
d351 1
a351 1
    if (SvTYPE(hv) == SVTYPEMASK)
d615 11
a625 7
    if (HvREHASH(hv)) {
	PERL_HASH_INTERNAL(hash, key, klen);
	/* We don't have a pointer to the hv, so we have to replicate the
	   flag into every HEK, so that hv_iterkeysv can see it.  */
	/* And yes, you do need this even though you are not "storing" because
	   you can flip the flags below if doing an lval lookup.  (And that
	   was put in to give the semantics Andreas was expecting.)  */
a626 7
    } else if (!hash) {
        if (keysv && (SvIsCOW_shared_hash(keysv))) {
            hash = SvSHARED_HASH(keysv);
        } else {
            PERL_HASH(hash, key, klen);
        }
    }
d690 1
a690 1
		    /* LVAL fetch which actaully needs a store.  */
d743 1
a743 1
	val = newSV(0);
d802 3
a804 9
    {
	const HE *counter = HeNEXT(entry);

	xhv->xhv_keys++; /* HvTOTALKEYS(hv)++ */
	if (!counter) {				/* initial entry? */
	    xhv->xhv_fill++; /* HvFILL(hv)++ */
	} else if ( SHOULD_DO_HSPLIT(xhv) ) {
	    hsplit(hv);
	}
d856 1
a856 1
    if (HvFILL((const HV *)hv)) 
d868 6
a873 4
Deletes a key/value pair in the hash.  The value SV is removed from the
hash and returned to the caller.  The C<klen> is the length of the key.
The C<flags> value will normally be zero; if set to G_DISCARD then NULL
will be returned.
d877 5
a881 4
Deletes a key/value pair in the hash.  The value SV is removed from the
hash and returned to the caller.  The C<flags> value will normally be zero;
if set to G_DISCARD then NULL will be returned.  C<hash> can be a valid
precomputed hash value, or 0 to ask for it to be computed.
a893 1
    HE *const *first_entry;
d960 4
a963 9
    if (HvREHASH(hv)) {
	PERL_HASH_INTERNAL(hash, key, klen);
    } else if (!hash) {
        if (keysv && (SvIsCOW_shared_hash(keysv))) {
            hash = SvSHARED_HASH(keysv);
        } else {
            PERL_HASH(hash, key, klen);
        }
    }
d967 1
a967 1
    first_entry = oentry = &(HvARRAY(hv))[hash & (I32) HvMAX(hv)];
d971 4
d996 2
a997 1
	if (SvREADONLY(hv) && HeVAL(entry) && SvREADONLY(HeVAL(entry))) {
d1005 36
a1040 5
	if (d_flags & G_DISCARD)
	    sv = NULL;
	else {
	    sv = sv_2mortal(HeVAL(entry));
	    HeVAL(entry) = &PL_sv_placeholder;
d1049 1
a1049 3
	if (SvREADONLY(hv)) {
	    SvREFCNT_dec(HeVAL(entry));
	    HeVAL(entry) = &PL_sv_placeholder;
d1053 1
a1053 1
	} else {
a1054 3
	    if(!*first_entry) {
		xhv->xhv_fill--; /* HvFILL(hv)-- */
	    }
d1057 4
a1060 1
	    else
d1062 1
d1067 10
a1099 1
    register HE **oentry;
d1138 1
a1138 7
    if (oldsize >= 64) {
	offer_nice_chunk(HvARRAY(hv),
			 PERL_HV_ARRAY_ALLOC_BYTES(oldsize)
			 + (SvOOK(hv) ? sizeof(struct xpvhv_aux) : 0));
    }
    else
	Safefree(HvARRAY(hv));
d1150 2
a1151 1
	register HE *entry;
d1154 1
a1154 1
	if (!*aep)				/* non-existent */
d1157 1
a1157 1
	for (oentry = aep, entry = *aep; entry; entry = *oentry) {
a1160 2
		if (!*bep)
		    xhv->xhv_fill++; /* HvFILL(hv)++ */
a1162 1
		continue;
d1168 2
a1169 3
	}
	if (!*aep)				/* everything moved */
	    xhv->xhv_fill--; /* HvFILL(hv)-- */
a1204 1
    xhv->xhv_fill = 0;
a1238 2
	    if (!*bep)
		    xhv->xhv_fill++; /* HvFILL(hv)++ */
a1258 2
    register HE *entry;
    register HE **oentry;
d1297 1
a1297 7
	if (oldsize >= 64) {
	    offer_nice_chunk(HvARRAY(hv),
			     PERL_HV_ARRAY_ALLOC_BYTES(oldsize)
			     + (SvOOK(hv) ? sizeof(struct xpvhv_aux) : 0));
	}
	else
	    Safefree(HvARRAY(hv));
d1307 1
a1307 1
    if (!xhv->xhv_fill /* !HvFILL(hv) */)	/* skip rest if no entries */
d1312 4
a1315 1
	if (!*aep)				/* non-existent */
d1317 1
a1317 1
	for (oentry = aep, entry = *aep; entry; entry = *oentry) {
d1323 1
a1323 2
		if (!(HeNEXT(entry) = aep[j]))
		    xhv->xhv_fill++; /* HvFILL(hv)++ */
a1324 1
		continue;
d1328 2
a1329 3
	}
	if (!*aep)				/* everything moved */
	    xhv->xhv_fill--; /* HvFILL(hv)-- */
d1338 1
a1338 1
    STRLEN hv_max, hv_fill;
d1340 1
a1340 1
    if (!ohv || (hv_fill = HvFILL(ohv)) == 0)
a1385 1
	HvFILL(hv)  = hv_fill;
d1394 1
d1403 7
a1409 3
	    SV *const val = HeVAL(entry);
	    (void)hv_store_flags(hv, HeKEY(entry), HeKLEN(entry),
			         SvIMMORTAL(val) ? val : newSVsv(val),
d1419 12
a1430 2
/* A rather specialised version of newHVhv for copying %^H, ensuring all the
   magic stays on it.  */
a1434 1
    STRLEN hv_fill;
d1436 1
a1436 1
    if (ohv && (hv_fill = HvFILL(ohv))) {
d1438 1
d1449 4
a1452 3
	    SV *const sv = newSVsv(HeVAL(entry));
	    SV *heksv = newSVhek(HeKEY_hek(entry));
	    sv_magic(sv, NULL, PERL_MAGIC_hintselem,
d1454 7
a1460 3
	    SvREFCNT_dec(heksv);
	    (void)hv_store_flags(hv, HeKEY(entry), HeKLEN(entry),
				 sv, HeHASH(entry), HeKFLAGS(entry));
d1469 3
a1471 2
void
Perl_hv_free_ent(pTHX_ HV *hv, register HE *entry)
d1476 1
a1476 1
    PERL_ARGS_ASSERT_HV_FREE_ENT;
d1479 1
a1479 1
	return;
a1480 3
    if (HvNAME(hv) && anonymise_cv(HvNAME_HEK(hv), val) && GvCVu(val))
	mro_method_changed_in(hv);
    SvREFCNT_dec(val);
d1490 1
d1493 3
a1495 2
static I32
S_anonymise_cv(pTHX_ HEK *stash, SV *val)
d1497 2
a1498 1
    CV *cv;
d1500 1
a1500 1
    PERL_ARGS_ASSERT_ANONYMISE_CV;
d1502 4
a1505 19
    if (val && isGV(val) && isGV_with_GP(val) && (cv = GvCV(val))) {
	if ((SV *)CvGV(cv) == val) {
	    GV *anongv;

	    if (stash) {
		SV *gvname = newSVhek(stash);
		sv_catpvs(gvname, "::__ANON__");
		anongv = gv_fetchsv(gvname, GV_ADDMULTI, SVt_PVCV);
		SvREFCNT_dec(gvname);
	    } else {
		anongv = gv_fetchpvs("__ANON__::__ANON__", GV_ADDMULTI,
				     SVt_PVCV);
	    }
	    CvGV(cv) = anongv;
	    CvANON_on(cv);
	    return 1;
	}
    }
    return 0;
d1508 1
d1529 5
a1533 1
Clears a hash, making it empty.
d1550 2
d1560 2
a1561 1
		    if (HeVAL(entry) && SvREADONLY(HeVAL(entry))) {
a1572 1
	goto reset;
d1574 3
d1578 2
a1579 4
    hfreeentries(hv);
    HvPLACEHOLDERS_set(hv, 0);
    if (HvARRAY(hv))
	Zero(HvARRAY(hv), xhv->xhv_max+1 /* HvMAX(hv)+1 */, HE*);
d1581 3
a1583 6
    if (SvRMAGICAL(hv))
	mg_clear(MUTABLE_SV(hv));

    HvHASKFLAGS_off(hv);
    HvREHASH_off(hv);
    reset:
d1585 1
a1585 1
        if(HvNAME_get(hv))
d1589 1
a1631 1
	bool first = TRUE;
a1637 2
		if (first && !*oentry)
		    HvFILL(hv)--; /* This linked list is now empty.  */
d1640 4
a1643 1
		else
d1645 1
d1650 1
a1650 1
		    if (HvKEYS(hv) == 0)
a1656 1
		first = FALSE;
d1668 3
a1670 4
    /* This is the array that we're going to restore  */
    HE **const orig_array = HvARRAY(hv);
    HEK *name;
    int attempts = 100;
d1674 2
a1675 17
    if (!orig_array)
	return;

    if (HvNAME(hv) && orig_array != NULL) {
	/* symbol table: make all the contained subs ANON */
	STRLEN i;
	XPVHV *xhv = (XPVHV*)SvANY(hv);

	for (i = 0; i <= xhv->xhv_max; i++) {
	    HE *entry = (HvARRAY(hv))[i];
	    for (; entry; entry = HeNEXT(entry)) {
		SV *val = HeVAL(entry);
		/* we need to put the subs in the __ANON__ symtable, as
		 * this one is being cleared. */
		anonymise_cv(NULL, val);
	    }
	}
d1677 1
a1678 4
    if (SvOOK(hv)) {
	/* If the hash is actually a symbol table with a name, look after the
	   name.  */
	struct xpvhv_aux *iter = HvAUX(hv);
d1680 8
a1687 5
	name = iter->xhv_name;
	iter->xhv_name = NULL;
    } else {
	name = NULL;
    }
d1689 9
a1697 11
    /* orig_array remains unchanged throughout the loop. If after freeing all
       the entries it turns out that one of the little blighters has triggered
       an action that has caused HvARRAY to be re-allocated, then we set
       array to the new HvARRAY, and try again.  */

    while (1) {
	/* This is the one we're going to try to empty.  First time round
	   it's the original array.  (Hopefully there will only be 1 time
	   round) */
	HE ** const array = HvARRAY(hv);
	I32 i = HvMAX(hv);
d1699 1
a1699 3
	/* Because we have taken xhv_name out, the only allocated pointer
	   in the aux structure that might exist is the backreference array.
	*/
d1701 10
a1710 57
	if (SvOOK(hv)) {
	    HE *entry;
            struct mro_meta *meta;
	    struct xpvhv_aux *iter = HvAUX(hv);
	    /* If there are weak references to this HV, we need to avoid
	       freeing them up here.  In particular we need to keep the AV
	       visible as what we're deleting might well have weak references
	       back to this HV, so the for loop below may well trigger
	       the removal of backreferences from this array.  */

	    if (iter->xhv_backreferences) {
		/* So donate them to regular backref magic to keep them safe.
		   The sv_magic will increase the reference count of the AV,
		   so we need to drop it first. */
		SvREFCNT_dec(iter->xhv_backreferences);
		if (AvFILLp(iter->xhv_backreferences) == -1) {
		    /* Turns out that the array is empty. Just free it.  */
		    SvREFCNT_dec(iter->xhv_backreferences);

		} else {
		    sv_magic(MUTABLE_SV(hv),
			     MUTABLE_SV(iter->xhv_backreferences),
			     PERL_MAGIC_backref, NULL, 0);
		}
		iter->xhv_backreferences = NULL;
	    }

	    entry = iter->xhv_eiter; /* HvEITER(hv) */
	    if (entry && HvLAZYDEL(hv)) {	/* was deleted earlier? */
		HvLAZYDEL_off(hv);
		hv_free_ent(hv, entry);
	    }
	    iter->xhv_riter = -1; 	/* HvRITER(hv) = -1 */
	    iter->xhv_eiter = NULL;	/* HvEITER(hv) = NULL */

            if((meta = iter->xhv_mro_meta)) {
		if (meta->mro_linear_all) {
		    SvREFCNT_dec(MUTABLE_SV(meta->mro_linear_all));
		    meta->mro_linear_all = NULL;
		    /* This is just acting as a shortcut pointer.  */
		    meta->mro_linear_current = NULL;
		} else if (meta->mro_linear_current) {
		    /* Only the current MRO is stored, so this owns the data.
		     */
		    SvREFCNT_dec(meta->mro_linear_current);
		    meta->mro_linear_current = NULL;
		}
                if(meta->mro_nextmethod) SvREFCNT_dec(meta->mro_nextmethod);
                SvREFCNT_dec(meta->isa);
                Safefree(meta);
                iter->xhv_mro_meta = NULL;
            }

	    /* There are now no allocated pointers in the aux structure.  */

	    SvFLAGS(hv) &= ~SVf_OOK; /* Goodbye, aux structure.  */
	    /* What aux structure?  */
d1712 3
d1716 2
a1717 6
	/* make everyone else think the array is empty, so that the destructors
	 * called for freed entries can't recusively mess with us */
	HvARRAY(hv) = NULL;
	HvFILL(hv) = 0;
	((XPVHV*) SvANY(hv))->xhv_keys = 0;

d1719 22
a1740 16
	do {
	    /* Loop down the linked list heads  */
	    HE *entry = array[i];

	    while (entry) {
		register HE * const oentry = entry;
		entry = HeNEXT(entry);
		hv_free_ent(hv, oentry);
	    }
	} while (--i >= 0);

	/* As there are no allocated pointers in the aux structure, it's now
	   safe to free the array we just cleaned up, if it's not the one we're
	   going to put back.  */
	if (array != orig_array) {
	    Safefree(array);
d1742 3
a1745 4
	if (!HvARRAY(hv)) {
	    /* Good. No-one added anything this time round.  */
	    break;
	}
d1747 2
a1748 5
	if (SvOOK(hv)) {
	    /* Someone attempted to iterate or set the hash name while we had
	       the array set to 0.  We'll catch backferences on the next time
	       round the while loop.  */
	    assert(HvARRAY(hv));
d1750 1
a1750 11
	    if (HvAUX(hv)->xhv_name) {
		unshare_hek_or_pvn(HvAUX(hv)->xhv_name, 0, 0, 0);
	    }
	}

	if (--attempts == 0) {
	    Perl_die(aTHX_ "panic: hfreeentries failed to free hash - something is repeatedly re-creating entries");
	}
    }
	
    HvARRAY(hv) = orig_array;
d1752 2
a1753 9
    /* If the hash was actually a symbol table, put the name back.  */
    if (name) {
	/* We have restored the original array.  If name is non-NULL, then
	   the original array had an aux structure at the end. So this is
	   valid:  */
	SvFLAGS(hv) |= SVf_OOK;
	HvAUX(hv)->xhv_name = name;
    }
}
d1755 2
a1756 2
/*
=for apidoc hv_undef
d1758 1
a1758 1
Undefines the hash.
d1764 1
a1764 1
Perl_hv_undef(pTHX_ HV *hv)
d1769 1
d1773 1
d1777 26
a1802 2
    if ((name = HvNAME_get(hv)) && !PL_dirty)
        mro_isa_changed_in(hv);
d1804 3
a1806 2
    hfreeentries(hv);
    if (name) {
d1808 39
a1846 2
	    (void)hv_delete(PL_stashcache, name, HvNAMELEN_get(hv), G_DISCARD);
	hv_name_set(hv, NULL, 0, 0);
d1848 4
a1851 5
    SvFLAGS(hv) &= ~SVf_OOK;
    Safefree(HvARRAY(hv));
    xhv->xhv_max   = 7;	/* HvMAX(hv) = 7 (it's a normal hash) */
    HvARRAY(hv) = 0;
    HvPLACEHOLDERS_set(hv, 0);
d1855 33
d1906 1
a1906 2
    /* SvOOK_on(hv) attacks the IV flags.  */
    SvFLAGS(hv) |= SVf_OOK;
d1911 2
a1912 1
    iter->xhv_name = 0;
d1922 1
a1922 1
keys in the hash (i.e. the same as C<HvKEYS(tb)>).  The return value is
d1927 1
a1927 1
value, you can get it through the macro C<HvFILL(tb)>.
d2034 1
a2036 1
    PERL_UNUSED_ARG(flags);
d2043 44
a2086 2
	if (iter->xhv_name) {
	    unshare_hek_or_pvn(iter->xhv_name, 0, 0, 0);
d2088 1
d2094 1
d2097 161
a2257 1
    iter->xhv_name = name ? share_hek(name, len, hash) : NULL;
d2284 2
a2285 1
	SvREFCNT_dec(av);
d2311 1
a2311 1
C<&Perl_sv_placeholder>. Note that the implementation of placeholders and
d2391 1
a2391 1
    /* hv_iterint now ensures this.  */
d2434 1
a2580 1
    HE **first;
d2621 1
a2621 1
    first = oentry = &(HvARRAY(PL_strtab))[hash & (I32) HvMAX(PL_strtab)];
a2645 4
            if (!*first) {
		/* There are now no entries in our slot.  */
                xhv->xhv_fill--; /* HvFILL(hv)-- */
	    }
d2653 1
a2653 1
			 "Attempt to free non-existent shared string '%s'%s"
d2687 2
a2688 1
      if (str != save)
d2690 1
d2743 1
a2743 1
	   HEK directly from the HE.
a2766 1
	    xhv->xhv_fill++; /* HvFILL(hv)++ */
d2863 2
a2864 2
	Perl_croak(aTHX_ "panic: refcounted_he_value bad flags %x",
		   he->refcounted_he_data[0]);
d2870 1
a2870 1
=for apidoc refcounted_he_chain_2hv
d2872 3
a2874 2
Generates and returns a C<HV *> by walking up the tree starting at the passed
in C<struct refcounted_he *>.
d2879 1
a2879 1
Perl_refcounted_he_chain_2hv(pTHX_ const struct refcounted_he *chain)
d2882 7
a2888 2
    HV *hv = newHV();
    U32 placeholders = 0;
d2892 2
a2893 2
    const U32 max = HvMAX(hv);

d2900 1
a2954 4
	if (!HeNEXT(entry)) {
	    /* initial entry.   */
	    HvFILL(hv)++;
	}
d2977 14
d2992 2
a2993 2
Perl_refcounted_he_fetch(pTHX_ const struct refcounted_he *chain, SV *keysv,
			 const char *key, STRLEN klen, int flags, U32 hash)
d2996 2
a2997 3
    /* Just to be awkward, if you're using this interface the UTF-8-or-not-ness
       of your key has to exactly match that which is stored.  */
    SV *value = &PL_sv_placeholder;
d2999 37
a3035 3
    if (chain) {
	/* No point in doing any of this if there's nothing to find.  */
	bool is_utf8;
d3037 19
a3055 8
	if (keysv) {
	    if (flags & HVhek_FREEKEY)
		Safefree(key);
	    key = SvPV_const(keysv, klen);
	    flags = 0;
	    is_utf8 = (SvUTF8(keysv) != 0);
	} else {
	    is_utf8 = ((flags & HVhek_UTF8) ? TRUE : FALSE);
d3057 3
d3061 16
a3076 7
	if (!hash) {
	    if (keysv && (SvIsCOW_shared_hash(keysv))) {
		hash = SvSHARED_HASH(keysv);
	    } else {
		PERL_HASH(hash, key, klen);
	    }
	}
d3078 2
a3079 20
	for (; chain; chain = chain->refcounted_he_next) {
#ifdef USE_ITHREADS
	    if (hash != chain->refcounted_he_hash)
		continue;
	    if (klen != chain->refcounted_he_keylen)
		continue;
	    if (memNE(REF_HE_KEY(chain),key,klen))
		continue;
	    if (!!is_utf8 != !!(chain->refcounted_he_data[0] & HVhek_UTF8))
		continue;
#else
	    if (hash != HEK_HASH(chain->refcounted_he_hek))
		continue;
	    if (klen != (STRLEN)HEK_LEN(chain->refcounted_he_hek))
		continue;
	    if (memNE(HEK_KEY(chain->refcounted_he_hek),key,klen))
		continue;
	    if (!!is_utf8 != !!HEK_UTF8(chain->refcounted_he_hek))
		continue;
#endif
d3081 2
a3082 4
	    value = sv_2mortal(refcounted_he_value(chain));
	    break;
	}
    }
d3084 2
a3085 2
    if (flags & HVhek_FREEKEY)
	Safefree(key);
d3087 16
a3102 1
    return value;
d3106 1
a3106 1
=for apidoc refcounted_he_new
d3108 26
a3133 3
Creates a new C<struct refcounted_he>. As S<key> is copied, and value is
stored in a compact form, all references remain the property of the caller.
The C<struct refcounted_he> is returned with a reference count of 1.
d3139 3
a3141 2
Perl_refcounted_he_new(pTHX_ struct refcounted_he *const parent,
		       SV *const key, SV *const value) {
a3142 2
    STRLEN key_len;
    const char *key_p = SvPV_const(key, key_len);
d3145 1
d3147 4
a3150 2
    char flags;
    bool is_utf8 = SvUTF8(key) ? TRUE : FALSE;
d3152 3
a3154 1
    if (SvPOK(value)) {
a3157 2
    } else if (value == &PL_sv_placeholder) {
	value_type = HVrhek_delete;
d3163 2
a3164 2

    if (value_type == HVrhek_PV) {
d3170 1
d3172 1
a3172 27
    flags = value_type;

    if (is_utf8) {
	/* Hash keys are always stored normalised to (yes) ISO-8859-1.
	   As we're going to be building hash keys from this value in future,
	   normalise it now.  */
	key_p = (char*)bytes_from_utf8((const U8*)key_p, &key_len, &is_utf8);
	flags |= is_utf8 ? HVhek_UTF8 : HVhek_WASUTF8;
    }

    return refcounted_he_new_common(parent, key_p, key_len, flags, value_type,
				    ((value_type == HVrhek_PV
				      || value_type == HVrhek_PV_UTF8) ?
				     (void *)value_p : (void *)value),
				    value_len);
}

static struct refcounted_he *
S_refcounted_he_new_common(pTHX_ struct refcounted_he *const parent,
			   const char *const key_p, const STRLEN key_len,
			   const char flags, char value_type,
			   const void *value, const STRLEN value_len) {
    dVAR;
    struct refcounted_he *he;
    U32 hash;
    const bool is_pv = value_type == HVrhek_PV || value_type == HVrhek_PV_UTF8;
    STRLEN key_offset = is_pv ? value_len + 2 : 1;
d3174 33
a3206 1
    PERL_ARGS_ASSERT_REFCOUNTED_HE_NEW_COMMON;
d3211 1
a3211 1
			     + key_len
d3222 1
a3222 1
	Copy((char *)value, he->refcounted_he_data + 1, value_len + 1, char);
d3225 1
a3225 1
	he->refcounted_he_val.refcounted_he_u_iv = SvIVX((const SV *)value);
d3227 1
a3227 1
	he->refcounted_he_val.refcounted_he_u_uv = SvUVX((const SV *)value);
a3229 2
    PERL_HASH(hash, key_p, key_len);

d3232 2
a3233 2
    he->refcounted_he_keylen = key_len;
    Copy(key_p, he->refcounted_he_data + key_offset, key_len, char);
d3235 1
a3235 1
    he->refcounted_he_hek = share_hek_flags(key_p, key_len, hash, flags);
d3238 1
a3238 7
    if (flags & HVhek_WASUTF8) {
	/* If it was downgraded from UTF-8, then the pointer returned from
	   bytes_from_utf8 is an allocated pointer that we must free.  */
	Safefree(key_p);
    }

    he->refcounted_he_data[0] = flags;
d3245 1
a3245 1
=for apidoc refcounted_he_free
d3247 49
a3295 3
Decrements the reference count of the passed in C<struct refcounted_he *>
by one. If the reference count reaches zero the structure's memory is freed,
and C<refcounted_he_free> iterates onto the parent node.
d3326 31
d3360 5
a3364 2
Perl_fetch_cop_label(pTHX_ struct refcounted_he *const chain, STRLEN *len,
		     U32 *flags) {
d3393 12
a3404 5
/* As newSTATEOP currently gets passed plain char* labels, we will only provide
   that interface. Once it works out how to pass in length and UTF-8 ness, this
   function will need superseding.  */
struct refcounted_he *
Perl_store_cop_label(pTHX_ struct refcounted_he *const chain, const char *label)
d3406 2
a3407 1
    PERL_ARGS_ASSERT_STORE_COP_LABEL;
d3409 8
a3416 2
    return refcounted_he_new_common(chain, ":", 1, HVrhek_PV, HVrhek_PV,
				    label, strlen(label));
@


1.14
log
@merge in perl 5.12.2 plus local changes
@
text
@d38 2
a39 1
#define HV_MAX_LENGTH_BEFORE_SPLIT 14
d822 1
a822 1
	} else if (xhv->xhv_keys > (IV)xhv->xhv_max) {
a823 15
	} else if(!HvREHASH(hv)) {
	    U32 n_links = 1;

	    while ((counter = HeNEXT(counter)))
		n_links++;

	    if (n_links > HV_MAX_LENGTH_BEFORE_SPLIT) {
		/* Use only the old HvKEYS(hv) > HvMAX(hv) condition to limit
		   bucket splits on a rehashed hash, as we're not going to
		   split it again, and if someone is lucky (evil) enough to
		   get all the keys in one list they could exhaust our memory
		   as we repeatedly double the number of buckets on every
		   entry. Linear search feels a less worse thing to do.  */
		hsplit(hv);
	    }
d1169 1
a1169 1
    if (longest_chain <= HV_MAX_LENGTH_BEFORE_SPLIT /* split worked?  */
d2540 2
a2541 2
	} else if (xhv->xhv_keys > (IV)xhv->xhv_max /* HvKEYS(hv) > HvMAX(hv) */) {
		hsplit(PL_strtab);
@


1.14.8.1
log
@Apply patch from RedHat to address CVE-2013-1667, perl: DoS in rehashing code
For more information please refer to: http://code.activestate.com/lists/perl5-porters/191311/

ok millert@@
@
text
@d38 1
a38 2
#define HV_MAX_LENGTH_BEFORE_REHASH 14
#define SHOULD_DO_HSPLIT(xhv) ((xhv)->xhv_keys > (xhv)->xhv_max) /* HvTOTALKEYS(hv) > HvMAX(hv) */
d821 1
a821 1
	} else if ( SHOULD_DO_HSPLIT(xhv) ) {
d823 15
d1183 1
a1183 1
    if (longest_chain <= HV_MAX_LENGTH_BEFORE_REHASH /* split worked?  */
d2554 2
a2555 2
	} else if ( SHOULD_DO_HSPLIT(xhv) ) {
            hsplit(PL_strtab);
@


1.13
log
@Merge in perl 5.10.1
@
text
@d1349 1
d1383 1
d1385 1
a1385 1
		HeVAL(ent)     = newSVsv(HeVAL(oent));
d1416 1
d1418 2
a1419 2
			         newSVsv(HeVAL(entry)), HeHASH(entry),
			         HeKFLAGS(entry));
d1474 2
a1475 2
    if (val && isGV(val) && isGV_with_GP(val) && GvCVu(val) && HvNAME_get(hv))
        mro_method_changed_in(hv);	/* deletion of method from stash */
d1488 28
d1680 16
d1759 3
a1761 3
		if (meta->mro_linear_dfs) {
		    SvREFCNT_dec(MUTABLE_SV(meta->mro_linear_dfs));
		    meta->mro_linear_dfs = NULL;
d1763 2
a1764 2
		    meta->mro_linear_c3 = NULL;
		} else if (meta->mro_linear_c3) {
d1767 2
a1768 2
		    SvREFCNT_dec(MUTABLE_SV(meta->mro_linear_c3));
		    meta->mro_linear_c3 = NULL;
d2153 1
a2153 2
            if (HeVAL(entry))
                SvREFCNT_dec(HeVAL(entry));
a2191 2
    while (!entry) {
	/* OK. Come to the end of the current list.  Grab the next one.  */
d2193 13
a2205 7
	iter->xhv_riter++; /* HvRITER(hv)++ */
	if (iter->xhv_riter > (I32)xhv->xhv_max /* HvRITER(hv) > HvMAX(hv) */) {
	    /* There is no next one.  End of the hash.  */
	    iter->xhv_riter = -1; /* HvRITER(hv) = -1 */
	    break;
	}
	entry = (HvARRAY(hv))[iter->xhv_riter];
d2207 9
a2215 5
        if (!(flags & HV_ITERNEXT_WANTPLACEHOLDERS)) {
            /* If we have an entry, but it's a placeholder, don't count it.
	       Try the next.  */
	    while (entry && HeVAL(entry) == &PL_sv_placeholder)
		entry = HeNEXT(entry);
a2216 3
	/* Will loop again if this linked list starts NULL
	   (for HV_ITERNEXT_WANTPLACEHOLDERS)
	   or if we run through it and find only placeholders.  */
a2379 1
	LOCK_STRTAB_MUTEX;
a2381 1
	    UNLOCK_STRTAB_MUTEX;
a2383 1
	UNLOCK_STRTAB_MUTEX;
a2404 1
    LOCK_STRTAB_MUTEX;
d2439 6
a2444 7
    UNLOCK_STRTAB_MUTEX;
    if (!entry && ckWARN_d(WARN_INTERNAL))
	Perl_warner(aTHX_ packWARN(WARN_INTERNAL),
                    "Attempt to free non-existent shared string '%s'%s"
                    pTHX__FORMAT,
                    hek ? HEK_KEY(hek) : str,
                    ((k_flags & HVhek_UTF8) ? " (utf8)" : "") pTHX__VALUE);
a2502 1
    LOCK_STRTAB_MUTEX;
a2559 1
    UNLOCK_STRTAB_MUTEX;
d2587 1
a2587 1
Perl_hv_placeholders_get(pTHX_ HV *hv)
d2590 1
a2590 1
    MAGIC * const mg = mg_find((SV*)hv, PERL_MAGIC_rhash);
a2837 1
    struct refcounted_he *he;
a2843 2
    STRLEN key_offset;
    U32 hash;
d2849 1
a2849 1
	value_type = HVrhek_IV;
d2859 2
d2862 11
a2872 4
	key_offset = value_len + 2;
    } else {
	value_len = 0;
	key_offset = 1;
d2875 20
a2905 1

d2908 2
a2909 2
    if (value_type == HVrhek_PV) {
	Copy(value_p, he->refcounted_he_data + 1, value_len + 1, char);
a2910 4
	/* Do it this way so that the SvUTF8() test is after the SvPV, in case
	   the value is overloaded, and doesn't yet have the UTF-8flag set.  */
	if (SvUTF8(value))
	    value_type = HVrhek_PV_UTF8;
d2912 3
a2914 6
	if (SvUOK(value)) {
	    he->refcounted_he_val.refcounted_he_u_uv = SvUVX(value);
	    value_type = HVrhek_UV;
	} else {
	    he->refcounted_he_val.refcounted_he_u_iv = SvIVX(value);
	}
a2915 1
    flags = value_type;
a2916 7
    if (is_utf8) {
	/* Hash keys are always stored normalised to (yes) ISO-8859-1.
	   As we're going to be building hash keys from this value in future,
	   normalise it now.  */
	key_p = (char*)bytes_from_utf8((const U8*)key_p, &key_len, &is_utf8);
	flags |= is_utf8 ? HVhek_UTF8 : HVhek_WASUTF8;
    }
d2973 45
@


1.12
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d3 2
a4 2
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, by Larry Wall and others
d12 5
a16 1
 * "I sit beside the fire and think of all that I have seen."  --Bilbo
d47 5
a51 2
    HE* he = (HE*) Perl_get_arena(aTHX_ PERL_ARENA_SIZE, HE_SVSLOT);
    HE * const heend = &he[PERL_ARENA_SIZE / sizeof(HE) - 1];
d101 2
d137 1
a137 1
    HEK *shared = (HEK*)ptr_table_fetch(PL_ptr_table, source);
d139 1
d142 4
d164 2
d180 1
a180 1
	Newx(k, HEK_BASESIZE + sizeof(SV*), char);
d215 3
d334 2
d368 1
a368 1
	if ((mg = mg_find((SV*)hv, PERL_MAGIC_uvar))) {
d374 3
a376 3
		    keysv = sv_2mortal(newSVpvn(key, klen));
		    if (flags & HVhek_UTF8)
			SvUTF8_on(keysv);
d381 1
a381 1
		magic_getuvar((SV*)hv, mg);
a394 1
	flags = 0;
d396 5
d414 2
a415 1
	    if ( mg_find((SV*)hv, PERL_MAGIC_tied) || SvGMAGICAL((SV*)hv))
d420 2
a421 5
		    keysv = newSVpvn(key, klen);
		    if (is_utf8) {
			SvUTF8_on(keysv);
		    }
		} else {
d425 1
a425 1
                mg_copy((SV*)hv, sv, (char *)keysv, HEf_SVKEY);
d434 1
a434 1
		    Newx(k, HEK_BASESIZE + sizeof(SV*), char);
d443 1
a443 1
		LvTARG(sv) = (SV*)entry;
d455 1
a455 1
	    else if (mg_find((SV*)hv, PERL_MAGIC_env)) {
d490 2
a491 1
	    if (mg_find((SV*)hv, PERL_MAGIC_tied) || SvGMAGICAL((SV*)hv)) {
d499 1
a499 2
			keysv = newSVpvn(key, klen);
			SvUTF8_on(keysv);
d503 1
a503 1
		    mg_copy((SV*)hv, sv, (char *)sv_2mortal(keysv), HEf_SVKEY);
d505 1
a505 1
		    mg_copy((SV*)hv, sv, key, klen);
d516 1
a516 1
	    else if (mg_find((SV*)hv, PERL_MAGIC_env)) {
d541 1
a541 2
			keysv = newSVpvn(key, klen);
			SvUTF8_on(keysv);
d546 1
a546 1
		    mg_copy((SV*)hv, val, (char*)keysv, HEf_SVKEY);
d548 1
a548 1
		    mg_copy((SV*)hv, val, key, klen);
d558 1
a558 1
		else if (mg_find((SV*)hv, PERL_MAGIC_env)) {
d581 2
a582 1
		 || (SvRMAGICAL((SV*)hv) && mg_find((SV*)hv, PERL_MAGIC_env))
d606 1
a606 1
    if (is_utf8) {
d617 5
d730 2
a731 1
	&& SvRMAGICAL((SV*)hv) && mg_find((SV*)hv, PERL_MAGIC_env)) {
d851 3
d881 2
d884 1
a884 1
	MAGIC * const mg = mg_find((SV*)hv, PERL_MAGIC_tied);
d890 1
a890 1
    if (HvFILL((HV*)hv)) 
d954 1
a954 1
		else if (mg_find((SV*)hv, PERL_MAGIC_env)) {
d956 1
a956 1
		    keysv = sv_2mortal(newSVpvn(key,klen));
d989 1
a989 1
        HvHASKFLAGS_on((SV*)hv);
d1096 2
d1118 1
a1118 1
	Copy(&a[oldsize * sizeof(HE*)], &a[newsize * sizeof(HE*)], 1, struct xpvhv_aux);
d1267 2
a1345 24
/*
=for apidoc newHV

Creates a new HV.  The reference count is set to 1.

=cut
*/

HV *
Perl_newHV(pTHX)
{
    register XPVHV* xhv;
    HV * const hv = (HV*)newSV_type(SVt_PVHV);
    xhv = (XPVHV*)SvANY(hv);
    assert(!SvOK(hv));
#ifndef NODEFAULT_SHAREKEYS
    HvSHAREKEYS_on(hv);         /* key-sharing on by default */
#endif

    xhv->xhv_max    = 7;	/* HvMAX(hv) = 7 (start with 8 buckets) */
    xhv->xhv_fill   = 0;	/* HvFILL(hv) = 0 */
    return hv;
}

d1356 1
a1356 1
    if (!SvMAGICAL((SV *)ohv)) {
d1446 1
d1448 2
a1449 1
		     (char *)newSVhek (HeKEY_hek(entry)), HEf_SVKEY);
d1466 2
d1489 3
d1551 1
a1551 1
	mg_clear((SV*)hv);
d1583 2
d1595 2
d1644 2
d1696 2
a1697 1
		    sv_magic((SV*)hv, (SV*)iter->xhv_backreferences,
d1712 11
a1722 2
                if(meta->mro_linear_dfs) SvREFCNT_dec(meta->mro_linear_dfs);
                if(meta->mro_linear_c3)  SvREFCNT_dec(meta->mro_linear_c3);
d1724 1
d1829 1
a1829 1
	mg_clear((SV*)hv);
d1837 2
d1878 4
d1906 2
d1919 2
d1932 2
d1952 2
d1977 1
d2001 2
d2004 1
d2012 2
d2021 2
a2022 1
	Perl_sv_kill_backrefs(aTHX_ (SV*) hv, av);
d2065 2
d2082 1
a2082 1
	if ( ( mg = mg_find((SV*)hv, PERL_MAGIC_tied) ) ) {
d2095 1
a2095 1
                Newxz(k, HEK_BASESIZE + sizeof(SV*), char);
d2100 1
a2100 1
            magic_nextpack((SV*) hv,mg,key);
d2115 2
a2116 1
    if (!entry && SvRMAGICAL((SV*)hv) && mg_find((SV*)hv, PERL_MAGIC_env)) {
d2192 2
d2220 2
d2237 2
d2240 1
a2240 1
	if (mg_find((SV*)hv, PERL_MAGIC_tied)) {
d2243 1
a2243 1
		mg_copy((SV*)hv, sv, (char*)HeKEY_sv(entry), HEf_SVKEY);
d2245 1
a2245 1
		mg_copy((SV*)hv, sv, HeKEY(entry), HeKLEN(entry));
d2266 2
d2414 2
d2443 3
d2455 1
a2455 1
    register XPVHV * const xhv = (XPVHV*)SvANY(PL_strtab);
d2527 3
a2529 1
    MAGIC *mg = mg_find((SV*)hv, PERL_MAGIC_rhash);
d2532 1
a2532 1
	mg = sv_magicext((SV*)hv, 0, PERL_MAGIC_rhash, 0, 0, 0);
d2548 2
d2557 3
a2559 1
    MAGIC * const mg = mg_find((SV*)hv, PERL_MAGIC_rhash);
d2564 1
a2564 1
	if (!sv_magicext((SV*)hv, 0, PERL_MAGIC_rhash, 0, 0, ph))
d2575 3
a2724 1
    bool is_utf8;
d2726 13
a2738 9
    if (keysv) {
	if (flags & HVhek_FREEKEY)
	    Safefree(key);
	key = SvPV_const(keysv, klen);
	flags = 0;
	is_utf8 = (SvUTF8(keysv) != 0);
    } else {
	is_utf8 = ((flags & HVhek_UTF8) ? TRUE : FALSE);
    }
d2740 7
a2746 7
    if (!hash) {
	if (keysv && (SvIsCOW_shared_hash(keysv))) {
            hash = SvSHARED_HASH(keysv);
        } else {
            PERL_HASH(hash, key, klen);
        }
    }
d2748 1
a2748 1
    for (; chain; chain = chain->refcounted_he_next) {
d2750 8
a2757 8
	if (hash != chain->refcounted_he_hash)
	    continue;
	if (klen != chain->refcounted_he_keylen)
	    continue;
	if (memNE(REF_HE_KEY(chain),key,klen))
	    continue;
	if (!!is_utf8 != !!(chain->refcounted_he_data[0] & HVhek_UTF8))
	    continue;
d2759 8
a2766 8
	if (hash != HEK_HASH(chain->refcounted_he_hek))
	    continue;
	if (klen != (STRLEN)HEK_LEN(chain->refcounted_he_hek))
	    continue;
	if (memNE(HEK_KEY(chain->refcounted_he_hek),key,klen))
	    continue;
	if (!!is_utf8 != !!HEK_UTF8(chain->refcounted_he_hek))
	    continue;
d2769 3
a2771 2
	value = sv_2mortal(refcounted_he_value(chain));
	break;
d2943 2
d2967 1
a2967 1
    if (!SvTIED_mg((SV*)hv, PERL_MAGIC_tied)) {
d2988 1
a2988 1
	sv_dump((SV *)hv);
@


1.11
log
@merge in perl 5.8.8
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006, by Larry Wall and others
d36 3
d42 5
a46 10
    register HE* he;
    register HE* heend;
    XPV *ptr;
    Newx(ptr, PERL_ARENA_SIZE/sizeof(XPV), XPV);
    ptr->xpv_pv = (char*)PL_he_arenaroot;
    PL_he_arenaroot = ptr;

    he = (HE*)ptr;
    heend = &he[PERL_ARENA_SIZE / sizeof(HE) - 1];
    PL_he_root = ++he;
d54 7
d64 1
d66 3
a68 2
    LOCK_SV_MUTEX;
    if (!PL_he_root)
d70 3
a72 3
    he = PL_he_root;
    PL_he_root = HeNEXT(he);
    UNLOCK_SV_MUTEX;
d76 6
a81 10
STATIC void
S_del_he(pTHX_ HE *p)
{
    LOCK_SV_MUTEX;
    HeNEXT(p) = (HE*)PL_he_root;
    PL_he_root = p;
    UNLOCK_SV_MUTEX;
}

#ifdef PURIFY
a82 4
#define new_HE() (HE*)safemalloc(sizeof(HE))
#define del_HE(p) safefree((char*)p)

#else
a83 2
#define new_HE() new_he()
#define del_HE(p) del_he(p)
d88 1
a88 1
S_save_hek_flags(pTHX_ const char *str, I32 len, U32 hash, int flags)
d100 1
a100 1
    HEK_FLAGS(hek) = (unsigned char)flags_masked;
d113 1
d121 1
a121 1
    PL_hv_fetch_ent_mh = Nullhe;
d125 20
d146 1
a146 1
Perl_he_dup(pTHX_ HE *e, bool shared, CLONE_PARAMS* param)
d151 1
a151 1
	return Nullhe;
d168 18
a185 3
    else if (shared)
	HeKEY_hek(ret) = share_hek_flags(HeKEY(e), HeKLEN(e), HeHASH(e),
                                         HeKFLAGS(e));
d198 1
a198 1
    SV *sv = sv_newmortal();
d210 1
a210 1
    Perl_croak(aTHX_ msg, sv);
a215 5
#define HV_FETCH_ISSTORE   0x01
#define HV_FETCH_ISEXISTS  0x02
#define HV_FETCH_LVALUE    0x04
#define HV_FETCH_JUST_SV   0x08

a238 32
=cut
*/

SV**
Perl_hv_store(pTHX_ HV *hv, const char *key, I32 klen_i32, SV *val, U32 hash)
{
    HE *hek;
    STRLEN klen;
    int flags;

    if (klen_i32 < 0) {
	klen = -klen_i32;
	flags = HVhek_UTF8;
    } else {
	klen = klen_i32;
	flags = 0;
    }
    hek = hv_fetch_common (hv, NULL, key, klen, flags,
			   (HV_FETCH_ISSTORE|HV_FETCH_JUST_SV), val, hash);
    return hek ? &HeVAL(hek) : NULL;
}

SV**
Perl_hv_store_flags(pTHX_ HV *hv, const char *key, I32 klen, SV *val,
                 register U32 hash, int flags)
{
    HE * const hek = hv_fetch_common (hv, NULL, key, klen, flags,
			       (HV_FETCH_ISSTORE|HV_FETCH_JUST_SV), val, hash);
    return hek ? &HeVAL(hek) : NULL;
}

/*
a263 10
=cut
*/

HE *
Perl_hv_store_ent(pTHX_ HV *hv, SV *keysv, SV *val, U32 hash)
{
  return hv_fetch_common(hv, keysv, NULL, 0, 0, HV_FETCH_ISSTORE, val, hash);
}

/*
a268 21
=cut
*/

bool
Perl_hv_exists(pTHX_ HV *hv, const char *key, I32 klen_i32)
{
    STRLEN klen;
    int flags;

    if (klen_i32 < 0) {
	klen = -klen_i32;
	flags = HVhek_UTF8;
    } else {
	klen = klen_i32;
	flags = 0;
    }
    return hv_fetch_common(hv, NULL, key, klen, flags, HV_FETCH_ISEXISTS, 0, 0)
	? TRUE : FALSE;
}

/*
a278 24
=cut
*/

SV**
Perl_hv_fetch(pTHX_ HV *hv, const char *key, I32 klen_i32, I32 lval)
{
    HE *hek;
    STRLEN klen;
    int flags;

    if (klen_i32 < 0) {
	klen = -klen_i32;
	flags = HVhek_UTF8;
    } else {
	klen = klen_i32;
	flags = 0;
    }
    hek = hv_fetch_common (hv, NULL, key, klen, flags,
			   HV_FETCH_JUST_SV | (lval ? HV_FETCH_LVALUE : 0),
			   Nullsv, 0);
    return hek ? &HeVAL(hek) : NULL;
}

/*
a287 7
bool
Perl_hv_exists_ent(pTHX_ HV *hv, SV *keysv, U32 hash)
{
    return hv_fetch_common(hv, keysv, NULL, 0, 0, HV_FETCH_ISEXISTS, 0, hash)
	? TRUE : FALSE;
}

d307 4
a310 2
HE *
Perl_hv_fetch_ent(pTHX_ HV *hv, SV *keysv, I32 lval, register U32 hash)
d312 11
a322 2
    return hv_fetch_common(hv, keysv, NULL, 0, 0, 
			   (lval ? HV_FETCH_LVALUE : 0), Nullsv, hash);
d325 3
a327 3
STATIC HE *
S_hv_fetch_common(pTHX_ HV *hv, SV *keysv, const char *key, STRLEN klen,
		  int flags, int action, SV *val, register U32 hash)
d329 1
d336 1
d339 24
a362 1
	return 0;
d364 6
d380 6
d388 4
a391 6
	if (SvRMAGICAL(hv) && !(action & (HV_FETCH_ISSTORE|HV_FETCH_ISEXISTS)))
	  {
	    if (mg_find((SV*)hv, PERL_MAGIC_tied) || SvGMAGICAL((SV*)hv)) {
		sv = sv_newmortal();

		/* XXX should be able to skimp on the HE/HEK here when
a392 1

d401 2
a402 1
		mg_copy((SV*)hv, sv, (char *)keysv, HEf_SVKEY);
d414 1
a414 1
		HeNEXT(entry) = Nullhe;
d426 4
a429 1
		return entry;
d438 1
a438 1
			const char *nkey = strupr(savepvn(key,klen));
d441 8
a448 6
			entry = hv_fetch_common(hv, Nullsv, nkey, klen,
						HVhek_FREEKEY, /* free nkey */
						0 /* non-LVAL fetch */,
						Nullsv /* no value */,
						0 /* compute hash */);
			if (!entry && (action & HV_FETCH_LVALUE)) {
d452 5
a456 3
			    entry = hv_fetch_common(hv, keysv, key, klen,
						    flags, HV_FETCH_ISSTORE,
						    NEWSV(61,0), hash);
d461 1
a461 1
			return entry;
d490 1
a490 1
		return SvTRUE(svret) ? (HE *)hv : NULL;
d499 1
a499 1
		is_utf8 = 0;
d530 1
a530 1
		if (!xhv->xhv_array /* !HvARRAY(hv) */ && !needs_store) {
d533 1
a533 1
		    return Nullhe;
d542 1
a542 1
		    is_utf8 = 0;
d556 1
a556 1
    if (!xhv->xhv_array /* !HvARRAY(hv) */) {
d579 1
a579 1
	    return 0;
d584 1
a584 1
	char * const keysave = (char * const)key;
a605 2
	/* Not enough shared hash key scalars around to make this worthwhile
	   (about 4% slowdown in perlbench with this in)
d608 1
a608 3
        } else
	*/
	{
d616 1
a616 1
    if (!xhv->xhv_array /* !HvARRAY(hv) */) entry = Null(HE*);
d620 1
a620 2
	/* entry = (HvARRAY(hv))[hash & (I32) HvMAX(hv)]; */
	entry = ((HE**)xhv->xhv_array)[hash & (I32) xhv->xhv_max];
a622 2
	if (!HeKEY_hek(entry))
	    continue;
d642 1
a642 1
		    HEK *new_hek = share_hek_flags(key, klen, hash,
d647 8
d676 2
a677 2
		    val = NEWSV(61,0);
		    xhv->xhv_placeholders--;
d681 1
a681 1
			xhv->xhv_placeholders--;
d695 3
d708 3
a710 2
	    return hv_fetch_common(hv,keysv,key,klen,flags,HV_FETCH_ISSTORE,sv,
				   hash);
d716 1
a716 1
	S_hv_notallowed(aTHX_ flags, key, klen,
d724 1
a724 1
	return 0;
d727 1
a727 1
	val = NEWSV(61,0);
d733 9
a741 2
	    return hv_fetch_common(hv, keysv, key, klen, flags,
				   HV_FETCH_ISSTORE, val, hash);
d749 1
a749 1
    if (!xhv->xhv_array) {
d760 1
a760 1
    oentry = &((HE**)xhv->xhv_array)[hash & (I32) xhv->xhv_max];
d767 8
d782 1
a782 1
	xhv->xhv_placeholders++;
d789 1
a789 1
	xhv->xhv_keys++; /* HvKEYS(hv)++ */
d812 4
a815 1
    return entry;
d819 1
a819 1
S_hv_magic_check(pTHX_ HV *hv, bool *needs_copy, bool *needs_store)
a872 19
=cut
*/

SV *
Perl_hv_delete(pTHX_ HV *hv, const char *key, I32 klen_i32, I32 flags)
{
    STRLEN klen;
    int k_flags = 0;

    if (klen_i32 < 0) {
	klen = -klen_i32;
	k_flags |= HVhek_UTF8;
    } else {
	klen = klen_i32;
    }
    return hv_delete_common(hv, NULL, key, klen, k_flags, flags, 0);
}

/*
a882 6
SV *
Perl_hv_delete_ent(pTHX_ HV *hv, SV *keysv, I32 flags, U32 hash)
{
    return hv_delete_common(hv, keysv, NULL, 0, 0, flags, hash);
}

d887 1
d892 1
a892 2
    SV *sv;
    bool is_utf8;
a894 13
    if (!hv)
	return Nullsv;

    if (keysv) {
	if (k_flags & HVhek_FREEKEY)
	    Safefree(key);
	key = SvPV_const(keysv, klen);
	k_flags = 0;
	is_utf8 = (SvUTF8(keysv) != 0);
    } else {
	is_utf8 = ((k_flags & HVhek_UTF8) ? TRUE : FALSE);
    }

d901 5
a905 3
	    entry = hv_fetch_common(hv, keysv, key, klen,
				    k_flags & ~HVhek_FREEKEY, HV_FETCH_LVALUE,
				    Nullsv, hash);
d917 1
a917 1
		    return Nullsv;		/* element cannot be deleted */
d936 2
a937 2
    if (!xhv->xhv_array /* !HvARRAY(hv) */)
	return Nullsv;
d940 1
a940 1
	const char *keysave = key;
a960 2
	/* Not enough shared hash key scalars around to make this worthwhile
	   (about 4% slowdown in perlbench with this in)
d963 1
a963 3
        } else
	*/
	{
d970 1
a970 2
    /* oentry = &(HvARRAY(hv))[hash & (I32) HvMAX(hv)]; */
    first_entry = oentry = &((HE**)xhv->xhv_array)[hash & (I32) xhv->xhv_max];
d973 1
d983 6
d990 4
a993 5
	if (HeVAL(entry) == &PL_sv_placeholder)
	{
	  if (k_flags & HVhek_FREEKEY)
            Safefree(key);
	  return Nullsv;
d995 2
a996 2
	else if (SvREADONLY(hv) && HeVAL(entry) && SvREADONLY(HeVAL(entry))) {
	    S_hv_notallowed(aTHX_ k_flags, key, klen,
d1004 1
a1004 1
	    sv = Nullsv;
d1021 1
a1021 1
	    xhv->xhv_placeholders++; /* HvPLACEHOLDERS(hv)++ */
d1027 1
a1027 1
	    if (entry == xhv->xhv_eiter /* HvEITER(hv) */)
d1031 1
a1031 1
	    xhv->xhv_keys--; /* HvKEYS(hv)-- */
d1038 1
a1038 1
        S_hv_notallowed(aTHX_ k_flags, key, klen,
d1045 1
a1045 1
    return Nullsv;
d1051 2
a1052 1
    register XPVHV* xhv = (XPVHV*)SvANY(hv);
d1056 1
a1056 1
    register char *a = xhv->xhv_array; /* HvARRAY(hv) */
d1063 1
a1063 1
      hv, (int) oldsize);*/
d1075 2
a1076 1
    Renew(a, PERL_HV_ARRAY_ALLOC_BYTES(newsize), char);
d1081 3
d1085 2
a1086 1
    Newx(a, PERL_HV_ARRAY_ALLOC_BYTES(newsize), char);
d1091 4
a1094 1
    Copy(xhv->xhv_array /* HvARRAY(hv) */, a, oldsize * sizeof(HE*), char);
d1096 3
a1098 2
	offer_nice_chunk(xhv->xhv_array /* HvARRAY(hv) */,
			PERL_HV_ARRAY_ALLOC_BYTES(oldsize));
d1101 1
a1101 1
	Safefree(xhv->xhv_array /* HvARRAY(hv) */);
d1107 1
a1107 1
    xhv->xhv_array = a;		/* HvARRAY(hv) = a */
d1159 1
a1159 1
    /*PerlIO_printf(PerlIO_stderr(), "%p %d of %d with %d/%d buckets\n", hv,
d1163 6
a1168 1
    Newxz(a, PERL_HV_ARRAY_ALLOC_BYTES(newsize), char);
d1175 1
a1175 1
    aep = (HE **) xhv->xhv_array;
d1214 2
a1215 2
    Safefree (xhv->xhv_array);
    xhv->xhv_array = a;		/* HvARRAY(hv) = a */
d1221 1
d1242 1
a1242 1
    a = xhv->xhv_array; /* HvARRAY(hv) */
d1246 2
a1247 1
	Renew(a, PERL_HV_ARRAY_ALLOC_BYTES(newsize), char);
d1252 3
d1256 2
a1257 1
	Newx(a, PERL_HV_ARRAY_ALLOC_BYTES(newsize), char);
d1262 4
a1265 1
	Copy(xhv->xhv_array /* HvARRAY(hv) */, a, oldsize * sizeof(HE*), char);
d1267 3
a1269 2
	    offer_nice_chunk(xhv->xhv_array /* HvARRAY(hv) */,
			    PERL_HV_ARRAY_ALLOC_BYTES(oldsize));
d1272 1
a1272 1
	    Safefree(xhv->xhv_array /* HvARRAY(hv) */);
d1281 1
a1281 1
    xhv->xhv_array = a; 	/* HvARRAY(hv) = a */
d1290 3
a1292 2
	    register I32 j;
	    if ((j = (HeHASH(entry) & newsize)) != i) {
d1320 1
a1320 3
    HV * const hv = (HV*)NEWSV(502,0);

    sv_upgrade((SV *)hv, SVt_PVHV);
d1322 1
a1322 2
    SvPOK_off(hv);
    SvNOK_off(hv);
a1328 2
    xhv->xhv_pmroot = 0;	/* HvPMROOT(hv) = 0 */
    (void)hv_iterinit(hv);	/* so each() will start off right */
d1353 1
a1353 1
	    HE *prev = NULL, *ent = NULL;
d1367 1
a1368 1
		ent = new_HE();
d1400 3
a1402 3
	    hv_store_flags(hv, HeKEY(entry), HeKLEN(entry),
                           newSVsv(HeVAL(entry)), HeHASH(entry),
                           HeKFLAGS(entry));
d1411 33
d1447 1
d1453 2
a1454 2
    if (val && isGV(val) && GvCVu(val) && HvNAME_get(hv))
	PL_sub_generation++;	/* may be deletion of method from stash */
d1470 1
d1492 1
d1497 2
d1501 1
a1501 1
    if (SvREADONLY(hv) && xhv->xhv_array != NULL) {
d1505 1
a1505 1
	    HE *entry = ((HE**)xhv->xhv_array)[i];
d1510 1
a1510 1
			SV* keysv = hv_iterkeysv(entry);
d1512 2
a1513 2
	"Attempt to delete readonly key '%"SVf"' from a restricted hash",
				   keysv);
d1517 1
a1517 1
		    xhv->xhv_placeholders++; /* HvPLACEHOLDERS(hv)++ */
d1525 3
a1527 4
    xhv->xhv_placeholders = 0; /* HvPLACEHOLDERS(hv) = 0 */
    if (xhv->xhv_array /* HvARRAY(hv) */)
	(void)memzero(xhv->xhv_array /* HvARRAY(hv) */,
		      (xhv->xhv_max+1 /* HvMAX(hv)+1 */) * sizeof(HE*));
d1535 5
a1539 1
    HvEITER_set(hv, NULL);
d1559 11
a1569 1
    I32 items = (I32)HvPLACEHOLDERS_get(hv);
d1578 1
a1578 1
	bool first = 1;
d1580 1
a1580 4
	HE *entry = *oentry;

	if (!entry)
	    continue;
d1582 1
a1582 1
	for (; entry; entry = *oentry) {
d1602 1
a1602 1
		first = 0;
d1614 4
a1617 4
    register HE **array;
    register HE *entry;
    I32 riter;
    I32 max;
d1619 2
d1622 4
a1625 2
    if (!HvARRAY(hv))
	return;
d1627 4
a1630 21
    riter = 0;
    max = HvMAX(hv);
    array = HvARRAY(hv);
    /* make everyone else think the array is empty, so that the destructors
     * called for freed entries can't recusively mess with us */
    HvARRAY(hv) = Null(HE**); 
    HvFILL(hv) = 0;
    ((XPVHV*) SvANY(hv))->xhv_keys = 0;

    entry = array[0];
    for (;;) {
	if (entry) {
	    register HE * const oentry = entry;
	    entry = HeNEXT(entry);
	    hv_free_ent(hv, oentry);
	}
	if (!entry) {
	    if (++riter > max)
		break;
	    entry = array[riter];
	}
a1631 3
    HvARRAY(hv) = array;
    (void)hv_iterinit(hv);
}
d1633 11
a1643 2
/*
=for apidoc hv_undef
d1645 3
a1647 1
Undefines the hash.
d1649 18
a1666 2
=cut
*/
d1668 6
a1673 19
void
Perl_hv_undef(pTHX_ HV *hv)
{
    register XPVHV* xhv;
    const char *name;
    if (!hv)
	return;
    xhv = (XPVHV*)SvANY(hv);
    hfreeentries(hv);
    Safefree(xhv->xhv_array /* HvARRAY(hv) */);
    if ((name = HvNAME_get(hv))) {
	/* FIXME - strlen HvNAME  */
        if(PL_stashcache)
	    hv_delete(PL_stashcache, name, strlen(name), G_DISCARD);
	hv_name_set(hv, Nullch, 0, 0);
    }
    xhv->xhv_max   = 7;	/* HvMAX(hv) = 7 (it's a normal hash) */
    xhv->xhv_array = 0;	/* HvARRAY(hv) = 0 */
    xhv->xhv_placeholders = 0; /* HvPLACEHOLDERS(hv) = 0 */
d1675 144
a1818 3
    if (SvRMAGICAL(hv))
	mg_clear((SV*)hv);
}
a1837 3
    register XPVHV* xhv;
    HE *entry;

d1840 12
a1851 5
    xhv = (XPVHV*)SvANY(hv);
    entry = xhv->xhv_eiter; /* HvEITER(hv) */
    if (entry && HvLAZYDEL(hv)) {	/* was deleted earlier? */
	HvLAZYDEL_off(hv);
	hv_free_ent(hv, entry);
d1853 1
a1853 2
    xhv->xhv_riter = -1; 	/* HvRITER(hv) = -1 */
    xhv->xhv_eiter = Null(HE*); /* HvEITER(hv) = Null(HE*) */
d1857 110
d1968 2
a1981 10
=cut
*/

HE *
Perl_hv_iternext(pTHX_ HV *hv)
{
    return hv_iternext_flags(hv, 0);
}

/*
d1999 1
d2004 1
d2008 1
a2009 1
    oldentry = entry = xhv->xhv_eiter; /* HvEITER(hv) */
d2011 7
a2017 9
    if ((mg = SvTIED_mg((SV*)hv, PERL_MAGIC_tied))) {
	SV *key = sv_newmortal();
	if (entry) {
	    sv_setsv(key, HeSVKEY_force(entry));
	    SvREFCNT_dec(HeSVKEY(entry));	/* get rid of previous key */
	}
	else {
	    char *k;
	    HEK *hek;
d2019 33
a2051 20
	    /* one HE per MAGICAL hash */
	    xhv->xhv_eiter = entry = new_HE(); /* HvEITER(hv) = new_HE() */
	    Zero(entry, 1, HE);
	    Newxz(k, HEK_BASESIZE + sizeof(SV*), char);
	    hek = (HEK*)k;
	    HeKEY_hek(entry) = hek;
	    HeKLEN(entry) = HEf_SVKEY;
	}
	magic_nextpack((SV*) hv,mg,key);
	if (SvOK(key)) {
	    /* force key to stay around until next time */
	    HeSVKEY_set(entry, SvREFCNT_inc(key));
	    return entry;		/* beware, hent_val is not set */
	}
	if (HeVAL(entry))
	    SvREFCNT_dec(HeVAL(entry));
	Safefree(HeKEY_hek(entry));
	del_HE(entry);
	xhv->xhv_eiter = Null(HE*); /* HvEITER(hv) = Null(HE*) */
	return Null(HE*);
d2053 1
a2053 1
#ifdef DYNAMIC_ENV_FETCH  /* set up %ENV for iteration */
d2061 2
a2062 1
	oldentry = entry = xhv->xhv_eiter; /* HvEITER(hv) */
d2067 3
a2069 4
    if (!xhv->xhv_array /* !HvARRAY(hv) */)
	Newz(506, xhv->xhv_array /* HvARRAY(hv) */,
	     PERL_HV_ARRAY_ALLOC_BYTES(xhv->xhv_max+1 /* HvMAX(hv)+1 */),
	     char);
d2087 2
a2088 2
	xhv->xhv_riter++; /* HvRITER(hv)++ */
	if (xhv->xhv_riter > (I32)xhv->xhv_max /* HvRITER(hv) > HvMAX(hv) */) {
d2090 1
a2090 1
	    xhv->xhv_riter = -1; /* HvRITER(hv) = -1 */
d2093 1
a2093 2
	/* entry = (HvARRAY(hv))[HvRITER(hv)]; */
	entry = ((HE**)xhv->xhv_array)[xhv->xhv_riter];
d2112 1
a2112 1
      PerlIO_printf(PerlIO_stderr(), "Awooga %p %p\n", hv, entry);*/
d2114 1
a2114 1
    xhv->xhv_eiter = entry; /* HvEITER(hv) = entry */
d2132 1
a2132 1
	char *p = SvPV(HeKEY_sv(entry), len);
d2173 1
a2173 1
	    SV* sv = sv_newmortal();
d2196 3
a2198 2
    HE *he;
    if ( (he = hv_iternext_flags(hv, 0)) == NULL)
d2205 3
a2214 16
void
Perl_hv_magic(pTHX_ HV *hv, GV *gv, int how)
{
    sv_magic((SV*)hv, (SV*)gv, how, Nullch, 0);
}

#if 0 /* use the macro from hv.h instead */

char*	
Perl_sharepvn(pTHX_ const char *sv, I32 len, U32 hash)
{
    return HEK_KEY(share_hek(sv, len, hash));
}

#endif

d2228 1
d2237 1
a2237 1
S_unshare_hek_or_pvn(pTHX_ HEK *hek, const char *str, I32 len, U32 hash)
d2239 1
d2241 1
a2241 1
    register HE *entry;
a2243 1
    bool found = 0;
d2247 1
d2250 17
d2280 1
a2280 1
    /* what follows is the moral equivalent of:
d2282 1
a2282 1
	if (--*Svp == Nullsv)
d2288 3
a2290 3
    /* oentry = &(HvARRAY(hv))[hash & (I32) HvMAX(hv)]; */
    first = oentry = &((HE**)xhv->xhv_array)[hash & (I32) xhv->xhv_max];
    if (hek) {
d2292 2
a2293 4
            if (HeKEY_hek(entry) != hek)
                continue;
            found = 1;
            break;
a2305 1
            found = 1;
d2310 2
a2311 2
    if (found) {
        if (--HeVAL(entry) == Nullsv) {
d2317 2
a2318 3
            Safefree(HeKEY_hek(entry));
            del_HE(entry);
            xhv->xhv_keys--; /* HvKEYS(hv)-- */
d2323 1
a2323 1
    if (!found && ckWARN_d(WARN_INTERNAL))
d2367 1
a2367 1
    register XPVHV* xhv;
a2368 2
    register HE **oentry;
    I32 found = 0;
d2370 1
d2375 1
a2375 1
	hv_store(PL_strtab, str, len, Nullsv, hash);
d2380 1
a2380 1
    xhv = (XPVHV*)SvANY(PL_strtab);
d2383 2
a2384 3
    /* oentry = &(HvARRAY(hv))[hash & (I32) HvMAX(hv)]; */
    oentry = &((HE**)xhv->xhv_array)[hash & (I32) xhv->xhv_max];
    for (entry = *oentry; entry; entry = HeNEXT(entry)) {
a2392 1
	found = 1;
d2395 2
a2396 1
    if (!found) {
d2400 33
a2432 8
	const HE *old_first = *oentry;
	entry = new_HE();
	HeKEY_hek(entry) = save_hek_flags(str, len, hash, flags_masked);
	HeVAL(entry) = Nullsv;
	HeNEXT(entry) = *oentry;
	*oentry = entry;
	xhv->xhv_keys++; /* HvKEYS(hv)++ */
	if (!old_first) {			/* initial entry? */
d2439 1
a2439 1
    ++HeVAL(entry);				/* use value slot as REFCNT */
d2447 458
@


1.10
log
@sync in-tree perl with 5.8.6
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, by Larry Wall and others
d36 20
d62 1
a62 1
	more_he();
a77 20
STATIC void
S_more_he(pTHX)
{
    register HE* he;
    register HE* heend;
    XPV *ptr;
    New(54, ptr, 1008/sizeof(XPV), XPV);
    ptr->xpv_pv = (char*)PL_he_arenaroot;
    PL_he_arenaroot = ptr;

    he = (HE*)ptr;
    heend = &he[1008 / sizeof(HE) - 1];
    PL_he_root = ++he;
    while (he < heend) {
	HeNEXT(he) = (HE*)(he + 1);
	he++;
    }
    HeNEXT(he) = 0;
}

d93 1
a93 1
    int flags_masked = flags & HVhek_MASK;
d97 1
a97 1
    New(54, k, HEK_BASESIZE + len + 2, char);
d110 1
a110 1
/* free the pool of temporary HE/HEK pairs retunrned by hv_fetch_ent
a115 1
    HE *ohe;
d118 1
a119 1
	ohe = he;
d146 1
a146 1
	New(54, k, HEK_BASESIZE + sizeof(SV*), char);
d165 1
a165 1
    SV *sv = sv_newmortal(), *esv = sv_newmortal();
d177 1
a177 2
    Perl_sv_setpvf(aTHX_ esv, "Attempt to %s a restricted hash", msg);
    Perl_croak(aTHX_ SvPVX(esv), sv);
d237 1
a237 1
    HE *hek = hv_fetch_common (hv, NULL, key, klen, flags,
a384 1
    U32 n_links;
d397 1
a397 1
	key = SvPV(keysv, klen);
d431 1
a431 1
		    New(54, k, HEK_BASESIZE + sizeof(SV*), char);
d455 1
a455 1
			char *nkey = strupr(savepvn(key,klen));
a480 1
		SV* svret;
d483 1
a483 1
		svret = sv_newmortal();
d508 1
a508 1
		const char *keysave = key;
d528 1
a528 1
		bool save_taint = PL_tainted;	
d574 3
a576 2
								  )
	    Newz(503, xhv->xhv_array /* HvARRAY(hv) */,
d579 2
d597 1
a597 1
	const char *keysave = key;
d622 1
a622 1
            hash = SvUVX(keysv);
a630 1
    n_links = 0;
d640 3
a642 1
    for (; entry; ++n_links, entry = HeNEXT(entry)) {
d713 1
a713 1
	char *env = PerlEnv_ENVgetenv_len(key,&len);
d725 2
a726 2
			"access disallowed key '%"SVf"' in"
			);
d754 2
a755 1
	Newz(503, xhv->xhv_array /* HvARRAY(hv) */,
d758 1
d779 24
a802 12
    xhv->xhv_keys++; /* HvKEYS(hv)++ */
    if (!n_links) {				/* initial entry? */
	xhv->xhv_fill++; /* HvFILL(hv)++ */
    } else if ((xhv->xhv_keys > (IV)xhv->xhv_max)
	       || ((n_links > HV_MAX_LENGTH_BEFORE_SPLIT) && !HvREHASH(hv))) {
	/* Use only the old HvKEYS(hv) > HvMAX(hv) condition to limit bucket
	   splits on a rehashed hash, as we're not going to split it again,
	   and if someone is lucky (evil) enough to get all the keys in one
	   list they could exhaust our memory as we repeatedly double the
	   number of buckets on every entry. Linear search feels a less worse
	   thing to do.  */
        hsplit(hv);
d811 1
a811 1
    MAGIC *mg = SvMAGIC(hv);
d817 1
a817 3
	    switch (mg->mg_type) {
	    case PERL_MAGIC_tied:
	    case PERL_MAGIC_sig:
d819 1
a836 1
    MAGIC *mg;
d838 6
a843 5
    
    if ((SvRMAGICAL(hv) && (mg = mg_find((SV*)hv, PERL_MAGIC_tied)))) {
        sv = magic_scalarpack(hv, mg);
        return sv;
    } 
a902 1
    register I32 i;
d905 1
d916 1
a916 1
	key = SvPV(keysv, klen);
d966 2
a967 2
    const char *keysave = key;
    key = (char*)bytes_from_utf8((U8*)key, &klen, &is_utf8);
d990 1
a990 1
            hash = SvUVX(keysv);
d1001 1
a1001 1
    oentry = &((HE**)xhv->xhv_array)[hash & (I32) xhv->xhv_max];
d1003 1
a1003 2
    i = 1;
    for (; entry; i=0, oentry = &HeNEXT(entry), entry = *oentry) {
d1022 2
a1023 2
			    "delete readonly key '%"SVf"' from"
			    );
d1049 1
a1049 1
	    if (i && !*oentry)
d1051 1
d1064 2
a1065 2
			"delete disallowed key '%"SVf"' from"
			);
d1077 1
a1077 1
    I32 oldsize = (I32) xhv->xhv_max+1; /* HvMAX(hv)+1 (sick) */
a1081 2
    register HE **bep;
    register HE *entry;
d1089 1
a1089 1
    if (HvPLACEHOLDERS(hv) && !SvREADONLY(hv)) {
d1105 1
a1105 1
    New(2, a, PERL_HV_ARRAY_ALLOC_BYTES(newsize), char);
d1128 2
d1178 1
a1178 1
    Newz(2, a, PERL_HV_ARRAY_ALLOC_BYTES(newsize), char);
d1188 1
a1188 1
	entry = *aep;
d1192 1
a1192 1
	    HE *next = HeNEXT(entry);
d1194 1
d1201 1
a1201 1
		HEK *new_hek
d1232 1
a1232 1
    I32 oldsize = (I32) xhv->xhv_max+1; /* HvMAX(hv)+1 (sick) */
a1234 1
    register I32 j;
d1261 1
a1261 1
	New(2, a, PERL_HV_ARRAY_ALLOC_BYTES(newsize), char);
d1278 1
a1278 1
	Newz(0, a, PERL_HV_ARRAY_ALLOC_BYTES(newsize), char);
d1290 1
a1317 1
    register HV *hv;
d1319 1
a1320 1
    hv = (HV*)NEWSV(502,0);
d1339 1
a1339 1
    HV *hv = newHV();
d1349 2
a1350 2
	bool shared = !!HvSHAREKEYS(ohv);
	HE **ents, **oents = (HE **)HvARRAY(ohv);
d1352 1
a1352 1
	New(0, a, PERL_HV_ARRAY_ALLOC_BYTES(hv_max+1), char);
d1357 2
a1358 1
	    HE *prev = NULL, *ent = NULL, *oent = oents[i];
d1366 5
a1370 5
	    for (oent = oents[i]; oent; oent = HeNEXT(oent)) {
		U32 hash   = HeHASH(oent);
		char *key  = HeKEY(oent);
		STRLEN len = HeKLEN(oent);
                int flags  = HeKFLAGS(oent);
d1390 1
a1390 1
    }
d1394 2
a1395 2
	I32 riter = HvRITER(ohv);
	HE *eiter = HvEITER(ohv);
d1408 2
a1409 2
	HvRITER(ohv) = riter;
	HvEITER(ohv) = eiter;
d1423 1
a1423 1
    if (val && isGV(val) && GvCVu(val) && HvNAME(hv))
d1442 2
a1443 3
    if (isGV(HeVAL(entry)) && GvCVu(HeVAL(entry)) && HvNAME(hv))
	PL_sub_generation++;	/* may be deletion of method from stash */
    sv_2mortal(HeVAL(entry));	/* free between statements */
d1445 1
a1445 2
	sv_2mortal(HeKEY_sv(entry));
	Safefree(HeKEY_hek(entry));
d1447 1
a1447 5
    else if (HvSHAREKEYS(hv))
	unshare_hek(HeKEY_hek(entry));
    else
	Safefree(HeKEY_hek(entry));
    del_HE(entry);
d1469 3
a1471 4
	I32 i;
	HE* entry;
	for (i = 0; i <= (I32) xhv->xhv_max; i++) {
	    entry = ((HE**)xhv->xhv_array)[i];
d1502 1
a1502 1
    HvEITER(hv) = NULL;
d1522 2
a1523 2
    I32 items = (I32)HvPLACEHOLDERS(hv);
    I32 i = HvMAX(hv);
d1528 1
d1531 1
a1531 1
	int first = 1;
d1543 1
a1543 1
		if (HvEITER(hv))
d1550 1
a1550 1
		    HvTOTALKEYS(hv) -= HvPLACEHOLDERS(hv);
d1553 1
a1553 1
		    HvPLACEHOLDERS(hv) = 0;
a1571 1
    register HE *oentry = Null(HE*);
d1575 1
a1575 2
    if (!hv)
	return;
d1591 1
a1591 1
	    oentry = entry;
d1617 1
d1623 2
a1624 1
    if (HvNAME(hv)) {
d1626 2
a1627 3
	    hv_delete(PL_stashcache, HvNAME(hv), strlen(HvNAME(hv)), G_DISCARD);
	Safefree(HvNAME(hv));
	HvNAME(hv) = 0;
d1669 1
a1669 1
    return XHvTOTALKEYS(xhv);
d1734 1
a1734 1
	    Newz(54, k, HEK_BASESIZE + sizeof(SV*), char);
d1753 1
a1753 1
    if (!entry && SvRMAGICAL((SV*)hv) && mg_find((SV*)hv, PERL_MAGIC_env))
d1755 8
d1856 1
a1856 33
    if (HeKLEN(entry) != HEf_SVKEY) {
        HEK *hek = HeKEY_hek(entry);
        int flags = HEK_FLAGS(hek);
        SV *sv;

        if (flags & HVhek_WASUTF8) {
            /* Trouble :-)
               Andreas would like keys he put in as utf8 to come back as utf8
            */
            STRLEN utf8_len = HEK_LEN(hek);
            U8 *as_utf8 = bytes_to_utf8 ((U8*)HEK_KEY(hek), &utf8_len);

            sv = newSVpvn ((char*)as_utf8, utf8_len);
            SvUTF8_on (sv);
	    Safefree (as_utf8); /* bytes_to_utf8() allocates a new string */
	} else if (flags & HVhek_REHASH) {
	    /* We don't have a pointer to the hv, so we have to replicate the
	       flag into every HEK. This hv is using custom a hasing
	       algorithm. Hence we can't return a shared string scalar, as
	       that would contain the (wrong) hash value, and might get passed
	       into an hv routine with a regular hash  */

            sv = newSVpvn (HEK_KEY(hek), HEK_LEN(hek));
	    if (HEK_UTF8(hek))
		SvUTF8_on (sv);
	} else {
            sv = newSVpvn_share(HEK_KEY(hek),
                                (HEK_UTF8(hek) ? -HEK_LEN(hek) : HEK_LEN(hek)),
                                HEK_HASH(hek));
        }
        return sv_2mortal(sv);
    }
    return sv_mortalcopy(HeKEY_sv(entry));
d1876 2
a1877 1
	    else mg_copy((SV*)hv, sv, HeKEY(entry), HeKLEN(entry));
d1953 2
a1954 2
    register I32 i = 1;
    I32 found = 0;
d1957 1
a1957 1
    const char *save = str;
d1982 1
a1982 1
    oentry = &((HE**)xhv->xhv_array)[hash & (I32) xhv->xhv_max];
d1984 1
a1984 1
        for (entry = *oentry; entry; i=0, oentry = &HeNEXT(entry), entry = *oentry) {
d1991 2
a1992 2
        int flags_masked = k_flags & HVhek_MASK;
        for (entry = *oentry; entry; i=0, oentry = &HeNEXT(entry), entry = *oentry) {
d2009 2
a2010 1
            if (i && !*oentry)
d2012 1
d2039 1
a2039 1
    const char *save = str;
a2066 1
    register I32 i = 1;
d2068 1
a2068 1
    int flags_masked = flags & HVhek_MASK;
d2083 1
a2083 1
    for (entry = *oentry; entry; i=0, entry = HeNEXT(entry)) {
d2096 4
d2106 1
a2106 1
	if (i) {				/* initial entry? */
d2121 10
@


1.9
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d17 10
d231 1
a231 1
			   (HV_FETCH_ISSTORE|HV_FETCH_JUST_SV), val, 0);
d518 1
d561 1
d1505 1
a1505 1
but will still allow the hash to have a value reaasigned to the key at some
@


1.8
log
@merge local changes into perl-5.8.3
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, by Larry Wall and others
d372 1
a372 1
HE *
d873 1
a873 1
SV *
a987 2
        if (k_flags & HVhek_FREEKEY)
            Safefree(key);
d992 3
a994 16
	    if (SvREADONLY(hv))
		return Nullsv; /* if still SvREADONLY, leave it deleted. */

           /* okay, really delete the placeholder. */
           *oentry = HeNEXT(entry);
           if (i && !*oentry)
               xhv->xhv_fill--; /* HvFILL(hv)-- */
           if (entry == xhv->xhv_eiter /* HvEITER(hv) */)
               HvLAZYDEL_on(hv);
           else
               hv_free_ent(hv, entry);
           xhv->xhv_keys--; /* HvKEYS(hv)-- */
	   if (xhv->xhv_keys == 0)
               HvHASKFLAGS_off(hv);
           xhv->xhv_placeholders--;
           return Nullsv;
d1001 2
d1018 1
d1063 11
d1503 11
a1513 28
    I32 items;
    items = (I32)HvPLACEHOLDERS(hv);
    if (items) {
        HE *entry;
        I32 riter = HvRITER(hv);
        HE *eiter = HvEITER(hv);
        hv_iterinit(hv);
        /* This may look suboptimal with the items *after* the iternext, but
           it's quite deliberate. We only get here with items==0 if we've
           just deleted the last placeholder in the hash. If we've just done
           that then it means that the hash is in lazy delete mode, and the
           HE is now only referenced in our iterator. If we just quit the loop
           and discarded our iterator then the HE leaks. So we do the && the
           other way to ensure iternext is called just one more time, which
           has the side effect of triggering the lazy delete.  */
        while ((entry = hv_iternext_flags(hv, HV_ITERNEXT_WANTPLACEHOLDERS))
            && items) {
            SV *val = hv_iterval(hv, entry);

            if (val == &PL_sv_placeholder) {

                /* It seems that I have to go back in the front of the hash
                   API to delete a hash, even though I have a HE structure
                   pointing to the very entry I want to delete, and could hold
                   onto the previous HE that points to it. And it's easier to
                   go in with SVs as I can then specify the precomputed hash,
                   and don't have fun and games with utf8 keys.  */
                SV *key = hv_iterkeysv(entry);
d1515 30
a1544 7
                hv_delete_ent (hv, key, G_DISCARD, HeHASH(entry));
                items--;
            }
        }
        HvRITER(hv) = riter;
        HvEITER(hv) = eiter;
    }
d2024 2
a2025 1
                    "Attempt to free non-existent shared string '%s'%s",
d2027 1
a2027 1
                    (k_flags & HVhek_UTF8) ? " (utf8)" : "");
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d83 1
d93 4
a96 1
    HEK_FLAGS(hek) = (unsigned char)flags;
d175 5
d181 1
a181 1
=for apidoc hv_fetch
d183 16
a198 4
Returns the SV which corresponds to the specified key in the hash.  The
C<klen> is the length of the key.  If C<lval> is set then the fetch will be
part of a store.  Check that the return value is non-null before
dereferencing it to an C<SV*>.
d206 18
d226 2
a227 1
Perl_hv_fetch(pTHX_ HV *hv, const char *key, I32 klen, I32 lval)
d229 27
a255 3
    bool is_utf8 = FALSE;
    const char *keysave = key;
    int flags = 0;
d257 2
a258 4
    if (klen < 0) {
      klen = -klen;
      is_utf8 = TRUE;
    }
d260 2
a261 15
    if (is_utf8) {
	STRLEN tmplen = klen;
	/* Just casting the &klen to (STRLEN) won't work well
	 * if STRLEN and I32 are of different widths. --jhi */
	key = (char*)bytes_from_utf8((U8*)key, &tmplen, &is_utf8);
	klen = tmplen;
        /* If we were able to downgrade here, then than means that we were
           passed in a key which only had chars 0-255, but was utf8 encoded.  */
        if (is_utf8)
            flags = HVhek_UTF8;
        /* If we found we were able to downgrade the string to bytes, then
           we should flag that it needs upgrading on keys or each.  */
        if (key != keysave)
            flags |= HVhek_WASUTF8 | HVhek_FREEKEY;
    }
d263 4
a266 1
    return hv_fetch_flags (hv, key, klen, lval, flags);
d269 11
a279 2
STATIC SV**
S_hv_fetch_flags(pTHX_ HV *hv, const char *key, I32 klen, I32 lval, int flags)
d281 21
a301 4
    register XPVHV* xhv;
    register U32 hash;
    register HE *entry;
    SV *sv;
d303 2
a304 2
    if (!hv)
	return 0;
d306 2
a307 33
    if (SvRMAGICAL(hv)) {
        /* All this clause seems to be utf8 unaware.
           By moving the utf8 stuff out to hv_fetch_flags I need to ensure
           key doesn't leak. I've not tried solving the utf8-ness.
           NWC.
        */
	if (mg_find((SV*)hv, PERL_MAGIC_tied) || SvGMAGICAL((SV*)hv)) {
	    sv = sv_newmortal();
	    sv_upgrade(sv, SVt_PVLV);
	    mg_copy((SV*)hv, sv, key, klen);
            if (flags & HVhek_FREEKEY)
                Safefree(key);
	    LvTYPE(sv) = 't';
	    LvTARG(sv) = sv; /* fake (SV**) */
	    return &(LvTARG(sv));
	}
#ifdef ENV_IS_CASELESS
	else if (mg_find((SV*)hv, PERL_MAGIC_env)) {
	    I32 i;
	    for (i = 0; i < klen; ++i)
		if (isLOWER(key[i])) {
		    char *nkey = strupr(SvPVX(sv_2mortal(newSVpvn(key,klen))));
		    SV **ret = hv_fetch(hv, nkey, klen, 0);
		    if (!ret && lval) {
			ret = hv_store_flags(hv, key, klen, NEWSV(61,0), 0,
                                             flags);
                    } else if (flags & HVhek_FREEKEY)
                        Safefree(key);
		    return ret;
		}
	}
#endif
    }
d309 6
a314 18
    /* We use xhv->xhv_foo fields directly instead of HvFOO(hv) to
       avoid unnecessary pointer dereferencing. */
    xhv = (XPVHV*)SvANY(hv);
    if (!xhv->xhv_array /* !HvARRAY(hv) */) {
	if (lval
#ifdef DYNAMIC_ENV_FETCH  /* if it's an %ENV lookup, we may get it on the fly */
		 || (SvRMAGICAL((SV*)hv) && mg_find((SV*)hv, PERL_MAGIC_env))
#endif
								  )
	    Newz(503, xhv->xhv_array /* HvARRAY(hv) */,
		 PERL_HV_ARRAY_ALLOC_BYTES(xhv->xhv_max+1 /* HvMAX(hv)+1 */),
		 char);
	else {
            if (flags & HVhek_FREEKEY)
                Safefree(key);
	    return 0;
        }
    }
d316 3
a318 6
    if (HvREHASH(hv)) {
	PERL_HASH_INTERNAL(hash, key, klen);
	/* Yes, you do need this even though you are not "storing" because
	   you can flip the flags below if doing an lval lookup.  (And that
	   was put in to give the semantics Andreas was expecting.)  */
	flags |= HVhek_REHASH;
d320 2
a321 1
	PERL_HASH(hash, key, klen);
d323 8
d332 6
a337 39
    /* entry = (HvARRAY(hv))[hash & (I32) HvMAX(hv)]; */
    entry = ((HE**)xhv->xhv_array)[hash & (I32) xhv->xhv_max];
    for (; entry; entry = HeNEXT(entry)) {
	if (HeHASH(entry) != hash)		/* strings can't be equal */
	    continue;
	if (HeKLEN(entry) != (I32)klen)
	    continue;
	if (HeKEY(entry) != key && memNE(HeKEY(entry),key,klen))	/* is this it? */
	    continue;
        /* flags is 0 if not utf8. need HeKFLAGS(entry) also 0.
           flags is 1 if utf8. need HeKFLAGS(entry) also 1.
           xor is true if bits differ, in which case this isn't a match.  */
	if ((HeKFLAGS(entry) ^ flags) & HVhek_UTF8)
	    continue;
        if (lval && HeKFLAGS(entry) != flags) {
            /* We match if HVhek_UTF8 bit in our flags and hash key's match.
               But if entry was set previously with HVhek_WASUTF8 and key now
               doesn't (or vice versa) then we should change the key's flag,
               as this is assignment.  */
            if (HvSHAREKEYS(hv)) {
                /* Need to swap the key we have for a key with the flags we
                   need. As keys are shared we can't just write to the flag,
                   so we share the new one, unshare the old one.  */
                int flags_nofree = flags & ~HVhek_FREEKEY;
                HEK *new_hek = share_hek_flags(key, klen, hash, flags_nofree);
                unshare_hek (HeKEY_hek(entry));
                HeKEY_hek(entry) = new_hek;
            }
            else
                HeKFLAGS(entry) = flags;
            if (flags & HVhek_ENABLEHVKFLAGS)
                HvHASKFLAGS_on(hv);
        }
        if (flags & HVhek_FREEKEY)
            Safefree(key);
	/* if we find a placeholder, we pretend we haven't found anything */
	if (HeVAL(entry) == &PL_sv_placeholder)
	    break;
	return &HeVAL(entry);
d339 5
a343 26
    }
#ifdef DYNAMIC_ENV_FETCH  /* %ENV lookup?  If so, try to fetch the value now */
    if (SvRMAGICAL((SV*)hv) && mg_find((SV*)hv, PERL_MAGIC_env)) {
	unsigned long len;
	char *env = PerlEnv_ENVgetenv_len(key,&len);
	if (env) {
	    sv = newSVpvn(env,len);
	    SvTAINTED_on(sv);
	    if (flags & HVhek_FREEKEY)
		Safefree(key);
	    return hv_store(hv,key,klen,sv,hash);
	}
    }
#endif
    if (!entry && SvREADONLY(hv)) {
	S_hv_notallowed(aTHX_ flags, key, klen,
			"access disallowed key '%"SVf"' in"
			);
    }
    if (lval) {		/* gonna assign to this, so it better be there */
	sv = NEWSV(61,0);
        return hv_store_flags(hv,key,klen,sv,hash,flags);
    }
    if (flags & HVhek_FREEKEY)
        Safefree(key);
    return 0;
d368 12
a379 4
    register XPVHV* xhv;
    register char *key;
    STRLEN klen;
    register HE *entry;
d382 1
a382 2
    int flags = 0;
    char *keysave;
d387 126
a512 14
    if (SvRMAGICAL(hv)) {
	if (mg_find((SV*)hv, PERL_MAGIC_tied) || SvGMAGICAL((SV*)hv)) {
	    sv = sv_newmortal();
	    keysv = newSVsv(keysv);
	    mg_copy((SV*)hv, sv, (char*)keysv, HEf_SVKEY);
	    /* grab a fake HE/HEK pair from the pool or make a new one */
	    entry = PL_hv_fetch_ent_mh;
	    if (entry)
		PL_hv_fetch_ent_mh = HeNEXT(entry);
	    else {
		char *k;
		entry = new_HE();
		New(54, k, HEK_BASESIZE + sizeof(SV*), char);
		HeKEY_hek(entry) = (HEK*)k;
d514 27
a540 8
	    HeNEXT(entry) = Nullhe;
	    HeSVKEY_set(entry, keysv);
	    HeVAL(entry) = sv;
	    sv_upgrade(sv, SVt_PVLV);
	    LvTYPE(sv) = 'T';
	    LvTARG(sv) = (SV*)entry; /* so we can free entry when freeing sv */
	    return entry;
 	}
d542 13
a554 11
	else if (mg_find((SV*)hv, PERL_MAGIC_env)) {
	    U32 i;
	    key = SvPV(keysv, klen);
	    for (i = 0; i < klen; ++i)
		if (isLOWER(key[i])) {
		    SV *nkeysv = sv_2mortal(newSVpvn(key,klen));
		    (void)strupr(SvPVX(nkeysv));
		    entry = hv_fetch_ent(hv, nkeysv, 0, 0);
		    if (!entry && lval)
			entry = hv_store_ent(hv, keysv, NEWSV(61,0), hash);
		    return entry;
a555 1
	}
d557 3
a559 1
    }
a560 2
    keysave = key = SvPV(keysv, klen);
    xhv = (XPVHV*)SvANY(hv);
d562 1
a562 1
	if (lval
d570 11
a580 1
	else
d582 1
a584 2
    is_utf8 = (SvUTF8(keysv)!=0);

d586 1
d589 6
a594 2
            flags = HVhek_UTF8;
        if (key != keysave)
d596 1
d601 3
a603 1
	/* Yes, you do need this even though you are not "storing" because
d608 9
a616 1
	PERL_HASH(hash, key, klen);
d619 12
a630 3
    /* entry = (HvARRAY(hv))[hash & (I32) HvMAX(hv)]; */
    entry = ((HE**)xhv->xhv_array)[hash & (I32) xhv->xhv_max];
    for (; entry; entry = HeNEXT(entry)) {
d637 1
a637 1
	if ((HeKFLAGS(entry) ^ flags) & HVhek_UTF8)
d639 55
a693 20
        if (lval && HeKFLAGS(entry) != flags) {
            /* We match if HVhek_UTF8 bit in our flags and hash key's match.
               But if entry was set previously with HVhek_WASUTF8 and key now
               doesn't (or vice versa) then we should change the key's flag,
               as this is assignment.  */
            if (HvSHAREKEYS(hv)) {
                /* Need to swap the key we have for a key with the flags we
                   need. As keys are shared we can't just write to the flag,
                   so we share the new one, unshare the old one.  */
                int flags_nofree = flags & ~HVhek_FREEKEY;
                HEK *new_hek = share_hek_flags(key, klen, hash, flags_nofree);
                unshare_hek (HeKEY_hek(entry));
                HeKEY_hek(entry) = new_hek;
            }
            else
                HeKFLAGS(entry) = flags;
            if (flags & HVhek_ENABLEHVKFLAGS)
                HvHASKFLAGS_on(hv);
        }
	if (key != keysave)
a694 3
	/* if we find a placeholder, we pretend we haven't found anything */
	if (HeVAL(entry) == &PL_sv_placeholder)
	    break;
d698 2
a699 1
    if (SvRMAGICAL((SV*)hv) && mg_find((SV*)hv, PERL_MAGIC_env)) {
d705 2
a706 1
	    return hv_store_ent(hv,keysv,sv,hash);
d710 2
a711 1
    if (!entry && SvREADONLY(hv)) {
d716 5
a720 80
    if (flags & HVhek_FREEKEY)
	Safefree(key);
    if (lval) {		/* gonna assign to this, so it better be there */
	sv = NEWSV(61,0);
	return hv_store_ent(hv,keysv,sv,hash);
    }
    return 0;
}

STATIC void
S_hv_magic_check(pTHX_ HV *hv, bool *needs_copy, bool *needs_store)
{
    MAGIC *mg = SvMAGIC(hv);
    *needs_copy = FALSE;
    *needs_store = TRUE;
    while (mg) {
	if (isUPPER(mg->mg_type)) {
	    *needs_copy = TRUE;
	    switch (mg->mg_type) {
	    case PERL_MAGIC_tied:
	    case PERL_MAGIC_sig:
		*needs_store = FALSE;
	    }
	}
	mg = mg->mg_moremagic;
    }
}

/*
=for apidoc hv_store

Stores an SV in a hash.  The hash key is specified as C<key> and C<klen> is
the length of the key.  The C<hash> parameter is the precomputed hash
value; if it is zero then Perl will compute it.  The return value will be
NULL if the operation failed or if the value did not need to be actually
stored within the hash (as in the case of tied hashes).  Otherwise it can
be dereferenced to get the original C<SV*>.  Note that the caller is
responsible for suitably incrementing the reference count of C<val> before
the call, and decrementing it if the function returned NULL.  Effectively
a successful hv_store takes ownership of one reference to C<val>.  This is
usually what you want; a newly created SV has a reference count of one, so
if all your code does is create SVs then store them in a hash, hv_store
will own the only reference to the new SV, and your code doesn't need to do
anything further to tidy up.  hv_store is not implemented as a call to
hv_store_ent, and does not create a temporary SV for the key, so if your
key data is not already in SV form then use hv_store in preference to
hv_store_ent.

See L<perlguts/"Understanding the Magic of Tied Hashes and Arrays"> for more
information on how to use this function on tied hashes.

=cut
*/

SV**
Perl_hv_store(pTHX_ HV *hv, const char *key, I32 klen, SV *val, U32 hash)
{
    bool is_utf8 = FALSE;
    const char *keysave = key;
    int flags = 0;

    if (klen < 0) {
      klen = -klen;
      is_utf8 = TRUE;
    }

    if (is_utf8) {
	STRLEN tmplen = klen;
	/* Just casting the &klen to (STRLEN) won't work well
	 * if STRLEN and I32 are of different widths. --jhi */
	key = (char*)bytes_from_utf8((U8*)key, &tmplen, &is_utf8);
	klen = tmplen;
        /* If we were able to downgrade here, then than means that we were
           passed in a key which only had chars 0-255, but was utf8 encoded.  */
        if (is_utf8)
            flags = HVhek_UTF8;
        /* If we found we were able to downgrade the string to bytes, then
           we should flag that it needs upgrading on keys or each.  */
        if (key != keysave)
            flags |= HVhek_WASUTF8 | HVhek_FREEKEY;
d722 11
a732 35

    return hv_store_flags (hv, key, klen, val, hash, flags);
}

SV**
Perl_hv_store_flags(pTHX_ HV *hv, const char *key, I32 klen, SV *val,
                 register U32 hash, int flags)
{
    register XPVHV* xhv;
    register U32 n_links;
    register HE *entry;
    register HE **oentry;

    if (!hv)
	return 0;

    xhv = (XPVHV*)SvANY(hv);
    if (SvMAGICAL(hv)) {
	bool needs_copy;
	bool needs_store;
	hv_magic_check (hv, &needs_copy, &needs_store);
	if (needs_copy) {
	    mg_copy((SV*)hv, val, key, klen);
	    if (!xhv->xhv_array /* !HvARRAY */ && !needs_store) {
                if (flags & HVhek_FREEKEY)
                    Safefree(key);
		return 0;
            }
#ifdef ENV_IS_CASELESS
	    else if (mg_find((SV*)hv, PERL_MAGIC_env)) {
		key = savepvn(key,klen);
		key = (const char*)strupr((char*)key);
		hash = 0;
	    }
#endif
d736 7
a742 13
    if (flags)
        HvHASKFLAGS_on((SV*)hv);

    if (HvREHASH(hv)) {
	/* We don't have a pointer to the hv, so we have to replicate the
	   flag into every HEK, so that hv_iterkeysv can see it.  */
	flags |= HVhek_REHASH;
	PERL_HASH_INTERNAL(hash, key, klen);
    } else if (!hash)
	PERL_HASH(hash, key, klen);

    if (!xhv->xhv_array /* !HvARRAY(hv) */)
	Newz(505, xhv->xhv_array /* HvARRAY(hv) */,
d745 1
a746 1
    /* oentry = &(HvARRAY(hv))[hash & (I32) HvMAX(hv)]; */
a748 51
    n_links = 0;

    for (entry = *oentry; entry; ++n_links, entry = HeNEXT(entry)) {
	if (HeHASH(entry) != hash)		/* strings can't be equal */
	    continue;
	if (HeKLEN(entry) != (I32)klen)
	    continue;
	if (HeKEY(entry) != key && memNE(HeKEY(entry),key,klen))	/* is this it? */
	    continue;
	if ((HeKFLAGS(entry) ^ flags) & HVhek_UTF8)
	    continue;
	if (HeVAL(entry) == &PL_sv_placeholder)
	    xhv->xhv_placeholders--; /* yes, can store into placeholder slot */
	else
	    SvREFCNT_dec(HeVAL(entry));
        if (flags & HVhek_PLACEHOLD) {
            /* We have been requested to insert a placeholder. Currently
               only Storable is allowed to do this.  */
            xhv->xhv_placeholders++;
            HeVAL(entry) = &PL_sv_placeholder;
        } else
            HeVAL(entry) = val;

        if (HeKFLAGS(entry) != flags) {
            /* We match if HVhek_UTF8 bit in our flags and hash key's match.
               But if entry was set previously with HVhek_WASUTF8 and key now
               doesn't (or vice versa) then we should change the key's flag,
               as this is assignment.  */
            if (HvSHAREKEYS(hv)) {
                /* Need to swap the key we have for a key with the flags we
                   need. As keys are shared we can't just write to the flag,
                   so we share the new one, unshare the old one.  */
                int flags_nofree = flags & ~HVhek_FREEKEY;
                HEK *new_hek = share_hek_flags(key, klen, hash, flags_nofree);
                unshare_hek (HeKEY_hek(entry));
                HeKEY_hek(entry) = new_hek;
            }
            else
                HeKFLAGS(entry) = flags;
        }
        if (flags & HVhek_FREEKEY)
            Safefree(key);
	return &HeVAL(entry);
    }

    if (SvREADONLY(hv)) {
	S_hv_notallowed(aTHX_ flags, key, klen,
			"access disallowed key '%"SVf"' to"
			);
    }

d756 1
a756 7
    if (flags & HVhek_PLACEHOLD) {
        /* We have been requested to insert a placeholder. Currently
           only Storable is allowed to do this.  */
        xhv->xhv_placeholders++;
        HeVAL(entry) = &PL_sv_placeholder;
    } else
        HeVAL(entry) = val;
d760 5
d770 1
a770 1
	/* Use the old HvKEYS(hv) > HvMAX(hv) condition to limit bucket
d779 1
a779 1
    return &HeVAL(entry);
d782 2
a783 31
/*
=for apidoc hv_store_ent

Stores C<val> in a hash.  The hash key is specified as C<key>.  The C<hash>
parameter is the precomputed hash value; if it is zero then Perl will
compute it.  The return value is the new hash entry so created.  It will be
NULL if the operation failed or if the value did not need to be actually
stored within the hash (as in the case of tied hashes).  Otherwise the
contents of the return value can be accessed using the C<He?> macros
described here.  Note that the caller is responsible for suitably
incrementing the reference count of C<val> before the call, and
decrementing it if the function returned NULL.  Effectively a successful
hv_store_ent takes ownership of one reference to C<val>.  This is
usually what you want; a newly created SV has a reference count of one, so
if all your code does is create SVs then store them in a hash, hv_store
will own the only reference to the new SV, and your code doesn't need to do
anything further to tidy up.  Note that hv_store_ent only reads the C<key>;
unlike C<val> it does not take ownership of it, so maintaining the correct
reference count on C<key> is entirely the caller's responsibility.  hv_store
is not implemented as a call to hv_store_ent, and does not create a temporary
SV for the key, so if your key data is not already in SV form then use
hv_store in preference to hv_store_ent.

See L<perlguts/"Understanding the Magic of Tied Hashes and Arrays"> for more
information on how to use this function on tied hashes.

=cut
*/

HE *
Perl_hv_store_ent(pTHX_ HV *hv, SV *keysv, SV *val, U32 hash)
d785 10
a794 33
    XPVHV* xhv;
    char *key;
    STRLEN klen;
    U32 n_links;
    HE *entry;
    HE **oentry;
    bool is_utf8;
    int flags = 0;
    char *keysave;

    if (!hv)
	return 0;

    xhv = (XPVHV*)SvANY(hv);
    if (SvMAGICAL(hv)) {
	bool needs_copy;
	bool needs_store;
	hv_magic_check (hv, &needs_copy, &needs_store);
	if (needs_copy) {
	    bool save_taint = PL_tainted;
	    if (PL_tainting)
		PL_tainted = SvTAINTED(keysv);
	    keysv = sv_2mortal(newSVsv(keysv));
	    mg_copy((SV*)hv, val, (char*)keysv, HEf_SVKEY);
	    TAINT_IF(save_taint);
	    if (!xhv->xhv_array /* !HvARRAY(hv) */ && !needs_store)
		return Nullhe;
#ifdef ENV_IS_CASELESS
	    else if (mg_find((SV*)hv, PERL_MAGIC_env)) {
		key = SvPV(keysv, klen);
		keysv = sv_2mortal(newSVpvn(key,klen));
		(void)strupr(SvPVX(keysv));
		hash = 0;
a795 1
#endif
d797 1
d799 1
d801 2
a802 2
    keysave = key = SvPV(keysv, klen);
    is_utf8 = (SvUTF8(keysv) != 0);
d804 1
a804 8
    if (is_utf8) {
	key = (char*)bytes_from_utf8((U8*)key, &klen, &is_utf8);
        if (is_utf8)
            flags = HVhek_UTF8;
        if (key != keysave)
            flags |= HVhek_WASUTF8 | HVhek_FREEKEY;
        HvHASKFLAGS_on((SV*)hv);
    }
d806 2
a807 8
    if (HvREHASH(hv)) {
	/* We don't have a pointer to the hv, so we have to replicate the
	   flag into every HEK, so that hv_iterkeysv can see it.  */
	flags |= HVhek_REHASH;
	PERL_HASH_INTERNAL(hash, key, klen);
    } else if (!hash) {
	PERL_HASH(hash, key, klen);
    }
d809 19
a827 77
    if (!xhv->xhv_array /* !HvARRAY(hv) */)
	Newz(505, xhv->xhv_array /* HvARRAY(hv) */,
	     PERL_HV_ARRAY_ALLOC_BYTES(xhv->xhv_max+1 /* HvMAX(hv)+1 */),
	     char);

    /* oentry = &(HvARRAY(hv))[hash & (I32) HvMAX(hv)]; */
    oentry = &((HE**)xhv->xhv_array)[hash & (I32) xhv->xhv_max];
    n_links = 0;
    entry = *oentry;
    for (; entry; ++n_links, entry = HeNEXT(entry)) {
	if (HeHASH(entry) != hash)		/* strings can't be equal */
	    continue;
	if (HeKLEN(entry) != (I32)klen)
	    continue;
	if (HeKEY(entry) != key && memNE(HeKEY(entry),key,klen))	/* is this it? */
	    continue;
	if ((HeKFLAGS(entry) ^ flags) & HVhek_UTF8)
	    continue;
	if (HeVAL(entry) == &PL_sv_placeholder)
	    xhv->xhv_placeholders--; /* yes, can store into placeholder slot */
	else
	    SvREFCNT_dec(HeVAL(entry));
	HeVAL(entry) = val;
        if (HeKFLAGS(entry) != flags) {
            /* We match if HVhek_UTF8 bit in our flags and hash key's match.
               But if entry was set previously with HVhek_WASUTF8 and key now
               doesn't (or vice versa) then we should change the key's flag,
               as this is assignment.  */
            if (HvSHAREKEYS(hv)) {
                /* Need to swap the key we have for a key with the flags we
                   need. As keys are shared we can't just write to the flag,
                   so we share the new one, unshare the old one.  */
                int flags_nofree = flags & ~HVhek_FREEKEY;
                HEK *new_hek = share_hek_flags(key, klen, hash, flags_nofree);
                unshare_hek (HeKEY_hek(entry));
                HeKEY_hek(entry) = new_hek;
            }
            else
                HeKFLAGS(entry) = flags;
        }
        if (flags & HVhek_FREEKEY)
	    Safefree(key);
	return entry;
    }

    if (SvREADONLY(hv)) {
	S_hv_notallowed(aTHX_ flags, key, klen,
			"access disallowed key '%"SVf"' to"
			);
    }

    entry = new_HE();
    /* share_hek_flags will do the free for us.  This might be considered
       bad API design.  */
    if (HvSHAREKEYS(hv))
	HeKEY_hek(entry) = share_hek_flags(key, klen, hash, flags);
    else                                       /* gotta do the real thing */
	HeKEY_hek(entry) = save_hek_flags(key, klen, hash, flags);
    HeVAL(entry) = val;
    HeNEXT(entry) = *oentry;
    *oentry = entry;

    xhv->xhv_keys++; /* HvKEYS(hv)++ */
    if (!n_links) {				/* initial entry? */
	xhv->xhv_fill++; /* HvFILL(hv)++ */
    } else if ((xhv->xhv_keys > (IV)xhv->xhv_max)
	       || ((n_links > HV_MAX_LENGTH_BEFORE_SPLIT) && !HvREHASH(hv))) {
	/* Use only the old HvKEYS(hv) > HvMAX(hv) condition to limit bucket
	   splits on a rehashed hash, as we're not going to split it again,
	   and if someone is lucky (evil) enough to get all the keys in one
	   list they could exhaust our memory as we repeatedly double the
	   number of buckets on every entry. Linear search feels a less worse
	   thing to do.  */
        hsplit(hv);
    }

    return entry;
d841 5
a845 115
SV *
Perl_hv_delete(pTHX_ HV *hv, const char *key, I32 klen, I32 flags)
{
    register XPVHV* xhv;
    register I32 i;
    register U32 hash;
    register HE *entry;
    register HE **oentry;
    SV **svp;
    SV *sv;
    bool is_utf8 = FALSE;
    int k_flags = 0;
    const char *keysave = key;

    if (!hv)
	return Nullsv;
    if (klen < 0) {
	klen = -klen;
	is_utf8 = TRUE;
    }
    if (SvRMAGICAL(hv)) {
	bool needs_copy;
	bool needs_store;
	hv_magic_check (hv, &needs_copy, &needs_store);

	if (needs_copy && (svp = hv_fetch(hv, key, klen, TRUE))) {
	    sv = *svp;
	    if (SvMAGICAL(sv)) {
	        mg_clear(sv);
	    }
	    if (!needs_store) {
		if (mg_find(sv, PERL_MAGIC_tiedelem)) {
		    /* No longer an element */
		    sv_unmagic(sv, PERL_MAGIC_tiedelem);
		    return sv;
		}
		return Nullsv;          /* element cannot be deleted */
	    }
#ifdef ENV_IS_CASELESS
	    else if (mg_find((SV*)hv, PERL_MAGIC_env)) {
		sv = sv_2mortal(newSVpvn(key,klen));
		key = strupr(SvPVX(sv));
	    }
#endif
	}
    }
    xhv = (XPVHV*)SvANY(hv);
    if (!xhv->xhv_array /* !HvARRAY(hv) */)
	return Nullsv;

    if (is_utf8) {
	STRLEN tmplen = klen;
	/* See the note in hv_fetch(). --jhi */
	key = (char*)bytes_from_utf8((U8*)key, &tmplen, &is_utf8);
	klen = tmplen;
        if (is_utf8)
            k_flags = HVhek_UTF8;
        if (key != keysave)
            k_flags |= HVhek_FREEKEY;
    }

    if (HvREHASH(hv)) {
	PERL_HASH_INTERNAL(hash, key, klen);
    } else {
	PERL_HASH(hash, key, klen);
    }

    /* oentry = &(HvARRAY(hv))[hash & (I32) HvMAX(hv)]; */
    oentry = &((HE**)xhv->xhv_array)[hash & (I32) xhv->xhv_max];
    entry = *oentry;
    i = 1;
    for (; entry; i=0, oentry = &HeNEXT(entry), entry = *oentry) {
	if (HeHASH(entry) != hash)		/* strings can't be equal */
	    continue;
	if (HeKLEN(entry) != (I32)klen)
	    continue;
	if (HeKEY(entry) != key && memNE(HeKEY(entry),key,klen))	/* is this it? */
	    continue;
	if ((HeKFLAGS(entry) ^ k_flags) & HVhek_UTF8)
	    continue;
	if (k_flags & HVhek_FREEKEY)
	    Safefree(key);
	/* if placeholder is here, it's already been deleted.... */
	if (HeVAL(entry) == &PL_sv_placeholder)
	{
	    if (SvREADONLY(hv))
		return Nullsv;  /* if still SvREADONLY, leave it deleted. */
	    else {
		/* okay, really delete the placeholder... */
		*oentry = HeNEXT(entry);
		if (i && !*oentry)
		    xhv->xhv_fill--; /* HvFILL(hv)-- */
		if (entry == xhv->xhv_eiter /* HvEITER(hv) */)
		    HvLAZYDEL_on(hv);
		else
		    hv_free_ent(hv, entry);
		xhv->xhv_keys--; /* HvKEYS(hv)-- */
		if (xhv->xhv_keys == 0)
		    HvHASKFLAGS_off(hv);
		xhv->xhv_placeholders--;
		return Nullsv;
	    }
	}
	else if (SvREADONLY(hv) && HeVAL(entry) && SvREADONLY(HeVAL(entry))) {
	    S_hv_notallowed(aTHX_ k_flags, key, klen,
			    "delete readonly key '%"SVf"' from"
			    );
	}

	if (flags & G_DISCARD)
	    sv = Nullsv;
	else {
	    sv = sv_2mortal(HeVAL(entry));
	    HeVAL(entry) = &PL_sv_placeholder;
	}
d847 5
a851 29
	/*
	 * If a restricted hash, rather than really deleting the entry, put
	 * a placeholder there. This marks the key as being "approved", so
	 * we can still access via not-really-existing key without raising
	 * an error.
	 */
	if (SvREADONLY(hv)) {
	    HeVAL(entry) = &PL_sv_placeholder;
	    /* We'll be saving this slot, so the number of allocated keys
	     * doesn't go down, but the number placeholders goes up */
	    xhv->xhv_placeholders++; /* HvPLACEHOLDERS(hv)++ */
	} else {
	    *oentry = HeNEXT(entry);
	    if (i && !*oentry)
		xhv->xhv_fill--; /* HvFILL(hv)-- */
	    if (entry == xhv->xhv_eiter /* HvEITER(hv) */)
		HvLAZYDEL_on(hv);
	    else
		hv_free_ent(hv, entry);
	    xhv->xhv_keys--; /* HvKEYS(hv)-- */
	    if (xhv->xhv_keys == 0)
	        HvHASKFLAGS_off(hv);
	}
	return sv;
    }
    if (SvREADONLY(hv)) {
	S_hv_notallowed(aTHX_ k_flags, key, klen,
			"access disallowed key '%"SVf"' from"
			);
d853 1
a853 4

    if (k_flags & HVhek_FREEKEY)
	Safefree(key);
    return Nullsv;
d870 7
a878 2
    register char *key;
    STRLEN klen;
d883 1
a883 2
    int k_flags = 0;
    char *keysave;
d887 11
d903 17
a919 13
	if (needs_copy && (entry = hv_fetch_ent(hv, keysv, TRUE, hash))) {
	    sv = HeVAL(entry);
	    if (SvMAGICAL(sv)) {
		mg_clear(sv);
	    }
	    if (!needs_store) {
		if (mg_find(sv, PERL_MAGIC_tiedelem)) {
		    /* No longer an element */
		    sv_unmagic(sv, PERL_MAGIC_tiedelem);
		    return sv;
		}		
		return Nullsv;		/* element cannot be deleted */
	    }
d921 12
a932 5
	    else if (mg_find((SV*)hv, PERL_MAGIC_env)) {
		key = SvPV(keysv, klen);
		keysv = sv_2mortal(newSVpvn(key,klen));
		(void)strupr(SvPVX(keysv));
		hash = 0;
a933 1
#endif
d940 3
a942 2
    keysave = key = SvPV(keysv, klen);
    is_utf8 = (SvUTF8(keysv) != 0);
a943 2
    if (is_utf8) {
	key = (char*)bytes_from_utf8((U8*)key, &klen, &is_utf8);
d945 12
a956 3
            k_flags = HVhek_UTF8;
        if (key != keysave)
            k_flags |= HVhek_FREEKEY;
d962 9
a970 1
	PERL_HASH(hash, key, klen);
d973 2
d986 1
a986 1
	if ((HeKFLAGS(entry) ^ k_flags) & HVhek_UTF8)
d1017 1
a1017 1
	if (flags & G_DISCARD)
a1059 214
/*
=for apidoc hv_exists

Returns a boolean indicating whether the specified hash key exists.  The
C<klen> is the length of the key.

=cut
*/

bool
Perl_hv_exists(pTHX_ HV *hv, const char *key, I32 klen)
{
    register XPVHV* xhv;
    register U32 hash;
    register HE *entry;
    SV *sv;
    bool is_utf8 = FALSE;
    const char *keysave = key;
    int k_flags = 0;

    if (!hv)
	return 0;

    if (klen < 0) {
      klen = -klen;
      is_utf8 = TRUE;
    }

    if (SvRMAGICAL(hv)) {
	if (mg_find((SV*)hv, PERL_MAGIC_tied) || SvGMAGICAL((SV*)hv)) {
	    sv = sv_newmortal();
	    mg_copy((SV*)hv, sv, key, klen);
	    magic_existspack(sv, mg_find(sv, PERL_MAGIC_tiedelem));
	    return (bool)SvTRUE(sv);
	}
#ifdef ENV_IS_CASELESS
	else if (mg_find((SV*)hv, PERL_MAGIC_env)) {
	    sv = sv_2mortal(newSVpvn(key,klen));
	    key = strupr(SvPVX(sv));
	}
#endif
    }

    xhv = (XPVHV*)SvANY(hv);
#ifndef DYNAMIC_ENV_FETCH
    if (!xhv->xhv_array /* !HvARRAY(hv) */)
	return 0;
#endif

    if (is_utf8) {
	STRLEN tmplen = klen;
	/* See the note in hv_fetch(). --jhi */
	key = (char*)bytes_from_utf8((U8*)key, &tmplen, &is_utf8);
	klen = tmplen;
        if (is_utf8)
            k_flags = HVhek_UTF8;
        if (key != keysave)
            k_flags |= HVhek_FREEKEY;
    }

    if (HvREHASH(hv)) {
	PERL_HASH_INTERNAL(hash, key, klen);
    } else {
	PERL_HASH(hash, key, klen);
    }

#ifdef DYNAMIC_ENV_FETCH
    if (!xhv->xhv_array /* !HvARRAY(hv) */) entry = Null(HE*);
    else
#endif
    /* entry = (HvARRAY(hv))[hash & (I32) HvMAX(hv)]; */
    entry = ((HE**)xhv->xhv_array)[hash & (I32) xhv->xhv_max];
    for (; entry; entry = HeNEXT(entry)) {
	if (HeHASH(entry) != hash)		/* strings can't be equal */
	    continue;
	if (HeKLEN(entry) != klen)
	    continue;
	if (HeKEY(entry) != key && memNE(HeKEY(entry),key,klen))	/* is this it? */
	    continue;
	if ((HeKFLAGS(entry) ^ k_flags) & HVhek_UTF8)
	    continue;
	if (k_flags & HVhek_FREEKEY)
	    Safefree(key);
	/* If we find the key, but the value is a placeholder, return false. */
	if (HeVAL(entry) == &PL_sv_placeholder)
	    return FALSE;

	return TRUE;
    }
#ifdef DYNAMIC_ENV_FETCH  /* is it out there? */
    if (SvRMAGICAL((SV*)hv) && mg_find((SV*)hv, PERL_MAGIC_env)) {
	unsigned long len;
	char *env = PerlEnv_ENVgetenv_len(key,&len);
	if (env) {
	    sv = newSVpvn(env,len);
	    SvTAINTED_on(sv);
	    (void)hv_store(hv,key,klen,sv,hash);
            if (k_flags & HVhek_FREEKEY)
                Safefree(key);
	    return TRUE;
	}
    }
#endif
    if (k_flags & HVhek_FREEKEY)
        Safefree(key);
    return FALSE;
}


/*
=for apidoc hv_exists_ent

Returns a boolean indicating whether the specified hash key exists. C<hash>
can be a valid precomputed hash value, or 0 to ask for it to be
computed.

=cut
*/

bool
Perl_hv_exists_ent(pTHX_ HV *hv, SV *keysv, U32 hash)
{
    register XPVHV* xhv;
    register char *key;
    STRLEN klen;
    register HE *entry;
    SV *sv;
    bool is_utf8;
    char *keysave;
    int k_flags = 0;

    if (!hv)
	return 0;

    if (SvRMAGICAL(hv)) {
	if (mg_find((SV*)hv, PERL_MAGIC_tied) || SvGMAGICAL((SV*)hv)) {
	   SV* svret = sv_newmortal();
	    sv = sv_newmortal();
	    keysv = sv_2mortal(newSVsv(keysv));
	    mg_copy((SV*)hv, sv, (char*)keysv, HEf_SVKEY);
	   magic_existspack(svret, mg_find(sv, PERL_MAGIC_tiedelem));
	   return (bool)SvTRUE(svret);
	}
#ifdef ENV_IS_CASELESS
	else if (mg_find((SV*)hv, PERL_MAGIC_env)) {
	    key = SvPV(keysv, klen);
	    keysv = sv_2mortal(newSVpvn(key,klen));
	    (void)strupr(SvPVX(keysv));
	    hash = 0;
	}
#endif
    }

    xhv = (XPVHV*)SvANY(hv);
#ifndef DYNAMIC_ENV_FETCH
    if (!xhv->xhv_array /* !HvARRAY(hv) */)
	return 0;
#endif

    keysave = key = SvPV(keysv, klen);
    is_utf8 = (SvUTF8(keysv) != 0);
    if (is_utf8) {
	key = (char*)bytes_from_utf8((U8*)key, &klen, &is_utf8);
        if (is_utf8)
            k_flags = HVhek_UTF8;
        if (key != keysave)
            k_flags |= HVhek_FREEKEY;
    }
    if (HvREHASH(hv)) {
	PERL_HASH_INTERNAL(hash, key, klen);
    } else if (!hash)
	PERL_HASH(hash, key, klen);

#ifdef DYNAMIC_ENV_FETCH
    if (!xhv->xhv_array /* !HvARRAY(hv) */) entry = Null(HE*);
    else
#endif
    /* entry = (HvARRAY(hv))[hash & (I32) HvMAX(hv)]; */
    entry = ((HE**)xhv->xhv_array)[hash & (I32) xhv->xhv_max];
    for (; entry; entry = HeNEXT(entry)) {
	if (HeHASH(entry) != hash)		/* strings can't be equal */
	    continue;
	if (HeKLEN(entry) != (I32)klen)
	    continue;
	if (HeKEY(entry) != key && memNE(HeKEY(entry),key,klen))	/* is this it? */
	    continue;
	if ((HeKFLAGS(entry) ^ k_flags) & HVhek_UTF8)
	    continue;
	if (k_flags & HVhek_FREEKEY)
	    Safefree(key);
	/* If we find the key, but the value is a placeholder, return false. */
	if (HeVAL(entry) == &PL_sv_placeholder)
	    return FALSE;
	return TRUE;
    }
#ifdef DYNAMIC_ENV_FETCH  /* is it out there? */
    if (SvRMAGICAL((SV*)hv) && mg_find((SV*)hv, PERL_MAGIC_env)) {
	unsigned long len;
	char *env = PerlEnv_ENVgetenv_len(key,&len);
	if (env) {
	    sv = newSVpvn(env,len);
	    SvTAINTED_on(sv);
	    (void)hv_store_ent(hv,keysv,sv,hash);
            if (k_flags & HVhek_FREEKEY)
                Safefree(key);
	    return TRUE;
	}
    }
#endif
    if (k_flags & HVhek_FREEKEY)
        Safefree(key);
    return FALSE;
}

d1448 1
a1448 1
    if (SvREADONLY(hv)) {
d1469 1
a1469 1
	return;
d1483 57
d2094 1
a2094 1
	HeKEY_hek(entry) = save_hek_flags(str, len, hash, flags);
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d3 2
a4 1
 *    Copyright (c) 1991-2002, Larry Wall
d21 1
d24 2
d96 17
d131 4
a134 1
    if (HeKLEN(e) == HEf_SVKEY)
d136 1
d158 1
a158 1
	SV *sv = sv_newmortal();
d236 1
d240 3
a242 2
	    PL_hv_fetch_sv = sv;
	    return &PL_hv_fetch_sv;
d281 9
a289 1
    PERL_HASH(hash, key, klen);
d321 2
d327 1
a327 1
	if (HeVAL(entry) == &PL_sv_undef)
d396 1
a396 1
	    keysv = sv_2mortal(newSVsv(keysv));
d398 5
a402 1
	    if (!HeKEY_hek(&PL_hv_fetch_ent_mh)) {
d404 1
d406 1
a406 1
		HeKEY_hek(&PL_hv_fetch_ent_mh) = (HEK*)k;
d408 8
a415 4
	    HeSVKEY_set(&PL_hv_fetch_ent_mh, keysv);
	    HeVAL(&PL_hv_fetch_ent_mh) = sv;
	    return &PL_hv_fetch_ent_mh;
	}
d433 1
a447 1
    keysave = key = SvPV(keysv, klen);
d458 7
a464 1
    if (!hash)
d466 1
d495 2
d501 1
a501 1
	if (HeVAL(entry) == &PL_sv_undef)
d559 9
a567 1
the call, and decrementing it if the function returned NULL.
d611 1
a611 1
    register I32 i;
d643 6
a648 1
    if (!hash)
a657 1
    i = 1;
d659 3
a661 1
    for (entry = *oentry; entry; i=0, entry = HeNEXT(entry)) {
d670 1
a670 1
	if (HeVAL(entry) == &PL_sv_undef)
d678 1
a678 1
            HeVAL(entry) = &PL_sv_undef;
d721 1
a721 1
        HeVAL(entry) = &PL_sv_undef;
d728 1
a728 1
    if (i) {				/* initial entry? */
d730 9
a738 2
	if (xhv->xhv_keys > (IV)xhv->xhv_max /* HvKEYS(hv) > HvMAX(hv) */)
	    hsplit(hv);
d755 11
a765 1
decrementing it if the function returned NULL.
d779 1
a779 1
    I32 i;
d826 6
a831 1
    if (!hash)
d833 1
d842 1
a842 1
    i = 1;
d844 1
a844 1
    for (; entry; i=0, entry = HeNEXT(entry)) {
d853 1
a853 1
	if (HeVAL(entry) == &PL_sv_undef)
d898 1
a898 1
    if (i) {				/* initial entry? */
d900 9
a908 2
	if (xhv->xhv_keys > (IV)xhv->xhv_max /* HvKEYS(hv) > HvMAX(hv) */)
	    hsplit(hv);
d942 2
a943 2
      klen = -klen;
      is_utf8 = TRUE;
d952 3
a954 1
	    mg_clear(sv);
d986 5
a990 1
    PERL_HASH(hash, key, klen);
d1008 1
a1008 1
	if (HeVAL(entry) == &PL_sv_undef)
d1038 1
a1038 1
	    HeVAL(entry) = &PL_sv_undef;
d1048 1
a1048 1
	    HeVAL(entry) = &PL_sv_undef;
d1111 3
a1113 1
	    mg_clear(sv);
d1147 3
a1149 1
    if (!hash)
d1151 1
d1170 1
a1170 1
	if (HeVAL(entry) == &PL_sv_undef)
d1199 1
a1199 1
	    HeVAL(entry) = &PL_sv_undef;
d1209 1
a1209 1
	    HeVAL(entry) = &PL_sv_undef;
d1298 5
a1302 1
    PERL_HASH(hash, key, klen);
d1322 1
a1322 1
	if (HeVAL(entry) == &PL_sv_undef)
d1406 3
a1408 1
    if (!hash)
d1429 1
a1429 1
	if (HeVAL(entry) == &PL_sv_undef)
d1464 2
d1496 3
d1509 1
d1512 1
a1512 1
	    else
d1514 2
d1519 71
d1591 2
d1696 1
d1838 24
a1861 2
    if(SvREADONLY(hv)) {
        Perl_croak(aTHX_ "Attempt to clear a restricted hash");
a1863 1
    xhv = (XPVHV*)SvANY(hv);
a1864 2
    xhv->xhv_fill = 0; /* HvFILL(hv) = 0 */
    xhv->xhv_keys = 0; /* HvKEYS(hv) = 0 */
d1874 1
d1894 6
d1913 1
d1935 2
a1941 2
    xhv->xhv_fill  = 0;	/* HvFILL(hv) = 0 */
    xhv->xhv_keys  = 0;	/* HvKEYS(hv) = 0 */
d2011 2
a2012 3
Currently a placeholder is implemented with a value that is literally
<&Perl_sv_undef> (a regular C<undef> value is a normal read-write SV for which
C<!SvOK> is false). Note that the implementation of placeholders and
d2072 1
d2081 1
a2081 1
            while (entry && HeVAL(entry) == &PL_sv_undef) {
d2087 2
d2091 1
d2099 8
a2106 4
            /* if we have an entry, but it's a placeholder, don't count it */
            if (entry && HeVAL(entry) == &PL_sv_undef)
                entry = 0;
        }
d2114 3
d2174 11
a2184 1
        } else {
d2406 3
d2436 1
a2436 1
	    if (xhv->xhv_keys > (IV)xhv->xhv_max /* HvKEYS(hv) > HvMAX(hv) */)
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2001, Larry Wall
d14 4
d28 1
a28 1
        more_he();
d58 2
a59 2
        HeNEXT(he) = (HE*)(he + 1);
        he++;
d77 1
a77 1
S_save_hek(pTHX_ const char *str, I32 len, U32 hash)
d81 2
a82 2
    
    New(54, k, HEK_BASESIZE + len + 1, char);
d85 1
a85 1
    *(HEK_KEY(hek) + len) = '\0';
d88 1
a91 6
void
Perl_unshare_hek(pTHX_ HEK *hek)
{
    unsharepvn(HEK_KEY(hek),HEK_LEN(hek),HEK_HASH(hek));
}

d94 1
a94 1
Perl_he_dup(pTHX_ HE *e, bool shared)
d109 1
a109 1
    HeNEXT(ret) = he_dup(HeNEXT(e),shared);
d111 1
a111 1
	HeKEY_sv(ret) = SvREFCNT_inc(sv_dup(HeKEY_sv(e)));
d113 2
a114 1
	HeKEY_hek(ret) = share_hek(HeKEY(e), HeKLEN(e), HeHASH(e));
d116 3
a118 2
	HeKEY_hek(ret) = save_hek(HeKEY(e), HeKLEN(e), HeHASH(e));
    HeVAL(ret) = SvREFCNT_inc(sv_dup(HeVAL(e)));
d123 20
d152 1
a152 1
dereferencing it to a C<SV*>. 
d160 1
d162 32
a193 1
Perl_hv_fetch(pTHX_ HV *hv, const char *key, U32 klen, I32 lval)
d204 6
a209 1
	if (mg_find((SV*)hv,'P')) {
d212 2
d218 2
a219 2
	else if (mg_find((SV*)hv,'E')) {
	    U32 i;
d224 5
a228 2
		    if (!ret && lval)
			ret = hv_store(hv, key, klen, NEWSV(61,0), 0);
d235 2
d238 2
a239 2
    if (!xhv->xhv_array) {
	if (lval 
d241 1
a241 1
	         || (HvNAME(hv) && strEQ(HvNAME(hv),ENV_HV_NAME))
d243 7
a249 4
	                                                          )
	    Newz(503, xhv->xhv_array,
		 PERL_HV_ARRAY_ALLOC_BYTES(xhv->xhv_max + 1), char);
	else
d251 1
d256 1
d261 1
a261 1
	if (HeKLEN(entry) != klen)
d263 1
a263 1
	if (memNE(HeKEY(entry),key,klen))	/* is this it? */
d265 27
d293 1
d296 1
a296 1
    if (HvNAME(hv) && strEQ(HvNAME(hv),ENV_HV_NAME)) {
d302 2
d308 5
d315 1
a315 1
	return hv_store(hv,key,klen,sv,hash);
d317 2
d322 1
a322 1
/* returns a HE * structure with the all fields set */
d333 1
a333 1
store it somewhere. 
d349 3
d357 1
a357 1
	if (mg_find((SV*)hv,'P')) {
d371 1
a371 1
	else if (mg_find((SV*)hv,'E')) {
d388 2
a389 2
    if (!xhv->xhv_array) {
	if (lval 
d391 1
a391 1
	         || (HvNAME(hv) && strEQ(HvNAME(hv),ENV_HV_NAME))
d393 4
a396 3
	                                                          )
	    Newz(503, xhv->xhv_array,
		 PERL_HV_ARRAY_ALLOC_BYTES(xhv->xhv_max + 1), char);
d401 11
a411 2
    key = SvPV(keysv, klen);
    
d415 1
d420 3
a422 1
	if (HeKLEN(entry) != klen)
d424 1
a424 1
	if (memNE(HeKEY(entry),key,klen))	/* is this it? */
d426 22
d451 1
a451 1
    if (HvNAME(hv) && strEQ(HvNAME(hv),ENV_HV_NAME)) {
d461 7
d485 2
a486 2
	    case 'P':
	    case 'S':
d504 1
a504 1
the call, and decrementing it if the function returned NULL.  
d513 33
a545 1
Perl_hv_store(pTHX_ HV *hv, const char *key, U32 klen, SV *val, register U32 hash)
d562 3
a564 1
	    if (!xhv->xhv_array && !needs_store)
d566 1
d568 3
a570 3
	    else if (mg_find((SV*)hv,'E')) {
		SV *sv = sv_2mortal(newSVpvn(key,klen));
		key = strupr(SvPVX(sv));
d576 4
d583 4
a586 3
    if (!xhv->xhv_array)
	Newz(505, xhv->xhv_array,
	     PERL_HV_ARRAY_ALLOC_BYTES(xhv->xhv_max + 1), char);
d588 1
d595 3
a597 1
	if (HeKLEN(entry) != klen)
d599 1
a599 1
	if (memNE(HeKEY(entry),key,klen))	/* is this it? */
d601 31
a631 2
	SvREFCNT_dec(HeVAL(entry));
	HeVAL(entry) = val;
d635 6
d642 2
d645 1
a645 1
	HeKEY_hek(entry) = share_hek(key, klen, hash);
d647 8
a654 2
	HeKEY_hek(entry) = save_hek(key, klen, hash);
    HeVAL(entry) = val;
d658 1
a658 1
    xhv->xhv_keys++;
d660 2
a661 2
	++xhv->xhv_fill;
	if (xhv->xhv_keys > xhv->xhv_max)
d676 1
a676 1
contents of the return value can be accessed using the C<He???> macros
d679 1
a679 1
decrementing it if the function returned NULL. 
d688 1
a688 1
Perl_hv_store_ent(pTHX_ HV *hv, SV *keysv, SV *val, register U32 hash)
d690 2
a691 2
    register XPVHV* xhv;
    register char *key;
d693 6
a698 3
    register I32 i;
    register HE *entry;
    register HE **oentry;
d705 12
a716 12
 	bool needs_copy;
 	bool needs_store;
 	hv_magic_check (hv, &needs_copy, &needs_store);
 	if (needs_copy) {
 	    bool save_taint = PL_tainted;
 	    if (PL_tainting)
 		PL_tainted = SvTAINTED(keysv);
 	    keysv = sv_2mortal(newSVsv(keysv));
 	    mg_copy((SV*)hv, val, (char*)keysv, HEf_SVKEY);
 	    TAINT_IF(save_taint);
 	    if (!xhv->xhv_array && !needs_store)
 		return Nullhe;
d718 1
a718 1
	    else if (mg_find((SV*)hv,'E')) {
d728 11
a738 1
    key = SvPV(keysv, klen);
d743 4
a746 3
    if (!xhv->xhv_array)
	Newz(505, xhv->xhv_array,
	     PERL_HV_ARRAY_ALLOC_BYTES(xhv->xhv_max + 1), char);
d748 1
d751 2
a752 2

    for (entry = *oentry; entry; i=0, entry = HeNEXT(entry)) {
d755 3
a757 1
	if (HeKLEN(entry) != klen)
d759 1
a759 1
	if (memNE(HeKEY(entry),key,klen))	/* is this it? */
d761 4
a764 1
	SvREFCNT_dec(HeVAL(entry));
d766 19
d788 6
d795 2
d798 1
a798 1
	HeKEY_hek(entry) = share_hek(key, klen, hash);
d800 1
a800 1
	HeKEY_hek(entry) = save_hek(key, klen, hash);
d805 1
a805 1
    xhv->xhv_keys++;
d807 2
a808 2
	++xhv->xhv_fill;
	if (xhv->xhv_keys > xhv->xhv_max)
d819 1
a819 1
hash and returned to the caller.  The C<klen> is the length of the key. 
d827 1
a827 1
Perl_hv_delete(pTHX_ HV *hv, const char *key, U32 klen, I32 flags)
d836 3
d842 4
d855 3
a857 2
		if (mg_find(sv, 'p')) {
		    sv_unmagic(sv, 'p');        /* No longer an element */
d863 1
a863 1
	    else if (mg_find((SV*)hv,'E')) {
d868 1
a868 1
        }
d871 1
a871 1
    if (!xhv->xhv_array)
d874 11
d887 1
d894 3
a896 1
	if (HeKLEN(entry) != klen)
d898 1
a898 1
	if (memNE(HeKEY(entry),key,klen))	/* is this it? */
d900 29
a928 3
	*oentry = HeNEXT(entry);
	if (i && !*oentry)
	    xhv->xhv_fill--;
d935 24
a958 5
	if (entry == xhv->xhv_eiter)
	    HvLAZYDEL_on(hv);
	else
	    hv_free_ent(hv, entry);
	--xhv->xhv_keys;
d961 8
d993 4
a996 1
    
d1008 3
a1010 2
		if (mg_find(sv, 'p')) {
		    sv_unmagic(sv, 'p');	/* No longer an element */
d1016 1
a1016 1
	    else if (mg_find((SV*)hv,'E')) {
d1020 1
a1020 1
		hash = 0; 
d1026 1
a1026 1
    if (!xhv->xhv_array)
d1029 11
a1039 2
    key = SvPV(keysv, klen);
    
d1043 1
d1050 3
a1052 1
	if (HeKLEN(entry) != klen)
d1054 1
a1054 1
	if (memNE(HeKEY(entry),key,klen))	/* is this it? */
d1056 29
a1084 3
	*oentry = HeNEXT(entry);
	if (i && !*oentry)
	    xhv->xhv_fill--;
d1091 24
a1114 5
	if (entry == xhv->xhv_eiter)
	    HvLAZYDEL_on(hv);
	else
	    hv_free_ent(hv, entry);
	--xhv->xhv_keys;
d1117 8
d1138 1
a1138 1
Perl_hv_exists(pTHX_ HV *hv, const char *key, U32 klen)
d1144 3
d1151 5
d1157 1
a1157 1
	if (mg_find((SV*)hv,'P')) {
d1159 3
a1161 3
	    mg_copy((SV*)hv, sv, key, klen); 
	    magic_existspack(sv, mg_find(sv, 'p'));
	    return SvTRUE(sv);
d1164 1
a1164 1
	else if (mg_find((SV*)hv,'E')) {
d1173 2
a1174 2
    if (!xhv->xhv_array)
	return 0; 
d1177 11
d1191 1
a1191 1
    if (!xhv->xhv_array) entry = Null(HE*);
d1194 1
d1201 3
a1203 1
	if (memNE(HeKEY(entry),key,klen))	/* is this it? */
d1205 6
d1214 1
a1214 1
    if (HvNAME(hv) && strEQ(HvNAME(hv), ENV_HV_NAME)) {
d1221 2
d1227 2
d1251 3
d1259 2
a1260 1
	if (mg_find((SV*)hv,'P')) {
d1263 3
a1265 3
	    mg_copy((SV*)hv, sv, (char*)keysv, HEf_SVKEY); 
	    magic_existspack(sv, mg_find(sv, 'p'));
	    return SvTRUE(sv);
d1268 1
a1268 1
	else if (mg_find((SV*)hv,'E')) {
d1272 1
a1272 1
	    hash = 0; 
d1279 2
a1280 2
    if (!xhv->xhv_array)
	return 0; 
d1283 9
a1291 1
    key = SvPV(keysv, klen);
d1296 1
a1296 1
    if (!xhv->xhv_array) entry = Null(HE*);
d1299 1
d1304 3
a1306 1
	if (HeKLEN(entry) != klen)
d1308 1
a1308 1
	if (memNE(HeKEY(entry),key,klen))	/* is this it? */
d1310 5
d1318 1
a1318 1
    if (HvNAME(hv) && strEQ(HvNAME(hv), ENV_HV_NAME)) {
d1325 2
d1331 2
d1340 1
a1340 1
    I32 oldsize = (I32) xhv->xhv_max + 1; /* sic(k) */
d1343 1
a1343 1
    register char *a = xhv->xhv_array;
a1356 1
#define MALLOC_OVERHEAD 16
d1362 1
a1362 1
    Copy(xhv->xhv_array, a, oldsize * sizeof(HE*), char);
d1364 2
a1365 1
	offer_nice_chunk(xhv->xhv_array, PERL_HV_ARRAY_ALLOC_BYTES(oldsize));
d1368 1
a1368 1
	Safefree(xhv->xhv_array);
d1373 2
a1374 2
    xhv->xhv_max = --newsize;
    xhv->xhv_array = a;
d1382 1
a1382 1
	    if ((HeHASH(entry) & newsize) != i) {
d1386 1
a1386 1
		    xhv->xhv_fill++;
d1394 1
a1394 1
	    xhv->xhv_fill--;
d1402 1
a1402 1
    I32 oldsize = (I32) xhv->xhv_max + 1; /* sic(k) */
d1422 1
a1422 1
    a = xhv->xhv_array;
d1427 1
a1427 1
        if (!a) {
d1433 1
a1433 1
        if (!a) {
d1437 1
a1437 1
	Copy(xhv->xhv_array, a, oldsize * sizeof(HE*), char);
d1439 2
a1440 1
	    offer_nice_chunk(xhv->xhv_array, PERL_HV_ARRAY_ALLOC_BYTES(oldsize));
d1443 1
a1443 1
	    Safefree(xhv->xhv_array);
d1451 3
a1453 3
    xhv->xhv_max = --newsize;
    xhv->xhv_array = a;
    if (!xhv->xhv_fill)				/* skip rest if no entries */
d1465 1
a1465 1
		    xhv->xhv_fill++;
d1473 1
a1473 1
	    xhv->xhv_fill--;
d1496 1
a1496 1
#ifndef NODEFAULT_SHAREKEYS    
d1498 4
a1501 4
#endif    
    xhv->xhv_max = 7;		/* start with 8 buckets */
    xhv->xhv_fill = 0;
    xhv->xhv_pmroot = 0;
d1509 2
a1510 3
    register HV *hv;
    STRLEN hv_max = ohv ? HvMAX(ohv) : 0;
    STRLEN hv_fill = ohv ? HvFILL(ohv) : 0;
d1512 1
a1512 5
    hv = newHV();
    while (hv_max && hv_max + 1 >= hv_fill * 2)
	hv_max = hv_max / 2;	/* Is always 2^n-1 */
    HvMAX(hv) = hv_max;
    if (!hv_fill)
d1514 40
d1555 7
a1561 7
#if 0
    if (! SvTIED_mg((SV*)ohv, 'P')) {
	/* Quick way ???*/
    } 
    else 
#endif
    {
d1563 8
a1570 4
	I32 hv_riter = HvRITER(ohv);	/* current root of iterator */
	HE *hv_eiter = HvEITER(ohv);	/* current entry of iterator */
	
	/* Slow way */
d1572 4
a1575 3
	while ((entry = hv_iternext(ohv))) {
	    hv_store(hv, HeKEY(entry), HeKLEN(entry),
		     newSVsv(HeVAL(entry)), HeHASH(entry));
d1577 2
a1578 2
	HvRITER(ohv) = hv_riter;
	HvEITER(ohv) = hv_eiter;
d1580 1
a1580 1
    
d1597 1
a1597 1
        Safefree(HeKEY_hek(entry));
d1639 5
d1646 6
a1651 4
    xhv->xhv_fill = 0;
    xhv->xhv_keys = 0;
    if (xhv->xhv_array)
	(void)memzero(xhv->xhv_array, (xhv->xhv_max + 1) * sizeof(HE*));
d1654 3
a1656 1
	mg_clear((SV*)hv); 
d1687 1
a1687 1
	} 
d1708 1
a1708 1
    Safefree(xhv->xhv_array);
d1713 5
a1717 4
    xhv->xhv_array = 0;
    xhv->xhv_max = 7;		/* it's a normal hash */
    xhv->xhv_fill = 0;
    xhv->xhv_keys = 0;
d1720 1
a1720 1
	mg_clear((SV*)hv); 
d1728 1
a1728 1
currently only meaningful for hashes without tie magic. 
d1734 1
d1747 1
a1747 1
    entry = xhv->xhv_eiter;
d1752 4
a1755 3
    xhv->xhv_riter = -1;
    xhv->xhv_eiter = Null(HE*);
    return xhv->xhv_keys;	/* used to be xhv->xhv_fill before 5.004_65 */
a1756 1

d1762 8
d1776 22
d1806 1
a1806 1
    oldentry = entry = xhv->xhv_eiter;
d1808 1
a1808 1
    if ((mg = SvTIED_mg((SV*)hv, 'P'))) {
d1818 2
a1819 1
	    xhv->xhv_eiter = entry = new_HE();  /* one HE per MAGICAL hash */
d1827 1
a1827 1
        if (SvOK(key)) {
d1831 1
a1831 1
        }
d1836 1
a1836 1
	xhv->xhv_eiter = Null(HE*);
d1840 1
a1840 1
    if (!entry && HvNAME(hv) && strEQ(HvNAME(hv), ENV_HV_NAME))
d1844 4
a1847 3
    if (!xhv->xhv_array)
	Newz(506, xhv->xhv_array,
	     PERL_HV_ARRAY_ALLOC_BYTES(xhv->xhv_max + 1), char);
d1849 1
d1851 10
d1862 3
a1864 3
	++xhv->xhv_riter;
	if (xhv->xhv_riter > xhv->xhv_max) {
	    xhv->xhv_riter = -1;
d1867 1
d1869 6
d1882 1
a1882 1
    xhv->xhv_eiter = entry;
d1924 23
a1946 5
    if (HeKLEN(entry) == HEf_SVKEY)
	return sv_mortalcopy(HeKEY_sv(entry));
    else
	return sv_2mortal(newSVpvn((HeKLEN(entry) ? HeKEY(entry) : ""),
				  HeKLEN(entry)));
d1962 1
a1962 1
	if (mg_find((SV*)hv,'P')) {
d1986 1
a1986 1
    if ( (he = hv_iternext(hv)) == NULL)
d2006 2
d2014 2
d2022 17
d2044 18
a2061 1
    
d2070 1
d2072 32
a2103 17
    for (entry = *oentry; entry; i=0, oentry = &HeNEXT(entry), entry = *oentry) {
	if (HeHASH(entry) != hash)		/* strings can't be equal */
	    continue;
	if (HeKLEN(entry) != len)
	    continue;
	if (memNE(HeKEY(entry),str,len))	/* is this it? */
	    continue;
	found = 1;
	if (--HeVAL(entry) == Nullsv) {
	    *oentry = HeNEXT(entry);
	    if (i && !*oentry)
		xhv->xhv_fill--;
	    Safefree(HeKEY_hek(entry));
	    del_HE(entry);
	    --xhv->xhv_keys;
	}
	break;
d2105 1
d2108 6
a2113 1
	Perl_warner(aTHX_ WARN_INTERNAL, "Attempt to free non-existent shared string");    
d2123 27
d2155 1
d2158 1
a2158 1
       
d2160 1
a2160 1
    	hv_store(PL_strtab, str, len, Nullsv, hash);
d2165 1
d2172 3
a2174 1
	if (memNE(HeKEY(entry),str,len))	/* is this it? */
d2181 1
a2181 1
	HeKEY_hek(entry) = save_hek(str, len, hash);
d2185 1
a2185 1
	xhv->xhv_keys++;
d2187 2
a2188 2
	    ++xhv->xhv_fill;
	    if (xhv->xhv_keys > xhv->xhv_max)
d2195 4
a2200 3



@


1.4
log
@perl-5.6.0 + local changes
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2000, Larry Wall
d45 6
a50 2
    New(54, PL_he_root, 1008/sizeof(HE), HE);
    he = PL_he_root;
d52 1
a151 1
	    dTHR;
a247 1
	    dTHR;
a463 1
	dTHR;
a720 1
	    dTHR;
a795 1
	    dTHR;		/* just for SvTRUE */
d1048 2
a1049 2
	    hv_store(hv, HeKEY(entry), HeKLEN(entry), 
		     SvREFCNT_inc(HeVAL(entry)), HeHASH(entry));
d1447 2
a1448 6
    
    {
        dTHR;
        if (!found && ckWARN_d(WARN_INTERNAL))
	    Perl_warner(aTHX_ WARN_INTERNAL, "Attempt to free non-existent shared string");    
    }
@


1.3
log
@perl5.005_03 (stock)
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1999, Larry Wall
d15 1
a17 14
static void hv_magic_check _((HV *hv, bool *needs_copy, bool *needs_store));
#ifndef PERL_OBJECT
static void hsplit _((HV *hv));
static void hfreeentries _((HV *hv));
static void more_he _((void));
#endif

#if defined(STRANGE_MALLOC) || defined(MYMALLOC)
#  define ARRAY_ALLOC_BYTES(size) ( (size)*sizeof(HE*) )
#else
#  define MALLOC_OVERHEAD 16
#  define ARRAY_ALLOC_BYTES(size) ( (size)*sizeof(HE*)*2 - MALLOC_OVERHEAD )
#endif

d19 1
a19 1
new_he(void)
d32 1
a32 1
del_he(HE *p)
d41 1
a41 1
more_he(void)
d55 12
d68 1
a68 1
save_hek(char *str, I32 len, U32 hash)
d83 1
a83 1
unshare_hek(HEK *hek)
d88 29
d120 14
d135 1
a135 1
hv_fetch(HV *hv, char *key, U32 klen, I32 lval)
d158 1
a158 1
		    char *nkey = strupr(SvPVX(sv_2mortal(newSVpv(key,klen))));
d175 2
a176 1
	    Newz(503,xhv->xhv_array, ARRAY_ALLOC_BYTES(xhv->xhv_max + 1), char);
d195 7
a201 7
      char *gotenv;

      if ((gotenv = PerlEnv_getenv(key)) != Nullch) {
        sv = newSVpv(gotenv,strlen(gotenv));
        SvTAINTED_on(sv);
        return hv_store(hv,key,klen,sv,hash);
      }
d213 17
d231 1
a231 1
hv_fetch_ent(HV *hv, SV *keysv, I32 lval, register U32 hash)
d263 1
a263 1
		    SV *nkeysv = sv_2mortal(newSVpv(key,klen));
d281 2
a282 1
	    Newz(503,xhv->xhv_array, ARRAY_ALLOC_BYTES(xhv->xhv_max + 1), char);
d304 7
a310 7
      char *gotenv;

      if ((gotenv = PerlEnv_getenv(key)) != Nullch) {
        sv = newSVpv(gotenv,strlen(gotenv));
        SvTAINTED_on(sv);
        return hv_store_ent(hv,keysv,sv,hash);
      }
d320 2
a321 2
static void
hv_magic_check (HV *hv, bool *needs_copy, bool *needs_store)
d339 18
d358 1
a358 1
hv_store(HV *hv, char *key, U32 klen, SV *val, register U32 hash)
d379 1
a379 1
		SV *sv = sv_2mortal(newSVpv(key,klen));
d390 2
a391 1
	Newz(505, xhv->xhv_array, ARRAY_ALLOC_BYTES(xhv->xhv_max + 1), char);
d408 1
a408 1
    entry = new_he();
d427 19
d447 1
a447 1
hv_store_ent(HV *hv, SV *keysv, SV *val, register U32 hash)
d477 1
a477 1
		keysv = sv_2mortal(newSVpv(key,klen));
d491 2
a492 1
	Newz(505, xhv->xhv_array, ARRAY_ALLOC_BYTES(xhv->xhv_max + 1), char);
d509 1
a509 1
    entry = new_he();
d528 11
d540 1
a540 1
hv_delete(HV *hv, char *key, U32 klen, I32 flags)
d569 1
a569 1
		sv = sv_2mortal(newSVpv(key,klen));
d596 4
a599 2
	else
	    sv = sv_mortalcopy(HeVAL(entry));
d610 11
d622 1
a622 1
hv_delete_ent(HV *hv, SV *keysv, I32 flags, U32 hash)
d652 1
a652 1
		keysv = sv_2mortal(newSVpv(key,klen));
d683 4
a686 2
	else
	    sv = sv_mortalcopy(HeVAL(entry));
d697 9
d707 1
a707 1
hv_exists(HV *hv, char *key, U32 klen)
d727 1
a727 1
	    sv = sv_2mortal(newSVpv(key,klen));
d734 1
d737 1
d741 4
d755 12
d771 10
d782 1
a782 1
hv_exists_ent(HV *hv, SV *keysv, U32 hash)
d805 1
a805 1
	    keysv = sv_2mortal(newSVpv(key,klen));
d813 1
d816 1
d822 4
d836 12
d852 1
a852 1
hsplit(HV *hv)
d866 1
a866 1
    Renew(a, ARRAY_ALLOC_BYTES(newsize), char);
d873 1
a873 1
    New(2, a, ARRAY_ALLOC_BYTES(newsize), char);
d880 1
a880 1
	offer_nice_chunk(xhv->xhv_array, ARRAY_ALLOC_BYTES(oldsize));
d914 1
a914 1
hv_ksplit(HV *hv, IV newmax)
d941 1
a941 1
	Renew(a, ARRAY_ALLOC_BYTES(newsize), char);
d947 1
a947 1
	New(2, a, ARRAY_ALLOC_BYTES(newsize), char);
d954 1
a954 1
	    offer_nice_chunk(xhv->xhv_array, ARRAY_ALLOC_BYTES(oldsize));
d963 1
a963 1
	Newz(0, a, ARRAY_ALLOC_BYTES(newsize), char);
d991 8
d1000 1
a1000 1
newHV(void)
d1021 1
a1021 1
newHVhv(HV *ohv)
d1047 1
a1047 1
	while (entry = hv_iternext(ohv)) {
d1059 1
a1059 1
hv_free_ent(HV *hv, register HE *entry)
d1077 1
a1077 1
    del_he(entry);
d1081 1
a1081 1
hv_delayfree_ent(HV *hv, register HE *entry)
d1096 1
a1096 1
    del_he(entry);
d1099 8
d1108 1
a1108 1
hv_clear(HV *hv)
d1125 1
a1125 1
hfreeentries(HV *hv)
d1157 8
d1166 1
a1166 1
hv_undef(HV *hv)
d1187 14
d1202 1
a1202 1
hv_iterinit(HV *hv)
d1208 1
a1208 1
	croak("Bad hash");
a1210 4
#ifdef DYNAMIC_ENV_FETCH  /* set up %ENV for iteration */
    if (HvNAME(hv) && strEQ(HvNAME(hv), ENV_HV_NAME))
	prime_env_iter();
#endif
d1220 8
d1229 1
a1229 1
hv_iternext(HV *hv)
d1237 1
a1237 1
	croak("Bad hash");
d1241 1
a1241 1
    if (mg = SvTIED_mg((SV*)hv, 'P')) {
d1251 1
a1251 1
	    xhv->xhv_eiter = entry = new_he();  /* one HE per MAGICAL hash */
d1267 1
a1267 1
	del_he(entry);
d1271 4
d1277 2
a1278 1
	Newz(506,xhv->xhv_array, ARRAY_ALLOC_BYTES(xhv->xhv_max + 1), char);
d1299 9
d1309 1
a1309 1
hv_iterkey(register HE *entry, I32 *retlen)
d1324 10
d1335 1
a1335 1
hv_iterkeysv(register HE *entry)
d1340 1
a1340 1
	return sv_2mortal(newSVpv((HeKLEN(entry) ? HeKEY(entry) : ""),
d1344 9
d1354 1
a1354 1
hv_iterval(HV *hv, register HE *entry)
d1368 9
d1378 1
a1378 1
hv_iternextsv(HV *hv, char **key, I32 *retlen)
d1387 8
d1396 1
a1396 1
hv_magic(HV *hv, GV *gv, int how)
d1402 1
a1402 1
sharepvn(char *sv, I32 len, U32 hash)
d1411 1
a1411 1
unsharepvn(char *str, I32 len, U32 hash)
d1441 1
a1441 1
	    del_he(entry);
d1448 5
a1452 2
    if (!found)
	warn("Attempt to free non-existent shared string");    
d1460 1
a1460 1
share_hek(char *str, I32 len, register U32 hash)
d1488 1
a1488 1
	entry = new_he();
@


1.2
log
@perl 5.004_04
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1997, Larry Wall
d17 2
d21 2
d24 6
a29 1
static HE* more_he();
d31 2
a32 2
static HE*
new_he()
d35 16
a50 6
    if (he_root) {
        he = he_root;
        he_root = HeNEXT(he);
        return he;
    }
    return more_he();
d53 2
a54 10
static void
del_he(p)
HE* p;
{
    HeNEXT(p) = (HE*)he_root;
    he_root = p;
}

static HE*
more_he()
d58 2
a59 2
    he_root = (HE*)safemalloc(1008);
    he = he_root;
a65 1
    return new_he();
d68 2
a69 5
static HEK *
save_hek(str, len, hash)
char *str;
I32 len;
U32 hash;
d84 1
a84 2
unshare_hek(hek)
HEK *hek;
d93 1
a93 5
hv_fetch(hv,key,klen,lval)
HV *hv;
char *key;
U32 klen;
I32 lval;
d105 1
d108 14
a121 2
	    Sv = sv;
	    return &Sv;
d123 1
d133 1
a133 1
	    Newz(503,xhv->xhv_array, sizeof(HE*) * (xhv->xhv_max + 1), char);
d154 1
a154 1
      if ((gotenv = ENV_getenv(key)) != Nullch) {
d171 1
a171 5
hv_fetch_ent(hv,keysv,lval,hash)
HV *hv;
SV *keysv;
I32 lval;
register U32 hash;
d182 28
a209 10
    if (SvRMAGICAL(hv) && mg_find((SV*)hv,'P')) {
	static HE mh;

	sv = sv_newmortal();
	keysv = sv_2mortal(newSVsv(keysv));
	mg_copy((SV*)hv, sv, (char*)keysv, HEf_SVKEY);
	if (!HeKEY_hek(&mh)) {
	    char *k;
	    New(54, k, HEK_BASESIZE + sizeof(SV*), char);
	    HeKEY_hek(&mh) = (HEK*)k;
d211 1
a211 3
	HeSVKEY_set(&mh, keysv);
	HeVAL(&mh) = sv;
	return &mh;
d221 1
a221 1
	    Newz(503,xhv->xhv_array, sizeof(HE*) * (xhv->xhv_max + 1), char);
d245 1
a245 1
      if ((gotenv = ENV_getenv(key)) != Nullch) {
d259 19
d279 1
a279 6
hv_store(hv,key,klen,val,hash)
HV *hv;
char *key;
U32 klen;
SV *val;
register U32 hash;
d291 15
a305 9
	mg_copy((SV*)hv, val, key, klen);
	if (!xhv->xhv_array
	    && (SvMAGIC(hv)->mg_moremagic
		|| (SvMAGIC(hv)->mg_type != 'E'
#ifdef OVERLOAD
		    && SvMAGIC(hv)->mg_type != 'A'
#endif /* OVERLOAD */
		    )))
	    return 0;
d311 1
a311 1
	Newz(505, xhv->xhv_array, sizeof(HE**) * (xhv->xhv_max + 1), char);
d348 1
a348 5
hv_store_ent(hv,keysv,val,hash)
HV *hv;
SV *keysv;
SV *val;
register U32 hash;
d362 22
a383 14
	bool save_taint = tainted;
	if (tainting)
	    tainted = SvTAINTED(keysv);
	keysv = sv_2mortal(newSVsv(keysv));
	mg_copy((SV*)hv, val, (char*)keysv, HEf_SVKEY);
	TAINT_IF(save_taint);
	if (!xhv->xhv_array
	    && (SvMAGIC(hv)->mg_moremagic
		|| (SvMAGIC(hv)->mg_type != 'E'
#ifdef OVERLOAD
		    && SvMAGIC(hv)->mg_type != 'A'
#endif /* OVERLOAD */
		    )))
	  return Nullhe;
d387 1
a387 1
    
d392 1
a392 1
	Newz(505, xhv->xhv_array, sizeof(HE**) * (xhv->xhv_max + 1), char);
d429 1
a429 5
hv_delete(hv,key,klen,flags)
HV *hv;
char *key;
U32 klen;
I32 flags;
d436 1
d442 21
a462 9
	sv = *hv_fetch(hv, key, klen, TRUE);
	mg_clear(sv);
	if (mg_find(sv, 's')) {
	    return Nullsv;		/* %SIG elements cannot be deleted */
	}
	if (mg_find(sv, 'p')) {
	    sv_unmagic(sv, 'p');	/* No longer an element */
	    return sv;
	}
d498 1
a498 5
hv_delete_ent(hv,keysv,flags,hash)
HV *hv;
SV *keysv;
I32 flags;
U32 hash;
d511 22
a532 6
	entry = hv_fetch_ent(hv, keysv, TRUE, hash);
	sv = HeVAL(entry);
	mg_clear(sv);
	if (mg_find(sv, 'p')) {
	    sv_unmagic(sv, 'p');	/* No longer an element */
	    return sv;
d572 1
a572 4
hv_exists(hv,key,klen)
HV *hv;
char *key;
U32 klen;
d584 1
d590 6
d619 1
a619 4
hv_exists_ent(hv,keysv,hash)
HV *hv;
SV *keysv;
U32 hash;
d632 1
d639 8
d670 2
a671 3
static void
hsplit(hv)
HV *hv;
d677 3
a679 2
    register HE **a;
    register HE **b;
a681 3
#ifndef STRANGE_MALLOC
    I32 tmp;
#endif
d683 7
a689 4
    a = (HE**)xhv->xhv_array;
    nomemok = TRUE;
#ifdef STRANGE_MALLOC
    Renew(a, newsize, HE*);
a690 1
    i = newsize * sizeof(HE*);
d692 8
a699 11
    tmp = MALLOC_OVERHEAD;
    while (tmp - MALLOC_OVERHEAD < i)
	tmp += tmp;
    tmp -= MALLOC_OVERHEAD;
    tmp /= sizeof(HE*);
    assert(tmp >= newsize);
    New(2,a, tmp, HE*);
    Copy(xhv->xhv_array, a, oldsize, HE*);
    if (oldsize >= 64 && !nice_chunk) {
	nice_chunk = (char*)xhv->xhv_array;
	nice_chunk_size = oldsize * sizeof(HE*) * 2 - MALLOC_OVERHEAD;
d705 2
a706 2
    nomemok = FALSE;
    Zero(&a[oldsize], oldsize, HE*);		/* zero 2nd half*/
d708 2
a709 1
    xhv->xhv_array = (char*)a;
d711 2
a712 2
    for (i=0; i<oldsize; i++,a++) {
	if (!*a)				/* non-existent */
d714 2
a715 2
	b = a+oldsize;
	for (oentry = a, entry = *a; entry; entry = *oentry) {
d718 2
a719 2
		HeNEXT(entry) = *b;
		if (!*b)
d721 1
a721 1
		*b = entry;
d727 1
a727 1
	if (!*a)				/* everything moved */
d733 1
a733 3
hv_ksplit(hv, newmax)
HV *hv;
IV newmax;
d740 2
a741 1
    register HE **a;
d756 1
a756 1
    a = (HE**)xhv->xhv_array;
d758 7
a764 3
	nomemok = TRUE;
#ifdef STRANGE_MALLOC
	Renew(a, newsize, HE*);
d766 8
a773 12
	i = newsize * sizeof(HE*);
	j = MALLOC_OVERHEAD;
	while (j - MALLOC_OVERHEAD < i)
	    j += j;
	j -= MALLOC_OVERHEAD;
	j /= sizeof(HE*);
	assert(j >= newsize);
	New(2, a, j, HE*);
	Copy(xhv->xhv_array, a, oldsize, HE*);
	if (oldsize >= 64 && !nice_chunk) {
	    nice_chunk = (char*)xhv->xhv_array;
	    nice_chunk_size = oldsize * sizeof(HE*) * 2 - MALLOC_OVERHEAD;
d778 2
a779 2
	nomemok = FALSE;
	Zero(&a[oldsize], newsize-oldsize, HE*); /* zero 2nd half*/
d782 1
a782 1
	Newz(0, a, newsize, HE*);
d785 1
a785 1
    xhv->xhv_array = (char*)a;
d789 3
a791 2
    for (i=0; i<oldsize; i++,a++) {
	if (!*a)				/* non-existent */
d793 1
a793 1
	for (oentry = a, entry = *a; entry; entry = *oentry) {
d797 1
a797 1
		if (!(HeNEXT(entry) = a[j]))
d799 1
a799 1
		a[j] = entry;
d805 1
a805 1
	if (!*a)				/* everything moved */
d811 1
a811 1
newHV()
d831 38
d870 1
a870 3
hv_free_ent(hv, entry)
HV *hv;
register HE *entry;
d872 2
d876 4
a879 3
    if (isGV(HeVAL(entry)) && GvCVu(HeVAL(entry)) && HvNAME(hv))
	sub_generation++;	/* may be deletion of method from stash */
    SvREFCNT_dec(HeVAL(entry));
d892 1
a892 3
hv_delayfree_ent(hv, entry)
HV *hv;
register HE *entry;
d897 1
a897 1
	sub_generation++;	/* may be deletion of method from stash */
d911 1
a911 2
hv_clear(hv)
HV *hv;
d927 2
a928 3
static void
hfreeentries(hv)
HV *hv;
d961 1
a961 2
hv_undef(hv)
HV *hv;
d983 1
a983 2
hv_iterinit(hv)
HV *hv;
d1002 1
a1002 1
    return xhv->xhv_fill;	/* should be xhv->xhv_keys? May change later */
d1006 1
a1006 2
hv_iternext(hv)
HV *hv;
d1018 1
a1018 1
    if (SvRMAGICAL(hv) && (mg = mg_find((SV*)hv,'P'))) {
d1050 1
a1050 1
	Newz(506,xhv->xhv_array, sizeof(HE*) * (xhv->xhv_max + 1), char);
d1072 1
a1072 3
hv_iterkey(entry,retlen)
register HE *entry;
I32 *retlen;
d1088 1
a1088 2
hv_iterkeysv(entry)
register HE *entry;
d1098 1
a1098 3
hv_iterval(hv,entry)
HV *hv;
register HE *entry;
d1113 1
a1113 4
hv_iternextsv(hv, key, retlen)
    HV *hv;
    char **key;
    I32 *retlen;
d1123 1
a1123 4
hv_magic(hv, gv, how)
HV* hv;
GV* gv;
int how;
d1129 1
a1129 4
sharepvn(sv, len, hash)
char* sv;
I32 len;
U32 hash;
d1138 1
a1138 4
unsharepvn(str, len, hash)
char* str;
I32 len;
U32 hash;
d1147 1
a1147 1
    if ((Svp = hv_fetch(strtab, tmpsv, FALSE, hash))) {
d1149 1
a1149 1
	    hv_delete(strtab, str, len, G_DISCARD, hash);
d1151 1
a1151 1
    xhv = (XPVHV*)SvANY(strtab);
d1153 1
d1173 1
d1184 1
a1184 4
share_hek(str, len, hash)
char *str;
I32 len;
register U32 hash;
d1194 2
a1195 2
    if (!(Svp = hv_fetch(strtab, str, len, FALSE)))
    	hv_store(strtab, str, len, Nullsv, hash);
d1197 1
a1197 1
    xhv = (XPVHV*)SvANY(strtab);
d1199 1
d1221 1
a1221 1
		hsplit(strtab);
d1226 1
d1229 1
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1994, Larry Wall
d28 1
a28 1
        he_root = (HE*)he->hent_next;
d38 1
a38 1
    p->hent_next = (HE*)he_root;
d51 1
a51 1
        he->hent_next = (HE*)(he + 1);
d54 1
a54 1
    he->hent_next = 0;
d58 28
d94 1
a94 3
    register char *s;
    register I32 i;
    register I32 hash;
d122 1
a122 5
    i = klen;
    hash = 0;
    s = key;
    while (i--)
	hash = hash * 33 + *s++;
d125 2
a126 2
    for (; entry; entry = entry->hent_next) {
	if (entry->hent_hash != hash)		/* strings can't be equal */
d128 1
a128 1
	if (entry->hent_klen != klen)
d130 1
a130 1
	if (bcmp(entry->hent_key,key,klen))	/* is this it? */
d132 1
a132 1
	return &entry->hent_val;
d138 1
a138 2
      gotenv = my_getenv(key);
      if (gotenv != NULL) {
d140 1
d152 79
a239 1
    register char *s;
d250 7
a256 2
#ifndef OVERLOAD
	if (!xhv->xhv_array)
d258 71
a328 4
#else
	if (!xhv->xhv_array && (SvMAGIC(hv)->mg_type != 'A'
				|| SvMAGIC(hv)->mg_moremagic))
	  return 0;
d330 2
d333 5
a337 6
    if (!hash) {
    i = klen;
    s = key;
    while (i--)
	hash = hash * 33 + *s++;
    }
d345 2
a346 2
    for (entry = *oentry; entry; i=0, entry = entry->hent_next) {
	if (entry->hent_hash != hash)		/* strings can't be equal */
d348 1
a348 1
	if (entry->hent_klen != klen)
d350 1
a350 1
	if (bcmp(entry->hent_key,key,klen))	/* is this it? */
d352 3
a354 3
	SvREFCNT_dec(entry->hent_val);
	entry->hent_val = val;
	return &entry->hent_val;
d358 6
a363 5
    entry->hent_klen = klen;
    entry->hent_key = savepvn(key,klen);
    entry->hent_val = val;
    entry->hent_hash = hash;
    entry->hent_next = *oentry;
d373 1
a373 1
    return &entry->hent_val;
a383 1
    register char *s;
d385 1
a385 1
    register I32 hash;
d395 62
d465 5
a469 5
    i = klen;
    hash = 0;
    s = key;
    while (i--)
	hash = hash * 33 + *s++;
d474 2
a475 2
    for (; entry; i=0, oentry = &entry->hent_next, entry = *oentry) {
	if (entry->hent_hash != hash)		/* strings can't be equal */
d477 1
a477 1
	if (entry->hent_klen != klen)
d479 1
a479 1
	if (bcmp(entry->hent_key,key,klen))	/* is this it? */
d481 1
a481 1
	*oentry = entry->hent_next;
d487 1
a487 1
	    sv = sv_mortalcopy(entry->hent_val);
d489 1
a489 1
	    entry->hent_klen = -1;
d491 1
a491 1
	    he_free(entry);
d505 1
a505 3
    register char *s;
    register I32 i;
    register I32 hash;
d525 48
a572 5
    i = klen;
    hash = 0;
    s = key;
    while (i--)
	hash = hash * 33 + *s++;
d575 2
a576 2
    for (; entry; entry = entry->hent_next) {
	if (entry->hent_hash != hash)		/* strings can't be equal */
d578 1
a578 1
	if (entry->hent_klen != klen)
d580 1
a580 1
	if (bcmp(entry->hent_key,key,klen))	/* is this it? */
d636 3
a638 3
	    if ((entry->hent_hash & newsize) != i) {
		*oentry = entry->hent_next;
		entry->hent_next = *b;
d645 79
a723 1
		oentry = &entry->hent_next;
d741 3
d752 3
a754 2
he_free(hent)
register HE *hent;
d756 1
a756 1
    if (!hent)
d758 12
a769 3
    SvREFCNT_dec(hent->hent_val);
    Safefree(hent->hent_key);
    del_he(hent);
d773 3
a775 2
he_delayfree(hent)
register HE *hent;
d777 1
a777 1
    if (!hent)
d779 12
a790 3
    sv_2mortal(hent->hent_val);	/* free between statements */
    Safefree(hent->hent_key);
    del_he(hent);
d816 2
a817 2
    register HE *hent;
    register HE *ohent = Null(HE*);
d829 1
a829 1
    hent = array[0];
d831 4
a834 4
	if (hent) {
	    ohent = hent;
	    hent = hent->hent_next;
	    he_free(ohent);
d836 1
a836 1
	if (!hent) {
d839 1
a839 1
	    hent = array[riter];
d860 1
a860 1
    xhv->xhv_max = 7;		/* it's a normal associative array */
d872 15
a886 4
    register XPVHV* xhv = (XPVHV*)SvANY(hv);
    HE *entry = xhv->xhv_eiter;
    if (entry && entry->hent_klen < 0)	/* was deleted earlier? */
	he_free(entry);
d889 1
a889 1
    return xhv->xhv_fill;
d902 1
a902 1
	croak("Bad associative array");
d909 2
a910 2
	    sv_usepvn(key, entry->hent_key, entry->hent_klen);
	    entry->hent_key = 0;
d913 4
a916 1
	    xhv->xhv_eiter = entry = new_he();
d918 4
d925 3
a927 6
	    STRLEN len;
	    entry->hent_key = SvPV_force(key, len);
	    entry->hent_klen = len;
	    SvPOK_off(key);
	    SvPVX(key) = 0;
	    return entry;
d929 3
a931 2
	if (entry->hent_val)
	    SvREFCNT_dec(entry->hent_val);
d939 7
a945 10
    do {
	if (entry)
	    entry = entry->hent_next;
	if (!entry) {
	    ++xhv->xhv_riter;
	    if (xhv->xhv_riter > xhv->xhv_max) {
		xhv->xhv_riter = -1;
		break;
	    }
	    entry = ((HE**)xhv->xhv_array)[xhv->xhv_riter];
d947 2
a948 1
    } while (!entry);
d950 4
a953 2
    if (oldentry && oldentry->hent_klen < 0)	/* was deleted earlier? */
	he_free(oldentry);
d964 22
a985 2
    *retlen = entry->hent_klen;
    return entry->hent_key;
d996 3
a998 1
	    mg_copy((SV*)hv, sv, entry->hent_key, entry->hent_klen);
d1002 1
a1002 1
    return entry->hent_val;
d1026 109
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1999, Larry Wall
a16 2
static void hv_magic_check _((HV *hv, bool *needs_copy, bool *needs_store));
#ifndef PERL_OBJECT
a18 2
static void more_he _((void));
#endif
d20 1
a20 6
#if defined(STRANGE_MALLOC) || defined(MYMALLOC)
#  define ARRAY_ALLOC_BYTES(size) ( (size)*sizeof(HE*) )
#else
#  define MALLOC_OVERHEAD 16
#  define ARRAY_ALLOC_BYTES(size) ( (size)*sizeof(HE*)*2 - MALLOC_OVERHEAD )
#endif
d22 2
a23 2
STATIC HE*
new_he(void)
d26 6
a31 7
    LOCK_SV_MUTEX;
    if (!PL_he_root)
        more_he();
    he = PL_he_root;
    PL_he_root = HeNEXT(he);
    UNLOCK_SV_MUTEX;
    return he;
d34 3
a36 2
STATIC void
del_he(HE *p)
d38 2
a39 4
    LOCK_SV_MUTEX;
    HeNEXT(p) = (HE*)PL_he_root;
    PL_he_root = p;
    UNLOCK_SV_MUTEX;
d42 2
a43 2
STATIC void
more_he(void)
d47 2
a48 2
    New(54, PL_he_root, 1008/sizeof(HE), HE);
    he = PL_he_root;
d51 1
a51 1
        HeNEXT(he) = (HE*)(he + 1);
d54 2
a55 22
    HeNEXT(he) = 0;
}

STATIC HEK *
save_hek(char *str, I32 len, U32 hash)
{
    char *k;
    register HEK *hek;
    
    New(54, k, HEK_BASESIZE + len + 1, char);
    hek = (HEK*)k;
    Copy(str, HEK_KEY(hek), len, char);
    *(HEK_KEY(hek) + len) = '\0';
    HEK_LEN(hek) = len;
    HEK_HASH(hek) = hash;
    return hek;
}

void
unshare_hek(HEK *hek)
{
    unsharepvn(HEK_KEY(hek),HEK_LEN(hek),HEK_HASH(hek));
a57 3
/* (klen == HEf_SVKEY) is special for MAGICAL hv entries, meaning key slot
 * contains an SV* */

d59 5
a63 1
hv_fetch(HV *hv, char *key, U32 klen, I32 lval)
d66 3
a68 1
    register U32 hash;
a76 1
	    dTHR;
d79 2
a80 14
	    PL_hv_fetch_sv = sv;
	    return &PL_hv_fetch_sv;
	}
#ifdef ENV_IS_CASELESS
	else if (mg_find((SV*)hv,'E')) {
	    U32 i;
	    for (i = 0; i < klen; ++i)
		if (isLOWER(key[i])) {
		    char *nkey = strupr(SvPVX(sv_2mortal(newSVpv(key,klen))));
		    SV **ret = hv_fetch(hv, nkey, klen, 0);
		    if (!ret && lval)
			ret = hv_store(hv, key, klen, NEWSV(61,0), 0);
		    return ret;
		}
a81 1
#endif
d91 1
a91 1
	    Newz(503,xhv->xhv_array, ARRAY_ALLOC_BYTES(xhv->xhv_max + 1), char);
d96 5
a100 1
    PERL_HASH(hash, key, klen);
d103 2
a104 2
    for (; entry; entry = HeNEXT(entry)) {
	if (HeHASH(entry) != hash)		/* strings can't be equal */
d106 1
a106 1
	if (HeKLEN(entry) != klen)
d108 1
a108 1
	if (memNE(HeKEY(entry),key,klen))	/* is this it? */
d110 1
a110 1
	return &HeVAL(entry);
d116 2
a117 1
      if ((gotenv = PerlEnv_getenv(key)) != Nullch) {
a118 1
        SvTAINTED_on(sv);
a129 110
/* returns a HE * structure with the all fields set */
/* note that hent_val will be a mortal sv for MAGICAL hashes */
HE *
hv_fetch_ent(HV *hv, SV *keysv, I32 lval, register U32 hash)
{
    register XPVHV* xhv;
    register char *key;
    STRLEN klen;
    register HE *entry;
    SV *sv;

    if (!hv)
	return 0;

    if (SvRMAGICAL(hv)) {
	if (mg_find((SV*)hv,'P')) {
	    dTHR;
	    sv = sv_newmortal();
	    keysv = sv_2mortal(newSVsv(keysv));
	    mg_copy((SV*)hv, sv, (char*)keysv, HEf_SVKEY);
	    if (!HeKEY_hek(&PL_hv_fetch_ent_mh)) {
		char *k;
		New(54, k, HEK_BASESIZE + sizeof(SV*), char);
		HeKEY_hek(&PL_hv_fetch_ent_mh) = (HEK*)k;
	    }
	    HeSVKEY_set(&PL_hv_fetch_ent_mh, keysv);
	    HeVAL(&PL_hv_fetch_ent_mh) = sv;
	    return &PL_hv_fetch_ent_mh;
	}
#ifdef ENV_IS_CASELESS
	else if (mg_find((SV*)hv,'E')) {
	    U32 i;
	    key = SvPV(keysv, klen);
	    for (i = 0; i < klen; ++i)
		if (isLOWER(key[i])) {
		    SV *nkeysv = sv_2mortal(newSVpv(key,klen));
		    (void)strupr(SvPVX(nkeysv));
		    entry = hv_fetch_ent(hv, nkeysv, 0, 0);
		    if (!entry && lval)
			entry = hv_store_ent(hv, keysv, NEWSV(61,0), hash);
		    return entry;
		}
	}
#endif
    }

    xhv = (XPVHV*)SvANY(hv);
    if (!xhv->xhv_array) {
	if (lval 
#ifdef DYNAMIC_ENV_FETCH  /* if it's an %ENV lookup, we may get it on the fly */
	         || (HvNAME(hv) && strEQ(HvNAME(hv),ENV_HV_NAME))
#endif
	                                                          )
	    Newz(503,xhv->xhv_array, ARRAY_ALLOC_BYTES(xhv->xhv_max + 1), char);
	else
	    return 0;
    }

    key = SvPV(keysv, klen);
    
    if (!hash)
	PERL_HASH(hash, key, klen);

    entry = ((HE**)xhv->xhv_array)[hash & (I32) xhv->xhv_max];
    for (; entry; entry = HeNEXT(entry)) {
	if (HeHASH(entry) != hash)		/* strings can't be equal */
	    continue;
	if (HeKLEN(entry) != klen)
	    continue;
	if (memNE(HeKEY(entry),key,klen))	/* is this it? */
	    continue;
	return entry;
    }
#ifdef DYNAMIC_ENV_FETCH  /* %ENV lookup?  If so, try to fetch the value now */
    if (HvNAME(hv) && strEQ(HvNAME(hv),ENV_HV_NAME)) {
      char *gotenv;

      if ((gotenv = PerlEnv_getenv(key)) != Nullch) {
        sv = newSVpv(gotenv,strlen(gotenv));
        SvTAINTED_on(sv);
        return hv_store_ent(hv,keysv,sv,hash);
      }
    }
#endif
    if (lval) {		/* gonna assign to this, so it better be there */
	sv = NEWSV(61,0);
	return hv_store_ent(hv,keysv,sv,hash);
    }
    return 0;
}

static void
hv_magic_check (HV *hv, bool *needs_copy, bool *needs_store)
{
    MAGIC *mg = SvMAGIC(hv);
    *needs_copy = FALSE;
    *needs_store = TRUE;
    while (mg) {
	if (isUPPER(mg->mg_type)) {
	    *needs_copy = TRUE;
	    switch (mg->mg_type) {
	    case 'P':
	    case 'S':
		*needs_store = FALSE;
	    }
	}
	mg = mg->mg_moremagic;
    }
}

d131 6
a136 1
hv_store(HV *hv, char *key, U32 klen, SV *val, register U32 hash)
d139 1
d149 15
a163 15
	bool needs_copy;
	bool needs_store;
	hv_magic_check (hv, &needs_copy, &needs_store);
	if (needs_copy) {
	    mg_copy((SV*)hv, val, key, klen);
	    if (!xhv->xhv_array && !needs_store)
		return 0;
#ifdef ENV_IS_CASELESS
	    else if (mg_find((SV*)hv,'E')) {
		SV *sv = sv_2mortal(newSVpv(key,klen));
		key = strupr(SvPVX(sv));
		hash = 0;
	    }
#endif
	}
a164 2
    if (!hash)
	PERL_HASH(hash, key, klen);
d167 1
a167 1
	Newz(505, xhv->xhv_array, ARRAY_ALLOC_BYTES(xhv->xhv_max + 1), char);
d172 2
a173 2
    for (entry = *oentry; entry; i=0, entry = HeNEXT(entry)) {
	if (HeHASH(entry) != hash)		/* strings can't be equal */
d175 1
a175 1
	if (HeKLEN(entry) != klen)
d177 1
a177 1
	if (memNE(HeKEY(entry),key,klen))	/* is this it? */
d179 3
a181 3
	SvREFCNT_dec(HeVAL(entry));
	HeVAL(entry) = val;
	return &HeVAL(entry);
d185 5
a189 6
    if (HvSHAREKEYS(hv))
	HeKEY_hek(entry) = share_hek(key, klen, hash);
    else                                       /* gotta do the real thing */
	HeKEY_hek(entry) = save_hek(key, klen, hash);
    HeVAL(entry) = val;
    HeNEXT(entry) = *oentry;
d199 1
a199 82
    return &HeVAL(entry);
}

HE *
hv_store_ent(HV *hv, SV *keysv, SV *val, register U32 hash)
{
    register XPVHV* xhv;
    register char *key;
    STRLEN klen;
    register I32 i;
    register HE *entry;
    register HE **oentry;

    if (!hv)
	return 0;

    xhv = (XPVHV*)SvANY(hv);
    if (SvMAGICAL(hv)) {
	dTHR;
 	bool needs_copy;
 	bool needs_store;
 	hv_magic_check (hv, &needs_copy, &needs_store);
 	if (needs_copy) {
 	    bool save_taint = PL_tainted;
 	    if (PL_tainting)
 		PL_tainted = SvTAINTED(keysv);
 	    keysv = sv_2mortal(newSVsv(keysv));
 	    mg_copy((SV*)hv, val, (char*)keysv, HEf_SVKEY);
 	    TAINT_IF(save_taint);
 	    if (!xhv->xhv_array && !needs_store)
 		return Nullhe;
#ifdef ENV_IS_CASELESS
	    else if (mg_find((SV*)hv,'E')) {
		key = SvPV(keysv, klen);
		keysv = sv_2mortal(newSVpv(key,klen));
		(void)strupr(SvPVX(keysv));
		hash = 0;
	    }
#endif
	}
    }

    key = SvPV(keysv, klen);

    if (!hash)
	PERL_HASH(hash, key, klen);

    if (!xhv->xhv_array)
	Newz(505, xhv->xhv_array, ARRAY_ALLOC_BYTES(xhv->xhv_max + 1), char);

    oentry = &((HE**)xhv->xhv_array)[hash & (I32) xhv->xhv_max];
    i = 1;

    for (entry = *oentry; entry; i=0, entry = HeNEXT(entry)) {
	if (HeHASH(entry) != hash)		/* strings can't be equal */
	    continue;
	if (HeKLEN(entry) != klen)
	    continue;
	if (memNE(HeKEY(entry),key,klen))	/* is this it? */
	    continue;
	SvREFCNT_dec(HeVAL(entry));
	HeVAL(entry) = val;
	return entry;
    }

    entry = new_he();
    if (HvSHAREKEYS(hv))
	HeKEY_hek(entry) = share_hek(key, klen, hash);
    else                                       /* gotta do the real thing */
	HeKEY_hek(entry) = save_hek(key, klen, hash);
    HeVAL(entry) = val;
    HeNEXT(entry) = *oentry;
    *oentry = entry;

    xhv->xhv_keys++;
    if (i) {				/* initial entry? */
	++xhv->xhv_fill;
	if (xhv->xhv_keys > xhv->xhv_max)
	    hsplit(hv);
    }

    return entry;
d203 5
a207 1
hv_delete(HV *hv, char *key, U32 klen, I32 flags)
d210 1
d212 1
a212 1
    register U32 hash;
a214 1
    SV **svp;
d220 5
a224 91
	bool needs_copy;
	bool needs_store;
	hv_magic_check (hv, &needs_copy, &needs_store);

	if (needs_copy && (svp = hv_fetch(hv, key, klen, TRUE))) {
	    sv = *svp;
	    mg_clear(sv);
	    if (!needs_store) {
		if (mg_find(sv, 'p')) {
		    sv_unmagic(sv, 'p');        /* No longer an element */
		    return sv;
		}
		return Nullsv;          /* element cannot be deleted */
	    }
#ifdef ENV_IS_CASELESS
	    else if (mg_find((SV*)hv,'E')) {
		sv = sv_2mortal(newSVpv(key,klen));
		key = strupr(SvPVX(sv));
	    }
#endif
        }
    }
    xhv = (XPVHV*)SvANY(hv);
    if (!xhv->xhv_array)
	return Nullsv;

    PERL_HASH(hash, key, klen);

    oentry = &((HE**)xhv->xhv_array)[hash & (I32) xhv->xhv_max];
    entry = *oentry;
    i = 1;
    for (; entry; i=0, oentry = &HeNEXT(entry), entry = *oentry) {
	if (HeHASH(entry) != hash)		/* strings can't be equal */
	    continue;
	if (HeKLEN(entry) != klen)
	    continue;
	if (memNE(HeKEY(entry),key,klen))	/* is this it? */
	    continue;
	*oentry = HeNEXT(entry);
	if (i && !*oentry)
	    xhv->xhv_fill--;
	if (flags & G_DISCARD)
	    sv = Nullsv;
	else
	    sv = sv_mortalcopy(HeVAL(entry));
	if (entry == xhv->xhv_eiter)
	    HvLAZYDEL_on(hv);
	else
	    hv_free_ent(hv, entry);
	--xhv->xhv_keys;
	return sv;
    }
    return Nullsv;
}

SV *
hv_delete_ent(HV *hv, SV *keysv, I32 flags, U32 hash)
{
    register XPVHV* xhv;
    register I32 i;
    register char *key;
    STRLEN klen;
    register HE *entry;
    register HE **oentry;
    SV *sv;
    
    if (!hv)
	return Nullsv;
    if (SvRMAGICAL(hv)) {
	bool needs_copy;
	bool needs_store;
	hv_magic_check (hv, &needs_copy, &needs_store);

	if (needs_copy && (entry = hv_fetch_ent(hv, keysv, TRUE, hash))) {
	    sv = HeVAL(entry);
	    mg_clear(sv);
	    if (!needs_store) {
		if (mg_find(sv, 'p')) {
		    sv_unmagic(sv, 'p');	/* No longer an element */
		    return sv;
		}		
		return Nullsv;		/* element cannot be deleted */
	    }
#ifdef ENV_IS_CASELESS
	    else if (mg_find((SV*)hv,'E')) {
		key = SvPV(keysv, klen);
		keysv = sv_2mortal(newSVpv(key,klen));
		(void)strupr(SvPVX(keysv));
		hash = 0; 
	    }
#endif
d230 5
a234 5

    key = SvPV(keysv, klen);
    
    if (!hash)
	PERL_HASH(hash, key, klen);
d239 2
a240 2
    for (; entry; i=0, oentry = &HeNEXT(entry), entry = *oentry) {
	if (HeHASH(entry) != hash)		/* strings can't be equal */
d242 1
a242 1
	if (HeKLEN(entry) != klen)
d244 1
a244 1
	if (memNE(HeKEY(entry),key,klen))	/* is this it? */
d246 1
a246 1
	*oentry = HeNEXT(entry);
d252 1
a252 1
	    sv = sv_mortalcopy(HeVAL(entry));
d254 1
a254 1
	    HvLAZYDEL_on(hv);
d256 1
a256 1
	    hv_free_ent(hv, entry);
d264 4
a267 1
hv_exists(HV *hv, char *key, U32 klen)
d270 3
a272 1
    register U32 hash;
a280 1
	    dTHR;
a285 6
#ifdef ENV_IS_CASELESS
	else if (mg_find((SV*)hv,'E')) {
	    sv = sv_2mortal(newSVpv(key,klen));
	    key = strupr(SvPVX(sv));
	}
#endif
d292 5
a296 1
    PERL_HASH(hash, key, klen);
d299 2
a300 2
    for (; entry; entry = HeNEXT(entry)) {
	if (HeHASH(entry) != hash)		/* strings can't be equal */
d302 1
a302 1
	if (HeKLEN(entry) != klen)
d304 1
a304 1
	if (memNE(HeKEY(entry),key,klen))	/* is this it? */
d311 3
a313 55

bool
hv_exists_ent(HV *hv, SV *keysv, U32 hash)
{
    register XPVHV* xhv;
    register char *key;
    STRLEN klen;
    register HE *entry;
    SV *sv;

    if (!hv)
	return 0;

    if (SvRMAGICAL(hv)) {
	if (mg_find((SV*)hv,'P')) {
	    dTHR;		/* just for SvTRUE */
	    sv = sv_newmortal();
	    keysv = sv_2mortal(newSVsv(keysv));
	    mg_copy((SV*)hv, sv, (char*)keysv, HEf_SVKEY); 
	    magic_existspack(sv, mg_find(sv, 'p'));
	    return SvTRUE(sv);
	}
#ifdef ENV_IS_CASELESS
	else if (mg_find((SV*)hv,'E')) {
	    key = SvPV(keysv, klen);
	    keysv = sv_2mortal(newSVpv(key,klen));
	    (void)strupr(SvPVX(keysv));
	    hash = 0; 
	}
#endif
    }

    xhv = (XPVHV*)SvANY(hv);
    if (!xhv->xhv_array)
	return 0; 

    key = SvPV(keysv, klen);
    if (!hash)
	PERL_HASH(hash, key, klen);

    entry = ((HE**)xhv->xhv_array)[hash & (I32) xhv->xhv_max];
    for (; entry; entry = HeNEXT(entry)) {
	if (HeHASH(entry) != hash)		/* strings can't be equal */
	    continue;
	if (HeKLEN(entry) != klen)
	    continue;
	if (memNE(HeKEY(entry),key,klen))	/* is this it? */
	    continue;
	return TRUE;
    }
    return FALSE;
}

STATIC void
hsplit(HV *hv)
d319 2
a320 3
    register char *a = xhv->xhv_array;
    register HE **aep;
    register HE **bep;
d323 3
d327 4
a330 7
    PL_nomemok = TRUE;
#if defined(STRANGE_MALLOC) || defined(MYMALLOC)
    Renew(a, ARRAY_ALLOC_BYTES(newsize), char);
    if (!a) {
      PL_nomemok = FALSE;
      return;
    }
d332 1
d334 11
a344 8
    New(2, a, ARRAY_ALLOC_BYTES(newsize), char);
    if (!a) {
      PL_nomemok = FALSE;
      return;
    }
    Copy(xhv->xhv_array, a, oldsize * sizeof(HE*), char);
    if (oldsize >= 64) {
	offer_nice_chunk(xhv->xhv_array, ARRAY_ALLOC_BYTES(oldsize));
d350 2
a351 79
    PL_nomemok = FALSE;
    Zero(&a[oldsize * sizeof(HE*)], (newsize-oldsize) * sizeof(HE*), char);	/* zero 2nd half*/
    xhv->xhv_max = --newsize;
    xhv->xhv_array = a;
    aep = (HE**)a;

    for (i=0; i<oldsize; i++,aep++) {
	if (!*aep)				/* non-existent */
	    continue;
	bep = aep+oldsize;
	for (oentry = aep, entry = *aep; entry; entry = *oentry) {
	    if ((HeHASH(entry) & newsize) != i) {
		*oentry = HeNEXT(entry);
		HeNEXT(entry) = *bep;
		if (!*bep)
		    xhv->xhv_fill++;
		*bep = entry;
		continue;
	    }
	    else
		oentry = &HeNEXT(entry);
	}
	if (!*aep)				/* everything moved */
	    xhv->xhv_fill--;
    }
}

void
hv_ksplit(HV *hv, IV newmax)
{
    register XPVHV* xhv = (XPVHV*)SvANY(hv);
    I32 oldsize = (I32) xhv->xhv_max + 1; /* sic(k) */
    register I32 newsize;
    register I32 i;
    register I32 j;
    register char *a;
    register HE **aep;
    register HE *entry;
    register HE **oentry;

    newsize = (I32) newmax;			/* possible truncation here */
    if (newsize != newmax || newmax <= oldsize)
	return;
    while ((newsize & (1 + ~newsize)) != newsize) {
	newsize &= ~(newsize & (1 + ~newsize));	/* get proper power of 2 */
    }
    if (newsize < newmax)
	newsize *= 2;
    if (newsize < newmax)
	return;					/* overflow detection */

    a = xhv->xhv_array;
    if (a) {
	PL_nomemok = TRUE;
#if defined(STRANGE_MALLOC) || defined(MYMALLOC)
	Renew(a, ARRAY_ALLOC_BYTES(newsize), char);
        if (!a) {
	  PL_nomemok = FALSE;
	  return;
	}
#else
	New(2, a, ARRAY_ALLOC_BYTES(newsize), char);
        if (!a) {
	  PL_nomemok = FALSE;
	  return;
	}
	Copy(xhv->xhv_array, a, oldsize * sizeof(HE*), char);
	if (oldsize >= 64) {
	    offer_nice_chunk(xhv->xhv_array, ARRAY_ALLOC_BYTES(oldsize));
	}
	else
	    Safefree(xhv->xhv_array);
#endif
	PL_nomemok = FALSE;
	Zero(&a[oldsize * sizeof(HE*)], (newsize-oldsize) * sizeof(HE*), char); /* zero 2nd half*/
    }
    else {
	Newz(0, a, ARRAY_ALLOC_BYTES(newsize), char);
    }
d353 1
a353 3
    xhv->xhv_array = a;
    if (!xhv->xhv_fill)				/* skip rest if no entries */
	return;
d355 2
a356 3
    aep = (HE**)a;
    for (i=0; i<oldsize; i++,aep++) {
	if (!*aep)				/* non-existent */
d358 6
a363 5
	for (oentry = aep, entry = *aep; entry; entry = *oentry) {
	    if ((j = (HeHASH(entry) & newsize)) != i) {
		j -= i;
		*oentry = HeNEXT(entry);
		if (!(HeNEXT(entry) = aep[j]))
d365 1
a365 1
		aep[j] = entry;
d369 1
a369 1
		oentry = &HeNEXT(entry);
d371 1
a371 1
	if (!*aep)				/* everything moved */
d377 1
a377 1
newHV(void)
a386 3
#ifndef NODEFAULT_SHAREKEYS    
    HvSHAREKEYS_on(hv);         /* key-sharing on by default */
#endif    
a393 38
HV *
newHVhv(HV *ohv)
{
    register HV *hv;
    STRLEN hv_max = ohv ? HvMAX(ohv) : 0;
    STRLEN hv_fill = ohv ? HvFILL(ohv) : 0;

    hv = newHV();
    while (hv_max && hv_max + 1 >= hv_fill * 2)
	hv_max = hv_max / 2;	/* Is always 2^n-1 */
    HvMAX(hv) = hv_max;
    if (!hv_fill)
	return hv;

#if 0
    if (! SvTIED_mg((SV*)ohv, 'P')) {
	/* Quick way ???*/
    } 
    else 
#endif
    {
	HE *entry;
	I32 hv_riter = HvRITER(ohv);	/* current root of iterator */
	HE *hv_eiter = HvEITER(ohv);	/* current entry of iterator */
	
	/* Slow way */
	hv_iterinit(ohv);
	while (entry = hv_iternext(ohv)) {
	    hv_store(hv, HeKEY(entry), HeKLEN(entry), 
		     SvREFCNT_inc(HeVAL(entry)), HeHASH(entry));
	}
	HvRITER(ohv) = hv_riter;
	HvEITER(ohv) = hv_eiter;
    }
    
    return hv;
}

d395 2
a396 1
hv_free_ent(HV *hv, register HE *entry)
d398 1
a398 3
    SV *val;

    if (!entry)
d400 3
a402 13
    val = HeVAL(entry);
    if (val && isGV(val) && GvCVu(val) && HvNAME(hv))
	PL_sub_generation++;	/* may be deletion of method from stash */
    SvREFCNT_dec(val);
    if (HeKLEN(entry) == HEf_SVKEY) {
	SvREFCNT_dec(HeKEY_sv(entry));
        Safefree(HeKEY_hek(entry));
    }
    else if (HvSHAREKEYS(hv))
	unshare_hek(HeKEY_hek(entry));
    else
	Safefree(HeKEY_hek(entry));
    del_he(entry);
d406 2
a407 1
hv_delayfree_ent(HV *hv, register HE *entry)
d409 1
a409 1
    if (!entry)
d411 3
a413 12
    if (isGV(HeVAL(entry)) && GvCVu(HeVAL(entry)) && HvNAME(hv))
	PL_sub_generation++;	/* may be deletion of method from stash */
    sv_2mortal(HeVAL(entry));	/* free between statements */
    if (HeKLEN(entry) == HEf_SVKEY) {
	sv_2mortal(HeKEY_sv(entry));
	Safefree(HeKEY_hek(entry));
    }
    else if (HvSHAREKEYS(hv))
	unshare_hek(HeKEY_hek(entry));
    else
	Safefree(HeKEY_hek(entry));
    del_he(entry);
d417 2
a418 1
hv_clear(HV *hv)
d434 3
a436 2
STATIC void
hfreeentries(HV *hv)
d439 2
a440 2
    register HE *entry;
    register HE *oentry = Null(HE*);
d452 1
a452 1
    entry = array[0];
d454 4
a457 4
	if (entry) {
	    oentry = entry;
	    entry = HeNEXT(entry);
	    hv_free_ent(hv, oentry);
d459 1
a459 1
	if (!entry) {
d462 1
a462 1
	    entry = array[riter];
d469 2
a470 1
hv_undef(HV *hv)
d483 1
a483 1
    xhv->xhv_max = 7;		/* it's a normal hash */
d492 2
a493 1
hv_iterinit(HV *hv)
d495 4
a498 15
    register XPVHV* xhv;
    HE *entry;

    if (!hv)
	croak("Bad hash");
    xhv = (XPVHV*)SvANY(hv);
    entry = xhv->xhv_eiter;
#ifdef DYNAMIC_ENV_FETCH  /* set up %ENV for iteration */
    if (HvNAME(hv) && strEQ(HvNAME(hv), ENV_HV_NAME))
	prime_env_iter();
#endif
    if (entry && HvLAZYDEL(hv)) {	/* was deleted earlier? */
	HvLAZYDEL_off(hv);
	hv_free_ent(hv, entry);
    }
d501 1
a501 1
    return xhv->xhv_keys;	/* used to be xhv->xhv_fill before 5.004_65 */
d505 2
a506 1
hv_iternext(HV *hv)
d514 1
a514 1
	croak("Bad hash");
d518 1
a518 1
    if (mg = SvTIED_mg((SV*)hv, 'P')) {
d521 2
a522 2
	    sv_setsv(key, HeSVKEY_force(entry));
	    SvREFCNT_dec(HeSVKEY(entry));	/* get rid of previous key */
d525 1
a525 4
	    char *k;
	    HEK *hek;

	    xhv->xhv_eiter = entry = new_he();  /* one HE per MAGICAL hash */
a526 4
	    Newz(54, k, HEK_BASESIZE + sizeof(SV*), char);
	    hek = (HEK*)k;
	    HeKEY_hek(entry) = hek;
	    HeKLEN(entry) = HEf_SVKEY;
d530 6
a535 3
	    /* force key to stay around until next time */
	    HeSVKEY_set(entry, SvREFCNT_inc(key));
	    return entry;		/* beware, hent_val is not set */
d537 2
a538 3
	if (HeVAL(entry))
	    SvREFCNT_dec(HeVAL(entry));
	Safefree(HeKEY_hek(entry));
d545 11
a555 8
	Newz(506,xhv->xhv_array, ARRAY_ALLOC_BYTES(xhv->xhv_max + 1), char);
    if (entry)
	entry = HeNEXT(entry);
    while (!entry) {
	++xhv->xhv_riter;
	if (xhv->xhv_riter > xhv->xhv_max) {
	    xhv->xhv_riter = -1;
	    break;
d557 1
a557 2
	entry = ((HE**)xhv->xhv_array)[xhv->xhv_riter];
    }
d559 2
a560 4
    if (oldentry && HvLAZYDEL(hv)) {		/* was deleted earlier? */
	HvLAZYDEL_off(hv);
	hv_free_ent(hv, oldentry);
    }
d567 3
a569 1
hv_iterkey(register HE *entry, I32 *retlen)
d571 2
a572 10
    if (HeKLEN(entry) == HEf_SVKEY) {
	STRLEN len;
	char *p = SvPV(HeKEY_sv(entry), len);
	*retlen = len;
	return p;
    }
    else {
	*retlen = HeKLEN(entry);
	return HeKEY(entry);
    }
a574 1
/* unlike hv_iterval(), this always returns a mortal copy of the key */
d576 3
a578 11
hv_iterkeysv(register HE *entry)
{
    if (HeKLEN(entry) == HEf_SVKEY)
	return sv_mortalcopy(HeKEY_sv(entry));
    else
	return sv_2mortal(newSVpv((HeKLEN(entry) ? HeKEY(entry) : ""),
				  HeKLEN(entry)));
}

SV *
hv_iterval(HV *hv, register HE *entry)
d583 1
a583 3
	    if (HeKLEN(entry) == HEf_SVKEY)
		mg_copy((SV*)hv, sv, (char*)HeKEY_sv(entry), HEf_SVKEY);
	    else mg_copy((SV*)hv, sv, HeKEY(entry), HeKLEN(entry));
d587 1
a587 1
    return HeVAL(entry);
d591 4
a594 1
hv_iternextsv(HV *hv, char **key, I32 *retlen)
d604 4
a607 1
hv_magic(HV *hv, GV *gv, int how)
a610 105

char*	
sharepvn(char *sv, I32 len, U32 hash)
{
    return HEK_KEY(share_hek(sv, len, hash));
}

/* possibly free a shared string if no one has access to it
 * len and hash must both be valid for str.
 */
void
unsharepvn(char *str, I32 len, U32 hash)
{
    register XPVHV* xhv;
    register HE *entry;
    register HE **oentry;
    register I32 i = 1;
    I32 found = 0;
    
    /* what follows is the moral equivalent of:
    if ((Svp = hv_fetch(PL_strtab, tmpsv, FALSE, hash))) {
	if (--*Svp == Nullsv)
	    hv_delete(PL_strtab, str, len, G_DISCARD, hash);
    } */
    xhv = (XPVHV*)SvANY(PL_strtab);
    /* assert(xhv_array != 0) */
    LOCK_STRTAB_MUTEX;
    oentry = &((HE**)xhv->xhv_array)[hash & (I32) xhv->xhv_max];
    for (entry = *oentry; entry; i=0, oentry = &HeNEXT(entry), entry = *oentry) {
	if (HeHASH(entry) != hash)		/* strings can't be equal */
	    continue;
	if (HeKLEN(entry) != len)
	    continue;
	if (memNE(HeKEY(entry),str,len))	/* is this it? */
	    continue;
	found = 1;
	if (--HeVAL(entry) == Nullsv) {
	    *oentry = HeNEXT(entry);
	    if (i && !*oentry)
		xhv->xhv_fill--;
	    Safefree(HeKEY_hek(entry));
	    del_he(entry);
	    --xhv->xhv_keys;
	}
	break;
    }
    UNLOCK_STRTAB_MUTEX;
    
    if (!found)
	warn("Attempt to free non-existent shared string");    
}

/* get a (constant) string ptr from the global string table
 * string will get added if it is not already there.
 * len and hash must both be valid for str.
 */
HEK *
share_hek(char *str, I32 len, register U32 hash)
{
    register XPVHV* xhv;
    register HE *entry;
    register HE **oentry;
    register I32 i = 1;
    I32 found = 0;

    /* what follows is the moral equivalent of:
       
    if (!(Svp = hv_fetch(PL_strtab, str, len, FALSE)))
    	hv_store(PL_strtab, str, len, Nullsv, hash);
    */
    xhv = (XPVHV*)SvANY(PL_strtab);
    /* assert(xhv_array != 0) */
    LOCK_STRTAB_MUTEX;
    oentry = &((HE**)xhv->xhv_array)[hash & (I32) xhv->xhv_max];
    for (entry = *oentry; entry; i=0, entry = HeNEXT(entry)) {
	if (HeHASH(entry) != hash)		/* strings can't be equal */
	    continue;
	if (HeKLEN(entry) != len)
	    continue;
	if (memNE(HeKEY(entry),str,len))	/* is this it? */
	    continue;
	found = 1;
	break;
    }
    if (!found) {
	entry = new_he();
	HeKEY_hek(entry) = save_hek(str, len, hash);
	HeVAL(entry) = Nullsv;
	HeNEXT(entry) = *oentry;
	*oentry = entry;
	xhv->xhv_keys++;
	if (i) {				/* initial entry? */
	    ++xhv->xhv_fill;
	    if (xhv->xhv_keys > xhv->xhv_max)
		hsplit(PL_strtab);
	}
    }

    ++HeVAL(entry);				/* use value slot as REFCNT */
    UNLOCK_STRTAB_MUTEX;
    return HeKEY_hek(entry);
}



@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2000, Larry Wall
a14 1
#define PERL_IN_HV_C
d17 14
d32 1
a32 1
S_new_he(pTHX)
d45 1
a45 1
S_del_he(pTHX_ HE *p)
d54 1
a54 1
S_more_he(pTHX)
a67 12
#ifdef PURIFY

#define new_HE() (HE*)safemalloc(sizeof(HE))
#define del_HE(p) safefree((char*)p)

#else

#define new_HE() new_he()
#define del_HE(p) del_he(p)

#endif

d69 1
a69 1
S_save_hek(pTHX_ const char *str, I32 len, U32 hash)
d84 1
a84 1
Perl_unshare_hek(pTHX_ HEK *hek)
a88 29
#if defined(USE_ITHREADS)
HE *
Perl_he_dup(pTHX_ HE *e, bool shared)
{
    HE *ret;

    if (!e)
	return Nullhe;
    /* look for it in the table first */
    ret = (HE*)ptr_table_fetch(PL_ptr_table, e);
    if (ret)
	return ret;

    /* create anew and remember what it is */
    ret = new_HE();
    ptr_table_store(PL_ptr_table, e, ret);

    HeNEXT(ret) = he_dup(HeNEXT(e),shared);
    if (HeKLEN(e) == HEf_SVKEY)
	HeKEY_sv(ret) = SvREFCNT_inc(sv_dup(HeKEY_sv(e)));
    else if (shared)
	HeKEY_hek(ret) = share_hek(HeKEY(e), HeKLEN(e), HeHASH(e));
    else
	HeKEY_hek(ret) = save_hek(HeKEY(e), HeKLEN(e), HeHASH(e));
    HeVAL(ret) = SvREFCNT_inc(sv_dup(HeVAL(e)));
    return ret;
}
#endif	/* USE_ITHREADS */

a91 14
/*
=for apidoc hv_fetch

Returns the SV which corresponds to the specified key in the hash.  The
C<klen> is the length of the key.  If C<lval> is set then the fetch will be
part of a store.  Check that the return value is non-null before
dereferencing it to a C<SV*>. 

See L<perlguts/"Understanding the Magic of Tied Hashes and Arrays"> for more
information on how to use this function on tied hashes.

=cut
*/

d93 1
a93 1
Perl_hv_fetch(pTHX_ HV *hv, const char *key, U32 klen, I32 lval)
d116 1
a116 1
		    char *nkey = strupr(SvPVX(sv_2mortal(newSVpvn(key,klen))));
d133 1
a133 2
	    Newz(503, xhv->xhv_array,
		 PERL_HV_ARRAY_ALLOC_BYTES(xhv->xhv_max + 1), char);
d152 7
a158 7
	unsigned long len;
	char *env = PerlEnv_ENVgetenv_len(key,&len);
	if (env) {
	    sv = newSVpvn(env,len);
	    SvTAINTED_on(sv);
	    return hv_store(hv,key,klen,sv,hash);
	}
a169 17
/*
=for apidoc hv_fetch_ent

Returns the hash entry which corresponds to the specified key in the hash.
C<hash> must be a valid precomputed hash number for the given C<key>, or 0
if you want the function to compute it.  IF C<lval> is set then the fetch
will be part of a store.  Make sure the return value is non-null before
accessing it.  The return value when C<tb> is a tied hash is a pointer to a
static location, so be sure to make a copy of the structure if you need to
store it somewhere. 

See L<perlguts/"Understanding the Magic of Tied Hashes and Arrays"> for more
information on how to use this function on tied hashes.

=cut
*/

d171 1
a171 1
Perl_hv_fetch_ent(pTHX_ HV *hv, SV *keysv, I32 lval, register U32 hash)
d203 1
a203 1
		    SV *nkeysv = sv_2mortal(newSVpvn(key,klen));
d221 1
a221 2
	    Newz(503, xhv->xhv_array,
		 PERL_HV_ARRAY_ALLOC_BYTES(xhv->xhv_max + 1), char);
d243 7
a249 7
	unsigned long len;
	char *env = PerlEnv_ENVgetenv_len(key,&len);
	if (env) {
	    sv = newSVpvn(env,len);
	    SvTAINTED_on(sv);
	    return hv_store_ent(hv,keysv,sv,hash);
	}
d259 2
a260 2
STATIC void
S_hv_magic_check(pTHX_ HV *hv, bool *needs_copy, bool *needs_store)
a277 18
/*
=for apidoc hv_store

Stores an SV in a hash.  The hash key is specified as C<key> and C<klen> is
the length of the key.  The C<hash> parameter is the precomputed hash
value; if it is zero then Perl will compute it.  The return value will be
NULL if the operation failed or if the value did not need to be actually
stored within the hash (as in the case of tied hashes).  Otherwise it can
be dereferenced to get the original C<SV*>.  Note that the caller is
responsible for suitably incrementing the reference count of C<val> before
the call, and decrementing it if the function returned NULL.  

See L<perlguts/"Understanding the Magic of Tied Hashes and Arrays"> for more
information on how to use this function on tied hashes.

=cut
*/

d279 1
a279 1
Perl_hv_store(pTHX_ HV *hv, const char *key, U32 klen, SV *val, register U32 hash)
d300 1
a300 1
		SV *sv = sv_2mortal(newSVpvn(key,klen));
d311 1
a311 2
	Newz(505, xhv->xhv_array,
	     PERL_HV_ARRAY_ALLOC_BYTES(xhv->xhv_max + 1), char);
d328 1
a328 1
    entry = new_HE();
a346 19
/*
=for apidoc hv_store_ent

Stores C<val> in a hash.  The hash key is specified as C<key>.  The C<hash>
parameter is the precomputed hash value; if it is zero then Perl will
compute it.  The return value is the new hash entry so created.  It will be
NULL if the operation failed or if the value did not need to be actually
stored within the hash (as in the case of tied hashes).  Otherwise the
contents of the return value can be accessed using the C<He???> macros
described here.  Note that the caller is responsible for suitably
incrementing the reference count of C<val> before the call, and
decrementing it if the function returned NULL. 

See L<perlguts/"Understanding the Magic of Tied Hashes and Arrays"> for more
information on how to use this function on tied hashes.

=cut
*/

d348 1
a348 1
Perl_hv_store_ent(pTHX_ HV *hv, SV *keysv, SV *val, register U32 hash)
d378 1
a378 1
		keysv = sv_2mortal(newSVpvn(key,klen));
d392 1
a392 2
	Newz(505, xhv->xhv_array,
	     PERL_HV_ARRAY_ALLOC_BYTES(xhv->xhv_max + 1), char);
d409 1
a409 1
    entry = new_HE();
a427 11
/*
=for apidoc hv_delete

Deletes a key/value pair in the hash.  The value SV is removed from the
hash and returned to the caller.  The C<klen> is the length of the key. 
The C<flags> value will normally be zero; if set to G_DISCARD then NULL
will be returned.

=cut
*/

d429 1
a429 1
Perl_hv_delete(pTHX_ HV *hv, const char *key, U32 klen, I32 flags)
d458 1
a458 1
		sv = sv_2mortal(newSVpvn(key,klen));
d485 2
a486 4
	else {
	    sv = sv_2mortal(HeVAL(entry));
	    HeVAL(entry) = &PL_sv_undef;
	}
a496 11
/*
=for apidoc hv_delete_ent

Deletes a key/value pair in the hash.  The value SV is removed from the
hash and returned to the caller.  The C<flags> value will normally be zero;
if set to G_DISCARD then NULL will be returned.  C<hash> can be a valid
precomputed hash value, or 0 to ask for it to be computed.

=cut
*/

d498 1
a498 1
Perl_hv_delete_ent(pTHX_ HV *hv, SV *keysv, I32 flags, U32 hash)
d528 1
a528 1
		keysv = sv_2mortal(newSVpvn(key,klen));
d559 2
a560 4
	else {
	    sv = sv_2mortal(HeVAL(entry));
	    HeVAL(entry) = &PL_sv_undef;
	}
a570 9
/*
=for apidoc hv_exists

Returns a boolean indicating whether the specified hash key exists.  The
C<klen> is the length of the key.

=cut
*/

d572 1
a572 1
Perl_hv_exists(pTHX_ HV *hv, const char *key, U32 klen)
d592 1
a592 1
	    sv = sv_2mortal(newSVpvn(key,klen));
a598 1
#ifndef DYNAMIC_ENV_FETCH
a600 1
#endif
a603 4
#ifdef DYNAMIC_ENV_FETCH
    if (!xhv->xhv_array) entry = Null(HE*);
    else
#endif
a613 12
#ifdef DYNAMIC_ENV_FETCH  /* is it out there? */
    if (HvNAME(hv) && strEQ(HvNAME(hv), ENV_HV_NAME)) {
	unsigned long len;
	char *env = PerlEnv_ENVgetenv_len(key,&len);
	if (env) {
	    sv = newSVpvn(env,len);
	    SvTAINTED_on(sv);
	    (void)hv_store(hv,key,klen,sv,hash);
	    return TRUE;
	}
    }
#endif
a617 10
/*
=for apidoc hv_exists_ent

Returns a boolean indicating whether the specified hash key exists. C<hash>
can be a valid precomputed hash value, or 0 to ask for it to be
computed.

=cut
*/

d619 1
a619 1
Perl_hv_exists_ent(pTHX_ HV *hv, SV *keysv, U32 hash)
d642 1
a642 1
	    keysv = sv_2mortal(newSVpvn(key,klen));
a649 1
#ifndef DYNAMIC_ENV_FETCH
a651 1
#endif
a656 4
#ifdef DYNAMIC_ENV_FETCH
    if (!xhv->xhv_array) entry = Null(HE*);
    else
#endif
a666 12
#ifdef DYNAMIC_ENV_FETCH  /* is it out there? */
    if (HvNAME(hv) && strEQ(HvNAME(hv), ENV_HV_NAME)) {
	unsigned long len;
	char *env = PerlEnv_ENVgetenv_len(key,&len);
	if (env) {
	    sv = newSVpvn(env,len);
	    SvTAINTED_on(sv);
	    (void)hv_store_ent(hv,keysv,sv,hash);
	    return TRUE;
	}
    }
#endif
d671 1
a671 1
S_hsplit(pTHX_ HV *hv)
d685 1
a685 1
    Renew(a, PERL_HV_ARRAY_ALLOC_BYTES(newsize), char);
d692 1
a692 1
    New(2, a, PERL_HV_ARRAY_ALLOC_BYTES(newsize), char);
d699 1
a699 1
	offer_nice_chunk(xhv->xhv_array, PERL_HV_ARRAY_ALLOC_BYTES(oldsize));
d733 1
a733 1
Perl_hv_ksplit(pTHX_ HV *hv, IV newmax)
d760 1
a760 1
	Renew(a, PERL_HV_ARRAY_ALLOC_BYTES(newsize), char);
d766 1
a766 1
	New(2, a, PERL_HV_ARRAY_ALLOC_BYTES(newsize), char);
d773 1
a773 1
	    offer_nice_chunk(xhv->xhv_array, PERL_HV_ARRAY_ALLOC_BYTES(oldsize));
d782 1
a782 1
	Newz(0, a, PERL_HV_ARRAY_ALLOC_BYTES(newsize), char);
a809 8
/*
=for apidoc newHV

Creates a new HV.  The reference count is set to 1.

=cut
*/

d811 1
a811 1
Perl_newHV(pTHX)
d832 1
a832 1
Perl_newHVhv(pTHX_ HV *ohv)
d858 1
a858 1
	while ((entry = hv_iternext(ohv))) {
d870 1
a870 1
Perl_hv_free_ent(pTHX_ HV *hv, register HE *entry)
d888 1
a888 1
    del_HE(entry);
d892 1
a892 1
Perl_hv_delayfree_ent(pTHX_ HV *hv, register HE *entry)
d907 1
a907 1
    del_HE(entry);
a909 8
/*
=for apidoc hv_clear

Clears a hash, making it empty.

=cut
*/

d911 1
a911 1
Perl_hv_clear(pTHX_ HV *hv)
d928 1
a928 1
S_hfreeentries(pTHX_ HV *hv)
a959 8
/*
=for apidoc hv_undef

Undefines the hash.

=cut
*/

d961 1
a961 1
Perl_hv_undef(pTHX_ HV *hv)
a981 14
/*
=for apidoc hv_iterinit

Prepares a starting point to traverse a hash table.  Returns the number of
keys in the hash (i.e. the same as C<HvKEYS(tb)>).  The return value is
currently only meaningful for hashes without tie magic. 

NOTE: Before version 5.004_65, C<hv_iterinit> used to return the number of
hash buckets that happen to be in use.  If you still need that esoteric
value, you can get it through the macro C<HvFILL(tb)>.

=cut
*/

d983 1
a983 1
Perl_hv_iterinit(pTHX_ HV *hv)
d989 1
a989 1
	Perl_croak(aTHX_ "Bad hash");
d992 4
a1004 8
/*
=for apidoc hv_iternext

Returns entries from a hash iterator.  See C<hv_iterinit>.

=cut
*/

d1006 1
a1006 1
Perl_hv_iternext(pTHX_ HV *hv)
d1014 1
a1014 1
	Perl_croak(aTHX_ "Bad hash");
d1018 1
a1018 1
    if ((mg = SvTIED_mg((SV*)hv, 'P'))) {
d1028 1
a1028 1
	    xhv->xhv_eiter = entry = new_HE();  /* one HE per MAGICAL hash */
d1044 1
a1044 1
	del_HE(entry);
a1047 4
#ifdef DYNAMIC_ENV_FETCH  /* set up %ENV for iteration */
    if (!entry && HvNAME(hv) && strEQ(HvNAME(hv), ENV_HV_NAME))
	prime_env_iter();
#endif
d1050 1
a1050 2
	Newz(506, xhv->xhv_array,
	     PERL_HV_ARRAY_ALLOC_BYTES(xhv->xhv_max + 1), char);
a1070 9
/*
=for apidoc hv_iterkey

Returns the key from the current position of the hash iterator.  See
C<hv_iterinit>.

=cut
*/

d1072 1
a1072 1
Perl_hv_iterkey(pTHX_ register HE *entry, I32 *retlen)
a1086 10
/*
=for apidoc hv_iterkeysv

Returns the key as an C<SV*> from the current position of the hash
iterator.  The return value will always be a mortal copy of the key.  Also
see C<hv_iterinit>.

=cut
*/

d1088 1
a1088 1
Perl_hv_iterkeysv(pTHX_ register HE *entry)
d1093 1
a1093 1
	return sv_2mortal(newSVpvn((HeKLEN(entry) ? HeKEY(entry) : ""),
a1096 9
/*
=for apidoc hv_iterval

Returns the value from the current position of the hash iterator.  See
C<hv_iterkey>.

=cut
*/

d1098 1
a1098 1
Perl_hv_iterval(pTHX_ HV *hv, register HE *entry)
a1111 9
/*
=for apidoc hv_iternextsv

Performs an C<hv_iternext>, C<hv_iterkey>, and C<hv_iterval> in one
operation.

=cut
*/

d1113 1
a1113 1
Perl_hv_iternextsv(pTHX_ HV *hv, char **key, I32 *retlen)
a1121 8
/*
=for apidoc hv_magic

Adds magic to a hash.  See C<sv_magic>.

=cut
*/

d1123 1
a1123 1
Perl_hv_magic(pTHX_ HV *hv, GV *gv, int how)
d1129 1
a1129 1
Perl_sharepvn(pTHX_ const char *sv, I32 len, U32 hash)
d1138 1
a1138 1
Perl_unsharepvn(pTHX_ const char *str, I32 len, U32 hash)
d1168 1
a1168 1
	    del_HE(entry);
d1175 2
a1176 5
    {
        dTHR;
        if (!found && ckWARN_d(WARN_INTERNAL))
	    Perl_warner(aTHX_ WARN_INTERNAL, "Attempt to free non-existent shared string");    
    }
d1184 1
a1184 1
Perl_share_hek(pTHX_ const char *str, I32 len, register U32 hash)
d1212 1
a1212 1
	entry = new_HE();
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2001, Larry Wall
d45 2
a46 6
    XPV *ptr;
    New(54, ptr, 1008/sizeof(XPV), XPV);
    ptr->xpv_pv = (char*)PL_he_arenaroot;
    PL_he_arenaroot = ptr;

    he = (HE*)ptr;
a47 1
    PL_he_root = ++he;
d147 1
d244 1
d461 1
d719 1
d795 1
d1048 2
a1049 2
	    hv_store(hv, HeKEY(entry), HeKLEN(entry),
		     newSVsv(HeVAL(entry)), HeHASH(entry));
d1447 6
a1452 2
    if (!found && ckWARN_d(WARN_INTERNAL))
	Perl_warner(aTHX_ WARN_INTERNAL, "Attempt to free non-existent shared string");    
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2002, Larry Wall
a13 4
/* 
=head1 Hash Manipulation Functions
*/

d24 1
a24 1
	more_he();
d54 2
a55 2
	HeNEXT(he) = (HE*)(he + 1);
	he++;
d73 1
a73 1
S_save_hek_flags(pTHX_ const char *str, I32 len, U32 hash, int flags)
d77 2
a78 2

    New(54, k, HEK_BASESIZE + len + 2, char);
d81 1
a81 1
    HEK_KEY(hek)[len] = 0;
a83 1
    HEK_FLAGS(hek) = (unsigned char)flags;
d87 6
d95 1
a95 1
Perl_he_dup(pTHX_ HE *e, bool shared, CLONE_PARAMS* param)
d110 1
a110 1
    HeNEXT(ret) = he_dup(HeNEXT(e),shared, param);
d112 1
a112 1
	HeKEY_sv(ret) = SvREFCNT_inc(sv_dup(HeKEY_sv(e), param));
d114 1
a114 2
	HeKEY_hek(ret) = share_hek_flags(HeKEY(e), HeKLEN(e), HeHASH(e),
                                         HeKFLAGS(e));
d116 2
a117 3
	HeKEY_hek(ret) = save_hek_flags(HeKEY(e), HeKLEN(e), HeHASH(e),
                                        HeKFLAGS(e));
    HeVAL(ret) = SvREFCNT_inc(sv_dup(HeVAL(e), param));
a121 20
static void
S_hv_notallowed(pTHX_ int flags, const char *key, I32 klen,
		const char *msg)
{
    SV *sv = sv_newmortal(), *esv = sv_newmortal();
    if (!(flags & HVhek_FREEKEY)) {
	sv_setpvn(sv, key, klen);
    }
    else {
	/* Need to free saved eventually assign to mortal SV */
	SV *sv = sv_newmortal();
	sv_usepvn(sv, (char *) key, klen);
    }
    if (flags & HVhek_UTF8) {
	SvUTF8_on(sv);
    }
    Perl_sv_setpvf(aTHX_ esv, "Attempt to %s a restricted hash", msg);
    Perl_croak(aTHX_ SvPVX(esv), sv);
}

d131 1
a131 1
dereferencing it to an C<SV*>.
a138 1

d140 1
a140 32
Perl_hv_fetch(pTHX_ HV *hv, const char *key, I32 klen, I32 lval)
{
    bool is_utf8 = FALSE;
    const char *keysave = key;
    int flags = 0;

    if (klen < 0) {
      klen = -klen;
      is_utf8 = TRUE;
    }

    if (is_utf8) {
	STRLEN tmplen = klen;
	/* Just casting the &klen to (STRLEN) won't work well
	 * if STRLEN and I32 are of different widths. --jhi */
	key = (char*)bytes_from_utf8((U8*)key, &tmplen, &is_utf8);
	klen = tmplen;
        /* If we were able to downgrade here, then than means that we were
           passed in a key which only had chars 0-255, but was utf8 encoded.  */
        if (is_utf8)
            flags = HVhek_UTF8;
        /* If we found we were able to downgrade the string to bytes, then
           we should flag that it needs upgrading on keys or each.  */
        if (key != keysave)
            flags |= HVhek_WASUTF8 | HVhek_FREEKEY;
    }

    return hv_fetch_flags (hv, key, klen, lval, flags);
}

STATIC SV**
S_hv_fetch_flags(pTHX_ HV *hv, const char *key, I32 klen, I32 lval, int flags)
d151 1
a151 6
        /* All this clause seems to be utf8 unaware.
           By moving the utf8 stuff out to hv_fetch_flags I need to ensure
           key doesn't leak. I've not tried solving the utf8-ness.
           NWC.
        */
	if (mg_find((SV*)hv, PERL_MAGIC_tied) || SvGMAGICAL((SV*)hv)) {
a153 2
            if (flags & HVhek_FREEKEY)
                Safefree(key);
d158 2
a159 2
	else if (mg_find((SV*)hv, PERL_MAGIC_env)) {
	    I32 i;
d164 2
a165 5
		    if (!ret && lval) {
			ret = hv_store_flags(hv, key, klen, NEWSV(61,0), 0,
                                             flags);
                    } else if (flags & HVhek_FREEKEY)
                        Safefree(key);
a171 2
    /* We use xhv->xhv_foo fields directly instead of HvFOO(hv) to
       avoid unnecessary pointer dereferencing. */
d173 2
a174 2
    if (!xhv->xhv_array /* !HvARRAY(hv) */) {
	if (lval
d176 1
a176 1
		 || (SvRMAGICAL((SV*)hv) && mg_find((SV*)hv, PERL_MAGIC_env))
d178 4
a181 7
								  )
	    Newz(503, xhv->xhv_array /* HvARRAY(hv) */,
		 PERL_HV_ARRAY_ALLOC_BYTES(xhv->xhv_max+1 /* HvMAX(hv)+1 */),
		 char);
	else {
            if (flags & HVhek_FREEKEY)
                Safefree(key);
a182 1
        }
a186 1
    /* entry = (HvARRAY(hv))[hash & (I32) HvMAX(hv)]; */
d191 1
a191 1
	if (HeKLEN(entry) != (I32)klen)
d193 1
a193 1
	if (HeKEY(entry) != key && memNE(HeKEY(entry),key,klen))	/* is this it? */
a194 27
        /* flags is 0 if not utf8. need HeKFLAGS(entry) also 0.
           flags is 1 if utf8. need HeKFLAGS(entry) also 1.
           xor is true if bits differ, in which case this isn't a match.  */
	if ((HeKFLAGS(entry) ^ flags) & HVhek_UTF8)
	    continue;
        if (lval && HeKFLAGS(entry) != flags) {
            /* We match if HVhek_UTF8 bit in our flags and hash key's match.
               But if entry was set previously with HVhek_WASUTF8 and key now
               doesn't (or vice versa) then we should change the key's flag,
               as this is assignment.  */
            if (HvSHAREKEYS(hv)) {
                /* Need to swap the key we have for a key with the flags we
                   need. As keys are shared we can't just write to the flag,
                   so we share the new one, unshare the old one.  */
                int flags_nofree = flags & ~HVhek_FREEKEY;
                HEK *new_hek = share_hek_flags(key, klen, hash, flags_nofree);
                unshare_hek (HeKEY_hek(entry));
                HeKEY_hek(entry) = new_hek;
            }
            else
                HeKFLAGS(entry) = flags;
        }
        if (flags & HVhek_FREEKEY)
            Safefree(key);
	/* if we find a placeholder, we pretend we haven't found anything */
	if (HeVAL(entry) == &PL_sv_undef)
	    break;
a195 1

d198 1
a198 1
    if (SvRMAGICAL((SV*)hv) && mg_find((SV*)hv, PERL_MAGIC_env)) {
a203 2
	    if (flags & HVhek_FREEKEY)
		Safefree(key);
a207 5
    if (!entry && SvREADONLY(hv)) {
	S_hv_notallowed(aTHX_ flags, key, klen,
			"access disallowed key '%"SVf"' in"
			);
    }
d210 1
a210 1
        return hv_store_flags(hv,key,klen,sv,hash,flags);
a211 2
    if (flags & HVhek_FREEKEY)
        Safefree(key);
d215 1
a215 1
/* returns an HE * structure with the all fields set */
d226 1
a226 1
store it somewhere.
a241 3
    bool is_utf8;
    int flags = 0;
    char *keysave;
d247 1
a247 1
	if (mg_find((SV*)hv, PERL_MAGIC_tied) || SvGMAGICAL((SV*)hv)) {
d261 1
a261 1
	else if (mg_find((SV*)hv, PERL_MAGIC_env)) {
d278 2
a279 2
    if (!xhv->xhv_array /* !HvARRAY(hv) */) {
	if (lval
d281 1
a281 1
		 || (SvRMAGICAL((SV*)hv) && mg_find((SV*)hv, PERL_MAGIC_env))
d283 3
a285 4
								  )
	    Newz(503, xhv->xhv_array /* HvARRAY(hv) */,
		 PERL_HV_ARRAY_ALLOC_BYTES(xhv->xhv_max+1 /* HvMAX(hv)+1 */),
		 char);
d290 2
a291 11
    keysave = key = SvPV(keysv, klen);
    is_utf8 = (SvUTF8(keysv)!=0);

    if (is_utf8) {
	key = (char*)bytes_from_utf8((U8*)key, &klen, &is_utf8);
        if (is_utf8)
            flags = HVhek_UTF8;
        if (key != keysave)
            flags |= HVhek_WASUTF8 | HVhek_FREEKEY;
    }

a294 1
    /* entry = (HvARRAY(hv))[hash & (I32) HvMAX(hv)]; */
d299 1
a299 3
	if (HeKLEN(entry) != (I32)klen)
	    continue;
	if (HeKEY(entry) != key && memNE(HeKEY(entry),key,klen))	/* is this it? */
d301 1
a301 1
	if ((HeKFLAGS(entry) ^ flags) & HVhek_UTF8)
a302 22
        if (lval && HeKFLAGS(entry) != flags) {
            /* We match if HVhek_UTF8 bit in our flags and hash key's match.
               But if entry was set previously with HVhek_WASUTF8 and key now
               doesn't (or vice versa) then we should change the key's flag,
               as this is assignment.  */
            if (HvSHAREKEYS(hv)) {
                /* Need to swap the key we have for a key with the flags we
                   need. As keys are shared we can't just write to the flag,
                   so we share the new one, unshare the old one.  */
                int flags_nofree = flags & ~HVhek_FREEKEY;
                HEK *new_hek = share_hek_flags(key, klen, hash, flags_nofree);
                unshare_hek (HeKEY_hek(entry));
                HeKEY_hek(entry) = new_hek;
            }
            else
                HeKFLAGS(entry) = flags;
        }
	if (key != keysave)
	    Safefree(key);
	/* if we find a placeholder, we pretend we haven't found anything */
	if (HeVAL(entry) == &PL_sv_undef)
	    break;
d306 1
a306 1
    if (SvRMAGICAL((SV*)hv) && mg_find((SV*)hv, PERL_MAGIC_env)) {
a315 7
    if (!entry && SvREADONLY(hv)) {
	S_hv_notallowed(aTHX_ flags, key, klen,
			"access disallowed key '%"SVf"' in"
			);
    }
    if (flags & HVhek_FREEKEY)
	Safefree(key);
d333 2
a334 2
	    case PERL_MAGIC_tied:
	    case PERL_MAGIC_sig:
d352 1
a352 1
the call, and decrementing it if the function returned NULL.
d361 1
a361 33
Perl_hv_store(pTHX_ HV *hv, const char *key, I32 klen, SV *val, U32 hash)
{
    bool is_utf8 = FALSE;
    const char *keysave = key;
    int flags = 0;

    if (klen < 0) {
      klen = -klen;
      is_utf8 = TRUE;
    }

    if (is_utf8) {
	STRLEN tmplen = klen;
	/* Just casting the &klen to (STRLEN) won't work well
	 * if STRLEN and I32 are of different widths. --jhi */
	key = (char*)bytes_from_utf8((U8*)key, &tmplen, &is_utf8);
	klen = tmplen;
        /* If we were able to downgrade here, then than means that we were
           passed in a key which only had chars 0-255, but was utf8 encoded.  */
        if (is_utf8)
            flags = HVhek_UTF8;
        /* If we found we were able to downgrade the string to bytes, then
           we should flag that it needs upgrading on keys or each.  */
        if (key != keysave)
            flags |= HVhek_WASUTF8 | HVhek_FREEKEY;
    }

    return hv_store_flags (hv, key, klen, val, hash, flags);
}

SV**
Perl_hv_store_flags(pTHX_ HV *hv, const char *key, I32 klen, SV *val,
                 register U32 hash, int flags)
d378 1
a378 3
	    if (!xhv->xhv_array /* !HvARRAY */ && !needs_store) {
                if (flags & HVhek_FREEKEY)
                    Safefree(key);
a379 1
            }
d381 3
a383 3
	    else if (mg_find((SV*)hv, PERL_MAGIC_env)) {
		key = savepvn(key,klen);
		key = (const char*)strupr((char*)key);
a388 4

    if (flags)
        HvHASKFLAGS_on((SV*)hv);

d392 3
a394 4
    if (!xhv->xhv_array /* !HvARRAY(hv) */)
	Newz(505, xhv->xhv_array /* HvARRAY(hv) */,
	     PERL_HV_ARRAY_ALLOC_BYTES(xhv->xhv_max+1 /* HvMAX(hv)+1 */),
	     char);
a395 1
    /* oentry = &(HvARRAY(hv))[hash & (I32) HvMAX(hv)]; */
d402 1
a402 1
	if (HeKLEN(entry) != (I32)klen)
d404 1
a404 1
	if (HeKEY(entry) != key && memNE(HeKEY(entry),key,klen))	/* is this it? */
d406 2
a407 33
	if ((HeKFLAGS(entry) ^ flags) & HVhek_UTF8)
	    continue;
	if (HeVAL(entry) == &PL_sv_undef)
	    xhv->xhv_placeholders--; /* yes, can store into placeholder slot */
	else
	    SvREFCNT_dec(HeVAL(entry));
        if (flags & HVhek_PLACEHOLD) {
            /* We have been requested to insert a placeholder. Currently
               only Storable is allowed to do this.  */
            xhv->xhv_placeholders++;
            HeVAL(entry) = &PL_sv_undef;
        } else
            HeVAL(entry) = val;

        if (HeKFLAGS(entry) != flags) {
            /* We match if HVhek_UTF8 bit in our flags and hash key's match.
               But if entry was set previously with HVhek_WASUTF8 and key now
               doesn't (or vice versa) then we should change the key's flag,
               as this is assignment.  */
            if (HvSHAREKEYS(hv)) {
                /* Need to swap the key we have for a key with the flags we
                   need. As keys are shared we can't just write to the flag,
                   so we share the new one, unshare the old one.  */
                int flags_nofree = flags & ~HVhek_FREEKEY;
                HEK *new_hek = share_hek_flags(key, klen, hash, flags_nofree);
                unshare_hek (HeKEY_hek(entry));
                HeKEY_hek(entry) = new_hek;
            }
            else
                HeKFLAGS(entry) = flags;
        }
        if (flags & HVhek_FREEKEY)
            Safefree(key);
a410 6
    if (SvREADONLY(hv)) {
	S_hv_notallowed(aTHX_ flags, key, klen,
			"access disallowed key '%"SVf"' to"
			);
    }

a411 2
    /* share_hek_flags will do the free for us.  This might be considered
       bad API design.  */
d413 1
a413 1
	HeKEY_hek(entry) = share_hek_flags(key, klen, hash, flags);
d415 2
a416 8
	HeKEY_hek(entry) = save_hek_flags(key, klen, hash, flags);
    if (flags & HVhek_PLACEHOLD) {
        /* We have been requested to insert a placeholder. Currently
           only Storable is allowed to do this.  */
        xhv->xhv_placeholders++;
        HeVAL(entry) = &PL_sv_undef;
    } else
        HeVAL(entry) = val;
d420 1
a420 1
    xhv->xhv_keys++; /* HvKEYS(hv)++ */
d422 2
a423 2
	xhv->xhv_fill++; /* HvFILL(hv)++ */
	if (xhv->xhv_keys > (IV)xhv->xhv_max /* HvKEYS(hv) > HvMAX(hv) */)
d438 1
a438 1
contents of the return value can be accessed using the C<He?> macros
d441 1
a441 1
decrementing it if the function returned NULL.
d450 1
a450 1
Perl_hv_store_ent(pTHX_ HV *hv, SV *keysv, SV *val, U32 hash)
d452 2
a453 2
    XPVHV* xhv;
    char *key;
d455 3
a457 6
    I32 i;
    HE *entry;
    HE **oentry;
    bool is_utf8;
    int flags = 0;
    char *keysave;
d464 12
a475 12
	bool needs_copy;
	bool needs_store;
	hv_magic_check (hv, &needs_copy, &needs_store);
	if (needs_copy) {
	    bool save_taint = PL_tainted;
	    if (PL_tainting)
		PL_tainted = SvTAINTED(keysv);
	    keysv = sv_2mortal(newSVsv(keysv));
	    mg_copy((SV*)hv, val, (char*)keysv, HEf_SVKEY);
	    TAINT_IF(save_taint);
	    if (!xhv->xhv_array /* !HvARRAY(hv) */ && !needs_store)
		return Nullhe;
d477 1
a477 1
	    else if (mg_find((SV*)hv, PERL_MAGIC_env)) {
d487 1
a487 11
    keysave = key = SvPV(keysv, klen);
    is_utf8 = (SvUTF8(keysv) != 0);

    if (is_utf8) {
	key = (char*)bytes_from_utf8((U8*)key, &klen, &is_utf8);
        if (is_utf8)
            flags = HVhek_UTF8;
        if (key != keysave)
            flags |= HVhek_WASUTF8 | HVhek_FREEKEY;
        HvHASKFLAGS_on((SV*)hv);
    }
d492 3
a494 4
    if (!xhv->xhv_array /* !HvARRAY(hv) */)
	Newz(505, xhv->xhv_array /* HvARRAY(hv) */,
	     PERL_HV_ARRAY_ALLOC_BYTES(xhv->xhv_max+1 /* HvMAX(hv)+1 */),
	     char);
a495 1
    /* oentry = &(HvARRAY(hv))[hash & (I32) HvMAX(hv)]; */
d498 2
a499 2
    entry = *oentry;
    for (; entry; i=0, entry = HeNEXT(entry)) {
d502 1
a502 1
	if (HeKLEN(entry) != (I32)klen)
d504 1
a504 1
	if (HeKEY(entry) != key && memNE(HeKEY(entry),key,klen))	/* is this it? */
d506 1
a506 6
	if ((HeKFLAGS(entry) ^ flags) & HVhek_UTF8)
	    continue;
	if (HeVAL(entry) == &PL_sv_undef)
	    xhv->xhv_placeholders--; /* yes, can store into placeholder slot */
	else
	    SvREFCNT_dec(HeVAL(entry));
a507 19
        if (HeKFLAGS(entry) != flags) {
            /* We match if HVhek_UTF8 bit in our flags and hash key's match.
               But if entry was set previously with HVhek_WASUTF8 and key now
               doesn't (or vice versa) then we should change the key's flag,
               as this is assignment.  */
            if (HvSHAREKEYS(hv)) {
                /* Need to swap the key we have for a key with the flags we
                   need. As keys are shared we can't just write to the flag,
                   so we share the new one, unshare the old one.  */
                int flags_nofree = flags & ~HVhek_FREEKEY;
                HEK *new_hek = share_hek_flags(key, klen, hash, flags_nofree);
                unshare_hek (HeKEY_hek(entry));
                HeKEY_hek(entry) = new_hek;
            }
            else
                HeKFLAGS(entry) = flags;
        }
        if (flags & HVhek_FREEKEY)
	    Safefree(key);
a510 6
    if (SvREADONLY(hv)) {
	S_hv_notallowed(aTHX_ flags, key, klen,
			"access disallowed key '%"SVf"' to"
			);
    }

a511 2
    /* share_hek_flags will do the free for us.  This might be considered
       bad API design.  */
d513 1
a513 1
	HeKEY_hek(entry) = share_hek_flags(key, klen, hash, flags);
d515 1
a515 1
	HeKEY_hek(entry) = save_hek_flags(key, klen, hash, flags);
d520 1
a520 1
    xhv->xhv_keys++; /* HvKEYS(hv)++ */
d522 2
a523 2
	xhv->xhv_fill++; /* HvFILL(hv)++ */
	if (xhv->xhv_keys > (IV)xhv->xhv_max /* HvKEYS(hv) > HvMAX(hv) */)
d534 1
a534 1
hash and returned to the caller.  The C<klen> is the length of the key.
d542 1
a542 1
Perl_hv_delete(pTHX_ HV *hv, const char *key, I32 klen, I32 flags)
a550 3
    bool is_utf8 = FALSE;
    int k_flags = 0;
    const char *keysave = key;
a553 4
    if (klen < 0) {
      klen = -klen;
      is_utf8 = TRUE;
    }
d563 2
a564 3
		if (mg_find(sv, PERL_MAGIC_tiedelem)) {
		    /* No longer an element */
		    sv_unmagic(sv, PERL_MAGIC_tiedelem);
d570 1
a570 1
	    else if (mg_find((SV*)hv, PERL_MAGIC_env)) {
d575 1
a575 1
	}
d578 1
a578 1
    if (!xhv->xhv_array /* !HvARRAY(hv) */)
a580 11
    if (is_utf8) {
	STRLEN tmplen = klen;
	/* See the note in hv_fetch(). --jhi */
	key = (char*)bytes_from_utf8((U8*)key, &tmplen, &is_utf8);
	klen = tmplen;
        if (is_utf8)
            k_flags = HVhek_UTF8;
        if (key != keysave)
            k_flags |= HVhek_FREEKEY;
    }

a582 1
    /* oentry = &(HvARRAY(hv))[hash & (I32) HvMAX(hv)]; */
d589 1
a589 1
	if (HeKLEN(entry) != (I32)klen)
d591 1
a591 1
	if (HeKEY(entry) != key && memNE(HeKEY(entry),key,klen))	/* is this it? */
d593 3
a595 31
	if ((HeKFLAGS(entry) ^ k_flags) & HVhek_UTF8)
	    continue;
	if (k_flags & HVhek_FREEKEY)
	    Safefree(key);
	/* if placeholder is here, it's already been deleted.... */
	if (HeVAL(entry) == &PL_sv_undef)
	{
	    if (SvREADONLY(hv))
		return Nullsv;  /* if still SvREADONLY, leave it deleted. */
	    else {
		/* okay, really delete the placeholder... */
		*oentry = HeNEXT(entry);
		if (i && !*oentry)
		    xhv->xhv_fill--; /* HvFILL(hv)-- */
		if (entry == xhv->xhv_eiter /* HvEITER(hv) */)
		    HvLAZYDEL_on(hv);
		else
		    hv_free_ent(hv, entry);
		xhv->xhv_keys--; /* HvKEYS(hv)-- */
		if (xhv->xhv_keys == 0)
		    HvHASKFLAGS_off(hv);
		xhv->xhv_placeholders--;
		return Nullsv;
	    }
	}
	else if (SvREADONLY(hv) && HeVAL(entry) && SvREADONLY(HeVAL(entry))) {
	    S_hv_notallowed(aTHX_ k_flags, key, klen,
			    "delete readonly key '%"SVf"' from"
			    );
	}

d602 5
a606 24

	/*
	 * If a restricted hash, rather than really deleting the entry, put
	 * a placeholder there. This marks the key as being "approved", so
	 * we can still access via not-really-existing key without raising
	 * an error.
	 */
	if (SvREADONLY(hv)) {
	    HeVAL(entry) = &PL_sv_undef;
	    /* We'll be saving this slot, so the number of allocated keys
	     * doesn't go down, but the number placeholders goes up */
	    xhv->xhv_placeholders++; /* HvPLACEHOLDERS(hv)++ */
	} else {
	    *oentry = HeNEXT(entry);
	    if (i && !*oentry)
		xhv->xhv_fill--; /* HvFILL(hv)-- */
	    if (entry == xhv->xhv_eiter /* HvEITER(hv) */)
		HvLAZYDEL_on(hv);
	    else
		hv_free_ent(hv, entry);
	    xhv->xhv_keys--; /* HvKEYS(hv)-- */
	    if (xhv->xhv_keys == 0)
	        HvHASKFLAGS_off(hv);
	}
a608 8
    if (SvREADONLY(hv)) {
	S_hv_notallowed(aTHX_ k_flags, key, klen,
			"access disallowed key '%"SVf"' from"
			);
    }

    if (k_flags & HVhek_FREEKEY)
	Safefree(key);
d633 1
a633 4
    bool is_utf8;
    int k_flags = 0;
    char *keysave;

d645 2
a646 3
		if (mg_find(sv, PERL_MAGIC_tiedelem)) {
		    /* No longer an element */
		    sv_unmagic(sv, PERL_MAGIC_tiedelem);
d652 1
a652 1
	    else if (mg_find((SV*)hv, PERL_MAGIC_env)) {
d656 1
a656 1
		hash = 0;
d662 1
a662 1
    if (!xhv->xhv_array /* !HvARRAY(hv) */)
d665 2
a666 11
    keysave = key = SvPV(keysv, klen);
    is_utf8 = (SvUTF8(keysv) != 0);

    if (is_utf8) {
	key = (char*)bytes_from_utf8((U8*)key, &klen, &is_utf8);
        if (is_utf8)
            k_flags = HVhek_UTF8;
        if (key != keysave)
            k_flags |= HVhek_FREEKEY;
    }

a669 1
    /* oentry = &(HvARRAY(hv))[hash & (I32) HvMAX(hv)]; */
d676 1
a676 1
	if (HeKLEN(entry) != (I32)klen)
d678 1
a678 1
	if (HeKEY(entry) != key && memNE(HeKEY(entry),key,klen))	/* is this it? */
d680 3
a682 31
	if ((HeKFLAGS(entry) ^ k_flags) & HVhek_UTF8)
	    continue;
        if (k_flags & HVhek_FREEKEY)
            Safefree(key);

	/* if placeholder is here, it's already been deleted.... */
	if (HeVAL(entry) == &PL_sv_undef)
	{
	    if (SvREADONLY(hv))
		return Nullsv; /* if still SvREADONLY, leave it deleted. */

           /* okay, really delete the placeholder. */
           *oentry = HeNEXT(entry);
           if (i && !*oentry)
               xhv->xhv_fill--; /* HvFILL(hv)-- */
           if (entry == xhv->xhv_eiter /* HvEITER(hv) */)
               HvLAZYDEL_on(hv);
           else
               hv_free_ent(hv, entry);
           xhv->xhv_keys--; /* HvKEYS(hv)-- */
	   if (xhv->xhv_keys == 0)
               HvHASKFLAGS_off(hv);
           xhv->xhv_placeholders--;
           return Nullsv;
	}
	else if (SvREADONLY(hv) && HeVAL(entry) && SvREADONLY(HeVAL(entry))) {
	    S_hv_notallowed(aTHX_ k_flags, key, klen,
			    "delete readonly key '%"SVf"' from"
			    );
	}

d689 5
a693 24

	/*
	 * If a restricted hash, rather than really deleting the entry, put
	 * a placeholder there. This marks the key as being "approved", so
	 * we can still access via not-really-existing key without raising
	 * an error.
	 */
	if (SvREADONLY(hv)) {
	    HeVAL(entry) = &PL_sv_undef;
	    /* We'll be saving this slot, so the number of allocated keys
	     * doesn't go down, but the number placeholders goes up */
	    xhv->xhv_placeholders++; /* HvPLACEHOLDERS(hv)++ */
	} else {
	    *oentry = HeNEXT(entry);
	    if (i && !*oentry)
		xhv->xhv_fill--; /* HvFILL(hv)-- */
	    if (entry == xhv->xhv_eiter /* HvEITER(hv) */)
		HvLAZYDEL_on(hv);
	    else
		hv_free_ent(hv, entry);
	    xhv->xhv_keys--; /* HvKEYS(hv)-- */
	    if (xhv->xhv_keys == 0)
	        HvHASKFLAGS_off(hv);
	}
a695 8
    if (SvREADONLY(hv)) {
        S_hv_notallowed(aTHX_ k_flags, key, klen,
			"delete disallowed key '%"SVf"' from"
			);
    }

    if (k_flags & HVhek_FREEKEY)
	Safefree(key);
d709 1
a709 1
Perl_hv_exists(pTHX_ HV *hv, const char *key, I32 klen)
a714 3
    bool is_utf8 = FALSE;
    const char *keysave = key;
    int k_flags = 0;
a718 5
    if (klen < 0) {
      klen = -klen;
      is_utf8 = TRUE;
    }

d720 1
a720 1
	if (mg_find((SV*)hv, PERL_MAGIC_tied) || SvGMAGICAL((SV*)hv)) {
d722 3
a724 3
	    mg_copy((SV*)hv, sv, key, klen);
	    magic_existspack(sv, mg_find(sv, PERL_MAGIC_tiedelem));
	    return (bool)SvTRUE(sv);
d727 1
a727 1
	else if (mg_find((SV*)hv, PERL_MAGIC_env)) {
d736 2
a737 2
    if (!xhv->xhv_array /* !HvARRAY(hv) */)
	return 0;
a739 11
    if (is_utf8) {
	STRLEN tmplen = klen;
	/* See the note in hv_fetch(). --jhi */
	key = (char*)bytes_from_utf8((U8*)key, &tmplen, &is_utf8);
	klen = tmplen;
        if (is_utf8)
            k_flags = HVhek_UTF8;
        if (key != keysave)
            k_flags |= HVhek_FREEKEY;
    }

d743 1
a743 1
    if (!xhv->xhv_array /* !HvARRAY(hv) */) entry = Null(HE*);
a745 1
    /* entry = (HvARRAY(hv))[hash & (I32) HvMAX(hv)]; */
d752 1
a752 3
	if (HeKEY(entry) != key && memNE(HeKEY(entry),key,klen))	/* is this it? */
	    continue;
	if ((HeKFLAGS(entry) ^ k_flags) & HVhek_UTF8)
a753 6
	if (k_flags & HVhek_FREEKEY)
	    Safefree(key);
	/* If we find the key, but the value is a placeholder, return false. */
	if (HeVAL(entry) == &PL_sv_undef)
	    return FALSE;

d757 1
a757 1
    if (SvRMAGICAL((SV*)hv) && mg_find((SV*)hv, PERL_MAGIC_env)) {
a763 2
            if (k_flags & HVhek_FREEKEY)
                Safefree(key);
a767 2
    if (k_flags & HVhek_FREEKEY)
        Safefree(key);
a789 3
    bool is_utf8;
    char *keysave;
    int k_flags = 0;
d795 1
a795 2
	if (mg_find((SV*)hv, PERL_MAGIC_tied) || SvGMAGICAL((SV*)hv)) {
	   SV* svret = sv_newmortal();
d798 3
a800 3
	    mg_copy((SV*)hv, sv, (char*)keysv, HEf_SVKEY);
	   magic_existspack(svret, mg_find(sv, PERL_MAGIC_tiedelem));
	   return (bool)SvTRUE(svret);
d803 1
a803 1
	else if (mg_find((SV*)hv, PERL_MAGIC_env)) {
d807 1
a807 1
	    hash = 0;
d814 2
a815 2
    if (!xhv->xhv_array /* !HvARRAY(hv) */)
	return 0;
d818 1
a818 9
    keysave = key = SvPV(keysv, klen);
    is_utf8 = (SvUTF8(keysv) != 0);
    if (is_utf8) {
	key = (char*)bytes_from_utf8((U8*)key, &klen, &is_utf8);
        if (is_utf8)
            k_flags = HVhek_UTF8;
        if (key != keysave)
            k_flags |= HVhek_FREEKEY;
    }
d823 1
a823 1
    if (!xhv->xhv_array /* !HvARRAY(hv) */) entry = Null(HE*);
a825 1
    /* entry = (HvARRAY(hv))[hash & (I32) HvMAX(hv)]; */
d830 1
a830 3
	if (HeKLEN(entry) != (I32)klen)
	    continue;
	if (HeKEY(entry) != key && memNE(HeKEY(entry),key,klen))	/* is this it? */
d832 1
a832 1
	if ((HeKFLAGS(entry) ^ k_flags) & HVhek_UTF8)
a833 5
	if (k_flags & HVhek_FREEKEY)
	    Safefree(key);
	/* If we find the key, but the value is a placeholder, return false. */
	if (HeVAL(entry) == &PL_sv_undef)
	    return FALSE;
d837 1
a837 1
    if (SvRMAGICAL((SV*)hv) && mg_find((SV*)hv, PERL_MAGIC_env)) {
a843 2
            if (k_flags & HVhek_FREEKEY)
                Safefree(key);
a847 2
    if (k_flags & HVhek_FREEKEY)
        Safefree(key);
d855 1
a855 1
    I32 oldsize = (I32) xhv->xhv_max+1; /* HvMAX(hv)+1 (sick) */
d858 1
a858 1
    register char *a = xhv->xhv_array; /* HvARRAY(hv) */
d872 1
d878 1
a878 1
    Copy(xhv->xhv_array /* HvARRAY(hv) */, a, oldsize * sizeof(HE*), char);
d880 1
a880 2
	offer_nice_chunk(xhv->xhv_array /* HvARRAY(hv) */,
			PERL_HV_ARRAY_ALLOC_BYTES(oldsize));
d883 1
a883 1
	Safefree(xhv->xhv_array /* HvARRAY(hv) */);
d888 2
a889 2
    xhv->xhv_max = --newsize;	/* HvMAX(hv) = --newsize */
    xhv->xhv_array = a;		/* HvARRAY(hv) = a */
d897 1
a897 1
	    if ((HeHASH(entry) & newsize) != (U32)i) {
d901 1
a901 1
		    xhv->xhv_fill++; /* HvFILL(hv)++ */
d909 1
a909 1
	    xhv->xhv_fill--; /* HvFILL(hv)-- */
d917 1
a917 1
    I32 oldsize = (I32) xhv->xhv_max+1; /* HvMAX(hv)+1 (sick) */
d937 1
a937 1
    a = xhv->xhv_array; /* HvARRAY(hv) */
d942 1
a942 1
	if (!a) {
d948 1
a948 1
	if (!a) {
d952 1
a952 1
	Copy(xhv->xhv_array /* HvARRAY(hv) */, a, oldsize * sizeof(HE*), char);
d954 1
a954 2
	    offer_nice_chunk(xhv->xhv_array /* HvARRAY(hv) */,
			    PERL_HV_ARRAY_ALLOC_BYTES(oldsize));
d957 1
a957 1
	    Safefree(xhv->xhv_array /* HvARRAY(hv) */);
d965 3
a967 3
    xhv->xhv_max = --newsize; 	/* HvMAX(hv) = --newsize */
    xhv->xhv_array = a; 	/* HvARRAY(hv) = a */
    if (!xhv->xhv_fill /* !HvFILL(hv) */)	/* skip rest if no entries */
d979 1
a979 1
		    xhv->xhv_fill++; /* HvFILL(hv)++ */
d987 1
a987 1
	    xhv->xhv_fill--; /* HvFILL(hv)-- */
d1010 1
a1010 1
#ifndef NODEFAULT_SHAREKEYS
d1012 4
a1015 4
#endif
    xhv->xhv_max    = 7;	/* HvMAX(hv) = 7 (start with 8 buckets) */
    xhv->xhv_fill   = 0;	/* HvFILL(hv) = 0 */
    xhv->xhv_pmroot = 0;	/* HvPMROOT(hv) = 0 */
d1023 3
a1025 2
    HV *hv = newHV();
    STRLEN hv_max, hv_fill;
d1027 5
a1031 1
    if (!ohv || (hv_fill = HvFILL(ohv)) == 0)
a1032 1
    hv_max = HvMAX(ohv);
d1034 7
a1040 46
    if (!SvMAGICAL((SV *)ohv)) {
	/* It's an ordinary hash, so copy it fast. AMS 20010804 */
	STRLEN i;
	bool shared = !!HvSHAREKEYS(ohv);
	HE **ents, **oents = (HE **)HvARRAY(ohv);
	char *a;
	New(0, a, PERL_HV_ARRAY_ALLOC_BYTES(hv_max+1), char);
	ents = (HE**)a;

	/* In each bucket... */
	for (i = 0; i <= hv_max; i++) {
	    HE *prev = NULL, *ent = NULL, *oent = oents[i];

	    if (!oent) {
		ents[i] = NULL;
		continue;
	    }

	    /* Copy the linked list of entries. */
	    for (oent = oents[i]; oent; oent = HeNEXT(oent)) {
		U32 hash   = HeHASH(oent);
		char *key  = HeKEY(oent);
		STRLEN len = HeKLEN(oent);
                int flags  = HeKFLAGS(oent);

		ent = new_HE();
		HeVAL(ent)     = newSVsv(HeVAL(oent));
		HeKEY_hek(ent)
                    = shared ? share_hek_flags(key, len, hash, flags)
                             :  save_hek_flags(key, len, hash, flags);
		if (prev)
		    HeNEXT(prev) = ent;
		else
		    ents[i] = ent;
		prev = ent;
		HeNEXT(ent) = NULL;
	    }
	}

	HvMAX(hv)   = hv_max;
	HvFILL(hv)  = hv_fill;
	HvTOTALKEYS(hv)  = HvTOTALKEYS(ohv);
	HvARRAY(hv) = ents;
    }
    else {
	/* Iterate over ohv, copying keys and values one at a time. */
d1042 4
a1045 8
	I32 riter = HvRITER(ohv);
	HE *eiter = HvEITER(ohv);

	/* Can we use fewer buckets? (hv_max is always 2^n-1) */
	while (hv_max && hv_max + 1 >= hv_fill * 2)
	    hv_max = hv_max / 2;
	HvMAX(hv) = hv_max;

d1047 3
a1049 4
	while ((entry = hv_iternext_flags(ohv, 0))) {
	    hv_store_flags(hv, HeKEY(entry), HeKLEN(entry),
                           newSVsv(HeVAL(entry)), HeHASH(entry),
                           HeKFLAGS(entry));
d1051 2
a1052 2
	HvRITER(ohv) = riter;
	HvEITER(ohv) = eiter;
d1054 1
a1054 1

d1071 1
a1071 1
	Safefree(HeKEY_hek(entry));
a1112 5

    if(SvREADONLY(hv)) {
        Perl_croak(aTHX_ "Attempt to clear a restricted hash");
    }

d1115 4
a1118 6
    xhv->xhv_fill = 0; /* HvFILL(hv) = 0 */
    xhv->xhv_keys = 0; /* HvKEYS(hv) = 0 */
    xhv->xhv_placeholders = 0; /* HvPLACEHOLDERS(hv) = 0 */
    if (xhv->xhv_array /* HvARRAY(hv) */)
	(void)memzero(xhv->xhv_array /* HvARRAY(hv) */,
		      (xhv->xhv_max+1 /* HvMAX(hv)+1 */) * sizeof(HE*));
d1121 1
a1121 3
	mg_clear((SV*)hv);

    HvHASKFLAGS_off(hv);
d1152 1
a1152 1
	}
d1173 1
a1173 1
    Safefree(xhv->xhv_array /* HvARRAY(hv) */);
d1178 4
a1181 5
    xhv->xhv_max   = 7;	/* HvMAX(hv) = 7 (it's a normal hash) */
    xhv->xhv_array = 0;	/* HvARRAY(hv) = 0 */
    xhv->xhv_fill  = 0;	/* HvFILL(hv) = 0 */
    xhv->xhv_keys  = 0;	/* HvKEYS(hv) = 0 */
    xhv->xhv_placeholders = 0; /* HvPLACEHOLDERS(hv) = 0 */
d1184 1
a1184 1
	mg_clear((SV*)hv);
d1192 1
a1192 1
currently only meaningful for hashes without tie magic.
a1197 1

d1210 1
a1210 1
    entry = xhv->xhv_eiter; /* HvEITER(hv) */
d1215 3
a1217 4
    xhv->xhv_riter = -1; 	/* HvRITER(hv) = -1 */
    xhv->xhv_eiter = Null(HE*); /* HvEITER(hv) = Null(HE*) */
    /* used to be xhv->xhv_fill before 5.004_65 */
    return XHvTOTALKEYS(xhv);
d1219 1
a1224 8
You may call C<hv_delete> or C<hv_delete_ent> on the hash entry that the
iterator currently points to, without losing your place or invalidating your
iterator.  Note that in this case the current entry is deleted from the hash
with your iterator holding the last reference to it.  Your iterator is flagged
to free the entry on the next call to C<hv_iternext>, so you must not discard
your iterator immediately else the entry will leak - call C<hv_iternext> to
trigger the resource deallocation.

a1230 22
    return hv_iternext_flags(hv, 0);
}

/*
=for apidoc hv_iternext_flags

Returns entries from a hash iterator.  See C<hv_iterinit> and C<hv_iternext>.
The C<flags> value will normally be zero; if HV_ITERNEXT_WANTPLACEHOLDERS is
set the placeholders keys (for restricted hashes) will be returned in addition
to normal keys. By default placeholders are automatically skipped over.
Currently a placeholder is implemented with a value that is literally
<&Perl_sv_undef> (a regular C<undef> value is a normal read-write SV for which
C<!SvOK> is false). Note that the implementation of placeholders and
restricted hashes may change, and the implementation currently is
insufficiently abstracted for any change to be tidy.

=cut
*/

HE *
Perl_hv_iternext_flags(pTHX_ HV *hv, I32 flags)
{
d1239 1
a1239 1
    oldentry = entry = xhv->xhv_eiter; /* HvEITER(hv) */
d1241 1
a1241 1
    if ((mg = SvTIED_mg((SV*)hv, PERL_MAGIC_tied))) {
d1251 1
a1251 2
	    /* one HE per MAGICAL hash */
	    xhv->xhv_eiter = entry = new_HE(); /* HvEITER(hv) = new_HE() */
d1259 1
a1259 1
	if (SvOK(key)) {
d1263 1
a1263 1
	}
d1268 1
a1268 1
	xhv->xhv_eiter = Null(HE*); /* HvEITER(hv) = Null(HE*) */
d1272 1
a1272 1
    if (!entry && SvRMAGICAL((SV*)hv) && mg_find((SV*)hv, PERL_MAGIC_env))
d1276 3
a1278 4
    if (!xhv->xhv_array /* !HvARRAY(hv) */)
	Newz(506, xhv->xhv_array /* HvARRAY(hv) */,
	     PERL_HV_ARRAY_ALLOC_BYTES(xhv->xhv_max+1 /* HvMAX(hv)+1 */),
	     char);
a1279 1
    {
a1280 10
        if (!(flags & HV_ITERNEXT_WANTPLACEHOLDERS)) {
            /*
             * Skip past any placeholders -- don't want to include them in
             * any iteration.
             */
            while (entry && HeVAL(entry) == &PL_sv_undef) {
                entry = HeNEXT(entry);
            }
	}
    }
d1282 3
a1284 3
	xhv->xhv_riter++; /* HvRITER(hv)++ */
	if (xhv->xhv_riter > (I32)xhv->xhv_max /* HvRITER(hv) > HvMAX(hv) */) {
	    xhv->xhv_riter = -1; /* HvRITER(hv) = -1 */
a1286 1
	/* entry = (HvARRAY(hv))[HvRITER(hv)]; */
a1287 6

        if (!(flags & HV_ITERNEXT_WANTPLACEHOLDERS)) {
            /* if we have an entry, but it's a placeholder, don't count it */
            if (entry && HeVAL(entry) == &PL_sv_undef)
                entry = 0;
        }
d1295 1
a1295 1
    xhv->xhv_eiter = entry; /* HvEITER(hv) = entry */
d1337 5
a1341 23
    if (HeKLEN(entry) != HEf_SVKEY) {
        HEK *hek = HeKEY_hek(entry);
        int flags = HEK_FLAGS(hek);
        SV *sv;

        if (flags & HVhek_WASUTF8) {
            /* Trouble :-)
               Andreas would like keys he put in as utf8 to come back as utf8
            */
            STRLEN utf8_len = HEK_LEN(hek);
            U8 *as_utf8 = bytes_to_utf8 ((U8*)HEK_KEY(hek), &utf8_len);

            sv = newSVpvn ((char*)as_utf8, utf8_len);
            SvUTF8_on (sv);
	    Safefree (as_utf8); /* bytes_to_utf8() allocates a new string */
        } else {
            sv = newSVpvn_share(HEK_KEY(hek),
                                (HEK_UTF8(hek) ? -HEK_LEN(hek) : HEK_LEN(hek)),
                                HEK_HASH(hek));
        }
        return sv_2mortal(sv);
    }
    return sv_mortalcopy(HeKEY_sv(entry));
d1357 1
a1357 1
	if (mg_find((SV*)hv, PERL_MAGIC_tied)) {
d1381 1
a1381 1
    if ( (he = hv_iternext_flags(hv, 0)) == NULL)
a1400 2
#if 0 /* use the macro from hv.h instead */

a1406 2
#endif

a1412 17
    unshare_hek_or_pvn (NULL, str, len, hash);
}


void
Perl_unshare_hek(pTHX_ HEK *hek)
{
    unshare_hek_or_pvn(hek, NULL, 0, 0);
}

/* possibly free a shared string if no one has access to it
   hek if non-NULL takes priority over the other 3, else str, len and hash
   are used.  If so, len and hash must both be valid for str.
 */
STATIC void
S_unshare_hek_or_pvn(pTHX_ HEK *hek, const char *str, I32 len, U32 hash)
{
d1418 1
a1418 18
    bool is_utf8 = FALSE;
    int k_flags = 0;
    const char *save = str;

    if (hek) {
        hash = HEK_HASH(hek);
    } else if (len < 0) {
        STRLEN tmplen = -len;
        is_utf8 = TRUE;
        /* See the note in hv_fetch(). --jhi */
        str = (char*)bytes_from_utf8((U8*)str, &tmplen, &is_utf8);
        len = tmplen;
        if (is_utf8)
            k_flags = HVhek_UTF8;
        if (str != save)
            k_flags |= HVhek_WASUTF8 | HVhek_FREEKEY;
    }

a1426 1
    /* oentry = &(HvARRAY(hv))[hash & (I32) HvMAX(hv)]; */
d1428 17
a1444 21
    if (hek) {
        for (entry = *oentry; entry; i=0, oentry = &HeNEXT(entry), entry = *oentry) {
            if (HeKEY_hek(entry) != hek)
                continue;
            found = 1;
            break;
        }
    } else {
        int flags_masked = k_flags & HVhek_MASK;
        for (entry = *oentry; entry; i=0, oentry = &HeNEXT(entry), entry = *oentry) {
            if (HeHASH(entry) != hash)		/* strings can't be equal */
                continue;
            if (HeKLEN(entry) != len)
                continue;
            if (HeKEY(entry) != str && memNE(HeKEY(entry),str,len))	/* is this it? */
                continue;
            if (HeKFLAGS(entry) != flags_masked)
                continue;
            found = 1;
            break;
        }
a1445 12

    if (found) {
        if (--HeVAL(entry) == Nullsv) {
            *oentry = HeNEXT(entry);
            if (i && !*oentry)
                xhv->xhv_fill--; /* HvFILL(hv)-- */
            Safefree(HeKEY_hek(entry));
            del_HE(entry);
            xhv->xhv_keys--; /* HvKEYS(hv)-- */
        }
    }

d1448 1
a1448 6
	Perl_warner(aTHX_ packWARN(WARN_INTERNAL),
                    "Attempt to free non-existent shared string '%s'%s",
                    hek ? HEK_KEY(hek) : str,
                    (k_flags & HVhek_UTF8) ? " (utf8)" : "");
    if (k_flags & HVhek_FREEKEY)
	Safefree(str);
a1457 27
    bool is_utf8 = FALSE;
    int flags = 0;
    const char *save = str;

    if (len < 0) {
      STRLEN tmplen = -len;
      is_utf8 = TRUE;
      /* See the note in hv_fetch(). --jhi */
      str = (char*)bytes_from_utf8((U8*)str, &tmplen, &is_utf8);
      len = tmplen;
      /* If we were able to downgrade here, then than means that we were passed
         in a key which only had chars 0-255, but was utf8 encoded.  */
      if (is_utf8)
          flags = HVhek_UTF8;
      /* If we found we were able to downgrade the string to bytes, then
         we should flag that it needs upgrading on keys or each.  Also flag
         that we need share_hek_flags to free the string.  */
      if (str != save)
          flags |= HVhek_WASUTF8 | HVhek_FREEKEY;
    }

    return share_hek_flags (str, len, hash, flags);
}

STATIC HEK *
S_share_hek_flags(pTHX_ const char *str, I32 len, register U32 hash, int flags)
{
a1462 1
    int flags_masked = flags & HVhek_MASK;
d1465 1
a1465 1

d1467 1
a1467 1
	hv_store(PL_strtab, str, len, Nullsv, hash);
a1471 1
    /* oentry = &(HvARRAY(hv))[hash & (I32) HvMAX(hv)]; */
d1478 1
a1478 3
	if (HeKEY(entry) != str && memNE(HeKEY(entry),str,len))	/* is this it? */
	    continue;
	if (HeKFLAGS(entry) != flags_masked)
d1485 1
a1485 1
	HeKEY_hek(entry) = save_hek_flags(str, len, hash, flags);
d1489 1
a1489 1
	xhv->xhv_keys++; /* HvKEYS(hv)++ */
d1491 2
a1492 2
	    xhv->xhv_fill++; /* HvFILL(hv)++ */
	    if (xhv->xhv_keys > (IV)xhv->xhv_max /* HvKEYS(hv) > HvMAX(hv) */)
d1499 3
a1502 2
    if (flags & HVhek_FREEKEY)
	Safefree(str);
a1503 2
    return HeKEY_hek(entry);
}
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@d3 1
a3 2
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
 *    2000, 2001, 2002, 2003, by Larry Wall and others
a19 1
#define PERL_HASH_INTERNAL_ACCESS
a21 2
#define HV_MAX_LENGTH_BEFORE_SPLIT 14

a91 17
/* free the pool of temporary HE/HEK pairs retunrned by hv_fetch_ent
 * for tied hashes */

void
Perl_free_tied_hv_pool(pTHX)
{
    HE *ohe;
    HE *he = PL_hv_fetch_ent_mh;
    while (he) {
	Safefree(HeKEY_hek(he));
	ohe = he;
	he = HeNEXT(he);
	del_HE(ohe);
    }
    PL_hv_fetch_ent_mh = Nullhe;
}

d110 1
a110 4
    if (HeKLEN(e) == HEf_SVKEY) {
	char *k;
	New(54, k, HEK_BASESIZE + sizeof(SV*), char);
	HeKEY_hek(ret) = (HEK*)k;
a111 1
    }
d133 1
a133 1
	/* XXX is this line an error ???:  SV *sv = sv_newmortal(); */
a210 1
	    sv_upgrade(sv, SVt_PVLV);
d214 2
a215 3
	    LvTYPE(sv) = 't';
	    LvTARG(sv) = sv; /* fake (SV**) */
	    return &(LvTARG(sv));
d254 1
a254 9
    if (HvREHASH(hv)) {
	PERL_HASH_INTERNAL(hash, key, klen);
	/* Yes, you do need this even though you are not "storing" because
	   you can flip the flags below if doing an lval lookup.  (And that
	   was put in to give the semantics Andreas was expecting.)  */
	flags |= HVhek_REHASH;
    } else {
	PERL_HASH(hash, key, klen);
    }
a285 2
            if (flags & HVhek_ENABLEHVKFLAGS)
                HvHASKFLAGS_on(hv);
d290 1
a290 1
	if (HeVAL(entry) == &PL_sv_placeholder)
d359 1
a359 1
	    keysv = newSVsv(keysv);
d361 1
a361 5
	    /* grab a fake HE/HEK pair from the pool or make a new one */
	    entry = PL_hv_fetch_ent_mh;
	    if (entry)
		PL_hv_fetch_ent_mh = HeNEXT(entry);
	    else {
a362 1
		entry = new_HE();
d364 1
a364 1
		HeKEY_hek(entry) = (HEK*)k;
d366 4
a369 8
	    HeNEXT(entry) = Nullhe;
	    HeSVKEY_set(entry, keysv);
	    HeVAL(entry) = sv;
	    sv_upgrade(sv, SVt_PVLV);
	    LvTYPE(sv) = 'T';
	    LvTARG(sv) = (SV*)entry; /* so we can free entry when freeing sv */
	    return entry;
 	}
a386 1
    keysave = key = SvPV(keysv, klen);
d401 1
d412 1
a412 7
    if (HvREHASH(hv)) {
	PERL_HASH_INTERNAL(hash, key, klen);
	/* Yes, you do need this even though you are not "storing" because
	   you can flip the flags below if doing an lval lookup.  (And that
	   was put in to give the semantics Andreas was expecting.)  */
	flags |= HVhek_REHASH;
    } else if (!hash) {
a413 1
    }
a441 2
            if (flags & HVhek_ENABLEHVKFLAGS)
                HvHASKFLAGS_on(hv);
d446 1
a446 1
	if (HeVAL(entry) == &PL_sv_placeholder)
d504 1
a504 9
the call, and decrementing it if the function returned NULL.  Effectively
a successful hv_store takes ownership of one reference to C<val>.  This is
usually what you want; a newly created SV has a reference count of one, so
if all your code does is create SVs then store them in a hash, hv_store
will own the only reference to the new SV, and your code doesn't need to do
anything further to tidy up.  hv_store is not implemented as a call to
hv_store_ent, and does not create a temporary SV for the key, so if your
key data is not already in SV form then use hv_store in preference to
hv_store_ent.
d548 1
a548 1
    register U32 n_links;
d580 1
a580 6
    if (HvREHASH(hv)) {
	/* We don't have a pointer to the hv, so we have to replicate the
	   flag into every HEK, so that hv_iterkeysv can see it.  */
	flags |= HVhek_REHASH;
	PERL_HASH_INTERNAL(hash, key, klen);
    } else if (!hash)
d590 1
d592 1
a592 3
    n_links = 0;

    for (entry = *oentry; entry; ++n_links, entry = HeNEXT(entry)) {
d601 1
a601 1
	if (HeVAL(entry) == &PL_sv_placeholder)
d609 1
a609 1
            HeVAL(entry) = &PL_sv_placeholder;
d652 1
a652 1
        HeVAL(entry) = &PL_sv_placeholder;
d659 1
a659 1
    if (!n_links) {				/* initial entry? */
d661 2
a662 9
    } else if ((xhv->xhv_keys > (IV)xhv->xhv_max)
	       || ((n_links > HV_MAX_LENGTH_BEFORE_SPLIT) && !HvREHASH(hv))) {
	/* Use the old HvKEYS(hv) > HvMAX(hv) condition to limit bucket
	   splits on a rehashed hash, as we're not going to split it again,
	   and if someone is lucky (evil) enough to get all the keys in one
	   list they could exhaust our memory as we repeatedly double the
	   number of buckets on every entry. Linear search feels a less worse
	   thing to do.  */
        hsplit(hv);
d679 1
a679 11
decrementing it if the function returned NULL.  Effectively a successful
hv_store_ent takes ownership of one reference to C<val>.  This is
usually what you want; a newly created SV has a reference count of one, so
if all your code does is create SVs then store them in a hash, hv_store
will own the only reference to the new SV, and your code doesn't need to do
anything further to tidy up.  Note that hv_store_ent only reads the C<key>;
unlike C<val> it does not take ownership of it, so maintaining the correct
reference count on C<key> is entirely the caller's responsibility.  hv_store
is not implemented as a call to hv_store_ent, and does not create a temporary
SV for the key, so if your key data is not already in SV form then use
hv_store in preference to hv_store_ent.
d693 1
a693 1
    U32 n_links;
d740 1
a740 6
    if (HvREHASH(hv)) {
	/* We don't have a pointer to the hv, so we have to replicate the
	   flag into every HEK, so that hv_iterkeysv can see it.  */
	flags |= HVhek_REHASH;
	PERL_HASH_INTERNAL(hash, key, klen);
    } else if (!hash) {
a741 1
    }
d750 1
a750 1
    n_links = 0;
d752 1
a752 1
    for (; entry; ++n_links, entry = HeNEXT(entry)) {
d761 1
a761 1
	if (HeVAL(entry) == &PL_sv_placeholder)
d806 1
a806 1
    if (!n_links) {				/* initial entry? */
d808 2
a809 9
    } else if ((xhv->xhv_keys > (IV)xhv->xhv_max)
	       || ((n_links > HV_MAX_LENGTH_BEFORE_SPLIT) && !HvREHASH(hv))) {
	/* Use only the old HvKEYS(hv) > HvMAX(hv) condition to limit bucket
	   splits on a rehashed hash, as we're not going to split it again,
	   and if someone is lucky (evil) enough to get all the keys in one
	   list they could exhaust our memory as we repeatedly double the
	   number of buckets on every entry. Linear search feels a less worse
	   thing to do.  */
        hsplit(hv);
d843 2
a844 2
	klen = -klen;
	is_utf8 = TRUE;
d853 1
a853 3
	    if (SvMAGICAL(sv)) {
	        mg_clear(sv);
	    }
d885 1
a885 5
    if (HvREHASH(hv)) {
	PERL_HASH_INTERNAL(hash, key, klen);
    } else {
	PERL_HASH(hash, key, klen);
    }
d903 1
a903 1
	if (HeVAL(entry) == &PL_sv_placeholder)
d933 1
a933 1
	    HeVAL(entry) = &PL_sv_placeholder;
d943 1
a943 1
	    HeVAL(entry) = &PL_sv_placeholder;
d1006 1
a1006 3
	    if (SvMAGICAL(sv)) {
		mg_clear(sv);
	    }
d1040 1
a1040 3
    if (HvREHASH(hv)) {
	PERL_HASH_INTERNAL(hash, key, klen);
    } else if (!hash) {
a1041 1
    }
d1060 1
a1060 1
	if (HeVAL(entry) == &PL_sv_placeholder)
d1089 1
a1089 1
	    HeVAL(entry) = &PL_sv_placeholder;
d1099 1
a1099 1
	    HeVAL(entry) = &PL_sv_placeholder;
d1188 1
a1188 5
    if (HvREHASH(hv)) {
	PERL_HASH_INTERNAL(hash, key, klen);
    } else {
	PERL_HASH(hash, key, klen);
    }
d1208 1
a1208 1
	if (HeVAL(entry) == &PL_sv_placeholder)
d1292 1
a1292 3
    if (HvREHASH(hv)) {
	PERL_HASH_INTERNAL(hash, key, klen);
    } else if (!hash)
d1313 1
a1313 1
	if (HeVAL(entry) == &PL_sv_placeholder)
a1347 2
    int longest_chain = 0;
    int was_shared;
a1377 3
	int left_length = 0;
	int right_length = 0;

a1387 1
		right_length++;
d1390 1
a1390 1
	    else {
a1391 2
		left_length++;
	    }
a1394 71
	/* I think we don't actually need to keep track of the longest length,
	   merely flag if anything is too long. But for the moment while
	   developing this code I'll track it.  */
	if (left_length > longest_chain)
	    longest_chain = left_length;
	if (right_length > longest_chain)
	    longest_chain = right_length;
    }


    /* Pick your policy for "hashing isn't working" here:  */
    if (longest_chain <= HV_MAX_LENGTH_BEFORE_SPLIT /* split worked?  */
	|| HvREHASH(hv)) {
	return;
    }

    if (hv == PL_strtab) {
	/* Urg. Someone is doing something nasty to the string table.
	   Can't win.  */
	return;
    }

    /* Awooga. Awooga. Pathological data.  */
    /*PerlIO_printf(PerlIO_stderr(), "%p %d of %d with %d/%d buckets\n", hv,
      longest_chain, HvTOTALKEYS(hv), HvFILL(hv),  1+HvMAX(hv));*/

    ++newsize;
    Newz(2, a, PERL_HV_ARRAY_ALLOC_BYTES(newsize), char);
    was_shared = HvSHAREKEYS(hv);

    xhv->xhv_fill = 0;
    HvSHAREKEYS_off(hv);
    HvREHASH_on(hv);

    aep = (HE **) xhv->xhv_array;

    for (i=0; i<newsize; i++,aep++) {
	entry = *aep;
	while (entry) {
	    /* We're going to trash this HE's next pointer when we chain it
	       into the new hash below, so store where we go next.  */
	    HE *next = HeNEXT(entry);
	    UV hash;

	    /* Rehash it */
	    PERL_HASH_INTERNAL(hash, HeKEY(entry), HeKLEN(entry));

	    if (was_shared) {
		/* Unshare it.  */
		HEK *new_hek
		    = save_hek_flags(HeKEY(entry), HeKLEN(entry),
				     hash, HeKFLAGS(entry));
		unshare_hek (HeKEY_hek(entry));
		HeKEY_hek(entry) = new_hek;
	    } else {
		/* Not shared, so simply write the new hash in. */
		HeHASH(entry) = hash;
	    }
	    /*PerlIO_printf(PerlIO_stderr(), "%d ", HeKFLAGS(entry));*/
	    HEK_REHASH_on(HeKEY_hek(entry));
	    /*PerlIO_printf(PerlIO_stderr(), "%d\n", HeKFLAGS(entry));*/

	    /* Copy oentry to the correct new chain.  */
	    bep = ((HE**)a) + (hash & (I32) xhv->xhv_max);
	    if (!*bep)
		    xhv->xhv_fill++; /* HvFILL(hv)++ */
	    HeNEXT(entry) = *bep;
	    *bep = entry;

	    entry = next;
	}
a1395 2
    Safefree (xhv->xhv_array);
    xhv->xhv_array = a;		/* HvARRAY(hv) = a */
a1498 1

d1640 2
a1641 24
    xhv = (XPVHV*)SvANY(hv);

    if (SvREADONLY(hv)) {
	/* restricted hash: convert all keys to placeholders */
	I32 i;
	HE* entry;
	for (i = 0; i <= (I32) xhv->xhv_max; i++) {
	    entry = ((HE**)xhv->xhv_array)[i];
	    for (; entry; entry = HeNEXT(entry)) {
		/* not already placeholder */
		if (HeVAL(entry) != &PL_sv_placeholder) {
		    if (HeVAL(entry) && SvREADONLY(HeVAL(entry))) {
			SV* keysv = hv_iterkeysv(entry);
			Perl_croak(aTHX_
	"Attempt to delete readonly key '%"SVf"' from a restricted hash",
				   keysv);
		    }
		    SvREFCNT_dec(HeVAL(entry));
		    HeVAL(entry) = &PL_sv_placeholder;
		    xhv->xhv_placeholders++; /* HvPLACEHOLDERS(hv)++ */
		}
	    }
	}
	return;
d1644 1
d1646 2
a1656 1
    HvREHASH_off(hv);
a1675 6
    /* make everyone else think the array is empty, so that the destructors
     * called for freed entries can't recusively mess with us */
    HvARRAY(hv) = Null(HE**); 
    HvFILL(hv) = 0;
    ((XPVHV*) SvANY(hv))->xhv_keys = 0;

a1688 1
    HvARRAY(hv) = array;
a1709 2
        if(PL_stashcache)
	    hv_delete(PL_stashcache, HvNAME(hv), strlen(HvNAME(hv)), G_DISCARD);
d1715 2
d1786 3
a1788 2
Currently a placeholder is implemented with a value that is
C<&Perl_sv_placeholder>. Note that the implementation of placeholders and
a1847 1
    /* At start of hash, entry is NULL.  */
d1856 1
a1856 1
            while (entry && HeVAL(entry) == &PL_sv_placeholder) {
a1861 2
	/* OK. Come to the end of the current list.  Grab the next one.  */

a1863 1
	    /* There is no next one.  End of the hash.  */
d1871 4
a1874 8
            /* If we have an entry, but it's a placeholder, don't count it.
	       Try the next.  */
	    while (entry && HeVAL(entry) == &PL_sv_placeholder)
		entry = HeNEXT(entry);
	}
	/* Will loop again if this linked list starts NULL
	   (for HV_ITERNEXT_WANTPLACEHOLDERS)
	   or if we run through it and find only placeholders.  */
a1881 3
    /*if (HvREHASH(hv) && entry && !HeKREHASH(entry))
      PerlIO_printf(PerlIO_stderr(), "Awooga %p %p\n", hv, entry);*/

d1939 1
a1939 11
	} else if (flags & HVhek_REHASH) {
	    /* We don't have a pointer to the hv, so we have to replicate the
	       flag into every HEK. This hv is using custom a hasing
	       algorithm. Hence we can't return a shared string scalar, as
	       that would contain the (wrong) hash value, and might get passed
	       into an hv routine with a regular hash  */

            sv = newSVpvn (HEK_KEY(hek), HEK_LEN(hek));
	    if (HEK_UTF8(hek))
		SvUTF8_on (sv);
	} else {
a2160 3

	Can't rehash the shared string table, so not sure if it's worth
	counting the number of entries in the linked list
d2188 1
a2188 1
	} else if (xhv->xhv_keys > (IV)xhv->xhv_max /* HvKEYS(hv) > HvMAX(hv) */) {
@


1.1.1.7
log
@perl 5.8.3 from CPAN
@
text
@a82 1
    int flags_masked = flags & HVhek_MASK;
d92 1
a92 4
    HEK_FLAGS(hek) = (unsigned char)flags_masked;

    if (flags & HVhek_FREEKEY)
	Safefree(str);
a170 5
#define HV_FETCH_ISSTORE   0x01
#define HV_FETCH_ISEXISTS  0x02
#define HV_FETCH_LVALUE    0x04
#define HV_FETCH_JUST_SV   0x08

d172 1
a172 1
=for apidoc hv_store
d174 4
a177 16
Stores an SV in a hash.  The hash key is specified as C<key> and C<klen> is
the length of the key.  The C<hash> parameter is the precomputed hash
value; if it is zero then Perl will compute it.  The return value will be
NULL if the operation failed or if the value did not need to be actually
stored within the hash (as in the case of tied hashes).  Otherwise it can
be dereferenced to get the original C<SV*>.  Note that the caller is
responsible for suitably incrementing the reference count of C<val> before
the call, and decrementing it if the function returned NULL.  Effectively
a successful hv_store takes ownership of one reference to C<val>.  This is
usually what you want; a newly created SV has a reference count of one, so
if all your code does is create SVs then store them in a hash, hv_store
will own the only reference to the new SV, and your code doesn't need to do
anything further to tidy up.  hv_store is not implemented as a call to
hv_store_ent, and does not create a temporary SV for the key, so if your
key data is not already in SV form then use hv_store in preference to
hv_store_ent.
d185 1
d187 1
a187 1
Perl_hv_store(pTHX_ HV *hv, const char *key, I32 klen_i32, SV *val, U32 hash)
d189 8
a196 3
    HE *hek;
    STRLEN klen;
    int flags;
d198 14
a211 6
    if (klen_i32 < 0) {
	klen = -klen_i32;
	flags = HVhek_UTF8;
    } else {
	klen = klen_i32;
	flags = 0;
a212 4
    hek = hv_fetch_common (hv, NULL, key, klen, flags,
			   (HV_FETCH_ISSTORE|HV_FETCH_JUST_SV), val, 0);
    return hek ? &HeVAL(hek) : NULL;
}
d214 1
a214 7
SV**
Perl_hv_store_flags(pTHX_ HV *hv, const char *key, I32 klen, SV *val,
                 register U32 hash, int flags)
{
    HE *hek = hv_fetch_common (hv, NULL, key, klen, flags,
			       (HV_FETCH_ISSTORE|HV_FETCH_JUST_SV), val, hash);
    return hek ? &HeVAL(hek) : NULL;
d217 2
a218 31
/*
=for apidoc hv_store_ent

Stores C<val> in a hash.  The hash key is specified as C<key>.  The C<hash>
parameter is the precomputed hash value; if it is zero then Perl will
compute it.  The return value is the new hash entry so created.  It will be
NULL if the operation failed or if the value did not need to be actually
stored within the hash (as in the case of tied hashes).  Otherwise the
contents of the return value can be accessed using the C<He?> macros
described here.  Note that the caller is responsible for suitably
incrementing the reference count of C<val> before the call, and
decrementing it if the function returned NULL.  Effectively a successful
hv_store_ent takes ownership of one reference to C<val>.  This is
usually what you want; a newly created SV has a reference count of one, so
if all your code does is create SVs then store them in a hash, hv_store
will own the only reference to the new SV, and your code doesn't need to do
anything further to tidy up.  Note that hv_store_ent only reads the C<key>;
unlike C<val> it does not take ownership of it, so maintaining the correct
reference count on C<key> is entirely the caller's responsibility.  hv_store
is not implemented as a call to hv_store_ent, and does not create a temporary
SV for the key, so if your key data is not already in SV form then use
hv_store in preference to hv_store_ent.

See L<perlguts/"Understanding the Magic of Tied Hashes and Arrays"> for more
information on how to use this function on tied hashes.

=cut
*/

HE *
Perl_hv_store_ent(pTHX_ HV *hv, SV *keysv, SV *val, U32 hash)
d220 4
a223 2
  return hv_fetch_common(hv, keysv, NULL, 0, 0, HV_FETCH_ISSTORE, val, hash);
}
d225 2
a226 2
/*
=for apidoc hv_exists
d228 33
a260 2
Returns a boolean indicating whether the specified hash key exists.  The
C<klen> is the length of the key.
d262 18
a279 2
=cut
*/
d281 6
a286 9
bool
Perl_hv_exists(pTHX_ HV *hv, const char *key, I32 klen_i32)
{
    STRLEN klen;
    int flags;

    if (klen_i32 < 0) {
	klen = -klen_i32;
	flags = HVhek_UTF8;
d288 1
a288 2
	klen = klen_i32;
	flags = 0;
a289 3
    return hv_fetch_common(hv, NULL, key, klen, flags, HV_FETCH_ISEXISTS, 0, 0)
	? TRUE : FALSE;
}
d291 39
a329 2
/*
=for apidoc hv_fetch
a330 24
Returns the SV which corresponds to the specified key in the hash.  The
C<klen> is the length of the key.  If C<lval> is set then the fetch will be
part of a store.  Check that the return value is non-null before
dereferencing it to an C<SV*>.

See L<perlguts/"Understanding the Magic of Tied Hashes and Arrays"> for more
information on how to use this function on tied hashes.

=cut
*/

SV**
Perl_hv_fetch(pTHX_ HV *hv, const char *key, I32 klen_i32, I32 lval)
{
    HE *hek;
    STRLEN klen;
    int flags;

    if (klen_i32 < 0) {
	klen = -klen_i32;
	flags = HVhek_UTF8;
    } else {
	klen = klen_i32;
	flags = 0;
d332 25
a356 21
    hek = hv_fetch_common (hv, NULL, key, klen, flags,
			   HV_FETCH_JUST_SV | (lval ? HV_FETCH_LVALUE : 0),
			   Nullsv, 0);
    return hek ? &HeVAL(hek) : NULL;
}

/*
=for apidoc hv_exists_ent

Returns a boolean indicating whether the specified hash key exists. C<hash>
can be a valid precomputed hash value, or 0 to ask for it to be
computed.

=cut
*/

bool
Perl_hv_exists_ent(pTHX_ HV *hv, SV *keysv, U32 hash)
{
    return hv_fetch_common(hv, keysv, NULL, 0, 0, HV_FETCH_ISEXISTS, 0, hash)
	? TRUE : FALSE;
d381 4
a384 12
    return hv_fetch_common(hv, keysv, NULL, 0, 0, 
			   (lval ? HV_FETCH_LVALUE : 0), Nullsv, hash);
}

HE *
S_hv_fetch_common(pTHX_ HV *hv, SV *keysv, const char *key, STRLEN klen,
		  int flags, int action, SV *val, register U32 hash)
{
    XPVHV* xhv;
    U32 n_links;
    HE *entry;
    HE **oentry;
d387 2
a388 1
    int masked_flags;
d393 14
a406 82
    if (keysv) {
	if (flags & HVhek_FREEKEY)
	    Safefree(key);
	key = SvPV(keysv, klen);
	flags = 0;
	is_utf8 = (SvUTF8(keysv) != 0);
    } else {
	is_utf8 = ((flags & HVhek_UTF8) ? TRUE : FALSE);
    }

    xhv = (XPVHV*)SvANY(hv);
    if (SvMAGICAL(hv)) {
	if (SvRMAGICAL(hv) && !(action & (HV_FETCH_ISSTORE|HV_FETCH_ISEXISTS)))
	  {
	    if (mg_find((SV*)hv, PERL_MAGIC_tied) || SvGMAGICAL((SV*)hv)) {
		sv = sv_newmortal();

		/* XXX should be able to skimp on the HE/HEK here when
		   HV_FETCH_JUST_SV is true.  */

		if (!keysv) {
		    keysv = newSVpvn(key, klen);
		    if (is_utf8) {
			SvUTF8_on(keysv);
		    }
		} else {
		    keysv = newSVsv(keysv);
		}
		mg_copy((SV*)hv, sv, (char *)keysv, HEf_SVKEY);

		/* grab a fake HE/HEK pair from the pool or make a new one */
		entry = PL_hv_fetch_ent_mh;
		if (entry)
		    PL_hv_fetch_ent_mh = HeNEXT(entry);
		else {
		    char *k;
		    entry = new_HE();
		    New(54, k, HEK_BASESIZE + sizeof(SV*), char);
		    HeKEY_hek(entry) = (HEK*)k;
		}
		HeNEXT(entry) = Nullhe;
		HeSVKEY_set(entry, keysv);
		HeVAL(entry) = sv;
		sv_upgrade(sv, SVt_PVLV);
		LvTYPE(sv) = 'T';
		 /* so we can free entry when freeing sv */
		LvTARG(sv) = (SV*)entry;

		/* XXX remove at some point? */
		if (flags & HVhek_FREEKEY)
		    Safefree(key);

		return entry;
	    }
#ifdef ENV_IS_CASELESS
	    else if (mg_find((SV*)hv, PERL_MAGIC_env)) {
		U32 i;
		for (i = 0; i < klen; ++i)
		    if (isLOWER(key[i])) {
			/* Would be nice if we had a routine to do the
			   copy and upercase in a single pass through.  */
			char *nkey = strupr(savepvn(key,klen));
			/* Note that this fetch is for nkey (the uppercased
			   key) whereas the store is for key (the original)  */
			entry = hv_fetch_common(hv, Nullsv, nkey, klen,
						HVhek_FREEKEY, /* free nkey */
						0 /* non-LVAL fetch */,
						Nullsv /* no value */,
						0 /* compute hash */);
			if (!entry && (action & HV_FETCH_LVALUE)) {
			    /* This call will free key if necessary.
			       Do it this way to encourage compiler to tail
			       call optimise.  */
			    entry = hv_fetch_common(hv, keysv, key, klen,
						    flags, HV_FETCH_ISSTORE,
						    NEWSV(61,0), hash);
			} else {
			    if (flags & HVhek_FREEKEY)
				Safefree(key);
			}
			return entry;
		    }
d408 8
a415 29
#endif
	} /* ISFETCH */
	else if (SvRMAGICAL(hv) && (action & HV_FETCH_ISEXISTS)) {
	    if (mg_find((SV*)hv, PERL_MAGIC_tied) || SvGMAGICAL((SV*)hv)) {
		SV* svret;
		/* I don't understand why hv_exists_ent has svret and sv,
		   whereas hv_exists only had one.  */
		svret = sv_newmortal();
		sv = sv_newmortal();

		if (keysv || is_utf8) {
		    if (!keysv) {
			keysv = newSVpvn(key, klen);
			SvUTF8_on(keysv);
		    } else {
			keysv = newSVsv(keysv);
		    }
		    mg_copy((SV*)hv, sv, (char *)sv_2mortal(keysv), HEf_SVKEY);
		} else {
		    mg_copy((SV*)hv, sv, key, klen);
		}
		if (flags & HVhek_FREEKEY)
		    Safefree(key);
		magic_existspack(svret, mg_find(sv, PERL_MAGIC_tiedelem));
		/* This cast somewhat evil, but I'm merely using NULL/
		   not NULL to return the boolean exists.
		   And I know hv is not NULL.  */
		return SvTRUE(svret) ? (HE *)hv : NULL;
		}
d417 11
a427 11
	    else if (mg_find((SV*)hv, PERL_MAGIC_env)) {
		/* XXX This code isn't UTF8 clean.  */
		const char *keysave = key;
		/* Will need to free this, so set FREEKEY flag.  */
		key = savepvn(key,klen);
		key = (const char*)strupr((char*)key);
		is_utf8 = 0;
		hash = 0;

		if (flags & HVhek_FREEKEY) {
		    Safefree(keysave);
d429 1
a429 2
		flags |= HVhek_FREEKEY;
	    }
d431 1
a431 45
	} /* ISEXISTS */
	else if (action & HV_FETCH_ISSTORE) {
	    bool needs_copy;
	    bool needs_store;
	    hv_magic_check (hv, &needs_copy, &needs_store);
	    if (needs_copy) {
		bool save_taint = PL_tainted;	
		if (keysv || is_utf8) {
		    if (!keysv) {
			keysv = newSVpvn(key, klen);
			SvUTF8_on(keysv);
		    }
		    if (PL_tainting)
			PL_tainted = SvTAINTED(keysv);
		    keysv = sv_2mortal(newSVsv(keysv));
		    mg_copy((SV*)hv, val, (char*)keysv, HEf_SVKEY);
		} else {
		    mg_copy((SV*)hv, val, key, klen);
		}

		TAINT_IF(save_taint);
		if (!xhv->xhv_array /* !HvARRAY(hv) */ && !needs_store) {
		    if (flags & HVhek_FREEKEY)
			Safefree(key);
		    return Nullhe;
		}
#ifdef ENV_IS_CASELESS
		else if (mg_find((SV*)hv, PERL_MAGIC_env)) {
		    /* XXX This code isn't UTF8 clean.  */
		    const char *keysave = key;
		    /* Will need to free this, so set FREEKEY flag.  */
		    key = savepvn(key,klen);
		    key = (const char*)strupr((char*)key);
		    is_utf8 = 0;
		    hash = 0;

		    if (flags & HVhek_FREEKEY) {
			Safefree(keysave);
		    }
		    flags |= HVhek_FREEKEY;
		}
#endif
	    }
	} /* ISSTORE */
    } /* SvMAGICAL */
d433 2
d436 1
a436 1
	if ((action & (HV_FETCH_LVALUE | HV_FETCH_ISSTORE))
d444 1
a444 11
#ifdef DYNAMIC_ENV_FETCH
	else if (action & HV_FETCH_ISEXISTS) {
	    /* for an %ENV exists, if we do an insert it's by a recursive
	       store call, so avoid creating HvARRAY(hv) right now.  */
	}
#endif
	else {
	    /* XXX remove at some point? */
            if (flags & HVhek_FREEKEY)
                Safefree(key);

a445 1
	}
d448 2
a450 1
	const char *keysave = key;
d453 2
a454 6
	    flags |= HVhek_UTF8;
	else
	    flags &= ~HVhek_UTF8;
        if (key != keysave) {
	    if (flags & HVhek_FREEKEY)
		Safefree(keysave);
a455 1
	}
d460 1
a460 3
	/* We don't have a pointer to the hv, so we have to replicate the
	   flag into every HEK, so that hv_iterkeysv can see it.  */
	/* And yes, you do need this even though you are not "storing" because
d465 1
a465 9
	/* Not enough shared hash key scalars around to make this worthwhile
	   (about 4% slowdown in perlbench with this in)
        if (keysv && (SvIsCOW_shared_hash(keysv))) {
            hash = SvUVX(keysv);
        } else
	*/
	{
            PERL_HASH(hash, key, klen);
        }
d468 7
a474 16
    masked_flags = (flags & HVhek_MASK);
    n_links = 0;

#ifdef DYNAMIC_ENV_FETCH
    if (!xhv->xhv_array /* !HvARRAY(hv) */) entry = Null(HE*);
    else
#endif
    {
	/* entry = (HvARRAY(hv))[hash & (I32) HvMAX(hv)]; */
	entry = ((HE**)xhv->xhv_array)[hash & (I32) xhv->xhv_max];
    }
    for (; entry; ++n_links, entry = HeNEXT(entry)) {
	if (HeHASH(entry) != hash)		/* strings can't be equal */
	    continue;
	if (HeKLEN(entry) != (I32)klen)
	    continue;
d477 1
a477 1
	if ((HeKFLAGS(entry) ^ masked_flags) & HVhek_UTF8)
d479 23
a501 52

        if (action & (HV_FETCH_LVALUE|HV_FETCH_ISSTORE)) {
	    if (HeKFLAGS(entry) != masked_flags) {
		/* We match if HVhek_UTF8 bit in our flags and hash key's
		   match.  But if entry was set previously with HVhek_WASUTF8
		   and key now doesn't (or vice versa) then we should change
		   the key's flag, as this is assignment.  */
		if (HvSHAREKEYS(hv)) {
		    /* Need to swap the key we have for a key with the flags we
		       need. As keys are shared we can't just write to the
		       flag, so we share the new one, unshare the old one.  */
		    HEK *new_hek = share_hek_flags(key, klen, hash,
						   masked_flags);
		    unshare_hek (HeKEY_hek(entry));
		    HeKEY_hek(entry) = new_hek;
		}
		else
		    HeKFLAGS(entry) = masked_flags;
		if (masked_flags & HVhek_ENABLEHVKFLAGS)
		    HvHASKFLAGS_on(hv);
	    }
	    if (HeVAL(entry) == &PL_sv_placeholder) {
		/* yes, can store into placeholder slot */
		if (action & HV_FETCH_LVALUE) {
		    if (SvMAGICAL(hv)) {
			/* This preserves behaviour with the old hv_fetch
			   implementation which at this point would bail out
			   with a break; (at "if we find a placeholder, we
			   pretend we haven't found anything")

			   That break mean that if a placeholder were found, it
			   caused a call into hv_store, which in turn would
			   check magic, and if there is no magic end up pretty
			   much back at this point (in hv_store's code).  */
			break;
		    }
		    /* LVAL fetch which actaully needs a store.  */
		    val = NEWSV(61,0);
		    xhv->xhv_placeholders--;
		} else {
		    /* store */
		    if (val != &PL_sv_placeholder)
			xhv->xhv_placeholders--;
		}
		HeVAL(entry) = val;
	    } else if (action & HV_FETCH_ISSTORE) {
		SvREFCNT_dec(HeVAL(entry));
		HeVAL(entry) = val;
	    }
	} else if (HeVAL(entry) == &PL_sv_placeholder) {
	    /* if we find a placeholder, we pretend we haven't found
	       anything */
a502 3
	}
	if (flags & HVhek_FREEKEY)
	    Safefree(key);
d506 1
a506 2
    if (!(action & HV_FETCH_ISSTORE) 
	&& SvRMAGICAL((SV*)hv) && mg_find((SV*)hv, PERL_MAGIC_env)) {
d512 1
a512 2
	    return hv_fetch_common(hv,keysv,key,klen,flags,HV_FETCH_ISSTORE,sv,
				   hash);
d516 1
a516 2

    if (!entry && SvREADONLY(hv) && !(action & HV_FETCH_ISEXISTS)) {
d521 95
a615 4
    if (!(action & (HV_FETCH_LVALUE|HV_FETCH_ISSTORE))) {
	/* Not doing some form of store, so return failure.  */
	if (flags & HVhek_FREEKEY)
	    Safefree(key);
d617 122
d740 71
a810 11
    if (action & HV_FETCH_LVALUE) {
	val = NEWSV(61,0);
	if (SvMAGICAL(hv)) {
	    /* At this point the old hv_fetch code would call to hv_store,
	       which in turn might do some tied magic. So we need to make that
	       magic check happen.  */
	    /* gonna assign to this, so it better be there */
	    return hv_fetch_common(hv, keysv, key, klen, flags,
				   HV_FETCH_ISSTORE, val, hash);
	    /* XXX Surely that could leak if the fetch-was-store fails?
	       Just like the hv_fetch.  */
d814 23
a836 7
    /* Welcome to hv_store...  */

    if (!xhv->xhv_array) {
	/* Not sure if we can get here.  I think the only case of oentry being
	   NULL is for %ENV with dynamic env fetch.  But that should disappear
	   with magic in the previous code.  */
	Newz(503, xhv->xhv_array /* HvARRAY(hv) */,
d839 39
d880 5
a884 1
    oentry = &((HE**)xhv->xhv_array)[hash & (I32) xhv->xhv_max];
a896 5
    if (val == &PL_sv_placeholder)
	xhv->xhv_placeholders++;
    if (masked_flags & HVhek_ENABLEHVKFLAGS)
	HvHASKFLAGS_on(hv);

d905 160
a1064 4
	   list they could exhaust our memory as we repeatedly double the
	   number of buckets on every entry. Linear search feels a less worse
	   thing to do.  */
        hsplit(hv);
d1066 4
a1069 20

    return entry;
}

STATIC void
S_hv_magic_check(pTHX_ HV *hv, bool *needs_copy, bool *needs_store)
{
    MAGIC *mg = SvMAGIC(hv);
    *needs_copy = FALSE;
    *needs_store = TRUE;
    while (mg) {
	if (isUPPER(mg->mg_type)) {
	    *needs_copy = TRUE;
	    switch (mg->mg_type) {
	    case PERL_MAGIC_tied:
	    case PERL_MAGIC_sig:
		*needs_store = FALSE;
	    }
	}
	mg = mg->mg_moremagic;
a1070 1
}
d1072 3
a1074 53
/*
=for apidoc hv_scalar

Evaluates the hash in scalar context and returns the result. Handles magic when the hash is tied.

=cut
*/

SV *
Perl_hv_scalar(pTHX_ HV *hv)
{
    MAGIC *mg;
    SV *sv;
    
    if ((SvRMAGICAL(hv) && (mg = mg_find((SV*)hv, PERL_MAGIC_tied)))) {
        sv = magic_scalarpack(hv, mg);
        return sv;
    } 

    sv = sv_newmortal();
    if (HvFILL((HV*)hv)) 
        Perl_sv_setpvf(aTHX_ sv, "%ld/%ld",
                (long)HvFILL(hv), (long)HvMAX(hv) + 1);
    else
        sv_setiv(sv, 0);
    
    return sv;
}

/*
=for apidoc hv_delete

Deletes a key/value pair in the hash.  The value SV is removed from the
hash and returned to the caller.  The C<klen> is the length of the key.
The C<flags> value will normally be zero; if set to G_DISCARD then NULL
will be returned.

=cut
*/

SV *
Perl_hv_delete(pTHX_ HV *hv, const char *key, I32 klen_i32, I32 flags)
{
    STRLEN klen;
    int k_flags = 0;

    if (klen_i32 < 0) {
	klen = -klen_i32;
	k_flags |= HVhek_UTF8;
    } else {
	klen = klen_i32;
    }
    return hv_delete_common(hv, NULL, key, klen, k_flags, flags, 0);
a1090 7
    return hv_delete_common(hv, keysv, NULL, 0, 0, flags, hash);
}

SV *
S_hv_delete_common(pTHX_ HV *hv, SV *keysv, const char *key, STRLEN klen,
		   int k_flags, I32 d_flags, U32 hash)
{
d1093 2
d1099 2
a1100 1
    int masked_flags;
a1103 11

    if (keysv) {
	if (k_flags & HVhek_FREEKEY)
	    Safefree(key);
	key = SvPV(keysv, klen);
	k_flags = 0;
	is_utf8 = (SvUTF8(keysv) != 0);
    } else {
	is_utf8 = ((k_flags & HVhek_UTF8) ? TRUE : FALSE);
    }

d1109 13
a1121 17
	if (needs_copy) {
	    entry = hv_fetch_common(hv, keysv, key, klen,
				    k_flags & ~HVhek_FREEKEY, HV_FETCH_LVALUE,
				    Nullsv, hash);
	    sv = entry ? HeVAL(entry) : NULL;
	    if (sv) {
		if (SvMAGICAL(sv)) {
		    mg_clear(sv);
		}
		if (!needs_store) {
		    if (mg_find(sv, PERL_MAGIC_tiedelem)) {
			/* No longer an element */
			sv_unmagic(sv, PERL_MAGIC_tiedelem);
			return sv;
		    }		
		    return Nullsv;		/* element cannot be deleted */
		}
d1123 6
a1128 11
		else if (mg_find((SV*)hv, PERL_MAGIC_env)) {
		    /* XXX This code isn't UTF8 clean.  */
		    keysv = sv_2mortal(newSVpvn(key,klen));
		    if (k_flags & HVhek_FREEKEY) {
			Safefree(key);
		    }
		    key = strupr(SvPVX(keysv));
		    is_utf8 = 0;
		    k_flags = 0;
		    hash = 0;
		}
a1129 1
	    }
d1136 3
d1140 1
a1140 3
    const char *keysave = key;
    key = (char*)bytes_from_utf8((U8*)key, &klen, &is_utf8);

d1142 3
a1144 12
            k_flags |= HVhek_UTF8;
	else
            k_flags &= ~HVhek_UTF8;
        if (key != keysave) {
	    if (k_flags & HVhek_FREEKEY) {
		/* This shouldn't happen if our caller does what we expect,
		   but strictly the API allows it.  */
		Safefree(keysave);
	    }
	    k_flags |= HVhek_WASUTF8 | HVhek_FREEKEY;
	}
        HvHASKFLAGS_on((SV*)hv);
d1150 1
a1150 9
	/* Not enough shared hash key scalars around to make this worthwhile
	   (about 4% slowdown in perlbench with this in)
        if (keysv && (SvIsCOW_shared_hash(keysv))) {
            hash = SvUVX(keysv);
        } else
	*/
	{
            PERL_HASH(hash, key, klen);
        }
a1152 2
    masked_flags = (k_flags & HVhek_MASK);

d1164 1
a1164 1
	if ((HeKFLAGS(entry) ^ masked_flags) & HVhek_UTF8)
d1195 1
a1195 1
	if (d_flags & G_DISCARD)
d1238 214
d1840 1
a1840 1
    if (SvREADONLY(hv) && xhv->xhv_array != NULL) {
d1861 1
a1861 1
	goto reset;
a1874 57
    reset:
    HvEITER(hv) = NULL;
}

/*
=for apidoc hv_clear_placeholders

Clears any placeholders from a hash.  If a restricted hash has any of its keys
marked as readonly and the key is subsequently deleted, the key is not actually
deleted but is marked by assigning it a value of &PL_sv_placeholder.  This tags
it so it will be ignored by future operations such as iterating over the hash,
but will still allow the hash to have a value reaasigned to the key at some
future point.  This function clears any such placeholder keys from the hash.
See Hash::Util::lock_keys() for an example of its use.

=cut
*/

void
Perl_hv_clear_placeholders(pTHX_ HV *hv)
{
    I32 items;
    items = (I32)HvPLACEHOLDERS(hv);
    if (items) {
        HE *entry;
        I32 riter = HvRITER(hv);
        HE *eiter = HvEITER(hv);
        hv_iterinit(hv);
        /* This may look suboptimal with the items *after* the iternext, but
           it's quite deliberate. We only get here with items==0 if we've
           just deleted the last placeholder in the hash. If we've just done
           that then it means that the hash is in lazy delete mode, and the
           HE is now only referenced in our iterator. If we just quit the loop
           and discarded our iterator then the HE leaks. So we do the && the
           other way to ensure iternext is called just one more time, which
           has the side effect of triggering the lazy delete.  */
        while ((entry = hv_iternext_flags(hv, HV_ITERNEXT_WANTPLACEHOLDERS))
            && items) {
            SV *val = hv_iterval(hv, entry);

            if (val == &PL_sv_placeholder) {

                /* It seems that I have to go back in the front of the hash
                   API to delete a hash, even though I have a HE structure
                   pointing to the very entry I want to delete, and could hold
                   onto the previous HE that points to it. And it's easier to
                   go in with SVs as I can then specify the precomputed hash,
                   and don't have fun and games with utf8 keys.  */
                SV *key = hv_iterkeysv(entry);

                hv_delete_ent (hv, key, G_DISCARD, HeHASH(entry));
                items--;
            }
        }
        HvRITER(hv) = riter;
        HvEITER(hv) = eiter;
    }
d2429 1
a2429 1
	HeKEY_hek(entry) = save_hek_flags(str, len, hash, flags_masked);
@


1.1.1.8
log
@Import of stock perl 5.8.5
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, by Larry Wall and others
d372 1
a372 1
STATIC HE *
d873 1
a873 1
STATIC SV *
d988 2
d994 16
a1009 3
	  if (k_flags & HVhek_FREEKEY)
            Safefree(key);
	  return Nullsv;
a1015 2
        if (k_flags & HVhek_FREEKEY)
            Safefree(key);
a1030 1
	    SvREFCNT_dec(HeVAL(entry));
a1074 11
    /*PerlIO_printf(PerlIO_stderr(), "hsplit called for %p which had %d\n",
      hv, (int) oldsize);*/

    if (HvPLACEHOLDERS(hv) && !SvREADONLY(hv)) {
      /* Can make this clear any placeholders first for non-restricted hashes,
	 even though Storable rebuilds restricted hashes by putting in all the
	 placeholders (first) before turning on the readonly flag, because
	 Storable always pre-splits the hash.  */
      hv_clear_placeholders(hv);
    }
	       
d1504 28
a1531 2
    I32 items = (I32)HvPLACEHOLDERS(hv);
    I32 i = HvMAX(hv);
d1533 7
a1539 39
    if (items == 0)
	return;

    do {
	/* Loop down the linked list heads  */
	int first = 1;
	HE **oentry = &(HvARRAY(hv))[i];
	HE *entry = *oentry;

	if (!entry)
	    continue;

	for (; entry; entry = *oentry) {
	    if (HeVAL(entry) == &PL_sv_placeholder) {
		*oentry = HeNEXT(entry);
		if (first && !*oentry)
		    HvFILL(hv)--; /* This linked list is now empty.  */
		if (HvEITER(hv))
		    HvLAZYDEL_on(hv);
		else
		    hv_free_ent(hv, entry);

		if (--items == 0) {
		    /* Finished.  */
		    HvTOTALKEYS(hv) -= HvPLACEHOLDERS(hv);
		    if (HvKEYS(hv) == 0)
			HvHASKFLAGS_off(hv);
		    HvPLACEHOLDERS(hv) = 0;
		    return;
		}
	    } else {
		oentry = &HeNEXT(entry);
		first = 0;
	    }
	}
    } while (--i >= 0);
    /* You can't get here, hence assertion should always fail.  */
    assert (items == 0);
    assert (0);
d2019 1
a2019 2
                    "Attempt to free non-existent shared string '%s'%s"
                    pTHX__FORMAT,
d2021 1
a2021 1
                    ((k_flags & HVhek_UTF8) ? " (utf8)" : "") pTHX__VALUE);
@


1.1.1.9
log
@perl 5.8.6 from CPAN
@
text
@a16 10

A HV structure represents a Perl hash. It consists mainly of an array
of pointers, each of which points to a linked list of HE structures. The
array is indexed by the hash function of the key, so each linked list
represents all the hash entries with the same hash value. Each HE contains
a pointer to the actual value, plus a pointer to a HEK structure which
holds the key and hash value.

=cut

d221 1
a221 1
			   (HV_FETCH_ISSTORE|HV_FETCH_JUST_SV), val, hash);
a507 1
		keysv = 0;
a549 1
		    keysv = 0;
d1493 1
a1493 1
but will still allow the hash to have a value reassigned to the key at some
@


1.1.1.10
log
@perl 5.8.8 import
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006, by Larry Wall and others
a35 20
STATIC void
S_more_he(pTHX)
{
    register HE* he;
    register HE* heend;
    XPV *ptr;
    Newx(ptr, PERL_ARENA_SIZE/sizeof(XPV), XPV);
    ptr->xpv_pv = (char*)PL_he_arenaroot;
    PL_he_arenaroot = ptr;

    he = (HE*)ptr;
    heend = &he[PERL_ARENA_SIZE / sizeof(HE) - 1];
    PL_he_root = ++he;
    while (he < heend) {
	HeNEXT(he) = (HE*)(he + 1);
	he++;
    }
    HeNEXT(he) = 0;
}

d42 1
a42 1
	S_more_he(aTHX);
d58 20
d93 1
a93 1
    const int flags_masked = flags & HVhek_MASK;
d97 1
a97 1
    Newx(k, HEK_BASESIZE + len + 2, char);
d110 1
a110 1
/* free the pool of temporary HE/HEK pairs returned by hv_fetch_ent
d116 1
a118 1
	HE * const ohe = he;
d120 1
d147 1
a147 1
	Newx(k, HEK_BASESIZE + sizeof(SV*), char);
d166 1
a166 1
    SV *sv = sv_newmortal();
d178 2
a179 1
    Perl_croak(aTHX_ msg, sv);
d239 1
a239 1
    HE * const hek = hv_fetch_common (hv, NULL, key, klen, flags,
d387 1
d400 1
a400 1
	key = SvPV_const(keysv, klen);
d434 1
a434 1
		    Newx(k, HEK_BASESIZE + sizeof(SV*), char);
d458 1
a458 1
			const char *nkey = strupr(savepvn(key,klen));
d484 1
d487 1
a487 1
		SV * const svret = sv_newmortal();
d512 1
a512 1
		char * const keysave = (char * const)key;
d532 1
a532 1
		const bool save_taint = PL_tainted;
d578 2
a579 3
								  ) {
	    char *array;
	    Newxz(array,
a581 2
	    HvARRAY(hv) = (HE**)array;
	}
d598 1
a598 1
	char * const keysave = (char * const)key;
d623 1
a623 1
            hash = SvSHARED_HASH(keysv);
d632 1
d642 1
a642 3
    for (; entry; entry = HeNEXT(entry)) {
	if (!HeKEY_hek(entry))
	    continue;
d713 1
a713 1
	const char * const env = PerlEnv_ENVgetenv_len(key,&len);
d725 2
a726 2
			"Attempt to access disallowed key '%"SVf"' in"
			" a restricted hash");
d754 1
a754 2
	char *array;
	Newxz(array,
a756 1
	HvARRAY(hv) = (HE**)array;
d777 12
a788 24
    {
	const HE *counter = HeNEXT(entry);

	xhv->xhv_keys++; /* HvKEYS(hv)++ */
	if (!counter) {				/* initial entry? */
	    xhv->xhv_fill++; /* HvFILL(hv)++ */
	} else if (xhv->xhv_keys > (IV)xhv->xhv_max) {
	    hsplit(hv);
	} else if(!HvREHASH(hv)) {
	    U32 n_links = 1;

	    while ((counter = HeNEXT(counter)))
		n_links++;

	    if (n_links > HV_MAX_LENGTH_BEFORE_SPLIT) {
		/* Use only the old HvKEYS(hv) > HvMAX(hv) condition to limit
		   bucket splits on a rehashed hash, as we're not going to
		   split it again, and if someone is lucky (evil) enough to
		   get all the keys in one list they could exhaust our memory
		   as we repeatedly double the number of buckets on every
		   entry. Linear search feels a less worse thing to do.  */
		hsplit(hv);
	    }
	}
d797 1
a797 1
    const MAGIC *mg = SvMAGIC(hv);
d803 3
a805 1
	    if (mg->mg_type == PERL_MAGIC_tied) {
a806 1
		return; /* We've set all there is to set. */
d824 1
d826 5
a830 6

    if (SvRMAGICAL(hv)) {
	MAGIC * const mg = mg_find((SV*)hv, PERL_MAGIC_tied);
	if (mg)
	    return magic_scalarpack(hv, mg);
    }
d890 1
a892 1
    HE *const *first_entry;
d903 1
a903 1
	key = SvPV_const(keysv, klen);
d953 2
a954 2
	const char *keysave = key;
	key = (char*)bytes_from_utf8((U8*)key, &klen, &is_utf8);
d977 1
a977 1
            hash = SvSHARED_HASH(keysv);
d988 1
a988 1
    first_entry = oentry = &((HE**)xhv->xhv_array)[hash & (I32) xhv->xhv_max];
d990 2
a991 1
    for (; entry; oentry = &HeNEXT(entry), entry = *oentry) {
d1010 2
a1011 2
			    "Attempt to delete readonly key '%"SVf"' from"
			    " a restricted hash");
d1037 1
a1037 1
	    if(!*first_entry) {
a1038 1
	    }
d1051 2
a1052 2
			"Attempt to delete disallowed key '%"SVf"' from"
			" a restricted hash");
d1064 1
a1064 1
    const I32 oldsize = (I32) xhv->xhv_max+1; /* HvMAX(hv)+1 (sick) */
d1069 2
d1078 1
a1078 1
    if (HvPLACEHOLDERS_get(hv) && !SvREADONLY(hv)) {
d1094 1
a1094 1
    Newx(a, PERL_HV_ARRAY_ALLOC_BYTES(newsize), char);
a1116 2
	register HE *entry;
	register HE **bep;
d1165 1
a1165 1
    Newxz(a, PERL_HV_ARRAY_ALLOC_BYTES(newsize), char);
d1175 1
a1175 1
	register HE *entry = *aep;
d1179 1
a1179 1
	    HE * const next = HeNEXT(entry);
a1180 1
	    HE **bep;
d1187 1
a1187 1
		HEK * const new_hek
d1218 1
a1218 1
    const I32 oldsize = (I32) xhv->xhv_max+1; /* HvMAX(hv)+1 (sick) */
d1221 1
d1248 1
a1248 1
	Newx(a, PERL_HV_ARRAY_ALLOC_BYTES(newsize), char);
d1265 1
a1265 1
	Newxz(a, PERL_HV_ARRAY_ALLOC_BYTES(newsize), char);
a1276 1
	    register I32 j;
d1304 1
a1305 1
    HV * const hv = (HV*)NEWSV(502,0);
d1307 1
d1326 1
a1326 1
    HV * const hv = newHV();
d1336 2
a1337 2
	const bool shared = !!HvSHAREKEYS(ohv);
	HE **ents, ** const oents = (HE **)HvARRAY(ohv);
d1339 1
a1339 1
	Newx(a, PERL_HV_ARRAY_ALLOC_BYTES(hv_max+1), char);
d1344 1
a1344 2
	    HE *prev = NULL, *ent = NULL;
	    HE *oent = oents[i];
d1352 5
a1356 5
	    for (; oent; oent = HeNEXT(oent)) {
		const U32 hash   = HeHASH(oent);
		const char * const key = HeKEY(oent);
		const STRLEN len = HeKLEN(oent);
		const int flags  = HeKFLAGS(oent);
d1376 1
a1376 1
    } /* not magical */
d1380 2
a1381 2
	const I32 riter = HvRITER_get(ohv);
	HE * const eiter = HvEITER_get(ohv);
d1394 2
a1395 2
	HvRITER_set(ohv, riter);
	HvEITER_set(ohv, eiter);
d1409 1
a1409 1
    if (val && isGV(val) && GvCVu(val) && HvNAME_get(hv))
d1428 3
a1430 2
    /* SvREFCNT_inc to counter the SvREFCNT_dec in hv_free_ent  */
    sv_2mortal(SvREFCNT_inc(HeVAL(entry)));	/* free between statements */
d1432 2
a1433 1
	sv_2mortal(SvREFCNT_inc(HeKEY_sv(entry)));
d1435 5
a1439 1
    hv_free_ent(hv, entry);
d1461 4
a1464 3
	STRLEN i;
	for (i = 0; i <= xhv->xhv_max; i++) {
	    HE *entry = ((HE**)xhv->xhv_array)[i];
d1495 1
a1495 1
    HvEITER_set(hv, NULL);
d1515 2
a1516 2
    I32 items = (I32)HvPLACEHOLDERS_get(hv);
    I32 i;
a1520 1
    i = HvMAX(hv);
d1523 1
a1523 1
	bool first = 1;
d1535 1
a1535 1
		if (entry == HvEITER_get(hv))
d1542 1
a1542 1
		    HvTOTALKEYS(hv) -= (IV)HvPLACEHOLDERS_get(hv);
d1545 1
a1545 1
		    HvPLACEHOLDERS_set(hv, 0);
d1564 1
d1568 2
a1569 1

d1585 1
a1585 1
	    register HE * const oentry = entry;
a1610 1
    const char *name;
d1616 1
a1616 2
    if ((name = HvNAME_get(hv))) {
	/* FIXME - strlen HvNAME  */
d1618 3
a1620 2
	    hv_delete(PL_stashcache, name, strlen(name), G_DISCARD);
	hv_name_set(hv, Nullch, 0, 0);
d1662 1
a1662 1
    return HvTOTALKEYS(hv);
d1727 1
a1727 1
	    Newxz(k, HEK_BASESIZE + sizeof(SV*), char);
d1746 1
a1746 1
    if (!entry && SvRMAGICAL((SV*)hv) && mg_find((SV*)hv, PERL_MAGIC_env)) {
a1747 8
#ifdef VMS
	/* The prime_env_iter() on VMS just loaded up new hash values
	 * so the iteration count needs to be reset back to the beginning
	 */
	hv_iterinit(hv);
	oldentry = entry = xhv->xhv_eiter; /* HvEITER(hv) */
#endif
    }
d1841 33
a1873 1
    return sv_2mortal(newSVhek(HeKEY_hek(entry)));
d1893 1
a1893 2
	    else
		mg_copy((SV*)hv, sv, HeKEY(entry), HeKLEN(entry));
d1969 2
a1970 2
    HE **first;
    bool found = 0;
d1973 1
a1973 1
    const char * const save = str;
d1998 1
a1998 1
    first = oentry = &((HE**)xhv->xhv_array)[hash & (I32) xhv->xhv_max];
d2000 1
a2000 1
        for (entry = *oentry; entry; oentry = &HeNEXT(entry), entry = *oentry) {
d2007 2
a2008 2
        const int flags_masked = k_flags & HVhek_MASK;
        for (entry = *oentry; entry; oentry = &HeNEXT(entry), entry = *oentry) {
d2025 1
a2025 2
            if (!*first) {
		/* There are now no entries in our slot.  */
a2026 1
	    }
d2053 1
a2053 1
    const char * const save = str;
d2081 1
d2083 1
a2083 1
    const int flags_masked = flags & HVhek_MASK;
d2098 1
a2098 1
    for (entry = *oentry; entry; entry = HeNEXT(entry)) {
a2110 4
	/* What used to be head of the list.
	   If this is NULL, then we're the first entry for this slot, which
	   means we need to increate fill.  */
	const HE *old_first = *oentry;
d2117 1
a2117 1
	if (!old_first) {			/* initial entry? */
a2131 10

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 noet:
 */
@


1.1.1.11
log
@import perl 5.10.0 from CPAN
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, by Larry Wall and others
a35 3
static const char S_strtab_error[]
    = "Cannot modify shared string table in hv_%s";

d39 10
a48 5
    dVAR;
    HE* he = (HE*) Perl_get_arena(aTHX_ PERL_ARENA_SIZE, HE_SVSLOT);
    HE * const heend = &he[PERL_ARENA_SIZE / sizeof(HE) - 1];

    PL_body_roots[HE_SVSLOT] = he;
a55 7
#ifdef PURIFY

#define new_HE() (HE*)safemalloc(sizeof(HE))
#define del_HE(p) safefree((char*)p)

#else

a58 1
    dVAR;
d60 2
a61 3
    void ** const root = &PL_body_roots[HE_SVSLOT];

    if (!*root)
d63 3
a65 3
    he = (HE*) *root;
    assert(he);
    *root = HeNEXT(he);
d69 13
a81 6
#define new_HE() new_he()
#define del_HE(p) \
    STMT_START { \
	HeNEXT(p) = (HE*)(PL_body_roots[HE_SVSLOT]);	\
	PL_body_roots[HE_SVSLOT] = p; \
    } STMT_END
d83 1
d85 2
d91 1
a91 1
S_save_hek_flags(const char *str, I32 len, U32 hash, int flags)
d103 1
a103 1
    HEK_FLAGS(hek) = (unsigned char)flags_masked | HVhek_UNSHARED;
a115 1
    dVAR;
d123 1
a123 1
    PL_hv_fetch_ent_mh = NULL;
a126 20
HEK *
Perl_hek_dup(pTHX_ HEK *source, CLONE_PARAMS* param)
{
    HEK *shared = (HEK*)ptr_table_fetch(PL_ptr_table, source);

    PERL_UNUSED_ARG(param);

    if (shared) {
	/* We already shared this hash key.  */
	(void)share_hek_hek(shared);
    }
    else {
	shared
	    = share_hek_flags(HEK_KEY(source), HEK_LEN(source),
			      HEK_HASH(source), HEK_FLAGS(source));
	ptr_table_store(PL_ptr_table, source, shared);
    }
    return shared;
}

d128 1
a128 1
Perl_he_dup(pTHX_ const HE *e, bool shared, CLONE_PARAMS* param)
d133 1
a133 1
	return NULL;
d150 3
a152 18
    else if (shared) {
	/* This is hek_dup inlined, which seems to be important for speed
	   reasons.  */
	HEK * const source = HeKEY_hek(e);
	HEK *shared = (HEK*)ptr_table_fetch(PL_ptr_table, source);

	if (shared) {
	    /* We already shared this hash key.  */
	    (void)share_hek_hek(shared);
	}
	else {
	    shared
		= share_hek_flags(HEK_KEY(source), HEK_LEN(source),
				  HEK_HASH(source), HEK_FLAGS(source));
	    ptr_table_store(PL_ptr_table, source, shared);
	}
	HeKEY_hek(ret) = shared;
    }
d165 1
a165 1
    SV * const sv = sv_newmortal();
d177 1
a177 1
    Perl_croak(aTHX_ msg, SVfARG(sv));
d183 5
d211 32
d268 10
d283 21
d314 24
d347 7
d373 2
a374 4
/* Common code for hv_delete()/hv_exists()/hv_fetch()/hv_store()  */
void *
Perl_hv_common_key_len(pTHX_ HV *hv, const char *key, I32 klen_i32,
		       const int action, SV *val, const U32 hash)
d376 2
a377 11
    STRLEN klen;
    int flags;

    if (klen_i32 < 0) {
	klen = -klen_i32;
	flags = HVhek_UTF8;
    } else {
	klen = klen_i32;
	flags = 0;
    }
    return hv_common(hv, NULL, key, klen, flags, action, val, hash);
d380 3
a382 3
void *
Perl_hv_common(pTHX_ HV *hv, SV *keysv, const char *key, STRLEN klen,
	       int flags, int action, SV *val, register U32 hash)
a383 1
    dVAR;
a389 1
    const int return_svp = action & HV_FETCH_JUST_SV;
d392 1
a392 24
	return NULL;
    if (SvTYPE(hv) == SVTYPEMASK)
	return NULL;

    assert(SvTYPE(hv) == SVt_PVHV);

    if (SvSMAGICAL(hv) && SvGMAGICAL(hv) && !(action & HV_DISABLE_UVAR_XKEY)) {
	MAGIC* mg;
	if ((mg = mg_find((SV*)hv, PERL_MAGIC_uvar))) {
	    struct ufuncs * const uf = (struct ufuncs *)mg->mg_ptr;
	    if (uf->uf_set == NULL) {
		SV* obj = mg->mg_obj;

		if (!keysv) {
		    keysv = sv_2mortal(newSVpvn(key, klen));
		    if (flags & HVhek_UTF8)
			SvUTF8_on(keysv);
		}
		
		mg->mg_obj = keysv;         /* pass key */
		uf->uf_index = action;      /* pass action */
		magic_getuvar((SV*)hv, mg);
		keysv = mg->mg_obj;         /* may have changed */
		mg->mg_obj = obj;
a393 6
		/* If the key may have changed, then we need to invalidate
		   any passed-in computed hash value.  */
		hash = 0;
	    }
	}
    }
a403 6
    if (action & HV_DELETE) {
	return (void *) hv_delete_common(hv, keysv, key, klen,
					 flags | (is_utf8 ? HVhek_UTF8 : 0),
					 action, hash);
    }

d406 6
a411 4
	if (SvRMAGICAL(hv) && !(action & (HV_FETCH_ISSTORE|HV_FETCH_ISEXISTS))) {
	    if ( mg_find((SV*)hv, PERL_MAGIC_tied) || SvGMAGICAL((SV*)hv))
	    {
		/* FIXME should be able to skimp on the HE/HEK here when
d413 1
d422 1
a422 2
                sv = sv_newmortal();
                mg_copy((SV*)hv, sv, (char *)keysv, HEf_SVKEY);
d434 1
a434 1
		HeNEXT(entry) = NULL;
d446 1
a446 4
		if (return_svp) {
		    return entry ? (void *) &HeVAL(entry) : NULL;
		}
		return (void *) entry;
d455 1
a455 1
			const char * const nkey = strupr(savepvn(key,klen));
d458 6
a463 8
			void *result = hv_common(hv, NULL, nkey, klen,
						 HVhek_FREEKEY, /* free nkey */
						 0 /* non-LVAL fetch */
						 | HV_DISABLE_UVAR_XKEY
						 | return_svp,
						 NULL /* no value */,
						 0 /* compute hash */);
			if (!result && (action & HV_FETCH_LVALUE)) {
d467 3
a469 5
			    result = hv_common(hv, keysv, key, klen, flags,
					       HV_FETCH_ISSTORE
					       | HV_DISABLE_UVAR_XKEY
					       | return_svp,
					       newSV(0), hash);
d474 1
a474 1
			return result;
d503 1
a503 1
		return SvTRUE(svret) ? (void *)hv : NULL;
d512 1
a512 1
		is_utf8 = FALSE;
d543 1
a543 1
		if (!needs_store) {
d546 1
a546 1
		    return NULL;
d555 1
a555 1
		    is_utf8 = FALSE;
d569 1
a569 1
    if (!HvARRAY(hv)) {
d592 1
a592 1
	    return NULL;
d597 1
a597 1
	char * const keysave = (char *)key;
d619 2
d623 3
a625 1
        } else {
d633 1
a633 1
    if (!HvARRAY(hv)) entry = NULL;
d637 2
a638 1
	entry = (HvARRAY(hv))[hash & (I32) HvMAX(hv)];
d641 2
d662 1
a662 1
		    HEK * const new_hek = share_hek_flags(key, klen, hash,
a666 8
		else if (hv == PL_strtab) {
		    /* PL_strtab is usually the only hash without HvSHAREKEYS,
		       so putting this test here is cheap  */
		    if (flags & HVhek_FREEKEY)
			Safefree(key);
		    Perl_croak(aTHX_ S_strtab_error,
			       action & HV_FETCH_LVALUE ? "fetch" : "store");
		}
d688 2
a689 2
		    val = newSV(0);
		    HvPLACEHOLDERS(hv)--;
d693 1
a693 1
			HvPLACEHOLDERS(hv)--;
a706 3
	if (return_svp) {
	    return entry ? (void *) &HeVAL(entry) : NULL;
	}
d717 2
a718 3
	    return hv_common(hv, keysv, key, klen, flags,
			     HV_FETCH_ISSTORE|HV_DISABLE_UVAR_XKEY|return_svp,
			     sv, hash);
d724 1
a724 1
	hv_notallowed(flags, key, klen,
d732 1
a732 1
	return NULL;
d735 1
a735 1
	val = newSV(0);
d741 2
a742 9
	    /* If a fetch-as-store fails on the fetch, then the action is to
	       recurse once into "hv_store". If we didn't do this, then that
	       recursive call would call the key conversion routine again.
	       However, as we replace the original key with the converted
	       key, this would result in a double conversion, which would show
	       up as a bug if the conversion routine is not idempotent.  */
	    return hv_common(hv, keysv, key, klen, flags,
			     HV_FETCH_ISSTORE|HV_DISABLE_UVAR_XKEY|return_svp,
			     val, hash);
d750 1
a750 1
    if (!HvARRAY(hv)) {
d761 1
a761 1
    oentry = &(HvARRAY(hv))[hash & (I32) xhv->xhv_max];
a767 8
    else if (hv == PL_strtab) {
	/* PL_strtab is usually the only hash without HvSHAREKEYS, so putting
	   this test here is cheap  */
	if (flags & HVhek_FREEKEY)
	    Safefree(key);
	Perl_croak(aTHX_ S_strtab_error,
		   action & HV_FETCH_LVALUE ? "fetch" : "store");
    }
d775 1
a775 1
	HvPLACEHOLDERS(hv)++;
d782 1
a782 1
	xhv->xhv_keys++; /* HvTOTALKEYS(hv)++ */
d805 1
a805 4
    if (return_svp) {
	return entry ? (void *) &HeVAL(entry) : NULL;
    }
    return (void *) entry;
d809 1
a809 1
S_hv_magic_check(HV *hv, bool *needs_copy, bool *needs_store)
d863 19
d892 6
a901 1
    dVAR;
d906 2
a907 1
    bool is_utf8 = (k_flags & HVhek_UTF8) ? TRUE : FALSE;
d910 13
d929 3
a931 5
	    SV *sv;
	    entry = (HE *) hv_common(hv, keysv, key, klen,
				     k_flags & ~HVhek_FREEKEY,
				     HV_FETCH_LVALUE|HV_DISABLE_UVAR_XKEY,
				     NULL, hash);
d943 1
a943 1
		    return NULL;		/* element cannot be deleted */
d962 2
a963 2
    if (!HvARRAY(hv))
	return NULL;
d966 1
a966 1
	const char * const keysave = key;
d987 2
d991 3
a993 1
        } else {
d1000 2
a1001 1
    first_entry = oentry = &(HvARRAY(hv))[hash & (I32) HvMAX(hv)];
a1003 1
	SV *sv;
a1012 6
	if (hv == PL_strtab) {
	    if (k_flags & HVhek_FREEKEY)
		Safefree(key);
	    Perl_croak(aTHX_ S_strtab_error, "delete");
	}

d1014 5
a1018 4
	if (HeVAL(entry) == &PL_sv_placeholder) {
	    if (k_flags & HVhek_FREEKEY)
		Safefree(key);
	    return NULL;
d1020 2
a1021 2
	if (SvREADONLY(hv) && HeVAL(entry) && SvREADONLY(HeVAL(entry))) {
	    hv_notallowed(k_flags, key, klen,
d1029 1
a1029 1
	    sv = NULL;
d1046 1
a1046 1
	    HvPLACEHOLDERS(hv)++;
d1052 1
a1052 1
	    if (SvOOK(hv) && entry == HvAUX(hv)->xhv_eiter /* HvEITER(hv) */)
d1056 1
a1056 1
	    xhv->xhv_keys--; /* HvTOTALKEYS(hv)-- */
d1063 1
a1063 1
	hv_notallowed(k_flags, key, klen,
d1070 1
a1070 1
    return NULL;
d1076 1
a1076 2
    dVAR;
    register XPVHV* const xhv = (XPVHV*)SvANY(hv);
d1080 1
a1080 1
    char *a = (char*) HvARRAY(hv);
d1087 1
a1087 1
      (void*)hv, (int) oldsize);*/
d1099 1
a1099 2
    Renew(a, PERL_HV_ARRAY_ALLOC_BYTES(newsize)
	  + (SvOOK(hv) ? sizeof(struct xpvhv_aux) : 0), char);
a1103 3
    if (SvOOK(hv)) {
	Copy(&a[oldsize * sizeof(HE*)], &a[newsize * sizeof(HE*)], 1, struct xpvhv_aux);
    }
d1105 1
a1105 2
    Newx(a, PERL_HV_ARRAY_ALLOC_BYTES(newsize)
	+ (SvOOK(hv) ? sizeof(struct xpvhv_aux) : 0), char);
d1110 1
a1110 4
    Copy(HvARRAY(hv), a, oldsize * sizeof(HE*), char);
    if (SvOOK(hv)) {
	Copy(HvAUX(hv), &a[newsize * sizeof(HE*)], 1, struct xpvhv_aux);
    }
d1112 2
a1113 3
	offer_nice_chunk(HvARRAY(hv),
			 PERL_HV_ARRAY_ALLOC_BYTES(oldsize)
			 + (SvOOK(hv) ? sizeof(struct xpvhv_aux) : 0));
d1116 1
a1116 1
	Safefree(HvARRAY(hv));
d1122 1
a1122 1
    HvARRAY(hv) = (HE**) a;
d1174 1
a1174 1
    /*PerlIO_printf(PerlIO_stderr(), "%p %d of %d with %d/%d buckets\n", (void*)hv,
d1178 1
a1178 6
    Newxz(a, PERL_HV_ARRAY_ALLOC_BYTES(newsize)
	 + (SvOOK(hv) ? sizeof(struct xpvhv_aux) : 0), char);
    if (SvOOK(hv)) {
	Copy(HvAUX(hv), &a[newsize * sizeof(HE*)], 1, struct xpvhv_aux);
    }

d1185 1
a1185 1
    aep = HvARRAY(hv);
d1224 2
a1225 2
    Safefree (HvARRAY(hv));
    HvARRAY(hv) = (HE **)a;
a1230 1
    dVAR;
d1251 1
a1251 1
    a = (char *) HvARRAY(hv);
d1255 1
a1255 2
	Renew(a, PERL_HV_ARRAY_ALLOC_BYTES(newsize)
	      + (SvOOK(hv) ? sizeof(struct xpvhv_aux) : 0), char);
a1259 3
	if (SvOOK(hv)) {
	    Copy(&a[oldsize * sizeof(HE*)], &a[newsize * sizeof(HE*)], 1, struct xpvhv_aux);
	}
d1261 1
a1261 2
	Newx(a, PERL_HV_ARRAY_ALLOC_BYTES(newsize)
	    + (SvOOK(hv) ? sizeof(struct xpvhv_aux) : 0), char);
d1266 1
a1266 4
	Copy(HvARRAY(hv), a, oldsize * sizeof(HE*), char);
	if (SvOOK(hv)) {
	    Copy(HvAUX(hv), &a[newsize * sizeof(HE*)], 1, struct xpvhv_aux);
	}
d1268 2
a1269 3
	    offer_nice_chunk(HvARRAY(hv),
			     PERL_HV_ARRAY_ALLOC_BYTES(oldsize)
			     + (SvOOK(hv) ? sizeof(struct xpvhv_aux) : 0));
d1272 1
a1272 1
	    Safefree(HvARRAY(hv));
d1281 1
a1281 1
    HvARRAY(hv) = (HE **) a;
d1290 2
a1291 3
	    register I32 j = (HeHASH(entry) & newsize);

	    if (j != i) {
d1319 3
a1321 1
    HV * const hv = (HV*)newSV_type(SVt_PVHV);
d1323 2
a1324 1
    assert(!SvOK(hv));
d1331 2
d1357 1
a1357 1
	    HE *prev = NULL;
a1370 1
		HE * const ent   = new_HE();
d1372 1
d1404 3
a1406 3
	    (void)hv_store_flags(hv, HeKEY(entry), HeKLEN(entry),
			         newSVsv(HeVAL(entry)), HeHASH(entry),
			         HeKFLAGS(entry));
a1414 33
/* A rather specialised version of newHVhv for copying %^H, ensuring all the
   magic stays on it.  */
HV *
Perl_hv_copy_hints_hv(pTHX_ HV *const ohv)
{
    HV * const hv = newHV();
    STRLEN hv_fill;

    if (ohv && (hv_fill = HvFILL(ohv))) {
	STRLEN hv_max = HvMAX(ohv);
	HE *entry;
	const I32 riter = HvRITER_get(ohv);
	HE * const eiter = HvEITER_get(ohv);

	while (hv_max && hv_max + 1 >= hv_fill * 2)
	    hv_max = hv_max / 2;
	HvMAX(hv) = hv_max;

	hv_iterinit(ohv);
	while ((entry = hv_iternext_flags(ohv, 0))) {
	    SV *const sv = newSVsv(HeVAL(entry));
	    sv_magic(sv, NULL, PERL_MAGIC_hintselem,
		     (char *)newSVhek (HeKEY_hek(entry)), HEf_SVKEY);
	    (void)hv_store_flags(hv, HeKEY(entry), HeKLEN(entry),
				 sv, HeHASH(entry), HeKFLAGS(entry));
	}
	HvRITER_set(ohv, riter);
	HvEITER_set(ohv, eiter);
    }
    hv_magic(hv, NULL, PERL_MAGIC_hints);
    return hv;
}

a1417 1
    dVAR;
d1423 2
a1424 2
    if (val && isGV(val) && isGV_with_GP(val) && GvCVu(val) && HvNAME_get(hv))
        mro_method_changed_in(hv);	/* deletion of method from stash */
a1439 1
    dVAR;
a1460 1
    dVAR;
a1464 2
    DEBUG_A(Perl_hv_assert(aTHX_ hv));

d1467 1
a1467 1
    if (SvREADONLY(hv) && HvARRAY(hv) != NULL) {
d1471 1
a1471 1
	    HE *entry = (HvARRAY(hv))[i];
d1476 1
a1476 1
			SV* const keysv = hv_iterkeysv(entry);
d1478 2
a1479 2
				   "Attempt to delete readonly key '%"SVf"' from a restricted hash",
				   (void*)keysv);
d1483 1
a1483 1
		    HvPLACEHOLDERS(hv)++;
d1491 4
a1494 3
    HvPLACEHOLDERS_set(hv, 0);
    if (HvARRAY(hv))
	Zero(HvARRAY(hv), xhv->xhv_max+1 /* HvMAX(hv)+1 */, HE*);
d1502 1
a1502 5
    if (SvOOK(hv)) {
        if(HvNAME_get(hv))
            mro_isa_changed_in(hv);
	HvEITER_set(hv, NULL);
    }
d1522 1
a1522 11
    dVAR;
    const U32 items = (U32)HvPLACEHOLDERS_get(hv);

    if (items)
	clear_placeholders(hv, items);
}

static void
S_clear_placeholders(pTHX_ HV *hv, U32 items)
{
    dVAR;
d1531 1
a1531 1
	bool first = TRUE;
d1533 4
a1536 1
	HE *entry;
d1538 1
a1538 1
	while ((entry = *oentry)) {
d1558 1
a1558 1
		first = FALSE;
d1570 4
a1573 4
    /* This is the array that we're going to restore  */
    HE **const orig_array = HvARRAY(hv);
    HEK *name;
    int attempts = 100;
d1575 2
a1576 1
    if (!orig_array)
d1579 21
a1599 9
    if (SvOOK(hv)) {
	/* If the hash is actually a symbol table with a name, look after the
	   name.  */
	struct xpvhv_aux *iter = HvAUX(hv);

	name = iter->xhv_name;
	iter->xhv_name = NULL;
    } else {
	name = NULL;
d1601 3
d1605 2
a1606 11
    /* orig_array remains unchanged throughout the loop. If after freeing all
       the entries it turns out that one of the little blighters has triggered
       an action that has caused HvARRAY to be re-allocated, then we set
       array to the new HvARRAY, and try again.  */

    while (1) {
	/* This is the one we're going to try to empty.  First time round
	   it's the original array.  (Hopefully there will only be 1 time
	   round) */
	HE ** const array = HvARRAY(hv);
	I32 i = HvMAX(hv);
d1608 1
a1608 3
	/* Because we have taken xhv_name out, the only allocated pointer
	   in the aux structure that might exist is the backreference array.
	*/
d1610 2
a1611 18
	if (SvOOK(hv)) {
	    HE *entry;
            struct mro_meta *meta;
	    struct xpvhv_aux *iter = HvAUX(hv);
	    /* If there are weak references to this HV, we need to avoid
	       freeing them up here.  In particular we need to keep the AV
	       visible as what we're deleting might well have weak references
	       back to this HV, so the for loop below may well trigger
	       the removal of backreferences from this array.  */

	    if (iter->xhv_backreferences) {
		/* So donate them to regular backref magic to keep them safe.
		   The sv_magic will increase the reference count of the AV,
		   so we need to drop it first. */
		SvREFCNT_dec(iter->xhv_backreferences);
		if (AvFILLp(iter->xhv_backreferences) == -1) {
		    /* Turns out that the array is empty. Just free it.  */
		    SvREFCNT_dec(iter->xhv_backreferences);
d1613 19
a1631 6
		} else {
		    sv_magic((SV*)hv, (SV*)iter->xhv_backreferences,
			     PERL_MAGIC_backref, NULL, 0);
		}
		iter->xhv_backreferences = NULL;
	    }
d1633 3
a1635 144
	    entry = iter->xhv_eiter; /* HvEITER(hv) */
	    if (entry && HvLAZYDEL(hv)) {	/* was deleted earlier? */
		HvLAZYDEL_off(hv);
		hv_free_ent(hv, entry);
	    }
	    iter->xhv_riter = -1; 	/* HvRITER(hv) = -1 */
	    iter->xhv_eiter = NULL;	/* HvEITER(hv) = NULL */

            if((meta = iter->xhv_mro_meta)) {
                if(meta->mro_linear_dfs) SvREFCNT_dec(meta->mro_linear_dfs);
                if(meta->mro_linear_c3)  SvREFCNT_dec(meta->mro_linear_c3);
                if(meta->mro_nextmethod) SvREFCNT_dec(meta->mro_nextmethod);
                Safefree(meta);
                iter->xhv_mro_meta = NULL;
            }

	    /* There are now no allocated pointers in the aux structure.  */

	    SvFLAGS(hv) &= ~SVf_OOK; /* Goodbye, aux structure.  */
	    /* What aux structure?  */
	}

	/* make everyone else think the array is empty, so that the destructors
	 * called for freed entries can't recusively mess with us */
	HvARRAY(hv) = NULL;
	HvFILL(hv) = 0;
	((XPVHV*) SvANY(hv))->xhv_keys = 0;


	do {
	    /* Loop down the linked list heads  */
	    HE *entry = array[i];

	    while (entry) {
		register HE * const oentry = entry;
		entry = HeNEXT(entry);
		hv_free_ent(hv, oentry);
	    }
	} while (--i >= 0);

	/* As there are no allocated pointers in the aux structure, it's now
	   safe to free the array we just cleaned up, if it's not the one we're
	   going to put back.  */
	if (array != orig_array) {
	    Safefree(array);
	}

	if (!HvARRAY(hv)) {
	    /* Good. No-one added anything this time round.  */
	    break;
	}

	if (SvOOK(hv)) {
	    /* Someone attempted to iterate or set the hash name while we had
	       the array set to 0.  We'll catch backferences on the next time
	       round the while loop.  */
	    assert(HvARRAY(hv));

	    if (HvAUX(hv)->xhv_name) {
		unshare_hek_or_pvn(HvAUX(hv)->xhv_name, 0, 0, 0);
	    }
	}

	if (--attempts == 0) {
	    Perl_die(aTHX_ "panic: hfreeentries failed to free hash - something is repeatedly re-creating entries");
	}
    }
	
    HvARRAY(hv) = orig_array;

    /* If the hash was actually a symbol table, put the name back.  */
    if (name) {
	/* We have restored the original array.  If name is non-NULL, then
	   the original array had an aux structure at the end. So this is
	   valid:  */
	SvFLAGS(hv) |= SVf_OOK;
	HvAUX(hv)->xhv_name = name;
    }
}

/*
=for apidoc hv_undef

Undefines the hash.

=cut
*/

void
Perl_hv_undef(pTHX_ HV *hv)
{
    dVAR;
    register XPVHV* xhv;
    const char *name;

    if (!hv)
	return;
    DEBUG_A(Perl_hv_assert(aTHX_ hv));
    xhv = (XPVHV*)SvANY(hv);

    if ((name = HvNAME_get(hv)) && !PL_dirty)
        mro_isa_changed_in(hv);

    hfreeentries(hv);
    if (name) {
        if (PL_stashcache)
	    (void)hv_delete(PL_stashcache, name, HvNAMELEN_get(hv), G_DISCARD);
	hv_name_set(hv, NULL, 0, 0);
    }
    SvFLAGS(hv) &= ~SVf_OOK;
    Safefree(HvARRAY(hv));
    xhv->xhv_max   = 7;	/* HvMAX(hv) = 7 (it's a normal hash) */
    HvARRAY(hv) = 0;
    HvPLACEHOLDERS_set(hv, 0);

    if (SvRMAGICAL(hv))
	mg_clear((SV*)hv);
}

static struct xpvhv_aux*
S_hv_auxinit(HV *hv) {
    struct xpvhv_aux *iter;
    char *array;

    if (!HvARRAY(hv)) {
	Newxz(array, PERL_HV_ARRAY_ALLOC_BYTES(HvMAX(hv) + 1)
	    + sizeof(struct xpvhv_aux), char);
    } else {
	array = (char *) HvARRAY(hv);
	Renew(array, PERL_HV_ARRAY_ALLOC_BYTES(HvMAX(hv) + 1)
	      + sizeof(struct xpvhv_aux), char);
    }
    HvARRAY(hv) = (HE**) array;
    /* SvOOK_on(hv) attacks the IV flags.  */
    SvFLAGS(hv) |= SVf_OOK;
    iter = HvAUX(hv);

    iter->xhv_riter = -1; 	/* HvRITER(hv) = -1 */
    iter->xhv_eiter = NULL;	/* HvEITER(hv) = NULL */
    iter->xhv_name = 0;
    iter->xhv_backreferences = 0;
    iter->xhv_mro_meta = NULL;
    return iter;
}
d1655 3
d1660 5
a1664 12

    if (SvOOK(hv)) {
	struct xpvhv_aux * const iter = HvAUX(hv);
	HE * const entry = iter->xhv_eiter; /* HvEITER(hv) */
	if (entry && HvLAZYDEL(hv)) {	/* was deleted earlier? */
	    HvLAZYDEL_off(hv);
	    hv_free_ent(hv, entry);
	}
	iter->xhv_riter = -1; 	/* HvRITER(hv) = -1 */
	iter->xhv_eiter = NULL; /* HvEITER(hv) = NULL */
    } else {
	hv_auxinit(hv);
d1666 2
a1667 1

a1670 110

I32 *
Perl_hv_riter_p(pTHX_ HV *hv) {
    struct xpvhv_aux *iter;

    if (!hv)
	Perl_croak(aTHX_ "Bad hash");

    iter = SvOOK(hv) ? HvAUX(hv) : hv_auxinit(hv);
    return &(iter->xhv_riter);
}

HE **
Perl_hv_eiter_p(pTHX_ HV *hv) {
    struct xpvhv_aux *iter;

    if (!hv)
	Perl_croak(aTHX_ "Bad hash");

    iter = SvOOK(hv) ? HvAUX(hv) : hv_auxinit(hv);
    return &(iter->xhv_eiter);
}

void
Perl_hv_riter_set(pTHX_ HV *hv, I32 riter) {
    struct xpvhv_aux *iter;

    if (!hv)
	Perl_croak(aTHX_ "Bad hash");

    if (SvOOK(hv)) {
	iter = HvAUX(hv);
    } else {
	if (riter == -1)
	    return;

	iter = hv_auxinit(hv);
    }
    iter->xhv_riter = riter;
}

void
Perl_hv_eiter_set(pTHX_ HV *hv, HE *eiter) {
    struct xpvhv_aux *iter;

    if (!hv)
	Perl_croak(aTHX_ "Bad hash");

    if (SvOOK(hv)) {
	iter = HvAUX(hv);
    } else {
	/* 0 is the default so don't go malloc()ing a new structure just to
	   hold 0.  */
	if (!eiter)
	    return;

	iter = hv_auxinit(hv);
    }
    iter->xhv_eiter = eiter;
}

void
Perl_hv_name_set(pTHX_ HV *hv, const char *name, U32 len, U32 flags)
{
    dVAR;
    struct xpvhv_aux *iter;
    U32 hash;

    PERL_UNUSED_ARG(flags);

    if (len > I32_MAX)
	Perl_croak(aTHX_ "panic: hv name too long (%"UVuf")", (UV) len);

    if (SvOOK(hv)) {
	iter = HvAUX(hv);
	if (iter->xhv_name) {
	    unshare_hek_or_pvn(iter->xhv_name, 0, 0, 0);
	}
    } else {
	if (name == 0)
	    return;

	iter = hv_auxinit(hv);
    }
    PERL_HASH(hash, name, len);
    iter->xhv_name = name ? share_hek(name, len, hash) : NULL;
}

AV **
Perl_hv_backreferences_p(pTHX_ HV *hv) {
    struct xpvhv_aux * const iter = SvOOK(hv) ? HvAUX(hv) : hv_auxinit(hv);
    PERL_UNUSED_CONTEXT;
    return &(iter->xhv_backreferences);
}

void
Perl_hv_kill_backrefs(pTHX_ HV *hv) {
    AV *av;

    if (!SvOOK(hv))
	return;

    av = HvAUX(hv)->xhv_backreferences;

    if (av) {
	HvAUX(hv)->xhv_backreferences = 0;
	Perl_sv_kill_backrefs(aTHX_ (SV*) hv, av);
    }
}

a1671 2
hv_iternext is implemented as a macro in hv.h

d1684 10
a1710 1
    dVAR;
a1714 1
    struct xpvhv_aux *iter;
a1717 1

d1719 1
d1721 9
a1729 7
    if (!SvOOK(hv)) {
	/* Too many things (well, pp_each at least) merrily assume that you can
	   call iv_iternext without calling hv_iterinit, so we'll have to deal
	   with it.  */
	hv_iterinit(hv);
    }
    iter = HvAUX(hv);
d1731 20
a1750 33
    oldentry = entry = iter->xhv_eiter; /* HvEITER(hv) */
    if (SvMAGICAL(hv) && SvRMAGICAL(hv)) {
	if ( ( mg = mg_find((SV*)hv, PERL_MAGIC_tied) ) ) {
            SV * const key = sv_newmortal();
            if (entry) {
                sv_setsv(key, HeSVKEY_force(entry));
                SvREFCNT_dec(HeSVKEY(entry));       /* get rid of previous key */
            }
            else {
                char *k;
                HEK *hek;

                /* one HE per MAGICAL hash */
                iter->xhv_eiter = entry = new_HE(); /* HvEITER(hv) = new_HE() */
                Zero(entry, 1, HE);
                Newxz(k, HEK_BASESIZE + sizeof(SV*), char);
                hek = (HEK*)k;
                HeKEY_hek(entry) = hek;
                HeKLEN(entry) = HEf_SVKEY;
            }
            magic_nextpack((SV*) hv,mg,key);
            if (SvOK(key)) {
                /* force key to stay around until next time */
                HeSVKEY_set(entry, SvREFCNT_inc_simple_NN(key));
                return entry;               /* beware, hent_val is not set */
            }
            if (HeVAL(entry))
                SvREFCNT_dec(HeVAL(entry));
            Safefree(HeKEY_hek(entry));
            del_HE(entry);
            iter->xhv_eiter = NULL; /* HvEITER(hv) = NULL */
            return NULL;
        }
d1752 1
a1752 1
#if defined(DYNAMIC_ENV_FETCH) && !defined(__riscos__)  /* set up %ENV for iteration */
d1760 1
a1760 2
	iter = HvAUX(hv);
	oldentry = entry = iter->xhv_eiter; /* HvEITER(hv) */
d1765 4
a1768 3
    /* hv_iterint now ensures this.  */
    assert (HvARRAY(hv));

d1786 2
a1787 2
	iter->xhv_riter++; /* HvRITER(hv)++ */
	if (iter->xhv_riter > (I32)xhv->xhv_max /* HvRITER(hv) > HvMAX(hv) */) {
d1789 1
a1789 1
	    iter->xhv_riter = -1; /* HvRITER(hv) = -1 */
d1792 2
a1793 1
	entry = (HvARRAY(hv))[iter->xhv_riter];
d1812 1
a1812 1
      PerlIO_printf(PerlIO_stderr(), "Awooga %p %p\n", (void*)hv, (void*)entry);*/
d1814 1
a1814 1
    iter->xhv_eiter = entry; /* HvEITER(hv) = entry */
d1832 1
a1832 1
	char * const p = SvPV(HeKEY_sv(entry), len);
d1873 1
a1873 1
	    SV* const sv = sv_newmortal();
d1896 2
a1897 3
    HE * const he = hv_iternext_flags(hv, 0);

    if (!he)
a1903 3

Now a macro in hv.h

d1911 16
a1939 1
    assert(hek);
d1948 1
a1948 1
S_unshare_hek_or_pvn(pTHX_ const HEK *hek, const char *str, I32 len, U32 hash)
a1949 1
    dVAR;
d1951 1
a1951 1
    HE *entry;
d1954 1
a1957 1
    struct shared_he *he = NULL;
a1959 17
	/* Find the shared he which is just before us in memory.  */
	he = (struct shared_he *)(((char *)hek)
				  - STRUCT_OFFSET(struct shared_he,
						  shared_he_hek));

	/* Assert that the caller passed us a genuine (or at least consistent)
	   shared hek  */
	assert (he->shared_he_he.hent_hek == hek);

	LOCK_STRTAB_MUTEX;
	if (he->shared_he_he.he_valu.hent_refcount - 1) {
	    --he->shared_he_he.he_valu.hent_refcount;
	    UNLOCK_STRTAB_MUTEX;
	    return;
	}
	UNLOCK_STRTAB_MUTEX;

d1973 1
a1973 1
    /* what follows was the moral equivalent of:
d1975 1
a1975 1
	if (--*Svp == NULL)
d1981 3
a1983 3
    first = oentry = &(HvARRAY(PL_strtab))[hash & (I32) HvMAX(PL_strtab)];
    if (he) {
	const HE *const he_he = &(he->shared_he_he);
d1985 4
a1988 2
            if (entry == he_he)
                break;
d2001 1
d2006 2
a2007 2
    if (entry) {
        if (--entry->he_valu.hent_refcount == 0) {
d2013 3
a2015 2
            Safefree(entry);
            xhv->xhv_keys--; /* HvTOTALKEYS(hv)-- */
d2020 1
a2020 1
    if (!entry && ckWARN_d(WARN_INTERNAL))
d2064 1
a2064 1
    dVAR;
d2066 2
a2068 1
    const U32 hindex = hash & (I32) HvMAX(PL_strtab);
d2073 1
a2073 1
	hv_store(PL_strtab, str, len, NULL, hash);
d2078 1
a2078 1
    register XPVHV * const xhv = (XPVHV*)SvANY(PL_strtab);
d2081 3
a2083 2
    entry = (HvARRAY(PL_strtab))[hindex];
    for (;entry; entry = HeNEXT(entry)) {
d2092 1
d2095 1
a2095 2

    if (!entry) {
d2099 8
a2106 33
	struct shared_he *new_entry;
	HEK *hek;
	char *k;
	HE **const head = &HvARRAY(PL_strtab)[hindex];
	HE *const next = *head;

	/* We don't actually store a HE from the arena and a regular HEK.
	   Instead we allocate one chunk of memory big enough for both,
	   and put the HEK straight after the HE. This way we can find the
	   HEK directly from the HE.
	*/

	Newx(k, STRUCT_OFFSET(struct shared_he,
				shared_he_hek.hek_key[0]) + len + 2, char);
	new_entry = (struct shared_he *)k;
	entry = &(new_entry->shared_he_he);
	hek = &(new_entry->shared_he_hek);

	Copy(str, HEK_KEY(hek), len, char);
	HEK_KEY(hek)[len] = 0;
	HEK_LEN(hek) = len;
	HEK_HASH(hek) = hash;
	HEK_FLAGS(hek) = (unsigned char)flags_masked;

	/* Still "point" to the HEK, so that other code need not know what
	   we're up to.  */
	HeKEY_hek(entry) = hek;
	entry->he_valu.hent_refcount = 0;
	HeNEXT(entry) = next;
	*head = entry;

	xhv->xhv_keys++; /* HvTOTALKEYS(hv)++ */
	if (!next) {			/* initial entry? */
d2113 1
a2113 1
    ++entry->he_valu.hent_refcount;
a2120 458

I32 *
Perl_hv_placeholders_p(pTHX_ HV *hv)
{
    dVAR;
    MAGIC *mg = mg_find((SV*)hv, PERL_MAGIC_rhash);

    if (!mg) {
	mg = sv_magicext((SV*)hv, 0, PERL_MAGIC_rhash, 0, 0, 0);

	if (!mg) {
	    Perl_die(aTHX_ "panic: hv_placeholders_p");
	}
    }
    return &(mg->mg_len);
}


I32
Perl_hv_placeholders_get(pTHX_ HV *hv)
{
    dVAR;
    MAGIC * const mg = mg_find((SV*)hv, PERL_MAGIC_rhash);

    return mg ? mg->mg_len : 0;
}

void
Perl_hv_placeholders_set(pTHX_ HV *hv, I32 ph)
{
    dVAR;
    MAGIC * const mg = mg_find((SV*)hv, PERL_MAGIC_rhash);

    if (mg) {
	mg->mg_len = ph;
    } else if (ph) {
	if (!sv_magicext((SV*)hv, 0, PERL_MAGIC_rhash, 0, 0, ph))
	    Perl_die(aTHX_ "panic: hv_placeholders_set");
    }
    /* else we don't need to add magic to record 0 placeholders.  */
}

STATIC SV *
S_refcounted_he_value(pTHX_ const struct refcounted_he *he)
{
    dVAR;
    SV *value;
    switch(he->refcounted_he_data[0] & HVrhek_typemask) {
    case HVrhek_undef:
	value = newSV(0);
	break;
    case HVrhek_delete:
	value = &PL_sv_placeholder;
	break;
    case HVrhek_IV:
	value = newSViv(he->refcounted_he_val.refcounted_he_u_iv);
	break;
    case HVrhek_UV:
	value = newSVuv(he->refcounted_he_val.refcounted_he_u_uv);
	break;
    case HVrhek_PV:
    case HVrhek_PV_UTF8:
	/* Create a string SV that directly points to the bytes in our
	   structure.  */
	value = newSV_type(SVt_PV);
	SvPV_set(value, (char *) he->refcounted_he_data + 1);
	SvCUR_set(value, he->refcounted_he_val.refcounted_he_u_len);
	/* This stops anything trying to free it  */
	SvLEN_set(value, 0);
	SvPOK_on(value);
	SvREADONLY_on(value);
	if ((he->refcounted_he_data[0] & HVrhek_typemask) == HVrhek_PV_UTF8)
	    SvUTF8_on(value);
	break;
    default:
	Perl_croak(aTHX_ "panic: refcounted_he_value bad flags %x",
		   he->refcounted_he_data[0]);
    }
    return value;
}

/*
=for apidoc refcounted_he_chain_2hv

Generates and returns a C<HV *> by walking up the tree starting at the passed
in C<struct refcounted_he *>.

=cut
*/
HV *
Perl_refcounted_he_chain_2hv(pTHX_ const struct refcounted_he *chain)
{
    dVAR;
    HV *hv = newHV();
    U32 placeholders = 0;
    /* We could chase the chain once to get an idea of the number of keys,
       and call ksplit.  But for now we'll make a potentially inefficient
       hash with only 8 entries in its array.  */
    const U32 max = HvMAX(hv);

    if (!HvARRAY(hv)) {
	char *array;
	Newxz(array, PERL_HV_ARRAY_ALLOC_BYTES(max + 1), char);
	HvARRAY(hv) = (HE**)array;
    }

    while (chain) {
#ifdef USE_ITHREADS
	U32 hash = chain->refcounted_he_hash;
#else
	U32 hash = HEK_HASH(chain->refcounted_he_hek);
#endif
	HE **oentry = &((HvARRAY(hv))[hash & max]);
	HE *entry = *oentry;
	SV *value;

	for (; entry; entry = HeNEXT(entry)) {
	    if (HeHASH(entry) == hash) {
		/* We might have a duplicate key here.  If so, entry is older
		   than the key we've already put in the hash, so if they are
		   the same, skip adding entry.  */
#ifdef USE_ITHREADS
		const STRLEN klen = HeKLEN(entry);
		const char *const key = HeKEY(entry);
		if (klen == chain->refcounted_he_keylen
		    && (!!HeKUTF8(entry)
			== !!(chain->refcounted_he_data[0] & HVhek_UTF8))
		    && memEQ(key, REF_HE_KEY(chain), klen))
		    goto next_please;
#else
		if (HeKEY_hek(entry) == chain->refcounted_he_hek)
		    goto next_please;
		if (HeKLEN(entry) == HEK_LEN(chain->refcounted_he_hek)
		    && HeKUTF8(entry) == HEK_UTF8(chain->refcounted_he_hek)
		    && memEQ(HeKEY(entry), HEK_KEY(chain->refcounted_he_hek),
			     HeKLEN(entry)))
		    goto next_please;
#endif
	    }
	}
	assert (!entry);
	entry = new_HE();

#ifdef USE_ITHREADS
	HeKEY_hek(entry)
	    = share_hek_flags(REF_HE_KEY(chain),
			      chain->refcounted_he_keylen,
			      chain->refcounted_he_hash,
			      (chain->refcounted_he_data[0]
			       & (HVhek_UTF8|HVhek_WASUTF8)));
#else
	HeKEY_hek(entry) = share_hek_hek(chain->refcounted_he_hek);
#endif
	value = refcounted_he_value(chain);
	if (value == &PL_sv_placeholder)
	    placeholders++;
	HeVAL(entry) = value;

	/* Link it into the chain.  */
	HeNEXT(entry) = *oentry;
	if (!HeNEXT(entry)) {
	    /* initial entry.   */
	    HvFILL(hv)++;
	}
	*oentry = entry;

	HvTOTALKEYS(hv)++;

    next_please:
	chain = chain->refcounted_he_next;
    }

    if (placeholders) {
	clear_placeholders(hv, placeholders);
	HvTOTALKEYS(hv) -= placeholders;
    }

    /* We could check in the loop to see if we encounter any keys with key
       flags, but it's probably not worth it, as this per-hash flag is only
       really meant as an optimisation for things like Storable.  */
    HvHASKFLAGS_on(hv);
    DEBUG_A(Perl_hv_assert(aTHX_ hv));

    return hv;
}

SV *
Perl_refcounted_he_fetch(pTHX_ const struct refcounted_he *chain, SV *keysv,
			 const char *key, STRLEN klen, int flags, U32 hash)
{
    dVAR;
    /* Just to be awkward, if you're using this interface the UTF-8-or-not-ness
       of your key has to exactly match that which is stored.  */
    SV *value = &PL_sv_placeholder;
    bool is_utf8;

    if (keysv) {
	if (flags & HVhek_FREEKEY)
	    Safefree(key);
	key = SvPV_const(keysv, klen);
	flags = 0;
	is_utf8 = (SvUTF8(keysv) != 0);
    } else {
	is_utf8 = ((flags & HVhek_UTF8) ? TRUE : FALSE);
    }

    if (!hash) {
	if (keysv && (SvIsCOW_shared_hash(keysv))) {
            hash = SvSHARED_HASH(keysv);
        } else {
            PERL_HASH(hash, key, klen);
        }
    }

    for (; chain; chain = chain->refcounted_he_next) {
#ifdef USE_ITHREADS
	if (hash != chain->refcounted_he_hash)
	    continue;
	if (klen != chain->refcounted_he_keylen)
	    continue;
	if (memNE(REF_HE_KEY(chain),key,klen))
	    continue;
	if (!!is_utf8 != !!(chain->refcounted_he_data[0] & HVhek_UTF8))
	    continue;
#else
	if (hash != HEK_HASH(chain->refcounted_he_hek))
	    continue;
	if (klen != (STRLEN)HEK_LEN(chain->refcounted_he_hek))
	    continue;
	if (memNE(HEK_KEY(chain->refcounted_he_hek),key,klen))
	    continue;
	if (!!is_utf8 != !!HEK_UTF8(chain->refcounted_he_hek))
	    continue;
#endif

	value = sv_2mortal(refcounted_he_value(chain));
	break;
    }

    if (flags & HVhek_FREEKEY)
	Safefree(key);

    return value;
}

/*
=for apidoc refcounted_he_new

Creates a new C<struct refcounted_he>. As S<key> is copied, and value is
stored in a compact form, all references remain the property of the caller.
The C<struct refcounted_he> is returned with a reference count of 1.

=cut
*/

struct refcounted_he *
Perl_refcounted_he_new(pTHX_ struct refcounted_he *const parent,
		       SV *const key, SV *const value) {
    dVAR;
    struct refcounted_he *he;
    STRLEN key_len;
    const char *key_p = SvPV_const(key, key_len);
    STRLEN value_len = 0;
    const char *value_p = NULL;
    char value_type;
    char flags;
    STRLEN key_offset;
    U32 hash;
    bool is_utf8 = SvUTF8(key) ? TRUE : FALSE;

    if (SvPOK(value)) {
	value_type = HVrhek_PV;
    } else if (SvIOK(value)) {
	value_type = HVrhek_IV;
    } else if (value == &PL_sv_placeholder) {
	value_type = HVrhek_delete;
    } else if (!SvOK(value)) {
	value_type = HVrhek_undef;
    } else {
	value_type = HVrhek_PV;
    }

    if (value_type == HVrhek_PV) {
	value_p = SvPV_const(value, value_len);
	key_offset = value_len + 2;
    } else {
	value_len = 0;
	key_offset = 1;
    }

#ifdef USE_ITHREADS
    he = (struct refcounted_he*)
	PerlMemShared_malloc(sizeof(struct refcounted_he) - 1
			     + key_len
			     + key_offset);
#else
    he = (struct refcounted_he*)
	PerlMemShared_malloc(sizeof(struct refcounted_he) - 1
			     + key_offset);
#endif


    he->refcounted_he_next = parent;

    if (value_type == HVrhek_PV) {
	Copy(value_p, he->refcounted_he_data + 1, value_len + 1, char);
	he->refcounted_he_val.refcounted_he_u_len = value_len;
	/* Do it this way so that the SvUTF8() test is after the SvPV, in case
	   the value is overloaded, and doesn't yet have the UTF-8flag set.  */
	if (SvUTF8(value))
	    value_type = HVrhek_PV_UTF8;
    } else if (value_type == HVrhek_IV) {
	if (SvUOK(value)) {
	    he->refcounted_he_val.refcounted_he_u_uv = SvUVX(value);
	    value_type = HVrhek_UV;
	} else {
	    he->refcounted_he_val.refcounted_he_u_iv = SvIVX(value);
	}
    }
    flags = value_type;

    if (is_utf8) {
	/* Hash keys are always stored normalised to (yes) ISO-8859-1.
	   As we're going to be building hash keys from this value in future,
	   normalise it now.  */
	key_p = (char*)bytes_from_utf8((const U8*)key_p, &key_len, &is_utf8);
	flags |= is_utf8 ? HVhek_UTF8 : HVhek_WASUTF8;
    }
    PERL_HASH(hash, key_p, key_len);

#ifdef USE_ITHREADS
    he->refcounted_he_hash = hash;
    he->refcounted_he_keylen = key_len;
    Copy(key_p, he->refcounted_he_data + key_offset, key_len, char);
#else
    he->refcounted_he_hek = share_hek_flags(key_p, key_len, hash, flags);
#endif

    if (flags & HVhek_WASUTF8) {
	/* If it was downgraded from UTF-8, then the pointer returned from
	   bytes_from_utf8 is an allocated pointer that we must free.  */
	Safefree(key_p);
    }

    he->refcounted_he_data[0] = flags;
    he->refcounted_he_refcnt = 1;

    return he;
}

/*
=for apidoc refcounted_he_free

Decrements the reference count of the passed in C<struct refcounted_he *>
by one. If the reference count reaches zero the structure's memory is freed,
and C<refcounted_he_free> iterates onto the parent node.

=cut
*/

void
Perl_refcounted_he_free(pTHX_ struct refcounted_he *he) {
    dVAR;
    PERL_UNUSED_CONTEXT;

    while (he) {
	struct refcounted_he *copy;
	U32 new_count;

	HINTS_REFCNT_LOCK;
	new_count = --he->refcounted_he_refcnt;
	HINTS_REFCNT_UNLOCK;
	
	if (new_count) {
	    return;
	}

#ifndef USE_ITHREADS
	unshare_hek_or_pvn (he->refcounted_he_hek, 0, 0, 0);
#endif
	copy = he;
	he = he->refcounted_he_next;
	PerlMemShared_free(copy);
    }
}

/*
=for apidoc hv_assert

Check that a hash is in an internally consistent state.

=cut
*/

#ifdef DEBUGGING

void
Perl_hv_assert(pTHX_ HV *hv)
{
    dVAR;
    HE* entry;
    int withflags = 0;
    int placeholders = 0;
    int real = 0;
    int bad = 0;
    const I32 riter = HvRITER_get(hv);
    HE *eiter = HvEITER_get(hv);

    (void)hv_iterinit(hv);

    while ((entry = hv_iternext_flags(hv, HV_ITERNEXT_WANTPLACEHOLDERS))) {
	/* sanity check the values */
	if (HeVAL(entry) == &PL_sv_placeholder)
	    placeholders++;
	else
	    real++;
	/* sanity check the keys */
	if (HeSVKEY(entry)) {
	    NOOP;   /* Don't know what to check on SV keys.  */
	} else if (HeKUTF8(entry)) {
	    withflags++;
	    if (HeKWASUTF8(entry)) {
		PerlIO_printf(Perl_debug_log,
			    "hash key has both WASUTF8 and UTF8: '%.*s'\n",
			    (int) HeKLEN(entry),  HeKEY(entry));
		bad = 1;
	    }
	} else if (HeKWASUTF8(entry))
	    withflags++;
    }
    if (!SvTIED_mg((SV*)hv, PERL_MAGIC_tied)) {
	static const char bad_count[] = "Count %d %s(s), but hash reports %d\n";
	const int nhashkeys = HvUSEDKEYS(hv);
	const int nhashplaceholders = HvPLACEHOLDERS_get(hv);

	if (nhashkeys != real) {
	    PerlIO_printf(Perl_debug_log, bad_count, real, "keys", nhashkeys );
	    bad = 1;
	}
	if (nhashplaceholders != placeholders) {
	    PerlIO_printf(Perl_debug_log, bad_count, placeholders, "placeholder", nhashplaceholders );
	    bad = 1;
	}
    }
    if (withflags && ! HvHASKFLAGS(hv)) {
	PerlIO_printf(Perl_debug_log,
		    "Hash has HASKFLAGS off but I count %d key(s) with flags\n",
		    withflags);
	bad = 1;
    }
    if (bad) {
	sv_dump((SV *)hv);
    }
    HvRITER_set(hv, riter);		/* Restore hash iterator state */
    HvEITER_set(hv, eiter);
}

#endif
@


1.1.1.12
log
@import perl 5.10.1
@
text
@d3 2
a4 2
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
 *    2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 by Larry Wall and others
d12 1
a12 5
 *      I sit beside the fire and think
 *          of all that I have seen.
 *                         --Bilbo
 *
 *     [p.278 of _The Lord of the Rings_, II/iii: "The Ring Goes South"]
d43 2
a44 5
    /* We could generate this at compile time via (another) auxiliary C
       program?  */
    const size_t arena_size = Perl_malloc_good_size(PERL_ARENA_SIZE);
    HE* he = (HE*) Perl_get_arena(aTHX_ arena_size, HE_SVSLOT);
    HE * const heend = &he[arena_size / sizeof(HE) - 1];
a93 2
    PERL_ARGS_ASSERT_SAVE_HEK_FLAGS;

d128 1
a128 1
    HEK *shared;
a129 1
    PERL_ARGS_ASSERT_HEK_DUP;
a131 4
    if (!source)
	return NULL;

    shared = (HEK*)ptr_table_fetch(PL_ptr_table, source);
a149 2
    PERL_ARGS_ASSERT_HE_DUP;

d164 1
a164 1
	Newx(k, HEK_BASESIZE + sizeof(const SV *), char);
a198 3

    PERL_ARGS_ASSERT_HV_NOTALLOWED;

a314 2
    PERL_ARGS_ASSERT_HV_COMMON_KEY_LEN;

d347 1
a347 1
	if ((mg = mg_find((const SV *)hv, PERL_MAGIC_uvar))) {
d353 3
a355 3
		    keysv = newSVpvn_flags(key, klen, SVs_TEMP |
					   ((flags & HVhek_UTF8)
					    ? SVf_UTF8 : 0));
d360 1
a360 1
		magic_getuvar(MUTABLE_SV(hv), mg);
d374 1
a375 5
	if (SvIsCOW_shared_hash(keysv)) {
	    flags = HVhek_KEYCANONICAL | (is_utf8 ? HVhek_UTF8 : 0);
	} else {
	    flags = 0;
	}
d389 1
a389 2
	    if (mg_find((const SV *)hv, PERL_MAGIC_tied)
		|| SvGMAGICAL((const SV *)hv))
d394 5
a398 2
		    keysv = newSVpvn_utf8(key, klen, is_utf8);
  		} else {
d402 1
a402 1
                mg_copy(MUTABLE_SV(hv), sv, (char *)keysv, HEf_SVKEY);
d411 1
a411 1
		    Newx(k, HEK_BASESIZE + sizeof(const SV *), char);
d420 1
a420 1
		LvTARG(sv) = MUTABLE_SV(entry);
d432 1
a432 1
	    else if (mg_find((const SV *)hv, PERL_MAGIC_env)) {
d467 1
a467 2
	    if (mg_find((const SV *)hv, PERL_MAGIC_tied)
		|| SvGMAGICAL((const SV *)hv)) {
d475 2
a476 1
			keysv = newSVpvn_utf8(key, klen, TRUE);
d480 1
a480 1
		    mg_copy(MUTABLE_SV(hv), sv, (char *)sv_2mortal(keysv), HEf_SVKEY);
d482 1
a482 1
		    mg_copy(MUTABLE_SV(hv), sv, key, klen);
d493 1
a493 1
	    else if (mg_find((const SV *)hv, PERL_MAGIC_env)) {
d518 2
a519 1
			keysv = newSVpvn_utf8(key, klen, TRUE);
d524 1
a524 1
		    mg_copy(MUTABLE_SV(hv), val, (char*)keysv, HEf_SVKEY);
d526 1
a526 1
		    mg_copy(MUTABLE_SV(hv), val, key, klen);
d536 1
a536 1
		else if (mg_find((const SV *)hv, PERL_MAGIC_env)) {
d559 1
a559 2
		 || (SvRMAGICAL((const SV *)hv)
		     && mg_find((const SV *)hv, PERL_MAGIC_env))
d583 1
a583 1
    if (is_utf8 & !(flags & HVhek_KEYCANONICAL)) {
a593 5
	    /* If the caller calculated a hash, it was on the sequence of
	       octets that are the UTF-8 form. We've now changed the sequence
	       of octets stored to that of the equivalent byte representation,
	       so the hash we need is different.  */
	    hash = 0;
d702 1
a702 2
	&& SvRMAGICAL((const SV *)hv)
	&& mg_find((const SV *)hv, PERL_MAGIC_env)) {
a821 3

    PERL_ARGS_ASSERT_HV_MAGIC_CHECK;

a848 2
    PERL_ARGS_ASSERT_HV_SCALAR;

d850 1
a850 1
	MAGIC * const mg = mg_find((const SV *)hv, PERL_MAGIC_tied);
d856 1
a856 1
    if (HvFILL((const HV *)hv)) 
d920 1
a920 1
		else if (mg_find((const SV *)hv, PERL_MAGIC_env)) {
d922 1
a922 1
		    keysv = newSVpvn_flags(key, klen, SVs_TEMP);
d955 1
a955 1
        HvHASKFLAGS_on(MUTABLE_SV(hv));
a1061 2
    PERL_ARGS_ASSERT_HSPLIT;

d1082 1
a1082 1
	Move(&a[oldsize * sizeof(HE*)], &a[newsize * sizeof(HE*)], 1, struct xpvhv_aux);
a1230 2
    PERL_ARGS_ASSERT_HV_KSPLIT;

d1308 24
d1342 1
a1342 1
    if (!SvMAGICAL((const SV *)ohv)) {
a1431 1
	    SV *heksv = newSVhek(HeKEY_hek(entry));
d1433 1
a1433 2
		     (char *)heksv, HEf_SVKEY);
	    SvREFCNT_dec(heksv);
a1449 2
    PERL_ARGS_ASSERT_HV_FREE_ENT;

a1470 3

    PERL_ARGS_ASSERT_HV_DELAYFREE_ENT;

d1530 1
a1530 1
	mg_clear(MUTABLE_SV(hv));
a1561 2
    PERL_ARGS_ASSERT_HV_CLEAR_PLACEHOLDERS;

a1571 2
    PERL_ARGS_ASSERT_CLEAR_PLACEHOLDERS;

a1618 2
    PERL_ARGS_ASSERT_HFREEENTRIES;

d1669 1
a1669 2
		    sv_magic(MUTABLE_SV(hv),
			     MUTABLE_SV(iter->xhv_backreferences),
d1684 2
a1685 11
		if (meta->mro_linear_dfs) {
		    SvREFCNT_dec(MUTABLE_SV(meta->mro_linear_dfs));
		    meta->mro_linear_dfs = NULL;
		    /* This is just acting as a shortcut pointer.  */
		    meta->mro_linear_c3 = NULL;
		} else if (meta->mro_linear_c3) {
		    /* Only the current MRO is stored, so this owns the data.
		     */
		    SvREFCNT_dec(MUTABLE_SV(meta->mro_linear_c3));
		    meta->mro_linear_c3 = NULL;
		}
a1686 1
                SvREFCNT_dec(meta->isa);
d1791 1
a1791 1
	mg_clear(MUTABLE_SV(hv));
a1798 2
    PERL_ARGS_ASSERT_HV_AUXINIT;

a1837 4
    PERL_ARGS_ASSERT_HV_ITERINIT;

    /* FIXME: Are we not NULL, or do we croak? Place bets now! */

a1861 2
    PERL_ARGS_ASSERT_HV_RITER_P;

a1872 2
    PERL_ARGS_ASSERT_HV_EITER_P;

a1883 2
    PERL_ARGS_ASSERT_HV_RITER_SET;

a1901 2
    PERL_ARGS_ASSERT_HV_EITER_SET;

a1924 1
    PERL_ARGS_ASSERT_HV_NAME_SET;
a1947 2

    PERL_ARGS_ASSERT_HV_BACKREFERENCES_P;
a1948 1

a1955 2
    PERL_ARGS_ASSERT_HV_KILL_BACKREFS;

d1963 1
a1963 2
	Perl_sv_kill_backrefs(aTHX_ MUTABLE_SV(hv), av);
	SvREFCNT_dec(av);
a2005 2
    PERL_ARGS_ASSERT_HV_ITERNEXT_FLAGS;

d2021 1
a2021 1
	if ( ( mg = mg_find((const SV *)hv, PERL_MAGIC_tied) ) ) {
d2034 1
a2034 1
                Newxz(k, HEK_BASESIZE + sizeof(const SV *), char);
d2039 1
a2039 1
            magic_nextpack(MUTABLE_SV(hv),mg,key);
d2054 1
a2054 2
    if (!entry && SvRMAGICAL((const SV *)hv)
	&& mg_find((const SV *)hv, PERL_MAGIC_env)) {
a2129 2
    PERL_ARGS_ASSERT_HV_ITERKEY;

a2155 2
    PERL_ARGS_ASSERT_HV_ITERKEYSV;

a2170 2
    PERL_ARGS_ASSERT_HV_ITERVAL;

d2172 1
a2172 1
	if (mg_find((const SV *)hv, PERL_MAGIC_tied)) {
d2175 1
a2175 1
		mg_copy(MUTABLE_SV(hv), sv, (char*)HeKEY_sv(entry), HEf_SVKEY);
d2177 1
a2177 1
		mg_copy(MUTABLE_SV(hv), sv, HeKEY(entry), HeKLEN(entry));
a2197 2
    PERL_ARGS_ASSERT_HV_ITERNEXTSV;

a2343 2
    PERL_ARGS_ASSERT_SHARE_HEK;

a2370 3
    register XPVHV * const xhv = (XPVHV*)SvANY(PL_strtab);

    PERL_ARGS_ASSERT_SHARE_HEK_FLAGS;
d2380 1
a2380 1

d2452 1
a2452 3
    MAGIC *mg = mg_find((const SV *)hv, PERL_MAGIC_rhash);

    PERL_ARGS_ASSERT_HV_PLACEHOLDERS_P;
d2455 1
a2455 1
	mg = sv_magicext(MUTABLE_SV(hv), 0, PERL_MAGIC_rhash, 0, 0, 0);
a2470 2
    PERL_ARGS_ASSERT_HV_PLACEHOLDERS_GET;

d2478 1
a2478 3
    MAGIC * const mg = mg_find((const SV *)hv, PERL_MAGIC_rhash);

    PERL_ARGS_ASSERT_HV_PLACEHOLDERS_SET;
d2483 1
a2483 1
	if (!sv_magicext(MUTABLE_SV(hv), 0, PERL_MAGIC_rhash, 0, 0, ph))
a2493 3

    PERL_ARGS_ASSERT_REFCOUNTED_HE_VALUE;

d2641 1
d2643 9
a2651 3
    if (chain) {
	/* No point in doing any of this if there's nothing to find.  */
	bool is_utf8;
d2653 7
a2659 17
	if (keysv) {
	    if (flags & HVhek_FREEKEY)
		Safefree(key);
	    key = SvPV_const(keysv, klen);
	    flags = 0;
	    is_utf8 = (SvUTF8(keysv) != 0);
	} else {
	    is_utf8 = ((flags & HVhek_UTF8) ? TRUE : FALSE);
	}

	if (!hash) {
	    if (keysv && (SvIsCOW_shared_hash(keysv))) {
		hash = SvSHARED_HASH(keysv);
	    } else {
		PERL_HASH(hash, key, klen);
	    }
	}
d2661 1
a2661 1
	for (; chain; chain = chain->refcounted_he_next) {
d2663 8
a2670 8
	    if (hash != chain->refcounted_he_hash)
		continue;
	    if (klen != chain->refcounted_he_keylen)
		continue;
	    if (memNE(REF_HE_KEY(chain),key,klen))
		continue;
	    if (!!is_utf8 != !!(chain->refcounted_he_data[0] & HVhek_UTF8))
		continue;
d2672 8
a2679 8
	    if (hash != HEK_HASH(chain->refcounted_he_hek))
		continue;
	    if (klen != (STRLEN)HEK_LEN(chain->refcounted_he_hek))
		continue;
	    if (memNE(HEK_KEY(chain->refcounted_he_hek),key,klen))
		continue;
	    if (!!is_utf8 != !!HEK_UTF8(chain->refcounted_he_hek))
		continue;
d2682 2
a2683 3
	    value = sv_2mortal(refcounted_he_value(chain));
	    break;
	}
a2854 2
    PERL_ARGS_ASSERT_HV_ASSERT;

d2877 1
a2877 1
    if (!SvTIED_mg((const SV *)hv, PERL_MAGIC_tied)) {
d2898 1
a2898 1
	sv_dump(MUTABLE_SV(hv));
@


1.1.1.13
log
@Perl 5.12.2 from CPAN
@
text
@a1348 1
    dVAR;
a1381 1
		SV *const val    = HeVAL(oent);
d1383 1
a1383 1
		HeVAL(ent) = SvIMMORTAL(val) ? val : newSVsv(val);
a1413 1
	    SV *const val = HeVAL(entry);
d1415 2
a1416 2
			         SvIMMORTAL(val) ? val : newSVsv(val),
				 HeHASH(entry), HeKFLAGS(entry));
d1471 2
a1472 2
    if (HvNAME(hv) && anonymise_cv(HvNAME_HEK(hv), val) && GvCVu(val))
	mro_method_changed_in(hv);
a1484 28
static I32
S_anonymise_cv(pTHX_ HEK *stash, SV *val)
{
    CV *cv;

    PERL_ARGS_ASSERT_ANONYMISE_CV;

    if (val && isGV(val) && isGV_with_GP(val) && (cv = GvCV(val))) {
	if ((SV *)CvGV(cv) == val) {
	    GV *anongv;

	    if (stash) {
		SV *gvname = newSVhek(stash);
		sv_catpvs(gvname, "::__ANON__");
		anongv = gv_fetchsv(gvname, GV_ADDMULTI, SVt_PVCV);
		SvREFCNT_dec(gvname);
	    } else {
		anongv = gv_fetchpvs("__ANON__::__ANON__", GV_ADDMULTI,
				     SVt_PVCV);
	    }
	    CvGV(cv) = anongv;
	    CvANON_on(cv);
	    return 1;
	}
    }
    return 0;
}

a1648 16
    if (HvNAME(hv) && orig_array != NULL) {
	/* symbol table: make all the contained subs ANON */
	STRLEN i;
	XPVHV *xhv = (XPVHV*)SvANY(hv);

	for (i = 0; i <= xhv->xhv_max; i++) {
	    HE *entry = (HvARRAY(hv))[i];
	    for (; entry; entry = HeNEXT(entry)) {
		SV *val = HeVAL(entry);
		/* we need to put the subs in the __ANON__ symtable, as
		 * this one is being cleared. */
		anonymise_cv(NULL, val);
	    }
	}
    }

d1712 3
a1714 3
		if (meta->mro_linear_all) {
		    SvREFCNT_dec(MUTABLE_SV(meta->mro_linear_all));
		    meta->mro_linear_all = NULL;
d1716 2
a1717 2
		    meta->mro_linear_current = NULL;
		} else if (meta->mro_linear_current) {
d1720 2
a1721 2
		    SvREFCNT_dec(meta->mro_linear_current);
		    meta->mro_linear_current = NULL;
d2106 2
a2107 1
            SvREFCNT_dec(HeVAL(entry));
d2146 2
d2149 7
a2155 13
    /* Skip the entire loop if the hash is empty.   */
    if ((flags & HV_ITERNEXT_WANTPLACEHOLDERS)
	? HvTOTALKEYS(hv) : HvUSEDKEYS(hv)) {
	while (!entry) {
	    /* OK. Come to the end of the current list.  Grab the next one.  */

	    iter->xhv_riter++; /* HvRITER(hv)++ */
	    if (iter->xhv_riter > (I32)xhv->xhv_max /* HvRITER(hv) > HvMAX(hv) */) {
		/* There is no next one.  End of the hash.  */
		iter->xhv_riter = -1; /* HvRITER(hv) = -1 */
		break;
	    }
	    entry = (HvARRAY(hv))[iter->xhv_riter];
d2157 5
a2161 9
	    if (!(flags & HV_ITERNEXT_WANTPLACEHOLDERS)) {
		/* If we have an entry, but it's a placeholder, don't count it.
		   Try the next.  */
		while (entry && HeVAL(entry) == &PL_sv_placeholder)
		    entry = HeNEXT(entry);
	    }
	    /* Will loop again if this linked list starts NULL
	       (for HV_ITERNEXT_WANTPLACEHOLDERS)
	       or if we run through it and find only placeholders.  */
d2163 3
d2329 1
d2332 1
d2335 1
d2357 1
d2392 7
a2398 6
    if (!entry)
	Perl_ck_warner_d(aTHX_ packWARN(WARN_INTERNAL),
			 "Attempt to free non-existent shared string '%s'%s"
			 pTHX__FORMAT,
			 hek ? HEK_KEY(hek) : str,
			 ((k_flags & HVhek_UTF8) ? " (utf8)" : "") pTHX__VALUE);
d2457 1
d2515 1
d2543 1
a2543 1
Perl_hv_placeholders_get(pTHX_ const HV *hv)
d2546 1
a2546 1
    MAGIC * const mg = mg_find((const SV *)hv, PERL_MAGIC_rhash);
d2794 1
d2801 2
d2808 1
a2808 1
	value_type = SvUOK((const SV *)value) ? HVrhek_UV : HVrhek_IV;
a2817 2
	/* Do it this way so that the SvUTF8() test is after the SvPV, in case
	   the value is overloaded, and doesn't yet have the UTF-8flag set.  */
d2819 4
a2822 2
	if (SvUTF8(value))
	    value_type = HVrhek_PV_UTF8;
a2823 29
    flags = value_type;

    if (is_utf8) {
	/* Hash keys are always stored normalised to (yes) ISO-8859-1.
	   As we're going to be building hash keys from this value in future,
	   normalise it now.  */
	key_p = (char*)bytes_from_utf8((const U8*)key_p, &key_len, &is_utf8);
	flags |= is_utf8 ? HVhek_UTF8 : HVhek_WASUTF8;
    }

    return refcounted_he_new_common(parent, key_p, key_len, flags, value_type,
				    ((value_type == HVrhek_PV
				      || value_type == HVrhek_PV_UTF8) ?
				     (void *)value_p : (void *)value),
				    value_len);
}

static struct refcounted_he *
S_refcounted_he_new_common(pTHX_ struct refcounted_he *const parent,
			   const char *const key_p, const STRLEN key_len,
			   const char flags, char value_type,
			   const void *value, const STRLEN value_len) {
    dVAR;
    struct refcounted_he *he;
    U32 hash;
    const bool is_pv = value_type == HVrhek_PV || value_type == HVrhek_PV_UTF8;
    STRLEN key_offset = is_pv ? value_len + 2 : 1;

    PERL_ARGS_ASSERT_REFCOUNTED_HE_NEW_COMMON;
d2836 1
d2839 2
a2840 2
    if (is_pv) {
	Copy((char *)value, he->refcounted_he_data + 1, value_len + 1, char);
d2842 4
d2847 6
a2852 3
	he->refcounted_he_val.refcounted_he_u_iv = SvIVX((const SV *)value);
    } else if (value_type == HVrhek_UV) {
	he->refcounted_he_val.refcounted_he_u_uv = SvUVX((const SV *)value);
d2854 1
d2856 7
a2918 45
}

/* pp_entereval is aware that labels are stored with a key ':' at the top of
   the linked list.  */
const char *
Perl_fetch_cop_label(pTHX_ struct refcounted_he *const chain, STRLEN *len,
		     U32 *flags) {
    if (!chain)
	return NULL;
#ifdef USE_ITHREADS
    if (chain->refcounted_he_keylen != 1)
	return NULL;
    if (*REF_HE_KEY(chain) != ':')
	return NULL;
#else
    if ((STRLEN)HEK_LEN(chain->refcounted_he_hek) != 1)
	return NULL;
    if (*HEK_KEY(chain->refcounted_he_hek) != ':')
	return NULL;
#endif
    /* Stop anyone trying to really mess us up by adding their own value for
       ':' into %^H  */
    if ((chain->refcounted_he_data[0] & HVrhek_typemask) != HVrhek_PV
	&& (chain->refcounted_he_data[0] & HVrhek_typemask) != HVrhek_PV_UTF8)
	return NULL;

    if (len)
	*len = chain->refcounted_he_val.refcounted_he_u_len;
    if (flags) {
	*flags = ((chain->refcounted_he_data[0] & HVrhek_typemask)
		  == HVrhek_PV_UTF8) ? SVf_UTF8 : 0;
    }
    return chain->refcounted_he_data + 1;
}

/* As newSTATEOP currently gets passed plain char* labels, we will only provide
   that interface. Once it works out how to pass in length and UTF-8 ness, this
   function will need superseding.  */
struct refcounted_he *
Perl_store_cop_label(pTHX_ struct refcounted_he *const chain, const char *label)
{
    PERL_ARGS_ASSERT_STORE_COP_LABEL;

    return refcounted_he_new_common(chain, ":", 1, HVrhek_PV, HVrhek_PV,
				    label, strlen(label));
@


1.1.1.14
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d22 2
a23 2
A HV structure represents a Perl hash.  It consists mainly of an array
of pointers, each of which points to a linked list of HE structures.  The
d25 1
a25 1
represents all the hash entries with the same hash value.  Each HE contains
d38 1
a38 2
#define HV_MAX_LENGTH_BEFORE_REHASH 14
#define SHOULD_DO_HSPLIT(xhv) ((xhv)->xhv_keys > (xhv)->xhv_max) /* HvTOTALKEYS(hv) > HvMAX(hv) */
d43 18
d76 1
a76 1
	Perl_more_bodies(aTHX_ HE_SVSLOT, sizeof(HE), PERL_ARENA_SIZE);
d182 1
a182 1
	HeKEY_sv(ret) = sv_dup_inc(HeKEY_sv(e), param);
d205 1
a205 1
    HeVAL(ret) = sv_dup_inc(HeVAL(e), param);
d238 3
a240 7
Stores an SV in a hash.  The hash key is specified as C<key> and the
absolute value of C<klen> is the length of the key.  If C<klen> is
negative the key is assumed to be in UTF-8-encoded Unicode.  The
C<hash> parameter is the precomputed hash value; if it is zero then
Perl will compute it.

The return value will be
d286 1
a286 2
absolute value of C<klen> is the length of the key.  If C<klen> is
negative the key is assumed to be in UTF-8-encoded Unicode.
d290 4
a293 5
Returns the SV which corresponds to the specified key in the hash.
The absolute value of C<klen> is the length of the key.  If C<klen> is
negative the key is assumed to be in UTF-8-encoded Unicode.  If
C<lval> is set then the fetch will be part of a store.  Check that the
return value is non-null before dereferencing it to an C<SV*>.
d300 1
a300 2
Returns a boolean indicating whether
the specified hash key exists.  C<hash>
d316 1
a316 1
accessing it.  The return value when C<hv> is a tied hash is a pointer to a
d361 1
a361 1
    if (SvTYPE(hv) == (svtype)SVTYPEMASK)
d625 7
a631 11
    if (HvREHASH(hv) || (!hash && !(keysv && (SvIsCOW_shared_hash(keysv)))))
	PERL_HASH_INTERNAL_(hash, key, klen, HvREHASH(hv));
    else if (!hash)
	hash = SvSHARED_HASH(keysv);

    /* We don't have a pointer to the hv, so we have to replicate the
       flag into every HEK, so that hv_iterkeysv can see it.
       And yes, you do need this even though you are not "storing" because
       you can flip the flags below if doing an lval lookup.  (And that
       was put in to give the semantics Andreas was expecting.)  */
    if (HvREHASH(hv))
d633 7
d703 1
a703 1
		    /* LVAL fetch which actually needs a store.  */
d756 1
a756 1
	val = action & HV_FETCH_EMPTY_HE ? NULL : newSV(0);
d815 24
a838 3
    xhv->xhv_keys++; /* HvTOTALKEYS(hv)++ */
    if ( SHOULD_DO_HSPLIT(xhv) ) {
        hsplit(hv);
d890 1
a890 1
    if (HvTOTALKEYS((const HV *)hv)) 
d902 4
a905 6
Deletes a key/value pair in the hash.  The value's SV is removed from
the hash, made mortal, and returned to the caller.  The absolute
value of C<klen> is the length of the key.  If C<klen> is negative the
key is assumed to be in UTF-8-encoded Unicode.  The C<flags> value
will normally be zero; if set to G_DISCARD then NULL will be returned.
NULL will also be returned if the key is not found.
d909 4
a912 5
Deletes a key/value pair in the hash.  The value SV is removed from the hash,
made mortal, and returned to the caller.  The C<flags> value will normally be
zero; if set to G_DISCARD then NULL will be returned.  NULL will also be
returned if the key is not found.  C<hash> can be a valid precomputed hash
value, or 0 to ask for it to be computed.
d925 1
d992 9
a1000 4
    if (HvREHASH(hv) || (!hash && !(keysv && (SvIsCOW_shared_hash(keysv)))))
	PERL_HASH_INTERNAL_(hash, key, klen, HvREHASH(hv));
    else if (!hash)
	hash = SvSHARED_HASH(keysv);
d1004 1
a1004 1
    oentry = &(HvARRAY(hv))[hash & (I32) HvMAX(hv)];
a1007 4
	U8 mro_changes = 0; /* 1 = isa; 2 = package moved */
	GV *gv = NULL;
	HV *stash = NULL;

d1029 1
a1029 2
	if (SvREADONLY(hv) && HeVAL(entry) && SvREADONLY(HeVAL(entry))
	 && !SvIsCOW(HeVAL(entry))) {
d1037 5
a1041 36
	/* If this is a stash and the key ends with ::, then someone is 
	 * deleting a package.
	 */
	if (HeVAL(entry) && HvENAME_get(hv)) {
		gv = (GV *)HeVAL(entry);
		if (keysv) key = SvPV(keysv, klen);
		if ((
		     (klen > 1 && key[klen-2] == ':' && key[klen-1] == ':')
		      ||
		     (klen == 1 && key[0] == ':')
		    )
		 && (klen != 6 || hv!=PL_defstash || memNE(key,"main::",6))
		 && SvTYPE(gv) == SVt_PVGV && (stash = GvHV((GV *)gv))
		 && HvENAME_get(stash)) {
			/* A previous version of this code checked that the
			 * GV was still in the symbol table by fetching the
			 * GV with its name. That is not necessary (and
			 * sometimes incorrect), as HvENAME cannot be set
			 * on hv if it is not in the symtab. */
			mro_changes = 2;
			/* Hang on to it for a bit. */
			SvREFCNT_inc_simple_void_NN(
			 sv_2mortal((SV *)gv)
			);
		}
		else if (klen == 3 && strnEQ(key, "ISA", 3))
		    mro_changes = 1;
	}

	sv = d_flags & G_DISCARD ? HeVAL(entry) : sv_2mortal(HeVAL(entry));
	HeVAL(entry) = &PL_sv_placeholder;
	if (sv) {
	    /* deletion of method from stash */
	    if (isGV(sv) && isGV_with_GP(sv) && GvCVu(sv)
	     && HvENAME_get(hv))
		mro_method_changed_in(hv);
d1050 3
a1052 1
	if (SvREADONLY(hv))
d1056 1
a1056 1
	else {
d1058 3
d1063 1
a1063 4
	    else {
		if (SvOOK(hv) && HvLAZYDEL(hv) &&
		    entry == HeNEXT(HvAUX(hv)->xhv_eiter))
		    HeNEXT(HvAUX(hv)->xhv_eiter) = HeNEXT(entry);
a1064 1
	    }
a1068 10

	if (d_flags & G_DISCARD) {
	    SvREFCNT_dec(sv);
	    sv = NULL;
	}

	if (mro_changes == 1) mro_isa_changed_in(hv);
	else if (mro_changes == 2)
	    mro_package_moved(NULL, stash, gv, 1);

d1092 1
d1131 7
a1137 1
    Safefree(HvARRAY(hv));
d1149 1
a1149 2
	HE **oentry = aep;
	HE *entry = *aep;
d1152 1
a1152 1
	if (!entry)				/* non-existent */
d1155 1
a1155 1
	do {
d1159 2
d1163 1
d1169 3
a1171 2
	    entry = *oentry;
	} while (entry);
d1183 1
a1183 1
    if (longest_chain <= HV_MAX_LENGTH_BEFORE_REHASH /* split worked?  */
d1207 1
d1242 2
d1264 2
d1304 7
a1310 1
	Safefree(HvARRAY(hv));
d1320 1
a1320 1
    if (!xhv->xhv_keys /* !HvTOTALKEYS(hv) */)	/* skip rest if no entries */
d1325 1
a1325 4
	HE **oentry = aep;
	HE *entry = *aep;

	if (!entry)				/* non-existent */
d1327 1
a1327 1
	do {
d1333 2
a1334 1
		HeNEXT(entry) = aep[j];
d1336 1
d1340 3
a1342 2
	    entry = *oentry;
	} while (entry);
d1351 1
a1351 1
    STRLEN hv_max;
d1353 1
a1353 1
    if (!ohv || (!HvTOTALKEYS(ohv) && !SvMAGICAL((const SV *)ohv)))
d1399 1
a1407 1
	STRLEN hv_fill = HvFILL(ohv);
d1416 3
a1418 7
	    SV *val = hv_iterval(ohv,entry);
	    SV * const keysv = HeSVKEY(entry);
	    val = SvIMMORTAL(val) ? val : newSVsv(val);
	    if (keysv)
		(void)hv_store_ent(hv, keysv, val, 0);
	    else
	        (void)hv_store_flags(hv, HeKEY(entry), HeKLEN(entry), val,
d1428 2
a1429 12
/*
=for apidoc Am|HV *|hv_copy_hints_hv|HV *ohv

A specialised version of L</newHVhv> for copying C<%^H>.  I<ohv> must be
a pointer to a hash (which may have C<%^H> magic, but should be generally
non-magical), or C<NULL> (interpreted as an empty hash).  The content
of I<ohv> is copied to a new hash, which has the C<%^H>-specific magic
added to it.  A pointer to the new hash is returned.

=cut
*/

d1434 1
d1436 1
a1436 1
    if (ohv) {
a1437 1
	STRLEN hv_fill = HvFILL(ohv);
d1448 3
a1450 4
	    SV *const sv = newSVsv(hv_iterval(ohv,entry));
	    SV *heksv = HeSVKEY(entry);
	    if (!heksv && sv) heksv = newSVhek(HeKEY_hek(entry));
	    if (sv) sv_magic(sv, NULL, PERL_MAGIC_hintselem,
d1452 3
a1454 7
	    if (heksv == HeSVKEY(entry))
		(void)hv_store_ent(hv, heksv, sv, 0);
	    else {
		(void)hv_common(hv, heksv, HeKEY(entry), HeKLEN(entry),
				 HeKFLAGS(entry), HV_FETCH_ISSTORE|HV_FETCH_JUST_SV, sv, HeHASH(entry));
		SvREFCNT_dec(heksv);
	    }
d1463 2
a1464 3
/* like hv_free_ent, but returns the SV rather than freeing it */
STATIC SV*
S_hv_free_ent_ret(pTHX_ HV *hv, register HE *entry)
d1469 1
a1469 1
    PERL_ARGS_ASSERT_HV_FREE_ENT_RET;
d1472 1
a1472 1
	return NULL;
d1474 3
a1485 1
    return val;
d1488 2
a1489 3

void
Perl_hv_free_ent(pTHX_ HV *hv, register HE *entry)
d1491 1
a1491 2
    dVAR;
    SV *val;
d1493 1
a1493 1
    PERL_ARGS_ASSERT_HV_FREE_ENT;
d1495 19
a1513 4
    if (!entry)
	return;
    val = hv_free_ent_ret(hv, entry);
    SvREFCNT_dec(val);
a1515 1

d1536 1
a1536 5
Frees the all the elements of a hash, leaving it empty.
The XS equivalent of C<%hash = ()>.  See also L</hv_undef>.

If any destructors are triggered as a result, the hv itself may
be freed.
a1552 2
    ENTER;
    SAVEFREESV(SvREFCNT_inc_simple_NN(hv));
d1561 1
a1561 2
		    if (HeVAL(entry) && SvREADONLY(HeVAL(entry))
		     && !SvIsCOW(HeVAL(entry))) {
d1573 1
a1574 3
    else {
	hfreeentries(hv);
	HvPLACEHOLDERS_set(hv, 0);
d1576 4
a1579 2
	if (SvRMAGICAL(hv))
	    mg_clear(MUTABLE_SV(hv));
d1581 6
a1586 3
	HvHASKFLAGS_off(hv);
	HvREHASH_off(hv);
    }
d1588 1
a1588 1
        if(HvENAME_get(hv))
a1591 1
    LEAVE;
d1634 1
d1641 2
d1645 1
a1645 4
		else {
		    if (SvOOK(hv) && HvLAZYDEL(hv) &&
			entry == HeNEXT(HvAUX(hv)->xhv_eiter))
			HeNEXT(HvAUX(hv)->xhv_eiter) = HeNEXT(entry);
a1646 1
		}
d1651 1
a1651 1
		    if (HvUSEDKEYS(hv) == 0)
d1658 1
d1670 4
a1673 3
    STRLEN index = 0;
    XPVHV * const xhv = (XPVHV*)SvANY(hv);
    SV *sv;
d1677 17
a1693 2
    while ((sv = Perl_hfree_next_entry(aTHX_ hv, &index))||xhv->xhv_keys) {
	SvREFCNT_dec(sv);
d1695 92
a1786 1
}
d1789 3
a1791 8
/* hfree_next_entry()
 * For use only by S_hfreeentries() and sv_clear().
 * Delete the next available HE from hv and return the associated SV.
 * Returns null on empty hash. Nevertheless null is not a reliable
 * indicator that the hash is empty, as the deleted entry may have a
 * null value.
 * indexp is a pointer to the current index into HvARRAY. The index should
 * initially be set to 0. hfree_next_entry() may update it.  */
d1793 6
a1798 9
SV*
Perl_hfree_next_entry(pTHX_ HV *hv, STRLEN *indexp)
{
    struct xpvhv_aux *iter;
    HE *entry;
    HE ** array;
#ifdef DEBUGGING
    STRLEN orig_index = *indexp;
#endif
d1800 6
a1805 1
    PERL_ARGS_ASSERT_HFREE_NEXT_ENTRY;
d1807 3
a1809 10
    if (SvOOK(hv) && ((iter = HvAUX(hv)))
	&& ((entry = iter->xhv_eiter)) )
    {
	/* the iterator may get resurrected after each
	 * destructor call, so check each time */
	if (entry && HvLAZYDEL(hv)) {	/* was deleted earlier? */
	    HvLAZYDEL_off(hv);
	    hv_free_ent(hv, entry);
	    /* warning: at this point HvARRAY may have been
	     * re-allocated, HvMAX changed etc */
a1810 3
	iter->xhv_riter = -1; 	/* HvRITER(hv) = -1 */
	iter->xhv_eiter = NULL;	/* HvEITER(hv) = NULL */
    }
d1812 10
a1821 2
    if (!((XPVHV*)SvANY(hv))->xhv_keys)
	return NULL;
d1823 2
a1824 22
    array = HvARRAY(hv);
    assert(array);
    while ( ! ((entry = array[*indexp])) ) {
	if ((*indexp)++ >= HvMAX(hv))
	    *indexp = 0;
	assert(*indexp != orig_index);
    }
    array[*indexp] = HeNEXT(entry);
    ((XPVHV*) SvANY(hv))->xhv_keys--;

    if (   PL_phase != PERL_PHASE_DESTRUCT && HvENAME(hv)
	&& HeVAL(entry) && isGV(HeVAL(entry))
	&& GvHV(HeVAL(entry)) && HvENAME(GvHV(HeVAL(entry)))
    ) {
	STRLEN klen;
	const char * const key = HePV(entry,klen);
	if ((klen > 1 && key[klen-1]==':' && key[klen-2]==':')
	 || (klen == 1 && key[0] == ':')) {
	    mro_package_moved(
	     NULL, GvHV(HeVAL(entry)),
	     (GV *)HeVAL(entry), 0
	    );
d1827 11
a1837 1
    return hv_free_ent_ret(hv, entry);
a1839 1

d1843 1
a1843 9
Undefines the hash.  The XS equivalent of C<undef(%hash)>.

As well as freeing all the elements of the hash (like hv_clear()), this
also frees any auxiliary data and storage associated with the hash.

If any destructors are triggered as a result, the hv itself may
be freed.

See also L</hv_clear>.
d1849 1
a1849 1
Perl_hv_undef_flags(pTHX_ HV *hv, U32 flags)
a1853 1
    const bool save = !!SvREFCNT(hv);
d1860 5
a1864 11
    /* The name must be deleted before the call to hfreeeeentries so that
       CVs are anonymised properly. But the effective name must be pre-
       served until after that call (and only deleted afterwards if the
       call originated from sv_clear). For stashes with one name that is
       both the canonical name and the effective name, hv_name_set has to
       allocate an array for storing the effective name. We can skip that
       during global destruction, as it does not matter where the CVs point
       if they will be freed anyway. */
    /* note that the code following prior to hfreeentries is duplicated
     * in sv_clear(), and changes here should be done there too */
    if (PL_phase != PERL_PHASE_DESTRUCT && (name = HvNAME(hv))) {
d1866 1
a1866 4
	    (void)hv_delete(PL_stashcache, name,
                            HEK_UTF8(HvNAME_HEK(hv)) ? -HvNAMELEN_get(hv) : HvNAMELEN_get(hv),
                            G_DISCARD
                           );
d1869 5
a1873 57
    if (save) {
	ENTER;
	SAVEFREESV(SvREFCNT_inc_simple_NN(hv));
    }
    hfreeentries(hv);
    if (SvOOK(hv)) {
      struct xpvhv_aux * const aux = HvAUX(hv);
      struct mro_meta *meta;

      if ((name = HvENAME_get(hv))) {
	if (PL_phase != PERL_PHASE_DESTRUCT)
	    mro_isa_changed_in(hv);
        if (PL_stashcache)
	    (void)hv_delete(
	            PL_stashcache, name,
                    HEK_UTF8(HvENAME_HEK(hv)) ? -HvENAMELEN_get(hv) : HvENAMELEN_get(hv),
                    G_DISCARD
	          );
      }

      /* If this call originated from sv_clear, then we must check for
       * effective names that need freeing, as well as the usual name. */
      name = HvNAME(hv);
      if (flags & HV_NAME_SETALL ? !!aux->xhv_name_u.xhvnameu_name : !!name) {
        if (name && PL_stashcache)
	    (void)hv_delete(PL_stashcache, name, (HEK_UTF8(HvNAME_HEK(hv)) ? -HvNAMELEN_get(hv) : HvNAMELEN_get(hv)), G_DISCARD);
	hv_name_set(hv, NULL, 0, flags);
      }
      if((meta = aux->xhv_mro_meta)) {
	if (meta->mro_linear_all) {
	    SvREFCNT_dec(MUTABLE_SV(meta->mro_linear_all));
	    meta->mro_linear_all = NULL;
	    /* This is just acting as a shortcut pointer.  */
	    meta->mro_linear_current = NULL;
	} else if (meta->mro_linear_current) {
	    /* Only the current MRO is stored, so this owns the data.
	     */
	    SvREFCNT_dec(meta->mro_linear_current);
	    meta->mro_linear_current = NULL;
	}
	SvREFCNT_dec(meta->mro_nextmethod);
	SvREFCNT_dec(meta->isa);
	Safefree(meta);
	aux->xhv_mro_meta = NULL;
      }
      if (!aux->xhv_name_u.xhvnameu_name && ! aux->xhv_backreferences)
	SvFLAGS(hv) &= ~SVf_OOK;
    }
    if (!SvOOK(hv)) {
	Safefree(HvARRAY(hv));
	xhv->xhv_max   = 7;	/* HvMAX(hv) = 7 (it's a normal hash) */
	HvARRAY(hv) = 0;
    }
    /* if we're freeing the HV, the SvMAGIC field has been reused for
     * other purposes, and so there can't be any placeholder magic */
    if (SvREFCNT(hv))
	HvPLACEHOLDERS_set(hv, 0);
a1876 33
    if (save) LEAVE;
}

/*
=for apidoc hv_fill

Returns the number of hash buckets that happen to be in use. This function is
wrapped by the macro C<HvFILL>.

Previously this value was stored in the HV structure, rather than being
calculated on demand.

=cut
*/

STRLEN
Perl_hv_fill(pTHX_ HV const *const hv)
{
    STRLEN count = 0;
    HE **ents = HvARRAY(hv);

    PERL_ARGS_ASSERT_HV_FILL;

    if (ents) {
	HE *const *const last = ents + HvMAX(hv);
	count = last + 1 - ents;

	do {
	    if (!*ents)
		--count;
	} while (++ents <= last);
    }
    return count;
d1895 2
a1896 1
    SvOOK_on(hv);
d1901 1
a1901 2
    iter->xhv_name_u.xhvnameu_name = 0;
    iter->xhv_name_count = 0;
d1911 1
a1911 1
keys in the hash (i.e. the same as C<HvUSEDKEYS(hv)>).  The return value is
d1916 1
a1916 1
value, you can get it through the macro C<HvFILL(hv)>.
a2022 1
    HEK **spot;
d2025 1
d2032 2
a2033 44
	if (iter->xhv_name_u.xhvnameu_name) {
	    if(iter->xhv_name_count) {
	      if(flags & HV_NAME_SETALL) {
		HEK ** const name = HvAUX(hv)->xhv_name_u.xhvnameu_names;
		HEK **hekp = name + (
		    iter->xhv_name_count < 0
		     ? -iter->xhv_name_count
		     :  iter->xhv_name_count
		   );
		while(hekp-- > name+1) 
		    unshare_hek_or_pvn(*hekp, 0, 0, 0);
		/* The first elem may be null. */
		if(*name) unshare_hek_or_pvn(*name, 0, 0, 0);
		Safefree(name);
		spot = &iter->xhv_name_u.xhvnameu_name;
		iter->xhv_name_count = 0;
	      }
	      else {
		if(iter->xhv_name_count > 0) {
		    /* shift some things over */
		    Renew(
		     iter->xhv_name_u.xhvnameu_names, iter->xhv_name_count + 1, HEK *
		    );
		    spot = iter->xhv_name_u.xhvnameu_names;
		    spot[iter->xhv_name_count] = spot[1];
		    spot[1] = spot[0];
		    iter->xhv_name_count = -(iter->xhv_name_count + 1);
		}
		else if(*(spot = iter->xhv_name_u.xhvnameu_names)) {
		    unshare_hek_or_pvn(*spot, 0, 0, 0);
		}
	      }
	    }
	    else if (flags & HV_NAME_SETALL) {
		unshare_hek_or_pvn(iter->xhv_name_u.xhvnameu_name, 0, 0, 0);
		spot = &iter->xhv_name_u.xhvnameu_name;
	    }
	    else {
		HEK * const existing_name = iter->xhv_name_u.xhvnameu_name;
		Newx(iter->xhv_name_u.xhvnameu_names, 2, HEK *);
		iter->xhv_name_count = -2;
		spot = iter->xhv_name_u.xhvnameu_names;
		spot[1] = existing_name;
	    }
a2034 1
	else { spot = &iter->xhv_name_u.xhvnameu_name; iter->xhv_name_count = 0; }
a2039 1
	spot = &iter->xhv_name_u.xhvnameu_name;
d2042 1
a2042 161
    *spot = name ? share_hek(name, flags & SVf_UTF8 ? -(I32)len : (I32)len, hash) : NULL;
}

/*
This is basically sv_eq_flags() in sv.c, but we avoid the magic
and bytes checking.
*/

STATIC I32
hek_eq_pvn_flags(pTHX_ const HEK *hek, const char* pv, const I32 pvlen, const U32 flags) {
    if ( (HEK_UTF8(hek) ? 1 : 0) != (flags & SVf_UTF8 ? 1 : 0) ) {
        if (flags & SVf_UTF8)
            return (bytes_cmp_utf8(
                        (const U8*)HEK_KEY(hek), HEK_LEN(hek),
		        (const U8*)pv, pvlen) == 0);
        else
            return (bytes_cmp_utf8(
                        (const U8*)pv, pvlen,
		        (const U8*)HEK_KEY(hek), HEK_LEN(hek)) == 0);
    }
    else
        return HEK_LEN(hek) == pvlen && ((HEK_KEY(hek) == pv)
                    || memEQ(HEK_KEY(hek), pv, pvlen));
}

/*
=for apidoc hv_ename_add

Adds a name to a stash's internal list of effective names.  See
C<hv_ename_delete>.

This is called when a stash is assigned to a new location in the symbol
table.

=cut
*/

void
Perl_hv_ename_add(pTHX_ HV *hv, const char *name, U32 len, U32 flags)
{
    dVAR;
    struct xpvhv_aux *aux = SvOOK(hv) ? HvAUX(hv) : hv_auxinit(hv);
    U32 hash;

    PERL_ARGS_ASSERT_HV_ENAME_ADD;

    if (len > I32_MAX)
	Perl_croak(aTHX_ "panic: hv name too long (%"UVuf")", (UV) len);

    PERL_HASH(hash, name, len);

    if (aux->xhv_name_count) {
	HEK ** const xhv_name = aux->xhv_name_u.xhvnameu_names;
	I32 count = aux->xhv_name_count;
	HEK **hekp = xhv_name + (count < 0 ? -count : count);
	while (hekp-- > xhv_name)
	    if (
                 (HEK_UTF8(*hekp) || (flags & SVf_UTF8)) 
                    ? hek_eq_pvn_flags(aTHX_ *hekp, name, (I32)len, flags)
	            : (HEK_LEN(*hekp) == (I32)len && memEQ(HEK_KEY(*hekp), name, len))
               ) {
		if (hekp == xhv_name && count < 0)
		    aux->xhv_name_count = -count;
		return;
	    }
	if (count < 0) aux->xhv_name_count--, count = -count;
	else aux->xhv_name_count++;
	Renew(aux->xhv_name_u.xhvnameu_names, count + 1, HEK *);
	(aux->xhv_name_u.xhvnameu_names)[count] = share_hek(name, (flags & SVf_UTF8 ? -(I32)len : (I32)len), hash);
    }
    else {
	HEK *existing_name = aux->xhv_name_u.xhvnameu_name;
	if (
	    existing_name && (
             (HEK_UTF8(existing_name) || (flags & SVf_UTF8))
                ? hek_eq_pvn_flags(aTHX_ existing_name, name, (I32)len, flags)
	        : (HEK_LEN(existing_name) == (I32)len && memEQ(HEK_KEY(existing_name), name, len))
	    )
	) return;
	Newx(aux->xhv_name_u.xhvnameu_names, 2, HEK *);
	aux->xhv_name_count = existing_name ? 2 : -2;
	*aux->xhv_name_u.xhvnameu_names = existing_name;
	(aux->xhv_name_u.xhvnameu_names)[1] = share_hek(name, (flags & SVf_UTF8 ? -(I32)len : (I32)len), hash);
    }
}

/*
=for apidoc hv_ename_delete

Removes a name from a stash's internal list of effective names.  If this is
the name returned by C<HvENAME>, then another name in the list will take
its place (C<HvENAME> will use it).

This is called when a stash is deleted from the symbol table.

=cut
*/

void
Perl_hv_ename_delete(pTHX_ HV *hv, const char *name, U32 len, U32 flags)
{
    dVAR;
    struct xpvhv_aux *aux;

    PERL_ARGS_ASSERT_HV_ENAME_DELETE;

    if (len > I32_MAX)
	Perl_croak(aTHX_ "panic: hv name too long (%"UVuf")", (UV) len);

    if (!SvOOK(hv)) return;

    aux = HvAUX(hv);
    if (!aux->xhv_name_u.xhvnameu_name) return;

    if (aux->xhv_name_count) {
	HEK ** const namep = aux->xhv_name_u.xhvnameu_names;
	I32 const count = aux->xhv_name_count;
	HEK **victim = namep + (count < 0 ? -count : count);
	while (victim-- > namep + 1)
	    if (
             (HEK_UTF8(*victim) || (flags & SVf_UTF8)) 
                ? hek_eq_pvn_flags(aTHX_ *victim, name, (I32)len, flags)
	        : (HEK_LEN(*victim) == (I32)len && memEQ(HEK_KEY(*victim), name, len))
	    ) {
		unshare_hek_or_pvn(*victim, 0, 0, 0);
		if (count < 0) ++aux->xhv_name_count;
		else --aux->xhv_name_count;
		if (
		    (aux->xhv_name_count == 1 || aux->xhv_name_count == -1)
		 && !*namep
		) {  /* if there are none left */
		    Safefree(namep);
		    aux->xhv_name_u.xhvnameu_names = NULL;
		    aux->xhv_name_count = 0;
		}
		else {
		    /* Move the last one back to fill the empty slot. It
		       does not matter what order they are in. */
		    *victim = *(namep + (count < 0 ? -count : count) - 1);
		}
		return;
	    }
	if (
	    count > 0 && (HEK_UTF8(*namep) || (flags & SVf_UTF8)) 
                ? hek_eq_pvn_flags(aTHX_ *namep, name, (I32)len, flags)
	        : (HEK_LEN(*namep) == (I32)len && memEQ(HEK_KEY(*namep), name, len))
	) {
	    aux->xhv_name_count = -count;
	}
    }
    else if(
        (HEK_UTF8(aux->xhv_name_u.xhvnameu_name) || (flags & SVf_UTF8)) 
                ? hek_eq_pvn_flags(aTHX_ aux->xhv_name_u.xhvnameu_name, name, (I32)len, flags)
	        : (HEK_LEN(aux->xhv_name_u.xhvnameu_name) == (I32)len &&
                            memEQ(HEK_KEY(aux->xhv_name_u.xhvnameu_name), name, len))
    ) {
	HEK * const namehek = aux->xhv_name_u.xhvnameu_name;
	Newx(aux->xhv_name_u.xhvnameu_names, 1, HEK *);
	*aux->xhv_name_u.xhvnameu_names = namehek;
	aux->xhv_name_count = -1;
    }
d2069 1
a2069 2
	if (SvTYPE(av) == SVt_PVAV)
	    SvREFCNT_dec(av);
d2095 1
a2095 1
C<&PL_sv_placeholder>.  Note that the implementation of placeholders and
d2175 1
a2175 1
    /* hv_iterinit now ensures this.  */
a2217 1
    else iter->xhv_riter = -1;
d2364 1
d2405 1
a2405 1
    oentry = &(HvARRAY(PL_strtab))[hash & (I32) HvMAX(PL_strtab)];
d2430 4
d2441 1
a2441 1
			 "Attempt to free nonexistent shared string '%s'%s"
d2475 1
a2475 2
      if (str != save) {
          PERL_HASH(hash, str, len);
a2476 1
      }
d2529 1
a2529 1
	   HE directly from the HEK.
d2553 3
a2555 2
	} else if ( SHOULD_DO_HSPLIT(xhv) ) {
            hsplit(PL_strtab);
d2650 2
a2651 2
	Perl_croak(aTHX_ "panic: refcounted_he_value bad flags %"UVxf,
		   (UV)he->refcounted_he_data[0]);
d2657 1
a2657 1
=for apidoc m|HV *|refcounted_he_chain_2hv|const struct refcounted_he *c|U32 flags
d2659 2
a2660 3
Generates and returns a C<HV *> representing the content of a
C<refcounted_he> chain.
I<flags> is currently unused and must be zero.
d2665 1
a2665 1
Perl_refcounted_he_chain_2hv(pTHX_ const struct refcounted_he *chain, U32 flags)
d2668 2
a2669 7
    HV *hv;
    U32 placeholders, max;

    if (flags)
	Perl_croak(aTHX_ "panic: refcounted_he_chain_2hv bad flags %"UVxf,
	    (UV)flags);

d2673 2
a2674 2
    hv = newHV();
    max = HvMAX(hv);
a2680 1
    placeholders = 0;
d2735 4
a2760 14
/*
=for apidoc m|SV *|refcounted_he_fetch_pvn|const struct refcounted_he *chain|const char *keypv|STRLEN keylen|U32 hash|U32 flags

Search along a C<refcounted_he> chain for an entry with the key specified
by I<keypv> and I<keylen>.  If I<flags> has the C<REFCOUNTED_HE_KEY_UTF8>
bit set, the key octets are interpreted as UTF-8, otherwise they
are interpreted as Latin-1.  I<hash> is a precomputed hash of the key
string, or zero if it has not been precomputed.  Returns a mortal scalar
representing the value associated with the key, or C<&PL_sv_placeholder>
if there is no value associated with the key.

=cut
*/

d2762 2
a2763 2
Perl_refcounted_he_fetch_pvn(pTHX_ const struct refcounted_he *chain,
			 const char *keypv, STRLEN keylen, U32 hash, U32 flags)
d2766 7
a2772 2
    U8 utf8_flag;
    PERL_ARGS_ASSERT_REFCOUNTED_HE_FETCH_PVN;
d2774 17
a2790 37
    if (flags & ~(REFCOUNTED_HE_KEY_UTF8|REFCOUNTED_HE_EXISTS))
	Perl_croak(aTHX_ "panic: refcounted_he_fetch_pvn bad flags %"UVxf,
	    (UV)flags);
    if (!chain)
	return &PL_sv_placeholder;
    if (flags & REFCOUNTED_HE_KEY_UTF8) {
	/* For searching purposes, canonicalise to Latin-1 where possible. */
	const char *keyend = keypv + keylen, *p;
	STRLEN nonascii_count = 0;
	for (p = keypv; p != keyend; p++) {
	    U8 c = (U8)*p;
	    if (c & 0x80) {
		if (!((c & 0xfe) == 0xc2 && ++p != keyend &&
			    (((U8)*p) & 0xc0) == 0x80))
		    goto canonicalised_key;
		nonascii_count++;
	    }
	}
	if (nonascii_count) {
	    char *q;
	    const char *p = keypv, *keyend = keypv + keylen;
	    keylen -= nonascii_count;
	    Newx(q, keylen, char);
	    SAVEFREEPV(q);
	    keypv = q;
	    for (; p != keyend; p++, q++) {
		U8 c = (U8)*p;
		*q = (char)
		    ((c & 0x80) ? ((c & 0x03) << 6) | (((U8)*++p) & 0x3f) : c);
	    }
	}
	flags &= ~REFCOUNTED_HE_KEY_UTF8;
	canonicalised_key: ;
    }
    utf8_flag = (flags & REFCOUNTED_HE_KEY_UTF8) ? HVhek_UTF8 : 0;
    if (!hash)
	PERL_HASH(hash, keypv, keylen);
d2792 1
a2792 2
    for (; chain; chain = chain->refcounted_he_next) {
	if (
d2794 8
a2801 4
	    hash == chain->refcounted_he_hash &&
	    keylen == chain->refcounted_he_keylen &&
	    memEQ(REF_HE_KEY(chain), keypv, keylen) &&
	    utf8_flag == (chain->refcounted_he_data[0] & HVhek_UTF8)
d2803 12
a2814 11
	    hash == HEK_HASH(chain->refcounted_he_hek) &&
	    keylen == (STRLEN)HEK_LEN(chain->refcounted_he_hek) &&
	    memEQ(HEK_KEY(chain->refcounted_he_hek), keypv, keylen) &&
	    utf8_flag == (HEK_FLAGS(chain->refcounted_he_hek) & HVhek_UTF8)
#endif
	) {
	    if (flags & REFCOUNTED_HE_EXISTS)
		return (chain->refcounted_he_data[0] & HVrhek_typemask)
		    == HVrhek_delete
		    ? NULL : &PL_sv_yes;
	    return sv_2mortal(refcounted_he_value(chain));
a2816 2
    return flags & REFCOUNTED_HE_EXISTS ? NULL : &PL_sv_placeholder;
}
d2818 2
a2819 2
/*
=for apidoc m|SV *|refcounted_he_fetch_pv|const struct refcounted_he *chain|const char *key|U32 hash|U32 flags
d2821 1
a2821 39
Like L</refcounted_he_fetch_pvn>, but takes a nul-terminated string
instead of a string/length pair.

=cut
*/

SV *
Perl_refcounted_he_fetch_pv(pTHX_ const struct refcounted_he *chain,
			 const char *key, U32 hash, U32 flags)
{
    PERL_ARGS_ASSERT_REFCOUNTED_HE_FETCH_PV;
    return refcounted_he_fetch_pvn(chain, key, strlen(key), hash, flags);
}

/*
=for apidoc m|SV *|refcounted_he_fetch_sv|const struct refcounted_he *chain|SV *key|U32 hash|U32 flags

Like L</refcounted_he_fetch_pvn>, but takes a Perl scalar instead of a
string/length pair.

=cut
*/

SV *
Perl_refcounted_he_fetch_sv(pTHX_ const struct refcounted_he *chain,
			 SV *key, U32 hash, U32 flags)
{
    const char *keypv;
    STRLEN keylen;
    PERL_ARGS_ASSERT_REFCOUNTED_HE_FETCH_SV;
    if (flags & REFCOUNTED_HE_KEY_UTF8)
	Perl_croak(aTHX_ "panic: refcounted_he_fetch_sv bad flags %"UVxf,
	    (UV)flags);
    keypv = SvPV_const(key, keylen);
    if (SvUTF8(key))
	flags |= REFCOUNTED_HE_KEY_UTF8;
    if (!hash && SvIsCOW_shared_hash(key))
	hash = SvSHARED_HASH(key);
    return refcounted_he_fetch_pvn(chain, keypv, keylen, hash, flags);
d2825 1
a2825 1
=for apidoc m|struct refcounted_he *|refcounted_he_new_pvn|struct refcounted_he *parent|const char *keypv|STRLEN keylen|U32 hash|SV *value|U32 flags
d2827 3
a2829 26
Creates a new C<refcounted_he>.  This consists of a single key/value
pair and a reference to an existing C<refcounted_he> chain (which may
be empty), and thus forms a longer chain.  When using the longer chain,
the new key/value pair takes precedence over any entry for the same key
further along the chain.

The new key is specified by I<keypv> and I<keylen>.  If I<flags> has
the C<REFCOUNTED_HE_KEY_UTF8> bit set, the key octets are interpreted
as UTF-8, otherwise they are interpreted as Latin-1.  I<hash> is
a precomputed hash of the key string, or zero if it has not been
precomputed.

I<value> is the scalar value to store for this key.  I<value> is copied
by this function, which thus does not take ownership of any reference
to it, and later changes to the scalar will not be reflected in the
value visible in the C<refcounted_he>.  Complex types of scalar will not
be stored with referential integrity, but will be coerced to strings.
I<value> may be either null or C<&PL_sv_placeholder> to indicate that no
value is to be associated with the key; this, as with any non-null value,
takes precedence over the existence of a value for the key further along
the chain.

I<parent> points to the rest of the C<refcounted_he> chain to be
attached to the new C<refcounted_he>.  This function takes ownership
of one reference to I<parent>, and returns one reference to the new
C<refcounted_he>.
d2835 2
a2836 3
Perl_refcounted_he_new_pvn(pTHX_ struct refcounted_he *parent,
	const char *keypv, STRLEN keylen, U32 hash, SV *value, U32 flags)
{
d2838 2
a2841 1
    bool is_pv;
d2843 2
a2844 4
    char hekflags;
    STRLEN key_offset = 1;
    struct refcounted_he *he;
    PERL_ARGS_ASSERT_REFCOUNTED_HE_NEW_PVN;
d2846 1
a2846 3
    if (!value || value == &PL_sv_placeholder) {
	value_type = HVrhek_delete;
    } else if (SvPOK(value)) {
d2850 2
d2857 2
a2858 2
    is_pv = value_type == HVrhek_PV;
    if (is_pv) {
a2863 1
	key_offset = value_len + 2;
d2865 27
a2891 1
    hekflags = value_type;
d2893 1
a2893 33
    if (flags & REFCOUNTED_HE_KEY_UTF8) {
	/* Canonicalise to Latin-1 where possible. */
	const char *keyend = keypv + keylen, *p;
	STRLEN nonascii_count = 0;
	for (p = keypv; p != keyend; p++) {
	    U8 c = (U8)*p;
	    if (c & 0x80) {
		if (!((c & 0xfe) == 0xc2 && ++p != keyend &&
			    (((U8)*p) & 0xc0) == 0x80))
		    goto canonicalised_key;
		nonascii_count++;
	    }
	}
	if (nonascii_count) {
	    char *q;
	    const char *p = keypv, *keyend = keypv + keylen;
	    keylen -= nonascii_count;
	    Newx(q, keylen, char);
	    SAVEFREEPV(q);
	    keypv = q;
	    for (; p != keyend; p++, q++) {
		U8 c = (U8)*p;
		*q = (char)
		    ((c & 0x80) ? ((c & 0x03) << 6) | (((U8)*++p) & 0x3f) : c);
	    }
	}
	flags &= ~REFCOUNTED_HE_KEY_UTF8;
	canonicalised_key: ;
    }
    if (flags & REFCOUNTED_HE_KEY_UTF8)
	hekflags |= HVhek_UTF8;
    if (!hash)
	PERL_HASH(hash, keypv, keylen);
d2898 1
a2898 1
			     + keylen
d2909 1
a2909 1
	Copy(value_p, he->refcounted_he_data + 1, value_len + 1, char);
d2912 1
a2912 1
	he->refcounted_he_val.refcounted_he_u_iv = SvIVX(value);
d2914 1
a2914 1
	he->refcounted_he_val.refcounted_he_u_uv = SvUVX(value);
d2917 2
d2921 2
a2922 2
    he->refcounted_he_keylen = keylen;
    Copy(keypv, he->refcounted_he_data + key_offset, keylen, char);
d2924 1
a2924 1
    he->refcounted_he_hek = share_hek_flags(keypv, keylen, hash, hekflags);
d2927 7
a2933 1
    he->refcounted_he_data[0] = hekflags;
d2940 1
a2940 1
=for apidoc m|struct refcounted_he *|refcounted_he_new_pv|struct refcounted_he *parent|const char *key|U32 hash|SV *value|U32 flags
d2942 3
a2944 49
Like L</refcounted_he_new_pvn>, but takes a nul-terminated string instead
of a string/length pair.

=cut
*/

struct refcounted_he *
Perl_refcounted_he_new_pv(pTHX_ struct refcounted_he *parent,
	const char *key, U32 hash, SV *value, U32 flags)
{
    PERL_ARGS_ASSERT_REFCOUNTED_HE_NEW_PV;
    return refcounted_he_new_pvn(parent, key, strlen(key), hash, value, flags);
}

/*
=for apidoc m|struct refcounted_he *|refcounted_he_new_sv|struct refcounted_he *parent|SV *key|U32 hash|SV *value|U32 flags

Like L</refcounted_he_new_pvn>, but takes a Perl scalar instead of a
string/length pair.

=cut
*/

struct refcounted_he *
Perl_refcounted_he_new_sv(pTHX_ struct refcounted_he *parent,
	SV *key, U32 hash, SV *value, U32 flags)
{
    const char *keypv;
    STRLEN keylen;
    PERL_ARGS_ASSERT_REFCOUNTED_HE_NEW_SV;
    if (flags & REFCOUNTED_HE_KEY_UTF8)
	Perl_croak(aTHX_ "panic: refcounted_he_new_sv bad flags %"UVxf,
	    (UV)flags);
    keypv = SvPV_const(key, keylen);
    if (SvUTF8(key))
	flags |= REFCOUNTED_HE_KEY_UTF8;
    if (!hash && SvIsCOW_shared_hash(key))
	hash = SvSHARED_HASH(key);
    return refcounted_he_new_pvn(parent, keypv, keylen, hash, value, flags);
}

/*
=for apidoc m|void|refcounted_he_free|struct refcounted_he *he

Decrements the reference count of a C<refcounted_he> by one.  If the
reference count reaches zero the structure's memory is freed, which
(recursively) causes a reduction of its parent C<refcounted_he>'s
reference count.  It is safe to pass a null pointer to this function:
no action occurs in this case.
a2974 31
/*
=for apidoc m|struct refcounted_he *|refcounted_he_inc|struct refcounted_he *he

Increment the reference count of a C<refcounted_he>.  The pointer to the
C<refcounted_he> is also returned.  It is safe to pass a null pointer
to this function: no action occurs and a null pointer is returned.

=cut
*/

struct refcounted_he *
Perl_refcounted_he_inc(pTHX_ struct refcounted_he *he)
{
    dVAR;
    if (he) {
	HINTS_REFCNT_LOCK;
	he->refcounted_he_refcnt++;
	HINTS_REFCNT_UNLOCK;
    }
    return he;
}

/*
=for apidoc cop_fetch_label

Returns the label attached to a cop.
The flags pointer may be set to C<SVf_UTF8> or 0.

=cut
*/

d2978 2
a2979 5
Perl_cop_fetch_label(pTHX_ COP *const cop, STRLEN *len, U32 *flags) {
    struct refcounted_he *const chain = cop->cop_hints_hash;

    PERL_ARGS_ASSERT_COP_FETCH_LABEL;

d3008 5
a3012 12
/*
=for apidoc cop_store_label

Save a label into a C<cop_hints_hash>. You need to set flags to C<SVf_UTF8>
for a utf-8 label.

=cut
*/

void
Perl_cop_store_label(pTHX_ COP *const cop, const char *label, STRLEN len,
		     U32 flags)
d3014 1
a3014 2
    SV *labelsv;
    PERL_ARGS_ASSERT_COP_STORE_LABEL;
d3016 2
a3017 8
    if (flags & ~(SVf_UTF8))
	Perl_croak(aTHX_ "panic: cop_store_label illegal flag bits 0x%" UVxf,
		   (UV)flags);
    labelsv = newSVpvn_flags(label, len, SVs_TEMP);
    if (flags & SVf_UTF8)
	SvUTF8_on(labelsv);
    cop->cop_hints_hash
	= refcounted_he_new_pvs(cop->cop_hints_hash, ":", labelsv, 0);
@


1.1.1.15
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d38 2
a39 1
#define DO_HSPLIT(xhv) ((xhv)->xhv_keys > (xhv)->xhv_max) /* HvTOTALKEYS(hv) > HvMAX(hv) */
d82 1
a82 1
    HEK *hek;
d281 1
a281 4
C<lval> is set then the fetch will be part of a store.  This means that if
there is no value in the hash associated with the given key, then one is
created and a pointer to it is returned.  The C<SV*> it points to can be
assigned to.  But always check that the
d338 1
a338 1
	       int flags, int action, SV *val, U32 hash)
d389 1
a389 1
	    flags = is_utf8 ? HVhek_UTF8 : 0;
d397 2
a398 1
					 flags, action, hash);
d528 1
a528 1
		const bool save_taint = TAINT_get;
d533 2
a534 2
		    if (TAINTING_get)
			TAINT_set(SvTAINTED(keysv));
a541 3
#ifdef NO_TAINT_SUPPORT
                PERL_UNUSED_VAR(save_taint);
#endif
d596 1
a596 1
    if (is_utf8 && !(flags & HVhek_KEYCANONICAL)) {
d615 12
a626 6
    if (!hash) {
        if (keysv && (SvIsCOW_shared_hash(keysv)))
            hash = SvSHARED_HASH(keysv);
        else
            PERL_HASH(hash, key, klen);
    }
d794 2
a795 42

#ifdef PERL_HASH_RANDOMIZE_KEYS
    /* This logic semi-randomizes the insert order in a bucket.
     * Either we insert into the top, or the slot below the top,
     * making it harder to see if there is a collision. We also
     * reset the iterator randomizer if there is one.
     */
    if ( *oentry && PL_HASH_RAND_BITS_ENABLED) {
        PL_hash_rand_bits++;
        PL_hash_rand_bits= ROTL_UV(PL_hash_rand_bits,1);
        if ( PL_hash_rand_bits & 1 ) {
            HeNEXT(entry) = HeNEXT(*oentry);
            HeNEXT(*oentry) = entry;
        } else {
            HeNEXT(entry) = *oentry;
            *oentry = entry;
        }
    } else
#endif
    {
        HeNEXT(entry) = *oentry;
        *oentry = entry;
    }
#ifdef PERL_HASH_RANDOMIZE_KEYS
    if (SvOOK(hv)) {
        /* Currently this makes various tests warn in annoying ways.
         * So Silenced for now. - Yves | bogus end of comment =>* /
        if (HvAUX(hv)->xhv_riter != -1) {
            Perl_ck_warner_d(aTHX_ packWARN(WARN_INTERNAL),
                             "[TESTING] Inserting into a hash during each() traversal results in undefined behavior"
                             pTHX__FORMAT
                             pTHX__VALUE);
        }
        */
        if (PL_HASH_RAND_BITS_ENABLED) {
            if (PL_HASH_RAND_BITS_ENABLED == 1)
                PL_hash_rand_bits += (PTRV)entry + 1;  /* we don't bother to use ptr_hash here */
            PL_hash_rand_bits= ROTL_UV(PL_hash_rand_bits,1);
        }
        HvAUX(hv)->xhv_rand= (U32)PL_hash_rand_bits;
    }
#endif
d803 2
a804 21
    if ( DO_HSPLIT(xhv) ) {
        const STRLEN oldsize = xhv->xhv_max + 1;
        const U32 items = (U32)HvPLACEHOLDERS_get(hv);

        if (items /* hash has placeholders  */
            && !SvREADONLY(hv) /* but is not a restricted hash */) {
            /* If this hash previously was a "restricted hash" and had
               placeholders, but the "restricted" flag has been turned off,
               then the placeholders no longer serve any useful purpose.
               However, they have the downsides of taking up RAM, and adding
               extra steps when finding used values. It's safe to clear them
               at this point, even though Storable rebuilds restricted hashes by
               putting in all the placeholders (first) before turning on the
               readonly flag, because Storable always pre-splits the hash.
               If we're lucky, then we may clear sufficient placeholders to
               avoid needing to split the hash at all.  */
            clear_placeholders(hv, items);
            if (DO_HSPLIT(xhv))
                hsplit(hv, oldsize, oldsize * 2);
        } else
            hsplit(hv, oldsize, oldsize * 2);
d891 3
a893 3
    XPVHV* xhv;
    HE *entry;
    HE **oentry;
d941 1
a941 1
    if (is_utf8 && !(k_flags & HVhek_KEYCANONICAL)) {
d960 4
a963 6
    if (!hash) {
        if (keysv && (SvIsCOW_shared_hash(keysv)))
            hash = SvSHARED_HASH(keysv);
        else
            PERL_HASH(hash, key, klen);
    }
d1091 1
a1091 1
S_hsplit(pTHX_ HV *hv, STRLEN const oldsize, STRLEN newsize)
d1094 4
a1097 1
    STRLEN i = 0;
d1099 3
a1101 1
    HE **aep;
d1108 8
d1117 1
d1124 2
a1125 10
#ifdef PERL_HASH_RANDOMIZE_KEYS
    /* the idea of this is that we create a "random" value by hashing the address of
     * the array, we then use the low bit to decide if we insert at the top, or insert
     * second from top. After each such insert we rotate the hashed value. So we can
     * use the same hashed value over and over, and in normal build environments use
     * very few ops to do so. ROTL32() should produce a single machine operation. */
    if (PL_HASH_RAND_BITS_ENABLED) {
        if (PL_HASH_RAND_BITS_ENABLED == 1)
            PL_hash_rand_bits += ptr_hash((PTRV)a);
        PL_hash_rand_bits = ROTL_UV(PL_hash_rand_bits,1);
d1127 8
a1134 2
#endif

d1136 3
a1138 6
        struct xpvhv_aux *const dest
            = (struct xpvhv_aux*) &a[newsize * sizeof(HE*)];
        Move(&a[oldsize * sizeof(HE*)], dest, 1, struct xpvhv_aux);
        /* we reset the iterator's xhv_rand as well, so they get a totally new ordering */
#ifdef PERL_HASH_RANDOMIZE_KEYS
        dest->xhv_rand = (U32)PL_hash_rand_bits;
a1139 1
    }
d1143 1
a1143 1
    HvMAX(hv) = --newsize;
d1145 1
d1147 6
a1152 7
    if (!HvTOTALKEYS(hv))       /* skip rest if no entries */
        return;

    aep = (HE**)a;
    do {
	HE **oentry = aep + i;
	HE *entry = aep[i];
d1156 1
d1158 1
a1158 2
            U32 j = (HeHASH(entry) & newsize);
	    if (j != (U32)i) {
d1160 3
a1162 25
#ifdef PERL_HASH_RANDOMIZE_KEYS
                /* if the target cell is empty or PL_HASH_RAND_BITS_ENABLED is false
                 * insert to top, otherwise rotate the bucket rand 1 bit,
                 * and use the new low bit to decide if we insert at top,
                 * or next from top. IOW, we only rotate on a collision.*/
                if (aep[j] && PL_HASH_RAND_BITS_ENABLED) {
                    PL_hash_rand_bits+= ROTL_UV(HeHASH(entry), 17);
                    PL_hash_rand_bits= ROTL_UV(PL_hash_rand_bits,1);
                    if (PL_hash_rand_bits & 1) {
                        HeNEXT(entry)= HeNEXT(aep[j]);
                        HeNEXT(aep[j])= entry;
                    } else {
                        /* Note, this is structured in such a way as the optimizer
                        * should eliminate the duplicated code here and below without
                        * us needing to explicitly use a goto. */
                        HeNEXT(entry) = aep[j];
                        aep[j] = entry;
                    }
                } else
#endif
                {
                    /* see comment above about duplicated code */
                    HeNEXT(entry) = aep[j];
                    aep[j] = entry;
                }
d1166 1
d1170 77
a1246 1
    } while (i++ < oldsize);
d1253 1
a1253 1
    XPVHV* xhv = (XPVHV*)SvANY(hv);
d1255 4
a1258 2
    I32 newsize;
    char *a;
d1275 29
a1303 5
        hsplit(hv, oldsize, newsize);
    } else {
        Newxz(a, PERL_HV_ARRAY_ALLOC_BYTES(newsize), char);
        xhv->xhv_max = --newsize;
        HvARRAY(hv) = (HE **) a;
d1305 4
a1308 1
}
d1310 4
a1313 13
/* IMO this should also handle cases where hv_max is smaller than hv_keys
 * as tied hashes could play silly buggers and mess us around. We will
 * do the right thing during hv_store() afterwards, but still - Yves */
#define HV_SET_MAX_ADJUSTED_FOR_KEYS(hv,hv_max,hv_keys) STMT_START {\
    /* Can we use fewer buckets? (hv_max is always 2^n-1) */        \
    if (hv_max < PERL_HASH_DEFAULT_HvMAX) {                         \
        hv_max = PERL_HASH_DEFAULT_HvMAX;                           \
    } else {                                                        \
        while (hv_max > PERL_HASH_DEFAULT_HvMAX && hv_max + 1 >= hv_keys * 2) \
            hv_max = hv_max / 2;                                    \
    }                                                               \
    HvMAX(hv) = hv_max;                                             \
} STMT_END
d1315 17
d1394 1
a1394 1
        STRLEN hv_keys = HvTOTALKEYS(ohv);
d1396 4
a1399 1
        HV_SET_MAX_ADJUSTED_FOR_KEYS(hv,hv_max,hv_keys);
d1438 1
a1438 1
        STRLEN hv_keys = HvTOTALKEYS(ohv);
d1443 3
a1445 4
	ENTER;
	SAVEFREESV(hv);

        HV_SET_MAX_ADJUSTED_FOR_KEYS(hv,hv_max,hv_keys);
d1459 1
a1459 1
		SvREFCNT_dec_NN(heksv);
a1463 3

	SvREFCNT_inc_simple_void_NN(hv);
	LEAVE;
a1467 1
#undef HV_SET_MAX_ADJUSTED_FOR_KEYS
d1471 1
a1471 1
S_hv_free_ent_ret(pTHX_ HV *hv, HE *entry)
d1478 2
d1495 1
a1495 1
Perl_hv_free_ent(pTHX_ HV *hv, HE *entry)
d1510 1
a1510 1
Perl_hv_delayfree_ent(pTHX_ HV *hv, HE *entry)
d1542 1
a1542 1
    XPVHV* xhv;
d1560 6
a1565 8
		    if (HeVAL(entry)) {
			if (SvREADONLY(HeVAL(entry)) && !SvIsCOW(HeVAL(entry))) {
			    SV* const keysv = hv_iterkeysv(entry);
			    Perl_croak_nocontext(
				"Attempt to delete readonly key '%"SVf"' from a restricted hash",
				(void*)keysv);
			}
			SvREFCNT_dec_NN(HeVAL(entry));
d1567 1
d1582 1
a1713 3
#ifdef PERL_HASH_RANDOMIZE_KEYS
        iter->xhv_last_rand = iter->xhv_rand;
#endif
d1767 1
a1767 1
    XPVHV* xhv;
d1787 1
a1787 3
        if (PL_stashcache) {
            DEBUG_o(Perl_deb(aTHX_ "hv_undef_flags clearing PL_stashcache for '%"
                             HEKf"'\n", HvNAME_HEK(hv)));
a1791 1
        }
d1806 1
a1806 3
        if (PL_stashcache) {
            DEBUG_o(Perl_deb(aTHX_ "hv_undef_flags clearing PL_stashcache for effective name '%"
                             HEKf"'\n", HvENAME_HEK(hv)));
a1811 1
        }
d1818 1
a1818 3
        if (name && PL_stashcache) {
            DEBUG_o(Perl_deb(aTHX_ "hv_undef_flags clearing PL_stashcache for name '%"
                             HEKf"'\n", HvNAME_HEK(hv)));
a1819 1
        }
d1824 5
a1828 5
	    SvREFCNT_dec_NN(meta->mro_linear_all);
	    /* mro_linear_current is just acting as a shortcut pointer,
	       hence the else.  */
	}
	else
d1832 2
a1838 1
      SvREFCNT_dec(aux->xhv_super);
d1844 1
a1844 1
        xhv->xhv_max = PERL_HASH_DEFAULT_HvMAX;        /* HvMAX(hv) = 7 (it's a normal hash) */
a1888 34
/* hash a pointer to a U32 - Used in the hash traversal randomization
 * and bucket order randomization code
 *
 * this code was derived from Sereal, which was derived from autobox.
 */

PERL_STATIC_INLINE U32 S_ptr_hash(PTRV u) {
#if PTRSIZE == 8
    /*
     * This is one of Thomas Wang's hash functions for 64-bit integers from:
     * http://www.concentric.net/~Ttwang/tech/inthash.htm
     */
    u = (~u) + (u << 18);
    u = u ^ (u >> 31);
    u = u * 21;
    u = u ^ (u >> 11);
    u = u + (u << 6);
    u = u ^ (u >> 22);
#else
    /*
     * This is one of Bob Jenkins' hash functions for 32-bit integers
     * from: http://burtleburtle.net/bob/hash/integer.html
     */
    u = (u + 0x7ed55d16) + (u << 12);
    u = (u ^ 0xc761c23c) ^ (u >> 19);
    u = (u + 0x165667b1) + (u << 5);
    u = (u + 0xd3a2646c) ^ (u << 9);
    u = (u + 0xfd7046c5) + (u << 3);
    u = (u ^ 0xb55a4f09) ^ (u >> 16);
#endif
    return (U32)u;
}


d1890 1
a1890 1
S_hv_auxinit(pTHX_ HV *hv) {
d1896 3
a1898 21
    if (!SvOOK(hv)) {
        if (!HvARRAY(hv)) {
            Newxz(array, PERL_HV_ARRAY_ALLOC_BYTES(HvMAX(hv) + 1)
                + sizeof(struct xpvhv_aux), char);
        } else {
            array = (char *) HvARRAY(hv);
            Renew(array, PERL_HV_ARRAY_ALLOC_BYTES(HvMAX(hv) + 1)
                  + sizeof(struct xpvhv_aux), char);
        }
        HvARRAY(hv) = (HE**)array;
        SvOOK_on(hv);
        iter = HvAUX(hv);
#ifdef PERL_HASH_RANDOMIZE_KEYS
        if (PL_HASH_RAND_BITS_ENABLED) {
            /* mix in some new state to PL_hash_rand_bits to "randomize" the traversal order*/
            if (PL_HASH_RAND_BITS_ENABLED == 1)
                PL_hash_rand_bits += ptr_hash((PTRV)array);
            PL_hash_rand_bits = ROTL_UV(PL_hash_rand_bits,1);
        }
        iter->xhv_rand = (U32)PL_hash_rand_bits;
#endif
d1900 3
a1902 1
        iter = HvAUX(hv);
d1904 3
a1909 3
#ifdef PERL_HASH_RANDOMIZE_KEYS
    iter->xhv_last_rand = iter->xhv_rand;
#endif
a1913 1
    iter->xhv_super = NULL;
a1950 3
#ifdef PERL_HASH_RANDOMIZE_KEYS
        iter->xhv_last_rand = iter->xhv_rand;
#endif
a2005 21
Perl_hv_rand_set(pTHX_ HV *hv, U32 new_xhv_rand) {
    struct xpvhv_aux *iter;

    PERL_ARGS_ASSERT_HV_RAND_SET;

#ifdef PERL_HASH_RANDOMIZE_KEYS
    if (!hv)
        Perl_croak(aTHX_ "Bad hash");

    if (SvOOK(hv)) {
        iter = HvAUX(hv);
    } else {
        iter = hv_auxinit(hv);
    }
    iter->xhv_rand = new_xhv_rand;
#else
    Perl_croak(aTHX_ "This Perl has not been built with support for randomized hash key traversal but something called Perl_hv_rand_set().");
#endif
}

void
d2284 1
a2284 1
	    SvREFCNT_dec_NN(av);
d2321 2
a2322 2
    XPVHV* xhv;
    HE *entry;
d2336 1
a2336 1
	   call hv_iternext without calling hv_iterinit, so we'll have to deal
a2348 1
		HeSVKEY_set(entry, NULL);
a2355 1
		HvLAZYDEL_on(hv); /* make sure entry gets freed */
a2371 1
	    HvLAZYDEL_off(hv);
a2407 12
#ifdef PERL_HASH_RANDOMIZE_KEYS
    if (iter->xhv_last_rand != iter->xhv_rand) {
        if (iter->xhv_riter != -1) {
            Perl_ck_warner_d(aTHX_ packWARN(WARN_INTERNAL),
                             "Use of each() on hash after insertion without resetting hash iterator results in undefined behavior"
                             pTHX__FORMAT
                             pTHX__VALUE);
        }
        iter->xhv_last_rand = iter->xhv_rand;
    }
#endif

a2417 3
#ifdef PERL_HASH_RANDOMIZE_KEYS
                iter->xhv_last_rand = iter->xhv_rand; /* reset xhv_last_rand so we can detect inserts during traversal */
#endif
d2420 1
a2420 1
            entry = (HvARRAY(hv))[ PERL_HASH_ITER_BUCKET(iter) & xhv->xhv_max ];
d2433 1
a2433 6
    else {
        iter->xhv_riter = -1;
#ifdef PERL_HASH_RANDOMIZE_KEYS
        iter->xhv_last_rand = iter->xhv_rand;
#endif
    }
d2440 3
d2457 1
a2457 1
Perl_hv_iterkey(pTHX_ HE *entry, I32 *retlen)
d2485 1
a2485 1
Perl_hv_iterkeysv(pTHX_ HE *entry)
d2502 1
a2502 1
Perl_hv_iterval(pTHX_ HV *hv, HE *entry)
d2577 1
a2577 1
    XPVHV* xhv;
d2579 1
a2579 1
    HE **oentry;
d2665 1
a2665 1
Perl_share_hek(pTHX_ const char *str, I32 len, U32 hash)
a2686 1
          dVAR;
d2696 1
a2696 1
S_share_hek_flags(pTHX_ const char *str, I32 len, U32 hash, int flags)
d2699 1
a2699 1
    HE *entry;
d2702 1
a2702 1
    XPVHV * const xhv = (XPVHV*)SvANY(PL_strtab);
d2766 2
a2767 3
	} else if ( DO_HSPLIT(xhv) ) {
            const STRLEN oldsize = xhv->xhv_max + 1;
            hsplit(PL_strtab, oldsize, oldsize * 2);
d3497 1
a3497 1
 * indent-tabs-mode: nil
d3500 1
a3500 1
 * ex: set ts=8 sts=4 sw=4 et:
@


1.1.1.16
log
@Import perl-5.20.1
@
text
@a38 1
#define HV_FILL_THRESHOLD 31
d752 1
a752 2
	       up as a bug if the conversion routine is not idempotent.
	       Hence the use of HV_DISABLE_UVAR_XKEY.  */
a792 7
    if (!*oentry && SvOOK(hv)) {
        /* initial entry, and aux struct present.  */
        struct xpvhv_aux *const aux = HvAUX(hv);
        if (aux->xhv_fill_lazy)
            ++aux->xhv_fill_lazy;
    }

d894 1
a894 2
Evaluates the hash in scalar context and returns the result.  Handles magic
when the hash is tied.
a950 1
    HE *const *first_entry;
d1026 1
a1026 1
    first_entry = oentry = &(HvARRAY(hv))[hash & (I32) HvMAX(hv)];
d1055 2
a1056 1
	if (SvREADONLY(hv) && HeVAL(entry) && SvREADONLY(HeVAL(entry))) {
a1113 6
            if(!*first_entry && SvOOK(hv)) {
                /* removed last entry, and aux struct present.  */
                struct xpvhv_aux *const aux = HvAUX(hv);
                if (aux->xhv_fill_lazy)
                    --aux->xhv_fill_lazy;
            }
a1148 1

d1157 1
a1157 8
    bool do_aux= (
        /* already have an HvAUX(hv) so we have to move it */
        SvOOK(hv) ||
        /* no HvAUX() but array we are going to allocate is large enough
         * there is no point in saving the space for the iterator, and
         * speeds up later traversals. */
        ( ( hv != PL_strtab ) && ( newsize >= PERL_HV_ALLOC_AUX_SIZE ) )
    );
d1159 2
a1160 1
    PERL_ARGS_ASSERT_HSPLIT;
d1164 1
a1164 2
          + (do_aux ? sizeof(struct xpvhv_aux) : 0), char);
    PL_nomemok = FALSE;
d1166 1
a1168 1

d1181 2
a1182 6
    HvARRAY(hv) = (HE**) a;
    HvMAX(hv) = newsize - 1;
    /* before we zero the newly added memory, we
     * need to deal with the aux struct that may be there
     * or have been allocated by us*/
    if (do_aux) {
d1185 2
a1186 16
        if (SvOOK(hv)) {
            /* alread have an aux, copy the old one in place. */
            Move(&a[oldsize * sizeof(HE*)], dest, 1, struct xpvhv_aux);
            /* we reset the iterator's xhv_rand as well, so they get a totally new ordering */
#ifdef PERL_HASH_RANDOMIZE_KEYS
            dest->xhv_rand = (U32)PL_hash_rand_bits;
#endif
            /* For now, just reset the lazy fill counter.
               It would be possible to update the counter in the code below
               instead.  */
            dest->xhv_fill_lazy = 0;
        } else {
            /* no existing aux structure, but we allocated space for one
             * so intialize it properly. This unrolls hv_auxinit() a bit,
             * since we have to do the realloc anyway. */
            /* first we set the iterator's xhv_rand so it can be copied into lastrand below */
d1188 1
a1188 1
            dest->xhv_rand = (U32)PL_hash_rand_bits;
a1189 5
            /* this is the "non realloc" part of the hv_auxinit() */
            (void)hv_auxinit_internal(dest);
            /* Turn on the OOK flag */
            SvOOK_on(hv);
        }
d1191 2
a1192 1
    /* now we can safely clear the second half */
d1194 2
a1199 1
    newsize--;
d1520 1
a1520 1
			if (SvREADONLY(HeVAL(entry))) {
d1608 2
a1609 4
		    I32 placeholders = HvPLACEHOLDERS_get(hv);
		    HvTOTALKEYS(hv) -= (IV)placeholders;
		    /* HvUSEDKEYS expanded */
		    if ((HvTOTALKEYS(hv) - placeholders) == 0)
d1621 1
a1621 1
    NOT_REACHED;
d1660 13
a1672 13
    if (SvOOK(hv) && ((iter = HvAUX(hv)))) {
	if ((entry = iter->xhv_eiter)) {
            /* the iterator may get resurrected after each
             * destructor call, so check each time */
            if (entry && HvLAZYDEL(hv)) {	/* was deleted earlier? */
                HvLAZYDEL_off(hv);
                hv_free_ent(hv, entry);
                /* warning: at this point HvARRAY may have been
                 * re-allocated, HvMAX changed etc */
            }
            iter = HvAUX(hv); /* may have been realloced */
            iter->xhv_riter = -1; 	/* HvRITER(hv) = -1 */
            iter->xhv_eiter = NULL;	/* HvEITER(hv) = NULL */
d1674 1
a1674 1
            iter->xhv_last_rand = iter->xhv_rand;
a1675 7
        }
        /* Reset any cached HvFILL() to "unknown".  It's unlikely that anyone
           will actually call HvFILL() on a hash under destruction, so it
           seems pointless attempting to track the number of keys remaining.
           But if they do, we want to reset it again.  */
        if (iter->xhv_fill_lazy)
            iter->xhv_fill_lazy = 0;
d1730 2
a1731 1
    bool save;
a1734 1
    save = !!SvREFCNT(hv);
d1748 1
a1748 1
    if (PL_phase != PERL_PHASE_DESTRUCT && HvNAME(hv)) {
d1752 4
a1755 1
	    (void)hv_deletehek(PL_stashcache, HvNAME_HEK(hv), G_DISCARD);
d1765 1
a1766 1
      const char *name;
d1768 1
a1768 1
      if (HvENAME_get(hv)) {
d1774 5
a1778 1
	    (void)hv_deletehek(PL_stashcache, HvENAME_HEK(hv), G_DISCARD);
d1785 1
a1785 1
      if (flags & HV_NAME_SETALL ? !!HvAUX(hv)->xhv_name_u.xhvnameu_name : !!name) {
d1789 1
a1789 1
	    (void)hv_deletehek(PL_stashcache, HvNAME_HEK(hv), G_DISCARD);
d1793 1
a1793 1
      if((meta = HvAUX(hv)->xhv_mro_meta)) {
a1804 1
	SvREFCNT_dec(meta->super);
d1806 1
a1806 1
	HvAUX(hv)->xhv_mro_meta = NULL;
d1808 2
a1809 1
      if (!HvAUX(hv)->xhv_name_u.xhvnameu_name && ! HvAUX(hv)->xhv_backreferences)
d1830 1
a1830 2
Returns the number of hash buckets that
happen to be in use.  This function is
d1833 2
a1834 7
Previously this value was always stored in the HV structure, which created an
overhead on every hash (and pretty much every object) for something that was
rarely used.  Now we calculate it on demand the first
time that it is needed, and cache it if that calculation
is going to be costly to repeat.  The cached
value is updated by insertions and deletions, but (currently) discarded if
the hash is split.
d1840 1
a1840 1
Perl_hv_fill(pTHX_ HV *const hv)
a1843 1
    struct xpvhv_aux *aux = SvOOK(hv) ? HvAUX(hv) : NULL;
a1846 10
    /* No keys implies no buckets used.
       One key can only possibly mean one bucket used.  */
    if (HvTOTALKEYS(hv) < 2)
        return HvTOTALKEYS(hv);

#ifndef DEBUGGING
    if (aux && aux->xhv_fill_lazy)
        return aux->xhv_fill_lazy;
#endif

a1855 10
    if (aux) {
#ifdef DEBUGGING
        if (aux->xhv_fill_lazy)
            assert(aux->xhv_fill_lazy == count);
#endif
        aux->xhv_fill_lazy = count;
    } else if (HvMAX(hv) >= HV_FILL_THRESHOLD) {
        aux = hv_auxinit(hv);
        aux->xhv_fill_lazy = count;
    }        
a1891 17
static struct xpvhv_aux*
S_hv_auxinit_internal(struct xpvhv_aux *iter) {
    PERL_ARGS_ASSERT_HV_AUXINIT_INTERNAL;
    iter->xhv_riter = -1; 	/* HvRITER(hv) = -1 */
    iter->xhv_eiter = NULL;	/* HvEITER(hv) = NULL */
#ifdef PERL_HASH_RANDOMIZE_KEYS
    iter->xhv_last_rand = iter->xhv_rand;
#endif
    iter->xhv_fill_lazy = 0;
    iter->xhv_name_u.xhvnameu_name = 0;
    iter->xhv_name_count = 0;
    iter->xhv_backreferences = 0;
    iter->xhv_mro_meta = NULL;
    iter->xhv_aux_flags = 0;
    return iter;
}

d1925 11
a1935 1
    return hv_auxinit_internal(iter);
d1964 1
a1964 1
	struct xpvhv_aux * iter = HvAUX(hv);
a1969 1
	iter = HvAUX(hv); /* may have been reallocated */
a2100 1
                iter = HvAUX(hv); /* may been realloced */
a2121 1
                iter = HvAUX(hv); /* may been realloced */
a2265 1
                aux = HvAUX(hv); /* may been realloced */
d2353 1
a2353 1
to normal keys.  By default placeholders are automatically skipped over.
a2417 1
            iter = HvAUX(hv); /* may been realloced */
a2463 1
        iter = HvAUX(hv); /* may been realloced */
a2507 1
    iter = HvAUX(hv); /* may been realloced */
d2846 1
a2846 1
SSize_t *
d3075 4
a3078 2
	    if (! UTF8_IS_INVARIANT(*p)) {
		if (! UTF8_IS_NEXT_CHAR_DOWNGRADEABLE(p, keyend)) {
a3079 1
                }
a3080 1
                p++;
d3092 2
a3093 7
                if (UTF8_IS_INVARIANT(c)) {
                    *q = (char) c;
                }
                else {
                    p++;
                    *q = (char) TWO_BYTE_UTF8_TO_NATIVE(c, *p);
                }
d3245 4
a3248 2
	    if (! UTF8_IS_INVARIANT(*p)) {
		if (! UTF8_IS_NEXT_CHAR_DOWNGRADEABLE(p, keyend)) {
a3249 1
                }
a3250 1
                p++;
d3262 2
a3263 7
                if (UTF8_IS_INVARIANT(c)) {
                    *q = (char) c;
                }
                else {
                    p++;
                    *q = (char) TWO_BYTE_UTF8_TO_NATIVE(c, *p);
                }
d3462 1
a3462 2
Save a label into a C<cop_hints_hash>.
You need to set flags to C<SVf_UTF8>
@


