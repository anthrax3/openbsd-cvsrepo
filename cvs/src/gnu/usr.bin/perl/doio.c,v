head	1.19;
access;
symbols
	OPENBSD_6_2:1.19.0.2
	OPENBSD_6_2_BASE:1.19
	PERL_5_24_2:1.1.1.17
	OPENBSD_6_1:1.19.0.4
	OPENBSD_6_1_BASE:1.19
	OPENBSD_6_0:1.18.0.10
	OPENBSD_6_0_BASE:1.18
	OPENBSD_5_9:1.18.0.4
	OPENBSD_5_9_BASE:1.18
	OPENBSD_5_8:1.18.0.6
	OPENBSD_5_8_BASE:1.18
	PERL_5_20_2:1.1.1.16
	OPENBSD_5_7:1.18.0.2
	OPENBSD_5_7_BASE:1.18
	PERL_5_20_1:1.1.1.16
	OPENBSD_5_6:1.17.0.4
	OPENBSD_5_6_BASE:1.17
	PERL_5_18_2:1.1.1.15
	PERL:1.1.1
	OPENBSD_5_5:1.16.0.6
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.2
	OPENBSD_5_4_BASE:1.16
	PERL_5_16_3:1.1.1.14
	OPENBSD_5_3:1.15.0.10
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.8
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.6
	OPENBSD_5_0:1.15.0.4
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.2
	OPENBSD_4_9_BASE:1.15
	PERL_5_12_2:1.1.1.13
	OPENBSD_4_8:1.14.0.4
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.2
	OPENBSD_4_7_BASE:1.14
	PERL_5_10_1:1.1.1.12
	OPENBSD_4_6:1.13.0.6
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.2
	OPENBSD_4_5_BASE:1.13
	PERL_5_10_0:1.1.1.11
	OPENBSD_4_4:1.12.0.10
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.8
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.6
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.4
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.2
	OPENBSD_4_0_BASE:1.12
	PERL_5_8_8:1.1.1.10
	OPENBSD_3_9:1.11.0.6
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.4
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.2
	OPENBSD_3_7_BASE:1.11
	PERL_5_8_6:1.1.1.9
	OPENBSD_3_6:1.10.0.2
	OPENBSD_3_6_BASE:1.10
	PERL_5_8_5:1.1.1.8
	PERL_5_8_3:1.1.1.7
	OPENBSD_3_5:1.8.0.2
	OPENBSD_3_5_BASE:1.8
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.7.0.4
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.7.0.2
	OPENBSD_3_3_BASE:1.7
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.6.0.6
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.4
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.5.0.6
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.4
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.2
	OPENBSD_2_7_BASE:1.5
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.4.0.2
	OPENBSD_2_6_BASE:1.4
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.3.0.6
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.4
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.2
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.19
date	2017.02.05.00.31.52;	author afresh1;	state Exp;
branches;
next	1.18;
commitid	cxJ08BvJA9Pt2PTM;

1.18
date	2014.11.17.20.56.47;	author afresh1;	state Exp;
branches;
next	1.17;
commitid	QP75iYx42Uo7mMxO;

1.17
date	2014.03.24.15.05.13;	author afresh1;	state Exp;
branches;
next	1.16;

1.16
date	2013.03.25.20.40.44;	author sthen;	state Exp;
branches;
next	1.15;

1.15
date	2010.09.24.15.06.40;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2009.10.12.18.24.20;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2008.09.29.17.35.56;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2006.03.28.19.22.56;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2005.01.15.21.30.18;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2004.08.09.18.08.54;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2004.04.07.21.32.59;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2003.12.03.03.02.20;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.10.27.22.25.17;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.05.24.18.34.47;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2000.04.06.17.03.48;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	99.04.29.22.50.58;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	98.02.20.10.38.10;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.48.28;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.11.38;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.11.38;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.37.09;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.08.34;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.21.58;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.14.46;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.43.28;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.04.07.21.12.48;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.08.09.17.45.38;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2005.01.15.21.16.23;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2006.03.28.18.47.24;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2008.09.29.17.18.04;	author millert;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2009.10.12.18.10.36;	author millert;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2010.09.24.14.48.33;	author millert;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2013.03.25.20.06.21;	author sthen;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	2014.03.24.14.58.44;	author afresh1;	state Exp;
branches;
next	1.1.1.16;

1.1.1.16
date	2014.11.17.20.52.35;	author afresh1;	state Exp;
branches;
next	1.1.1.17;
commitid	B31cAbBIXiCqnL97;

1.1.1.17
date	2017.08.14.13.45.25;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.19
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@/*    doio.c
 *
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
 *    2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

/*
 *  Far below them they saw the white waters pour into a foaming bowl, and
 *  then swirl darkly about a deep oval basin in the rocks, until they found
 *  their way out again through a narrow gate, and flowed away, fuming and
 *  chattering, into calmer and more level reaches.
 *
 *     [p.684 of _The Lord of the Rings_, IV/vi: "The Forbidden Pool"]
 */

/* This file contains functions that do the actual I/O on behalf of ops.
 * For example, pp_print() calls the do_print() function in this file for
 * each argument needing printing.
 */

#include "EXTERN.h"
#define PERL_IN_DOIO_C
#include "perl.h"

#if defined(HAS_MSG) || defined(HAS_SEM) || defined(HAS_SHM)
#ifndef HAS_SEM
#include <sys/ipc.h>
#endif
#ifdef HAS_MSG
#include <sys/msg.h>
#endif
#ifdef HAS_SHM
#include <sys/shm.h>
# ifndef HAS_SHMAT_PROTOTYPE
    extern Shmat_t shmat (int, char *, int);
# endif
#endif
#endif

#ifdef I_UTIME
#  if defined(_MSC_VER) || defined(__MINGW32__)
#    include <sys/utime.h>
#  else
#    include <utime.h>
#  endif
#endif

#ifdef O_EXCL
#  define OPEN_EXCL O_EXCL
#else
#  define OPEN_EXCL 0
#endif

#define PERL_MODE_MAX 8
#define PERL_FLAGS_MAX 10

#include <signal.h>

static IO *
S_openn_setup(pTHX_ GV *gv, char *mode, PerlIO **saveifp, PerlIO **saveofp,
              int *savefd,  char *savetype)
{
    IO * const io = GvIOn(gv);

    PERL_ARGS_ASSERT_OPENN_SETUP;

    *saveifp = NULL;
    *saveofp = NULL;
    *savefd = -1;
    *savetype = IoTYPE_CLOSED;

    Zero(mode,sizeof(mode),char);
    PL_forkprocess = 1;		/* assume true if no fork */

    /* If currently open - close before we re-open */
    if (IoIFP(io)) {
	if (IoTYPE(io) == IoTYPE_STD) {
	    /* This is a clone of one of STD* handles */
	}
	else {
            const int old_fd = PerlIO_fileno(IoIFP(io));

            if (old_fd >= 0 && old_fd <= PL_maxsysfd) {
                /* This is one of the original STD* handles */
                *saveifp  = IoIFP(io);
                *saveofp  = IoOFP(io);
                *savetype = IoTYPE(io);
                *savefd   = old_fd;
            }
            else {
                int result;

                if (IoTYPE(io) == IoTYPE_PIPE)
                    result = PerlProc_pclose(IoIFP(io));
                else if (IoIFP(io) != IoOFP(io)) {
                    if (IoOFP(io)) {
                        result = PerlIO_close(IoOFP(io));
                        PerlIO_close(IoIFP(io)); /* clear stdio, fd already closed */
                    }
                    else
                        result = PerlIO_close(IoIFP(io));
                }
                else
                    result = PerlIO_close(IoIFP(io));

                if (result == EOF && old_fd > PL_maxsysfd) {
                    /* Why is this not Perl_warn*() call ? */
                    PerlIO_printf(Perl_error_log,
                                  "Warning: unable to close filehandle %"HEKf" properly.\n",
                                  HEKfARG(GvENAME_HEK(gv))
                        );
                }
            }
        }
	IoOFP(io) = IoIFP(io) = NULL;
    }
    return io;
}

bool
Perl_do_openn(pTHX_ GV *gv, const char *oname, I32 len, int as_raw,
	      int rawmode, int rawperm, PerlIO *supplied_fp, SV **svp,
	      I32 num_svs)
{
    PERL_ARGS_ASSERT_DO_OPENN;

    if (as_raw) {
        /* sysopen style args, i.e. integer mode and permissions */

	if (num_svs != 0) {
	    Perl_croak(aTHX_ "panic: sysopen with multiple args, num_svs=%ld",
		       (long) num_svs);
	}
        return do_open_raw(gv, oname, len, rawmode, rawperm);
    }
    return do_open6(gv, oname, len, supplied_fp, svp, num_svs);
}

bool
Perl_do_open_raw(pTHX_ GV *gv, const char *oname, STRLEN len,
                 int rawmode, int rawperm)
{
    PerlIO *saveifp;
    PerlIO *saveofp;
    int savefd;
    char savetype;
    char mode[PERL_MODE_MAX];	/* file mode ("r\0", "rb\0", "ab\0" etc.) */
    IO * const io = openn_setup(gv, mode, &saveifp, &saveofp, &savefd, &savetype);
    int writing = 0;
    PerlIO *fp;

    PERL_ARGS_ASSERT_DO_OPEN_RAW;

    /* For ease of blame back to 5.000, keep the existing indenting. */
    {
        /* sysopen style args, i.e. integer mode and permissions */
	STRLEN ix = 0;
	const int appendtrunc =
	     0
#ifdef O_APPEND	/* Not fully portable. */
	     |O_APPEND
#endif
#ifdef O_TRUNC	/* Not fully portable. */
	     |O_TRUNC
#endif
	     ;
	const int modifyingmode = O_WRONLY|O_RDWR|O_CREAT|appendtrunc;
	int ismodifying;
        SV *namesv;

	/* It's not always

	   O_RDONLY 0
	   O_WRONLY 1
	   O_RDWR   2

	   It might be (in OS/390 and Mac OS Classic it is)

	   O_WRONLY 1
	   O_RDONLY 2
	   O_RDWR   3

	   This means that simple & with O_RDWR would look
	   like O_RDONLY is present.  Therefore we have to
	   be more careful.
	*/
	if ((ismodifying = (rawmode & modifyingmode))) {
	     if ((ismodifying & O_WRONLY) == O_WRONLY ||
		 (ismodifying & O_RDWR)   == O_RDWR   ||
		 (ismodifying & (O_CREAT|appendtrunc)))
		  TAINT_PROPER("sysopen");
	}
	mode[ix++] = IoTYPE_NUMERIC; /* Marker to openn to use numeric "sysopen" */

#if defined(USE_64_BIT_RAWIO) && defined(O_LARGEFILE)
	rawmode |= O_LARGEFILE;	/* Transparently largefiley. */
#endif

        IoTYPE(io) = PerlIO_intmode2str(rawmode, &mode[ix], &writing);

	namesv = newSVpvn_flags(oname, len, SVs_TEMP);
	fp = PerlIO_openn(aTHX_ NULL, mode, -1, rawmode, rawperm, NULL, 1, &namesv);
    }
    return openn_cleanup(gv, io, fp, mode, oname, saveifp, saveofp, savefd,
                         savetype, writing, 0, NULL);
}

bool
Perl_do_open6(pTHX_ GV *gv, const char *oname, STRLEN len,
              PerlIO *supplied_fp, SV **svp, U32 num_svs)
{
    PerlIO *saveifp;
    PerlIO *saveofp;
    int savefd;
    char savetype;
    char mode[PERL_MODE_MAX];	/* file mode ("r\0", "rb\0", "ab\0" etc.) */
    IO * const io = openn_setup(gv, mode, &saveifp, &saveofp, &savefd, &savetype);
    int writing = 0;
    PerlIO *fp;
    bool was_fdopen = FALSE;
    char *type  = NULL;

    PERL_ARGS_ASSERT_DO_OPEN6;

    /* For ease of blame back to 5.000, keep the existing indenting. */
    {
	/* Regular (non-sys) open */
	char *name;
	STRLEN olen = len;
	char *tend;
	int dodup = 0;
        bool in_raw = 0, in_crlf = 0, out_raw = 0, out_crlf = 0;

        /* Collect default raw/crlf info from the op */
        if (PL_op && PL_op->op_type == OP_OPEN) {
            /* set up IO layers */
            const U8 flags = PL_op->op_private;
            in_raw = (flags & OPpOPEN_IN_RAW);
            in_crlf = (flags & OPpOPEN_IN_CRLF);
            out_raw = (flags & OPpOPEN_OUT_RAW);
            out_crlf = (flags & OPpOPEN_OUT_CRLF);
        }

	type = savepvn(oname, len);
	tend = type+len;
	SAVEFREEPV(type);

        /* Lose leading and trailing white space */
	while (isSPACE(*type))
	    type++;
        while (tend > type && isSPACE(tend[-1]))
	    *--tend = '\0';

	if (num_svs) {
            const char *p;
            STRLEN nlen = 0;
	    /* New style explicit name, type is just mode and layer info */
#ifdef USE_STDIO
	    if (SvROK(*svp) && !strchr(oname,'&')) {
		if (ckWARN(WARN_IO))
		    Perl_warner(aTHX_ packWARN(WARN_IO),
			    "Can't open a reference");
		SETERRNO(EINVAL, LIB_INVARG);
                fp = NULL;
		goto say_false;
	    }
#endif /* USE_STDIO */
            p = (SvOK(*svp) || SvGMAGICAL(*svp)) ? SvPV(*svp, nlen) : NULL;

            if (p && !IS_SAFE_PATHNAME(p, nlen, "open")) {
                fp = NULL;
                goto say_false;
            }

	    name = p ? savepvn(p, nlen) : savepvs("");

	    SAVEFREEPV(name);
	}
	else {
	    name = type;
	    len  = tend-type;
	}
	IoTYPE(io) = *type;
	if ((*type == IoTYPE_RDWR) && /* scary */
           (*(type+1) == IoTYPE_RDONLY || *(type+1) == IoTYPE_WRONLY) &&
	    ((!num_svs || (tend > type+1 && tend[-1] != IoTYPE_PIPE)))) {
	    TAINT_PROPER("open");
	    mode[1] = *type++;
	    writing = 1;
	}

	if (*type == IoTYPE_PIPE) {
	    if (num_svs) {
		if (type[1] != IoTYPE_STD) {
	          unknown_open_mode:
		    Perl_croak(aTHX_ "Unknown open() mode '%.*s'", (int)olen, oname);
		}
		type++;
	    }
	    do {
		type++;
	    } while (isSPACE(*type));
	    if (!num_svs) {
		name = type;
		len = tend-type;
	    }
	    if (*name == '\0') {
		/* command is missing 19990114 */
		if (ckWARN(WARN_PIPE))
		    Perl_warner(aTHX_ packWARN(WARN_PIPE), "Missing command in piped open");
		errno = EPIPE;
                fp = NULL;
		goto say_false;
	    }
	    if (!(*name == '-' && name[1] == '\0') || num_svs)
		TAINT_ENV();
	    TAINT_PROPER("piped open");
	    if (!num_svs && name[len-1] == '|') {
		name[--len] = '\0' ;
		if (ckWARN(WARN_PIPE))
		    Perl_warner(aTHX_ packWARN(WARN_PIPE), "Can't open bidirectional pipe");
	    }
	    mode[0] = 'w';
	    writing = 1;
            if (out_raw)
		mode[1] = 'b';
            else if (out_crlf)
		mode[1] = 't';
	    if (num_svs > 1) {
		fp = PerlProc_popen_list(mode, num_svs, svp);
	    }
	    else {
		fp = PerlProc_popen(name,mode);
	    }
	    if (num_svs) {
		if (*type) {
		    if (PerlIO_apply_layers(aTHX_ fp, mode, type) != 0) {
                        fp = NULL;
			goto say_false;
		    }
		}
	    }
	} /* IoTYPE_PIPE */
	else if (*type == IoTYPE_WRONLY) {
	    TAINT_PROPER("open");
	    type++;
	    if (*type == IoTYPE_WRONLY) {
		/* Two IoTYPE_WRONLYs in a row make for an IoTYPE_APPEND. */
		mode[0] = IoTYPE(io) = IoTYPE_APPEND;
		type++;
	    }
	    else {
		mode[0] = 'w';
	    }
	    writing = 1;

            if (out_raw)
		mode[1] = 'b';
            else if (out_crlf)
		mode[1] = 't';
	    if (*type == '&') {
	      duplicity:
		dodup = PERLIO_DUP_FD;
		type++;
		if (*type == '=') {
		    dodup = 0;
		    type++;
		}
		if (!num_svs && !*type && supplied_fp) {
		    /* "<+&" etc. is used by typemaps */
		    fp = supplied_fp;
		}
		else {
		    PerlIO *that_fp = NULL;
                    int wanted_fd;
                    UV uv;
		    if (num_svs > 1) {
			/* diag_listed_as: More than one argument to '%s' open */
			Perl_croak(aTHX_ "More than one argument to '%c&' open",IoTYPE(io));
		    }
		    while (isSPACE(*type))
			type++;
		    if (num_svs && (
			     SvIOK(*svp)
			  || (SvPOKp(*svp) && looks_like_number(*svp))
		       )) {
                        wanted_fd = SvUV(*svp);
			num_svs = 0;
		    }
		    else if (isDIGIT(*type)
                        && grok_atoUV(type, &uv, NULL)
                        && uv <= INT_MAX
                    ) {
                        wanted_fd = (int)uv;
		    }
		    else {
			const IO* thatio;
			if (num_svs) {
			    thatio = sv_2io(*svp);
			}
			else {
			    GV * const thatgv = gv_fetchpvn_flags(type, tend - type,
						       0, SVt_PVIO);
			    thatio = GvIO(thatgv);
			}
			if (!thatio) {
#ifdef EINVAL
			    SETERRNO(EINVAL,SS_IVCHAN);
#endif
                            fp = NULL;
			    goto say_false;
			}
			if ((that_fp = IoIFP(thatio))) {
			    /* Flush stdio buffer before dup. --mjd
			     * Unfortunately SEEK_CURing 0 seems to
			     * be optimized away on most platforms;
			     * only Solaris and Linux seem to flush
			     * on that. --jhi */
			    /* On the other hand, do all platforms
			     * take gracefully to flushing a read-only
			     * filehandle?  Perhaps we should do
			     * fsetpos(src)+fgetpos(dst)?  --nik */
			    PerlIO_flush(that_fp);
			    wanted_fd = PerlIO_fileno(that_fp);
			    /* When dup()ing STDIN, STDOUT or STDERR
			     * explicitly set appropriate access mode */
			    if (that_fp == PerlIO_stdout()
				|| that_fp == PerlIO_stderr())
			        IoTYPE(io) = IoTYPE_WRONLY;
			    else if (that_fp == PerlIO_stdin())
                                IoTYPE(io) = IoTYPE_RDONLY;
			    /* When dup()ing a socket, say result is
			     * one as well */
			    else if (IoTYPE(thatio) == IoTYPE_SOCKET)
				IoTYPE(io) = IoTYPE_SOCKET;
			}
                        else {
                            SETERRNO(EBADF, RMS_IFI);
                            fp = NULL;
                            goto say_false;
                        }
		    }
		    if (!num_svs)
			type = NULL;
		    if (that_fp) {
			fp = PerlIO_fdupopen(aTHX_ that_fp, NULL, dodup);
		    }
		    else {
			if (dodup)
                            wanted_fd = PerlLIO_dup(wanted_fd);
			else
			    was_fdopen = TRUE;
                        if (!(fp = PerlIO_openn(aTHX_ type,mode,wanted_fd,0,0,NULL,num_svs,svp))) {
                            if (dodup && wanted_fd >= 0)
                                PerlLIO_close(wanted_fd);
			}
		    }
		}
	    } /* & */
	    else {
		while (isSPACE(*type))
		    type++;
		if (*type == IoTYPE_STD && (!type[1] || isSPACE(type[1]) || type[1] == ':')) {
		    type++;
		    fp = PerlIO_stdout();
		    IoTYPE(io) = IoTYPE_STD;
		    if (num_svs > 1) {
			/* diag_listed_as: More than one argument to '%s' open */
			Perl_croak(aTHX_ "More than one argument to '>%c' open",IoTYPE_STD);
		    }
		}
		else  {
		    if (num_svs) {
                        fp = PerlIO_openn(aTHX_ type,mode,-1,0,0,NULL,num_svs,svp);
                    }
                    else {
                        SV *namesv = newSVpvn_flags(type, tend - type, SVs_TEMP);
		        type = NULL;
                        fp = PerlIO_openn(aTHX_ type,mode,-1,0,0,NULL,1,&namesv);
		    }
		}
	    } /* !& */
	    if (!fp && type && *type && *type != ':' && !isIDFIRST(*type))
	       goto unknown_open_mode;
	} /* IoTYPE_WRONLY */
	else if (*type == IoTYPE_RDONLY) {
	    do {
		type++;
	    } while (isSPACE(*type));
	    mode[0] = 'r';
            if (in_raw)
		mode[1] = 'b';
            else if (in_crlf)
		mode[1] = 't';
	    if (*type == '&') {
		goto duplicity;
	    }
	    if (*type == IoTYPE_STD && (!type[1] || isSPACE(type[1]) || type[1] == ':')) {
		type++;
		fp = PerlIO_stdin();
		IoTYPE(io) = IoTYPE_STD;
		if (num_svs > 1) {
		    /* diag_listed_as: More than one argument to '%s' open */
		    Perl_croak(aTHX_ "More than one argument to '<%c' open",IoTYPE_STD);
		}
	    }
	    else {
		if (num_svs) {
                    fp = PerlIO_openn(aTHX_ type,mode,-1,0,0,NULL,num_svs,svp);
                }
                else {
                    SV *namesv  = newSVpvn_flags(type, tend - type, SVs_TEMP);
		    type = NULL;
                    fp = PerlIO_openn(aTHX_ type,mode,-1,0,0,NULL,1,&namesv);
		}
	    }
	    if (!fp && type && *type && *type != ':' && !isIDFIRST(*type))
	       goto unknown_open_mode;
	} /* IoTYPE_RDONLY */
	else if ((num_svs && /* '-|...' or '...|' */
		  type[0] == IoTYPE_STD && type[1] == IoTYPE_PIPE) ||
	         (!num_svs && tend > type+1 && tend[-1] == IoTYPE_PIPE)) {
	    if (num_svs) {
		type += 2;   /* skip over '-|' */
	    }
	    else {
		*--tend = '\0';
		while (tend > type && isSPACE(tend[-1]))
		    *--tend = '\0';
		for (; isSPACE(*type); type++)
		    ;
		name = type;
	        len  = tend-type;
	    }
	    if (*name == '\0') {
		/* command is missing 19990114 */
		if (ckWARN(WARN_PIPE))
		    Perl_warner(aTHX_ packWARN(WARN_PIPE), "Missing command in piped open");
		errno = EPIPE;
                fp = NULL;
		goto say_false;
	    }
	    if (!(*name == '-' && name[1] == '\0') || num_svs)
		TAINT_ENV();
	    TAINT_PROPER("piped open");
	    mode[0] = 'r';

            if (in_raw)
		mode[1] = 'b';
            else if (in_crlf)
		mode[1] = 't';

	    if (num_svs > 1) {
		fp = PerlProc_popen_list(mode,num_svs,svp);
	    }
	    else {
		fp = PerlProc_popen(name,mode);
	    }
	    IoTYPE(io) = IoTYPE_PIPE;
	    if (num_svs) {
		while (isSPACE(*type))
		    type++;
		if (*type) {
		    if (PerlIO_apply_layers(aTHX_ fp, mode, type) != 0) {
                        fp = NULL;
			goto say_false;
		    }
		}
	    }
	}
	else { /* layer(Args) */
	    if (num_svs)
		goto unknown_open_mode;
	    name = type;
	    IoTYPE(io) = IoTYPE_RDONLY;
	    for (; isSPACE(*name); name++)
		;
	    mode[0] = 'r';

            if (in_raw)
		mode[1] = 'b';
            else if (in_crlf)
		mode[1] = 't';

	    if (*name == '-' && name[1] == '\0') {
		fp = PerlIO_stdin();
		IoTYPE(io) = IoTYPE_STD;
	    }
	    else {
		if (num_svs) {
                    fp = PerlIO_openn(aTHX_ type,mode,-1,0,0,NULL,num_svs,svp);
                }
                else {
		    SV *namesv = newSVpvn_flags(type, tend - type, SVs_TEMP);
		    type = NULL;
                    fp = PerlIO_openn(aTHX_ type,mode,-1,0,0,NULL,1,&namesv);
		}
	    }
	}
    }

  say_false:
    return openn_cleanup(gv, io, fp, mode, oname, saveifp, saveofp, savefd,
                         savetype, writing, was_fdopen, type);
}

/* Yes, this is ugly, but it's private, and I don't see a cleaner way to
   simplify the two-headed public interface of do_openn. */
static bool
S_openn_cleanup(pTHX_ GV *gv, IO *io, PerlIO *fp, char *mode, const char *oname,
                PerlIO *saveifp, PerlIO *saveofp, int savefd, char savetype,
                int writing, bool was_fdopen, const char *type)
{
    int fd;

    PERL_ARGS_ASSERT_OPENN_CLEANUP;

    if (!fp) {
	if (IoTYPE(io) == IoTYPE_RDONLY && ckWARN(WARN_NEWLINE)
	    && should_warn_nl(oname)
	    
	)
        {
            GCC_DIAG_IGNORE(-Wformat-nonliteral); /* PL_warn_nl is constant */
	    Perl_warner(aTHX_ packWARN(WARN_NEWLINE), PL_warn_nl, "open");
            GCC_DIAG_RESTORE;
        }
	goto say_false;
    }

    if (ckWARN(WARN_IO)) {
	if ((IoTYPE(io) == IoTYPE_RDONLY) &&
	    (fp == PerlIO_stdout() || fp == PerlIO_stderr())) {
		Perl_warner(aTHX_ packWARN(WARN_IO),
			    "Filehandle STD%s reopened as %"HEKf
			    " only for input",
			    ((fp == PerlIO_stdout()) ? "OUT" : "ERR"),
			    HEKfARG(GvENAME_HEK(gv)));
	}
	else if ((IoTYPE(io) == IoTYPE_WRONLY) && fp == PerlIO_stdin()) {
		Perl_warner(aTHX_ packWARN(WARN_IO),
		    "Filehandle STDIN reopened as %"HEKf" only for output",
		     HEKfARG(GvENAME_HEK(gv))
		);
	}
    }

    fd = PerlIO_fileno(fp);
    /* Do NOT do: "if (fd < 0) goto say_false;" here.  If there is no
     * fd assume it isn't a socket - this covers PerlIO::scalar -
     * otherwise unless we "know" the type probe for socket-ness.
     */
    if (IoTYPE(io) && IoTYPE(io) != IoTYPE_PIPE && IoTYPE(io) != IoTYPE_STD && fd >= 0) {
	if (PerlLIO_fstat(fd,&PL_statbuf) < 0) {
	    /* If PerlIO claims to have fd we had better be able to fstat() it. */
	    (void) PerlIO_close(fp);
	    goto say_false;
	}
#ifndef PERL_MICRO
	if (S_ISSOCK(PL_statbuf.st_mode))
	    IoTYPE(io) = IoTYPE_SOCKET;	/* in case a socket was passed in to us */
#ifdef HAS_SOCKET
	else if (
	    !(PL_statbuf.st_mode & S_IFMT)
	    && IoTYPE(io) != IoTYPE_WRONLY  /* Dups of STD* filehandles already have */
	    && IoTYPE(io) != IoTYPE_RDONLY  /* type so they aren't marked as sockets */
	) {				    /* on OS's that return 0 on fstat()ed pipe */
	     char tmpbuf[256];
	     Sock_size_t buflen = sizeof tmpbuf;
	     if (PerlSock_getsockname(fd, (struct sockaddr *)tmpbuf, &buflen) >= 0
		      || errno != ENOTSOCK)
		    IoTYPE(io) = IoTYPE_SOCKET; /* some OS's return 0 on fstat()ed socket */
				                /* but some return 0 for streams too, sigh */
	}
#endif /* HAS_SOCKET */
#endif /* !PERL_MICRO */
    }

    /* Eeek - FIXME !!!
     * If this is a standard handle we discard all the layer stuff
     * and just dup the fd into whatever was on the handle before !
     */

    if (saveifp) {		/* must use old fp? */
        /* If fd is less that PL_maxsysfd i.e. STDIN..STDERR
           then dup the new fileno down
         */
	if (saveofp) {
	    PerlIO_flush(saveofp);	/* emulate PerlIO_close() */
	    if (saveofp != saveifp) {	/* was a socket? */
		PerlIO_close(saveofp);
	    }
	}
	if (savefd != fd) {
	    /* Still a small can-of-worms here if (say) PerlIO::scalar
	       is assigned to (say) STDOUT - for now let dup2() fail
	       and provide the error
	     */
	    if (fd < 0) {
                SETERRNO(EBADF,RMS_IFI);
		goto say_false;
            } else if (PerlLIO_dup2(fd, savefd) < 0) {
		(void)PerlIO_close(fp);
		goto say_false;
	    }
#ifdef VMS
	    if (savefd != PerlIO_fileno(PerlIO_stdin())) {
                char newname[FILENAME_MAX+1];
                if (PerlIO_getname(fp, newname)) {
                    if (fd == PerlIO_fileno(PerlIO_stdout()))
                        vmssetuserlnm("SYS$OUTPUT", newname);
                    if (fd == PerlIO_fileno(PerlIO_stderr()))
                        vmssetuserlnm("SYS$ERROR", newname);
                }
	    }
#endif

#if !defined(WIN32)
           /* PL_fdpid isn't used on Windows, so avoid this useless work.
            * XXX Probably the same for a lot of other places. */
            {
                Pid_t pid;
                SV *sv;

                sv = *av_fetch(PL_fdpid,fd,TRUE);
                SvUPGRADE(sv, SVt_IV);
                pid = SvIVX(sv);
                SvIV_set(sv, 0);
                sv = *av_fetch(PL_fdpid,savefd,TRUE);
                SvUPGRADE(sv, SVt_IV);
                SvIV_set(sv, pid);
            }
#endif

	    if (was_fdopen) {
                /* need to close fp without closing underlying fd */
                int ofd = PerlIO_fileno(fp);
                int dupfd = ofd >= 0 ? PerlLIO_dup(ofd) : -1;
#if defined(HAS_FCNTL) && defined(F_SETFD)
		/* Assume if we have F_SETFD we have F_GETFD. */
                /* Get a copy of all the fd flags. */
                int fd_flags = ofd >= 0 ? fcntl(ofd, F_GETFD) : -1;
                if (fd_flags < 0) {
                    if (dupfd >= 0)
                        PerlLIO_close(dupfd);
                    goto say_false;
                }
#endif
                if (ofd < 0 || dupfd < 0) {
                    if (dupfd >= 0)
                        PerlLIO_close(dupfd);
                    goto say_false;
                }
                PerlIO_close(fp);
                PerlLIO_dup2(dupfd, ofd);
#if defined(HAS_FCNTL) && defined(F_SETFD)
		/* The dup trick has lost close-on-exec on ofd,
                 * and possibly any other flags, so restore them. */
		fcntl(ofd,F_SETFD, fd_flags);
#endif
                PerlLIO_close(dupfd);
	    }
            else
		PerlIO_close(fp);
	}
	fp = saveifp;
	PerlIO_clearerr(fp);
	fd = PerlIO_fileno(fp);
    }
#if defined(HAS_FCNTL) && defined(F_SETFD) && defined(FD_CLOEXEC)
    if (fd >= 0 && fd > PL_maxsysfd && fcntl(fd, F_SETFD, FD_CLOEXEC) < 0) {
        PerlLIO_close(fd);
        goto say_false;
    }
#endif
    IoIFP(io) = fp;

    IoFLAGS(io) &= ~IOf_NOLINE;
    if (writing) {
	if (IoTYPE(io) == IoTYPE_SOCKET
	    || (IoTYPE(io) == IoTYPE_WRONLY && fd >= 0 && S_ISCHR(PL_statbuf.st_mode)) ) {
	    char *s = mode;
	    if (*s == IoTYPE_IMPLICIT || *s == IoTYPE_NUMERIC)
	      s++;
	    *s = 'w';
	    if (!(IoOFP(io) = PerlIO_openn(aTHX_ type,s,fd,0,0,NULL,0,NULL))) {
		PerlIO_close(fp);
		goto say_false;
	    }
	}
	else
	    IoOFP(io) = fp;
    }
    return TRUE;

  say_false:
    IoIFP(io) = saveifp;
    IoOFP(io) = saveofp;
    IoTYPE(io) = savetype;
    return FALSE;
}

PerlIO *
Perl_nextargv(pTHX_ GV *gv, bool nomagicopen)
{
    IO * const io = GvIOp(gv);
    SV *const old_out_name = PL_inplace ? newSVsv(GvSV(gv)) : NULL;

    PERL_ARGS_ASSERT_NEXTARGV;

    if (old_out_name)
        SAVEFREESV(old_out_name);

    if (!PL_argvoutgv)
	PL_argvoutgv = gv_fetchpvs("ARGVOUT", GV_ADD|GV_NOTQUAL, SVt_PVIO);
    if (io && (IoFLAGS(io) & (IOf_ARGV|IOf_START)) == (IOf_ARGV|IOf_START)) {
	IoFLAGS(io) &= ~IOf_START;
	if (PL_inplace) {
	    assert(PL_defoutgv);
	    Perl_av_create_and_push(aTHX_ &PL_argvout_stack,
				    SvREFCNT_inc_simple_NN(PL_defoutgv));
	}
    }
    if (PL_filemode & (S_ISUID|S_ISGID)) {
	PerlIO_flush(IoIFP(GvIOn(PL_argvoutgv)));  /* chmod must follow last write */
#ifdef HAS_FCHMOD
	if (PL_lastfd != -1)
	    (void)fchmod(PL_lastfd,PL_filemode);
#else
	(void)PerlLIO_chmod(PL_oldname,PL_filemode);
#endif
    }
    PL_lastfd = -1;
    PL_filemode = 0;
    if (!GvAV(gv))
	return NULL;
    while (av_tindex(GvAV(gv)) >= 0) {
	Stat_t statbuf;
	STRLEN oldlen;
        SV *const sv = av_shift(GvAV(gv));
	SAVEFREESV(sv);
	SvTAINTED_off(GvSVn(gv)); /* previous tainting irrelevant */
	sv_setsv(GvSVn(gv),sv);
	SvSETMAGIC(GvSV(gv));
	PL_oldname = SvPVx(GvSV(gv), oldlen);
        if (LIKELY(!PL_inplace)) {
            if (nomagicopen
                    ? do_open6(gv, "<", 1, NULL, &GvSV(gv), 1)
                    : do_open6(gv, PL_oldname, oldlen, NULL, NULL, 0)
               ) {
                return IoIFP(GvIOp(gv));
            }
        }
        else {
            {
                IO * const io = GvIOp(PL_argvoutgv);
                if (io && IoIFP(io) && old_out_name && !io_close(io, PL_argvoutgv, FALSE, FALSE)) {
                    Perl_croak(aTHX_ "Failed to close in-place edit file %"SVf": %s\n",
                               old_out_name, Strerror(errno));
                }
            }
            /* This very long block ends with return IoIFP(GvIOp(gv));
               Both this block and the block above fall through on open
               failure to the warning code, and then the while loop above tries
               the next entry. */
            if (do_open_raw(gv, PL_oldname, oldlen, O_RDONLY, 0)) {
#ifndef FLEXFILENAMES
                int filedev;
                int fileino;
#endif
                Uid_t fileuid;
                Gid_t filegid;

		TAINT_PROPER("inplace open");
		if (oldlen == 1 && *PL_oldname == '-') {
		    setdefout(gv_fetchpvs("STDOUT", GV_ADD|GV_NOTQUAL,
					  SVt_PVIO));
		    return IoIFP(GvIOp(gv));
		}
#ifndef FLEXFILENAMES
		filedev = PL_statbuf.st_dev;
		fileino = PL_statbuf.st_ino;
#endif
		PL_filemode = PL_statbuf.st_mode;
		fileuid = PL_statbuf.st_uid;
		filegid = PL_statbuf.st_gid;
		if (!S_ISREG(PL_filemode)) {
		    Perl_ck_warner_d(aTHX_ packWARN(WARN_INPLACE),
				     "Can't do inplace edit: %s is not a regular file",
				     PL_oldname );
		    do_close(gv,FALSE);
		    continue;
		}
		if (*PL_inplace && strNE(PL_inplace, "*")) {
		    const char *star = strchr(PL_inplace, '*');
		    if (star) {
			const char *begin = PL_inplace;
			sv_setpvs(sv, "");
			do {
			    sv_catpvn(sv, begin, star - begin);
			    sv_catpvn(sv, PL_oldname, oldlen);
			    begin = ++star;
			} while ((star = strchr(begin, '*')));
			if (*begin)
			    sv_catpv(sv,begin);
		    }
		    else {
			sv_catpv(sv,PL_inplace);
		    }
#ifndef FLEXFILENAMES
		    if ((PerlLIO_stat(SvPVX_const(sv),&PL_statbuf) >= 0
			 && PL_statbuf.st_dev == filedev
			 && PL_statbuf.st_ino == fileino)
#ifdef DJGPP
			|| ((_djstat_fail_bits & _STFAIL_TRUENAME)!=0)
#endif
                      )
		    {
			Perl_ck_warner_d(aTHX_ packWARN(WARN_INPLACE),
					 "Can't do inplace edit: %"SVf" would not be unique",
					 SVfARG(sv));
			do_close(gv,FALSE);
			continue;
		    }
#endif
#ifdef HAS_RENAME
#if !defined(DOSISH) && !defined(__CYGWIN__)
		    if (PerlLIO_rename(PL_oldname,SvPVX_const(sv)) < 0) {
			Perl_ck_warner_d(aTHX_ packWARN(WARN_INPLACE),
					 "Can't rename %s to %"SVf": %s, skipping file",
					 PL_oldname, SVfARG(sv), Strerror(errno));
			do_close(gv,FALSE);
			continue;
		    }
#else
		    do_close(gv,FALSE);
		    (void)PerlLIO_unlink(SvPVX_const(sv));
		    (void)PerlLIO_rename(PL_oldname,SvPVX_const(sv));
		    do_open_raw(gv, SvPVX_const(sv), SvCUR(sv), O_RDONLY, 0);
#endif /* DOSISH */
#else
		    (void)UNLINK(SvPVX_const(sv));
		    if (link(PL_oldname,SvPVX_const(sv)) < 0) {
			Perl_ck_warner_d(aTHX_ packWARN(WARN_INPLACE),
					 "Can't rename %s to %"SVf": %s, skipping file",
					 PL_oldname, SVfARG(sv), Strerror(errno) );
			do_close(gv,FALSE);
			continue;
		    }
		    (void)UNLINK(PL_oldname);
#endif
		}
		else {
#if !defined(DOSISH) && !defined(__amigaos4__)
#  ifndef VMS  /* Don't delete; use automatic file versioning */
		    if (UNLINK(PL_oldname) < 0) {
			Perl_ck_warner_d(aTHX_ packWARN(WARN_INPLACE),
					 "Can't remove %s: %s, skipping file",
					 PL_oldname, Strerror(errno) );
			do_close(gv,FALSE);
			continue;
		    }
#  endif
#else
		    Perl_croak(aTHX_ "Can't do inplace edit without backup");
#endif
		}

		sv_setpvn(sv,PL_oldname,oldlen);
		SETERRNO(0,0);		/* in case sprintf set errno */
		if (!Perl_do_open_raw(aTHX_ PL_argvoutgv, SvPVX_const(sv),
                                      SvCUR(sv),
#ifdef VMS
                                      O_WRONLY|O_CREAT|O_TRUNC, 0
#else
                                      O_WRONLY|O_CREAT|OPEN_EXCL, 0600
#endif
                        )) {
		    Perl_ck_warner_d(aTHX_ packWARN(WARN_INPLACE), "Can't do inplace edit on %s: %s",
				     PL_oldname, Strerror(errno) );
		    do_close(gv,FALSE);
		    continue;
		}
		setdefout(PL_argvoutgv);
		PL_lastfd = PerlIO_fileno(IoIFP(GvIOp(PL_argvoutgv)));
                if (PL_lastfd >= 0) {
                    (void)PerlLIO_fstat(PL_lastfd,&statbuf);
#ifdef HAS_FCHMOD
                    (void)fchmod(PL_lastfd,PL_filemode);
#else
                    (void)PerlLIO_chmod(PL_oldname,PL_filemode);
#endif
                    if (fileuid != statbuf.st_uid || filegid != statbuf.st_gid) {
                        /* XXX silently ignore failures */
#ifdef HAS_FCHOWN
                        PERL_UNUSED_RESULT(fchown(PL_lastfd,fileuid,filegid));
#else
#ifdef HAS_CHOWN
                        PERL_UNUSED_RESULT(PerlLIO_chown(PL_oldname,fileuid,filegid));
#endif
#endif
                    }
		}
                return IoIFP(GvIOp(gv));
	    }
	} /* successful do_open_raw(), PL_inplace non-NULL */

        if (ckWARN_d(WARN_INPLACE)) {
            const int eno = errno;
            if (PerlLIO_stat(PL_oldname, &statbuf) >= 0
                && !S_ISREG(statbuf.st_mode)) {
                Perl_warner(aTHX_ packWARN(WARN_INPLACE),
                            "Can't do inplace edit: %s is not a regular file",
                            PL_oldname);
            }
            else {
                Perl_warner(aTHX_ packWARN(WARN_INPLACE), "Can't open %s: %s",
                            PL_oldname, Strerror(eno));
            }
	}
    }
    if (io && (IoFLAGS(io) & IOf_ARGV))
	IoFLAGS(io) |= IOf_START;
    if (PL_inplace) {
        if (old_out_name) {
            IO * const io = GvIOp(PL_argvoutgv);
            if (io && IoIFP(io) && !io_close(io, PL_argvoutgv, FALSE, FALSE)) {
                Perl_croak(aTHX_ "Failed to close in-place edit file %"SVf": %s\n",
                           old_out_name, Strerror(errno));
            }
        }
        else {
            /* maybe this is no longer wanted */
            (void)do_close(PL_argvoutgv,FALSE);
        }
	if (io && (IoFLAGS(io) & IOf_ARGV)
	    && PL_argvout_stack && AvFILLp(PL_argvout_stack) >= 0)
	{
	    GV * const oldout = MUTABLE_GV(av_pop(PL_argvout_stack));
	    setdefout(oldout);
	    SvREFCNT_dec_NN(oldout);
	    return NULL;
	}
	setdefout(gv_fetchpvs("STDOUT", GV_ADD|GV_NOTQUAL, SVt_PVIO));
    }
    return NULL;
}

/* explicit renamed to avoid C++ conflict    -- kja */
bool
Perl_do_close(pTHX_ GV *gv, bool not_implicit)
{
    bool retval;
    IO *io;

    if (!gv)
	gv = PL_argvgv;
    if (!gv || !isGV_with_GP(gv)) {
	if (not_implicit)
	    SETERRNO(EBADF,SS_IVCHAN);
	return FALSE;
    }
    io = GvIO(gv);
    if (!io) {		/* never opened */
	if (not_implicit) {
	    report_evil_fh(gv);
	    SETERRNO(EBADF,SS_IVCHAN);
	}
	return FALSE;
    }
    retval = io_close(io, NULL, not_implicit, FALSE);
    if (not_implicit) {
	IoLINES(io) = 0;
	IoPAGE(io) = 0;
	IoLINES_LEFT(io) = IoPAGE_LEN(io);
    }
    IoTYPE(io) = IoTYPE_CLOSED;
    return retval;
}

bool
Perl_io_close(pTHX_ IO *io, GV *gv, bool not_implicit, bool warn_on_fail)
{
    bool retval = FALSE;

    PERL_ARGS_ASSERT_IO_CLOSE;

    if (IoIFP(io)) {
	if (IoTYPE(io) == IoTYPE_PIPE) {
	    const int status = PerlProc_pclose(IoIFP(io));
	    if (not_implicit) {
		STATUS_NATIVE_CHILD_SET(status);
		retval = (STATUS_UNIX == 0);
	    }
	    else {
		retval = (status != -1);
	    }
	}
	else if (IoTYPE(io) == IoTYPE_STD)
	    retval = TRUE;
	else {
	    if (IoOFP(io) && IoOFP(io) != IoIFP(io)) {		/* a socket */
		const bool prev_err = PerlIO_error(IoOFP(io));
#ifdef USE_PERLIO
		if (prev_err)
		    PerlIO_restore_errno(IoOFP(io));
#endif
		retval = (PerlIO_close(IoOFP(io)) != EOF && !prev_err);
		PerlIO_close(IoIFP(io));	/* clear stdio, fd already closed */
	    }
	    else {
		const bool prev_err = PerlIO_error(IoIFP(io));
#ifdef USE_PERLIO
		if (prev_err)
		    PerlIO_restore_errno(IoIFP(io));
#endif
		retval = (PerlIO_close(IoIFP(io)) != EOF && !prev_err);
	    }
	}
	IoOFP(io) = IoIFP(io) = NULL;

	if (warn_on_fail && !retval) {
	    if (gv)
		Perl_ck_warner_d(aTHX_ packWARN(WARN_IO),
				"Warning: unable to close filehandle %"
				 HEKf" properly: %"SVf,
				 HEKfARG(GvNAME_HEK(gv)),
                                 SVfARG(get_sv("!",GV_ADD)));
	    else
		Perl_ck_warner_d(aTHX_ packWARN(WARN_IO),
				"Warning: unable to close filehandle "
				"properly: %"SVf,
				 SVfARG(get_sv("!",GV_ADD)));
	}
    }
    else if (not_implicit) {
	SETERRNO(EBADF,SS_IVCHAN);
    }

    return retval;
}

bool
Perl_do_eof(pTHX_ GV *gv)
{
    IO * const io = GvIO(gv);

    PERL_ARGS_ASSERT_DO_EOF;

    if (!io)
	return TRUE;
    else if (IoTYPE(io) == IoTYPE_WRONLY)
	report_wrongway_fh(gv, '>');

    while (IoIFP(io)) {
        if (PerlIO_has_cntptr(IoIFP(io))) {	/* (the code works without this) */
	    if (PerlIO_get_cnt(IoIFP(io)) > 0)	/* cheat a little, since */
		return FALSE;			/* this is the most usual case */
        }

	{
	     /* getc and ungetc can stomp on errno */
	    dSAVE_ERRNO;
	    const int ch = PerlIO_getc(IoIFP(io));
	    if (ch != EOF) {
		(void)PerlIO_ungetc(IoIFP(io),ch);
		RESTORE_ERRNO;
		return FALSE;
	    }
	    RESTORE_ERRNO;
	}

        if (PerlIO_has_cntptr(IoIFP(io)) && PerlIO_canset_cnt(IoIFP(io))) {
	    if (PerlIO_get_cnt(IoIFP(io)) < -1)
		PerlIO_set_cnt(IoIFP(io),-1);
	}
	if (PL_op->op_flags & OPf_SPECIAL) { /* not necessarily a real EOF yet? */
	    if (gv != PL_argvgv || !nextargv(gv, FALSE))	/* get another fp handy */
		return TRUE;
	}
	else
	    return TRUE;		/* normal fp, definitely end of file */
    }
    return TRUE;
}

Off_t
Perl_do_tell(pTHX_ GV *gv)
{
    IO *const io = GvIO(gv);
    PerlIO *fp;

    PERL_ARGS_ASSERT_DO_TELL;

    if (io && (fp = IoIFP(io))) {
	return PerlIO_tell(fp);
    }
    report_evil_fh(gv);
    SETERRNO(EBADF,RMS_IFI);
    return (Off_t)-1;
}

bool
Perl_do_seek(pTHX_ GV *gv, Off_t pos, int whence)
{
    IO *const io = GvIO(gv);
    PerlIO *fp;

    if (io && (fp = IoIFP(io))) {
	return PerlIO_seek(fp, pos, whence) >= 0;
    }
    report_evil_fh(gv);
    SETERRNO(EBADF,RMS_IFI);
    return FALSE;
}

Off_t
Perl_do_sysseek(pTHX_ GV *gv, Off_t pos, int whence)
{
    IO *const io = GvIO(gv);
    PerlIO *fp;

    PERL_ARGS_ASSERT_DO_SYSSEEK;

    if (io && (fp = IoIFP(io))) {
        int fd = PerlIO_fileno(fp);
        if (fd < 0 || (whence == SEEK_SET && pos < 0)) {
            SETERRNO(EINVAL,LIB_INVARG);
            return -1;
        } else {
            return PerlLIO_lseek(fd, pos, whence);
        }
    }
    report_evil_fh(gv);
    SETERRNO(EBADF,RMS_IFI);
    return (Off_t)-1;
}

int
Perl_mode_from_discipline(pTHX_ const char *s, STRLEN len)
{
    int mode = O_BINARY;
    PERL_UNUSED_CONTEXT;
    if (s) {
	while (*s) {
	    if (*s == ':') {
		switch (s[1]) {
		case 'r':
		    if (s[2] == 'a' && s[3] == 'w'
			&& (!s[4] || s[4] == ':' || isSPACE(s[4])))
		    {
			mode = O_BINARY;
			s += 4;
			len -= 4;
			break;
		    }
		    /* FALLTHROUGH */
		case 'c':
		    if (s[2] == 'r' && s[3] == 'l' && s[4] == 'f'
			&& (!s[5] || s[5] == ':' || isSPACE(s[5])))
		    {
			mode = O_TEXT;
			s += 5;
			len -= 5;
			break;
		    }
		    /* FALLTHROUGH */
		default:
		    goto fail_discipline;
		}
	    }
	    else if (isSPACE(*s)) {
		++s;
		--len;
	    }
	    else {
		const char *end;
  fail_discipline:
		end = strchr(s+1, ':');
		if (!end)
		    end = s+len;
#ifndef PERLIO_LAYERS
		Perl_croak(aTHX_ "IO layers (like '%.*s') unavailable", end-s, s);
#else
		len -= end-s;
		s = end;
#endif
	    }
	}
    }
    return mode;
}

#if !defined(HAS_TRUNCATE) && !defined(HAS_CHSIZE)
I32
my_chsize(int fd, Off_t length)
{
#ifdef F_FREESP
	/* code courtesy of William Kucharski */
#define HAS_CHSIZE

    Stat_t filebuf;

    if (PerlLIO_fstat(fd, &filebuf) < 0)
	return -1;

    if (filebuf.st_size < length) {

	/* extend file length */

	if ((PerlLIO_lseek(fd, (length - 1), 0)) < 0)
	    return -1;

	/* write a "0" byte */

	if ((PerlLIO_write(fd, "", 1)) != 1)
	    return -1;
    }
    else {
	/* truncate length */
	struct flock fl;
	fl.l_whence = 0;
	fl.l_len = 0;
	fl.l_start = length;
	fl.l_type = F_WRLCK;    /* write lock on file space */

	/*
	* This relies on the UNDOCUMENTED F_FREESP argument to
	* fcntl(2), which truncates the file so that it ends at the
	* position indicated by fl.l_start.
	*
	* Will minor miracles never cease?
	*/

	if (fcntl(fd, F_FREESP, &fl) < 0)
	    return -1;

    }
    return 0;
#else
    Perl_croak_nocontext("truncate not implemented");
#endif /* F_FREESP */
    return -1;
}
#endif /* !HAS_TRUNCATE && !HAS_CHSIZE */

bool
Perl_do_print(pTHX_ SV *sv, PerlIO *fp)
{
    PERL_ARGS_ASSERT_DO_PRINT;

    /* assuming fp is checked earlier */
    if (!sv)
	return TRUE;
    if (SvTYPE(sv) == SVt_IV && SvIOK(sv)) {
	assert(!SvGMAGICAL(sv));
	if (SvIsUV(sv))
	    PerlIO_printf(fp, "%"UVuf, (UV)SvUVX(sv));
	else
	    PerlIO_printf(fp, "%"IVdf, (IV)SvIVX(sv));
	return !PerlIO_error(fp);
    }
    else {
	STRLEN len;
	/* Do this first to trigger any overloading.  */
	const char *tmps = SvPV_const(sv, len);
	U8 *tmpbuf = NULL;
	bool happy = TRUE;

	if (PerlIO_isutf8(fp)) { /* If the stream is utf8 ... */
	    if (!SvUTF8(sv)) {	/* Convert to utf8 if necessary */
		/* We don't modify the original scalar.  */
		tmpbuf = bytes_to_utf8((const U8*) tmps, &len);
		tmps = (char *) tmpbuf;
	    }
	    else if (ckWARN4_d(WARN_UTF8, WARN_SURROGATE, WARN_NON_UNICODE, WARN_NONCHAR)) {
		(void) check_utf8_print((const U8*) tmps, len);
	    }
	} /* else stream isn't utf8 */
	else if (DO_UTF8(sv)) { /* But if is utf8 internally, attempt to
				   convert to bytes */
	    STRLEN tmplen = len;
	    bool utf8 = TRUE;
	    U8 * const result = bytes_from_utf8((const U8*) tmps, &tmplen, &utf8);
	    if (!utf8) {

		/* Here, succeeded in downgrading from utf8.  Set up to below
		 * output the converted value */
		tmpbuf = result;
		tmps = (char *) tmpbuf;
		len = tmplen;
	    }
	    else {  /* Non-utf8 output stream, but string only representable in
		       utf8 */
		assert((char *)result == tmps);
		Perl_ck_warner_d(aTHX_ packWARN(WARN_UTF8),
				 "Wide character in %s",
				   PL_op ? OP_DESC(PL_op) : "print"
				);
		    /* Could also check that isn't one of the things to avoid
		     * in utf8 by using check_utf8_print(), but not doing so,
		     * since the stream isn't a UTF8 stream */
	    }
	}
	/* To detect whether the process is about to overstep its
	 * filesize limit we would need getrlimit().  We could then
	 * also transparently raise the limit with setrlimit() --
	 * but only until the system hard limit/the filesystem limit,
	 * at which we would get EPERM.  Note that when using buffered
	 * io the write failure can be delayed until the flush/close. --jhi */
	if (len && (PerlIO_write(fp,tmps,len) == 0))
	    happy = FALSE;
	Safefree(tmpbuf);
	return happy ? !PerlIO_error(fp) : FALSE;
    }
}

I32
Perl_my_stat_flags(pTHX_ const U32 flags)
{
    dSP;
    IO *io;
    GV* gv;

    if (PL_op->op_flags & OPf_REF) {
	gv = cGVOP_gv;
      do_fstat:
        if (gv == PL_defgv)
            return PL_laststatval;
	io = GvIO(gv);
        do_fstat_have_io:
        PL_laststype = OP_STAT;
        PL_statgv = gv ? gv : (GV *)io;
        sv_setpvs(PL_statname, "");
        if (io) {
	    if (IoIFP(io)) {
                int fd = PerlIO_fileno(IoIFP(io));
                if (fd < 0) {
                    /* E.g. PerlIO::scalar has no real fd. */
                    return (PL_laststatval = -1);
                } else {
                    return (PL_laststatval = PerlLIO_fstat(fd, &PL_statcache));
                }
            } else if (IoDIRP(io)) {
                return (PL_laststatval = PerlLIO_fstat(my_dirfd(IoDIRP(io)), &PL_statcache));
            }
        }
	PL_laststatval = -1;
	report_evil_fh(gv);
	return -1;
    }
    else if ((PL_op->op_private & (OPpFT_STACKED|OPpFT_AFTER_t))
	     == OPpFT_STACKED)
	return PL_laststatval;
    else {
	SV* const sv = TOPs;
	const char *s;
	STRLEN len;
	if ((gv = MAYBE_DEREF_GV_flags(sv,flags))) {
	    goto do_fstat;
	}
        else if (SvROK(sv) && SvTYPE(SvRV(sv)) == SVt_PVIO) {
            io = MUTABLE_IO(SvRV(sv));
	    gv = NULL;
            goto do_fstat_have_io;
        }

	s = SvPV_flags_const(sv, len, flags);
	PL_statgv = NULL;
	sv_setpvn(PL_statname, s, len);
	s = SvPVX_const(PL_statname);		/* s now NUL-terminated */
	PL_laststype = OP_STAT;
	PL_laststatval = PerlLIO_stat(s, &PL_statcache);
	if (PL_laststatval < 0 && ckWARN(WARN_NEWLINE) && should_warn_nl(s)) {
            GCC_DIAG_IGNORE(-Wformat-nonliteral); /* PL_warn_nl is constant */
	    Perl_warner(aTHX_ packWARN(WARN_NEWLINE), PL_warn_nl, "stat");
            GCC_DIAG_RESTORE;
        }
	return PL_laststatval;
    }
}


I32
Perl_my_lstat_flags(pTHX_ const U32 flags)
{
    static const char* const no_prev_lstat = "The stat preceding -l _ wasn't an lstat";
    dSP;
    const char *file;
    SV* const sv = TOPs;
    bool isio = FALSE;
    if (PL_op->op_flags & OPf_REF) {
	if (cGVOP_gv == PL_defgv) {
	    if (PL_laststype != OP_LSTAT)
		Perl_croak(aTHX_ "%s", no_prev_lstat);
	    return PL_laststatval;
	}
	PL_laststatval = -1;
	if (ckWARN(WARN_IO)) {
	    /* diag_listed_as: Use of -l on filehandle%s */
	    Perl_warner(aTHX_ packWARN(WARN_IO),
		 	     "Use of -l on filehandle %"HEKf,
			      HEKfARG(GvENAME_HEK(cGVOP_gv)));
	}
	return -1;
    }
    if ((PL_op->op_private & (OPpFT_STACKED|OPpFT_AFTER_t))
	     == OPpFT_STACKED) {
      if (PL_laststype != OP_LSTAT)
	Perl_croak(aTHX_ "%s", no_prev_lstat);
      return PL_laststatval;
    }

    PL_laststype = OP_LSTAT;
    PL_statgv = NULL;
    if ( (  (SvROK(sv) && (  isGV_with_GP(SvRV(sv))
                          || (isio = SvTYPE(SvRV(sv)) == SVt_PVIO)  )
            )
         || isGV_with_GP(sv)
         )
      && ckWARN(WARN_IO)) {
        if (isio)
	    /* diag_listed_as: Use of -l on filehandle%s */
            Perl_warner(aTHX_ packWARN(WARN_IO),
                             "Use of -l on filehandle");
        else
	    /* diag_listed_as: Use of -l on filehandle%s */
            Perl_warner(aTHX_ packWARN(WARN_IO),
                             "Use of -l on filehandle %"HEKf,
                              HEKfARG(GvENAME_HEK((const GV *)
                                          (SvROK(sv) ? SvRV(sv) : sv))));
    }
    file = SvPV_flags_const_nolen(sv, flags);
    sv_setpv(PL_statname,file);
    PL_laststatval = PerlLIO_lstat(file,&PL_statcache);
    if (PL_laststatval < 0 && ckWARN(WARN_NEWLINE) && should_warn_nl(file)) {
        GCC_DIAG_IGNORE(-Wformat-nonliteral); /* PL_warn_nl is constant */
        Perl_warner(aTHX_ packWARN(WARN_NEWLINE), PL_warn_nl, "lstat");
        GCC_DIAG_RESTORE;
    }
    return PL_laststatval;
}

static void
S_exec_failed(pTHX_ const char *cmd, int fd, int do_report)
{
    const int e = errno;
    PERL_ARGS_ASSERT_EXEC_FAILED;

    if (ckWARN(WARN_EXEC))
        Perl_warner(aTHX_ packWARN(WARN_EXEC), "Can't exec \"%s\": %s",
                    cmd, Strerror(e));
    if (do_report) {
        /* XXX silently ignore failures */
        PERL_UNUSED_RESULT(PerlLIO_write(fd, (void*)&e, sizeof(int)));
	PerlLIO_close(fd);
    }
}

bool
Perl_do_aexec5(pTHX_ SV *really, SV **mark, SV **sp,
	       int fd, int do_report)
{
    dVAR;
    PERL_ARGS_ASSERT_DO_AEXEC5;
#if defined(__SYMBIAN32__) || defined(__LIBCATAMOUNT__)
    Perl_croak(aTHX_ "exec? I'm not *that* kind of operating system");
#else
    if (sp > mark) {
	const char **a;
	const char *tmps = NULL;
	Newx(PL_Argv, sp - mark + 1, const char*);
	a = PL_Argv;

	while (++mark <= sp) {
	    if (*mark)
		*a++ = SvPV_nolen_const(*mark);
	    else
		*a++ = "";
	}
	*a = NULL;
	if (really)
	    tmps = SvPV_nolen_const(really);
	if ((!really && *PL_Argv[0] != '/') ||
	    (really && *tmps != '/'))		/* will execvp use PATH? */
	    TAINT_ENV();		/* testing IFS here is overkill, probably */
	PERL_FPU_PRE_EXEC
	if (really && *tmps) {
            PerlProc_execvp(tmps,EXEC_ARGV_CAST(PL_Argv));
	} else {
            PerlProc_execvp(PL_Argv[0],EXEC_ARGV_CAST(PL_Argv));
	}
	PERL_FPU_POST_EXEC
 	S_exec_failed(aTHX_ (really ? tmps : PL_Argv[0]), fd, do_report);
    }
    do_execfree();
#endif
    return FALSE;
}

void
Perl_do_execfree(pTHX)
{
    Safefree(PL_Argv);
    PL_Argv = NULL;
    Safefree(PL_Cmd);
    PL_Cmd = NULL;
}

#ifdef PERL_DEFAULT_DO_EXEC3_IMPLEMENTATION

bool
Perl_do_exec3(pTHX_ const char *incmd, int fd, int do_report)
{
    dVAR;
    const char **a;
    char *s;
    char *buf;
    char *cmd;
    /* Make a copy so we can change it */
    const Size_t cmdlen = strlen(incmd) + 1;

    PERL_ARGS_ASSERT_DO_EXEC3;

    Newx(buf, cmdlen, char);
    cmd = buf;
    memcpy(cmd, incmd, cmdlen);

    while (*cmd && isSPACE(*cmd))
	cmd++;

    /* save an extra exec if possible */

#ifdef CSH
    {
        char flags[PERL_FLAGS_MAX];
	if (strnEQ(cmd,PL_cshname,PL_cshlen) &&
	    strnEQ(cmd+PL_cshlen," -c",3)) {
          my_strlcpy(flags, "-c", PERL_FLAGS_MAX);
	  s = cmd+PL_cshlen+3;
	  if (*s == 'f') {
	      s++;
              my_strlcat(flags, "f", PERL_FLAGS_MAX - 2);
	  }
	  if (*s == ' ')
	      s++;
	  if (*s++ == '\'') {
	      char * const ncmd = s;

	      while (*s)
		  s++;
	      if (s[-1] == '\n')
		  *--s = '\0';
	      if (s[-1] == '\'') {
		  *--s = '\0';
		  PERL_FPU_PRE_EXEC
		  PerlProc_execl(PL_cshname, "csh", flags, ncmd, (char*)NULL);
		  PERL_FPU_POST_EXEC
		  *s = '\'';
 		  S_exec_failed(aTHX_ PL_cshname, fd, do_report);
		  Safefree(buf);
		  return FALSE;
	      }
	  }
	}
    }
#endif /* CSH */

    /* see if there are shell metacharacters in it */

    if (*cmd == '.' && isSPACE(cmd[1]))
	goto doshell;

    if (strnEQ(cmd,"exec",4) && isSPACE(cmd[4]))
	goto doshell;

    s = cmd;
    while (isWORDCHAR(*s))
	s++;	/* catch VAR=val gizmo */
    if (*s == '=')
	goto doshell;

    for (s = cmd; *s; s++) {
	if (*s != ' ' && !isALPHA(*s) &&
	    strchr("$&*(){}[]'\";\\|?<>~`\n",*s)) {
	    if (*s == '\n' && !s[1]) {
		*s = '\0';
		break;
	    }
	    /* handle the 2>&1 construct at the end */
	    if (*s == '>' && s[1] == '&' && s[2] == '1'
		&& s > cmd + 1 && s[-1] == '2' && isSPACE(s[-2])
		&& (!s[3] || isSPACE(s[3])))
	    {
                const char *t = s + 3;

		while (*t && isSPACE(*t))
		    ++t;
		if (!*t && (PerlLIO_dup2(1,2) != -1)) {
		    s[-2] = '\0';
		    break;
		}
	    }
	  doshell:
	    PERL_FPU_PRE_EXEC
            PerlProc_execl(PL_sh_path, "sh", "-c", cmd, (char *)NULL);
	    PERL_FPU_POST_EXEC
 	    S_exec_failed(aTHX_ PL_sh_path, fd, do_report);
	    Safefree(buf);
	    return FALSE;
	}
    }

    Newx(PL_Argv, (s - cmd) / 2 + 2, const char*);
    PL_Cmd = savepvn(cmd, s-cmd);
    a = PL_Argv;
    for (s = PL_Cmd; *s;) {
	while (isSPACE(*s))
	    s++;
	if (*s)
	    *(a++) = s;
	while (*s && !isSPACE(*s))
	    s++;
	if (*s)
	    *s++ = '\0';
    }
    *a = NULL;
    if (PL_Argv[0]) {
	PERL_FPU_PRE_EXEC
        PerlProc_execvp(PL_Argv[0],EXEC_ARGV_CAST(PL_Argv));
	PERL_FPU_POST_EXEC
	if (errno == ENOEXEC) {		/* for system V NIH syndrome */
	    do_execfree();
	    goto doshell;
	}
 	S_exec_failed(aTHX_ PL_Argv[0], fd, do_report);
    }
    do_execfree();
    Safefree(buf);
    return FALSE;
}

#endif /* OS2 || WIN32 */

I32
Perl_apply(pTHX_ I32 type, SV **mark, SV **sp)
{
    I32 val;
    I32 tot = 0;
    const char *const what = PL_op_name[type];
    const char *s;
    STRLEN len;
    SV ** const oldmark = mark;
    bool killgp = FALSE;

    PERL_ARGS_ASSERT_APPLY;

    PERL_UNUSED_VAR(what); /* may not be used depending on compile options */

    /* Doing this ahead of the switch statement preserves the old behaviour,
       where attempting to use kill as a taint test test would fail on
       platforms where kill was not defined.  */
#ifndef HAS_KILL
    if (type == OP_KILL)
	Perl_die(aTHX_ PL_no_func, what);
#endif
#ifndef HAS_CHOWN
    if (type == OP_CHOWN)
	Perl_die(aTHX_ PL_no_func, what);
#endif


#define APPLY_TAINT_PROPER() \
    STMT_START {							\
	if (TAINT_get) { TAINT_PROPER(what); }				\
    } STMT_END

    /* This is a first heuristic; it doesn't catch tainting magic. */
    if (TAINTING_get) {
	while (++mark <= sp) {
	    if (SvTAINTED(*mark)) {
		TAINT;
		break;
	    }
	}
	mark = oldmark;
    }
    switch (type) {
    case OP_CHMOD:
	APPLY_TAINT_PROPER();
	if (++mark <= sp) {
	    val = SvIV(*mark);
	    APPLY_TAINT_PROPER();
	    tot = sp - mark;
	    while (++mark <= sp) {
                GV* gv;
                if ((gv = MAYBE_DEREF_GV(*mark))) {
		    if (GvIO(gv) && IoIFP(GvIOp(gv))) {
#ifdef HAS_FCHMOD
                        int fd = PerlIO_fileno(IoIFP(GvIOn(gv)));
			APPLY_TAINT_PROPER();
                        if (fd < 0) {
                            SETERRNO(EBADF,RMS_IFI);
                            tot--;
                        } else if (fchmod(fd, val))
                            tot--;
#else
			Perl_die(aTHX_ PL_no_func, "fchmod");
#endif
		    }
		    else {
                        SETERRNO(EBADF,RMS_IFI);
			tot--;
		    }
		}
		else {
		    const char *name = SvPV_nomg_const(*mark, len);
		    APPLY_TAINT_PROPER();
                    if (!IS_SAFE_PATHNAME(name, len, "chmod") ||
                        PerlLIO_chmod(name, val)) {
                        tot--;
                    }
		}
	    }
	}
	break;
#ifdef HAS_CHOWN
    case OP_CHOWN:
	APPLY_TAINT_PROPER();
	if (sp - mark > 2) {
            I32 val2;
	    val = SvIVx(*++mark);
	    val2 = SvIVx(*++mark);
	    APPLY_TAINT_PROPER();
	    tot = sp - mark;
	    while (++mark <= sp) {
                GV* gv;
		if ((gv = MAYBE_DEREF_GV(*mark))) {
		    if (GvIO(gv) && IoIFP(GvIOp(gv))) {
#ifdef HAS_FCHOWN
                        int fd = PerlIO_fileno(IoIFP(GvIOn(gv)));
			APPLY_TAINT_PROPER();
                        if (fd < 0) {
			    SETERRNO(EBADF,RMS_IFI);
			    tot--;
#if Uid_t_sign == 1
			} else if (val < 0) {
			    SETERRNO(EINVAL,LIB_INVARG);
			    tot--;
#endif
#if Gid_t_sign == 1
			} else if (val2 < 0) {
			    SETERRNO(EINVAL,LIB_INVARG);
			    tot--;
#endif
                        } else if (fchown(fd, val, val2))
			    tot--;
#else
			Perl_die(aTHX_ PL_no_func, "fchown");
#endif
		    }
		    else {
                        SETERRNO(EBADF,RMS_IFI);
			tot--;
		    }
		}
		else {
		    const char *name = SvPV_nomg_const(*mark, len);
		    APPLY_TAINT_PROPER();
                    if (!IS_SAFE_PATHNAME(name, len, "chown") ||
                        PerlLIO_chown(name, val, val2)) {
			tot--;
                    }
		}
	    }
	}
	break;
#endif
/*
XXX Should we make lchown() directly available from perl?
For now, we'll let Configure test for HAS_LCHOWN, but do
nothing in the core.
    --AD  5/1998
*/
#ifdef HAS_KILL
    case OP_KILL:
	APPLY_TAINT_PROPER();
	if (mark == sp)
	    break;
	s = SvPVx_const(*++mark, len);
	if (*s == '-' && isALPHA(s[1]))
	{
	    s++;
	    len--;
            killgp = TRUE;
	}
	if (isALPHA(*s)) {
	    if (*s == 'S' && s[1] == 'I' && s[2] == 'G') {
		s += 3;
                len -= 3;
            }
           if ((val = whichsig_pvn(s, len)) < 0)
               Perl_croak(aTHX_ "Unrecognized signal name \"%"SVf"\"", SVfARG(*mark));
	}
	else
	{
	    val = SvIV(*mark);
	    if (val < 0)
	    {
		killgp = TRUE;
                val = -val;
	    }
	}
	APPLY_TAINT_PROPER();
	tot = sp - mark;

	while (++mark <= sp) {
	    Pid_t proc;
	    SvGETMAGIC(*mark);
	    if (!(SvNIOK(*mark) || looks_like_number(*mark)))
		Perl_croak(aTHX_ "Can't kill a non-numeric process ID");
	    proc = SvIV_nomg(*mark);
	    APPLY_TAINT_PROPER();
#ifdef HAS_KILLPG
            /* use killpg in preference, as the killpg() wrapper for Win32
             * understands process groups, but the kill() wrapper doesn't */
            if (killgp ? PerlProc_killpg(proc, val)
                       : PerlProc_kill(proc, val))
#else
            if (PerlProc_kill(killgp ? -proc: proc, val))
#endif
		tot--;
	}
	PERL_ASYNC_CHECK();
	break;
#endif
    case OP_UNLINK:
	APPLY_TAINT_PROPER();
	tot = sp - mark;
	while (++mark <= sp) {
	    s = SvPV_const(*mark, len);
	    APPLY_TAINT_PROPER();
	    if (!IS_SAFE_PATHNAME(s, len, "unlink")) {
                tot--;
            }
	    else if (PL_unsafe) {
		if (UNLINK(s))
		{
		    tot--;
		}
#if defined(__amigaos4__) && defined(NEWLIB)
		else
		{
                  /* Under AmigaOS4 unlink only 'fails' if the
                   * filename is invalid.  It may not remove the file
                   * if it's locked, so check if it's still around. */
                  if ((access(s,F_OK) != -1))
                  {
                    tot--;
                  }
		}
#endif
	    }
	    else {	/* don't let root wipe out directories without -U */
		Stat_t statbuf;
		if (PerlLIO_lstat(s, &statbuf) < 0)
		    tot--;
		else if (S_ISDIR(statbuf.st_mode)) {
		    SETERRNO(EISDIR, SS_NOPRIV);
		    tot--;
		}
		else {
		    if (UNLINK(s))
		    {
				tot--;
			}
#if defined(__amigaos4__) && defined(NEWLIB)
			else
			{
				/* Under AmigaOS4 unlink only 'fails' if the filename is invalid */
				/* It may not remove the file if it's Locked, so check if it's still */
				/* arround */
				if((access(s,F_OK) != -1))
				{
					tot--;
				}
			}	
#endif
		}
	    }
	}
	break;
#if defined(HAS_UTIME) || defined(HAS_FUTIMES)
    case OP_UTIME:
	APPLY_TAINT_PROPER();
	if (sp - mark > 2) {
#if defined(HAS_FUTIMES)
	    struct timeval utbuf[2];
	    void *utbufp = utbuf;
#elif defined(I_UTIME) || defined(VMS)
	    struct utimbuf utbuf;
	    struct utimbuf *utbufp = &utbuf;
#else
	    struct {
		Time_t	actime;
		Time_t	modtime;
	    } utbuf;
	    void *utbufp = &utbuf;
#endif

	   SV* const accessed = *++mark;
	   SV* const modified = *++mark;

           /* Be like C, and if both times are undefined, let the C
            * library figure out what to do.  This usually means
            * "current time". */

           if ( accessed == &PL_sv_undef && modified == &PL_sv_undef )
                utbufp = NULL;
           else {
                Zero(&utbuf, sizeof utbuf, char);
#ifdef HAS_FUTIMES
		utbuf[0].tv_sec = (long)SvIV(accessed);  /* time accessed */
		utbuf[0].tv_usec = 0;
		utbuf[1].tv_sec = (long)SvIV(modified);  /* time modified */
		utbuf[1].tv_usec = 0;
#elif defined(BIG_TIME)
                utbuf.actime = (Time_t)SvNV(accessed);  /* time accessed */
                utbuf.modtime = (Time_t)SvNV(modified); /* time modified */
#else
                utbuf.actime = (Time_t)SvIV(accessed);  /* time accessed */
                utbuf.modtime = (Time_t)SvIV(modified); /* time modified */
#endif
            }
	    APPLY_TAINT_PROPER();
	    tot = sp - mark;
	    while (++mark <= sp) {
                GV* gv;
                if ((gv = MAYBE_DEREF_GV(*mark))) {
		    if (GvIO(gv) && IoIFP(GvIOp(gv))) {
#ifdef HAS_FUTIMES
                        int fd =  PerlIO_fileno(IoIFP(GvIOn(gv)));
			APPLY_TAINT_PROPER();
                        if (fd < 0) {
                            SETERRNO(EBADF,RMS_IFI);
                            tot--;
			} else if (futimes(fd, (struct timeval *) utbufp))
			    tot--;
#else
			Perl_die(aTHX_ PL_no_func, "futimes");
#endif
		    }
		    else {
			tot--;
		    }
		}
		else {
		    const char * const name = SvPV_nomg_const(*mark, len);
		    APPLY_TAINT_PROPER();
		    if (!IS_SAFE_PATHNAME(name, len, "utime")) {
                        tot--;
                    }
                    else
#ifdef HAS_FUTIMES
		    if (utimes(name, (struct timeval *)utbufp))
#else
		    if (PerlLIO_utime(name, utbufp))
#endif
			tot--;
		}

	    }
	}
	else
	    tot = 0;
	break;
#endif
    }
    return tot;

#undef APPLY_TAINT_PROPER
}

/* Do the permissions allow some operation?  Assumes statcache already set. */
#ifndef VMS /* VMS' cando is in vms.c */
bool
Perl_cando(pTHX_ Mode_t mode, bool effective, const Stat_t *statbufp)
/* effective is a flag, true for EUID, or for checking if the effective gid
 *  is in the list of groups returned from getgroups().
 */
{
    PERL_ARGS_ASSERT_CANDO;
    PERL_UNUSED_CONTEXT;

#ifdef DOSISH
    /* [Comments and code from Len Reed]
     * MS-DOS "user" is similar to UNIX's "superuser," but can't write
     * to write-protected files.  The execute permission bit is set
     * by the Microsoft C library stat() function for the following:
     *		.exe files
     *		.com files
     *		.bat files
     *		directories
     * All files and directories are readable.
     * Directories and special files, e.g. "CON", cannot be
     * write-protected.
     * [Comment by Tom Dinger -- a directory can have the write-protect
     *		bit set in the file system, but DOS permits changes to
     *		the directory anyway.  In addition, all bets are off
     *		here for networked software, such as Novell and
     *		Sun's PC-NFS.]
     */

     /* Atari stat() does pretty much the same thing. we set x_bit_set_in_stat
      * too so it will actually look into the files for magic numbers
      */
     return (mode & statbufp->st_mode) ? TRUE : FALSE;

#else /* ! DOSISH */
# ifdef __CYGWIN__
    if (ingroup(544,effective)) {     /* member of Administrators */
# else
    if ((effective ? PerlProc_geteuid() : PerlProc_getuid()) == 0) {	/* root is special */
# endif
	if (mode == S_IXUSR) {
	    if (statbufp->st_mode & 0111 || S_ISDIR(statbufp->st_mode))
		return TRUE;
	}
	else
	    return TRUE;		/* root reads and writes anything */
	return FALSE;
    }
    if (statbufp->st_uid == (effective ? PerlProc_geteuid() : PerlProc_getuid()) ) {
	if (statbufp->st_mode & mode)
	    return TRUE;	/* ok as "user" */
    }
    else if (ingroup(statbufp->st_gid,effective)) {
	if (statbufp->st_mode & mode >> 3)
	    return TRUE;	/* ok as "group" */
    }
    else if (statbufp->st_mode & mode >> 6)
	return TRUE;	/* ok as "other" */
    return FALSE;
#endif /* ! DOSISH */
}
#endif /* ! VMS */

static bool
S_ingroup(pTHX_ Gid_t testgid, bool effective)
{
#ifndef PERL_IMPLICIT_SYS
    /* PERL_IMPLICIT_SYS like Win32: getegid() etc. require the context. */
    PERL_UNUSED_CONTEXT;
#endif
    if (testgid == (effective ? PerlProc_getegid() : PerlProc_getgid()))
	return TRUE;
#ifdef HAS_GETGROUPS
    {
	Groups_t *gary = NULL;
	I32 anum;
        bool rc = FALSE;

	anum = getgroups(0, gary);
        if (anum > 0) {
            Newx(gary, anum, Groups_t);
            anum = getgroups(anum, gary);
            while (--anum >= 0)
                if (gary[anum] == testgid) {
                    rc = TRUE;
                    break;
                }

            Safefree(gary);
        }
        return rc;
    }
#else
    return FALSE;
#endif
}

#if defined(HAS_MSG) || defined(HAS_SEM) || defined(HAS_SHM)

I32
Perl_do_ipcget(pTHX_ I32 optype, SV **mark, SV **sp)
{
    const key_t key = (key_t)SvNVx(*++mark);
    SV *nsv = optype == OP_MSGGET ? NULL : *++mark;
    const I32 flags = SvIVx(*++mark);

    PERL_ARGS_ASSERT_DO_IPCGET;
    PERL_UNUSED_ARG(sp);

    SETERRNO(0,0);
    switch (optype)
    {
#ifdef HAS_MSG
    case OP_MSGGET:
	return msgget(key, flags);
#endif
#ifdef HAS_SEM
    case OP_SEMGET:
	return semget(key, (int) SvIV(nsv), flags);
#endif
#ifdef HAS_SHM
    case OP_SHMGET:
	return shmget(key, (size_t) SvUV(nsv), flags);
#endif
#if !defined(HAS_MSG) || !defined(HAS_SEM) || !defined(HAS_SHM)
    default:
        /* diag_listed_as: msg%s not implemented */
	Perl_croak(aTHX_ "%s not implemented", PL_op_desc[optype]);
#endif
    }
    return -1;			/* should never happen */
}

I32
Perl_do_ipcctl(pTHX_ I32 optype, SV **mark, SV **sp)
{
    char *a;
    I32 ret = -1;
    const I32 id  = SvIVx(*++mark);
#ifdef Semctl
    const I32 n   = (optype == OP_SEMCTL) ? SvIVx(*++mark) : 0;
#endif
    const I32 cmd = SvIVx(*++mark);
    SV * const astr = *++mark;
    STRLEN infosize = 0;
    I32 getinfo = (cmd == IPC_STAT);

    PERL_ARGS_ASSERT_DO_IPCCTL;
    PERL_UNUSED_ARG(sp);

    switch (optype)
    {
#ifdef HAS_MSG
    case OP_MSGCTL:
	if (cmd == IPC_STAT || cmd == IPC_SET)
	    infosize = sizeof(struct msqid_ds);
	break;
#endif
#ifdef HAS_SHM
    case OP_SHMCTL:
	if (cmd == IPC_STAT || cmd == IPC_SET)
	    infosize = sizeof(struct shmid_ds);
	break;
#endif
#ifdef HAS_SEM
    case OP_SEMCTL:
#ifdef Semctl
	if (cmd == IPC_STAT || cmd == IPC_SET)
	    infosize = sizeof(struct semid_ds);
	else if (cmd == GETALL || cmd == SETALL)
	{
	    struct semid_ds semds;
	    union semun semun;
#ifdef EXTRA_F_IN_SEMUN_BUF
            semun.buff = &semds;
#else
            semun.buf = &semds;
#endif
	    getinfo = (cmd == GETALL);
	    if (Semctl(id, 0, IPC_STAT, semun) == -1)
		return -1;
	    infosize = semds.sem_nsems * sizeof(short);
		/* "short" is technically wrong but much more portable
		   than guessing about u_?short(_t)? */
	}
#else
        /* diag_listed_as: sem%s not implemented */
	Perl_croak(aTHX_ "%s not implemented", PL_op_desc[optype]);
#endif
	break;
#endif
#if !defined(HAS_MSG) || !defined(HAS_SEM) || !defined(HAS_SHM)
    default:
        /* diag_listed_as: shm%s not implemented */
	Perl_croak(aTHX_ "%s not implemented", PL_op_desc[optype]);
#endif
    }

    if (infosize)
    {
	if (getinfo)
	{
	    SvPV_force_nolen(astr);
	    a = SvGROW(astr, infosize+1);
	}
	else
	{
	    STRLEN len;
	    a = SvPV(astr, len);
	    if (len != infosize)
		Perl_croak(aTHX_ "Bad arg length for %s, is %lu, should be %ld",
		      PL_op_desc[optype],
		      (unsigned long)len,
		      (long)infosize);
	}
    }
    else
    {
	const IV i = SvIV(astr);
	a = INT2PTR(char *,i);		/* ouch */
    }
    SETERRNO(0,0);
    switch (optype)
    {
#ifdef HAS_MSG
    case OP_MSGCTL:
	ret = msgctl(id, cmd, (struct msqid_ds *)a);
	break;
#endif
#ifdef HAS_SEM
    case OP_SEMCTL: {
#ifdef Semctl
            union semun unsemds;

            if(cmd == SETVAL) {
                unsemds.val = PTR2nat(a);
            }
            else {
#ifdef EXTRA_F_IN_SEMUN_BUF
                unsemds.buff = (struct semid_ds *)a;
#else
                unsemds.buf = (struct semid_ds *)a;
#endif
            }
	    ret = Semctl(id, n, cmd, unsemds);
#else
	    /* diag_listed_as: sem%s not implemented */
	    Perl_croak(aTHX_ "%s not implemented", PL_op_desc[optype]);
#endif
        }
	break;
#endif
#ifdef HAS_SHM
    case OP_SHMCTL:
	ret = shmctl(id, cmd, (struct shmid_ds *)a);
	break;
#endif
    }
    if (getinfo && ret >= 0) {
	SvCUR_set(astr, infosize);
	*SvEND(astr) = '\0';
	SvSETMAGIC(astr);
    }
    return ret;
}

I32
Perl_do_msgsnd(pTHX_ SV **mark, SV **sp)
{
#ifdef HAS_MSG
    STRLEN len;
    const I32 id = SvIVx(*++mark);
    SV * const mstr = *++mark;
    const I32 flags = SvIVx(*++mark);
    const char * const mbuf = SvPV_const(mstr, len);
    const I32 msize = len - sizeof(long);

    PERL_ARGS_ASSERT_DO_MSGSND;
    PERL_UNUSED_ARG(sp);

    if (msize < 0)
	Perl_croak(aTHX_ "Arg too short for msgsnd");
    SETERRNO(0,0);
    if (id >= 0 && flags >= 0) {
      return msgsnd(id, (struct msgbuf *)mbuf, msize, flags);
    } else {
      SETERRNO(EINVAL,LIB_INVARG);
      return -1;
    }
#else
    PERL_UNUSED_ARG(sp);
    PERL_UNUSED_ARG(mark);
    /* diag_listed_as: msg%s not implemented */
    Perl_croak(aTHX_ "msgsnd not implemented");
    return -1;
#endif
}

I32
Perl_do_msgrcv(pTHX_ SV **mark, SV **sp)
{
#ifdef HAS_MSG
    char *mbuf;
    long mtype;
    I32 msize, flags, ret;
    const I32 id = SvIVx(*++mark);
    SV * const mstr = *++mark;

    PERL_ARGS_ASSERT_DO_MSGRCV;
    PERL_UNUSED_ARG(sp);

    /* suppress warning when reading into undef var --jhi */
    if (! SvOK(mstr))
	sv_setpvs(mstr, "");
    msize = SvIVx(*++mark);
    mtype = (long)SvIVx(*++mark);
    flags = SvIVx(*++mark);
    SvPV_force_nolen(mstr);
    mbuf = SvGROW(mstr, sizeof(long)+msize+1);

    SETERRNO(0,0);
    if (id >= 0 && msize >= 0 && flags >= 0) {
        ret = msgrcv(id, (struct msgbuf *)mbuf, msize, mtype, flags);
    } else {
        SETERRNO(EINVAL,LIB_INVARG);
        ret = -1;
    }
    if (ret >= 0) {
	SvCUR_set(mstr, sizeof(long)+ret);
	*SvEND(mstr) = '\0';
	/* who knows who has been playing with this message? */
	SvTAINTED_on(mstr);
    }
    return ret;
#else
    PERL_UNUSED_ARG(sp);
    PERL_UNUSED_ARG(mark);
    /* diag_listed_as: msg%s not implemented */
    Perl_croak(aTHX_ "msgrcv not implemented");
    return -1;
#endif
}

I32
Perl_do_semop(pTHX_ SV **mark, SV **sp)
{
#ifdef HAS_SEM
    STRLEN opsize;
    const I32 id = SvIVx(*++mark);
    SV * const opstr = *++mark;
    const char * const opbuf = SvPV_const(opstr, opsize);

    PERL_ARGS_ASSERT_DO_SEMOP;
    PERL_UNUSED_ARG(sp);

    if (opsize < 3 * SHORTSIZE
	|| (opsize % (3 * SHORTSIZE))) {
	SETERRNO(EINVAL,LIB_INVARG);
	return -1;
    }
    SETERRNO(0,0);
    /* We can't assume that sizeof(struct sembuf) == 3 * sizeof(short). */
    {
        const int nsops  = opsize / (3 * sizeof (short));
        int i      = nsops;
        short * const ops = (short *) opbuf;
        short *o   = ops;
        struct sembuf *temps, *t;
        I32 result;

        Newx (temps, nsops, struct sembuf);
        t = temps;
        while (i--) {
            t->sem_num = *o++;
            t->sem_op  = *o++;
            t->sem_flg = *o++;
            t++;
        }
        result = semop(id, temps, nsops);
        Safefree(temps);
        return result;
    }
#else
    /* diag_listed_as: sem%s not implemented */
    Perl_croak(aTHX_ "semop not implemented");
#endif
}

I32
Perl_do_shmio(pTHX_ I32 optype, SV **mark, SV **sp)
{
#ifdef HAS_SHM
    char *shm;
    struct shmid_ds shmds;
    const I32 id = SvIVx(*++mark);
    SV * const mstr = *++mark;
    const I32 mpos = SvIVx(*++mark);
    const I32 msize = SvIVx(*++mark);

    PERL_ARGS_ASSERT_DO_SHMIO;
    PERL_UNUSED_ARG(sp);

    SETERRNO(0,0);
    if (shmctl(id, IPC_STAT, &shmds) == -1)
	return -1;
    if (mpos < 0 || msize < 0
	|| (size_t)mpos + msize > (size_t)shmds.shm_segsz) {
	SETERRNO(EFAULT,SS_ACCVIO);		/* can't do as caller requested */
	return -1;
    }
    if (id >= 0) {
        shm = (char *)shmat(id, NULL, (optype == OP_SHMREAD) ? SHM_RDONLY : 0);
    } else {
        SETERRNO(EINVAL,LIB_INVARG);
        return -1;
    }
    if (shm == (char *)-1)	/* I hate System V IPC, I really do */
	return -1;
    if (optype == OP_SHMREAD) {
	char *mbuf;
	/* suppress warning when reading into undef var (tchrist 3/Mar/00) */
	SvGETMAGIC(mstr);
	SvUPGRADE(mstr, SVt_PV);
	if (! SvOK(mstr))
	    sv_setpvs(mstr, "");
	SvPOK_only(mstr);
	mbuf = SvGROW(mstr, (STRLEN)msize+1);

	Copy(shm + mpos, mbuf, msize, char);
	SvCUR_set(mstr, msize);
	*SvEND(mstr) = '\0';
	SvSETMAGIC(mstr);
	/* who knows who has been playing with this shared memory? */
	SvTAINTED_on(mstr);
    }
    else {
	STRLEN len;

	const char *mbuf = SvPV_const(mstr, len);
	const I32 n = ((I32)len > msize) ? msize : (I32)len;
	Copy(mbuf, shm + mpos, n, char);
	if (n < msize)
	    memzero(shm + mpos + n, msize - n);
    }
    return shmdt(shm);
#else
    /* diag_listed_as: shm%s not implemented */
    Perl_croak(aTHX_ "shm I/O not implemented");
    return -1;
#endif
}

#endif /* SYSV IPC */

/*
=head1 IO Functions

=for apidoc start_glob

Function called by C<do_readline> to spawn a glob (or do the glob inside
perl on VMS).  This code used to be inline, but now perl uses C<File::Glob>
this glob starter is only used by miniperl during the build process,
or when PERL_EXTERNAL_GLOB is defined.
Moving it away shrinks F<pp_hot.c>; shrinking F<pp_hot.c> helps speed perl up.

=cut
*/

PerlIO *
Perl_start_glob (pTHX_ SV *tmpglob, IO *io)
{
    SV * const tmpcmd = newSV(0);
    PerlIO *fp;
    STRLEN len;
    const char *s = SvPV(tmpglob, len);

    PERL_ARGS_ASSERT_START_GLOB;

    if (!IS_SAFE_SYSCALL(s, len, "pattern", "glob"))
        return NULL;

    ENTER;
    SAVEFREESV(tmpcmd);
#ifdef VMS /* expand the wildcards right here, rather than opening a pipe, */
           /* since spawning off a process is a real performance hit */

PerlIO * 
Perl_vms_start_glob
   (pTHX_ SV *tmpglob,
    IO *io);

    fp = Perl_vms_start_glob(aTHX_ tmpglob, io);

#else /* !VMS */
#ifdef DOSISH
#ifdef OS2
    sv_setpv(tmpcmd, "for a in ");
    sv_catsv(tmpcmd, tmpglob);
    sv_catpv(tmpcmd, "; do echo \"$a\\0\\c\"; done |");
#else
#ifdef DJGPP
    sv_setpv(tmpcmd, "/dev/dosglob/"); /* File System Extension */
    sv_catsv(tmpcmd, tmpglob);
#else
    sv_setpv(tmpcmd, "perlglob ");
    sv_catsv(tmpcmd, tmpglob);
    sv_catpv(tmpcmd, " |");
#endif /* !DJGPP */
#endif /* !OS2 */
#else /* !DOSISH */
#if defined(CSH)
    sv_setpvn(tmpcmd, PL_cshname, PL_cshlen);
    sv_catpv(tmpcmd, " -cf 'set nonomatch; glob ");
    sv_catsv(tmpcmd, tmpglob);
    sv_catpv(tmpcmd, "' 2>/dev/null |");
#else
    sv_setpv(tmpcmd, "echo ");
    sv_catsv(tmpcmd, tmpglob);
    sv_catpv(tmpcmd, "|tr -s ' \t\f\r' '\\n\\n\\n\\n'|");
#endif /* !CSH */
#endif /* !DOSISH */
    {
	GV * const envgv = gv_fetchpvs("ENV", 0, SVt_PVHV);
	SV ** const home = hv_fetchs(GvHV(envgv), "HOME", 0);
	SV ** const path = hv_fetchs(GvHV(envgv), "PATH", 0);
	if (home && *home) SvGETMAGIC(*home);
	if (path && *path) SvGETMAGIC(*path);
	save_hash(gv_fetchpvs("ENV", 0, SVt_PVHV));
	if (home && *home) SvSETMAGIC(*home);
	if (path && *path) SvSETMAGIC(*path);
    }
    (void)do_open6(PL_last_in_gv, SvPVX_const(tmpcmd), SvCUR(tmpcmd),
                   NULL, NULL, 0);
    fp = IoIFP(io);
#endif /* !VMS */
    LEAVE;

    if (!fp && ckWARN(WARN_GLOB)) {
        Perl_warner(aTHX_ packWARN(WARN_GLOB), "glob failed (can't start child: %s)",
                    Strerror(errno));
    }

    return fp;
}

/*
 * ex: set ts=8 sts=4 sw=4 et:
 */
@


1.18
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@a66 1
    dVAR;
a146 1
    dVAR;
a215 1
    dVAR;
d380 1
d394 5
a398 2
		    else if (isDIGIT(*type)) {
                        wanted_fd = atoi(type);
d441 5
a445 2
			else
			    wanted_fd = -1;
d624 1
a624 1
	    && strchr(oname, '\n')
d653 3
a655 3
    /* If there is no fd (e.g. PerlIO::scalar) assume it isn't a
     * socket - this covers PerlIO::scalar - otherwise unless we "know" the
     * type probe for socket-ness.
d703 4
a706 1
	    if (PerlLIO_dup2(fd, savefd) < 0) {
d742 1
a742 1
                int dupfd = PerlLIO_dup(ofd);
d744 8
a751 2
		/* Assume if we have F_SETFD we have F_GETFD */
                int coe = fcntl(ofd,F_GETFD);
d753 5
d759 1
a759 1
                PerlLIO_dup2(dupfd,ofd);
d761 3
a763 2
		/* The dup trick has lost close-on-exec on ofd */
		fcntl(ofd,F_SETFD, coe);
d774 4
a777 5
#if defined(HAS_FCNTL) && defined(F_SETFD)
    if (fd >= 0) {
	dSAVE_ERRNO;
	fcntl(fd,F_SETFD,fd > PL_maxsysfd); /* can change errno */
	RESTORE_ERRNO;
a791 1
		IoIFP(io) = NULL;
d800 1
a800 1
say_false:
d808 1
a808 1
Perl_nextargv(pTHX_ GV *gv)
a809 1
    dVAR;
d811 1
d815 3
d820 1
a820 1
    if (io && (IoFLAGS(io) & IOf_ARGV) && (IoFLAGS(io) & IOf_START)) {
d842 1
d851 4
a854 1
            if (do_open6(gv, PL_oldname, oldlen, NULL, NULL, 0)) {
d859 7
d958 1
a958 1
#if !defined(DOSISH) && !defined(AMIGAOS)
d990 2
a991 1
		(void)PerlLIO_fstat(PL_lastfd,&PL_statbuf);
d993 1
a993 1
		(void)fchmod(PL_lastfd,PL_filemode);
d995 1
a995 1
		(void)PerlLIO_chmod(PL_oldname,PL_filemode);
d997 2
a998 2
		if (fileuid != PL_statbuf.st_uid || filegid != PL_statbuf.st_gid) {
		    /* XXX silently ignore failures */
d1000 1
a1000 1
		    PERL_UNUSED_RESULT(fchown(PL_lastfd,fileuid,filegid));
d1003 1
a1003 1
		    PERL_UNUSED_RESULT(PerlLIO_chown(PL_oldname,fileuid,filegid));
d1006 1
d1014 2
a1015 2
            if (PerlLIO_stat(PL_oldname, &PL_statbuf) >= 0
                && !S_ISREG(PL_statbuf.st_mode)) {
d1029 11
a1039 1
	(void)do_close(PL_argvoutgv,FALSE);
a1056 1
    dVAR;
d1075 1
a1075 1
    retval = io_close(io, not_implicit);
d1086 1
a1086 1
Perl_io_close(pTHX_ IO *io, bool not_implicit)
a1087 1
    dVAR;
d1108 4
d1117 4
d1125 14
a1149 1
    dVAR;
d1182 1
a1182 1
	    if (gv != PL_argvgv || !nextargv(gv))	/* get another fp handy */
a1193 1
    dVAR;
a1209 1
    dVAR;
a1223 1
    dVAR;
d1229 9
a1237 2
    if (io && (fp = IoIFP(io)))
	return PerlLIO_lseek(PerlIO_fileno(fp), pos, whence);
d1247 1
d1261 1
a1261 1
		    /* FALL THROUGH */
d1271 1
a1271 1
		    /* FALL THROUGH */
d1282 1
a1282 1
fail_discipline:
a1353 2
    dVAR;

a1424 1
    dVAR;
d1439 1
a1439 1
        if(io) {
d1441 7
a1447 1
	        return (PL_laststatval = PerlLIO_fstat(PerlIO_fileno(IoIFP(io)), &PL_statcache));
d1478 1
a1478 1
	if (PL_laststatval < 0 && ckWARN(WARN_NEWLINE) && strchr(s, '\n')) {
a1490 1
    dVAR;
d1534 2
a1535 2
                              GvENAME_HEK((const GV *)
                                          (SvROK(sv) ? SvRV(sv) : sv)));
d1540 1
a1540 1
    if (PL_laststatval < 0 && ckWARN(WARN_NEWLINE) && strchr(file, '\n')) {
d1553 1
d1555 2
a1556 2
	Perl_warner(aTHX_ packWARN(WARN_EXEC), "Can't exec \"%s\": %s",
		    cmd, Strerror(e));
d1592 5
a1596 4
	if (really && *tmps)
	    PerlProc_execvp(tmps,EXEC_ARGV_CAST(PL_Argv));
	else
	    PerlProc_execvp(PL_Argv[0],EXEC_ARGV_CAST(PL_Argv));
a1607 1
    dVAR;
d1710 1
a1710 1
	    PerlProc_execl(PL_sh_path, "sh", "-c", cmd, (char *)NULL);
d1734 1
a1734 1
	PerlProc_execvp(PL_Argv[0],EXEC_ARGV_CAST(PL_Argv));
a1748 4
#ifdef VMS
#include <starlet.h> /* for sys$delprc */
#endif

a1751 1
    dVAR;
d1804 1
d1806 5
a1810 2
			if (fchmod(PerlIO_fileno(IoIFP(GvIOn(gv))), val))
			    tot--;
d1816 1
d1845 1
d1847 14
a1860 1
			if (fchown(PerlIO_fileno(IoIFP(GvIOn(gv))), val, val2))
d1867 1
d1920 1
a1920 34
#ifdef VMS
	/* kill() doesn't do process groups (job trees?) under VMS */
	if (val == SIGKILL) {
	    /* Use native sys$delprc() to insure that target process is
	     * deleted; supervisor-mode images don't pay attention to
	     * CRTL's emulation of Unix-style signals and kill()
	     */
	    while (++mark <= sp) {
		I32 proc;
		unsigned long int __vmssts;
		SvGETMAGIC(*mark);
		if (!(SvIOK(*mark) || SvNOK(*mark) || looks_like_number(*mark)))
		    Perl_croak(aTHX_ "Can't kill a non-numeric process ID");
		proc = SvIV_nomg(*mark);
		APPLY_TAINT_PROPER();
		if (!((__vmssts = sys$delprc(&proc,0)) & 1)) {
		    tot--;
		    switch (__vmssts) {
			case SS$_NONEXPR:
			case SS$_NOSUCHNODE:
			    SETERRNO(ESRCH,__vmssts);
			    break;
			case SS$_NOPRIV:
			    SETERRNO(EPERM,__vmssts);
			    break;
			default:
			    SETERRNO(EVMSERR,__vmssts);
		    }
		}
	    }
	    PERL_ASYNC_CHECK();
	    break;
	}
#endif
d1952 1
d1954 13
d1969 2
a1970 1
		if (PerlLIO_lstat(s,&PL_statbuf) < 0)
d1972 2
a1973 1
		else if (S_ISDIR(PL_statbuf.st_mode)) {
a1974 1
		    SETERRNO(EISDIR, SS$_NOPRIV);
d1978 15
a1992 1
			tot--;
d2046 1
d2048 4
a2051 2
			if (futimes(PerlIO_fileno(IoIFP(GvIOn(gv))),
                            (struct timeval *) utbufp))
a2095 2
    dVAR;

d2097 1
d2155 4
a2158 1
    dVAR;
d2168 8
a2175 7
        Newx(gary, anum, Groups_t);
        anum = getgroups(anum, gary);
	while (--anum >= 0)
	    if (gary[anum] == testgid) {
                rc = TRUE;
                break;
            }
d2177 2
a2178 1
        Safefree(gary);
a2190 1
    dVAR;
a2224 1
    dVAR;
a2357 1
    dVAR;
d2372 6
a2377 1
    return msgsnd(id, (struct msgbuf *)mbuf, msize, flags);
a2390 1
    dVAR;
d2410 6
a2415 1
    ret = msgrcv(id, (struct msgbuf *)mbuf, msize, mtype, flags);
a2435 1
    dVAR;
a2480 1
    dVAR;
d2499 6
a2504 1
    shm = (char *)shmat(id, NULL, (optype == OP_SHMREAD) ? SHM_RDONLY : 0);
d2550 3
a2552 2
this glob starter is only used by miniperl during the build process.
Moving it away shrinks pp_hot.c; shrinking pp_hot.c helps speed perl up.
a2559 1
    dVAR;
a2634 6
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
@


1.17
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d63 3
a65 4
bool
Perl_do_openn(pTHX_ GV *gv, const char *oname, I32 len, int as_raw,
	      int rawmode, int rawperm, PerlIO *supplied_fp, SV **svp,
	      I32 num_svs)
a68 13
    PerlIO *saveifp = NULL;
    PerlIO *saveofp = NULL;
    int savefd = -1;
    char savetype = IoTYPE_CLOSED;
    int writing = 0;
    PerlIO *fp;
    int fd;
    int result;
    bool was_fdopen = FALSE;
    bool in_raw = 0, in_crlf = 0, out_raw = 0, out_crlf = 0;
    char *type  = NULL;
    char mode[PERL_MODE_MAX];	/* file mode ("r\0", "rb\0", "ab\0" etc.) */
    SV *namesv;
d70 6
a75 1
    PERL_ARGS_ASSERT_DO_OPENN;
a79 10
    /* Collect default raw/crlf info from the op */
    if (PL_op && PL_op->op_type == OP_OPEN) {
	/* set up IO layers */
	const U8 flags = PL_op->op_private;
	in_raw = (flags & OPpOPEN_IN_RAW);
	in_crlf = (flags & OPpOPEN_IN_CRLF);
	out_raw = (flags & OPpOPEN_OUT_RAW);
	out_crlf = (flags & OPpOPEN_OUT_CRLF);
    }

a81 1
	fd = PerlIO_fileno(IoIFP(io));
a83 28
	    result = 0;
	}
	else if (fd >= 0 && fd <= PL_maxsysfd) {
	    /* This is one of the original STD* handles */
	    saveifp  = IoIFP(io);
	    saveofp  = IoOFP(io);
	    savetype = IoTYPE(io);
	    savefd   = fd;
	    result   = 0;
	}
	else if (IoTYPE(io) == IoTYPE_PIPE)
	    result = PerlProc_pclose(IoIFP(io));
	else if (IoIFP(io) != IoOFP(io)) {
	    if (IoOFP(io)) {
		result = PerlIO_close(IoOFP(io));
		PerlIO_close(IoIFP(io)); /* clear stdio, fd already closed */
	    }
	    else
		result = PerlIO_close(IoIFP(io));
	}
	else
	    result = PerlIO_close(IoIFP(io));
	if (result == EOF && fd > PL_maxsysfd) {
	    /* Why is this not Perl_warn*() call ? */
	    PerlIO_printf(Perl_error_log,
		"Warning: unable to close filehandle %"HEKf" properly.\n",
		 HEKfARG(GvENAME_HEK(gv))
	    );
d85 35
d122 9
d134 29
d175 1
a176 4
	if (num_svs != 0) {
	    Perl_croak(aTHX_ "panic: sysopen with multiple args, num_svs=%ld",
		       (long) num_svs);
	}
d208 1
a208 4
	num_svs = 1;
	svp = &namesv;
	type = NULL;
	fp = PerlIO_openn(aTHX_ type, mode, -1, rawmode, rawperm, NULL, num_svs, svp);
d210 24
a233 1
    else {
d239 11
d262 2
d271 1
d275 9
a283 2
	    name = (SvOK(*svp) || SvGMAGICAL(*svp)) ?
			savesvpv (*svp) : savepvs ("");
d319 1
d345 1
d382 1
d393 1
a393 1
			fd = SvUV(*svp);
d397 1
a397 1
			fd = atoi(type);
d413 1
a421 7
#ifdef USE_SFIO
			    /* sfio fails to clear error on next
			       sfwrite, contrary to documentation.
			       -- Nicholas Clark */
			    if (PerlIO_seek(that_fp, 0, SEEK_CUR) == -1)
				PerlIO_clearerr(that_fp);
#endif
d427 1
a427 1
			    fd = PerlIO_fileno(that_fp);
d441 1
a441 1
			    fd = -1;
d450 1
a450 1
			    fd = PerlLIO_dup(fd);
d453 3
a455 3
			if (!(fp = PerlIO_openn(aTHX_ type,mode,fd,0,0,NULL,num_svs,svp))) {
			    if (dodup && fd >= 0)
				PerlLIO_close(fd);
d473 5
a477 4
		    if (!num_svs) {
			namesv = newSVpvn_flags(type, tend - type, SVs_TEMP);
			num_svs = 1;
			svp = &namesv;
d479 1
a480 1
		    fp = PerlIO_openn(aTHX_ type,mode,-1,0,0,NULL,num_svs,svp);
d508 5
a512 4
		if (!num_svs) {
		    namesv = newSVpvn_flags(type, tend - type, SVs_TEMP);
		    num_svs = 1;
		    svp = &namesv;
d514 1
a515 1
		fp = PerlIO_openn(aTHX_ type,mode,-1,0,0,NULL,num_svs,svp);
d540 1
d565 1
d590 5
a594 4
		if (!num_svs) {
		    namesv = newSVpvn_flags(type, tend - type, SVs_TEMP);
		    num_svs = 1;
		    svp = &namesv;
d596 1
a597 1
		fp = PerlIO_openn(aTHX_ type,mode,-1,0,0,NULL,num_svs,svp);
d601 17
d623 2
d626 2
a663 1
#ifdef S_IFMT
a664 3
#else
	    !PL_statbuf.st_mode
#endif
d772 1
a772 1
	    if (!(IoOFP(io) = PerlIO_openn(aTHX_ type,s,fd,0,0,NULL,0,svp))) {
a793 7
    SV *sv;
#ifndef FLEXFILENAMES
    int filedev;
    int fileino;
#endif
    Uid_t fileuid;
    Gid_t filegid;
d821 1
a821 1
    while (av_len(GvAV(gv)) >= 0) {
d823 1
a823 1
	sv = av_shift(GvAV(gv));
d829 18
a846 2
	if (do_open(gv,PL_oldname,oldlen,PL_inplace!=0,O_RDONLY,0,NULL)) {
	    if (PL_inplace) {
d912 1
a912 1
		    do_open(gv,(char*)SvPVX_const(sv),SvCUR(sv),TRUE,O_RDONLY,0,NULL);
d944 2
a945 2
		if (!Perl_do_openn(aTHX_ PL_argvoutgv, (char*)SvPVX_const(sv),
				   SvCUR(sv), TRUE,
d947 1
a947 1
				   O_WRONLY|O_CREAT|O_TRUNC,0,
d949 1
a949 1
				   O_WRONLY|O_CREAT|OPEN_EXCL,0600,
d951 1
a951 1
				   NULL, NULL, 0)) {
d966 1
d968 1
a968 1
		    (void)fchown(PL_lastfd,fileuid,filegid);
d971 1
a971 1
		    (void)PerlLIO_chown(PL_oldname,fileuid,filegid);
d975 1
d977 14
a990 16
	    return IoIFP(GvIOp(gv));
	}
	else {
	    if (ckWARN_d(WARN_INPLACE)) {
		const int eno = errno;
		if (PerlLIO_stat(PL_oldname, &PL_statbuf) >= 0
		    && !S_ISREG(PL_statbuf.st_mode))	
		{
		    Perl_warner(aTHX_ packWARN(WARN_INPLACE),
				"Can't do inplace edit: %s is not a regular file",
				PL_oldname);
		}
		else
		    Perl_warner(aTHX_ packWARN(WARN_INPLACE), "Can't open %s: %s",
				PL_oldname, Strerror(eno));
	    }
a1138 4
#ifdef ULTRIX_STDIO_BOTCH
	if (PerlIO_eof(fp))
	    (void)PerlIO_seek(fp, 0L, 2);	/* ultrix 1.2 workaround */
#endif
a1153 4
#ifdef ULTRIX_STDIO_BOTCH
	if (PerlIO_eof(fp))
	    (void)PerlIO_seek(fp, 0L, 2);	/* ultrix 1.2 workaround */
#endif
d1408 2
a1409 1
	if (PL_laststatval < 0 && ckWARN(WARN_NEWLINE) && strchr(s, '\n'))
d1411 2
d1426 1
d1435 1
d1451 16
a1466 3
    if (SvROK(sv) && isGV_with_GP(SvRV(sv)) && ckWARN(WARN_IO)) {
        Perl_warner(aTHX_ packWARN(WARN_IO), "Use of -l on filehandle %s",
           GvENAME((const GV *)SvRV(sv)));
d1471 5
a1475 2
    if (PL_laststatval < 0 && ckWARN(WARN_NEWLINE) && strchr(file, '\n'))
	Perl_warner(aTHX_ packWARN(WARN_NEWLINE), PL_warn_nl, "lstat");
d1488 2
a1489 1
	PerlLIO_write(fd, (void*)&e, sizeof(int));
d1751 1
a1751 1
		    const char *name = SvPV_nomg_const_nolen(*mark);
d1753 4
a1756 2
		    if (PerlLIO_chmod(name, val))
			tot--;
d1787 1
a1787 1
		    const char *name = SvPV_nomg_const_nolen(*mark);
d1789 2
a1790 1
		    if (PerlLIO_chown(name, val, val2))
d1792 1
a1874 4
	    if (killgp)
	    {
                proc = -proc;
	    }
d1876 8
a1883 1
	    if (PerlProc_kill(proc, val))
d1893 1
a1893 1
	    s = SvPV_nolen_const(*mark);
d1895 4
a1898 1
	    if (PerlProc_geteuid() || PL_unsafe) {
d1903 3
a1905 1
		if (PerlLIO_lstat(s,&PL_statbuf) < 0 || S_ISDIR(PL_statbuf.st_mode))
d1907 2
d1978 1
a1978 1
		    const char * const name = SvPV_nomg_const_nolen(*mark);
d1980 4
d2237 4
d2242 1
a2242 1
            unsemds.buff = (struct semid_ds *)a;
d2244 1
a2244 1
            unsemds.buf = (struct semid_ds *)a;
d2246 1
a2324 1
#ifndef INCOMPLETE_TAINTS
a2326 1
#endif
a2374 9
        t = temps;
        o = ops;
        i = nsops;
        while (i--) {
            *o++ = t->sem_num;
            *o++ = t->sem_op;
            *o++ = t->sem_flg;
            t++;
        }
a2423 1
#ifndef INCOMPLETE_TAINTS
a2425 1
#endif
d2452 1
a2452 1
perl on VMS). This code used to be inline, but now perl uses C<File::Glob>
d2465 2
d2470 3
a2509 3
#if 'z' - 'a' == 25
    sv_catpv(tmpcmd, "|tr -s ' \t\f\r' '\\012\\012\\012\\012'|");
#else
a2510 1
#endif
d2523 2
a2524 2
    (void)do_open(PL_last_in_gv, (char*)SvPVX_const(tmpcmd), SvCUR(tmpcmd),
		  FALSE, O_RDONLY, 0, NULL);
d2528 6
@


1.16
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d64 1
a64 1
Perl_do_openn(pTHX_ GV *gv, register const char *oname, I32 len, int as_raw,
d69 1
a69 1
    register IO * const io = GvIOn(gv);
d323 4
a326 1
		    if (num_svs && (SvIOK(*svp) || (SvPOK(*svp) && looks_like_number(*svp)))) {
d626 1
a626 1
                        Perl_vmssetuserlnm(aTHX_ "SYS$OUTPUT", newname);
d628 1
a628 1
                        Perl_vmssetuserlnm(aTHX_ "SYS$ERROR",  newname);
d709 1
a709 1
Perl_nextargv(pTHX_ register GV *gv)
d712 1
a712 1
    register SV *sv;
d750 1
d809 1
a809 1
#if !defined(DOSISH) && !defined(__CYGWIN__) && !defined(EPOC)
d911 1
a911 1
	    SvREFCNT_dec(oldout);
d997 1
a997 1
    register IO * const io = GvIO(gv);
d1043 1
a1043 1
    register PerlIO *fp;
d1064 1
a1064 1
    register PerlIO *fp;
d1083 1
a1083 1
    register PerlIO *fp;
d1202 1
a1202 1
Perl_do_print(pTHX_ register SV *sv, PerlIO *fp)
d1226 2
a1227 2
	if (PerlIO_isutf8(fp)) {
	    if (!SvUTF8(sv)) {
d1235 3
a1237 2
	}
	else if (DO_UTF8(sv)) {
d1242 3
d1249 2
a1250 1
	    else {
a1282 1
	EXTEND(SP,1);
d1303 1
a1303 4
    else {
      SV* const sv = PL_op->op_private & OPpFT_STACKING ? TOPs : POPs;
      PUTBACK;
      if ((PL_op->op_private & (OPpFT_STACKED|OPpFT_AFTER_t))
d1306 2
a1307 1
      else {
a1327 1
      }
d1336 1
a1336 1
    static const char no_prev_lstat[] = "The stat preceding -l _ wasn't an lstat";
a1337 1
    SV *sv;
d1339 1
a1340 1
	EXTEND(SP,1);
d1343 1
a1343 1
		Perl_croak(aTHX_ no_prev_lstat);
a1353 2
    sv = PL_op->op_private & OPpFT_STACKING ? TOPs : POPs;
    PUTBACK;
d1357 1
a1357 1
	Perl_croak(aTHX_ no_prev_lstat);
d1359 1
a1359 1
    } 
d1363 4
d1390 1
a1390 1
Perl_do_aexec5(pTHX_ SV *really, register SV **mark, register SV **sp,
d1445 2
a1446 2
    register const char **a;
    register char *s;
d1507 1
a1507 1
    while (isALNUM(*s))
d1574 4
d1579 1
a1579 1
Perl_apply(pTHX_ I32 type, register SV **mark, register SV **sp)
d1582 2
a1583 2
    register I32 val;
    register I32 tot = 0;
d1588 1
d1592 2
d1609 1
a1609 1
	if (PL_tainted) { TAINT_PROPER(what); }				\
d1613 1
a1613 1
    if (PL_tainting) {
d1658 1
a1658 1
            register I32 val2;
d1701 6
d1716 1
d1718 6
a1727 1
	if (val < 0) val = -val;
a1728 1
#	    include <starlet.h>
d1735 1
a1735 1
		register unsigned long int __vmssts;
d1760 9
a1768 27
	if (val < 0) {
	    val = -val;
	    while (++mark <= sp) {
		I32 proc;
		SvGETMAGIC(*mark);
		if (!(SvIOK(*mark) || SvNOK(*mark) || looks_like_number(*mark)))
		    Perl_croak(aTHX_ "Can't kill a non-numeric process ID");
		proc = SvIV_nomg(*mark);
		APPLY_TAINT_PROPER();
#ifdef HAS_KILLPG
		if (PerlProc_killpg(proc,val))	/* BSD */
#else
		if (PerlProc_kill(-proc,val))	/* SYSV */
#endif
		    tot--;
	    }
	}
	else {
	    while (++mark <= sp) {
		I32 proc;
		SvGETMAGIC(*mark);
		if (!(SvIOK(*mark) || SvNOK(*mark) || looks_like_number(*mark)))
		    Perl_croak(aTHX_ "Can't kill a non-numeric process ID");
		proc = SvIV_nomg(*mark);
		APPLY_TAINT_PROPER();
		if (PerlProc_kill(proc, val))
		    tot--;
d1770 3
d1884 1
a1884 1
Perl_cando(pTHX_ Mode_t mode, bool effective, register const Stat_t *statbufp)
d2165 1
d2208 1
d2296 2
a2299 1
	SvUPGRADE(mstr, SVt_PV);
d2325 1
d2419 1
a2419 1
 * indent-tabs-mode: t
d2422 1
a2422 1
 * ex: set ts=8 sts=4 sw=4 noet:
@


1.15
log
@merge in perl 5.12.2 plus local changes
@
text
@d129 3
a131 2
			  "Warning: unable to close filehandle %s properly.\n",
			  GvENAME(gv));
d152 2
a153 1
	     Perl_croak(aTHX_ "panic: sysopen with multiple args");
d219 2
a220 1
	    name = SvOK(*svp) ? savesvpv (*svp) : savepvs ("");
d546 2
a547 1
			    "Filehandle STD%s reopened as %s only for input",
d549 1
a549 1
			    GvENAME(gv));
d553 3
a555 2
			    "Filehandle STDIN reopened as %s only for output",
			    GvENAME(gv));
a867 2
#  if !(defined(WIN32) && defined(__BORLANDC__))
		/* Borland runtime creates a readonly file! */
a868 1
#  endif
d933 1
a933 2
	    if (ckWARN(WARN_UNOPENED)) /* no check for closed here */
		report_evil_fh(gv, io, PL_op->op_type);
d999 2
a1000 2
    else if ((IoTYPE(io) == IoTYPE_WRONLY) && ckWARN(WARN_IO))
	report_evil_fh(gv, io, OP_phoney_OUTPUT_ONLY);
d1038 1
a1038 1
    register IO *io = NULL;
d1043 1
a1043 1
    if (gv && (io = GvIO(gv)) && (fp = IoIFP(io))) {
d1050 1
a1050 2
    if (ckWARN2(WARN_UNOPENED,WARN_CLOSED))
	report_evil_fh(gv, io, PL_op->op_type);
d1059 1
a1059 1
    register IO *io = NULL;
d1062 1
a1062 1
    if (gv && (io = GvIO(gv)) && (fp = IoIFP(io))) {
d1069 1
a1069 2
    if (ckWARN2(WARN_UNOPENED,WARN_CLOSED))
	report_evil_fh(gv, io, PL_op->op_type);
d1078 1
a1078 1
    register IO *io = NULL;
d1083 1
a1083 1
    if (gv && (io = GvIO(gv)) && (fp = IoIFP(io)))
d1085 1
a1085 2
    if (ckWARN2(WARN_UNOPENED,WARN_CLOSED))
	report_evil_fh(gv, io, PL_op->op_type);
d1228 3
d1244 6
a1249 1
				 "Wide character in print");
d1266 1
a1266 1
Perl_my_stat(pTHX)
d1282 1
a1282 1
        PL_statgv = gv;
a1288 4
            } else {
                if (ckWARN2(WARN_UNOPENED,WARN_CLOSED))
                    report_evil_fh(gv, io, PL_op->op_type);
                return (PL_laststatval = -1);
a1289 4
	} else {
            if (ckWARN2(WARN_UNOPENED,WARN_CLOSED))
                report_evil_fh(gv, io, PL_op->op_type);
            return (PL_laststatval = -1);
d1291 3
d1295 5
a1299 1
    else if (PL_op->op_private & OPpFT_STACKED) {
d1301 1
a1301 3
    }
    else {
	SV* const sv = POPs;
d1304 1
a1304 7
	PUTBACK;
	if (isGV_with_GP(sv)) {
	    gv = MUTABLE_GV(sv);
	    goto do_fstat;
	}
	else if (SvROK(sv) && isGV_with_GP(SvRV(sv))) {
	    gv = MUTABLE_GV(SvRV(sv));
d1313 1
a1313 1
	s = SvPV_const(sv, len);
d1322 1
d1328 1
a1328 1
Perl_my_lstat(pTHX)
d1342 1
d1344 3
a1346 3
	    Perl_warner(aTHX_ packWARN(WARN_IO), "Use of -l on filehandle %s",
		    GvENAME(cGVOP_gv));
	    return (PL_laststatval = -1);
d1348 1
d1350 5
a1354 2
    else if (PL_laststype != OP_LSTAT
	    && (PL_op->op_private & OPpFT_STACKED) && ckWARN(WARN_IO))
d1356 2
d1361 1
a1361 8
    sv = POPs;
    PUTBACK;
    if (SvROK(sv) && isGV_with_GP(SvRV(sv)) && ckWARN(WARN_IO)) {
	Perl_warner(aTHX_ packWARN(WARN_IO), "Use of -l on filehandle %s",
		GvENAME((const GV *)SvRV(sv)));
	return (PL_laststatval = -1);
    }
    file = SvPV_nolen_const(sv);
d1576 1
d1618 1
a1618 3
                if (isGV_with_GP(*mark)) {
                    gv = MUTABLE_GV(*mark);
		do_fchmod:
a1631 4
		else if (SvROK(*mark) && isGV_with_GP(SvRV(*mark))) {
		    gv = MUTABLE_GV(SvRV(*mark));
		    goto do_fchmod;
		}
d1633 1
a1633 1
		    const char *name = SvPV_nolen_const(*mark);
d1652 1
a1652 3
                if (isGV_with_GP(*mark)) {
                    gv = MUTABLE_GV(*mark);
		do_fchown:
a1665 4
		else if (SvROK(*mark) && isGV_with_GP(SvRV(*mark))) {
		    gv = MUTABLE_GV(SvRV(*mark));
		    goto do_fchown;
		}
d1667 1
a1667 1
		    const char *name = SvPV_nolen_const(*mark);
d1687 1
a1687 1
	s = SvPVx_nolen_const(*++mark);
d1689 1
a1689 1
	    if (*s == 'S' && s[1] == 'I' && s[2] == 'G')
d1691 4
a1694 2
	    if ((val = whichsig(s)) < 0)
		Perl_croak(aTHX_ "Unrecognized signal name \"%s\"",s);
d1712 1
d1715 1
a1715 1
		proc = SvIV(*mark);
d1732 1
d1740 1
d1743 1
a1743 1
		proc = SvIV(*mark);
d1756 1
d1759 1
a1759 1
		proc = SvIV(*mark);
d1765 1
d1774 1
a1774 1
	    if (PL_euid || PL_unsafe) {
d1834 1
a1834 3
                if (isGV_with_GP(*mark)) {
                    gv = MUTABLE_GV(*mark);
		do_futimes:
a1848 4
		else if (SvROK(*mark) && isGV_with_GP(SvRV(*mark))) {
		    gv = MUTABLE_GV(SvRV(*mark));
		    goto do_futimes;
		}
d1850 1
a1850 1
		    const char * const name = SvPV_nolen_const(*mark);
d1888 1
a1888 1
     * by the Miscrosoft C library stat() function for the following:
d1912 1
a1912 1
    if ((effective ? PL_euid : PL_uid) == 0) {	/* root is special */
d1922 1
a1922 1
    if (statbufp->st_uid == (effective ? PL_euid : PL_uid) ) {
d1941 1
a1941 1
    if (testgid == (effective ? PL_egid : PL_gid))
d2287 2
a2288 1
	SvPV_force_nolen(mstr);
d2384 10
@


1.14
log
@Merge in perl 5.10.1
@
text
@d315 1
d402 1
d436 1
a631 1
                LOCK_FDPID_MUTEX;
a638 1
                UNLOCK_FDPID_MUTEX;
d761 3
a763 4
		    if (ckWARN_d(WARN_INPLACE))	
		        Perl_warner(aTHX_ packWARN(WARN_INPLACE),
			    "Can't do inplace edit: %s is not a regular file",
		            PL_oldname );
d767 1
a767 1
		if (*PL_inplace) {
d792 3
a794 4
			if (ckWARN_d(WARN_INPLACE))	
			    Perl_warner(aTHX_ packWARN(WARN_INPLACE),
			      "Can't do inplace edit: %"SVf" would not be unique",
			      SVfARG(sv));
d802 3
a804 4
		        if (ckWARN_d(WARN_INPLACE))	
			    Perl_warner(aTHX_ packWARN(WARN_INPLACE),
			      "Can't rename %s to %"SVf": %s, skipping file",
			      PL_oldname, SVfARG(sv), Strerror(errno));
d817 3
a819 4
		        if (ckWARN_d(WARN_INPLACE))	
			    Perl_warner(aTHX_ packWARN(WARN_INPLACE),
			      "Can't rename %s to %"SVf": %s, skipping file",
			      PL_oldname, SVfARG(sv), Strerror(errno) );
d830 3
a832 4
		        if (ckWARN_d(WARN_INPLACE))	
			    Perl_warner(aTHX_ packWARN(WARN_INPLACE),
			      "Can't remove %s: %s, skipping file",
			      PL_oldname, Strerror(errno) );
d852 2
a853 3
		    if (ckWARN_d(WARN_INPLACE))	
		        Perl_warner(aTHX_ packWARN(WARN_INPLACE), "Can't do inplace edit on %s: %s",
		          PL_oldname, Strerror(errno) );
d1093 1
a1093 1
Perl_mode_from_discipline(pTHX_ SV *discp)
d1096 1
a1096 3
    if (discp) {
	STRLEN len;
	const char *s = SvPV_const(discp,len);
d1242 2
a1243 4
		if (ckWARN_d(WARN_UTF8)) {
		    Perl_warner(aTHX_ packWARN(WARN_UTF8),
				"Wide character in print");
		}
d1391 1
a1391 1
#if defined(MACOS_TRADITIONAL) || defined(__SYMBIAN32__) || defined(__LIBCATAMOUNT__)
d1721 1
a1721 1
		I32 proc = SvIV(*mark);
d1723 3
d1748 4
a1751 1
		const I32 proc = SvIV(*mark);
d1763 4
a1766 1
		const I32 proc = SvIV(*mark);
d1921 3
d1925 1
d1949 2
a1950 2
bool
Perl_ingroup(pTHX_ Gid_t testgid, bool effective)
a1951 4
#ifdef MACOS_TRADITIONAL
    /* This is simply not correct for AppleShare, but fix it yerself. */
    return TRUE;
#else
a1975 1
#endif
d2008 1
d2069 1
d2076 1
d2124 1
d2166 1
d2208 1
d2263 1
d2322 1
a2363 5
#ifdef MACOS_TRADITIONAL
    sv_setpv(tmpcmd, "glob ");
    sv_catsv(tmpcmd, tmpglob);
    sv_catpv(tmpcmd, " |");
#else
a2394 1
#endif /* MACOS_TRADITIONAL */
@


1.13
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d3 2
a4 2
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, by Larry Wall and others
d12 6
a17 4
 * "Far below them they saw the white waters pour into a foaming bowl, and
 * then swirl darkly about a deep oval basin in the rocks, until they found
 * their way out again through a narrow gate, and flowed away, fuming and
 * chattering, into calmer and more level reaches."
d84 2
d183 1
a183 1
	namesv = sv_2mortal(newSVpvn(oname,len));
d217 1
a217 1
	    name = SvOK(*svp) ? savesvpv (*svp) : savepvn ("", 0);
d406 1
a406 1
			namesv = sv_2mortal(newSVpvn(type,tend - type));
d439 1
a439 1
		    namesv = sv_2mortal(newSVpvn(type,tend - type));
d518 1
a518 1
		    namesv = sv_2mortal(newSVpvn(type,tend - type));
d666 1
a666 1
	const int save_errno = errno;
d668 1
a668 1
	errno = save_errno;
d712 2
d771 1
a771 1
			sv_setpvn(sv, "", 0);
d814 1
a814 2
		    do_open(gv,(char*)SvPVX_const(sv),SvCUR(sv),PL_inplace!=0,
			    O_RDONLY,0,NULL);
d846 1
a846 2
		sv_setpvn(sv,">",!PL_inplace);
		sv_catpvn(sv,PL_oldname,oldlen);
d848 2
d851 1
a851 2
		if (!do_open(PL_argvoutgv,(char*)SvPVX_const(sv),SvCUR(sv),
			     PL_inplace!=0,O_WRONLY|O_CREAT|O_TRUNC,0,NULL))
d853 1
a853 3
		    if (!do_open(PL_argvoutgv,(char*)SvPVX_const(sv),SvCUR(sv),
			     PL_inplace!=0,O_WRONLY|O_CREAT|OPEN_EXCL,0666,
			     NULL))
d855 1
a855 1
		{
d908 1
a908 1
	    GV * const oldout = (GV*)av_pop(PL_argvout_stack);
d928 1
a928 1
    if (!gv || SvTYPE(gv) != SVt_PVGV) {
d958 2
d999 2
d1014 1
a1014 1
	    const int saverrno = errno;
d1018 1
a1018 1
		errno = saverrno;
d1021 1
a1021 1
	    errno = saverrno;
d1045 2
d1087 2
d1210 3
d1286 1
a1286 1
        sv_setpvn(PL_statname, "", 0);
d1311 2
a1312 2
	if (SvTYPE(sv) == SVt_PVGV) {
	    gv = (GV*)sv;
d1315 2
a1316 2
	else if (SvROK(sv) && SvTYPE(SvRV(sv)) == SVt_PVGV) {
	    gv = (GV*)SvRV(sv);
d1320 1
a1320 1
            io = (IO*)SvRV(sv);
d1345 1
d1367 1
a1367 1
    if (SvROK(sv) && SvTYPE(SvRV(sv)) == SVt_PVGV && ckWARN(WARN_IO)) {
d1369 1
a1369 1
		GvENAME((GV*) SvRV(sv)));
d1372 4
a1375 4
    /* XXX Do really need to be calling SvPV() all these times? */
    sv_setpv(PL_statname,SvPV_nolen_const(sv));
    PL_laststatval = PerlLIO_lstat(SvPV_nolen_const(sv),&PL_statcache);
    if (PL_laststatval < 0 && ckWARN(WARN_NEWLINE) && strchr(SvPV_nolen_const(sv), '\n'))
d1384 1
d1399 1
d1404 1
a1404 1
	char **a;
d1406 1
a1406 1
	Newx(PL_Argv, sp - mark + 1, char*);
d1411 1
a1411 1
		*a++ = (char*)SvPV_nolen_const(*mark);
d1450 1
a1450 1
    register char **a;
a1453 1

d1456 3
d1548 1
a1548 1
    Newx(PL_Argv, (s - cmd) / 2 + 2, char*);
d1564 1
a1564 1
	PerlProc_execvp(PL_Argv[0],PL_Argv);
d1589 2
d1628 2
a1629 2
                if (SvTYPE(*mark) == SVt_PVGV) {
                    gv = (GV*)*mark;
d1644 2
a1645 2
		else if (SvROK(*mark) && SvTYPE(SvRV(*mark)) == SVt_PVGV) {
		    gv = (GV*)SvRV(*mark);
d1668 2
a1669 2
                if (SvTYPE(*mark) == SVt_PVGV) {
                    gv = (GV*)*mark;
d1684 2
a1685 2
		else if (SvROK(*mark) && SvTYPE(SvRV(*mark)) == SVt_PVGV) {
		    gv = (GV*)SvRV(*mark);
d1840 2
a1841 2
                if (SvTYPE(*mark) == SVt_PVGV) {
                    gv = (GV*)*mark;
d1857 2
a1858 2
		else if (SvROK(*mark) && SvTYPE(SvRV(*mark)) == SVt_PVGV) {
		    gv = (GV*)SvRV(*mark);
d1893 3
d1986 1
a1986 1
    const I32 n = (optype == OP_MSGGET) ? 0 : SvIVx(*++mark);
d1989 1
d2001 1
a2001 1
	return semget(key, n, flags);
d2005 1
a2005 1
	return shmget(key, n, flags);
d2030 1
d2153 1
d2177 2
d2183 1
a2183 1
	sv_setpvn(mstr, "", 0);
d2217 2
d2273 2
d2292 1
a2292 1
	    sv_setpvn(mstr, "", 0);
d2341 3
@


1.12
log
@merge in perl 5.8.8
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006, by Larry Wall and others
d62 1
a62 19
Perl_do_open(pTHX_ GV *gv, register char *name, I32 len, int as_raw,
	     int rawmode, int rawperm, PerlIO *supplied_fp)
{
    return do_openn(gv, name, len, as_raw, rawmode, rawperm,
		    supplied_fp, (SV **) NULL, 0);
}

bool
Perl_do_open9(pTHX_ GV *gv, register char *name, I32 len, int as_raw,
	      int rawmode, int rawperm, PerlIO *supplied_fp, SV *svs,
	      I32 num_svs)
{
    PERL_UNUSED_ARG(num_svs);
    return do_openn(gv, name, len, as_raw, rawmode, rawperm,
		    supplied_fp, &svs, 1);
}

bool
Perl_do_openn(pTHX_ GV *gv, register char *name, I32 len, int as_raw,
d66 1
d68 2
a69 2
    PerlIO *saveifp = Nullfp;
    PerlIO *saveofp = Nullfp;
d79 1
a79 1
    char mode[PERL_MODE_MAX];	/* stdio file mode ("r\0", "rb\0", "r+b\0" etc.) */
d128 1
a128 1
	IoOFP(io) = IoIFP(io) = Nullfp;
d179 1
a179 1
	namesv = sv_2mortal(newSVpvn(name,strlen(name)));
d182 1
a182 1
        type = Nullch;
d187 1
a187 1
	char *oname = name;
a190 1
	PerlIO *that_fp = NULL;
d192 1
a192 1
	type = savepvn(name, len);
d197 2
a198 1
        for (; isSPACE(*type); type++) ;
d205 1
a205 1
	    if (SvROK(*svp) && !strchr(name,'&')) {
d237 3
a239 1
	    for (type++; isSPACE(*type); type++) ;
d251 1
a251 1
	    if ((*name == '-' && name[1] == '\0') || num_svs)
a260 1
#ifdef HAS_STRLCAT
d262 1
a262 1
                strlcat(mode, "b", PERL_MODE_MAX);
d264 1
a264 7
                strlcat(mode, "t", PERL_MODE_MAX); 
#else
	    if (out_raw)
		strcat(mode, "b");
	    else if (out_crlf)
		strcat(mode, "t");
#endif
a291 1
#ifdef HAS_STRLCAT
d293 1
a293 1
                strlcat(mode, "b", PERL_MODE_MAX);
d295 1
a295 7
                strlcat(mode, "t", PERL_MODE_MAX);
#else
	    if (out_raw)
		strcat(mode, "b");
	    else if (out_crlf)
		strcat(mode, "t");
#endif
d309 1
d313 2
a314 1
		    for (; isSPACE(*type); type++) ;
d328 2
a329 2
			    GV *thatgv;
			    thatgv = gv_fetchpv(type,FALSE,SVt_PVIO);
d373 1
a373 1
			type = Nullch;
d390 2
a391 1
		for (; isSPACE(*type); type++) ;
d402 1
a402 1
			namesv = sv_2mortal(newSVpvn(type,strlen(type)));
d405 1
a405 1
		        type = Nullch;
d414 3
a416 1
	    for (type++; isSPACE(*type); type++) ;
a417 1
#ifdef HAS_STRLCAT
d419 1
a419 1
                strlcat(mode, "b", PERL_MODE_MAX);
d421 1
a421 7
                strlcat(mode, "t", PERL_MODE_MAX);
#else
	    if (in_raw)
		strcat(mode, "b");
	    else if (in_crlf)
		strcat(mode, "t");
#endif
d435 1
a435 1
		    namesv = sv_2mortal(newSVpvn(type,strlen(type)));
d438 1
a438 1
		    type = Nullch;
a471 1
#ifdef HAS_STRLCAT
d473 1
a473 1
                strlcat(mode, "b", PERL_MODE_MAX);
d475 1
a475 7
                strlcat(mode, "t", PERL_MODE_MAX);
#else
	    if (in_raw)
		strcat(mode, "b");
	    else if (in_crlf)
		strcat(mode, "t");
#endif
d485 2
a486 1
		for (; isSPACE(*type); type++) ;
a502 1
#ifdef HAS_STRLCAT
d504 1
a504 1
                strlcat(mode, "b", PERL_MODE_MAX);
d506 1
a506 7
                strlcat(mode, "t", PERL_MODE_MAX);
#else
	    if (in_raw)
		strcat(mode, "b");
	    else if (in_crlf)
		strcat(mode, "t");
#endif
d514 1
a514 1
		    namesv = sv_2mortal(newSVpvn(type,strlen(type)));
d517 1
a517 1
		    type = Nullch;
d525 1
a525 1
	    && strchr(name, '\n')
d627 1
a627 1
                (void)SvUPGRADE(sv, SVt_IV);
d631 1
a631 1
                (void)SvUPGRADE(sv, SVt_IV);
d662 1
a662 1
	int save_errno = errno;
d679 1
a679 1
		IoIFP(io) = Nullfp;
d698 1
d709 1
a709 1
	PL_argvoutgv = gv_fetchpv("ARGVOUT",TRUE,SVt_PVIO);
d713 3
a715 3
	    if (!PL_argvout_stack)
		PL_argvout_stack = newAV();
	    av_push(PL_argvout_stack, SvREFCNT_inc(PL_defoutgv));
d730 1
a730 1
        return Nullfp;
d738 1
a738 1
	if (do_open(gv,PL_oldname,oldlen,PL_inplace!=0,O_RDONLY,0,Nullfp)) {
d742 2
a743 1
		    setdefout(gv_fetchpv("STDOUT",TRUE,SVt_PVIO));
d789 1
a789 1
			      sv);
d800 1
a800 1
			      PL_oldname, sv, Strerror(errno) );
d809 1
a809 1
			    O_RDONLY,0,Nullfp);
d817 1
a817 1
			      PL_oldname, sv, Strerror(errno) );
d846 1
a846 1
			     PL_inplace!=0,O_WRONLY|O_CREAT|O_TRUNC,0,Nullfp))
d850 1
a850 1
			     Nullfp))
d905 1
a905 1
	    GV *oldout = (GV*)av_pop(PL_argvout_stack);
d908 1
a908 1
	    return Nullfp;
d910 1
a910 1
	setdefout(gv_fetchpv("STDOUT",TRUE,SVt_PVIO));
d912 1
a912 1
    return Nullfp;
a914 46
#ifdef HAS_PIPE
void
Perl_do_pipe(pTHX_ SV *sv, GV *rgv, GV *wgv)
{
    register IO *rstio;
    register IO *wstio;
    int fd[2];

    if (!rgv)
	goto badexit;
    if (!wgv)
	goto badexit;

    rstio = GvIOn(rgv);
    wstio = GvIOn(wgv);

    if (IoIFP(rstio))
	do_close(rgv,FALSE);
    if (IoIFP(wstio))
	do_close(wgv,FALSE);

    if (PerlProc_pipe(fd) < 0)
	goto badexit;
    IoIFP(rstio) = PerlIO_fdopen(fd[0], "r"PIPE_OPEN_MODE);
    IoOFP(wstio) = PerlIO_fdopen(fd[1], "w"PIPE_OPEN_MODE);
    IoOFP(rstio) = IoIFP(rstio);
    IoIFP(wstio) = IoOFP(wstio);
    IoTYPE(rstio) = IoTYPE_RDONLY;
    IoTYPE(wstio) = IoTYPE_WRONLY;
    if (!IoIFP(rstio) || !IoOFP(wstio)) {
	if (IoIFP(rstio)) PerlIO_close(IoIFP(rstio));
	else PerlLIO_close(fd[0]);
	if (IoOFP(wstio)) PerlIO_close(IoOFP(wstio));
	else PerlLIO_close(fd[1]);
	goto badexit;
    }

    sv_setsv(sv,&PL_sv_yes);
    return;

badexit:
    sv_setsv(sv,&PL_sv_undef);
    return;
}
#endif

d919 1
d952 1
d959 2
a960 2
		STATUS_NATIVE_SET(status);
		retval = (STATUS_POSIX == 0);
d970 1
a970 1
		bool prev_err = PerlIO_error(IoOFP(io));
d975 1
a975 1
		bool prev_err = PerlIO_error(IoIFP(io));
d979 1
a979 1
	IoOFP(io) = IoIFP(io) = Nullfp;
d991 2
a992 4
    register IO *io;
    int ch;

    io = GvIO(gv);
a999 2
        int saverrno;

d1005 9
a1013 4
	saverrno = errno; /* getc and ungetc can stomp on errno */
	ch = PerlIO_getc(IoIFP(io));
	if (ch != EOF) {
	    (void)PerlIO_ungetc(IoIFP(io),ch);
a1014 1
	    return FALSE;
a1015 1
	errno = saverrno;
d1034 2
a1035 1
    register IO *io = 0;
d1054 2
a1055 1
    register IO *io = 0;
d1074 2
a1075 1
    register IO *io = 0;
a1141 14
int
Perl_do_binmode(pTHX_ PerlIO *fp, int iotype, int mode)
{
 /* The old body of this is now in non-LAYER part of perlio.c
  * This is a stub for any XS code which might have been calling it.
  */
 const char *name = ":raw";
#ifdef PERLIO_USING_CRLF
 if (!(mode & O_BINARY))
     name = ":crlf";
#endif
 return PerlIO_binmode(aTHX_ fp, iotype, mode, name);
}

a1149 1
    struct flock fl;
d1169 1
a1169 1

d1198 1
a1198 3
    register const char *tmps;
    STRLEN len;

d1202 15
a1216 30
    if (PL_ofmt) {
	if (SvGMAGICAL(sv))
	    mg_get(sv);
        if (SvIOK(sv) && SvIVX(sv) != 0) {
	    PerlIO_printf(fp, PL_ofmt, (NV)SvIVX(sv));
	    return !PerlIO_error(fp);
	}
	if (  (SvNOK(sv) && SvNVX(sv) != 0.0)
	   || (looks_like_number(sv) && sv_2nv(sv) != 0.0) ) {
	    PerlIO_printf(fp, PL_ofmt, SvNVX(sv));
	    return !PerlIO_error(fp);
	}
    }
    switch (SvTYPE(sv)) {
    case SVt_NULL:
	if (ckWARN(WARN_UNINITIALIZED))
	    report_uninit();
	return TRUE;
    case SVt_IV:
	if (SvIOK(sv)) {
	    if (SvGMAGICAL(sv))
		mg_get(sv);
	    if (SvIsUV(sv))
		PerlIO_printf(fp, "%"UVuf, (UV)SvUVX(sv));
	    else
		PerlIO_printf(fp, "%"IVdf, (IV)SvIVX(sv));
	    return !PerlIO_error(fp);
	}
	/* FALL THROUGH */
    default:
d1218 5
a1222 3
	    if (!SvUTF8(sv))
		sv_utf8_upgrade_flags(sv = sv_mortalcopy(sv),
				      SV_GMAGIC|SV_UTF8_NO_ENCODING);
d1225 14
a1238 4
	    if (!sv_utf8_downgrade((sv = sv_mortalcopy(sv)), TRUE)
		&& ckWARN_d(WARN_UTF8))
	    {
		Perl_warner(aTHX_ packWARN(WARN_UTF8), "Wide character in print");
d1241 10
a1250 2
	tmps = SvPV_const(sv, len);
	break;
a1251 9
    /* To detect whether the process is about to overstep its
     * filesize limit we would need getrlimit().  We could then
     * also transparently raise the limit with setrlimit() --
     * but only until the system hard limit/the filesystem limit,
     * at which we would get EPERM.  Note that when using buffered
     * io the write failure can be delayed until the flush/close. --jhi */
    if (len && (PerlIO_write(fp,tmps,len) == 0))
	return FALSE;
    return !PerlIO_error(fp);
d1257 1
d1266 2
d1269 22
a1290 15
	if (io && IoIFP(io)) {
	    PL_statgv = gv;
	    sv_setpvn(PL_statname,"", 0);
	    PL_laststype = OP_STAT;
	    return (PL_laststatval = PerlLIO_fstat(PerlIO_fileno(IoIFP(io)), &PL_statcache));
	}
	else {
	    if (gv == PL_defgv)
		return PL_laststatval;
	    if (ckWARN2(WARN_UNOPENED,WARN_CLOSED))
		report_evil_fh(gv, io, PL_op->op_type);
	    PL_statgv = Nullgv;
	    sv_setpvn(PL_statname,"", 0);
	    return (PL_laststatval = -1);
	}
d1293 1
a1293 1
	SV* sv = POPs;
d1305 5
d1312 1
a1312 1
	PL_statgv = Nullgv;
a1322 1
static const char no_prev_lstat[] = "The stat preceding -l _ wasn't an lstat";
d1327 2
d1344 3
d1349 1
a1349 1
    PL_statgv = Nullgv;
d1365 2
a1366 3
#ifndef OS2
bool
Perl_do_aexec(pTHX_ SV *really, register SV **mark, register SV **sp)
d1368 8
a1375 1
    return do_aexec5(really, mark, sp, 0, 0);
a1376 1
#endif
d1382 2
a1383 1
#if defined(MACOS_TRADITIONAL) || defined(SYMBIAN)
d1388 1
a1388 1
	const char *tmps = Nullch;
d1398 1
a1398 1
	*a = Nullch;
d1410 1
a1410 9
	if (ckWARN(WARN_EXEC))
	    Perl_warner(aTHX_ packWARN(WARN_EXEC), "Can't exec \"%s\": %s",
		(really ? tmps : PL_Argv[0]), Strerror(errno));
	if (do_report) {
	    int e = errno;

	    PerlLIO_write(fd, (void*)&e, sizeof(int));
	    PerlLIO_close(fd);
	}
d1420 1
d1422 1
a1422 1
    PL_Argv = Null(char **);
d1424 1
a1424 1
    PL_Cmd = Nullch;
d1427 1
a1427 1
#if !defined(OS2) && !defined(WIN32) && !defined(DJGPP) && !defined(EPOC) && !defined(SYMBIAN) && !defined(MACOS_TRADITIONAL)
d1430 1
a1430 7
Perl_do_exec(pTHX_ char *cmd)
{
    return do_exec3(cmd,0,0);
}

bool
Perl_do_exec3(pTHX_ char *cmd, int fd, int do_report)
d1432 1
d1435 8
d1454 1
a1454 5
#ifdef HAS_STRLCPY
          strlcpy(flags, "-c", PERL_FLAGS_MAX);
#else
	  strcpy(flags,"-c");
#endif
d1458 1
a1458 5
#ifdef HAS_STRLCPY
              strlcat(flags, "f", PERL_FLAGS_MAX);
#else
	      strcat(flags,"f");
#endif
d1463 1
a1463 1
	      char *ncmd = s;
d1472 1
a1472 1
		  PerlProc_execl(PL_cshname,"csh", flags, ncmd, (char*)0);
d1475 2
d1492 3
a1494 1
    for (s = cmd; *s && isALNUM(*s); s++) ;	/* catch VAR=val gizmo */
d1521 1
a1521 1
	    PerlProc_execl(PL_sh_path, "sh", "-c", cmd, (char*)0);
d1523 2
d1533 2
a1534 1
	while (*s && isSPACE(*s)) s++;
d1537 2
a1538 1
	while (*s && !isSPACE(*s)) s++;
d1542 1
a1542 1
    *a = Nullch;
d1551 1
a1551 10
	{
	    if (ckWARN(WARN_EXEC))
		Perl_warner(aTHX_ packWARN(WARN_EXEC), "Can't exec \"%s\": %s",
		    PL_Argv[0], Strerror(errno));
	    if (do_report) {
		int e = errno;
		PerlLIO_write(fd, (void*)&e, sizeof(int));
		PerlLIO_close(fd);
	    }
	}
d1554 1
d1563 1
d1566 1
a1566 1
    const char *what;
d1570 13
a1599 1
	what = "chmod";
d1602 1
a1602 1
	    val = SvIVx(*mark);
a1637 1
	what = "chown";
a1684 1
	what = "kill";
d1692 1
a1692 1
	    if ((val = whichsig((char *)s)) < 0)
d1696 1
a1696 1
	    val = SvIVx(*mark);
d1709 1
a1709 1
		I32 proc = SvIVx(*mark);
d1733 1
a1733 1
		I32 proc = SvIVx(*mark);
d1745 1
a1745 1
		I32 proc = SvIVx(*mark);
a1753 1
	what = "unlink";
d1760 1
a1760 1
		if (UNLINK((char *)s))
d1767 1
a1767 1
		    if (UNLINK((char*)s))
d1773 1
a1773 1
#ifdef HAS_UTIME
a1774 1
	what = "utime";
d1777 4
a1780 1
#if defined(I_UTIME) || defined(VMS)
d1791 2
a1792 2
           SV* accessed = *++mark;
           SV* modified = *++mark;
d1802 8
a1809 3
#ifdef BIG_TIME
                utbuf.actime = (Time_t)SvNVx(accessed);  /* time accessed */
                utbuf.modtime = (Time_t)SvNVx(modified); /* time modified */
d1811 2
a1812 2
                utbuf.actime = (Time_t)SvIVx(accessed);  /* time accessed */
                utbuf.modtime = (Time_t)SvIVx(modified); /* time modified */
d1818 33
a1850 4
		char *name = SvPV_nolen(*mark);
		APPLY_TAINT_PROPER();
		if (PerlLIO_utime(name, utbufp))
		    tot--;
d1866 4
a1869 3
Perl_cando(pTHX_ Mode_t mode, Uid_t effective, register Stat_t *statbufp)
/* Note: we use "effective" both for uids and gids.
 * Here we are betting on Uid_t being equal or wider than Gid_t.  */
d1871 1
d1922 1
a1922 1
Perl_ingroup(pTHX_ Gid_t testgid, Uid_t effective)
d1928 1
d1949 2
a1951 1
    return FALSE;
d1960 2
a1961 1
    key_t key = (key_t)SvNVx(*++mark);
d1964 2
a1965 1
    (void)sp;
d1993 1
a1993 1
    SV *astr;
a1994 2
    STRLEN infosize;
    I32 getinfo;
d1997 1
d1999 1
d2001 4
a2006 4
    astr = *++mark;
    infosize = 0;
    getinfo = (cmd == IPC_STAT);

d2073 1
a2073 1
	IV i = SvIV(astr);
d2118 1
a2119 3
    SV *mstr;
    const char *mbuf;
    I32 msize, flags;
d2122 5
d2129 1
a2129 4
    mstr = *++mark;
    flags = SvIVx(*++mark);
    mbuf = SvPV_const(mstr, len);
    if ((msize = len - sizeof(long)) < 0)
d2134 2
d2144 1
a2144 1
    SV *mstr;
d2149 1
a2151 1
    mstr = *++mark;
d2173 2
d2183 1
a2183 2
    SV *opstr;
    const char *opbuf;
d2186 2
a2189 2
    opstr = *++mark;
    opbuf = SvPV_const(opstr, opsize);
d2200 1
a2200 1
        short *ops = (short *) opbuf;
d2235 1
a2235 1
    SV *mstr;
a2236 1
    I32 mpos, msize;
d2239 3
a2243 3
    mstr = *++mark;
    mpos = SvIVx(*++mark);
    msize = SvIVx(*++mark);
d2247 2
a2248 1
    if (mpos < 0 || msize < 0 || mpos + msize > shmds.shm_segsz) {
d2252 1
a2252 1
    shm = (char *)shmat(id, (char*)NULL, (optype == OP_SHMREAD) ? SHM_RDONLY : 0);
d2256 1
a2256 1
	const char *mbuf;
d2261 1
a2261 1
	mbuf = SvGROW(mstr, msize+1);
a2272 1
	I32 n;
d2276 1
a2276 2
	if ((n = len) > msize)
	    n = msize;
d2305 2
a2306 1
    SV * const tmpcmd = NEWSV(55, 0);
d2312 8
a2319 83
    {
#include <descrip.h>
#include <lib$routines.h>
#include <nam.h>
#include <rmsdef.h>
	char rslt[NAM$C_MAXRSS+1+sizeof(unsigned short int)] = {'\0','\0'};
	char vmsspec[NAM$C_MAXRSS+1];
	char * const rstr = rslt + sizeof(unsigned short int);
	char *begin, *end, *cp;
	$DESCRIPTOR(dfltdsc,"SYS$DISK:[]*.*;");
	PerlIO *tmpfp;
	STRLEN i;
	struct dsc$descriptor_s wilddsc
	    = {0, DSC$K_DTYPE_T, DSC$K_CLASS_S, 0};
	struct dsc$descriptor_vs rsdsc
	    = {sizeof rslt, DSC$K_DTYPE_VT, DSC$K_CLASS_VS, rslt};
	unsigned long int cxt = 0, sts = 0, ok = 1, hasdir = 0, hasver = 0, isunix = 0;

	/* We could find out if there's an explicit dev/dir or version
	   by peeking into lib$find_file's internal context at
	   ((struct NAM *)((struct FAB *)cxt)->fab$l_nam)->nam$l_fnb
	   but that's unsupported, so I don't want to do it now and
	   have it bite someone in the future. */
	cp = SvPV(tmpglob,i);
	for (; i; i--) {
	    if (cp[i] == ';') hasver = 1;
	    if (cp[i] == '.') {
		if (sts) hasver = 1;
		else sts = 1;
	    }
	    if (cp[i] == '/') {
		hasdir = isunix = 1;
		break;
	    }
	    if (cp[i] == ']' || cp[i] == '>' || cp[i] == ':') {
		hasdir = 1;
		break;
	    }
	}
       if ((tmpfp = PerlIO_tmpfile()) != NULL) {
	    Stat_t st;
	    if (!PerlLIO_stat(SvPVX_const(tmpglob),&st) && S_ISDIR(st.st_mode))
		ok = ((wilddsc.dsc$a_pointer = tovmspath((char *)SvPVX_const(tmpglob),vmsspec)) != NULL);
	    else ok = ((wilddsc.dsc$a_pointer = tovmsspec((char *)SvPVX_const(tmpglob),vmsspec)) != NULL);
	    if (ok) wilddsc.dsc$w_length = (unsigned short int) strlen(wilddsc.dsc$a_pointer);
	    for (cp=wilddsc.dsc$a_pointer; ok && cp && *cp; cp++)
		if (*cp == '?') *cp = '%';  /* VMS style single-char wildcard */
	    while (ok && ((sts = lib$find_file(&wilddsc,&rsdsc,&cxt,
					       &dfltdsc,NULL,NULL,NULL))&1)) {
		/* with varying string, 1st word of buffer contains result length */
		end = rstr + *((unsigned short int*)rslt);
		if (!hasver) while (*end != ';' && end > rstr) end--;
		*(end++) = '\n';  *end = '\0';
		for (cp = rstr; *cp; cp++) *cp = _tolower(*cp);
		if (hasdir) {
		    if (isunix) trim_unixpath(rstr,SvPVX(tmpglob),1);
		    begin = rstr;
		}
		else {
		    begin = end;
		    while (*(--begin) != ']' && *begin != '>') ;
		    ++begin;
		}
		ok = (PerlIO_puts(tmpfp,begin) != EOF);
	    }
	    if (cxt) (void)lib$find_file_end(&cxt);
	    if (ok && sts != RMS$_NMF &&
		sts != RMS$_DNF && sts != RMS_FNF) ok = 0;
	    if (!ok) {
		if (!(sts & 1)) {
		    SETERRNO((sts == RMS$_SYN ? EINVAL : EVMSERR),sts);
		}
		PerlIO_close(tmpfp);
		fp = NULL;
	    }
	    else {
		PerlIO_rewind(tmpfp);
		IoTYPE(io) = IoTYPE_RDONLY;
		IoIFP(io) = fp = tmpfp;
		IoFLAGS(io) &= ~IOf_UNTAINT;  /* maybe redundant */
	    }
	}
    }
d2359 1
a2359 1
		  FALSE, O_RDONLY, 0, Nullfp);
@


1.11
log
@sync in-tree perl with 5.8.6
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, by Larry Wall and others
d56 3
d74 1
d84 1
a84 1
    register IO *io = GvIOn(gv);
d96 1
a96 1
    char mode[8];		/* stdio file mode ("r\0", "rb\0", "r+b\0" etc.) */
d105 1
a105 1
	U8 flags = PL_op->op_private;
d151 1
a151 1
	int appendtrunc =
d160 1
a160 2
	int modifyingmode =
	     O_WRONLY|O_RDWR|O_CREAT|appendtrunc;
a214 1
        /*SUPPRESS 530*/
a220 1
	    STRLEN l = 0;
d230 1
a230 3
	    name = SvOK(*svp) ? SvPV(*svp, l) : "";
	    len = (I32)l;
	    name = savepvn(name, len);
a253 1
	    /*SUPPRESS 530*/
d266 1
a266 1
	    if (strNE(name,"-") || num_svs)
d276 6
d286 1
d314 6
d324 1
a324 1

a340 1
		    /*SUPPRESS 530*/
d350 1
a350 1
			IO* thatio;
d374 1
a374 1
			       -- Nick Clark */
d410 1
a410 1
			    if (dodup)
a416 1
		/*SUPPRESS 530*/
a418 1
		    /*SUPPRESS 530*/
a439 1
	    /*SUPPRESS 530*/
d442 6
d452 1
a452 1

a456 1
		/*SUPPRESS 530*/
d486 2
a487 2
		/*SUPPRESS 530*/
		for (; isSPACE(*type); type++) ;
d498 1
a498 1
	    if (strNE(name,"-") || num_svs)
d502 7
d513 2
d536 2
a537 2
	    /*SUPPRESS 530*/
	    for (; isSPACE(*name); name++) ;
d539 7
d550 3
a552 1
	    if (strEQ(name,"-")) {
d568 4
a571 1
	if (ckWARN(WARN_NEWLINE) && IoTYPE(io) == IoTYPE_RDONLY && strchr(name, '\n'))
d673 1
a673 1
                SvIVX(sv) = 0;
d676 1
a676 1
                SvIVX(sv) = pid;
d749 1
a749 1
    IO *io = GvIOp(gv);
d778 1
a778 1
	sv_setsv(GvSV(gv),sv);
d804 1
a804 1
		    char *star = strchr(PL_inplace, '*');
d806 1
a806 1
			char *begin = PL_inplace;
d820 1
a820 1
		    if ((PerlLIO_stat(SvPVX(sv),&PL_statbuf) >= 0
d838 1
a838 1
		    if (PerlLIO_rename(PL_oldname,SvPVX(sv)) < 0) {
d848 4
a851 3
		    (void)PerlLIO_unlink(SvPVX(sv));
		    (void)PerlLIO_rename(PL_oldname,SvPVX(sv));
		    do_open(gv,SvPVX(sv),SvCUR(sv),PL_inplace!=0,O_RDONLY,0,Nullfp);
d854 2
a855 2
		    (void)UNLINK(SvPVX(sv));
		    if (link(PL_oldname,SvPVX(sv)) < 0) {
d887 2
a888 2
		if (!do_open(PL_argvoutgv,SvPVX(sv),SvCUR(sv),PL_inplace!=0,
                 O_WRONLY|O_CREAT|O_TRUNC,0,Nullfp))
d890 3
a892 2
		if (!do_open(PL_argvoutgv,SvPVX(sv),SvCUR(sv),PL_inplace!=0,
			     O_WRONLY|O_CREAT|OPEN_EXCL,0666,Nullfp))
d926 1
a926 1
		int eno = errno;
a1039 1
    int status;
d1043 1
a1043 1
	    status = PerlProc_pclose(IoIFP(io));
d1056 2
a1057 1
		retval = (PerlIO_close(IoOFP(io)) != EOF);
d1060 4
a1063 2
	    else
		retval = (PerlIO_close(IoIFP(io)) != EOF);
d1084 1
a1084 1
    else if (ckWARN(WARN_IO) && (IoTYPE(io) == IoTYPE_WRONLY))
d1176 1
a1176 1
	char *s = SvPV(discp,len);
d1181 1
a1181 1
		    if (len > 3 && strnEQ(s+1, "raw", 3)
d1191 1
a1191 1
		    if (len > 4 && strnEQ(s+1, "crlf", 4)
d1209 1
a1209 1
		char *end;
d1232 1
a1232 1
 char *name = ":raw";
d1240 5
a1244 1
#if !defined(HAS_TRUNCATE) && !defined(HAS_CHSIZE) && defined(F_FREESP)
a1247 4
I32 my_chsize(fd, length)
I32 fd;			/* file descriptor */
Off_t length;		/* length to set file to */
{
a1285 1

d1287 4
d1292 1
a1292 1
#endif /* F_FREESP */
d1297 1
a1297 1
    register char *tmps;
d1345 1
a1345 1
	tmps = SvPV(sv, len);
d1373 1
a1373 1
	    sv_setpv(PL_statname,"");
d1383 1
a1383 1
	    sv_setpv(PL_statname,"");
d1389 1
a1389 1
	char *s;
d1401 1
a1401 1
	s = SvPV(sv, len);
d1404 1
a1404 1
	s = SvPVX(PL_statname);		/* s now NUL-terminated */
d1413 2
a1419 1
    STRLEN n_a;
d1424 1
a1424 1
		Perl_croak(aTHX_ "The stat preceding -l _ wasn't an lstat");
d1443 4
a1446 3
    sv_setpv(PL_statname,SvPV(sv, n_a));
    PL_laststatval = PerlLIO_lstat(SvPV(sv, n_a),&PL_statcache);
    if (PL_laststatval < 0 && ckWARN(WARN_NEWLINE) && strchr(SvPV(sv, n_a), '\n'))
d1463 1
a1463 1
#ifdef MACOS_TRADITIONAL
a1465 4
    register char **a;
    char *tmps = Nullch;
    STRLEN n_a;

d1467 3
a1469 1
	New(401,PL_Argv, sp - mark + 1, char*);
d1471 1
d1474 1
a1474 1
		*a++ = SvPVx(*mark, n_a);
d1480 1
a1480 1
	    tmps = SvPV(really, n_a);
d1508 4
a1511 8
    if (PL_Argv) {
	Safefree(PL_Argv);
	PL_Argv = Null(char **);
    }
    if (PL_Cmd) {
	Safefree(PL_Cmd);
	PL_Cmd = Nullch;
    }
d1514 1
a1514 1
#if !defined(OS2) && !defined(WIN32) && !defined(DJGPP) && !defined(EPOC) && !defined(MACOS_TRADITIONAL)
d1535 1
a1535 1
        char flags[10];
d1538 3
d1542 1
d1546 3
d1550 1
d1598 1
a1598 1
		char *t = s + 3;
d1615 1
a1615 1
    New(402,PL_Argv, (s - cmd) / 2 + 2, char*);
a1635 2
	    int e = errno;

d1640 1
a1655 1
    register I32 val2;
d1657 3
a1659 4
    char *what;
    char *s;
    SV **oldmark = mark;
    STRLEN n_a;
d1685 27
a1711 4
		char *name = SvPVx(*mark, n_a);
		APPLY_TAINT_PROPER();
		if (PerlLIO_chmod(name, val))
		    tot--;
d1720 1
d1726 27
a1752 4
		char *name = SvPVx(*mark, n_a);
		APPLY_TAINT_PROPER();
		if (PerlLIO_chown(name, val, val2))
		    tot--;
d1769 1
a1769 1
	s = SvPVx(*++mark, n_a);
d1773 1
a1773 1
	    if ((val = whichsig(s)) < 0)
d1839 1
a1839 1
	    s = SvPVx(*mark, n_a);
d1842 1
a1842 1
		if (UNLINK(s))
d1849 1
a1849 1
		    if (UNLINK(s))
d1862 1
d1868 1
a1872 1
           void * utbufp = &utbuf;
d1890 1
a1890 1
            APPLY_TAINT_PROPER();
d1893 1
a1893 1
		char *name = SvPVx(*mark, n_a);
d1895 1
a1895 1
               if (PerlLIO_utime(name, utbufp))
d1913 1
a1913 1
/* Note: we use `effective' both for uids and gids.
a1974 3
#ifndef NGROUPS
#define NGROUPS 32
#endif
d1976 1
a1976 1
	Groups_t gary[NGROUPS];
d1978 1
d1980 3
a1982 1
	anum = getgroups(NGROUPS,gary);
d1984 7
a1990 2
	    if (gary[anum] == testgid)
		return TRUE;
d2002 4
a2005 2
    key_t key;
    I32 n, flags;
a2006 3
    key = (key_t)SvNVx(*++mark);
    n = (optype == OP_MSGGET) ? 0 : SvIVx(*++mark);
    flags = SvIVx(*++mark);
d2035 2
a2036 1
    I32 id, n, cmd, infosize, getinfo;
d2038 4
a2042 3
    id = SvIVx(*++mark);
    n = (optype == OP_SEMCTL) ? SvIVx(*++mark) : 0;
    cmd = SvIVx(*++mark);
a2094 1
	STRLEN len;
d2097 1
a2097 1
	    SvPV_force(astr, len);
d2102 1
d2160 2
a2161 2
    char *mbuf;
    I32 id, msize, flags;
d2163 2
a2165 1
    id = SvIVx(*++mark);
d2168 1
a2168 1
    mbuf = SvPV(mstr, len);
d2185 3
a2187 2
    I32 id, msize, flags, ret;
    STRLEN len;
a2188 1
    id = SvIVx(*++mark);
d2196 1
a2196 1
    SvPV_force(mstr, len);
d2220 1
a2220 2
    char *opbuf;
    I32 id;
d2222 2
a2224 1
    id = SvIVx(*++mark);
d2226 1
a2226 1
    opbuf = SvPV(opstr, opsize);
d2235 1
a2235 1
        int nsops  = opsize / (3 * sizeof (short));
d2242 1
a2242 1
        New (0, temps, nsops, struct sembuf);
d2273 2
a2274 3
    char *mbuf, *shm;
    I32 id, mpos, msize;
    STRLEN len;
d2276 2
a2278 1
    id = SvIVx(*++mark);
d2293 1
d2297 1
a2297 1
	SvPV_force(mstr, len);
d2311 1
d2313 1
a2313 1
	mbuf = SvPV(mstr, len);
d2344 1
a2344 1
    SV *tmpcmd = NEWSV(55, 0);
d2357 2
a2358 1
	char *rstr = rslt + sizeof(unsigned short int), *begin, *end, *cp;
d2391 3
a2393 3
	    if (!PerlLIO_stat(SvPVX(tmpglob),&st) && S_ISDIR(st.st_mode))
		ok = ((wilddsc.dsc$a_pointer = tovmspath(SvPVX(tmpglob),vmsspec)) != NULL);
	    else ok = ((wilddsc.dsc$a_pointer = tovmsspec(SvPVX(tmpglob),vmsspec)) != NULL);
d2471 1
a2471 1
    (void)do_open(PL_last_in_gv, SvPVX(tmpcmd), SvCUR(tmpcmd),
d2478 10
@


1.10
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d18 5
@


1.9
log
@merge local changes into perl-5.8.3
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, by Larry Wall and others
d726 2
a727 1
	(void)fchmod(PL_lastfd,PL_filemode);
d732 1
d1175 1
@


1.8
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@a50 1
#if !defined(NSIG) || defined(M_UNIX) || defined(M_XENIX)
a51 1
#endif
d2291 3
a2293 2
		end = rstr + (unsigned long int) *rslt;
		if (!hasver) while (*end != ';') end--;
@


1.7
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d3 2
a4 1
 *    Copyright (c) 1991-2002, Larry Wall
d97 1
a97 1
	/* set up disciplines */
d182 1
a182 1
	mode[ix++] = '#'; /* Marker to openn to use numeric "sysopen" */
d215 1
a215 1
	    /* New style explict name, type is just mode and discipline/layer info */
d222 1
a222 1
		SETERRNO(EINVAL, LIB$_INVARG);
d239 1
a239 1
        TAINT_PROPER("open");
d247 1
a247 1
	          unknown_desr:
d292 1
a292 1
	}
d327 2
d331 1
a333 2
			/*SUPPRESS 530*/
			for (; isSPACE(*type); type++) ;
a342 2
			    /*SUPPRESS 530*/
			    for (; isSPACE(*type); type++) ;
d348 1
a348 1
			    SETERRNO(EINVAL,SS$_IVCHAN);
d425 3
a427 1
	}
d458 5
a462 2
	}
	else if ((num_svs && type[0] == IoTYPE_STD && type[1] == IoTYPE_PIPE) ||
d507 1
a507 1
	else {
d509 1
a509 1
		goto unknown_desr;
d544 3
a546 2
			    "Filehandle STD%s opened only for input",
			    (fp == PerlIO_stdout()) ? "OUT" : "ERR");
d550 2
a551 1
			    "Filehandle STDIN opened only for output");
d649 4
d655 4
d682 2
a683 2
	    if (*s == 'I' || *s == '#')
	     s++;
d734 2
d792 2
a793 2
			      "Can't do inplace edit: %s would not be unique",
			      SvPVX(sv));
d803 2
a804 2
			      "Can't rename %s to %s: %s, skipping file",
			      PL_oldname, SvPVX(sv), Strerror(errno) );
d819 2
a820 2
			      "Can't rename %s to %s: %s, skipping file",
			      PL_oldname, SvPVX(sv), Strerror(errno) );
d940 2
a941 2
    IoIFP(rstio) = PerlIO_fdopen(fd[0], "r");
    IoOFP(wstio) = PerlIO_fdopen(fd[1], "w");
d974 1
a974 1
	    SETERRNO(EBADF,SS$_IVCHAN);
d982 1
a982 1
	    SETERRNO(EBADF,SS$_IVCHAN);
d1026 1
a1026 1
	SETERRNO(EBADF,SS$_IVCHAN);
d1046 1
d1053 1
d1057 1
d1060 1
d1091 1
a1091 1
    SETERRNO(EBADF,RMS$_IFI);
d1110 1
a1110 1
    SETERRNO(EBADF,RMS$_IFI);
d1124 1
a1124 1
    SETERRNO(EBADF,RMS$_IFI);
d1173 1
a1173 1
		Perl_croak(aTHX_ "Unknown discipline '%.*s'", end-s, s);
d1289 2
a1290 1
		sv_utf8_upgrade(sv = sv_mortalcopy(sv));
d1344 1
a1344 1
	STRLEN n_a;
d1355 1
a1355 1
	s = SvPV(sv, n_a);
d1357 2
a1358 1
	sv_setpv(PL_statname, s);
d1403 1
d1409 1
d1437 1
d1442 1
d1512 1
d1514 1
d1551 1
a1551 1
		if (!*t && (dup2(1,2) != -1)) {
d1557 1
d1559 1
d1577 1
d1579 1
d1675 1
a1675 1
	if (isUPPER(*s)) {
d1678 1
a1678 1
	    if (!(val = whichsig(s)))
d1778 3
a1780 3
           /* be like C, and if both times are undefined, let the C
              library figure out what to do.  This usually means
              "current time" */
d1783 3
a1785 3
             utbufp = NULL;

	    Zero(&utbuf, sizeof utbuf, char);
d1787 2
a1788 2
           utbuf.actime = (Time_t)SvNVx(accessed);     /* time accessed */
           utbuf.modtime = (Time_t)SvNVx(modified);    /* time modified */
d1790 2
a1791 2
           utbuf.actime = (Time_t)SvIVx(accessed);     /* time accessed */
           utbuf.modtime = (Time_t)SvIVx(modified);    /* time modified */
d1793 2
a1794 1
	    APPLY_TAINT_PROPER();
d2126 1
a2126 1
	SETERRNO(EINVAL,LIB$_INVARG);
d2183 1
a2183 1
	SETERRNO(EFAULT,SS$_ACCVIO);		/* can't do as caller requested */
d2310 1
a2310 1
		sts != RMS$_DNF && sts != RMS$_FNF) ok = 0;
@


1.6
log
@merge in perl 5.6.1 with our local changes
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2001, Larry Wall
d58 2
a59 2
    return do_open9(gv, name, len, as_raw, rawmode, rawperm,
		    supplied_fp, Nullsv, 0);
d67 9
d79 1
d87 3
d91 1
d94 1
d104 1
d107 2
a108 1
	if (IoTYPE(io) == IoTYPE_STD)
d110 5
a114 3
	else if (fd <= PL_maxsysfd) {
	    saveifp = IoIFP(io);
	    saveofp = IoOFP(io);
d116 2
a117 1
	    result = 0;
d131 2
a132 1
	if (result == EOF && fd > PL_maxsysfd)
d136 1
d141 42
d184 1
a184 1
	rawmode |= O_LARGEFILE;
d187 1
a187 3
#ifndef O_ACCMODE
#define O_ACCMODE 3		/* Assume traditional implementation */
#endif
d189 5
a193 45
	switch (result = rawmode & O_ACCMODE) {
	case O_RDONLY:
	     IoTYPE(io) = IoTYPE_RDONLY;
	     break;
	case O_WRONLY:
	     IoTYPE(io) = IoTYPE_WRONLY;
	     break;
	case O_RDWR:
	default:
	     IoTYPE(io) = IoTYPE_RDWR;
	     break;
	}

	writing = (result > 0);
	fd = PerlLIO_open3(name, rawmode, rawperm);

	if (fd == -1)
	    fp = NULL;
	else {
	    char fpmode[4];
	    STRLEN ix = 0;
	    if (result == O_RDONLY)
		fpmode[ix++] = 'r';
#ifdef O_APPEND
	    else if (rawmode & O_APPEND) {
		fpmode[ix++] = 'a';
		if (result != O_WRONLY)
		    fpmode[ix++] = '+';
	    }
#endif
	    else {
		if (result == O_WRONLY)
		    fpmode[ix++] = 'w';
		else {
		    fpmode[ix++] = 'r';
		    fpmode[ix++] = '+';
		}
	    }
	    if (rawmode & O_BINARY)
		fpmode[ix++] = 'b';
	    fpmode[ix] = '\0';
	    fp = PerlIO_fdopen(fd, fpmode);
	    if (!fp)
		PerlLIO_close(fd);
	}
d196 1
a196 1
	char *type;
a197 1
	STRLEN tlen;
d199 3
a201 2
	char mode[4];		/* stdio file mode ("r\0", "rb\0", "r+b\0" etc.) */
	int dodup;
d204 1
a204 1
	tlen = len;
d206 7
d214 12
a225 2
	    STRLEN l;
	    name = SvPV(svs, l) ;
a230 2
	    while (tlen && isSPACE(type[tlen-1]))
		type[--tlen] = '\0';
d232 1
a232 1
	    len = tlen;
a233 1
	mode[0] = mode[1] = mode[2] = mode[3] = '\0';
d235 4
a238 1
	if (*type == IoTYPE_RDWR && tlen > 1 && type[tlen-1] != IoTYPE_PIPE) { /* scary */
a239 1
	    --tlen;
d244 6
a249 3
	    if (num_svs && (tlen != 2 || type[1] != IoTYPE_STD)) {
	      unknown_desr:
		Perl_croak(aTHX_ "Unknown open() mode '%.*s'", (int)olen, oname);
d252 1
a252 1
	    for (type++, tlen--; isSPACE(*type); type++, tlen--) ;
d255 1
a255 1
		len = tlen;
d257 2
a258 1
	    if (*name == '\0') { /* command is missing 19990114 */
d260 1
a260 1
		    Perl_warner(aTHX_ WARN_PIPE, "Missing command in piped open");
d267 1
a267 1
	    if (name[len-1] == '|') {
d270 10
a279 1
		    Perl_warner(aTHX_ WARN_PIPE, "Can't open bidirectional pipe");
d281 1
a281 8
	    {
		char *mode;
		if (out_raw)
		    mode = "wb";
		else if (out_crlf)
		    mode = "wt";
		else
		    mode = "w";
d284 7
a290 1
	    writing = 1;
a298 1
		tlen--;
d300 1
a300 1
	    else
d302 1
a309 2
	    if (num_svs && tlen != 1)
	        goto unknown_desr;
a310 1
		name = type;
d312 3
a314 3
		dodup = 1;
		name++;
		if (*name == '=') {
d316 1
a316 1
		    name++;
d318 2
a319 1
		if (!*name && supplied_fp)
d321 1
d323 11
a333 4
		    /*SUPPRESS 530*/
		    for (; isSPACE(*name); name++) ;
		    if (isDIGIT(*name))
			fd = atoi(name);
d336 10
a345 2
			gv = gv_fetchpv(name,FALSE,SVt_PVIO);
			thatio = GvIO(gv);
d352 1
a352 2
			if (IoIFP(thatio)) {
			    PerlIO *fp = IoIFP(thatio);
d362 2
a363 2
			    if (PerlIO_seek(fp, 0, SEEK_CUR) == -1)
				PerlIO_clearerr(fp);
d369 2
a370 2
			    PerlIO_flush(fp);
			    fd = PerlIO_fileno(fp);
d373 2
a374 2
			    if (IoIFP(thatio) == PerlIO_stdout()
				|| IoIFP(thatio) == PerlIO_stderr())
d376 1
a376 1
			    else if (IoIFP(thatio) == PerlIO_stdin())
d386 6
a391 5
		    if (dodup)
			fd = PerlLIO_dup(fd);
		    else
			was_fdopen = TRUE;
		    if (!(fp = PerlIO_fdopen(fd,mode))) {
d393 7
a399 1
			    PerlLIO_close(fd);
d402 1
a402 1
	    }
d406 3
a408 1
		if (*type == IoTYPE_STD && !type[1]) {
d411 3
d416 7
a422 1
		    fp = PerlIO_open((num_svs ? name : type), mode);
d424 1
a424 1
	    }
a426 2
	    if (num_svs && tlen != 1)
	        goto unknown_desr;
a435 1
		name = type;
d438 3
a440 1
	    if (*type == IoTYPE_STD && !type[1]) {
d443 12
a455 2
	    else
		fp = PerlIO_open((num_svs ? name : type), mode);
d457 2
a458 1
	else if (tlen > 1 && type[tlen-1] == IoTYPE_PIPE) {
d460 1
a460 2
		if (tlen != 2 || type[0] != IoTYPE_STD)
		    goto unknown_desr;
d463 3
a465 3
		type[--tlen] = '\0';
		while (tlen && isSPACE(type[tlen-1]))
		    type[--tlen] = '\0';
d469 1
d471 2
a472 1
	    if (*name == '\0') { /* command is missing 19990114 */
d474 1
a474 1
		    Perl_warner(aTHX_ WARN_PIPE, "Missing command in piped open");
d481 9
a489 8
	    {
		char *mode;
		if (in_raw)
		    mode = "rb";
		else if (in_crlf)
		    mode = "rt";
		else
		    mode = "r";
d493 8
d509 5
d519 7
a525 8
		char *mode;
		if (in_raw)
		    mode = "rb";
		else if (in_crlf)
		    mode = "rt";
		else
		    mode = "r";
		fp = PerlIO_open(name,mode);
d531 1
a531 1
	    Perl_warner(aTHX_ WARN_NEWLINE, PL_warn_nl, "open");
d534 23
a556 3
    if (IoTYPE(io) && IoTYPE(io) != IoTYPE_PIPE && IoTYPE(io) != IoTYPE_STD) {
	if (PerlLIO_fstat(PerlIO_fileno(fp),&PL_statbuf) < 0) {
	    (void)PerlIO_close(fp);
d559 1
d572 9
a580 9
	    char tmpbuf[256];
	    Sock_size_t buflen = sizeof tmpbuf;
	    if (PerlSock_getsockname(PerlIO_fileno(fp), (struct sockaddr *)tmpbuf,
			    &buflen) >= 0
		  || errno != ENOTSOCK)
		IoTYPE(io) = IoTYPE_SOCKET; /* some OS's return 0 on fstat()ed socket */
				/* but some return 0 for streams too, sigh */
	}
#endif
d582 6
d589 3
a591 1
	fd = PerlIO_fileno(saveifp);
d593 1
a593 1
	    PerlIO_flush(saveofp);		/* emulate PerlIO_close() */
a595 2
		if (fd > 2)
		    Safefree(saveofp);
d598 9
a606 5
	if (fd != PerlIO_fileno(fp)) {
	    Pid_t pid;
	    SV *sv;

	    PerlLIO_dup2(PerlIO_fileno(fp), fd);
d608 8
a615 6
	    if (fd != PerlIO_fileno(PerlIO_stdin())) {
	      char newname[FILENAME_MAX+1];
	      if (fgetname(fp, newname)) {
	        if (fd == PerlIO_fileno(PerlIO_stdout())) Perl_vmssetuserlnm("SYS$OUTPUT", newname);
	        if (fd == PerlIO_fileno(PerlIO_stderr())) Perl_vmssetuserlnm("SYS$ERROR",  newname);
	      }
d618 29
a646 10
	    LOCK_FDPID_MUTEX;
	    sv = *av_fetch(PL_fdpid,PerlIO_fileno(fp),TRUE);
	    (void)SvUPGRADE(sv, SVt_IV);
	    pid = SvIVX(sv);
	    SvIVX(sv) = 0;
	    sv = *av_fetch(PL_fdpid,fd,TRUE);
	    UNLOCK_FDPID_MUTEX;
	    (void)SvUPGRADE(sv, SVt_IV);
	    SvIVX(sv) = pid;
	    if (!was_fdopen)
a647 1

d651 1
d654 1
a654 1
    {
a655 1
	fd = PerlIO_fileno(fp);
d661 1
d665 6
a670 11
	    || (IoTYPE(io) == IoTYPE_WRONLY && S_ISCHR(PL_statbuf.st_mode)) )
	{
	    char *mode;
	    if (out_raw)
		mode = "wb";
	    else if (out_crlf)
		mode = "wt";
	    else
		mode = "w";

	    if (!(IoOFP(io) = PerlIO_fdopen(PerlIO_fileno(fp),mode))) {
d742 1
a742 1
		        Perl_warner(aTHX_ WARN_INPLACE,
d765 3
a767 3
		    if (PerlLIO_stat(SvPVX(sv),&PL_statbuf) >= 0
		      && PL_statbuf.st_dev == filedev
		      && PL_statbuf.st_ino == fileino
d769 1
a769 1
                      || (_djstat_fail_bits & _STFAIL_TRUENAME)!=0
d774 1
a774 1
			    Perl_warner(aTHX_ WARN_INPLACE,
d782 1
a782 1
#if !defined(DOSISH) && !defined(__CYGWIN__)
d785 1
a785 1
			    Perl_warner(aTHX_ WARN_INPLACE, 
d801 1
a801 1
			    Perl_warner(aTHX_ WARN_INPLACE,
d815 1
a815 1
			    Perl_warner(aTHX_ WARN_INPLACE,
d839 1
a839 1
		        Perl_warner(aTHX_ WARN_INPLACE, "Can't do inplace edit on %s: %s",
d873 1
a873 1
		    Perl_warner(aTHX_ WARN_INPLACE,
d878 1
a878 1
		    Perl_warner(aTHX_ WARN_INPLACE, "Can't open %s: %s",
d925 1
d1025 2
a1026 18
    else if (ckWARN(WARN_IO)
	     && (IoTYPE(io) == IoTYPE_WRONLY || IoIFP(io) == PerlIO_stdout()
		 || IoIFP(io) == PerlIO_stderr()))
    {
	/* integrate to report_evil_fh()? */
        char *name = NULL; 
	if (isGV(gv)) {
	    SV* sv = sv_newmortal();
	    gv_efullname4(sv, gv, Nullch, FALSE);
	    name = SvPV_nolen(sv);
	}
	if (name && *name)
	    Perl_warner(aTHX_ WARN_IO,
			"Filehandle %s opened only for output", name);
	else
	    Perl_warner(aTHX_ WARN_IO,
			"Filehandle opened only for output");
    }
d1040 1
d1046 1
a1046 1
	    if (!nextargv(PL_argvgv))	/* get another fp handy */
d1058 1
a1058 1
    register IO *io;
d1077 1
a1077 1
    register IO *io;
d1096 1
a1096 1
    register IO *io;
d1151 1
d1153 3
d1165 7
a1171 39
#ifdef DOSISH
#  if defined(atarist) || defined(__MINT__)
    if (!PerlIO_flush(fp)) {
	if (mode & O_BINARY)
	    ((FILE*)fp)->_flag |= _IOBIN;
	else
	    ((FILE*)fp)->_flag &= ~ _IOBIN;
	return 1;
    }
    return 0;
#  else
    if (PerlLIO_setmode(PerlIO_fileno(fp), mode) != -1) {
#    if defined(WIN32) && defined(__BORLANDC__)
	/* The translation mode of the stream is maintained independent
	 * of the translation mode of the fd in the Borland RTL (heavy
	 * digging through their runtime sources reveal).  User has to
	 * set the mode explicitly for the stream (though they don't
	 * document this anywhere). GSAR 97-5-24
	 */
	PerlIO_seek(fp,0L,0);
	if (mode & O_BINARY)
	    ((FILE*)fp)->flags |= _F_BIN;
	else
	    ((FILE*)fp)->flags &= ~ _F_BIN;
#    endif
	return 1;
    }
    else
	return 0;
#  endif
#else
#  if defined(USEMYBINMODE)
    if (my_binmode(fp, iotype, mode) != FALSE)
	return 1;
    else
	return 0;
#  else
    return 1;
#  endif
d1173 1
d1185 1
a1185 1
    struct stat filebuf;
d1266 11
d1339 1
a1339 1
	    Perl_warner(aTHX_ WARN_NEWLINE, PL_warn_nl, "stat");
d1357 5
a1361 1
	Perl_croak(aTHX_ "You can't use -l on a filehandle");
d1368 5
d1376 1
a1376 1
	Perl_warner(aTHX_ WARN_NEWLINE, PL_warn_nl, "lstat");
d1394 1
a1394 1
    char *tmps;
d1417 1
a1417 1
	    Perl_warner(aTHX_ WARN_EXEC, "Can't exec \"%s\": %s",
a1456 1
    char flags[10];
d1464 26
a1489 22
    if (strnEQ(cmd,PL_cshname,PL_cshlen) && strnEQ(cmd+PL_cshlen," -c",3)) {
	strcpy(flags,"-c");
	s = cmd+PL_cshlen+3;
	if (*s == 'f') {
	    s++;
	    strcat(flags,"f");
	}
	if (*s == ' ')
	    s++;
	if (*s++ == '\'') {
	    char *ncmd = s;

	    while (*s)
		s++;
	    if (s[-1] == '\n')
		*--s = '\0';
	    if (s[-1] == '\'') {
		*--s = '\0';
		PerlProc_execl(PL_cshname,"csh", flags,ncmd,(char*)0);
		*s = '\'';
		return FALSE;
	    }
d1507 2
a1508 1
	if (*s != ' ' && !isALPHA(*s) && strchr("$&*(){}[]'\";\\|?<>~`\n",*s)) {
d1555 1
a1555 1
		Perl_warner(aTHX_ WARN_EXEC, "Can't exec \"%s\": %s", 
d1629 1
a1629 1
/* 
d1741 11
d1754 2
a1755 2
	    utbuf.actime = (Time_t)SvNVx(*++mark);	/* time accessed */
	    utbuf.modtime = (Time_t)SvNVx(*++mark);	/* time modified */
d1757 2
a1758 2
	    utbuf.actime = (Time_t)SvIVx(*++mark);	/* time accessed */
	    utbuf.modtime = (Time_t)SvIVx(*++mark);	/* time modified */
d1765 1
a1765 1
		if (PerlLIO_utime(name, &utbuf))
d2061 1
a2061 1
    
d2090 2
a2091 2
    if (opsize < sizeof(struct sembuf)
	|| (opsize % sizeof(struct sembuf)) != 0) {
d2096 30
a2125 1
    return semop(id, (struct sembuf *)opbuf, opsize/sizeof(struct sembuf));
d2189 148
@


1.5
log
@perl-5.6.0 + local changes
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2000, Larry Wall
a53 20
/* XXX If this causes problems, set i_unistd=undef in the hint file.  */
#ifdef I_UNISTD
#  include <unistd.h>
#endif

#if defined(HAS_SOCKET) && !defined(VMS) /* VMS handles sockets via vmsish.h */
# include <sys/socket.h>
# if defined(USE_SOCKS) && defined(I_SOCKS)
#   include <socks.h>
# endif 
# ifdef I_NETBSD
#  include <netdb.h>
# endif
# ifndef ENOTSOCK
#  ifdef I_NET_ERRNO
#   include <net/errno.h>
#  endif
# endif
#endif

d70 1
a70 1
    char savetype = ' ';
d91 1
a91 1
	if (IoTYPE(io) == '-')
d99 1
a99 1
	else if (IoTYPE(io) == '|')
d129 1
a129 1
	     IoTYPE(io) = '<';
d132 1
a132 1
	     IoTYPE(io) = '>';
d136 1
a136 1
	     IoTYPE(io) = '+';
d199 1
a199 1
	if (*type == '+' && tlen > 1 && type[tlen-1] != '|') { /* scary */
d205 2
a206 2
	if (*type == '|') {
	    if (num_svs && (tlen != 2 || type[1] != '-')) {
a216 1
		dTHR;
a225 1
		dTHR;
d242 1
a242 1
	else if (*type == '>') {
d245 3
a247 2
	    if (*type == '>') {
		mode[0] = IoTYPE(io) = 'a';
d295 7
a301 1
			    PerlIO_seek(fp, 0, SEEK_CUR);
d308 11
a318 2
			    if (IoTYPE(thatio) == 's')
				IoTYPE(io) = 's';
d336 1
a336 1
		if (strEQ(type,"-")) {
d338 1
a338 1
		    IoTYPE(io) = '-';
d345 1
a345 1
	else if (*type == '<') {
d360 1
a360 1
	    if (strEQ(type,"-")) {
d362 1
a362 1
		IoTYPE(io) = '-';
d367 1
a367 1
	else if (tlen > 1 && type[tlen-1] == '|') {
d369 1
a369 1
		if (tlen != 2 || type[0] != '-')
a380 1
		dTHR;
d399 1
a399 1
	    IoTYPE(io) = '|';
d405 1
a405 1
	    IoTYPE(io) = '<';
d410 1
a410 1
		IoTYPE(io) = '-';
d425 1
a425 2
	dTHR;
	if (ckWARN(WARN_NEWLINE) && IoTYPE(io) == '<' && strchr(name, '\n'))
d429 1
a429 3
    if (IoTYPE(io) &&
      IoTYPE(io) != '|' && IoTYPE(io) != '-') {
	dTHR;
d435 1
a435 1
	    IoTYPE(io) = 's';	/* in case a socket was passed in to us */
d443 3
a445 1
	) {
d451 1
a451 1
		IoTYPE(io) = 's'; /* some OS's return 0 on fstat()ed socket */
d471 10
d486 1
d507 2
a508 3
	dTHR;
	if (IoTYPE(io) == 's'
	    || (IoTYPE(io) == '>' && S_ISCHR(PL_statbuf.st_mode)) )
a567 1
	dTHR;
a715 1
	    dTHR;
d774 2
a775 2
    IoTYPE(rstio) = '<';
    IoTYPE(wstio) = '>';
d810 2
a811 4
	    dTHR;
	    if (ckWARN(WARN_UNOPENED))
		Perl_warner(aTHX_ WARN_UNOPENED, 
		       "Close on unopened file <%s>",GvENAME(gv));
d822 1
a822 1
    IoTYPE(io) = ' ';
d833 1
a833 1
	if (IoTYPE(io) == '|') {
d843 1
a843 1
	else if (IoTYPE(io) == '-')
a864 1
    dTHR;
d873 1
a873 1
	     && (IoTYPE(io) == '>' || IoIFP(io) == PerlIO_stdout()
d876 13
a888 4
	SV* sv = sv_newmortal();
	gv_efullname3(sv, gv, Nullch);
	Perl_warner(aTHX_ WARN_IO, "Filehandle %s opened only for output",
		    SvPV_nolen(sv));
d930 2
a931 5
    {
	dTHR;
	if (ckWARN(WARN_UNOPENED))
	    Perl_warner(aTHX_ WARN_UNOPENED, "tell() on unopened file");
    }
d949 2
a950 5
    {
	dTHR;
	if (ckWARN(WARN_UNOPENED))
	    Perl_warner(aTHX_ WARN_UNOPENED, "seek() on unopened file");
    }
d963 2
a964 5
    {
	dTHR;
	if (ckWARN(WARN_UNOPENED))
	    Perl_warner(aTHX_ WARN_UNOPENED, "sysseek() on unopened file");
    }
d1140 2
a1141 5
	{
	    dTHR;
	    if (ckWARN(WARN_UNINITIALIZED))
		report_uninit();
	}
d1164 1
a1164 1
    if (len && (PerlIO_write(fp,tmps,len) == 0 || PerlIO_error(fp)))
d1172 1
a1172 1
    djSP;
d1174 1
a1174 1
    GV* tmpgv;
d1178 1
a1178 1
	tmpgv = cGVOP_gv;
d1180 1
a1180 1
	io = GvIO(tmpgv);
d1182 1
a1182 1
	    PL_statgv = tmpgv;
d1188 1
a1188 1
	    if (tmpgv == PL_defgv)
d1190 2
a1191 3
	    if (ckWARN(WARN_UNOPENED))
		Perl_warner(aTHX_ WARN_UNOPENED, "Stat on unopened file <%s>",
		  GvENAME(tmpgv));
d1203 1
a1203 1
	    tmpgv = (GV*)sv;
d1207 1
a1207 1
	    tmpgv = (GV*)SvRV(sv);
d1225 1
a1225 1
    djSP;
a1266 1
	dTHR;
d1276 4
a1279 1
	if (*PL_Argv[0] != '/')	/* will execvp use PATH? */
d1281 2
a1282 2
	if (really && *(tmps = SvPV(really, n_a)))
	    PerlProc_execvp(tmps,PL_Argv);
d1284 1
a1284 1
	    PerlProc_execvp(PL_Argv[0],PL_Argv);
d1286 2
a1287 2
	    Perl_warner(aTHX_ WARN_EXEC, "Can't exec \"%s\": %s", 
		PL_Argv[0], Strerror(errno));
a1416 1
	    dTHR;
a1436 1
    dTHR;
a1720 1
    dTHR;
a1752 1
    dTHR;
a1876 1
    dTHR;
a1898 1
    dTHR;
d1907 3
a1935 1
    dTHR;
a1959 1
    dTHR;
@


1.4
log
@perl5.005_03 (stock)
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1999, Larry Wall
d18 1
d31 1
a31 1
    extern Shmat_t shmat _((int, char *, int));
a43 6
#ifdef I_FCNTL
#include <fcntl.h>
#endif
#ifdef I_SYS_FILE
#include <sys/file.h>
#endif
d61 6
a66 1
# include <netdb.h>
d74 7
a80 8
/* Put this after #includes because <unistd.h> defines _XOPEN_*. */
#ifndef Sock_size_t
#  if _XOPEN_VERSION >= 5 || defined(_XOPEN_SOURCE_EXTENDED) || defined(__GLIBC__)
#    define Sock_size_t Size_t
#  else
#    define Sock_size_t int
#  endif
#endif
d83 3
a85 1
do_open(GV *gv, register char *name, I32 len, int as_raw, int rawmode, int rawperm, PerlIO *supplied_fp)
d96 1
d100 9
d124 1
a124 1
		PerlIO_close(IoIFP(io));	/* clear stdio, fd already closed */
d132 3
a134 2
	    PerlIO_printf(PerlIO_stderr(), "Warning: unable to close filehandle %s properly.\n",
	      GvENAME(gv));
d139 4
d146 1
d166 2
a167 1
	    char *fpmode;
d169 1
a169 1
		fpmode = "r";
d171 5
a175 2
	    else if (rawmode & O_APPEND)
		fpmode = (result == O_WRONLY) ? "a" : "a+";
d177 11
a187 2
	    else
		fpmode = (result == O_WRONLY) ? "w" : "r+";
d194 5
a198 2
	char *myname;
	char mode[3];		/* stdio file mode ("r\0" or "r+\0") */
d201 21
a221 11
	myname = savepvn(name, len);
	SAVEFREEPV(myname);
	name = myname;
	while (len && isSPACE(name[len-1]))
	    name[--len] = '\0';

	mode[0] = mode[1] = mode[2] = '\0';
	IoTYPE(io) = *name;
	if (*name == '+' && len > 1 && name[len-1] != '|') { /* scary */
	    mode[1] = *name++;
	    --len;
d225 5
a229 1
	if (*name == '|') {
d231 13
a243 2
	    for (name++; isSPACE(*name); name++) ;
	    if (strNE(name,"-"))
d246 15
a260 4
	    if (name[strlen(name)-1] == '|') {
		name[strlen(name)-1] = '\0' ;
		if (PL_dowarn)
		    warn("Can't do bidirectional pipe");
a261 1
	    fp = PerlProc_popen(name,"w");
d264 1
a264 1
	else if (*name == '>') {
d266 2
a267 2
	    name++;
	    if (*name == '>') {
d269 2
a270 1
		name++;
d276 9
a284 1
	    if (*name == '&') {
d310 13
a322 1
			    fd = PerlIO_fileno(IoIFP(thatio));
d336 1
a336 1
			}
d341 2
a342 2
		for (; isSPACE(*name); name++) ;
		if (strEQ(name,"-")) {
d347 1
a347 1
		    fp = PerlIO_open(name,mode);
d351 3
a353 1
	else if (*name == '<') {
d355 1
a355 1
	    for (name++; isSPACE(*name); name++) ;
d357 7
a363 1
	    if (*name == '&')
d365 2
a366 1
	    if (strEQ(name,"-")) {
d371 1
a371 1
		fp = PerlIO_open(name,mode);
d373 21
a393 7
	else if (len > 1 && name[len-1] == '|') {
	    name[--len] = '\0';
	    while (len && isSPACE(name[len-1]))
		name[--len] = '\0';
	    /*SUPPRESS 530*/
	    for (; isSPACE(*name); name++) ;
	    if (strNE(name,"-"))
d396 10
a405 1
	    fp = PerlProc_popen(name,"r");
d409 3
d419 10
a428 2
	    else
		fp = PerlIO_open(name,"r");
d432 3
a434 2
	if (PL_dowarn && IoTYPE(io) == '<' && strchr(name, '\n'))
	    warn(warn_nl, "open");
d475 1
a475 1
	    int pid;
d502 1
d506 11
a516 2
	  || (IoTYPE(io) == '>' && S_ISCHR(PL_statbuf.st_mode)) ) {
	    if (!(IoOFP(io) = PerlIO_fdopen(PerlIO_fileno(fp),"w"))) {
d535 1
a535 1
nextargv(register GV *gv)
d542 3
a544 2
    int fileuid;
    int filegid;
d548 8
d588 4
a591 2
		    warn("Can't do inplace edit: %s is not a regular file",
		      PL_oldname );
d618 6
a623 3
                      ) {
			warn("Can't do inplace edit: %s would not be uniq",
			  SvPVX(sv) );
d629 1
a629 1
#ifndef DOSISH
d631 4
a634 2
			warn("Can't rename %s to %s: %s, skipping file",
			  PL_oldname, SvPVX(sv), Strerror(errno) );
d647 4
a650 2
			warn("Can't rename %s to %s: %s, skipping file",
			  PL_oldname, SvPVX(sv), Strerror(errno) );
d661 4
a664 2
			warn("Can't remove %s: %s, skipping file",
			  PL_oldname, Strerror(errno) );
d670 1
a670 1
		    croak("Can't do inplace edit without backup");
d679 1
a679 1
                 O_WRONLY|O_CREAT|O_TRUNC,0,Nullfp)) { 
d682 1
a682 1
			     O_WRONLY|O_CREAT|OPEN_EXCL,0666,Nullfp)) {
d684 4
a687 2
		    warn("Can't do inplace edit on %s: %s",
		      PL_oldname, Strerror(errno) );
d714 16
a729 3
	else
	    PerlIO_printf(PerlIO_stderr(), "Can't open %s: %s\n",
	      SvPV(sv, oldlen), Strerror(errno));
d731 2
d735 8
d750 1
a750 1
do_pipe(SV *sv, GV *rgv, GV *wgv)
d795 1
a795 1
do_close(GV *gv, bool not_implicit)
d810 4
a813 2
	    if (PL_dowarn)
		warn("Close on unopened file <%s>",GvENAME(gv));
d818 1
a818 1
    retval = io_close(io);
d829 1
a829 1
io_close(IO *io)
d837 7
a843 2
	    STATUS_NATIVE_SET(status);
	    retval = (STATUS_POSIX == 0);
d857 1
a857 1
    else {
d865 1
a865 1
do_eof(GV *gv)
d875 9
d911 2
a912 2
long
do_tell(GV *gv)
d924 5
a928 2
    if (PL_dowarn)
	warn("tell() on unopened file");
d930 1
a930 1
    return -1L;
d934 1
a934 1
do_seek(GV *gv, long int pos, int whence)
d946 5
a950 2
    if (PL_dowarn)
	warn("seek() on unopened file");
d955 2
a956 2
long
do_sysseek(GV *gv, long int pos, int whence)
d963 5
a967 2
    if (PL_dowarn)
	warn("sysseek() on unopened file");
d969 1
a969 1
    return -1L;
d973 52
a1024 1
do_binmode(PerlIO *fp, int iotype, int flag)
a1025 2
    if (flag != TRUE)
	croak("panic: unsetting binmode"); /* Not implemented yet */
d1027 6
a1032 2
#if defined(atarist) || defined(__MINT__)
    if (!PerlIO_flush(fp) && (fp->_flag |= _IOBIN))
d1034 5
a1038 5
    else
	return 0;
#else
    if (PerlLIO_setmode(PerlIO_fileno(fp), OP_BINARY) != -1) {
#if defined(WIN32) && defined(__BORLANDC__)
d1046 5
a1050 2
	((FILE*)fp)->flags |= _F_BIN;
#endif
d1055 1
a1055 1
#endif
d1057 2
a1058 2
#if defined(USEMYBINMODE)
    if (my_binmode(fp,iotype) != NULL)
d1062 1
a1062 1
#else
d1064 1
a1064 1
#endif
d1120 1
a1120 1
do_print(register SV *sv, PerlIO *fp)
d1132 1
a1132 1
	    PerlIO_printf(fp, PL_ofmt, (double)SvIVX(sv));
d1143 5
a1147 2
	if (PL_dowarn)
	    warn(warn_uninit);
d1153 4
a1156 1
	    PerlIO_printf(fp, "%ld", (long)SvIVX(sv));
d1164 6
d1176 1
a1176 1
my_stat(ARGSproto)
d1184 1
a1184 1
	tmpgv = cGVOP->op_gv;
d1196 2
a1197 2
	    if (PL_dowarn)
		warn("Stat on unopened file <%s>",
d1223 2
a1224 2
	if (PL_laststatval < 0 && PL_dowarn && strchr(s, '\n'))
	    warn(warn_nl, "stat");
d1230 1
a1230 1
my_lstat(ARGSproto)
d1237 1
a1237 1
	if (cGVOP->op_gv == PL_defgv) {
d1239 1
a1239 1
		croak("The stat preceding -l _ wasn't an lstat");
d1242 1
a1242 1
	croak("You can't use -l on a filehandle");
a1249 1
#ifdef HAS_LSTAT
d1251 2
a1252 5
#else
    PL_laststatval = PerlLIO_stat(SvPV(sv, n_a),&PL_statcache);
#endif
    if (PL_laststatval < 0 && PL_dowarn && strchr(SvPV(sv, n_a), '\n'))
	warn(warn_nl, "lstat");
d1257 8
a1264 1
do_aexec(SV *really, register SV **mark, register SV **sp)
d1266 3
d1290 9
a1298 2
	if (PL_dowarn)
	    warn("Can't exec \"%s\": %s", PL_Argv[0], Strerror(errno));
d1301 1
d1306 1
a1306 1
do_execfree(void)
d1318 1
a1318 1
#if !defined(OS2) && !defined(WIN32) && !defined(DJGPP)
d1321 7
a1327 1
do_exec(char *cmd)
d1373 1
a1373 1
    for (s = cmd; *s && isALPHA(*s); s++) ;	/* catch VAR=val gizmo */
d1383 14
d1421 12
a1432 2
	if (PL_dowarn)
	    warn("Can't exec \"%s\": %s", PL_Argv[0], Strerror(errno));
d1441 1
a1441 1
apply(I32 type, register SV **mark, register SV **sp)
d1518 1
a1518 1
		croak("Unrecognized signal name \"%s\"",s);
a1589 1
#ifdef HAS_LSTAT
a1590 3
#else
		if (PerlLIO_stat(s,&PL_statbuf) < 0 || S_ISDIR(PL_statbuf.st_mode))
#endif
d1642 4
a1645 2
I32
cando(I32 bit, I32 effective, register struct stat *statbufp)
d1669 1
a1669 1
     return (bit & statbufp->st_mode) ? TRUE : FALSE;
d1673 1
a1673 1
	if (bit == S_IXUSR) {
d1682 1
a1682 1
	if (statbufp->st_mode & bit)
d1685 2
a1686 2
    else if (ingroup((I32)statbufp->st_gid,effective)) {
	if (statbufp->st_mode & bit >> 3)
d1689 1
a1689 1
    else if (statbufp->st_mode & bit >> 6)
d1696 2
a1697 2
I32
ingroup(I32 testgid, I32 effective)
d1699 4
d1720 1
d1726 1
a1726 1
do_ipcget(I32 optype, SV **mark, SV **sp)
d1752 1
a1752 1
	croak("%s not implemented", op_desc[optype]);
d1759 1
a1759 1
do_ipcctl(I32 optype, SV **mark, SV **sp)
d1790 1
d1797 3
a1799 1

d1801 1
d1809 3
d1816 1
a1816 1
	croak("%s not implemented", op_desc[optype]);
d1832 4
a1835 2
		croak("Bad arg length for %s, is %lu, should be %ld",
			op_desc[optype], (unsigned long)len, (long)infosize);
d1841 1
a1841 1
	a = (char *)i;		/* ouch */
d1853 1
d1856 3
d1860 1
d1862 3
d1883 1
a1883 1
do_msgsnd(SV **mark, SV **sp)
d1897 1
a1897 1
	croak("Arg too short for msgsnd");
d1901 1
a1901 1
    croak("msgsnd not implemented");
d1906 1
a1906 1
do_msgrcv(SV **mark, SV **sp)
a1920 6
    if (SvTHINKFIRST(mstr)) {
	if (SvREADONLY(mstr))
	    croak("Can't msgrcv to readonly var");
	if (SvROK(mstr))
	    sv_unref(mstr);
    }
d1929 4
d1936 1
a1936 1
    croak("msgrcv not implemented");
d1941 1
a1941 1
do_semop(SV **mark, SV **sp)
d1961 1
a1961 1
    croak("semop not implemented");
d1966 1
a1966 1
do_shmio(I32 optype, SV **mark, SV **sp)
d1991 3
d2001 4
d2018 1
a2018 1
    croak("shm I/O not implemented");
@


1.3
log
@Our semctl takes a union semun as 4th arg
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1997, Larry Wall
d21 1
d23 1
a26 3
#ifdef HAS_SEM
#include <sys/sem.h>
#endif
d36 1
a36 1
#  ifdef _MSC_VER
d42 1
d49 5
d84 1
a84 7
do_open(gv,name,len,as_raw,rawmode,rawperm,supplied_fp)
GV *gv;
register char *name;
I32 len;
int as_raw;
int rawmode, rawperm;
PerlIO *supplied_fp;
d94 1
d96 1
a96 1
    forkprocess = 1;		/* assume true if no fork */
d102 1
a102 1
	else if (fd <= maxsysfd) {
d109 1
a109 1
	    result = my_pclose(IoIFP(io));
d120 1
a120 1
	if (result == EOF && fd > maxsysfd)
d127 16
a142 2
	result = rawmode & 3;
	IoTYPE(io) = "<>++"[result];
d144 2
a145 1
	fd = open(name, rawmode, rawperm);
d150 1
a150 1
	    if (result == 0)
d154 1
a154 1
		fpmode = (result == 1) ? "a" : "a+";
d157 1
a157 1
		fpmode = (result == 1) ? "w" : "r+";
d160 1
a160 1
		close(fd);
d188 6
a193 3
	    if (dowarn && name[strlen(name)-1] == '|')
		warn("Can't do bidirectional pipe");
	    fp = my_popen(name,"w");
d241 3
a243 1
			fd = dup(fd);
d246 1
a246 1
			    close(fd);
d275 1
a275 1
	else if (name[len-1] == '|') {
d284 1
a284 1
	    fp = my_popen(name,"r");
d300 1
a300 1
	if (dowarn && IoTYPE(io) == '<' && strchr(name, '\n'))
d306 2
a307 1
	if (Fstat(PerlIO_fileno(fp),&statbuf) < 0) {
d311 1
a311 1
	if (S_ISSOCK(statbuf.st_mode))
d316 1
a316 1
	    !(statbuf.st_mode & S_IFMT)
d318 1
a318 1
	    !statbuf.st_mode
d321 3
a323 2
	    Sock_size_t buflen = sizeof tokenbuf;
	    if (getsockname(PerlIO_fileno(fp), (struct sockaddr *)tokenbuf,
d345 2
a346 2
	    dup2(PerlIO_fileno(fp), fd);
	    sv = *av_fetch(fdpid,PerlIO_fileno(fp),TRUE);
d350 1
a350 1
	    sv = *av_fetch(fdpid,fd,TRUE);
d353 2
a354 1
	    PerlIO_close(fp);
d361 6
a366 2
    fd = PerlIO_fileno(fp);
    fcntl(fd,F_SETFD,fd > maxsysfd);
d370 1
d372 1
a372 1
	  || (IoTYPE(io) == '>' && S_ISCHR(statbuf.st_mode)) ) {
d392 1
a392 2
nextargv(gv)
register GV *gv;
d402 4
a405 4
    if (!argvoutgv)
	argvoutgv = gv_fetchpv("ARGVOUT",TRUE,SVt_PVIO);
    if (filemode & (S_ISUID|S_ISGID)) {
	PerlIO_flush(IoIFP(GvIOn(argvoutgv)));  /* chmod must follow last write */
d407 1
a407 1
	(void)fchmod(lastfd,filemode);
d409 1
a409 1
	(void)chmod(oldname,filemode);
d412 1
a412 1
    filemode = 0;
d414 2
a415 1
	STRLEN len;
d420 3
a422 3
	oldname = SvPVx(GvSV(gv), len);
	if (do_open(gv,oldname,len,FALSE,0,0,Nullfp)) {
	    if (inplace) {
d424 1
a424 1
		if (strEQ(oldname,"-")) {
d429 2
a430 2
		filedev = statbuf.st_dev;
		fileino = statbuf.st_ino;
d432 4
a435 4
		filemode = statbuf.st_mode;
		fileuid = statbuf.st_uid;
		filegid = statbuf.st_gid;
		if (!S_ISREG(filemode)) {
d437 1
a437 1
		      oldname );
d441 22
a462 5
		if (*inplace) {
#ifdef SUFFIX
		    add_suffix(sv,inplace);
#else
		    sv_catpv(sv,inplace);
d464 2
a465 5
#ifndef FLEXFILENAMES
		    if (Stat(SvPVX(sv),&statbuf) >= 0
		      && statbuf.st_dev == filedev
		      && statbuf.st_ino == fileino ) {
			warn("Can't do inplace edit: %s > 14 characters",
d473 1
a473 1
		    if (rename(oldname,SvPVX(sv)) < 0) {
d475 1
a475 1
			  oldname, SvPVX(sv), Strerror(errno) );
d481 3
a483 3
		    (void)unlink(SvPVX(sv));
		    (void)rename(oldname,SvPVX(sv));
		    do_open(gv,SvPVX(sv),SvCUR(sv),FALSE,0,0,Nullfp);
d487 1
a487 1
		    if (link(oldname,SvPVX(sv)) < 0) {
d489 1
a489 1
			  oldname, SvPVX(sv), Strerror(errno) );
d493 1
a493 1
		    (void)UNLINK(oldname);
d499 3
a501 3
		    if (UNLINK(oldname) < 0) {
			warn("Can't rename %s to %s: %s, skipping file",
			  oldname, SvPVX(sv), Strerror(errno) );
d511 2
a512 2
		sv_setpvn(sv,">",1);
		sv_catpv(sv,oldname);
d514 7
a520 1
		if (!do_open(argvoutgv,SvPVX(sv),SvCUR(sv),FALSE,0,0,Nullfp)) {
d522 1
a522 1
		      oldname, Strerror(errno) );
d526 3
a528 3
		setdefout(argvoutgv);
		lastfd = PerlIO_fileno(IoIFP(GvIOp(argvoutgv)));
		(void)Fstat(lastfd,&statbuf);
d530 1
a530 1
		(void)fchmod(lastfd,filemode);
d534 1
a534 1
		(void)chmod(oldname,filemode);
d537 1
a537 1
		if (fileuid != statbuf.st_uid || filegid != statbuf.st_gid) {
d539 1
a539 1
		    (void)fchown(lastfd,fileuid,filegid);
d542 1
a542 1
		    (void)chown(oldname,fileuid,filegid);
d550 2
a551 1
	    PerlIO_printf(PerlIO_stderr(), "Can't open %s: %s\n",SvPV(sv, na), Strerror(errno));
d553 2
a554 2
    if (inplace) {
	(void)do_close(argvoutgv,FALSE);
d562 1
a562 4
do_pipe(sv, rgv, wgv)
SV *sv;
GV *rgv;
GV *wgv;
d581 1
a581 1
    if (pipe(fd) < 0)
d590 1
a590 1
	else close(fd[0]);
d592 1
a592 1
	else close(fd[1]);
d596 1
a596 1
    sv_setsv(sv,&sv_yes);
d600 1
a600 1
    sv_setsv(sv,&sv_undef);
a606 5
#ifndef CAN_PROTOTYPE
do_close(gv,not_implicit)
GV *gv;
bool not_implicit;
#else
a607 1
#endif /* CAN_PROTOTYPE */
d613 1
a613 1
	gv = argvgv;
d615 2
a616 1
	SETERRNO(EBADF,SS$_IVCHAN);
d621 5
a625 2
	if (dowarn && not_implicit)
	    warn("Close on unopened file <%s>",GvENAME(gv));
d639 1
a639 2
io_close(io)
IO* io;
d646 1
a646 1
	    status = my_pclose(IoIFP(io));
d662 3
d670 1
a670 2
do_eof(gv)
GV *gv;
d672 1
d697 2
a698 2
	if (op->op_flags & OPf_SPECIAL) { /* not necessarily a real EOF yet? */
	    if (!nextargv(argvgv))	/* get another fp handy */
d708 1
a708 2
do_tell(gv)
GV *gv;
d720 1
a720 1
    if (dowarn)
d727 1
a727 4
do_seek(gv, pos, whence)
GV *gv;
long pos;
int whence;
d739 1
a739 1
    if (dowarn)
d746 1
a746 4
do_sysseek(gv, pos, whence)
GV *gv;
long pos;
int whence;
d752 2
a753 2
	return lseek(PerlIO_fileno(fp), pos, whence);
    if (dowarn)
d759 40
d810 1
a810 1
    if (Fstat(fd, &filebuf) < 0)
d817 1
a817 1
	if ((lseek(fd, (length - 1), 0)) < 0)
d822 1
a822 1
	if ((write(fd, "", 1)) != 1)
d851 1
a851 3
do_print(sv,fp)
register SV *sv;
PerlIO *fp;
d859 1
a859 1
    if (ofmt) {
d863 1
a863 1
	    PerlIO_printf(fp, ofmt, (double)SvIVX(sv));
d868 1
a868 1
	    PerlIO_printf(fp, ofmt, SvNVX(sv));
d874 1
a874 1
	if (dowarn)
d895 1
a895 2
my_stat(ARGS)
dARGS
d897 1
a897 1
    dSP;
d901 2
a902 2
    if (op->op_flags & OPf_REF) {
	EXTEND(sp,1);
d907 4
a910 4
	    statgv = tmpgv;
	    sv_setpv(statname,"");
	    laststype = OP_STAT;
	    return (laststatval = Fstat(PerlIO_fileno(IoIFP(io)), &statcache));
d913 3
a915 3
	    if (tmpgv == defgv)
		return laststatval;
	    if (dowarn)
d918 3
a920 3
	    statgv = Nullgv;
	    sv_setpv(statname,"");
	    return (laststatval = -1);
d925 2
d937 6
a942 5
	statgv = Nullgv;
	sv_setpv(statname,SvPV(sv, na));
	laststype = OP_STAT;
	laststatval = Stat(SvPV(sv, na),&statcache);
	if (laststatval < 0 && dowarn && strchr(SvPV(sv, na), '\n'))
d944 1
a944 1
	return laststatval;
d949 1
a949 2
my_lstat(ARGS)
dARGS
d951 1
a951 1
    dSP;
d953 5
a957 4
    if (op->op_flags & OPf_REF) {
	EXTEND(sp,1);
	if (cGVOP->op_gv == defgv) {
	    if (laststype != OP_LSTAT)
d959 1
a959 1
	    return laststatval;
d964 2
a965 2
    laststype = OP_LSTAT;
    statgv = Nullgv;
d968 1
a968 1
    sv_setpv(statname,SvPV(sv, na));
d970 1
a970 1
    laststatval = lstat(SvPV(sv, na),&statcache);
d972 1
a972 1
    laststatval = Stat(SvPV(sv, na),&statcache);
d974 1
a974 1
    if (laststatval < 0 && dowarn && strchr(SvPV(sv, na), '\n'))
d976 1
a976 1
    return laststatval;
d980 1
a980 4
do_aexec(really,mark,sp)
SV *really;
register SV **mark;
register SV **sp;
d984 1
d987 3
a989 2
	New(401,Argv, sp - mark + 1, char*);
	a = Argv;
d992 1
a992 1
		*a++ = SvPVx(*mark, na);
d997 1
a997 1
	if (*Argv[0] != '/')	/* will execvp use PATH? */
d999 2
a1000 2
	if (really && *(tmps = SvPV(really, na)))
	    execvp(tmps,Argv);
d1002 3
a1004 3
	    execvp(Argv[0],Argv);
	if (dowarn)
	    warn("Can't exec \"%s\": %s", Argv[0], Strerror(errno));
d1011 1
a1011 1
do_execfree()
d1013 3
a1015 3
    if (Argv) {
	Safefree(Argv);
	Argv = Null(char **);
d1017 3
a1019 3
    if (Cmd) {
	Safefree(Cmd);
	Cmd = Nullch;
d1023 1
a1023 1
#if !defined(OS2) && !defined(WIN32)
d1026 1
a1026 2
do_exec(cmd)
char *cmd;
d1038 1
a1038 1
    if (strnEQ(cmd,cshname,cshlen) && strnEQ(cmd+cshlen," -c",3)) {
d1040 1
a1040 1
	s = cmd+cshlen+3;
d1056 1
a1056 1
		execl(cshname,"csh", flags,ncmd,(char*)0);
d1083 1
a1083 1
	    execl(sh_path, "sh", "-c", cmd, (char*)0);
d1088 4
a1091 4
    New(402,Argv, (s - cmd) / 2 + 2, char*);
    Cmd = savepvn(cmd, s-cmd);
    a = Argv;
    for (s = Cmd; *s;) {
d1100 2
a1101 2
    if (Argv[0]) {
	execvp(Argv[0],Argv);
d1106 2
a1107 2
	if (dowarn)
	    warn("Can't exec \"%s\": %s", Argv[0], Strerror(errno));
d1116 1
a1116 4
apply(type,mark,sp)
I32 type;
register SV **mark;
register SV **sp;
d1118 1
d1122 1
d1125 6
d1132 2
a1133 1
    if (tainting) {
d1144 2
a1145 1
	TAINT_PROPER("chmod");
d1147 2
a1149 1
	    val = SvIVx(*mark);
d1151 3
a1153 1
		if (chmod(SvPVx(*mark, na),val))
d1160 2
a1161 1
	TAINT_PROPER("chown");
d1165 1
d1168 3
a1170 1
		if (chown(SvPVx(*mark, na),val,val2))
d1176 6
d1184 2
a1185 1
	TAINT_PROPER("kill");
d1188 1
a1188 2
	s = SvPVx(*++mark, na);
	tot = sp - mark;
d1197 2
d1211 1
d1234 1
d1236 1
a1236 1
		if (killpg(proc,val))	/* BSD */
d1238 1
a1238 1
		if (kill(-proc,val))	/* SYSV */
d1245 3
a1247 1
		if (kill(SvIVx(*mark),val))
d1254 2
a1255 1
	TAINT_PROPER("unlink");
d1258 3
a1260 2
	    s = SvPVx(*mark, na);
	    if (euid || unsafe) {
d1266 1
a1266 1
		if (lstat(s,&statbuf) < 0 || S_ISDIR(statbuf.st_mode))
d1268 1
a1268 1
		if (Stat(s,&statbuf) < 0 || S_ISDIR(statbuf.st_mode))
d1280 2
a1281 1
	TAINT_PROPER("utime");
d1287 2
a1288 2
		long    actime;
		long	modtime;
d1294 2
a1295 2
	    utbuf.actime = (Time_t)SvNVx(*++mark);    /* time accessed */
	    utbuf.modtime = (Time_t)SvNVx(*++mark);    /* time modified */
d1297 2
a1298 2
	    utbuf.actime = SvIVx(*++mark);    /* time accessed */
	    utbuf.modtime = SvIVx(*++mark);    /* time modified */
d1300 1
d1303 3
a1305 1
		if (utime(SvPVx(*mark, na),&utbuf))
d1315 2
d1322 1
a1322 4
cando(bit, effective, statbufp)
I32 bit;
I32 effective;
register struct stat *statbufp;
d1349 1
a1349 1
    if ((effective ? euid : uid) == 0) {	/* root is special */
d1358 1
a1358 1
    if (statbufp->st_uid == (effective ? euid : uid) ) {
d1374 1
a1374 3
ingroup(testgid,effective)
I32 testgid;
I32 effective;
d1376 1
a1376 1
    if (testgid == (effective ? egid : gid))
d1398 1
a1398 4
do_ipcget(optype, mark, sp)
I32 optype;
SV **mark;
SV **sp;
d1400 1
d1431 1
a1431 4
do_ipcctl(optype, mark, sp)
I32 optype;
SV **mark;
SV **sp;
d1433 1
a1437 3
#if defined(__linux__) || defined (__OpenBSD__)	/* XXX Need metaconfig test */
    union semun unsemds;
#endif
d1467 2
a1468 10
#if defined(__linux__) || defined (__OpenBSD__)	/* XXX Need metaconfig test */
/* linux & OpenBSD (and Solaris2?) uses :
   int semctl (int semid, int semnum, int cmd, union semun arg)
       union semun {
            int val;
            struct semid_ds *buf;
            ushort *array;
       };
*/
            union semun semun;
d1470 2
a1471 4
	    if (semctl(id, 0, IPC_STAT, semun) == -1)
#else
	    if (semctl(id, 0, IPC_STAT, &semds) == -1)
#endif
a1472 1
	    getinfo = (cmd == GETALL);
d1515 6
a1520 7
    case OP_SEMCTL:
#if defined(__linux__) || defined (__OpenBSD__)	/* XXX Need metaconfig test */
        unsemds.buf = (struct semid_ds *)a;
	ret = semctl(id, n, cmd, unsemds);
#else
	ret = semctl(id, n, cmd, (struct semid_ds *)a);
#endif
d1538 1
a1538 3
do_msgsnd(mark, sp)
SV **mark;
SV **sp;
d1541 1
d1561 1
a1561 3
do_msgrcv(mark, sp)
SV **mark;
SV **sp;
d1564 1
d1598 1
a1598 3
do_semop(mark, sp)
SV **mark;
SV **sp;
d1601 1
d1623 1
a1623 4
do_shmio(optype, mark, sp)
I32 optype;
SV **mark;
SV **sp;
d1626 1
d1644 1
a1644 1
    shm = (Shmat_t)shmat(id, (char*)NULL, (optype == OP_SHMREAD) ? SHM_RDONLY : 0);
d1673 1
@


1.2
log
@perl 5.004_04
@
text
@d1336 1
a1336 1
#ifdef __linux__	/* XXX Need metaconfig test */
d1368 2
a1369 2
#ifdef __linux__	/* XXX Need metaconfig test */
/* linux (and Solaris2?) uses :
d1428 1
a1428 1
#ifdef __linux__	/* XXX Need metaconfig test */
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1994, Larry Wall
d37 5
a41 1
#include <utime.h>
d50 9
d69 9
d85 1
a85 1
FILE *supplied_fp;
d88 2
a89 2
    FILE *saveifp = Nullfp;
    FILE *saveofp = Nullfp;
d92 1
a92 1
    FILE *fp;
d99 1
a99 1
	fd = fileno(IoIFP(io));
d112 2
a113 2
		result = fclose(IoOFP(io));
		fclose(IoIFP(io));	/* clear stdio, fd already closed */
d116 1
a116 1
		result = fclose(IoIFP(io));
d119 1
a119 1
	    result = fclose(IoIFP(io));
d121 1
a121 1
	    fprintf(stderr,"Warning: unable to close filehandle %s properly.\n",
d134 10
a143 3
	    fp = fdopen(fd, ((result == 0) ? "r"
			     : (result == 1) ? "w"
			     : "r+"));
d215 1
a215 1
			    fd = fileno(IoIFP(thatio));
d224 1
a224 1
		    if (!(fp = fdopen(fd,mode)))
d227 1
d234 1
a234 1
		    fp = stdout;
d238 1
a238 1
		    fp = fopen(name,mode);
d249 1
a249 1
		fp = stdin;
d253 1
a253 1
		fp = fopen(name,mode);
d272 1
a272 1
		fp = stdin;
d276 1
a276 1
		fp = fopen(name,"r");
d286 2
a287 2
	if (Fstat(fileno(fp),&statbuf) < 0) {
	    (void)fclose(fp);
d300 4
a303 3
	    int buflen = sizeof tokenbuf;
	    if (getsockname(fileno(fp), (struct sockaddr *)tokenbuf, &buflen) >= 0
		|| errno != ENOTSOCK)
d310 1
a310 1
	fd = fileno(saveifp);
d312 1
a312 1
	    Fflush(saveofp);		/* emulate fclose() */
d314 1
a314 1
		fclose(saveofp);
d319 1
a319 1
	if (fd != fileno(fp)) {
d323 2
a324 2
	    dup2(fileno(fp), fd);
	    sv = *av_fetch(fdpid,fileno(fp),TRUE);
d331 1
a331 1
	    fclose(fp);
d335 1
a335 1
	clearerr(fp);
d338 1
a338 1
    fd = fileno(fp);
d345 2
a346 2
	    if (!(IoOFP(io) = fdopen(fileno(fp),"w"))) {
		fclose(fp);
d363 1
a363 1
FILE *
d378 1
a378 1
	Fflush(IoIFP(GvIOn(argvoutgv)));  /* chmod must follow last write */
d442 1
a442 1
#endif /* MSDOS */
d455 2
a456 1
#ifndef DOSISH
d463 1
d479 1
a479 1
		lastfd = fileno(IoIFP(GvIOp(argvoutgv)));
d484 2
d487 1
d502 1
a502 1
	    fprintf(stderr,"Can't open %s: %s\n",SvPV(sv, na), Strerror(errno));
d537 2
a538 2
    IoIFP(rstio) = fdopen(fd[0], "r");
    IoOFP(wstio) = fdopen(fd[1], "w");
d543 1
a543 1
	if (IoIFP(rstio)) fclose(IoIFP(rstio));
d545 1
a545 1
	if (IoOFP(wstio)) fclose(IoOFP(wstio));
d559 1
d562 1
a562 1
do_close(gv,explicit)
d564 1
a564 1
bool explicit;
d566 1
a566 1
do_close(GV *gv, bool explicit)
d580 1
a580 1
	if (dowarn && explicit)
d585 1
a585 1
    if (explicit) {
d604 2
a605 2
	    retval = (status == 0);
	    statusvalue = FIXSTATUS(status);
d611 2
a612 2
		retval = (fclose(IoOFP(io)) != EOF);
		fclose(IoIFP(io));	/* clear stdio, fd already closed */
d615 1
a615 1
		retval = (fclose(IoIFP(io)) != EOF);
d637 4
a640 4
#ifdef USE_STDIO_PTR			/* (the code works without this) */
	if (FILE_cnt(IoIFP(io)) > 0)	/* cheat a little, since */
	    return FALSE;		/* this is the most usual case */
#endif
d642 1
a642 1
	ch = getc(IoIFP(io));
d644 1
a644 1
	    (void)ungetc(ch, IoIFP(io));
d647 4
a650 4
#if defined(USE_STDIO_PTR) && defined(STDIO_CNT_LVALUE)
	if (FILE_cnt(IoIFP(io)) < -1)
	    FILE_cnt(IoIFP(io)) = -1;
#endif
d666 1
d668 1
a668 7
    if (!gv)
	goto phooey;

    io = GvIO(gv);
    if (!io || !IoIFP(io))
	goto phooey;

d670 2
a671 2
    if (feof(IoIFP(io)))
	(void)fseek (IoIFP(io), 0L, 2);		/* ultrix 1.2 workaround */
d673 2
a674 4

    return ftell(IoIFP(io));

phooey:
d688 1
d690 1
a690 7
    if (!gv)
	goto nuts;

    io = GvIO(gv);
    if (!io || !IoIFP(io))
	goto nuts;

d692 2
a693 2
    if (feof(IoIFP(io)))
	(void)fseek (IoIFP(io), 0L, 2);		/* ultrix 1.2 workaround */
d695 7
d703 8
a710 1
    return fseek(IoIFP(io), pos, whence) >= 0;
d712 2
a713 1
nuts:
d715 1
a715 1
	warn("seek() on unopened file");
d717 1
a717 1
    return FALSE;
d724 1
a724 1
I32 chsize(fd, length)
a727 1
    extern long lseek();
a770 50
I32
looks_like_number(sv)
SV *sv;
{
    register char *s;
    register char *send;

    if (!SvPOK(sv)) {
	STRLEN len;
	if (!SvPOKp(sv))
	    return TRUE;
	s = SvPV(sv, len);
	send = s + len;
    }
    else {
	s = SvPVX(sv); 
	send = s + SvCUR(sv);
    }
    while (isSPACE(*s))
	s++;
    if (s >= send)
	return FALSE;
    if (*s == '+' || *s == '-')
	s++;
    while (isDIGIT(*s))
	s++;
    if (s == send)
	return TRUE;
    if (*s == '.') 
	s++;
    else if (s == SvPVX(sv))
	return FALSE;
    while (isDIGIT(*s))
	s++;
    if (s == send)
	return TRUE;
    if (*s == 'e' || *s == 'E') {
	s++;
	if (*s == '+' || *s == '-')
	    s++;
	while (isDIGIT(*s))
	    s++;
    }
    while (isSPACE(*s))
	s++;
    if (s >= send)
	return TRUE;
    return FALSE;
}

d774 1
a774 1
FILE *fp;
d786 2
a787 2
	    fprintf(fp, ofmt, (double)SvIVX(sv));
	    return !ferror(fp);
d791 2
a792 2
	    fprintf(fp, ofmt, SvNVX(sv));
	    return !ferror(fp);
d804 2
a805 2
	    fprintf(fp, "%ld", (long)SvIVX(sv));
	    return !ferror(fp);
d812 1
a812 1
    if (len && (fwrite1(tmps,1,len,fp) == 0 || ferror(fp)))
d814 1
a814 1
    return TRUE;
d834 1
a834 1
	    return (laststatval = Fstat(fileno(IoIFP(io)), &statcache));
d945 2
d1006 1
a1006 1
	    execl("/bin/sh","sh","-c",cmd,(char*)0);
d1036 2
d1052 4
a1055 3
	    MAGIC *mg;
	    if (SvMAGICAL(*mark) && (mg = mg_find(*mark, 't')) && mg->mg_len & 1)
		tainted = TRUE;
d1088 2
d1187 4
d1193 1
d1240 1
a1240 1
#else /* ! MSDOS */
d1261 1
a1261 1
#endif /* ! MSDOS */
d1336 3
d1368 13
d1382 1
d1409 2
a1410 2
		croak("Bad arg length for %s, is %d, should be %d",
			op_desc[optype], len, infosize);
d1415 1
a1415 1
	I32 i = SvIV(astr);
d1428 4
d1433 1
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1999, Larry Wall
a20 1
#ifndef HAS_SEM
a21 1
#endif
d25 3
d37 1
a37 5
#  if defined(_MSC_VER) || defined(__MINGW32__)
#    include <sys/utime.h>
#  else
#    include <utime.h>
#  endif
a38 1

a44 14
#ifdef O_EXCL
#  define OPEN_EXCL O_EXCL
#else
#  define OPEN_EXCL 0
#endif

#if !defined(NSIG) || defined(M_UNIX) || defined(M_XENIX)
#include <signal.h>
#endif

/* XXX If this causes problems, set i_unistd=undef in the hint file.  */
#ifdef I_UNISTD
#  include <unistd.h>
#endif
a55 9
/* Put this after #includes because <unistd.h> defines _XOPEN_*. */
#ifndef Sock_size_t
#  if _XOPEN_VERSION >= 5 || defined(_XOPEN_SOURCE_EXTENDED) || defined(__GLIBC__)
#    define Sock_size_t Size_t
#  else
#    define Sock_size_t int
#  endif
#endif

d57 7
a63 1
do_open(GV *gv, register char *name, I32 len, int as_raw, int rawmode, int rawperm, PerlIO *supplied_fp)
d66 2
a67 2
    PerlIO *saveifp = Nullfp;
    PerlIO *saveofp = Nullfp;
d70 1
a70 1
    PerlIO *fp;
a72 1
    bool was_fdopen = FALSE;
d74 1
a74 1
    PL_forkprocess = 1;		/* assume true if no fork */
d77 1
a77 1
	fd = PerlIO_fileno(IoIFP(io));
d80 1
a80 1
	else if (fd <= PL_maxsysfd) {
d87 1
a87 1
	    result = PerlProc_pclose(IoIFP(io));
d90 2
a91 2
		result = PerlIO_close(IoOFP(io));
		PerlIO_close(IoIFP(io));	/* clear stdio, fd already closed */
d94 1
a94 1
		result = PerlIO_close(IoIFP(io));
d97 3
a99 3
	    result = PerlIO_close(IoIFP(io));
	if (result == EOF && fd > PL_maxsysfd)
	    PerlIO_printf(PerlIO_stderr(), "Warning: unable to close filehandle %s properly.\n",
d105 2
a106 16
#ifndef O_ACCMODE
#define O_ACCMODE 3		/* Assume traditional implementation */
#endif
	switch (result = rawmode & O_ACCMODE) {
	case O_RDONLY:
	     IoTYPE(io) = '<';
	     break;
	case O_WRONLY:
	     IoTYPE(io) = '>';
	     break;
	case O_RDWR:
	default:
	     IoTYPE(io) = '+';
	     break;
	}

d108 1
a108 2
	fd = PerlLIO_open3(name, rawmode, rawperm);

d112 3
a114 10
	    char *fpmode;
	    if (result == O_RDONLY)
		fpmode = "r";
#ifdef O_APPEND
	    else if (rawmode & O_APPEND)
		fpmode = (result == O_WRONLY) ? "a" : "a+";
#endif
	    else
		fpmode = (result == O_WRONLY) ? "w" : "r+";
	    fp = PerlIO_fdopen(fd, fpmode);
d116 1
a116 1
		PerlLIO_close(fd);
d144 3
a146 6
	    if (name[strlen(name)-1] == '|') {
		name[strlen(name)-1] = '\0' ;
		if (PL_dowarn)
		    warn("Can't do bidirectional pipe");
	    }
	    fp = PerlProc_popen(name,"w");
d186 1
a186 1
			    fd = PerlIO_fileno(IoIFP(thatio));
d194 2
a195 4
			fd = PerlLIO_dup(fd);
		    else
			was_fdopen = TRUE;
		    if (!(fp = PerlIO_fdopen(fd,mode))) {
d197 1
a197 2
			    PerlLIO_close(fd);
			}
d204 1
a204 1
		    fp = PerlIO_stdout();
d208 1
a208 1
		    fp = PerlIO_open(name,mode);
d219 1
a219 1
		fp = PerlIO_stdin();
d223 1
a223 1
		fp = PerlIO_open(name,mode);
d225 1
a225 1
	else if (len > 1 && name[len-1] == '|') {
d234 1
a234 1
	    fp = PerlProc_popen(name,"r");
d242 1
a242 1
		fp = PerlIO_stdin();
d246 1
a246 1
		fp = PerlIO_open(name,"r");
d250 1
a250 1
	if (PL_dowarn && IoTYPE(io) == '<' && strchr(name, '\n'))
d256 2
a257 3
	dTHR;
	if (PerlLIO_fstat(PerlIO_fileno(fp),&PL_statbuf) < 0) {
	    (void)PerlIO_close(fp);
d260 1
a260 1
	if (S_ISSOCK(PL_statbuf.st_mode))
d265 1
a265 1
	    !(PL_statbuf.st_mode & S_IFMT)
d267 1
a267 1
	    !PL_statbuf.st_mode
d270 3
a272 5
	    char tmpbuf[256];
	    Sock_size_t buflen = sizeof tmpbuf;
	    if (PerlSock_getsockname(PerlIO_fileno(fp), (struct sockaddr *)tmpbuf,
			    &buflen) >= 0
		  || errno != ENOTSOCK)
d279 1
a279 1
	fd = PerlIO_fileno(saveifp);
d281 1
a281 1
	    PerlIO_flush(saveofp);		/* emulate PerlIO_close() */
d283 1
a283 1
		PerlIO_close(saveofp);
d288 1
a288 1
	if (fd != PerlIO_fileno(fp)) {
d292 2
a293 2
	    PerlLIO_dup2(PerlIO_fileno(fp), fd);
	    sv = *av_fetch(PL_fdpid,PerlIO_fileno(fp),TRUE);
d297 1
a297 1
	    sv = *av_fetch(PL_fdpid,fd,TRUE);
d300 1
a300 2
	    if (!was_fdopen)
		PerlIO_close(fp);
d304 1
a304 1
	PerlIO_clearerr(fp);
d307 2
a308 6
    {
	int save_errno = errno;
	fd = PerlIO_fileno(fp);
	fcntl(fd,F_SETFD,fd > PL_maxsysfd); /* can change errno */
	errno = save_errno;
    }
a311 1
	dTHR;
d313 3
a315 3
	  || (IoTYPE(io) == '>' && S_ISCHR(PL_statbuf.st_mode)) ) {
	    if (!(IoOFP(io) = PerlIO_fdopen(PerlIO_fileno(fp),"w"))) {
		PerlIO_close(fp);
d332 3
a334 2
PerlIO *
nextargv(register GV *gv)
d344 4
a347 4
    if (!PL_argvoutgv)
	PL_argvoutgv = gv_fetchpv("ARGVOUT",TRUE,SVt_PVIO);
    if (PL_filemode & (S_ISUID|S_ISGID)) {
	PerlIO_flush(IoIFP(GvIOn(PL_argvoutgv)));  /* chmod must follow last write */
d349 1
a349 1
	(void)fchmod(PL_lastfd,PL_filemode);
d351 1
a351 1
	(void)PerlLIO_chmod(PL_oldname,PL_filemode);
d354 1
a354 1
    PL_filemode = 0;
d356 1
a356 2
	dTHR;
	STRLEN oldlen;
d361 3
a363 3
	PL_oldname = SvPVx(GvSV(gv), oldlen);
	if (do_open(gv,PL_oldname,oldlen,PL_inplace!=0,O_RDONLY,0,Nullfp)) {
	    if (PL_inplace) {
d365 1
a365 1
		if (oldlen == 1 && *PL_oldname == '-') {
d370 2
a371 2
		filedev = PL_statbuf.st_dev;
		fileino = PL_statbuf.st_ino;
d373 4
a376 4
		PL_filemode = PL_statbuf.st_mode;
		fileuid = PL_statbuf.st_uid;
		filegid = PL_statbuf.st_gid;
		if (!S_ISREG(PL_filemode)) {
d378 1
a378 1
		      PL_oldname );
d382 6
a387 16
		if (*PL_inplace) {
		    char *star = strchr(PL_inplace, '*');
		    if (star) {
			char *begin = PL_inplace;
			sv_setpvn(sv, "", 0);
			do {
			    sv_catpvn(sv, begin, star - begin);
			    sv_catpvn(sv, PL_oldname, oldlen);
			    begin = ++star;
			} while ((star = strchr(begin, '*')));
			if (*begin)
			    sv_catpv(sv,begin);
		    }
		    else {
			sv_catpv(sv,PL_inplace);
		    }
d389 4
a392 8
		    if (PerlLIO_stat(SvPVX(sv),&PL_statbuf) >= 0
		      && PL_statbuf.st_dev == filedev
		      && PL_statbuf.st_ino == fileino
#ifdef DJGPP
                      || (_djstat_fail_bits & _STFAIL_TRUENAME)!=0
#endif
                      ) {
			warn("Can't do inplace edit: %s would not be uniq",
d400 1
a400 1
		    if (PerlLIO_rename(PL_oldname,SvPVX(sv)) < 0) {
d402 1
a402 1
			  PL_oldname, SvPVX(sv), Strerror(errno) );
d408 4
a411 4
		    (void)PerlLIO_unlink(SvPVX(sv));
		    (void)PerlLIO_rename(PL_oldname,SvPVX(sv));
		    do_open(gv,SvPVX(sv),SvCUR(sv),PL_inplace!=0,O_RDONLY,0,Nullfp);
#endif /* DOSISH */
d414 1
a414 1
		    if (link(PL_oldname,SvPVX(sv)) < 0) {
d416 1
a416 1
			  PL_oldname, SvPVX(sv), Strerror(errno) );
d420 1
a420 1
		    (void)UNLINK(PL_oldname);
d424 4
a427 5
#if !defined(DOSISH) && !defined(AMIGAOS)
#  ifndef VMS  /* Don't delete; use automatic file versioning */
		    if (UNLINK(PL_oldname) < 0) {
			warn("Can't remove %s: %s, skipping file",
			  PL_oldname, Strerror(errno) );
a430 1
#  endif
d436 2
a437 2
		sv_setpvn(sv,">",!PL_inplace);
		sv_catpvn(sv,PL_oldname,oldlen);
d439 1
a439 7
#ifdef VMS
		if (!do_open(PL_argvoutgv,SvPVX(sv),SvCUR(sv),PL_inplace!=0,
                 O_WRONLY|O_CREAT|O_TRUNC,0,Nullfp)) { 
#else
		if (!do_open(PL_argvoutgv,SvPVX(sv),SvCUR(sv),PL_inplace!=0,
			     O_WRONLY|O_CREAT|OPEN_EXCL,0666,Nullfp)) {
#endif
d441 1
a441 1
		      PL_oldname, Strerror(errno) );
d445 3
a447 3
		setdefout(PL_argvoutgv);
		PL_lastfd = PerlIO_fileno(IoIFP(GvIOp(PL_argvoutgv)));
		(void)PerlLIO_fstat(PL_lastfd,&PL_statbuf);
d449 1
a449 1
		(void)fchmod(PL_lastfd,PL_filemode);
d451 1
a451 4
#  if !(defined(WIN32) && defined(__BORLANDC__))
		/* Borland runtime creates a readonly file! */
		(void)PerlLIO_chmod(PL_oldname,PL_filemode);
#  endif
d453 1
a453 1
		if (fileuid != PL_statbuf.st_uid || filegid != PL_statbuf.st_gid) {
d455 1
a455 1
		    (void)fchown(PL_lastfd,fileuid,filegid);
d458 1
a458 1
		    (void)PerlLIO_chown(PL_oldname,fileuid,filegid);
d466 1
a466 2
	    PerlIO_printf(PerlIO_stderr(), "Can't open %s: %s\n",
	      SvPV(sv, oldlen), Strerror(errno));
d468 2
a469 2
    if (PL_inplace) {
	(void)do_close(PL_argvoutgv,FALSE);
d477 4
a480 1
do_pipe(SV *sv, GV *rgv, GV *wgv)
d499 1
a499 1
    if (PerlProc_pipe(fd) < 0)
d501 2
a502 2
    IoIFP(rstio) = PerlIO_fdopen(fd[0], "r");
    IoOFP(wstio) = PerlIO_fdopen(fd[1], "w");
d507 4
a510 4
	if (IoIFP(rstio)) PerlIO_close(IoIFP(rstio));
	else PerlLIO_close(fd[0]);
	if (IoOFP(wstio)) PerlIO_close(IoOFP(wstio));
	else PerlLIO_close(fd[1]);
d514 1
a514 1
    sv_setsv(sv,&PL_sv_yes);
d518 1
a518 1
    sv_setsv(sv,&PL_sv_undef);
a522 1
/* explicit renamed to avoid C++ conflict    -- kja */
d524 7
a530 1
do_close(GV *gv, bool not_implicit)
d536 1
a536 1
	gv = PL_argvgv;
d538 1
a538 2
	if (not_implicit)
	    SETERRNO(EBADF,SS$_IVCHAN);
d543 2
a544 5
	if (not_implicit) {
	    if (PL_dowarn)
		warn("Close on unopened file <%s>",GvENAME(gv));
	    SETERRNO(EBADF,SS$_IVCHAN);
	}
d548 1
a548 1
    if (not_implicit) {
d558 2
a559 1
io_close(IO *io)
d566 3
a568 3
	    status = PerlProc_pclose(IoIFP(io));
	    STATUS_NATIVE_SET(status);
	    retval = (STATUS_POSIX == 0);
d574 2
a575 2
		retval = (PerlIO_close(IoOFP(io)) != EOF);
		PerlIO_close(IoIFP(io));	/* clear stdio, fd already closed */
d578 1
a578 1
		retval = (PerlIO_close(IoIFP(io)) != EOF);
a581 3
    else {
	SETERRNO(EBADF,SS$_IVCHAN);
    }
d587 2
a588 1
do_eof(GV *gv)
a589 1
    dTHR;
d600 4
a603 4
        if (PerlIO_has_cntptr(IoIFP(io))) {	/* (the code works without this) */
	    if (PerlIO_get_cnt(IoIFP(io)) > 0)	/* cheat a little, since */
		return FALSE;			/* this is the most usual case */
        }
d605 1
a605 1
	ch = PerlIO_getc(IoIFP(io));
d607 1
a607 1
	    (void)PerlIO_ungetc(IoIFP(io),ch);
d610 6
a615 6
        if (PerlIO_has_cntptr(IoIFP(io)) && PerlIO_canset_cnt(IoIFP(io))) {
	    if (PerlIO_get_cnt(IoIFP(io)) < -1)
		PerlIO_set_cnt(IoIFP(io),-1);
	}
	if (PL_op->op_flags & OPf_SPECIAL) { /* not necessarily a real EOF yet? */
	    if (!nextargv(PL_argvgv))	/* get another fp handy */
d625 2
a626 1
do_tell(GV *gv)
a628 1
    register PerlIO *fp;
d630 7
a636 1
    if (gv && (io = GvIO(gv)) && (fp = IoIFP(io))) {
d638 2
a639 2
	if (PerlIO_eof(fp))
	    (void)PerlIO_seek(fp, 0L, 2);	/* ultrix 1.2 workaround */
d641 5
a645 3
	return PerlIO_tell(fp);
    }
    if (PL_dowarn)
d652 4
a655 1
do_seek(GV *gv, long int pos, int whence)
a657 1
    register PerlIO *fp;
d659 7
a665 1
    if (gv && (io = GvIO(gv)) && (fp = IoIFP(io))) {
d667 2
a668 2
	if (PerlIO_eof(fp))
	    (void)PerlIO_seek(fp, 0L, 2);	/* ultrix 1.2 workaround */
d670 5
a674 3
	return PerlIO_seek(fp, pos, whence) >= 0;
    }
    if (PL_dowarn)
a679 54
long
do_sysseek(GV *gv, long int pos, int whence)
{
    register IO *io;
    register PerlIO *fp;

    if (gv && (io = GvIO(gv)) && (fp = IoIFP(io)))
	return PerlLIO_lseek(PerlIO_fileno(fp), pos, whence);
    if (PL_dowarn)
	warn("sysseek() on unopened file");
    SETERRNO(EBADF,RMS$_IFI);
    return -1L;
}

int
do_binmode(PerlIO *fp, int iotype, int flag)
{
    if (flag != TRUE)
	croak("panic: unsetting binmode"); /* Not implemented yet */
#ifdef DOSISH
#if defined(atarist) || defined(__MINT__)
    if (!PerlIO_flush(fp) && (fp->_flag |= _IOBIN))
	return 1;
    else
	return 0;
#else
    if (PerlLIO_setmode(PerlIO_fileno(fp), OP_BINARY) != -1) {
#if defined(WIN32) && defined(__BORLANDC__)
	/* The translation mode of the stream is maintained independent
	 * of the translation mode of the fd in the Borland RTL (heavy
	 * digging through their runtime sources reveal).  User has to
	 * set the mode explicitly for the stream (though they don't
	 * document this anywhere). GSAR 97-5-24
	 */
	PerlIO_seek(fp,0L,0);
	((FILE*)fp)->flags |= _F_BIN;
#endif
	return 1;
    }
    else
	return 0;
#endif
#else
#if defined(USEMYBINMODE)
    if (my_binmode(fp,iotype) != NULL)
	return 1;
    else
	return 0;
#else
    return 1;
#endif
#endif
}

d684 1
a684 1
I32 my_chsize(fd, length)
d688 1
d692 1
a692 1
    if (PerlLIO_fstat(fd, &filebuf) < 0)
d699 1
a699 1
	if ((PerlLIO_lseek(fd, (length - 1), 0)) < 0)
d704 1
a704 1
	if ((PerlLIO_write(fd, "", 1)) != 1)
d732 50
d783 3
a785 1
do_print(register SV *sv, PerlIO *fp)
d793 1
a793 1
    if (PL_ofmt) {
d797 2
a798 2
	    PerlIO_printf(fp, PL_ofmt, (double)SvIVX(sv));
	    return !PerlIO_error(fp);
d802 2
a803 2
	    PerlIO_printf(fp, PL_ofmt, SvNVX(sv));
	    return !PerlIO_error(fp);
d808 1
a808 1
	if (PL_dowarn)
d815 2
a816 2
	    PerlIO_printf(fp, "%ld", (long)SvIVX(sv));
	    return !PerlIO_error(fp);
d823 1
a823 1
    if (len && (PerlIO_write(fp,tmps,len) == 0 || PerlIO_error(fp)))
d825 1
a825 1
    return !PerlIO_error(fp);
d829 2
a830 1
my_stat(ARGSproto)
d832 1
a832 1
    djSP;
d836 2
a837 2
    if (PL_op->op_flags & OPf_REF) {
	EXTEND(SP,1);
d842 4
a845 4
	    PL_statgv = tmpgv;
	    sv_setpv(PL_statname,"");
	    PL_laststype = OP_STAT;
	    return (PL_laststatval = PerlLIO_fstat(PerlIO_fileno(IoIFP(io)), &PL_statcache));
d848 3
a850 3
	    if (tmpgv == PL_defgv)
		return PL_laststatval;
	    if (PL_dowarn)
d853 3
a855 3
	    PL_statgv = Nullgv;
	    sv_setpv(PL_statname,"");
	    return (PL_laststatval = -1);
a859 2
	char *s;
	STRLEN n_a;
d870 5
a874 6
	s = SvPV(sv, n_a);
	PL_statgv = Nullgv;
	sv_setpv(PL_statname, s);
	PL_laststype = OP_STAT;
	PL_laststatval = PerlLIO_stat(s, &PL_statcache);
	if (PL_laststatval < 0 && PL_dowarn && strchr(s, '\n'))
d876 1
a876 1
	return PL_laststatval;
d881 2
a882 1
my_lstat(ARGSproto)
d884 1
a884 1
    djSP;
d886 4
a889 5
    STRLEN n_a;
    if (PL_op->op_flags & OPf_REF) {
	EXTEND(SP,1);
	if (cGVOP->op_gv == PL_defgv) {
	    if (PL_laststype != OP_LSTAT)
d891 1
a891 1
	    return PL_laststatval;
d896 2
a897 2
    PL_laststype = OP_LSTAT;
    PL_statgv = Nullgv;
d900 1
a900 1
    sv_setpv(PL_statname,SvPV(sv, n_a));
d902 1
a902 1
    PL_laststatval = PerlLIO_lstat(SvPV(sv, n_a),&PL_statcache);
d904 1
a904 1
    PL_laststatval = PerlLIO_stat(SvPV(sv, n_a),&PL_statcache);
d906 1
a906 1
    if (PL_laststatval < 0 && PL_dowarn && strchr(SvPV(sv, n_a), '\n'))
d908 1
a908 1
    return PL_laststatval;
d912 4
a915 1
do_aexec(SV *really, register SV **mark, register SV **sp)
a918 1
    STRLEN n_a;
d921 2
a922 3
	dTHR;
	New(401,PL_Argv, sp - mark + 1, char*);
	a = PL_Argv;
d925 1
a925 1
		*a++ = SvPVx(*mark, n_a);
d930 1
a930 1
	if (*PL_Argv[0] != '/')	/* will execvp use PATH? */
d932 2
a933 2
	if (really && *(tmps = SvPV(really, n_a)))
	    PerlProc_execvp(tmps,PL_Argv);
d935 3
a937 3
	    PerlProc_execvp(PL_Argv[0],PL_Argv);
	if (PL_dowarn)
	    warn("Can't exec \"%s\": %s", PL_Argv[0], Strerror(errno));
d944 1
a944 1
do_execfree(void)
d946 7
a952 7
    if (PL_Argv) {
	Safefree(PL_Argv);
	PL_Argv = Null(char **);
    }
    if (PL_Cmd) {
	Safefree(PL_Cmd);
	PL_Cmd = Nullch;
a955 2
#if !defined(OS2) && !defined(WIN32) && !defined(DJGPP)

d957 2
a958 1
do_exec(char *cmd)
d970 1
a970 1
    if (strnEQ(cmd,PL_cshname,PL_cshlen) && strnEQ(cmd+PL_cshlen," -c",3)) {
d972 1
a972 1
	s = cmd+PL_cshlen+3;
d988 1
a988 1
		PerlProc_execl(PL_cshname,"csh", flags,ncmd,(char*)0);
d1015 1
a1015 1
	    PerlProc_execl(PL_sh_path, "sh", "-c", cmd, (char*)0);
d1020 4
a1023 4
    New(402,PL_Argv, (s - cmd) / 2 + 2, char*);
    PL_Cmd = savepvn(cmd, s-cmd);
    a = PL_Argv;
    for (s = PL_Cmd; *s;) {
d1032 2
a1033 2
    if (PL_Argv[0]) {
	PerlProc_execvp(PL_Argv[0],PL_Argv);
d1038 2
a1039 2
	if (PL_dowarn)
	    warn("Can't exec \"%s\": %s", PL_Argv[0], Strerror(errno));
a1044 2
#endif /* OS2 || WIN32 */

d1046 4
a1049 1
apply(I32 type, register SV **mark, register SV **sp)
a1050 1
    dTHR;
a1053 1
    char *what;
a1055 6
    STRLEN n_a;

#define APPLY_TAINT_PROPER() \
    STMT_START {							\
	if (PL_tainted) { TAINT_PROPER(what); }				\
    } STMT_END
d1057 1
a1057 2
    /* This is a first heuristic; it doesn't catch tainting magic. */
    if (PL_tainting) {
d1059 3
a1061 4
	    if (SvTAINTED(*mark)) {
		TAINT;
		break;
	    }
d1067 1
a1067 2
	what = "chmod";
	APPLY_TAINT_PROPER();
d1069 1
a1070 2
	    APPLY_TAINT_PROPER();
	    tot = sp - mark;
d1072 1
a1072 3
		char *name = SvPVx(*mark, n_a);
		APPLY_TAINT_PROPER();
		if (PerlLIO_chmod(name, val))
d1079 1
a1079 2
	what = "chown";
	APPLY_TAINT_PROPER();
a1082 1
	    APPLY_TAINT_PROPER();
d1085 1
a1085 3
		char *name = SvPVx(*mark, n_a);
		APPLY_TAINT_PROPER();
		if (PerlLIO_chown(name, val, val2))
a1090 6
/* 
XXX Should we make lchown() directly available from perl?
For now, we'll let Configure test for HAS_LCHOWN, but do
nothing in the core.
    --AD  5/1998
*/
d1093 3
a1095 5
	what = "kill";
	APPLY_TAINT_PROPER();
	if (mark == sp)
	    break;
	s = SvPVx(*++mark, n_a);
a1103 2
	APPLY_TAINT_PROPER();
	tot = sp - mark;
a1115 1
		APPLY_TAINT_PROPER();
a1137 1
		APPLY_TAINT_PROPER();
d1139 1
a1139 1
		if (PerlProc_killpg(proc,val))	/* BSD */
d1141 1
a1141 1
		if (PerlProc_kill(-proc,val))	/* SYSV */
d1148 1
a1148 3
		I32 proc = SvIVx(*mark);
		APPLY_TAINT_PROPER();
		if (PerlProc_kill(proc, val))
d1155 1
a1155 2
	what = "unlink";
	APPLY_TAINT_PROPER();
d1158 2
a1159 3
	    s = SvPVx(*mark, n_a);
	    APPLY_TAINT_PROPER();
	    if (PL_euid || PL_unsafe) {
d1165 1
a1165 1
		if (PerlLIO_lstat(s,&PL_statbuf) < 0 || S_ISDIR(PL_statbuf.st_mode))
d1167 1
a1167 1
		if (PerlLIO_stat(s,&PL_statbuf) < 0 || S_ISDIR(PL_statbuf.st_mode))
d1179 1
a1179 2
	what = "utime";
	APPLY_TAINT_PROPER();
d1185 2
a1186 2
		Time_t	actime;
		Time_t	modtime;
d1191 2
a1192 8
#ifdef BIG_TIME
	    utbuf.actime = (Time_t)SvNVx(*++mark);	/* time accessed */
	    utbuf.modtime = (Time_t)SvNVx(*++mark);	/* time modified */
#else
	    utbuf.actime = (Time_t)SvIVx(*++mark);	/* time accessed */
	    utbuf.modtime = (Time_t)SvIVx(*++mark);	/* time modified */
#endif
	    APPLY_TAINT_PROPER();
d1195 1
a1195 3
		char *name = SvPVx(*mark, n_a);
		APPLY_TAINT_PROPER();
		if (PerlLIO_utime(name, &utbuf))
a1204 2

#undef APPLY_TAINT_PROPER
d1210 4
a1213 1
cando(I32 bit, I32 effective, register struct stat *statbufp)
d1239 2
a1240 2
#else /* ! DOSISH */
    if ((effective ? PL_euid : PL_uid) == 0) {	/* root is special */
d1249 1
a1249 1
    if (statbufp->st_uid == (effective ? PL_euid : PL_uid) ) {
d1260 1
a1260 1
#endif /* ! DOSISH */
d1265 3
a1267 1
ingroup(I32 testgid, I32 effective)
d1269 1
a1269 1
    if (testgid == (effective ? PL_egid : PL_gid))
d1291 4
a1294 1
do_ipcget(I32 optype, SV **mark, SV **sp)
a1295 1
    dTHR;
d1326 4
a1329 1
do_ipcctl(I32 optype, SV **mark, SV **sp)
a1330 1
    dTHR;
d1364 2
a1365 3
	    union semun semun;

            semun.buf = &semds;
a1366 2
	    if (Semctl(id, 0, IPC_STAT, semun) == -1)
		return -1;
d1391 2
a1392 2
		croak("Bad arg length for %s, is %lu, should be %ld",
			op_desc[optype], (unsigned long)len, (long)infosize);
d1397 1
a1397 1
	IV i = SvIV(astr);
d1409 2
a1410 6
    case OP_SEMCTL: {
            union semun unsemds;

            unsemds.buf = (struct semid_ds *)a;
	    ret = Semctl(id, n, cmd, unsemds);
        }
d1428 3
a1430 1
do_msgsnd(SV **mark, SV **sp)
a1432 1
    dTHR;
d1452 3
a1454 1
do_msgrcv(SV **mark, SV **sp)
a1456 1
    dTHR;
d1490 3
a1492 1
do_semop(SV **mark, SV **sp)
a1494 1
    dTHR;
d1516 4
a1519 1
do_shmio(I32 optype, SV **mark, SV **sp)
a1521 1
    dTHR;
d1539 1
a1539 1
    shm = (char *)shmat(id, (char*)NULL, (optype == OP_SHMREAD) ? SHM_RDONLY : 0);
a1567 1

@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2000, Larry Wall
a17 1
#define PERL_IN_DOIO_C
d30 1
a30 1
    extern Shmat_t shmat (int, char *, int);
d43 6
d66 1
a66 6
# if defined(USE_SOCKS) && defined(I_SOCKS)
#   include <socks.h>
# endif 
# ifdef I_NETBSD
#  include <netdb.h>
# endif
d74 8
a81 7
bool
Perl_do_open(pTHX_ GV *gv, register char *name, I32 len, int as_raw,
	     int rawmode, int rawperm, PerlIO *supplied_fp)
{
    return do_open9(gv, name, len, as_raw, rawmode, rawperm,
		    supplied_fp, Nullsv, 0);
}
d84 1
a84 3
Perl_do_open9(pTHX_ GV *gv, register char *name, I32 len, int as_raw,
	      int rawmode, int rawperm, PerlIO *supplied_fp, SV *svs,
	      I32 num_svs)
a94 1
    bool in_raw = 0, in_crlf = 0, out_raw = 0, out_crlf = 0;
a97 9
    if (PL_op && PL_op->op_type == OP_OPEN) {
	/* set up disciplines */
	U8 flags = PL_op->op_private;
	in_raw = (flags & OPpOPEN_IN_RAW);
	in_crlf = (flags & OPpOPEN_IN_CRLF);
	out_raw = (flags & OPpOPEN_OUT_RAW);
	out_crlf = (flags & OPpOPEN_OUT_CRLF);
    }

d113 1
a113 1
		PerlIO_close(IoIFP(io)); /* clear stdio, fd already closed */
d121 2
a122 3
	    PerlIO_printf(Perl_error_log,
			  "Warning: unable to close filehandle %s properly.\n",
			  GvENAME(gv));
a126 4
#if defined(USE_64_BIT_RAWIO) && defined(O_LARGEFILE)
	rawmode |= O_LARGEFILE;
#endif

a129 1

d149 1
a149 2
	    char fpmode[4];
	    STRLEN ix = 0;
d151 1
a151 1
		fpmode[ix++] = 'r';
d153 2
a154 5
	    else if (rawmode & O_APPEND) {
		fpmode[ix++] = 'a';
		if (result != O_WRONLY)
		    fpmode[ix++] = '+';
	    }
d156 2
a157 11
	    else {
		if (result == O_WRONLY)
		    fpmode[ix++] = 'w';
		else {
		    fpmode[ix++] = 'r';
		    fpmode[ix++] = '+';
		}
	    }
	    if (rawmode & O_BINARY)
		fpmode[ix++] = 'b';
	    fpmode[ix] = '\0';
d164 2
a165 5
	char *type;
	char *oname = name;
	STRLEN tlen;
	STRLEN olen = len;
	char mode[4];		/* stdio file mode ("r\0", "rb\0", "r+b\0" etc.) */
d168 11
a178 21
	type = savepvn(name, len);
	tlen = len;
	SAVEFREEPV(type);
	if (num_svs) {
	    STRLEN l;
	    name = SvPV(svs, l) ;
	    len = (I32)l;
	    name = savepvn(name, len);
	    SAVEFREEPV(name);
	}
	else {
	    while (tlen && isSPACE(type[tlen-1]))
		type[--tlen] = '\0';
	    name = type;
	    len = tlen;
	}
	mode[0] = mode[1] = mode[2] = mode[3] = '\0';
	IoTYPE(io) = *type;
	if (*type == '+' && tlen > 1 && type[tlen-1] != '|') { /* scary */
	    mode[1] = *type++;
	    --tlen;
d182 1
a182 5
	if (*type == '|') {
	    if (num_svs && (tlen != 2 || type[1] != '-')) {
	      unknown_desr:
		Perl_croak(aTHX_ "Unknown open() mode '%.*s'", (int)olen, oname);
	    }
d184 2
a185 13
	    for (type++, tlen--; isSPACE(*type); type++, tlen--) ;
	    if (!num_svs) {
		name = type;
		len = tlen;
	    }
	    if (*name == '\0') { /* command is missing 19990114 */
		dTHR;
		if (ckWARN(WARN_PIPE))
		    Perl_warner(aTHX_ WARN_PIPE, "Missing command in piped open");
		errno = EPIPE;
		goto say_false;
	    }
	    if (strNE(name,"-") || num_svs)
d188 4
a191 15
	    if (name[len-1] == '|') {
		dTHR;
		name[--len] = '\0' ;
		if (ckWARN(WARN_PIPE))
		    Perl_warner(aTHX_ WARN_PIPE, "Can't open bidirectional pipe");
	    }
	    {
		char *mode;
		if (out_raw)
		    mode = "wb";
		else if (out_crlf)
		    mode = "wt";
		else
		    mode = "w";
		fp = PerlProc_popen(name,mode);
d193 1
d196 1
a196 1
	else if (*type == '>') {
d198 2
a199 2
	    type++;
	    if (*type == '>') {
d201 1
a201 2
		type++;
		tlen--;
d207 1
a207 9
	    if (out_raw)
		strcat(mode, "b");
	    else if (out_crlf)
		strcat(mode, "t");

	    if (num_svs && tlen != 1)
	        goto unknown_desr;
	    if (*type == '&') {
		name = type;
d233 1
a233 13
			    PerlIO *fp = IoIFP(thatio);
			    /* Flush stdio buffer before dup. --mjd
			     * Unfortunately SEEK_CURing 0 seems to
			     * be optimized away on most platforms;
			     * only Solaris and Linux seem to flush
			     * on that. --jhi */
			    PerlIO_seek(fp, 0, SEEK_CUR);
			    /* On the other hand, do all platforms
			     * take gracefully to flushing a read-only
			     * filehandle?  Perhaps we should do
			     * fsetpos(src)+fgetpos(dst)?  --nik */
			    PerlIO_flush(fp);
			    fd = PerlIO_fileno(fp);
d247 1
a247 1
		    }
d252 2
a253 2
		for (; isSPACE(*type); type++) ;
		if (strEQ(type,"-")) {
d258 1
a258 1
		    fp = PerlIO_open((num_svs ? name : type), mode);
d262 1
a262 3
	else if (*type == '<') {
	    if (num_svs && tlen != 1)
	        goto unknown_desr;
d264 1
a264 1
	    for (type++; isSPACE(*type); type++) ;
d266 1
a266 7
	    if (in_raw)
		strcat(mode, "b");
	    else if (in_crlf)
		strcat(mode, "t");

	    if (*type == '&') {
		name = type;
d268 1
a268 2
	    }
	    if (strEQ(type,"-")) {
d273 1
a273 1
		fp = PerlIO_open((num_svs ? name : type), mode);
d275 7
a281 21
	else if (tlen > 1 && type[tlen-1] == '|') {
	    if (num_svs) {
		if (tlen != 2 || type[0] != '-')
		    goto unknown_desr;
	    }
	    else {
		type[--tlen] = '\0';
		while (tlen && isSPACE(type[tlen-1]))
		    type[--tlen] = '\0';
		/*SUPPRESS 530*/
		for (; isSPACE(*type); type++) ;
		name = type;
	    }
	    if (*name == '\0') { /* command is missing 19990114 */
		dTHR;
		if (ckWARN(WARN_PIPE))
		    Perl_warner(aTHX_ WARN_PIPE, "Missing command in piped open");
		errno = EPIPE;
		goto say_false;
	    }
	    if (strNE(name,"-") || num_svs)
d284 1
a284 10
	    {
		char *mode;
		if (in_raw)
		    mode = "rb";
		else if (in_crlf)
		    mode = "rt";
		else
		    mode = "r";
		fp = PerlProc_popen(name,mode);
	    }
a287 3
	    if (num_svs)
		goto unknown_desr;
	    name = type;
d295 2
a296 10
	    else {
		char *mode;
		if (in_raw)
		    mode = "rb";
		else if (in_crlf)
		    mode = "rt";
		else
		    mode = "r";
		fp = PerlIO_open(name,mode);
	    }
d300 2
a301 3
	dTHR;
	if (ckWARN(WARN_NEWLINE) && IoTYPE(io) == '<' && strchr(name, '\n'))
	    Perl_warner(aTHX_ WARN_NEWLINE, PL_warn_nl, "open");
d342 1
a342 1
	    Pid_t pid;
a368 1
    IoFLAGS(io) &= ~IOf_NOLINE;
d372 2
a373 11
	    || (IoTYPE(io) == '>' && S_ISCHR(PL_statbuf.st_mode)) )
	{
	    char *mode;
	    if (out_raw)
		mode = "wb";
	    else if (out_crlf)
		mode = "wt";
	    else
		mode = "w";

	    if (!(IoOFP(io) = PerlIO_fdopen(PerlIO_fileno(fp),mode))) {
d392 1
a392 1
Perl_nextargv(pTHX_ register GV *gv)
d399 2
a400 3
    Uid_t fileuid;
    Gid_t filegid;
    IO *io = GvIOp(gv);
a403 8
    if (io && (IoFLAGS(io) & IOf_ARGV) && (IoFLAGS(io) & IOf_START)) {
	IoFLAGS(io) &= ~IOf_START;
	if (PL_inplace) {
	    if (!PL_argvout_stack)
		PL_argvout_stack = newAV();
	    av_push(PL_argvout_stack, SvREFCNT_inc(PL_defoutgv));
	}
    }
d436 2
a437 4
		    if (ckWARN_d(WARN_INPLACE))	
		        Perl_warner(aTHX_ WARN_INPLACE,
			    "Can't do inplace edit: %s is not a regular file",
		            PL_oldname );
d464 3
a466 6
                      )
		    {
			if (ckWARN_d(WARN_INPLACE))	
			    Perl_warner(aTHX_ WARN_INPLACE,
			      "Can't do inplace edit: %s would not be unique",
			      SvPVX(sv));
d472 1
a472 1
#if !defined(DOSISH) && !defined(__CYGWIN__)
d474 2
a475 4
		        if (ckWARN_d(WARN_INPLACE))	
			    Perl_warner(aTHX_ WARN_INPLACE, 
			      "Can't rename %s to %s: %s, skipping file",
			      PL_oldname, SvPVX(sv), Strerror(errno) );
d488 2
a489 4
		        if (ckWARN_d(WARN_INPLACE))	
			    Perl_warner(aTHX_ WARN_INPLACE,
			      "Can't rename %s to %s: %s, skipping file",
			      PL_oldname, SvPVX(sv), Strerror(errno) );
d500 2
a501 4
		        if (ckWARN_d(WARN_INPLACE))	
			    Perl_warner(aTHX_ WARN_INPLACE,
			      "Can't remove %s: %s, skipping file",
			      PL_oldname, Strerror(errno) );
d507 1
a507 1
		    Perl_croak(aTHX_ "Can't do inplace edit without backup");
d516 1
a516 1
                 O_WRONLY|O_CREAT|O_TRUNC,0,Nullfp))
d519 1
a519 1
			     O_WRONLY|O_CREAT|OPEN_EXCL,0666,Nullfp))
d521 2
a522 4
		{
		    if (ckWARN_d(WARN_INPLACE))	
		        Perl_warner(aTHX_ WARN_INPLACE, "Can't do inplace edit on %s: %s",
		          PL_oldname, Strerror(errno) );
d549 3
a551 16
	else {
	    dTHR;
	    if (ckWARN_d(WARN_INPLACE)) {
		int eno = errno;
		if (PerlLIO_stat(PL_oldname, &PL_statbuf) >= 0
		    && !S_ISREG(PL_statbuf.st_mode))	
		{
		    Perl_warner(aTHX_ WARN_INPLACE,
				"Can't do inplace edit: %s is not a regular file",
				PL_oldname);
		}
		else
		    Perl_warner(aTHX_ WARN_INPLACE, "Can't open %s: %s",
				PL_oldname, Strerror(eno));
	    }
	}
a552 2
    if (io && (IoFLAGS(io) & IOf_ARGV))
	IoFLAGS(io) |= IOf_START;
a554 8
	if (io && (IoFLAGS(io) & IOf_ARGV)
	    && PL_argvout_stack && AvFILLp(PL_argvout_stack) >= 0)
	{
	    GV *oldout = (GV*)av_pop(PL_argvout_stack);
	    setdefout(oldout);
	    SvREFCNT_dec(oldout);
	    return Nullfp;
	}
d562 1
a562 1
Perl_do_pipe(pTHX_ SV *sv, GV *rgv, GV *wgv)
d607 1
a607 1
Perl_do_close(pTHX_ GV *gv, bool not_implicit)
d622 2
a623 4
	    dTHR;
	    if (ckWARN(WARN_UNOPENED))
		Perl_warner(aTHX_ WARN_UNOPENED, 
		       "Close on unopened file <%s>",GvENAME(gv));
d628 1
a628 1
    retval = io_close(io, not_implicit);
d639 1
a639 1
Perl_io_close(pTHX_ IO *io, bool not_implicit)
d647 2
a648 7
	    if (not_implicit) {
		STATUS_NATIVE_SET(status);
		retval = (STATUS_POSIX == 0);
	    }
	    else {
		retval = (status != -1);
	    }
d662 1
a662 1
    else if (not_implicit) {
d670 1
a670 1
Perl_do_eof(pTHX_ GV *gv)
a679 9
    else if (ckWARN(WARN_IO)
	     && (IoTYPE(io) == '>' || IoIFP(io) == PerlIO_stdout()
		 || IoIFP(io) == PerlIO_stderr()))
    {
	SV* sv = sv_newmortal();
	gv_efullname3(sv, gv, Nullch);
	Perl_warner(aTHX_ WARN_IO, "Filehandle %s opened only for output",
		    SvPV_nolen(sv));
    }
d707 2
a708 2
Off_t
Perl_do_tell(pTHX_ GV *gv)
d720 2
a721 5
    {
	dTHR;
	if (ckWARN(WARN_UNOPENED))
	    Perl_warner(aTHX_ WARN_UNOPENED, "tell() on unopened file");
    }
d723 1
a723 1
    return (Off_t)-1;
d727 1
a727 1
Perl_do_seek(pTHX_ GV *gv, Off_t pos, int whence)
d739 2
a740 5
    {
	dTHR;
	if (ckWARN(WARN_UNOPENED))
	    Perl_warner(aTHX_ WARN_UNOPENED, "seek() on unopened file");
    }
d745 2
a746 2
Off_t
Perl_do_sysseek(pTHX_ GV *gv, Off_t pos, int whence)
d753 2
a754 5
    {
	dTHR;
	if (ckWARN(WARN_UNOPENED))
	    Perl_warner(aTHX_ WARN_UNOPENED, "sysseek() on unopened file");
    }
d756 1
a756 1
    return (Off_t)-1;
d760 1
a760 52
Perl_mode_from_discipline(pTHX_ SV *discp)
{
    int mode = O_BINARY;
    if (discp) {
	STRLEN len;
	char *s = SvPV(discp,len);
	while (*s) {
	    if (*s == ':') {
		switch (s[1]) {
		case 'r':
		    if (len > 3 && strnEQ(s+1, "raw", 3)
			&& (!s[4] || s[4] == ':' || isSPACE(s[4])))
		    {
			mode = O_BINARY;
			s += 4;
			len -= 4;
			break;
		    }
		    /* FALL THROUGH */
		case 'c':
		    if (len > 4 && strnEQ(s+1, "crlf", 4)
			&& (!s[5] || s[5] == ':' || isSPACE(s[5])))
		    {
			mode = O_TEXT;
			s += 5;
			len -= 5;
			break;
		    }
		    /* FALL THROUGH */
		default:
		    goto fail_discipline;
		}
	    }
	    else if (isSPACE(*s)) {
		++s;
		--len;
	    }
	    else {
		char *end;
fail_discipline:
		end = strchr(s+1, ':');
		if (!end)
		    end = s+len;
		Perl_croak(aTHX_ "Unknown discipline '%.*s'", end-s, s);
	    }
	}
    }
    return mode;
}

int
Perl_do_binmode(pTHX_ PerlIO *fp, int iotype, int mode)
d762 2
d765 2
a766 6
#  if defined(atarist) || defined(__MINT__)
    if (!PerlIO_flush(fp)) {
	if (mode & O_BINARY)
	    ((FILE*)fp)->_flag |= _IOBIN;
	else
	    ((FILE*)fp)->_flag &= ~ _IOBIN;
d768 5
a772 5
    }
    return 0;
#  else
    if (PerlLIO_setmode(PerlIO_fileno(fp), mode) != -1) {
#    if defined(WIN32) && defined(__BORLANDC__)
d780 2
a781 5
	if (mode & O_BINARY)
	    ((FILE*)fp)->flags |= _F_BIN;
	else
	    ((FILE*)fp)->flags &= ~ _F_BIN;
#    endif
d786 1
a786 1
#  endif
d788 2
a789 2
#  if defined(USEMYBINMODE)
    if (my_binmode(fp, iotype, mode) != FALSE)
d793 1
a793 1
#  else
d795 1
a795 1
#  endif
d851 1
a851 1
Perl_do_print(pTHX_ register SV *sv, PerlIO *fp)
d863 1
a863 1
	    PerlIO_printf(fp, PL_ofmt, (NV)SvIVX(sv));
d874 2
a875 5
	{
	    dTHR;
	    if (ckWARN(WARN_UNINITIALIZED))
		report_uninit();
	}
d881 1
a881 4
	    if (SvIsUV(sv))
		PerlIO_printf(fp, "%"UVuf, (UV)SvUVX(sv));
	    else
		PerlIO_printf(fp, "%"IVdf, (IV)SvIVX(sv));
a888 6
    /* To detect whether the process is about to overstep its
     * filesize limit we would need getrlimit().  We could then
     * also transparently raise the limit with setrlimit() --
     * but only until the system hard limit/the filesystem limit,
     * at which we would get EPERM.  Note that when using buffered
     * io the write failure can be delayed until the flush/close. --jhi */
d895 1
a895 1
Perl_my_stat(pTHX)
d903 1
a903 1
	tmpgv = cGVOP_gv;
d915 2
a916 2
	    if (ckWARN(WARN_UNOPENED))
		Perl_warner(aTHX_ WARN_UNOPENED, "Stat on unopened file <%s>",
d942 2
a943 2
	if (PL_laststatval < 0 && ckWARN(WARN_NEWLINE) && strchr(s, '\n'))
	    Perl_warner(aTHX_ WARN_NEWLINE, PL_warn_nl, "stat");
d949 1
a949 1
Perl_my_lstat(pTHX)
d956 1
a956 1
	if (cGVOP_gv == PL_defgv) {
d958 1
a958 1
		Perl_croak(aTHX_ "The stat preceding -l _ wasn't an lstat");
d961 1
a961 1
	Perl_croak(aTHX_ "You can't use -l on a filehandle");
d969 1
d971 5
a975 2
    if (PL_laststatval < 0 && ckWARN(WARN_NEWLINE) && strchr(SvPV(sv, n_a), '\n'))
	Perl_warner(aTHX_ WARN_NEWLINE, PL_warn_nl, "lstat");
d980 1
a980 8
Perl_do_aexec(pTHX_ SV *really, register SV **mark, register SV **sp)
{
    return do_aexec5(really, mark, sp, 0, 0);
}

bool
Perl_do_aexec5(pTHX_ SV *really, register SV **mark, register SV **sp,
	       int fd, int do_report)
a981 3
#ifdef MACOS_TRADITIONAL
    Perl_croak(aTHX_ "exec? I'm not *that* kind of operating system");
#else
d1003 2
a1004 9
	if (ckWARN(WARN_EXEC))
	    Perl_warner(aTHX_ WARN_EXEC, "Can't exec \"%s\": %s", 
		PL_Argv[0], Strerror(errno));
	if (do_report) {
	    int e = errno;

	    PerlLIO_write(fd, (void*)&e, sizeof(int));
	    PerlLIO_close(fd);
	}
a1006 1
#endif
d1011 1
a1011 1
Perl_do_execfree(pTHX)
d1023 1
a1023 1
#if !defined(OS2) && !defined(WIN32) && !defined(DJGPP) && !defined(EPOC) && !defined(MACOS_TRADITIONAL)
d1026 1
a1026 7
Perl_do_exec(pTHX_ char *cmd)
{
    return do_exec3(cmd,0,0);
}

bool
Perl_do_exec3(pTHX_ char *cmd, int fd, int do_report)
d1072 1
a1072 1
    for (s = cmd; *s && isALNUM(*s); s++) ;	/* catch VAR=val gizmo */
a1081 14
	    /* handle the 2>&1 construct at the end */
	    if (*s == '>' && s[1] == '&' && s[2] == '1'
		&& s > cmd + 1 && s[-1] == '2' && isSPACE(s[-2])
		&& (!s[3] || isSPACE(s[3])))
	    {
		char *t = s + 3;

		while (*t && isSPACE(*t))
		    ++t;
		if (!*t && (dup2(1,2) != -1)) {
		    s[-2] = '\0';
		    break;
		}
	    }
d1106 2
a1107 12
	{
	    dTHR;
	    int e = errno;

	    if (ckWARN(WARN_EXEC))
		Perl_warner(aTHX_ WARN_EXEC, "Can't exec \"%s\": %s", 
		    PL_Argv[0], Strerror(errno));
	    if (do_report) {
		PerlLIO_write(fd, (void*)&e, sizeof(int));
		PerlLIO_close(fd);
	    }
	}
d1116 1
a1116 1
Perl_apply(pTHX_ I32 type, register SV **mark, register SV **sp)
d1193 1
a1193 1
		Perl_croak(aTHX_ "Unrecognized signal name \"%s\"",s);
d1265 1
d1267 3
d1321 2
a1322 4
bool
Perl_cando(pTHX_ Mode_t mode, Uid_t effective, register Stat_t *statbufp)
/* Note: we use `effective' both for uids and gids.
 * Here we are betting on Uid_t being equal or wider than Gid_t.  */
d1346 1
a1346 1
     return (mode & statbufp->st_mode) ? TRUE : FALSE;
d1350 1
a1350 1
	if (mode == S_IXUSR) {
d1359 1
a1359 1
	if (statbufp->st_mode & mode)
d1362 2
a1363 2
    else if (ingroup(statbufp->st_gid,effective)) {
	if (statbufp->st_mode & mode >> 3)
d1366 1
a1366 1
    else if (statbufp->st_mode & mode >> 6)
d1373 2
a1374 2
bool
Perl_ingroup(pTHX_ Gid_t testgid, Uid_t effective)
a1375 4
#ifdef MACOS_TRADITIONAL
    /* This is simply not correct for AppleShare, but fix it yerself. */
    return TRUE;
#else
a1392 1
#endif
d1398 1
a1398 1
Perl_do_ipcget(pTHX_ I32 optype, SV **mark, SV **sp)
d1424 1
a1424 1
	Perl_croak(aTHX_ "%s not implemented", PL_op_desc[optype]);
d1431 1
a1431 1
Perl_do_ipcctl(pTHX_ I32 optype, SV **mark, SV **sp)
a1461 1
#ifdef Semctl
d1468 1
a1468 3
#ifdef EXTRA_F_IN_SEMUN_BUF
            semun.buff = &semds;
#else
a1469 1
#endif
a1476 3
#else
	Perl_croak(aTHX_ "%s not implemented", PL_op_desc[optype]);
#endif
d1481 1
a1481 1
	Perl_croak(aTHX_ "%s not implemented", PL_op_desc[optype]);
d1497 2
a1498 4
		Perl_croak(aTHX_ "Bad arg length for %s, is %lu, should be %ld",
		      PL_op_desc[optype],
		      (unsigned long)len,
		      (long)infosize);
d1504 1
a1504 1
	a = INT2PTR(char *,i);		/* ouch */
a1515 1
#ifdef Semctl
a1517 3
#ifdef EXTRA_F_IN_SEMUN_BUF
            unsemds.buff = (struct semid_ds *)a;
#else
a1518 1
#endif
a1519 3
#else
	    Perl_croak(aTHX_ "%s not implemented", PL_op_desc[optype]);
#endif
d1538 1
a1538 1
Perl_do_msgsnd(pTHX_ SV **mark, SV **sp)
d1552 1
a1552 1
	Perl_croak(aTHX_ "Arg too short for msgsnd");
d1556 1
a1556 1
    Perl_croak(aTHX_ "msgsnd not implemented");
d1561 1
a1561 1
Perl_do_msgrcv(pTHX_ SV **mark, SV **sp)
d1576 6
a1589 4
#ifndef INCOMPLETE_TAINTS
	/* who knows who has been playing with this message? */
	SvTAINTED_on(mstr);
#endif
d1593 1
a1593 1
    Perl_croak(aTHX_ "msgrcv not implemented");
d1598 1
a1598 1
Perl_do_semop(pTHX_ SV **mark, SV **sp)
d1618 1
a1618 1
    Perl_croak(aTHX_ "semop not implemented");
d1623 1
a1623 1
Perl_do_shmio(pTHX_ I32 optype, SV **mark, SV **sp)
a1647 3
	/* suppress warning when reading into undef var (tchrist 3/Mar/00) */
	if (! SvOK(mstr))
	    sv_setpvn(mstr, "", 0);
a1654 4
#ifndef INCOMPLETE_TAINTS
	/* who knows who has been playing with this shared memory? */
	SvTAINTED_on(mstr);
#endif
d1668 1
a1668 1
    Perl_croak(aTHX_ "shm I/O not implemented");
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2001, Larry Wall
d54 20
d90 1
a90 1
    char savetype = IoTYPE_CLOSED;
d111 1
a111 1
	if (IoTYPE(io) == IoTYPE_STD)
d119 1
a119 1
	else if (IoTYPE(io) == IoTYPE_PIPE)
d149 1
a149 1
	     IoTYPE(io) = IoTYPE_RDONLY;
d152 1
a152 1
	     IoTYPE(io) = IoTYPE_WRONLY;
d156 1
a156 1
	     IoTYPE(io) = IoTYPE_RDWR;
d219 1
a219 1
	if (*type == IoTYPE_RDWR && tlen > 1 && type[tlen-1] != IoTYPE_PIPE) { /* scary */
d225 2
a226 2
	if (*type == IoTYPE_PIPE) {
	    if (num_svs && (tlen != 2 || type[1] != IoTYPE_STD)) {
d237 1
d247 1
d264 1
a264 1
	else if (*type == IoTYPE_WRONLY) {
d267 2
a268 3
	    if (*type == IoTYPE_WRONLY) {
		/* Two IoTYPE_WRONLYs in a row make for an IoTYPE_APPEND. */
		mode[0] = IoTYPE(io) = IoTYPE_APPEND;
d316 1
a316 7
#ifdef USE_SFIO
			    /* sfio fails to clear error on next
			       sfwrite, contrary to documentation.
			       -- Nick Clark */
			    if (PerlIO_seek(fp, 0, SEEK_CUR) == -1)
				PerlIO_clearerr(fp);
#endif
d323 2
a324 11
			    /* When dup()ing STDIN, STDOUT or STDERR
			     * explicitly set appropriate access mode */
			    if (IoIFP(thatio) == PerlIO_stdout()
				|| IoIFP(thatio) == PerlIO_stderr())
			        IoTYPE(io) = IoTYPE_WRONLY;
			    else if (IoIFP(thatio) == PerlIO_stdin())
                                IoTYPE(io) = IoTYPE_RDONLY;
			    /* When dup()ing a socket, say result is
			     * one as well */
			    else if (IoTYPE(thatio) == IoTYPE_SOCKET)
				IoTYPE(io) = IoTYPE_SOCKET;
d342 1
a342 1
		if (*type == IoTYPE_STD && !type[1]) {
d344 1
a344 1
		    IoTYPE(io) = IoTYPE_STD;
d351 1
a351 1
	else if (*type == IoTYPE_RDONLY) {
d366 1
a366 1
	    if (*type == IoTYPE_STD && !type[1]) {
d368 1
a368 1
		IoTYPE(io) = IoTYPE_STD;
d373 1
a373 1
	else if (tlen > 1 && type[tlen-1] == IoTYPE_PIPE) {
d375 1
a375 1
		if (tlen != 2 || type[0] != IoTYPE_STD)
d387 1
d406 1
a406 1
	    IoTYPE(io) = IoTYPE_PIPE;
d412 1
a412 1
	    IoTYPE(io) = IoTYPE_RDONLY;
d417 1
a417 1
		IoTYPE(io) = IoTYPE_STD;
d432 2
a433 1
	if (ckWARN(WARN_NEWLINE) && IoTYPE(io) == IoTYPE_RDONLY && strchr(name, '\n'))
d437 3
a439 1
    if (IoTYPE(io) && IoTYPE(io) != IoTYPE_PIPE && IoTYPE(io) != IoTYPE_STD) {
d445 1
a445 1
	    IoTYPE(io) = IoTYPE_SOCKET;	/* in case a socket was passed in to us */
d453 1
a453 3
	    && IoTYPE(io) != IoTYPE_WRONLY  /* Dups of STD* filehandles already have */
	    && IoTYPE(io) != IoTYPE_RDONLY  /* type so they aren't marked as sockets */
	) {				    /* on OS's that return 0 on fstat()ed pipe */
d459 1
a459 1
		IoTYPE(io) = IoTYPE_SOCKET; /* some OS's return 0 on fstat()ed socket */
a478 10
#ifdef VMS
	    if (fd != PerlIO_fileno(PerlIO_stdin())) {
	      char newname[FILENAME_MAX+1];
	      if (fgetname(fp, newname)) {
	        if (fd == PerlIO_fileno(PerlIO_stdout())) Perl_vmssetuserlnm("SYS$OUTPUT", newname);
	        if (fd == PerlIO_fileno(PerlIO_stderr())) Perl_vmssetuserlnm("SYS$ERROR",  newname);
	      }
	    }
#endif
	    LOCK_FDPID_MUTEX;
a483 1
	    UNLOCK_FDPID_MUTEX;
d504 3
a506 2
	if (IoTYPE(io) == IoTYPE_SOCKET
	    || (IoTYPE(io) == IoTYPE_WRONLY && S_ISCHR(PL_statbuf.st_mode)) )
d566 1
d715 1
d774 2
a775 2
    IoTYPE(rstio) = IoTYPE_RDONLY;
    IoTYPE(wstio) = IoTYPE_WRONLY;
d810 4
a813 2
	    if (ckWARN(WARN_UNOPENED)) /* no check for closed here */
		report_evil_fh(gv, io, PL_op->op_type);
d824 1
a824 1
    IoTYPE(io) = IoTYPE_CLOSED;
d835 1
a835 1
	if (IoTYPE(io) == IoTYPE_PIPE) {
d845 1
a845 1
	else if (IoTYPE(io) == IoTYPE_STD)
d867 1
d876 1
a876 1
	     && (IoTYPE(io) == IoTYPE_WRONLY || IoIFP(io) == PerlIO_stdout()
d879 4
a882 13
	/* integrate to report_evil_fh()? */
        char *name = NULL; 
	if (isGV(gv)) {
	    SV* sv = sv_newmortal();
	    gv_efullname4(sv, gv, Nullch, FALSE);
	    name = SvPV_nolen(sv);
	}
	if (name && *name)
	    Perl_warner(aTHX_ WARN_IO,
			"Filehandle %s opened only for output", name);
	else
	    Perl_warner(aTHX_ WARN_IO,
			"Filehandle opened only for output");
d924 5
a928 2
    if (ckWARN2(WARN_UNOPENED,WARN_CLOSED))
	report_evil_fh(gv, io, PL_op->op_type);
d946 5
a950 2
    if (ckWARN2(WARN_UNOPENED,WARN_CLOSED))
	report_evil_fh(gv, io, PL_op->op_type);
d963 5
a967 2
    if (ckWARN2(WARN_UNOPENED,WARN_CLOSED))
	report_evil_fh(gv, io, PL_op->op_type);
d1143 5
a1147 2
	if (ckWARN(WARN_UNINITIALIZED))
	    report_uninit();
d1170 1
a1170 1
    if (len && (PerlIO_write(fp,tmps,len) == 0))
d1178 1
a1178 1
    dSP;
d1180 1
a1180 1
    GV* gv;
d1184 1
a1184 1
	gv = cGVOP_gv;
d1186 1
a1186 1
	io = GvIO(gv);
d1188 1
a1188 1
	    PL_statgv = gv;
d1194 1
a1194 1
	    if (gv == PL_defgv)
d1196 3
a1198 2
	    if (ckWARN2(WARN_UNOPENED,WARN_CLOSED))
		report_evil_fh(gv, io, PL_op->op_type);
d1210 1
a1210 1
	    gv = (GV*)sv;
d1214 1
a1214 1
	    gv = (GV*)SvRV(sv);
d1232 1
a1232 1
    dSP;
d1274 1
d1284 1
a1284 4
	if (really)
	    tmps = SvPV(really, n_a);
	if ((!really && *PL_Argv[0] != '/') ||
	    (really && *tmps != '/'))		/* will execvp use PATH? */
d1286 2
a1287 2
	if (really && *tmps)
	    PerlProc_execvp(tmps,EXEC_ARGV_CAST(PL_Argv));
d1289 1
a1289 1
	    PerlProc_execvp(PL_Argv[0],EXEC_ARGV_CAST(PL_Argv));
d1291 2
a1292 2
	    Perl_warner(aTHX_ WARN_EXEC, "Can't exec \"%s\": %s",
		(really ? tmps : PL_Argv[0]), Strerror(errno));
d1422 1
d1443 1
d1728 1
d1761 1
d1886 1
d1909 1
a1917 3
    /* suppress warning when reading into undef var --jhi */
    if (! SvOK(mstr))
	sv_setpvn(mstr, "", 0);
d1944 1
d1969 1
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2002, Larry Wall
d58 2
a59 2
    return do_openn(gv, name, len, as_raw, rawmode, rawperm,
		    supplied_fp, (SV **) NULL, 0);
a66 9
    return do_openn(gv, name, len, as_raw, rawmode, rawperm,
		    supplied_fp, &svs, 1);
}

bool
Perl_do_openn(pTHX_ GV *gv, register char *name, I32 len, int as_raw,
	      int rawmode, int rawperm, PerlIO *supplied_fp, SV **svp,
	      I32 num_svs)
{
a69 1
    int savefd = -1;
a76 3
    char *type  = NULL;
    char mode[8];		/* stdio file mode ("r\0", "rb\0", "r+b\0" etc.) */
    SV *namesv;
a77 1
    Zero(mode,sizeof(mode),char);
a79 1
    /* Collect default raw/crlf info from the op */
a88 1
    /* If currently open - close before we re-open */
d91 1
a91 2
	if (IoTYPE(io) == IoTYPE_STD) {
	    /* This is a clone of one of STD* handles */
d93 3
a95 5
	}
	else if (fd >= 0 && fd <= PL_maxsysfd) {
	    /* This is one of the original STD* handles */
	    saveifp  = IoIFP(io);
	    saveofp  = IoOFP(io);
d97 1
a97 2
	    savefd   = fd;
	    result   = 0;
d111 1
a111 2
	if (result == EOF && fd > PL_maxsysfd) {
	    /* Why is this not Perl_warn*() call ? */
a114 1
	}
a118 42
        /* sysopen style args, i.e. integer mode and permissions */
	STRLEN ix = 0;
	int appendtrunc =
	     0
#ifdef O_APPEND	/* Not fully portable. */
	     |O_APPEND
#endif
#ifdef O_TRUNC	/* Not fully portable. */
	     |O_TRUNC
#endif
	     ;
	int modifyingmode =
	     O_WRONLY|O_RDWR|O_CREAT|appendtrunc;
	int ismodifying;

	if (num_svs != 0) {
	     Perl_croak(aTHX_ "panic: sysopen with multiple args");
	}
	/* It's not always

	   O_RDONLY 0
	   O_WRONLY 1
	   O_RDWR   2

	   It might be (in OS/390 and Mac OS Classic it is)

	   O_WRONLY 1
	   O_RDONLY 2
	   O_RDWR   3

	   This means that simple & with O_RDWR would look
	   like O_RDONLY is present.  Therefore we have to
	   be more careful.
	*/
	if ((ismodifying = (rawmode & modifyingmode))) {
	     if ((ismodifying & O_WRONLY) == O_WRONLY ||
		 (ismodifying & O_RDWR)   == O_RDWR   ||
		 (ismodifying & (O_CREAT|appendtrunc)))
		  TAINT_PROPER("sysopen");
	}
	mode[ix++] = '#'; /* Marker to openn to use numeric "sysopen" */

d120 1
a120 1
	rawmode |= O_LARGEFILE;	/* Transparently largefiley. */
d123 3
a125 1
        IoTYPE(io) = PerlIO_intmode2str(rawmode, &mode[ix], &writing);
d127 45
a171 5
	namesv = sv_2mortal(newSVpvn(name,strlen(name)));
	num_svs = 1;
	svp = &namesv;
        type = Nullch;
	fp = PerlIO_openn(aTHX_ type, mode, -1, rawmode, rawperm, NULL, num_svs, svp);
d174 1
a174 1
	/* Regular (non-sys) open */
d176 1
d178 2
a179 3
	char *tend;
	int dodup = 0;
	PerlIO *that_fp = NULL;
d182 1
a182 1
	tend = type+len;
a183 7

        /* Lose leading and trailing white space */
        /*SUPPRESS 530*/
        for (; isSPACE(*type); type++) ;
        while (tend > type && isSPACE(tend[-1]))
	    *--tend = '\0';

d185 2
a186 12
	    /* New style explict name, type is just mode and discipline/layer info */
	    STRLEN l = 0;
#ifdef USE_STDIO
	    if (SvROK(*svp) && !strchr(name,'&')) {
		if (ckWARN(WARN_IO))
		    Perl_warner(aTHX_ packWARN(WARN_IO),
			    "Can't open a reference");
		SETERRNO(EINVAL, LIB$_INVARG);
		goto say_false;
	    }
#endif /* USE_STDIO */
	    name = SvOK(*svp) ? SvPV(*svp, l) : "";
d192 2
d195 1
a195 1
	    len  = tend-type;
d197 1
d199 1
a199 4
	if ((*type == IoTYPE_RDWR) && /* scary */
           (*(type+1) == IoTYPE_RDONLY || *(type+1) == IoTYPE_WRONLY) &&
	    ((!num_svs || (tend > type+1 && tend[-1] != IoTYPE_PIPE)))) {
        TAINT_PROPER("open");
d201 1
d206 3
a208 6
	    if (num_svs) {
		if (type[1] != IoTYPE_STD) {
	          unknown_desr:
		    Perl_croak(aTHX_ "Unknown open() mode '%.*s'", (int)olen, oname);
		}
		type++;
d211 1
a211 1
	    for (type++; isSPACE(*type); type++) ;
d214 1
a214 1
		len = tend-type;
d216 1
a216 2
	    if (*name == '\0') {
		/* command is missing 19990114 */
d218 1
a218 1
		    Perl_warner(aTHX_ packWARN(WARN_PIPE), "Missing command in piped open");
d225 1
a225 1
	    if (!num_svs && name[len-1] == '|') {
d228 1
a228 1
		    Perl_warner(aTHX_ packWARN(WARN_PIPE), "Can't open bidirectional pipe");
d230 8
a237 10
	    mode[0] = 'w';
	    writing = 1;
	    if (out_raw)
		strcat(mode, "b");
	    else if (out_crlf)
		strcat(mode, "t");
	    if (num_svs > 1) {
		fp = PerlProc_popen_list(mode, num_svs, svp);
	    }
	    else {
d240 1
a240 7
	    if (num_svs) {
		if (*type) {
		    if (PerlIO_apply_layers(aTHX_ fp, mode, type) != 0) {
			goto say_false;
		    }
		}
	    }
d249 1
d251 1
a251 1
	    else {
a252 1
	    }
d260 2
d263 1
d265 3
a267 3
		dodup = PERLIO_DUP_FD;
		type++;
		if (*type == '=') {
d269 1
a269 1
		    type++;
d271 1
a271 2
		if (!num_svs && !*type && supplied_fp) {
		    /* "<+&" etc. is used by typemaps */
a272 1
		}
d274 4
a277 11
		    if (num_svs > 1) {
			Perl_croak(aTHX_ "More than one argument to '%c&' open",IoTYPE(io));
		    }
		    if (num_svs && (SvIOK(*svp) || (SvPOK(*svp) && looks_like_number(*svp)))) {
			fd = SvUV(*svp);
		    }
		    else if (isDIGIT(*type)) {
			/*SUPPRESS 530*/
			for (; isSPACE(*type); type++) ;
			fd = atoi(type);
		    }
d280 2
a281 10
			if (num_svs) {
			    thatio = sv_2io(*svp);
			}
			else {
			    GV *thatgv;
			    /*SUPPRESS 530*/
			    for (; isSPACE(*type); type++) ;
			    thatgv = gv_fetchpv(type,FALSE,SVt_PVIO);
			    thatio = GvIO(thatgv);
			}
d288 2
a289 1
			if ((that_fp = IoIFP(thatio))) {
d299 2
a300 2
			    if (PerlIO_seek(that_fp, 0, SEEK_CUR) == -1)
				PerlIO_clearerr(that_fp);
d306 2
a307 2
			    PerlIO_flush(that_fp);
			    fd = PerlIO_fileno(that_fp);
d310 2
a311 2
			    if (that_fp == PerlIO_stdout()
				|| that_fp == PerlIO_stderr())
d313 1
a313 1
			    else if (that_fp == PerlIO_stdin())
d323 5
a327 6
		    if (!num_svs)
			type = Nullch;
		    if (that_fp) {
			fp = PerlIO_fdupopen(aTHX_ that_fp, NULL, dodup);
		    }
		    else {
d329 1
a329 7
			    fd = PerlLIO_dup(fd);
			else
			    was_fdopen = TRUE;
			if (!(fp = PerlIO_openn(aTHX_ type,mode,fd,0,0,NULL,num_svs,svp))) {
			    if (dodup)
				PerlLIO_close(fd);
			}
d332 1
a332 1
	    } /* & */
d336 1
a336 3
		if (*type == IoTYPE_STD && (!type[1] || isSPACE(type[1]) || type[1] == ':')) {
		    /*SUPPRESS 530*/
		    type++;
a338 3
		    if (num_svs > 1) {
			Perl_croak(aTHX_ "More than one argument to '>%c' open",IoTYPE_STD);
		    }
d341 1
a341 7
		    if (!num_svs) {
			namesv = sv_2mortal(newSVpvn(type,strlen(type)));
			num_svs = 1;
			svp = &namesv;
		        type = Nullch;
		    }
		    fp = PerlIO_openn(aTHX_ type,mode,-1,0,0,NULL,num_svs,svp);
d343 1
a343 1
	    } /* !& */
d346 2
d357 1
d360 1
a360 3
	    if (*type == IoTYPE_STD && (!type[1] || isSPACE(type[1]) || type[1] == ':')) {
		/*SUPPRESS 530*/
		type++;
a362 12
		if (num_svs > 1) {
		    Perl_croak(aTHX_ "More than one argument to '<%c' open",IoTYPE_STD);
		}
	    }
	    else {
		if (!num_svs) {
		    namesv = sv_2mortal(newSVpvn(type,strlen(type)));
		    num_svs = 1;
		    svp = &namesv;
		    type = Nullch;
		}
		fp = PerlIO_openn(aTHX_ type,mode,-1,0,0,NULL,num_svs,svp);
d364 2
d367 1
a367 2
	else if ((num_svs && type[0] == IoTYPE_STD && type[1] == IoTYPE_PIPE) ||
	         (!num_svs && tend > type+1 && tend[-1] == IoTYPE_PIPE)) {
d369 2
a370 1
		type += 2;   /* skip over '-|' */
d373 3
a375 3
		*--tend = '\0';
		while (tend > type && isSPACE(tend[-1]))
		    *--tend = '\0';
a378 1
	        len  = tend-type;
d380 1
a380 2
	    if (*name == '\0') {
		/* command is missing 19990114 */
d382 1
a382 1
		    Perl_warner(aTHX_ packWARN(WARN_PIPE), "Missing command in piped open");
d389 8
a396 9
	    mode[0] = 'r';
	    if (in_raw)
		strcat(mode, "b");
	    else if (in_crlf)
		strcat(mode, "t");
	    if (num_svs > 1) {
		fp = PerlProc_popen_list(mode,num_svs,svp);
	    }
	    else {
a399 8
	    if (num_svs) {
		for (; isSPACE(*type); type++) ;
		if (*type) {
		    if (PerlIO_apply_layers(aTHX_ fp, mode, type) != 0) {
			goto say_false;
		    }
		}
	    }
a407 5
	    mode[0] = 'r';
	    if (in_raw)
		strcat(mode, "b");
	    else if (in_crlf)
		strcat(mode, "t");
d413 8
a420 7
		if (!num_svs) {
		    namesv = sv_2mortal(newSVpvn(type,strlen(type)));
		    num_svs = 1;
		    svp = &namesv;
		    type = Nullch;
		}
		fp = PerlIO_openn(aTHX_ type,mode,-1,0,0,NULL,num_svs,svp);
d426 1
a426 1
	    Perl_warner(aTHX_ packWARN(WARN_NEWLINE), PL_warn_nl, "open");
d429 3
a431 23

    if (ckWARN(WARN_IO)) {
	if ((IoTYPE(io) == IoTYPE_RDONLY) &&
	    (fp == PerlIO_stdout() || fp == PerlIO_stderr())) {
		Perl_warner(aTHX_ packWARN(WARN_IO),
			    "Filehandle STD%s opened only for input",
			    (fp == PerlIO_stdout()) ? "OUT" : "ERR");
	}
	else if ((IoTYPE(io) == IoTYPE_WRONLY) && fp == PerlIO_stdin()) {
		Perl_warner(aTHX_ packWARN(WARN_IO),
			    "Filehandle STDIN opened only for output");
	}
    }

    fd = PerlIO_fileno(fp);
    /* If there is no fd (e.g. PerlIO::scalar) assume it isn't a
     * socket - this covers PerlIO::scalar - otherwise unless we "know" the
     * type probe for socket-ness.
     */
    if (IoTYPE(io) && IoTYPE(io) != IoTYPE_PIPE && IoTYPE(io) != IoTYPE_STD && fd >= 0) {
	if (PerlLIO_fstat(fd,&PL_statbuf) < 0) {
	    /* If PerlIO claims to have fd we had better be able to fstat() it. */
	    (void) PerlIO_close(fp);
a433 1
#ifndef PERL_MICRO
d446 9
a454 9
	     char tmpbuf[256];
	     Sock_size_t buflen = sizeof tmpbuf;
	     if (PerlSock_getsockname(fd, (struct sockaddr *)tmpbuf, &buflen) >= 0
		      || errno != ENOTSOCK)
		    IoTYPE(io) = IoTYPE_SOCKET; /* some OS's return 0 on fstat()ed socket */
				                /* but some return 0 for streams too, sigh */
	}
#endif /* HAS_SOCKET */
#endif /* !PERL_MICRO */
a455 6

    /* Eeek - FIXME !!!
     * If this is a standard handle we discard all the layer stuff
     * and just dup the fd into whatever was on the handle before !
     */

d457 1
a457 3
        /* If fd is less that PL_maxsysfd i.e. STDIN..STDERR
           then dup the new fileno down
         */
d459 1
a459 1
	    PerlIO_flush(saveofp);	/* emulate PerlIO_close() */
d462 2
d466 5
a470 9
	if (savefd != fd) {
	    /* Still a small can-of-worms here if (say) PerlIO::scalar
	       is assigned to (say) STDOUT - for now let dup2() fail
	       and provide the error
	     */
	    if (PerlLIO_dup2(fd, savefd) < 0) {
		(void)PerlIO_close(fp);
		goto say_false;
	    }
d472 6
a477 8
	    if (savefd != PerlIO_fileno(PerlIO_stdin())) {
                char newname[FILENAME_MAX+1];
                if (PerlIO_getname(fp, newname)) {
                    if (fd == PerlIO_fileno(PerlIO_stdout()))
                        Perl_vmssetuserlnm(aTHX_ "SYS$OUTPUT", newname);
                    if (fd == PerlIO_fileno(PerlIO_stderr()))
                        Perl_vmssetuserlnm(aTHX_ "SYS$ERROR",  newname);
                }
d480 11
a491 29
#if !defined(WIN32)
           /* PL_fdpid isn't used on Windows, so avoid this useless work.
            * XXX Probably the same for a lot of other places. */
            {
                Pid_t pid;
                SV *sv;

                LOCK_FDPID_MUTEX;
                sv = *av_fetch(PL_fdpid,fd,TRUE);
                (void)SvUPGRADE(sv, SVt_IV);
                pid = SvIVX(sv);
                SvIVX(sv) = 0;
                sv = *av_fetch(PL_fdpid,savefd,TRUE);
                (void)SvUPGRADE(sv, SVt_IV);
                SvIVX(sv) = pid;
                UNLOCK_FDPID_MUTEX;
            }
#endif

	    if (was_fdopen) {
                /* need to close fp without closing underlying fd */
                int ofd = PerlIO_fileno(fp);
                int dupfd = PerlLIO_dup(ofd);
                PerlIO_close(fp);
                PerlLIO_dup2(dupfd,ofd);
                PerlLIO_close(dupfd);
	    }
            else
		PerlIO_close(fp);
a494 1
	fd = PerlIO_fileno(fp);
d497 1
a497 1
    if (fd >= 0) {
d499 1
a504 1

d508 11
a518 6
	    || (IoTYPE(io) == IoTYPE_WRONLY && fd >= 0 && S_ISCHR(PL_statbuf.st_mode)) ) {
	    char *s = mode;
	    if (*s == 'I' || *s == '#')
	     s++;
	    *s = 'w';
	    if (!(IoOFP(io) = PerlIO_openn(aTHX_ type,s,fd,0,0,NULL,0,svp))) {
d590 1
a590 1
		        Perl_warner(aTHX_ packWARN(WARN_INPLACE),
d613 3
a615 3
		    if ((PerlLIO_stat(SvPVX(sv),&PL_statbuf) >= 0
			 && PL_statbuf.st_dev == filedev
			 && PL_statbuf.st_ino == fileino)
d617 1
a617 1
			|| ((_djstat_fail_bits & _STFAIL_TRUENAME)!=0)
d622 1
a622 1
			    Perl_warner(aTHX_ packWARN(WARN_INPLACE),
d630 1
a630 1
#if !defined(DOSISH) && !defined(__CYGWIN__) && !defined(EPOC)
d633 1
a633 1
			    Perl_warner(aTHX_ packWARN(WARN_INPLACE),
d649 1
a649 1
			    Perl_warner(aTHX_ packWARN(WARN_INPLACE),
d663 1
a663 1
			    Perl_warner(aTHX_ packWARN(WARN_INPLACE),
d687 1
a687 1
		        Perl_warner(aTHX_ packWARN(WARN_INPLACE), "Can't do inplace edit on %s: %s",
d721 1
a721 1
		    Perl_warner(aTHX_ packWARN(WARN_INPLACE),
d726 1
a726 1
		    Perl_warner(aTHX_ packWARN(WARN_INPLACE), "Can't open %s: %s",
a772 1
    IoOFP(rstio) = IoIFP(rstio);
d872 18
a889 2
    else if (ckWARN(WARN_IO) && (IoTYPE(io) == IoTYPE_WRONLY))
	report_evil_fh(gv, io, OP_phoney_OUTPUT_ONLY);
a902 1

d908 1
a908 1
	    if (gv != PL_argvgv || !nextargv(gv))	/* get another fp handy */
d920 1
a920 1
    register IO *io = 0;
d939 1
a939 1
    register IO *io = 0;
d958 1
a958 1
    register IO *io = 0;
a1012 1
#ifndef PERLIO_LAYERS
a1013 3
#else
		s = end;
#endif
d1023 39
a1061 7
 /* The old body of this is now in non-LAYER part of perlio.c
  * This is a stub for any XS code which might have been calling it.
  */
 char *name = ":raw";
#ifdef PERLIO_USING_CRLF
 if (!(mode & O_BINARY))
     name = ":crlf";
a1062 1
 return PerlIO_binmode(aTHX_ fp, iotype, mode, name);
d1074 1
a1074 1
    Stat_t filebuf;
a1154 11
	if (PerlIO_isutf8(fp)) {
	    if (!SvUTF8(sv))
		sv_utf8_upgrade(sv = sv_mortalcopy(sv));
	}
	else if (DO_UTF8(sv)) {
	    if (!sv_utf8_downgrade((sv = sv_mortalcopy(sv)), TRUE)
		&& ckWARN_d(WARN_UTF8))
	    {
		Perl_warner(aTHX_ packWARN(WARN_UTF8), "Wide character in print");
	    }
	}
d1217 1
a1217 1
	    Perl_warner(aTHX_ packWARN(WARN_NEWLINE), PL_warn_nl, "stat");
d1235 1
a1235 5
	if (ckWARN(WARN_IO)) {
	    Perl_warner(aTHX_ packWARN(WARN_IO), "Use of -l on filehandle %s",
		    GvENAME(cGVOP_gv));
	    return (PL_laststatval = -1);
	}
a1241 5
    if (SvROK(sv) && SvTYPE(SvRV(sv)) == SVt_PVGV && ckWARN(WARN_IO)) {
	Perl_warner(aTHX_ packWARN(WARN_IO), "Use of -l on filehandle %s",
		GvENAME((GV*) SvRV(sv)));
	return (PL_laststatval = -1);
    }
d1245 1
a1245 1
	Perl_warner(aTHX_ packWARN(WARN_NEWLINE), PL_warn_nl, "lstat");
d1263 1
a1263 1
    char *tmps = Nullch;
d1286 1
a1286 1
	    Perl_warner(aTHX_ packWARN(WARN_EXEC), "Can't exec \"%s\": %s",
d1326 1
d1334 22
a1355 26
    {
        char flags[10];
	if (strnEQ(cmd,PL_cshname,PL_cshlen) &&
	    strnEQ(cmd+PL_cshlen," -c",3)) {
	  strcpy(flags,"-c");
	  s = cmd+PL_cshlen+3;
	  if (*s == 'f') {
	      s++;
	      strcat(flags,"f");
	  }
	  if (*s == ' ')
	      s++;
	  if (*s++ == '\'') {
	      char *ncmd = s;

	      while (*s)
		  s++;
	      if (s[-1] == '\n')
		  *--s = '\0';
	      if (s[-1] == '\'') {
		  *--s = '\0';
		  PerlProc_execl(PL_cshname,"csh", flags, ncmd, (char*)0);
		  *s = '\'';
		  return FALSE;
	      }
	  }
d1373 1
a1373 2
	if (*s != ' ' && !isALPHA(*s) &&
	    strchr("$&*(){}[]'\";\\|?<>~`\n",*s)) {
d1420 1
a1420 1
		Perl_warner(aTHX_ packWARN(WARN_EXEC), "Can't exec \"%s\": %s",
d1494 1
a1494 1
/*
a1605 11
           SV* accessed = *++mark;
           SV* modified = *++mark;
           void * utbufp = &utbuf;

           /* be like C, and if both times are undefined, let the C
              library figure out what to do.  This usually means
              "current time" */

           if ( accessed == &PL_sv_undef && modified == &PL_sv_undef )
             utbufp = NULL;

d1608 2
a1609 2
           utbuf.actime = (Time_t)SvNVx(accessed);     /* time accessed */
           utbuf.modtime = (Time_t)SvNVx(modified);    /* time modified */
d1611 2
a1612 2
           utbuf.actime = (Time_t)SvIVx(accessed);     /* time accessed */
           utbuf.modtime = (Time_t)SvIVx(modified);    /* time modified */
d1619 1
a1619 1
               if (PerlLIO_utime(name, utbufp))
d1915 1
a1915 1

d1944 2
a1945 2
    if (opsize < 3 * SHORTSIZE
	|| (opsize % (3 * SHORTSIZE))) {
d1950 1
a1950 30
    /* We can't assume that sizeof(struct sembuf) == 3 * sizeof(short). */
    {
        int nsops  = opsize / (3 * sizeof (short));
        int i      = nsops;
        short *ops = (short *) opbuf;
        short *o   = ops;
        struct sembuf *temps, *t;
        I32 result;

        New (0, temps, nsops, struct sembuf);
        t = temps;
        while (i--) {
            t->sem_num = *o++;
            t->sem_op  = *o++;
            t->sem_flg = *o++;
            t++;
        }
        result = semop(id, temps, nsops);
        t = temps;
        o = ops;
        i = nsops;
        while (i--) {
            *o++ = t->sem_num;
            *o++ = t->sem_op;
            *o++ = t->sem_flg;
            t++;
        }
        Safefree(temps);
        return result;
    }
a2013 148
/*
=head1 IO Functions

=for apidoc start_glob

Function called by C<do_readline> to spawn a glob (or do the glob inside
perl on VMS). This code used to be inline, but now perl uses C<File::Glob>
this glob starter is only used by miniperl during the build process.
Moving it away shrinks pp_hot.c; shrinking pp_hot.c helps speed perl up.

=cut
*/

PerlIO *
Perl_start_glob (pTHX_ SV *tmpglob, IO *io)
{
    SV *tmpcmd = NEWSV(55, 0);
    PerlIO *fp;
    ENTER;
    SAVEFREESV(tmpcmd);
#ifdef VMS /* expand the wildcards right here, rather than opening a pipe, */
           /* since spawning off a process is a real performance hit */
    {
#include <descrip.h>
#include <lib$routines.h>
#include <nam.h>
#include <rmsdef.h>
	char rslt[NAM$C_MAXRSS+1+sizeof(unsigned short int)] = {'\0','\0'};
	char vmsspec[NAM$C_MAXRSS+1];
	char *rstr = rslt + sizeof(unsigned short int), *begin, *end, *cp;
	$DESCRIPTOR(dfltdsc,"SYS$DISK:[]*.*;");
	PerlIO *tmpfp;
	STRLEN i;
	struct dsc$descriptor_s wilddsc
	    = {0, DSC$K_DTYPE_T, DSC$K_CLASS_S, 0};
	struct dsc$descriptor_vs rsdsc
	    = {sizeof rslt, DSC$K_DTYPE_VT, DSC$K_CLASS_VS, rslt};
	unsigned long int cxt = 0, sts = 0, ok = 1, hasdir = 0, hasver = 0, isunix = 0;

	/* We could find out if there's an explicit dev/dir or version
	   by peeking into lib$find_file's internal context at
	   ((struct NAM *)((struct FAB *)cxt)->fab$l_nam)->nam$l_fnb
	   but that's unsupported, so I don't want to do it now and
	   have it bite someone in the future. */
	cp = SvPV(tmpglob,i);
	for (; i; i--) {
	    if (cp[i] == ';') hasver = 1;
	    if (cp[i] == '.') {
		if (sts) hasver = 1;
		else sts = 1;
	    }
	    if (cp[i] == '/') {
		hasdir = isunix = 1;
		break;
	    }
	    if (cp[i] == ']' || cp[i] == '>' || cp[i] == ':') {
		hasdir = 1;
		break;
	    }
	}
       if ((tmpfp = PerlIO_tmpfile()) != NULL) {
	    Stat_t st;
	    if (!PerlLIO_stat(SvPVX(tmpglob),&st) && S_ISDIR(st.st_mode))
		ok = ((wilddsc.dsc$a_pointer = tovmspath(SvPVX(tmpglob),vmsspec)) != NULL);
	    else ok = ((wilddsc.dsc$a_pointer = tovmsspec(SvPVX(tmpglob),vmsspec)) != NULL);
	    if (ok) wilddsc.dsc$w_length = (unsigned short int) strlen(wilddsc.dsc$a_pointer);
	    for (cp=wilddsc.dsc$a_pointer; ok && cp && *cp; cp++)
		if (*cp == '?') *cp = '%';  /* VMS style single-char wildcard */
	    while (ok && ((sts = lib$find_file(&wilddsc,&rsdsc,&cxt,
					       &dfltdsc,NULL,NULL,NULL))&1)) {
		end = rstr + (unsigned long int) *rslt;
		if (!hasver) while (*end != ';') end--;
		*(end++) = '\n';  *end = '\0';
		for (cp = rstr; *cp; cp++) *cp = _tolower(*cp);
		if (hasdir) {
		    if (isunix) trim_unixpath(rstr,SvPVX(tmpglob),1);
		    begin = rstr;
		}
		else {
		    begin = end;
		    while (*(--begin) != ']' && *begin != '>') ;
		    ++begin;
		}
		ok = (PerlIO_puts(tmpfp,begin) != EOF);
	    }
	    if (cxt) (void)lib$find_file_end(&cxt);
	    if (ok && sts != RMS$_NMF &&
		sts != RMS$_DNF && sts != RMS$_FNF) ok = 0;
	    if (!ok) {
		if (!(sts & 1)) {
		    SETERRNO((sts == RMS$_SYN ? EINVAL : EVMSERR),sts);
		}
		PerlIO_close(tmpfp);
		fp = NULL;
	    }
	    else {
		PerlIO_rewind(tmpfp);
		IoTYPE(io) = IoTYPE_RDONLY;
		IoIFP(io) = fp = tmpfp;
		IoFLAGS(io) &= ~IOf_UNTAINT;  /* maybe redundant */
	    }
	}
    }
#else /* !VMS */
#ifdef MACOS_TRADITIONAL
    sv_setpv(tmpcmd, "glob ");
    sv_catsv(tmpcmd, tmpglob);
    sv_catpv(tmpcmd, " |");
#else
#ifdef DOSISH
#ifdef OS2
    sv_setpv(tmpcmd, "for a in ");
    sv_catsv(tmpcmd, tmpglob);
    sv_catpv(tmpcmd, "; do echo \"$a\\0\\c\"; done |");
#else
#ifdef DJGPP
    sv_setpv(tmpcmd, "/dev/dosglob/"); /* File System Extension */
    sv_catsv(tmpcmd, tmpglob);
#else
    sv_setpv(tmpcmd, "perlglob ");
    sv_catsv(tmpcmd, tmpglob);
    sv_catpv(tmpcmd, " |");
#endif /* !DJGPP */
#endif /* !OS2 */
#else /* !DOSISH */
#if defined(CSH)
    sv_setpvn(tmpcmd, PL_cshname, PL_cshlen);
    sv_catpv(tmpcmd, " -cf 'set nonomatch; glob ");
    sv_catsv(tmpcmd, tmpglob);
    sv_catpv(tmpcmd, "' 2>/dev/null |");
#else
    sv_setpv(tmpcmd, "echo ");
    sv_catsv(tmpcmd, tmpglob);
#if 'z' - 'a' == 25
    sv_catpv(tmpcmd, "|tr -s ' \t\f\r' '\\012\\012\\012\\012'|");
#else
    sv_catpv(tmpcmd, "|tr -s ' \t\f\r' '\\n\\n\\n\\n'|");
#endif
#endif /* !CSH */
#endif /* !DOSISH */
#endif /* MACOS_TRADITIONAL */
    (void)do_open(PL_last_in_gv, SvPVX(tmpcmd), SvCUR(tmpcmd),
		  FALSE, O_RDONLY, 0, Nullfp);
    fp = IoIFP(io);
#endif /* !VMS */
    LEAVE;
    return fp;
}
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@d3 1
a3 2
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
 *    2000, 2001, 2002, 2003, by Larry Wall and others
d96 1
a96 1
	/* set up IO layers */
d181 1
a181 1
	mode[ix++] = IoTYPE_NUMERIC; /* Marker to openn to use numeric "sysopen" */
d214 1
a214 1
	    /* New style explicit name, type is just mode and layer info */
d221 1
a221 1
		SETERRNO(EINVAL, LIB_INVARG);
d238 1
a238 1
	    TAINT_PROPER("open");
d246 1
a246 1
	          unknown_open_mode:
d291 1
a291 1
	} /* IoTYPE_PIPE */
a325 2
		    /*SUPPRESS 530*/
		    for (; isSPACE(*type); type++) ;
a327 1
			num_svs = 0;
d330 2
d341 2
d348 1
a348 1
			    SETERRNO(EINVAL,SS_IVCHAN);
d425 1
a425 3
	    if (!fp && type && *type && *type != ':' && !isIDFIRST(*type))
	       goto unknown_open_mode;
	} /* IoTYPE_WRONLY */
d456 2
a457 5
	    if (!fp && type && *type && *type != ':' && !isIDFIRST(*type))
	       goto unknown_open_mode;
	} /* IoTYPE_RDONLY */
	else if ((num_svs && /* '-|...' or '...|' */
		  type[0] == IoTYPE_STD && type[1] == IoTYPE_PIPE) ||
d502 1
a502 1
	else { /* layer(Args) */
d504 1
a504 1
		goto unknown_open_mode;
d539 2
a540 3
			    "Filehandle STD%s reopened as %s only for input",
			    ((fp == PerlIO_stdout()) ? "OUT" : "ERR"),
			    GvENAME(gv));
d544 1
a544 2
			    "Filehandle STDIN reopened as %s only for output",
			    GvENAME(gv));
a641 4
#if defined(HAS_FCNTL) && defined(F_SETFD)
		/* Assume if we have F_SETFD we have F_GETFD */
                int coe = fcntl(ofd,F_GETFD);
#endif
a643 4
#if defined(HAS_FCNTL) && defined(F_SETFD)
		/* The dup trick has lost close-on-exec on ofd */
		fcntl(ofd,F_SETFD, coe);
#endif
d667 2
a668 2
	    if (*s == IoTYPE_IMPLICIT || *s == IoTYPE_NUMERIC)
	      s++;
a718 2
    if (!GvAV(gv))
        return Nullfp;
d775 2
a776 2
			      "Can't do inplace edit: %"SVf" would not be unique",
			      sv);
d786 2
a787 2
			      "Can't rename %s to %"SVf": %s, skipping file",
			      PL_oldname, sv, Strerror(errno) );
d802 2
a803 2
			      "Can't rename %s to %"SVf": %s, skipping file",
			      PL_oldname, sv, Strerror(errno) );
d923 2
a924 2
    IoIFP(rstio) = PerlIO_fdopen(fd[0], "r"PIPE_OPEN_MODE);
    IoOFP(wstio) = PerlIO_fdopen(fd[1], "w"PIPE_OPEN_MODE);
d957 1
a957 1
	    SETERRNO(EBADF,SS_IVCHAN);
d965 1
a965 1
	    SETERRNO(EBADF,SS_IVCHAN);
d1009 1
a1009 1
	SETERRNO(EBADF,SS_IVCHAN);
a1028 1
        int saverrno;
a1034 1
	saverrno = errno; /* getc and ungetc can stomp on errno */
a1037 1
	    errno = saverrno;
a1039 1
	errno = saverrno;
d1070 1
a1070 1
    SETERRNO(EBADF,RMS_IFI);
d1089 1
a1089 1
    SETERRNO(EBADF,RMS_IFI);
d1103 1
a1103 1
    SETERRNO(EBADF,RMS_IFI);
d1152 1
a1152 1
		Perl_croak(aTHX_ "IO layers (like '%.*s') unavailable", end-s, s);
d1268 1
a1268 2
		sv_utf8_upgrade_flags(sv = sv_mortalcopy(sv),
				      SV_GMAGIC|SV_UTF8_NO_ENCODING);
d1322 1
a1322 1
	STRLEN len;
d1333 1
a1333 1
	s = SvPV(sv, len);
d1335 1
a1335 2
	sv_setpvn(PL_statname, s, len);
	s = SvPVX(PL_statname);		/* s now NUL-terminated */
a1379 1
#ifndef OS2
a1384 1
#endif
a1411 1
	PERL_FPU_PRE_EXEC
a1415 1
	PERL_FPU_POST_EXEC
a1484 1
		  PERL_FPU_PRE_EXEC
a1485 1
		  PERL_FPU_POST_EXEC
d1522 1
a1522 1
		if (!*t && (PerlLIO_dup2(1,2) != -1)) {
a1527 1
	    PERL_FPU_PRE_EXEC
a1528 1
	    PERL_FPU_POST_EXEC
a1545 1
	PERL_FPU_PRE_EXEC
a1546 1
	PERL_FPU_POST_EXEC
d1642 1
a1642 1
	if (isALPHA(*s)) {
d1645 1
a1645 1
	    if ((val = whichsig(s)) < 0)
d1745 3
a1747 3
           /* Be like C, and if both times are undefined, let the C
            * library figure out what to do.  This usually means
            * "current time". */
d1750 3
a1752 3
                utbufp = NULL;
           else {
                Zero(&utbuf, sizeof utbuf, char);
d1754 2
a1755 2
                utbuf.actime = (Time_t)SvNVx(accessed);  /* time accessed */
                utbuf.modtime = (Time_t)SvNVx(modified); /* time modified */
d1757 2
a1758 2
                utbuf.actime = (Time_t)SvIVx(accessed);  /* time accessed */
                utbuf.modtime = (Time_t)SvIVx(modified); /* time modified */
d1760 1
a1760 2
            }
            APPLY_TAINT_PROPER();
d2092 1
a2092 1
	SETERRNO(EINVAL,LIB_INVARG);
d2149 1
a2149 1
	SETERRNO(EFAULT,SS_ACCVIO);		/* can't do as caller requested */
d2276 1
a2276 1
		sts != RMS$_DNF && sts != RMS_FNF) ok = 0;
@


1.1.1.7
log
@perl 5.8.3 from CPAN
@
text
@d51 1
d53 1
d2293 2
a2294 3
		/* with varying string, 1st word of buffer contains result length */
		end = rstr + *((unsigned short int*)rslt);
		if (!hasver) while (*end != ';' && end > rstr) end--;
@


1.1.1.8
log
@Import of stock perl 5.8.5
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, by Larry Wall and others
d726 1
a726 2
	if (PL_lastfd != -1)
	    (void)fchmod(PL_lastfd,PL_filemode);
a730 1
    PL_lastfd = -1;
a1172 1
		len -= end-s;
@


1.1.1.9
log
@perl 5.8.6 from CPAN
@
text
@a17 5
/* This file contains functions that do the actual I/O on behalf of ops.
 * For example, pp_print() calls the do_print() function in this file for
 * each argument needing printing.
 */

@


1.1.1.10
log
@perl 5.8.8 import
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006, by Larry Wall and others
a55 3
#define PERL_MODE_MAX 8
#define PERL_FLAGS_MAX 10

a70 1
    PERL_UNUSED_ARG(num_svs);
d80 1
a80 1
    register IO * const io = GvIOn(gv);
d92 1
a92 1
    char mode[PERL_MODE_MAX];	/* stdio file mode ("r\0", "rb\0", "r+b\0" etc.) */
d101 1
a101 1
	const U8 flags = PL_op->op_private;
d147 1
a147 1
	const int appendtrunc =
d156 2
a157 1
	const int modifyingmode = O_WRONLY|O_RDWR|O_CREAT|appendtrunc;
d212 1
d219 1
d229 3
a231 1
	    name = SvOK(*svp) ? savesvpv (*svp) : savepvn ("", 0);
d255 1
d268 1
a268 1
	    if ((*name == '-' && name[1] == '\0') || num_svs)
a277 6
#ifdef HAS_STRLCAT
            if (out_raw)
                strlcat(mode, "b", PERL_MODE_MAX);
            else if (out_crlf)
                strlcat(mode, "t", PERL_MODE_MAX); 
#else
a281 1
#endif
a308 6
#ifdef HAS_STRLCAT
            if (out_raw)
                strlcat(mode, "b", PERL_MODE_MAX);
            else if (out_crlf)
                strlcat(mode, "t", PERL_MODE_MAX);
#else
d313 1
a313 1
#endif
d330 1
d340 1
a340 1
			const IO* thatio;
d364 1
a364 1
			       -- Nicholas Clark */
d400 1
a400 1
			    if (dodup && fd >= 0)
d407 1
d410 1
d432 1
a434 6
#ifdef HAS_STRLCAT
            if (in_raw)
                strlcat(mode, "b", PERL_MODE_MAX);
            else if (in_crlf)
                strlcat(mode, "t", PERL_MODE_MAX);
#else
d439 1
a439 1
#endif
d444 1
d474 2
a475 2
		for (; isSPACE(*type); type++)
		    ;
d486 1
a486 1
	    if (!(*name == '-' && name[1] == '\0') || num_svs)
a489 7

#ifdef HAS_STRLCAT
            if (in_raw)
                strlcat(mode, "b", PERL_MODE_MAX);
            else if (in_crlf)
                strlcat(mode, "t", PERL_MODE_MAX);
#else
a493 2
#endif

d515 2
a516 2
	    for (; isSPACE(*name); name++)
		;
a517 7

#ifdef HAS_STRLCAT
            if (in_raw)
                strlcat(mode, "b", PERL_MODE_MAX);
            else if (in_crlf)
                strlcat(mode, "t", PERL_MODE_MAX);
#else
d522 1
a522 3
#endif

	    if (*name == '-' && name[1] == '\0') {
d538 1
a538 4
	if (IoTYPE(io) == IoTYPE_RDONLY && ckWARN(WARN_NEWLINE)
	    && strchr(name, '\n')
	    
	)
d640 1
a640 1
                SvIV_set(sv, 0);
d643 1
a643 1
                SvIV_set(sv, pid);
d716 1
a716 1
    IO * const io = GvIOp(gv);
d745 1
a745 1
	sv_setsv(GvSVn(gv),sv);
d771 1
a771 1
		    const char *star = strchr(PL_inplace, '*');
d773 1
a773 1
			const char *begin = PL_inplace;
d787 1
a787 1
		    if ((PerlLIO_stat(SvPVX_const(sv),&PL_statbuf) >= 0
d805 1
a805 1
		    if (PerlLIO_rename(PL_oldname,SvPVX_const(sv)) < 0) {
d815 3
a817 4
		    (void)PerlLIO_unlink(SvPVX_const(sv));
		    (void)PerlLIO_rename(PL_oldname,SvPVX_const(sv));
		    do_open(gv,(char*)SvPVX_const(sv),SvCUR(sv),PL_inplace!=0,
			    O_RDONLY,0,Nullfp);
d820 2
a821 2
		    (void)UNLINK(SvPVX_const(sv));
		    if (link(PL_oldname,SvPVX_const(sv)) < 0) {
d853 2
a854 2
		if (!do_open(PL_argvoutgv,(char*)SvPVX_const(sv),SvCUR(sv),
			     PL_inplace!=0,O_WRONLY|O_CREAT|O_TRUNC,0,Nullfp))
d856 2
a857 3
		    if (!do_open(PL_argvoutgv,(char*)SvPVX_const(sv),SvCUR(sv),
			     PL_inplace!=0,O_WRONLY|O_CREAT|OPEN_EXCL,0666,
			     Nullfp))
d891 1
a891 1
		const int eno = errno;
d1005 1
d1009 1
a1009 1
	    const int status = PerlProc_pclose(IoIFP(io));
d1022 1
a1022 2
		bool prev_err = PerlIO_error(IoOFP(io));
		retval = (PerlIO_close(IoOFP(io)) != EOF && !prev_err);
d1025 2
a1026 4
	    else {
		bool prev_err = PerlIO_error(IoIFP(io));
		retval = (PerlIO_close(IoIFP(io)) != EOF && !prev_err);
	    }
d1047 1
a1047 1
    else if ((IoTYPE(io) == IoTYPE_WRONLY) && ckWARN(WARN_IO))
d1139 1
a1139 1
	const char *s = SvPV_const(discp,len);
d1144 1
a1144 1
		    if (s[2] == 'a' && s[3] == 'w'
d1154 1
a1154 1
		    if (s[2] == 'r' && s[3] == 'l' && s[4] == 'f'
d1172 1
a1172 1
		const char *end;
d1195 1
a1195 1
 const char *name = ":raw";
d1203 1
a1203 5
#if !defined(HAS_TRUNCATE) && !defined(HAS_CHSIZE)
I32
my_chsize(int fd, Off_t length)
{
#ifdef F_FREESP
d1207 4
d1249 1
d1251 1
a1251 2
#else
    Perl_croak_nocontext("truncate not implemented");
a1252 3
    return -1;
}
#endif /* !HAS_TRUNCATE && !HAS_CHSIZE */
d1257 1
a1257 1
    register const char *tmps;
d1305 1
a1305 1
	tmps = SvPV_const(sv, len);
d1333 1
a1333 1
	    sv_setpvn(PL_statname,"", 0);
d1343 1
a1343 1
	    sv_setpvn(PL_statname,"", 0);
d1349 1
a1349 1
	const char *s;
d1361 1
a1361 1
	s = SvPV_const(sv, len);
d1364 1
a1364 1
	s = SvPVX_const(PL_statname);		/* s now NUL-terminated */
a1372 2
static const char no_prev_lstat[] = "The stat preceding -l _ wasn't an lstat";

d1378 1
d1383 1
a1383 1
		Perl_croak(aTHX_ no_prev_lstat);
d1402 3
a1404 4
    /* XXX Do really need to be calling SvPV() all these times? */
    sv_setpv(PL_statname,SvPV_nolen_const(sv));
    PL_laststatval = PerlLIO_lstat(SvPV_nolen_const(sv),&PL_statcache);
    if (PL_laststatval < 0 && ckWARN(WARN_NEWLINE) && strchr(SvPV_nolen_const(sv), '\n'))
d1421 1
a1421 1
#if defined(MACOS_TRADITIONAL) || defined(SYMBIAN)
d1424 4
d1429 1
a1429 3
	char **a;
	const char *tmps = Nullch;
	Newx(PL_Argv, sp - mark + 1, char*);
a1430 1

d1433 1
a1433 1
		*a++ = (char*)SvPV_nolen_const(*mark);
d1439 1
a1439 1
	    tmps = SvPV_nolen_const(really);
d1467 8
a1474 4
    Safefree(PL_Argv);
    PL_Argv = Null(char **);
    Safefree(PL_Cmd);
    PL_Cmd = Nullch;
d1477 1
a1477 1
#if !defined(OS2) && !defined(WIN32) && !defined(DJGPP) && !defined(EPOC) && !defined(SYMBIAN) && !defined(MACOS_TRADITIONAL)
d1498 1
a1498 1
        char flags[PERL_FLAGS_MAX];
a1500 3
#ifdef HAS_STRLCPY
          strlcpy(flags, "-c", PERL_FLAGS_MAX);
#else
a1501 1
#endif
a1504 3
#ifdef HAS_STRLCPY
              strlcat(flags, "f", PERL_FLAGS_MAX);
#else
a1505 1
#endif
d1553 1
a1553 1
                const char *t = s + 3;
d1570 1
a1570 1
    Newx(PL_Argv, (s - cmd) / 2 + 2, char*);
d1591 2
a1596 1
		int e = errno;
d1612 1
d1614 4
a1617 3
    const char *what;
    const char *s;
    SV ** const oldmark = mark;
d1643 4
a1646 27
                GV* gv;
                if (SvTYPE(*mark) == SVt_PVGV) {
                    gv = (GV*)*mark;
		do_fchmod:
		    if (GvIO(gv) && IoIFP(GvIOp(gv))) {
#ifdef HAS_FCHMOD
			APPLY_TAINT_PROPER();
			if (fchmod(PerlIO_fileno(IoIFP(GvIOn(gv))), val))
			    tot--;
#else
			Perl_die(aTHX_ PL_no_func, "fchmod");
#endif
		    }
		    else {
			tot--;
		    }
		}
		else if (SvROK(*mark) && SvTYPE(SvRV(*mark)) == SVt_PVGV) {
		    gv = (GV*)SvRV(*mark);
		    goto do_fchmod;
		}
		else {
		    const char *name = SvPV_nolen_const(*mark);
		    APPLY_TAINT_PROPER();
		    if (PerlLIO_chmod(name, val))
			tot--;
		}
a1654 1
            register I32 val2;
d1660 4
a1663 27
                GV* gv;
                if (SvTYPE(*mark) == SVt_PVGV) {
                    gv = (GV*)*mark;
		do_fchown:
		    if (GvIO(gv) && IoIFP(GvIOp(gv))) {
#ifdef HAS_FCHOWN
			APPLY_TAINT_PROPER();
			if (fchown(PerlIO_fileno(IoIFP(GvIOn(gv))), val, val2))
			    tot--;
#else
			Perl_die(aTHX_ PL_no_func, "fchown");
#endif
		    }
		    else {
			tot--;
		    }
		}
		else if (SvROK(*mark) && SvTYPE(SvRV(*mark)) == SVt_PVGV) {
		    gv = (GV*)SvRV(*mark);
		    goto do_fchown;
		}
		else {
		    const char *name = SvPV_nolen_const(*mark);
		    APPLY_TAINT_PROPER();
		    if (PerlLIO_chown(name, val, val2))
			tot--;
		}
d1680 1
a1680 1
	s = SvPVx_nolen_const(*++mark);
d1684 1
a1684 1
	    if ((val = whichsig((char *)s)) < 0)
d1750 1
a1750 1
	    s = SvPV_nolen_const(*mark);
d1753 1
a1753 1
		if (UNLINK((char *)s))
d1760 1
a1760 1
		    if (UNLINK((char*)s))
a1772 1
	    struct utimbuf *utbufp = &utbuf;
a1777 1
	    void *utbufp = &utbuf;
d1782 1
d1800 1
a1800 1
	    APPLY_TAINT_PROPER();
d1803 1
a1803 1
		char *name = SvPV_nolen(*mark);
d1805 1
a1805 1
		if (PerlLIO_utime(name, utbufp))
d1823 1
a1823 1
/* Note: we use "effective" both for uids and gids.
d1885 3
d1889 1
a1889 1
	Groups_t *gary = NULL;
a1890 1
        bool rc = FALSE;
d1892 1
a1892 3
	anum = getgroups(0, gary);
        Newx(gary, anum, Groups_t);
        anum = getgroups(anum, gary);
d1894 2
a1895 7
	    if (gary[anum] == testgid) {
                rc = TRUE;
                break;
            }

        Safefree(gary);
        return rc;
d1907 2
a1908 4
    key_t key = (key_t)SvNVx(*++mark);
    const I32 n = (optype == OP_MSGGET) ? 0 : SvIVx(*++mark);
    const I32 flags = SvIVx(*++mark);
    (void)sp;
d1910 3
d1941 1
a1941 2
    STRLEN infosize;
    I32 getinfo;
a1942 4
    const I32 id  = SvIVx(*++mark);
    const I32 n   = (optype == OP_SEMCTL) ? SvIVx(*++mark) : 0;
    const I32 cmd = SvIVx(*++mark);
    PERL_UNUSED_ARG(sp);
d1944 3
d1999 1
d2002 1
a2002 1
	    SvPV_force_nolen(astr);
a2006 1
	    STRLEN len;
d2064 2
a2065 2
    const char *mbuf;
    I32 msize, flags;
a2066 2
    const I32 id = SvIVx(*++mark);
    PERL_UNUSED_ARG(sp);
d2068 1
d2071 1
a2071 1
    mbuf = SvPV_const(mstr, len);
d2088 2
a2089 3
    I32 msize, flags, ret;
    const I32 id = SvIVx(*++mark);
    PERL_UNUSED_ARG(sp);
d2091 1
d2099 1
a2099 1
    SvPV_force_nolen(mstr);
d2123 2
a2124 1
    const char *opbuf;
a2125 2
    const I32 id = SvIVx(*++mark);
    PERL_UNUSED_ARG(sp);
d2127 1
d2129 1
a2129 1
    opbuf = SvPV_const(opstr, opsize);
d2138 1
a2138 1
        const int nsops  = opsize / (3 * sizeof (short));
d2145 1
a2145 1
        Newx (temps, nsops, struct sembuf);
d2176 3
a2178 2
    char *shm;
    I32 mpos, msize;
a2179 2
    const I32 id = SvIVx(*++mark);
    PERL_UNUSED_ARG(sp);
d2181 1
a2195 1
	const char *mbuf;
d2199 1
a2199 1
	SvPV_force_nolen(mstr);
a2212 1
	STRLEN len;
d2214 1
a2214 1
	const char *mbuf = SvPV_const(mstr, len);
d2245 1
a2245 1
    SV * const tmpcmd = NEWSV(55, 0);
d2258 1
a2258 2
	char * const rstr = rslt + sizeof(unsigned short int);
	char *begin, *end, *cp;
d2291 3
a2293 3
	    if (!PerlLIO_stat(SvPVX_const(tmpglob),&st) && S_ISDIR(st.st_mode))
		ok = ((wilddsc.dsc$a_pointer = tovmspath((char *)SvPVX_const(tmpglob),vmsspec)) != NULL);
	    else ok = ((wilddsc.dsc$a_pointer = tovmsspec((char *)SvPVX_const(tmpglob),vmsspec)) != NULL);
d2371 1
a2371 1
    (void)do_open(PL_last_in_gv, (char*)SvPVX_const(tmpcmd), SvCUR(tmpcmd),
a2377 10

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 noet:
 */
@


1.1.1.11
log
@import perl 5.10.0 from CPAN
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, by Larry Wall and others
d62 19
a80 1
Perl_do_openn(pTHX_ GV *gv, register const char *oname, I32 len, int as_raw,
a83 1
    dVAR;
d85 2
a86 2
    PerlIO *saveifp = NULL;
    PerlIO *saveofp = NULL;
d96 1
a96 1
    char mode[PERL_MODE_MAX];	/* file mode ("r\0", "rb\0", "ab\0" etc.) */
d145 1
a145 1
	IoOFP(io) = IoIFP(io) = NULL;
d196 1
a196 1
	namesv = sv_2mortal(newSVpvn(oname,len));
d199 1
a199 1
	type = NULL;
d204 1
a204 1
	char *name;
d208 1
d210 1
a210 1
	type = savepvn(oname, len);
d215 1
a215 2
	while (isSPACE(*type))
	    type++;
d222 1
a222 1
	    if (SvROK(*svp) && !strchr(oname,'&')) {
d254 1
a254 3
	    do {
		type++;
	    } while (isSPACE(*type));
d266 1
a266 1
	    if (!(*name == '-' && name[1] == '\0') || num_svs)
d276 1
d278 1
a278 1
		mode[1] = 'b';
d280 7
a286 1
		mode[1] = 't';
d314 1
d316 1
a316 1
		mode[1] = 'b';
d318 7
a324 1
		mode[1] = 't';
a337 1
		    PerlIO *that_fp = NULL;
d341 1
a341 2
		    while (isSPACE(*type))
			type++;
d355 2
a356 2
			    GV * const thatgv = gv_fetchpvn_flags(type, tend - type,
						       0, SVt_PVIO);
d400 1
a400 1
			type = NULL;
d417 1
a417 2
		while (isSPACE(*type))
		    type++;
d428 1
a428 1
			namesv = sv_2mortal(newSVpvn(type,tend - type));
d431 1
a431 1
		        type = NULL;
d440 1
a440 3
	    do {
		type++;
	    } while (isSPACE(*type));
d442 1
d444 1
a444 1
		mode[1] = 'b';
d446 7
a452 1
		mode[1] = 't';
d466 1
a466 1
		    namesv = sv_2mortal(newSVpvn(type,tend - type));
d469 1
a469 1
		    type = NULL;
d503 1
d505 1
a505 1
		mode[1] = 'b';
d507 7
a513 1
		mode[1] = 't';
d523 1
a523 2
		while (isSPACE(*type))
		    type++;
d540 1
d542 1
a542 1
		mode[1] = 'b';
d544 7
a550 1
		mode[1] = 't';
d558 1
a558 1
		    namesv = sv_2mortal(newSVpvn(type,tend - type));
d561 1
a561 1
		    type = NULL;
d569 1
a569 1
	    && strchr(oname, '\n')
d671 1
a671 1
                SvUPGRADE(sv, SVt_IV);
d675 1
a675 1
                SvUPGRADE(sv, SVt_IV);
d706 1
a706 1
	const int save_errno = errno;
d723 1
a723 1
		IoIFP(io) = NULL;
a741 1
    dVAR;
d752 1
a752 1
	PL_argvoutgv = gv_fetchpvs("ARGVOUT", GV_ADD|GV_NOTQUAL, SVt_PVIO);
d756 3
a758 3
	    assert(PL_defoutgv);
	    Perl_av_create_and_push(aTHX_ &PL_argvout_stack,
				    SvREFCNT_inc_simple_NN(PL_defoutgv));
d773 1
a773 1
	return NULL;
d781 1
a781 1
	if (do_open(gv,PL_oldname,oldlen,PL_inplace!=0,O_RDONLY,0,NULL)) {
d785 1
a785 2
		    setdefout(gv_fetchpvs("STDOUT", GV_ADD|GV_NOTQUAL,
					  SVt_PVIO));
d831 1
a831 1
			      SVfARG(sv));
d842 1
a842 1
			      PL_oldname, SVfARG(sv), Strerror(errno));
d851 1
a851 1
			    O_RDONLY,0,NULL);
d859 1
a859 1
			      PL_oldname, SVfARG(sv), Strerror(errno) );
d888 1
a888 1
			     PL_inplace!=0,O_WRONLY|O_CREAT|O_TRUNC,0,NULL))
d892 1
a892 1
			     NULL))
d947 1
a947 1
	    GV * const oldout = (GV*)av_pop(PL_argvout_stack);
d950 1
a950 1
	    return NULL;
d952 1
a952 1
	setdefout(gv_fetchpvs("STDOUT", GV_ADD|GV_NOTQUAL, SVt_PVIO));
d954 1
a954 1
    return NULL;
d957 46
a1006 1
    dVAR;
a1038 1
    dVAR;
d1045 2
a1046 2
		STATUS_NATIVE_CHILD_SET(status);
		retval = (STATUS_UNIX == 0);
d1056 1
a1056 1
		const bool prev_err = PerlIO_error(IoOFP(io));
d1061 1
a1061 1
		const bool prev_err = PerlIO_error(IoIFP(io));
d1065 1
a1065 1
	IoOFP(io) = IoIFP(io) = NULL;
d1077 4
a1080 2
    dVAR;
    register IO * const io = GvIO(gv);
d1088 2
d1095 4
a1098 9
	{
	     /* getc and ungetc can stomp on errno */
	    const int saverrno = errno;
	    const int ch = PerlIO_getc(IoIFP(io));
	    if (ch != EOF) {
		(void)PerlIO_ungetc(IoIFP(io),ch);
		errno = saverrno;
		return FALSE;
	    }
d1100 1
d1102 1
d1121 1
a1121 2
    dVAR;
    register IO *io = NULL;
d1140 1
a1140 2
    dVAR;
    register IO *io = NULL;
d1159 1
a1159 2
    dVAR;
    register IO *io = NULL;
d1226 14
d1248 1
d1268 1
a1268 1
	struct flock fl;
d1297 3
a1299 1
    dVAR;
d1303 30
a1332 15
    if (SvTYPE(sv) == SVt_IV && SvIOK(sv)) {
	assert(!SvGMAGICAL(sv));
	if (SvIsUV(sv))
	    PerlIO_printf(fp, "%"UVuf, (UV)SvUVX(sv));
	else
	    PerlIO_printf(fp, "%"IVdf, (IV)SvIVX(sv));
	return !PerlIO_error(fp);
    }
    else {
	STRLEN len;
	/* Do this first to trigger any overloading.  */
	const char *tmps = SvPV_const(sv, len);
	U8 *tmpbuf = NULL;
	bool happy = TRUE;

d1334 3
a1336 5
	    if (!SvUTF8(sv)) {
		/* We don't modify the original scalar.  */
		tmpbuf = bytes_to_utf8((const U8*) tmps, &len);
		tmps = (char *) tmpbuf;
	    }
d1339 4
a1342 14
	    STRLEN tmplen = len;
	    bool utf8 = TRUE;
	    U8 * const result = bytes_from_utf8((const U8*) tmps, &tmplen, &utf8);
	    if (!utf8) {
		tmpbuf = result;
		tmps = (char *) tmpbuf;
		len = tmplen;
	    }
	    else {
		assert((char *)result == tmps);
		if (ckWARN_d(WARN_UTF8)) {
		    Perl_warner(aTHX_ packWARN(WARN_UTF8),
				"Wide character in print");
		}
d1345 2
a1346 10
	/* To detect whether the process is about to overstep its
	 * filesize limit we would need getrlimit().  We could then
	 * also transparently raise the limit with setrlimit() --
	 * but only until the system hard limit/the filesystem limit,
	 * at which we would get EPERM.  Note that when using buffered
	 * io the write failure can be delayed until the flush/close. --jhi */
	if (len && (PerlIO_write(fp,tmps,len) == 0))
	    happy = FALSE;
	Safefree(tmpbuf);
	return happy ? !PerlIO_error(fp) : FALSE;
d1348 9
a1361 1
    dVAR;
a1369 2
        if (gv == PL_defgv)
            return PL_laststatval;
d1371 15
a1385 22
        do_fstat_have_io:
        PL_laststype = OP_STAT;
        PL_statgv = gv;
        sv_setpvn(PL_statname, "", 0);
        if(io) {
	    if (IoIFP(io)) {
	        return (PL_laststatval = PerlLIO_fstat(PerlIO_fileno(IoIFP(io)), &PL_statcache));
            } else if (IoDIRP(io)) {
                return (PL_laststatval = PerlLIO_fstat(my_dirfd(IoDIRP(io)), &PL_statcache));
            } else {
                if (ckWARN2(WARN_UNOPENED,WARN_CLOSED))
                    report_evil_fh(gv, io, PL_op->op_type);
                return (PL_laststatval = -1);
            }
	} else {
            if (ckWARN2(WARN_UNOPENED,WARN_CLOSED))
                report_evil_fh(gv, io, PL_op->op_type);
            return (PL_laststatval = -1);
        }
    }
    else if (PL_op->op_private & OPpFT_STACKED) {
	return PL_laststatval;
d1388 1
a1388 1
	SV* const sv = POPs;
a1399 5
        else if (SvROK(sv) && SvTYPE(SvRV(sv)) == SVt_PVIO) {
            io = (IO*)SvRV(sv);
	    gv = NULL;
            goto do_fstat_have_io;
        }
d1402 1
a1402 1
	PL_statgv = NULL;
d1413 1
a1417 2
    dVAR;
    static const char no_prev_lstat[] = "The stat preceding -l _ wasn't an lstat";
a1432 3
    else if (PL_laststype != OP_LSTAT
	    && (PL_op->op_private & OPpFT_STACKED) && ckWARN(WARN_IO))
	Perl_croak(aTHX_ no_prev_lstat);
d1435 1
a1435 1
    PL_statgv = NULL;
d1451 3
a1453 2
static void
S_exec_failed(pTHX_ const char *cmd, int fd, int do_report)
d1455 1
a1455 8
    const int e = errno;
    if (ckWARN(WARN_EXEC))
	Perl_warner(aTHX_ packWARN(WARN_EXEC), "Can't exec \"%s\": %s",
		    cmd, Strerror(e));
    if (do_report) {
	PerlLIO_write(fd, (void*)&e, sizeof(int));
	PerlLIO_close(fd);
    }
d1457 1
d1463 1
a1463 2
    dVAR;
#if defined(MACOS_TRADITIONAL) || defined(__SYMBIAN32__) || defined(__LIBCATAMOUNT__)
d1468 1
a1468 1
	const char *tmps = NULL;
d1478 1
a1478 1
	*a = NULL;
d1490 9
a1498 1
 	S_exec_failed(aTHX_ (really ? tmps : PL_Argv[0]), fd, do_report);
a1507 1
    dVAR;
d1509 1
a1509 1
    PL_Argv = NULL;
d1511 1
a1511 1
    PL_Cmd = NULL;
d1514 1
a1514 1
#ifdef PERL_DEFAULT_DO_EXEC3_IMPLEMENTATION
d1517 7
a1523 1
Perl_do_exec3(pTHX_ const char *incmd, int fd, int do_report)
a1524 1
    dVAR;
a1526 8
    char *buf;
    char *cmd;

    /* Make a copy so we can change it */
    const Size_t cmdlen = strlen(incmd) + 1;
    Newx(buf, cmdlen, char);
    cmd = buf;
    memcpy(cmd, incmd, cmdlen);
d1538 5
a1542 1
          my_strlcpy(flags, "-c", PERL_FLAGS_MAX);
d1546 5
a1550 1
              my_strlcat(flags, "f", PERL_FLAGS_MAX - 2);
d1555 1
a1555 1
	      char * const ncmd = s;
d1564 1
a1564 1
		  PerlProc_execl(PL_cshname, "csh", flags, ncmd, (char*)NULL);
a1566 2
 		  S_exec_failed(aTHX_ PL_cshname, fd, do_report);
		  Safefree(buf);
d1582 1
a1582 3
    s = cmd;
    while (isALNUM(*s))
	s++;	/* catch VAR=val gizmo */
d1609 1
a1609 1
	    PerlProc_execl(PL_sh_path, "sh", "-c", cmd, (char *)NULL);
a1610 2
 	    S_exec_failed(aTHX_ PL_sh_path, fd, do_report);
	    Safefree(buf);
d1619 1
a1619 2
	while (isSPACE(*s))
	    s++;
d1622 1
a1622 2
	while (*s && !isSPACE(*s))
	    s++;
d1626 1
a1626 1
    *a = NULL;
d1635 10
a1644 1
 	S_exec_failed(aTHX_ PL_Argv[0], fd, do_report);
a1646 1
    Safefree(buf);
a1654 1
    dVAR;
d1657 1
a1657 1
    const char *const what = PL_op_name[type];
a1660 13
    /* Doing this ahead of the switch statement preserves the old behaviour,
       where attempting to use kill as a taint test test would fail on
       platforms where kill was not defined.  */
#ifndef HAS_KILL
    if (type == OP_KILL)
	Perl_die(aTHX_ PL_no_func, what);
#endif
#ifndef HAS_CHOWN
    if (type == OP_CHOWN)
	Perl_die(aTHX_ PL_no_func, what);
#endif


d1678 1
d1681 1
a1681 1
	    val = SvIV(*mark);
d1717 1
d1765 1
d1773 1
a1773 1
	    if ((val = whichsig(s)) < 0)
d1777 1
a1777 1
	    val = SvIV(*mark);
d1790 1
a1790 1
		I32 proc = SvIV(*mark);
d1814 1
a1814 1
		const I32 proc = SvIV(*mark);
d1826 1
a1826 1
		const I32 proc = SvIV(*mark);
d1835 1
d1842 1
a1842 1
		if (UNLINK(s))
d1849 1
a1849 1
		    if (UNLINK(s))
d1855 1
a1855 1
#if defined(HAS_UTIME) || defined(HAS_FUTIMES)
d1857 1
d1860 1
a1860 4
#if defined(HAS_FUTIMES)
	    struct timeval utbuf[2];
	    void *utbufp = utbuf;
#elif defined(I_UTIME) || defined(VMS)
d1871 2
a1872 2
	   SV* const accessed = *++mark;
	   SV* const modified = *++mark;
d1882 3
a1884 8
#ifdef HAS_FUTIMES
		utbuf[0].tv_sec = (long)SvIV(accessed);  /* time accessed */
		utbuf[0].tv_usec = 0;
		utbuf[1].tv_sec = (long)SvIV(modified);  /* time modified */
		utbuf[1].tv_usec = 0;
#elif defined(BIG_TIME)
                utbuf.actime = (Time_t)SvNV(accessed);  /* time accessed */
                utbuf.modtime = (Time_t)SvNV(modified); /* time modified */
d1886 2
a1887 2
                utbuf.actime = (Time_t)SvIV(accessed);  /* time accessed */
                utbuf.modtime = (Time_t)SvIV(modified); /* time modified */
d1893 4
a1896 33
                GV* gv;
                if (SvTYPE(*mark) == SVt_PVGV) {
                    gv = (GV*)*mark;
		do_futimes:
		    if (GvIO(gv) && IoIFP(GvIOp(gv))) {
#ifdef HAS_FUTIMES
			APPLY_TAINT_PROPER();
			if (futimes(PerlIO_fileno(IoIFP(GvIOn(gv))),
                            (struct timeval *) utbufp))
			    tot--;
#else
			Perl_die(aTHX_ PL_no_func, "futimes");
#endif
		    }
		    else {
			tot--;
		    }
		}
		else if (SvROK(*mark) && SvTYPE(SvRV(*mark)) == SVt_PVGV) {
		    gv = (GV*)SvRV(*mark);
		    goto do_futimes;
		}
		else {
		    const char * const name = SvPV_nolen_const(*mark);
		    APPLY_TAINT_PROPER();
#ifdef HAS_FUTIMES
		    if (utimes(name, (struct timeval *)utbufp))
#else
		    if (PerlLIO_utime(name, utbufp))
#endif
			tot--;
		}

d1912 3
a1914 4
Perl_cando(pTHX_ Mode_t mode, bool effective, register const Stat_t *statbufp)
/* effective is a flag, true for EUID, or for checking if the effective gid
 *  is in the list of groups returned from getgroups().
 */
a1915 1
    dVAR;
d1966 1
a1966 1
Perl_ingroup(pTHX_ Gid_t testgid, bool effective)
a1971 1
    dVAR;
d1992 1
a1992 1
#else
a1994 1
#endif
d2002 1
a2002 2
    dVAR;
    const key_t key = (key_t)SvNVx(*++mark);
d2005 1
a2005 2

    PERL_UNUSED_ARG(sp);
d2033 1
a2033 1
    dVAR;
d2035 2
a2038 1
#ifdef Semctl
a2039 1
#endif
d2041 1
a2041 3
    SV * const astr = *++mark;
    STRLEN infosize = 0;
    I32 getinfo = (cmd == IPC_STAT);
d2043 3
a2045 1
    PERL_UNUSED_ARG(sp);
d2113 1
a2113 1
	const IV i = SvIV(astr);
a2157 1
    dVAR;
d2159 3
a2163 5
    SV * const mstr = *++mark;
    const I32 flags = SvIVx(*++mark);
    const char * const mbuf = SvPV_const(mstr, len);
    const I32 msize = len - sizeof(long);

d2166 4
a2169 1
    if (msize < 0)
a2173 2
    PERL_UNUSED_ARG(sp);
    PERL_UNUSED_ARG(mark);
d2182 1
a2182 1
    dVAR;
a2186 1
    SV * const mstr = *++mark;
d2189 1
a2210 2
    PERL_UNUSED_ARG(sp);
    PERL_UNUSED_ARG(mark);
d2219 2
a2220 1
    dVAR;
a2222 2
    SV * const opstr = *++mark;
    const char * const opbuf = SvPV_const(opstr, opsize);
d2225 2
d2237 1
a2237 1
        short * const ops = (short *) opbuf;
d2272 1
a2272 1
    dVAR;
d2274 1
a2276 3
    SV * const mstr = *++mark;
    const I32 mpos = SvIVx(*++mark);
    const I32 msize = SvIVx(*++mark);
d2279 3
d2285 1
a2285 2
    if (mpos < 0 || msize < 0
	|| (size_t)mpos + msize > (size_t)shmds.shm_segsz) {
d2289 1
a2289 1
    shm = (char *)shmat(id, NULL, (optype == OP_SHMREAD) ? SHM_RDONLY : 0);
d2293 1
a2293 1
	char *mbuf;
d2298 1
a2298 1
	mbuf = SvGROW(mstr, (STRLEN)msize+1);
d2310 1
d2314 2
a2315 1
	const I32 n = ((I32)len > msize) ? msize : (I32)len;
d2344 1
a2344 2
    dVAR;
    SV * const tmpcmd = newSV(0);
d2350 83
a2432 8

PerlIO * 
Perl_vms_start_glob
   (pTHX_ SV *tmpglob,
    IO *io);

    fp = Perl_vms_start_glob(aTHX_ tmpglob, io);

d2472 1
a2472 1
		  FALSE, O_RDONLY, 0, NULL);
@


1.1.1.12
log
@import perl 5.10.1
@
text
@d3 2
a4 2
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
 *    2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 by Larry Wall and others
d12 4
a15 6
 *  Far below them they saw the white waters pour into a foaming bowl, and
 *  then swirl darkly about a deep oval basin in the rocks, until they found
 *  their way out again through a narrow gate, and flowed away, fuming and
 *  chattering, into calmer and more level reaches.
 *
 *     [p.684 of _The Lord of the Rings_, IV/vi: "The Forbidden Pool"]
a81 2
    PERL_ARGS_ASSERT_DO_OPENN;

d179 1
a179 1
	namesv = newSVpvn_flags(oname, len, SVs_TEMP);
d213 1
a213 1
	    name = SvOK(*svp) ? savesvpv (*svp) : savepvs ("");
d402 1
a402 1
			namesv = newSVpvn_flags(type, tend - type, SVs_TEMP);
d435 1
a435 1
		    namesv = newSVpvn_flags(type, tend - type, SVs_TEMP);
d514 1
a514 1
		    namesv = newSVpvn_flags(type, tend - type, SVs_TEMP);
d662 1
a662 1
	dSAVE_ERRNO;
d664 1
a664 1
	RESTORE_ERRNO;
a707 2
    PERL_ARGS_ASSERT_NEXTARGV;

d765 1
a765 1
			sv_setpvs(sv, "");
d808 2
a809 1
		    do_open(gv,(char*)SvPVX_const(sv),SvCUR(sv),TRUE,O_RDONLY,0,NULL);
d841 2
a842 1
		sv_setpvn(sv,PL_oldname,oldlen);
a843 2
		if (!Perl_do_openn(aTHX_ PL_argvoutgv, (char*)SvPVX_const(sv),
				   SvCUR(sv), TRUE,
d845 2
a846 1
				   O_WRONLY|O_CREAT|O_TRUNC,0,
d848 3
a850 1
				   O_WRONLY|O_CREAT|OPEN_EXCL,0600,
d852 1
a852 1
				   NULL, NULL, 0)) {
d905 1
a905 1
	    GV * const oldout = MUTABLE_GV(av_pop(PL_argvout_stack));
d925 1
a925 1
    if (!gv || !isGV_with_GP(gv)) {
a954 2
    PERL_ARGS_ASSERT_IO_CLOSE;

a993 2
    PERL_ARGS_ASSERT_DO_EOF;

d1007 1
a1007 1
	    dSAVE_ERRNO;
d1011 1
a1011 1
		RESTORE_ERRNO;
d1014 1
a1014 1
	    RESTORE_ERRNO;
a1037 2
    PERL_ARGS_ASSERT_DO_TELL;

a1077 2
    PERL_ARGS_ASSERT_DO_SYSSEEK;

a1198 3

    PERL_ARGS_ASSERT_DO_PRINT;

d1272 1
a1272 1
        sv_setpvs(PL_statname, "");
d1297 2
a1298 2
	if (isGV_with_GP(sv)) {
	    gv = MUTABLE_GV(sv);
d1301 2
a1302 2
	else if (SvROK(sv) && isGV_with_GP(SvRV(sv))) {
	    gv = MUTABLE_GV(SvRV(sv));
d1306 1
a1306 1
            io = MUTABLE_IO(SvRV(sv));
a1330 1
    const char *file;
d1352 1
a1352 1
    if (SvROK(sv) && isGV_with_GP(SvRV(sv)) && ckWARN(WARN_IO)) {
d1354 1
a1354 1
		GvENAME((const GV *)SvRV(sv)));
d1357 4
a1360 4
    file = SvPV_nolen_const(sv);
    sv_setpv(PL_statname,file);
    PL_laststatval = PerlLIO_lstat(file,&PL_statcache);
    if (PL_laststatval < 0 && ckWARN(WARN_NEWLINE) && strchr(file, '\n'))
a1368 1
    PERL_ARGS_ASSERT_EXEC_FAILED;
a1382 1
    PERL_ARGS_ASSERT_DO_AEXEC5;
d1387 1
a1387 1
	const char **a;
d1389 1
a1389 1
	Newx(PL_Argv, sp - mark + 1, const char*);
d1394 1
a1394 1
		*a++ = SvPV_nolen_const(*mark);
d1433 1
a1433 1
    register const char **a;
d1437 1
a1439 3

    PERL_ARGS_ASSERT_DO_EXEC3;

d1529 1
a1529 1
    Newx(PL_Argv, (s - cmd) / 2 + 2, const char*);
d1545 1
a1545 1
	PerlProc_execvp(PL_Argv[0],EXEC_ARGV_CAST(PL_Argv));
a1569 2
    PERL_ARGS_ASSERT_APPLY;

d1607 2
a1608 2
                if (isGV_with_GP(*mark)) {
                    gv = MUTABLE_GV(*mark);
d1623 2
a1624 2
		else if (SvROK(*mark) && isGV_with_GP(SvRV(*mark))) {
		    gv = MUTABLE_GV(SvRV(*mark));
d1647 2
a1648 2
                if (isGV_with_GP(*mark)) {
                    gv = MUTABLE_GV(*mark);
d1663 2
a1664 2
		else if (SvROK(*mark) && isGV_with_GP(SvRV(*mark))) {
		    gv = MUTABLE_GV(SvRV(*mark));
d1819 2
a1820 2
                if (isGV_with_GP(*mark)) {
                    gv = MUTABLE_GV(*mark);
d1836 2
a1837 2
		else if (SvROK(*mark) && isGV_with_GP(SvRV(*mark))) {
		    gv = MUTABLE_GV(SvRV(*mark));
a1871 3

    PERL_ARGS_ASSERT_CANDO;

d1962 1
a1962 1
    SV *nsv = optype == OP_MSGGET ? NULL : *++mark;
a1964 1
    PERL_ARGS_ASSERT_DO_IPCGET;
d1976 1
a1976 1
	return semget(key, (int) SvIV(nsv), flags);
d1980 1
a1980 1
	return shmget(key, (size_t) SvUV(nsv), flags);
a2004 1
    PERL_ARGS_ASSERT_DO_IPCCTL;
a2126 1
    PERL_ARGS_ASSERT_DO_MSGSND;
a2149 2

    PERL_ARGS_ASSERT_DO_MSGRCV;
d2154 1
a2154 1
	sv_setpvs(mstr, "");
a2187 2

    PERL_ARGS_ASSERT_DO_SEMOP;
a2241 2

    PERL_ARGS_ASSERT_DO_SHMIO;
d2259 1
a2259 1
	    sv_setpvs(mstr, "");
a2307 3

    PERL_ARGS_ASSERT_START_GLOB;

@


1.1.1.13
log
@Perl 5.12.2 from CPAN
@
text
@a314 1
			/* diag_listed_as: More than one argument to '%s' open */
a400 1
			/* diag_listed_as: More than one argument to '%s' open */
a433 1
		    /* diag_listed_as: More than one argument to '%s' open */
d629 1
d637 1
d760 4
a763 3
		    Perl_ck_warner_d(aTHX_ packWARN(WARN_INPLACE),
				     "Can't do inplace edit: %s is not a regular file",
				     PL_oldname );
d767 1
a767 1
		if (*PL_inplace && strNE(PL_inplace, "*")) {
d792 4
a795 3
			Perl_ck_warner_d(aTHX_ packWARN(WARN_INPLACE),
					 "Can't do inplace edit: %"SVf" would not be unique",
					 SVfARG(sv));
d803 4
a806 3
			Perl_ck_warner_d(aTHX_ packWARN(WARN_INPLACE),
					 "Can't rename %s to %"SVf": %s, skipping file",
					 PL_oldname, SVfARG(sv), Strerror(errno));
d819 4
a822 3
			Perl_ck_warner_d(aTHX_ packWARN(WARN_INPLACE),
					 "Can't rename %s to %"SVf": %s, skipping file",
					 PL_oldname, SVfARG(sv), Strerror(errno) );
d833 4
a836 3
			Perl_ck_warner_d(aTHX_ packWARN(WARN_INPLACE),
					 "Can't remove %s: %s, skipping file",
					 PL_oldname, Strerror(errno) );
d856 3
a858 2
		    Perl_ck_warner_d(aTHX_ packWARN(WARN_INPLACE), "Can't do inplace edit on %s: %s",
				     PL_oldname, Strerror(errno) );
d1098 1
a1098 1
Perl_mode_from_discipline(pTHX_ const char *s, STRLEN len)
d1101 3
a1103 1
    if (s) {
d1249 4
a1252 2
		Perl_ck_warner_d(aTHX_ packWARN(WARN_UTF8),
				 "Wide character in print");
d1400 1
a1400 1
#if defined(__SYMBIAN32__) || defined(__LIBCATAMOUNT__)
d1730 1
a1730 1
		I32 proc;
a1731 3
		if (!(SvIOK(*mark) || SvNOK(*mark) || looks_like_number(*mark)))
		    Perl_croak(aTHX_ "Can't kill a non-numeric process ID");
		proc = SvIV(*mark);
d1754 1
a1754 4
		I32 proc;
		if (!(SvIOK(*mark) || SvNOK(*mark) || looks_like_number(*mark)))
		    Perl_croak(aTHX_ "Can't kill a non-numeric process ID");
		proc = SvIV(*mark);
d1766 1
a1766 4
		I32 proc;
		if (!(SvIOK(*mark) || SvNOK(*mark) || looks_like_number(*mark)))
		    Perl_croak(aTHX_ "Can't kill a non-numeric process ID");
		proc = SvIV(*mark);
a1920 3
# ifdef __CYGWIN__
    if (ingroup(544,effective)) {     /* member of Administrators */
# else
a1921 1
# endif
d1945 2
a1946 2
static bool
S_ingroup(pTHX_ Gid_t testgid, bool effective)
d1948 4
d1976 1
a2008 1
        /* diag_listed_as: msg%s not implemented */
a2068 1
        /* diag_listed_as: sem%s not implemented */
a2074 1
        /* diag_listed_as: shm%s not implemented */
a2121 1
	    /* diag_listed_as: sem%s not implemented */
a2162 1
    /* diag_listed_as: msg%s not implemented */
a2203 1
    /* diag_listed_as: msg%s not implemented */
a2257 1
    /* diag_listed_as: sem%s not implemented */
a2315 1
    /* diag_listed_as: shm%s not implemented */
d2357 5
d2393 1
@


1.1.1.14
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d129 2
a130 3
		"Warning: unable to close filehandle %"HEKf" properly.\n",
		 HEKfARG(GvENAME_HEK(gv))
	    );
d151 1
a151 2
	    Perl_croak(aTHX_ "panic: sysopen with multiple args, num_svs=%ld",
		       (long) num_svs);
d217 1
a217 2
	    name = (SvOK(*svp) || SvGMAGICAL(*svp)) ?
			savesvpv (*svp) : savepvs ("");
d543 1
a543 2
			    "Filehandle STD%s reopened as %"HEKf
			    " only for input",
d545 1
a545 1
			    HEKfARG(GvENAME_HEK(gv)));
d549 2
a550 3
		    "Filehandle STDIN reopened as %"HEKf" only for output",
		     HEKfARG(GvENAME_HEK(gv))
		);
d863 2
d866 1
d931 2
a932 1
	    report_evil_fh(gv);
d998 2
a999 2
    else if (IoTYPE(io) == IoTYPE_WRONLY)
	report_wrongway_fh(gv, '>');
d1037 1
a1037 1
    IO *const io = GvIO(gv);
d1042 1
a1042 1
    if (io && (fp = IoIFP(io))) {
d1049 2
a1050 1
    report_evil_fh(gv);
d1059 1
a1059 1
    IO *const io = GvIO(gv);
d1062 1
a1062 1
    if (io && (fp = IoIFP(io))) {
d1069 2
a1070 1
    report_evil_fh(gv);
d1079 1
a1079 1
    IO *const io = GvIO(gv);
d1084 1
a1084 1
    if (io && (fp = IoIFP(io)))
d1086 2
a1087 1
    report_evil_fh(gv);
a1229 3
	    else if (ckWARN4_d(WARN_UTF8, WARN_SURROGATE, WARN_NON_UNICODE, WARN_NONCHAR)) {
		(void) check_utf8_print((const U8*) tmps, len);
	    }
d1243 1
a1243 6
				 "Wide character in %s",
				   PL_op ? OP_DESC(PL_op) : "print"
				);
		    /* Could also check that isn't one of the things to avoid
		     * in utf8 by using check_utf8_print(), but not doing so,
		     * since the stream isn't a UTF8 stream */
d1260 1
a1260 1
Perl_my_stat_flags(pTHX_ const U32 flags)
d1276 1
a1276 1
        PL_statgv = gv ? gv : (GV *)io;
d1283 4
d1288 4
d1293 3
a1295 3
	PL_laststatval = -1;
	report_evil_fh(gv);
	return -1;
d1298 1
a1298 6
      SV* const sv = PL_op->op_private & OPpFT_STACKING ? TOPs : POPs;
      PUTBACK;
      if ((PL_op->op_private & (OPpFT_STACKED|OPpFT_AFTER_t))
	     == OPpFT_STACKED)
	return PL_laststatval;
      else {
d1301 7
a1307 1
	if ((gv = MAYBE_DEREF_GV_flags(sv,flags))) {
d1316 1
a1316 1
	s = SvPV_flags_const(sv, len, flags);
a1324 1
      }
d1330 1
a1330 1
Perl_my_lstat_flags(pTHX_ const U32 flags)
a1343 1
	PL_laststatval = -1;
d1345 3
a1347 3
	    Perl_warner(aTHX_ packWARN(WARN_IO),
		 	     "Use of -l on filehandle %"HEKf,
			      HEKfARG(GvENAME_HEK(cGVOP_gv)));
a1348 1
	return -1;
d1350 2
a1351 5
    sv = PL_op->op_private & OPpFT_STACKING ? TOPs : POPs;
    PUTBACK;
    if ((PL_op->op_private & (OPpFT_STACKED|OPpFT_AFTER_t))
	     == OPpFT_STACKED) {
      if (PL_laststype != OP_LSTAT)
a1352 2
      return PL_laststatval;
    } 
d1356 8
a1363 1
    file = SvPV_flags_const_nolen(sv, flags);
a1577 1
    STRLEN len;
d1619 3
a1621 1
                if ((gv = MAYBE_DEREF_GV(*mark))) {
d1635 4
d1640 1
a1640 1
		    const char *name = SvPV_nomg_const_nolen(*mark);
d1659 3
a1661 1
		if ((gv = MAYBE_DEREF_GV(*mark))) {
d1675 4
d1680 1
a1680 1
		    const char *name = SvPV_nomg_const_nolen(*mark);
d1700 1
a1700 1
	s = SvPVx_const(*++mark, len);
d1702 1
a1702 1
	    if (*s == 'S' && s[1] == 'I' && s[2] == 'G') {
d1704 2
a1705 4
                len -= 3;
            }
           if ((val = whichsig_pvn(s, len)) < 0)
               Perl_croak(aTHX_ "Unrecognized signal name \"%"SVf"\"", SVfARG(*mark));
a1722 1
		SvGETMAGIC(*mark);
d1725 1
a1725 1
		proc = SvIV_nomg(*mark);
a1741 1
	    PERL_ASYNC_CHECK();
a1748 1
		SvGETMAGIC(*mark);
d1751 1
a1751 1
		proc = SvIV_nomg(*mark);
a1763 1
		SvGETMAGIC(*mark);
d1766 1
a1766 1
		proc = SvIV_nomg(*mark);
a1771 1
	PERL_ASYNC_CHECK();
d1780 1
a1780 1
	    if (PerlProc_geteuid() || PL_unsafe) {
d1840 3
a1842 1
                if ((gv = MAYBE_DEREF_GV(*mark))) {
d1857 4
d1862 1
a1862 1
		    const char * const name = SvPV_nomg_const_nolen(*mark);
d1900 1
a1900 1
     * by the Microsoft C library stat() function for the following:
d1924 1
a1924 1
    if ((effective ? PerlProc_geteuid() : PerlProc_getuid()) == 0) {	/* root is special */
d1934 1
a1934 1
    if (statbufp->st_uid == (effective ? PerlProc_geteuid() : PerlProc_getuid()) ) {
d1953 1
a1953 1
    if (testgid == (effective ? PerlProc_getegid() : PerlProc_getgid()))
d2299 1
a2299 2
	SvUPGRADE(mstr, SVt_PV);
	SvPOK_only(mstr);
a2394 10
    {
	GV * const envgv = gv_fetchpvs("ENV", 0, SVt_PVHV);
	SV ** const home = hv_fetchs(GvHV(envgv), "HOME", 0);
	SV ** const path = hv_fetchs(GvHV(envgv), "PATH", 0);
	if (home && *home) SvGETMAGIC(*home);
	if (path && *path) SvGETMAGIC(*path);
	save_hash(gv_fetchpvs("ENV", 0, SVt_PVHV));
	if (home && *home) SvSETMAGIC(*home);
	if (path && *path) SvSETMAGIC(*path);
    }
@


1.1.1.15
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d64 1
a64 1
Perl_do_openn(pTHX_ GV *gv, const char *oname, I32 len, int as_raw,
d69 1
a69 1
    IO * const io = GvIOn(gv);
d323 1
a323 4
		    if (num_svs && (
			     SvIOK(*svp)
			  || (SvPOKp(*svp) && looks_like_number(*svp))
		       )) {
d623 1
a623 1
                        vmssetuserlnm("SYS$OUTPUT", newname);
d625 1
a625 1
                        vmssetuserlnm("SYS$ERROR", newname);
d706 1
a706 1
Perl_nextargv(pTHX_ GV *gv)
d709 1
a709 1
    SV *sv;
a746 1
	SvTAINTED_off(GvSVn(gv)); /* previous tainting irrelevant */
d805 1
a805 1
#if !defined(DOSISH) && !defined(__CYGWIN__)
d907 1
a907 1
	    SvREFCNT_dec_NN(oldout);
d993 1
a993 1
    IO * const io = GvIO(gv);
d1039 1
a1039 1
    PerlIO *fp;
d1060 1
a1060 1
    PerlIO *fp;
d1079 1
a1079 1
    PerlIO *fp;
d1198 1
a1198 1
Perl_do_print(pTHX_ SV *sv, PerlIO *fp)
d1222 2
a1223 2
	if (PerlIO_isutf8(fp)) { /* If the stream is utf8 ... */
	    if (!SvUTF8(sv)) {	/* Convert to utf8 if necessary */
d1231 2
a1232 3
	} /* else stream isn't utf8 */
	else if (DO_UTF8(sv)) { /* But if is utf8 internally, attempt to
				   convert to bytes */
a1236 3

		/* Here, succeeded in downgrading from utf8.  Set up to below
		 * output the converted value */
d1241 1
a1241 2
	    else {  /* Non-utf8 output stream, but string only representable in
		       utf8 */
d1274 1
d1295 4
a1298 1
    else if ((PL_op->op_private & (OPpFT_STACKED|OPpFT_AFTER_t))
d1301 1
a1301 2
    else {
	SV* const sv = TOPs;
d1322 1
d1331 1
a1331 1
    static const char* const no_prev_lstat = "The stat preceding -l _ wasn't an lstat";
d1333 1
a1334 1
    SV* const sv = TOPs;
d1336 1
d1339 1
a1339 1
		Perl_croak(aTHX_ "%s", no_prev_lstat);
d1350 2
d1355 1
a1355 1
	Perl_croak(aTHX_ "%s", no_prev_lstat);
d1357 1
a1357 1
    }
a1360 4
    if (SvROK(sv) && isGV_with_GP(SvRV(sv)) && ckWARN(WARN_IO)) {
        Perl_warner(aTHX_ packWARN(WARN_IO), "Use of -l on filehandle %s",
           GvENAME((const GV *)SvRV(sv)));
    }
d1384 1
a1384 1
Perl_do_aexec5(pTHX_ SV *really, SV **mark, SV **sp,
d1439 2
a1440 2
    const char **a;
    char *s;
d1501 1
a1501 1
    while (isWORDCHAR(*s))
a1567 4
#ifdef VMS
#include <starlet.h> /* for sys$delprc */
#endif

d1569 1
a1569 1
Perl_apply(pTHX_ I32 type, SV **mark, SV **sp)
d1572 2
a1573 2
    I32 val;
    I32 tot = 0;
a1577 1
    bool killgp = FALSE;
a1580 2
    PERL_UNUSED_VAR(what); /* may not be used depending on compile options */

d1596 1
a1596 1
	if (TAINT_get) { TAINT_PROPER(what); }				\
d1600 1
a1600 1
    if (TAINTING_get) {
d1645 1
a1645 1
            I32 val2;
a1687 6
	if (*s == '-' && isALPHA(s[1]))
	{
	    s++;
	    len--;
            killgp = TRUE;
	}
a1696 1
	{
a1697 6
	    if (val < 0)
	    {
		killgp = TRUE;
                val = -val;
	    }
	}
d1702 1
d1704 1
d1711 1
a1711 1
		unsigned long int __vmssts;
d1736 27
a1762 9
	while (++mark <= sp) {
	    Pid_t proc;
	    SvGETMAGIC(*mark);
	    if (!(SvNIOK(*mark) || looks_like_number(*mark)))
		Perl_croak(aTHX_ "Can't kill a non-numeric process ID");
	    proc = SvIV_nomg(*mark);
	    if (killgp)
	    {
                proc = -proc;
a1763 3
	    APPLY_TAINT_PROPER();
	    if (PerlProc_kill(proc, val))
		tot--;
d1875 1
a1875 1
Perl_cando(pTHX_ Mode_t mode, bool effective, const Stat_t *statbufp)
a2155 1
    return -1;
a2197 1
    return -1;
a2284 2
	SvGETMAGIC(mstr);
	SvUPGRADE(mstr, SVt_PV);
d2287 1
a2312 1
    return -1;
d2406 1
a2406 1
 * indent-tabs-mode: nil
d2409 1
a2409 1
 * ex: set ts=8 sts=4 sw=4 et:
@


1.1.1.16
log
@Import perl-5.20.1
@
text
@d63 4
a66 3
static IO *
S_openn_setup(pTHX_ GV *gv, char *mode, PerlIO **saveifp, PerlIO **saveofp,
              int *savefd,  char *savetype)
d70 13
d84 1
a84 6
    PERL_ARGS_ASSERT_OPENN_SETUP;

    *saveifp = NULL;
    *saveofp = NULL;
    *savefd = -1;
    *savetype = IoTYPE_CLOSED;
d89 10
d101 1
d104 28
a132 35
	else {
            const int old_fd = PerlIO_fileno(IoIFP(io));

            if (old_fd >= 0 && old_fd <= PL_maxsysfd) {
                /* This is one of the original STD* handles */
                *saveifp  = IoIFP(io);
                *saveofp  = IoOFP(io);
                *savetype = IoTYPE(io);
                *savefd   = old_fd;
            }
            else {
                int result;

                if (IoTYPE(io) == IoTYPE_PIPE)
                    result = PerlProc_pclose(IoIFP(io));
                else if (IoIFP(io) != IoOFP(io)) {
                    if (IoOFP(io)) {
                        result = PerlIO_close(IoOFP(io));
                        PerlIO_close(IoIFP(io)); /* clear stdio, fd already closed */
                    }
                    else
                        result = PerlIO_close(IoIFP(io));
                }
                else
                    result = PerlIO_close(IoIFP(io));

                if (result == EOF && old_fd > PL_maxsysfd) {
                    /* Why is this not Perl_warn*() call ? */
                    PerlIO_printf(Perl_error_log,
                                  "Warning: unable to close filehandle %"HEKf" properly.\n",
                                  HEKfARG(GvENAME_HEK(gv))
                        );
                }
            }
        }
a134 9
    return io;
}

bool
Perl_do_openn(pTHX_ GV *gv, const char *oname, I32 len, int as_raw,
	      int rawmode, int rawperm, PerlIO *supplied_fp, SV **svp,
	      I32 num_svs)
{
    PERL_ARGS_ASSERT_DO_OPENN;
a137 29

	if (num_svs != 0) {
	    Perl_croak(aTHX_ "panic: sysopen with multiple args, num_svs=%ld",
		       (long) num_svs);
	}
        return do_open_raw(gv, oname, len, rawmode, rawperm);
    }
    return do_open6(gv, oname, len, supplied_fp, svp, num_svs);
}

bool
Perl_do_open_raw(pTHX_ GV *gv, const char *oname, STRLEN len,
                 int rawmode, int rawperm)
{
    dVAR;
    PerlIO *saveifp;
    PerlIO *saveofp;
    int savefd;
    char savetype;
    char mode[PERL_MODE_MAX];	/* file mode ("r\0", "rb\0", "ab\0" etc.) */
    IO * const io = openn_setup(gv, mode, &saveifp, &saveofp, &savefd, &savetype);
    int writing = 0;
    PerlIO *fp;

    PERL_ARGS_ASSERT_DO_OPEN_RAW;

    /* For ease of blame back to 5.000, keep the existing indenting. */
    {
        /* sysopen style args, i.e. integer mode and permissions */
a149 1
        SV *namesv;
d151 4
d186 4
a189 1
	fp = PerlIO_openn(aTHX_ NULL, mode, -1, rawmode, rawperm, NULL, 1, &namesv);
d191 1
a191 24
    return openn_cleanup(gv, io, fp, mode, oname, saveifp, saveofp, savefd,
                         savetype, writing, 0, NULL);
}

bool
Perl_do_open6(pTHX_ GV *gv, const char *oname, STRLEN len,
              PerlIO *supplied_fp, SV **svp, U32 num_svs)
{
    dVAR;
    PerlIO *saveifp;
    PerlIO *saveofp;
    int savefd;
    char savetype;
    char mode[PERL_MODE_MAX];	/* file mode ("r\0", "rb\0", "ab\0" etc.) */
    IO * const io = openn_setup(gv, mode, &saveifp, &saveofp, &savefd, &savetype);
    int writing = 0;
    PerlIO *fp;
    bool was_fdopen = FALSE;
    char *type  = NULL;

    PERL_ARGS_ASSERT_DO_OPEN6;

    /* For ease of blame back to 5.000, keep the existing indenting. */
    {
a196 11
        bool in_raw = 0, in_crlf = 0, out_raw = 0, out_crlf = 0;

        /* Collect default raw/crlf info from the op */
        if (PL_op && PL_op->op_type == OP_OPEN) {
            /* set up IO layers */
            const U8 flags = PL_op->op_private;
            in_raw = (flags & OPpOPEN_IN_RAW);
            in_crlf = (flags & OPpOPEN_IN_CRLF);
            out_raw = (flags & OPpOPEN_OUT_RAW);
            out_crlf = (flags & OPpOPEN_OUT_CRLF);
        }
a208 2
            const char *p;
            STRLEN nlen = 0;
a215 1
                fp = NULL;
d219 2
a220 9
            p = (SvOK(*svp) || SvGMAGICAL(*svp)) ? SvPV(*svp, nlen) : NULL;

            if (p && !IS_SAFE_PATHNAME(p, nlen, "open")) {
                fp = NULL;
                goto say_false;
            }

	    name = p ? savepvn(p, nlen) : savepvs("");

a255 1
                fp = NULL;
a280 1
                        fp = NULL;
a316 1
                    int wanted_fd;
d327 1
a327 1
                        wanted_fd = SvUV(*svp);
d331 1
a331 1
                        wanted_fd = atoi(type);
a346 1
                            fp = NULL;
d355 7
d367 1
a367 1
			    wanted_fd = PerlIO_fileno(that_fp);
d381 1
a381 1
			    wanted_fd = -1;
d390 1
a390 1
                            wanted_fd = PerlLIO_dup(wanted_fd);
d393 3
a395 3
                        if (!(fp = PerlIO_openn(aTHX_ type,mode,wanted_fd,0,0,NULL,num_svs,svp))) {
                            if (dodup && wanted_fd >= 0)
                                PerlLIO_close(wanted_fd);
d413 4
a416 5
		    if (num_svs) {
                        fp = PerlIO_openn(aTHX_ type,mode,-1,0,0,NULL,num_svs,svp);
                    }
                    else {
                        SV *namesv = newSVpvn_flags(type, tend - type, SVs_TEMP);
a417 1
                        fp = PerlIO_openn(aTHX_ type,mode,-1,0,0,NULL,1,&namesv);
d419 1
d447 4
a450 5
		if (num_svs) {
                    fp = PerlIO_openn(aTHX_ type,mode,-1,0,0,NULL,num_svs,svp);
                }
                else {
                    SV *namesv  = newSVpvn_flags(type, tend - type, SVs_TEMP);
a451 1
                    fp = PerlIO_openn(aTHX_ type,mode,-1,0,0,NULL,1,&namesv);
d453 1
a477 1
                fp = NULL;
a501 1
                        fp = NULL;
d526 4
a529 5
		if (num_svs) {
                    fp = PerlIO_openn(aTHX_ type,mode,-1,0,0,NULL,num_svs,svp);
                }
                else {
		    SV *namesv = newSVpvn_flags(type, tend - type, SVs_TEMP);
a530 1
                    fp = PerlIO_openn(aTHX_ type,mode,-1,0,0,NULL,1,&namesv);
d532 1
a535 17

  say_false:
    return openn_cleanup(gv, io, fp, mode, oname, saveifp, saveofp, savefd,
                         savetype, writing, was_fdopen, type);
}

/* Yes, this is ugly, but it's private, and I don't see a cleaner way to
   simplify the two-headed public interface of do_openn. */
static bool
S_openn_cleanup(pTHX_ GV *gv, IO *io, PerlIO *fp, char *mode, const char *oname,
                PerlIO *saveifp, PerlIO *saveofp, int savefd, char savetype,
                int writing, bool was_fdopen, const char *type)
{
    int fd;

    PERL_ARGS_ASSERT_OPENN_CLEANUP;

a540 2
        {
            GCC_DIAG_IGNORE(-Wformat-nonliteral); /* PL_warn_nl is constant */
a541 2
            GCC_DIAG_RESTORE;
        }
d578 1
d580 3
d690 1
a690 1
	    if (!(IoOFP(io) = PerlIO_openn(aTHX_ type,s,fd,0,0,NULL,0,NULL))) {
d712 7
d746 1
a746 1
    while (av_tindex(GvAV(gv)) >= 0) {
d748 1
a748 1
        SV *const sv = av_shift(GvAV(gv));
d754 2
a755 18
        if (LIKELY(!PL_inplace)) {
            if (do_open6(gv, PL_oldname, oldlen, NULL, NULL, 0)) {
                return IoIFP(GvIOp(gv));
            }
        }
        else {
            /* This very long block ends with return IoIFP(GvIOp(gv));
               Both this block and the block above fall through on open
               failure to the warning code, and then the while loop above tries
               the next entry. */
            if (do_open_raw(gv, PL_oldname, oldlen, O_RDONLY, 0)) {
#ifndef FLEXFILENAMES
                int filedev;
                int fileino;
#endif
                Uid_t fileuid;
                Gid_t filegid;

d821 1
a821 1
		    do_open_raw(gv, SvPVX_const(sv), SvCUR(sv), O_RDONLY, 0);
d853 2
a854 2
		if (!Perl_do_open_raw(aTHX_ PL_argvoutgv, SvPVX_const(sv),
                                      SvCUR(sv),
d856 1
a856 1
                                      O_WRONLY|O_CREAT|O_TRUNC, 0
d858 1
a858 1
                                      O_WRONLY|O_CREAT|OPEN_EXCL, 0600
d860 1
a860 1
                        )) {
a874 1
		    /* XXX silently ignore failures */
d876 1
a876 1
		    PERL_UNUSED_RESULT(fchown(PL_lastfd,fileuid,filegid));
d879 1
a879 1
		    PERL_UNUSED_RESULT(PerlLIO_chown(PL_oldname,fileuid,filegid));
a882 1
                return IoIFP(GvIOp(gv));
d884 16
a899 14
	} /* successful do_open_raw(), PL_inplace non-NULL */

        if (ckWARN_d(WARN_INPLACE)) {
            const int eno = errno;
            if (PerlLIO_stat(PL_oldname, &PL_statbuf) >= 0
                && !S_ISREG(PL_statbuf.st_mode)) {
                Perl_warner(aTHX_ packWARN(WARN_INPLACE),
                            "Can't do inplace edit: %s is not a regular file",
                            PL_oldname);
            }
            else {
                Perl_warner(aTHX_ packWARN(WARN_INPLACE), "Can't open %s: %s",
                            PL_oldname, Strerror(eno));
            }
d1048 4
d1067 4
d1325 1
a1325 2
	if (PL_laststatval < 0 && ckWARN(WARN_NEWLINE) && strchr(s, '\n')) {
            GCC_DIAG_IGNORE(-Wformat-nonliteral); /* PL_warn_nl is constant */
a1326 2
            GCC_DIAG_RESTORE;
        }
a1339 1
    bool isio = FALSE;
a1347 1
	    /* diag_listed_as: Use of -l on filehandle%s */
d1363 3
a1365 16
    if ( (  (SvROK(sv) && (  isGV_with_GP(SvRV(sv))
                          || (isio = SvTYPE(SvRV(sv)) == SVt_PVIO)  )
            )
         || isGV_with_GP(sv)
         )
      && ckWARN(WARN_IO)) {
        if (isio)
	    /* diag_listed_as: Use of -l on filehandle%s */
            Perl_warner(aTHX_ packWARN(WARN_IO),
                             "Use of -l on filehandle");
        else
	    /* diag_listed_as: Use of -l on filehandle%s */
            Perl_warner(aTHX_ packWARN(WARN_IO),
                             "Use of -l on filehandle %"HEKf,
                              GvENAME_HEK((const GV *)
                                          (SvROK(sv) ? SvRV(sv) : sv)));
d1370 2
a1371 5
    if (PL_laststatval < 0 && ckWARN(WARN_NEWLINE) && strchr(file, '\n')) {
        GCC_DIAG_IGNORE(-Wformat-nonliteral); /* PL_warn_nl is constant */
        Perl_warner(aTHX_ packWARN(WARN_NEWLINE), PL_warn_nl, "lstat");
        GCC_DIAG_RESTORE;
    }
d1384 1
a1384 2
        /* XXX silently ignore failures */
        PERL_UNUSED_RESULT(PerlLIO_write(fd, (void*)&e, sizeof(int)));
d1646 1
a1646 1
		    const char *name = SvPV_nomg_const(*mark, len);
d1648 2
a1649 4
                    if (!IS_SAFE_PATHNAME(name, len, "chmod") ||
                        PerlLIO_chmod(name, val)) {
                        tot--;
                    }
d1680 1
a1680 1
		    const char *name = SvPV_nomg_const(*mark, len);
d1682 1
a1682 2
                    if (!IS_SAFE_PATHNAME(name, len, "chown") ||
                        PerlLIO_chown(name, val, val2)) {
a1683 1
                    }
d1766 4
d1771 1
a1771 8
#ifdef HAS_KILLPG
            /* use killpg in preference, as the killpg() wrapper for Win32
             * understands process groups, but the kill() wrapper doesn't */
            if (killgp ? PerlProc_killpg(proc, val)
                       : PerlProc_kill(proc, val))
#else
            if (PerlProc_kill(killgp ? -proc: proc, val))
#endif
d1781 1
a1781 1
	    s = SvPV_const(*mark, len);
d1783 1
a1783 4
	    if (!IS_SAFE_PATHNAME(s, len, "unlink")) {
                tot--;
            }
	    else if (PL_unsafe) {
d1788 1
a1788 3
		if (PerlLIO_lstat(s,&PL_statbuf) < 0)
		    tot--;
		else if (S_ISDIR(PL_statbuf.st_mode)) {
a1789 2
		    SETERRNO(EISDIR, SS$_NOPRIV);
		}
d1859 1
a1859 1
		    const char * const name = SvPV_nomg_const(*mark, len);
a1860 4
		    if (!IS_SAFE_PATHNAME(name, len, "utime")) {
                        tot--;
                    }
                    else
a2113 4
            if(cmd == SETVAL) {
                unsemds.val = PTR2nat(a);
            }
            else {
d2115 1
a2115 1
                unsemds.buff = (struct semid_ds *)a;
d2117 1
a2117 1
                unsemds.buf = (struct semid_ds *)a;
a2118 1
            }
d2197 1
d2200 1
d2249 9
d2307 1
d2310 1
d2337 1
a2337 1
perl on VMS).  This code used to be inline, but now perl uses C<File::Glob>
a2349 2
    STRLEN len;
    const char *s = SvPV(tmpglob, len);
a2352 3
    if (!IS_SAFE_SYSCALL(s, len, "pattern", "glob"))
        return NULL;

d2390 3
d2394 1
d2407 2
a2408 2
    (void)do_open6(PL_last_in_gv, SvPVX_const(tmpcmd), SvCUR(tmpcmd),
                   NULL, NULL, 0);
a2411 6

    if (!fp && ckWARN(WARN_GLOB)) {
        Perl_warner(aTHX_ packWARN(WARN_GLOB), "glob failed (can't start child: %s)",
                    Strerror(errno));
    }

@


1.1.1.17
log
@Import perl-5.24.2
@
text
@d67 1
d148 1
d218 1
a382 1
                    UV uv;
d396 2
a397 5
		    else if (isDIGIT(*type)
                        && grok_atoUV(type, &uv, NULL)
                        && uv <= INT_MAX
                    ) {
                        wanted_fd = (int)uv;
d440 2
a441 5
                        else {
                            SETERRNO(EBADF, RMS_IFI);
                            fp = NULL;
                            goto say_false;
                        }
d620 1
a620 1
	    && should_warn_nl(oname)
d649 3
a651 3
    /* Do NOT do: "if (fd < 0) goto say_false;" here.  If there is no
     * fd assume it isn't a socket - this covers PerlIO::scalar -
     * otherwise unless we "know" the type probe for socket-ness.
d699 1
a699 4
	    if (fd < 0) {
                SETERRNO(EBADF,RMS_IFI);
		goto say_false;
            } else if (PerlLIO_dup2(fd, savefd) < 0) {
d735 1
a735 1
                int dupfd = ofd >= 0 ? PerlLIO_dup(ofd) : -1;
d737 2
a738 8
		/* Assume if we have F_SETFD we have F_GETFD. */
                /* Get a copy of all the fd flags. */
                int fd_flags = ofd >= 0 ? fcntl(ofd, F_GETFD) : -1;
                if (fd_flags < 0) {
                    if (dupfd >= 0)
                        PerlLIO_close(dupfd);
                    goto say_false;
                }
a739 5
                if (ofd < 0 || dupfd < 0) {
                    if (dupfd >= 0)
                        PerlLIO_close(dupfd);
                    goto say_false;
                }
d741 1
a741 1
                PerlLIO_dup2(dupfd, ofd);
d743 2
a744 3
		/* The dup trick has lost close-on-exec on ofd,
                 * and possibly any other flags, so restore them. */
		fcntl(ofd,F_SETFD, fd_flags);
d755 5
a759 4
#if defined(HAS_FCNTL) && defined(F_SETFD) && defined(FD_CLOEXEC)
    if (fd >= 0 && fd > PL_maxsysfd && fcntl(fd, F_SETFD, FD_CLOEXEC) < 0) {
        PerlLIO_close(fd);
        goto say_false;
d774 1
d783 1
a783 1
  say_false:
d791 1
a791 1
Perl_nextargv(pTHX_ GV *gv, bool nomagicopen)
d793 1
a794 1
    SV *const old_out_name = PL_inplace ? newSVsv(GvSV(gv)) : NULL;
a797 3
    if (old_out_name)
        SAVEFREESV(old_out_name);

d800 1
a800 1
    if (io && (IoFLAGS(io) & (IOf_ARGV|IOf_START)) == (IOf_ARGV|IOf_START)) {
a821 1
	Stat_t statbuf;
d830 1
a830 4
            if (nomagicopen
                    ? do_open6(gv, "<", 1, NULL, &GvSV(gv), 1)
                    : do_open6(gv, PL_oldname, oldlen, NULL, NULL, 0)
               ) {
a834 7
            {
                IO * const io = GvIOp(PL_argvoutgv);
                if (io && IoIFP(io) && old_out_name && !io_close(io, PL_argvoutgv, FALSE, FALSE)) {
                    Perl_croak(aTHX_ "Failed to close in-place edit file %"SVf": %s\n",
                               old_out_name, Strerror(errno));
                }
            }
d927 1
a927 1
#if !defined(DOSISH) && !defined(__amigaos4__)
d959 1
a959 2
                if (PL_lastfd >= 0) {
                    (void)PerlLIO_fstat(PL_lastfd,&statbuf);
d961 1
a961 1
                    (void)fchmod(PL_lastfd,PL_filemode);
d963 1
a963 1
                    (void)PerlLIO_chmod(PL_oldname,PL_filemode);
d965 2
a966 2
                    if (fileuid != statbuf.st_uid || filegid != statbuf.st_gid) {
                        /* XXX silently ignore failures */
d968 1
a968 1
                        PERL_UNUSED_RESULT(fchown(PL_lastfd,fileuid,filegid));
d971 1
a971 1
                        PERL_UNUSED_RESULT(PerlLIO_chown(PL_oldname,fileuid,filegid));
a973 1
                    }
d981 2
a982 2
            if (PerlLIO_stat(PL_oldname, &statbuf) >= 0
                && !S_ISREG(statbuf.st_mode)) {
d996 1
a996 11
        if (old_out_name) {
            IO * const io = GvIOp(PL_argvoutgv);
            if (io && IoIFP(io) && !io_close(io, PL_argvoutgv, FALSE, FALSE)) {
                Perl_croak(aTHX_ "Failed to close in-place edit file %"SVf": %s\n",
                           old_out_name, Strerror(errno));
            }
        }
        else {
            /* maybe this is no longer wanted */
            (void)do_close(PL_argvoutgv,FALSE);
        }
d1014 1
d1033 1
a1033 1
    retval = io_close(io, NULL, not_implicit, FALSE);
d1044 1
a1044 1
Perl_io_close(pTHX_ IO *io, GV *gv, bool not_implicit, bool warn_on_fail)
d1046 1
a1066 4
#ifdef USE_PERLIO
		if (prev_err)
		    PerlIO_restore_errno(IoOFP(io));
#endif
a1071 4
#ifdef USE_PERLIO
		if (prev_err)
		    PerlIO_restore_errno(IoIFP(io));
#endif
a1075 14

	if (warn_on_fail && !retval) {
	    if (gv)
		Perl_ck_warner_d(aTHX_ packWARN(WARN_IO),
				"Warning: unable to close filehandle %"
				 HEKf" properly: %"SVf,
				 HEKfARG(GvNAME_HEK(gv)),
                                 SVfARG(get_sv("!",GV_ADD)));
	    else
		Perl_ck_warner_d(aTHX_ packWARN(WARN_IO),
				"Warning: unable to close filehandle "
				"properly: %"SVf,
				 SVfARG(get_sv("!",GV_ADD)));
	}
d1087 1
d1120 1
a1120 1
	    if (gv != PL_argvgv || !nextargv(gv, FALSE))	/* get another fp handy */
d1132 1
d1149 1
d1164 1
d1170 2
a1171 9
    if (io && (fp = IoIFP(io))) {
        int fd = PerlIO_fileno(fp);
        if (fd < 0 || (whence == SEEK_SET && pos < 0)) {
            SETERRNO(EINVAL,LIB_INVARG);
            return -1;
        } else {
            return PerlLIO_lseek(fd, pos, whence);
        }
    }
a1180 1
    PERL_UNUSED_CONTEXT;
d1194 1
a1194 1
		    /* FALLTHROUGH */
d1204 1
a1204 1
		    /* FALLTHROUGH */
d1215 1
a1215 1
  fail_discipline:
d1287 2
d1360 1
d1375 1
a1375 1
        if (io) {
d1377 1
a1377 7
                int fd = PerlIO_fileno(IoIFP(io));
                if (fd < 0) {
                    /* E.g. PerlIO::scalar has no real fd. */
                    return (PL_laststatval = -1);
                } else {
                    return (PL_laststatval = PerlLIO_fstat(fd, &PL_statcache));
                }
d1408 1
a1408 1
	if (PL_laststatval < 0 && ckWARN(WARN_NEWLINE) && should_warn_nl(s)) {
d1421 1
d1465 2
a1466 2
                              HEKfARG(GvENAME_HEK((const GV *)
                                          (SvROK(sv) ? SvRV(sv) : sv))));
d1471 1
a1471 1
    if (PL_laststatval < 0 && ckWARN(WARN_NEWLINE) && should_warn_nl(file)) {
a1483 1

d1485 2
a1486 2
        Perl_warner(aTHX_ packWARN(WARN_EXEC), "Can't exec \"%s\": %s",
                    cmd, Strerror(e));
d1522 4
a1525 5
	if (really && *tmps) {
            PerlProc_execvp(tmps,EXEC_ARGV_CAST(PL_Argv));
	} else {
            PerlProc_execvp(PL_Argv[0],EXEC_ARGV_CAST(PL_Argv));
	}
d1537 1
d1640 1
a1640 1
            PerlProc_execl(PL_sh_path, "sh", "-c", cmd, (char *)NULL);
d1664 1
a1664 1
        PerlProc_execvp(PL_Argv[0],EXEC_ARGV_CAST(PL_Argv));
d1679 4
d1686 1
a1738 1
                        int fd = PerlIO_fileno(IoIFP(GvIOn(gv)));
d1740 2
a1741 5
                        if (fd < 0) {
                            SETERRNO(EBADF,RMS_IFI);
                            tot--;
                        } else if (fchmod(fd, val))
                            tot--;
a1746 1
                        SETERRNO(EBADF,RMS_IFI);
a1774 1
                        int fd = PerlIO_fileno(IoIFP(GvIOn(gv)));
d1776 1
a1776 14
                        if (fd < 0) {
			    SETERRNO(EBADF,RMS_IFI);
			    tot--;
#if Uid_t_sign == 1
			} else if (val < 0) {
			    SETERRNO(EINVAL,LIB_INVARG);
			    tot--;
#endif
#if Gid_t_sign == 1
			} else if (val2 < 0) {
			    SETERRNO(EINVAL,LIB_INVARG);
			    tot--;
#endif
                        } else if (fchown(fd, val, val2))
a1782 1
                        SETERRNO(EBADF,RMS_IFI);
d1835 34
a1868 1

a1899 1
		{
a1900 13
		}
#if defined(__amigaos4__) && defined(NEWLIB)
		else
		{
                  /* Under AmigaOS4 unlink only 'fails' if the
                   * filename is invalid.  It may not remove the file
                   * if it's locked, so check if it's still around. */
                  if ((access(s,F_OK) != -1))
                  {
                    tot--;
                  }
		}
#endif
d1903 1
a1903 2
		Stat_t statbuf;
		if (PerlLIO_lstat(s, &statbuf) < 0)
d1905 1
a1905 2
		else if (S_ISDIR(statbuf.st_mode)) {
		    SETERRNO(EISDIR, SS_NOPRIV);
d1907 1
d1911 1
a1911 15
		    {
				tot--;
			}
#if defined(__amigaos4__) && defined(NEWLIB)
			else
			{
				/* Under AmigaOS4 unlink only 'fails' if the filename is invalid */
				/* It may not remove the file if it's Locked, so check if it's still */
				/* arround */
				if((access(s,F_OK) != -1))
				{
					tot--;
				}
			}	
#endif
a1964 1
                        int fd =  PerlIO_fileno(IoIFP(GvIOn(gv)));
d1966 2
a1967 4
                        if (fd < 0) {
                            SETERRNO(EBADF,RMS_IFI);
                            tot--;
			} else if (futimes(fd, (struct timeval *) utbufp))
d2012 2
a2014 1
    PERL_UNUSED_CONTEXT;
d2072 1
a2072 4
#ifndef PERL_IMPLICIT_SYS
    /* PERL_IMPLICIT_SYS like Win32: getegid() etc. require the context. */
    PERL_UNUSED_CONTEXT;
#endif
d2082 7
a2088 8
        if (anum > 0) {
            Newx(gary, anum, Groups_t);
            anum = getgroups(anum, gary);
            while (--anum >= 0)
                if (gary[anum] == testgid) {
                    rc = TRUE;
                    break;
                }
d2090 1
a2090 2
            Safefree(gary);
        }
d2103 1
d2138 1
d2272 1
d2287 1
a2287 6
    if (id >= 0 && flags >= 0) {
      return msgsnd(id, (struct msgbuf *)mbuf, msize, flags);
    } else {
      SETERRNO(EINVAL,LIB_INVARG);
      return -1;
    }
d2301 1
d2321 1
a2321 6
    if (id >= 0 && msize >= 0 && flags >= 0) {
        ret = msgrcv(id, (struct msgbuf *)mbuf, msize, mtype, flags);
    } else {
        SETERRNO(EINVAL,LIB_INVARG);
        ret = -1;
    }
d2342 1
d2388 1
d2407 1
a2407 6
    if (id >= 0) {
        shm = (char *)shmat(id, NULL, (optype == OP_SHMREAD) ? SHM_RDONLY : 0);
    } else {
        SETERRNO(EINVAL,LIB_INVARG);
        return -1;
    }
d2453 2
a2454 3
this glob starter is only used by miniperl during the build process,
or when PERL_EXTERNAL_GLOB is defined.
Moving it away shrinks F<pp_hot.c>; shrinking F<pp_hot.c> helps speed perl up.
d2462 1
d2538 6
@


