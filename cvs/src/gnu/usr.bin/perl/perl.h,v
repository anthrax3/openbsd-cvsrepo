head	1.21;
access;
symbols
	OPENBSD_6_0:1.20.0.8
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.20.0.2
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.20.0.4
	OPENBSD_5_8_BASE:1.20
	PERL_5_20_2:1.1.1.17
	OPENBSD_5_7:1.19.0.2
	OPENBSD_5_7_BASE:1.19
	PERL_5_20_1:1.1.1.16
	OPENBSD_5_6:1.18.0.4
	OPENBSD_5_6_BASE:1.18
	PERL_5_18_2:1.1.1.15
	PERL:1.1.1
	OPENBSD_5_5:1.17.0.6
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.17.0.2
	OPENBSD_5_4_BASE:1.17
	PERL_5_16_3:1.1.1.14
	OPENBSD_5_3:1.16.0.10
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.8
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.6
	OPENBSD_5_0:1.16.0.4
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.16.0.2
	OPENBSD_4_9_BASE:1.16
	PERL_5_12_2:1.1.1.13
	OPENBSD_4_8:1.15.0.4
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.2
	OPENBSD_4_7_BASE:1.15
	PERL_5_10_1:1.1.1.12
	OPENBSD_4_6:1.14.0.6
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.2
	OPENBSD_4_5_BASE:1.14
	PERL_5_10_0:1.1.1.11
	OPENBSD_4_4:1.13.0.8
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.6
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.4
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.2
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.12.0.2
	OPENBSD_4_0_BASE:1.12
	PERL_5_8_8:1.1.1.10
	OPENBSD_3_9:1.11.0.2
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.10.0.4
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.2
	OPENBSD_3_7_BASE:1.10
	PERL_5_8_6:1.1.1.9
	OPENBSD_3_6:1.9.0.2
	OPENBSD_3_6_BASE:1.9
	PERL_5_8_5:1.1.1.8
	PERL_5_8_3:1.1.1.7
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.21
date	2017.02.05.00.31.53;	author afresh1;	state Exp;
branches;
next	1.20;
commitid	cxJ08BvJA9Pt2PTM;

1.20
date	2015.04.25.19.14.37;	author afresh1;	state Exp;
branches;
next	1.19;
commitid	XRK22kO4se3v2i2I;

1.19
date	2014.11.17.20.56.47;	author afresh1;	state Exp;
branches;
next	1.18;
commitid	QP75iYx42Uo7mMxO;

1.18
date	2014.03.24.15.05.13;	author afresh1;	state Exp;
branches;
next	1.17;

1.17
date	2013.03.25.20.40.44;	author sthen;	state Exp;
branches;
next	1.16;

1.16
date	2010.09.24.15.06.41;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2009.10.12.18.24.21;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2008.09.29.17.35.58;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2007.01.31.14.48.04;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2006.03.28.19.22.58;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2006.01.02.23.37.10;	author brad;	state Exp;
branches;
next	1.10;

1.10
date	2005.01.15.21.30.20;	author millert;	state Exp;
branches
	1.10.2.1
	1.10.4.1;
next	1.9;

1.9
date	2004.08.09.18.08.55;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2004.04.07.21.32.59;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.21;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.18;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.34.53;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.04.09;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.51.04;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.48.57;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.11.44;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.11.44;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.37.33;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.08.41;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.22.12;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.14.48;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.43.32;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.04.07.21.12.52;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.08.09.17.45.43;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2005.01.15.21.16.29;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2006.03.28.18.47.34;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2008.09.29.17.18.07;	author millert;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2009.10.12.18.10.34;	author millert;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2010.09.24.14.48.25;	author millert;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2013.03.25.20.06.29;	author sthen;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	2014.03.24.14.58.46;	author afresh1;	state Exp;
branches;
next	1.1.1.16;

1.1.1.16
date	2014.11.17.20.52.38;	author afresh1;	state Exp;
branches;
next	1.1.1.17;
commitid	B31cAbBIXiCqnL97;

1.1.1.17
date	2015.04.25.19.10.11;	author afresh1;	state Exp;
branches;
next	;
commitid	Wpcs5S8qILgEZC7F;

1.10.2.1
date	2006.01.03.05.44.49;	author brad;	state Exp;
branches;
next	;

1.10.4.1
date	2006.01.03.04.22.40;	author brad;	state Exp;
branches;
next	;


desc
@@


1.21
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@/*    perl.h
 *
 *    Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
 *    2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

#ifndef H_PERL
#define H_PERL 1

#ifdef PERL_FOR_X2P
/*
 * This file is being used for x2p stuff.
 * Above symbol is defined via -D in 'x2p/Makefile.SH'
 * Decouple x2p stuff from some of perls more extreme eccentricities.
 */
#undef MULTIPLICITY
#undef USE_STDIO
#define USE_STDIO
#endif /* PERL_FOR_X2P */

#ifdef PERL_MICRO
#   include "uconfig.h"
#else
#   include "config.h"
#endif

/* NOTE 1: that with gcc -std=c89 the __STDC_VERSION__ is *not* defined
 * because the __STDC_VERSION__ became a thing only with C90.  Therefore,
 * with gcc, HAS_C99 will never become true as long as we use -std=c89.

 * NOTE 2: headers lie.  Do not expect that if HAS_C99 gets to be true,
 * all the C99 features are there and are correct. */
#if (defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L) || \
    defined(_STDC_C99) || defined(__c99)
#  define HAS_C99 1
#endif

/* See L<perlguts/"The Perl API"> for detailed notes on
 * PERL_IMPLICIT_CONTEXT and PERL_IMPLICIT_SYS */

/* Note that from here --> to <-- the same logic is
 * repeated in makedef.pl, so be certain to update
 * both places when editing. */

#ifdef USE_ITHREADS
#  if !defined(MULTIPLICITY)
#    define MULTIPLICITY
#  endif
#endif

#ifdef PERL_GLOBAL_STRUCT_PRIVATE
#  ifndef PERL_GLOBAL_STRUCT
#    define PERL_GLOBAL_STRUCT
#  endif
#endif

#ifdef PERL_GLOBAL_STRUCT
#  ifndef MULTIPLICITY
#    define MULTIPLICITY
#  endif
#endif

#ifdef MULTIPLICITY
#  ifndef PERL_IMPLICIT_CONTEXT
#    define PERL_IMPLICIT_CONTEXT
#  endif
#endif

/* undef WIN32 when building on Cygwin (for libwin32) - gph */
#ifdef __CYGWIN__
#   undef WIN32
#   undef _WIN32
#endif

#if defined(__SYMBIAN32__) || (defined(__VC32__) && defined(WINS))
#   ifndef SYMBIAN
#       define SYMBIAN
#   endif
#endif

#ifdef __SYMBIAN32__
#  include "symbian/symbian_proto.h"
#endif

/* Any stack-challenged places.  The limit varies (and often
 * is configurable), but using more than a kilobyte of stack
 * is usually dubious in these systems. */
#if defined(__SYMBIAN32__)
/* Symbian: need to work around the SDK features. *
 * On WINS: MS VC5 generates calls to _chkstk,         *
 * if a "large" stack frame is allocated.              *
 * gcc on MARM does not generate calls like these.     */
#   define USE_HEAP_INSTEAD_OF_STACK
#endif

/* Use the reentrant APIs like localtime_r and getpwent_r */
/* Win32 has naturally threadsafe libraries, no need to use any _r variants. */
#if defined(USE_ITHREADS) && !defined(USE_REENTRANT_API) && !defined(NETWARE) && !defined(WIN32) && !defined(PERL_DARWIN)
#   define USE_REENTRANT_API
#endif

/* <--- here ends the logic shared by perl.h and makedef.pl */

/* Microsoft Visual C++ 6.0 needs special treatment in numerous places */
#if defined(WIN32) && defined(_MSC_VER) && _MSC_VER >= 1200 && _MSC_VER < 1300
#  define USING_MSVC6
#endif

#undef START_EXTERN_C
#undef END_EXTERN_C
#undef EXTERN_C
#ifdef __cplusplus
#  define START_EXTERN_C extern "C" {
#  define END_EXTERN_C }
#  define EXTERN_C extern "C"
#else
#  define START_EXTERN_C
#  define END_EXTERN_C
#  define EXTERN_C extern
#endif

/* Fallback definitions in case we don't have definitions from config.h.
   This should only matter for systems that don't use Configure and
   haven't been modified to define PERL_STATIC_INLINE yet.
*/
#if !defined(PERL_STATIC_INLINE)
#  ifdef HAS_STATIC_INLINE
#    define PERL_STATIC_INLINE static inline
#  else
#    define PERL_STATIC_INLINE static
#  endif
#endif

#ifdef PERL_GLOBAL_STRUCT
#  ifndef PERL_GET_VARS
#    ifdef PERL_GLOBAL_STRUCT_PRIVATE
       EXTERN_C struct perl_vars* Perl_GetVarsPrivate();
#      define PERL_GET_VARS() Perl_GetVarsPrivate() /* see miniperlmain.c */
#    else
#      define PERL_GET_VARS() PL_VarsPtr
#    endif
#  endif
#endif

/* this used to be off by default, now its on, see perlio.h */
#define PERLIO_FUNCS_CONST

#define pVAR    struct perl_vars* my_vars PERL_UNUSED_DECL

#ifdef PERL_GLOBAL_STRUCT
#  define dVAR		pVAR    = (struct perl_vars*)PERL_GET_VARS()
#else
#  define dVAR		dNOOP
#endif

#ifdef PERL_IMPLICIT_CONTEXT
#  ifndef MULTIPLICITY
#    define MULTIPLICITY
#  endif
#  define tTHX	PerlInterpreter*
#  define pTHX  tTHX my_perl PERL_UNUSED_DECL
#  define aTHX	my_perl
#  define aTHXa(a) aTHX = (tTHX)a
#  ifdef PERL_GLOBAL_STRUCT
#    define dTHXa(a)	dVAR; pTHX = (tTHX)a
#  else
#    define dTHXa(a)	pTHX = (tTHX)a
#  endif
#  ifdef PERL_GLOBAL_STRUCT
#    define dTHX		dVAR; pTHX = PERL_GET_THX
#  else
#    define dTHX		pTHX = PERL_GET_THX
#  endif
#  define pTHX_		pTHX,
#  define aTHX_		aTHX,
#  define pTHX_1	2
#  define pTHX_2	3
#  define pTHX_3	4
#  define pTHX_4	5
#  define pTHX_5	6
#  define pTHX_6	7
#  define pTHX_7	8
#  define pTHX_8	9
#  define pTHX_9	10
#  define pTHX_12	13
#  if defined(DEBUGGING) && !defined(PERL_TRACK_MEMPOOL)
#    define PERL_TRACK_MEMPOOL
#  endif
#else
#  undef PERL_TRACK_MEMPOOL
#endif

#define STATIC static

#ifndef PERL_CORE
/* Do not use these macros. They were part of PERL_OBJECT, which was an
 * implementation of multiplicity using C++ objects. They have been left
 * here solely for the sake of XS code which has incorrectly
 * cargo-culted them.
 */
#define CPERLscope(x) x
#define CPERLarg void
#define CPERLarg_
#define _CPERLarg
#define PERL_OBJECT_THIS
#define _PERL_OBJECT_THIS
#define PERL_OBJECT_THIS_
#define CALL_FPTR(fptr) (*fptr)
#define MEMBER_TO_FPTR(name) name
#endif /* !PERL_CORE */

#define CALLRUNOPS  PL_runops

#define CALLREGCOMP(sv, flags) Perl_pregcomp(aTHX_ (sv),(flags))

#define CALLREGCOMP_ENG(prog, sv, flags) (prog)->comp(aTHX_ sv, flags)
#define CALLREGEXEC(prog,stringarg,strend,strbeg,minend,sv,data,flags) \
    RX_ENGINE(prog)->exec(aTHX_ (prog),(stringarg),(strend), \
        (strbeg),(minend),(sv),(data),(flags))
#define CALLREG_INTUIT_START(prog,sv,strbeg,strpos,strend,flags,data) \
    RX_ENGINE(prog)->intuit(aTHX_ (prog), (sv), (strbeg), (strpos), \
        (strend),(flags),(data))
#define CALLREG_INTUIT_STRING(prog) \
    RX_ENGINE(prog)->checkstr(aTHX_ (prog))

#define CALLREGFREE(prog) \
    Perl_pregfree(aTHX_ (prog))

#define CALLREGFREE_PVT(prog) \
    if(prog) RX_ENGINE(prog)->rxfree(aTHX_ (prog))

#define CALLREG_NUMBUF_FETCH(rx,paren,usesv)                                \
    RX_ENGINE(rx)->numbered_buff_FETCH(aTHX_ (rx),(paren),(usesv))

#define CALLREG_NUMBUF_STORE(rx,paren,value) \
    RX_ENGINE(rx)->numbered_buff_STORE(aTHX_ (rx),(paren),(value))

#define CALLREG_NUMBUF_LENGTH(rx,sv,paren)                              \
    RX_ENGINE(rx)->numbered_buff_LENGTH(aTHX_ (rx),(sv),(paren))

#define CALLREG_NAMED_BUFF_FETCH(rx, key, flags) \
    RX_ENGINE(rx)->named_buff(aTHX_ (rx), (key), NULL, ((flags) | RXapif_FETCH))

#define CALLREG_NAMED_BUFF_STORE(rx, key, value, flags) \
    RX_ENGINE(rx)->named_buff(aTHX_ (rx), (key), (value), ((flags) | RXapif_STORE))

#define CALLREG_NAMED_BUFF_DELETE(rx, key, flags) \
    RX_ENGINE(rx)->named_buff(aTHX_ (rx),(key), NULL, ((flags) | RXapif_DELETE))

#define CALLREG_NAMED_BUFF_CLEAR(rx, flags) \
    RX_ENGINE(rx)->named_buff(aTHX_ (rx), NULL, NULL, ((flags) | RXapif_CLEAR))

#define CALLREG_NAMED_BUFF_EXISTS(rx, key, flags) \
    RX_ENGINE(rx)->named_buff(aTHX_ (rx), (key), NULL, ((flags) | RXapif_EXISTS))

#define CALLREG_NAMED_BUFF_FIRSTKEY(rx, flags) \
    RX_ENGINE(rx)->named_buff_iter(aTHX_ (rx), NULL, ((flags) | RXapif_FIRSTKEY))

#define CALLREG_NAMED_BUFF_NEXTKEY(rx, lastkey, flags) \
    RX_ENGINE(rx)->named_buff_iter(aTHX_ (rx), (lastkey), ((flags) | RXapif_NEXTKEY))

#define CALLREG_NAMED_BUFF_SCALAR(rx, flags) \
    RX_ENGINE(rx)->named_buff(aTHX_ (rx), NULL, NULL, ((flags) | RXapif_SCALAR))

#define CALLREG_NAMED_BUFF_COUNT(rx) \
    RX_ENGINE(rx)->named_buff(aTHX_ (rx), NULL, NULL, RXapif_REGNAMES_COUNT)

#define CALLREG_NAMED_BUFF_ALL(rx, flags) \
    RX_ENGINE(rx)->named_buff(aTHX_ (rx), NULL, NULL, flags)

#define CALLREG_PACKAGE(rx) \
    RX_ENGINE(rx)->qr_package(aTHX_ (rx))

#if defined(USE_ITHREADS)
#define CALLREGDUPE(prog,param) \
    Perl_re_dup(aTHX_ (prog),(param))

#define CALLREGDUPE_PVT(prog,param) \
    (prog ? RX_ENGINE(prog)->dupe(aTHX_ (prog),(param)) \
          : (REGEXP *)NULL)
#endif





/*
 * Because of backward compatibility reasons the PERL_UNUSED_DECL
 * cannot be changed from postfix to PERL_UNUSED_DECL(x).  Sigh.
 *
 * Note that there are C compilers such as MetroWerks CodeWarrior
 * which do not have an "inlined" way (like the gcc __attribute__) of
 * marking unused variables (they need e.g. a #pragma) and therefore
 * cpp macros like PERL_UNUSED_DECL cannot work for this purpose, even
 * if it were PERL_UNUSED_DECL(x), which it cannot be (see above).
 *
 */

#if defined(__SYMBIAN32__) && defined(__GNUC__)
#  ifdef __cplusplus
#    define PERL_UNUSED_DECL
#  else
#    define PERL_UNUSED_DECL __attribute__((unused))
#  endif
#endif

#ifndef PERL_UNUSED_DECL
#  if defined(HASATTRIBUTE_UNUSED) && (!defined(__cplusplus) || (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)))
#    define PERL_UNUSED_DECL __attribute__unused__
#  else
#    define PERL_UNUSED_DECL
#  endif
#endif

/* gcc -Wall:
 * for silencing unused variables that are actually used most of the time,
 * but we cannot quite get rid of, such as "ax" in PPCODE+noargs xsubs,
 * or variables/arguments that are used only in certain configurations.
 */
#ifndef PERL_UNUSED_ARG
#  if defined(lint) && defined(S_SPLINT_S) /* www.splint.org */
#    include <note.h>
#    define PERL_UNUSED_ARG(x) NOTE(ARGUNUSED(x))
#  else
#    define PERL_UNUSED_ARG(x) ((void)sizeof(x))
#  endif
#endif
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(x) ((void)sizeof(x))
#endif

#if defined(USE_ITHREADS) || defined(PERL_GLOBAL_STRUCT)
#  define PERL_UNUSED_CONTEXT PERL_UNUSED_ARG(my_perl)
#else
#  define PERL_UNUSED_CONTEXT
#endif

/* gcc (-ansi) -pedantic doesn't allow gcc statement expressions,
 * g++ allows them but seems to have problems with them
 * (insane errors ensue).
 * g++ does not give insane errors now (RMB 2008-01-30, gcc 4.2.2).
 */
#if defined(PERL_GCC_PEDANTIC) || \
    (defined(__GNUC__) && defined(__cplusplus) && \
	((__GNUC__ < 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ < 2))))
#  ifndef PERL_GCC_BRACE_GROUPS_FORBIDDEN
#    define PERL_GCC_BRACE_GROUPS_FORBIDDEN
#  endif
#endif

/* Use PERL_UNUSED_RESULT() to suppress the warnings about unused results
 * of function calls, e.g. PERL_UNUSED_RESULT(foo(a, b)).
 *
 * The main reason for this is that the combination of gcc -Wunused-result
 * (part of -Wall) and the __attribute__((warn_unused_result)) cannot
 * be silenced with casting to void.  This causes trouble when the system
 * header files use the attribute.
 *
 * Use PERL_UNUSED_RESULT sparingly, though, since usually the warning
 * is there for a good reason: you might lose success/failure information,
 * or leak resources, or changes in resources.
 *
 * But sometimes you just want to ignore the return value, e.g. on
 * codepaths soon ending up in abort, or in "best effort" attempts,
 * or in situations where there is no good way to handle failures.
 *
 * Sometimes PERL_UNUSED_RESULT might not be the most natural way:
 * another possibility is that you can capture the return value
 * and use PERL_UNUSED_VAR on that.
 *
 * The __typeof__() is used instead of typeof() since typeof() is not
 * available under strict C89, and because of compilers masquerading
 * as gcc (clang and icc), we want exactly the gcc extension
 * __typeof__ and nothing else.
 */
#ifndef PERL_UNUSED_RESULT
#  if defined(__GNUC__) && defined(HASATTRIBUTE_WARN_UNUSED_RESULT)
#    define PERL_UNUSED_RESULT(v) STMT_START { __typeof__(v) z = (v); (void)sizeof(z); } STMT_END
#  else
#    define PERL_UNUSED_RESULT(v) ((void)(v))
#  endif
#endif

/* on gcc (and clang), specify that a warning should be temporarily
 * ignored; e.g.
 *
 *    GCC_DIAG_IGNORE(-Wmultichar);
 *    char b = 'ab';
 *    GCC_DIAG_RESTORE;
 *
 * based on http://dbp-consulting.com/tutorials/SuppressingGCCWarnings.html
 *
 * Note that "pragma GCC diagnostic push/pop" was added in GCC 4.6, Mar 2011;
 * clang only pretends to be GCC 4.2, but still supports push/pop.
 *
 * Note on usage: on non-gcc (or lookalike, like clang) compilers
 * one cannot use these at file (global) level without warnings
 * since they are defined as empty, which leads into the terminating
 * semicolon being left alone on a line:
 * ;
 * which makes compilers mildly cranky.  Therefore at file level one
 * should use the GCC_DIAG_IGNORE and GCC_DIAG_RESTORE_FILE *without*
 * the semicolons.
 *
 * (A dead-on-arrival solution would be to try to define the macros as
 * NOOP or dNOOP, those don't work both inside functions and outside.)
 */

#if defined(__clang__) || defined(__clang) || \
       (defined( __GNUC__) && ((__GNUC__ * 100) + __GNUC_MINOR__) >= 406)
#  define GCC_DIAG_PRAGMA(x) _Pragma (#x)
/* clang has "clang diagnostic" pragmas, but also understands gcc. */
#  define GCC_DIAG_IGNORE(x) _Pragma("GCC diagnostic push") \
                             GCC_DIAG_PRAGMA(GCC diagnostic ignored #x)
#  define GCC_DIAG_RESTORE   _Pragma("GCC diagnostic pop")
#else
#  define GCC_DIAG_IGNORE(w)
#  define GCC_DIAG_RESTORE
#endif
/* for clang specific pragmas */
#if defined(__clang__) || defined(__clang)
#  define CLANG_DIAG_PRAGMA(x) _Pragma (#x)
#  define CLANG_DIAG_IGNORE(x) _Pragma("clang diagnostic push") \
                               CLANG_DIAG_PRAGMA(clang diagnostic ignored #x)
#  define CLANG_DIAG_RESTORE   _Pragma("clang diagnostic pop")
#else
#  define CLANG_DIAG_IGNORE(w)
#  define CLANG_DIAG_RESTORE
#endif

#define NOOP /*EMPTY*/(void)0
/* cea2e8a9dd23747f accidentally lost the comment originally from the first
   check in of thread.h, explaining why we need dNOOP at all:  */
/* Rats: if dTHR is just blank then the subsequent ";" throws an error */
/* Declaring a *function*, instead of a variable, ensures that we don't rely
   on being able to suppress "unused" warnings.  */
#ifdef __cplusplus
#define dNOOP (void)0
#else
#define dNOOP extern int Perl___notused(void)
#endif

#ifndef pTHX
/* Don't bother defining tTHX ; using it outside
 * code guarded by PERL_IMPLICIT_CONTEXT is an error.
 */
#  define pTHX		void
#  define pTHX_
#  define aTHX
#  define aTHX_
#  define aTHXa(a)      NOOP
#  define dTHXa(a)	dNOOP
#  define dTHX		dNOOP
#  define pTHX_1	1	
#  define pTHX_2	2
#  define pTHX_3	3
#  define pTHX_4	4
#  define pTHX_5	5
#  define pTHX_6	6
#  define pTHX_7	7
#  define pTHX_8	8
#  define pTHX_9	9
#  define pTHX_12	12
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif

/* these are only defined for compatibility; should not be used internally */
#if !defined(pTHXo) && !defined(PERL_CORE)
#  define pTHXo		pTHX
#  define pTHXo_	pTHX_
#  define aTHXo		aTHX
#  define aTHXo_	aTHX_
#  define dTHXo		dTHX
#  define dTHXoa(x)	dTHXa(x)
#endif

#ifndef pTHXx
#  define pTHXx		PerlInterpreter *my_perl
#  define pTHXx_	pTHXx,
#  define aTHXx		my_perl
#  define aTHXx_	aTHXx,
#  define dTHXx		dTHX
#endif

/* Under PERL_IMPLICIT_SYS (used in Windows for fork emulation)
 * PerlIO_foo() expands to PL_StdIO->pFOO(PL_StdIO, ...).
 * dTHXs is therefore needed for all functions using PerlIO_foo(). */
#ifdef PERL_IMPLICIT_SYS
#  ifdef PERL_GLOBAL_STRUCT_PRIVATE
#    define dTHXs		dVAR; dTHX
#  else
#    define dTHXs		dTHX
#  endif
#else
#  ifdef PERL_GLOBAL_STRUCT_PRIVATE
#    define dTHXs		dVAR
#  else
#    define dTHXs		dNOOP
#  endif
#endif

#if defined(__GNUC__) && !defined(PERL_GCC_BRACE_GROUPS_FORBIDDEN) && !defined(__cplusplus)
#  ifndef PERL_USE_GCC_BRACE_GROUPS
#    define PERL_USE_GCC_BRACE_GROUPS
#  endif
#endif

/*
 * STMT_START { statements; } STMT_END;
 * can be used as a single statement, as in
 * if (x) STMT_START { ... } STMT_END; else ...
 *
 * Trying to select a version that gives no warnings...
 */
#if !(defined(STMT_START) && defined(STMT_END))
# ifdef PERL_USE_GCC_BRACE_GROUPS
#   define STMT_START	(void)(	/* gcc supports "({ STATEMENTS; })" */
#   define STMT_END	)
# else
#   define STMT_START	do
#   define STMT_END	while (0)
# endif
#endif

#ifndef BYTEORDER  /* Should never happen -- byteorder is in config.h */
#   define BYTEORDER 0x1234
#endif

/* Overall memory policy? */
#ifndef CONSERVATIVE
#   define LIBERAL 1
#endif

#if 'A' == 65 && 'I' == 73 && 'J' == 74 && 'Z' == 90
#define ASCIIish
#else
#undef  ASCIIish
#endif

/*
 * The following contortions are brought to you on behalf of all the
 * standards, semi-standards, de facto standards, not-so-de-facto standards
 * of the world, as well as all the other botches anyone ever thought of.
 * The basic theory is that if we work hard enough here, the rest of the
 * code can be a lot prettier.  Well, so much for theory.  Sorry, Henry...
 */

/* define this once if either system, instead of cluttering up the src */
#if defined(MSDOS) || defined(WIN32) || defined(NETWARE)
#define DOSISH 1
#endif

#if defined(__STDC__) || defined(_AIX) || defined(__stdc__) || defined(__cplusplus) || defined(NETWARE) || defined(__SYMBIAN32__)
# define STANDARD_C 1
#endif

#if defined(__cplusplus) || defined(WIN32) || defined(__sgi) || defined(__EMX__) || defined(__QNX__) || defined(NETWARE) || defined(PERL_MICRO)
# define DONT_DECLARE_STD 1
#endif

#if defined(HASVOLATILE) || defined(STANDARD_C)
#	define VOL volatile
#else
#   define VOL
#endif

/* By compiling a perl with -DNO_TAINT_SUPPORT or -DSILENT_NO_TAINT_SUPPORT,
 * you get a perl without taint support, but doubtlessly with a lesser
 * degree of support. Do not do so unless you know exactly what it means
 * technically, have a good reason to do so, and know exactly how the
 * perl will be used. perls with -DSILENT_NO_TAINT_SUPPORT are considered
 * a potential security risk due to flat out ignoring the security-relevant
 * taint flags. This being said, a perl without taint support compiled in
 * has marginal run-time performance benefits.
 * SILENT_NO_TAINT_SUPPORT implies NO_TAINT_SUPPORT.
 * SILENT_NO_TAINT_SUPPORT is the same as NO_TAINT_SUPPORT except it
 * silently ignores -t/-T instead of throwing an exception.
 *
 * DANGER! Using NO_TAINT_SUPPORT or SILENT_NO_TAINT_SUPPORT
 *         voids your nonexistent warranty!
 */
#if defined(SILENT_NO_TAINT_SUPPORT) && !defined(NO_TAINT_SUPPORT)
#  define NO_TAINT_SUPPORT 1
#endif

/* NO_TAINT_SUPPORT can be set to transform virtually all taint-related
 * operations into no-ops for a very modest speed-up. Enable only if you
 * know what you're doing: tests and CPAN modules' tests are bound to fail.
 */
#ifdef NO_TAINT_SUPPORT
#   define TAINT		NOOP
#   define TAINT_NOT		NOOP
#   define TAINT_IF(c)		NOOP
#   define TAINT_ENV()		NOOP
#   define TAINT_PROPER(s)	NOOP
#   define TAINT_set(s)		NOOP
#   define TAINT_get		0
#   define TAINTING_get		0
#   define TAINTING_set(s)	NOOP
#   define TAINT_WARN_get       0
#   define TAINT_WARN_set(s)    NOOP
#else
#   define TAINT		(PL_tainted = PL_tainting)
#   define TAINT_NOT	(PL_tainted = FALSE)
#   define TAINT_IF(c)	if (UNLIKELY(c)) { PL_tainted = PL_tainting; }
#   define TAINT_ENV()	if (UNLIKELY(PL_tainting)) { taint_env(); }
#   define TAINT_PROPER(s)	if (UNLIKELY(PL_tainting)) { taint_proper(NULL, s); }
#   define TAINT_set(s)		(PL_tainted = (s))
#   define TAINT_get		(PL_tainted)
#   define TAINTING_get		(PL_tainting)
#   define TAINTING_set(s)	(PL_tainting = (s))
#   define TAINT_WARN_get       (PL_taint_warn)
#   define TAINT_WARN_set(s)    (PL_taint_warn = (s))
#endif

/* flags used internally only within pp_subst and pp_substcont */
#ifdef PERL_CORE
#  define SUBST_TAINT_STR      1	/* string tainted */
#  define SUBST_TAINT_PAT      2	/* pattern tainted */
#  define SUBST_TAINT_REPL     4	/* replacement tainted */
#  define SUBST_TAINT_RETAINT  8	/* use re'taint' in scope */
#  define SUBST_TAINT_BOOLRET 16	/* return is boolean (don't taint) */
#endif

/* XXX All process group stuff is handled in pp_sys.c.  Should these
   defines move there?  If so, I could simplify this a lot. --AD  9/96.
*/
/* Process group stuff changed from traditional BSD to POSIX.
   perlfunc.pod documents the traditional BSD-style syntax, so we'll
   try to preserve that, if possible.
*/
#ifdef HAS_SETPGID
#  define BSD_SETPGRP(pid, pgrp)	setpgid((pid), (pgrp))
#else
#  if defined(HAS_SETPGRP) && defined(USE_BSD_SETPGRP)
#    define BSD_SETPGRP(pid, pgrp)	setpgrp((pid), (pgrp))
#  else
#    ifdef HAS_SETPGRP2  /* DG/UX */
#      define BSD_SETPGRP(pid, pgrp)	setpgrp2((pid), (pgrp))
#    endif
#  endif
#endif
#if defined(BSD_SETPGRP) && !defined(HAS_SETPGRP)
#  define HAS_SETPGRP  /* Well, effectively it does . . . */
#endif

/* getpgid isn't POSIX, but at least Solaris and Linux have it, and it makes
    our life easier :-) so we'll try it.
*/
#ifdef HAS_GETPGID
#  define BSD_GETPGRP(pid)		getpgid((pid))
#else
#  if defined(HAS_GETPGRP) && defined(USE_BSD_GETPGRP)
#    define BSD_GETPGRP(pid)		getpgrp((pid))
#  else
#    ifdef HAS_GETPGRP2  /* DG/UX */
#      define BSD_GETPGRP(pid)		getpgrp2((pid))
#    endif
#  endif
#endif
#if defined(BSD_GETPGRP) && !defined(HAS_GETPGRP)
#  define HAS_GETPGRP  /* Well, effectively it does . . . */
#endif

/* These are not exact synonyms, since setpgrp() and getpgrp() may
   have different behaviors, but perl.h used to define USE_BSDPGRP
   (prior to 5.003_05) so some extension might depend on it.
*/
#if defined(USE_BSD_SETPGRP) || defined(USE_BSD_GETPGRP)
#  ifndef USE_BSDPGRP
#    define USE_BSDPGRP
#  endif
#endif

/* HP-UX 10.X CMA (Common Multithreaded Architecture) insists that
   pthread.h must be included before all other header files.
*/
#if defined(USE_ITHREADS) && defined(PTHREAD_H_FIRST) && defined(I_PTHREAD)
#  include <pthread.h>
#endif

#include <sys/types.h>

#ifdef __cplusplus
#  ifndef I_STDARG
#    define I_STDARG 1
#  endif
#endif

/* EVC 4 SDK headers includes a bad definition of MB_CUR_MAX in stdlib.h
  which is included from stdarg.h. Bad definition not present in SD 2008
  SDK headers. wince.h is not yet included, so we cant fix this from there
  since by then MB_CUR_MAX will be defined from stdlib.h.
  cewchar.h includes a correct definition of MB_CUR_MAX and it is copied here
  since cewchar.h can't be included this early */
#if defined(UNDER_CE) && (_MSC_VER < 1300)
#  define MB_CUR_MAX 1
#endif
#ifdef I_STDARG
#  include <stdarg.h>
#else
#  ifdef I_VARARGS
#    include <varargs.h>
#  endif
#endif

#ifdef I_STDINT
# include <stdint.h>
#endif

#include <ctype.h>

#ifdef METHOD 	/* Defined by OSF/1 v3.0 by ctype.h */
#undef METHOD
#endif

#ifdef PERL_MICRO
#   define NO_LOCALE
#endif

#ifdef I_LOCALE
#   include <locale.h>
#endif

#if !defined(NO_LOCALE) && defined(HAS_SETLOCALE)
#   define USE_LOCALE
#   define HAS_SKIP_LOCALE_INIT /* Solely for XS code to test for this
                                   capability */
#   if !defined(NO_LOCALE_COLLATE) && defined(LC_COLLATE) \
       && defined(HAS_STRXFRM)
#	define USE_LOCALE_COLLATE
#   endif
#   if !defined(NO_LOCALE_CTYPE) && defined(LC_CTYPE)
#	define USE_LOCALE_CTYPE
#   endif
#   if !defined(NO_LOCALE_NUMERIC) && defined(LC_NUMERIC)
#	define USE_LOCALE_NUMERIC
#   endif
#   if !defined(NO_LOCALE_MESSAGES) && defined(LC_MESSAGES)
#	define USE_LOCALE_MESSAGES
#   endif
#   if !defined(NO_LOCALE_MONETARY) && defined(LC_MONETARY)
#	define USE_LOCALE_MONETARY
#   endif
#   if !defined(NO_LOCALE_TIME) && defined(LC_TIME)
#	define USE_LOCALE_TIME
#   endif
#   ifndef WIN32    /* No wrapper except on Windows */
#       define my_setlocale(a,b) setlocale(a,b)
#   endif
#endif /* !NO_LOCALE && HAS_SETLOCALE */

/* Is $^ENCODING set, or are we under the encoding pragma? */
#define IN_ENCODING UNLIKELY(PL_encoding                                      \
                             || (PL_lex_encoding && _get_encoding() != NULL))

#include <setjmp.h>

#ifdef I_SYS_PARAM
#   ifdef PARAM_NEEDS_TYPES
#	include <sys/types.h>
#   endif
#   include <sys/param.h>
#endif

/* On BSD-derived systems, <sys/param.h> defines BSD to a year-month
   value something like 199306.  This may be useful if no more-specific
   feature test is available.
*/
#if defined(BSD)
#   ifndef BSDish
#       define BSDish
#   endif
#endif

/* Use all the "standard" definitions? */
#if defined(STANDARD_C) && defined(I_STDLIB)
#   include <stdlib.h>
#endif

/* If this causes problems, set i_unistd=undef in the hint file.  */
#ifdef I_UNISTD
#    if defined(__amigaos4__)
#        ifdef I_NETINET_IN
#            include <netinet/in.h>
#        endif
#   endif
#   include <unistd.h>
#   if defined(__amigaos4__)
/* Under AmigaOS 4 newlib.library provides an environ.  However using
 * it doesn't give us enough control over inheritance of variables by
 * subshells etc. so replace with custom version based on abc-shell
 * code. */
extern char **myenviron;
#       undef environ
#       define environ myenviron
#   endif
#endif

/* for WCOREDUMP */
#ifdef I_SYS_WAIT
#   include <sys/wait.h>
#endif

#ifdef __SYMBIAN32__
#   undef _SC_ARG_MAX /* Symbian has _SC_ARG_MAX but no sysconf() */
#endif

#if defined(HAS_SYSCALL) && !defined(HAS_SYSCALL_PROTO)
EXTERN_C int syscall(int, ...);
#endif

#if defined(HAS_USLEEP) && !defined(HAS_USLEEP_PROTO)
EXTERN_C int usleep(unsigned int);
#endif

#ifdef PERL_CORE

/* macros for correct constant construction */
# if INTSIZE >= 2
#  define U16_CONST(x) ((U16)x##U)
# else
#  define U16_CONST(x) ((U16)x##UL)
# endif

# if INTSIZE >= 4
#  define U32_CONST(x) ((U32)x##U)
# else
#  define U32_CONST(x) ((U32)x##UL)
# endif

# ifdef HAS_QUAD
#  if INTSIZE >= 8
#   define U64_CONST(x) ((U64)x##U)
#  elif LONGSIZE >= 8
#   define U64_CONST(x) ((U64)x##UL)
#  elif QUADKIND == QUAD_IS_LONG_LONG
#   define U64_CONST(x) ((U64)x##ULL)
#  elif QUADKIND == QUAD_IS___INT64
#   define U64_CONST(x) ((U64)x##UI64)
#  else /* best guess we can make */
#   define U64_CONST(x) ((U64)x##UL)
#  endif
# endif

/* byte-swapping functions for big-/little-endian conversion */
# define _swab_16_(x) ((U16)( \
         (((U16)(x) & U16_CONST(0x00ff)) << 8) | \
         (((U16)(x) & U16_CONST(0xff00)) >> 8) ))

# define _swab_32_(x) ((U32)( \
         (((U32)(x) & U32_CONST(0x000000ff)) << 24) | \
         (((U32)(x) & U32_CONST(0x0000ff00)) <<  8) | \
         (((U32)(x) & U32_CONST(0x00ff0000)) >>  8) | \
         (((U32)(x) & U32_CONST(0xff000000)) >> 24) ))

# ifdef HAS_QUAD
#  define _swab_64_(x) ((U64)( \
          (((U64)(x) & U64_CONST(0x00000000000000ff)) << 56) | \
          (((U64)(x) & U64_CONST(0x000000000000ff00)) << 40) | \
          (((U64)(x) & U64_CONST(0x0000000000ff0000)) << 24) | \
          (((U64)(x) & U64_CONST(0x00000000ff000000)) <<  8) | \
          (((U64)(x) & U64_CONST(0x000000ff00000000)) >>  8) | \
          (((U64)(x) & U64_CONST(0x0000ff0000000000)) >> 24) | \
          (((U64)(x) & U64_CONST(0x00ff000000000000)) >> 40) | \
          (((U64)(x) & U64_CONST(0xff00000000000000)) >> 56) ))
# endif

/* The old value was hard coded at 1008. (4096-16) seems to be a bit faster,
   at least on FreeBSD.  YMMV, so experiment.  */
#ifndef PERL_ARENA_SIZE
#define PERL_ARENA_SIZE 4080
#endif

/* Maximum level of recursion */
#ifndef PERL_SUB_DEPTH_WARN
#define PERL_SUB_DEPTH_WARN 100
#endif

#endif /* PERL_CORE */

/* We no longer default to creating a new SV for GvSV.
   Do this before embed.  */
#ifndef PERL_CREATE_GVSV
#  ifndef PERL_DONT_CREATE_GVSV
#    define PERL_DONT_CREATE_GVSV
#  endif
#endif

#if !defined(HAS_WAITPID) && !defined(HAS_WAIT4) || defined(HAS_WAITPID_RUNTIME)
#define PERL_USES_PL_PIDSTATUS
#endif

#if !defined(OS2) && !defined(WIN32) && !defined(DJGPP) && !defined(__SYMBIAN32__)
#define PERL_DEFAULT_DO_EXEC3_IMPLEMENTATION
#endif

#define MEM_SIZE Size_t

/* Round all values passed to malloc up, by default to a multiple of
   sizeof(size_t)
*/
#ifndef PERL_STRLEN_ROUNDUP_QUANTUM
#define PERL_STRLEN_ROUNDUP_QUANTUM Size_t_size
#endif

/* sv_grow() will expand strings by at least a certain percentage of
   the previously *used* length to avoid excessive calls to realloc().
   The default is 25% of the current length.
*/
#ifndef PERL_STRLEN_EXPAND_SHIFT
#  define PERL_STRLEN_EXPAND_SHIFT 2
#endif

#if defined(STANDARD_C) && defined(I_STDDEF) && !defined(PERL_GCC_PEDANTIC)
#   include <stddef.h>
#   define STRUCT_OFFSET(s,m)  offsetof(s,m)
#else
#   define STRUCT_OFFSET(s,m)  (Size_t)(&(((s *)0)->m))
#endif

/* ptrdiff_t is C11, so undef it under pedantic builds */
#ifdef PERL_GCC_PEDANTIC
#   undef HAS_PTRDIFF_T
#endif

#ifndef __SYMBIAN32__
#  if defined(I_STRING) || defined(__cplusplus)
#     include <string.h>
#  else
#     include <strings.h>
#  endif
#endif

/* This comes after <stdlib.h> so we don't try to change the standard
 * library prototypes; we'll use our own in proto.h instead. */

#ifdef MYMALLOC
#  ifdef PERL_POLLUTE_MALLOC
#   ifndef PERL_EXTMALLOC_DEF
#    define Perl_malloc		malloc
#    define Perl_calloc		calloc
#    define Perl_realloc	realloc
#    define Perl_mfree		free
#   endif
#  else
#    define EMBEDMYMALLOC	/* for compatibility */
#  endif

#  define safemalloc  Perl_malloc
#  define safecalloc  Perl_calloc
#  define saferealloc Perl_realloc
#  define safefree    Perl_mfree
#  define CHECK_MALLOC_TOO_LATE_FOR_(code)	STMT_START {		\
	if (!PL_tainting && MallocCfg_ptr[MallocCfg_cfg_env_read])	\
		code;							\
    } STMT_END
#  define CHECK_MALLOC_TOO_LATE_FOR(ch)				\
	CHECK_MALLOC_TOO_LATE_FOR_(MALLOC_TOO_LATE_FOR(ch))
#  define panic_write2(s)		write(2, s, strlen(s))
#  define CHECK_MALLOC_TAINT(newval)				\
	CHECK_MALLOC_TOO_LATE_FOR_(				\
		if (newval) {					\
		  PERL_UNUSED_RESULT(panic_write2("panic: tainting with $ENV{PERL_MALLOC_OPT}\n"));\
		  exit(1); })
#  define MALLOC_CHECK_TAINT(argc,argv,env)	STMT_START {	\
	if (doing_taint(argc,argv,env)) {			\
		MallocCfg_ptr[MallocCfg_skip_cfg_env] = 1;	\
    }} STMT_END;
#else  /* MYMALLOC */
#  define safemalloc  safesysmalloc
#  define safecalloc  safesyscalloc
#  define saferealloc safesysrealloc
#  define safefree    safesysfree
#  define CHECK_MALLOC_TOO_LATE_FOR(ch)		((void)0)
#  define CHECK_MALLOC_TAINT(newval)		((void)0)
#  define MALLOC_CHECK_TAINT(argc,argv,env)
#endif /* MYMALLOC */

/* diag_listed_as: "-T" is on the #! line, it must also be used on the command line */
#define TOO_LATE_FOR_(ch,what)	Perl_croak(aTHX_ "\"-%c\" is on the #! line, it must also be used on the command line%s", (char)(ch), what)
#define TOO_LATE_FOR(ch)	TOO_LATE_FOR_(ch, "")
#define MALLOC_TOO_LATE_FOR(ch)	TOO_LATE_FOR_(ch, " with $ENV{PERL_MALLOC_OPT}")
#define MALLOC_CHECK_TAINT2(argc,argv)	MALLOC_CHECK_TAINT(argc,argv,NULL)

#if !defined(HAS_STRCHR) && defined(HAS_INDEX) && !defined(strchr)
#define strchr index
#define strrchr rindex
#endif

#ifdef I_MEMORY
#  include <memory.h>
#endif

#ifdef HAS_MEMCPY
#  if !defined(STANDARD_C) && !defined(I_STRING) && !defined(I_MEMORY)
#    ifndef memcpy
        extern char * memcpy (char*, char*, int);
#    endif
#  endif
#else
#   ifndef memcpy
#	define memcpy(d,s,l) my_bcopy(s,d,l)
#   endif
#endif /* HAS_MEMCPY */

#ifdef HAS_MEMSET
#  if !defined(STANDARD_C) && !defined(I_STRING) && !defined(I_MEMORY)
#    ifndef memset
	extern char *memset (char*, int, int);
#    endif
#  endif
#else
#  undef  memset
#  define memset(d,c,l) my_memset(d,c,l)
#endif /* HAS_MEMSET */

#if !defined(HAS_MEMMOVE) && !defined(memmove)
#   if defined(HAS_MEMCPY) && defined(HAS_SAFE_MEMCPY)
#	define memmove(d,s,l) memcpy(d,s,l)
#   else
#	define memmove(d,s,l) my_bcopy(s,d,l)
#   endif
#endif

#if defined(mips) && defined(ultrix) && !defined(__STDC__)
#   undef HAS_MEMCMP
#endif

#if defined(HAS_MEMCMP) && defined(HAS_SANE_MEMCMP)
#  if !defined(STANDARD_C) && !defined(I_STRING) && !defined(I_MEMORY)
#    ifndef memcmp
	extern int memcmp (char*, char*, int);
#    endif
#  endif
#else
#   ifndef memcmp
#	define memcmp 	my_memcmp
#   endif
#endif /* HAS_MEMCMP && HAS_SANE_MEMCMP */

#ifndef memzero
#   ifdef HAS_MEMSET
#	define memzero(d,l) memset(d,0,l)
#   else
#	ifdef HAS_BZERO
#	    define memzero(d,l) bzero(d,l)
#	else
#	    define memzero(d,l) my_bzero(d,l)
#	endif
#   endif
#endif

#ifndef PERL_MICRO
#ifndef memchr
#   ifndef HAS_MEMCHR
#       define memchr(s,c,n) ninstr((char*)(s), ((char*)(s)) + n, &(c), &(c) + 1)
#   endif
#endif
#endif

#ifndef HAS_BCMP
#   ifndef bcmp
#	define bcmp(s1,s2,l) memcmp(s1,s2,l)
#   endif
#endif /* !HAS_BCMP */

#ifdef I_NETINET_IN
#   include <netinet/in.h>
#endif

#ifdef I_ARPA_INET
#   include <arpa/inet.h>
#endif

#ifdef I_SYS_STAT
#   include <sys/stat.h>
#endif

/* Microsoft VC's sys/stat.h defines all S_Ixxx macros except S_IFIFO.
   This definition should ideally go into win32/win32.h, but S_IFIFO is
   used later here in perl.h before win32/win32.h is being included. */
#if !defined(S_IFIFO) && defined(_S_IFIFO)
#   define S_IFIFO _S_IFIFO
#endif

/* The stat macros for Unisoft System V/88 (and derivatives
   like UTekV) are broken, sometimes giving false positives.  Undefine
   them here and let the code below set them to proper values.

   The ghs macro stands for GreenHills Software C-1.8.5 which
   is the C compiler for sysV88 and the various derivatives.
   This header file bug is corrected in gcc-2.5.8 and later versions.
   --Kaveh Ghazi (ghazi@@noc.rutgers.edu) 10/3/94.  */

#if defined(m88k) && defined(ghs)
#   undef S_ISDIR
#   undef S_ISCHR
#   undef S_ISBLK
#   undef S_ISREG
#   undef S_ISFIFO
#   undef S_ISLNK
#endif

#ifdef I_TIME
#   include <time.h>
#endif

#ifdef I_SYS_TIME
#   ifdef I_SYS_TIME_KERNEL
#	define KERNEL
#   endif
#   include <sys/time.h>
#   ifdef I_SYS_TIME_KERNEL
#	undef KERNEL
#   endif
#endif

#if defined(HAS_TIMES) && defined(I_SYS_TIMES)
#    include <sys/times.h>
#endif

#if defined(HAS_STRERROR) && (!defined(HAS_MKDIR) || !defined(HAS_RMDIR))
#   undef HAS_STRERROR
#endif

#include <errno.h>

#if defined(WIN32) && defined(PERL_IMPLICIT_SYS)
#  define WIN32SCK_IS_STDSCK		/* don't pull in custom wsock layer */
#endif

#if defined(HAS_SOCKET) && !defined(WIN32) /* WIN32 handles sockets via win32.h */
# include <sys/socket.h>
# if defined(USE_SOCKS) && defined(I_SOCKS)
#   if !defined(INCLUDE_PROTOTYPES)
#       define INCLUDE_PROTOTYPES /* for <socks.h> */
#       define PERL_SOCKS_NEED_PROTOTYPES
#   endif
#   include <socks.h>
#   ifdef PERL_SOCKS_NEED_PROTOTYPES /* keep cpp space clean */
#       undef INCLUDE_PROTOTYPES
#       undef PERL_SOCKS_NEED_PROTOTYPES
#   endif
# endif
# ifdef I_NETDB
#  ifdef NETWARE
#   include<stdio.h>
#  endif
#  include <netdb.h>
# endif
# ifndef ENOTSOCK
#  ifdef I_NET_ERRNO
#   include <net/errno.h>
#  endif
# endif
#endif

/* sockatmark() is so new (2001) that many places might have it hidden
 * behind some -D_BLAH_BLAH_SOURCE guard.  The __THROW magic is required
 * e.g. in Gentoo, see http://bugs.gentoo.org/show_bug.cgi?id=12605 */
#if defined(HAS_SOCKATMARK) && !defined(HAS_SOCKATMARK_PROTO)
# if defined(__THROW) && defined(__GLIBC__)
int sockatmark(int) __THROW;
# else
int sockatmark(int);
# endif
#endif

#if defined(__osf__) && defined(__cplusplus) && !defined(_XOPEN_SOURCE_EXTENDED) /* Tru64 "cxx" (C++), see hints/dec_osf.sh for why the _XOPEN_SOURCE_EXTENDED cannot be defined. */
EXTERN_C int fchdir(int);
EXTERN_C int flock(int, int);
EXTERN_C int fseeko(FILE *, off_t, int);
EXTERN_C off_t ftello(FILE *);
#endif

#if defined(__SUNPRO_CC) /* SUNWspro CC (C++) */
EXTERN_C char *crypt(const char *, const char *);
EXTERN_C char **environ;
#endif

#if defined(__cplusplus)
#  if defined(BSDish)
EXTERN_C char **environ;
#  elif defined(__CYGWIN__)
EXTERN_C char *crypt(const char *, const char *);
#endif
#endif

#ifdef SETERRNO
# undef SETERRNO  /* SOCKS might have defined this */
#endif

#ifdef VMS
#   define SETERRNO(errcode,vmserrcode) \
	STMT_START {			\
	    set_errno(errcode);		\
	    set_vaxc_errno(vmserrcode);	\
	} STMT_END
#   define dSAVEDERRNO    int saved_errno; unsigned saved_vms_errno
#   define dSAVE_ERRNO    int saved_errno = errno; unsigned saved_vms_errno = vaxc$errno
#   define SAVE_ERRNO     ( saved_errno = errno, saved_vms_errno = vaxc$errno )
#   define RESTORE_ERRNO  SETERRNO(saved_errno, saved_vms_errno)

#   define LIB_INVARG 		LIB$_INVARG
#   define RMS_DIR    		RMS$_DIR
#   define RMS_FAC    		RMS$_FAC
#   define RMS_FEX    		RMS$_FEX
#   define RMS_FNF    		RMS$_FNF
#   define RMS_IFI    		RMS$_IFI
#   define RMS_ISI    		RMS$_ISI
#   define RMS_PRV    		RMS$_PRV
#   define SS_ACCVIO      	SS$_ACCVIO
#   define SS_DEVOFFLINE	SS$_DEVOFFLINE
#   define SS_IVCHAN  		SS$_IVCHAN
#   define SS_NORMAL  		SS$_NORMAL
#   define SS_NOPRIV  		SS$_NOPRIV
#   define SS_BUFFEROVF		SS$_BUFFEROVF
#else
#   define LIB_INVARG 		0
#   define RMS_DIR    		0
#   define RMS_FAC    		0
#   define RMS_FEX    		0
#   define RMS_FNF    		0
#   define RMS_IFI    		0
#   define RMS_ISI    		0
#   define RMS_PRV    		0
#   define SS_ACCVIO      	0
#   define SS_DEVOFFLINE	0
#   define SS_IVCHAN  		0
#   define SS_NORMAL  		0
#   define SS_NOPRIV  		0
#   define SS_BUFFEROVF		0
#endif

#ifdef WIN32
#   define dSAVEDERRNO  int saved_errno; DWORD saved_win32_errno
#   define dSAVE_ERRNO  int saved_errno = errno; DWORD saved_win32_errno = GetLastError()
#   define SAVE_ERRNO   ( saved_errno = errno, saved_win32_errno = GetLastError() )
#   define RESTORE_ERRNO ( errno = saved_errno, SetLastError(saved_win32_errno) )
#endif

#ifdef OS2
#   define dSAVEDERRNO  int saved_errno; unsigned long saved_os2_errno
#   define dSAVE_ERRNO  int saved_errno = errno; unsigned long saved_os2_errno = Perl_rc
#   define SAVE_ERRNO   ( saved_errno = errno, saved_os2_errno = Perl_rc )
#   define RESTORE_ERRNO ( errno = saved_errno, Perl_rc = saved_os2_errno )
#endif

#ifndef SETERRNO
#   define SETERRNO(errcode,vmserrcode) (errno = (errcode))
#endif

#ifndef dSAVEDERRNO
#   define dSAVEDERRNO    int saved_errno
#   define dSAVE_ERRNO    int saved_errno = errno
#   define SAVE_ERRNO     (saved_errno = errno)
#   define RESTORE_ERRNO  (errno = saved_errno)
#endif

#define ERRSV GvSVn(PL_errgv)

/* contains inlined gv_add_by_type */
#define CLEAR_ERRSV() STMT_START {					\
    SV ** const svp = &GvSV(PL_errgv);					\
    if (!*svp) {							\
	goto clresv_newemptypv;						\
    } else if (SvREADONLY(*svp)) {					\
	SvREFCNT_dec_NN(*svp);						\
	clresv_newemptypv:						\
	*svp = newSVpvs("");						\
    } else {								\
	SV *const errsv = *svp;						\
	sv_setpvs(errsv, "");						\
	SvPOK_only(errsv);						\
	if (SvMAGICAL(errsv)) {						\
	    mg_free(errsv);						\
	}								\
    }									\
    } STMT_END


#ifdef PERL_CORE
# define DEFSV (0 + GvSVn(PL_defgv))
# define DEFSV_set(sv) \
    (SvREFCNT_dec(GvSV(PL_defgv)), GvSV(PL_defgv) = SvREFCNT_inc(sv))
# define SAVE_DEFSV                \
    (                               \
	save_gp(PL_defgv, 0),        \
	GvINTRO_off(PL_defgv),        \
	SAVEGENERICSV(GvSV(PL_defgv)), \
	GvSV(PL_defgv) = NULL           \
    )
#else
# define DEFSV GvSVn(PL_defgv)
# define DEFSV_set(sv) (GvSV(PL_defgv) = (sv))
# define SAVE_DEFSV SAVESPTR(GvSV(PL_defgv))
#endif

#ifndef errno
	extern int errno;     /* ANSI allows errno to be an lvalue expr.
			       * For example in multithreaded environments
			       * something like this might happen:
			       * extern int *_errno(void);
			       * #define errno (*_errno()) */
#endif

#define UNKNOWN_ERRNO_MSG "(unknown)"

#ifdef HAS_STRERROR
#   ifndef DONT_DECLARE_STD
#       ifdef VMS
	char *strerror (int,...);
#       else
	char *strerror (int);
#       endif
#    endif
#    ifndef Strerror
#       define Strerror strerror
#    endif
#else
#    ifdef HAS_SYS_ERRLIST
	extern int sys_nerr;
	extern char *sys_errlist[];
#       ifndef Strerror
#           define Strerror(e) \
		((e) < 0 || (e) >= sys_nerr ? UNKNOWN_ERRNO_MSG : sys_errlist[e])
#       endif
#   endif
#endif

#ifdef I_SYS_IOCTL
#   ifndef _IOCTL_
#	include <sys/ioctl.h>
#   endif
#endif

#if defined(mc300) || defined(mc500) || defined(mc700) || defined(mc6000)
#   ifdef HAS_SOCKETPAIR
#	undef HAS_SOCKETPAIR
#   endif
#   ifdef I_NDBM
#	undef I_NDBM
#   endif
#endif

#ifndef HAS_SOCKETPAIR
#   ifdef HAS_SOCKET
#	define socketpair Perl_my_socketpair
#   endif
#endif

#if INTSIZE == 2
#   define htoni htons
#   define ntohi ntohs
#else
#   define htoni htonl
#   define ntohi ntohl
#endif

/* Configure already sets Direntry_t */
#if defined(I_DIRENT)
#   include <dirent.h>
#else
#   ifdef I_SYS_NDIR
#	include <sys/ndir.h>
#   else
#	ifdef I_SYS_DIR
#	    ifdef hp9000s500
#		include <ndir.h>	/* may be wrong in the future */
#	    else
#		include <sys/dir.h>
#	    endif
#	endif
#   endif
#endif

/*
 * The following gobbledygook brought to you on behalf of __STDC__.
 * (I could just use #ifndef __STDC__, but this is more bulletproof
 * in the face of half-implementations.)
 */

#if defined(I_SYSMODE)
#include <sys/mode.h>
#endif

#ifndef S_IFMT
#   ifdef _S_IFMT
#	define S_IFMT _S_IFMT
#   else
#	define S_IFMT 0170000
#   endif
#endif

#ifndef S_ISDIR
#   define S_ISDIR(m) ((m & S_IFMT) == S_IFDIR)
#endif

#ifndef S_ISCHR
#   define S_ISCHR(m) ((m & S_IFMT) == S_IFCHR)
#endif

#ifndef S_ISBLK
#   ifdef S_IFBLK
#	define S_ISBLK(m) ((m & S_IFMT) == S_IFBLK)
#   else
#	define S_ISBLK(m) (0)
#   endif
#endif

#ifndef S_ISREG
#   define S_ISREG(m) ((m & S_IFMT) == S_IFREG)
#endif

#ifndef S_ISFIFO
#   ifdef S_IFIFO
#	define S_ISFIFO(m) ((m & S_IFMT) == S_IFIFO)
#   else
#	define S_ISFIFO(m) (0)
#   endif
#endif

#ifndef S_ISLNK
#   ifdef _S_ISLNK
#	define S_ISLNK(m) _S_ISLNK(m)
#   else
#	ifdef _S_IFLNK
#	    define S_ISLNK(m) ((m & S_IFMT) == _S_IFLNK)
#	else
#	    ifdef S_IFLNK
#		define S_ISLNK(m) ((m & S_IFMT) == S_IFLNK)
#	    else
#		define S_ISLNK(m) (0)
#	    endif
#	endif
#   endif
#endif

#ifndef S_ISSOCK
#   ifdef _S_ISSOCK
#	define S_ISSOCK(m) _S_ISSOCK(m)
#   else
#	ifdef _S_IFSOCK
#	    define S_ISSOCK(m) ((m & S_IFMT) == _S_IFSOCK)
#	else
#	    ifdef S_IFSOCK
#		define S_ISSOCK(m) ((m & S_IFMT) == S_IFSOCK)
#	    else
#		define S_ISSOCK(m) (0)
#	    endif
#	endif
#   endif
#endif

#ifndef S_IRUSR
#   ifdef S_IREAD
#	define S_IRUSR S_IREAD
#	define S_IWUSR S_IWRITE
#	define S_IXUSR S_IEXEC
#   else
#	define S_IRUSR 0400
#	define S_IWUSR 0200
#	define S_IXUSR 0100
#   endif
#endif

#ifndef S_IRGRP
#   ifdef S_IRUSR
#       define S_IRGRP (S_IRUSR>>3)
#       define S_IWGRP (S_IWUSR>>3)
#       define S_IXGRP (S_IXUSR>>3)
#   else
#       define S_IRGRP 0040
#       define S_IWGRP 0020
#       define S_IXGRP 0010
#   endif
#endif

#ifndef S_IROTH
#   ifdef S_IRUSR
#       define S_IROTH (S_IRUSR>>6)
#       define S_IWOTH (S_IWUSR>>6)
#       define S_IXOTH (S_IXUSR>>6)
#   else
#       define S_IROTH 0040
#       define S_IWOTH 0020
#       define S_IXOTH 0010
#   endif
#endif

#ifndef S_ISUID
#   define S_ISUID 04000
#endif

#ifndef S_ISGID
#   define S_ISGID 02000
#endif

#ifndef S_IRWXU
#   define S_IRWXU (S_IRUSR|S_IWUSR|S_IXUSR)
#endif

#ifndef S_IRWXG
#   define S_IRWXG (S_IRGRP|S_IWGRP|S_IXGRP)
#endif

#ifndef S_IRWXO
#   define S_IRWXO (S_IROTH|S_IWOTH|S_IXOTH)
#endif

/* Haiku R1 seems to define S_IREAD and S_IWRITE in <posix/fcntl.h>
 * which would get included through <sys/file.h >, but that is 3000
 * lines in the future.  --jhi */

#if !defined(S_IREAD) && !defined(__HAIKU__)
#   define S_IREAD S_IRUSR
#endif

#if !defined(S_IWRITE) && !defined(__HAIKU__)
#   define S_IWRITE S_IWUSR
#endif

#ifndef S_IEXEC
#   define S_IEXEC S_IXUSR
#endif

#if defined(cray) || defined(gould) || defined(i860) || defined(pyr)
#   define SLOPPYDIVIDE
#endif

#ifdef UV
#undef UV
#endif

/* For the times when you want the return value of sprintf, and you want it
   to be the length. Can't have a thread variable passed in, because C89 has
   no varargs macros.
*/
#ifdef SPRINTF_RETURNS_STRLEN
#  define my_sprintf sprintf
#else
#  define my_sprintf Perl_my_sprintf
#endif

/*
 * If we have v?snprintf() and the C99 variadic macros, we can just
 * use just the v?snprintf().  It is nice to try to trap the buffer
 * overflow, however, so if we are DEBUGGING, and we cannot use the
 * gcc statement expressions, then use the function wrappers which try
 * to trap the overflow.  If we can use the gcc statement expressions,
 * we can try that even with the version that uses the C99 variadic
 * macros.
 */

/* Note that we do not check against snprintf()/vsnprintf() returning
 * negative values because that is non-standard behaviour and we use
 * snprintf/vsnprintf only iff HAS_VSNPRINTF has been defined, and
 * that should be true only if the snprintf()/vsnprintf() are true
 * to the standard. */

#define PERL_SNPRINTF_CHECK(len, max, api) STMT_START { if ((max) > 0 && (Size_t)len >= (max)) Perl_croak_nocontext("panic: %s buffer overflow", STRINGIFY(api)); } STMT_END

#ifdef USE_QUADMATH
#  define my_snprintf Perl_my_snprintf
#  define PERL_MY_SNPRINTF_GUARDED
#else
#if defined(HAS_SNPRINTF) && defined(HAS_C99_VARIADIC_MACROS) && !(defined(DEBUGGING) && !defined(PERL_USE_GCC_BRACE_GROUPS)) && !defined(PERL_GCC_PEDANTIC)
#  ifdef PERL_USE_GCC_BRACE_GROUPS
#      define my_snprintf(buffer, max, ...) ({ int len = snprintf(buffer, max, __VA_ARGS__); PERL_SNPRINTF_CHECK(len, max, snprintf); len; })
#      define PERL_MY_SNPRINTF_GUARDED
#  else
#    define my_snprintf(buffer, max, ...) snprintf(buffer, max, __VA_ARGS__)
#  endif
#else
#  define my_snprintf  Perl_my_snprintf
#  define PERL_MY_SNPRINTF_GUARDED
#endif
#endif

/* There is no quadmath_vsnprintf, and therefore my_vsnprintf()
 * dies if called under USE_QUADMATH. */
#if defined(HAS_VSNPRINTF) && defined(HAS_C99_VARIADIC_MACROS) && !(defined(DEBUGGING) && !defined(PERL_USE_GCC_BRACE_GROUPS)) && !defined(PERL_GCC_PEDANTIC)
#  ifdef PERL_USE_GCC_BRACE_GROUPS
#      define my_vsnprintf(buffer, max, ...) ({ int len = vsnprintf(buffer, max, __VA_ARGS__); PERL_SNPRINTF_CHECK(len, max, vsnprintf); len; })
#      define PERL_MY_VSNPRINTF_GUARDED
#  else
#    define my_vsnprintf(buffer, max, ...) vsnprintf(buffer, max, __VA_ARGS__)
#  endif
#else
#  define my_vsnprintf Perl_my_vsnprintf
#  define PERL_MY_VSNPRINTF_GUARDED
#endif

/* You will definitely need to use the PERL_MY_SNPRINTF_POST_GUARD()
 * or PERL_MY_VSNPRINTF_POST_GUARD() if you otherwise decide to ignore
 * the result of my_snprintf() or my_vsnprintf().  (No, you should not
 * completely ignore it: otherwise you cannot know whether your output
 * was too long.)
 *
 * int len = my_sprintf(buf, max, ...);
 * PERL_MY_SNPRINTF_POST_GUARD(len, max);
 *
 * The trick is that in certain platforms [a] the my_sprintf() already
 * contains the sanity check, while in certain platforms [b] it needs
 * to be done as a separate step.  The POST_GUARD is that step-- in [a]
 * platforms the POST_GUARD actually does nothing since the check has
 * already been done.  Watch out for the max being the same in both calls.
 *
 * If you actually use the snprintf/vsnprintf return value already,
 * you assumedly are checking its validity somehow.  But you can
 * insert the POST_GUARD() also in that case. */

#ifndef PERL_MY_SNPRINTF_GUARDED
#  define PERL_MY_SNPRINTF_POST_GUARD(len, max) PERL_SNPRINTF_CHECK(len, max, snprintf)
#else
#  define PERL_MY_SNPRINTF_POST_GUARD(len, max) PERL_UNUSED_VAR(len)
#endif

#ifndef  PERL_MY_VSNPRINTF_GUARDED
#  define PERL_MY_VSNPRINTF_POST_GUARD(len, max) PERL_SNPRINTF_CHECK(len, max, vsnprintf)
#else
#  define PERL_MY_VSNPRINTF_POST_GUARD(len, max) PERL_UNUSED_VAR(len)
#endif

#ifdef HAS_STRLCAT
#  define my_strlcat    strlcat
#else
#  define my_strlcat    Perl_my_strlcat
#endif

#ifdef HAS_STRLCPY
#  define my_strlcpy	strlcpy
#else
#  define my_strlcpy	Perl_my_strlcpy
#endif

/*
    The IV type is supposed to be long enough to hold any integral
    value or a pointer.
    --Andy Dougherty	August 1996
*/

typedef IVTYPE IV;
typedef UVTYPE UV;

#if defined(USE_64_BIT_INT) && defined(HAS_QUAD)
#  if QUADKIND == QUAD_IS_INT64_T && defined(INT64_MAX)
#    define IV_MAX INT64_MAX
#    define IV_MIN INT64_MIN
#    define UV_MAX UINT64_MAX
#    ifndef UINT64_MIN
#      define UINT64_MIN 0
#    endif
#    define UV_MIN UINT64_MIN
#  else
#    define IV_MAX PERL_QUAD_MAX
#    define IV_MIN PERL_QUAD_MIN
#    define UV_MAX PERL_UQUAD_MAX
#    define UV_MIN PERL_UQUAD_MIN
#  endif
#  define IV_IS_QUAD
#  define UV_IS_QUAD
#else
#  if defined(INT32_MAX) && IVSIZE == 4
#    define IV_MAX INT32_MAX
#    define IV_MIN INT32_MIN
#    ifndef UINT32_MAX_BROKEN /* e.g. HP-UX with gcc messes this up */
#        define UV_MAX UINT32_MAX
#    else
#        define UV_MAX 4294967295U
#    endif
#    ifndef UINT32_MIN
#      define UINT32_MIN 0
#    endif
#    define UV_MIN UINT32_MIN
#  else
#    define IV_MAX PERL_LONG_MAX
#    define IV_MIN PERL_LONG_MIN
#    define UV_MAX PERL_ULONG_MAX
#    define UV_MIN PERL_ULONG_MIN
#  endif
#  if IVSIZE == 8
#    define IV_IS_QUAD
#    define UV_IS_QUAD
#    ifndef HAS_QUAD
#      define HAS_QUAD
#    endif
#  else
#    undef IV_IS_QUAD
#    undef UV_IS_QUAD
#if !defined(PERL_CORE) || defined(USING_MSVC6)
/* We think that removing this decade-old undef this will cause too much
   breakage on CPAN for too little gain. (See RT #119753)
   However, we do need HAS_QUAD in the core for use by the drand48 code,
   but not for Win32 VC6 because it has poor __int64 support. */
#    undef HAS_QUAD
#endif
#  endif
#endif

#define Size_t_MAX (~(Size_t)0)
#define SSize_t_MAX (SSize_t)(~(Size_t)0 >> 1)

#define IV_DIG (BIT_DIGITS(IVSIZE * 8))
#define UV_DIG (BIT_DIGITS(UVSIZE * 8))

#ifndef NO_PERL_PRESERVE_IVUV
#define PERL_PRESERVE_IVUV	/* We like our integers to stay integers. */
#endif

/*
 *  The macros INT2PTR and NUM2PTR are (despite their names)
 *  bi-directional: they will convert int/float to or from pointers.
 *  However the conversion to int/float are named explicitly:
 *  PTR2IV, PTR2UV, PTR2NV.
 *
 *  For int conversions we do not need two casts if pointers are
 *  the same size as IV and UV.   Otherwise we need an explicit
 *  cast (PTRV) to avoid compiler warnings.
 */
#if (IVSIZE == PTRSIZE) && (UVSIZE == PTRSIZE)
#  define PTRV			UV
#  define INT2PTR(any,d)	(any)(d)
#else
#  if PTRSIZE == LONGSIZE
#    define PTRV		unsigned long
#    define PTR2ul(p)		(unsigned long)(p)
#  else
#    define PTRV		unsigned
#  endif
#endif

#ifndef INT2PTR
#  define INT2PTR(any,d)	(any)(PTRV)(d)
#endif

#ifndef PTR2ul
#  define PTR2ul(p)	INT2PTR(unsigned long,p)	
#endif

#define NUM2PTR(any,d)	(any)(PTRV)(d)
#define PTR2IV(p)	INT2PTR(IV,p)
#define PTR2UV(p)	INT2PTR(UV,p)
#define PTR2NV(p)	NUM2PTR(NV,p)
#define PTR2nat(p)	(PTRV)(p)	/* pointer to integer of PTRSIZE */

/* According to strict ANSI C89 one cannot freely cast between
 * data pointers and function (code) pointers.  There are at least
 * two ways around this.  One (used below) is to do two casts,
 * first the other pointer to an (unsigned) integer, and then
 * the integer to the other pointer.  The other way would be
 * to use unions to "overlay" the pointers.  For an example of
 * the latter technique, see union dirpu in struct xpvio in sv.h.
 * The only feasible use is probably temporarily storing
 * function pointers in a data pointer (such as a void pointer). */

#define DPTR2FPTR(t,p) ((t)PTR2nat(p))	/* data pointer to function pointer */
#define FPTR2DPTR(t,p) ((t)PTR2nat(p))	/* function pointer to data pointer */

#ifdef USE_LONG_DOUBLE
#  if LONG_DOUBLESIZE == DOUBLESIZE
#    define LONG_DOUBLE_EQUALS_DOUBLE
#    undef USE_LONG_DOUBLE /* Ouch! */
#  endif
#endif

#ifdef OVR_DBL_DIG
/* Use an overridden DBL_DIG */
# ifdef DBL_DIG
#  undef DBL_DIG
# endif
# define DBL_DIG OVR_DBL_DIG
#else
/* The following is all to get DBL_DIG, in order to pick a nice
   default value for printing floating point numbers in Gconvert
   (see config.h). (It also has other uses, such as figuring out if
   a given precision of printing can be done with a double instead of
   a long double - Allen).
*/
#ifdef I_LIMITS
#include <limits.h>
#endif
#ifdef I_FLOAT
#include <float.h>
#endif
#ifndef HAS_DBL_DIG
#define DBL_DIG	15   /* A guess that works lots of places */
#endif
#endif

#ifdef OVR_LDBL_DIG
/* Use an overridden LDBL_DIG */
# ifdef LDBL_DIG
#  undef LDBL_DIG
# endif
# define LDBL_DIG OVR_LDBL_DIG
#else
/* The following is all to get LDBL_DIG, in order to pick a nice
   default value for printing floating point numbers in Gconvert.
   (see config.h)
*/
# ifdef I_LIMITS
#   include <limits.h>
# endif
# ifdef I_FLOAT
#  include <float.h>
# endif
# ifndef HAS_LDBL_DIG
#  if LONG_DOUBLESIZE == 10
#   define LDBL_DIG 18 /* assume IEEE */
#  else
#   if LONG_DOUBLESIZE == 12
#    define LDBL_DIG 18 /* gcc? */
#   else
#    if LONG_DOUBLESIZE == 16
#     define LDBL_DIG 33 /* assume IEEE */
#    else
#     if LONG_DOUBLESIZE == DOUBLESIZE
#      define LDBL_DIG DBL_DIG /* bummer */
#     endif
#    endif
#   endif
#  endif
# endif
#endif

/*
 * This is for making sure we have a good DBL_MAX value, if possible,
 * either for usage as NV_MAX or for usage in figuring out if we can
 * fit a given long double into a double, if bug-fixing makes it
 * necessary to do so. - Allen <allens@@cpan.org>
 */

#ifdef I_LIMITS
#  include <limits.h>
#endif

#ifdef I_VALUES
#  if !(defined(DBL_MIN) && defined(DBL_MAX) && defined(I_LIMITS))
#    include <values.h>
#    if defined(MAXDOUBLE) && !defined(DBL_MAX)
#      define DBL_MAX MAXDOUBLE
#    endif
#    if defined(MINDOUBLE) && !defined(DBL_MIN)
#      define DBL_MIN MINDOUBLE
#    endif
#  endif
#endif /* defined(I_VALUES) */

typedef NVTYPE NV;

#ifdef I_IEEEFP
#   include <ieeefp.h>
#endif

#ifdef USING_MSVC6
/* VC6 has broken NaN semantics: NaN == NaN returns true instead of false,
 * and for example NaN < IV_MIN. */
#  define NAN_COMPARE_BROKEN
#endif
#if defined(__DECC) && defined(__osf__)
/* Also Tru64 cc has broken NaN comparisons. */
#  define NAN_COMPARE_BROKEN
#endif
#if defined(__sgi)
#  define NAN_COMPARE_BROKEN
#endif

#ifdef USE_LONG_DOUBLE
#   ifdef I_SUNMATH
#       include <sunmath.h>
#   endif
#   if defined(LDBL_DIG)
#       define NV_DIG LDBL_DIG
#       ifdef LDBL_MANT_DIG
#           define NV_MANT_DIG LDBL_MANT_DIG
#       endif
#       ifdef LDBL_MIN
#           define NV_MIN LDBL_MIN
#       endif
#       ifdef LDBL_MAX
#           define NV_MAX LDBL_MAX
#       endif
#       ifdef LDBL_MIN_EXP
#           define NV_MIN_EXP LDBL_MIN_EXP
#       endif
#       ifdef LDBL_MAX_EXP
#           define NV_MAX_EXP LDBL_MAX_EXP
#       endif
#       ifdef LDBL_MIN_10_EXP
#           define NV_MIN_10_EXP LDBL_MIN_10_EXP
#       endif
#       ifdef LDBL_MAX_10_EXP
#           define NV_MAX_10_EXP LDBL_MAX_10_EXP
#       endif
#       ifdef LDBL_EPSILON
#           define NV_EPSILON LDBL_EPSILON
#       endif
#       ifdef LDBL_MAX
#           define NV_MAX LDBL_MAX
/* Having LDBL_MAX doesn't necessarily mean that we have LDBL_MIN... -Allen */
#       else
#           ifdef HUGE_VALL
#               define NV_MAX HUGE_VALL
#           endif
#       endif
#   endif
#   if defined(HAS_SQRTL)
#       define Perl_acos acosl
#       define Perl_asin asinl
#       define Perl_atan atanl
#       define Perl_atan2 atan2l
#       define Perl_ceil ceill
#       define Perl_cos cosl
#       define Perl_cosh coshl
#       define Perl_exp expl
/* no Perl_fabs, but there's PERL_ABS */
#       define Perl_floor floorl
#       define Perl_fmod fmodl
#       define Perl_log logl
#       define Perl_log10 log10l
#       define Perl_pow powl
#       define Perl_sin sinl
#       define Perl_sinh sinhl
#       define Perl_sqrt sqrtl
#       define Perl_tan tanl
#       define Perl_tanh tanhl
#   endif
/* e.g. libsunmath doesn't have modfl and frexpl as of mid-March 2000 */
#   ifndef Perl_modf
#       ifdef HAS_MODFL
#           define Perl_modf(x,y) modfl(x,y)
/* eg glibc 2.2 series seems to provide modfl on ppc and arm, but has no
   prototype in <math.h> */
#           ifndef HAS_MODFL_PROTO
EXTERN_C long double modfl(long double, long double *);
#	    endif
#       elif (defined(HAS_TRUNCL) || defined(HAS_AINTL)) && defined(HAS_COPYSIGNL)
        extern long double Perl_my_modfl(long double x, long double *ip);
#           define Perl_modf(x,y) Perl_my_modfl(x,y)
#       endif
#   endif
#   ifndef Perl_frexp
#       ifdef HAS_FREXPL
#           define Perl_frexp(x,y) frexpl(x,y)
#       else
#           if defined(HAS_ILOGBL) && defined(HAS_SCALBNL)
extern long double Perl_my_frexpl(long double x, int *e);
#               define Perl_frexp(x,y) Perl_my_frexpl(x,y)
#           endif
#       endif
#   endif
#   ifndef Perl_ldexp
#       ifdef HAS_LDEXPL
#           define Perl_ldexp(x, y) ldexpl(x,y)
#       else
#           if defined(HAS_SCALBNL) && FLT_RADIX == 2
#               define Perl_ldexp(x,y) scalbnl(x,y)
#           endif
#       endif
#   endif
#   ifndef Perl_isnan
#       if defined(HAS_ISNANL) && !(defined(isnan) && defined(HAS_C99))
#           define Perl_isnan(x) isnanl(x)
#       elif defined(__sgi) && defined(__c99)  /* XXX Configure test needed */
#           define Perl_isnan(x) isnan(x)
#       endif
#   endif
#   ifndef Perl_isinf
#       if defined(HAS_ISINFL) && !(defined(isinf) && defined(HAS_C99))
#           define Perl_isinf(x) isinfl(x)
#       elif defined(__sgi) && defined(__c99)  /* XXX Configure test needed */
#           define Perl_isinf(x) isinf(x)
#       elif defined(LDBL_MAX) && !defined(NAN_COMPARE_BROKEN)
#           define Perl_isinf(x) ((x) > LDBL_MAX || (x) < -LDBL_MAX)
#       endif
#   endif
#   ifndef Perl_isfinite
#       define Perl_isfinite(x) Perl_isfinitel(x)
#   endif
#elif defined(USE_QUADMATH) && defined(I_QUADMATH)
#   include <quadmath.h>
#   define NV_DIG FLT128_DIG
#   define NV_MANT_DIG FLT128_MANT_DIG
#   define NV_MIN FLT128_MIN
#   define NV_MAX FLT128_MAX
#   define NV_MIN_EXP FLT128_MIN_EXP
#   define NV_MAX_EXP FLT128_MAX_EXP
#   define NV_EPSILON FLT128_EPSILON
#   define NV_MIN_10_EXP FLT128_MIN_10_EXP
#   define NV_MAX_10_EXP FLT128_MAX_10_EXP
#   define Perl_acos acosq
#   define Perl_asin asinq
#   define Perl_atan atanq
#   define Perl_atan2 atan2q
#   define Perl_ceil ceilq
#   define Perl_cos cosq
#   define Perl_cosh coshq
#   define Perl_exp expq
/* no Perl_fabs, but there's PERL_ABS */
#   define Perl_floor floorq
#   define Perl_fmod fmodq
#   define Perl_log logq
#   define Perl_log10 log10q
#   define Perl_pow powq
#   define Perl_sin sinq
#   define Perl_sinh sinhq
#   define Perl_sqrt sqrtq
#   define Perl_tan tanq
#   define Perl_tanh tanhq
#   define Perl_modf(x,y) modfq(x,y)
#   define Perl_frexp(x,y) frexpq(x,y)
#   define Perl_ldexp(x, y) ldexpq(x,y)
#   define Perl_isinf(x) isinfq(x)
#   define Perl_isnan(x) isnanq(x)
#   define Perl_isfinite(x) !(isnanq(x) || isinfq(x))
#else
#   define NV_DIG DBL_DIG
#   ifdef DBL_MANT_DIG
#       define NV_MANT_DIG DBL_MANT_DIG
#   endif
#   ifdef DBL_MIN
#       define NV_MIN DBL_MIN
#   endif
#   ifdef DBL_MAX
#       define NV_MAX DBL_MAX
#   endif
#   ifdef DBL_MIN_EXP
#       define NV_MIN_EXP DBL_MIN_EXP
#   endif
#   ifdef DBL_MAX_EXP
#       define NV_MAX_EXP DBL_MAX_EXP
#   endif
#   ifdef DBL_MIN_10_EXP
#       define NV_MIN_10_EXP DBL_MIN_10_EXP
#   endif
#   ifdef DBL_MAX_10_EXP
#       define NV_MAX_10_EXP DBL_MAX_10_EXP
#   endif
#   ifdef DBL_EPSILON
#       define NV_EPSILON DBL_EPSILON
#   endif
#   ifdef DBL_MAX               /* XXX Does DBL_MAX imply having DBL_MIN? */
#       define NV_MAX DBL_MAX
#       define NV_MIN DBL_MIN
#   else
#       ifdef HUGE_VAL
#           define NV_MAX HUGE_VAL
#       endif
#   endif

/* These math interfaces are C89. */
#   define Perl_acos acos
#   define Perl_asin asin
#   define Perl_atan atan
#   define Perl_atan2 atan2
#   define Perl_ceil ceil
#   define Perl_cos cos
#   define Perl_cosh cosh
#   define Perl_exp exp
/* no Perl_fabs, but there's PERL_ABS */
#   define Perl_floor floor
#   define Perl_fmod fmod
#   define Perl_log log
#   define Perl_log10 log10
#   define Perl_pow pow
#   define Perl_sin sin
#   define Perl_sinh sinh
#   define Perl_sqrt sqrt
#   define Perl_tan tan
#   define Perl_tanh tanh

#   define Perl_modf(x,y) modf(x,y)
#   define Perl_frexp(x,y) frexp(x,y)
#   define Perl_ldexp(x,y) ldexp(x,y)

#   ifndef Perl_isnan
#       ifdef HAS_ISNAN
#           define Perl_isnan(x) isnan(x)
#       endif
#   endif
#   ifndef Perl_isinf
#       if defined(HAS_ISINF)
#           define Perl_isinf(x) isinf(x)
#       elif defined(DBL_MAX) && !defined(NAN_COMPARE_BROKEN)
#           define Perl_isinf(x) ((x) > DBL_MAX || (x) < -DBL_MAX)
#       endif
#   endif
#   ifndef Perl_isfinite
#     ifdef HAS_ISFINITE
#       define Perl_isfinite(x) isfinite(x)
#     elif defined(HAS_FINITE)
#       define Perl_isfinite(x) finite(x)
#     endif
#   endif
#endif

/* fpclassify(): C99.  It is supposed to be a macro that switches on
* the sizeof() of its argument, so there's no need for e.g. fpclassifyl().*/
#if !defined(Perl_fp_class) && defined(HAS_FPCLASSIFY)
#    include <math.h>
#    if defined(FP_INFINITE) && defined(FP_NAN)
#        define Perl_fp_class(x)	fpclassify(x)
#        define Perl_fp_class_inf(x)	(Perl_fp_class(x)==FP_INFINITE)
#        define Perl_fp_class_nan(x)	(Perl_fp_class(x)==FP_NAN)
#        define Perl_fp_class_norm(x)	(Perl_fp_class(x)==FP_NORMAL)
#        define Perl_fp_class_denorm(x)	(Perl_fp_class(x)==FP_SUBNORMAL)
#        define Perl_fp_class_zero(x)	(Perl_fp_class(x)==FP_ZERO)
#    elif defined(FP_PLUS_INF) && defined(FP_QNAN)
/* Some versions of HP-UX (10.20) have (only) fpclassify() but which is
 * actually not the C99 fpclassify, with its own set of return defines. */
#        define Perl_fp_class(x)	fpclassify(x)
#        define Perl_fp_class_pinf(x)	(Perl_fp_class(x)==FP_PLUS_INF)
#        define Perl_fp_class_ninf(x)	(Perl_fp_class(x)==FP_MINUS_INF)
#        define Perl_fp_class_snan(x)	(Perl_fp_class(x)==FP_SNAN)
#        define Perl_fp_class_qnan(x)	(Perl_fp_class(x)==FP_QNAN)
#        define Perl_fp_class_pnorm(x)	(Perl_fp_class(x)==FP_PLUS_NORM)
#        define Perl_fp_class_nnorm(x)	(Perl_fp_class(x)==FP_MINUS_NORM)
#        define Perl_fp_class_pdenorm(x)	(Perl_fp_class(x)==FP_PLUS_DENORM)
#        define Perl_fp_class_ndenorm(x)	(Perl_fp_class(x)==FP_MINUS_DENORM)
#        define Perl_fp_class_pzero(x)	(Perl_fp_class(x)==FP_PLUS_ZERO)
#        define Perl_fp_class_nzero(x)	(Perl_fp_class(x)==FP_MINUS_ZERO)
#    else
#        undef Perl_fp_class /* Unknown set of defines */
#    endif
#endif

/* fp_classify(): Legacy: VMS, maybe Unicos? The values, however,
 * are identical to the C99 fpclassify(). */
#if !defined(Perl_fp_class) && defined(HAS_FP_CLASSIFY)
#    include <math.h>
#    ifdef __VMS
     /* FP_INFINITE and others are here rather than in math.h as C99 stipulates */
#        include <fp.h>
     /* oh, and the isnormal macro has a typo in it! */
#    undef isnormal
#    define isnormal(x) Perl_fp_class_norm(x)
#    endif
#    if defined(FP_INFINITE) && defined(FP_NAN)
#        define Perl_fp_class(x)	fp_classify(x)
#        define Perl_fp_class_inf(x)	(Perl_fp_class(x)==FP_INFINITE)
#        define Perl_fp_class_nan(x)	(Perl_fp_class(x)==FP_NAN)
#        define Perl_fp_class_norm(x)	(Perl_fp_class(x)==FP_NORMAL)
#        define Perl_fp_class_denorm(x)	(Perl_fp_class(x)==FP_SUBNORMAL)
#        define Perl_fp_class_zero(x)	(Perl_fp_class(x)==FP_ZERO)
#    else
#        undef Perl_fp_class /* Unknown set of defines */
#    endif
#endif

/* Feel free to check with me for the SGI manpages, SGI testing,
 * etcetera, if you want to try getting this to work with IRIX.
 *
 * - Allen <allens@@cpan.org> */

/* fpclass(): SysV, at least Solaris and some versions of IRIX. */
#if !defined(Perl_fp_class) && (defined(HAS_FPCLASS)||defined(HAS_FPCLASSL))
/* Solaris and IRIX have fpclass/fpclassl, but they are using
 * an enum typedef, not cpp symbols, and Configure doesn't detect that.
 * Define some symbols also as cpp symbols so we can detect them. */
#    if defined(__sun) || defined(__sgi) /* XXX Configure test instead */
#     define FP_PINF FP_PINF
#     define FP_QNAN FP_QNAN
#    endif
#    include <math.h>
#    ifdef I_IEEFP
#        include <ieeefp.h>
#    endif
#    ifdef I_FP
#        include <fp.h>
#    endif
#    if defined(USE_LONG_DOUBLE) && defined(HAS_FPCLASSL)
#        define Perl_fp_class(x)	fpclassl(x)
#    else
#        define Perl_fp_class(x)	fpclass(x)
#    endif
#    if defined(FP_CLASS_PINF) && defined(FP_CLASS_SNAN)
#        define Perl_fp_class_snan(x)	(Perl_fp_class(x)==FP_CLASS_SNAN)
#        define Perl_fp_class_qnan(x)	(Perl_fp_class(x)==FP_CLASS_QNAN)
#        define Perl_fp_class_ninf(x)	(Perl_fp_class(x)==FP_CLASS_NINF)
#        define Perl_fp_class_pinf(x)	(Perl_fp_class(x)==FP_CLASS_PINF)
#        define Perl_fp_class_nnorm(x)	(Perl_fp_class(x)==FP_CLASS_NNORM)
#        define Perl_fp_class_pnorm(x)	(Perl_fp_class(x)==FP_CLASS_PNORM)
#        define Perl_fp_class_ndenorm(x)	(Perl_fp_class(x)==FP_CLASS_NDENORM)
#        define Perl_fp_class_pdenorm(x)	(Perl_fp_class(x)==FP_CLASS_PDENORM)
#        define Perl_fp_class_nzero(x)	(Perl_fp_class(x)==FP_CLASS_NZERO)
#        define Perl_fp_class_pzero(x)	(Perl_fp_class(x)==FP_CLASS_PZERO)
#    elif defined(FP_PINF) && defined(FP_QNAN)
#        define Perl_fp_class_snan(x)	(Perl_fp_class(x)==FP_SNAN)
#        define Perl_fp_class_qnan(x)	(Perl_fp_class(x)==FP_QNAN)
#        define Perl_fp_class_ninf(x)	(Perl_fp_class(x)==FP_NINF)
#        define Perl_fp_class_pinf(x)	(Perl_fp_class(x)==FP_PINF)
#        define Perl_fp_class_nnorm(x)	(Perl_fp_class(x)==FP_NNORM)
#        define Perl_fp_class_pnorm(x)	(Perl_fp_class(x)==FP_PNORM)
#        define Perl_fp_class_ndenorm(x)	(Perl_fp_class(x)==FP_NDENORM)
#        define Perl_fp_class_pdenorm(x)	(Perl_fp_class(x)==FP_PDENORM)
#        define Perl_fp_class_nzero(x)	(Perl_fp_class(x)==FP_NZERO)
#        define Perl_fp_class_pzero(x)	(Perl_fp_class(x)==FP_PZERO)
#    else
#        undef Perl_fp_class /* Unknown set of defines */
#    endif
#endif

/* fp_class(): Legacy: at least Tru64, some versions of IRIX. */
#if !defined(Perl_fp_class) && (defined(HAS_FP_CLASS)||defined(HAS_FP_CLASSL))
#    include <math.h>
#    if !defined(FP_SNAN) && defined(I_FP_CLASS)
#        include <fp_class.h>
#    endif
#    if defined(FP_POS_INF) && defined(FP_QNAN)
#        ifdef __sgi /* XXX Configure test instead */
#            ifdef USE_LONG_DOUBLE
#                define Perl_fp_class(x)	fp_class_l(x)
#            else
#                define Perl_fp_class(x)	fp_class_d(x)
#            endif
#        else
#            if defined(USE_LONG_DOUBLE) && defined(HAS_FP_CLASSL)
#                define Perl_fp_class(x)	fp_classl(x)
#            else
#                define Perl_fp_class(x)	fp_class(x)
#            endif
#        endif
#        if defined(FP_POS_INF) && defined(FP_QNAN)
#            define Perl_fp_class_snan(x)	(Perl_fp_class(x)==FP_SNAN)
#            define Perl_fp_class_qnan(x)	(Perl_fp_class(x)==FP_QNAN)
#            define Perl_fp_class_ninf(x)	(Perl_fp_class(x)==FP_NEG_INF)
#            define Perl_fp_class_pinf(x)	(Perl_fp_class(x)==FP_POS_INF)
#            define Perl_fp_class_nnorm(x)	(Perl_fp_class(x)==FP_NEG_NORM)
#            define Perl_fp_class_pnorm(x)	(Perl_fp_class(x)==FP_POS_NORM)
#            define Perl_fp_class_ndenorm(x)	(Perl_fp_class(x)==FP_NEG_DENORM)
#            define Perl_fp_class_pdenorm(x)	(Perl_fp_class(x)==FP_POS_DENORM)
#            define Perl_fp_class_nzero(x)	(Perl_fp_class(x)==FP_NEG_ZERO)
#            define Perl_fp_class_pzero(x)	(Perl_fp_class(x)==FP_POS_ZERO)
#        else
#            undef Perl_fp_class /* Unknown set of defines */
#        endif
#    endif
#endif

/* class(), _class(): Legacy: AIX. */
#if !defined(Perl_fp_class) && defined(HAS_CLASS)
#    include <math.h>
#    if defined(FP_PLUS_NORM) && defined(FP_PLUS_INF)
#        ifndef _cplusplus
#            define Perl_fp_class(x)	class(x)
#        else
#            define Perl_fp_class(x)	_class(x)
#        endif
#        if defined(FP_PLUS_INF) && defined(FP_NANQ)
#            define Perl_fp_class_snan(x)	(Perl_fp_class(x)==FP_NANS)
#            define Perl_fp_class_qnan(x)	(Perl_fp_class(x)==FP_NANQ)
#            define Perl_fp_class_ninf(x)	(Perl_fp_class(x)==FP_MINUS_INF)
#            define Perl_fp_class_pinf(x)	(Perl_fp_class(x)==FP_PLUS_INF)
#            define Perl_fp_class_nnorm(x)	(Perl_fp_class(x)==FP_MINUS_NORM)
#            define Perl_fp_class_pnorm(x)	(Perl_fp_class(x)==FP_PLUS_NORM)
#            define Perl_fp_class_ndenorm(x)	(Perl_fp_class(x)==FP_MINUS_DENORM)
#            define Perl_fp_class_pdenorm(x)	(Perl_fp_class(x)==FP_PLUS_DENORM)
#            define Perl_fp_class_nzero(x)	(Perl_fp_class(x)==FP_MINUS_ZERO)
#            define Perl_fp_class_pzero(x)	(Perl_fp_class(x)==FP_PLUS_ZERO)
#        else
#            undef Perl_fp_class /* Unknown set of defines */
#        endif
#    endif
#endif

/* Win32: _fpclass(), _isnan(), _finite(). */
#ifdef WIN32
#  ifndef Perl_isnan
#    define Perl_isnan(x) _isnan(x)
#  endif
#  ifndef Perl_isfinite
#    define Perl_isfinite(x) _finite(x)
#  endif
#  ifndef Perl_fp_class_snan
/* No simple way to #define Perl_fp_class because _fpclass()
 * returns a set of bits. */
#    define Perl_fp_class_snan(x) (_fpclass(x) & _FPCLASS_SNAN)
#    define Perl_fp_class_qnan(x) (_fpclass(x) & _FPCLASS_QNAN)
#    define Perl_fp_class_nan(x) (_fpclass(x) & (_FPCLASS_SNAN|_FPCLASS_QNAN))
#    define Perl_fp_class_ninf(x) (_fpclass(x) & _FPCLASS_NINF))
#    define Perl_fp_class_pinf(x) (_fpclass(x) & _FPCLASS_PINF))
#    define Perl_fp_class_inf(x) (_fpclass(x) & (_FPCLASS_NINF|_FPCLASS_PINF))
#    define Perl_fp_class_nnorm(x) (_fpclass(x) & _FPCLASS_NN)
#    define Perl_fp_class_pnorm(x) (_fpclass(x) & _FPCLASS_PN)
#    define Perl_fp_class_norm(x) (_fpclass(x) & (_FPCLASS_NN|_FPCLASS_PN))
#    define Perl_fp_class_ndenorm(x) (_fpclass(x) & _FPCLASS_ND)
#    define Perl_fp_class_pdenorm(x) (_fpclass(x) & _FPCLASS_PD)
#    define Perl_fp_class_denorm(x) (_fpclass(x) & (_FPCLASS_ND|_FPCLASS_PD))
#    define Perl_fp_class_nzero(x) (_fpclass(x) & _FPCLASS_NZ)
#    define Perl_fp_class_pzero(x) (_fpclass(x) & _FPCLASS_PZ)
#    define Perl_fp_class_zero(x) (_fpclass(x) & (_FPCLASS_NZ|_FPCLASS_PZ))
#  endif
#endif

#if !defined(Perl_fp_class_inf) && \
  defined(Perl_fp_class_pinf) && defined(Perl_fp_class_ninf)
#  define Perl_fp_class_inf(x) \
    (Perl_fp_class_pinf(x) || Perl_fp_class_ninf(x))
#endif

#if !defined(Perl_fp_class_nan) && \
  defined(Perl_fp_class_snan) && defined(Perl_fp_class_qnan)
#  define Perl_fp_class_nan(x) \
    (Perl_fp_class_snan(x) || Perl_fp_class_qnan(x))
#endif

#if !defined(Perl_fp_class_zero) && \
  defined(Perl_fp_class_pzero) && defined(Perl_fp_class_nzero)
#  define Perl_fp_class_zero(x) \
    (Perl_fp_class_pzero(x) || Perl_fp_class_nzero(x))
#endif

#if !defined(Perl_fp_class_norm) && \
  defined(Perl_fp_class_pnorm) && defined(Perl_fp_class_nnorm)
#  define Perl_fp_class_norm(x) \
    (Perl_fp_class_pnorm(x) || Perl_fp_class_nnorm(x))
#endif

#if !defined(Perl_fp_class_denorm) && \
  defined(Perl_fp_class_pdenorm) && defined(Perl_fp_class_ndenorm)
#  define Perl_fp_class_denorm(x) \
    (Perl_fp_class_pdenorm(x) || Perl_fp_class_ndenorm(x))
#endif

#ifdef UNDER_CE
int isnan(double d);
#endif

#ifndef Perl_isnan
#   ifdef Perl_fp_class_nan
#       define Perl_isnan(x) Perl_fp_class_nan(x)
#   else
#       ifdef HAS_UNORDERED
#           define Perl_isnan(x) unordered((x), 0.0)
#       else
#           define Perl_isnan(x) ((x)!=(x))
#       endif
#   endif
#endif

#ifndef Perl_isinf
#   ifdef Perl_fp_class_inf
#       define Perl_isinf(x) Perl_fp_class_inf(x)
#   endif
#endif

#ifndef Perl_isfinite
#   if defined(HAS_ISFINITE) && !defined(isfinite)
#     define Perl_isfinite(x) isfinite((double)(x))
#   elif defined(HAS_FINITE)
#       define Perl_isfinite(x) finite((double)(x))
#   elif defined(Perl_fp_class_finite)
#     define Perl_isfinite(x) Perl_fp_class_finite(x)
#   else
/* For the infinities the multiplication returns nan,
 * for the nan the multiplication also returns nan,
 * for everything else (that is, finite) zero should be returned. */
#     define Perl_isfinite(x) (((x) * 0) == 0)
#   endif
#endif

#ifndef Perl_isinf
#   if defined(Perl_isfinite) && defined(Perl_isnan)
#       define Perl_isinf(x) !(Perl_isfinite(x)||Perl_isnan(x))
#   endif
#endif

/* We need Perl_isfinitel (ends with ell) (if available) even when
 * not USE_LONG_DOUBLE because the printf code (sv_catpvfn_flags)
 * needs that. */
#if defined(HAS_LONG_DOUBLE) && !defined(Perl_isfinitel)
/* If isfinite() is a macro and looks like we have C99,
 * we assume it's the type-aware C99 isfinite(). */
#    if defined(HAS_ISFINITE) && defined(isfinite) && defined(HAS_C99)
#        define Perl_isfinitel(x) isfinite(x)
#    elif defined(HAS_ISFINITEL)
#        define Perl_isfinitel(x) isfinitel(x)
#    elif defined(HAS_FINITEL)
#        define Perl_isfinitel(x) finitel(x)
#    elif defined(HAS_INFL) && defined(HAS_NANL)
#        define Perl_isfinitel(x) !(isinfl(x)||isnanl(x))
#    else
#        define Perl_isfinitel(x) ((x) * 0 == 0)  /* See Perl_isfinite. */
#    endif
#endif

/* The default is to use Perl's own atof() implementation (in numeric.c).
 * Usually that is the one to use but for some platforms (e.g. UNICOS)
 * it is however best to use the native implementation of atof.
 * You can experiment with using your native one by -DUSE_PERL_ATOF=0.
 * Some good tests to try out with either setting are t/base/num.t,
 * t/op/numconvert.t, and t/op/pack.t. Note that if using long doubles
 * you may need to be using a different function than atof! */

#ifndef USE_PERL_ATOF
#   ifndef _UNICOS
#       define USE_PERL_ATOF
#   endif
#else
#   if USE_PERL_ATOF == 0
#       undef USE_PERL_ATOF
#   endif
#endif

#ifdef USE_PERL_ATOF
#   define Perl_atof(s) Perl_my_atof(s)
#   define Perl_atof2(s, n) Perl_my_atof2(aTHX_ (s), &(n))
#else
#   define Perl_atof(s) (NV)atof(s)
#   define Perl_atof2(s, n) ((n) = atof(s))
#endif

/* Previously these definitions used hardcoded figures.
 * It is hoped these formula are more portable, although
 * no data one way or another is presently known to me.
 * The "PERL_" names are used because these calculated constants
 * do not meet the ANSI requirements for LONG_MAX, etc., which
 * need to be constants acceptable to #if - kja
 *    define PERL_LONG_MAX        2147483647L
 *    define PERL_LONG_MIN        (-LONG_MAX - 1)
 *    define PERL ULONG_MAX       4294967295L
 */

#ifdef I_LIMITS  /* Needed for cast_xxx() functions below. */
#  include <limits.h>
#endif
/* Included values.h above if necessary; still including limits.h down here,
 * despite doing above, because math.h might have overridden... XXX - Allen */

/*
 * Try to figure out max and min values for the integral types.  THE CORRECT
 * SOLUTION TO THIS MESS: ADAPT enquire.c FROM GCC INTO CONFIGURE.  The
 * following hacks are used if neither limits.h or values.h provide them:
 * U<TYPE>_MAX: for types >= int: ~(unsigned TYPE)0
 *              for types <  int:  (unsigned TYPE)~(unsigned)0
 *	The argument to ~ must be unsigned so that later signed->unsigned
 *	conversion can't modify the value's bit pattern (e.g. -0 -> +0),
 *	and it must not be smaller than int because ~ does integral promotion.
 * <type>_MAX: (<type>) (U<type>_MAX >> 1)
 * <type>_MIN: -<type>_MAX - <is_twos_complement_architecture: (3 & -1) == 3>.
 *	The latter is a hack which happens to work on some machines but
 *	does *not* catch any random system, or things like integer types
 *	with NaN if that is possible.
 *
 * All of the types are explicitly cast to prevent accidental loss of
 * numeric range, and in the hope that they will be less likely to confuse
 * over-eager optimizers.
 *
 */

#define PERL_UCHAR_MIN ((unsigned char)0)

#ifdef UCHAR_MAX
#  define PERL_UCHAR_MAX ((unsigned char)UCHAR_MAX)
#else
#  ifdef MAXUCHAR
#    define PERL_UCHAR_MAX ((unsigned char)MAXUCHAR)
#  else
#    define PERL_UCHAR_MAX       ((unsigned char)~(unsigned)0)
#  endif
#endif

/*
 * CHAR_MIN and CHAR_MAX are not included here, as the (char) type may be
 * ambiguous. It may be equivalent to (signed char) or (unsigned char)
 * depending on local options. Until Configure detects this (or at least
 * detects whether the "signed" keyword is available) the CHAR ranges
 * will not be included. UCHAR functions normally.
 *                                                           - kja
 */

#define PERL_USHORT_MIN ((unsigned short)0)

#ifdef USHORT_MAX
#  define PERL_USHORT_MAX ((unsigned short)USHORT_MAX)
#else
#  ifdef MAXUSHORT
#    define PERL_USHORT_MAX ((unsigned short)MAXUSHORT)
#  else
#    ifdef USHRT_MAX
#      define PERL_USHORT_MAX ((unsigned short)USHRT_MAX)
#    else
#      define PERL_USHORT_MAX       ((unsigned short)~(unsigned)0)
#    endif
#  endif
#endif

#ifdef SHORT_MAX
#  define PERL_SHORT_MAX ((short)SHORT_MAX)
#else
#  ifdef MAXSHORT    /* Often used in <values.h> */
#    define PERL_SHORT_MAX ((short)MAXSHORT)
#  else
#    ifdef SHRT_MAX
#      define PERL_SHORT_MAX ((short)SHRT_MAX)
#    else
#      define PERL_SHORT_MAX      ((short) (PERL_USHORT_MAX >> 1))
#    endif
#  endif
#endif

#ifdef SHORT_MIN
#  define PERL_SHORT_MIN ((short)SHORT_MIN)
#else
#  ifdef MINSHORT
#    define PERL_SHORT_MIN ((short)MINSHORT)
#  else
#    ifdef SHRT_MIN
#      define PERL_SHORT_MIN ((short)SHRT_MIN)
#    else
#      define PERL_SHORT_MIN        (-PERL_SHORT_MAX - ((3 & -1) == 3))
#    endif
#  endif
#endif

#ifdef UINT_MAX
#  define PERL_UINT_MAX ((unsigned int)UINT_MAX)
#else
#  ifdef MAXUINT
#    define PERL_UINT_MAX ((unsigned int)MAXUINT)
#  else
#    define PERL_UINT_MAX       (~(unsigned int)0)
#  endif
#endif

#define PERL_UINT_MIN ((unsigned int)0)

#ifdef INT_MAX
#  define PERL_INT_MAX ((int)INT_MAX)
#else
#  ifdef MAXINT    /* Often used in <values.h> */
#    define PERL_INT_MAX ((int)MAXINT)
#  else
#    define PERL_INT_MAX        ((int)(PERL_UINT_MAX >> 1))
#  endif
#endif

#ifdef INT_MIN
#  define PERL_INT_MIN ((int)INT_MIN)
#else
#  ifdef MININT
#    define PERL_INT_MIN ((int)MININT)
#  else
#    define PERL_INT_MIN        (-PERL_INT_MAX - ((3 & -1) == 3))
#  endif
#endif

#ifdef ULONG_MAX
#  define PERL_ULONG_MAX ((unsigned long)ULONG_MAX)
#else
#  ifdef MAXULONG
#    define PERL_ULONG_MAX ((unsigned long)MAXULONG)
#  else
#    define PERL_ULONG_MAX       (~(unsigned long)0)
#  endif
#endif

#define PERL_ULONG_MIN ((unsigned long)0L)

#ifdef LONG_MAX
#  define PERL_LONG_MAX ((long)LONG_MAX)
#else
#  ifdef MAXLONG    /* Often used in <values.h> */
#    define PERL_LONG_MAX ((long)MAXLONG)
#  else
#    define PERL_LONG_MAX        ((long) (PERL_ULONG_MAX >> 1))
#  endif
#endif

#ifdef LONG_MIN
#  define PERL_LONG_MIN ((long)LONG_MIN)
#else
#  ifdef MINLONG
#    define PERL_LONG_MIN ((long)MINLONG)
#  else
#    define PERL_LONG_MIN        (-PERL_LONG_MAX - ((3 & -1) == 3))
#  endif
#endif

#ifdef UV_IS_QUAD

#    define PERL_UQUAD_MAX	(~(UV)0)
#    define PERL_UQUAD_MIN	((UV)0)
#    define PERL_QUAD_MAX 	((IV) (PERL_UQUAD_MAX >> 1))
#    define PERL_QUAD_MIN 	(-PERL_QUAD_MAX - ((3 & -1) == 3))

#endif

typedef MEM_SIZE STRLEN;

typedef struct op OP;
typedef struct cop COP;
typedef struct unop UNOP;
typedef struct unop_aux UNOP_AUX;
typedef struct binop BINOP;
typedef struct listop LISTOP;
typedef struct logop LOGOP;
typedef struct pmop PMOP;
typedef struct svop SVOP;
typedef struct padop PADOP;
typedef struct pvop PVOP;
typedef struct loop LOOP;
typedef struct methop METHOP;

#ifdef PERL_CORE
typedef struct opslab OPSLAB;
typedef struct opslot OPSLOT;
#endif

typedef struct block_hooks BHK;
typedef struct custom_op XOP;

typedef struct interpreter PerlInterpreter;

/* SGI's <sys/sema.h> has struct sv */
#if defined(__sgi)
#   define STRUCT_SV perl_sv
#else
#   define STRUCT_SV sv
#endif
typedef struct STRUCT_SV SV;
typedef struct av AV;
typedef struct hv HV;
typedef struct cv CV;
typedef struct p5rx REGEXP;
typedef struct gp GP;
typedef struct gv GV;
typedef struct io IO;
typedef struct context PERL_CONTEXT;
typedef struct block BLOCK;

typedef struct magic MAGIC;
typedef struct xpv XPV;
typedef struct xpviv XPVIV;
typedef struct xpvuv XPVUV;
typedef struct xpvnv XPVNV;
typedef struct xpvmg XPVMG;
typedef struct xpvlv XPVLV;
typedef struct xpvinvlist XINVLIST;
typedef struct xpvav XPVAV;
typedef struct xpvhv XPVHV;
typedef struct xpvgv XPVGV;
typedef struct xpvcv XPVCV;
typedef struct xpvbm XPVBM;
typedef struct xpvfm XPVFM;
typedef struct xpvio XPVIO;
typedef struct mgvtbl MGVTBL;
typedef union any ANY;
typedef struct ptr_tbl_ent PTR_TBL_ENT_t;
typedef struct ptr_tbl PTR_TBL_t;
typedef struct clone_params CLONE_PARAMS;

/* a pad is currently just an AV; but that might change,
 * so hide the type.  */
typedef struct padlist PADLIST;
typedef AV PAD;
typedef struct padnamelist PADNAMELIST;
typedef struct padname PADNAME;

/* enable PERL_COPY_ON_WRITE by default */
#if !defined(PERL_COPY_ON_WRITE) && !defined(PERL_NO_COW)
#  define PERL_COPY_ON_WRITE
#endif

#ifdef PERL_COPY_ON_WRITE
#  define PERL_ANY_COW
#else
# define PERL_SAWAMPERSAND
#endif

#if defined(PERL_DEBUG_READONLY_OPS) && !defined(USE_ITHREADS)
# error PERL_DEBUG_READONLY_OPS only works with ithreads
#endif

#include "handy.h"
#include "charclass_invlists.h"

#if defined(USE_LARGE_FILES) && !defined(NO_64_BIT_RAWIO)
#   if LSEEKSIZE == 8 && !defined(USE_64_BIT_RAWIO)
#       define USE_64_BIT_RAWIO	/* implicit */
#   endif
#endif

/* Notice the use of HAS_FSEEKO: now we are obligated to always use
 * fseeko/ftello if possible.  Don't go #defining ftell to ftello yourself,
 * however, because operating systems like to do that themself. */
#ifndef FSEEKSIZE
#   ifdef HAS_FSEEKO
#       define FSEEKSIZE LSEEKSIZE
#   else
#       define FSEEKSIZE LONGSIZE
#   endif
#endif

#if defined(USE_LARGE_FILES) && !defined(NO_64_BIT_STDIO)
#   if FSEEKSIZE == 8 && !defined(USE_64_BIT_STDIO)
#       define USE_64_BIT_STDIO /* implicit */
#   endif
#endif

#ifdef USE_64_BIT_RAWIO
#   ifdef HAS_OFF64_T
#       undef Off_t
#       define Off_t off64_t
#       undef LSEEKSIZE
#       define LSEEKSIZE 8
#   endif
/* Most 64-bit environments have defines like _LARGEFILE_SOURCE that
 * will trigger defines like the ones below.  Some 64-bit environments,
 * however, do not.  Therefore we have to explicitly mix and match. */
#   if defined(USE_OPEN64)
#       define open open64
#   endif
#   if defined(USE_LSEEK64)
#       define lseek lseek64
#   else
#       if defined(USE_LLSEEK)
#           define lseek llseek
#       endif
#   endif
#   if defined(USE_STAT64)
#       define stat stat64
#   endif
#   if defined(USE_FSTAT64)
#       define fstat fstat64
#   endif
#   if defined(USE_LSTAT64)
#       define lstat lstat64
#   endif
#   if defined(USE_FLOCK64)
#       define flock flock64
#   endif
#   if defined(USE_LOCKF64)
#       define lockf lockf64
#   endif
#   if defined(USE_FCNTL64)
#       define fcntl fcntl64
#   endif
#   if defined(USE_TRUNCATE64)
#       define truncate truncate64
#   endif
#   if defined(USE_FTRUNCATE64)
#       define ftruncate ftruncate64
#   endif
#endif

#ifdef USE_64_BIT_STDIO
#   ifdef HAS_FPOS64_T
#       undef Fpos_t
#       define Fpos_t fpos64_t
#   endif
/* Most 64-bit environments have defines like _LARGEFILE_SOURCE that
 * will trigger defines like the ones below.  Some 64-bit environments,
 * however, do not. */
#   if defined(USE_FOPEN64)
#       define fopen fopen64
#   endif
#   if defined(USE_FSEEK64)
#       define fseek fseek64 /* don't do fseeko here, see perlio.c */
#   endif
#   if defined(USE_FTELL64)
#       define ftell ftell64 /* don't do ftello here, see perlio.c */
#   endif
#   if defined(USE_FSETPOS64)
#       define fsetpos fsetpos64
#   endif
#   if defined(USE_FGETPOS64)
#       define fgetpos fgetpos64
#   endif
#   if defined(USE_TMPFILE64)
#       define tmpfile tmpfile64
#   endif
#   if defined(USE_FREOPEN64)
#       define freopen freopen64
#   endif
#endif

#if defined(OS2)
#  include "iperlsys.h"
#endif

#ifdef DOSISH
#   if defined(OS2)
#       include "os2ish.h"
#   else
#       include "dosish.h"
#   endif
#elif defined(VMS)
#   include "vmsish.h"
#elif defined(PLAN9)
#   include "./plan9/plan9ish.h"
#elif defined(__VOS__)
#   ifdef __GNUC__
#     include "./vos/vosish.h"
#   else
#     include "vos/vosish.h"
#   endif
#elif defined(__SYMBIAN32__)
#   include "symbian/symbianish.h"
#elif defined(__HAIKU__)
#   include "haiku/haikuish.h"
#else
#   include "unixish.h"
#endif

#ifdef __amigaos4__
#    include "amigaos.h"
#    undef FD_CLOEXEC /* a lie in AmigaOS */
#endif

/* NSIG logic from Configure --> */
/* Strange style to avoid deeply-nested #if/#else/#endif */
#ifndef NSIG
#  ifdef _NSIG
#    define NSIG (_NSIG)
#  endif
#endif

#ifndef NSIG
#  ifdef SIGMAX
#    define NSIG (SIGMAX+1)
#  endif
#endif

#ifndef NSIG
#  ifdef SIG_MAX
#    define NSIG (SIG_MAX+1)
#  endif
#endif

#ifndef NSIG
#  ifdef _SIG_MAX
#    define NSIG (_SIG_MAX+1)
#  endif
#endif

#ifndef NSIG
#  ifdef MAXSIG
#    define NSIG (MAXSIG+1)
#  endif
#endif

#ifndef NSIG
#  ifdef MAX_SIG
#    define NSIG (MAX_SIG+1)
#  endif
#endif

#ifndef NSIG
#  ifdef SIGARRAYSIZE
#    define NSIG SIGARRAYSIZE /* Assume ary[SIGARRAYSIZE] */
#  endif
#endif

#ifndef NSIG
#  ifdef _sys_nsig
#    define NSIG (_sys_nsig) /* Solaris 2.5 */
#  endif
#endif

/* Default to some arbitrary number that's big enough to get most
   of the common signals.
*/
#ifndef NSIG
#    define NSIG 50
#endif
/* <-- NSIG logic from Configure */

#ifndef NO_ENVIRON_ARRAY
#  define USE_ENVIRON_ARRAY
#endif

/*
 * initialise to avoid floating-point exceptions from overflow, etc
 */
#ifndef PERL_FPU_INIT
#  ifdef HAS_FPSETMASK
#    if HAS_FLOATINGPOINT_H
#      include <floatingpoint.h>
#    endif
/* Some operating systems have this as a macro, which in turn expands to a comma
   expression, and the last sub-expression is something that gets calculated,
   and then they have the gall to warn that a value computed is not used. Hence
   cast to void.  */
#    define PERL_FPU_INIT (void)fpsetmask(0)
#  else
#    if defined(SIGFPE) && defined(SIG_IGN) && !defined(PERL_MICRO)
#      define PERL_FPU_INIT       PL_sigfpe_saved = (Sighandler_t) signal(SIGFPE, SIG_IGN)
#      define PERL_FPU_PRE_EXEC   { Sigsave_t xfpe; rsignal_save(SIGFPE, PL_sigfpe_saved, &xfpe);
#      define PERL_FPU_POST_EXEC    rsignal_restore(SIGFPE, &xfpe); }
#    else
#      define PERL_FPU_INIT

#    endif
#  endif
#endif
#ifndef PERL_FPU_PRE_EXEC
#  define PERL_FPU_PRE_EXEC   {
#  define PERL_FPU_POST_EXEC  }
#endif

/* In Tru64 the cc -ieee enables the IEEE math but disables traps.
 * We need to reenable the "invalid" trap because otherwise generation
 * of NaN values leaves the IEEE fp flags in bad state, leaving any further
 * fp ops behaving strangely (Inf + 1 resulting in zero, for example). */
#ifdef __osf__
#  include <machine/fpu.h>
#  define PERL_SYS_FPU_INIT \
     STMT_START { \
         ieee_set_fp_control(IEEE_TRAP_ENABLE_INV); \
         signal(SIGFPE, SIG_IGN); \
     } STMT_END
#endif
/* In IRIX the default for Flush to Zero bit is true,
 * which means that results going below the minimum of normal
 * floating points go to zero, instead of going denormal/subnormal.
 * This is unlike almost any other system running Perl, so let's clear it.
 * [perl #123767] IRIX64 blead (ddce084a) opbasic/arith.t failure, originally
 * [perl #120426] small numbers shouldn't round to zero if they have extra floating digits
 *
 * XXX The flush-to-zero behaviour should be a Configure scan.
 * To change the behaviour usually requires some system-specific
 * incantation, though, like the below. */
#ifdef __sgi
#  include <sys/fpu.h>
#  define PERL_SYS_FPU_INIT \
     STMT_START { \
         union fpc_csr csr; \
         csr.fc_word = get_fpc_csr(); \
         csr.fc_struct.flush = 0; \
         set_fpc_csr(csr.fc_word); \
     } STMT_END
#endif

#ifndef PERL_SYS_FPU_INIT
#  define PERL_SYS_FPU_INIT NOOP
#endif

#ifndef PERL_SYS_INIT3_BODY
#  define PERL_SYS_INIT3_BODY(argvp,argcp,envp) PERL_SYS_INIT_BODY(argvp,argcp)
#endif

/*
=head1 Miscellaneous Functions

=for apidoc Am|void|PERL_SYS_INIT|int *argc|char*** argv
Provides system-specific tune up of the C runtime environment necessary to
run Perl interpreters.  This should be called only once, before creating
any Perl interpreters.

=for apidoc Am|void|PERL_SYS_INIT3|int *argc|char*** argv|char*** env
Provides system-specific tune up of the C runtime environment necessary to
run Perl interpreters.  This should be called only once, before creating
any Perl interpreters.

=for apidoc Am|void|PERL_SYS_TERM|
Provides system-specific clean up of the C runtime environment after
running Perl interpreters.  This should be called only once, after
freeing any remaining Perl interpreters.

=cut
 */

#define PERL_SYS_INIT(argc, argv)	Perl_sys_init(argc, argv)
#define PERL_SYS_INIT3(argc, argv, env)	Perl_sys_init3(argc, argv, env)
#define PERL_SYS_TERM()			Perl_sys_term()

#ifndef PERL_WRITE_MSG_TO_CONSOLE
#  define PERL_WRITE_MSG_TO_CONSOLE(io, msg, len) PerlIO_write(io, msg, len)
#endif

#ifndef MAXPATHLEN
#  ifdef PATH_MAX
#    ifdef _POSIX_PATH_MAX
#       if PATH_MAX > _POSIX_PATH_MAX
/* POSIX 1990 (and pre) was ambiguous about whether PATH_MAX
 * included the null byte or not.  Later amendments of POSIX,
 * XPG4, the Austin Group, and the Single UNIX Specification
 * all explicitly include the null byte in the PATH_MAX.
 * Ditto for _POSIX_PATH_MAX. */
#         define MAXPATHLEN PATH_MAX
#       else
#         define MAXPATHLEN _POSIX_PATH_MAX
#       endif
#    else
#      define MAXPATHLEN (PATH_MAX+1)
#    endif
#  else
#    define MAXPATHLEN 1024	/* Err on the large side. */
#  endif
#endif

/* In case Configure was not used (we are using a "canned config"
 * such as Win32, or a cross-compilation setup, for example) try going
 * by the gcc major and minor versions.  One useful URL is
 * http://www.ohse.de/uwe/articles/gcc-attributes.html,
 * but contrary to this information warn_unused_result seems
 * not to be in gcc 3.3.5, at least. --jhi
 * Also, when building extensions with an installed perl, this allows
 * the user to upgrade gcc and get the right attributes, rather than
 * relying on the list generated at Configure time.  --AD
 * Set these up now otherwise we get confused when some of the <*thread.h>
 * includes below indirectly pull in <perlio.h> (which needs to know if we
 * have HASATTRIBUTE_FORMAT).
 */

#ifndef PERL_MICRO
#if defined __GNUC__ && !defined(__INTEL_COMPILER)
#  if __GNUC__ == 3 && __GNUC_MINOR__ >= 1 || __GNUC__ > 3 /* 3.1 -> */
#    define HASATTRIBUTE_DEPRECATED
#  endif
#  if __GNUC__ >= 3 /* 3.0 -> */ /* XXX Verify this version */
#    define HASATTRIBUTE_FORMAT
#    if defined __MINGW32__
#      define PRINTF_FORMAT_NULL_OK
#    endif
#  endif
#  if __GNUC__ >= 3 /* 3.0 -> */
#    define HASATTRIBUTE_MALLOC
#  endif
#  if __GNUC__ == 3 && __GNUC_MINOR__ >= 3 || __GNUC__ > 3 /* 3.3 -> */
#    define HASATTRIBUTE_NONNULL
#  endif
#  if __GNUC__ == 2 && __GNUC_MINOR__ >= 5 || __GNUC__ > 2 /* 2.5 -> */
#    define HASATTRIBUTE_NORETURN
#  endif
#  if __GNUC__ >= 3 /* gcc 3.0 -> */
#    define HASATTRIBUTE_PURE
#  endif
#  if __GNUC__ == 3 && __GNUC_MINOR__ >= 4 || __GNUC__ > 3 /* 3.4 -> */
#    define HASATTRIBUTE_UNUSED
#  endif
#  if __GNUC__ == 3 && __GNUC_MINOR__ == 3 && !defined(__cplusplus)
#    define HASATTRIBUTE_UNUSED /* gcc-3.3, but not g++-3.3. */
#  endif
#  if __GNUC__ == 3 && __GNUC_MINOR__ >= 4 || __GNUC__ > 3 /* 3.4 -> */
#    define HASATTRIBUTE_WARN_UNUSED_RESULT
#  endif
#endif
#endif /* #ifndef PERL_MICRO */

/* USE_5005THREADS needs to be after unixish.h as <pthread.h> includes
 * <sys/signal.h> which defines NSIG - which will stop inclusion of <signal.h>
 * this results in many functions being undeclared which bothers C++
 * May make sense to have threads after "*ish.h" anyway
 */

/* clang Thread Safety Analysis/Annotations/Attributes
 * http://clang.llvm.org/docs/ThreadSafetyAnalysis.html
 *
 * Available since clang 3.6-ish (appeared in 3.4, but shaky still in 3.5).
 * Apple XCode hijacks __clang_major__ and __clang_minor__
 * (6.1 means really clang 3.6), so needs extra hijinks
 * (could probably also test the contents of __apple_build_version__).
 */
#if defined(USE_ITHREADS) && defined(I_PTHREAD) && \
    defined(__clang__) && \
    !defined(SWIG) && \
  ((!defined(__apple_build_version__) &&               \
    ((__clang_major__ == 3 && __clang_minor__ >= 6) || \
     (__clang_major__ >= 4))) || \
   (defined(__apple_build_version__) &&                \
    ((__clang_major__ == 6 && __clang_minor__ >= 1) || \
     (__clang_major__ >= 7))))
#  define PERL_TSA__(x)   __attribute__((x))
#  define PERL_TSA_ACTIVE
#else
#  define PERL_TSA__(x)   /* No TSA, make TSA attributes no-ops. */
#  undef PERL_TSA_ACTIVE
#endif

/* PERL_TSA_CAPABILITY() is used to annotate typedefs.
 * typedef old_type PERL_TSA_CAPABILITY("mutex") new_type;
 */
#define PERL_TSA_CAPABILITY(x) \
    PERL_TSA__(capability(x))

/* In the below examples the mutex must be lexically visible, usually
 * either as global variables, or as function arguments. */

/* PERL_TSA_GUARDED_BY() is used to annotate global variables.
 *
 * Foo foo PERL_TSA_GUARDED_BY(mutex);
 */
#define PERL_TSA_GUARDED_BY(x) \
    PERL_TSA__(guarded_by(x))

/* PERL_TSA_PT_GUARDED_BY() is used to annotate global pointers.
 * The data _behind_ the pointer is guarded.
 *
 * Foo* ptr PERL_TSA_PT_GUARDED_BY(mutex);
 */
#define PERL_TSA_PT_GUARDED_BY(x) \
    PERL_TSA__(pt_guarded_by(x))

/* PERL_TSA_REQUIRES() is used to annotate functions.
 * The caller MUST hold the resource when calling the function.
 *
 * void Foo() PERL_TSA_REQUIRES(mutex);
 */
#define PERL_TSA_REQUIRES(x) \
    PERL_TSA__(requires_capability(x))

/* PERL_TSA_EXCLUDES() is used to annotate functions.
 * The caller MUST NOT hold resource when calling the function.
 *
 * EXCLUDES should be used when the function first acquires
 * the resource and then releases it.  Use to avoid deadlock.
 *
 * void Foo() PERL_TSA_EXCLUDES(mutex);
 */
#define PERL_TSA_EXCLUDES(x) \
    PERL_TSA__(locks_excluded(x))

/* PERL_TSA_ACQUIRE() is used to annotate functions.
 * The caller MUST NOT hold the resource when calling the function,
 * and the function will acquire the resource.
 *
 * void Foo() PERL_TSA_ACQUIRE(mutex);
 */
#define PERL_TSA_ACQUIRE(x) \
    PERL_TSA__(acquire_capability(x))

/* PERL_TSA_RELEASE() is used to annotate functions.
 * The caller MUST hold the resource when calling the function,
 * and the function will release the resource.
 *
 * void Foo() PERL_TSA_RELEASE(mutex);
 */
#define PERL_TSA_RELEASE(x) \
    PERL_TSA__(release_capability(x))

/* PERL_TSA_NO_TSA is used to annotate functions.
 * Used when being intentionally unsafe, or when the code is too
 * complicated for the analysis.  Use sparingly.
 *
 * void Foo() PERL_TSA_NO_TSA;
 */
#define PERL_TSA_NO_TSA \
    PERL_TSA__(no_thread_safety_analysis)

/* There are more annotations/attributes available, see the clang
 * documentation for details. */

#if defined(USE_ITHREADS)
#  ifdef NETWARE
#   include <nw5thread.h>
#  else
#    ifdef WIN32
#      include <win32thread.h>
#    else
#      ifdef OS2
#        include "os2thread.h"
#      else
#        ifdef I_MACH_CTHREADS
#          include <mach/cthreads.h>
typedef cthread_t	perl_os_thread;
typedef mutex_t		perl_mutex;
typedef condition_t	perl_cond;
typedef void *		perl_key;
#        else /* Posix threads */
#          ifdef I_PTHREAD
#            include <pthread.h>
#          endif
typedef pthread_t	perl_os_thread;
typedef pthread_mutex_t PERL_TSA_CAPABILITY("mutex") perl_mutex;
typedef pthread_cond_t	perl_cond;
typedef pthread_key_t	perl_key;
#        endif /* I_MACH_CTHREADS */
#      endif /* OS2 */
#    endif /* WIN32 */
#  endif /* NETWARE */
#endif /* USE_ITHREADS */

#ifdef PERL_TSA_ACTIVE
/* Since most pthread mutex interfaces have not been annotated, we
 * need to have these wrappers. The NO_TSA annotation is quite ugly
 * but it cannot be avoided in plain C, unlike in C++, where one could
 * e.g. use ACQUIRE() with no arg on a mutex lock method.
 *
 * The bodies of these wrappers are in util.c
 *
 * TODO: however, some platforms are starting to get these clang
 * thread safety annotations for pthreads, for example FreeBSD.
 * Do we need a way to a bypass these wrappers? */
EXTERN_C int perl_tsa_mutex_lock(perl_mutex* mutex)
  PERL_TSA_ACQUIRE(*mutex)
  PERL_TSA_NO_TSA;
EXTERN_C int perl_tsa_mutex_unlock(perl_mutex* mutex)
  PERL_TSA_RELEASE(*mutex)
  PERL_TSA_NO_TSA;
#endif

#if defined(WIN32)
#  include "win32.h"
#endif

#ifdef NETWARE
#  include "netware.h"
#endif

#define STATUS_UNIX	PL_statusvalue
#ifdef VMS
#   define STATUS_NATIVE	PL_statusvalue_vms
/*
 * vaxc$errno is only guaranteed to be valid if errno == EVMSERR, otherwise
 * its contents can not be trusted.  Unfortunately, Perl seems to check
 * it on exit, so it when PL_statusvalue_vms is updated, vaxc$errno should
 * be updated also.
 */
#  include <stsdef.h>
#  include <ssdef.h>
/* Presume this because if VMS changes it, it will require a new
 * set of APIs for waiting on children for binary compatibility.
 */
#  define child_offset_bits (8)
#  ifndef C_FAC_POSIX
#  define C_FAC_POSIX 0x35A000
#  endif

/*  STATUS_EXIT - validates and returns a NATIVE exit status code for the
 * platform from the existing UNIX or Native status values.
 */

#   define STATUS_EXIT \
	(((I32)PL_statusvalue_vms == -1 ? SS$_ABORT : PL_statusvalue_vms) | \
	   (VMSISH_HUSHED ? STS$M_INHIB_MSG : 0))


/* STATUS_NATIVE_CHILD_SET - Calculate UNIX status that matches the child
 * exit code and shifts the UNIX value over the correct number of bits to
 * be a child status.  Usually the number of bits is 8, but that could be
 * platform dependent.  The NATIVE status code is presumed to have either
 * from a child process.
 */

/* This is complicated.  The child processes return a true native VMS
   status which must be saved.  But there is an assumption in Perl that
   the UNIX child status has some relationship to errno values, so
   Perl tries to translate it to text in some of the tests.
   In order to get the string translation correct, for the error, errno
   must be EVMSERR, but that generates a different text message
   than what the test programs are expecting.  So an errno value must
   be derived from the native status value when an error occurs.
   That will hide the true native status message.  With this version of
   perl, the true native child status can always be retrieved so that
   is not a problem.  But in this case, Pl_statusvalue and errno may
   have different values in them.
 */

#   define STATUS_NATIVE_CHILD_SET(n) \
	STMT_START {							\
	    I32 evalue = (I32)n;					\
	    if (evalue == EVMSERR) {					\
	      PL_statusvalue_vms = vaxc$errno;				\
	      PL_statusvalue = evalue;					\
	    } else {							\
	      PL_statusvalue_vms = evalue;				\
	      if (evalue == -1) {					\
		PL_statusvalue = -1;					\
		PL_statusvalue_vms = SS$_ABORT; /* Should not happen */ \
	      } else							\
		PL_statusvalue = Perl_vms_status_to_unix(evalue, 1);	\
	      set_vaxc_errno(evalue);					\
	      if ((PL_statusvalue_vms & C_FAC_POSIX) == C_FAC_POSIX)	\
		  set_errno(EVMSERR);					\
	      else set_errno(Perl_vms_status_to_unix(evalue, 0));	\
	      PL_statusvalue = PL_statusvalue << child_offset_bits;	\
	    }								\
	} STMT_END

#   ifdef VMSISH_STATUS
#	define STATUS_CURRENT	(VMSISH_STATUS ? STATUS_NATIVE : STATUS_UNIX)
#   else
#	define STATUS_CURRENT	STATUS_UNIX
#   endif

  /* STATUS_UNIX_SET - takes a UNIX/POSIX errno value and attempts to update
   * the NATIVE status to an equivalent value.  Can not be used to translate
   * exit code values as exit code values are not guaranteed to have any
   * relationship at all to errno values.
   * This is used when Perl is forcing errno to have a specific value.
   */
#   define STATUS_UNIX_SET(n)				\
	STMT_START {					\
	    I32 evalue = (I32)n;			\
	    PL_statusvalue = evalue;			\
	    if (PL_statusvalue != -1) {			\
		if (PL_statusvalue != EVMSERR) {	\
		  PL_statusvalue &= 0xFFFF;		\
		  if (MY_POSIX_EXIT)			\
		    PL_statusvalue_vms=PL_statusvalue ? SS$_ABORT : SS$_NORMAL;\
		  else PL_statusvalue_vms = Perl_unix_status_to_vms(evalue); \
		}					\
		else {					\
		  PL_statusvalue_vms = vaxc$errno;	\
		}					\
	    }						\
	    else PL_statusvalue_vms = SS$_ABORT;	\
	    set_vaxc_errno(PL_statusvalue_vms);		\
	} STMT_END

  /* STATUS_UNIX_EXIT_SET - Takes a UNIX/POSIX exit code and sets
   * the NATIVE error status based on it.
   *
   * When in the default mode to comply with the Perl VMS documentation,
   * 0 is a success and any other code sets the NATIVE status to a failure
   * code of SS$_ABORT.
   *
   * In the new POSIX EXIT mode, native status will be set so that the
   * actual exit code will can be retrieved by the calling program or
   * shell.
   *
   * If the exit code is not clearly a UNIX parent or child exit status,
   * it will be passed through as a VMS status.
   */

#   define STATUS_UNIX_EXIT_SET(n)			\
	STMT_START {					\
	    I32 evalue = (I32)n;			\
	    PL_statusvalue = evalue;			\
	    if (MY_POSIX_EXIT) { \
	      if (evalue <= 0xFF00) {		\
		  if (evalue > 0xFF)			\
		    evalue = (evalue >> child_offset_bits) & 0xFF; \
		  PL_statusvalue_vms =		\
		    (C_FAC_POSIX | (evalue << 3 ) |	\
		    ((evalue == 1) ? (STS$K_ERROR | STS$M_INHIB_MSG) : 1)); \
	      } else /* forgive them Perl, for they have sinned */ \
		PL_statusvalue_vms = evalue; \
	    } else { \
	      if (evalue == 0)			\
		PL_statusvalue_vms = SS$_NORMAL;	\
	      else if (evalue <= 0xFF00) \
		PL_statusvalue_vms = SS$_ABORT; \
	      else { /* forgive them Perl, for they have sinned */ \
		  if (evalue != EVMSERR) PL_statusvalue_vms = evalue; \
		  else PL_statusvalue_vms = vaxc$errno;	\
		  /* And obviously used a VMS status value instead of UNIX */ \
		  PL_statusvalue = EVMSERR;		\
	      } \
	      set_vaxc_errno(PL_statusvalue_vms);	\
	    }						\
	} STMT_END


  /* STATUS_EXIT_SET - Takes a NATIVE/UNIX/POSIX exit code
   * and sets the NATIVE error status based on it.  This special case
   * is needed to maintain compatibility with past VMS behavior.
   *
   * In the default mode on VMS, this number is passed through as
   * both the NATIVE and UNIX status.  Which makes it different
   * that the STATUS_UNIX_EXIT_SET.
   *
   * In the new POSIX EXIT mode, native status will be set so that the
   * actual exit code will can be retrieved by the calling program or
   * shell.
   *
   * A POSIX exit code is from 0 to 255.  If the exit code is higher
   * than this, it needs to be assumed that it is a VMS exit code and
   * passed through.
   */

#   define STATUS_EXIT_SET(n)				\
	STMT_START {					\
	    I32 evalue = (I32)n;			\
	    PL_statusvalue = evalue;			\
	    if (MY_POSIX_EXIT)				\
		if (evalue > 255) PL_statusvalue_vms = evalue; else {	\
		  PL_statusvalue_vms = \
		    (C_FAC_POSIX | (evalue << 3 ) |	\
		     ((evalue == 1) ? (STS$K_ERROR | STS$M_INHIB_MSG) : 1));} \
	    else					\
		PL_statusvalue_vms = evalue ? evalue : SS$_NORMAL; \
	    set_vaxc_errno(PL_statusvalue_vms);		\
	} STMT_END


 /* This macro forces a success status */
#   define STATUS_ALL_SUCCESS	\
	(PL_statusvalue = 0, PL_statusvalue_vms = SS$_NORMAL)

 /* This macro forces a failure status */
#   define STATUS_ALL_FAILURE	(PL_statusvalue = 1, \
     vaxc$errno = PL_statusvalue_vms = MY_POSIX_EXIT ? \
	(C_FAC_POSIX | (1 << 3) | STS$K_ERROR | STS$M_INHIB_MSG) : SS$_ABORT)

#elif defined(__amigaos4__)
 /* A somewhat experimental attempt to simulate posix return code values */
#   define STATUS_NATIVE	PL_statusvalue_posix
#   define STATUS_NATIVE_CHILD_SET(n)                      \
        STMT_START {                                       \
            PL_statusvalue_posix = (n);                    \
            if (PL_statusvalue_posix < 0) {                \
                PL_statusvalue = -1;                       \
            }                                              \
            else {                                         \
                PL_statusvalue = n << 8;                   \
            }                                              \
        } STMT_END
#   define STATUS_UNIX_SET(n)		\
	STMT_START {			\
	    PL_statusvalue = (n);		\
	    if (PL_statusvalue != -1)	\
		PL_statusvalue &= 0xFFFF;	\
	} STMT_END
#   define STATUS_UNIX_EXIT_SET(n) STATUS_UNIX_SET(n)
#   define STATUS_EXIT_SET(n) STATUS_UNIX_SET(n)
#   define STATUS_CURRENT STATUS_UNIX
#   define STATUS_EXIT STATUS_UNIX
#   define STATUS_ALL_SUCCESS	(PL_statusvalue = 0, PL_statusvalue_posix = 0)
#   define STATUS_ALL_FAILURE	(PL_statusvalue = 1, PL_statusvalue_posix = 1)

#else
#   define STATUS_NATIVE	PL_statusvalue_posix
#   if defined(WCOREDUMP)
#       define STATUS_NATIVE_CHILD_SET(n)                  \
            STMT_START {                                   \
                PL_statusvalue_posix = (n);                \
                if (PL_statusvalue_posix == -1)            \
                    PL_statusvalue = -1;                   \
                else {                                     \
                    PL_statusvalue =                       \
                        (WIFEXITED(PL_statusvalue_posix) ? (WEXITSTATUS(PL_statusvalue_posix) << 8) : 0) |  \
                        (WIFSIGNALED(PL_statusvalue_posix) ? (WTERMSIG(PL_statusvalue_posix) & 0x7F) : 0) | \
                        (WIFSIGNALED(PL_statusvalue_posix) && WCOREDUMP(PL_statusvalue_posix) ? 0x80 : 0);  \
                }                                          \
            } STMT_END
#   elif defined(WIFEXITED)
#       define STATUS_NATIVE_CHILD_SET(n)                  \
            STMT_START {                                   \
                PL_statusvalue_posix = (n);                \
                if (PL_statusvalue_posix == -1)            \
                    PL_statusvalue = -1;                   \
                else {                                     \
                    PL_statusvalue =                       \
                        (WIFEXITED(PL_statusvalue_posix) ? (WEXITSTATUS(PL_statusvalue_posix) << 8) : 0) |  \
                        (WIFSIGNALED(PL_statusvalue_posix) ? (WTERMSIG(PL_statusvalue_posix) & 0x7F) : 0);  \
                }                                          \
            } STMT_END
#   else
#       define STATUS_NATIVE_CHILD_SET(n)                  \
            STMT_START {                                   \
                PL_statusvalue_posix = (n);                \
                if (PL_statusvalue_posix == -1)            \
                    PL_statusvalue = -1;                   \
                else {                                     \
                    PL_statusvalue =                       \
                        PL_statusvalue_posix & 0xFFFF;     \
                }                                          \
            } STMT_END
#   endif
#   define STATUS_UNIX_SET(n)		\
	STMT_START {			\
	    PL_statusvalue = (n);		\
	    if (PL_statusvalue != -1)	\
		PL_statusvalue &= 0xFFFF;	\
	} STMT_END
#   define STATUS_UNIX_EXIT_SET(n) STATUS_UNIX_SET(n)
#   define STATUS_EXIT_SET(n) STATUS_UNIX_SET(n)
#   define STATUS_CURRENT STATUS_UNIX
#   define STATUS_EXIT STATUS_UNIX
#   define STATUS_ALL_SUCCESS	(PL_statusvalue = 0, PL_statusvalue_posix = 0)
#   define STATUS_ALL_FAILURE	(PL_statusvalue = 1, PL_statusvalue_posix = 1)
#endif

/* flags in PL_exit_flags for nature of exit() */
#define PERL_EXIT_EXPECTED	0x01
#define PERL_EXIT_DESTRUCT_END  0x02  /* Run END in perl_destruct */
#define PERL_EXIT_WARN		0x04  /* Warn if Perl_my_exit() or Perl_my_failure_exit() called */
#define PERL_EXIT_ABORT		0x08  /* Call abort() if Perl_my_exit() or Perl_my_failure_exit() called */

#ifndef PERL_CORE
/* format to use for version numbers in file/directory names */
/* XXX move to Configure? */
/* This was only ever used for the current version, and that can be done at
   compile time, as PERL_FS_VERSION, so should we just delete it?  */
#  ifndef PERL_FS_VER_FMT
#    define PERL_FS_VER_FMT	"%d.%d.%d"
#  endif
#endif

#ifndef PERL_FS_VERSION
#  define PERL_FS_VERSION	PERL_VERSION_STRING
#endif

/* This defines a way to flush all output buffers.  This may be a
 * performance issue, so we allow people to disable it.  Also, if
 * we are using stdio, there are broken implementations of fflush(NULL)
 * out there, Solaris being the most prominent.
 */
#ifndef PERL_FLUSHALL_FOR_CHILD
# if defined(USE_PERLIO) || defined(FFLUSH_NULL)
#  define PERL_FLUSHALL_FOR_CHILD	PerlIO_flush((PerlIO*)NULL)
# else
#  ifdef FFLUSH_ALL
#   define PERL_FLUSHALL_FOR_CHILD	my_fflush_all()
#  else
#   define PERL_FLUSHALL_FOR_CHILD	NOOP
#  endif
# endif
#endif

#ifndef PERL_WAIT_FOR_CHILDREN
#  define PERL_WAIT_FOR_CHILDREN	NOOP
#endif

/* the traditional thread-unsafe notion of "current interpreter". */
#ifndef PERL_SET_INTERP
#  define PERL_SET_INTERP(i)		(PL_curinterp = (PerlInterpreter*)(i))
#endif

#ifndef PERL_GET_INTERP
#  define PERL_GET_INTERP		(PL_curinterp)
#endif

#if defined(PERL_IMPLICIT_CONTEXT) && !defined(PERL_GET_THX)
#  ifdef MULTIPLICITY
#    define PERL_GET_THX		((PerlInterpreter *)PERL_GET_CONTEXT)
#  endif
#  define PERL_SET_THX(t)		PERL_SET_CONTEXT(t)
#endif

/*
    This replaces the previous %_ "hack" by the "%p" hacks.
    All that is required is that the perl source does not
    use "%-p" or "%-<number>p" or "%<number>p" formats.
    These formats will still work in perl code.
    See comments in sv.c for further details.

    Robin Barker 2005-07-14

    No longer use %1p for VDf = %vd.  RMB 2007-10-19
*/

#ifndef SVf_
#  define SVf_(n) "-" STRINGIFY(n) "p"
#endif

#ifndef SVf
#  define SVf "-p"
#endif

#ifndef SVf32
#  define SVf32 SVf_(32)
#endif

#ifndef SVf256
#  define SVf256 SVf_(256)
#endif

#define SVfARG(p) ((void*)(p))

#ifndef HEKf
#  define HEKf "2p"
#endif

/* Not ideal, but we cannot easily include a number in an already-numeric
 * format sequence. */
#ifndef HEKf256
#  define HEKf256 "3p"
#endif

#define HEKfARG(p) ((void*)(p))

/* Takes three arguments: is_utf8, length, str */
#ifndef UTF8f
#  define UTF8f "d%" UVuf "%4p"
#endif
#define UTF8fARG(u,l,p) (int)cBOOL(u), (UV)(l), (void*)(p)

#define PNf UTF8f
#define PNfARG(pn) (int)1, (UV)PadnameLEN(pn), (void *)PadnamePV(pn)

#ifdef PERL_CORE
/* not used; but needed for backward compatibility with XS code? - RMB */
#  undef UVf
#else
#  ifndef UVf
#    define UVf UVuf
#  endif
#endif

#ifdef HASATTRIBUTE_DEPRECATED
#  define __attribute__deprecated__         __attribute__((deprecated))
#endif
#ifdef HASATTRIBUTE_FORMAT
#  define __attribute__format__(x,y,z)      __attribute__((format(x,y,z)))
#endif
#ifdef HASATTRIBUTE_MALLOC
#  define __attribute__malloc__             __attribute__((__malloc__))
#endif
#ifdef HASATTRIBUTE_NONNULL
#  define __attribute__nonnull__(a)         __attribute__((nonnull(a)))
#endif
#ifdef HASATTRIBUTE_NORETURN
#  define __attribute__noreturn__           __attribute__((noreturn))
#endif
#ifdef HASATTRIBUTE_PURE
#  define __attribute__pure__               __attribute__((pure))
#endif
#ifdef HASATTRIBUTE_UNUSED
#  define __attribute__unused__             __attribute__((unused))
#endif
#ifdef HASATTRIBUTE_WARN_UNUSED_RESULT
#  define __attribute__warn_unused_result__ __attribute__((warn_unused_result))
#endif

/* If we haven't defined the attributes yet, define them to blank. */
#ifndef __attribute__deprecated__
#  define __attribute__deprecated__
#endif
#ifndef __attribute__format__
#  define __attribute__format__(x,y,z)
#endif
#ifndef __attribute__malloc__
#  define __attribute__malloc__
#endif
#ifndef __attribute__nonnull__
#  define __attribute__nonnull__(a)
#endif
#ifndef __attribute__noreturn__
#  define __attribute__noreturn__
#endif
#ifndef __attribute__pure__
#  define __attribute__pure__
#endif
#ifndef __attribute__unused__
#  define __attribute__unused__
#endif
#ifndef __attribute__warn_unused_result__
#  define __attribute__warn_unused_result__
#endif

#ifdef I_ASSERT
#  if !defined(DEBUGGING) && !defined(NDEBUG)
#    define NDEBUG 1
#  endif
#  include <assert.h>
#endif

/* For functions that are marked as __attribute__noreturn__, it's not
   appropriate to call return.  In either case, include the lint directive.
 */
#ifdef HASATTRIBUTE_NORETURN
#  define NORETURN_FUNCTION_END NOT_REACHED;
#else
#  define NORETURN_FUNCTION_END NOT_REACHED; return 0
#endif

/* Some OS warn on NULL format to printf */
#ifdef PRINTF_FORMAT_NULL_OK
#  define __attribute__format__null_ok__(x,y,z)  __attribute__format__(x,y,z)
#else
#  define __attribute__format__null_ok__(x,y,z)
#endif

#ifdef HAS_BUILTIN_EXPECT
#  define EXPECT(expr,val)                  __builtin_expect(expr,val)
#else
#  define EXPECT(expr,val)                  (expr)
#endif
#define LIKELY(cond)                        EXPECT(cBOOL(cond),TRUE)
#define UNLIKELY(cond)                      EXPECT(cBOOL(cond),FALSE)
#ifdef HAS_BUILTIN_CHOOSE_EXPR
/* placeholder */
#endif

/* STATIC_ASSERT_GLOBAL/STATIC_ASSERT_STMT are like assert(), but for compile
   time invariants. That is, their argument must be a constant expression that
   can be verified by the compiler. This expression can contain anything that's
   known to the compiler, e.g. #define constants, enums, or sizeof (...). If
   the expression evaluates to 0, compilation fails.
   Because they generate no runtime code (i.e.  their use is "free"), they're
   always active, even under non-DEBUGGING builds.
   STATIC_ASSERT_GLOBAL expands to a declaration and is suitable for use at
   file scope (outside of any function).
   STATIC_ASSERT_STMT expands to a statement and is suitable for use inside a
   function.
*/
#if (defined(static_assert) || (defined(__cplusplus) && __cplusplus >= 201103L)) && (!defined(__IBMC__) || __IBMC__ >= 1210)
/* static_assert is a macro defined in <assert.h> in C11 or a compiler
   builtin in C++11.
*/
/* IBM XL C V11 does not support _Static_assert, no matter what <assert.h> says */
#  define STATIC_ASSERT_GLOBAL(COND) static_assert(COND, #COND)
#else
/* We use a bit-field instead of an array because gcc accepts
   'typedef char x[n]' where n is not a compile-time constant.
   We want to enforce constantness.
*/
#  define STATIC_ASSERT_2(COND, SUFFIX) \
    typedef struct { \
        unsigned int _static_assertion_failed_##SUFFIX : (COND) ? 1 : -1; \
    } _static_assertion_failed_##SUFFIX PERL_UNUSED_DECL
#  define STATIC_ASSERT_1(COND, SUFFIX) STATIC_ASSERT_2(COND, SUFFIX)
#  define STATIC_ASSERT_GLOBAL(COND)    STATIC_ASSERT_1(COND, __LINE__)
#endif
/* We need this wrapper even in C11 because 'case X: static_assert(...);' is an
   error (static_assert is a declaration, and only statements can have labels).
*/
#define STATIC_ASSERT_STMT(COND)      do { STATIC_ASSERT_GLOBAL(COND); } while (0)

#ifndef __has_builtin
#  define __has_builtin(x) 0 /* not a clang style compiler */
#endif

/* ASSUME is like assert(), but it has a benefit in a release build. It is a
   hint to a compiler about a statement of fact in a function call free
   expression, which allows the compiler to generate better machine code.
   In a debug build, ASSUME(x) is a synonym for assert(x). ASSUME(0) means
   the control path is unreachable. In a for loop, ASSUME can be used to hint
   that a loop will run at least X times. ASSUME is based off MSVC's __assume
   intrinsic function, see its documents for more details.
*/

#ifndef DEBUGGING
#  if __has_builtin(__builtin_unreachable) \
     || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5 || __GNUC__ > 4) /* 4.5 -> */
#    define ASSUME(x) ((x) ? (void) 0 : __builtin_unreachable())
#  elif defined(_MSC_VER)
#    define ASSUME(x) __assume(x)
#  elif defined(__ARMCC_VERSION) /* untested */
#    define ASSUME(x) __promise(x)
#  else
/* a random compiler might define assert to its own special optimization token
   so pass it through to C lib as a last resort */
#    define ASSUME(x) assert(x)
#  endif
#else
#  define ASSUME(x) assert(x)
#endif

#define NOT_REACHED ASSUME(0)

/* Some unistd.h's give a prototype for pause() even though
   HAS_PAUSE ends up undefined.  This causes the #define
   below to be rejected by the compiler.  Sigh.
*/
#ifdef HAS_PAUSE
#define Pause	pause
#else
#define Pause() sleep((32767<<16)+32767)
#endif

#ifndef IOCPARM_LEN
#   ifdef IOCPARM_MASK
	/* on BSDish systems we're safe */
#	define IOCPARM_LEN(x)  (((x) >> 16) & IOCPARM_MASK)
#   else
#	if defined(_IOC_SIZE) && defined(__GLIBC__)
	/* on Linux systems we're safe; except when we're not [perl #38223] */
#	    define IOCPARM_LEN(x) (_IOC_SIZE(x) < 256 ? 256 : _IOC_SIZE(x))
#	else
	/* otherwise guess at what's safe */
#	    define IOCPARM_LEN(x)	256
#	endif
#   endif
#endif

#if defined(__CYGWIN__)
/* USEMYBINMODE
 *   This symbol, if defined, indicates that the program should
 *   use the routine my_binmode(FILE *fp, char iotype, int mode) to insure
 *   that a file is in "binary" mode -- that is, that no translation
 *   of bytes occurs on read or write operations.
 */
#  define USEMYBINMODE /**/
#  include <io.h> /* for setmode() prototype */
#  define my_binmode(fp, iotype, mode) \
            (PerlLIO_setmode(fileno(fp), mode) != -1 ? TRUE : FALSE)
#endif

#ifdef __CYGWIN__
void init_os_extras(void);
#endif

#ifdef UNION_ANY_DEFINITION
UNION_ANY_DEFINITION;
#else
union any {
    void*	any_ptr;
    I32		any_i32;
    U32		any_u32;
    IV		any_iv;
    UV		any_uv;
    long	any_long;
    bool	any_bool;
    void	(*any_dptr) (void*);
    void	(*any_dxptr) (pTHX_ void*);
};
#endif

typedef I32 (*filter_t) (pTHX_ int, SV *, int);

#define FILTER_READ(idx, sv, len)  filter_read(idx, sv, len)
#define FILTER_DATA(idx) \
	    (PL_parser ? AvARRAY(PL_parser->rsfp_filters)[idx] : NULL)
#define FILTER_ISREADER(idx) \
	    (PL_parser && PL_parser->rsfp_filters \
		&& idx >= AvFILLp(PL_parser->rsfp_filters))
#define PERL_FILTER_EXISTS(i) \
	    (PL_parser && PL_parser->rsfp_filters \
		&& (i) <= av_tindex(PL_parser->rsfp_filters))

#if defined(_AIX) && !defined(_AIX43)
#if defined(USE_REENTRANT) || defined(_REENTRANT) || defined(_THREAD_SAFE)
/* We cannot include <crypt.h> to get the struct crypt_data
 * because of setkey prototype problems when threading */
typedef        struct crypt_data {     /* straight from /usr/include/crypt.h */
    /* From OSF, Not needed in AIX
       char C[28], D[28];
    */
    char E[48];
    char KS[16][48];
    char block[66];
    char iobuf[16];
} CRYPTD;
#endif /* threading */
#endif /* AIX */

#ifndef PERL_CALLCONV
#  ifdef __cplusplus
#    define PERL_CALLCONV extern "C"
#  else
#    define PERL_CALLCONV
#  endif
#endif
#ifndef PERL_CALLCONV_NO_RET
#    define PERL_CALLCONV_NO_RET PERL_CALLCONV
#endif

/* PERL_STATIC_NO_RET is supposed to be equivalent to STATIC on builds that
   dont have a noreturn as a declaration specifier
*/
#ifndef PERL_STATIC_NO_RET
#  define PERL_STATIC_NO_RET STATIC
#endif
/* PERL_STATIC_NO_RET is supposed to be equivalent to PERL_STATIC_INLINE on
   builds that dont have a noreturn as a declaration specifier
*/
#ifndef PERL_STATIC_INLINE_NO_RET
#  define PERL_STATIC_INLINE_NO_RET PERL_STATIC_INLINE
#endif

#if !defined(OS2)
#  include "iperlsys.h"
#endif

#ifdef __LIBCATAMOUNT__
#undef HAS_PASSWD  /* unixish.h but not unixish enough. */
#undef HAS_GROUP
#define FAKE_BIT_BUCKET
#endif

/* [perl #22371] Algorimic Complexity Attack on Perl 5.6.1, 5.8.0.
 * Note that the USE_HASH_SEED and USE_HASH_SEED_EXPLICIT are *NOT*
 * defined by Configure, despite their names being similar to the
 * other defines like USE_ITHREADS.  Configure in fact knows nothing
 * about the randomised hashes.  Therefore to enable/disable the hash
 * randomisation defines use the Configure -Accflags=... instead. */
#if !defined(NO_HASH_SEED) && !defined(USE_HASH_SEED) && !defined(USE_HASH_SEED_EXPLICIT)
#  define USE_HASH_SEED
#endif

/* Win32 defines a type 'WORD' in windef.h, and AmigaOS in exec/types.h.
 * This conflicts with the enumerator 'WORD' defined in perly.h.
 * The yytokentype enum is only a debugging aid, so it's not really needed. */
#if defined(WIN32) || defined(__amigaos4__)
#  define YYTOKENTYPE
#endif
#include "perly.h"


/* macros to define bit-fields in structs. */
#ifndef PERL_BITFIELD8
#  define PERL_BITFIELD8 unsigned
#endif
#ifndef PERL_BITFIELD16
#  define PERL_BITFIELD16 unsigned
#endif
#ifndef PERL_BITFIELD32
#  define PERL_BITFIELD32 unsigned
#endif

#include "sv.h"
#include "regexp.h"
#include "util.h"
#include "form.h"
#include "gv.h"
#include "pad.h"
#include "cv.h"
#include "opnames.h"
#include "op.h"
#include "hv.h"
#include "cop.h"
#include "av.h"
#include "mg.h"
#include "scope.h"
#include "warnings.h"
#include "utf8.h"

/* these would be in doio.h if there was such a file */
#define my_stat()  my_stat_flags(SV_GMAGIC)
#define my_lstat() my_lstat_flags(SV_GMAGIC)

/* defined in sv.c, but also used in [ach]v.c */
#undef _XPV_HEAD
#undef _XPVMG_HEAD
#undef _XPVCV_COMMON

typedef struct _sublex_info SUBLEXINFO;
struct _sublex_info {
    U8 super_state;	/* lexer state to save */
    U16 sub_inwhat;	/* "lex_inwhat" to use */
    OP *sub_op;		/* "lex_op" to use */
    SV *repl;		/* replacement of s/// or y/// */
};

#include "parser.h"

typedef struct magic_state MGS;	/* struct magic_state defined in mg.c */

#if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_REGEXEC_C)

/* These have to be predeclared, as they are used in proto.h which is #included
 * before their definitions in regcomp.h. */

struct scan_data_t;
typedef struct regnode_charclass regnode_charclass;

struct regnode_charclass_class;

/* A hopefully less confusing name.  The sub-classes are all Posix classes only
 * used under /l matching */
typedef struct regnode_charclass_class regnode_charclass_posixl;

typedef struct regnode_ssc regnode_ssc;
typedef struct RExC_state_t RExC_state_t;
struct _reg_trie_data;

#endif

struct ptr_tbl_ent {
    struct ptr_tbl_ent*		next;
    const void*			oldval;
    void*			newval;
};

struct ptr_tbl {
    struct ptr_tbl_ent**	tbl_ary;
    UV				tbl_max;
    UV				tbl_items;
    struct ptr_tbl_arena	*tbl_arena;
    struct ptr_tbl_ent		*tbl_arena_next;
    struct ptr_tbl_ent		*tbl_arena_end;
};

#if defined(htonl) && !defined(HAS_HTONL)
#define HAS_HTONL
#endif
#if defined(htons) && !defined(HAS_HTONS)
#define HAS_HTONS
#endif
#if defined(ntohl) && !defined(HAS_NTOHL)
#define HAS_NTOHL
#endif
#if defined(ntohs) && !defined(HAS_NTOHS)
#define HAS_NTOHS
#endif
#ifndef HAS_HTONL
#define HAS_HTONS
#define HAS_HTONL
#define HAS_NTOHS
#define HAS_NTOHL
#  if (BYTEORDER & 0xffff) == 0x4321
/* Big endian system, so ntohl, ntohs, htonl and htons do not need to
   re-order their values. However, to behave identically to the alternative
   implementations, they should truncate to the correct size.  */
#    define ntohl(x)    ((x)&0xFFFFFFFF)
#    define htonl(x)    ntohl(x)
#    define ntohs(x)    ((x)&0xFFFF)
#    define htons(x)    ntohs(x)
#  elif BYTEORDER == 0x1234 || BYTEORDER == 0x12345678

/* Note that we can't straight out declare our own htonl and htons because
   the Win32 build process forcibly undefines HAS_HTONL etc for its miniperl,
   to avoid the overhead of initialising the socket subsystem, but the headers
   that *declare* the various functions are still seen. If we declare our own
   htonl etc they will clash with the declarations in the Win32 headers.  */

PERL_STATIC_INLINE U32
my_swap32(const U32 x) {
    return ((x & 0xFF) << 24) | ((x >> 24) & 0xFF)	
        | ((x & 0x0000FF00) << 8) | ((x & 0x00FF0000) >> 8);
}

PERL_STATIC_INLINE U16
my_swap16(const U16 x) {
    return ((x & 0xFF) << 8) | ((x >> 8) & 0xFF);
}

#    define htonl(x)    my_swap32(x)
#    define ntohl(x)    my_swap32(x)
#    define ntohs(x)    my_swap16(x)
#    define htons(x)    my_swap16(x)
#  else
#    error "Unsupported byteorder"
/* The C pre-processor doesn't let us return the value of BYTEORDER as part of
   the error message. Please check the value of the macro BYTEORDER, as defined
   in config.h. The values of BYTEORDER we expect are

	    big endian  little endian
   32 bit       0x4321  0x1234
   64 bit   0x87654321  0x12345678

   If you have a system with a different byte order, please see
   pod/perlhack.pod for how to submit a patch to add supporting code.
*/
#  endif
#endif

/*
 * Little-endian byte order functions - 'v' for 'VAX', or 'reVerse'.
 * -DWS
 */
#if BYTEORDER == 0x1234 || BYTEORDER == 0x12345678
/* Little endian system, so vtohl, vtohs, htovl and htovs do not need to
   re-order their values. However, to behave identically to the alternative
   implementations, they should truncate to the correct size.  */
#  define vtohl(x)      ((x)&0xFFFFFFFF)
#  define vtohs(x)      ((x)&0xFFFF)
#  define htovl(x)      vtohl(x)
#  define htovs(x)      vtohs(x)
#elif BYTEORDER == 0x4321 || BYTEORDER == 0x87654321
#  define vtohl(x)	((((x)&0xFF)<<24)	\
			+(((x)>>24)&0xFF)	\
			+(((x)&0x0000FF00)<<8)	\
			+(((x)&0x00FF0000)>>8)	)
#  define vtohs(x)	((((x)&0xFF)<<8) + (((x)>>8)&0xFF))
#  define htovl(x)	vtohl(x)
#  define htovs(x)	vtohs(x)
#else
#  error "Unsupported byteorder"
/* If you have need for current perl on PDP-11 or similar, and can help test
   that blead keeps working on a mixed-endian system, then see
   pod/perlhack.pod for how to submit patches to things working again.  */
#endif

/* *MAX Plus 1. A floating point value.
   Hopefully expressed in a way that dodgy floating point can't mess up.
   >> 2 rather than 1, so that value is safely less than I32_MAX after 1
   is added to it
   May find that some broken compiler will want the value cast to I32.
   [after the shift, as signed >> may not be as secure as unsigned >>]
*/
#define I32_MAX_P1 (2.0 * (1 + (((U32)I32_MAX) >> 1)))
#define U32_MAX_P1 (4.0 * (1 + ((U32_MAX) >> 2)))
/* For compilers that can't correctly cast NVs over 0x7FFFFFFF (or
   0x7FFFFFFFFFFFFFFF) to an unsigned integer. In the future, sizeof(UV)
   may be greater than sizeof(IV), so don't assume that half max UV is max IV.
*/
#define U32_MAX_P1_HALF (2.0 * (1 + ((U32_MAX) >> 2)))

#define UV_MAX_P1 (4.0 * (1 + ((UV_MAX) >> 2)))
#define IV_MAX_P1 (2.0 * (1 + (((UV)IV_MAX) >> 1)))
#define UV_MAX_P1_HALF (2.0 * (1 + ((UV_MAX) >> 2)))

/* This may look like unnecessary jumping through hoops, but converting
   out of range floating point values to integers *is* undefined behaviour,
   and it is starting to bite.
*/
#ifndef CAST_INLINE
#define I_32(what) (cast_i32((NV)(what)))
#define U_32(what) (cast_ulong((NV)(what)))
#define I_V(what) (cast_iv((NV)(what)))
#define U_V(what) (cast_uv((NV)(what)))
#else
#define I_32(n) ((n) < I32_MAX_P1 ? ((n) < I32_MIN ? I32_MIN : (I32) (n)) \
                  : ((n) < U32_MAX_P1 ? (I32)(U32) (n) \
                     : ((n) > 0 ? (I32) U32_MAX : 0 /* NaN */)))
#define U_32(n) ((n) < 0.0 ? ((n) < I32_MIN ? (UV) I32_MIN : (U32)(I32) (n)) \
                  : ((n) < U32_MAX_P1 ? (U32) (n) \
                     : ((n) > 0 ? U32_MAX : 0 /* NaN */)))
#define I_V(n) (LIKELY((n) < IV_MAX_P1) ? (UNLIKELY((n) < IV_MIN) ? IV_MIN : (IV) (n)) \
                  : (LIKELY((n) < UV_MAX_P1) ? (IV)(UV) (n) \
                     : ((n) > 0 ? (IV)UV_MAX : 0 /* NaN */)))
#define U_V(n) ((n) < 0.0 ? (UNLIKELY((n) < IV_MIN) ? (UV) IV_MIN : (UV)(IV) (n)) \
                  : (LIKELY((n) < UV_MAX_P1) ? (UV) (n) \
                     : ((n) > 0 ? UV_MAX : 0 /* NaN */)))
#endif

#define U_S(what) ((U16)U_32(what))
#define U_I(what) ((unsigned int)U_32(what))
#define U_L(what) U_32(what)

#ifdef HAS_SIGNBIT
#  define Perl_signbit signbit
#endif

/* These do not care about the fractional part, only about the range. */
#define NV_WITHIN_IV(nv) (I_V(nv) >= IV_MIN && I_V(nv) <= IV_MAX)
#define NV_WITHIN_UV(nv) ((nv)>=0.0 && U_V(nv) >= UV_MIN && U_V(nv) <= UV_MAX)

/* Used with UV/IV arguments: */
					/* XXXX: need to speed it up */
#define CLUMP_2UV(iv)	((iv) < 0 ? 0 : (UV)(iv))
#define CLUMP_2IV(uv)	((uv) > (UV)IV_MAX ? IV_MAX : (IV)(uv))

#ifndef MAXSYSFD
#   define MAXSYSFD 2
#endif

#ifndef __cplusplus
#if !(defined(WIN32) || defined(UNDER_CE) || defined(SYMBIAN))
Uid_t getuid (void);
Uid_t geteuid (void);
Gid_t getgid (void);
Gid_t getegid (void);
#endif
#endif

#ifndef Perl_debug_log
#  define Perl_debug_log	PerlIO_stderr()
#endif

#ifndef Perl_error_log
#  define Perl_error_log	(PL_stderrgv			\
				 && isGV(PL_stderrgv)		\
				 && GvIOp(PL_stderrgv)          \
				 && IoOFP(GvIOp(PL_stderrgv))	\
				 ? IoOFP(GvIOp(PL_stderrgv))	\
				 : PerlIO_stderr())
#endif


#define DEBUG_p_FLAG		0x00000001 /*      1 */
#define DEBUG_s_FLAG		0x00000002 /*      2 */
#define DEBUG_l_FLAG		0x00000004 /*      4 */
#define DEBUG_t_FLAG		0x00000008 /*      8 */
#define DEBUG_o_FLAG		0x00000010 /*     16 */
#define DEBUG_c_FLAG		0x00000020 /*     32 */
#define DEBUG_P_FLAG		0x00000040 /*     64 */
#define DEBUG_m_FLAG		0x00000080 /*    128 */
#define DEBUG_f_FLAG		0x00000100 /*    256 */
#define DEBUG_r_FLAG		0x00000200 /*    512 */
#define DEBUG_x_FLAG		0x00000400 /*   1024 */
#define DEBUG_u_FLAG		0x00000800 /*   2048 */
/* U is reserved for Unofficial, exploratory hacking */
#define DEBUG_U_FLAG		0x00001000 /*   4096 */
#define DEBUG_H_FLAG		0x00002000 /*   8192 */
#define DEBUG_X_FLAG		0x00004000 /*  16384 */
#define DEBUG_D_FLAG		0x00008000 /*  32768 */
#define DEBUG_S_FLAG		0x00010000 /*  65536 */
#define DEBUG_T_FLAG		0x00020000 /* 131072 */
#define DEBUG_R_FLAG		0x00040000 /* 262144 */
#define DEBUG_J_FLAG		0x00080000 /* 524288 */
#define DEBUG_v_FLAG		0x00100000 /*1048576 */
#define DEBUG_C_FLAG		0x00200000 /*2097152 */
#define DEBUG_A_FLAG		0x00400000 /*4194304 */
#define DEBUG_q_FLAG		0x00800000 /*8388608 */
#define DEBUG_M_FLAG		0x01000000 /*16777216*/
#define DEBUG_B_FLAG		0x02000000 /*33554432*/
#define DEBUG_L_FLAG		0x04000000 /*67108864*/
#define DEBUG_i_FLAG		0x08000000 /*134217728*/
#define DEBUG_MASK		0x0FFFEFFF /* mask of all the standard flags */

#define DEBUG_DB_RECURSE_FLAG	0x40000000
#define DEBUG_TOP_FLAG		0x80000000 /* -D was given --> PL_debug |= FLAG */

#  define DEBUG_p_TEST_ (PL_debug & DEBUG_p_FLAG)
#  define DEBUG_s_TEST_ (PL_debug & DEBUG_s_FLAG)
#  define DEBUG_l_TEST_ (PL_debug & DEBUG_l_FLAG)
#  define DEBUG_t_TEST_ (PL_debug & DEBUG_t_FLAG)
#  define DEBUG_o_TEST_ (PL_debug & DEBUG_o_FLAG)
#  define DEBUG_c_TEST_ (PL_debug & DEBUG_c_FLAG)
#  define DEBUG_P_TEST_ (PL_debug & DEBUG_P_FLAG)
#  define DEBUG_m_TEST_ (PL_debug & DEBUG_m_FLAG)
#  define DEBUG_f_TEST_ (PL_debug & DEBUG_f_FLAG)
#  define DEBUG_r_TEST_ (PL_debug & DEBUG_r_FLAG)
#  define DEBUG_x_TEST_ (PL_debug & DEBUG_x_FLAG)
#  define DEBUG_u_TEST_ (PL_debug & DEBUG_u_FLAG)
#  define DEBUG_U_TEST_ (PL_debug & DEBUG_U_FLAG)
#  define DEBUG_H_TEST_ (PL_debug & DEBUG_H_FLAG)
#  define DEBUG_X_TEST_ (PL_debug & DEBUG_X_FLAG)
#  define DEBUG_D_TEST_ (PL_debug & DEBUG_D_FLAG)
#  define DEBUG_S_TEST_ (PL_debug & DEBUG_S_FLAG)
#  define DEBUG_T_TEST_ (PL_debug & DEBUG_T_FLAG)
#  define DEBUG_R_TEST_ (PL_debug & DEBUG_R_FLAG)
#  define DEBUG_J_TEST_ (PL_debug & DEBUG_J_FLAG)
#  define DEBUG_v_TEST_ (PL_debug & DEBUG_v_FLAG)
#  define DEBUG_C_TEST_ (PL_debug & DEBUG_C_FLAG)
#  define DEBUG_A_TEST_ (PL_debug & DEBUG_A_FLAG)
#  define DEBUG_q_TEST_ (PL_debug & DEBUG_q_FLAG)
#  define DEBUG_M_TEST_ (PL_debug & DEBUG_M_FLAG)
#  define DEBUG_B_TEST_ (PL_debug & DEBUG_B_FLAG)
#  define DEBUG_L_TEST_ (PL_debug & DEBUG_L_FLAG)
#  define DEBUG_i_TEST_ (PL_debug & DEBUG_i_FLAG)
#  define DEBUG_Xv_TEST_ (DEBUG_X_TEST_ && DEBUG_v_TEST_)
#  define DEBUG_Uv_TEST_ (DEBUG_U_TEST_ && DEBUG_v_TEST_)
#  define DEBUG_Pv_TEST_ (DEBUG_P_TEST_ && DEBUG_v_TEST_)
#  define DEBUG_Lv_TEST_ (DEBUG_L_TEST_ && DEBUG_v_TEST_)

#ifdef DEBUGGING

#  define DEBUG_p_TEST DEBUG_p_TEST_
#  define DEBUG_s_TEST DEBUG_s_TEST_
#  define DEBUG_l_TEST DEBUG_l_TEST_
#  define DEBUG_t_TEST DEBUG_t_TEST_
#  define DEBUG_o_TEST DEBUG_o_TEST_
#  define DEBUG_c_TEST DEBUG_c_TEST_
#  define DEBUG_P_TEST DEBUG_P_TEST_
#  define DEBUG_m_TEST DEBUG_m_TEST_
#  define DEBUG_f_TEST DEBUG_f_TEST_
#  define DEBUG_r_TEST DEBUG_r_TEST_
#  define DEBUG_x_TEST DEBUG_x_TEST_
#  define DEBUG_u_TEST DEBUG_u_TEST_
#  define DEBUG_U_TEST DEBUG_U_TEST_
#  define DEBUG_H_TEST DEBUG_H_TEST_
#  define DEBUG_X_TEST DEBUG_X_TEST_
#  define DEBUG_D_TEST DEBUG_D_TEST_
#  define DEBUG_S_TEST DEBUG_S_TEST_
#  define DEBUG_T_TEST DEBUG_T_TEST_
#  define DEBUG_R_TEST DEBUG_R_TEST_
#  define DEBUG_J_TEST DEBUG_J_TEST_
#  define DEBUG_v_TEST DEBUG_v_TEST_
#  define DEBUG_C_TEST DEBUG_C_TEST_
#  define DEBUG_A_TEST DEBUG_A_TEST_
#  define DEBUG_q_TEST DEBUG_q_TEST_
#  define DEBUG_M_TEST DEBUG_M_TEST_
#  define DEBUG_B_TEST DEBUG_B_TEST_
#  define DEBUG_L_TEST DEBUG_L_TEST_
#  define DEBUG_i_TEST DEBUG_i_TEST_
#  define DEBUG_Xv_TEST DEBUG_Xv_TEST_
#  define DEBUG_Uv_TEST DEBUG_Uv_TEST_
#  define DEBUG_Pv_TEST DEBUG_Pv_TEST_
#  define DEBUG_Lv_TEST DEBUG_Lv_TEST_

#  define PERL_DEB(a)                  a
#  define PERL_DEB2(a,b)               a
#  define PERL_DEBUG(a) if (PL_debug)  a
#  define DEBUG_p(a) if (DEBUG_p_TEST) a
#  define DEBUG_s(a) if (DEBUG_s_TEST) a
#  define DEBUG_l(a) if (DEBUG_l_TEST) a
#  define DEBUG_t(a) if (DEBUG_t_TEST) a
#  define DEBUG_o(a) if (DEBUG_o_TEST) a
#  define DEBUG_c(a) if (DEBUG_c_TEST) a
#  define DEBUG_P(a) if (DEBUG_P_TEST) a

     /* Temporarily turn off memory debugging in case the a
      * does memory allocation, either directly or indirectly. */
#  define DEBUG_m(a)  \
    STMT_START {							\
        if (PERL_GET_INTERP) { dTHX; if (DEBUG_m_TEST) {PL_debug&=~DEBUG_m_FLAG; a; PL_debug|=DEBUG_m_FLAG;} } \
    } STMT_END

#  define DEBUG__(t, a) \
	STMT_START { \
		if (t) STMT_START {a;} STMT_END; \
	} STMT_END

#  define DEBUG_f(a) DEBUG__(DEBUG_f_TEST, a)
#ifndef PERL_EXT_RE_BUILD
#  define DEBUG_r(a) DEBUG__(DEBUG_r_TEST, a)
#else
#  define DEBUG_r(a) STMT_START {a;} STMT_END
#endif /* PERL_EXT_RE_BUILD */
#  define DEBUG_x(a) DEBUG__(DEBUG_x_TEST, a)
#  define DEBUG_u(a) DEBUG__(DEBUG_u_TEST, a)
#  define DEBUG_U(a) DEBUG__(DEBUG_U_TEST, a)
#  define DEBUG_H(a) DEBUG__(DEBUG_H_TEST, a)
#  define DEBUG_X(a) DEBUG__(DEBUG_X_TEST, a)
#  define DEBUG_D(a) DEBUG__(DEBUG_D_TEST, a)
#  define DEBUG_Xv(a) DEBUG__(DEBUG_Xv_TEST, a)
#  define DEBUG_Uv(a) DEBUG__(DEBUG_Uv_TEST, a)
#  define DEBUG_Pv(a) DEBUG__(DEBUG_Pv_TEST, a)
#  define DEBUG_Lv(a) DEBUG__(DEBUG_Lv_TEST, a)

#  define DEBUG_S(a) DEBUG__(DEBUG_S_TEST, a)
#  define DEBUG_T(a) DEBUG__(DEBUG_T_TEST, a)
#  define DEBUG_R(a) DEBUG__(DEBUG_R_TEST, a)
#  define DEBUG_v(a) DEBUG__(DEBUG_v_TEST, a)
#  define DEBUG_C(a) DEBUG__(DEBUG_C_TEST, a)
#  define DEBUG_A(a) DEBUG__(DEBUG_A_TEST, a)
#  define DEBUG_q(a) DEBUG__(DEBUG_q_TEST, a)
#  define DEBUG_M(a) DEBUG__(DEBUG_M_TEST, a)
#  define DEBUG_B(a) DEBUG__(DEBUG_B_TEST, a)
#  define DEBUG_L(a) DEBUG__(DEBUG_L_TEST, a)
#  define DEBUG_i(a) DEBUG__(DEBUG_i_TEST, a)

#else /* DEBUGGING */

#  define DEBUG_p_TEST (0)
#  define DEBUG_s_TEST (0)
#  define DEBUG_l_TEST (0)
#  define DEBUG_t_TEST (0)
#  define DEBUG_o_TEST (0)
#  define DEBUG_c_TEST (0)
#  define DEBUG_P_TEST (0)
#  define DEBUG_m_TEST (0)
#  define DEBUG_f_TEST (0)
#  define DEBUG_r_TEST (0)
#  define DEBUG_x_TEST (0)
#  define DEBUG_u_TEST (0)
#  define DEBUG_U_TEST (0)
#  define DEBUG_H_TEST (0)
#  define DEBUG_X_TEST (0)
#  define DEBUG_D_TEST (0)
#  define DEBUG_S_TEST (0)
#  define DEBUG_T_TEST (0)
#  define DEBUG_R_TEST (0)
#  define DEBUG_J_TEST (0)
#  define DEBUG_v_TEST (0)
#  define DEBUG_C_TEST (0)
#  define DEBUG_A_TEST (0)
#  define DEBUG_q_TEST (0)
#  define DEBUG_M_TEST (0)
#  define DEBUG_B_TEST (0)
#  define DEBUG_L_TEST (0)
#  define DEBUG_i_TEST (0)
#  define DEBUG_Xv_TEST (0)
#  define DEBUG_Uv_TEST (0)
#  define DEBUG_Pv_TEST (0)
#  define DEBUG_Lv_TEST (0)

#  define PERL_DEB(a)
#  define PERL_DEB2(a,b)               b
#  define PERL_DEBUG(a)
#  define DEBUG_p(a)
#  define DEBUG_s(a)
#  define DEBUG_l(a)
#  define DEBUG_t(a)
#  define DEBUG_o(a)
#  define DEBUG_c(a)
#  define DEBUG_P(a)
#  define DEBUG_m(a)
#  define DEBUG_f(a)
#  define DEBUG_r(a)
#  define DEBUG_x(a)
#  define DEBUG_u(a)
#  define DEBUG_U(a)
#  define DEBUG_H(a)
#  define DEBUG_X(a)
#  define DEBUG_D(a)
#  define DEBUG_S(a)
#  define DEBUG_T(a)
#  define DEBUG_R(a)
#  define DEBUG_v(a)
#  define DEBUG_C(a)
#  define DEBUG_A(a)
#  define DEBUG_q(a)
#  define DEBUG_M(a)
#  define DEBUG_B(a)
#  define DEBUG_L(a)
#  define DEBUG_i(a)
#  define DEBUG_Xv(a)
#  define DEBUG_Uv(a)
#  define DEBUG_Pv(a)
#  define DEBUG_Lv(a)
#endif /* DEBUGGING */


#define DEBUG_SCOPE(where) \
    DEBUG_l( \
    Perl_deb(aTHX_ "%s scope %ld (savestack=%ld) at %s:%d\n",	\
		    where, (long)PL_scopestack_ix, (long)PL_savestack_ix, \
		    __FILE__, __LINE__));

/* Keep the old croak based assert for those who want it, and as a fallback if
   the platform is so heretically non-ANSI that it can't assert.  */

#define Perl_assert(what)	PERL_DEB2( 				\
	((what) ? ((void) 0) :						\
	    (Perl_croak_nocontext("Assertion %s failed: file \"" __FILE__ \
			"\", line %d", STRINGIFY(what), __LINE__),	\
             (void) 0)), ((void)0))

/* assert() gets defined if DEBUGGING (and I_ASSERT).
 * If no DEBUGGING, the <assert.h> has not been included. */
#ifndef assert
#  define assert(what)	Perl_assert(what)
#endif
#ifdef DEBUGGING
#  define assert_(what)	assert(what),
#else
#  define assert_(what)
#endif

struct ufuncs {
    I32 (*uf_val)(pTHX_ IV, SV*);
    I32 (*uf_set)(pTHX_ IV, SV*);
    IV uf_index;
};

/* In pre-5.7-Perls the PERL_MAGIC_uvar magic didn't get the thread context.
 * XS code wanting to be backward compatible can do something
 * like the following:

#ifndef PERL_MG_UFUNC
#define PERL_MG_UFUNC(name,ix,sv) I32 name(IV ix, SV *sv)
#endif

static PERL_MG_UFUNC(foo_get, index, val)
{
    sv_setsv(val, ...);
    return TRUE;
}

-- Doug MacEachern

*/

#ifndef PERL_MG_UFUNC
#define PERL_MG_UFUNC(name,ix,sv) I32 name(pTHX_ IV ix, SV *sv)
#endif

/* Fix these up for __STDC__ */
#ifndef DONT_DECLARE_STD
char *mktemp (char*);
#ifndef atof
double atof (const char*);
#endif
#endif

#ifndef STANDARD_C
/* All of these are in stdlib.h or time.h for ANSI C */
Time_t time();
struct tm *gmtime(), *localtime();
#if defined(OEMVS)
char *(strchr)(), *(strrchr)();
char *(strcpy)(), *(strcat)();
#else
char *strchr(), *strrchr();
char *strcpy(), *strcat();
#endif
#endif /* ! STANDARD_C */


#ifdef I_MATH
#    include <math.h>
#    ifdef __VMS
     /* isfinite and others are here rather than in math.h as C99 stipulates */
#        include <fp.h>
#    endif
#else
START_EXTERN_C
	    double exp (double);
	    double log (double);
	    double log10 (double);
	    double sqrt (double);
	    double frexp (double,int*);
	    double ldexp (double,int);
	    double modf (double,double*);
	    double sin (double);
	    double cos (double);
	    double atan2 (double,double);
	    double pow (double,double);
END_EXTERN_C
#endif

#ifndef __cplusplus
#  if !defined(WIN32) && !defined(VMS)
#ifndef crypt
char *crypt (const char*, const char*);
#endif
#  endif /* !WIN32 */
#  ifndef DONT_DECLARE_STD
#    ifndef getenv
char *getenv (const char*);
#    endif /* !getenv */
#    if !defined(HAS_LSEEK_PROTO) && !defined(__hpux)
#      ifdef _FILE_OFFSET_BITS
#        if _FILE_OFFSET_BITS == 64
Off_t lseek (int,Off_t,int);
#        endif
#      endif
#    endif
#  endif /* !DONT_DECLARE_STD */
#  ifndef WIN32
#    ifndef getlogin
char *getlogin (void);
#    endif
#  endif /* !WIN32 */
#endif /* !__cplusplus */

/* Fixme on VMS.  This needs to be a run-time, not build time options */
/* Also rename() is affected by this */
#ifdef UNLINK_ALL_VERSIONS /* Currently only makes sense for VMS */
#define UNLINK unlnk
I32 unlnk (pTHX_ const char*);
#else
#define UNLINK PerlLIO_unlink
#endif

/* some versions of glibc are missing the setresuid() proto */
#if defined(HAS_SETRESUID) && !defined(HAS_SETRESUID_PROTO)
int setresuid(uid_t ruid, uid_t euid, uid_t suid);
#endif
/* some versions of glibc are missing the setresgid() proto */
#if defined(HAS_SETRESGID) && !defined(HAS_SETRESGID_PROTO)
int setresgid(gid_t rgid, gid_t egid, gid_t sgid);
#endif

#ifndef HAS_SETREUID
#  ifdef HAS_SETRESUID
#    define setreuid(r,e) setresuid(r,e,(Uid_t)-1)
#    define HAS_SETREUID
#  endif
#endif
#ifndef HAS_SETREGID
#  ifdef HAS_SETRESGID
#    define setregid(r,e) setresgid(r,e,(Gid_t)-1)
#    define HAS_SETREGID
#  endif
#endif

/* Sighandler_t defined in iperlsys.h */

#ifdef HAS_SIGACTION
typedef struct sigaction Sigsave_t;
#else
typedef Sighandler_t Sigsave_t;
#endif

#define SCAN_DEF 0
#define SCAN_TR 1
#define SCAN_REPL 2

#ifdef DEBUGGING
# ifndef register
#  define register
# endif
# define RUNOPS_DEFAULT Perl_runops_debug
#else
# define RUNOPS_DEFAULT Perl_runops_standard
#endif

#if defined(USE_PERLIO)
EXTERN_C void PerlIO_teardown(void);
# ifdef USE_ITHREADS
#  define PERLIO_INIT MUTEX_INIT(&PL_perlio_mutex)
#  define PERLIO_TERM 				\
	STMT_START {				\
		PerlIO_teardown();		\
		MUTEX_DESTROY(&PL_perlio_mutex);\
	} STMT_END
# else
#  define PERLIO_INIT
#  define PERLIO_TERM	PerlIO_teardown()
# endif
#else
#  define PERLIO_INIT
#  define PERLIO_TERM
#endif

#ifdef MYMALLOC
#  ifdef MUTEX_INIT_CALLS_MALLOC
#    define MALLOC_INIT					\
	STMT_START {					\
		PL_malloc_mutex = NULL;			\
		MUTEX_INIT(&PL_malloc_mutex);		\
	} STMT_END
#    define MALLOC_TERM					\
	STMT_START {					\
		perl_mutex tmp = PL_malloc_mutex;	\
		PL_malloc_mutex = NULL;			\
		MUTEX_DESTROY(&tmp);			\
	} STMT_END
#  else
#    define MALLOC_INIT MUTEX_INIT(&PL_malloc_mutex)
#    define MALLOC_TERM MUTEX_DESTROY(&PL_malloc_mutex)
#  endif
#else
#  define MALLOC_INIT
#  define MALLOC_TERM
#endif

#if defined(PERL_IMPLICIT_CONTEXT)

struct perl_memory_debug_header;
struct perl_memory_debug_header {
  tTHX	interpreter;
#  if defined(PERL_POISON) || defined(PERL_DEBUG_READONLY_COW)
  MEM_SIZE size;
#  endif
  struct perl_memory_debug_header *prev;
  struct perl_memory_debug_header *next;
#  ifdef PERL_DEBUG_READONLY_COW
  bool readonly;
#  endif
};

#elif defined(PERL_DEBUG_READONLY_COW)

struct perl_memory_debug_header;
struct perl_memory_debug_header {
  MEM_SIZE size;
};

#endif

#if defined (PERL_TRACK_MEMPOOL) || defined (PERL_DEBUG_READONLY_COW)

#  define PERL_MEMORY_DEBUG_HEADER_SIZE \
        (sizeof(struct perl_memory_debug_header) + \
	(MEM_ALIGNBYTES - sizeof(struct perl_memory_debug_header) \
	 %MEM_ALIGNBYTES) % MEM_ALIGNBYTES)

#else
#  define PERL_MEMORY_DEBUG_HEADER_SIZE	0
#endif

#ifdef PERL_TRACK_MEMPOOL
# ifdef PERL_DEBUG_READONLY_COW
#  define INIT_TRACK_MEMPOOL(header, interp)			\
	STMT_START {						\
		(header).interpreter = (interp);		\
		(header).prev = (header).next = &(header);	\
		(header).readonly = 0;				\
	} STMT_END
# else
#  define INIT_TRACK_MEMPOOL(header, interp)			\
	STMT_START {						\
		(header).interpreter = (interp);		\
		(header).prev = (header).next = &(header);	\
	} STMT_END
# endif
# else
#  define INIT_TRACK_MEMPOOL(header, interp)
#endif

#ifdef I_MALLOCMALLOC
/* Needed for malloc_size(), malloc_good_size() on some systems */
#  include <malloc/malloc.h>
#endif

#ifdef MYMALLOC
#  define Perl_safesysmalloc_size(where)	Perl_malloced_size(where)
#else
#  if defined(HAS_MALLOC_SIZE) && !defined(PERL_DEBUG_READONLY_COW)
#    ifdef PERL_TRACK_MEMPOOL
#	define Perl_safesysmalloc_size(where)			\
	    (malloc_size(((char *)(where)) - PERL_MEMORY_DEBUG_HEADER_SIZE) - PERL_MEMORY_DEBUG_HEADER_SIZE)
#    else
#	define Perl_safesysmalloc_size(where) malloc_size(where)
#    endif
#  endif
#  ifdef HAS_MALLOC_GOOD_SIZE
#    ifdef PERL_TRACK_MEMPOOL
#	define Perl_malloc_good_size(how_much)			\
	    (malloc_good_size((how_much) + PERL_MEMORY_DEBUG_HEADER_SIZE) - PERL_MEMORY_DEBUG_HEADER_SIZE)
#    else
#	define Perl_malloc_good_size(how_much) malloc_good_size(how_much)
#    endif
#  else
/* Having this as the identity operation makes some code simpler.  */
#	define Perl_malloc_good_size(how_much)	(how_much)
#  endif
#endif

typedef int (*runops_proc_t)(pTHX);
typedef void (*share_proc_t) (pTHX_ SV *sv);
typedef int  (*thrhook_proc_t) (pTHX);
typedef OP* (*PPADDR_t[]) (pTHX);
typedef bool (*destroyable_proc_t) (pTHX_ SV *sv);
typedef void (*despatch_signals_proc_t) (pTHX);

#if defined(__DYNAMIC__) && defined(PERL_DARWIN) && defined(PERL_CORE)
#  include <crt_externs.h>	/* for the env array */
#  define environ (*_NSGetEnviron())
#else
   /* VMS and some other platforms don't use the environ array */
#  ifdef USE_ENVIRON_ARRAY
#    if !defined(DONT_DECLARE_STD) || \
        (defined(__svr4__) && defined(__GNUC__) && defined(__sun)) || \
        defined(__sgi)
extern char **	environ;	/* environment variables supplied via exec */
#    endif
#  endif
#endif

#define PERL_PATCHLEVEL_H_IMPLICIT
#include "patchlevel.h"
#undef PERL_PATCHLEVEL_H_IMPLICIT

#define PERL_VERSION_STRING	STRINGIFY(PERL_REVISION) "." \
				STRINGIFY(PERL_VERSION) "." \
				STRINGIFY(PERL_SUBVERSION)

#define PERL_API_VERSION_STRING	STRINGIFY(PERL_API_REVISION) "." \
				STRINGIFY(PERL_API_VERSION) "." \
				STRINGIFY(PERL_API_SUBVERSION)

START_EXTERN_C

/* handy constants */
EXTCONST char PL_warn_uninit[]
  INIT("Use of uninitialized value%s%s%s");
EXTCONST char PL_warn_uninit_sv[]
  INIT("Use of uninitialized value%" SVf "%s%s");
EXTCONST char PL_warn_nosemi[]
  INIT("Semicolon seems to be missing");
EXTCONST char PL_warn_reserved[]
  INIT("Unquoted string \"%s\" may clash with future reserved word");
EXTCONST char PL_warn_nl[]
  INIT("Unsuccessful %s on filename containing newline");
EXTCONST char PL_no_wrongref[]
  INIT("Can't use %s ref as %s ref");
/* The core no longer needs this here. If you require the string constant,
   please inline a copy into your own code.  */
EXTCONST char PL_no_symref[] __attribute__deprecated__
  INIT("Can't use string (\"%.32s\") as %s ref while \"strict refs\" in use");
EXTCONST char PL_no_symref_sv[]
  INIT("Can't use string (\"%" SVf32 "\"%s) as %s ref while \"strict refs\" in use");

EXTCONST char PL_no_usym[]
  INIT("Can't use an undefined value as %s reference");
EXTCONST char PL_no_aelem[]
  INIT("Modification of non-creatable array value attempted, subscript %d");
EXTCONST char PL_no_helem_sv[]
  INIT("Modification of non-creatable hash value attempted, subscript \"%" SVf "\"");
EXTCONST char PL_no_modify[]
  INIT("Modification of a read-only value attempted");
EXTCONST char PL_no_mem[sizeof("Out of memory!\n")]
  INIT("Out of memory!\n");
EXTCONST char PL_no_security[]
  INIT("Insecure dependency in %s%s");
EXTCONST char PL_no_sock_func[]
  INIT("Unsupported socket function \"%s\" called");
EXTCONST char PL_no_dir_func[]
  INIT("Unsupported directory function \"%s\" called");
EXTCONST char PL_no_func[]
  INIT("The %s function is unimplemented");
EXTCONST char PL_no_myglob[]
  INIT("\"%s\" %se %s can't be in a package");
EXTCONST char PL_no_localize_ref[]
  INIT("Can't localize through a reference");
EXTCONST char PL_memory_wrap[]
  INIT("panic: memory wrap");

EXTCONST char PL_Yes[]
  INIT("1");
EXTCONST char PL_No[]
  INIT("");
EXTCONST char PL_hexdigit[]
  INIT("0123456789abcdef0123456789ABCDEF");

/* This is constant on most architectures, a global on OS/2 */
#ifndef OS2
EXTCONST char PL_sh_path[]
  INIT(SH_PATH); /* full path of shell */
#endif

#ifdef CSH
EXTCONST char PL_cshname[]
  INIT(CSH);
#  define PL_cshlen	(sizeof(CSH "") - 1)
#endif

/* These are baked at compile time into any shared perl library.
   In future releases this will allow us in main() to sanity test the
   library we're linking against.  */

EXTCONST U8 PL_revision
  INIT(PERL_REVISION);
EXTCONST U8 PL_version
  INIT(PERL_VERSION);
EXTCONST U8 PL_subversion
  INIT(PERL_SUBVERSION);

EXTCONST char PL_uuemap[65]
  INIT("`!\"#$%&'()*+,-./0123456789:;<=>?@@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_");

#ifdef DOINIT
EXTCONST char PL_uudmap[256] =
#  ifdef PERL_MICRO
#    include "uuudmap.h"
#  else
#    include "uudmap.h"
#  endif
;
EXTCONST char PL_bitcount[256] =
#  ifdef PERL_MICRO
#    include "ubitcount.h"
#else
#    include "bitcount.h"
#  endif
;
EXTCONST char* const PL_sig_name[] = { SIG_NAME };
EXTCONST int         PL_sig_num[]  = { SIG_NUM };
#else
EXTCONST char PL_uudmap[256];
EXTCONST char PL_bitcount[256];
EXTCONST char* const PL_sig_name[];
EXTCONST int         PL_sig_num[];
#endif

/* fast conversion and case folding tables.  The folding tables complement the
 * fold, so that 'a' maps to 'A' and 'A' maps to 'a', ignoring more complicated
 * folds such as outside the range or to multiple characters. */

#ifdef DOINIT
#ifndef EBCDIC

/* The EBCDIC fold table depends on the code page, and hence is found in
 * utfebcdic.h */

EXTCONST  unsigned char PL_fold[] = {
	0,	1,	2,	3,	4,	5,	6,	7,
	8,	9,	10,	11,	12,	13,	14,	15,
	16,	17,	18,	19,	20,	21,	22,	23,
	24,	25,	26,	27,	28,	29,	30,	31,
	32,	33,	34,	35,	36,	37,	38,	39,
	40,	41,	42,	43,	44,	45,	46,	47,
	48,	49,	50,	51,	52,	53,	54,	55,
	56,	57,	58,	59,	60,	61,	62,	63,
	64,	'a',	'b',	'c',	'd',	'e',	'f',	'g',
	'h',	'i',	'j',	'k',	'l',	'm',	'n',	'o',
	'p',	'q',	'r',	's',	't',	'u',	'v',	'w',
	'x',	'y',	'z',	91,	92,	93,	94,	95,
	96,	'A',	'B',	'C',	'D',	'E',	'F',	'G',
	'H',	'I',	'J',	'K',	'L',	'M',	'N',	'O',
	'P',	'Q',	'R',	'S',	'T',	'U',	'V',	'W',
	'X',	'Y',	'Z',	123,	124,	125,	126,	127,
	128,	129,	130,	131,	132,	133,	134,	135,
	136,	137,	138,	139,	140,	141,	142,	143,
	144,	145,	146,	147,	148,	149,	150,	151,
	152,	153,	154,	155,	156,	157,	158,	159,
	160,	161,	162,	163,	164,	165,	166,	167,
	168,	169,	170,	171,	172,	173,	174,	175,
	176,	177,	178,	179,	180,	181,	182,	183,
	184,	185,	186,	187,	188,	189,	190,	191,
	192,	193,	194,	195,	196,	197,	198,	199,
	200,	201,	202,	203,	204,	205,	206,	207,
	208,	209,	210,	211,	212,	213,	214,	215,
	216,	217,	218,	219,	220,	221,	222,	223,	
	224,	225,	226,	227,	228,	229,	230,	231,
	232,	233,	234,	235,	236,	237,	238,	239,
	240,	241,	242,	243,	244,	245,	246,	247,
	248,	249,	250,	251,	252,	253,	254,	255
};
EXTCONST  unsigned char PL_fold_latin1[] = {
    /* Full latin1 complement folding, except for three problematic code points:
     *	Micro sign (181 = 0xB5) and y with diearesis (255 = 0xFF) have their
     *	fold complements outside the Latin1 range, so can't match something
     *	that isn't in utf8.
     *	German lower case sharp s (223 = 0xDF) folds to two characters, 'ss',
     *	not one, so can't be represented in this table.
     *
     * All have to be specially handled */
	0,	1,	2,	3,	4,	5,	6,	7,
	8,	9,	10,	11,	12,	13,	14,	15,
	16,	17,	18,	19,	20,	21,	22,	23,
	24,	25,	26,	27,	28,	29,	30,	31,
	32,	33,	34,	35,	36,	37,	38,	39,
	40,	41,	42,	43,	44,	45,	46,	47,
	48,	49,	50,	51,	52,	53,	54,	55,
	56,	57,	58,	59,	60,	61,	62,	63,
	64,	'a',	'b',	'c',	'd',	'e',	'f',	'g',
	'h',	'i',	'j',	'k',	'l',	'm',	'n',	'o',
	'p',	'q',	'r',	's',	't',	'u',	'v',	'w',
	'x',	'y',	'z',	91,	92,	93,	94,	95,
	96,	'A',	'B',	'C',	'D',	'E',	'F',	'G',
	'H',	'I',	'J',	'K',	'L',	'M',	'N',	'O',
	'P',	'Q',	'R',	'S',	'T',	'U',	'V',	'W',
	'X',	'Y',	'Z',	123,	124,	125,	126,	127,
	128,	129,	130,	131,	132,	133,	134,	135,
	136,	137,	138,	139,	140,	141,	142,	143,
	144,	145,	146,	147,	148,	149,	150,	151,
	152,	153,	154,	155,	156,	157,	158,	159,
	160,	161,	162,	163,	164,	165,	166,	167,
	168,	169,	170,	171,	172,	173,	174,	175,
	176,	177,	178,	179,	180,	181 /*micro */,	182,	183,
	184,	185,	186,	187,	188,	189,	190,	191,
	192+32,	193+32,	194+32,	195+32,	196+32,	197+32,	198+32,	199+32,
	200+32,	201+32,	202+32,	203+32,	204+32,	205+32,	206+32,	207+32,
	208+32,	209+32,	210+32,	211+32,	212+32,	213+32,	214+32,	215,
	216+32,	217+32,	218+32,	219+32,	220+32,	221+32,	222+32,	223 /* ss */,
	224-32,	225-32,	226-32,	227-32,	228-32,	229-32,	230-32,	231-32,
	232-32,	233-32,	234-32,	235-32,	236-32,	237-32,	238-32,	239-32,
	240-32,	241-32,	242-32,	243-32,	244-32,	245-32,	246-32,	247,
	248-32,	249-32,	250-32,	251-32,	252-32,	253-32,	254-32,
	255 /* y with diaeresis */
};

/* If these tables are accessed through ebcdic, the access will be converted to
 * latin1 first */
EXTCONST  unsigned char PL_latin1_lc[] = {  /* lowercasing */
	0,	1,	2,	3,	4,	5,	6,	7,
	8,	9,	10,	11,	12,	13,	14,	15,
	16,	17,	18,	19,	20,	21,	22,	23,
	24,	25,	26,	27,	28,	29,	30,	31,
	32,	33,	34,	35,	36,	37,	38,	39,
	40,	41,	42,	43,	44,	45,	46,	47,
	48,	49,	50,	51,	52,	53,	54,	55,
	56,	57,	58,	59,	60,	61,	62,	63,
	64,	'a',	'b',	'c',	'd',	'e',	'f',	'g',
	'h',	'i',	'j',	'k',	'l',	'm',	'n',	'o',
	'p',	'q',	'r',	's',	't',	'u',	'v',	'w',
	'x',	'y',	'z',	91,	92,	93,	94,	95,
	96,	97,	98,	99,	100,	101,	102,	103,
	104,	105,	106,	107,	108,	109,	110,	111,
	112,	113,	114,	115,	116,	117,	118,	119,
	120,	121,	122,	123,	124,	125,	126,	127,
	128,	129,	130,	131,	132,	133,	134,	135,
	136,	137,	138,	139,	140,	141,	142,	143,
	144,	145,	146,	147,	148,	149,	150,	151,
	152,	153,	154,	155,	156,	157,	158,	159,
	160,	161,	162,	163,	164,	165,	166,	167,
	168,	169,	170,	171,	172,	173,	174,	175,
	176,	177,	178,	179,	180,	181,	182,	183,
	184,	185,	186,	187,	188,	189,	190,	191,
	192+32,	193+32,	194+32,	195+32,	196+32,	197+32,	198+32,	199+32,
	200+32,	201+32,	202+32,	203+32,	204+32,	205+32,	206+32,	207+32,
	208+32,	209+32,	210+32,	211+32,	212+32,	213+32,	214+32,	215,
	216+32,	217+32,	218+32,	219+32,	220+32,	221+32,	222+32,	223,	
	224,	225,	226,	227,	228,	229,	230,	231,
	232,	233,	234,	235,	236,	237,	238,	239,
	240,	241,	242,	243,	244,	245,	246,	247,
	248,	249,	250,	251,	252,	253,	254,	255
};

/* upper and title case of latin1 characters, modified so that the three tricky
 * ones are mapped to 255 (which is one of the three) */
EXTCONST  unsigned char PL_mod_latin1_uc[] = {
	0,	1,	2,	3,	4,	5,	6,	7,
	8,	9,	10,	11,	12,	13,	14,	15,
	16,	17,	18,	19,	20,	21,	22,	23,
	24,	25,	26,	27,	28,	29,	30,	31,
	32,	33,	34,	35,	36,	37,	38,	39,
	40,	41,	42,	43,	44,	45,	46,	47,
	48,	49,	50,	51,	52,	53,	54,	55,
	56,	57,	58,	59,	60,	61,	62,	63,
	64,	65,	66,	67,	68,	69,	70,	71,
	72,	73,	74,	75,	76,	77,	78,	79,
	80,	81,	82,	83,	84,	85,	86,	87,
	88,	89,	90,	91,	92,	93,	94,	95,
	96,	'A',	'B',	'C',	'D',	'E',	'F',	'G',
	'H',	'I',	'J',	'K',	'L',	'M',	'N',	'O',
	'P',	'Q',	'R',	'S',	'T',	'U',	'V',	'W',
	'X',	'Y',	'Z',	123,	124,	125,	126,	127,
	128,	129,	130,	131,	132,	133,	134,	135,
	136,	137,	138,	139,	140,	141,	142,	143,
	144,	145,	146,	147,	148,	149,	150,	151,
	152,	153,	154,	155,	156,	157,	158,	159,
	160,	161,	162,	163,	164,	165,	166,	167,
	168,	169,	170,	171,	172,	173,	174,	175,
	176,	177,	178,	179,	180,	255 /*micro*/,	182,	183,
	184,	185,	186,	187,	188,	189,	190,	191,
	192,	193,	194,	195,	196,	197,	198,	199,
	200,	201,	202,	203,	204,	205,	206,	207,
	208,	209,	210,	211,	212,	213,	214,	215,
	216,	217,	218,	219,	220,	221,	222,
#if    UNICODE_MAJOR_VERSION > 2                                        \
   || (UNICODE_MAJOR_VERSION == 2 && UNICODE_DOT_VERSION >= 1		\
                                  && UNICODE_DOT_DOT_VERSION >= 8)
	                                                        255 /*sharp s*/,
#else   /* uc() is itself in early unicode */
	                                                        223,
#endif
	224-32,	225-32,	226-32,	227-32,	228-32,	229-32,	230-32,	231-32,
	232-32,	233-32,	234-32,	235-32,	236-32,	237-32,	238-32,	239-32,
	240-32,	241-32,	242-32,	243-32,	244-32,	245-32,	246-32,	247,
	248-32,	249-32,	250-32,	251-32,	252-32,	253-32,	254-32,	255
};
#endif  /* !EBCDIC, but still in DOINIT */
#else	/* ! DOINIT */
#   ifndef EBCDIC
EXTCONST unsigned char PL_fold[];
EXTCONST unsigned char PL_fold_latin1[];
EXTCONST unsigned char PL_mod_latin1_uc[];
EXTCONST unsigned char PL_latin1_lc[];
#   endif
#endif

#ifndef PERL_GLOBAL_STRUCT /* or perlvars.h */
#ifdef DOINIT
EXT unsigned char PL_fold_locale[] = { /* Unfortunately not EXTCONST. */
	0,	1,	2,	3,	4,	5,	6,	7,
	8,	9,	10,	11,	12,	13,	14,	15,
	16,	17,	18,	19,	20,	21,	22,	23,
	24,	25,	26,	27,	28,	29,	30,	31,
	32,	33,	34,	35,	36,	37,	38,	39,
	40,	41,	42,	43,	44,	45,	46,	47,
	48,	49,	50,	51,	52,	53,	54,	55,
	56,	57,	58,	59,	60,	61,	62,	63,
	64,	'a',	'b',	'c',	'd',	'e',	'f',	'g',
	'h',	'i',	'j',	'k',	'l',	'm',	'n',	'o',
	'p',	'q',	'r',	's',	't',	'u',	'v',	'w',
	'x',	'y',	'z',	91,	92,	93,	94,	95,
	96,	'A',	'B',	'C',	'D',	'E',	'F',	'G',
	'H',	'I',	'J',	'K',	'L',	'M',	'N',	'O',
	'P',	'Q',	'R',	'S',	'T',	'U',	'V',	'W',
	'X',	'Y',	'Z',	123,	124,	125,	126,	127,
	128,	129,	130,	131,	132,	133,	134,	135,
	136,	137,	138,	139,	140,	141,	142,	143,
	144,	145,	146,	147,	148,	149,	150,	151,
	152,	153,	154,	155,	156,	157,	158,	159,
	160,	161,	162,	163,	164,	165,	166,	167,
	168,	169,	170,	171,	172,	173,	174,	175,
	176,	177,	178,	179,	180,	181,	182,	183,
	184,	185,	186,	187,	188,	189,	190,	191,
	192,	193,	194,	195,	196,	197,	198,	199,
	200,	201,	202,	203,	204,	205,	206,	207,
	208,	209,	210,	211,	212,	213,	214,	215,
	216,	217,	218,	219,	220,	221,	222,	223,	
	224,	225,	226,	227,	228,	229,	230,	231,
	232,	233,	234,	235,	236,	237,	238,	239,
	240,	241,	242,	243,	244,	245,	246,	247,
	248,	249,	250,	251,	252,	253,	254,	255
};
#else
EXT unsigned char PL_fold_locale[]; /* Unfortunately not EXTCONST. */
#endif
#endif /* !PERL_GLOBAL_STRUCT */

#ifdef DOINIT
#ifdef EBCDIC
EXTCONST unsigned char PL_freq[] = {/* EBCDIC frequencies for mixed English/C */
    1,      2,      84,     151,    154,    155,    156,    157,
    165,    246,    250,    3,      158,    7,      18,     29,
    40,     51,     62,     73,     85,     96,     107,    118,
    129,    140,    147,    148,    149,    150,    152,    153,
    255,      6,      8,      9,     10,     11,     12,     13,
     14,     15,     24,     25,     26,     27,     28,    226,
     29,     30,     31,     32,     33,     43,     44,     45,
     46,     47,     48,     49,     50,     76,     77,     78,
     79,     80,     81,     82,     83,     84,     85,     86,
     87,     94,     95,    234,    181,    233,    187,    190,
    180,     96,     97,     98,     99,    100,    101,    102,
    104,    112,    182,    174,    236,    232,    229,    103,
    228,    226,    114,    115,    116,    117,    118,    119,
    120,    121,    122,    235,    176,    230,    194,    162,
    130,    131,    132,    133,    134,    135,    136,    137,
    138,    139,    201,    205,    163,    217,    220,    224,
    5,      248,    227,    244,    242,    255,    241,    231,
    240,    253,    16,     197,    19,     20,     21,     187,
    23,     169,    210,    245,    237,    249,    247,    239,
    168,    252,    34,     196,    36,     37,     38,     39,
    41,     42,     251,    254,    238,    223,    221,    213,
    225,    177,    52,     53,     54,     55,     56,     57,
    58,     59,     60,     61,     63,     64,     65,     66,
    67,     68,     69,     70,     71,     72,     74,     75,
    205,    208,    186,    202,    200,    218,    198,    179,
    178,    214,    88,     89,     90,     91,     92,     93,
    217,    166,    170,    207,    199,    209,    206,    204,
    160,    212,    105,    106,    108,    109,    110,    111,
    203,    113,    216,    215,    192,    175,    193,    243,
    172,    161,    123,    124,    125,    126,    127,    128,
    222,    219,    211,    195,    188,    193,    185,    184,
    191,    183,    141,    142,    143,    144,    145,    146
};
#else  /* ascii rather than ebcdic */
EXTCONST unsigned char PL_freq[] = {	/* letter frequencies for mixed English/C */
	1,	2,	84,	151,	154,	155,	156,	157,
	165,	246,	250,	3,	158,	7,	18,	29,
	40,	51,	62,	73,	85,	96,	107,	118,
	129,	140,	147,	148,	149,	150,	152,	153,
	255,	182,	224,	205,	174,	176,	180,	217,
	233,	232,	236,	187,	235,	228,	234,	226,
	222,	219,	211,	195,	188,	193,	185,	184,
	191,	183,	201,	229,	181,	220,	194,	162,
	163,	208,	186,	202,	200,	218,	198,	179,
	178,	214,	166,	170,	207,	199,	209,	206,
	204,	160,	212,	216,	215,	192,	175,	173,
	243,	172,	161,	190,	203,	189,	164,	230,
	167,	248,	227,	244,	242,	255,	241,	231,
	240,	253,	169,	210,	245,	237,	249,	247,
	239,	168,	252,	251,	254,	238,	223,	221,
	213,	225,	177,	197,	171,	196,	159,	4,
	5,	6,	8,	9,	10,	11,	12,	13,
	14,	15,	16,	17,	19,	20,	21,	22,
	23,	24,	25,	26,	27,	28,	30,	31,
	32,	33,	34,	35,	36,	37,	38,	39,
	41,	42,	43,	44,	45,	46,	47,	48,
	49,	50,	52,	53,	54,	55,	56,	57,
	58,	59,	60,	61,	63,	64,	65,	66,
	67,	68,	69,	70,	71,	72,	74,	75,
	76,	77,	78,	79,	80,	81,	82,	83,
	86,	87,	88,	89,	90,	91,	92,	93,
	94,	95,	97,	98,	99,	100,	101,	102,
	103,	104,	105,	106,	108,	109,	110,	111,
	112,	113,	114,	115,	116,	117,	119,	120,
	121,	122,	123,	124,	125,	126,	127,	128,
	130,	131,	132,	133,	134,	135,	136,	137,
	138,	139,	141,	142,	143,	144,	145,	146
};
#endif
#else
EXTCONST unsigned char PL_freq[];
#endif

/* Although only used for debugging, these constants must be available in
 * non-debugging builds too, since they're used in ext/re/re_exec.c,
 * which has DEBUGGING enabled always */
#ifdef DOINIT
EXTCONST char* const PL_block_type[] = {
	"NULL",
	"WHEN",
	"BLOCK",
	"GIVEN",
	"LOOP_ARY",
	"LOOP_LAZYSV",
	"LOOP_LAZYIV",
	"LOOP_LIST",
	"LOOP_PLAIN",
	"SUB",
	"FORMAT",
	"EVAL",
	"SUBST"
};
#else
EXTCONST char* PL_block_type[];
#endif

/* These are all the compile time options that affect binary compatibility.
   Other compile time options that are binary compatible are in perl.c
   Both are combined for the output of perl -V
   However, this string will be embedded in any shared perl library, which will
   allow us add a comparison check in perlmain.c in the near future.  */
#ifdef DOINIT
EXTCONST char PL_bincompat_options[] =
#  ifdef DEBUG_LEAKING_SCALARS
			     " DEBUG_LEAKING_SCALARS"
#  endif
#  ifdef DEBUG_LEAKING_SCALARS_FORK_DUMP
			     " DEBUG_LEAKING_SCALARS_FORK_DUMP"
#  endif
#  ifdef FCRYPT
			     " FCRYPT"
#  endif
#  ifdef HAS_TIMES
			     " HAS_TIMES"
#  endif
#  ifdef HAVE_INTERP_INTERN
			     " HAVE_INTERP_INTERN"
#  endif
#  ifdef MULTIPLICITY
			     " MULTIPLICITY"
#  endif
#  ifdef MYMALLOC
			     " MYMALLOC"
#  endif
#  ifdef PERLIO_LAYERS
			     " PERLIO_LAYERS"
#  endif
#  ifdef PERL_DEBUG_READONLY_COW
			     " PERL_DEBUG_READONLY_COW"
#  endif
#  ifdef PERL_DEBUG_READONLY_OPS
			     " PERL_DEBUG_READONLY_OPS"
#  endif
#  ifdef PERL_GLOBAL_STRUCT
			     " PERL_GLOBAL_STRUCT"
#  endif
#  ifdef PERL_GLOBAL_STRUCT_PRIVATE
			     " PERL_GLOBAL_STRUCT_PRIVATE"
#  endif
#  ifdef PERL_IMPLICIT_CONTEXT
			     " PERL_IMPLICIT_CONTEXT"
#  endif
#  ifdef PERL_IMPLICIT_SYS
			     " PERL_IMPLICIT_SYS"
#  endif
#  ifdef PERL_MICRO
			     " PERL_MICRO"
#  endif
#  ifdef PERL_NEED_APPCTX
			     " PERL_NEED_APPCTX"
#  endif
#  ifdef PERL_NEED_TIMESBASE
			     " PERL_NEED_TIMESBASE"
#  endif
#  ifdef PERL_POISON
			     " PERL_POISON"
#  endif
#  ifdef PERL_SAWAMPERSAND
			     " PERL_SAWAMPERSAND"
#  endif
#  ifdef PERL_TRACK_MEMPOOL
			     " PERL_TRACK_MEMPOOL"
#  endif
#  ifdef PERL_USES_PL_PIDSTATUS
			     " PERL_USES_PL_PIDSTATUS"
#  endif
#  ifdef USE_64_BIT_ALL
			     " USE_64_BIT_ALL"
#  endif
#  ifdef USE_64_BIT_INT
			     " USE_64_BIT_INT"
#  endif
#  ifdef USE_IEEE
			     " USE_IEEE"
#  endif
#  ifdef USE_ITHREADS
			     " USE_ITHREADS"
#  endif
#  ifdef USE_LARGE_FILES
			     " USE_LARGE_FILES"
#  endif
#  ifdef USE_LOCALE_COLLATE
			     " USE_LOCALE_COLLATE"
#  endif
#  ifdef USE_LOCALE_NUMERIC
			     " USE_LOCALE_NUMERIC"
#  endif
#  ifdef USE_LOCALE_TIME
			     " USE_LOCALE_TIME"
#  endif
#  ifdef USE_LONG_DOUBLE
			     " USE_LONG_DOUBLE"
#  endif
#  ifdef USE_PERLIO
			     " USE_PERLIO"
#  endif
#  ifdef USE_QUADMATH
			     " USE_QUADMATH"
#  endif
#  ifdef USE_REENTRANT_API
			     " USE_REENTRANT_API"
#  endif
#  ifdef USE_SOCKS
			     " USE_SOCKS"
#  endif
#  ifdef VMS_DO_SOCKETS
			     " VMS_DO_SOCKETS"
#  endif
#  ifdef VMS_SHORTEN_LONG_SYMBOLS
			     " VMS_SHORTEN_LONG_SYMBOLS"
#  endif
#  ifdef VMS_WE_ARE_CASE_SENSITIVE
			     " VMS_SYMBOL_CASE_AS_IS"
#  endif
  "";
#else
EXTCONST char PL_bincompat_options[];
#endif

#ifndef PERL_SET_PHASE
#  define PERL_SET_PHASE(new_phase) \
    PERL_DTRACE_PROBE_PHASE(new_phase); \
    PL_phase = new_phase;
#endif

/* The interpreter phases. If these ever change, PL_phase_names right below will
 * need to be updated accordingly. */
enum perl_phase {
    PERL_PHASE_CONSTRUCT	= 0,
    PERL_PHASE_START		= 1,
    PERL_PHASE_CHECK		= 2,
    PERL_PHASE_INIT		= 3,
    PERL_PHASE_RUN		= 4,
    PERL_PHASE_END		= 5,
    PERL_PHASE_DESTRUCT		= 6
};

#ifdef DOINIT
EXTCONST char *const PL_phase_names[] = {
    "CONSTRUCT",
    "START",
    "CHECK",
    "INIT",
    "RUN",
    "END",
    "DESTRUCT"
};
#else
EXTCONST char *const PL_phase_names[];
#endif

#ifndef PERL_CORE
/* Do not use this macro. It only exists for extensions that rely on PL_dirty
 * instead of using the newer PL_phase, which provides everything PL_dirty
 * provided, and more. */
#  define PL_dirty cBOOL(PL_phase == PERL_PHASE_DESTRUCT)

#  define PL_amagic_generation PL_na
#endif /* !PERL_CORE */

#define PL_hints PL_compiling.cop_hints

END_EXTERN_C

/*****************************************************************************/
/* This lexer/parser stuff is currently global since yacc is hard to reenter */
/*****************************************************************************/
/* XXX This needs to be revisited, since BEGIN makes yacc re-enter... */

#ifdef __Lynx__
/* LynxOS defines these in scsi.h which is included via ioctl.h */
#ifdef FORMAT
#undef FORMAT
#endif
#ifdef SPACE
#undef SPACE
#endif
#endif

#define LEX_NOTPARSING		11	/* borrowed from toke.c */

typedef enum {
    XOPERATOR,
    XTERM,
    XREF,
    XSTATE,
    XBLOCK,
    XATTRBLOCK,
    XATTRTERM,
    XTERMBLOCK,
    XBLOCKTERM,
    XPOSTDEREF,
    XTERMORDORDOR /* evil hack */
    /* update exp_name[] in toke.c if adding to this enum */
} expectation;

/* Hints are now stored in a dedicated U32, so the bottom 8 bits are no longer
   special and there is no need for HINT_PRIVATE_MASK for COPs
   However, bitops store HINT_INTEGER in their op_private.

    NOTE: The typical module using these has the bit value hard-coded, so don't
    blindly change the values of these.

   If we run out of bits, the 2 locale ones could be combined.  The PARTIAL one
   is for "use locale 'FOO'" which excludes some categories.  It requires going
   to %^H to find out which are in and which are out.  This could be extended
   for the normal case of a plain HINT_LOCALE, so that %^H would be used for
   any locale form. */
#define HINT_INTEGER		0x00000001 /* integer pragma */
#define HINT_STRICT_REFS	0x00000002 /* strict pragma */
#define HINT_LOCALE		0x00000004 /* locale pragma */
#define HINT_BYTES		0x00000008 /* bytes pragma */
#define HINT_LOCALE_PARTIAL	0x00000010 /* locale, but a subset of categories */

#define HINT_EXPLICIT_STRICT_REFS	0x00000020 /* strict.pm */
#define HINT_EXPLICIT_STRICT_SUBS	0x00000040 /* strict.pm */
#define HINT_EXPLICIT_STRICT_VARS	0x00000080 /* strict.pm */

#define HINT_BLOCK_SCOPE	0x00000100
#define HINT_STRICT_SUBS	0x00000200 /* strict pragma */
#define HINT_STRICT_VARS	0x00000400 /* strict pragma */
#define HINT_UNI_8_BIT		0x00000800 /* unicode_strings feature */

/* The HINT_NEW_* constants are used by the overload pragma */
#define HINT_NEW_INTEGER	0x00001000
#define HINT_NEW_FLOAT		0x00002000
#define HINT_NEW_BINARY		0x00004000
#define HINT_NEW_STRING		0x00008000
#define HINT_NEW_RE		0x00010000
#define HINT_LOCALIZE_HH	0x00020000 /* %^H needs to be copied */
#define HINT_LEXICAL_IO_IN	0x00040000 /* ${^OPEN} is set for input */
#define HINT_LEXICAL_IO_OUT	0x00080000 /* ${^OPEN} is set for output */

#define HINT_RE_TAINT		0x00100000 /* re pragma */
#define HINT_RE_EVAL		0x00200000 /* re pragma */

#define HINT_FILETEST_ACCESS	0x00400000 /* filetest pragma */
#define HINT_UTF8		0x00800000 /* utf8 pragma */

#define HINT_NO_AMAGIC		0x01000000 /* overloading pragma */

#define HINT_RE_FLAGS		0x02000000 /* re '/xism' pragma */

#define HINT_FEATURE_MASK	0x1c000000 /* 3 bits for feature bundles */

				/* Note: Used for HINT_M_VMSISH_*,
				   currently defined by vms/vmsish.h:
				0x40000000
				0x80000000
				 */

/* The following are stored in $^H{sort}, not in PL_hints */
#define HINT_SORT_SORT_BITS	0x000000FF /* allow 256 different ones */
#define HINT_SORT_QUICKSORT	0x00000001
#define HINT_SORT_MERGESORT	0x00000002
#define HINT_SORT_STABLE	0x00000100 /* sort styles (currently one) */

/* flags for PL_sawampersand */

#define SAWAMPERSAND_LEFT       1   /* saw $` */
#define SAWAMPERSAND_MIDDLE     2   /* saw $& */
#define SAWAMPERSAND_RIGHT      4   /* saw $' */

#ifndef PERL_SAWAMPERSAND
# define PL_sawampersand \
	(SAWAMPERSAND_LEFT|SAWAMPERSAND_MIDDLE|SAWAMPERSAND_RIGHT)
#endif

/* Used for debugvar magic */
#define DBVARMG_SINGLE  0
#define DBVARMG_TRACE   1
#define DBVARMG_SIGNAL  2
#define DBVARMG_COUNT   3

#define PL_DBsingle_iv  (PL_DBcontrol[DBVARMG_SINGLE])
#define PL_DBtrace_iv   (PL_DBcontrol[DBVARMG_TRACE])
#define PL_DBsignal_iv  (PL_DBcontrol[DBVARMG_SIGNAL])

/* Various states of the input record separator SV (rs) */
#define RsSNARF(sv)   (! SvOK(sv))
#define RsSIMPLE(sv)  (SvOK(sv) && (! SvPOK(sv) || SvCUR(sv)))
#define RsPARA(sv)    (SvPOK(sv) && ! SvCUR(sv))
#define RsRECORD(sv)  (SvROK(sv) && (SvIV(SvRV(sv)) > 0))

/* A struct for keeping various DEBUGGING related stuff,
 * neatly packed.  Currently only scratch variables for
 * constructing debug output are included.  Needed always,
 * not just when DEBUGGING, though, because of the re extension. c*/
struct perl_debug_pad {
  SV pad[3];
};

#define PERL_DEBUG_PAD(i)	&(PL_debug_pad.pad[i])
#define PERL_DEBUG_PAD_ZERO(i)	(SvPVX(PERL_DEBUG_PAD(i))[0] = 0, \
	(((XPV*) SvANY(PERL_DEBUG_PAD(i)))->xpv_cur = 0), \
	PERL_DEBUG_PAD(i))

/* Enable variables which are pointers to functions */
typedef void (*peep_t)(pTHX_ OP* o);
typedef regexp* (*regcomp_t) (pTHX_ char* exp, char* xend, PMOP* pm);
typedef I32     (*regexec_t) (pTHX_ regexp* prog, char* stringarg,
				      char* strend, char* strbeg, I32 minend,
				      SV* screamer, void* data, U32 flags);
typedef char*   (*re_intuit_start_t) (pTHX_ regexp *prog, SV *sv,
						char *strpos, char *strend,
						U32 flags,
						re_scream_pos_data *d);
typedef SV*	(*re_intuit_string_t) (pTHX_ regexp *prog);
typedef void	(*regfree_t) (pTHX_ struct regexp* r);
typedef regexp* (*regdupe_t) (pTHX_ const regexp* r, CLONE_PARAMS *param);
typedef I32     (*re_fold_t)(const char *, char const *, I32);

typedef void (*DESTRUCTORFUNC_NOCONTEXT_t) (void*);
typedef void (*DESTRUCTORFUNC_t) (pTHX_ void*);
typedef void (*SVFUNC_t) (pTHX_ SV* const);
typedef I32  (*SVCOMPARE_t) (pTHX_ SV* const, SV* const);
typedef void (*XSINIT_t) (pTHX);
typedef void (*ATEXIT_t) (pTHX_ void*);
typedef void (*XSUBADDR_t) (pTHX_ CV *);

typedef OP* (*Perl_ppaddr_t)(pTHX);
typedef OP* (*Perl_check_t) (pTHX_ OP*);
typedef void(*Perl_ophook_t)(pTHX_ OP*);
typedef int (*Perl_keyword_plugin_t)(pTHX_ char*, STRLEN, OP**);
typedef void(*Perl_cpeep_t)(pTHX_ OP *, OP *);

typedef void(*globhook_t)(pTHX);

#define KEYWORD_PLUGIN_DECLINE 0
#define KEYWORD_PLUGIN_STMT    1
#define KEYWORD_PLUGIN_EXPR    2

/* Interpreter exitlist entry */
typedef struct exitlistentry {
    void (*fn) (pTHX_ void*);
    void *ptr;
} PerlExitListEntry;

/* if you only have signal() and it resets on each signal, FAKE_PERSISTENT_SIGNAL_HANDLERS fixes */
/* These have to be before perlvars.h */
#if !defined(HAS_SIGACTION) && defined(VMS)
#  define  FAKE_PERSISTENT_SIGNAL_HANDLERS
#endif
/* if we're doing kill() with sys$sigprc on VMS, FAKE_DEFAULT_SIGNAL_HANDLERS */
#if defined(KILL_BY_SIGPRC)
#  define  FAKE_DEFAULT_SIGNAL_HANDLERS
#endif

#if !defined(MULTIPLICITY)

struct interpreter {
    char broiled;
};

#else

/* If we have multiple interpreters define a struct
   holding variables which must be per-interpreter
   If we don't have threads anything that would have
   be per-thread is per-interpreter.
*/

/* Set up PERLVAR macros for populating structs */
#  define PERLVAR(prefix,var,type) type prefix##var;

/* 'var' is an array of length 'n' */
#  define PERLVARA(prefix,var,n,type) type prefix##var[n];

/* initialize 'var' to init' */
#  define PERLVARI(prefix,var,type,init) type prefix##var;

/* like PERLVARI, but make 'var' a const */
#  define PERLVARIC(prefix,var,type,init) type prefix##var;

struct interpreter {
#  include "intrpvar.h"
};

EXTCONST U16 PL_interp_size
  INIT(sizeof(struct interpreter));

#  define PERL_INTERPRETER_SIZE_UPTO_MEMBER(member)			\
    STRUCT_OFFSET(struct interpreter, member) +				\
    sizeof(((struct interpreter*)0)->member)

/* This will be useful for subsequent releases, because this has to be the
   same in your libperl as in main(), else you have a mismatch and must abort.
*/
EXTCONST U16 PL_interp_size_5_18_0
  INIT(PERL_INTERPRETER_SIZE_UPTO_MEMBER(PERL_LAST_5_18_0_INTERP_MEMBER));


#  ifdef PERL_GLOBAL_STRUCT
/* MULTIPLICITY is automatically defined when PERL_GLOBAL_STRUCT is defined,
   hence it's safe and sane to nest this within #ifdef MULTIPLICITY  */

struct perl_vars {
#    include "perlvars.h"
};

EXTCONST U16 PL_global_struct_size
  INIT(sizeof(struct perl_vars));

#    ifdef PERL_CORE
#      ifndef PERL_GLOBAL_STRUCT_PRIVATE
EXT struct perl_vars PL_Vars;
EXT struct perl_vars *PL_VarsPtr INIT(&PL_Vars);
#        undef PERL_GET_VARS
#        define PERL_GET_VARS() PL_VarsPtr
#      endif /* !PERL_GLOBAL_STRUCT_PRIVATE */
#    else /* PERL_CORE */
#      if !defined(__GNUC__) || !defined(WIN32)
EXT
#      endif /* WIN32 */
struct perl_vars *PL_VarsPtr;
#      define PL_Vars (*((PL_VarsPtr) \
		       ? PL_VarsPtr : (PL_VarsPtr = Perl_GetVars(aTHX))))
#    endif /* PERL_CORE */
#  endif /* PERL_GLOBAL_STRUCT */

/* Done with PERLVAR macros for now ... */
#  undef PERLVAR
#  undef PERLVARA
#  undef PERLVARI
#  undef PERLVARIC

#endif /* MULTIPLICITY */

struct tempsym; /* defined in pp_pack.c */

#include "thread.h"
#include "pp.h"

#undef PERL_CKDEF
#undef PERL_PPDEF
#define PERL_CKDEF(s)	PERL_CALLCONV OP *s (pTHX_ OP *o);
#define PERL_PPDEF(s)	PERL_CALLCONV OP *s (pTHX);

#ifdef MYMALLOC
#  include "malloc_ctl.h"
#endif

/*
 * This provides a layer of functions and macros to ensure extensions will
 * get to use the same RTL functions as the core.
 */
#if defined(WIN32)
#  include "win32iop.h"
#endif


#include "proto.h"

/* this has structure inits, so it cannot be included before here */
#include "opcode.h"

/* The following must follow proto.h as #defines mess up syntax */

#if !defined(PERL_FOR_X2P)
#  include "embedvar.h"
#endif

/* Now include all the 'global' variables
 * If we don't have threads or multiple interpreters
 * these include variables that would have been their struct-s
 */

#define PERLVAR(prefix,var,type) EXT type PL_##var;
#define PERLVARA(prefix,var,n,type) EXT type PL_##var[n];
#define PERLVARI(prefix,var,type,init) EXT type  PL_##var INIT(init);
#define PERLVARIC(prefix,var,type,init) EXTCONST type PL_##var INIT(init);

#if !defined(MULTIPLICITY)
START_EXTERN_C
#  include "intrpvar.h"
END_EXTERN_C
#endif

#ifdef PERL_CORE
/* All core uses now exterminated. Ensure no zombies can return:  */
#  undef PL_na
#endif

/* Now all the config stuff is setup we can include embed.h
   In particular, need the relevant *ish file included already, as it may
   define HAVE_INTERP_INTERN  */
#include "embed.h"

#ifndef PERL_GLOBAL_STRUCT
START_EXTERN_C

#  include "perlvars.h"

END_EXTERN_C
#endif

#undef PERLVAR
#undef PERLVARA
#undef PERLVARI
#undef PERLVARIC

#if !defined(MULTIPLICITY)
/* Set up PERLVAR macros for populating structs */
#  define PERLVAR(prefix,var,type) type prefix##var;
/* 'var' is an array of length 'n' */
#  define PERLVARA(prefix,var,n,type) type prefix##var[n];
/* initialize 'var' to init' */
#  define PERLVARI(prefix,var,type,init) type prefix##var;
/* like PERLVARI, but make 'var' a const */
#  define PERLVARIC(prefix,var,type,init) type prefix##var;

/* this is never instantiated, is it just used for sizeof(struct PerlHandShakeInterpreter) */
struct PerlHandShakeInterpreter {
#  include "intrpvar.h"
};
#  undef PERLVAR
#  undef PERLVARA
#  undef PERLVARI
#  undef PERLVARIC
#endif

START_EXTERN_C

/* dummy variables that hold pointers to both runops functions, thus forcing
 * them *both* to get linked in (useful for Peek.xs, debugging etc) */

EXTCONST runops_proc_t PL_runops_std
  INIT(Perl_runops_standard);
EXTCONST runops_proc_t PL_runops_dbg
  INIT(Perl_runops_debug);

#define EXT_MGVTBL EXTCONST MGVTBL

#define PERL_MAGIC_READONLY_ACCEPTABLE 0x40
#define PERL_MAGIC_VALUE_MAGIC 0x80
#define PERL_MAGIC_VTABLE_MASK 0x3F
#define PERL_MAGIC_TYPE_READONLY_ACCEPTABLE(t) \
    (PL_magic_data[(U8)(t)] & PERL_MAGIC_READONLY_ACCEPTABLE)
#define PERL_MAGIC_TYPE_IS_VALUE_MAGIC(t) \
    (PL_magic_data[(U8)(t)] & PERL_MAGIC_VALUE_MAGIC)

#include "mg_vtable.h"

#ifdef DOINIT
EXTCONST U8 PL_magic_data[256] =
#  ifdef PERL_MICRO
#    include "umg_data.h"
#  else
#    include "mg_data.h"
#  endif
;
#else
EXTCONST U8 PL_magic_data[256];
#endif

#ifdef DOINIT
		        /* NL IV NV PV INV PI PN MG RX GV LV AV HV CV FM IO */
EXTCONST bool
PL_valid_types_IVX[]    = { 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0 };
EXTCONST bool
PL_valid_types_NVX[]    = { 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0 };
EXTCONST bool
PL_valid_types_PVX[]    = { 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1 };
EXTCONST bool
PL_valid_types_RV[]     = { 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1 };
EXTCONST bool
PL_valid_types_IV_set[] = { 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1 };
EXTCONST bool
PL_valid_types_NV_set[] = { 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0 };

#else

EXTCONST bool PL_valid_types_IVX[];
EXTCONST bool PL_valid_types_NVX[];
EXTCONST bool PL_valid_types_PVX[];
EXTCONST bool PL_valid_types_RV[];
EXTCONST bool PL_valid_types_IV_set[];
EXTCONST bool PL_valid_types_NV_set[];

#endif

/* In C99 we could use designated (named field) union initializers.
 * In C89 we need to initialize the member declared first.
 *
 * With the U8_NV version you will want to have inner braces,
 * while with the NV_U8 use just the NV.*/
#define INFNAN_U8_NV_DECL EXTCONST union { U8 u8[NVSIZE]; NV nv; }
#define INFNAN_NV_U8_DECL EXTCONST union { NV nv; U8 u8[NVSIZE]; }

#ifdef DOINIT

/* PL_inf and PL_nan initialization.
 *
 * For inf and nan initialization the ultimate fallback is dividing
 * one or zero by zero: however, some compilers will warn or even fail
 * on divide-by-zero, but hopefully something earlier will work.
 *
 * If you are thinking of using HUGE_VAL for infinity, or using
 * <math.h> functions to generate NV_INF (e.g. exp(1e9), log(-1.0)),
 * stop.  Neither will work portably: HUGE_VAL can be just DBL_MAX,
 * and the math functions might be just generating DBL_MAX, or even zero.
 *
 * Also, do NOT try doing NV_NAN based on NV_INF and trying (NV_INF-NV_INF).
 * Though logically correct, some compilers (like Visual C 2003)
 * falsely misoptimize that to zero (x-x is always zero, right?)
 */

/* The quadmath literals are anon structs which -Wc++-compat doesn't like. */
GCC_DIAG_IGNORE(-Wc++-compat)

#  ifdef USE_QUADMATH
/* Cannot use HUGE_VALQ for PL_inf because not a compile-time
 * constant. */
INFNAN_NV_U8_DECL PL_inf = { 1.0Q/0.0Q };
#  elif NVSIZE == LONG_DOUBLESIZE && defined(LONGDBLINFBYTES)
INFNAN_U8_NV_DECL PL_inf = { { LONGDBLINFBYTES } };
#  elif NVSIZE == DOUBLESIZE && defined(DOUBLEINFBYTES)
INFNAN_U8_NV_DECL PL_inf = { { DOUBLEINFBYTES } };
#  else
#    if NVSIZE == LONG_DOUBLESIZE && defined(USE_LONG_DOUBLE)
#      if defined(LDBL_INFINITY)
INFNAN_NV_U8_DECL PL_inf = { LDBL_INFINITY };
#      elif defined(LDBL_INF)
INFNAN_NV_U8_DECL PL_inf = { LDBL_INF };
#      elif defined(INFINITY)
INFNAN_NV_U8_DECL PL_inf = { (NV)INFINITY };
#      elif defined(INF)
INFNAN_NV_U8_DECL PL_inf = { (NV)INF };
#      else
INFNAN_NV_U8_DECL PL_inf = { 1.0L/0.0L }; /* keep last */
#      endif
#    else
#      if defined(DBL_INFINITY)
INFNAN_NV_U8_DECL PL_inf = { DBL_INFINITY };
#      elif defined(DBL_INF)
INFNAN_NV_U8_DECL PL_inf = { DBL_INF };
#      elif defined(INFINITY) /* C99 */
INFNAN_NV_U8_DECL PL_inf = { (NV)INFINITY };
#      elif defined(INF)
INFNAN_NV_U8_DECL PL_inf = { (NV)INF };
#      else
INFNAN_NV_U8_DECL PL_inf = { 1.0/0.0 }; /* keep last */
#      endif
#    endif
#  endif

#  ifdef USE_QUADMATH
/* Cannot use nanq("0") for PL_nan because not a compile-time
 * constant. */
INFNAN_NV_U8_DECL PL_nan = { 0.0Q/0.0Q };
#  elif NVSIZE == LONG_DOUBLESIZE && defined(LONGDBLNANBYTES)
INFNAN_U8_NV_DECL PL_nan = { { LONGDBLNANBYTES } };
#  elif NVSIZE == DOUBLESIZE && defined(DOUBLENANBYTES)
INFNAN_U8_NV_DECL PL_nan = { { DOUBLENANBYTES } };
#  else
#    if NVSIZE == LONG_DOUBLESIZE && defined(USE_LONG_DOUBLE)
#      if defined(LDBL_NAN)
INFNAN_NV_U8_DECL PL_nan = { LDBL_NAN };
#      elif defined(LDBL_QNAN)
INFNAN_NV_U8_DECL PL_nan = { LDBL_QNAN };
#      elif defined(NAN)
INFNAN_NV_U8_DECL PL_nan = { (NV)NAN };
#      else
INFNAN_NV_U8_DECL PL_nan = { 0.0L/0.0L }; /* keep last */
#      endif
#    else
#      if defined(DBL_NAN)
INFNAN_NV_U8_DECL PL_nan = { DBL_NAN };
#      elif defined(DBL_QNAN)
INFNAN_NV_U8_DECL PL_nan = { DBL_QNAN };
#      elif defined(NAN) /* C99 */
INFNAN_NV_U8_DECL PL_nan = { (NV)NAN };
#      else
INFNAN_NV_U8_DECL PL_nan = { 0.0/0.0 }; /* keep last */
#      endif
#    endif
#  endif

GCC_DIAG_RESTORE

#else

INFNAN_NV_U8_DECL PL_inf;
INFNAN_NV_U8_DECL PL_nan;

#endif

/* If you have not defined NV_INF/NV_NAN (like for example win32/win32.h),
 * we will define NV_INF/NV_NAN as the nv part of the global const
 * PL_inf/PL_nan.  Note, however, that the preexisting NV_INF/NV_NAN
 * might not be a compile-time constant, in which case it cannot be
 * used to initialize PL_inf/PL_nan above. */
#ifndef NV_INF
#  define NV_INF PL_inf.nv
#endif
#ifndef NV_NAN
#  define NV_NAN PL_nan.nv
#endif

/* if these never got defined, they need defaults */
#ifndef PERL_SET_CONTEXT
#  define PERL_SET_CONTEXT(i)		PERL_SET_INTERP(i)
#endif

#ifndef PERL_GET_CONTEXT
#  define PERL_GET_CONTEXT		PERL_GET_INTERP
#endif

#ifndef PERL_GET_THX
#  define PERL_GET_THX			((void*)NULL)
#endif

#ifndef PERL_SET_THX
#  define PERL_SET_THX(t)		NOOP
#endif


#ifndef PERL_NO_INLINE_FUNCTIONS
/* Static inline funcs that depend on includes and declarations above.
   Some of these reference functions in the perl object files, and some
   compilers aren't smart enough to eliminate unused static inline
   functions, so including this file in source code can cause link errors
   even if the source code uses none of the functions. Hence including these
   can be be suppressed by setting PERL_NO_INLINE_FUNCTIONS. Doing this will
   (obviously) result in unworkable XS code, but allows simple probing code
   to continue to work, because it permits tests to include the perl headers
   for definitions without creating a link dependency on the perl library
   (which may not exist yet).
*/

#  include "inline.h"
#endif

#include "overload.h"

END_EXTERN_C

struct am_table {
  U8 flags;
  U8 fallback;
  U16 spare;
  U32 was_ok_sub;
  CV* table[NofAMmeth];
};
struct am_table_short {
  U8 flags;
  U8 fallback;
  U16 spare;
  U32 was_ok_sub;
};
typedef struct am_table AMT;
typedef struct am_table_short AMTS;

#define AMGfallNEVER	1
#define AMGfallNO	2
#define AMGfallYES	3

#define AMTf_AMAGIC		1
#define AMT_AMAGIC(amt)		((amt)->flags & AMTf_AMAGIC)
#define AMT_AMAGIC_on(amt)	((amt)->flags |= AMTf_AMAGIC)
#define AMT_AMAGIC_off(amt)	((amt)->flags &= ~AMTf_AMAGIC)

#define StashHANDLER(stash,meth)	gv_handler((stash),CAT2(meth,_amg))

/*
 * some compilers like to redefine cos et alia as faster
 * (and less accurate?) versions called F_cos et cetera (Quidquid
 * latine dictum sit, altum viditur.)  This trick collides with
 * the Perl overloading (amg).  The following #defines fool both.
 */

#ifdef _FASTMATH
#   ifdef atan2
#       define F_atan2_amg  atan2_amg
#   endif
#   ifdef cos
#       define F_cos_amg    cos_amg
#   endif
#   ifdef exp
#       define F_exp_amg    exp_amg
#   endif
#   ifdef log
#       define F_log_amg    log_amg
#   endif
#   ifdef pow
#       define F_pow_amg    pow_amg
#   endif
#   ifdef sin
#       define F_sin_amg    sin_amg
#   endif
#   ifdef sqrt
#       define F_sqrt_amg   sqrt_amg
#   endif
#endif /* _FASTMATH */

#define PERLDB_ALL		(PERLDBf_SUB	| PERLDBf_LINE	|	\
				 PERLDBf_NOOPT	| PERLDBf_INTER	|	\
				 PERLDBf_SUBLINE| PERLDBf_SINGLE|	\
				 PERLDBf_NAMEEVAL| PERLDBf_NAMEANON |   \
				 PERLDBf_SAVESRC)
					/* No _NONAME, _GOTO */
#define PERLDBf_SUB		0x01	/* Debug sub enter/exit */
#define PERLDBf_LINE		0x02	/* Keep line # */
#define PERLDBf_NOOPT		0x04	/* Switch off optimizations */
#define PERLDBf_INTER		0x08	/* Preserve more data for
					   later inspections  */
#define PERLDBf_SUBLINE		0x10	/* Keep subr source lines */
#define PERLDBf_SINGLE		0x20	/* Start with single-step on */
#define PERLDBf_NONAME		0x40	/* For _SUB: no name of the subr */
#define PERLDBf_GOTO		0x80	/* Report goto: call DB::goto */
#define PERLDBf_NAMEEVAL	0x100	/* Informative names for evals */
#define PERLDBf_NAMEANON	0x200	/* Informative names for anon subs */
#define PERLDBf_SAVESRC  	0x400	/* Save source lines into @@{"_<$filename"} */
#define PERLDBf_SAVESRC_NOSUBS	0x800	/* Including evals that generate no subroutines */
#define PERLDBf_SAVESRC_INVALID	0x1000	/* Save source that did not compile */

#define PERLDB_SUB		(PL_perldb & PERLDBf_SUB)
#define PERLDB_LINE		(PL_perldb & PERLDBf_LINE)
#define PERLDB_NOOPT		(PL_perldb & PERLDBf_NOOPT)
#define PERLDB_INTER		(PL_perldb & PERLDBf_INTER)
#define PERLDB_SUBLINE		(PL_perldb & PERLDBf_SUBLINE)
#define PERLDB_SINGLE		(PL_perldb & PERLDBf_SINGLE)
#define PERLDB_SUB_NN		(PL_perldb & PERLDBf_NONAME)
#define PERLDB_GOTO		(PL_perldb & PERLDBf_GOTO)
#define PERLDB_NAMEEVAL 	(PL_perldb & PERLDBf_NAMEEVAL)
#define PERLDB_NAMEANON 	(PL_perldb & PERLDBf_NAMEANON)
#define PERLDB_SAVESRC  	(PL_perldb & PERLDBf_SAVESRC)
#define PERLDB_SAVESRC_NOSUBS	(PL_perldb & PERLDBf_SAVESRC_NOSUBS)
#define PERLDB_SAVESRC_INVALID	(PL_perldb & PERLDBf_SAVESRC_INVALID)

#define PERLDB_LINE_OR_SAVESRC (PL_perldb & (PERLDBf_LINE | PERLDBf_SAVESRC))

#ifdef USE_LOCALE
/* These locale things are all subject to change */

#   define LOCALE_INIT   MUTEX_INIT(&PL_locale_mutex)
#   define LOCALE_TERM   MUTEX_DESTROY(&PL_locale_mutex)

#   define LOCALE_LOCK   MUTEX_LOCK(&PL_locale_mutex)
#   define LOCALE_UNLOCK MUTEX_UNLOCK(&PL_locale_mutex)

/* Returns TRUE if the plain locale pragma without a parameter is in effect
 */
#   define IN_LOCALE_RUNTIME	cBOOL(CopHINTS_get(PL_curcop) & HINT_LOCALE)

/* Returns TRUE if either form of the locale pragma is in effect */
#   define IN_SOME_LOCALE_FORM_RUNTIME   \
           cBOOL(CopHINTS_get(PL_curcop) & (HINT_LOCALE|HINT_LOCALE_PARTIAL))

#   define IN_LOCALE_COMPILETIME	cBOOL(PL_hints & HINT_LOCALE)
#   define IN_SOME_LOCALE_FORM_COMPILETIME \
                          cBOOL(PL_hints & (HINT_LOCALE|HINT_LOCALE_PARTIAL))

#   define IN_LOCALE \
	(IN_PERL_COMPILETIME ? IN_LOCALE_COMPILETIME : IN_LOCALE_RUNTIME)
#   define IN_SOME_LOCALE_FORM \
	(IN_PERL_COMPILETIME ? IN_SOME_LOCALE_FORM_COMPILETIME \
	                     : IN_SOME_LOCALE_FORM_RUNTIME)

#   define IN_LC_ALL_COMPILETIME   IN_LOCALE_COMPILETIME
#   define IN_LC_ALL_RUNTIME       IN_LOCALE_RUNTIME

#   define IN_LC_PARTIAL_COMPILETIME   cBOOL(PL_hints & HINT_LOCALE_PARTIAL)
#   define IN_LC_PARTIAL_RUNTIME  \
                        cBOOL(CopHINTS_get(PL_curcop) & HINT_LOCALE_PARTIAL)

#   define IN_LC_COMPILETIME(category)                                       \
       (IN_LC_ALL_COMPILETIME || (IN_LC_PARTIAL_COMPILETIME                  \
                                  && _is_in_locale_category(TRUE, (category))))
#   define IN_LC_RUNTIME(category)                                           \
       (IN_LC_ALL_RUNTIME || (IN_LC_PARTIAL_RUNTIME                          \
                              && _is_in_locale_category(FALSE, (category))))
#   define IN_LC(category)  \
                    (IN_LC_COMPILETIME(category) || IN_LC_RUNTIME(category))

#   if defined (PERL_CORE) || defined (PERL_IN_XSUB_RE)

        /* This internal macro should be called from places that operate under
         * locale rules.  It there is a problem with the current locale that
         * hasn't been raised yet, it will output a warning this time.  Because
         * this will so rarely  be true, there is no point to optimize for
         * time; instead it makes sense to minimize space used and do all the
         * work in the rarely called function */
#       ifdef USE_LOCALE_CTYPE
#           define _CHECK_AND_WARN_PROBLEMATIC_LOCALE                         \
                STMT_START {                                                  \
                    if (UNLIKELY(PL_warn_locale)) {                           \
                        _warn_problematic_locale();                           \
                    }                                                         \
                }  STMT_END
#       else
#           define _CHECK_AND_WARN_PROBLEMATIC_LOCALE
#       endif


    /* These two internal macros are called when a warning should be raised,
     * and will do so if enabled.  The first takes a single code point
     * argument; the 2nd, is a pointer to the first byte of the UTF-8 encoded
     * string, and an end position which it won't try to read past */
#   define _CHECK_AND_OUTPUT_WIDE_LOCALE_CP_MSG(cp)                         \
	STMT_START {                                                        \
            if (! PL_in_utf8_CTYPE_locale && ckWARN(WARN_LOCALE)) {         \
                Perl_warner(aTHX_ packWARN(WARN_LOCALE),                    \
                                        "Wide character (U+%"UVXf") in %s", \
                                        (UV) cp, OP_DESC(PL_op));           \
            }                                                               \
        }  STMT_END

#  define _CHECK_AND_OUTPUT_WIDE_LOCALE_UTF8_MSG(s, send)                   \
	STMT_START { /* Check if to warn before doing the conversion work */\
            if (! PL_in_utf8_CTYPE_locale && ckWARN(WARN_LOCALE)) {         \
                UV cp = utf8_to_uvchr_buf((U8 *) s, (U8 *) send, NULL);     \
                Perl_warner(aTHX_ packWARN(WARN_LOCALE),                    \
                    "Wide character (U+%"UVXf") in %s",                     \
                    (cp == 0)                                               \
                     ? UNICODE_REPLACEMENT                                  \
                     : (UV) cp,                                             \
                    OP_DESC(PL_op));                                        \
            }                                                               \
        }  STMT_END

#   endif   /* PERL_CORE or PERL_IN_XSUB_RE */

#else   /* No locale usage */
#   define LOCALE_INIT
#   define LOCALE_TERM
#   define LOCALE_LOCK
#   define LOCALE_UNLOCK
#   define IN_LOCALE_RUNTIME                0
#   define IN_SOME_LOCALE_FORM_RUNTIME      0
#   define IN_LOCALE_COMPILETIME            0
#   define IN_SOME_LOCALE_FORM_COMPILETIME  0
#   define IN_LOCALE                        0
#   define IN_SOME_LOCALE_FORM              0
#   define IN_LC_ALL_COMPILETIME            0
#   define IN_LC_ALL_RUNTIME                0
#   define IN_LC_PARTIAL_COMPILETIME        0
#   define IN_LC_PARTIAL_RUNTIME            0
#   define IN_LC_COMPILETIME(category)      0
#   define IN_LC_RUNTIME(category)          0
#   define IN_LC(category)                  0

#   define _CHECK_AND_WARN_PROBLEMATIC_LOCALE
#   define _CHECK_AND_OUTPUT_WIDE_LOCALE_CP_MSG(a)
#   define _CHECK_AND_OUTPUT_WIDE_LOCALE_UTF8_MSG(a,b)
#endif

#ifdef USE_LOCALE_NUMERIC

/* These macros are for toggling between the underlying locale (UNDERLYING or
 * LOCAL) and the C locale (STANDARD).

=head1 Locale-related functions and macros

=for apidoc Amn|void|DECLARATION_FOR_LC_NUMERIC_MANIPULATION

This macro should be used as a statement.  It declares a private variable
(whose name begins with an underscore) that is needed by the other macros in
this section.  Failing to include this correctly should lead to a syntax error.
For compatibility with C89 C compilers it should be placed in a block before
any executable statements.

=for apidoc Am|void|STORE_LC_NUMERIC_FORCE_TO_UNDERLYING

This is used by XS code that that is C<LC_NUMERIC> locale-aware to force the
locale for category C<LC_NUMERIC> to be what perl thinks is the current
underlying locale.  (The perl interpreter could be wrong about what the
underlying locale actually is if some C or XS code has called the C library
function L<setlocale(3)> behind its back; calling L</sync_locale> before calling
this macro will update perl's records.)

A call to L</DECLARATION_FOR_LC_NUMERIC_MANIPULATION> must have been made to
declare at compile time a private variable used by this macro.  This macro
should be called as a single statement, not an expression, but with an empty
argument list, like this:

 {
    DECLARATION_FOR_LC_NUMERIC_MANIPULATION;
     ...
    STORE_LC_NUMERIC_FORCE_TO_UNDERLYING();
     ...
    RESTORE_LC_NUMERIC();
     ...
 }

The private variable is used to save the current locale state, so
that the requisite matching call to L</RESTORE_LC_NUMERIC> can restore it.

=for apidoc Am|void|STORE_LC_NUMERIC_SET_TO_NEEDED

This is used to help wrap XS or C code that that is C<LC_NUMERIC> locale-aware.
This locale category is generally kept set to the C locale by Perl for
backwards compatibility, and because most XS code that reads floating point
values can cope only with the decimal radix character being a dot.

This macro makes sure the current C<LC_NUMERIC> state is set properly, to be
aware of locale if the call to the XS or C code from the Perl program is
from within the scope of a S<C<use locale>>; or to ignore locale if the call is
instead from outside such scope.

This macro is the start of wrapping the C or XS code; the wrap ending is done
by calling the L</RESTORE_LC_NUMERIC> macro after the operation.  Otherwise
the state can be changed that will adversely affect other XS code.

A call to L</DECLARATION_FOR_LC_NUMERIC_MANIPULATION> must have been made to
declare at compile time a private variable used by this macro.  This macro
should be called as a single statement, not an expression, but with an empty
argument list, like this:

 {
    DECLARATION_FOR_LC_NUMERIC_MANIPULATION;
     ...
    STORE_LC_NUMERIC_SET_TO_NEEDED();
     ...
    RESTORE_LC_NUMERIC();
     ...
 }

=for apidoc Am|void|RESTORE_LC_NUMERIC

This is used in conjunction with one of the macros
L</STORE_LC_NUMERIC_SET_TO_NEEDED>
and
L</STORE_LC_NUMERIC_FORCE_TO_UNDERLYING>

to properly restore the C<LC_NUMERIC> state.

A call to L</DECLARATION_FOR_LC_NUMERIC_MANIPULATION> must have been made to
declare at compile time a private variable used by this macro and the two
C<STORE> ones.  This macro should be called as a single statement, not an
expression, but with an empty argument list, like this:

 {
    DECLARATION_FOR_LC_NUMERIC_MANIPULATION;
     ...
    RESTORE_LC_NUMERIC();
     ...
 }

=cut

*/

#define _NOT_IN_NUMERIC_STANDARD (! PL_numeric_standard)

/* We can lock the category to stay in the C locale, making requests to the
 * contrary be noops, in the dynamic scope by setting PL_numeric_standard to 2.
 * */
#define _NOT_IN_NUMERIC_UNDERLYING                                          \
                        (! PL_numeric_local && PL_numeric_standard < 2)

#define DECLARATION_FOR_LC_NUMERIC_MANIPULATION                             \
    void (*_restore_LC_NUMERIC_function)(pTHX) = NULL

#define STORE_LC_NUMERIC_SET_TO_NEEDED()                                    \
    if (IN_LC(LC_NUMERIC)) {                                                \
        if (_NOT_IN_NUMERIC_UNDERLYING) {                                   \
            set_numeric_local();                                            \
            _restore_LC_NUMERIC_function = &Perl_set_numeric_standard;      \
        }                                                                   \
    }                                                                       \
    else {                                                                  \
        if (_NOT_IN_NUMERIC_STANDARD) {                                     \
            SET_NUMERIC_STANDARD();                                         \
            _restore_LC_NUMERIC_function = &Perl_set_numeric_local;         \
        }                                                                   \
    }

#define RESTORE_LC_NUMERIC()                                                \
    if (_restore_LC_NUMERIC_function) {                                     \
        _restore_LC_NUMERIC_function(aTHX);                                 \
    }

/* The next two macros set unconditionally.  These should be rarely used, and
 * only after being sure that this is what is needed */
#define SET_NUMERIC_STANDARD()                                              \
	STMT_START { if (_NOT_IN_NUMERIC_STANDARD) set_numeric_standard();  \
                                                                 } STMT_END

#define SET_NUMERIC_UNDERLYING()                                            \
	STMT_START { if (_NOT_IN_NUMERIC_UNDERLYING)                        \
                                            set_numeric_local(); } STMT_END

/* The rest of these LC_NUMERIC macros toggle to one or the other state, with
 * the RESTORE_foo ones called to switch back, but only if need be */
#define STORE_LC_NUMERIC_UNDERLYING_SET_STANDARD()                          \
	bool _was_local = _NOT_IN_NUMERIC_STANDARD;                         \
	if (_was_local) set_numeric_standard();

/* Doesn't change to underlying locale unless within the scope of some form of
 * 'use locale'.  This is the usual desired behavior. */
#define STORE_LC_NUMERIC_STANDARD_SET_UNDERLYING()                          \
	bool _was_standard = _NOT_IN_NUMERIC_UNDERLYING                     \
                            && IN_LC(LC_NUMERIC);                           \
	if (_was_standard) set_numeric_local();

/* Rarely, we want to change to the underlying locale even outside of 'use
 * locale'.  This is principally in the POSIX:: functions */
#define STORE_LC_NUMERIC_FORCE_TO_UNDERLYING()                              \
    if (_NOT_IN_NUMERIC_UNDERLYING) {                                       \
        set_numeric_local();                                                \
        _restore_LC_NUMERIC_function = &Perl_set_numeric_standard;          \
    }

/* Lock to the C locale until unlock is called */
#define LOCK_LC_NUMERIC_STANDARD()                          \
        (__ASSERT_(PL_numeric_standard)                     \
        PL_numeric_standard = 2)

#define UNLOCK_LC_NUMERIC_STANDARD()                        \
        (__ASSERT_(PL_numeric_standard == 2)                \
        PL_numeric_standard = 1)

#define RESTORE_LC_NUMERIC_UNDERLYING()                     \
	if (_was_local) set_numeric_local();

#define RESTORE_LC_NUMERIC_STANDARD()                       \
    if (_restore_LC_NUMERIC_function) {                     \
        _restore_LC_NUMERIC_function(aTHX);                 \
    }

#else /* !USE_LOCALE_NUMERIC */

#define SET_NUMERIC_STANDARD()
#define SET_NUMERIC_UNDERLYING()
#define IS_NUMERIC_RADIX(a, b)		(0)
#define STORE_LC_NUMERIC_UNDERLYING_SET_STANDARD()
#define STORE_LC_NUMERIC_STANDARD_SET_UNDERLYING()
#define STORE_LC_NUMERIC_FORCE_TO_UNDERLYING()
#define RESTORE_LC_NUMERIC_UNDERLYING()
#define RESTORE_LC_NUMERIC_STANDARD()
#define DECLARATION_FOR_LC_NUMERIC_MANIPULATION
#define STORE_LC_NUMERIC_SET_TO_NEEDED()
#define RESTORE_LC_NUMERIC()
#define LOCK_LC_NUMERIC_STANDARD()
#define UNLOCK_LC_NUMERIC_STANDARD()

#endif /* !USE_LOCALE_NUMERIC */

#define Atof				my_atof

/* Back-compat names */
#define DECLARATION_FOR_STORE_LC_NUMERIC_SET_TO_NEEDED              \
                        DECLARATION_FOR_LC_NUMERIC_MANIPULATION
#define DECLARE_STORE_LC_NUMERIC_SET_TO_NEEDED()                    \
                DECLARATION_FOR_STORE_LC_NUMERIC_SET_TO_NEEDED;     \
                STORE_LC_NUMERIC_SET_TO_NEEDED();
#define LOCK_NUMERIC_STANDARD() LOCK_LC_NUMERIC_STANDARD()
#define RESTORE_NUMERIC_LOCAL() RESTORE_LC_NUMERIC_UNDERLYING()
#define RESTORE_NUMERIC_STANDARD() RESTORE_LC_NUMERIC_STANDARD()
#define SET_NUMERIC_LOCAL() SET_NUMERIC_UNDERLYING()
#define STORE_NUMERIC_LOCAL_SET_STANDARD()                          \
                    STORE_LC_NUMERIC_UNDERLYING_SET_STANDARD()
#define STORE_NUMERIC_STANDARD_SET_LOCAL()                          \
                    STORE_LC_NUMERIC_STANDARD_SET_UNDERLYING()
#define STORE_NUMERIC_STANDARD_FORCE_LOCAL()                        \
                        STORE_LC_NUMERIC_FORCE_TO_UNDERLYING()
#define UNLOCK_NUMERIC_STANDARD() UNLOCK_LC_NUMERIC_STANDARD()



#ifdef USE_QUADMATH
#  define Perl_strtod(s, e) strtoflt128(s, e)
#elif defined(HAS_LONG_DOUBLE) && defined(USE_LONG_DOUBLE)
#  if defined(HAS_STRTOLD)
#    define Perl_strtod(s, e) strtold(s, e)
#  elif defined(HAS_STRTOD)
#    define Perl_strtod(s, e) (NV)strtod(s, e) /* Unavoidable loss. */
#  endif
#elif defined(HAS_STRTOD)
#  define Perl_strtod(s, e) strtod(s, e)
#endif

#if !defined(Strtol) && defined(USE_64_BIT_INT) && defined(IV_IS_QUAD) && \
	(QUADKIND == QUAD_IS_LONG_LONG || QUADKIND == QUAD_IS___INT64)
#    ifdef __hpux
#        define strtoll __strtoll	/* secret handshake */
#    endif
#    ifdef WIN64
#        define strtoll _strtoi64	/* secret handshake */
#    endif
#   if !defined(Strtol) && defined(HAS_STRTOLL)
#       define Strtol	strtoll
#   endif
#    if !defined(Strtol) && defined(HAS_STRTOQ)
#       define Strtol	strtoq
#    endif
/* is there atoq() anywhere? */
#endif
#if !defined(Strtol) && defined(HAS_STRTOL)
#   define Strtol	strtol
#endif
#ifndef Atol
/* It would be more fashionable to use Strtol() to define atol()
 * (as is done for Atoul(), see below) but for backward compatibility
 * we just assume atol(). */
#   if defined(USE_64_BIT_INT) && defined(IV_IS_QUAD) && defined(HAS_ATOLL) && \
	(QUADKIND == QUAD_IS_LONG_LONG || QUADKIND == QUAD_IS___INT64)
#    ifdef WIN64
#       define atoll    _atoi64		/* secret handshake */
#    endif
#       define Atol	atoll
#   else
#       define Atol	atol
#   endif
#endif

#if !defined(Strtoul) && defined(USE_64_BIT_INT) && defined(UV_IS_QUAD) && \
	(QUADKIND == QUAD_IS_LONG_LONG || QUADKIND == QUAD_IS___INT64)
#    ifdef __hpux
#        define strtoull __strtoull	/* secret handshake */
#    endif
#    ifdef WIN64
#        define strtoull _strtoui64	/* secret handshake */
#    endif
#    if !defined(Strtoul) && defined(HAS_STRTOULL)
#       define Strtoul	strtoull
#    endif
#    if !defined(Strtoul) && defined(HAS_STRTOUQ)
#       define Strtoul	strtouq
#    endif
/* is there atouq() anywhere? */
#endif
#if !defined(Strtoul) && defined(HAS_STRTOUL)
#   define Strtoul	strtoul
#endif
#if !defined(Strtoul) && defined(HAS_STRTOL) /* Last resort. */
#   define Strtoul(s, e, b)	strchr((s), '-') ? ULONG_MAX : (unsigned long)strtol((s), (e), (b))
#endif
#ifndef Atoul
#   define Atoul(s)	Strtoul(s, NULL, 10)
#endif

#ifndef PERL_SCRIPT_MODE
#define PERL_SCRIPT_MODE "r"
#endif

/* not used. Kept as a NOOP for backcompat */
#define PERL_STACK_OVERFLOW_CHECK()  NOOP

/*
 * Some nonpreemptive operating systems find it convenient to
 * check for asynchronous conditions after each op execution.
 * Keep this check simple, or it may slow down execution
 * massively.
 */

#ifndef PERL_MICRO
#	ifndef PERL_ASYNC_CHECK
#		define PERL_ASYNC_CHECK() if (UNLIKELY(PL_sig_pending)) PL_signalhook(aTHX)
#	endif
#endif

#ifndef PERL_ASYNC_CHECK
#   define PERL_ASYNC_CHECK()  NOOP
#endif

/*
 * On some operating systems, a memory allocation may succeed,
 * but put the process too close to the system's comfort limit.
 * In this case, PERL_ALLOC_CHECK frees the pointer and sets
 * it to NULL.
 */
#ifndef PERL_ALLOC_CHECK
#define PERL_ALLOC_CHECK(p)  NOOP
#endif

#ifdef HAS_SEM
#   include <sys/ipc.h>
#   include <sys/sem.h>
#   ifndef HAS_UNION_SEMUN	/* Provide the union semun. */
    union semun {
	int		val;
	struct semid_ds	*buf;
	unsigned short	*array;
    };
#   endif
#   ifdef USE_SEMCTL_SEMUN
#	ifdef IRIX32_SEMUN_BROKEN_BY_GCC
            union gccbug_semun {
		int             val;
		struct semid_ds *buf;
		unsigned short  *array;
		char            __dummy[5];
	    };
#           define semun gccbug_semun
#	endif
#       define Semctl(id, num, cmd, semun) semctl(id, num, cmd, semun)
#   else
#       ifdef USE_SEMCTL_SEMID_DS
#           ifdef EXTRA_F_IN_SEMUN_BUF
#               define Semctl(id, num, cmd, semun) semctl(id, num, cmd, semun.buff)
#           else
#               define Semctl(id, num, cmd, semun) semctl(id, num, cmd, semun.buf)
#           endif
#       endif
#   endif
#endif

/*
 * Boilerplate macros for initializing and accessing interpreter-local
 * data from C.  All statics in extensions should be reworked to use
 * this, if you want to make the extension thread-safe.  See
 * ext/XS/APItest/APItest.xs for an example of the use of these macros,
 * and perlxs.pod for more.
 *
 * Code that uses these macros is responsible for the following:
 * 1. #define MY_CXT_KEY to a unique string, e.g.
 *    "DynaLoader::_guts" XS_VERSION
 *    XXX in the current implementation, this string is ignored.
 * 2. Declare a typedef named my_cxt_t that is a structure that contains
 *    all the data that needs to be interpreter-local.
 * 3. Use the START_MY_CXT macro after the declaration of my_cxt_t.
 * 4. Use the MY_CXT_INIT macro such that it is called exactly once
 *    (typically put in the BOOT: section).
 * 5. Use the members of the my_cxt_t structure everywhere as
 *    MY_CXT.member.
 * 6. Use the dMY_CXT macro (a declaration) in all the functions that
 *    access MY_CXT.
 */

#if defined(PERL_IMPLICIT_CONTEXT)

/* START_MY_CXT must appear in all extensions that define a my_cxt_t structure,
 * right after the definition (i.e. at file scope).  The non-threads
 * case below uses it to declare the data as static. */
#  ifdef PERL_GLOBAL_STRUCT_PRIVATE
#    define START_MY_CXT
#    define MY_CXT_INDEX Perl_my_cxt_index(aTHX_ MY_CXT_KEY)
#    define MY_CXT_INIT_ARG MY_CXT_KEY
#  else
#    define START_MY_CXT static int my_cxt_index = -1;
#    define MY_CXT_INDEX my_cxt_index
#    define MY_CXT_INIT_ARG &my_cxt_index
#  endif /* #ifdef PERL_GLOBAL_STRUCT_PRIVATE */

/* Creates and zeroes the per-interpreter data.
 * (We allocate my_cxtp in a Perl SV so that it will be released when
 * the interpreter goes away.) */
#  define MY_CXT_INIT \
	my_cxt_t *my_cxtp = \
	    (my_cxt_t*)Perl_my_cxt_init(aTHX_ MY_CXT_INIT_ARG, sizeof(my_cxt_t)); \
	PERL_UNUSED_VAR(my_cxtp)
#  define MY_CXT_INIT_INTERP(my_perl) \
	my_cxt_t *my_cxtp = \
	    (my_cxt_t*)Perl_my_cxt_init(my_perl, MY_CXT_INIT_ARG, sizeof(my_cxt_t)); \
	PERL_UNUSED_VAR(my_cxtp)

/* This declaration should be used within all functions that use the
 * interpreter-local data. */
#  define dMY_CXT	\
	my_cxt_t *my_cxtp = (my_cxt_t *)PL_my_cxt_list[MY_CXT_INDEX]
#  define dMY_CXT_INTERP(my_perl)	\
	my_cxt_t *my_cxtp = (my_cxt_t *)(my_perl)->Imy_cxt_list[MY_CXT_INDEX]

/* Clones the per-interpreter data. */
#  define MY_CXT_CLONE \
	my_cxt_t *my_cxtp = (my_cxt_t*)SvPVX(newSV(sizeof(my_cxt_t)-1));\
	void * old_my_cxtp = PL_my_cxt_list[MY_CXT_INDEX];		\
	PL_my_cxt_list[MY_CXT_INDEX] = my_cxtp;				\
	Copy(old_my_cxtp, my_cxtp, 1, my_cxt_t);



/* This macro must be used to access members of the my_cxt_t structure.
 * e.g. MY_CXT.some_data */
#  define MY_CXT		(*my_cxtp)

/* Judicious use of these macros can reduce the number of times dMY_CXT
 * is used.  Use is similar to pTHX, aTHX etc. */
#  define pMY_CXT	my_cxt_t *my_cxtp
#  define pMY_CXT_	pMY_CXT,
#  define _pMY_CXT	,pMY_CXT
#  define aMY_CXT	my_cxtp
#  define aMY_CXT_	aMY_CXT,
#  define _aMY_CXT	,aMY_CXT

#else /* PERL_IMPLICIT_CONTEXT */

#  define START_MY_CXT		static my_cxt_t my_cxt;
#  define dMY_CXT_SV	    	dNOOP
#  define dMY_CXT		dNOOP
#  define dMY_CXT_INTERP(my_perl) dNOOP
#  define MY_CXT_INIT		NOOP
#  define MY_CXT_CLONE		NOOP
#  define MY_CXT		my_cxt

#  define pMY_CXT		void
#  define pMY_CXT_
#  define _pMY_CXT
#  define aMY_CXT
#  define aMY_CXT_
#  define _aMY_CXT

#endif /* !defined(PERL_IMPLICIT_CONTEXT) */

#ifdef I_FCNTL
#  include <fcntl.h>
#endif

#ifdef __Lynx__
#  include <fcntl.h>
#endif

#ifdef __amigaos4__
#  undef FD_CLOEXEC /* a lie in AmigaOS */
#endif

#ifdef I_SYS_FILE
#  include <sys/file.h>
#endif

#if defined(HAS_FLOCK) && !defined(HAS_FLOCK_PROTO)
int flock(int fd, int op);
#endif

#ifndef O_RDONLY
/* Assume UNIX defaults */
#    define O_RDONLY	0000
#    define O_WRONLY	0001
#    define O_RDWR	0002
#    define O_CREAT	0100
#endif

#ifndef O_BINARY
#  define O_BINARY 0
#endif

#ifndef O_TEXT
#  define O_TEXT 0
#endif

#if O_TEXT != O_BINARY
    /* If you have different O_TEXT and O_BINARY and you are a CRLF shop,
     * that is, you are somehow DOSish. */
#   if defined(__HAIKU__) || defined(__VOS__) || defined(__CYGWIN__)
    /* Haiku has O_TEXT != O_BINARY but O_TEXT and O_BINARY have no effect;
     * Haiku is always UNIXoid (LF), not DOSish (CRLF). */
    /* VOS has O_TEXT != O_BINARY, and they have effect,
     * but VOS always uses LF, never CRLF. */
    /* If you have O_TEXT different from your O_BINARY but you still are
     * not a CRLF shop. */
#       undef PERLIO_USING_CRLF
#   else
    /* If you really are DOSish. */
#      define PERLIO_USING_CRLF 1
#   endif
#endif

#ifdef I_LIBUTIL
#   include <libutil.h>		/* setproctitle() in some FreeBSDs */
#endif

#ifndef EXEC_ARGV_CAST
#define EXEC_ARGV_CAST(x) (char **)x
#endif

#define IS_NUMBER_IN_UV		      0x01 /* number within UV range (maybe not
					      int).  value returned in pointed-
					      to UV */
#define IS_NUMBER_GREATER_THAN_UV_MAX 0x02 /* pointed to UV undefined */
#define IS_NUMBER_NOT_INT	      0x04 /* saw . or E notation or infnan */
#define IS_NUMBER_NEG		      0x08 /* leading minus sign */
#define IS_NUMBER_INFINITY	      0x10 /* this is big */
#define IS_NUMBER_NAN                 0x20 /* this is not */
#define IS_NUMBER_TRAILING            0x40 /* number has trailing trash */

#define GROK_NUMERIC_RADIX(sp, send) grok_numeric_radix(sp, send)

/* Input flags: */
#define PERL_SCAN_ALLOW_UNDERSCORES   0x01 /* grok_??? accept _ in numbers */
#define PERL_SCAN_DISALLOW_PREFIX     0x02 /* grok_??? reject 0x in hex etc */
#define PERL_SCAN_SILENT_ILLDIGIT     0x04 /* grok_??? not warn about illegal digits */
#define PERL_SCAN_SILENT_NON_PORTABLE 0x08 /* grok_??? not warn about very large
					      numbers which are <= UV_MAX */
#define PERL_SCAN_TRAILING            0x10 /* grok_number_flags() allow trailing
                                              and set IS_NUMBER_TRAILING */

/* Output flags: */
#define PERL_SCAN_GREATER_THAN_UV_MAX 0x02 /* should this merge with above? */

/* to let user control profiling */
#ifdef PERL_GPROF_CONTROL
extern void moncontrol(int);
#define PERL_GPROF_MONCONTROL(x) moncontrol(x)
#else
#define PERL_GPROF_MONCONTROL(x)
#endif

#ifdef UNDER_CE
#include "wince.h"
#endif

/* ISO 6429 NEL - C1 control NExt Line */
/* See http://www.unicode.org/unicode/reports/tr13/ */
#define NEXT_LINE_CHAR	NEXT_LINE_NATIVE

#ifndef PIPESOCK_MODE
#  define PIPESOCK_MODE
#endif

#ifndef SOCKET_OPEN_MODE
#  define SOCKET_OPEN_MODE	PIPESOCK_MODE
#endif

#ifndef PIPE_OPEN_MODE
#  define PIPE_OPEN_MODE	PIPESOCK_MODE
#endif

#define PERL_MAGIC_UTF8_CACHESIZE	2

#define PERL_UNICODE_STDIN_FLAG			0x0001
#define PERL_UNICODE_STDOUT_FLAG		0x0002
#define PERL_UNICODE_STDERR_FLAG		0x0004
#define PERL_UNICODE_IN_FLAG			0x0008
#define PERL_UNICODE_OUT_FLAG			0x0010
#define PERL_UNICODE_ARGV_FLAG			0x0020
#define PERL_UNICODE_LOCALE_FLAG		0x0040
#define PERL_UNICODE_WIDESYSCALLS_FLAG		0x0080 /* for Sarathy */
#define PERL_UNICODE_UTF8CACHEASSERT_FLAG	0x0100

#define PERL_UNICODE_STD_FLAG		\
	(PERL_UNICODE_STDIN_FLAG	| \
	 PERL_UNICODE_STDOUT_FLAG	| \
	 PERL_UNICODE_STDERR_FLAG)

#define PERL_UNICODE_INOUT_FLAG		\
	(PERL_UNICODE_IN_FLAG	| \
	 PERL_UNICODE_OUT_FLAG)

#define PERL_UNICODE_DEFAULT_FLAGS	\
	(PERL_UNICODE_STD_FLAG		| \
	 PERL_UNICODE_INOUT_FLAG	| \
	 PERL_UNICODE_LOCALE_FLAG)

#define PERL_UNICODE_ALL_FLAGS			0x01ff

#define PERL_UNICODE_STDIN			'I'
#define PERL_UNICODE_STDOUT			'O'
#define PERL_UNICODE_STDERR			'E'
#define PERL_UNICODE_STD			'S'
#define PERL_UNICODE_IN				'i'
#define PERL_UNICODE_OUT			'o'
#define PERL_UNICODE_INOUT			'D'
#define PERL_UNICODE_ARGV			'A'
#define PERL_UNICODE_LOCALE			'L'
#define PERL_UNICODE_WIDESYSCALLS		'W'
#define PERL_UNICODE_UTF8CACHEASSERT		'a'

#define PERL_SIGNALS_UNSAFE_FLAG	0x0001

/* Use instead of abs() since abs() forces its argument to be an int,
 * but also beware since this evaluates its argument twice, so no x++. */
#define PERL_ABS(x) ((x) < 0 ? -(x) : (x))

#if defined(__DECC) && defined(__osf__)
#pragma message disable (mainparm) /* Perl uses the envp in main(). */
#endif

#define do_open(g, n, l, a, rm, rp, sf) \
	do_openn(g, n, l, a, rm, rp, sf, (SV **) NULL, 0)
#ifdef PERL_DEFAULT_DO_EXEC3_IMPLEMENTATION
#  define do_exec(cmd)			do_exec3(cmd,0,0)
#endif
#ifdef OS2
#  define do_aexec			Perl_do_aexec
#else
#  define do_aexec(really, mark,sp)	do_aexec5(really, mark, sp, 0, 0)
#endif

/* check embedded \0 characters in pathnames passed to syscalls,
   but allow one ending \0 */
#define IS_SAFE_SYSCALL(p, len, what, op_name) (S_is_safe_syscall(aTHX_ (p), (len), (what), (op_name)))

#define IS_SAFE_PATHNAME(p, len, op_name) IS_SAFE_SYSCALL((p), (len), "pathname", (op_name))

#if defined(OEMVS) || defined(__amigaos4__)
#define NO_ENV_ARRAY_IN_MAIN
#endif

/* These are used by Perl_pv_escape() and Perl_pv_pretty()
 * are here so that they are available throughout the core
 * NOTE that even though some are for _escape and some for _pretty
 * there must not be any clashes as the flags from _pretty are
 * passed straight through to _escape.
 */

#define PERL_PV_ESCAPE_QUOTE        0x000001
#define PERL_PV_PRETTY_QUOTE        PERL_PV_ESCAPE_QUOTE

#define PERL_PV_PRETTY_ELLIPSES     0x000002
#define PERL_PV_PRETTY_LTGT         0x000004
#define PERL_PV_PRETTY_EXACTSIZE    0x000008

#define PERL_PV_ESCAPE_UNI          0x000100
#define PERL_PV_ESCAPE_UNI_DETECT   0x000200
#define PERL_PV_ESCAPE_NONASCII     0x000400
#define PERL_PV_ESCAPE_FIRSTCHAR    0x000800

#define PERL_PV_ESCAPE_ALL            0x001000
#define PERL_PV_ESCAPE_NOBACKSLASH  0x002000
#define PERL_PV_ESCAPE_NOCLEAR      0x004000
#define PERL_PV_PRETTY_NOCLEAR      PERL_PV_ESCAPE_NOCLEAR
#define PERL_PV_ESCAPE_RE           0x008000

#define PERL_PV_ESCAPE_DWIM         0x010000


/* used by pv_display in dump.c*/
#define PERL_PV_PRETTY_DUMP  PERL_PV_PRETTY_ELLIPSES|PERL_PV_PRETTY_QUOTE
#define PERL_PV_PRETTY_REGPROP PERL_PV_PRETTY_ELLIPSES|PERL_PV_PRETTY_LTGT|PERL_PV_ESCAPE_RE|PERL_PV_ESCAPE_NONASCII

#if DOUBLEKIND == DOUBLE_IS_IEEE_754_32_BIT_LITTLE_ENDIAN || \
    DOUBLEKIND == DOUBLE_IS_IEEE_754_64_BIT_LITTLE_ENDIAN || \
    DOUBLEKIND == DOUBLE_IS_IEEE_754_128_BIT_LITTLE_ENDIAN
#  define DOUBLE_LITTLE_ENDIAN
#endif

#if DOUBLEKIND == DOUBLE_IS_IEEE_754_32_BIT_BIG_ENDIAN || \
    DOUBLEKIND == DOUBLE_IS_IEEE_754_64_BIT_BIG_ENDIAN || \
    DOUBLEKIND == DOUBLE_IS_IEEE_754_128_BIT_BIG_ENDIAN
#  define DOUBLE_BIG_ENDIAN
#endif

#if DOUBLEKIND == DOUBLE_IS_IEEE_754_64_BIT_MIXED_ENDIAN_LE_BE || \
    DOUBLEKIND == DOUBLE_IS_IEEE_754_64_BIT_MIXED_ENDIAN_BE_LE
#  define DOUBLE_MIX_ENDIAN
#endif

/* All the basic IEEE formats have the implicit bit,
 * except for the 80-bit extended formats, which will undef this. */
#define NV_IMPLICIT_BIT

#ifdef LONG_DOUBLEKIND

#  if LONG_DOUBLEKIND == LONG_DOUBLE_IS_IEEE_754_128_BIT_LITTLE_ENDIAN || \
      LONG_DOUBLEKIND == LONG_DOUBLE_IS_X86_80_BIT_LITTLE_ENDIAN || \
      LONG_DOUBLEKIND == LONG_DOUBLE_IS_DOUBLEDOUBLE_128_BIT_LE_LE
#    define LONGDOUBLE_LITTLE_ENDIAN
#  endif

#  if LONG_DOUBLEKIND == LONG_DOUBLE_IS_IEEE_754_128_BIT_BIG_ENDIAN || \
      LONG_DOUBLEKIND == LONG_DOUBLE_IS_X86_80_BIT_BIG_ENDIAN || \
      LONG_DOUBLEKIND == LONG_DOUBLE_IS_DOUBLEDOUBLE_128_BIT_BE_BE
#    define LONGDOUBLE_BIG_ENDIAN
#  endif

#  if LONG_DOUBLEKIND == LONG_DOUBLE_IS_DOUBLEDOUBLE_128_BIT_LE_BE || \
      LONG_DOUBLEKIND == LONG_DOUBLE_IS_DOUBLEDOUBLE_128_BIT_BE_LE
#    define LONGDOUBLE_MIX_ENDIAN
#  endif

#  if LONG_DOUBLEKIND == LONG_DOUBLE_IS_X86_80_BIT_LITTLE_ENDIAN || \
      LONG_DOUBLEKIND == LONG_DOUBLE_IS_X86_80_BIT_BIG_ENDIAN
#    define LONGDOUBLE_X86_80_BIT
#    ifdef USE_LONG_DOUBLE
#      undef NV_IMPLICIT_BIT
#    endif
#  endif

#  if LONG_DOUBLEKIND == LONG_DOUBLE_IS_DOUBLEDOUBLE_128_BIT_LE_LE || \
      LONG_DOUBLEKIND == LONG_DOUBLE_IS_DOUBLEDOUBLE_128_BIT_BE_BE || \
      LONG_DOUBLEKIND == LONG_DOUBLE_IS_DOUBLEDOUBLE_128_BIT_LE_BE || \
      LONG_DOUBLEKIND == LONG_DOUBLE_IS_DOUBLEDOUBLE_128_BIT_BE_LE
#    define LONGDOUBLE_DOUBLEDOUBLE
#  endif

#endif /* LONG_DOUBLEKIND */

#ifdef USE_QUADMATH /* assume quadmath endianness == native double endianness */
#  if defined(DOUBLE_LITTLE_ENDIAN)
#    define NV_LITTLE_ENDIAN
#  elif defined(DOUBLE_BIG_ENDIAN)
#    define NV_BIG_ENDIAN
#  elif defined(DOUBLE_MIX_ENDIAN) /* stretch */
#    define NV_MIX_ENDIAN
#  endif
#elif NVSIZE == DOUBLESIZE
#  ifdef DOUBLE_LITTLE_ENDIAN
#    define NV_LITTLE_ENDIAN
#  endif
#  ifdef DOUBLE_BIG_ENDIAN
#    define NV_BIG_ENDIAN
#  endif
#  ifdef DOUBLE_MIX_ENDIAN
#    define NV_MIX_ENDIAN
#  endif
#elif NVSIZE == LONG_DOUBLESIZE
#  ifdef LONGDOUBLE_LITTLE_ENDIAN
#    define NV_LITTLE_ENDIAN
#  endif
#  ifdef LONGDOUBLE_BIG_ENDIAN
#    define NV_BIG_ENDIAN
#  endif
#  ifdef LONGDOUBLE_MIX_ENDIAN
#    define NV_MIX_ENDIAN
#  endif
#endif

/* NaNs (not-a-numbers) can carry payload bits, in addition to
 * "nan-ness".  Part of the payload is the quiet/signaling bit.
 * To back up a bit (harhar):
 *
 * For IEEE 754 64-bit formats [1]:
 *
 * s 000 (mantissa all-zero)  zero
 * s 000 (mantissa non-zero)  subnormals (denormals)
 * s 001 ... 7fe              normals
 * s 7ff q                    nan
 *
 * For IEEE 754 128-bit formats:
 *
 * s 0000 (mantissa all-zero)  zero
 * s 0000 (mantissa non-zero)  subnormals (denormals)
 * s 0001 ... 7ffe             normals
 * s 7fff q                    nan
 *
 * [1] this looks like big-endian, but applies equally to little-endian.
 *
 * s = Sign bit.  Yes, zeros and nans can have negative sign,
 *     the interpretation is application-specific.
 *
 * q = Quietness bit, the interpretation is platform-specific.
 *     Most platforms have the most significant bit being one
 *     meaning quiet, but some (older mips, hppa) have the msb
 *     being one meaning signaling.  Note that the above means
 *     that on most platforms there cannot be signaling nan with
 *     zero payload because that is identical with infinity;
 *     while conversely on older mips/hppa there cannot be a quiet nan
 *     because that is identical with infinity.
 *
 *     Moreover, whether there is any behavioral difference
 *     between quiet and signaling NaNs, depends on the platform.
 *
 * x86 80-bit extended precision is different, the mantissa bits:
 *
 * 63 62 61   30387+    pre-387    visual c
 * --------   ----      --------   --------
 *  0  0  0   invalid   infinity
 *  0  0  1   invalid   snan
 *  0  1  0   invalid   snan
 *  0  1  1   invalid   snan
 *  1  0  0   infinity  snan        1.#INF
 *  1  0  1   snan                  1.#SNAN
 *  1  1  0   qnan                 -1.#IND  (x86 chooses this to negative)
 *  1  1  1   qnan                  1.#QNAN
 *
 * This means that in this format there are 61 bits available
 * for the nan payload.
 *
 * Note that the 32-bit x86 ABI cannot do signaling nans: the x87
 * simply cannot preserve the bit.  You can either use the 80-bit
 * extended precision (long double, -Duselongdouble), or use x86-64.
 *
 * In all platforms, the payload bytes (and bits, some of them are
 * often in a partial byte) themselves can be either all zero (x86),
 * all one (sparc or mips), or a mixture: in IEEE 754 128-bit double
 * or in a double-double, the first half of the payload can follow the
 * native double, while in the second half the payload can be all
 * zeros.  (Therefore the mask for payload bits is not necessarily
 * identical to bit complement of the NaN.)  Another way of putting
 * this: the payload for the default NaN might not be zero.
 *
 * For the x86 80-bit long doubles, the trailing bytes (the 80 bits
 * being 'packaged' in either 12 or 16 bytes) can be whatever random
 * garbage.
 *
 * Furthermore, the semantics of the sign bit on NaNs are platform-specific.
 * On normal floats, the sign bit being on means negative.  But this may,
 * or may not, be reverted on NaNs: in other words, the default NaN might
 * have the sign bit on, and therefore look like negative if you look
 * at it at the bit level.
 *
 * NaN payloads are not propagated even on copies, or in arithmetics.
 * They *might* be, according to some rules, on your particular
 * cpu/os/compiler/libraries, but no guarantees.
 *
 * To summarize, on most platforms, and for 64-bit doubles
 * (using big-endian ordering here):
 *
 * [7FF8000000000000..7FFFFFFFFFFFFFFF] quiet
 * [FFF8000000000000..FFFFFFFFFFFFFFFF] quiet
 * [7FF0000000000001..7FF7FFFFFFFFFFFF] signaling
 * [FFF0000000000001..FFF7FFFFFFFFFFFF] signaling
 *
 * The C99 nan() is supposed to generate *quiet* NaNs.
 *
 * Note the asymmetry:
 * The 7FF0000000000000 is positive infinity,
 * the FFF0000000000000 is negative infinity.
 */

/* NVMANTBITS is the number of _real_ mantissa bits in an NV.
 * For the standard IEEE 754 fp this number is usually one less that
 * *DBL_MANT_DIG because of the implicit (aka hidden) bit, which isn't
 * real.  For the 80-bit extended precision formats (x86*), the number
 * of mantissa bits... depends. For normal floats, it's 64.  But for
 * the inf/nan, it's different (zero for inf, 61 for nan).
 * NVMANTBITS works for normal floats. */

/* We do not want to include the quiet/signaling bit. */
#define NV_NAN_BITS (NVMANTBITS - 1)

#if defined(USE_LONG_DOUBLE) && NVSIZE > DOUBLESIZE
#  if LONG_DOUBLEKIND == LONG_DOUBLE_IS_IEEE_754_128_BIT_LITTLE_ENDIAN
#    define NV_NAN_QS_BYTE_OFFSET 13
#  elif LONG_DOUBLEKIND == LONG_DOUBLE_IS_IEEE_754_128_BIT_BIG_ENDIAN
#    define NV_NAN_QS_BYTE_OFFSET 2
#  elif LONG_DOUBLEKIND == LONG_DOUBLE_IS_X86_80_BIT_LITTLE_ENDIAN
#    define NV_NAN_QS_BYTE_OFFSET 7
#  elif LONG_DOUBLEKIND == LONG_DOUBLE_IS_X86_80_BIT_BIG_ENDIAN
#    define NV_NAN_QS_BYTE_OFFSET 2
#  elif LONG_DOUBLEKIND == LONG_DOUBLE_IS_DOUBLEDOUBLE_128_BIT_LE_LE
#    define NV_NAN_QS_BYTE_OFFSET 13
#  elif LONG_DOUBLEKIND == LONG_DOUBLE_IS_DOUBLEDOUBLE_128_BIT_BE_BE
#    define NV_NAN_QS_BYTE_OFFSET 1
#  elif LONG_DOUBLEKIND == LONG_DOUBLE_IS_DOUBLEDOUBLE_128_BIT_LE_BE
#    define NV_NAN_QS_BYTE_OFFSET 9
#  elif LONG_DOUBLEKIND == LONG_DOUBLE_IS_DOUBLEDOUBLE_128_BIT_BE_LE
#    define NV_NAN_QS_BYTE_OFFSET 6
#  else
#    error "Unexpected long double format"
#  endif
#else
#  ifdef USE_QUADMATH
#    ifdef NV_LITTLE_ENDIAN
#      define NV_NAN_QS_BYTE_OFFSET 13
#    elif defined(NV_BIG_ENDIAN)
#      define NV_NAN_QS_BYTE_OFFSET 2
#    else
#      error "Unexpected quadmath format"
#    endif
#  elif DOUBLEKIND == DOUBLE_IS_IEEE_754_32_BIT_LITTLE_ENDIAN
#    define NV_NAN_QS_BYTE_OFFSET 2
#  elif DOUBLEKIND == DOUBLE_IS_IEEE_754_32_BIT_BIG_ENDIAN
#    define NV_NAN_QS_BYTE_OFFSET 1
#  elif DOUBLEKIND == DOUBLE_IS_IEEE_754_64_BIT_LITTLE_ENDIAN
#    define NV_NAN_QS_BYTE_OFFSET 6
#  elif DOUBLEKIND == DOUBLE_IS_IEEE_754_64_BIT_BIG_ENDIAN
#    define NV_NAN_QS_BYTE_OFFSET 1
#  elif DOUBLEKIND == DOUBLE_IS_IEEE_754_128_BIT_LITTLE_ENDIAN
#    define NV_NAN_QS_BYTE_OFFSET 13
#  elif DOUBLEKIND == DOUBLE_IS_IEEE_754_128_BIT_BIG_ENDIAN
#    define NV_NAN_QS_BYTE_OFFSET 2
#  elif DOUBLEKIND == DOUBLE_IS_IEEE_754_64_BIT_MIXED_ENDIAN_LE_BE
#    define NV_NAN_QS_BYTE_OFFSET 2 /* bytes 4 5 6 7 0 1 2 3 (MSB 7) */
#  elif DOUBLEKIND == DOUBLE_IS_IEEE_754_64_BIT_MIXED_ENDIAN_BE_LE
#    define NV_NAN_QS_BYTE_OFFSET 5 /* bytes 3 2 1 0 7 6 5 4 (MSB 7) */
#  else
#    error "Unexpected double format"
#  endif
#endif
/* NV_NAN_QS_BYTE is the byte to test for the quiet/signaling */
#define NV_NAN_QS_BYTE(nvp) (((U8*)(nvp))[NV_NAN_QS_BYTE_OFFSET])
/* NV_NAN_QS_BIT is the bit to test in the NV_NAN_QS_BYTE_OFFSET
 * for the quiet/signaling */
#if defined(USE_LONG_DOUBLE) && \
  (LONG_DOUBLEKIND == LONG_DOUBLE_IS_X86_80_BIT_LITTLE_ENDIAN || \
   LONG_DOUBLEKIND == LONG_DOUBLE_IS_X86_80_BIT_BIG_ENDIAN)
#  define NV_NAN_QS_BIT_SHIFT 6 /* 0x40 */
#elif defined(USE_LONG_DOUBLE) && \
  (LONG_DOUBLEKIND == LONG_DOUBLE_IS_DOUBLEDOUBLE_128_BIT_LE_LE || \
   LONG_DOUBLEKIND == LONG_DOUBLE_IS_DOUBLEDOUBLE_128_BIT_BE_BE || \
   LONG_DOUBLEKIND == LONG_DOUBLE_IS_DOUBLEDOUBLE_128_BIT_LE_BE || \
   LONG_DOUBLEKIND == LONG_DOUBLE_IS_DOUBLEDOUBLE_128_BIT_BE_LE)
#  define NV_NAN_QS_BIT_SHIFT 3 /* 0x08, but not via NV_NAN_BITS */
#else
#  define NV_NAN_QS_BIT_SHIFT ((NV_NAN_BITS) % 8) /* usually 3, or 0x08 */
#endif
#define NV_NAN_QS_BIT (1 << (NV_NAN_QS_BIT_SHIFT))
/* NV_NAN_QS_BIT_OFFSET is the bit offset from the beginning of a NV
 * (bytes ordered big-endianly) for the quiet/signaling bit
 * for the quiet/signaling */
#define NV_NAN_QS_BIT_OFFSET \
    (8 * (NV_NAN_QS_BYTE_OFFSET) + (NV_NAN_QS_BIT_SHIFT))
/* NV_NAN_QS_QUIET (always defined) is true if the NV_NAN_QS_QS_BIT being
 * on indicates quiet NaN.  NV_NAN_QS_SIGNALING (also always defined)
 * is true if the NV_NAN_QS_BIT being on indicates signaling NaN. */
#define NV_NAN_QS_QUIET \
    ((NV_NAN_QS_BYTE(PL_nan.u8) & NV_NAN_QS_BIT) == NV_NAN_QS_BIT)
#define NV_NAN_QS_SIGNALING (!(NV_NAN_QS_QUIET))
#define NV_NAN_QS_TEST(nvp) (NV_NAN_QS_BYTE(nvp) & NV_NAN_QS_BIT)
/* NV_NAN_IS_QUIET() returns true if the NV behind nvp is a NaN,
 * whether it is a quiet NaN, NV_NAN_IS_SIGNALING() if a signaling NaN.
 * Note however that these do not check whether the nvp is a NaN. */
#define NV_NAN_IS_QUIET(nvp) \
    (NV_NAN_QS_TEST(nvp) == (NV_NAN_QS_QUIET ? NV_NAN_QS_BIT : 0))
#define NV_NAN_IS_SIGNALING(nvp) \
    (NV_NAN_QS_TEST(nvp) == (NV_NAN_QS_QUIET ? 0 : NV_NAN_QS_BIT))
#define NV_NAN_SET_QUIET(nvp) \
    (NV_NAN_QS_QUIET ? \
     (NV_NAN_QS_BYTE(nvp) |= NV_NAN_QS_BIT) : \
     (NV_NAN_QS_BYTE(nvp) &= ~NV_NAN_QS_BIT))
#define NV_NAN_SET_SIGNALING(nvp) \
    (NV_NAN_QS_QUIET ? \
     (NV_NAN_QS_BYTE(nvp) &= ~NV_NAN_QS_BIT) : \
     (NV_NAN_QS_BYTE(nvp) |= NV_NAN_QS_BIT))
#define NV_NAN_QS_XOR(nvp) (NV_NAN_QS_BYTE(nvp) ^= NV_NAN_QS_BIT)

/* NV_NAN_PAYLOAD_MASK: masking the nan payload bits.
 *
 * NV_NAN_PAYLOAD_PERM: permuting the nan payload bytes.
 * 0xFF means "don't go here".*/

/* Shorthands to avoid typoses. */
#define NV_NAN_PAYLOAD_MASK_SKIP_EIGHT \
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
#define NV_NAN_PAYLOAD_PERM_SKIP_EIGHT \
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
#define NV_NAN_PAYLOAD_PERM_0_TO_7 \
  0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7
#define NV_NAN_PAYLOAD_PERM_7_TO_0 \
  0x7, 0x6, 0x5, 0x4, 0x3, 0x2, 0x1, 0x0
#define NV_NAN_PAYLOAD_MASK_IEEE_754_128_LE \
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, \
  0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x00, 0x00
#define NV_NAN_PAYLOAD_PERM_IEEE_754_128_LE \
  NV_NAN_PAYLOAD_PERM_0_TO_7, \
  0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xFF, 0xFF
#define NV_NAN_PAYLOAD_MASK_IEEE_754_128_BE \
  0x00, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, \
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
#define NV_NAN_PAYLOAD_PERM_IEEE_754_128_BE \
  0xFF, 0xFF, 0xd, 0xc, 0xb, 0xa, 0x9, 0x8, \
  NV_NAN_PAYLOAD_PERM_7_TO_0
#define NV_NAN_PAYLOAD_MASK_IEEE_754_64_LE \
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x07, 0x00
#define NV_NAN_PAYLOAD_PERM_IEEE_754_64_LE \
  0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0xFF
#define NV_NAN_PAYLOAD_MASK_IEEE_754_64_BE \
  0x00, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
#define NV_NAN_PAYLOAD_PERM_IEEE_754_64_BE \
  0xFF, 0x6, 0x5, 0x4, 0x3, 0x2, 0x1, 0x0

#if defined(USE_LONG_DOUBLE) && NVSIZE > DOUBLESIZE
#  if LONG_DOUBLEKIND == LONG_DOUBLE_IS_IEEE_754_128_BIT_LITTLE_ENDIAN
#    define NV_NAN_PAYLOAD_MASK NV_NAN_PAYLOAD_MASK_IEEE_754_128_LE
#    define NV_NAN_PAYLOAD_PERM NV_NAN_PAYLOAD_PERM_IEEE_754_128_LE
#  elif LONG_DOUBLEKIND == LONG_DOUBLE_IS_IEEE_754_128_BIT_BIG_ENDIAN
#    define NV_NAN_PAYLOAD_MASK NV_NAN_PAYLOAD_MASK_IEEE_754_128_BE
#    define NV_NAN_PAYLOAD_PERM NV_NAN_PAYLOAD_PERM_IEEE_754_128_BE
#  elif LONG_DOUBLEKIND == LONG_DOUBLE_IS_X86_80_BIT_LITTLE_ENDIAN
#    if LONG_DOUBLESIZE == 10
#      define NV_NAN_PAYLOAD_MASK \
         0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, \
         0x00, 0x00
#      define NV_NAN_PAYLOAD_PERM \
         NV_NAN_PAYLOAD_PERM_0_TO_7, 0xFF, 0xFF
#    elif LONG_DOUBLESIZE == 12
#      define NV_NAN_PAYLOAD_MASK \
         0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, \
         0x00, 0x00, 0x00, 0x00
#      define NV_NAN_PAYLOAD_PERM \
         NV_NAN_PAYLOAD_PERM_0_TO_7, 0xFF, 0xFF, 0xFF, 0xFF
#    elif LONG_DOUBLESIZE == 16
#      define NV_NAN_PAYLOAD_MASK \
         0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, \
         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
#      define NV_NAN_PAYLOAD_PERM \
         NV_NAN_PAYLOAD_PERM_0_TO_7, \
         0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
#    else
#      error "Unexpected x86 80-bit little-endian long double format"
#    endif
#  elif LONG_DOUBLEKIND == LONG_DOUBLE_IS_X86_80_BIT_BIG_ENDIAN
#    if LONG_DOUBLESIZE == 10
#      define NV_NAN_PAYLOAD_MASK \
         0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, \
         0xff, 0xff
#      define NV_NAN_PAYLOAD_PERM \
         NV_NAN_PAYLOAD_PERM_7_TO_0, 0xFF, 0xFF
#    elif LONG_DOUBLESIZE == 12
#      define NV_NAN_PAYLOAD_MASK \
         0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, \
         0xff, 0xff, 0x00, 0x00
#      define NV_NAN_PAYLOAD_PERM \
         NV_NAN_PAYLOAD_PERM_7_TO_0, 0xFF, 0xFF, 0xFF, 0xFF
#    elif LONG_DOUBLESIZE == 16
#      define NV_NAN_PAYLOAD_MASK \
         0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, \
         0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
#      define NV_NAN_PAYLOAD_PERM \
         NV_NAN_PAYLOAD_PERM_7_TO_0, \
         0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
#    else
#      error "Unexpected x86 80-bit big-endian long double format"
#    endif
#  elif LONG_DOUBLEKIND == LONG_DOUBLE_IS_DOUBLEDOUBLE_128_BIT_LE_LE
/* For double-double we assume only the first double (in LE or BE terms)
 * is used for NaN. */
#    define NV_NAN_PAYLOAD_MASK \
       NV_NAN_PAYLOAD_MASK_SKIP_EIGHT, NV_NAN_PAYLOAD_MASK_IEEE_754_64_LE
#    define NV_NAN_PAYLOAD_PERM \
       NV_NAN_PAYLOAD_PERM_SKIP_EIGHT, NV_NAN_PAYLOAD_PERM_IEEE_754_64_LE
#  elif LONG_DOUBLEKIND == LONG_DOUBLE_IS_DOUBLEDOUBLE_128_BIT_BE_BE
#    define NV_NAN_PAYLOAD_MASK \
       NV_NAN_PAYLOAD_MASK_IEEE_754_64_BE
#    define NV_NAN_PAYLOAD_PERM \
       NV_NAN_PAYLOAD_PERM_IEEE_754_64_BE
#  elif LONG_DOUBLEKIND == LONG_DOUBLE_IS_DOUBLEDOUBLE_128_BIT_LE_BE
#    define NV_NAN_PAYLOAD_MASK \
       NV_NAN_PAYLOAD_MASK_IEEE_754_64_LE
#    define NV_NAN_PAYLOAD_PERM \
       NV_NAN_PAYLOAD_PERM_IEEE_754_64_LE
#  elif LONG_DOUBLEKIND == LONG_DOUBLE_IS_DOUBLEDOUBLE_128_BIT_BE_LE
#    define NV_NAN_PAYLOAD_MASK \
       NV_NAN_PAYLOAD_MASK_SKIP_EIGHT, NV_NAN_PAYLOAD_MASK_IEEE_754_64_BE
#    define NV_NAN_PAYLOAD_PERM \
       NV_NAN_PAYLOAD_PERM_SKIP_EIGHT, NV_NAN_PAYLOAD_PERM_IEEE_754_64_BE
#  else
#    error "Unexpected long double format"
#  endif
#else
#  ifdef USE_QUADMATH /* quadmath is not long double */
#    ifdef NV_LITTLE_ENDIAN
#      define NV_NAN_PAYLOAD_MASK NV_NAN_PAYLOAD_MASK_IEEE_754_128_LE
#      define NV_NAN_PAYLOAD_PERM NV_NAN_PAYLOAD_PERM_IEEE_754_128_LE
#    elif defined(NV_BIG_ENDIAN)
#      define NV_NAN_PAYLOAD_MASK NV_NAN_PAYLOAD_MASK_IEEE_754_128_BE
#      define NV_NAN_PAYLOAD_PERM NV_NAN_PAYLOAD_PERM_IEEE_754_128_BE
#    else
#      error "Unexpected quadmath format"
#    endif
#  elif DOUBLEKIND == DOUBLE_IS_IEEE_754_32_BIT_LITTLE_ENDIAN
#    define NV_NAN_PAYLOAD_MASK 0xff, 0xff, 0x07, 0x00
#    define NV_NAN_PAYLOAD_PERM 0x0, 0x1, 0x2, 0xFF
#  elif DOUBLEKIND == DOUBLE_IS_IEEE_754_32_BIT_BIG_ENDIAN
#    define NV_NAN_PAYLOAD_MASK 0x00, 0x07, 0xff, 0xff
#    define NV_NAN_PAYLOAD_PERM 0xFF, 0x2, 0x1, 0x0
#  elif DOUBLEKIND == DOUBLE_IS_IEEE_754_64_BIT_LITTLE_ENDIAN
#    define NV_NAN_PAYLOAD_MASK NV_NAN_PAYLOAD_MASK_IEEE_754_64_LE
#    define NV_NAN_PAYLOAD_PERM NV_NAN_PAYLOAD_PERM_IEEE_754_64_LE
#  elif DOUBLEKIND == DOUBLE_IS_IEEE_754_64_BIT_BIG_ENDIAN
#    define NV_NAN_PAYLOAD_MASK NV_NAN_PAYLOAD_MASK_IEEE_754_64_BE
#    define NV_NAN_PAYLOAD_PERM NV_NAN_PAYLOAD_PERM_IEEE_754_64_BE
#  elif DOUBLEKIND == DOUBLE_IS_IEEE_754_128_BIT_LITTLE_ENDIAN
#    define NV_NAN_PAYLOAD_MASK NV_NAN_PAYLOAD_MASK_IEEE_754_128_LE
#    define NV_NAN_PAYLOAD_PERM NV_NAN_PAYLOAD_PERM_IEEE_754_128_LE
#  elif DOUBLEKIND == DOUBLE_IS_IEEE_754_128_BIT_BIG_ENDIAN
#    define NV_NAN_PAYLOAD_MASK NV_NAN_PAYLOAD_MASK_IEEE_754_128_BE
#    define NV_NAN_PAYLOAD_PERM NV_NAN_PAYLOAD_PERM_IEEE_754_128_BE
#  elif DOUBLEKIND == DOUBLE_IS_IEEE_754_64_BIT_MIXED_ENDIAN_LE_BE
#    define NV_NAN_PAYLOAD_MASK 0xff, 0xff, 0x07, 0x00, 0xff, 0xff, 0xff, 0xff
#    define NV_NAN_PAYLOAD_PERM 0x4, 0x5, 0x6, 0xFF, 0x0, 0x1, 0x2, 0x3
#  elif DOUBLEKIND == DOUBLE_IS_IEEE_754_64_BIT_MIXED_ENDIAN_BE_LE
#    define NV_NAN_PAYLOAD_MASK 0xff, 0xff, 0xff, 0xff, 0x00, 0x07, 0xff, 0xff
#    define NV_NAN_PAYLOAD_PERM 0x3, 0x2, 0x1, 0x0, 0xFF, 0x6, 0x5, 0x4
#  else
#    error "Unexpected double format"
#  endif
#endif
/*

   (KEEP THIS LAST IN perl.h!)

   Mention

   NV_PRESERVES_UV

   HAS_MKSTEMP
   HAS_MKSTEMPS
   HAS_MKDTEMP

   HAS_GETCWD

   HAS_MMAP
   HAS_MPROTECT
   HAS_MSYNC
   HAS_MADVISE
   HAS_MUNMAP
   I_SYSMMAN
   Mmap_t

   NVef
   NVff
   NVgf

   HAS_UALARM
   HAS_USLEEP

   HAS_SETITIMER
   HAS_GETITIMER

   HAS_SENDMSG
   HAS_RECVMSG
   HAS_READV
   HAS_WRITEV
   I_SYSUIO
   HAS_STRUCT_MSGHDR
   HAS_STRUCT_CMSGHDR

   HAS_NL_LANGINFO

   HAS_DIRFD

   so that Configure picks them up.

   (KEEP THIS LAST IN perl.h!)

*/

#endif /* Include guard */

/*
 * ex: set ts=8 sts=4 sw=4 et:
 */
@


1.20
log
@Fix merge issues, remove excess files - match perl-5.20.2 dist
@
text
@d31 11
a142 3
#      ifndef PERLIO_FUNCS_CONST
#        define PERLIO_FUNCS_CONST /* Can't have these lying around. */
#      endif
d149 3
d234 1
a234 1
    if(prog) RX_ENGINE(prog)->free(aTHX_ (prog))
d312 1
a312 1
#  if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
d321 2
a322 1
 * but we cannot quite get rid of, such as "ax" in PPCODE+noargs xsubs
d329 1
a329 1
#    define PERL_UNUSED_ARG(x) ((void)x)
d333 1
a333 1
#  define PERL_UNUSED_VAR(x) ((void)x)
d336 1
a336 1
#ifdef USE_ITHREADS
d399 12
d413 1
a413 1
#if defined(__clang) || \
d415 2
a416 2
#  define GCC_DIAG_DO_PRAGMA_(x) _Pragma (#x)

d418 1
a418 1
                             GCC_DIAG_DO_PRAGMA_(GCC diagnostic ignored #x)
d424 10
a433 1

a508 20
/* Some platforms require marking function declarations
 * for them to be exportable.  Used in perlio.h, proto.h
 * is handled either by the makedef.pl or by defining the
 * PERL_CALLCONV to be something special.  See also the
 * definition of XS() in XSUB.h. */
#ifndef PERL_EXPORT_C
#  ifdef __cplusplus
#    define PERL_EXPORT_C extern "C"
#  else
#    define PERL_EXPORT_C extern
#  endif
#endif
#ifndef PERL_XS_EXPORT_C
#  ifdef __cplusplus
#    define PERL_XS_EXPORT_C extern "C"
#  else
#    define PERL_XS_EXPORT_C
#  endif
#endif

d610 1
a610 1
#   define TAINT		(PL_tainted = TRUE)
d612 1
a612 1
#   define TAINT_IF(c)	if (UNLIKELY(c)) { PL_tainted = TRUE; }
d714 3
a716 11
#ifdef USE_NEXT_CTYPE

#if NX_CURRENT_COMPILER_RELEASE >= 500
#  include <bsd/ctypes.h>
#else
#  if NX_CURRENT_COMPILER_RELEASE >= 400
#    include <objc/NXCType.h>
#  else /*  NX_CURRENT_COMPILER_RELEASE < 400 */
#    include <appkit/NXCType.h>
#  endif /*  NX_CURRENT_COMPILER_RELEASE >= 400 */
#endif /*  NX_CURRENT_COMPILER_RELEASE >= 500 */
a717 1
#else /* !USE_NEXT_CTYPE */
a718 1
#endif /* USE_NEXT_CTYPE */
d752 3
d760 4
d790 5
d796 9
d922 1
a922 1
#if defined(STANDARD_C) && defined(I_STDDEF)
d929 5
d971 1
a971 1
		  panic_write2("panic: tainting with $ENV{PERL_MALLOC_OPT}\n");\
d1010 1
a1010 5
#	ifdef HAS_BCOPY
#	    define memcpy(d,s,l) bcopy(s,d,l)
#	else
#	    define memcpy(d,s,l) my_bcopy(s,d,l)
#	endif
d1026 2
a1027 2
#   if defined(HAS_BCOPY) && defined(HAS_SAFE_BCOPY)
#	define memmove(d,s,l) bcopy(s,d,l)
d1029 1
a1029 5
#	if defined(HAS_MEMCPY) && defined(HAS_SAFE_MEMCPY)
#	    define memmove(d,s,l) memcpy(d,s,l)
#	else
#	    define memmove(d,s,l) my_bcopy(s,d,l)
#	endif
d1224 2
d1239 2
d1270 1
d1272 7
a1278 5
    if (!GvSV(PL_errgv)) {						\
	sv_setpvs(GvSV(gv_add_by_type(PL_errgv, SVt_PV)), "");		\
    } else if (SvREADONLY(GvSV(PL_errgv))) {				\
	SvREFCNT_dec(GvSV(PL_errgv));					\
	GvSV(PL_errgv) = newSVpvs("");					\
d1280 1
a1280 1
	SV *const errsv = GvSV(PL_errgv);				\
d1282 1
a1285 1
	SvPOK_only(errsv);						\
a1370 4
    /* NeXT needs dirent + sys/dir.h */
#   if  defined(I_SYS_DIR) && (defined(NeXT) || defined(__NeXT__))
#	include <sys/dir.h>
#   endif
d1569 6
d1577 1
a1577 1
#      define my_snprintf(buffer, len, ...) ({ int __len__ = snprintf(buffer, len, __VA_ARGS__); if ((len) > 0 && (Size_t)__len__ >= (len)) Perl_croak_nocontext("panic: snprintf buffer overflow"); __len__; })
d1580 1
a1580 1
#    define my_snprintf(buffer, len, ...) snprintf(buffer, len, __VA_ARGS__)
d1586 1
d1588 2
d1592 1
a1592 1
#      define my_vsnprintf(buffer, len, ...) ({ int __len__ = vsnprintf(buffer, len, __VA_ARGS__); if ((len) > 0 && (Size_t)__len__ >= (Size_t)(len)) Perl_croak_nocontext("panic: vsnprintf buffer overflow"); __len__; })
d1595 1
a1595 1
#    define my_vsnprintf(buffer, len, ...) vsnprintf(buffer, len, __VA_ARGS__)
d1602 31
d1709 2
a1710 1
#define SSize_t_MAX (SSize_t)(~(size_t)0 >> 1)
d1769 3
a1771 5
#  if defined(HAS_LONG_DOUBLE) && LONG_DOUBLESIZE == DOUBLESIZE
#      define LONG_DOUBLE_EQUALS_DOUBLE
#  endif
#  if !(defined(HAS_LONG_DOUBLE) && (LONG_DOUBLESIZE > DOUBLESIZE))
#     undef USE_LONG_DOUBLE /* Ouch! */
d1873 3
d1881 28
a1908 21
#   define NV_DIG LDBL_DIG
#   ifdef LDBL_MANT_DIG
#       define NV_MANT_DIG LDBL_MANT_DIG
#   endif
#   ifdef LDBL_MIN
#       define NV_MIN LDBL_MIN
#   endif
#   ifdef LDBL_MAX
#       define NV_MAX LDBL_MAX
#   endif
#   ifdef LDBL_MIN_10_EXP
#       define NV_MIN_10_EXP LDBL_MIN_10_EXP
#   endif
#   ifdef LDBL_MAX_10_EXP
#       define NV_MAX_10_EXP LDBL_MAX_10_EXP
#   endif
#   ifdef LDBL_EPSILON
#       define NV_EPSILON LDBL_EPSILON
#   endif
#   ifdef LDBL_MAX
#       define NV_MAX LDBL_MAX
a1909 3
#   else
#       ifdef HUGE_VALL
#           define NV_MAX HUGE_VALL
d1911 2
a1912 2
#           ifdef HUGE_VAL
#               define NV_MAX ((NV)HUGE_VAL)
d1916 6
a1921 1
#   ifdef HAS_SQRTL
d1923 1
a1923 2
#       define Perl_sin sinl
#       define Perl_sqrt sqrtl
d1925 3
d1929 1
a1929 1
#       define Perl_atan2 atan2l
d1931 5
a1935 3
#       define Perl_floor floorl
#       define Perl_ceil ceill
#       define Perl_fmod fmodl
d1938 3
a1940 2
#   ifdef HAS_MODFL
#       define Perl_modf(x,y) modfl(x,y)
d1943 1
a1943 1
#       ifndef HAS_MODFL_PROTO
d1945 2
a1946 3
#	endif
#   else
#       if defined(HAS_AINTL) && defined(HAS_COPYSIGNL)
d1951 17
a1967 6
#   ifdef HAS_FREXPL
#       define Perl_frexp(x,y) frexpl(x,y)
#   else
#       if defined(HAS_ILOGBL) && defined(HAS_SCALBNL)
        extern long double Perl_my_frexpl(long double x, int *e);
#           define Perl_frexp(x,y) Perl_my_frexpl(x,y)
d1971 1
a1971 1
#       ifdef HAS_ISNANL
d1973 2
d1978 6
a1983 2
#       ifdef HAS_FINITEL
#           define Perl_isinf(x) !(finitel(x)||Perl_isnan(x))
d1986 39
d2036 6
d2059 7
d2067 1
a2067 2
#   define Perl_sin sin
#   define Perl_sqrt sqrt
d2069 3
d2073 1
a2073 1
#   define Perl_atan2 atan2
d2075 6
a2080 3
#   define Perl_floor floor
#   define Perl_ceil ceil
#   define Perl_fmod fmod
d2083 51
d2136 22
a2157 1
/* rumor has it that Win32 has _fpclass() */
d2159 4
a2162 6
/* SGI has fpclassl... but not with the same result values,
 * and it's via a typedef (not via #define), so will need to redo Configure
 * to use. Not worth the trouble, IMO, at least until the below is used
 * more places. Also has fp_class_l, BTW, via fp_class.h. Feel free to check
 * with me for the SGI manpages, SGI testing, etcetera, if you want to
 * try getting this to work with IRIX. - Allen <allens@@cpan.org> */
d2164 1
d2166 8
d2181 1
a2181 1
#        define Perl_fp_class()		fpclassl(x)
d2183 26
a2208 1
#        define Perl_fp_class()		fpclass(x)
a2209 15
#    define Perl_fp_class_snan(x)	(Perl_fp_class(x)==FP_CLASS_SNAN)
#    define Perl_fp_class_qnan(x)	(Perl_fp_class(x)==FP_CLASS_QNAN)
#    define Perl_fp_class_nan(x)	(Perl_fp_class(x)==FP_CLASS_SNAN||Perl_fp_class(x)==FP_CLASS_QNAN)
#    define Perl_fp_class_ninf(x)	(Perl_fp_class(x)==FP_CLASS_NINF)
#    define Perl_fp_class_pinf(x)	(Perl_fp_class(x)==FP_CLASS_PINF)
#    define Perl_fp_class_inf(x)	(Perl_fp_class(x)==FP_CLASS_NINF||Perl_fp_class(x)==FP_CLASS_PINF)
#    define Perl_fp_class_nnorm(x)	(Perl_fp_class(x)==FP_CLASS_NNORM)
#    define Perl_fp_class_pnorm(x)	(Perl_fp_class(x)==FP_CLASS_PNORM)
#    define Perl_fp_class_norm(x)	(Perl_fp_class(x)==FP_CLASS_NNORM||Perl_fp_class(x)==FP_CLASS_PNORM)
#    define Perl_fp_class_ndenorm(x)	(Perl_fp_class(x)==FP_CLASS_NDENORM)
#    define Perl_fp_class_pdenorm(x)	(Perl_fp_class(x)==FP_CLASS_PDENORM)
#    define Perl_fp_class_denorm(x)	(Perl_fp_class(x)==FP_CLASS_NDENORM||Perl_fp_class(x)==FP_CLASS_PDENORM)
#    define Perl_fp_class_nzero(x)	(Perl_fp_class(x)==FP_CLASS_NZERO)
#    define Perl_fp_class_pzero(x)	(Perl_fp_class(x)==FP_CLASS_PZERO)
#    define Perl_fp_class_zero(x)	(Perl_fp_class(x)==FP_CLASS_NZERO||Perl_fp_class(x)==FP_CLASS_PZERO)
d2212 2
a2213 1
#if !defined(Perl_fp_class) && defined(HAS_FP_CLASS)
d2218 29
a2246 26
#    define Perl_fp_class(x)		fp_class(x)
#    define Perl_fp_class_snan(x)	(fp_class(x)==FP_SNAN)
#    define Perl_fp_class_qnan(x)	(fp_class(x)==FP_QNAN)
#    define Perl_fp_class_nan(x)	(fp_class(x)==FP_SNAN||fp_class(x)==FP_QNAN)
#    define Perl_fp_class_ninf(x)	(fp_class(x)==FP_NEG_INF)
#    define Perl_fp_class_pinf(x)	(fp_class(x)==FP_POS_INF)
#    define Perl_fp_class_inf(x)	(fp_class(x)==FP_NEG_INF||fp_class(x)==FP_POS_INF)
#    define Perl_fp_class_nnorm(x)	(fp_class(x)==FP_NEG_NORM)
#    define Perl_fp_class_pnorm(x)	(fp_class(x)==FP_POS_NORM)
#    define Perl_fp_class_norm(x)	(fp_class(x)==FP_NEG_NORM||fp_class(x)==FP_POS_NORM)
#    define Perl_fp_class_ndenorm(x)	(fp_class(x)==FP_NEG_DENORM)
#    define Perl_fp_class_pdenorm(x)	(fp_class(x)==FP_POS_DENORM)
#    define Perl_fp_class_denorm(x)	(fp_class(x)==FP_NEG_DENORM||fp_class(x)==FP_POS_DENORM)
#    define Perl_fp_class_nzero(x)	(fp_class(x)==FP_NEG_ZERO)
#    define Perl_fp_class_pzero(x)	(fp_class(x)==FP_POS_ZERO)
#    define Perl_fp_class_zero(x)	(fp_class(x)==FP_NEG_ZERO||fp_class(x)==FP_POS_ZERO)
#endif

#if !defined(Perl_fp_class) && defined(HAS_FPCLASSIFY)
#    include <math.h>
#    define Perl_fp_class(x)		fpclassify(x)
#    define Perl_fp_class_nan(x)	(fp_classify(x)==FP_SNAN||fp_classify(x)==FP_QNAN)
#    define Perl_fp_class_inf(x)	(fp_classify(x)==FP_INFINITE)
#    define Perl_fp_class_norm(x)	(fp_classify(x)==FP_NORMAL)
#    define Perl_fp_class_denorm(x)	(fp_classify(x)==FP_SUBNORMAL)
#    define Perl_fp_class_zero(x)	(fp_classify(x)==FP_ZERO)
d2249 1
d2252 20
a2271 4
#    ifndef _cplusplus
#        define Perl_fp_class(x)	class(x)
#    else
#        define Perl_fp_class(x)	_class(x)
a2272 15
#    define Perl_fp_class_snan(x)	(Perl_fp_class(x)==FP_NANS)
#    define Perl_fp_class_qnan(x)	(Perl_fp_class(x)==FP_NANQ)
#    define Perl_fp_class_nan(x)	(Perl_fp_class(x)==FP_SNAN||Perl_fp_class(x)==FP_QNAN)
#    define Perl_fp_class_ninf(x)	(Perl_fp_class(x)==FP_MINUS_INF)
#    define Perl_fp_class_pinf(x)	(Perl_fp_class(x)==FP_PLUS_INF)
#    define Perl_fp_class_inf(x)	(Perl_fp_class(x)==FP_MINUS_INF||Perl_fp_class(x)==FP_PLUS_INF)
#    define Perl_fp_class_nnorm(x)	(Perl_fp_class(x)==FP_MINUS_NORM)
#    define Perl_fp_class_pnorm(x)	(Perl_fp_class(x)==FP_PLUS_NORM)
#    define Perl_fp_class_norm(x)	(Perl_fp_class(x)==FP_MINUS_NORM||Perl_fp_class(x)==FP_PLUS_NORM)
#    define Perl_fp_class_ndenorm(x)	(Perl_fp_class(x)==FP_MINUS_DENORM)
#    define Perl_fp_class_pdenorm(x)	(Perl_fp_class(x)==FP_PLUS_DENORM)
#    define Perl_fp_class_denorm(x)	(Perl_fp_class(x)==FP_MINUS_DENORM||Perl_fp_class(x)==FP_PLUS_DENORM)
#    define Perl_fp_class_nzero(x)	(Perl_fp_class(x)==FP_MINUS_ZERO)
#    define Perl_fp_class_pzero(x)	(Perl_fp_class(x)==FP_PLUS_ZERO)
#    define Perl_fp_class_zero(x)	(Perl_fp_class(x)==FP_MINUS_ZERO||Perl_fp_class(x)==FP_PLUS_ZERO)
d2275 28
a2302 1
/* rumor has it that Win32 has _isnan() */
d2304 28
a2331 14
#ifndef Perl_isnan
#   ifdef HAS_ISNAN
#       define Perl_isnan(x) isnan((NV)x)
#   else
#       ifdef Perl_fp_class_nan
#           define Perl_isnan(x) Perl_fp_class_nan(x)
#       else
#           ifdef HAS_UNORDERED
#               define Perl_isnan(x) unordered((x), 0.0)
#           else
#               define Perl_isnan(x) ((x)!=(x))
#           endif
#       endif
#   endif
d2338 3
a2340 3
#ifndef Perl_isinf
#   ifdef HAS_ISINF
#       define Perl_isinf(x) isinf((NV)x)
d2342 2
a2343 2
#       ifdef Perl_fp_class_inf
#           define Perl_isinf(x) Perl_fp_class_inf(x)
d2345 1
a2345 1
#           define Perl_isinf(x) ((x)==NV_INF)
d2350 6
d2357 6
a2362 2
#   ifdef HAS_FINITE
#       define Perl_isfinite(x) finite((NV)x)
d2364 10
a2373 9
#       ifdef HAS_ISFINITE
#           define Perl_isfinite(x) isfinite(x)
#       else
#           ifdef Perl_fp_class_finite
#               define Perl_isfinite(x) Perl_fp_class_finite(x)
#           else
#               define Perl_isfinite(x) !(Perl_is_inf(x)||Perl_is_nan(x))
#           endif
#       endif
d2377 19
a2599 5
#ifdef PERL_MAD
typedef struct token TOKEN;
typedef struct madprop MADPROP;
typedef struct nexttoken NEXTTOKE;
#endif
d2603 1
d2612 1
d2662 1
a2662 1
/* a pad or name pad is currently just an AV; but that might change,
d2666 2
a2667 2
typedef AV PADNAMELIST;
typedef SV PADNAME;
d2669 3
a2671 3
/* enable PERL_NEW_COPY_ON_WRITE by default */
#if !defined(PERL_OLD_COPY_ON_WRITE) && !defined(PERL_NEW_COPY_ON_WRITE) && !defined(PERL_NO_COW)
#  define PERL_NEW_COPY_ON_WRITE
d2674 1
a2674 4
#if defined(PERL_OLD_COPY_ON_WRITE) || defined(PERL_NEW_COPY_ON_WRITE)
# if defined(PERL_OLD_COPY_ON_WRITE) && defined(PERL_NEW_COPY_ON_WRITE)
#  error PERL_OLD_COPY_ON_WRITE and PERL_NEW_COPY_ON_WRITE are exclusive
# else
a2675 1
# endif
d2680 4
d2685 1
d2815 5
d2911 37
d2953 2
d3057 97
a3165 3
#          if (defined(NeXT) || defined(__NeXT__)) && defined(PERL_POLLUTE_MALLOC)
#            define MUTEX_INIT_CALLS_MALLOC
#          endif
d3175 1
a3175 1
typedef pthread_mutex_t	perl_mutex;
d3184 19
d3397 26
d3581 3
d3644 7
d3655 1
a3655 1
#  define NORETURN_FUNCTION_END NOT_REACHED; /* NOTREACHED */
d3657 1
a3657 1
#  define NORETURN_FUNCTION_END NOT_REACHED; /* NOTREACHED */ return 0
d3678 34
d3722 1
a3722 1
   that a loop will run atleast X times. ASSUME is based off MSVC's __assume
d3728 1
a3728 1
     || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5 || __GNUC__ > 5) /* 4.5 -> */
d3831 26
a3856 2
#if !defined(OS2)
#  include "iperlsys.h"
d3875 4
a3878 5
/* Win32 defines a type 'WORD' in windef.h. This conflicts with the enumerator
 * 'WORD' defined in perly.h. The yytokentype enum is only a debugging aid, so
 * it's not really needed.
 */
#if defined(WIN32)
a3882 7
#ifdef PERL_MAD
struct nexttoken {
    YYSTYPE next_val;	/* value of next token, if any */
    I32 next_type;	/* type of next token */
    MADPROP *next_mad;	/* everything else about that token */
};
#endif
d4174 2
a4175 1
#define DEBUG_MASK		0x07FFEFFF /* mask of all the standard flags */
d4178 1
a4178 2
#define DEBUG_TOP_FLAG		0x80000000 /* XXX what's this for ??? Signal
					      that something was done? */
d4207 1
d4211 1
d4242 1
d4246 1
d4249 1
d4286 1
d4298 1
d4329 1
d4333 1
d4336 1
d4364 1
d4368 1
a4377 4
#if defined(DEBUGGING) && defined(I_ASSERT)
#  include <assert.h>
#endif

d4381 1
a4381 1
#define Perl_assert(what)	PERL_DEB( 				\
d4385 1
a4385 1
	    (void) 0)))
d4387 2
d4450 4
a4469 49
#if !defined(NV_INF) && defined(USE_LONG_DOUBLE) && defined(LDBL_INFINITY)
#  define NV_INF LDBL_INFINITY
#endif
#if !defined(NV_INF) && defined(DBL_INFINITY)
#  define NV_INF (NV)DBL_INFINITY
#endif
#if !defined(NV_INF) && defined(INFINITY)
#  define NV_INF (NV)INFINITY
#endif
#if !defined(NV_INF) && defined(INF)
#  define NV_INF (NV)INF
#endif
#if !defined(NV_INF) && defined(USE_LONG_DOUBLE) && defined(HUGE_VALL)
#  define NV_INF (NV)HUGE_VALL
#endif
#if !defined(NV_INF) && defined(HUGE_VAL)
#  define NV_INF (NV)HUGE_VAL
#endif

#if !defined(NV_NAN) && defined(USE_LONG_DOUBLE)
#   if !defined(NV_NAN) && defined(LDBL_NAN)
#       define NV_NAN LDBL_NAN
#   endif
#   if !defined(NV_NAN) && defined(LDBL_QNAN)
#       define NV_NAN LDBL_QNAN
#   endif
#   if !defined(NV_NAN) && defined(LDBL_SNAN)
#       define NV_NAN LDBL_SNAN
#   endif
#endif
#if !defined(NV_NAN) && defined(DBL_NAN)
#  define NV_NAN (NV)DBL_NAN
#endif
#if !defined(NV_NAN) && defined(DBL_QNAN)
#  define NV_NAN (NV)DBL_QNAN
#endif
#if !defined(NV_NAN) && defined(DBL_SNAN)
#  define NV_NAN (NV)DBL_SNAN
#endif
#if !defined(NV_NAN) && defined(QNAN)
#  define NV_NAN (NV)QNAN
#endif
#if !defined(NV_NAN) && defined(SNAN)
#  define NV_NAN (NV)SNAN
#endif
#if !defined(NV_NAN) && defined(NAN)
#  define NV_NAN (NV)NAN
#endif

d4471 1
a4471 4
#  if defined(NeXT) || defined(__NeXT__) /* or whatever catches all NeXTs */
char *crypt ();       /* Maybe more hosts will need the unprototyped version */
#  else
#    if !defined(WIN32) && !defined(VMS)
d4475 1
a4475 2
#    endif /* !WIN32 */
#  endif /* !NeXT && !__NeXT__ */
d4677 3
a4679 13
/* NeXT has problems with crt0.o globals */
#if defined(__DYNAMIC__) && \
    (defined(NeXT) || defined(__NeXT__) || defined(PERL_DARWIN))
#  if defined(NeXT) || defined(__NeXT)
#    include <mach-o/dyld.h>
#    define environ (*environ_pointer)
EXT char *** environ_pointer;
#  else
#    if defined(PERL_DARWIN) && defined(PERL_CORE)
#      include <crt_externs.h>	/* for the env array */
#      define environ (*_NSGetEnviron())
#    endif
#  endif
d4718 1
a4718 1
/* The core no longer needs these here. If you require the string constant,
d4722 3
a4724 2
EXTCONST char PL_no_symref_sv[] __attribute__deprecated__
  INIT("Can't use string (\"%" SVf32 "\") as %s ref while \"strict refs\" in use");
d4744 1
a4744 1
  INIT("\"%s\" variable %s can't be in a package");
d4962 8
a4969 1
	216,	217,	218,	219,	220,	221,	222,	255 /*sharp s*/,	
d5111 1
a5111 2
	"LOOP_FOR",
	"LOOP_PLAIN",
d5114 2
a5173 3
#  ifdef PERL_MAD
			     " PERL_MAD"
#  endif
a5182 3
#  ifdef PERL_OLD_COPY_ON_WRITE
			     " PERL_OLD_COPY_ON_WRITE"
#  endif
d5216 3
d5225 3
d5250 1
a5250 1
    PHASE_CHANGE_PROBE(PL_phase_names[new_phase], PL_phase_names[PL_phase]); \
d5284 1
a5284 1
#  define PL_dirty (PL_phase == PERL_PHASE_DESTRUCT)
d5319 1
d5330 7
a5336 1
    blindly change the values of these */
d5341 1
a5341 1
#define HINT_LOCALE_NOT_CHARS	0x00000010 /* locale ':not_characters' pragma */
d5374 2
a5375 2
				/* Note: Used for NATIVE_HINTS, currently
				   defined by vms/vmsish.h:
d5397 10
a5561 25
#ifndef PERL_CALLCONV
#  ifdef __cplusplus
#    define PERL_CALLCONV extern "C"
#  else
#    define PERL_CALLCONV
#  endif
#endif
#ifndef PERL_CALLCONV_NO_RET
#    define PERL_CALLCONV_NO_RET PERL_CALLCONV
#endif

/* PERL_STATIC_NO_RET is supposed to be equivalent to STATIC on builds that
   dont have a noreturn as a declaration specifier
*/
#ifndef PERL_STATIC_NO_RET
#  define PERL_STATIC_NO_RET STATIC
#endif
/* PERL_STATIC_NO_RET is supposed to be equivalent to PERL_STATIC_INLINE on
   builds that dont have a noreturn as a declaration specifier
*/
#ifndef PERL_STATIC_INLINE_NO_RET
#  define PERL_STATIC_INLINE_NO_RET PERL_STATIC_INLINE
#endif


d5571 9
a5589 6
#ifndef PERL_MAD
#  undef PL_madskills
#  undef PL_xmlfp
#  define PL_madskills 0
#  define PL_xmlfp 0
#endif
a5615 4
#ifndef PERL_MAD
#  undef op_getmad
#  define op_getmad(arg,pegop,slot) NOOP
#endif
d5630 20
d5660 1
a5660 8
/* PERL_GLOBAL_STRUCT_PRIVATE wants to keep global data like the
 * magic vtables const, but this is incompatible with SWIG which
 * does want to modify the vtables. */
#ifdef PERL_GLOBAL_STRUCT_PRIVATE
#  define EXT_MGVTBL EXTCONST MGVTBL
#else
#  define EXT_MGVTBL EXT MGVTBL
#endif
d5710 136
d5945 15
a5959 17
#define PERLDB_SUB	(PL_perldb && (PL_perldb & PERLDBf_SUB))
#define PERLDB_LINE	(PL_perldb && (PL_perldb & PERLDBf_LINE))
#define PERLDB_NOOPT	(PL_perldb && (PL_perldb & PERLDBf_NOOPT))
#define PERLDB_INTER	(PL_perldb && (PL_perldb & PERLDBf_INTER))
#define PERLDB_SUBLINE	(PL_perldb && (PL_perldb & PERLDBf_SUBLINE))
#define PERLDB_SINGLE	(PL_perldb && (PL_perldb & PERLDBf_SINGLE))
#define PERLDB_SUB_NN	(PL_perldb && (PL_perldb & (PERLDBf_NONAME)))
#define PERLDB_GOTO	(PL_perldb && (PL_perldb & PERLDBf_GOTO))
#define PERLDB_NAMEEVAL	(PL_perldb && (PL_perldb & PERLDBf_NAMEEVAL))
#define PERLDB_NAMEANON	(PL_perldb && (PL_perldb & PERLDBf_NAMEANON))
#define PERLDB_SAVESRC 	(PL_perldb && (PL_perldb & PERLDBf_SAVESRC))
#define PERLDB_SAVESRC_NOSUBS	(PL_perldb && (PL_perldb & PERLDBf_SAVESRC_NOSUBS))
#define PERLDB_SAVESRC_INVALID	(PL_perldb && (PL_perldb & PERLDBf_SAVESRC_INVALID))

/*

=head1 Locale-related functions and macros
d5961 2
a5962 1
=for apidoc sync_locale
d5964 2
a5965 4
Changing the program's locale should be avoided by XS code.  Nevertheless,
certain non-Perl libraries called from XS, such as C<Gtk> do so.  When this
happens, Perl needs to be told that the locale has changed.  Use this macro
to do so, before returning to Perl code.
d5967 2
a5968 10
=cut
*/

/* Temporary for maint.  Is a function in 5.21 */
#define sync_locale() (new_ctype(setlocale(LC_CTYPE, NULL)),        \
                       new_collate(setlocale(LC_COLLATE, NULL)),    \
                       set_numeric_local(),                         \
                       new_numeric(setlocale(LC_NUMERIC, NULL)))

#ifdef USE_LOCALE_NUMERIC
d5972 1
a5972 1
#define IN_LOCALE_RUNTIME	cBOOL(CopHINTS_get(PL_curcop) & HINT_LOCALE)
d5975 2
a5976 2
#define IN_SOME_LOCALE_FORM_RUNTIME   \
           cBOOL(CopHINTS_get(PL_curcop) & (HINT_LOCALE|HINT_LOCALE_NOT_CHARS))
d5978 3
a5980 3
#define IN_LOCALE_COMPILETIME	cBOOL(PL_hints & HINT_LOCALE)
#define IN_SOME_LOCALE_FORM_COMPILETIME \
                          cBOOL(PL_hints & (HINT_LOCALE|HINT_LOCALE_NOT_CHARS))
d5982 1
a5982 1
#define IN_LOCALE \
d5984 1
a5984 1
#define IN_SOME_LOCALE_FORM \
d5988 35
a6022 2
/* These macros are for toggling between the underlying locale (LOCAL) and the
 * C locale. */
d6024 60
a6083 25
/* The first set makes sure that the locale is set to C unless within a 'use
 * locale's scope; otherwise to the default locale.  A function pointer is
 * used, which can be declared separately by
 * DECLARATION_FOR_STORE_LC_NUMERIC_SET_TO_NEEDED, followed by the actual
 * setting (using STORE_LC_NUMERIC_SET_TO_NEEDED()), or the two can be combined
 * into one call DECLARE_STORE_LC_NUMERIC_SET_TO_NEEDED().
 * RESTORE_LC_NUMERIC() in all cases restores the locale to what it was before
 * these were called */

#define DECLARATION_FOR_STORE_LC_NUMERIC_SET_TO_NEEDED                       \
    void (*_restore_LC_NUMERIC_function)(pTHX) = NULL;

#define STORE_LC_NUMERIC_SET_TO_NEEDED()                                     \
    if (IN_SOME_LOCALE_FORM) {                                               \
        if (! PL_numeric_local) {                                            \
            SET_NUMERIC_LOCAL();                                             \
            _restore_LC_NUMERIC_function = &Perl_set_numeric_standard;       \
        }                                                                    \
    }                                                                        \
    else {                                                                   \
        if (! PL_numeric_standard) {                                         \
            SET_NUMERIC_STANDARD();                                          \
            _restore_LC_NUMERIC_function = &Perl_set_numeric_local;          \
        }                                                                    \
    }
d6085 56
a6140 2
#define DECLARE_STORE_LC_NUMERIC_SET_TO_NEEDED()                             \
    DECLARATION_FOR_STORE_LC_NUMERIC_SET_TO_NEEDED;                          \
d6142 29
d6172 28
a6199 3
#define RESTORE_LC_NUMERIC()                                                 \
    if (_restore_LC_NUMERIC_function) {                                      \
        _restore_LC_NUMERIC_function(aTHX);                                  \
d6204 7
a6210 5
#define SET_NUMERIC_STANDARD() \
	set_numeric_standard();

#define SET_NUMERIC_LOCAL() \
	set_numeric_local();
d6214 3
a6216 3
#define STORE_NUMERIC_LOCAL_SET_STANDARD() \
	bool was_local = PL_numeric_local; \
	if (was_local) SET_NUMERIC_STANDARD();
d6220 4
a6223 3
#define STORE_NUMERIC_STANDARD_SET_LOCAL() \
	bool was_standard = PL_numeric_standard && IN_SOME_LOCALE_FORM; \
	if (was_standard) SET_NUMERIC_LOCAL();
d6227 5
a6231 3
#define STORE_NUMERIC_STANDARD_FORCE_LOCAL() \
	bool was_standard = PL_numeric_standard; \
	if (was_standard) SET_NUMERIC_LOCAL();
d6233 16
a6248 7
#define RESTORE_NUMERIC_LOCAL() \
	if (was_local) SET_NUMERIC_LOCAL();

#define RESTORE_NUMERIC_STANDARD() \
	if (was_standard) SET_NUMERIC_STANDARD();

#define Atof				my_atof
d6252 2
a6253 2
#define SET_NUMERIC_STANDARD()  	/**/
#define SET_NUMERIC_LOCAL()     	/**/
d6255 6
a6260 6
#define STORE_NUMERIC_LOCAL_SET_STANDARD()	/**/
#define STORE_NUMERIC_STANDARD_SET_LOCAL()	/**/
#define STORE_NUMERIC_STANDARD_FORCE_LOCAL()
#define RESTORE_NUMERIC_LOCAL()		/**/
#define RESTORE_NUMERIC_STANDARD()	/**/
#define DECLARATION_FOR_STORE_LC_NUMERIC_SET_TO_NEEDED
a6261 1
#define DECLARE_STORE_LC_NUMERIC_SET_TO_NEEDED()
d6263 4
a6268 2
#define IN_LOCALE_RUNTIME		0
#define IN_LOCALE_COMPILETIME		0
d6270 31
a6300 1
#endif /* !USE_LOCALE_NUMERIC */
a6361 18

/* if these never got defined, they need defaults */
#ifndef PERL_SET_CONTEXT
#  define PERL_SET_CONTEXT(i)		PERL_SET_INTERP(i)
#endif

#ifndef PERL_GET_CONTEXT
#  define PERL_GET_CONTEXT		PERL_GET_INTERP
#endif

#ifndef PERL_GET_THX
#  define PERL_GET_THX			((void*)NULL)
#endif

#ifndef PERL_SET_THX
#  define PERL_SET_THX(t)		NOOP
#endif

d6366 1
a6366 5
/*
 * Some operating systems are stingy with stack allocation,
 * so perl may have to guard against stack overflow.
 */
#ifndef PERL_STACK_OVERFLOW_CHECK
a6367 1
#endif
d6487 4
a6490 2
	Copy(PL_my_cxt_list[MY_CXT_INDEX], my_cxtp, 1, my_cxt_t);\
	PL_my_cxt_list[MY_CXT_INDEX] = my_cxtp				\
d6533 4
d6562 1
a6562 1
    /* If you have different O_TEXT and O_BINARY and you are a CLRF shop,
d6590 1
a6590 1
#define IS_NUMBER_NOT_INT	      0x04 /* saw . or E notation */
d6594 1
d6604 3
a6625 8
/* The UTF-8 bytes of the Unicode LS and PS, U+2028 and U+2029 */
#define UNICODE_LINE_SEPA_0	0xE2
#define UNICODE_LINE_SEPA_1	0x80
#define UNICODE_LINE_SEPA_2	0xA8
#define UNICODE_PARA_SEPA_0	0xE2
#define UNICODE_PARA_SEPA_1	0x80
#define UNICODE_PARA_SEPA_2	0xA9

d6705 1
a6705 1
#if defined(OEMVS)
d6716 1
a6716 1
#define PERL_PV_ESCAPE_QUOTE        0x0001
d6719 27
a6745 2
#define PERL_PV_PRETTY_ELLIPSES     0x0002
#define PERL_PV_PRETTY_LTGT         0x0004
d6747 5
a6751 1
#define PERL_PV_ESCAPE_FIRSTCHAR    0x0008
d6753 4
a6756 3
#define PERL_PV_ESCAPE_UNI          0x0100
#define PERL_PV_ESCAPE_UNI_DETECT   0x0200
#define PERL_PV_ESCAPE_NONASCII     0x0400
d6758 3
a6760 4
#define PERL_PV_ESCAPE_ALL	    0x1000
#define PERL_PV_ESCAPE_NOBACKSLASH  0x2000
#define PERL_PV_ESCAPE_NOCLEAR      0x4000
#define PERL_PV_ESCAPE_RE           0x8000
d6762 1
a6762 1
#define PERL_PV_ESCAPE_DWIM         0x10000
d6764 263
a7026 1
#define PERL_PV_PRETTY_NOCLEAR      PERL_PV_ESCAPE_NOCLEAR
d7028 4
a7031 3
/* used by pv_display in dump.c*/
#define PERL_PV_PRETTY_DUMP  PERL_PV_PRETTY_ELLIPSES|PERL_PV_PRETTY_QUOTE
#define PERL_PV_PRETTY_REGPROP PERL_PV_PRETTY_ELLIPSES|PERL_PV_PRETTY_LTGT|PERL_PV_ESCAPE_RE|PERL_PV_ESCAPE_NONASCII
d7033 147
a7232 6
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
@


1.19
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d684 9
a1118 8
/* In Tru64 use the 4.4BSD struct msghdr, not the 4.3 one.
 * This is important for using IPv6.
 * For OSF/1 3.2, however, defining _SOCKADDR_LEN would be
 * a bad idea since it breaks send() and recv(). */
#if defined(__osf__) && defined(__alpha) && !defined(_SOCKADDR_LEN) && !defined(DEC_OSF1_3_X)
#   define _SOCKADDR_LEN
#endif

d1799 10
@


1.18
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@a24 9
#if defined(DGUX)
#include <sys/fcntl.h>
#endif

#ifdef VOIDUSED
#   undef VOIDUSED
#endif
#define VOIDUSED 1

d28 1
a28 5
#   ifndef USE_CROSS_COMPILE
#       include "config.h"
#   else
#       include "xconfig.h"
#   endif
d89 1
a89 1
#/* Use the reentrant APIs like localtime_r and getpwent_r */
d97 3
a99 9
/*
 * PERL_DARWIN for MacOSX (__APPLE__ exists but is not officially sanctioned)
 * (The -DPERL_DARWIN comes from the hints/darwin.sh.)
 * __bsdi__ for BSD/OS
 */
#if defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__) || defined(PERL_DARWIN) || defined(__bsdi__) || defined(BSD41) || defined(BSD42) || defined(BSD43) || defined(BSD44)
#   ifndef BSDish
#       define BSDish
#   endif
d178 1
d210 1
a210 1
#define CALLREGEXEC(prog,stringarg,strend,strbeg,minend,screamer,data,flags) \
d212 3
a214 3
        (strbeg),(minend),(screamer),(data),(flags))
#define CALLREG_INTUIT_START(prog,sv,strpos,strend,flags,data) \
    RX_ENGINE(prog)->intuit(aTHX_ (prog), (sv), (strpos), \
d330 72
d415 1
a415 1
/* Don't bother defining tTHX and sTHX; using them outside
d434 1
a495 21
#ifdef OP_IN_REGISTER
#  ifdef __GNUC__
#    define stringify_immed(s) #s
#    define stringify(s) stringify_immed(s)
struct op *Perl_op asm(stringify(OP_IN_REGISTER));
#  endif
#endif

/* gcc (-ansi) -pedantic doesn't allow gcc statement expressions,
 * g++ allows them but seems to have problems with them
 * (insane errors ensue).
 * g++ does not give insane errors now (RMB 2008-01-30, gcc 4.2.2).
 */
#if defined(PERL_GCC_PEDANTIC) || \
    (defined(__GNUC__) && defined(__cplusplus) && \
	((__GNUC__ < 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ < 2))))
#  ifndef PERL_GCC_BRACE_GROUPS_FORBIDDEN
#    define PERL_GCC_BRACE_GROUPS_FORBIDDEN
#  endif
#endif

a513 5
   /* Now which other defined()s do we need here ??? */
#  if (VOIDFLAGS) && (defined(sun) || defined(__sun__)) && !defined(__GNUC__)
#   define STMT_START	if (1)
#   define STMT_END	else (void)0
#  else
a515 1
#  endif
d551 1
a551 1
#if defined(__cplusplus) || defined(WIN32) || defined(__sgi) || defined(__EMX__) || defined(__DGUX) || defined(__QNX__) || defined(NETWARE) || defined(PERL_MICRO)
d576 1
a576 1
#if SILENT_NO_TAINT_SUPPORT && !defined(NO_TAINT_SUPPORT)
d584 1
a584 1
#if NO_TAINT_SUPPORT
d676 1
a676 5
#ifndef _TYPES_		/* If types.h defines this it's easy. */
#   ifndef major		/* Does everyone's types.h define this? */
#	include <sys/types.h>
#   endif
#endif
d722 2
d734 9
d754 10
d783 1
a783 1
#if defined(HAS_SYSCALL) && !defined(HAS_SYSCALL_PROTO) && !defined(PERL_MICRO)
d787 1
a787 1
#if defined(HAS_USLEEP) && !defined(HAS_USLEEP_PROTO) && !defined(PERL_MICRO)
a790 9
/* Funky places that do not have socket stuff. */
#if defined(__LIBCATAMOUNT__)
#  define MYSWAP
#endif

#ifdef PERL_MICRO /* Last chance to export Perl_my_swap */
#  define MYSWAP
#endif

a842 183
/*----------------------------------------------------------------------------*/
# if BYTEORDER == 0x1234 || BYTEORDER == 0x12345678  /*     little-endian     */
/*----------------------------------------------------------------------------*/
#  define my_htole16(x)		(x)
#  define my_letoh16(x)		(x)
#  define my_htole32(x)		(x)
#  define my_letoh32(x)		(x)
#  define my_htobe16(x)		_swab_16_(x)
#  define my_betoh16(x)		_swab_16_(x)
#  define my_htobe32(x)		_swab_32_(x)
#  define my_betoh32(x)		_swab_32_(x)
#  ifdef HAS_QUAD
#   define my_htole64(x)	(x)
#   define my_letoh64(x)	(x)
#   define my_htobe64(x)	_swab_64_(x)
#   define my_betoh64(x)	_swab_64_(x)
#  endif
#  define my_htoles(x)		(x)
#  define my_letohs(x)		(x)
#  define my_htolei(x)		(x)
#  define my_letohi(x)		(x)
#  define my_htolel(x)		(x)
#  define my_letohl(x)		(x)
#  if SHORTSIZE == 1
#   define my_htobes(x)		(x)
#   define my_betohs(x)		(x)
#  elif SHORTSIZE == 2
#   define my_htobes(x)		_swab_16_(x)
#   define my_betohs(x)		_swab_16_(x)
#  elif SHORTSIZE == 4
#   define my_htobes(x)		_swab_32_(x)
#   define my_betohs(x)		_swab_32_(x)
#  elif SHORTSIZE == 8
#   define my_htobes(x)		_swab_64_(x)
#   define my_betohs(x)		_swab_64_(x)
#  else
#   define PERL_NEED_MY_HTOBES
#   define PERL_NEED_MY_BETOHS
#  endif
#  if INTSIZE == 1
#   define my_htobei(x)		(x)
#   define my_betohi(x)		(x)
#  elif INTSIZE == 2
#   define my_htobei(x)		_swab_16_(x)
#   define my_betohi(x)		_swab_16_(x)
#  elif INTSIZE == 4
#   define my_htobei(x)		_swab_32_(x)
#   define my_betohi(x)		_swab_32_(x)
#  elif INTSIZE == 8
#   define my_htobei(x)		_swab_64_(x)
#   define my_betohi(x)		_swab_64_(x)
#  else
#   define PERL_NEED_MY_HTOBEI
#   define PERL_NEED_MY_BETOHI
#  endif
#  if LONGSIZE == 1
#   define my_htobel(x)		(x)
#   define my_betohl(x)		(x)
#  elif LONGSIZE == 2
#   define my_htobel(x)		_swab_16_(x)
#   define my_betohl(x)		_swab_16_(x)
#  elif LONGSIZE == 4
#   define my_htobel(x)		_swab_32_(x)
#   define my_betohl(x)		_swab_32_(x)
#  elif LONGSIZE == 8
#   define my_htobel(x)		_swab_64_(x)
#   define my_betohl(x)		_swab_64_(x)
#  else
#   define PERL_NEED_MY_HTOBEL
#   define PERL_NEED_MY_BETOHL
#  endif
#  define my_htolen(p,n)	NOOP
#  define my_letohn(p,n)	NOOP
#  define my_htoben(p,n)	my_swabn(p,n)
#  define my_betohn(p,n)	my_swabn(p,n)
/*----------------------------------------------------------------------------*/
# elif BYTEORDER == 0x4321 || BYTEORDER == 0x87654321  /*     big-endian      */
/*----------------------------------------------------------------------------*/
#  define my_htobe16(x)		(x)
#  define my_betoh16(x)		(x)
#  define my_htobe32(x)		(x)
#  define my_betoh32(x)		(x)
#  define my_htole16(x)		_swab_16_(x)
#  define my_letoh16(x)		_swab_16_(x)
#  define my_htole32(x)		_swab_32_(x)
#  define my_letoh32(x)		_swab_32_(x)
#  ifdef HAS_QUAD
#   define my_htobe64(x)	(x)
#   define my_betoh64(x)	(x)
#   define my_htole64(x)	_swab_64_(x)
#   define my_letoh64(x)	_swab_64_(x)
#  endif
#  define my_htobes(x)		(x)
#  define my_betohs(x)		(x)
#  define my_htobei(x)		(x)
#  define my_betohi(x)		(x)
#  define my_htobel(x)		(x)
#  define my_betohl(x)		(x)
#  if SHORTSIZE == 1
#   define my_htoles(x)		(x)
#   define my_letohs(x)		(x)
#  elif SHORTSIZE == 2
#   define my_htoles(x)		_swab_16_(x)
#   define my_letohs(x)		_swab_16_(x)
#  elif SHORTSIZE == 4
#   define my_htoles(x)		_swab_32_(x)
#   define my_letohs(x)		_swab_32_(x)
#  elif SHORTSIZE == 8
#   define my_htoles(x)		_swab_64_(x)
#   define my_letohs(x)		_swab_64_(x)
#  else
#   define PERL_NEED_MY_HTOLES
#   define PERL_NEED_MY_LETOHS
#  endif
#  if INTSIZE == 1
#   define my_htolei(x)		(x)
#   define my_letohi(x)		(x)
#  elif INTSIZE == 2
#   define my_htolei(x)		_swab_16_(x)
#   define my_letohi(x)		_swab_16_(x)
#  elif INTSIZE == 4
#   define my_htolei(x)		_swab_32_(x)
#   define my_letohi(x)		_swab_32_(x)
#  elif INTSIZE == 8
#   define my_htolei(x)		_swab_64_(x)
#   define my_letohi(x)		_swab_64_(x)
#  else
#   define PERL_NEED_MY_HTOLEI
#   define PERL_NEED_MY_LETOHI
#  endif
#  if LONGSIZE == 1
#   define my_htolel(x)		(x)
#   define my_letohl(x)		(x)
#  elif LONGSIZE == 2
#   define my_htolel(x)		_swab_16_(x)
#   define my_letohl(x)		_swab_16_(x)
#  elif LONGSIZE == 4
#   define my_htolel(x)		_swab_32_(x)
#   define my_letohl(x)		_swab_32_(x)
#  elif LONGSIZE == 8
#   define my_htolel(x)		_swab_64_(x)
#   define my_letohl(x)		_swab_64_(x)
#  else
#   define PERL_NEED_MY_HTOLEL
#   define PERL_NEED_MY_LETOHL
#  endif
#  define my_htolen(p,n)	my_swabn(p,n)
#  define my_letohn(p,n)	my_swabn(p,n)
#  define my_htoben(p,n)	NOOP
#  define my_betohn(p,n)	NOOP
/*----------------------------------------------------------------------------*/
# else /*                       all other byte-orders                         */
/*----------------------------------------------------------------------------*/
#  define PERL_NEED_MY_HTOLE16
#  define PERL_NEED_MY_LETOH16
#  define PERL_NEED_MY_HTOBE16
#  define PERL_NEED_MY_BETOH16
#  define PERL_NEED_MY_HTOLE32
#  define PERL_NEED_MY_LETOH32
#  define PERL_NEED_MY_HTOBE32
#  define PERL_NEED_MY_BETOH32
#  ifdef HAS_QUAD
#   define PERL_NEED_MY_HTOLE64
#   define PERL_NEED_MY_LETOH64
#   define PERL_NEED_MY_HTOBE64
#   define PERL_NEED_MY_BETOH64
#  endif
#  define PERL_NEED_MY_HTOLES
#  define PERL_NEED_MY_LETOHS
#  define PERL_NEED_MY_HTOBES
#  define PERL_NEED_MY_BETOHS
#  define PERL_NEED_MY_HTOLEI
#  define PERL_NEED_MY_LETOHI
#  define PERL_NEED_MY_HTOBEI
#  define PERL_NEED_MY_BETOHI
#  define PERL_NEED_MY_HTOLEL
#  define PERL_NEED_MY_LETOHL
#  define PERL_NEED_MY_HTOBEL
#  define PERL_NEED_MY_BETOHL
/*----------------------------------------------------------------------------*/
# endif /*                     end of byte-order macros                       */
/*----------------------------------------------------------------------------*/

a1012 3
#  ifdef BUGGY_MSC
#    pragma function(memcmp)
#  endif
a1052 6
#if defined(SF_APPEND) && defined(USE_SFIO) && defined(I_SFIO)
/* <sfio.h> defines SF_APPEND and <sys/stat.h> might define SF_APPEND
 * (the neo-BSD seem to do this).  */
#   undef SF_APPEND
#endif

d1168 1
a1168 1
#  if defined(__OpenBSD__) || defined(__FreeBSD__) || defined(__NetBSD__)
a1202 6
#   define SETERRNO(errcode,vmserrcode) (errno = (errcode))
#   define dSAVEDERRNO    int saved_errno
#   define dSAVE_ERRNO    int saved_errno = errno
#   define SAVE_ERRNO     (saved_errno = errno)
#   define RESTORE_ERRNO  (errno = saved_errno)

d1217 25
a1277 2
#define ERRHV GvHV(PL_errgv)	/* XXX unused, here for compatibility */

d1286 2
d1289 1
a1289 1
#ifndef DONT_DECLARE_STD
d1295 4
a1298 4
#endif
#       ifndef Strerror
#           define Strerror strerror
#       endif
d1305 1
a1305 1
		((e) < 0 || (e) >= sys_nerr ? "(unknown)" : sys_errlist[e])
a1359 13
#ifdef PERL_MICRO
#   ifndef DIR
#      define DIR void
#   endif
#endif

#ifdef FPUTS_BOTCH
/* work around botch in SunOS 4.0.1 and 4.0.2 */
#   ifndef fputs
#	define fputs(sv,fp) fprintf(fp,"%s",sv)
#   endif
#endif

d1366 1
a1366 1
#if defined(I_SYSMODE) && !defined(PERL_MICRO)
a1509 4
#ifdef ff_next
#   undef ff_next
#endif

d1634 5
d1640 1
d1644 1
a1644 6
#ifndef HAS_QUAD
# undef PERL_NEED_MY_HTOLE64
# undef PERL_NEED_MY_LETOH64
# undef PERL_NEED_MY_HTOBE64
# undef PERL_NEED_MY_BETOH64
#endif
d1959 1
a1959 1
#if !defined(Perl_fp_class) && defined(HAS_FP_CLASS) && !defined(PERL_MICRO)
a2267 3
struct RExC_state_t;
struct _reg_trie_data;

d2321 1
d2342 4
a2345 5
/* XXX for 5.18, disable the COW by default
 * #if !defined(PERL_OLD_COPY_ON_WRITE) && !defined(PERL_NEW_COPY_ON_WRITE) && !defined(PERL_NO_COW)
 * # define PERL_NEW_COPY_ON_WRITE
 * #endif
 */
d2469 1
a2469 4
#   define ISHISH "dos"
#endif

#if defined(VMS)
d2471 1
a2471 4
#   define ISHISH "vms"
#endif

#if defined(PLAN9)
d2473 1
a2473 4
#   define ISHISH "plan9"
#endif

#if defined(__VOS__)
d2479 1
a2479 4
#   define ISHISH "vos"
#endif

#ifdef __SYMBIAN32__
d2481 1
a2481 5
#   define ISHISH "symbian"
#endif


#if defined(__HAIKU__)
d2483 1
a2483 4
#   define ISHISH "haiku"
#endif

#ifndef ISHISH
a2484 1
#   define ISHISH "unix"
d2585 1
a2585 1
run Perl interpreters. This should be called only once, before creating
d2590 1
a2590 1
run Perl interpreters. This should be called only once, before creating
d2595 1
a2595 1
running Perl interpreters. This should be called only once, after
a2688 3
#  ifdef FAKE_THREADS
#    include "fakethr.h"
#  else
d2715 1
a2715 2
#  endif /* FAKE_THREADS */
#endif	/* NETWARE */
d2968 2
d2991 1
a2991 1
# if defined(USE_PERLIO) || defined(FFLUSH_NULL) || defined(USE_SFIO)
d3064 3
a3066 7
#ifdef PERL_CORE
/* not used; but needed for backward compatibility with XS code? - RMB */
#  undef VDf
#else
#  ifndef VDf
#    define VDf "vd"
#  endif
d3068 1
d3134 1
a3134 1
#  define NORETURN_FUNCTION_END assert(0); /* NOTREACHED */
d3136 1
a3136 1
#  define NORETURN_FUNCTION_END assert(0); /* NOTREACHED */ return 0
d3151 2
a3152 2
#define LIKELY(cond)                        EXPECT(cond,1)
#define UNLIKELY(cond)                      EXPECT(cond,0)
d3157 33
d3238 1
d3258 1
a3258 1
		&& (i) <= av_len(PL_parser->rsfp_filters))
d3362 19
a3380 2
struct scan_data_t;		/* Used in S_* functions in regcomp.c */
struct regnode_charclass_class;	/* Used in S_* functions in regcomp.c */
a3409 1
#if (BYTEORDER & 0xffff) != 0x4321
d3414 45
a3458 13
#define MYSWAP
#define htons my_swap
#define htonl my_htonl
#define ntohs my_swap
#define ntohl my_ntohl
#endif
#else
#if (BYTEORDER & 0xffff) == 0x4321
#undef HAS_HTONS
#undef HAS_HTONL
#undef HAS_NTOHS
#undef HAS_NTOHL
#endif
d3465 9
a3473 6
#if BYTEORDER != 0x1234
# define HAS_VTOHL
# define HAS_VTOHS
# define HAS_HTOVL
# define HAS_HTOVS
# if BYTEORDER == 0x4321 || BYTEORDER == 0x87654321
d3481 5
a3485 8
# endif
	/* otherwise default to functions in util.c */
#ifndef htovs
short htovs(short n);
short vtohs(short n);
long htovl(long n);
long vtohl(long n);
#endif
d3523 2
a3524 2
#define I_V(n) ((n) < IV_MAX_P1 ? ((n) < IV_MIN ? IV_MIN : (IV) (n)) \
                  : ((n) < UV_MAX_P1 ? (IV)(UV) (n) \
d3526 2
a3527 2
#define U_V(n) ((n) < 0.0 ? ((n) < IV_MIN ? (UV) IV_MIN : (UV)(IV) (n)) \
                  : ((n) < UV_MAX_P1 ? (UV) (n) \
d3602 2
a3603 1
#define DEBUG_MASK		0x03FFEFFF /* mask of all the standard flags */
d3635 1
d3668 1
d3720 1
d3750 1
d3782 1
d4015 1
a4015 1
#ifdef USE_PERLIO
d4060 1
a4060 1
#  ifdef PERL_POISON
d4065 10
d4077 6
a4082 1
#  define sTHX	(sizeof(struct perl_memory_debug_header) + \
d4087 1
a4087 1
#  define sTHX	0
d4091 8
d4104 2
a4105 1
#  else
d4117 1
a4117 1
#  ifdef HAS_MALLOC_SIZE
d4120 1
a4120 1
	    (malloc_size(((char *)(where)) - sTHX) - sTHX)
d4128 1
a4128 1
	    (malloc_good_size((how_much) + sTHX) - sTHX)
d4162 2
a4163 3
        (defined(__svr4__) && defined(__GNUC__) && defined(sun)) || \
        defined(__sgi) || \
        defined(__DGUX)
d4187 1
a4187 1
  INIT("Use of uninitialized value%"SVf"%s%s");
d4207 1
a4207 1
  INIT("Modification of non-creatable hash value attempted, subscript \"%"SVf"\"");
a4370 1
#endif  /* !EBCDIC, but still in DOINIT */
d4445 1
d4447 1
a4447 1
#ifndef EBCDIC
a4449 1
#endif
d4452 1
a4606 3
#  ifdef FAKE_THREADS
			     " FAKE_THREADS"
#  endif
d4625 3
d4634 3
a4657 3
#  ifdef PERL_NEW_COPY_ON_WRITE
			     " PERL_NEW_COPY_ON_WRITE"
#  endif
a4699 3
#  ifdef USE_SFIO
			     " USE_SFIO"
#  endif
d4758 2
d4788 1
d4795 4
a4798 1
   However, bitops store HINT_INTEGER in their op_private.  */
d5150 1
a5150 1
		        /* NL BD IV NV PV PI PN MG RX GV LV AV HV CV FM IO */
d5152 1
a5152 1
PL_valid_types_IVX[]    = { 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0 };
d5154 1
a5154 1
PL_valid_types_NVX[]    = { 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0 };
d5156 1
a5156 1
PL_valid_types_PVX[]    = { 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1 };
d5158 1
a5158 1
PL_valid_types_RV[]     = { 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1 };
d5160 1
a5160 1
PL_valid_types_IV_set[] = { 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1 };
d5162 1
a5162 1
PL_valid_types_NV_set[] = { 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0 };
d5288 13
a5300 1
#ifdef USE_LOCALE_NUMERIC
d5302 5
a5306 2
#define SET_NUMERIC_STANDARD() \
	set_numeric_standard();
d5308 1
a5308 2
#define SET_NUMERIC_LOCAL() \
	set_numeric_local();
d5310 1
a5310 1
/* Returns non-zero If the plain locale pragma without a parameter is in effect
d5312 1
a5312 1
#define IN_LOCALE_RUNTIME	(CopHINTS_get(PL_curcop) & HINT_LOCALE)
d5314 1
a5314 1
/* Returns non-zero If either form of the locale pragma is in effect */
d5316 1
a5316 1
		(CopHINTS_get(PL_curcop) & (HINT_LOCALE|HINT_LOCALE_NOT_CHARS))
d5318 1
a5318 1
#define IN_LOCALE_COMPILETIME	(PL_hints & HINT_LOCALE)
d5320 1
a5320 1
			    (PL_hints & (HINT_LOCALE|HINT_LOCALE_NOT_CHARS))
d5328 48
d5377 1
a5377 1
	bool was_local = PL_numeric_local && IN_LOCALE; \
d5380 2
d5383 7
a5389 1
	bool was_standard = PL_numeric_standard && IN_LOCALE; \
d5407 1
d5410 5
d5520 1
a5520 1
#		define PERL_ASYNC_CHECK() if (PL_sig_pending) PL_signalhook(aTHX)
d5839 6
d5872 2
@


1.17
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@a50 9
#ifdef PERL_IMPLICIT_SYS
/* PERL_IMPLICIT_SYS implies PerlMemShared != PerlMem
   so use slab allocator to avoid lots of MUTEX overhead
 */
#  ifndef PL_OP_SLAB_ALLOC
#    define PL_OP_SLAB_ALLOC
#  endif
#endif

d94 2
a95 2
#if defined(EPOC) || defined(__SYMBIAN32__)
/* EPOC/Symbian: need to work around the SDK features. *
d160 1
a160 1
#define pVAR    register struct perl_vars* my_vars PERL_UNUSED_DECL
d173 1
a173 1
#  define pTHX  register tTHX my_perl PERL_UNUSED_DECL
d175 1
d354 3
d358 1
d368 1
d397 1
a397 1
#  define pTHXx		register PerlInterpreter *my_perl
d445 1
a445 1
register struct op *Perl_op asm(stringify(OP_IN_REGISTER));
d515 1
a515 1
#if defined(MSDOS) || defined(atarist) || defined(WIN32) || defined(NETWARE)
d519 1
a519 1
#if defined(__STDC__) || defined(_AIX) || defined(__stdc__) || defined(__cplusplus) || defined(EPOC) || defined(NETWARE) || defined(__SYMBIAN32__)
d523 1
a523 1
#if defined(__cplusplus) || defined(WIN32) || defined(__sgi) || defined(__EMX__) || defined(__DGUX) || defined(EPOC) || defined(__QNX__) || defined(NETWARE) || defined(PERL_MICRO)
d533 48
a580 5
#define TAINT		(PL_tainted = TRUE)
#define TAINT_NOT	(PL_tainted = FALSE)
#define TAINT_IF(c)	if (c) { PL_tainted = TRUE; }
#define TAINT_ENV()	if (PL_tainting) { taint_env(); }
#define TAINT_PROPER(s)	if (PL_tainting) { taint_proper(NULL, s); }
d777 2
d1015 1
a1015 1
#if !defined(OS2) && !defined(WIN32) && !defined(DJGPP) && !defined(EPOC) && !defined(__SYMBIAN32__)
d1220 1
a1220 1
/* The stat macros for Amdahl UTS, Unisoft System V/88 (and derivatives
d1229 1
a1229 1
#if defined(uts) || (defined(m88k) && defined(ghs))
d1426 1
a1429 1
#ifndef DONT_DECLARE_STD
d1431 1
a1432 1
#       endif
d1644 1
a1644 1
/* BeOS 5.0 and Haiku R1 seem to define S_IREAD and S_IWRITE in <posix/fcntl.h>
d1648 1
a1648 1
#if !defined(S_IREAD) && !(defined(__BEOS__) || defined(__HAIKU__))
d1652 1
a1652 1
#if !defined(S_IWRITE) && !(defined(__BEOS__) || defined(__HAIKU__))
a1671 4
#ifdef	SPRINTF_E_BUG
#  define sprintf UTS_sprintf_wrap
#endif

d1712 1
a1712 1
#      define my_vsnprintf(buffer, len, ...) ({ int __len__ = vsnprintf(buffer, len, __VA_ARGS__); if ((len) > 0 && (Size_t)__len__ >= (len)) Perl_croak_nocontext("panic: vsnprintf buffer overflow"); __len__; })
a1733 7
/* Configure gets this right but the UTS compiler gets it wrong.
   -- Hal Morris <hom00@@utsglobal.com> */
#ifdef UTS
#  undef  UVTYPE
#  define UVTYPE unsigned
#endif

a1798 5
#if defined(uts) || defined(UTS)
#	undef UV_MAX
#	define UV_MAX (4294967295u)
#endif

d2443 5
a2452 1
/* Amdahl's <ksync.h> has struct sv */
d2454 1
a2454 1
#if defined(UTS) || defined(__sgi)
d2490 23
a2618 5
#if defined(__OPEN_VM)
#   include "vmesa/vmesaish.h"
#   define ISHISH "vmesa"
#endif

a2637 5
#if defined(MPE)
#  include "mpeix/mpeixish.h"
#  define ISHISH "mpeix"
#endif

a2646 5
#if defined(EPOC)
#   include "epocish.h"
#   define ISHISH "epoc"
#endif

a2655 3
#elif defined(__BEOS__)
#   include "beos/beosish.h"
#   define ISHISH "beos"
d2759 1
a2759 1
=for apidoc Am|void|PERL_SYS_INIT|int argc|char** argv
d2764 1
a2764 1
=for apidoc Am|void|PERL_SYS_INIT3|int argc|char** argv|char** env
d3315 1
a3315 1
#  define NORETURN_FUNCTION_END /* NOTREACHED */
d3317 1
a3317 1
#  define NORETURN_FUNCTION_END /* NOTREACHED */ return 0
d3502 1
a3502 2
    char *super_bufptr;	/* PL_parser->bufptr that was */
    char *super_bufend;	/* PL_parser->bufend that was */
a3526 4
#if defined(iAPX286) || defined(M_I286) || defined(I80286)
#   define I286
#endif

d3652 1
a3652 1
#if !(defined(UNDER_CE) || defined(SYMBIAN))
d3691 1
a3691 1
/* 0x00010000 is unused, used to be S */
d3701 1
a3701 1
#define DEBUG_MASK		0x03FEEFFF /* mask of all the standard flags */
d3723 1
d3755 1
d3807 1
d3835 1
d3867 1
d3904 5
d3950 1
a3950 1
#if defined(OEMVS) || defined(__OPEN_VM)
d4041 1
a4041 1
#    if !defined(HAS_LSEEK_PROTO) && !defined(EPOC) && !defined(__hpux)
d4049 2
a4050 1
#ifndef getlogin
d4052 2
a4053 1
#endif
d4280 1
a4280 1
EXTCONST char PL_no_mem[]
d4517 1
d4520 1
d4642 3
a4644 1
#ifdef DEBUGGING
a4662 1
#endif
d4725 3
d4731 3
a4739 3
#  ifdef PL_OP_SLAB_ALLOC
			     " PL_OP_SLAB_ALLOC"
#  endif
d4827 2
d4915 11
d5012 2
d5015 2
d5018 2
d5036 2
a5037 2
EXTCONST U16 PL_interp_size_5_16_0
  INIT(PERL_INTERPRETER_SIZE_UPTO_MEMBER(PERL_LAST_5_16_0_INTERP_MEMBER));
d5088 18
d5223 1
a5223 1
PL_valid_types_PVX[]    = { 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1 };
d5242 15
a5266 1
  long was_ok_am;
a5273 1
  long was_ok_am;
a5282 1
#define AMTf_OVERLOADED		2
a5285 3
#define AMT_OVERLOADED(amt)	((amt)->flags & AMTf_OVERLOADED)
#define AMT_OVERLOADED_on(amt)	((amt)->flags |= AMTf_OVERLOADED)
#define AMT_OVERLOADED_off(amt)	((amt)->flags &= ~AMTf_OVERLOADED)
d5412 2
a5413 1
#if !defined(Strtol) && defined(USE_64_BIT_INT) && defined(IV_IS_QUAD) && QUADKIND == QUAD_IS_LONG_LONG
d5435 2
a5436 1
#   if defined(USE_64_BIT_INT) && defined(IV_IS_QUAD) && QUADKIND == QUAD_IS_LONG_LONG && defined(HAS_ATOLL)
d5446 2
a5447 1
#if !defined(Strtoul) && defined(USE_64_BIT_INT) && defined(UV_IS_QUAD) && QUADKIND == QUAD_IS_LONG_LONG
d5691 3
a5693 4
#   if defined(__BEOS__) || defined(__HAIKU__) || defined(__VOS__) || \
	defined(__CYGWIN__)
    /* BeOS/Haiku has O_TEXT != O_BINARY but O_TEXT and O_BINARY have no effect;
     * BeOS/Haiku is always UNIXoid (LF), not DOSish (CRLF). */
d5747 1
a5747 9
#ifdef EBCDIC	/* In EBCDIC NEL is just an alias for LF */
#   if '^' == 95	/* CP 1047: MVS OpenEdition - OS/390 - z/OS */
#       define NEXT_LINE_CHAR	0x15
#   else		/* CDRA */
#       define NEXT_LINE_CHAR	0x25
#   endif
#else
#   define NEXT_LINE_CHAR	0x85
#endif
d5920 1
a5920 1
 * indent-tabs-mode: t
d5923 1
a5923 1
 * ex: set ts=8 sts=4 sw=4 noet:
@


1.16
log
@merge in perl 5.12.2 plus local changes
@
text
@d143 12
d213 7
d228 2
d231 1
a231 1
#define CALLRUNOPS  CALL_FPTR(PL_runops)
d235 1
a235 2
#define CALLREGCOMP_ENG(prog, sv, flags) \
    CALL_FPTR(((prog)->comp))(aTHX_ sv, flags)
d237 1
a237 1
    CALL_FPTR(RX_ENGINE(prog)->exec)(aTHX_ (prog),(stringarg),(strend), \
d240 1
a240 1
    CALL_FPTR(RX_ENGINE(prog)->intuit)(aTHX_ (prog), (sv), (strpos), \
d243 1
a243 1
    CALL_FPTR(RX_ENGINE(prog)->checkstr)(aTHX_ (prog))
d249 1
a249 1
    if(prog) CALL_FPTR(RX_ENGINE(prog)->free)(aTHX_ (prog))
d252 1
a252 1
    CALL_FPTR(RX_ENGINE(rx)->numbered_buff_FETCH)(aTHX_ (rx),(paren),(usesv))
d255 1
a255 1
    CALL_FPTR(RX_ENGINE(rx)->numbered_buff_STORE)(aTHX_ (rx),(paren),(value))
d258 1
a258 1
    CALL_FPTR(RX_ENGINE(rx)->numbered_buff_LENGTH)(aTHX_ (rx),(sv),(paren))
d261 1
a261 1
    CALL_FPTR(RX_ENGINE(rx)->named_buff)(aTHX_ (rx), (key), NULL, ((flags) | RXapif_FETCH))
d264 1
a264 1
    CALL_FPTR(RX_ENGINE(rx)->named_buff)(aTHX_ (rx), (key), (value), ((flags) | RXapif_STORE))
d267 1
a267 1
    CALL_FPTR(RX_ENGINE(rx)->named_buff)(aTHX_ (rx),(key), NULL, ((flags) | RXapif_DELETE))
d270 1
a270 1
    CALL_FPTR(RX_ENGINE(rx)->named_buff)(aTHX_ (rx), NULL, NULL, ((flags) | RXapif_CLEAR))
d273 1
a273 1
    CALL_FPTR(RX_ENGINE(rx)->named_buff)(aTHX_ (rx), (key), NULL, ((flags) | RXapif_EXISTS))
d276 1
a276 1
    CALL_FPTR(RX_ENGINE(rx)->named_buff_iter)(aTHX_ (rx), NULL, ((flags) | RXapif_FIRSTKEY))
d279 1
a279 1
    CALL_FPTR(RX_ENGINE(rx)->named_buff_iter)(aTHX_ (rx), (lastkey), ((flags) | RXapif_NEXTKEY))
d282 1
a282 1
    CALL_FPTR(RX_ENGINE(rx)->named_buff)(aTHX_ (rx), NULL, NULL, ((flags) | RXapif_SCALAR))
d285 1
a285 1
    CALL_FPTR(RX_ENGINE(rx)->named_buff)(aTHX_ (rx), NULL, NULL, RXapif_REGNAMES_COUNT)
d288 1
a288 1
    CALL_FPTR(RX_ENGINE(rx)->named_buff)(aTHX_ (rx), NULL, NULL, flags)
d291 1
a291 1
    CALL_FPTR(RX_ENGINE(rx)->qr_package)(aTHX_ (rx))
d298 1
a298 1
    (prog ? CALL_FPTR(RX_ENGINE(prog)->dupe)(aTHX_ (prog),(param)) \
d357 6
a362 5
#if !defined(HASATTRIBUTE_UNUSED) && defined(__cplusplus)
#define dNOOP /*EMPTY*/(void)0 /* Older g++ has no __attribute((unused))__ */
#else
#define dNOOP extern int /*@@unused@@*/ Perl___notused PERL_UNUSED_DECL
#endif
a493 3
#define WITH_THX(s) STMT_START { dTHX; s; } STMT_END
#define WITH_THR(s) WITH_THX(s)

d542 9
d601 1
a601 1
/* HP-UX 10.X CMA (Common Multithreaded Architecure) insists that
a976 11
/* Cannot include embed.h here on Win32 as win32.h has not
   yet been included and defines some config variables e.g. HAVE_INTERP_INTERN
 */
#if !defined(PERL_FOR_X2P) && !(defined(WIN32)||defined(VMS))
#  include "embed.h"
#  ifndef PERL_MAD
#    undef op_getmad
#    define op_getmad(arg,pegop,slot) NOOP
#  endif
#endif

d986 8
d1232 1
a1232 1
#if defined(HAS_SOCKET) && !defined(VMS) && !defined(WIN32) /* VMS/WIN32 handle sockets via vmsish.h/win32.h */
d1358 9
d1369 2
a1371 2
#define DEFSV_set(sv) (GvSV(PL_defgv) = (sv))
#define SAVE_DEFSV SAVESPTR(GvSV(PL_defgv))
d2234 1
a2234 1
 * despite doing above, because math.h might have overriden... XXX - Allen */
a2394 4
#ifdef MYMALLOC
#  include "malloc_ctl.h"
#endif

d2417 3
a2432 1
typedef struct regexp ORANGE;	/* This is the body structure.  */
a2581 5
#   include "embed.h"
#  ifndef PERL_MAD
#    undef op_getmad
#    define op_getmad(arg,pegop,slot) NOOP
#  endif
a2610 5
#   include "embed.h"
#  ifndef PERL_MAD
#    undef op_getmad
#    define op_getmad(arg,pegop,slot) NOOP
#  endif
d2767 1
a2767 5
#    ifdef _POSIX_PATH_MAX
#       define MAXPATHLEN _POSIX_PATH_MAX
#    else
#       define MAXPATHLEN 1024	/* Err on the large side. */
#    endif
a3113 4
#ifndef MEMBER_TO_FPTR
#  define MEMBER_TO_FPTR(name)		name
#endif

d3170 1
a3170 1
    See comments in sv.c for futher details.
d3195 12
d3208 1
a3208 1
/* not used; but needed for backward compatibilty with XS code? - RMB */
d3217 1
a3217 1
/* not used; but needed for backward compatibilty with XS code? - RMB */
a3224 8
#if !defined(PERL_CORE) && !defined(PERL_NO_SHORT_NAMES)
#  if defined(PERL_IMPLICIT_CONTEXT)
#    define pmflag(a,b)		Perl_pmflag(aTHX_ a,b)
#  else
#    define pmflag			Perl_pmflag
#  endif
#endif

d3352 1
d3453 4
a3477 3
/* Keep next first in this structure, because sv_free_arenas take
   advantage of this to share code between the pte arenas and the SV
   body arenas  */
d3488 3
d3704 1
d3735 1
d3773 1
d3813 1
d3843 1
d3848 4
a3851 58
    DEBUG_l(WITH_THR(Perl_deb(aTHX_ "%s scope %ld at %s:%d\n",	\
		    where, (long)PL_scopestack_ix, __FILE__, __LINE__)));




/* These constants should be used in preference to raw characters
 * when using magic. Note that some perl guts still assume
 * certain character properties of these constants, namely that
 * isUPPER() and toLOWER() may do useful mappings.
 *
 * Update the magic_names table in dump.c when adding/amending these
 */

#define PERL_MAGIC_sv		  '\0' /* Special scalar variable */
#define PERL_MAGIC_overload	  'A' /* %OVERLOAD hash */
#define PERL_MAGIC_overload_elem  'a' /* %OVERLOAD hash element */
#define PERL_MAGIC_overload_table 'c' /* Holds overload table (AMT) on stash */
#define PERL_MAGIC_bm		  'B' /* Boyer-Moore (fast string search) */
#define PERL_MAGIC_regdata	  'D' /* Regex match position data
					(@@+ and @@- vars) */
#define PERL_MAGIC_regdatum	  'd' /* Regex match position data element */
#define PERL_MAGIC_env		  'E' /* %ENV hash */
#define PERL_MAGIC_envelem	  'e' /* %ENV hash element */
#define PERL_MAGIC_fm		  'f' /* Formline ('compiled' format) */
#define PERL_MAGIC_regex_global	  'g' /* m//g target / study()ed string */
#define PERL_MAGIC_hints	  'H' /* %^H hash */
#define PERL_MAGIC_hintselem	  'h' /* %^H hash element */
#define PERL_MAGIC_isa		  'I' /* @@ISA array */
#define PERL_MAGIC_isaelem	  'i' /* @@ISA array element */
#define PERL_MAGIC_nkeys	  'k' /* scalar(keys()) lvalue */
#define PERL_MAGIC_dbfile	  'L' /* Debugger %_<filename */
#define PERL_MAGIC_dbline	  'l' /* Debugger %_<filename element */
#define PERL_MAGIC_shared	  'N' /* Shared between threads */
#define PERL_MAGIC_shared_scalar  'n' /* Shared between threads */
#define PERL_MAGIC_collxfrm	  'o' /* Locale transformation */
#define PERL_MAGIC_tied		  'P' /* Tied array or hash */
#define PERL_MAGIC_tiedelem	  'p' /* Tied array or hash element */
#define PERL_MAGIC_tiedscalar	  'q' /* Tied scalar or handle */
#define PERL_MAGIC_qr		  'r' /* precompiled qr// regex */
#define PERL_MAGIC_sig		  'S' /* %SIG hash */
#define PERL_MAGIC_sigelem	  's' /* %SIG hash element */
#define PERL_MAGIC_taint	  't' /* Taintedness */
#define PERL_MAGIC_uvar		  'U' /* Available for use by extensions */
#define PERL_MAGIC_uvar_elem	  'u' /* Reserved for use by extensions */
#define PERL_MAGIC_vec		  'v' /* vec() lvalue */
#define PERL_MAGIC_vstring	  'V' /* SV was vstring literal */
#define PERL_MAGIC_utf8		  'w' /* Cached UTF-8 information */
#define PERL_MAGIC_substr	  'x' /* substr() lvalue */
#define PERL_MAGIC_defelem	  'y' /* Shadow "foreach" iterator variable /
					smart parameter vivification */
#define PERL_MAGIC_arylen	  '#' /* Array length ($#ary) */
#define PERL_MAGIC_pos		  '.' /* pos() lvalue */
#define PERL_MAGIC_backref	  '<' /* for weak ref data */
#define PERL_MAGIC_symtab	  ':' /* extra data for symbol tables */
#define PERL_MAGIC_rhash	  '%' /* extra data for restricted hashes */
#define PERL_MAGIC_arylen_p	  '@@' /* to move arylen out of XPVAV */
#define PERL_MAGIC_ext		  '~' /* Available for use by extensions */
d4165 6
a4170 8
typedef int (CPERLscope(*runops_proc_t)) (pTHX);
typedef void (CPERLscope(*share_proc_t)) (pTHX_ SV *sv);
typedef int  (CPERLscope(*thrhook_proc_t)) (pTHX);
typedef OP* (CPERLscope(*PPADDR_t)[]) (pTHX);
typedef bool (CPERLscope(*destroyable_proc_t)) (pTHX_ SV *sv);

/* _ (for $_) must be first in the following list (DEFSV requires it) */
#define THREADSV_NAMES "_123456789&`'+/.,\\\";^-%=|~:\001\005!@@"
d4197 12
d4214 2
d4255 13
d4274 11
d4290 5
a4294 1
#include "uudmap.h"
d4297 5
a4301 1
#  include "bitcount.h"
d4312 3
a4314 1
/* fast conversion and case folding tables */
d4317 5
a4321 36
#ifdef EBCDIC
EXTCONST unsigned char PL_fold[] = { /* fast EBCDIC case folding table */
    0,      1,      2,      3,      4,      5,      6,      7,
    8,      9,      10,     11,     12,     13,     14,     15,
    16,     17,     18,     19,     20,     21,     22,     23,
    24,     25,     26,     27,     28,     29,     30,     31,
    32,     33,     34,     35,     36,     37,     38,     39,
    40,     41,     42,     43,     44,     45,     46,     47,
    48,     49,     50,     51,     52,     53,     54,     55,
    56,     57,     58,     59,     60,     61,     62,     63,
    64,     65,     66,     67,     68,     69,     70,     71,
    72,     73,     74,     75,     76,     77,     78,     79,
    80,     81,     82,     83,     84,     85,     86,     87,
    88,     89,     90,     91,     92,     93,     94,     95,
    96,     97,     98,     99,     100,    101,    102,    103,
    104,    105,    106,    107,    108,    109,    110,    111,
    112,    113,    114,    115,    116,    117,    118,    119,
    120,    121,    122,    123,    124,    125,    126,    127,
    128,    'A',    'B',    'C',    'D',    'E',    'F',    'G',
    'H',    'I',    138,    139,    140,    141,    142,    143,
    144,    'J',    'K',    'L',    'M',    'N',    'O',    'P',
    'Q',    'R',    154,    155,    156,    157,    158,    159,
    160,    161,    'S',    'T',    'U',    'V',    'W',    'X',
    'Y',    'Z',    170,    171,    172,    173,    174,    175,
    176,    177,    178,    179,    180,    181,    182,    183,
    184,    185,    186,    187,    188,    189,    190,    191,
    192,    'a',    'b',    'c',    'd',    'e',    'f',    'g',
    'h',    'i',    202,    203,    204,    205,    206,    207,
    208,    'j',    'k',    'l',    'm',    'n',    'o',    'p',
    'q',    'r',    218,    219,    220,    221,    222,    223,
    224,    225,    's',    't',    'u',    'v',    'w',    'x',
    'y',    'z',    234,    235,    236,    237,    238,    239,
    240,    241,    242,    243,    244,    245,    246,    247,
    248,    249,    250,    251,    252,    253,    254,    255
};
#else   /* ascii rather than ebcdic */
d4356 43
d4476 1
d4635 9
d4650 3
d4668 3
a4691 3
#  ifdef THREADS_HAVE_PIDS
			     " THREADS_HAVE_PIDS"
#  endif
d4707 6
d4730 3
a4732 3
#    ifdef DECCRTL_SOCKETS
			     " DECCRTL_SOCKETS"
#    endif
d4742 39
a4812 38
enum {		/* pass one of these to get_vtbl */
    want_vtbl_sv,
    want_vtbl_env,
    want_vtbl_envelem,
    want_vtbl_sig,
    want_vtbl_sigelem,
    want_vtbl_pack,
    want_vtbl_packelem,
    want_vtbl_dbline,
    want_vtbl_isa,
    want_vtbl_isaelem,
    want_vtbl_arylen,
    want_vtbl_glob,
    want_vtbl_mglob,
    want_vtbl_nkeys,
    want_vtbl_taint,
    want_vtbl_substr,
    want_vtbl_vec,
    want_vtbl_pos,
    want_vtbl_bm,
    want_vtbl_fm,
    want_vtbl_uvar,
    want_vtbl_defelem,
    want_vtbl_regexp,
    want_vtbl_collxfrm,
    want_vtbl_amagic,
    want_vtbl_amagicelem,
    want_vtbl_regdata,
    want_vtbl_regdatum,
    want_vtbl_backref,
    want_vtbl_utf8,
    want_vtbl_symtab,
    want_vtbl_arylen_p,
    want_vtbl_hintselem,
    want_vtbl_hints
};


d4820 5
a4824 3
#define HINT_ARYBASE		0x00000010 /* $[ is non-zero */
				/* Note: 20,40,80 used for NATIVE_HINTS */
				/* currently defined by vms/vmsish.h */
d4849 10
d4885 3
a4887 3
typedef void (CPERLscope(*peep_t))(pTHX_ OP* o);
typedef regexp*(CPERLscope(*regcomp_t)) (pTHX_ char* exp, char* xend, PMOP* pm);
typedef I32 (CPERLscope(*regexec_t)) (pTHX_ regexp* prog, char* stringarg,
d4890 1
a4890 1
typedef char* (CPERLscope(*re_intuit_start_t)) (pTHX_ regexp *prog, SV *sv,
d4894 4
a4897 3
typedef SV*	(CPERLscope(*re_intuit_string_t)) (pTHX_ regexp *prog);
typedef void	(CPERLscope(*regfree_t)) (pTHX_ struct regexp* r);
typedef regexp*(CPERLscope(*regdupe_t)) (pTHX_ const regexp* r, CLONE_PARAMS *param);
d4907 7
a4913 11
/* Set up PERLVAR macros for populating structs */
#define PERLVAR(var,type) type var;
#define PERLVARA(var,n,type) type var[n];
#define PERLVARI(var,type,init) type var;
#define PERLVARIC(var,type,init) type var;
#define PERLVARISC(var,init) const char var[sizeof(init)];

typedef OP* (CPERLscope(*Perl_ppaddr_t))(pTHX);
typedef OP* (CPERLscope(*Perl_check_t)) (pTHX_ OP*);
typedef void(CPERLscope(*Perl_ophook_t))(pTHX_ OP*);
typedef int (CPERLscope(*Perl_keyword_plugin_t))(pTHX_ char*, STRLEN, OP**);
d4935 1
a4935 3
#define PERL_PATCHLEVEL_H_IMPLICIT
#include "patchlevel.h"
#undef PERL_PATCHLEVEL_H_IMPLICIT
d4937 2
a4938 7
#define PERL_VERSION_STRING	STRINGIFY(PERL_REVISION) "." \
				STRINGIFY(PERL_VERSION) "." \
				STRINGIFY(PERL_SUBVERSION)

#ifdef PERL_GLOBAL_STRUCT
struct perl_vars {
#  include "perlvars.h"
d4941 1
a4941 16
#  ifdef PERL_CORE
#    ifndef PERL_GLOBAL_STRUCT_PRIVATE
EXT struct perl_vars PL_Vars;
EXT struct perl_vars *PL_VarsPtr INIT(&PL_Vars);
#      undef PERL_GET_VARS
#      define PERL_GET_VARS() PL_VarsPtr
#    endif /* !PERL_GLOBAL_STRUCT_PRIVATE */
#  else /* PERL_CORE */
#    if !defined(__GNUC__) || !defined(WIN32)
EXT
#    endif /* WIN32 */
struct perl_vars *PL_VarsPtr;
#    define PL_Vars (*((PL_VarsPtr) \
		       ? PL_VarsPtr : (PL_VarsPtr = Perl_GetVars(aTHX))))
#  endif /* PERL_CORE */
#endif /* PERL_GLOBAL_STRUCT */
a4942 1
#if defined(MULTIPLICITY)
d4949 6
d4959 20
a4978 3
#else
struct interpreter {
    char broiled;
d4980 20
a4999 1
#endif /* MULTIPLICITY */
d5002 6
a5007 5
#undef PERLVAR
#undef PERLVARA
#undef PERLVARI
#undef PERLVARIC
#undef PERLVARISC
d5026 4
d5052 4
a5055 5
#define PERLVAR(var,type) EXT type PL_##var;
#define PERLVARA(var,n,type) EXT type PL_##var[n];
#define PERLVARI(var,type,init) EXT type  PL_##var INIT(init);
#define PERLVARIC(var,type,init) EXTCONST type PL_##var INIT(init);
#define PERLVARISC(var,init) EXTCONST char PL_##var[sizeof(init)] INIT(init);
d5068 7
a5074 7
#if defined(WIN32)
/* Now all the config stuff is setup we can include embed.h */
#  include "embed.h"
#  ifndef PERL_MAD
#    undef op_getmad
#    define op_getmad(arg,pegop,slot) NOOP
#  endif
d5092 8
d5109 10
d5120 9
a5128 7
#  define MGVTBL_SET(var,a,b,c,d,e,f,g,h) EXT_MGVTBL var = {a,b,c,d,e,f,g,h}
/* Like MGVTBL_SET but with the get magic having a const MG* */
#  define MGVTBL_SET_CONST_MAGIC_GET(var,a,b,c,d,e,f,g,h) EXT_MGVTBL var \
    = {(int (*)(pTHX_ SV *, MAGIC *))a,b,c,d,e,f,g,h}
#else
#  define MGVTBL_SET(var,a,b,c,d,e,f,g,h) EXT_MGVTBL var
#  define MGVTBL_SET_CONST_MAGIC_GET(var,a,b,c,d,e,f,g,h) EXT_MGVTBL var
d5131 25
a5155 52
/* These all need to be 0, not NULL, as NULL can be (void*)0, which is a
 * pointer to data, whereas we're assigning pointers to functions, which are
 * not the same beast. ANSI doesn't allow the assignment from one to the other.
 * (although most, but not all, compilers are prepared to do it)
 */
MGVTBL_SET(
    PL_vtbl_sv,
    MEMBER_TO_FPTR(Perl_magic_get),
    MEMBER_TO_FPTR(Perl_magic_set),
    MEMBER_TO_FPTR(Perl_magic_len),
    0,
    0,
    0,
    0,
    0
);

MGVTBL_SET(
    PL_vtbl_env,
    0,
    MEMBER_TO_FPTR(Perl_magic_set_all_env),
    0,
    MEMBER_TO_FPTR(Perl_magic_clear_all_env),
    0,
    0,
    0,
    0
);

MGVTBL_SET(
    PL_vtbl_envelem,
    0,
    MEMBER_TO_FPTR(Perl_magic_setenv),
    0,
    MEMBER_TO_FPTR(Perl_magic_clearenv),
    0,
    0,
    0,
    0
);

MGVTBL_SET(
    PL_vtbl_sig,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
);
a5156 363
#ifdef PERL_MICRO
MGVTBL_SET(
    PL_vtbl_sigelem,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
);

#else
MGVTBL_SET(
    PL_vtbl_sigelem,
    MEMBER_TO_FPTR(Perl_magic_getsig),
    MEMBER_TO_FPTR(Perl_magic_setsig),
    0,
    MEMBER_TO_FPTR(Perl_magic_clearsig),
    0,
    0,
    0,
    0
);
#endif

MGVTBL_SET(
    PL_vtbl_pack,
    0,
    0,
    MEMBER_TO_FPTR(Perl_magic_sizepack),
    MEMBER_TO_FPTR(Perl_magic_wipepack),
    0,
    0,
    0,
    0
);

MGVTBL_SET(
    PL_vtbl_packelem,
    MEMBER_TO_FPTR(Perl_magic_getpack),
    MEMBER_TO_FPTR(Perl_magic_setpack),
    0,
    MEMBER_TO_FPTR(Perl_magic_clearpack),
    0,
    0,
    0,
    0
);

MGVTBL_SET(
    PL_vtbl_dbline,
    0,
    MEMBER_TO_FPTR(Perl_magic_setdbline),
    0,
    0,
    0,
    0,
    0,
    0
);

MGVTBL_SET(
    PL_vtbl_isa,
    0,
    MEMBER_TO_FPTR(Perl_magic_setisa),
    0,
    MEMBER_TO_FPTR(Perl_magic_clearisa),
    0,
    0,
    0,
    0
);

MGVTBL_SET(
    PL_vtbl_isaelem,
    0,
    MEMBER_TO_FPTR(Perl_magic_setisa),
    0,
    0,
    0,
    0,
    0,
    0
);

MGVTBL_SET_CONST_MAGIC_GET(
    PL_vtbl_arylen,
    MEMBER_TO_FPTR(Perl_magic_getarylen),
    MEMBER_TO_FPTR(Perl_magic_setarylen),
    0,
    0,
    0,
    0,
    0,
    0
);

MGVTBL_SET(
    PL_vtbl_arylen_p,
    0,
    0,
    0,
    0,
    MEMBER_TO_FPTR(Perl_magic_freearylen_p),
    0,
    0,
    0
);

MGVTBL_SET(
    PL_vtbl_mglob,
    0,
    MEMBER_TO_FPTR(Perl_magic_setmglob),
    0,
    0,
    0,
    0,
    0,
    0
);

MGVTBL_SET(
    PL_vtbl_nkeys,
    MEMBER_TO_FPTR(Perl_magic_getnkeys),
    MEMBER_TO_FPTR(Perl_magic_setnkeys),
    0,
    0,
    0,
    0,
    0,
    0
);

MGVTBL_SET(
    PL_vtbl_taint,
    MEMBER_TO_FPTR(Perl_magic_gettaint),
    MEMBER_TO_FPTR(Perl_magic_settaint),
    0,
    0,
    0,
    0,
    0,
    0
);

MGVTBL_SET(
    PL_vtbl_substr,
    MEMBER_TO_FPTR(Perl_magic_getsubstr),
    MEMBER_TO_FPTR(Perl_magic_setsubstr),
    0,
    0,
    0,
    0,
    0,
    0
);

MGVTBL_SET(
    PL_vtbl_vec,
    MEMBER_TO_FPTR(Perl_magic_getvec),
    MEMBER_TO_FPTR(Perl_magic_setvec),
    0,
    0,
    0,
    0,
    0,
    0
);

MGVTBL_SET(
    PL_vtbl_pos,
    MEMBER_TO_FPTR(Perl_magic_getpos),
    MEMBER_TO_FPTR(Perl_magic_setpos),
    0,
    0,
    0,
    0,
    0,
    0
);

MGVTBL_SET(
    PL_vtbl_bm,
    0,
    MEMBER_TO_FPTR(Perl_magic_setregexp),
    0,
    0,
    0,
    0,
    0,
    0
);

MGVTBL_SET(
    PL_vtbl_fm,
    0,
    MEMBER_TO_FPTR(Perl_magic_setregexp),
    0,
    0,
    0,
    0,
    0,
    0
);

MGVTBL_SET(
    PL_vtbl_uvar,
    MEMBER_TO_FPTR(Perl_magic_getuvar),
    MEMBER_TO_FPTR(Perl_magic_setuvar),
    0,
    0,
    0,
    0,
    0,
    0
);

MGVTBL_SET(
    PL_vtbl_defelem,
    MEMBER_TO_FPTR(Perl_magic_getdefelem),
    MEMBER_TO_FPTR(Perl_magic_setdefelem),
    0,
    0,
    0,
    0,
    0,
    0
);

MGVTBL_SET(
    PL_vtbl_regexp,
    0,
    MEMBER_TO_FPTR(Perl_magic_setregexp),
    0,
    0,
    0,
    0,
    0,
    0
);

MGVTBL_SET(
    PL_vtbl_regdata,
    0,
    0,
    MEMBER_TO_FPTR(Perl_magic_regdata_cnt),
    0,
    0,
    0,
    0,
    0
);

MGVTBL_SET(
    PL_vtbl_regdatum,
    MEMBER_TO_FPTR(Perl_magic_regdatum_get),
    MEMBER_TO_FPTR(Perl_magic_regdatum_set),
    0,
    0,
    0,
    0,
    0,
    0
);

MGVTBL_SET(
    PL_vtbl_amagic,
    0,
    MEMBER_TO_FPTR(Perl_magic_setamagic),
    0,
    0,
    MEMBER_TO_FPTR(Perl_magic_setamagic),
    0,
    0,
    0
);

MGVTBL_SET(
    PL_vtbl_amagicelem,
    0,
    MEMBER_TO_FPTR(Perl_magic_setamagic),
    0,
    0,
    MEMBER_TO_FPTR(Perl_magic_setamagic),
    0,
    0,
    0
);

MGVTBL_SET(
    PL_vtbl_backref,
    0,
    0,
    0,
    0,
    MEMBER_TO_FPTR(Perl_magic_killbackrefs),
    0,
    0,
    0
);

MGVTBL_SET(
    PL_vtbl_ovrld,
    0,
    0,
    0,
    0,
    MEMBER_TO_FPTR(Perl_magic_freeovrld),
    0,
    0,
    0
);

MGVTBL_SET(
    PL_vtbl_utf8,
    0,
    MEMBER_TO_FPTR(Perl_magic_setutf8),
    0,
    0,
    0,
    0,
    0,
    0
);
#ifdef USE_LOCALE_COLLATE
MGVTBL_SET(
    PL_vtbl_collxfrm,
    0,
    MEMBER_TO_FPTR(Perl_magic_setcollxfrm),
    0,
    0,
    0,
    0,
    0,
    0
);
#endif

MGVTBL_SET(
    PL_vtbl_hintselem,
    0,
    MEMBER_TO_FPTR(Perl_magic_sethint),
    0,
    MEMBER_TO_FPTR(Perl_magic_clearhint),
    0,
    0,
    0,
    0
);

MGVTBL_SET(
    PL_vtbl_hints,
    0,
    0,
    0,
    MEMBER_TO_FPTR(Perl_magic_clearhints),
    0,
    0,
    0,
    0
);
d5163 3
a5165 1
  U32 flags;
a5167 1
  long fallback;
d5171 3
a5173 1
  U32 flags;
d5244 1
a5244 1
#define PERLDBf_SAVESRC_NOSUBS	0x800	/* Including evals that generate no subrouties */
d5269 2
d5272 5
d5278 2
d5283 3
d5314 1
d5414 1
a5414 1
#		define PERL_ASYNC_CHECK() if (PL_sig_pending) despatch_signals()
d5488 1
a5488 3
#ifdef PERL_GLOBAL_STRUCT_PRIVATE

/* This must appear in all extensions that define a my_cxt_t structure,
d5491 9
a5499 2
#define START_MY_CXT
#define MY_CXT_INDEX Perl_my_cxt_index(aTHX_ MY_CXT_KEY)
d5504 1
a5504 1
#define MY_CXT_INIT \
d5506 3
a5508 2
	    (my_cxt_t*)Perl_my_cxt_init(aTHX_ MY_CXT_KEY, sizeof(my_cxt_t))
#define MY_CXT_INIT_INTERP(my_perl) \
d5510 2
a5511 1
	    (my_cxt_t*)Perl_my_cxt_init(my_perl, MY_CXT_KEY, sizeof(my_cxt_t))
d5515 1
a5515 1
#define dMY_CXT	\
d5517 1
a5517 1
#define dMY_CXT_INTERP(my_perl)	\
d5521 1
a5521 1
#define MY_CXT_CLONE \
a5525 31
#else /* #ifdef PERL_GLOBAL_STRUCT_PRIVATE */

/* This must appear in all extensions that define a my_cxt_t structure,
 * right after the definition (i.e. at file scope).  The non-threads
 * case below uses it to declare the data as static. */
#define START_MY_CXT static int my_cxt_index = -1;

/* This declaration should be used within all functions that use the
 * interpreter-local data. */
#define dMY_CXT	\
	my_cxt_t *my_cxtp = (my_cxt_t *)PL_my_cxt_list[my_cxt_index]
#define dMY_CXT_INTERP(my_perl)	\
	my_cxt_t *my_cxtp = (my_cxt_t *)(my_perl)->Imy_cxt_list[my_cxt_index]

/* Creates and zeroes the per-interpreter data.
 * (We allocate my_cxtp in a Perl SV so that it will be released when
 * the interpreter goes away.) */
#define MY_CXT_INIT \
	my_cxt_t *my_cxtp = \
	    (my_cxt_t*)Perl_my_cxt_init(aTHX_ &my_cxt_index, sizeof(my_cxt_t))
#define MY_CXT_INIT_INTERP(my_perl) \
	my_cxt_t *my_cxtp = \
	    (my_cxt_t*)Perl_my_cxt_init(my_perl, &my_cxt_index, sizeof(my_cxt_t))

/* Clones the per-interpreter data. */
#define MY_CXT_CLONE \
	my_cxt_t *my_cxtp = (my_cxt_t*)SvPVX(newSV(sizeof(my_cxt_t)-1));\
	Copy(PL_my_cxt_list[my_cxt_index], my_cxtp, 1, my_cxt_t);\
	PL_my_cxt_list[my_cxt_index] = my_cxtp				\

#endif /* #ifdef PERL_GLOBAL_STRUCT_PRIVATE */
d5528 2
a5529 2
 * e.g. MYCXT.some_data */
#define MY_CXT		(*my_cxtp)
d5533 6
a5538 6
#define pMY_CXT		my_cxt_t *my_cxtp
#define pMY_CXT_	pMY_CXT,
#define _pMY_CXT	,pMY_CXT
#define aMY_CXT		my_cxtp
#define aMY_CXT_	aMY_CXT,
#define _aMY_CXT	,aMY_CXT
d5542 14
a5555 14
#define START_MY_CXT	static my_cxt_t my_cxt;
#define dMY_CXT_SV	dNOOP
#define dMY_CXT		dNOOP
#define dMY_CXT_INTERP(my_perl)	dNOOP
#define MY_CXT_INIT	NOOP
#define MY_CXT_CLONE	NOOP
#define MY_CXT		my_cxt

#define pMY_CXT		void
#define pMY_CXT_
#define _pMY_CXT
#define aMY_CXT
#define aMY_CXT_
#define _aMY_CXT
d5632 2
a5722 30
/* From sigaction(2) (FreeBSD man page):
 * | Signal routines normally execute with the signal that
 * | caused their invocation blocked, but other signals may
 * | yet occur.
 * Emulation of this behavior (from within Perl) is enabled
 * by defining PERL_BLOCK_SIGNALS.
 */
#define PERL_BLOCK_SIGNALS

#if defined(HAS_SIGPROCMASK) && defined(PERL_BLOCK_SIGNALS)
#   define PERL_BLOCKSIG_ADD(set,sig) \
	sigset_t set; sigemptyset(&(set)); sigaddset(&(set), sig)
#   define PERL_BLOCKSIG_BLOCK(set) \
	sigprocmask(SIG_BLOCK, &(set), NULL)
#   define PERL_BLOCKSIG_UNBLOCK(set) \
	sigprocmask(SIG_UNBLOCK, &(set), NULL)
#endif /* HAS_SIGPROCMASK && PERL_BLOCK_SIGNALS */

/* How about the old style of sigblock()? */

#ifndef PERL_BLOCKSIG_ADD
#   define PERL_BLOCKSIG_ADD(set, sig)	NOOP
#endif
#ifndef PERL_BLOCKSIG_BLOCK
#   define PERL_BLOCKSIG_BLOCK(set)	NOOP
#endif
#ifndef PERL_BLOCKSIG_UNBLOCK
#   define PERL_BLOCKSIG_UNBLOCK(set)	NOOP
#endif

d5763 1
d5774 1
a5774 1
#define PERL_PV_PRETTY_REGPROP PERL_PV_PRETTY_ELLIPSES|PERL_PV_PRETTY_LTGT|PERL_PV_ESCAPE_RE
@


1.15
log
@Merge in perl 5.10.1
@
text
@d31 1
a31 1
#endif 
a43 18
/* This logic needs to come after reading config.h, but before including
   proto.h  */
#ifdef IAMSUID
#  ifndef DOSUID
#    define DOSUID
#  endif
#endif

#ifdef SETUID_SCRIPTS_ARE_SECURE_NOW
#  ifdef DOSUID
#    undef DOSUID
#  endif
#  ifdef IAMSUID
#    undef IAMSUID
#    define SETUID_SCRIPTS_ARE_SECURE_NOW_AND_IAMSUID
#  endif
#endif

a224 4
#define CALLREG_AS_STR(mg,lp,flags,haseval) \
        Perl_reg_stringify(aTHX_ (mg), (lp), (flags), (haseval))
#define CALLREG_STRINGIFY(mg,lp,flags) CALLREG_AS_STR(mg,lp,flags,0)

d273 1
a273 1
#if defined(USE_ITHREADS)         
d279 1
a279 1
          : (REGEXP *)NULL) 
d313 1
a313 1
 
d946 1
a946 1
#if !defined(OS2) && !defined(WIN32) && !defined(DJGPP) && !defined(EPOC) && !defined(__SYMBIAN32__) && !defined(MACOS_TRADITIONAL)
d950 1
a950 1
/* Cannot include embed.h here on Win32 as win32.h has not 
d1030 1
d1147 7
d1201 1
a1201 1
 * This is important for using IPv6. 
d1313 19
a1331 1
#define ERRSV GvSV(PL_errgv)
d2401 2
a2402 1
typedef struct regexp REGEXP;
d2531 1
a2531 1
#if defined(OS2) || defined(MACOS_TRADITIONAL)
a2592 7
#if defined(MACOS_TRADITIONAL)
#   include "macos/macish.h"
#   ifndef NO_ENVIRON_ARRAY
#       define NO_ENVIRON_ARRAY
#   endif
#   define ISHISH "macos classic"
#endif
d2801 1
a2801 1
#endif /* #ifndef PERL_MICRO */ 
d2892 1
a2892 1
   Perl tries to translate it to text in some of the tests.  
d3152 1
a3152 1
/* 
d3155 2
a3156 2
    use "%-p" or "%-<number>p" or "%<number>p" formats.  
    These formats will still work in perl code.   
d3161 1
a3161 1
    No longer use %1p for VDf = %vd.  RMB 2007-10-19 
d3183 1
a3183 1
/* not used; but needed for backward compatibilty with XS code? - RMB */ 
d3192 1
a3192 1
/* not used; but needed for backward compatibilty with XS code? - RMB */ 
d3200 8
d3272 1
a3272 1
#  define __attribute__format__null_ok__(x,y,z)  
d3370 1
a3370 1
#if !defined(OS2) && !defined(MACOS_TRADITIONAL)
d3375 1
a3375 1
#undef HAS_PASSWD  /* unixish.h but not unixish enough. */ 
d3418 1
a3419 1
#include "sv.h"
d3435 4
d3639 1
a3639 1
#define DEBUG_S_FLAG		0x00010000 /*  65536 */
d3647 3
a3649 1
#define DEBUG_MASK		0x00FFEFFF /* mask of all the standard flags */
a3670 1
#  define DEBUG_S_TEST_ (PL_debug & DEBUG_S_FLAG)
d3678 2
a3700 1
#  define DEBUG_S_TEST DEBUG_S_TEST_
d3708 2
a3749 2
#  define DEBUG_S(a)

d3756 2
a3776 1
#  define DEBUG_S_TEST (0)
d3784 2
a3806 1
#  define DEBUG_S(a)
d3813 2
d3880 6
d3887 1
a3887 2
#ifndef assert  /* <assert.h> might have been included somehow */
#define assert(what)	PERL_DEB( 					\
d3892 3
d4239 3
a4241 1
EXTCONST char PL_no_symref[]
d4243 1
a4243 1
EXTCONST char PL_no_symref_sv[]
d4283 3
d4290 1
d4368 76
a4443 2
#endif  /* !EBCDIC */
#else
d4445 2
d4570 7
d4578 1
d4580 1
a4580 6
	"LOOP",
	"SUBST",
	"BLOCK",
	"FORMAT",
	"GIVEN",
	"WHEN"
d4757 2
a4758 1
    want_vtbl_hintselem
d4776 1
d4837 2
a4838 2
typedef void (*SVFUNC_t) (pTHX_ SV*);
typedef I32  (*SVCOMPARE_t) (pTHX_ SV*, SV*);
d4852 6
d4980 5
a5068 1
/* For now, hints magic will also use vtbl_sig, because it is all 0  */
d5318 1
a5318 1
    MEMBER_TO_FPTR(Perl_magic_freeregexp),
d5433 12
d5515 1
a5515 1
					/* No _NONAME, _GOTO, _ASSERTION */
a5528 1
#if 0 /* Not yet working. */
a5529 1
#endif
a5540 1
#define PERLDB_ASSERTION (PL_perldb && (PL_perldb & PERLDBf_ASSERTION))
a5542 1
#if 0 /* Not yet working. */
a5543 1
#endif
a5903 58
#ifdef IAMSUID

#ifdef I_SYS_STATVFS
#   if defined(PERL_SCO) && !defined(_SVID3)
#       define _SVID3
#   endif
#   include <sys/statvfs.h>     /* for f?statvfs() */
#endif
#ifdef I_SYS_MOUNT
#   include <sys/mount.h>       /* for *BSD f?statfs() */
#endif
#ifdef I_MNTENT
#   include <mntent.h>          /* for getmntent() */
#endif
#ifdef I_SYS_STATFS
#   include <sys/statfs.h>      /* for some statfs() */
#endif
#ifdef I_SYS_VFS
#  ifdef __sgi
#    define sv IRIX_sv		/* kludge: IRIX has an sv of its own */
#  endif
#    include <sys/vfs.h>	/* for some statfs() */
#  ifdef __sgi
#    undef IRIX_sv
#  endif
#endif
#ifdef I_USTAT
#   include <ustat.h>           /* for ustat() */
#endif

#if !defined(PERL_MOUNT_NOSUID) && defined(MOUNT_NOSUID)
#    define PERL_MOUNT_NOSUID MOUNT_NOSUID
#endif
#if !defined(PERL_MOUNT_NOSUID) && defined(MNT_NOSUID)
#    define PERL_MOUNT_NOSUID MNT_NOSUID
#endif
#if !defined(PERL_MOUNT_NOSUID) && defined(MS_NOSUID)
#   define PERL_MOUNT_NOSUID MS_NOSUID
#endif
#if !defined(PERL_MOUNT_NOSUID) && defined(M_NOSUID)
#   define PERL_MOUNT_NOSUID M_NOSUID
#endif

#if !defined(PERL_MOUNT_NOEXEC) && defined(MOUNT_NOEXEC)
#    define PERL_MOUNT_NOEXEC MOUNT_NOEXEC
#endif
#if !defined(PERL_MOUNT_NOEXEC) && defined(MNT_NOEXEC)
#    define PERL_MOUNT_NOEXEC MNT_NOEXEC
#endif
#if !defined(PERL_MOUNT_NOEXEC) && defined(MS_NOEXEC)
#   define PERL_MOUNT_NOEXEC MS_NOEXEC
#endif
#if !defined(PERL_MOUNT_NOEXEC) && defined(M_NOEXEC)
#   define PERL_MOUNT_NOEXEC M_NOEXEC
#endif

#endif /* IAMSUID */

d6069 2
a6070 2
/* These are used by Perl_pv_escape() and Perl_pv_pretty() 
 * are here so that they are available throughout the core 
d6084 1
a6084 1
#define PERL_PV_ESCAPE_UNI          0x0100     
a6148 2

#define CLEAR_ERRSV() STMT_START { sv_setpvn(ERRSV,"",0); if (SvMAGICAL(ERRSV)) { mg_free(ERRSV); } SvPOK_only(ERRSV); } STMT_END
@


1.14
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d3 2
a4 2
 *    Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999,
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, by Larry Wall and others
d44 18
d148 13
d164 1
a164 1
       extern struct perl_vars* Perl_GetVarsPrivate();
d235 1
a235 1
    CALL_FPTR((prog)->engine->exec)(aTHX_ (prog),(stringarg),(strend), \
d238 1
a238 1
    CALL_FPTR((prog)->engine->intuit)(aTHX_ (prog), (sv), (strpos), \
d241 1
a241 1
    CALL_FPTR((prog)->engine->checkstr)(aTHX_ (prog))
d251 1
a251 1
    if(prog) CALL_FPTR((prog)->engine->free)(aTHX_ (prog))
d254 1
a254 1
    CALL_FPTR((rx)->engine->numbered_buff_FETCH)(aTHX_ (rx),(paren),(usesv))
d257 1
a257 1
    CALL_FPTR((rx)->engine->numbered_buff_STORE)(aTHX_ (rx),(paren),(value))
d260 1
a260 1
    CALL_FPTR((rx)->engine->numbered_buff_LENGTH)(aTHX_ (rx),(sv),(paren))
d263 1
a263 1
    CALL_FPTR((rx)->engine->named_buff)(aTHX_ (rx), (key), NULL, ((flags) | RXapif_FETCH))
d266 1
a266 1
    CALL_FPTR((rx)->engine->named_buff)(aTHX_ (rx), (key), (value), ((flags) | RXapif_STORE))
d269 1
a269 1
    CALL_FPTR((rx)->engine->named_buff)(aTHX_ (rx),(key), NULL, ((flags) | RXapif_DELETE))
d272 1
a272 1
    CALL_FPTR((rx)->engine->named_buff)(aTHX_ (rx), NULL, NULL, ((flags) | RXapif_CLEAR))
d275 1
a275 1
    CALL_FPTR((rx)->engine->named_buff)(aTHX_ (rx), (key), NULL, ((flags) | RXapif_EXISTS))
d278 1
a278 1
    CALL_FPTR((rx)->engine->named_buff_iter)(aTHX_ (rx), NULL, ((flags) | RXapif_FIRSTKEY))
d281 1
a281 1
    CALL_FPTR((rx)->engine->named_buff_iter)(aTHX_ (rx), (lastkey), ((flags) | RXapif_NEXTKEY))
d284 1
a284 1
    CALL_FPTR((rx)->engine->named_buff)(aTHX_ (rx), NULL, NULL, ((flags) | RXapif_SCALAR))
d287 1
a287 1
    CALL_FPTR((rx)->engine->named_buff)(aTHX_ (rx), NULL, NULL, RXapif_REGNAMES_COUNT)
d290 1
a290 1
    CALL_FPTR((rx)->engine->named_buff)(aTHX_ (rx), NULL, NULL, flags)
d293 1
a293 1
    CALL_FPTR((rx)->engine->qr_package)(aTHX_ (rx))
d300 1
a300 1
    (prog ? CALL_FPTR((prog)->engine->dupe)(aTHX_ (prog),(param)) \
a424 13
#undef START_EXTERN_C
#undef END_EXTERN_C
#undef EXTERN_C
#ifdef __cplusplus
#  define START_EXTERN_C extern "C" {
#  define END_EXTERN_C }
#  define EXTERN_C extern "C"
#else
#  define START_EXTERN_C
#  define END_EXTERN_C
#  define EXTERN_C extern
#endif

d455 6
a460 2
 * (insane errors ensue). */
#if defined(PERL_GCC_PEDANTIC) || (defined(__GNUC__) && defined(__cplusplus))
a534 3
#   ifdef __cplusplus
#	define VOL		/* to temporarily suppress warnings */
#   else
a535 1
#   endif
d684 5
d949 5
d1289 5
d1308 5
d1328 6
a1333 2
/* FIXME? Change the assignments to PL_defgv to instantiate GvSV?  */
#define DEFSV GvSVn(PL_defgv)
d1565 1
a1565 1
/* BeOS 5.0 seems to define S_IREAD and S_IWRITE in <posix/fcntl.h>
d1569 1
a1569 1
#if !defined(S_IREAD) && !defined(__BEOS__)
d1573 1
a1573 1
#if !defined(S_IWRITE) && !defined(__BEOS__)
d2596 4
a2599 1
#if defined(__BEOS__)
d2679 5
a2683 1
#    define PERL_FPU_INIT fpsetmask(0)
d2704 19
d2772 3
d2958 5
a2962 5
   * the NATIVE error status based on it.  It does not assume that
   * the UNIX/POSIX exit codes have any relationship to errno, except
   * that 0 indicates a success.  When in the default mode to comply
   * with the Perl VMS documentation, any other code sets the NATIVE
   * status to a failure code of SS$_ABORT.
d2976 22
a2997 22
	    if (evalue != -1) {				\
	      if (evalue <= 0xFF00) {			\
		if (evalue > 0xFF)			\
		  evalue = (evalue >> child_offset_bits) & 0xFF; \
		if (evalue == 0)			\
		  PL_statusvalue_vms == SS$_NORMAL;	\
		else					\
		  if (MY_POSIX_EXIT)			\
		    PL_statusvalue_vms =	\
		       (C_FAC_POSIX | (evalue << 3 ) | (evalue == 1)? \
		        (STS$K_ERROR | STS$M_INHIB_MSG) : 1); \
		  else					\
		    PL_statusvalue_vms = SS$_ABORT; \
	      } else { /* forgive them Perl, for they have sinned */ \
		if (evalue != EVMSERR) PL_statusvalue_vms = evalue; \
		else PL_statusvalue_vms = vaxc$errno;		\
	        /* And obviously used a VMS status value instead of UNIX */ \
	        PL_statusvalue = EVMSERR;				\
	      }							\
	    }							\
	    else PL_statusvalue_vms = SS$_ABORT;		\
	    set_vaxc_errno(PL_statusvalue_vms);			\
d3000 1
d3013 3
d3023 4
a3026 3
		PL_statusvalue_vms =			\
		  (C_FAC_POSIX | (evalue << 3 ) | (evalue == 1)? \
		   (STS$K_ERROR | STS$M_INHIB_MSG) : 1); \
d3103 1
d3106 9
a3114 2
#ifndef PERL_FS_VER_FMT
#  define PERL_FS_VER_FMT	"%d.%d.%d"
d3202 3
d3228 3
d3401 11
d4070 1
a4070 1
EXTERN_C void PerlIO_teardown();
d4125 2
d4139 28
d4683 2
d4762 4
d5028 1
a5028 1
    MEMBER_TO_FPTR(Perl_magic_setisa),
d5146 1
a5146 1
    MEMBER_TO_FPTR(Perl_magic_setbm),
d5158 1
a5158 1
    MEMBER_TO_FPTR(Perl_magic_setfm),
d5380 2
a5381 1
				 PERLDBf_NAMEEVAL| PERLDBf_NAMEANON )
d5394 5
d5411 5
d5712 1
d5761 4
a5764 3
#   if defined(__BEOS__) || defined(__VOS__) || defined(__CYGWIN__)
    /* BeOS has O_TEXT != O_BINARY but O_TEXT and O_BINARY have no effect;
     * BeOS is always UNIXoid (LF), not DOSish (CRLF). */
d5839 1
a5839 1
#define EXEC_ARGV_CAST(x) x
d6079 12
@


1.13
log
@gcc 3.3 doesn't support __attribute__((unused)) in C++ mode.  Patch
taken from the perl devel tree.  Required to build C++-based perl
extensions.  OK espie@@ (who had a slightly different patch).
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006 by Larry Wall and others
d37 5
a41 5
#   include "config.h"
#endif

#if defined(USE_ITHREADS) && defined(USE_5005THREADS)
#  include "error: USE_ITHREADS and USE_5005THREADS are incompatible"
d66 9
a74 3
#ifdef USE_5005THREADS
#  ifndef PERL_IMPLICIT_CONTEXT
#    define PERL_IMPLICIT_CONTEXT
d78 1
a78 1
#if defined(MULTIPLICITY)
d90 22
a111 1
/* Use the reentrant APIs like localtime_r and getpwent_r */
d130 22
d153 13
a165 6
#  ifdef USE_5005THREADS
struct perl_thread;
#    define pTHX	register struct perl_thread *thr PERL_UNUSED_DECL
#    define aTHX	thr
#    define dTHR	dNOOP /* only backward compatibility */
#    define dTHXa(a)	pTHX = (struct perl_thread*)a
d167 1
a167 6
#    ifndef MULTIPLICITY
#      define MULTIPLICITY
#    endif
#    define pTHX	register PerlInterpreter *my_perl PERL_UNUSED_DECL
#    define aTHX	my_perl
#    define dTHXa(a)	pTHX = (PerlInterpreter*)a
a168 1
#  define dTHX		pTHX = PERL_GET_THX
d180 5
a197 5
#define CALLREGCOMP CALL_FPTR(PL_regcompp)
#define CALLREGEXEC CALL_FPTR(PL_regexecp)
#define CALLREG_INTUIT_START CALL_FPTR(PL_regint_start)
#define CALLREG_INTUIT_STRING CALL_FPTR(PL_regint_string)
#define CALLREGFREE CALL_FPTR(PL_regfree)
d199 72
a270 2
#ifdef PERL_FLEXIBLE_EXCEPTIONS
#  define CALLPROTECT CALL_FPTR(PL_protect)
d273 17
a289 1
#if defined(SYMBIAN) && defined(__GNUC__)
d310 1
a310 1
#  ifdef lint
d355 4
d381 5
a385 1
#  define dTHXs		dTHX
d387 5
a391 1
#  define dTHXs		dNOOP
d413 5
a417 1
#  define PERL_EXPORT_C extern
d420 5
a424 1
#  define PERL_XS_EXPORT_C
d435 5
a439 2
#if defined(__STRICT_ANSI__) && defined(PERL_GCC_PEDANTIC)
#  if !defined(PERL_GCC_BRACE_GROUPS_FORBIDDEN)
d444 6
d458 1
a458 1
# if defined(__GNUC__) && !defined(PERL_GCC_BRACE_GROUPS_FORBIDDEN) && !defined(__cplusplus)
a475 10
/*
 * SOFT_CAST can be used for args to prototyped functions to retain some
 * type checking; it only casts if the compiler does not know prototypes.
 */
#if defined(CAN_PROTOTYPE) && defined(DEBUGGING_COMPILE)
#define SOFT_CAST(type)	
#else
#define SOFT_CAST(type)	(type)
#endif

d504 1
a504 1
#if defined(__STDC__) || defined(vax11c) || defined(_AIX) || defined(__stdc__) || defined(__cplusplus) || defined( EPOC) || defined(NETWARE)
d508 1
a508 1
#if defined(__cplusplus) || defined(WIN32) || defined(__sgi) || defined(__EMX__) || defined(__DGUX) || defined( EPOC) || defined(__QNX__) || defined(NETWARE) || defined(PERL_MICRO)
d526 1
a526 1
#define TAINT_PROPER(s)	if (PL_tainting) { taint_proper(Nullch, s); }
d581 1
a581 2
#if (defined(USE_5005THREADS) || defined(USE_ITHREADS)) \
    && defined(PTHREAD_H_FIRST) && defined(I_PTHREAD)
d666 4
d671 1
a671 1
int syscall(int, ...);
d675 6
a680 1
int usleep(unsigned int);
d928 16
d949 4
d971 6
a976 4
#if defined(I_STRING) || defined(__cplusplus)
#   include <string.h>
#else
#   include <strings.h>
a1200 4
#   ifdef USE_5005THREADS
#       define PERL_USE_THREADS /* store our value */
#       undef USE_5005THREADS
#   endif
a1201 7
#   ifdef USE_5005THREADS
#       undef USE_5005THREADS /* socks.h does this on its own */
#   endif
#   ifdef PERL_USE_THREADS
#       define USE_5005THREADS /* restore our value */
#       undef PERL_USE_THREADS
#   endif
d1231 20
d1289 1
a1289 5
#ifdef USE_5005THREADS
#  define ERRSV (thr->errsv)
#  define DEFSV THREADSV(0)
#  define SAVE_DEFSV save_threadsv(0)
#else
d1291 2
a1292 4
#  define ERRSV GvSV(PL_errgv)
#  define DEFSV GvSVn(PL_defgv)
#  define SAVE_DEFSV SAVESPTR(GvSV(PL_defgv))
#endif /* USE_5005THREADS */
d1555 62
a1781 6
#ifdef I_FLOAT
#include <float.h>
#endif
#ifndef HAS_DBL_DIG
#define DBL_DIG	15   /* A guess that works lots of places */
#endif
d2321 1
d2325 5
a2362 1
typedef struct xrv XRV;
d2505 4
d2536 10
d2564 58
d2634 1
a2634 1
#    define PERL_FPU_INIT fpsetmask(0);
d2637 1
a2637 1
#      define PERL_FPU_INIT       PL_sigfpe_saved = signal(SIGFPE, SIG_IGN);
d2651 2
a2652 2
#ifndef PERL_SYS_INIT3
#  define PERL_SYS_INIT3(argvp,argcp,envp) PERL_SYS_INIT(argvp,argcp)
d2655 4
d2702 1
d2732 1
d2775 1
a2775 1
#endif /* USE_5005THREADS || USE_ITHREADS */
d2785 1
d2788 47
a2834 3
#   define STATUS_NATIVE_EXPORT \
	(((I32)PL_statusvalue_vms == -1 ? 44 : PL_statusvalue_vms) | (VMSISH_HUSHED ? 0x10000000 : 0))
#   define STATUS_NATIVE_SET(n)						\
d2836 7
a2842 2
	    PL_statusvalue_vms = (n);					\
	    if ((I32)PL_statusvalue_vms == -1)				\
d2844 9
a2852 6
	    else if (PL_statusvalue_vms & STS$M_SUCCESS)		\
		PL_statusvalue = 0;					\
	    else if ((PL_statusvalue_vms & STS$M_SEVERITY) == 0)	\
		PL_statusvalue = 1 << 8;				\
	    else							\
		PL_statusvalue = (PL_statusvalue_vms & STS$M_SEVERITY) << 8;	\
d2854 1
a2854 1
#   define STATUS_POSIX	PL_statusvalue
d2856 1
a2856 1
#	define STATUS_CURRENT	(VMSISH_STATUS ? STATUS_NATIVE : STATUS_POSIX)
d2858 1
a2858 1
#	define STATUS_CURRENT	STATUS_POSIX
d2860 8
a2867 1
#   define STATUS_POSIX_SET(n)				\
d2869 2
a2870 1
	    PL_statusvalue = (n);				\
d2872 9
a2880 2
		PL_statusvalue &= 0xFFFF;			\
		PL_statusvalue_vms = PL_statusvalue ? 44 : 1;	\
d2882 2
a2883 1
	    else PL_statusvalue_vms = -1;			\
d2885 121
a3005 8
#   define STATUS_ALL_SUCCESS	(PL_statusvalue = 0, PL_statusvalue_vms = 1)
#   define STATUS_ALL_FAILURE	(PL_statusvalue = 1, PL_statusvalue_vms = 44)
#else
#   define STATUS_NATIVE	STATUS_POSIX
#   define STATUS_NATIVE_EXPORT	STATUS_POSIX
#   define STATUS_NATIVE_SET	STATUS_POSIX_SET
#   define STATUS_POSIX		PL_statusvalue
#   define STATUS_POSIX_SET(n)		\
d3011 6
a3016 3
#   define STATUS_CURRENT STATUS_POSIX
#   define STATUS_ALL_SUCCESS	(PL_statusvalue = 0)
#   define STATUS_ALL_FAILURE	(PL_statusvalue = 1)
a3063 3
#  ifdef USE_5005THREADS
#    define PERL_GET_THX		((struct perl_thread *)PERL_GET_CONTEXT)
#  else
a3066 1
#  endif
d3070 11
a3080 7
#ifndef SVf
#  ifdef CHECK_FORMAT
#    define SVf "-p"
#  else
#    define SVf "_"
#  endif
#endif
d3082 2
a3083 6
#ifndef SVf_precision
#  ifdef CHECK_FORMAT
#    define SVf_precision(n) "-" n "p"
#  else
#    define SVf_precision(n) "." n "_"
#  endif
d3086 2
a3087 6
#ifndef VDf
#  ifdef CHECK_FORMAT
#    define VDf "-1p"
#  else
#    define VDf "vd"
#  endif
d3091 1
a3091 1
#  define SVf32 SVf_precision("32")
d3095 1
a3095 5
#  define SVf256 SVf_precision("256")
#endif
 
#ifndef UVf
#  define UVf UVuf
d3098 8
a3105 3
#ifndef PERL_CORE
#  ifndef DieNull
#    define DieNull Perl_vdie(aTHX_ Nullch, Null(va_list *))
d3109 7
a3115 4
/* Because 5.8.x has to keep using %_ for SVf, which will make the format
 * checking code (quite correctly) bleat a lot.  */
#ifndef CHECK_FORMAT
#  undef HASATTRIBUTE_FORMAT
d3167 1
a3167 1
#  define NORETURN_FUNCTION_END /* NOT REACHED */
d3169 19
a3187 1
#  define NORETURN_FUNCTION_END /* NOT REACHED */ return 0
a3245 6
#ifdef USE_5005THREADS
#define ARGSproto struct perl_thread *thr
#else
#define ARGSproto
#endif /* USE_5005THREADS */

d3249 8
a3256 2
#define FILTER_DATA(idx)	   (AvARRAY(PL_rsfp_filters)[idx])
#define FILTER_ISREADER(idx)	   (idx >= AvFILLp(PL_rsfp_filters))
d3278 6
d3294 17
d3320 1
a3322 1
#include "hv.h"
a3327 13
/* Current curly descriptor */
typedef struct curcur CURCUR;
struct curcur {
    int		parenfloor;	/* how far back to strip paren data */
    int		cur;		/* how many instances of scan we've matched */
    int		min;		/* the minimal number of scans to match */
    int		max;		/* the maximal number of scans to match */
    int		minmod;		/* whether to work our way up or down */
    regnode *	scan;		/* the thing to match */
    regnode *	next;		/* what has to match after it */
    char *	lastloc;	/* where we started matching this scan */
    CURCUR *	oldcc;		/* current curly before we started this one */
};
d3331 2
a3332 2
    I32 super_state;	/* lexer state to save */
    I32 sub_inwhat;	/* "lex_inwhat" to use */
d3334 2
a3335 2
    char *super_bufptr;	/* PL_bufptr that was */
    char *super_bufend;	/* PL_bufend that was */
d3338 2
d3345 3
a3347 2
typedef I32 CHECKPOINT;

d3471 4
d3489 1
a3489 1
#ifndef UNDER_CE
d3523 2
d3533 4
a3536 1
#define DEBUG_MASK		0x001FEFFF /* mask of all the standard flags */
d3554 1
d3563 3
d3567 1
a3567 1

a3570 3
#  undef  YYDEBUG
#  define YYDEBUG 1

d3583 1
a3585 1
#  define DEBUG_Xv_TEST DEBUG_Xv_TEST_
d3592 5
d3621 1
d3623 3
d3628 1
d3631 1
d3633 1
a3633 1
#  define DEBUG_D(a) DEBUG__(DEBUG_D_TEST, a)
d3635 1
a3635 5
#  ifdef USE_5005THREADS
#    define DEBUG_S(a) DEBUG__(DEBUG_S_TEST, a)
#  else
#    define DEBUG_S(a)
#  endif
d3640 3
d3658 1
a3660 1
#  define DEBUG_Xv_TEST (0)
d3667 5
d3687 1
a3689 1
#  define DEBUG_Xv(a)
d3695 5
d3730 2
a3736 1
#define PERL_MAGIC_mutex	  'm' /* for lock op */
d3749 1
a3750 1
#define PERL_MAGIC_vec		  'v' /* vec() lvalue */
a3754 1
#define PERL_MAGIC_glob		  '*' /* GV (typeglob) */
d3758 3
a3763 2
#define YYMAXDEPTH 300

d3767 1
a3767 1
	    (Perl_croak(aTHX_ "Assertion %s failed: file \"" __FILE__ 	\
a3768 1
	    PerlProc_exit(1),						\
d3916 2
d3920 1
a3920 1
I32 unlnk (char*);
d3968 18
d4008 28
d4041 1
d4075 1
a4075 1
  INIT("Use of uninitialized value%s%s");
d4086 2
a4091 2
EXTCONST char PL_no_helem[]
  INIT("Modification of non-creatable hash value attempted, subscript \"%s\"");
d4093 1
a4093 1
  INIT("Modification of non-creatable hash value attempted, subscript \""SVf"\"");
d4107 1
a4107 1
  INIT("\"my\" variable %s can't be in a package");
d4113 6
a4121 1

d4123 9
a4131 5
EXT const char *PL_sig_name[] = { SIG_NAME };
EXT int   PL_sig_num[]  = { SIG_NUM };
#else
EXT const char *PL_sig_name[];
EXT int   PL_sig_num[];
d4138 1
a4138 1
EXT unsigned char PL_fold[] = { /* fast EBCDIC case folding table */
d4212 1
d4214 1
a4214 1
EXT unsigned char PL_fold_locale[] = {
d4249 1
a4249 1
EXT unsigned char PL_fold_locale[];
d4251 1
d4255 1
a4255 1
EXT unsigned char PL_freq[] = {/* EBCDIC frequencies for mixed English/C */
d4331 1
a4331 1
EXTCONST char* PL_block_type[] = {
d4338 3
d4347 105
a4468 2
#include "perly.h"

d4479 3
a4481 1
    XTERMBLOCK
a4510 3
#ifdef USE_5005THREADS
    want_vtbl_mutex,
#endif
d4514 4
a4517 1
    want_vtbl_utf8
d4520 4
a4523 3
				/* Note: the lowest 8 bits are reserved for
				   stuffing into op->op_private */
#define HINT_PRIVATE_MASK	0x000000ff
d4528 1
a4528 1
/* #define HINT_notused10	0x00000010 */
d4543 2
d4552 1
a4552 1
/* The following are stored in $sort::hints, not in PL_hints */
d4586 1
a4586 1
						struct re_scream_pos_data_s *d);
d4589 1
d4604 4
d4615 14
d4635 1
d4638 3
a4658 3
#  ifndef USE_5005THREADS
#    include "thrdvar.h"
#  endif
a4659 5
/*
 * The following is a buffer where new variables must
 * be defined to maintain binary compatibility with previous versions
 */
PERLVARA(object_compatibility,30,	char)
a4667 16
#ifdef USE_5005THREADS
/* If we have threads define a struct with all the variables
 * that have to be per-thread
 */


struct perl_thread {
#include "thrdvar.h"
};

typedef struct perl_thread *Thread;

#else
typedef void *Thread;
#endif

d4673 1
d4675 1
a4675 19
/* Types used by pack/unpack */ 
typedef enum {
  e_no_len,     /* no length  */
  e_number,     /* number, [] */
  e_star        /* asterisk   */
} howlen_t;

typedef struct {
  char*    patptr;   /* current template char */
  char*    patend;   /* one after last char   */
  char*    grpbeg;   /* 1st char of ()-group  */
  char*    grpend;   /* end of ()-group       */
  I32      code;     /* template code (!<>)   */
  I32      length;   /* length/repeat count   */
  howlen_t howlen;   /* how length is given   */ 
  int      level;    /* () nesting level      */
  U32      flags;    /* /=4, comma=2, pack=1  */
                     /*   and group modifiers */
} tempsym_t;
d4681 5
a4685 1
#  define PERL_CALLCONV
d4702 6
d4718 1
a4722 3
#  ifndef USE_5005THREADS
#    include "thrdvar.h"
#  endif
d4729 4
a4742 2
#include "reentr.inc"

d4750 5
a4754 15
#ifdef DOINIT

EXT MGVTBL PL_vtbl_sv =		{MEMBER_TO_FPTR(Perl_magic_get),
				MEMBER_TO_FPTR(Perl_magic_set),
					MEMBER_TO_FPTR(Perl_magic_len),
						0,	0};
EXT MGVTBL PL_vtbl_env =	{0,	MEMBER_TO_FPTR(Perl_magic_set_all_env),
				0,	MEMBER_TO_FPTR(Perl_magic_clear_all_env),
							0};
EXT MGVTBL PL_vtbl_envelem =	{0,	MEMBER_TO_FPTR(Perl_magic_setenv),
					0,	MEMBER_TO_FPTR(Perl_magic_clearenv),
							0};
EXT MGVTBL PL_vtbl_sig =	{0,	0,		 0, 0, 0};
#ifdef PERL_MICRO
EXT MGVTBL PL_vtbl_sigelem =	{0,	0,		 0, 0, 0};
d4756 2
a4757 62
EXT MGVTBL PL_vtbl_sigelem =	{MEMBER_TO_FPTR(Perl_magic_getsig),
					MEMBER_TO_FPTR(Perl_magic_setsig),
					0,	MEMBER_TO_FPTR(Perl_magic_clearsig),
							0};
#endif
EXT MGVTBL PL_vtbl_pack =	{0,	0,	
    				MEMBER_TO_FPTR(Perl_magic_sizepack),	
				MEMBER_TO_FPTR(Perl_magic_wipepack),
							0};
EXT MGVTBL PL_vtbl_packelem =	{MEMBER_TO_FPTR(Perl_magic_getpack),
					MEMBER_TO_FPTR(Perl_magic_setpack),
					0,	MEMBER_TO_FPTR(Perl_magic_clearpack),
							0};
EXT MGVTBL PL_vtbl_dbline =	{0,	MEMBER_TO_FPTR(Perl_magic_setdbline),
					0,	0,	0};
EXT MGVTBL PL_vtbl_isa =	{0,	MEMBER_TO_FPTR(Perl_magic_setisa),
					0,	MEMBER_TO_FPTR(Perl_magic_setisa),
							0};
EXT MGVTBL PL_vtbl_isaelem =	{0,	MEMBER_TO_FPTR(Perl_magic_setisa),
					0,	0,	0};
EXT MGVTBL PL_vtbl_arylen =	{MEMBER_TO_FPTR(Perl_magic_getarylen),
				MEMBER_TO_FPTR(Perl_magic_setarylen),
					0,	0,	0};
EXT MGVTBL PL_vtbl_glob =	{MEMBER_TO_FPTR(Perl_magic_getglob),
				MEMBER_TO_FPTR(Perl_magic_setglob),
					0,	0,	0};
EXT MGVTBL PL_vtbl_mglob =	{0,	MEMBER_TO_FPTR(Perl_magic_setmglob),
					0,	0,	0};
EXT MGVTBL PL_vtbl_nkeys =	{MEMBER_TO_FPTR(Perl_magic_getnkeys),
				MEMBER_TO_FPTR(Perl_magic_setnkeys),
					0,	0,	0};
EXT MGVTBL PL_vtbl_taint =	{MEMBER_TO_FPTR(Perl_magic_gettaint),
    					MEMBER_TO_FPTR(Perl_magic_settaint),
					0,	0,	0};
EXT MGVTBL PL_vtbl_substr =	{MEMBER_TO_FPTR(Perl_magic_getsubstr),
    					MEMBER_TO_FPTR(Perl_magic_setsubstr),
					0,	0,	0};
EXT MGVTBL PL_vtbl_vec =	{MEMBER_TO_FPTR(Perl_magic_getvec),
					MEMBER_TO_FPTR(Perl_magic_setvec),
					0,	0,	0};
EXT MGVTBL PL_vtbl_pos =	{MEMBER_TO_FPTR(Perl_magic_getpos),
				MEMBER_TO_FPTR(Perl_magic_setpos),
					0,	0,	0};
EXT MGVTBL PL_vtbl_bm =	{0,	MEMBER_TO_FPTR(Perl_magic_setbm),
					0,	0,	0};
EXT MGVTBL PL_vtbl_fm =	{0,	MEMBER_TO_FPTR(Perl_magic_setfm),
					0,	0,	0};
EXT MGVTBL PL_vtbl_uvar =	{MEMBER_TO_FPTR(Perl_magic_getuvar),
				MEMBER_TO_FPTR(Perl_magic_setuvar),
					0,	0,	0};
#ifdef USE_5005THREADS
EXT MGVTBL PL_vtbl_mutex =	{0,	0,	0,	0,	
					MEMBER_TO_FPTR(Perl_magic_mutexfree)};
#endif /* USE_5005THREADS */
EXT MGVTBL PL_vtbl_defelem = {MEMBER_TO_FPTR(Perl_magic_getdefelem),
    					MEMBER_TO_FPTR(Perl_magic_setdefelem),
					0,	0,	0};

EXT MGVTBL PL_vtbl_regexp = {0, MEMBER_TO_FPTR(Perl_magic_setregexp),0,0, MEMBER_TO_FPTR(Perl_magic_freeregexp)};
EXT MGVTBL PL_vtbl_regdata = {0, 0, MEMBER_TO_FPTR(Perl_magic_regdata_cnt), 0, 0};
EXT MGVTBL PL_vtbl_regdatum = {MEMBER_TO_FPTR(Perl_magic_regdatum_get),
			       MEMBER_TO_FPTR(Perl_magic_regdatum_set), 0, 0, 0};
d4759 8
a4766 57
#ifdef USE_LOCALE_COLLATE
EXT MGVTBL PL_vtbl_collxfrm = {0,
				MEMBER_TO_FPTR(Perl_magic_setcollxfrm),
					0,	0,	0};
#endif

EXT MGVTBL PL_vtbl_amagic =       {0,     MEMBER_TO_FPTR(Perl_magic_setamagic),
                                        0,      0,      MEMBER_TO_FPTR(Perl_magic_setamagic)};
EXT MGVTBL PL_vtbl_amagicelem =   {0,     MEMBER_TO_FPTR(Perl_magic_setamagic),
                                        0,      0,      MEMBER_TO_FPTR(Perl_magic_setamagic)};

EXT MGVTBL PL_vtbl_backref = 	  {0,	0,
					0,	0,	MEMBER_TO_FPTR(Perl_magic_killbackrefs)};

EXT MGVTBL PL_vtbl_ovrld   = 	  {0,	0,
					0,	0,	MEMBER_TO_FPTR(Perl_magic_freeovrld)};

EXT MGVTBL PL_vtbl_utf8 = {0,
				MEMBER_TO_FPTR(Perl_magic_setutf8),
					0,	0,	0};

#else /* !DOINIT */

EXT MGVTBL PL_vtbl_sv;
EXT MGVTBL PL_vtbl_env;
EXT MGVTBL PL_vtbl_envelem;
EXT MGVTBL PL_vtbl_sig;
EXT MGVTBL PL_vtbl_sigelem;
EXT MGVTBL PL_vtbl_pack;
EXT MGVTBL PL_vtbl_packelem;
EXT MGVTBL PL_vtbl_dbline;
EXT MGVTBL PL_vtbl_isa;
EXT MGVTBL PL_vtbl_isaelem;
EXT MGVTBL PL_vtbl_arylen;
EXT MGVTBL PL_vtbl_glob;
EXT MGVTBL PL_vtbl_mglob;
EXT MGVTBL PL_vtbl_nkeys;
EXT MGVTBL PL_vtbl_taint;
EXT MGVTBL PL_vtbl_substr;
EXT MGVTBL PL_vtbl_vec;
EXT MGVTBL PL_vtbl_pos;
EXT MGVTBL PL_vtbl_bm;
EXT MGVTBL PL_vtbl_fm;
EXT MGVTBL PL_vtbl_uvar;
EXT MGVTBL PL_vtbl_ovrld;

#ifdef USE_5005THREADS
EXT MGVTBL PL_vtbl_mutex;
#endif /* USE_5005THREADS */

EXT MGVTBL PL_vtbl_defelem;
EXT MGVTBL PL_vtbl_regexp;
EXT MGVTBL PL_vtbl_regdata;
EXT MGVTBL PL_vtbl_regdatum;

#ifdef USE_LOCALE_COLLATE
EXT MGVTBL PL_vtbl_collxfrm;
d4769 53
a4821 2
EXT MGVTBL PL_vtbl_amagic;
EXT MGVTBL PL_vtbl_amagicelem;
d4823 351
a5173 45
EXT MGVTBL PL_vtbl_backref;
EXT MGVTBL PL_vtbl_utf8;

#endif /* !DOINIT */

enum {
  fallback_amg,        abs_amg,
  bool__amg,   nomethod_amg,
  string_amg,  numer_amg,
  add_amg,     add_ass_amg,
  subtr_amg,   subtr_ass_amg,
  mult_amg,    mult_ass_amg,
  div_amg,     div_ass_amg,
  modulo_amg,  modulo_ass_amg,
  pow_amg,     pow_ass_amg,
  lshift_amg,  lshift_ass_amg,
  rshift_amg,  rshift_ass_amg,
  band_amg,    band_ass_amg,
  bor_amg,     bor_ass_amg,
  bxor_amg,    bxor_ass_amg,
  lt_amg,      le_amg,
  gt_amg,      ge_amg,
  eq_amg,      ne_amg,
  ncmp_amg,    scmp_amg,
  slt_amg,     sle_amg,
  sgt_amg,     sge_amg,
  seq_amg,     sne_amg,
  not_amg,     compl_amg,
  inc_amg,     dec_amg,
  atan2_amg,   cos_amg,
  sin_amg,     exp_amg,
  log_amg,     sqrt_amg,
  repeat_amg,   repeat_ass_amg,
  concat_amg,  concat_ass_amg,
  copy_amg,    neg_amg,
  to_sv_amg,   to_av_amg,
  to_hv_amg,   to_gv_amg,
  to_cv_amg,   iter_amg,
  int_amg,	DESTROY_amg,
  max_amg_code
  /* Do not leave a trailing comma here.  C9X allows it, C89 doesn't. */
};

#define NofAMmeth max_amg_code
#define AMG_id2name(id) (PL_AMG_names[id]+1)
d5175 1
a5175 44
#ifdef DOINIT
EXTCONST char * PL_AMG_names[NofAMmeth] = {
  /* Names kept in the symbol table.  fallback => "()", the rest has
     "(" prepended.  The only other place in perl which knows about
     this convention is AMG_id2name (used for debugging output and
     'nomethod' only), the only other place which has it hardwired is
     overload.pm.  */
  "()",		"(abs",			/* "fallback" should be the first. */
  "(bool",	"(nomethod",
  "(\"\"",	"(0+",
  "(+",		"(+=",
  "(-",		"(-=",
  "(*",		"(*=",
  "(/",		"(/=",
  "(%",		"(%=",
  "(**",	"(**=",
  "(<<",	"(<<=",
  "(>>",	"(>>=",
  "(&",		"(&=",
  "(|",		"(|=",
  "(^",		"(^=",
  "(<",		"(<=",
  "(>",		"(>=",
  "(==",	"(!=",
  "(<=>",	"(cmp",
  "(lt",	"(le",
  "(gt",	"(ge",
  "(eq",	"(ne",
  "(!",		"(~",
  "(++",	"(--",
  "(atan2",	"(cos",
  "(sin",	"(exp",
  "(log",	"(sqrt",
  "(x",		"(x=",
  "(.",		"(.=",
  "(=",		"(neg",
  "(${}",	"(@@{}",
  "(%{}",	"(*{}",
  "(&{}",	"(<>",
  "(int",	"DESTROY",
};
#else
EXTCONST char * PL_AMG_names[NofAMmeth];
#endif /* def INITAMAGIC */
d5180 1
d5183 1
a5183 1
  U32 flags;
a5184 1
  long fallback;
d5187 1
a5189 1
  U32 flags;
d5243 2
a5244 2
				 PERLDBf_NAMEEVAL| PERLDBf_NAMEANON)
					/* No _NONAME, _GOTO */
d5267 1
a5267 1

d5277 1
a5277 1
#define IN_LOCALE_RUNTIME	(PL_curcop->op_private & HINT_LOCALE)
d5367 1
a5367 1
#   define Atoul(s)	Strtoul(s, (char **)NULL, 10)
d5462 3
a5464 2
 * this, if you want to make the extension thread-safe.  See ext/re/re.xs
 * for an example of the use of these macros, and perlxs.pod for more.
d5469 1
d5483 2
d5489 1
d5491 9
a5499 4
/* Fetches the SV that keeps the per-interpreter data. */
#define dMY_CXT_SV \
	SV *my_cxt_sv = *hv_fetch(PL_modglobal, MY_CXT_KEY,		\
				  sizeof(MY_CXT_KEY)-1, TRUE)
d5504 23
a5526 2
	dMY_CXT_SV;							\
	my_cxt_t *my_cxtp = INT2PTR(my_cxt_t*, SvUV(my_cxt_sv))
d5532 5
a5536 5
	dMY_CXT_SV;							\
	/* newSV() allocates one more than needed */			\
	my_cxt_t *my_cxtp = (my_cxt_t*)SvPVX(newSV(sizeof(my_cxt_t)-1));\
	Zero(my_cxtp, 1, my_cxt_t);					\
	sv_setuv(my_cxt_sv, PTR2UV(my_cxtp))
a5539 1
	dMY_CXT_SV;							\
d5541 4
a5544 2
	Copy(INT2PTR(my_cxt_t*, SvUV(my_cxt_sv)), my_cxtp, 1, my_cxt_t);\
	sv_setuv(my_cxt_sv, PTR2UV(my_cxtp))
d5559 1
a5559 1
#else /* USE_ITHREADS */
d5575 1
a5575 1
#endif /* !defined(USE_ITHREADS) */
d5764 1
d5780 1
a5780 1
#define PERL_UNICODE_ALL_FLAGS			0x00ff
d5792 1
d5834 47
a5880 4
/* and finally... */
#define PERL_PATCHLEVEL_H_IMPLICIT
#include "patchlevel.h"
#undef PERL_PATCHLEVEL_H_IMPLICIT
d5882 1
a5882 1
/* Mention
d5922 1
a5922 1
   so that Configure picks them up. */
d5924 1
a5924 5
/* Source code compatibility cruft:
   PERL_XS_APIVERSION is not used, and has been superseded by inc_version_list
   It and PERL_PM_APIVERSION are retained for source compatibility in the
   5.8.x maintenance branch.
 */
d5926 1
a5926 2
#define PERL_XS_APIVERSION "5.8.3"
#define PERL_PM_APIVERSION "5.005"
a5928 1

@


1.12
log
@merge in perl 5.8.8
@
text
@d162 1
a162 1
#  ifdef HASATTRIBUTE_UNUSED
d168 1
a168 1

d185 12
a196 2
#define NOOP (void)0
#define dNOOP extern int Perl___notused PERL_UNUSED_DECL
d199 3
d2369 3
d2377 1
a2377 1
#if defined __GNUC__
d2380 3
d2396 1
a2396 1
#  if __GNUC__ >= 3 /* gcc 3.0 -> */ /* XXX Verify this version */
d2399 3
d2407 1
a2407 2
/*
 * USE_5005THREADS needs to be after unixish.h as <pthread.h> includes
d2413 1
a2413 6
#if defined(USE_5005THREADS) || defined(USE_ITHREADS)
#  if defined(USE_5005THREADS)
   /* pending resolution of licensing issues, we avoid the erstwhile
    * atomic.h everywhere */
#  define EMULATE_ATOMIC_REFCOUNTS
#  endif
@


1.11
log
@The official fix for the Perl sprintf buffer overflow.

ok millert@@
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, by Larry Wall and others
d121 1
a121 1
#  define pTHX_1	2	
d125 5
d153 2
a154 2
#ifdef HASATTRIBUTE
#  if (defined(__GNUC__) && defined(__cplusplus)) || defined(__INTEL_COMPILER)
d159 8
a166 2
#else
#  define PERL_UNUSED_DECL
d171 1
a171 1
 * but we cannot quite get rid of, such `ax' in PPCODE+noargs xsubs
d173 11
a183 1
#define PERL_UNUSED_VAR(var) if (0) var = var
d199 5
d246 12
d267 3
a269 1
#   define PERL_GCC_BRACE_GROUPS_FORBIDDEN
d281 1
a281 1
#   define STMT_START	(void)(	/* gcc supports ``({ STATEMENTS; })'' */
d511 241
d761 7
d826 1
a826 1
#define TOO_LATE_FOR_(ch,s)	Perl_croak(aTHX_ "\"-%c\" is on the #! line, it must also be used on the command line", (char)(ch), s)
d1087 1
d1089 1
a1089 1
#  define DEFSV GvSV(PL_defgv)
d1419 7
d1454 1
d1458 3
d1463 5
d1472 14
a1485 5
#if PTRSIZE == LONGSIZE
#  define PTR2ul(p)	(unsigned long)(p)
#else
#  define PTR2ul(p)	INT2PTR(unsigned long,p)	
#endif
d1644 1
a1644 1
long double modfl(long double, long double *);
d2350 35
d2548 1
a2548 4
#    define SVf "p"
#    ifndef SVf256
#      define SVf256 SVf
#    endif
d2554 1
a2554 5
#ifndef SVf256
#  define SVf256 ".256"SVf
#endif

#ifndef UVf
d2556 1
a2556 1
#    define UVf UVuf
d2558 1
a2558 1
#    define UVf "Vu"
d2564 1
a2564 1
#    define VDf "p"
d2570 15
a2584 5
#ifndef Nullformat
#  ifdef CHECK_FORMAT
#    define Nullformat "%s",""
#  else
#    define Nullformat Nullch
d2588 29
d2618 28
a2645 5
#  ifdef CHECK_FORMAT
#    define __attribute__format__(x,y,z) __attribute__((__format__(x,y,z)))
#  else
#    define __attribute__format__(x,y,z)
#  endif
d2647 1
a2647 1
 
d2660 1
a2660 1
	/* on BSDish systes we're safe */
d2663 4
d2668 2
a2669 1
#	define IOCPARM_LEN(x)	256
d2795 1
a2795 1
    void*			oldval;
d3120 1
a3120 1
		    where, PL_scopestack_ix, __FILE__, __LINE__)));
d3179 6
a3184 15
#ifdef DEBUGGING
#define assert(what)	PERL_DEB( {					\
	if (!(what)) {							\
	    Perl_croak(aTHX_ "Assertion " STRINGIFY(what) " failed: file \"%s\", line %d",	\
		__FILE__, __LINE__);					\
	    PerlProc_exit(1);						\
	}})
#else
#define assert(what)	PERL_DEB( {					\
	if (!(what)) {							\
	    Perl_croak(aTHX_ "Assertion failed: file \"%s\", line %d",	\
		__FILE__, __LINE__);					\
	    PerlProc_exit(1);						\
	}})
#endif
d3458 2
d3484 1
a3484 1
EXT char *PL_sig_name[] = { SIG_NAME };
d3487 1
a3487 1
EXT char *PL_sig_name[];
d3817 3
a3819 1
#define PERL_DEBUG_PAD_ZERO(i)	(SvPVX(PERL_DEBUG_PAD(i))[0] = 0, SvCUR(PERL_DEBUG_PAD(i)) = 0, PERL_DEBUG_PAD(i))
d3931 1
a3931 1
  I32      code;     /* template code (!)     */
d3936 1
a3944 10

#ifndef NEXT30_NO_ATTRIBUTE
#  ifndef HASATTRIBUTE       /* disable GNU-cc attribute checking? */
#    ifdef  __attribute__      /* Avoid possible redefinition errors */
#      undef  __attribute__
#    endif
#    define __attribute__(attr)
#  endif
#endif

d3947 2
a3948 2
#define PERL_CKDEF(s)	OP *s (pTHX_ OP *o);
#define PERL_PPDEF(s)	OP *s (pTHX);
d4187 1
a4187 1
#define AMG_id2name(id) ((char*)PL_AMG_names[id]+1)
a4483 20
/*
 * nice_chunk and nice_chunk size need to be set
 * and queried under the protection of sv_mutex
 */
#define offer_nice_chunk(chunk, chunk_size) STMT_START {  \
       void *new_chunk;                                   \
       U32 new_chunk_size;                                \
       LOCK_SV_MUTEX;                                     \
       new_chunk = (void *)(chunk);                       \
       new_chunk_size = (chunk_size);                     \
       if (new_chunk_size > PL_nice_chunk_size) {         \
           if (PL_nice_chunk) Safefree(PL_nice_chunk);    \
           PL_nice_chunk = new_chunk;                     \
           PL_nice_chunk_size = new_chunk_size;           \
       } else {                                           \
           Safefree(chunk);                               \
       }                                                  \
       UNLOCK_SV_MUTEX;                                   \
   } STMT_END

d4852 4
@


1.10
log
@sync in-tree perl with 5.8.6
@
text
@a3073 1
#ifdef PERL_MALLOC_WRAP
a3075 1
#endif
@


1.10.2.1
log
@MFC:
Fix by brad@@

The official fix for the Perl sprintf buffer overflow.
@
text
@d3074 1
d3077 1
@


1.10.4.1
log
@MFC:
Fix by brad@@

The official fix for the Perl sprintf buffer overflow.
@
text
@d3074 1
d3077 1
@


1.9
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d538 1
a538 1
#define TOO_LATE_FOR_(ch,s)	Perl_croak(aTHX_ "Too late for \"-%c\" option%s", (char)(ch), s)
d4191 7
d4217 1
@


1.8
log
@merge local changes into perl-5.8.3
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, by Larry Wall and others
a1805 1

d3074 4
d4313 13
d4518 9
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d1321 1
d1392 1
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d3 2
a4 1
 *    Copyright (c) 1987-2002, Larry Wall
a43 7
/* XXX This next guard can disappear if the sources are revised
   to use USE_5005THREADS throughout. -- A.D  1/6/2000
*/
#if defined(USE_ITHREADS) && defined(USE_5005THREADS)
#  include "error: USE_ITHREADS and USE_5005THREADS are incompatible"
#endif

d86 1
a86 1
#if defined(USE_ITHREADS) && !defined(USE_REENTRANT_API) && !defined(NETWARE) && !defined(WIN32) && !defined(__APPLE__)
d92 11
d149 1
a149 1
#  if defined(__GNUC__) && defined(__cplusplus)
d228 4
d240 1
a240 1
# if defined(__GNUC__) && !defined(__STRICT_ANSI__) && !defined(__cplusplus)
d245 1
a245 1
#  if (VOIDFLAGS) && (defined(sun) || defined(__sun__))
d300 1
a300 1
#if defined(__cplusplus) || defined(WIN32) || defined(__sgi) || defined(OS2) || defined(__DGUX) || defined( EPOC) || defined(__QNX__) || defined(NETWARE)
a506 10
START_EXTERN_C
Malloc_t Perl_malloc (MEM_SIZE nbytes);
Malloc_t Perl_calloc (MEM_SIZE elements, MEM_SIZE size);
Malloc_t Perl_realloc (Malloc_t where, MEM_SIZE nbytes);
/* 'mfree' rather than 'free', since there is already a 'perl_free'
 * that causes clashes with case-insensitive linkers */
Free_t   Perl_mfree (Malloc_t where);
END_EXTERN_C

typedef struct perl_mstats perl_mstats_t;
d512 16
d533 3
d538 5
d602 1
a602 1
  #  pragma function(memcmp)
d622 1
d628 1
d700 6
a705 3
/* In Tru64 use the 4.4BSD struct msghdr, not the 4.3 one */
#if defined(__osf__) && defined(__alpha) && !defined(_SOCKADDR_LEN)
#  define _SOCKADDR_LEN
d746 2
a747 1
 * behind some -D_BLAH_BLAH_SOURCE guard. */
d749 3
d753 1
d766 12
d780 12
d1190 4
a1193 2
   default value for printing floating point numbers in Gconvert.
   (see config.h)
d1248 23
d1302 1
a1302 1
#       define NV_MIN LDBL_MIN
d1326 5
d1332 4
a1335 1
#       define Perl_modf(x,y) ((long double)modf((double)(x),(double*)(y)))
d1340 4
a1343 1
#       define Perl_frexp(x,y) ((long double)frexp((double)(x),y))
d1375 1
a1375 1
#   ifdef DBL_MAX
d1398 7
d1546 2
a1547 1
 * t/op/numconvert.t, and t/op/pack.t. */
a1579 4
#else
#ifdef I_VALUES
#  include <values.h>
#endif
d1581 2
d1743 4
a1746 11
struct perl_mstats {
    UV *nfree;
    UV *ntotal;
    IV topbucket, topbucket_ev, topbucket_odd, totfree, total, total_chain;
    IV total_sbrk, sbrks, sbrk_good, sbrk_slack, start_slack, sbrked_remains;
    IV minbucket;
    /* Level 1 info */
    UV *bucket_mem_size;
    UV *bucket_available_size;
    UV nbuckets;
};
d1987 4
a1990 2
#    if defined(SIGFPE) && defined(SIG_IGN)
#      define PERL_FPU_INIT signal(SIGFPE, SIG_IGN);
d1993 1
d1997 4
d2014 6
a2019 3
/* MAXPATHLEN is supposed to include the final null character,
 * as opposed to PATH_MAX and _POSIX_PATH_MAX. */
#         define MAXPATHLEN (PATH_MAX+1)
d2021 1
a2021 1
#         define MAXPATHLEN (_POSIX_PATH_MAX+1)
d2028 1
a2028 1
#       define MAXPATHLEN (_POSIX_PATH_MAX+1)
d2199 3
d2207 4
d2235 8
d2270 2
a2271 1
#  define USEMYBINMODE / **/
d2273 5
a2277 1
            (PerlLIO_setmode(PerlIO_fileno(fp), mode) != -1 ? TRUE : FALSE)
d2288 1
d2325 11
d2341 1
d2534 1
a2553 1
#define DEBUG_L_FLAG		0x00001000 /*   4096 */
d2561 2
a2562 1
#define DEBUG_MASK		0x000FFFFF /* mask of all the standard flags */
a2579 1
#  define DEBUG_L_TEST_ (PL_debug & DEBUG_L_FLAG)
d2587 3
a2607 1
#  define DEBUG_L_TEST DEBUG_L_TEST_
d2610 1
d2616 1
d2618 2
a2619 2
#  define DEB(a)     a
#  define DEBUG(a)   if (PL_debug)   a
a2643 1
#  define DEBUG_L(a) DEBUG__(DEBUG_L_TEST, a)
d2646 1
d2657 1
a2672 1
#  define DEBUG_L_TEST (0)
d2675 1
d2681 1
d2683 2
a2684 2
#  define DEB(a)
#  define DEBUG(a)
a2696 1
#  define DEBUG_L(a)
d2699 1
d2704 1
d2708 7
d2753 1
d2755 1
d2770 1
a2770 1
#define assert(what)	DEB( {						\
d2777 1
a2777 1
#define assert(what)	DEB( {						\
a2974 1
# define PAD_SV(po) pad_sv(po)
a2976 1
# define PAD_SV(po) PL_curpad[po]
d3013 1
a3013 1
    (defined(NeXT) || defined(__NeXT__) || defined(__APPLE__))
d3019 1
a3019 1
#    if defined(__APPLE__) && defined(PERL_CORE)
d3071 2
d3301 10
d3358 2
a3359 1
    want_vtbl_backref
d3365 4
a3368 4
#define HINT_INTEGER		0x00000001
#define HINT_STRICT_REFS	0x00000002
#define HINT_LOCALE		0x00000004
#define HINT_BYTES		0x00000008
d3371 1
d3374 2
a3375 2
#define HINT_STRICT_SUBS	0x00000200
#define HINT_STRICT_VARS	0x00000400
d3377 1
d3385 2
a3386 2
#define HINT_RE_TAINT		0x00100000
#define HINT_RE_EVAL		0x00200000
d3388 2
a3389 2
#define HINT_FILETEST_ACCESS	0x00400000
#define HINT_UTF8		0x00800000
d3391 1
d3512 19
d3595 2
d3678 1
a3678 1
EXT MGVTBL PL_vtbl_regexp = {0,0,0,0, MEMBER_TO_FPTR(Perl_magic_freeregexp)};
d3700 4
d3746 1
d3940 1
a3940 1
	(PL_curcop == &PL_compiling ? IN_LOCALE_COMPILETIME : IN_LOCALE_RUNTIME)
d4022 3
a4028 11
#if !defined(PERLIO_IS_STDIO)
/*
 * Remap printf
 */
#undef printf
#ifdef __GNUC__
#define printf(fmt,args...) PerlIO_stdoutf(fmt,##args)
#else
#define printf PerlIO_stdoutf
#endif
#endif
d4067 3
a4069 5
#   ifndef PERL_OLD_SIGNALS
#		ifndef PERL_ASYNC_CHECK
#			define PERL_ASYNC_CHECK() if (PL_sig_pending) despatch_signals()
#		endif
#   endif
d4220 4
d4251 1
a4251 1
#   if defined(__BEOS__) || defined(__VOS__)
d4332 1
d4368 86
d4481 1
a4482 1
   HAS_UALARM
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d3 1
a3 1
 *    Copyright (c) 1987-2001, Larry Wall
d9 1
d15 1
a15 1
 * This file is being used for x2p stuff. 
d17 1
a17 1
 * Decouple x2p stuff from some of perls more extreme eccentricities. 
d24 7
d32 6
a37 1
#include "config.h"
d46 2
a47 2
#if defined(USE_ITHREADS) && defined(USE_THREADS)
#  include "error: USE_ITHREADS and USE_THREADS are incompatible"
d53 13
d67 1
a67 1
#  if !defined(MULTIPLICITY) && !defined(PERL_OBJECT)
d72 1
a72 1
#ifdef USE_THREADS
d84 4
a87 11
#ifdef PERL_CAPI
#  undef PERL_OBJECT
#  ifndef MULTIPLICITY
#    define MULTIPLICITY
#  endif
#  ifndef PERL_IMPLICIT_CONTEXT
#    define PERL_IMPLICIT_CONTEXT
#  endif
#  ifndef PERL_IMPLICIT_SYS
#    define PERL_IMPLICIT_SYS
#  endif
d90 4
a93 7
#ifdef PERL_OBJECT
#  ifndef PERL_IMPLICIT_CONTEXT
#    define PERL_IMPLICIT_CONTEXT
#  endif
#  ifndef PERL_IMPLICIT_SYS
#    define PERL_IMPLICIT_SYS
#  endif
d96 1
a96 96
#ifdef PERL_OBJECT

/* PERL_OBJECT explained  - DickH and DougL @@ ActiveState.com

Defining PERL_OBJECT turns on creation of a C++ object that
contains all writable core perl global variables and functions.
Stated another way, all necessary global variables and functions
are members of a big C++ object. This object's class is CPerlObj.
This allows a Perl Host to have multiple, independent perl
interpreters in the same process space. This is very important on
Win32 systems as the overhead of process creation is quite high --
this could be even higher than the script compile and execute time
for small scripts.

The perl executable implementation on Win32 is composed of perl.exe
(the Perl Host) and perlX.dll. (the Perl Core). This allows the
same Perl Core to easily be embedded in other applications that use
the perl interpreter.

+-----------+
| Perl Host |
+-----------+
      ^
      |
      v
+-----------+   +-----------+
| Perl Core |<->| Extension |
+-----------+   +-----------+ ...

Defining PERL_OBJECT has the following effects:

PERL CORE
1. CPerlObj is defined (this is the PERL_OBJECT)
2. all static functions that needed to access either global
variables or functions needed are made member functions
3. all writable static variables are made member variables
4. all global variables and functions are defined as:
	#define var CPerlObj::PL_var
	#define func CPerlObj::Perl_func
	* these are in embed.h
This necessitated renaming some local variables and functions that
had the same name as a global variable or function. This was
probably a _good_ thing anyway.


EXTENSIONS
1. Access to global variables and perl functions is through a
pointer to the PERL_OBJECT. This pointer type is CPerlObj*. This is
made transparent to extension developers by the following macros:
	#define var pPerl->PL_var
	#define func pPerl->Perl_func
	* these are done in objXSUB.h
This requires that the extension be compiled as C++, which means
that the code must be ANSI C and not K&R C. For K&R extensions,
please see the C API notes located in Win32/GenCAPI.pl. This script
creates a perlCAPI.lib that provides a K & R compatible C interface
to the PERL_OBJECT.
2. Local variables and functions cannot have the same name as perl's
variables or functions since the macros will redefine these. Look for
this if you get some strange error message and it does not look like
the code that you had written. This often happens with variables that
are local to a function.

PERL HOST
1. The perl host is linked with perlX.lib to get perl_alloc. This
function will return a pointer to CPerlObj (the PERL_OBJECT). It
takes pointers to the various PerlXXX_YYY interfaces (see iperlsys.h
for more information on this).
2. The perl host calls the same functions as normally would be
called in setting up and running a perl script, except that the
functions are now member functions of the PERL_OBJECT.

*/


class CPerlObj;

#define STATIC
#define CPERLscope(x)		CPerlObj::x
#define CALL_FPTR(fptr)		(aTHXo->*fptr)

#define pTHXo			CPerlObj *pPerl
#define pTHXo_			pTHXo,
#define aTHXo			this
#define aTHXo_			this,
#define PERL_OBJECT_THIS	aTHXo
#define PERL_OBJECT_THIS_	aTHXo_
#define dTHXoa(a)		pTHXo = (CPerlObj*)a
#define dTHXo			pTHXo = PERL_GET_THX

#define pTHXx		void
#define pTHXx_
#define aTHXx
#define aTHXx_

#else /* !PERL_OBJECT */
d99 1
a99 1
#  ifdef USE_THREADS
d101 1
a101 1
#    define pTHX	register struct perl_thread *thr
d109 1
a109 1
#    define pTHX	register PerlInterpreter *my_perl
a131 2
#endif /* PERL_OBJECT */

d143 16
d160 1
a160 1
#define dNOOP extern int Perl___notused
d175 2
a176 1
#ifndef pTHXo
d193 9
d210 2
a211 2
#  define START_EXTERN_C 
#  define END_EXTERN_C 
d283 1
a283 1
#if defined(MSDOS) || defined(atarist) || defined(WIN32)
d287 1
a287 1
#if defined(__STDC__) || defined(vax11c) || defined(_AIX) || defined(__stdc__) || defined(__cplusplus) || defined( EPOC)
d291 1
a291 1
#if defined(__cplusplus) || defined(WIN32) || defined(__sgi) || defined(OS2) || defined(__DGUX) || defined( EPOC) || defined(__QNX__)
d297 1
a297 1
#	define VOL		// to temporarily suppress warnings
d311 1
a311 1
/* XXX All process group stuff is handled in pp_sys.c.  Should these 
d351 1
a351 1
/* These are not exact synonyms, since setpgrp() and getpgrp() may 
d364 1
a364 1
#if (defined(USE_THREADS) || defined(USE_ITHREADS)) \
d409 4
d450 8
d462 4
a465 1
#if !defined(PERL_FOR_X2P) && !defined(WIN32)
d498 1
d505 1
d552 1
d671 1
a671 1
#if defined(WIN32) && (defined(PERL_OBJECT) || defined(PERL_IMPLICIT_SYS) || defined(PERL_CAPI))
d675 6
a680 1
#if defined(HAS_SOCKET) && !defined(VMS) /* VMS handles sockets via vmsish.h */
d687 1
a687 1
#   ifdef USE_THREADS
d689 1
a689 1
#       undef USE_THREADS
d692 2
a693 2
#   ifdef USE_THREADS
#       undef USE_THREADS /* socks.h does this on its own */
d696 1
a696 1
#       define USE_THREADS /* restore our value */
d703 1
a703 4
#   ifdef USE_64_BIT_ALL
#       define SOCKS_64BIT_BUG /* until proven otherwise */
#   endif
# endif 
d705 3
d717 6
d737 1
a737 1
#ifdef USE_THREADS
d745 1
a745 1
#endif /* USE_THREADS */
d794 6
d829 6
d848 1
a848 1
#ifdef I_SYSMODE
d966 1
a966 1
#endif 
d970 1
a970 1
#endif 
d974 5
a978 1
#endif 
d980 1
a980 1
#ifndef S_IREAD
d984 1
a984 1
#ifndef S_IWRITE
d1004 11
d1073 5
d1081 5
a1085 1
/*   
d1099 1
a1099 1
#  if PTRSIZE == LONGSIZE 
d1110 1
a1110 1
#if PTRSIZE == LONGSIZE 
d1115 1
a1115 1
  
d1203 15
d1252 8
a1259 7
#   ifdef HAS_ISNANL
#       define Perl_isnan(x) isnanl(x)
#   else
#       ifdef HAS_ISNAN
#           define Perl_isnan(x) isnan((double)(x))
#       else
#           define Perl_isnan(x) ((x)!=(x))
d1267 15
d1301 93
d1395 21
a1415 1
#       define Perl_isnan(x) isnan(x)
d1417 5
a1421 1
#       define Perl_isnan(x) ((x)!=(x))
d1425 13
a1437 3
#if !defined(Perl_atof) && defined(USE_LONG_DOUBLE) && defined(HAS_LONG_DOUBLE)
#   if !defined(Perl_atof) && defined(HAS_STRTOLD) 
#       define Perl_atof(s) (NV)strtold(s, (char**)NULL)
d1439 12
a1450 2
#   if !defined(Perl_atof) && defined(HAS_ATOLF)
#       define Perl_atof (NV)atolf
d1452 3
a1454 3
#   if !defined(Perl_atof) && defined(PERL_SCNfldbl)
#       define Perl_atof PERL_SCNfldbl
#       define Perl_atof2(s,f) sscanf((s), "%"PERL_SCNfldbl, &(f))
d1457 7
a1463 5
#if !defined(Perl_atof)
#   define Perl_atof atof /* we assume atof being available anywhere */
#endif
#if !defined(Perl_atof2)
#   define Perl_atof2(s,f) ((f) = (NV)Perl_atof(s))
d1466 1
a1466 1
/* Previously these definitions used hardcoded figures. 
d1517 1
a1517 1
 
d1655 1
d1672 5
a1676 2
#ifdef UTS
#   define STRUCT_SV perl_sv /* Amdahl's <ksync.h> has struct sv */
d1710 2
d1729 1
a1729 1
#   endif  
d1815 1
a1815 1
#if defined(OS2)
d1820 2
a1821 1
# include "vmesa/vmesaish.h"
d1825 9
a1833 7
# if defined(OS2)
#   include "os2ish.h"
# else
#   include "dosish.h"
# endif
#else
# if defined(VMS)
d1835 17
a1851 3
# else
#   if defined(PLAN9)
#     include "./plan9/plan9ish.h"
d1853 14
a1866 20
#     if defined(MPE)
#       include "mpeix/mpeixish.h"
#     else
#       if defined(__VOS__)
#         include "vosish.h"
#       else
#         if defined(EPOC)
#           include "epocish.h"
#         else
#           if defined(MACOS_TRADITIONAL)
#             include "macos/macish.h"
#	      ifndef NO_ENVIRON_ARRAY
#               define NO_ENVIRON_ARRAY
#             endif
#           else
#             include "unixish.h"
#           endif
#         endif
#       endif
#     endif
d1868 11
a1878 1
# endif
d1885 16
a1900 5
#ifdef JPL
    /* E.g. JPL needs to operate on a copy of the real environment.
     * JDK 1.2 and 1.3 seem to get upset if the original environment
     * is diddled with. */
#   define NEED_ENVIRON_DUP_FOR_MODIFY
d1907 4
d1933 2
a1934 2
/* 
 * USE_THREADS needs to be after unixish.h as <pthread.h> includes
d1940 2
a1941 2
#if defined(USE_THREADS) || defined(USE_ITHREADS)
#  if defined(USE_THREADS)
d1946 3
d1979 2
a1980 1
#endif /* USE_THREADS || USE_ITHREADS */
d1982 1
a1982 1
#ifdef WIN32
d1986 4
d2041 1
d2054 3
a2056 1
 * performance issue, so we allow people to disable it.
d2059 1
a2059 1
# if defined(FFLUSH_NULL) || defined(USE_SFIO)
d2084 1
a2084 1
#  ifdef USE_THREADS
a2088 4
#  else
#  ifdef PERL_OBJECT
#    define PERL_GET_THX		((CPerlObj *)PERL_GET_CONTEXT)
#  endif
d2099 1
a2099 1
#  endif 
d2107 1
a2107 1
#  endif 
d2115 9
a2123 1
#  endif 
d2167 1
a2167 1
    void	(*any_dxptr) (pTHXo_ void*);
d2171 1
a2171 1
#ifdef USE_THREADS
d2175 1
a2175 1
#endif /* USE_THREADS */
d2177 1
a2177 1
typedef I32 (*filter_t) (pTHXo_ int, SV *, int);
d2183 17
a2199 1
#if !defined(OS2)
d2316 6
d2324 14
a2337 9
#ifdef CASTNEGFLOAT
#define U_S(what) ((U16)(what))
#define U_I(what) ((unsigned int)(what))
#define U_L(what) ((U32)(what))
#else
#define U_S(what) ((U16)cast_ulong((NV)(what)))
#define U_I(what) ((unsigned int)cast_ulong((NV)(what)))
#define U_L(what) (cast_ulong((NV)(what)))
#endif
d2339 9
a2347 5
#ifdef CASTI32
#define I_32(what) ((I32)(what))
#define I_V(what) ((IV)(what))
#define U_V(what) ((UV)(what))
#else
d2349 1
d2352 18
a2369 1
#endif
d2385 1
d2391 1
d2405 48
d2454 35
a2488 14
#undef  YYDEBUG
#define YYDEBUG 1
#define DEB(a)     			a
#define DEBUG(a)   if (PL_debug)		a
#define DEBUG_p(a) if (PL_debug & 1)	a
#define DEBUG_s(a) if (PL_debug & 2)	a
#define DEBUG_l(a) if (PL_debug & 4)	a
#define DEBUG_t(a) if (PL_debug & 8)	a
#define DEBUG_o(a) if (PL_debug & 16)	a
#define DEBUG_c(a) if (PL_debug & 32)	a
#define DEBUG_P(a) if (PL_debug & 64)	a
#  if defined(PERL_OBJECT)
#    define DEBUG_m(a) if (PL_debug & 128)	a
#  else
d2491 1
a2491 1
#    define DEBUG_m(a)  \
d2493 1
a2493 1
        if (PERL_GET_INTERP) { dTHX; if (PL_debug & 128) {PL_debug&=~128; a; PL_debug|=128;} } \
d2495 17
a2511 11
#  endif
#define DEBUG_f(a) if (PL_debug & 256)	a
#define DEBUG_r(a) if (PL_debug & 512)	a
#define DEBUG_x(a) if (PL_debug & 1024)	a
#define DEBUG_u(a) if (PL_debug & 2048)	a
#define DEBUG_L(a) if (PL_debug & 4096)	a
#define DEBUG_H(a) if (PL_debug & 8192)	a
#define DEBUG_X(a) if (PL_debug & 16384)	a
#define DEBUG_D(a) if (PL_debug & 32768)	a
#  ifdef USE_THREADS
#    define DEBUG_S(a) if (PL_debug & (1<<16))	a
d2515 100
a2614 23
#define DEBUG_T(a) if (PL_debug & (1<<17))	a
#else
#define DEB(a)
#define DEBUG(a)
#define DEBUG_p(a)
#define DEBUG_s(a)
#define DEBUG_l(a)
#define DEBUG_t(a)
#define DEBUG_o(a)
#define DEBUG_c(a)
#define DEBUG_P(a)
#define DEBUG_m(a)
#define DEBUG_f(a)
#define DEBUG_r(a)
#define DEBUG_x(a)
#define DEBUG_u(a)
#define DEBUG_S(a)
#define DEBUG_H(a)
#define DEBUG_X(a)
#define DEBUG_D(a)
#define DEBUG_S(a)
#define DEBUG_T(a)
#endif
d2618 8
d2633 1
d2636 2
a2637 2
    I32 (*uf_val)(IV, SV*);
    I32 (*uf_set)(IV, SV*);
d2641 22
d2703 49
d2756 2
a2757 1
#    if !defined(WIN32)
d2759 1
d2774 1
d2776 1
d2786 9
d2855 2
d2881 1
a2881 1
        defined(__DGUX) 
d2935 1
a2935 1
/* fast case folding tables */
d3192 1
a3192 1
#ifdef USE_THREADS
d3205 2
a3206 2
/* #define HINT_notused4	0x00000004 */
#define HINT_BYTE		0x00000008
a3212 1
#define HINT_LOCALE		0x00000800
d3227 6
a3232 1
/* Various states of an input record separator SV (rs, nrs) */
d3238 11
d3250 1
d3263 6
a3268 6
typedef void (*DESTRUCTORFUNC_t) (pTHXo_ void*);
typedef void (*SVFUNC_t) (pTHXo_ SV*);
typedef I32  (*SVCOMPARE_t) (pTHXo_ SV*, SV*);
typedef void (*XSINIT_t) (pTHXo);
typedef void (*ATEXIT_t) (pTHXo_ void*);
typedef void (*XSUBADDR_t) (pTHXo_ CV *);
d3278 1
a3278 1
    void (*fn) (pTHXo_ void*);
d3300 2
a3301 2
#if defined(MULTIPLICITY) || defined(PERL_OBJECT)
/* If we have multiple interpreters define a struct 
d3303 1
a3303 1
   If we don't have threads anything that would have 
d3308 1
a3308 1
#  ifndef USE_THREADS
d3314 1
a3314 1
 * be defined to maintain binary compatibility with PERL_OBJECT
d3323 1
a3323 1
#endif /* MULTIPLICITY || PERL_OBJECT */
d3325 1
a3325 1
#ifdef USE_THREADS
d3352 1
a3352 1
#endif 
a3362 4
#ifdef PERL_OBJECT
#  define PERL_DECL_PROT
#endif

a3369 5
#ifdef PERL_OBJECT
#  undef PERL_DECL_PROT
#endif

#ifndef PERL_OBJECT
d3371 1
a3371 2
#  include "opcode.h"
#endif
d3379 1
a3379 1
/* Now include all the 'global' variables 
d3381 1
a3381 1
 * these include variables that would have been their struct-s 
d3383 1
a3383 1
                         
d3389 1
a3389 1
#if !defined(MULTIPLICITY) && !defined(PERL_OBJECT)
d3392 1
a3392 1
#  ifndef USE_THREADS
d3398 2
a3399 1
#ifdef PERL_OBJECT
d3401 1
a3401 15

#  ifdef DOINIT
#    include "INTERN.h"
#  else
#    include "EXTERN.h"
#  endif

/* this has structure inits, so it cannot be included before here */
#  include "opcode.h"

#else
#  if defined(WIN32)
#    include "embed.h"
#  endif
#endif  /* PERL_OBJECT */
d3420 1
a3420 1
EXT MGVTBL PL_vtbl_sv =	{MEMBER_TO_FPTR(Perl_magic_get),
d3431 3
d3438 4
a3441 1
EXT MGVTBL PL_vtbl_pack =	{0,	0,	MEMBER_TO_FPTR(Perl_magic_sizepack),	MEMBER_TO_FPTR(Perl_magic_wipepack),
d3444 1
a3444 1
				MEMBER_TO_FPTR(Perl_magic_setpack),
d3465 2
a3466 1
EXT MGVTBL PL_vtbl_taint =	{MEMBER_TO_FPTR(Perl_magic_gettaint),MEMBER_TO_FPTR(Perl_magic_settaint),
d3468 2
a3469 1
EXT MGVTBL PL_vtbl_substr =	{MEMBER_TO_FPTR(Perl_magic_getsubstr), MEMBER_TO_FPTR(Perl_magic_setsubstr),
d3472 1
a3472 1
				MEMBER_TO_FPTR(Perl_magic_setvec),
d3484 6
a3489 4
#ifdef USE_THREADS
EXT MGVTBL PL_vtbl_mutex =	{0,	0,	0,	0,	MEMBER_TO_FPTR(Perl_magic_mutexfree)};
#endif /* USE_THREADS */
EXT MGVTBL PL_vtbl_defelem = {MEMBER_TO_FPTR(Perl_magic_getdefelem),MEMBER_TO_FPTR(Perl_magic_setdefelem),
d3511 3
d3537 1
d3539 1
a3539 1
#ifdef USE_THREADS
d3541 1
a3541 1
#endif /* USE_THREADS */
d3591 2
a3592 1
  to_cv_amg,   iter_amg,    
d3598 1
d3602 38
a3639 32
  "fallback",	"abs",			/* "fallback" should be the first. */
  "bool",	"nomethod",
  "\"\"",	"0+",
  "+",		"+=",
  "-",		"-=",
  "*",		"*=",
  "/",		"/=",
  "%",		"%=",
  "**",		"**=",
  "<<",		"<<=",
  ">>",		">>=",
  "&",		"&=",
  "|",		"|=",
  "^",		"^=",
  "<",		"<=",
  ">",		">=",
  "==",		"!=",
  "<=>",	"cmp",
  "lt",		"le",
  "gt",		"ge",
  "eq",		"ne",
  "!",		"~",
  "++",		"--",
  "atan2",	"cos",
  "sin",	"exp",
  "log",	"sqrt",
  "x",		"x=",
  ".",		".=",
  "=",		"neg",
  "${}",	"@@{}",
  "%{}",	"*{}",
  "&{}",	"<>",
d3648 1
a3648 1
  long was_ok_sub;
d3655 1
a3655 1
  long was_ok_sub;
d3667 1
d3671 3
d3675 1
d3745 5
a3749 3
#define IS_NUMERIC_RADIX(s)	\
	((PL_hints & HINT_LOCALE) && \
	  PL_numeric_radix_sv && memEQ(s, SvPVX(PL_numeric_radix_sv), SvCUR(PL_numeric_radix_sv)))
d3752 1
a3752 1
	bool was_local = (PL_hints & HINT_LOCALE) && PL_numeric_local; \
d3756 1
a3756 1
	bool was_standard = (PL_hints & HINT_LOCALE) && PL_numeric_standard; \
d3771 1
a3771 1
#define IS_NUMERIC_RADIX(c)		(0)
d3776 2
a3777 1
#define Atof				Perl_atof
d3785 3
d3791 3
d3804 3
d3817 3
d3835 3
a3837 4
#if !defined(PERLIO_IS_STDIO) && defined(HASATTRIBUTE)
/* 
 * Now we have __attribute__ out of the way 
 * Remap printf 
d3840 3
d3845 1
d3882 9
d3892 1
a3892 1
#define PERL_ASYNC_CHECK()  NOOP
d3909 15
a3923 11
#define offer_nice_chunk(chunk, chunk_size) do {	\
	LOCK_SV_MUTEX;					\
	if (!PL_nice_chunk) {				\
	    PL_nice_chunk = (char*)(chunk);		\
	    PL_nice_chunk_size = (chunk_size);		\
	}						\
	else {						\
	    Safefree(chunk);				\
	}						\
	UNLOCK_SV_MUTEX;				\
    } while (0)
d3957 78
d4043 4
d4063 17
d4083 3
d4133 49
d4188 1
a4188 1
   
a4190 3
   HAS_ICONV
   I_ICONV

d4209 18
d4230 1
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d3 1
a3 1
 *    Copyright (c) 1987-2000, Larry Wall
d167 2
a168 2
#define dTHXoa(a)		pTHXo = a
#define dTHXo			dTHXoa(PERL_GET_THX)
d182 2
a183 1
#    define dTHR	dNOOP
d190 1
d192 1
a192 2
#  define dTHXa(a)	pTHX = a
#  define dTHX		dTHXa(PERL_GET_THX)
d246 1
d302 1
a302 1
#define WITH_THR(s) STMT_START { dTHR; s; } STMT_END
a490 1

d496 5
a546 11
struct perl_mstats {
    unsigned long *nfree;
    unsigned long *ntotal;
    long topbucket, topbucket_ev, topbucket_odd, totfree, total, total_chain;
    long total_sbrk, sbrks, sbrk_good, sbrk_slack, start_slack, sbrked_remains;
    long minbucket;
    /* Level 1 info */
    unsigned long *bucket_mem_size;
    unsigned long *bucket_available_size;
};

d707 44
a750 4
#ifdef HAS_SOCKET
#   ifdef I_NET_ERRNO
#     include <net/errno.h>
#   endif
d1100 5
d1107 3
d1190 9
a1198 6
#   ifdef HAS_SQRTL
        /* libsunmath doesn't have modfl and frexpl as of mid-March 2000 */
	/* XXX Configure probe for modfl and frexpl needed XXX */
#       if defined(__sun) && defined(__svr4)
#           define Perl_modf(x,y) ((long double)modf((double)(x),(double*)(y)))
#           define Perl_frexp(x) ((long double)frexp((double)(x)))
d1200 3
a1202 2
#           define Perl_modf modfl
#           define Perl_frexp frexpl
d1204 2
d1216 20
d1238 11
a1248 2
#   define Perl_modf modf
#   define Perl_frexp frexp
d1258 7
d1269 1
a1269 1
#       define Perl_atof(s) strtold(s, (char**)NULL)
d1272 5
a1276 1
#       define Perl_atof atolf
d1282 3
a1456 3
#  ifdef UQUAD_MAX
#    define PERL_UQUAD_MAX ((UV)UQUAD_MAX)
#  else
d1458 1
a1458 7
#  endif

#  define PERL_UQUAD_MIN ((UV)0)

#  ifdef QUAD_MAX
#    define PERL_QUAD_MAX ((IV)QUAD_MAX)
#  else
a1459 5
#  endif

#  ifdef QUAD_MIN
#    define PERL_QUAD_MIN ((IV)QUAD_MIN)
#  else
a1460 1
#  endif
d1464 12
d1491 6
a1496 1
typedef struct sv SV;
d1661 3
d1672 12
a1683 1
#endif         
d1873 16
d1891 1
a1891 1
   below to be rejected by the compmiler.  Sigh.
d2111 1
d2132 2
d2136 1
a2136 1
	if (PERL_GET_INTERP) { dTHX; if (PL_debug & 128) { a; } }	\
d2152 1
d2173 1
d2244 3
a2246 1
#    if !defined(EPOC) && !(defined(__hpux) && defined(_FILE_OFFSET_BITS) && _FILE_OFFSET_BITS == 64) && !defined(HAS_LSEEK_PROTO)
d2248 2
d2335 1
a2335 1
#    if defined(__APPLE__)
d2342 1
a2342 1
#  if !defined(VMS)
d2346 1
a2346 1
        defined(__DGUX) || defined(EPOC)
a2710 4
#ifdef USE_PURE_BISON
int Perl_yylex(pTHX_ YYSTYPE *lvalp, int *lcharp);
#endif

d2956 2
a2957 1
EXT MGVTBL PL_vtbl_regdatum = {MEMBER_TO_FPTR(Perl_magic_regdatum_get), 0, 0, 0, 0};
d3185 1
a3185 4
    STMT_START {				\
	if (! PL_numeric_standard)		\
	    set_numeric_standard();		\
    } STMT_END
d3188 1
a3188 4
    STMT_START {				\
	if (! PL_numeric_local)			\
	    set_numeric_local();		\
    } STMT_END
d3190 1
a3190 1
#define IS_NUMERIC_RADIX(c)	\
d3192 15
a3206 1
	  PL_numeric_radix && (c) == PL_numeric_radix)
a3207 2
#define RESTORE_NUMERIC_LOCAL()		if ((PL_hints & HINT_LOCALE) && PL_numeric_standard) SET_NUMERIC_LOCAL()
#define RESTORE_NUMERIC_STANDARD()	if ((PL_hints & HINT_LOCALE) && PL_numeric_local) SET_NUMERIC_STANDARD()
d3215 2
d3437 8
d3470 4
@


1.3
log
@perl5.005_03 (stock)
@
text
@d3 1
a3 1
 *    Copyright (c) 1987-1999, Larry Wall
a10 1
#define OVERLOAD
a17 3
#undef EMBED
#undef NO_EMBED
#define NO_EMBED
d23 57
d103 2
a104 2
	  |
	  v
d117 1
a117 1
	#define var CPerlObj::Perl_var
d119 1
a119 1
	* these are in objpp.h
d129 1
a129 1
	#define var pPerl->Perl_var
d158 16
a173 12
#define CPERLscope(x) CPerlObj::x
#define CPERLproto CPerlObj *
#define _CPERLproto ,CPERLproto
#define CPERLarg CPerlObj *pPerl
#define CPERLarg_ CPERLarg,
#define _CPERLarg ,CPERLarg
#define PERL_OBJECT_THIS this
#define _PERL_OBJECT_THIS ,this
#define PERL_OBJECT_THIS_ this,
#define CALLRUNOPS (this->*PL_runops)
#define CALLREGCOMP (this->*PL_regcompp)
#define CALLREGEXEC (this->*PL_regexecp)
d177 23
a201 2
#define CPERLproto
#define _CPERLproto
d208 1
a208 3
#define CALLRUNOPS PL_runops
#define CALLREGCOMP (*PL_regcompp)
#define CALLREGEXEC (*PL_regexecp)
d212 10
a221 2
#define VOIDUSED 1
#include "config.h"
d223 31
a253 1
#include "embed.h"
d265 1
a265 1
#  define EXTERN_C
a271 1
#ifdef EMBED
a272 3
#else
register struct op *op asm(stringify(OP_IN_REGISTER));
#endif
d299 1
a299 2
#define NOOP (void)0

d340 1
a340 1
#if defined(__STDC__) || defined(vax11c) || defined(_AIX) || defined(__stdc__) || defined(__cplusplus)
d344 1
a344 1
#if defined(__cplusplus) || defined(WIN32) || defined(__sgi) || defined(OS2) || defined(__DGUX)
d414 8
a441 2
#include "iperlsys.h"

d444 9
a452 5
#if NX_CURRENT_COMPILER_RELEASE >= 400
#include <objc/NXCType.h>
#else /*  NX_CURRENT_COMPILER_RELEASE < 400 */
#include <appkit/NXCType.h>
#endif /*  NX_CURRENT_COMPILER_RELEASE >= 400 */
d495 3
a497 6
#define MEM_SIZE Size_t

/* This comes after <stdlib.h> so we don't try to change the standard
 * library prototypes; we'll use our own in proto.h instead. */

#ifdef MYMALLOC
d499 2
a500 28
#   ifdef HIDEMYMALLOC
#	define malloc  Mymalloc
#	define calloc  Mycalloc
#	define realloc Myrealloc
#	define free    Myfree
Malloc_t Mymalloc _((MEM_SIZE nbytes));
Malloc_t Mycalloc _((MEM_SIZE elements, MEM_SIZE size));
Malloc_t Myrealloc _((Malloc_t where, MEM_SIZE nbytes));
Free_t   Myfree _((Malloc_t where));
#   endif
#   ifdef EMBEDMYMALLOC
#	define malloc  Perl_malloc
#	define calloc  Perl_calloc
#	define realloc Perl_realloc
/* VMS' external symbols are case-insensitive, and there's already a */
/* perl_free in perl.h */
#ifdef VMS
#	define free    Perl_myfree
#else
#	define free    Perl_free
#endif
Malloc_t Perl_malloc _((MEM_SIZE nbytes));
Malloc_t Perl_calloc _((MEM_SIZE elements, MEM_SIZE size));
Malloc_t Perl_realloc _((Malloc_t where, MEM_SIZE nbytes));
#ifdef VMS
Free_t   Perl_myfree _((Malloc_t where));
#else
Free_t   Perl_free _((Malloc_t where));
a501 1
#   endif
d503 1
a503 10
#   undef safemalloc
#   undef safecalloc
#   undef saferealloc
#   undef safefree
#   define safemalloc  malloc
#   define safecalloc  calloc
#   define saferealloc realloc
#   define safefree    free

#endif /* MYMALLOC */
d518 45
d575 1
a575 1
        extern char * memcpy _((char*, char*, int));
d591 1
a591 1
	extern char *memset _((char*, int, int));
d617 1
a617 1
	extern int memcmp _((char*, char*, int));
d641 6
a729 1
#  define ERRHV (thr->errhv)
a733 1
#  define ERRHV GvHV(PL_errgv)
d738 2
d741 5
a745 1
	extern int errno;     /* ANSI allows errno to be an lvalue expr */
d750 1
a750 1
	char *strerror _((int,...));
d753 1
a753 1
	char *strerror _((int));
d796 2
a797 1
#   if defined(NeXT) && defined(I_SYS_DIR) /* NeXT needs dirent + sys/dir.h */
d827 4
d909 24
a932 6
#   define S_IRGRP (S_IRUSR>>3)
#   define S_IWGRP (S_IWUSR>>3)
#   define S_IXGRP (S_IXUSR>>3)
#   define S_IROTH (S_IRUSR>>6)
#   define S_IWOTH (S_IWUSR>>6)
#   define S_IXOTH (S_IXUSR>>6)
d943 24
d979 1
a979 8
/*  XXX QUAD stuff is not currently supported on most systems.
    Specifically, perl internals don't support long long.  Among
    the many problems is that some compilers support long long,
    but the underlying library functions (such as sprintf) don't.
    Some things do work (such as quad pack/unpack on convex);
    also some systems use long long for the fpos_t typedef.  That
    seems to work too.

d985 121
a1105 2
#ifdef cray
#   define Quad_t int
d1107 16
a1122 2
#   ifdef convex
#	define Quad_t long long
d1124 7
a1130 3
#	if LONGSIZE == 8
#	    define Quad_t long
#	endif
d1132 2
d1136 4
a1139 7
/* XXX Experimental set-up for long long.  Just add -DUSE_LONG_LONG
   to your ccflags.  --Andy Dougherty   4/1998
*/
#ifdef USE_LONG_LONG
#  if defined(HAS_LONG_LONG) && LONGLONGSIZE == 8
#    define Quad_t long long
#  endif
d1142 50
a1191 15
#ifdef Quad_t
#   define HAS_QUAD
    typedef Quad_t IV;
    typedef unsigned Quad_t UV;
#   define IV_MAX PERL_QUAD_MAX
#   define IV_MIN PERL_QUAD_MIN
#   define UV_MAX PERL_UQUAD_MAX
#   define UV_MIN PERL_UQUAD_MIN
#else
    typedef long IV;
    typedef unsigned long UV;
#   define IV_MAX PERL_LONG_MAX
#   define IV_MIN PERL_LONG_MIN
#   define UV_MAX PERL_ULONG_MAX
#   define UV_MIN PERL_ULONG_MIN
d1363 1
a1363 1
#ifdef HAS_QUAD
a1394 1
typedef struct condop CONDOP;
d1397 1
a1397 1
typedef struct gvop GVOP;
a1400 1
typedef struct Outrec Outrec;
a1401 3
#ifndef __BORLANDC__
typedef struct ff FF;		/* XXX not defined anywhere, should go? */
#endif
d1430 2
d1435 102
a1536 4
#ifdef PERL_OBJECT
typedef I32 (*filter_t) _((CPerlObj*, int, SV *, int));
#else
typedef I32 (*filter_t) _((int, SV *, int));
d1539 3
a1541 3
#define FILTER_READ(idx, sv, len)  filter_read(idx, sv, len)
#define FILTER_DATA(idx)	   (AvARRAY(PL_rsfp_filters)[idx])
#define FILTER_ISREADER(idx)	   (idx >= AvFILLp(PL_rsfp_filters))
d1562 9
a1570 1
#         include "unixish.h"
d1577 24
a1600 2
#ifndef FUNC_NAME_TO_PTR
#define FUNC_NAME_TO_PTR(name)		name
d1610 2
a1611 1
#ifdef USE_THREADS
d1615 1
a1615 1

d1627 1
a1627 1
#          ifdef NeXT
d1635 3
a1637 1
#          include <pthread.h>
d1646 1
a1646 1
#endif /* USE_THREADS */
d1648 3
a1651 1
  
d1655 1
a1655 1
	((I32)PL_statusvalue_vms == -1 ? 44 : PL_statusvalue_vms)
d1701 64
d1785 12
d1805 2
a1806 1
    void	(CPERLscope(*any_dptr)) _((void*));
d1813 1
a1813 1
#define ARGSproto void
d1816 8
a1823 3
/* Work around some cygwin32 problems with importing global symbols */
#if defined(CYGWIN32) && defined(DLLIMPORT) 
#   include "cw32imp.h"
a1824 1

d1831 1
a1831 1
#include "opcode.h"
d1838 2
a1839 2
#include "bytecode.h"
#include "byterun.h"
d1860 2
d1864 4
a1867 24
#ifdef PERL_OBJECT
struct magic_state {
    SV* mgs_sv;
    U32 mgs_flags;
};
typedef struct magic_state MGS;

typedef struct {
    I32 len_min;
    I32 len_delta;
    I32 pos_min;
    I32 pos_delta;
    SV *last_found;
    I32 last_end;			/* min value, <0 unless valid. */
    I32 last_start_min;
    I32 last_start_max;
    SV **longest;			/* Either &l_fixed, or &l_float. */
    SV *longest_fixed;
    I32 offset_fixed;
    SV *longest_float;
    I32 offset_float_min;
    I32 offset_float_max;
    I32 flags;
} scan_data_t;
a1869 1
#endif /* PERL_OBJECT */
d1871 11
a1881 4
/* work around some libPW problems */
#ifdef DOINIT
EXT char Error[1];
#endif
d1946 3
a1948 4
EXTERN_C U32 cast_ulong _((double));
#define U_S(what) ((U16)cast_ulong((double)(what)))
#define U_I(what) ((unsigned int)cast_ulong((double)(what)))
#define U_L(what) (cast_ulong((double)(what)))
d1956 3
a1958 8
START_EXTERN_C
I32 cast_i32 _((double));
IV cast_iv _((double));
UV cast_uv _((double));
END_EXTERN_C
#define I_32(what) (cast_i32((double)(what)))
#define I_V(what) (cast_iv((double)(what)))
#define U_V(what) (cast_uv((double)(what)))
d1961 8
a1968 5
struct Outrec {
    I32		o_lines;
    char	*o_str;
    U32		o_len;
};
d1974 5
a1978 2
#ifndef TMPPATH
#  define TMPPATH "/tmp/perl-eXXXXXX"
d1981 9
a1989 5
#ifndef __cplusplus
Uid_t getuid _((void));
Uid_t geteuid _((void));
Gid_t getgid _((void));
Gid_t getegid _((void));
a1992 3
#ifndef Perl_debug_log
#define Perl_debug_log	PerlIO_stderr()
#endif
d2004 8
a2011 1
#define DEBUG_m(a) if (PL_curinterp && PL_debug & 128)	a
d2051 1
a2051 1
	    croak("Assertion failed: file \"%s\", line %d",		\
d2053 1
a2053 1
	    PerlProc_exit(1);							\
d2058 2
a2059 2
    I32 (*uf_val)_((IV, SV*));
    I32 (*uf_set)_((IV, SV*));
d2065 4
a2068 2
char *mktemp _((char*));
double atof _((const char*));
d2075 1
a2075 1
#ifdef OEMVS
d2089 11
a2099 11
	    double exp _((double));
	    double log _((double));
	    double log10 _((double));
	    double sqrt _((double));
	    double frexp _((double,int*));
	    double ldexp _((double,int));
	    double modf _((double,double*));
	    double sin _((double));
	    double cos _((double));
	    double atan2 _((double,double));
	    double pow _((double,double));
d2104 1
a2104 1
#  ifdef __NeXT__ /* or whatever catches all NeXTs */
d2107 4
a2110 4
#    if !defined(WIN32) || !defined(HAVE_DES_FCRYPT)
char *crypt _((const char*, const char*));
#    endif /* !WIN32 && !HAVE_CRYPT_SOURCE */
#  endif /* !__NeXT__ */
d2113 1
a2113 1
char *getenv _((const char*));
d2115 3
a2117 1
Off_t lseek _((int,Off_t,int));
d2119 1
a2119 1
char *getlogin _((void));
d2124 1
a2124 1
I32 unlnk _((char*));
d2142 1
a2142 1
typedef Signal_t (*Sighandler_t) _((int));
d2159 1
a2159 1
# define RUNOPS_DEFAULT runops_debug
d2162 1
a2162 1
# define RUNOPS_DEFAULT runops_standard
d2188 2
a2189 12
/*
 * These need prototyping here because <proto.h> isn't
 * included until after runops is initialised.
 */

#ifndef PERL_OBJECT
typedef int runops_proc_t _((void));
int runops_standard _((void));
#ifdef DEBUGGING
int runops_debug _((void));
#endif
#endif  /* PERL_OBJECT */
d2194 20
a2213 5
/* VMS doesn't use environ array and NeXT has problems with crt0.o globals */
#if !defined(VMS) && !(defined(NeXT) && defined(__DYNAMIC__))
#if !defined(DONT_DECLARE_STD) \
	|| (defined(__svr4__) && defined(__GNUC__) && defined(sun)) \
	|| defined(__sgi) || defined(__DGUX)
d2215 2
a2217 2
#else
#  if defined(NeXT) && defined(__DYNAMIC__)
d2219 1
a2219 11
#  include <mach-o/dyld.h>
EXT char *** environ_pointer;
#  define environ (*environ_pointer)
#  endif
#endif /* environ processing */


/* for tmp use in stupid debuggers */
EXT int *	di;
EXT short *	ds;
EXT char *	dc;
d2222 3
a2224 3
EXTCONST char warn_uninit[]
  INIT("Use of uninitialized value");
EXTCONST char warn_nosemi[]
d2226 1
a2226 1
EXTCONST char warn_reserved[]
d2228 1
a2228 1
EXTCONST char warn_nl[]
d2230 1
a2230 1
EXTCONST char no_wrongref[]
d2232 1
a2232 1
EXTCONST char no_symref[]
d2234 1
a2234 1
EXTCONST char no_usym[]
d2236 1
a2236 1
EXTCONST char no_aelem[]
d2238 1
a2238 1
EXTCONST char no_helem[]
d2240 1
a2240 1
EXTCONST char no_modify[]
d2242 1
a2242 1
EXTCONST char no_mem[]
d2244 1
a2244 1
EXTCONST char no_security[]
d2246 1
a2246 1
EXTCONST char no_sock_func[]
d2248 1
a2248 1
EXTCONST char no_dir_func[]
d2250 1
a2250 1
EXTCONST char no_func[]
d2252 1
a2252 1
EXTCONST char no_myglob[]
d2255 4
d2260 5
a2264 9
EXT char *sig_name[] = { SIG_NAME };
EXT int   sig_num[]  = { SIG_NUM };
EXT SV	* psig_ptr[sizeof(sig_num)/sizeof(*sig_num)];
EXT SV  * psig_name[sizeof(sig_num)/sizeof(*sig_num)];
#else
EXT char *sig_name[];
EXT int   sig_num[];
EXT SV  * psig_ptr[];
EXT SV  * psig_name[];
d2271 1
a2271 1
EXT unsigned char fold[] = { /* fast EBCDIC case folding table */
d2306 1
a2306 1
EXTCONST  unsigned char fold[] = {
d2342 1
a2342 1
EXTCONST unsigned char fold[];
d2346 1
a2346 1
EXT unsigned char fold_locale[] = {
d2381 1
a2381 1
EXT unsigned char fold_locale[];
d2386 1
a2386 1
EXT unsigned char freq[] = {/* EBCDIC frequencies for mixed English/C */
d2421 1
a2421 1
EXTCONST unsigned char freq[] = {	/* letter frequencies for mixed English/C */
d2457 1
a2457 1
EXTCONST unsigned char freq[];
d2462 1
a2462 1
EXTCONST char* block_type[] = {
d2471 1
a2471 1
EXTCONST char* block_type[];
d2475 2
d2492 2
d2523 1
a2523 1
    want_vtbl_amagicelem
d2525 1
a2525 2
    ,
    want_vtbl_mutex
d2527 3
a2531 1

d2534 1
d2537 4
d2557 3
d2562 2
a2563 2
#define RsSIMPLE(sv)  (SvOK(sv) && SvCUR(sv))
#define RsPARA(sv)    (SvOK(sv) && ! SvCUR(sv))
d2567 22
a2588 13
#ifdef PERL_OBJECT
typedef regexp*(CPerlObj::*regcomp_t) _((char* exp, char* xend, PMOP* pm));
typedef I32 (CPerlObj::*regexec_t) _((regexp* prog, char* stringarg,
				      char* strend, char* strbeg,
				      I32 minend, SV* screamer, void* data,
				      U32 flags));
#else
typedef regexp*(*regcomp_t) _((char* exp, char* xend, PMOP* pm));
typedef I32 (*regexec_t) _((regexp* prog, char* stringarg, char* strend, char*
			    strbeg, I32 minend, SV* screamer, void* data, 
			    U32 flags));

#endif
d2592 1
d2598 1
a2598 5
#ifdef PERL_OBJECT
    void (*fn) _((CPerlObj*, void*));
#else
    void (*fn) _((void*));
#endif
a2601 18
#ifdef PERL_OBJECT
extern "C" CPerlObj* perl_alloc _((IPerlMem*, IPerlEnv*, IPerlStdIO*, IPerlLIO*, IPerlDir*, IPerlSock*, IPerlProc*));

typedef int (CPerlObj::*runops_proc_t) _((void));
#undef EXT
#define EXT
#undef EXTCONST
#define EXTCONST
#undef INIT
#define INIT(x)

class CPerlObj {
public:
	CPerlObj(IPerlMem*, IPerlEnv*, IPerlStdIO*, IPerlLIO*, IPerlDir*, IPerlSock*, IPerlProc*);
	void Init(void);
	void* operator new(size_t nSize, IPerlMem *pvtbl);
#endif /* PERL_OBJECT */

d2604 1
a2604 1
#include "perlvars.h"
d2607 1
a2607 1
#ifdef PERL_CORE
d2610 2
a2611 2
#else /* PERL_CORE */
#if !defined(__GNUC__) || !defined(WIN32)
d2613 1
a2613 1
#endif /* WIN32 */
d2615 3
a2617 2
#define PL_Vars (*((PL_VarsPtr) ? PL_VarsPtr : (PL_VarsPtr =  Perl_GetVars())))
#endif /* PERL_CORE */
d2620 1
a2620 1
#ifdef MULTIPLICITY
d2628 9
a2636 4
#ifndef USE_THREADS
#include "thrdvar.h"
#endif
#include "intrpvar.h"
d2643 1
a2643 1
#endif
d2663 1
d2669 23
d2694 7
a2700 6
#ifdef EMBED
#define Perl_sv_setptrobj(rv,ptr,name) Perl_sv_setref_iv(rv,name,(IV)ptr)
#define Perl_sv_setptrref(rv,ptr) Perl_sv_setref_iv(rv,Nullch,(IV)ptr)
#else
#define sv_setptrobj(rv,ptr,name) sv_setref_iv(rv,name,(IV)ptr)
#define sv_setptrref(rv,ptr) sv_setref_iv(rv,Nullch,(IV)ptr)
d2705 3
a2707 1
#include "embedvar.h"
d2715 1
d2719 2
a2720 6
#ifndef PERL_GLOBAL_STRUCT
#include "perlvars.h"
#endif

#ifndef MULTIPLICITY

d2725 1
a2725 1

d2729 1
a2729 43
/* from perly.c */
#undef  yydebug
#undef  yynerrs
#undef  yyerrflag
#undef  yychar
#undef  yyssp
#undef  yyvsp
#undef  yyval
#undef  yylval
#define yydebug	    PL_yydebug
#define yynerrs	    PL_yynerrs
#define yyerrflag   PL_yyerrflag
#define yychar	    PL_yychar
#define yyssp	    PL_yyssp
#define yyvsp	    PL_yyvsp
#define yyval	    PL_yyval
#define yylval	    PL_yylval
PERLVAR(yydebug,		int)
PERLVAR(yynerrs,		int)
PERLVAR(yyerrflag,		int)
PERLVAR(yychar,			int)
PERLVAR(yyssp,			short*)
PERLVAR(yyvsp,			YYSTYPE*)
PERLVAR(yyval,			YYSTYPE)
PERLVAR(yylval,			YYSTYPE)

#define efloatbuf		PL_efloatbuf
#define efloatsize		PL_efloatsize
PERLVAR(efloatbuf,		char *)
PERLVAR(efloatsize,		STRLEN)

#define glob_index		PL_glob_index
#define srand_called	PL_srand_called
#define uudmap			PL_uudmap
#define bitcount		PL_bitcount
#define filter_debug	PL_filter_debug
PERLVAR(glob_index,		int)
PERLVAR(srand_called,	bool)
PERLVAR(uudmap[256],	char)
PERLVAR(bitcount,		char*)
PERLVAR(filter_debug,	int)
PERLVAR(super_bufptr,	char*)	/* PL_bufptr that was */
PERLVAR(super_bufend,	char*)	/* PL_bufend that was */
d2731 8
a2738 7
/*
 * The following is a buffer where new variables must
 * be defined to maintain binary compatibility with PERL_OBJECT
 * for 5.005
 */
PERLVAR(object_compatibility[30],	char)
};
a2739 3
#include "objpp.h"
#ifdef DOINIT
#include "INTERN.h"
d2741 3
a2743 2
#include "EXTERN.h"
#endif
d2746 7
d2755 1
d2759 1
a2759 11
#if defined(HASATTRIBUTE) && defined(WIN32)
/*
 * This provides a layer of functions and macros to ensure extensions will
 * get to use the same RTL functions as the core.
 * It has to go here or #define of printf messes up __attribute__
 * stuff in proto.h  
 */
#ifndef PERL_OBJECT
#  include <win32iop.h>
#endif  /* PERL_OBJECT */
#endif	/* WIN32 */
d2763 3
a2765 3
EXT MGVTBL vtbl_sv =	{magic_get,
				magic_set,
					magic_len,
d2767 2
a2768 2
EXT MGVTBL vtbl_env =	{0,	magic_set_all_env,
				0,	magic_clear_all_env,
d2770 2
a2771 2
EXT MGVTBL vtbl_envelem =	{0,	magic_setenv,
					0,	magic_clearenv,
d2773 4
a2776 4
EXT MGVTBL vtbl_sig =	{0,	0,		 0, 0, 0};
EXT MGVTBL vtbl_sigelem =	{magic_getsig,
					magic_setsig,
					0,	magic_clearsig,
d2778 1
a2778 1
EXT MGVTBL vtbl_pack =	{0,	0,	magic_sizepack,	magic_wipepack,
d2780 3
a2782 3
EXT MGVTBL vtbl_packelem =	{magic_getpack,
				magic_setpack,
					0,	magic_clearpack,
d2784 1
a2784 1
EXT MGVTBL vtbl_dbline =	{0,	magic_setdbline,
d2786 2
a2787 2
EXT MGVTBL vtbl_isa =	{0,	magic_setisa,
					0,	magic_setisa,
d2789 1
a2789 1
EXT MGVTBL vtbl_isaelem =	{0,	magic_setisa,
d2791 2
a2792 2
EXT MGVTBL vtbl_arylen =	{magic_getarylen,
				magic_setarylen,
d2794 2
a2795 2
EXT MGVTBL vtbl_glob =	{magic_getglob,
				magic_setglob,
d2797 1
a2797 1
EXT MGVTBL vtbl_mglob =	{0,	magic_setmglob,
d2799 2
a2800 2
EXT MGVTBL vtbl_nkeys =	{magic_getnkeys,
				magic_setnkeys,
d2802 1
a2802 1
EXT MGVTBL vtbl_taint =	{magic_gettaint,magic_settaint,
d2804 1
a2804 1
EXT MGVTBL vtbl_substr =	{magic_getsubstr, magic_setsubstr,
d2806 2
a2807 2
EXT MGVTBL vtbl_vec =	{magic_getvec,
				magic_setvec,
d2809 2
a2810 2
EXT MGVTBL vtbl_pos =	{magic_getpos,
				magic_setpos,
d2812 1
a2812 1
EXT MGVTBL vtbl_bm =	{0,	magic_setbm,
d2814 1
a2814 1
EXT MGVTBL vtbl_fm =	{0,	magic_setfm,
d2816 2
a2817 2
EXT MGVTBL vtbl_uvar =	{magic_getuvar,
				magic_setuvar,
d2820 1
a2820 1
EXT MGVTBL vtbl_mutex =	{0,	0,	0,	0,	magic_mutexfree};
d2822 1
a2822 1
EXT MGVTBL vtbl_defelem = {magic_getdefelem,magic_setdefelem,
d2825 3
a2827 1
EXT MGVTBL vtbl_regexp = {0,0,0,0, magic_freeregexp};
d2830 2
a2831 2
EXT MGVTBL vtbl_collxfrm = {0,
				magic_setcollxfrm,
d2835 7
a2841 6
#ifdef OVERLOAD
EXT MGVTBL vtbl_amagic =       {0,     magic_setamagic,
                                        0,      0,      magic_setamagic};
EXT MGVTBL vtbl_amagicelem =   {0,     magic_setamagic,
                                        0,      0,      magic_setamagic};
#endif /* OVERLOAD */
d2845 21
a2865 21
EXT MGVTBL vtbl_sv;
EXT MGVTBL vtbl_env;
EXT MGVTBL vtbl_envelem;
EXT MGVTBL vtbl_sig;
EXT MGVTBL vtbl_sigelem;
EXT MGVTBL vtbl_pack;
EXT MGVTBL vtbl_packelem;
EXT MGVTBL vtbl_dbline;
EXT MGVTBL vtbl_isa;
EXT MGVTBL vtbl_isaelem;
EXT MGVTBL vtbl_arylen;
EXT MGVTBL vtbl_glob;
EXT MGVTBL vtbl_mglob;
EXT MGVTBL vtbl_nkeys;
EXT MGVTBL vtbl_taint;
EXT MGVTBL vtbl_substr;
EXT MGVTBL vtbl_vec;
EXT MGVTBL vtbl_pos;
EXT MGVTBL vtbl_bm;
EXT MGVTBL vtbl_fm;
EXT MGVTBL vtbl_uvar;
d2868 1
a2868 1
EXT MGVTBL vtbl_mutex;
d2871 4
a2874 2
EXT MGVTBL vtbl_defelem;
EXT MGVTBL vtbl_regexp;
d2877 1
a2877 1
EXT MGVTBL vtbl_collxfrm;
d2880 4
a2883 4
#ifdef OVERLOAD
EXT MGVTBL vtbl_amagic;
EXT MGVTBL vtbl_amagicelem;
#endif /* OVERLOAD */
d2887 38
a2924 1
#ifdef OVERLOAD
a2925 1
#define NofAMmeth 58
d2927 1
a2927 1
EXTCONST char * AMG_names[NofAMmeth] = {
d2956 4
a2959 1
  "=",		"neg"
d2962 1
a2962 1
EXTCONST char * AMG_names[NofAMmeth];
d2965 2
a2990 31
enum {
  fallback_amg,	abs_amg,
  bool__amg,	nomethod_amg,
  string_amg,	numer_amg,
  add_amg,	add_ass_amg,
  subtr_amg,	subtr_ass_amg,
  mult_amg,	mult_ass_amg,
  div_amg,	div_ass_amg,
  modulo_amg,	modulo_ass_amg,
  pow_amg,	pow_ass_amg,
  lshift_amg,	lshift_ass_amg,
  rshift_amg,	rshift_ass_amg,
  band_amg,	band_ass_amg,
  bor_amg,	bor_ass_amg,
  bxor_amg,	bxor_ass_amg,
  lt_amg,	le_amg,
  gt_amg,	ge_amg,
  eq_amg,	ne_amg,
  ncmp_amg,	scmp_amg,
  slt_amg,	sle_amg,
  sgt_amg,	sge_amg,
  seq_amg,	sne_amg,
  not_amg,	compl_amg,
  inc_amg,	dec_amg,
  atan2_amg,	cos_amg,
  sin_amg,	exp_amg,
  log_amg,	sqrt_amg,
  repeat_amg,   repeat_ass_amg,
  concat_amg,	concat_ass_amg,
  copy_amg,	neg_amg
};
d3023 16
a3038 12
#endif /* OVERLOAD */

#define PERLDB_ALL	0x3f		/* No _NONAME, _GOTO */
#define PERLDBf_SUB	0x01		/* Debug sub enter/exit. */
#define PERLDBf_LINE	0x02		/* Keep line #. */
#define PERLDBf_NOOPT	0x04		/* Switch off optimizations. */
#define PERLDBf_INTER	0x08		/* Preserve more data for
					   later inspections.  */
#define PERLDBf_SUBLINE	0x10		/* Keep subr source lines. */
#define PERLDBf_SINGLE	0x20		/* Start with single-step on. */
#define PERLDBf_NONAME	0x40		/* For _SUB: no name of the subr. */
#define PERLDBf_GOTO	0x80		/* Report goto: call DB::goto. */
d3048 2
d3056 2
a3057 2
	if (! PL_numeric_standard)			\
	    perl_set_numeric_standard();	\
d3063 1
a3063 1
	    perl_set_numeric_local();		\
d3066 8
d3076 6
a3081 2
#define SET_NUMERIC_STANDARD()  /**/
#define SET_NUMERIC_LOCAL()     /**/
d3085 42
d3132 1
d3136 17
d3158 28
d3206 3
a3208 3
	int val;
	struct semid_ds *buf;
	unsigned short *array;
d3212 9
d3224 5
a3228 1
#           define Semctl(id, num, cmd, semun) semctl(id, num, cmd, semun.buf)
d3231 24
a3254 3
#   ifndef Semctl	/* Place our bets on the semun horse. */
#       define Semctl(id, num, cmd, semun) semctl(id, num, cmd, semun)
#   endif
d3268 28
d3298 28
@


1.2
log
@perl 5.004_04
@
text
@d3 1
a3 1
 *    Copyright (c) 1987-1997, Larry Wall
d27 109
d141 25
d189 4
d203 1
a203 1
#ifndef BYTEORDER
d212 6
d235 1
a235 1
#if defined(__cplusplus) || defined(WIN32)
d249 5
a253 5
#define TAINT		(tainted = TRUE)
#define TAINT_NOT	(tainted = FALSE)
#define TAINT_IF(c)	if (c) { tainted = TRUE; }
#define TAINT_ENV()	if (tainting) { taint_env(); }
#define TAINT_PROPER(s)	if (tainting) { taint_proper(no_security, s); }
d325 1
a325 1
#include "perlio.h"
d376 2
d386 1
a386 1
#	define realloc Myremalloc
d388 4
d397 5
d403 9
a424 2
#define MEM_SIZE Size_t

d526 4
a579 6
#ifndef HAS_MKFIFO
#  ifndef mkfifo
#    define mkfifo(path, mode) (mknod((path), (mode) | S_IFIFO, 0))
#  endif
#endif /* !HAS_MKFIFO */

d594 1
a594 1
#   define SETERRNO(errcode,vmserrcode) errno = (errcode)
d597 12
d816 1
a816 1
#	if BYTEORDER > 0xFFFF
d822 9
d917 5
a921 1
#    define PERL_USHORT_MAX       ((unsigned short)~(unsigned)0)
d931 5
a935 1
#    define PERL_SHORT_MAX      ((short) (PERL_USHORT_MAX >> 1))
d945 5
a949 1
#    define PERL_SHORT_MIN        (-PERL_SHORT_MAX - ((3 & -1) == 3))
d1069 1
a1069 1
typedef struct context CONTEXT;
d1092 3
d1096 2
d1099 2
a1100 2
#define FILTER_DATA(idx)	   (AvARRAY(rsfp_filters)[idx])
#define FILTER_ISREADER(idx)	   (idx >= AvFILL(rsfp_filters))
d1115 9
a1123 1
#     include "unixish.h"
d1126 4
d1131 44
d1177 1
a1177 1
#   define STATUS_NATIVE	statusvalue_vms
d1179 1
a1179 1
	((I32)statusvalue_vms == -1 ? 44 : statusvalue_vms)
d1182 7
a1188 7
	    statusvalue_vms = (n);					\
	    if ((I32)statusvalue_vms == -1)				\
		statusvalue = -1;					\
	    else if (statusvalue_vms & STS$M_SUCCESS)			\
		statusvalue = 0;					\
	    else if ((statusvalue_vms & STS$M_SEVERITY) == 0)		\
		statusvalue = 1 << 8;					\
d1190 1
a1190 1
		statusvalue = (statusvalue_vms & STS$M_SEVERITY) << 8;	\
d1192 1
a1192 1
#   define STATUS_POSIX	statusvalue
d1200 4
a1203 4
	    statusvalue = (n);				\
	    if (statusvalue != -1) {			\
		statusvalue &= 0xFFFF;			\
		statusvalue_vms = statusvalue ? 44 : 1;	\
d1205 1
a1205 1
	    else statusvalue_vms = -1;			\
d1207 2
a1208 2
#   define STATUS_ALL_SUCCESS	(statusvalue = 0, statusvalue_vms = 1)
#   define STATUS_ALL_FAILURE	(statusvalue = 1, statusvalue_vms = 44)
d1213 1
a1213 1
#   define STATUS_POSIX		statusvalue
d1216 3
a1218 3
	    statusvalue = (n);		\
	    if (statusvalue != -1)	\
		statusvalue &= 0xFFFF;	\
d1221 2
a1222 2
#   define STATUS_ALL_SUCCESS	(statusvalue = 0)
#   define STATUS_ALL_FAILURE	(statusvalue = 1)
d1245 3
d1253 1
a1253 1
    void	(*any_dptr) _((void*));
d1255 7
d1281 51
d1384 1
a1384 1
# if BYTEORDER == 0x4321
d1401 1
a1401 7
#  ifdef __cplusplus
    extern "C" {
#  endif
U32 cast_ulong _((double));
#  ifdef __cplusplus
    }
#  endif
d1412 1
a1412 3
#  ifdef __cplusplus
    extern "C" {
#  endif
d1416 1
a1416 3
#  ifdef __cplusplus
    }
#  endif
d1447 1
d1450 22
a1471 17
#define DEBUG(a)   if (debug)		a
#define DEBUG_p(a) if (debug & 1)	a
#define DEBUG_s(a) if (debug & 2)	a
#define DEBUG_l(a) if (debug & 4)	a
#define DEBUG_t(a) if (debug & 8)	a
#define DEBUG_o(a) if (debug & 16)	a
#define DEBUG_c(a) if (debug & 32)	a
#define DEBUG_P(a) if (debug & 64)	a
#define DEBUG_m(a) if (curinterp && debug & 128)	a
#define DEBUG_f(a) if (debug & 256)	a
#define DEBUG_r(a) if (debug & 512)	a
#define DEBUG_x(a) if (debug & 1024)	a
#define DEBUG_u(a) if (debug & 2048)	a
#define DEBUG_L(a) if (debug & 4096)	a
#define DEBUG_H(a) if (debug & 8192)	a
#define DEBUG_X(a) if (debug & 16384)	a
#define DEBUG_D(a) if (debug & 32768)	a
d1487 1
a1487 1
#define DEBUG_L(a)
d1491 1
d1500 1
a1500 1
	    exit(1);							\
d1520 4
d1526 1
d1533 1
a1533 3
#   ifdef __cplusplus
	extern "C" {
#   endif
d1545 1
a1545 3
#   ifdef __cplusplus
	};
#   endif
d1549 1
a1549 1
#ifdef __NeXT__ /* or whatever catches all NeXTs */
d1551 2
a1552 1
#else
d1554 4
a1557 3
#endif
#ifndef DONT_DECLARE_STD
#ifndef getenv
d1559 1
a1559 1
#endif
d1561 1
a1561 1
#endif
d1563 1
a1563 1
#endif
d1569 1
a1569 1
#define UNLINK unlink
d1602 23
d1626 2
a1627 1
# define PAD_SV(po) curpad[po]
a1629 3
/****************/
/* Truly global */
/****************/
d1631 16
a1646 2
/* global state */
EXT PerlInterpreter *	curinterp;	/* currently running interpreter */
d1649 3
a1651 1
#ifndef DONT_DECLARE_STD
a1662 63
EXT int		uid;		/* current real user id */
EXT int		euid;		/* current effective user id */
EXT int		gid;		/* current real group id */
EXT int		egid;		/* current effective group id */
EXT bool	nomemok;	/* let malloc context handle nomem */
EXT U32		an;		/* malloc sequence number */
EXT U32		cop_seqmax;	/* statement sequence number */
EXT U16		op_seqmax;	/* op sequence number */
EXT U32		evalseq;	/* eval sequence number */
EXT U32		sub_generation;	/* inc to force methods to be looked up again */
EXT char **	origenviron;
EXT U32		origalen;
EXT HV *	pidstatus;	/* pid-to-status mappings for waitpid */
EXT U32 *	profiledata;
EXT int		maxo INIT(MAXO);/* Number of ops */
EXT char *	osname;		/* operating system */
EXT char *	sh_path INIT(SH_PATH); /* full path of shell */

EXT XPV*	xiv_arenaroot;	/* list of allocated xiv areas */
EXT IV **	xiv_root;	/* free xiv list--shared by interpreters */
EXT double *	xnv_root;	/* free xnv list--shared by interpreters */
EXT XRV *	xrv_root;	/* free xrv list--shared by interpreters */
EXT XPV *	xpv_root;	/* free xpv list--shared by interpreters */
EXT HE *	he_root;	/* free he list--shared by interpreters */
EXT char *	nice_chunk;	/* a nice chunk of memory to reuse */
EXT U32		nice_chunk_size;/* how nice the chunk of memory is */

/* Stack for currently executing thread--context switch must handle this.     */
EXT SV **	stack_base;	/* stack->array_ary */
EXT SV **	stack_sp;	/* stack pointer now */
EXT SV **	stack_max;	/* stack->array_ary + stack->array_max */

/* likewise for these */

EXT OP *	op;		/* current op--oughta be in a global register */

EXT I32 *	scopestack;	/* blocks we've entered */
EXT I32		scopestack_ix;
EXT I32		scopestack_max;

EXT ANY*	savestack;	/* to save non-local values on */
EXT I32		savestack_ix;
EXT I32		savestack_max;

EXT OP **	retstack;	/* returns we've pushed */
EXT I32		retstack_ix;
EXT I32		retstack_max;

EXT I32 *	markstack;	/* stackmarks we're remembering */
EXT I32 *	markstack_ptr;	/* stackmarks we're remembering */
EXT I32 *	markstack_max;	/* stackmarks we're remembering */

EXT SV **	curpad;

/* temp space */
EXT SV *	Sv;
EXT XPV *	Xpv;
EXT char	tokenbuf[256];
EXT struct stat	statbuf;
#ifdef HAS_TIMES
EXT struct tms	timesbuf;
#endif
EXT STRLEN na;		/* for use in SvPV when length is Not Applicable */
a1669 6
EXTCONST char *	Yes INIT("1");
EXTCONST char *	No INIT("");
EXTCONST char *	hexdigit INIT("0123456789abcdef0123456789ABCDEFx");
EXTCONST char *	patleave INIT("\\.^$@@dDwWsSbB+*?|()-nrtfeaxc0123456789[{]}");
EXTCONST char *	vert INIT("|");

a1702 8
EXT SV		sv_undef;
EXT SV		sv_no;
EXT SV		sv_yes;
#ifdef CSH
    EXT char *	cshname INIT(CSH);
    EXT I32	cshlen;
#endif

d1718 36
d1788 1
d1833 36
d1903 1
d1941 30
a1970 60
EXT U32		lex_state;	/* next token is determined */
EXT U32		lex_defer;	/* state after determined token */
EXT expectation	lex_expect;	/* expect after determined token */
EXT I32		lex_brackets;	/* bracket count */
EXT I32		lex_formbrack;	/* bracket count at outer format level */
EXT I32		lex_fakebrack;	/* outer bracket is mere delimiter */
EXT I32		lex_casemods;	/* casemod count */
EXT I32		lex_dojoin;	/* doing an array interpolation */
EXT I32		lex_starts;	/* how many interps done on level */
EXT SV *	lex_stuff;	/* runtime pattern from m// or s/// */
EXT SV *	lex_repl;	/* runtime replacement from s/// */
EXT OP *	lex_op;		/* extra info to pass back on op */
EXT OP *	lex_inpat;	/* in pattern $) and $| are special */
EXT I32		lex_inwhat;	/* what kind of quoting are we in */
EXT char *	lex_brackstack;	/* what kind of brackets to pop */
EXT char *	lex_casestack;	/* what kind of case mods in effect */

/* What we know when we're in LEX_KNOWNEXT state. */
EXT YYSTYPE	nextval[5];	/* value of next token, if any */
EXT I32		nexttype[5];	/* type of next token */
EXT I32		nexttoke;

EXT PerlIO * VOL	rsfp INIT(Nullfp);
EXT SV *	linestr;
EXT char *	bufptr;
EXT char *	oldbufptr;
EXT char *	oldoldbufptr;
EXT char *	bufend;
EXT expectation expect INIT(XSTATE);	/* how to interpret ambiguous tokens */
EXT AV * 	rsfp_filters;

EXT I32		multi_start;	/* 1st line of multi-line string */
EXT I32		multi_end;	/* last line of multi-line string */
EXT I32		multi_open;	/* delimiter of said string */
EXT I32		multi_close;	/* delimiter of said string */

EXT GV *	scrgv;
EXT I32		error_count;	/* how many errors so far, max 10 */
EXT I32		subline;	/* line this subroutine began on */
EXT SV *	subname;	/* name of current subroutine */

EXT CV *	compcv;		/* currently compiling subroutine */
EXT AV *	comppad;	/* storage for lexically scoped temporaries */
EXT AV *	comppad_name;	/* variable names for "my" variables */
EXT I32		comppad_name_fill;/* last "introduced" variable offset */
EXT I32		comppad_name_floor;/* start of vars in innermost block */
EXT I32		min_intro_pending;/* start of vars to introduce */
EXT I32		max_intro_pending;/* end of vars to introduce */
EXT I32		padix;		/* max used index in current "register" pad */
EXT I32		padix_floor;	/* how low may inner block reset padix */
EXT I32		pad_reset_pending; /* reset pad on next attempted alloc */
EXT COP		compiling;

EXT I32		thisexpr;	/* name id for nothing_in_common() */
EXT char *	last_uni;	/* position of last named-unary operator */
EXT char *	last_lop;	/* position of last list operator */
EXT OPCODE	last_lop_op;	/* last list operator */
EXT bool	in_my;		/* we're compiling a "my" declaration */
#ifdef FCRYPT
EXT I32		cryptseen;	/* has fast crypt() been initialized? */
d1972 1
a1973 1
EXT U32		hints;		/* various compilation flags */
d1985 6
a1990 38
/**************************************************************************/
/* This regexp stuff is global since it always happens within 1 expr eval */
/**************************************************************************/

EXT char *	regprecomp;	/* uncompiled string. */
EXT char *	regparse;	/* Input-scan pointer. */
EXT char *	regxend;	/* End of input for compile */
EXT I32		regnpar;	/* () count. */
EXT char *	regcode;	/* Code-emit pointer; &regdummy = don't. */
EXT I32		regsize;	/* Code size. */
EXT I32		regnaughty;	/* How bad is this pattern? */
EXT I32		regsawback;	/* Did we see \1, ...? */

EXT char *	reginput;	/* String-input pointer. */
EXT char *	regbol;		/* Beginning of input, for ^ check. */
EXT char *	regeol;		/* End of input, for $ check. */
EXT char **	regstartp;	/* Pointer to startp array. */
EXT char **	regendp;	/* Ditto for endp. */
EXT U32 *	reglastparen;	/* Similarly for lastparen. */
EXT char *	regtill;	/* How far we are required to go. */
EXT U16		regflags;	/* are we folding, multilining? */
EXT char	regprev;	/* char before regbol, \n if none */

EXT bool	do_undump;	/* -u or dump seen? */
EXT VOL U32	debug;

/***********************************************/
/* Global only to current interpreter instance */
/***********************************************/

#ifdef MULTIPLICITY
#define IEXT
#define IINIT(x)
struct interpreter {
#else
#define IEXT EXT
#define IINIT(x) INIT(x)
#endif
d1992 2
a1993 10
/* pseudo environmental stuff */
IEXT int	Iorigargc;
IEXT char **	Iorigargv;
IEXT GV *	Ienvgv;
IEXT GV *	Isiggv;
IEXT GV *	Iincgv;
IEXT char *	Iorigfilename;
IEXT SV *	Idiehook;
IEXT SV *	Iwarnhook;
IEXT SV *	Iparsehook;
d1999 14
a2013 42
/* switches */
IEXT char *	Icddir;
IEXT bool	Iminus_c;
IEXT char	Ipatchlevel[10];
IEXT char **	Ilocalpatches;
IEXT SV *	Inrs;
IEXT char *	Isplitstr IINIT(" ");
IEXT bool	Ipreprocess;
IEXT bool	Iminus_n;
IEXT bool	Iminus_p;
IEXT bool	Iminus_l;
IEXT bool	Iminus_a;
IEXT bool	Iminus_F;
IEXT bool	Idoswitches;
IEXT bool	Idowarn;
IEXT bool	Idoextract;
IEXT bool	Isawampersand;	/* must save all match strings */
IEXT bool	Isawstudy;	/* do fbm_instr on all strings */
IEXT bool	Isawvec;
IEXT bool	Iunsafe;
IEXT char *	Iinplace;
IEXT char *	Ie_tmpname;
IEXT PerlIO *	Ie_fp;
IEXT U32	Iperldb;
	/* This value may be raised by extensions for testing purposes */
IEXT int	Iperl_destruct_level IINIT(0);	/* 0=none, 1=full, 2=full with checks */

/* magical thingies */
IEXT Time_t	Ibasetime;		/* $^T */
IEXT SV *	Iformfeed;		/* $^L */
IEXT char *	Ichopset IINIT(" \n-");	/* $: */
IEXT SV *	Irs;			/* $/ */
IEXT char *	Iofs;			/* $, */
IEXT STRLEN	Iofslen;
IEXT char *	Iors;			/* $\ */
IEXT STRLEN	Iorslen;
IEXT char *	Iofmt;			/* $# */
IEXT I32	Imaxsysfd IINIT(MAXSYSFD); /* top fd to pass to subprocesses */
IEXT int	Imultiline;		/* $*--do strings hold >1 line? */
IEXT I32	Istatusvalue;		/* $? */
#ifdef VMS
IEXT U32	Istatusvalue_vms;
d2016 37
a2052 130
IEXT struct stat Istatcache;		/* _ */
IEXT GV *	Istatgv;
IEXT SV *	Istatname IINIT(Nullsv);

/* shortcuts to various I/O objects */
IEXT GV *	Istdingv;
IEXT GV *	Ilast_in_gv;
IEXT GV *	Idefgv;
IEXT GV *	Iargvgv;
IEXT GV *	Idefoutgv;
IEXT GV *	Iargvoutgv;

/* shortcuts to regexp stuff */
IEXT GV *	Ileftgv;
IEXT GV *	Iampergv;
IEXT GV *	Irightgv;
IEXT PMOP *	Icurpm;		/* what to do \ interps from */
IEXT I32 *	Iscreamfirst;
IEXT I32 *	Iscreamnext;
IEXT I32	Imaxscream IINIT(-1);
IEXT SV *	Ilastscream;

/* shortcuts to misc objects */
IEXT GV *	Ierrgv;

/* shortcuts to debugging objects */
IEXT GV *	IDBgv;
IEXT GV *	IDBline;
IEXT GV *	IDBsub;
IEXT SV *	IDBsingle;
IEXT SV *	IDBtrace;
IEXT SV *	IDBsignal;
IEXT AV *	Ilineary;	/* lines of script for debugger */
IEXT AV *	Idbargs;	/* args to call listed by caller function */

/* symbol tables */
IEXT HV *	Idefstash;	/* main symbol table */
IEXT HV *	Icurstash;	/* symbol table for current package */
IEXT HV *	Idebstash;	/* symbol table for perldb package */
IEXT SV *	Icurstname;	/* name of current package */
IEXT AV *	Ibeginav;	/* names of BEGIN subroutines */
IEXT AV *	Iendav;		/* names of END subroutines */
IEXT HV *	Istrtab;	/* shared string table */

/* memory management */
IEXT SV **	Itmps_stack;
IEXT I32	Itmps_ix IINIT(-1);
IEXT I32	Itmps_floor IINIT(-1);
IEXT I32	Itmps_max;
IEXT I32	Isv_count;	/* how many SV* are currently allocated */
IEXT I32	Isv_objcount;	/* how many objects are currently allocated */
IEXT SV*	Isv_root;	/* storage for SVs belonging to interp */
IEXT SV*	Isv_arenaroot;	/* list of areas for garbage collection */

/* funky return mechanisms */
IEXT I32	Ilastspbase;
IEXT I32	Ilastsize;
IEXT int	Iforkprocess;	/* so do_open |- can return proc# */

/* subprocess state */
IEXT AV *	Ifdpid;		/* keep fd-to-pid mappings for my_popen */

/* internal state */
IEXT VOL int	Iin_eval;	/* trap "fatal" errors? */
IEXT OP *	Irestartop;	/* Are we propagating an error from croak? */
IEXT int	Idelaymagic;	/* ($<,$>) = ... */
IEXT bool	Idirty;		/* In the middle of tearing things down? */
IEXT U8		Ilocalizing;	/* are we processing a local() list? */
IEXT bool	Itainted;	/* using variables controlled by $< */
IEXT bool	Itainting;	/* doing taint checks */
IEXT char *	Iop_mask IINIT(NULL);	/* masked operations for safe evals */

/* trace state */
IEXT I32	Idlevel;
IEXT I32	Idlmax IINIT(128);
IEXT char *	Idebname;
IEXT char *	Idebdelim;

/* current interpreter roots */
IEXT CV *	Imain_cv;
IEXT OP *	Imain_root;
IEXT OP *	Imain_start;
IEXT OP *	Ieval_root;
IEXT OP *	Ieval_start;

/* runtime control stuff */
IEXT COP * VOL	Icurcop IINIT(&compiling);
IEXT COP *	Icurcopdb IINIT(NULL);
IEXT line_t	Icopline IINIT(NOLINE);
IEXT CONTEXT *	Icxstack;
IEXT I32	Icxstack_ix IINIT(-1);
IEXT I32	Icxstack_max IINIT(128);
IEXT JMPENV 	Istart_env;	/* empty startup sigjmp() environment */
IEXT JMPENV *	Itop_env;	/* ptr. to current sigjmp() environment */
IEXT I32	Irunlevel;

/* stack stuff */
IEXT AV *	Icurstack;		/* THE STACK */
IEXT AV *	Imainstack;	/* the stack when nothing funny is happening */
IEXT SV **	Imystack_base;	/* stack->array_ary */
IEXT SV **	Imystack_sp;	/* stack pointer now */
IEXT SV **	Imystack_max;	/* stack->array_ary + stack->array_max */

/* format accumulators */
IEXT SV *	Iformtarget;
IEXT SV *	Ibodytarget;
IEXT SV *	Itoptarget;

/* statics moved here for shared library purposes */
IEXT SV		Istrchop;	/* return value from chop */
IEXT int	Ifilemode;	/* so nextargv() can preserve mode */
IEXT int	Ilastfd;	/* what to preserve mode on */
IEXT char *	Ioldname;	/* what to preserve mode on */
IEXT char **	IArgv;		/* stuff to free from do_aexec, vfork safe */
IEXT char *	ICmd;		/* stuff to free from do_aexec, vfork safe */
IEXT OP *	Isortcop;	/* user defined sort routine */
IEXT HV *	Isortstash;	/* which is in some package or other */
IEXT GV *	Ifirstgv;	/* $a */
IEXT GV *	Isecondgv;	/* $b */
IEXT AV *	Isortstack;	/* temp stack during pp_sort() */
IEXT AV *	Isignalstack;	/* temp stack during sighandler() */
IEXT SV *	Imystrk;	/* temp key string for do_each() */
IEXT I32	Idumplvl;	/* indentation level on syntax tree dump */
IEXT PMOP *	Ioldlastpm;	/* for saving regexp context during debugger */
IEXT I32	Igensym;	/* next symbol for getsym() to define */
IEXT bool	Ipreambled;
IEXT AV *	Ipreambleav;
IEXT int	Ilaststatval IINIT(-1);
IEXT I32	Ilaststype IINIT(OP_STAT);
IEXT SV *	Imess_sv;
d2054 11
a2064 2
#undef IEXT
#undef IINIT
d2067 11
d2079 1
d2086 11
a2096 1
#include "pp.h"
d2098 2
a2099 2
#ifdef __cplusplus
extern "C" {
d2102 7
d2119 77
a2195 1
#ifdef __cplusplus
d2197 6
d2204 2
d2207 15
a2221 1
/* The following must follow proto.h */
d2240 1
a2240 1
EXT MGVTBL vtbl_pack =	{0,	0,	0,	magic_wipepack,
d2261 2
a2262 1
EXT MGVTBL vtbl_nkeys =	{0,	magic_setnkeys,
d2266 1
a2266 1
EXT MGVTBL vtbl_substr =	{0,	magic_setsubstr,
d2268 2
a2269 1
EXT MGVTBL vtbl_vec =	{0,	magic_setvec,
d2281 3
d2285 3
a2287 1
					0,	0,	magic_freedefelem};
d2325 5
d2331 1
a2345 2
EXT long amagic_generation;

d2415 1
a2415 1
  mod_amg,	mod_ass_amg,
d2472 1
a2472 1
#define PERLDB_ALL	0xff
d2480 2
d2483 8
a2490 6
#define PERLDB_SUB	(perldb && (perldb & PERLDBf_SUB))
#define PERLDB_LINE	(perldb && (perldb & PERLDBf_LINE))
#define PERLDB_NOOPT	(perldb && (perldb & PERLDBf_NOOPT))
#define PERLDB_INTER	(perldb && (perldb & PERLDBf_INTER))
#define PERLDB_SUBLINE	(perldb && (perldb & PERLDBf_SUBLINE))
#define PERLDB_SINGLE	(perldb && (perldb & PERLDBf_SINGLE))
a2491 7
#ifdef USE_LOCALE_COLLATE
EXT U32		collation_ix;		/* Collation generation index */
EXT char *	collation_name;		/* Name of current collation */
EXT bool	collation_standard INIT(TRUE); /* Assume simple collation */
EXT Size_t	collxfrm_base;		/* Basic overhead in *xfrm() */
EXT Size_t	collxfrm_mult INIT(2);	/* Expansion factor in *xfrm() */
#endif /* USE_LOCALE_COLLATE */
a2494 4
EXT char *	numeric_name;		/* Name of current numeric locale */
EXT bool	numeric_standard INIT(TRUE); /* Assume simple numerics */
EXT bool	numeric_local INIT(TRUE);    /* Assume local numerics */

d2497 1
a2497 1
	if (! numeric_standard)			\
d2503 1
a2503 1
	if (! numeric_local)			\
d2514 1
a2514 1
#if !defined(PERLIO_IS_STDIO) && defined(HAS_ATTRIBUTE)
d2522 56
a2578 1

@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 *    Copyright (c) 1987-1994, Larry Wall
d13 19
d40 1
a40 1
# if defined(__GNUC__) && !defined(__STRICT_ANSI__)
d55 9
a63 4
#include "embed.h"

#define VOIDUSED 1
#include "config.h"
d83 1
a83 1
#if defined(MSDOS) || defined(atarist)
d91 4
d105 55
a159 4
#define TAINT_IF(c)	(tainted |= (c))
#define TAINT_NOT	(tainted = 0)
#define TAINT_PROPER(s)	if (tainting) taint_proper(no_security, s)
#define TAINT_ENV()	if (tainting) taint_env()
d161 3
a163 6
#ifdef USE_BSDPGRP
#   ifdef HAS_GETPGRP
#       define BSD_GETPGRP(pid) getpgrp((pid))
#   endif
#   ifdef HAS_SETPGRP
#       define BSD_SETPGRP(pid, pgrp) setpgrp((pid), (pgrp))
d165 10
d176 3
a178 12
#   ifdef HAS_GETPGRP2
#       define BSD_GETPGRP(pid) getpgrp2((pid))
#       ifndef HAS_GETPGRP
#    	    define HAS_GETPGRP
#    	endif
#   endif
#   ifdef HAS_SETPGRP2
#       define BSD_SETPGRP(pid, pgrp) setpgrp2((pid), (pgrp))
#       ifndef HAS_SETPGRP
#    	    define HAS_SETPGRP
#    	endif
#   endif
d181 2
a182 1
#include <stdio.h>
d184 4
d189 3
a191 1
#else
d193 4
d200 1
a200 1
#include <locale.h>
d203 13
a215 3
#ifdef METHOD 	/* Defined by OSF/1 v3.0 by ctype.h */
#undef METHOD
#endif
d230 4
a233 1
#endif /* STANDARD_C */
a234 4
/* Maybe this comes after <stdlib.h> so we don't try to change 
   the standard library prototypes?.  We'll use our own in 
   proto.h instead.  I guess.  The patch had no explanation.
*/
d236 1
d238 2
a239 1
#	define malloc Mymalloc
d241 1
a241 1
#	define free Myfree
d243 13
a255 1
#   define safemalloc malloc
d257 3
a259 2
#   define safefree free
#endif
d263 7
a280 4
#if defined(mips) && defined(ultrix) && !defined(__STDC__)
#   undef HAS_MEMCMP
#endif

a306 1
#  define memzero(d,l) memset(d,0,l)
d308 9
a316 3
#   ifndef memzero
#	ifdef HAS_BZERO
#	    define memzero(d,l) bzero(d,l)
d318 1
a318 1
#	    define memzero(d,l) my_bzero(d,l)
d321 5
a325 1
#endif /* HAS_MEMSET */
d327 1
a327 1
#ifdef HAS_MEMCMP
d333 3
d340 1
a340 8
#endif /* HAS_MEMCMP */

/* XXX we prefer bcmp slightly for comparisons that don't care about ordering */
#ifndef HAS_BCMP
#   ifndef bcmp
#	define bcmp(s1,s2,l) memcmp(s1,s2,l)
#   endif
#endif /* HAS_BCMP */
d342 3
a344 3
#if !defined(HAS_MEMMOVE) && !defined(memmove)
#   if defined(HAS_BCOPY) && defined(HAS_SAFE_BCOPY)
#	define memmove(d,s,l) bcopy(s,d,l)
d346 2
a347 2
#	if defined(HAS_MEMCPY) && defined(HAS_SAFE_MEMCPY)
#	    define memmove(d,s,l) memcpy(d,s,l)
d349 1
a349 1
#	    define memmove(d,s,l) my_bcopy(s,d,l)
d354 3
a356 3
#ifndef _TYPES_		/* If types.h defines this it's easy. */
#   ifndef major		/* Does everyone's types.h define this? */
#	include <sys/types.h>
d358 1
a358 1
#endif
d364 6
d371 1
a371 1
#include <sys/stat.h>
d406 1
a406 2
#ifndef MSDOS
#  if defined(HAS_TIMES) && defined(I_SYS_TIMES)
a407 1
#  endif
d426 8
a433 3
#ifndef VMS
#   define FIXSTATUS(sts)  (U_L((sts) & 0xffff))
#   define SHIFTSTATUS(sts) ((sts) >> 8)
a434 4
#else
#   define FIXSTATUS(sts)  (U_L(sts))
#   define SHIFTSTATUS(sts) (sts)
#   define SETERRNO(errcode,vmserrcode) STMT_START {set_errno(errcode); set_vaxc_errno(vmserrcode);} STMT_END
d437 1
a437 2
#ifndef MSDOS
#   ifndef errno
a438 1
#   endif
d445 1
d447 1
a620 4
#if defined(cray) || defined(convex) || defined (uts) || BYTEORDER > 0xffff
#   define HAS_QUAD
#endif

d625 18
a642 3
#ifdef HAS_QUAD
#   ifdef cray
#	define Quad_t int
d644 1
a644 3
#	if defined(convex) || defined (uts)
#	    define Quad_t long long
#	else
d648 4
d654 4
d661 185
d865 3
a867 1
typedef struct ff FF;
d874 1
a874 1
typedef struct sv GV;
d883 1
d914 5
a918 1
#   include "unixish.h"
d921 58
a978 3

#ifndef HAS_PAUSE
#define pause() sleep((32767<<16)+32767)
d999 5
d1086 3
d1090 3
d1103 3
d1107 5
a1112 1
IV cast_iv _((double));
a1113 1
UV cast_uv _((double));
d1139 3
d1152 1
a1152 1
#define DEBUG_m(a) if (debug & 128)	a
d1183 1
d1190 1
d1199 1
a1199 1
#ifndef __cplusplus
d1221 1
d1223 2
d1236 3
d1240 3
d1244 1
d1246 1
d1270 8
a1285 3
# ifdef MYMALLOC
# define DEBUGGING_MSTATS
# endif
d1297 3
a1299 1
#ifndef VMS  /* VMS doesn't use environ array */
d1302 9
d1323 1
d1327 1
a1367 1
EXT char	buf[2048];	/* should be longer than PATH_MAX */
d1381 5
a1385 5
EXT char *	Yes INIT("1");
EXT char *	No INIT("");
EXT char *	hexdigit INIT("0123456789abcdef0123456789ABCDEFx");
EXT char *	patleave INIT("\\.^$@@dDwWsSbB+*?|()-nrtfeaxc0123456789[{]}");
EXT char *	vert INIT("|");
d1387 1
a1387 1
EXT char	warn_uninit[]
d1389 1
a1389 1
EXT char	warn_nosemi[]
d1391 1
a1391 1
EXT char	warn_reserved[]
d1393 1
a1393 1
EXT char	warn_nl[]
d1395 1
a1395 1
EXT char	no_wrongref[]
d1397 1
a1397 1
EXT char	no_symref[]
d1399 1
a1399 1
EXT char	no_usym[]
d1401 1
a1401 1
EXT char	no_aelem[]
d1403 1
a1403 1
EXT char	no_helem[]
d1405 1
a1405 1
EXT char	no_modify[]
d1407 1
a1407 1
EXT char	no_mem[]
d1409 1
a1409 1
EXT char	no_security[]
d1411 1
a1411 1
EXT char	no_sock_func[]
d1413 1
a1413 1
EXT char	no_dir_func[]
d1415 1
a1415 1
EXT char	no_func[]
d1417 1
a1417 1
EXT char	no_myglob[]
d1431 2
d1436 43
d1482 1
a1482 1
EXT unsigned char fold[] = {	/* fast case folding table */
d1517 1
a1517 1
EXT unsigned char fold[];
d1521 1
a1521 1
EXT unsigned char freq[] = {	/* letter frequencies for mixed English/C */
d1556 1
a1556 1
EXT unsigned char freq[];
d1561 1
a1561 1
EXT char* block_type[] = {
d1570 1
a1570 1
EXT char* block_type[];
d1581 2
d1614 1
a1614 1
EXT FILE * VOL	rsfp INIT(Nullfp);
d1637 1
d1664 1
d1689 3
a1738 1
IEXT bool	Isawi;		/* study must assume case insensitive */
a1740 1
IEXT bool	Ido_undump;		/* -u or dump seen? */
d1743 1
a1743 2
IEXT FILE *	Ie_fp;
IEXT VOL U32	Idebug;
d1746 1
a1746 1
IEXT int	Iperl_destruct_level;	/* 0=none, 1=full, 2=full with checks */
d1759 5
a1763 2
IEXT int	Imultiline;	  /* $*--do strings hold >1 line? */
IEXT U32	Istatusvalue;	/* $? */
d1807 1
a1807 2
IEXT AV *	Ipad;		/* storage for lexically scoped temporaries */
IEXT AV *	Ipadname;	/* variable names for "my" variables */
a1825 1
IEXT HV *	Ipidstatus;	/* keep pid-to-status mappings for waitpid */
d1852 1
d1857 2
a1858 1
IEXT Sigjmp_buf	Itop_env;
d1862 1
a1862 1
IEXT AV *	Istack;		/* THE STACK */
d1894 1
a1912 14
#ifdef __cplusplus
#  ifndef I_STDARG
#    define I_STDARG 1
#  endif
#endif

#ifdef I_STDARG
#  include <stdarg.h>
#else
#  ifdef I_VARARGS
#    include <varargs.h>
#  endif
#endif

d1930 1
d1935 3
a1937 1
EXT MGVTBL vtbl_env =	{0,	0,	0,	0,	0};
d1942 4
a1945 2
EXT MGVTBL vtbl_sigelem =	{0,	magic_setsig,
					0,	0,	0};
d1955 2
a1956 1
					0,	0,	0};
d1967 2
d1980 2
d1985 8
d2001 2
a2002 1
#else
d2016 1
d2022 1
d2024 5
d2035 1
a2035 1
#endif
d2038 1
d2041 1
a2041 1
#define NofAMmeth 29
d2043 30
a2072 30
EXT char * AMG_names[NofAMmeth][2] = {
  {"fallback","abs"},
  {"bool", "nomethod"},
  {"\"\"", "0+"},
  {"+","+="},
  {"-","-="},
  {"*", "*="},
  {"/", "/="},
  {"%", "%="},
  {"**", "**="},
  {"<<", "<<="},
  {">>", ">>="},
  {"&", "&="},
  {"|", "|="},
  {"^", "^="},
  {"<", "<="},
  {">", ">="},
  {"==", "!="},
  {"<=>", "cmp"},
  {"lt", "le"},
  {"gt", "ge"},
  {"eq", "ne"},
  {"!", "~"},
  {"++", "--"},
  {"atan2", "cos"},
  {"sin", "exp"},
  {"log", "sqrt"},
  {"x","x="},
  {".",".="},
  {"=","neg"}
d2075 1
a2075 1
EXT char * AMG_names[NofAMmeth][2];
d2078 1
a2078 1
struct  am_table        {
d2081 2
a2082 1
  CV* table[NofAMmeth*2];
d2085 5
d2091 1
d2097 5
d2133 32
d2167 57
d2225 1
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d3 1
a3 1
 *    Copyright (c) 1987-1999, Larry Wall
a12 153
#ifdef PERL_FOR_X2P
/*
 * This file is being used for x2p stuff. 
 * Above symbol is defined via -D in 'x2p/Makefile.SH'
 * Decouple x2p stuff from some of perls more extreme eccentricities. 
 */
#undef EMBED
#undef NO_EMBED
#define NO_EMBED
#undef MULTIPLICITY
#undef USE_STDIO
#define USE_STDIO
#endif /* PERL_FOR_X2P */

#ifdef PERL_OBJECT

/* PERL_OBJECT explained  - DickH and DougL @@ ActiveState.com

Defining PERL_OBJECT turns on creation of a C++ object that
contains all writable core perl global variables and functions.
Stated another way, all necessary global variables and functions
are members of a big C++ object. This object's class is CPerlObj.
This allows a Perl Host to have multiple, independent perl
interpreters in the same process space. This is very important on
Win32 systems as the overhead of process creation is quite high --
this could be even higher than the script compile and execute time
for small scripts.

The perl executable implementation on Win32 is composed of perl.exe
(the Perl Host) and perlX.dll. (the Perl Core). This allows the
same Perl Core to easily be embedded in other applications that use
the perl interpreter.

+-----------+
| Perl Host |
+-----------+
      ^
	  |
	  v
+-----------+   +-----------+
| Perl Core |<->| Extension |
+-----------+   +-----------+ ...

Defining PERL_OBJECT has the following effects:

PERL CORE
1. CPerlObj is defined (this is the PERL_OBJECT)
2. all static functions that needed to access either global
variables or functions needed are made member functions
3. all writable static variables are made member variables
4. all global variables and functions are defined as:
	#define var CPerlObj::Perl_var
	#define func CPerlObj::Perl_func
	* these are in objpp.h
This necessitated renaming some local variables and functions that
had the same name as a global variable or function. This was
probably a _good_ thing anyway.


EXTENSIONS
1. Access to global variables and perl functions is through a
pointer to the PERL_OBJECT. This pointer type is CPerlObj*. This is
made transparent to extension developers by the following macros:
	#define var pPerl->Perl_var
	#define func pPerl->Perl_func
	* these are done in objXSUB.h
This requires that the extension be compiled as C++, which means
that the code must be ANSI C and not K&R C. For K&R extensions,
please see the C API notes located in Win32/GenCAPI.pl. This script
creates a perlCAPI.lib that provides a K & R compatible C interface
to the PERL_OBJECT.
2. Local variables and functions cannot have the same name as perl's
variables or functions since the macros will redefine these. Look for
this if you get some strange error message and it does not look like
the code that you had written. This often happens with variables that
are local to a function.

PERL HOST
1. The perl host is linked with perlX.lib to get perl_alloc. This
function will return a pointer to CPerlObj (the PERL_OBJECT). It
takes pointers to the various PerlXXX_YYY interfaces (see iperlsys.h
for more information on this).
2. The perl host calls the same functions as normally would be
called in setting up and running a perl script, except that the
functions are now member functions of the PERL_OBJECT.

*/


class CPerlObj;

#define STATIC
#define CPERLscope(x) CPerlObj::x
#define CPERLproto CPerlObj *
#define _CPERLproto ,CPERLproto
#define CPERLarg CPerlObj *pPerl
#define CPERLarg_ CPERLarg,
#define _CPERLarg ,CPERLarg
#define PERL_OBJECT_THIS this
#define _PERL_OBJECT_THIS ,this
#define PERL_OBJECT_THIS_ this,
#define CALLRUNOPS (this->*PL_runops)
#define CALLREGCOMP (this->*PL_regcompp)
#define CALLREGEXEC (this->*PL_regexecp)

#else /* !PERL_OBJECT */

#define STATIC static
#define CPERLscope(x) x
#define CPERLproto
#define _CPERLproto
#define CPERLarg void
#define CPERLarg_
#define _CPERLarg
#define PERL_OBJECT_THIS
#define _PERL_OBJECT_THIS
#define PERL_OBJECT_THIS_
#define CALLRUNOPS PL_runops
#define CALLREGCOMP (*PL_regcompp)
#define CALLREGEXEC (*PL_regexecp)

#endif /* PERL_OBJECT */

#define VOIDUSED 1
#include "config.h"

#include "embed.h"

#undef START_EXTERN_C
#undef END_EXTERN_C
#undef EXTERN_C
#ifdef __cplusplus
#  define START_EXTERN_C extern "C" {
#  define END_EXTERN_C }
#  define EXTERN_C extern "C"
#else
#  define START_EXTERN_C 
#  define END_EXTERN_C 
#  define EXTERN_C
#endif

#ifdef OP_IN_REGISTER
#  ifdef __GNUC__
#    define stringify_immed(s) #s
#    define stringify(s) stringify_immed(s)
#ifdef EMBED
register struct op *Perl_op asm(stringify(OP_IN_REGISTER));
#else
register struct op *op asm(stringify(OP_IN_REGISTER));
#endif
#  endif
#endif

d21 1
a21 1
# if defined(__GNUC__) && !defined(__STRICT_ANSI__) && !defined(__cplusplus)
d36 1
a36 1
#define NOOP (void)0
d38 2
a39 11
#define WITH_THR(s) STMT_START { dTHR; s; } STMT_END

/*
 * SOFT_CAST can be used for args to prototyped functions to retain some
 * type checking; it only casts if the compiler does not know prototypes.
 */
#if defined(CAN_PROTOTYPE) && defined(DEBUGGING_COMPILE)
#define SOFT_CAST(type)	
#else
#define SOFT_CAST(type)	(type)
#endif
d41 1
a41 1
#ifndef BYTEORDER  /* Should never happen -- byteorder is in config.h */
a49 6
#if 'A' == 65 && 'I' == 73 && 'J' == 74 && 'Z' == 90
#define ASCIIish
#else
#undef  ASCIIish
#endif

d59 1
a59 1
#if defined(MSDOS) || defined(atarist) || defined(WIN32)
a66 4
#if defined(__cplusplus) || defined(WIN32) || defined(__sgi) || defined(OS2) || defined(__DGUX)
# define DONT_DECLARE_STD 1
#endif

d77 4
a80 5
#define TAINT		(PL_tainted = TRUE)
#define TAINT_NOT	(PL_tainted = FALSE)
#define TAINT_IF(c)	if (c) { PL_tainted = TRUE; }
#define TAINT_ENV()	if (PL_tainting) { taint_env(); }
#define TAINT_PROPER(s)	if (PL_tainting) { taint_proper(Nullch, s); }
d82 7
a88 9
/* XXX All process group stuff is handled in pp_sys.c.  Should these 
   defines move there?  If so, I could simplify this a lot. --AD  9/96.
*/
/* Process group stuff changed from traditional BSD to POSIX.
   perlfunc.pod documents the traditional BSD-style syntax, so we'll
   try to preserve that, if possible.
*/
#ifdef HAS_SETPGID
#  define BSD_SETPGRP(pid, pgrp)	setpgid((pid), (pgrp))
d90 11
a100 43
#  if defined(HAS_SETPGRP) && defined(USE_BSD_SETPGRP)
#    define BSD_SETPGRP(pid, pgrp)	setpgrp((pid), (pgrp))
#  else
#    ifdef HAS_SETPGRP2  /* DG/UX */
#      define BSD_SETPGRP(pid, pgrp)	setpgrp2((pid), (pgrp))
#    endif
#  endif
#endif
#if defined(BSD_SETPGRP) && !defined(HAS_SETPGRP)
#  define HAS_SETPGRP  /* Well, effectively it does . . . */
#endif

/* getpgid isn't POSIX, but at least Solaris and Linux have it, and it makes
    our life easier :-) so we'll try it.
*/
#ifdef HAS_GETPGID
#  define BSD_GETPGRP(pid)		getpgid((pid))
#else
#  if defined(HAS_GETPGRP) && defined(USE_BSD_GETPGRP)
#    define BSD_GETPGRP(pid)		getpgrp((pid))
#  else
#    ifdef HAS_GETPGRP2  /* DG/UX */
#      define BSD_GETPGRP(pid)		getpgrp2((pid))
#    endif
#  endif
#endif
#if defined(BSD_GETPGRP) && !defined(HAS_GETPGRP)
#  define HAS_GETPGRP  /* Well, effectively it does . . . */
#endif

/* These are not exact synonyms, since setpgrp() and getpgrp() may 
   have different behaviors, but perl.h used to define USE_BSDPGRP
   (prior to 5.003_05) so some extension might depend on it.
*/
#if defined(USE_BSD_SETPGRP) || defined(USE_BSD_GETPGRP)
#  ifndef USE_BSDPGRP
#    define USE_BSDPGRP
#  endif
#endif

#ifndef _TYPES_		/* If types.h defines this it's easy. */
#   ifndef major		/* Does everyone's types.h define this? */
#	include <sys/types.h>
d104 1
a104 16
#ifdef __cplusplus
#  ifndef I_STDARG
#    define I_STDARG 1
#  endif
#endif

#ifdef I_STDARG
#  include <stdarg.h>
#else
#  ifdef I_VARARGS
#    include <varargs.h>
#  endif
#endif

#include "iperlsys.h"

a105 4

#if NX_CURRENT_COMPILER_RELEASE >= 400
#include <objc/NXCType.h>
#else /*  NX_CURRENT_COMPILER_RELEASE < 400 */
d107 1
a107 3
#endif /*  NX_CURRENT_COMPILER_RELEASE >= 400 */

#else /* !USE_NEXT_CTYPE */
a108 4
#endif /* USE_NEXT_CTYPE */

#ifdef METHOD 	/* Defined by OSF/1 v3.0 by ctype.h */
#undef METHOD
d112 1
a112 1
#   include <locale.h>
d115 3
a117 13
#if !defined(NO_LOCALE) && defined(HAS_SETLOCALE)
#   define USE_LOCALE
#   if !defined(NO_LOCALE_COLLATE) && defined(LC_COLLATE) \
       && defined(HAS_STRXFRM)
#	define USE_LOCALE_COLLATE
#   endif
#   if !defined(NO_LOCALE_CTYPE) && defined(LC_CTYPE)
#	define USE_LOCALE_CTYPE
#   endif
#   if !defined(NO_LOCALE_NUMERIC) && defined(LC_NUMERIC)
#	define USE_LOCALE_NUMERIC
#   endif
#endif /* !NO_LOCALE && HAS_SETLOCALE */
d132 1
a132 6
#endif

#define MEM_SIZE Size_t

/* This comes after <stdlib.h> so we don't try to change the standard
 * library prototypes; we'll use our own in proto.h instead. */
d134 4
a138 1

d140 3
a142 28
#	define malloc  Mymalloc
#	define calloc  Mycalloc
#	define realloc Myrealloc
#	define free    Myfree
Malloc_t Mymalloc _((MEM_SIZE nbytes));
Malloc_t Mycalloc _((MEM_SIZE elements, MEM_SIZE size));
Malloc_t Myrealloc _((Malloc_t where, MEM_SIZE nbytes));
Free_t   Myfree _((Malloc_t where));
#   endif
#   ifdef EMBEDMYMALLOC
#	define malloc  Perl_malloc
#	define calloc  Perl_calloc
#	define realloc Perl_realloc
/* VMS' external symbols are case-insensitive, and there's already a */
/* perl_free in perl.h */
#ifdef VMS
#	define free    Perl_myfree
#else
#	define free    Perl_free
#endif
Malloc_t Perl_malloc _((MEM_SIZE nbytes));
Malloc_t Perl_calloc _((MEM_SIZE elements, MEM_SIZE size));
Malloc_t Perl_realloc _((Malloc_t where, MEM_SIZE nbytes));
#ifdef VMS
Free_t   Perl_myfree _((Malloc_t where));
#else
Free_t   Perl_free _((Malloc_t where));
#endif
d144 1
a144 7

#   undef safemalloc
#   undef safecalloc
#   undef saferealloc
#   undef safefree
#   define safemalloc  malloc
#   define safecalloc  calloc
d146 2
a147 1
#   define safefree    free
d149 1
a149 8
#endif /* MYMALLOC */

#if defined(STANDARD_C) && defined(I_STDDEF)
#   include <stddef.h>
#   define STRUCT_OFFSET(s,m)  offsetof(s,m)
#else
#   define STRUCT_OFFSET(s,m)  (Size_t)(&(((s *)0)->m))
#endif
d162 4
d192 1
d194 3
a196 9
#  define memset(d,c,l) my_memset(d,c,l)
#endif /* HAS_MEMSET */

#if !defined(HAS_MEMMOVE) && !defined(memmove)
#   if defined(HAS_BCOPY) && defined(HAS_SAFE_BCOPY)
#	define memmove(d,s,l) bcopy(s,d,l)
#   else
#	if defined(HAS_MEMCPY) && defined(HAS_SAFE_MEMCPY)
#	    define memmove(d,s,l) memcpy(d,s,l)
d198 1
a198 1
#	    define memmove(d,s,l) my_bcopy(s,d,l)
d201 1
a201 5
#endif

#if defined(mips) && defined(ultrix) && !defined(__STDC__)
#   undef HAS_MEMCMP
#endif
d203 1
a203 1
#if defined(HAS_MEMCMP) && defined(HAS_SANE_MEMCMP)
a208 3
#  ifdef BUGGY_MSC
  #  pragma function(memcmp)
#  endif
d213 8
a220 1
#endif /* HAS_MEMCMP && HAS_SANE_MEMCMP */
d222 3
a224 3
#ifndef memzero
#   ifdef HAS_MEMSET
#	define memzero(d,l) memset(d,0,l)
d226 2
a227 2
#	ifdef HAS_BZERO
#	    define memzero(d,l) bzero(d,l)
d229 1
a229 1
#	    define memzero(d,l) my_bzero(d,l)
d234 3
a236 3
#ifndef HAS_BCMP
#   ifndef bcmp
#	define bcmp(s1,s2,l) memcmp(s1,s2,l)
d238 1
a238 1
#endif /* !HAS_BCMP */
a243 10
#ifdef I_ARPA_INET
#   include <arpa/inet.h>
#endif

#if defined(SF_APPEND) && defined(USE_SFIO) && defined(I_SFIO)
/* <sfio.h> defines SF_APPEND and <sys/stat.h> might define SF_APPEND
 * (the neo-BSD seem to do this).  */
#   undef SF_APPEND
#endif

d245 1
a245 1
#   include <sys/stat.h>
d280 2
a281 1
#if defined(HAS_TIMES) && defined(I_SYS_TIMES)
d283 1
d290 6
d302 9
d312 2
a313 23
#ifdef VMS
#   define SETERRNO(errcode,vmserrcode) \
	STMT_START {			\
	    set_errno(errcode);		\
	    set_vaxc_errno(vmserrcode);	\
	} STMT_END
#else
#   define SETERRNO(errcode,vmserrcode) (errno = (errcode))
#endif

#ifdef USE_THREADS
#  define ERRSV (thr->errsv)
#  define ERRHV (thr->errhv)
#  define DEFSV THREADSV(0)
#  define SAVE_DEFSV save_threadsv(0)
#else
#  define ERRSV GvSV(PL_errgv)
#  define ERRHV GvHV(PL_errgv)
#  define DEFSV GvSV(PL_defgv)
#  define SAVE_DEFSV SAVESPTR(GvSV(PL_defgv))
#endif /* USE_THREADS */

#ifndef errno
d315 1
a321 1
#ifndef DONT_DECLARE_STD
a322 1
#endif
d496 4
d504 3
a506 18
/*  XXX QUAD stuff is not currently supported on most systems.
    Specifically, perl internals don't support long long.  Among
    the many problems is that some compilers support long long,
    but the underlying library functions (such as sprintf) don't.
    Some things do work (such as quad pack/unpack on convex);
    also some systems use long long for the fpos_t typedef.  That
    seems to work too.

    The IV type is supposed to be long enough to hold any integral
    value or a pointer.
    --Andy Dougherty	August 1996
*/

#ifdef cray
#   define Quad_t int
#else
#   ifdef convex
#	define Quad_t long long
d508 3
a510 1
#	if LONGSIZE == 8
a513 13
#endif

/* XXX Experimental set-up for long long.  Just add -DUSE_LONG_LONG
   to your ccflags.  --Andy Dougherty   4/1998
*/
#ifdef USE_LONG_LONG
#  if defined(HAS_LONG_LONG) && LONGLONGSIZE == 8
#    define Quad_t long long
#  endif
#endif

#ifdef Quad_t
#   define HAS_QUAD
a515 4
#   define IV_MAX PERL_QUAD_MAX
#   define IV_MIN PERL_QUAD_MIN
#   define UV_MAX PERL_UQUAD_MAX
#   define UV_MIN PERL_UQUAD_MIN
a518 197
#   define IV_MAX PERL_LONG_MAX
#   define IV_MIN PERL_LONG_MIN
#   define UV_MAX PERL_ULONG_MAX
#   define UV_MIN PERL_ULONG_MIN
#endif

/* Previously these definitions used hardcoded figures. 
 * It is hoped these formula are more portable, although
 * no data one way or another is presently known to me.
 * The "PERL_" names are used because these calculated constants
 * do not meet the ANSI requirements for LONG_MAX, etc., which
 * need to be constants acceptable to #if - kja
 *    define PERL_LONG_MAX        2147483647L
 *    define PERL_LONG_MIN        (-LONG_MAX - 1)
 *    define PERL ULONG_MAX       4294967295L
 */

#ifdef I_LIMITS  /* Needed for cast_xxx() functions below. */
#  include <limits.h>
#else
#ifdef I_VALUES
#  include <values.h>
#endif
#endif

/*
 * Try to figure out max and min values for the integral types.  THE CORRECT
 * SOLUTION TO THIS MESS: ADAPT enquire.c FROM GCC INTO CONFIGURE.  The
 * following hacks are used if neither limits.h or values.h provide them:
 * U<TYPE>_MAX: for types >= int: ~(unsigned TYPE)0
 *              for types <  int:  (unsigned TYPE)~(unsigned)0
 *	The argument to ~ must be unsigned so that later signed->unsigned
 *	conversion can't modify the value's bit pattern (e.g. -0 -> +0),
 *	and it must not be smaller than int because ~ does integral promotion.
 * <type>_MAX: (<type>) (U<type>_MAX >> 1)
 * <type>_MIN: -<type>_MAX - <is_twos_complement_architecture: (3 & -1) == 3>.
 *	The latter is a hack which happens to work on some machines but
 *	does *not* catch any random system, or things like integer types
 *	with NaN if that is possible.
 *
 * All of the types are explicitly cast to prevent accidental loss of
 * numeric range, and in the hope that they will be less likely to confuse
 * over-eager optimizers.
 *
 */

#define PERL_UCHAR_MIN ((unsigned char)0)

#ifdef UCHAR_MAX
#  define PERL_UCHAR_MAX ((unsigned char)UCHAR_MAX)
#else
#  ifdef MAXUCHAR
#    define PERL_UCHAR_MAX ((unsigned char)MAXUCHAR)
#  else
#    define PERL_UCHAR_MAX       ((unsigned char)~(unsigned)0)
#  endif
#endif
 
/*
 * CHAR_MIN and CHAR_MAX are not included here, as the (char) type may be
 * ambiguous. It may be equivalent to (signed char) or (unsigned char)
 * depending on local options. Until Configure detects this (or at least
 * detects whether the "signed" keyword is available) the CHAR ranges
 * will not be included. UCHAR functions normally.
 *                                                           - kja
 */

#define PERL_USHORT_MIN ((unsigned short)0)

#ifdef USHORT_MAX
#  define PERL_USHORT_MAX ((unsigned short)USHORT_MAX)
#else
#  ifdef MAXUSHORT
#    define PERL_USHORT_MAX ((unsigned short)MAXUSHORT)
#  else
#    ifdef USHRT_MAX
#      define PERL_USHORT_MAX ((unsigned short)USHRT_MAX)
#    else
#      define PERL_USHORT_MAX       ((unsigned short)~(unsigned)0)
#    endif
#  endif
#endif

#ifdef SHORT_MAX
#  define PERL_SHORT_MAX ((short)SHORT_MAX)
#else
#  ifdef MAXSHORT    /* Often used in <values.h> */
#    define PERL_SHORT_MAX ((short)MAXSHORT)
#  else
#    ifdef SHRT_MAX
#      define PERL_SHORT_MAX ((short)SHRT_MAX)
#    else
#      define PERL_SHORT_MAX      ((short) (PERL_USHORT_MAX >> 1))
#    endif
#  endif
#endif

#ifdef SHORT_MIN
#  define PERL_SHORT_MIN ((short)SHORT_MIN)
#else
#  ifdef MINSHORT
#    define PERL_SHORT_MIN ((short)MINSHORT)
#  else
#    ifdef SHRT_MIN
#      define PERL_SHORT_MIN ((short)SHRT_MIN)
#    else
#      define PERL_SHORT_MIN        (-PERL_SHORT_MAX - ((3 & -1) == 3))
#    endif
#  endif
#endif

#ifdef UINT_MAX
#  define PERL_UINT_MAX ((unsigned int)UINT_MAX)
#else
#  ifdef MAXUINT
#    define PERL_UINT_MAX ((unsigned int)MAXUINT)
#  else
#    define PERL_UINT_MAX       (~(unsigned int)0)
#  endif
#endif

#define PERL_UINT_MIN ((unsigned int)0)

#ifdef INT_MAX
#  define PERL_INT_MAX ((int)INT_MAX)
#else
#  ifdef MAXINT    /* Often used in <values.h> */
#    define PERL_INT_MAX ((int)MAXINT)
#  else
#    define PERL_INT_MAX        ((int)(PERL_UINT_MAX >> 1))
#  endif
#endif

#ifdef INT_MIN
#  define PERL_INT_MIN ((int)INT_MIN)
#else
#  ifdef MININT
#    define PERL_INT_MIN ((int)MININT)
#  else
#    define PERL_INT_MIN        (-PERL_INT_MAX - ((3 & -1) == 3))
#  endif
#endif

#ifdef ULONG_MAX
#  define PERL_ULONG_MAX ((unsigned long)ULONG_MAX)
#else
#  ifdef MAXULONG
#    define PERL_ULONG_MAX ((unsigned long)MAXULONG)
#  else
#    define PERL_ULONG_MAX       (~(unsigned long)0)
#  endif
#endif

#define PERL_ULONG_MIN ((unsigned long)0L)

#ifdef LONG_MAX
#  define PERL_LONG_MAX ((long)LONG_MAX)
#else
#  ifdef MAXLONG    /* Often used in <values.h> */
#    define PERL_LONG_MAX ((long)MAXLONG)
#  else
#    define PERL_LONG_MAX        ((long) (PERL_ULONG_MAX >> 1))
#  endif
#endif

#ifdef LONG_MIN
#  define PERL_LONG_MIN ((long)LONG_MIN)
#else
#  ifdef MINLONG
#    define PERL_LONG_MIN ((long)MINLONG)
#  else
#    define PERL_LONG_MIN        (-PERL_LONG_MAX - ((3 & -1) == 3))
#  endif
#endif

#ifdef HAS_QUAD

#  ifdef UQUAD_MAX
#    define PERL_UQUAD_MAX ((UV)UQUAD_MAX)
#  else
#    define PERL_UQUAD_MAX	(~(UV)0)
#  endif

#  define PERL_UQUAD_MIN ((UV)0)

#  ifdef QUAD_MAX
#    define PERL_QUAD_MAX ((IV)QUAD_MAX)
#  else
#    define PERL_QUAD_MAX 	((IV) (PERL_UQUAD_MAX >> 1))
#  endif

#  ifdef QUAD_MIN
#    define PERL_QUAD_MIN ((IV)QUAD_MIN)
#  else
#    define PERL_QUAD_MIN 	(-PERL_QUAD_MAX - ((3 & -1) == 3))
#  endif

d538 1
a538 3
#ifndef __BORLANDC__
typedef struct ff FF;		/* XXX not defined anywhere, should go? */
#endif
d545 1
a545 1
typedef struct gv GV;
d547 1
a547 1
typedef struct context PERL_CONTEXT;
a553 1
typedef struct xpvuv XPVUV;
a568 3
#ifdef PERL_OBJECT
typedef I32 (*filter_t) _((CPerlObj*, int, SV *, int));
#else
a569 2
#endif

d571 2
a572 2
#define FILTER_DATA(idx)	   (AvARRAY(PL_rsfp_filters)[idx])
#define FILTER_ISREADER(idx)	   (idx >= AvFILLp(PL_rsfp_filters))
d584 1
a584 13
#   if defined(PLAN9)
#     include "./plan9/plan9ish.h"
#   else
#     if defined(MPE)
#       include "mpeix/mpeixish.h"
#     else
#       if defined(__VOS__)
#         include "vosish.h"
#       else
#         include "unixish.h"
#       endif
#     endif
#   endif
a585 4
#endif         

#ifndef FUNC_NAME_TO_PTR
#define FUNC_NAME_TO_PTR(name)		name
d588 2
a589 101
/* 
 * USE_THREADS needs to be after unixish.h as <pthread.h> includes
 * <sys/signal.h> which defines NSIG - which will stop inclusion of <signal.h>
 * this results in many functions being undeclared which bothers C++
 * May make sense to have threads after "*ish.h" anyway
 */

#ifdef USE_THREADS
   /* pending resolution of licensing issues, we avoid the erstwhile
    * atomic.h everywhere */
#  define EMULATE_ATOMIC_REFCOUNTS

#  ifdef FAKE_THREADS
#    include "fakethr.h"
#  else
#    ifdef WIN32
#      include <win32thread.h>
#    else
#      ifdef OS2
#        include "os2thread.h"
#      else
#        ifdef I_MACH_CTHREADS
#          include <mach/cthreads.h>
#          ifdef NeXT
#            define MUTEX_INIT_CALLS_MALLOC
#          endif
typedef cthread_t	perl_os_thread;
typedef mutex_t		perl_mutex;
typedef condition_t	perl_cond;
typedef void *		perl_key;
#        else /* Posix threads */
#          include <pthread.h>
typedef pthread_t	perl_os_thread;
typedef pthread_mutex_t	perl_mutex;
typedef pthread_cond_t	perl_cond;
typedef pthread_key_t	perl_key;
#        endif /* I_MACH_CTHREADS */
#      endif /* OS2 */
#    endif /* WIN32 */
#  endif /* FAKE_THREADS */
#endif /* USE_THREADS */


  
#ifdef VMS
#   define STATUS_NATIVE	PL_statusvalue_vms
#   define STATUS_NATIVE_EXPORT \
	((I32)PL_statusvalue_vms == -1 ? 44 : PL_statusvalue_vms)
#   define STATUS_NATIVE_SET(n)						\
	STMT_START {							\
	    PL_statusvalue_vms = (n);					\
	    if ((I32)PL_statusvalue_vms == -1)				\
		PL_statusvalue = -1;					\
	    else if (PL_statusvalue_vms & STS$M_SUCCESS)		\
		PL_statusvalue = 0;					\
	    else if ((PL_statusvalue_vms & STS$M_SEVERITY) == 0)	\
		PL_statusvalue = 1 << 8;				\
	    else							\
		PL_statusvalue = (PL_statusvalue_vms & STS$M_SEVERITY) << 8;	\
	} STMT_END
#   define STATUS_POSIX	PL_statusvalue
#   ifdef VMSISH_STATUS
#	define STATUS_CURRENT	(VMSISH_STATUS ? STATUS_NATIVE : STATUS_POSIX)
#   else
#	define STATUS_CURRENT	STATUS_POSIX
#   endif
#   define STATUS_POSIX_SET(n)				\
	STMT_START {					\
	    PL_statusvalue = (n);				\
	    if (PL_statusvalue != -1) {			\
		PL_statusvalue &= 0xFFFF;			\
		PL_statusvalue_vms = PL_statusvalue ? 44 : 1;	\
	    }						\
	    else PL_statusvalue_vms = -1;			\
	} STMT_END
#   define STATUS_ALL_SUCCESS	(PL_statusvalue = 0, PL_statusvalue_vms = 1)
#   define STATUS_ALL_FAILURE	(PL_statusvalue = 1, PL_statusvalue_vms = 44)
#else
#   define STATUS_NATIVE	STATUS_POSIX
#   define STATUS_NATIVE_EXPORT	STATUS_POSIX
#   define STATUS_NATIVE_SET	STATUS_POSIX_SET
#   define STATUS_POSIX		PL_statusvalue
#   define STATUS_POSIX_SET(n)		\
	STMT_START {			\
	    PL_statusvalue = (n);		\
	    if (PL_statusvalue != -1)	\
		PL_statusvalue &= 0xFFFF;	\
	} STMT_END
#   define STATUS_CURRENT STATUS_POSIX
#   define STATUS_ALL_SUCCESS	(PL_statusvalue = 0)
#   define STATUS_ALL_FAILURE	(PL_statusvalue = 1)
#endif

/* Some unistd.h's give a prototype for pause() even though
   HAS_PAUSE ends up undefined.  This causes the #define
   below to be rejected by the compmiler.  Sigh.
*/
#ifdef HAS_PAUSE
#define Pause	pause
#else
#define Pause() sleep((32767<<16)+32767)
a601 3
#ifdef UNION_ANY_DEFINITION
UNION_ANY_DEFINITION;
#else
d607 1
a607 1
    void	(CPERLscope(*any_dptr)) _((void*));
a608 12
#endif

#ifdef USE_THREADS
#define ARGSproto struct perl_thread *thr
#else
#define ARGSproto void
#endif /* USE_THREADS */

/* Work around some cygwin32 problems with importing global symbols */
#if defined(CYGWIN32) && defined(DLLIMPORT) 
#   include "cw32imp.h"
#endif
a622 51
#include "bytecode.h"
#include "byterun.h"

/* Current curly descriptor */
typedef struct curcur CURCUR;
struct curcur {
    int		parenfloor;	/* how far back to strip paren data */
    int		cur;		/* how many instances of scan we've matched */
    int		min;		/* the minimal number of scans to match */
    int		max;		/* the maximal number of scans to match */
    int		minmod;		/* whether to work our way up or down */
    regnode *	scan;		/* the thing to match */
    regnode *	next;		/* what has to match after it */
    char *	lastloc;	/* where we started matching this scan */
    CURCUR *	oldcc;		/* current curly before we started this one */
};

typedef struct _sublex_info SUBLEXINFO;
struct _sublex_info {
    I32 super_state;	/* lexer state to save */
    I32 sub_inwhat;	/* "lex_inwhat" to use */
    OP *sub_op;		/* "lex_op" to use */
};

#ifdef PERL_OBJECT
struct magic_state {
    SV* mgs_sv;
    U32 mgs_flags;
};
typedef struct magic_state MGS;

typedef struct {
    I32 len_min;
    I32 len_delta;
    I32 pos_min;
    I32 pos_delta;
    SV *last_found;
    I32 last_end;			/* min value, <0 unless valid. */
    I32 last_start_min;
    I32 last_start_max;
    SV **longest;			/* Either &l_fixed, or &l_float. */
    SV *longest_fixed;
    I32 offset_fixed;
    SV *longest_float;
    I32 offset_float_min;
    I32 offset_float_max;
    I32 flags;
} scan_data_t;

typedef I32 CHECKPOINT;
#endif /* PERL_OBJECT */
d675 1
a675 1
# if BYTEORDER == 0x4321 || BYTEORDER == 0x87654321
d692 1
a692 1
EXTERN_C U32 cast_ulong _((double));
a702 1
START_EXTERN_C
d704 1
d706 1
a707 3
END_EXTERN_C
#define I_32(what) (cast_i32((double)(what)))
#define I_V(what) (cast_iv((double)(what)))
a732 4
#ifndef Perl_debug_log
#define Perl_debug_log	PerlIO_stderr()
#endif
#undef  YYDEBUG
d735 17
a751 22
#define DEBUG(a)   if (PL_debug)		a
#define DEBUG_p(a) if (PL_debug & 1)	a
#define DEBUG_s(a) if (PL_debug & 2)	a
#define DEBUG_l(a) if (PL_debug & 4)	a
#define DEBUG_t(a) if (PL_debug & 8)	a
#define DEBUG_o(a) if (PL_debug & 16)	a
#define DEBUG_c(a) if (PL_debug & 32)	a
#define DEBUG_P(a) if (PL_debug & 64)	a
#define DEBUG_m(a) if (PL_curinterp && PL_debug & 128)	a
#define DEBUG_f(a) if (PL_debug & 256)	a
#define DEBUG_r(a) if (PL_debug & 512)	a
#define DEBUG_x(a) if (PL_debug & 1024)	a
#define DEBUG_u(a) if (PL_debug & 2048)	a
#define DEBUG_L(a) if (PL_debug & 4096)	a
#define DEBUG_H(a) if (PL_debug & 8192)	a
#define DEBUG_X(a) if (PL_debug & 16384)	a
#define DEBUG_D(a) if (PL_debug & 32768)	a
#  ifdef USE_THREADS
#    define DEBUG_S(a) if (PL_debug & (1<<16))	a
#  else
#    define DEBUG_S(a)
#  endif
d767 1
a767 1
#define DEBUG_S(a)
a770 1
#define DEBUG_S(a)
a773 1
#ifndef assert  /* <assert.h> might have been included somehow */
d778 1
a778 1
	    PerlProc_exit(1);							\
a779 1
#endif
d788 1
a788 1
#ifndef DONT_DECLARE_STD
a796 4
#ifdef OEMVS
char *(strchr)(), *(strrchr)();
char *(strcpy)(), *(strcat)();
#else
a798 1
#endif
d805 3
a807 1
START_EXTERN_C
a809 1
	    double log10 _((double));
a810 2
	    double frexp _((double,int*));
	    double ldexp _((double,int));
d816 3
a818 1
END_EXTERN_C
a821 4
#  ifdef __NeXT__ /* or whatever catches all NeXTs */
char *crypt ();       /* Maybe more hosts will need the unprototyped version */
#  else
#    if !defined(WIN32) || !defined(HAVE_DES_FCRYPT)
a822 4
#    endif /* !WIN32 && !HAVE_CRYPT_SOURCE */
#  endif /* !__NeXT__ */
#  ifndef DONT_DECLARE_STD
#    ifndef getenv
a823 1
#    endif /* !getenv */
a824 1
#  endif /* !DONT_DECLARE_STD */
d826 1
a826 1
#endif /* !__cplusplus */
d832 1
a832 1
#define UNLINK PerlLIO_unlink
a847 8
typedef Signal_t (*Sighandler_t) _((int));

#ifdef HAS_SIGACTION
typedef struct sigaction Sigsave_t;
#else
typedef Sighandler_t Sigsave_t;
#endif

d856 3
a859 1
# define RUNOPS_DEFAULT runops_debug
d861 1
a861 2
# define PAD_SV(po) PL_curpad[po]
# define RUNOPS_DEFAULT runops_standard
d864 3
a866 21
#ifdef MYMALLOC
#  ifdef MUTEX_INIT_CALLS_MALLOC
#    define MALLOC_INIT					\
	STMT_START {					\
		PL_malloc_mutex = NULL;			\
		MUTEX_INIT(&PL_malloc_mutex);		\
	} STMT_END
#    define MALLOC_TERM					\
	STMT_START {					\
		perl_mutex tmp = PL_malloc_mutex;	\
		PL_malloc_mutex = NULL;			\
		MUTEX_DESTROY(&tmp);			\
	} STMT_END
#  else
#    define MALLOC_INIT MUTEX_INIT(&PL_malloc_mutex)
#    define MALLOC_TERM MUTEX_DESTROY(&PL_malloc_mutex)
#  endif
#else
#  define MALLOC_INIT
#  define MALLOC_TERM
#endif
d868 4
a871 11

/*
 * These need prototyping here because <proto.h> isn't
 * included until after runops is initialised.
 */

#ifndef PERL_OBJECT
typedef int runops_proc_t _((void));
int runops_standard _((void));
#ifdef DEBUGGING
int runops_debug _((void));
d873 60
a932 11
#endif  /* PERL_OBJECT */

/* _ (for $_) must be first in the following list (DEFSV requires it) */
#define THREADSV_NAMES "_123456789&`'+/.,\\\";^-%=|~:\001\005!@@"

/* VMS doesn't use environ array and NeXT has problems with crt0.o globals */
#if !defined(VMS) && !(defined(NeXT) && defined(__DYNAMIC__))
#if !defined(DONT_DECLARE_STD) \
	|| (defined(__svr4__) && defined(__GNUC__) && defined(sun)) \
	|| defined(__sgi) || defined(__DGUX)
extern char **	environ;	/* environment variables supplied via exec */
d934 1
a934 9
#else
#  if defined(NeXT) && defined(__DYNAMIC__)

#  include <mach-o/dyld.h>
EXT char *** environ_pointer;
#  define environ (*environ_pointer)
#  endif
#endif /* environ processing */

d942 7
a948 1
EXTCONST char warn_uninit[]
d950 1
a950 1
EXTCONST char warn_nosemi[]
d952 1
a952 1
EXTCONST char warn_reserved[]
d954 1
a954 1
EXTCONST char warn_nl[]
d956 1
a956 1
EXTCONST char no_wrongref[]
d958 1
a958 1
EXTCONST char no_symref[]
d960 1
a960 1
EXTCONST char no_usym[]
d962 1
a962 1
EXTCONST char no_aelem[]
d964 1
a964 1
EXTCONST char no_helem[]
d966 1
a966 1
EXTCONST char no_modify[]
d968 1
a968 1
EXTCONST char no_mem[]
d970 1
a970 1
EXTCONST char no_security[]
d972 1
a972 1
EXTCONST char no_sock_func[]
d974 1
a974 1
EXTCONST char no_dir_func[]
d976 1
a976 1
EXTCONST char no_func[]
d978 1
a978 1
EXTCONST char no_myglob[]
d981 8
a991 2
EXT SV	* psig_ptr[sizeof(sig_num)/sizeof(*sig_num)];
EXT SV  * psig_name[sizeof(sig_num)/sizeof(*sig_num)];
a994 2
EXT SV  * psig_ptr[];
EXT SV  * psig_name[];
a996 2
/* fast case folding tables */

d998 1
a998 37
#ifdef EBCDIC
EXT unsigned char fold[] = { /* fast EBCDIC case folding table */
    0,      1,      2,      3,      4,      5,      6,      7,
    8,      9,      10,     11,     12,     13,     14,     15,
    16,     17,     18,     19,     20,     21,     22,     23,
    24,     25,     26,     27,     28,     29,     30,     31,
    32,     33,     34,     35,     36,     37,     38,     39,
    40,     41,     42,     43,     44,     45,     46,     47,
    48,     49,     50,     51,     52,     53,     54,     55,
    56,     57,     58,     59,     60,     61,     62,     63,
    64,     65,     66,     67,     68,     69,     70,     71,
    72,     73,     74,     75,     76,     77,     78,     79,
    80,     81,     82,     83,     84,     85,     86,     87,
    88,     89,     90,     91,     92,     93,     94,     95,
    96,     97,     98,     99,     100,    101,    102,    103,
    104,    105,    106,    107,    108,    109,    110,    111,
    112,    113,    114,    115,    116,    117,    118,    119,
    120,    121,    122,    123,    124,    125,    126,    127,
    128,    'A',    'B',    'C',    'D',    'E',    'F',    'G',
    'H',    'I',    138,    139,    140,    141,    142,    143,
    144,    'J',    'K',    'L',    'M',    'N',    'O',    'P',
    'Q',    'R',    154,    155,    156,    157,    158,    159,
    160,    161,    'S',    'T',    'U',    'V',    'W',    'X',
    'Y',    'Z',    170,    171,    172,    173,    174,    175,
    176,    177,    178,    179,    180,    181,    182,    183,
    184,    185,    186,    187,    188,    189,    190,    191,
    192,    'a',    'b',    'c',    'd',    'e',    'f',    'g',
    'h',    'i',    202,    203,    204,    205,    206,    207,
    208,    'j',    'k',    'l',    'm',    'n',    'o',    'p',
    'q',    'r',    218,    219,    220,    221,    222,    223,
    224,    225,    's',    't',    'u',    'v',    'w',    'x',
    'y',    'z',    234,    235,    236,    237,    238,    239,
    240,    241,    242,    243,    244,    245,    246,    247,
    248,    249,    250,    251,    252,    253,    254,    255
};
#else   /* ascii rather than ebcdic */
EXTCONST  unsigned char fold[] = {
a1031 1
#endif  /* !EBCDIC */
d1033 1
a1033 1
EXTCONST unsigned char fold[];
d1037 1
a1037 76
EXT unsigned char fold_locale[] = {
	0,	1,	2,	3,	4,	5,	6,	7,
	8,	9,	10,	11,	12,	13,	14,	15,
	16,	17,	18,	19,	20,	21,	22,	23,
	24,	25,	26,	27,	28,	29,	30,	31,
	32,	33,	34,	35,	36,	37,	38,	39,
	40,	41,	42,	43,	44,	45,	46,	47,
	48,	49,	50,	51,	52,	53,	54,	55,
	56,	57,	58,	59,	60,	61,	62,	63,
	64,	'a',	'b',	'c',	'd',	'e',	'f',	'g',
	'h',	'i',	'j',	'k',	'l',	'm',	'n',	'o',
	'p',	'q',	'r',	's',	't',	'u',	'v',	'w',
	'x',	'y',	'z',	91,	92,	93,	94,	95,
	96,	'A',	'B',	'C',	'D',	'E',	'F',	'G',
	'H',	'I',	'J',	'K',	'L',	'M',	'N',	'O',
	'P',	'Q',	'R',	'S',	'T',	'U',	'V',	'W',
	'X',	'Y',	'Z',	123,	124,	125,	126,	127,
	128,	129,	130,	131,	132,	133,	134,	135,
	136,	137,	138,	139,	140,	141,	142,	143,
	144,	145,	146,	147,	148,	149,	150,	151,
	152,	153,	154,	155,	156,	157,	158,	159,
	160,	161,	162,	163,	164,	165,	166,	167,
	168,	169,	170,	171,	172,	173,	174,	175,
	176,	177,	178,	179,	180,	181,	182,	183,
	184,	185,	186,	187,	188,	189,	190,	191,
	192,	193,	194,	195,	196,	197,	198,	199,
	200,	201,	202,	203,	204,	205,	206,	207,
	208,	209,	210,	211,	212,	213,	214,	215,
	216,	217,	218,	219,	220,	221,	222,	223,	
	224,	225,	226,	227,	228,	229,	230,	231,
	232,	233,	234,	235,	236,	237,	238,	239,
	240,	241,	242,	243,	244,	245,	246,	247,
	248,	249,	250,	251,	252,	253,	254,	255
};
#else
EXT unsigned char fold_locale[];
#endif

#ifdef DOINIT
#ifdef EBCDIC
EXT unsigned char freq[] = {/* EBCDIC frequencies for mixed English/C */
    1,      2,      84,     151,    154,    155,    156,    157,
    165,    246,    250,    3,      158,    7,      18,     29,
    40,     51,     62,     73,     85,     96,     107,    118,
    129,    140,    147,    148,    149,    150,    152,    153,
    255,      6,      8,      9,     10,     11,     12,     13,
     14,     15,     24,     25,     26,     27,     28,    226,
     29,     30,     31,     32,     33,     43,     44,     45,
     46,     47,     48,     49,     50,     76,     77,     78,
     79,     80,     81,     82,     83,     84,     85,     86,
     87,     94,     95,    234,    181,    233,    187,    190,
    180,     96,     97,     98,     99,    100,    101,    102,
    104,    112,    182,    174,    236,    232,    229,    103,
    228,    226,    114,    115,    116,    117,    118,    119,
    120,    121,    122,    235,    176,    230,    194,    162,
    130,    131,    132,    133,    134,    135,    136,    137,
    138,    139,    201,    205,    163,    217,    220,    224,
    5,      248,    227,    244,    242,    255,    241,    231,
    240,    253,    16,     197,    19,     20,     21,     187,
    23,     169,    210,    245,    237,    249,    247,    239,
    168,    252,    34,     196,    36,     37,     38,     39,
    41,     42,     251,    254,    238,    223,    221,    213,
    225,    177,    52,     53,     54,     55,     56,     57,
    58,     59,     60,     61,     63,     64,     65,     66,
    67,     68,     69,     70,     71,     72,     74,     75,
    205,    208,    186,    202,    200,    218,    198,    179,
    178,    214,    88,     89,     90,     91,     92,     93,
    217,    166,    170,    207,    199,    209,    206,    204,
    160,    212,    105,    106,    108,    109,    110,    111,
    203,    113,    216,    215,    192,    175,    193,    243,
    172,    161,    123,    124,    125,    126,    127,    128,
    222,    219,    211,    195,    188,    193,    185,    184,
    191,    183,    141,    142,    143,    144,    145,    146
};
#else  /* ascii rather than ebcdic */
EXTCONST unsigned char freq[] = {	/* letter frequencies for mixed English/C */
a1070 1
#endif
d1072 1
a1072 1
EXTCONST unsigned char freq[];
d1077 1
a1077 1
EXTCONST char* block_type[] = {
d1086 1
a1086 1
EXTCONST char* block_type[];
a1096 2
#define LEX_NOTPARSING		11	/* borrowed from toke.c */

d1106 59
a1164 30
enum {		/* pass one of these to get_vtbl */
    want_vtbl_sv,
    want_vtbl_env,
    want_vtbl_envelem,
    want_vtbl_sig,
    want_vtbl_sigelem,
    want_vtbl_pack,
    want_vtbl_packelem,
    want_vtbl_dbline,
    want_vtbl_isa,
    want_vtbl_isaelem,
    want_vtbl_arylen,
    want_vtbl_glob,
    want_vtbl_mglob,
    want_vtbl_nkeys,
    want_vtbl_taint,
    want_vtbl_substr,
    want_vtbl_vec,
    want_vtbl_pos,
    want_vtbl_bm,
    want_vtbl_fm,
    want_vtbl_uvar,
    want_vtbl_defelem,
    want_vtbl_regexp,
    want_vtbl_collxfrm,
    want_vtbl_amagic,
    want_vtbl_amagicelem
#ifdef USE_THREADS
    ,
    want_vtbl_mutex
a1165 1
};
d1167 1
a1176 1
#define HINT_LOCALE		0x00000800
d1178 35
a1212 6
#define HINT_NEW_INTEGER	0x00001000
#define HINT_NEW_FLOAT		0x00002000
#define HINT_NEW_BINARY		0x00004000
#define HINT_NEW_STRING		0x00008000
#define HINT_NEW_RE		0x00010000
#define HINT_LOCALIZE_HH	0x00020000 /* %^H needs to be copied */
d1214 10
a1223 2
#define HINT_RE_TAINT		0x00100000
#define HINT_RE_EVAL		0x00200000
a1228 1
#define RsRECORD(sv)  (SvROK(sv) && (SvIV(SvRV(sv)) > 0))
d1230 173
a1402 12
/* Enable variables which are pointers to functions */
#ifdef PERL_OBJECT
typedef regexp*(CPerlObj::*regcomp_t) _((char* exp, char* xend, PMOP* pm));
typedef I32 (CPerlObj::*regexec_t) _((regexp* prog, char* stringarg,
				      char* strend, char* strbeg,
				      I32 minend, SV* screamer, void* data,
				      U32 flags));
#else
typedef regexp*(*regcomp_t) _((char* exp, char* xend, PMOP* pm));
typedef I32 (*regexec_t) _((regexp* prog, char* stringarg, char* strend, char*
			    strbeg, I32 minend, SV* screamer, void* data, 
			    U32 flags));
d1404 2
a1405 51
#endif

/* Set up PERLVAR macros for populating structs */
#define PERLVAR(var,type) type var;
#define PERLVARI(var,type,init) type var;
#define PERLVARIC(var,type,init) type var;

/* Interpreter exitlist entry */
typedef struct exitlistentry {
#ifdef PERL_OBJECT
    void (*fn) _((CPerlObj*, void*));
#else
    void (*fn) _((void*));
#endif
    void *ptr;
} PerlExitListEntry;

#ifdef PERL_OBJECT
extern "C" CPerlObj* perl_alloc _((IPerlMem*, IPerlEnv*, IPerlStdIO*, IPerlLIO*, IPerlDir*, IPerlSock*, IPerlProc*));

typedef int (CPerlObj::*runops_proc_t) _((void));
#undef EXT
#define EXT
#undef EXTCONST
#define EXTCONST
#undef INIT
#define INIT(x)

class CPerlObj {
public:
	CPerlObj(IPerlMem*, IPerlEnv*, IPerlStdIO*, IPerlLIO*, IPerlDir*, IPerlSock*, IPerlProc*);
	void Init(void);
	void* operator new(size_t nSize, IPerlMem *pvtbl);
#endif /* PERL_OBJECT */

#ifdef PERL_GLOBAL_STRUCT
struct perl_vars {
#include "perlvars.h"
};

#ifdef PERL_CORE
EXT struct perl_vars PL_Vars;
EXT struct perl_vars *PL_VarsPtr INIT(&PL_Vars);
#else /* PERL_CORE */
#if !defined(__GNUC__) || !defined(WIN32)
EXT
#endif /* WIN32 */
struct perl_vars *PL_VarsPtr;
#define PL_Vars (*((PL_VarsPtr) ? PL_VarsPtr : (PL_VarsPtr =  Perl_GetVars())))
#endif /* PERL_CORE */
#endif /* PERL_GLOBAL_STRUCT */
a1407 11
/* If we have multiple interpreters define a struct 
   holding variables which must be per-interpreter
   If we don't have threads anything that would have 
   be per-thread is per-interpreter.
*/

struct interpreter {
#ifndef USE_THREADS
#include "thrdvar.h"
#endif
#include "intrpvar.h"
a1408 1

d1415 1
a1415 4
#ifdef USE_THREADS
/* If we have threads define a struct with all the variables
 * that have to be per-thread
 */
d1417 3
d1421 5
a1425 5
struct perl_thread {
#include "thrdvar.h"
};

typedef struct perl_thread *Thread;
d1427 2
d1430 3
a1432 1
typedef void *Thread;
a1434 7
/* Done with PERLVAR macros for now ... */
#undef PERLVAR
#undef PERLVARI
#undef PERLVARIC

#include "thread.h"
#include "pp.h"
d1445 1
a1445 77
/* The following must follow proto.h as #defines mess up syntax */

#include "embedvar.h"

/* Now include all the 'global' variables 
 * If we don't have threads or multiple interpreters
 * these include variables that would have been their struct-s 
 */
                         
#define PERLVAR(var,type) EXT type PL_##var;
#define PERLVARI(var,type,init) EXT type  PL_##var INIT(init);
#define PERLVARIC(var,type,init) EXTCONST type PL_##var INIT(init);

#ifndef PERL_GLOBAL_STRUCT
#include "perlvars.h"
#endif

#ifndef MULTIPLICITY

#  include "intrpvar.h"
#  ifndef USE_THREADS
#    include "thrdvar.h"
#  endif

#endif

#ifdef PERL_OBJECT
/* from perly.c */
#undef  yydebug
#undef  yynerrs
#undef  yyerrflag
#undef  yychar
#undef  yyssp
#undef  yyvsp
#undef  yyval
#undef  yylval
#define yydebug	    PL_yydebug
#define yynerrs	    PL_yynerrs
#define yyerrflag   PL_yyerrflag
#define yychar	    PL_yychar
#define yyssp	    PL_yyssp
#define yyvsp	    PL_yyvsp
#define yyval	    PL_yyval
#define yylval	    PL_yylval
PERLVAR(yydebug,		int)
PERLVAR(yynerrs,		int)
PERLVAR(yyerrflag,		int)
PERLVAR(yychar,			int)
PERLVAR(yyssp,			short*)
PERLVAR(yyvsp,			YYSTYPE*)
PERLVAR(yyval,			YYSTYPE)
PERLVAR(yylval,			YYSTYPE)

#define efloatbuf		PL_efloatbuf
#define efloatsize		PL_efloatsize
PERLVAR(efloatbuf,		char *)
PERLVAR(efloatsize,		STRLEN)

#define glob_index		PL_glob_index
#define srand_called	PL_srand_called
#define uudmap			PL_uudmap
#define bitcount		PL_bitcount
#define filter_debug	PL_filter_debug
PERLVAR(glob_index,		int)
PERLVAR(srand_called,	bool)
PERLVAR(uudmap[256],	char)
PERLVAR(bitcount,		char*)
PERLVAR(filter_debug,	int)
PERLVAR(super_bufptr,	char*)	/* PL_bufptr that was */
PERLVAR(super_bufend,	char*)	/* PL_bufend that was */

/*
 * The following is a buffer where new variables must
 * be defined to maintain binary compatibility with PERL_OBJECT
 * for 5.005
 */
PERLVAR(object_compatibility[30],	char)
a1446 6

#include "objpp.h"
#ifdef DOINIT
#include "INTERN.h"
#else
#include "EXTERN.h"
a1447 1
#endif  /* PERL_OBJECT */
d1449 1
a1449 16

#undef PERLVAR
#undef PERLVARI
#undef PERLVARIC

#if defined(HASATTRIBUTE) && defined(WIN32)
/*
 * This provides a layer of functions and macros to ensure extensions will
 * get to use the same RTL functions as the core.
 * It has to go here or #define of printf messes up __attribute__
 * stuff in proto.h  
 */
#ifndef PERL_OBJECT
#  include <win32iop.h>
#endif  /* PERL_OBJECT */
#endif	/* WIN32 */
a1451 1

d1456 1
a1456 3
EXT MGVTBL vtbl_env =	{0,	magic_set_all_env,
				0,	magic_clear_all_env,
							0};
d1461 3
a1463 5
EXT MGVTBL vtbl_sigelem =	{magic_getsig,
					magic_setsig,
					0,	magic_clearsig,
							0};
EXT MGVTBL vtbl_pack =	{0,	0,	magic_sizepack,	magic_wipepack,
d1472 1
a1472 2
					0,	magic_setisa,
							0};
a1482 3
EXT MGVTBL vtbl_nkeys =	{magic_getnkeys,
				magic_setnkeys,
					0,	0,	0};
d1485 1
a1485 1
EXT MGVTBL vtbl_substr =	{magic_getsubstr, magic_setsubstr,
d1487 1
a1487 2
EXT MGVTBL vtbl_vec =	{magic_getvec,
				magic_setvec,
a1493 2
EXT MGVTBL vtbl_fm =	{0,	magic_setfm,
					0,	0,	0};
a1496 13
#ifdef USE_THREADS
EXT MGVTBL vtbl_mutex =	{0,	0,	0,	0,	magic_mutexfree};
#endif /* USE_THREADS */
EXT MGVTBL vtbl_defelem = {magic_getdefelem,magic_setdefelem,
					0,	0,	0};

EXT MGVTBL vtbl_regexp = {0,0,0,0, magic_freeregexp};

#ifdef USE_LOCALE_COLLATE
EXT MGVTBL vtbl_collxfrm = {0,
				magic_setcollxfrm,
					0,	0,	0};
#endif
d1505 1
a1505 2
#else /* !DOINIT */

a1518 1
EXT MGVTBL vtbl_nkeys;
a1523 1
EXT MGVTBL vtbl_fm;
a1525 11
#ifdef USE_THREADS
EXT MGVTBL vtbl_mutex;
#endif /* USE_THREADS */

EXT MGVTBL vtbl_defelem;
EXT MGVTBL vtbl_regexp;

#ifdef USE_LOCALE_COLLATE
EXT MGVTBL vtbl_collxfrm;
#endif

d1531 1
a1531 1
#endif /* !DOINIT */
d1534 1
d1536 1
a1536 1
#define NofAMmeth 58
d1538 30
a1567 30
EXTCONST char * AMG_names[NofAMmeth] = {
  "fallback",	"abs",			/* "fallback" should be the first. */
  "bool",	"nomethod",
  "\"\"",	"0+",
  "+",		"+=",
  "-",		"-=",
  "*",		"*=",
  "/",		"/=",
  "%",		"%=",
  "**",		"**=",
  "<<",		"<<=",
  ">>",		">>=",
  "&",		"&=",
  "|",		"|=",
  "^",		"^=",
  "<",		"<=",
  ">",		">=",
  "==",		"!=",
  "<=>",	"cmp",
  "lt",		"le",
  "gt",		"ge",
  "eq",		"ne",
  "!",		"~",
  "++",		"--",
  "atan2",	"cos",
  "sin",	"exp",
  "log",	"sqrt",
  "x",		"x=",
  ".",		".=",
  "=",		"neg"
d1570 1
a1570 1
EXTCONST char * AMG_names[NofAMmeth];
d1573 1
a1573 1
struct am_table {
d1576 1
a1576 2
  U32 flags;
  CV* table[NofAMmeth];
a1578 5
struct am_table_short {
  long was_ok_sub;
  long was_ok_am;
  U32 flags;
};
a1579 1
typedef struct am_table_short AMTS;
a1584 5
#define AMTf_AMAGIC		1
#define AMT_AMAGIC(amt)		((amt)->flags & AMTf_AMAGIC)
#define AMT_AMAGIC_on(amt)	((amt)->flags |= AMTf_AMAGIC)
#define AMT_AMAGIC_off(amt)	((amt)->flags &= ~AMTf_AMAGIC)

d1593 1
a1593 1
  modulo_amg,	modulo_ass_amg,
a1615 32

/*
 * some compilers like to redefine cos et alia as faster
 * (and less accurate?) versions called F_cos et cetera (Quidquid
 * latine dictum sit, altum viditur.)  This trick collides with
 * the Perl overloading (amg).  The following #defines fool both.
 */

#ifdef _FASTMATH
#   ifdef atan2
#       define F_atan2_amg  atan2_amg
#   endif
#   ifdef cos
#       define F_cos_amg    cos_amg
#   endif
#   ifdef exp
#       define F_exp_amg    exp_amg
#   endif
#   ifdef log
#       define F_log_amg    log_amg
#   endif
#   ifdef pow
#       define F_pow_amg    pow_amg
#   endif
#   ifdef sin
#       define F_sin_amg    sin_amg
#   endif
#   ifdef sqrt
#       define F_sqrt_amg   sqrt_amg
#   endif
#endif /* _FASTMATH */

a1616 106

#define PERLDB_ALL	0x3f		/* No _NONAME, _GOTO */
#define PERLDBf_SUB	0x01		/* Debug sub enter/exit. */
#define PERLDBf_LINE	0x02		/* Keep line #. */
#define PERLDBf_NOOPT	0x04		/* Switch off optimizations. */
#define PERLDBf_INTER	0x08		/* Preserve more data for
					   later inspections.  */
#define PERLDBf_SUBLINE	0x10		/* Keep subr source lines. */
#define PERLDBf_SINGLE	0x20		/* Start with single-step on. */
#define PERLDBf_NONAME	0x40		/* For _SUB: no name of the subr. */
#define PERLDBf_GOTO	0x80		/* Report goto: call DB::goto. */

#define PERLDB_SUB	(PL_perldb && (PL_perldb & PERLDBf_SUB))
#define PERLDB_LINE	(PL_perldb && (PL_perldb & PERLDBf_LINE))
#define PERLDB_NOOPT	(PL_perldb && (PL_perldb & PERLDBf_NOOPT))
#define PERLDB_INTER	(PL_perldb && (PL_perldb & PERLDBf_INTER))
#define PERLDB_SUBLINE	(PL_perldb && (PL_perldb & PERLDBf_SUBLINE))
#define PERLDB_SINGLE	(PL_perldb && (PL_perldb & PERLDBf_SINGLE))
#define PERLDB_SUB_NN	(PL_perldb && (PL_perldb & (PERLDBf_NONAME)))
#define PERLDB_GOTO	(PL_perldb && (PL_perldb & PERLDBf_GOTO))


#ifdef USE_LOCALE_NUMERIC

#define SET_NUMERIC_STANDARD() \
    STMT_START {				\
	if (! PL_numeric_standard)			\
	    perl_set_numeric_standard();	\
    } STMT_END

#define SET_NUMERIC_LOCAL() \
    STMT_START {				\
	if (! PL_numeric_local)			\
	    perl_set_numeric_local();		\
    } STMT_END

#else /* !USE_LOCALE_NUMERIC */

#define SET_NUMERIC_STANDARD()  /**/
#define SET_NUMERIC_LOCAL()     /**/

#endif /* !USE_LOCALE_NUMERIC */

#if !defined(PERLIO_IS_STDIO) && defined(HASATTRIBUTE)
/* 
 * Now we have __attribute__ out of the way 
 * Remap printf 
 */
#define printf PerlIO_stdoutf
#endif

#ifndef PERL_SCRIPT_MODE
#define PERL_SCRIPT_MODE "r"
#endif

/*
 * nice_chunk and nice_chunk size need to be set
 * and queried under the protection of sv_mutex
 */
#define offer_nice_chunk(chunk, chunk_size) do {	\
	LOCK_SV_MUTEX;					\
	if (!PL_nice_chunk) {				\
	    PL_nice_chunk = (char*)(chunk);		\
	    PL_nice_chunk_size = (chunk_size);		\
	}						\
	else {						\
	    Safefree(chunk);				\
	}						\
	UNLOCK_SV_MUTEX;				\
    } while (0)

#ifdef HAS_SEM
#   include <sys/ipc.h>
#   include <sys/sem.h>
#   ifndef HAS_UNION_SEMUN	/* Provide the union semun. */
    union semun {
	int val;
	struct semid_ds *buf;
	unsigned short *array;
    };
#   endif
#   ifdef USE_SEMCTL_SEMUN
#       define Semctl(id, num, cmd, semun) semctl(id, num, cmd, semun)
#   else
#       ifdef USE_SEMCTL_SEMID_DS
#           define Semctl(id, num, cmd, semun) semctl(id, num, cmd, semun.buf)
#       endif
#   endif
#   ifndef Semctl	/* Place our bets on the semun horse. */
#       define Semctl(id, num, cmd, semun) semctl(id, num, cmd, semun)
#   endif
#endif

#ifdef IAMSUID

#ifdef I_SYS_STATVFS
#   include <sys/statvfs.h>     /* for f?statvfs() */
#endif
#ifdef I_SYS_MOUNT
#   include <sys/mount.h>       /* for *BSD f?statfs() */
#endif
#ifdef I_MNTENT
#   include <mntent.h>          /* for getmntent() */
#endif

#endif /* IAMSUID */
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d3 1
a3 1
 *    Copyright (c) 1987-2000, Larry Wall
d11 1
d19 3
a26 57
#define VOIDUSED 1
#include "config.h"

#if defined(USE_ITHREADS) && defined(USE_5005THREADS)
#  include "error: USE_ITHREADS and USE_5005THREADS are incompatible"
#endif

/* XXX This next guard can disappear if the sources are revised
   to use USE_5005THREADS throughout. -- A.D  1/6/2000
*/
#if defined(USE_ITHREADS) && defined(USE_THREADS)
#  include "error: USE_ITHREADS and USE_THREADS are incompatible"
#endif

/* See L<perlguts/"The Perl API"> for detailed notes on
 * PERL_IMPLICIT_CONTEXT and PERL_IMPLICIT_SYS */

#ifdef USE_ITHREADS
#  if !defined(MULTIPLICITY) && !defined(PERL_OBJECT)
#    define MULTIPLICITY
#  endif
#endif

#ifdef USE_THREADS
#  ifndef PERL_IMPLICIT_CONTEXT
#    define PERL_IMPLICIT_CONTEXT
#  endif
#endif

#if defined(MULTIPLICITY)
#  ifndef PERL_IMPLICIT_CONTEXT
#    define PERL_IMPLICIT_CONTEXT
#  endif
#endif

#ifdef PERL_CAPI
#  undef PERL_OBJECT
#  ifndef MULTIPLICITY
#    define MULTIPLICITY
#  endif
#  ifndef PERL_IMPLICIT_CONTEXT
#    define PERL_IMPLICIT_CONTEXT
#  endif
#  ifndef PERL_IMPLICIT_SYS
#    define PERL_IMPLICIT_SYS
#  endif
#endif

#ifdef PERL_OBJECT
#  ifndef PERL_IMPLICIT_CONTEXT
#    define PERL_IMPLICIT_CONTEXT
#  endif
#  ifndef PERL_IMPLICIT_SYS
#    define PERL_IMPLICIT_SYS
#  endif
#endif

d50 2
a51 2
      |
      v
d64 1
a64 1
	#define var CPerlObj::PL_var
d66 1
a66 1
	* these are in embed.h
d76 1
a76 1
	#define var pPerl->PL_var
d105 12
a116 16
#define CPERLscope(x)		CPerlObj::x
#define CALL_FPTR(fptr)		(aTHXo->*fptr)

#define pTHXo			CPerlObj *pPerl
#define pTHXo_			pTHXo,
#define aTHXo			this
#define aTHXo_			this,
#define PERL_OBJECT_THIS	aTHXo
#define PERL_OBJECT_THIS_	aTHXo_
#define dTHXoa(a)		pTHXo = a
#define dTHXo			dTHXoa(PERL_GET_THX)

#define pTHXx		void
#define pTHXx_
#define aTHXx
#define aTHXx_
a119 23
#ifdef PERL_IMPLICIT_CONTEXT
#  ifdef USE_THREADS
struct perl_thread;
#    define pTHX	register struct perl_thread *thr
#    define aTHX	thr
#    define dTHR	dNOOP
#  else
#    ifndef MULTIPLICITY
#      define MULTIPLICITY
#    endif
#    define pTHX	register PerlInterpreter *my_perl
#    define aTHX	my_perl
#  endif
#  define dTHXa(a)	pTHX = a
#  define dTHX		dTHXa(PERL_GET_THX)
#  define pTHX_		pTHX,
#  define aTHX_		aTHX,
#  define pTHX_1	2	
#  define pTHX_2	3
#  define pTHX_3	4
#  define pTHX_4	5
#endif

d122 2
d130 3
a132 1
#define CALL_FPTR(fptr) (*fptr)
d136 2
a137 6
#define CALLRUNOPS  CALL_FPTR(PL_runops)
#define CALLREGCOMP CALL_FPTR(PL_regcompp)
#define CALLREGEXEC CALL_FPTR(PL_regexecp)
#define CALLREG_INTUIT_START CALL_FPTR(PL_regint_start)
#define CALLREG_INTUIT_STRING CALL_FPTR(PL_regint_string)
#define CALLREGFREE CALL_FPTR(PL_regfree)
d139 1
a139 35
#ifdef PERL_FLEXIBLE_EXCEPTIONS
#  define CALLPROTECT CALL_FPTR(PL_protect)
#endif

#define NOOP (void)0
#define dNOOP extern int Perl___notused

#ifndef pTHX
#  define pTHX		void
#  define pTHX_
#  define aTHX
#  define aTHX_
#  define dTHXa(a)	dNOOP
#  define dTHX		dNOOP
#  define pTHX_1	1	
#  define pTHX_2	2
#  define pTHX_3	3
#  define pTHX_4	4
#endif

#ifndef pTHXo
#  define pTHXo		pTHX
#  define pTHXo_	pTHX_
#  define aTHXo		aTHX
#  define aTHXo_	aTHX_
#  define dTHXo		dTHX
#endif

#ifndef pTHXx
#  define pTHXx		register PerlInterpreter *my_perl
#  define pTHXx_	pTHXx,
#  define aTHXx		my_perl
#  define aTHXx_	aTHXx,
#  define dTHXx		dTHX
#endif
d151 1
a151 1
#  define EXTERN_C extern
d158 1
d160 3
d189 2
a190 1
#define WITH_THX(s) STMT_START { dTHX; s; } STMT_END
d231 1
a231 1
#if defined(__STDC__) || defined(vax11c) || defined(_AIX) || defined(__stdc__) || defined(__cplusplus) || defined( EPOC)
d235 1
a235 1
#if defined(__cplusplus) || defined(WIN32) || defined(__sgi) || defined(OS2) || defined(__DGUX) || defined( EPOC) || defined(__QNX__)
a304 8
/* HP-UX 10.X CMA (Common Multithreaded Architecure) insists that
   pthread.h must be included before all other header files.
*/
#if (defined(USE_THREADS) || defined(USE_ITHREADS)) \
    && defined(PTHREAD_H_FIRST) && defined(I_PTHREAD)
#  include <pthread.h>
#endif

d325 2
d329 5
a333 9
#if NX_CURRENT_COMPILER_RELEASE >= 500
#  include <bsd/ctypes.h>
#else
#  if NX_CURRENT_COMPILER_RELEASE >= 400
#    include <objc/NXCType.h>
#  else /*  NX_CURRENT_COMPILER_RELEASE < 400 */
#    include <appkit/NXCType.h>
#  endif /*  NX_CURRENT_COMPILER_RELEASE >= 400 */
#endif /*  NX_CURRENT_COMPILER_RELEASE >= 500 */
d376 35
a410 2
#ifdef PERL_MICRO /* Last chance to export Perl_my_swap */
#  define MYSWAP
d412 1
d414 8
a421 3
#if !defined(PERL_FOR_X2P) && !defined(WIN32)
#  include "embed.h"
#endif
d423 1
a423 1
#define MEM_SIZE Size_t
a437 45
/* This comes after <stdlib.h> so we don't try to change the standard
 * library prototypes; we'll use our own in proto.h instead. */

#ifdef MYMALLOC
#  ifdef PERL_POLLUTE_MALLOC
#   ifndef PERL_EXTMALLOC_DEF
#    define Perl_malloc		malloc
#    define Perl_calloc		calloc
#    define Perl_realloc	realloc
#    define Perl_mfree		free
#   endif
#  else
#    define EMBEDMYMALLOC	/* for compatibility */
#  endif
Malloc_t Perl_malloc (MEM_SIZE nbytes);
Malloc_t Perl_calloc (MEM_SIZE elements, MEM_SIZE size);
Malloc_t Perl_realloc (Malloc_t where, MEM_SIZE nbytes);
/* 'mfree' rather than 'free', since there is already a 'perl_free'
 * that causes clashes with case-insensitive linkers */
Free_t   Perl_mfree (Malloc_t where);

typedef struct perl_mstats perl_mstats_t;

struct perl_mstats {
    unsigned long *nfree;
    unsigned long *ntotal;
    long topbucket, topbucket_ev, topbucket_odd, totfree, total, total_chain;
    long total_sbrk, sbrks, sbrk_good, sbrk_slack, start_slack, sbrked_remains;
    long minbucket;
    /* Level 1 info */
    unsigned long *bucket_mem_size;
    unsigned long *bucket_available_size;
};

#  define safemalloc  Perl_malloc
#  define safecalloc  Perl_calloc
#  define saferealloc Perl_realloc
#  define safefree    Perl_mfree
#else  /* MYMALLOC */
#  define safemalloc  safesysmalloc
#  define safecalloc  safesyscalloc
#  define saferealloc safesysrealloc
#  define safefree    safesysfree
#endif /* MYMALLOC */

d450 1
a450 1
        extern char * memcpy (char*, char*, int);
d466 1
a466 1
	extern char *memset (char*, int, int);
d492 1
a492 1
	extern int memcmp (char*, char*, int);
a515 6
#ifndef memchr
#   ifndef HAS_MEMCHR
#       define memchr(s,c,n) ninstr((char*)(s), ((char*)(s)) + n, &(c), &(c) + 1)
#   endif
#endif

d599 1
d604 1
a608 2
#define ERRHV GvHV(PL_errgv)	/* XXX unused, here for compatibility */

d610 1
a610 5
	extern int errno;     /* ANSI allows errno to be an lvalue expr.
			       * For example in multithreaded environments
			       * something like this might happen:
			       * extern int *_errno(void);
			       * #define errno (*_errno()) */
d615 1
a615 1
	char *strerror (int,...);
d618 1
a618 1
	char *strerror (int);
d661 1
a661 2
    /* NeXT needs dirent + sys/dir.h */
#   if  defined(I_SYS_DIR) && (defined(NeXT) || defined(__NeXT__))
a690 4
#ifdef I_SYSMODE
#include <sys/mode.h>
#endif

d769 6
a774 24
#endif

#ifndef S_IRGRP
#   ifdef S_IRUSR
#       define S_IRGRP (S_IRUSR>>3)
#       define S_IWGRP (S_IWUSR>>3)
#       define S_IXGRP (S_IXUSR>>3)
#   else
#       define S_IRGRP 0040
#       define S_IWGRP 0020
#       define S_IXGRP 0010
#   endif
#endif

#ifndef S_IROTH
#   ifdef S_IRUSR
#       define S_IROTH (S_IRUSR>>6)
#       define S_IWOTH (S_IWUSR>>6)
#       define S_IXOTH (S_IXUSR>>6)
#   else
#       define S_IROTH 0040
#       define S_IWOTH 0020
#       define S_IXOTH 0010
#   endif
a784 24
#ifndef S_IRWXU
#   define S_IRWXU (S_IRUSR|S_IWUSR|S_IXUSR)
#endif 

#ifndef S_IRWXG
#   define S_IRWXG (S_IRGRP|S_IWGRP|S_IXGRP)
#endif 

#ifndef S_IRWXO
#   define S_IRWXO (S_IROTH|S_IWOTH|S_IXOTH)
#endif 

#ifndef S_IREAD
#   define S_IREAD S_IRUSR
#endif

#ifndef S_IWRITE
#   define S_IWRITE S_IWUSR
#endif

#ifndef S_IEXEC
#   define S_IEXEC S_IXUSR
#endif

d797 8
a804 1
/*
d810 2
a811 121
typedef IVTYPE IV;
typedef UVTYPE UV;

#if defined(USE_64_BIT_INT) && defined(HAS_QUAD)
#  if QUADKIND == QUAD_IS_INT64_T && defined(INT64_MAX)
#    define IV_MAX INT64_MAX
#    define IV_MIN INT64_MIN
#    define UV_MAX UINT64_MAX
#    ifndef UINT64_MIN
#      define UINT64_MIN 0
#    endif
#    define UV_MIN UINT64_MIN
#  else
#    define IV_MAX PERL_QUAD_MAX
#    define IV_MIN PERL_QUAD_MIN
#    define UV_MAX PERL_UQUAD_MAX
#    define UV_MIN PERL_UQUAD_MIN
#  endif
#  define IV_IS_QUAD
#  define UV_IS_QUAD
#else
#  if defined(INT32_MAX) && IVSIZE == 4
#    define IV_MAX INT32_MAX
#    define IV_MIN INT32_MIN
#    ifndef UINT32_MAX_BROKEN /* e.g. HP-UX with gcc messes this up */
#        define UV_MAX UINT32_MAX
#    else
#        define UV_MAX 4294967295U
#    endif
#    ifndef UINT32_MIN
#      define UINT32_MIN 0
#    endif
#    define UV_MIN UINT32_MIN
#  else
#    define IV_MAX PERL_LONG_MAX
#    define IV_MIN PERL_LONG_MIN
#    define UV_MAX PERL_ULONG_MAX
#    define UV_MIN PERL_ULONG_MIN
#  endif
#  if IVSIZE == 8
#    define IV_IS_QUAD
#    define UV_IS_QUAD
#    ifndef HAS_QUAD
#      define HAS_QUAD
#    endif
#  else
#    undef IV_IS_QUAD
#    undef UV_IS_QUAD
#    undef HAS_QUAD
#  endif
#endif

#define IV_DIG (BIT_DIGITS(IVSIZE * 8))
#define UV_DIG (BIT_DIGITS(UVSIZE * 8))

/*   
 *  The macros INT2PTR and NUM2PTR are (despite their names)
 *  bi-directional: they will convert int/float to or from pointers.
 *  However the conversion to int/float are named explicitly:
 *  PTR2IV, PTR2UV, PTR2NV.
 *
 *  For int conversions we do not need two casts if pointers are
 *  the same size as IV and UV.   Otherwise we need an explicit
 *  cast (PTRV) to avoid compiler warnings.
 */
#if (IVSIZE == PTRSIZE) && (UVSIZE == PTRSIZE)
#  define PTRV			UV
#  define INT2PTR(any,d)	(any)(d)
#else
#  if PTRSIZE == LONGSIZE 
#    define PTRV		unsigned long
#  else
#    define PTRV		unsigned
#  endif
#  define INT2PTR(any,d)	(any)(PTRV)(d)
#endif
#define NUM2PTR(any,d)	(any)(PTRV)(d)
#define PTR2IV(p)	INT2PTR(IV,p)
#define PTR2UV(p)	INT2PTR(UV,p)
#define PTR2NV(p)	NUM2PTR(NV,p)
  
#ifdef USE_LONG_DOUBLE
#  if !(defined(HAS_LONG_DOUBLE) && (LONG_DOUBLESIZE > DOUBLESIZE))
#     undef USE_LONG_DOUBLE /* Ouch! */
#  endif
#endif

#ifdef OVR_DBL_DIG
/* Use an overridden DBL_DIG */
# ifdef DBL_DIG
#  undef DBL_DIG
# endif
# define DBL_DIG OVR_DBL_DIG
#else
/* The following is all to get DBL_DIG, in order to pick a nice
   default value for printing floating point numbers in Gconvert.
   (see config.h)
*/
#ifdef I_LIMITS
#include <limits.h>
#endif
#ifdef I_FLOAT
#include <float.h>
#endif
#ifndef HAS_DBL_DIG
#define DBL_DIG	15   /* A guess that works lots of places */
#endif
#endif
#ifdef I_FLOAT
#include <float.h>
#endif
#ifndef HAS_DBL_DIG
#define DBL_DIG	15   /* A guess that works lots of places */
#endif

#ifdef OVR_LDBL_DIG
/* Use an overridden LDBL_DIG */
# ifdef LDBL_DIG
#  undef LDBL_DIG
# endif
# define LDBL_DIG OVR_LDBL_DIG
d813 2
a814 16
/* The following is all to get LDBL_DIG, in order to pick a nice
   default value for printing floating point numbers in Gconvert.
   (see config.h)
*/
# ifdef I_LIMITS
#   include <limits.h>
# endif
# ifdef I_FLOAT
#  include <float.h>
# endif
# ifndef HAS_LDBL_DIG
#  if LONG_DOUBLESIZE == 10
#   define LDBL_DIG 18 /* assume IEEE */
#  else
#   if LONG_DOUBLESIZE == 12
#    define LDBL_DIG 18 /* gcc? */
d816 3
a818 7
#    if LONG_DOUBLESIZE == 16
#     define LDBL_DIG 33 /* assume IEEE */
#    else
#     if LONG_DOUBLESIZE == DOUBLESIZE
#      define LDBL_DIG DBL_DIG /* bummer */
#     endif
#    endif
a819 2
#  endif
# endif
d822 7
a828 4
typedef NVTYPE NV;

#ifdef I_IEEEFP
#   include <ieeefp.h>
d831 15
a845 50
#ifdef USE_LONG_DOUBLE
#   ifdef I_SUNMATH
#       include <sunmath.h>
#   endif
#   define NV_DIG LDBL_DIG
#   ifdef HAS_SQRTL
        /* libsunmath doesn't have modfl and frexpl as of mid-March 2000 */
	/* XXX Configure probe for modfl and frexpl needed XXX */
#       if defined(__sun) && defined(__svr4)
#           define Perl_modf(x,y) ((long double)modf((double)(x),(double*)(y)))
#           define Perl_frexp(x) ((long double)frexp((double)(x)))
#       else
#           define Perl_modf modfl
#           define Perl_frexp frexpl
#       endif
#       define Perl_cos cosl
#       define Perl_sin sinl
#       define Perl_sqrt sqrtl
#       define Perl_exp expl
#       define Perl_log logl
#       define Perl_atan2 atan2l
#       define Perl_pow powl
#       define Perl_floor floorl
#       define Perl_fmod fmodl
#   endif
#else
#   define NV_DIG DBL_DIG
#   define Perl_modf modf
#   define Perl_frexp frexp
#   define Perl_cos cos
#   define Perl_sin sin
#   define Perl_sqrt sqrt
#   define Perl_exp exp
#   define Perl_log log
#   define Perl_atan2 atan2
#   define Perl_pow pow
#   define Perl_floor floor
#   define Perl_fmod fmod
#endif

#if !defined(Perl_atof) && defined(USE_LONG_DOUBLE) && defined(HAS_LONG_DOUBLE)
#   if !defined(Perl_atof) && defined(HAS_STRTOLD) 
#       define Perl_atof(s) strtold(s, (char**)NULL)
#   endif
#   if !defined(Perl_atof) && defined(HAS_ATOLF)
#       define Perl_atof atolf
#   endif
#endif
#if !defined(Perl_atof)
#   define Perl_atof atof /* we assume atof being available anywhere */
d1017 1
a1017 1
#ifdef UV_IS_QUAD
d1049 1
d1052 1
a1052 1
typedef struct padop PADOP;
d1056 1
d1058 3
a1088 2
typedef struct ptr_tbl_ent PTR_TBL_ENT_t;
typedef struct ptr_tbl PTR_TBL_t;
d1092 4
a1095 4
#if defined(USE_LARGE_FILES) && !defined(NO_64_BIT_RAWIO)
#   if LSEEKSIZE == 8 && !defined(USE_64_BIT_RAWIO)
#       define USE_64_BIT_RAWIO	/* implicit */
#   endif
d1098 3
a1100 101
/* Notice the use of HAS_FSEEKO: now we are obligated to always use
 * fseeko/ftello if possible.  Don't go #defining ftell to ftello yourself,
 * however, because operating systems like to do that themself. */
#ifndef FSEEKSIZE
#   ifdef HAS_FSEEKO
#       define FSEEKSIZE LSEEKSIZE
#   else
#       define FSEEKSIZE LONGSIZE
#   endif  
#endif

#if defined(USE_LARGE_FILES) && !defined(NO_64_BIT_STDIO)
#   if FSEEKSIZE == 8 && !defined(USE_64_BIT_STDIO)
#       define USE_64_BIT_STDIO /* implicit */
#   endif
#endif

#ifdef USE_64_BIT_RAWIO
#   ifdef HAS_OFF64_T
#       undef Off_t
#       define Off_t off64_t
#       undef LSEEKSIZE
#       define LSEEKSIZE 8
#   endif
/* Most 64-bit environments have defines like _LARGEFILE_SOURCE that
 * will trigger defines like the ones below.  Some 64-bit environments,
 * however, do not.  Therefore we have to explicitly mix and match. */
#   if defined(USE_OPEN64)
#       define open open64
#   endif
#   if defined(USE_LSEEK64)
#       define lseek lseek64
#   else
#       if defined(USE_LLSEEK)
#           define lseek llseek
#       endif
#   endif
#   if defined(USE_STAT64)
#       define stat stat64
#   endif
#   if defined(USE_FSTAT64)
#       define fstat fstat64
#   endif
#   if defined(USE_LSTAT64)
#       define lstat lstat64
#   endif
#   if defined(USE_FLOCK64)
#       define flock flock64
#   endif
#   if defined(USE_LOCKF64)
#       define lockf lockf64
#   endif
#   if defined(USE_FCNTL64)
#       define fcntl fcntl64
#   endif
#   if defined(USE_TRUNCATE64)
#       define truncate truncate64
#   endif
#   if defined(USE_FTRUNCATE64)
#       define ftruncate ftruncate64
#   endif
#endif

#ifdef USE_64_BIT_STDIO
#   ifdef HAS_FPOS64_T
#       undef Fpos_t
#       define Fpos_t fpos64_t
#   endif
/* Most 64-bit environments have defines like _LARGEFILE_SOURCE that
 * will trigger defines like the ones below.  Some 64-bit environments,
 * however, do not. */
#   if defined(USE_FOPEN64)
#       define fopen fopen64
#   endif
#   if defined(USE_FSEEK64)
#       define fseek fseek64 /* don't do fseeko here, see perlio.c */
#   endif
#   if defined(USE_FTELL64)
#       define ftell ftell64 /* don't do ftello here, see perlio.c */
#   endif
#   if defined(USE_FSETPOS64)
#       define fsetpos fsetpos64
#   endif
#   if defined(USE_FGETPOS64)
#       define fgetpos fgetpos64
#   endif
#   if defined(USE_TMPFILE64)
#       define tmpfile tmpfile64
#   endif
#   if defined(USE_FREOPEN64)
#       define freopen freopen64
#   endif
#endif

#if defined(OS2)
#  include "iperlsys.h"
#endif

#if defined(__OPEN_VM)
# include "vmesa/vmesaish.h"
#endif
d1121 1
a1121 9
#         if defined(EPOC)
#           include "epocish.h"
#         else
#           if defined(MACOS_TRADITIONAL)
#             include "macos/macish.h"
#           else
#             include "unixish.h"
#           endif
#         endif
d1128 2
a1129 24
#ifndef PERL_SYS_INIT3
#  define PERL_SYS_INIT3(argvp,argcp,envp) PERL_SYS_INIT(argvp,argcp)
#endif

#ifndef MAXPATHLEN
#  ifdef PATH_MAX
#    ifdef _POSIX_PATH_MAX
#       if PATH_MAX > _POSIX_PATH_MAX
/* MAXPATHLEN is supposed to include the final null character,
 * as opposed to PATH_MAX and _POSIX_PATH_MAX. */
#         define MAXPATHLEN (PATH_MAX+1)
#       else
#         define MAXPATHLEN (_POSIX_PATH_MAX+1)
#       endif
#    else
#      define MAXPATHLEN (PATH_MAX+1)
#    endif
#  else
#    ifdef _POSIX_PATH_MAX
#       define MAXPATHLEN (_POSIX_PATH_MAX+1)
#    else
#       define MAXPATHLEN 1024	/* Err on the large side. */
#    endif
#  endif
d1139 1
a1139 2
#if defined(USE_THREADS) || defined(USE_ITHREADS)
#  if defined(USE_THREADS)
d1143 1
a1143 1
#  endif
d1155 1
a1155 1
#          if (defined(NeXT) || defined(__NeXT__)) && defined(PERL_POLLUTE_MALLOC)
d1163 1
a1163 3
#          ifdef I_PTHREAD
#            include <pthread.h>
#          endif
d1172 1
a1172 1
#endif /* USE_THREADS || USE_ITHREADS */
a1173 3
#ifdef WIN32
#  include "win32.h"
#endif
d1175 1
d1179 1
a1179 1
	(((I32)PL_statusvalue_vms == -1 ? 44 : PL_statusvalue_vms) | (VMSISH_HUSHED ? 0x10000000 : 0))
a1224 64
/* flags in PL_exit_flags for nature of exit() */
#define PERL_EXIT_EXPECTED	0x01

#ifndef MEMBER_TO_FPTR
#  define MEMBER_TO_FPTR(name)		name
#endif

/* format to use for version numbers in file/directory names */
/* XXX move to Configure? */
#ifndef PERL_FS_VER_FMT
#  define PERL_FS_VER_FMT	"%d.%d.%d"
#endif

/* This defines a way to flush all output buffers.  This may be a
 * performance issue, so we allow people to disable it.
 */
#ifndef PERL_FLUSHALL_FOR_CHILD
# if defined(FFLUSH_NULL) || defined(USE_SFIO)
#  define PERL_FLUSHALL_FOR_CHILD	PerlIO_flush((PerlIO*)NULL)
# else
#  ifdef FFLUSH_ALL
#   define PERL_FLUSHALL_FOR_CHILD	my_fflush_all()
#  else
#   define PERL_FLUSHALL_FOR_CHILD	NOOP
#  endif
# endif
#endif

#ifndef PERL_WAIT_FOR_CHILDREN
#  define PERL_WAIT_FOR_CHILDREN	NOOP
#endif

/* the traditional thread-unsafe notion of "current interpreter". */
#ifndef PERL_SET_INTERP
#  define PERL_SET_INTERP(i)		(PL_curinterp = (PerlInterpreter*)(i))
#endif

#ifndef PERL_GET_INTERP
#  define PERL_GET_INTERP		(PL_curinterp)
#endif

#if defined(PERL_IMPLICIT_CONTEXT) && !defined(PERL_GET_THX)
#  ifdef USE_THREADS
#    define PERL_GET_THX		((struct perl_thread *)PERL_GET_CONTEXT)
#  else
#  ifdef MULTIPLICITY
#    define PERL_GET_THX		((PerlInterpreter *)PERL_GET_CONTEXT)
#  else
#  ifdef PERL_OBJECT
#    define PERL_GET_THX		((CPerlObj *)PERL_GET_CONTEXT)
#  endif
#  endif
#  endif
#  define PERL_SET_THX(t)		PERL_SET_CONTEXT(t)
#endif

#ifndef SVf
#  ifdef CHECK_FORMAT
#    define SVf "p"
#  else
#    define SVf "_"
#  endif 
#endif

a1244 12
#if defined(__CYGWIN__)
/* USEMYBINMODE
 *   This symbol, if defined, indicates that the program should
 *   use the routine my_binmode(FILE *fp, char iotype, int mode) to insure
 *   that a file is in "binary" mode -- that is, that no translation
 *   of bytes occurs on read or write operations.
 */
#  define USEMYBINMODE / **/
#  define my_binmode(fp, iotype, mode) \
            (PerlLIO_setmode(PerlIO_fileno(fp), mode) != -1 ? TRUE : FALSE)
#endif

d1253 1
a1253 2
    void	(*any_dptr) (void*);
    void	(*any_dxptr) (pTHXo_ void*);
d1260 1
a1260 1
#define ARGSproto
d1263 4
a1266 1
typedef I32 (*filter_t) (pTHXo_ int, SV *, int);
a1267 7
#define FILTER_READ(idx, sv, len)  filter_read(idx, sv, len)
#define FILTER_DATA(idx)	   (AvARRAY(PL_rsfp_filters)[idx])
#define FILTER_ISREADER(idx)	   (idx >= AvFILLp(PL_rsfp_filters))

#if !defined(OS2)
#  include "iperlsys.h"
#endif
d1274 1
a1274 1
#include "opnames.h"
d1281 2
a1282 2
#include "warnings.h"
#include "utf8.h"
a1302 2
    char *super_bufptr;	/* PL_bufptr that was */
    char *super_bufend;	/* PL_bufend that was */
d1305 24
a1328 4
typedef struct magic_state MGS;	/* struct magic_state defined in mg.c */

struct scan_data_t;		/* Used in S_* functions in regcomp.c */
struct regnode_charclass_class;	/* Used in S_* functions in regcomp.c */
d1331 1
d1333 4
a1336 11
struct ptr_tbl_ent {
    struct ptr_tbl_ent*		next;
    void*			oldval;
    void*			newval;
};

struct ptr_tbl {
    struct ptr_tbl_ent**	tbl_ary;
    UV				tbl_max;
    UV				tbl_items;
};
d1401 4
a1404 3
#define U_S(what) ((U16)cast_ulong((NV)(what)))
#define U_I(what) ((unsigned int)cast_ulong((NV)(what)))
#define U_L(what) (cast_ulong((NV)(what)))
d1412 8
a1419 3
#define I_32(what) (cast_i32((NV)(what)))
#define I_V(what) (cast_iv((NV)(what)))
#define U_V(what) (cast_uv((NV)(what)))
d1422 5
a1426 8
/* These do not care about the fractional part, only about the range. */
#define NV_WITHIN_IV(nv) (I_V(nv) >= IV_MIN && I_V(nv) <= IV_MAX)
#define NV_WITHIN_UV(nv) ((nv)>=0.0 && U_V(nv) >= UV_MIN && U_V(nv) <= UV_MAX)

/* Used with UV/IV arguments: */
					/* XXXX: need to speed it up */
#define CLUMP_2UV(iv)	((iv) < 0 ? 0 : (UV)(iv))
#define CLUMP_2IV(uv)	((uv) > (UV)IV_MAX ? IV_MAX : (IV)(uv))
d1432 4
d1437 4
a1440 4
Uid_t getuid (void);
Uid_t geteuid (void);
Gid_t getgid (void);
Gid_t getegid (void);
d1443 1
d1445 1
a1445 8
#  define Perl_debug_log	PerlIO_stderr()
#endif

#ifndef Perl_error_log
#  define Perl_error_log	(PL_stderrgv			\
				 && IoOFP(GvIOp(PL_stderrgv))	\
				 ? IoOFP(GvIOp(PL_stderrgv))	\
				 : PerlIO_stderr())
a1446 2

#ifdef DEBUGGING
d1458 1
a1458 8
#  if defined(PERL_OBJECT)
#    define DEBUG_m(a) if (PL_debug & 128)	a
#  else
#    define DEBUG_m(a)  \
    STMT_START {							\
	if (PERL_GET_INTERP) { dTHX; if (PL_debug & 128) { a; } }	\
    } STMT_END
#  endif
d1498 1
a1498 1
	    Perl_croak(aTHX_ "Assertion failed: file \"%s\", line %d",	\
d1500 1
a1500 1
	    PerlProc_exit(1);						\
d1505 2
a1506 2
    I32 (*uf_val)(IV, SV*);
    I32 (*uf_set)(IV, SV*);
d1512 2
a1513 4
char *mktemp (char*);
#ifndef atof
double atof (const char*);
#endif
d1520 1
a1520 1
#if defined(OEMVS) || defined(__OPEN_VM)
d1534 11
a1544 11
	    double exp (double);
	    double log (double);
	    double log10 (double);
	    double sqrt (double);
	    double frexp (double,int*);
	    double ldexp (double,int);
	    double modf (double,double*);
	    double sin (double);
	    double cos (double);
	    double atan2 (double,double);
	    double pow (double,double);
d1549 1
a1549 1
#  if defined(NeXT) || defined(__NeXT__) /* or whatever catches all NeXTs */
d1552 4
a1555 4
#    if !defined(WIN32)
char *crypt (const char*, const char*);
#    endif /* !WIN32 */
#  endif /* !NeXT && !__NeXT__ */
d1558 1
a1558 1
char *getenv (const char*);
d1560 1
a1560 3
#    if !defined(EPOC) && !(defined(__hpux) && defined(_FILE_OFFSET_BITS) && _FILE_OFFSET_BITS == 64) && !defined(HAS_LSEEK_PROTO)
Off_t lseek (int,Off_t,int);
#    endif
d1562 1
a1562 1
char *getlogin (void);
d1567 1
a1567 1
I32 unlnk (char*);
d1585 1
a1585 1
/* Sighandler_t defined in iperlsys.h */
d1602 1
a1602 1
# define RUNOPS_DEFAULT Perl_runops_debug
d1605 1
a1605 1
# define RUNOPS_DEFAULT Perl_runops_standard
d1631 12
a1642 2
typedef int (CPERLscope(*runops_proc_t)) (pTHX);
typedef OP* (CPERLscope(*PPADDR_t)[]) (pTHX);
d1647 11
a1657 6
/* NeXT has problems with crt0.o globals */
#if defined(__DYNAMIC__) && \
    (defined(NeXT) || defined(__NeXT__) || defined(__APPLE__))
#  if defined(NeXT) || defined(__NeXT)
#    include <mach-o/dyld.h>
#    define environ (*environ_pointer)
d1659 1
a1659 5
#  else
#    if defined(__APPLE__)
#      include <crt_externs.h>	/* for the env array */
#      define environ (*_NSGetEnviron())
#    endif
d1661 2
a1662 11
#else
   /* VMS and some other platforms don't use the environ array */
#  if !defined(VMS)
#    if !defined(DONT_DECLARE_STD) || \
        (defined(__svr4__) && defined(__GNUC__) && defined(sun)) || \
        defined(__sgi) || \
        defined(__DGUX) || defined(EPOC)
extern char **	environ;	/* environment variables supplied via exec */
#    endif
#  endif
#endif
d1664 4
a1667 1
START_EXTERN_C
d1670 3
a1672 3
EXTCONST char PL_warn_uninit[]
  INIT("Use of uninitialized value%s%s");
EXTCONST char PL_warn_nosemi[]
d1674 1
a1674 1
EXTCONST char PL_warn_reserved[]
d1676 1
a1676 1
EXTCONST char PL_warn_nl[]
d1678 1
a1678 1
EXTCONST char PL_no_wrongref[]
d1680 1
a1680 1
EXTCONST char PL_no_symref[]
d1682 1
a1682 1
EXTCONST char PL_no_usym[]
d1684 1
a1684 1
EXTCONST char PL_no_aelem[]
d1686 1
a1686 1
EXTCONST char PL_no_helem[]
d1688 1
a1688 1
EXTCONST char PL_no_modify[]
d1690 1
a1690 1
EXTCONST char PL_no_mem[]
d1692 1
a1692 1
EXTCONST char PL_no_security[]
d1694 1
a1694 1
EXTCONST char PL_no_sock_func[]
d1696 1
a1696 1
EXTCONST char PL_no_dir_func[]
d1698 1
a1698 1
EXTCONST char PL_no_func[]
d1700 1
a1700 1
EXTCONST char PL_no_myglob[]
a1702 4
EXTCONST char PL_uuemap[65]
  INIT("`!\"#$%&'()*+,-./0123456789:;<=>?@@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_");


d1704 9
a1712 5
EXT char *PL_sig_name[] = { SIG_NAME };
EXT int   PL_sig_num[]  = { SIG_NUM };
#else
EXT char *PL_sig_name[];
EXT int   PL_sig_num[];
d1719 1
a1719 1
EXT unsigned char PL_fold[] = { /* fast EBCDIC case folding table */
d1754 1
a1754 1
EXTCONST  unsigned char PL_fold[] = {
d1790 1
a1790 1
EXTCONST unsigned char PL_fold[];
d1794 1
a1794 1
EXT unsigned char PL_fold_locale[] = {
d1829 1
a1829 1
EXT unsigned char PL_fold_locale[];
d1834 1
a1834 1
EXT unsigned char PL_freq[] = {/* EBCDIC frequencies for mixed English/C */
d1869 1
a1869 1
EXTCONST unsigned char PL_freq[] = {	/* letter frequencies for mixed English/C */
d1905 1
a1905 1
EXTCONST unsigned char PL_freq[];
d1910 1
a1910 1
EXTCONST char* PL_block_type[] = {
d1919 1
a1919 1
EXTCONST char* PL_block_type[];
a1922 2
END_EXTERN_C

a1937 2
    XATTRBLOCK,
    XATTRTERM,
d1967 1
a1967 1
    want_vtbl_amagicelem,
d1969 2
a1970 1
    want_vtbl_mutex,
a1971 3
    want_vtbl_regdata,
    want_vtbl_regdatum,
    want_vtbl_backref
d1974 1
a1976 1
#define HINT_PRIVATE_MASK	0x000000ff
a1978 4
/* #define HINT_notused4	0x00000004 */
#define HINT_BYTE		0x00000008
/* #define HINT_notused10	0x00000010 */
				/* Note: 20,40,80 used for NATIVE_HINTS */
a1994 3
#define HINT_FILETEST_ACCESS	0x00400000
#define HINT_UTF8		0x00800000

d1997 2
a1998 2
#define RsSIMPLE(sv)  (SvOK(sv) && (! SvPOK(sv) || SvCUR(sv)))
#define RsPARA(sv)    (SvPOK(sv) && ! SvCUR(sv))
d2002 13
a2014 22
typedef regexp*(CPERLscope(*regcomp_t)) (pTHX_ char* exp, char* xend, PMOP* pm);
typedef I32 (CPERLscope(*regexec_t)) (pTHX_ regexp* prog, char* stringarg,
				      char* strend, char* strbeg, I32 minend,
				      SV* screamer, void* data, U32 flags);
typedef char* (CPERLscope(*re_intuit_start_t)) (pTHX_ regexp *prog, SV *sv,
						char *strpos, char *strend,
						U32 flags,
						struct re_scream_pos_data_s *d);
typedef SV*	(CPERLscope(*re_intuit_string_t)) (pTHX_ regexp *prog);
typedef void	(CPERLscope(*regfree_t)) (pTHX_ struct regexp* r);

#ifdef USE_PURE_BISON
int Perl_yylex(pTHX_ YYSTYPE *lvalp, int *lcharp);
#endif

typedef void (*DESTRUCTORFUNC_NOCONTEXT_t) (void*);
typedef void (*DESTRUCTORFUNC_t) (pTHXo_ void*);
typedef void (*SVFUNC_t) (pTHXo_ SV*);
typedef I32  (*SVCOMPARE_t) (pTHXo_ SV*, SV*);
typedef void (*XSINIT_t) (pTHXo);
typedef void (*ATEXIT_t) (pTHXo_ void*);
typedef void (*XSUBADDR_t) (pTHXo_ CV *);
a2017 1
#define PERLVARA(var,n,type) type var[n];
d2023 5
a2027 1
    void (*fn) (pTHXo_ void*);
d2031 18
d2051 1
a2051 1
#  include "perlvars.h"
d2054 1
a2054 1
#  ifdef PERL_CORE
d2057 2
a2058 2
#  else /* PERL_CORE */
#    if !defined(__GNUC__) || !defined(WIN32)
d2060 1
a2060 1
#    endif /* WIN32 */
d2062 2
a2063 3
#    define PL_Vars (*((PL_VarsPtr) \
		       ? PL_VarsPtr : (PL_VarsPtr = Perl_GetVars(aTHX))))
#  endif /* PERL_CORE */
d2066 1
a2066 1
#if defined(MULTIPLICITY) || defined(PERL_OBJECT)
d2074 4
a2077 9
#  ifndef USE_THREADS
#    include "thrdvar.h"
#  endif
#  include "intrpvar.h"
/*
 * The following is a buffer where new variables must
 * be defined to maintain binary compatibility with PERL_OBJECT
 */
PERLVARA(object_compatibility,30,	char)
d2084 1
a2084 1
#endif /* MULTIPLICITY || PERL_OBJECT */
a2103 1
#undef PERLVARA
a2108 23

#ifndef PERL_CALLCONV
#  define PERL_CALLCONV
#endif 

#ifndef NEXT30_NO_ATTRIBUTE
#  ifndef HASATTRIBUTE       /* disable GNU-cc attribute checking? */
#    ifdef  __attribute__      /* Avoid possible redefinition errors */
#      undef  __attribute__
#    endif
#    define __attribute__(attr)
#  endif
#endif

#ifdef PERL_OBJECT
#  define PERL_DECL_PROT
#endif

#undef PERL_CKDEF
#undef PERL_PPDEF
#define PERL_CKDEF(s)	OP *s (pTHX_ OP *o);
#define PERL_PPDEF(s)	OP *s (pTHX);

d2111 6
a2116 7
#ifdef PERL_OBJECT
#  undef PERL_DECL_PROT
#endif

#ifndef PERL_OBJECT
/* this has structure inits, so it cannot be included before here */
#  include "opcode.h"
d2121 1
a2121 3
#if !defined(PERL_FOR_X2P)
#  include "embedvar.h"
#endif
a2128 1
#define PERLVARA(var,n,type) EXT type PL_##var[n];
d2132 6
a2137 2
#if !defined(MULTIPLICITY) && !defined(PERL_OBJECT)
START_EXTERN_C
d2142 1
a2142 1
END_EXTERN_C
d2146 43
a2188 1
#  include "embed.h"
d2190 7
a2196 8
#  ifdef DOINIT
#    include "INTERN.h"
#  else
#    include "EXTERN.h"
#  endif

/* this has structure inits, so it cannot be included before here */
#  include "opcode.h"
d2198 3
d2202 2
a2203 3
#  if defined(WIN32)
#    include "embed.h"
#  endif
a2205 7
#ifndef PERL_GLOBAL_STRUCT
START_EXTERN_C

#  include "perlvars.h"

END_EXTERN_C
#endif
a2207 1
#undef PERLVARA
d2211 11
a2221 1
START_EXTERN_C
d2225 3
a2227 3
EXT MGVTBL PL_vtbl_sv =	{MEMBER_TO_FPTR(Perl_magic_get),
				MEMBER_TO_FPTR(Perl_magic_set),
					MEMBER_TO_FPTR(Perl_magic_len),
d2229 2
a2230 2
EXT MGVTBL PL_vtbl_env =	{0,	MEMBER_TO_FPTR(Perl_magic_set_all_env),
				0,	MEMBER_TO_FPTR(Perl_magic_clear_all_env),
d2232 2
a2233 2
EXT MGVTBL PL_vtbl_envelem =	{0,	MEMBER_TO_FPTR(Perl_magic_setenv),
					0,	MEMBER_TO_FPTR(Perl_magic_clearenv),
d2235 4
a2238 4
EXT MGVTBL PL_vtbl_sig =	{0,	0,		 0, 0, 0};
EXT MGVTBL PL_vtbl_sigelem =	{MEMBER_TO_FPTR(Perl_magic_getsig),
					MEMBER_TO_FPTR(Perl_magic_setsig),
					0,	MEMBER_TO_FPTR(Perl_magic_clearsig),
d2240 1
a2240 1
EXT MGVTBL PL_vtbl_pack =	{0,	0,	MEMBER_TO_FPTR(Perl_magic_sizepack),	MEMBER_TO_FPTR(Perl_magic_wipepack),
d2242 3
a2244 3
EXT MGVTBL PL_vtbl_packelem =	{MEMBER_TO_FPTR(Perl_magic_getpack),
				MEMBER_TO_FPTR(Perl_magic_setpack),
					0,	MEMBER_TO_FPTR(Perl_magic_clearpack),
d2246 1
a2246 1
EXT MGVTBL PL_vtbl_dbline =	{0,	MEMBER_TO_FPTR(Perl_magic_setdbline),
d2248 2
a2249 2
EXT MGVTBL PL_vtbl_isa =	{0,	MEMBER_TO_FPTR(Perl_magic_setisa),
					0,	MEMBER_TO_FPTR(Perl_magic_setisa),
d2251 1
a2251 1
EXT MGVTBL PL_vtbl_isaelem =	{0,	MEMBER_TO_FPTR(Perl_magic_setisa),
d2253 2
a2254 2
EXT MGVTBL PL_vtbl_arylen =	{MEMBER_TO_FPTR(Perl_magic_getarylen),
				MEMBER_TO_FPTR(Perl_magic_setarylen),
d2256 2
a2257 2
EXT MGVTBL PL_vtbl_glob =	{MEMBER_TO_FPTR(Perl_magic_getglob),
				MEMBER_TO_FPTR(Perl_magic_setglob),
d2259 1
a2259 1
EXT MGVTBL PL_vtbl_mglob =	{0,	MEMBER_TO_FPTR(Perl_magic_setmglob),
d2261 2
a2262 2
EXT MGVTBL PL_vtbl_nkeys =	{MEMBER_TO_FPTR(Perl_magic_getnkeys),
				MEMBER_TO_FPTR(Perl_magic_setnkeys),
d2264 1
a2264 1
EXT MGVTBL PL_vtbl_taint =	{MEMBER_TO_FPTR(Perl_magic_gettaint),MEMBER_TO_FPTR(Perl_magic_settaint),
d2266 1
a2266 1
EXT MGVTBL PL_vtbl_substr =	{MEMBER_TO_FPTR(Perl_magic_getsubstr), MEMBER_TO_FPTR(Perl_magic_setsubstr),
d2268 2
a2269 2
EXT MGVTBL PL_vtbl_vec =	{MEMBER_TO_FPTR(Perl_magic_getvec),
				MEMBER_TO_FPTR(Perl_magic_setvec),
d2271 2
a2272 2
EXT MGVTBL PL_vtbl_pos =	{MEMBER_TO_FPTR(Perl_magic_getpos),
				MEMBER_TO_FPTR(Perl_magic_setpos),
d2274 1
a2274 1
EXT MGVTBL PL_vtbl_bm =	{0,	MEMBER_TO_FPTR(Perl_magic_setbm),
d2276 1
a2276 1
EXT MGVTBL PL_vtbl_fm =	{0,	MEMBER_TO_FPTR(Perl_magic_setfm),
d2278 2
a2279 2
EXT MGVTBL PL_vtbl_uvar =	{MEMBER_TO_FPTR(Perl_magic_getuvar),
				MEMBER_TO_FPTR(Perl_magic_setuvar),
d2282 1
a2282 1
EXT MGVTBL PL_vtbl_mutex =	{0,	0,	0,	0,	MEMBER_TO_FPTR(Perl_magic_mutexfree)};
d2284 1
a2284 1
EXT MGVTBL PL_vtbl_defelem = {MEMBER_TO_FPTR(Perl_magic_getdefelem),MEMBER_TO_FPTR(Perl_magic_setdefelem),
d2287 1
a2287 3
EXT MGVTBL PL_vtbl_regexp = {0,0,0,0, MEMBER_TO_FPTR(Perl_magic_freeregexp)};
EXT MGVTBL PL_vtbl_regdata = {0, 0, MEMBER_TO_FPTR(Perl_magic_regdata_cnt), 0, 0};
EXT MGVTBL PL_vtbl_regdatum = {MEMBER_TO_FPTR(Perl_magic_regdatum_get), 0, 0, 0, 0};
d2290 2
a2291 2
EXT MGVTBL PL_vtbl_collxfrm = {0,
				MEMBER_TO_FPTR(Perl_magic_setcollxfrm),
d2295 6
a2300 7
EXT MGVTBL PL_vtbl_amagic =       {0,     MEMBER_TO_FPTR(Perl_magic_setamagic),
                                        0,      0,      MEMBER_TO_FPTR(Perl_magic_setamagic)};
EXT MGVTBL PL_vtbl_amagicelem =   {0,     MEMBER_TO_FPTR(Perl_magic_setamagic),
                                        0,      0,      MEMBER_TO_FPTR(Perl_magic_setamagic)};

EXT MGVTBL PL_vtbl_backref = 	  {0,	0,
					0,	0,	MEMBER_TO_FPTR(Perl_magic_killbackrefs)};
d2304 21
a2324 21
EXT MGVTBL PL_vtbl_sv;
EXT MGVTBL PL_vtbl_env;
EXT MGVTBL PL_vtbl_envelem;
EXT MGVTBL PL_vtbl_sig;
EXT MGVTBL PL_vtbl_sigelem;
EXT MGVTBL PL_vtbl_pack;
EXT MGVTBL PL_vtbl_packelem;
EXT MGVTBL PL_vtbl_dbline;
EXT MGVTBL PL_vtbl_isa;
EXT MGVTBL PL_vtbl_isaelem;
EXT MGVTBL PL_vtbl_arylen;
EXT MGVTBL PL_vtbl_glob;
EXT MGVTBL PL_vtbl_mglob;
EXT MGVTBL PL_vtbl_nkeys;
EXT MGVTBL PL_vtbl_taint;
EXT MGVTBL PL_vtbl_substr;
EXT MGVTBL PL_vtbl_vec;
EXT MGVTBL PL_vtbl_pos;
EXT MGVTBL PL_vtbl_bm;
EXT MGVTBL PL_vtbl_fm;
EXT MGVTBL PL_vtbl_uvar;
d2327 1
a2327 1
EXT MGVTBL PL_vtbl_mutex;
d2330 2
a2331 4
EXT MGVTBL PL_vtbl_defelem;
EXT MGVTBL PL_vtbl_regexp;
EXT MGVTBL PL_vtbl_regdata;
EXT MGVTBL PL_vtbl_regdatum;
d2334 1
a2334 1
EXT MGVTBL PL_vtbl_collxfrm;
d2337 4
a2340 4
EXT MGVTBL PL_vtbl_amagic;
EXT MGVTBL PL_vtbl_amagicelem;

EXT MGVTBL PL_vtbl_backref;
d2344 1
a2344 38
enum {
  fallback_amg,        abs_amg,
  bool__amg,   nomethod_amg,
  string_amg,  numer_amg,
  add_amg,     add_ass_amg,
  subtr_amg,   subtr_ass_amg,
  mult_amg,    mult_ass_amg,
  div_amg,     div_ass_amg,
  modulo_amg,  modulo_ass_amg,
  pow_amg,     pow_ass_amg,
  lshift_amg,  lshift_ass_amg,
  rshift_amg,  rshift_ass_amg,
  band_amg,    band_ass_amg,
  bor_amg,     bor_ass_amg,
  bxor_amg,    bxor_ass_amg,
  lt_amg,      le_amg,
  gt_amg,      ge_amg,
  eq_amg,      ne_amg,
  ncmp_amg,    scmp_amg,
  slt_amg,     sle_amg,
  sgt_amg,     sge_amg,
  seq_amg,     sne_amg,
  not_amg,     compl_amg,
  inc_amg,     dec_amg,
  atan2_amg,   cos_amg,
  sin_amg,     exp_amg,
  log_amg,     sqrt_amg,
  repeat_amg,   repeat_ass_amg,
  concat_amg,  concat_ass_amg,
  copy_amg,    neg_amg,
  to_sv_amg,   to_av_amg,
  to_hv_amg,   to_gv_amg,
  to_cv_amg,   iter_amg,    
  max_amg_code
  /* Do not leave a trailing comma here.  C9X allows it, C89 doesn't. */
};

#define NofAMmeth max_amg_code
d2346 1
d2348 1
a2348 1
EXTCONST char * PL_AMG_names[NofAMmeth] = {
d2377 1
a2377 4
  "=",		"neg",
  "${}",	"@@{}",
  "%{}",	"*{}",
  "&{}",	"<>",
d2380 1
a2380 1
EXTCONST char * PL_AMG_names[NofAMmeth];
a2382 2
END_EXTERN_C

d2407 31
d2470 12
a2481 16
#define PERLDB_ALL		(PERLDBf_SUB	| PERLDBf_LINE	|	\
				 PERLDBf_NOOPT	| PERLDBf_INTER	|	\
				 PERLDBf_SUBLINE| PERLDBf_SINGLE|	\
				 PERLDBf_NAMEEVAL| PERLDBf_NAMEANON)
					/* No _NONAME, _GOTO */
#define PERLDBf_SUB		0x01	/* Debug sub enter/exit */
#define PERLDBf_LINE		0x02	/* Keep line # */
#define PERLDBf_NOOPT		0x04	/* Switch off optimizations */
#define PERLDBf_INTER		0x08	/* Preserve more data for
					   later inspections  */
#define PERLDBf_SUBLINE		0x10	/* Keep subr source lines */
#define PERLDBf_SINGLE		0x20	/* Start with single-step on */
#define PERLDBf_NONAME		0x40	/* For _SUB: no name of the subr */
#define PERLDBf_GOTO		0x80	/* Report goto: call DB::goto */
#define PERLDBf_NAMEEVAL	0x100	/* Informative names for evals */
#define PERLDBf_NAMEANON	0x200	/* Informative names for anon subs */
a2490 2
#define PERLDB_NAMEEVAL	(PL_perldb && (PL_perldb & PERLDBf_NAMEEVAL))
#define PERLDB_NAMEANON	(PL_perldb && (PL_perldb & PERLDBf_NAMEANON))
d2497 2
a2498 2
	if (! PL_numeric_standard)		\
	    set_numeric_standard();		\
d2504 1
a2504 1
	    set_numeric_local();		\
a2506 8
#define IS_NUMERIC_RADIX(c)	\
	((PL_hints & HINT_LOCALE) && \
	  PL_numeric_radix && (c) == PL_numeric_radix)

#define RESTORE_NUMERIC_LOCAL()		if ((PL_hints & HINT_LOCALE) && PL_numeric_standard) SET_NUMERIC_LOCAL()
#define RESTORE_NUMERIC_STANDARD()	if ((PL_hints & HINT_LOCALE) && PL_numeric_local) SET_NUMERIC_STANDARD()
#define Atof				my_atof

d2509 2
a2510 6
#define SET_NUMERIC_STANDARD()  	/**/
#define SET_NUMERIC_LOCAL()     	/**/
#define IS_NUMERIC_RADIX(c)		(0)
#define RESTORE_NUMERIC_LOCAL()		/**/
#define RESTORE_NUMERIC_STANDARD()	/**/
#define Atof				Perl_atof
a2513 42
#if !defined(Strtol) && defined(USE_64_BIT_INT) && defined(IV_IS_QUAD) && QUADKIND == QUAD_IS_LONG_LONG
#    ifdef __hpux
#        define strtoll __strtoll	/* secret handshake */
#    endif
#   if !defined(Strtol) && defined(HAS_STRTOLL)
#       define Strtol	strtoll
#   endif
/* is there atoq() anywhere? */
#endif
#if !defined(Strtol) && defined(HAS_STRTOL)
#   define Strtol	strtol
#endif
#ifndef Atol
/* It would be more fashionable to use Strtol() to define atol()
 * (as is done for Atoul(), see below) but for backward compatibility
 * we just assume atol(). */
#   if defined(USE_64_BIT_INT) && defined(IV_IS_QUAD) && QUADKIND == QUAD_IS_LONG_LONG && defined(HAS_ATOLL)
#       define Atol	atoll
#   else
#       define Atol	atol
#   endif
#endif

#if !defined(Strtoul) && defined(USE_64_BIT_INT) && defined(UV_IS_QUAD) && QUADKIND == QUAD_IS_LONG_LONG
#    ifdef __hpux
#        define strtoull __strtoull	/* secret handshake */
#    endif
#    if !defined(Strtoul) && defined(HAS_STRTOULL)
#       define Strtoul	strtoull
#    endif
#    if !defined(Strtoul) && defined(HAS_STRTOUQ)
#       define Strtoul	strtouq
#    endif
/* is there atouq() anywhere? */
#endif
#if !defined(Strtoul) && defined(HAS_STRTOUL)
#   define Strtoul	strtoul
#endif
#ifndef Atoul
#   define Atoul(s)	Strtoul(s, (char **)NULL, 10)
#endif

a2518 1
#undef printf
a2521 17
/* if these never got defined, they need defaults */
#ifndef PERL_SET_CONTEXT
#  define PERL_SET_CONTEXT(i)		PERL_SET_INTERP(i)
#endif

#ifndef PERL_GET_CONTEXT
#  define PERL_GET_CONTEXT		PERL_GET_INTERP
#endif

#ifndef PERL_GET_THX
#  define PERL_GET_THX			((void*)NULL)
#endif

#ifndef PERL_SET_THX
#  define PERL_SET_THX(t)		NOOP
#endif

a2526 28
 * Some operating systems are stingy with stack allocation,
 * so perl may have to guard against stack overflow.
 */
#ifndef PERL_STACK_OVERFLOW_CHECK
#define PERL_STACK_OVERFLOW_CHECK()  NOOP
#endif

/*
 * Some nonpreemptive operating systems find it convenient to
 * check for asynchronous conditions after each op execution.
 * Keep this check simple, or it may slow down execution
 * massively.
 */
#ifndef PERL_ASYNC_CHECK
#define PERL_ASYNC_CHECK()  NOOP
#endif

/*
 * On some operating systems, a memory allocation may succeed,
 * but put the process too close to the system's comfort limit.
 * In this case, PERL_ALLOC_CHECK frees the pointer and sets
 * it to NULL.
 */
#ifndef PERL_ALLOC_CHECK
#define PERL_ALLOC_CHECK(p)  NOOP
#endif

/*
d2547 3
a2549 3
	int		val;
	struct semid_ds	*buf;
	unsigned short	*array;
a2552 9
#	ifdef IRIX32_SEMUN_BROKEN_BY_GCC
            union gccbug_semun {
		int             val;
		struct semid_ds *buf;
		unsigned short  *array;
		char            __dummy[5];
	    };
#           define semun gccbug_semun
#	endif
d2556 1
a2556 5
#           ifdef EXTRA_F_IN_SEMUN_BUF
#               define Semctl(id, num, cmd, semun) semctl(id, num, cmd, semun.buff)
#           else
#               define Semctl(id, num, cmd, semun) semctl(id, num, cmd, semun.buf)
#           endif
d2559 3
a2561 24
#endif

#ifdef I_FCNTL
#  include <fcntl.h>
#endif

#ifdef I_SYS_FILE
#  include <sys/file.h>
#endif

#ifndef O_RDONLY
/* Assume UNIX defaults */
#    define O_RDONLY	0000
#    define O_WRONLY	0001
#    define O_RDWR	0002
#    define O_CREAT	0100
#endif

#ifndef O_BINARY
#  define O_BINARY 0
#endif

#ifndef O_TEXT
#  define O_TEXT 0
a2574 28
#ifdef I_SYS_STATFS
#   include <sys/statfs.h>      /* for some statfs() */
#endif
#ifdef I_SYS_VFS
#  ifdef __sgi
#    define sv IRIX_sv		/* kludge: IRIX has an sv of its own */
#  endif
#    include <sys/vfs.h>	/* for some statfs() */
#  ifdef __sgi
#    undef IRIX_sv
#  endif
#endif
#ifdef I_USTAT
#   include <ustat.h>           /* for ustat() */
#endif

#if !defined(PERL_MOUNT_NOSUID) && defined(MOUNT_NOSUID)
#    define PERL_MOUNT_NOSUID MOUNT_NOSUID
#endif
#if !defined(PERL_MOUNT_NOSUID) && defined(MNT_NOSUID)
#    define PERL_MOUNT_NOSUID MNT_NOSUID
#endif
#if !defined(PERL_MOUNT_NOSUID) && defined(MS_NOSUID)
#   define PERL_MOUNT_NOSUID MS_NOSUID
#endif
#if !defined(PERL_MOUNT_NOSUID) && defined(M_NOSUID)
#   define PERL_MOUNT_NOSUID M_NOSUID
#endif
a2576 28

/* and finally... */
#define PERL_PATCHLEVEL_H_IMPLICIT
#include "patchlevel.h"
#undef PERL_PATCHLEVEL_H_IMPLICIT

/* Mention
   
   NV_PRESERVES_UV

   HAS_ICONV
   I_ICONV

   HAS_MKSTEMP
   HAS_MKSTEMPS
   HAS_MKDTEMP

   HAS_GETCWD

   HAS_MMAP
   HAS_MPROTECT
   HAS_MSYNC
   HAS_MADVISE
   HAS_MUNMAP
   I_SYSMMAN
   Mmap_t

   so that Configure picks them up. */
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d3 1
a3 1
 *    Copyright (c) 1987-2001, Larry Wall
d167 2
a168 2
#define dTHXoa(a)		pTHXo = (CPerlObj*)a
#define dTHXo			pTHXo = PERL_GET_THX
d182 1
a182 2
#    define dTHR	dNOOP /* only backward compatibility */
#    define dTHXa(a)	pTHX = (struct perl_thread*)a
a188 1
#    define dTHXa(a)	pTHX = (PerlInterpreter*)a
d190 2
a191 1
#  define dTHX		pTHX = PERL_GET_THX
a244 1
#  define dTHXoa(x)	dTHXa(x)
d300 1
a300 1
#define WITH_THR(s) WITH_THX(s)
d489 1
a494 5
/* If this causes problems, set i_unistd=undef in the hint file.  */
#ifdef I_UNISTD
#   include <unistd.h>
#endif

d541 11
d712 4
a715 44

#if defined(WIN32) && (defined(PERL_OBJECT) || defined(PERL_IMPLICIT_SYS) || defined(PERL_CAPI))
#  define WIN32SCK_IS_STDSCK		/* don't pull in custom wsock layer */
#endif

#if defined(HAS_SOCKET) && !defined(VMS) /* VMS handles sockets via vmsish.h */
# include <sys/socket.h>
# if defined(USE_SOCKS) && defined(I_SOCKS)
#   if !defined(INCLUDE_PROTOTYPES)
#       define INCLUDE_PROTOTYPES /* for <socks.h> */
#       define PERL_SOCKS_NEED_PROTOTYPES
#   endif
#   ifdef USE_THREADS
#       define PERL_USE_THREADS /* store our value */
#       undef USE_THREADS
#   endif
#   include <socks.h>
#   ifdef USE_THREADS
#       undef USE_THREADS /* socks.h does this on its own */
#   endif
#   ifdef PERL_USE_THREADS
#       define USE_THREADS /* restore our value */
#       undef PERL_USE_THREADS
#   endif
#   ifdef PERL_SOCKS_NEED_PROTOTYPES /* keep cpp space clean */
#       undef INCLUDE_PROTOTYPES
#       undef PERL_SOCKS_NEED_PROTOTYPES
#   endif
#   ifdef USE_64_BIT_ALL
#       define SOCKS_64BIT_BUG /* until proven otherwise */
#   endif
# endif 
# ifdef I_NETDB
#  include <netdb.h>
# endif
# ifndef ENOTSOCK
#  ifdef I_NET_ERRNO
#   include <net/errno.h>
#  endif
# endif
#endif

#ifdef SETERRNO
# undef SETERRNO  /* SOCKS might have defined this */
a1064 5
#if PTRSIZE == LONGSIZE 
#  define PTR2ul(p)	(unsigned long)(p)
#else
#  define PTR2ul(p)	INT2PTR(unsigned long,p)	
#endif
a1066 3
#  if defined(HAS_LONG_DOUBLE) && LONG_DOUBLESIZE == DOUBLESIZE
#      define LONG_DOUBLE_EQUALS_DOUBLE
#  endif
d1147 6
a1152 9
#   ifdef LDBL_MANT_DIG
#       define NV_MANT_DIG LDBL_MANT_DIG
#   endif
#   ifdef LDBL_MAX
#       define NV_MAX LDBL_MAX
#       define NV_MIN LDBL_MIN
#   else
#       ifdef HUGE_VALL
#           define NV_MAX HUGE_VALL
d1154 2
a1155 3
#           ifdef HUGE_VAL
#               define NV_MAX ((NV)HUGE_VAL)
#           endif
a1156 2
#   endif
#   ifdef HAS_SQRTL
a1166 20
/* e.g. libsunmath doesn't have modfl and frexpl as of mid-March 2000 */
#   ifdef HAS_MODFL
#       define Perl_modf(x,y) modfl(x,y)
#   else
#       define Perl_modf(x,y) ((long double)modf((double)(x),(double*)(y)))
#   endif
#   ifdef HAS_FREXPL
#       define Perl_frexp(x,y) frexpl(x,y)
#   else
#       define Perl_frexp(x,y) ((long double)frexp((double)(x),y))
#   endif
#   ifdef HAS_ISNANL
#       define Perl_isnan(x) isnanl(x)
#   else
#       ifdef HAS_ISNAN
#           define Perl_isnan(x) isnan((double)(x))
#       else
#           define Perl_isnan(x) ((x)!=(x))
#       endif
#   endif
d1169 2
a1170 11
#   ifdef DBL_MANT_DIG
#       define NV_MANT_DIG DBL_MANT_DIG
#   endif
#   ifdef DBL_MAX
#       define NV_MAX DBL_MAX
#       define NV_MIN DBL_MIN
#   else
#       ifdef HUGE_VAL
#           define NV_MAX HUGE_VAL
#       endif
#   endif
a1179 7
#   define Perl_modf(x,y) modf(x,y)
#   define Perl_frexp(x,y) frexp(x,y)
#   ifdef HAS_ISNAN
#       define Perl_isnan(x) isnan(x)
#   else
#       define Perl_isnan(x) ((x)!=(x))
#   endif
d1184 1
a1184 1
#       define Perl_atof(s) (NV)strtold(s, (char**)NULL)
d1187 1
a1187 5
#       define Perl_atof (NV)atolf
#   endif
#   if !defined(Perl_atof) && defined(PERL_SCNfldbl)
#       define Perl_atof PERL_SCNfldbl
#       define Perl_atof2(s,f) sscanf((s), "%"PERL_SCNfldbl, &(f))
a1192 3
#if !defined(Perl_atof2)
#   define Perl_atof2(s,f) ((f) = (NV)Perl_atof(s))
#endif
d1365 3
d1369 7
a1375 1
#    define PERL_UQUAD_MIN	((UV)0)
d1377 5
d1383 1
a1386 12
struct perl_mstats {
    UV *nfree;
    UV *ntotal;
    IV topbucket, topbucket_ev, topbucket_odd, totfree, total, total_chain;
    IV total_sbrk, sbrks, sbrk_good, sbrk_slack, start_slack, sbrked_remains;
    IV minbucket;
    /* Level 1 info */
    UV *bucket_mem_size;
    UV *bucket_available_size;
    UV nbuckets;
};

d1402 1
a1402 6
#ifdef UTS
#   define STRUCT_SV perl_sv /* Amdahl's <ksync.h> has struct sv */
#else
#   define STRUCT_SV sv
#endif
typedef struct STRUCT_SV SV;
a1566 3
#	      ifndef NO_ENVIRON_ARRAY
#               define NO_ENVIRON_ARRAY
#             endif
d1575 1
a1575 12
#endif

#ifndef NO_ENVIRON_ARRAY
#  define USE_ENVIRON_ARRAY
#endif

#ifdef JPL
    /* E.g. JPL needs to operate on a copy of the real environment.
     * JDK 1.2 and 1.3 seem to get upset if the original environment
     * is diddled with. */
#   define NEED_ENVIRON_DUP_FOR_MODIFY
#endif
a1764 16
#ifndef UVf
#  ifdef CHECK_FORMAT
#    define UVf UVuf
#  else
#    define UVf "Vu"
#  endif 
#endif

#ifndef VDf
#  ifdef CHECK_FORMAT
#    define VDf "p"
#  else
#    define VDf "vd"
#  endif 
#endif

d1767 1
a1767 1
   below to be rejected by the compiler.  Sigh.
a1986 1
				 && GvIOp(PL_stderrgv)          \
a2006 2
     /* Temporarily turn off memory debugging in case the a
      * does memory allocation, either directly or indirectly. */
d2009 1
a2009 1
        if (PERL_GET_INTERP) { dTHX; if (PL_debug & 128) {PL_debug&=~128; a; PL_debug|=128;} } \
a2024 1
#define DEBUG_T(a) if (PL_debug & (1<<17))	a
a2044 1
#define DEBUG_T(a)
d2115 1
a2115 3
#    if !defined(HAS_LSEEK_PROTO) && !defined(EPOC) && !defined(__hpux)
#      ifdef _FILE_OFFSET_BITS
#        if _FILE_OFFSET_BITS == 64
a2116 2
#        endif
#      endif
d2202 1
a2202 1
#    if defined(__APPLE__) && defined(PERL_CORE)
d2209 1
a2209 1
#  ifdef USE_ENVIRON_ARRAY
d2213 1
a2213 1
        defined(__DGUX) 
d2578 4
d2827 1
a2827 2
EXT MGVTBL PL_vtbl_regdatum = {MEMBER_TO_FPTR(Perl_magic_regdatum_get),
			       MEMBER_TO_FPTR(Perl_magic_regdatum_set), 0, 0, 0};
d3055 4
a3058 1
	set_numeric_standard();
d3061 4
a3064 1
	set_numeric_local();
d3066 1
a3066 1
#define IS_NUMERIC_RADIX(s)	\
d3068 1
a3068 15
	  PL_numeric_radix_sv && memEQ(s, SvPVX(PL_numeric_radix_sv), SvCUR(PL_numeric_radix_sv)))

#define STORE_NUMERIC_LOCAL_SET_STANDARD() \
	bool was_local = (PL_hints & HINT_LOCALE) && PL_numeric_local; \
	if (was_local) SET_NUMERIC_STANDARD();

#define STORE_NUMERIC_STANDARD_SET_LOCAL() \
	bool was_standard = (PL_hints & HINT_LOCALE) && PL_numeric_standard; \
	if (was_standard) SET_NUMERIC_LOCAL();

#define RESTORE_NUMERIC_LOCAL() \
	if (was_local) SET_NUMERIC_LOCAL();

#define RESTORE_NUMERIC_STANDARD() \
	if (was_standard) SET_NUMERIC_STANDARD();
d3070 2
a3078 2
#define STORE_NUMERIC_LOCAL_SET_STANDARD()	/**/
#define STORE_NUMERIC_STANDARD_SET_LOCAL()	/**/
a3298 8
#ifdef I_LIBUTIL
#   include <libutil.h>		/* setproctitle() in some FreeBSDs */
#endif

#ifndef EXEC_ARGV_CAST
#define EXEC_ARGV_CAST(x) x
#endif

a3323 4

   NVef
   NVff
   NVgf
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d3 1
a3 1
 *    Copyright (c) 1987-2002, Larry Wall
a8 1

d14 1
a14 1
 * This file is being used for x2p stuff.
d16 1
a16 1
 * Decouple x2p stuff from some of perls more extreme eccentricities.
a22 7
#if defined(DGUX)
#include <sys/fcntl.h>
#endif

#ifdef VOIDUSED
#   undef VOIDUSED
#endif 
d24 1
a24 6

#ifdef PERL_MICRO
#   include "uconfig.h"
#else
#   include "config.h"
#endif
d33 2
a34 2
#if defined(USE_ITHREADS) && defined(USE_5005THREADS)
#  include "error: USE_ITHREADS and USE_5005THREADS are incompatible"
a39 13
/* Note that from here --> to <-- the same logic is
 * repeated in makedef.pl, so be certain to update
 * both places when editing. */

#ifdef PERL_IMPLICIT_SYS
/* PERL_IMPLICIT_SYS implies PerlMemShared != PerlMem
   so use slab allocator to avoid lots of MUTEX overhead
 */
#  ifndef PL_OP_SLAB_ALLOC
#    define PL_OP_SLAB_ALLOC
#  endif
#endif

d41 1
a41 1
#  if !defined(MULTIPLICITY)
d46 1
a46 1
#ifdef USE_5005THREADS
d58 11
a68 4
/* undef WIN32 when building on Cygwin (for libwin32) - gph */
#ifdef __CYGWIN__
#   undef WIN32
#   undef _WIN32
d71 7
a77 4
/* Use the reentrant APIs like localtime_r and getpwent_r */
/* Win32 has naturally threadsafe libraries, no need to use any _r variants. */
#if defined(USE_ITHREADS) && !defined(USE_REENTRANT_API) && !defined(NETWARE) && !defined(WIN32) && !defined(__APPLE__)
#   define USE_REENTRANT_API
d80 96
a175 1
/* <--- here ends the logic shared by perl.h and makedef.pl */
d178 1
a178 1
#  ifdef USE_5005THREADS
d180 1
a180 1
#    define pTHX	register struct perl_thread *thr PERL_UNUSED_DECL
d188 1
a188 1
#    define pTHX	register PerlInterpreter *my_perl PERL_UNUSED_DECL
d211 2
a223 16
#ifdef HASATTRIBUTE
#  if defined(__GNUC__) && defined(__cplusplus)
#    define PERL_UNUSED_DECL
#  else
#    define PERL_UNUSED_DECL __attribute__((unused))
#  endif
#else
#  define PERL_UNUSED_DECL
#endif

/* gcc -Wall:
 * for silencing unused variables that are actually used most of the time,
 * but we cannot quite get rid of, such `ax' in PPCODE+noargs xsubs
 */
#define PERL_UNUSED_VAR(var) if (0) var = var

d225 1
a225 1
#define dNOOP extern int Perl___notused PERL_UNUSED_DECL
d240 1
a240 2
/* these are only defined for compatibility; should not be used internally */
#if !defined(pTHXo) && !defined(PERL_CORE)
a256 9
/* Under PERL_IMPLICIT_SYS (used in Windows for fork emulation)
 * PerlIO_foo() expands to PL_StdIO->pFOO(PL_StdIO, ...).
 * dTHXs is therefore needed for all functions using PerlIO_foo(). */
#ifdef PERL_IMPLICIT_SYS
#  define dTHXs		dTHX
#else
#  define dTHXs		dNOOP
#endif

d265 2
a266 2
#  define START_EXTERN_C
#  define END_EXTERN_C
d338 1
a338 1
#if defined(MSDOS) || defined(atarist) || defined(WIN32) || defined(NETWARE)
d342 1
a342 1
#if defined(__STDC__) || defined(vax11c) || defined(_AIX) || defined(__stdc__) || defined(__cplusplus) || defined( EPOC) || defined(NETWARE)
d346 1
a346 1
#if defined(__cplusplus) || defined(WIN32) || defined(__sgi) || defined(OS2) || defined(__DGUX) || defined( EPOC) || defined(__QNX__) || defined(NETWARE)
d352 1
a352 1
#	define VOL		/* to temporarily suppress warnings */
d366 1
a366 1
/* XXX All process group stuff is handled in pp_sys.c.  Should these
d406 1
a406 1
/* These are not exact synonyms, since setpgrp() and getpgrp() may
d419 1
a419 1
#if (defined(USE_5005THREADS) || defined(USE_ITHREADS)) \
a463 4
#ifdef PERL_MICRO
#   define NO_LOCALE
#endif

a500 8
#if defined(HAS_SYSCALL) && !defined(HAS_SYSCALL_PROTO) && !defined(PERL_MICRO)
int syscall(int, ...);
#endif

#if defined(HAS_USLEEP) && !defined(HAS_USLEEP_PROTO) && !defined(PERL_MICRO)
int usleep(unsigned int);
#endif

d505 1
a505 4
/* Cannot include embed.h here on Win32 as win32.h has not 
   yet been included and defines some config variables e.g. HAVE_INTERP_INTERN
 */
#if !defined(PERL_FOR_X2P) && !(defined(WIN32)||defined(VMS))
a537 1
START_EXTERN_C
a543 1
END_EXTERN_C
a589 1
#  undef  memset
d708 1
a708 1
#if defined(WIN32) && defined(PERL_IMPLICIT_SYS)
d712 1
a712 6
/* In Tru64 use the 4.4BSD struct msghdr, not the 4.3 one */
#if defined(__osf__) && defined(__alpha) && !defined(_SOCKADDR_LEN)
#  define _SOCKADDR_LEN
#endif

#if defined(HAS_SOCKET) && !defined(VMS) && !defined(WIN32) /* VMS/WIN32 handle sockets via vmsish.h/win32.h */
d719 1
a719 1
#   ifdef USE_5005THREADS
d721 1
a721 1
#       undef USE_5005THREADS
d724 2
a725 2
#   ifdef USE_5005THREADS
#       undef USE_5005THREADS /* socks.h does this on its own */
d728 1
a728 1
#       define USE_5005THREADS /* restore our value */
d735 4
a738 1
# endif
a739 3
#  ifdef NETWARE
#   include<stdio.h>
#  endif
a748 6
/* sockatmark() is so new (2001) that many places might have it hidden
 * behind some -D_BLAH_BLAH_SOURCE guard. */
#if defined(HAS_SOCKATMARK) && !defined(HAS_SOCKATMARK_PROTO)
int sockatmark(int);
#endif

d763 1
a763 1
#ifdef USE_5005THREADS
d771 1
a771 1
#endif /* USE_5005THREADS */
a819 6
#ifndef HAS_SOCKETPAIR
#   ifdef HAS_SOCKET
#	define socketpair Perl_my_socketpair
#   endif
#endif

a848 6
#ifdef PERL_MICRO
#   ifndef DIR
#      define DIR void
#   endif
#endif

d862 1
a862 1
#if defined(I_SYSMODE) && !defined(PERL_MICRO)
d980 1
a980 1
#endif
d984 1
a984 1
#endif
d988 1
a988 5
#endif

/* BeOS 5.0 seems to define S_IREAD and S_IWRITE in <posix/fcntl.h>
 * which would get included through <sys/file.h >, but that is 3000
 * lines in the future.  --jhi */
d990 1
a990 1
#if !defined(S_IREAD) && !defined(__BEOS__)
d994 1
a994 1
#if !defined(S_IWRITE) && !defined(__BEOS__)
a1013 11
#ifdef	SPRINTF_E_BUG
#  define sprintf UTS_sprintf_wrap
#endif

/* Configure gets this right but the UTS compiler gets it wrong.
   -- Hal Morris <hom00@@utsglobal.com> */
#ifdef UTS
#  undef  UVTYPE
#  define UVTYPE unsigned
#endif

a1071 5
#if defined(uts) || defined(UTS)
#	undef UV_MAX
#	define UV_MAX (4294967295u)
#endif

d1075 1
a1075 5
#ifndef NO_PERL_PRESERVE_IVUV
#define PERL_PRESERVE_IVUV	/* We like our integers to stay integers. */
#endif

/*
d1089 1
a1089 1
#  if PTRSIZE == LONGSIZE
d1100 1
a1100 1
#if PTRSIZE == LONGSIZE
d1105 1
a1105 1

a1192 15
#   ifdef LDBL_MIN
#       define NV_MIN LDBL_MIN
#   endif
#   ifdef LDBL_MAX
#       define NV_MAX LDBL_MAX
#   endif
#   ifdef LDBL_MIN_10_EXP
#       define NV_MIN_10_EXP LDBL_MIN_10_EXP
#   endif
#   ifdef LDBL_MAX_10_EXP
#       define NV_MAX_10_EXP LDBL_MAX_10_EXP
#   endif
#   ifdef LDBL_EPSILON
#       define NV_EPSILON LDBL_EPSILON
#   endif
d1227 7
a1233 8
#   ifndef Perl_isnan
#       ifdef HAS_ISNANL
#           define Perl_isnan(x) isnanl(x)
#       endif
#   endif
#   ifndef Perl_isinf
#       ifdef HAS_FINITEL
#           define Perl_isinf(x) !(finitel(x)||Perl_isnan(x))
a1240 15
#   ifdef DBL_MIN
#       define NV_MIN DBL_MIN
#   endif
#   ifdef DBL_MAX
#       define NV_MAX DBL_MAX
#   endif
#   ifdef DBL_MIN_10_EXP
#       define NV_MIN_10_EXP DBL_MIN_10_EXP
#   endif
#   ifdef DBL_MAX_10_EXP
#       define NV_MAX_10_EXP DBL_MAX_10_EXP
#   endif
#   ifdef DBL_EPSILON
#       define NV_EPSILON DBL_EPSILON
#   endif
a1259 93
#endif

/* rumor has it that Win32 has _fpclass() */

#if !defined(Perl_fp_class) && (defined(HAS_FPCLASS)||defined(HAS_FPCLASSL))
#    ifdef I_IEEFP
#        include <ieeefp.h>
#    endif
#    ifdef I_FP
#        include <fp.h>
#    endif
#    if defined(USE_LONG_DOUBLE) && defined(HAS_FPCLASSL)
#        define Perl_fp_class()		fpclassl(x)
#    else
#        define Perl_fp_class()		fpclass(x)
#    endif
#    define Perl_fp_class_snan(x)	(Perl_fp_class(x)==FP_CLASS_SNAN)
#    define Perl_fp_class_qnan(x)	(Perl_fp_class(x)==FP_CLASS_QNAN)
#    define Perl_fp_class_nan(x)	(Perl_fp_class(x)==FP_CLASS_SNAN||Perl_fp_class(x)==FP_CLASS_QNAN)
#    define Perl_fp_class_ninf(x)	(Perl_fp_class(x)==FP_CLASS_NINF)
#    define Perl_fp_class_pinf(x)	(Perl_fp_class(x)==FP_CLASS_PINF)
#    define Perl_fp_class_inf(x)	(Perl_fp_class(x)==FP_CLASS_NINF||Perl_fp_class(x)==FP_CLASS_PINF)
#    define Perl_fp_class_nnorm(x)	(Perl_fp_class(x)==FP_CLASS_NNORM)
#    define Perl_fp_class_pnorm(x)	(Perl_fp_class(x)==FP_CLASS_PNORM)
#    define Perl_fp_class_norm(x)	(Perl_fp_class(x)==FP_CLASS_NNORM||Perl_fp_class(x)==FP_CLASS_PNORM)
#    define Perl_fp_class_ndenorm(x)	(Perl_fp_class(x)==FP_CLASS_NDENORM)
#    define Perl_fp_class_pdenorm(x)	(Perl_fp_class(x)==FP_CLASS_PDENORM)
#    define Perl_fp_class_denorm(x)	(Perl_fp_class(x)==FP_CLASS_NDENORM||Perl_fp_class(x)==FP_CLASS_PDENORM)
#    define Perl_fp_class_nzero(x)	(Perl_fp_class(x)==FP_CLASS_NZERO)
#    define Perl_fp_class_pzero(x)	(Perl_fp_class(x)==FP_CLASS_PZERO)
#    define Perl_fp_class_zero(x)	(Perl_fp_class(x)==FP_CLASS_NZERO||Perl_fp_class(x)==FP_CLASS_PZERO)
#endif

#if !defined(Perl_fp_class) && defined(HAS_FP_CLASS) && !defined(PERL_MICRO)
#    include <math.h>
#    if !defined(FP_SNAN) && defined(I_FP_CLASS)
#        include <fp_class.h>
#    endif
#    define Perl_fp_class(x)		fp_class(x)
#    define Perl_fp_class_snan(x)	(fp_class(x)==FP_SNAN)
#    define Perl_fp_class_qnan(x)	(fp_class(x)==FP_QNAN)
#    define Perl_fp_class_nan(x)	(fp_class(x)==FP_SNAN||fp_class(x)==FP_QNAN)
#    define Perl_fp_class_ninf(x)	(fp_class(x)==FP_NEG_INF)
#    define Perl_fp_class_pinf(x)	(fp_class(x)==FP_POS_INF)
#    define Perl_fp_class_inf(x)	(fp_class(x)==FP_NEG_INF||fp_class(x)==FP_POS_INF)
#    define Perl_fp_class_nnorm(x)	(fp_class(x)==FP_NEG_NORM)
#    define Perl_fp_class_pnorm(x)	(fp_class(x)==FP_POS_NORM)
#    define Perl_fp_class_norm(x)	(fp_class(x)==FP_NEG_NORM||fp_class(x)==FP_POS_NORM)
#    define Perl_fp_class_ndenorm(x)	(fp_class(x)==FP_NEG_DENORM)
#    define Perl_fp_class_pdenorm(x)	(fp_class(x)==FP_POS_DENORM)
#    define Perl_fp_class_denorm(x)	(fp_class(x)==FP_NEG_DENORM||fp_class(x)==FP_POS_DENORM)
#    define Perl_fp_class_nzero(x)	(fp_class(x)==FP_NEG_ZERO)
#    define Perl_fp_class_pzero(x)	(fp_class(x)==FP_POS_ZERO)
#    define Perl_fp_class_zero(x)	(fp_class(x)==FP_NEG_ZERO||fp_class(x)==FP_POS_ZERO)
#endif

#if !defined(Perl_fp_class) && defined(HAS_FPCLASSIFY)
#    include <math.h>
#    define Perl_fp_class(x)		fpclassify(x)
#    define Perl_fp_class_nan(x)	(fp_classify(x)==FP_SNAN||fp_classify(x)==FP_QNAN)
#    define Perl_fp_class_inf(x)	(fp_classify(x)==FP_INFINITE)
#    define Perl_fp_class_norm(x)	(fp_classify(x)==FP_NORMAL)
#    define Perl_fp_class_denorm(x)	(fp_classify(x)==FP_SUBNORMAL)
#    define Perl_fp_class_zero(x)	(fp_classify(x)==FP_ZERO)
#endif

#if !defined(Perl_fp_class) && defined(HAS_CLASS)
#    include <math.h>
#    ifndef _cplusplus
#        define Perl_fp_class(x)	class(x)
#    else
#        define Perl_fp_class(x)	_class(x)
#    endif
#    define Perl_fp_class_snan(x)	(Perl_fp_class(x)==FP_NANS)
#    define Perl_fp_class_qnan(x)	(Perl_fp_class(x)==FP_NANQ)
#    define Perl_fp_class_nan(x)	(Perl_fp_class(x)==FP_SNAN||Perl_fp_class(x)==FP_QNAN)
#    define Perl_fp_class_ninf(x)	(Perl_fp_class(x)==FP_MINUS_INF)
#    define Perl_fp_class_pinf(x)	(Perl_fp_class(x)==FP_PLUS_INF)
#    define Perl_fp_class_inf(x)	(Perl_fp_class(x)==FP_MINUS_INF||Perl_fp_class(x)==FP_PLUS_INF)
#    define Perl_fp_class_nnorm(x)	(Perl_fp_class(x)==FP_MINUS_NORM)
#    define Perl_fp_class_pnorm(x)	(Perl_fp_class(x)==FP_PLUS_NORM)
#    define Perl_fp_class_norm(x)	(Perl_fp_class(x)==FP_MINUS_NORM||Perl_fp_class(x)==FP_PLUS_NORM)
#    define Perl_fp_class_ndenorm(x)	(Perl_fp_class(x)==FP_MINUS_DENORM)
#    define Perl_fp_class_pdenorm(x)	(Perl_fp_class(x)==FP_PLUS_DENORM)
#    define Perl_fp_class_denorm(x)	(Perl_fp_class(x)==FP_MINUS_DENORM||Perl_fp_class(x)==FP_PLUS_DENORM)
#    define Perl_fp_class_nzero(x)	(Perl_fp_class(x)==FP_MINUS_ZERO)
#    define Perl_fp_class_pzero(x)	(Perl_fp_class(x)==FP_PLUS_ZERO)
#    define Perl_fp_class_zero(x)	(Perl_fp_class(x)==FP_MINUS_ZERO||Perl_fp_class(x)==FP_PLUS_ZERO)
#endif

/* rumor has it that Win32 has _isnan() */

#ifndef Perl_isnan
d1261 1
a1261 21
#       define Perl_isnan(x) isnan((NV)x)
#   else
#       ifdef Perl_fp_class_nan
#           define Perl_isnan(x) Perl_fp_class_nan(x)
#       else
#           ifdef HAS_UNORDERED
#               define Perl_isnan(x) unordered((x), 0.0)
#           else
#               define Perl_isnan(x) ((x)!=(x))
#           endif
#       endif
#   endif
#endif

#ifdef UNDER_CE
int isnan(double d);
#endif

#ifndef Perl_isinf
#   ifdef HAS_ISINF
#       define Perl_isinf(x) isinf((NV)x)
d1263 1
a1263 5
#       ifdef Perl_fp_class_inf
#           define Perl_isinf(x) Perl_fp_class_inf(x)
#       else
#           define Perl_isinf(x) ((x)==NV_INF)
#       endif
d1267 3
a1269 13
#ifndef Perl_isfinite
#   ifdef HAS_FINITE
#       define Perl_isfinite(x) finite((NV)x)
#   else
#       ifdef HAS_ISFINITE
#           define Perl_isfinite(x) isfinite(x)
#       else
#           ifdef Perl_fp_class_finite
#               define Perl_isfinite(x) Perl_fp_class_finite(x)
#           else
#               define Perl_isfinite(x) !(Perl_is_inf(x)||Perl_is_nan(x))
#           endif
#       endif
d1271 2
a1272 12
#endif

/* The default is to use Perl's own atof() implementation (in numeric.c).
 * Usually that is the one to use but for some platforms (e.g. UNICOS)
 * it is however best to use the native implementation of atof.
 * You can experiment with using your native one by -DUSE_PERL_ATOF=0.
 * Some good tests to try out with either setting are t/base/num.t,
 * t/op/numconvert.t, and t/op/pack.t. */

#ifndef USE_PERL_ATOF
#   ifndef _UNICOS
#       define USE_PERL_ATOF
d1274 3
a1276 3
#else
#   if USE_PERL_ATOF == 0
#       undef USE_PERL_ATOF
d1279 5
a1283 7

#ifdef USE_PERL_ATOF
#   define Perl_atof(s) Perl_my_atof(s)
#   define Perl_atof2(s, n) Perl_my_atof2(aTHX_ (s), &(n))
#else
#   define Perl_atof(s) (NV)atof(s)
#   define Perl_atof2(s, n) ((n) = atof(s))
d1286 1
a1286 1
/* Previously these definitions used hardcoded figures.
d1337 1
a1337 1

a1474 1
struct RExC_state_t;
d1491 2
a1492 5

/* Amdahl's <ksync.h> has struct sv */
/* SGI's <sys/sema.h> has struct sv */
#if defined(UTS) || defined(__sgi)
#   define STRUCT_SV perl_sv
a1525 2
typedef struct clone_params CLONE_PARAMS;

d1543 1
a1543 1
#   endif
d1629 1
a1629 1
#if defined(OS2) || defined(MACOS_TRADITIONAL)
d1634 1
a1634 2
#   include "vmesa/vmesaish.h"
#   define ISHISH "vmesa"
d1638 7
a1644 9
#   if defined(OS2)
#       include "os2ish.h"
#   else
#       include "dosish.h"
#   endif
#   define ISHISH "dos"
#endif

#if defined(VMS)
d1646 3
a1648 17
#   include "embed.h"
#   define ISHISH "vms"
#endif

#if defined(PLAN9)
#   include "./plan9/plan9ish.h"
#   define ISHISH "plan9"
#endif

#if defined(MPE)
#  include "mpeix/mpeixish.h"
#  define ISHISH "mpeix"
#endif

#if defined(__VOS__)
#   ifdef __GNUC__
#     include "./vos/vosish.h"
d1650 20
a1669 1
#     include "vos/vosish.h"
d1671 1
a1671 24
#   define ISHISH "vos"
#endif

#if defined(EPOC)
#   include "epocish.h"
#   define ISHISH "epoc"
#endif

#if defined(MACOS_TRADITIONAL)
#   include "macos/macish.h"
#   ifndef NO_ENVIRON_ARRAY
#       define NO_ENVIRON_ARRAY
#   endif
#   define ISHISH "macos classic"
#endif

#if defined(__BEOS__)
#   include "beos/beosish.h"
#   define ISHISH "beos"
#endif

#ifndef ISHISH
#   include "unixish.h"
#   define ISHISH "unix"
d1678 5
a1682 16
/*
 * initialise to avoid floating-point exceptions from overflow, etc
 */
#ifndef PERL_FPU_INIT
#  ifdef HAS_FPSETMASK
#    if HAS_FLOATINGPOINT_H
#      include <floatingpoint.h>
#    endif
#    define PERL_FPU_INIT fpsetmask(0);
#  else
#    if defined(SIGFPE) && defined(SIG_IGN)
#      define PERL_FPU_INIT signal(SIGFPE, SIG_IGN);
#    else
#      define PERL_FPU_INIT
#    endif
#  endif
a1688 4
#ifndef PERL_WRITE_MSG_TO_CONSOLE
#  define PERL_WRITE_MSG_TO_CONSOLE(io, msg, len) PerlIO_write(io, msg, len)
#endif

d1711 2
a1712 2
/*
 * USE_5005THREADS needs to be after unixish.h as <pthread.h> includes
d1718 2
a1719 2
#if defined(USE_5005THREADS) || defined(USE_ITHREADS)
#  if defined(USE_5005THREADS)
a1723 3
#  ifdef NETWARE
#   include <nw5thread.h>
#  else
d1754 1
a1754 2
#endif	/* NETWARE */
#endif /* USE_5005THREADS || USE_ITHREADS */
d1756 1
a1756 1
#if defined(WIN32)
a1759 4
#ifdef NETWARE
#  include "netware.h"
#endif

a1810 1
#define PERL_EXIT_DESTRUCT_END  0x02  /* Run END in perl_destruct */
d1823 1
a1823 3
 * performance issue, so we allow people to disable it.  Also, if
 * we are using stdio, there are broken implementations of fflush(NULL)
 * out there, Solaris being the most prominent.
d1826 1
a1826 1
# if defined(USE_PERLIO) || defined(FFLUSH_NULL) || defined(USE_SFIO)
d1851 1
a1851 1
#  ifdef USE_5005THREADS
d1856 4
d1870 1
a1870 1
#  endif
d1878 1
a1878 1
#  endif
d1886 1
a1886 9
#  endif
#endif

#ifndef Nullformat
#  ifdef CHECK_FORMAT
#    define Nullformat "%s",""
#  else
#    define Nullformat Nullch
#  endif
d1930 1
a1930 1
    void	(*any_dxptr) (pTHX_ void*);
d1934 1
a1934 1
#ifdef USE_5005THREADS
d1938 1
a1938 1
#endif /* USE_5005THREADS */
d1940 1
a1940 1
typedef I32 (*filter_t) (pTHX_ int, SV *, int);
d1946 1
a1946 17
#if defined(_AIX) && !defined(_AIX43)
#if defined(USE_REENTRANT) || defined(_REENTRANT) || defined(_THREAD_SAFE)
/* We cannot include <crypt.h> to get the struct crypt_data
 * because of setkey prototype problems when threading */
typedef        struct crypt_data {     /* straight from /usr/include/crypt.h */
    /* From OSF, Not needed in AIX
       char C[28], D[28];
    */
    char E[48];
    char KS[16][48];
    char block[66];
    char iobuf[16];
} CRYPTD;
#endif /* threading */
#endif /* AIX */

#if !defined(OS2) && !defined(MACOS_TRADITIONAL)
a2062 5
#ifndef htovs
short htovs(short n);
short vtohs(short n);
long htovl(long n);
long vtohl(long n);
d2064 9
d2075 5
a2079 24
/* *MAX Plus 1. A floating point value.
   Hopefully expressed in a way that dodgy floating point can't mess up.
   >> 2 rather than 1, so that value is safely less than I32_MAX after 1
   is added to it
   May find that some broken compiler will want the value cast to I32.
   [after the shift, as signed >> may not be as secure as unsigned >>]
*/
#define I32_MAX_P1 (2.0 * (1 + (((U32)I32_MAX) >> 1)))
#define U32_MAX_P1 (4.0 * (1 + ((U32_MAX) >> 2)))
/* For compilers that can't correctly cast NVs over 0x7FFFFFFF (or
   0x7FFFFFFFFFFFFFFF) to an unsigned integer. In the future, sizeof(UV)
   may be greater than sizeof(IV), so don't assume that half max UV is max IV.
*/
#define U32_MAX_P1_HALF (2.0 * (1 + ((U32_MAX) >> 2)))

#define UV_MAX_P1 (4.0 * (1 + ((UV_MAX) >> 2)))
#define IV_MAX_P1 (2.0 * (1 + (((UV)IV_MAX) >> 1)))
#define UV_MAX_P1_HALF (2.0 * (1 + ((UV_MAX) >> 2)))

/* This may look like unnecessary jumping through hoops, but converting
   out of range floating point values to integers *is* undefined behaviour,
   and it is starting to bite.
*/
#ifndef CAST_INLINE
a2080 1
#define U_32(what) (cast_ulong((NV)(what)))
d2083 1
a2083 18
#else
#define I_32(n) ((n) < I32_MAX_P1 ? ((n) < I32_MIN ? I32_MIN : (I32) (n)) \
                  : ((n) < U32_MAX_P1 ? (I32)(U32) (n) \
                     : ((n) > 0 ? (I32) U32_MAX : 0 /* NaN */)))
#define U_32(n) ((n) < 0.0 ? ((n) < I32_MIN ? (UV) I32_MIN : (U32)(I32) (n)) \
                  : ((n) < U32_MAX_P1 ? (U32) (n) \
                     : ((n) > 0 ? U32_MAX : 0 /* NaN */)))
#define I_V(n) ((n) < IV_MAX_P1 ? ((n) < IV_MIN ? IV_MIN : (IV) (n)) \
                  : ((n) < UV_MAX_P1 ? (IV)(UV) (n) \
                     : ((n) > 0 ? (IV)UV_MAX : 0 /* NaN */)))
#define U_V(n) ((n) < 0.0 ? ((n) < IV_MIN ? (UV) IV_MIN : (UV)(IV) (n)) \
                  : ((n) < UV_MAX_P1 ? (UV) (n) \
                     : ((n) > 0 ? UV_MAX : 0 /* NaN */)))
#endif

#define U_S(what) ((U16)U_32(what))
#define U_I(what) ((unsigned int)U_32(what))
#define U_L(what) U_32(what)
a2098 1
#ifndef UNDER_CE
a2103 1
#endif
a2116 48

#define DEBUG_p_FLAG		0x00000001 /*      1 */
#define DEBUG_s_FLAG		0x00000002 /*      2 */
#define DEBUG_l_FLAG		0x00000004 /*      4 */
#define DEBUG_t_FLAG		0x00000008 /*      8 */
#define DEBUG_o_FLAG		0x00000010 /*     16 */
#define DEBUG_c_FLAG		0x00000020 /*     32 */
#define DEBUG_P_FLAG		0x00000040 /*     64 */
#define DEBUG_m_FLAG		0x00000080 /*    128 */
#define DEBUG_f_FLAG		0x00000100 /*    256 */
#define DEBUG_r_FLAG		0x00000200 /*    512 */
#define DEBUG_x_FLAG		0x00000400 /*   1024 */
#define DEBUG_u_FLAG		0x00000800 /*   2048 */
#define DEBUG_L_FLAG		0x00001000 /*   4096 */
#define DEBUG_H_FLAG		0x00002000 /*   8192 */
#define DEBUG_X_FLAG		0x00004000 /*  16384 */
#define DEBUG_D_FLAG		0x00008000 /*  32768 */
#define DEBUG_S_FLAG		0x00010000 /*  65536 */
#define DEBUG_T_FLAG		0x00020000 /* 131072 */
#define DEBUG_R_FLAG		0x00040000 /* 262144 */
#define DEBUG_J_FLAG		0x00080000 /* 524288 */
#define DEBUG_MASK		0x000FFFFF /* mask of all the standard flags */

#define DEBUG_DB_RECURSE_FLAG	0x40000000
#define DEBUG_TOP_FLAG		0x80000000 /* XXX what's this for ??? Signal
					      that something was done? */

#  define DEBUG_p_TEST_ (PL_debug & DEBUG_p_FLAG)
#  define DEBUG_s_TEST_ (PL_debug & DEBUG_s_FLAG)
#  define DEBUG_l_TEST_ (PL_debug & DEBUG_l_FLAG)
#  define DEBUG_t_TEST_ (PL_debug & DEBUG_t_FLAG)
#  define DEBUG_o_TEST_ (PL_debug & DEBUG_o_FLAG)
#  define DEBUG_c_TEST_ (PL_debug & DEBUG_c_FLAG)
#  define DEBUG_P_TEST_ (PL_debug & DEBUG_P_FLAG)
#  define DEBUG_m_TEST_ (PL_debug & DEBUG_m_FLAG)
#  define DEBUG_f_TEST_ (PL_debug & DEBUG_f_FLAG)
#  define DEBUG_r_TEST_ (PL_debug & DEBUG_r_FLAG)
#  define DEBUG_x_TEST_ (PL_debug & DEBUG_x_FLAG)
#  define DEBUG_u_TEST_ (PL_debug & DEBUG_u_FLAG)
#  define DEBUG_L_TEST_ (PL_debug & DEBUG_L_FLAG)
#  define DEBUG_H_TEST_ (PL_debug & DEBUG_H_FLAG)
#  define DEBUG_X_TEST_ (PL_debug & DEBUG_X_FLAG)
#  define DEBUG_D_TEST_ (PL_debug & DEBUG_D_FLAG)
#  define DEBUG_S_TEST_ (PL_debug & DEBUG_S_FLAG)
#  define DEBUG_T_TEST_ (PL_debug & DEBUG_T_FLAG)
#  define DEBUG_R_TEST_ (PL_debug & DEBUG_R_FLAG)
#  define DEBUG_J_TEST_ (PL_debug & DEBUG_J_FLAG)

d2118 14
a2131 35

#  undef  YYDEBUG
#  define YYDEBUG 1

#  define DEBUG_p_TEST DEBUG_p_TEST_
#  define DEBUG_s_TEST DEBUG_s_TEST_
#  define DEBUG_l_TEST DEBUG_l_TEST_
#  define DEBUG_t_TEST DEBUG_t_TEST_
#  define DEBUG_o_TEST DEBUG_o_TEST_
#  define DEBUG_c_TEST DEBUG_c_TEST_
#  define DEBUG_P_TEST DEBUG_P_TEST_
#  define DEBUG_m_TEST DEBUG_m_TEST_
#  define DEBUG_f_TEST DEBUG_f_TEST_
#  define DEBUG_r_TEST DEBUG_r_TEST_
#  define DEBUG_x_TEST DEBUG_x_TEST_
#  define DEBUG_u_TEST DEBUG_u_TEST_
#  define DEBUG_L_TEST DEBUG_L_TEST_
#  define DEBUG_H_TEST DEBUG_H_TEST_
#  define DEBUG_X_TEST DEBUG_X_TEST_
#  define DEBUG_D_TEST DEBUG_D_TEST_
#  define DEBUG_S_TEST DEBUG_S_TEST_
#  define DEBUG_T_TEST DEBUG_T_TEST_
#  define DEBUG_R_TEST DEBUG_R_TEST_
#  define DEBUG_J_TEST DEBUG_J_TEST_

#  define DEB(a)     a
#  define DEBUG(a)   if (PL_debug)   a
#  define DEBUG_p(a) if (DEBUG_p_TEST) a
#  define DEBUG_s(a) if (DEBUG_s_TEST) a
#  define DEBUG_l(a) if (DEBUG_l_TEST) a
#  define DEBUG_t(a) if (DEBUG_t_TEST) a
#  define DEBUG_o(a) if (DEBUG_o_TEST) a
#  define DEBUG_c(a) if (DEBUG_c_TEST) a
#  define DEBUG_P(a) if (DEBUG_P_TEST) a

d2134 1
a2134 1
#  define DEBUG_m(a)  \
d2136 1
a2136 1
        if (PERL_GET_INTERP) { dTHX; if (DEBUG_m_TEST) {PL_debug&=~DEBUG_m_FLAG; a; PL_debug|=DEBUG_m_FLAG;} } \
d2138 11
a2148 17

#  define DEBUG__(t, a) \
	STMT_START { \
		if (t) STMT_START {a;} STMT_END; \
	} STMT_END

#  define DEBUG_f(a) DEBUG__(DEBUG_f_TEST, a)
#  define DEBUG_r(a) DEBUG__(DEBUG_r_TEST, a)
#  define DEBUG_x(a) DEBUG__(DEBUG_x_TEST, a)
#  define DEBUG_u(a) DEBUG__(DEBUG_u_TEST, a)
#  define DEBUG_L(a) DEBUG__(DEBUG_L_TEST, a)
#  define DEBUG_H(a) DEBUG__(DEBUG_H_TEST, a)
#  define DEBUG_X(a) DEBUG__(DEBUG_X_TEST, a)
#  define DEBUG_D(a) DEBUG__(DEBUG_D_TEST, a)

#  ifdef USE_5005THREADS
#    define DEBUG_S(a) DEBUG__(DEBUG_S_TEST, a)
d2152 23
a2174 100

#  define DEBUG_T(a) DEBUG__(DEBUG_T_TEST, a)
#  define DEBUG_R(a) DEBUG__(DEBUG_R_TEST, a)

#else /* DEBUGGING */

#  define DEBUG_p_TEST (0)
#  define DEBUG_s_TEST (0)
#  define DEBUG_l_TEST (0)
#  define DEBUG_t_TEST (0)
#  define DEBUG_o_TEST (0)
#  define DEBUG_c_TEST (0)
#  define DEBUG_P_TEST (0)
#  define DEBUG_m_TEST (0)
#  define DEBUG_f_TEST (0)
#  define DEBUG_r_TEST (0)
#  define DEBUG_x_TEST (0)
#  define DEBUG_u_TEST (0)
#  define DEBUG_L_TEST (0)
#  define DEBUG_H_TEST (0)
#  define DEBUG_X_TEST (0)
#  define DEBUG_D_TEST (0)
#  define DEBUG_S_TEST (0)
#  define DEBUG_T_TEST (0)
#  define DEBUG_R_TEST (0)
#  define DEBUG_J_TEST (0)

#  define DEB(a)
#  define DEBUG(a)
#  define DEBUG_p(a)
#  define DEBUG_s(a)
#  define DEBUG_l(a)
#  define DEBUG_t(a)
#  define DEBUG_o(a)
#  define DEBUG_c(a)
#  define DEBUG_P(a)
#  define DEBUG_m(a)
#  define DEBUG_f(a)
#  define DEBUG_r(a)
#  define DEBUG_x(a)
#  define DEBUG_u(a)
#  define DEBUG_L(a)
#  define DEBUG_H(a)
#  define DEBUG_X(a)
#  define DEBUG_D(a)
#  define DEBUG_S(a)
#  define DEBUG_T(a)
#  define DEBUG_R(a)
#endif /* DEBUGGING */


/* These constants should be used in preference to raw characters
 * when using magic. Note that some perl guts still assume
 * certain character properties of these constants, namely that
 * isUPPER() and toLOWER() may do useful mappings.
 *
 * Update the magic_names table in dump.c when adding/amending these
 */

#define PERL_MAGIC_sv		  '\0' /* Special scalar variable */
#define PERL_MAGIC_overload	  'A' /* %OVERLOAD hash */
#define PERL_MAGIC_overload_elem  'a' /* %OVERLOAD hash element */
#define PERL_MAGIC_overload_table 'c' /* Holds overload table (AMT) on stash */
#define PERL_MAGIC_bm		  'B' /* Boyer-Moore (fast string search) */
#define PERL_MAGIC_regdata	  'D' /* Regex match position data
					(@@+ and @@- vars) */
#define PERL_MAGIC_regdatum	  'd' /* Regex match position data element */
#define PERL_MAGIC_env		  'E' /* %ENV hash */
#define PERL_MAGIC_envelem	  'e' /* %ENV hash element */
#define PERL_MAGIC_fm		  'f' /* Formline ('compiled' format) */
#define PERL_MAGIC_regex_global	  'g' /* m//g target / study()ed string */
#define PERL_MAGIC_isa		  'I' /* @@ISA array */
#define PERL_MAGIC_isaelem	  'i' /* @@ISA array element */
#define PERL_MAGIC_nkeys	  'k' /* scalar(keys()) lvalue */
#define PERL_MAGIC_dbfile	  'L' /* Debugger %_<filename */
#define PERL_MAGIC_dbline	  'l' /* Debugger %_<filename element */
#define PERL_MAGIC_mutex	  'm' /* for lock op */
#define PERL_MAGIC_shared	  'N' /* Shared between threads */
#define PERL_MAGIC_shared_scalar  'n' /* Shared between threads */
#define PERL_MAGIC_collxfrm	  'o' /* Locale transformation */
#define PERL_MAGIC_tied		  'P' /* Tied array or hash */
#define PERL_MAGIC_tiedelem	  'p' /* Tied array or hash element */
#define PERL_MAGIC_tiedscalar	  'q' /* Tied scalar or handle */
#define PERL_MAGIC_qr		  'r' /* precompiled qr// regex */
#define PERL_MAGIC_sig		  'S' /* %SIG hash */
#define PERL_MAGIC_sigelem	  's' /* %SIG hash element */
#define PERL_MAGIC_taint	  't' /* Taintedness */
#define PERL_MAGIC_uvar		  'U' /* Available for use by extensions */
#define PERL_MAGIC_uvar_elem	  'u' /* Reserved for use by extensions */
#define PERL_MAGIC_vec		  'v' /* vec() lvalue */
#define PERL_MAGIC_substr	  'x' /* substr() lvalue */
#define PERL_MAGIC_defelem	  'y' /* Shadow "foreach" iterator variable /
					smart parameter vivification */
#define PERL_MAGIC_glob		  '*' /* GV (typeglob) */
#define PERL_MAGIC_arylen	  '#' /* Array length ($#ary) */
#define PERL_MAGIC_pos		  '.' /* pos() lvalue */
#define PERL_MAGIC_backref	  '<' /* for weak ref data */
#define PERL_MAGIC_ext		  '~' /* Available for use by extensions */


a2177 8
#ifdef DEBUGGING
#define assert(what)	DEB( {						\
	if (!(what)) {							\
	    Perl_croak(aTHX_ "Assertion " STRINGIFY(what) " failed: file \"%s\", line %d",	\
		__FILE__, __LINE__);					\
	    PerlProc_exit(1);						\
	}})
#else
a2184 1
#endif
d2187 2
a2188 2
    I32 (*uf_val)(pTHX_ IV, SV*);
    I32 (*uf_set)(pTHX_ IV, SV*);
a2191 22
/* In pre-5.7-Perls the PERL_MAGIC_uvar magic didn't get the thread context.
 * XS code wanting to be backward compatible can do something
 * like the following:

#ifndef PERL_MG_UFUNC
#define PERL_MG_UFUNC(name,ix,sv) I32 name(IV ix, SV *sv)
#endif

static PERL_MG_UFUNC(foo_get, index, val)
{
    sv_setsv(val, ...);
    return TRUE;
}

-- Doug MacEachern

*/

#ifndef PERL_MG_UFUNC
#define PERL_MG_UFUNC(name,ix,sv) I32 name(pTHX_ IV ix, SV *sv)
#endif

a2231 49
#if !defined(NV_INF) && defined(USE_LONG_DOUBLE) && defined(LDBL_INFINITY)
#  define NV_INF LDBL_INFINITY
#endif
#if !defined(NV_INF) && defined(DBL_INFINITY)
#  define NV_INF (NV)DBL_INFINITY
#endif
#if !defined(NV_INF) && defined(INFINITY)
#  define NV_INF (NV)INFINITY
#endif
#if !defined(NV_INF) && defined(INF)
#  define NV_INF (NV)INF
#endif
#if !defined(NV_INF) && defined(USE_LONG_DOUBLE) && defined(HUGE_VALL)
#  define NV_INF (NV)HUGE_VALL
#endif
#if !defined(NV_INF) && defined(HUGE_VAL)
#  define NV_INF (NV)HUGE_VAL
#endif

#if !defined(NV_NAN) && defined(USE_LONG_DOUBLE)
#   if !defined(NV_NAN) && defined(LDBL_NAN)
#       define NV_NAN LDBL_NAN
#   endif
#   if !defined(NV_NAN) && defined(LDBL_QNAN)
#       define NV_NAN LDBL_QNAN
#   endif
#   if !defined(NV_NAN) && defined(LDBL_SNAN)
#       define NV_NAN LDBL_SNAN
#   endif
#endif
#if !defined(NV_NAN) && defined(DBL_NAN)
#  define NV_NAN (NV)DBL_NAN
#endif
#if !defined(NV_NAN) && defined(DBL_QNAN)
#  define NV_NAN (NV)DBL_QNAN
#endif
#if !defined(NV_NAN) && defined(DBL_SNAN)
#  define NV_NAN (NV)DBL_SNAN
#endif
#if !defined(NV_NAN) && defined(QNAN)
#  define NV_NAN (NV)QNAN
#endif
#if !defined(NV_NAN) && defined(SNAN)
#  define NV_NAN (NV)SNAN
#endif
#if !defined(NV_NAN) && defined(NAN)
#  define NV_NAN (NV)NAN
#endif

d2236 1
a2236 2
#    if !defined(WIN32) && !defined(VMS)
#ifndef crypt
a2237 1
#endif
a2251 1
#ifndef getlogin
a2252 1
#endif
a2261 9
/* some versions of glibc are missing the setresuid() proto */
#if defined(HAS_SETRESUID) && !defined(HAS_SETRESUID_PROTO)
int setresuid(uid_t ruid, uid_t euid, uid_t suid);
#endif
/* some versions of glibc are missing the setresgid() proto */
#if defined(HAS_SETRESGID) && !defined(HAS_SETRESGID_PROTO)
int setresgid(gid_t rgid, gid_t egid, gid_t sgid);
#endif

a2321 2
typedef void (CPERLscope(*share_proc_t)) (pTHX_ SV *sv);
typedef int  (CPERLscope(*thrhook_proc_t)) (pTHX);
d2346 1
a2346 1
        defined(__DGUX)
d2400 1
a2400 1
/* fast conversion and case folding tables */
d2657 1
a2657 1
#ifdef USE_5005THREADS
d2670 2
a2671 2
#define HINT_LOCALE		0x00000004
#define HINT_BYTES		0x00000008
d2678 1
d2693 1
a2693 6
#define HINT_SORT_SORT_BITS	0x000000FF /* allow 256 different ones */
#define HINT_SORT_QUICKSORT	0x00000001
#define HINT_SORT_MERGESORT	0x00000002
#define HINT_SORT_STABLE	0x00000100 /* sort styles (currently one) */

/* Various states of the input record separator SV (rs) */
a2698 11
/* A struct for keeping various DEBUGGING related stuff,
 * neatly packed.  Currently only scratch variables for
 * constructing debug output are included.  Needed always,
 * not just when DEBUGGING, though, because of the re extension. c*/
struct perl_debug_pad {
  SV pad[3];
};

#define PERL_DEBUG_PAD(i)	&(PL_debug_pad.pad[i])
#define PERL_DEBUG_PAD_ZERO(i)	(SvPVX(PERL_DEBUG_PAD(i))[0] = 0, SvCUR(PERL_DEBUG_PAD(i)) = 0, PERL_DEBUG_PAD(i))

a2699 1
typedef void (CPERLscope(*peep_t))(pTHX_ OP* o);
d2712 6
a2717 6
typedef void (*DESTRUCTORFUNC_t) (pTHX_ void*);
typedef void (*SVFUNC_t) (pTHX_ SV*);
typedef I32  (*SVCOMPARE_t) (pTHX_ SV*, SV*);
typedef void (*XSINIT_t) (pTHX);
typedef void (*ATEXIT_t) (pTHX_ void*);
typedef void (*XSUBADDR_t) (pTHX_ CV *);
d2727 1
a2727 1
    void (*fn) (pTHX_ void*);
d2749 2
a2750 2
#if defined(MULTIPLICITY)
/* If we have multiple interpreters define a struct
d2752 1
a2752 1
   If we don't have threads anything that would have
d2757 1
a2757 1
#  ifndef USE_5005THREADS
d2763 1
a2763 1
 * be defined to maintain binary compatibility with previous versions
d2772 1
a2772 1
#endif /* MULTIPLICITY */
d2774 1
a2774 1
#ifdef USE_5005THREADS
d2801 1
a2801 1
#endif
d2812 4
d2823 5
d2829 2
a2830 1
#include "opcode.h"
d2838 1
a2838 1
/* Now include all the 'global' variables
d2840 1
a2840 1
 * these include variables that would have been their struct-s
d2842 1
a2842 1

d2848 1
a2848 1
#if !defined(MULTIPLICITY)
d2851 1
a2851 1
#  ifndef USE_5005THREADS
d2857 1
a2857 2
#if defined(WIN32)
/* Now all the config stuff is setup we can include embed.h */
d2859 15
a2873 1
#endif
d2892 1
a2892 1
EXT MGVTBL PL_vtbl_sv =		{MEMBER_TO_FPTR(Perl_magic_get),
a2902 3
#ifdef PERL_MICRO
EXT MGVTBL PL_vtbl_sigelem =	{0,	0,		 0, 0, 0};
#else
d2907 1
a2907 4
#endif
EXT MGVTBL PL_vtbl_pack =	{0,	0,	
    				MEMBER_TO_FPTR(Perl_magic_sizepack),	
				MEMBER_TO_FPTR(Perl_magic_wipepack),
d2910 1
a2910 1
					MEMBER_TO_FPTR(Perl_magic_setpack),
d2931 1
a2931 2
EXT MGVTBL PL_vtbl_taint =	{MEMBER_TO_FPTR(Perl_magic_gettaint),
    					MEMBER_TO_FPTR(Perl_magic_settaint),
d2933 1
a2933 2
EXT MGVTBL PL_vtbl_substr =	{MEMBER_TO_FPTR(Perl_magic_getsubstr),
    					MEMBER_TO_FPTR(Perl_magic_setsubstr),
d2936 1
a2936 1
					MEMBER_TO_FPTR(Perl_magic_setvec),
d2948 4
a2951 6
#ifdef USE_5005THREADS
EXT MGVTBL PL_vtbl_mutex =	{0,	0,	0,	0,	
					MEMBER_TO_FPTR(Perl_magic_mutexfree)};
#endif /* USE_5005THREADS */
EXT MGVTBL PL_vtbl_defelem = {MEMBER_TO_FPTR(Perl_magic_getdefelem),
    					MEMBER_TO_FPTR(Perl_magic_setdefelem),
a2972 3
EXT MGVTBL PL_vtbl_ovrld   = 	  {0,	0,
					0,	0,	MEMBER_TO_FPTR(Perl_magic_freeovrld)};

a2995 1
EXT MGVTBL PL_vtbl_ovrld;
d2997 1
a2997 1
#ifdef USE_5005THREADS
d2999 1
a2999 1
#endif /* USE_5005THREADS */
d3049 1
a3049 2
  to_cv_amg,   iter_amg,
  int_amg,	DESTROY_amg,
a3054 1
#define AMG_id2name(id) ((char*)PL_AMG_names[id]+1)
d3058 32
a3089 38
  /* Names kept in the symbol table.  fallback => "()", the rest has
     "(" prepended.  The only other place in perl which knows about
     this convention is AMG_id2name (used for debugging output and
     'nomethod' only), the only other place which has it hardwired is
     overload.pm.  */
  "()",		"(abs",			/* "fallback" should be the first. */
  "(bool",	"(nomethod",
  "(\"\"",	"(0+",
  "(+",		"(+=",
  "(-",		"(-=",
  "(*",		"(*=",
  "(/",		"(/=",
  "(%",		"(%=",
  "(**",	"(**=",
  "(<<",	"(<<=",
  "(>>",	"(>>=",
  "(&",		"(&=",
  "(|",		"(|=",
  "(^",		"(^=",
  "(<",		"(<=",
  "(>",		"(>=",
  "(==",	"(!=",
  "(<=>",	"(cmp",
  "(lt",	"(le",
  "(gt",	"(ge",
  "(eq",	"(ne",
  "(!",		"(~",
  "(++",	"(--",
  "(atan2",	"(cos",
  "(sin",	"(exp",
  "(log",	"(sqrt",
  "(x",		"(x=",
  "(.",		"(.=",
  "(=",		"(neg",
  "(${}",	"(@@{}",
  "(%{}",	"(*{}",
  "(&{}",	"(<>",
  "(int",	"DESTROY",
d3098 1
a3098 1
  U32 was_ok_sub;
d3105 1
a3105 1
  U32 was_ok_sub;
a3116 1
#define AMTf_OVERLOADED		2
a3119 3
#define AMT_OVERLOADED(amt)	((amt)->flags & AMTf_OVERLOADED)
#define AMT_OVERLOADED_on(amt)	((amt)->flags |= AMTf_OVERLOADED)
#define AMT_OVERLOADED_off(amt)	((amt)->flags &= ~AMTf_OVERLOADED)
a3120 1
#define StashHANDLER(stash,meth)	gv_handler((stash),CAT2(meth,_amg))
d3190 3
a3192 5
#define IN_LOCALE_RUNTIME	(PL_curcop->op_private & HINT_LOCALE)
#define IN_LOCALE_COMPILETIME	(PL_hints & HINT_LOCALE)

#define IN_LOCALE \
	(PL_curcop == &PL_compiling ? IN_LOCALE_COMPILETIME : IN_LOCALE_RUNTIME)
d3195 1
a3195 1
	bool was_local = PL_numeric_local && IN_LOCALE; \
d3199 1
a3199 1
	bool was_standard = PL_numeric_standard && IN_LOCALE; \
d3214 1
a3214 1
#define IS_NUMERIC_RADIX(a, b)		(0)
d3219 1
a3219 2
#define Atof				my_atof
#define IN_LOCALE_RUNTIME		0
a3226 3
#    ifdef WIN64
#        define strtoll _strtoi64	/* secret handshake */
#    endif
a3229 3
#    if !defined(Strtol) && defined(HAS_STRTOQ)
#       define Strtol	strtoq
#    endif
a3239 3
#    ifdef WIN64
#       define atoll    _atoi64		/* secret handshake */
#    endif
a3249 3
#    ifdef WIN64
#        define strtoull _strtoui64	/* secret handshake */
#    endif
d3265 4
a3268 3
#if !defined(PERLIO_IS_STDIO)
/*
 * Remap printf
a3270 3
#ifdef __GNUC__
#define printf(fmt,args...) PerlIO_stdoutf(fmt,##args)
#else
a3272 1
#endif
a3308 9

#ifndef PERL_MICRO
#   ifndef PERL_OLD_SIGNALS
#		ifndef PERL_ASYNC_CHECK
#			define PERL_ASYNC_CHECK() if (PL_sig_pending) despatch_signals()
#		endif
#   endif
#endif

d3310 1
a3310 1
#   define PERL_ASYNC_CHECK()  NOOP
d3327 11
a3337 15
#define offer_nice_chunk(chunk, chunk_size) STMT_START {  \
       void *new_chunk;                                   \
       U32 new_chunk_size;                                \
       LOCK_SV_MUTEX;                                     \
       new_chunk = (void *)(chunk);                       \
       new_chunk_size = (chunk_size);                     \
       if (new_chunk_size > PL_nice_chunk_size) {         \
           if (PL_nice_chunk) Safefree(PL_nice_chunk);    \
           PL_nice_chunk = new_chunk;                     \
           PL_nice_chunk_size = new_chunk_size;           \
       } else {                                           \
           Safefree(chunk);                               \
       }                                                  \
       UNLOCK_SV_MUTEX;                                   \
   } STMT_END
a3370 78
/*
 * Boilerplate macros for initializing and accessing interpreter-local
 * data from C.  All statics in extensions should be reworked to use
 * this, if you want to make the extension thread-safe.  See ext/re/re.xs
 * for an example of the use of these macros, and perlxs.pod for more.
 *
 * Code that uses these macros is responsible for the following:
 * 1. #define MY_CXT_KEY to a unique string, e.g.
 *    "DynaLoader::_guts" XS_VERSION
 * 2. Declare a typedef named my_cxt_t that is a structure that contains
 *    all the data that needs to be interpreter-local.
 * 3. Use the START_MY_CXT macro after the declaration of my_cxt_t.
 * 4. Use the MY_CXT_INIT macro such that it is called exactly once
 *    (typically put in the BOOT: section).
 * 5. Use the members of the my_cxt_t structure everywhere as
 *    MY_CXT.member.
 * 6. Use the dMY_CXT macro (a declaration) in all the functions that
 *    access MY_CXT.
 */

#if defined(PERL_IMPLICIT_CONTEXT)

/* This must appear in all extensions that define a my_cxt_t structure,
 * right after the definition (i.e. at file scope).  The non-threads
 * case below uses it to declare the data as static. */
#define START_MY_CXT

/* Fetches the SV that keeps the per-interpreter data. */
#define dMY_CXT_SV \
	SV *my_cxt_sv = *hv_fetch(PL_modglobal, MY_CXT_KEY,		\
				  sizeof(MY_CXT_KEY)-1, TRUE)

/* This declaration should be used within all functions that use the
 * interpreter-local data. */
#define dMY_CXT	\
	dMY_CXT_SV;							\
	my_cxt_t *my_cxtp = INT2PTR(my_cxt_t*, SvUV(my_cxt_sv))

/* Creates and zeroes the per-interpreter data.
 * (We allocate my_cxtp in a Perl SV so that it will be released when
 * the interpreter goes away.) */
#define MY_CXT_INIT \
	dMY_CXT_SV;							\
	/* newSV() allocates one more than needed */			\
	my_cxt_t *my_cxtp = (my_cxt_t*)SvPVX(newSV(sizeof(my_cxt_t)-1));\
	Zero(my_cxtp, 1, my_cxt_t);					\
	sv_setuv(my_cxt_sv, PTR2UV(my_cxtp))

/* This macro must be used to access members of the my_cxt_t structure.
 * e.g. MYCXT.some_data */
#define MY_CXT		(*my_cxtp)

/* Judicious use of these macros can reduce the number of times dMY_CXT
 * is used.  Use is similar to pTHX, aTHX etc. */
#define pMY_CXT		my_cxt_t *my_cxtp
#define pMY_CXT_	pMY_CXT,
#define _pMY_CXT	,pMY_CXT
#define aMY_CXT		my_cxtp
#define aMY_CXT_	aMY_CXT,
#define _aMY_CXT	,aMY_CXT

#else /* USE_ITHREADS */

#define START_MY_CXT	static my_cxt_t my_cxt;
#define dMY_CXT_SV	dNOOP
#define dMY_CXT		dNOOP
#define MY_CXT_INIT	NOOP
#define MY_CXT		my_cxt

#define pMY_CXT		void
#define pMY_CXT_
#define _pMY_CXT
#define aMY_CXT
#define aMY_CXT_
#define _aMY_CXT

#endif /* !defined(USE_ITHREADS) */

a3378 4
#if defined(HAS_FLOCK) && !defined(HAS_FLOCK_PROTO)
int flock(int fd, int op);
#endif

a3394 17
#if O_TEXT != O_BINARY
    /* If you have different O_TEXT and O_BINARY and you are a CLRF shop,
     * that is, you are somehow DOSish. */
#   if defined(__BEOS__) || defined(__VOS__)
    /* BeOS has O_TEXT != O_BINARY but O_TEXT and O_BINARY have no effect;
     * BeOS is always UNIXoid (LF), not DOSish (CRLF). */
    /* VOS has O_TEXT != O_BINARY, and they have effect,
     * but VOS always uses LF, never CRLF. */
    /* If you have O_TEXT different from your O_BINARY but you still are
     * not a CRLF shop. */
#       undef PERLIO_USING_CRLF
#   else
    /* If you really are DOSish. */
#      define PERLIO_USING_CRLF 1
#   endif
#endif

a3397 3
#   if defined(PERL_SCO) && !defined(_SVID3)
#       define _SVID3
#   endif
a3444 49
#define IS_NUMBER_IN_UV		      0x01 /* number within UV range (maybe not
					      int).  value returned in pointed-
					      to UV */
#define IS_NUMBER_GREATER_THAN_UV_MAX 0x02 /* pointed to UV undefined */
#define IS_NUMBER_NOT_INT	      0x04 /* saw . or E notation */
#define IS_NUMBER_NEG		      0x08 /* leading minus sign */
#define IS_NUMBER_INFINITY	      0x10 /* this is big */
#define IS_NUMBER_NAN                 0x20 /* this is not */

#define GROK_NUMERIC_RADIX(sp, send) grok_numeric_radix(sp, send)

/* Input flags: */
#define PERL_SCAN_ALLOW_UNDERSCORES   0x01 /* grok_??? accept _ in numbers */
#define PERL_SCAN_DISALLOW_PREFIX     0x02 /* grok_??? reject 0x in hex etc */
/* Output flags: */
#define PERL_SCAN_GREATER_THAN_UV_MAX 0x02 /* should this merge with above? */

/* to let user control profiling */
#ifdef PERL_GPROF_CONTROL
extern void moncontrol(int);
#define PERL_GPROF_MONCONTROL(x) moncontrol(x)
#else
#define PERL_GPROF_MONCONTROL(x)
#endif

#ifdef UNDER_CE
#include "wince.h"
#endif

/* ISO 6429 NEL - C1 control NExt Line */
/* See http://www.unicode.org/unicode/reports/tr13/ */
#ifdef EBCDIC	/* In EBCDIC NEL is just an alias for LF */
#   if '^' == 95	/* CP 1047: MVS OpenEdition - OS/390 - z/OS */
#       define NEXT_LINE_CHAR	0x15
#   else		/* CDRA */
#       define NEXT_LINE_CHAR	0x25
#   endif
#else
#   define NEXT_LINE_CHAR	0x85
#endif

/* The UTF-8 bytes of the Unicode LS and PS, U+2028 and U+2029 */
#define UNICODE_LINE_SEPA_0	0xE2
#define UNICODE_LINE_SEPA_1	0x80
#define UNICODE_LINE_SEPA_2	0xA8
#define UNICODE_PARA_SEPA_0	0xE2
#define UNICODE_PARA_SEPA_1	0x80
#define UNICODE_PARA_SEPA_2	0xA9

d3451 2
d3454 2
a3455 1
   NV_PRESERVES_UV
a3474 18
   HAS_USLEEP
   HAS_UALARM

   HAS_SETITIMER
   HAS_GETITIMER

   HAS_SENDMSG
   HAS_RECVMSG
   HAS_READV
   HAS_WRITEV
   I_SYSUIO
   HAS_STRUCT_MSGHDR
   HAS_STRUCT_CMSGHDR

   HAS_NL_LANGINFO

   HAS_DIRFD

a3477 1

@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@d3 1
a3 2
 *    Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999,
 *    2000, 2001, 2002, 2003, by Larry Wall and others
d43 7
d92 1
a92 1
#if defined(USE_ITHREADS) && !defined(USE_REENTRANT_API) && !defined(NETWARE) && !defined(WIN32) && !defined(PERL_DARWIN)
a97 11
/*
 * PERL_DARWIN for MacOSX (__APPLE__ exists but is not officially sanctioned)
 * (The -DPERL_DARWIN comes from the hints/darwin.sh.)
 * __bsdi__ for BSD/OS
 */
#if defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__) || defined(PERL_DARWIN) || defined(__bsdi__) || defined(BSD41) || defined(BSD42) || defined(BSD43) || defined(BSD44)
#   ifndef BSDish
#       define BSDish
#   endif
#endif

d144 1
a144 1
#  if (defined(__GNUC__) && defined(__cplusplus)) || defined(__INTEL_COMPILER)
a222 4
#if defined(__STRICT_ANSI__) && defined(PERL_GCC_PEDANTIC)
#   define PERL_GCC_BRACE_GROUPS_FORBIDDEN
#endif

d231 1
a231 1
# if defined(__GNUC__) && !defined(PERL_GCC_BRACE_GROUPS_FORBIDDEN) && !defined(__cplusplus)
d236 1
a236 1
#  if (VOIDFLAGS) && (defined(sun) || defined(__sun__)) && !defined(__GNUC__)
d291 1
a291 1
#if defined(__cplusplus) || defined(WIN32) || defined(__sgi) || defined(__EMX__) || defined(__DGUX) || defined( EPOC) || defined(__QNX__) || defined(NETWARE) || defined(PERL_MICRO)
d498 10
a512 16
#  define CHECK_MALLOC_TOO_LATE_FOR_(code)	STMT_START {		\
	if (!PL_tainting && MallocCfg_ptr[MallocCfg_cfg_env_read])	\
		code;							\
    } STMT_END
#  define CHECK_MALLOC_TOO_LATE_FOR(ch)				\
	CHECK_MALLOC_TOO_LATE_FOR_(MALLOC_TOO_LATE_FOR(ch))
#  define panic_write2(s)		write(2, s, strlen(s))
#  define CHECK_MALLOC_TAINT(newval)				\
	CHECK_MALLOC_TOO_LATE_FOR_(				\
		if (newval) {					\
		  panic_write2("panic: tainting with $ENV{PERL_MALLOC_OPT}\n");\
		  exit(1); })
#  define MALLOC_CHECK_TAINT(argc,argv,env)	STMT_START {	\
	if (doing_taint(argc,argv,env)) {			\
		MallocCfg_ptr[MallocCfg_skip_cfg_env] = 1;	\
    }} STMT_END;
a517 3
#  define CHECK_MALLOC_TOO_LATE_FOR(ch)		((void)0)
#  define CHECK_MALLOC_TAINT(newval)		((void)0)
#  define MALLOC_CHECK_TAINT(argc,argv,env)
a519 5
#define TOO_LATE_FOR_(ch,s)	Perl_croak(aTHX_ "Too late for \"-%c\" option%s", (char)(ch), s)
#define TOO_LATE_FOR(ch)	TOO_LATE_FOR_(ch, "")
#define MALLOC_TOO_LATE_FOR(ch)	TOO_LATE_FOR_(ch, " with $ENV{PERL_MALLOC_OPT}")
#define MALLOC_CHECK_TAINT2(argc,argv)	MALLOC_CHECK_TAINT(argc,argv,NULL)

d579 1
a579 1
#    pragma function(memcmp)
a598 1
#ifndef PERL_MICRO
a603 1
#endif
d675 3
a677 6
/* In Tru64 use the 4.4BSD struct msghdr, not the 4.3 one.
 * This is important for using IPv6. 
 * For OSF/1 3.2, however, defining _SOCKADDR_LEN would be
 * a bad idea since it breaks send() and recv(). */
#if defined(__osf__) && defined(__alpha) && !defined(_SOCKADDR_LEN) && !defined(DEC_OSF1_3_X)
#   define _SOCKADDR_LEN
d718 1
a718 2
 * behind some -D_BLAH_BLAH_SOURCE guard.  The __THROW magic is required
 * e.g. in Gentoo, see http://bugs.gentoo.org/show_bug.cgi?id=12605 */
a719 3
# if defined(__THROW) && defined(__GLIBC__)
int sockatmark(int) __THROW;
# else
a720 1
# endif
a732 12
#   define LIB_INVARG 		LIB$_INVARG
#   define RMS_DIR    		RMS$_DIR
#   define RMS_FAC    		RMS$_FAC
#   define RMS_FEX    		RMS$_FEX
#   define RMS_FNF    		RMS$_FNF
#   define RMS_IFI    		RMS$_IFI
#   define RMS_ISI    		RMS$_ISI
#   define RMS_PRV    		RMS$_PRV
#   define SS_ACCVIO      	SS$_ACCVIO
#   define SS_DEVOFFLINE	SS$_DEVOFFLINE
#   define SS_IVCHAN  		SS$_IVCHAN
#   define SS_NORMAL  		SS$_NORMAL
a734 12
#   define LIB_INVARG 		0
#   define RMS_DIR    		0
#   define RMS_FAC    		0
#   define RMS_FEX    		0
#   define RMS_FNF    		0
#   define RMS_IFI    		0
#   define RMS_ISI    		0
#   define RMS_PRV    		0
#   define SS_ACCVIO      	0
#   define SS_DEVOFFLINE	0
#   define SS_IVCHAN  		0
#   define SS_NORMAL  		0
d1133 2
a1134 4
   default value for printing floating point numbers in Gconvert
   (see config.h). (It also has other uses, such as figuring out if
   a given precision of printing can be done with a double instead of
   a long double - Allen).
a1188 23
/*
 * This is for making sure we have a good DBL_MAX value, if possible,
 * either for usage as NV_MAX or for usage in figuring out if we can
 * fit a given long double into a double, if bug-fixing makes it
 * necessary to do so. - Allen <allens@@cpan.org>
 */

#ifdef I_LIMITS
#  include <limits.h>
#endif

#ifdef I_VALUES
#  if !(defined(DBL_MIN) && defined(DBL_MAX) && defined(I_LIMITS))
#    include <values.h>
#    if defined(MAXDOUBLE) && !defined(DBL_MAX)
#      define DBL_MAX MAXDOUBLE
#    endif
#    if defined(MINDOUBLE) && !defined(DBL_MIN)
#      define DBL_MIN MINDOUBLE
#    endif
#  endif
#endif /* defined(I_VALUES) */

d1220 1
a1220 1
/* Having LDBL_MAX doesn't necessarily mean that we have LDBL_MIN... -Allen */
a1243 5
/* eg glibc 2.2 series seems to provide modfl on ppc and arm, but has no
   prototype in <math.h> */
#       ifndef HAS_MODFL_PROTO
long double modfl(long double, long double *);
#	endif
d1245 1
a1245 4
#       if defined(HAS_AINTL) && defined(HAS_COPYSIGNL)
        extern long double Perl_my_modfl(long double x, long double *ip);
#           define Perl_modf(x,y) Perl_my_modfl(x,y)
#       endif
d1250 1
a1250 4
#       if defined(HAS_ILOGBL) && defined(HAS_SCALBNL)
        extern long double Perl_my_frexpl(long double x, int *e);
#           define Perl_frexp(x,y) Perl_my_frexpl(x,y)
#       endif
d1282 1
a1282 1
#   ifdef DBL_MAX               /* XXX Does DBL_MAX imply having DBL_MIN? */
a1304 7
/* SGI has fpclassl... but not with the same result values,
 * and it's via a typedef (not via #define), so will need to redo Configure
 * to use. Not worth the trouble, IMO, at least until the below is used
 * more places. Also has fp_class_l, BTW, via fp_class.h. Feel free to check
 * with me for the SGI manpages, SGI testing, etcetera, if you want to
 * try getting this to work with IRIX. - Allen <allens@@cpan.org> */

d1446 1
a1446 2
 * t/op/numconvert.t, and t/op/pack.t. Note that if using long doubles
 * you may need to be using a different function than atof! */
d1479 4
a1483 2
/* Included values.h above if necessary; still including limits.h down here,
 * despite doing above, because math.h might have overriden... XXX - Allen */
d1644 11
a1654 4
#ifdef MYMALLOC
#  include "malloc_ctl.h"
#endif

d1895 2
a1896 4
#    if defined(SIGFPE) && defined(SIG_IGN) && !defined(PERL_MICRO)
#      define PERL_FPU_INIT       PL_sigfpe_saved = signal(SIGFPE, SIG_IGN);
#      define PERL_FPU_PRE_EXEC   { Sigsave_t xfpe; rsignal_save(SIGFPE, PL_sigfpe_saved, &xfpe);
#      define PERL_FPU_POST_EXEC    rsignal_restore(SIGFPE, &xfpe); }
a1898 1

a1901 4
#ifndef PERL_FPU_PRE_EXEC
#  define PERL_FPU_PRE_EXEC   {
#  define PERL_FPU_POST_EXEC  }
#endif
d1915 3
a1917 6
/* POSIX 1990 (and pre) was ambiguous about whether PATH_MAX
 * included the null byte or not.  Later amendments of POSIX,
 * XPG4, the Austin Group, and the Single UNIX Specification
 * all explicitly include the null byte in the PATH_MAX.
 * Ditto for _POSIX_PATH_MAX. */
#         define MAXPATHLEN PATH_MAX
d1919 1
a1919 1
#         define MAXPATHLEN _POSIX_PATH_MAX
d1926 1
a1926 1
#       define MAXPATHLEN _POSIX_PATH_MAX
a2096 3
#    ifndef SVf256
#      define SVf256 SVf
#    endif
a2101 4
#ifndef SVf256
#  define SVf256 ".256"SVf
#endif

a2125 8
#ifndef __attribute__format__
#  ifdef CHECK_FORMAT
#    define __attribute__format__(x,y,z) __attribute__((__format__(x,y,z)))
#  else
#    define __attribute__format__(x,y,z)
#  endif
#endif
 
d2153 1
a2153 2
#  define USEMYBINMODE /**/
#  include <io.h> /* for setmode() prototype */
d2155 1
a2155 5
            (PerlLIO_setmode(fileno(fp), mode) != -1 ? TRUE : FALSE)
#endif

#ifdef __CYGWIN__
void init_os_extras(void);
a2165 1
    bool	any_bool;
a2201 11

/* [perl #22371] Algorimic Complexity Attack on Perl 5.6.1, 5.8.0.
 * Note that the USE_HASH_SEED and USE_HASH_SEED_EXPLICIT are *NOT*
 * defined by Configure, despite their names being similar to the
 * other defines like USE_ITHREADS.  Configure in fact knows nothing
 * about the randomised hashes.  Therefore to enable/disable the hash
 * randomisation defines use the Configure -Accflags=... instead. */
#if !defined(NO_HASH_SEED) && !defined(USE_HASH_SEED) && !defined(USE_HASH_SEED_EXPLICIT)
#  define USE_HASH_SEED
#endif

a2206 1
#include "pad.h"
a2398 1
				 && isGV(PL_stderrgv)		\
d2418 1
d2426 1
a2426 2
#define DEBUG_v_FLAG		0x00100000 /*1048576 */
#define DEBUG_MASK		0x001FEFFF /* mask of all the standard flags */
d2444 1
a2451 3
#  define DEBUG_v_TEST_ (PL_debug & DEBUG_v_FLAG)
#  define DEBUG_Xv_TEST_ (DEBUG_X_TEST_ && DEBUG_v_TEST_)

d2470 1
a2472 1
#  define DEBUG_Xv_TEST DEBUG_Xv_TEST_
a2477 1
#  define DEBUG_v_TEST DEBUG_v_TEST_
d2479 2
a2480 2
#  define PERL_DEB(a)                  a
#  define PERL_DEBUG(a) if (PL_debug)  a
d2505 1
a2507 1
#  define DEBUG_Xv(a) DEBUG__(DEBUG_Xv_TEST, a)
a2517 1
#  define DEBUG_v(a) DEBUG__(DEBUG_v_TEST, a)
d2533 1
a2535 1
#  define DEBUG_Xv_TEST (0)
a2540 1
#  define DEBUG_v_TEST (0)
d2542 2
a2543 2
#  define PERL_DEB(a)
#  define PERL_DEBUG(a)
d2556 1
a2558 1
#  define DEBUG_Xv(a)
a2562 1
#  define DEBUG_v(a)
a2565 7
#define DEBUG_SCOPE(where) \
    DEBUG_l(WITH_THR(Perl_deb(aTHX_ "%s scope %ld at %s:%d\n",	\
		    where, PL_scopestack_ix, __FILE__, __LINE__)));




a2603 1
#define PERL_MAGIC_vstring	  'V' /* SV was vstring literal */
a2604 1
#define PERL_MAGIC_utf8		  'w' /* Cached UTF-8 information */
d2619 1
a2619 1
#define assert(what)	PERL_DEB( {					\
d2626 1
a2626 1
#define assert(what)	PERL_DEB( {					\
d2824 1
d2827 1
d2864 1
a2864 1
    (defined(NeXT) || defined(__NeXT__) || defined(PERL_DARWIN))
d2870 1
a2870 1
#    if defined(PERL_DARWIN) && defined(PERL_CORE)
a2921 2
EXTCONST char PL_no_localize_ref[]
  INIT("Can't localize through a reference");
a3149 10
#ifdef __Lynx__
/* LynxOS defines these in scsi.h which is included via ioctl.h */
#ifdef FORMAT
#undef FORMAT
#endif
#ifdef SPACE
#undef SPACE
#endif
#endif

d3197 1
a3197 2
    want_vtbl_backref,
    want_vtbl_utf8
d3203 4
a3206 4
#define HINT_INTEGER		0x00000001 /* integer pragma */
#define HINT_STRICT_REFS	0x00000002 /* strict pragma */
#define HINT_LOCALE		0x00000004 /* locale pragma */
#define HINT_BYTES		0x00000008 /* bytes pragma */
a3208 1
				/* currently defined by vms/vmsish.h */
d3211 2
a3212 2
#define HINT_STRICT_SUBS	0x00000200 /* strict pragma */
#define HINT_STRICT_VARS	0x00000400 /* strict pragma */
a3213 1
/* The HINT_NEW_* constants are used by the overload pragma */
d3221 2
a3222 2
#define HINT_RE_TAINT		0x00100000 /* re pragma */
#define HINT_RE_EVAL		0x00200000 /* re pragma */
d3224 2
a3225 2
#define HINT_FILETEST_ACCESS	0x00400000 /* filetest pragma */
#define HINT_UTF8		0x00800000 /* utf8 pragma */
a3226 1
/* The following are stored in $sort::hints, not in PL_hints */
a3346 19
/* Types used by pack/unpack */ 
typedef enum {
  e_no_len,     /* no length  */
  e_number,     /* number, [] */
  e_star        /* asterisk   */
} howlen_t;

typedef struct {
  char*    patptr;   /* current template char */
  char*    patend;   /* one after last char   */
  char*    grpbeg;   /* 1st char of ()-group  */
  char*    grpend;   /* end of ()-group       */
  I32      code;     /* template code (!)     */
  I32      length;   /* length/repeat count   */
  howlen_t howlen;   /* how length is given   */ 
  int      level;    /* () nesting level      */
  U32      flags;    /* /=4, comma=2, pack=1  */
} tempsym_t;

a3410 2
#include "reentr.inc"

d3492 1
a3492 1
EXT MGVTBL PL_vtbl_regexp = {0, MEMBER_TO_FPTR(Perl_magic_setregexp),0,0, MEMBER_TO_FPTR(Perl_magic_freeregexp)};
a3513 4
EXT MGVTBL PL_vtbl_utf8 = {0,
				MEMBER_TO_FPTR(Perl_magic_setutf8),
					0,	0,	0};

a3555 1
EXT MGVTBL PL_vtbl_utf8;
d3749 1
a3749 1
	(IN_PERL_COMPILETIME ? IN_LOCALE_COMPILETIME : IN_LOCALE_RUNTIME)
a3830 3
#if !defined(Strtoul) && defined(HAS_STRTOL) /* Last resort. */
#   define Strtoul(s, e, b)	strchr((s), '-') ? ULONG_MAX : (unsigned long)strtol((s), (e), (b))
#endif
d3835 11
d3884 5
a3888 3
#	ifndef PERL_ASYNC_CHECK
#		define PERL_ASYNC_CHECK() if (PL_sig_pending) despatch_signals()
#	endif
a4038 4
#ifdef __Lynx__
#  include <fcntl.h>
#endif

d4066 1
a4066 1
#   if defined(__BEOS__) || defined(__VOS__) || defined(__CYGWIN__)
a4146 1
#define PERL_SCAN_SILENT_ILLDIGIT     0x04 /* grok_??? not warn about illegal digits */
a4181 86
#ifndef PIPESOCK_MODE
#  define PIPESOCK_MODE
#endif

#ifndef SOCKET_OPEN_MODE
#  define SOCKET_OPEN_MODE	PIPESOCK_MODE
#endif

#ifndef PIPE_OPEN_MODE
#  define PIPE_OPEN_MODE	PIPESOCK_MODE
#endif

#define PERL_MAGIC_UTF8_CACHESIZE	2

#define PERL_UNICODE_STDIN_FLAG			0x0001
#define PERL_UNICODE_STDOUT_FLAG		0x0002
#define PERL_UNICODE_STDERR_FLAG		0x0004
#define PERL_UNICODE_IN_FLAG			0x0008
#define PERL_UNICODE_OUT_FLAG			0x0010
#define PERL_UNICODE_ARGV_FLAG			0x0020
#define PERL_UNICODE_LOCALE_FLAG		0x0040
#define PERL_UNICODE_WIDESYSCALLS_FLAG		0x0080 /* for Sarathy */

#define PERL_UNICODE_STD_FLAG		\
	(PERL_UNICODE_STDIN_FLAG	| \
	 PERL_UNICODE_STDOUT_FLAG	| \
	 PERL_UNICODE_STDERR_FLAG)

#define PERL_UNICODE_INOUT_FLAG		\
	(PERL_UNICODE_IN_FLAG	| \
	 PERL_UNICODE_OUT_FLAG)

#define PERL_UNICODE_DEFAULT_FLAGS	\
	(PERL_UNICODE_STD_FLAG		| \
	 PERL_UNICODE_INOUT_FLAG	| \
	 PERL_UNICODE_LOCALE_FLAG)

#define PERL_UNICODE_ALL_FLAGS			0x00ff

#define PERL_UNICODE_STDIN			'I'
#define PERL_UNICODE_STDOUT			'O'
#define PERL_UNICODE_STDERR			'E'
#define PERL_UNICODE_STD			'S'
#define PERL_UNICODE_IN				'i'
#define PERL_UNICODE_OUT			'o'
#define PERL_UNICODE_INOUT			'D'
#define PERL_UNICODE_ARGV			'A'
#define PERL_UNICODE_LOCALE			'L'
#define PERL_UNICODE_WIDESYSCALLS		'W'

#define PERL_SIGNALS_UNSAFE_FLAG	0x0001

/* From sigaction(2) (FreeBSD man page):
 * | Signal routines normally execute with the signal that
 * | caused their invocation blocked, but other signals may
 * | yet occur.
 * Emulation of this behavior (from within Perl) is enabled
 * by defining PERL_BLOCK_SIGNALS.
 */
#define PERL_BLOCK_SIGNALS

#if defined(HAS_SIGPROCMASK) && defined(PERL_BLOCK_SIGNALS)
#   define PERL_BLOCKSIG_ADD(set,sig) \
	sigset_t set; sigemptyset(&(set)); sigaddset(&(set), sig)
#   define PERL_BLOCKSIG_BLOCK(set) \
	sigprocmask(SIG_BLOCK, &(set), NULL)
#   define PERL_BLOCKSIG_UNBLOCK(set) \
	sigprocmask(SIG_UNBLOCK, &(set), NULL)
#endif /* HAS_SIGPROCMASK && PERL_BLOCK_SIGNALS */

/* How about the old style of sigblock()? */

#ifndef PERL_BLOCKSIG_ADD
#   define PERL_BLOCKSIG_ADD(set, sig)	NOOP
#endif
#ifndef PERL_BLOCKSIG_BLOCK
#   define PERL_BLOCKSIG_BLOCK(set)	NOOP
#endif
#ifndef PERL_BLOCKSIG_UNBLOCK
#   define PERL_BLOCKSIG_UNBLOCK(set)	NOOP
#endif

/* Use instead of abs() since abs() forces its argument to be an int,
 * but also beware since this evaluates its argument twice, so no x++. */
#define PERL_ABS(x) ((x) < 0 ? -(x) : (x))

d4209 1
a4210 1
   HAS_USLEEP
@


1.1.1.7
log
@perl 5.8.3 from CPAN
@
text
@a1320 1
#       define Perl_ceil ceill
a1390 1
#   define Perl_ceil ceil
@


1.1.1.8
log
@Import of stock perl 5.8.5
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, by Larry Wall and others
d1806 1
a3074 4
#ifdef PERL_MALLOC_WRAP
EXTCONST char PL_memory_wrap[]
  INIT("panic: memory wrap");
#endif
a4309 13
#if !defined(PERL_MOUNT_NOEXEC) && defined(MOUNT_NOEXEC)
#    define PERL_MOUNT_NOEXEC MOUNT_NOEXEC
#endif
#if !defined(PERL_MOUNT_NOEXEC) && defined(MNT_NOEXEC)
#    define PERL_MOUNT_NOEXEC MNT_NOEXEC
#endif
#if !defined(PERL_MOUNT_NOEXEC) && defined(MS_NOEXEC)
#   define PERL_MOUNT_NOEXEC MS_NOEXEC
#endif
#if !defined(PERL_MOUNT_NOEXEC) && defined(M_NOEXEC)
#   define PERL_MOUNT_NOEXEC M_NOEXEC
#endif

a4501 9

/* Source code compatibility cruft:
   PERL_XS_APIVERSION is not used, and has been superseded by inc_version_list
   It and PERL_PM_APIVERSION are retained for source compatibility in the
   5.8.x maintenance branch.
 */

#define PERL_XS_APIVERSION "5.8.3"
#define PERL_PM_APIVERSION "5.005"
@


1.1.1.9
log
@perl 5.8.6 from CPAN
@
text
@d538 1
a538 1
#define TOO_LATE_FOR_(ch,s)	Perl_croak(aTHX_ "\"-%c\" is on the #! line, it must also be used on the command line", (char)(ch), s)
a4190 7
/* Clones the per-interpreter data. */
#define MY_CXT_CLONE \
	dMY_CXT_SV;							\
	my_cxt_t *my_cxtp = (my_cxt_t*)SvPVX(newSV(sizeof(my_cxt_t)-1));\
	Copy(INT2PTR(my_cxt_t*, SvUV(my_cxt_sv)), my_cxtp, 1, my_cxt_t);\
	sv_setuv(my_cxt_sv, PTR2UV(my_cxtp))

a4209 1
#define MY_CXT_CLONE	NOOP
@


1.1.1.10
log
@perl 5.8.8 import
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006 by Larry Wall and others
d121 1
a121 1
#  define pTHX_1	2
a124 5
#  define pTHX_5	6
#  define pTHX_6	7
#  define pTHX_7	8
#  define pTHX_8	9
#  define pTHX_9	10
d148 2
a149 2
#if defined(SYMBIAN) && defined(__GNUC__)
#  ifdef __cplusplus
d154 2
a155 8
#endif

#ifndef PERL_UNUSED_DECL
#  ifdef HASATTRIBUTE_UNUSED
#    define PERL_UNUSED_DECL __attribute__unused__
#  else
#    define PERL_UNUSED_DECL
#  endif
d160 1
a160 1
 * but we cannot quite get rid of, such as "ax" in PPCODE+noargs xsubs
d162 1
a162 11
#ifndef PERL_UNUSED_ARG
#  ifdef lint
#    include <note.h>
#    define PERL_UNUSED_ARG(x) NOTE(ARGUNUSED(x))
#  else
#    define PERL_UNUSED_ARG(x) ((void)x)
#  endif
#endif
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(x) ((void)x)
#endif
a177 5
#  define pTHX_5	5
#  define pTHX_6	6
#  define pTHX_7	7
#  define pTHX_8	8
#  define pTHX_9	9
a219 12
/* Some platforms require marking function declarations
 * for them to be exportable.  Used in perlio.h, proto.h
 * is handled either by the makedef.pl or by defining the
 * PERL_CALLCONV to be something special.  See also the
 * definition of XS() in XSUB.h. */
#ifndef PERL_EXPORT_C
#  define PERL_EXPORT_C extern
#endif
#ifndef PERL_XS_EXPORT_C
#  define PERL_XS_EXPORT_C
#endif

d229 1
a229 3
#  if !defined(PERL_GCC_BRACE_GROUPS_FORBIDDEN)
#    define PERL_GCC_BRACE_GROUPS_FORBIDDEN
#  endif
d241 1
a241 1
#   define STMT_START	(void)(	/* gcc supports "({ STATEMENTS; })" */
a470 241
#ifdef PERL_CORE

/* macros for correct constant construction */
# if INTSIZE >= 2
#  define U16_CONST(x) ((U16)x##U)
# else
#  define U16_CONST(x) ((U16)x##UL)
# endif

# if INTSIZE >= 4
#  define U32_CONST(x) ((U32)x##U)
# else
#  define U32_CONST(x) ((U32)x##UL)
# endif

# ifdef HAS_QUAD
#  if INTSIZE >= 8
#   define U64_CONST(x) ((U64)x##U)
#  elif LONGSIZE >= 8
#   define U64_CONST(x) ((U64)x##UL)
#  elif QUADKIND == QUAD_IS_LONG_LONG
#   define U64_CONST(x) ((U64)x##ULL)
#  else /* best guess we can make */
#   define U64_CONST(x) ((U64)x##UL)
#  endif
# endif

/* byte-swapping functions for big-/little-endian conversion */
# define _swab_16_(x) ((U16)( \
         (((U16)(x) & U16_CONST(0x00ff)) << 8) | \
         (((U16)(x) & U16_CONST(0xff00)) >> 8) ))

# define _swab_32_(x) ((U32)( \
         (((U32)(x) & U32_CONST(0x000000ff)) << 24) | \
         (((U32)(x) & U32_CONST(0x0000ff00)) <<  8) | \
         (((U32)(x) & U32_CONST(0x00ff0000)) >>  8) | \
         (((U32)(x) & U32_CONST(0xff000000)) >> 24) ))

# ifdef HAS_QUAD
#  define _swab_64_(x) ((U64)( \
          (((U64)(x) & U64_CONST(0x00000000000000ff)) << 56) | \
          (((U64)(x) & U64_CONST(0x000000000000ff00)) << 40) | \
          (((U64)(x) & U64_CONST(0x0000000000ff0000)) << 24) | \
          (((U64)(x) & U64_CONST(0x00000000ff000000)) <<  8) | \
          (((U64)(x) & U64_CONST(0x000000ff00000000)) >>  8) | \
          (((U64)(x) & U64_CONST(0x0000ff0000000000)) >> 24) | \
          (((U64)(x) & U64_CONST(0x00ff000000000000)) >> 40) | \
          (((U64)(x) & U64_CONST(0xff00000000000000)) >> 56) ))
# endif

/*----------------------------------------------------------------------------*/
# if BYTEORDER == 0x1234 || BYTEORDER == 0x12345678  /*     little-endian     */
/*----------------------------------------------------------------------------*/
#  define my_htole16(x)		(x)
#  define my_letoh16(x)		(x)
#  define my_htole32(x)		(x)
#  define my_letoh32(x)		(x)
#  define my_htobe16(x)		_swab_16_(x)
#  define my_betoh16(x)		_swab_16_(x)
#  define my_htobe32(x)		_swab_32_(x)
#  define my_betoh32(x)		_swab_32_(x)
#  ifdef HAS_QUAD
#   define my_htole64(x)	(x)
#   define my_letoh64(x)	(x)
#   define my_htobe64(x)	_swab_64_(x)
#   define my_betoh64(x)	_swab_64_(x)
#  endif
#  define my_htoles(x)		(x)
#  define my_letohs(x)		(x)
#  define my_htolei(x)		(x)
#  define my_letohi(x)		(x)
#  define my_htolel(x)		(x)
#  define my_letohl(x)		(x)
#  if SHORTSIZE == 1
#   define my_htobes(x)		(x)
#   define my_betohs(x)		(x)
#  elif SHORTSIZE == 2
#   define my_htobes(x)		_swab_16_(x)
#   define my_betohs(x)		_swab_16_(x)
#  elif SHORTSIZE == 4
#   define my_htobes(x)		_swab_32_(x)
#   define my_betohs(x)		_swab_32_(x)
#  elif SHORTSIZE == 8
#   define my_htobes(x)		_swab_64_(x)
#   define my_betohs(x)		_swab_64_(x)
#  else
#   define PERL_NEED_MY_HTOBES
#   define PERL_NEED_MY_BETOHS
#  endif
#  if INTSIZE == 1
#   define my_htobei(x)		(x)
#   define my_betohi(x)		(x)
#  elif INTSIZE == 2
#   define my_htobei(x)		_swab_16_(x)
#   define my_betohi(x)		_swab_16_(x)
#  elif INTSIZE == 4
#   define my_htobei(x)		_swab_32_(x)
#   define my_betohi(x)		_swab_32_(x)
#  elif INTSIZE == 8
#   define my_htobei(x)		_swab_64_(x)
#   define my_betohi(x)		_swab_64_(x)
#  else
#   define PERL_NEED_MY_HTOBEI
#   define PERL_NEED_MY_BETOHI
#  endif
#  if LONGSIZE == 1
#   define my_htobel(x)		(x)
#   define my_betohl(x)		(x)
#  elif LONGSIZE == 2
#   define my_htobel(x)		_swab_16_(x)
#   define my_betohl(x)		_swab_16_(x)
#  elif LONGSIZE == 4
#   define my_htobel(x)		_swab_32_(x)
#   define my_betohl(x)		_swab_32_(x)
#  elif LONGSIZE == 8
#   define my_htobel(x)		_swab_64_(x)
#   define my_betohl(x)		_swab_64_(x)
#  else
#   define PERL_NEED_MY_HTOBEL
#   define PERL_NEED_MY_BETOHL
#  endif
#  define my_htolen(p,n)	NOOP
#  define my_letohn(p,n)	NOOP
#  define my_htoben(p,n)	my_swabn(p,n)
#  define my_betohn(p,n)	my_swabn(p,n)
/*----------------------------------------------------------------------------*/
# elif BYTEORDER == 0x4321 || BYTEORDER == 0x87654321  /*     big-endian      */
/*----------------------------------------------------------------------------*/
#  define my_htobe16(x)		(x)
#  define my_betoh16(x)		(x)
#  define my_htobe32(x)		(x)
#  define my_betoh32(x)		(x)
#  define my_htole16(x)		_swab_16_(x)
#  define my_letoh16(x)		_swab_16_(x)
#  define my_htole32(x)		_swab_32_(x)
#  define my_letoh32(x)		_swab_32_(x)
#  ifdef HAS_QUAD
#   define my_htobe64(x)	(x)
#   define my_betoh64(x)	(x)
#   define my_htole64(x)	_swab_64_(x)
#   define my_letoh64(x)	_swab_64_(x)
#  endif
#  define my_htobes(x)		(x)
#  define my_betohs(x)		(x)
#  define my_htobei(x)		(x)
#  define my_betohi(x)		(x)
#  define my_htobel(x)		(x)
#  define my_betohl(x)		(x)
#  if SHORTSIZE == 1
#   define my_htoles(x)		(x)
#   define my_letohs(x)		(x)
#  elif SHORTSIZE == 2
#   define my_htoles(x)		_swab_16_(x)
#   define my_letohs(x)		_swab_16_(x)
#  elif SHORTSIZE == 4
#   define my_htoles(x)		_swab_32_(x)
#   define my_letohs(x)		_swab_32_(x)
#  elif SHORTSIZE == 8
#   define my_htoles(x)		_swab_64_(x)
#   define my_letohs(x)		_swab_64_(x)
#  else
#   define PERL_NEED_MY_HTOLES
#   define PERL_NEED_MY_LETOHS
#  endif
#  if INTSIZE == 1
#   define my_htolei(x)		(x)
#   define my_letohi(x)		(x)
#  elif INTSIZE == 2
#   define my_htolei(x)		_swab_16_(x)
#   define my_letohi(x)		_swab_16_(x)
#  elif INTSIZE == 4
#   define my_htolei(x)		_swab_32_(x)
#   define my_letohi(x)		_swab_32_(x)
#  elif INTSIZE == 8
#   define my_htolei(x)		_swab_64_(x)
#   define my_letohi(x)		_swab_64_(x)
#  else
#   define PERL_NEED_MY_HTOLEI
#   define PERL_NEED_MY_LETOHI
#  endif
#  if LONGSIZE == 1
#   define my_htolel(x)		(x)
#   define my_letohl(x)		(x)
#  elif LONGSIZE == 2
#   define my_htolel(x)		_swab_16_(x)
#   define my_letohl(x)		_swab_16_(x)
#  elif LONGSIZE == 4
#   define my_htolel(x)		_swab_32_(x)
#   define my_letohl(x)		_swab_32_(x)
#  elif LONGSIZE == 8
#   define my_htolel(x)		_swab_64_(x)
#   define my_letohl(x)		_swab_64_(x)
#  else
#   define PERL_NEED_MY_HTOLEL
#   define PERL_NEED_MY_LETOHL
#  endif
#  define my_htolen(p,n)	my_swabn(p,n)
#  define my_letohn(p,n)	my_swabn(p,n)
#  define my_htoben(p,n)	NOOP
#  define my_betohn(p,n)	NOOP
/*----------------------------------------------------------------------------*/
# else /*                       all other byte-orders                         */
/*----------------------------------------------------------------------------*/
#  define PERL_NEED_MY_HTOLE16
#  define PERL_NEED_MY_LETOH16
#  define PERL_NEED_MY_HTOBE16
#  define PERL_NEED_MY_BETOH16
#  define PERL_NEED_MY_HTOLE32
#  define PERL_NEED_MY_LETOH32
#  define PERL_NEED_MY_HTOBE32
#  define PERL_NEED_MY_BETOH32
#  ifdef HAS_QUAD
#   define PERL_NEED_MY_HTOLE64
#   define PERL_NEED_MY_LETOH64
#   define PERL_NEED_MY_HTOBE64
#   define PERL_NEED_MY_BETOH64
#  endif
#  define PERL_NEED_MY_HTOLES
#  define PERL_NEED_MY_LETOHS
#  define PERL_NEED_MY_HTOBES
#  define PERL_NEED_MY_BETOHS
#  define PERL_NEED_MY_HTOLEI
#  define PERL_NEED_MY_LETOHI
#  define PERL_NEED_MY_HTOBEI
#  define PERL_NEED_MY_BETOHI
#  define PERL_NEED_MY_HTOLEL
#  define PERL_NEED_MY_LETOHL
#  define PERL_NEED_MY_HTOBEL
#  define PERL_NEED_MY_BETOHL
/*----------------------------------------------------------------------------*/
# endif /*                     end of byte-order macros                       */
/*----------------------------------------------------------------------------*/

/* The old value was hard coded at 1008. (4096-16) seems to be a bit faster,
   at least on FreeBSD.  YMMV, so experiment.  */
#ifndef PERL_ARENA_SIZE
#define PERL_ARENA_SIZE 4080
#endif

#endif /* PERL_CORE */

a479 7
/* Round all values passed to malloc up, by default to a multiple of
   sizeof(size_t)
*/
#ifndef PERL_STRLEN_ROUNDUP_QUANTUM
#define PERL_STRLEN_ROUNDUP_QUANTUM Size_t_size
#endif

d538 1
a538 1
#define TOO_LATE_FOR_(ch,what)	Perl_croak(aTHX_ "\"-%c\" is on the #! line, it must also be used on the command line%s", (char)(ch), what)
a798 1
/* FIXME? Change the assignments to PL_defgv to instantiate GvSV?  */
d800 1
a800 1
#  define DEFSV GvSVn(PL_defgv)
a1129 7
#ifndef HAS_QUAD
# undef PERL_NEED_MY_HTOLE64
# undef PERL_NEED_MY_LETOH64
# undef PERL_NEED_MY_HTOBE64
# undef PERL_NEED_MY_BETOH64
#endif

a1157 1
#    define PTR2ul(p)		(unsigned long)(p)
a1160 3
#endif

#ifndef INT2PTR
a1162 5

#ifndef PTR2ul
#  define PTR2ul(p)	INT2PTR(unsigned long,p)	
#endif

d1167 5
a1171 14
#define PTR2nat(p)	(PTRV)(p)	/* pointer to integer of PTRSIZE */

/* According to strict ANSI C89 one cannot freely cast between
 * data pointers and function (code) pointers.  There are at least
 * two ways around this.  One (used below) is to do two casts,
 * first the other pointer to an (unsigned) integer, and then
 * the integer to the other pointer.  The other way would be
 * to use unions to "overlay" the pointers.  For an example of
 * the latter technique, see union dirpu in struct xpvio in sv.h.
 * The only feasible use is probably temporarily storing
 * function pointers in a data pointer (such as a void pointer). */

#define DPTR2FPTR(t,p) ((t)PTR2nat(p))	/* data pointer to function pointer */
#define FPTR2DPTR(t,p) ((t)PTR2nat(p))	/* function pointer to data pointer */
d1330 1
a1330 1
EXTERN_C long double modfl(long double, long double *);
a2035 35
/* In case Configure was not used (we are using a "canned config"
 * such as Win32, or a cross-compilation setup, for example) try going
 * by the gcc major and minor versions.  One useful URL is
 * http://www.ohse.de/uwe/articles/gcc-attributes.html,
 * but contrary to this information warn_unused_result seems
 * not to be in gcc 3.3.5, at least. --jhi
 * Set these up now otherwise we get confused when some of the <*thread.h>
 * includes below indirectly pull in <perlio.h> (which needs to know if we
 * have HASATTRIBUTE_FORMAT).
 */

#if defined __GNUC__
#  if __GNUC__ >= 3 /* 3.0 -> */ /* XXX Verify this version */
#    define HASATTRIBUTE_FORMAT
#  endif
#  if __GNUC__ >= 3 /* 3.0 -> */
#    define HASATTRIBUTE_MALLOC
#  endif
#  if __GNUC__ == 3 && __GNUC_MINOR__ >= 3 || __GNUC__ > 3 /* 3.3 -> */
#    define HASATTRIBUTE_NONNULL
#  endif
#  if __GNUC__ == 2 && __GNUC_MINOR__ >= 5 || __GNUC__ > 2 /* 2.5 -> */
#    define HASATTRIBUTE_NORETURN
#  endif
#  if __GNUC__ >= 3 /* gcc 3.0 -> */
#    define HASATTRIBUTE_PURE
#  endif
#  if __GNUC__ >= 3 /* gcc 3.0 -> */ /* XXX Verify this version */
#    define HASATTRIBUTE_UNUSED
#  endif
#  if __GNUC__ == 3 && __GNUC_MINOR__ >= 4 || __GNUC__ > 3 /* 3.4 -> */
#    define HASATTRIBUTE_WARN_UNUSED_RESULT
#  endif
#endif

d2199 4
a2202 1
#    define SVf "-p"
d2208 5
a2212 1
#ifndef SVf_precision
d2214 1
a2214 1
#    define SVf_precision(n) "-" n "p"
d2216 1
a2216 1
#    define SVf_precision(n) "." n "_"
d2222 1
a2222 1
#    define VDf "-1p"
d2228 5
a2232 15
#ifndef SVf32
#  define SVf32 SVf_precision("32")
#endif

#ifndef SVf256
#  define SVf256 SVf_precision("256")
#endif
 
#ifndef UVf
#  define UVf UVuf
#endif

#ifndef PERL_CORE
#  ifndef DieNull
#    define DieNull Perl_vdie(aTHX_ Nullch, Null(va_list *))
a2235 29
/* Because 5.8.x has to keep using %_ for SVf, which will make the format
 * checking code (quite correctly) bleat a lot.  */
#ifndef CHECK_FORMAT
#  undef HASATTRIBUTE_FORMAT
#endif

#ifdef HASATTRIBUTE_FORMAT
#  define __attribute__format__(x,y,z)      __attribute__((format(x,y,z)))
#endif
#ifdef HASATTRIBUTE_MALLOC
#  define __attribute__malloc__             __attribute__((__malloc__))
#endif
#ifdef HASATTRIBUTE_NONNULL
#  define __attribute__nonnull__(a)         __attribute__((nonnull(a)))
#endif
#ifdef HASATTRIBUTE_NORETURN
#  define __attribute__noreturn__           __attribute__((noreturn))
#endif
#ifdef HASATTRIBUTE_PURE
#  define __attribute__pure__               __attribute__((pure))
#endif
#ifdef HASATTRIBUTE_UNUSED
#  define __attribute__unused__             __attribute__((unused))
#endif
#ifdef HASATTRIBUTE_WARN_UNUSED_RESULT
#  define __attribute__warn_unused_result__ __attribute__((warn_unused_result))
#endif

/* If we haven't defined the attributes yet, define them to blank. */
d2237 5
a2241 1
#  define __attribute__format__(x,y,z)
d2243 1
a2243 28
#ifndef __attribute__malloc__
#  define __attribute__malloc__
#endif
#ifndef __attribute__nonnull__
#  define __attribute__nonnull__(a)
#endif
#ifndef __attribute__noreturn__
#  define __attribute__noreturn__
#endif
#ifndef __attribute__pure__
#  define __attribute__pure__
#endif
#ifndef __attribute__unused__
#  define __attribute__unused__
#endif
#ifndef __attribute__warn_unused_result__
#  define __attribute__warn_unused_result__
#endif

/* For functions that are marked as __attribute__noreturn__, it's not
   appropriate to call return.  In either case, include the lint directive.
 */
#ifdef HASATTRIBUTE_NORETURN
#  define NORETURN_FUNCTION_END /* NOT REACHED */
#else
#  define NORETURN_FUNCTION_END /* NOT REACHED */ return 0
#endif

d2256 1
a2256 1
	/* on BSDish systems we're safe */
a2258 4
#	if defined(_IOC_SIZE) && defined(__GLIBC__)
	/* on Linux systems we're safe; except when we're not [perl #38223] */
#	    define IOCPARM_LEN(x) (_IOC_SIZE(x) < 256 ? 256 : _IOC_SIZE(x))
#	else
d2260 1
a2260 2
#	    define IOCPARM_LEN(x)	256
#	endif
d2386 1
a2386 1
    const void*			oldval;
d2711 1
a2711 1
		    where, (long)PL_scopestack_ix, __FILE__, __LINE__)));
d2770 15
a2784 6
#define assert(what)	PERL_DEB( 					\
	((what) ? ((void) 0) :						\
	    (Perl_croak(aTHX_ "Assertion %s failed: file \"" __FILE__ 	\
			"\", line %d", STRINGIFY(what), __LINE__),	\
	    PerlProc_exit(1),						\
	    (void) 0)))
a3057 2
EXTCONST char PL_no_helem_sv[]
  INIT("Modification of non-creatable hash value attempted, subscript \""SVf"\"");
d3074 1
d3077 1
d3084 1
a3084 1
EXT const char *PL_sig_name[] = { SIG_NAME };
d3087 1
a3087 1
EXT const char *PL_sig_name[];
d3417 1
a3417 3
#define PERL_DEBUG_PAD_ZERO(i)	(SvPVX(PERL_DEBUG_PAD(i))[0] = 0, \
	(((XPV*) SvANY(PERL_DEBUG_PAD(i)))->xpv_cur = 0), \
	PERL_DEBUG_PAD(i))
d3529 1
a3529 1
  I32      code;     /* template code (!<>)   */
a3533 1
                     /*   and group modifiers */
d3542 10
d3554 2
a3555 2
#define PERL_CKDEF(s)	PERL_CALLCONV OP *s (pTHX_ OP *o);
#define PERL_PPDEF(s)	PERL_CALLCONV OP *s (pTHX);
d3794 1
a3794 1
#define AMG_id2name(id) (PL_AMG_names[id]+1)
d4091 20
a4478 4

#if defined(__DECC) && defined(__osf__)
#pragma message disable (mainparm) /* Perl uses the envp in main(). */
#endif
@


1.1.1.11
log
@import perl 5.10.0 from CPAN
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, by Larry Wall and others
d37 5
a41 5
#   ifndef USE_CROSS_COMPILE
#       include "config.h"
#   else
#       include "xconfig.h"
#   endif
d66 3
a68 3
#ifdef PERL_GLOBAL_STRUCT_PRIVATE
#  ifndef PERL_GLOBAL_STRUCT
#    define PERL_GLOBAL_STRUCT
d72 1
a72 7
#ifdef PERL_GLOBAL_STRUCT
#  ifndef MULTIPLICITY
#    define MULTIPLICITY
#  endif
#endif

#ifdef MULTIPLICITY
d84 1
a84 22
#if defined(__SYMBIAN32__) || (defined(__VC32__) && defined(WINS))
#   ifndef SYMBIAN
#       define SYMBIAN
#   endif
#endif

#ifdef __SYMBIAN32__
#  include "symbian/symbian_proto.h"
#endif

/* Any stack-challenged places.  The limit varies (and often
 * is configurable), but using more than a kilobyte of stack
 * is usually dubious in these systems. */
#if defined(EPOC) || defined(__SYMBIAN32__)
/* EPOC/Symbian: need to work around the SDK features. *
 * On WINS: MS VC5 generates calls to _chkstk,         *
 * if a "large" stack frame is allocated.              *
 * gcc on MARM does not generate calls like these.     */
#   define USE_HEAP_INSTEAD_OF_STACK
#endif

#/* Use the reentrant APIs like localtime_r and getpwent_r */
a102 22
#ifdef PERL_GLOBAL_STRUCT
#  ifndef PERL_GET_VARS
#    ifdef PERL_GLOBAL_STRUCT_PRIVATE
       extern struct perl_vars* Perl_GetVarsPrivate();
#      define PERL_GET_VARS() Perl_GetVarsPrivate() /* see miniperlmain.c */
#      ifndef PERLIO_FUNCS_CONST
#        define PERLIO_FUNCS_CONST /* Can't have these lying around. */
#      endif
#    else
#      define PERL_GET_VARS() PL_VarsPtr
#    endif
#  endif
#endif

#define pVAR    register struct perl_vars* my_vars PERL_UNUSED_DECL

#ifdef PERL_GLOBAL_STRUCT
#  define dVAR		pVAR    = (struct perl_vars*)PERL_GET_VARS()
#else
#  define dVAR		dNOOP
#endif

d104 6
a109 8
#  ifndef MULTIPLICITY
#    define MULTIPLICITY
#  endif
#  define tTHX	PerlInterpreter*
#  define pTHX  register tTHX my_perl PERL_UNUSED_DECL
#  define aTHX	my_perl
#  ifdef PERL_GLOBAL_STRUCT
#    define dTHXa(a)	dVAR; pTHX = (tTHX)a
d111 6
a116 6
#    define dTHXa(a)	pTHX = (tTHX)a
#  endif
#  ifdef PERL_GLOBAL_STRUCT
#    define dTHX		dVAR; pTHX = PERL_GET_THX
#  else
#    define dTHX		pTHX = PERL_GET_THX
d118 1
a129 5
#  if defined(DEBUGGING) && !defined(PERL_TRACK_MEMPOOL)
#    define PERL_TRACK_MEMPOOL
#  endif
#else
#  undef PERL_TRACK_MEMPOOL
d143 5
d149 2
a150 72
#define CALLREGCOMP(sv, flags) Perl_pregcomp(aTHX_ (sv),(flags))

#define CALLREGCOMP_ENG(prog, sv, flags) \
    CALL_FPTR(((prog)->comp))(aTHX_ sv, flags)
#define CALLREGEXEC(prog,stringarg,strend,strbeg,minend,screamer,data,flags) \
    CALL_FPTR((prog)->engine->exec)(aTHX_ (prog),(stringarg),(strend), \
        (strbeg),(minend),(screamer),(data),(flags))
#define CALLREG_INTUIT_START(prog,sv,strpos,strend,flags,data) \
    CALL_FPTR((prog)->engine->intuit)(aTHX_ (prog), (sv), (strpos), \
        (strend),(flags),(data))
#define CALLREG_INTUIT_STRING(prog) \
    CALL_FPTR((prog)->engine->checkstr)(aTHX_ (prog))

#define CALLREG_AS_STR(mg,lp,flags,haseval) \
        Perl_reg_stringify(aTHX_ (mg), (lp), (flags), (haseval))
#define CALLREG_STRINGIFY(mg,lp,flags) CALLREG_AS_STR(mg,lp,flags,0)

#define CALLREGFREE(prog) \
    Perl_pregfree(aTHX_ (prog))

#define CALLREGFREE_PVT(prog) \
    if(prog) CALL_FPTR((prog)->engine->free)(aTHX_ (prog))

#define CALLREG_NUMBUF_FETCH(rx,paren,usesv)                                \
    CALL_FPTR((rx)->engine->numbered_buff_FETCH)(aTHX_ (rx),(paren),(usesv))

#define CALLREG_NUMBUF_STORE(rx,paren,value) \
    CALL_FPTR((rx)->engine->numbered_buff_STORE)(aTHX_ (rx),(paren),(value))

#define CALLREG_NUMBUF_LENGTH(rx,sv,paren)                              \
    CALL_FPTR((rx)->engine->numbered_buff_LENGTH)(aTHX_ (rx),(sv),(paren))

#define CALLREG_NAMED_BUFF_FETCH(rx, key, flags) \
    CALL_FPTR((rx)->engine->named_buff)(aTHX_ (rx), (key), NULL, ((flags) | RXapif_FETCH))

#define CALLREG_NAMED_BUFF_STORE(rx, key, value, flags) \
    CALL_FPTR((rx)->engine->named_buff)(aTHX_ (rx), (key), (value), ((flags) | RXapif_STORE))

#define CALLREG_NAMED_BUFF_DELETE(rx, key, flags) \
    CALL_FPTR((rx)->engine->named_buff)(aTHX_ (rx),(key), NULL, ((flags) | RXapif_DELETE))

#define CALLREG_NAMED_BUFF_CLEAR(rx, flags) \
    CALL_FPTR((rx)->engine->named_buff)(aTHX_ (rx), NULL, NULL, ((flags) | RXapif_CLEAR))

#define CALLREG_NAMED_BUFF_EXISTS(rx, key, flags) \
    CALL_FPTR((rx)->engine->named_buff)(aTHX_ (rx), (key), NULL, ((flags) | RXapif_EXISTS))

#define CALLREG_NAMED_BUFF_FIRSTKEY(rx, flags) \
    CALL_FPTR((rx)->engine->named_buff_iter)(aTHX_ (rx), NULL, ((flags) | RXapif_FIRSTKEY))

#define CALLREG_NAMED_BUFF_NEXTKEY(rx, lastkey, flags) \
    CALL_FPTR((rx)->engine->named_buff_iter)(aTHX_ (rx), (lastkey), ((flags) | RXapif_NEXTKEY))

#define CALLREG_NAMED_BUFF_SCALAR(rx, flags) \
    CALL_FPTR((rx)->engine->named_buff)(aTHX_ (rx), NULL, NULL, ((flags) | RXapif_SCALAR))

#define CALLREG_NAMED_BUFF_COUNT(rx) \
    CALL_FPTR((rx)->engine->named_buff)(aTHX_ (rx), NULL, NULL, RXapif_REGNAMES_COUNT)

#define CALLREG_NAMED_BUFF_ALL(rx, flags) \
    CALL_FPTR((rx)->engine->named_buff)(aTHX_ (rx), NULL, NULL, flags)

#define CALLREG_PACKAGE(rx) \
    CALL_FPTR((rx)->engine->qr_package)(aTHX_ (rx))

#if defined(USE_ITHREADS)         
#define CALLREGDUPE(prog,param) \
    Perl_re_dup(aTHX_ (prog),(param))

#define CALLREGDUPE_PVT(prog,param) \
    (prog ? CALL_FPTR((prog)->engine->dupe)(aTHX_ (prog),(param)) \
          : (REGEXP *)NULL) 
d153 1
a153 17




/*
 * Because of backward compatibility reasons the PERL_UNUSED_DECL
 * cannot be changed from postfix to PERL_UNUSED_DECL(x).  Sigh.
 *
 * Note that there are C compilers such as MetroWerks CodeWarrior
 * which do not have an "inlined" way (like the gcc __attribute__) of
 * marking unused variables (they need e.g. a #pragma) and therefore
 * cpp macros like PERL_UNUSED_DECL cannot work for this purpose, even
 * if it were PERL_UNUSED_DECL(x), which it cannot be (see above).
 *
 */

#if defined(__SYMBIAN32__) && defined(__GNUC__)
d162 1
a162 1
#  if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
d168 1
a168 1
 
d174 1
a174 1
#  if defined(lint) && defined(S_SPLINT_S) /* www.splint.org */
d185 2
a186 12
#ifdef USE_ITHREADS
#  define PERL_UNUSED_CONTEXT PERL_UNUSED_ARG(my_perl)
#else
#  define PERL_UNUSED_CONTEXT
#endif

#define NOOP /*EMPTY*/(void)0
#if !defined(HASATTRIBUTE_UNUSED) && defined(__cplusplus)
#define dNOOP /*EMPTY*/(void)0 /* Older g++ has no __attribute((unused))__ */
#else
#define dNOOP extern int /*@@unused@@*/ Perl___notused PERL_UNUSED_DECL
#endif
a188 3
/* Don't bother defining tTHX and sTHX; using them outside
 * code guarded by PERL_IMPLICIT_CONTEXT is an error.
 */
a205 4
#ifndef dVAR
#  define dVAR		dNOOP
#endif

d228 1
a228 5
#  ifdef PERL_GLOBAL_STRUCT_PRIVATE
#    define dTHXs		dVAR; dTHX
#  else
#    define dTHXs		dTHX
#  endif
d230 1
a230 5
#  ifdef PERL_GLOBAL_STRUCT_PRIVATE
#    define dTHXs		dVAR
#  else
#    define dTHXs		dNOOP
#  endif
d252 1
a252 5
#  ifdef __cplusplus
#    define PERL_EXPORT_C extern "C"
#  else
#    define PERL_EXPORT_C extern
#  endif
d255 1
a255 5
#  ifdef __cplusplus
#    define PERL_XS_EXPORT_C extern "C"
#  else
#    define PERL_XS_EXPORT_C
#  endif
d266 2
a267 5
/* gcc (-ansi) -pedantic doesn't allow gcc statement expressions,
 * g++ allows them but seems to have problems with them
 * (insane errors ensue). */
#if defined(PERL_GCC_PEDANTIC) || (defined(__GNUC__) && defined(__cplusplus))
#  ifndef PERL_GCC_BRACE_GROUPS_FORBIDDEN
a271 6
#if defined(__GNUC__) && !defined(PERL_GCC_BRACE_GROUPS_FORBIDDEN) && !defined(__cplusplus)
#  ifndef PERL_USE_GCC_BRACE_GROUPS
#    define PERL_USE_GCC_BRACE_GROUPS
#  endif
#endif

d280 1
a280 1
# ifdef PERL_USE_GCC_BRACE_GROUPS
d298 10
d336 1
a336 1
#if defined(__STDC__) || defined(_AIX) || defined(__stdc__) || defined(__cplusplus) || defined(EPOC) || defined(NETWARE) || defined(__SYMBIAN32__)
d340 1
a340 1
#if defined(__cplusplus) || defined(WIN32) || defined(__sgi) || defined(__EMX__) || defined(__DGUX) || defined(EPOC) || defined(__QNX__) || defined(NETWARE) || defined(PERL_MICRO)
d358 1
a358 1
#define TAINT_PROPER(s)	if (PL_tainting) { taint_proper(NULL, s); }
d413 2
a414 1
#if defined(USE_ITHREADS) && defined(PTHREAD_H_FIRST) && defined(I_PTHREAD)
a498 4
#ifdef __SYMBIAN32__
#   undef _SC_ARG_MAX /* Symbian has _SC_ARG_MAX but no sysconf() */
#endif

d500 1
a500 1
EXTERN_C int syscall(int, ...);
d504 1
a504 6
EXTERN_C int usleep(unsigned int);
#endif

/* Funky places that do not have socket stuff. */
#if defined(__LIBCATAMOUNT__)
#  define MYSWAP
a751 16
/* We no longer default to creating a new SV for GvSV.
   Do this before embed.  */
#ifndef PERL_CREATE_GVSV
#  ifndef PERL_DONT_CREATE_GVSV
#    define PERL_DONT_CREATE_GVSV
#  endif
#endif

#if !defined(HAS_WAITPID) && !defined(HAS_WAIT4) || defined(HAS_WAITPID_RUNTIME)
#define PERL_USES_PL_PIDSTATUS
#endif

#if !defined(OS2) && !defined(WIN32) && !defined(DJGPP) && !defined(EPOC) && !defined(__SYMBIAN32__) && !defined(MACOS_TRADITIONAL)
#define PERL_DEFAULT_DO_EXEC3_IMPLEMENTATION
#endif

a756 4
#  ifndef PERL_MAD
#    undef op_getmad
#    define op_getmad(arg,pegop,slot) NOOP
#  endif
d775 4
a778 6
#ifndef __SYMBIAN32__
#  if defined(I_STRING) || defined(__cplusplus)
#     include <string.h>
#  else
#     include <strings.h>
#  endif
d1003 4
d1008 7
a1043 20
#if defined(__osf__) && defined(__cplusplus) && !defined(_XOPEN_SOURCE_EXTENDED) /* Tru64 "cxx" (C++), see hints/dec_osf.sh for why the _XOPEN_SOURCE_EXTENDED cannot be defined. */
EXTERN_C int fchdir(int);
EXTERN_C int flock(int, int);
EXTERN_C int fseeko(FILE *, off_t, int);
EXTERN_C off_t ftello(FILE *);
#endif

#if defined(__SUNPRO_CC) /* SUNWspro CC (C++) */
EXTERN_C char *crypt(const char *, const char *);
EXTERN_C char **environ;
#endif

#if defined(__cplusplus)
#  if defined(__OpenBSD__) || defined(__FreeBSD__) || defined(__NetBSD__)
EXTERN_C char **environ;
#  elif defined(__CYGWIN__)
EXTERN_C char *crypt(const char *, const char *);
#endif
#endif

d1082 5
a1086 1
#define ERRSV GvSV(PL_errgv)
d1088 4
a1091 2
#define DEFSV GvSVn(PL_defgv)
#define SAVE_DEFSV SAVESPTR(GvSV(PL_defgv))
a1353 62
/* For the times when you want the return value of sprintf, and you want it
   to be the length. Can't have a thread variable passed in, because C89 has
   no varargs macros.
*/
#ifdef SPRINTF_RETURNS_STRLEN
#  define my_sprintf sprintf
#else
#  define my_sprintf Perl_my_sprintf
#endif

/*
 * If we have v?snprintf() and the C99 variadic macros, we can just
 * use just the v?snprintf().  It is nice to try to trap the buffer
 * overflow, however, so if we are DEBUGGING, and we cannot use the
 * gcc statement expressions, then use the function wrappers which try
 * to trap the overflow.  If we can use the gcc statement expressions,
 * we can try that even with the version that uses the C99 variadic
 * macros.
 */

/* Note that we do not check against snprintf()/vsnprintf() returning
 * negative values because that is non-standard behaviour and we use
 * snprintf/vsnprintf only iff HAS_VSNPRINTF has been defined, and
 * that should be true only if the snprintf()/vsnprintf() are true
 * to the standard. */

#if defined(HAS_SNPRINTF) && defined(HAS_C99_VARIADIC_MACROS) && !(defined(DEBUGGING) && !defined(PERL_USE_GCC_BRACE_GROUPS)) && !defined(PERL_GCC_PEDANTIC)
#  ifdef PERL_USE_GCC_BRACE_GROUPS
#      define my_snprintf(buffer, len, ...) ({ int __len__ = snprintf(buffer, len, __VA_ARGS__); if ((len) > 0 && (Size_t)__len__ >= (len)) Perl_croak_nocontext("panic: snprintf buffer overflow"); __len__; })
#      define PERL_MY_SNPRINTF_GUARDED
#  else
#    define my_snprintf(buffer, len, ...) snprintf(buffer, len, __VA_ARGS__)
#  endif
#else
#  define my_snprintf  Perl_my_snprintf
#  define PERL_MY_SNPRINTF_GUARDED
#endif

#if defined(HAS_VSNPRINTF) && defined(HAS_C99_VARIADIC_MACROS) && !(defined(DEBUGGING) && !defined(PERL_USE_GCC_BRACE_GROUPS)) && !defined(PERL_GCC_PEDANTIC)
#  ifdef PERL_USE_GCC_BRACE_GROUPS
#      define my_vsnprintf(buffer, len, ...) ({ int __len__ = vsnprintf(buffer, len, __VA_ARGS__); if ((len) > 0 && (Size_t)__len__ >= (len)) Perl_croak_nocontext("panic: vsnprintf buffer overflow"); __len__; })
#      define PERL_MY_VSNPRINTF_GUARDED
#  else
#    define my_vsnprintf(buffer, len, ...) vsnprintf(buffer, len, __VA_ARGS__)
#  endif
#else
#  define my_vsnprintf Perl_my_vsnprintf
#  define PERL_MY_VSNPRINTF_GUARDED
#endif

#ifdef HAS_STRLCAT
#  define my_strlcat    strlcat
#else
#  define my_strlcat    Perl_my_strlcat
#endif

#ifdef HAS_STRLCPY
#  define my_strlcpy	strlcpy
#else
#  define my_strlcpy	Perl_my_strlcpy
#endif

d1519 6
a2063 1
struct _reg_trie_data;
a2066 5
#ifdef PERL_MAD
typedef struct token TOKEN;
typedef struct madprop MADPROP;
typedef struct nexttoken NEXTTOKE;
#endif
d2100 1
a2242 4
#  ifndef PERL_MAD
#    undef op_getmad
#    define op_getmad(arg,pegop,slot) NOOP
#  endif
a2269 10
#ifdef __SYMBIAN32__
#   include "symbian/symbianish.h"
#   include "embed.h"
#  ifndef PERL_MAD
#    undef op_getmad
#    define op_getmad(arg,pegop,slot) NOOP
#  endif
#   define ISHISH "symbian"
#endif

a2287 58
/* NSIG logic from Configure --> */
/* Strange style to avoid deeply-nested #if/#else/#endif */
#ifndef NSIG
#  ifdef _NSIG
#    define NSIG (_NSIG)
#  endif
#endif

#ifndef NSIG
#  ifdef SIGMAX
#    define NSIG (SIGMAX+1)
#  endif
#endif

#ifndef NSIG
#  ifdef SIG_MAX
#    define NSIG (SIG_MAX+1)
#  endif
#endif

#ifndef NSIG
#  ifdef _SIG_MAX
#    define NSIG (_SIG_MAX+1)
#  endif
#endif

#ifndef NSIG
#  ifdef MAXSIG
#    define NSIG (MAXSIG+1)
#  endif
#endif

#ifndef NSIG
#  ifdef MAX_SIG
#    define NSIG (MAX_SIG+1)
#  endif
#endif

#ifndef NSIG
#  ifdef SIGARRAYSIZE
#    define NSIG SIGARRAYSIZE /* Assume ary[SIGARRAYSIZE] */
#  endif
#endif

#ifndef NSIG
#  ifdef _sys_nsig
#    define NSIG (_sys_nsig) /* Solaris 2.5 */
#  endif
#endif

/* Default to some arbitrary number that's big enough to get most
   of the common signals.
*/
#ifndef NSIG
#    define NSIG 50
#endif
/* <-- NSIG logic from Configure */

d2300 1
a2300 1
#    define PERL_FPU_INIT fpsetmask(0)
d2303 1
a2303 1
#      define PERL_FPU_INIT       PL_sigfpe_saved = (Sighandler_t) signal(SIGFPE, SIG_IGN)
d2317 2
a2318 2
#ifndef PERL_SYS_INIT3_BODY
#  define PERL_SYS_INIT3_BODY(argvp,argcp,envp) PERL_SYS_INIT_BODY(argvp,argcp)
a2320 4
#define PERL_SYS_INIT(argc, argv)	Perl_sys_init(argc, argv)
#define PERL_SYS_INIT3(argc, argv, env)	Perl_sys_init3(argc, argv, env)
#define PERL_SYS_TERM()			Perl_sys_term()

a2355 3
 * Also, when building extensions with an installed perl, this allows
 * the user to upgrade gcc and get the right attributes, rather than
 * relying on the list generated at Configure time.  --AD
d2361 1
a2361 2
#ifndef PERL_MICRO
#if defined __GNUC__ && !defined(__INTEL_COMPILER)
a2363 3
#    if defined __MINGW32__
#      define PRINTF_FORMAT_NULL_OK
#    endif
d2377 1
a2377 1
#  if __GNUC__ == 3 && __GNUC_MINOR__ >= 4 || __GNUC__ > 3 /* 3.4 -> */
a2379 3
#  if __GNUC__ == 3 && __GNUC_MINOR__ == 3 && !defined(__cplusplus)
#    define HASATTRIBUTE_UNUSED /* gcc-3.3, but not g++-3.3. */
#  endif
a2383 1
#endif /* #ifndef PERL_MICRO */ 
d2385 2
a2386 1
/* USE_5005THREADS needs to be after unixish.h as <pthread.h> includes
d2392 6
a2397 1
#if defined(USE_ITHREADS)
d2432 1
a2432 1
#endif /* USE_ITHREADS */
a2441 1
#define STATUS_UNIX	PL_statusvalue
d2444 3
a2446 47
/*
 * vaxc$errno is only guaranteed to be valid if errno == EVMSERR, otherwise
 * its contents can not be trusted.  Unfortunately, Perl seems to check
 * it on exit, so it when PL_statusvalue_vms is updated, vaxc$errno should
 * be updated also.
 */
#  include <stsdef.h>
#  include <ssdef.h>
/* Presume this because if VMS changes it, it will require a new
 * set of APIs for waiting on children for binary compatibility.
 */
#  define child_offset_bits (8)
#  ifndef C_FAC_POSIX
#  define C_FAC_POSIX 0x35A000
#  endif

/*  STATUS_EXIT - validates and returns a NATIVE exit status code for the
 * platform from the existing UNIX or Native status values.
 */

#   define STATUS_EXIT \
	(((I32)PL_statusvalue_vms == -1 ? SS$_ABORT : PL_statusvalue_vms) | \
	   (VMSISH_HUSHED ? STS$M_INHIB_MSG : 0))


/* STATUS_NATIVE_CHILD_SET - Calculate UNIX status that matches the child
 * exit code and shifts the UNIX value over the correct number of bits to
 * be a child status.  Usually the number of bits is 8, but that could be
 * platform dependent.  The NATIVE status code is presumed to have either
 * from a child process.
 */

/* This is complicated.  The child processes return a true native VMS
   status which must be saved.  But there is an assumption in Perl that
   the UNIX child status has some relationship to errno values, so
   Perl tries to translate it to text in some of the tests.  
   In order to get the string translation correct, for the error, errno
   must be EVMSERR, but that generates a different text message
   than what the test programs are expecting.  So an errno value must
   be derived from the native status value when an error occurs.
   That will hide the true native status message.  With this version of
   perl, the true native child status can always be retrieved so that
   is not a problem.  But in this case, Pl_statusvalue and errno may
   have different values in them.
 */

#   define STATUS_NATIVE_CHILD_SET(n) \
d2448 2
a2449 7
	    I32 evalue = (I32)n;					\
	    if (evalue == EVMSERR) {					\
	      PL_statusvalue_vms = vaxc$errno;				\
	      PL_statusvalue = evalue;					\
	    } else {							\
	      PL_statusvalue_vms = evalue;				\
	      if (evalue == -1) {					\
d2451 6
a2456 9
		PL_statusvalue_vms = SS$_ABORT; /* Should not happen */ \
	      } else							\
		PL_statusvalue = Perl_vms_status_to_unix(evalue, 1);	\
	      set_vaxc_errno(evalue);					\
	      if ((PL_statusvalue_vms & C_FAC_POSIX) == C_FAC_POSIX)	\
		  set_errno(EVMSERR);					\
	      else set_errno(Perl_vms_status_to_unix(evalue, 0));	\
	      PL_statusvalue = PL_statusvalue << child_offset_bits;	\
	    }								\
d2458 1
a2458 1

d2460 1
a2460 1
#	define STATUS_CURRENT	(VMSISH_STATUS ? STATUS_NATIVE : STATUS_UNIX)
d2462 1
a2462 1
#	define STATUS_CURRENT	STATUS_UNIX
d2464 1
a2464 8

  /* STATUS_UNIX_SET - takes a UNIX/POSIX errno value and attempts to update
   * the NATIVE status to an equivalent value.  Can not be used to translate
   * exit code values as exit code values are not guaranteed to have any
   * relationship at all to errno values.
   * This is used when Perl is forcing errno to have a specific value.
   */
#   define STATUS_UNIX_SET(n)				\
d2466 1
a2466 2
	    I32 evalue = (I32)n;			\
	    PL_statusvalue = evalue;			\
d2468 2
a2469 9
		if (PL_statusvalue != EVMSERR) {	\
		  PL_statusvalue &= 0xFFFF;		\
		  if (MY_POSIX_EXIT)			\
		    PL_statusvalue_vms=PL_statusvalue ? SS$_ABORT : SS$_NORMAL;\
		  else PL_statusvalue_vms = Perl_unix_status_to_vms(evalue); \
		}					\
		else {					\
		  PL_statusvalue_vms = vaxc$errno;	\
		}					\
d2471 1
a2471 2
	    else PL_statusvalue_vms = SS$_ABORT;	\
	    set_vaxc_errno(PL_statusvalue_vms);		\
d2473 8
a2480 121

  /* STATUS_UNIX_EXIT_SET - Takes a UNIX/POSIX exit code and sets
   * the NATIVE error status based on it.  It does not assume that
   * the UNIX/POSIX exit codes have any relationship to errno, except
   * that 0 indicates a success.  When in the default mode to comply
   * with the Perl VMS documentation, any other code sets the NATIVE
   * status to a failure code of SS$_ABORT.
   *
   * In the new POSIX EXIT mode, native status will be set so that the
   * actual exit code will can be retrieved by the calling program or
   * shell.
   *
   * If the exit code is not clearly a UNIX parent or child exit status,
   * it will be passed through as a VMS status.
   */

#   define STATUS_UNIX_EXIT_SET(n)			\
	STMT_START {					\
	    I32 evalue = (I32)n;			\
	    PL_statusvalue = evalue;			\
	    if (evalue != -1) {				\
	      if (evalue <= 0xFF00) {			\
		if (evalue > 0xFF)			\
		  evalue = (evalue >> child_offset_bits) & 0xFF; \
		if (evalue == 0)			\
		  PL_statusvalue_vms == SS$_NORMAL;	\
		else					\
		  if (MY_POSIX_EXIT)			\
		    PL_statusvalue_vms =	\
		       (C_FAC_POSIX | (evalue << 3 ) | (evalue == 1)? \
		        (STS$K_ERROR | STS$M_INHIB_MSG) : 1); \
		  else					\
		    PL_statusvalue_vms = SS$_ABORT; \
	      } else { /* forgive them Perl, for they have sinned */ \
		if (evalue != EVMSERR) PL_statusvalue_vms = evalue; \
		else PL_statusvalue_vms = vaxc$errno;		\
	        /* And obviously used a VMS status value instead of UNIX */ \
	        PL_statusvalue = EVMSERR;				\
	      }							\
	    }							\
	    else PL_statusvalue_vms = SS$_ABORT;		\
	    set_vaxc_errno(PL_statusvalue_vms);			\
	} STMT_END

  /* STATUS_EXIT_SET - Takes a NATIVE/UNIX/POSIX exit code
   * and sets the NATIVE error status based on it.  This special case
   * is needed to maintain compatibility with past VMS behavior.
   *
   * In the default mode on VMS, this number is passed through as
   * both the NATIVE and UNIX status.  Which makes it different
   * that the STATUS_UNIX_EXIT_SET.
   *
   * In the new POSIX EXIT mode, native status will be set so that the
   * actual exit code will can be retrieved by the calling program or
   * shell.
   *
   */

#   define STATUS_EXIT_SET(n)				\
	STMT_START {					\
	    I32 evalue = (I32)n;			\
	    PL_statusvalue = evalue;			\
	    if (MY_POSIX_EXIT)				\
		PL_statusvalue_vms =			\
		  (C_FAC_POSIX | (evalue << 3 ) | (evalue == 1)? \
		   (STS$K_ERROR | STS$M_INHIB_MSG) : 1); \
	    else					\
		PL_statusvalue_vms = evalue ? evalue : SS$_NORMAL; \
	    set_vaxc_errno(PL_statusvalue_vms);		\
	} STMT_END


 /* This macro forces a success status */
#   define STATUS_ALL_SUCCESS	\
	(PL_statusvalue = 0, PL_statusvalue_vms = SS$_NORMAL)

 /* This macro forces a failure status */
#   define STATUS_ALL_FAILURE	(PL_statusvalue = 1, \
     vaxc$errno = PL_statusvalue_vms = MY_POSIX_EXIT ? \
	(C_FAC_POSIX | (1 << 3) | STS$K_ERROR | STS$M_INHIB_MSG) : SS$_ABORT)

#else
#   define STATUS_NATIVE	PL_statusvalue_posix
#   if defined(WCOREDUMP)
#       define STATUS_NATIVE_CHILD_SET(n)                  \
            STMT_START {                                   \
                PL_statusvalue_posix = (n);                \
                if (PL_statusvalue_posix == -1)            \
                    PL_statusvalue = -1;                   \
                else {                                     \
                    PL_statusvalue =                       \
                        (WIFEXITED(PL_statusvalue_posix) ? (WEXITSTATUS(PL_statusvalue_posix) << 8) : 0) |  \
                        (WIFSIGNALED(PL_statusvalue_posix) ? (WTERMSIG(PL_statusvalue_posix) & 0x7F) : 0) | \
                        (WIFSIGNALED(PL_statusvalue_posix) && WCOREDUMP(PL_statusvalue_posix) ? 0x80 : 0);  \
                }                                          \
            } STMT_END
#   elif defined(WIFEXITED)
#       define STATUS_NATIVE_CHILD_SET(n)                  \
            STMT_START {                                   \
                PL_statusvalue_posix = (n);                \
                if (PL_statusvalue_posix == -1)            \
                    PL_statusvalue = -1;                   \
                else {                                     \
                    PL_statusvalue =                       \
                        (WIFEXITED(PL_statusvalue_posix) ? (WEXITSTATUS(PL_statusvalue_posix) << 8) : 0) |  \
                        (WIFSIGNALED(PL_statusvalue_posix) ? (WTERMSIG(PL_statusvalue_posix) & 0x7F) : 0);  \
                }                                          \
            } STMT_END
#   else
#       define STATUS_NATIVE_CHILD_SET(n)                  \
            STMT_START {                                   \
                PL_statusvalue_posix = (n);                \
                if (PL_statusvalue_posix == -1)            \
                    PL_statusvalue = -1;                   \
                else {                                     \
                    PL_statusvalue =                       \
                        PL_statusvalue_posix & 0xFFFF;     \
                }                                          \
            } STMT_END
#   endif
#   define STATUS_UNIX_SET(n)		\
d2486 3
a2488 6
#   define STATUS_UNIX_EXIT_SET(n) STATUS_UNIX_SET(n)
#   define STATUS_EXIT_SET(n) STATUS_UNIX_SET(n)
#   define STATUS_CURRENT STATUS_UNIX
#   define STATUS_EXIT STATUS_UNIX
#   define STATUS_ALL_SUCCESS	(PL_statusvalue = 0, PL_statusvalue_posix = 0)
#   define STATUS_ALL_FAILURE	(PL_statusvalue = 1, PL_statusvalue_posix = 1)
d2536 3
d2542 1
d2546 7
a2552 6
/* 
    This replaces the previous %_ "hack" by the "%p" hacks.
    All that is required is that the perl source does not
    use "%-p" or "%-<number>p" or "%<number>p" formats.  
    These formats will still work in perl code.   
    See comments in sv.c for futher details.
d2554 6
a2559 7
    Robin Barker 2005-07-14

    No longer use %1p for VDf = %vd.  RMB 2007-10-19 
*/

#ifndef SVf_
#  define SVf_(n) "-" STRINGIFY(n) "p"
d2562 6
a2567 2
#ifndef SVf
#  define SVf "-p"
d2571 1
a2571 1
#  define SVf32 SVf_(32)
d2575 5
a2579 1
#  define SVf256 SVf_(256)
d2582 3
a2584 8
#define SVfARG(p) ((void*)(p))

#ifdef PERL_CORE
/* not used; but needed for backward compatibilty with XS code? - RMB */ 
#  undef VDf
#else
#  ifndef VDf
#    define VDf "vd"
d2588 4
a2591 7
#ifdef PERL_CORE
/* not used; but needed for backward compatibilty with XS code? - RMB */ 
#  undef UVf
#else
#  ifndef UVf
#    define UVf UVuf
#  endif
d2643 1
a2643 8
#  define NORETURN_FUNCTION_END /* NOTREACHED */
#else
#  define NORETURN_FUNCTION_END /* NOTREACHED */ return 0
#endif

/* Some OS warn on NULL format to printf */
#ifdef PRINTF_FORMAT_NULL_OK
#  define __attribute__format__null_ok__(x,y,z)  __attribute__format__(x,y,z)
d2645 1
a2645 12
#  define __attribute__format__null_ok__(x,y,z)  
#endif

#ifdef HAS_BUILTIN_EXPECT
#  define EXPECT(expr,val)                  __builtin_expect(expr,val)
#else
#  define EXPECT(expr,val)                  (expr)
#endif
#define LIKELY(cond)                        EXPECT(cond,1)
#define UNLIKELY(cond)                      EXPECT(cond,0)
#ifdef HAS_BUILTIN_CHOOSE_EXPR
/* placeholder */
d2704 6
d2713 2
a2714 8
#define FILTER_DATA(idx) \
	    (PL_parser ? AvARRAY(PL_parser->rsfp_filters)[idx] : NULL)
#define FILTER_ISREADER(idx) \
	    (PL_parser && PL_parser->rsfp_filters \
		&& idx >= AvFILLp(PL_parser->rsfp_filters))
#define PERL_FILTER_EXISTS(i) \
	    (PL_parser && PL_parser->rsfp_filters \
		&& (i) <= av_len(PL_parser->rsfp_filters))
a2735 6
#ifdef __LIBCATAMOUNT__
#undef HAS_PASSWD  /* unixish.h but not unixish enough. */ 
#undef HAS_GROUP
#define FAKE_BIT_BUCKET
#endif

a2745 17
/* Win32 defines a type 'WORD' in windef.h. This conflicts with the enumerator
 * 'WORD' defined in perly.h. The yytokentype enum is only a debugging aid, so
 * it's not really needed.
 */
#if defined(WIN32)
#  define YYTOKENTYPE
#endif
#include "perly.h"

#ifdef PERL_MAD
struct nexttoken {
    YYSTYPE next_val;	/* value of next token, if any */
    I32 next_type;	/* type of next token */
    MADPROP *next_mad;	/* everything else about that token */
};
#endif

a2754 1
#include "hv.h"
d2757 1
d2763 13
d2779 2
a2780 2
    U8 super_state;	/* lexer state to save */
    U16 sub_inwhat;	/* "lex_inwhat" to use */
d2782 2
a2783 2
    char *super_bufptr;	/* PL_parser->bufptr that was */
    char *super_bufend;	/* PL_parser->bufend that was */
a2785 2
#include "parser.h"

d2791 2
a2792 3
/* Keep next first in this structure, because sv_free_arenas take
   advantage of this to share code between the pte arenas and the SV
   body arenas  */
a2915 4
#ifdef HAS_SIGNBIT
#  define Perl_signbit signbit
#endif

d2930 1
a2930 1
#if !(defined(UNDER_CE) || defined(SYMBIAN))
a2963 2
/* U is reserved for Unofficial, exploratory hacking */
#define DEBUG_U_FLAG		0x00001000 /*   4096 */
d2972 1
a2972 4
#define DEBUG_C_FLAG		0x00200000 /*2097152 */
#define DEBUG_A_FLAG		0x00400000 /*4194304 */
#define DEBUG_q_FLAG		0x00800000 /*8388608 */
#define DEBUG_MASK		0x00FFEFFF /* mask of all the standard flags */
a2989 1
#  define DEBUG_U_TEST_ (PL_debug & DEBUG_U_FLAG)
a2997 3
#  define DEBUG_C_TEST_ (PL_debug & DEBUG_C_FLAG)
#  define DEBUG_A_TEST_ (PL_debug & DEBUG_A_FLAG)
#  define DEBUG_q_TEST_ (PL_debug & DEBUG_q_FLAG)
d2999 1
a2999 1
#  define DEBUG_Uv_TEST_ (DEBUG_U_TEST_ && DEBUG_v_TEST_)
d3003 3
a3017 1
#  define DEBUG_U_TEST DEBUG_U_TEST_
d3020 1
a3026 5
#  define DEBUG_C_TEST DEBUG_C_TEST_
#  define DEBUG_A_TEST DEBUG_A_TEST_
#  define DEBUG_q_TEST DEBUG_q_TEST_
#  define DEBUG_Xv_TEST DEBUG_Xv_TEST_
#  define DEBUG_Uv_TEST DEBUG_Uv_TEST_
a3050 1
#ifndef PERL_EXT_RE_BUILD
a3051 3
#else
#  define DEBUG_r(a) STMT_START {a;} STMT_END
#endif /* PERL_EXT_RE_BUILD */
a3053 1
#  define DEBUG_U(a) DEBUG__(DEBUG_U_TEST, a)
d3056 1
a3057 2
#  define DEBUG_Xv(a) DEBUG__(DEBUG_Xv_TEST, a)
#  define DEBUG_Uv(a) DEBUG__(DEBUG_Uv_TEST, a)
d3059 5
a3063 1
#  define DEBUG_S(a)
a3067 3
#  define DEBUG_C(a) DEBUG__(DEBUG_C_TEST, a)
#  define DEBUG_A(a) DEBUG__(DEBUG_A_TEST, a)
#  define DEBUG_q(a) DEBUG__(DEBUG_q_TEST, a)
a3082 1
#  define DEBUG_U_TEST (0)
d3085 1
a3091 5
#  define DEBUG_C_TEST (0)
#  define DEBUG_A_TEST (0)
#  define DEBUG_q_TEST (0)
#  define DEBUG_Xv_TEST (0)
#  define DEBUG_Uv_TEST (0)
a3106 1
#  define DEBUG_U(a)
d3109 1
a3114 5
#  define DEBUG_C(a)
#  define DEBUG_A(a)
#  define DEBUG_q(a)
#  define DEBUG_Xv(a)
#  define DEBUG_Uv(a)
a3144 2
#define PERL_MAGIC_hints	  'H' /* %^H hash */
#define PERL_MAGIC_hintselem	  'h' /* %^H hash element */
d3150 1
d3163 1
a3164 1
#define PERL_MAGIC_vstring	  'V' /* SV was vstring literal */
d3169 1
a3172 3
#define PERL_MAGIC_symtab	  ':' /* extra data for symbol tables */
#define PERL_MAGIC_rhash	  '%' /* extra data for restricted hashes */
#define PERL_MAGIC_arylen_p	  '@@' /* to move arylen out of XPVAV */
d3176 2
d3181 1
a3181 1
	    (Perl_croak_nocontext("Assertion %s failed: file \"" __FILE__ \
d3183 1
a3330 2
/* Fixme on VMS.  This needs to be a run-time, not build time options */
/* Also rename() is affected by this */
d3333 1
a3333 1
I32 unlnk (pTHX_ const char*);
a3380 18
#ifdef USE_PERLIO
EXTERN_C void PerlIO_teardown();
# ifdef USE_ITHREADS
#  define PERLIO_INIT MUTEX_INIT(&PL_perlio_mutex)
#  define PERLIO_TERM 				\
	STMT_START {				\
		PerlIO_teardown();		\
		MUTEX_DESTROY(&PL_perlio_mutex);\
	} STMT_END
# else
#  define PERLIO_INIT
#  define PERLIO_TERM	PerlIO_teardown()
# endif
#else
#  define PERLIO_INIT
#  define PERLIO_TERM
#endif

a3402 28
#if defined(PERL_IMPLICIT_CONTEXT)

struct perl_memory_debug_header;
struct perl_memory_debug_header {
  tTHX	interpreter;
#  ifdef PERL_POISON
  MEM_SIZE size;
#  endif
  struct perl_memory_debug_header *prev;
  struct perl_memory_debug_header *next;
};

#  define sTHX	(sizeof(struct perl_memory_debug_header) + \
	(MEM_ALIGNBYTES - sizeof(struct perl_memory_debug_header) \
	 %MEM_ALIGNBYTES) % MEM_ALIGNBYTES)

#endif

#ifdef PERL_TRACK_MEMPOOL
#  define INIT_TRACK_MEMPOOL(header, interp)			\
	STMT_START {						\
		(header).interpreter = (interp);		\
		(header).prev = (header).next = &(header);	\
	} STMT_END
#  else
#  define INIT_TRACK_MEMPOOL(header, interp)
#endif

a3407 1
typedef bool (CPERLscope(*destroyable_proc_t)) (pTHX_ SV *sv);
d3441 1
a3441 1
  INIT("Use of uninitialized value%s%s%s");
a3451 2
EXTCONST char PL_no_symref_sv[]
  INIT("Can't use string (\"%" SVf32 "\") as %s ref while \"strict refs\" in use");
d3456 2
d3459 1
a3459 1
  INIT("Modification of non-creatable hash value attempted, subscript \"%"SVf"\"");
d3473 1
a3473 1
  INIT("\"%s\" variable %s can't be in a package");
a3478 6
#ifdef CSH
EXTCONST char PL_cshname[]
  INIT(CSH);
#  define PL_cshlen	(sizeof(CSH "") - 1)
#endif

d3482 1
d3484 5
a3488 9
EXTCONST char PL_uudmap[256] =
#include "uudmap.h"
;
EXTCONST char* const PL_sig_name[] = { SIG_NAME };
EXTCONST int         PL_sig_num[]  = { SIG_NUM };
#else
EXTCONST char PL_uudmap[256];
EXTCONST char* const PL_sig_name[];
EXTCONST int         PL_sig_num[];
d3495 1
a3495 1
EXTCONST unsigned char PL_fold[] = { /* fast EBCDIC case folding table */
a3568 1
#ifndef PERL_GLOBAL_STRUCT /* or perlvars.h */
d3570 1
a3570 1
EXT unsigned char PL_fold_locale[] = { /* Unfortunately not EXTCONST. */
d3605 1
a3605 1
EXT unsigned char PL_fold_locale[]; /* Unfortunately not EXTCONST. */
a3606 1
#endif /* !PERL_GLOBAL_STRUCT */
d3610 1
a3610 1
EXTCONST unsigned char PL_freq[] = {/* EBCDIC frequencies for mixed English/C */
d3686 1
a3686 1
EXTCONST char* const PL_block_type[] = {
a3692 3
	"FORMAT",
	"GIVEN",
	"WHEN"
a3698 105
/* These are all the compile time options that affect binary compatibility.
   Other compile time options that are binary compatible are in perl.c
   Both are combined for the output of perl -V
   However, this string will be embedded in any shared perl library, which will
   allow us add a comparison check in perlmain.c in the near future.  */
#ifdef DOINIT
EXTCONST char PL_bincompat_options[] =
#  ifdef DEBUG_LEAKING_SCALARS
			     " DEBUG_LEAKING_SCALARS"
#  endif
#  ifdef DEBUG_LEAKING_SCALARS_FORK_DUMP
			     " DEBUG_LEAKING_SCALARS_FORK_DUMP"
#  endif
#  ifdef FAKE_THREADS
			     " FAKE_THREADS"
#  endif
#  ifdef MULTIPLICITY
			     " MULTIPLICITY"
#  endif
#  ifdef MYMALLOC
			     " MYMALLOC"
#  endif
#  ifdef PERL_DEBUG_READONLY_OPS
			     " PERL_DEBUG_READONLY_OPS"
#  endif
#  ifdef PERL_GLOBAL_STRUCT
			     " PERL_GLOBAL_STRUCT"
#  endif
#  ifdef PERL_IMPLICIT_CONTEXT
			     " PERL_IMPLICIT_CONTEXT"
#  endif
#  ifdef PERL_IMPLICIT_SYS
			     " PERL_IMPLICIT_SYS"
#  endif
#  ifdef PERL_MAD
			     " PERL_MAD"
#  endif
#  ifdef PERL_NEED_APPCTX
			     " PERL_NEED_APPCTX"
#  endif
#  ifdef PERL_NEED_TIMESBASE
			     " PERL_NEED_TIMESBASE"
#  endif
#  ifdef PERL_OLD_COPY_ON_WRITE
			     " PERL_OLD_COPY_ON_WRITE"
#  endif
#  ifdef PERL_POISON
			     " PERL_POISON"
#  endif
#  ifdef PERL_TRACK_MEMPOOL
			     " PERL_TRACK_MEMPOOL"
#  endif
#  ifdef PERL_USES_PL_PIDSTATUS
			     " PERL_USES_PL_PIDSTATUS"
#  endif
#  ifdef PL_OP_SLAB_ALLOC
			     " PL_OP_SLAB_ALLOC"
#  endif
#  ifdef THREADS_HAVE_PIDS
			     " THREADS_HAVE_PIDS"
#  endif
#  ifdef USE_64_BIT_ALL
			     " USE_64_BIT_ALL"
#  endif
#  ifdef USE_64_BIT_INT
			     " USE_64_BIT_INT"
#  endif
#  ifdef USE_IEEE
			     " USE_IEEE"
#  endif
#  ifdef USE_ITHREADS
			     " USE_ITHREADS"
#  endif
#  ifdef USE_LARGE_FILES
			     " USE_LARGE_FILES"
#  endif
#  ifdef USE_LONG_DOUBLE
			     " USE_LONG_DOUBLE"
#  endif
#  ifdef USE_PERLIO
			     " USE_PERLIO"
#  endif
#  ifdef USE_REENTRANT_API
			     " USE_REENTRANT_API"
#  endif
#  ifdef USE_SFIO
			     " USE_SFIO"
#  endif
#  ifdef USE_SOCKS
			     " USE_SOCKS"
#  endif
#  ifdef VMS_DO_SOCKETS
			     " VMS_DO_SOCKETS"
#    ifdef DECCRTL_SOCKETS
			     " DECCRTL_SOCKETS"
#    endif
#  endif
#  ifdef VMS_WE_ARE_CASE_SENSITIVE
			     " VMS_SYMBOL_CASE_AS_IS"
#  endif
  "";
#else
EXTCONST char PL_bincompat_options[];
#endif

d3716 2
d3728 1
a3728 3
    XTERMBLOCK,
    XTERMORDORDOR /* evil hack */
    /* update exp_name[] in toke.c if adding to this enum */
d3758 3
d3764 1
a3764 4
    want_vtbl_utf8,
    want_vtbl_symtab,
    want_vtbl_arylen_p,
    want_vtbl_hintselem
d3767 3
a3769 4

/* Hints are now stored in a dedicated U32, so the bottom 8 bits are no longer
   special and there is no need for HINT_PRIVATE_MASK for COPs
   However, bitops store HINT_INTEGER in their op_private.  */
d3774 1
a3774 1
#define HINT_ARYBASE		0x00000010 /* $[ is non-zero */
a3788 2
#define HINT_LEXICAL_IO_IN	0x00040000 /* ${^OPEN} is set for input */
#define HINT_LEXICAL_IO_OUT	0x00080000 /* ${^OPEN} is set for output */
d3796 1
a3796 1
/* The following are stored in $^H{sort}, not in PL_hints */
d3830 1
a3830 1
						re_scream_pos_data *d);
a3832 1
typedef regexp*(CPERLscope(*regdupe_t)) (pTHX_ const regexp* r, CLONE_PARAMS *param);
a3846 4
#define PERLVARISC(var,init) const char var[sizeof(init)];

typedef OP* (CPERLscope(*Perl_ppaddr_t))(pTHX);
typedef OP* (CPERLscope(*Perl_check_t)) (pTHX_ OP*);
a3853 14
/* if you only have signal() and it resets on each signal, FAKE_PERSISTENT_SIGNAL_HANDLERS fixes */
/* These have to be before perlvars.h */
#if !defined(HAS_SIGACTION) && defined(VMS)
#  define  FAKE_PERSISTENT_SIGNAL_HANDLERS
#endif
/* if we're doing kill() with sys$sigprc on VMS, FAKE_DEFAULT_SIGNAL_HANDLERS */
#if defined(KILL_BY_SIGPRC)
#  define  FAKE_DEFAULT_SIGNAL_HANDLERS
#endif

#define PERL_PATCHLEVEL_H_IMPLICIT
#include "patchlevel.h"
#undef PERL_PATCHLEVEL_H_IMPLICIT

a3859 1
#    ifndef PERL_GLOBAL_STRUCT_PRIVATE
a3861 3
#      undef PERL_GET_VARS
#      define PERL_GET_VARS() PL_VarsPtr
#    endif /* !PERL_GLOBAL_STRUCT_PRIVATE */
d3880 3
d3884 5
d3897 16
a3917 1
#undef PERLVARISC
d3919 19
a3937 1
struct tempsym; /* defined in pp_pack.c */
d3943 1
a3943 5
#  ifdef __cplusplus
#    define PERL_CALLCONV extern "C"
#  else
#    define PERL_CALLCONV
#  endif
a3959 6
#ifndef PERL_MAD
#  undef PL_madskills
#  undef PL_xmlfp
#  define PL_madskills 0
#  define PL_xmlfp 0
#endif
a3969 1
#define PERLVARISC(var,init) EXTCONST char PL_##var[sizeof(init)] INIT(init);
d3974 3
a3982 4
#  ifndef PERL_MAD
#    undef op_getmad
#    define op_getmad(arg,pegop,slot) NOOP
#  endif
d3993 2
d4002 15
a4016 5
/* PERL_GLOBAL_STRUCT_PRIVATE wants to keep global data like the
 * magic vtables const, but this is incompatible with SWIG which
 * does want to modify the vtables. */
#ifdef PERL_GLOBAL_STRUCT_PRIVATE
#  define EXT_MGVTBL EXTCONST MGVTBL
d4018 120
a4137 1
#  define EXT_MGVTBL EXT MGVTBL
d4140 5
a4144 9
#ifdef DOINIT
#  define MGVTBL_SET(var,a,b,c,d,e,f,g,h) EXT_MGVTBL var = {a,b,c,d,e,f,g,h}
/* Like MGVTBL_SET but with the get magic having a const MG* */
#  define MGVTBL_SET_CONST_MAGIC_GET(var,a,b,c,d,e,f,g,h) EXT_MGVTBL var \
    = {(int (*)(pTHX_ SV *, MAGIC *))a,b,c,d,e,f,g,h}
#else
#  define MGVTBL_SET(var,a,b,c,d,e,f,g,h) EXT_MGVTBL var
#  define MGVTBL_SET_CONST_MAGIC_GET(var,a,b,c,d,e,f,g,h) EXT_MGVTBL var
#endif
d4146 39
a4184 53
/* These all need to be 0, not NULL, as NULL can be (void*)0, which is a
 * pointer to data, whereas we're assigning pointers to functions, which are
 * not the same beast. ANSI doesn't allow the assignment from one to the other.
 * (although most, but not all, compilers are prepared to do it)
 */
MGVTBL_SET(
    PL_vtbl_sv,
    MEMBER_TO_FPTR(Perl_magic_get),
    MEMBER_TO_FPTR(Perl_magic_set),
    MEMBER_TO_FPTR(Perl_magic_len),
    0,
    0,
    0,
    0,
    0
);

MGVTBL_SET(
    PL_vtbl_env,
    0,
    MEMBER_TO_FPTR(Perl_magic_set_all_env),
    0,
    MEMBER_TO_FPTR(Perl_magic_clear_all_env),
    0,
    0,
    0,
    0
);

MGVTBL_SET(
    PL_vtbl_envelem,
    0,
    MEMBER_TO_FPTR(Perl_magic_setenv),
    0,
    MEMBER_TO_FPTR(Perl_magic_clearenv),
    0,
    0,
    0,
    0
);

/* For now, hints magic will also use vtbl_sig, because it is all 0  */
MGVTBL_SET(
    PL_vtbl_sig,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
);
d4186 2
a4187 351
#ifdef PERL_MICRO
MGVTBL_SET(
    PL_vtbl_sigelem,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
);

#else
MGVTBL_SET(
    PL_vtbl_sigelem,
    MEMBER_TO_FPTR(Perl_magic_getsig),
    MEMBER_TO_FPTR(Perl_magic_setsig),
    0,
    MEMBER_TO_FPTR(Perl_magic_clearsig),
    0,
    0,
    0,
    0
);
#endif

MGVTBL_SET(
    PL_vtbl_pack,
    0,
    0,
    MEMBER_TO_FPTR(Perl_magic_sizepack),
    MEMBER_TO_FPTR(Perl_magic_wipepack),
    0,
    0,
    0,
    0
);

MGVTBL_SET(
    PL_vtbl_packelem,
    MEMBER_TO_FPTR(Perl_magic_getpack),
    MEMBER_TO_FPTR(Perl_magic_setpack),
    0,
    MEMBER_TO_FPTR(Perl_magic_clearpack),
    0,
    0,
    0,
    0
);

MGVTBL_SET(
    PL_vtbl_dbline,
    0,
    MEMBER_TO_FPTR(Perl_magic_setdbline),
    0,
    0,
    0,
    0,
    0,
    0
);

MGVTBL_SET(
    PL_vtbl_isa,
    0,
    MEMBER_TO_FPTR(Perl_magic_setisa),
    0,
    MEMBER_TO_FPTR(Perl_magic_setisa),
    0,
    0,
    0,
    0
);

MGVTBL_SET(
    PL_vtbl_isaelem,
    0,
    MEMBER_TO_FPTR(Perl_magic_setisa),
    0,
    0,
    0,
    0,
    0,
    0
);

MGVTBL_SET_CONST_MAGIC_GET(
    PL_vtbl_arylen,
    MEMBER_TO_FPTR(Perl_magic_getarylen),
    MEMBER_TO_FPTR(Perl_magic_setarylen),
    0,
    0,
    0,
    0,
    0,
    0
);

MGVTBL_SET(
    PL_vtbl_arylen_p,
    0,
    0,
    0,
    0,
    MEMBER_TO_FPTR(Perl_magic_freearylen_p),
    0,
    0,
    0
);

MGVTBL_SET(
    PL_vtbl_mglob,
    0,
    MEMBER_TO_FPTR(Perl_magic_setmglob),
    0,
    0,
    0,
    0,
    0,
    0
);

MGVTBL_SET(
    PL_vtbl_nkeys,
    MEMBER_TO_FPTR(Perl_magic_getnkeys),
    MEMBER_TO_FPTR(Perl_magic_setnkeys),
    0,
    0,
    0,
    0,
    0,
    0
);

MGVTBL_SET(
    PL_vtbl_taint,
    MEMBER_TO_FPTR(Perl_magic_gettaint),
    MEMBER_TO_FPTR(Perl_magic_settaint),
    0,
    0,
    0,
    0,
    0,
    0
);

MGVTBL_SET(
    PL_vtbl_substr,
    MEMBER_TO_FPTR(Perl_magic_getsubstr),
    MEMBER_TO_FPTR(Perl_magic_setsubstr),
    0,
    0,
    0,
    0,
    0,
    0
);

MGVTBL_SET(
    PL_vtbl_vec,
    MEMBER_TO_FPTR(Perl_magic_getvec),
    MEMBER_TO_FPTR(Perl_magic_setvec),
    0,
    0,
    0,
    0,
    0,
    0
);

MGVTBL_SET(
    PL_vtbl_pos,
    MEMBER_TO_FPTR(Perl_magic_getpos),
    MEMBER_TO_FPTR(Perl_magic_setpos),
    0,
    0,
    0,
    0,
    0,
    0
);

MGVTBL_SET(
    PL_vtbl_bm,
    0,
    MEMBER_TO_FPTR(Perl_magic_setbm),
    0,
    0,
    0,
    0,
    0,
    0
);

MGVTBL_SET(
    PL_vtbl_fm,
    0,
    MEMBER_TO_FPTR(Perl_magic_setfm),
    0,
    0,
    0,
    0,
    0,
    0
);

MGVTBL_SET(
    PL_vtbl_uvar,
    MEMBER_TO_FPTR(Perl_magic_getuvar),
    MEMBER_TO_FPTR(Perl_magic_setuvar),
    0,
    0,
    0,
    0,
    0,
    0
);

MGVTBL_SET(
    PL_vtbl_defelem,
    MEMBER_TO_FPTR(Perl_magic_getdefelem),
    MEMBER_TO_FPTR(Perl_magic_setdefelem),
    0,
    0,
    0,
    0,
    0,
    0
);

MGVTBL_SET(
    PL_vtbl_regexp,
    0,
    MEMBER_TO_FPTR(Perl_magic_setregexp),
    0,
    0,
    MEMBER_TO_FPTR(Perl_magic_freeregexp),
    0,
    0,
    0
);

MGVTBL_SET(
    PL_vtbl_regdata,
    0,
    0,
    MEMBER_TO_FPTR(Perl_magic_regdata_cnt),
    0,
    0,
    0,
    0,
    0
);

MGVTBL_SET(
    PL_vtbl_regdatum,
    MEMBER_TO_FPTR(Perl_magic_regdatum_get),
    MEMBER_TO_FPTR(Perl_magic_regdatum_set),
    0,
    0,
    0,
    0,
    0,
    0
);

MGVTBL_SET(
    PL_vtbl_amagic,
    0,
    MEMBER_TO_FPTR(Perl_magic_setamagic),
    0,
    0,
    MEMBER_TO_FPTR(Perl_magic_setamagic),
    0,
    0,
    0
);

MGVTBL_SET(
    PL_vtbl_amagicelem,
    0,
    MEMBER_TO_FPTR(Perl_magic_setamagic),
    0,
    0,
    MEMBER_TO_FPTR(Perl_magic_setamagic),
    0,
    0,
    0
);

MGVTBL_SET(
    PL_vtbl_backref,
    0,
    0,
    0,
    0,
    MEMBER_TO_FPTR(Perl_magic_killbackrefs),
    0,
    0,
    0
);

MGVTBL_SET(
    PL_vtbl_ovrld,
    0,
    0,
    0,
    0,
    MEMBER_TO_FPTR(Perl_magic_freeovrld),
    0,
    0,
    0
);

MGVTBL_SET(
    PL_vtbl_utf8,
    0,
    MEMBER_TO_FPTR(Perl_magic_setutf8),
    0,
    0,
    0,
    0,
    0,
    0
);
#ifdef USE_LOCALE_COLLATE
MGVTBL_SET(
    PL_vtbl_collxfrm,
    0,
    MEMBER_TO_FPTR(Perl_magic_setcollxfrm),
    0,
    0,
    0,
    0,
    0,
    0
);
#endif

MGVTBL_SET(
    PL_vtbl_hintselem,
    0,
    MEMBER_TO_FPTR(Perl_magic_sethint),
    0,
    MEMBER_TO_FPTR(Perl_magic_clearhint),
    0,
    0,
    0,
    0
);
d4189 44
a4232 1
#include "overload.h"
a4236 1
  U32 flags;
d4239 2
a4241 1
  CV* table[NofAMmeth];
a4243 1
  U32 flags;
d4246 1
d4300 2
a4301 2
				 PERLDBf_NAMEEVAL| PERLDBf_NAMEANON )
					/* No _NONAME, _GOTO, _ASSERTION */
d4324 1
a4324 1
#define PERLDB_ASSERTION (PL_perldb && (PL_perldb & PERLDBf_ASSERTION))
d4334 1
a4334 1
#define IN_LOCALE_RUNTIME	(CopHINTS_get(PL_curcop) & HINT_LOCALE)
d4424 1
a4424 1
#   define Atoul(s)	Strtoul(s, NULL, 10)
d4519 2
a4520 3
 * this, if you want to make the extension thread-safe.  See
 * ext/XS/APItest/APItest.xs for an example of the use of these macros,
 * and perlxs.pod for more.
a4524 1
 *    XXX in the current implementation, this string is ignored.
a4537 2
#ifdef PERL_GLOBAL_STRUCT_PRIVATE

a4541 1
#define MY_CXT_INDEX Perl_my_cxt_index(aTHX_ MY_CXT_KEY)
d4543 4
a4546 9
/* Creates and zeroes the per-interpreter data.
 * (We allocate my_cxtp in a Perl SV so that it will be released when
 * the interpreter goes away.) */
#define MY_CXT_INIT \
	my_cxt_t *my_cxtp = \
	    (my_cxt_t*)Perl_my_cxt_init(aTHX_ MY_CXT_KEY, sizeof(my_cxt_t))
#define MY_CXT_INIT_INTERP(my_perl) \
	my_cxt_t *my_cxtp = \
	    (my_cxt_t*)Perl_my_cxt_init(my_perl, MY_CXT_KEY, sizeof(my_cxt_t))
d4551 2
a4552 23
	my_cxt_t *my_cxtp = (my_cxt_t *)PL_my_cxt_list[MY_CXT_INDEX]
#define dMY_CXT_INTERP(my_perl)	\
	my_cxt_t *my_cxtp = (my_cxt_t *)(my_perl)->Imy_cxt_list[MY_CXT_INDEX]

/* Clones the per-interpreter data. */
#define MY_CXT_CLONE \
	my_cxt_t *my_cxtp = (my_cxt_t*)SvPVX(newSV(sizeof(my_cxt_t)-1));\
	Copy(PL_my_cxt_list[MY_CXT_INDEX], my_cxtp, 1, my_cxt_t);\
	PL_my_cxt_list[MY_CXT_INDEX] = my_cxtp				\

#else /* #ifdef PERL_GLOBAL_STRUCT_PRIVATE */

/* This must appear in all extensions that define a my_cxt_t structure,
 * right after the definition (i.e. at file scope).  The non-threads
 * case below uses it to declare the data as static. */
#define START_MY_CXT static int my_cxt_index = -1;

/* This declaration should be used within all functions that use the
 * interpreter-local data. */
#define dMY_CXT	\
	my_cxt_t *my_cxtp = (my_cxt_t *)PL_my_cxt_list[my_cxt_index]
#define dMY_CXT_INTERP(my_perl)	\
	my_cxt_t *my_cxtp = (my_cxt_t *)(my_perl)->Imy_cxt_list[my_cxt_index]
d4558 5
a4562 5
	my_cxt_t *my_cxtp = \
	    (my_cxt_t*)Perl_my_cxt_init(aTHX_ &my_cxt_index, sizeof(my_cxt_t))
#define MY_CXT_INIT_INTERP(my_perl) \
	my_cxt_t *my_cxtp = \
	    (my_cxt_t*)Perl_my_cxt_init(my_perl, &my_cxt_index, sizeof(my_cxt_t))
d4566 1
d4568 2
a4569 4
	Copy(PL_my_cxt_list[my_cxt_index], my_cxtp, 1, my_cxt_t);\
	PL_my_cxt_list[my_cxt_index] = my_cxtp				\

#endif /* #ifdef PERL_GLOBAL_STRUCT_PRIVATE */
d4584 1
a4584 1
#else /* PERL_IMPLICIT_CONTEXT */
d4600 1
a4600 1
#endif /* !defined(PERL_IMPLICIT_CONTEXT) */
a4788 1
#define PERL_UNICODE_UTF8CACHEASSERT_FLAG	0x0100
d4804 1
a4804 1
#define PERL_UNICODE_ALL_FLAGS			0x01ff
a4815 1
#define PERL_UNICODE_UTF8CACHEASSERT		'a'
d4857 4
a4860 21
#define do_open(g, n, l, a, rm, rp, sf) \
	do_openn(g, n, l, a, rm, rp, sf, (SV **) NULL, 0)
#ifdef PERL_DEFAULT_DO_EXEC3_IMPLEMENTATION
#  define do_exec(cmd)			do_exec3(cmd,0,0)
#endif
#ifdef OS2
#  define do_aexec			Perl_do_aexec
#else
#  define do_aexec(really, mark,sp)	do_aexec5(really, mark, sp, 0, 0)
#endif

#if defined(OEMVS)
#define NO_ENV_ARRAY_IN_MAIN
#endif

/* These are used by Perl_pv_escape() and Perl_pv_pretty() 
 * are here so that they are available throughout the core 
 * NOTE that even though some are for _escape and some for _pretty
 * there must not be any clashes as the flags from _pretty are
 * passed straight through to _escape.
 */
d4862 1
a4862 27
#define PERL_PV_ESCAPE_QUOTE        0x0001
#define PERL_PV_PRETTY_QUOTE        PERL_PV_ESCAPE_QUOTE

#define PERL_PV_PRETTY_ELLIPSES     0x0002
#define PERL_PV_PRETTY_LTGT         0x0004

#define PERL_PV_ESCAPE_FIRSTCHAR    0x0008

#define PERL_PV_ESCAPE_UNI          0x0100     
#define PERL_PV_ESCAPE_UNI_DETECT   0x0200

#define PERL_PV_ESCAPE_ALL	    0x1000
#define PERL_PV_ESCAPE_NOBACKSLASH  0x2000
#define PERL_PV_ESCAPE_NOCLEAR      0x4000
#define PERL_PV_ESCAPE_RE           0x8000

#define PERL_PV_PRETTY_NOCLEAR      PERL_PV_ESCAPE_NOCLEAR

/* used by pv_display in dump.c*/
#define PERL_PV_PRETTY_DUMP  PERL_PV_PRETTY_ELLIPSES|PERL_PV_PRETTY_QUOTE
#define PERL_PV_PRETTY_REGPROP PERL_PV_PRETTY_ELLIPSES|PERL_PV_PRETTY_LTGT|PERL_PV_ESCAPE_RE

/*

   (KEEP THIS LAST IN perl.h!)

   Mention
d4902 1
a4902 1
   so that Configure picks them up.
d4904 5
a4908 1
   (KEEP THIS LAST IN perl.h!)
d4910 2
a4911 1
*/
d4914 1
@


1.1.1.12
log
@import perl 5.10.1
@
text
@d3 2
a4 2
 *    Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
 *    2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 by Larry Wall and others
a43 18
/* This logic needs to come after reading config.h, but before including
   proto.h  */
#ifdef IAMSUID
#  ifndef DOSUID
#    define DOSUID
#  endif
#endif

#ifdef SETUID_SCRIPTS_ARE_SECURE_NOW
#  ifdef DOSUID
#    undef DOSUID
#  endif
#  ifdef IAMSUID
#    undef IAMSUID
#    define SETUID_SCRIPTS_ARE_SECURE_NOW_AND_IAMSUID
#  endif
#endif

a129 13
#undef START_EXTERN_C
#undef END_EXTERN_C
#undef EXTERN_C
#ifdef __cplusplus
#  define START_EXTERN_C extern "C" {
#  define END_EXTERN_C }
#  define EXTERN_C extern "C"
#else
#  define START_EXTERN_C
#  define END_EXTERN_C
#  define EXTERN_C extern
#endif

d133 1
a133 1
       EXTERN_C struct perl_vars* Perl_GetVarsPrivate();
d204 1
a204 1
    CALL_FPTR(RX_ENGINE(prog)->exec)(aTHX_ (prog),(stringarg),(strend), \
d207 1
a207 1
    CALL_FPTR(RX_ENGINE(prog)->intuit)(aTHX_ (prog), (sv), (strpos), \
d210 1
a210 1
    CALL_FPTR(RX_ENGINE(prog)->checkstr)(aTHX_ (prog))
d220 1
a220 1
    if(prog) CALL_FPTR(RX_ENGINE(prog)->free)(aTHX_ (prog))
d223 1
a223 1
    CALL_FPTR(RX_ENGINE(rx)->numbered_buff_FETCH)(aTHX_ (rx),(paren),(usesv))
d226 1
a226 1
    CALL_FPTR(RX_ENGINE(rx)->numbered_buff_STORE)(aTHX_ (rx),(paren),(value))
d229 1
a229 1
    CALL_FPTR(RX_ENGINE(rx)->numbered_buff_LENGTH)(aTHX_ (rx),(sv),(paren))
d232 1
a232 1
    CALL_FPTR(RX_ENGINE(rx)->named_buff)(aTHX_ (rx), (key), NULL, ((flags) | RXapif_FETCH))
d235 1
a235 1
    CALL_FPTR(RX_ENGINE(rx)->named_buff)(aTHX_ (rx), (key), (value), ((flags) | RXapif_STORE))
d238 1
a238 1
    CALL_FPTR(RX_ENGINE(rx)->named_buff)(aTHX_ (rx),(key), NULL, ((flags) | RXapif_DELETE))
d241 1
a241 1
    CALL_FPTR(RX_ENGINE(rx)->named_buff)(aTHX_ (rx), NULL, NULL, ((flags) | RXapif_CLEAR))
d244 1
a244 1
    CALL_FPTR(RX_ENGINE(rx)->named_buff)(aTHX_ (rx), (key), NULL, ((flags) | RXapif_EXISTS))
d247 1
a247 1
    CALL_FPTR(RX_ENGINE(rx)->named_buff_iter)(aTHX_ (rx), NULL, ((flags) | RXapif_FIRSTKEY))
d250 1
a250 1
    CALL_FPTR(RX_ENGINE(rx)->named_buff_iter)(aTHX_ (rx), (lastkey), ((flags) | RXapif_NEXTKEY))
d253 1
a253 1
    CALL_FPTR(RX_ENGINE(rx)->named_buff)(aTHX_ (rx), NULL, NULL, ((flags) | RXapif_SCALAR))
d256 1
a256 1
    CALL_FPTR(RX_ENGINE(rx)->named_buff)(aTHX_ (rx), NULL, NULL, RXapif_REGNAMES_COUNT)
d259 1
a259 1
    CALL_FPTR(RX_ENGINE(rx)->named_buff)(aTHX_ (rx), NULL, NULL, flags)
d262 1
a262 1
    CALL_FPTR(RX_ENGINE(rx)->qr_package)(aTHX_ (rx))
d269 1
a269 1
    (prog ? CALL_FPTR(RX_ENGINE(prog)->dupe)(aTHX_ (prog),(param)) \
d394 13
d437 2
a438 6
 * (insane errors ensue).
 * g++ does not give insane errors now (RMB 2008-01-30, gcc 4.2.2).
 */
#if defined(PERL_GCC_PEDANTIC) || \
    (defined(__GNUC__) && defined(__cplusplus) && \
	((__GNUC__ < 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ < 2))))
d513 3
d517 1
a665 5
/* for WCOREDUMP */
#ifdef I_SYS_WAIT
#   include <sys/wait.h>
#endif

a925 5
/* Maximum level of recursion */
#ifndef PERL_SUB_DEPTH_WARN
#define PERL_SUB_DEPTH_WARN 100
#endif

a1260 5
#   define dSAVEDERRNO    int saved_errno; unsigned saved_vms_errno
#   define dSAVE_ERRNO    int saved_errno = errno; unsigned saved_vms_errno = vaxc$errno
#   define SAVE_ERRNO     ( saved_errno = errno, saved_vms_errno = vaxc$errno )
#   define RESTORE_ERRNO  SETERRNO(saved_errno, saved_vms_errno)

a1274 5
#   define dSAVEDERRNO    int saved_errno
#   define dSAVE_ERRNO    int saved_errno = errno
#   define SAVE_ERRNO     (saved_errno = errno)
#   define RESTORE_ERRNO  (errno = saved_errno)

d1290 2
a1291 6
#ifdef PERL_CORE
# define DEFSV (0 + GvSVn(PL_defgv))
#else
# define DEFSV GvSVn(PL_defgv)
#endif
#define DEFSV_set(sv) (GvSV(PL_defgv) = (sv))
d1523 1
a1523 1
/* BeOS 5.0 and Haiku R1 seem to define S_IREAD and S_IWRITE in <posix/fcntl.h>
d1527 1
a1527 1
#if !defined(S_IREAD) && !(defined(__BEOS__) || defined(__HAIKU__))
d1531 1
a1531 1
#if !defined(S_IWRITE) && !(defined(__BEOS__) || defined(__HAIKU__))
d2554 1
a2554 4
#if defined(__HAIKU__)
#   include "haiku/haikuish.h"
#   define ISHISH "haiku"
#elif defined(__BEOS__)
d2634 1
a2634 5
/* Some operating systems have this as a macro, which in turn expands to a comma
   expression, and the last sub-expression is something that gets calculated,
   and then they have the gall to warn that a value computed is not used. Hence
   cast to void.  */
#    define PERL_FPU_INIT (void)fpsetmask(0)
a2654 19
/*
=for apidoc Am|void|PERL_SYS_INIT|int argc|char** argv
Provides system-specific tune up of the C runtime environment necessary to
run Perl interpreters. This should be called only once, before creating
any Perl interpreters.

=for apidoc Am|void|PERL_SYS_INIT3|int argc|char** argv|char** env
Provides system-specific tune up of the C runtime environment necessary to
run Perl interpreters. This should be called only once, before creating
any Perl interpreters.

=for apidoc Am|void|PERL_SYS_TERM|
Provides system-specific clean up of the C runtime environment after
running Perl interpreters. This should be called only once, after
freeing any remaining Perl interpreters.

=cut
 */

a2703 3
#  if __GNUC__ == 3 && __GNUC_MINOR__ >= 1 || __GNUC__ > 3 /* 3.1 -> */
#    define HASATTRIBUTE_DEPRECATED
#  endif
d2887 5
a2891 5
   * the NATIVE error status based on it.
   *
   * When in the default mode to comply with the Perl VMS documentation,
   * 0 is a success and any other code sets the NATIVE status to a failure
   * code of SS$_ABORT.
d2905 22
a2926 22
	    if (MY_POSIX_EXIT) { \
	      if (evalue <= 0xFF00) {		\
		  if (evalue > 0xFF)			\
		    evalue = (evalue >> child_offset_bits) & 0xFF; \
		  PL_statusvalue_vms =		\
		    (C_FAC_POSIX | (evalue << 3 ) |	\
		    ((evalue == 1) ? (STS$K_ERROR | STS$M_INHIB_MSG) : 1)); \
	      } else /* forgive them Perl, for they have sinned */ \
		PL_statusvalue_vms = evalue; \
	    } else { \
	      if (evalue == 0)			\
		PL_statusvalue_vms = SS$_NORMAL;	\
	      else if (evalue <= 0xFF00) \
		PL_statusvalue_vms = SS$_ABORT; \
	      else { /* forgive them Perl, for they have sinned */ \
		  if (evalue != EVMSERR) PL_statusvalue_vms = evalue; \
		  else PL_statusvalue_vms = vaxc$errno;	\
		  /* And obviously used a VMS status value instead of UNIX */ \
		  PL_statusvalue = EVMSERR;		\
	      } \
	      set_vaxc_errno(PL_statusvalue_vms);	\
	    }						\
a2928 1

a2940 3
   * A POSIX exit code is from 0 to 255.  If the exit code is higher
   * than this, it needs to be assumed that it is a VMS exit code and
   * passed through.
d2948 3
a2950 4
		if (evalue > 255) PL_statusvalue_vms = evalue; else {	\
		  PL_statusvalue_vms = \
		    (C_FAC_POSIX | (evalue << 3 ) |	\
		     ((evalue == 1) ? (STS$K_ERROR | STS$M_INHIB_MSG) : 1));} \
a3026 1
#ifndef PERL_CORE
d3029 2
a3030 9
/* This was only ever used for the current version, and that can be done at
   compile time, as PERL_FS_VERSION, so should we just delete it?  */
#  ifndef PERL_FS_VER_FMT
#    define PERL_FS_VER_FMT	"%d.%d.%d"
#  endif
#endif

#ifndef PERL_FS_VERSION
#  define PERL_FS_VERSION	PERL_VERSION_STRING
a3117 3
#ifdef HASATTRIBUTE_DEPRECATED
#  define __attribute__deprecated__         __attribute__((deprecated))
#endif
a3140 3
#ifndef __attribute__deprecated__
#  define __attribute__deprecated__
#endif
a3310 11
/* macros to define bit-fields in structs. */
#ifndef PERL_BITFIELD8
#  define PERL_BITFIELD8 unsigned
#endif
#ifndef PERL_BITFIELD16
#  define PERL_BITFIELD16 unsigned
#endif
#ifndef PERL_BITFIELD32
#  define PERL_BITFIELD32 unsigned
#endif

d3969 1
a3969 1
EXTERN_C void PerlIO_teardown(void);
a4023 2
#else
#  define sTHX	0
a4035 28
#ifdef I_MALLOCMALLOC
/* Needed for malloc_size(), malloc_good_size() on some systems */
#  include <malloc/malloc.h>
#endif

#ifdef MYMALLOC
#  define Perl_safesysmalloc_size(where)	Perl_malloced_size(where)
#else
#  ifdef HAS_MALLOC_SIZE
#    ifdef PERL_TRACK_MEMPOOL
#	define Perl_safesysmalloc_size(where)			\
	    (malloc_size(((char *)(where)) - sTHX) - sTHX)
#    else
#	define Perl_safesysmalloc_size(where) malloc_size(where)
#    endif
#  endif
#  ifdef HAS_MALLOC_GOOD_SIZE
#    ifdef PERL_TRACK_MEMPOOL
#	define Perl_malloc_good_size(how_much)			\
	    (malloc_good_size((how_much) + sTHX) - sTHX)
#    else
#	define Perl_malloc_good_size(how_much) malloc_good_size(how_much)
#    endif
#  else
/* Having this as the identity operation makes some code simpler.  */
#	define Perl_malloc_good_size(how_much)	(how_much)
#  endif
#endif
a4551 2
#define HINT_NO_AMAGIC		0x01000000 /* overloading pragma */

a4628 4
#define PERL_VERSION_STRING	STRINGIFY(PERL_REVISION) "." \
				STRINGIFY(PERL_VERSION) "." \
				STRINGIFY(PERL_SUBVERSION)

d4891 1
a4891 1
    MEMBER_TO_FPTR(Perl_magic_clearisa),
d5009 1
a5009 1
    MEMBER_TO_FPTR(Perl_magic_setregexp),
d5021 1
a5021 1
    MEMBER_TO_FPTR(Perl_magic_setregexp),
d5243 1
a5243 2
				 PERLDBf_NAMEEVAL| PERLDBf_NAMEANON |   \
				 PERLDBf_SAVESRC)
a5255 5
#define PERLDBf_SAVESRC  	0x400	/* Save source lines into @@{"_<$filename"} */
#define PERLDBf_SAVESRC_NOSUBS	0x800	/* Including evals that generate no subrouties */
#if 0 /* Not yet working. */
#define PERLDBf_SAVESRC_INVALID	0x1000	/* Save source that did not compile */
#endif
a5267 5
#define PERLDB_SAVESRC 	(PL_perldb && (PL_perldb & PERLDBf_SAVESRC))
#define PERLDB_SAVESRC_NOSUBS	(PL_perldb && (PL_perldb & PERLDBf_SAVESRC_NOSUBS))
#if 0 /* Not yet working. */
#define PERLDB_SAVESRC_INVALID	(PL_perldb && (PL_perldb & PERLDBf_SAVESRC_INVALID))
#endif
a5563 1
#define dMY_CXT_INTERP(my_perl)	dNOOP
d5612 3
a5614 4
#   if defined(__BEOS__) || defined(__HAIKU__) || defined(__VOS__) || \
	defined(__CYGWIN__)
    /* BeOS/Haiku has O_TEXT != O_BINARY but O_TEXT and O_BINARY have no effect;
     * BeOS/Haiku is always UNIXoid (LF), not DOSish (CRLF). */
d5689 1
a5689 1
#define EXEC_ARGV_CAST(x) (char **)x
a5928 12

#define CLEAR_ERRSV() STMT_START { sv_setpvn(ERRSV,"",0); if (SvMAGICAL(ERRSV)) { mg_free(ERRSV); } SvPOK_only(ERRSV); } STMT_END

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 noet:
 */
@


1.1.1.13
log
@Perl 5.12.2 from CPAN
@
text
@d31 1
a31 1
#endif
d44 18
d243 4
d295 1
a295 1
#if defined(USE_ITHREADS)
d301 1
a301 1
          : (REGEXP *)NULL)
d335 1
a335 1

d968 1
a968 1
#if !defined(OS2) && !defined(WIN32) && !defined(DJGPP) && !defined(EPOC) && !defined(__SYMBIAN32__)
d972 1
a972 1
/* Cannot include embed.h here on Win32 as win32.h has not
a1051 1
/* diag_listed_as: "-T" is on the #! line, it must also be used on the command line */
a1167 7
/* Microsoft VC's sys/stat.h defines all S_Ixxx macros except S_IFIFO.
   This definition should ideally go into win32/win32.h, but S_IFIFO is
   used later here in perl.h before win32/win32.h is being included. */
#if !defined(S_IFIFO) && defined(_S_IFIFO)
#   define S_IFIFO _S_IFIFO
#endif

d1215 1
a1215 1
 * This is important for using IPv6.
d1327 1
a1327 19
#define ERRSV GvSVn(PL_errgv)

#define CLEAR_ERRSV() STMT_START {					\
    if (!GvSV(PL_errgv)) {						\
	sv_setpvs(GvSV(gv_add_by_type(PL_errgv, SVt_PV)), "");		\
    } else if (SvREADONLY(GvSV(PL_errgv))) {				\
	SvREFCNT_dec(GvSV(PL_errgv));					\
	GvSV(PL_errgv) = newSVpvs("");					\
    } else {								\
	SV *const errsv = GvSV(PL_errgv);				\
	sv_setpvs(errsv, "");						\
	if (SvMAGICAL(errsv)) {						\
	    mg_free(errsv);						\
	}								\
	SvPOK_only(errsv);						\
    }									\
    } STMT_END


d2397 1
a2397 2
typedef struct regexp ORANGE;	/* This is the body structure.  */
typedef struct p5rx REGEXP;
d2526 1
a2526 1
#if defined(OS2)
d2588 7
d2803 1
a2803 1
#endif /* #ifndef PERL_MICRO */
d2894 1
a2894 1
   Perl tries to translate it to text in some of the tests.
d3154 1
a3154 1
/*
d3157 2
a3158 2
    use "%-p" or "%-<number>p" or "%<number>p" formats.
    These formats will still work in perl code.
d3163 1
a3163 1
    No longer use %1p for VDf = %vd.  RMB 2007-10-19
d3185 1
a3185 1
/* not used; but needed for backward compatibilty with XS code? - RMB */
d3194 1
a3194 1
/* not used; but needed for backward compatibilty with XS code? - RMB */
a3201 8
#if !defined(PERL_CORE) && !defined(PERL_NO_SHORT_NAMES)
#  if defined(PERL_IMPLICIT_CONTEXT)
#    define pmflag(a,b)		Perl_pmflag(aTHX_ a,b)
#  else
#    define pmflag			Perl_pmflag
#  endif
#endif

d3266 1
a3266 1
#  define __attribute__format__null_ok__(x,y,z)
d3364 1
a3364 1
#if !defined(OS2)
d3369 1
a3369 1
#undef HAS_PASSWD  /* unixish.h but not unixish enough. */
d3412 1
a3413 1
#include "regexp.h"
a3428 4
/* defined in sv.c, but also used in [ach]v.c */
#undef _XPV_HEAD
#undef _XPVMG_HEAD
#undef _XPVCV_COMMON
d3629 1
a3629 1
/* 0x00010000 is unused, used to be S */
d3637 1
a3637 3
#define DEBUG_M_FLAG		0x01000000 /*16777216*/
#define DEBUG_B_FLAG		0x02000000 /*33554432*/
#define DEBUG_MASK		0x03FEEFFF /* mask of all the standard flags */
d3659 1
a3666 2
#  define DEBUG_M_TEST_ (PL_debug & DEBUG_M_FLAG)
#  define DEBUG_B_TEST_ (PL_debug & DEBUG_B_FLAG)
d3688 1
a3695 2
#  define DEBUG_M_TEST DEBUG_M_TEST_
#  define DEBUG_B_TEST DEBUG_B_TEST_
d3736 2
a3743 2
#  define DEBUG_M(a) DEBUG__(DEBUG_M_TEST, a)
#  define DEBUG_B(a) DEBUG__(DEBUG_B_TEST, a)
d3763 1
a3770 2
#  define DEBUG_M_TEST (0)
#  define DEBUG_B_TEST (0)
d3792 1
a3798 2
#  define DEBUG_M(a)
#  define DEBUG_B(a)
a3863 6
#if defined(DEBUGGING) && defined(I_ASSERT)
#  include <assert.h>
#endif

/* Keep the old croak based assert for those who want it, and as a fallback if
   the platform is so heretically non-ANSI that it can't assert.  */
d3865 2
a3866 1
#define Perl_assert(what)	PERL_DEB( 				\
a3870 3

#ifndef assert
#  define assert(what)	Perl_assert(what)
d4215 1
a4215 3
/* The core no longer needs these here. If you require the string constant,
   please inline a copy into your own code.  */
EXTCONST char PL_no_symref[] __attribute__deprecated__
d4217 1
a4217 1
EXTCONST char PL_no_symref_sv[] __attribute__deprecated__
a4256 3
EXTCONST char PL_bitcount[256] =
#  include "bitcount.h"
;
a4260 1
EXTCONST char PL_bitcount[256];
d4338 2
a4339 76
#endif  /* !EBCDIC, but still in DOINIT */

/* If these tables are accessed through ebcdic, the access will be converted to
 * latin1 first */
EXTCONST  unsigned char PL_latin1_lc[] = {  /* lowercasing */
	0,	1,	2,	3,	4,	5,	6,	7,
	8,	9,	10,	11,	12,	13,	14,	15,
	16,	17,	18,	19,	20,	21,	22,	23,
	24,	25,	26,	27,	28,	29,	30,	31,
	32,	33,	34,	35,	36,	37,	38,	39,
	40,	41,	42,	43,	44,	45,	46,	47,
	48,	49,	50,	51,	52,	53,	54,	55,
	56,	57,	58,	59,	60,	61,	62,	63,
	64,	'a',	'b',	'c',	'd',	'e',	'f',	'g',
	'h',	'i',	'j',	'k',	'l',	'm',	'n',	'o',
	'p',	'q',	'r',	's',	't',	'u',	'v',	'w',
	'x',	'y',	'z',	91,	92,	93,	94,	95,
	96,	97,	98,	99,	100,	101,	102,	103,
	104,	105,	106,	107,	108,	109,	110,	111,
	112,	113,	114,	115,	116,	117,	118,	119,
	120,	121,	122,	123,	124,	125,	126,	127,
	128,	129,	130,	131,	132,	133,	134,	135,
	136,	137,	138,	139,	140,	141,	142,	143,
	144,	145,	146,	147,	148,	149,	150,	151,
	152,	153,	154,	155,	156,	157,	158,	159,
	160,	161,	162,	163,	164,	165,	166,	167,
	168,	169,	170,	171,	172,	173,	174,	175,
	176,	177,	178,	179,	180,	181,	182,	183,
	184,	185,	186,	187,	188,	189,	190,	191,
	192+32,	193+32,	194+32,	195+32,	196+32,	197+32,	198+32,	199+32,
	200+32,	201+32,	202+32,	203+32,	204+32,	205+32,	206+32,	207+32,
	208+32,	209+32,	210+32,	211+32,	212+32,	213+32,	214+32,	215,
	216+32,	217+32,	218+32,	219+32,	220+32,	221+32,	222+32,	223,	
	224,	225,	226,	227,	228,	229,	230,	231,
	232,	233,	234,	235,	236,	237,	238,	239,
	240,	241,	242,	243,	244,	245,	246,	247,
	248,	249,	250,	251,	252,	253,	254,	255
};

/* upper and title case of latin1 characters, modified so that the three tricky
 * ones are mapped to 255 (which is one of the three) */
EXTCONST  unsigned char PL_mod_latin1_uc[] = {
	0,	1,	2,	3,	4,	5,	6,	7,
	8,	9,	10,	11,	12,	13,	14,	15,
	16,	17,	18,	19,	20,	21,	22,	23,
	24,	25,	26,	27,	28,	29,	30,	31,
	32,	33,	34,	35,	36,	37,	38,	39,
	40,	41,	42,	43,	44,	45,	46,	47,
	48,	49,	50,	51,	52,	53,	54,	55,
	56,	57,	58,	59,	60,	61,	62,	63,
	64,	65,	66,	67,	68,	69,	70,	71,
	72,	73,	74,	75,	76,	77,	78,	79,
	80,	81,	82,	83,	84,	85,	86,	87,
	88,	89,	90,	91,	92,	93,	94,	95,
	96,	'A',	'B',	'C',	'D',	'E',	'F',	'G',
	'H',	'I',	'J',	'K',	'L',	'M',	'N',	'O',
	'P',	'Q',	'R',	'S',	'T',	'U',	'V',	'W',
	'X',	'Y',	'Z',	123,	124,	125,	126,	127,
	128,	129,	130,	131,	132,	133,	134,	135,
	136,	137,	138,	139,	140,	141,	142,	143,
	144,	145,	146,	147,	148,	149,	150,	151,
	152,	153,	154,	155,	156,	157,	158,	159,
	160,	161,	162,	163,	164,	165,	166,	167,
	168,	169,	170,	171,	172,	173,	174,	175,
	176,	177,	178,	179,	180,	255 /*micro*/,	182,	183,
	184,	185,	186,	187,	188,	189,	190,	191,
	192,	193,	194,	195,	196,	197,	198,	199,
	200,	201,	202,	203,	204,	205,	206,	207,
	208,	209,	210,	211,	212,	213,	214,	215,
	216,	217,	218,	219,	220,	221,	222,	255 /*sharp s*/,	
	224-32,	225-32,	226-32,	227-32,	228-32,	229-32,	230-32,	231-32,
	232-32,	233-32,	234-32,	235-32,	236-32,	237-32,	238-32,	239-32,
	240-32,	241-32,	242-32,	243-32,	244-32,	245-32,	246-32,	247,
	248-32,	249-32,	250-32,	251-32,	252-32,	253-32,	254-32,	255
};
#else	/* ! DOINIT */
a4340 2
EXTCONST unsigned char PL_mod_latin1_uc[];
EXTCONST unsigned char PL_latin1_lc[];
d4464 4
a4467 1
	"WHEN",
d4469 1
d4471 1
a4471 8
	"LOOP_FOR",
	"LOOP_PLAIN",
	"LOOP_LAZYSV",
	"LOOP_LAZYIV",
	"SUB",
	"FORMAT",
	"EVAL",
	"SUBST"
d4648 1
a4648 2
    want_vtbl_hintselem,
    want_vtbl_hints
a4665 1
#define HINT_UNI_8_BIT		0x00000800 /* unicode_strings feature */
d4726 2
a4727 2
typedef void (*SVFUNC_t) (pTHX_ SV* const);
typedef I32  (*SVCOMPARE_t) (pTHX_ SV* const, SV* const);
a4740 6
typedef void(CPERLscope(*Perl_ophook_t))(pTHX_ OP*);
typedef int (CPERLscope(*Perl_keyword_plugin_t))(pTHX_ char*, STRLEN, OP**);

#define KEYWORD_PLUGIN_DECLINE 0
#define KEYWORD_PLUGIN_STMT    1
#define KEYWORD_PLUGIN_EXPR    2
a4862 5
#ifdef PERL_CORE
/* All core uses now exterminated. Ensure no zombies can return:  */
#  undef PL_na
#endif

d4947 1
d5197 1
a5197 1
    0,
a5311 12
MGVTBL_SET(
    PL_vtbl_hints,
    0,
    0,
    0,
    MEMBER_TO_FPTR(Perl_magic_clearhints),
    0,
    0,
    0,
    0
);

d5382 1
a5382 1
					/* No _NONAME, _GOTO */
d5396 1
d5398 1
d5410 1
d5413 1
d5415 1
d5776 58
d5999 2
a6000 2
/* These are used by Perl_pv_escape() and Perl_pv_pretty()
 * are here so that they are available throughout the core
d6014 1
a6014 1
#define PERL_PV_ESCAPE_UNI          0x0100
d6079 2
@


1.1.1.14
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@a142 12
/* Fallback definitions in case we don't have definitions from config.h.
   This should only matter for systems that don't use Configure and
   haven't been modified to define PERL_STATIC_INLINE yet.
*/
#if !defined(PERL_STATIC_INLINE)
#  ifdef HAS_STATIC_INLINE
#    define PERL_STATIC_INLINE static inline
#  else
#    define PERL_STATIC_INLINE static
#  endif
#endif

a200 7

#ifndef PERL_CORE
/* Do not use these macros. They were part of PERL_OBJECT, which was an
 * implementation of multiplicity using C++ objects. They have been left
 * here solely for the sake of XS code which has incorrectly
 * cargo-culted them.
 */
a208 2
#define MEMBER_TO_FPTR(name) name
#endif /* !PERL_CORE */
d210 1
a210 1
#define CALLRUNOPS  PL_runops
d214 2
a215 1
#define CALLREGCOMP_ENG(prog, sv, flags) (prog)->comp(aTHX_ sv, flags)
d217 1
a217 1
    RX_ENGINE(prog)->exec(aTHX_ (prog),(stringarg),(strend), \
d220 1
a220 1
    RX_ENGINE(prog)->intuit(aTHX_ (prog), (sv), (strpos), \
d223 1
a223 1
    RX_ENGINE(prog)->checkstr(aTHX_ (prog))
d229 1
a229 1
    if(prog) RX_ENGINE(prog)->free(aTHX_ (prog))
d232 1
a232 1
    RX_ENGINE(rx)->numbered_buff_FETCH(aTHX_ (rx),(paren),(usesv))
d235 1
a235 1
    RX_ENGINE(rx)->numbered_buff_STORE(aTHX_ (rx),(paren),(value))
d238 1
a238 1
    RX_ENGINE(rx)->numbered_buff_LENGTH(aTHX_ (rx),(sv),(paren))
d241 1
a241 1
    RX_ENGINE(rx)->named_buff(aTHX_ (rx), (key), NULL, ((flags) | RXapif_FETCH))
d244 1
a244 1
    RX_ENGINE(rx)->named_buff(aTHX_ (rx), (key), (value), ((flags) | RXapif_STORE))
d247 1
a247 1
    RX_ENGINE(rx)->named_buff(aTHX_ (rx),(key), NULL, ((flags) | RXapif_DELETE))
d250 1
a250 1
    RX_ENGINE(rx)->named_buff(aTHX_ (rx), NULL, NULL, ((flags) | RXapif_CLEAR))
d253 1
a253 1
    RX_ENGINE(rx)->named_buff(aTHX_ (rx), (key), NULL, ((flags) | RXapif_EXISTS))
d256 1
a256 1
    RX_ENGINE(rx)->named_buff_iter(aTHX_ (rx), NULL, ((flags) | RXapif_FIRSTKEY))
d259 1
a259 1
    RX_ENGINE(rx)->named_buff_iter(aTHX_ (rx), (lastkey), ((flags) | RXapif_NEXTKEY))
d262 1
a262 1
    RX_ENGINE(rx)->named_buff(aTHX_ (rx), NULL, NULL, ((flags) | RXapif_SCALAR))
d265 1
a265 1
    RX_ENGINE(rx)->named_buff(aTHX_ (rx), NULL, NULL, RXapif_REGNAMES_COUNT)
d268 1
a268 1
    RX_ENGINE(rx)->named_buff(aTHX_ (rx), NULL, NULL, flags)
d271 1
a271 1
    RX_ENGINE(rx)->qr_package(aTHX_ (rx))
d278 1
a278 1
    (prog ? RX_ENGINE(prog)->dupe(aTHX_ (prog),(param)) \
d337 5
a341 6
/* cea2e8a9dd23747f accidentally lost the comment originally from the first
   check in of thread.h, explaining why we need dNOOP at all:  */
/* Rats: if dTHR is just blank then the subsequent ";" throws an error */
/* Declaring a *function*, instead of a variable, ensures that we don't rely
   on being able to suppress "unused" warnings.  */
#define dNOOP extern int Perl___notused(void)
d473 3
a523 9
/* flags used internally only within pp_subst and pp_substcont */
#ifdef PERL_CORE
#  define SUBST_TAINT_STR      1	/* string tainted */
#  define SUBST_TAINT_PAT      2	/* pattern tainted */
#  define SUBST_TAINT_REPL     4	/* replacement tainted */
#  define SUBST_TAINT_RETAINT  8	/* use re'taint' in scope */
#  define SUBST_TAINT_BOOLRET 16	/* return is boolean (don't taint) */
#endif

d574 1
a574 1
/* HP-UX 10.X CMA (Common Multithreaded Architecture) insists that
d950 11
a969 8
/* sv_grow() will expand strings by at least a certain percentage of
   the previously *used* length to avoid excessive calls to realloc().
   The default is 25% of the current length.
*/
#ifndef PERL_STRLEN_EXPAND_SHIFT
#  define PERL_STRLEN_EXPAND_SHIFT 2
#endif

d1208 1
a1208 1
#if defined(HAS_SOCKET) && !defined(WIN32) /* WIN32 handles sockets via win32.h */
a1333 9
# define DEFSV_set(sv) \
    (SvREFCNT_dec(GvSV(PL_defgv)), GvSV(PL_defgv) = SvREFCNT_inc(sv))
# define SAVE_DEFSV                \
    (                               \
	save_gp(PL_defgv, 0),        \
	GvINTRO_off(PL_defgv),        \
	SAVEGENERICSV(GvSV(PL_defgv)), \
	GvSV(PL_defgv) = NULL           \
    )
a1335 2
# define DEFSV_set(sv) (GvSV(PL_defgv) = (sv))
# define SAVE_DEFSV SAVESPTR(GvSV(PL_defgv))
d1337 2
d2201 1
a2201 1
 * despite doing above, because math.h might have overridden... XXX - Allen */
d2362 4
a2387 3
typedef struct block_hooks BHK;
typedef struct custom_op XOP;

d2401 1
d2551 5
d2585 5
d2746 5
a2750 1
#    define MAXPATHLEN 1024	/* Err on the large side. */
d3097 4
d3157 1
a3157 1
    See comments in sv.c for further details.
a3181 12
#ifndef HEKf
#  define HEKf "2p"
#endif

/* Not ideal, but we cannot easily include a number in an already-numeric
 * format sequence. */
#ifndef HEKf256
#  define HEKf256 "3p"
#endif

#define HEKfARG(p) ((void*)(p))

d3183 1
a3183 1
/* not used; but needed for backward compatibility with XS code? - RMB */
d3192 1
a3192 1
/* not used; but needed for backward compatibility with XS code? - RMB */
d3200 8
a3334 1
    UV		any_uv;
a3434 4
/* these would be in doio.h if there was such a file */
#define my_stat()  my_stat_flags(SV_GMAGIC)
#define my_lstat() my_lstat_flags(SV_GMAGIC)

d3456 3
a3468 3
    struct ptr_tbl_arena	*tbl_arena;
    struct ptr_tbl_ent		*tbl_arena_next;
    struct ptr_tbl_ent		*tbl_arena_end;
a3681 1
#  define DEBUG_Pv_TEST_ (DEBUG_P_TEST_ && DEBUG_v_TEST_)
a3711 1
#  define DEBUG_Pv_TEST DEBUG_Pv_TEST_
a3748 1
#  define DEBUG_Pv(a) DEBUG__(DEBUG_Pv_TEST, a)
a3787 1
#  define DEBUG_Pv_TEST (0)
a3816 1
#  define DEBUG_Pv(a)
d3821 58
a3878 4
    DEBUG_l( \
    Perl_deb(aTHX_ "%s scope %ld (savestack=%ld) at %s:%d\n",	\
		    where, (long)PL_scopestack_ix, (long)PL_savestack_ix, \
		    __FILE__, __LINE__));
d4192 8
a4199 6
typedef int (*runops_proc_t)(pTHX);
typedef void (*share_proc_t) (pTHX_ SV *sv);
typedef int  (*thrhook_proc_t) (pTHX);
typedef OP* (*PPADDR_t[]) (pTHX);
typedef bool (*destroyable_proc_t) (pTHX_ SV *sv);
typedef void (*despatch_signals_proc_t) (pTHX);
a4225 12
#define PERL_PATCHLEVEL_H_IMPLICIT
#include "patchlevel.h"
#undef PERL_PATCHLEVEL_H_IMPLICIT

#define PERL_VERSION_STRING	STRINGIFY(PERL_REVISION) "." \
				STRINGIFY(PERL_VERSION) "." \
				STRINGIFY(PERL_SUBVERSION)

#define PERL_API_VERSION_STRING	STRINGIFY(PERL_API_REVISION) "." \
				STRINGIFY(PERL_API_VERSION) "." \
				STRINGIFY(PERL_API_SUBVERSION)

a4230 2
EXTCONST char PL_warn_uninit_sv[]
  INIT("Use of uninitialized value%"SVf"%s%s");
a4269 13
EXTCONST char PL_Yes[]
  INIT("1");
EXTCONST char PL_No[]
  INIT("");
EXTCONST char PL_hexdigit[]
  INIT("0123456789abcdef0123456789ABCDEF");

/* This is constant on most architectures, a global on OS/2 */
#ifndef OS2
EXTCONST char PL_sh_path[]
  INIT(SH_PATH); /* full path of shell */
#endif

a4275 11
/* These are baked at compile time into any shared perl library.
   In future releases this will allow us in main() to sanity test the
   library we're linking against.  */

EXTCONST U8 PL_revision
  INIT(PERL_REVISION);
EXTCONST U8 PL_version
  INIT(PERL_VERSION);
EXTCONST U8 PL_subversion
  INIT(PERL_SUBVERSION);

d4281 1
a4281 5
#  ifdef PERL_MICRO
#    include "uuudmap.h"
#  else
#    include "uudmap.h"
#  endif
d4284 1
a4284 5
#  ifdef PERL_MICRO
#    include "ubitcount.h"
#else
#    include "bitcount.h"
#  endif
d4295 1
a4295 3
/* fast conversion and case folding tables.  The folding tables complement the
 * fold, so that 'a' maps to 'A' and 'A' maps to 'a', ignoring more complicated
 * folds such as outside the range or to multiple characters. */
d4298 36
a4333 5
#ifndef EBCDIC

/* The EBCDIC fold table depends on the code page, and hence is found in
 * utfebcdic.h */

a4367 43
EXTCONST  unsigned char PL_fold_latin1[] = {
    /* Full latin1 complement folding, except for three problematic code points:
     *	Micro sign (181 = 0xB5) and y with diearesis (255 = 0xFF) have their
     *	fold complements outside the Latin1 range, so can't match something
     *	that isn't in utf8.
     *	German lower case sharp s (223 = 0xDF) folds to two characters, 'ss',
     *	not one, so can't be represented in this table.
     *
     * All have to be specially handled */
	0,	1,	2,	3,	4,	5,	6,	7,
	8,	9,	10,	11,	12,	13,	14,	15,
	16,	17,	18,	19,	20,	21,	22,	23,
	24,	25,	26,	27,	28,	29,	30,	31,
	32,	33,	34,	35,	36,	37,	38,	39,
	40,	41,	42,	43,	44,	45,	46,	47,
	48,	49,	50,	51,	52,	53,	54,	55,
	56,	57,	58,	59,	60,	61,	62,	63,
	64,	'a',	'b',	'c',	'd',	'e',	'f',	'g',
	'h',	'i',	'j',	'k',	'l',	'm',	'n',	'o',
	'p',	'q',	'r',	's',	't',	'u',	'v',	'w',
	'x',	'y',	'z',	91,	92,	93,	94,	95,
	96,	'A',	'B',	'C',	'D',	'E',	'F',	'G',
	'H',	'I',	'J',	'K',	'L',	'M',	'N',	'O',
	'P',	'Q',	'R',	'S',	'T',	'U',	'V',	'W',
	'X',	'Y',	'Z',	123,	124,	125,	126,	127,
	128,	129,	130,	131,	132,	133,	134,	135,
	136,	137,	138,	139,	140,	141,	142,	143,
	144,	145,	146,	147,	148,	149,	150,	151,
	152,	153,	154,	155,	156,	157,	158,	159,
	160,	161,	162,	163,	164,	165,	166,	167,
	168,	169,	170,	171,	172,	173,	174,	175,
	176,	177,	178,	179,	180,	181 /*micro */,	182,	183,
	184,	185,	186,	187,	188,	189,	190,	191,
	192+32,	193+32,	194+32,	195+32,	196+32,	197+32,	198+32,	199+32,
	200+32,	201+32,	202+32,	203+32,	204+32,	205+32,	206+32,	207+32,
	208+32,	209+32,	210+32,	211+32,	212+32,	213+32,	214+32,	215,
	216+32,	217+32,	218+32,	219+32,	220+32,	221+32,	222+32,	223 /* ss */,
	224-32,	225-32,	226-32,	227-32,	228-32,	229-32,	230-32,	231-32,
	232-32,	233-32,	234-32,	235-32,	236-32,	237-32,	238-32,	239-32,
	240-32,	241-32,	242-32,	243-32,	244-32,	245-32,	246-32,	247,
	248-32,	249-32,	250-32,	251-32,	252-32,	253-32,	254-32,
	255 /* y with diaeresis */
};
a4444 1
EXTCONST unsigned char PL_fold_latin1[];
a4602 9
#  ifdef FCRYPT
			     " FCRYPT"
#  endif
#  ifdef HAS_TIMES
			     " HAS_TIMES"
#  endif
#  ifdef HAVE_INTERP_INTERN
			     " HAVE_INTERP_INTERN"
#  endif
a4608 3
#  ifdef PERLIO_LAYERS
			     " PERLIO_LAYERS"
#  endif
a4623 3
#  ifdef PERL_MICRO
			     " PERL_MICRO"
#  endif
d4645 3
a4662 6
#  ifdef USE_LOCALE_COLLATE
			     " USE_LOCALE_COLLATE"
#  endif
#  ifdef USE_LOCALE_NUMERIC
			     " USE_LOCALE_NUMERIC"
#  endif
d4680 3
a4682 3
#  endif
#  ifdef VMS_SHORTEN_LONG_SYMBOLS
			     " VMS_SHORTEN_LONG_SYMBOLS"
a4691 39
#ifndef PERL_SET_PHASE
#  define PERL_SET_PHASE(new_phase) \
    PHASE_CHANGE_PROBE(PL_phase_names[new_phase], PL_phase_names[PL_phase]); \
    PL_phase = new_phase;
#endif

/* The interpreter phases. If these ever change, PL_phase_names right below will
 * need to be updated accordingly. */
enum perl_phase {
    PERL_PHASE_CONSTRUCT	= 0,
    PERL_PHASE_START		= 1,
    PERL_PHASE_CHECK		= 2,
    PERL_PHASE_INIT		= 3,
    PERL_PHASE_RUN		= 4,
    PERL_PHASE_END		= 5,
    PERL_PHASE_DESTRUCT		= 6
};

#ifdef DOINIT
EXTCONST char *const PL_phase_names[] = {
    "CONSTRUCT",
    "START",
    "CHECK",
    "INIT",
    "RUN",
    "END",
    "DESTRUCT"
};
#else
EXTCONST char *const PL_phase_names[];
#endif

#ifndef PERL_CORE
/* Do not use this macro. It only exists for extensions that rely on PL_dirty
 * instead of using the newer PL_phase, which provides everything PL_dirty
 * provided, and more. */
#  define PL_dirty (PL_phase == PERL_PHASE_DESTRUCT)
#endif /* !PERL_CORE */

d4724 38
d4769 3
a4771 5
#define HINT_LOCALE_NOT_CHARS	0x00000010 /* locale ':not_characters' pragma */

#define HINT_EXPLICIT_STRICT_REFS	0x00000020 /* strict.pm */
#define HINT_EXPLICIT_STRICT_SUBS	0x00000040 /* strict.pm */
#define HINT_EXPLICIT_STRICT_VARS	0x00000080 /* strict.pm */
a4795 10
#define HINT_RE_FLAGS		0x02000000 /* re '/xism' pragma */

#define HINT_FEATURE_MASK	0x1c000000 /* 3 bits for feature bundles */

				/* Note: Used for NATIVE_HINTS, currently
				   defined by vms/vmsish.h:
				0x40000000
				0x80000000
				 */

d4822 3
a4824 3
typedef void (*peep_t)(pTHX_ OP* o);
typedef regexp* (*regcomp_t) (pTHX_ char* exp, char* xend, PMOP* pm);
typedef I32     (*regexec_t) (pTHX_ regexp* prog, char* stringarg,
d4827 1
a4827 1
typedef char*   (*re_intuit_start_t) (pTHX_ regexp *prog, SV *sv,
d4831 3
a4833 4
typedef SV*	(*re_intuit_string_t) (pTHX_ regexp *prog);
typedef void	(*regfree_t) (pTHX_ struct regexp* r);
typedef regexp* (*regdupe_t) (pTHX_ const regexp* r, CLONE_PARAMS *param);
typedef I32     (*re_fold_t)(const char *, char const *, I32);
d4843 11
a4853 7
typedef OP* (*Perl_ppaddr_t)(pTHX);
typedef OP* (*Perl_check_t) (pTHX_ OP*);
typedef void(*Perl_ophook_t)(pTHX_ OP*);
typedef int (*Perl_keyword_plugin_t)(pTHX_ char*, STRLEN, OP**);
typedef void(*Perl_cpeep_t)(pTHX_ OP *, OP *);

typedef void(*globhook_t)(pTHX);
d4875 7
a4881 1
#if !defined(MULTIPLICITY)
d4883 3
a4885 2
struct interpreter {
    char broiled;
d4888 16
a4903 1
#else
d4905 1
a4911 6
/* Set up PERLVAR macros for populating structs */
#  define PERLVAR(prefix,var,type) type prefix##var;
#  define PERLVARA(prefix,var,n,type) type prefix##var[n];
#  define PERLVARI(prefix,var,type,init) type prefix##var;
#  define PERLVARIC(prefix,var,type,init) type prefix##var;

d4916 3
a4918 20
EXTCONST U16 PL_interp_size
  INIT(sizeof(struct interpreter));

#  define PERL_INTERPRETER_SIZE_UPTO_MEMBER(member)			\
    STRUCT_OFFSET(struct interpreter, member) +				\
    sizeof(((struct interpreter*)0)->member)

/* This will be useful for subsequent releases, because this has to be the
   same in your libperl as in main(), else you have a mismatch and must abort.
*/
EXTCONST U16 PL_interp_size_5_16_0
  INIT(PERL_INTERPRETER_SIZE_UPTO_MEMBER(PERL_LAST_5_16_0_INTERP_MEMBER));


#  ifdef PERL_GLOBAL_STRUCT
/* MULTIPLICITY is automatically defined when PERL_GLOBAL_STRUCT is defined,
   hence it's safe and sane to nest this within #ifdef MULTIPLICITY  */

struct perl_vars {
#    include "perlvars.h"
d4920 1
a4920 20

EXTCONST U16 PL_global_struct_size
  INIT(sizeof(struct perl_vars));

#    ifdef PERL_CORE
#      ifndef PERL_GLOBAL_STRUCT_PRIVATE
EXT struct perl_vars PL_Vars;
EXT struct perl_vars *PL_VarsPtr INIT(&PL_Vars);
#        undef PERL_GET_VARS
#        define PERL_GET_VARS() PL_VarsPtr
#      endif /* !PERL_GLOBAL_STRUCT_PRIVATE */
#    else /* PERL_CORE */
#      if !defined(__GNUC__) || !defined(WIN32)
EXT
#      endif /* WIN32 */
struct perl_vars *PL_VarsPtr;
#      define PL_Vars (*((PL_VarsPtr) \
		       ? PL_VarsPtr : (PL_VarsPtr = Perl_GetVars(aTHX))))
#    endif /* PERL_CORE */
#  endif /* PERL_GLOBAL_STRUCT */
d4923 5
a4927 6
#  undef PERLVAR
#  undef PERLVARA
#  undef PERLVARI
#  undef PERLVARIC

#endif /* MULTIPLICITY */
a4945 4
#ifdef MYMALLOC
#  include "malloc_ctl.h"
#endif

d4968 5
a4972 4
#define PERLVAR(prefix,var,type) EXT type PL_##var;
#define PERLVARA(prefix,var,n,type) EXT type PL_##var[n];
#define PERLVARI(prefix,var,type,init) EXT type  PL_##var INIT(init);
#define PERLVARIC(prefix,var,type,init) EXTCONST type PL_##var INIT(init);
d4985 7
a4991 7
/* Now all the config stuff is setup we can include embed.h
   In particular, need the relevant *ish file included already, as it may
   define HAVE_INTERP_INTERN  */
#include "embed.h"
#ifndef PERL_MAD
#  undef op_getmad
#  define op_getmad(arg,pegop,slot) NOOP
a5008 8
/* dummy variables that hold pointers to both runops functions, thus forcing
 * them *both* to get linked in (useful for Peek.xs, debugging etc) */

EXTCONST runops_proc_t PL_runops_std
  INIT(Perl_runops_standard);
EXTCONST runops_proc_t PL_runops_dbg
  INIT(Perl_runops_debug);

a5017 10
#define PERL_MAGIC_READONLY_ACCEPTABLE 0x40
#define PERL_MAGIC_VALUE_MAGIC 0x80
#define PERL_MAGIC_VTABLE_MASK 0x3F
#define PERL_MAGIC_TYPE_READONLY_ACCEPTABLE(t) \
    (PL_magic_data[(U8)(t)] & PERL_MAGIC_READONLY_ACCEPTABLE)
#define PERL_MAGIC_TYPE_IS_VALUE_MAGIC(t) \
    (PL_magic_data[(U8)(t)] & PERL_MAGIC_VALUE_MAGIC)

#include "mg_vtable.h"

d5019 7
a5025 9
EXTCONST U8 PL_magic_data[256] =
#  ifdef PERL_MICRO
#    include "umg_data.h"
#  else
#    include "mg_data.h"
#  endif
;
#else
EXTCONST U8 PL_magic_data[256];
d5028 52
a5079 25
#ifdef DOINIT
		        /* NL BD IV NV PV PI PN MG RX GV LV AV HV CV FM IO */
EXTCONST bool
PL_valid_types_IVX[]    = { 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0 };
EXTCONST bool
PL_valid_types_NVX[]    = { 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0 };
EXTCONST bool
PL_valid_types_PVX[]    = { 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1 };
EXTCONST bool
PL_valid_types_RV[]     = { 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1 };
EXTCONST bool
PL_valid_types_IV_set[] = { 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1 };
EXTCONST bool
PL_valid_types_NV_set[] = { 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0 };

#else

EXTCONST bool PL_valid_types_IVX[];
EXTCONST bool PL_valid_types_NVX[];
EXTCONST bool PL_valid_types_PVX[];
EXTCONST bool PL_valid_types_RV[];
EXTCONST bool PL_valid_types_IV_set[];
EXTCONST bool PL_valid_types_NV_set[];

#endif
d5081 363
d5450 1
a5450 3
  U8 flags;
  U8 fallback;
  U16 spare;
d5453 1
d5457 1
a5457 3
  U8 flags;
  U8 fallback;
  U16 spare;
d5528 1
a5528 1
#define PERLDBf_SAVESRC_NOSUBS	0x800	/* Including evals that generate no subroutines */
a5552 2
/* Returns non-zero If the plain locale pragma without a parameter is in effect
 */
a5553 5

/* Returns non-zero If either form of the locale pragma is in effect */
#define IN_SOME_LOCALE_FORM_RUNTIME   \
		(CopHINTS_get(PL_curcop) & (HINT_LOCALE|HINT_LOCALE_NOT_CHARS))

a5554 2
#define IN_SOME_LOCALE_FORM_COMPILETIME \
			    (PL_hints & (HINT_LOCALE|HINT_LOCALE_NOT_CHARS))
a5557 3
#define IN_SOME_LOCALE_FORM \
	(IN_PERL_COMPILETIME ? IN_SOME_LOCALE_FORM_COMPILETIME \
	                     : IN_SOME_LOCALE_FORM_RUNTIME)
d5685 1
a5685 1
#		define PERL_ASYNC_CHECK() if (PL_sig_pending) PL_signalhook(aTHX)
d5759 3
a5761 1
/* START_MY_CXT must appear in all extensions that define a my_cxt_t structure,
d5764 2
a5765 9
#  ifdef PERL_GLOBAL_STRUCT_PRIVATE
#    define START_MY_CXT
#    define MY_CXT_INDEX Perl_my_cxt_index(aTHX_ MY_CXT_KEY)
#    define MY_CXT_INIT_ARG MY_CXT_KEY
#  else
#    define START_MY_CXT static int my_cxt_index = -1;
#    define MY_CXT_INDEX my_cxt_index
#    define MY_CXT_INIT_ARG &my_cxt_index
#  endif /* #ifdef PERL_GLOBAL_STRUCT_PRIVATE */
d5770 1
a5770 1
#  define MY_CXT_INIT \
d5772 2
a5773 3
	    (my_cxt_t*)Perl_my_cxt_init(aTHX_ MY_CXT_INIT_ARG, sizeof(my_cxt_t)); \
	PERL_UNUSED_VAR(my_cxtp)
#  define MY_CXT_INIT_INTERP(my_perl) \
d5775 1
a5775 2
	    (my_cxt_t*)Perl_my_cxt_init(my_perl, MY_CXT_INIT_ARG, sizeof(my_cxt_t)); \
	PERL_UNUSED_VAR(my_cxtp)
d5779 1
a5779 1
#  define dMY_CXT	\
d5781 1
a5781 1
#  define dMY_CXT_INTERP(my_perl)	\
d5785 1
a5785 1
#  define MY_CXT_CLONE \
d5790 31
d5823 2
a5824 2
 * e.g. MY_CXT.some_data */
#  define MY_CXT		(*my_cxtp)
d5828 6
a5833 6
#  define pMY_CXT	my_cxt_t *my_cxtp
#  define pMY_CXT_	pMY_CXT,
#  define _pMY_CXT	,pMY_CXT
#  define aMY_CXT	my_cxtp
#  define aMY_CXT_	aMY_CXT,
#  define _aMY_CXT	,aMY_CXT
d5837 14
a5850 14
#  define START_MY_CXT		static my_cxt_t my_cxt;
#  define dMY_CXT_SV	    	dNOOP
#  define dMY_CXT		dNOOP
#  define dMY_CXT_INTERP(my_perl) dNOOP
#  define MY_CXT_INIT		NOOP
#  define MY_CXT_CLONE		NOOP
#  define MY_CXT		my_cxt

#  define pMY_CXT		void
#  define pMY_CXT_
#  define _pMY_CXT
#  define aMY_CXT
#  define aMY_CXT_
#  define _aMY_CXT
a5926 2
#define PERL_SCAN_SILENT_NON_PORTABLE 0x08 /* grok_??? not warn about very large
					      numbers which are <= UV_MAX */
d6016 30
a6085 1
#define PERL_PV_ESCAPE_NONASCII     0x0400
d6096 1
a6096 1
#define PERL_PV_PRETTY_REGPROP PERL_PV_PRETTY_ELLIPSES|PERL_PV_PRETTY_LTGT|PERL_PV_ESCAPE_RE|PERL_PV_ESCAPE_NONASCII
@


1.1.1.15
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d51 9
d103 2
a104 2
#if defined(__SYMBIAN32__)
/* Symbian: need to work around the SDK features. *
d169 1
a169 1
#define pVAR    struct perl_vars* my_vars PERL_UNUSED_DECL
d182 1
a182 1
#  define pTHX  tTHX my_perl PERL_UNUSED_DECL
a183 1
#  define aTHXa(a) aTHX = (tTHX)a
a361 3
#ifdef __cplusplus
#define dNOOP (void)0
#else
a362 1
#endif
a371 1
#  define aTHXa(a)      NOOP
d400 1
a400 1
#  define pTHXx		PerlInterpreter *my_perl
d448 1
a448 1
struct op *Perl_op asm(stringify(OP_IN_REGISTER));
d518 1
a518 1
#if defined(MSDOS) || defined(WIN32) || defined(NETWARE)
d522 1
a522 1
#if defined(__STDC__) || defined(_AIX) || defined(__stdc__) || defined(__cplusplus) || defined(NETWARE) || defined(__SYMBIAN32__)
d526 1
a526 1
#if defined(__cplusplus) || defined(WIN32) || defined(__sgi) || defined(__EMX__) || defined(__DGUX) || defined(__QNX__) || defined(NETWARE) || defined(PERL_MICRO)
d536 5
a540 48
/* By compiling a perl with -DNO_TAINT_SUPPORT or -DSILENT_NO_TAINT_SUPPORT,
 * you get a perl without taint support, but doubtlessly with a lesser
 * degree of support. Do not do so unless you know exactly what it means
 * technically, have a good reason to do so, and know exactly how the
 * perl will be used. perls with -DSILENT_NO_TAINT_SUPPORT are considered
 * a potential security risk due to flat out ignoring the security-relevant
 * taint flags. This being said, a perl without taint support compiled in
 * has marginal run-time performance benefits.
 * SILENT_NO_TAINT_SUPPORT implies NO_TAINT_SUPPORT.
 * SILENT_NO_TAINT_SUPPORT is the same as NO_TAINT_SUPPORT except it
 * silently ignores -t/-T instead of throwing an exception.
 *
 * DANGER! Using NO_TAINT_SUPPORT or SILENT_NO_TAINT_SUPPORT
 *         voids your nonexistent warranty!
 */
#if SILENT_NO_TAINT_SUPPORT && !defined(NO_TAINT_SUPPORT)
#  define NO_TAINT_SUPPORT 1
#endif

/* NO_TAINT_SUPPORT can be set to transform virtually all taint-related
 * operations into no-ops for a very modest speed-up. Enable only if you
 * know what you're doing: tests and CPAN modules' tests are bound to fail.
 */
#if NO_TAINT_SUPPORT
#   define TAINT		NOOP
#   define TAINT_NOT		NOOP
#   define TAINT_IF(c)		NOOP
#   define TAINT_ENV()		NOOP
#   define TAINT_PROPER(s)	NOOP
#   define TAINT_set(s)		NOOP
#   define TAINT_get		0
#   define TAINTING_get		0
#   define TAINTING_set(s)	NOOP
#   define TAINT_WARN_get       0
#   define TAINT_WARN_set(s)    NOOP
#else
#   define TAINT		(PL_tainted = TRUE)
#   define TAINT_NOT	(PL_tainted = FALSE)
#   define TAINT_IF(c)	if (UNLIKELY(c)) { PL_tainted = TRUE; }
#   define TAINT_ENV()	if (UNLIKELY(PL_tainting)) { taint_env(); }
#   define TAINT_PROPER(s)	if (UNLIKELY(PL_tainting)) { taint_proper(NULL, s); }
#   define TAINT_set(s)		(PL_tainted = (s))
#   define TAINT_get		(PL_tainted)
#   define TAINTING_get		(PL_tainting)
#   define TAINTING_set(s)	(PL_tainting = (s))
#   define TAINT_WARN_get       (PL_taint_warn)
#   define TAINT_WARN_set(s)    (PL_taint_warn = (s))
#endif
a736 2
#  elif QUADKIND == QUAD_IS___INT64
#   define U64_CONST(x) ((U64)x##UI64)
d973 1
a973 1
#if !defined(OS2) && !defined(WIN32) && !defined(DJGPP) && !defined(__SYMBIAN32__)
d1178 1
a1178 1
/* The stat macros for Unisoft System V/88 (and derivatives
d1187 1
a1187 1
#if defined(m88k) && defined(ghs)
a1383 1
#ifndef DONT_DECLARE_STD
d1387 1
d1389 1
a1390 1
#endif
d1602 1
a1602 1
/* Haiku R1 seems to define S_IREAD and S_IWRITE in <posix/fcntl.h>
d1606 1
a1606 1
#if !defined(S_IREAD) && !defined(__HAIKU__)
d1610 1
a1610 1
#if !defined(S_IWRITE) && !defined(__HAIKU__)
d1630 4
d1674 1
a1674 1
#      define my_vsnprintf(buffer, len, ...) ({ int __len__ = vsnprintf(buffer, len, __VA_ARGS__); if ((len) > 0 && (Size_t)__len__ >= (Size_t)(len)) Perl_croak_nocontext("panic: vsnprintf buffer overflow"); __len__; })
d1696 7
d1768 5
a2416 5
#ifdef PERL_CORE
typedef struct opslab OPSLAB;
typedef struct opslot OPSLOT;
#endif

d2422 1
d2424 1
a2424 1
#if defined(__sgi)
a2459 23
/* a pad or name pad is currently just an AV; but that might change,
 * so hide the type.  */
typedef struct padlist PADLIST;
typedef AV PAD;
typedef AV PADNAMELIST;
typedef SV PADNAME;

/* XXX for 5.18, disable the COW by default
 * #if !defined(PERL_OLD_COPY_ON_WRITE) && !defined(PERL_NEW_COPY_ON_WRITE) && !defined(PERL_NO_COW)
 * # define PERL_NEW_COPY_ON_WRITE
 * #endif
 */

#if defined(PERL_OLD_COPY_ON_WRITE) || defined(PERL_NEW_COPY_ON_WRITE)
# if defined(PERL_OLD_COPY_ON_WRITE) && defined(PERL_NEW_COPY_ON_WRITE)
#  error PERL_OLD_COPY_ON_WRITE and PERL_NEW_COPY_ON_WRITE are exclusive
# else
#  define PERL_ANY_COW
# endif
#else
# define PERL_SAWAMPERSAND
#endif

d2566 5
d2590 5
d2604 5
d2618 3
d2724 1
a2724 1
=for apidoc Am|void|PERL_SYS_INIT|int *argc|char*** argv
d2729 1
a2729 1
=for apidoc Am|void|PERL_SYS_INIT3|int *argc|char*** argv|char*** env
d3280 1
a3280 1
#  define NORETURN_FUNCTION_END assert(0); /* NOTREACHED */
d3282 1
a3282 1
#  define NORETURN_FUNCTION_END assert(0); /* NOTREACHED */ return 0
d3467 2
a3468 1
    SV *repl;		/* replacement of s/// or y/// */
d3493 4
d3622 1
a3622 1
#if !(defined(WIN32) || defined(UNDER_CE) || defined(SYMBIAN))
d3661 1
a3661 1
#define DEBUG_S_FLAG		0x00010000 /*  65536 */
d3671 1
a3671 1
#define DEBUG_MASK		0x03FFEFFF /* mask of all the standard flags */
a3692 1
#  define DEBUG_S_TEST_ (PL_debug & DEBUG_S_FLAG)
a3723 1
#  define DEBUG_S_TEST DEBUG_S_TEST_
a3774 1
#  define DEBUG_S(a) DEBUG__(DEBUG_S_TEST, a)
a3801 1
#  define DEBUG_S_TEST (0)
a3832 1
#  define DEBUG_S(a)
a3868 5
#ifdef DEBUGGING
#  define assert_(what)	assert(what),
#else
#  define assert_(what)
#endif
d3910 1
a3910 1
#if defined(OEMVS)
d4001 1
a4001 1
#    if !defined(HAS_LSEEK_PROTO) && !defined(__hpux)
d4009 1
a4009 2
#  ifndef WIN32
#    ifndef getlogin
d4011 1
a4011 2
#    endif
#  endif /* !WIN32 */
d4238 1
a4238 1
EXTCONST char PL_no_mem[sizeof("Out of memory!\n")]
a4474 1
#ifndef EBCDIC
a4476 1
#endif
d4598 1
a4598 3
/* Although only used for debugging, these constants must be available in
 * non-debugging builds too, since they're used in ext/re/re_exec.c,
 * which has DEBUGGING enabled always */
d4617 1
a4679 3
#  ifdef PERL_NEW_COPY_ON_WRITE
			     " PERL_NEW_COPY_ON_WRITE"
#  endif
a4682 3
#  ifdef PERL_SAWAMPERSAND
			     " PERL_SAWAMPERSAND"
#  endif
d4689 3
a4778 2

#  define PL_amagic_generation PL_na
a4864 11
/* flags for PL_sawampersand */

#define SAWAMPERSAND_LEFT       1   /* saw $` */
#define SAWAMPERSAND_MIDDLE     2   /* saw $& */
#define SAWAMPERSAND_RIGHT      4   /* saw $' */

#ifndef PERL_SAWAMPERSAND
# define PL_sawampersand \
	(SAWAMPERSAND_LEFT|SAWAMPERSAND_MIDDLE|SAWAMPERSAND_RIGHT)
#endif

a4950 2

/* 'var' is an array of length 'n' */
a4951 2

/* initialize 'var' to init' */
a4952 2

/* like PERLVARI, but make 'var' a const */
d4969 2
a4970 2
EXTCONST U16 PL_interp_size_5_18_0
  INIT(PERL_INTERPRETER_SIZE_UPTO_MEMBER(PERL_LAST_5_18_0_INTERP_MEMBER));
a5020 18
#ifndef PERL_CALLCONV_NO_RET
#    define PERL_CALLCONV_NO_RET PERL_CALLCONV
#endif

/* PERL_STATIC_NO_RET is supposed to be equivalent to STATIC on builds that
   dont have a noreturn as a declaration specifier
*/
#ifndef PERL_STATIC_NO_RET
#  define PERL_STATIC_NO_RET STATIC
#endif
/* PERL_STATIC_NO_RET is supposed to be equivalent to PERL_STATIC_INLINE on
   builds that dont have a noreturn as a declaration specifier
*/
#ifndef PERL_STATIC_INLINE_NO_RET
#  define PERL_STATIC_INLINE_NO_RET PERL_STATIC_INLINE
#endif


d5138 1
a5138 1
PL_valid_types_PVX[]    = { 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1 };
a5156 15
#ifndef PERL_NO_INLINE_FUNCTIONS
/* Static inline funcs that depend on includes and declarations above.
   Some of these reference functions in the perl object files, and some
   compilers aren't smart enough to eliminate unused static inline
   functions, so including this file in source code can cause link errors
   even if the source code uses none of the functions. Hence including these
   can be be suppressed by setting PERL_NO_INLINE_FUNCTIONS. Doing this will
   (obviously) result in unworkable XS code, but allows simple probing code
   to continue to work, because it permits tests to include the perl headers
   for definitions without creating a link dependency on the perl library
   (which may not exist yet).
*/

#  include "inline.h"
#endif
d5167 1
d5175 1
d5185 1
d5189 3
a5313 1
#define IN_LOCALE_COMPILETIME		0
d5317 1
a5317 2
#if !defined(Strtol) && defined(USE_64_BIT_INT) && defined(IV_IS_QUAD) && \
	(QUADKIND == QUAD_IS_LONG_LONG || QUADKIND == QUAD_IS___INT64)
d5339 1
a5339 2
#   if defined(USE_64_BIT_INT) && defined(IV_IS_QUAD) && defined(HAS_ATOLL) && \
	(QUADKIND == QUAD_IS_LONG_LONG || QUADKIND == QUAD_IS___INT64)
d5349 1
a5349 2
#if !defined(Strtoul) && defined(USE_64_BIT_INT) && defined(UV_IS_QUAD) && \
	(QUADKIND == QUAD_IS_LONG_LONG || QUADKIND == QUAD_IS___INT64)
d5593 4
a5596 3
#   if defined(__HAIKU__) || defined(__VOS__) || defined(__CYGWIN__)
    /* Haiku has O_TEXT != O_BINARY but O_TEXT and O_BINARY have no effect;
     * Haiku is always UNIXoid (LF), not DOSish (CRLF). */
d5650 9
a5658 1
#define NEXT_LINE_CHAR	NEXT_LINE_NATIVE
d5831 1
a5831 1
 * indent-tabs-mode: nil
d5834 1
a5834 1
 * ex: set ts=8 sts=4 sw=4 et:
@


1.1.1.16
log
@Import perl-5.20.1
@
text
@d25 9
d37 5
a41 1
#   include "config.h"
d102 1
a102 1
/* Use the reentrant APIs like localtime_r and getpwent_r */
d110 9
a118 3
/* Microsoft Visual C++ 6.0 needs special treatment in numerous places */
#if defined(WIN32) && defined(_MSC_VER) && _MSC_VER >= 1200 && _MSC_VER < 1300
#  define USING_MSVC6
a196 1
#  define pTHX_12	13
d228 1
a228 1
#define CALLREGEXEC(prog,stringarg,strend,strbeg,minend,sv,data,flags) \
d230 3
a232 3
        (strbeg),(minend),(sv),(data),(flags))
#define CALLREG_INTUIT_START(prog,sv,strbeg,strpos,strend,flags,data) \
    RX_ENGINE(prog)->intuit(aTHX_ (prog), (sv), (strbeg), (strpos), \
a347 72
/* gcc (-ansi) -pedantic doesn't allow gcc statement expressions,
 * g++ allows them but seems to have problems with them
 * (insane errors ensue).
 * g++ does not give insane errors now (RMB 2008-01-30, gcc 4.2.2).
 */
#if defined(PERL_GCC_PEDANTIC) || \
    (defined(__GNUC__) && defined(__cplusplus) && \
	((__GNUC__ < 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ < 2))))
#  ifndef PERL_GCC_BRACE_GROUPS_FORBIDDEN
#    define PERL_GCC_BRACE_GROUPS_FORBIDDEN
#  endif
#endif

/* Use PERL_UNUSED_RESULT() to suppress the warnings about unused results
 * of function calls, e.g. PERL_UNUSED_RESULT(foo(a, b)).
 *
 * The main reason for this is that the combination of gcc -Wunused-result
 * (part of -Wall) and the __attribute__((warn_unused_result)) cannot
 * be silenced with casting to void.  This causes trouble when the system
 * header files use the attribute.
 *
 * Use PERL_UNUSED_RESULT sparingly, though, since usually the warning
 * is there for a good reason: you might lose success/failure information,
 * or leak resources, or changes in resources.
 *
 * But sometimes you just want to ignore the return value, e.g. on
 * codepaths soon ending up in abort, or in "best effort" attempts,
 * or in situations where there is no good way to handle failures.
 *
 * Sometimes PERL_UNUSED_RESULT might not be the most natural way:
 * another possibility is that you can capture the return value
 * and use PERL_UNUSED_VAR on that.
 *
 * The __typeof__() is used instead of typeof() since typeof() is not
 * available under strict C89, and because of compilers masquerading
 * as gcc (clang and icc), we want exactly the gcc extension
 * __typeof__ and nothing else.
 */
#ifndef PERL_UNUSED_RESULT
#  if defined(__GNUC__) && defined(HASATTRIBUTE_WARN_UNUSED_RESULT)
#    define PERL_UNUSED_RESULT(v) STMT_START { __typeof__(v) z = (v); (void)sizeof(z); } STMT_END
#  else
#    define PERL_UNUSED_RESULT(v) ((void)(v))
#  endif
#endif

/* on gcc (and clang), specify that a warning should be temporarily
 * ignored; e.g.
 *
 *    GCC_DIAG_IGNORE(-Wmultichar);
 *    char b = 'ab';
 *    GCC_DIAG_RESTORE;
 *
 * based on http://dbp-consulting.com/tutorials/SuppressingGCCWarnings.html
 *
 * Note that "pragma GCC diagnostic push/pop" was added in GCC 4.6, Mar 2011;
 * clang only pretends to be GCC 4.2, but still supports push/pop.
 */

#if defined(__clang) || \
       (defined( __GNUC__) && ((__GNUC__ * 100) + __GNUC_MINOR__) >= 406)
#  define GCC_DIAG_DO_PRAGMA_(x) _Pragma (#x)

#  define GCC_DIAG_IGNORE(x) _Pragma("GCC diagnostic push") \
                             GCC_DIAG_DO_PRAGMA_(GCC diagnostic ignored #x)
#  define GCC_DIAG_RESTORE   _Pragma("GCC diagnostic pop")
#else
#  define GCC_DIAG_IGNORE(w)
#  define GCC_DIAG_RESTORE
#endif


d361 1
a361 1
/* Don't bother defining tTHX ; using it outside
a379 1
#  define pTHX_12	12
d441 21
d480 5
d487 1
d523 1
a523 1
#if defined(__cplusplus) || defined(WIN32) || defined(__sgi) || defined(__EMX__) || defined(__QNX__) || defined(NETWARE) || defined(PERL_MICRO)
d548 1
a548 1
#if defined(SILENT_NO_TAINT_SUPPORT) && !defined(NO_TAINT_SUPPORT)
d556 1
a556 1
#ifdef NO_TAINT_SUPPORT
d648 5
a652 1
#include <sys/types.h>
a697 2
#   define HAS_SKIP_LOCALE_INIT /* Solely for XS code to test for this
                                   capability */
a707 9
#   if !defined(NO_LOCALE_MESSAGES) && defined(LC_MESSAGES)
#	define USE_LOCALE_MESSAGES
#   endif
#   if !defined(NO_LOCALE_MONETARY) && defined(LC_MONETARY)
#	define USE_LOCALE_MONETARY
#   endif
#   ifndef WIN32    /* No wrapper except on Windows */
#       define my_setlocale(a,b) setlocale(a,b)
#   endif
a718 10
/* On BSD-derived systems, <sys/param.h> defines BSD to a year-month
   value something like 199306.  This may be useful if no more-specific
   feature test is available.
*/
#if defined(BSD)
#   ifndef BSDish
#       define BSDish
#   endif
#endif

d738 1
a738 1
#if defined(HAS_SYSCALL) && !defined(HAS_SYSCALL_PROTO)
d742 1
a742 1
#if defined(HAS_USLEEP) && !defined(HAS_USLEEP_PROTO)
d746 9
d807 183
d1160 3
d1203 6
d1324 1
a1324 1
#  if defined(BSDish)
d1359 6
a1378 25
#ifdef WIN32
#   define dSAVEDERRNO  int saved_errno; DWORD saved_win32_errno
#   define dSAVE_ERRNO  int saved_errno = errno; DWORD saved_win32_errno = GetLastError()
#   define SAVE_ERRNO   ( saved_errno = errno, saved_win32_errno = GetLastError() )
#   define RESTORE_ERRNO ( errno = saved_errno, SetLastError(saved_win32_errno) )
#endif

#ifdef OS2
#   define dSAVEDERRNO  int saved_errno; unsigned long saved_os2_errno
#   define dSAVE_ERRNO  int saved_errno = errno; unsigned long saved_os2_errno = Perl_rc
#   define SAVE_ERRNO   ( saved_errno = errno, saved_os2_errno = Perl_rc )
#   define RESTORE_ERRNO ( errno = saved_errno, Perl_rc = saved_os2_errno )
#endif

#ifndef SETERRNO
#   define SETERRNO(errcode,vmserrcode) (errno = (errcode))
#endif

#ifndef dSAVEDERRNO
#   define dSAVEDERRNO    int saved_errno
#   define dSAVE_ERRNO    int saved_errno = errno
#   define SAVE_ERRNO     (saved_errno = errno)
#   define RESTORE_ERRNO  (errno = saved_errno)
#endif

d1415 2
a1424 2
#define UNKNOWN_ERRNO_MSG "(unknown)"

d1426 1
a1426 1
#   ifndef DONT_DECLARE_STD
d1432 4
a1435 4
#    endif
#    ifndef Strerror
#       define Strerror strerror
#    endif
d1442 1
a1442 1
		((e) < 0 || (e) >= sys_nerr ? UNKNOWN_ERRNO_MSG : sys_errlist[e])
d1497 13
d1516 1
a1516 1
#if defined(I_SYSMODE)
d1660 4
a1787 5
#if !defined(PERL_CORE) || defined(USING_MSVC6)
/* We think that removing this decade-old undef this will cause too much
   breakage on CPAN for too little gain. (See RT #119753)
   However, we do need HAS_QUAD in the core for use by the drand48 code,
   but not for Win32 VC6 because it has poor __int64 support. */
a1788 1
#endif
d1792 6
a1797 1
#define SSize_t_MAX (SSize_t)(~(size_t)0 >> 1)
d2112 1
a2112 1
#if !defined(Perl_fp_class) && defined(HAS_FP_CLASS)
d2421 3
a2476 1
typedef struct xpvinvlist XINVLIST;
d2497 5
a2501 4
/* enable PERL_NEW_COPY_ON_WRITE by default */
#if !defined(PERL_OLD_COPY_ON_WRITE) && !defined(PERL_NEW_COPY_ON_WRITE) && !defined(PERL_NO_COW)
#  define PERL_NEW_COPY_ON_WRITE
#endif
d2625 4
a2628 1
#elif defined(VMS)
d2630 4
a2633 1
#elif defined(PLAN9)
d2635 4
a2638 1
#elif defined(__VOS__)
d2644 4
a2647 1
#elif defined(__SYMBIAN32__)
d2649 5
a2653 1
#elif defined(__HAIKU__)
d2655 4
a2658 1
#else
d2660 1
d2761 1
a2761 1
run Perl interpreters.  This should be called only once, before creating
d2766 1
a2766 1
run Perl interpreters.  This should be called only once, before creating
d2771 1
a2771 1
running Perl interpreters.  This should be called only once, after
d2865 3
d2894 2
a2895 1
#  endif /* NETWARE */
a3147 2
#define PERL_EXIT_WARN		0x04  /* Warn if Perl_my_exit() or Perl_my_failure_exit() called */
#define PERL_EXIT_ABORT		0x08  /* Call abort() if Perl_my_exit() or Perl_my_failure_exit() called */
d3169 1
a3169 1
# if defined(USE_PERLIO) || defined(FFLUSH_NULL)
d3242 7
a3248 3
/* Takes three arguments: is_utf8, length, str */
#ifndef UTF8f
#  define UTF8f "d%" UVuf "%4p"
a3249 1
#define UTF8fARG(u,l,p) (int)cBOOL(u), (UV)(l), (void*)(p)
d3315 1
a3315 1
#  define NORETURN_FUNCTION_END NOT_REACHED; /* NOTREACHED */
d3317 1
a3317 1
#  define NORETURN_FUNCTION_END NOT_REACHED; /* NOTREACHED */ return 0
d3332 2
a3333 2
#define LIKELY(cond)                        EXPECT(cBOOL(cond),TRUE)
#define UNLIKELY(cond)                      EXPECT(cBOOL(cond),FALSE)
a3337 33

#ifndef __has_builtin
#  define __has_builtin(x) 0 /* not a clang style compiler */
#endif

/* ASSUME is like assert(), but it has a benefit in a release build. It is a
   hint to a compiler about a statement of fact in a function call free
   expression, which allows the compiler to generate better machine code.
   In a debug build, ASSUME(x) is a synonym for assert(x). ASSUME(0) means
   the control path is unreachable. In a for loop, ASSUME can be used to hint
   that a loop will run atleast X times. ASSUME is based off MSVC's __assume
   intrinsic function, see its documents for more details.
*/

#ifndef DEBUGGING
#  if __has_builtin(__builtin_unreachable) \
     || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5 || __GNUC__ > 5) /* 4.5 -> */
#    define ASSUME(x) ((x) ? (void) 0 : __builtin_unreachable())
#  elif defined(_MSC_VER)
#    define ASSUME(x) __assume(x)
#  elif defined(__ARMCC_VERSION) /* untested */
#    define ASSUME(x) __promise(x)
#  else
/* a random compiler might define assert to its own special optimization token
   so pass it through to C lib as a last resort */
#    define ASSUME(x) assert(x)
#  endif
#else
#  define ASSUME(x) assert(x)
#endif

#define NOT_REACHED ASSUME(0)

a3385 1
    U32		any_u32;
d3405 1
a3405 1
		&& (i) <= av_tindex(PL_parser->rsfp_filters))
d3509 2
a3510 19
#if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_REGEXEC_C)

/* These have to be predeclared, as they are used in proto.h which is #included
 * before their definitions in regcomp.h. */

struct scan_data_t;
typedef struct regnode_charclass regnode_charclass;

struct regnode_charclass_class;

/* A hopefully less confusing name.  The sub-classes are all Posix classes only
 * used under /l matching */
typedef struct regnode_charclass_class regnode_charclass_posixl;

typedef struct regnode_ssc regnode_ssc;
typedef struct RExC_state_t RExC_state_t;
struct _reg_trie_data;

#endif
d3540 1
d3545 13
a3557 45
#  if (BYTEORDER & 0xffff) == 0x4321
/* Big endian system, so ntohl, ntohs, htonl and htons do not need to
   re-order their values. However, to behave identically to the alternative
   implementations, they should truncate to the correct size.  */
#    define ntohl(x)    ((x)&0xFFFFFFFF)
#    define htonl(x)    ntohl(x)
#    define ntohs(x)    ((x)&0xFFFF)
#    define htons(x)    ntohs(x)
#  elif BYTEORDER == 0x1234 || BYTEORDER == 0x12345678

/* Note that we can't straight out declare our own htonl and htons because
   the Win32 build process forcibly undefines HAS_HTONL etc for its miniperl,
   to avoid the overhead of initialising the socket subsystem, but the headers
   that *declare* the various functions are still seen. If we declare our own
   htonl etc they will clash with the declarations in the Win32 headers.  */

PERL_STATIC_INLINE U32
my_swap32(const U32 x) {
    return ((x & 0xFF) << 24) | ((x >> 24) & 0xFF)	
        | ((x & 0x0000FF00) << 8) | ((x & 0x00FF0000) >> 8);
}

PERL_STATIC_INLINE U16
my_swap16(const U16 x) {
    return ((x & 0xFF) << 8) | ((x >> 8) & 0xFF);
}

#    define htonl(x)    my_swap32(x)
#    define ntohl(x)    my_swap32(x)
#    define ntohs(x)    my_swap16(x)
#    define htons(x)    my_swap16(x)
#  else
#    error "Unsupported byteorder"
/* The C pre-processor doesn't let us return the value of BYTEORDER as part of
   the error message. Please check the value of the macro BYTEORDER, as defined
   in config.h. The values of BYTEORDER we expect are

	    big endian  little endian
   32 bit       0x4321  0x1234
   64 bit   0x87654321  0x12345678

   If you have a system with a different byte order, please see
   pod/perlhack.pod for how to submit a patch to add supporting code.
*/
#  endif
d3564 6
a3569 9
#if BYTEORDER == 0x1234 || BYTEORDER == 0x12345678
/* Little endian system, so vtohl, vtohs, htovl and htovs do not need to
   re-order their values. However, to behave identically to the alternative
   implementations, they should truncate to the correct size.  */
#  define vtohl(x)      ((x)&0xFFFFFFFF)
#  define vtohs(x)      ((x)&0xFFFF)
#  define htovl(x)      vtohl(x)
#  define htovs(x)      vtohs(x)
#elif BYTEORDER == 0x4321 || BYTEORDER == 0x87654321
d3577 8
a3584 5
#else
#  error "Unsupported byteorder"
/* If you have need for current perl on PDP-11 or similar, and can help test
   that blead keeps working on a mixed-endian system, then see
   pod/perlhack.pod for how to submit patches to things working again.  */
d3622 2
a3623 2
#define I_V(n) (LIKELY((n) < IV_MAX_P1) ? (UNLIKELY((n) < IV_MIN) ? IV_MIN : (IV) (n)) \
                  : (LIKELY((n) < UV_MAX_P1) ? (IV)(UV) (n) \
d3625 2
a3626 2
#define U_V(n) ((n) < 0.0 ? (UNLIKELY((n) < IV_MIN) ? (UV) IV_MIN : (UV)(IV) (n)) \
                  : (LIKELY((n) < UV_MAX_P1) ? (UV) (n) \
d3701 1
a3701 2
#define DEBUG_L_FLAG		0x04000000 /*67108864*/
#define DEBUG_MASK		0x07FFEFFF /* mask of all the standard flags */
a3732 1
#  define DEBUG_L_TEST_ (PL_debug & DEBUG_L_FLAG)
a3764 1
#  define DEBUG_L_TEST DEBUG_L_TEST_
a3815 1
#  define DEBUG_L(a) DEBUG__(DEBUG_L_TEST, a)
a3844 1
#  define DEBUG_L_TEST (0)
a3875 1
#  define DEBUG_L(a)
d4108 1
a4108 1
#if defined(USE_PERLIO)
d4153 1
a4153 1
#  if defined(PERL_POISON) || defined(PERL_DEBUG_READONLY_COW)
a4157 10
#  ifdef PERL_DEBUG_READONLY_COW
  bool readonly;
#  endif
};

#elif defined(PERL_DEBUG_READONLY_COW)

struct perl_memory_debug_header;
struct perl_memory_debug_header {
  MEM_SIZE size;
d4160 1
a4160 6
#endif

#if defined (PERL_TRACK_MEMPOOL) || defined (PERL_DEBUG_READONLY_COW)

#  define PERL_MEMORY_DEBUG_HEADER_SIZE \
        (sizeof(struct perl_memory_debug_header) + \
d4165 1
a4165 1
#  define PERL_MEMORY_DEBUG_HEADER_SIZE	0
a4168 1
# ifdef PERL_DEBUG_READONLY_COW
a4172 1
		(header).readonly = 0;				\
d4174 1
a4174 8
# else
#  define INIT_TRACK_MEMPOOL(header, interp)			\
	STMT_START {						\
		(header).interpreter = (interp);		\
		(header).prev = (header).next = &(header);	\
	} STMT_END
# endif
# else
d4186 1
a4186 1
#  if defined(HAS_MALLOC_SIZE) && !defined(PERL_DEBUG_READONLY_COW)
d4189 1
a4189 1
	    (malloc_size(((char *)(where)) - PERL_MEMORY_DEBUG_HEADER_SIZE) - PERL_MEMORY_DEBUG_HEADER_SIZE)
d4197 1
a4197 1
	    (malloc_good_size((how_much) + PERL_MEMORY_DEBUG_HEADER_SIZE) - PERL_MEMORY_DEBUG_HEADER_SIZE)
d4231 3
a4233 2
        (defined(__svr4__) && defined(__GNUC__) && defined(__sun)) || \
        defined(__sgi)
d4257 1
a4257 1
  INIT("Use of uninitialized value%" SVf "%s%s");
d4277 1
a4277 1
  INIT("Modification of non-creatable hash value attempted, subscript \"%" SVf "\"");
d4441 1
a4515 1
#endif  /* !EBCDIC, but still in DOINIT */
d4517 1
a4517 1
#   ifndef EBCDIC
d4520 1
a4522 1
#   endif
d4677 3
a4697 3
#  ifdef PERL_DEBUG_READONLY_COW
			     " PERL_DEBUG_READONLY_COW"
#  endif
a4703 3
#  ifdef PERL_GLOBAL_STRUCT_PRIVATE
			     " PERL_GLOBAL_STRUCT_PRIVATE"
#  endif
d4725 3
d4770 3
a4830 2
#define PL_hints PL_compiling.cop_hints

a4858 1
    XPOSTDEREF,
d4865 1
a4865 4
   However, bitops store HINT_INTEGER in their op_private.

    NOTE: The typical module using these has the bit value hard-coded, so don't
    blindly change the values of these */
d5217 1
a5217 1
		        /* NL IV NV PV INV PI PN MG RX GV LV AV HV CV FM IO */
d5219 1
a5219 1
PL_valid_types_IVX[]    = { 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0 };
d5221 1
a5221 1
PL_valid_types_NVX[]    = { 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0 };
d5223 1
a5223 1
PL_valid_types_PVX[]    = { 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1 };
d5225 1
a5225 1
PL_valid_types_RV[]     = { 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1 };
d5227 1
a5227 1
PL_valid_types_IV_set[] = { 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1 };
d5229 1
a5229 1
PL_valid_types_NV_set[] = { 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0 };
d5355 1
a5355 1
/*
d5357 2
a5358 1
=head1 Locale-related functions and macros
d5360 2
a5361 17
=for apidoc sync_locale

Changing the program's locale should be avoided by XS code.  Nevertheless,
certain non-Perl libraries called from XS, such as C<Gtk> do so.  When this
happens, Perl needs to be told that the locale has changed.  Use this macro
to do so, before returning to Perl code.

=cut
*/

/* Temporary for maint.  Is a function in 5.21 */
#define sync_locale() (new_ctype(setlocale(LC_CTYPE, NULL)),        \
                       new_collate(setlocale(LC_COLLATE, NULL)),    \
                       set_numeric_local(),                         \
                       new_numeric(setlocale(LC_NUMERIC, NULL)))

#ifdef USE_LOCALE_NUMERIC
d5363 1
a5363 1
/* Returns TRUE if the plain locale pragma without a parameter is in effect
d5365 1
a5365 1
#define IN_LOCALE_RUNTIME	cBOOL(CopHINTS_get(PL_curcop) & HINT_LOCALE)
d5367 1
a5367 1
/* Returns TRUE if either form of the locale pragma is in effect */
d5369 1
a5369 1
           cBOOL(CopHINTS_get(PL_curcop) & (HINT_LOCALE|HINT_LOCALE_NOT_CHARS))
d5371 1
a5371 1
#define IN_LOCALE_COMPILETIME	cBOOL(PL_hints & HINT_LOCALE)
d5373 1
a5373 1
                          cBOOL(PL_hints & (HINT_LOCALE|HINT_LOCALE_NOT_CHARS))
a5380 48
/* These macros are for toggling between the underlying locale (LOCAL) and the
 * C locale. */

/* The first set makes sure that the locale is set to C unless within a 'use
 * locale's scope; otherwise to the default locale.  A function pointer is
 * used, which can be declared separately by
 * DECLARATION_FOR_STORE_LC_NUMERIC_SET_TO_NEEDED, followed by the actual
 * setting (using STORE_LC_NUMERIC_SET_TO_NEEDED()), or the two can be combined
 * into one call DECLARE_STORE_LC_NUMERIC_SET_TO_NEEDED().
 * RESTORE_LC_NUMERIC() in all cases restores the locale to what it was before
 * these were called */

#define DECLARATION_FOR_STORE_LC_NUMERIC_SET_TO_NEEDED                       \
    void (*_restore_LC_NUMERIC_function)(pTHX) = NULL;

#define STORE_LC_NUMERIC_SET_TO_NEEDED()                                     \
    if (IN_SOME_LOCALE_FORM) {                                               \
        if (! PL_numeric_local) {                                            \
            SET_NUMERIC_LOCAL();                                             \
            _restore_LC_NUMERIC_function = &Perl_set_numeric_standard;       \
        }                                                                    \
    }                                                                        \
    else {                                                                   \
        if (! PL_numeric_standard) {                                         \
            SET_NUMERIC_STANDARD();                                          \
            _restore_LC_NUMERIC_function = &Perl_set_numeric_local;          \
        }                                                                    \
    }

#define DECLARE_STORE_LC_NUMERIC_SET_TO_NEEDED()                             \
    DECLARATION_FOR_STORE_LC_NUMERIC_SET_TO_NEEDED;                          \
    STORE_LC_NUMERIC_SET_TO_NEEDED();

#define RESTORE_LC_NUMERIC()                                                 \
    if (_restore_LC_NUMERIC_function) {                                      \
        _restore_LC_NUMERIC_function(aTHX);                                  \
    }

/* The next two macros set unconditionally.  These should be rarely used, and
 * only after being sure that this is what is needed */
#define SET_NUMERIC_STANDARD() \
	set_numeric_standard();

#define SET_NUMERIC_LOCAL() \
	set_numeric_local();

/* The rest of these LC_NUMERIC macros toggle to one or the other state, with
 * the RESTORE_foo ones called to switch back, but only if need be */
d5382 1
a5382 1
	bool was_local = PL_numeric_local; \
a5384 2
/* Doesn't change to underlying locale unless within the scope of some form of
 * 'use locale'.  This is the usual desired behavior. */
d5386 1
a5386 7
	bool was_standard = PL_numeric_standard && IN_SOME_LOCALE_FORM; \
	if (was_standard) SET_NUMERIC_LOCAL();

/* Rarely, we want to change to the underlying locale even outside of 'use
 * locale'.  This is principally in the POSIX:: functions */
#define STORE_NUMERIC_STANDARD_FORCE_LOCAL() \
	bool was_standard = PL_numeric_standard; \
a5403 1
#define STORE_NUMERIC_STANDARD_FORCE_LOCAL()
a5405 5
#define DECLARATION_FOR_STORE_LC_NUMERIC_SET_TO_NEEDED
#define STORE_LC_NUMERIC_SET_TO_NEEDED()
#define DECLARE_STORE_LC_NUMERIC_SET_TO_NEEDED()
#define RESTORE_LC_NUMERIC()

d5511 1
a5511 1
#		define PERL_ASYNC_CHECK() if (UNLIKELY(PL_sig_pending)) PL_signalhook(aTHX)
a5829 6
/* check embedded \0 characters in pathnames passed to syscalls,
   but allow one ending \0 */
#define IS_SAFE_SYSCALL(p, len, what, op_name) (S_is_safe_syscall(aTHX_ (p), (len), (what), (op_name)))

#define IS_SAFE_PATHNAME(p, len, op_name) IS_SAFE_SYSCALL((p), (len), "pathname", (op_name))

a5856 2

#define PERL_PV_ESCAPE_DWIM         0x10000
@


1.1.1.17
log
@Import perl-5.20.2
@
text
@a683 9
/* EVC 4 SDK headers includes a bad definition of MB_CUR_MAX in stdlib.h
  which is included from stdarg.h. Bad definition not present in SD 2008
  SDK headers. wince.h is not yet included, so we cant fix this from there
  since by then MB_CUR_MAX will be defined from stdlib.h.
  cewchar.h includes a correct definition of MB_CUR_MAX and it is copied here
  since cewchar.h can't be included this early */
#if defined(UNDER_CE) && (_MSC_VER < 1300)
#  define MB_CUR_MAX 1
#endif
d1110 8
a1797 10
#endif

#ifdef USING_MSVC6
/* VC6 has broken NaN semantics: NaN == NaN returns true instead of false,
 * and for example NaN < IV_MIN. */
#  define NAN_COMPARE_BROKEN
#endif
#if defined(__DECC) && defined(__osf__)
/* Also Tru64 cc has broken NaN comparisons. */
#  define NAN_COMPARE_BROKEN
@


