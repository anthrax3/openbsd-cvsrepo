head	1.14;
access;
symbols
	OPENBSD_5_3:1.13.0.10
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.8
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.6
	OPENBSD_5_0:1.13.0.4
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.2
	OPENBSD_4_9_BASE:1.13
	PERL_5_12_2:1.1.1.11
	OPENBSD_4_8:1.12.0.4
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	PERL_5_10_1:1.1.1.10
	OPENBSD_4_6:1.11.0.6
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.2
	OPENBSD_4_5_BASE:1.11
	PERL_5_10_0:1.1.1.9
	OPENBSD_4_4:1.10.0.10
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.8
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.6
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.4
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.2
	OPENBSD_4_0_BASE:1.10
	PERL_5_8_8:1.1.1.8
	OPENBSD_3_9:1.9.0.2
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.8.0.6
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.4
	OPENBSD_3_7_BASE:1.8
	PERL_5_8_6:1.1.1.7
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	PERL_5_8_5:1.1.1.7
	PERL_5_8_3:1.1.1.6
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.14
date	2013.03.25.20.40.44;	author sthen;	state dead;
branches;
next	1.13;

1.13
date	2010.09.24.15.06.40;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2009.10.12.18.24.21;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2008.09.29.17.35.58;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2006.03.28.19.22.58;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2006.01.02.23.37.10;	author brad;	state Exp;
branches;
next	1.8;

1.8
date	2004.08.09.18.08.55;	author millert;	state Exp;
branches
	1.8.4.1
	1.8.6.1;
next	1.7;

1.7
date	2003.12.03.03.02.21;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.18;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.34.52;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.04.07;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.51.03;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.48.53;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.11.44;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.11.44;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.37.31;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.08.40;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.22.10;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.14.48;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.43.32;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.08.09.17.45.42;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2006.03.28.18.47.32;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2008.09.29.17.18.06;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2009.10.12.18.10.35;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2010.09.24.14.48.27;	author millert;	state Exp;
branches;
next	;

1.8.4.1
date	2006.01.03.05.44.49;	author brad;	state Exp;
branches;
next	;

1.8.6.1
date	2006.01.03.04.22.40;	author brad;	state Exp;
branches;
next	;


desc
@@


1.14
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@#!/usr/bin/perl -w
# 
# Regenerate (overwriting only if changed):
#
#    opcode.h
#    opnames.h
#    pp_proto.h
#    pp.sym
#
# from information stored in the DATA section of this file, plus the
# values hardcoded into this script in @@raw_alias.
#
# Accepts the standard regen_lib -q and -v args.
#
# This script is normally invoked from regen.pl.

use strict;

BEGIN {
    # Get function prototypes
    require 'regen_lib.pl';
}

my $opcode_new = 'opcode.h-new';
my $opname_new = 'opnames.h-new';
my $oc = safer_open($opcode_new);
my $on = safer_open($opname_new);
select $oc;

# Read data.

my %seen;
my (@@ops, %desc, %check, %ckname, %flags, %args, %opnum);

while (<DATA>) {
    chop;
    next unless $_;
    next if /^#/;
    my ($key, $desc, $check, $flags, $args) = split(/\t+/, $_, 5);
    $args = '' unless defined $args;

    warn qq[Description "$desc" duplicates $seen{$desc}\n] if $seen{$desc};
    die qq[Opcode "$key" duplicates $seen{$key}\n] if $seen{$key};
    $seen{$desc} = qq[description of opcode "$key"];
    $seen{$key} = qq[opcode "$key"];

    push(@@ops, $key);
    $opnum{$key} = $#ops;
    $desc{$key} = $desc;
    $check{$key} = $check;
    $ckname{$check}++;
    $flags{$key} = $flags;
    $args{$key} = $args;
}

# Set up aliases

my %alias;

# Format is "this function" => "does these op names"
my @@raw_alias = (
		 Perl_do_kv => [qw( keys values )],
		 Perl_unimplemented_op => [qw(padany mapstart custom)],
		 # All the ops with a body of { return NORMAL; }
		 Perl_pp_null => [qw(scalar regcmaybe lineseq scope)],

		 Perl_pp_goto => ['dump'],
		 Perl_pp_require => ['dofile'],
		 Perl_pp_untie => ['dbmclose'],
		 Perl_pp_sysread => [qw(read recv)],
		 Perl_pp_sysseek => ['seek'],
		 Perl_pp_ioctl => ['fcntl'],
		 Perl_pp_ssockopt => ['gsockopt'],
		 Perl_pp_getpeername => ['getsockname'],
		 Perl_pp_stat => ['lstat'],
		 Perl_pp_ftrowned => [qw(fteowned ftzero ftsock ftchr ftblk
					 ftfile ftdir ftpipe ftsuid ftsgid
 					 ftsvtx)],
		 Perl_pp_fttext => ['ftbinary'],
		 Perl_pp_gmtime => ['localtime'],
		 Perl_pp_semget => [qw(shmget msgget)],
		 Perl_pp_semctl => [qw(shmctl msgctl)],
		 Perl_pp_ghostent => [qw(ghbyname ghbyaddr)],
		 Perl_pp_gnetent => [qw(gnbyname gnbyaddr)],
		 Perl_pp_gprotoent => [qw(gpbyname gpbynumber)],
		 Perl_pp_gservent => [qw(gsbyname gsbyport)],
		 Perl_pp_gpwent => [qw(gpwnam gpwuid)],
		 Perl_pp_ggrent => [qw(ggrnam ggrgid)],
		 Perl_pp_ftis => [qw(ftsize ftmtime ftatime ftctime)],
		 Perl_pp_chown => [qw(unlink chmod utime kill)],
		 Perl_pp_link => ['symlink'],
		 Perl_pp_ftrread => [qw(ftrwrite ftrexec fteread ftewrite
 					fteexec)],
		 Perl_pp_shmwrite => [qw(shmread msgsnd msgrcv semop)],
		 Perl_pp_send => ['syswrite'],
		 Perl_pp_defined => [qw(dor dorassign)],
                 Perl_pp_and => ['andassign'],
		 Perl_pp_or => ['orassign'],
		 Perl_pp_ucfirst => ['lcfirst'],
		 Perl_pp_sle => [qw(slt sgt sge)],
		 Perl_pp_print => ['say'],
		 Perl_pp_index => ['rindex'],
		 Perl_pp_oct => ['hex'],
		 Perl_pp_shift => ['pop'],
		 Perl_pp_sin => [qw(cos exp log sqrt)],
		 Perl_pp_bit_or => ['bit_xor'],
		 Perl_pp_rv2av => ['rv2hv'],
		 Perl_pp_akeys => ['avalues'],
		);

while (my ($func, $names) = splice @@raw_alias, 0, 2) {
    $alias{$_} = $func for @@$names;
}

# Emit defines.

print <<"END";
/* -*- buffer-read-only: t -*-
 *
 *    opcode.h
 *
 *    Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
 *    2001, 2002, 2003, 2004, 2005, 2006, 2007 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 * !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
 *  This file is built by opcode.pl from its data.  Any changes made here
 *  will be lost!
 */

#ifndef PERL_GLOBAL_STRUCT_INIT

#define Perl_pp_i_preinc Perl_pp_preinc
#define Perl_pp_i_predec Perl_pp_predec
#define Perl_pp_i_postinc Perl_pp_postinc
#define Perl_pp_i_postdec Perl_pp_postdec

PERL_PPDEF(Perl_unimplemented_op)

END

print $on <<"END";
/* -*- buffer-read-only: t -*-
 *
 *    opnames.h
 *
 *    Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
 *    2007, 2008 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 *
 * !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
 *  This file is built by opcode.pl from its data.  Any changes made here
 *  will be lost!
 */

typedef enum opcode {
END

my $i = 0;
for (@@ops) {
    # print $on "\t", &tab(3,"OP_\U$_,"), "/* ", $i++, " */\n";
      print $on "\t", &tab(3,"OP_\U$_"), " = ", $i++, ",\n";
}
print $on "\t", &tab(3,"OP_max"), "\n";
print $on "} opcode;\n";
print $on "\n#define MAXO ", scalar @@ops, "\n";
print $on "#define OP_phoney_INPUT_ONLY -1\n";
print $on "#define OP_phoney_OUTPUT_ONLY -2\n\n";

# Emit op names and descriptions.

print <<END;
START_EXTERN_C

#define OP_NAME(o) ((o)->op_type == OP_CUSTOM ? custom_op_name(o) : \\
                    PL_op_name[(o)->op_type])
#define OP_DESC(o) ((o)->op_type == OP_CUSTOM ? custom_op_desc(o) : \\
                    PL_op_desc[(o)->op_type])

#ifndef DOINIT
EXTCONST char* const PL_op_name[];
#else
EXTCONST char* const PL_op_name[] = {
END

for (@@ops) {
    print qq(\t"$_",\n);
}

print <<END;
};
#endif

END

print <<END;
#ifndef DOINIT
EXTCONST char* const PL_op_desc[];
#else
EXTCONST char* const PL_op_desc[] = {
END

for (@@ops) {
    my($safe_desc) = $desc{$_};

    # Have to escape double quotes and escape characters.
    $safe_desc =~ s/(^|[^\\])([\\"])/$1\\$2/g;

    print qq(\t"$safe_desc",\n);
}

print <<END;
};
#endif

END_EXTERN_C

#endif /* !PERL_GLOBAL_STRUCT_INIT */
END

# Emit function declarations.

#for (sort keys %ckname) {
#    print "OP *\t", &tab(3,$_),"(pTHX_ OP* o);\n";
#}
#
#print "\n";
#
#for (@@ops) {
#    print "OP *\t", &tab(3, "pp_$_"), "(pTHX);\n";
#}

# Emit ppcode switch array.

print <<END;

START_EXTERN_C

#ifdef PERL_GLOBAL_STRUCT_INIT
#  define PERL_PPADDR_INITED
static const Perl_ppaddr_t Gppaddr[]
#else
#  ifndef PERL_GLOBAL_STRUCT
#    define PERL_PPADDR_INITED
EXT Perl_ppaddr_t PL_ppaddr[] /* or perlvars.h */
#  endif
#endif /* PERL_GLOBAL_STRUCT */
#if (defined(DOINIT) && !defined(PERL_GLOBAL_STRUCT)) || defined(PERL_GLOBAL_STRUCT_INIT)
#  define PERL_PPADDR_INITED
= {
END

for (@@ops) {
    if (my $name = $alias{$_}) {
	print "\tMEMBER_TO_FPTR($name),\t/* Perl_pp_$_ */\n";
    }
    else {
	print "\tMEMBER_TO_FPTR(Perl_pp_$_),\n";
    }
}

print <<END;
}
#endif
#ifdef PERL_PPADDR_INITED
;
#endif

END

# Emit check routines.

print <<END;
#ifdef PERL_GLOBAL_STRUCT_INIT
#  define PERL_CHECK_INITED
static const Perl_check_t Gcheck[]
#else
#  ifndef PERL_GLOBAL_STRUCT
#    define PERL_CHECK_INITED
EXT Perl_check_t PL_check[] /* or perlvars.h */
#  endif
#endif
#if (defined(DOINIT) && !defined(PERL_GLOBAL_STRUCT)) || defined(PERL_GLOBAL_STRUCT_INIT)
#  define PERL_CHECK_INITED
= {
END

for (@@ops) {
    print "\t", &tab(3, "MEMBER_TO_FPTR(Perl_$check{$_}),"), "\t/* $_ */\n";
}

print <<END;
}
#endif
#ifdef PERL_CHECK_INITED
;
#endif /* #ifdef PERL_CHECK_INITED */

END

# Emit allowed argument types.

my $ARGBITS = 32;

print <<END;
#ifndef PERL_GLOBAL_STRUCT_INIT

#ifndef DOINIT
EXTCONST U32 PL_opargs[];
#else
EXTCONST U32 PL_opargs[] = {
END

my %argnum = (
    'S',  1,		# scalar
    'L',  2,		# list
    'A',  3,		# array value
    'H',  4,		# hash value
    'C',  5,		# code value
    'F',  6,		# file value
    'R',  7,		# scalar reference
);

my %opclass = (
    '0',  0,		# baseop
    '1',  1,		# unop
    '2',  2,		# binop
    '|',  3,		# logop
    '@@',  4,		# listop
    '/',  5,		# pmop
    '$',  6,		# svop_or_padop
    '#',  7,		# padop
    '"',  8,		# pvop_or_svop
    '{',  9,		# loop
    ';',  10,		# cop
    '%',  11,		# baseop_or_unop
    '-',  12,		# filestatop
    '}',  13,		# loopexop
);

my %opflags = (
    'm' =>   1,		# needs stack mark
    'f' =>   2,		# fold constants
    's' =>   4,		# always produces scalar
    't' =>   8,		# needs target scalar
    'T' =>   8 | 256,	# ... which may be lexical
    'i' =>  16,		# always produces integer
    'I' =>  32,		# has corresponding int op
    'd' =>  64,		# danger, unknown side effects
    'u' => 128,		# defaults to $_
);

my %OP_IS_SOCKET;
my %OP_IS_FILETEST;
my %OP_IS_FT_ACCESS;
my $OCSHIFT = 9;
my $OASHIFT = 13;

for my $op (@@ops) {
    my $argsum = 0;
    my $flags = $flags{$op};
    for my $flag (keys %opflags) {
	if ($flags =~ s/$flag//) {
	    die "Flag collision for '$op' ($flags{$op}, $flag)\n"
		if $argsum & $opflags{$flag};
	    $argsum |= $opflags{$flag};
	}
    }
    die qq[Opcode '$op' has no class indicator ($flags{$op} => $flags)\n]
	unless exists $opclass{$flags};
    $argsum |= $opclass{$flags} << $OCSHIFT;
    my $argshift = $OASHIFT;
    for my $arg (split(' ',$args{$op})) {
	if ($arg =~ /^F/) {
	    # record opnums of these opnames
	    $OP_IS_SOCKET{$op}   = $opnum{$op} if $arg =~ s/s//;
	    $OP_IS_FILETEST{$op} = $opnum{$op} if $arg =~ s/-//;
	    $OP_IS_FT_ACCESS{$op} = $opnum{$op} if $arg =~ s/\+//;
        }
	my $argnum = ($arg =~ s/\?//) ? 8 : 0;
        die "op = $op, arg = $arg\n"
	    unless exists $argnum{$arg};
	$argnum += $argnum{$arg};
	die "Argument overflow for '$op'\n"
	    if $argshift >= $ARGBITS ||
	       $argnum > ((1 << ($ARGBITS - $argshift)) - 1);
	$argsum += $argnum << $argshift;
	$argshift += 4;
    }
    $argsum = sprintf("0x%08x", $argsum);
    print "\t", &tab(3, "$argsum,"), "/* $op */\n";
}

print <<END;
};
#endif

#endif /* !PERL_GLOBAL_STRUCT_INIT */

END_EXTERN_C

END

# Emit OP_IS_* macros

print $on <<EO_OP_IS_COMMENT;

/* the OP_IS_(SOCKET|FILETEST) macros are optimized to a simple range
    check because all the member OPs are contiguous in opcode.pl
    <DATA> table.  opcode.pl verifies the range contiguity.  */

EO_OP_IS_COMMENT

gen_op_is_macro( \%OP_IS_SOCKET, 'OP_IS_SOCKET');
gen_op_is_macro( \%OP_IS_FILETEST, 'OP_IS_FILETEST');
gen_op_is_macro( \%OP_IS_FT_ACCESS, 'OP_IS_FILETEST_ACCESS');

sub gen_op_is_macro {
    my ($op_is, $macname) = @@_;
    if (keys %$op_is) {
	
	# get opnames whose numbers are lowest and highest
	my ($first, @@rest) = sort {
	    $op_is->{$a} <=> $op_is->{$b}
	} keys %$op_is;
	
	my $last = pop @@rest;	# @@rest slurped, get its last
	die "Invalid range of ops: $first .. $last\n" unless $last;

	print $on "#define $macname(op)	\\\n\t(";

	# verify that op-ct matches 1st..last range (and fencepost)
	# (we know there are no dups)
	if ( $op_is->{$last} - $op_is->{$first} == scalar @@rest + 1) {
	    
	    # contiguous ops -> optimized version
	    print $on "(op) >= OP_" . uc($first) . " && (op) <= OP_" . uc($last);
	    print $on ")\n\n";
	}
	else {
	    print $on join(" || \\\n\t ",
			  map { "(op) == OP_" . uc() } sort keys %$op_is);
	    print $on ")\n\n";
	}
    }
}

print $oc "/* ex: set ro: */\n";
print $on "/* ex: set ro: */\n";

safer_close($oc);
safer_close($on);

rename_if_different $opcode_new, 'opcode.h';
rename_if_different $opname_new, 'opnames.h';

my $pp_proto_new = 'pp_proto.h-new';
my $pp_sym_new  = 'pp.sym-new';

my $pp = safer_open($pp_proto_new);
my $ppsym = safer_open($pp_sym_new);

print $pp <<"END";
/* -*- buffer-read-only: t -*-
   !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
   This file is built by opcode.pl from its data.  Any changes made here
   will be lost!
*/

END

print $ppsym <<"END";
# -*- buffer-read-only: t -*-
#
# !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
#   This file is built by opcode.pl from its data.  Any changes made here
#   will be lost!
#

END


for (sort keys %ckname) {
    print $pp "PERL_CKDEF(Perl_$_)\n";
    print $ppsym "Perl_$_\n";
#OP *\t", &tab(3,$_),"(OP* o);\n";
}

print $pp "\n\n";

for (@@ops) {
    next if /^i_(pre|post)(inc|dec)$/;
    next if /^custom$/;
    print $pp "PERL_PPDEF(Perl_pp_$_)\n";
    print $ppsym "Perl_pp_$_\n";
}
print $pp "\n/* ex: set ro: */\n";
print $ppsym "\n# ex: set ro:\n";

safer_close($pp);
safer_close($ppsym);

rename_if_different $pp_proto_new, 'pp_proto.h';
rename_if_different $pp_sym_new, 'pp.sym';

END {
  foreach ('opcode.h', 'opnames.h', 'pp_proto.h', 'pp.sym') {
    1 while unlink "$_-old";
  }
}

###########################################################################
sub tab {
    my ($l, $t) = @@_;
    $t .= "\t" x ($l - (length($t) + 1) / 8);
    $t;
}
###########################################################################

# Some comments about 'T' opcode classifier:

# Safe to set if the ppcode uses:
#	tryAMAGICbin, tryAMAGICun, SETn, SETi, SETu, PUSHn, PUSHTARG, SETTARG,
#	SETs(TARG), XPUSHn, XPUSHu,

# Unsafe to set if the ppcode uses dTARG or [X]RETPUSH[YES|NO|UNDEF]

# lt and friends do SETs (including ncmp, but not scmp)

# Additional mode of failure: the opcode can modify TARG before it "used"
# all the arguments (or may call an external function which does the same).
# If the target coincides with one of the arguments ==> kaboom.

# pp.c	pos substr each not OK (RETPUSHUNDEF)
#	substr vec also not OK due to LV to target (are they???)
#	ref not OK (RETPUSHNO)
#	trans not OK (dTARG; TARG = sv_newmortal();)
#	ucfirst etc not OK: TMP arg processed inplace
#	quotemeta not OK (unsafe when TARG == arg)
#	each repeat not OK too due to list context
#	pack split - unknown whether they are safe
#	sprintf: is calling do_sprintf(TARG,...) which can act on TARG
#	  before other args are processed.

#	Suspicious wrt "additional mode of failure" (and only it):
#	schop, chop, postinc/dec, bit_and etc, negate, complement.

#	Also suspicious: 4-arg substr, sprintf, uc/lc (POK_only), reverse, pack.

#	substr/vec: doing TAINT_off()???

# pp_hot.c
#	readline - unknown whether it is safe
#	match subst not OK (dTARG)
#	grepwhile not OK (not always setting)
#	join not OK (unsafe when TARG == arg)

#	Suspicious wrt "additional mode of failure": concat (dealt with
#	in ck_sassign()), join (same).

# pp_ctl.c
#	mapwhile flip caller not OK (not always setting)

# pp_sys.c
#	backtick glob warn die not OK (not always setting)
#	warn not OK (RETPUSHYES)
#	open fileno getc sysread syswrite ioctl accept shutdown
#	 ftsize(etc) readlink telldir fork alarm getlogin not OK (RETPUSHUNDEF)
#	umask select not OK (XPUSHs(&PL_sv_undef);)
#	fileno getc sysread syswrite tell not OK (meth("FILENO" "GETC"))
#	sselect shm* sem* msg* syscall - unknown whether they are safe
#	gmtime not OK (list context)

#	Suspicious wrt "additional mode of failure": warn, die, select.

__END__

# New ops always go at the end
# The restriction on having custom as the last op has been removed

# A recapitulation of the format of this file:
# The file consists of five columns: the name of the op, an English
# description, the name of the "check" routine used to optimize this
# operation, some flags, and a description of the operands.

# The flags consist of options followed by a mandatory op class signifier

# The classes are:
# baseop      - 0            unop     - 1            binop      - 2
# logop       - |            listop   - @@            pmop       - /
# padop/svop  - $            padop    - # (unused)   loop       - {
# baseop/unop - %            loopexop - }            filestatop - -
# pvop/svop   - "            cop      - ;

# Other options are:
#   needs stack mark                    - m
#   needs constant folding              - f
#   produces a scalar                   - s
#   produces an integer                 - i
#   needs a target                      - t
#   target can be in a pad              - T
#   has a corresponding integer version - I
#   has side effects                    - d
#   uses $_ if no argument given        - u

# Values for the operands are:
# scalar      - S            list     - L            array     - A
# hash        - H            sub (CV) - C            file      - F
# socket      - Fs           filetest - F-           filetest_access - F-+

# reference - R
# "?" denotes an optional operand.

# Nothing.

null		null operation		ck_null		0	
stub		stub			ck_null		0
scalar		scalar			ck_fun		s%	S

# Pushy stuff.

pushmark	pushmark		ck_null		s0	
wantarray	wantarray		ck_null		is0	

const		constant item		ck_svconst	s$	

gvsv		scalar variable		ck_null		ds$	
gv		glob value		ck_null		ds$	
gelem		glob elem		ck_null		d2	S S
padsv		private variable	ck_null		ds0
padav		private array		ck_null		d0
padhv		private hash		ck_null		d0
padany		private value		ck_null		d0

pushre		push regexp		ck_null		d/

# References and stuff.

rv2gv		ref-to-glob cast	ck_rvconst	ds1	
rv2sv		scalar dereference	ck_rvconst	ds1	
av2arylen	array length		ck_null		is1	
rv2cv		subroutine dereference	ck_rvconst	d1
anoncode	anonymous subroutine	ck_anoncode	$	
prototype	subroutine prototype	ck_null		s%	S
refgen		reference constructor	ck_spair	m1	L
srefgen		single ref constructor	ck_null		fs1	S
ref		reference-type operator	ck_fun		stu%	S?
bless		bless			ck_fun		s@@	S S?

# Pushy I/O.

backtick	quoted execution (``, qx)	ck_open		tu%	S?
# glob defaults its first arg to $_
glob		glob			ck_glob		t@@	S?
readline	<HANDLE>		ck_readline	t%	F?
rcatline	append I/O operator	ck_null		t$

# Bindable operators.

regcmaybe	regexp internal guard	ck_fun		s1	S
regcreset	regexp internal reset	ck_fun		s1	S
regcomp		regexp compilation	ck_null		s|	S
match		pattern match (m//)	ck_match	d/
qr		pattern quote (qr//)	ck_match	s/
subst		substitution (s///)	ck_match	dis/	S
substcont	substitution iterator	ck_null		dis|	
trans		transliteration (tr///)	ck_match	is"	S

# Lvalue operators.
# sassign is special-cased for op class

sassign		scalar assignment	ck_sassign	s0
aassign		list assignment		ck_null		t2	L L

chop		chop			ck_spair	mts%	L
schop		scalar chop		ck_null		stu%	S?
chomp		chomp			ck_spair	mTs%	L
schomp		scalar chomp		ck_null		sTu%	S?
defined		defined operator	ck_defined	isu%	S?
undef		undef operator		ck_lfun		s%	S?
study		study			ck_fun		su%	S?
pos		match position		ck_lfun		stu%	S?

preinc		preincrement (++)		ck_lfun		dIs1	S
i_preinc	integer preincrement (++)	ck_lfun		dis1	S
predec		predecrement (--)		ck_lfun		dIs1	S
i_predec	integer predecrement (--)	ck_lfun		dis1	S
postinc		postincrement (++)		ck_lfun		dIst1	S
i_postinc	integer postincrement (++)	ck_lfun		disT1	S
postdec		postdecrement (--)		ck_lfun		dIst1	S
i_postdec	integer postdecrement (--)	ck_lfun		disT1	S

# Ordinary operators.

pow		exponentiation (**)	ck_null		fsT2	S S

multiply	multiplication (*)	ck_null		IfsT2	S S
i_multiply	integer multiplication (*)	ck_null		ifsT2	S S
divide		division (/)		ck_null		IfsT2	S S
i_divide	integer division (/)	ck_null		ifsT2	S S
modulo		modulus (%)		ck_null		IifsT2	S S
i_modulo	integer modulus (%)	ck_null		ifsT2	S S
repeat		repeat (x)		ck_repeat	mt2	L S

add		addition (+)		ck_null		IfsT2	S S
i_add		integer addition (+)	ck_null		ifsT2	S S
subtract	subtraction (-)		ck_null		IfsT2	S S
i_subtract	integer subtraction (-)	ck_null		ifsT2	S S
concat		concatenation (.) or string	ck_concat	fsT2	S S
stringify	string			ck_fun		fsT@@	S

left_shift	left bitshift (<<)	ck_bitop	fsT2	S S
right_shift	right bitshift (>>)	ck_bitop	fsT2	S S

lt		numeric lt (<)		ck_null		Iifs2	S S
i_lt		integer lt (<)		ck_null		ifs2	S S
gt		numeric gt (>)		ck_null		Iifs2	S S
i_gt		integer gt (>)		ck_null		ifs2	S S
le		numeric le (<=)		ck_null		Iifs2	S S
i_le		integer le (<=)		ck_null		ifs2	S S
ge		numeric ge (>=)		ck_null		Iifs2	S S
i_ge		integer ge (>=)		ck_null		ifs2	S S
eq		numeric eq (==)		ck_null		Iifs2	S S
i_eq		integer eq (==)		ck_null		ifs2	S S
ne		numeric ne (!=)		ck_null		Iifs2	S S
i_ne		integer ne (!=)		ck_null		ifs2	S S
ncmp		numeric comparison (<=>)	ck_null		Iifst2	S S
i_ncmp		integer comparison (<=>)	ck_null		ifst2	S S

slt		string lt		ck_null		ifs2	S S
sgt		string gt		ck_null		ifs2	S S
sle		string le		ck_null		ifs2	S S
sge		string ge		ck_null		ifs2	S S
seq		string eq		ck_null		ifs2	S S
sne		string ne		ck_null		ifs2	S S
scmp		string comparison (cmp)	ck_null		ifst2	S S

bit_and		bitwise and (&)		ck_bitop	fst2	S S
bit_xor		bitwise xor (^)		ck_bitop	fst2	S S
bit_or		bitwise or (|)		ck_bitop	fst2	S S

negate		negation (-)		ck_null		Ifst1	S
i_negate	integer negation (-)	ck_null		ifsT1	S
not		not			ck_null		ifs1	S
complement	1's complement (~)	ck_bitop	fst1	S

smartmatch	smart match		ck_smartmatch	s2

# High falutin' math.

atan2		atan2			ck_fun		fsT@@	S S
sin		sin			ck_fun		fsTu%	S?
cos		cos			ck_fun		fsTu%	S?
rand		rand			ck_fun		sT%	S?
srand		srand			ck_fun		s%	S?
exp		exp			ck_fun		fsTu%	S?
log		log			ck_fun		fsTu%	S?
sqrt		sqrt			ck_fun		fsTu%	S?

# Lowbrow math.

int		int			ck_fun		fsTu%	S?
hex		hex			ck_fun		fsTu%	S?
oct		oct			ck_fun		fsTu%	S?
abs		abs			ck_fun		fsTu%	S?

# String stuff.

length		length			ck_fun		ifsTu%	S?
substr		substr			ck_substr	st@@	S S S? S?
vec		vec			ck_fun		ist@@	S S S

index		index			ck_index	isT@@	S S S?
rindex		rindex			ck_index	isT@@	S S S?

sprintf		sprintf			ck_fun		fmst@@	S L
formline	formline		ck_fun		ms@@	S L
ord		ord			ck_fun		ifsTu%	S?
chr		chr			ck_fun		fsTu%	S?
crypt		crypt			ck_fun		fsT@@	S S
ucfirst		ucfirst			ck_fun		fstu%	S?
lcfirst		lcfirst			ck_fun		fstu%	S?
uc		uc			ck_fun		fstu%	S?
lc		lc			ck_fun		fstu%	S?
quotemeta	quotemeta		ck_fun		fstu%	S?

# Arrays.

rv2av		array dereference	ck_rvconst	dt1	
aelemfast	constant array element	ck_null		s$	A S
aelem		array element		ck_null		s2	A S
aslice		array slice		ck_null		m@@	A L

aeach		each on array		ck_each		%	A
akeys		keys on array		ck_each		t%	A
avalues		values on array		ck_each		t%	A

# Hashes.

each		each			ck_each		%	H
values		values			ck_each		t%	H
keys		keys			ck_each		t%	H
delete		delete			ck_delete	%	S
exists		exists			ck_exists	is%	S
rv2hv		hash dereference	ck_rvconst	dt1	
helem		hash element		ck_null		s2	H S
hslice		hash slice		ck_null		m@@	H L
boolkeys	boolkeys		ck_fun		%	H

# Explosives and implosives.

unpack		unpack			ck_unpack	@@	S S?
pack		pack			ck_fun		mst@@	S L
split		split			ck_split	t@@	S S S
join		join or string		ck_join		mst@@	S L

# List operators.

list		list			ck_null		m@@	L
lslice		list slice		ck_null		2	H L L
anonlist	anonymous list ([])	ck_fun		ms@@	L
anonhash	anonymous hash ({})	ck_fun		ms@@	L

splice		splice			ck_fun		m@@	A S? S? L
push		push			ck_fun		imsT@@	A L
pop		pop			ck_shift	s%	A?
shift		shift			ck_shift	s%	A?
unshift		unshift			ck_fun		imsT@@	A L
sort		sort			ck_sort		dm@@	C? L
reverse		reverse			ck_fun		mt@@	L

grepstart	grep			ck_grep		dm@@	C L
grepwhile	grep iterator		ck_null		dt|	

mapstart	map			ck_grep		dm@@	C L
mapwhile	map iterator		ck_null		dt|

# Range stuff.

range		flipflop		ck_null		|	S S
flip		range (or flip)		ck_null		1	S S
flop		range (or flop)		ck_null		1

# Control.

and		logical and (&&)		ck_null		|	
or		logical or (||)			ck_null		|	
xor		logical xor			ck_null		fs2	S S	
dor		defined or (//)			ck_null		|
cond_expr	conditional expression		ck_null		d|	
andassign	logical and assignment (&&=)	ck_null		s|	
orassign	logical or assignment (||=)	ck_null		s|	
dorassign	defined or assignment (//=)	ck_null		s|

method		method lookup		ck_method	d1
entersub	subroutine entry	ck_subr		dmt1	L
leavesub	subroutine exit		ck_null		1	
leavesublv	lvalue subroutine return	ck_null		1	
caller		caller			ck_fun		t%	S?
warn		warn			ck_fun		imst@@	L
die		die			ck_die		dimst@@	L
reset		symbol reset		ck_fun		is%	S?

lineseq		line sequence		ck_null		@@	
nextstate	next statement		ck_null		s;	
dbstate		debug next statement	ck_null		s;	
unstack		iteration finalizer	ck_null		s0
enter		block entry		ck_null		0	
leave		block exit		ck_null		@@	
scope		block			ck_null		@@	
enteriter	foreach loop entry	ck_null		d{	
iter		foreach loop iterator	ck_null		0	
enterloop	loop entry		ck_null		d{	
leaveloop	loop exit		ck_null		2	
return		return			ck_return	dm@@	L
last		last			ck_null		ds}	
next		next			ck_null		ds}	
redo		redo			ck_null		ds}	
dump		dump			ck_null		ds}	
goto		goto			ck_null		ds}	
exit		exit			ck_exit		ds%	S?
method_named	method with known name	ck_null		d$

entergiven	given()			ck_null		d|
leavegiven	leave given block	ck_null		1
enterwhen	when()			ck_null		d|
leavewhen	leave when block	ck_null		1
break		break			ck_null		0
continue	continue		ck_null		0

# I/O.

open		open			ck_open		ismt@@	F S? L
close		close			ck_fun		is%	F?
pipe_op		pipe			ck_fun		is@@	F F

fileno		fileno			ck_fun		ist%	F
umask		umask			ck_fun		ist%	S?
binmode		binmode			ck_fun		s@@	F S?

tie		tie			ck_fun		idms@@	R S L
untie		untie			ck_fun		is%	R
tied		tied			ck_fun		s%	R
dbmopen		dbmopen			ck_fun		is@@	H S S
dbmclose	dbmclose		ck_fun		is%	H

sselect		select system call	ck_select	t@@	S S S S
select		select			ck_select	st@@	F?

getc		getc			ck_eof		st%	F?
read		read			ck_fun		imst@@	F R S S?
enterwrite	write			ck_fun		dis%	F?
leavewrite	write exit		ck_null		1	

prtf		printf			ck_listiob	ims@@	F? L
print		print			ck_listiob	ims@@	F? L
say		say			ck_listiob	ims@@	F? L

sysopen		sysopen			ck_fun		s@@	F S S S?
sysseek		sysseek			ck_fun		s@@	F S S
sysread		sysread			ck_fun		imst@@	F R S S?
syswrite	syswrite		ck_fun		imst@@	F S S? S?

eof		eof			ck_eof		is%	F?
tell		tell			ck_fun		st%	F?
seek		seek			ck_fun		s@@	F S S
# truncate really behaves as if it had both "S S" and "F S"
truncate	truncate		ck_trunc	is@@	S S

fcntl		fcntl			ck_fun		st@@	F S S
ioctl		ioctl			ck_fun		st@@	F S S
flock		flock			ck_fun		isT@@	F S

# Sockets.  OP_IS_SOCKET wants them consecutive (so moved 1st 2)

send		send			ck_fun		imst@@	Fs S S S?
recv		recv			ck_fun		imst@@	Fs R S S

socket		socket			ck_fun		is@@	Fs S S S
sockpair	socketpair		ck_fun		is@@	Fs Fs S S S

bind		bind			ck_fun		is@@	Fs S
connect		connect			ck_fun		is@@	Fs S
listen		listen			ck_fun		is@@	Fs S
accept		accept			ck_fun		ist@@	Fs Fs
shutdown	shutdown		ck_fun		ist@@	Fs S

gsockopt	getsockopt		ck_fun		is@@	Fs S S
ssockopt	setsockopt		ck_fun		is@@	Fs S S S

getsockname	getsockname		ck_fun		is%	Fs
getpeername	getpeername		ck_fun		is%	Fs

# Stat calls.  OP_IS_FILETEST wants them consecutive.

lstat		lstat			ck_ftst		u-	F
stat		stat			ck_ftst		u-	F
ftrread		-R			ck_ftst		isu-	F-+
ftrwrite	-W			ck_ftst		isu-	F-+
ftrexec		-X			ck_ftst		isu-	F-+
fteread		-r			ck_ftst		isu-	F-+
ftewrite	-w			ck_ftst		isu-	F-+
fteexec		-x			ck_ftst		isu-	F-+
ftis		-e			ck_ftst		isu-	F-
ftsize		-s			ck_ftst		istu-	F-
ftmtime		-M			ck_ftst		stu-	F-
ftatime		-A			ck_ftst		stu-	F-
ftctime		-C			ck_ftst		stu-	F-
ftrowned	-O			ck_ftst		isu-	F-
fteowned	-o			ck_ftst		isu-	F-
ftzero		-z			ck_ftst		isu-	F-
ftsock		-S			ck_ftst		isu-	F-
ftchr		-c			ck_ftst		isu-	F-
ftblk		-b			ck_ftst		isu-	F-
ftfile		-f			ck_ftst		isu-	F-
ftdir		-d			ck_ftst		isu-	F-
ftpipe		-p			ck_ftst		isu-	F-
ftsuid		-u			ck_ftst		isu-	F-
ftsgid		-g			ck_ftst		isu-	F-
ftsvtx		-k			ck_ftst		isu-	F-
ftlink		-l			ck_ftst		isu-	F-
fttty		-t			ck_ftst		is-	F-
fttext		-T			ck_ftst		isu-	F-
ftbinary	-B			ck_ftst		isu-	F-

# File calls.

# chdir really behaves as if it had both "S?" and "F?"
chdir		chdir			ck_chdir	isT%	S?
chown		chown			ck_fun		imsT@@	L
chroot		chroot			ck_fun		isTu%	S?
unlink		unlink			ck_fun		imsTu@@	L
chmod		chmod			ck_fun		imsT@@	L
utime		utime			ck_fun		imsT@@	L
rename		rename			ck_fun		isT@@	S S
link		link			ck_fun		isT@@	S S
symlink		symlink			ck_fun		isT@@	S S
readlink	readlink		ck_fun		stu%	S?
mkdir		mkdir			ck_fun		isTu@@	S? S?
rmdir		rmdir			ck_fun		isTu%	S?

# Directory calls.

open_dir	opendir			ck_fun		is@@	F S
readdir		readdir			ck_fun		%	F
telldir		telldir			ck_fun		st%	F
seekdir		seekdir			ck_fun		s@@	F S
rewinddir	rewinddir		ck_fun		s%	F
closedir	closedir		ck_fun		is%	F

# Process control.

fork		fork			ck_null		ist0	
wait		wait			ck_null		isT0	
waitpid		waitpid			ck_fun		isT@@	S S
system		system			ck_exec		imsT@@	S? L
exec		exec			ck_exec		dimsT@@	S? L
kill		kill			ck_fun		dimsT@@	L
getppid		getppid			ck_null		isT0	
getpgrp		getpgrp			ck_fun		isT%	S?
setpgrp		setpgrp			ck_fun		isT@@	S? S?
getpriority	getpriority		ck_fun		isT@@	S S
setpriority	setpriority		ck_fun		isT@@	S S S

# Time calls.

# NOTE: MacOS patches the 'i' of time() away later when the interpreter
# is created because in MacOS time() is already returning times > 2**31-1,
# that is, non-integers.

time		time			ck_null		isT0	
tms		times			ck_null		0	
localtime	localtime		ck_fun		t%	S?
gmtime		gmtime			ck_fun		t%	S?
alarm		alarm			ck_fun		istu%	S?
sleep		sleep			ck_fun		isT%	S?

# Shared memory.

shmget		shmget			ck_fun		imst@@	S S S
shmctl		shmctl			ck_fun		imst@@	S S S
shmread		shmread			ck_fun		imst@@	S S S S
shmwrite	shmwrite		ck_fun		imst@@	S S S S

# Message passing.

msgget		msgget			ck_fun		imst@@	S S
msgctl		msgctl			ck_fun		imst@@	S S S
msgsnd		msgsnd			ck_fun		imst@@	S S S
msgrcv		msgrcv			ck_fun		imst@@	S S S S S

# Semaphores.

semop		semop			ck_fun		imst@@	S S
semget		semget			ck_fun		imst@@	S S S
semctl		semctl			ck_fun		imst@@	S S S S

# Eval.

require		require			ck_require	du%	S?
dofile		do "file"		ck_fun		d1	S
hintseval	eval hints		ck_svconst	s$
entereval	eval "string"		ck_eval		d%	S
leaveeval	eval "string" exit	ck_null		1	S
#evalonce	eval constant string	ck_null		d1	S
entertry	eval {block}		ck_eval		d%	
leavetry	eval {block} exit	ck_null		@@	

# Get system info.

ghbyname	gethostbyname		ck_fun		%	S
ghbyaddr	gethostbyaddr		ck_fun		@@	S S
ghostent	gethostent		ck_null		0	
gnbyname	getnetbyname		ck_fun		%	S
gnbyaddr	getnetbyaddr		ck_fun		@@	S S
gnetent		getnetent		ck_null		0	
gpbyname	getprotobyname		ck_fun		%	S
gpbynumber	getprotobynumber	ck_fun		@@	S
gprotoent	getprotoent		ck_null		0	
gsbyname	getservbyname		ck_fun		@@	S S
gsbyport	getservbyport		ck_fun		@@	S S
gservent	getservent		ck_null		0	
shostent	sethostent		ck_fun		is%	S
snetent		setnetent		ck_fun		is%	S
sprotoent	setprotoent		ck_fun		is%	S
sservent	setservent		ck_fun		is%	S
ehostent	endhostent		ck_null		is0	
enetent		endnetent		ck_null		is0	
eprotoent	endprotoent		ck_null		is0	
eservent	endservent		ck_null		is0	
gpwnam		getpwnam		ck_fun		%	S
gpwuid		getpwuid		ck_fun		%	S
gpwent		getpwent		ck_null		0	
spwent		setpwent		ck_null		is0	
epwent		endpwent		ck_null		is0	
ggrnam		getgrnam		ck_fun		%	S
ggrgid		getgrgid		ck_fun		%	S
ggrent		getgrent		ck_null		0	
sgrent		setgrent		ck_null		is0	
egrent		endgrent		ck_null		is0	
getlogin	getlogin		ck_null		st0	

# Miscellaneous.

syscall		syscall			ck_fun		imst@@	S L

# For multi-threading
lock		lock			ck_rfun		s%	R

# For state support

once		once			ck_null		|	

custom		unknown custom operator		ck_null		0
@


1.13
log
@merge in perl 5.12.2 plus local changes
@
text
@@


1.12
log
@Merge in perl 5.10.1
@
text
@d33 1
a33 1
my (@@ops, %desc, %check, %ckname, %flags, %args);
d48 1
d108 1
d166 2
a167 1
    print $on "\t", &tab(3,"OP_\U$_,"), "/* ", $i++, " */\n";
d360 1
d380 4
a383 2
           $OP_IS_SOCKET{$op}   = 1 if $arg =~ s/s//;
           $OP_IS_FILETEST{$op} = 1 if $arg =~ s/-//;
d409 3
a411 6
if (keys %OP_IS_SOCKET) {
    print $on "\n#define OP_IS_SOCKET(op)	\\\n\t(";
    print $on join(" || \\\n\t ",
               map { "(op) == OP_" . uc() } sort keys %OP_IS_SOCKET);
    print $on ")\n\n";
}
d413 38
a450 5
if (keys %OP_IS_FILETEST) {
    print $on "\n#define OP_IS_FILETEST(op)	\\\n\t(";
    print $on join(" || \\\n\t ",
               map { "(op) == OP_" . uc() } sort keys %OP_IS_FILETEST);
    print $on ")\n\n";
d614 3
a616 1
# socket      - Fs           filetest - F-           reference - R
d774 1
a774 1
length		length			ck_lengthconst	ifsTu%	S?
d799 4
d805 3
a807 3
each		each			ck_fun		%	H
values		values			ck_fun		t%	H
keys		keys			ck_fun		t%	H
d813 1
a886 1
setstate	set statement info	ck_null		s;
a928 3
send		send			ck_fun		imst@@	Fs S S S?
recv		recv			ck_fun		imst@@	Fs R S S

d939 4
a942 1
# Sockets.
d959 1
a959 1
# Stat calls.
d963 6
a968 6
ftrread		-R			ck_ftst		isu-	F-
ftrwrite	-W			ck_ftst		isu-	F-
ftrexec		-X			ck_ftst		isu-	F-
fteread		-r			ck_ftst		isu-	F-
ftewrite	-w			ck_ftst		isu-	F-
fteexec		-x			ck_ftst		isu-	F-
d1067 1
d1071 1
a1071 1
entertry	eval {block}		ck_null		|	
@


1.11
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d2 15
d26 3
a28 5
open(OC, ">$opcode_new") || die "Can't create $opcode_new: $!\n";
binmode OC;
open(ON, ">$opname_new") || die "Can't create $opname_new: $!\n";
binmode ON;
select OC;
d142 1
a142 1
print ON <<"END";
d148 1
a148 1
 *    2007 by Larry Wall and others
d164 1
a164 1
    print ON "\t", &tab(3,"OP_\U$_,"), "/* ", $i++, " */\n";
d166 5
a170 5
print ON "\t", &tab(3,"OP_max"), "\n";
print ON "} opcode;\n";
print ON "\n#define MAXO ", scalar @@ops, "\n";
print ON "#define OP_phoney_INPUT_ONLY -1\n";
print ON "#define OP_phoney_OUTPUT_ONLY -2\n\n";
d305 2
d343 12
d357 2
d360 1
a360 1
for (@@ops) {
d362 13
a374 14
    my $flags = $flags{$_};
    $argsum |= 1 if $flags =~ /m/;		# needs stack mark
    $argsum |= 2 if $flags =~ /f/;		# fold constants
    $argsum |= 4 if $flags =~ /s/;		# always produces scalar
    $argsum |= 8 if $flags =~ /t/;		# needs target scalar
    $argsum |= (8|256) if $flags =~ /T/;	# ... which may be lexical
    $argsum |= 16 if $flags =~ /i/;		# always produces integer
    $argsum |= 32 if $flags =~ /I/;		# has corresponding int op
    $argsum |= 64 if $flags =~ /d/;		# danger, unknown side effects
    $argsum |= 128 if $flags =~ /u/;		# defaults to $_
    $flags =~ /([\W\d_])/ or die qq[Opcode "$_" has no class indicator];
    $argsum |= $opclass{$1} << 9;
    my $mul = 0x2000;				# 2 ^ OASHIFT
    for my $arg (split(' ',$args{$_})) {
d376 2
a377 2
           $OP_IS_SOCKET{$_}   = 1 if $arg =~ s/s//;
           $OP_IS_FILETEST{$_} = 1 if $arg =~ s/-//;
d380 2
a381 1
        die "op = $_, arg = $arg\n" unless length($arg) == 1;
d383 5
a387 4
	warn "# Conflicting bit 32 for '$_'.\n"
	    if $argnum & 8 and $mul == 0x10000000;
	$argsum += $argnum * $mul;
	$mul <<= 4;
d390 1
a390 1
    print "\t", &tab(3, "$argsum,"), "/* $_ */\n";
d404 2
a405 2
    print ON "\n#define OP_IS_SOCKET(op)	\\\n\t(";
    print ON join(" || \\\n\t ",
d407 1
a407 1
    print ON ")\n\n";
d411 2
a412 2
    print ON "\n#define OP_IS_FILETEST(op)	\\\n\t(";
    print ON join(" || \\\n\t ",
d414 1
a414 1
    print ON ")\n\n";
d417 2
a418 2
print OC "/* ex: set ro: */\n";
print ON "/* ex: set ro: */\n";
d420 2
a421 2
close OC or die "Error closing opcode.h: $!";
close ON or die "Error closing opnames.h: $!";
d423 2
a424 5
foreach ('opcode.h', 'opnames.h') {
    safer_rename_silent $_, "$_-old";
}
safer_rename $opcode_new, 'opcode.h';
safer_rename $opname_new, 'opnames.h';
d429 2
a430 4
open PP, ">$pp_proto_new" or die "Error creating $pp_proto_new: $!";
binmode PP;
open PPSYM, ">$pp_sym_new" or die "Error creating $pp_sym_new: $!";
binmode PPSYM;
d432 1
a432 1
print PP <<"END";
d441 1
a441 1
print PPSYM <<"END";
d453 2
a454 2
    print PP "PERL_CKDEF(Perl_$_)\n";
    print PPSYM "Perl_$_\n";
d458 1
a458 1
print PP "\n\n";
d463 2
a464 2
    print PP "PERL_PPDEF(Perl_pp_$_)\n";
    print PPSYM "Perl_pp_$_\n";
d466 2
a467 2
print PP "\n/* ex: set ro: */\n";
print PPSYM "\n# ex: set ro:\n";
d469 2
a470 2
close PP or die "Error closing pp_proto.h: $!";
close PPSYM or die "Error closing pp.sym: $!";
d472 2
a473 5
foreach ('pp_proto.h', 'pp.sym') {
    safer_rename_silent $_, "$_-old";
}
safer_rename $pp_proto_new, 'pp_proto.h';
safer_rename $pp_sym_new, 'pp.sym';
d736 1
a736 1
length		length			ck_lengthconst	isTu%	S?
d743 1
a743 1
sprintf		sprintf			ck_fun		mst@@	S L
d769 1
a769 1
helem		hash element		ck_null		s2@@	H S
@


1.10
log
@merge in perl 5.8.8
@
text
@d1 3
a3 1
#!/usr/bin/perl
d9 2
a10 2
$opcode_new = 'opcode.h-new';
$opname_new = 'opnames.h-new';
d19 3
d26 2
a27 1
    ($key, $desc, $check, $flags, $args) = split(/\t+/, $_, 5);
d42 58
a101 1
$i = 0;
d107 2
a108 2
 *    Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999,
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006 by Larry Wall and others
d118 2
d125 2
d135 1
a135 1
 *    by Larry Wall and others
d149 1
a161 1

a163 1

d170 1
a170 1
EXT char *PL_op_name[];
d172 1
a172 1
EXT char *PL_op_name[] = {
d187 1
a187 1
EXT char *PL_op_desc[];
d189 1
a189 1
EXT char *PL_op_desc[] = {
d207 1
d228 3
a230 2
#ifndef DOINIT
EXT OP * (CPERLscope(*PL_ppaddr)[])(pTHX);
d232 8
a239 1
EXT OP * (CPERLscope(*PL_ppaddr)[])(pTHX) = {
d243 6
a248 1
    print "\tMEMBER_TO_FPTR(Perl_pp_$_),\n" unless $_ eq "custom";
d252 4
a255 1
};
d263 3
a265 2
#ifndef DOINIT
EXT OP * (CPERLscope(*PL_check)[]) (pTHX_ OP *op);
d267 8
a274 1
EXT OP * (CPERLscope(*PL_check)[]) (pTHX_ OP *op) = {
d282 1
a282 1
};
d284 3
d293 2
d296 1
a296 1
EXT U32 PL_opargs[];
d298 1
a298 1
EXT U32 PL_opargs[] = {
d301 8
a308 8
%argnum = (
    S,	1,		# scalar
    L,	2,		# list
    A,	3,		# array value
    H,	4,		# hash value
    C,	5,		# code value
    F,	6,		# file value
    R,	7,		# scalar reference
d311 1
a311 1
%opclass = (
d332 2
a333 2
    $argsum = 0;
    $flags = $flags{$_};
d345 2
a346 2
    $mul = 0x2000;				# 2 ^ OASHIFT
    for $arg (split(' ',$args{$_})) {
d351 1
a351 1
	$argnum = ($arg =~ s/\?//) ? 8 : 0;
d367 2
d370 1
d399 2
a400 2
$pp_proto_new = 'pp_proto.h-new';
$pp_sym_new  = 'pp.sym-new';
d461 1
a461 1
    local($l, $t) = @@_;
d525 2
a526 1
# New ops always go at the end, just before 'custom'
d597 1
a597 1
backtick	quoted execution (``, qx)	ck_open		t%	
d600 1
a600 1
readline	<HANDLE>		ck_null		t%	F?
d610 1
a610 1
subst		substitution (s///)	ck_null		dis/	S
d612 1
a612 1
trans		transliteration (tr///)	ck_null		is"	S
d692 2
d752 1
a752 1
unpack		unpack			ck_fun		@@	S S
d769 1
a769 1
sort		sort			ck_sort		m@@	C? L
d789 1
d793 1
d822 2
a823 1
# continued below
d825 6
a830 2
#nswitch	numeric switch		ck_null		d	
#cswitch	character switch	ck_null		d	
d858 1
a905 3
fteowned	-o			ck_ftst		isu-	F-
ftrowned	-O			ck_ftst		isu-	F-
ftzero		-z			ck_ftst		isu-	F-
d910 3
a918 1
ftlink		-l			ck_ftst		isu-	F-
d922 1
d929 2
a930 1
chdir		chdir			ck_fun		isT%	S?
d940 1
a940 1
mkdir		mkdir			ck_fun		isT@@	S S?
d995 1
a997 1
semop		semop			ck_fun		imst@@	S S
a1048 1
threadsv	per-thread value	ck_null		ds0
d1050 1
a1050 3
# Control (contd.)
setstate	set statement info	ck_null		s;
method_named	method with known name	ck_null		d$
d1052 1
a1052 1
# Add new ops before this, the custom operator.
@


1.9
log
@The official fix for the Perl sprintf buffer overflow.

ok millert@@
@
text
@d10 1
d12 1
d40 2
a41 1
/*
d45 1
a45 1
 *    2000, 2001, 2002, 2003, 2004, by Larry Wall and others
d63 2
a64 1
/*
d67 2
a68 1
 *    Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, by Larry Wall and others
d288 3
d304 1
d306 1
d309 2
a310 1
/* !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
d318 1
d342 2
d796 2
a797 2
fteowned	-O			ck_ftst		isu-	F-
ftrowned	-o			ck_ftst		isu-	F-
@


1.8
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d605 1
a605 1
sprintf		sprintf			ck_fun		mfst@@	S L
@


1.8.4.1
log
@MFC:
Fix by brad@@

The official fix for the Perl sprintf buffer overflow.
@
text
@d605 1
a605 1
sprintf		sprintf			ck_fun		mst@@	S L
@


1.8.6.1
log
@MFC:
Fix by brad@@

The official fix for the Perl sprintf buffer overflow.
@
text
@d605 1
a605 1
sprintf		sprintf			ck_fun		mst@@	S L
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d42 1
a42 1
 *    2000, 2001, 2002, 2003, by Larry Wall and others
d63 1
a63 1
 *    Copyright (C) 1999, 2000, 2001, 2002, 2003, by Larry Wall and others
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d2 4
d41 2
a42 1
 *    Copyright (c) 1997-2002, Larry Wall
d63 1
a63 1
 *    Copyright (c) 1997-2002, Larry Wall
d93 4
a96 4
#define OP_NAME(o) (o->op_type == OP_CUSTOM ? custom_op_name(o) : \\
                    PL_op_name[o->op_type])
#define OP_DESC(o) (o->op_type == OP_CUSTOM ? custom_op_desc(o) : \\
                    PL_op_desc[o->op_type])
d286 5
a290 9
chmod 0600, 'opcode.h';  # required by dosish filesystems
chmod 0600, 'opnames.h'; # required by dosish filesystems

# Some dosish systems can't rename over an existing file:
unlink		"$_-old"	for qw(opcode.h opnames.h);
rename $_,	"$_-old"	for qw(opcode.h opnames.h);

rename $opcode_new, 'opcode.h' or die "renaming opcode.h: $!\n";
rename $opname_new, 'opnames.h' or die "renaming opnames.h: $!\n";
d334 5
a338 2
chmod 0600, 'pp_proto.h'; # required by dosish filesystems
chmod 0600, 'pp.sym';     # required by dosish filesystems
d340 5
a344 6
# Some dosish systems can't rename over an existing file:
unlink		"$_-old"	for qw(pp_proto.h pp.sym);
rename $_,	"$_-old"	for qw(pp_proto.h pp.sym);

rename $pp_proto_new, 'pp_proto.h' or die "rename pp_proto.h: $!\n";
rename $pp_sym_new, 'pp.sym' or die "rename pp.sym: $!\n";
d426 1
a426 1
# pvop/svop   - "
d650 2
a651 2
pop		pop			ck_shift	s%	A
shift		shift			ck_shift	s%	A
d923 1
a923 1
lock		lock			ck_rfun		s%	S
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d3 4
a6 4
chmod 0666, "opcode.h", "opnames.h";
unlink "opcode.h", "opnames.h";
open(OC, ">opcode.h") || die "Can't create opcode.h: $!\n";
open(ON, ">opnames.h") || die "Can't create opnames.h: $!\n";
d34 12
a45 4
/* !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!! 
   This file is built by opcode.pl from its data.  Any changes made here
   will be lost!
*/
d55 13
a67 4
/* !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!! 
   This file is built by opcode.pl from its data.  Any changes made here
   will be lost!
*/
d77 3
a79 1
print ON "\n#define MAXO ", scalar @@ops, "\n\n"; 
d87 6
d119 1
a119 1
    # Have to escape double quotes and escape characters.    
d158 1
a158 1
    print "\tMEMBER_TO_FPTR(Perl_pp_$_),\n";
a236 1

d281 15
a295 4
unlink "pp_proto.h";
unlink "pp.sym";
open PP, '>pp_proto.h' or die "Error creating pp_proto.h: $!";
open PPSYM, '>pp.sym' or die "Error creating pp.sym: $!";
d298 1
a298 1
/* !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!! 
d307 1
a307 1
# !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!! 
d325 1
d333 10
d409 32
a440 1
# New ops always go at the very end
d483 2
a484 2
readline	<HANDLE>		ck_null		t%	
rcatline	append I/O operator	ck_null		t%	
d558 4
a561 4
slt		string lt		ck_scmp		ifs2	S S
sgt		string gt		ck_scmp		ifs2	S S
sle		string le		ck_scmp		ifs2	S S
sge		string ge		ck_scmp		ifs2	S S
d564 1
a564 1
scmp		string comparison (cmp)	ck_scmp		ifst2	S S
d602 1
a602 1
sprintf		sprintf			ck_fun_locale	mfst@@	S L
d607 4
a610 4
ucfirst		ucfirst			ck_fun_locale	fstu%	S?
lcfirst		lcfirst			ck_fun_locale	fstu%	S?
uc		uc			ck_fun_locale	fstu%	S?
lc		lc			ck_fun_locale	fstu%	S?
d680 1
a680 1
die		die			ck_fun		dimst@@	L
d708 1
a708 1
open		open			ck_open		ist@@	F S? L
d926 4
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d3 1
d197 3
d217 4
d222 1
d240 14
d325 1
a325 1
#	each repeat not OK too due to array context
d460 1
a460 1
concat		concatenation (.)	ck_concat	fsT2	S S
d519 1
a519 1
substr		substr			ck_fun		st@@	S S S? S?
d559 1
a559 1
join		join			ck_join		mst@@	S L
d600 1
a600 1
leavesublv	lvalue subroutine exit	ck_null		1	
d617 1
a617 1
return		return			ck_null		dm@@	L
d661 2
a662 2
send		send			ck_fun		imst@@	F S S S?
recv		recv			ck_fun		imst@@	F R S S
d676 2
a677 2
socket		socket			ck_fun		is@@	F S S S
sockpair	socketpair		ck_fun		is@@	F F S S S
d679 5
a683 5
bind		bind			ck_fun		is@@	F S
connect		connect			ck_fun		is@@	F S
listen		listen			ck_fun		is@@	F S
accept		accept			ck_fun		ist@@	F F
shutdown	shutdown		ck_fun		ist@@	F S
d685 2
a686 2
gsockopt	getsockopt		ck_fun		is@@	F S S
ssockopt	setsockopt		ck_fun		is@@	F S S S
d688 2
a689 2
getsockname	getsockname		ck_fun		is%	F
getpeername	getpeername		ck_fun		is%	F
d695 27
a721 27
ftrread		-R			ck_ftst		isu-	F
ftrwrite	-W			ck_ftst		isu-	F
ftrexec		-X			ck_ftst		isu-	F
fteread		-r			ck_ftst		isu-	F
ftewrite	-w			ck_ftst		isu-	F
fteexec		-x			ck_ftst		isu-	F
ftis		-e			ck_ftst		isu-	F
fteowned	-O			ck_ftst		isu-	F
ftrowned	-o			ck_ftst		isu-	F
ftzero		-z			ck_ftst		isu-	F
ftsize		-s			ck_ftst		istu-	F
ftmtime		-M			ck_ftst		stu-	F
ftatime		-A			ck_ftst		stu-	F
ftctime		-C			ck_ftst		stu-	F
ftsock		-S			ck_ftst		isu-	F
ftchr		-c			ck_ftst		isu-	F
ftblk		-b			ck_ftst		isu-	F
ftfile		-f			ck_ftst		isu-	F
ftdir		-d			ck_ftst		isu-	F
ftpipe		-p			ck_ftst		isu-	F
ftlink		-l			ck_ftst		isu-	F
ftsuid		-u			ck_ftst		isu-	F
ftsgid		-g			ck_ftst		isu-	F
ftsvtx		-k			ck_ftst		isu-	F
fttty		-t			ck_ftst		is-	F
fttext		-T			ck_ftst		isu-	F
ftbinary	-B			ck_ftst		isu-	F
@


1.3
log
@perl5.005_03 (stock)
@
text
@d3 1
a3 1
unlink "opcode.h";
d5 1
d33 4
a36 4
#define pp_i_preinc pp_preinc
#define pp_i_predec pp_predec
#define pp_i_postinc pp_postinc
#define pp_i_postdec pp_postdec
d38 14
a51 1
typedef enum {
d53 1
d55 1
a55 1
    print "\t", &tab(3,"OP_\U$_,"), "/* ", $i++, " */\n";
d57 3
a59 3
print "\t", &tab(3,"OP_max"), "\n";
print "} opcode;\n";
print "\n#define MAXO ", scalar @@ops, "\n\n"; 
d64 3
d68 1
a68 1
EXT char *op_name[];
d70 1
a70 1
EXT char *op_name[] = {
d85 1
a85 1
EXT char *op_desc[];
d87 1
a87 1
EXT char *op_desc[] = {
d91 6
a96 1
    print qq(\t"$desc{$_}",\n);
d103 1
a103 2
#ifndef PERL_OBJECT
START_EXTERN_C
d109 9
a117 9
for (sort keys %ckname) {
    print "OP *\t", &tab(3,$_),"_((OP* o));\n";
}

print "\n";

for (@@ops) {
    print "OP *\t", &tab(3, "pp_$_"), "_((ARGSproto));\n";
}
d123 1
a123 2
END_EXTERN_C
#endif	/* PERL_OBJECT */
d126 1
a126 1
EXT OP * (CPERLscope(*ppaddr)[])(ARGSproto);
d128 1
a128 2
#ifndef PERL_OBJECT
EXT OP * (CPERLscope(*ppaddr)[])(ARGSproto) = {
d132 1
a132 1
    print "\tpp_$_,\n";
a136 1
#endif	/* PERL_OBJECT */
d145 1
a145 1
EXT OP * (CPERLscope(*check)[]) _((OP *op));
d147 1
a147 2
#ifndef PERL_OBJECT
EXT OP * (CPERLscope(*check)[]) _((OP *op)) = {
d151 1
a151 1
    print "\t", &tab(3, "$check{$_},"), "/* $_ */\n";
a155 1
#endif	/* PERL_OBJECT */
d164 1
a164 1
EXT U32 opargs[];
d166 1
a166 1
EXT U32 opargs[] = {
d184 10
a193 11
    '?',  4,		# condop
    '@@',  5,		# listop
    '/',  6,		# pmop
    '$',  7,		# svop
    '*',  8,		# gvop
    '"',  9,		# pvop
    '{',  10,		# loop
    ';',  11,		# cop
    '%',  12,		# baseop_or_unop
    '-',  13,		# filestatop
    '}',  14,		# loopexop
d203 1
d210 2
a211 2
    $argsum |= $opclass{$1} << 8;
    $mul = 4096;				# 2 ^ OASHIFT
d215 2
d227 2
d232 1
d235 1
d237 28
d267 2
a268 1
    print PP "PPDEF(pp_$_)\n";
d272 1
d281 57
d340 2
d355 2
a356 2
gvsv		scalar variable		ck_null		ds*	
gv		glob value		ck_null		ds*	
d361 1
a361 1
padany		private something	ck_null		d0
d368 1
a368 1
rv2sv		scalar deref		ck_rvconst	ds1	
d370 1
a370 1
rv2cv		subroutine deref	ck_rvconst	d1
d374 1
a374 1
srefgen		scalar ref constructor	ck_null		fs1	S
d380 1
a380 1
backtick	backticks		ck_null		t%	
d382 1
a382 1
glob		glob			ck_glob		t@@	S? S?
d388 2
a389 2
regcmaybe	regexp comp once	ck_fun		s1	S
regcreset	regexp reset interpolation flag	ck_fun		s1	S
d391 5
a395 5
match		pattern match		ck_match	d/
qr		pattern quote		ck_match	s/
subst		substitution		ck_null		dis/	S
substcont	substitution cont	ck_null		dis|	
trans		character translation	ck_null		is"	S
d400 1
a400 1
sassign		scalar assignment	ck_null		s0
d405 3
a407 3
chomp		safe chop		ck_spair	mts%	L
schomp		scalar safe chop	ck_null		stu%	S?
defined		defined operator	ck_rfun		isu%	S?
d412 8
a419 8
preinc		preincrement		ck_lfun		dIs1	S
i_preinc	integer preincrement	ck_lfun		dis1	S
predec		predecrement		ck_lfun		dIs1	S
i_predec	integer predecrement	ck_lfun		dis1	S
postinc		postincrement		ck_lfun		dIst1	S
i_postinc	integer postincrement	ck_lfun		dist1	S
postdec		postdecrement		ck_lfun		dIst1	S
i_postdec	integer postdecrement	ck_lfun		dist1	S
d423 1
a423 1
pow		exponentiation		ck_null		fst2	S S
d425 32
a456 32
multiply	multiplication		ck_null		Ifst2	S S
i_multiply	integer multiplication	ck_null		ifst2	S S
divide		division		ck_null		Ifst2	S S
i_divide	integer division	ck_null		ifst2	S S
modulo		modulus			ck_null		Iifst2	S S
i_modulo	integer modulus		ck_null		ifst2	S S
repeat		repeat			ck_repeat	mt2	L S

add		addition		ck_null		Ifst2	S S
i_add		integer addition	ck_null		ifst2	S S
subtract	subtraction		ck_null		Ifst2	S S
i_subtract	integer subtraction	ck_null		ifst2	S S
concat		concatenation		ck_concat	fst2	S S
stringify	string			ck_fun		fst@@	S

left_shift	left bitshift		ck_bitop	fst2	S S
right_shift	right bitshift		ck_bitop	fst2	S S

lt		numeric lt		ck_null		Iifs2	S S
i_lt		integer lt		ck_null		ifs2	S S
gt		numeric gt		ck_null		Iifs2	S S
i_gt		integer gt		ck_null		ifs2	S S
le		numeric le		ck_null		Iifs2	S S
i_le		integer le		ck_null		ifs2	S S
ge		numeric ge		ck_null		Iifs2	S S
i_ge		integer ge		ck_null		ifs2	S S
eq		numeric eq		ck_null		Iifs2	S S
i_eq		integer eq		ck_null		ifs2	S S
ne		numeric ne		ck_null		Iifs2	S S
i_ne		integer ne		ck_null		ifs2	S S
ncmp		spaceship operator	ck_null		Iifst2	S S
i_ncmp		integer spaceship	ck_null		ifst2	S S
d464 1
a464 1
scmp		string comparison	ck_scmp		ifst2	S S
d466 3
a468 3
bit_and		bitwise and		ck_bitop	fst2	S S
bit_xor		bitwise xor		ck_bitop	fst2	S S
bit_or		bitwise or		ck_bitop	fst2	S S
d470 2
a471 2
negate		negate			ck_null		Ifst1	S
i_negate	integer negate		ck_null		ifst1	S
d473 1
a473 1
complement	1's complement		ck_bitop	fst1	S
d477 4
a480 4
atan2		atan2			ck_fun		fst@@	S S
sin		sin			ck_fun		fstu%	S?
cos		cos			ck_fun		fstu%	S?
rand		rand			ck_fun		st%	S?
d482 3
a484 3
exp		exp			ck_fun		fstu%	S?
log		log			ck_fun		fstu%	S?
sqrt		sqrt			ck_fun		fstu%	S?
d488 4
a491 4
int		int			ck_fun		fstu%	S?
hex		hex			ck_fun		fstu%	S?
oct		oct			ck_fun		fstu%	S?
abs		abs			ck_fun		fstu%	S?
d495 1
a495 1
length		length			ck_lengthconst	istu%	S?
d499 2
a500 2
index		index			ck_index	ist@@	S S S?
rindex		rindex			ck_index	ist@@	S S S?
d504 8
a511 8
ord		ord			ck_fun		ifstu%	S?
chr		chr			ck_fun		fstu%	S?
crypt		crypt			ck_fun		fst@@	S S
ucfirst		upper case first	ck_fun_locale	fstu%	S?
lcfirst		lower case first	ck_fun_locale	fstu%	S?
uc		upper case		ck_fun_locale	fstu%	S?
lc		lower case		ck_fun_locale	fstu%	S?
quotemeta	quote metachars		ck_fun		fstu%	S?
d515 2
a516 2
rv2av		array deref		ck_rvconst	dt1	
aelemfast	known array element	ck_null		s*	A S
d522 1
a522 1
each		each			ck_fun		t%	H
d526 3
a528 3
exists		exists operator		ck_exists	is%	S
rv2hv		hash deref		ck_rvconst	dt1	
helem		hash elem		ck_null		s2@@	H S
d536 1
a536 1
join		join			ck_fun		mst@@	S L
d542 2
a543 2
anonlist	anonymous list		ck_fun		ms@@	L
anonhash	anonymous hash		ck_fun		ms@@	L
d546 1
a546 1
push		push			ck_fun		imst@@	A L
d549 1
a549 1
unshift		unshift			ck_fun		imst@@	A L
d561 1
a561 1
range		flipflop		ck_null		?	S S
d567 6
a572 6
and		logical and		ck_null		|	
or		logical or		ck_null		|	
xor		logical xor		ck_null		fs|	S S	
cond_expr	conditional expression	ck_null		d?	
andassign	logical and assignment	ck_null		s|	
orassign	logical or assignment	ck_null		s|	
d574 1
a574 1
method		method lookup		ck_null		d1
d577 1
d581 1
a581 1
reset		reset			ck_fun		is%	S?
d600 2
a601 1
exit		exit			ck_fun		ds%	S?
d603 2
a604 2
#nswitch		numeric switch		ck_null		d	
#cswitch		character switch	ck_null		d	
d608 1
a608 1
open		open			ck_fun		ist@@	F S?
d614 1
a614 1
binmode		binmode			ck_fun		s%	F
d649 1
a649 1
flock		flock			ck_fun		ist@@	F S
d702 9
a710 9
chdir		chdir			ck_fun		ist%	S?
chown		chown			ck_fun		imst@@	L
chroot		chroot			ck_fun		istu%	S?
unlink		unlink			ck_fun		imstu@@	L
chmod		chmod			ck_fun		imst@@	L
utime		utime			ck_fun		imst@@	L
rename		rename			ck_fun		ist@@	S S
link		link			ck_fun		ist@@	S S
symlink		symlink			ck_fun		ist@@	S S
d712 2
a713 2
mkdir		mkdir			ck_fun		ist@@	S S
rmdir		rmdir			ck_fun		istu%	S?
d727 10
a736 10
wait		wait			ck_null		ist0	
waitpid		waitpid			ck_fun		ist@@	S S
system		system			ck_exec		imst@@	S? L
exec		exec			ck_exec		dimst@@	S? L
kill		kill			ck_fun		dimst@@	L
getppid		getppid			ck_null		ist0	
getpgrp		getpgrp			ck_fun		ist%	S?
setpgrp		setpgrp			ck_fun		ist@@	S? S?
getpriority	getpriority		ck_fun		ist@@	S S
setpriority	setpriority		ck_fun		ist@@	S S S
d740 5
a744 1
time		time			ck_null		ist0	
d749 1
a749 1
sleep		sleep			ck_fun		ist%	S?
d774 3
a776 3
dofile		do 'file'		ck_fun		d1	S
entereval	eval string		ck_eval		d%	S
leaveeval	eval exit		ck_null		1	S
d778 2
a779 2
entertry	eval block		ck_null		|	
leavetry	eval block exit		ck_null		@@	
d821 5
a825 1
threadsv	per-thread variable	ck_null		ds0
@


1.2
log
@perl 5.004_04
@
text
@d80 3
d88 1
a88 1
    print "OP *\t", &tab(3,$_),"_((OP* op));\n";
d94 1
a94 1
    print "OP *\t", &tab(3, "pp_\L$_"), "_((void));\n";
d101 3
d105 1
a105 1
EXT OP * (*ppaddr[])();
d107 2
a108 1
EXT OP * (*ppaddr[])() = {
d112 1
a112 1
    print "\tpp_\L$_,\n";
d117 1
d126 1
a126 1
EXT OP * (*check[]) _((OP *op));
d128 2
a129 1
EXT OP * (*check[]) _((OP *op)) = {
d133 1
a133 1
    print "\t", &tab(3, "$check{$_},"), "/* \L$_ */\n";
d138 1
d162 18
d191 4
a194 1
    $mul = 256;
d202 1
a202 1
    print "\t", &tab(3, "$argsum,"), "/* \L$_ */\n";
d210 11
d234 1
a234 1
scalar		scalar			ck_fun		s	S
d238 2
a239 2
pushmark	pushmark		ck_null		s	
wantarray	wantarray		ck_null		is	
d241 1
a241 1
const		constant item		ck_svconst	s	
d243 7
a249 7
gvsv		scalar variable		ck_null		ds	
gv		glob value		ck_null		ds	
gelem		glob elem		ck_null		d	S S
padsv		private variable	ck_null		ds
padav		private array		ck_null		d
padhv		private hash		ck_null		d
padany		private something	ck_null		d
d251 1
a251 1
pushre		push regexp		ck_null		0
d255 10
a264 10
rv2gv		ref-to-glob cast	ck_rvconst	ds	
rv2sv		scalar deref		ck_rvconst	ds	
av2arylen	array length		ck_null		is	
rv2cv		subroutine deref	ck_rvconst	d
anoncode	anonymous subroutine	ck_anoncode	0	
prototype	subroutine prototype	ck_null		s	S
refgen		reference constructor	ck_spair	m	L
srefgen		scalar ref constructor	ck_null		fs	S
ref		reference-type operator	ck_fun		stu	S?
bless		bless			ck_fun		s	S S?
d268 1
a268 1
backtick	backticks		ck_null		t	
d270 3
a272 3
glob		glob			ck_glob		t	S? S?
readline	<HANDLE>		ck_null		t	
rcatline	append I/O operator	ck_null		t	
d276 8
a283 6
regcmaybe	regexp comp once	ck_fun		s	S
regcomp		regexp compilation	ck_null		s	S
match		pattern match		ck_match	d
subst		substitution		ck_null		dis	S
substcont	substitution cont	ck_null		dis	
trans		character translation	ck_null		is	S
d286 1
d288 2
a289 2
sassign		scalar assignment	ck_null		s
aassign		list assignment		ck_null		t	L L
d291 17
a307 17
chop		chop			ck_spair	mts	L
schop		scalar chop		ck_null		stu	S?
chomp		safe chop		ck_spair	mts	L
schomp		scalar safe chop	ck_null		stu	S?
defined		defined operator	ck_rfun		isu	S?
undef		undef operator		ck_lfun		s	S?
study		study			ck_fun		su	S?
pos		match position		ck_lfun		stu	S?

preinc		preincrement		ck_lfun		dIs	S
i_preinc	integer preincrement	ck_lfun		dis	S
predec		predecrement		ck_lfun		dIs	S
i_predec	integer predecrement	ck_lfun		dis	S
postinc		postincrement		ck_lfun		dIst	S
i_postinc	integer postincrement	ck_lfun		dist	S
postdec		postdecrement		ck_lfun		dIst	S
i_postdec	integer postdecrement	ck_lfun		dist	S
d311 1
a311 1
pow		exponentiation		ck_null		fst	S S
d313 49
a361 49
multiply	multiplication		ck_null		Ifst	S S
i_multiply	integer multiplication	ck_null		ifst	S S
divide		division		ck_null		Ifst	S S
i_divide	integer division	ck_null		ifst	S S
modulo		modulus			ck_null		Iifst	S S
i_modulo	integer modulus		ck_null		ifst	S S
repeat		repeat			ck_repeat	mt	L S

add		addition		ck_null		Ifst	S S
i_add		integer addition	ck_null		ifst	S S
subtract	subtraction		ck_null		Ifst	S S
i_subtract	integer subtraction	ck_null		ifst	S S
concat		concatenation		ck_concat	fst	S S
stringify	string			ck_fun		fst	S

left_shift	left bitshift		ck_bitop	fst	S S
right_shift	right bitshift		ck_bitop	fst	S S

lt		numeric lt		ck_null		Iifs	S S
i_lt		integer lt		ck_null		ifs	S S
gt		numeric gt		ck_null		Iifs	S S
i_gt		integer gt		ck_null		ifs	S S
le		numeric le		ck_null		Iifs	S S
i_le		integer le		ck_null		ifs	S S
ge		numeric ge		ck_null		Iifs	S S
i_ge		integer ge		ck_null		ifs	S S
eq		numeric eq		ck_null		Iifs	S S
i_eq		integer eq		ck_null		ifs	S S
ne		numeric ne		ck_null		Iifs	S S
i_ne		integer ne		ck_null		ifs	S S
ncmp		spaceship operator	ck_null		Iifst	S S
i_ncmp		integer spaceship	ck_null		ifst	S S

slt		string lt		ck_scmp		ifs	S S
sgt		string gt		ck_scmp		ifs	S S
sle		string le		ck_scmp		ifs	S S
sge		string ge		ck_scmp		ifs	S S
seq		string eq		ck_null		ifs	S S
sne		string ne		ck_null		ifs	S S
scmp		string comparison	ck_scmp		ifst	S S

bit_and		bitwise and		ck_bitop	fst	S S
bit_xor		bitwise xor		ck_bitop	fst	S S
bit_or		bitwise or		ck_bitop	fst	S S

negate		negate			ck_null		Ifst	S
i_negate	integer negate		ck_null		ifst	S
not		not			ck_null		ifs	S
complement	1's complement		ck_bitop	fst	S
d365 8
a372 8
atan2		atan2			ck_fun		fst	S S
sin		sin			ck_fun		fstu	S?
cos		cos			ck_fun		fstu	S?
rand		rand			ck_fun		st	S?
srand		srand			ck_fun		s	S?
exp		exp			ck_fun		fstu	S?
log		log			ck_fun		fstu	S?
sqrt		sqrt			ck_fun		fstu	S?
d376 4
a379 4
int		int			ck_fun		fstu	S?
hex		hex			ck_fun		fstu	S?
oct		oct			ck_fun		fstu	S?
abs		abs			ck_fun		fstu	S?
d383 17
a399 17
length		length			ck_lengthconst	istu	S?
substr		substr			ck_fun		st	S S S?
vec		vec			ck_fun		ist	S S S

index		index			ck_index	ist	S S S?
rindex		rindex			ck_index	ist	S S S?

sprintf		sprintf			ck_fun_locale	mfst	S L
formline	formline		ck_fun		ms	S L
ord		ord			ck_fun		ifstu	S?
chr		chr			ck_fun		fstu	S?
crypt		crypt			ck_fun		fst	S S
ucfirst		upper case first	ck_fun_locale	fstu	S?
lcfirst		lower case first	ck_fun_locale	fstu	S?
uc		upper case		ck_fun_locale	fstu	S?
lc		lower case		ck_fun_locale	fstu	S?
quotemeta	quote metachars		ck_fun		fstu	S?
d403 4
a406 4
rv2av		array deref		ck_rvconst	dt	
aelemfast	known array element	ck_null		s	A S
aelem		array element		ck_null		s	A S
aslice		array slice		ck_null		m	A L
d410 8
a417 8
each		each			ck_fun		t	H
values		values			ck_fun		t	H
keys		keys			ck_fun		t	H
delete		delete			ck_delete	0	S
exists		exists operator		ck_exists	is	S
rv2hv		hash deref		ck_rvconst	dt	
helem		hash elem		ck_null		s	H S
hslice		hash slice		ck_null		m	H L
d421 4
a424 4
unpack		unpack			ck_fun		0	S S
pack		pack			ck_fun		mst	S L
split		split			ck_split	t	S S S
join		join			ck_fun		mst	S L
d428 12
a439 12
list		list			ck_null		m	L
lslice		list slice		ck_null		0	H L L
anonlist	anonymous list		ck_fun		ms	L
anonhash	anonymous hash		ck_fun		ms	L

splice		splice			ck_fun		m	A S? S? L
push		push			ck_fun		imst	A L
pop		pop			ck_shift	s	A
shift		shift			ck_shift	s	A
unshift		unshift			ck_fun		imst	A L
sort		sort			ck_sort		m	C? L
reverse		reverse			ck_fun		mt	L
d441 2
a442 2
grepstart	grep			ck_grep		dm	C L
grepwhile	grep iterator		ck_null		dt	
d444 2
a445 2
mapstart	map			ck_grep		dm	C L
mapwhile	map iterator		ck_null		dt
d449 3
a451 3
range		flipflop		ck_null		0	S S
flip		range (or flip)		ck_null		0	S S
flop		range (or flop)		ck_null		0
d455 19
a473 19
and		logical and		ck_null		0	
or		logical or		ck_null		0	
xor		logical xor		ck_null		fs	S S	
cond_expr	conditional expression	ck_null		d	
andassign	logical and assignment	ck_null		s	
orassign	logical or assignment	ck_null		s	

method		method lookup		ck_null		d
entersub	subroutine entry	ck_subr		dmt	L
leavesub	subroutine exit		ck_null		0	
caller		caller			ck_fun		t	S?
warn		warn			ck_fun		imst	L
die		die			ck_fun		dimst	L
reset		reset			ck_fun		is	S?

lineseq		line sequence		ck_null		0	
nextstate	next statement		ck_null		s	
dbstate		debug next statement	ck_null		s	
unstack		unstack			ck_null		s
d475 3
a477 3
leave		block exit		ck_null		0	
scope		block			ck_null		0	
enteriter	foreach loop entry	ck_null		d	
d479 9
a487 9
enterloop	loop entry		ck_null		d	
leaveloop	loop exit		ck_null		0	
return		return			ck_null		dm	L
last		last			ck_null		ds	
next		next			ck_null		ds	
redo		redo			ck_null		ds	
dump		dump			ck_null		ds	
goto		goto			ck_null		ds	
exit		exit			ck_fun		ds	S?
d494 36
a529 36
open		open			ck_fun		ist	F S?
close		close			ck_fun		is	F?
pipe_op		pipe			ck_fun		is	F F

fileno		fileno			ck_fun		ist	F
umask		umask			ck_fun		ist	S?
binmode		binmode			ck_fun		s	F

tie		tie			ck_fun		idms	R S L
untie		untie			ck_fun		is	R
tied		tied			ck_fun		s	R
dbmopen		dbmopen			ck_fun		is	H S S
dbmclose	dbmclose		ck_fun		is	H

sselect		select system call	ck_select	t	S S S S
select		select			ck_select	st	F?

getc		getc			ck_eof		st	F?
read		read			ck_fun		imst	F R S S?
enterwrite	write			ck_fun		dis	F?
leavewrite	write exit		ck_null		0	

prtf		printf			ck_listiob	ims	F? L
print		print			ck_listiob	ims	F? L

sysopen		sysopen			ck_fun		s	F S S S?
sysseek		sysseek			ck_fun		s	F S S
sysread		sysread			ck_fun		imst	F R S S?
syswrite	syswrite		ck_fun		imst	F S S S?

send		send			ck_fun		imst	F S S S?
recv		recv			ck_fun		imst	F R S S

eof		eof			ck_eof		is	F?
tell		tell			ck_fun		st	F?
seek		seek			ck_fun		s	F S S
d531 1
a531 1
truncate	truncate		ck_trunc	is	S S
d533 3
a535 3
fcntl		fcntl			ck_fun		st	F S S
ioctl		ioctl			ck_fun		st	F S S
flock		flock			ck_fun		ist	F S
d539 2
a540 2
socket		socket			ck_fun		is	F S S S
sockpair	socketpair		ck_fun		is	F F S S S
d542 5
a546 5
bind		bind			ck_fun		is	F S
connect		connect			ck_fun		is	F S
listen		listen			ck_fun		is	F S
accept		accept			ck_fun		ist	F F
shutdown	shutdown		ck_fun		ist	F S
d548 2
a549 2
gsockopt	getsockopt		ck_fun		is	F S S
ssockopt	setsockopt		ck_fun		is	F S S S
d551 2
a552 2
getsockname	getsockname		ck_fun		is	F
getpeername	getpeername		ck_fun		is	F
d556 29
a584 29
lstat		lstat			ck_ftst		u	F
stat		stat			ck_ftst		u	F
ftrread		-R			ck_ftst		isu	F
ftrwrite	-W			ck_ftst		isu	F
ftrexec		-X			ck_ftst		isu	F
fteread		-r			ck_ftst		isu	F
ftewrite	-w			ck_ftst		isu	F
fteexec		-x			ck_ftst		isu	F
ftis		-e			ck_ftst		isu	F
fteowned	-O			ck_ftst		isu	F
ftrowned	-o			ck_ftst		isu	F
ftzero		-z			ck_ftst		isu	F
ftsize		-s			ck_ftst		istu	F
ftmtime		-M			ck_ftst		stu	F
ftatime		-A			ck_ftst		stu	F
ftctime		-C			ck_ftst		stu	F
ftsock		-S			ck_ftst		isu	F
ftchr		-c			ck_ftst		isu	F
ftblk		-b			ck_ftst		isu	F
ftfile		-f			ck_ftst		isu	F
ftdir		-d			ck_ftst		isu	F
ftpipe		-p			ck_ftst		isu	F
ftlink		-l			ck_ftst		isu	F
ftsuid		-u			ck_ftst		isu	F
ftsgid		-g			ck_ftst		isu	F
ftsvtx		-k			ck_ftst		isu	F
fttty		-t			ck_ftst		is	F
fttext		-T			ck_ftst		isu	F
ftbinary	-B			ck_ftst		isu	F
d588 12
a599 12
chdir		chdir			ck_fun		ist	S?
chown		chown			ck_fun		imst	L
chroot		chroot			ck_fun		istu	S?
unlink		unlink			ck_fun		imstu	L
chmod		chmod			ck_fun		imst	L
utime		utime			ck_fun		imst	L
rename		rename			ck_fun		ist	S S
link		link			ck_fun		ist	S S
symlink		symlink			ck_fun		ist	S S
readlink	readlink		ck_fun		stu	S?
mkdir		mkdir			ck_fun		ist	S S
rmdir		rmdir			ck_fun		istu	S?
d603 6
a608 6
open_dir	opendir			ck_fun		is	F S
readdir		readdir			ck_fun		0	F
telldir		telldir			ck_fun		st	F
seekdir		seekdir			ck_fun		s	F S
rewinddir	rewinddir		ck_fun		s	F
closedir	closedir		ck_fun		is	F
d612 11
a622 11
fork		fork			ck_null		ist	
wait		wait			ck_null		ist	
waitpid		waitpid			ck_fun		ist	S S
system		system			ck_exec		imst	S? L
exec		exec			ck_exec		dimst	S? L
kill		kill			ck_fun		dimst	L
getppid		getppid			ck_null		ist	
getpgrp		getpgrp			ck_fun		ist	S?
setpgrp		setpgrp			ck_fun		ist	S? S?
getpriority	getpriority		ck_fun		ist	S S
setpriority	setpriority		ck_fun		ist	S S S
d626 1
a626 1
time		time			ck_null		ist	
d628 4
a631 4
localtime	localtime		ck_fun		t	S?
gmtime		gmtime			ck_fun		t	S?
alarm		alarm			ck_fun		istu	S?
sleep		sleep			ck_fun		ist	S?
d635 4
a638 4
shmget		shmget			ck_fun		imst	S S S
shmctl		shmctl			ck_fun		imst	S S S
shmread		shmread			ck_fun		imst	S S S S
shmwrite	shmwrite		ck_fun		imst	S S S S
d642 4
a645 4
msgget		msgget			ck_fun		imst	S S
msgctl		msgctl			ck_fun		imst	S S S
msgsnd		msgsnd			ck_fun		imst	S S S
msgrcv		msgrcv			ck_fun		imst	S S S S S
d649 3
a651 3
semget		semget			ck_fun		imst	S S S
semctl		semctl			ck_fun		imst	S S S S
semop		semop			ck_fun		imst	S S
d655 7
a661 7
require		require			ck_require	du	S?
dofile		do 'file'		ck_fun		d	S
entereval	eval string		ck_eval		d	S
leaveeval	eval exit		ck_null		0	S
#evalonce	eval constant string	ck_null		d	S
entertry	eval block		ck_null		0	
leavetry	eval block exit		ck_null		0	
d665 2
a666 2
ghbyname	gethostbyname		ck_fun		0	S
ghbyaddr	gethostbyaddr		ck_fun		0	S S
d668 2
a669 2
gnbyname	getnetbyname		ck_fun		0	S
gnbyaddr	getnetbyaddr		ck_fun		0	S S
d671 2
a672 2
gpbyname	getprotobyname		ck_fun		0	S
gpbynumber	getprotobynumber	ck_fun		0	S
d674 2
a675 2
gsbyname	getservbyname		ck_fun		0	S S
gsbyport	getservbyport		ck_fun		0	S S
d677 10
a686 10
shostent	sethostent		ck_fun		is	S
snetent		setnetent		ck_fun		is	S
sprotoent	setprotoent		ck_fun		is	S
sservent	setservent		ck_fun		is	S
ehostent	endhostent		ck_null		is	
enetent		endnetent		ck_null		is	
eprotoent	endprotoent		ck_null		is	
eservent	endservent		ck_null		is	
gpwnam		getpwnam		ck_fun		0	S
gpwuid		getpwuid		ck_fun		0	S
d688 4
a691 4
spwent		setpwent		ck_null		is	
epwent		endpwent		ck_null		is	
ggrnam		getgrnam		ck_fun		0	S
ggrgid		getgrgid		ck_fun		0	S
d693 3
a695 3
sgrent		setgrent		ck_null		is	
egrent		endgrent		ck_null		is	
getlogin	getlogin		ck_null		st	
d699 5
a703 1
syscall		syscall			ck_fun		imst	S L
@


1.1
log
@Initial revision
@
text
@d3 1
d118 1
a118 1
EXT OP * (*check[])();
d120 1
a120 1
EXT OP * (*check[])() = {
d217 1
a217 1
anoncode	anonymous subroutine	ck_null		0	
d227 2
a228 1
glob		glob			ck_glob		t	S S
d283 2
a284 2
left_shift	left bitshift		ck_null		ifst	S S
right_shift	right bitshift		ck_null		ifst	S S
d301 4
a304 4
slt		string lt		ck_null		ifs	S S
sgt		string gt		ck_null		ifs	S S
sle		string le		ck_null		ifs	S S
sge		string ge		ck_null		ifs	S S
d307 1
a307 1
scmp		string comparison	ck_null		ifst	S S
d309 3
a311 3
bit_and		bitwise and		ck_null		fst	S S
bit_xor		bitwise xor		ck_null		fst	S S
bit_or		bitwise or		ck_null		fst	S S
d316 1
a316 1
complement	1's complement		ck_null		fst	S
d329 2
d332 2
a333 2
hex		hex			ck_fun		istu	S?
oct		oct			ck_fun		istu	S?
d345 2
a346 2
sprintf		sprintf			ck_fun		mst	S L
formline	formline		ck_formline	ms	S L
d350 5
a354 5
ucfirst		upper case first	ck_fun		fst	S
lcfirst		lower case first	ck_fun		fst	S
uc		upper case		ck_fun		fst	S
lc		lower case		ck_fun		fst	S
quotemeta	quote metachars		ck_fun		fst	S
d363 1
a363 1
# Associative arrays.
d368 5
a372 5
delete		delete			ck_delete	s	S
exists		exists operator		ck_delete	is	S
rv2hv		associative array deref	ck_rvconst	dt	
helem		associative array elem	ck_null		s	H S
hslice		associative array slice	ck_null		m	H L
d475 1
d485 1
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@a2 1
unlink "opcode.h";
a78 3
#ifndef PERL_OBJECT
START_EXTERN_C

d84 1
a84 1
    print "OP *\t", &tab(3,$_),"_((OP* o));\n";
d90 1
a90 1
    print "OP *\t", &tab(3, "pp_$_"), "_((ARGSproto));\n";
a96 3
END_EXTERN_C
#endif	/* PERL_OBJECT */

d98 1
a98 1
EXT OP * (CPERLscope(*ppaddr)[])(ARGSproto);
d100 1
a100 2
#ifndef PERL_OBJECT
EXT OP * (CPERLscope(*ppaddr)[])(ARGSproto) = {
d104 1
a104 1
    print "\tpp_$_,\n";
a108 1
#endif	/* PERL_OBJECT */
d117 1
a117 1
EXT OP * (CPERLscope(*check)[]) _((OP *op));
d119 1
a119 2
#ifndef PERL_OBJECT
EXT OP * (CPERLscope(*check)[]) _((OP *op)) = {
d123 1
a123 1
    print "\t", &tab(3, "$check{$_},"), "/* $_ */\n";
a127 1
#endif	/* PERL_OBJECT */
a150 18
%opclass = (
    '0',  0,		# baseop
    '1',  1,		# unop
    '2',  2,		# binop
    '|',  3,		# logop
    '?',  4,		# condop
    '@@',  5,		# listop
    '/',  6,		# pmop
    '$',  7,		# svop
    '*',  8,		# gvop
    '"',  9,		# pvop
    '{',  10,		# loop
    ';',  11,		# cop
    '%',  12,		# baseop_or_unop
    '-',  13,		# filestatop
    '}',  14,		# loopexop
);

d162 1
a162 4

    $flags =~ /([\W\d_])/ or die qq[Opcode "$_" has no class indicator];
    $argsum |= $opclass{$1} << 8;
    $mul = 4096;				# 2 ^ OASHIFT
d170 1
a170 1
    print "\t", &tab(3, "$argsum,"), "/* $_ */\n";
a177 11
close OC or die "Error closing opcode.h: $!";

unlink "pp_proto.h";
open PP, '>pp_proto.h' or die "Error creating pp_proto.h: $!";
for (@@ops) {
    next if /^i_(pre|post)(inc|dec)$/;
    print PP "PPDEF(pp_$_)\n";
}

close PP or die "Error closing pp_proto.h: $!";

d191 1
a191 1
scalar		scalar			ck_fun		s%	S
d195 2
a196 2
pushmark	pushmark		ck_null		s0	
wantarray	wantarray		ck_null		is0	
d198 1
a198 1
const		constant item		ck_svconst	s$	
d200 7
a206 7
gvsv		scalar variable		ck_null		ds*	
gv		glob value		ck_null		ds*	
gelem		glob elem		ck_null		d2	S S
padsv		private variable	ck_null		ds0
padav		private array		ck_null		d0
padhv		private hash		ck_null		d0
padany		private something	ck_null		d0
d208 1
a208 1
pushre		push regexp		ck_null		d/
d212 10
a221 10
rv2gv		ref-to-glob cast	ck_rvconst	ds1	
rv2sv		scalar deref		ck_rvconst	ds1	
av2arylen	array length		ck_null		is1	
rv2cv		subroutine deref	ck_rvconst	d1
anoncode	anonymous subroutine	ck_anoncode	$	
prototype	subroutine prototype	ck_null		s%	S
refgen		reference constructor	ck_spair	m1	L
srefgen		scalar ref constructor	ck_null		fs1	S
ref		reference-type operator	ck_fun		stu%	S?
bless		bless			ck_fun		s@@	S S?
d225 4
a228 5
backtick	backticks		ck_null		t%	
# glob defaults its first arg to $_
glob		glob			ck_glob		t@@	S? S?
readline	<HANDLE>		ck_null		t%	
rcatline	append I/O operator	ck_null		t%	
d232 6
a237 8
regcmaybe	regexp comp once	ck_fun		s1	S
regcreset	regexp reset interpolation flag	ck_fun		s1	S
regcomp		regexp compilation	ck_null		s|	S
match		pattern match		ck_match	d/
qr		pattern quote		ck_match	s/
subst		substitution		ck_null		dis/	S
substcont	substitution cont	ck_null		dis|	
trans		character translation	ck_null		is"	S
a239 1
# sassign is special-cased for op class
d241 2
a242 2
sassign		scalar assignment	ck_null		s0
aassign		list assignment		ck_null		t2	L L
d244 17
a260 17
chop		chop			ck_spair	mts%	L
schop		scalar chop		ck_null		stu%	S?
chomp		safe chop		ck_spair	mts%	L
schomp		scalar safe chop	ck_null		stu%	S?
defined		defined operator	ck_rfun		isu%	S?
undef		undef operator		ck_lfun		s%	S?
study		study			ck_fun		su%	S?
pos		match position		ck_lfun		stu%	S?

preinc		preincrement		ck_lfun		dIs1	S
i_preinc	integer preincrement	ck_lfun		dis1	S
predec		predecrement		ck_lfun		dIs1	S
i_predec	integer predecrement	ck_lfun		dis1	S
postinc		postincrement		ck_lfun		dIst1	S
i_postinc	integer postincrement	ck_lfun		dist1	S
postdec		postdecrement		ck_lfun		dIst1	S
i_postdec	integer postdecrement	ck_lfun		dist1	S
d264 1
a264 1
pow		exponentiation		ck_null		fst2	S S
d266 49
a314 49
multiply	multiplication		ck_null		Ifst2	S S
i_multiply	integer multiplication	ck_null		ifst2	S S
divide		division		ck_null		Ifst2	S S
i_divide	integer division	ck_null		ifst2	S S
modulo		modulus			ck_null		Iifst2	S S
i_modulo	integer modulus		ck_null		ifst2	S S
repeat		repeat			ck_repeat	mt2	L S

add		addition		ck_null		Ifst2	S S
i_add		integer addition	ck_null		ifst2	S S
subtract	subtraction		ck_null		Ifst2	S S
i_subtract	integer subtraction	ck_null		ifst2	S S
concat		concatenation		ck_concat	fst2	S S
stringify	string			ck_fun		fst@@	S

left_shift	left bitshift		ck_bitop	fst2	S S
right_shift	right bitshift		ck_bitop	fst2	S S

lt		numeric lt		ck_null		Iifs2	S S
i_lt		integer lt		ck_null		ifs2	S S
gt		numeric gt		ck_null		Iifs2	S S
i_gt		integer gt		ck_null		ifs2	S S
le		numeric le		ck_null		Iifs2	S S
i_le		integer le		ck_null		ifs2	S S
ge		numeric ge		ck_null		Iifs2	S S
i_ge		integer ge		ck_null		ifs2	S S
eq		numeric eq		ck_null		Iifs2	S S
i_eq		integer eq		ck_null		ifs2	S S
ne		numeric ne		ck_null		Iifs2	S S
i_ne		integer ne		ck_null		ifs2	S S
ncmp		spaceship operator	ck_null		Iifst2	S S
i_ncmp		integer spaceship	ck_null		ifst2	S S

slt		string lt		ck_scmp		ifs2	S S
sgt		string gt		ck_scmp		ifs2	S S
sle		string le		ck_scmp		ifs2	S S
sge		string ge		ck_scmp		ifs2	S S
seq		string eq		ck_null		ifs2	S S
sne		string ne		ck_null		ifs2	S S
scmp		string comparison	ck_scmp		ifst2	S S

bit_and		bitwise and		ck_bitop	fst2	S S
bit_xor		bitwise xor		ck_bitop	fst2	S S
bit_or		bitwise or		ck_bitop	fst2	S S

negate		negate			ck_null		Ifst1	S
i_negate	integer negate		ck_null		ifst1	S
not		not			ck_null		ifs1	S
complement	1's complement		ck_bitop	fst1	S
d318 13
a330 15
atan2		atan2			ck_fun		fst@@	S S
sin		sin			ck_fun		fstu%	S?
cos		cos			ck_fun		fstu%	S?
rand		rand			ck_fun		st%	S?
srand		srand			ck_fun		s%	S?
exp		exp			ck_fun		fstu%	S?
log		log			ck_fun		fstu%	S?
sqrt		sqrt			ck_fun		fstu%	S?

# Lowbrow math.

int		int			ck_fun		fstu%	S?
hex		hex			ck_fun		fstu%	S?
oct		oct			ck_fun		fstu%	S?
abs		abs			ck_fun		fstu%	S?
d334 17
a350 17
length		length			ck_lengthconst	istu%	S?
substr		substr			ck_fun		st@@	S S S? S?
vec		vec			ck_fun		ist@@	S S S

index		index			ck_index	ist@@	S S S?
rindex		rindex			ck_index	ist@@	S S S?

sprintf		sprintf			ck_fun_locale	mfst@@	S L
formline	formline		ck_fun		ms@@	S L
ord		ord			ck_fun		ifstu%	S?
chr		chr			ck_fun		fstu%	S?
crypt		crypt			ck_fun		fst@@	S S
ucfirst		upper case first	ck_fun_locale	fstu%	S?
lcfirst		lower case first	ck_fun_locale	fstu%	S?
uc		upper case		ck_fun_locale	fstu%	S?
lc		lower case		ck_fun_locale	fstu%	S?
quotemeta	quote metachars		ck_fun		fstu%	S?
d354 15
a368 15
rv2av		array deref		ck_rvconst	dt1	
aelemfast	known array element	ck_null		s*	A S
aelem		array element		ck_null		s2	A S
aslice		array slice		ck_null		m@@	A L

# Hashes.

each		each			ck_fun		t%	H
values		values			ck_fun		t%	H
keys		keys			ck_fun		t%	H
delete		delete			ck_delete	%	S
exists		exists operator		ck_exists	is%	S
rv2hv		hash deref		ck_rvconst	dt1	
helem		hash elem		ck_null		s2@@	H S
hslice		hash slice		ck_null		m@@	H L
d372 4
a375 4
unpack		unpack			ck_fun		@@	S S
pack		pack			ck_fun		mst@@	S L
split		split			ck_split	t@@	S S S
join		join			ck_fun		mst@@	S L
d379 12
a390 12
list		list			ck_null		m@@	L
lslice		list slice		ck_null		2	H L L
anonlist	anonymous list		ck_fun		ms@@	L
anonhash	anonymous hash		ck_fun		ms@@	L

splice		splice			ck_fun		m@@	A S? S? L
push		push			ck_fun		imst@@	A L
pop		pop			ck_shift	s%	A
shift		shift			ck_shift	s%	A
unshift		unshift			ck_fun		imst@@	A L
sort		sort			ck_sort		m@@	C? L
reverse		reverse			ck_fun		mt@@	L
d392 2
a393 2
grepstart	grep			ck_grep		dm@@	C L
grepwhile	grep iterator		ck_null		dt|	
d395 2
a396 2
mapstart	map			ck_grep		dm@@	C L
mapwhile	map iterator		ck_null		dt|
d400 3
a402 3
range		flipflop		ck_null		?	S S
flip		range (or flip)		ck_null		1	S S
flop		range (or flop)		ck_null		1
d406 19
a424 19
and		logical and		ck_null		|	
or		logical or		ck_null		|	
xor		logical xor		ck_null		fs|	S S	
cond_expr	conditional expression	ck_null		d?	
andassign	logical and assignment	ck_null		s|	
orassign	logical or assignment	ck_null		s|	

method		method lookup		ck_null		d1
entersub	subroutine entry	ck_subr		dmt1	L
leavesub	subroutine exit		ck_null		1	
caller		caller			ck_fun		t%	S?
warn		warn			ck_fun		imst@@	L
die		die			ck_fun		dimst@@	L
reset		reset			ck_fun		is%	S?

lineseq		line sequence		ck_null		@@	
nextstate	next statement		ck_null		s;	
dbstate		debug next statement	ck_null		s;	
unstack		iteration finalizer	ck_null		s0
d426 3
a428 3
leave		block exit		ck_null		@@	
scope		block			ck_null		@@	
enteriter	foreach loop entry	ck_null		d{	
d430 9
a438 9
enterloop	loop entry		ck_null		d{	
leaveloop	loop exit		ck_null		2	
return		return			ck_null		dm@@	L
last		last			ck_null		ds}	
next		next			ck_null		ds}	
redo		redo			ck_null		ds}	
dump		dump			ck_null		ds}	
goto		goto			ck_null		ds}	
exit		exit			ck_fun		ds%	S?
d445 40
a484 42
open		open			ck_fun		ist@@	F S?
close		close			ck_fun		is%	F?
pipe_op		pipe			ck_fun		is@@	F F

fileno		fileno			ck_fun		ist%	F
umask		umask			ck_fun		ist%	S?
binmode		binmode			ck_fun		s%	F

tie		tie			ck_fun		idms@@	R S L
untie		untie			ck_fun		is%	R
tied		tied			ck_fun		s%	R
dbmopen		dbmopen			ck_fun		is@@	H S S
dbmclose	dbmclose		ck_fun		is%	H

sselect		select system call	ck_select	t@@	S S S S
select		select			ck_select	st@@	F?

getc		getc			ck_eof		st%	F?
read		read			ck_fun		imst@@	F R S S?
enterwrite	write			ck_fun		dis%	F?
leavewrite	write exit		ck_null		1	

prtf		printf			ck_listiob	ims@@	F? L
print		print			ck_listiob	ims@@	F? L

sysopen		sysopen			ck_fun		s@@	F S S S?
sysseek		sysseek			ck_fun		s@@	F S S
sysread		sysread			ck_fun		imst@@	F R S S?
syswrite	syswrite		ck_fun		imst@@	F S S? S?

send		send			ck_fun		imst@@	F S S S?
recv		recv			ck_fun		imst@@	F R S S

eof		eof			ck_eof		is%	F?
tell		tell			ck_fun		st%	F?
seek		seek			ck_fun		s@@	F S S
# truncate really behaves as if it had both "S S" and "F S"
truncate	truncate		ck_trunc	is@@	S S

fcntl		fcntl			ck_fun		st@@	F S S
ioctl		ioctl			ck_fun		st@@	F S S
flock		flock			ck_fun		ist@@	F S
d488 2
a489 2
socket		socket			ck_fun		is@@	F S S S
sockpair	socketpair		ck_fun		is@@	F F S S S
d491 5
a495 5
bind		bind			ck_fun		is@@	F S
connect		connect			ck_fun		is@@	F S
listen		listen			ck_fun		is@@	F S
accept		accept			ck_fun		ist@@	F F
shutdown	shutdown		ck_fun		ist@@	F S
d497 2
a498 2
gsockopt	getsockopt		ck_fun		is@@	F S S
ssockopt	setsockopt		ck_fun		is@@	F S S S
d500 2
a501 2
getsockname	getsockname		ck_fun		is%	F
getpeername	getpeername		ck_fun		is%	F
d505 29
a533 29
lstat		lstat			ck_ftst		u-	F
stat		stat			ck_ftst		u-	F
ftrread		-R			ck_ftst		isu-	F
ftrwrite	-W			ck_ftst		isu-	F
ftrexec		-X			ck_ftst		isu-	F
fteread		-r			ck_ftst		isu-	F
ftewrite	-w			ck_ftst		isu-	F
fteexec		-x			ck_ftst		isu-	F
ftis		-e			ck_ftst		isu-	F
fteowned	-O			ck_ftst		isu-	F
ftrowned	-o			ck_ftst		isu-	F
ftzero		-z			ck_ftst		isu-	F
ftsize		-s			ck_ftst		istu-	F
ftmtime		-M			ck_ftst		stu-	F
ftatime		-A			ck_ftst		stu-	F
ftctime		-C			ck_ftst		stu-	F
ftsock		-S			ck_ftst		isu-	F
ftchr		-c			ck_ftst		isu-	F
ftblk		-b			ck_ftst		isu-	F
ftfile		-f			ck_ftst		isu-	F
ftdir		-d			ck_ftst		isu-	F
ftpipe		-p			ck_ftst		isu-	F
ftlink		-l			ck_ftst		isu-	F
ftsuid		-u			ck_ftst		isu-	F
ftsgid		-g			ck_ftst		isu-	F
ftsvtx		-k			ck_ftst		isu-	F
fttty		-t			ck_ftst		is-	F
fttext		-T			ck_ftst		isu-	F
ftbinary	-B			ck_ftst		isu-	F
d537 12
a548 12
chdir		chdir			ck_fun		ist%	S?
chown		chown			ck_fun		imst@@	L
chroot		chroot			ck_fun		istu%	S?
unlink		unlink			ck_fun		imstu@@	L
chmod		chmod			ck_fun		imst@@	L
utime		utime			ck_fun		imst@@	L
rename		rename			ck_fun		ist@@	S S
link		link			ck_fun		ist@@	S S
symlink		symlink			ck_fun		ist@@	S S
readlink	readlink		ck_fun		stu%	S?
mkdir		mkdir			ck_fun		ist@@	S S
rmdir		rmdir			ck_fun		istu%	S?
d552 6
a557 6
open_dir	opendir			ck_fun		is@@	F S
readdir		readdir			ck_fun		%	F
telldir		telldir			ck_fun		st%	F
seekdir		seekdir			ck_fun		s@@	F S
rewinddir	rewinddir		ck_fun		s%	F
closedir	closedir		ck_fun		is%	F
d561 11
a571 11
fork		fork			ck_null		ist0	
wait		wait			ck_null		ist0	
waitpid		waitpid			ck_fun		ist@@	S S
system		system			ck_exec		imst@@	S? L
exec		exec			ck_exec		dimst@@	S? L
kill		kill			ck_fun		dimst@@	L
getppid		getppid			ck_null		ist0	
getpgrp		getpgrp			ck_fun		ist%	S?
setpgrp		setpgrp			ck_fun		ist@@	S? S?
getpriority	getpriority		ck_fun		ist@@	S S
setpriority	setpriority		ck_fun		ist@@	S S S
d575 1
a575 1
time		time			ck_null		ist0	
d577 4
a580 4
localtime	localtime		ck_fun		t%	S?
gmtime		gmtime			ck_fun		t%	S?
alarm		alarm			ck_fun		istu%	S?
sleep		sleep			ck_fun		ist%	S?
d584 4
a587 4
shmget		shmget			ck_fun		imst@@	S S S
shmctl		shmctl			ck_fun		imst@@	S S S
shmread		shmread			ck_fun		imst@@	S S S S
shmwrite	shmwrite		ck_fun		imst@@	S S S S
d591 4
a594 4
msgget		msgget			ck_fun		imst@@	S S
msgctl		msgctl			ck_fun		imst@@	S S S
msgsnd		msgsnd			ck_fun		imst@@	S S S
msgrcv		msgrcv			ck_fun		imst@@	S S S S S
d598 3
a600 3
semget		semget			ck_fun		imst@@	S S S
semctl		semctl			ck_fun		imst@@	S S S S
semop		semop			ck_fun		imst@@	S S
d604 7
a610 7
require		require			ck_require	du%	S?
dofile		do 'file'		ck_fun		d1	S
entereval	eval string		ck_eval		d%	S
leaveeval	eval exit		ck_null		1	S
#evalonce	eval constant string	ck_null		d1	S
entertry	eval block		ck_null		|	
leavetry	eval block exit		ck_null		@@	
d614 2
a615 2
ghbyname	gethostbyname		ck_fun		%	S
ghbyaddr	gethostbyaddr		ck_fun		@@	S S
d617 2
a618 2
gnbyname	getnetbyname		ck_fun		%	S
gnbyaddr	getnetbyaddr		ck_fun		@@	S S
d620 2
a621 2
gpbyname	getprotobyname		ck_fun		%	S
gpbynumber	getprotobynumber	ck_fun		@@	S
d623 2
a624 2
gsbyname	getservbyname		ck_fun		@@	S S
gsbyport	getservbyport		ck_fun		@@	S S
d626 10
a635 10
shostent	sethostent		ck_fun		is%	S
snetent		setnetent		ck_fun		is%	S
sprotoent	setprotoent		ck_fun		is%	S
sservent	setservent		ck_fun		is%	S
ehostent	endhostent		ck_null		is0	
enetent		endnetent		ck_null		is0	
eprotoent	endprotoent		ck_null		is0	
eservent	endservent		ck_null		is0	
gpwnam		getpwnam		ck_fun		%	S
gpwuid		getpwuid		ck_fun		%	S
d637 4
a640 4
spwent		setpwent		ck_null		is0	
epwent		endpwent		ck_null		is0	
ggrnam		getgrnam		ck_fun		%	S
ggrgid		getgrgid		ck_fun		%	S
d642 3
a644 3
sgrent		setgrent		ck_null		is0	
egrent		endgrent		ck_null		is0	
getlogin	getlogin		ck_null		st0	
d648 1
a648 5
syscall		syscall			ck_fun		imst@@	S L

# For multi-threading
lock		lock			ck_rfun		s%	S
threadsv	per-thread variable	ck_null		ds0
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d3 1
a3 1
unlink "opcode.h", "opnames.h";
a4 1
open(ON, ">opnames.h") || die "Can't create opnames.h: $!\n";
d32 4
a35 4
/* !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!! 
   This file is built by opcode.pl from its data.  Any changes made here
   will be lost!
*/
d37 1
a37 14
#define Perl_pp_i_preinc Perl_pp_preinc
#define Perl_pp_i_predec Perl_pp_predec
#define Perl_pp_i_postinc Perl_pp_postinc
#define Perl_pp_i_postdec Perl_pp_postdec

END

print ON <<"END";
/* !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!! 
   This file is built by opcode.pl from its data.  Any changes made here
   will be lost!
*/

typedef enum opcode {
a38 1

d40 1
a40 1
    print ON "\t", &tab(3,"OP_\U$_,"), "/* ", $i++, " */\n";
d42 3
a44 3
print ON "\t", &tab(3,"OP_max"), "\n";
print ON "} opcode;\n";
print ON "\n#define MAXO ", scalar @@ops, "\n\n"; 
a48 3

START_EXTERN_C

d50 1
a50 1
EXT char *PL_op_name[];
d52 1
a52 1
EXT char *PL_op_name[] = {
d67 1
a67 1
EXT char *PL_op_desc[];
d69 1
a69 1
EXT char *PL_op_desc[] = {
d73 1
a73 6
    my($safe_desc) = $desc{$_};

    # Have to escape double quotes and escape characters.    
    $safe_desc =~ s/(^|[^\\])([\\"])/$1\\$2/g;

    print qq(\t"$safe_desc",\n);
d80 2
a81 1
END_EXTERN_C
d87 9
a95 9
#for (sort keys %ckname) {
#    print "OP *\t", &tab(3,$_),"(pTHX_ OP* o);\n";
#}
#
#print "\n";
#
#for (@@ops) {
#    print "OP *\t", &tab(3, "pp_$_"), "(pTHX);\n";
#}
d101 2
a102 1
START_EXTERN_C
d105 1
a105 1
EXT OP * (CPERLscope(*PL_ppaddr)[])(pTHX);
d107 2
a108 1
EXT OP * (CPERLscope(*PL_ppaddr)[])(pTHX) = {
d112 1
a112 1
    print "\tMEMBER_TO_FPTR(Perl_pp_$_),\n";
d117 1
d126 1
a126 1
EXT OP * (CPERLscope(*PL_check)[]) (pTHX_ OP *op);
d128 2
a129 1
EXT OP * (CPERLscope(*PL_check)[]) (pTHX_ OP *op) = {
d133 1
a133 1
    print "\t", &tab(3, "MEMBER_TO_FPTR(Perl_$check{$_}),"), "\t/* $_ */\n";
d138 1
d147 1
a147 1
EXT U32 PL_opargs[];
d149 1
a149 1
EXT U32 PL_opargs[] = {
d167 11
a177 10
    '@@',  4,		# listop
    '/',  5,		# pmop
    '$',  6,		# svop_or_padop
    '#',  7,		# padop
    '"',  8,		# pvop_or_svop
    '{',  9,		# loop
    ';',  10,		# cop
    '%',  11,		# baseop_or_unop
    '-',  12,		# filestatop
    '}',  13,		# loopexop
a186 1
    $argsum |= (8|256) if $flags =~ /T/;	# ... which may be lexical
d193 2
a194 2
    $argsum |= $opclass{$1} << 9;
    $mul = 0x2000;				# 2 ^ OASHIFT
a197 2
	warn "# Conflicting bit 32 for '$_'.\n"
	    if $argnum & 8 and $mul == 0x10000000;
a207 2

END_EXTERN_C
a210 1
close ON or die "Error closing opnames.h: $!";
a212 1
unlink "pp.sym";
a213 28
open PPSYM, '>pp.sym' or die "Error creating pp.sym: $!";

print PP <<"END";
/* !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!! 
   This file is built by opcode.pl from its data.  Any changes made here
   will be lost!
*/

END

print PPSYM <<"END";
#
# !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!! 
#   This file is built by opcode.pl from its data.  Any changes made here
#   will be lost!
#

END


for (sort keys %ckname) {
    print PP "PERL_CKDEF(Perl_$_)\n";
    print PPSYM "Perl_$_\n";
#OP *\t", &tab(3,$_),"(OP* o);\n";
}

print PP "\n\n";

d216 1
a216 2
    print PP "PERL_PPDEF(Perl_pp_$_)\n";
    print PPSYM "Perl_pp_$_\n";
a219 1
close PPSYM or die "Error closing pp.sym: $!";
a227 57

# Some comments about 'T' opcode classifier:

# Safe to set if the ppcode uses:
#	tryAMAGICbin, tryAMAGICun, SETn, SETi, SETu, PUSHn, PUSHTARG, SETTARG,
#	SETs(TARG), XPUSHn, XPUSHu,

# Unsafe to set if the ppcode uses dTARG or [X]RETPUSH[YES|NO|UNDEF]

# lt and friends do SETs (including ncmp, but not scmp)

# Additional mode of failure: the opcode can modify TARG before it "used"
# all the arguments (or may call an external function which does the same).
# If the target coincides with one of the arguments ==> kaboom.

# pp.c	pos substr each not OK (RETPUSHUNDEF)
#	substr vec also not OK due to LV to target (are they???)
#	ref not OK (RETPUSHNO)
#	trans not OK (dTARG; TARG = sv_newmortal();)
#	ucfirst etc not OK: TMP arg processed inplace
#	quotemeta not OK (unsafe when TARG == arg)
#	each repeat not OK too due to array context
#	pack split - unknown whether they are safe
#	sprintf: is calling do_sprintf(TARG,...) which can act on TARG
#	  before other args are processed.

#	Suspicious wrt "additional mode of failure" (and only it):
#	schop, chop, postinc/dec, bit_and etc, negate, complement.

#	Also suspicious: 4-arg substr, sprintf, uc/lc (POK_only), reverse, pack.

#	substr/vec: doing TAINT_off()???

# pp_hot.c
#	readline - unknown whether it is safe
#	match subst not OK (dTARG)
#	grepwhile not OK (not always setting)
#	join not OK (unsafe when TARG == arg)

#	Suspicious wrt "additional mode of failure": concat (dealt with
#	in ck_sassign()), join (same).

# pp_ctl.c
#	mapwhile flip caller not OK (not always setting)

# pp_sys.c
#	backtick glob warn die not OK (not always setting)
#	warn not OK (RETPUSHYES)
#	open fileno getc sysread syswrite ioctl accept shutdown
#	 ftsize(etc) readlink telldir fork alarm getlogin not OK (RETPUSHUNDEF)
#	umask select not OK (XPUSHs(&PL_sv_undef);)
#	fileno getc sysread syswrite tell not OK (meth("FILENO" "GETC"))
#	sselect shm* sem* msg* syscall - unknown whether they are safe
#	gmtime not OK (list context)

#	Suspicious wrt "additional mode of failure": warn, die, select.

a229 2
# New ops always go at the very end

d243 2
a244 2
gvsv		scalar variable		ck_null		ds$	
gv		glob value		ck_null		ds$	
d249 1
a249 1
padany		private value		ck_null		d0
d256 1
a256 1
rv2sv		scalar dereference	ck_rvconst	ds1	
d258 1
a258 1
rv2cv		subroutine dereference	ck_rvconst	d1
d262 1
a262 1
srefgen		single ref constructor	ck_null		fs1	S
d268 1
a268 1
backtick	quoted execution (``, qx)	ck_open		t%	
d270 1
a270 1
glob		glob			ck_glob		t@@	S?
d276 2
a277 2
regcmaybe	regexp internal guard	ck_fun		s1	S
regcreset	regexp internal reset	ck_fun		s1	S
d279 5
a283 5
match		pattern match (m//)	ck_match	d/
qr		pattern quote (qr//)	ck_match	s/
subst		substitution (s///)	ck_null		dis/	S
substcont	substitution iterator	ck_null		dis|	
trans		transliteration (tr///)	ck_null		is"	S
d288 1
a288 1
sassign		scalar assignment	ck_sassign	s0
d293 3
a295 3
chomp		chomp			ck_spair	mTs%	L
schomp		scalar chomp		ck_null		sTu%	S?
defined		defined operator	ck_defined	isu%	S?
d300 8
a307 8
preinc		preincrement (++)		ck_lfun		dIs1	S
i_preinc	integer preincrement (++)	ck_lfun		dis1	S
predec		predecrement (--)		ck_lfun		dIs1	S
i_predec	integer predecrement (--)	ck_lfun		dis1	S
postinc		postincrement (++)		ck_lfun		dIst1	S
i_postinc	integer postincrement (++)	ck_lfun		disT1	S
postdec		postdecrement (--)		ck_lfun		dIst1	S
i_postdec	integer postdecrement (--)	ck_lfun		disT1	S
d311 1
a311 1
pow		exponentiation (**)	ck_null		fsT2	S S
d313 32
a344 32
multiply	multiplication (*)	ck_null		IfsT2	S S
i_multiply	integer multiplication (*)	ck_null		ifsT2	S S
divide		division (/)		ck_null		IfsT2	S S
i_divide	integer division (/)	ck_null		ifsT2	S S
modulo		modulus (%)		ck_null		IifsT2	S S
i_modulo	integer modulus (%)	ck_null		ifsT2	S S
repeat		repeat (x)		ck_repeat	mt2	L S

add		addition (+)		ck_null		IfsT2	S S
i_add		integer addition (+)	ck_null		ifsT2	S S
subtract	subtraction (-)		ck_null		IfsT2	S S
i_subtract	integer subtraction (-)	ck_null		ifsT2	S S
concat		concatenation (.)	ck_concat	fsT2	S S
stringify	string			ck_fun		fsT@@	S

left_shift	left bitshift (<<)	ck_bitop	fsT2	S S
right_shift	right bitshift (>>)	ck_bitop	fsT2	S S

lt		numeric lt (<)		ck_null		Iifs2	S S
i_lt		integer lt (<)		ck_null		ifs2	S S
gt		numeric gt (>)		ck_null		Iifs2	S S
i_gt		integer gt (>)		ck_null		ifs2	S S
le		numeric le (<=)		ck_null		Iifs2	S S
i_le		integer le (<=)		ck_null		ifs2	S S
ge		numeric ge (>=)		ck_null		Iifs2	S S
i_ge		integer ge (>=)		ck_null		ifs2	S S
eq		numeric eq (==)		ck_null		Iifs2	S S
i_eq		integer eq (==)		ck_null		ifs2	S S
ne		numeric ne (!=)		ck_null		Iifs2	S S
i_ne		integer ne (!=)		ck_null		ifs2	S S
ncmp		numeric comparison (<=>)	ck_null		Iifst2	S S
i_ncmp		integer comparison (<=>)	ck_null		ifst2	S S
d352 1
a352 1
scmp		string comparison (cmp)	ck_scmp		ifst2	S S
d354 3
a356 3
bit_and		bitwise and (&)		ck_bitop	fst2	S S
bit_xor		bitwise xor (^)		ck_bitop	fst2	S S
bit_or		bitwise or (|)		ck_bitop	fst2	S S
d358 2
a359 2
negate		negation (-)		ck_null		Ifst1	S
i_negate	integer negation (-)	ck_null		ifsT1	S
d361 1
a361 1
complement	1's complement (~)	ck_bitop	fst1	S
d365 4
a368 4
atan2		atan2			ck_fun		fsT@@	S S
sin		sin			ck_fun		fsTu%	S?
cos		cos			ck_fun		fsTu%	S?
rand		rand			ck_fun		sT%	S?
d370 3
a372 3
exp		exp			ck_fun		fsTu%	S?
log		log			ck_fun		fsTu%	S?
sqrt		sqrt			ck_fun		fsTu%	S?
d376 4
a379 4
int		int			ck_fun		fsTu%	S?
hex		hex			ck_fun		fsTu%	S?
oct		oct			ck_fun		fsTu%	S?
abs		abs			ck_fun		fsTu%	S?
d383 1
a383 1
length		length			ck_lengthconst	isTu%	S?
d387 2
a388 2
index		index			ck_index	isT@@	S S S?
rindex		rindex			ck_index	isT@@	S S S?
d392 8
a399 8
ord		ord			ck_fun		ifsTu%	S?
chr		chr			ck_fun		fsTu%	S?
crypt		crypt			ck_fun		fsT@@	S S
ucfirst		ucfirst			ck_fun_locale	fstu%	S?
lcfirst		lcfirst			ck_fun_locale	fstu%	S?
uc		uc			ck_fun_locale	fstu%	S?
lc		lc			ck_fun_locale	fstu%	S?
quotemeta	quotemeta		ck_fun		fstu%	S?
d403 2
a404 2
rv2av		array dereference	ck_rvconst	dt1	
aelemfast	constant array element	ck_null		s$	A S
d410 1
a410 1
each		each			ck_fun		%	H
d414 3
a416 3
exists		exists			ck_exists	is%	S
rv2hv		hash dereference	ck_rvconst	dt1	
helem		hash element		ck_null		s2@@	H S
d424 1
a424 1
join		join			ck_join		mst@@	S L
d430 2
a431 2
anonlist	anonymous list ([])	ck_fun		ms@@	L
anonhash	anonymous hash ({})	ck_fun		ms@@	L
d434 1
a434 1
push		push			ck_fun		imsT@@	A L
d437 1
a437 1
unshift		unshift			ck_fun		imsT@@	A L
d449 1
a449 1
range		flipflop		ck_null		|	S S
d455 6
a460 6
and		logical and (&&)		ck_null		|	
or		logical or (||)			ck_null		|	
xor		logical xor			ck_null		fs2	S S	
cond_expr	conditional expression		ck_null		d|	
andassign	logical and assignment (&&=)	ck_null		s|	
orassign	logical or assignment (||=)	ck_null		s|	
d462 1
a462 1
method		method lookup		ck_method	d1
a464 1
leavesublv	lvalue subroutine exit	ck_null		1	
d468 1
a468 1
reset		symbol reset		ck_fun		is%	S?
d487 1
a487 2
exit		exit			ck_exit		ds%	S?
# continued below
d489 2
a490 2
#nswitch	numeric switch		ck_null		d	
#cswitch	character switch	ck_null		d	
d494 1
a494 1
open		open			ck_open		ist@@	F S? L
d500 1
a500 1
binmode		binmode			ck_fun		s@@	F S?
d535 1
a535 1
flock		flock			ck_fun		isT@@	F S
d588 9
a596 9
chdir		chdir			ck_fun		isT%	S?
chown		chown			ck_fun		imsT@@	L
chroot		chroot			ck_fun		isTu%	S?
unlink		unlink			ck_fun		imsTu@@	L
chmod		chmod			ck_fun		imsT@@	L
utime		utime			ck_fun		imsT@@	L
rename		rename			ck_fun		isT@@	S S
link		link			ck_fun		isT@@	S S
symlink		symlink			ck_fun		isT@@	S S
d598 2
a599 2
mkdir		mkdir			ck_fun		isT@@	S S?
rmdir		rmdir			ck_fun		isTu%	S?
d613 10
a622 10
wait		wait			ck_null		isT0	
waitpid		waitpid			ck_fun		isT@@	S S
system		system			ck_exec		imsT@@	S? L
exec		exec			ck_exec		dimsT@@	S? L
kill		kill			ck_fun		dimsT@@	L
getppid		getppid			ck_null		isT0	
getpgrp		getpgrp			ck_fun		isT%	S?
setpgrp		setpgrp			ck_fun		isT@@	S? S?
getpriority	getpriority		ck_fun		isT@@	S S
setpriority	setpriority		ck_fun		isT@@	S S S
d626 1
a626 5
# NOTE: MacOS patches the 'i' of time() away later when the interpreter
# is created because in MacOS time() is already returning times > 2**31-1,
# that is, non-integers.

time		time			ck_null		isT0	
d631 1
a631 1
sleep		sleep			ck_fun		isT%	S?
d656 3
a658 3
dofile		do "file"		ck_fun		d1	S
entereval	eval "string"		ck_eval		d%	S
leaveeval	eval "string" exit	ck_null		1	S
d660 2
a661 2
entertry	eval {block}		ck_null		|	
leavetry	eval {block} exit	ck_null		@@	
d703 1
a703 5
threadsv	per-thread value	ck_null		ds0

# Control (contd.)
setstate	set statement info	ck_null		s;
method_named	method with known name	ck_null		d$
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@a2 1
chmod 0666, "opcode.h", "opnames.h";
a195 3
my %OP_IS_SOCKET;
my %OP_IS_FILETEST;

a212 4
	if ($arg =~ /^F/) {
           $OP_IS_SOCKET{$_}   = 1 if $arg =~ s/s//;
           $OP_IS_FILETEST{$_} = 1 if $arg =~ s/-//;
        }
a213 1
        die "op = $_, arg = $arg\n" unless length($arg) == 1;
a230 14
if (keys %OP_IS_SOCKET) {
    print ON "\n#define OP_IS_SOCKET(op)	\\\n\t(";
    print ON join(" || \\\n\t ",
               map { "(op) == OP_" . uc() } sort keys %OP_IS_SOCKET);
    print ON ")\n\n";
}

if (keys %OP_IS_FILETEST) {
    print ON "\n#define OP_IS_FILETEST(op)	\\\n\t(";
    print ON join(" || \\\n\t ",
               map { "(op) == OP_" . uc() } sort keys %OP_IS_FILETEST);
    print ON ")\n\n";
}

d302 1
a302 1
#	each repeat not OK too due to list context
d437 1
a437 1
concat		concatenation (.) or string	ck_concat	fsT2	S S
d496 1
a496 1
substr		substr			ck_substr	st@@	S S S? S?
d536 1
a536 1
join		join or string		ck_join		mst@@	S L
d577 1
a577 1
leavesublv	lvalue subroutine return	ck_null		1	
d594 1
a594 1
return		return			ck_return	dm@@	L
d638 2
a639 2
send		send			ck_fun		imst@@	Fs S S S?
recv		recv			ck_fun		imst@@	Fs R S S
d653 2
a654 2
socket		socket			ck_fun		is@@	Fs S S S
sockpair	socketpair		ck_fun		is@@	Fs Fs S S S
d656 5
a660 5
bind		bind			ck_fun		is@@	Fs S
connect		connect			ck_fun		is@@	Fs S
listen		listen			ck_fun		is@@	Fs S
accept		accept			ck_fun		ist@@	Fs Fs
shutdown	shutdown		ck_fun		ist@@	Fs S
d662 2
a663 2
gsockopt	getsockopt		ck_fun		is@@	Fs S S
ssockopt	setsockopt		ck_fun		is@@	Fs S S S
d665 2
a666 2
getsockname	getsockname		ck_fun		is%	Fs
getpeername	getpeername		ck_fun		is%	Fs
d672 27
a698 27
ftrread		-R			ck_ftst		isu-	F-
ftrwrite	-W			ck_ftst		isu-	F-
ftrexec		-X			ck_ftst		isu-	F-
fteread		-r			ck_ftst		isu-	F-
ftewrite	-w			ck_ftst		isu-	F-
fteexec		-x			ck_ftst		isu-	F-
ftis		-e			ck_ftst		isu-	F-
fteowned	-O			ck_ftst		isu-	F-
ftrowned	-o			ck_ftst		isu-	F-
ftzero		-z			ck_ftst		isu-	F-
ftsize		-s			ck_ftst		istu-	F-
ftmtime		-M			ck_ftst		stu-	F-
ftatime		-A			ck_ftst		stu-	F-
ftctime		-C			ck_ftst		stu-	F-
ftsock		-S			ck_ftst		isu-	F-
ftchr		-c			ck_ftst		isu-	F-
ftblk		-b			ck_ftst		isu-	F-
ftfile		-f			ck_ftst		isu-	F-
ftdir		-d			ck_ftst		isu-	F-
ftpipe		-p			ck_ftst		isu-	F-
ftlink		-l			ck_ftst		isu-	F-
ftsuid		-u			ck_ftst		isu-	F-
ftsgid		-g			ck_ftst		isu-	F-
ftsvtx		-k			ck_ftst		isu-	F-
fttty		-t			ck_ftst		is-	F-
fttext		-T			ck_ftst		isu-	F-
ftbinary	-B			ck_ftst		isu-	F-
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d3 4
a6 4
$opcode_new = 'opcode.h-new';
$opname_new = 'opnames.h-new';
open(OC, ">$opcode_new") || die "Can't create $opcode_new: $!\n";
open(ON, ">$opname_new") || die "Can't create $opname_new: $!\n";
d34 4
a37 12
/*
 *    opcode.h
 *
 *    Copyright (c) 1997-2002, Larry Wall
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 * !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
 *  This file is built by opcode.pl from its data.  Any changes made here
 *  will be lost!
 */
d47 4
a50 13
/*
 *    opnames.h
 *
 *    Copyright (c) 1997-2002, Larry Wall
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 *
 * !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
 *  This file is built by opcode.pl from its data.  Any changes made here
 *  will be lost!
 */
d60 1
a60 3
print ON "\n#define MAXO ", scalar @@ops, "\n";
print ON "#define OP_phoney_INPUT_ONLY -1\n";
print ON "#define OP_phoney_OUTPUT_ONLY -2\n\n";
a67 6

#define OP_NAME(o) (o->op_type == OP_CUSTOM ? custom_op_name(o) : \\
                    PL_op_name[o->op_type])
#define OP_DESC(o) (o->op_type == OP_CUSTOM ? custom_op_desc(o) : \\
                    PL_op_desc[o->op_type])

d94 1
a94 1
    # Have to escape double quotes and escape characters.
d133 1
a133 1
    print "\tMEMBER_TO_FPTR(Perl_pp_$_),\n" unless $_ eq "custom";
d212 1
d257 4
a260 15
chmod 0600, 'opcode.h';  # required by dosish filesystems
chmod 0600, 'opnames.h'; # required by dosish filesystems

# Some dosish systems can't rename over an existing file:
unlink		"$_-old"	for qw(opcode.h opnames.h);
rename $_,	"$_-old"	for qw(opcode.h opnames.h);

rename $opcode_new, 'opcode.h' or die "renaming opcode.h: $!\n";
rename $opname_new, 'opnames.h' or die "renaming opnames.h: $!\n";

$pp_proto_new = 'pp_proto.h-new';
$pp_sym_new  = 'pp.sym-new';

open PP, ">$pp_proto_new" or die "Error creating $pp_proto_new: $!";
open PPSYM, ">$pp_sym_new" or die "Error creating $pp_sym_new: $!";
d263 1
a263 1
/* !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
d272 1
a272 1
# !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
a289 1
    next if /^custom$/;
a296 10
chmod 0600, 'pp_proto.h'; # required by dosish filesystems
chmod 0600, 'pp.sym';     # required by dosish filesystems

# Some dosish systems can't rename over an existing file:
unlink		"$_-old"	for qw(pp_proto.h pp.sym);
rename $_,	"$_-old"	for qw(pp_proto.h pp.sym);

rename $pp_proto_new, 'pp_proto.h' or die "rename pp_proto.h: $!\n";
rename $pp_sym_new, 'pp.sym' or die "rename pp.sym: $!\n";

d363 1
a363 32
# New ops always go at the end, just before 'custom'

# A recapitulation of the format of this file:
# The file consists of five columns: the name of the op, an English
# description, the name of the "check" routine used to optimize this
# operation, some flags, and a description of the operands.

# The flags consist of options followed by a mandatory op class signifier

# The classes are:
# baseop      - 0            unop     - 1            binop      - 2
# logop       - |            listop   - @@            pmop       - /
# padop/svop  - $            padop    - # (unused)   loop       - {
# baseop/unop - %            loopexop - }            filestatop - -
# pvop/svop   - "

# Other options are:
#   needs stack mark                    - m
#   needs constant folding              - f
#   produces a scalar                   - s
#   produces an integer                 - i
#   needs a target                      - t
#   target can be in a pad              - T
#   has a corresponding integer version - I
#   has side effects                    - d
#   uses $_ if no argument given        - u

# Values for the operands are:
# scalar      - S            list     - L            array     - A
# hash        - H            sub (CV) - C            file      - F
# socket      - Fs           filetest - F-           reference - R
# "?" denotes an optional operand.
d406 2
a407 2
readline	<HANDLE>		ck_null		t%	F?
rcatline	append I/O operator	ck_null		t$
d481 4
a484 4
slt		string lt		ck_null		ifs2	S S
sgt		string gt		ck_null		ifs2	S S
sle		string le		ck_null		ifs2	S S
sge		string ge		ck_null		ifs2	S S
d487 1
a487 1
scmp		string comparison (cmp)	ck_null		ifst2	S S
d525 1
a525 1
sprintf		sprintf			ck_fun		mfst@@	S L
d530 4
a533 4
ucfirst		ucfirst			ck_fun		fstu%	S?
lcfirst		lcfirst			ck_fun		fstu%	S?
uc		uc			ck_fun		fstu%	S?
lc		lc			ck_fun		fstu%	S?
d603 1
a603 1
die		die			ck_die		dimst@@	L
d631 1
a631 1
open		open			ck_open		ismt@@	F S? L
a848 4

# Add new ops before this, the custom operator.

custom		unknown custom operator		ck_null		0
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@a1 4
BEGIN {
    # Get function prototypes
    require 'regen_lib.pl';
}
d37 1
a37 2
 *    Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999,
 *    2000, 2001, 2002, 2003, by Larry Wall and others
d58 1
a58 1
 *    Copyright (C) 1999, 2000, 2001, 2002, 2003, by Larry Wall and others
d88 4
a91 4
#define OP_NAME(o) ((o)->op_type == OP_CUSTOM ? custom_op_name(o) : \\
                    PL_op_name[(o)->op_type])
#define OP_DESC(o) ((o)->op_type == OP_CUSTOM ? custom_op_desc(o) : \\
                    PL_op_desc[(o)->op_type])
d281 9
a289 5
foreach ('opcode.h', 'opnames.h') {
    safer_rename_silent $_, "$_-old";
}
safer_rename $opcode_new, 'opcode.h';
safer_rename $opname_new, 'opnames.h';
d333 6
a338 5
foreach ('pp_proto.h', 'pp.sym') {
    safer_rename_silent $_, "$_-old";
}
safer_rename $pp_proto_new, 'pp_proto.h';
safer_rename $pp_sym_new, 'pp.sym';
d340 2
a341 5
END {
  foreach ('opcode.h', 'opnames.h', 'pp_proto.h', 'pp.sym') {
    1 while unlink "$_-old";
  }
}
d423 1
a423 1
# pvop/svop   - "            cop      - ;
d647 2
a648 2
pop		pop			ck_shift	s%	A?
shift		shift			ck_shift	s%	A?
d920 1
a920 1
lock		lock			ck_rfun		s%	R
@


1.1.1.7
log
@Import of stock perl 5.8.5
@
text
@d42 1
a42 1
 *    2000, 2001, 2002, 2003, 2004, by Larry Wall and others
d63 1
a63 1
 *    Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, by Larry Wall and others
@


1.1.1.8
log
@perl 5.8.8 import
@
text
@a9 1
binmode OC;
a10 1
binmode ON;
d38 1
a38 2
/* -*- buffer-read-only: t -*-
 *
d42 1
a42 1
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006 by Larry Wall and others
d60 1
a60 2
/* -*- buffer-read-only: t -*-
 *
d63 1
a63 2
 *    Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
 *    by Larry Wall and others
a282 3
print OC "/* ex: set ro: */\n";
print ON "/* ex: set ro: */\n";

a295 1
binmode PP;
a296 1
binmode PPSYM;
d299 1
a299 2
/* -*- buffer-read-only: t -*-
   !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
a306 1
# -*- buffer-read-only: t -*-
a329 2
print PP "\n/* ex: set ro: */\n";
print PPSYM "\n# ex: set ro:\n";
d605 1
a605 1
sprintf		sprintf			ck_fun		mst@@	S L
d782 2
a783 2
fteowned	-o			ck_ftst		isu-	F-
ftrowned	-O			ck_ftst		isu-	F-
@


1.1.1.9
log
@import perl 5.10.0 from CPAN
@
text
@d1 1
a1 3
#!/usr/bin/perl -w
use strict;

d7 2
a8 2
my $opcode_new = 'opcode.h-new';
my $opname_new = 'opnames.h-new';
a16 3
my %seen;
my (@@ops, %desc, %check, %ckname, %flags, %args);

d21 1
a21 2
    my ($key, $desc, $check, $flags, $args) = split(/\t+/, $_, 5);
    $args = '' unless defined $args;
a35 58
# Set up aliases

my %alias;

# Format is "this function" => "does these op names"
my @@raw_alias = (
		 Perl_do_kv => [qw( keys values )],
		 Perl_unimplemented_op => [qw(padany mapstart custom)],
		 # All the ops with a body of { return NORMAL; }
		 Perl_pp_null => [qw(scalar regcmaybe lineseq scope)],

		 Perl_pp_goto => ['dump'],
		 Perl_pp_require => ['dofile'],
		 Perl_pp_untie => ['dbmclose'],
		 Perl_pp_sysread => [qw(read recv)],
		 Perl_pp_sysseek => ['seek'],
		 Perl_pp_ioctl => ['fcntl'],
		 Perl_pp_ssockopt => ['gsockopt'],
		 Perl_pp_getpeername => ['getsockname'],
		 Perl_pp_stat => ['lstat'],
		 Perl_pp_ftrowned => [qw(fteowned ftzero ftsock ftchr ftblk
					 ftfile ftdir ftpipe ftsuid ftsgid
 					 ftsvtx)],
		 Perl_pp_fttext => ['ftbinary'],
		 Perl_pp_gmtime => ['localtime'],
		 Perl_pp_semget => [qw(shmget msgget)],
		 Perl_pp_semctl => [qw(shmctl msgctl)],
		 Perl_pp_ghostent => [qw(ghbyname ghbyaddr)],
		 Perl_pp_gnetent => [qw(gnbyname gnbyaddr)],
		 Perl_pp_gprotoent => [qw(gpbyname gpbynumber)],
		 Perl_pp_gservent => [qw(gsbyname gsbyport)],
		 Perl_pp_gpwent => [qw(gpwnam gpwuid)],
		 Perl_pp_ggrent => [qw(ggrnam ggrgid)],
		 Perl_pp_ftis => [qw(ftsize ftmtime ftatime ftctime)],
		 Perl_pp_chown => [qw(unlink chmod utime kill)],
		 Perl_pp_link => ['symlink'],
		 Perl_pp_ftrread => [qw(ftrwrite ftrexec fteread ftewrite
 					fteexec)],
		 Perl_pp_shmwrite => [qw(shmread msgsnd msgrcv semop)],
		 Perl_pp_send => ['syswrite'],
		 Perl_pp_defined => [qw(dor dorassign)],
                 Perl_pp_and => ['andassign'],
		 Perl_pp_or => ['orassign'],
		 Perl_pp_ucfirst => ['lcfirst'],
		 Perl_pp_sle => [qw(slt sgt sge)],
		 Perl_pp_print => ['say'],
		 Perl_pp_index => ['rindex'],
		 Perl_pp_oct => ['hex'],
		 Perl_pp_shift => ['pop'],
		 Perl_pp_sin => [qw(cos exp log sqrt)],
		 Perl_pp_bit_or => ['bit_xor'],
		 Perl_pp_rv2av => ['rv2hv'],
		);

while (my ($func, $names) = splice @@raw_alias, 0, 2) {
    $alias{$_} = $func for @@$names;
}

d38 1
d44 2
a45 2
 *    Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
 *    2001, 2002, 2003, 2004, 2005, 2006, 2007 by Larry Wall and others
a54 2
#ifndef PERL_GLOBAL_STRUCT_INIT

a59 2
PERL_PPDEF(Perl_unimplemented_op)

d68 1
a68 1
 *    2007 by Larry Wall and others
a81 1
my $i = 0;
d94 1
d97 1
d104 1
a104 1
EXTCONST char* const PL_op_name[];
d106 1
a106 1
EXTCONST char* const PL_op_name[] = {
d121 1
a121 1
EXTCONST char* const PL_op_desc[];
d123 1
a123 1
EXTCONST char* const PL_op_desc[] = {
a140 1
#endif /* !PERL_GLOBAL_STRUCT_INIT */
d161 2
a162 3
#ifdef PERL_GLOBAL_STRUCT_INIT
#  define PERL_PPADDR_INITED
static const Perl_ppaddr_t Gppaddr[]
d164 1
a164 8
#  ifndef PERL_GLOBAL_STRUCT
#    define PERL_PPADDR_INITED
EXT Perl_ppaddr_t PL_ppaddr[] /* or perlvars.h */
#  endif
#endif /* PERL_GLOBAL_STRUCT */
#if (defined(DOINIT) && !defined(PERL_GLOBAL_STRUCT)) || defined(PERL_GLOBAL_STRUCT_INIT)
#  define PERL_PPADDR_INITED
= {
d168 1
a168 6
    if (my $name = $alias{$_}) {
	print "\tMEMBER_TO_FPTR($name),\t/* Perl_pp_$_ */\n";
    }
    else {
	print "\tMEMBER_TO_FPTR(Perl_pp_$_),\n";
    }
d172 1
a172 4
}
#endif
#ifdef PERL_PPADDR_INITED
;
d180 2
a181 3
#ifdef PERL_GLOBAL_STRUCT_INIT
#  define PERL_CHECK_INITED
static const Perl_check_t Gcheck[]
d183 1
a183 8
#  ifndef PERL_GLOBAL_STRUCT
#    define PERL_CHECK_INITED
EXT Perl_check_t PL_check[] /* or perlvars.h */
#  endif
#endif
#if (defined(DOINIT) && !defined(PERL_GLOBAL_STRUCT)) || defined(PERL_GLOBAL_STRUCT_INIT)
#  define PERL_CHECK_INITED
= {
d191 1
a191 1
}
a192 3
#ifdef PERL_CHECK_INITED
;
#endif /* #ifdef PERL_CHECK_INITED */
a198 2
#ifndef PERL_GLOBAL_STRUCT_INIT

d200 1
a200 1
EXTCONST U32 PL_opargs[];
d202 1
a202 1
EXTCONST U32 PL_opargs[] = {
d205 8
a212 8
my %argnum = (
    'S',  1,		# scalar
    'L',  2,		# list
    'A',  3,		# array value
    'H',  4,		# hash value
    'C',  5,		# code value
    'F',  6,		# file value
    'R',  7,		# scalar reference
d215 1
a215 1
my %opclass = (
d236 2
a237 2
    my $argsum = 0;
    my $flags = $flags{$_};
d249 2
a250 2
    my $mul = 0x2000;				# 2 ^ OASHIFT
    for my $arg (split(' ',$args{$_})) {
d255 1
a255 1
	my $argnum = ($arg =~ s/\?//) ? 8 : 0;
a270 2
#endif /* !PERL_GLOBAL_STRUCT_INIT */

a271 1

d300 2
a301 2
my $pp_proto_new = 'pp_proto.h-new';
my $pp_sym_new  = 'pp.sym-new';
d362 1
a362 1
    my ($l, $t) = @@_;
d426 1
a426 2
# New ops always go at the end
# The restriction on having custom as the last op has been removed
d497 1
a497 1
backtick	quoted execution (``, qx)	ck_open		tu%	S?
d500 1
a500 1
readline	<HANDLE>		ck_readline	t%	F?
d510 1
a510 1
subst		substitution (s///)	ck_match	dis/	S
d512 1
a512 1
trans		transliteration (tr///)	ck_match	is"	S
a591 2
smartmatch	smart match		ck_smartmatch	s2

d650 1
a650 1
unpack		unpack			ck_unpack	@@	S S?
d667 1
a667 1
sort		sort			ck_sort		dm@@	C? L
a686 1
dor		defined or (//)			ck_null		|
a689 1
dorassign	defined or assignment (//=)	ck_null		s|
d718 1
a718 2
setstate	set statement info	ck_null		s;
method_named	method with known name	ck_null		d$
d720 2
a721 6
entergiven	given()			ck_null		d|
leavegiven	leave given block	ck_null		1
enterwhen	when()			ck_null		d|
leavewhen	leave when block	ck_null		1
break		break			ck_null		0
continue	continue		ck_null		0
a748 1
say		say			ck_listiob	ims@@	F? L
d796 3
a802 3
ftrowned	-O			ck_ftst		isu-	F-
fteowned	-o			ck_ftst		isu-	F-
ftzero		-z			ck_ftst		isu-	F-
d809 1
a812 1
ftlink		-l			ck_ftst		isu-	F-
d819 1
a819 2
# chdir really behaves as if it had both "S?" and "F?"
chdir		chdir			ck_chdir	isT%	S?
d829 1
a829 1
mkdir		mkdir			ck_fun		isTu@@	S? S?
a883 1
semop		semop			ck_fun		imst@@	S S
d886 1
d938 1
d940 3
a942 1
# For state support
d944 1
a944 1
once		once			ck_null		|	
@


1.1.1.10
log
@import perl 5.10.1
@
text
@a1 15
# 
# Regenerate (overwriting only if changed):
#
#    opcode.h
#    opnames.h
#    pp_proto.h
#    pp.sym
#
# from information stored in the DATA section of this file, plus the
# values hardcoded into this script in @@raw_alias.
#
# Accepts the standard regen_lib -q and -v args.
#
# This script is normally invoked from regen.pl.

d11 5
a15 3
my $oc = safer_open($opcode_new);
my $on = safer_open($opname_new);
select $oc;
d129 1
a129 1
print $on <<"END";
d135 1
a135 1
 *    2007, 2008 by Larry Wall and others
d151 1
a151 1
    print $on "\t", &tab(3,"OP_\U$_,"), "/* ", $i++, " */\n";
d153 5
a157 5
print $on "\t", &tab(3,"OP_max"), "\n";
print $on "} opcode;\n";
print $on "\n#define MAXO ", scalar @@ops, "\n";
print $on "#define OP_phoney_INPUT_ONLY -1\n";
print $on "#define OP_phoney_OUTPUT_ONLY -2\n\n";
a291 2
my $ARGBITS = 32;

a327 12
my %opflags = (
    'm' =>   1,		# needs stack mark
    'f' =>   2,		# fold constants
    's' =>   4,		# always produces scalar
    't' =>   8,		# needs target scalar
    'T' =>   8 | 256,	# ... which may be lexical
    'i' =>  16,		# always produces integer
    'I' =>  32,		# has corresponding int op
    'd' =>  64,		# danger, unknown side effects
    'u' => 128,		# defaults to $_
);

a329 2
my $OCSHIFT = 9;
my $OASHIFT = 13;
d331 1
a331 1
for my $op (@@ops) {
d333 14
a346 13
    my $flags = $flags{$op};
    for my $flag (keys %opflags) {
	if ($flags =~ s/$flag//) {
	    die "Flag collision for '$op' ($flags{$op}, $flag)\n"
		if $argsum & $opflags{$flag};
	    $argsum |= $opflags{$flag};
	}
    }
    die qq[Opcode '$op' has no class indicator ($flags{$op} => $flags)\n]
	unless exists $opclass{$flags};
    $argsum |= $opclass{$flags} << $OCSHIFT;
    my $argshift = $OASHIFT;
    for my $arg (split(' ',$args{$op})) {
d348 2
a349 2
           $OP_IS_SOCKET{$op}   = 1 if $arg =~ s/s//;
           $OP_IS_FILETEST{$op} = 1 if $arg =~ s/-//;
d352 1
a352 2
        die "op = $op, arg = $arg\n"
	    unless exists $argnum{$arg};
d354 4
a357 5
	die "Argument overflow for '$op'\n"
	    if $argshift >= $ARGBITS ||
	       $argnum > ((1 << ($ARGBITS - $argshift)) - 1);
	$argsum += $argnum << $argshift;
	$argshift += 4;
d360 1
a360 1
    print "\t", &tab(3, "$argsum,"), "/* $op */\n";
d374 2
a375 2
    print $on "\n#define OP_IS_SOCKET(op)	\\\n\t(";
    print $on join(" || \\\n\t ",
d377 1
a377 1
    print $on ")\n\n";
d381 2
a382 2
    print $on "\n#define OP_IS_FILETEST(op)	\\\n\t(";
    print $on join(" || \\\n\t ",
d384 1
a384 1
    print $on ")\n\n";
d387 2
a388 2
print $oc "/* ex: set ro: */\n";
print $on "/* ex: set ro: */\n";
d390 2
a391 2
safer_close($oc);
safer_close($on);
d393 5
a397 2
rename_if_different $opcode_new, 'opcode.h';
rename_if_different $opname_new, 'opnames.h';
d402 4
a405 2
my $pp = safer_open($pp_proto_new);
my $ppsym = safer_open($pp_sym_new);
d407 1
a407 1
print $pp <<"END";
d416 1
a416 1
print $ppsym <<"END";
d428 2
a429 2
    print $pp "PERL_CKDEF(Perl_$_)\n";
    print $ppsym "Perl_$_\n";
d433 1
a433 1
print $pp "\n\n";
d438 2
a439 2
    print $pp "PERL_PPDEF(Perl_pp_$_)\n";
    print $ppsym "Perl_pp_$_\n";
d441 2
a442 2
print $pp "\n/* ex: set ro: */\n";
print $ppsym "\n# ex: set ro:\n";
d444 2
a445 2
safer_close($pp);
safer_close($ppsym);
d447 5
a451 2
rename_if_different $pp_proto_new, 'pp_proto.h';
rename_if_different $pp_sym_new, 'pp.sym';
d714 1
a714 1
length		length			ck_lengthconst	ifsTu%	S?
d721 1
a721 1
sprintf		sprintf			ck_fun		fmst@@	S L
d747 1
a747 1
helem		hash element		ck_null		s2	H S
@


1.1.1.11
log
@Perl 5.12.2 from CPAN
@
text
@d33 1
a33 1
my (@@ops, %desc, %check, %ckname, %flags, %args, %opnum);
a47 1
    $opnum{$key} = $#ops;
a106 1
		 Perl_pp_akeys => ['avalues'],
d164 1
a164 2
    # print $on "\t", &tab(3,"OP_\U$_,"), "/* ", $i++, " */\n";
      print $on "\t", &tab(3,"OP_\U$_"), " = ", $i++, ",\n";
a356 1
my %OP_IS_FT_ACCESS;
d376 2
a377 4
	    # record opnums of these opnames
	    $OP_IS_SOCKET{$op}   = $opnum{$op} if $arg =~ s/s//;
	    $OP_IS_FILETEST{$op} = $opnum{$op} if $arg =~ s/-//;
	    $OP_IS_FT_ACCESS{$op} = $opnum{$op} if $arg =~ s/\+//;
d403 6
a408 3
# Emit OP_IS_* macros

print $on <<EO_OP_IS_COMMENT;
d410 5
a414 38
/* the OP_IS_(SOCKET|FILETEST) macros are optimized to a simple range
    check because all the member OPs are contiguous in opcode.pl
    <DATA> table.  opcode.pl verifies the range contiguity.  */

EO_OP_IS_COMMENT

gen_op_is_macro( \%OP_IS_SOCKET, 'OP_IS_SOCKET');
gen_op_is_macro( \%OP_IS_FILETEST, 'OP_IS_FILETEST');
gen_op_is_macro( \%OP_IS_FT_ACCESS, 'OP_IS_FILETEST_ACCESS');

sub gen_op_is_macro {
    my ($op_is, $macname) = @@_;
    if (keys %$op_is) {
	
	# get opnames whose numbers are lowest and highest
	my ($first, @@rest) = sort {
	    $op_is->{$a} <=> $op_is->{$b}
	} keys %$op_is;
	
	my $last = pop @@rest;	# @@rest slurped, get its last
	die "Invalid range of ops: $first .. $last\n" unless $last;

	print $on "#define $macname(op)	\\\n\t(";

	# verify that op-ct matches 1st..last range (and fencepost)
	# (we know there are no dups)
	if ( $op_is->{$last} - $op_is->{$first} == scalar @@rest + 1) {
	    
	    # contiguous ops -> optimized version
	    print $on "(op) >= OP_" . uc($first) . " && (op) <= OP_" . uc($last);
	    print $on ")\n\n";
	}
	else {
	    print $on join(" || \\\n\t ",
			  map { "(op) == OP_" . uc() } sort keys %$op_is);
	    print $on ")\n\n";
	}
    }
d578 1
a578 3
# socket      - Fs           filetest - F-           filetest_access - F-+

# reference - R
d736 1
a736 1
length		length			ck_fun		ifsTu%	S?
a760 4
aeach		each on array		ck_each		%	A
akeys		keys on array		ck_each		t%	A
avalues		values on array		ck_each		t%	A

d763 3
a765 3
each		each			ck_each		%	H
values		values			ck_each		t%	H
keys		keys			ck_each		t%	H
a770 1
boolkeys	boolkeys		ck_fun		%	H
d844 1
d887 3
d900 1
a900 4
# Sockets.  OP_IS_SOCKET wants them consecutive (so moved 1st 2)

send		send			ck_fun		imst@@	Fs S S S?
recv		recv			ck_fun		imst@@	Fs R S S
d917 1
a917 1
# Stat calls.  OP_IS_FILETEST wants them consecutive.
d921 6
a926 6
ftrread		-R			ck_ftst		isu-	F-+
ftrwrite	-W			ck_ftst		isu-	F-+
ftrexec		-X			ck_ftst		isu-	F-+
fteread		-r			ck_ftst		isu-	F-+
ftewrite	-w			ck_ftst		isu-	F-+
fteexec		-x			ck_ftst		isu-	F-+
a1024 1
hintseval	eval hints		ck_svconst	s$
d1028 1
a1028 1
entertry	eval {block}		ck_eval		d%	
@


