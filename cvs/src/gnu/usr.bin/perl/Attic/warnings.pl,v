head	1.2;
access;
symbols
	OPENBSD_5_3:1.1.1.10.0.10
	OPENBSD_5_3_BASE:1.1.1.10
	OPENBSD_5_2:1.1.1.10.0.8
	OPENBSD_5_2_BASE:1.1.1.10
	OPENBSD_5_1_BASE:1.1.1.10
	OPENBSD_5_1:1.1.1.10.0.6
	OPENBSD_5_0:1.1.1.10.0.4
	OPENBSD_5_0_BASE:1.1.1.10
	OPENBSD_4_9:1.1.1.10.0.2
	OPENBSD_4_9_BASE:1.1.1.10
	PERL_5_12_2:1.1.1.10
	OPENBSD_4_8:1.1.1.9.0.4
	OPENBSD_4_8_BASE:1.1.1.9
	OPENBSD_4_7:1.1.1.9.0.2
	OPENBSD_4_7_BASE:1.1.1.9
	PERL_5_10_1:1.1.1.9
	OPENBSD_4_6:1.1.1.8.0.6
	OPENBSD_4_6_BASE:1.1.1.8
	OPENBSD_4_5:1.1.1.8.0.2
	OPENBSD_4_5_BASE:1.1.1.8
	PERL_5_10_0:1.1.1.8
	OPENBSD_4_4:1.1.1.7.0.10
	OPENBSD_4_4_BASE:1.1.1.7
	OPENBSD_4_3:1.1.1.7.0.8
	OPENBSD_4_3_BASE:1.1.1.7
	OPENBSD_4_2:1.1.1.7.0.6
	OPENBSD_4_2_BASE:1.1.1.7
	OPENBSD_4_1:1.1.1.7.0.4
	OPENBSD_4_1_BASE:1.1.1.7
	OPENBSD_4_0:1.1.1.7.0.2
	OPENBSD_4_0_BASE:1.1.1.7
	PERL_5_8_8:1.1.1.7
	OPENBSD_3_9:1.1.1.6.0.6
	OPENBSD_3_9_BASE:1.1.1.6
	OPENBSD_3_8:1.1.1.6.0.4
	OPENBSD_3_8_BASE:1.1.1.6
	OPENBSD_3_7:1.1.1.6.0.2
	OPENBSD_3_7_BASE:1.1.1.6
	PERL_5_8_6:1.1.1.6
	OPENBSD_3_6:1.1.1.5.0.2
	OPENBSD_3_6_BASE:1.1.1.5
	PERL_5_8_5:1.1.1.5
	PERL_5_8_3:1.1.1.5
	OPENBSD_3_5:1.1.1.4.0.2
	OPENBSD_3_5_BASE:1.1.1.4
	PERL_5_8_2:1.1.1.4
	OPENBSD_3_4:1.1.1.3.0.4
	OPENBSD_3_4_BASE:1.1.1.3
	OPENBSD_3_3:1.1.1.3.0.2
	OPENBSD_3_3_BASE:1.1.1.3
	PERL_5_8_0:1.1.1.3
	OPENBSD_3_2:1.1.1.2.0.6
	OPENBSD_3_2_BASE:1.1.1.2
	OPENBSD_3_1:1.1.1.2.0.4
	OPENBSD_3_1_BASE:1.1.1.2
	OPENBSD_3_0:1.1.1.2.0.2
	OPENBSD_3_0_BASE:1.1.1.2
	PERL_5_6_1:1.1.1.2
	OPENBSD_2_9:1.1.1.1.0.6
	OPENBSD_2_9_BASE:1.1.1.1
	OPENBSD_2_8:1.1.1.1.0.4
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.2
	OPENBSD_2_7_BASE:1.1.1.1
	PERL_5_6_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2013.03.25.20.40.45;	author sthen;	state dead;
branches;
next	1.1;

1.1
date	2000.04.06.16.08.51;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.04.06.16.08.51;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.05.24.18.22.28;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.10.27.22.14.52;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.12.03.02.43.39;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.04.07.21.12.57;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2005.01.15.21.16.39;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2006.03.28.18.47.49;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2008.09.29.17.18.11;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2009.10.12.18.10.35;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2010.09.24.14.48.26;	author millert;	state Exp;
branches;
next	;


desc
@@


1.2
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@#!/usr/bin/perl

BEGIN {
  push @@INC, './lib';
}
use strict ;

sub DEFAULT_ON  () { 1 }
sub DEFAULT_OFF () { 2 }

my $tree = {

'all' => {
       	'io'  		=> { 	'pipe' 		=> DEFAULT_OFF,
       				'unopened'	=> DEFAULT_OFF,
       				'closed'	=> DEFAULT_OFF,
       				'newline'	=> DEFAULT_OFF,
       				'exec'		=> DEFAULT_OFF,
			   },
       	'syntax'	=> { 	'ambiguous'	=> DEFAULT_OFF,
			     	'semicolon'	=> DEFAULT_OFF,
			     	'precedence'	=> DEFAULT_OFF,
			     	'bareword'	=> DEFAULT_OFF,
			     	'reserved'	=> DEFAULT_OFF,
				'digit'		=> DEFAULT_OFF,
			     	'parenthesis'	=> DEFAULT_OFF,
       	 			'deprecated'	=> DEFAULT_OFF,
       	 			'printf'	=> DEFAULT_OFF,
       	 			'prototype'	=> DEFAULT_OFF,
       	 			'qw'		=> DEFAULT_OFF,
			   },
       	'severe'	=> { 	'inplace'	=> DEFAULT_ON,
	 			'internal'	=> DEFAULT_ON,
         			'debugging'	=> DEFAULT_ON,
         			'malloc'	=> DEFAULT_ON,
	 		   },
       	'void'		=> DEFAULT_OFF,
       	'recursion'	=> DEFAULT_OFF,
       	'redefine'	=> DEFAULT_OFF,
       	'numeric'	=> DEFAULT_OFF,
        'uninitialized'	=> DEFAULT_OFF,
       	'once'		=> DEFAULT_OFF,
       	'misc'		=> DEFAULT_OFF,
       	'regexp'	=> DEFAULT_OFF,
       	'glob'		=> DEFAULT_OFF,
       	'y2k'		=> DEFAULT_OFF,
       	'chmod'		=> DEFAULT_OFF,
       	'umask'		=> DEFAULT_OFF,
       	'untie'		=> DEFAULT_OFF,
	'substr'	=> DEFAULT_OFF,
	'taint'		=> DEFAULT_OFF,
	'signal'	=> DEFAULT_OFF,
	'closure'	=> DEFAULT_OFF,
	'overflow'	=> DEFAULT_OFF,
	'portable'	=> DEFAULT_OFF,
	'utf8'		=> DEFAULT_OFF,
       	'exiting'	=> DEFAULT_OFF,
       	'pack'		=> DEFAULT_OFF,
       	'unpack'	=> DEFAULT_OFF,
       	 #'default'	=> DEFAULT_ON,
  	}
} ;


###########################################################################
sub tab {
    my($l, $t) = @@_;
    $t .= "\t" x ($l - (length($t) + 1) / 8);
    $t;
}

###########################################################################

my %list ;
my %Value ;
my $index ;

sub walk
{
    my $tre = shift ;
    my @@list = () ;
    my ($k, $v) ;

    foreach $k (sort keys %$tre) {
	$v = $tre->{$k};
	die "duplicate key $k\n" if defined $list{$k} ;
	$Value{$index} = uc $k ;
        push @@{ $list{$k} }, $index ++ ;
	if (ref $v)
	  { push (@@{ $list{$k} }, walk ($v)) }
	push @@list, @@{ $list{$k} } ;
    }

   return @@list ;
}

###########################################################################

sub mkRange
{
    my @@a = @@_ ;
    my @@out = @@a ;
    my $i ;


    for ($i = 1 ; $i < @@a; ++ $i) {
      	$out[$i] = ".." 
          if $a[$i] == $a[$i - 1] + 1 && $a[$i] + 1 == $a[$i + 1] ;
    }

    my $out = join(",",@@out);

    $out =~ s/,(\.\.,)+/../g ;
    return $out;
}

###########################################################################
sub printTree
{
    my $tre = shift ;
    my $prefix = shift ;
    my $indent = shift ;
    my ($k, $v) ;

    my $max = (sort {$a <=> $b} map { length $_ } keys %$tre)[-1] ;

    $prefix .= " " x $indent ;
    foreach $k (sort keys %$tre) {
	$v = $tre->{$k};
	print $prefix . "|\n" ;
	print $prefix . "+- $k" ;
	if (ref $v)
	{ 
	    print " " . "-" x ($max - length $k ) . "+\n" ;
	    printTree ($v, $prefix . "|" , $max + $indent - 1) 
	}
	else
	  { print "\n" }
    }

}

###########################################################################

sub mkHex
{
    my ($max, @@a) = @@_ ;
    my $mask = "\x00" x $max ;
    my $string = "" ;

    foreach (@@a) {
	vec($mask, $_, 1) = 1 ;
    }

    #$string = unpack("H$max", $mask) ;
    #$string =~ s/(..)/\x$1/g;
    foreach (unpack("C*", $mask)) {
	$string .= '\x' . sprintf("%2.2x", $_) ;
    }
    return $string ;
}

###########################################################################

if (@@ARGV && $ARGV[0] eq "tree")
{
    #print "  all -+\n" ;
    printTree($tree, "   ", 4) ;
    exit ;
}

#unlink "warnings.h";
#unlink "lib/warnings.pm";
open(WARN, ">warnings.h") || die "Can't create warnings.h: $!\n";
open(PM, ">lib/warnings.pm") || die "Can't create lib/warnings.pm: $!\n";

print WARN <<'EOM' ;
/* !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
   This file is built by warnings.pl
   Any changes made here will be lost!
*/


#define Off(x)			((x) / 8)
#define Bit(x)			(1 << ((x) % 8))
#define IsSet(a, x)		((a)[Off(x)] & Bit(x))


#define G_WARN_OFF		0 	/* $^W == 0 */
#define G_WARN_ON		1	/* -w flag and $^W != 0 */
#define G_WARN_ALL_ON		2	/* -W flag */
#define G_WARN_ALL_OFF		4	/* -X flag */
#define G_WARN_ONCE		8	/* set if 'once' ever enabled */
#define G_WARN_ALL_MASK		(G_WARN_ALL_ON|G_WARN_ALL_OFF)

#define pWARN_STD		Nullsv
#define pWARN_ALL		(Nullsv+1)	/* use warnings 'all' */
#define pWARN_NONE		(Nullsv+2)	/* no  warnings 'all' */

#define specialWARN(x)		((x) == pWARN_STD || (x) == pWARN_ALL ||	\
				 (x) == pWARN_NONE)

#define ckDEAD(x)							\
	   ( ! specialWARN(PL_curcop->cop_warnings) &&			\
	    IsSet(SvPVX(PL_curcop->cop_warnings), 2*x+1))

#define ckWARN(x)							\
	( (PL_curcop->cop_warnings != pWARN_STD &&			\
	   PL_curcop->cop_warnings != pWARN_NONE &&			\
	      (PL_curcop->cop_warnings == pWARN_ALL ||			\
	       IsSet(SvPVX(PL_curcop->cop_warnings), 2*x) ) )		\
	  || (PL_curcop->cop_warnings == pWARN_STD && PL_dowarn & G_WARN_ON) )

#define ckWARN2(x,y)							\
	  ( (PL_curcop->cop_warnings != pWARN_STD  &&			\
	     PL_curcop->cop_warnings != pWARN_NONE &&			\
	      (PL_curcop->cop_warnings == pWARN_ALL ||			\
	        IsSet(SvPVX(PL_curcop->cop_warnings), 2*x)  ||		\
	        IsSet(SvPVX(PL_curcop->cop_warnings), 2*y) ) ) 		\
	    ||	(PL_curcop->cop_warnings == pWARN_STD && PL_dowarn & G_WARN_ON) )

#define ckWARN_d(x)							\
	  (PL_curcop->cop_warnings == pWARN_STD ||			\
	   PL_curcop->cop_warnings == pWARN_ALL ||			\
	     (PL_curcop->cop_warnings != pWARN_NONE &&			\
	      IsSet(SvPVX(PL_curcop->cop_warnings), 2*x) ) )

#define ckWARN2_d(x,y)							\
	  (PL_curcop->cop_warnings == pWARN_STD ||			\
	   PL_curcop->cop_warnings == pWARN_ALL ||			\
	     (PL_curcop->cop_warnings != pWARN_NONE &&			\
	        (IsSet(SvPVX(PL_curcop->cop_warnings), 2*x)  ||		\
	         IsSet(SvPVX(PL_curcop->cop_warnings), 2*y) ) ) )


#define isLEXWARN_on 	(PL_curcop->cop_warnings != pWARN_STD)
#define isLEXWARN_off	(PL_curcop->cop_warnings == pWARN_STD)
#define isWARN_ONCE	(PL_dowarn & (G_WARN_ON|G_WARN_ONCE))
#define isWARN_on(c,x)	(IsSet(SvPVX(c), 2*(x)))

EOM

my $offset = 0 ;

$index = $offset ;
#@@{ $list{"all"} } = walk ($tree) ;
walk ($tree) ;


$index *= 2 ;
my $warn_size = int($index / 8) + ($index % 8 != 0) ;

my $k ;
foreach $k (sort { $a <=> $b } keys %Value) {
    print WARN tab(5, "#define WARN_$Value{$k}"), "$k\n" ;
}
print WARN "\n" ;

print WARN tab(5, '#define WARNsize'),	"$warn_size\n" ;
#print WARN tab(5, '#define WARN_ALLstring'), '"', ('\377' x $warn_size) , "\"\n" ;
print WARN tab(5, '#define WARN_ALLstring'), '"', ('\125' x $warn_size) , "\"\n" ;
print WARN tab(5, '#define WARN_NONEstring'), '"', ('\0' x $warn_size) , "\"\n" ;

print WARN <<'EOM';

/* end of file warnings.h */

EOM

close WARN ;

while (<DATA>) {
    last if /^KEYWORDS$/ ;
    print PM $_ ;
}

#$list{'all'} = [ $offset .. 8 * ($warn_size/2) - 1 ] ;

#my %Keys = map {lc $Value{$_}, $_} keys %Value ;

print PM "%Offsets = (\n" ;
foreach my $k (sort { $a <=> $b } keys %Value) {
    my $v = lc $Value{$k} ;
    $k *= 2 ;
    print PM tab(4, "    '$v'"), "=> $k,\n" ;
}

print PM "  );\n\n" ;

print PM "%Bits = (\n" ;
foreach $k (sort keys  %list) {

    my $v = $list{$k} ;
    my @@list = sort { $a <=> $b } @@$v ;

    print PM tab(4, "    '$k'"), '=> "', 
		# mkHex($warn_size, @@list), 
		mkHex($warn_size, map $_ * 2 , @@list), 
		'", # [', mkRange(@@list), "]\n" ;
}

print PM "  );\n\n" ;

print PM "%DeadBits = (\n" ;
foreach $k (sort keys  %list) {

    my $v = $list{$k} ;
    my @@list = sort { $a <=> $b } @@$v ;

    print PM tab(4, "    '$k'"), '=> "', 
		# mkHex($warn_size, @@list), 
		mkHex($warn_size, map $_ * 2 + 1 , @@list), 
		'", # [', mkRange(@@list), "]\n" ;
}

print PM "  );\n\n" ;
print PM '$NONE     = "', ('\0' x $warn_size) , "\";\n" ;
print PM '$LAST_BIT = ' . "$index ;\n" ;
print PM '$BYTES    = ' . "$warn_size ;\n" ;
while (<DATA>) {
    print PM $_ ;
}

close PM ;

__END__

# This file was created by warnings.pl
# Any changes made here will be lost.
#

package warnings;

=head1 NAME

warnings - Perl pragma to control optional warnings

=head1 SYNOPSIS

    use warnings;
    no warnings;

    use warnings "all";
    no warnings "all";

    use warnings::register;
    if (warnings::enabled()) {
        warnings::warn("some warning");
    }

    if (warnings::enabled("void")) {
        warnings::warn("void", "some warning");
    }

=head1 DESCRIPTION

If no import list is supplied, all possible warnings are either enabled
or disabled.

A number of functions are provided to assist module authors. 

=over 4

=item use warnings::register

Creates a new warnings category which has the same name as the module
where the call to the pragma is used.

=item warnings::enabled([$category])

Returns TRUE if the warnings category C<$category> is enabled in the
calling module.  Otherwise returns FALSE.

If the parameter, C<$category>, isn't supplied, the current package name
will be used.

=item warnings::warn([$category,] $message)

If the calling module has I<not> set C<$category> to "FATAL", print
C<$message> to STDERR.
If the calling module has set C<$category> to "FATAL", print C<$message>
STDERR then die.

If the parameter, C<$category>, isn't supplied, the current package name
will be used.

=back

See L<perlmod/Pragmatic Modules> and L<perllexwarn>.

=cut

use Carp ;

KEYWORDS

$All = "" ; vec($All, $Offsets{'all'}, 2) = 3 ;

sub bits {
    my $mask ;
    my $catmask ;
    my $fatal = 0 ;
    foreach my $word (@@_) {
	if  ($word eq 'FATAL') {
	    $fatal = 1;
	}
	elsif ($catmask = $Bits{$word}) {
	    $mask |= $catmask ;
	    $mask |= $DeadBits{$word} if $fatal ;
	}
	else
          { croak("unknown warnings category '$word'")}  
    }

    return $mask ;
}

sub import {
    shift;
    ${^WARNING_BITS} |= bits(@@_ ? @@_ : 'all') ;
}

sub unimport {
    shift;
    my $mask = ${^WARNING_BITS} ;
    if (vec($mask, $Offsets{'all'}, 1)) {
        $mask = $Bits{'all'} ;
        $mask |= $DeadBits{'all'} if vec($mask, $Offsets{'all'}+1, 1);
    }
    ${^WARNING_BITS} = $mask & ~ (bits(@@_ ? @@_ : 'all') | $All) ;
}

sub enabled
{
    croak("Usage: warnings::enabled([category])")
	unless @@_ == 1 || @@_ == 0 ;
    local $Carp::CarpLevel = 1 ;
    my $category ;
    my $offset ;
    my $callers_bitmask = (caller(1))[9] ; 
    return 0 unless defined $callers_bitmask ;


    if (@@_) {
        # check the category supplied.
        $category = shift ;
        $offset = $Offsets{$category};
        croak("unknown warnings category '$category'")
	    unless defined $offset;
    }
    else {
        $category = (caller(0))[0] ; 
        $offset = $Offsets{$category};
        croak("package '$category' not registered for warnings")
	    unless defined $offset ;
    }

    return vec($callers_bitmask, $offset, 1) ||
           vec($callers_bitmask, $Offsets{'all'}, 1) ;
}


sub warn
{
    croak("Usage: warnings::warn([category,] 'message')")
	unless @@_ == 2 || @@_ == 1 ;
    local $Carp::CarpLevel = 1 ;
    my $category ;
    my $offset ;
    my $callers_bitmask = (caller(1))[9] ; 

    if (@@_ == 2) {
        $category = shift ;
        $offset = $Offsets{$category};
        croak("unknown warnings category '$category'")
	    unless defined $offset ;
    }
    else {
        $category = (caller(0))[0] ; 
        $offset = $Offsets{$category};
        croak("package '$category' not registered for warnings")
	    unless defined $offset ;
    }

    my $message = shift ;
    croak($message) 
	if vec($callers_bitmask, $offset+1, 1) ||
	   vec($callers_bitmask, $Offsets{'all'}+1, 1) ;
    carp($message) ;
}

1;
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@virgin perl 5.6.0
@
text
@@


1.1.1.2
log
@stock perl 5.6.1
@
text
@d172 2
a173 2
unlink "warnings.h";
unlink "lib/warnings.pm";
d202 39
a265 35
#define isLEXWARN_on 	(PL_curcop->cop_warnings != pWARN_STD)
#define isLEXWARN_off	(PL_curcop->cop_warnings == pWARN_STD)
#define isWARN_ONCE	(PL_dowarn & (G_WARN_ON|G_WARN_ONCE))
#define isWARN_on(c,x)	(IsSet(SvPVX(c), 2*(x)))
#define isWARNf_on(c,x)	(IsSet(SvPVX(c), 2*(x)+1))

#define ckDEAD(x)							\
	   ( ! specialWARN(PL_curcop->cop_warnings) &&			\
	    ( isWARNf_on(PL_curcop->cop_warnings, WARN_ALL) || 		\
	      isWARNf_on(PL_curcop->cop_warnings, x)))

#define ckWARN(x)							\
	( (isLEXWARN_on && PL_curcop->cop_warnings != pWARN_NONE &&	\
	      (PL_curcop->cop_warnings == pWARN_ALL ||			\
	       isWARN_on(PL_curcop->cop_warnings, x) ) )		\
	  || (isLEXWARN_off && PL_dowarn & G_WARN_ON) )

#define ckWARN2(x,y)							\
	  ( (isLEXWARN_on && PL_curcop->cop_warnings != pWARN_NONE &&	\
	      (PL_curcop->cop_warnings == pWARN_ALL ||			\
	        isWARN_on(PL_curcop->cop_warnings, x)  ||		\
	        isWARN_on(PL_curcop->cop_warnings, y) ) ) 		\
	    ||	(isLEXWARN_off && PL_dowarn & G_WARN_ON) )

#define ckWARN_d(x)							\
	  (isLEXWARN_off || PL_curcop->cop_warnings == pWARN_ALL ||	\
	     (PL_curcop->cop_warnings != pWARN_NONE &&			\
	      isWARN_on(PL_curcop->cop_warnings, x) ) )

#define ckWARN2_d(x,y)							\
	  (isLEXWARN_off || PL_curcop->cop_warnings == pWARN_ALL ||	\
	     (PL_curcop->cop_warnings != pWARN_NONE &&			\
	        (isWARN_on(PL_curcop->cop_warnings, x)  ||		\
	         isWARN_on(PL_curcop->cop_warnings, y) ) ) )

a354 8
    if (warnings::enabled($object)) {
        warnings::warn($object, "some warning");
    }

    warnif("some warning");
    warnif("void", "some warning");
    warnif($object, "some warning");

d366 2
a367 33
Creates a new warnings category with the same name as the package where
the call to the pragma is used.

=item warnings::enabled()

Use the warnings category with the same name as the current package.

Return TRUE if that warnings category is enabled in the calling module.
Otherwise returns FALSE.

=item warnings::enabled($category)

Return TRUE if the warnings category, C<$category>, is enabled in the
calling module.
Otherwise returns FALSE.

=item warnings::enabled($object)

Use the name of the class for the object reference, C<$object>, as the
warnings category.

Return TRUE if that warnings category is enabled in the first scope
where the object is used.
Otherwise returns FALSE.

=item warnings::warn($message)

Print C<$message> to STDERR.

Use the warnings category with the same name as the current package.

If that warnings category has been set to "FATAL" in the calling module
then die. Otherwise return.
d369 1
a369 1
=item warnings::warn($category, $message)
d371 2
a372 1
Print C<$message> to STDERR.
d374 2
a375 2
If the warnings category, C<$category>, has been set to "FATAL" in the
calling module then die. Otherwise return.
d377 1
a377 1
=item warnings::warn($object, $message)
d379 4
a382 1
Print C<$message> to STDERR.
d384 2
a385 27
Use the name of the class for the object reference, C<$object>, as the
warnings category.

If that warnings category has been set to "FATAL" in the scope where C<$object>
is first used then die. Otherwise return.


=item warnings::warnif($message)

Equivalent to:

    if (warnings::enabled())
      { warnings::warn($message) }

=item warnings::warnif($category, $message)

Equivalent to:

    if (warnings::enabled($category))
      { warnings::warn($category, $message) }

=item warnings::warnif($object, $message)

Equivalent to:

    if (warnings::enabled($object))
      { warnings::warn($object, $message) }
d389 1
a389 1
See L<perlmodlib/Pragmatic Modules> and L<perllexwarn>.
d420 1
a420 6
    my $mask = ${^WARNING_BITS} ;
    if (vec($mask, $Offsets{'all'}, 1)) {
        $mask |= $Bits{'all'} ;
        $mask |= $DeadBits{'all'} if vec($mask, $Offsets{'all'}+1, 1);
    }
    ${^WARNING_BITS} = $mask | bits(@@_ ? @@_ : 'all') ;
d427 1
a427 1
        $mask |= $Bits{'all'} ;
d433 1
a433 1
sub __chk
d435 3
d440 3
a442 1
    my $isobj = 0 ;
a446 6
        if (ref $category) {
            croak ("not an object")
                if $category !~ /^([^=]+)=/ ;+
	    $category = $1 ;
            $isobj = 1 ;
        }
d452 1
a452 1
        $category = (caller(1))[0] ; 
a457 30
    my $this_pkg = (caller(1))[0] ; 
    my $i = 2 ;
    my $pkg ;

    if ($isobj) {
        while (do { { package DB; $pkg = (caller($i++))[0] } } ) {
            last unless @@DB::args && $DB::args[0] =~ /^$category=/ ;
        }
	$i -= 2 ;
    }
    else {
        for ($i = 2 ; $pkg = (caller($i))[0] ; ++ $i) {
            last if $pkg ne $this_pkg ;
        }
        $i = 2 
            if !$pkg || $pkg eq $this_pkg ;
    }

    my $callers_bitmask = (caller($i))[9] ; 
    return ($callers_bitmask, $offset, $i) ;
}

sub enabled
{
    croak("Usage: warnings::enabled([category])")
	unless @@_ == 1 || @@_ == 0 ;

    my ($callers_bitmask, $offset, $i) = __chk(@@_) ;

    return 0 unless defined $callers_bitmask ;
d467 17
d485 1
a485 3
    my $message = pop ;
    my ($callers_bitmask, $offset, $i) = __chk(@@_) ;
    local $Carp::CarpLevel = $i ;
a491 20
sub warnif
{
    croak("Usage: warnings::warnif([category,] 'message')")
	unless @@_ == 2 || @@_ == 1 ;

    my $message = pop ;
    my ($callers_bitmask, $offset, $i) = __chk(@@_) ;
    local $Carp::CarpLevel = $i ;

    return 
        unless defined $callers_bitmask &&
            	(vec($callers_bitmask, $offset, 1) ||
            	vec($callers_bitmask, $Offsets{'all'}, 1)) ;

    croak($message) 
	if vec($callers_bitmask, $offset+1, 1) ||
	   vec($callers_bitmask, $Offsets{'all'}+1, 1) ;

    carp($message) ;
}
@


1.1.1.3
log
@stock perl 5.8.0 from CPAN
@
text
@a2 3

$VERSION = '1.00';

d13 49
a61 52
'all' => [ 5.008, {
	'io'		=> [ 5.008, { 	
				'pipe' 		=> [ 5.008, DEFAULT_OFF],
       				'unopened'	=> [ 5.008, DEFAULT_OFF],
       				'closed'	=> [ 5.008, DEFAULT_OFF],
       				'newline'	=> [ 5.008, DEFAULT_OFF],
       				'exec'		=> [ 5.008, DEFAULT_OFF],
       				'layer'		=> [ 5.008, DEFAULT_OFF],
			   }],
     	'syntax'	=> [ 5.008, { 	
				'ambiguous'	=> [ 5.008, DEFAULT_OFF],
			     	'semicolon'	=> [ 5.008, DEFAULT_OFF],
			     	'precedence'	=> [ 5.008, DEFAULT_OFF],
			     	'bareword'	=> [ 5.008, DEFAULT_OFF],
			     	'reserved'	=> [ 5.008, DEFAULT_OFF],
				'digit'		=> [ 5.008, DEFAULT_OFF],
			     	'parenthesis'	=> [ 5.008, DEFAULT_OFF],
       	 			'printf'	=> [ 5.008, DEFAULT_OFF],
       	 			'prototype'	=> [ 5.008, DEFAULT_OFF],
       	 			'qw'		=> [ 5.008, DEFAULT_OFF],
			   }],
       	'severe'	=> [ 5.008, { 	
				'inplace'	=> [ 5.008, DEFAULT_ON],
	 			'internal'	=> [ 5.008, DEFAULT_ON],
         			'debugging'	=> [ 5.008, DEFAULT_ON],
         			'malloc'	=> [ 5.008, DEFAULT_ON],
	 		   }],
        'deprecated'	=> [ 5.008, DEFAULT_OFF],
       	'void'		=> [ 5.008, DEFAULT_OFF],
       	'recursion'	=> [ 5.008, DEFAULT_OFF],
       	'redefine'	=> [ 5.008, DEFAULT_OFF],
       	'numeric'	=> [ 5.008, DEFAULT_OFF],
        'uninitialized'	=> [ 5.008, DEFAULT_OFF],
       	'once'		=> [ 5.008, DEFAULT_OFF],
       	'misc'		=> [ 5.008, DEFAULT_OFF],
       	'regexp'	=> [ 5.008, DEFAULT_OFF],
       	'glob'		=> [ 5.008, DEFAULT_OFF],
       	'y2k'		=> [ 5.008, DEFAULT_OFF],
       	'untie'		=> [ 5.008, DEFAULT_OFF],
	'substr'	=> [ 5.008, DEFAULT_OFF],
	'taint'		=> [ 5.008, DEFAULT_OFF],
	'signal'	=> [ 5.008, DEFAULT_OFF],
	'closure'	=> [ 5.008, DEFAULT_OFF],
	'overflow'	=> [ 5.008, DEFAULT_OFF],
	'portable'	=> [ 5.008, DEFAULT_OFF],
	'utf8'		=> [ 5.008, DEFAULT_OFF],
       	'exiting'	=> [ 5.008, DEFAULT_OFF],
       	'pack'		=> [ 5.008, DEFAULT_OFF],
       	'unpack'	=> [ 5.008, DEFAULT_OFF],
       	'threads'	=> [ 5.008, DEFAULT_OFF],
       	 #'default'	=> [ 5.008, DEFAULT_ON ],
  	}],
d64 1
a75 2
my %ValueToName ;
my %NameToValue ;
a77 39
my %v_list = () ;

sub valueWalk
{
    my $tre = shift ;
    my @@list = () ;
    my ($k, $v) ;

    foreach $k (sort keys %$tre) {
	$v = $tre->{$k};
	die "duplicate key $k\n" if defined $list{$k} ;
	die "Value associated with key '$k' is not an ARRAY reference"
	    if !ref $v || ref $v ne 'ARRAY' ;

	my ($ver, $rest) = @@{ $v } ;
	push @@{ $v_list{$ver} }, $k;
	
	if (ref $rest)
	  { valueWalk ($rest) }

    }

}

sub orderValues
{
    my $index = 0;
    foreach my $ver ( sort { $a <=> $b } keys %v_list ) {
        foreach my $name (@@{ $v_list{$ver} } ) {
	    $ValueToName{ $index } = [ uc $name, $ver ] ;
	    $NameToValue{ uc $name } = $index ++ ;
        }
    }

    return $index ;
}

###########################################################################

d87 4
a90 11
	#$Value{$index} = uc $k ;
	die "Can't find key '$k'"
	    if ! defined $NameToValue{uc $k} ;
        push @@{ $list{$k} }, $NameToValue{uc $k} ;
	die "Value associated with key '$k' is not an ARRAY reference"
	    if !ref $v || ref $v ne 'ARRAY' ;
	
	my ($ver, $rest) = @@{ $v } ;
	if (ref $rest)
	  { push (@@{ $list{$k} }, walk ($rest)) }

d107 1
a107 1
      	$out[$i] = ".."
d122 1
a125 1
    my @@keys = sort keys %$tre ;
d127 2
a128 1
    while ($k = shift @@keys) {
d130 6
a135 20
	die "Value associated with key '$k' is not an ARRAY reference"
	    if !ref $v || ref $v ne 'ARRAY' ;
	
        my $offset ;
	if ($tre ne $tree) {
	    print $prefix . "|\n" ;
	    print $prefix . "+- $k" ;
	    $offset = ' ' x ($max + 4) ;
	}
	else {
	    print $prefix . "$k" ;
	    $offset = ' ' x ($max + 1) ;
	}

	my ($ver, $rest) = @@{ $v } ;
	if (ref $rest)
	{
	    my $bar = @@keys ? "|" : " ";
	    print " -" . "-" x ($max - length $k ) . "+\n" ;
	    printTree ($rest, $prefix . $bar . $offset )
d145 1
a145 1
sub mkHexOct
d147 1
a147 1
    my ($f, $max, @@a) = @@_ ;
d155 2
d158 1
a158 6
        if ($f eq 'x') {
            $string .= '\x' . sprintf("%2.2x", $_)
        }
        else {
            $string .= '\\' . sprintf("%o", $_)
        }
a162 12
sub mkHex
{
    my($max, @@a) = @@_;
    return mkHexOct("x", $max, @@a);
}

sub mkOct
{
    my($max, @@a) = @@_;
    return mkHexOct("o", $max, @@a);
}

d167 2
a168 1
    printTree($tree, "    ") ;
d208 1
a208 7
valueWalk ($tree) ;
my $index = orderValues();

die <<EOM if $index > 255 ;
Too many warnings categories -- max is 255
    rewrite packWARN* & unpackWARN* macros 
EOM
a209 1
walk ($tree) ;
d215 2
a216 7
my $last_ver = 0;
foreach $k (sort { $a <=> $b } keys %ValueToName) {
    my ($name, $version) = @@{ $ValueToName{$k} };
    print WARN "\n/* Warnings Categories added in Perl $version */\n\n"
        if $last_ver != $version ;
    print WARN tab(5, "#define WARN_$name"), "$k\n" ;
    $last_ver = $version ;
a223 3
my $WARN_TAINTstring = mkOct($warn_size, map $_ * 2, @@{ $list{'taint'} });

print WARN tab(5, '#define WARN_TAINTstring'), qq["$WARN_TAINTstring"\n] ;
d233 5
a250 17
#define ckWARN3(x,y,z)							\
	  ( (isLEXWARN_on && PL_curcop->cop_warnings != pWARN_NONE &&	\
	      (PL_curcop->cop_warnings == pWARN_ALL ||			\
	        isWARN_on(PL_curcop->cop_warnings, x)  ||		\
	        isWARN_on(PL_curcop->cop_warnings, y)  ||		\
	        isWARN_on(PL_curcop->cop_warnings, z) ) ) 		\
	    ||	(isLEXWARN_off && PL_dowarn & G_WARN_ON) )

#define ckWARN4(x,y,z,t)						\
	  ( (isLEXWARN_on && PL_curcop->cop_warnings != pWARN_NONE &&	\
	      (PL_curcop->cop_warnings == pWARN_ALL ||			\
	        isWARN_on(PL_curcop->cop_warnings, x)  ||		\
	        isWARN_on(PL_curcop->cop_warnings, y)  ||		\
	        isWARN_on(PL_curcop->cop_warnings, z)  ||		\
	        isWARN_on(PL_curcop->cop_warnings, t) ) ) 		\
	    ||	(isLEXWARN_off && PL_dowarn & G_WARN_ON) )

a261 33
#define ckWARN3_d(x,y,z)						\
	  (isLEXWARN_off || PL_curcop->cop_warnings == pWARN_ALL ||	\
	     (PL_curcop->cop_warnings != pWARN_NONE &&			\
	        (isWARN_on(PL_curcop->cop_warnings, x)  ||		\
	         isWARN_on(PL_curcop->cop_warnings, y)  ||		\
	         isWARN_on(PL_curcop->cop_warnings, z) ) ) )

#define ckWARN4_d(x,y,z,t)						\
	  (isLEXWARN_off || PL_curcop->cop_warnings == pWARN_ALL ||	\
	     (PL_curcop->cop_warnings != pWARN_NONE &&			\
	        (isWARN_on(PL_curcop->cop_warnings, x)  ||		\
	         isWARN_on(PL_curcop->cop_warnings, y)  ||		\
	         isWARN_on(PL_curcop->cop_warnings, z)  ||		\
	         isWARN_on(PL_curcop->cop_warnings, t) ) ) )

#define packWARN(a)		(a                                 )
#define packWARN2(a,b)		((a) | (b)<<8                      )
#define packWARN3(a,b,c)	((a) | (b)<<8 | (c) <<16           )
#define packWARN4(a,b,c,d)	((a) | (b)<<8 | (c) <<16 | (d) <<24)

#define unpackWARN1(x)		((x)        & 0xFF)
#define unpackWARN2(x)		(((x) >>8)  & 0xFF)
#define unpackWARN3(x)		(((x) >>16) & 0xFF)
#define unpackWARN4(x)		(((x) >>24) & 0xFF)

#define ckDEAD(x)							\
	   ( ! specialWARN(PL_curcop->cop_warnings) &&			\
	    ( isWARNf_on(PL_curcop->cop_warnings, WARN_ALL) || 		\
	      isWARNf_on(PL_curcop->cop_warnings, unpackWARN1(x)) ||	\
	      isWARNf_on(PL_curcop->cop_warnings, unpackWARN2(x)) ||	\
	      isWARNf_on(PL_curcop->cop_warnings, unpackWARN3(x)) ||	\
	      isWARNf_on(PL_curcop->cop_warnings, unpackWARN4(x))))

d275 2
a276 1
$last_ver = 0;
d278 2
a279 3
foreach my $k (sort { $a <=> $b } keys %ValueToName) {
    my ($name, $version) = @@{ $ValueToName{$k} };
    $name = lc $name;
d281 1
a281 7
    if ( $last_ver != $version ) {
        print PM "\n";
        print PM tab(4, "    # Warnings Categories added in Perl $version");
        print PM "\n\n";
    }
    print PM tab(4, "    '$name'"), "=> $k,\n" ;
    $last_ver = $version;
d292 3
a294 3
    print PM tab(4, "    '$k'"), '=> "',
		# mkHex($warn_size, @@list),
		mkHex($warn_size, map $_ * 2 , @@list),
d306 3
a308 3
    print PM tab(4, "    '$k'"), '=> "',
		# mkHex($warn_size, @@list),
		mkHex($warn_size, map $_ * 2 + 1 , @@list),
a323 1
# !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
a329 2
our $VERSION = '1.00';

d355 3
a357 3
    warnings::warnif("some warning");
    warnings::warnif("void", "some warning");
    warnings::warnif($object, "some warning");
d364 1
a364 1
A number of functions are provided to assist module authors.
d455 2
a456 13
sub Croaker
{
    delete $Carp::CarpInternal{'warnings'};
    croak @@_ ;
}

sub bits
{
    # called from B::Deparse.pm

    push @@_, 'all' unless @@_;

    my $mask;
d459 2
a460 4
    my $no_fatal = 0 ;

    foreach my $word ( @@_ ) {
	if ($word eq 'FATAL') {
a461 5
	    $no_fatal = 0;
	}
	elsif ($word eq 'NONFATAL') {
	    $fatal = 0;
	    $no_fatal = 1;
a465 1
	    $mask &= ~($DeadBits{$word}|$All) if $no_fatal ;
d468 1
a468 1
          { Croaker("Unknown warnings category '$word'")}
d474 1
a474 2
sub import 
{
a475 5

    my $catmask ;
    my $fatal = 0 ;
    my $no_fatal = 0 ;

a476 1

d481 1
a481 22
    
    push @@_, 'all' unless @@_;

    foreach my $word ( @@_ ) {
	if ($word eq 'FATAL') {
	    $fatal = 1;
	    $no_fatal = 0;
	}
	elsif ($word eq 'NONFATAL') {
	    $fatal = 0;
	    $no_fatal = 1;
	}
	elsif ($catmask = $Bits{$word}) {
	    $mask |= $catmask ;
	    $mask |= $DeadBits{$word} if $fatal ;
	    $mask &= ~($DeadBits{$word}|$All) if $no_fatal ;
	}
	else
          { Croaker("Unknown warnings category '$word'")}
    }

    ${^WARNING_BITS} = $mask ;
d484 1
a484 2
sub unimport 
{
a485 2

    my $catmask ;
a486 1

d491 1
a491 15

    push @@_, 'all' unless @@_;

    foreach my $word ( @@_ ) {
	if ($word eq 'FATAL') {
	    next; 
	}
	elsif ($catmask = $Bits{$word}) {
	    $mask &= ~($catmask | $DeadBits{$word} | $All);
	}
	else
          { Croaker("Unknown warnings category '$word'")}
    }

    ${^WARNING_BITS} = $mask ;
d504 2
a505 2
            Croaker ("not an object")
                if $category !~ /^([^=]+)=/ ;
d510 1
a510 1
        Croaker("Unknown warnings category '$category'")
d514 1
a514 1
        $category = (caller(1))[0] ;
d516 1
a516 1
        Croaker("package '$category' not registered for warnings")
d520 1
a520 1
    my $this_pkg = (caller(1))[0] ;
d534 1
a534 1
        $i = 2
d538 1
a538 1
    my $callers_bitmask = (caller($i))[9] ;
d544 1
a544 1
    Croaker("Usage: warnings::enabled([category])")
d557 1
a557 1
    Croaker("Usage: warnings::warn([category,] 'message')")
d562 2
a563 1
    croak($message)
d571 1
a571 1
    Croaker("Usage: warnings::warnif([category,] 'message')")
d576 1
d578 1
a578 1
    return
d583 1
a583 1
    croak($message)
a588 1

@


1.1.1.4
log
@perl 5.8.2 from CPAN
@
text
@d3 2
a4 1
$VERSION = '1.02';
d416 1
a416 1
print PM "our %Offsets : unique = (\n" ;
d432 1
a432 1
print PM "our %Bits : unique = (\n" ;
d446 1
a446 1
print PM "our %DeadBits : unique = (\n" ;
d477 1
a477 1
our $VERSION = '1.03';
a509 4
The C<warnings> pragma is a replacement for the command line flag C<-w>,
but the pragma is limited to the enclosing block, while the flag is global.
See L<perllexwarn> for more information.

d598 1
a598 1
use Carp ();
d607 1
a607 1
    Carp::croak(@@_);
d776 1
a776 1
    Carp::croak($message)
d779 1
a779 1
    Carp::carp($message) ;
d795 1
a795 1
    Carp::croak($message)
d799 1
a799 1
    Carp::carp($message) ;
@


1.1.1.5
log
@perl 5.8.3 from CPAN
@
text
@d415 1
a415 1
print PM "our %Offsets = (\n" ;
d431 1
a431 1
print PM "our %Bits = (\n" ;
d445 1
a445 1
print PM "our %DeadBits = (\n" ;
@


1.1.1.6
log
@perl 5.8.6 from CPAN
@
text
@a710 2
my %builtin_type; @@builtin_type{qw(SCALAR ARRAY HASH CODE REF GLOB LVALUE Regexp)} = ();

d720 4
a723 4
        if (my $type = ref $category) {
            Croaker("not an object")
                if exists $builtin_type{$type};
	    $category = $type;
@


1.1.1.7
log
@perl 5.8.8 import
@
text
@d3 1
a3 1
$VERSION = '1.02_02';
a253 1
binmode WARN;
a254 1
binmode PM;
d257 1
a257 2
/* -*- buffer-read-only: t -*-
   !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
d324 2
a325 2
#define isWARN_on(c,x)	(IsSet(SvPVX_const(c), 2*(x)))
#define isWARNf_on(c,x)	(IsSet(SvPVX_const(c), 2*(x)+1))
d327 60
a386 14
#define ckWARN(w)		Perl_ckwarn(aTHX_ packWARN(w))
#define ckWARN2(w1,w2)		Perl_ckwarn(aTHX_ packWARN2(w1,w2))
#define ckWARN3(w1,w2,w3)	Perl_ckwarn(aTHX_ packWARN3(w1,w2,w3))
#define ckWARN4(w1,w2,w3,w4)	Perl_ckwarn(aTHX_ packWARN4(w1,w2,w3,w4))

#define ckWARN_d(w)		Perl_ckwarn_d(aTHX_ packWARN(w))
#define ckWARN2_d(w1,w2)	Perl_ckwarn_d(aTHX_ packWARN2(w1,w2))
#define ckWARN3_d(w1,w2,w3)	Perl_ckwarn_d(aTHX_ packWARN3(w1,w2,w3))
#define ckWARN4_d(w1,w2,w3,w4)	Perl_ckwarn_d(aTHX_ packWARN4(w1,w2,w3,w4))

#define packWARN(a)		(a                                      )
#define packWARN2(a,b)		((a) | ((b)<<8)                         )
#define packWARN3(a,b,c)	((a) | ((b)<<8) | ((c)<<16)             )
#define packWARN4(a,b,c,d)	((a) | ((b)<<8) | ((c)<<16) | ((d) <<24))
d402 1
a402 1
/* ex: set ro: */
a464 1
print PM "# ex: set ro:\n";
d468 1
a468 1
# -*- buffer-read-only: t -*-
d476 1
a476 1
our $VERSION = '1.05';
a608 1
    local $Carp::CarpInternal{'warnings'};
@


1.1.1.8
log
@import perl 5.10.0 from CPAN
@
text
@d52 1
a64 1

d278 3
a280 3
#define pWARN_STD		NULL
#define pWARN_ALL		(((STRLEN*)0)+1)    /* use warnings 'all' */
#define pWARN_NONE		(((STRLEN*)0)+2)    /* no  warnings 'all' */
a283 3

/* if PL_warnhook is set to this value, then warnings die */
#define PERL_WARNHOOK_FATAL	(&PL_sv_placeholder)
d318 3
d327 2
a328 7
#define isWARN_on(c,x)	(IsSet((U8 *)(c + 1), 2*(x)))
#define isWARNf_on(c,x)	(IsSet((U8 *)(c + 1), 2*(x)+1))

#define DUP_WARNINGS(p)		\
    (specialWARN(p) ? (STRLEN*)(p)	\
    : (STRLEN*)CopyD(p, PerlMemShared_malloc(sizeof(*p)+*p), sizeof(*p)+*p, \
		     			     char))
d434 1
a434 8
our $VERSION = '1.06';

# Verify that we're called correctly so that warnings will work.
# see also strict.pm.
unless ( __FILE__ =~ /(^|[\/\\])\Q${\__PACKAGE__}\E\.pmc?$/ ) {
    my (undef, $f, $l) = caller;
    die("Incorrect use of pragma '${\__PACKAGE__}' at $f line $l.\n");
}
d559 2
a566 1
    require Carp::Heavy; # this initializes %CarpInternal
d709 5
a713 1
        $i = _error_loc(); # see where Carp will allocate the error
a719 5
sub _error_loc {
    require Carp::Heavy;
    goto &Carp::short_error_loc; # don't introduce another stack frame
}                                                             

a739 1
    require Carp;
a758 1
    require Carp;
@


1.1.1.9
log
@import perl 5.10.1
@
text
@a1 13
# 
# Regenerate (overwriting only if changed):
#
#    lib/warnings.pm
#    warnings.h
#
# from information hardcoded into this script (the $tree hash), plus the
# template for warnings.pm in the DATA section.
#
# With an argument of 'tree', just dump the contents of $tree and exits.
# Also accepts the standard regen_lib -q and -v args.
#
# This script is normally invoked from regen.pl.
d6 1
a6 2
    require 'regen_lib.pl';
    push @@INC, './lib';
d251 6
a256 2
my $warn = safer_open("warnings.h-new");
my $pm = safer_open("lib/warnings.pm-new");
d258 1
a258 1
print $warn <<'EOM' ;
d310 1
a310 1
    print $warn "\n/* Warnings Categories added in Perl $version */\n\n"
d312 1
a312 1
    print $warn tab(5, "#define WARN_$name"), "$k\n" ;
d315 1
a315 1
print $warn "\n" ;
d317 1
a317 1
print $warn tab(5, '#define WARNsize'),	"$warn_size\n" ;
d319 2
a320 2
print $warn tab(5, '#define WARN_ALLstring'), '"', ('\125' x $warn_size) , "\"\n" ;
print $warn tab(5, '#define WARN_NONEstring'), '"', ('\0' x $warn_size) , "\"\n" ;
d322 1
a322 1
print $warn <<'EOM';
d367 1
a367 2
safer_close $warn;
rename_if_different("warnings.h-new", "warnings.h");
d371 1
a371 1
    print $pm $_ ;
d377 1
a377 1
print $pm "our %Offsets = (\n" ;
d383 3
a385 3
        print $pm "\n";
        print $pm tab(4, "    # Warnings Categories added in Perl $version");
        print $pm "\n\n";
d387 1
a387 1
    print $pm tab(4, "    '$name'"), "=> $k,\n" ;
d391 1
a391 1
print $pm "  );\n\n" ;
d393 1
a393 1
print $pm "our %Bits = (\n" ;
d399 1
a399 1
    print $pm tab(4, "    '$k'"), '=> "',
d405 1
a405 1
print $pm "  );\n\n" ;
d407 1
a407 1
print $pm "our %DeadBits = (\n" ;
d413 1
a413 1
    print $pm tab(4, "    '$k'"), '=> "',
d419 4
a422 4
print $pm "  );\n\n" ;
print $pm '$NONE     = "', ('\0' x $warn_size) , "\";\n" ;
print $pm '$LAST_BIT = ' . "$index ;\n" ;
print $pm '$BYTES    = ' . "$warn_size ;\n" ;
d424 1
a424 1
    print $pm $_ ;
d427 2
a428 3
print $pm "# ex: set ro:\n";
safer_close $pm;
rename_if_different("lib/warnings.pm-new", "lib/warnings.pm");
@


1.1.1.10
log
@Perl 5.12.2 from CPAN
@
text
@d16 1
a16 1
$VERSION = '1.02_03';
a48 1
                                'illegalproto'  => [ 5.011, DEFAULT_OFF],
a77 1
       	'imprecision'	=> [ 5.011, DEFAULT_OFF],
a354 2
#define WARNshift		8

d451 1
a451 1
our $VERSION = '1.09';
a528 21
=item warnings::fatal_enabled()

Return TRUE if the warnings category with the same name as the current
package has been set to FATAL in the calling module.
Otherwise returns FALSE.

=item warnings::fatal_enabled($category)

Return TRUE if the warnings category C<$category> has been set to FATAL in
the calling module.
Otherwise returns FALSE.

=item warnings::fatal_enabled($object)

Use the name of the class for the object reference, C<$object>, as the
warnings category.

Return TRUE if that warnings category has been set to FATAL in the first
scope where the object is used.
Otherwise returns FALSE.

d589 1
a589 1
    require Carp; # this initializes %CarpInternal
d740 1
a740 1
    require Carp;
a755 11
sub fatal_enabled
{
    Croaker("Usage: warnings::fatal_enabled([category])")
  unless @@_ == 1 || @@_ == 0 ;

    my ($callers_bitmask, $offset, $i) = __chk(@@_) ;

    return 0 unless defined $callers_bitmask;
    return vec($callers_bitmask, $offset + 1, 1) ||
           vec($callers_bitmask, $Offsets{'all'} + 1, 1) ;
}
@


