head	1.6;
access;
symbols
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;


1.6
date	2002.10.27.22.25.17;	author millert;	state dead;
branches;
next	1.5;

1.5
date	2001.05.24.18.34.45;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.03.41;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.50.54;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.48.16;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.11.36;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.11.36;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.37.01;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.08.31;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.21.51;	author millert;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@Always check out the latest perl5-porters discussions on these subjects
before embarking on an implementation tour.

Bugs
	remove recursion in regular expression engine
	fix memory leaks during compile failures
	make signal handling safe

Tie Modules
	VecArray		Implement array using vec()
	SubstrArray		Implement array using substr()
	VirtualArray		Implement array using a file
	ShiftSplice		Defines shift et al in terms of splice method

Would be nice to have
	pack "(stuff)*", "(stuff)?", "(stuff)+", "(stuff)4", ...
	contiguous bitfields in pack/unpack
	lexperl
	bundled perl preprocessor/macro facility
	    this would solve many of the syntactic nice-to-haves
	use posix calls internally where possible
	gettimeofday (possibly best left for a module?)
	format BOTTOM
	-i rename file only when successfully changed
	all ARGV input should act like <>
	report HANDLE [formats].
	support in perlmain to rerun debugger
	regression tests using __DIE__ hook
	lexically scoped functions: my sub foo { ... }
		the basic concept is easy and sound,
		the difficulties begin with self-referential
		and mutually referential lexical subs: how to
		declare the subs?
	lexically scoped typeglobs? (lexical I/O handles work now)
        wantlvalue?  more generalized want()/caller()?
	named prototypes: sub foo ($foo, @@bar) { ... } ?
	regression/sanity tests for suidperl
	iterators/lazy evaluation/continuations/first/
	    first_defined/short-circuiting grep/??
	    This is a very thorny and hotly debated subject,
	    tread carefully and do your homework first
	generalise Errno way of extracting cpp symbols and use that in
	    Errno, Fcntl, POSIX (ExtUtils::CppSymbol?)
	the _r-problem: for all the {set,get,end}*() system database
	     calls (and a couple more: readdir, *rand*, crypt, *time,
	     tmpnam) there are in many systems the _r versions
	     to be used in re-entrant (=multithreaded) code
	     Icky things: the _r API is not standardized and
	     the _r-forms require per-thread data to store their state
	cross-compilation support
	    host vs target: compile in the host, get the executable to
	    the target, get the possible input files to the target,
	    execute in the target (and do not assume a UNIXish shell
	    in the target! e.g. no command redirection can be assumed),
	    get possible output files back to to host.  this needs to work
	    both during Configure and during the build.  You cannot assume
	    shared filesystems between the host and the target (you may need
	    e.g. ftp), executing the target executable may involve e.g. rsh
	a way to make << and >> to shift bitvectors instead of numbers

Possible pragmas
	debugger
	optimize (use less qw[memory cpu])

Optimizations
	constant function cache
	switch structures
	foreach(reverse...)
	cache eval tree (unless lexical outer scope used (mark in &compiling?))
	rcatmaybe
	shrink opcode tables via multiple implementations selected in peep
	cache hash value?  (Not a win, according to Guido)
	optimize away @@_ where possible
	tail recursion removal
	"one pass" global destruction
	rewrite regexp parser for better integrated optimization
	LRU cache of regexp: foreach $pat (@@pats) { foo() if /$pat/ }

Vague possibilities
	ref function in list context?
	make tr/// return histogram in list context?
	loop control on do{} et al
	explicit switch statements
	built-in globbing
	compile to real threaded code
	structured types
	autocroak?
	modifiable $1 et al
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@@


1.4
log
@perl-5.6.0 + local changes
@
text
@a49 4
	memory profiler: turn malloc.c:Perl_get_mstats() into
	    an extension (Devel::MProf?) that would return the malloc
	    stats in a nice Perl datastructure (also a simple interface
	    to return just the grand total would be good)
@


1.3
log
@perl5.005_03 (stock)
@
text
@d1 8
d16 2
a17 2
	pack "(stuff)*"
	Contiguous bitfields in pack/unpack
d19 3
a21 2
	Bundled perl preprocessor
	Use posix calls internally where possible
d25 1
a25 1
	All ARGV input should act like <>
a28 1
	reference to compiled regexp
d30 7
a36 1
	lvalue functions
d38 26
a63 3
	Full 64 bit support (i.e. "long long")
	Generalise Errno way of extracting cpp symbols and use that in
	    Errno and Fcntl (ExtUtils::CppSymbol?)
d67 1
a67 1
	optimize (use less memory, CPU)
a71 1
	eval qw() at compile time
d73 1
a73 2
	Set KEEP on constant split
	Cache eval tree (unless lexical outer scope used (mark in &compiling?))
d75 4
a78 3
	Shrink opcode tables via multiple implementations selected in peep
	Cache hash value?  (Not a win, according to Guido)
	Optimize away @@_ where possible
d80 1
a80 2
	Optimize sort by { $a <=> $b }
	Rewrite regexp parser for better integrated optimization
d84 1
a84 1
	ref function in list context
d86 2
a87 2
	Loop control on do{} et al
	Explicit switch statements
d92 1
a92 2
	Modifiable $1 et al

@


1.2
log
@perl 5.004_04
@
text
@d13 1
a13 1
	gettimeofday
a14 1
	-iprefix.
d23 4
a35 1
	foreach (1..1000000)
a49 1
	data prettyprint function?  (or is it, as I suspect, a lib routine?)
a57 1
	substr EXPR,OFFSET,LENGTH,STRING
@


1.1
log
@Initial revision
@
text
@a7 1
	Profiler
a12 1
	const variables
a13 1
	bytecompiler
a14 1
	$obj->can("method") to probe method inheritance
a17 1
	Multiple levels of warning
a18 2
	tie(FILEHANDLE, ...)
	__DATA__
d20 4
a23 2
	make 'r' print return value like gdb 'fini'
	regression tests using __WARN__ and __DIE__ hooks
a40 1
	sfio?
d44 1
a47 1
	Populate %SIG at startup if appropriate
a49 1
	undef wantarray in void context
a51 2
	perl to C translator
	multi-thread scheduling
a54 1
	paren counting in tokener to queue remote expectations
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d8 1
d14 3
a16 1
	gettimeofday (possibly best left for a module?)
d18 2
d22 1
d24 2
d27 2
a28 8
	regression tests using __DIE__ hook
	reference to compiled regexp
	lexically scoped functions: my sub foo { ... }
	lvalue functions
	regression/sanity tests for suidperl
	Full 64 bit support (i.e. "long long")
	Generalise Errno way of extracting cpp symbols and use that in
	    Errno and Fcntl (ExtUtils::CppSymbol?)
d38 1
d46 1
a49 1
	LRU cache of regexp: foreach $pat (@@pats) { foo() if /$pat/ }
d53 2
d56 1
d59 2
d64 1
d67 1
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@a0 8
Always check out the latest perl5-porters discussions on these subjects
before embarking on an implementation tour.

Bugs
	remove recursion in regular expression engine
	fix memory leaks during compile failures
	make signal handling safe

d8 2
a9 2
	pack "(stuff)*", "(stuff)?", "(stuff)+", "(stuff)4", ...
	contiguous bitfields in pack/unpack
d11 2
a12 3
	bundled perl preprocessor/macro facility
	    this would solve many of the syntactic nice-to-haves
	use posix calls internally where possible
d16 1
a16 1
	all ARGV input should act like <>
d20 1
d22 1
a22 7
		the basic concept is easy and sound,
		the difficulties begin with self-referential
		and mutually referential lexical subs: how to
		declare the subs?
	lexically scoped typeglobs? (lexical I/O handles work now)
        wantlvalue?  more generalized want()/caller()?
	named prototypes: sub foo ($foo, @@bar) { ... } ?
d24 3
a26 26
	iterators/lazy evaluation/continuations/first/
	    first_defined/short-circuiting grep/??
	    This is a very thorny and hotly debated subject,
	    tread carefully and do your homework first
	generalise Errno way of extracting cpp symbols and use that in
	    Errno, Fcntl, POSIX (ExtUtils::CppSymbol?)
	the _r-problem: for all the {set,get,end}*() system database
	     calls (and a couple more: readdir, *rand*, crypt, *time,
	     tmpnam) there are in many systems the _r versions
	     to be used in re-entrant (=multithreaded) code
	     Icky things: the _r API is not standardized and
	     the _r-forms require per-thread data to store their state
	memory profiler: turn malloc.c:Perl_get_mstats() into
	    an extension (Devel::MProf?) that would return the malloc
	    stats in a nice Perl datastructure (also a simple interface
	    to return just the grand total would be good)
	cross-compilation support
	    host vs target: compile in the host, get the executable to
	    the target, get the possible input files to the target,
	    execute in the target (and do not assume a UNIXish shell
	    in the target! e.g. no command redirection can be assumed),
	    get possible output files back to to host.  this needs to work
	    both during Configure and during the build.  You cannot assume
	    shared filesystems between the host and the target (you may need
	    e.g. ftp), executing the target executable may involve e.g. rsh
	a way to make << and >> to shift bitvectors instead of numbers
d30 1
a30 1
	optimize (use less qw[memory cpu])
d35 1
d37 2
a38 1
	cache eval tree (unless lexical outer scope used (mark in &compiling?))
d40 3
a42 4
	shrink opcode tables via multiple implementations selected in peep
	cache hash value?  (Not a win, according to Guido)
	optimize away @@_ where possible
	tail recursion removal
d44 2
a45 1
	rewrite regexp parser for better integrated optimization
d49 1
a49 1
	ref function in list context?
d51 2
a52 2
	loop control on do{} et al
	explicit switch statements
d57 2
a58 1
	modifiable $1 et al
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d50 4
@


