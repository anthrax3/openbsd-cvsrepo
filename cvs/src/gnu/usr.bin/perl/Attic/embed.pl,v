head	1.13;
access;
symbols
	OPENBSD_5_3:1.12.0.10
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.8
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.6
	OPENBSD_5_0:1.12.0.4
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.2
	OPENBSD_4_9_BASE:1.12
	PERL_5_12_2:1.1.1.11
	OPENBSD_4_8:1.11.0.4
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.2
	OPENBSD_4_7_BASE:1.11
	PERL_5_10_1:1.1.1.10
	OPENBSD_4_6:1.10.0.6
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.2
	OPENBSD_4_5_BASE:1.10
	PERL_5_10_0:1.1.1.9
	OPENBSD_4_4:1.9.0.10
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.8
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.6
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.4
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9
	PERL_5_8_8:1.1.1.8
	OPENBSD_3_9:1.8.0.8
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.6
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.4
	OPENBSD_3_7_BASE:1.8
	PERL_5_8_6:1.1.1.7
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	PERL_5_8_5:1.1.1.7
	PERL_5_8_3:1.1.1.6
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.13
date	2013.03.25.20.40.44;	author sthen;	state dead;
branches;
next	1.12;

1.12
date	2010.09.24.15.06.40;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2009.10.12.18.24.20;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2008.09.29.17.35.57;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2006.03.28.19.22.57;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2004.08.09.18.08.54;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.20;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.17;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.34.48;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.03.53;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.50.59;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.48.32;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.11.39;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.11.39;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.37.15;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.08.36;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.22.01;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.14.46;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.43.29;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.08.09.17.45.40;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2006.03.28.18.47.26;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2008.09.29.17.18.05;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2009.10.12.18.10.36;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2010.09.24.14.48.33;	author millert;	state Exp;
branches;
next	;


desc
@@


1.13
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@#!/usr/bin/perl -w
# 
# Regenerate (overwriting only if changed):
#
#    embed.h
#    embedvar.h
#    global.sym
#    perlapi.c
#    perlapi.h
#    proto.h
#
# from information stored in
#
#    embed.fnc
#    intrpvar.h
#    perlvars.h
#    pp.sym     (which has been generated by opcode.pl)
#
# plus from the values hardcoded into this script in @@extvars.
#
# Accepts the standard regen_lib -q and -v args.
#
# This script is normally invoked from regen.pl.

require 5.003;	# keep this compatible, an old perl is all we may have before
                # we build the new one

use strict;

BEGIN {
    # Get function prototypes
    require 'regen_lib.pl';
}

my $SPLINT = 0; # Turn true for experimental splint support http://www.splint.org

#
# See database of global and static function prototypes in embed.fnc
# This is used to generate prototype headers under various configurations,
# export symbols lists for different platforms, and macros to provide an
# implicit interpreter context argument.
#

sub do_not_edit ($)
{
    my $file = shift;

    my $years = '1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009';

    $years =~ s/1999,/1999,\n  / if length $years > 40;

    my $warning = <<EOW;
 -*- buffer-read-only: t -*-

   $file

   Copyright (C) $years, by Larry Wall and others

   You may distribute under the terms of either the GNU General Public
   License or the Artistic License, as specified in the README file.

!!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
This file is built by embed.pl from data in embed.fnc, embed.pl,
pp.sym, intrpvar.h, and perlvars.h.
Any changes made here will be lost!

Edit those files and run 'make regen_headers' to effect changes.

EOW

    $warning .= <<EOW if $file eq 'perlapi.c';

Up to the threshold of the door there mounted a flight of twenty-seven
broad stairs, hewn by some unknown art of the same black stone.  This
was the only entrance to the tower; ...

    [p.577 of _The Lord of the Rings_, III/x: "The Voice of Saruman"]


EOW

    if ($file =~ m:\.[ch]$:) {
	$warning =~ s:^: * :gm;
	$warning =~ s: +$::gm;
	$warning =~ s: :/:;
	$warning =~ s:$:/:;
    }
    else {
	$warning =~ s:^:# :gm;
	$warning =~ s: +$::gm;
    }
    $warning;
} # do_not_edit

open IN, "embed.fnc" or die $!;

# walk table providing an array of components in each line to
# subroutine, printing the result
sub walk_table (&@@) {
    my $function = shift;
    my $filename = shift || '-';
    my $leader = shift;
    defined $leader or $leader = do_not_edit ($filename);
    my $trailer = shift;
    my $F;
    if (ref $filename) {	# filehandle
	$F = $filename;
    }
    else {
	# safer_unlink $filename if $filename ne '/dev/null';
	$F = safer_open("$filename-new");
    }
    print $F $leader if $leader;
    seek IN, 0, 0;		# so we may restart
    while (<IN>) {
	chomp;
	next if /^:/;
	while (s|\\$||) {
	    $_ .= <IN>;
	    chomp;
	}
	s/\s+$//;
	my @@args;
	if (/^\s*(#|$)/) {
	    @@args = $_;
	}
	else {
	    @@args = split /\s*\|\s*/, $_;
	}
	my @@outs = &{$function}(@@args);
	print $F @@outs; # $function->(@@args) is not 5.003
    }
    print $F $trailer if $trailer;
    unless (ref $filename) {
	safer_close($F);
	rename_if_different("$filename-new", $filename);
    }
}

sub munge_c_files () {
    my $functions = {};
    unless (@@ARGV) {
	warn "\@@ARGV empty, nothing to do\n";
	return;
    }
    walk_table {
	if (@@_ > 1) {
	    $functions->{$_[2]} = \@@_ if $_[@@_-1] =~ /\.\.\./;
	}
    } '/dev/null', '', '';
    local $^I = '.bak';
    while (<>) {
	s{(\b(\w+)[ \t]*\([ \t]*(?!aTHX))}
	 {
	    my $repl = $1;
	    my $f = $2;
	    if (exists $functions->{$f}) {
		$repl .= "aTHX_ ";
		warn("$ARGV:$.:$`#$repl#$'");
	    }
	    $repl;
	 }eg;
	print;
	close ARGV if eof;	# restart $.
    }
    exit;
}

#munge_c_files();

# generate proto.h
my $wrote_protected = 0;

sub write_protos {
    my $ret = "";
    if (@@_ == 1) {
	my $arg = shift;
	$ret .= "$arg\n";
    }
    else {
	my ($flags,$retval,$plain_func,@@args) = @@_;
	my @@nonnull;
	my $has_context = ( $flags !~ /n/ );
	my $never_returns = ( $flags =~ /r/ );
	my $commented_out = ( $flags =~ /m/ );
	my $binarycompat = ( $flags =~ /b/ );
	my $is_malloc = ( $flags =~ /a/ );
	my $can_ignore = ( $flags !~ /R/ ) && !$is_malloc;
	my @@names_of_nn;
	my $func;

	my $splint_flags = "";
	if ( $SPLINT && !$commented_out ) {
	    $splint_flags .= '/*@@noreturn@@*/ ' if $never_returns;
	    if ($can_ignore && ($retval ne 'void') && ($retval !~ /\*/)) {
		$retval .= " /*\@@alt void\@@*/";
	    }
	}

	if ($flags =~ /s/) {
	    $retval = "STATIC $splint_flags$retval";
	    $func = "S_$plain_func";
	}
	else {
	    $retval = "PERL_CALLCONV $splint_flags$retval";
	    if ($flags =~ /[bp]/) {
		$func = "Perl_$plain_func";
	    } else {
		$func = $plain_func;
	    }
	}
	$ret .= "$retval\t$func(";
	if ( $has_context ) {
	    $ret .= @@args ? "pTHX_ " : "pTHX";
	}
	if (@@args) {
	    my $n;
	    for my $arg ( @@args ) {
		++$n;
		if ( $arg =~ /\*/ && $arg !~ /\b(NN|NULLOK)\b/ ) {
		    warn "$func: $arg needs NN or NULLOK\n";
		    our $unflagged_pointers;
		    ++$unflagged_pointers;
		}
		my $nn = ( $arg =~ s/\s*\bNN\b\s+// );
		push( @@nonnull, $n ) if $nn;

		my $nullok = ( $arg =~ s/\s*\bNULLOK\b\s+// ); # strip NULLOK with no effect

		# Make sure each arg has at least a type and a var name.
		# An arg of "int" is valid C, but want it to be "int foo".
		my $temp_arg = $arg;
		$temp_arg =~ s/\*//g;
		$temp_arg =~ s/\s*\bstruct\b\s*/ /g;
		if ( ($temp_arg ne "...")
		     && ($temp_arg !~ /\w+\s+(\w+)(?:\[\d+\])?\s*$/) ) {
		    warn "$func: $arg ($n) doesn't have a name\n";
		}
		if ( $SPLINT && $nullok && !$commented_out ) {
		    $arg = '/*@@null@@*/ ' . $arg;
		}
		if (defined $1 && $nn && !($commented_out && !$binarycompat)) {
		    push @@names_of_nn, $1;
		}
	    }
	    $ret .= join ", ", @@args;
	}
	else {
	    $ret .= "void" if !$has_context;
	}
	$ret .= ")";
	my @@attrs;
	if ( $flags =~ /r/ ) {
	    push @@attrs, "__attribute__noreturn__";
	}
	if ( $flags =~ /D/ ) {
	    push @@attrs, "__attribute__deprecated__";
	}
	if ( $is_malloc ) {
	    push @@attrs, "__attribute__malloc__";
	}
	if ( !$can_ignore ) {
	    push @@attrs, "__attribute__warn_unused_result__";
	}
	if ( $flags =~ /P/ ) {
	    push @@attrs, "__attribute__pure__";
	}
	if( $flags =~ /f/ ) {
	    my $prefix	= $has_context ? 'pTHX_' : '';
	    my $args	= scalar @@args;
 	    my $pat	= $args - 1;
	    my $macro	= @@nonnull && $nonnull[-1] == $pat  
				? '__attribute__format__'
				: '__attribute__format__null_ok__';
	    push @@attrs, sprintf "%s(__printf__,%s%d,%s%d)", $macro,
				$prefix, $pat, $prefix, $args;
	}
	if ( @@nonnull ) {
	    my @@pos = map { $has_context ? "pTHX_$_" : $_ } @@nonnull;
	    push @@attrs, map { sprintf( "__attribute__nonnull__(%s)", $_ ) } @@pos;
	}
	if ( @@attrs ) {
	    $ret .= "\n";
	    $ret .= join( "\n", map { "\t\t\t$_" } @@attrs );
	}
	$ret .= ";";
	$ret = "/* $ret */" if $commented_out;
	if (@@names_of_nn) {
	    $ret .= "\n#define PERL_ARGS_ASSERT_\U$plain_func\E\t\\\n\t"
		. join '; ', map "assert($_)", @@names_of_nn;
	}
	$ret .= @@attrs ? "\n\n" : "\n";
    }
    $ret;
}

# generates global.sym (API export list)
{
  my %seen;
  sub write_global_sym {
      my $ret = "";
      if (@@_ > 1) {
	  my ($flags,$retval,$func,@@args) = @@_;
	  # If a function is defined twice, for example before and after an
	  # #else, only process the flags on the first instance for global.sym
	  return $ret if $seen{$func}++;
	  if ($flags =~ /[AX]/ && $flags !~ /[xm]/
	      || $flags =~ /b/) { # public API, so export
	      $func = "Perl_$func" if $flags =~ /[pbX]/;
	      $ret = "$func\n";
	  }
      }
      $ret;
  }
}


our $unflagged_pointers;
walk_table(\&write_protos,     "proto.h", undef, "/* ex: set ro: */\n");
warn "$unflagged_pointers pointer arguments to clean up\n" if $unflagged_pointers;
walk_table(\&write_global_sym, "global.sym", undef, "# ex: set ro:\n");

# XXX others that may need adding
#       warnhook
#       hints
#       copline
my @@extvars = qw(sv_undef sv_yes sv_no na dowarn
		 curcop compiling
		 tainting tainted stack_base stack_sp sv_arenaroot
		 no_modify
		 curstash DBsub DBsingle DBassertion debstash
		 rsfp
		 stdingv
		 defgv
		 errgv
		 rsfp_filters
		 perldb
		 diehook
		 dirty
		 perl_destruct_level
		 ppaddr
                );

sub readsyms (\%$) {
    my ($syms, $file) = @@_;
    local (*FILE, $_);
    open(FILE, "< $file")
	or die "embed.pl: Can't open $file: $!\n";
    while (<FILE>) {
	s/[ \t]*#.*//;		# Delete comments.
	if (/^\s*(\S+)\s*$/) {
	    my $sym = $1;
	    warn "duplicate symbol $sym while processing $file line $.\n"
		if exists $$syms{$sym};
	    $$syms{$sym} = 1;
	}
    }
    close(FILE);
}

# Perl_pp_* and Perl_ck_* are in pp.sym
readsyms my %ppsym, 'pp.sym';

sub readvars(\%$$@@) {
    my ($syms, $file,$pre,$keep_pre) = @@_;
    local (*FILE, $_);
    open(FILE, "< $file")
	or die "embed.pl: Can't open $file: $!\n";
    while (<FILE>) {
	s/[ \t]*#.*//;		# Delete comments.
	if (/PERLVARA?I?S?C?\($pre(\w+)/) {
	    my $sym = $1;
	    $sym = $pre . $sym if $keep_pre;
	    warn "duplicate symbol $sym while processing $file line $.\n"
		if exists $$syms{$sym};
	    $$syms{$sym} = $pre || 1;
	}
    }
    close(FILE);
}

my %intrp;
my %globvar;

readvars %intrp,  'intrpvar.h','I';
readvars %globvar, 'perlvars.h','G';

my $sym;

sub undefine ($) {
    my ($sym) = @@_;
    "#undef  $sym\n";
}

sub hide ($$) {
    my ($from, $to) = @@_;
    my $t = int(length($from) / 8);
    "#define $from" . "\t" x ($t < 3 ? 3 - $t : 1) . "$to\n";
}

sub bincompat_var ($$) {
    my ($pfx, $sym) = @@_;
    my $arg = ($pfx eq 'G' ? 'NULL' : 'aTHX');
    undefine("PL_$sym") . hide("PL_$sym", "(*Perl_${pfx}${sym}_ptr($arg))");
}

sub multon ($$$) {
    my ($sym,$pre,$ptr) = @@_;
    hide("PL_$sym", "($ptr$pre$sym)");
}

sub multoff ($$) {
    my ($sym,$pre) = @@_;
    return hide("PL_$pre$sym", "PL_$sym");
}

my $em = safer_open('embed.h-new');

print $em do_not_edit ("embed.h"), <<'END';

/* (Doing namespace management portably in C is really gross.) */

/* By defining PERL_NO_SHORT_NAMES (not done by default) the short forms
 * (like warn instead of Perl_warn) for the API are not defined.
 * Not defining the short forms is a good thing for cleaner embedding. */

#ifndef PERL_NO_SHORT_NAMES

/* Hide global symbols */

#if !defined(PERL_IMPLICIT_CONTEXT)

END

# Try to elimiate lots of repeated
# #ifdef PERL_CORE
# foo
# #endif
# #ifdef PERL_CORE
# bar
# #endif
# by tracking state and merging foo and bar into one block.
my $ifdef_state = '';

walk_table {
    my $ret = "";
    my $new_ifdef_state = '';
    if (@@_ == 1) {
	my $arg = shift;
	$ret .= "$arg\n" if $arg =~ /^#\s*(if|ifn?def|else|endif)\b/;
    }
    else {
	my ($flags,$retval,$func,@@args) = @@_;
	unless ($flags =~ /[om]/) {
	    if ($flags =~ /s/) {
		$ret .= hide($func,"S_$func");
	    }
	    elsif ($flags =~ /p/) {
		$ret .= hide($func,"Perl_$func");
	    }
	}
	if ($ret ne '' && $flags !~ /A/) {
	    if ($flags =~ /E/) {
		$new_ifdef_state
		    = "#if defined(PERL_CORE) || defined(PERL_EXT)\n";
	    }
	    else {
		$new_ifdef_state = "#ifdef PERL_CORE\n";
	    }

	    if ($new_ifdef_state ne $ifdef_state) {
		$ret = $new_ifdef_state . $ret;
	    }
        }
    }
    if ($ifdef_state && $new_ifdef_state ne $ifdef_state) {
	# Close the old one ahead of opening the new one.
	$ret = "#endif\n$ret";
    }
    # Remember the new state.
    $ifdef_state = $new_ifdef_state;
    $ret;
} $em, "";

if ($ifdef_state) {
    print $em "#endif\n";
}

for $sym (sort keys %ppsym) {
    $sym =~ s/^Perl_//;
    print $em hide($sym, "Perl_$sym");
}

print $em <<'END';

#else	/* PERL_IMPLICIT_CONTEXT */

END

my @@az = ('a'..'z');

$ifdef_state = '';
walk_table {
    my $ret = "";
    my $new_ifdef_state = '';
    if (@@_ == 1) {
	my $arg = shift;
	$ret .= "$arg\n" if $arg =~ /^#\s*(if|ifn?def|else|endif)\b/;
    }
    else {
	my ($flags,$retval,$func,@@args) = @@_;
	unless ($flags =~ /[om]/) {
	    my $args = scalar @@args;
	    if ($args and $args[$args-1] =~ /\.\.\./) {
	        # we're out of luck for varargs functions under CPP
	    }
	    elsif ($flags =~ /n/) {
		if ($flags =~ /s/) {
		    $ret .= hide($func,"S_$func");
		}
		elsif ($flags =~ /p/) {
		    $ret .= hide($func,"Perl_$func");
		}
	    }
	    else {
		my $alist = join(",", @@az[0..$args-1]);
		$ret = "#define $func($alist)";
		my $t = int(length($ret) / 8);
		$ret .=  "\t" x ($t < 4 ? 4 - $t : 1);
		if ($flags =~ /s/) {
		    $ret .= "S_$func(aTHX";
		}
		elsif ($flags =~ /p/) {
		    $ret .= "Perl_$func(aTHX";
		}
		$ret .= "_ " if $alist;
		$ret .= $alist . ")\n";
	    }
	}
	unless ($flags =~ /A/) {
	    if ($flags =~ /E/) {
		$new_ifdef_state
		    = "#if defined(PERL_CORE) || defined(PERL_EXT)\n";
	    }
	    else {
		$new_ifdef_state = "#ifdef PERL_CORE\n";
	    }

	    if ($new_ifdef_state ne $ifdef_state) {
		$ret = $new_ifdef_state . $ret;
	    }
        }
    }
    if ($ifdef_state && $new_ifdef_state ne $ifdef_state) {
	# Close the old one ahead of opening the new one.
	$ret = "#endif\n$ret";
    }
    # Remember the new state.
    $ifdef_state = $new_ifdef_state;
    $ret;
} $em, "";

if ($ifdef_state) {
    print $em "#endif\n";
}

for $sym (sort keys %ppsym) {
    $sym =~ s/^Perl_//;
    if ($sym =~ /^ck_/) {
	print $em hide("$sym(a)", "Perl_$sym(aTHX_ a)");
    }
    elsif ($sym =~ /^pp_/) {
	print $em hide("$sym()", "Perl_$sym(aTHX)");
    }
    else {
	warn "Illegal symbol '$sym' in pp.sym";
    }
}

print $em <<'END';

#endif	/* PERL_IMPLICIT_CONTEXT */

#endif	/* #ifndef PERL_NO_SHORT_NAMES */

END

print $em <<'END';

/* Compatibility stubs.  Compile extensions with -DPERL_NOCOMPAT to
   disable them.
 */

#if !defined(PERL_CORE)
#  define sv_setptrobj(rv,ptr,name)	sv_setref_iv(rv,name,PTR2IV(ptr))
#  define sv_setptrref(rv,ptr)		sv_setref_iv(rv,NULL,PTR2IV(ptr))
#endif

#if !defined(PERL_CORE) && !defined(PERL_NOCOMPAT)

/* Compatibility for various misnamed functions.  All functions
   in the API that begin with "perl_" (not "Perl_") take an explicit
   interpreter context pointer.
   The following are not like that, but since they had a "perl_"
   prefix in previous versions, we provide compatibility macros.
 */
#  define perl_atexit(a,b)		call_atexit(a,b)
#  define perl_call_argv(a,b,c)		call_argv(a,b,c)
#  define perl_call_pv(a,b)		call_pv(a,b)
#  define perl_call_method(a,b)		call_method(a,b)
#  define perl_call_sv(a,b)		call_sv(a,b)
#  define perl_eval_sv(a,b)		eval_sv(a,b)
#  define perl_eval_pv(a,b)		eval_pv(a,b)
#  define perl_require_pv(a)		require_pv(a)
#  define perl_get_sv(a,b)		get_sv(a,b)
#  define perl_get_av(a,b)		get_av(a,b)
#  define perl_get_hv(a,b)		get_hv(a,b)
#  define perl_get_cv(a,b)		get_cv(a,b)
#  define perl_init_i18nl10n(a)		init_i18nl10n(a)
#  define perl_init_i18nl14n(a)		init_i18nl14n(a)
#  define perl_new_ctype(a)		new_ctype(a)
#  define perl_new_collate(a)		new_collate(a)
#  define perl_new_numeric(a)		new_numeric(a)

/* varargs functions can't be handled with CPP macros. :-(
   This provides a set of compatibility functions that don't take
   an extra argument but grab the context pointer using the macro
   dTHX.
 */
#if defined(PERL_IMPLICIT_CONTEXT) && !defined(PERL_NO_SHORT_NAMES)
#  define croak				Perl_croak_nocontext
#  define deb				Perl_deb_nocontext
#  define die				Perl_die_nocontext
#  define form				Perl_form_nocontext
#  define load_module			Perl_load_module_nocontext
#  define mess				Perl_mess_nocontext
#  define newSVpvf			Perl_newSVpvf_nocontext
#  define sv_catpvf			Perl_sv_catpvf_nocontext
#  define sv_setpvf			Perl_sv_setpvf_nocontext
#  define warn				Perl_warn_nocontext
#  define warner			Perl_warner_nocontext
#  define sv_catpvf_mg			Perl_sv_catpvf_mg_nocontext
#  define sv_setpvf_mg			Perl_sv_setpvf_mg_nocontext
#endif

#endif /* !defined(PERL_CORE) && !defined(PERL_NOCOMPAT) */

#if !defined(PERL_IMPLICIT_CONTEXT)
/* undefined symbols, point them back at the usual ones */
#  define Perl_croak_nocontext		Perl_croak
#  define Perl_die_nocontext		Perl_die
#  define Perl_deb_nocontext		Perl_deb
#  define Perl_form_nocontext		Perl_form
#  define Perl_load_module_nocontext	Perl_load_module
#  define Perl_mess_nocontext		Perl_mess
#  define Perl_newSVpvf_nocontext	Perl_newSVpvf
#  define Perl_sv_catpvf_nocontext	Perl_sv_catpvf
#  define Perl_sv_setpvf_nocontext	Perl_sv_setpvf
#  define Perl_warn_nocontext		Perl_warn
#  define Perl_warner_nocontext		Perl_warner
#  define Perl_sv_catpvf_mg_nocontext	Perl_sv_catpvf_mg
#  define Perl_sv_setpvf_mg_nocontext	Perl_sv_setpvf_mg
#endif

/* ex: set ro: */
END

safer_close($em);
rename_if_different('embed.h-new', 'embed.h');

$em = safer_open('embedvar.h-new');

print $em do_not_edit ("embedvar.h"), <<'END';

/* (Doing namespace management portably in C is really gross.) */

/*
   The following combinations of MULTIPLICITY and PERL_IMPLICIT_CONTEXT
   are supported:
     1) none
     2) MULTIPLICITY	# supported for compatibility
     3) MULTIPLICITY && PERL_IMPLICIT_CONTEXT

   All other combinations of these flags are errors.

   only #3 is supported directly, while #2 is a special
   case of #3 (supported by redefining vTHX appropriately).
*/

#if defined(MULTIPLICITY)
/* cases 2 and 3 above */

#  if defined(PERL_IMPLICIT_CONTEXT)
#    define vTHX	aTHX
#  else
#    define vTHX	PERL_GET_INTERP
#  endif

END

for $sym (sort keys %intrp) {
    print $em multon($sym,'I','vTHX->');
}

print $em <<'END';

#else	/* !MULTIPLICITY */

/* case 1 above */

END

for $sym (sort keys %intrp) {
    print $em multoff($sym,'I');
}

print $em <<'END';

END

print $em <<'END';

#endif	/* MULTIPLICITY */

#if defined(PERL_GLOBAL_STRUCT)

END

for $sym (sort keys %globvar) {
    print $em multon($sym,   'G','my_vars->');
    print $em multon("G$sym",'', 'my_vars->');
}

print $em <<'END';

#else /* !PERL_GLOBAL_STRUCT */

END

for $sym (sort keys %globvar) {
    print $em multoff($sym,'G');
}

print $em <<'END';

#endif /* PERL_GLOBAL_STRUCT */

#ifdef PERL_POLLUTE		/* disabled by default in 5.6.0 */

END

for $sym (sort @@extvars) {
    print $em hide($sym,"PL_$sym");
}

print $em <<'END';

#endif /* PERL_POLLUTE */

/* ex: set ro: */
END

safer_close($em);
rename_if_different('embedvar.h-new', 'embedvar.h');

my $capi = safer_open('perlapi.c-new');
my $capih = safer_open('perlapi.h-new');

print $capih do_not_edit ("perlapi.h"), <<'EOT';

/* declare accessor functions for Perl variables */
#ifndef __perlapi_h__
#define __perlapi_h__

#if defined (MULTIPLICITY)

START_EXTERN_C

#undef PERLVAR
#undef PERLVARA
#undef PERLVARI
#undef PERLVARIC
#undef PERLVARISC
#define PERLVAR(v,t)	EXTERN_C t* Perl_##v##_ptr(pTHX);
#define PERLVARA(v,n,t)	typedef t PL_##v##_t[n];			\
			EXTERN_C PL_##v##_t* Perl_##v##_ptr(pTHX);
#define PERLVARI(v,t,i)	PERLVAR(v,t)
#define PERLVARIC(v,t,i) PERLVAR(v, const t)
#define PERLVARISC(v,i)	typedef const char PL_##v##_t[sizeof(i)];	\
			EXTERN_C PL_##v##_t* Perl_##v##_ptr(pTHX);

#include "intrpvar.h"
#include "perlvars.h"

#undef PERLVAR
#undef PERLVARA
#undef PERLVARI
#undef PERLVARIC
#undef PERLVARISC

#ifndef PERL_GLOBAL_STRUCT
EXTERN_C Perl_ppaddr_t** Perl_Gppaddr_ptr(pTHX);
EXTERN_C Perl_check_t**  Perl_Gcheck_ptr(pTHX);
EXTERN_C unsigned char** Perl_Gfold_locale_ptr(pTHX);
#define Perl_ppaddr_ptr      Perl_Gppaddr_ptr
#define Perl_check_ptr       Perl_Gcheck_ptr
#define Perl_fold_locale_ptr Perl_Gfold_locale_ptr
#endif

END_EXTERN_C

#if defined(PERL_CORE)

/* accessor functions for Perl variables (provide binary compatibility) */

/* these need to be mentioned here, or most linkers won't put them in
   the perl executable */

#ifndef PERL_NO_FORCE_LINK

START_EXTERN_C

#ifndef DOINIT
EXTCONST void * const PL_force_link_funcs[];
#else
EXTCONST void * const PL_force_link_funcs[] = {
#undef PERLVAR
#undef PERLVARA
#undef PERLVARI
#undef PERLVARIC
#define PERLVAR(v,t)	(void*)Perl_##v##_ptr,
#define PERLVARA(v,n,t)	PERLVAR(v,t)
#define PERLVARI(v,t,i)	PERLVAR(v,t)
#define PERLVARIC(v,t,i) PERLVAR(v,t)
#define PERLVARISC(v,i) PERLVAR(v,char)

/* In Tru64 (__DEC && __osf__) the cc option -std1 causes that one
 * cannot cast between void pointers and function pointers without
 * info level warnings.  The PL_force_link_funcs[] would cause a few
 * hundred of those warnings.  In code one can circumnavigate this by using
 * unions that overlay the different pointers, but in declarations one
 * cannot use this trick.  Therefore we just disable the warning here
 * for the duration of the PL_force_link_funcs[] declaration. */

#if defined(__DECC) && defined(__osf__)
#pragma message save
#pragma message disable (nonstandcast)
#endif

#include "intrpvar.h"
#include "perlvars.h"

#if defined(__DECC) && defined(__osf__)
#pragma message restore
#endif

#undef PERLVAR
#undef PERLVARA
#undef PERLVARI
#undef PERLVARIC
#undef PERLVARISC
};
#endif	/* DOINIT */

END_EXTERN_C

#endif	/* PERL_NO_FORCE_LINK */

#else	/* !PERL_CORE */

EOT

foreach $sym (sort keys %intrp) {
    print $capih bincompat_var('I',$sym);
}

foreach $sym (sort keys %globvar) {
    print $capih bincompat_var('G',$sym);
}

print $capih <<'EOT';

#endif /* !PERL_CORE */
#endif /* MULTIPLICITY */

#endif /* __perlapi_h__ */

/* ex: set ro: */
EOT
safer_close($capih);
rename_if_different('perlapi.h-new', 'perlapi.h');

print $capi do_not_edit ("perlapi.c"), <<'EOT';

#include "EXTERN.h"
#include "perl.h"
#include "perlapi.h"

#if defined (MULTIPLICITY)

/* accessor functions for Perl variables (provides binary compatibility) */
START_EXTERN_C

#undef PERLVAR
#undef PERLVARA
#undef PERLVARI
#undef PERLVARIC
#undef PERLVARISC

#define PERLVAR(v,t)	t* Perl_##v##_ptr(pTHX)				\
			{ dVAR; PERL_UNUSED_CONTEXT; return &(aTHX->v); }
#define PERLVARA(v,n,t)	PL_##v##_t* Perl_##v##_ptr(pTHX)		\
			{ dVAR; PERL_UNUSED_CONTEXT; return &(aTHX->v); }

#define PERLVARI(v,t,i)	PERLVAR(v,t)
#define PERLVARIC(v,t,i) PERLVAR(v, const t)
#define PERLVARISC(v,i)	PL_##v##_t* Perl_##v##_ptr(pTHX)		\
			{ dVAR; PERL_UNUSED_CONTEXT; return &(aTHX->v); }

#include "intrpvar.h"

#undef PERLVAR
#undef PERLVARA
#define PERLVAR(v,t)	t* Perl_##v##_ptr(pTHX)				\
			{ dVAR; PERL_UNUSED_CONTEXT; return &(PL_##v); }
#define PERLVARA(v,n,t)	PL_##v##_t* Perl_##v##_ptr(pTHX)		\
			{ dVAR; PERL_UNUSED_CONTEXT; return &(PL_##v); }
#undef PERLVARIC
#undef PERLVARISC
#define PERLVARIC(v,t,i)	\
			const t* Perl_##v##_ptr(pTHX)		\
			{ PERL_UNUSED_CONTEXT; return (const t *)&(PL_##v); }
#define PERLVARISC(v,i)	PL_##v##_t* Perl_##v##_ptr(pTHX)	\
			{ dVAR; PERL_UNUSED_CONTEXT; return &(PL_##v); }
#include "perlvars.h"

#undef PERLVAR
#undef PERLVARA
#undef PERLVARI
#undef PERLVARIC
#undef PERLVARISC

#ifndef PERL_GLOBAL_STRUCT
/* A few evil special cases.  Could probably macrofy this. */
#undef PL_ppaddr
#undef PL_check
#undef PL_fold_locale
Perl_ppaddr_t** Perl_Gppaddr_ptr(pTHX) {
    static Perl_ppaddr_t* const ppaddr_ptr = PL_ppaddr;
    PERL_UNUSED_CONTEXT;
    return (Perl_ppaddr_t**)&ppaddr_ptr;
}
Perl_check_t**  Perl_Gcheck_ptr(pTHX) {
    static Perl_check_t* const check_ptr  = PL_check;
    PERL_UNUSED_CONTEXT;
    return (Perl_check_t**)&check_ptr;
}
unsigned char** Perl_Gfold_locale_ptr(pTHX) {
    static unsigned char* const fold_locale_ptr = PL_fold_locale;
    PERL_UNUSED_CONTEXT;
    return (unsigned char**)&fold_locale_ptr;
}
#endif

END_EXTERN_C

#endif /* MULTIPLICITY */

/* ex: set ro: */
EOT

safer_close($capi);
rename_if_different('perlapi.c-new', 'perlapi.c');

# functions that take va_list* for implementing vararg functions
# NOTE: makedef.pl must be updated if you add symbols to %vfuncs
# XXX %vfuncs currently unused
my %vfuncs = qw(
    Perl_croak			Perl_vcroak
    Perl_warn			Perl_vwarn
    Perl_warner			Perl_vwarner
    Perl_die			Perl_vdie
    Perl_form			Perl_vform
    Perl_load_module		Perl_vload_module
    Perl_mess			Perl_vmess
    Perl_deb			Perl_vdeb
    Perl_newSVpvf		Perl_vnewSVpvf
    Perl_sv_setpvf		Perl_sv_vsetpvf
    Perl_sv_setpvf_mg		Perl_sv_vsetpvf_mg
    Perl_sv_catpvf		Perl_sv_vcatpvf
    Perl_sv_catpvf_mg		Perl_sv_vcatpvf_mg
    Perl_dump_indent		Perl_dump_vindent
    Perl_default_protect	Perl_vdefault_protect
);

# ex: set ts=8 sts=4 sw=4 noet:
@


1.12
log
@merge in perl 5.12.2 plus local changes
@
text
@@


1.11
log
@Merge in perl 5.10.1
@
text
@d256 3
@


1.10
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d2 22
d48 1
a48 1
    my $years = '1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007';
d75 3
a77 1
was the only entrance to the tower.
a105 1
    local *F;
d110 2
a111 4
	safer_unlink $filename if $filename ne '/dev/null';
	open F, ">$filename" or die "Can't open $filename: $!";
	binmode F;
	$F = \*F;
d135 2
a136 1
	close $F or die "Error closing $filename: $!";
d181 1
a181 1
	my ($flags,$retval,$func,@@args) = @@_;
d186 1
d189 2
d202 1
a202 1
	    $func = "S_$func";
d207 3
a209 1
		$func = "Perl_$func";
d235 3
a237 2
		if ( ($temp_arg ne "...") && ($temp_arg !~ /\w+\s+\w+/) ) {
		    warn "$func: $arg doesn't have a name\n";
d242 3
d285 4
d414 1
a414 3
safer_unlink 'embed.h';
open(EM, '> embed.h') or die "Can't create embed.h: $!\n";
binmode EM;
d416 1
a416 1
print EM do_not_edit ("embed.h"), <<'END';
d480 1
a480 1
} \*EM, "";
d483 1
a483 1
    print EM "#endif\n";
d488 1
a488 1
    print EM hide($sym, "Perl_$sym");
d491 1
a491 1
print EM <<'END';
d558 1
a558 1
} \*EM, "";
d561 1
a561 1
    print EM "#endif\n";
d567 1
a567 1
	print EM hide("$sym(a)", "Perl_$sym(aTHX_ a)");
d570 1
a570 1
	print EM hide("$sym()", "Perl_$sym(aTHX)");
d577 1
a577 1
print EM <<'END';
d585 1
a585 1
print EM <<'END';
d665 2
a666 1
close(EM) or die "Error closing EM: $!";
d668 1
a668 4
safer_unlink 'embedvar.h';
open(EM, '> embedvar.h')
    or die "Can't create embedvar.h: $!\n";
binmode EM;
d670 1
a670 1
print EM do_not_edit ("embedvar.h"), <<'END';
d699 1
a699 1
    print EM multon($sym,'I','vTHX->');
d702 1
a702 1
print EM <<'END';
d711 1
a711 1
    print EM multoff($sym,'I');
d714 1
a714 1
print EM <<'END';
d718 1
a718 1
print EM <<'END';
d727 2
a728 2
    print EM multon($sym,   'G','my_vars->');
    print EM multon("G$sym",'', 'my_vars->');
d731 1
a731 1
print EM <<'END';
d738 1
a738 1
    print EM multoff($sym,'G');
d741 1
a741 1
print EM <<'END';
d750 1
a750 1
    print EM hide($sym,"PL_$sym");
d753 1
a753 1
print EM <<'END';
d760 2
a761 1
close(EM) or die "Error closing EM: $!";
d763 2
a764 6
safer_unlink 'perlapi.h';
safer_unlink 'perlapi.c';
open(CAPI, '> perlapi.c') or die "Can't create perlapi.c: $!\n";
binmode CAPI;
open(CAPIH, '> perlapi.h') or die "Can't create perlapi.h: $!\n";
binmode CAPIH;
d766 1
a766 1
print CAPIH do_not_edit ("perlapi.h"), <<'EOT';
d871 1
a871 1
    print CAPIH bincompat_var('I',$sym);
d875 1
a875 1
    print CAPIH bincompat_var('G',$sym);
d878 1
a878 1
print CAPIH <<'EOT';
d887 2
a888 1
close CAPIH or die "Error closing CAPIH: $!";
d890 1
a890 1
print CAPI do_not_edit ("perlapi.c"), <<'EOT';
d969 2
a970 1
close(CAPI) or die "Error closing CAPI: $!";
@


1.9
log
@merge in perl 5.8.8
@
text
@d6 2
d13 2
d26 1
a26 1
    my $years = '1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006';
d42 1
a42 1
pp.sym, intrpvar.h, perlvars.h and thrdvar.h.
a130 20
#	if (/^#\s*include\s+"perl.h"/) {
#	    my $file = uc $ARGV;
#	    $file =~ s/\./_/g;
#	    print "#define PERL_IN_$file\n";
#	}
#	s{^(\w+)\s*\(}
#	 {
#	    my $f = $1;
#	    my $repl = "$f(";
#	    if (exists $functions->{$f}) {
#		my $flags = $functions->{$f}[0];
#		$repl = "Perl_$repl" if $flags =~ /p/;
#		unless ($flags =~ /n/) {
#		    $repl .= "pTHX";
#		    $repl .= "_ " if @@{$functions->{$f}} > 3;
#		}
#		warn("$ARGV:$.:$repl\n");
#	    }
#	    $repl;
#	 }e;
d162 13
a174 1
	$ret .= '/* ' if $flags =~ /m/;
d176 1
a176 1
	    $retval = "STATIC $retval";
d180 2
a181 2
	    $retval = "PERL_CALLCONV $retval";
	    if ($flags =~ /p/) {
d198 4
a201 5
		# Given the bugs fixed by changes 25822 and 26253, for now
		# strip NN with no effect, until I'm confident that there are
		# no similar bugs lurking.
		# push( @@nonnull, $n ) if ( $arg =~ s/\s*\bNN\b\s+// );
		$arg =~ s/\s*\bNN\b\s+//;
d203 11
a213 1
		$arg =~ s/\s*\bNULLOK\b\s+//; # strip NULLOK with no effect
d225 1
a225 1
	if ( $flags =~ /a/ ) {
a226 1
	    $flags .= "R"; # All allocing must check return value
d228 1
a228 1
	if ( $flags =~ /R/ ) {
d235 8
a242 4
	    my $prefix = $has_context ? 'pTHX_' : '';
	    my $args = scalar @@args;
	    push @@attrs, sprintf "__attribute__format__(__printf__,%s%d,%s%d)",
				    $prefix, $args - 1, $prefix, $args;
d253 1
a253 1
	$ret .= ' */' if $flags =~ /m/;
d259 18
a276 12
# generates global.sym (API export list), and populates %global with global symbols
sub write_global_sym {
    my $ret = "";
    if (@@_ > 1) {
	my ($flags,$retval,$func,@@args) = @@_;
	if ($flags =~ /[AX]/ && $flags !~ /[xm]/
	    || $flags =~ /b/) { # public API, so export
	    $func = "Perl_$func" if $flags =~ /[pbX]/;
	    $ret = "$func\n";
	}
    }
    $ret;
d279 1
d293 1
a293 1
		 curstash DBsub DBsingle debstash
d315 1
a315 1
	    warn "duplicate symbol $sym while processing $file\n"
d333 1
a333 1
	if (/PERLVARA?I?C?\($pre(\w+)/) {
d336 1
a336 1
	    warn "duplicate symbol $sym while processing $file\n"
d345 1
a345 1
my %thread;
a347 1
readvars %thread, 'thrdvar.h','T';
a350 3
foreach $sym (sort keys %thread) {
  warn "$sym in intrpvar.h as well as thrdvar.h\n" if exists $intrp{$sym};
}
d560 1
a560 1
#  define sv_setptrref(rv,ptr)		sv_setref_iv(rv,Nullch,PTR2IV(ptr))
d644 2
a645 2
   The following combinations of MULTIPLICITY, USE_5005THREADS
   and PERL_IMPLICIT_CONTEXT are supported:
a648 2
     4) USE_5005THREADS && PERL_IMPLICIT_CONTEXT
     5) MULTIPLICITY && USE_5005THREADS && PERL_IMPLICIT_CONTEXT
d652 1
a652 1
   #3, #4, #5, and #6 are supported directly, while #2 is a special
d657 1
a657 1
/* cases 2, 3 and 5 above */
a666 22
for $sym (sort keys %thread) {
    print EM multon($sym,'T','vTHX->');
}

print EM <<'END';

#  if defined(USE_5005THREADS)
/* case 5 above */

END

for $sym (sort keys %intrp) {
    print EM multon($sym,'I','PERL_GET_INTERP->');
}

print EM <<'END';

#  else		/* !USE_5005THREADS */
/* cases 2 and 3 above */

END

a672 2
#  endif	/* USE_5005THREADS */

d675 1
a675 1
/* cases 1 and 4 above */
a684 3
#  if defined(USE_5005THREADS)
/* case 4 above */

a686 4
for $sym (sort keys %thread) {
    print EM multon($sym,'T','aTHX->');
}

a688 12
#  else	/* !USE_5005THREADS */
/* case 1 above */

END

for $sym (sort keys %thread) {
    print EM multoff($sym,'T');
}

print EM <<'END';

#  endif	/* USE_5005THREADS */
d696 2
a697 1
    print EM multon($sym,'G','PL_Vars.');
d752 1
d758 2
a760 1
#include "thrdvar.h"
d768 10
d793 1
a793 1
EXT void *PL_force_link_funcs[];
d795 1
a795 1
EXT void *PL_force_link_funcs[] = {
d804 1
a818 1
#include "thrdvar.h"
d830 1
a845 4
foreach $sym (sort keys %thread) {
    print CAPIH bincompat_var('T',$sym);
}

d876 1
d879 1
a879 1
			{ return &(aTHX->v); }
d881 1
a881 1
			{ return &(aTHX->v); }
d885 2
a887 1
#include "thrdvar.h"
d893 1
a893 1
			{ return &(PL_##v); }
d895 1
a895 1
			{ return &(PL_##v); }
d897 6
a902 2
#define PERLVARIC(v,t,i)	const t* Perl_##v##_ptr(pTHX)		\
			{ return (const t *)&(PL_##v); }
d909 23
@


1.8
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@a20 2
    
    my $years;
d22 1
a22 13
    if ($file eq 'embed.h') {
        $years = '1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004';
    } elsif ($file eq 'embedvar.h') {
        $years = '1999, 2000, 2001, 2002, 2003, 2004';
    } elsif ($file eq 'global.sym') {
        $years = '1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004';
    } elsif ($file eq 'perlapi.c') {
        $years = '1999, 2000, 2001';
    } elsif ($file eq 'perlapi.h') {
        $years = '1999, 2000, 2001, 2002, 2003, 2004';
    } elsif ($file eq 'proto.h') {
        $years = '1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004';
    }
d27 1
d83 1
a83 1
	safer_unlink $filename;
d85 1
d97 1
d105 2
a106 2
        my @@outs = &{$function}(@@args);
        print $F @@outs; # $function->(@@args) is not 5.003
d117 1
a117 1
        warn "\@@ARGV empty, nothing to do\n";
d124 1
a124 1
    } '/dev/null', '';
d176 2
d190 2
a191 3
	unless ($flags =~ /n/) {
	    $ret .= "pTHX";
	    $ret .= "_ " if @@args;
d194 16
d213 1
a213 1
	    $ret .= "void" if $flags =~ /n/;
d216 14
a229 1
	$ret .= " __attribute__((noreturn))" if $flags =~ /r/;
d231 1
a231 1
	    my $prefix = $flags =~ /n/ ? '' : 'pTHX_';
d233 1
a233 1
	    $ret .= sprintf "\n\t__attribute__format__(__printf__,%s%d,%s%d)",
d236 8
d246 1
a246 1
	$ret .= "\n";
d265 4
a268 2
walk_table(\&write_protos,     "proto.h", undef);
walk_table(\&write_global_sym, "global.sym", undef);
d275 2
a276 2
                 curcop compiling
                 tainting tainted stack_base stack_sp sv_arenaroot
d278 3
a280 3
                 curstash DBsub DBsingle debstash
                 rsfp
                 stdingv
d370 1
d388 10
d400 1
d417 9
a425 3
		$ret = "#if defined(PERL_CORE) || defined(PERL_EXT)\n$ret#endif\n";
	    } else {
		$ret = "#ifdef PERL_CORE\n$ret#endif\n";
d429 6
d438 4
d455 1
d458 1
d493 1
a493 1
         unless ($flags =~ /A/) {
d495 9
a503 3
		$ret = "#if defined(PERL_CORE) || defined(PERL_EXT)\n$ret#endif\n";
	    } else {
		$ret = "#ifdef PERL_CORE\n$ret#endif\n";
d507 6
d516 4
d618 1
d626 1
d758 2
d767 1
d769 1
d826 13
d843 4
d881 1
d931 2
d957 2
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d25 1
a25 1
        $years = '1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003';
d27 1
a27 1
        $years = '1999, 2000, 2001, 2002, 2003';
d29 1
a29 1
        $years = '1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003';
d33 1
a33 1
        $years = '1999, 2000, 2001, 2002, 2003';
d35 1
a35 1
        $years = '1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003';
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d6 5
d18 62
d88 1
d96 1
a96 1
	unlink $filename;
d120 3
a122 1
    close $F unless ref $filename;
d135 1
a135 1
    } '/dev/null';
d214 1
a214 2
	    $ret .= "\n#ifdef CHECK_FORMAT\n";
	    $ret .= sprintf " __attribute__((format(printf,%s%d,%s%d)))",
a215 1
	    $ret .= "\n#endif\n";
d229 3
a231 2
	if ($flags =~ /A/ && $flags !~ /[xm]/) { # public API, so export
	    $func = "Perl_$func" if $flags =~ /p/;
d238 2
a239 32

walk_table(\&write_protos, 'proto.h', <<'EOT');
/*
 *    proto.h
 *
 *    Copyright (c) 1997-2002, Larry Wall
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 * !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
 * This file is autogenerated from data in embed.pl.  Edit that file
 * and run 'make regen_headers' to effect changes.
 */

EOT

walk_table(\&write_global_sym, 'global.sym', <<'EOT');
#
#    global.sym
#
#    Copyright (c) 1997-2002, Larry Wall
#
#    You may distribute under the terms of either the GNU General Public
#    License or the Artistic License, as specified in the README file.
#
# !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
# This file is autogenerated from data in embed.pl.  Edit that file
# and run 'make regen_headers' to effect changes.
#

EOT
d339 1
a339 1
unlink 'embed.h';
d342 1
a342 13
print EM <<'END';
/*
 *    embed.h
 *
 *    Copyright (c) 1997-2002, Larry Wall
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 *  !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
 *  This file is built by embed.pl from data in embed.pl, pp.sym, intrpvar.h,
 *  perlvars.h and thrdvar.h.  Any changes made here will be lost!
 */
d346 5
a350 1
/* NO_EMBED is no longer supported. i.e. EMBED is always active. */
d374 7
d383 1
a383 1
} \*EM;
d434 7
d443 1
a443 1
} \*EM;
d462 2
d508 1
a508 1
#if defined(PERL_IMPLICIT_CONTEXT)
d545 1
a545 1
close(EM);
d547 1
a547 1
unlink 'embedvar.h';
d551 1
a551 14
print EM <<'END';
/*
 *    embedvar.h
 *
 *    Copyright (c) 1997-2002, Larry Wall
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 *
 * !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
 *  This file is built by embed.pl from data in embed.pl, pp.sym, intrpvar.h,
 *  perlvars.h and thrdvar.h.  Any changes made here will be lost!
 */
d683 1
a683 1
close(EM);
d685 2
a686 2
unlink 'perlapi.h';
unlink 'perlapi.c';
d690 1
a690 14
print CAPIH <<'EOT';
/*
 *    perlapi.h
 *
 *    Copyright (c) 1997-2002, Larry Wall
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 *
 * !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
 *  This file is built by embed.pl from data in embed.pl, pp.sym, intrpvar.h,
 *  perlvars.h and thrdvar.h.  Any changes made here will be lost!
 */
d784 1
a784 1
close CAPIH;
d786 1
a786 14
print CAPI <<'EOT';
/*
 *    perlapi.c
 *
 *    Copyright (c) 1997-2002, Larry Wall
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 *
 * !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
 *  This file is built by embed.pl from data in embed.pl, pp.sym, intrpvar.h,
 *  perlvars.h and thrdvar.h.  Any changes made here will be lost!
 */
d834 1
a834 1
close(CAPI);
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d7 1
a7 1
# See database of global and static function prototypes at the __END__.
d13 1
a13 1
my $END = tell DATA;
d33 2
a34 2
    seek DATA, $END, 0;		# so we may restart
    while (<DATA>) {
d38 1
a38 1
	    $_ .= <DATA>;
d48 2
a49 1
	print $F $function->(@@args);
d117 1
d141 1
a141 1
	if( $flags =~ /f/ ) { 
d143 1
a143 1
	    my $args = scalar @@args; 
d146 1
a146 1
				    $prefix, $args - 1, $prefix, $args; 
d149 3
a151 1
	$ret .= ";\n";
d161 1
a161 1
	if ($flags =~ /A/ && $flags !~ /x/) { # public API, so export
d172 7
d188 7
d207 1
a207 1
                 curcop compiling 
d211 1
a211 1
                 rsfp 
d268 2
a269 1
foreach my $sym (sort keys %thread) {
d286 1
a286 1
    my $arg = ($pfx eq 'G' ? 'NULL' : 'aTHXo');
d304 12
a315 4
/* !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!! 
   This file is built by embed.pl from data in embed.pl, pp.sym, intrpvar.h,
   perlvars.h and thrdvar.h.  Any changes made here will be lost!
*/
a320 36
/* provide binary compatible (but inconsistent) names */
#if defined(PERL_BINCOMPAT_5005)
#  define  Perl_call_atexit		perl_atexit
#  define  Perl_eval_sv			perl_eval_sv
#  define  Perl_eval_pv			perl_eval_pv
#  define  Perl_call_argv		perl_call_argv
#  define  Perl_call_method		perl_call_method
#  define  Perl_call_pv			perl_call_pv
#  define  Perl_call_sv			perl_call_sv
#  define  Perl_get_av			perl_get_av
#  define  Perl_get_cv			perl_get_cv
#  define  Perl_get_hv			perl_get_hv
#  define  Perl_get_sv			perl_get_sv
#  define  Perl_init_i18nl10n		perl_init_i18nl10n
#  define  Perl_init_i18nl14n		perl_init_i18nl14n
#  define  Perl_new_collate		perl_new_collate
#  define  Perl_new_ctype		perl_new_ctype
#  define  Perl_new_numeric		perl_new_numeric
#  define  Perl_require_pv		perl_require_pv
#  define  Perl_safesyscalloc		Perl_safecalloc
#  define  Perl_safesysfree		Perl_safefree
#  define  Perl_safesysmalloc		Perl_safemalloc
#  define  Perl_safesysrealloc		Perl_saferealloc
#  define  Perl_set_numeric_local	perl_set_numeric_local
#  define  Perl_set_numeric_standard	perl_set_numeric_standard
/* malloc() pollution was the default in earlier versions, so enable
 * it for bincompat; but not for systems that used to do prevent that,
 * or when they ask for {HIDE,EMBED}MYMALLOC */
#  if !defined(EMBEDMYMALLOC) && !defined(HIDEMYMALLOC)
#    if !defined(NeXT) && !defined(__NeXT) && !defined(__MACHTEN__) && \
        !defined(__QNX__)
#      define  PERL_POLLUTE_MALLOC
#    endif
#  endif
#endif

a322 1
#if !defined(PERL_OBJECT)
d335 1
a335 1
	unless ($flags =~ /o/) {
d368 1
a368 1
	unless ($flags =~ /o/) {
a415 1
#else	/* PERL_OBJECT */
a418 29
walk_table {
    my $ret = "";
    if (@@_ == 1) {
	my $arg = shift;
	$ret .= "$arg\n" if $arg =~ /^#\s*(if|ifn?def|else|endif)\b/;
    }
    else {
	my ($flags,$retval,$func,@@args) = @@_;
	if ($flags =~ /s/) {
	    $ret .= hide("S_$func","CPerlObj::S_$func") if $flags !~ /j/;
	    $ret .= hide($func,"S_$func");
	}
	elsif ($flags =~ /p/) {
	    $ret .= hide("Perl_$func","CPerlObj::Perl_$func") if $flags !~ /j/;
	    $ret .= hide($func,"Perl_$func");
	}
	else {
	    $ret .= hide($func,"CPerlObj::$func") if $flags !~ /j/;
	}
    }
    $ret;
} \*EM;

for $sym (sort keys %ppsym) {
    $sym =~ s/^Perl_//;
    print EM hide("Perl_$sym", "CPerlObj::Perl_$sym");
    print EM hide($sym, "Perl_$sym");
}

a420 2
#endif	/* PERL_OBJECT */

d430 1
a430 1
#if !defined(PERL_CORE) && !defined(PERL_NOCOMPAT) && !defined(PERL_BINCOMPAT_5005)
d461 1
a461 1
#if defined(PERL_IMPLICIT_CONTEXT) && !defined(PERL_OBJECT)
d505 13
a517 4
/* !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!! 
   This file is built by embed.pl from data in embed.pl, pp.sym, intrpvar.h,
   perlvars.h and thrdvar.h.  Any changes made here will be lost!
*/
d522 1
a522 1
   The following combinations of MULTIPLICITY, USE_THREADS, PERL_OBJECT
d527 2
a528 3
     4) USE_THREADS && PERL_IMPLICIT_CONTEXT
     5) MULTIPLICITY && USE_THREADS && PERL_IMPLICIT_CONTEXT
     6) PERL_OBJECT && PERL_IMPLICIT_CONTEXT
d553 1
a553 5
#  if defined(PERL_OBJECT)
#    include "error: PERL_OBJECT + MULTIPLICITY don't go together"
#  endif

#  if defined(USE_THREADS)
d564 1
a564 1
#  else		/* !USE_THREADS */
d575 1
a575 1
#  endif	/* USE_THREADS */
a578 18
#  if defined(PERL_OBJECT)
/* case 6 above */

END

for $sym (sort keys %thread) {
    print EM multon($sym,'T','aTHXo->interp.');
}


for $sym (sort keys %intrp) {
    print EM multon($sym,'I','aTHXo->interp.');
}

print EM <<'END';

#  else	/* !PERL_OBJECT */

d589 1
a589 1
#    if defined(USE_THREADS)
d600 1
a600 1
#    else	/* !USE_THREADS */
d611 1
a611 2
#    endif	/* USE_THREADS */
#  endif	/* PERL_OBJECT */
a650 57
unlink 'objXSUB.h';
open(OBX, '> objXSUB.h')
    or die "Can't create objXSUB.h: $!\n";

print OBX <<'EOT';
/* !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!! 
   This file is built by embed.pl from data in embed.pl, pp.sym, intrpvar.h,
   perlvars.h and thrdvar.h.  Any changes made here will be lost!
*/

#ifndef __objXSUB_h__
#define __objXSUB_h__

/* method calls via pPerl (static functions without a "this" pointer need these) */

#if defined(PERL_CORE) && defined(PERL_OBJECT)

/* XXX soon to be eliminated, only a few things in PERLCORE need these now */

EOT

walk_table {
    my $ret = "";
    if (@@_ == 1) {
	my $arg = shift;
	$ret .= "$arg\n" if $arg =~ /^#\s*(if|ifn?def|else|endif)\b/;
    }
    else {
	my ($flags,$retval,$func,@@args) = @@_;
	if ($flags =~ /A/ && $flags !~ /j/) { # API function needing macros
	    if ($flags =~ /p/) {
		$ret .= undefine("Perl_$func") . hide("Perl_$func","pPerl->Perl_$func");
		$ret .= undefine($func) . hide($func,"Perl_$func");
	    }
	    else {
		$ret .= undefine($func) . hide($func,"pPerl->$func");
	    }
	}
    }
    $ret;
} \*OBX;

# NOTE: not part of API
#for $sym (sort keys %ppsym) {
#    $sym =~ s/^Perl_//;
#    print OBX undefine("Perl_$sym") . hide("Perl_$sym", "pPerl->Perl_$sym");
#    print OBX undefine($sym) . hide($sym, "Perl_$sym");
#}

print OBX <<'EOT';

#endif  /* PERL_CORE && PERL_OBJECT */
#endif	/* __objXSUB_h__ */
EOT

close(OBX);

d657 13
a669 4
/* !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!! 
   This file is built by embed.pl from data in embed.pl, pp.sym, intrpvar.h,
   perlvars.h and thrdvar.h.  Any changes made here will be lost!
*/
d675 1
a675 8
#if defined(PERL_OBJECT) || defined (MULTIPLICITY)

#if defined(PERL_OBJECT)
#  undef  aTHXo
#  define aTHXo			pPerl
#  undef  aTHXo_
#  define aTHXo_		aTHXo,
#endif /* PERL_OBJECT */
d683 1
a683 1
#define PERLVAR(v,t)	EXTERN_C t* Perl_##v##_ptr(pTHXo);
d685 1
a685 1
			EXTERN_C PL_##v##_t* Perl_##v##_ptr(pTHXo);
d735 1
a735 1
START_EXTERN_C
d743 1
a743 1
foreach my $sym (sort keys %intrp) {
d747 1
a747 1
foreach my $sym (sort keys %thread) {
d751 1
a751 1
foreach my $sym (sort keys %globvar) {
d758 1
a758 1
#endif /* PERL_OBJECT || MULTIPLICITY */
d766 13
a778 4
/* !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!! 
   This file is built by embed.pl from data in embed.pl, pp.sym, intrpvar.h,
   perlvars.h and thrdvar.h.  Any changes made here will be lost!
*/
d784 1
a784 1
#if defined(PERL_OBJECT) || defined (MULTIPLICITY)
a793 6
#if defined(PERL_OBJECT)
#define PERLVAR(v,t)	t* Perl_##v##_ptr(pTHXo)			\
			{ return &(aTHXo->interp.v); }
#define PERLVARA(v,n,t)	PL_##v##_t* Perl_##v##_ptr(pTHXo)		\
			{ return &(aTHXo->interp.v); }
#else	/* MULTIPLICITY */
a797 1
#endif
d807 1
a807 1
#define PERLVAR(v,t)	t* Perl_##v##_ptr(pTHXo)			\
d809 1
a809 1
#define PERLVARA(v,n,t)	PL_##v##_t* Perl_##v##_ptr(pTHXo)		\
d812 1
a812 1
#define PERLVARIC(v,t,i)	const t* Perl_##v##_ptr(pTHXo)		\
d821 1
a821 1
#if defined(PERL_OBJECT)
d823 2
a824 1
/* C-API layer for PERL_OBJECT */
d826 1
a826 1
EOT
d830 1
a847 1595

sub emit_func {
    my ($addcontext, $rettype,$func,@@args) = @@_;
    my @@aargs = @@args;
    my $a;
    for $a (@@aargs) { $a =~ s/^.*\b(\w+)$/$1/ }
    my $ctxarg = '';
    if (not $addcontext) {
	$ctxarg = 'pTHXo';
	$ctxarg .= '_ ' if @@args;
    }
    my $decl = '';
    if ($addcontext) {
	$decl .= "    dTHXo;\n";
    }
    local $" = ', ';
    my $return = ($rettype =~ /^\s*(void|Free_t|Signal_t)\s*$/
		  ? '' : 'return ');
    my $emitval = '';
    if (@@args and $args[$#args] =~ /\.\.\./) {
	pop @@aargs;
	my $retarg = '';
	my $ctxfunc = $func;
	$ctxfunc =~ s/_nocontext$//;
	return $emitval unless exists $vfuncs{$ctxfunc};
	if (length $return) {
	    $decl .= "    $rettype retval;\n";
	    $retarg .= "retval = ";
	    $return = "\n    ${return}retval;\n";
	}
	$emitval .= <<EOT
$rettype
$func($ctxarg@@args)
{
$decl    va_list args;
    va_start(args, $aargs[$#aargs]);
    $retarg((CPerlObj*)pPerl)->$vfuncs{$ctxfunc}(@@aargs, &args);
    va_end(args);$return
}
EOT
    }
    else {
	$emitval .= <<EOT
$rettype
$func($ctxarg@@args)
{
$decl    $return((CPerlObj*)pPerl)->$func(@@aargs);
}
EOT
    }
    $emitval;
}

# XXXX temporary hack
my $sym;
for $sym (qw(
		perl_construct
		perl_destruct
		perl_free
		perl_run
		perl_parse
		))
{
    $skipapi_funcs{$sym}++;
}

walk_table {
    my $ret = "";
    if (@@_ == 1) {
	my $arg = shift;
	$ret .= "$arg\n" if $arg =~ /^#\s*(if|ifn?def|else|endif)\b/;
    }
    else {
	my ($flags,$retval,$func,@@args) = @@_;
	return $ret if exists $skipapi_funcs{$func};
	if ($flags =~ /A/ && $flags !~ /j/) { # in public API, needed for XSUBS
	    $ret .= "\n";
	    my $addctx = 1 if $flags =~ /n/;
	    if ($flags =~ /p/) {
		$ret .= undefine("Perl_$func");
		$ret .= emit_func($addctx,$retval,"Perl_$func",@@args);
	    }
	    else {
		$ret .= undefine($func);
		$ret .= emit_func($addctx,$retval,$func,@@args);
	    }
	}
    }
    $ret;
} \*CAPI;

# NOTE: not part of the API
#for $sym (sort keys %ppsym) {
#    $sym =~ s/^Perl_//;
#    print CAPI "\n";
#    print CAPI undefine("Perl_$sym");
#    if ($sym =~ /^ck_/) {
#	print CAPI emit_func(0, 'OP *',"Perl_$sym",'OP *o');
#    }
#   else {					# pp_foo
#	print CAPI emit_func(0, 'OP *',"Perl_$sym");
#    }
#}

print CAPI <<'EOT';

#undef Perl_fprintf_nocontext
int
Perl_fprintf_nocontext(PerlIO *stream, const char *format, ...)
{
    dTHXo;
    va_list(arglist);
    va_start(arglist, format);
    return (*PL_StdIO->pVprintf)(PL_StdIO, stream, format, arglist);
}

#undef Perl_printf_nocontext
int
Perl_printf_nocontext(const char *format, ...)
{
    dTHXo;
    va_list(arglist);
    va_start(arglist, format);
    return (*PL_StdIO->pVprintf)(PL_StdIO, PerlIO_stdout(), format, arglist);
}

END_EXTERN_C

#endif /* PERL_OBJECT */
#endif /* PERL_OBJECT || MULTIPLICITY */
EOT

close(CAPI);

# autogenerate documentation from comments in source files

my %apidocs;
my %gutsdocs;
my %docfuncs;

sub autodoc ($$) { # parse a file and extract documentation info
    my($fh,$file) = @@_;
    my($in, $doc, $line);
FUNC:
    while (defined($in = <$fh>)) {
	$line++;
	if ($in =~ /^=for\s+apidoc\s+(.*)\n/) {
	    my $proto = $1;
	    $proto = "||$proto" unless $proto =~ /\|/;
	    my($flags, $ret, $name, @@args) = split /\|/, $proto;
	    my $docs = "";
DOC:
	    while (defined($doc = <$fh>)) {
		$line++;
		last DOC if $doc =~ /^=\w+/;
		if ($doc =~ m:^\*/$:) {
		    warn "=cut missing? $file:$line:$doc";;
		    last DOC;
		}
		$docs .= $doc;
	    }
	    $docs = "\n$docs" if $docs and $docs !~ /^\n/;
	    if ($flags =~ /m/) {
		if ($flags =~ /A/) {
		    $apidocs{$name} = [$flags, $docs, $ret, $file, @@args];
		}
		else {
		    $gutsdocs{$name} = [$flags, $docs, $ret, $file, @@args];
		}
	    }
	    else {
		$docfuncs{$name} = [$flags, $docs, $ret, $file, @@args];
	    }
	    if (defined $doc) {
		if ($doc =~ /^=for/) {
		    $in = $doc;
		    redo FUNC;
		}
	    } else {
		warn "$file:$line:$in";
	    }
	}
    }
}

sub docout ($$$) { # output the docs for one function
    my($fh, $name, $docref) = @@_;
    my($flags, $docs, $ret, $file, @@args) = @@$docref;

    $docs .= "NOTE: this function is experimental and may change or be
removed without notice.\n\n" if $flags =~ /x/;
    $docs .= "NOTE: the perl_ form of this function is deprecated.\n\n" 
	if $flags =~ /p/;

    print $fh "=item $name\n$docs";

    if ($flags =~ /U/) { # no usage
	# nothing
    } elsif ($flags =~ /s/) { # semicolon ("dTHR;")
	print $fh "\t\t$name;\n\n";
    } elsif ($flags =~ /n/) { # no args
	print $fh "\t$ret\t$name\n\n";
    } else { # full usage
	print $fh "\t$ret\t$name";
	print $fh "(" . join(", ", @@args) . ")";
	print $fh "\n\n";
    }
    print $fh "=for hackers\nFound in file $file\n\n";
}

my $file;
for $file (glob('*.c'), glob('*.h')) {
    open F, "< $file" or die "Cannot open $file for docs: $!\n";
    autodoc(\*F,$file);
    close F or die "Error closing $file: $!\n";
}

unlink "pod/perlapi.pod";
open (DOC, ">pod/perlapi.pod") or 
	die "Can't create pod/perlapi.pod: $!\n";

walk_table {	# load documented functions into approriate hash
    if (@@_ > 1) {
	my($flags, $retval, $func, @@args) = @@_;
	return "" unless $flags =~ /d/;
	$func =~ s/\t//g; $flags =~ s/p//; # clean up fields from embed.pl
	$retval =~ s/\t//;
	if ($flags =~ /A/) {
	    my $docref = delete $docfuncs{$func};
	    warn "no docs for $func\n" unless $docref and @@$docref;
        $docref->[0].="x" if $flags =~ /M/;
	    $apidocs{$func} = [$docref->[0] . 'A', $docref->[1], $retval,
			       $docref->[3], @@args];
	} else {
	    my $docref = delete $docfuncs{$func};
	    $gutsdocs{$func} = [$docref->[0], $docref->[1], $retval,
				$docref->[3], @@args];
	}
    }
    return "";
} \*DOC;

for (sort keys %docfuncs) {
    # Have you used a full for apidoc or just a func name?  
    # Have you used Ap instead of Am in the for apidoc?
    warn "Unable to place $_!\n";
}

print DOC <<'_EOB_';
=head1 NAME

perlapi - autogenerated documentation for the perl public API

=head1 DESCRIPTION

This file contains the documentation of the perl public API generated by 
embed.pl, specifically a listing of functions, macros, flags, and variables 
that may be used by extension writers.  The interfaces of any functions that 
are not listed here are subject to change without notice.  For this reason,
blindly using functions listed in proto.h is to be avoided when writing
extensions.

Note that all Perl API global variables must be referenced with the C<PL_>
prefix.  Some macros are provided for compatibility with the older,
unadorned names, but this support may be disabled in a future release.

The listing is alphabetical, case insensitive.

=over 8

_EOB_

my $key;
for $key (sort { uc($a) cmp uc($b); } keys %apidocs) { # case insensitive sort
    docout(\*DOC, $key, $apidocs{$key});
}

print DOC <<'_EOE_';
=back

=head1 AUTHORS

Until May 1997, this document was maintained by Jeff Okamoto
<okamoto@@corp.hp.com>.  It is now maintained as part of Perl itself.

With lots of help and suggestions from Dean Roehrich, Malcolm Beattie,
Andreas Koenig, Paul Hudson, Ilya Zakharevich, Paul Marquess, Neil
Bowers, Matthew Green, Tim Bunce, Spider Boardman, Ulrich Pfeifer,
Stephen McCamant, and Gurusamy Sarathy.

API Listing originally by Dean Roehrich <roehrich@@cray.com>.

Updated to be autogenerated from comments in the source by Benjamin Stuhl.

=head1 SEE ALSO

perlguts(1), perlxs(1), perlxstut(1), perlintern(1)

_EOE_


close(DOC);

open(GUTS, ">pod/perlintern.pod") or 
		die "Unable to create pod/perlintern.pod: $!\n";
print GUTS <<'END';
=head1 NAME

perlintern - autogenerated documentation of purely B<internal> 
		 Perl functions

=head1 DESCRIPTION

This file is the autogenerated documentation of functions in the 
Perl interpreter that are documented using Perl's internal documentation
format but are not marked as part of the Perl API. In other words, 
B<they are not for use in extensions>!

=over 8

END

for $key (sort { uc($a) cmp uc($b); } keys %gutsdocs) {
    docout(\*GUTS, $key, $gutsdocs{$key});
}

print GUTS <<'END';
=back

=head1 AUTHORS

The autodocumentation system was originally added to the Perl core by 
Benjamin Stuhl. Documentation is by whoever was kind enough to 
document their functions.

=head1 SEE ALSO

perlguts(1), perlapi(1)

END

close GUTS;


__END__

: Lines are of the form:
:    flags|return_type|function_name|arg1|arg2|...|argN
:
: A line may be continued on another by ending it with a backslash.
: Leading and trailing whitespace will be ignored in each component.
:
: flags are single letters with following meanings:
:	A		member of public API
:	d		function has documentation with its source
:	s		static function, should have an S_ prefix in source
:				file
:	n		has no implicit interpreter/thread context argument
:	p		function has a Perl_ prefix
:	f		function takes printf style format string, varargs
:	r		function never returns
:       o		has no compatibility macro (#define foo Perl_foo)
:       j		not a member of CPerlObj
:       x		not exported
:       M		may change
:
: Individual flags may be separated by whitespace.
:
: New global functions should be added at the end for binary compatibility
: in some configurations.

START_EXTERN_C

#if defined(PERL_IMPLICIT_SYS)
Ajno	|PerlInterpreter*	|perl_alloc_using \
				|struct IPerlMem* m|struct IPerlMem* ms \
				|struct IPerlMem* mp|struct IPerlEnv* e \
				|struct IPerlStdIO* io|struct IPerlLIO* lio \
				|struct IPerlDir* d|struct IPerlSock* s \
				|struct IPerlProc* p
#endif
Ajnod	|PerlInterpreter*	|perl_alloc
Ajnod	|void	|perl_construct	|PerlInterpreter* interp
Ajnod	|void	|perl_destruct	|PerlInterpreter* interp
Ajnod	|void	|perl_free	|PerlInterpreter* interp
Ajnod	|int	|perl_run	|PerlInterpreter* interp
Ajnod	|int	|perl_parse	|PerlInterpreter* interp|XSINIT_t xsinit \
				|int argc|char** argv|char** env
#if defined(USE_ITHREADS)
: XXX: perl_clone needs docs
Ajno	|PerlInterpreter*|perl_clone|PerlInterpreter* interp, UV flags
#  if defined(PERL_IMPLICIT_SYS)
Ajno	|PerlInterpreter*|perl_clone_using|PerlInterpreter *interp|UV flags \
				|struct IPerlMem* m|struct IPerlMem* ms \
				|struct IPerlMem* mp|struct IPerlEnv* e \
				|struct IPerlStdIO* io|struct IPerlLIO* lio \
				|struct IPerlDir* d|struct IPerlSock* s \
				|struct IPerlProc* p
#  endif
#endif

#if defined(MYMALLOC)
Ajnop	|Malloc_t|malloc	|MEM_SIZE nbytes
Ajnop	|Malloc_t|calloc	|MEM_SIZE elements|MEM_SIZE size
Ajnop	|Malloc_t|realloc	|Malloc_t where|MEM_SIZE nbytes
Ajnop	|Free_t	|mfree		|Malloc_t where
jnp	|MEM_SIZE|malloced_size	|void *p
#endif

Ajnp	|void*	|get_context
Ajnp	|void	|set_context	|void *thx

END_EXTERN_C

/* functions with flag 'n' should come before here */
#if defined(PERL_OBJECT)
class CPerlObj {
public:
	struct interpreter interp;
	CPerlObj(IPerlMem*, IPerlMem*, IPerlMem*, IPerlEnv*, IPerlStdIO*,
	    IPerlLIO*, IPerlDir*, IPerlSock*, IPerlProc*);
	void* operator new(size_t nSize, IPerlMem *pvtbl);
#ifndef __BORLANDC__
	static void operator delete(void* pPerl, IPerlMem *pvtbl);
#endif
	int do_aspawn (void *vreally, void **vmark, void **vsp);
#endif
#if defined(PERL_OBJECT)
public:
#else
START_EXTERN_C
#endif
#  include "pp_proto.h"
Ap	|SV*	|amagic_call	|SV* left|SV* right|int method|int dir
Ap	|bool	|Gv_AMupdate	|HV* stash
p	|OP*	|append_elem	|I32 optype|OP* head|OP* tail
p	|OP*	|append_list	|I32 optype|LISTOP* first|LISTOP* last
p	|I32	|apply		|I32 type|SV** mark|SV** sp
Ap	|void	|apply_attrs_string|char *stashpv|CV *cv|char *attrstr|STRLEN len
Ap	|SV*	|avhv_delete_ent|AV *ar|SV* keysv|I32 flags|U32 hash
Ap	|bool	|avhv_exists_ent|AV *ar|SV* keysv|U32 hash
Ap	|SV**	|avhv_fetch_ent	|AV *ar|SV* keysv|I32 lval|U32 hash
Ap	|SV**	|avhv_store_ent	|AV *ar|SV* keysv|SV* val|U32 hash
Ap	|HE*	|avhv_iternext	|AV *ar
Ap	|SV*	|avhv_iterval	|AV *ar|HE* entry
Ap	|HV*	|avhv_keys	|AV *ar
Apd	|void	|av_clear	|AV* ar
Apd	|SV*	|av_delete	|AV* ar|I32 key|I32 flags
Apd	|bool	|av_exists	|AV* ar|I32 key
Apd	|void	|av_extend	|AV* ar|I32 key
p	|AV*	|av_fake	|I32 size|SV** svp
Apd	|SV**	|av_fetch	|AV* ar|I32 key|I32 lval
Apd	|void	|av_fill	|AV* ar|I32 fill
Apd	|I32	|av_len		|AV* ar
Apd	|AV*	|av_make	|I32 size|SV** svp
Apd	|SV*	|av_pop		|AV* ar
Apd	|void	|av_push	|AV* ar|SV* val
ApM	|void	|av_reify	|AV* ar
Apd	|SV*	|av_shift	|AV* ar
Apd	|SV**	|av_store	|AV* ar|I32 key|SV* val
Apd	|void	|av_undef	|AV* ar
Apd	|void	|av_unshift	|AV* ar|I32 num
p	|OP*	|bind_match	|I32 type|OP* left|OP* pat
p	|OP*	|block_end	|I32 floor|OP* seq
Ap	|I32	|block_gimme
p	|int	|block_start	|int full
p	|void	|boot_core_UNIVERSAL
Ap	|void	|call_list	|I32 oldscope|AV* av_list
p	|bool	|cando		|Mode_t mode|Uid_t effective|Stat_t* statbufp
Ap	|U32	|cast_ulong	|NV f
Ap	|I32	|cast_i32	|NV f
Ap	|IV	|cast_iv	|NV f
Ap	|UV	|cast_uv	|NV f
#if !defined(HAS_TRUNCATE) && !defined(HAS_CHSIZE) && defined(F_FREESP)
Ap	|I32	|my_chsize	|int fd|Off_t length
#endif
#if defined(USE_THREADS)
Ap	|MAGIC*	|condpair_magic	|SV *sv
#endif
p	|OP*	|convert	|I32 optype|I32 flags|OP* o
Afprd	|void	|croak		|const char* pat|...
Apr	|void	|vcroak		|const char* pat|va_list* args
#if defined(PERL_IMPLICIT_CONTEXT)
Afnrp	|void	|croak_nocontext|const char* pat|...
Afnp	|OP*	|die_nocontext	|const char* pat|...
Afnp	|void	|deb_nocontext	|const char* pat|...
Afnp	|char*	|form_nocontext	|const char* pat|...
Anp	|void	|load_module_nocontext|U32 flags|SV* name|SV* ver|...
Afnp	|SV*	|mess_nocontext	|const char* pat|...
Afnp	|void	|warn_nocontext	|const char* pat|...
Afnp	|void	|warner_nocontext|U32 err|const char* pat|...
Afnp	|SV*	|newSVpvf_nocontext|const char* pat|...
Afnp	|void	|sv_catpvf_nocontext|SV* sv|const char* pat|...
Afnp	|void	|sv_setpvf_nocontext|SV* sv|const char* pat|...
Afnp	|void	|sv_catpvf_mg_nocontext|SV* sv|const char* pat|...
Afnp	|void	|sv_setpvf_mg_nocontext|SV* sv|const char* pat|...
Afnp	|int	|fprintf_nocontext|PerlIO* stream|const char* fmt|...
Afnp	|int	|printf_nocontext|const char* fmt|...
#endif
p	|void	|cv_ckproto	|CV* cv|GV* gv|char* p
p	|CV*	|cv_clone	|CV* proto
Ap	|SV*	|cv_const_sv	|CV* cv
p	|SV*	|op_const_sv	|OP* o|CV* cv
Ap	|void	|cv_undef	|CV* cv
Ap	|void	|cx_dump	|PERL_CONTEXT* cs
Ap	|SV*	|filter_add	|filter_t funcp|SV* datasv
Ap	|void	|filter_del	|filter_t funcp
Ap	|I32	|filter_read	|int idx|SV* buffer|int maxlen
Ap	|char**	|get_op_descs
Ap	|char**	|get_op_names
p	|char*	|get_no_modify
p	|U32*	|get_opargs
Ap	|PPADDR_t*|get_ppaddr
p	|I32	|cxinc
Afp	|void	|deb		|const char* pat|...
Ap	|void	|vdeb		|const char* pat|va_list* args
Ap	|void	|debprofdump
Ap	|I32	|debop		|OP* o
Ap	|I32	|debstack
Ap	|I32	|debstackptrs
Ap	|char*	|delimcpy	|char* to|char* toend|char* from \
				|char* fromend|int delim|I32* retlen
p	|void	|deprecate	|char* s
Afp	|OP*	|die		|const char* pat|...
p	|OP*	|vdie		|const char* pat|va_list* args
p	|OP*	|die_where	|char* message|STRLEN msglen
Ap	|void	|dounwind	|I32 cxix
p	|bool	|do_aexec	|SV* really|SV** mark|SV** sp
p	|bool	|do_aexec5	|SV* really|SV** mark|SV** sp|int fd|int flag
Ap	|int	|do_binmode	|PerlIO *fp|int iotype|int mode
p	|void	|do_chop	|SV* asv|SV* sv
Ap	|bool	|do_close	|GV* gv|bool not_implicit
p	|bool	|do_eof		|GV* gv
p	|bool	|do_exec	|char* cmd
#if !defined(WIN32)
p	|bool	|do_exec3	|char* cmd|int fd|int flag
#endif
p	|void	|do_execfree
#if defined(HAS_MSG) || defined(HAS_SEM) || defined(HAS_SHM)
p	|I32	|do_ipcctl	|I32 optype|SV** mark|SV** sp
p	|I32	|do_ipcget	|I32 optype|SV** mark|SV** sp
p	|I32	|do_msgrcv	|SV** mark|SV** sp
p	|I32	|do_msgsnd	|SV** mark|SV** sp
p	|I32	|do_semop	|SV** mark|SV** sp
p	|I32	|do_shmio	|I32 optype|SV** mark|SV** sp
#endif
Ap	|void	|do_join	|SV* sv|SV* del|SV** mark|SV** sp
p	|OP*	|do_kv
Ap	|bool	|do_open	|GV* gv|char* name|I32 len|int as_raw \
				|int rawmode|int rawperm|PerlIO* supplied_fp
Ap	|bool	|do_open9	|GV *gv|char *name|I32 len|int as_raw \
				|int rawmode|int rawperm|PerlIO *supplied_fp \
				|SV *svs|I32 num
p	|void	|do_pipe	|SV* sv|GV* rgv|GV* wgv
p	|bool	|do_print	|SV* sv|PerlIO* fp
p	|OP*	|do_readline
p	|I32	|do_chomp	|SV* sv
p	|bool	|do_seek	|GV* gv|Off_t pos|int whence
p	|void	|do_sprintf	|SV* sv|I32 len|SV** sarg
p	|Off_t	|do_sysseek	|GV* gv|Off_t pos|int whence
p	|Off_t	|do_tell	|GV* gv
p	|I32	|do_trans	|SV* sv
p	|UV	|do_vecget	|SV* sv|I32 offset|I32 size
p	|void	|do_vecset	|SV* sv
p	|void	|do_vop		|I32 optype|SV* sv|SV* left|SV* right
p	|OP*	|dofile		|OP* term
Ap	|I32	|dowantarray
Ap	|void	|dump_all
Ap	|void	|dump_eval
#if defined(DUMP_FDS)
Ap	|void	|dump_fds	|char* s
#endif
Ap	|void	|dump_form	|GV* gv
Ap	|void	|gv_dump	|GV* gv
Ap	|void	|op_dump	|OP* arg
Ap	|void	|pmop_dump	|PMOP* pm
Ap	|void	|dump_packsubs	|HV* stash
Ap	|void	|dump_sub	|GV* gv
Apd	|void	|fbm_compile	|SV* sv|U32 flags
Apd	|char*	|fbm_instr	|unsigned char* big|unsigned char* bigend \
				|SV* littlesv|U32 flags
p	|char*	|find_script	|char *scriptname|bool dosearch \
				|char **search_ext|I32 flags
#if defined(USE_THREADS)
p	|PADOFFSET|find_threadsv|const char *name
#endif
p	|OP*	|force_list	|OP* arg
p	|OP*	|fold_constants	|OP* arg
Afp	|char*	|form		|const char* pat|...
Ap	|char*	|vform		|const char* pat|va_list* args
Ap	|void	|free_tmps
p	|OP*	|gen_constant_list|OP* o
#if !defined(HAS_GETENV_LEN)
p	|char*	|getenv_len	|const char* key|unsigned long *len
#endif
Ap	|void	|gp_free	|GV* gv
Ap	|GP*	|gp_ref		|GP* gp
Ap	|GV*	|gv_AVadd	|GV* gv
Ap	|GV*	|gv_HVadd	|GV* gv
Ap	|GV*	|gv_IOadd	|GV* gv
Ap	|GV*	|gv_autoload4	|HV* stash|const char* name|STRLEN len \
				|I32 method
Ap	|void	|gv_check	|HV* stash
Ap	|void	|gv_efullname	|SV* sv|GV* gv
Ap	|void	|gv_efullname3	|SV* sv|GV* gv|const char* prefix
Ap	|void	|gv_efullname4	|SV* sv|GV* gv|const char* prefix|bool keepmain
Ap	|GV*	|gv_fetchfile	|const char* name
Apd	|GV*	|gv_fetchmeth	|HV* stash|const char* name|STRLEN len \
				|I32 level
Apd	|GV*	|gv_fetchmethod	|HV* stash|const char* name
Apd	|GV*	|gv_fetchmethod_autoload|HV* stash|const char* name \
				|I32 autoload
Ap	|GV*	|gv_fetchpv	|const char* name|I32 add|I32 sv_type
Ap	|void	|gv_fullname	|SV* sv|GV* gv
Ap	|void	|gv_fullname3	|SV* sv|GV* gv|const char* prefix
Ap	|void	|gv_fullname4	|SV* sv|GV* gv|const char* prefix|bool keepmain
Ap	|void	|gv_init	|GV* gv|HV* stash|const char* name \
				|STRLEN len|int multi
Apd	|HV*	|gv_stashpv	|const char* name|I32 create
Ap	|HV*	|gv_stashpvn	|const char* name|U32 namelen|I32 create
Apd	|HV*	|gv_stashsv	|SV* sv|I32 create
Apd	|void	|hv_clear	|HV* tb
Ap	|void	|hv_delayfree_ent|HV* hv|HE* entry
Apd	|SV*	|hv_delete	|HV* tb|const char* key|U32 klen|I32 flags
Apd	|SV*	|hv_delete_ent	|HV* tb|SV* key|I32 flags|U32 hash
Apd	|bool	|hv_exists	|HV* tb|const char* key|U32 klen
Apd	|bool	|hv_exists_ent	|HV* tb|SV* key|U32 hash
Apd	|SV**	|hv_fetch	|HV* tb|const char* key|U32 klen|I32 lval
Apd	|HE*	|hv_fetch_ent	|HV* tb|SV* key|I32 lval|U32 hash
Ap	|void	|hv_free_ent	|HV* hv|HE* entry
Apd	|I32	|hv_iterinit	|HV* tb
Apd	|char*	|hv_iterkey	|HE* entry|I32* retlen
Apd	|SV*	|hv_iterkeysv	|HE* entry
Apd	|HE*	|hv_iternext	|HV* tb
Apd	|SV*	|hv_iternextsv	|HV* hv|char** key|I32* retlen
Apd	|SV*	|hv_iterval	|HV* tb|HE* entry
Ap	|void	|hv_ksplit	|HV* hv|IV newmax
Apd	|void	|hv_magic	|HV* hv|GV* gv|int how
Apd	|SV**	|hv_store	|HV* tb|const char* key|U32 klen|SV* val \
				|U32 hash
Apd	|HE*	|hv_store_ent	|HV* tb|SV* key|SV* val|U32 hash
Apd	|void	|hv_undef	|HV* tb
Ap	|I32	|ibcmp		|const char* a|const char* b|I32 len
Ap	|I32	|ibcmp_locale	|const char* a|const char* b|I32 len
p	|bool	|ingroup	|Gid_t testgid|Uid_t effective
p	|void	|init_debugger
Ap	|void	|init_stacks
p	|U32	|intro_my
Ap	|char*	|instr		|const char* big|const char* little
p	|bool	|io_close	|IO* io|bool not_implicit
p	|OP*	|invert		|OP* cmd
dp	|bool	|is_gv_magical	|char *name|STRLEN len|U32 flags
p	|I32	|is_lvalue_sub
Ap	|bool	|is_uni_alnum	|U32 c
Ap	|bool	|is_uni_alnumc	|U32 c
Ap	|bool	|is_uni_idfirst	|U32 c
Ap	|bool	|is_uni_alpha	|U32 c
Ap	|bool	|is_uni_ascii	|U32 c
Ap	|bool	|is_uni_space	|U32 c
Ap	|bool	|is_uni_cntrl	|U32 c
Ap	|bool	|is_uni_graph	|U32 c
Ap	|bool	|is_uni_digit	|U32 c
Ap	|bool	|is_uni_upper	|U32 c
Ap	|bool	|is_uni_lower	|U32 c
Ap	|bool	|is_uni_print	|U32 c
Ap	|bool	|is_uni_punct	|U32 c
Ap	|bool	|is_uni_xdigit	|U32 c
Ap	|U32	|to_uni_upper	|U32 c
Ap	|U32	|to_uni_title	|U32 c
Ap	|U32	|to_uni_lower	|U32 c
Ap	|bool	|is_uni_alnum_lc|U32 c
Ap	|bool	|is_uni_alnumc_lc|U32 c
Ap	|bool	|is_uni_idfirst_lc|U32 c
Ap	|bool	|is_uni_alpha_lc|U32 c
Ap	|bool	|is_uni_ascii_lc|U32 c
Ap	|bool	|is_uni_space_lc|U32 c
Ap	|bool	|is_uni_cntrl_lc|U32 c
Ap	|bool	|is_uni_graph_lc|U32 c
Ap	|bool	|is_uni_digit_lc|U32 c
Ap	|bool	|is_uni_upper_lc|U32 c
Ap	|bool	|is_uni_lower_lc|U32 c
Ap	|bool	|is_uni_print_lc|U32 c
Ap	|bool	|is_uni_punct_lc|U32 c
Ap	|bool	|is_uni_xdigit_lc|U32 c
Ap	|U32	|to_uni_upper_lc|U32 c
Ap	|U32	|to_uni_title_lc|U32 c
Ap	|U32	|to_uni_lower_lc|U32 c
Apd	|STRLEN	|is_utf8_char	|U8 *p
Apd	|bool	|is_utf8_string	|U8 *s|STRLEN len
Ap	|bool	|is_utf8_alnum	|U8 *p
Ap	|bool	|is_utf8_alnumc	|U8 *p
Ap	|bool	|is_utf8_idfirst|U8 *p
Ap	|bool	|is_utf8_alpha	|U8 *p
Ap	|bool	|is_utf8_ascii	|U8 *p
Ap	|bool	|is_utf8_space	|U8 *p
Ap	|bool	|is_utf8_cntrl	|U8 *p
Ap	|bool	|is_utf8_digit	|U8 *p
Ap	|bool	|is_utf8_graph	|U8 *p
Ap	|bool	|is_utf8_upper	|U8 *p
Ap	|bool	|is_utf8_lower	|U8 *p
Ap	|bool	|is_utf8_print	|U8 *p
Ap	|bool	|is_utf8_punct	|U8 *p
Ap	|bool	|is_utf8_xdigit	|U8 *p
Ap	|bool	|is_utf8_mark	|U8 *p
p	|OP*	|jmaybe		|OP* arg
p	|I32	|keyword	|char* d|I32 len
Ap	|void	|leave_scope	|I32 base
p	|void	|lex_end
p	|void	|lex_start	|SV* line
p	|OP*	|linklist	|OP* o
p	|OP*	|list		|OP* o
p	|OP*	|listkids	|OP* o
Ap	|void	|load_module|U32 flags|SV* name|SV* ver|...
Ap	|void	|vload_module|U32 flags|SV* name|SV* ver|va_list* args
p	|OP*	|localize	|OP* arg|I32 lexical
Apd	|I32	|looks_like_number|SV* sv
p	|int	|magic_clearenv	|SV* sv|MAGIC* mg
p	|int	|magic_clear_all_env|SV* sv|MAGIC* mg
p	|int	|magic_clearpack|SV* sv|MAGIC* mg
p	|int	|magic_clearsig	|SV* sv|MAGIC* mg
p	|int	|magic_existspack|SV* sv|MAGIC* mg
p	|int	|magic_freeregexp|SV* sv|MAGIC* mg
p	|int	|magic_get	|SV* sv|MAGIC* mg
p	|int	|magic_getarylen|SV* sv|MAGIC* mg
p	|int	|magic_getdefelem|SV* sv|MAGIC* mg
p	|int	|magic_getglob	|SV* sv|MAGIC* mg
p	|int	|magic_getnkeys	|SV* sv|MAGIC* mg
p	|int	|magic_getpack	|SV* sv|MAGIC* mg
p	|int	|magic_getpos	|SV* sv|MAGIC* mg
p	|int	|magic_getsig	|SV* sv|MAGIC* mg
p	|int	|magic_getsubstr|SV* sv|MAGIC* mg
p	|int	|magic_gettaint	|SV* sv|MAGIC* mg
p	|int	|magic_getuvar	|SV* sv|MAGIC* mg
p	|int	|magic_getvec	|SV* sv|MAGIC* mg
p	|U32	|magic_len	|SV* sv|MAGIC* mg
#if defined(USE_THREADS)
p	|int	|magic_mutexfree|SV* sv|MAGIC* mg
#endif
p	|int	|magic_nextpack	|SV* sv|MAGIC* mg|SV* key
p	|U32	|magic_regdata_cnt|SV* sv|MAGIC* mg
p	|int	|magic_regdatum_get|SV* sv|MAGIC* mg
p	|int	|magic_regdatum_set|SV* sv|MAGIC* mg
p	|int	|magic_set	|SV* sv|MAGIC* mg
p	|int	|magic_setamagic|SV* sv|MAGIC* mg
p	|int	|magic_setarylen|SV* sv|MAGIC* mg
p	|int	|magic_setbm	|SV* sv|MAGIC* mg
p	|int	|magic_setdbline|SV* sv|MAGIC* mg
#if defined(USE_LOCALE_COLLATE)
p	|int	|magic_setcollxfrm|SV* sv|MAGIC* mg
#endif
p	|int	|magic_setdefelem|SV* sv|MAGIC* mg
p	|int	|magic_setenv	|SV* sv|MAGIC* mg
p	|int	|magic_setfm	|SV* sv|MAGIC* mg
p	|int	|magic_setisa	|SV* sv|MAGIC* mg
p	|int	|magic_setglob	|SV* sv|MAGIC* mg
p	|int	|magic_setmglob	|SV* sv|MAGIC* mg
p	|int	|magic_setnkeys	|SV* sv|MAGIC* mg
p	|int	|magic_setpack	|SV* sv|MAGIC* mg
p	|int	|magic_setpos	|SV* sv|MAGIC* mg
p	|int	|magic_setsig	|SV* sv|MAGIC* mg
p	|int	|magic_setsubstr|SV* sv|MAGIC* mg
p	|int	|magic_settaint	|SV* sv|MAGIC* mg
p	|int	|magic_setuvar	|SV* sv|MAGIC* mg
p	|int	|magic_setvec	|SV* sv|MAGIC* mg
p	|int	|magic_set_all_env|SV* sv|MAGIC* mg
p	|U32	|magic_sizepack	|SV* sv|MAGIC* mg
p	|int	|magic_wipepack	|SV* sv|MAGIC* mg
p	|void	|magicname	|char* sym|char* name|I32 namlen
Ap	|void	|markstack_grow
#if defined(USE_LOCALE_COLLATE)
p	|char*	|mem_collxfrm	|const char* s|STRLEN len|STRLEN* xlen
#endif
Afp	|SV*	|mess		|const char* pat|...
Ap	|SV*	|vmess		|const char* pat|va_list* args
p	|void	|qerror		|SV* err
Apd	|int	|mg_clear	|SV* sv
Apd	|int	|mg_copy	|SV* sv|SV* nsv|const char* key|I32 klen
Apd	|MAGIC*	|mg_find	|SV* sv|int type
Apd	|int	|mg_free	|SV* sv
Apd	|int	|mg_get		|SV* sv
Apd	|U32	|mg_length	|SV* sv
Apd	|void	|mg_magical	|SV* sv
Apd	|int	|mg_set		|SV* sv
Ap	|I32	|mg_size	|SV* sv
p	|OP*	|mod		|OP* o|I32 type
p	|int	|mode_from_discipline|SV* discp
Ap	|char*	|moreswitches	|char* s
p	|OP*	|my		|OP* o
Ap	|NV	|my_atof	|const char *s
#if !defined(HAS_BCOPY) || !defined(HAS_SAFE_BCOPY)
Anp	|char*	|my_bcopy	|const char* from|char* to|I32 len
#endif
#if !defined(HAS_BZERO) && !defined(HAS_MEMSET)
Anp	|char*	|my_bzero	|char* loc|I32 len
#endif
Apr	|void	|my_exit	|U32 status
Apr	|void	|my_failure_exit
Ap	|I32	|my_fflush_all
Ap	|I32	|my_lstat
#if !defined(HAS_MEMCMP) || !defined(HAS_SANE_MEMCMP)
Anp	|I32	|my_memcmp	|const char* s1|const char* s2|I32 len
#endif
#if !defined(HAS_MEMSET)
Anp	|void*	|my_memset	|char* loc|I32 ch|I32 len
#endif
#if !defined(PERL_OBJECT)
Ap	|I32	|my_pclose	|PerlIO* ptr
Ap	|PerlIO*|my_popen	|char* cmd|char* mode
#endif
Ap	|void	|my_setenv	|char* nam|char* val
Ap	|I32	|my_stat
#if defined(MYSWAP)
Ap	|short	|my_swap	|short s
Ap	|long	|my_htonl	|long l
Ap	|long	|my_ntohl	|long l
#endif
p	|void	|my_unexec
Ap	|OP*	|newANONLIST	|OP* o
Ap	|OP*	|newANONHASH	|OP* o
Ap	|OP*	|newANONSUB	|I32 floor|OP* proto|OP* block
Ap	|OP*	|newASSIGNOP	|I32 flags|OP* left|I32 optype|OP* right
Ap	|OP*	|newCONDOP	|I32 flags|OP* expr|OP* trueop|OP* falseop
Apd	|void	|newCONSTSUB	|HV* stash|char* name|SV* sv
Ap	|void	|newFORM	|I32 floor|OP* o|OP* block
Ap	|OP*	|newFOROP	|I32 flags|char* label|line_t forline \
				|OP* sclr|OP* expr|OP*block|OP*cont
Ap	|OP*	|newLOGOP	|I32 optype|I32 flags|OP* left|OP* right
Ap	|OP*	|newLOOPEX	|I32 type|OP* label
Ap	|OP*	|newLOOPOP	|I32 flags|I32 debuggable|OP* expr|OP* block
Ap	|OP*	|newNULLLIST
Ap	|OP*	|newOP		|I32 optype|I32 flags
Ap	|void	|newPROG	|OP* o
Ap	|OP*	|newRANGE	|I32 flags|OP* left|OP* right
Ap	|OP*	|newSLICEOP	|I32 flags|OP* subscript|OP* listop
Ap	|OP*	|newSTATEOP	|I32 flags|char* label|OP* o
Ap	|CV*	|newSUB		|I32 floor|OP* o|OP* proto|OP* block
Apd	|CV*	|newXS		|char* name|XSUBADDR_t f|char* filename
Apd	|AV*	|newAV
Ap	|OP*	|newAVREF	|OP* o
Ap	|OP*	|newBINOP	|I32 type|I32 flags|OP* first|OP* last
Ap	|OP*	|newCVREF	|I32 flags|OP* o
Ap	|OP*	|newGVOP	|I32 type|I32 flags|GV* gv
Ap	|GV*	|newGVgen	|char* pack
Ap	|OP*	|newGVREF	|I32 type|OP* o
Ap	|OP*	|newHVREF	|OP* o
Apd	|HV*	|newHV
Ap	|HV*	|newHVhv	|HV* hv
Ap	|IO*	|newIO
Ap	|OP*	|newLISTOP	|I32 type|I32 flags|OP* first|OP* last
Ap	|OP*	|newPADOP	|I32 type|I32 flags|SV* sv
Ap	|OP*	|newPMOP	|I32 type|I32 flags
Ap	|OP*	|newPVOP	|I32 type|I32 flags|char* pv
Ap	|SV*	|newRV		|SV* pref
Apd	|SV*	|newRV_noinc	|SV *sv
Ap	|SV*	|newSV		|STRLEN len
Ap	|OP*	|newSVREF	|OP* o
Ap	|OP*	|newSVOP	|I32 type|I32 flags|SV* sv
Apd	|SV*	|newSViv	|IV i
Apd	|SV*	|newSVuv	|UV u
Apd	|SV*	|newSVnv	|NV n
Apd	|SV*	|newSVpv	|const char* s|STRLEN len
Apd	|SV*	|newSVpvn	|const char* s|STRLEN len
Afpd	|SV*	|newSVpvf	|const char* pat|...
Ap	|SV*	|vnewSVpvf	|const char* pat|va_list* args
Apd	|SV*	|newSVrv	|SV* rv|const char* classname
Apd	|SV*	|newSVsv	|SV* old
Ap	|OP*	|newUNOP	|I32 type|I32 flags|OP* first
Ap	|OP*	|newWHILEOP	|I32 flags|I32 debuggable|LOOP* loop \
				|I32 whileline|OP* expr|OP* block|OP* cont

Ap	|PERL_SI*|new_stackinfo|I32 stitems|I32 cxitems
p	|PerlIO*|nextargv	|GV* gv
Ap	|char*	|ninstr		|const char* big|const char* bigend \
				|const char* little|const char* lend
p	|OP*	|oopsCV		|OP* o
Ap	|void	|op_free	|OP* arg
p	|void	|package	|OP* o
p	|PADOFFSET|pad_alloc	|I32 optype|U32 tmptype
p	|PADOFFSET|pad_allocmy	|char* name
p	|PADOFFSET|pad_findmy	|char* name
p	|OP*	|oopsAV		|OP* o
p	|OP*	|oopsHV		|OP* o
p	|void	|pad_leavemy	|I32 fill
Ap	|SV*	|pad_sv		|PADOFFSET po
p	|void	|pad_free	|PADOFFSET po
p	|void	|pad_reset
p	|void	|pad_swipe	|PADOFFSET po
p	|void	|peep		|OP* o
#if defined(PERL_OBJECT)
Aox	|void	|Perl_construct
Aox	|void	|Perl_destruct
Aox	|void	|Perl_free
Aox	|int	|Perl_run
Aox	|int	|Perl_parse	|XSINIT_t xsinit \
				|int argc|char** argv|char** env
#endif
#if defined(USE_THREADS)
Ap	|struct perl_thread*	|new_struct_thread|struct perl_thread *t
#endif
Ap	|void	|call_atexit	|ATEXIT_t fn|void *ptr
Apd	|I32	|call_argv	|const char* sub_name|I32 flags|char** argv
Apd	|I32	|call_method	|const char* methname|I32 flags
Apd	|I32	|call_pv	|const char* sub_name|I32 flags
Apd	|I32	|call_sv	|SV* sv|I32 flags
Apd	|SV*	|eval_pv	|const char* p|I32 croak_on_error
Apd	|I32	|eval_sv	|SV* sv|I32 flags
Apd	|SV*	|get_sv		|const char* name|I32 create
Apd	|AV*	|get_av		|const char* name|I32 create
Apd	|HV*	|get_hv		|const char* name|I32 create
Apd	|CV*	|get_cv		|const char* name|I32 create
Ap	|int	|init_i18nl10n	|int printwarn
Ap	|int	|init_i18nl14n	|int printwarn
Ap	|void	|new_collate	|char* newcoll
Ap	|void	|new_ctype	|char* newctype
Ap	|void	|new_numeric	|char* newcoll
Ap	|void	|set_numeric_local
Ap	|void	|set_numeric_radix
Ap	|void	|set_numeric_standard
Apd	|void	|require_pv	|const char* pv
p	|void	|pidgone	|Pid_t pid|int status
Ap	|void	|pmflag		|U16* pmfl|int ch
p	|OP*	|pmruntime	|OP* pm|OP* expr|OP* repl
p	|OP*	|pmtrans	|OP* o|OP* expr|OP* repl
p	|OP*	|pop_return
Ap	|void	|pop_scope
p	|OP*	|prepend_elem	|I32 optype|OP* head|OP* tail
p	|void	|push_return	|OP* o
Ap	|void	|push_scope
p	|OP*	|ref		|OP* o|I32 type
p	|OP*	|refkids	|OP* o|I32 type
Ap	|void	|regdump	|regexp* r
Ap	|I32	|pregexec	|regexp* prog|char* stringarg \
				|char* strend|char* strbeg|I32 minend \
				|SV* screamer|U32 nosave
Ap	|void	|pregfree	|struct regexp* r
Ap	|regexp*|pregcomp	|char* exp|char* xend|PMOP* pm
Ap	|char*	|re_intuit_start|regexp* prog|SV* sv|char* strpos \
				|char* strend|U32 flags \
				|struct re_scream_pos_data_s *data
Ap	|SV*	|re_intuit_string|regexp* prog
Ap	|I32	|regexec_flags	|regexp* prog|char* stringarg \
				|char* strend|char* strbeg|I32 minend \
				|SV* screamer|void* data|U32 flags
Ap	|regnode*|regnext	|regnode* p
p	|void	|regprop	|SV* sv|regnode* o
Ap	|void	|repeatcpy	|char* to|const char* from|I32 len|I32 count
Ap	|char*	|rninstr	|const char* big|const char* bigend \
				|const char* little|const char* lend
Ap	|Sighandler_t|rsignal	|int i|Sighandler_t t
p	|int	|rsignal_restore|int i|Sigsave_t* t
p	|int	|rsignal_save	|int i|Sighandler_t t1|Sigsave_t* t2
p	|Sighandler_t|rsignal_state|int i
p	|void	|rxres_free	|void** rsp
p	|void	|rxres_restore	|void** rsp|REGEXP* prx
p	|void	|rxres_save	|void** rsp|REGEXP* prx
#if !defined(HAS_RENAME)
p	|I32	|same_dirent	|char* a|char* b
#endif
Apd	|char*	|savepv		|const char* sv
Apd	|char*	|savepvn	|const char* sv|I32 len
Ap	|void	|savestack_grow
Ap	|void	|save_aelem	|AV* av|I32 idx|SV **sptr
Ap	|I32	|save_alloc	|I32 size|I32 pad
Ap	|void	|save_aptr	|AV** aptr
Ap	|AV*	|save_ary	|GV* gv
Ap	|void	|save_clearsv	|SV** svp
Ap	|void	|save_delete	|HV* hv|char* key|I32 klen
Ap	|void	|save_destructor|DESTRUCTORFUNC_NOCONTEXT_t f|void* p
Ap	|void	|save_destructor_x|DESTRUCTORFUNC_t f|void* p
Ap	|void	|save_freesv	|SV* sv
p	|void	|save_freeop	|OP* o
Ap	|void	|save_freepv	|char* pv
Ap	|void	|save_generic_svref|SV** sptr
Ap	|void	|save_generic_pvref|char** str
Ap	|void	|save_gp	|GV* gv|I32 empty
Ap	|HV*	|save_hash	|GV* gv
Ap	|void	|save_helem	|HV* hv|SV *key|SV **sptr
Ap	|void	|save_hints
Ap	|void	|save_hptr	|HV** hptr
Ap	|void	|save_I16	|I16* intp
Ap	|void	|save_I32	|I32* intp
Ap	|void	|save_I8	|I8* bytep
Ap	|void	|save_int	|int* intp
Ap	|void	|save_item	|SV* item
Ap	|void	|save_iv	|IV* iv
Ap	|void	|save_list	|SV** sarg|I32 maxsarg
Ap	|void	|save_long	|long* longp
Ap	|void	|save_mortalizesv|SV* sv
Ap	|void	|save_nogv	|GV* gv
p	|void	|save_op
Ap	|SV*	|save_scalar	|GV* gv
Ap	|void	|save_pptr	|char** pptr
Ap	|void	|save_vptr	|void* pptr
Ap	|void	|save_re_context
Ap	|void	|save_padsv	|PADOFFSET off
Ap	|void	|save_sptr	|SV** sptr
Ap	|SV*	|save_svref	|SV** sptr
Ap	|SV**	|save_threadsv	|PADOFFSET i
p	|OP*	|sawparens	|OP* o
p	|OP*	|scalar		|OP* o
p	|OP*	|scalarkids	|OP* o
p	|OP*	|scalarseq	|OP* o
p	|OP*	|scalarvoid	|OP* o
Ap	|NV	|scan_bin	|char* start|STRLEN len|STRLEN* retlen
Ap	|NV	|scan_hex	|char* start|STRLEN len|STRLEN* retlen
Ap	|char*	|scan_num	|char* s|YYSTYPE *lvalp
Ap	|NV	|scan_oct	|char* start|STRLEN len|STRLEN* retlen
p	|OP*	|scope		|OP* o
Ap	|char*	|screaminstr	|SV* bigsv|SV* littlesv|I32 start_shift \
				|I32 end_shift|I32 *state|I32 last
#if !defined(VMS)
p	|I32	|setenv_getix	|char* nam
#endif
p	|void	|setdefout	|GV* gv
Ap	|char*	|sharepvn	|const char* sv|I32 len|U32 hash
p	|HEK*	|share_hek	|const char* sv|I32 len|U32 hash
np	|Signal_t |sighandler	|int sig
Ap	|SV**	|stack_grow	|SV** sp|SV**p|int n
Ap	|I32	|start_subparse	|I32 is_format|U32 flags
p	|void	|sub_crush_depth|CV* cv
Ap	|bool	|sv_2bool	|SV* sv
Ap	|CV*	|sv_2cv		|SV* sv|HV** st|GV** gvp|I32 lref
Ap	|IO*	|sv_2io		|SV* sv
Ap	|IV	|sv_2iv		|SV* sv
Apd	|SV*	|sv_2mortal	|SV* sv
Ap	|NV	|sv_2nv		|SV* sv
Ap	|char*	|sv_2pv		|SV* sv|STRLEN* lp
Ap	|char*	|sv_2pvutf8	|SV* sv|STRLEN* lp
Ap	|char*	|sv_2pvbyte	|SV* sv|STRLEN* lp
Ap	|UV	|sv_2uv		|SV* sv
Ap	|IV	|sv_iv		|SV* sv
Ap	|UV	|sv_uv		|SV* sv
Ap	|NV	|sv_nv		|SV* sv
Ap	|char*	|sv_pvn		|SV *sv|STRLEN *len
Ap	|char*	|sv_pvutf8n	|SV *sv|STRLEN *len
Ap	|char*	|sv_pvbyten	|SV *sv|STRLEN *len
Apd	|I32	|sv_true	|SV *sv
p	|void	|sv_add_arena	|char* ptr|U32 size|U32 flags
Ap	|int	|sv_backoff	|SV* sv
Apd	|SV*	|sv_bless	|SV* sv|HV* stash
Afpd	|void	|sv_catpvf	|SV* sv|const char* pat|...
Ap	|void	|sv_vcatpvf	|SV* sv|const char* pat|va_list* args
Apd	|void	|sv_catpv	|SV* sv|const char* ptr
Apd	|void	|sv_catpvn	|SV* sv|const char* ptr|STRLEN len
Apd	|void	|sv_catsv	|SV* dsv|SV* ssv
Apd	|void	|sv_chop	|SV* sv|char* ptr
p	|I32	|sv_clean_all
p	|void	|sv_clean_objs
Apd	|void	|sv_clear	|SV* sv
Apd	|I32	|sv_cmp		|SV* sv1|SV* sv2
Apd	|I32	|sv_cmp_locale	|SV* sv1|SV* sv2
#if defined(USE_LOCALE_COLLATE)
Ap	|char*	|sv_collxfrm	|SV* sv|STRLEN* nxp
#endif
Ap	|OP*	|sv_compile_2op	|SV* sv|OP** startp|char* code|AV** avp
Apd	|void	|sv_dec		|SV* sv
Ap	|void	|sv_dump	|SV* sv
Apd	|bool	|sv_derived_from|SV* sv|const char* name
Apd	|I32	|sv_eq		|SV* sv1|SV* sv2
Apd	|void	|sv_free	|SV* sv
p	|void	|sv_free_arenas
Apd	|char*	|sv_gets	|SV* sv|PerlIO* fp|I32 append
Apd	|char*	|sv_grow	|SV* sv|STRLEN newlen
Apd	|void	|sv_inc		|SV* sv
Apd	|void	|sv_insert	|SV* bigsv|STRLEN offset|STRLEN len \
				|char* little|STRLEN littlelen
Apd	|int	|sv_isa		|SV* sv|const char* name
Apd	|int	|sv_isobject	|SV* sv
Apd	|STRLEN	|sv_len		|SV* sv
Apd	|STRLEN	|sv_len_utf8	|SV* sv
Apd	|void	|sv_magic	|SV* sv|SV* obj|int how|const char* name \
				|I32 namlen
Apd	|SV*	|sv_mortalcopy	|SV* oldsv
Apd	|SV*	|sv_newmortal
Ap	|SV*	|sv_newref	|SV* sv
Ap	|char*	|sv_peek	|SV* sv
Ap	|void	|sv_pos_u2b	|SV* sv|I32* offsetp|I32* lenp
Ap	|void	|sv_pos_b2u	|SV* sv|I32* offsetp
Apd	|char*	|sv_pvn_force	|SV* sv|STRLEN* lp
Apd	|char*	|sv_pvutf8n_force|SV* sv|STRLEN* lp
Ap	|char*	|sv_pvbyten_force|SV* sv|STRLEN* lp
Apd	|char*	|sv_reftype	|SV* sv|int ob
Apd	|void	|sv_replace	|SV* sv|SV* nsv
Ap	|void	|sv_report_used
Ap	|void	|sv_reset	|char* s|HV* stash
Afpd	|void	|sv_setpvf	|SV* sv|const char* pat|...
Ap	|void	|sv_vsetpvf	|SV* sv|const char* pat|va_list* args
Apd	|void	|sv_setiv	|SV* sv|IV num
Apd	|void	|sv_setpviv	|SV* sv|IV num
Apd	|void	|sv_setuv	|SV* sv|UV num
Apd	|void	|sv_setnv	|SV* sv|NV num
Apd	|SV*	|sv_setref_iv	|SV* rv|const char* classname|IV iv
Apd	|SV*	|sv_setref_nv	|SV* rv|const char* classname|NV nv
Apd	|SV*	|sv_setref_pv	|SV* rv|const char* classname|void* pv
Apd	|SV*	|sv_setref_pvn	|SV* rv|const char* classname|char* pv \
				|STRLEN n
Apd	|void	|sv_setpv	|SV* sv|const char* ptr
Apd	|void	|sv_setpvn	|SV* sv|const char* ptr|STRLEN len
Apd	|void	|sv_setsv	|SV* dsv|SV* ssv
Ap	|void	|sv_taint	|SV* sv
Ap	|bool	|sv_tainted	|SV* sv
Apd	|int	|sv_unmagic	|SV* sv|int type
Apd	|void	|sv_unref	|SV* sv
Ap	|void	|sv_untaint	|SV* sv
Apd	|bool	|sv_upgrade	|SV* sv|U32 mt
Apd	|void	|sv_usepvn	|SV* sv|char* ptr|STRLEN len
Apd	|void	|sv_vcatpvfn	|SV* sv|const char* pat|STRLEN patlen \
				|va_list* args|SV** svargs|I32 svmax \
				|bool *maybe_tainted
Apd	|void	|sv_vsetpvfn	|SV* sv|const char* pat|STRLEN patlen \
				|va_list* args|SV** svargs|I32 svmax \
				|bool *maybe_tainted
Ap	|NV	|str_to_version	|SV *sv
Ap	|SV*	|swash_init	|char* pkg|char* name|SV* listsv \
				|I32 minbits|I32 none
Ap	|UV	|swash_fetch	|SV *sv|U8 *ptr
Ap	|void	|taint_env
Ap	|void	|taint_proper	|const char* f|const char* s
Ap	|UV	|to_utf8_lower	|U8 *p
Ap	|UV	|to_utf8_upper	|U8 *p
Ap	|UV	|to_utf8_title	|U8 *p
#if defined(UNLINK_ALL_VERSIONS)
Ap	|I32	|unlnk		|char* f
#endif
#if defined(USE_THREADS)
Ap	|void	|unlock_condpair|void* svv
#endif
Ap	|void	|unsharepvn	|const char* sv|I32 len|U32 hash
p	|void	|unshare_hek	|HEK* hek
p	|void	|utilize	|int aver|I32 floor|OP* version|OP* id|OP* arg
ApM	|U8*	|utf16_to_utf8	|U8* p|U8 *d|I32 bytelen|I32 *newlen
ApM	|U8*	|utf16_to_utf8_reversed|U8* p|U8 *d|I32 bytelen|I32 *newlen
ApMd	|STRLEN	|utf8_length	|U8* s|U8 *e
ApMd	|IV	|utf8_distance	|U8 *a|U8 *b
ApMd	|U8*	|utf8_hop	|U8 *s|I32 off
ApMd	|U8*	|utf8_to_bytes	|U8 *s|STRLEN *len
ApMd	|U8*	|bytes_from_utf8|U8 *s|STRLEN *len|bool *is_utf8
ApMd	|U8*	|bytes_to_utf8	|U8 *s|STRLEN *len
ApMd	|UV	|utf8_to_uv_simple|U8 *s|STRLEN* retlen
ApMd	|UV	|utf8_to_uv	|U8 *s|STRLEN curlen|STRLEN* retlen|U32 flags
ApMd	|U8*	|uv_to_utf8	|U8 *d|UV uv
p	|void	|vivify_defelem	|SV* sv
p	|void	|vivify_ref	|SV* sv|U32 to_what
p	|I32	|wait4pid	|Pid_t pid|int* statusp|int flags
p	|void	|report_evil_fh	|GV *gv|IO *io|I32 op
p	|void	|report_uninit
Afpd	|void	|warn		|const char* pat|...
Ap	|void	|vwarn		|const char* pat|va_list* args
Afp	|void	|warner		|U32 err|const char* pat|...
Ap	|void	|vwarner	|U32 err|const char* pat|va_list* args
p	|void	|watch		|char** addr
Ap	|I32	|whichsig	|char* sig
p	|int	|yyerror	|char* s
#ifdef USE_PURE_BISON
p	|int	|yylex_r	|YYSTYPE *lvalp|int *lcharp
#endif
p	|int	|yylex
p	|int	|yyparse
p	|int	|yywarn		|char* s
#if defined(MYMALLOC)
Ap	|void	|dump_mstats	|char* s
Ap	|int	|get_mstats	|perl_mstats_t *buf|int buflen|int level
#endif
Anp	|Malloc_t|safesysmalloc	|MEM_SIZE nbytes
Anp	|Malloc_t|safesyscalloc	|MEM_SIZE elements|MEM_SIZE size
Anp	|Malloc_t|safesysrealloc|Malloc_t where|MEM_SIZE nbytes
Anp	|Free_t	|safesysfree	|Malloc_t where
#if defined(LEAKTEST)
Anp	|Malloc_t|safexmalloc	|I32 x|MEM_SIZE size
Anp	|Malloc_t|safexcalloc	|I32 x|MEM_SIZE elements|MEM_SIZE size
Anp	|Malloc_t|safexrealloc	|Malloc_t where|MEM_SIZE size
Anp	|void	|safexfree	|Malloc_t where
#endif
#if defined(PERL_GLOBAL_STRUCT)
Ap	|struct perl_vars *|GetVars
#endif
Ap	|int	|runops_standard
Ap	|int	|runops_debug
#if defined(USE_THREADS)
Ap	|SV*	|sv_lock	|SV *sv
#endif
Afpd	|void	|sv_catpvf_mg	|SV *sv|const char* pat|...
Ap	|void	|sv_vcatpvf_mg	|SV* sv|const char* pat|va_list* args
Apd	|void	|sv_catpv_mg	|SV *sv|const char *ptr
Apd	|void	|sv_catpvn_mg	|SV *sv|const char *ptr|STRLEN len
Apd	|void	|sv_catsv_mg	|SV *dstr|SV *sstr
Afpd	|void	|sv_setpvf_mg	|SV *sv|const char* pat|...
Ap	|void	|sv_vsetpvf_mg	|SV* sv|const char* pat|va_list* args
Apd	|void	|sv_setiv_mg	|SV *sv|IV i
Apd	|void	|sv_setpviv_mg	|SV *sv|IV iv
Apd	|void	|sv_setuv_mg	|SV *sv|UV u
Apd	|void	|sv_setnv_mg	|SV *sv|NV num
Apd	|void	|sv_setpv_mg	|SV *sv|const char *ptr
Apd	|void	|sv_setpvn_mg	|SV *sv|const char *ptr|STRLEN len
Apd	|void	|sv_setsv_mg	|SV *dstr|SV *sstr
Apd	|void	|sv_usepvn_mg	|SV *sv|char *ptr|STRLEN len
Ap	|MGVTBL*|get_vtbl	|int vtbl_id
p	|char*	|pv_display	|SV *sv|char *pv|STRLEN cur|STRLEN len \
				|STRLEN pvlim
Afp	|void	|dump_indent	|I32 level|PerlIO *file|const char* pat|...
Ap	|void	|dump_vindent	|I32 level|PerlIO *file|const char* pat \
				|va_list *args
Ap	|void	|do_gv_dump	|I32 level|PerlIO *file|char *name|GV *sv
Ap	|void	|do_gvgv_dump	|I32 level|PerlIO *file|char *name|GV *sv
Ap	|void	|do_hv_dump	|I32 level|PerlIO *file|char *name|HV *sv
Ap	|void	|do_magic_dump	|I32 level|PerlIO *file|MAGIC *mg|I32 nest \
				|I32 maxnest|bool dumpops|STRLEN pvlim
Ap	|void	|do_op_dump	|I32 level|PerlIO *file|OP *o
Ap	|void	|do_pmop_dump	|I32 level|PerlIO *file|PMOP *pm
Ap	|void	|do_sv_dump	|I32 level|PerlIO *file|SV *sv|I32 nest \
				|I32 maxnest|bool dumpops|STRLEN pvlim
Ap	|void	|magic_dump	|MAGIC *mg
#if defined(PERL_FLEXIBLE_EXCEPTIONS)
Ap	|void*	|default_protect|volatile JMPENV *je|int *excpt \
				|protect_body_t body|...
Ap	|void*	|vdefault_protect|volatile JMPENV *je|int *excpt \
				|protect_body_t body|va_list *args
#endif
Ap	|void	|reginitcolors
Ap	|char*	|sv_2pv_nolen	|SV* sv
Ap	|char*	|sv_2pvutf8_nolen|SV* sv
Ap	|char*	|sv_2pvbyte_nolen|SV* sv
Ap	|char*	|sv_pv		|SV *sv
Ap	|char*	|sv_pvutf8	|SV *sv
Ap	|char*	|sv_pvbyte	|SV *sv
ApMd	|void   |sv_utf8_upgrade|SV *sv
ApMd	|bool   |sv_utf8_downgrade|SV *sv|bool fail_ok
ApMd	|void   |sv_utf8_encode |SV *sv
ApM	|bool   |sv_utf8_decode |SV *sv
Ap	|void	|sv_force_normal|SV *sv
Ap	|void	|sv_add_backref	|SV *tsv|SV *sv
Ap	|void	|sv_del_backref	|SV *sv
Ap	|void	|tmps_grow	|I32 n
Apd	|SV*	|sv_rvweaken	|SV *sv
p	|int	|magic_killbackrefs|SV *sv|MAGIC *mg
Ap	|OP*	|newANONATTRSUB	|I32 floor|OP *proto|OP *attrs|OP *block
Ap	|CV*	|newATTRSUB	|I32 floor|OP *o|OP *proto|OP *attrs|OP *block
Ap	|void	|newMYSUB	|I32 floor|OP *o|OP *proto|OP *attrs|OP *block
p	|OP *	|my_attrs	|OP *o|OP *attrs
p	|void	|boot_core_xsutils
#if defined(USE_ITHREADS)
Ap	|PERL_CONTEXT*|cx_dup	|PERL_CONTEXT* cx|I32 ix|I32 max
Ap	|PERL_SI*|si_dup	|PERL_SI* si
Ap	|ANY*	|ss_dup		|PerlInterpreter* proto_perl
Ap	|void*	|any_dup	|void* v|PerlInterpreter* proto_perl
Ap	|HE*	|he_dup		|HE* e|bool shared
Ap	|REGEXP*|re_dup		|REGEXP* r
Ap	|PerlIO*|fp_dup		|PerlIO* fp|char type
Ap	|DIR*	|dirp_dup	|DIR* dp
Ap	|GP*	|gp_dup		|GP* gp
Ap	|MAGIC*	|mg_dup		|MAGIC* mg
Ap	|SV*	|sv_dup		|SV* sstr
#if defined(HAVE_INTERP_INTERN)
Ap	|void	|sys_intern_dup	|struct interp_intern* src \
				|struct interp_intern* dst
#endif
Ap	|PTR_TBL_t*|ptr_table_new
Ap	|void*	|ptr_table_fetch|PTR_TBL_t *tbl|void *sv
Ap	|void	|ptr_table_store|PTR_TBL_t *tbl|void *oldsv|void *newsv
Ap	|void	|ptr_table_split|PTR_TBL_t *tbl
Ap	|void	|ptr_table_clear|PTR_TBL_t *tbl
Ap	|void	|ptr_table_free|PTR_TBL_t *tbl
#endif
#if defined(HAVE_INTERP_INTERN)
Ap	|void	|sys_intern_clear
Ap	|void	|sys_intern_init
#endif

#if defined(PERL_OBJECT)
protected:
#else
END_EXTERN_C
#endif

#if defined(PERL_IN_AV_C) || defined(PERL_DECL_PROT)
s	|I32	|avhv_index_sv	|SV* sv
s	|I32	|avhv_index	|AV* av|SV* sv|U32 hash
#endif

#if defined(PERL_IN_DOOP_C) || defined(PERL_DECL_PROT)
s	|I32	|do_trans_simple	|SV *sv
s	|I32	|do_trans_count		|SV *sv
s	|I32	|do_trans_complex	|SV *sv
s	|I32	|do_trans_simple_utf8	|SV *sv
s	|I32	|do_trans_count_utf8	|SV *sv
s	|I32	|do_trans_complex_utf8	|SV *sv
#endif

#if defined(PERL_IN_GV_C) || defined(PERL_DECL_PROT)
s	|void	|gv_init_sv	|GV *gv|I32 sv_type
#endif

#if defined(PERL_IN_HV_C) || defined(PERL_DECL_PROT)
s	|void	|hsplit		|HV *hv
s	|void	|hfreeentries	|HV *hv
s	|void	|more_he
s	|HE*	|new_he
s	|void	|del_he		|HE *p
s	|HEK*	|save_hek	|const char *str|I32 len|U32 hash
s	|void	|hv_magic_check	|HV *hv|bool *needs_copy|bool *needs_store
#endif

#if defined(PERL_IN_MG_C) || defined(PERL_DECL_PROT)
s	|void	|save_magic	|I32 mgs_ix|SV *sv
s	|int	|magic_methpack	|SV *sv|MAGIC *mg|char *meth
s	|int	|magic_methcall	|SV *sv|MAGIC *mg|char *meth|I32 f \
				|int n|SV *val
#endif

#if defined(PERL_IN_OP_C) || defined(PERL_DECL_PROT)
s	|I32	|list_assignment|OP *o
s	|void	|bad_type	|I32 n|char *t|char *name|OP *kid
s	|void	|cop_free	|COP *cop
s	|OP*	|modkids	|OP *o|I32 type
s	|void	|no_bareword_allowed|OP *o
s	|OP*	|no_fh_allowed	|OP *o
s	|OP*	|scalarboolean	|OP *o
s	|OP*	|too_few_arguments|OP *o|char* name
s	|OP*	|too_many_arguments|OP *o|char* name
s	|U8*	|trlist_upgrade	|U8** sp|U8** ep
s	|void	|op_clear	|OP* o
s	|void	|null		|OP* o
s	|PADOFFSET|pad_addlex	|SV* name
s	|PADOFFSET|pad_findlex	|char* name|PADOFFSET newoff|U32 seq \
				|CV* startcv|I32 cx_ix|I32 saweval|U32 flags
s	|OP*	|newDEFSVOP
s	|OP*	|new_logop	|I32 type|I32 flags|OP **firstp|OP **otherp
s	|void	|simplify_sort	|OP *o
s	|bool	|is_handle_constructor	|OP *o|I32 argnum
s	|char*	|gv_ename	|GV *gv
s	|void	|cv_dump	|CV *cv
s	|CV*	|cv_clone2	|CV *proto|CV *outside
s	|bool	|scalar_mod_type|OP *o|I32 type
s	|OP *	|my_kid		|OP *o|OP *attrs
s	|OP *	|dup_attrlist	|OP *o
s	|void	|apply_attrs	|HV *stash|SV *target|OP *attrs
#  if defined(PL_OP_SLAB_ALLOC)
s	|void*	|Slab_Alloc	|int m|size_t sz
#  endif
#endif

#if defined(PERL_IN_PERL_C) || defined(PERL_DECL_PROT)
s	|void	|find_beginning
s	|void	|forbid_setid	|char *
s	|void	|incpush	|char *|int|int
s	|void	|init_interp
s	|void	|init_ids
s	|void	|init_lexer
s	|void	|init_main_stash
s	|void	|init_perllib
s	|void	|init_postdump_symbols|int|char **|char **
s	|void	|init_predump_symbols
rs	|void	|my_exit_jump
s	|void	|nuke_stacks
s	|void	|open_script	|char *|bool|SV *|int *fd
s	|void	|usage		|char *
s	|void	|validate_suid	|char *|char*|int
#  if defined(IAMSUID)
s	|int	|fd_on_nosuid_fs|int fd
#  endif
s	|void*	|parse_body	|char **env|XSINIT_t xsinit
s	|void*	|run_body	|I32 oldscope
s	|void	|call_body	|OP *myop|int is_eval
s	|void*	|call_list_body	|CV *cv
#if defined(PERL_FLEXIBLE_EXCEPTIONS)
s	|void*	|vparse_body	|va_list args
s	|void*	|vrun_body	|va_list args
s	|void*	|vcall_body	|va_list args
s	|void*	|vcall_list_body|va_list args
#endif
#  if defined(USE_THREADS)
s	|struct perl_thread *	|init_main_thread
#  endif
#endif

#if defined(PERL_IN_PP_C) || defined(PERL_DECL_PROT)
s	|void	|doencodes	|SV* sv|char* s|I32 len
s	|SV*	|refto		|SV* sv
s	|U32	|seed
s	|SV*	|mul128		|SV *sv|U8 m
s	|SV*	|is_an_int	|char *s|STRLEN l
s	|int	|div128		|SV *pnum|bool *done
#endif

#if defined(PERL_IN_PP_CTL_C) || defined(PERL_DECL_PROT)
s	|OP*	|docatch	|OP *o
s	|void*	|docatch_body
#if defined(PERL_FLEXIBLE_EXCEPTIONS)
s	|void*	|vdocatch_body	|va_list args
#endif
s	|OP*	|dofindlabel	|OP *o|char *label|OP **opstack|OP **oplimit
s	|void	|doparseform	|SV *sv
s	|I32	|dopoptoeval	|I32 startingblock
s	|I32	|dopoptolabel	|char *label
s	|I32	|dopoptoloop	|I32 startingblock
s	|I32	|dopoptosub	|I32 startingblock
s	|I32	|dopoptosub_at	|PERL_CONTEXT* cxstk|I32 startingblock
s	|void	|save_lines	|AV *array|SV *sv
s	|OP*	|doeval		|int gimme|OP** startop
s	|PerlIO *|doopen_pmc	|const char *name|const char *mode
s	|void	|qsortsv	|SV ** array|size_t num_elts|SVCOMPARE_t f
#endif

#if defined(PERL_IN_PP_HOT_C) || defined(PERL_DECL_PROT)
s	|int	|do_maybe_phash	|AV *ary|SV **lelem|SV **firstlelem \
				|SV **relem|SV **lastrelem
s	|void	|do_oddball	|HV *hash|SV **relem|SV **firstrelem
s	|CV*	|get_db_sub	|SV **svp|CV *cv
s	|SV*	|method_common	|SV* meth|U32* hashp
#endif

#if defined(PERL_IN_PP_SYS_C) || defined(PERL_DECL_PROT)
s	|OP*	|doform		|CV *cv|GV *gv|OP *retop
s	|int	|emulate_eaccess|const char* path|Mode_t mode
#  if !defined(HAS_MKDIR) || !defined(HAS_RMDIR)
s	|int	|dooneliner	|char *cmd|char *filename
#  endif
#endif

#if defined(PERL_IN_REGCOMP_C) || defined(PERL_DECL_PROT)
s	|regnode*|reg		|I32|I32 *
s	|regnode*|reganode	|U8|U32
s	|regnode*|regatom	|I32 *
s	|regnode*|regbranch	|I32 *|I32
s	|void	|reguni		|UV|char *|STRLEN*
s	|regnode*|regclass
s	|regnode*|regclassutf8
s	|I32	|regcurly	|char *
s	|regnode*|reg_node	|U8
s	|regnode*|regpiece	|I32 *
s	|void	|reginsert	|U8|regnode *
s	|void	|regoptail	|regnode *|regnode *
s	|void	|regtail	|regnode *|regnode *
s	|char*|regwhite	|char *|char *
s	|char*|nextchar
s	|regnode*|dumpuntil	|regnode *start|regnode *node \
				|regnode *last|SV* sv|I32 l
s	|void	|put_byte	|SV* sv|int c
s	|void	|scan_commit	|struct scan_data_t *data
s	|void	|cl_anything	|struct regnode_charclass_class *cl
s	|int	|cl_is_anything	|struct regnode_charclass_class *cl
s	|void	|cl_init	|struct regnode_charclass_class *cl
s	|void	|cl_init_zero	|struct regnode_charclass_class *cl
s	|void	|cl_and		|struct regnode_charclass_class *cl \
				|struct regnode_charclass_class *and_with
s	|void	|cl_or		|struct regnode_charclass_class *cl \
				|struct regnode_charclass_class *or_with
s	|I32	|study_chunk	|regnode **scanp|I32 *deltap \
				|regnode *last|struct scan_data_t *data \
				|U32 flags
s	|I32	|add_data	|I32 n|char *s
rs	|void|re_croak2	|const char* pat1|const char* pat2|...
s	|I32	|regpposixcc	|I32 value
s	|void	|checkposixcc
#endif

#if defined(PERL_IN_REGEXEC_C) || defined(PERL_DECL_PROT)
s	|I32	|regmatch	|regnode *prog
s	|I32	|regrepeat	|regnode *p|I32 max
s	|I32	|regrepeat_hard	|regnode *p|I32 max|I32 *lp
s	|I32	|regtry		|regexp *prog|char *startpos
s	|bool	|reginclass	|regnode *p|I32 c
s	|bool	|reginclassutf8	|regnode *f|U8* p
s	|CHECKPOINT|regcppush	|I32 parenfloor
s	|char*|regcppop
s	|char*|regcp_set_to	|I32 ss
s	|void	|cache_re	|regexp *prog
s	|U8*	|reghop		|U8 *pos|I32 off
s	|U8*	|reghopmaybe	|U8 *pos|I32 off
s	|char*	|find_byclass	|regexp * prog|regnode *c|char *s|char *strend|char *startpos|I32 norun
#endif

#if defined(PERL_IN_RUN_C) || defined(PERL_DECL_PROT)
s	|void	|debprof	|OP *o
#endif

#if defined(PERL_IN_SCOPE_C) || defined(PERL_DECL_PROT)
s	|SV*	|save_scalar_at	|SV **sptr
#endif

#if defined(PERL_IN_SV_C) || defined(PERL_DECL_PROT)
s	|IV	|asIV		|SV* sv
s	|UV	|asUV		|SV* sv
s	|SV*	|more_sv
s	|void	|more_xiv
s	|void	|more_xnv
s	|void	|more_xpv
s	|void	|more_xpviv
s	|void	|more_xpvnv
s	|void	|more_xpvcv
s	|void	|more_xpvav
s	|void	|more_xpvhv
s	|void	|more_xpvmg
s	|void	|more_xpvlv
s	|void	|more_xpvbm
s	|void	|more_xrv
s	|XPVIV*	|new_xiv
s	|XPVNV*	|new_xnv
s	|XPV*	|new_xpv
s	|XPVIV*	|new_xpviv
s	|XPVNV*	|new_xpvnv
s	|XPVCV*	|new_xpvcv
s	|XPVAV*	|new_xpvav
s	|XPVHV*	|new_xpvhv
s	|XPVMG*	|new_xpvmg
s	|XPVLV*	|new_xpvlv
s	|XPVBM*	|new_xpvbm
s	|XRV*	|new_xrv
s	|void	|del_xiv	|XPVIV* p
s	|void	|del_xnv	|XPVNV* p
s	|void	|del_xpv	|XPV* p
s	|void	|del_xpviv	|XPVIV* p
s	|void	|del_xpvnv	|XPVNV* p
s	|void	|del_xpvcv	|XPVCV* p
s	|void	|del_xpvav	|XPVAV* p
s	|void	|del_xpvhv	|XPVHV* p
s	|void	|del_xpvmg	|XPVMG* p
s	|void	|del_xpvlv	|XPVLV* p
s	|void	|del_xpvbm	|XPVBM* p
s	|void	|del_xrv	|XRV* p
s	|void	|sv_unglob	|SV* sv
s	|void	|not_a_number	|SV *sv
s	|I32	|visit		|SVFUNC_t f
#  if defined(DEBUGGING)
s	|void	|del_sv	|SV *p
#  endif
#endif

#if defined(PERL_IN_TOKE_C) || defined(PERL_DECL_PROT)
s	|void	|check_uni
s	|void	|force_next	|I32 type
s	|char*	|force_version	|char *start
s	|char*	|force_word	|char *start|int token|int check_keyword \
				|int allow_pack|int allow_tick
s	|SV*	|tokeq		|SV *sv
s	|char*	|scan_const	|char *start
s	|char*	|scan_formline	|char *s
s	|char*	|scan_heredoc	|char *s
s	|char*	|scan_ident	|char *s|char *send|char *dest \
				|STRLEN destlen|I32 ck_uni
s	|char*	|scan_inputsymbol|char *start
s	|char*	|scan_pat	|char *start|I32 type
s	|char*	|scan_str	|char *start|int keep_quoted|int keep_delims
s	|char*	|scan_subst	|char *start
s	|char*	|scan_trans	|char *start
s	|char*	|scan_word	|char *s|char *dest|STRLEN destlen \
				|int allow_package|STRLEN *slp
s	|char*	|skipspace	|char *s
s	|char*	|swallow_bom	|U8 *s
s	|void	|checkcomma	|char *s|char *name|char *what
s	|void	|force_ident	|char *s|int kind
s	|void	|incline	|char *s
s	|int	|intuit_method	|char *s|GV *gv
s	|int	|intuit_more	|char *s
s	|I32	|lop		|I32 f|int x|char *s
s	|void	|missingterm	|char *s
s	|void	|no_op		|char *what|char *s
s	|void	|set_csh
s	|I32	|sublex_done
s	|I32	|sublex_push
s	|I32	|sublex_start
s	|char *	|filter_gets	|SV *sv|PerlIO *fp|STRLEN append
s	|HV *	|find_in_my_stash|char *pkgname|I32 len
s	|SV*	|new_constant	|char *s|STRLEN len|const char *key|SV *sv \
				|SV *pv|const char *type
s	|int	|ao		|int toketype
s	|void	|depcom
s	|char*	|incl_perldb
#if 0
s	|I32	|utf16_textfilter|int idx|SV *sv|int maxlen
s	|I32	|utf16rev_textfilter|int idx|SV *sv|int maxlen
#endif
#  if defined(CRIPPLED_CC)
s	|int	|uni		|I32 f|char *s
#  endif
#  if defined(PERL_CR_FILTER)
s	|I32	|cr_textfilter	|int idx|SV *sv|int maxlen
#  endif
#endif

#if defined(PERL_IN_UNIVERSAL_C) || defined(PERL_DECL_PROT)
s	|SV*|isa_lookup	|HV *stash|const char *name|int len|int level
#endif

#if defined(PERL_IN_UTIL_C) || defined(PERL_DECL_PROT)
s	|char*	|stdize_locale	|char* locs
s	|SV*	|mess_alloc
#  if defined(LEAKTEST)
s	|void	|xstat		|int
#  endif
#endif

#if defined(PERL_OBJECT)
};
#endif
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d28 1
d202 1
d921 3
d1072 10
d1096 3
a1098 4
sub autodoc ($) { # parse a file and extract documentation info
    my($fh) = @@_;
    my($in, $doc);

d1101 1
d1109 1
d1111 4
d1120 1
a1120 1
		    $apidocs{$name} = [$flags, $docs, $ret, @@args];
d1123 1
a1123 1
		    $gutsdocs{$name} = [$flags, $docs, $ret, @@args];
d1127 1
a1127 1
		$docfuncs{$name} = [$flags, $docs, $ret, @@args];
d1129 7
a1135 3
	    if ($doc =~ /^=for/) {
		$in = $doc;
		redo FUNC;
d1143 1
a1143 1
    my($flags, $docs, $ret, @@args) = @@$docref;
d1145 2
d1163 1
d1169 1
a1169 1
    autodoc(\*F);
d1186 3
a1188 1
	    $apidocs{$func} = [$docref->[0] . 'A', $docref->[1], $retval, @@args];
d1191 2
a1192 1
	    $gutsdocs{$func} = [$docref->[0], $docref->[1], $retval, @@args];
d1199 2
d1270 1
a1270 1
Perl intrepreter that are documented using Perl's internal documentation
d1287 1
a1287 1
The autodocumentation system was orignally added to the Perl core by 
d1320 1
d1394 1
d1403 2
a1404 2
Ap	|SV*	|av_delete	|AV* ar|I32 key|I32 flags
Ap	|bool	|av_exists	|AV* ar|I32 key
d1406 1
a1406 1
Ap	|AV*	|av_fake	|I32 size|SV** svp
d1408 1
a1408 1
Ap	|void	|av_fill	|AV* ar|I32 fill
d1413 1
a1413 1
Ap	|void	|av_reify	|AV* ar
d1443 1
a1443 1
Afnp	|void	|load_module_nocontext|U32 flags|SV* name|SV* ver|...
d1453 1
d1485 1
a1485 1
Ap	|int	|do_binmode	|PerlIO *fp|int iotype|int flag
d1502 1
a1502 1
p	|void	|do_join	|SV* sv|SV* del|SV** mark|SV** sp
d1549 1
a1549 1
p	|char*	|getenv_len	|char* key|unsigned long *len
d1561 1
d1571 1
d1607 2
d1643 2
a1644 1
Ap	|int	|is_utf8_char	|U8 *p
d1668 1
a1668 1
Afp	|void	|load_module|U32 flags|SV* name|SV* ver|...
d1697 1
d1868 3
a1870 3
Ap	|void	|new_collate	|const char* newcoll
Ap	|void	|new_ctype	|const char* newctype
Ap	|void	|new_numeric	|const char* newcoll
d1904 1
a1904 1
p	|Sighandler_t|rsignal	|int i|Sighandler_t t
d1929 1
d1943 1
d1950 1
d1959 4
a1962 4
Ap	|NV	|scan_bin	|char* start|I32 len|I32* retlen
Ap	|NV	|scan_hex	|char* start|I32 len|I32* retlen
Ap	|char*	|scan_num	|char* s
Ap	|NV	|scan_oct	|char* start|I32 len|I32* retlen
d1992 1
a1992 1
Ap	|I32	|sv_true	|SV *sv
d2002 1
a2002 1
p	|void	|sv_clean_all
d2004 1
a2004 1
Ap	|void	|sv_clear	|SV* sv
d2006 1
a2006 1
Ap	|I32	|sv_cmp_locale	|SV* sv1|SV* sv2
d2015 1
a2015 1
Ap	|void	|sv_free	|SV* sv
d2017 1
a2017 1
Ap	|char*	|sv_gets	|SV* sv|PerlIO* fp|I32 append
d2025 1
a2025 1
Ap	|STRLEN	|sv_len_utf8	|SV* sv
d2034 2
a2035 2
Ap	|char*	|sv_pvn_force	|SV* sv|STRLEN* lp
Ap	|char*	|sv_pvutf8n_force|SV* sv|STRLEN* lp
d2037 2
a2038 2
Ap	|char*	|sv_reftype	|SV* sv|int ob
Ap	|void	|sv_replace	|SV* sv|SV* nsv
d2057 1
a2057 1
Ap	|int	|sv_unmagic	|SV* sv|int type
d2086 11
a2096 6
Ap	|U8*	|utf16_to_utf8	|U16* p|U8 *d|I32 bytelen
Ap	|U8*	|utf16_to_utf8_reversed|U16* p|U8 *d|I32 bytelen
Ap	|I32	|utf8_distance	|U8 *a|U8 *b
Ap	|U8*	|utf8_hop	|U8 *s|I32 off
Ap	|UV	|utf8_to_uv	|U8 *s|I32* retlen
Ap	|U8*	|uv_to_utf8	|U8 *d|UV uv
d2100 1
a2100 1
p	|void	|report_closed_fh|GV *gv|IO *io|const char *func|const char *obj
d2107 1
a2107 1
p	|I32	|whichsig	|char* sig
d2109 3
a2111 3
#if defined(USE_PURE_BISON)
p	|int	|yylex		|YYSTYPE *lvalp|int *lcharp
#else
a2112 1
#endif
d2134 3
d2181 4
a2184 4
Ap      |void   |sv_utf8_upgrade|SV *sv
Ap      |bool   |sv_utf8_downgrade|SV *sv|bool fail_ok
Ap      |void   |sv_utf8_encode |SV *sv
Ap      |bool   |sv_utf8_decode |SV *sv
d2186 2
d2189 1
a2189 1
Ap	|SV*	|sv_rvweaken	|SV *sv
d2216 6
d2236 6
a2241 10
s	|I32	|do_trans_CC_simple	|SV *sv
s	|I32	|do_trans_CC_count	|SV *sv
s	|I32	|do_trans_CC_complex	|SV *sv
s	|I32	|do_trans_UU_simple	|SV *sv
s	|I32	|do_trans_UU_count	|SV *sv
s	|I32	|do_trans_UU_complex	|SV *sv
s	|I32	|do_trans_UC_simple	|SV *sv
s	|I32	|do_trans_CU_simple	|SV *sv
s	|I32	|do_trans_UC_trivial	|SV *sv
s	|I32	|do_trans_CU_trivial	|SV *sv
d2275 1
a2352 1
s	|void	|free_closures
d2380 1
a2380 1
s	|void	|reguni		|UV|char *|I32*
d2478 1
a2478 3
s	|void	|visit		|SVFUNC_t f
s	|void	|sv_add_backref	|SV *tsv|SV *sv
s	|void	|sv_del_backref	|SV *sv
d2504 1
d2518 1
d2541 1
@


1.3
log
@perl5.005_03 (stock)
@
text
@d3 179
a181 1
require 5.003;
d190 1
a204 1
    %$syms = ();
d211 4
a214 1
	    $$syms{$1} = 1;
d220 2
a221 1
readsyms %global, 'global.sym';
d223 2
a224 3
sub readvars(\%$$) {
    my ($syms, $file,$pre) = @@_;
    %$syms = ();
d230 6
a235 2
	if (/PERLVARI?C?\($pre(\w+)/) {
	    $$syms{$1} = 1;
d248 3
a250 17
foreach my $sym (sort keys %intrp)
 {
  if (exists $global{$sym})
   {
    delete $global{$sym};
    warn "$sym in global.sym as well as intrpvar.h\n";
   }
 }

foreach my $sym (sort keys %globvar)
 {
  if (exists $global{$sym})
   {
    delete $global{$sym};
    warn "$sym in global.sym as well as perlvars.h\n";
   }
 }
d252 4
a255 9
foreach my $sym (sort keys %thread)
 {
  warn "$sym in intrpvar.h as well as thrdvar.h\n" if exists $intrp{$sym};
  if (exists $global{$sym})
   {
    delete $global{$sym};
    warn "$sym in global.sym as well as thrdvar.h\n";
   }
 }
d262 5
a266 8
sub embed ($) {
    my ($sym) = @@_;
    hide($sym, "Perl_$sym");
}
sub embedvar ($) {
    my ($sym) = @@_;
#   hide($sym, "Perl_$sym");
    return '';
d273 1
d280 1
a280 2
open(EM, '> embed.h')
    or die "Can't create embed.h: $!\n";
d284 2
a285 2
   This file is built by embed.pl from global.sym, intrpvar.h,
   and thrdvar.h.  Any changes made here will be lost!
d290 36
a325 8
/*  EMBED has no run-time penalty, but helps keep the Perl namespace
    from colliding with that used by other libraries pulled in
    by extensions or by embedding perl.  Allow a cc -DNO_EMBED
    override, however, to keep binary compatability with previous
    versions of perl.
*/
#ifndef NO_EMBED
#  define EMBED 1 
d328 1
a328 1
/* Hide global symbols? */
d330 2
a331 1
#ifdef EMBED
d335 84
a418 2
for $sym (sort keys %global) {
    print EM embed($sym);
d423 112
a534 1
#endif /* EMBED */
d546 2
a547 2
   This file is built by embed.pl from global.sym, intrpvar.h,
   and thrdvar.h.  Any changes made here will be lost!
d552 9
a560 6
/*  EMBED has no run-time penalty, but helps keep the Perl namespace
    from colliding with that used by other libraries pulled in
    by extensions or by embedding perl.  Allow a cc -DNO_EMBED
    override, however, to keep binary compatability with previous
    versions of perl.
*/
d562 1
d564 3
a566 1
/* Put interpreter-specific symbols into a struct? */
d568 2
a569 1
#ifdef MULTIPLICITY
d571 5
a575 2
#ifndef USE_THREADS
/* If we do not have threads then per-thread vars are per-interpreter */
d580 1
a580 1
    print EM multon($sym,'T','PL_curinterp->');
d585 3
a587 1
#endif /* !USE_THREADS */
d589 2
a590 1
/* These are always per-interpreter if there is more than one */
d595 1
a595 1
    print EM multon($sym,'I','PL_curinterp->');
d600 2
a601 1
#else	/* !MULTIPLICITY */
d606 1
a606 1
    print EM multoff($sym,'I');
d611 6
a616 1
#ifndef USE_THREADS
d621 6
a626 1
    print EM multoff($sym,'T');
d631 1
a631 3
#endif /* USE_THREADS */

/* Hide what would have been interpreter-specific symbols? */
d633 1
a633 1
#ifdef EMBED
d638 1
a638 1
    print EM embedvar($sym);
d643 2
a644 1
#ifndef USE_THREADS
d649 1
a649 1
    print EM embedvar($sym);
d654 2
a655 7
#endif /* USE_THREADS */
#endif /* EMBED */
#endif /* MULTIPLICITY */

/* Now same trickey for per-thread variables */

#ifdef USE_THREADS
d660 1
a660 1
    print EM multon($sym,'T','thr->');
d665 3
a667 1
#endif /* USE_THREADS */
d669 1
a669 1
#ifdef PERL_GLOBAL_STRUCT
d689 3
a691 1
#ifdef EMBED
d695 2
a696 2
for $sym (sort keys %globvar) {
    print EM embedvar($sym);
d701 533
a1233 2
#endif /* EMBED */
#endif /* PERL_GLOBAL_STRUCT */
d1235 1
a1235 1
END
d1237 4
a1240 1
print EM <<'END';
d1242 1
a1242 1
#ifndef MIN_PERL_DEFINE  
d1246 2
a1247 2
for $sym (sort @@extvars) {
    print EM hide($sym,"PL_$sym");
d1250 12
a1261 1
print EM <<'END';
a1262 1
#endif /* MIN_PERL_DEFINE */
d1265 927
d2193 302
a2494 1
close(EM);
@


1.2
log
@perl 5.004_04
@
text
@d5 19
d40 50
a89 2
readsyms %interp, 'interp.sym';
readsyms %compat3, 'compat3.sym';
d100 1
a100 1
sub multon ($) {
d102 2
a103 1
    hide($sym, "(curinterp->I$sym)");
d105 8
a112 3
sub multoff ($) {
    my ($sym) = @@_;
    hide("I$sym", $sym);
d121 2
a122 2
   This file is built by embed.pl from global.sym, interp.sym,
   and compat3.sym.  Any changes made here will be lost!
d144 1
a144 1
    print EM embed($sym) unless $compat3{$sym};
d149 1
a149 1
/* Hide global symbols that 5.003 revealed? */
d151 1
a151 1
#ifndef BINCOMPAT3
d153 1
a153 1
END
d155 3
a157 3
for $sym (sort keys %global) {
    print EM embed($sym) if $compat3{$sym};
}
d160 6
d167 6
a172 1
#endif /* !BINCOMPAT3 */
a173 1
#endif /* EMBED */
d179 15
d196 2
a197 2
for $sym (sort keys %interp) {
    print EM multon($sym);
d206 12
a217 2
for $sym (sort keys %interp) {
    print EM multoff($sym);
d222 3
a224 1
/* Hide interpreter-specific symbols? */
d230 28
a257 2
for $sym (sort keys %interp) {
    print EM embed($sym) if $compat3{$sym};
d262 11
a272 1
/* Hide interpreter symbols that 5.003 revealed? */
d274 1
a274 1
#ifndef BINCOMPAT3
d278 2
a279 2
for $sym (sort keys %interp) {
    print EM embed($sym) unless $compat3{$sym};
d284 9
a292 1
#endif /* !BINCOMPAT3 */
d295 9
d305 7
a311 1
#endif /* MULTIPLICITY */
d314 2
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
#!/usr/bin/perl
d3 42
a44 1
open(EM, ">embed.h") || die "Can't create embed.h: $!\n";
d47 4
a50 1
/* This file is derived from global.sym and interp.sym */
d64 2
a67 1
/* globals we need to hide from the world */
d70 5
a74 1
open(GL, "<global.sym") || die "Can't open global.sym: $!\n";
d76 8
a83 6
while(<GL>) {
	s/[ \t]*#.*//;		# Delete comments.
	next unless /\S/;
	s/(.*)/#define $1\t\tPerl_$1/;
	s/(................\t)\t/$1/;
	print EM $_;
d86 1
a86 1
close(GL) || warn "Can't close global.sym: $!\n";
d88 1
a88 1
print EM <<'END';
d92 1
a92 1
/* Put interpreter specific symbols into a struct? */
d98 24
a121 7
open(INT, "<interp.sym") || die "Can't open interp.sym: $!\n";
while (<INT>) {
	s/[ \t]*#.*//;		# Delete comments.
	next unless /\S/;
	s/(.*)/#define $1\t\t(curinterp->I$1)/;
	s/(................\t)\t/$1/;
	print EM $_;
a122 1
close(INT) || warn "Can't close interp.sym: $!\n";
d126 3
a128 1
#else	/* not multiple, so translate interpreter symbols the other way... */
d132 2
a133 7
open(INT, "<interp.sym") || die "Can't open interp.sym: $!\n";
while (<INT>) {
	s/[ \t]*#.*//;		# Delete comments.
	next unless /\S/;
	s/(.*)/#define I$1\t\t$1/;
	s/(................\t)\t/$1/;
	print EM $_;
a134 1
close(INT) || warn "Can't close interp.sym: $!\n";
d137 4
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d1 1
a1 1
#!/usr/bin/perl -w
d3 1
a3 115
require 5.003;

# XXX others that may need adding
#       warnhook
#       hints
#       copline
my @@extvars = qw(sv_undef sv_yes sv_no na dowarn
                 curcop compiling 
                 tainting tainted stack_base stack_sp sv_arenaroot
                 curstash DBsub DBsingle debstash
                 rsfp 
                 stdingv
		 defgv
		 errgv
		 rsfp_filters
		 perldb
		 diehook
		 dirty
		 perl_destruct_level
                );

sub readsyms (\%$) {
    my ($syms, $file) = @@_;
    %$syms = ();
    local (*FILE, $_);
    open(FILE, "< $file")
	or die "embed.pl: Can't open $file: $!\n";
    while (<FILE>) {
	s/[ \t]*#.*//;		# Delete comments.
	if (/^\s*(\S+)\s*$/) {
	    $$syms{$1} = 1;
	}
    }
    close(FILE);
}

readsyms %global, 'global.sym';

sub readvars(\%$$) {
    my ($syms, $file,$pre) = @@_;
    %$syms = ();
    local (*FILE, $_);
    open(FILE, "< $file")
	or die "embed.pl: Can't open $file: $!\n";
    while (<FILE>) {
	s/[ \t]*#.*//;		# Delete comments.
	if (/PERLVARI?C?\($pre(\w+)/) {
	    $$syms{$1} = 1;
	}
    }
    close(FILE);
}

my %intrp;
my %thread;

readvars %intrp,  'intrpvar.h','I';
readvars %thread, 'thrdvar.h','T';
readvars %globvar, 'perlvars.h','G';

foreach my $sym (sort keys %intrp)
 {
  if (exists $global{$sym})
   {
    delete $global{$sym};
    warn "$sym in global.sym as well as intrpvar.h\n";
   }
 }

foreach my $sym (sort keys %globvar)
 {
  if (exists $global{$sym})
   {
    delete $global{$sym};
    warn "$sym in global.sym as well as perlvars.h\n";
   }
 }

foreach my $sym (sort keys %thread)
 {
  warn "$sym in intrpvar.h as well as thrdvar.h\n" if exists $intrp{$sym};
  if (exists $global{$sym})
   {
    delete $global{$sym};
    warn "$sym in global.sym as well as thrdvar.h\n";
   }
 }

sub hide ($$) {
    my ($from, $to) = @@_;
    my $t = int(length($from) / 8);
    "#define $from" . "\t" x ($t < 3 ? 3 - $t : 1) . "$to\n";
}
sub embed ($) {
    my ($sym) = @@_;
    hide($sym, "Perl_$sym");
}
sub embedvar ($) {
    my ($sym) = @@_;
#   hide($sym, "Perl_$sym");
    return '';
}

sub multon ($$$) {
    my ($sym,$pre,$ptr) = @@_;
    hide("PL_$sym", "($ptr$pre$sym)");
}
sub multoff ($$) {
    my ($sym,$pre) = @@_;
    return hide("PL_$pre$sym", "PL_$sym");
}

unlink 'embed.h';
open(EM, '> embed.h')
    or die "Can't create embed.h: $!\n";
d6 1
a6 4
/* !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!! 
   This file is built by embed.pl from global.sym, intrpvar.h,
   and thrdvar.h.  Any changes made here will be lost!
*/
a19 2
/* Hide global symbols? */

d22 1
d25 8
a32 2
for $sym (sort keys %global) {
    print EM embed($sym);
d35 2
d41 1
a41 25
END

close(EM);

unlink 'embedvar.h';
open(EM, '> embedvar.h')
    or die "Can't create embedvar.h: $!\n";

print EM <<'END';
/* !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!! 
   This file is built by embed.pl from global.sym, intrpvar.h,
   and thrdvar.h.  Any changes made here will be lost!
*/

/* (Doing namespace management portably in C is really gross.) */

/*  EMBED has no run-time penalty, but helps keep the Perl namespace
    from colliding with that used by other libraries pulled in
    by extensions or by embedding perl.  Allow a cc -DNO_EMBED
    override, however, to keep binary compatability with previous
    versions of perl.
*/


/* Put interpreter-specific symbols into a struct? */
a44 3
#ifndef USE_THREADS
/* If we do not have threads then per-thread vars are per-interpreter */

d47 7
a53 2
for $sym (sort keys %thread) {
    print EM multon($sym,'T','PL_curinterp->');
d55 1
d59 1
a59 3
#endif /* !USE_THREADS */

/* These are always per-interpreter if there is more than one */
d63 7
a69 36
for $sym (sort keys %intrp) {
    print EM multon($sym,'I','PL_curinterp->');
}

print EM <<'END';

#else	/* !MULTIPLICITY */

END

for $sym (sort keys %intrp) {
    print EM multoff($sym,'I');
}

print EM <<'END';

#ifndef USE_THREADS

END

for $sym (sort keys %thread) {
    print EM multoff($sym,'T');
}

print EM <<'END';

#endif /* USE_THREADS */

/* Hide what would have been interpreter-specific symbols? */

#ifdef EMBED

END

for $sym (sort keys %intrp) {
    print EM embedvar($sym);
d71 1
a74 12
#ifndef USE_THREADS

END

for $sym (sort keys %thread) {
    print EM embedvar($sym);
}

print EM <<'END';

#endif /* USE_THREADS */
#endif /* EMBED */
a75 54

/* Now same trickey for per-thread variables */

#ifdef USE_THREADS

END

for $sym (sort keys %thread) {
    print EM multon($sym,'T','thr->');
}

print EM <<'END';

#endif /* USE_THREADS */

#ifdef PERL_GLOBAL_STRUCT

END

for $sym (sort keys %globvar) {
    print EM multon($sym,'G','PL_Vars.');
}

print EM <<'END';

#else /* !PERL_GLOBAL_STRUCT */

END

for $sym (sort keys %globvar) {
    print EM multoff($sym,'G');
}

print EM <<'END';

#ifdef EMBED

END

for $sym (sort keys %globvar) {
    print EM embedvar($sym);
}

print EM <<'END';

#endif /* EMBED */
#endif /* PERL_GLOBAL_STRUCT */

END

print EM <<'END';

#ifndef MIN_PERL_DEFINE  

a77 11
for $sym (sort @@extvars) {
    print EM hide($sym,"PL_$sym");
}

print EM <<'END';

#endif /* MIN_PERL_DEFINE */
END


close(EM);
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d3 1
a3 179
require 5.003;	# keep this compatible, an old perl is all we may have before
                # we build the new one

#
# See database of global and static function prototypes at the __END__.
# This is used to generate prototype headers under various configurations,
# export symbols lists for different platforms, and macros to provide an
# implicit interpreter context argument.
#

my $END = tell DATA;

# walk table providing an array of components in each line to
# subroutine, printing the result
sub walk_table (&@@) {
    my $function = shift;
    my $filename = shift || '-';
    my $leader = shift;
    my $trailer = shift;
    my $F;
    local *F;
    if (ref $filename) {	# filehandle
	$F = $filename;
    }
    else {
	open F, ">$filename" or die "Can't open $filename: $!";
	$F = \*F;
    }
    print $F $leader if $leader;
    seek DATA, $END, 0;		# so we may restart
    while (<DATA>) {
	chomp;
	next if /^:/;
	while (s|\\$||) {
	    $_ .= <DATA>;
	    chomp;
	}
	my @@args;
	if (/^\s*(#|$)/) {
	    @@args = $_;
	}
	else {
	    @@args = split /\s*\|\s*/, $_;
	}
	print $F $function->(@@args);
    }
    print $F $trailer if $trailer;
    close $F unless ref $filename;
}

sub munge_c_files () {
    my $functions = {};
    unless (@@ARGV) {
        warn "\@@ARGV empty, nothing to do\n";
	return;
    }
    walk_table {
	if (@@_ > 1) {
	    $functions->{$_[2]} = \@@_ if $_[@@_-1] =~ /\.\.\./;
	}
    } '/dev/null';
    local $^I = '.bak';
    while (<>) {
#	if (/^#\s*include\s+"perl.h"/) {
#	    my $file = uc $ARGV;
#	    $file =~ s/\./_/g;
#	    print "#define PERL_IN_$file\n";
#	}
#	s{^(\w+)\s*\(}
#	 {
#	    my $f = $1;
#	    my $repl = "$f(";
#	    if (exists $functions->{$f}) {
#		my $flags = $functions->{$f}[0];
#		$repl = "Perl_$repl" if $flags =~ /p/;
#		unless ($flags =~ /n/) {
#		    $repl .= "pTHX";
#		    $repl .= "_ " if @@{$functions->{$f}} > 3;
#		}
#		warn("$ARGV:$.:$repl\n");
#	    }
#	    $repl;
#	 }e;
	s{(\b(\w+)[ \t]*\([ \t]*(?!aTHX))}
	 {
	    my $repl = $1;
	    my $f = $2;
	    if (exists $functions->{$f}) {
		$repl .= "aTHX_ ";
		warn("$ARGV:$.:$`#$repl#$'");
	    }
	    $repl;
	 }eg;
	print;
	close ARGV if eof;	# restart $.
    }
    exit;
}

#munge_c_files();

# generate proto.h
my $wrote_protected = 0;

sub write_protos {
    my $ret = "";
    if (@@_ == 1) {
	my $arg = shift;
	$ret .= "$arg\n";
    }
    else {
	my ($flags,$retval,$func,@@args) = @@_;
	if ($flags =~ /s/) {
	    $retval = "STATIC $retval";
	    $func = "S_$func";
	}
	else {
	    $retval = "PERL_CALLCONV $retval";
	    if ($flags =~ /p/) {
		$func = "Perl_$func";
	    }
	}
	$ret .= "$retval\t$func(";
	unless ($flags =~ /n/) {
	    $ret .= "pTHX";
	    $ret .= "_ " if @@args;
	}
	if (@@args) {
	    $ret .= join ", ", @@args;
	}
	else {
	    $ret .= "void" if $flags =~ /n/;
	}
	$ret .= ")";
	$ret .= " __attribute__((noreturn))" if $flags =~ /r/;
	if( $flags =~ /f/ ) { 
	    my $prefix = $flags =~ /n/ ? '' : 'pTHX_';
	    my $args = scalar @@args; 
	    $ret .= "\n#ifdef CHECK_FORMAT\n";
	    $ret .= sprintf " __attribute__((format(printf,%s%d,%s%d)))",
				    $prefix, $args - 1, $prefix, $args; 
	    $ret .= "\n#endif\n";
	}
	$ret .= ";\n";
    }
    $ret;
}

# generates global.sym (API export list), and populates %global with global symbols
sub write_global_sym {
    my $ret = "";
    if (@@_ > 1) {
	my ($flags,$retval,$func,@@args) = @@_;
	if ($flags =~ /A/ && $flags !~ /x/) { # public API, so export
	    $func = "Perl_$func" if $flags =~ /p/;
	    $ret = "$func\n";
	}
    }
    $ret;
}


walk_table(\&write_protos, 'proto.h', <<'EOT');
/*
 * !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
 * This file is autogenerated from data in embed.pl.  Edit that file
 * and run 'make regen_headers' to effect changes.
 */

EOT

walk_table(\&write_global_sym, 'global.sym', <<'EOT');
#
# !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
# This file is autogenerated from data in embed.pl.  Edit that file
# and run 'make regen_headers' to effect changes.
#

EOT
a11 1
		 no_modify
d26 1
d33 1
a33 4
	    my $sym = $1;
	    warn "duplicate symbol $sym while processing $file\n"
		if exists $$syms{$sym};
	    $$syms{$sym} = 1;
d39 1
a39 2
# Perl_pp_* and Perl_ck_* are in pp.sym
readsyms my %ppsym, 'pp.sym';
d41 3
a43 2
sub readvars(\%$$@@) {
    my ($syms, $file,$pre,$keep_pre) = @@_;
d49 2
a50 6
	if (/PERLVARA?I?C?\($pre(\w+)/) {
	    my $sym = $1;
	    $sym = $pre . $sym if $keep_pre;
	    warn "duplicate symbol $sym while processing $file\n"
		if exists $$syms{$sym};
	    $$syms{$sym} = $pre || 1;
d63 20
a82 1
foreach my $sym (sort keys %thread) {
d84 6
a89 6
}

sub undefine ($) {
    my ($sym) = @@_;
    "#undef  $sym\n";
}
d96 8
a103 5

sub bincompat_var ($$) {
    my ($pfx, $sym) = @@_;
    my $arg = ($pfx eq 'G' ? 'NULL' : 'aTHXo');
    undefine("PL_$sym") . hide("PL_$sym", "(*Perl_${pfx}${sym}_ptr($arg))");
a109 1

d116 2
a117 1
open(EM, '> embed.h') or die "Can't create embed.h: $!\n";
d121 2
a122 2
   This file is built by embed.pl from data in embed.pl, pp.sym, intrpvar.h,
   perlvars.h and thrdvar.h.  Any changes made here will be lost!
d127 8
a134 36
/* NO_EMBED is no longer supported. i.e. EMBED is always active. */

/* provide binary compatible (but inconsistent) names */
#if defined(PERL_BINCOMPAT_5005)
#  define  Perl_call_atexit		perl_atexit
#  define  Perl_eval_sv			perl_eval_sv
#  define  Perl_eval_pv			perl_eval_pv
#  define  Perl_call_argv		perl_call_argv
#  define  Perl_call_method		perl_call_method
#  define  Perl_call_pv			perl_call_pv
#  define  Perl_call_sv			perl_call_sv
#  define  Perl_get_av			perl_get_av
#  define  Perl_get_cv			perl_get_cv
#  define  Perl_get_hv			perl_get_hv
#  define  Perl_get_sv			perl_get_sv
#  define  Perl_init_i18nl10n		perl_init_i18nl10n
#  define  Perl_init_i18nl14n		perl_init_i18nl14n
#  define  Perl_new_collate		perl_new_collate
#  define  Perl_new_ctype		perl_new_ctype
#  define  Perl_new_numeric		perl_new_numeric
#  define  Perl_require_pv		perl_require_pv
#  define  Perl_safesyscalloc		Perl_safecalloc
#  define  Perl_safesysfree		Perl_safefree
#  define  Perl_safesysmalloc		Perl_safemalloc
#  define  Perl_safesysrealloc		Perl_saferealloc
#  define  Perl_set_numeric_local	perl_set_numeric_local
#  define  Perl_set_numeric_standard	perl_set_numeric_standard
/* malloc() pollution was the default in earlier versions, so enable
 * it for bincompat; but not for systems that used to do prevent that,
 * or when they ask for {HIDE,EMBED}MYMALLOC */
#  if !defined(EMBEDMYMALLOC) && !defined(HIDEMYMALLOC)
#    if !defined(NeXT) && !defined(__NeXT) && !defined(__MACHTEN__) && \
        !defined(__QNX__)
#      define  PERL_POLLUTE_MALLOC
#    endif
#  endif
d137 1
a137 1
/* Hide global symbols */
d139 1
a139 2
#if !defined(PERL_OBJECT)
#if !defined(PERL_IMPLICIT_CONTEXT)
d143 2
a144 84
walk_table {
    my $ret = "";
    if (@@_ == 1) {
	my $arg = shift;
	$ret .= "$arg\n" if $arg =~ /^#\s*(if|ifn?def|else|endif)\b/;
    }
    else {
	my ($flags,$retval,$func,@@args) = @@_;
	unless ($flags =~ /o/) {
	    if ($flags =~ /s/) {
		$ret .= hide($func,"S_$func");
	    }
	    elsif ($flags =~ /p/) {
		$ret .= hide($func,"Perl_$func");
	    }
	}
    }
    $ret;
} \*EM;

for $sym (sort keys %ppsym) {
    $sym =~ s/^Perl_//;
    print EM hide($sym, "Perl_$sym");
}

print EM <<'END';

#else	/* PERL_IMPLICIT_CONTEXT */

END

my @@az = ('a'..'z');

walk_table {
    my $ret = "";
    if (@@_ == 1) {
	my $arg = shift;
	$ret .= "$arg\n" if $arg =~ /^#\s*(if|ifn?def|else|endif)\b/;
    }
    else {
	my ($flags,$retval,$func,@@args) = @@_;
	unless ($flags =~ /o/) {
	    my $args = scalar @@args;
	    if ($args and $args[$args-1] =~ /\.\.\./) {
	        # we're out of luck for varargs functions under CPP
	    }
	    elsif ($flags =~ /n/) {
		if ($flags =~ /s/) {
		    $ret .= hide($func,"S_$func");
		}
		elsif ($flags =~ /p/) {
		    $ret .= hide($func,"Perl_$func");
		}
	    }
	    else {
		my $alist = join(",", @@az[0..$args-1]);
		$ret = "#define $func($alist)";
		my $t = int(length($ret) / 8);
		$ret .=  "\t" x ($t < 4 ? 4 - $t : 1);
		if ($flags =~ /s/) {
		    $ret .= "S_$func(aTHX";
		}
		elsif ($flags =~ /p/) {
		    $ret .= "Perl_$func(aTHX";
		}
		$ret .= "_ " if $alist;
		$ret .= $alist . ")\n";
	    }
	}
    }
    $ret;
} \*EM;

for $sym (sort keys %ppsym) {
    $sym =~ s/^Perl_//;
    if ($sym =~ /^ck_/) {
	print EM hide("$sym(a)", "Perl_$sym(aTHX_ a)");
    }
    elsif ($sym =~ /^pp_/) {
	print EM hide("$sym()", "Perl_$sym(aTHX)");
    }
    else {
	warn "Illegal symbol '$sym' in pp.sym";
    }
d149 1
a149 112
#endif	/* PERL_IMPLICIT_CONTEXT */
#else	/* PERL_OBJECT */

END

walk_table {
    my $ret = "";
    if (@@_ == 1) {
	my $arg = shift;
	$ret .= "$arg\n" if $arg =~ /^#\s*(if|ifn?def|else|endif)\b/;
    }
    else {
	my ($flags,$retval,$func,@@args) = @@_;
	if ($flags =~ /s/) {
	    $ret .= hide("S_$func","CPerlObj::S_$func") if $flags !~ /j/;
	    $ret .= hide($func,"S_$func");
	}
	elsif ($flags =~ /p/) {
	    $ret .= hide("Perl_$func","CPerlObj::Perl_$func") if $flags !~ /j/;
	    $ret .= hide($func,"Perl_$func");
	}
	else {
	    $ret .= hide($func,"CPerlObj::$func") if $flags !~ /j/;
	}
    }
    $ret;
} \*EM;

for $sym (sort keys %ppsym) {
    $sym =~ s/^Perl_//;
    print EM hide("Perl_$sym", "CPerlObj::Perl_$sym");
    print EM hide($sym, "Perl_$sym");
}

print EM <<'END';

#endif	/* PERL_OBJECT */

/* Compatibility stubs.  Compile extensions with -DPERL_NOCOMPAT to
   disable them.
 */

#if !defined(PERL_CORE)
#  define sv_setptrobj(rv,ptr,name)	sv_setref_iv(rv,name,PTR2IV(ptr))
#  define sv_setptrref(rv,ptr)		sv_setref_iv(rv,Nullch,PTR2IV(ptr))
#endif

#if !defined(PERL_CORE) && !defined(PERL_NOCOMPAT) && !defined(PERL_BINCOMPAT_5005)

/* Compatibility for various misnamed functions.  All functions
   in the API that begin with "perl_" (not "Perl_") take an explicit
   interpreter context pointer.
   The following are not like that, but since they had a "perl_"
   prefix in previous versions, we provide compatibility macros.
 */
#  define perl_atexit(a,b)		call_atexit(a,b)
#  define perl_call_argv(a,b,c)		call_argv(a,b,c)
#  define perl_call_pv(a,b)		call_pv(a,b)
#  define perl_call_method(a,b)		call_method(a,b)
#  define perl_call_sv(a,b)		call_sv(a,b)
#  define perl_eval_sv(a,b)		eval_sv(a,b)
#  define perl_eval_pv(a,b)		eval_pv(a,b)
#  define perl_require_pv(a)		require_pv(a)
#  define perl_get_sv(a,b)		get_sv(a,b)
#  define perl_get_av(a,b)		get_av(a,b)
#  define perl_get_hv(a,b)		get_hv(a,b)
#  define perl_get_cv(a,b)		get_cv(a,b)
#  define perl_init_i18nl10n(a)		init_i18nl10n(a)
#  define perl_init_i18nl14n(a)		init_i18nl14n(a)
#  define perl_new_ctype(a)		new_ctype(a)
#  define perl_new_collate(a)		new_collate(a)
#  define perl_new_numeric(a)		new_numeric(a)

/* varargs functions can't be handled with CPP macros. :-(
   This provides a set of compatibility functions that don't take
   an extra argument but grab the context pointer using the macro
   dTHX.
 */
#if defined(PERL_IMPLICIT_CONTEXT) && !defined(PERL_OBJECT)
#  define croak				Perl_croak_nocontext
#  define deb				Perl_deb_nocontext
#  define die				Perl_die_nocontext
#  define form				Perl_form_nocontext
#  define load_module			Perl_load_module_nocontext
#  define mess				Perl_mess_nocontext
#  define newSVpvf			Perl_newSVpvf_nocontext
#  define sv_catpvf			Perl_sv_catpvf_nocontext
#  define sv_setpvf			Perl_sv_setpvf_nocontext
#  define warn				Perl_warn_nocontext
#  define warner			Perl_warner_nocontext
#  define sv_catpvf_mg			Perl_sv_catpvf_mg_nocontext
#  define sv_setpvf_mg			Perl_sv_setpvf_mg_nocontext
#endif

#endif /* !defined(PERL_CORE) && !defined(PERL_NOCOMPAT) */

#if !defined(PERL_IMPLICIT_CONTEXT)
/* undefined symbols, point them back at the usual ones */
#  define Perl_croak_nocontext		Perl_croak
#  define Perl_die_nocontext		Perl_die
#  define Perl_deb_nocontext		Perl_deb
#  define Perl_form_nocontext		Perl_form
#  define Perl_load_module_nocontext	Perl_load_module
#  define Perl_mess_nocontext		Perl_mess
#  define Perl_newSVpvf_nocontext	Perl_newSVpvf
#  define Perl_sv_catpvf_nocontext	Perl_sv_catpvf
#  define Perl_sv_setpvf_nocontext	Perl_sv_setpvf
#  define Perl_warn_nocontext		Perl_warn
#  define Perl_warner_nocontext		Perl_warner
#  define Perl_sv_catpvf_mg_nocontext	Perl_sv_catpvf_mg
#  define Perl_sv_setpvf_mg_nocontext	Perl_sv_setpvf_mg
#endif
d161 2
a162 2
   This file is built by embed.pl from data in embed.pl, pp.sym, intrpvar.h,
   perlvars.h and thrdvar.h.  Any changes made here will be lost!
d167 6
a172 9
/*
   The following combinations of MULTIPLICITY, USE_THREADS, PERL_OBJECT
   and PERL_IMPLICIT_CONTEXT are supported:
     1) none
     2) MULTIPLICITY	# supported for compatibility
     3) MULTIPLICITY && PERL_IMPLICIT_CONTEXT
     4) USE_THREADS && PERL_IMPLICIT_CONTEXT
     5) MULTIPLICITY && USE_THREADS && PERL_IMPLICIT_CONTEXT
     6) PERL_OBJECT && PERL_IMPLICIT_CONTEXT
a173 1
   All other combinations of these flags are errors.
d175 1
a175 3
   #3, #4, #5, and #6 are supported directly, while #2 is a special
   case of #3 (supported by redefining vTHX appropriately).
*/
d177 1
a177 2
#if defined(MULTIPLICITY)
/* cases 2, 3 and 5 above */
d179 2
a180 5
#  if defined(PERL_IMPLICIT_CONTEXT)
#    define vTHX	aTHX
#  else
#    define vTHX	PERL_GET_INTERP
#  endif
d185 1
a185 1
    print EM multon($sym,'T','vTHX->');
d190 1
a190 3
#  if defined(PERL_OBJECT)
#    include "error: PERL_OBJECT + MULTIPLICITY don't go together"
#  endif
d192 1
a192 2
#  if defined(USE_THREADS)
/* case 5 above */
d197 1
a197 1
    print EM multon($sym,'I','PERL_GET_INTERP->');
d202 1
a202 2
#  else		/* !USE_THREADS */
/* cases 2 and 3 above */
d207 1
a207 1
    print EM multon($sym,'I','vTHX->');
d212 1
a212 6
#  endif	/* USE_THREADS */

#else	/* !MULTIPLICITY */

#  if defined(PERL_OBJECT)
/* case 6 above */
d217 1
a217 1
    print EM multon($sym,'T','aTHXo->interp.');
d220 1
d222 1
a222 5
for $sym (sort keys %intrp) {
    print EM multon($sym,'I','aTHXo->interp.');
}

print EM <<'END';
d224 1
a224 1
#  else	/* !PERL_OBJECT */
d226 1
a226 1
/* cases 1 and 4 above */
d231 1
a231 1
    print EM multoff($sym,'I');
d236 1
a236 2
#    if defined(USE_THREADS)
/* case 4 above */
d241 1
a241 1
    print EM multon($sym,'T','aTHX->');
d246 7
a252 2
#    else	/* !USE_THREADS */
/* case 1 above */
d257 1
a257 1
    print EM multoff($sym,'T');
d262 1
a262 3
#    endif	/* USE_THREADS */
#  endif	/* PERL_OBJECT */
#endif	/* MULTIPLICITY */
d264 1
a264 1
#if defined(PERL_GLOBAL_STRUCT)
d284 1
a284 3
#endif /* PERL_GLOBAL_STRUCT */

#ifdef PERL_POLLUTE		/* disabled by default in 5.6.0 */
d288 2
a289 2
for $sym (sort @@extvars) {
    print EM hide($sym,"PL_$sym");
d294 3
a296 1
#endif /* PERL_POLLUTE */
d299 1
a299 11
close(EM);

unlink 'objXSUB.h';
open(OBX, '> objXSUB.h')
    or die "Can't create objXSUB.h: $!\n";

print OBX <<'EOT';
/* !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!! 
   This file is built by embed.pl from data in embed.pl, pp.sym, intrpvar.h,
   perlvars.h and thrdvar.h.  Any changes made here will be lost!
*/
d301 1
a301 527
#ifndef __objXSUB_h__
#define __objXSUB_h__

/* method calls via pPerl (static functions without a "this" pointer need these) */

#if defined(PERL_CORE) && defined(PERL_OBJECT)

/* XXX soon to be eliminated, only a few things in PERLCORE need these now */

EOT

walk_table {
    my $ret = "";
    if (@@_ == 1) {
	my $arg = shift;
	$ret .= "$arg\n" if $arg =~ /^#\s*(if|ifn?def|else|endif)\b/;
    }
    else {
	my ($flags,$retval,$func,@@args) = @@_;
	if ($flags =~ /A/ && $flags !~ /j/) { # API function needing macros
	    if ($flags =~ /p/) {
		$ret .= undefine("Perl_$func") . hide("Perl_$func","pPerl->Perl_$func");
		$ret .= undefine($func) . hide($func,"Perl_$func");
	    }
	    else {
		$ret .= undefine($func) . hide($func,"pPerl->$func");
	    }
	}
    }
    $ret;
} \*OBX;

# NOTE: not part of API
#for $sym (sort keys %ppsym) {
#    $sym =~ s/^Perl_//;
#    print OBX undefine("Perl_$sym") . hide("Perl_$sym", "pPerl->Perl_$sym");
#    print OBX undefine($sym) . hide($sym, "Perl_$sym");
#}

print OBX <<'EOT';

#endif  /* PERL_CORE && PERL_OBJECT */
#endif	/* __objXSUB_h__ */
EOT

close(OBX);

unlink 'perlapi.h';
unlink 'perlapi.c';
open(CAPI, '> perlapi.c') or die "Can't create perlapi.c: $!\n";
open(CAPIH, '> perlapi.h') or die "Can't create perlapi.h: $!\n";

print CAPIH <<'EOT';
/* !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!! 
   This file is built by embed.pl from data in embed.pl, pp.sym, intrpvar.h,
   perlvars.h and thrdvar.h.  Any changes made here will be lost!
*/

/* declare accessor functions for Perl variables */
#ifndef __perlapi_h__
#define __perlapi_h__

#if defined(PERL_OBJECT) || defined (MULTIPLICITY)

#if defined(PERL_OBJECT)
#  undef  aTHXo
#  define aTHXo			pPerl
#  undef  aTHXo_
#  define aTHXo_		aTHXo,
#endif /* PERL_OBJECT */

START_EXTERN_C

#undef PERLVAR
#undef PERLVARA
#undef PERLVARI
#undef PERLVARIC
#define PERLVAR(v,t)	EXTERN_C t* Perl_##v##_ptr(pTHXo);
#define PERLVARA(v,n,t)	typedef t PL_##v##_t[n];			\
			EXTERN_C PL_##v##_t* Perl_##v##_ptr(pTHXo);
#define PERLVARI(v,t,i)	PERLVAR(v,t)
#define PERLVARIC(v,t,i) PERLVAR(v, const t)

#include "thrdvar.h"
#include "intrpvar.h"
#include "perlvars.h"

#undef PERLVAR
#undef PERLVARA
#undef PERLVARI
#undef PERLVARIC

END_EXTERN_C

#if defined(PERL_CORE)

/* accessor functions for Perl variables (provide binary compatibility) */

/* these need to be mentioned here, or most linkers won't put them in
   the perl executable */

#ifndef PERL_NO_FORCE_LINK

START_EXTERN_C

#ifndef DOINIT
EXT void *PL_force_link_funcs[];
#else
EXT void *PL_force_link_funcs[] = {
#undef PERLVAR
#undef PERLVARA
#undef PERLVARI
#undef PERLVARIC
#define PERLVAR(v,t)	(void*)Perl_##v##_ptr,
#define PERLVARA(v,n,t)	PERLVAR(v,t)
#define PERLVARI(v,t,i)	PERLVAR(v,t)
#define PERLVARIC(v,t,i) PERLVAR(v,t)

#include "thrdvar.h"
#include "intrpvar.h"
#include "perlvars.h"

#undef PERLVAR
#undef PERLVARA
#undef PERLVARI
#undef PERLVARIC
};
#endif	/* DOINIT */

START_EXTERN_C

#endif	/* PERL_NO_FORCE_LINK */

#else	/* !PERL_CORE */

EOT

foreach my $sym (sort keys %intrp) {
    print CAPIH bincompat_var('I',$sym);
}

foreach my $sym (sort keys %thread) {
    print CAPIH bincompat_var('T',$sym);
}

foreach my $sym (sort keys %globvar) {
    print CAPIH bincompat_var('G',$sym);
}

print CAPIH <<'EOT';

#endif /* !PERL_CORE */
#endif /* PERL_OBJECT || MULTIPLICITY */

#endif /* __perlapi_h__ */

EOT
close CAPIH;

print CAPI <<'EOT';
/* !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!! 
   This file is built by embed.pl from data in embed.pl, pp.sym, intrpvar.h,
   perlvars.h and thrdvar.h.  Any changes made here will be lost!
*/

#include "EXTERN.h"
#include "perl.h"
#include "perlapi.h"

#if defined(PERL_OBJECT) || defined (MULTIPLICITY)

/* accessor functions for Perl variables (provides binary compatibility) */
START_EXTERN_C

#undef PERLVAR
#undef PERLVARA
#undef PERLVARI
#undef PERLVARIC

#if defined(PERL_OBJECT)
#define PERLVAR(v,t)	t* Perl_##v##_ptr(pTHXo)			\
			{ return &(aTHXo->interp.v); }
#define PERLVARA(v,n,t)	PL_##v##_t* Perl_##v##_ptr(pTHXo)		\
			{ return &(aTHXo->interp.v); }
#else	/* MULTIPLICITY */
#define PERLVAR(v,t)	t* Perl_##v##_ptr(pTHX)				\
			{ return &(aTHX->v); }
#define PERLVARA(v,n,t)	PL_##v##_t* Perl_##v##_ptr(pTHX)		\
			{ return &(aTHX->v); }
#endif

#define PERLVARI(v,t,i)	PERLVAR(v,t)
#define PERLVARIC(v,t,i) PERLVAR(v, const t)

#include "thrdvar.h"
#include "intrpvar.h"

#undef PERLVAR
#undef PERLVARA
#define PERLVAR(v,t)	t* Perl_##v##_ptr(pTHXo)			\
			{ return &(PL_##v); }
#define PERLVARA(v,n,t)	PL_##v##_t* Perl_##v##_ptr(pTHXo)		\
			{ return &(PL_##v); }
#include "perlvars.h"

#undef PERLVAR
#undef PERLVARA
#undef PERLVARI
#undef PERLVARIC

#if defined(PERL_OBJECT)

/* C-API layer for PERL_OBJECT */

EOT

# functions that take va_list* for implementing vararg functions
# NOTE: makedef.pl must be updated if you add symbols to %vfuncs
my %vfuncs = qw(
    Perl_croak			Perl_vcroak
    Perl_warn			Perl_vwarn
    Perl_warner			Perl_vwarner
    Perl_die			Perl_vdie
    Perl_form			Perl_vform
    Perl_load_module		Perl_vload_module
    Perl_mess			Perl_vmess
    Perl_deb			Perl_vdeb
    Perl_newSVpvf		Perl_vnewSVpvf
    Perl_sv_setpvf		Perl_sv_vsetpvf
    Perl_sv_setpvf_mg		Perl_sv_vsetpvf_mg
    Perl_sv_catpvf		Perl_sv_vcatpvf
    Perl_sv_catpvf_mg		Perl_sv_vcatpvf_mg
    Perl_dump_indent		Perl_dump_vindent
    Perl_default_protect	Perl_vdefault_protect
);

sub emit_func {
    my ($addcontext, $rettype,$func,@@args) = @@_;
    my @@aargs = @@args;
    my $a;
    for $a (@@aargs) { $a =~ s/^.*\b(\w+)$/$1/ }
    my $ctxarg = '';
    if (not $addcontext) {
	$ctxarg = 'pTHXo';
	$ctxarg .= '_ ' if @@args;
    }
    my $decl = '';
    if ($addcontext) {
	$decl .= "    dTHXo;\n";
    }
    local $" = ', ';
    my $return = ($rettype =~ /^\s*(void|Free_t|Signal_t)\s*$/
		  ? '' : 'return ');
    my $emitval = '';
    if (@@args and $args[$#args] =~ /\.\.\./) {
	pop @@aargs;
	my $retarg = '';
	my $ctxfunc = $func;
	$ctxfunc =~ s/_nocontext$//;
	return $emitval unless exists $vfuncs{$ctxfunc};
	if (length $return) {
	    $decl .= "    $rettype retval;\n";
	    $retarg .= "retval = ";
	    $return = "\n    ${return}retval;\n";
	}
	$emitval .= <<EOT
$rettype
$func($ctxarg@@args)
{
$decl    va_list args;
    va_start(args, $aargs[$#aargs]);
    $retarg((CPerlObj*)pPerl)->$vfuncs{$ctxfunc}(@@aargs, &args);
    va_end(args);$return
}
EOT
    }
    else {
	$emitval .= <<EOT
$rettype
$func($ctxarg@@args)
{
$decl    $return((CPerlObj*)pPerl)->$func(@@aargs);
}
EOT
    }
    $emitval;
}

# XXXX temporary hack
my $sym;
for $sym (qw(
		perl_construct
		perl_destruct
		perl_free
		perl_run
		perl_parse
		))
{
    $skipapi_funcs{$sym}++;
}

walk_table {
    my $ret = "";
    if (@@_ == 1) {
	my $arg = shift;
	$ret .= "$arg\n" if $arg =~ /^#\s*(if|ifn?def|else|endif)\b/;
    }
    else {
	my ($flags,$retval,$func,@@args) = @@_;
	return $ret if exists $skipapi_funcs{$func};
	if ($flags =~ /A/ && $flags !~ /j/) { # in public API, needed for XSUBS
	    $ret .= "\n";
	    my $addctx = 1 if $flags =~ /n/;
	    if ($flags =~ /p/) {
		$ret .= undefine("Perl_$func");
		$ret .= emit_func($addctx,$retval,"Perl_$func",@@args);
	    }
	    else {
		$ret .= undefine($func);
		$ret .= emit_func($addctx,$retval,$func,@@args);
	    }
	}
    }
    $ret;
} \*CAPI;

# NOTE: not part of the API
#for $sym (sort keys %ppsym) {
#    $sym =~ s/^Perl_//;
#    print CAPI "\n";
#    print CAPI undefine("Perl_$sym");
#    if ($sym =~ /^ck_/) {
#	print CAPI emit_func(0, 'OP *',"Perl_$sym",'OP *o');
#    }
#   else {					# pp_foo
#	print CAPI emit_func(0, 'OP *',"Perl_$sym");
#    }
#}

print CAPI <<'EOT';

#undef Perl_fprintf_nocontext
int
Perl_fprintf_nocontext(PerlIO *stream, const char *format, ...)
{
    dTHXo;
    va_list(arglist);
    va_start(arglist, format);
    return (*PL_StdIO->pVprintf)(PL_StdIO, stream, format, arglist);
}

END_EXTERN_C

#endif /* PERL_OBJECT */
#endif /* PERL_OBJECT || MULTIPLICITY */
EOT

close(CAPI);

# autogenerate documentation from comments in source files

my %apidocs;
my %gutsdocs;
my %docfuncs;

sub autodoc ($) { # parse a file and extract documentation info
    my($fh) = @@_;
    my($in, $doc);

FUNC:
    while (defined($in = <$fh>)) {
	if ($in =~ /^=for\s+apidoc\s+(.*)\n/) {
	    my $proto = $1;
	    $proto = "||$proto" unless $proto =~ /\|/;
	    my($flags, $ret, $name, @@args) = split /\|/, $proto;
	    my $docs = "";
DOC:
	    while (defined($doc = <$fh>)) {
		last DOC if $doc =~ /^=\w+/;
		$docs .= $doc;
	    }
	    $docs = "\n$docs" if $docs and $docs !~ /^\n/;
	    if ($flags =~ /m/) {
		if ($flags =~ /A/) {
		    $apidocs{$name} = [$flags, $docs, $ret, @@args];
		}
		else {
		    $gutsdocs{$name} = [$flags, $docs, $ret, @@args];
		}
	    }
	    else {
		$docfuncs{$name} = [$flags, $docs, $ret, @@args];
	    }
	    if ($doc =~ /^=for/) {
		$in = $doc;
		redo FUNC;
	    }
	}
    }
}

sub docout ($$$) { # output the docs for one function
    my($fh, $name, $docref) = @@_;
    my($flags, $docs, $ret, @@args) = @@$docref;

    $docs .= "NOTE: the perl_ form of this function is deprecated.\n\n" 
	if $flags =~ /p/;

    print $fh "=item $name\n$docs";

    if ($flags =~ /U/) { # no usage
	# nothing
    } elsif ($flags =~ /s/) { # semicolon ("dTHR;")
	print $fh "\t\t$name;\n\n";
    } elsif ($flags =~ /n/) { # no args
	print $fh "\t$ret\t$name\n\n";
    } else { # full usage
	print $fh "\t$ret\t$name";
	print $fh "(" . join(", ", @@args) . ")";
	print $fh "\n\n";
    }
}

my $file;
for $file (glob('*.c'), glob('*.h')) {
    open F, "< $file" or die "Cannot open $file for docs: $!\n";
    autodoc(\*F);
    close F or die "Error closing $file: $!\n";
}

unlink "pod/perlapi.pod";
open (DOC, ">pod/perlapi.pod") or 
	die "Can't create pod/perlapi.pod: $!\n";

walk_table {	# load documented functions into approriate hash
    if (@@_ > 1) {
	my($flags, $retval, $func, @@args) = @@_;
	return "" unless $flags =~ /d/;
	$func =~ s/\t//g; $flags =~ s/p//; # clean up fields from embed.pl
	$retval =~ s/\t//;
	if ($flags =~ /A/) {
	    my $docref = delete $docfuncs{$func};
	    warn "no docs for $func\n" unless $docref and @@$docref;
	    $apidocs{$func} = [$docref->[0] . 'A', $docref->[1], $retval, @@args];
	} else {
	    my $docref = delete $docfuncs{$func};
	    $gutsdocs{$func} = [$docref->[0], $docref->[1], $retval, @@args];
	}
    }
    return "";
} \*DOC;

for (sort keys %docfuncs) {
    warn "Unable to place $_!\n";
}

print DOC <<'_EOB_';
=head1 NAME

perlapi - autogenerated documentation for the perl public API

=head1 DESCRIPTION

This file contains the documentation of the perl public API generated by 
embed.pl, specifically a listing of functions, macros, flags, and variables 
that may be used by extension writers.  The interfaces of any functions that 
are not listed here are subject to change without notice.  For this reason,
blindly using functions listed in proto.h is to be avoided when writing
extensions.

Note that all Perl API global variables must be referenced with the C<PL_>
prefix.  Some macros are provided for compatibility with the older,
unadorned names, but this support may be disabled in a future release.

The listing is alphabetical, case insensitive.

=over 8

_EOB_

my $key;
for $key (sort { uc($a) cmp uc($b); } keys %apidocs) { # case insensitive sort
    docout(\*DOC, $key, $apidocs{$key});
}

print DOC <<'_EOE_';
=back

=head1 AUTHORS

Until May 1997, this document was maintained by Jeff Okamoto
<okamoto@@corp.hp.com>.  It is now maintained as part of Perl itself.

With lots of help and suggestions from Dean Roehrich, Malcolm Beattie,
Andreas Koenig, Paul Hudson, Ilya Zakharevich, Paul Marquess, Neil
Bowers, Matthew Green, Tim Bunce, Spider Boardman, Ulrich Pfeifer,
Stephen McCamant, and Gurusamy Sarathy.

API Listing originally by Dean Roehrich <roehrich@@cray.com>.

Updated to be autogenerated from comments in the source by Benjamin Stuhl.

=head1 SEE ALSO

perlguts(1), perlxs(1), perlxstut(1), perlintern(1)

_EOE_


close(DOC);

open(GUTS, ">pod/perlintern.pod") or 
		die "Unable to create pod/perlintern.pod: $!\n";
print GUTS <<'END';
=head1 NAME

perlintern - autogenerated documentation of purely B<internal> 
		 Perl functions

=head1 DESCRIPTION

This file is the autogenerated documentation of functions in the 
Perl intrepreter that are documented using Perl's internal documentation
format but are not marked as part of the Perl API. In other words, 
B<they are not for use in extensions>!

=over 8
d305 2
a306 2
for $key (sort { uc($a) cmp uc($b); } keys %gutsdocs) {
    docout(\*GUTS, $key, $gutsdocs{$key});
d309 1
a309 12
print GUTS <<'END';
=back

=head1 AUTHORS

The autodocumentation system was orignally added to the Perl core by 
Benjamin Stuhl. Documentation is by whoever was kind enough to 
document their functions.

=head1 SEE ALSO

perlguts(1), perlapi(1)
d311 1
a313 1
close GUTS;
d315 1
a315 1228

__END__

: Lines are of the form:
:    flags|return_type|function_name|arg1|arg2|...|argN
:
: A line may be continued on another by ending it with a backslash.
: Leading and trailing whitespace will be ignored in each component.
:
: flags are single letters with following meanings:
:	A		member of public API
:	d		function has documentation with its source
:	s		static function, should have an S_ prefix in source
:				file
:	n		has no implicit interpreter/thread context argument
:	p		function has a Perl_ prefix
:	f		function takes printf style format string, varargs
:	r		function never returns
:       o		has no compatibility macro (#define foo Perl_foo)
:       j		not a member of CPerlObj
:       x		not exported
:
: Individual flags may be separated by whitespace.
:
: New global functions should be added at the end for binary compatibility
: in some configurations.

START_EXTERN_C

#if defined(PERL_IMPLICIT_SYS)
Ajno	|PerlInterpreter*	|perl_alloc_using \
				|struct IPerlMem* m|struct IPerlMem* ms \
				|struct IPerlMem* mp|struct IPerlEnv* e \
				|struct IPerlStdIO* io|struct IPerlLIO* lio \
				|struct IPerlDir* d|struct IPerlSock* s \
				|struct IPerlProc* p
#endif
Ajnod	|PerlInterpreter*	|perl_alloc
Ajnod	|void	|perl_construct	|PerlInterpreter* interp
Ajnod	|void	|perl_destruct	|PerlInterpreter* interp
Ajnod	|void	|perl_free	|PerlInterpreter* interp
Ajnod	|int	|perl_run	|PerlInterpreter* interp
Ajnod	|int	|perl_parse	|PerlInterpreter* interp|XSINIT_t xsinit \
				|int argc|char** argv|char** env
#if defined(USE_ITHREADS)
: XXX: perl_clone needs docs
Ajno	|PerlInterpreter*|perl_clone|PerlInterpreter* interp, UV flags
#  if defined(PERL_IMPLICIT_SYS)
Ajno	|PerlInterpreter*|perl_clone_using|PerlInterpreter *interp|UV flags \
				|struct IPerlMem* m|struct IPerlMem* ms \
				|struct IPerlMem* mp|struct IPerlEnv* e \
				|struct IPerlStdIO* io|struct IPerlLIO* lio \
				|struct IPerlDir* d|struct IPerlSock* s \
				|struct IPerlProc* p
#  endif
#endif

#if defined(MYMALLOC)
Ajnop	|Malloc_t|malloc	|MEM_SIZE nbytes
Ajnop	|Malloc_t|calloc	|MEM_SIZE elements|MEM_SIZE size
Ajnop	|Malloc_t|realloc	|Malloc_t where|MEM_SIZE nbytes
Ajnop	|Free_t	|mfree		|Malloc_t where
jnp	|MEM_SIZE|malloced_size	|void *p
#endif

Ajnp	|void*	|get_context
Ajnp	|void	|set_context	|void *thx

END_EXTERN_C

/* functions with flag 'n' should come before here */
#if defined(PERL_OBJECT)
class CPerlObj {
public:
	struct interpreter interp;
	CPerlObj(IPerlMem*, IPerlMem*, IPerlMem*, IPerlEnv*, IPerlStdIO*,
	    IPerlLIO*, IPerlDir*, IPerlSock*, IPerlProc*);
	void* operator new(size_t nSize, IPerlMem *pvtbl);
#ifndef __BORLANDC__
	static void operator delete(void* pPerl, IPerlMem *pvtbl);
#endif
	int do_aspawn (void *vreally, void **vmark, void **vsp);
#endif
#if defined(PERL_OBJECT)
public:
#else
START_EXTERN_C
#endif
#  include "pp_proto.h"
Ap	|SV*	|amagic_call	|SV* left|SV* right|int method|int dir
Ap	|bool	|Gv_AMupdate	|HV* stash
p	|OP*	|append_elem	|I32 optype|OP* head|OP* tail
p	|OP*	|append_list	|I32 optype|LISTOP* first|LISTOP* last
p	|I32	|apply		|I32 type|SV** mark|SV** sp
Ap	|SV*	|avhv_delete_ent|AV *ar|SV* keysv|I32 flags|U32 hash
Ap	|bool	|avhv_exists_ent|AV *ar|SV* keysv|U32 hash
Ap	|SV**	|avhv_fetch_ent	|AV *ar|SV* keysv|I32 lval|U32 hash
Ap	|SV**	|avhv_store_ent	|AV *ar|SV* keysv|SV* val|U32 hash
Ap	|HE*	|avhv_iternext	|AV *ar
Ap	|SV*	|avhv_iterval	|AV *ar|HE* entry
Ap	|HV*	|avhv_keys	|AV *ar
Apd	|void	|av_clear	|AV* ar
Ap	|SV*	|av_delete	|AV* ar|I32 key|I32 flags
Ap	|bool	|av_exists	|AV* ar|I32 key
Apd	|void	|av_extend	|AV* ar|I32 key
Ap	|AV*	|av_fake	|I32 size|SV** svp
Apd	|SV**	|av_fetch	|AV* ar|I32 key|I32 lval
Ap	|void	|av_fill	|AV* ar|I32 fill
Apd	|I32	|av_len		|AV* ar
Apd	|AV*	|av_make	|I32 size|SV** svp
Apd	|SV*	|av_pop		|AV* ar
Apd	|void	|av_push	|AV* ar|SV* val
Ap	|void	|av_reify	|AV* ar
Apd	|SV*	|av_shift	|AV* ar
Apd	|SV**	|av_store	|AV* ar|I32 key|SV* val
Apd	|void	|av_undef	|AV* ar
Apd	|void	|av_unshift	|AV* ar|I32 num
p	|OP*	|bind_match	|I32 type|OP* left|OP* pat
p	|OP*	|block_end	|I32 floor|OP* seq
Ap	|I32	|block_gimme
p	|int	|block_start	|int full
p	|void	|boot_core_UNIVERSAL
Ap	|void	|call_list	|I32 oldscope|AV* av_list
p	|bool	|cando		|Mode_t mode|Uid_t effective|Stat_t* statbufp
Ap	|U32	|cast_ulong	|NV f
Ap	|I32	|cast_i32	|NV f
Ap	|IV	|cast_iv	|NV f
Ap	|UV	|cast_uv	|NV f
#if !defined(HAS_TRUNCATE) && !defined(HAS_CHSIZE) && defined(F_FREESP)
Ap	|I32	|my_chsize	|int fd|Off_t length
#endif
#if defined(USE_THREADS)
Ap	|MAGIC*	|condpair_magic	|SV *sv
#endif
p	|OP*	|convert	|I32 optype|I32 flags|OP* o
Afprd	|void	|croak		|const char* pat|...
Apr	|void	|vcroak		|const char* pat|va_list* args
#if defined(PERL_IMPLICIT_CONTEXT)
Afnrp	|void	|croak_nocontext|const char* pat|...
Afnp	|OP*	|die_nocontext	|const char* pat|...
Afnp	|void	|deb_nocontext	|const char* pat|...
Afnp	|char*	|form_nocontext	|const char* pat|...
Afnp	|void	|load_module_nocontext|U32 flags|SV* name|SV* ver|...
Afnp	|SV*	|mess_nocontext	|const char* pat|...
Afnp	|void	|warn_nocontext	|const char* pat|...
Afnp	|void	|warner_nocontext|U32 err|const char* pat|...
Afnp	|SV*	|newSVpvf_nocontext|const char* pat|...
Afnp	|void	|sv_catpvf_nocontext|SV* sv|const char* pat|...
Afnp	|void	|sv_setpvf_nocontext|SV* sv|const char* pat|...
Afnp	|void	|sv_catpvf_mg_nocontext|SV* sv|const char* pat|...
Afnp	|void	|sv_setpvf_mg_nocontext|SV* sv|const char* pat|...
Afnp	|int	|fprintf_nocontext|PerlIO* stream|const char* fmt|...
#endif
p	|void	|cv_ckproto	|CV* cv|GV* gv|char* p
p	|CV*	|cv_clone	|CV* proto
Ap	|SV*	|cv_const_sv	|CV* cv
p	|SV*	|op_const_sv	|OP* o|CV* cv
Ap	|void	|cv_undef	|CV* cv
Ap	|void	|cx_dump	|PERL_CONTEXT* cs
Ap	|SV*	|filter_add	|filter_t funcp|SV* datasv
Ap	|void	|filter_del	|filter_t funcp
Ap	|I32	|filter_read	|int idx|SV* buffer|int maxlen
Ap	|char**	|get_op_descs
Ap	|char**	|get_op_names
p	|char*	|get_no_modify
p	|U32*	|get_opargs
Ap	|PPADDR_t*|get_ppaddr
p	|I32	|cxinc
Afp	|void	|deb		|const char* pat|...
Ap	|void	|vdeb		|const char* pat|va_list* args
Ap	|void	|debprofdump
Ap	|I32	|debop		|OP* o
Ap	|I32	|debstack
Ap	|I32	|debstackptrs
Ap	|char*	|delimcpy	|char* to|char* toend|char* from \
				|char* fromend|int delim|I32* retlen
p	|void	|deprecate	|char* s
Afp	|OP*	|die		|const char* pat|...
p	|OP*	|vdie		|const char* pat|va_list* args
p	|OP*	|die_where	|char* message|STRLEN msglen
Ap	|void	|dounwind	|I32 cxix
p	|bool	|do_aexec	|SV* really|SV** mark|SV** sp
p	|bool	|do_aexec5	|SV* really|SV** mark|SV** sp|int fd|int flag
Ap	|int	|do_binmode	|PerlIO *fp|int iotype|int flag
p	|void	|do_chop	|SV* asv|SV* sv
Ap	|bool	|do_close	|GV* gv|bool not_implicit
p	|bool	|do_eof		|GV* gv
p	|bool	|do_exec	|char* cmd
#if !defined(WIN32)
p	|bool	|do_exec3	|char* cmd|int fd|int flag
#endif
p	|void	|do_execfree
#if defined(HAS_MSG) || defined(HAS_SEM) || defined(HAS_SHM)
p	|I32	|do_ipcctl	|I32 optype|SV** mark|SV** sp
p	|I32	|do_ipcget	|I32 optype|SV** mark|SV** sp
p	|I32	|do_msgrcv	|SV** mark|SV** sp
p	|I32	|do_msgsnd	|SV** mark|SV** sp
p	|I32	|do_semop	|SV** mark|SV** sp
p	|I32	|do_shmio	|I32 optype|SV** mark|SV** sp
#endif
p	|void	|do_join	|SV* sv|SV* del|SV** mark|SV** sp
p	|OP*	|do_kv
Ap	|bool	|do_open	|GV* gv|char* name|I32 len|int as_raw \
				|int rawmode|int rawperm|PerlIO* supplied_fp
Ap	|bool	|do_open9	|GV *gv|char *name|I32 len|int as_raw \
				|int rawmode|int rawperm|PerlIO *supplied_fp \
				|SV *svs|I32 num
p	|void	|do_pipe	|SV* sv|GV* rgv|GV* wgv
p	|bool	|do_print	|SV* sv|PerlIO* fp
p	|OP*	|do_readline
p	|I32	|do_chomp	|SV* sv
p	|bool	|do_seek	|GV* gv|Off_t pos|int whence
p	|void	|do_sprintf	|SV* sv|I32 len|SV** sarg
p	|Off_t	|do_sysseek	|GV* gv|Off_t pos|int whence
p	|Off_t	|do_tell	|GV* gv
p	|I32	|do_trans	|SV* sv
p	|UV	|do_vecget	|SV* sv|I32 offset|I32 size
p	|void	|do_vecset	|SV* sv
p	|void	|do_vop		|I32 optype|SV* sv|SV* left|SV* right
p	|OP*	|dofile		|OP* term
Ap	|I32	|dowantarray
Ap	|void	|dump_all
Ap	|void	|dump_eval
#if defined(DUMP_FDS)
Ap	|void	|dump_fds	|char* s
#endif
Ap	|void	|dump_form	|GV* gv
Ap	|void	|gv_dump	|GV* gv
Ap	|void	|op_dump	|OP* arg
Ap	|void	|pmop_dump	|PMOP* pm
Ap	|void	|dump_packsubs	|HV* stash
Ap	|void	|dump_sub	|GV* gv
Apd	|void	|fbm_compile	|SV* sv|U32 flags
Apd	|char*	|fbm_instr	|unsigned char* big|unsigned char* bigend \
				|SV* littlesv|U32 flags
p	|char*	|find_script	|char *scriptname|bool dosearch \
				|char **search_ext|I32 flags
#if defined(USE_THREADS)
p	|PADOFFSET|find_threadsv|const char *name
#endif
p	|OP*	|force_list	|OP* arg
p	|OP*	|fold_constants	|OP* arg
Afp	|char*	|form		|const char* pat|...
Ap	|char*	|vform		|const char* pat|va_list* args
Ap	|void	|free_tmps
p	|OP*	|gen_constant_list|OP* o
#if !defined(HAS_GETENV_LEN)
p	|char*	|getenv_len	|char* key|unsigned long *len
#endif
Ap	|void	|gp_free	|GV* gv
Ap	|GP*	|gp_ref		|GP* gp
Ap	|GV*	|gv_AVadd	|GV* gv
Ap	|GV*	|gv_HVadd	|GV* gv
Ap	|GV*	|gv_IOadd	|GV* gv
Ap	|GV*	|gv_autoload4	|HV* stash|const char* name|STRLEN len \
				|I32 method
Ap	|void	|gv_check	|HV* stash
Ap	|void	|gv_efullname	|SV* sv|GV* gv
Ap	|void	|gv_efullname3	|SV* sv|GV* gv|const char* prefix
Ap	|GV*	|gv_fetchfile	|const char* name
Apd	|GV*	|gv_fetchmeth	|HV* stash|const char* name|STRLEN len \
				|I32 level
Apd	|GV*	|gv_fetchmethod	|HV* stash|const char* name
Apd	|GV*	|gv_fetchmethod_autoload|HV* stash|const char* name \
				|I32 autoload
Ap	|GV*	|gv_fetchpv	|const char* name|I32 add|I32 sv_type
Ap	|void	|gv_fullname	|SV* sv|GV* gv
Ap	|void	|gv_fullname3	|SV* sv|GV* gv|const char* prefix
Ap	|void	|gv_init	|GV* gv|HV* stash|const char* name \
				|STRLEN len|int multi
Apd	|HV*	|gv_stashpv	|const char* name|I32 create
Ap	|HV*	|gv_stashpvn	|const char* name|U32 namelen|I32 create
Apd	|HV*	|gv_stashsv	|SV* sv|I32 create
Apd	|void	|hv_clear	|HV* tb
Ap	|void	|hv_delayfree_ent|HV* hv|HE* entry
Apd	|SV*	|hv_delete	|HV* tb|const char* key|U32 klen|I32 flags
Apd	|SV*	|hv_delete_ent	|HV* tb|SV* key|I32 flags|U32 hash
Apd	|bool	|hv_exists	|HV* tb|const char* key|U32 klen
Apd	|bool	|hv_exists_ent	|HV* tb|SV* key|U32 hash
Apd	|SV**	|hv_fetch	|HV* tb|const char* key|U32 klen|I32 lval
Apd	|HE*	|hv_fetch_ent	|HV* tb|SV* key|I32 lval|U32 hash
Ap	|void	|hv_free_ent	|HV* hv|HE* entry
Apd	|I32	|hv_iterinit	|HV* tb
Apd	|char*	|hv_iterkey	|HE* entry|I32* retlen
Apd	|SV*	|hv_iterkeysv	|HE* entry
Apd	|HE*	|hv_iternext	|HV* tb
Apd	|SV*	|hv_iternextsv	|HV* hv|char** key|I32* retlen
Apd	|SV*	|hv_iterval	|HV* tb|HE* entry
Ap	|void	|hv_ksplit	|HV* hv|IV newmax
Apd	|void	|hv_magic	|HV* hv|GV* gv|int how
Apd	|SV**	|hv_store	|HV* tb|const char* key|U32 klen|SV* val \
				|U32 hash
Apd	|HE*	|hv_store_ent	|HV* tb|SV* key|SV* val|U32 hash
Apd	|void	|hv_undef	|HV* tb
Ap	|I32	|ibcmp		|const char* a|const char* b|I32 len
Ap	|I32	|ibcmp_locale	|const char* a|const char* b|I32 len
p	|bool	|ingroup	|Gid_t testgid|Uid_t effective
p	|void	|init_debugger
Ap	|void	|init_stacks
p	|U32	|intro_my
Ap	|char*	|instr		|const char* big|const char* little
p	|bool	|io_close	|IO* io|bool not_implicit
p	|OP*	|invert		|OP* cmd
Ap	|bool	|is_uni_alnum	|U32 c
Ap	|bool	|is_uni_alnumc	|U32 c
Ap	|bool	|is_uni_idfirst	|U32 c
Ap	|bool	|is_uni_alpha	|U32 c
Ap	|bool	|is_uni_ascii	|U32 c
Ap	|bool	|is_uni_space	|U32 c
Ap	|bool	|is_uni_cntrl	|U32 c
Ap	|bool	|is_uni_graph	|U32 c
Ap	|bool	|is_uni_digit	|U32 c
Ap	|bool	|is_uni_upper	|U32 c
Ap	|bool	|is_uni_lower	|U32 c
Ap	|bool	|is_uni_print	|U32 c
Ap	|bool	|is_uni_punct	|U32 c
Ap	|bool	|is_uni_xdigit	|U32 c
Ap	|U32	|to_uni_upper	|U32 c
Ap	|U32	|to_uni_title	|U32 c
Ap	|U32	|to_uni_lower	|U32 c
Ap	|bool	|is_uni_alnum_lc|U32 c
Ap	|bool	|is_uni_alnumc_lc|U32 c
Ap	|bool	|is_uni_idfirst_lc|U32 c
Ap	|bool	|is_uni_alpha_lc|U32 c
Ap	|bool	|is_uni_ascii_lc|U32 c
Ap	|bool	|is_uni_space_lc|U32 c
Ap	|bool	|is_uni_cntrl_lc|U32 c
Ap	|bool	|is_uni_graph_lc|U32 c
Ap	|bool	|is_uni_digit_lc|U32 c
Ap	|bool	|is_uni_upper_lc|U32 c
Ap	|bool	|is_uni_lower_lc|U32 c
Ap	|bool	|is_uni_print_lc|U32 c
Ap	|bool	|is_uni_punct_lc|U32 c
Ap	|bool	|is_uni_xdigit_lc|U32 c
Ap	|U32	|to_uni_upper_lc|U32 c
Ap	|U32	|to_uni_title_lc|U32 c
Ap	|U32	|to_uni_lower_lc|U32 c
Ap	|int	|is_utf8_char	|U8 *p
Ap	|bool	|is_utf8_alnum	|U8 *p
Ap	|bool	|is_utf8_alnumc	|U8 *p
Ap	|bool	|is_utf8_idfirst|U8 *p
Ap	|bool	|is_utf8_alpha	|U8 *p
Ap	|bool	|is_utf8_ascii	|U8 *p
Ap	|bool	|is_utf8_space	|U8 *p
Ap	|bool	|is_utf8_cntrl	|U8 *p
Ap	|bool	|is_utf8_digit	|U8 *p
Ap	|bool	|is_utf8_graph	|U8 *p
Ap	|bool	|is_utf8_upper	|U8 *p
Ap	|bool	|is_utf8_lower	|U8 *p
Ap	|bool	|is_utf8_print	|U8 *p
Ap	|bool	|is_utf8_punct	|U8 *p
Ap	|bool	|is_utf8_xdigit	|U8 *p
Ap	|bool	|is_utf8_mark	|U8 *p
p	|OP*	|jmaybe		|OP* arg
p	|I32	|keyword	|char* d|I32 len
Ap	|void	|leave_scope	|I32 base
p	|void	|lex_end
p	|void	|lex_start	|SV* line
p	|OP*	|linklist	|OP* o
p	|OP*	|list		|OP* o
p	|OP*	|listkids	|OP* o
Afp	|void	|load_module|U32 flags|SV* name|SV* ver|...
Ap	|void	|vload_module|U32 flags|SV* name|SV* ver|va_list* args
p	|OP*	|localize	|OP* arg|I32 lexical
Apd	|I32	|looks_like_number|SV* sv
p	|int	|magic_clearenv	|SV* sv|MAGIC* mg
p	|int	|magic_clear_all_env|SV* sv|MAGIC* mg
p	|int	|magic_clearpack|SV* sv|MAGIC* mg
p	|int	|magic_clearsig	|SV* sv|MAGIC* mg
p	|int	|magic_existspack|SV* sv|MAGIC* mg
p	|int	|magic_freeregexp|SV* sv|MAGIC* mg
p	|int	|magic_get	|SV* sv|MAGIC* mg
p	|int	|magic_getarylen|SV* sv|MAGIC* mg
p	|int	|magic_getdefelem|SV* sv|MAGIC* mg
p	|int	|magic_getglob	|SV* sv|MAGIC* mg
p	|int	|magic_getnkeys	|SV* sv|MAGIC* mg
p	|int	|magic_getpack	|SV* sv|MAGIC* mg
p	|int	|magic_getpos	|SV* sv|MAGIC* mg
p	|int	|magic_getsig	|SV* sv|MAGIC* mg
p	|int	|magic_getsubstr|SV* sv|MAGIC* mg
p	|int	|magic_gettaint	|SV* sv|MAGIC* mg
p	|int	|magic_getuvar	|SV* sv|MAGIC* mg
p	|int	|magic_getvec	|SV* sv|MAGIC* mg
p	|U32	|magic_len	|SV* sv|MAGIC* mg
#if defined(USE_THREADS)
p	|int	|magic_mutexfree|SV* sv|MAGIC* mg
#endif
p	|int	|magic_nextpack	|SV* sv|MAGIC* mg|SV* key
p	|U32	|magic_regdata_cnt|SV* sv|MAGIC* mg
p	|int	|magic_regdatum_get|SV* sv|MAGIC* mg
p	|int	|magic_set	|SV* sv|MAGIC* mg
p	|int	|magic_setamagic|SV* sv|MAGIC* mg
p	|int	|magic_setarylen|SV* sv|MAGIC* mg
p	|int	|magic_setbm	|SV* sv|MAGIC* mg
p	|int	|magic_setdbline|SV* sv|MAGIC* mg
#if defined(USE_LOCALE_COLLATE)
p	|int	|magic_setcollxfrm|SV* sv|MAGIC* mg
#endif
p	|int	|magic_setdefelem|SV* sv|MAGIC* mg
p	|int	|magic_setenv	|SV* sv|MAGIC* mg
p	|int	|magic_setfm	|SV* sv|MAGIC* mg
p	|int	|magic_setisa	|SV* sv|MAGIC* mg
p	|int	|magic_setglob	|SV* sv|MAGIC* mg
p	|int	|magic_setmglob	|SV* sv|MAGIC* mg
p	|int	|magic_setnkeys	|SV* sv|MAGIC* mg
p	|int	|magic_setpack	|SV* sv|MAGIC* mg
p	|int	|magic_setpos	|SV* sv|MAGIC* mg
p	|int	|magic_setsig	|SV* sv|MAGIC* mg
p	|int	|magic_setsubstr|SV* sv|MAGIC* mg
p	|int	|magic_settaint	|SV* sv|MAGIC* mg
p	|int	|magic_setuvar	|SV* sv|MAGIC* mg
p	|int	|magic_setvec	|SV* sv|MAGIC* mg
p	|int	|magic_set_all_env|SV* sv|MAGIC* mg
p	|U32	|magic_sizepack	|SV* sv|MAGIC* mg
p	|int	|magic_wipepack	|SV* sv|MAGIC* mg
p	|void	|magicname	|char* sym|char* name|I32 namlen
Ap	|void	|markstack_grow
#if defined(USE_LOCALE_COLLATE)
p	|char*	|mem_collxfrm	|const char* s|STRLEN len|STRLEN* xlen
#endif
Afp	|SV*	|mess		|const char* pat|...
Ap	|SV*	|vmess		|const char* pat|va_list* args
p	|void	|qerror		|SV* err
Apd	|int	|mg_clear	|SV* sv
Apd	|int	|mg_copy	|SV* sv|SV* nsv|const char* key|I32 klen
Apd	|MAGIC*	|mg_find	|SV* sv|int type
Apd	|int	|mg_free	|SV* sv
Apd	|int	|mg_get		|SV* sv
Apd	|U32	|mg_length	|SV* sv
Apd	|void	|mg_magical	|SV* sv
Apd	|int	|mg_set		|SV* sv
Ap	|I32	|mg_size	|SV* sv
p	|OP*	|mod		|OP* o|I32 type
p	|int	|mode_from_discipline|SV* discp
Ap	|char*	|moreswitches	|char* s
p	|OP*	|my		|OP* o
Ap	|NV	|my_atof	|const char *s
#if !defined(HAS_BCOPY) || !defined(HAS_SAFE_BCOPY)
Anp	|char*	|my_bcopy	|const char* from|char* to|I32 len
#endif
#if !defined(HAS_BZERO) && !defined(HAS_MEMSET)
Anp	|char*	|my_bzero	|char* loc|I32 len
#endif
Apr	|void	|my_exit	|U32 status
Apr	|void	|my_failure_exit
Ap	|I32	|my_fflush_all
Ap	|I32	|my_lstat
#if !defined(HAS_MEMCMP) || !defined(HAS_SANE_MEMCMP)
Anp	|I32	|my_memcmp	|const char* s1|const char* s2|I32 len
#endif
#if !defined(HAS_MEMSET)
Anp	|void*	|my_memset	|char* loc|I32 ch|I32 len
#endif
#if !defined(PERL_OBJECT)
Ap	|I32	|my_pclose	|PerlIO* ptr
Ap	|PerlIO*|my_popen	|char* cmd|char* mode
#endif
Ap	|void	|my_setenv	|char* nam|char* val
Ap	|I32	|my_stat
#if defined(MYSWAP)
Ap	|short	|my_swap	|short s
Ap	|long	|my_htonl	|long l
Ap	|long	|my_ntohl	|long l
#endif
p	|void	|my_unexec
Ap	|OP*	|newANONLIST	|OP* o
Ap	|OP*	|newANONHASH	|OP* o
Ap	|OP*	|newANONSUB	|I32 floor|OP* proto|OP* block
Ap	|OP*	|newASSIGNOP	|I32 flags|OP* left|I32 optype|OP* right
Ap	|OP*	|newCONDOP	|I32 flags|OP* expr|OP* trueop|OP* falseop
Apd	|void	|newCONSTSUB	|HV* stash|char* name|SV* sv
Ap	|void	|newFORM	|I32 floor|OP* o|OP* block
Ap	|OP*	|newFOROP	|I32 flags|char* label|line_t forline \
				|OP* sclr|OP* expr|OP*block|OP*cont
Ap	|OP*	|newLOGOP	|I32 optype|I32 flags|OP* left|OP* right
Ap	|OP*	|newLOOPEX	|I32 type|OP* label
Ap	|OP*	|newLOOPOP	|I32 flags|I32 debuggable|OP* expr|OP* block
Ap	|OP*	|newNULLLIST
Ap	|OP*	|newOP		|I32 optype|I32 flags
Ap	|void	|newPROG	|OP* o
Ap	|OP*	|newRANGE	|I32 flags|OP* left|OP* right
Ap	|OP*	|newSLICEOP	|I32 flags|OP* subscript|OP* listop
Ap	|OP*	|newSTATEOP	|I32 flags|char* label|OP* o
Ap	|CV*	|newSUB		|I32 floor|OP* o|OP* proto|OP* block
Apd	|CV*	|newXS		|char* name|XSUBADDR_t f|char* filename
Apd	|AV*	|newAV
Ap	|OP*	|newAVREF	|OP* o
Ap	|OP*	|newBINOP	|I32 type|I32 flags|OP* first|OP* last
Ap	|OP*	|newCVREF	|I32 flags|OP* o
Ap	|OP*	|newGVOP	|I32 type|I32 flags|GV* gv
Ap	|GV*	|newGVgen	|char* pack
Ap	|OP*	|newGVREF	|I32 type|OP* o
Ap	|OP*	|newHVREF	|OP* o
Apd	|HV*	|newHV
Ap	|HV*	|newHVhv	|HV* hv
Ap	|IO*	|newIO
Ap	|OP*	|newLISTOP	|I32 type|I32 flags|OP* first|OP* last
Ap	|OP*	|newPADOP	|I32 type|I32 flags|SV* sv
Ap	|OP*	|newPMOP	|I32 type|I32 flags
Ap	|OP*	|newPVOP	|I32 type|I32 flags|char* pv
Ap	|SV*	|newRV		|SV* pref
Apd	|SV*	|newRV_noinc	|SV *sv
Ap	|SV*	|newSV		|STRLEN len
Ap	|OP*	|newSVREF	|OP* o
Ap	|OP*	|newSVOP	|I32 type|I32 flags|SV* sv
Apd	|SV*	|newSViv	|IV i
Apd	|SV*	|newSVuv	|UV u
Apd	|SV*	|newSVnv	|NV n
Apd	|SV*	|newSVpv	|const char* s|STRLEN len
Apd	|SV*	|newSVpvn	|const char* s|STRLEN len
Afpd	|SV*	|newSVpvf	|const char* pat|...
Ap	|SV*	|vnewSVpvf	|const char* pat|va_list* args
Apd	|SV*	|newSVrv	|SV* rv|const char* classname
Apd	|SV*	|newSVsv	|SV* old
Ap	|OP*	|newUNOP	|I32 type|I32 flags|OP* first
Ap	|OP*	|newWHILEOP	|I32 flags|I32 debuggable|LOOP* loop \
				|I32 whileline|OP* expr|OP* block|OP* cont

Ap	|PERL_SI*|new_stackinfo|I32 stitems|I32 cxitems
p	|PerlIO*|nextargv	|GV* gv
Ap	|char*	|ninstr		|const char* big|const char* bigend \
				|const char* little|const char* lend
p	|OP*	|oopsCV		|OP* o
Ap	|void	|op_free	|OP* arg
p	|void	|package	|OP* o
p	|PADOFFSET|pad_alloc	|I32 optype|U32 tmptype
p	|PADOFFSET|pad_allocmy	|char* name
p	|PADOFFSET|pad_findmy	|char* name
p	|OP*	|oopsAV		|OP* o
p	|OP*	|oopsHV		|OP* o
p	|void	|pad_leavemy	|I32 fill
Ap	|SV*	|pad_sv		|PADOFFSET po
p	|void	|pad_free	|PADOFFSET po
p	|void	|pad_reset
p	|void	|pad_swipe	|PADOFFSET po
p	|void	|peep		|OP* o
#if defined(PERL_OBJECT)
Aox	|void	|Perl_construct
Aox	|void	|Perl_destruct
Aox	|void	|Perl_free
Aox	|int	|Perl_run
Aox	|int	|Perl_parse	|XSINIT_t xsinit \
				|int argc|char** argv|char** env
#endif
#if defined(USE_THREADS)
Ap	|struct perl_thread*	|new_struct_thread|struct perl_thread *t
#endif
Ap	|void	|call_atexit	|ATEXIT_t fn|void *ptr
Apd	|I32	|call_argv	|const char* sub_name|I32 flags|char** argv
Apd	|I32	|call_method	|const char* methname|I32 flags
Apd	|I32	|call_pv	|const char* sub_name|I32 flags
Apd	|I32	|call_sv	|SV* sv|I32 flags
Apd	|SV*	|eval_pv	|const char* p|I32 croak_on_error
Apd	|I32	|eval_sv	|SV* sv|I32 flags
Apd	|SV*	|get_sv		|const char* name|I32 create
Apd	|AV*	|get_av		|const char* name|I32 create
Apd	|HV*	|get_hv		|const char* name|I32 create
Apd	|CV*	|get_cv		|const char* name|I32 create
Ap	|int	|init_i18nl10n	|int printwarn
Ap	|int	|init_i18nl14n	|int printwarn
Ap	|void	|new_collate	|const char* newcoll
Ap	|void	|new_ctype	|const char* newctype
Ap	|void	|new_numeric	|const char* newcoll
Ap	|void	|set_numeric_local
Ap	|void	|set_numeric_radix
Ap	|void	|set_numeric_standard
Apd	|void	|require_pv	|const char* pv
p	|void	|pidgone	|Pid_t pid|int status
Ap	|void	|pmflag		|U16* pmfl|int ch
p	|OP*	|pmruntime	|OP* pm|OP* expr|OP* repl
p	|OP*	|pmtrans	|OP* o|OP* expr|OP* repl
p	|OP*	|pop_return
Ap	|void	|pop_scope
p	|OP*	|prepend_elem	|I32 optype|OP* head|OP* tail
p	|void	|push_return	|OP* o
Ap	|void	|push_scope
p	|OP*	|ref		|OP* o|I32 type
p	|OP*	|refkids	|OP* o|I32 type
Ap	|void	|regdump	|regexp* r
Ap	|I32	|pregexec	|regexp* prog|char* stringarg \
				|char* strend|char* strbeg|I32 minend \
				|SV* screamer|U32 nosave
Ap	|void	|pregfree	|struct regexp* r
Ap	|regexp*|pregcomp	|char* exp|char* xend|PMOP* pm
Ap	|char*	|re_intuit_start|regexp* prog|SV* sv|char* strpos \
				|char* strend|U32 flags \
				|struct re_scream_pos_data_s *data
Ap	|SV*	|re_intuit_string|regexp* prog
Ap	|I32	|regexec_flags	|regexp* prog|char* stringarg \
				|char* strend|char* strbeg|I32 minend \
				|SV* screamer|void* data|U32 flags
Ap	|regnode*|regnext	|regnode* p
p	|void	|regprop	|SV* sv|regnode* o
Ap	|void	|repeatcpy	|char* to|const char* from|I32 len|I32 count
Ap	|char*	|rninstr	|const char* big|const char* bigend \
				|const char* little|const char* lend
p	|Sighandler_t|rsignal	|int i|Sighandler_t t
p	|int	|rsignal_restore|int i|Sigsave_t* t
p	|int	|rsignal_save	|int i|Sighandler_t t1|Sigsave_t* t2
p	|Sighandler_t|rsignal_state|int i
p	|void	|rxres_free	|void** rsp
p	|void	|rxres_restore	|void** rsp|REGEXP* prx
p	|void	|rxres_save	|void** rsp|REGEXP* prx
#if !defined(HAS_RENAME)
p	|I32	|same_dirent	|char* a|char* b
#endif
Apd	|char*	|savepv		|const char* sv
Apd	|char*	|savepvn	|const char* sv|I32 len
Ap	|void	|savestack_grow
Ap	|void	|save_aelem	|AV* av|I32 idx|SV **sptr
Ap	|I32	|save_alloc	|I32 size|I32 pad
Ap	|void	|save_aptr	|AV** aptr
Ap	|AV*	|save_ary	|GV* gv
Ap	|void	|save_clearsv	|SV** svp
Ap	|void	|save_delete	|HV* hv|char* key|I32 klen
Ap	|void	|save_destructor|DESTRUCTORFUNC_NOCONTEXT_t f|void* p
Ap	|void	|save_destructor_x|DESTRUCTORFUNC_t f|void* p
Ap	|void	|save_freesv	|SV* sv
p	|void	|save_freeop	|OP* o
Ap	|void	|save_freepv	|char* pv
Ap	|void	|save_generic_svref|SV** sptr
Ap	|void	|save_gp	|GV* gv|I32 empty
Ap	|HV*	|save_hash	|GV* gv
Ap	|void	|save_helem	|HV* hv|SV *key|SV **sptr
Ap	|void	|save_hints
Ap	|void	|save_hptr	|HV** hptr
Ap	|void	|save_I16	|I16* intp
Ap	|void	|save_I32	|I32* intp
Ap	|void	|save_I8	|I8* bytep
Ap	|void	|save_int	|int* intp
Ap	|void	|save_item	|SV* item
Ap	|void	|save_iv	|IV* iv
Ap	|void	|save_list	|SV** sarg|I32 maxsarg
Ap	|void	|save_long	|long* longp
Ap	|void	|save_nogv	|GV* gv
p	|void	|save_op
Ap	|SV*	|save_scalar	|GV* gv
Ap	|void	|save_pptr	|char** pptr
Ap	|void	|save_vptr	|void* pptr
Ap	|void	|save_re_context
Ap	|void	|save_sptr	|SV** sptr
Ap	|SV*	|save_svref	|SV** sptr
Ap	|SV**	|save_threadsv	|PADOFFSET i
p	|OP*	|sawparens	|OP* o
p	|OP*	|scalar		|OP* o
p	|OP*	|scalarkids	|OP* o
p	|OP*	|scalarseq	|OP* o
p	|OP*	|scalarvoid	|OP* o
Ap	|NV	|scan_bin	|char* start|I32 len|I32* retlen
Ap	|NV	|scan_hex	|char* start|I32 len|I32* retlen
Ap	|char*	|scan_num	|char* s
Ap	|NV	|scan_oct	|char* start|I32 len|I32* retlen
p	|OP*	|scope		|OP* o
Ap	|char*	|screaminstr	|SV* bigsv|SV* littlesv|I32 start_shift \
				|I32 end_shift|I32 *state|I32 last
#if !defined(VMS)
p	|I32	|setenv_getix	|char* nam
#endif
p	|void	|setdefout	|GV* gv
Ap	|char*	|sharepvn	|const char* sv|I32 len|U32 hash
p	|HEK*	|share_hek	|const char* sv|I32 len|U32 hash
np	|Signal_t |sighandler	|int sig
Ap	|SV**	|stack_grow	|SV** sp|SV**p|int n
Ap	|I32	|start_subparse	|I32 is_format|U32 flags
p	|void	|sub_crush_depth|CV* cv
Ap	|bool	|sv_2bool	|SV* sv
Ap	|CV*	|sv_2cv		|SV* sv|HV** st|GV** gvp|I32 lref
Ap	|IO*	|sv_2io		|SV* sv
Ap	|IV	|sv_2iv		|SV* sv
Apd	|SV*	|sv_2mortal	|SV* sv
Ap	|NV	|sv_2nv		|SV* sv
Ap	|char*	|sv_2pv		|SV* sv|STRLEN* lp
Ap	|char*	|sv_2pvutf8	|SV* sv|STRLEN* lp
Ap	|char*	|sv_2pvbyte	|SV* sv|STRLEN* lp
Ap	|UV	|sv_2uv		|SV* sv
Ap	|IV	|sv_iv		|SV* sv
Ap	|UV	|sv_uv		|SV* sv
Ap	|NV	|sv_nv		|SV* sv
Ap	|char*	|sv_pvn		|SV *sv|STRLEN *len
Ap	|char*	|sv_pvutf8n	|SV *sv|STRLEN *len
Ap	|char*	|sv_pvbyten	|SV *sv|STRLEN *len
Ap	|I32	|sv_true	|SV *sv
p	|void	|sv_add_arena	|char* ptr|U32 size|U32 flags
Ap	|int	|sv_backoff	|SV* sv
Apd	|SV*	|sv_bless	|SV* sv|HV* stash
Afpd	|void	|sv_catpvf	|SV* sv|const char* pat|...
Ap	|void	|sv_vcatpvf	|SV* sv|const char* pat|va_list* args
Apd	|void	|sv_catpv	|SV* sv|const char* ptr
Apd	|void	|sv_catpvn	|SV* sv|const char* ptr|STRLEN len
Apd	|void	|sv_catsv	|SV* dsv|SV* ssv
Apd	|void	|sv_chop	|SV* sv|char* ptr
p	|void	|sv_clean_all
p	|void	|sv_clean_objs
Ap	|void	|sv_clear	|SV* sv
Apd	|I32	|sv_cmp		|SV* sv1|SV* sv2
Ap	|I32	|sv_cmp_locale	|SV* sv1|SV* sv2
#if defined(USE_LOCALE_COLLATE)
Ap	|char*	|sv_collxfrm	|SV* sv|STRLEN* nxp
#endif
Ap	|OP*	|sv_compile_2op	|SV* sv|OP** startp|char* code|AV** avp
Apd	|void	|sv_dec		|SV* sv
Ap	|void	|sv_dump	|SV* sv
Apd	|bool	|sv_derived_from|SV* sv|const char* name
Apd	|I32	|sv_eq		|SV* sv1|SV* sv2
Ap	|void	|sv_free	|SV* sv
p	|void	|sv_free_arenas
Ap	|char*	|sv_gets	|SV* sv|PerlIO* fp|I32 append
Apd	|char*	|sv_grow	|SV* sv|STRLEN newlen
Apd	|void	|sv_inc		|SV* sv
Apd	|void	|sv_insert	|SV* bigsv|STRLEN offset|STRLEN len \
				|char* little|STRLEN littlelen
Apd	|int	|sv_isa		|SV* sv|const char* name
Apd	|int	|sv_isobject	|SV* sv
Apd	|STRLEN	|sv_len		|SV* sv
Ap	|STRLEN	|sv_len_utf8	|SV* sv
Apd	|void	|sv_magic	|SV* sv|SV* obj|int how|const char* name \
				|I32 namlen
Apd	|SV*	|sv_mortalcopy	|SV* oldsv
Apd	|SV*	|sv_newmortal
Ap	|SV*	|sv_newref	|SV* sv
Ap	|char*	|sv_peek	|SV* sv
Ap	|void	|sv_pos_u2b	|SV* sv|I32* offsetp|I32* lenp
Ap	|void	|sv_pos_b2u	|SV* sv|I32* offsetp
Ap	|char*	|sv_pvn_force	|SV* sv|STRLEN* lp
Ap	|char*	|sv_pvutf8n_force|SV* sv|STRLEN* lp
Ap	|char*	|sv_pvbyten_force|SV* sv|STRLEN* lp
Ap	|char*	|sv_reftype	|SV* sv|int ob
Ap	|void	|sv_replace	|SV* sv|SV* nsv
Ap	|void	|sv_report_used
Ap	|void	|sv_reset	|char* s|HV* stash
Afpd	|void	|sv_setpvf	|SV* sv|const char* pat|...
Ap	|void	|sv_vsetpvf	|SV* sv|const char* pat|va_list* args
Apd	|void	|sv_setiv	|SV* sv|IV num
Apd	|void	|sv_setpviv	|SV* sv|IV num
Apd	|void	|sv_setuv	|SV* sv|UV num
Apd	|void	|sv_setnv	|SV* sv|NV num
Apd	|SV*	|sv_setref_iv	|SV* rv|const char* classname|IV iv
Apd	|SV*	|sv_setref_nv	|SV* rv|const char* classname|NV nv
Apd	|SV*	|sv_setref_pv	|SV* rv|const char* classname|void* pv
Apd	|SV*	|sv_setref_pvn	|SV* rv|const char* classname|char* pv \
				|STRLEN n
Apd	|void	|sv_setpv	|SV* sv|const char* ptr
Apd	|void	|sv_setpvn	|SV* sv|const char* ptr|STRLEN len
Apd	|void	|sv_setsv	|SV* dsv|SV* ssv
Ap	|void	|sv_taint	|SV* sv
Ap	|bool	|sv_tainted	|SV* sv
Ap	|int	|sv_unmagic	|SV* sv|int type
Apd	|void	|sv_unref	|SV* sv
Ap	|void	|sv_untaint	|SV* sv
Apd	|bool	|sv_upgrade	|SV* sv|U32 mt
Apd	|void	|sv_usepvn	|SV* sv|char* ptr|STRLEN len
Apd	|void	|sv_vcatpvfn	|SV* sv|const char* pat|STRLEN patlen \
				|va_list* args|SV** svargs|I32 svmax \
				|bool *maybe_tainted
Apd	|void	|sv_vsetpvfn	|SV* sv|const char* pat|STRLEN patlen \
				|va_list* args|SV** svargs|I32 svmax \
				|bool *maybe_tainted
Ap	|NV	|str_to_version	|SV *sv
Ap	|SV*	|swash_init	|char* pkg|char* name|SV* listsv \
				|I32 minbits|I32 none
Ap	|UV	|swash_fetch	|SV *sv|U8 *ptr
Ap	|void	|taint_env
Ap	|void	|taint_proper	|const char* f|const char* s
Ap	|UV	|to_utf8_lower	|U8 *p
Ap	|UV	|to_utf8_upper	|U8 *p
Ap	|UV	|to_utf8_title	|U8 *p
#if defined(UNLINK_ALL_VERSIONS)
Ap	|I32	|unlnk		|char* f
#endif
#if defined(USE_THREADS)
Ap	|void	|unlock_condpair|void* svv
#endif
Ap	|void	|unsharepvn	|const char* sv|I32 len|U32 hash
p	|void	|unshare_hek	|HEK* hek
p	|void	|utilize	|int aver|I32 floor|OP* version|OP* id|OP* arg
Ap	|U8*	|utf16_to_utf8	|U16* p|U8 *d|I32 bytelen
Ap	|U8*	|utf16_to_utf8_reversed|U16* p|U8 *d|I32 bytelen
Ap	|I32	|utf8_distance	|U8 *a|U8 *b
Ap	|U8*	|utf8_hop	|U8 *s|I32 off
Ap	|UV	|utf8_to_uv	|U8 *s|I32* retlen
Ap	|U8*	|uv_to_utf8	|U8 *d|UV uv
p	|void	|vivify_defelem	|SV* sv
p	|void	|vivify_ref	|SV* sv|U32 to_what
p	|I32	|wait4pid	|Pid_t pid|int* statusp|int flags
p	|void	|report_closed_fh|GV *gv|IO *io|const char *func|const char *obj
p	|void	|report_uninit
Afpd	|void	|warn		|const char* pat|...
Ap	|void	|vwarn		|const char* pat|va_list* args
Afp	|void	|warner		|U32 err|const char* pat|...
Ap	|void	|vwarner	|U32 err|const char* pat|va_list* args
p	|void	|watch		|char** addr
p	|I32	|whichsig	|char* sig
p	|int	|yyerror	|char* s
#if defined(USE_PURE_BISON)
p	|int	|yylex		|YYSTYPE *lvalp|int *lcharp
#else
p	|int	|yylex
#endif
p	|int	|yyparse
p	|int	|yywarn		|char* s
#if defined(MYMALLOC)
Ap	|void	|dump_mstats	|char* s
Ap	|int	|get_mstats	|perl_mstats_t *buf|int buflen|int level
#endif
Anp	|Malloc_t|safesysmalloc	|MEM_SIZE nbytes
Anp	|Malloc_t|safesyscalloc	|MEM_SIZE elements|MEM_SIZE size
Anp	|Malloc_t|safesysrealloc|Malloc_t where|MEM_SIZE nbytes
Anp	|Free_t	|safesysfree	|Malloc_t where
#if defined(LEAKTEST)
Anp	|Malloc_t|safexmalloc	|I32 x|MEM_SIZE size
Anp	|Malloc_t|safexcalloc	|I32 x|MEM_SIZE elements|MEM_SIZE size
Anp	|Malloc_t|safexrealloc	|Malloc_t where|MEM_SIZE size
Anp	|void	|safexfree	|Malloc_t where
#endif
#if defined(PERL_GLOBAL_STRUCT)
Ap	|struct perl_vars *|GetVars
#endif
Ap	|int	|runops_standard
Ap	|int	|runops_debug
Afpd	|void	|sv_catpvf_mg	|SV *sv|const char* pat|...
Ap	|void	|sv_vcatpvf_mg	|SV* sv|const char* pat|va_list* args
Apd	|void	|sv_catpv_mg	|SV *sv|const char *ptr
Apd	|void	|sv_catpvn_mg	|SV *sv|const char *ptr|STRLEN len
Apd	|void	|sv_catsv_mg	|SV *dstr|SV *sstr
Afpd	|void	|sv_setpvf_mg	|SV *sv|const char* pat|...
Ap	|void	|sv_vsetpvf_mg	|SV* sv|const char* pat|va_list* args
Apd	|void	|sv_setiv_mg	|SV *sv|IV i
Apd	|void	|sv_setpviv_mg	|SV *sv|IV iv
Apd	|void	|sv_setuv_mg	|SV *sv|UV u
Apd	|void	|sv_setnv_mg	|SV *sv|NV num
Apd	|void	|sv_setpv_mg	|SV *sv|const char *ptr
Apd	|void	|sv_setpvn_mg	|SV *sv|const char *ptr|STRLEN len
Apd	|void	|sv_setsv_mg	|SV *dstr|SV *sstr
Apd	|void	|sv_usepvn_mg	|SV *sv|char *ptr|STRLEN len
Ap	|MGVTBL*|get_vtbl	|int vtbl_id
p	|char*	|pv_display	|SV *sv|char *pv|STRLEN cur|STRLEN len \
				|STRLEN pvlim
Afp	|void	|dump_indent	|I32 level|PerlIO *file|const char* pat|...
Ap	|void	|dump_vindent	|I32 level|PerlIO *file|const char* pat \
				|va_list *args
Ap	|void	|do_gv_dump	|I32 level|PerlIO *file|char *name|GV *sv
Ap	|void	|do_gvgv_dump	|I32 level|PerlIO *file|char *name|GV *sv
Ap	|void	|do_hv_dump	|I32 level|PerlIO *file|char *name|HV *sv
Ap	|void	|do_magic_dump	|I32 level|PerlIO *file|MAGIC *mg|I32 nest \
				|I32 maxnest|bool dumpops|STRLEN pvlim
Ap	|void	|do_op_dump	|I32 level|PerlIO *file|OP *o
Ap	|void	|do_pmop_dump	|I32 level|PerlIO *file|PMOP *pm
Ap	|void	|do_sv_dump	|I32 level|PerlIO *file|SV *sv|I32 nest \
				|I32 maxnest|bool dumpops|STRLEN pvlim
Ap	|void	|magic_dump	|MAGIC *mg
#if defined(PERL_FLEXIBLE_EXCEPTIONS)
Ap	|void*	|default_protect|volatile JMPENV *je|int *excpt \
				|protect_body_t body|...
Ap	|void*	|vdefault_protect|volatile JMPENV *je|int *excpt \
				|protect_body_t body|va_list *args
#endif
Ap	|void	|reginitcolors
Ap	|char*	|sv_2pv_nolen	|SV* sv
Ap	|char*	|sv_2pvutf8_nolen|SV* sv
Ap	|char*	|sv_2pvbyte_nolen|SV* sv
Ap	|char*	|sv_pv		|SV *sv
Ap	|char*	|sv_pvutf8	|SV *sv
Ap	|char*	|sv_pvbyte	|SV *sv
Ap      |void   |sv_utf8_upgrade|SV *sv
Ap      |bool   |sv_utf8_downgrade|SV *sv|bool fail_ok
Ap      |void   |sv_utf8_encode |SV *sv
Ap      |bool   |sv_utf8_decode |SV *sv
Ap	|void	|sv_force_normal|SV *sv
Ap	|void	|tmps_grow	|I32 n
Ap	|SV*	|sv_rvweaken	|SV *sv
p	|int	|magic_killbackrefs|SV *sv|MAGIC *mg
Ap	|OP*	|newANONATTRSUB	|I32 floor|OP *proto|OP *attrs|OP *block
Ap	|CV*	|newATTRSUB	|I32 floor|OP *o|OP *proto|OP *attrs|OP *block
Ap	|void	|newMYSUB	|I32 floor|OP *o|OP *proto|OP *attrs|OP *block
p	|OP *	|my_attrs	|OP *o|OP *attrs
p	|void	|boot_core_xsutils
#if defined(USE_ITHREADS)
Ap	|PERL_CONTEXT*|cx_dup	|PERL_CONTEXT* cx|I32 ix|I32 max
Ap	|PERL_SI*|si_dup	|PERL_SI* si
Ap	|ANY*	|ss_dup		|PerlInterpreter* proto_perl
Ap	|void*	|any_dup	|void* v|PerlInterpreter* proto_perl
Ap	|HE*	|he_dup		|HE* e|bool shared
Ap	|REGEXP*|re_dup		|REGEXP* r
Ap	|PerlIO*|fp_dup		|PerlIO* fp|char type
Ap	|DIR*	|dirp_dup	|DIR* dp
Ap	|GP*	|gp_dup		|GP* gp
Ap	|MAGIC*	|mg_dup		|MAGIC* mg
Ap	|SV*	|sv_dup		|SV* sstr
#if defined(HAVE_INTERP_INTERN)
Ap	|void	|sys_intern_dup	|struct interp_intern* src \
				|struct interp_intern* dst
#endif
Ap	|PTR_TBL_t*|ptr_table_new
Ap	|void*	|ptr_table_fetch|PTR_TBL_t *tbl|void *sv
Ap	|void	|ptr_table_store|PTR_TBL_t *tbl|void *oldsv|void *newsv
Ap	|void	|ptr_table_split|PTR_TBL_t *tbl
#endif

#if defined(PERL_OBJECT)
protected:
#else
END_EXTERN_C
#endif

#if defined(PERL_IN_AV_C) || defined(PERL_DECL_PROT)
s	|I32	|avhv_index_sv	|SV* sv
s	|I32	|avhv_index	|AV* av|SV* sv|U32 hash
#endif

#if defined(PERL_IN_DOOP_C) || defined(PERL_DECL_PROT)
s	|I32	|do_trans_CC_simple	|SV *sv
s	|I32	|do_trans_CC_count	|SV *sv
s	|I32	|do_trans_CC_complex	|SV *sv
s	|I32	|do_trans_UU_simple	|SV *sv
s	|I32	|do_trans_UU_count	|SV *sv
s	|I32	|do_trans_UU_complex	|SV *sv
s	|I32	|do_trans_UC_simple	|SV *sv
s	|I32	|do_trans_CU_simple	|SV *sv
s	|I32	|do_trans_UC_trivial	|SV *sv
s	|I32	|do_trans_CU_trivial	|SV *sv
#endif

#if defined(PERL_IN_GV_C) || defined(PERL_DECL_PROT)
s	|void	|gv_init_sv	|GV *gv|I32 sv_type
#endif

#if defined(PERL_IN_HV_C) || defined(PERL_DECL_PROT)
s	|void	|hsplit		|HV *hv
s	|void	|hfreeentries	|HV *hv
s	|void	|more_he
s	|HE*	|new_he
s	|void	|del_he		|HE *p
s	|HEK*	|save_hek	|const char *str|I32 len|U32 hash
s	|void	|hv_magic_check	|HV *hv|bool *needs_copy|bool *needs_store
#endif

#if defined(PERL_IN_MG_C) || defined(PERL_DECL_PROT)
s	|void	|save_magic	|I32 mgs_ix|SV *sv
s	|int	|magic_methpack	|SV *sv|MAGIC *mg|char *meth
s	|int	|magic_methcall	|SV *sv|MAGIC *mg|char *meth|I32 f \
				|int n|SV *val
#endif

#if defined(PERL_IN_OP_C) || defined(PERL_DECL_PROT)
s	|I32	|list_assignment|OP *o
s	|void	|bad_type	|I32 n|char *t|char *name|OP *kid
s	|void	|cop_free	|COP *cop
s	|OP*	|modkids	|OP *o|I32 type
s	|void	|no_bareword_allowed|OP *o
s	|OP*	|no_fh_allowed	|OP *o
s	|OP*	|scalarboolean	|OP *o
s	|OP*	|too_few_arguments|OP *o|char* name
s	|OP*	|too_many_arguments|OP *o|char* name
s	|void	|op_clear	|OP* o
s	|void	|null		|OP* o
s	|PADOFFSET|pad_addlex	|SV* name
s	|PADOFFSET|pad_findlex	|char* name|PADOFFSET newoff|U32 seq \
				|CV* startcv|I32 cx_ix|I32 saweval|U32 flags
s	|OP*	|newDEFSVOP
s	|OP*	|new_logop	|I32 type|I32 flags|OP **firstp|OP **otherp
s	|void	|simplify_sort	|OP *o
s	|bool	|is_handle_constructor	|OP *o|I32 argnum
s	|char*	|gv_ename	|GV *gv
s	|void	|cv_dump	|CV *cv
s	|CV*	|cv_clone2	|CV *proto|CV *outside
s	|bool	|scalar_mod_type|OP *o|I32 type
s	|OP *	|my_kid		|OP *o|OP *attrs
s	|OP *	|dup_attrlist	|OP *o
s	|void	|apply_attrs	|HV *stash|SV *target|OP *attrs
#  if defined(PL_OP_SLAB_ALLOC)
s	|void*	|Slab_Alloc	|int m|size_t sz
#  endif
#endif

#if defined(PERL_IN_PERL_C) || defined(PERL_DECL_PROT)
s	|void	|find_beginning
s	|void	|forbid_setid	|char *
s	|void	|incpush	|char *|int|int
s	|void	|init_interp
s	|void	|init_ids
s	|void	|init_lexer
s	|void	|init_main_stash
s	|void	|init_perllib
s	|void	|init_postdump_symbols|int|char **|char **
s	|void	|init_predump_symbols
rs	|void	|my_exit_jump
s	|void	|nuke_stacks
s	|void	|open_script	|char *|bool|SV *|int *fd
s	|void	|usage		|char *
s	|void	|validate_suid	|char *|char*|int
#  if defined(IAMSUID)
s	|int	|fd_on_nosuid_fs|int fd
#  endif
s	|void*	|parse_body	|char **env|XSINIT_t xsinit
s	|void*	|run_body	|I32 oldscope
s	|void	|call_body	|OP *myop|int is_eval
s	|void*	|call_list_body	|CV *cv
#if defined(PERL_FLEXIBLE_EXCEPTIONS)
s	|void*	|vparse_body	|va_list args
s	|void*	|vrun_body	|va_list args
s	|void*	|vcall_body	|va_list args
s	|void*	|vcall_list_body|va_list args
#endif
#  if defined(USE_THREADS)
s	|struct perl_thread *	|init_main_thread
#  endif
#endif

#if defined(PERL_IN_PP_C) || defined(PERL_DECL_PROT)
s	|void	|doencodes	|SV* sv|char* s|I32 len
s	|SV*	|refto		|SV* sv
s	|U32	|seed
s	|SV*	|mul128		|SV *sv|U8 m
s	|SV*	|is_an_int	|char *s|STRLEN l
s	|int	|div128		|SV *pnum|bool *done
#endif

#if defined(PERL_IN_PP_CTL_C) || defined(PERL_DECL_PROT)
s	|OP*	|docatch	|OP *o
s	|void*	|docatch_body
#if defined(PERL_FLEXIBLE_EXCEPTIONS)
s	|void*	|vdocatch_body	|va_list args
#endif
s	|OP*	|dofindlabel	|OP *o|char *label|OP **opstack|OP **oplimit
s	|void	|doparseform	|SV *sv
s	|I32	|dopoptoeval	|I32 startingblock
s	|I32	|dopoptolabel	|char *label
s	|I32	|dopoptoloop	|I32 startingblock
s	|I32	|dopoptosub	|I32 startingblock
s	|I32	|dopoptosub_at	|PERL_CONTEXT* cxstk|I32 startingblock
s	|void	|free_closures
s	|void	|save_lines	|AV *array|SV *sv
s	|OP*	|doeval		|int gimme|OP** startop
s	|PerlIO *|doopen_pmc	|const char *name|const char *mode
s	|void	|qsortsv	|SV ** array|size_t num_elts|SVCOMPARE_t f
#endif

#if defined(PERL_IN_PP_HOT_C) || defined(PERL_DECL_PROT)
s	|int	|do_maybe_phash	|AV *ary|SV **lelem|SV **firstlelem \
				|SV **relem|SV **lastrelem
s	|void	|do_oddball	|HV *hash|SV **relem|SV **firstrelem
s	|CV*	|get_db_sub	|SV **svp|CV *cv
s	|SV*	|method_common	|SV* meth|U32* hashp
#endif

#if defined(PERL_IN_PP_SYS_C) || defined(PERL_DECL_PROT)
s	|OP*	|doform		|CV *cv|GV *gv|OP *retop
s	|int	|emulate_eaccess|const char* path|Mode_t mode
#  if !defined(HAS_MKDIR) || !defined(HAS_RMDIR)
s	|int	|dooneliner	|char *cmd|char *filename
#  endif
#endif

#if defined(PERL_IN_REGCOMP_C) || defined(PERL_DECL_PROT)
s	|regnode*|reg		|I32|I32 *
s	|regnode*|reganode	|U8|U32
s	|regnode*|regatom	|I32 *
s	|regnode*|regbranch	|I32 *|I32
s	|void	|reguni		|UV|char *|I32*
s	|regnode*|regclass
s	|regnode*|regclassutf8
s	|I32	|regcurly	|char *
s	|regnode*|reg_node	|U8
s	|regnode*|regpiece	|I32 *
s	|void	|reginsert	|U8|regnode *
s	|void	|regoptail	|regnode *|regnode *
s	|void	|regtail	|regnode *|regnode *
s	|char*|regwhite	|char *|char *
s	|char*|nextchar
s	|regnode*|dumpuntil	|regnode *start|regnode *node \
				|regnode *last|SV* sv|I32 l
s	|void	|put_byte	|SV* sv|int c
s	|void	|scan_commit	|struct scan_data_t *data
s	|void	|cl_anything	|struct regnode_charclass_class *cl
s	|int	|cl_is_anything	|struct regnode_charclass_class *cl
s	|void	|cl_init	|struct regnode_charclass_class *cl
s	|void	|cl_init_zero	|struct regnode_charclass_class *cl
s	|void	|cl_and		|struct regnode_charclass_class *cl \
				|struct regnode_charclass_class *and_with
s	|void	|cl_or		|struct regnode_charclass_class *cl \
				|struct regnode_charclass_class *or_with
s	|I32	|study_chunk	|regnode **scanp|I32 *deltap \
				|regnode *last|struct scan_data_t *data \
				|U32 flags
s	|I32	|add_data	|I32 n|char *s
rs	|void|re_croak2	|const char* pat1|const char* pat2|...
s	|I32	|regpposixcc	|I32 value
s	|void	|checkposixcc
#endif

#if defined(PERL_IN_REGEXEC_C) || defined(PERL_DECL_PROT)
s	|I32	|regmatch	|regnode *prog
s	|I32	|regrepeat	|regnode *p|I32 max
s	|I32	|regrepeat_hard	|regnode *p|I32 max|I32 *lp
s	|I32	|regtry		|regexp *prog|char *startpos
s	|bool	|reginclass	|regnode *p|I32 c
s	|bool	|reginclassutf8	|regnode *f|U8* p
s	|CHECKPOINT|regcppush	|I32 parenfloor
s	|char*|regcppop
s	|char*|regcp_set_to	|I32 ss
s	|void	|cache_re	|regexp *prog
s	|U8*	|reghop		|U8 *pos|I32 off
s	|U8*	|reghopmaybe	|U8 *pos|I32 off
s	|char*	|find_byclass	|regexp * prog|regnode *c|char *s|char *strend|char *startpos|I32 norun
#endif

#if defined(PERL_IN_RUN_C) || defined(PERL_DECL_PROT)
s	|void	|debprof	|OP *o
#endif

#if defined(PERL_IN_SCOPE_C) || defined(PERL_DECL_PROT)
s	|SV*	|save_scalar_at	|SV **sptr
#endif

#if defined(PERL_IN_SV_C) || defined(PERL_DECL_PROT)
s	|IV	|asIV		|SV* sv
s	|UV	|asUV		|SV* sv
s	|SV*	|more_sv
s	|void	|more_xiv
s	|void	|more_xnv
s	|void	|more_xpv
s	|void	|more_xpviv
s	|void	|more_xpvnv
s	|void	|more_xpvcv
s	|void	|more_xpvav
s	|void	|more_xpvhv
s	|void	|more_xpvmg
s	|void	|more_xpvlv
s	|void	|more_xpvbm
s	|void	|more_xrv
s	|XPVIV*	|new_xiv
s	|XPVNV*	|new_xnv
s	|XPV*	|new_xpv
s	|XPVIV*	|new_xpviv
s	|XPVNV*	|new_xpvnv
s	|XPVCV*	|new_xpvcv
s	|XPVAV*	|new_xpvav
s	|XPVHV*	|new_xpvhv
s	|XPVMG*	|new_xpvmg
s	|XPVLV*	|new_xpvlv
s	|XPVBM*	|new_xpvbm
s	|XRV*	|new_xrv
s	|void	|del_xiv	|XPVIV* p
s	|void	|del_xnv	|XPVNV* p
s	|void	|del_xpv	|XPV* p
s	|void	|del_xpviv	|XPVIV* p
s	|void	|del_xpvnv	|XPVNV* p
s	|void	|del_xpvcv	|XPVCV* p
s	|void	|del_xpvav	|XPVAV* p
s	|void	|del_xpvhv	|XPVHV* p
s	|void	|del_xpvmg	|XPVMG* p
s	|void	|del_xpvlv	|XPVLV* p
s	|void	|del_xpvbm	|XPVBM* p
s	|void	|del_xrv	|XRV* p
s	|void	|sv_unglob	|SV* sv
s	|void	|not_a_number	|SV *sv
s	|void	|visit		|SVFUNC_t f
s	|void	|sv_add_backref	|SV *tsv|SV *sv
s	|void	|sv_del_backref	|SV *sv
#  if defined(DEBUGGING)
s	|void	|del_sv	|SV *p
#  endif
#endif

#if defined(PERL_IN_TOKE_C) || defined(PERL_DECL_PROT)
s	|void	|check_uni
s	|void	|force_next	|I32 type
s	|char*	|force_version	|char *start
s	|char*	|force_word	|char *start|int token|int check_keyword \
				|int allow_pack|int allow_tick
s	|SV*	|tokeq		|SV *sv
s	|char*	|scan_const	|char *start
s	|char*	|scan_formline	|char *s
s	|char*	|scan_heredoc	|char *s
s	|char*	|scan_ident	|char *s|char *send|char *dest \
				|STRLEN destlen|I32 ck_uni
s	|char*	|scan_inputsymbol|char *start
s	|char*	|scan_pat	|char *start|I32 type
s	|char*	|scan_str	|char *start|int keep_quoted|int keep_delims
s	|char*	|scan_subst	|char *start
s	|char*	|scan_trans	|char *start
s	|char*	|scan_word	|char *s|char *dest|STRLEN destlen \
				|int allow_package|STRLEN *slp
s	|char*	|skipspace	|char *s
s	|void	|checkcomma	|char *s|char *name|char *what
s	|void	|force_ident	|char *s|int kind
s	|void	|incline	|char *s
s	|int	|intuit_method	|char *s|GV *gv
s	|int	|intuit_more	|char *s
s	|I32	|lop		|I32 f|int x|char *s
s	|void	|missingterm	|char *s
s	|void	|no_op		|char *what|char *s
s	|void	|set_csh
s	|I32	|sublex_done
s	|I32	|sublex_push
s	|I32	|sublex_start
s	|char *	|filter_gets	|SV *sv|PerlIO *fp|STRLEN append
s	|SV*	|new_constant	|char *s|STRLEN len|const char *key|SV *sv \
				|SV *pv|const char *type
s	|int	|ao		|int toketype
s	|void	|depcom
s	|char*	|incl_perldb
#if 0
s	|I32	|utf16_textfilter|int idx|SV *sv|int maxlen
s	|I32	|utf16rev_textfilter|int idx|SV *sv|int maxlen
#endif
#  if defined(CRIPPLED_CC)
s	|int	|uni		|I32 f|char *s
#  endif
#  if defined(PERL_CR_FILTER)
s	|I32	|cr_textfilter	|int idx|SV *sv|int maxlen
#  endif
#endif

#if defined(PERL_IN_UNIVERSAL_C) || defined(PERL_DECL_PROT)
s	|SV*|isa_lookup	|HV *stash|const char *name|int len|int level
#endif

#if defined(PERL_IN_UTIL_C) || defined(PERL_DECL_PROT)
s	|SV*	|mess_alloc
#  if defined(LEAKTEST)
s	|void	|xstat		|int
#  endif
#endif

#if defined(PERL_OBJECT)
};
#endif
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@a27 1
	unlink $filename;
a200 1
		 ppaddr
a918 3
#undef PERLVARIC
#define PERLVARIC(v,t,i)	const t* Perl_##v##_ptr(pTHXo)		\
			{ return (const t *)&(PL_##v); }
a1066 10
#undef Perl_printf_nocontext
int
Perl_printf_nocontext(const char *format, ...)
{
    dTHXo;
    va_list(arglist);
    va_start(arglist, format);
    return (*PL_StdIO->pVprintf)(PL_StdIO, PerlIO_stdout(), format, arglist);
}

d1081 4
a1084 3
sub autodoc ($$) { # parse a file and extract documentation info
    my($fh,$file) = @@_;
    my($in, $doc, $line);
a1086 1
	$line++;
a1093 1
		$line++;
a1094 4
		if ($doc =~ m:^\*/$:) {
		    warn "=cut missing? $file:$line:$doc";;
		    last DOC;
		}
d1100 1
a1100 1
		    $apidocs{$name} = [$flags, $docs, $ret, $file, @@args];
d1103 1
a1103 1
		    $gutsdocs{$name} = [$flags, $docs, $ret, $file, @@args];
d1107 1
a1107 1
		$docfuncs{$name} = [$flags, $docs, $ret, $file, @@args];
d1109 3
a1111 7
	    if (defined $doc) {
		if ($doc =~ /^=for/) {
		    $in = $doc;
		    redo FUNC;
		}
	    } else {
		warn "$file:$line:$in";
d1119 1
a1119 1
    my($flags, $docs, $ret, $file, @@args) = @@$docref;
a1120 2
    $docs .= "NOTE: this function is experimental and may change or be
removed without notice.\n\n" if $flags =~ /x/;
a1136 1
    print $fh "=for hackers\nFound in file $file\n\n";
d1142 1
a1142 1
    autodoc(\*F,$file);
d1159 1
a1159 3
        $docref->[0].="x" if $flags =~ /M/;
	    $apidocs{$func} = [$docref->[0] . 'A', $docref->[1], $retval,
			       $docref->[3], @@args];
d1162 1
a1162 2
	    $gutsdocs{$func} = [$docref->[0], $docref->[1], $retval,
				$docref->[3], @@args];
a1168 2
    # Have you used a full for apidoc or just a func name?  
    # Have you used Ap instead of Am in the for apidoc?
d1238 1
a1238 1
Perl interpreter that are documented using Perl's internal documentation
d1255 1
a1255 1
The autodocumentation system was originally added to the Perl core by 
a1287 1
:       M		may change
a1360 1
Ap	|void	|apply_attrs_string|char *stashpv|CV *cv|char *attrstr|STRLEN len
d1369 2
a1370 2
Apd	|SV*	|av_delete	|AV* ar|I32 key|I32 flags
Apd	|bool	|av_exists	|AV* ar|I32 key
d1372 1
a1372 1
p	|AV*	|av_fake	|I32 size|SV** svp
d1374 1
a1374 1
Apd	|void	|av_fill	|AV* ar|I32 fill
d1379 1
a1379 1
ApM	|void	|av_reify	|AV* ar
d1409 1
a1409 1
Anp	|void	|load_module_nocontext|U32 flags|SV* name|SV* ver|...
a1418 1
Afnp	|int	|printf_nocontext|const char* fmt|...
d1450 1
a1450 1
Ap	|int	|do_binmode	|PerlIO *fp|int iotype|int mode
d1467 1
a1467 1
Ap	|void	|do_join	|SV* sv|SV* del|SV** mark|SV** sp
d1514 1
a1514 1
p	|char*	|getenv_len	|const char* key|unsigned long *len
a1525 1
Ap	|void	|gv_efullname4	|SV* sv|GV* gv|const char* prefix|bool keepmain
a1534 1
Ap	|void	|gv_fullname4	|SV* sv|GV* gv|const char* prefix|bool keepmain
a1569 2
dp	|bool	|is_gv_magical	|char *name|STRLEN len|U32 flags
p	|I32	|is_lvalue_sub
d1604 1
a1604 2
Apd	|STRLEN	|is_utf8_char	|U8 *p
Apd	|bool	|is_utf8_string	|U8 *s|STRLEN len
d1628 1
a1628 1
Ap	|void	|load_module|U32 flags|SV* name|SV* ver|...
a1656 1
p	|int	|magic_regdatum_set|SV* sv|MAGIC* mg
d1827 3
a1829 3
Ap	|void	|new_collate	|char* newcoll
Ap	|void	|new_ctype	|char* newctype
Ap	|void	|new_numeric	|char* newcoll
d1863 1
a1863 1
Ap	|Sighandler_t|rsignal	|int i|Sighandler_t t
a1887 1
Ap	|void	|save_generic_pvref|char** str
a1900 1
Ap	|void	|save_mortalizesv|SV* sv
a1906 1
Ap	|void	|save_padsv	|PADOFFSET off
d1915 4
a1918 4
Ap	|NV	|scan_bin	|char* start|STRLEN len|STRLEN* retlen
Ap	|NV	|scan_hex	|char* start|STRLEN len|STRLEN* retlen
Ap	|char*	|scan_num	|char* s|YYSTYPE *lvalp
Ap	|NV	|scan_oct	|char* start|STRLEN len|STRLEN* retlen
d1948 1
a1948 1
Apd	|I32	|sv_true	|SV *sv
d1958 1
a1958 1
p	|I32	|sv_clean_all
d1960 1
a1960 1
Apd	|void	|sv_clear	|SV* sv
d1962 1
a1962 1
Apd	|I32	|sv_cmp_locale	|SV* sv1|SV* sv2
d1971 1
a1971 1
Apd	|void	|sv_free	|SV* sv
d1973 1
a1973 1
Apd	|char*	|sv_gets	|SV* sv|PerlIO* fp|I32 append
d1981 1
a1981 1
Apd	|STRLEN	|sv_len_utf8	|SV* sv
d1990 2
a1991 2
Apd	|char*	|sv_pvn_force	|SV* sv|STRLEN* lp
Apd	|char*	|sv_pvutf8n_force|SV* sv|STRLEN* lp
d1993 2
a1994 2
Apd	|char*	|sv_reftype	|SV* sv|int ob
Apd	|void	|sv_replace	|SV* sv|SV* nsv
d2013 1
a2013 1
Apd	|int	|sv_unmagic	|SV* sv|int type
d2042 6
a2047 11
ApM	|U8*	|utf16_to_utf8	|U8* p|U8 *d|I32 bytelen|I32 *newlen
ApM	|U8*	|utf16_to_utf8_reversed|U8* p|U8 *d|I32 bytelen|I32 *newlen
ApMd	|STRLEN	|utf8_length	|U8* s|U8 *e
ApMd	|IV	|utf8_distance	|U8 *a|U8 *b
ApMd	|U8*	|utf8_hop	|U8 *s|I32 off
ApMd	|U8*	|utf8_to_bytes	|U8 *s|STRLEN *len
ApMd	|U8*	|bytes_from_utf8|U8 *s|STRLEN *len|bool *is_utf8
ApMd	|U8*	|bytes_to_utf8	|U8 *s|STRLEN *len
ApMd	|UV	|utf8_to_uv_simple|U8 *s|STRLEN* retlen
ApMd	|UV	|utf8_to_uv	|U8 *s|STRLEN curlen|STRLEN* retlen|U32 flags
ApMd	|U8*	|uv_to_utf8	|U8 *d|UV uv
d2051 1
a2051 1
p	|void	|report_evil_fh	|GV *gv|IO *io|I32 op
d2058 1
a2058 1
Ap	|I32	|whichsig	|char* sig
d2060 4
a2063 2
#ifdef USE_PURE_BISON
p	|int	|yylex_r	|YYSTYPE *lvalp|int *lcharp
a2064 1
p	|int	|yylex
a2085 3
#if defined(USE_THREADS)
Ap	|SV*	|sv_lock	|SV *sv
#endif
d2130 4
a2133 4
ApMd	|void   |sv_utf8_upgrade|SV *sv
ApMd	|bool   |sv_utf8_downgrade|SV *sv|bool fail_ok
ApMd	|void   |sv_utf8_encode |SV *sv
ApM	|bool   |sv_utf8_decode |SV *sv
a2134 2
Ap	|void	|sv_add_backref	|SV *tsv|SV *sv
Ap	|void	|sv_del_backref	|SV *sv
d2136 1
a2136 1
Apd	|SV*	|sv_rvweaken	|SV *sv
a2162 6
Ap	|void	|ptr_table_clear|PTR_TBL_t *tbl
Ap	|void	|ptr_table_free|PTR_TBL_t *tbl
#endif
#if defined(HAVE_INTERP_INTERN)
Ap	|void	|sys_intern_clear
Ap	|void	|sys_intern_init
d2177 10
a2186 6
s	|I32	|do_trans_simple	|SV *sv
s	|I32	|do_trans_count		|SV *sv
s	|I32	|do_trans_complex	|SV *sv
s	|I32	|do_trans_simple_utf8	|SV *sv
s	|I32	|do_trans_count_utf8	|SV *sv
s	|I32	|do_trans_complex_utf8	|SV *sv
a2219 1
s	|U8*	|trlist_upgrade	|U8** sp|U8** ep
d2297 1
d2325 1
a2325 1
s	|void	|reguni		|UV|char *|STRLEN*
d2423 3
a2425 1
s	|I32	|visit		|SVFUNC_t f
a2450 1
s	|char*	|swallow_bom	|U8 *s
a2463 1
s	|HV *	|find_in_my_stash|char *pkgname|I32 len
a2485 1
s	|char*	|stdize_locale	|char* locs
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d7 1
a7 1
# See database of global and static function prototypes in embed.fnc
d13 1
a13 1
open IN, "embed.fnc" or die $!;
d33 2
a34 2
    seek IN, 0, 0;		# so we may restart
    while (<IN>) {
d38 1
a38 1
	    $_ .= <IN>;
d48 1
a48 2
        my @@outs = &{$function}(@@args);
        print $F @@outs; # $function->(@@args) is not 5.003
a115 1
	$ret .= '/* ' if $flags =~ /m/;
d139 1
a139 1
	if( $flags =~ /f/ ) {
d141 1
a141 1
	    my $args = scalar @@args;
d144 1
a144 1
				    $prefix, $args - 1, $prefix, $args;
d147 1
a147 3
	$ret .= ";";
	$ret .= ' */' if $flags =~ /m/;
	$ret .= "\n";
d157 1
a157 1
	if ($flags =~ /A/ && $flags !~ /[xm]/) { # public API, so export
a167 7
 *    proto.h
 *
 *    Copyright (c) 1997-2002, Larry Wall
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
a176 7
#    global.sym
#
#    Copyright (c) 1997-2002, Larry Wall
#
#    You may distribute under the terms of either the GNU General Public
#    License or the Artistic License, as specified in the README file.
#
d189 1
a189 1
                 curcop compiling
d193 1
a193 1
                 rsfp
d250 1
a250 2
my $sym;
foreach $sym (sort keys %thread) {
d267 1
a267 1
    my $arg = ($pfx eq 'G' ? 'NULL' : 'aTHX');
d285 4
a288 12
/*
 *    embed.h
 *
 *    Copyright (c) 1997-2002, Larry Wall
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 *  !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
 *  This file is built by embed.pl from data in embed.pl, pp.sym, intrpvar.h,
 *  perlvars.h and thrdvar.h.  Any changes made here will be lost!
 */
d294 36
d332 1
d345 1
a345 1
	unless ($flags =~ /[om]/) {
d378 1
a378 1
	unless ($flags =~ /[om]/) {
d426 1
d430 29
d461 2
d472 1
a472 1
#if !defined(PERL_CORE) && !defined(PERL_NOCOMPAT)
d503 1
a503 1
#if defined(PERL_IMPLICIT_CONTEXT)
d547 4
a550 13
/*
 *    embedvar.h
 *
 *    Copyright (c) 1997-2002, Larry Wall
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 *
 * !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
 *  This file is built by embed.pl from data in embed.pl, pp.sym, intrpvar.h,
 *  perlvars.h and thrdvar.h.  Any changes made here will be lost!
 */
d555 1
a555 1
   The following combinations of MULTIPLICITY, USE_5005THREADS
d560 3
a562 2
     4) USE_5005THREADS && PERL_IMPLICIT_CONTEXT
     5) MULTIPLICITY && USE_5005THREADS && PERL_IMPLICIT_CONTEXT
d587 5
a591 1
#  if defined(USE_5005THREADS)
d602 1
a602 1
#  else		/* !USE_5005THREADS */
d613 1
a613 1
#  endif	/* USE_5005THREADS */
d617 18
d645 1
a645 1
#  if defined(USE_5005THREADS)
d656 1
a656 1
#  else	/* !USE_5005THREADS */
d667 2
a668 1
#  endif	/* USE_5005THREADS */
d708 57
d771 4
a774 13
/*
 *    perlapi.h
 *
 *    Copyright (c) 1997-2002, Larry Wall
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 *
 * !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
 *  This file is built by embed.pl from data in embed.pl, pp.sym, intrpvar.h,
 *  perlvars.h and thrdvar.h.  Any changes made here will be lost!
 */
d780 8
a787 1
#if defined (MULTIPLICITY)
d795 1
a795 1
#define PERLVAR(v,t)	EXTERN_C t* Perl_##v##_ptr(pTHX);
d797 1
a797 1
			EXTERN_C PL_##v##_t* Perl_##v##_ptr(pTHX);
d847 1
a847 1
END_EXTERN_C
d855 1
a855 1
foreach $sym (sort keys %intrp) {
d859 1
a859 1
foreach $sym (sort keys %thread) {
d863 1
a863 1
foreach $sym (sort keys %globvar) {
d870 1
a870 1
#endif /* MULTIPLICITY */
d878 4
a881 13
/*
 *    perlapi.c
 *
 *    Copyright (c) 1997-2002, Larry Wall
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 *
 * !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
 *  This file is built by embed.pl from data in embed.pl, pp.sym, intrpvar.h,
 *  perlvars.h and thrdvar.h.  Any changes made here will be lost!
 */
d887 1
a887 1
#if defined (MULTIPLICITY)
d897 6
d907 1
d917 1
a917 1
#define PERLVAR(v,t)	t* Perl_##v##_ptr(pTHX)				\
d919 1
a919 1
#define PERLVARA(v,n,t)	PL_##v##_t* Perl_##v##_ptr(pTHX)		\
d922 1
a922 1
#define PERLVARIC(v,t,i)	const t* Perl_##v##_ptr(pTHX)		\
d931 3
a933 1
END_EXTERN_C
a934 1
#endif /* MULTIPLICITY */
a936 2
close(CAPI);

a938 1
# XXX %vfuncs currently unused
d956 1595
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@a5 5
BEGIN {
    # Get function prototypes
    require 'regen_lib.pl';
}

a12 62
sub do_not_edit ($)
{
    my $file = shift;
    
    my $years;

    if ($file eq 'embed.h') {
        $years = '1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003';
    } elsif ($file eq 'embedvar.h') {
        $years = '1999, 2000, 2001, 2002, 2003';
    } elsif ($file eq 'global.sym') {
        $years = '1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003';
    } elsif ($file eq 'perlapi.c') {
        $years = '1999, 2000, 2001';
    } elsif ($file eq 'perlapi.h') {
        $years = '1999, 2000, 2001, 2002, 2003';
    } elsif ($file eq 'proto.h') {
        $years = '1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003';
    }

    $years =~ s/1999,/1999,\n  / if length $years > 40;

    my $warning = <<EOW;

   $file

   Copyright (C) $years, by Larry Wall and others

   You may distribute under the terms of either the GNU General Public
   License or the Artistic License, as specified in the README file.

!!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
This file is built by embed.pl from data in embed.fnc, embed.pl,
pp.sym, intrpvar.h, perlvars.h and thrdvar.h.
Any changes made here will be lost!

Edit those files and run 'make regen_headers' to effect changes.

EOW

    $warning .= <<EOW if $file eq 'perlapi.c';

Up to the threshold of the door there mounted a flight of twenty-seven
broad stairs, hewn by some unknown art of the same black stone.  This
was the only entrance to the tower.


EOW

    if ($file =~ m:\.[ch]$:) {
	$warning =~ s:^: * :gm;
	$warning =~ s: +$::gm;
	$warning =~ s: :/:;
	$warning =~ s:$:/:;
    }
    else {
	$warning =~ s:^:# :gm;
	$warning =~ s: +$::gm;
    }
    $warning;
} # do_not_edit

a20 1
    defined $leader or $leader = do_not_edit ($filename);
d28 1
a28 1
	safer_unlink $filename;
d52 1
a52 3
    unless (ref $filename) {
	close $F or die "Error closing $filename: $!";
    }
d65 1
a65 1
    } '/dev/null', '';
d144 2
a145 1
	    $ret .= sprintf "\n\t__attribute__format__(__printf__,%s%d,%s%d)",
d147 1
d161 2
a162 3
	if ($flags =~ /[AX]/ && $flags !~ /[xm]/
	    || $flags =~ /b/) { # public API, so export
	    $func = "Perl_$func" if $flags =~ /[pbX]/;
d169 32
a200 2
walk_table(\&write_protos,     "proto.h", undef);
walk_table(\&write_global_sym, "global.sym", undef);
d300 1
a300 1
safer_unlink 'embed.h';
d303 13
a315 1
print EM do_not_edit ("embed.h"), <<'END';
d319 1
a319 5
/* By defining PERL_NO_SHORT_NAMES (not done by default) the short forms
 * (like warn instead of Perl_warn) for the API are not defined.
 * Not defining the short forms is a good thing for cleaner embedding. */

#ifndef PERL_NO_SHORT_NAMES
a342 7
	if ($ret ne '' && $flags !~ /A/) {
	    if ($flags =~ /E/) {
		$ret = "#if defined(PERL_CORE) || defined(PERL_EXT)\n$ret#endif\n";
	    } else {
		$ret = "#ifdef PERL_CORE\n$ret#endif\n";
	    }
        }
d345 1
a345 1
} \*EM, "";
a395 7
         unless ($flags =~ /A/) {
	    if ($flags =~ /E/) {
		$ret = "#if defined(PERL_CORE) || defined(PERL_EXT)\n$ret#endif\n";
	    } else {
		$ret = "#ifdef PERL_CORE\n$ret#endif\n";
	    }
        }
d398 1
a398 1
} \*EM, "";
a416 2
#endif	/* #ifndef PERL_NO_SHORT_NAMES */

d461 1
a461 1
#if defined(PERL_IMPLICIT_CONTEXT) && !defined(PERL_NO_SHORT_NAMES)
d498 1
a498 1
close(EM) or die "Error closing EM: $!";
d500 1
a500 1
safer_unlink 'embedvar.h';
d504 14
a517 1
print EM do_not_edit ("embedvar.h"), <<'END';
d649 1
a649 1
close(EM) or die "Error closing EM: $!";
d651 2
a652 2
safer_unlink 'perlapi.h';
safer_unlink 'perlapi.c';
d656 14
a669 1
print CAPIH do_not_edit ("perlapi.h"), <<'EOT';
d763 1
a763 1
close CAPIH or die "Error closing CAPIH: $!";
d765 14
a778 1
print CAPI do_not_edit ("perlapi.c"), <<'EOT';
d826 1
a826 1
close(CAPI) or die "Error closing CAPI: $!";
@


1.1.1.7
log
@Import of stock perl 5.8.5
@
text
@d25 1
a25 1
        $years = '1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004';
d27 1
a27 1
        $years = '1999, 2000, 2001, 2002, 2003, 2004';
d29 1
a29 1
        $years = '1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004';
d33 1
a33 1
        $years = '1999, 2000, 2001, 2002, 2003, 2004';
d35 1
a35 1
        $years = '1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004';
@


1.1.1.8
log
@perl 5.8.8 import
@
text
@d21 2
d24 13
a36 1
    my $years = '1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006';
a40 1
 -*- buffer-read-only: t -*-
d96 1
a96 1
	safer_unlink $filename if $filename ne '/dev/null';
a97 1
	binmode F;
a108 1
	s/\s+$//;
d116 2
a117 2
	my @@outs = &{$function}(@@args);
	print $F @@outs; # $function->(@@args) is not 5.003
d128 1
a128 1
	warn "\@@ARGV empty, nothing to do\n";
d135 1
a135 1
    } '/dev/null', '', '';
a186 2
	my @@nonnull;
	my $has_context = ( $flags !~ /n/ );
d199 3
a201 2
	if ( $has_context ) {
	    $ret .= @@args ? "pTHX_ " : "pTHX";
a203 16
	    my $n;
	    for my $arg ( @@args ) {
		++$n;
		if ( $arg =~ /\*/ && $arg !~ /\b(NN|NULLOK)\b/ ) {
		    warn "$func: $arg needs NN or NULLOK\n";
		    our $unflagged_pointers;
		    ++$unflagged_pointers;
		}
		# Given the bugs fixed by changes 25822 and 26253, for now
		# strip NN with no effect, until I'm confident that there are
		# no similar bugs lurking.
		# push( @@nonnull, $n ) if ( $arg =~ s/\s*\bNN\b\s+// );
		$arg =~ s/\s*\bNN\b\s+//;

		$arg =~ s/\s*\bNULLOK\b\s+//; # strip NULLOK with no effect
	    }
d207 1
a207 1
	    $ret .= "void" if !$has_context;
d210 1
a210 14
	my @@attrs;
	if ( $flags =~ /r/ ) {
	    push @@attrs, "__attribute__noreturn__";
	}
	if ( $flags =~ /a/ ) {
	    push @@attrs, "__attribute__malloc__";
	    $flags .= "R"; # All allocing must check return value
	}
	if ( $flags =~ /R/ ) {
	    push @@attrs, "__attribute__warn_unused_result__";
	}
	if ( $flags =~ /P/ ) {
	    push @@attrs, "__attribute__pure__";
	}
d212 1
a212 1
	    my $prefix = $has_context ? 'pTHX_' : '';
d214 1
a214 1
	    push @@attrs, sprintf "__attribute__format__(__printf__,%s%d,%s%d)",
a216 8
	if ( @@nonnull ) {
	    my @@pos = map { $has_context ? "pTHX_$_" : $_ } @@nonnull;
	    push @@attrs, map { sprintf( "__attribute__nonnull__(%s)", $_ ) } @@pos;
	}
	if ( @@attrs ) {
	    $ret .= "\n";
	    $ret .= join( "\n", map { "\t\t\t$_" } @@attrs );
	}
d219 1
a219 1
	$ret .= @@attrs ? "\n\n" : "\n";
d238 2
a239 4
our $unflagged_pointers;
walk_table(\&write_protos,     "proto.h", undef, "/* ex: set ro: */\n");
warn "$unflagged_pointers pointer arguments to clean up\n" if $unflagged_pointers;
walk_table(\&write_global_sym, "global.sym", undef, "# ex: set ro:\n");
d246 2
a247 2
		 curcop compiling
		 tainting tainted stack_base stack_sp sv_arenaroot
d249 3
a251 3
		 curstash DBsub DBsingle debstash
		 rsfp
		 stdingv
a340 1
binmode EM;
a357 10
# Try to elimiate lots of repeated
# #ifdef PERL_CORE
# foo
# #endif
# #ifdef PERL_CORE
# bar
# #endif
# by tracking state and merging foo and bar into one block.
my $ifdef_state = '';

a359 1
    my $new_ifdef_state = '';
d376 3
a378 9
		$new_ifdef_state
		    = "#if defined(PERL_CORE) || defined(PERL_EXT)\n";
	    }
	    else {
		$new_ifdef_state = "#ifdef PERL_CORE\n";
	    }

	    if ($new_ifdef_state ne $ifdef_state) {
		$ret = $new_ifdef_state . $ret;
a381 6
    if ($ifdef_state && $new_ifdef_state ne $ifdef_state) {
	# Close the old one ahead of opening the new one.
	$ret = "#endif\n$ret";
    }
    # Remember the new state.
    $ifdef_state = $new_ifdef_state;
a384 4
if ($ifdef_state) {
    print EM "#endif\n";
}

a397 1
$ifdef_state = '';
a399 1
    my $new_ifdef_state = '';
d434 1
a434 1
	unless ($flags =~ /A/) {
d436 3
a438 9
		$new_ifdef_state
		    = "#if defined(PERL_CORE) || defined(PERL_EXT)\n";
	    }
	    else {
		$new_ifdef_state = "#ifdef PERL_CORE\n";
	    }

	    if ($new_ifdef_state ne $ifdef_state) {
		$ret = $new_ifdef_state . $ret;
a441 6
    if ($ifdef_state && $new_ifdef_state ne $ifdef_state) {
	# Close the old one ahead of opening the new one.
	$ret = "#endif\n$ret";
    }
    # Remember the new state.
    $ifdef_state = $new_ifdef_state;
a444 4
if ($ifdef_state) {
    print EM "#endif\n";
}

a542 1
/* ex: set ro: */
a549 1
binmode EM;
a680 2

/* ex: set ro: */
a687 1
binmode CAPI;
a688 1
binmode CAPIH;
a744 13
/* In Tru64 (__DEC && __osf__) the cc option -std1 causes that one
 * cannot cast between void pointers and function pointers without
 * info level warnings.  The PL_force_link_funcs[] would cause a few
 * hundred of those warnings.  In code one can circumnavigate this by using
 * unions that overlay the different pointers, but in declarations one
 * cannot use this trick.  Therefore we just disable the warning here
 * for the duration of the PL_force_link_funcs[] declaration. */

#if defined(__DECC) && defined(__osf__)
#pragma message save
#pragma message disable (nonstandcast)
#endif

a748 4
#if defined(__DECC) && defined(__osf__)
#pragma message restore
#endif

a782 1
/* ex: set ro: */
a831 2

/* ex: set ro: */
a855 2

# ex: set ts=8 sts=4 sw=4 noet:
@


1.1.1.9
log
@import perl 5.10.0 from CPAN
@
text
@a5 2
use strict;

a10 2
my $SPLINT = 0; # Turn true for experimental splint support http://www.splint.org

d22 1
a22 1
    my $years = '1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007';
d38 1
a38 1
pp.sym, intrpvar.h, and perlvars.h.
d127 20
d178 1
a178 13
	my $never_returns = ( $flags =~ /r/ );
	my $commented_out = ( $flags =~ /m/ );
	my $is_malloc = ( $flags =~ /a/ );
	my $can_ignore = ( $flags !~ /R/ ) && !$is_malloc;

	my $splint_flags = "";
	if ( $SPLINT && !$commented_out ) {
	    $splint_flags .= '/*@@noreturn@@*/ ' if $never_returns;
	    if ($can_ignore && ($retval ne 'void') && ($retval !~ /\*/)) {
		$retval .= " /*\@@alt void\@@*/";
	    }
	}

d180 1
a180 1
	    $retval = "STATIC $splint_flags$retval";
d184 2
a185 2
	    $retval = "PERL_CALLCONV $splint_flags$retval";
	    if ($flags =~ /[bp]/) {
d202 5
a206 4
		my $nn = ( $arg =~ s/\s*\bNN\b\s+// );
		push( @@nonnull, $n ) if $nn;

		my $nullok = ( $arg =~ s/\s*\bNULLOK\b\s+// ); # strip NULLOK with no effect
d208 1
a208 11
		# Make sure each arg has at least a type and a var name.
		# An arg of "int" is valid C, but want it to be "int foo".
		my $temp_arg = $arg;
		$temp_arg =~ s/\*//g;
		$temp_arg =~ s/\s*\bstruct\b\s*/ /g;
		if ( ($temp_arg ne "...") && ($temp_arg !~ /\w+\s+\w+/) ) {
		    warn "$func: $arg doesn't have a name\n";
		}
		if ( $SPLINT && $nullok && !$commented_out ) {
		    $arg = '/*@@null@@*/ ' . $arg;
		}
d220 1
a220 1
	if ( $is_malloc ) {
d222 1
d224 1
a224 1
	if ( !$can_ignore ) {
d231 4
a234 8
	    my $prefix	= $has_context ? 'pTHX_' : '';
	    my $args	= scalar @@args;
 	    my $pat	= $args - 1;
	    my $macro	= @@nonnull && $nonnull[-1] == $pat  
				? '__attribute__format__'
				: '__attribute__format__null_ok__';
	    push @@attrs, sprintf "%s(__printf__,%s%d,%s%d)", $macro,
				$prefix, $pat, $prefix, $args;
d245 1
a245 1
	$ret = "/* $ret */" if $commented_out;
d251 12
a262 18
# generates global.sym (API export list)
{
  my %seen;
  sub write_global_sym {
      my $ret = "";
      if (@@_ > 1) {
	  my ($flags,$retval,$func,@@args) = @@_;
	  # If a function is defined twice, for example before and after an
	  # #else, only process the flags on the first instance for global.sym
	  return $ret if $seen{$func}++;
	  if ($flags =~ /[AX]/ && $flags !~ /[xm]/
	      || $flags =~ /b/) { # public API, so export
	      $func = "Perl_$func" if $flags =~ /[pbX]/;
	      $ret = "$func\n";
	  }
      }
      $ret;
  }
a264 1

d278 1
a278 1
		 curstash DBsub DBsingle DBassertion debstash
d300 1
a300 1
	    warn "duplicate symbol $sym while processing $file line $.\n"
d318 1
a318 1
	if (/PERLVARA?I?S?C?\($pre(\w+)/) {
d321 1
a321 1
	    warn "duplicate symbol $sym while processing $file line $.\n"
d330 1
a330 1
my %globvar;
d333 1
d337 3
d549 1
a549 1
#  define sv_setptrref(rv,ptr)		sv_setref_iv(rv,NULL,PTR2IV(ptr))
d633 2
a634 2
   The following combinations of MULTIPLICITY and PERL_IMPLICIT_CONTEXT
   are supported:
d638 2
d643 1
a643 1
   only #3 is supported directly, while #2 is a special
d648 1
a648 1
/* cases 2 and 3 above */
d658 22
d686 2
d690 1
a690 1
/* case 1 above */
d700 3
d705 4
d711 12
d730 1
a730 2
    print EM multon($sym,   'G','my_vars->');
    print EM multon("G$sym",'', 'my_vars->');
a784 1
#undef PERLVARISC
a789 2
#define PERLVARISC(v,i)	typedef const char PL_##v##_t[sizeof(i)];	\
			EXTERN_C PL_##v##_t* Perl_##v##_ptr(pTHX);
d791 1
a798 10
#undef PERLVARISC

#ifndef PERL_GLOBAL_STRUCT
EXTERN_C Perl_ppaddr_t** Perl_Gppaddr_ptr(pTHX);
EXTERN_C Perl_check_t**  Perl_Gcheck_ptr(pTHX);
EXTERN_C unsigned char** Perl_Gfold_locale_ptr(pTHX);
#define Perl_ppaddr_ptr      Perl_Gppaddr_ptr
#define Perl_check_ptr       Perl_Gcheck_ptr
#define Perl_fold_locale_ptr Perl_Gfold_locale_ptr
#endif
d814 1
a814 1
EXTCONST void * const PL_force_link_funcs[];
d816 1
a816 1
EXTCONST void * const PL_force_link_funcs[] = {
a824 1
#define PERLVARISC(v,i) PERLVAR(v,char)
d839 1
a850 1
#undef PERLVARISC
d866 4
a899 1
#undef PERLVARISC
d902 1
a902 1
			{ dVAR; PERL_UNUSED_CONTEXT; return &(aTHX->v); }
d904 1
a904 1
			{ dVAR; PERL_UNUSED_CONTEXT; return &(aTHX->v); }
a907 2
#define PERLVARISC(v,i)	PL_##v##_t* Perl_##v##_ptr(pTHX)		\
			{ dVAR; PERL_UNUSED_CONTEXT; return &(aTHX->v); }
d909 1
d915 1
a915 1
			{ dVAR; PERL_UNUSED_CONTEXT; return &(PL_##v); }
d917 1
a917 1
			{ dVAR; PERL_UNUSED_CONTEXT; return &(PL_##v); }
d919 2
a920 6
#undef PERLVARISC
#define PERLVARIC(v,t,i)	\
			const t* Perl_##v##_ptr(pTHX)		\
			{ PERL_UNUSED_CONTEXT; return (const t *)&(PL_##v); }
#define PERLVARISC(v,i)	PL_##v##_t* Perl_##v##_ptr(pTHX)	\
			{ dVAR; PERL_UNUSED_CONTEXT; return &(PL_##v); }
a926 23
#undef PERLVARISC

#ifndef PERL_GLOBAL_STRUCT
/* A few evil special cases.  Could probably macrofy this. */
#undef PL_ppaddr
#undef PL_check
#undef PL_fold_locale
Perl_ppaddr_t** Perl_Gppaddr_ptr(pTHX) {
    static Perl_ppaddr_t* const ppaddr_ptr = PL_ppaddr;
    PERL_UNUSED_CONTEXT;
    return (Perl_ppaddr_t**)&ppaddr_ptr;
}
Perl_check_t**  Perl_Gcheck_ptr(pTHX) {
    static Perl_check_t* const check_ptr  = PL_check;
    PERL_UNUSED_CONTEXT;
    return (Perl_check_t**)&check_ptr;
}
unsigned char** Perl_Gfold_locale_ptr(pTHX) {
    static unsigned char* const fold_locale_ptr = PL_fold_locale;
    PERL_UNUSED_CONTEXT;
    return (unsigned char**)&fold_locale_ptr;
}
#endif
@


1.1.1.10
log
@import perl 5.10.1
@
text
@a1 22
# 
# Regenerate (overwriting only if changed):
#
#    embed.h
#    embedvar.h
#    global.sym
#    perlapi.c
#    perlapi.h
#    proto.h
#
# from information stored in
#
#    embed.fnc
#    intrpvar.h
#    perlvars.h
#    pp.sym     (which has been generated by opcode.pl)
#
# plus from the values hardcoded into this script in @@extvars.
#
# Accepts the standard regen_lib -q and -v args.
#
# This script is normally invoked from regen.pl.
d26 1
a26 1
    my $years = '1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009';
d53 1
a53 3
was the only entrance to the tower; ...

    [p.577 of _The Lord of the Rings_, III/x: "The Voice of Saruman"]
d82 1
d87 4
a90 2
	# safer_unlink $filename if $filename ne '/dev/null';
	$F = safer_open("$filename-new");
d114 1
a114 2
	safer_close($F);
	rename_if_different("$filename-new", $filename);
d159 1
a159 1
	my ($flags,$retval,$plain_func,@@args) = @@_;
a163 1
	my $binarycompat = ( $flags =~ /b/ );
a165 2
	my @@names_of_nn;
	my $func;
d177 1
a177 1
	    $func = "S_$plain_func";
d182 1
a182 3
		$func = "Perl_$plain_func";
	    } else {
		$func = $plain_func;
d208 2
a209 3
		if ( ($temp_arg ne "...")
		     && ($temp_arg !~ /\w+\s+(\w+)(?:\[\d+\])?\s*$/) ) {
		    warn "$func: $arg ($n) doesn't have a name\n";
a213 3
		if (defined $1 && $nn && !($commented_out && !$binarycompat)) {
		    push @@names_of_nn, $1;
		}
a253 4
	if (@@names_of_nn) {
	    $ret .= "\n#define PERL_ARGS_ASSERT_\U$plain_func\E\t\\\n\t"
		. join '; ', map "assert($_)", @@names_of_nn;
	}
d379 3
a381 1
my $em = safer_open('embed.h-new');
d383 1
a383 1
print $em do_not_edit ("embed.h"), <<'END';
d447 1
a447 1
} $em, "";
d450 1
a450 1
    print $em "#endif\n";
d455 1
a455 1
    print $em hide($sym, "Perl_$sym");
d458 1
a458 1
print $em <<'END';
d525 1
a525 1
} $em, "";
d528 1
a528 1
    print $em "#endif\n";
d534 1
a534 1
	print $em hide("$sym(a)", "Perl_$sym(aTHX_ a)");
d537 1
a537 1
	print $em hide("$sym()", "Perl_$sym(aTHX)");
d544 1
a544 1
print $em <<'END';
d552 1
a552 1
print $em <<'END';
d632 1
a632 2
safer_close($em);
rename_if_different('embed.h-new', 'embed.h');
d634 4
a637 1
$em = safer_open('embedvar.h-new');
d639 1
a639 1
print $em do_not_edit ("embedvar.h"), <<'END';
d668 1
a668 1
    print $em multon($sym,'I','vTHX->');
d671 1
a671 1
print $em <<'END';
d680 1
a680 1
    print $em multoff($sym,'I');
d683 1
a683 1
print $em <<'END';
d687 1
a687 1
print $em <<'END';
d696 2
a697 2
    print $em multon($sym,   'G','my_vars->');
    print $em multon("G$sym",'', 'my_vars->');
d700 1
a700 1
print $em <<'END';
d707 1
a707 1
    print $em multoff($sym,'G');
d710 1
a710 1
print $em <<'END';
d719 1
a719 1
    print $em hide($sym,"PL_$sym");
d722 1
a722 1
print $em <<'END';
d729 1
a729 2
safer_close($em);
rename_if_different('embedvar.h-new', 'embedvar.h');
d731 6
a736 2
my $capi = safer_open('perlapi.c-new');
my $capih = safer_open('perlapi.h-new');
d738 1
a738 1
print $capih do_not_edit ("perlapi.h"), <<'EOT';
d843 1
a843 1
    print $capih bincompat_var('I',$sym);
d847 1
a847 1
    print $capih bincompat_var('G',$sym);
d850 1
a850 1
print $capih <<'EOT';
d859 1
a859 2
safer_close($capih);
rename_if_different('perlapi.h-new', 'perlapi.h');
d861 1
a861 1
print $capi do_not_edit ("perlapi.c"), <<'EOT';
d940 1
a940 2
safer_close($capi);
rename_if_different('perlapi.c-new', 'perlapi.c');
@


1.1.1.11
log
@Perl 5.12.2 from CPAN
@
text
@a255 3
	if ( $flags =~ /D/ ) {
	    push @@attrs, "__attribute__deprecated__";
	}
@


