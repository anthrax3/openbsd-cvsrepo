head	1.2;
access;
symbols
	OPENBSD_5_3:1.1.1.7.0.14
	OPENBSD_5_3_BASE:1.1.1.7
	OPENBSD_5_2:1.1.1.7.0.12
	OPENBSD_5_2_BASE:1.1.1.7
	OPENBSD_5_1_BASE:1.1.1.7
	OPENBSD_5_1:1.1.1.7.0.10
	OPENBSD_5_0:1.1.1.7.0.8
	OPENBSD_5_0_BASE:1.1.1.7
	OPENBSD_4_9:1.1.1.7.0.6
	OPENBSD_4_9_BASE:1.1.1.7
	PERL_5_12_2:1.1.1.7
	OPENBSD_4_8:1.1.1.7.0.4
	OPENBSD_4_8_BASE:1.1.1.7
	OPENBSD_4_7:1.1.1.7.0.2
	OPENBSD_4_7_BASE:1.1.1.7
	PERL_5_10_1:1.1.1.7
	OPENBSD_4_6:1.1.1.6.0.6
	OPENBSD_4_6_BASE:1.1.1.6
	OPENBSD_4_5:1.1.1.6.0.2
	OPENBSD_4_5_BASE:1.1.1.6
	PERL_5_10_0:1.1.1.6
	OPENBSD_4_4:1.1.1.5.0.10
	OPENBSD_4_4_BASE:1.1.1.5
	OPENBSD_4_3:1.1.1.5.0.8
	OPENBSD_4_3_BASE:1.1.1.5
	OPENBSD_4_2:1.1.1.5.0.6
	OPENBSD_4_2_BASE:1.1.1.5
	OPENBSD_4_1:1.1.1.5.0.4
	OPENBSD_4_1_BASE:1.1.1.5
	OPENBSD_4_0:1.1.1.5.0.2
	OPENBSD_4_0_BASE:1.1.1.5
	PERL_5_8_8:1.1.1.5
	OPENBSD_3_9:1.1.1.4.0.10
	OPENBSD_3_9_BASE:1.1.1.4
	OPENBSD_3_8:1.1.1.4.0.8
	OPENBSD_3_8_BASE:1.1.1.4
	OPENBSD_3_7:1.1.1.4.0.6
	OPENBSD_3_7_BASE:1.1.1.4
	PERL_5_8_6:1.1.1.4
	OPENBSD_3_6:1.1.1.4.0.4
	OPENBSD_3_6_BASE:1.1.1.4
	PERL_5_8_5:1.1.1.4
	PERL_5_8_3:1.1.1.4
	OPENBSD_3_5:1.1.1.4.0.2
	OPENBSD_3_5_BASE:1.1.1.4
	PERL_5_8_2:1.1.1.4
	OPENBSD_3_4:1.1.1.3.0.10
	OPENBSD_3_4_BASE:1.1.1.3
	OPENBSD_3_3:1.1.1.3.0.8
	OPENBSD_3_3_BASE:1.1.1.3
	PERL_5_8_0:1.1.1.3
	OPENBSD_3_2:1.1.1.3.0.6
	OPENBSD_3_2_BASE:1.1.1.3
	OPENBSD_3_1:1.1.1.3.0.4
	OPENBSD_3_1_BASE:1.1.1.3
	OPENBSD_3_0:1.1.1.3.0.2
	OPENBSD_3_0_BASE:1.1.1.3
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.1.1.2.0.6
	OPENBSD_2_9_BASE:1.1.1.2
	OPENBSD_2_8:1.1.1.2.0.4
	OPENBSD_2_8_BASE:1.1.1.2
	OPENBSD_2_7:1.1.1.2.0.2
	OPENBSD_2_7_BASE:1.1.1.2
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.1.1.1.0.2
	OPENBSD_2_6_BASE:1.1.1.1
	PERL_500503:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2013.03.25.20.40.45;	author sthen;	state dead;
branches;
next	1.1;

1.1
date	99.04.29.22.37.52;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.29.22.37.52;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.04.06.16.08.46;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.05.24.18.22.21;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.12.03.02.43.36;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2006.03.28.18.47.42;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2008.09.29.17.18.10;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2009.10.12.18.10.33;	author millert;	state Exp;
branches;
next	;


desc
@@


1.2
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@#use Fatal qw(open close rename chmod unlink);
open DESC, 'regcomp.sym';
$ind = 0;

while (<DESC>) {
  next if /^\s*($|\#)/;
  $ind++;
  chomp;
  ($name[$ind], $desc, $rest[$ind]) = split /\t+/, $_, 3;
  ($type[$ind], $code[$ind], $args[$ind], $longj[$ind]) 
    = split /[,\s]\s*/, $desc, 4;
}
close DESC;
$tot = $ind;

$tmp_h = 'tmp_reg.h';

unlink $tmp_h if -f $tmp_h;

open OUT, ">$tmp_h";

print OUT <<EOP;
/* !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
   This file is built by regcomp.pl from regcomp.sym.  
   Any changes made here will be lost!
*/

EOP

$ind = 0;
while (++$ind <= $tot) {
  $oind = $ind - 1;
  $hind = sprintf "%#4x", $oind;
  print OUT <<EOP;
#define	$name[$ind]	$oind	/* $hind $rest[$ind] */
EOP
}

print OUT <<EOP;

#ifndef DOINIT
EXTCONST U8 regkind[];
#else
EXTCONST U8 regkind[] = {
EOP

$ind = 0;
while (++$ind <= $tot) {
  print OUT <<EOP;
	$type[$ind],		/* $name[$ind] */
EOP
}

print OUT <<EOP;
};
#endif


#ifdef REG_COMP_C
const static U8 regarglen[] = {
EOP

$ind = 0;
while (++$ind <= $tot) {
  $size = 0;
  $size = "EXTRA_SIZE(struct regnode_$args[$ind])" if $args[$ind];
  
  print OUT <<EOP;
	$size,		/* $name[$ind] */
EOP
}

print OUT <<EOP;
};

const static char reg_off_by_arg[] = {
EOP

$ind = 0;
while (++$ind <= $tot) {
  $size = $longj[$ind] || 0;
  
  print OUT <<EOP;
	$size,		/* $name[$ind] */
EOP
}

print OUT <<EOP;
};
#endif /* REG_COMP_C */

EOP

close OUT;

chmod 0666, 'regnodes.h';
unlink 'regnodes.h';
rename $tmp_h, 'regnodes.h';
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@perl5.005_03
@
text
@@


1.1.1.2
log
@virgin perl 5.6.0
@
text
@d24 1
a24 1
   This file is built by regcomp.pl from regcomp.sym.
d42 1
a42 1
EXTCONST U8 PL_regkind[];
d44 1
a44 1
EXTCONST U8 PL_regkind[] = {
d82 1
a82 1

a89 21

#ifdef DEBUGGING
const static char * const reg_name[] = {
EOP

$ind = 0;
while (++$ind <= $tot) {
  $hind = sprintf "%#4x", $ind-1;
  $size = $longj[$ind] || 0;

  print OUT <<EOP;
	"$name[$ind]",		/* $hind */
EOP
}

print OUT <<EOP;
};

const static int reg_num = $tot;

#endif /* DEBUGGING */
@


1.1.1.3
log
@stock perl 5.6.1
@
text
@d60 1
a60 1
static const U8 regarglen[] = {
d76 1
a76 1
static const char reg_off_by_arg[] = {
d92 1
a92 1
static const char * const reg_name[] = {
d108 1
a108 1
static const int reg_num = $tot;
@


1.1.1.4
log
@perl 5.8.2 from CPAN
@
text
@a0 4
BEGIN {
    # Get function prototypes
    require 'regen_lib.pl';
}
d115 1
a115 1
close OUT or die "close $tmp_h: $!";
d117 3
a119 1
safer_rename $tmp_h, 'regnodes.h';
@


1.1.1.5
log
@perl 5.8.8 import
@
text
@a24 1
binmode OUT;
d27 1
a27 2
/* -*- buffer-read-only: t -*-
   !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
a116 1
/* ex: set ro: */
@


1.1.1.6
log
@import perl 5.10.0 from CPAN
@
text
@a5 3
use strict;
use warnings;

d7 1
a8 3
my $ind = 0;
my (@@name,@@rest,@@type,@@code,@@args,@@longj);
my ($desc,$lastregop);
d10 7
a16 48
    s/#.*$//;
    next if /^\s*$/;
    s/\s*\z//;
    if (/^-+\s*$/) {
        $lastregop= $ind;
        next;
    }
    unless ($lastregop) {
        $ind++;
        ($name[$ind], $desc, $rest[$ind]) = split /\t+/, $_, 3;  
        ($type[$ind], $code[$ind], $args[$ind], $longj[$ind]) 
          = split /[,\s]\s*/, $desc, 4;
    } else {
        my ($type,@@lists)=split /\s*\t+\s*/, $_;
        die "No list? $type" if !@@lists;
        foreach my $list (@@lists) {
            my ($names,$special)=split /:/, $list , 2;
            $special ||= "";
            foreach my $name (split /,/,$names) {
                my $real= $name eq 'resume' 
                        ? "resume_$type" 
                        : "${type}_$name";
                my @@suffix;
                if (!$special) {
                   @@suffix=("");
                } elsif ($special=~/\d/) {
                    @@suffix=(1..$special);
                } elsif ($special eq 'FAIL') {
                    @@suffix=("","_fail");
                } else {
                    die "unknown :type ':$special'";
                }
                foreach my $suffix (@@suffix) {
                    $ind++;
                    $name[$ind]="$real$suffix";
                    $type[$ind]=$type;
                    $rest[$ind]="state for $type";
                }
            }
        }
        
    }
}
# use fixed width to keep the diffs between regcomp.pl recompiles
# as small as possible.
my ($width,$rwidth,$twidth)=(22,12,9);
$lastregop ||= $ind;
my $tot = $ind;
d18 1
a18 2
die "Too many regexp/state opcodes! Maximum is 256, but there are $lastregop in file!"
    if $lastregop>256;
d20 1
a20 1
my $tmp_h = 'tmp_reg.h';
a24 1
#*OUT=\*STDOUT;
d27 1
a27 1
printf OUT <<EOP,
d34 1
a34 4
/* Regops and State definitions */

#define %*s\t%d
#define %*s\t%d
d36 6
a42 14
    -$width, REGNODE_MAX        => $lastregop - 1,
    -$width, REGMATCH_STATE_MAX => $tot - 1
;


for ($ind=1; $ind <= $lastregop ; $ind++) {
  my $oind = $ind - 1;
  printf OUT "#define\t%*s\t%d\t/* %#04x %s */\n",
    -$width, $name[$ind], $ind-1, $ind-1, $rest[$ind];
}
print OUT "\t/* ------------ States ------------- */\n";
for ( ; $ind <= $tot ; $ind++) {
  printf OUT "#define\t%*s\t(REGNODE_MAX + %d)\t/* %s */\n",
    -$width, $name[$ind], $ind - $lastregop, $rest[$ind];
a46 2
/* PL_regkind[] What type of regop or state is this. */

d55 3
a57 4
  printf OUT "\t%*s\t/* %*s */\n",
             -1-$twidth, "$type[$ind],", -$width, $name[$ind];
  print OUT "\t/* ------------ States ------------- */\n"
    if $ind == $lastregop and $lastregop != $tot;
a63 1
/* regarglen[] - How large is the argument part of the node (in regnodes) */
d70 2
a71 2
while (++$ind <= $lastregop) {
  my $size = 0;
d74 3
a76 2
  printf OUT "\t%*s\t/* %*s */\n",
	-37, "$size,",-$rwidth,$name[$ind];
a81 2
/* reg_off_by_arg[] - Which argument holds the offset to the next node */

d86 2
a87 2
while (++$ind <= $lastregop) {
  my $size = $longj[$ind] || 0;
d89 3
a91 2
  printf OUT "\t%d,\t/* %*s */\n",
	$size, -$rwidth, $name[$ind]
d97 2
a98 8
#endif /* REG_COMP_C */

/* reg_name[] - Opcode/state names in string form, for debugging */

#ifndef DOINIT
EXTCONST char * PL_reg_name[];
#else
EXTCONST char * const PL_reg_name[] = {
a101 2
my $ofs = 1;
my $sym = "";
d103 2
a104 1
  my $size = $longj[$ind] || 0;
d106 3
a108 8
  printf OUT "\t%*s\t/* $sym%#04x */\n",
	-3-$width,qq("$name[$ind]",), $ind - $ofs;
  if ($ind == $lastregop and $lastregop != $tot) {
    print OUT "\t/* ------------ States ------------- */\n";
    $ofs = $lastregop;
    $sym = 'REGNODE_MAX +';
  }
    
a112 1
#endif /* DOINIT */
d114 1
a114 1
/* PL_reg_extflags_name[] - Opcode/state names in string form, for debugging */
d116 2
a117 27
#ifndef DOINIT
EXTCONST char * PL_reg_extflags_name[];
#else
EXTCONST char * const PL_reg_extflags_name[] = {
EOP

open my $fh,"<","regexp.h" or die "Can't read regexp.h: $!";
my %rxfv;
my $val;
while (<$fh>) {
    if (/#define\s+(RXf_\w+)\s+(0x[A-F\d]+)/i) {
        $rxfv{$1}= eval $2;
        $val|=$rxfv{$1};
    }
}    
my %vrxf=reverse %rxfv;
printf OUT "\t/* Bits in extflags defined: %032b */\n",$val;
for (0..31) {
    my $n=$vrxf{2**$_}||"UNUSED_BIT_$_";
    $n=~s/^RXf_(PMf_)?//;
    printf OUT qq(\t%-20s/* 0x%08x */\n), 
        qq("$n",),2**$_;
}  
 
print OUT <<EOP;
};
#endif /* DOINIT */
d121 1
@


1.1.1.7
log
@import perl 5.10.1
@
text
@a0 15
#!/usr/bin/perl
# 
# Regenerate (overwriting only if changed):
#
#    regnodes.h
#
# from information stored in
#
#    regcomp.sym
#    regexp.h
#
# Accepts the standard regen_lib -q and -v args.
#
# This script is normally invoked from regen.pl.

d67 1
a67 1
my $tmp_h = 'regnodes.h-new';
d71 3
a73 1
my $out = safer_open($tmp_h);
d75 1
a75 1
printf $out <<EOP,
d95 1
a95 1
  printf $out "#define\t%*s\t%d\t/* %#04x %s */\n",
d98 1
a98 1
print $out "\t/* ------------ States ------------- */\n";
d100 1
a100 1
  printf $out "#define\t%*s\t(REGNODE_MAX + %d)\t/* %s */\n",
d104 1
a104 1
print $out <<EOP;
d116 1
a116 1
  printf $out "\t%*s\t/* %*s */\n",
d118 1
a118 1
  print $out "\t/* ------------ States ------------- */\n"
d122 1
a122 1
print $out <<EOP;
d137 1
a137 1
  printf $out "\t%*s\t/* %*s */\n",
d141 1
a141 1
print $out <<EOP;
d153 1
a153 1
  printf $out "\t%d,\t/* %*s */\n",
d157 1
a157 1
print $out <<EOP;
d176 1
a176 1
  printf $out "\t%*s\t/* $sym%#04x */\n",
d179 1
a179 1
    print $out "\t/* ------------ States ------------- */\n";
d186 1
a186 1
print $out <<EOP;
d200 1
a200 2
my $val = 0;
my %reverse;
d203 2
a204 7
	my $newval = eval $2;
	if($val & $newval) {
	    die sprintf "Both $1 and $reverse{$newval} use %08X", $newval;
	}
        $val|=$newval;
        $rxfv{$1}= $newval;
	$reverse{$newval} = $1;
d208 1
a208 1
printf $out "\t/* Bits in extflags defined: %032b */\n",$val;
d212 1
a212 1
    printf $out qq(\t%-20s/* 0x%08x */\n), 
d216 1
a216 1
print $out <<EOP;
d222 1
a222 1
safer_close($out);
d224 1
a224 1
rename_if_different $tmp_h, 'regnodes.h';
@


