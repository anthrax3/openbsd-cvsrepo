head	1.2;
access;
symbols
	OPENBSD_4_4:1.1.1.6.0.10
	OPENBSD_4_4_BASE:1.1.1.6
	OPENBSD_4_3:1.1.1.6.0.8
	OPENBSD_4_3_BASE:1.1.1.6
	OPENBSD_4_2:1.1.1.6.0.6
	OPENBSD_4_2_BASE:1.1.1.6
	OPENBSD_4_1:1.1.1.6.0.4
	OPENBSD_4_1_BASE:1.1.1.6
	OPENBSD_4_0:1.1.1.6.0.2
	OPENBSD_4_0_BASE:1.1.1.6
	PERL_5_8_8:1.1.1.6
	OPENBSD_3_9:1.1.1.5.0.10
	OPENBSD_3_9_BASE:1.1.1.5
	OPENBSD_3_8:1.1.1.5.0.8
	OPENBSD_3_8_BASE:1.1.1.5
	OPENBSD_3_7:1.1.1.5.0.6
	OPENBSD_3_7_BASE:1.1.1.5
	PERL_5_8_6:1.1.1.5
	OPENBSD_3_6:1.1.1.5.0.4
	OPENBSD_3_6_BASE:1.1.1.5
	PERL_5_8_5:1.1.1.5
	PERL_5_8_3:1.1.1.5
	OPENBSD_3_5:1.1.1.5.0.2
	OPENBSD_3_5_BASE:1.1.1.5
	PERL_5_8_2:1.1.1.5
	OPENBSD_3_4:1.1.1.4.0.4
	OPENBSD_3_4_BASE:1.1.1.4
	OPENBSD_3_3:1.1.1.4.0.2
	OPENBSD_3_3_BASE:1.1.1.4
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.1.1.3.0.6
	OPENBSD_3_2_BASE:1.1.1.3
	OPENBSD_3_1:1.1.1.3.0.4
	OPENBSD_3_1_BASE:1.1.1.3
	OPENBSD_3_0:1.1.1.3.0.2
	OPENBSD_3_0_BASE:1.1.1.3
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.1.1.2.0.6
	OPENBSD_2_9_BASE:1.1.1.2
	OPENBSD_2_8:1.1.1.2.0.4
	OPENBSD_2_8_BASE:1.1.1.2
	OPENBSD_2_7:1.1.1.2.0.2
	OPENBSD_2_7_BASE:1.1.1.2
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.1.1.1.0.2
	OPENBSD_2_6_BASE:1.1.1.1
	PERL_500503:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;


1.2
date	2008.09.29.17.35.56;	author millert;	state dead;
branches;
next	1.1;

1.1
date	99.04.29.22.37.03;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.29.22.37.03;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.04.06.16.08.32;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.05.24.18.21.56;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.27.22.14.39;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.12.03.02.43.04;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2006.03.28.18.46.11;	author millert;	state Exp;
branches;
next	;


desc
@@


1.2
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@use strict;
my %alias_to = (
    U32 => [qw(PADOFFSET STRLEN)],
    I32 => [qw(SSize_t long)],
    U16 => [qw(OPCODE line_t short)],
    U8 => [qw(char)],
);

my @@optype= qw(OP UNOP BINOP LOGOP CONDOP LISTOP PMOP SVOP GVOP PVOP LOOP COP);

# Nullsv *must* come first in the following so that the condition
# ($$sv == 0) can continue to be used to test (sv == Nullsv).
my @@specialsv = qw(Nullsv &PL_sv_undef &PL_sv_yes &PL_sv_no);

my (%alias_from, $from, $tos);
while (($from, $tos) = each %alias_to) {
    map { $alias_from{$_} = $from } @@$tos;
}

my $c_header = <<'EOT';
/*
 *      Copyright (c) 1996-1998 Malcolm Beattie
 *
 *      You may distribute under the terms of either the GNU General Public
 *      License or the Artistic License, as specified in the README file.
 *
 */
/*
 * This file is autogenerated from bytecode.pl. Changes made here will be lost.
 */
EOT

my $perl_header;
($perl_header = $c_header) =~ s{[/ ]?\*/?}{#}g;

unlink "byterun.c", "byterun.h", "ext/B/B/Asmdata.pm";

#
# Start with boilerplate for Asmdata.pm
#
open(ASMDATA_PM, ">ext/B/B/Asmdata.pm") or die "ext/B/B/Asmdata.pm: $!";
print ASMDATA_PM $perl_header, <<'EOT';
package B::Asmdata;
use Exporter;
@@ISA = qw(Exporter);
@@EXPORT_OK = qw(%insn_data @@insn_name @@optype @@specialsv_name);
use vars qw(%insn_data @@insn_name @@optype @@specialsv_name);

EOT
print ASMDATA_PM <<"EOT";
\@@optype = qw(@@optype);
\@@specialsv_name = qw(@@specialsv);

# XXX insn_data is initialised this way because with a large
# %insn_data = (foo => [...], bar => [...], ...) initialiser
# I get a hard-to-track-down stack underflow and segfault.
EOT

#
# Boilerplate for byterun.c
#
open(BYTERUN_C, ">byterun.c") or die "byterun.c: $!";
print BYTERUN_C $c_header, <<'EOT';

#include "EXTERN.h"
#include "perl.h"

void *
bset_obj_store(void *obj, I32 ix)
{
    if (ix > PL_bytecode_obj_list_fill) {
	if (PL_bytecode_obj_list_fill == -1)
	    New(666, PL_bytecode_obj_list, ix + 1, void*);
	else
	    Renew(PL_bytecode_obj_list, ix + 1, void*);
	PL_bytecode_obj_list_fill = ix;
    }
    PL_bytecode_obj_list[ix] = obj;
    return obj;
}

#ifdef INDIRECT_BGET_MACROS
void byterun(struct bytestream bs)
#else
void byterun(PerlIO *fp)
#endif /* INDIRECT_BGET_MACROS */
{
    dTHR;
    int insn;
    while ((insn = BGET_FGETC()) != EOF) {
	switch (insn) {
EOT


my (@@insn_name, $insn_num, $insn, $lvalue, $argtype, $flags, $fundtype);

while (<DATA>) {
    chop;
    s/#.*//;			# remove comments
    next unless length;
    if (/^%number\s+(.*)/) {
	$insn_num = $1;
	next;
    } elsif (/%enum\s+(.*?)\s+(.*)/) {
	create_enum($1, $2);	# must come before instructions
	next;
    }
    ($insn, $lvalue, $argtype, $flags) = split;
    $insn_name[$insn_num] = $insn;
    $fundtype = $alias_from{$argtype} || $argtype;

    #
    # Add the case statement and code for the bytecode interpreter in byterun.c
    #
    printf BYTERUN_C "\t  case INSN_%s:\t\t/* %d */\n\t    {\n",
	uc($insn), $insn_num;
    my $optarg = $argtype eq "none" ? "" : ", arg";
    if ($optarg) {
	printf BYTERUN_C "\t\t$argtype arg;\n\t\tBGET_%s(arg);\n", $fundtype;
    }
    if ($flags =~ /x/) {
	print BYTERUN_C "\t\tBSET_$insn($lvalue$optarg);\n";
    } elsif ($flags =~ /s/) {
	# Store instructions store to PL_bytecode_obj_list[arg]. "lvalue" field is rvalue.
	print BYTERUN_C "\t\tBSET_OBJ_STORE($lvalue$optarg);\n";
    }
    elsif ($optarg && $lvalue ne "none") {
	print BYTERUN_C "\t\t$lvalue = arg;\n";
    }
    print BYTERUN_C "\t\tbreak;\n\t    }\n";

    #
    # Add the initialiser line for %insn_data in Asmdata.pm
    #
    print ASMDATA_PM <<"EOT";
\$insn_data{$insn} = [$insn_num, \\&PUT_$fundtype, "GET_$fundtype"];
EOT

    # Find the next unused instruction number
    do { $insn_num++ } while $insn_name[$insn_num];
}

#
# Finish off byterun.c
#
print BYTERUN_C <<'EOT';
	  default:
	    croak("Illegal bytecode instruction %d\n", insn);
	    /* NOTREACHED */
	}
    }
}
EOT

#
# Write the instruction and optype enum constants into byterun.h
#
open(BYTERUN_H, ">byterun.h") or die "byterun.h: $!";
print BYTERUN_H $c_header, <<'EOT';
#ifdef INDIRECT_BGET_MACROS
struct bytestream {
    void *data;
    int (*fgetc)(void *);
    int (*fread)(char *, size_t, size_t, void*);
    void (*freadpv)(U32, void*);
};
#endif /* INDIRECT_BGET_MACROS */

void *bset_obj_store _((void *, I32));

enum {
EOT

my $i = 0;
my $add_enum_value = 0;
my $max_insn;
for ($i = 0; $i < @@insn_name; $i++) {
    $insn = uc($insn_name[$i]);
    if (defined($insn)) {
	$max_insn = $i;
	if ($add_enum_value) {
	    print BYTERUN_H "    INSN_$insn = $i,\t\t\t/* $i */\n";
	    $add_enum_value = 0;
	} else {
	    print BYTERUN_H "    INSN_$insn,\t\t\t/* $i */\n";
	}
    } else {
	$add_enum_value = 1;
    }
}

print BYTERUN_H "    MAX_INSN = $max_insn\n};\n";

print BYTERUN_H "\nenum {\n";
for ($i = 0; $i < @@optype - 1; $i++) {
    printf BYTERUN_H "    OPt_%s,\t\t/* %d */\n", $optype[$i], $i;
}
printf BYTERUN_H "    OPt_%s\t\t/* %d */\n};\n\n", $optype[$i], $i;
print BYTERUN_H <<'EOT';
EXT int optype_size[]
#ifdef DOINIT
= {
EOT
for ($i = 0; $i < @@optype - 1; $i++) {
    printf BYTERUN_H "    sizeof(%s),\n", $optype[$i], $i;
}
printf BYTERUN_H "    sizeof(%s)\n}\n", $optype[$i], $i;
print BYTERUN_H <<'EOT';
#endif /* DOINIT */
;

EOT

print BYTERUN_H <<'EOT';
#define INIT_SPECIALSV_LIST STMT_START { \
EOT
for ($i = 0; $i < @@specialsv; $i++) {
    print BYTERUN_H "\tPL_specialsv_list[$i] = $specialsv[$i]; \\\n";
}
print BYTERUN_H <<'EOT';
    } STMT_END
EOT

#
# Finish off insn_data and create array initialisers in Asmdata.pm
#
print ASMDATA_PM <<'EOT';

my ($insn_name, $insn_data);
while (($insn_name, $insn_data) = each %insn_data) {
    $insn_name[$insn_data->[0]] = $insn_name;
}
# Fill in any gaps
@@insn_name = map($_ || "unused", @@insn_name);

1;

__END__

=head1 NAME

B::Asmdata - Autogenerated data about Perl ops, used to generate bytecode

=head1 SYNOPSIS

	use Asmdata;

=head1 DESCRIPTION

See F<ext/B/B/Asmdata.pm>.

=head1 AUTHOR

Malcolm Beattie, C<mbeattie@@sable.ox.ac.uk>

=cut
EOT

__END__
# First set instruction ord("#") to read comment to end-of-line (sneaky)
%number 35
comment		arg			comment_t
# Then make ord("\n") into a no-op
%number 10
nop		none			none
# Now for the rest of the ordinary ones, beginning with \0 which is
# ret so that \0-terminated strings can be read properly as bytecode.
%number 0
#
#opcode		lvalue					argtype		flags	
#
ret		none					none		x
ldsv		PL_bytecode_sv				svindex
ldop		PL_op					opindex
stsv		PL_bytecode_sv				U32		s
stop		PL_op					U32		s
ldspecsv	PL_bytecode_sv				U8		x
newsv		PL_bytecode_sv				U8		x
newop		PL_op					U8		x
newopn		PL_op					U8		x
newpv		none					PV
pv_cur		PL_bytecode_pv.xpv_cur			STRLEN
pv_free		PL_bytecode_pv				none		x
sv_upgrade	PL_bytecode_sv				char		x
sv_refcnt	SvREFCNT(PL_bytecode_sv)		U32
sv_refcnt_add	SvREFCNT(PL_bytecode_sv)		I32		x
sv_flags	SvFLAGS(PL_bytecode_sv)			U32
xrv		SvRV(PL_bytecode_sv)			svindex
xpv		PL_bytecode_sv				none		x
xiv32		SvIVX(PL_bytecode_sv)			I32
xiv64		SvIVX(PL_bytecode_sv)			IV64
xnv		SvNVX(PL_bytecode_sv)			double
xlv_targoff	LvTARGOFF(PL_bytecode_sv)		STRLEN
xlv_targlen	LvTARGLEN(PL_bytecode_sv)		STRLEN
xlv_targ	LvTARG(PL_bytecode_sv)			svindex
xlv_type	LvTYPE(PL_bytecode_sv)			char
xbm_useful	BmUSEFUL(PL_bytecode_sv)		I32
xbm_previous	BmPREVIOUS(PL_bytecode_sv)		U16
xbm_rare	BmRARE(PL_bytecode_sv)			U8
xfm_lines	FmLINES(PL_bytecode_sv)			I32
xio_lines	IoLINES(PL_bytecode_sv)			long
xio_page	IoPAGE(PL_bytecode_sv)			long
xio_page_len	IoPAGE_LEN(PL_bytecode_sv)		long
xio_lines_left	IoLINES_LEFT(PL_bytecode_sv)		long
xio_top_name	IoTOP_NAME(PL_bytecode_sv)		pvcontents
xio_top_gv	*(SV**)&IoTOP_GV(PL_bytecode_sv)	svindex
xio_fmt_name	IoFMT_NAME(PL_bytecode_sv)		pvcontents
xio_fmt_gv	*(SV**)&IoFMT_GV(PL_bytecode_sv)	svindex
xio_bottom_name	IoBOTTOM_NAME(PL_bytecode_sv)		pvcontents
xio_bottom_gv	*(SV**)&IoBOTTOM_GV(PL_bytecode_sv)	svindex
xio_subprocess	IoSUBPROCESS(PL_bytecode_sv)		short
xio_type	IoTYPE(PL_bytecode_sv)			char
xio_flags	IoFLAGS(PL_bytecode_sv)			char
xcv_stash	*(SV**)&CvSTASH(PL_bytecode_sv)		svindex
xcv_start	CvSTART(PL_bytecode_sv)			opindex
xcv_root	CvROOT(PL_bytecode_sv)			opindex
xcv_gv		*(SV**)&CvGV(PL_bytecode_sv)		svindex
xcv_filegv	*(SV**)&CvFILEGV(PL_bytecode_sv)	svindex
xcv_depth	CvDEPTH(PL_bytecode_sv)			long
xcv_padlist	*(SV**)&CvPADLIST(PL_bytecode_sv)	svindex
xcv_outside	*(SV**)&CvOUTSIDE(PL_bytecode_sv)	svindex
xcv_flags	CvFLAGS(PL_bytecode_sv)			U8
av_extend	PL_bytecode_sv				SSize_t		x
av_push		PL_bytecode_sv				svindex		x
xav_fill	AvFILLp(PL_bytecode_sv)			SSize_t
xav_max		AvMAX(PL_bytecode_sv)			SSize_t
xav_flags	AvFLAGS(PL_bytecode_sv)			U8
xhv_riter	HvRITER(PL_bytecode_sv)			I32
xhv_name	HvNAME(PL_bytecode_sv)			pvcontents
hv_store	PL_bytecode_sv				svindex		x
sv_magic	PL_bytecode_sv				char		x
mg_obj		SvMAGIC(PL_bytecode_sv)->mg_obj		svindex
mg_private	SvMAGIC(PL_bytecode_sv)->mg_private	U16
mg_flags	SvMAGIC(PL_bytecode_sv)->mg_flags	U8
mg_pv		SvMAGIC(PL_bytecode_sv)			pvcontents	x
xmg_stash	*(SV**)&SvSTASH(PL_bytecode_sv)		svindex
gv_fetchpv	PL_bytecode_sv				strconst	x
gv_stashpv	PL_bytecode_sv				strconst	x
gp_sv		GvSV(PL_bytecode_sv)			svindex
gp_refcnt	GvREFCNT(PL_bytecode_sv)		U32
gp_refcnt_add	GvREFCNT(PL_bytecode_sv)		I32		x
gp_av		*(SV**)&GvAV(PL_bytecode_sv)		svindex
gp_hv		*(SV**)&GvHV(PL_bytecode_sv)		svindex
gp_cv		*(SV**)&GvCV(PL_bytecode_sv)		svindex
gp_filegv	*(SV**)&GvFILEGV(PL_bytecode_sv)	svindex
gp_io		*(SV**)&GvIOp(PL_bytecode_sv)		svindex
gp_form		*(SV**)&GvFORM(PL_bytecode_sv)		svindex
gp_cvgen	GvCVGEN(PL_bytecode_sv)			U32
gp_line		GvLINE(PL_bytecode_sv)			line_t
gp_share	PL_bytecode_sv				svindex		x
xgv_flags	GvFLAGS(PL_bytecode_sv)			U8
op_next		PL_op->op_next				opindex
op_sibling	PL_op->op_sibling			opindex
op_ppaddr	PL_op->op_ppaddr			strconst	x
op_targ		PL_op->op_targ				PADOFFSET
op_type		PL_op					OPCODE		x
op_seq		PL_op->op_seq				U16
op_flags	PL_op->op_flags				U8
op_private	PL_op->op_private			U8
op_first	cUNOP->op_first				opindex
op_last		cBINOP->op_last				opindex
op_other	cLOGOP->op_other			opindex
op_true		cCONDOP->op_true			opindex
op_false	cCONDOP->op_false			opindex
op_children	cLISTOP->op_children			U32
op_pmreplroot	cPMOP->op_pmreplroot			opindex
op_pmreplrootgv	*(SV**)&cPMOP->op_pmreplroot		svindex
op_pmreplstart	cPMOP->op_pmreplstart			opindex
op_pmnext	*(OP**)&cPMOP->op_pmnext		opindex
pregcomp	PL_op					pvcontents	x
op_pmflags	cPMOP->op_pmflags			U16
op_pmpermflags	cPMOP->op_pmpermflags			U16
op_sv		cSVOP->op_sv				svindex
op_gv		*(SV**)&cGVOP->op_gv			svindex
op_pv		cPVOP->op_pv				pvcontents
op_pv_tr	cPVOP->op_pv				op_tr_array
op_redoop	cLOOP->op_redoop			opindex
op_nextop	cLOOP->op_nextop			opindex
op_lastop	cLOOP->op_lastop			opindex
cop_label	cCOP->cop_label				pvcontents
cop_stash	*(SV**)&cCOP->cop_stash			svindex
cop_filegv	*(SV**)&cCOP->cop_filegv		svindex
cop_seq		cCOP->cop_seq				U32
cop_arybase	cCOP->cop_arybase			I32
cop_line	cCOP->cop_line				line_t
main_start	PL_main_start				opindex
main_root	PL_main_root				opindex
curpad		PL_curpad				svindex		x
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@perl5.005_03
@
text
@@


1.1.1.2
log
@virgin perl 5.6.0
@
text
@a0 3
BEGIN {
  push @@INC, './lib';
}
d9 1
a9 1
my @@optype= qw(OP UNOP BINOP LOGOP LISTOP PMOP SVOP PADOP PVOP LOOP COP);
d22 1
a22 1
 *      Copyright (c) 1996-1999 Malcolm Beattie
d36 1
a36 1
unlink "ext/ByteLoader/byterun.c", "ext/ByteLoader/byterun.h", "ext/B/B/Asmdata.pm";
d47 1
a47 1
our(%insn_data, @@insn_name, @@optype, @@specialsv_name);
d62 1
a62 1
open(BYTERUN_C, ">ext/ByteLoader/byterun.c") or die "ext/ByteLoader/byterun.c: $!";
a64 1
#define PERL_NO_GET_CONTEXT
a66 31
#define NO_XSLOCKS
#include "XSUB.h"

#ifdef PERL_OBJECT
#undef CALL_FPTR
#define CALL_FPTR(fptr) (pPerl->*fptr)
#undef PL_ppaddr
#define PL_ppaddr (*get_ppaddr())
#endif

#include "byterun.h"
#include "bytecode.h"


static int optype_size[] = {
EOT
my $i = 0;
for ($i = 0; $i < @@optype - 1; $i++) {
    printf BYTERUN_C "    sizeof(%s),\n", $optype[$i], $i;
}
printf BYTERUN_C "    sizeof(%s)\n", $optype[$i], $i;
print BYTERUN_C <<'EOT';
};

static SV *specialsv_list[4];

static int bytecode_iv_overflows = 0;
static SV *bytecode_sv;
static XPV bytecode_pv;
static void **bytecode_obj_list;
static I32 bytecode_obj_list_fill = -1;
d69 1
a69 1
bset_obj_store(pTHXo_ void *obj, I32 ix)
d71 3
a73 3
    if (ix > bytecode_obj_list_fill) {
	if (bytecode_obj_list_fill == -1)
	    New(666, bytecode_obj_list, ix + 1, void*);
d75 2
a76 2
	    Renew(bytecode_obj_list, ix + 1, void*);
	bytecode_obj_list_fill = ix;
d78 1
a78 1
    bytecode_obj_list[ix] = obj;
d82 5
a86 2
void
byterun(pTHXo_ struct bytestream bs)
a89 9

EOT

for (my $i = 0; $i < @@specialsv; $i++) {
    print BYTERUN_C "    specialsv_list[$i] = $specialsv[$i];\n";
}

print BYTERUN_C <<'EOT';

d124 1
a124 1
	# Store instructions store to bytecode_obj_list[arg]. "lvalue" field is rvalue.
d148 1
a148 1
	    Perl_croak(aTHX_ "Illegal bytecode instruction %d\n", insn);
d158 1
a158 1
open(BYTERUN_H, ">ext/ByteLoader/byterun.h") or die "ext/ByteLoader/byterun.h: $!";
d160 1
d163 3
a165 3
    int (*pfgetc)(void *);
    int (*pfread)(char *, size_t, size_t, void *);
    void (*pfreadpv)(U32, void *, XPV *);
d167 3
d174 1
d199 14
a214 2
extern void byterun(pTHXo_ struct bytestream bs);

d273 1
a273 1
ldsv		bytecode_sv				svindex
d275 1
a275 1
stsv		bytecode_sv				U32		s
d277 2
a278 2
ldspecsv	bytecode_sv				U8		x
newsv		bytecode_sv				U8		x
d282 70
a351 70
pv_cur		bytecode_pv.xpv_cur			STRLEN
pv_free		bytecode_pv				none		x
sv_upgrade	bytecode_sv				char		x
sv_refcnt	SvREFCNT(bytecode_sv)			U32
sv_refcnt_add	SvREFCNT(bytecode_sv)			I32		x
sv_flags	SvFLAGS(bytecode_sv)			U32
xrv		SvRV(bytecode_sv)			svindex
xpv		bytecode_sv				none		x
xiv32		SvIVX(bytecode_sv)			I32
xiv64		SvIVX(bytecode_sv)			IV64
xnv		SvNVX(bytecode_sv)			NV
xlv_targoff	LvTARGOFF(bytecode_sv)			STRLEN
xlv_targlen	LvTARGLEN(bytecode_sv)			STRLEN
xlv_targ	LvTARG(bytecode_sv)			svindex
xlv_type	LvTYPE(bytecode_sv)			char
xbm_useful	BmUSEFUL(bytecode_sv)			I32
xbm_previous	BmPREVIOUS(bytecode_sv)			U16
xbm_rare	BmRARE(bytecode_sv)			U8
xfm_lines	FmLINES(bytecode_sv)			I32
xio_lines	IoLINES(bytecode_sv)			long
xio_page	IoPAGE(bytecode_sv)			long
xio_page_len	IoPAGE_LEN(bytecode_sv)			long
xio_lines_left	IoLINES_LEFT(bytecode_sv)	       	long
xio_top_name	IoTOP_NAME(bytecode_sv)			pvcontents
xio_top_gv	*(SV**)&IoTOP_GV(bytecode_sv)		svindex
xio_fmt_name	IoFMT_NAME(bytecode_sv)			pvcontents
xio_fmt_gv	*(SV**)&IoFMT_GV(bytecode_sv)		svindex
xio_bottom_name	IoBOTTOM_NAME(bytecode_sv)		pvcontents
xio_bottom_gv	*(SV**)&IoBOTTOM_GV(bytecode_sv)	svindex
xio_subprocess	IoSUBPROCESS(bytecode_sv)		short
xio_type	IoTYPE(bytecode_sv)			char
xio_flags	IoFLAGS(bytecode_sv)			char
xcv_stash	*(SV**)&CvSTASH(bytecode_sv)		svindex
xcv_start	CvSTART(bytecode_sv)			opindex
xcv_root	CvROOT(bytecode_sv)			opindex
xcv_gv		*(SV**)&CvGV(bytecode_sv)		svindex
xcv_file	CvFILE(bytecode_sv)			pvcontents
xcv_depth	CvDEPTH(bytecode_sv)			long
xcv_padlist	*(SV**)&CvPADLIST(bytecode_sv)		svindex
xcv_outside	*(SV**)&CvOUTSIDE(bytecode_sv)		svindex
xcv_flags	CvFLAGS(bytecode_sv)			U16
av_extend	bytecode_sv				SSize_t		x
av_push		bytecode_sv				svindex		x
xav_fill	AvFILLp(bytecode_sv)			SSize_t
xav_max		AvMAX(bytecode_sv)			SSize_t
xav_flags	AvFLAGS(bytecode_sv)			U8
xhv_riter	HvRITER(bytecode_sv)			I32
xhv_name	HvNAME(bytecode_sv)			pvcontents
hv_store	bytecode_sv				svindex		x
sv_magic	bytecode_sv				char		x
mg_obj		SvMAGIC(bytecode_sv)->mg_obj		svindex
mg_private	SvMAGIC(bytecode_sv)->mg_private	U16
mg_flags	SvMAGIC(bytecode_sv)->mg_flags		U8
mg_pv		SvMAGIC(bytecode_sv)			pvcontents	x
xmg_stash	*(SV**)&SvSTASH(bytecode_sv)		svindex
gv_fetchpv	bytecode_sv				strconst	x
gv_stashpv	bytecode_sv				strconst	x
gp_sv		GvSV(bytecode_sv)			svindex
gp_refcnt	GvREFCNT(bytecode_sv)			U32
gp_refcnt_add	GvREFCNT(bytecode_sv)			I32		x
gp_av		*(SV**)&GvAV(bytecode_sv)		svindex
gp_hv		*(SV**)&GvHV(bytecode_sv)		svindex
gp_cv		*(SV**)&GvCV(bytecode_sv)		svindex
gp_file		GvFILE(bytecode_sv)			pvcontents
gp_io		*(SV**)&GvIOp(bytecode_sv)		svindex
gp_form		*(SV**)&GvFORM(bytecode_sv)		svindex
gp_cvgen	GvCVGEN(bytecode_sv)			U32
gp_line		GvLINE(bytecode_sv)			line_t
gp_share	bytecode_sv				svindex		x
xgv_flags	GvFLAGS(bytecode_sv)			U8
d363 2
d374 1
a374 1
op_padix	cPADOP->op_padix			PADOFFSET
d381 2
a382 2
cop_stashpv	cCOP					pvcontents	x
cop_file	cCOP					pvcontents	x
d385 1
a385 2
cop_line	cCOP					line_t		x
cop_warnings	cCOP->cop_warnings			svindex
@


1.1.1.3
log
@stock perl 5.6.1
@
text
@d16 1
a16 1
my @@specialsv = qw(Nullsv &PL_sv_undef &PL_sv_yes &PL_sv_no pWARN_ALL pWARN_NONE);
d85 1
a85 1
static const int optype_size[] = {
d95 8
d104 1
a104 1
bset_obj_store(pTHXo_ struct byteloader_state *bstate, void *obj, I32 ix)
d106 6
a111 3
    if (ix > bstate->bs_obj_list_fill) {
	Renew(bstate->bs_obj_list, ix + 32, void*);
	bstate->bs_obj_list_fill = ix + 31;
d113 1
a113 1
    bstate->bs_obj_list[ix] = obj;
d118 1
a118 1
byterun(pTHXo_ register struct byteloader_state *bstate)
d120 2
a121 7
    register int insn;
    U32 ix;
    SV *specialsv_list[6];

    BYTECODE_HEADER_CHECK;	/* croak if incorrect platform */
    New(666, bstate->bs_obj_list, 32, void*); /* set op objlist */
    bstate->bs_obj_list_fill = 31;
d201 5
a205 4
struct byteloader_fdata {
    SV	*datasv;
    int next_out;
    int	idx;
a207 13
struct byteloader_state {
    struct byteloader_fdata	*bs_fdata;
    SV				*bs_sv;
    void			**bs_obj_list;
    int				bs_obj_list_fill;
    XPV				bs_pv;
    int				bs_iv_overflows;
};

int bl_getc(struct byteloader_fdata *);
int bl_read(struct byteloader_fdata *, char *, size_t, size_t);
extern void byterun(pTHXo_ struct byteloader_state *);

d236 12
d297 1
a297 1
ldsv		bstate->bs_sv				svindex
d299 1
a299 1
stsv		bstate->bs_sv				U32		s
d301 2
a302 3
stpv		bstate->bs_pv.xpv_pv			U32		x
ldspecsv	bstate->bs_sv				U8		x
newsv		bstate->bs_sv				U8		x
d306 70
a375 70
pv_cur		bstate->bs_pv.xpv_cur			STRLEN
pv_free		bstate->bs_pv				none		x
sv_upgrade	bstate->bs_sv				char		x
sv_refcnt	SvREFCNT(bstate->bs_sv)			U32
sv_refcnt_add	SvREFCNT(bstate->bs_sv)			I32		x
sv_flags	SvFLAGS(bstate->bs_sv)			U32
xrv		SvRV(bstate->bs_sv)			svindex
xpv		bstate->bs_sv				none		x
xiv32		SvIVX(bstate->bs_sv)			I32
xiv64		SvIVX(bstate->bs_sv)			IV64
xnv		SvNVX(bstate->bs_sv)			NV
xlv_targoff	LvTARGOFF(bstate->bs_sv)		STRLEN
xlv_targlen	LvTARGLEN(bstate->bs_sv)		STRLEN
xlv_targ	LvTARG(bstate->bs_sv)			svindex
xlv_type	LvTYPE(bstate->bs_sv)			char
xbm_useful	BmUSEFUL(bstate->bs_sv)			I32
xbm_previous	BmPREVIOUS(bstate->bs_sv)		U16
xbm_rare	BmRARE(bstate->bs_sv)			U8
xfm_lines	FmLINES(bstate->bs_sv)			I32
xio_lines	IoLINES(bstate->bs_sv)			long
xio_page	IoPAGE(bstate->bs_sv)			long
xio_page_len	IoPAGE_LEN(bstate->bs_sv)		long
xio_lines_left	IoLINES_LEFT(bstate->bs_sv)	       	long
xio_top_name	IoTOP_NAME(bstate->bs_sv)		pvcontents
xio_top_gv	*(SV**)&IoTOP_GV(bstate->bs_sv)		svindex
xio_fmt_name	IoFMT_NAME(bstate->bs_sv)		pvcontents
xio_fmt_gv	*(SV**)&IoFMT_GV(bstate->bs_sv)		svindex
xio_bottom_name	IoBOTTOM_NAME(bstate->bs_sv)		pvcontents
xio_bottom_gv	*(SV**)&IoBOTTOM_GV(bstate->bs_sv)	svindex
xio_subprocess	IoSUBPROCESS(bstate->bs_sv)		short
xio_type	IoTYPE(bstate->bs_sv)			char
xio_flags	IoFLAGS(bstate->bs_sv)			char
xcv_stash	*(SV**)&CvSTASH(bstate->bs_sv)		svindex
xcv_start	CvSTART(bstate->bs_sv)			opindex
xcv_root	CvROOT(bstate->bs_sv)			opindex
xcv_gv		*(SV**)&CvGV(bstate->bs_sv)		svindex
xcv_file	CvFILE(bstate->bs_sv)			pvindex
xcv_depth	CvDEPTH(bstate->bs_sv)			long
xcv_padlist	*(SV**)&CvPADLIST(bstate->bs_sv)	svindex
xcv_outside	*(SV**)&CvOUTSIDE(bstate->bs_sv)	svindex
xcv_flags	CvFLAGS(bstate->bs_sv)			U16
av_extend	bstate->bs_sv				SSize_t		x
av_push		bstate->bs_sv				svindex		x
xav_fill	AvFILLp(bstate->bs_sv)			SSize_t
xav_max		AvMAX(bstate->bs_sv)			SSize_t
xav_flags	AvFLAGS(bstate->bs_sv)			U8
xhv_riter	HvRITER(bstate->bs_sv)			I32
xhv_name	HvNAME(bstate->bs_sv)			pvcontents
hv_store	bstate->bs_sv				svindex		x
sv_magic	bstate->bs_sv				char		x
mg_obj		SvMAGIC(bstate->bs_sv)->mg_obj		svindex
mg_private	SvMAGIC(bstate->bs_sv)->mg_private	U16
mg_flags	SvMAGIC(bstate->bs_sv)->mg_flags	U8
mg_pv		SvMAGIC(bstate->bs_sv)			pvcontents	x
xmg_stash	*(SV**)&SvSTASH(bstate->bs_sv)		svindex
gv_fetchpv	bstate->bs_sv				strconst	x
gv_stashpv	bstate->bs_sv				strconst	x
gp_sv		GvSV(bstate->bs_sv)			svindex
gp_refcnt	GvREFCNT(bstate->bs_sv)			U32
gp_refcnt_add	GvREFCNT(bstate->bs_sv)			I32		x
gp_av		*(SV**)&GvAV(bstate->bs_sv)		svindex
gp_hv		*(SV**)&GvHV(bstate->bs_sv)		svindex
gp_cv		*(SV**)&GvCV(bstate->bs_sv)		svindex
gp_file		GvFILE(bstate->bs_sv)			pvindex
gp_io		*(SV**)&GvIOp(bstate->bs_sv)		svindex
gp_form		*(SV**)&GvFORM(bstate->bs_sv)		svindex
gp_cvgen	GvCVGEN(bstate->bs_sv)			U32
gp_line		GvLINE(bstate->bs_sv)			line_t
gp_share	bstate->bs_sv				svindex		x
xgv_flags	GvFLAGS(bstate->bs_sv)			U8
d387 1
d402 3
a404 3
cop_label	cCOP->cop_label				pvindex
cop_stashpv	cCOP					pvindex		x
cop_file	cCOP					pvindex		x
a411 3
push_begin	PL_beginav				svindex		x
push_init	PL_initav				svindex		x
push_end	PL_endav				svindex		x
@


1.1.1.4
log
@stock perl 5.8.0 from CPAN
@
text
@a46 3

our $VERSION = '1.00';

d74 7
d96 1
a96 1
bset_obj_store(pTHX_ struct byteloader_state *bstate, void *obj, I32 ix)
d107 1
a107 1
byterun(pTHX_ register struct byteloader_state *bstate)
d119 1
a119 1
for my $i ( 0 .. $#specialsv ) {
d212 1
a212 1
extern void byterun(pTHX_ struct byteloader_state *);
d219 1
a219 1
for $i ( 0 .. $#insn_name ) {
d264 1
a264 1
	use B::Asmdata qw(%insn_data @@insn_name @@optype @@specialsv_name);
d268 1
a268 43
Provides information about Perl ops in order to generate bytecode via
a bunch of exported variables.  Its mostly used by B::Assembler and
B::Disassembler.

=over 4

=item %insn_data

  my($bytecode_num, $put_sub, $get_meth) = @@$insn_data{$op_name};

For a given $op_name (for example, 'cop_label', 'sv_flags', etc...) 
you get an array ref containing the bytecode number of the op, a
reference to the subroutine used to 'PUT', and the name of the method
used to 'GET'.

=for _private
Add more detail about what $put_sub and $get_meth are and how to use them.

=item @@insn_name

  my $op_name = $insn_name[$bytecode_num];

A simple mapping of the bytecode number to the name of the op.
Suitable for using with %insn_data like so:

  my $op_info = $insn_data{$insn_name[$bytecode_num]};

=item @@optype

  my $op_type = $optype[$op_type_num];

A simple mapping of the op type number to its type (like 'COP' or 'BINOP').

=item @@specialsv_name

  my $sv_name = $specialsv_name[$sv_index];

Certain SV types are considered 'special'.  They're represented by
B::SPECIAL and are refered to by a number from the specialsv_list.
This array maps that number back to the name of the SV (like 'Nullsv'
or '&PL_sv_undef').

=back
d303 1
a303 1
sv_upgrade	bstate->bs_sv				U8		x
d319 5
a323 5
xfm_lines	FmLINES(bstate->bs_sv)			IV
xio_lines	IoLINES(bstate->bs_sv)			IV
xio_page	IoPAGE(bstate->bs_sv)			IV
xio_page_len	IoPAGE_LEN(bstate->bs_sv)		IV
xio_lines_left	IoLINES_LEFT(bstate->bs_sv)	       	IV
@


1.1.1.5
log
@perl 5.8.2 from CPAN
@
text
@a2 1
  require 'regen_lib.pl';
d6 4
a9 4
    U32 => [qw(line_t)],
    PADOFFSET => [qw(STRLEN SSize_t)],
    U16 => [qw(OPCODE short)],
    U8  => [qw(char)],
d39 1
a39 1
safer_unlink "ext/ByteLoader/byterun.c", "ext/ByteLoader/byterun.h", "ext/B/B/Asmdata.pm";
d48 1
a48 1
our $VERSION = '1.01';
d102 1
a102 1
int
a111 2
    bstate->bs_obj_list[0] = NULL; /* first is always Null */
    bstate->bs_ix = 1;
a128 4
    if (/^\s*#/) {
	print BYTERUN_C if /^\s*#\s*(?:if|endif|el)/;
	next;
    }
d130 1
a139 4
    my $rvalcast = '';
    if ($argtype =~ m:(.+)/(.+):) {
	($rvalcast, $argtype) = ("($1)", $2);
    }
d159 1
a159 1
	print BYTERUN_C "\t\t$lvalue = ${rvalcast}arg;\n";
a182 1
    return 0;
a201 1
    int				bs_ix;
d208 1
a208 1
extern int byterun(pTHX_ struct byteloader_state *);
a314 5

close ASMDATA_PM or die "Error closing ASMDATA_PM: $!";
close BYTERUN_H or die "Error closing BYTERUN_H: $!";
close BYTERUN_C or die "Error closing BYTERUN_C: $!";

a321 1

a325 2
# The argtype is either a single type or "rightvaluecast/argtype".
#
a334 1
ldspecsvx	bstate->bs_sv				U8		x
a335 1
newsvx		bstate->bs_sv				U32		x
a336 1
newopx		PL_op					U16		x
d347 2
a348 3
xpv_cur		SvCUR(bstate->bs_sv)			STRLEN
xpv_len		SvLEN(bstate->bs_sv)			STRLEN
xiv		SvIVX(bstate->bs_sv)			IV
d362 1
a362 1
xio_top_name	IoTOP_NAME(bstate->bs_sv)		pvindex
d364 1
a364 1
xio_fmt_name	IoFMT_NAME(bstate->bs_sv)		pvindex
d366 1
a366 1
xio_bottom_name	IoBOTTOM_NAME(bstate->bs_sv)		pvindex
a370 1
xcv_xsubany	*(SV**)&CvXSUBANY(bstate->bs_sv).any_ptr	svindex
a378 1
xcv_outside_seq	CvOUTSIDE_SEQ(bstate->bs_sv)		U32
a380 1
av_pushx	bstate->bs_sv				svindex		x
d386 1
a386 2
xhv_name	HvNAME(bstate->bs_sv)			pvindex
xhv_pmroot	*(OP**)&HvPMROOT(bstate->bs_sv)		opindex
d392 1
a392 2
mg_name		SvMAGIC(bstate->bs_sv)			pvcontents	x
mg_namex	SvMAGIC(bstate->bs_sv)			svindex		x
a394 1
gv_fetchpvx	bstate->bs_sv				strconst	x
a395 1
gv_stashpvx	bstate->bs_sv				strconst	x
d421 1
a423 7
#ifdef USE_ITHREADS
op_pmstashpv	cPMOP					pvindex		x
op_pmreplrootpo	cPMOP->op_pmreplroot			OP*/PADOFFSET
#else
op_pmstash	*(SV**)&cPMOP->op_pmstash		svindex
op_pmreplrootgv	*(SV**)&cPMOP->op_pmreplroot		svindex
#endif
a426 1
op_pmdynflags	cPMOP->op_pmdynflags			U8
a434 1
#ifdef USE_ITHREADS
a436 4
#else
cop_stash	cCOP					svindex		x
cop_filegv	cCOP					svindex		x
#endif
d439 1
a439 2
cop_line	cCOP->cop_line				line_t
cop_io		cCOP->cop_io				svindex
a442 1
main_cv		*(SV**)&PL_main_cv			svindex
a446 14
curstash	*(SV**)&PL_curstash			svindex
defstash	*(SV**)&PL_defstash			svindex
data		none					U8		x
incav		*(SV**)&GvAV(PL_incgv)			svindex
load_glob	none					svindex		x
#ifdef USE_ITHREADS
regex_padav	*(SV**)&PL_regex_padav			svindex
#endif
dowarn		PL_dowarn				U8
comppad_name	*(SV**)&PL_comppad_name			svindex
xgv_stash	*(SV**)&GvSTASH(bstate->bs_sv)		svindex
signal		bstate->bs_sv				strconst	x
# to be removed
formfeed	PL_formfeed				svindex
@


1.1.1.6
log
@perl 5.8.8 import
@
text
@d25 1
a25 2
/* -*- buffer-read-only: t -*-
 *
a45 1
binmode ASMDATA_PM;
a69 1
binmode BYTERUN_C;
d111 1
a111 1
    Newx(bstate->bs_obj_list, 32, void*); /* set op objlist */
a194 2

/* ex: set ro: */
a200 1
binmode BYTERUN_H;
a249 2
print BYTERUN_H "/* ex: set ro: */\n";

d314 1
a314 1
B::SPECIAL and are referred to by a number from the specialsv_list.
a324 2

# ex: set ro:
d368 1
a368 1
xrv		bstate->bs_sv				svindex		x
d370 4
a373 4
xpv_cur		bstate->bs_sv	 			STRLEN		x
xpv_len		bstate->bs_sv				STRLEN		x
xiv		bstate->bs_sv				IV		x
xnv		bstate->bs_sv				NV		x
d413 1
a413 1
xhv_name	bstate->bs_sv				pvindex		x
d422 1
a422 1
xmg_stash	bstate->bs_sv				svindex		x
@


