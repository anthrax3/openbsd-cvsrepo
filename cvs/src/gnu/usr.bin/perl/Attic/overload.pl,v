head	1.2;
access;
symbols
	OPENBSD_5_3:1.1.1.3.0.10
	OPENBSD_5_3_BASE:1.1.1.3
	OPENBSD_5_2:1.1.1.3.0.8
	OPENBSD_5_2_BASE:1.1.1.3
	OPENBSD_5_1_BASE:1.1.1.3
	OPENBSD_5_1:1.1.1.3.0.6
	OPENBSD_5_0:1.1.1.3.0.4
	OPENBSD_5_0_BASE:1.1.1.3
	OPENBSD_4_9:1.1.1.3.0.2
	OPENBSD_4_9_BASE:1.1.1.3
	PERL_5_12_2:1.1.1.3
	OPENBSD_4_8:1.1.1.2.0.4
	OPENBSD_4_8_BASE:1.1.1.2
	OPENBSD_4_7:1.1.1.2.0.2
	OPENBSD_4_7_BASE:1.1.1.2
	PERL_5_10_1:1.1.1.2
	OPENBSD_4_6:1.1.1.1.0.6
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.2
	OPENBSD_4_5_BASE:1.1.1.1
	PERL_5_10_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2013.03.25.20.40.44;	author sthen;	state dead;
branches;
next	1.1;

1.1
date	2008.09.29.17.18.07;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2008.09.29.17.18.07;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2009.10.12.18.10.36;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2010.09.24.14.48.31;	author millert;	state Exp;
branches;
next	;


desc
@@


1.2
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@#!/usr/bin/perl -w

#
# Generate overload.h
# This allows the order of overloading constants to be changed.
# 

BEGIN {
    # Get function prototypes
    require 'regen_lib.pl';
}

use strict;

my (@@enums, @@names);
while (<DATA>) {
  next if /^#/;
  next if /^$/;
  my ($enum, $name) = /^(\S+)\s+(\S+)/ or die "Can't parse $_";
  push @@enums, $enum;
  push @@names, $name;
}

safer_unlink ('overload.h', 'overload.c');
die "overload.h: $!" unless open(C, ">overload.c");
binmode C;
die "overload.h: $!" unless open(H, ">overload.h");
binmode H;

sub print_header {
  my $file = shift;
  print <<"EOF";
/* -*- buffer-read-only: t -*-
 *
 *    $file
 *
 *    Copyright (C) 1997, 1998, 2000, 2001, 2005, 2006, 2007 by Larry Wall
 *    and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 *  !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
 *  This file is built by overload.pl
 */
EOF
}

select C;
print_header('overload.c');

select H;
print_header('overload.h');
print <<'EOF';

enum {
EOF

print "    ${_}_amg,\n", foreach @@enums;

print <<'EOF';
    max_amg_code
    /* Do not leave a trailing comma here.  C9X allows it, C89 doesn't. */
};

#define NofAMmeth max_amg_code

EOF

print C <<'EOF';

#define AMG_id2name(id) (PL_AMG_names[id]+1)
#define AMG_id2namelen(id) (PL_AMG_namelens[id]-1)

const U8 PL_AMG_namelens[NofAMmeth] = {
EOF

my $last = pop @@names;

print C "    $_,\n" foreach map { length $_ } @@names;

my $lastlen = length $last;
print C <<"EOT";
    $lastlen
};

char * const PL_AMG_names[NofAMmeth] = {
  /* Names kept in the symbol table.  fallback => "()", the rest has
     "(" prepended.  The only other place in perl which knows about
     this convention is AMG_id2name (used for debugging output and
     'nomethod' only), the only other place which has it hardwired is
     overload.pm.  */
EOT

print C "    \"$_\",\n" foreach map { s/(["\\"])/\\$1/g; $_ } @@names;

print C <<"EOT";
    "$last"
};
EOT

close H or die $!;
close C or die $!;

__DATA__
# Fallback should be the first
fallback	()

# These 5 are the most common in the fallback switch statement in amagic_call
to_sv		(${}
to_av		(@@{}
to_hv		(%{}
to_gv		(*{}
to_cv		(&{}

# These have non-default cases in that switch statement
inc		(++
dec		(--
bool_		(bool
numer		(0+
string		(""
not		(!
copy		(=
abs		(abs
neg		(neg
iter		(<>
int		(int

# These 12 feature in the next switch statement
lt		(<
le		(<=
gt		(>
ge		(>=
eq		(==
ne		(!=
slt		(lt
sle		(le
sgt		(gt
sge		(ge
seq		(eq
sne		(ne

nomethod	(nomethod
add		(+
add_ass		(+=
subtr		(-
subtr_ass	(-=
mult		(*
mult_ass	(*=
div		(/
div_ass		(/=
modulo		(%
modulo_ass	(%=
pow		(**
pow_ass		(**=
lshift		(<<
lshift_ass	(<<=
rshift		(>>
rshift_ass	(>>=
band		(&
band_ass	(&=
bor		(|
bor_ass		(|=
bxor		(^
bxor_ass	(^=
ncmp		(<=>
scmp		(cmp
compl		(~
atan2		(atan2
cos		(cos
sin		(sin
exp		(exp
log		(log
sqrt		(sqrt
repeat		(x
repeat_ass	(x=
concat		(.
concat_ass	(.=
smart		(~~
# Note: Perl_Gv_AMupdate() assumes that DESTROY is the last entry
DESTROY		DESTROY
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@import perl 5.10.0 from CPAN
@
text
@@


1.1.1.2
log
@import perl 5.10.1
@
text
@d2 1
d4 1
a4 8
# Regenerate (overwriting only if changed):
#
#    overload.h
#    overload.c
#    lib/overload/numbers.pm
#
# from information stored in the DATA section of this file.
#
d6 1
a6 4
#
# Accepts the standard regen_lib -q and -v args.
#
# This script is normally invoked from regen.pl.
a14 2
use File::Spec::Functions qw(catdir catfile);;

d24 5
a28 42
safer_unlink (catfile(qw(lib overload numbers.pm)));
my $c = safer_open("overload.c-new");
my $h = safer_open("overload.h-new");
mkdir("lib/overload") unless -d catdir(qw(lib overload));
my $p = safer_open(catfile(qw(lib overload numbers.pm)));


select $p;

{
local $" = "\n    ";
print <<"EOF";
# -*- buffer-read-only: t -*-
#
#   lib/overload/numbers.pm
#
#   Copyright (C) 2008 by Larry Wall and others
#
#   You may distribute under the terms of either the GNU General Public
#   License or the Artistic License, as specified in the README file.
#
# !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
# This file is built by overload.pl
#

package overload::numbers;

our \@@names = qw#
    @@names
#;

our \@@enums = qw#
    @@enums
#;

{ my \$i = 0; our %names = map { \$_ => \$i++ } \@@names }

{ my \$i = 0; our %enums = map { \$_ => \$i++ } \@@enums }

EOF
}

d49 1
a49 1
select $c;
d52 1
a52 1
select $h;
d70 1
a70 1
print $c <<'EOF';
d80 1
a80 1
print $c "    $_,\n" foreach map { length $_ } @@names;
d83 1
a83 1
print $c <<"EOT";
d87 1
a87 1
const char * const PL_AMG_names[NofAMmeth] = {
d95 1
a95 1
print $c "    \"$_\",\n" foreach map { s/(["\\"])/\\$1/g; $_ } @@names;
d97 1
a97 1
print $c <<"EOT";
d102 2
a103 5
safer_close($h);
safer_close($c);
safer_close($p);
rename_if_different("overload.c-new", "overload.c");
rename_if_different("overload.h-new","overload.h");
@


1.1.1.3
log
@Perl 5.12.2 from CPAN
@
text
@d123 1
a123 1
static const U8 PL_AMG_namelens[NofAMmeth] = {
d135 1
a135 1
static const char * const PL_AMG_names[NofAMmeth] = {
a230 2
ftest           (-X
regexp          (qr
@


