head	1.6;
access;
symbols
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;


1.6
date	2002.10.27.22.25.35;	author millert;	state dead;
branches;
next	1.5;

1.5
date	2001.05.24.18.36.09;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.08.07;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.52.29;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.08.00.24;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.13.14;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.13.14;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.41.30;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.10.41;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.25.11;	author millert;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@#!./perl -w

BEGIN {
    @@INC = '../lib';
    require Config; import Config;
    if ($Config{'extensions'} !~ /\bDB_File\b/) {
	print "1..0 # Skip: DB_File was not built\n";
	exit 0;
    }
}

use warnings;
use strict;
use DB_File; 
use Fcntl;

print "1..157\n";

sub ok
{
    my $no = shift ;
    my $result = shift ;
 
    print "not " unless $result ;
    print "ok $no\n" ;
}

sub lexical
{
    my(@@a) = unpack ("C*", $a) ;
    my(@@b) = unpack ("C*", $b) ;

    my $len = (@@a > @@b ? @@b : @@a) ;
    my $i = 0 ;

    foreach $i ( 0 .. $len -1) {
        return $a[$i] - $b[$i] if $a[$i] != $b[$i] ;
    }

    return @@a - @@b ;
}

{
    package Redirect ;
    use Symbol ;

    sub new
    {
        my $class = shift ;
        my $filename = shift ;
	my $fh = gensym ;
	open ($fh, ">$filename") || die "Cannot open $filename: $!" ;
	my $real_stdout = select($fh) ;
	return bless [$fh, $real_stdout ] ;

    }
    sub DESTROY
    {
        my $self = shift ;
	close $self->[0] ;
	select($self->[1]) ;
    }
}

sub docat
{ 
    my $file = shift;
    #local $/ = undef unless wantarray ;
    open(CAT,$file) || die "Cannot open $file: $!";
    my @@result = <CAT>;
    close(CAT);
    wantarray ? @@result : join("", @@result) ;
}   

sub docat_del
{ 
    my $file = shift;
    #local $/ = undef unless wantarray ;
    open(CAT,$file) || die "Cannot open $file: $!";
    my @@result = <CAT>;
    close(CAT);
    unlink $file ;
    wantarray ? @@result : join("", @@result) ;
}   


my $db185mode =  ($DB_File::db_version == 1 && ! $DB_File::db_185_compat) ;
my $null_keys_allowed = ($DB_File::db_ver < 2.004010 
				|| $DB_File::db_ver >= 3.1 );

my $Dfile = "dbbtree.tmp";
unlink $Dfile;

umask(0);

# Check the interface to BTREEINFO

my $dbh = new DB_File::BTREEINFO ;
ok(1, ! defined $dbh->{flags}) ;
ok(2, ! defined $dbh->{cachesize}) ;
ok(3, ! defined $dbh->{psize}) ;
ok(4, ! defined $dbh->{lorder}) ;
ok(5, ! defined $dbh->{minkeypage}) ;
ok(6, ! defined $dbh->{maxkeypage}) ;
ok(7, ! defined $dbh->{compare}) ;
ok(8, ! defined $dbh->{prefix}) ;

$dbh->{flags} = 3000 ;
ok(9, $dbh->{flags} == 3000) ;

$dbh->{cachesize} = 9000 ;
ok(10, $dbh->{cachesize} == 9000);

$dbh->{psize} = 400 ;
ok(11, $dbh->{psize} == 400) ;

$dbh->{lorder} = 65 ;
ok(12, $dbh->{lorder} == 65) ;

$dbh->{minkeypage} = 123 ;
ok(13, $dbh->{minkeypage} == 123) ;

$dbh->{maxkeypage} = 1234 ;
ok(14, $dbh->{maxkeypage} == 1234 );

$dbh->{compare} = 1234 ;
ok(15, $dbh->{compare} == 1234) ;

$dbh->{prefix} = 1234 ;
ok(16, $dbh->{prefix} == 1234 );

# Check that an invalid entry is caught both for store & fetch
eval '$dbh->{fred} = 1234' ;
ok(17, $@@ =~ /^DB_File::BTREEINFO::STORE - Unknown element 'fred' at/ ) ;
eval 'my $q = $dbh->{fred}' ;
ok(18, $@@ =~ /^DB_File::BTREEINFO::FETCH - Unknown element 'fred' at/ ) ;

# Now check the interface to BTREE

my ($X, %h) ;
ok(19, $X = tie(%h, 'DB_File',$Dfile, O_RDWR|O_CREAT, 0640, $DB_BTREE )) ;

my ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,
   $blksize,$blocks) = stat($Dfile);
ok(20, ($mode & 0777) == ($^O eq 'os2' ? 0666 : 0640) || $^O eq 'amigaos' || $^O eq 'MSWin32');

my ($key, $value, $i);
while (($key,$value) = each(%h)) {
    $i++;
}
ok(21, !$i ) ;

$h{'goner1'} = 'snork';

$h{'abc'} = 'ABC';
ok(22, $h{'abc'} eq 'ABC' );
ok(23, ! defined $h{'jimmy'} ) ;
ok(24, ! exists $h{'jimmy'} ) ;
ok(25,  defined $h{'abc'} ) ;

$h{'def'} = 'DEF';
$h{'jkl','mno'} = "JKL\034MNO";
$h{'a',2,3,4,5} = join("\034",'A',2,3,4,5);
$h{'a'} = 'A';

#$h{'b'} = 'B';
$X->STORE('b', 'B') ;

$h{'c'} = 'C';

#$h{'d'} = 'D';
$X->put('d', 'D') ;

$h{'e'} = 'E';
$h{'f'} = 'F';
$h{'g'} = 'X';
$h{'h'} = 'H';
$h{'i'} = 'I';

$h{'goner2'} = 'snork';
delete $h{'goner2'};


# IMPORTANT - $X must be undefined before the untie otherwise the
#             underlying DB close routine will not get called.
undef $X ;
untie(%h);

# tie to the same file again
ok(26, $X = tie(%h,'DB_File',$Dfile, O_RDWR, 0640, $DB_BTREE)) ;

# Modify an entry from the previous tie
$h{'g'} = 'G';

$h{'j'} = 'J';
$h{'k'} = 'K';
$h{'l'} = 'L';
$h{'m'} = 'M';
$h{'n'} = 'N';
$h{'o'} = 'O';
$h{'p'} = 'P';
$h{'q'} = 'Q';
$h{'r'} = 'R';
$h{'s'} = 'S';
$h{'t'} = 'T';
$h{'u'} = 'U';
$h{'v'} = 'V';
$h{'w'} = 'W';
$h{'x'} = 'X';
$h{'y'} = 'Y';
$h{'z'} = 'Z';

$h{'goner3'} = 'snork';

delete $h{'goner1'};
$X->DELETE('goner3');

my @@keys = keys(%h);
my @@values = values(%h);

ok(27, $#keys == 29 && $#values == 29) ;

$i = 0 ;
while (($key,$value) = each(%h)) {
    if ($key eq $keys[$i] && $value eq $values[$i] && $key eq lc($value)) {
	$key =~ y/a-z/A-Z/;
	$i++ if $key eq $value;
    }
}

ok(28, $i == 30) ;

@@keys = ('blurfl', keys(%h), 'dyick');
ok(29, $#keys == 31) ;

#Check that the keys can be retrieved in order
my @@b = keys %h ;
my @@c = sort lexical @@b ;
ok(30, ArrayCompare(\@@b, \@@c)) ;

$h{'foo'} = '';
ok(31, $h{'foo'} eq '' ) ;

# Berkeley DB from version 2.4.10 to 3.0 does not allow null keys.
# This feature was reenabled in version 3.1 of Berkeley DB.
my $result = 0 ;
if ($null_keys_allowed) {
    $h{''} = 'bar';
    $result = ( $h{''} eq 'bar' );
}
else
  { $result = 1 }
ok(32, $result) ;

# check cache overflow and numeric keys and contents
my $ok = 1;
for ($i = 1; $i < 200; $i++) { $h{$i + 0} = $i + 0; }
for ($i = 1; $i < 200; $i++) { $ok = 0 unless $h{$i} == $i; }
ok(33, $ok);

($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,
   $blksize,$blocks) = stat($Dfile);
ok(34, $size > 0 );

@@h{0..200} = 200..400;
my @@foo = @@h{0..200};
ok(35, join(':',200..400) eq join(':',@@foo) );

# Now check all the non-tie specific stuff


# Check R_NOOVERWRITE flag will make put fail when attempting to overwrite
# an existing record.
 
my $status = $X->put( 'x', 'newvalue', R_NOOVERWRITE) ;
ok(36, $status == 1 );
 
# check that the value of the key 'x' has not been changed by the 
# previous test
ok(37, $h{'x'} eq 'X' );

# standard put
$status = $X->put('key', 'value') ;
ok(38, $status == 0 );

#check that previous put can be retrieved
$value = 0 ;
$status = $X->get('key', $value) ;
ok(39, $status == 0 );
ok(40, $value eq 'value' );

# Attempting to delete an existing key should work

$status = $X->del('q') ;
ok(41, $status == 0 );
if ($null_keys_allowed) {
    $status = $X->del('') ;
} else {
    $status = 0 ;
}
ok(42, $status == 0 );

# Make sure that the key deleted, cannot be retrieved
ok(43, ! defined $h{'q'}) ;
ok(44, ! defined $h{''}) ;

undef $X ;
untie %h ;

ok(45, $X = tie(%h, 'DB_File',$Dfile, O_RDWR, 0640, $DB_BTREE ));

# Attempting to delete a non-existant key should fail

$status = $X->del('joe') ;
ok(46, $status == 1 );

# Check the get interface

# First a non-existing key
$status = $X->get('aaaa', $value) ;
ok(47, $status == 1 );

# Next an existing key
$status = $X->get('a', $value) ;
ok(48, $status == 0 );
ok(49, $value eq 'A' );

# seq
# ###

# use seq to find an approximate match
$key = 'ke' ;
$value = '' ;
$status = $X->seq($key, $value, R_CURSOR) ;
ok(50, $status == 0 );
ok(51, $key eq 'key' );
ok(52, $value eq 'value' );

# seq when the key does not match
$key = 'zzz' ;
$value = '' ;
$status = $X->seq($key, $value, R_CURSOR) ;
ok(53, $status == 1 );


# use seq to set the cursor, then delete the record @@ the cursor.

$key = 'x' ;
$value = '' ;
$status = $X->seq($key, $value, R_CURSOR) ;
ok(54, $status == 0 );
ok(55, $key eq 'x' );
ok(56, $value eq 'X' );
$status = $X->del(0, R_CURSOR) ;
ok(57, $status == 0 );
$status = $X->get('x', $value) ;
ok(58, $status == 1 );

# ditto, but use put to replace the key/value pair.
$key = 'y' ;
$value = '' ;
$status = $X->seq($key, $value, R_CURSOR) ;
ok(59, $status == 0 );
ok(60, $key eq 'y' );
ok(61, $value eq 'Y' );

$key = "replace key" ;
$value = "replace value" ;
$status = $X->put($key, $value, R_CURSOR) ;
ok(62, $status == 0 );
ok(63, $key eq 'replace key' );
ok(64, $value eq 'replace value' );
$status = $X->get('y', $value) ;
ok(65, 1) ; # hard-wire to always pass. the previous test ($status == 1)
	    # only worked because of a bug in 1.85/6

# use seq to walk forwards through a file 

$status = $X->seq($key, $value, R_FIRST) ;
ok(66, $status == 0 );
my $previous = $key ;

$ok = 1 ;
while (($status = $X->seq($key, $value, R_NEXT)) == 0)
{
    ($ok = 0), last if ($previous cmp $key) == 1 ;
}

ok(67, $status == 1 );
ok(68, $ok == 1 );

# use seq to walk backwards through a file 
$status = $X->seq($key, $value, R_LAST) ;
ok(69, $status == 0 );
$previous = $key ;

$ok = 1 ;
while (($status = $X->seq($key, $value, R_PREV)) == 0)
{
    ($ok = 0), last if ($previous cmp $key) == -1 ;
    #print "key = [$key] value = [$value]\n" ;
}

ok(70, $status == 1 );
ok(71, $ok == 1 );


# check seq FIRST/LAST

# sync
# ####

$status = $X->sync ;
ok(72, $status == 0 );


# fd
# ##

$status = $X->fd ;
ok(73, $status != 0 );


undef $X ;
untie %h ;

unlink $Dfile;

# Now try an in memory file
my $Y;
ok(74, $Y = tie(%h, 'DB_File',undef, O_RDWR|O_CREAT, 0640, $DB_BTREE ));

# fd with an in memory file should return failure
$status = $Y->fd ;
ok(75, $status == -1 );


undef $Y ;
untie %h ;

# Duplicate keys
my $bt = new DB_File::BTREEINFO ;
$bt->{flags} = R_DUP ;
my ($YY, %hh);
ok(76, $YY = tie(%hh, 'DB_File', $Dfile, O_RDWR|O_CREAT, 0640, $bt )) ;

$hh{'Wall'} = 'Larry' ;
$hh{'Wall'} = 'Stone' ; # Note the duplicate key
$hh{'Wall'} = 'Brick' ; # Note the duplicate key
$hh{'Wall'} = 'Brick' ; # Note the duplicate key and value
$hh{'Smith'} = 'John' ;
$hh{'mouse'} = 'mickey' ;

# first work in scalar context
ok(77, scalar $YY->get_dup('Unknown') == 0 );
ok(78, scalar $YY->get_dup('Smith') == 1 );
ok(79, scalar $YY->get_dup('Wall') == 4 );

# now in list context
my @@unknown = $YY->get_dup('Unknown') ;
ok(80, "@@unknown" eq "" );

my @@smith = $YY->get_dup('Smith') ;
ok(81, "@@smith" eq "John" );

{
my @@wall = $YY->get_dup('Wall') ;
my %wall ;
@@wall{@@wall} = @@wall ;
ok(82, (@@wall == 4 && $wall{'Larry'} && $wall{'Stone'} && $wall{'Brick'}) );
}

# hash
my %unknown = $YY->get_dup('Unknown', 1) ;
ok(83, keys %unknown == 0 );

my %smith = $YY->get_dup('Smith', 1) ;
ok(84, keys %smith == 1 && $smith{'John'}) ;

my %wall = $YY->get_dup('Wall', 1) ;
ok(85, keys %wall == 3 && $wall{'Larry'} == 1 && $wall{'Stone'} == 1 
		&& $wall{'Brick'} == 2);

undef $YY ;
untie %hh ;
unlink $Dfile;


# test multiple callbacks
my $Dfile1 = "btree1" ;
my $Dfile2 = "btree2" ;
my $Dfile3 = "btree3" ;
 
my $dbh1 = new DB_File::BTREEINFO ;
$dbh1->{compare} = sub { 
	no warnings 'numeric' ;
	$_[0] <=> $_[1] } ; 
 
my $dbh2 = new DB_File::BTREEINFO ;
$dbh2->{compare} = sub { $_[0] cmp $_[1] } ;
 
my $dbh3 = new DB_File::BTREEINFO ;
$dbh3->{compare} = sub { length $_[0] <=> length $_[1] } ;
 
 
my (%g, %k);
tie(%h, 'DB_File',$Dfile1, O_RDWR|O_CREAT, 0640, $dbh1 ) ; 
tie(%g, 'DB_File',$Dfile2, O_RDWR|O_CREAT, 0640, $dbh2 ) ;
tie(%k, 'DB_File',$Dfile3, O_RDWR|O_CREAT, 0640, $dbh3 ) ;
 
my @@Keys = qw( 0123 12 -1234 9 987654321 def  ) ;
my (@@srt_1, @@srt_2, @@srt_3);
{ 
  no warnings 'numeric' ;
  @@srt_1 = sort { $a <=> $b } @@Keys ; 
}
@@srt_2 = sort { $a cmp $b } @@Keys ;
@@srt_3 = sort { length $a <=> length $b } @@Keys ;
 
foreach (@@Keys) {
    $h{$_} = 1 ;
    $g{$_} = 1 ;
    $k{$_} = 1 ;
}
 
sub ArrayCompare
{
    my($a, $b) = @@_ ;
 
    return 0 if @@$a != @@$b ;
 
    foreach (1 .. length @@$a)
    {
        return 0 unless $$a[$_] eq $$b[$_] ;
    }
 
    1 ;
}
 
ok(86, ArrayCompare (\@@srt_1, [keys %h]) );
ok(87, ArrayCompare (\@@srt_2, [keys %g]) );
ok(88, ArrayCompare (\@@srt_3, [keys %k]) );

untie %h ;
untie %g ;
untie %k ;
unlink $Dfile1, $Dfile2, $Dfile3 ;

# clear
# #####

ok(89, tie(%h, 'DB_File', $Dfile1, O_RDWR|O_CREAT, 0640, $DB_BTREE ) );
foreach (1 .. 10)
  { $h{$_} = $_ * 100 }

# check that there are 10 elements in the hash
$i = 0 ;
while (($key,$value) = each(%h)) {
    $i++;
}
ok(90, $i == 10);

# now clear the hash
%h = () ;

# check it is empty
$i = 0 ;
while (($key,$value) = each(%h)) {
    $i++;
}
ok(91, $i == 0);

untie %h ;
unlink $Dfile1 ;

{
    # check that attempting to tie an array to a DB_BTREE will fail

    my $filename = "xyz" ;
    my @@x ;
    eval { tie @@x, 'DB_File', $filename, O_RDWR|O_CREAT, 0640, $DB_BTREE ; } ;
    ok(92, $@@ =~ /^DB_File can only tie an associative array to a DB_BTREE database/) ;
    unlink $filename ;
}

{
   # sub-class test

   package Another ;

   use warnings ;
   use strict ;

   open(FILE, ">SubDB.pm") or die "Cannot open SubDB.pm: $!\n" ;
   print FILE <<'EOM' ;

   package SubDB ;

   use warnings ;
   use strict ;
   use vars qw( @@ISA @@EXPORT) ;

   require Exporter ;
   use DB_File;
   @@ISA=qw(DB_File);
   @@EXPORT = @@DB_File::EXPORT ;

   sub STORE { 
	my $self = shift ;
        my $key = shift ;
        my $value = shift ;
        $self->SUPER::STORE($key, $value * 2) ;
   }

   sub FETCH { 
	my $self = shift ;
        my $key = shift ;
        $self->SUPER::FETCH($key) - 1 ;
   }

   sub put { 
	my $self = shift ;
        my $key = shift ;
        my $value = shift ;
        $self->SUPER::put($key, $value * 3) ;
   }

   sub get { 
	my $self = shift ;
        $self->SUPER::get($_[0], $_[1]) ;
	$_[1] -= 2 ;
   }

   sub A_new_method
   {
	my $self = shift ;
        my $key = shift ;
        my $value = $self->FETCH($key) ;
	return "[[$value]]" ;
   }

   1 ;
EOM

    close FILE ;

    BEGIN { push @@INC, '.'; }    
    eval 'use SubDB ; ';
    main::ok(93, $@@ eq "") ;
    my %h ;
    my $X ;
    eval '
	$X = tie(%h, "SubDB","dbbtree.tmp", O_RDWR|O_CREAT, 0640, $DB_BTREE );
	' ;

    main::ok(94, $@@ eq "") ;

    my $ret = eval '$h{"fred"} = 3 ; return $h{"fred"} ' ;
    main::ok(95, $@@ eq "") ;
    main::ok(96, $ret == 5) ;

    my $value = 0;
    $ret = eval '$X->put("joe", 4) ; $X->get("joe", $value) ; return $value' ;
    main::ok(97, $@@ eq "") ;
    main::ok(98, $ret == 10) ;

    $ret = eval ' R_NEXT eq main::R_NEXT ' ;
    main::ok(99, $@@ eq "" ) ;
    main::ok(100, $ret == 1) ;

    $ret = eval '$X->A_new_method("joe") ' ;
    main::ok(101, $@@ eq "") ;
    main::ok(102, $ret eq "[[11]]") ;

    undef $X;
    untie(%h);
    unlink "SubDB.pm", "dbbtree.tmp" ;

}

{
   # DBM Filter tests
   use warnings ;
   use strict ;
   my (%h, $db) ;
   my ($fetch_key, $store_key, $fetch_value, $store_value) = ("") x 4 ;
   unlink $Dfile;

   sub checkOutput
   {
       my($fk, $sk, $fv, $sv) = @@_ ;
       return
           $fetch_key eq $fk && $store_key eq $sk && 
	   $fetch_value eq $fv && $store_value eq $sv &&
	   $_ eq 'original' ;
   }
   
   ok(103, $db = tie(%h, 'DB_File', $Dfile, O_RDWR|O_CREAT, 0640, $DB_BTREE ) );

   $db->filter_fetch_key   (sub { $fetch_key = $_ }) ;
   $db->filter_store_key   (sub { $store_key = $_ }) ;
   $db->filter_fetch_value (sub { $fetch_value = $_}) ;
   $db->filter_store_value (sub { $store_value = $_ }) ;

   $_ = "original" ;

   $h{"fred"} = "joe" ;
   #                   fk   sk     fv   sv
   ok(104, checkOutput( "", "fred", "", "joe")) ;

   ($fetch_key, $store_key, $fetch_value, $store_value) = ("") x 4 ;
   ok(105, $h{"fred"} eq "joe");
   #                   fk    sk     fv    sv
   ok(106, checkOutput( "", "fred", "joe", "")) ;

   ($fetch_key, $store_key, $fetch_value, $store_value) = ("") x 4 ;
   ok(107, $db->FIRSTKEY() eq "fred") ;
   #                    fk     sk  fv  sv
   ok(108, checkOutput( "fred", "", "", "")) ;

   # replace the filters, but remember the previous set
   my ($old_fk) = $db->filter_fetch_key   
   			(sub { $_ = uc $_ ; $fetch_key = $_ }) ;
   my ($old_sk) = $db->filter_store_key   
   			(sub { $_ = lc $_ ; $store_key = $_ }) ;
   my ($old_fv) = $db->filter_fetch_value 
   			(sub { $_ = "[$_]"; $fetch_value = $_ }) ;
   my ($old_sv) = $db->filter_store_value 
   			(sub { s/o/x/g; $store_value = $_ }) ;
   
   ($fetch_key, $store_key, $fetch_value, $store_value) = ("") x 4 ;
   $h{"Fred"} = "Joe" ;
   #                   fk   sk     fv    sv
   ok(109, checkOutput( "", "fred", "", "Jxe")) ;

   ($fetch_key, $store_key, $fetch_value, $store_value) = ("") x 4 ;
   ok(110, $h{"Fred"} eq "[Jxe]");
   #                   fk   sk     fv    sv
   ok(111, checkOutput( "", "fred", "[Jxe]", "")) ;

   ($fetch_key, $store_key, $fetch_value, $store_value) = ("") x 4 ;
   ok(112, $db->FIRSTKEY() eq "FRED") ;
   #                   fk   sk     fv    sv
   ok(113, checkOutput( "FRED", "", "", "")) ;

   # put the original filters back
   $db->filter_fetch_key   ($old_fk);
   $db->filter_store_key   ($old_sk);
   $db->filter_fetch_value ($old_fv);
   $db->filter_store_value ($old_sv);

   ($fetch_key, $store_key, $fetch_value, $store_value) = ("") x 4 ;
   $h{"fred"} = "joe" ;
   ok(114, checkOutput( "", "fred", "", "joe")) ;

   ($fetch_key, $store_key, $fetch_value, $store_value) = ("") x 4 ;
   ok(115, $h{"fred"} eq "joe");
   ok(116, checkOutput( "", "fred", "joe", "")) ;

   ($fetch_key, $store_key, $fetch_value, $store_value) = ("") x 4 ;
   ok(117, $db->FIRSTKEY() eq "fred") ;
   ok(118, checkOutput( "fred", "", "", "")) ;

   # delete the filters
   $db->filter_fetch_key   (undef);
   $db->filter_store_key   (undef);
   $db->filter_fetch_value (undef);
   $db->filter_store_value (undef);

   ($fetch_key, $store_key, $fetch_value, $store_value) = ("") x 4 ;
   $h{"fred"} = "joe" ;
   ok(119, checkOutput( "", "", "", "")) ;

   ($fetch_key, $store_key, $fetch_value, $store_value) = ("") x 4 ;
   ok(120, $h{"fred"} eq "joe");
   ok(121, checkOutput( "", "", "", "")) ;

   ($fetch_key, $store_key, $fetch_value, $store_value) = ("") x 4 ;
   ok(122, $db->FIRSTKEY() eq "fred") ;
   ok(123, checkOutput( "", "", "", "")) ;

   undef $db ;
   untie %h;
   unlink $Dfile;
}

{    
    # DBM Filter with a closure

    use warnings ;
    use strict ;
    my (%h, $db) ;

    unlink $Dfile;
    ok(124, $db = tie(%h, 'DB_File', $Dfile, O_RDWR|O_CREAT, 0640, $DB_BTREE ) );

    my %result = () ;

    sub Closure
    {
        my ($name) = @@_ ;
	my $count = 0 ;
	my @@kept = () ;

	return sub { ++$count ; 
		     push @@kept, $_ ; 
		     $result{$name} = "$name - $count: [@@kept]" ;
		   }
    }

    $db->filter_store_key(Closure("store key")) ;
    $db->filter_store_value(Closure("store value")) ;
    $db->filter_fetch_key(Closure("fetch key")) ;
    $db->filter_fetch_value(Closure("fetch value")) ;

    $_ = "original" ;

    $h{"fred"} = "joe" ;
    ok(125, $result{"store key"} eq "store key - 1: [fred]");
    ok(126, $result{"store value"} eq "store value - 1: [joe]");
    ok(127, ! defined $result{"fetch key"} );
    ok(128, ! defined $result{"fetch value"} );
    ok(129, $_ eq "original") ;

    ok(130, $db->FIRSTKEY() eq "fred") ;
    ok(131, $result{"store key"} eq "store key - 1: [fred]");
    ok(132, $result{"store value"} eq "store value - 1: [joe]");
    ok(133, $result{"fetch key"} eq "fetch key - 1: [fred]");
    ok(134, ! defined $result{"fetch value"} );
    ok(135, $_ eq "original") ;

    $h{"jim"}  = "john" ;
    ok(136, $result{"store key"} eq "store key - 2: [fred jim]");
    ok(137, $result{"store value"} eq "store value - 2: [joe john]");
    ok(138, $result{"fetch key"} eq "fetch key - 1: [fred]");
    ok(139, ! defined $result{"fetch value"} );
    ok(140, $_ eq "original") ;

    ok(141, $h{"fred"} eq "joe");
    ok(142, $result{"store key"} eq "store key - 3: [fred jim fred]");
    ok(143, $result{"store value"} eq "store value - 2: [joe john]");
    ok(144, $result{"fetch key"} eq "fetch key - 1: [fred]");
    ok(145, $result{"fetch value"} eq "fetch value - 1: [joe]");
    ok(146, $_ eq "original") ;

    undef $db ;
    untie %h;
    unlink $Dfile;
}		

{
   # DBM Filter recursion detection
   use warnings ;
   use strict ;
   my (%h, $db) ;
   unlink $Dfile;

   ok(147, $db = tie(%h, 'DB_File', $Dfile, O_RDWR|O_CREAT, 0640, $DB_BTREE ) );

   $db->filter_store_key (sub { $_ = $h{$_} }) ;

   eval '$h{1} = 1234' ;
   ok(148, $@@ =~ /^recursion detected in filter_store_key at/ );
   
   undef $db ;
   untie %h;
   unlink $Dfile;
}


{
   # Examples from the POD


  my $file = "xyzt" ;
  {
    my $redirect = new Redirect $file ;

    # BTREE example 1
    ###

    use warnings FATAL => qw(all) ;
    use strict ;
    use DB_File ;

    my %h ;

    sub Compare
    {
        my ($key1, $key2) = @@_ ;
        "\L$key1" cmp "\L$key2" ;
    }

    # specify the Perl sub that will do the comparison
    $DB_BTREE->{'compare'} = \&Compare ;

    unlink "tree" ;
    tie %h, "DB_File", "tree", O_RDWR|O_CREAT, 0640, $DB_BTREE 
        or die "Cannot open file 'tree': $!\n" ;

    # Add a key/value pair to the file
    $h{'Wall'} = 'Larry' ;
    $h{'Smith'} = 'John' ;
    $h{'mouse'} = 'mickey' ;
    $h{'duck'}  = 'donald' ;

    # Delete
    delete $h{"duck"} ;

    # Cycle through the keys printing them in order.
    # Note it is not necessary to sort the keys as
    # the btree will have kept them in order automatically.
    foreach (keys %h)
      { print "$_\n" }

    untie %h ;

    unlink "tree" ;
  }  

  delete $DB_BTREE->{'compare'} ;

  ok(149, docat_del($file) eq <<'EOM') ;
mouse
Smith
Wall
EOM
   
  {
    my $redirect = new Redirect $file ;

    # BTREE example 2
    ###

    use warnings FATAL => qw(all) ;
    use strict ;
    use DB_File ;

    use vars qw($filename %h ) ;

    $filename = "tree" ;
    unlink $filename ;
 
    # Enable duplicate records
    $DB_BTREE->{'flags'} = R_DUP ;
 
    tie %h, "DB_File", $filename, O_RDWR|O_CREAT, 0640, $DB_BTREE 
	or die "Cannot open $filename: $!\n";
 
    # Add some key/value pairs to the file
    $h{'Wall'} = 'Larry' ;
    $h{'Wall'} = 'Brick' ; # Note the duplicate key
    $h{'Wall'} = 'Brick' ; # Note the duplicate key and value
    $h{'Smith'} = 'John' ;
    $h{'mouse'} = 'mickey' ;

    # iterate through the associative array
    # and print each key/value pair.
    foreach (keys %h)
      { print "$_	-> $h{$_}\n" }

    untie %h ;

    unlink $filename ;
  }  

  ok(150, docat_del($file) eq ($db185mode ? <<'EOM' : <<'EOM') ) ;
Smith	-> John
Wall	-> Brick
Wall	-> Brick
Wall	-> Brick
mouse	-> mickey
EOM
Smith	-> John
Wall	-> Larry
Wall	-> Larry
Wall	-> Larry
mouse	-> mickey
EOM

  {
    my $redirect = new Redirect $file ;

    # BTREE example 3
    ###

    use warnings FATAL => qw(all) ;
    use strict ;
    use DB_File ;
 
    use vars qw($filename $x %h $status $key $value) ;

    $filename = "tree" ;
    unlink $filename ;
 
    # Enable duplicate records
    $DB_BTREE->{'flags'} = R_DUP ;
 
    $x = tie %h, "DB_File", $filename, O_RDWR|O_CREAT, 0640, $DB_BTREE 
	or die "Cannot open $filename: $!\n";
 
    # Add some key/value pairs to the file
    $h{'Wall'} = 'Larry' ;
    $h{'Wall'} = 'Brick' ; # Note the duplicate key
    $h{'Wall'} = 'Brick' ; # Note the duplicate key and value
    $h{'Smith'} = 'John' ;
    $h{'mouse'} = 'mickey' ;
 
    # iterate through the btree using seq
    # and print each key/value pair.
    $key = $value = 0 ;
    for ($status = $x->seq($key, $value, R_FIRST) ;
         $status == 0 ;
         $status = $x->seq($key, $value, R_NEXT) )
      {  print "$key	-> $value\n" }
 
 
    undef $x ;
    untie %h ;
  }

  ok(151, docat_del($file) eq ($db185mode == 1 ? <<'EOM' : <<'EOM') ) ;
Smith	-> John
Wall	-> Brick
Wall	-> Brick
Wall	-> Larry
mouse	-> mickey
EOM
Smith	-> John
Wall	-> Larry
Wall	-> Brick
Wall	-> Brick
mouse	-> mickey
EOM


  {
    my $redirect = new Redirect $file ;

    # BTREE example 4
    ###

    use warnings FATAL => qw(all) ;
    use strict ;
    use DB_File ;
 
    use vars qw($filename $x %h ) ;

    $filename = "tree" ;
 
    # Enable duplicate records
    $DB_BTREE->{'flags'} = R_DUP ;
 
    $x = tie %h, "DB_File", $filename, O_RDWR|O_CREAT, 0640, $DB_BTREE 
	or die "Cannot open $filename: $!\n";
 
    my $cnt  = $x->get_dup("Wall") ;
    print "Wall occurred $cnt times\n" ;

    my %hash = $x->get_dup("Wall", 1) ;
    print "Larry is there\n" if $hash{'Larry'} ;
    print "There are $hash{'Brick'} Brick Walls\n" ;

    my @@list = sort $x->get_dup("Wall") ;
    print "Wall =>	[@@list]\n" ;

    @@list = $x->get_dup("Smith") ;
    print "Smith =>	[@@list]\n" ;
 
    @@list = $x->get_dup("Dog") ;
    print "Dog =>	[@@list]\n" ; 
 
    undef $x ;
    untie %h ;
  }

  ok(152, docat_del($file) eq <<'EOM') ;
Wall occurred 3 times
Larry is there
There are 2 Brick Walls
Wall =>	[Brick Brick Larry]
Smith =>	[John]
Dog =>	[]
EOM

  {
    my $redirect = new Redirect $file ;

    # BTREE example 5
    ###

    use warnings FATAL => qw(all) ;
    use strict ;
    use DB_File ;
 
    use vars qw($filename $x %h $found) ;

    my $filename = "tree" ;
 
    # Enable duplicate records
    $DB_BTREE->{'flags'} = R_DUP ;
 
    $x = tie %h, "DB_File", $filename, O_RDWR|O_CREAT, 0640, $DB_BTREE 
	or die "Cannot open $filename: $!\n";

    $found = ( $x->find_dup("Wall", "Larry") == 0 ? "" : "not") ; 
    print "Larry Wall is $found there\n" ;
    
    $found = ( $x->find_dup("Wall", "Harry") == 0 ? "" : "not") ; 
    print "Harry Wall is $found there\n" ;
    
    undef $x ;
    untie %h ;
  }

  ok(153, docat_del($file) eq <<'EOM') ;
Larry Wall is  there
Harry Wall is not there
EOM

  {
    my $redirect = new Redirect $file ;

    # BTREE example 6
    ###

    use warnings FATAL => qw(all) ;
    use strict ;
    use DB_File ;
 
    use vars qw($filename $x %h $found) ;

    my $filename = "tree" ;
 
    # Enable duplicate records
    $DB_BTREE->{'flags'} = R_DUP ;
 
    $x = tie %h, "DB_File", $filename, O_RDWR|O_CREAT, 0640, $DB_BTREE 
	or die "Cannot open $filename: $!\n";

    $x->del_dup("Wall", "Larry") ;

    $found = ( $x->find_dup("Wall", "Larry") == 0 ? "" : "not") ; 
    print "Larry Wall is $found there\n" ;
    
    undef $x ;
    untie %h ;

    unlink $filename ;
  }

  ok(154, docat_del($file) eq <<'EOM') ;
Larry Wall is not there
EOM

  {
    my $redirect = new Redirect $file ;

    # BTREE example 7
    ###

    use warnings FATAL => qw(all) ;
    use strict ;
    use DB_File ;
    use Fcntl ;

    use vars qw($filename $x %h $st $key $value) ;

    sub match
    {
        my $key = shift ;
        my $value = 0;
        my $orig_key = $key ;
        $x->seq($key, $value, R_CURSOR) ;
        print "$orig_key\t-> $key\t-> $value\n" ;
    }

    $filename = "tree" ;
    unlink $filename ;

    $x = tie %h, "DB_File", $filename, O_RDWR|O_CREAT, 0640, $DB_BTREE
        or die "Cannot open $filename: $!\n";
 
    # Add some key/value pairs to the file
    $h{'mouse'} = 'mickey' ;
    $h{'Wall'} = 'Larry' ;
    $h{'Walls'} = 'Brick' ; 
    $h{'Smith'} = 'John' ;
 

    $key = $value = 0 ;
    print "IN ORDER\n" ;
    for ($st = $x->seq($key, $value, R_FIRST) ;
	 $st == 0 ;
         $st = $x->seq($key, $value, R_NEXT) )
	
      {  print "$key	-> $value\n" }
 
    print "\nPARTIAL MATCH\n" ;

    match "Wa" ;
    match "A" ;
    match "a" ;

    undef $x ;
    untie %h ;

    unlink $filename ;

  }

  ok(155, docat_del($file) eq <<'EOM') ;
IN ORDER
Smith	-> John
Wall	-> Larry
Walls	-> Brick
mouse	-> mickey

PARTIAL MATCH
Wa	-> Wall	-> Larry
A	-> Smith	-> John
a	-> mouse	-> mickey
EOM

}

#{
#   # R_SETCURSOR
#   use strict ;
#   my (%h, $db) ;
#   unlink $Dfile;
#
#   ok(156, $db = tie(%h, 'DB_File', $Dfile, O_RDWR|O_CREAT, 0640, $DB_BTREE ) );
#
#   $h{abc} = 33 ;
#   my $k = "newest" ;
#   my $v = 44 ;
#   my $status = $db->put($k, $v, R_SETCURSOR) ;
#   print "status = [$status]\n" ;
#   ok(157, $status == 0) ;
#   $status = $db->del($k, R_CURSOR) ;
#   print "status = [$status]\n" ;
#   ok(158, $status == 0) ;
#   $k = "newest" ;
#   ok(159, $db->get($k, $v, R_CURSOR)) ;
#
#   ok(160, keys %h == 1) ;
#   
#   undef $db ;
#   untie %h;
#   unlink $Dfile;
#}

{
    # Bug ID 20001013.009
    #
    # test that $hash{KEY} = undef doesn't produce the warning
    #     Use of uninitialized value in null operation 
    use warnings ;
    use strict ;
    use DB_File ;

    unlink $Dfile;
    my %h ;
    my $a = "";
    local $SIG{__WARN__} = sub {$a = $_[0]} ;
    
    tie %h, 'DB_File', $Dfile, O_RDWR|O_CREAT, 0664, $DB_BTREE
	or die "Can't open file: $!\n" ;
    $h{ABC} = undef;
    ok(156, $a eq "") ;
    untie %h ;
    unlink $Dfile;
}

{
    # test that %hash = () doesn't produce the warning
    #     Argument "" isn't numeric in entersub
    use warnings ;
    use strict ;
    use DB_File ;

    unlink $Dfile;
    my %h ;
    my $a = "";
    local $SIG{__WARN__} = sub {$a = $_[0]} ;
    
    tie %h, 'DB_File', $Dfile, O_RDWR|O_CREAT, 0664, $DB_BTREE
	or die "Can't open file: $!\n" ;
    %h = (); ;
    ok(157, $a eq "") ;
    untie %h ;
    unlink $Dfile;
}

exit ;
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@@


1.4
log
@perl-5.6.0 + local changes
@
text
@d4 1
a4 1
    unshift @@INC, '../lib' if -d '../lib' ;
d12 2
d17 1
a17 1
print "1..155\n";
d87 3
a89 1
$db185mode =  ($DB_File::db_version == 1 && ! $DB_File::db_185_compat) ;
d135 1
a135 1
eval '$q = $dbh->{fred}' ;
d140 1
d143 1
a143 1
($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,
d147 1
d218 2
a219 2
@@keys = keys(%h);
@@values = values(%h);
d244 10
a253 3
#$h{''} = 'bar';
#ok(32, $h{''} eq 'bar' );
ok(32,1) ;
d256 1
a256 1
$ok = 1;
d266 1
a266 1
@@foo = @@h{0..200};
d275 1
a275 1
$status = $X->put( 'x', 'newvalue', R_NOOVERWRITE) ;
d296 6
a301 3
#$status = $X->del('') ;
#ok(42, $status == 0 );
ok(42,1) ;
d381 1
a381 1
$previous = $key ;
d430 1
d444 1
d490 8
a497 7
$Dfile1 = "btree1" ;
$Dfile2 = "btree2" ;
$Dfile3 = "btree3" ;
 
$dbh1 = new DB_File::BTREEINFO ;
{ local $^W = 0 ;
  $dbh1->{compare} = sub { $_[0] <=> $_[1] } ; }
d499 1
a499 1
$dbh2 = new DB_File::BTREEINFO ;
d502 1
a502 1
$dbh3 = new DB_File::BTREEINFO ;
d506 2
a507 1
tie(%h, 'DB_File',$Dfile1, O_RDWR|O_CREAT, 0640, $dbh1 ) ;
d511 6
a516 3
@@Keys = qw( 0123 12 -1234 9 987654321 def  ) ;
{ local $^W = 0 ;
  @@srt_1 = sort { $a <=> $b } @@Keys ; }
d521 1
a521 2
    { local $^W = 0 ; 
      $h{$_} = 1 ; }
d591 1
d599 1
d683 1
d790 1
d853 1
d882 1
d935 1
d987 1
d1043 1
d1092 1
d1127 1
d1162 1
d1253 42
@


1.3
log
@perl5.005_03 (stock)
@
text
@d4 1
a4 1
    @@INC = '../lib' if -d '../lib' ;
d7 1
a7 1
	print "1..0\n";
d15 1
a15 1
print "1..102\n";
d41 47
a87 1
$Dfile = "dbbtree.tmp";
a182 1

d656 563
@


1.2
log
@perl 5.004_04
@
text
@d94 1
a94 1
ok(20, ($mode & 0777) == (($^O eq 'os2' || $^O eq 'MSWin32') ? 0666 : 0640) || $^O eq 'amigaos');
d193 3
a195 2
$h{''} = 'bar';
ok(32, $h{''} eq 'bar' );
d238 3
a240 2
$status = $X->del('') ;
ok(42, $status == 0 );
d313 2
a314 1
ok(65, $status == 1 );
a518 1

d578 1
a578 1
    BEGIN { push @@INC, '.'; }
d606 2
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
#!./perl
d4 1
a4 1
    @@INC = '../lib';
d15 1
a15 1
print "1..76\n";
d17 25
a41 1
$Dfile = "Op.db-btree";
d48 9
a56 9
$dbh = TIEHASH DB_File::BTREEINFO ;
print (($dbh->{flags} == undef) ? "ok 1\n" : "not ok 1\n") ;
print (($dbh->{cachesize} == undef) ? "ok 2\n" : "not ok 2\n") ;
print (($dbh->{psize} == undef) ? "ok 3\n" : "not ok 3\n") ;
print (($dbh->{lorder} == undef) ? "ok 4\n" : "not ok 4\n") ;
print (($dbh->{minkeypage} == undef) ? "ok 5\n" : "not ok 5\n") ;
print (($dbh->{maxkeypage} == undef) ? "ok 6\n" : "not ok 6\n") ;
print (($dbh->{compare} == undef) ? "ok 7\n" : "not ok 7\n") ;
print (($dbh->{prefix} == undef) ? "ok 8\n" : "not ok 8\n") ;
d59 1
a59 1
print ($dbh->{flags} == 3000 ? "ok 9\n" : "not ok 9\n") ;
d62 2
a63 2
print ($dbh->{cachesize} == 9000 ? "ok 10\n" : "not ok 10\n") ;
#
d65 1
a65 1
print (($dbh->{psize} == 400) ? "ok 11\n" : "not ok 11\n") ;
d68 1
a68 1
print (($dbh->{lorder} == 65) ? "ok 12\n" : "not ok 12\n") ;
d71 1
a71 1
print (($dbh->{minkeypage} == 123) ? "ok 13\n" : "not ok 13\n") ;
d74 1
a74 1
print ($dbh->{maxkeypage} == 1234 ? "ok 14\n" : "not ok 14\n") ;
d77 1
a77 1
print ($dbh->{compare} == 1234 ? "ok 15\n" : "not ok 15\n") ;
d80 1
a80 1
print ($dbh->{prefix} == 1234 ? "ok 16\n" : "not ok 16\n") ;
d84 1
a84 1
print ($@@ eq '' ? "ok 17\n" : "not ok 17\n") ;
d86 1
a86 1
print ($@@ eq '' ? "ok 18\n" : "not ok 18\n") ;
d90 1
a90 1
print (($X = tie(%h, DB_File,$Dfile, O_RDWR|O_CREAT, 0640, $DB_BTREE )) ? "ok 19\n" : "not ok 19");
d94 1
a94 1
print (($mode & 0777) == 0640 ? "ok 20\n" : "not ok 20\n");
d99 1
a99 1
print (!$i ? "ok 21\n" : "not ok 21\n");
d104 4
a107 2
print ($h{'abc'} == 'ABC' ? "ok 22\n" : "not ok 22\n") ;
print (defined $h{'jimmy'} ? "not ok 23\n" : "ok 23\n");
d139 1
a139 1
print (($X = tie(%h,DB_File,$Dfile, O_RDWR, 0640, $DB_BTREE)) ? "ok 24\n" : "not ok 24\n");
d170 1
a170 1
if ($#keys == 29 && $#values == 29) {print "ok 25\n";} else {print "not ok 25\n";}
d172 1
d174 1
a174 1
    if ($key eq $keys[$i] && $value eq $values[$i] && $key gt $value) {
d180 1
a180 1
if ($i == 30) {print "ok 26\n";} else {print "not ok 26\n";}
d182 2
a183 2
@@keys = ('blurfl', keys(h), 'dyick');
if ($#keys == 31) {print "ok 27\n";} else {print "not ok 27\n";}
d186 3
a188 7
$ok = 1 ;
foreach (keys %h)
{
    ($ok = 0), last if defined $previous && $previous gt $_ ;
    $previous = $_ ;
}
print ($ok ? "ok 28\n" : "not ok 28\n") ;
d191 1
a191 1
print ($h{'foo'} eq '' ? "ok 29\n" : "not ok 29\n") ;
d194 1
a194 1
print ($h{''} eq 'bar' ? "ok 30\n" : "not ok 30\n") ;
d200 1
a200 1
print ($ok ? "ok 31\n" : "not ok 31\n");
d204 1
a204 1
print ($size > 0 ? "ok 32\n" : "not ok 32\n");
d208 1
a208 1
print join(':',200..400) eq join(':',@@foo) ? "ok 33\n" : "not ok 33\n";
d217 1
a217 1
print ($status == 1 ? "ok 34\n" : "not ok 34\n") ;
d221 1
a221 1
print ($h{'x'} eq 'X' ? "ok 35\n" : "not ok 35\n") ;
d225 1
a225 1
print ($status == 0 ? "ok 36\n" : "not ok 36\n") ;
d228 1
d230 2
a231 2
print ($status == 0 ? "ok 37\n" : "not ok 37\n") ;
print ($value eq 'value' ? "ok 38\n" : "not ok 38\n") ;
d236 1
a236 1
print ($status == 0 ? "ok 39\n" : "not ok 39\n") ;
d238 1
a238 1
print ($status == 0 ? "ok 40\n" : "not ok 40\n") ;
d241 2
a242 2
print (($h{'q'} eq undef) ? "ok 41\n" : "not ok 41\n") ;
print (($h{''} eq undef) ? "ok 42\n" : "not ok 42\n") ;
d247 1
a247 1
print (($X = tie(%h, DB_File,$Dfile, O_RDWR, 0640, $DB_BTREE )) ? "ok 43\n" : "not ok 43");
d252 1
a252 1
print ($status == 1 ? "ok 44\n" : "not ok 44\n") ;
d258 1
a258 1
print ($status == 1 ? "ok 45\n" : "not ok 45\n") ;
d262 2
a263 2
print ($status == 0 ? "ok 46\n" : "not ok 46\n") ;
print ($value eq 'A' ? "ok 47\n" : "not ok 47\n") ;
d272 3
a274 3
print ($status == 0 ? "ok 48\n" : "not ok 48\n") ;
print ($key eq 'key' ? "ok 49\n" : "not ok 49\n") ;
print ($value eq 'value' ? "ok 50\n" : "not ok 50\n") ;
d280 1
a280 1
print ($status == 1 ? "ok 51\n" : "not ok 51\n") ;
d288 3
a290 3
print ($status == 0 ? "ok 52\n" : "not ok 52\n") ;
print ($key eq 'x' ? "ok 53\n" : "not ok 53\n") ;
print ($value eq 'X' ? "ok 54\n" : "not ok 54\n") ;
d292 1
a292 1
print ($status == 0 ? "ok 55\n" : "not ok 55\n") ;
d294 1
a294 1
print ($status == 1 ? "ok 56\n" : "not ok 56\n") ;
d300 3
a302 3
print ($status == 0 ? "ok 57\n" : "not ok 57\n") ;
print ($key eq 'y' ? "ok 58\n" : "not ok 58\n") ;
print ($value eq 'Y' ? "ok 59\n" : "not ok 59\n") ;
d307 3
a309 3
print ($status == 0 ? "ok 60\n" : "not ok 60\n") ;
print ($key eq 'replace key' ? "ok 61\n" : "not ok 61\n") ;
print ($value eq 'replace value' ? "ok 62\n" : "not ok 62\n") ;
d311 1
a311 1
print ($status == 1 ? "ok 63\n" : "not ok 63\n") ;
d316 1
a316 1
print ($status == 0 ? "ok 64\n" : "not ok 64\n") ;
d325 2
a326 2
print ($status == 1 ? "ok 65\n" : "not ok 65\n") ;
print ($ok == 1 ? "ok 66\n" : "not ok 66\n") ;
d330 1
a330 1
print ($status == 0 ? "ok 67\n" : "not ok 67\n") ;
d340 2
a341 2
print ($status == 1 ? "ok 68\n" : "not ok 68\n") ;
print ($ok == 1 ? "ok 69\n" : "not ok 69\n") ;
d350 1
a350 1
print ($status == 0 ? "ok 70\n" : "not ok 70\n") ;
d357 1
a357 1
print ($status != 0 ? "ok 71\n" : "not ok 71\n") ;
d366 1
a366 1
print (($Y = tie(%h, DB_File,undef, O_RDWR|O_CREAT, 0640, $DB_BTREE )) ? "ok 72\n" : "not ok 72");
d370 2
a371 1
print ($status == -1 ? "ok 73\n" : "not ok 73\n") ;
d376 47
d428 3
a430 2
$dbh1 = TIEHASH DB_File::BTREEINFO ;
$dbh1->{compare} = sub { $_[0] <=> $_[1] } ;
d432 1
a432 1
$dbh2 = TIEHASH DB_File::BTREEINFO ;
d435 1
a435 1
$dbh3 = TIEHASH DB_File::BTREEINFO ;
d439 3
a441 3
tie(%h, DB_File,$Dfile1, O_RDWR|O_CREAT, 0640, $dbh1 ) ;
tie(%g, DB_File,$Dfile2, O_RDWR|O_CREAT, 0640, $dbh2 ) ;
tie(%k, DB_File,$Dfile3, O_RDWR|O_CREAT, 0640, $dbh3 ) ;
d444 2
a445 1
@@srt_1 = sort { $a <=> $b } @@Keys ;
d450 2
a451 1
    $h{$_} = 1 ;
d470 3
a472 3
print ( ArrayCompare (\@@srt_1, [keys %h]) ? "ok 74\n" : "not ok 74\n") ;
print ( ArrayCompare (\@@srt_2, [keys %g]) ? "ok 75\n" : "not ok 75\n") ;
print ( ArrayCompare (\@@srt_3, [keys %k]) ? "ok 76\n" : "not ok 76\n") ;
d478 129
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d1 1
a1 1
#!./perl -w
d4 1
a4 1
    @@INC = '../lib' if -d '../lib' ;
d15 1
a15 1
print "1..102\n";
d17 1
a17 25
sub ok
{
    my $no = shift ;
    my $result = shift ;
 
    print "not " unless $result ;
    print "ok $no\n" ;
}

sub lexical
{
    my(@@a) = unpack ("C*", $a) ;
    my(@@b) = unpack ("C*", $b) ;

    my $len = (@@a > @@b ? @@b : @@a) ;
    my $i = 0 ;

    foreach $i ( 0 .. $len -1) {
        return $a[$i] - $b[$i] if $a[$i] != $b[$i] ;
    }

    return @@a - @@b ;
}

$Dfile = "dbbtree.tmp";
d24 9
a32 9
my $dbh = new DB_File::BTREEINFO ;
ok(1, ! defined $dbh->{flags}) ;
ok(2, ! defined $dbh->{cachesize}) ;
ok(3, ! defined $dbh->{psize}) ;
ok(4, ! defined $dbh->{lorder}) ;
ok(5, ! defined $dbh->{minkeypage}) ;
ok(6, ! defined $dbh->{maxkeypage}) ;
ok(7, ! defined $dbh->{compare}) ;
ok(8, ! defined $dbh->{prefix}) ;
d35 1
a35 1
ok(9, $dbh->{flags} == 3000) ;
d38 2
a39 2
ok(10, $dbh->{cachesize} == 9000);

d41 1
a41 1
ok(11, $dbh->{psize} == 400) ;
d44 1
a44 1
ok(12, $dbh->{lorder} == 65) ;
d47 1
a47 1
ok(13, $dbh->{minkeypage} == 123) ;
d50 1
a50 1
ok(14, $dbh->{maxkeypage} == 1234 );
d53 1
a53 1
ok(15, $dbh->{compare} == 1234) ;
d56 1
a56 1
ok(16, $dbh->{prefix} == 1234 );
d60 1
a60 1
ok(17, $@@ =~ /^DB_File::BTREEINFO::STORE - Unknown element 'fred' at/ ) ;
d62 1
a62 1
ok(18, $@@ =~ /^DB_File::BTREEINFO::FETCH - Unknown element 'fred' at/ ) ;
d66 1
a66 1
ok(19, $X = tie(%h, 'DB_File',$Dfile, O_RDWR|O_CREAT, 0640, $DB_BTREE )) ;
d70 1
a70 1
ok(20, ($mode & 0777) == ($^O eq 'os2' ? 0666 : 0640) || $^O eq 'amigaos' || $^O eq 'MSWin32');
d75 1
a75 1
ok(21, !$i ) ;
d80 2
a81 4
ok(22, $h{'abc'} eq 'ABC' );
ok(23, ! defined $h{'jimmy'} ) ;
ok(24, ! exists $h{'jimmy'} ) ;
ok(25,  defined $h{'abc'} ) ;
d113 1
a113 1
ok(26, $X = tie(%h,'DB_File',$Dfile, O_RDWR, 0640, $DB_BTREE)) ;
d144 1
a144 1
ok(27, $#keys == 29 && $#values == 29) ;
a145 1
$i = 0 ;
d147 1
a147 1
    if ($key eq $keys[$i] && $value eq $values[$i] && $key eq lc($value)) {
d153 1
a153 1
ok(28, $i == 30) ;
d155 2
a156 2
@@keys = ('blurfl', keys(%h), 'dyick');
ok(29, $#keys == 31) ;
d159 7
a165 3
my @@b = keys %h ;
my @@c = sort lexical @@b ;
ok(30, ArrayCompare(\@@b, \@@c)) ;
d168 1
a168 1
ok(31, $h{'foo'} eq '' ) ;
d170 2
a171 3
#$h{''} = 'bar';
#ok(32, $h{''} eq 'bar' );
ok(32,1) ;
d177 1
a177 1
ok(33, $ok);
d181 1
a181 1
ok(34, $size > 0 );
d185 1
a185 1
ok(35, join(':',200..400) eq join(':',@@foo) );
d194 1
a194 1
ok(36, $status == 1 );
d198 1
a198 1
ok(37, $h{'x'} eq 'X' );
d202 1
a202 1
ok(38, $status == 0 );
a204 1
$value = 0 ;
d206 2
a207 2
ok(39, $status == 0 );
ok(40, $value eq 'value' );
d212 3
a214 4
ok(41, $status == 0 );
#$status = $X->del('') ;
#ok(42, $status == 0 );
ok(42,1) ;
d217 2
a218 2
ok(43, ! defined $h{'q'}) ;
ok(44, ! defined $h{''}) ;
d223 1
a223 1
ok(45, $X = tie(%h, 'DB_File',$Dfile, O_RDWR, 0640, $DB_BTREE ));
d228 1
a228 1
ok(46, $status == 1 );
d234 1
a234 1
ok(47, $status == 1 );
d238 2
a239 2
ok(48, $status == 0 );
ok(49, $value eq 'A' );
d248 3
a250 3
ok(50, $status == 0 );
ok(51, $key eq 'key' );
ok(52, $value eq 'value' );
d256 1
a256 1
ok(53, $status == 1 );
d264 3
a266 3
ok(54, $status == 0 );
ok(55, $key eq 'x' );
ok(56, $value eq 'X' );
d268 1
a268 1
ok(57, $status == 0 );
d270 1
a270 1
ok(58, $status == 1 );
d276 3
a278 3
ok(59, $status == 0 );
ok(60, $key eq 'y' );
ok(61, $value eq 'Y' );
d283 3
a285 3
ok(62, $status == 0 );
ok(63, $key eq 'replace key' );
ok(64, $value eq 'replace value' );
d287 1
a287 2
ok(65, 1) ; # hard-wire to always pass. the previous test ($status == 1)
	    # only worked because of a bug in 1.85/6
d292 1
a292 1
ok(66, $status == 0 );
d301 2
a302 2
ok(67, $status == 1 );
ok(68, $ok == 1 );
d306 1
a306 1
ok(69, $status == 0 );
d316 2
a317 2
ok(70, $status == 1 );
ok(71, $ok == 1 );
d326 1
a326 1
ok(72, $status == 0 );
d333 1
a333 1
ok(73, $status != 0 );
d342 1
a342 1
ok(74, $Y = tie(%h, 'DB_File',undef, O_RDWR|O_CREAT, 0640, $DB_BTREE ));
d346 1
a346 2
ok(75, $status == -1 );

a350 47
# Duplicate keys
my $bt = new DB_File::BTREEINFO ;
$bt->{flags} = R_DUP ;
ok(76, $YY = tie(%hh, 'DB_File', $Dfile, O_RDWR|O_CREAT, 0640, $bt )) ;

$hh{'Wall'} = 'Larry' ;
$hh{'Wall'} = 'Stone' ; # Note the duplicate key
$hh{'Wall'} = 'Brick' ; # Note the duplicate key
$hh{'Wall'} = 'Brick' ; # Note the duplicate key and value
$hh{'Smith'} = 'John' ;
$hh{'mouse'} = 'mickey' ;

# first work in scalar context
ok(77, scalar $YY->get_dup('Unknown') == 0 );
ok(78, scalar $YY->get_dup('Smith') == 1 );
ok(79, scalar $YY->get_dup('Wall') == 4 );

# now in list context
my @@unknown = $YY->get_dup('Unknown') ;
ok(80, "@@unknown" eq "" );

my @@smith = $YY->get_dup('Smith') ;
ok(81, "@@smith" eq "John" );

{
my @@wall = $YY->get_dup('Wall') ;
my %wall ;
@@wall{@@wall} = @@wall ;
ok(82, (@@wall == 4 && $wall{'Larry'} && $wall{'Stone'} && $wall{'Brick'}) );
}

# hash
my %unknown = $YY->get_dup('Unknown', 1) ;
ok(83, keys %unknown == 0 );

my %smith = $YY->get_dup('Smith', 1) ;
ok(84, keys %smith == 1 && $smith{'John'}) ;

my %wall = $YY->get_dup('Wall', 1) ;
ok(85, keys %wall == 3 && $wall{'Larry'} == 1 && $wall{'Stone'} == 1 
		&& $wall{'Brick'} == 2);

undef $YY ;
untie %hh ;
unlink $Dfile;


d356 2
a357 3
$dbh1 = new DB_File::BTREEINFO ;
{ local $^W = 0 ;
  $dbh1->{compare} = sub { $_[0] <=> $_[1] } ; }
d359 1
a359 1
$dbh2 = new DB_File::BTREEINFO ;
d362 1
a362 1
$dbh3 = new DB_File::BTREEINFO ;
d366 3
a368 3
tie(%h, 'DB_File',$Dfile1, O_RDWR|O_CREAT, 0640, $dbh1 ) ;
tie(%g, 'DB_File',$Dfile2, O_RDWR|O_CREAT, 0640, $dbh2 ) ;
tie(%k, 'DB_File',$Dfile3, O_RDWR|O_CREAT, 0640, $dbh3 ) ;
d371 1
a371 2
{ local $^W = 0 ;
  @@srt_1 = sort { $a <=> $b } @@Keys ; }
d376 1
a376 2
    { local $^W = 0 ; 
      $h{$_} = 1 ; }
d395 3
a397 3
ok(86, ArrayCompare (\@@srt_1, [keys %h]) );
ok(87, ArrayCompare (\@@srt_2, [keys %g]) );
ok(88, ArrayCompare (\@@srt_3, [keys %k]) );
a402 130

# clear
# #####

ok(89, tie(%h, 'DB_File', $Dfile1, O_RDWR|O_CREAT, 0640, $DB_BTREE ) );
foreach (1 .. 10)
  { $h{$_} = $_ * 100 }

# check that there are 10 elements in the hash
$i = 0 ;
while (($key,$value) = each(%h)) {
    $i++;
}
ok(90, $i == 10);

# now clear the hash
%h = () ;

# check it is empty
$i = 0 ;
while (($key,$value) = each(%h)) {
    $i++;
}
ok(91, $i == 0);

untie %h ;
unlink $Dfile1 ;

{
    # check that attempting to tie an array to a DB_BTREE will fail

    my $filename = "xyz" ;
    my @@x ;
    eval { tie @@x, 'DB_File', $filename, O_RDWR|O_CREAT, 0640, $DB_BTREE ; } ;
    ok(92, $@@ =~ /^DB_File can only tie an associative array to a DB_BTREE database/) ;
    unlink $filename ;
}

{
   # sub-class test

   package Another ;

   use strict ;

   open(FILE, ">SubDB.pm") or die "Cannot open SubDB.pm: $!\n" ;
   print FILE <<'EOM' ;

   package SubDB ;

   use strict ;
   use vars qw( @@ISA @@EXPORT) ;

   require Exporter ;
   use DB_File;
   @@ISA=qw(DB_File);
   @@EXPORT = @@DB_File::EXPORT ;

   sub STORE { 
	my $self = shift ;
        my $key = shift ;
        my $value = shift ;
        $self->SUPER::STORE($key, $value * 2) ;
   }

   sub FETCH { 
	my $self = shift ;
        my $key = shift ;
        $self->SUPER::FETCH($key) - 1 ;
   }

   sub put { 
	my $self = shift ;
        my $key = shift ;
        my $value = shift ;
        $self->SUPER::put($key, $value * 3) ;
   }

   sub get { 
	my $self = shift ;
        $self->SUPER::get($_[0], $_[1]) ;
	$_[1] -= 2 ;
   }

   sub A_new_method
   {
	my $self = shift ;
        my $key = shift ;
        my $value = $self->FETCH($key) ;
	return "[[$value]]" ;
   }

   1 ;
EOM

    close FILE ;

    BEGIN { push @@INC, '.'; }    
    eval 'use SubDB ; ';
    main::ok(93, $@@ eq "") ;
    my %h ;
    my $X ;
    eval '
	$X = tie(%h, "SubDB","dbbtree.tmp", O_RDWR|O_CREAT, 0640, $DB_BTREE );
	' ;

    main::ok(94, $@@ eq "") ;

    my $ret = eval '$h{"fred"} = 3 ; return $h{"fred"} ' ;
    main::ok(95, $@@ eq "") ;
    main::ok(96, $ret == 5) ;

    my $value = 0;
    $ret = eval '$X->put("joe", 4) ; $X->get("joe", $value) ; return $value' ;
    main::ok(97, $@@ eq "") ;
    main::ok(98, $ret == 10) ;

    $ret = eval ' R_NEXT eq main::R_NEXT ' ;
    main::ok(99, $@@ eq "" ) ;
    main::ok(100, $ret == 1) ;

    $ret = eval '$X->A_new_method("joe") ' ;
    main::ok(101, $@@ eq "") ;
    main::ok(102, $ret eq "[[11]]") ;

    undef $X;
    untie(%h);
    unlink "SubDB.pm", "dbbtree.tmp" ;

}
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d4 1
a4 1
    unshift @@INC, '../lib' if -d '../lib' ;
d7 1
a7 1
	print "1..0 # Skip: DB_File was not built\n";
d15 1
a15 1
print "1..155\n";
d41 1
a41 47
{
    package Redirect ;
    use Symbol ;

    sub new
    {
        my $class = shift ;
        my $filename = shift ;
	my $fh = gensym ;
	open ($fh, ">$filename") || die "Cannot open $filename: $!" ;
	my $real_stdout = select($fh) ;
	return bless [$fh, $real_stdout ] ;

    }
    sub DESTROY
    {
        my $self = shift ;
	close $self->[0] ;
	select($self->[1]) ;
    }
}

sub docat
{ 
    my $file = shift;
    #local $/ = undef unless wantarray ;
    open(CAT,$file) || die "Cannot open $file: $!";
    my @@result = <CAT>;
    close(CAT);
    wantarray ? @@result : join("", @@result) ;
}   

sub docat_del
{ 
    my $file = shift;
    #local $/ = undef unless wantarray ;
    open(CAT,$file) || die "Cannot open $file: $!";
    my @@result = <CAT>;
    close(CAT);
    unlink $file ;
    wantarray ? @@result : join("", @@result) ;
}   


$db185mode =  ($DB_File::db_version == 1 && ! $DB_File::db_185_compat) ;

my $Dfile = "dbbtree.tmp";
d137 1
a610 563

{
   # DBM Filter tests
   use strict ;
   my (%h, $db) ;
   my ($fetch_key, $store_key, $fetch_value, $store_value) = ("") x 4 ;
   unlink $Dfile;

   sub checkOutput
   {
       my($fk, $sk, $fv, $sv) = @@_ ;
       return
           $fetch_key eq $fk && $store_key eq $sk && 
	   $fetch_value eq $fv && $store_value eq $sv &&
	   $_ eq 'original' ;
   }
   
   ok(103, $db = tie(%h, 'DB_File', $Dfile, O_RDWR|O_CREAT, 0640, $DB_BTREE ) );

   $db->filter_fetch_key   (sub { $fetch_key = $_ }) ;
   $db->filter_store_key   (sub { $store_key = $_ }) ;
   $db->filter_fetch_value (sub { $fetch_value = $_}) ;
   $db->filter_store_value (sub { $store_value = $_ }) ;

   $_ = "original" ;

   $h{"fred"} = "joe" ;
   #                   fk   sk     fv   sv
   ok(104, checkOutput( "", "fred", "", "joe")) ;

   ($fetch_key, $store_key, $fetch_value, $store_value) = ("") x 4 ;
   ok(105, $h{"fred"} eq "joe");
   #                   fk    sk     fv    sv
   ok(106, checkOutput( "", "fred", "joe", "")) ;

   ($fetch_key, $store_key, $fetch_value, $store_value) = ("") x 4 ;
   ok(107, $db->FIRSTKEY() eq "fred") ;
   #                    fk     sk  fv  sv
   ok(108, checkOutput( "fred", "", "", "")) ;

   # replace the filters, but remember the previous set
   my ($old_fk) = $db->filter_fetch_key   
   			(sub { $_ = uc $_ ; $fetch_key = $_ }) ;
   my ($old_sk) = $db->filter_store_key   
   			(sub { $_ = lc $_ ; $store_key = $_ }) ;
   my ($old_fv) = $db->filter_fetch_value 
   			(sub { $_ = "[$_]"; $fetch_value = $_ }) ;
   my ($old_sv) = $db->filter_store_value 
   			(sub { s/o/x/g; $store_value = $_ }) ;
   
   ($fetch_key, $store_key, $fetch_value, $store_value) = ("") x 4 ;
   $h{"Fred"} = "Joe" ;
   #                   fk   sk     fv    sv
   ok(109, checkOutput( "", "fred", "", "Jxe")) ;

   ($fetch_key, $store_key, $fetch_value, $store_value) = ("") x 4 ;
   ok(110, $h{"Fred"} eq "[Jxe]");
   #                   fk   sk     fv    sv
   ok(111, checkOutput( "", "fred", "[Jxe]", "")) ;

   ($fetch_key, $store_key, $fetch_value, $store_value) = ("") x 4 ;
   ok(112, $db->FIRSTKEY() eq "FRED") ;
   #                   fk   sk     fv    sv
   ok(113, checkOutput( "FRED", "", "", "")) ;

   # put the original filters back
   $db->filter_fetch_key   ($old_fk);
   $db->filter_store_key   ($old_sk);
   $db->filter_fetch_value ($old_fv);
   $db->filter_store_value ($old_sv);

   ($fetch_key, $store_key, $fetch_value, $store_value) = ("") x 4 ;
   $h{"fred"} = "joe" ;
   ok(114, checkOutput( "", "fred", "", "joe")) ;

   ($fetch_key, $store_key, $fetch_value, $store_value) = ("") x 4 ;
   ok(115, $h{"fred"} eq "joe");
   ok(116, checkOutput( "", "fred", "joe", "")) ;

   ($fetch_key, $store_key, $fetch_value, $store_value) = ("") x 4 ;
   ok(117, $db->FIRSTKEY() eq "fred") ;
   ok(118, checkOutput( "fred", "", "", "")) ;

   # delete the filters
   $db->filter_fetch_key   (undef);
   $db->filter_store_key   (undef);
   $db->filter_fetch_value (undef);
   $db->filter_store_value (undef);

   ($fetch_key, $store_key, $fetch_value, $store_value) = ("") x 4 ;
   $h{"fred"} = "joe" ;
   ok(119, checkOutput( "", "", "", "")) ;

   ($fetch_key, $store_key, $fetch_value, $store_value) = ("") x 4 ;
   ok(120, $h{"fred"} eq "joe");
   ok(121, checkOutput( "", "", "", "")) ;

   ($fetch_key, $store_key, $fetch_value, $store_value) = ("") x 4 ;
   ok(122, $db->FIRSTKEY() eq "fred") ;
   ok(123, checkOutput( "", "", "", "")) ;

   undef $db ;
   untie %h;
   unlink $Dfile;
}

{    
    # DBM Filter with a closure

    use strict ;
    my (%h, $db) ;

    unlink $Dfile;
    ok(124, $db = tie(%h, 'DB_File', $Dfile, O_RDWR|O_CREAT, 0640, $DB_BTREE ) );

    my %result = () ;

    sub Closure
    {
        my ($name) = @@_ ;
	my $count = 0 ;
	my @@kept = () ;

	return sub { ++$count ; 
		     push @@kept, $_ ; 
		     $result{$name} = "$name - $count: [@@kept]" ;
		   }
    }

    $db->filter_store_key(Closure("store key")) ;
    $db->filter_store_value(Closure("store value")) ;
    $db->filter_fetch_key(Closure("fetch key")) ;
    $db->filter_fetch_value(Closure("fetch value")) ;

    $_ = "original" ;

    $h{"fred"} = "joe" ;
    ok(125, $result{"store key"} eq "store key - 1: [fred]");
    ok(126, $result{"store value"} eq "store value - 1: [joe]");
    ok(127, ! defined $result{"fetch key"} );
    ok(128, ! defined $result{"fetch value"} );
    ok(129, $_ eq "original") ;

    ok(130, $db->FIRSTKEY() eq "fred") ;
    ok(131, $result{"store key"} eq "store key - 1: [fred]");
    ok(132, $result{"store value"} eq "store value - 1: [joe]");
    ok(133, $result{"fetch key"} eq "fetch key - 1: [fred]");
    ok(134, ! defined $result{"fetch value"} );
    ok(135, $_ eq "original") ;

    $h{"jim"}  = "john" ;
    ok(136, $result{"store key"} eq "store key - 2: [fred jim]");
    ok(137, $result{"store value"} eq "store value - 2: [joe john]");
    ok(138, $result{"fetch key"} eq "fetch key - 1: [fred]");
    ok(139, ! defined $result{"fetch value"} );
    ok(140, $_ eq "original") ;

    ok(141, $h{"fred"} eq "joe");
    ok(142, $result{"store key"} eq "store key - 3: [fred jim fred]");
    ok(143, $result{"store value"} eq "store value - 2: [joe john]");
    ok(144, $result{"fetch key"} eq "fetch key - 1: [fred]");
    ok(145, $result{"fetch value"} eq "fetch value - 1: [joe]");
    ok(146, $_ eq "original") ;

    undef $db ;
    untie %h;
    unlink $Dfile;
}		

{
   # DBM Filter recursion detection
   use strict ;
   my (%h, $db) ;
   unlink $Dfile;

   ok(147, $db = tie(%h, 'DB_File', $Dfile, O_RDWR|O_CREAT, 0640, $DB_BTREE ) );

   $db->filter_store_key (sub { $_ = $h{$_} }) ;

   eval '$h{1} = 1234' ;
   ok(148, $@@ =~ /^recursion detected in filter_store_key at/ );
   
   undef $db ;
   untie %h;
   unlink $Dfile;
}


{
   # Examples from the POD


  my $file = "xyzt" ;
  {
    my $redirect = new Redirect $file ;

    # BTREE example 1
    ###

    use strict ;
    use DB_File ;

    my %h ;

    sub Compare
    {
        my ($key1, $key2) = @@_ ;
        "\L$key1" cmp "\L$key2" ;
    }

    # specify the Perl sub that will do the comparison
    $DB_BTREE->{'compare'} = \&Compare ;

    unlink "tree" ;
    tie %h, "DB_File", "tree", O_RDWR|O_CREAT, 0640, $DB_BTREE 
        or die "Cannot open file 'tree': $!\n" ;

    # Add a key/value pair to the file
    $h{'Wall'} = 'Larry' ;
    $h{'Smith'} = 'John' ;
    $h{'mouse'} = 'mickey' ;
    $h{'duck'}  = 'donald' ;

    # Delete
    delete $h{"duck"} ;

    # Cycle through the keys printing them in order.
    # Note it is not necessary to sort the keys as
    # the btree will have kept them in order automatically.
    foreach (keys %h)
      { print "$_\n" }

    untie %h ;

    unlink "tree" ;
  }  

  delete $DB_BTREE->{'compare'} ;

  ok(149, docat_del($file) eq <<'EOM') ;
mouse
Smith
Wall
EOM
   
  {
    my $redirect = new Redirect $file ;

    # BTREE example 2
    ###

    use strict ;
    use DB_File ;

    use vars qw($filename %h ) ;

    $filename = "tree" ;
    unlink $filename ;
 
    # Enable duplicate records
    $DB_BTREE->{'flags'} = R_DUP ;
 
    tie %h, "DB_File", $filename, O_RDWR|O_CREAT, 0640, $DB_BTREE 
	or die "Cannot open $filename: $!\n";
 
    # Add some key/value pairs to the file
    $h{'Wall'} = 'Larry' ;
    $h{'Wall'} = 'Brick' ; # Note the duplicate key
    $h{'Wall'} = 'Brick' ; # Note the duplicate key and value
    $h{'Smith'} = 'John' ;
    $h{'mouse'} = 'mickey' ;

    # iterate through the associative array
    # and print each key/value pair.
    foreach (keys %h)
      { print "$_	-> $h{$_}\n" }

    untie %h ;

    unlink $filename ;
  }  

  ok(150, docat_del($file) eq ($db185mode ? <<'EOM' : <<'EOM') ) ;
Smith	-> John
Wall	-> Brick
Wall	-> Brick
Wall	-> Brick
mouse	-> mickey
EOM
Smith	-> John
Wall	-> Larry
Wall	-> Larry
Wall	-> Larry
mouse	-> mickey
EOM

  {
    my $redirect = new Redirect $file ;

    # BTREE example 3
    ###

    use strict ;
    use DB_File ;
 
    use vars qw($filename $x %h $status $key $value) ;

    $filename = "tree" ;
    unlink $filename ;
 
    # Enable duplicate records
    $DB_BTREE->{'flags'} = R_DUP ;
 
    $x = tie %h, "DB_File", $filename, O_RDWR|O_CREAT, 0640, $DB_BTREE 
	or die "Cannot open $filename: $!\n";
 
    # Add some key/value pairs to the file
    $h{'Wall'} = 'Larry' ;
    $h{'Wall'} = 'Brick' ; # Note the duplicate key
    $h{'Wall'} = 'Brick' ; # Note the duplicate key and value
    $h{'Smith'} = 'John' ;
    $h{'mouse'} = 'mickey' ;
 
    # iterate through the btree using seq
    # and print each key/value pair.
    $key = $value = 0 ;
    for ($status = $x->seq($key, $value, R_FIRST) ;
         $status == 0 ;
         $status = $x->seq($key, $value, R_NEXT) )
      {  print "$key	-> $value\n" }
 
 
    undef $x ;
    untie %h ;
  }

  ok(151, docat_del($file) eq ($db185mode == 1 ? <<'EOM' : <<'EOM') ) ;
Smith	-> John
Wall	-> Brick
Wall	-> Brick
Wall	-> Larry
mouse	-> mickey
EOM
Smith	-> John
Wall	-> Larry
Wall	-> Brick
Wall	-> Brick
mouse	-> mickey
EOM


  {
    my $redirect = new Redirect $file ;

    # BTREE example 4
    ###

    use strict ;
    use DB_File ;
 
    use vars qw($filename $x %h ) ;

    $filename = "tree" ;
 
    # Enable duplicate records
    $DB_BTREE->{'flags'} = R_DUP ;
 
    $x = tie %h, "DB_File", $filename, O_RDWR|O_CREAT, 0640, $DB_BTREE 
	or die "Cannot open $filename: $!\n";
 
    my $cnt  = $x->get_dup("Wall") ;
    print "Wall occurred $cnt times\n" ;

    my %hash = $x->get_dup("Wall", 1) ;
    print "Larry is there\n" if $hash{'Larry'} ;
    print "There are $hash{'Brick'} Brick Walls\n" ;

    my @@list = sort $x->get_dup("Wall") ;
    print "Wall =>	[@@list]\n" ;

    @@list = $x->get_dup("Smith") ;
    print "Smith =>	[@@list]\n" ;
 
    @@list = $x->get_dup("Dog") ;
    print "Dog =>	[@@list]\n" ; 
 
    undef $x ;
    untie %h ;
  }

  ok(152, docat_del($file) eq <<'EOM') ;
Wall occurred 3 times
Larry is there
There are 2 Brick Walls
Wall =>	[Brick Brick Larry]
Smith =>	[John]
Dog =>	[]
EOM

  {
    my $redirect = new Redirect $file ;

    # BTREE example 5
    ###

    use strict ;
    use DB_File ;
 
    use vars qw($filename $x %h $found) ;

    my $filename = "tree" ;
 
    # Enable duplicate records
    $DB_BTREE->{'flags'} = R_DUP ;
 
    $x = tie %h, "DB_File", $filename, O_RDWR|O_CREAT, 0640, $DB_BTREE 
	or die "Cannot open $filename: $!\n";

    $found = ( $x->find_dup("Wall", "Larry") == 0 ? "" : "not") ; 
    print "Larry Wall is $found there\n" ;
    
    $found = ( $x->find_dup("Wall", "Harry") == 0 ? "" : "not") ; 
    print "Harry Wall is $found there\n" ;
    
    undef $x ;
    untie %h ;
  }

  ok(153, docat_del($file) eq <<'EOM') ;
Larry Wall is  there
Harry Wall is not there
EOM

  {
    my $redirect = new Redirect $file ;

    # BTREE example 6
    ###

    use strict ;
    use DB_File ;
 
    use vars qw($filename $x %h $found) ;

    my $filename = "tree" ;
 
    # Enable duplicate records
    $DB_BTREE->{'flags'} = R_DUP ;
 
    $x = tie %h, "DB_File", $filename, O_RDWR|O_CREAT, 0640, $DB_BTREE 
	or die "Cannot open $filename: $!\n";

    $x->del_dup("Wall", "Larry") ;

    $found = ( $x->find_dup("Wall", "Larry") == 0 ? "" : "not") ; 
    print "Larry Wall is $found there\n" ;
    
    undef $x ;
    untie %h ;

    unlink $filename ;
  }

  ok(154, docat_del($file) eq <<'EOM') ;
Larry Wall is not there
EOM

  {
    my $redirect = new Redirect $file ;

    # BTREE example 7
    ###

    use strict ;
    use DB_File ;
    use Fcntl ;

    use vars qw($filename $x %h $st $key $value) ;

    sub match
    {
        my $key = shift ;
        my $value = 0;
        my $orig_key = $key ;
        $x->seq($key, $value, R_CURSOR) ;
        print "$orig_key\t-> $key\t-> $value\n" ;
    }

    $filename = "tree" ;
    unlink $filename ;

    $x = tie %h, "DB_File", $filename, O_RDWR|O_CREAT, 0640, $DB_BTREE
        or die "Cannot open $filename: $!\n";
 
    # Add some key/value pairs to the file
    $h{'mouse'} = 'mickey' ;
    $h{'Wall'} = 'Larry' ;
    $h{'Walls'} = 'Brick' ; 
    $h{'Smith'} = 'John' ;
 

    $key = $value = 0 ;
    print "IN ORDER\n" ;
    for ($st = $x->seq($key, $value, R_FIRST) ;
	 $st == 0 ;
         $st = $x->seq($key, $value, R_NEXT) )
	
      {  print "$key	-> $value\n" }
 
    print "\nPARTIAL MATCH\n" ;

    match "Wa" ;
    match "A" ;
    match "a" ;

    undef $x ;
    untie %h ;

    unlink $filename ;

  }

  ok(155, docat_del($file) eq <<'EOM') ;
IN ORDER
Smith	-> John
Wall	-> Larry
Walls	-> Brick
mouse	-> mickey

PARTIAL MATCH
Wa	-> Wall	-> Larry
A	-> Smith	-> John
a	-> mouse	-> mickey
EOM

}

#{
#   # R_SETCURSOR
#   use strict ;
#   my (%h, $db) ;
#   unlink $Dfile;
#
#   ok(156, $db = tie(%h, 'DB_File', $Dfile, O_RDWR|O_CREAT, 0640, $DB_BTREE ) );
#
#   $h{abc} = 33 ;
#   my $k = "newest" ;
#   my $v = 44 ;
#   my $status = $db->put($k, $v, R_SETCURSOR) ;
#   print "status = [$status]\n" ;
#   ok(157, $status == 0) ;
#   $status = $db->del($k, R_CURSOR) ;
#   print "status = [$status]\n" ;
#   ok(158, $status == 0) ;
#   $k = "newest" ;
#   ok(159, $db->get($k, $v, R_CURSOR)) ;
#
#   ok(160, keys %h == 1) ;
#   
#   undef $db ;
#   untie %h;
#   unlink $Dfile;
#}
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d4 1
a4 1
    @@INC = '../lib';
a11 2
use warnings;
use strict;
d15 1
a15 1
print "1..157\n";
d85 1
a85 3
my $db185mode =  ($DB_File::db_version == 1 && ! $DB_File::db_185_compat) ;
my $null_keys_allowed = ($DB_File::db_ver < 2.004010 
				|| $DB_File::db_ver >= 3.1 );
d131 1
a131 1
eval 'my $q = $dbh->{fred}' ;
a135 1
my ($X, %h) ;
d138 1
a138 1
my ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,
a141 1
my ($key, $value, $i);
d212 2
a213 2
my @@keys = keys(%h);
my @@values = values(%h);
d238 3
a240 10
# Berkeley DB from version 2.4.10 to 3.0 does not allow null keys.
# This feature was reenabled in version 3.1 of Berkeley DB.
my $result = 0 ;
if ($null_keys_allowed) {
    $h{''} = 'bar';
    $result = ( $h{''} eq 'bar' );
}
else
  { $result = 1 }
ok(32, $result) ;
d243 1
a243 1
my $ok = 1;
d253 1
a253 1
my @@foo = @@h{0..200};
d262 1
a262 1
my $status = $X->put( 'x', 'newvalue', R_NOOVERWRITE) ;
d283 3
a285 6
if ($null_keys_allowed) {
    $status = $X->del('') ;
} else {
    $status = 0 ;
}
ok(42, $status == 0 );
d365 1
a365 1
my $previous = $key ;
a413 1
my $Y;
a426 1
my ($YY, %hh);
d472 7
a478 8
my $Dfile1 = "btree1" ;
my $Dfile2 = "btree2" ;
my $Dfile3 = "btree3" ;
 
my $dbh1 = new DB_File::BTREEINFO ;
$dbh1->{compare} = sub { 
	no warnings 'numeric' ;
	$_[0] <=> $_[1] } ; 
d480 1
a480 1
my $dbh2 = new DB_File::BTREEINFO ;
d483 1
a483 1
my $dbh3 = new DB_File::BTREEINFO ;
d487 1
a487 2
my (%g, %k);
tie(%h, 'DB_File',$Dfile1, O_RDWR|O_CREAT, 0640, $dbh1 ) ; 
d491 3
a493 6
my @@Keys = qw( 0123 12 -1234 9 987654321 def  ) ;
my (@@srt_1, @@srt_2, @@srt_3);
{ 
  no warnings 'numeric' ;
  @@srt_1 = sort { $a <=> $b } @@Keys ; 
}
d498 2
a499 1
    $h{$_} = 1 ;
a568 1
   use warnings ;
a575 1
   use warnings ;
a658 1
   use warnings ;
a764 1
    use warnings ;
a826 1
   use warnings ;
a854 1
    use warnings FATAL => qw(all) ;
a906 1
    use warnings FATAL => qw(all) ;
a957 1
    use warnings FATAL => qw(all) ;
a1012 1
    use warnings FATAL => qw(all) ;
a1060 1
    use warnings FATAL => qw(all) ;
a1094 1
    use warnings FATAL => qw(all) ;
a1128 1
    use warnings FATAL => qw(all) ;
a1218 42

{
    # Bug ID 20001013.009
    #
    # test that $hash{KEY} = undef doesn't produce the warning
    #     Use of uninitialized value in null operation 
    use warnings ;
    use strict ;
    use DB_File ;

    unlink $Dfile;
    my %h ;
    my $a = "";
    local $SIG{__WARN__} = sub {$a = $_[0]} ;
    
    tie %h, 'DB_File', $Dfile, O_RDWR|O_CREAT, 0664, $DB_BTREE
	or die "Can't open file: $!\n" ;
    $h{ABC} = undef;
    ok(156, $a eq "") ;
    untie %h ;
    unlink $Dfile;
}

{
    # test that %hash = () doesn't produce the warning
    #     Argument "" isn't numeric in entersub
    use warnings ;
    use strict ;
    use DB_File ;

    unlink $Dfile;
    my %h ;
    my $a = "";
    local $SIG{__WARN__} = sub {$a = $_[0]} ;
    
    tie %h, 'DB_File', $Dfile, O_RDWR|O_CREAT, 0664, $DB_BTREE
	or die "Can't open file: $!\n" ;
    %h = (); ;
    ok(157, $a eq "") ;
    untie %h ;
    unlink $Dfile;
}
@


