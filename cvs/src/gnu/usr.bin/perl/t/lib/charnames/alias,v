head	1.2;
access;
symbols
	OPENBSD_6_2:1.2.0.6
	OPENBSD_6_2_BASE:1.2
	PERL_5_24_2:1.1.1.3
	OPENBSD_6_1:1.2.0.4
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.2.0.12
	OPENBSD_6_0_BASE:1.1.1.2
	OPENBSD_5_9:1.1.1.2.0.6
	OPENBSD_5_9_BASE:1.1.1.2
	OPENBSD_5_8:1.1.1.2.0.8
	OPENBSD_5_8_BASE:1.1.1.2
	PERL_5_20_2:1.1.1.2
	OPENBSD_5_7:1.1.1.2.0.2
	OPENBSD_5_7_BASE:1.1.1.2
	PERL_5_20_1:1.1.1.2
	OPENBSD_5_6:1.1.1.2.0.4
	OPENBSD_5_6_BASE:1.1.1.2
	PERL_5_18_2:1.1.1.2
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.1.0.6
	OPENBSD_5_5_BASE:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.2
	OPENBSD_5_4_BASE:1.1.1.1
	PERL_5_16_3:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.32.20;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2013.03.25.20.09.34;	author sthen;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2013.03.25.20.09.34;	author sthen;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2014.03.24.14.59.09;	author afresh1;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2017.08.14.13.46.23;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@Tests for use charnames with compilation errors and aliases.
__END__
# NAME illegal :pragma
use warnings;
use charnames ":scoobydoo";
"Here: \N{e_ACUTE}!\n";
EXPECT
OPTIONS regex
unsupported special ':scoobydoo' in charnames at
########
# NAME autoload doesn't get vianame
print "Here: \N{DIGIT ONE}\n";
charnames::vianame("DIGIT TWO");
EXPECT
OPTIONS regex
Undefined subroutine &charnames::vianame called at - line \d+.
Here: 1
########
# NAME autoload doesn't get viacode
print "Here: \N{DIGIT THREE}\n";
charnames::viacode(utf8::unicode_to_native(0x34));
EXPECT
OPTIONS regex
Undefined subroutine &charnames::viacode called at - line \d+.
Here: 3
########
# NAME autoload doesn't get string_vianame
print "Here: \N{DIGIT FOUR}\n";
charnames::string_vianame("DIGIT FIVE");
EXPECT
OPTIONS regex
Undefined subroutine &charnames::string_vianame called at - line \d+.
Here: 4
########
# NAME wrong type of alias (missing colon)
no warnings;
use charnames "alias";
"Here: \N{e_ACUTE}!\n";
EXPECT
OPTIONS regex fatal
Unknown charname 'e_ACUTE' at - line \d+, within string
########
# NAME alias without an argument
use warnings;
use charnames ":alias";
"Here: \N{e_ACUTE}!\n";
EXPECT
OPTIONS regex
:alias needs an argument in charnames at
########
# NAME reversed sequence
use warnings;
use charnames ":alias" => ":full";
"Here: \N{e_ACUTE}!\n";
EXPECT
OPTIONS regex
:alias cannot use existing pragma :full \(reversed order\?\) at
########
# NAME alias with hashref but with :short
use warnings;
no warnings 'void';
use charnames ":short", ":alias" => { e_ACUTE => "LATIN SMALL LETTER E WITH ACUTE" };
"Here: \N{e_ACUTE}!\n";
EXPECT
OPTIONS regex fatal
Unknown charname 'e_ACUTE' at - line \d+, within string
########
# NAME alias with hashref to :full OK
use warnings;
no warnings 'void';
use charnames ":full", ":alias" => { e_ACUTE => "LATIN SMALL LETTER E WITH ACUTE" };
"Here: \N{e_ACUTE}!\n";
EXPECT
OPTIONS regex
$
########
# NAME alias with hashref to :loose OK
use warnings;
no warnings 'void';
use charnames ":loose", ":alias" => { e_ACUTE => "LATIN SMALL LETTER E WITH ACUTE" };
"Here: \N{e_ACUTE}!\n";
EXPECT
OPTIONS regex
$
########
# NAME alias with :loose requires :full type name
use warnings;
no warnings 'void';
use charnames ":loose", ":alias" => { e_ACUTE => "latin SMALL LETTER E WITH ACUTE" };
"Here: \N{e_ACUTE}!\n";
EXPECT
OPTIONS regex fatal
Unknown charname 'e_ACUTE' at - line \d+, within string
########
# NAME alias with hashref to :short but using :full
use warnings;
no warnings 'void';
use charnames ":full", ":alias" => { e_ACUTE => "LATIN:e WITH ACUTE" };
"Here: \N{e_ACUTE}!\n";
EXPECT
OPTIONS regex fatal
Unknown charname 'e_ACUTE' at - line \d+, within string
########
# NAME alias with hashref to :short OK
use warnings;
no warnings 'void';
use charnames ":short", ":alias" => { e_ACUTE => "LATIN:e WITH ACUTE" };
"Here: \N{e_ACUTE}!\n";
EXPECT
OPTIONS regex
$
########
# NAME alias with bad hashref
use warnings;
no warnings 'void';
use charnames ":short", ":alias" => "e_ACUTE";
"Here: \N{e_ACUTE}\N{a_ACUTE}!\n";
EXPECT
OPTIONS regex
unicore/e_ACUTE_alias.pl cannot be used as alias file for charnames at
########
# NAME alias with arrayref
use warnings;
no warnings 'void';
use charnames ":short", ":alias" => [ e_ACUTE => "LATIN:e WITH ACUTE" ];
"Here: \N{e_ACUTE}!\n";
EXPECT
OPTIONS regex
Only HASH reference supported as argument to :alias at
########
# NAME alias with bad hashref
no warnings;
use charnames ":short", ":alias" => { e_ACUTE => "LATIN:e WITH ACUTE", "a_ACUTE" };
"Here: \N{e_ACUTE}\N{a_ACUTE}!\n";
EXPECT
OPTIONS regex
Unknown charname 'a_ACUTE' at
########
# NAME alias with hashref two aliases
use warnings;
no warnings 'void';
use charnames ":short", ":alias" => {
    e_ACUTE => "LATIN:e WITH ACUTE",
    a_ACUTE => "",
    };
"Here: \N{e_ACUTE}\N{a_ACUTE}!\n";
EXPECT
OPTIONS regex fatal
Unknown charname 'a_ACUTE' at - line \d+, within string
########
# NAME alias with hashref two aliases
use warnings;
no warnings 'void';
use charnames ":short", ":alias" => {
    e_ACUTE => "LATIN:e WITH ACUTE",
    a_ACUTE => "LATIN:a WITH ACUTE",
    };
"Here: \N{e_ACUTE}\N{a_ACUTE}!\n";
EXPECT
OPTIONS regex
$
########
# NAME alias with hashref using mixed aliases
use warnings;
use charnames ":short", ":alias" => {
    e_ACUTE => "LATIN:e WITH ACUTE",
    a_ACUTE => "LATIN SMALL LETTER A WITH ACUT",
    };
"Here: \N{e_ACUTE}\N{a_ACUTE}!\n";
EXPECT
OPTIONS regex fatal
Unknown charname 'a_ACUTE' at - line \d+, within string
########
# NAME alias with hashref using mixed aliases
use warnings;
use charnames ":short", ":alias" => {
    e_ACUTE => "LATIN:e WITH ACUTE",
    a_ACUTE => "LATIN SMALL LETTER A WITH ACUTE",
    };
"Here: \N{e_ACUTE}\N{a_ACUTE}!\n";
EXPECT
OPTIONS regex fatal
Unknown charname 'a_ACUTE' at - line \d+, within string
########
# NAME alias with hashref using mixed aliases
use warnings;
no warnings 'void';
use charnames ":full", ":alias" => {
    e_ACUTE => "LATIN:e WITH ACUTE",
    a_ACUTE => "LATIN SMALL LETTER A WITH ACUTE",
    };
"Here: \N{e_ACUTE}\N{a_ACUTE}!\n";
EXPECT
OPTIONS regex fatal
Unknown charname 'e_ACUTE' at - line \d+, within string
########
# NAME alias with nonexisting file
use warnings;
no warnings 'void';
use charnames ":full", ":alias" => "non_existing_xyzzy";
"Here: \N{e_ACUTE}\N{a_ACUTE}!\n";
EXPECT
OPTIONS regex
unicore/non_existing_xyzzy_alias.pl cannot be used as alias file for charnames at
########
# NAME alias with bad file name
use warnings;
no warnings 'void';
use charnames ":full", ":alias" => "xy 7-";
"Here: \N{e_ACUTE}\N{a_ACUTE}!\n";
EXPECT
OPTIONS regex
Charnames alias file names can only have identifier characters at
########
# NAME alias with non_absolute (existing) file name (which it should /not/ use)
use warnings;
no warnings 'void';
use charnames ":full", ":alias" => "perl";
"Here: \N{e_ACUTE}\N{a_ACUTE}!\n";
EXPECT
OPTIONS regex
unicore/perl_alias.pl cannot be used as alias file for charnames at
########
# NAME alias with bad file
--FILE-- ../../lib/unicore/xyzzy_alias.pl
#!perl
0;
--FILE--
use warnings;
no warnings 'void';
use charnames ":full", ":alias" => "xyzzy";
"Here: \N{e_ACUTE}\N{a_ACUTE}!\n";
EXPECT
OPTIONS regex
unicore/xyzzy_alias.pl did not return a \(valid\) list of alias pairs at
########
# NAME alias with file with empty list
--FILE-- ../../lib/unicore/xyzzy_alias.pl
#!perl
();
--FILE--
use warnings;
no warnings 'void';
use charnames ":full", ":alias" => "xyzzy";
"Here: \N{e_ACUTE}\N{a_ACUTE}!\n";
EXPECT
OPTIONS regex fatal
Unknown charname 'e_ACUTE' at - line \d+, within string
########
# NAME alias with file OK but file has :short aliases
--FILE-- ../../lib/unicore/xyzzy_alias.pl
#!perl
(   e_ACUTE => "LATIN:e WITH ACUTE",
    a_ACUTE => "LATIN:a WITH ACUTE",
    );
--FILE--
use warnings;
no warnings 'void';
use charnames ":full", ":alias" => "xyzzy";
"Here: \N{e_ACUTE}\N{a_ACUTE}!\n";
EXPECT
OPTIONS regex fatal
Unknown charname 'e_ACUTE' at - line \d+, within string
########
# NAME alias with :short and file OK
--FILE-- ../../lib/unicore/xyzzy_alias.pl
#!perl
(   e_ACUTE => "LATIN:e WITH ACUTE",
    a_ACUTE => "LATIN:a WITH ACUTE",
    );
--FILE--
use warnings;
no warnings 'void';
use charnames ":short", ":alias" => "xyzzy";
"Here: \N{e_ACUTE}\N{a_ACUTE}!\n";
EXPECT
OPTIONS regex
$
########
# NAME alias with :short and file OK has :long aliases
--FILE-- ../../lib/unicore/xyzzy_alias.pl
#!perl
(   e_ACUTE => "LATIN SMALL LETTER E WITH ACUTE",
    a_ACUTE => "LATIN SMALL LETTER A WITH ACUTE",
    );
--FILE--
use warnings;
no warnings 'void';
use charnames ":short", ":alias" => "xyzzy";
"Here: \N{e_ACUTE}\N{a_ACUTE}!\n";
EXPECT
OPTIONS regex fatal
Unknown charname 'e_ACUTE' at - line \d+, within string
########
# NAME alias with file implicit :full but file has :short aliases
--FILE-- ../../lib/unicore/xyzzy_alias.pl
#!perl
(   e_ACUTE => "LATIN:e WITH ACUTE",
    a_ACUTE => "LATIN:a WITH ACUTE",
    );
--FILE--
use warnings;
no warnings 'void';
use charnames ":alias" => ":xyzzy";
"Here: \N{e_ACUTE}\N{a_ACUTE}!\n";
EXPECT
OPTIONS regex fatal
Unknown charname 'e_ACUTE' at - line \d+, within string
########
# NAME alias with file implicit :full and file has :long aliases
--FILE-- ../../lib/unicore/xyzzy_alias.pl
#!perl
(   e_ACUTE => "LATIN SMALL LETTER E WITH ACUTE",
    a_ACUTE => "LATIN SMALL LETTER A WITH ACUTE",
    );
--FILE--
use warnings;
no warnings 'void';
use charnames ":alias" => ":xyzzy";
"Here: \N{e_ACUTE}\N{a_ACUTE}!\n";
EXPECT
OPTIONS regex
$
########
# NAME charnames with no import still works for runtime functions
use warnings;
no warnings 'void';
use charnames ();
charnames::vianame('SPACE');
charnames::viacode(utf8::unicode_to_native(0x41));
EXPECT
OPTIONS regex
$
########
# NAME no extraneous warning [perl #11560]
use warnings;
use charnames ();
print charnames::viacode(utf8::unicode_to_native(0x80)), "\n";
EXPECT
OPTIONS regex
PADDING CHARACTER
########
# NAME A wrong character in :alias is an error
# These next tests could be combined, but the messages can come out in
# different orders on EBCDIC vs ASCII, and can't have both 'random' and 'regex'
# options, and need 'regex' to avoid 'at line X' getting in the way.
use charnames ":full", ":alias" => {
                            "4e_ACUTE" => "LATIN SMALL LETTER E WITH ACUTE",
                    };
EXPECT
OPTIONS regex
Invalid character in charnames alias definition; marked by <-- HERE in '4<-- HERE e_ACUTE'
########
# NAME Another wrong character in :alias is an error
use charnames ":full", ":alias" => {
                            "e_A,CUTE" => "LATIN SMALL LETTER E WITH ACUTE",
                    };
EXPECT
OPTIONS regex
Invalid character in charnames alias definition; marked by <-- HERE in 'e_A,<-- HERE CUTE'
########
# NAME Another wrong character in :alias is an error
# The EXPECT regex matches both the UTF-8 and non-UTF-8 form.
# This is because under some circumstances the message gets output as UTF-8.
# We use \xab, as that is invalid in both ASCII and EBCDIC platforms, and we
# accept both UTF-8 and 1047 UTF-EBCDIC.
use charnames ":full", ":alias" => {
                            "e_ACUT\x{ab}E" => "LATIN SMALL LETTER E WITH ACUTE",
                    };
EXPECT
OPTIONS regex
Invalid character in charnames alias definition; marked by <-- HERE in 'e_ACUT(?:\x{ab}|\x{C2}\x{AB}|\x{80\x{73})<-- HERE E'
########
# RT#73022
# NAME \N{...} interprets ... as octets rather than UTF-8
use utf8;
use open qw( :utf8 :std );
use charnames ":full", ":alias" => { "自転車に乗る人" => "BICYCLIST" };
print "ok\n" if "\N{自転車に乗る人}" eq "\x{1F6B4}";
EXPECT
ok
########
# NAME Misspelled \N{} UTF-8 names are errors
use utf8;
use open qw( :utf8 :std );
use charnames ":full", ":alias" => { "自転車に乗る人" => "BICYCLIST" };
print "ok\n" if "\N{転車に乗る人}" eq "\x{1F6B4}";
EXPECT
OPTIONS regex
Unknown charname '転車に乗る人' at - line \d+, within string
########
# NAME various wrong UTF-8 characters in :alias are errors
# First has a punctuation, KATAKANA MIDDLE DOT, in it; second begins with a
# digit: ARABIC-INDIC DIGIT FOUR
# Note that output order is alphabetical by character name
use utf8;
use open qw( :utf8 :std );
use charnames ":full", ":alias" => { "自転車・に乗る人" => "BICYCLIST",
                                     "٤転車に乗る人" => "BICYCLIST",
                                "TOO  MANY SPACES" => "NO ENTRY SIGN",
                                "TRAILING SPACE " => "FACE WITH NO GOOD GESTURE"
                                    };
print "ok\n" if "\N{TOO  MANY SPACES}" eq "\x{1F6AB}";
print "ok\n" if "\N{TRAILING SPACE }" eq "\x{1F645}";
print "ok\n" if "\N{自転車・に乗る人}" eq "\x{1F6B4}";
print "ok\n" if "\N{٤転車に乗る人}" eq "\x{1F6B4}";
EXPECT
OPTIONS regex fatal
charnames alias definitions may not contain a sequence of multiple spaces; marked by <-- HERE in 'TOO   <-- HERE MANY SPACES'
charnames alias definitions may not contain trailing white-space; marked by <-- HERE in 'TRAILING SPACE  <-- HERE '
Invalid character in charnames alias definition; marked by <-- HERE in '٤<-- HERE 転車に乗る人'
Invalid character in charnames alias definition; marked by <-- HERE in '自転車・<-- HERE に乗る人' at - line \d+
########
# NAME Using NBSP in :alias names is deprectated
use utf8;
use open qw( :utf8 :std );
use charnames ":alias" => { "NBSP SEPARATED SPACE" => "BLACK SMILING FACE" };
print "ok\n" if "\N{NBSP SEPARATED SPACE}" eq "\x{263B}";
print "ok\n" if "\N{NBSP SEPARATED SPACE}" eq "\x{263B}";
no warnings 'deprecated';
print "ok\n" if "\N{NBSP SEPARATED SPACE}" eq "\x{263B}";
EXPECT
OPTIONS regex
NO-BREAK SPACE in a charnames alias definition is deprecated; marked by <-- HERE in 'NBSP SEPARATED  <-- HERE SPACE' at - line \d+.
ok
ok
ok
@


1.1
log
@Initial revision
@
text
@d15 2
a16 1
Undefined subroutine &charnames::vianame called at - line 2.
d21 1
a21 1
charnames::viacode(0x34);
d24 1
a24 1
Undefined subroutine &charnames::viacode called at - line 2.
d32 1
a32 1
Undefined subroutine &charnames::string_vianame called at - line 2.
d40 2
a41 2
OPTIONS regex
Unknown charname 'e_ACUTE' at
a58 8
# NAME alias with hashref but no :full
use warnings;
use charnames ":alias" => { e_ACUTE => "LATIN SMALL LETTER E WITH ACUTE" };
"Here: \N{e_ACUTE}!\n";
EXPECT
OPTIONS regex
Unknown charname 'LATIN SMALL LETTER E WITH ACUTE' at
########
d65 2
a66 2
OPTIONS regex
Unknown charname 'LATIN SMALL LETTER E WITH ACUTE' at
d92 2
a93 2
OPTIONS regex
Unknown charname 'latin SMALL LETTER E WITH ACUTE' at
d101 2
a102 2
OPTIONS regex
Unknown charname 'LATIN:e WITH ACUTE' at
d148 2
a149 2
OPTIONS regex
Unknown charname '' at
d171 2
a172 2
OPTIONS regex
Unknown charname 'LATIN SMALL LETTER A WITH ACUT' at
d182 2
a183 2
OPTIONS regex
Unknown charname 'LATIN SMALL LETTER A WITH ACUTE' at
d194 2
a195 2
OPTIONS regex
Unknown charname 'LATIN:e WITH ACUTE' at
d213 1
a213 1
Charnames alias files can only have identifier characters at
d224 1
a224 1
# alias with bad file
d237 1
a237 1
# alias with file with empty list
d247 2
a248 2
OPTIONS regex
Unknown charname 'e_ACUTE' at
d250 1
a250 1
# alias with file OK but file has :short aliases
d262 2
a263 2
OPTIONS regex
Unknown charname 'LATIN:e WITH ACUTE' at
d265 1
a265 1
# alias with :short and file OK
d280 1
a280 1
# alias with :short and file OK has :long aliases
d292 2
a293 2
OPTIONS regex
Unknown charname 'LATIN SMALL LETTER E WITH ACUTE' at
d295 1
a295 1
# alias with file implicit :full but file has :short aliases
d307 2
a308 2
OPTIONS regex
Unknown charname 'LATIN:e WITH ACUTE' at
d310 1
a310 1
# alias with file implicit :full and file has :long aliases
d330 1
a330 1
charnames::viacode(0x41);
d338 1
a338 1
print charnames::viacode(0x80), "\n";
d342 86
@


1.1.1.1
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@@


1.1.1.2
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d15 1
a15 2
OPTIONS regex
Undefined subroutine &charnames::vianame called at - line \d+.
d23 1
a23 1
Undefined subroutine &charnames::viacode called at - line \d+.
d31 1
a31 1
Undefined subroutine &charnames::string_vianame called at - line \d+.
d39 2
a40 2
OPTIONS regex fatal
Unknown charname 'e_ACUTE' at - line \d+, within string
d58 8
d72 2
a73 2
OPTIONS regex fatal
Unknown charname 'e_ACUTE' at - line \d+, within string
d99 2
a100 2
OPTIONS regex fatal
Unknown charname 'e_ACUTE' at - line \d+, within string
d108 2
a109 2
OPTIONS regex fatal
Unknown charname 'e_ACUTE' at - line \d+, within string
d155 2
a156 2
OPTIONS regex fatal
Unknown charname 'a_ACUTE' at - line \d+, within string
d178 2
a179 2
OPTIONS regex fatal
Unknown charname 'a_ACUTE' at - line \d+, within string
d189 2
a190 2
OPTIONS regex fatal
Unknown charname 'a_ACUTE' at - line \d+, within string
d201 2
a202 2
OPTIONS regex fatal
Unknown charname 'e_ACUTE' at - line \d+, within string
d220 1
a220 1
Charnames alias file names can only have identifier characters at
d231 1
a231 1
# NAME alias with bad file
d244 1
a244 1
# NAME alias with file with empty list
d254 2
a255 2
OPTIONS regex fatal
Unknown charname 'e_ACUTE' at - line \d+, within string
d257 1
a257 1
# NAME alias with file OK but file has :short aliases
d269 2
a270 2
OPTIONS regex fatal
Unknown charname 'e_ACUTE' at - line \d+, within string
d272 1
a272 1
# NAME alias with :short and file OK
d287 1
a287 1
# NAME alias with :short and file OK has :long aliases
d299 2
a300 2
OPTIONS regex fatal
Unknown charname 'e_ACUTE' at - line \d+, within string
d302 1
a302 1
# NAME alias with file implicit :full but file has :short aliases
d314 2
a315 2
OPTIONS regex fatal
Unknown charname 'e_ACUTE' at - line \d+, within string
d317 1
a317 1
# NAME alias with file implicit :full and file has :long aliases
a348 65
########
# NAME various wrong characters in :alias are errors
# Below, one of the EXPECT regexes matches both the UTF-8 and non-UTF-8 form.
# This is because under some circumstances the message gets output as UTF-8.
use charnames ":full", ":alias" => {
                            "4e_ACUTE" => "LATIN SMALL LETTER E WITH ACUTE",
                            "e_A,CUTE" => "LATIN SMALL LETTER E WITH ACUTE",
                            "e_ACUT\x{d7}E" => "LATIN SMALL LETTER E WITH ACUTE",
                    };
EXPECT
OPTIONS regex
Invalid character in charnames alias definition; marked by <-- HERE in '4<-- HERE e_ACUTE'
Invalid character in charnames alias definition; marked by <-- HERE in 'e_A,<-- HERE CUTE'
Invalid character in charnames alias definition; marked by <-- HERE in 'e_ACUT(?:\x{d7}|\x{C3}\x{97})<-- HERE E'
########
# RT#73022
# NAME \N{...} interprets ... as octets rather than UTF-8
use utf8;
use open qw( :utf8 :std );
use charnames ":full", ":alias" => { "自転車に乗る人" => "BICYCLIST" };
print "ok\n" if "\N{自転車に乗る人}" eq "\x{1F6B4}";
EXPECT
ok
########
# NAME Misspelled \N{} UTF-8 names are errors
use utf8;
use open qw( :utf8 :std );
use charnames ":full", ":alias" => { "自転車に乗る人" => "BICYCLIST" };
print "ok\n" if "\N{転車に乗る人}" eq "\x{1F6B4}";
EXPECT
OPTIONS regex
Unknown charname '転車に乗る人' at - line \d+, within string
########
# NAME various wrong UTF-8 characters in :alias are errors
# First has a punctuation, KATAKANA MIDDLE DOT, in it; second begins with a
# digit: ARABIC-INDIC DIGIT FOUR
use utf8;
use open qw( :utf8 :std );
use charnames ":full", ":alias" => { "自転車・に乗る人" => "BICYCLIST",
                                     "٤転車に乗る人" => "BICYCLIST",
                                    };
print "ok\n" if "\N{自転車・に乗る人}" eq "\x{1F6B4}";
print "ok\n" if "\N{٤転車に乗る人}" eq "\x{1F6B4}";
EXPECT
OPTIONS regex
Invalid character in charnames alias definition; marked by <-- HERE in '٤<-- HERE 転車に乗る人'
Invalid character in charnames alias definition; marked by <-- HERE in '自転車・<-- HERE に乗る人' at - line \d+
########
# NAME trailing and sequences of multiple spaces in :alias names are deprectated
use charnames ":alias" => { "TOO  MANY SPACES" => "NO ENTRY SIGN",
                            "TRAILING SPACE " => "FACE WITH NO GOOD GESTURE"
                          };
print "ok\n" if "\N{TOO  MANY SPACES}" eq "\x{1F6AB}";
print "ok\n" if "\N{TRAILING SPACE }" eq "\x{1F645}";
no warnings 'deprecated';
print "ok\n" if "\N{TOO  MANY SPACES}" eq "\x{1F6AB}";
print "ok\n" if "\N{TRAILING SPACE }" eq "\x{1F645}";
EXPECT
OPTIONS regex
A sequence of multiple spaces in a charnames alias definition is deprecated; marked by <-- HERE in 'TOO   <-- HERE MANY SPACES' at - line \d+.
Trailing white-space in a charnames alias definition is deprecated; marked by <-- HERE in 'TRAILING SPACE  <-- HERE ' at - line \d+.
ok
ok
ok
ok
@


1.1.1.3
log
@Import perl-5.24.2
@
text
@d21 1
a21 1
charnames::viacode(utf8::unicode_to_native(0x34));
d330 1
a330 1
charnames::viacode(utf8::unicode_to_native(0x41));
d338 1
a338 1
print charnames::viacode(utf8::unicode_to_native(0x80)), "\n";
d343 3
a345 4
# NAME A wrong character in :alias is an error
# These next tests could be combined, but the messages can come out in
# different orders on EBCDIC vs ASCII, and can't have both 'random' and 'regex'
# options, and need 'regex' to avoid 'at line X' getting in the way.
d348 2
a353 7
########
# NAME Another wrong character in :alias is an error
use charnames ":full", ":alias" => {
                            "e_A,CUTE" => "LATIN SMALL LETTER E WITH ACUTE",
                    };
EXPECT
OPTIONS regex
d355 1
a355 12
########
# NAME Another wrong character in :alias is an error
# The EXPECT regex matches both the UTF-8 and non-UTF-8 form.
# This is because under some circumstances the message gets output as UTF-8.
# We use \xab, as that is invalid in both ASCII and EBCDIC platforms, and we
# accept both UTF-8 and 1047 UTF-EBCDIC.
use charnames ":full", ":alias" => {
                            "e_ACUT\x{ab}E" => "LATIN SMALL LETTER E WITH ACUTE",
                    };
EXPECT
OPTIONS regex
Invalid character in charnames alias definition; marked by <-- HERE in 'e_ACUT(?:\x{ab}|\x{C2}\x{AB}|\x{80\x{73})<-- HERE E'
a377 1
# Note that output order is alphabetical by character name
a381 2
                                "TOO  MANY SPACES" => "NO ENTRY SIGN",
                                "TRAILING SPACE " => "FACE WITH NO GOOD GESTURE"
a382 2
print "ok\n" if "\N{TOO  MANY SPACES}" eq "\x{1F6AB}";
print "ok\n" if "\N{TRAILING SPACE }" eq "\x{1F645}";
d386 1
a386 3
OPTIONS regex fatal
charnames alias definitions may not contain a sequence of multiple spaces; marked by <-- HERE in 'TOO   <-- HERE MANY SPACES'
charnames alias definitions may not contain trailing white-space; marked by <-- HERE in 'TRAILING SPACE  <-- HERE '
d390 6
a395 6
# NAME Using NBSP in :alias names is deprectated
use utf8;
use open qw( :utf8 :std );
use charnames ":alias" => { "NBSP SEPARATED SPACE" => "BLACK SMILING FACE" };
print "ok\n" if "\N{NBSP SEPARATED SPACE}" eq "\x{263B}";
print "ok\n" if "\N{NBSP SEPARATED SPACE}" eq "\x{263B}";
d397 2
a398 1
print "ok\n" if "\N{NBSP SEPARATED SPACE}" eq "\x{263B}";
d401 3
a403 1
NO-BREAK SPACE in a charnames alias definition is deprecated; marked by <-- HERE in 'NBSP SEPARATED  <-- HERE SPACE' at - line \d+.
@


