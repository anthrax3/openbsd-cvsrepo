head	1.2;
access;
symbols
	OPENBSD_6_1:1.2.0.2
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.1.0.58
	OPENBSD_6_0_BASE:1.1.1.1
	OPENBSD_5_9:1.1.1.1.0.52
	OPENBSD_5_9_BASE:1.1.1.1
	OPENBSD_5_8:1.1.1.1.0.54
	OPENBSD_5_8_BASE:1.1.1.1
	PERL_5_20_2:1.1.1.1
	OPENBSD_5_7:1.1.1.1.0.46
	OPENBSD_5_7_BASE:1.1.1.1
	PERL_5_20_1:1.1.1.1
	OPENBSD_5_6:1.1.1.1.0.50
	OPENBSD_5_6_BASE:1.1.1.1
	PERL_5_18_2:1.1.1.1
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.1.0.48
	OPENBSD_5_5_BASE:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.44
	OPENBSD_5_4_BASE:1.1.1.1
	PERL_5_16_3:1.1.1.1
	OPENBSD_5_3:1.1.1.1.0.42
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.40
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.38
	OPENBSD_5_0:1.1.1.1.0.36
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.34
	OPENBSD_4_9_BASE:1.1.1.1
	PERL_5_12_2:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.32
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.28
	OPENBSD_4_7_BASE:1.1.1.1
	PERL_5_10_1:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.30
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.26
	OPENBSD_4_5_BASE:1.1.1.1
	PERL_5_10_0:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.24
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.22
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.20
	OPENBSD_4_2_BASE:1.1.1.1
	OPENBSD_4_1:1.1.1.1.0.18
	OPENBSD_4_1_BASE:1.1.1.1
	OPENBSD_4_0:1.1.1.1.0.16
	OPENBSD_4_0_BASE:1.1.1.1
	PERL_5_8_8:1.1.1.1
	OPENBSD_3_9:1.1.1.1.0.14
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.12
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.10
	OPENBSD_3_7_BASE:1.1.1.1
	PERL_5_8_6:1.1.1.1
	OPENBSD_3_6:1.1.1.1.0.8
	OPENBSD_3_6_BASE:1.1.1.1
	PERL_5_8_5:1.1.1.1
	PERL_5_8_3:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.6
	OPENBSD_3_5_BASE:1.1.1.1
	PERL_5_8_2:1.1.1.1
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	PERL_5_8_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.32.20;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2002.10.27.22.15.10;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.27.22.15.10;	author millert;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@  regexec.c	

  This test generates "bad free" warnings when run under
  PERL_DESTRUCT_LEVEL.  This file merely serves as a placeholder
  for investigation.

  Complex regular subexpression recursion limit (%d) exceeded

        $_ = 'a' x (2**15+1); /^()(a\1)*$/ ;
  Complex regular subexpression recursion limit (%d) exceeded

        $_ = 'a' x (2**15+1); /^()(a\1)*?$/ ;

  (The actual value substituted for %d is masked in the tests so that
  REG_INFTY configuration variable value does not affect outcome.)
__END__
# regexec.c
print("SKIPPED\n# most systems run into stacksize limits\n"),exit;
use warnings 'regexp' ;
$SIG{__WARN__} = sub{local ($m) = shift;
                 $m =~ s/\(\d+\)/(*MASKED*)/;
                 print STDERR $m};
$_ = 'a' x (2**15+1); 
/^()(a\1)*$/ ;
#
# If this test fails with a segmentation violation or similar,
# you may have to increase the default stacksize limit in your
# shell.  You may need superuser privileges.
#
# Under the sh, ksh, zsh:
#    $ ulimit -s
#    8192
#    $ ulimit -s 16000
#
# Under the csh:
#    % limit stacksize
#    stacksize        8192 kbytes
#    % limit stacksize 16000
#
EXPECT
Complex regular subexpression recursion limit (*MASKED*) exceeded at - line 9.
########
# regexec.c
print("SKIPPED\n# most systems run into stacksize limits\n"),exit;
no warnings 'regexp' ;
$SIG{__WARN__} = sub{local ($m) = shift;
                 $m =~ s/\(\d+\)/(*MASKED*)/;
                 print STDERR $m};
$_ = 'a' x (2**15+1); 
/^()(a\1)*$/ ;
#
# If this test fails with a segmentation violation or similar,
# you may have to increase the default stacksize limit in your
# shell.  You may need superuser privileges.
#
# Under the sh, ksh, zsh:
#    $ ulimit -s
#    8192
#    $ ulimit -s 16000
#
# Under the csh:
#    % limit stacksize
#    stacksize        8192 kbytes
#    % limit stacksize 16000
#
EXPECT

########
# regexec.c
print("SKIPPED\n# most systems run into stacksize limits\n"),exit;
use warnings 'regexp' ;
$SIG{__WARN__} = sub{local ($m) = shift;
                 $m =~ s/\(\d+\)/(*MASKED*)/;
                 print STDERR $m};
$_ = 'a' x (2**15+1);
/^()(a\1)*?$/ ;
#
# If this test fails with a segmentation violation or similar,
# you may have to increase the default stacksize limit in your
# shell.  You may need superuser privileges.
#
# Under the sh, ksh, zsh:
#    $ ulimit -s
#    8192
#    $ ulimit -s 16000
#
# Under the csh:
#    % limit stacksize
#    stacksize        8192 kbytes
#    % limit stacksize 16000
#
EXPECT
Complex regular subexpression recursion limit (*MASKED*) exceeded at - line 9.
########
# regexec.c
print("SKIPPED\n# most systems run into stacksize limits\n"),exit;
no warnings 'regexp' ;
$SIG{__WARN__} = sub{local ($m) = shift;
                 $m =~ s/\(\d+\)/(*MASKED*)/;
                 print STDERR $m};
$_ = 'a' x (2**15+1);
/^()(a\1)*?$/ ;
#
# If this test fails with a segmentation violation or similar,
# you may have to increase the default stacksize limit in your
# shell.  You may need superuser privileges.
#
# Under the sh, ksh, zsh:
#    $ ulimit -s
#    8192
#    $ ulimit -s 16000
#
# Under the csh:
#    % limit stacksize
#    stacksize        8192 kbytes
#    % limit stacksize 16000
#
EXPECT

########
# NAME Wide character in non-UTF-8 locale
require '../loc_tools.pl';
unless (locales_enabled()) {
    print("SKIPPED\n# locales not available\n"),exit;
}
eval { require POSIX; POSIX->import("locale_h") };
if ($@@) {
    print("SKIPPED\n# no POSIX\n"),exit;
}
use warnings 'locale';
use locale;
setlocale(&POSIX::LC_CTYPE, "C");
"\x{100}" =~ /\x{100}|\x{101}/il;
"\x{100}" =~ /\x{100}|\x{101}/l;
"\x{100}" =~ /\w/l;
"\x{100}" =~ /\x{100}+/l;
"\x{100}" =~ /[\x{100}\x{102}]/l;
no warnings 'locale';
EXPECT
Wide character (U+100) in pattern match (m//) at - line 12.
Wide character (U+100) in pattern match (m//) at - line 12.
Wide character (U+100) in pattern match (m//) at - line 13.
Wide character (U+100) in pattern match (m//) at - line 13.
Wide character (U+100) in pattern match (m//) at - line 13.
Wide character (U+100) in pattern match (m//) at - line 14.
Wide character (U+100) in pattern match (m//) at - line 14.
Wide character (U+100) in pattern match (m//) at - line 15.
Wide character (U+100) in pattern match (m//) at - line 16.
Wide character (U+100) in pattern match (m//) at - line 16.
########
# NAME Wide character in UTF-8 locale
require '../loc_tools.pl';
unless (locales_enabled()) {
    print("SKIPPED\n# locales not available\n"),exit;
}
eval { require POSIX; POSIX->import("locale_h") };
if ($@@) {
    print("SKIPPED\n# no POSIX\n"),exit;
}
my @@utf8_locales = find_utf8_ctype_locale();
unless (@@utf8_locales) {
    print("SKIPPED\n# no UTF-8 locales\n"),exit;
}
use warnings 'locale';
use locale;
setlocale(&POSIX::LC_CTYPE, $utf8_locales[0]);
"\x{100}" =~ /\x{100}|\x{101}/il;
"\x{100}" =~ /\x{100}|\x{101}/l;
"\x{100}" =~ /\w/l;
"\x{100}" =~ /\x{100}+/l;
"\x{100}" =~ /[\x{100}\x{102}]/l;
EXPECT
########
# NAME \b{} in non-UTF-8 locale
eval { require POSIX; POSIX->import("locale_h") };
if ($@@) {
    print("SKIPPED\n# no POSIX\n"),exit;
}
use warnings 'locale';
use locale;
setlocale(&POSIX::LC_CTYPE, "C");
"a" =~ /\b{gcb}/l;
no warnings 'locale';
"a" =~ /\b{gcb}/l;
EXPECT
Use of \b{} or \B{} for non-UTF-8 locale is wrong.  Assuming a UTF-8 locale at - line 8.
Use of \b{} or \B{} for non-UTF-8 locale is wrong.  Assuming a UTF-8 locale at - line 8.
########
# NAME \b{} in UTF-8 locale
require '../loc_tools.pl';
unless (locales_enabled()) {
    print("SKIPPED\n# locales not available\n"),exit;
}
eval { require POSIX; POSIX->import("locale_h") };
if ($@@) {
    print("SKIPPED\n# no POSIX\n"),exit;
}
my $utf8_locale = find_utf8_ctype_locale();
unless ($utf8_locale) {
    print("SKIPPED\n# No UTF-8 locale available\n"),exit;
}
use warnings 'locale';
use locale;
setlocale(&POSIX::LC_CTYPE, "C");
 "abc def" =~ /\b{wb}.*?/;
 "abc def" =~ /\B{wb}.*?/;
setlocale(&POSIX::LC_CTYPE, $utf8_locale);
 "abc def" =~ /\b{wb}.*?/;
 "abc def" =~ /\B{wb}.*?/;
EXPECT
Use of \b{} or \B{} for non-UTF-8 locale is wrong.  Assuming a UTF-8 locale at - line 16.
Use of \b{} or \B{} for non-UTF-8 locale is wrong.  Assuming a UTF-8 locale at - line 16.
Use of \b{} or \B{} for non-UTF-8 locale is wrong.  Assuming a UTF-8 locale at - line 17.
Use of \b{} or \B{} for non-UTF-8 locale is wrong.  Assuming a UTF-8 locale at - line 17.
Use of \b{} or \B{} for non-UTF-8 locale is wrong.  Assuming a UTF-8 locale at - line 17.
########
# NAME (?[ ]) in non-UTF-8 locale
eval { require POSIX; POSIX->import("locale_h") };
if ($@@) {
    print("SKIPPED\n# no POSIX\n"),exit;
}
no warnings 'experimental::regex_sets';
use warnings 'locale';
use locale;
setlocale(&POSIX::LC_CTYPE, "C");
"\N{KELVIN SIGN}" =~ /(?[ \N{KELVIN SIGN} ])/i;
"K" =~ /(?[ \N{KELVIN SIGN} ])/i;
"k" =~ /(?[ \N{KELVIN SIGN} ])/i;
":" =~ /(?[ \: ])/;
no warnings 'locale';
EXPECT
Use of (?[ ]) for non-UTF-8 locale is wrong.  Assuming a UTF-8 locale at - line 9.
Use of (?[ ]) for non-UTF-8 locale is wrong.  Assuming a UTF-8 locale at - line 9.
Use of (?[ ]) for non-UTF-8 locale is wrong.  Assuming a UTF-8 locale at - line 10.
Use of (?[ ]) for non-UTF-8 locale is wrong.  Assuming a UTF-8 locale at - line 10.
Use of (?[ ]) for non-UTF-8 locale is wrong.  Assuming a UTF-8 locale at - line 11.
Use of (?[ ]) for non-UTF-8 locale is wrong.  Assuming a UTF-8 locale at - line 11.
Use of (?[ ]) for non-UTF-8 locale is wrong.  Assuming a UTF-8 locale at - line 12.
Use of (?[ ]) for non-UTF-8 locale is wrong.  Assuming a UTF-8 locale at - line 12.
########
# NAME (?[ ]) in UTF-8 locale
require '../loc_tools.pl';
unless (locales_enabled()) {
    print("SKIPPED\n# locales not available\n"),exit;
}
eval { require POSIX; POSIX->import("locale_h") };
if ($@@) {
    print("SKIPPED\n# no POSIX\n"),exit;
}
my $utf8_locale = find_utf8_ctype_locale();
unless ($utf8_locale) {
    print("SKIPPED\n# No UTF-8 locale available\n"),exit;
}
no warnings 'experimental::regex_sets';
use warnings 'locale';
use locale;
setlocale(&POSIX::LC_CTYPE, $utf8_locale);
"\N{KELVIN SIGN}" =~ /(?[ \N{KELVIN SIGN} ])/i;
"K" =~ /(?[ \N{KELVIN SIGN} ])/i;
"k" =~ /(?[ \N{KELVIN SIGN} ])/i;
":" =~ /(?[ \: ])/;
EXPECT
@


1.1
log
@Initial revision
@
text
@d120 143
@


1.1.1.1
log
@stock perl 5.8.0 from CPAN
@
text
@@
