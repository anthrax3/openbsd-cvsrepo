head	1.2;
access;
symbols
	OPENBSD_6_2:1.2.0.2
	OPENBSD_6_2_BASE:1.2
	PERL_5_24_2:1.1.1.7
	OPENBSD_6_1:1.2.0.4
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.6.0.10
	OPENBSD_6_0_BASE:1.1.1.6
	OPENBSD_5_9:1.1.1.6.0.4
	OPENBSD_5_9_BASE:1.1.1.6
	OPENBSD_5_8:1.1.1.6.0.6
	OPENBSD_5_8_BASE:1.1.1.6
	PERL_5_20_2:1.1.1.6
	OPENBSD_5_7:1.1.1.6.0.2
	OPENBSD_5_7_BASE:1.1.1.6
	PERL_5_20_1:1.1.1.6
	OPENBSD_5_6:1.1.1.5.0.4
	OPENBSD_5_6_BASE:1.1.1.5
	PERL_5_18_2:1.1.1.5
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.4.0.6
	OPENBSD_5_5_BASE:1.1.1.4
	OPENBSD_5_4:1.1.1.4.0.2
	OPENBSD_5_4_BASE:1.1.1.4
	PERL_5_16_3:1.1.1.4
	OPENBSD_5_3:1.1.1.3.0.18
	OPENBSD_5_3_BASE:1.1.1.3
	OPENBSD_5_2:1.1.1.3.0.16
	OPENBSD_5_2_BASE:1.1.1.3
	OPENBSD_5_1_BASE:1.1.1.3
	OPENBSD_5_1:1.1.1.3.0.14
	OPENBSD_5_0:1.1.1.3.0.12
	OPENBSD_5_0_BASE:1.1.1.3
	OPENBSD_4_9:1.1.1.3.0.10
	OPENBSD_4_9_BASE:1.1.1.3
	PERL_5_12_2:1.1.1.3
	OPENBSD_4_8:1.1.1.3.0.8
	OPENBSD_4_8_BASE:1.1.1.3
	OPENBSD_4_7:1.1.1.3.0.4
	OPENBSD_4_7_BASE:1.1.1.3
	PERL_5_10_1:1.1.1.3
	OPENBSD_4_6:1.1.1.3.0.6
	OPENBSD_4_6_BASE:1.1.1.3
	OPENBSD_4_5:1.1.1.3.0.2
	OPENBSD_4_5_BASE:1.1.1.3
	PERL_5_10_0:1.1.1.3
	OPENBSD_4_4:1.1.1.2.0.20
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.18
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_2:1.1.1.2.0.16
	OPENBSD_4_2_BASE:1.1.1.2
	OPENBSD_4_1:1.1.1.2.0.14
	OPENBSD_4_1_BASE:1.1.1.2
	OPENBSD_4_0:1.1.1.2.0.12
	OPENBSD_4_0_BASE:1.1.1.2
	PERL_5_8_8:1.1.1.2
	OPENBSD_3_9:1.1.1.2.0.10
	OPENBSD_3_9_BASE:1.1.1.2
	OPENBSD_3_8:1.1.1.2.0.8
	OPENBSD_3_8_BASE:1.1.1.2
	OPENBSD_3_7:1.1.1.2.0.6
	OPENBSD_3_7_BASE:1.1.1.2
	PERL_5_8_6:1.1.1.2
	OPENBSD_3_6:1.1.1.2.0.4
	OPENBSD_3_6_BASE:1.1.1.2
	PERL_5_8_5:1.1.1.2
	PERL_5_8_3:1.1.1.2
	OPENBSD_3_5:1.1.1.2.0.2
	OPENBSD_3_5_BASE:1.1.1.2
	PERL_5_8_2:1.1.1.2
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	PERL_5_8_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.32.20;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2002.10.27.22.15.10;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.27.22.15.10;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.12.03.02.44.31;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2008.09.29.17.19.00;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2013.03.25.20.09.34;	author sthen;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2014.03.24.14.59.10;	author afresh1;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2014.11.17.20.53.17;	author afresh1;	state Exp;
branches;
next	1.1.1.7;
commitid	B31cAbBIXiCqnL97;

1.1.1.7
date	2017.08.14.13.46.23;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@  pp_hot.c	

  print() on unopened filehandle abc		[pp_print]
    $f = $a = "abc" ; print $f $a

  Filehandle %s opened only for input		[pp_print]
    print STDIN "abc" ;

  Filehandle %s opened only for output		[pp_print]
    $a = <STDOUT> ;

  print() on closed filehandle %s		[pp_print]
    close STDIN ; print STDIN "abc" ;

  uninitialized					[pp_rv2av]
	my $a = undef ; my @@b = @@$a

  uninitialized					[pp_rv2hv]
	my $a = undef ; my %b = %$a

  Odd number of elements in hash list		[pp_aassign]
	%X = (1,2,3) ;

  Reference found where even-sized list expected [pp_aassign]
	$X = [ 1 ..3 ];

  Filehandle %s opened only for output		[Perl_do_readline] 
  	open (FH, ">./xcv") ;
	my $a = <FH> ;

  glob failed (can't start child: %s)		[Perl_do_readline] <<TODO

  readline() on closed filehandle %s		[Perl_do_readline]
    close STDIN ; $a = <STDIN>;

  readline() on closed filehandle %s		[Perl_do_readline]
    readline(NONESUCH);

  glob failed (child exited with status %d%s)	[Perl_do_readline] <<TODO

  Deep recursion on subroutine \"%s\"		[Perl_sub_crush_depth]
    sub fred { fred() if $a++ < 200} fred()

  Deep recursion on anonymous subroutine 	[Perl_sub_crush_depth]
    $a = sub { &$a if $a++ < 200} &$a

  Use of reference "%s" as array index [pp_aelem]
    $x[\1]

__END__
# pp_hot.c [pp_print]
use warnings 'unopened' ;
$f = $a = "abc" ; 
print $f $a;
no warnings 'unopened' ;
print $f $a;
use warnings;
no warnings 'unopened' ;
print $f $a;
EXPECT
print() on unopened filehandle abc at - line 4.
########
# pp_hot.c [pp_print]
use warnings 'unopened' ;
$SIG{__WARN__} = sub { warn $_[0] =~ s/\0/\\0/rug; };
print {"a\0b"} "anc";
print {"\0b"} "anc";
EXPECT
print() on unopened filehandle a\0b at - line 4.
print() on unopened filehandle \0b at - line 5.
########
# pp_hot.c [pp_print]
use warnings 'io' ;
# There is no guarantee that STDOUT is output only, or STDIN input only.
# Certainly on some BSDs (at least FreeBSD, Darwin, BSDi) file descriptors
# 1 and 2 are opened read/write on the tty, and the IO layers may reflect this.
# So we must make our own file handle that is read only.
my $file = "./xcv" ; unlink $file ;
open (FH, ">$file") or die $! ;
close FH or die $! ;
die "There is no file $file" unless -f $file ;
open (FH, "<$file") or die $! ;
print FH "anc" ;
open(FOO, "<&FH") or die $! ;
print FOO "anc" ;
no warnings 'io' ;
print FH "anc" ;
print FOO "anc" ;
use warnings 'io' ;
print FH "anc" ;
print FOO "anc" ;
close (FH) or die $! ;
close (FOO) or die $! ;
unlink $file ;
EXPECT
Filehandle FH opened only for input at - line 12.
Filehandle FOO opened only for input at - line 14.
Filehandle FH opened only for input at - line 19.
Filehandle FOO opened only for input at - line 20.
########
# pp_hot.c [pp_print]
$SIG{__WARN__} = sub { warn $_[0] =~ s/\0/\\0/rug; };
use warnings 'io' ;
my $file = "./xcv" ; unlink $file ;
open (FH, ">$file") or die $! ;
close FH or die $! ;
die "There is no file $file" unless -f $file ;
open ("a\0b", "<$file") or die $! ;
print {"a\0b"} "anc" ;
open ("\0b", "<$file") or die $! ;
print {"\0b"} "anc" ;
close "a\0b" or die $! ;
close "\0b" or die $! ;
unlink $file ;
EXPECT
Filehandle a\0b opened only for input at - line 9.
Filehandle \0b opened only for input at - line 11.
########
# pp_hot.c [pp_print]
use warnings 'closed' ;
close STDIN ;
print STDIN "anc";
opendir STDIN, ".";
print STDIN "anc";
closedir STDIN;
no warnings 'closed' ;
print STDIN "anc";
opendir STDIN, ".";
print STDIN "anc";
use warnings;
no warnings 'closed' ;
print STDIN "anc";
EXPECT
print() on closed filehandle STDIN at - line 4.
print() on closed filehandle STDIN at - line 6.
	(Are you trying to call print() on dirhandle STDIN?)
########
# pp_hot.c [pp_print]
# [ID 20020425.012] from Dave Steiner <steiner@@bakerst.rutgers.edu>
# This goes segv on 5.7.3
use warnings 'closed' ;
my $fh = *STDOUT{IO};
close STDOUT or die "Can't close STDOUT";
print $fh "Shouldn't print anything, but shouldn't SEGV either\n";
EXPECT
print() on closed filehandle __ANONIO__ at - line 7.
########
# pp_hot.c [pp_print]
package foo;
use warnings 'closed';
open my $fh1, "nonexistent";
print $fh1 42;
open $fh2, "nonexistent";
print $fh2 42;
open $bar::fh3, "nonexistent";
print $bar::fh3 42;
open bar::FH4, "nonexistent";
print bar::FH4 42;
EXPECT
print() on closed filehandle $fh1 at - line 5.
print() on closed filehandle $fh2 at - line 7.
print() on closed filehandle $fh3 at - line 9.
print() on closed filehandle FH4 at - line 11.
########
# pp_hot.c [pp_rv2av]
use warnings 'uninitialized' ;
my $a = undef ;
my @@b = @@$a;
no warnings 'uninitialized' ;
my @@c = @@$a;
EXPECT
Use of uninitialized value $a in array dereference at - line 4.
########
# pp_hot.c [pp_rv2hv]
use warnings 'uninitialized' ;
my $a = undef ;
my %b = %$a;
no warnings 'uninitialized' ;
my %c = %$a;
EXPECT
Use of uninitialized value $a in hash dereference at - line 4.
########
# pp_hot.c [pp_aassign]
use warnings 'misc' ;
my %X ; %X = (1,2,3) ;
no warnings 'misc' ;
my %Y ; %Y = (1,2,3) ;
EXPECT
Odd number of elements in hash assignment at - line 3.
########
# pp_hot.c [pp_aassign]
use warnings 'misc' ;
my %X ; %X = [1 .. 3] ;
no warnings 'misc' ;
my %Y ; %Y = [1 .. 3] ;
EXPECT
Reference found where even-sized list expected at - line 3.
########
# pp_hot.c [Perl_do_readline]
use warnings 'closed' ;
close STDIN        ; $a = <STDIN> ;
opendir STDIN, "." ; $a = <STDIN> ;
closedir STDIN;
no warnings 'closed' ;
opendir STDIN, "." ; $a = <STDIN> ;
$a = <STDIN> ;
EXPECT
readline() on closed filehandle STDIN at - line 3.
readline() on closed filehandle STDIN at - line 4.
	(Are you trying to call readline() on dirhandle STDIN?)
########
# pp_hot.c [Perl_do_readline]
use warnings 'closed' ;
close STDIN        ; $a .= <STDIN> ;
opendir STDIN, "." ; $a .= <STDIN> ;
closedir STDIN;
no warnings 'closed' ;
opendir STDIN, "." ; $a .= <STDIN> ;
$a = <STDIN> ;
EXPECT
readline() on closed filehandle STDIN at - line 3.
readline() on closed filehandle STDIN at - line 4.
	(Are you trying to call readline() on dirhandle STDIN?)
########
# pp_hot.c [Perl_do_readline]
use warnings 'io' ;
my $file = "./xcv" ; unlink $file ;
open (FH, ">$file") or die $! ;
my $a = <FH> ;
no warnings 'io' ;
$a = <FH> ;
use warnings 'io' ;
open(FOO, ">&FH") or die $! ;
$a = <FOO> ;
no warnings 'io' ;
$a = <FOO> ;
use warnings 'io' ;
$a = <FOO> ;
$a = <FH> ;
close (FH) or die $! ;
close (FOO) or die $! ;
unlink $file ;
EXPECT
Filehandle FH opened only for output at - line 5.
Filehandle FOO opened only for output at - line 10.
Filehandle FOO opened only for output at - line 14.
Filehandle FH opened only for output at - line 15.
########
# pp_hot.c [Perl_sub_crush_depth]
use warnings 'recursion' ;
sub fred 
{ 
    fred() if $a++ < 200
} 
{
  local $SIG{__WARN__} = sub {
    die "ok\n" if $_[0] =~ /^Deep recursion on subroutine "main::fred"/
  };
  fred();
}
EXPECT
ok
########
# pp_hot.c [Perl_sub_crush_depth]
no warnings 'recursion' ;
sub fred 
{ 
    fred() if $a++ < 200
} 
{
  local $SIG{__WARN__} = sub {
    die "ok\n" if $_[0] =~ /^Deep recursion on subroutine "main::fred"/
  };
  fred();
}
EXPECT

########
# pp_hot.c [Perl_sub_crush_depth]
use warnings 'recursion' ;
$b = sub 
{ 
    &$b if $a++ < 200
}  ;

&$b ;
EXPECT
Deep recursion on anonymous subroutine at - line 5.
########
# pp_hot.c [Perl_sub_crush_depth]
no warnings 'recursion' ;
$b = sub 
{ 
    &$b if $a++ < 200
}  ;

&$b ;
EXPECT
########
# pp_hot.c [pp_concat]
use warnings 'uninitialized';
my($x, $y);
sub a { shift }
a($x . "x");	# should warn once
a($x . $y);	# should warn twice
$x .= $y;	# should warn once
$y .= $y;	# should warn once
EXPECT
Use of uninitialized value $x in concatenation (.) or string at - line 5.
Use of uninitialized value $x in concatenation (.) or string at - line 6.
Use of uninitialized value $y in concatenation (.) or string at - line 6.
Use of uninitialized value $y in concatenation (.) or string at - line 7.
Use of uninitialized value $y in concatenation (.) or string at - line 8.
########
# pp_hot.c [pp_aelem]
{
use warnings 'misc';
print $x[\1];
}
{
no warnings 'misc';
print $x[\1];
}

EXPECT
OPTION regex
Use of reference ".*" as array index at - line 4.
########
# pp_hot.c [pp_aelem]
package Foo;use overload q("") => sub {};package main;$a = bless {}, "Foo";
$b = {};
{
use warnings 'misc';
print $x[$a];
print $x[$b];
}
{
no warnings 'misc';
print $x[$a];
print $x[$b];
}

EXPECT
OPTION regex
Use of reference ".*" as array index at - line 7.
########
use warnings 'misc';
use constant FOO => { a => 1 };
() = $_[FOO->{a}];

EXPECT
########
use warnings 'misc';
use constant FOO => {};
() = $_[FOO];

EXPECT
OPTION regex
Use of reference "HASH\(0x\w+\)" as array index at - line 3.
@


1.1
log
@Initial revision
@
text
@a46 3
  Possible Y2K bug: about to append an integer to '19' [pp_concat]
    $x     = "19$yy\n";

d57 3
d64 9
d102 18
d130 3
d146 1
a146 1
print() on closed filehandle at - line 7.
d172 1
a172 1
Use of uninitialized value in array dereference at - line 4.
d181 1
a181 1
Use of uninitialized value in hash dereference at - line 4.
d213 13
d309 5
a313 31
Use of uninitialized value in concatenation (.) or string at - line 5.
Use of uninitialized value in concatenation (.) or string at - line 6.
Use of uninitialized value in concatenation (.) or string at - line 6.
Use of uninitialized value in concatenation (.) or string at - line 7.
Use of uninitialized value in concatenation (.) or string at - line 8.
########
# pp_hot.c [pp_concat]
use warnings 'y2k';
use Config;
BEGIN {
    unless ($Config{ccflags} =~ /Y2KWARN/) {
	print "SKIPPED\n# perl not built with -DPERL_Y2KWARN";
	exit 0;
    }
}
my $x;
my $yy = 78;
$x     = "19$yy\n";
$x     = "19" . $yy . "\n";
$x     = "319$yy\n";
$x     = "319" . $yy . "\n";
$yy = 19;
$x     = "ok $yy\n";
$yy = 9;
$x     = 1 . $yy;
no warnings 'y2k';
$x     = "19$yy\n";
$x     = "19" . $yy . "\n";
EXPECT
Possible Y2K bug: about to append an integer to '19' at - line 12.
Possible Y2K bug: about to append an integer to '19' at - line 13.
d346 14
@


1.1.1.1
log
@stock perl 5.8.0 from CPAN
@
text
@@


1.1.1.2
log
@perl 5.8.2 from CPAN
@
text
@a59 3
use warnings;
no warnings 'unopened' ;
print $f $a;
a101 3
print STDIN "anc";
use warnings;
no warnings 'closed' ;
@


1.1.1.3
log
@import perl 5.10.0 from CPAN
@
text
@d47 3
d148 1
a148 1
Use of uninitialized value $a in array dereference at - line 4.
d157 1
a157 1
Use of uninitialized value $a in hash dereference at - line 4.
d272 31
a302 5
Use of uninitialized value $x in concatenation (.) or string at - line 5.
Use of uninitialized value $x in concatenation (.) or string at - line 6.
Use of uninitialized value $y in concatenation (.) or string at - line 6.
Use of uninitialized value $y in concatenation (.) or string at - line 7.
Use of uninitialized value $y in concatenation (.) or string at - line 8.
@


1.1.1.4
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d119 1
a119 1
print() on closed filehandle __ANONIO__ at - line 7.
@


1.1.1.5
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@a63 9
use warnings 'unopened' ;
$SIG{__WARN__} = sub { warn $_[0] =~ s/\0/\\0/rug; };
print {"a\0b"} "anc";
print {"\0b"} "anc";
EXPECT
print() on unopened filehandle a\0b at - line 4.
print() on unopened filehandle \0b at - line 5.
########
# pp_hot.c [pp_print]
a90 18
########
# pp_hot.c [pp_print]
$SIG{__WARN__} = sub { warn $_[0] =~ s/\0/\\0/rug; };
use warnings 'io' ;
my $file = "./xcv" ; unlink $file ;
open (FH, ">$file") or die $! ;
close FH or die $! ;
die "There is no file $file" unless -f $file ;
open ("a\0b", "<$file") or die $! ;
print {"a\0b"} "anc" ;
open ("\0b", "<$file") or die $! ;
print {"\0b"} "anc" ;
close "a\0b" or die $! ;
close "\0b" or die $! ;
unlink $file ;
EXPECT
Filehandle a\0b opened only for input at - line 9.
Filehandle \0b opened only for input at - line 11.
@


1.1.1.6
log
@Import perl-5.20.1
@
text
@a212 13
use warnings 'closed' ;
close STDIN        ; $a .= <STDIN> ;
opendir STDIN, "." ; $a .= <STDIN> ;
closedir STDIN;
no warnings 'closed' ;
opendir STDIN, "." ; $a .= <STDIN> ;
$a = <STDIN> ;
EXPECT
readline() on closed filehandle STDIN at - line 3.
readline() on closed filehandle STDIN at - line 4.
	(Are you trying to call readline() on dirhandle STDIN?)
########
# pp_hot.c [Perl_do_readline]
@


1.1.1.7
log
@Import perl-5.24.2
@
text
@a345 14
########
use warnings 'misc';
use constant FOO => { a => 1 };
() = $_[FOO->{a}];

EXPECT
########
use warnings 'misc';
use constant FOO => {};
() = $_[FOO];

EXPECT
OPTION regex
Use of reference "HASH\(0x\w+\)" as array index at - line 3.
@


