head	1.2;
access;
symbols
	OPENBSD_6_1:1.2.0.4
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.4.0.10
	OPENBSD_6_0_BASE:1.1.1.4
	OPENBSD_5_9:1.1.1.4.0.4
	OPENBSD_5_9_BASE:1.1.1.4
	OPENBSD_5_8:1.1.1.4.0.6
	OPENBSD_5_8_BASE:1.1.1.4
	PERL_5_20_2:1.1.1.4
	OPENBSD_5_7:1.1.1.4.0.2
	OPENBSD_5_7_BASE:1.1.1.4
	PERL_5_20_1:1.1.1.4
	OPENBSD_5_6:1.1.1.3.0.8
	OPENBSD_5_6_BASE:1.1.1.3
	PERL_5_18_2:1.1.1.3
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.3.0.6
	OPENBSD_5_5_BASE:1.1.1.3
	OPENBSD_5_4:1.1.1.3.0.2
	OPENBSD_5_4_BASE:1.1.1.3
	PERL_5_16_3:1.1.1.3
	OPENBSD_5_3:1.1.1.2.0.10
	OPENBSD_5_3_BASE:1.1.1.2
	OPENBSD_5_2:1.1.1.2.0.8
	OPENBSD_5_2_BASE:1.1.1.2
	OPENBSD_5_1_BASE:1.1.1.2
	OPENBSD_5_1:1.1.1.2.0.6
	OPENBSD_5_0:1.1.1.2.0.4
	OPENBSD_5_0_BASE:1.1.1.2
	OPENBSD_4_9:1.1.1.2.0.2
	OPENBSD_4_9_BASE:1.1.1.2
	PERL_5_12_2:1.1.1.2
	OPENBSD_4_8:1.1.1.1.0.18
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.14
	OPENBSD_4_7_BASE:1.1.1.1
	PERL_5_10_1:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.16
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.12
	OPENBSD_4_5_BASE:1.1.1.1
	PERL_5_10_0:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.10
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.8
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.6
	OPENBSD_4_2_BASE:1.1.1.1
	OPENBSD_4_1:1.1.1.1.0.4
	OPENBSD_4_1_BASE:1.1.1.1
	OPENBSD_4_0:1.1.1.1.0.2
	OPENBSD_4_0_BASE:1.1.1.1
	PERL_5_8_8:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.32.20;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2006.03.28.18.49.46;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.03.28.18.49.46;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2010.09.24.14.49.16;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2013.03.25.20.09.37;	author sthen;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.11.17.20.53.18;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl

my $hires;
BEGIN {
    chdir 't' if -d 't';
    @@INC = ('.', '../lib');
    $hires = eval 'use Time::HiResx "time"; 1';
}

require './test.pl';

skip_all("Win32 miniperl has no socket select")
  if $^O eq "MSWin32" && is_miniperl();

plan (15);

my $blank = "";
eval {select undef, $blank, $blank, 0};
is ($@@, "", 'select undef  $blank $blank 0');
eval {select $blank, undef, $blank, 0};
is ($@@, "", 'select $blank undef  $blank 0');
eval {select $blank, $blank, undef, 0};
is ($@@, "", 'select $blank $blank undef  0');

eval {select "", $blank, $blank, 0};
is ($@@, "", 'select ""     $blank $blank 0');
eval {select $blank, "", $blank, 0};
is ($@@, "", 'select $blank ""     $blank 0');
eval {select $blank, $blank, "", 0};
is ($@@, "", 'select $blank $blank ""     0');

# Test with read-only copy-on-write empty string
my($rocow) = keys%{{""=>undef}};
Internals::SvREADONLY($rocow,1);
eval {select $rocow, $blank, $blank, 0};
is ($@@, "", 'select $rocow     $blank $blank 0');
eval {select $blank, $rocow, $blank, 0};
is ($@@, "", 'select $blank $rocow     $blank 0');
eval {select $blank, $blank, $rocow, 0};
is ($@@, "", 'select $blank $blank $rocow     0');

eval {select "a", $blank, $blank, 0};
like ($@@, qr/^Modification of a read-only value attempted/,
	    'select "a"    $blank $blank 0');
eval {select $blank, "a", $blank, 0};
like ($@@, qr/^Modification of a read-only value attempted/,
	    'select $blank "a"    $blank 0');
eval {select $blank, $blank, "a", 0};
like ($@@, qr/^Modification of a read-only value attempted/,
	    'select $blank $blank "a"    0');

my $sleep = 3;
# Actual sleep time on Windows may be rounded down to an integral
# multiple of the system clock tick interval.  Clock tick interval
# is configurable, but usually about 15.625 milliseconds.
# time() however (if we haven;t loaded Time::HiRes), doesn't return
# fractional values, so the observed delay may be 1 second short.
#
# There is also a report that old linux kernels may return 0.5ms early:
# <20110520081714.GC17549@@mars.tony.develop-help.com>.
#

my $under = $hires ? 0.1 : 1;

my $t0 = time;
select(undef, undef, undef, $sleep);
my $t1 = time;
my $diff = $t1-$t0;
ok($diff >= $sleep-$under, "select(u,u,u,\$sleep):  at least $sleep seconds have passed");
note("diff=$diff under=$under");

my $empty = "";
vec($empty,0,1) = 0;
$t0 = time;
select($empty, undef, undef, $sleep);
$t1 = time;
$diff = $t1-$t0;
ok($diff >= $sleep-$under, "select(\$e,u,u,\$sleep): at least $sleep seconds have passed");
note("diff=$diff under=$under");

# [perl #120102] CORE::select ignoring timeout var's magic

{
    package RT120102;

    my $count = 0;

    sub TIESCALAR { bless [] }
    sub FETCH { $count++; 0.1 }

    my $sleep;

    tie $sleep, 'RT120102';
    select (undef, undef, undef, $sleep);
    ::is($count, 1, 'RT120102');
}
@


1.1
log
@Initial revision
@
text
@d3 1
d7 1
d10 1
a10 1
require 'test.pl';
d12 4
a15 1
plan (9);
d19 1
a19 1
is ($@@, "");
d21 1
a21 1
is ($@@, "");
d23 1
a23 1
is ($@@, "");
d26 1
a26 1
is ($@@, "");
d28 1
a28 1
is ($@@, "");
d30 11
a40 1
is ($@@, "");
d43 2
a44 1
like ($@@, qr/^Modification of a read-only value attempted/);
d46 2
a47 1
like ($@@, qr/^Modification of a read-only value attempted/);
d49 48
a96 1
like ($@@, qr/^Modification of a read-only value attempted/);
@


1.1.1.1
log
@perl 5.8.8 import
@
text
@@


1.1.1.2
log
@Perl 5.12.2 from CPAN
@
text
@d10 1
a10 1
plan (11);
a32 18

my($sleep,$fudge) = (3,0);
# Actual sleep time on Windows may be rounded down to an integral
# multiple of the system clock tick interval.  Clock tick interval
# is configurable, but usually about 15.625 milliseconds.
# time() however doesn't return fractional values, so the observed
# delay may be 1 second short.
($sleep,$fudge) = (4,1) if $^O eq "MSWin32";

my $t = time;
select(undef, undef, undef, $sleep);
ok(time-$t >= $sleep-$fudge, "$sleep seconds have passed");

my $empty = "";
vec($empty,0,1) = 0;
$t = time;
select($empty, undef, undef, $sleep);
ok(time-$t >= $sleep-$fudge, "$sleep seconds have passed");
@


1.1.1.3
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@a2 1
my $hires;
a5 1
    $hires = eval 'use Time::HiResx "time"; 1';
d14 1
a14 1
is ($@@, "", 'select undef  $blank $blank 0');
d16 1
a16 1
is ($@@, "", 'select $blank undef  $blank 0');
d18 1
a18 1
is ($@@, "", 'select $blank $blank undef  0');
d21 1
a21 1
is ($@@, "", 'select ""     $blank $blank 0');
d23 1
a23 1
is ($@@, "", 'select $blank ""     $blank 0');
d25 1
a25 1
is ($@@, "", 'select $blank $blank ""     0');
d28 1
a28 2
like ($@@, qr/^Modification of a read-only value attempted/,
	    'select "a"    $blank $blank 0');
d30 1
a30 2
like ($@@, qr/^Modification of a read-only value attempted/,
	    'select $blank "a"    $blank 0');
d32 1
a32 2
like ($@@, qr/^Modification of a read-only value attempted/,
	    'select $blank $blank "a"    0');
d34 1
a34 1
my $sleep = 3;
d38 3
a40 6
# time() however (if we haven;t loaded Time::HiRes), doesn't return
# fractional values, so the observed delay may be 1 second short.
#
# There is also a report that old linux kernels may return 0.5ms early:
# <20110520081714.GC17549@@mars.tony.develop-help.com>.
#
d42 1
a42 3
my $under = $hires ? 0.1 : 1;

my $t0 = time;
d44 1
a44 4
my $t1 = time;
my $diff = $t1-$t0;
ok($diff >= $sleep-$under, "select(u,u,u,\$sleep):  at least $sleep seconds have passed");
note("diff=$diff under=$under");
d48 1
a48 1
$t0 = time;
d50 1
a50 4
$t1 = time;
$diff = $t1-$t0;
ok($diff >= $sleep-$under, "select(\$e,u,u,\$sleep): at least $sleep seconds have passed");
note("diff=$diff under=$under");
@


1.1.1.4
log
@Import perl-5.20.1
@
text
@d12 1
a12 1
plan (15);
a28 10
# Test with read-only copy-on-write empty string
my($rocow) = keys%{{""=>undef}};
Internals::SvREADONLY($rocow,1);
eval {select $rocow, $blank, $blank, 0};
is ($@@, "", 'select $rocow     $blank $blank 0');
eval {select $blank, $rocow, $blank, 0};
is ($@@, "", 'select $blank $rocow     $blank 0');
eval {select $blank, $blank, $rocow, 0};
is ($@@, "", 'select $blank $blank $rocow     0');

a66 17

# [perl #120102] CORE::select ignoring timeout var's magic

{
    package RT120102;

    my $count = 0;

    sub TIESCALAR { bless [] }
    sub FETCH { $count++; 0.1 }

    my $sleep;

    tie $sleep, 'RT120102';
    select (undef, undef, undef, $sleep);
    ::is($count, 1, 'RT120102');
}
@


