head	1.2;
access;
symbols
	OPENBSD_6_0:1.1.1.7.0.12
	OPENBSD_6_0_BASE:1.1.1.7
	OPENBSD_5_9:1.1.1.7.0.6
	OPENBSD_5_9_BASE:1.1.1.7
	OPENBSD_5_8:1.1.1.7.0.8
	OPENBSD_5_8_BASE:1.1.1.7
	PERL_5_20_2:1.1.1.7
	OPENBSD_5_7:1.1.1.7.0.2
	OPENBSD_5_7_BASE:1.1.1.7
	PERL_5_20_1:1.1.1.7
	OPENBSD_5_6:1.1.1.7.0.4
	OPENBSD_5_6_BASE:1.1.1.7
	PERL_5_18_2:1.1.1.7
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.6.0.6
	OPENBSD_5_5_BASE:1.1.1.6
	OPENBSD_5_4:1.1.1.6.0.2
	OPENBSD_5_4_BASE:1.1.1.6
	PERL_5_16_3:1.1.1.6
	OPENBSD_5_3:1.1.1.5.0.14
	OPENBSD_5_3_BASE:1.1.1.5
	OPENBSD_5_2:1.1.1.5.0.12
	OPENBSD_5_2_BASE:1.1.1.5
	OPENBSD_5_1_BASE:1.1.1.5
	OPENBSD_5_1:1.1.1.5.0.10
	OPENBSD_5_0:1.1.1.5.0.8
	OPENBSD_5_0_BASE:1.1.1.5
	OPENBSD_4_9:1.1.1.5.0.6
	OPENBSD_4_9_BASE:1.1.1.5
	PERL_5_12_2:1.1.1.5
	OPENBSD_4_8:1.1.1.5.0.4
	OPENBSD_4_8_BASE:1.1.1.5
	OPENBSD_4_7:1.1.1.5.0.2
	OPENBSD_4_7_BASE:1.1.1.5
	PERL_5_10_1:1.1.1.5
	OPENBSD_4_6:1.1.1.4.0.6
	OPENBSD_4_6_BASE:1.1.1.4
	OPENBSD_4_5:1.1.1.4.0.2
	OPENBSD_4_5_BASE:1.1.1.4
	PERL_5_10_0:1.1.1.4
	OPENBSD_4_4:1.1.1.3.0.24
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.22
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_2:1.1.1.3.0.20
	OPENBSD_4_2_BASE:1.1.1.3
	OPENBSD_4_1:1.1.1.3.0.18
	OPENBSD_4_1_BASE:1.1.1.3
	OPENBSD_4_0:1.1.1.3.0.16
	OPENBSD_4_0_BASE:1.1.1.3
	PERL_5_8_8:1.1.1.3
	OPENBSD_3_9:1.1.1.3.0.14
	OPENBSD_3_9_BASE:1.1.1.3
	OPENBSD_3_8:1.1.1.3.0.12
	OPENBSD_3_8_BASE:1.1.1.3
	OPENBSD_3_7:1.1.1.3.0.10
	OPENBSD_3_7_BASE:1.1.1.3
	PERL_5_8_6:1.1.1.3
	OPENBSD_3_6:1.1.1.3.0.8
	OPENBSD_3_6_BASE:1.1.1.3
	PERL_5_8_5:1.1.1.3
	PERL_5_8_3:1.1.1.3
	OPENBSD_3_5:1.1.1.3.0.6
	OPENBSD_3_5_BASE:1.1.1.3
	PERL_5_8_2:1.1.1.3
	OPENBSD_3_4:1.1.1.3.0.4
	OPENBSD_3_4_BASE:1.1.1.3
	OPENBSD_3_3:1.1.1.3.0.2
	OPENBSD_3_3_BASE:1.1.1.3
	PERL_5_8_0:1.1.1.3
	OPENBSD_3_2:1.1.1.2.0.6
	OPENBSD_3_2_BASE:1.1.1.2
	OPENBSD_3_1:1.1.1.2.0.4
	OPENBSD_3_1_BASE:1.1.1.2
	OPENBSD_3_0:1.1.1.2.0.2
	OPENBSD_3_0_BASE:1.1.1.2
	PERL_5_6_1:1.1.1.2
	OPENBSD_2_9:1.1.1.1.0.6
	OPENBSD_2_9_BASE:1.1.1.1
	OPENBSD_2_8:1.1.1.1.0.4
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.2
	OPENBSD_2_7_BASE:1.1.1.1
	PERL_5_6_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.32.20;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2000.04.06.16.10.50;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.04.06.16.10.50;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.05.24.18.25.44;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.10.27.22.15.10;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2008.09.29.17.19.01;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2009.10.12.18.10.45;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2013.03.25.20.09.36;	author sthen;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2014.03.24.14.59.10;	author afresh1;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl

BEGIN {
    chdir 't' if -d 't';
    @@INC = '../lib';
    require './test.pl';
}

use strict;
use warnings;

eval {my @@n = getpwuid 0; setpwent()};
skip_all($1) if $@@ && $@@ =~ /(The \w+ function is unimplemented)/;

eval { require Config; };

sub try_prog {
    my ($where, $args, @@pathnames) = @@_;
    foreach my $prog (@@pathnames) {
	next unless -x $prog;
	next unless open PW, '-|', "$prog $args 2>/dev/null";
	next unless defined <PW>;
	return $where;
    }
    return;
}

# Try NIS.
my $where = try_prog('NIS passwd', 'passwd',
		     qw(/usr/bin/ypcat /bin/ypcat /etc/ypcat));

# Try NetInfo.
$where //= try_prog('NetInfo passwd', 'passwd .', '/usr/bin/nidump');

# Try NIS+.
$where //= try_prog('NIS+', 'passwd.org_dir', '/bin/niscat');

# Try dscl
DSCL: {
my @@dscl = qw(/usr/bin/dscl);
if (!defined $where && $Config::Config{useperlio} && grep { -x } @@dscl) {
    eval { require PerlIO::scalar; }; # Beware miniperl.
    if ($@@) {
        print "# No PerlIO::scalar, will not try dscl\n";
        last DSCL;
    }
    # Map dscl items to passwd fields, and provide support for
    # mucking with the dscl output if we need to (and we do).
    my %want = do {
	my $inx = 0;
	map {$_ => {inx => $inx++, mung => sub {$_[0]}}}
	    qw{RecordName Password UniqueID PrimaryGroupID
	       RealName NFSHomeDirectory UserShell};
    };

    # The RecordName for a /User record is the username. In some
    # cases there are synonyms (e.g. _www and www), in which case we
    # get a blank-delimited list. We prefer the first entry in the
    # list because getpwnam() does.
    $want{RecordName}{mung} = sub {(split '\s+', $_[0], 2)[0]};

    # The UniqueID and PrimaryGroupID for a /User record are the
    # user ID and the primary group ID respectively. In cases where
    # the high bit is set, 'dscl' returns a negative number, whereas
    # getpwnam() returns its twos complement. This mungs the dscl
    # output to agree with what getpwnam() produces. Interestingly
    # enough, getpwuid(-2) returns the right record ('nobody'), even
    # though it returns the uid as 4294967294. If you track uid_t
    # on an i386, you find it is an unsigned int, which makes the
    # unsigned version the right one; but both /etc/passwd and
    # /etc/master.passwd contain negative numbers.
    $want{UniqueID}{mung} = $want{PrimaryGroupID}{mung} = sub {
	unpack 'L', pack 'l', $_[0]};

    foreach my $dscl (@@dscl) {
	next unless -x $dscl;
	next unless open my $fh, '-|', "$dscl . -readall /Users @@{[keys %want]} 2>/dev/null";
	my @@lines;
	my @@rec;
	while (<$fh>) {
	    chomp;
	    if ($_ eq '-') {
		if (@@rec) {
		    # Some records do not have all items. In particular,
		    # the macports user has no real name. Here it's an undef,
		    # in the password file it becomes an empty string.
		    no warnings 'uninitialized';
		    push @@lines, join (':', @@rec) . "\n";
		    @@rec = ();
		}
		next;
	    }
	    my ($name, $value) = split ':\s+', $_, 2;
	    unless (defined $value) {
		s/:$//;
		$name = $_;
		$value = <$fh>;
		chomp $value;
		$value =~ s/^\s+//;
	    }
	    if (defined (my $info = $want{$name})) {
		$rec[$info->{inx}] = $info->{mung}->($value);
	    }
	}
	if (@@rec) {
        # see above
        no warnings 'uninitialized';
	    push @@lines, join (':', @@rec) . "\n";
	}
	my $data = join '', @@lines;
	if (open PW, '<', \$data) { # Needs PerlIO::scalar.
	    $where = "dscl . -readall /Users";
	    last;
	}
    }
}
} # DSCL:

if (not defined $where) {
    # Try local.
    my $no_i_pwd = !$Config::Config{i_pwd} && '$Config{i_pwd} undefined';

    my $PW = "/etc/passwd";
    if (!-f $PW) {
	skip_all($no_i_pwd) if $no_i_pwd;
	skip_all("no $PW file");
    } elsif (open PW, '<', $PW) {
	if(defined <PW>) {
	    $where = $PW;
	} else {
	    skip_all($no_i_pwd) if $no_i_pwd;
	    die "\$Config{i_pwd} is defined, $PW exists but has no entries, all other approaches failed, giving up";
	}
    } else {
	die "Can't open $PW: $!";
    }
}

# By now the PW filehandle should be open and full of juicy password entries.

plan(tests => 2);

# Go through at most this many users.
# (note that the first entry has been read away by now)
my $max = 25;

my $n = 0;
my %perfect;
my %seen;

print "# where $where\n";

setpwent();

while (<PW>) {
    chomp;
    # LIMIT -1 so that users with empty shells don't fall off
    my @@s = split /:/, $_, -1;
    my ($name_s, $passwd_s, $uid_s, $gid_s, $gcos_s, $home_s, $shell_s);
    (my $v) = $Config::Config{osvers} =~ /^(\d+)/;
    if ($^O eq 'darwin' && $v < 9) {
       ($name_s, $passwd_s, $uid_s, $gid_s, $gcos_s, $home_s, $shell_s) = @@s[0,1,2,3,7,8,9];
    } else {
       ($name_s, $passwd_s, $uid_s, $gid_s, $gcos_s, $home_s, $shell_s) = @@s;
    }
    next if /^\+/; # ignore NIS includes
    if (@@s) {
	push @@{ $seen{$name_s} }, $.;
    } else {
	warn "# Your $where line $. is empty.\n";
	next;
    }
    if ($n == $max) {
	local $/;
	my $junk = <PW>;
	last;
    }
    # In principle we could whine if @@s != 7 but do we know enough
    # of passwd file formats everywhere?
    if (@@s == 7 || ($^O eq 'darwin' && @@s == 10)) {
	my @@n = getpwuid($uid_s);
	# 'nobody' et al.
	next unless @@n;
	my ($name,$passwd,$uid,$gid,$quota,$comment,$gcos,$home,$shell) = @@n;
	# Protect against one-to-many and many-to-one mappings.
	if ($name_s ne $name) {
	    @@n = getpwnam($name_s);
	    ($name,$passwd,$uid,$gid,$quota,$comment,$gcos,$home,$shell) = @@n;
	    next if $name_s ne $name;
	}
	$perfect{$name_s}++
	    if $name    eq $name_s    and
               $uid     eq $uid_s     and
# Do not compare passwords: think shadow passwords.
               $gid     eq $gid_s     and
               $gcos    eq $gcos_s    and
               $home    eq $home_s    and
               $shell   eq $shell_s;
    }
    $n++;
}

endpwent();

print "# max = $max, n = $n, perfect = ", scalar keys %perfect, "\n";

SKIP: {
    skip("Found no password entries", 1) unless $n;

    if (keys %perfect == 0) {
	$max++;
	print <<EOEX;
#
# The failure of op/pwent test is not necessarily serious.
# It may fail due to local password administration conventions.
# If you are for example using both NIS and local passwords,
# test failure is possible.  Any distributed password scheme
# can cause such failures.
#
# What the pwent test is doing is that it compares the $max first
# entries of $where
# with the results of getpwuid() and getpwnam() call.  If it finds no
# matches at all, it suspects something is wrong.
# 
EOEX
    }

    cmp_ok(keys %perfect, '>', 0, "pwent test satisfactory")
	or note("(not necessarily serious: run t/op/pwent.t by itself)");
}

# Test both the scalar and list contexts.

my @@pw1;

setpwent();
for (1..$max) {
    my $pw = scalar getpwent();
    last unless defined $pw;
    push @@pw1, $pw;
}
endpwent();

my @@pw2;

setpwent();
for (1..$max) {
    my ($pw) = (getpwent());
    last unless defined $pw;
    push @@pw2, $pw;
}
endpwent();

is("@@pw1", "@@pw2",
    "getpwent() produced identical results in list and scalar contexts");

close(PW);
@


1.1
log
@Initial revision
@
text
@d5 19
a23 25
    unshift @@INC, "../lib" if -d "../lib";
    eval {my @@n = getpwuid 0};
    if ($@@ && $@@ =~ /(The \w+ function is unimplemented)/) {
	print "1..0 # Skip: $1\n";
	exit 0;
    }
    eval { require Config; import Config; };
    my $reason;
    if ($Config{'i_pwd'} ne 'define') {
	$reason = '$Config{i_pwd} undefined';
    }
    elsif (not -f "/etc/passwd" ) { # Play safe.
	$reason = 'no /etc/passwd file';
    }

    if (not defined $where) {	# Try NIS.
	foreach my $ypcat (qw(/usr/bin/ypcat /bin/ypcat /etc/ypcat)) {
	    if (-x $ypcat &&
		open(PW, "$ypcat passwd 2>/dev/null |") &&
		defined(<PW>)) {
		$where = "NIS passwd";
		undef $reason;
		last;
	    }
	}
d25 2
d28 72
a99 8
    if (not defined $where) {	# Try NetInfo.
	foreach my $nidump (qw(/usr/bin/nidump)) {
	    if (-x $nidump &&
		open(PW, "$nidump passwd . 2>/dev/null |") &&
		defined(<PW>)) {
		$where = "NetInfo passwd";
		undef $reason;
		last;
d101 13
d116 2
d119 10
a128 3
    if (not defined $where) {	# Try local.
	my $PW = "/etc/passwd";
	if (-f $PW && open(PW, $PW) && defined(<PW>)) {
d130 3
a132 1
	    undef $reason;
d134 2
a135 5
    }

    if ($reason) {	# Give up.
	print "1..0 # Skip: $reason\n";
	exit 0;
d139 1
a139 1
# By now PW filehandle should be open and full of juicy password entries.
d141 1
a141 1
print "1..1\n";
a147 1
my $tst = 1;
d151 4
d157 9
a165 2
    my @@s = split /:/;
    my ($name_s, $passwd_s, $uid_s, $gid_s, $gcos_s, $home_s, $shell_s) = @@s;
d180 2
a181 2
    if (@@s == 7) {
	@@n = getpwuid($uid_s);
d203 10
a212 3
if (keys %perfect == 0) {
    $max++;
    print <<EOEX;
d226 30
a255 8
    print "not ";
    $not = 1;
} else {
    $not = 0;
}
print "ok ", $tst++;
print "\t# (not necessarily serious: run t/op/pwent.t by itself)" if $not;
print "\n";
@


1.1.1.1
log
@virgin perl 5.6.0
@
text
@@


1.1.1.2
log
@stock perl 5.6.1
@
text
@d5 1
a5 1
    @@INC = '../lib';
d58 1
a58 1
# By now the PW filehandle should be open and full of juicy password entries.
d60 1
a60 1
print "1..2\n";
a70 1
setpwent();
d73 2
a74 8
    # LIMIT -1 so that users with empty shells don't fall off
    my @@s = split /:/, $_, -1;
    my ($name_s, $passwd_s, $uid_s, $gid_s, $gcos_s, $home_s, $shell_s);
    if ($^O eq 'darwin') {
       ($name_s, $passwd_s, $uid_s, $gid_s, $gcos_s, $home_s, $shell_s) = @@s[0,1,2,3,7,8,9];
    } else {
       ($name_s, $passwd_s, $uid_s, $gid_s, $gcos_s, $home_s, $shell_s) = @@s;
    }
d89 1
a89 1
    if (@@s == 7 || ($^O eq 'darwin' && @@s == 10)) {
a110 1
endpwent();
a135 25

# Test both the scalar and list contexts.

my @@pw1;

setpwent();
for (1..$max) {
    my $pw = scalar getpwent();
    last unless defined $pw;
    push @@pw1, $pw;
}
endpwent();

my @@pw2;

setpwent();
for (1..$max) {
    my ($pw) = (getpwent());
    last unless defined $pw;
    push @@pw2, $pw;
}
endpwent();

print "not " unless "@@pw1" eq "@@pw2";
print "ok ", $tst++, "\n";
@


1.1.1.3
log
@stock perl 5.8.0 from CPAN
@
text
@d6 1
a6 1
    eval {my @@n = getpwuid 0; setpwent()};
a51 12
    if (not defined $where) {      # Try NIS+
     foreach my $niscat (qw(/bin/niscat)) {
         if (-x $niscat &&
           open(PW, "$niscat passwd.org_dir 2>/dev/null |") &&
           defined(<PW>)) {
           $where = "NIS+ $niscat passwd.org_dir";
           undef $reason;
           last;
         }
     }
    }

a70 2
print "# where $where\n";

a71 1

a117 1

d120 1
a120 3
print "# max = $max, n = $n, perfect = ", scalar keys %perfect, "\n";

if (keys %perfect == 0 && $n) {
@


1.1.1.4
log
@import perl 5.10.0 from CPAN
@
text
@d92 1
a92 2
    (my $v) = $Config{osvers} =~ /^(\d+)/;
    if ($^O eq 'darwin' && $v < 9) {
@


1.1.1.5
log
@import perl 5.10.1
@
text
@a43 65
    if (not defined $where &&		# Try dscl
	$Config{useperlio} eq 'define') {	# need perlio

	# Map dscl items to passwd fields, and provide support for
	# mucking with the dscl output if we need to (and we do).
	my %want = do {
	    my $inx = 0;
	    map {$_ => {inx => $inx++, mung => sub {$_[0]}}}
		qw{RecordName Password UniqueID PrimaryGroupID
		RealName NFSHomeDirectory UserShell};
	};

	# The RecordName for a /User record is the username. In some
	# cases there are synonyms (e.g. _www and www), in which case we
	# get a blank-delimited list. We prefer the first entry in the
	# list because getpwnam() does.
	$want{RecordName}{mung} = sub {(split '\s+', $_[0], 2)[0]};

	# The UniqueID and PrimaryGroupID for a /User record are the
	# user ID and the primary group ID respectively. In cases where
	# the high bit is set, 'dscl' returns a negative number, whereas
	# getpwnam() returns its twos complement. This mungs the dscl
	# output to agree with what getpwnam() produces. Interestingly
	# enough, getpwuid(-2) returns the right record ('nobody'), even
	# though it returns the uid as 4294967294. If you track uid_t
	# on an i386, you find it is an unsigned int, which makes the
	# unsigned version the right one; but both /etc/passwd and
	# /etc/master.passwd contain negative numbers.
	$want{UniqueID}{mung} = $want{PrimaryGroupID}{mung} = sub {
	    unpack 'L', pack 'l', $_[0]};

	foreach my $dscl (qw(/usr/bin/dscl)) {
	    -x $dscl or next;
	    open (my $fh, '-|', join (' ', $dscl, qw{. -readall /Users},
		    keys %want, '2>/dev/null')) or next;
	    my $data;
	    my @@rec;
	    while (<$fh>) {
		chomp;
		if ($_ eq '-') {
		    @@rec and $data .= join (':', @@rec) . "\n";
		    @@rec = ();
		    next;
		}
		my ($name, $value) = split ':\s+', $_, 2;
		unless (defined $value) {
		    s/:$//;
		    $name = $_;
		    $value = <$fh>;
		    chomp $value;
		    $value =~ s/^\s+//;
		}
		if (defined (my $info = $want{$name})) {
		    $rec[$info->{inx}] = $info->{mung}->($value);
		}
	    }
	    @@rec and $data .= join (':', @@rec) . "\n";
	    if (open (PW, '<', \$data)) {
		$where = "dscl . -readall /Users";
		undef $reason;
		last;
	    }
	}
    }

@


1.1.1.6
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d6 25
a30 2
    require './test.pl';
}
d32 11
a42 2
use strict;
use warnings;
d44 2
a45 2
eval {my @@n = getpwuid 0; setpwent()};
skip_all($1) if $@@ && $@@ =~ /(The \w+ function is unimplemented)/;
d47 38
a84 67
eval { require Config; };

sub try_prog {
    my ($where, $args, @@pathnames) = @@_;
    foreach my $prog (@@pathnames) {
	next unless -x $prog;
	next unless open PW, '-|', "$prog $args 2>/dev/null";
	next unless defined <PW>;
	return $where;
    }
    return;
}

# Try NIS.
my $where = try_prog('NIS passwd', 'passwd',
		     qw(/usr/bin/ypcat /bin/ypcat /etc/ypcat));

# Try NetInfo.
$where //= try_prog('NetInfo passwd', 'passwd .', '/usr/bin/nidump');

# Try NIS+.
$where //= try_prog('NIS+', 'passwd.org_dir', '/bin/niscat');

# Try dscl
if (!defined $where && $Config::Config{useperlio}) {
    # Map dscl items to passwd fields, and provide support for
    # mucking with the dscl output if we need to (and we do).
    my %want = do {
	my $inx = 0;
	map {$_ => {inx => $inx++, mung => sub {$_[0]}}}
	    qw{RecordName Password UniqueID PrimaryGroupID
	       RealName NFSHomeDirectory UserShell};
    };

    # The RecordName for a /User record is the username. In some
    # cases there are synonyms (e.g. _www and www), in which case we
    # get a blank-delimited list. We prefer the first entry in the
    # list because getpwnam() does.
    $want{RecordName}{mung} = sub {(split '\s+', $_[0], 2)[0]};

    # The UniqueID and PrimaryGroupID for a /User record are the
    # user ID and the primary group ID respectively. In cases where
    # the high bit is set, 'dscl' returns a negative number, whereas
    # getpwnam() returns its twos complement. This mungs the dscl
    # output to agree with what getpwnam() produces. Interestingly
    # enough, getpwuid(-2) returns the right record ('nobody'), even
    # though it returns the uid as 4294967294. If you track uid_t
    # on an i386, you find it is an unsigned int, which makes the
    # unsigned version the right one; but both /etc/passwd and
    # /etc/master.passwd contain negative numbers.
    $want{UniqueID}{mung} = $want{PrimaryGroupID}{mung} = sub {
	unpack 'L', pack 'l', $_[0]};

    foreach my $dscl (qw(/usr/bin/dscl)) {
	next unless -x $dscl;
	next unless open my $fh, '-|', "$dscl . -readall /Users @@{[keys %want]} 2>/dev/null";
	my @@lines;
	my @@rec;
	while (<$fh>) {
	    chomp;
	    if ($_ eq '-') {
		if (@@rec) {
		    # Some records do not have all items. In particular,
		    # the macports user has no real name. Here it's an undef,
		    # in the password file it becomes an empty string.
		    no warnings 'uninitialized';
		    push @@lines, join (':', @@rec) . "\n";
d86 12
a98 1
		next;
d100 5
a104 7
	    my ($name, $value) = split ':\s+', $_, 2;
	    unless (defined $value) {
		s/:$//;
		$name = $_;
		$value = <$fh>;
		chomp $value;
		$value =~ s/^\s+//;
a105 11
	    if (defined (my $info = $want{$name})) {
		$rec[$info->{inx}] = $info->{mung}->($value);
	    }
	}
	if (@@rec) {
	    push @@lines, join (':', @@rec) . "\n";
	}
	my $data = join '', @@lines;
	if (open PW, '<', \$data) {
	    $where = "dscl . -readall /Users";
	    last;
a107 1
}
d109 3
a111 10
if (not defined $where) {
    # Try local.
    my $no_i_pwd = !$Config::Config{i_pwd} && '$Config{i_pwd} undefined';

    my $PW = "/etc/passwd";
    if (!-f $PW) {
	skip_all($no_i_pwd) if $no_i_pwd;
	skip_all("no $PW file");
    } elsif (open PW, '<', $PW) {
	if(defined <PW>) {
d113 1
a113 3
	} else {
	    skip_all($no_i_pwd) if $no_i_pwd;
	    die "\$Config{i_pwd} is defined, $PW exists but has no entries, all other approaches failed, giving up";
d115 17
a131 2
    } else {
	die "Can't open $PW: $!";
d137 1
a137 1
plan(tests => 2);
d144 1
d157 1
a157 1
    (my $v) = $Config::Config{osvers} =~ /^(\d+)/;
d178 1
a178 1
	my @@n = getpwuid($uid_s);
d204 3
a206 6
SKIP: {
    skip("Found no password entries", 1) unless $n;

    if (keys %perfect == 0) {
	$max++;
	print <<EOEX;
d220 8
a227 5
    }

    cmp_ok(keys %perfect, '>', 0)
	or note("(not necessarily serious: run t/op/pwent.t by itself)");
}
d251 2
a252 1
is("@@pw1", "@@pw2");
@


1.1.1.7
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@a98 2
        # see above
        no warnings 'uninitialized';
d218 1
a218 1
    cmp_ok(keys %perfect, '>', 0, "pwent test satisfactory")
d244 1
a244 2
is("@@pw1", "@@pw2",
    "getpwent() produced identical results in list and scalar contexts");
@


