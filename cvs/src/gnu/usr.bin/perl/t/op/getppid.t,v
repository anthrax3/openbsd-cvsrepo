head	1.2;
access;
symbols
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.4.0.12
	OPENBSD_6_0_BASE:1.1.1.4
	OPENBSD_5_9:1.1.1.4.0.6
	OPENBSD_5_9_BASE:1.1.1.4
	OPENBSD_5_8:1.1.1.4.0.8
	OPENBSD_5_8_BASE:1.1.1.4
	PERL_5_20_2:1.1.1.4
	OPENBSD_5_7:1.1.1.4.0.2
	OPENBSD_5_7_BASE:1.1.1.4
	PERL_5_20_1:1.1.1.4
	OPENBSD_5_6:1.1.1.4.0.4
	OPENBSD_5_6_BASE:1.1.1.4
	PERL_5_18_2:1.1.1.4
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.3.0.6
	OPENBSD_5_5_BASE:1.1.1.3
	OPENBSD_5_4:1.1.1.3.0.2
	OPENBSD_5_4_BASE:1.1.1.3
	PERL_5_16_3:1.1.1.3
	OPENBSD_5_3:1.1.1.2.0.18
	OPENBSD_5_3_BASE:1.1.1.2
	OPENBSD_5_2:1.1.1.2.0.16
	OPENBSD_5_2_BASE:1.1.1.2
	OPENBSD_5_1_BASE:1.1.1.2
	OPENBSD_5_1:1.1.1.2.0.14
	OPENBSD_5_0:1.1.1.2.0.12
	OPENBSD_5_0_BASE:1.1.1.2
	OPENBSD_4_9:1.1.1.2.0.10
	OPENBSD_4_9_BASE:1.1.1.2
	PERL_5_12_2:1.1.1.2
	OPENBSD_4_8:1.1.1.2.0.8
	OPENBSD_4_8_BASE:1.1.1.2
	OPENBSD_4_7:1.1.1.2.0.4
	OPENBSD_4_7_BASE:1.1.1.2
	PERL_5_10_1:1.1.1.2
	OPENBSD_4_6:1.1.1.2.0.6
	OPENBSD_4_6_BASE:1.1.1.2
	OPENBSD_4_5:1.1.1.2.0.2
	OPENBSD_4_5_BASE:1.1.1.2
	PERL_5_10_0:1.1.1.2
	OPENBSD_4_4:1.1.1.1.0.10
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.8
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.6
	OPENBSD_4_2_BASE:1.1.1.1
	OPENBSD_4_1:1.1.1.1.0.4
	OPENBSD_4_1_BASE:1.1.1.1
	OPENBSD_4_0:1.1.1.1.0.2
	OPENBSD_4_0_BASE:1.1.1.1
	PERL_5_8_8:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.33.41;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	7JLVNm1wwPgqSqTa;

1.1
date	2006.03.28.18.49.44;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.03.28.18.49.44;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2008.09.29.17.19.00;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2013.03.25.20.09.35;	author sthen;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.03.24.14.59.10;	author afresh1;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Apply local patches - perl-5.24.1
@
text
@#!./perl

# Test that getppid() follows UNIX semantics: when the parent process
# dies, the child is reparented to the init process
# The init process is usually 1, but doesn't have to be, and there's no
# standard way to find out what it is, so the only portable way to go it so
# attempt 2 reparentings and see if the PID both orphaned grandchildren get is
# the same. (and not ours)

BEGIN {
    chdir 't' if -d 't';
    @@INC = qw(../lib);
}

use strict;

BEGIN {
    require './test.pl';
    skip_all_without_config(qw(d_pipe d_fork d_waitpid d_getppid));
    plan (8);
}

# No, we don't want any zombies. kill 0, $ppid spots zombies :-(
$SIG{CHLD} = 'IGNORE';

sub fork_and_retrieve {
    my $which = shift;
    pipe my ($r, $w) or die "pipe: $!\n";
    my $pid = fork; defined $pid or die "fork: $!\n";

    if ($pid) {
	# parent
	close $w or die "close: $!\n";
	$_ = <$r>;
	chomp;
	die "Garbled output '$_'"
	    unless my ($how, $first, $second) = /^([a-z]+),(\d+),(\d+)\z/;
	cmp_ok ($first, '>=', 1, "Parent of $which grandchild");
	my $message = "grandchild waited until '$how'";
	cmp_ok ($second, '>=', 1, "New parent of orphaned $which grandchild")
	    ? note ($message) : diag ($message);

	SKIP: {
	    skip("Orphan processes are not reparented on QNX", 1)
		if $^O eq 'nto';
	    isnt($first, $second,
                 "Orphaned $which grandchild got a new parent");
	}
	return $second;
    }
    else {
	# child
	# Prevent test.pl from thinking that we failed to run any tests.
	$::NO_ENDING = 1;
	close $r or die "close: $!\n";

	pipe my ($r2, $w2) or die "pipe: $!\n";
	pipe my ($r3, $w3) or die "pipe: $!\n";
	my $pid2 = fork; defined $pid2 or die "fork: $!\n";
	if ($pid2) {
	    close $w or die "close: $!\n";
	    close $w2 or die "close: $!\n";
	    close $r3 or die "close: $!\n";
	    # Wait for our child to signal that it's read our PID:
	    <$r2>;
	    # Implicit close of $w3:
	    exit 0;
	}
	else {
	    # grandchild
	    close $r2 or die "close: $!\n";
	    close $w3 or die "close: $!\n";
	    my $ppid1 = getppid();
	    # kill 0 isn't portable:
	    my $can_kill0 = eval {
		kill 0, $ppid1;
	    };
	    my $how = $can_kill0 ? 'undead' : 'sleep';

	    # Tell immediate parent to exit:
	    close $w2 or die "close: $!\n";
	    # Wait for it to (start to) exit:
	    <$r3>;
	    # Which sadly isn't enough to be sure that it has exited - often we
	    # get switched in during its shutdown, after $w3 closes but before
	    # it exits and we get reparented.
	    if ($can_kill0) {
		# use kill 0 where possible. Try 10 times, then give up:
		for (0..9) {
		    my $got = kill 0, $ppid1;
		    die "kill: $!" unless defined $got;
		    if (!$got) {
			$how = 'kill';
			last;
		    }
		    sleep 1;
		}
	    } else {
		# Fudge it by waiting a bit more:
		sleep 3;
	    }
	    my $ppid2 = getppid();
	    print $w "$how,$ppid1,$ppid2\n";
	}
	exit 0;
    }
}

my $first = fork_and_retrieve("first");
my $second = fork_and_retrieve("second");
SKIP: {
    skip ("Orphan processes are not reparented on QNX", 1) if $^O eq 'nto';
    is ($first, $second, "Both orphaned grandchildren get the same new parent");
}
isnt ($first, $$, "And that new parent isn't this process");
@


1.1
log
@Initial revision
@
text
@d4 5
a8 1
# dies, the child is reparented to the init process (pid 1).
a15 1
use Config;
d18 3
a20 7
    for my $syscall (qw(pipe fork waitpid getppid)) {
	if (!$Config{"d_$syscall"}) {
	    print "1..0 # Skip: no $syscall\n";
	    exit;
	}
    }
    print "1..3\n";
d23 7
a29 2
pipe my ($r, $w) or die "pipe: $!\n";
my $pid = fork; defined $pid or die "fork: $!\n";
d31 19
a49 13
if ($pid) {
    # parent
    close $w;
    waitpid($pid, 0) == $pid or die "waitpid: $!\n";
    print <$r>;
}
else {
    # child
    close $r;
    my $pid2 = fork; defined $pid2 or die "fork: $!\n";
    if ($pid2) {
	close $w;
	sleep 1;
d52 54
a105 10
	# grandchild
	my $ppid1 = getppid();
	print $w "not " if $ppid1 <= 1;
	print $w "ok 1 # ppid1=$ppid1\n";
	sleep 2;
	my $ppid2 = getppid();
	print $w "not " if $ppid1 == $ppid2;
	print $w "ok 2 # ppid2=$ppid2, ppid1!=ppid2\n";
	print $w "not " if $ppid2 != 1;
	print $w "ok 3 # ppid2=1\n";
a106 1
    exit 0;
d108 8
@


1.1.1.1
log
@perl 5.8.8 import
@
text
@@


1.1.1.2
log
@import perl 5.10.0 from CPAN
@
text
@d4 1
a4 5
# dies, the child is reparented to the init process
# The init process is usually 1, but doesn't have to be, and there's no
# standard way to find out what it is, so the only portable way to go it so
# attempt 2 reparentings and see if the PID both orphaned grandchildren get is
# the same. (and not ours)
d21 1
a21 2
    require './test.pl';
    plan (8);
d24 2
a25 4
sub fork_and_retrieve {
    my $which = shift;
    pipe my ($r, $w) or die "pipe: $!\n";
    my $pid = fork; defined $pid or die "fork: $!\n";
d27 11
a37 2
    if ($pid) {
	# parent
d39 1
a39 13
	$_ = <$r>;
	chomp;
	die "Garbled output '$_'"
	    unless my ($first, $second) = /^(\d+),(\d+)\z/;
	cmp_ok ($first, '>=', 1, "Parent of $which grandchild");
	cmp_ok ($second, '>=', 1, "New parent of orphaned $which grandchild");
	SKIP: {
	    skip("Orphan processes are not reparented on QNX", 1)
		if $^O eq 'nto';
	    isnt($first, $second,
                 "Orphaned $which grandchild got a new parent");
	}
	return $second;
d42 10
a51 19
	# child
	# Prevent test.pl from thinking that we failed to run any tests.
	$::NO_ENDING = 1;
	close $r;

	my $pid2 = fork; defined $pid2 or die "fork: $!\n";
	if ($pid2) {
	    close $w;
	    sleep 1;
	}
	else {
	    # grandchild
	    my $ppid1 = getppid();
	    # Wait for immediate parent to exit
	    sleep 2;
	    my $ppid2 = getppid();
	    print $w "$ppid1,$ppid2\n";
	}
	exit 0;
d53 1
a54 8

my $first = fork_and_retrieve("first");
my $second = fork_and_retrieve("second");
SKIP: {
    skip ("Orphan processes are not reparented on QNX", 1) if $^O eq 'nto';
    is ($first, $second, "Both orphaned grandchildren get the same new parent");
}
isnt ($first, $$, "And that new parent isn't this process");
@


1.1.1.3
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d16 1
d19 6
a25 1
    skip_all_without_config(qw(d_pipe d_fork d_waitpid d_getppid));
@


1.1.1.4
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@a22 3
# No, we don't want any zombies. kill 0, $ppid spots zombies :-(
$SIG{CHLD} = 'IGNORE';

d30 1
a30 1
	close $w or die "close: $!\n";
d34 1
a34 1
	    unless my ($how, $first, $second) = /^([a-z]+),(\d+),(\d+)\z/;
d36 1
a36 4
	my $message = "grandchild waited until '$how'";
	cmp_ok ($second, '>=', 1, "New parent of orphaned $which grandchild")
	    ? note ($message) : diag ($message);

d49 1
a49 1
	close $r or die "close: $!\n";
a50 2
	pipe my ($r2, $w2) or die "pipe: $!\n";
	pipe my ($r3, $w3) or die "pipe: $!\n";
d53 2
a54 7
	    close $w or die "close: $!\n";
	    close $w2 or die "close: $!\n";
	    close $r3 or die "close: $!\n";
	    # Wait for our child to signal that it's read our PID:
	    <$r2>;
	    # Implicit close of $w3:
	    exit 0;
a57 2
	    close $r2 or die "close: $!\n";
	    close $w3 or die "close: $!\n";
d59 2
a60 28
	    # kill 0 isn't portable:
	    my $can_kill0 = eval {
		kill 0, $ppid1;
	    };
	    my $how = $can_kill0 ? 'undead' : 'sleep';

	    # Tell immediate parent to exit:
	    close $w2 or die "close: $!\n";
	    # Wait for it to (start to) exit:
	    <$r3>;
	    # Which sadly isn't enough to be sure that it has exited - often we
	    # get switched in during its shutdown, after $w3 closes but before
	    # it exits and we get reparented.
	    if ($can_kill0) {
		# use kill 0 where possible. Try 10 times, then give up:
		for (0..9) {
		    my $got = kill 0, $ppid1;
		    die "kill: $!" unless defined $got;
		    if (!$got) {
			$how = 'kill';
			last;
		    }
		    sleep 1;
		}
	    } else {
		# Fudge it by waiting a bit more:
		sleep 2;
	    }
d62 1
a62 1
	    print $w "$how,$ppid1,$ppid2\n";
@


