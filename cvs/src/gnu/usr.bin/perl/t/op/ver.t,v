head	1.2;
access;
symbols
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.8.0.10
	OPENBSD_6_0_BASE:1.1.1.8
	OPENBSD_5_9:1.1.1.8.0.4
	OPENBSD_5_9_BASE:1.1.1.8
	OPENBSD_5_8:1.1.1.8.0.6
	OPENBSD_5_8_BASE:1.1.1.8
	PERL_5_20_2:1.1.1.8
	OPENBSD_5_7:1.1.1.8.0.2
	OPENBSD_5_7_BASE:1.1.1.8
	PERL_5_20_1:1.1.1.8
	OPENBSD_5_6:1.1.1.7.0.4
	OPENBSD_5_6_BASE:1.1.1.7
	PERL_5_18_2:1.1.1.7
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.6.0.6
	OPENBSD_5_5_BASE:1.1.1.6
	OPENBSD_5_4:1.1.1.6.0.2
	OPENBSD_5_4_BASE:1.1.1.6
	PERL_5_16_3:1.1.1.6
	OPENBSD_5_3:1.1.1.5.0.18
	OPENBSD_5_3_BASE:1.1.1.5
	OPENBSD_5_2:1.1.1.5.0.16
	OPENBSD_5_2_BASE:1.1.1.5
	OPENBSD_5_1_BASE:1.1.1.5
	OPENBSD_5_1:1.1.1.5.0.14
	OPENBSD_5_0:1.1.1.5.0.12
	OPENBSD_5_0_BASE:1.1.1.5
	OPENBSD_4_9:1.1.1.5.0.10
	OPENBSD_4_9_BASE:1.1.1.5
	PERL_5_12_2:1.1.1.5
	OPENBSD_4_8:1.1.1.5.0.8
	OPENBSD_4_8_BASE:1.1.1.5
	OPENBSD_4_7:1.1.1.5.0.4
	OPENBSD_4_7_BASE:1.1.1.5
	PERL_5_10_1:1.1.1.5
	OPENBSD_4_6:1.1.1.5.0.6
	OPENBSD_4_6_BASE:1.1.1.5
	OPENBSD_4_5:1.1.1.5.0.2
	OPENBSD_4_5_BASE:1.1.1.5
	PERL_5_10_0:1.1.1.5
	OPENBSD_4_4:1.1.1.4.0.20
	OPENBSD_4_4_BASE:1.1.1.4
	OPENBSD_4_3:1.1.1.4.0.18
	OPENBSD_4_3_BASE:1.1.1.4
	OPENBSD_4_2:1.1.1.4.0.16
	OPENBSD_4_2_BASE:1.1.1.4
	OPENBSD_4_1:1.1.1.4.0.14
	OPENBSD_4_1_BASE:1.1.1.4
	OPENBSD_4_0:1.1.1.4.0.12
	OPENBSD_4_0_BASE:1.1.1.4
	PERL_5_8_8:1.1.1.4
	OPENBSD_3_9:1.1.1.4.0.10
	OPENBSD_3_9_BASE:1.1.1.4
	OPENBSD_3_8:1.1.1.4.0.8
	OPENBSD_3_8_BASE:1.1.1.4
	OPENBSD_3_7:1.1.1.4.0.6
	OPENBSD_3_7_BASE:1.1.1.4
	PERL_5_8_6:1.1.1.4
	OPENBSD_3_6:1.1.1.4.0.4
	OPENBSD_3_6_BASE:1.1.1.4
	PERL_5_8_5:1.1.1.4
	PERL_5_8_3:1.1.1.4
	OPENBSD_3_5:1.1.1.4.0.2
	OPENBSD_3_5_BASE:1.1.1.4
	PERL_5_8_2:1.1.1.4
	OPENBSD_3_4:1.1.1.3.0.4
	OPENBSD_3_4_BASE:1.1.1.3
	OPENBSD_3_3:1.1.1.3.0.2
	OPENBSD_3_3_BASE:1.1.1.3
	PERL_5_8_0:1.1.1.3
	OPENBSD_3_2:1.1.1.2.0.6
	OPENBSD_3_2_BASE:1.1.1.2
	OPENBSD_3_1:1.1.1.2.0.4
	OPENBSD_3_1_BASE:1.1.1.2
	OPENBSD_3_0:1.1.1.2.0.2
	OPENBSD_3_0_BASE:1.1.1.2
	PERL_5_6_1:1.1.1.2
	OPENBSD_2_9:1.1.1.1.0.6
	OPENBSD_2_9_BASE:1.1.1.1
	OPENBSD_2_8:1.1.1.1.0.4
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.2
	OPENBSD_2_7_BASE:1.1.1.1
	PERL_5_6_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.32.20;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2000.04.06.16.10.53;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.04.06.16.10.53;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.05.24.18.25.49;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.10.27.22.15.11;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.12.03.02.44.33;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2008.09.29.17.19.02;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2013.03.25.20.09.37;	author sthen;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2014.03.24.14.59.11;	author afresh1;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2014.11.17.20.53.18;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl

BEGIN {
    chdir 't' if -d 't';
    @@INC = qw(. ../lib);
    $SIG{'__WARN__'} = sub { warn $_[0] if $DOWARN };
    require "./test.pl"; require "./charset_tools.pl";
}

$DOWARN = 1; # enable run-time warnings now

use Config;

plan( tests => 58 );

eval 'use v5.5.640';
is( $@@, '', "use v5.5.640; $@@");

require_ok('v5.5.640');

# printing characters should work
if ($::IS_ASCII) { # ASCII
    is('ok ',v111.107.32,'ASCII printing characters');

    # hash keys too
    $h{v111.107} = "ok";
    is('ok',$h{v111.107},'ASCII hash keys');
}
else { # EBCDIC
    is('ok ',v150.146.64,'EBCDIC printing characters');

    # hash keys too
    $h{v150.146} = "ok";
    is('ok',$h{v150.146},'EBCDIC hash keys');
}

# poetry optimization should also
sub v77 { "ok" }
$x = v77;
is('ok',$x,'poetry optimization');

# but not when dots are involved
if ($::IS_ASCII) { # ASCII
    $x = v77.78.79;
}
else {
    $x = v212.213.214;
}
is($x, 'MNO','poetry optimization with dots');

is(v1.20.300.4000, "\x{1}\x{14}\x{12c}\x{fa0}",'compare embedded \x{} string');

#
# now do the same without the "v"
eval 'use 5.5.640';
is( $@@, '', "use 5.5.640; $@@");

require_ok('5.5.640');

# hash keys too
if ($::IS_ASCII) { # ASCII
    $h{111.107.32} = "ok";
}
else {
    $h{150.146.64} = "ok";
}
is('ok',$h{ok },'hash keys w/o v');

if ($::IS_ASCII) { # ASCII
    $x = 77.78.79;
}
else {
    $x = 212.213.214;
}
is($x, 'MNO','poetry optimization with dots w/o v');

is(1.20.300.4000, "\x{1}\x{14}\x{12c}\x{fa0}",'compare embedded \x{} string w/o v');

# test sprintf("%vd"...) etc
if ($::IS_ASCII) { # ASCII
    is(sprintf("%vd", "Perl"), '80.101.114.108', 'ASCII sprintf("%vd", "Perl")');
}
else {
    is(sprintf("%vd", "Perl"), '215.133.153.147', 'EBCDIC sprintf("%vd", "Perl")');
}

is(sprintf("%vd", v1.22.333.4444), '1.22.333.4444', 'sprintf("%vd", v1.22.333.4444)');

if ($::IS_ASCII) { # ASCII
    is(sprintf("%vx", "Perl"), '50.65.72.6c', 'ASCII sprintf("%vx", "Perl")');
}
else {
    is(sprintf("%vx", "Perl"), 'd7.85.99.93', 'EBCDIC sprintf("%vx", "Perl")');
}

is(sprintf("%vX", 1.22.333.4444), '1.16.14D.115C','ASCII sprintf("%vX", 1.22.333.4444)');

if ($::IS_ASCII) { # ASCII
    is(sprintf("%#*vo", ":", "Perl"), '0120:0145:0162:0154', 'ASCII sprintf("%vo", "Perl")');
}
else {
    is(sprintf("%#*vo", ":", "Perl"), '0327:0205:0231:0223', 'EBCDIC sprintf("%vo", "Perl")');
}

is(sprintf("%*vb", "##", v1.22.333.4444),
    '1##10110##101001101##1000101011100', 'sprintf("%vb", 1.22.333.4444)');

is(sprintf("%vd", join("", map { chr }
			 unpack 'U*', pack('U*',2001,2002,2003))),
     '2001.2002.2003','unpack/pack U*');

{
    use bytes;

    if ($::IS_ASCII) { # ASCII
	is(sprintf("%vd", "Perl"), '80.101.114.108', 'ASCII sprintf("%vd", "Perl") w/use bytes');
    }
    else {
	is(sprintf("%vd", "Perl"), '215.133.153.147', 'EBCDIC sprintf("%vd", "Perl") w/use bytes');
    }

    if ($::IS_ASCII) { # ASCII
	is(sprintf("%vd", 1.22.333.4444), '1.22.197.141.225.133.156', 'ASCII sprintf("%vd", v1.22.333.4444 w/use bytes');
    }
    else {
	is(sprintf("%vd", 1.22.333.4444), '1.22.142.84.187.81.112', 'EBCDIC sprintf("%vd", v1.22.333.4444 w/use bytes');
    }

    if ($::IS_ASCII) { # ASCII
	is(sprintf("%vx", "Perl"), '50.65.72.6c', 'ASCII sprintf("%vx", "Perl")');
    }
    else {
	is(sprintf("%vx", "Perl"), 'd7.85.99.93', 'EBCDIC sprintf("%vx", "Perl")');
    }

    if ($::IS_ASCII) { # ASCII
	is(sprintf("%vX", v1.22.333.4444), '1.16.C5.8D.E1.85.9C', 'ASCII sprintf("%vX", v1.22.333.4444)');
    }
    else {
	is(sprintf("%vX", v1.22.333.4444), '1.16.8E.54.BB.51.70', 'EBCDIC sprintf("%vX", v1.22.333.4444)');
    }

    if ($::IS_ASCII) { # ASCII
	is(sprintf("%#*vo", ":", "Perl"), '0120:0145:0162:0154', 'ASCII sprintf("%#*vo", ":", "Perl")');
    }
    else {
	is(sprintf("%#*vo", ":", "Perl"), '0327:0205:0231:0223', 'EBCDIC sprintf("%#*vo", ":", "Perl")');
    }

    if ($::IS_ASCII) { # ASCII
	is(sprintf("%*vb", "##", v1.22.333.4444),
	     '1##10110##11000101##10001101##11100001##10000101##10011100',
	     'ASCII sprintf("%*vb", "##", v1.22.333.4444)');
    }
    else {
	is(sprintf("%*vb", "##", v1.22.333.4444),
            '1##10110##10001110##1010100##10111011##1010001##1110000',
	    'EBCDIC sprintf("%*vb", "##", v1.22.333.4444)');
    }
}

{
    # bug id 20000323.056

    is( "\x{41}",      +v65, 'bug id 20000323.056');
    is( "\x41",        +v65, 'bug id 20000323.056');
    is( "\x{c8}",     +v200, 'bug id 20000323.056');
    is( "\xc8",       +v200, 'bug id 20000323.056');
    is( "\x{221b}",  +v8731, 'bug id 20000323.056');
}

# See if the things Camel-III says are true: 29..33

# Chapter 2 pp67/68
my $vs = v1.20.300.4000;
is($vs,"\x{1}\x{14}\x{12c}\x{fa0}","v-string ne \\x{}");
is($vs,chr(1).chr(20).chr(300).chr(4000),"v-string ne chr()");
is('foo',($::IS_EBCDIC ? v134.150.150 : v102.111.111),"v-string ne ''");

# Chapter 15, pp403

# See if sane addr and gethostbyaddr() work
eval { require Socket; gethostbyaddr(v127.0.0.1, &Socket::AF_INET) };
if ($@@) {
    # No - so do not test insane fails.
    $@@ =~ s/\n/\n# /g;
}
SKIP: {
    skip("No Socket::AF_INET # $@@") if $@@;
    my $ip   = v2004.148.0.1;
    my $host;
    eval { $host = gethostbyaddr($ip,&Socket::AF_INET) };
    like($@@, qr/Wide character/, "Non-bytes leak to gethostbyaddr");
}

# Chapter 28, pp671
ok(v5.6.0 lt v5.7.0, "v5.6.0 lt v5.7.0");

# part of 20000323.059
is(v200, chr(200),      "v200 eq chr(200)"      );
is(v200, +v200,         "v200 eq +v200"         );
is(v200, eval( "v200"), 'v200 eq "v200"'        );
is(v200, eval("+v200"), 'v200 eq eval("+v200")' );

# Tests for string/numeric value of $] itself
my ($revision,$version,$subversion) = split /\./, sprintf("%vd",$^V);

# $^V always displays the leading 'v' but we don't want that here
$revision =~ s/^v//;

print "# revision   = '$revision'\n";
print "# version    = '$version'\n";
print "# subversion = '$subversion'\n";

my $v = sprintf("%d.%.3d%.3d",$revision,$version,$subversion);

print "# v = '$v'\n";
print "# ] = '$]'\n";

is( $v, "$]", qq{\$^V eq "\$]"});

$v = $revision + $version/1000 + $subversion/1000000;

ok( abs($v - $]) < 10**-8 , "\$^V == \$] (numeric)" );

{

  no warnings 'deprecated'; # These are above IV_MAX on 32 bit machines
  # [ID 20010902.001] check if v-strings handle full UV range or not
  if ( $Config{'uvsize'} >= 4 ) {
    is(  sprintf("%vd", eval 'v2147483647.2147483648'),   '2147483647.2147483648', 'v-string > IV_MAX[32-bit]' );
    is(  sprintf("%vd", eval 'v3141592653'),              '3141592653',            'IV_MAX < v-string < UV_MAX[32-bit]');
    is(  sprintf("%vd", eval 'v4294967295'),              '4294967295',            'v-string == UV_MAX[32-bit] - 1');
  }

  SKIP: {
    skip("No quads", 3) if $Config{uvsize} < 8;

    if ( $Config{'uvsize'} >= 8 ) {
      is(  sprintf("%vd", eval 'v9223372036854775807.9223372036854775808'),   '9223372036854775807.9223372036854775808', 'v-string > IV_MAX[64-bit]' );
      is(  sprintf("%vd", eval 'v17446744073709551615'),                      '17446744073709551615',                    'IV_MAX < v-string < UV_MAX[64-bit]');
      is(  sprintf("%vd", eval 'v18446744073709551615'),                      '18446744073709551615',                    'v-string == UV_MAX[64-bit] - 1');
    }
  }
}

# Tests for magic v-strings 

$v = 1.2.3;
is( ref(\$v), 'VSTRING', 'v-string objects' );

$v = v1.2_3;
is( ref(\$v), 'VSTRING', 'v-string objects with v' );
is( sprintf("%vd", $v), '1.23', 'v-string ignores underscores' );

# [perl #16010]
%h = (v65 => 42);
ok( exists $h{v65}, "v-stringness is not engaged for vX" );
%h = (v65.66 => 42);
ok( exists $h{chr(65).chr(66)}, "v-stringness is engaged for vX.Y" );
%h = (65.66.67 => 42);
ok( exists $h{chr(65).chr(66).chr(67)}, "v-stringness is engaged for X.Y.Z" );

{
    local $|;
    $| = v0;
    $| = 1;
    --$|; --$|;
    is $|, 1, 'clobbering vstrings does not clobber all magic';
}

$a = $::IS_EBCDIC ? v134 : v102; $a =~ s/f/f/;
is ref \$a, 'SCALAR',
  's/// flattens vstrings even when the subst results in the same value';
$a = $::IS_EBCDIC ? v134 : v102; $a =~ y/f/g/;
is ref \$a, 'SCALAR', 'y/// flattens vstrings';

sub { $_[0] = v3;
      is ref \$h{nonexistent}, 'VSTRING', 'defelems can pass vstrings' }
->($h{nonexistent});

# The following tests whether v-strings are correctly
# interpreted by the tokeniser when it's in a XTERMORDORDOR
# state (fittingly, the only tokeniser state to contain the
# word MORDOR).

*{"\3"} = *DATA;
is( (readline v3), "This is what we expect to see!\n", "v-strings even work in Mordor" );

__DATA__
This is what we expect to see!
@


1.1
log
@Initial revision
@
text
@d5 3
a7 1
    unshift @@INC, "../lib";
d10 1
a10 1
print "1..22\n";
d12 1
a12 1
my $test = 1;
d14 6
a19 3
use v5.5.640;
require v5.5.640;
print "ok $test\n";  ++$test;
d22 9
a30 3
print v111;
print v107.32;
print "$test\n"; ++$test;
d32 4
a35 3
# hash keys too
$h{v111.107} = "ok";
print "$h{ok} $test\n"; ++$test;
d40 1
a40 1
print "$x $test\n"; ++$test;
d43 7
a49 3
$x = v77.78.79;
print "not " unless $x eq "MNO";
print "ok $test\n";  ++$test;
d51 1
a51 2
print "not " unless v1.20.300.4000 eq "\x{1}\x{14}\x{12c}\x{fa0}";
print "ok $test\n";  ++$test;
d55 4
a58 3
use 5.5.640;
require 5.5.640;
print "ok $test\n";  ++$test;
d61 7
a67 2
$h{111.107.32} = "ok";
print "$h{ok } $test\n"; ++$test;
d69 7
a75 3
$x = 77.78.79;
print "not " unless $x eq "MNO";
print "ok $test\n";  ++$test;
d77 1
a77 2
print "not " unless 1.20.300.4000 eq "\x{1}\x{14}\x{12c}\x{fa0}";
print "ok $test\n";  ++$test;
d80 6
a85 2
print "not " unless sprintf("%vd", "Perl") eq '80.101.114.108';
print "ok $test\n";  ++$test;
d87 8
a94 2
print "not " unless sprintf("%vd", v1.22.333.4444) eq '1.22.333.4444';
print "ok $test\n";  ++$test;
d96 1
a96 2
print "not " unless sprintf("%vx", "Perl") eq '50.65.72.6c';
print "ok $test\n";  ++$test;
d98 6
a103 2
print "not " unless sprintf("%vX", 1.22.333.4444) eq '1.16.14D.115C';
print "ok $test\n";  ++$test;
d105 2
a106 2
print "not " unless sprintf("%*v#o", ":", "Perl") eq '0120:0145:0162:0154';
print "ok $test\n";  ++$test;
d108 3
a110 3
print "not " unless sprintf("%*vb", "##", v1.22.333.4444)
    eq '1##10110##101001101##1000101011100';
print "ok $test\n";  ++$test;
a113 2
    print "not " unless sprintf("%vd", "Perl") eq '80.101.114.108';
    print "ok $test\n";  ++$test;
d115 46
a160 3
    print "not " unless
        sprintf("%vd", 1.22.333.4444) eq '1.22.197.141.225.133.156';
    print "ok $test\n";  ++$test;
d162 2
a163 2
    print "not " unless sprintf("%vx", "Perl") eq '50.65.72.6c';
    print "ok $test\n";  ++$test;
d165 6
a170 2
    print "not " unless sprintf("%vX", v1.22.333.4444) eq '1.16.C5.8D.E1.85.9C';
    print "ok $test\n";  ++$test;
d172 1
a172 2
    print "not " unless sprintf("%*v#o", ":", "Perl") eq '0120:0145:0162:0154';
    print "ok $test\n";  ++$test;
d174 20
a193 3
    print "not " unless sprintf("%*vb", "##", v1.22.333.4444)
	eq '1##10110##11000101##10001101##11100001##10000101##10011100';
    print "ok $test\n";  ++$test;
d195 97
@


1.1.1.1
log
@virgin perl 5.6.0
@
text
@@


1.1.1.2
log
@stock perl 5.6.1
@
text
@d5 1
a5 1
    @@INC = '../lib';
d8 1
a8 1
print "1..28\n";
d17 7
a23 18
if (ord("\t") == 9) { # ASCII
    print v111;
    print v107.32;
    print "$test\n"; ++$test;

    # hash keys too
    $h{v111.107} = "ok";
    print "$h{ok} $test\n"; ++$test;
}
else { # EBCDIC
    print v150;
    print v146.64;
    print "$test\n"; ++$test;

    # hash keys too
    $h{v150.146} = "ok";
    print "$h{ok} $test\n"; ++$test;
}
d31 1
a31 6
if (ord("\t") == 9) { # ASCII
    $x = v77.78.79;
}
else {
    $x = v212.213.214;
}
d45 1
a45 6
if (ord("\t") == 9) { # ASCII
    $h{111.107.32} = "ok";
}
else {
    $h{150.146.64} = "ok";
}
d48 1
a48 6
if (ord("\t") == 9) { # ASCII
    $x = 77.78.79;
}
else {
    $x = 212.213.214;
}
d56 1
a56 6
if (ord("\t") == 9) { # ASCII
    print "not " unless sprintf("%vd", "Perl") eq '80.101.114.108';
}
else {
    print "not " unless sprintf("%vd", "Perl") eq '215.133.153.147';
}
d62 1
a62 6
if (ord("\t") == 9) { # ASCII
    print "not " unless sprintf("%vx", "Perl") eq '50.65.72.6c';
}
else {
    print "not " unless sprintf("%vx", "Perl") eq 'd7.85.99.93';
}
d68 1
a68 6
if (ord("\t") == 9) { # ASCII
    print "not " unless sprintf("%*v#o", ":", "Perl") eq '0120:0145:0162:0154';
}
else {
    print "not " unless sprintf("%*v#o", ":", "Perl") eq '0327:0205:0231:0223';
}
a74 5
print "not " unless sprintf("%vd", join("", map { chr }
					    unpack "U*", v2001.2002.2003))
		    eq '2001.2002.2003';
print "ok $test\n";  ++$test;

d77 1
a77 6
    if (ord("\t") == 9) { # ASCII
        print "not " unless sprintf("%vd", "Perl") eq '80.101.114.108';
    }
    else {
        print "not " unless sprintf("%vd", "Perl") eq '215.133.153.147';
    }
d84 1
a84 6
    if (ord("\t") == 9) { # ASCII
        print "not " unless sprintf("%vx", "Perl") eq '50.65.72.6c';
    }
    else {
        print "not " unless sprintf("%vx", "Perl") eq 'd7.85.99.93';
    }
d90 1
a90 6
    if (ord("\t") == 9) { # ASCII
        print "not " unless sprintf("%*v#o", ":", "Perl") eq '0120:0145:0162:0154';
    }
    else {
        print "not " unless sprintf("%*v#o", ":", "Perl") eq '0327:0205:0231:0223';
    }
a95 24
}

{
    # bug id 20000323.056

    print "not " unless "\x{41}" eq +v65;
    print "ok $test\n";
    $test++;

    print "not " unless "\x41" eq +v65;
    print "ok $test\n";
    $test++;

    print "not " unless "\x{c8}" eq +v200;
    print "ok $test\n";
    $test++;

    print "not " unless "\xc8" eq +v200;
    print "ok $test\n";
    $test++;

    print "not " unless "\x{221b}" eq v8731;
    print "ok $test\n";
    $test++;
@


1.1.1.3
log
@stock perl 5.8.0 from CPAN
@
text
@d5 1
a5 2
    @@INC = qw(. ../lib);
    $SIG{'__WARN__'} = sub { warn $_[0] if $DOWARN };
d8 1
a8 1
$DOWARN = 1; # enable run-time warnings now
d10 1
a10 1
use Config;
d12 3
a14 7
require "test.pl";
plan( tests => 47 );

eval { use v5.5.640; };
is( $@@, '', "use v5.5.640; $@@");

require_ok('v5.5.640');
d18 3
a20 1
    is('ok ',v111.107.32,'ASCII printing characters');
d24 1
a24 1
    is('ok',$h{v111.107},'ASCII hash keys');
d27 3
a29 1
    is('ok ',v150.146.64,'EBCDIC printing characters');
d33 1
a33 1
    is('ok',$h{v150.146},'EBCDIC hash keys');
d39 1
a39 1
is('ok',$x,'poetry optimization');
d48 2
a49 1
is($x, 'MNO','poetry optimization with dots');
d51 2
a52 1
is(v1.20.300.4000, "\x{1}\x{14}\x{12c}\x{fa0}",'compare embedded \x{} string');
d56 3
a58 4
eval { use 5.5.640; };
is( $@@, '', "use 5.5.640; $@@");

require_ok('5.5.640');
d67 1
a67 1
is('ok',$h{ok },'hash keys w/o v');
d75 2
a76 1
is($x, 'MNO','poetry optimization with dots w/o v');
d78 2
a79 1
is(1.20.300.4000, "\x{1}\x{14}\x{12c}\x{fa0}",'compare embedded \x{} string w/o v');
d83 1
a83 1
    is(sprintf("%vd", "Perl"), '80.101.114.108', 'ASCII sprintf("%vd", "Perl")');
d86 1
a86 1
    is(sprintf("%vd", "Perl"), '215.133.153.147', 'EBCDIC sprintf("%vd", "Perl")');
d88 1
d90 2
a91 1
is(sprintf("%vd", v1.22.333.4444), '1.22.333.4444', 'sprintf("%vd", v1.22.333.4444)');
d94 1
a94 1
    is(sprintf("%vx", "Perl"), '50.65.72.6c', 'ASCII sprintf("%vx", "Perl")');
d97 1
a97 1
    is(sprintf("%vx", "Perl"), 'd7.85.99.93', 'EBCDIC sprintf("%vx", "Perl")');
d99 1
d101 2
a102 1
is(sprintf("%vX", 1.22.333.4444), '1.16.14D.115C','ASCII sprintf("%vX", 1.22.333.4444)');
d105 1
a105 1
    is(sprintf("%#*vo", ":", "Perl"), '0120:0145:0162:0154', 'ASCII sprintf("%vo", "Perl")');
d108 1
a108 1
    is(sprintf("%#*vo", ":", "Perl"), '0327:0205:0231:0223', 'EBCDIC sprintf("%vo", "Perl")');
d110 1
d112 3
a114 2
is(sprintf("%*vb", "##", v1.22.333.4444),
    '1##10110##101001101##1000101011100', 'sprintf("%vb", 1.22.333.4444)');
d116 4
a119 3
is(sprintf("%vd", join("", map { chr }
			 unpack 'U*', pack('U*',2001,2002,2003))),
     '2001.2002.2003','unpack/pack U*');
a122 1

d124 1
a124 1
	is(sprintf("%vd", "Perl"), '80.101.114.108', 'ASCII sprintf("%vd", "Perl") w/use bytes');
d127 1
a127 1
	is(sprintf("%vd", "Perl"), '215.133.153.147', 'EBCDIC sprintf("%vd", "Perl") w/use bytes');
d129 1
d131 3
a133 6
    if (ord("\t") == 9) { # ASCII
	is(sprintf("%vd", 1.22.333.4444), '1.22.197.141.225.133.156', 'ASCII sprintf("%vd", v1.22.333.4444 w/use bytes');
    }
    else {
	is(sprintf("%vd", 1.22.333.4444), '1.22.142.84.187.81.112', 'EBCDIC sprintf("%vd", v1.22.333.4444 w/use bytes');
    }
d136 1
a136 1
	is(sprintf("%vx", "Perl"), '50.65.72.6c', 'ASCII sprintf("%vx", "Perl")');
d139 1
a139 1
	is(sprintf("%vx", "Perl"), 'd7.85.99.93', 'EBCDIC sprintf("%vx", "Perl")');
d141 1
d143 2
a144 6
    if (ord("\t") == 9) { # ASCII
	is(sprintf("%vX", v1.22.333.4444), '1.16.C5.8D.E1.85.9C', 'ASCII sprintf("%vX", v1.22.333.4444)');
    }
    else {
	is(sprintf("%vX", v1.22.333.4444), '1.16.8E.54.BB.51.70', 'EBCDIC sprintf("%vX", v1.22.333.4444)');
    }
d147 1
a147 1
	is(sprintf("%#*vo", ":", "Perl"), '0120:0145:0162:0154', 'ASCII sprintf("%#*vo", ":", "Perl")');
d150 1
a150 1
	is(sprintf("%#*vo", ":", "Perl"), '0327:0205:0231:0223', 'EBCDIC sprintf("%#*vo", ":", "Perl")');
d152 1
d154 3
a156 10
    if (ord("\t") == 9) { # ASCII
	is(sprintf("%*vb", "##", v1.22.333.4444),
	     '1##10110##11000101##10001101##11100001##10000101##10011100',
	     'ASCII sprintf("%*vb", "##", v1.22.333.4444)');
    }
    else {
	is(sprintf("%*vb", "##", v1.22.333.4444),
            '1##10110##10001110##1010100##10111011##1010001##1110000',
	    'EBCDIC sprintf("%*vb", "##", v1.22.333.4444)');
    }
d162 19
a180 82
    is( "\x{41}",      +v65, 'bug id 20000323.056');
    is( "\x41",        +v65, 'bug id 20000323.056');
    is( "\x{c8}",     +v200, 'bug id 20000323.056');
    is( "\xc8",       +v200, 'bug id 20000323.056');
    is( "\x{221b}",  +v8731, 'bug id 20000323.056');
}

# See if the things Camel-III says are true: 29..33

# Chapter 2 pp67/68
my $vs = v1.20.300.4000;
is($vs,"\x{1}\x{14}\x{12c}\x{fa0}","v-string ne \\x{}");
is($vs,chr(1).chr(20).chr(300).chr(4000),"v-string ne chr()");
is('foo',((chr(193) eq 'A') ? v134.150.150 : v102.111.111),"v-string ne ''");

# Chapter 15, pp403

# See if sane addr and gethostbyaddr() work
eval { require Socket; gethostbyaddr(v127.0.0.1, &Socket::AF_INET) };
if ($@@) {
    # No - so do not test insane fails.
    $@@ =~ s/\n/\n# /g;
}
SKIP: {
    skip("No Socket::AF_INET # $@@") if $@@;
    my $ip   = v2004.148.0.1;
    my $host;
    eval { $host = gethostbyaddr($ip,&Socket::AF_INET) };
    like($@@, qr/Wide character/, "Non-bytes leak to gethostbyaddr");
}

# Chapter 28, pp671
ok(v5.6.0 lt v5.7.0, "v5.6.0 lt v5.7.0");

# part of 20000323.059
is(v200, chr(200),      "v200 eq chr(200)"      );
is(v200, +v200,         "v200 eq +v200"         );
is(v200, eval( "v200"), 'v200 eq "v200"'        );
is(v200, eval("+v200"), 'v200 eq eval("+v200")' );

# Tests for string/numeric value of $] itself
my ($revision,$version,$subversion) = split '\.', sprintf("%vd",$^V);

print "# revision   = '$revision'\n";
print "# version    = '$version'\n";
print "# subversion = '$subversion'\n";

my $v = sprintf("%d.%.3d%.3d",$revision,$version,$subversion);

print "# v = '$v'\n";
print "# ] = '$]'\n";

$v =~ s/000$// if $subversion == 0;

print "# v = '$v'\n";

ok( $v eq "$]", qq{\$^V eq "\$]"});

$v = $revision + $version/1000 + $subversion/1000000;

ok( $v == $], "\$^V == \$] (numeric)" );

SKIP: {
  skip("In EBCDIC the v-string components cannot exceed 2147483647", 6)
    if ord "A" == 193;

  # [ID 20010902.001] check if v-strings handle full UV range or not
  if ( $Config{'uvsize'} >= 4 ) {
    is(  sprintf("%vd", eval 'v2147483647.2147483648'),   '2147483647.2147483648', 'v-string > IV_MAX[32-bit]' );
    is(  sprintf("%vd", eval 'v3141592653'),              '3141592653',            'IV_MAX < v-string < UV_MAX[32-bit]');
    is(  sprintf("%vd", eval 'v4294967295'),              '4294967295',            'v-string == UV_MAX[32-bit] - 1');
  }

  SKIP: {
    skip("No quads", 3) if $Config{uvsize} < 8;

    if ( $Config{'uvsize'} >= 8 ) {
      is(  sprintf("%vd", eval 'v9223372036854775807.9223372036854775808'),   '9223372036854775807.9223372036854775808', 'v-string > IV_MAX[64-bit]' );
      is(  sprintf("%vd", eval 'v17446744073709551615'),                      '17446744073709551615',                    'IV_MAX < v-string < UV_MAX[64-bit]');
      is(  sprintf("%vd", eval 'v18446744073709551615'),                      '18446744073709551615',                    'v-string == UV_MAX[64-bit] - 1');
    }
  }
@


1.1.1.4
log
@perl 5.8.2 from CPAN
@
text
@d14 1
a14 1
plan( tests => 53 );
d16 1
a16 1
eval 'use v5.5.640';
d55 1
a55 1
eval 'use 5.5.640';
a247 19

# Tests for magic v-strings

$v = 1.2.3;
is( ref(\$v), 'SCALAR', 'v-strings are just scalars' );

$v = v1.2_3;
is( ref(\$v), 'SCALAR', 'v-strings with v are just scalars' );
is( sprintf("%vd", $v), '1.23', 'v-string ignores underscores' );

# [perl #16010]
%h = (v65 => 42);
ok( exists $h{v65}, "v-stringness is not engaged for vX" );
%h = (v65.66 => 42);
ok( exists $h{chr(65).chr(66)}, "v-stringness is engaged for vX.Y" );
%h = (65.66.67 => 42);
ok( exists $h{chr(65).chr(66).chr(67)}, "v-stringness is engaged for X.Y.Z" );


@


1.1.1.5
log
@import perl 5.10.0 from CPAN
@
text
@d14 1
a14 1
plan( tests => 54 );
d206 1
a206 4
my ($revision,$version,$subversion) = split /\./, sprintf("%vd",$^V);

# $^V always displays the leading 'v' but we don't want that here
$revision =~ s/^v//;
d217 5
a221 1
is( $v, "$]", qq{\$^V eq "\$]"});
d225 1
a225 1
ok( abs($v - $]) < 10**-8 , "\$^V == \$] (numeric)" );
d249 1
a249 1
# Tests for magic v-strings 
d252 1
a252 1
is( ref(\$v), 'VSTRING', 'v-string objects' );
d255 1
a255 1
is( ref(\$v), 'VSTRING', 'v-string objects with v' );
a266 10
# The following tests whether v-strings are correctly
# interpreted by the tokeniser when it's in a XTERMORDORDOR
# state (fittingly, the only tokeniser state to contain the
# word MORDOR).

*{"\3"} = *DATA;
is( (readline v3), "This is what we expect to see!\n", "v-strings even work in Mordor" );

__DATA__
This is what we expect to see!
@


1.1.1.6
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@a6 1
    require "test.pl";
d13 2
a14 1
plan( tests => 55 );
a263 8

{
    local $|;
    $| = v0;
    $| = 1;
    --$|; --$|;
    is $|, 1, 'clobbering vstrings does not clobber all magic';
}
@


1.1.1.7
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d14 1
a14 1
plan( tests => 57 );
a272 5
$a = v102; $a =~ s/f/f/;
is ref \$a, 'SCALAR',
  's/// flattens vstrings even when the subst results in the same value';
$a = v102; $a =~ y/f/g/;
is ref \$a, 'SCALAR', 'y/// flattens vstrings';
@


1.1.1.8
log
@Import perl-5.20.1
@
text
@d14 1
a14 1
plan( tests => 58 );
a277 4

sub { $_[0] = v3;
      is ref \$h{nonexistent}, 'VSTRING', 'defelems can pass vstrings' }
->($h{nonexistent});
@


