head	1.2;
access;
symbols
	OPENBSD_6_2:1.2.0.2
	OPENBSD_6_2_BASE:1.2
	PERL_5_24_2:1.1.1.12
	OPENBSD_6_1:1.2.0.4
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.11.0.10
	OPENBSD_6_0_BASE:1.1.1.11
	OPENBSD_5_9:1.1.1.11.0.4
	OPENBSD_5_9_BASE:1.1.1.11
	OPENBSD_5_8:1.1.1.11.0.6
	OPENBSD_5_8_BASE:1.1.1.11
	PERL_5_20_2:1.1.1.11
	OPENBSD_5_7:1.1.1.11.0.2
	OPENBSD_5_7_BASE:1.1.1.11
	PERL_5_20_1:1.1.1.11
	OPENBSD_5_6:1.1.1.10.0.4
	OPENBSD_5_6_BASE:1.1.1.10
	PERL_5_18_2:1.1.1.10
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.9.0.6
	OPENBSD_5_5_BASE:1.1.1.9
	OPENBSD_5_4:1.1.1.9.0.2
	OPENBSD_5_4_BASE:1.1.1.9
	PERL_5_16_3:1.1.1.9
	OPENBSD_5_3:1.1.1.8.0.14
	OPENBSD_5_3_BASE:1.1.1.8
	OPENBSD_5_2:1.1.1.8.0.12
	OPENBSD_5_2_BASE:1.1.1.8
	OPENBSD_5_1_BASE:1.1.1.8
	OPENBSD_5_1:1.1.1.8.0.10
	OPENBSD_5_0:1.1.1.8.0.8
	OPENBSD_5_0_BASE:1.1.1.8
	OPENBSD_4_9:1.1.1.8.0.6
	OPENBSD_4_9_BASE:1.1.1.8
	PERL_5_12_2:1.1.1.8
	OPENBSD_4_8:1.1.1.8.0.4
	OPENBSD_4_8_BASE:1.1.1.8
	OPENBSD_4_7:1.1.1.8.0.2
	OPENBSD_4_7_BASE:1.1.1.8
	PERL_5_10_1:1.1.1.8
	OPENBSD_4_6:1.1.1.7.0.6
	OPENBSD_4_6_BASE:1.1.1.7
	OPENBSD_4_5:1.1.1.7.0.2
	OPENBSD_4_5_BASE:1.1.1.7
	PERL_5_10_0:1.1.1.7
	OPENBSD_4_4:1.1.1.6.0.10
	OPENBSD_4_4_BASE:1.1.1.6
	OPENBSD_4_3:1.1.1.6.0.8
	OPENBSD_4_3_BASE:1.1.1.6
	OPENBSD_4_2:1.1.1.6.0.6
	OPENBSD_4_2_BASE:1.1.1.6
	OPENBSD_4_1:1.1.1.6.0.4
	OPENBSD_4_1_BASE:1.1.1.6
	OPENBSD_4_0:1.1.1.6.0.2
	OPENBSD_4_0_BASE:1.1.1.6
	PERL_5_8_8:1.1.1.6
	OPENBSD_3_9:1.1.1.5.0.10
	OPENBSD_3_9_BASE:1.1.1.5
	OPENBSD_3_8:1.1.1.5.0.8
	OPENBSD_3_8_BASE:1.1.1.5
	OPENBSD_3_7:1.1.1.5.0.6
	OPENBSD_3_7_BASE:1.1.1.5
	PERL_5_8_6:1.1.1.5
	OPENBSD_3_6:1.1.1.5.0.4
	OPENBSD_3_6_BASE:1.1.1.5
	PERL_5_8_5:1.1.1.5
	PERL_5_8_3:1.1.1.5
	OPENBSD_3_5:1.1.1.5.0.2
	OPENBSD_3_5_BASE:1.1.1.5
	PERL_5_8_2:1.1.1.5
	OPENBSD_3_4:1.1.1.4.0.4
	OPENBSD_3_4_BASE:1.1.1.4
	OPENBSD_3_3:1.1.1.4.0.2
	OPENBSD_3_3_BASE:1.1.1.4
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.1.1.3.0.6
	OPENBSD_3_2_BASE:1.1.1.3
	OPENBSD_3_1:1.1.1.3.0.4
	OPENBSD_3_1_BASE:1.1.1.3
	OPENBSD_3_0:1.1.1.3.0.2
	OPENBSD_3_0_BASE:1.1.1.3
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.1.1.2.0.6
	OPENBSD_2_9_BASE:1.1.1.2
	OPENBSD_2_8:1.1.1.2.0.4
	OPENBSD_2_8_BASE:1.1.1.2
	OPENBSD_2_7:1.1.1.2.0.2
	OPENBSD_2_7_BASE:1.1.1.2
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.1.1.1.0.2
	OPENBSD_2_6_BASE:1.1.1.1
	PERL_500503:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.32.20;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	99.04.29.22.41.53;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.29.22.41.53;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.04.06.16.10.52;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.05.24.18.25.49;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.27.22.15.11;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.12.03.02.44.33;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2006.03.28.18.49.47;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2008.09.29.17.19.02;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2009.10.12.18.10.45;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2013.03.25.20.09.37;	author sthen;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2014.03.24.14.59.11;	author afresh1;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2014.11.17.20.53.18;	author afresh1;	state Exp;
branches;
next	1.1.1.12;
commitid	B31cAbBIXiCqnL97;

1.1.1.12
date	2017.08.14.13.46.24;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@# tr.t
$|=1;

use utf8;

BEGIN {
    chdir 't' if -d 't';
    require './test.pl';
    set_up_inc('../lib');
}

plan tests => 164;

# Test this first before we extend the stack with other operations.
# This caused an asan failure due to a bad write past the end of the stack.
eval { my $x; die  1..127, $x =~ y/// };

$_ = "abcdefghijklmnopqrstuvwxyz";

tr/a-z/A-Z/;

is($_, "ABCDEFGHIJKLMNOPQRSTUVWXYZ",    'uc');

tr/A-Z/a-z/;

is($_, "abcdefghijklmnopqrstuvwxyz",    'lc');

tr/b-y/B-Y/;
is($_, "aBCDEFGHIJKLMNOPQRSTUVWXYz",    'partial uc');

eval 'tr/a/\N{KATAKANA LETTER AINU P}/;';
like $@@,
     qr/\\N\{KATAKANA LETTER AINU P} must not be a named sequence in transliteration operator/,
     "Illegal to tr/// named sequence";

eval 'tr/\x{101}-\x{100}//;';
like $@@,
     qr/Invalid range "\\x\{0101}-\\x\{0100}" in transliteration operator/,
     "UTF-8 range with min > max";

SKIP: {   # Test literal range end point special handling
    unless ($::IS_EBCDIC) {
        skip "Valid only for EBCDIC", 24;
    }

    $_ = "\x89";    # is 'i'
    tr/i-j//d;
    is($_, "", '"\x89" should match [i-j]');
    $_ = "\x8A";
    tr/i-j//d;
    is($_, "\x8A", '"\x8A" shouldnt match [i-j]');
    $_ = "\x90";
    tr/i-j//d;
    is($_, "\x90", '"\x90" shouldnt match [i-j]');
    $_ = "\x91";    # is 'j'
    tr/i-j//d;
    is($_, "", '"\x91" should match [i-j]');

    $_ = "\x89";
    tr/i-\N{LATIN SMALL LETTER J}//d;
    is($_, "", '"\x89" should match [i-\N{LATIN SMALL LETTER J}]');
    $_ = "\x8A";
    tr/i-\N{LATIN SMALL LETTER J}//d;
    is($_, "\x8A", '"\x8A" shouldnt match [i-\N{LATIN SMALL LETTER J}]');
    $_ = "\x90";
    tr/i-\N{LATIN SMALL LETTER J}//d;
    is($_, "\x90", '"\x90" shouldnt match [i-\N{LATIN SMALL LETTER J}]');
    $_ = "\x91";
    tr/i-\N{LATIN SMALL LETTER J}//d;
    is($_, "", '"\x91" should match [i-\N{LATIN SMALL LETTER J}]');

    $_ = "\x89";
    tr/i-\N{U+6A}//d;
    is($_, "", '"\x89" should match [i-\N{U+6A}]');
    $_ = "\x8A";
    tr/i-\N{U+6A}//d;
    is($_, "\x8A", '"\x8A" shouldnt match [i-\N{U+6A}]');
    $_ = "\x90";
    tr/i-\N{U+6A}//d;
    is($_, "\x90", '"\x90" shouldnt match [i-\N{U+6A}]');
    $_ = "\x91";
    tr/i-\N{U+6A}//d;
    is($_, "", '"\x91" should match [i-\N{U+6A}]');

    $_ = "\x89";
    tr/\N{U+69}-\N{U+6A}//d;
    is($_, "", '"\x89" should match [\N{U+69}-\N{U+6A}]');
    $_ = "\x8A";
    tr/\N{U+69}-\N{U+6A}//d;
    is($_, "\x8A", '"\x8A" shouldnt match [\N{U+69}-\N{U+6A}]');
    $_ = "\x90";
    tr/\N{U+69}-\N{U+6A}//d;
    is($_, "\x90", '"\x90" shouldnt match [\N{U+69}-\N{U+6A}]');
    $_ = "\x91";
    tr/\N{U+69}-\N{U+6A}//d;
    is($_, "", '"\x91" should match [\N{U+69}-\N{U+6A}]');

    $_ = "\x89";
    tr/i-\x{91}//d;
    is($_, "", '"\x89" should match [i-\x{91}]');
    $_ = "\x8A";
    tr/i-\x{91}//d;
    is($_, "", '"\x8A" should match [i-\x{91}]');
    $_ = "\x90";
    tr/i-\x{91}//d;
    is($_, "", '"\x90" should match [i-\x{91}]');
    $_ = "\x91";
    tr/i-\x{91}//d;
    is($_, "", '"\x91" should match [i-\x{91}]');

    # Need to use eval, because tries to compile on ASCII platforms even
    # though the tests are skipped, and fails because 0x89-j is an illegal
    # range there.
    $_ = "\x89";
    eval 'tr/\x{89}-j//d';
    is($_, "", '"\x89" should match [\x{89}-j]');
    $_ = "\x8A";
    eval 'tr/\x{89}-j//d';
    is($_, "", '"\x8A" should match [\x{89}-j]');
    $_ = "\x90";
    eval 'tr/\x{89}-j//d';
    is($_, "", '"\x90" should match [\x{89}-j]');
    $_ = "\x91";
    eval 'tr/\x{89}-j//d';
    is($_, "", '"\x91" should match [\x{89}-j]');
}


# In EBCDIC 'I' is \xc9 and 'J' is \0xd1, 'i' is \x89 and 'j' is \x91.
# Yes, discontinuities.  Regardless, the \xca in the below should stay
# untouched (and not became \x8a).
{
    $_ = "I\xcaJ";

    tr/I-J/i-j/;

    is($_, "i\xcaj",    'EBCDIC discontinuity');
}
#

($x = 12) =~ tr/1/3/;
(my $y = 12) =~ tr/1/3/;
($f = 1.5) =~ tr/1/3/;
(my $g = 1.5) =~ tr/1/3/;
is($x + $y + $f + $g, 71,   'tr cancels IOK and NOK');

# /r
$_ = 'adam';
is y/dam/ve/rd, 'eve', '/r';
is $_, 'adam', '/r leaves param alone';
$g = 'ruby';
is $g =~ y/bury/repl/r, 'perl', '/r with explicit param';
is $g, 'ruby', '/r leaves explicit param alone';
is "aaa" =~ y\a\b\r, 'bbb', '/r with constant param';
ok !eval '$_ !~ y///r', "!~ y///r is forbidden";
like $@@, qr\^Using !~ with tr///r doesn't make sense\,
  "!~ y///r error message";
{
  my $w;
  my $wc;
  local $SIG{__WARN__} = sub { $w = shift; ++$wc };
  local $^W = 1;
  eval 'y///r; 1';
  like $w, qr '^Useless use of non-destructive transliteration \(tr///r\)',
    '/r warns in void context';
  is $wc, 1, '/r warns just once';
}

# perlbug [ID 20000511.005]
$_ = 'fred';
/([a-z]{2})/;
$1 =~ tr/A-Z//;
s/^(\s*)f/$1F/;
is($_, 'Fred',  'harmless if explicitly not updating');


# A variant of the above, added in 5.7.2
$_ = 'fred';
/([a-z]{2})/;
eval '$1 =~ tr/A-Z/A-Z/;';
s/^(\s*)f/$1F/;
is($_, 'Fred',  'harmless if implicitly not updating');
is($@@, '',      '    no error');


# check tr handles UTF8 correctly
($x = 256.65.258) =~ tr/a/b/;
is($x, 256.65.258,  'handles UTF8');
is(length $x, 3);

$x =~ tr/A/B/;
is(length $x, 3);
if ($::IS_ASCII) { # ASCII
    is($x, 256.66.258);
}
else {
    is($x, 256.65.258);
}

# EBCDIC variants of the above tests
($x = 256.193.258) =~ tr/a/b/;
is(length $x, 3);
is($x, 256.193.258);

$x =~ tr/A/B/;
is(length $x, 3);
if ($::IS_ASCII) { # ASCII
    is($x, 256.193.258);
}
else {
    is($x, 256.194.258);
}


{
    my $l = chr(300); my $r = chr(400);
    $x = 200.300.400;
    $x =~ tr/\x{12c}/\x{190}/;
    is($x, 200.400.400,     
                        'changing UTF8 chars in a UTF8 string, same length');
    is(length $x, 3);

    $x = 200.300.400;
    $x =~ tr/\x{12c}/\x{be8}/;
    is($x, 200.3048.400,    '    more bytes');
    is(length $x, 3);

    $x = 100.125.60;
    $x =~ tr/\x{64}/\x{190}/;
    is($x, 400.125.60,      'Putting UT8 chars into a non-UTF8 string');
    is(length $x, 3);

    $x = 400.125.60;
    $x =~ tr/\x{190}/\x{64}/;
    is($x, 100.125.60,      'Removing UTF8 chars from UTF8 string');
    is(length $x, 3);

    $x = 400.125.60.400;
    $y = $x =~ tr/\x{190}/\x{190}/;
    is($y, 2,               'Counting UTF8 chars in UTF8 string');

    $x = 60.400.125.60.400;
    $y = $x =~ tr/\x{3c}/\x{3c}/;
    is($y, 2,               '         non-UTF8 chars in UTF8 string');

    # 17 - counting UTF8 chars in non-UTF8 string
    $x = 200.125.60;
    $y = $x =~ tr/\x{190}/\x{190}/;
    is($y, 0,               '         UTF8 chars in non-UTFs string');
}

$_ = "abcdefghijklmnopqrstuvwxyz";
eval 'tr/a-z-9/ /';
like($@@, qr/^Ambiguous range in transliteration operator/,  'tr/a-z-9//');

# 19-21: Make sure leading and trailing hyphens still work
$_ = "car-rot9";
tr/-a-m/./;
is($_, '..r.rot9',  'hyphens, leading');

$_ = "car-rot9";
tr/a-m-/./;
is($_, '..r.rot9',  '   trailing');

$_ = "car-rot9";
tr/-a-m-/./;
is($_, '..r.rot9',  '   both');

$_ = "abcdefghijklmnop";
tr/ae-hn/./;
is($_, '.bcd....ijklm.op');

$_ = "abcdefghijklmnop";
tr/a-cf-kn-p/./;
is($_, '...de......lm...');

$_ = "abcdefghijklmnop";
tr/a-ceg-ikm-o/./;
is($_, '...d.f...j.l...p');


# 20000705 MJD
eval "tr/m-d/ /";
like($@@, qr/^Invalid range "m-d" in transliteration operator/,
              'reversed range check');

'abcdef' =~ /(bcd)/;
is(eval '$1 =~ tr/abcd//', 3,  'explicit read-only count');
is($@@, '',                      '    no error');

'abcdef' =~ /(bcd)/;
is(eval '$1 =~ tr/abcd/abcd/', 3,  'implicit read-only count');
is($@@, '',                      '    no error');

is(eval '"123" =~ tr/12//', 2,     'LHS of non-updating tr');

eval '"123" =~ tr/1/2/';
like($@@, qr|^Can't modify constant item in transliteration \(tr///\)|,
         'LHS bad on updating tr');


# v300 (0x12c) is UTF-8-encoded as 196 172 (0xc4 0xac)
# v400 (0x190) is UTF-8-encoded as 198 144 (0xc6 0x90)

# Transliterate a byte to a byte, all four ways.

($a = v300.196.172.300.196.172) =~ tr/\xc4/\xc5/;
is($a, v300.197.172.300.197.172,    'byte2byte transliteration');

($a = v300.196.172.300.196.172) =~ tr/\xc4/\x{c5}/;
is($a, v300.197.172.300.197.172);

($a = v300.196.172.300.196.172) =~ tr/\x{c4}/\xc5/;
is($a, v300.197.172.300.197.172);

($a = v300.196.172.300.196.172) =~ tr/\x{c4}/\x{c5}/;
is($a, v300.197.172.300.197.172);


($a = v300.196.172.300.196.172) =~ tr/\xc4/\x{12d}/;
is($a, v300.301.172.300.301.172,    'byte2wide transliteration');

($a = v300.196.172.300.196.172) =~ tr/\x{12c}/\xc3/;
is($a, v195.196.172.195.196.172,    '   wide2byte');

($a = v300.196.172.300.196.172) =~ tr/\x{12c}/\x{12d}/;
is($a, v301.196.172.301.196.172,    '   wide2wide');


($a = v300.196.172.300.196.172) =~ tr/\xc4\x{12c}/\x{12d}\xc3/;
is($a, v195.301.172.195.301.172,    'byte2wide & wide2byte');


($a = v300.196.172.300.196.172.400.198.144) =~
	tr/\xac\xc4\x{12c}\x{190}/\xad\x{12d}\xc5\x{191}/;
is($a, v197.301.173.197.301.173.401.198.144,    'all together now!');


is((($a = v300.196.172.300.196.172) =~ tr/\xc4/\xc5/), 2,
                                     'transliterate and count');

is((($a = v300.196.172.300.196.172) =~ tr/\x{12c}/\x{12d}/), 2);


($a = v300.196.172.300.196.172) =~ tr/\xc4/\x{12d}/c;
is($a, v301.196.301.301.196.301,    'translit w/complement');

($a = v300.196.172.300.196.172) =~ tr/\x{12c}/\xc5/c;
is($a, v300.197.197.300.197.197);


($a = v300.196.172.300.196.172) =~ tr/\xc4//d;
is($a, v300.172.300.172,            'translit w/deletion');

($a = v300.196.172.300.196.172) =~ tr/\x{12c}//d;
is($a, v196.172.196.172);


($a = v196.196.172.300.300.196.172) =~ tr/\xc4/\xc5/s;
is($a, v197.172.300.300.197.172,    'translit w/squeeze');

($a = v196.172.300.300.196.172.172) =~ tr/\x{12c}/\x{12d}/s;
is($a, v196.172.301.196.172.172);


# Tricky cases (When Simon Cozens Attacks)
($a = v196.172.200) =~ tr/\x{12c}/a/;
is(sprintf("%vd", $a), '196.172.200');

($a = v196.172.200) =~ tr/\x{12c}/\x{12c}/;
is(sprintf("%vd", $a), '196.172.200');

($a = v196.172.200) =~ tr/\x{12c}//d;
is(sprintf("%vd", $a), '196.172.200');


# UTF8 range tests from Inaba Hiroto

($a = v300.196.172.302.197.172) =~ tr/\x{12c}-\x{130}/\xc0-\xc4/;
is($a, v192.196.172.194.197.172,    'UTF range');

($a = v300.196.172.302.197.172) =~ tr/\xc4-\xc8/\x{12c}-\x{130}/;
is($a, v300.300.172.302.301.172);


# UTF8 range tests from Karsten Sperling (patch #9008 required)

($a = "\x{0100}") =~ tr/\x00-\x{100}/X/;
is($a, "X");

($a = "\x{0100}") =~ tr/\x{0000}-\x{00ff}/X/c;
is($a, "X");

($a = "\x{0100}") =~ tr/\x{0000}-\x{00ff}\x{0101}/X/c;
is($a, "X");
 
($a = v256) =~ tr/\x{0000}-\x{00ff}\x{0101}/X/c;
is($a, "X");


# UTF8 range tests from Inaba Hiroto

($a = "\x{200}") =~ tr/\x00-\x{100}/X/c;
is($a, "X");

($a = "\x{200}") =~ tr/\x00-\x{100}/X/cs;
is($a, "X");

# Tricky on EBCDIC: while [a-z] [A-Z] must not match the gap characters (as
# well as i-j, r-s, I-J, R-S), [\x89-\x91] [\xc9-\xd1] has to match them,
# from Karsten Sperling.

$c = ($a = "\x89\x8a\x8b\x8c\x8d\x8f\x90\x91") =~ tr/\x89-\x91/X/;
is($c, 8);
is($a, "XXXXXXXX");

$c = ($a = "\xc9\xca\xcb\xcc\xcd\xcf\xd0\xd1") =~ tr/\xc9-\xd1/X/;
is($c, 8);
is($a, "XXXXXXXX");

SKIP: {
    skip "EBCDIC-centric tests", 4 unless $::IS_EBCDIC;

    $c = ($a = "\x89\x8a\x8b\x8c\x8d\x8f\x90\x91") =~ tr/i-j/X/;
    is($c, 2);
    is($a, "X\x8a\x8b\x8c\x8d\x8f\x90X");
   
    $c = ($a = "\xc9\xca\xcb\xcc\xcd\xcf\xd0\xd1") =~ tr/I-J/X/;
    is($c, 2);
    is($a, "X\xca\xcb\xcc\xcd\xcf\xd0X");
}

($a = "\x{100}") =~ tr/\x00-\xff/X/c;
is(ord($a), ord("X"));

($a = "\x{100}") =~ tr/\x00-\xff/X/cs;
is(ord($a), ord("X"));

($a = "\x{100}\x{100}") =~ tr/\x{101}-\x{200}//c;
is($a, "\x{100}\x{100}");

($a = "\x{100}\x{100}") =~ tr/\x{101}-\x{200}//cs;
is($a, "\x{100}");

$a = "\xfe\xff"; $a =~ tr/\xfe\xff/\x{1ff}\x{1fe}/;
is($a, "\x{1ff}\x{1fe}");


# From David Dyck
($a = "R0_001") =~ tr/R_//d;
is(hex($a), 1);

# From Inaba Hiroto
@@a = (1,2); map { y/1/./ for $_ } @@a;
is("@@a", ". 2");

@@a = (1,2); map { y/1/./ for $_.'' } @@a;
is("@@a", "1 2");


# Additional test for Inaba Hiroto patch (robin@@kitsite.com)
($a = "\x{100}\x{102}\x{101}") =~ tr/\x00-\377/XYZ/c;
is($a, "XZY");


# Used to fail with "Modification of a read-only value attempted"
%a = (N=>1);
foreach (keys %a) {
  eval 'tr/N/n/';
  is($_, 'n',   'pp_trans needs to unshare shared hash keys');
  is($@@, '',    '   no error');
}


$x = eval '"1213" =~ tr/1/1/';
is($x, 2,   'implicit count on constant');
is($@@, '',  '   no error');


my @@foo = ();
eval '$foo[-1] =~ tr/N/N/';
is( $@@, '',         'implicit count outside array bounds, index negative' );
is( scalar @@foo, 0, "    doesn't extend the array");

eval '$foo[1] =~ tr/N/N/';
is( $@@, '',         'implicit count outside array bounds, index positive' );
is( scalar @@foo, 0, "    doesn't extend the array");


my %foo = ();
eval '$foo{bar} =~ tr/N/N/';
is( $@@, '',         'implicit count outside hash bounds' );
is( scalar keys %foo, 0,   "    doesn't extend the hash");

$x = \"foo";
is( $x =~ tr/A/A/, 2, 'non-modifying tr/// on a scalar ref' );
is( ref $x, 'SCALAR', "    doesn't stringify its argument" );

# rt.perl.org 36622.  Perl didn't like a y/// at end of file.  No trailing
# newline allowed.
fresh_perl_is(q[$_ = "foo"; y/A-Z/a-z/], '');


{ # [perl #38293] chr(65535) should be allowed in regexes
no warnings 'utf8'; # to allow non-characters

$s = "\x{d800}\x{ffff}";
$s =~ tr/\0/A/;
is($s, "\x{d800}\x{ffff}", "do_trans_simple");

$s = "\x{d800}\x{ffff}";
$i = $s =~ tr/\0//;
is($i, 0, "do_trans_count");

$s = "\x{d800}\x{ffff}";
$s =~ tr/\0/A/s;
is($s, "\x{d800}\x{ffff}", "do_trans_complex, SQUASH");

$s = "\x{d800}\x{ffff}";
$s =~ tr/\0/A/c;
is($s, "AA", "do_trans_complex, COMPLEMENT");

$s = "A\x{ffff}B";
$s =~ tr/\x{ffff}/\x{1ffff}/;
is($s, "A\x{1ffff}B", "utf8, SEARCHLIST");

$s = "\x{fffd}\x{fffe}\x{ffff}";
$s =~ tr/\x{fffd}-\x{ffff}/ABC/;
is($s, "ABC", "utf8, SEARCHLIST range");

$s = "ABC";
$s =~ tr/ABC/\x{ffff}/;
is($s, "\x{ffff}"x3, "utf8, REPLACEMENTLIST");

$s = "ABC";
$s =~ tr/ABC/\x{fffd}-\x{ffff}/;
is($s, "\x{fffd}\x{fffe}\x{ffff}", "utf8, REPLACEMENTLIST range");

$s = "A\x{ffff}B\x{100}\0\x{fffe}\x{ffff}";
$i = $s =~ tr/\x{ffff}//;
is($i, 2, "utf8, count");

$s = "A\x{ffff}\x{ffff}C";
$s =~ tr/\x{ffff}/\x{100}/s;
is($s, "A\x{100}C", "utf8, SQUASH");

$s = "A\x{ffff}\x{ffff}\x{fffe}\x{fffe}\x{fffe}C";
$s =~ tr/\x{fffe}\x{ffff}//s;
is($s, "A\x{ffff}\x{fffe}C", "utf8, SQUASH");

$s = "xAABBBy";
$s =~ tr/AB/\x{ffff}/s;
is($s, "x\x{ffff}y", "utf8, SQUASH");

$s = "xAABBBy";
$s =~ tr/AB/\x{fffe}\x{ffff}/s;
is($s, "x\x{fffe}\x{ffff}y", "utf8, SQUASH");

$s = "A\x{ffff}B\x{fffe}C";
$s =~ tr/\x{fffe}\x{ffff}/x/c;
is($s, "x\x{ffff}x\x{fffe}x", "utf8, COMPLEMENT");

$s = "A\x{10000}B\x{2abcd}C";
$s =~ tr/\0-\x{ffff}/x/c;
is($s, "AxBxC", "utf8, COMPLEMENT range");

$s = "A\x{fffe}B\x{ffff}C";
$s =~ tr/\x{fffe}\x{ffff}/x/d;
is($s, "AxBC", "utf8, DELETE");

} # non-characters end

{ # related to [perl #27940]
    my $c;

    ($c = "\x20\c@@\x30\cA\x40\cZ\x50\c_\x60") =~ tr/\c@@-\c_//d;
    is($c, "\x20\x30\x40\x50\x60", "tr/\\c\@@-\\c_//d");

    ($c = "\x20\x00\x30\x01\x40\x1A\x50\x1F\x60") =~ tr/\x00-\x1f//d;
    is($c, "\x20\x30\x40\x50\x60", "tr/\\x00-\\x1f//d");
}

($s) = keys %{{pie => 3}};
SKIP: {
    if (!eval { require XS::APItest }) { skip "no XS::APItest", 2 }
    my $wasro = XS::APItest::SvIsCOW($s);
    ok $wasro, "have a COW";
    $s =~ tr/i//;
    ok( XS::APItest::SvIsCOW($s),
       "count-only tr doesn't deCOW COWs" );
}

# [ RT #61520 ]
#
# under threads, unicode tr within a cloned closure would SEGV or assert
# fail, since the pointer in the pad to the swash was getting zeroed out
# in the proto-CV

{
    my $x = "\x{142}";
    sub {
	$x =~ tr[\x{142}][\x{143}];
    }->();
    is($x,"\x{143}", "utf8 + closure");
}

# Freeing of trans ops prior to pmtrans() [perl #102858].
eval q{ $a ~= tr/a/b/; };
ok 1;
SKIP: {
    no warnings "deprecated";
    skip "no encoding", 1 unless eval { require encoding; 1 };
    eval q{ use encoding "utf8"; $a ~= tr/a/b/; };
    ok 1;
}

{ # [perl #113584]

    my $x = "Perlα";
    $x =~ tr/αα/βγ/;
    { no warnings 'utf8'; print "# $x\n"; } # No note() to avoid wide warning.
    is($x, "Perlβ", "Only first of multiple transliterations is used");
}

# tr/a/b/ should fail even on zero-length read-only strings
use constant nullrocow => (keys%{{""=>undef}})[0];
for ("", nullrocow) {
    eval { $_ =~ y/a/b/ };
    like $@@, qr/^Modification of a read-only value attempted at /,
        'tr/a/b/ fails on zero-length ro string';
}

# Whether they're permitted or not, non-modifying tr/// should not write
# to read-only values, even with funky flags.
{ # [perl #123759]
	eval q{ ('a' =~ /./) =~ tr///d };
	ok(1, "tr///d on PL_Yes does not assert");
	eval q{ ('a' =~ /./) =~ tr/a-z/a-z/d };
	ok(1, "tr/a-z/a-z/d on PL_Yes does not assert");
	eval q{ ('a' =~ /./) =~ tr///s };
	ok(1, "tr///s on PL_Yes does not assert");
	eval q{ *x =~ tr///d };
	ok(1, "tr///d on glob does not assert");
}

1;
@


1.1
log
@Initial revision
@
text
@d2 1
d4 13
a16 1
print "1..4\n";
d22 1
a22 2
print "not " unless $_ eq "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
print "ok 1\n";
d26 1
a26 2
print "not " unless $_ eq "abcdefghijklmnopqrstuvwxyz";
print "ok 2\n";
d29 98
a127 2
print "not " unless $_ eq "aBCDEFGHIJKLMNOPQRSTUVWXYz";
print "ok 3\n";
d132 252
a384 1
$_ = "I\xcaJ";
d386 1
a386 1
tr/I-J/i-j/;
d388 2
a389 2
print "not " unless $_ eq "i\xcaj";
print "ok 4\n";
d391 203
d595 52
@


1.1.1.1
log
@perl5.005_03
@
text
@@


1.1.1.2
log
@virgin perl 5.6.0
@
text
@a2 5
BEGIN {
    chdir 't' if -d 't';
    unshift @@INC, "../lib";
}

d25 8
a32 9
{
    no utf8;
    $_ = "I\xcaJ";

    tr/I-J/i-j/;

    print "not " unless $_ eq "i\xcaj";
    print "ok 4\n";
}
@


1.1.1.3
log
@stock perl 5.6.1
@
text
@d5 1
a5 1
    @@INC = '../lib';
d8 1
a8 1
print "1..54\n";
a39 272

# make sure that tr cancels IOK and NOK
($x = 12) =~ tr/1/3/;
(my $y = 12) =~ tr/1/3/;
($f = 1.5) =~ tr/1/3/;
(my $g = 1.5) =~ tr/1/3/;
print "not " unless $x + $y + $f + $g == 71;
print "ok 5\n";

# make sure tr is harmless if not updating  -  see [ID 20000511.005]
$_ = 'fred';
/([a-z]{2})/;
$1 =~ tr/A-Z//;
s/^(\s*)f/$1F/;
print "not " if $_ ne 'Fred';
print "ok 6\n";

# check tr handles UTF8 correctly
($x = 256.65.258) =~ tr/a/b/;
print "not " if $x ne 256.65.258 or length $x != 3;
print "ok 7\n";
$x =~ tr/A/B/;
if (ord("\t") == 9) { # ASCII
    print "not " if $x ne 256.66.258 or length $x != 3;
}
else {
    print "not " if $x ne 256.65.258 or length $x != 3;
}
print "ok 8\n";
# EBCDIC variants of the above tests
($x = 256.193.258) =~ tr/a/b/;
print "not " if $x ne 256.193.258 or length $x != 3;
print "ok 9\n";
$x =~ tr/A/B/;
if (ord("\t") == 9) { # ASCII
    print "not " if $x ne 256.193.258 or length $x != 3;
}
else {
    print "not " if $x ne 256.194.258 or length $x != 3;
}
print "ok 10\n";

{
if (ord("\t") == 9) { # ASCII
    use utf8;
}
# 11 - changing UTF8 characters in a UTF8 string, same length.
$l = chr(300); $r = chr(400);
$x = 200.300.400;
$x =~ tr/\x{12c}/\x{190}/;
printf "not (%vd) ", $x if $x ne 200.400.400 or length $x != 3;
print "ok 11\n";

# 12 - changing UTF8 characters in UTF8 string, more bytes.
$x = 200.300.400;
$x =~ tr/\x{12c}/\x{be8}/;
printf "not (%vd) ", $x if $x ne 200.3048.400 or length $x != 3;
print "ok 12\n";

# 13 - introducing UTF8 characters to non-UTF8 string.
$x = 100.125.60;
$x =~ tr/\x{64}/\x{190}/;
printf "not (%vd) ", $x if $x ne 400.125.60 or length $x != 3;
print "ok 13\n";

# 14 - removing UTF8 characters from UTF8 string
$x = 400.125.60;
$x =~ tr/\x{190}/\x{64}/;
printf "not (%vd) ", $x if $x ne 100.125.60 or length $x != 3;
print "ok 14\n";

# 15 - counting UTF8 chars in UTF8 string
$x = 400.125.60.400;
$y = $x =~ tr/\x{190}/\x{190}/;
print "not " if $y != 2;
print "ok 15\n";

# 16 - counting non-UTF8 chars in UTF8 string
$x = 60.400.125.60.400;
$y = $x =~ tr/\x{3c}/\x{3c}/;
print "not " if $y != 2;
print "ok 16\n";

# 17 - counting UTF8 chars in non-UTF8 string
$x = 200.125.60;
$y = $x =~ tr/\x{190}/\x{190}/;
print "not " if $y != 0;
print "ok 17\n";
}

# 18: test brokenness with tr/a-z-9//;
$_ = "abcdefghijklmnopqrstuvwxyz";
eval "tr/a-z-9/ /";
print (($@@ =~ /^Ambiguous range in transliteration operator/ || $^V lt v5.7.0) 
       ? '' : 'not ', "ok 18\n");

# 19-21: Make sure leading and trailing hyphens still work
$_ = "car-rot9";
tr/-a-m/./;
print (($_ eq '..r.rot9') ? '' : 'not ', "ok 19\n");

$_ = "car-rot9";
tr/a-m-/./;
print (($_ eq '..r.rot9') ? '' : 'not ', "ok 20\n");

$_ = "car-rot9";
tr/-a-m-/./;
print (($_ eq '..r.rot9') ? '' : 'not ', "ok 21\n");

$_ = "abcdefghijklmnop";
tr/ae-hn/./;
print (($_ eq '.bcd....ijklm.op') ? '' : 'not ', "ok 22\n");

$_ = "abcdefghijklmnop";
tr/a-cf-kn-p/./;
print (($_ eq '...de......lm...') ? '' : 'not ', "ok 23\n");

$_ = "abcdefghijklmnop";
tr/a-ceg-ikm-o/./;
print (($_ eq '...d.f...j.l...p') ? '' : 'not ', "ok 24\n");

# 25: Test reversed range check
# 20000705 MJD
eval "tr/m-d/ /";
print (($@@ =~ /^Invalid \[\] range "m-d" in transliteration operator/ || $^V lt v5.7.0) 
       ? '' : 'not ', "ok 25\n");

# 26: test cannot update if read-only
eval '$1 =~ tr/x/y/';
print (($@@ =~ /^Modification of a read-only value attempted/) ? '' : 'not ',
       "ok 26\n");

# 27: test can count read-only
'abcdef' =~ /(bcd)/;
print (( eval '$1 =~ tr/abcd//' == 3) ? '' : 'not ', "ok 27\n");

# 28: test lhs OK if not updating
print ((eval '"123" =~ tr/12//' == 2) ? '' : 'not ', "ok 28\n");

# 29: test lhs bad if updating
eval '"123" =~ tr/1/1/';
print (($@@ =~ m|^Can't modify constant item in transliteration \(tr///\)|)
       ? '' : 'not ', "ok 29\n");

# v300 (0x12c) is UTF-8-encoded as 196 172 (0xc4 0xac)
# v400 (0x190) is UTF-8-encoded as 198 144 (0xc6 0x90)

# Transliterate a byte to a byte, all four ways.

($a = v300.196.172.300.196.172) =~ tr/\xc4/\xc5/;
print "not " unless $a eq v300.197.172.300.197.172;
print "ok 30\n";

($a = v300.196.172.300.196.172) =~ tr/\xc4/\x{c5}/;
print "not " unless $a eq v300.197.172.300.197.172;
print "ok 31\n";

($a = v300.196.172.300.196.172) =~ tr/\x{c4}/\xc5/;
print "not " unless $a eq v300.197.172.300.197.172;
print "ok 32\n";

($a = v300.196.172.300.196.172) =~ tr/\x{c4}/\x{c5}/;
print "not " unless $a eq v300.197.172.300.197.172;
print "ok 33\n";

# Transliterate a byte to a wide character.

($a = v300.196.172.300.196.172) =~ tr/\xc4/\x{12d}/;
print "not " unless $a eq v300.301.172.300.301.172;
print "ok 34\n";

# Transliterate a wide character to a byte.

($a = v300.196.172.300.196.172) =~ tr/\x{12c}/\xc3/;
print "not " unless $a eq v195.196.172.195.196.172;
print "ok 35\n";

# Transliterate a wide character to a wide character.

($a = v300.196.172.300.196.172) =~ tr/\x{12c}/\x{12d}/;
print "not " unless $a eq v301.196.172.301.196.172;
print "ok 36\n";

# Transliterate both ways.

($a = v300.196.172.300.196.172) =~ tr/\xc4\x{12c}/\x{12d}\xc3/;
print "not " unless $a eq v195.301.172.195.301.172;
print "ok 37\n";

# Transliterate all (four) ways.

($a = v300.196.172.300.196.172.400.198.144) =~
	tr/\xac\xc4\x{12c}\x{190}/\xad\x{12d}\xc5\x{191}/;
print "not " unless $a eq v197.301.173.197.301.173.401.198.144;
print "ok 38\n";

# Transliterate and count.

print "not "
    unless (($a = v300.196.172.300.196.172) =~ tr/\xc4/\xc5/)       == 2;
print "ok 39\n";

print "not "
    unless (($a = v300.196.172.300.196.172) =~ tr/\x{12c}/\x{12d}/) == 2;
print "ok 40\n";

# Transliterate with complement.

($a = v300.196.172.300.196.172) =~ tr/\xc4/\x{12d}/c;
print "not " unless $a eq v301.196.301.301.196.301;
print "ok 41\n";

($a = v300.196.172.300.196.172) =~ tr/\x{12c}/\xc5/c;
print "not " unless $a eq v300.197.197.300.197.197;
print "ok 42\n";

# Transliterate with deletion.

($a = v300.196.172.300.196.172) =~ tr/\xc4//d;
print "not " unless $a eq v300.172.300.172;
print "ok 43\n";

($a = v300.196.172.300.196.172) =~ tr/\x{12c}//d;
print "not " unless $a eq v196.172.196.172;
print "ok 44\n";

# Transliterate with squeeze.

($a = v196.196.172.300.300.196.172) =~ tr/\xc4/\xc5/s;
print "not " unless $a eq v197.172.300.300.197.172;
print "ok 45\n";

($a = v196.172.300.300.196.172.172) =~ tr/\x{12c}/\x{12d}/s;
print "not " unless $a eq v196.172.301.196.172.172;
print "ok 46\n";

# Tricky cases by Simon Cozens.

($a = v196.172.200) =~ tr/\x{12c}/a/;
print "not " unless sprintf("%vd", $a) eq '196.172.200';
print "ok 47\n";

($a = v196.172.200) =~ tr/\x{12c}/\x{12c}/;
print "not " unless sprintf("%vd", $a) eq '196.172.200';
print "ok 48\n";

($a = v196.172.200) =~ tr/\x{12c}//d;
print "not " unless sprintf("%vd", $a) eq '196.172.200';
print "ok 49\n";

# UTF8 range

($a = v300.196.172.302.197.172) =~ tr/\x{12c}-\x{130}/\xc0-\xc4/;
print "not " unless $a eq v192.196.172.194.197.172;
print "ok 50\n";

($a = v300.196.172.302.197.172) =~ tr/\xc4-\xc8/\x{12c}-\x{130}/;
print "not " unless $a eq v300.300.172.302.301.172;
print "ok 51\n";

# misc
($a = "R0_001") =~ tr/R_//d;
print "not " if hex($a) != 1;
print "ok 52\n";

@@a = (1,2); map { y/1/./ for $_ } @@a;
print "not " if "@@a" ne ". 2";
print "ok 53\n";

@@a = (1,2); map { y/1/./ for $_.'' } @@a;
print "not " if "@@a" ne "1 2";
print "ok 54\n";
@


1.1.1.4
log
@stock perl 5.8.0 from CPAN
@
text
@a5 1
    require './test.pl';
d8 1
a8 3
plan tests => 97;

my $Is_EBCDIC = (ord('i') == 0x89 & ord('J') == 0xd1);
d14 2
a15 1
is($_, "ABCDEFGHIJKLMNOPQRSTUVWXYZ",    'uc');
d19 2
a20 1
is($_, "abcdefghijklmnopqrstuvwxyz",    'lc');
a22 1
is($_, "aBCDEFGHIJKLMNOPQRSTUVWXYz",    'partial uc');
d24 2
d36 2
a37 1
    is($_, "i\xcaj",    'EBCDIC discontinuity');
d41 1
a41 1

d46 2
a47 1
is($x + $y + $f + $g, 71,   'tr cancels IOK and NOK');
d49 1
a49 2

# perlbug [ID 20000511.005]
d54 2
a55 11
is($_, 'Fred',  'harmless if explicitly not updating');


# A variant of the above, added in 5.7.2
$_ = 'fred';
/([a-z]{2})/;
eval '$1 =~ tr/A-Z/A-Z/;';
s/^(\s*)f/$1F/;
is($_, 'Fred',  'harmless if implicitly not updating');
is($@@, '',      '    no error');

d59 2
a60 3
is($x, 256.65.258,  'handles UTF8');
is(length $x, 3);

a61 1
is(length $x, 3);
d63 1
a63 1
    is($x, 256.66.258);
d66 1
a66 1
    is($x, 256.65.258);
d68 1
a68 1

d71 2
a72 3
is(length $x, 3);
is($x, 256.193.258);

a73 1
is(length $x, 3);
d75 1
a75 1
    is($x, 256.193.258);
d78 1
a78 1
    is($x, 256.194.258);
d80 1
a80 1

d83 45
a127 34
    my $l = chr(300); my $r = chr(400);
    $x = 200.300.400;
    $x =~ tr/\x{12c}/\x{190}/;
    is($x, 200.400.400,     
                        'changing UTF8 chars in a UTF8 string, same length');
    is(length $x, 3);

    $x = 200.300.400;
    $x =~ tr/\x{12c}/\x{be8}/;
    is($x, 200.3048.400,    '    more bytes');
    is(length $x, 3);

    $x = 100.125.60;
    $x =~ tr/\x{64}/\x{190}/;
    is($x, 400.125.60,      'Putting UT8 chars into a non-UTF8 string');
    is(length $x, 3);

    $x = 400.125.60;
    $x =~ tr/\x{190}/\x{64}/;
    is($x, 100.125.60,      'Removing UTF8 chars from UTF8 string');
    is(length $x, 3);

    $x = 400.125.60.400;
    $y = $x =~ tr/\x{190}/\x{190}/;
    is($y, 2,               'Counting UTF8 chars in UTF8 string');

    $x = 60.400.125.60.400;
    $y = $x =~ tr/\x{3c}/\x{3c}/;
    is($y, 2,               '         non-UTF8 chars in UTF8 string');

    # 17 - counting UTF8 chars in non-UTF8 string
    $x = 200.125.60;
    $y = $x =~ tr/\x{190}/\x{190}/;
    is($y, 0,               '         UTF8 chars in non-UTFs string');
d130 1
d132 3
a134 2
eval 'tr/a-z-9/ /';
like($@@, qr/^Ambiguous range in transliteration operator/,  'tr/a-z-9//');
d139 1
a139 1
is($_, '..r.rot9',  'hyphens, leading');
d143 1
a143 1
is($_, '..r.rot9',  '   trailing');
d147 1
a147 1
is($_, '..r.rot9',  '   both');
d151 1
a151 1
is($_, '.bcd....ijklm.op');
d155 1
a155 1
is($_, '...de......lm...');
d159 1
a159 2
is($_, '...d.f...j.l...p');

d161 1
d164 2
a165 2
like($@@, qr/^Invalid \[\] range "m-d" in transliteration operator/,
              'reversed range check');
d167 1
d169 2
a170 6
like($@@, qr/^Modification of a read-only value attempted/,
              'cannot update read-only var');

'abcdef' =~ /(bcd)/;
is(eval '$1 =~ tr/abcd//', 3,  'explicit read-only count');
is($@@, '',                      '    no error');
d172 1
d174 1
a174 2
is(eval '$1 =~ tr/abcd/abcd/', 3,  'implicit read-only count');
is($@@, '',                      '    no error');
d176 2
a177 5
is(eval '"123" =~ tr/12//', 2,     'LHS of non-updating tr');

eval '"123" =~ tr/1/2/';
like($@@, qr|^Can't modify constant item in transliteration \(tr///\)|,
         'LHS bad on updating tr');
d179 4
d190 2
a191 1
is($a, v300.197.172.300.197.172,    'byte2byte transliteration');
d194 2
a195 1
is($a, v300.197.172.300.197.172);
d198 2
a199 1
is($a, v300.197.172.300.197.172);
d202 2
a203 1
is($a, v300.197.172.300.197.172);
d205 1
d208 4
a211 1
is($a, v300.301.172.300.301.172,    'byte2wide transliteration');
d214 4
a217 1
is($a, v195.196.172.195.196.172,    '   wide2byte');
d220 2
a221 1
is($a, v301.196.172.301.196.172,    '   wide2wide');
d223 1
d226 2
a227 1
is($a, v195.301.172.195.301.172,    'byte2wide & wide2byte');
d229 1
d233 2
a234 1
is($a, v197.301.173.197.301.173.401.198.144,    'all together now!');
d236 1
d238 3
a240 2
is((($a = v300.196.172.300.196.172) =~ tr/\xc4/\xc5/), 2,
                                     'transliterate and count');
d242 3
a244 1
is((($a = v300.196.172.300.196.172) =~ tr/\x{12c}/\x{12d}/), 2);
d246 1
d249 2
a250 1
is($a, v301.196.301.301.196.301,    'translit w/complement');
d253 2
a254 1
is($a, v300.197.197.300.197.197);
d256 1
d259 2
a260 1
is($a, v300.172.300.172,            'translit w/deletion');
d263 2
a264 1
is($a, v196.172.196.172);
d266 1
d269 2
a270 1
is($a, v197.172.300.300.197.172,    'translit w/squeeze');
d273 2
a274 1
is($a, v196.172.301.196.172.172);
d276 1
a277 1
# Tricky cases (When Simon Cozens Attacks)
d279 2
a280 1
is(sprintf("%vd", $a), '196.172.200');
d283 2
a284 1
is(sprintf("%vd", $a), '196.172.200');
d287 2
a288 1
is(sprintf("%vd", $a), '196.172.200');
d290 1
a291 3
# UTF8 range tests from Inaba Hiroto

# Not working in EBCDIC as of 12674.
d293 2
a294 1
is($a, v192.196.172.194.197.172,    'UTF range');
d297 2
a298 17
is($a, v300.300.172.302.301.172);


# UTF8 range tests from Karsten Sperling (patch #9008 required)

($a = "\x{0100}") =~ tr/\x00-\x{100}/X/;
is($a, "X");

($a = "\x{0100}") =~ tr/\x{0000}-\x{00ff}/X/c;
is($a, "X");

($a = "\x{0100}") =~ tr/\x{0000}-\x{00ff}\x{0101}/X/c;
is($a, "X");
 
($a = v256) =~ tr/\x{0000}-\x{00ff}\x{0101}/X/c;
is($a, "X");

d300 1
a300 53
# UTF8 range tests from Inaba Hiroto

($a = "\x{200}") =~ tr/\x00-\x{100}/X/c;
is($a, "X");

($a = "\x{200}") =~ tr/\x00-\x{100}/X/cs;
is($a, "X");


# Tricky on EBCDIC: while [a-z] [A-Z] must not match the gap characters,
# (i-j, r-s, I-J, R-S), [\x89-\x91] [\xc9-\xd1] has to match them,
# from Karsten Sperling.

# Not working in EBCDIC as of 12674.
$c = ($a = "\x89\x8a\x8b\x8c\x8d\x8f\x90\x91") =~ tr/\x89-\x91/X/;
is($c, 8);
is($a, "XXXXXXXX");
   
# Not working in EBCDIC as of 12674.
$c = ($a = "\xc9\xca\xcb\xcc\xcd\xcf\xd0\xd1") =~ tr/\xc9-\xd1/X/;
is($c, 8);
is($a, "XXXXXXXX");


SKIP: {   
    skip "not EBCDIC", 4 unless $Is_EBCDIC;

    $c = ($a = "\x89\x8a\x8b\x8c\x8d\x8f\x90\x91") =~ tr/i-j/X/;
    is($c, 2);
    is($a, "X\x8a\x8b\x8c\x8d\x8f\x90X");
   
    $c = ($a = "\xc9\xca\xcb\xcc\xcd\xcf\xd0\xd1") =~ tr/I-J/X/;
    is($c, 2);
    is($a, "X\xca\xcb\xcc\xcd\xcf\xd0X");
}

($a = "\x{100}") =~ tr/\x00-\xff/X/c;
is(ord($a), ord("X"));

($a = "\x{100}") =~ tr/\x00-\xff/X/cs;
is(ord($a), ord("X"));

($a = "\x{100}\x{100}") =~ tr/\x{101}-\x{200}//c;
is($a, "\x{100}\x{100}");

($a = "\x{100}\x{100}") =~ tr/\x{101}-\x{200}//cs;
is($a, "\x{100}");

$a = "\xfe\xff"; $a =~ tr/\xfe\xff/\x{1ff}\x{1fe}/;
is($a, "\x{1ff}\x{1fe}");


# From David Dyck
d302 2
a303 1
is(hex($a), 1);
a304 1
# From Inaba Hiroto
d306 2
a307 1
is("@@a", ". 2");
d310 2
a311 36
is("@@a", "1 2");


# Additional test for Inaba Hiroto patch (robin@@kitsite.com)
($a = "\x{100}\x{102}\x{101}") =~ tr/\x00-\377/XYZ/c;
is($a, "XZY");


# Used to fail with "Modification of a read-only value attempted"
%a = (N=>1);
foreach (keys %a) {
  eval 'tr/N/n/';
  is($_, 'n',   'pp_trans needs to unshare shared hash keys');
  is($@@, '',    '   no error');
}


$x = eval '"1213" =~ tr/1/1/';
is($x, 2,   'implicit count on constant');
is($@@, '',  '   no error');


my @@foo = ();
eval '$foo[-1] =~ tr/N/N/';
is( $@@, '',         'implicit count outside array bounds, index negative' );
is( scalar @@foo, 0, "    doesn't extend the array");

eval '$foo[1] =~ tr/N/N/';
is( $@@, '',         'implicit count outside array bounds, index positive' );
is( scalar @@foo, 0, "    doesn't extend the array");


my %foo = ();
eval '$foo{bar} =~ tr/N/N/';
is( $@@, '',         'implicit count outside hash bounds' );
is( scalar keys %foo, 0,   "    doesn't extend the hash");
@


1.1.1.5
log
@perl 5.8.2 from CPAN
@
text
@d9 1
a9 1
plan tests => 99;
d163 1
a163 1
like($@@, qr/^Invalid range "m-d" in transliteration operator/,
a381 4

$x = \"foo";
is( $x =~ tr/A/A/, 2, 'non-modifying tr/// on a scalar ref' );
is( ref $x, 'SCALAR', "    doesn't stringify its argument" );
@


1.1.1.6
log
@perl 5.8.8 import
@
text
@d9 1
a9 1
plan tests => 100;
d298 1
d302 2
a303 1

d308 2
a309 1
SKIP: {
a385 4

# rt.perl.org 36622.  Perl didn't like a y/// at end of file.  No trailing
# newline allowed.
fresh_perl_is(q[$_ = "foo"; y/A-Z/a-z/], '');
@


1.1.1.7
log
@import perl 5.10.0 from CPAN
@
text
@d9 1
a9 1
plan tests => 117;
d166 4
a386 81


{ # [perl #38293] chr(65535) should be allowed in regexes
no warnings 'utf8'; # to allow non-characters

$s = "\x{d800}\x{ffff}";
$s =~ tr/\0/A/;
is($s, "\x{d800}\x{ffff}", "do_trans_simple");

$s = "\x{d800}\x{ffff}";
$i = $s =~ tr/\0//;
is($i, 0, "do_trans_count");

$s = "\x{d800}\x{ffff}";
$s =~ tr/\0/A/s;
is($s, "\x{d800}\x{ffff}", "do_trans_complex, SQUASH");

$s = "\x{d800}\x{ffff}";
$s =~ tr/\0/A/c;
is($s, "AA", "do_trans_complex, COMPLEMENT");

$s = "A\x{ffff}B";
$s =~ tr/\x{ffff}/\x{1ffff}/;
is($s, "A\x{1ffff}B", "utf8, SEARCHLIST");

$s = "\x{fffd}\x{fffe}\x{ffff}";
$s =~ tr/\x{fffd}-\x{ffff}/ABC/;
is($s, "ABC", "utf8, SEARCHLIST range");

$s = "ABC";
$s =~ tr/ABC/\x{ffff}/;
is($s, "\x{ffff}"x3, "utf8, REPLACEMENTLIST");

$s = "ABC";
$s =~ tr/ABC/\x{fffd}-\x{ffff}/;
is($s, "\x{fffd}\x{fffe}\x{ffff}", "utf8, REPLACEMENTLIST range");

$s = "A\x{ffff}B\x{100}\0\x{fffe}\x{ffff}";
$i = $s =~ tr/\x{ffff}//;
is($i, 2, "utf8, count");

$s = "A\x{ffff}\x{ffff}C";
$s =~ tr/\x{ffff}/\x{100}/s;
is($s, "A\x{100}C", "utf8, SQUASH");

$s = "A\x{ffff}\x{ffff}\x{fffe}\x{fffe}\x{fffe}C";
$s =~ tr/\x{fffe}\x{ffff}//s;
is($s, "A\x{ffff}\x{fffe}C", "utf8, SQUASH");

$s = "xAABBBy";
$s =~ tr/AB/\x{ffff}/s;
is($s, "x\x{ffff}y", "utf8, SQUASH");

$s = "xAABBBy";
$s =~ tr/AB/\x{fffe}\x{ffff}/s;
is($s, "x\x{fffe}\x{ffff}y", "utf8, SQUASH");

$s = "A\x{ffff}B\x{fffe}C";
$s =~ tr/\x{fffe}\x{ffff}/x/c;
is($s, "x\x{ffff}x\x{fffe}x", "utf8, COMPLEMENT");

$s = "A\x{10000}B\x{2abcd}C";
$s =~ tr/\0-\x{ffff}/x/c;
is($s, "AxBxC", "utf8, COMPLEMENT range");

$s = "A\x{fffe}B\x{ffff}C";
$s =~ tr/\x{fffe}\x{ffff}/x/d;
is($s, "AxBC", "utf8, DELETE");

} # non-characters end

{ # related to [perl #27940]
    my $c;

    ($c = "\x20\c@@\x30\cA\x40\cZ\x50\c_\x60") =~ tr/\c@@-\c_//d;
    is($c, "\x20\x30\x40\x50\x60", "tr/\\c\@@-\\c_//d");

    ($c = "\x20\x00\x30\x01\x40\x1A\x50\x1F\x60") =~ tr/\x00-\x1f//d;
    is($c, "\x20\x30\x40\x50\x60", "tr/\\x00-\\x1f//d");
}

@


1.1.1.8
log
@import perl 5.10.1
@
text
@d9 1
a9 1
plan tests => 119;
a462 23

($s) = keys %{{pie => 3}};
my $wasro = Internals::SvREADONLY($s);
{
    $wasro or local $TODO = "didn't have a COW";
    $s =~ tr/i//;
    ok( Internals::SvREADONLY($s), "count-only tr doesn't deCOW COWs" );
}

# [ RT #61520 ]
#
# under threads, unicode tr within a cloned closure would SEGV or assert
# fail, since the pointer in the pad to the swash was getting zeroed out
# in the proto-CV

{
    my $x = "\x{142}";
    sub {
	$x =~ tr[\x{142}][\x{143}];
    }->();
    is($x,"\x{143}", "utf8 + closure");
}

@


1.1.1.9
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@a2 2
use utf8;

d9 1
a9 1
plan tests => 131;
a46 21
# /r
$_ = 'adam';
is y/dam/ve/rd, 'eve', '/r';
is $_, 'adam', '/r leaves param alone';
$g = 'ruby';
is $g =~ y/bury/repl/r, 'perl', '/r with explicit param';
is $g, 'ruby', '/r leaves explicit param alone';
is "aaa" =~ y\a\b\r, 'bbb', '/r with constant param';
ok !eval '$_ !~ y///r', "!~ y///r is forbidden";
like $@@, qr\^Using !~ with tr///r doesn't make sense\,
  "!~ y///r error message";
{
  my $w;
  my $wc;
  local $SIG{__WARN__} = sub { $w = shift; ++$wc };
  local $^W = 1;
  eval 'y///r; 1';
  like $w, qr '^Useless use of non-destructive transliteration \(tr///r\)',
    '/r warns in void context';
  is $wc, 1, '/r warns just once';
}
d465 2
a466 3
SKIP: {
    if (!eval { require B }) { skip "no B", 1 }
    my $wasro = B::svref_2object(\$s)->FLAGS & &B::SVf_READONLY;
d469 1
a469 2
    ok( B::svref_2object(\$s)->FLAGS & &B::SVf_READONLY,
       "count-only tr doesn't deCOW COWs" );
a485 16
# Freeing of trans ops prior to pmtrans() [perl #102858].
eval q{ $a ~= tr/a/b/; };
ok 1;
SKIP: {
    skip "no encoding", 1 unless eval { require encoding; 1 };
    eval q{ use encoding "utf8"; $a ~= tr/a/b/; };
    ok 1;
}

{ # [perl #113584]

    my $x = "Perlα";
    $x =~ tr/αα/βγ/;
    note $x;
    is($x, "Perlβ", "Only first of multiple transliterations is used");
}
a486 1
1;
@


1.1.1.10
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d11 1
a11 1
plan tests => 132;
d489 3
a491 3
    if (!eval { require XS::APItest }) { skip "no XS::APItest", 2 }
    my $wasro = XS::APItest::SvIsCOW($s);
    ok $wasro, "have a COW";
d493 1
a493 1
    ok( XS::APItest::SvIsCOW($s),
a514 1
    no warnings "deprecated";
@


1.1.1.11
log
@Import perl-5.20.1
@
text
@d11 1
a11 1
plan tests => 134;
a526 8
}

# tr/a/b/ should fail even on zero-length read-only strings
use constant nullrocow => (keys%{{""=>undef}})[0];
for ("", nullrocow) {
    eval { $_ =~ y/a/b/ };
    like $@@, qr/^Modification of a read-only value attempted at /,
        'tr/a/b/ fails on zero-length ro string';
@


1.1.1.12
log
@Import perl-5.24.2
@
text
@a1 1
$|=1;
d7 1
a8 1
    set_up_inc('../lib');
d11 1
a11 1
plan tests => 164;
d13 1
a13 3
# Test this first before we extend the stack with other operations.
# This caused an asan failure due to a bad write past the end of the stack.
eval { my $x; die  1..127, $x =~ y/// };
a27 97
eval 'tr/a/\N{KATAKANA LETTER AINU P}/;';
like $@@,
     qr/\\N\{KATAKANA LETTER AINU P} must not be a named sequence in transliteration operator/,
     "Illegal to tr/// named sequence";

eval 'tr/\x{101}-\x{100}//;';
like $@@,
     qr/Invalid range "\\x\{0101}-\\x\{0100}" in transliteration operator/,
     "UTF-8 range with min > max";

SKIP: {   # Test literal range end point special handling
    unless ($::IS_EBCDIC) {
        skip "Valid only for EBCDIC", 24;
    }

    $_ = "\x89";    # is 'i'
    tr/i-j//d;
    is($_, "", '"\x89" should match [i-j]');
    $_ = "\x8A";
    tr/i-j//d;
    is($_, "\x8A", '"\x8A" shouldnt match [i-j]');
    $_ = "\x90";
    tr/i-j//d;
    is($_, "\x90", '"\x90" shouldnt match [i-j]');
    $_ = "\x91";    # is 'j'
    tr/i-j//d;
    is($_, "", '"\x91" should match [i-j]');

    $_ = "\x89";
    tr/i-\N{LATIN SMALL LETTER J}//d;
    is($_, "", '"\x89" should match [i-\N{LATIN SMALL LETTER J}]');
    $_ = "\x8A";
    tr/i-\N{LATIN SMALL LETTER J}//d;
    is($_, "\x8A", '"\x8A" shouldnt match [i-\N{LATIN SMALL LETTER J}]');
    $_ = "\x90";
    tr/i-\N{LATIN SMALL LETTER J}//d;
    is($_, "\x90", '"\x90" shouldnt match [i-\N{LATIN SMALL LETTER J}]');
    $_ = "\x91";
    tr/i-\N{LATIN SMALL LETTER J}//d;
    is($_, "", '"\x91" should match [i-\N{LATIN SMALL LETTER J}]');

    $_ = "\x89";
    tr/i-\N{U+6A}//d;
    is($_, "", '"\x89" should match [i-\N{U+6A}]');
    $_ = "\x8A";
    tr/i-\N{U+6A}//d;
    is($_, "\x8A", '"\x8A" shouldnt match [i-\N{U+6A}]');
    $_ = "\x90";
    tr/i-\N{U+6A}//d;
    is($_, "\x90", '"\x90" shouldnt match [i-\N{U+6A}]');
    $_ = "\x91";
    tr/i-\N{U+6A}//d;
    is($_, "", '"\x91" should match [i-\N{U+6A}]');

    $_ = "\x89";
    tr/\N{U+69}-\N{U+6A}//d;
    is($_, "", '"\x89" should match [\N{U+69}-\N{U+6A}]');
    $_ = "\x8A";
    tr/\N{U+69}-\N{U+6A}//d;
    is($_, "\x8A", '"\x8A" shouldnt match [\N{U+69}-\N{U+6A}]');
    $_ = "\x90";
    tr/\N{U+69}-\N{U+6A}//d;
    is($_, "\x90", '"\x90" shouldnt match [\N{U+69}-\N{U+6A}]');
    $_ = "\x91";
    tr/\N{U+69}-\N{U+6A}//d;
    is($_, "", '"\x91" should match [\N{U+69}-\N{U+6A}]');

    $_ = "\x89";
    tr/i-\x{91}//d;
    is($_, "", '"\x89" should match [i-\x{91}]');
    $_ = "\x8A";
    tr/i-\x{91}//d;
    is($_, "", '"\x8A" should match [i-\x{91}]');
    $_ = "\x90";
    tr/i-\x{91}//d;
    is($_, "", '"\x90" should match [i-\x{91}]');
    $_ = "\x91";
    tr/i-\x{91}//d;
    is($_, "", '"\x91" should match [i-\x{91}]');

    # Need to use eval, because tries to compile on ASCII platforms even
    # though the tests are skipped, and fails because 0x89-j is an illegal
    # range there.
    $_ = "\x89";
    eval 'tr/\x{89}-j//d';
    is($_, "", '"\x89" should match [\x{89}-j]');
    $_ = "\x8A";
    eval 'tr/\x{89}-j//d';
    is($_, "", '"\x8A" should match [\x{89}-j]');
    $_ = "\x90";
    eval 'tr/\x{89}-j//d';
    is($_, "", '"\x90" should match [\x{89}-j]');
    $_ = "\x91";
    eval 'tr/\x{89}-j//d';
    is($_, "", '"\x91" should match [\x{89}-j]');
}

d33 1
d42 1
d95 1
a95 1
if ($::IS_ASCII) { # ASCII
d109 1
a109 1
if ($::IS_ASCII) { # ASCII
d281 1
d312 3
a314 2
# Tricky on EBCDIC: while [a-z] [A-Z] must not match the gap characters (as
# well as i-j, r-s, I-J, R-S), [\x89-\x91] [\xc9-\xd1] has to match them,
d326 1
a326 1
    skip "EBCDIC-centric tests", 4 unless $::IS_EBCDIC;
d525 1
a525 1
    { no warnings 'utf8'; print "# $x\n"; } # No note() to avoid wide warning.
a534 13
}

# Whether they're permitted or not, non-modifying tr/// should not write
# to read-only values, even with funky flags.
{ # [perl #123759]
	eval q{ ('a' =~ /./) =~ tr///d };
	ok(1, "tr///d on PL_Yes does not assert");
	eval q{ ('a' =~ /./) =~ tr/a-z/a-z/d };
	ok(1, "tr/a-z/a-z/d on PL_Yes does not assert");
	eval q{ ('a' =~ /./) =~ tr///s };
	ok(1, "tr///s on PL_Yes does not assert");
	eval q{ *x =~ tr///d };
	ok(1, "tr///d on glob does not assert");
@


