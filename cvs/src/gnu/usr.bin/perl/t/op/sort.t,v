head	1.17;
access;
symbols
	OPENBSD_6_1_BASE:1.17
	OPENBSD_6_0:1.16.0.8
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.16.0.2
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.16.0.4
	OPENBSD_5_8_BASE:1.16
	PERL_5_20_2:1.1.1.15
	OPENBSD_5_7:1.15.0.2
	OPENBSD_5_7_BASE:1.15
	PERL_5_20_1:1.1.1.14
	OPENBSD_5_6:1.14.0.4
	OPENBSD_5_6_BASE:1.14
	PERL_5_18_2:1.1.1.13
	PERL:1.1.1
	OPENBSD_5_5:1.13.0.6
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.2
	OPENBSD_5_4_BASE:1.13
	PERL_5_16_3:1.1.1.12
	OPENBSD_5_3:1.12.0.10
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.8
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.6
	OPENBSD_5_0:1.12.0.4
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.2
	OPENBSD_4_9_BASE:1.12
	PERL_5_12_2:1.1.1.11
	OPENBSD_4_8:1.11.0.4
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.2
	OPENBSD_4_7_BASE:1.11
	PERL_5_10_1:1.1.1.10
	OPENBSD_4_6:1.10.0.6
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.2
	OPENBSD_4_5_BASE:1.10
	PERL_5_10_0:1.1.1.9
	OPENBSD_4_4:1.9.0.10
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.8
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.6
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.4
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9
	PERL_5_8_8:1.1.1.8
	OPENBSD_3_9:1.8.0.6
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.4
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.2
	OPENBSD_3_7_BASE:1.8
	PERL_5_8_6:1.1.1.7
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7
	PERL_5_8_5:1.1.1.6
	PERL_5_8_3:1.1.1.5
	OPENBSD_3_5:1.6.0.6
	OPENBSD_3_5_BASE:1.6
	PERL_5_8_2:1.1.1.5
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.17
date	2017.02.05.00.32.20;	author afresh1;	state Exp;
branches;
next	1.16;
commitid	cxJ08BvJA9Pt2PTM;

1.16
date	2015.04.25.19.14.48;	author afresh1;	state Exp;
branches;
next	1.15;
commitid	XRK22kO4se3v2i2I;

1.15
date	2014.11.17.20.57.07;	author afresh1;	state Exp;
branches;
next	1.14;
commitid	QP75iYx42Uo7mMxO;

1.14
date	2014.03.24.15.05.33;	author afresh1;	state Exp;
branches;
next	1.13;

1.13
date	2013.03.25.20.41.00;	author sthen;	state Exp;
branches;
next	1.12;

1.12
date	2010.09.24.15.07.09;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2009.10.12.18.30.28;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2008.09.29.17.36.20;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2006.03.28.19.23.13;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2005.01.15.21.30.40;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2004.08.09.18.10.27;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.37;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.36.22;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.08.32;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.52.38;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.08.05.42;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.13.22;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.13.22;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.41.51;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.10.51;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.25.47;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.15.11;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.08.09.17.48.35;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2005.01.15.21.18.19;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2006.03.28.18.49.46;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2008.09.29.17.19.01;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2009.10.12.18.10.44;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2010.09.24.14.49.17;	author millert;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2013.03.25.20.09.37;	author sthen;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2014.03.24.14.59.10;	author afresh1;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2014.11.17.20.53.18;	author afresh1;	state Exp;
branches;
next	1.1.1.15;
commitid	B31cAbBIXiCqnL97;

1.1.1.15
date	2015.04.25.19.10.48;	author afresh1;	state Exp;
branches;
next	;
commitid	Wpcs5S8qILgEZC7F;


desc
@@


1.17
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl
$|=1;

BEGIN {
    chdir 't' if -d 't';
    require './test.pl';
    set_up_inc('../lib');
}
use warnings;
plan(tests => 195);

# these shouldn't hang
{
    no warnings;
    sort { for ($_ = 0;; $_++) {} } @@a;
    sort { while(1) {}            } @@a;
    sort { while(1) { last; }     } @@a;
    sort { while(0) { last; }     } @@a;

    # Change 26011: Re: A surprising segfault
    map scalar(sort(+())), ('')x68;
}

sub Backwards { $a lt $b ? 1 : $a gt $b ? -1 : 0 }
sub Backwards_stacked($$) { my($a,$b) = @@_; $a lt $b ? 1 : $a gt $b ? -1 : 0 }
sub Backwards_other { $a lt $b ? 1 : $a gt $b ? -1 : 0 }

my $upperfirst = 'A' lt 'a';

# Beware: in future this may become hairier because of possible
# collation complications: qw(A a B b) can be sorted at least as
# any of the following
#
#	A a B b
#	A B a b
#	a b A B
#	a A b B
#
# All the above orders make sense.
#
# That said, EBCDIC sorts all small letters first, as opposed
# to ASCII which sorts all big letters first.

@@harry = ('dog','cat','x','Cain','Abel');
@@george = ('gone','chased','yz','punished','Axed');

$x = join('', sort @@harry);
$expected = $upperfirst ? 'AbelCaincatdogx' : 'catdogxAbelCain';

cmp_ok($x,'eq',$expected,'upper first 1');

$x = join('', sort( Backwards @@harry));
$expected = $upperfirst ? 'xdogcatCainAbel' : 'CainAbelxdogcat';

cmp_ok($x,'eq',$expected,'upper first 2');

$x = join('', sort( Backwards_stacked @@harry));
$expected = $upperfirst ? 'xdogcatCainAbel' : 'CainAbelxdogcat';

cmp_ok($x,'eq',$expected,'upper first 3');

$x = join('', sort @@george, 'to', @@harry);
$expected = $upperfirst ?
    'AbelAxedCaincatchaseddoggonepunishedtoxyz' :
    'catchaseddoggonepunishedtoxyzAbelAxedCain' ;

my @@initially_sorted = ( 0 .. 260,
                         0x3FF, 0x400, 0x401,
                         0x7FF, 0x800, 0x801,
                         0x3FFF, 0x4000, 0x4001,
		         0xFFFF, 0x10000, 0x10001,
                       );
# It makes things easier below if there are an even number of elements in the
# array.
if (scalar(@@initially_sorted) % 2 == 1) {
    push @@initially_sorted, $initially_sorted[-1] + 1;
}

# We convert to a chr(), but prepend a constant string to make sure things can
# work on more than a single character.
my $prefix = "a\xb6";
my $prefix_len = length $prefix;

my @@chr_initially_sorted = @@initially_sorted;
$_ = $prefix . chr($_) for @@chr_initially_sorted;

# Create a very unsorted version by reversing it, and then pushing the same
# code points again, but pair-wise reversed.
my @@initially_unsorted = reverse @@chr_initially_sorted;
for (my $i = 0; $i < @@chr_initially_sorted - 1; $i += 2) {
    push @@initially_unsorted, $chr_initially_sorted[$i+1],
                              $chr_initially_sorted[$i];
}

# And, an all-UTF-8 version
my @@utf8_initialy_unsorted = @@initially_unsorted;
utf8::upgrade($_) for @@utf8_initialy_unsorted;

# Sort the non-UTF-8 version
my @@non_utf8_result = sort @@initially_unsorted;
my @@wrongly_utf8;
my $ordered_correctly = 1;
for my $i (0 .. @@chr_initially_sorted -1) {
    if (   $chr_initially_sorted[$i] ne $non_utf8_result[2*$i]
        || $chr_initially_sorted[$i] ne $non_utf8_result[2*$i+1])
    {
        $ordered_correctly = 0;
        last;
    }
    push @@wrongly_utf8, $i if $i < 256 && utf8::is_utf8($non_utf8_result[$i]);
}
if (! ok($ordered_correctly, "sort of non-utf8 list worked")) {
    diag ("This should be in numeric order (with 2 instances of every code point):\n"
        . join " ", map { sprintf "%02x", ord substr $_, $prefix_len, 1 } @@non_utf8_result);
}
if (! is(@@wrongly_utf8, 0,
                      "No elements were wrongly converted to utf8 in sorting"))
{
    diag "For code points " . join " ", @@wrongly_utf8;
}

# And then the UTF-8 one
my @@wrongly_non_utf8;
$ordered_correctly = 1;
my @@utf8_result = sort @@utf8_initialy_unsorted;
for my $i (0 .. @@chr_initially_sorted -1) {
    if (   $chr_initially_sorted[$i] ne $utf8_result[2*$i]
        || $chr_initially_sorted[$i] ne $utf8_result[2*$i+1])
    {
        $ordered_correctly = 0;
        last;
    }
    push @@wrongly_non_utf8, $i unless utf8::is_utf8($utf8_result[$i]);
}
if (! ok($ordered_correctly, "sort of utf8 list worked")) {
    diag ("This should be in numeric order (with 2 instances of every code point):\n"
        . join " ", map { sprintf "%02x", ord substr $_, $prefix_len, 1 } @@utf8_result);
}
if (! is(@@wrongly_non_utf8, 0,
                      "No elements were wrongly converted from utf8 in sorting"))
{
    diag "For code points " . join " ", @@wrongly_non_utf8;
}

cmp_ok($x,'eq',$expected,'upper first 4');
$" = ' ';
@@a = ();
@@b = reverse @@a;
cmp_ok("@@b",'eq',"",'reverse 1');

@@a = (1);
@@b = reverse @@a;
cmp_ok("@@b",'eq',"1",'reverse 2');

@@a = (1,2);
@@b = reverse @@a;
cmp_ok("@@b",'eq',"2 1",'reverse 3');

@@a = (1,2,3);
@@b = reverse @@a;
cmp_ok("@@b",'eq',"3 2 1",'reverse 4');

@@a = (1,2,3,4);
@@b = reverse @@a;
cmp_ok("@@b",'eq',"4 3 2 1",'reverse 5');

@@a = (10,2,3,4);
@@b = sort {$a <=> $b;} @@a;
cmp_ok("@@b",'eq',"2 3 4 10",'sort numeric');

$sub = 'Backwards';
$x = join('', sort $sub @@harry);
$expected = $upperfirst ? 'xdogcatCainAbel' : 'CainAbelxdogcat';

cmp_ok($x,'eq',$expected,'sorter sub name in var 1');

$sub = 'Backwards_stacked';
$x = join('', sort $sub @@harry);
$expected = $upperfirst ? 'xdogcatCainAbel' : 'CainAbelxdogcat';

cmp_ok($x,'eq',$expected,'sorter sub name in var 2');

# literals, combinations

@@b = sort (4,1,3,2);
cmp_ok("@@b",'eq','1 2 3 4','just sort');


@@b = sort grep { $_ } (4,1,3,2);
cmp_ok("@@b",'eq','1 2 3 4','grep then sort');


@@b = sort map { $_ } (4,1,3,2);
cmp_ok("@@b",'eq','1 2 3 4','map then sort');


@@b = sort reverse (4,1,3,2);
cmp_ok("@@b",'eq','1 2 3 4','reverse then sort');


@@b = sort CORE::reverse (4,1,3,2);
cmp_ok("@@b",'eq','1 2 3 4','CORE::reverse then sort');

eval  { @@b = sort CORE::revers (4,1,3,2); };
like($@@, qr/^Undefined sort subroutine "CORE::revers" called at /);


sub twoface { no warnings 'redefine'; *twoface = sub { $a <=> $b }; &twoface }
eval { @@b = sort twoface 4,1,3,2 };
cmp_ok("@@b",'eq','1 2 3 4','redefine sort sub inside the sort sub');


eval { no warnings 'redefine'; *twoface = sub { &Backwards } };
ok(!$@@,"redefining sort subs outside the sort \$@@=[$@@]");

eval { @@b = sort twoface 4,1,3,2 };
cmp_ok("@@b",'eq','4 3 2 1','twoface redefinition');

{
  no warnings 'redefine';
  *twoface = sub { *twoface = *Backwards_other; $a <=> $b };
}

eval { @@b = sort twoface 4,1,9,5 };
ok(($@@ eq "" && "@@b" eq "1 4 5 9"),'redefinition should not take effect during the sort');

{
  no warnings 'redefine';
  *twoface = sub {
                 eval 'sub twoface { $a <=> $b }';
		 die($@@ eq "" ? "good\n" : "bad\n");
		 $a <=> $b;
	       };
}
eval { @@b = sort twoface 4,1 };
cmp_ok(substr($@@,0,4), 'eq', 'good', 'twoface eval');

eval <<'CODE';
    my @@result = sort main'Backwards 'one', 'two';
CODE
cmp_ok($@@,'eq','',q(old skool package));

eval <<'CODE';
    # "sort 'one', 'two'" should not try to parse "'one" as a sort sub
    my @@result = sort 'one', 'two';
CODE
cmp_ok($@@,'eq','',q(one is not a sub));

{
  my $sortsub = \&Backwards;
  my $sortglob = *Backwards;
  my $sortglobr = \*Backwards;
  my $sortname = 'Backwards';
  @@b = sort $sortsub 4,1,3,2;
  cmp_ok("@@b",'eq','4 3 2 1','sortname 1');
  @@b = sort $sortglob 4,1,3,2;
  cmp_ok("@@b",'eq','4 3 2 1','sortname 2');
  @@b = sort $sortname 4,1,3,2;
  cmp_ok("@@b",'eq','4 3 2 1','sortname 3');
  @@b = sort $sortglobr 4,1,3,2;
  cmp_ok("@@b",'eq','4 3 2 1','sortname 4');
}

{
  my $sortsub = \&Backwards_stacked;
  my $sortglob = *Backwards_stacked;
  my $sortglobr = \*Backwards_stacked;
  my $sortname = 'Backwards_stacked';
  @@b = sort $sortsub 4,1,3,2;
  cmp_ok("@@b",'eq','4 3 2 1','sortname 5');
  @@b = sort $sortglob 4,1,3,2;
  cmp_ok("@@b",'eq','4 3 2 1','sortname 6');
  @@b = sort $sortname 4,1,3,2;
  cmp_ok("@@b",'eq','4 3 2 1','sortname 7');
  @@b = sort $sortglobr 4,1,3,2;
  cmp_ok("@@b",'eq','4 3 2 1','sortname 8');
}

{
  local $sortsub = \&Backwards;
  local $sortglob = *Backwards;
  local $sortglobr = \*Backwards;
  local $sortname = 'Backwards';
  @@b = sort $sortsub 4,1,3,2;
  cmp_ok("@@b",'eq','4 3 2 1','sortname local 1');
  @@b = sort $sortglob 4,1,3,2;
  cmp_ok("@@b",'eq','4 3 2 1','sortname local 2');
  @@b = sort $sortname 4,1,3,2;
  cmp_ok("@@b",'eq','4 3 2 1','sortname local 3');
  @@b = sort $sortglobr 4,1,3,2;
  cmp_ok("@@b",'eq','4 3 2 1','sortname local 4');
}

{
  local $sortsub = \&Backwards_stacked;
  local $sortglob = *Backwards_stacked;
  local $sortglobr = \*Backwards_stacked;
  local $sortname = 'Backwards_stacked';
  @@b = sort $sortsub 4,1,3,2;
  cmp_ok("@@b",'eq','4 3 2 1','sortname local 5');
  @@b = sort $sortglob 4,1,3,2;
  cmp_ok("@@b",'eq','4 3 2 1','sortname local 6');
  @@b = sort $sortname 4,1,3,2;
  cmp_ok("@@b",'eq','4 3 2 1','sortname local 7');
  @@b = sort $sortglobr 4,1,3,2;
  cmp_ok("@@b",'eq','4 3 2 1','sortname local 8');
}

## exercise sort builtins... ($a <=> $b already tested)
@@a = ( 5, 19, 1996, 255, 90 );
@@b = sort {
    my $dummy;		# force blockness
    return $b <=> $a
} @@a;
cmp_ok("@@b",'eq','1996 255 90 19 5','force blockness');

$x = join('', sort { $a cmp $b } @@harry);
$expected = $upperfirst ? 'AbelCaincatdogx' : 'catdogxAbelCain';
cmp_ok($x,'eq',$expected,'a cmp b');

$x = join('', sort { $b cmp $a } @@harry);
$expected = $upperfirst ? 'xdogcatCainAbel' : 'CainAbelxdogcat';
cmp_ok($x,'eq',$expected,'b cmp a');

{
    use integer;
    @@b = sort { $a <=> $b } @@a;
    cmp_ok("@@b",'eq','5 19 90 255 1996','integer a <=> b');

    @@b = sort { $b <=> $a } @@a;
    cmp_ok("@@b",'eq','1996 255 90 19 5','integer b <=> a');

    $x = join('', sort { $a cmp $b } @@harry);
    $expected = $upperfirst ? 'AbelCaincatdogx' : 'catdogxAbelCain';
    cmp_ok($x,'eq',$expected,'integer a cmp b');

    $x = join('', sort { $b cmp $a } @@harry);
    $expected = $upperfirst ? 'xdogcatCainAbel' : 'CainAbelxdogcat';
    cmp_ok($x,'eq',$expected,'integer b cmp a');

}



$x = join('', sort { $a <=> $b } 3, 1, 2);
cmp_ok($x,'eq','123',q(optimized-away comparison block doesn't take any other arguments away with it));

# test sorting in non-main package
{
    package Foo;
    @@a = ( 5, 19, 1996, 255, 90 );
    @@b = sort { $b <=> $a } @@a;
    ::cmp_ok("@@b",'eq','1996 255 90 19 5','not in main:: 1');

    @@b = sort ::Backwards_stacked @@a;
    ::cmp_ok("@@b",'eq','90 5 255 1996 19','not in main:: 2');

    # check if context for sort arguments is handled right
    sub test_if_list {
        my $gimme = wantarray;
        ::is($gimme,1,'wantarray 1');
    }
    my $m = sub { $a <=> $b };

    sub cxt_one { sort $m test_if_list() }
    cxt_one();
    sub cxt_two { sort { $a <=> $b } test_if_list() }
    cxt_two();
    sub cxt_three { sort &test_if_list() }
    cxt_three();
    sub cxt_three_anna_half { sort 0, test_if_list() }
    cxt_three_anna_half();

    sub test_if_scalar {
        my $gimme = wantarray;
        ::is(!($gimme or !defined($gimme)),1,'wantarray 2');
    }

    $m = \&test_if_scalar;
    sub cxt_four { sort $m 1,2 }
    @@x = cxt_four();
    sub cxt_five { sort { test_if_scalar($a,$b); } 1,2 }
    @@x = cxt_five();
    sub cxt_six { sort test_if_scalar 1,2 }
    @@x = cxt_six();
}


# test against a reentrancy bug
{
    package Bar;
    sub compare { $a cmp $b }
    sub reenter { my @@force = sort compare qw/a b/ }
}
{
    my($def, $init) = (0, 0);
    @@b = sort {
	$def = 1 if defined $Bar::a;
	Bar::reenter() unless $init++;
	$a <=> $b
    } qw/4 3 1 2/;
    cmp_ok("@@b",'eq','1 2 3 4','reenter 1');

    ok(!$def,'reenter 2');
}


{
    sub routine { "one", "two" };
    @@a = sort(routine(1));
    cmp_ok("@@a",'eq',"one two",'bug id 19991001.003');
}


# check for in-place optimisation of @@a = sort @@a
{
    my ($r1,$r2,@@a);
    our @@g;
    @@g = (3,2,1); $r1 = \$g[2]; @@g = sort @@g; $r2 = \$g[0];
    is "$r1-@@g", "$r2-1 2 3", "inplace sort of global";

    @@a = qw(b a c); $r1 = \$a[1]; @@a = sort @@a; $r2 = \$a[0];
    is "$r1-@@a", "$r2-a b c", "inplace sort of lexical";

    @@g = (2,3,1); $r1 = \$g[1]; @@g = sort { $b <=> $a } @@g; $r2 = \$g[0];
    is "$r1-@@g", "$r2-3 2 1", "inplace reversed sort of global";

    @@g = (2,3,1);
    $r1 = \$g[1]; @@g = sort { $a<$b?1:$a>$b?-1:0 } @@g; $r2 = \$g[0];
    is "$r1-@@g", "$r2-3 2 1", "inplace custom sort of global";

    sub mysort { $b cmp $a };
    @@a = qw(b c a); $r1 = \$a[1]; @@a = sort mysort @@a; $r2 = \$a[0];
    is "$r1-@@a", "$r2-c b a", "inplace sort with function of lexical";

    use Tie::Array;
    my @@t;
    tie @@t, 'Tie::StdArray';

    @@t = qw(b c a); @@t = sort @@t;
    is "@@t", "a b c", "inplace sort of tied array";

    @@t = qw(b c a); @@t = sort mysort @@t;
    is "@@t", "c b a", "inplace sort of tied array with function";

    #  [perl #29790] don't optimise @@a = ('a', sort @@a) !

    @@g = (3,2,1); @@g = ('0', sort @@g);
    is "@@g", "0 1 2 3", "un-inplace sort of global";
    @@g = (3,2,1); @@g = (sort(@@g),'4');
    is "@@g", "1 2 3 4", "un-inplace sort of global 2";

    @@a = qw(b a c); @@a = ('x', sort @@a);
    is "@@a", "x a b c", "un-inplace sort of lexical";
    @@a = qw(b a c); @@a = ((sort @@a), 'x');
    is "@@a", "a b c x", "un-inplace sort of lexical 2";

    @@g = (2,3,1); @@g = ('0', sort { $b <=> $a } @@g);
    is "@@g", "0 3 2 1", "un-inplace reversed sort of global";
    @@g = (2,3,1); @@g = ((sort { $b <=> $a } @@g),'4');
    is "@@g", "3 2 1 4", "un-inplace reversed sort of global 2";

    @@g = (2,3,1); @@g = ('0', sort { $a<$b?1:$a>$b?-1:0 } @@g);
    is "@@g", "0 3 2 1", "un-inplace custom sort of global";
    @@g = (2,3,1); @@g = ((sort { $a<$b?1:$a>$b?-1:0 } @@g),'4');
    is "@@g", "3 2 1 4", "un-inplace custom sort of global 2";

    @@a = qw(b c a); @@a = ('x', sort mysort @@a);
    is "@@a", "x c b a", "un-inplace sort with function of lexical";
    @@a = qw(b c a); @@a = ((sort mysort @@a),'x');
    is "@@a", "c b a x", "un-inplace sort with function of lexical 2";

    # RT#54758. Git 62b40d2474e7487e6909e1872b6bccdf812c6818
    no warnings 'void';
    my @@m; push @@m, 0 for 1 .. 1024; $#m; @@m = sort @@m;
    ::pass("in-place sorting segfault");
}

# Test optimisations of reversed sorts. As we now guarantee stability by
# default, # optimisations which do not provide this are bogus.

{
    package Oscalar;
    use overload (qw("" stringify 0+ numify fallback 1));

    sub new {
	bless [$_[1], $_[2]], $_[0];
    }

    sub stringify { $_[0]->[0] }

    sub numify { $_[0]->[1] }
}

sub generate {
    my $count = 0;
    map {new Oscalar $_, $count++} qw(A A A B B B C C C);
}

my @@input = &generate;
my @@output = sort @@input;
is join(" ", map {0+$_} @@output), "0 1 2 3 4 5 6 7 8", "Simple stable sort";

@@input = &generate;
@@input = sort @@input;
is join(" ", map {0+$_} @@input), "0 1 2 3 4 5 6 7 8",
    "Simple stable in place sort";

# This won't be very interesting
@@input = &generate;
@@output = sort {$a <=> $b} @@input;
is "@@output", "A A A B B B C C C", 'stable $a <=> $b sort';

@@input = &generate;
@@output = sort {$a cmp $b} @@input;
is join(" ", map {0+$_} @@output), "0 1 2 3 4 5 6 7 8", 'stable $a cmp $b sort';

@@input = &generate;
@@input = sort {$a cmp $b} @@input;
is join(" ", map {0+$_} @@input), "0 1 2 3 4 5 6 7 8",
    'stable $a cmp $b in place sort';

@@input = &generate;
@@output = sort {$b cmp $a} @@input;
is join(" ", map {0+$_} @@output), "6 7 8 3 4 5 0 1 2", 'stable $b cmp $a sort';

@@input = &generate;
@@input = sort {$b cmp $a} @@input;
is join(" ", map {0+$_} @@input), "6 7 8 3 4 5 0 1 2",
    'stable $b cmp $a in place sort';

@@input = &generate;
@@output = reverse sort @@input;
is join(" ", map {0+$_} @@output), "8 7 6 5 4 3 2 1 0", "Reversed stable sort";

@@input = &generate;
@@input = reverse sort @@input;
is join(" ", map {0+$_} @@input), "8 7 6 5 4 3 2 1 0",
    "Reversed stable in place sort";

@@input = &generate;
my $output = reverse sort @@input;
is $output, "CCCBBBAAA", "Reversed stable sort in scalar context";


@@input = &generate;
@@output = reverse sort {$a cmp $b} @@input;
is join(" ", map {0+$_} @@output), "8 7 6 5 4 3 2 1 0",
    'reversed stable $a cmp $b sort';

@@input = &generate;
@@input = reverse sort {$a cmp $b} @@input;
is join(" ", map {0+$_} @@input), "8 7 6 5 4 3 2 1 0",
    'revesed stable $a cmp $b in place sort';

@@input = &generate;
$output = reverse sort {$a cmp $b} @@input;
is $output, "CCCBBBAAA", 'Reversed stable $a cmp $b sort in scalar context';

@@input = &generate;
@@output = reverse sort {$b cmp $a} @@input;
is join(" ", map {0+$_} @@output), "2 1 0 5 4 3 8 7 6",
    'reversed stable $b cmp $a sort';

@@input = &generate;
@@input = reverse sort {$b cmp $a} @@input;
is join(" ", map {0+$_} @@input), "2 1 0 5 4 3 8 7 6",
    'revesed stable $b cmp $a in place sort';

@@input = &generate;
$output = reverse sort {$b cmp $a} @@input;
is $output, "AAABBBCCC", 'Reversed stable $b cmp $a sort in scalar context';

sub stuff {
    # Something complex enough to defeat any constant folding optimiser
    $$ - $$;
}

@@input = &generate;
@@output = reverse sort {stuff || $a cmp $b} @@input;
is join(" ", map {0+$_} @@output), "8 7 6 5 4 3 2 1 0",
    'reversed stable complex sort';

@@input = &generate;
@@input = reverse sort {stuff || $a cmp $b} @@input;
is join(" ", map {0+$_} @@input), "8 7 6 5 4 3 2 1 0",
    'revesed stable complex in place sort';

@@input = &generate;
$output = reverse sort {stuff || $a cmp $b } @@input;
is $output, "CCCBBBAAA", 'Reversed stable complex sort in scalar context';

sub sortr {
    reverse sort @@_;
}

@@output = sortr &generate;
is join(" ", map {0+$_} @@output), "8 7 6 5 4 3 2 1 0",
    'reversed stable sort return list context';
$output = sortr &generate;
is $output, "CCCBBBAAA",
    'reversed stable sort return scalar context';

sub sortcmpr {
    reverse sort {$a cmp $b} @@_;
}

@@output = sortcmpr &generate;
is join(" ", map {0+$_} @@output), "8 7 6 5 4 3 2 1 0",
    'reversed stable $a cmp $b sort return list context';
$output = sortcmpr &generate;
is $output, "CCCBBBAAA",
    'reversed stable $a cmp $b sort return scalar context';

sub sortcmprba {
    reverse sort {$b cmp $a} @@_;
}

@@output = sortcmprba &generate;
is join(" ", map {0+$_} @@output), "2 1 0 5 4 3 8 7 6",
    'reversed stable $b cmp $a sort return list context';
$output = sortcmprba &generate;
is $output, "AAABBBCCC",
'reversed stable $b cmp $a sort return scalar context';

sub sortcmprq {
    reverse sort {stuff || $a cmp $b} @@_;
}

@@output = sortcmpr &generate;
is join(" ", map {0+$_} @@output), "8 7 6 5 4 3 2 1 0",
    'reversed stable complex sort return list context';
$output = sortcmpr &generate;
is $output, "CCCBBBAAA",
    'reversed stable complex sort return scalar context';

# And now with numbers

sub generate1 {
    my $count = 'A';
    map {new Oscalar $count++, $_} 0, 0, 0, 1, 1, 1, 2, 2, 2;
}

# This won't be very interesting
@@input = &generate1;
@@output = sort {$a cmp $b} @@input;
is "@@output", "A B C D E F G H I", 'stable $a cmp $b sort';

@@input = &generate1;
@@output = sort {$a <=> $b} @@input;
is "@@output", "A B C D E F G H I", 'stable $a <=> $b sort';

@@input = &generate1;
@@input = sort {$a <=> $b} @@input;
is "@@input", "A B C D E F G H I", 'stable $a <=> $b in place sort';

@@input = &generate1;
@@output = sort {$b <=> $a} @@input;
is "@@output", "G H I D E F A B C", 'stable $b <=> $a sort';

@@input = &generate1;
@@input = sort {$b <=> $a} @@input;
is "@@input", "G H I D E F A B C", 'stable $b <=> $a in place sort';

# test that optimized {$b cmp $a} and {$b <=> $a} remain stable
# (new in 5.9) without overloading
{ no warnings;
@@b = sort { $b <=> $a } @@input = qw/5first 6first 5second 6second/;
is "@@b" , "6first 6second 5first 5second", "optimized {$b <=> $a} without overloading" ;
@@input = sort {$b <=> $a} @@input;
is "@@input" , "6first 6second 5first 5second","inline optimized {$b <=> $a} without overloading" ;
};

# These two are actually doing string cmp on 0 1 and 2
@@input = &generate1;
@@output = reverse sort @@input;
is "@@output", "I H G F E D C B A", "Reversed stable sort";

@@input = &generate1;
@@input = reverse sort @@input;
is "@@input", "I H G F E D C B A", "Reversed stable in place sort";

@@input = &generate1;
$output = reverse sort @@input;
is $output, "IHGFEDCBA", "Reversed stable sort in scalar context";

@@input = &generate1;
@@output = reverse sort {$a <=> $b} @@input;
is "@@output", "I H G F E D C B A", 'reversed stable $a <=> $b sort';

@@input = &generate1;
@@input = reverse sort {$a <=> $b} @@input;
is "@@input", "I H G F E D C B A", 'revesed stable $a <=> $b in place sort';

@@input = &generate1;
$output = reverse sort {$a <=> $b} @@input;
is $output, "IHGFEDCBA", 'reversed stable $a <=> $b sort in scalar context';

@@input = &generate1;
@@output = reverse sort {$b <=> $a} @@input;
is "@@output", "C B A F E D I H G", 'reversed stable $b <=> $a sort';

@@input = &generate1;
@@input = reverse sort {$b <=> $a} @@input;
is "@@input", "C B A F E D I H G", 'revesed stable $b <=> $a in place sort';

@@input = &generate1;
$output = reverse sort {$b <=> $a} @@input;
is $output, "CBAFEDIHG", 'reversed stable $b <=> $a sort in scalar context';

@@input = &generate1;
@@output = reverse sort {stuff || $a <=> $b} @@input;
is "@@output", "I H G F E D C B A", 'reversed stable complex sort';

@@input = &generate1;
@@input = reverse sort {stuff || $a <=> $b} @@input;
is "@@input", "I H G F E D C B A", 'revesed stable complex in place sort';

@@input = &generate1;
$output = reverse sort {stuff || $a <=> $b} @@input;
is $output, "IHGFEDCBA", 'reversed stable complex sort in scalar context';

sub sortnumr {
    reverse sort {$a <=> $b} @@_;
}

@@output = sortnumr &generate1;
is "@@output", "I H G F E D C B A",
    'reversed stable $a <=> $b sort return list context';
$output = sortnumr &generate1;
is $output, "IHGFEDCBA", 'reversed stable $a <=> $b sort return scalar context';

sub sortnumrba {
    reverse sort {$b <=> $a} @@_;
}

@@output = sortnumrba &generate1;
is "@@output", "C B A F E D I H G",
    'reversed stable $b <=> $a sort return list context';
$output = sortnumrba &generate1;
is $output, "CBAFEDIHG", 'reversed stable $b <=> $a sort return scalar context';

sub sortnumrq {
    reverse sort {stuff || $a <=> $b} @@_;
}

@@output = sortnumrq &generate1;
is "@@output", "I H G F E D C B A",
    'reversed stable complex sort return list context';
$output = sortnumrq &generate1;
is $output, "IHGFEDCBA", 'reversed stable complex sort return scalar context';

@@output = reverse (sort(qw(C A B)), 0);
is "@@output", "0 C B A", 'reversed sort with trailing argument';

@@output = reverse (0, sort(qw(C A B)));
is "@@output", "C B A 0", 'reversed sort with leading argument';

eval { @@output = sort {goto sub {}} 1,2; };
$fail_msg = q(Can't goto subroutine outside a subroutine);
cmp_ok(substr($@@,0,length($fail_msg)),'eq',$fail_msg,'goto subr outside subr');



sub goto_sub {goto sub{}}
eval { @@output = sort goto_sub 1,2; };
$fail_msg = q(Can't goto subroutine from a sort sub);
cmp_ok(substr($@@,0,length($fail_msg)),'eq',$fail_msg,'goto subr from a sort sub');



eval { @@output = sort {goto label} 1,2; };
$fail_msg = q(Can't "goto" out of a pseudo block);
cmp_ok(substr($@@,0,length($fail_msg)),'eq',$fail_msg,'goto out of a pseudo block 1');



sub goto_label {goto label}
label: eval { @@output = sort goto_label 1,2; };
$fail_msg = q(Can't "goto" out of a pseudo block);
cmp_ok(substr($@@,0,length($fail_msg)),'eq',$fail_msg,'goto out of a pseudo block 2');



sub self_immolate {undef &self_immolate; $a<=>$b}
eval { @@output = sort self_immolate 1,2,3 };
$fail_msg = q(Can't undef active subroutine);
cmp_ok(substr($@@,0,length($fail_msg)),'eq',$fail_msg,'undef active subr');


for(1,2) # We run this twice, to make sure sort does not lower the ref
{        # count. See bug 71076.
    my $failed = 0;

    sub rec {
	my $n = shift;
	if (!defined($n)) {  # No arg means we're being called by sort()
	    return 1;
	}
	if ($n<5) { rec($n+1); }
	else { () = sort rec 1,2; }

	$failed = 1 if !defined $n;
    }

    rec(1);
    ok(!$failed, "sort from active sub");
}

# $a and $b are set in the package the sort() is called from,
# *not* the package the sort sub is in. This is longstanding
# de facto behaviour that shouldn't be broken.
my $answer = "good";
() = sort OtherPack::foo 1,2,3,4;

{
    package OtherPack;
    no warnings 'once';
    sub foo {
	$answer = "something was unexpectedly defined or undefined" if
	defined($a) || defined($b) || !defined($main::a) || !defined($main::b);
	$main::a <=> $main::b;
    }
}

cmp_ok($answer,'eq','good','sort subr called from other package');


# Bug 36430 - sort called in package2 while a
# sort in package1 is active should set $package2::a/b.
{
    my $answer = "good";
    my @@list = sort { A::min(@@$a) <=> A::min(@@$b) }
      [3, 1, 5], [2, 4], [0];

    cmp_ok($answer,'eq','good','bug 36430');

    package A;
    sub min {
        my @@list = sort {
            $answer = '$a and/or $b are not defined ' if !defined($a) || !defined($b);
            $a <=> $b;
        } @@_;
        $list[0];
    }
}


# Bug 7567 - an array shouldn't be modifiable while it's being
# sorted in-place.
{
    eval { @@a=(1..8); @@a = sort { @@a = (0) } @@a; };

    $fail_msg = q(Modification of a read-only value attempted);
    cmp_ok(substr($@@,0,length($fail_msg)),'eq',$fail_msg,'bug 7567');
    eval { @@a=1..3 };
    is $@@, "", 'abrupt scope exit turns off readonliness';
}

# I commented out this TODO test because messing with FREEd scalars on the
# stack can have all sorts of strange side-effects, not made safe by eval
# - DAPM.
#
#{
#    local $TODO = "sort should make sure elements are not freed in the sort block";
#    eval { @@nomodify_x=(1..8);
#	   our @@copy = sort { undef @@nomodify_x; 1 } (@@nomodify_x, 3); };
#    is($@@, "");
#}


# Sorting shouldn't increase the refcount of a sub
{
    sub sportello {(1+$a) <=> (1+$b)}
    my $refcnt = &Internals::SvREFCNT(\&sportello);
    @@output = sort sportello 3,7,9;

    {
        package Doc;
        ::is($refcnt, &Internals::SvREFCNT(\&::sportello), "sort sub refcnt");
        $fail_msg = q(Modification of a read-only value attempted);
        # Sorting a read-only array in-place shouldn't be allowed
        my @@readonly = (1..10);
        Internals::SvREADONLY(@@readonly, 1);
        eval { @@readonly = sort @@readonly; };
        ::cmp_ok(substr($@@,0,length($fail_msg)),'eq',$fail_msg,'in-place sort of read-only array');
    }
}


# Using return() should be okay even in a deeper context
@@b = sort {while (1) {return ($a <=> $b)} } 1..10;
is("@@b", "1 2 3 4 5 6 7 8 9 10", "return within loop");

# Using return() should be okay even if there are other items
# on the stack at the time.
@@b = sort {$_ = ($a<=>$b) + do{return $b<=> $a}} 1..10;
is("@@b", "10 9 8 7 6 5 4 3 2 1", "return with SVs on stack");

# As above, but with a sort sub rather than a sort block.
sub ret_with_stacked { $_ = ($a<=>$b) + do {return $b <=> $a} }
@@b = sort ret_with_stacked 1..10;
is("@@b", "10 9 8 7 6 5 4 3 2 1", "return with SVs on stack");

# Comparison code should be able to give result in non-integer representation.
sub cmp_as_string($$) { $_[0] < $_[1] ? "-1" : $_[0] == $_[1] ? "0" : "+1" }
@@b = sort { cmp_as_string($a, $b) } (1,5,4,7,3,2,3);
is("@@b", "1 2 3 3 4 5 7", "comparison result as string");
@@b = sort cmp_as_string (1,5,4,7,3,2,3);
is("@@b", "1 2 3 3 4 5 7", "comparison result as string");

# RT #34604: sort didn't honour overloading if the overloaded elements
# were retrieved via tie

{
    package RT34604;

    sub TIEHASH { bless {
			p => bless({ val => 2 }),
			q => bless({ val => 1 }),
		    }
		}
    sub FETCH { $_[0]{$_[1] } }

    my $cc = 0;
    sub compare { $cc++; $_[0]{val} cmp $_[1]{val} }
    my $cs = 0;
    sub str { $cs++; $_[0]{val} }

    use overload 'cmp' => \&compare, '""' => \&str;

    package main;

    tie my %h, 'RT34604';
    my @@sorted = sort @@h{qw(p q)};
    is($cc, 1, 'overload compare called once');
    is("@@sorted","1 2", 'overload sort result');
    is($cs, 2, 'overload string called twice');
}

fresh_perl_is('sub w ($$) {my ($l, $r) = @@_; my $v = \@@_; undef @@_; $l <=> $r}; print join q{ }, sort w 3, 1, 2, 0',
             '0 1 2 3',
             {stderr => 1, switches => ['-w']},
             'RT #72334');

fresh_perl_is('sub w ($$) {my ($l, $r) = @@_; my $v = \@@_; undef @@_; @@_ = 0..2; $l <=> $r}; print join q{ }, sort w 3, 1, 2, 0',
             '0 1 2 3',
             {stderr => 1, switches => ['-w']},
             'RT #72334');

{
    my $count = 0;
    {
	package Counter;

	sub new {
	    ++$count;
	    bless [];
	}

	sub DESTROY {
	    --$count;
	}
    }

    sub sorter ($$) {
	my ($l, $r) = @@_;
	my $q = \@@_;
	$l <=> $r;
    }

    is($count, 0, 'None before we start');
    my @@a = map { Counter->new() } 0..1;
    is($count, 2, '2 here');

    my @@b = sort sorter @@a;

    is(scalar @@b, 2);
    cmp_ok($b[0], '<', $b[1], 'sorted!');

    is($count, 2, 'still the same 2 here');

    @@a = (); @@b = ();

    is($count, 0, 'all gone');
}

# [perl #77930] The context stack may be reallocated during a sort, as a
#               result of deeply-nested (or not-so-deeply-nested) calls
#               from a custom sort subroutine.
fresh_perl_is
 '
   $sub = sub {
    local $count = $count+1;
    ()->$sub if $count < 1000;
    $a cmp $b
   };
   () = sort $sub qw<a b c d e f g>;
   print "ok"
 ',
 'ok',
  {},
 '[perl #77930] cx_stack reallocation during sort'
;

# [perl #76026]
# Match vars should not leak from one sort sub call to the next
{
  my $output = '';
  sub soarter {
    $output .= $1;
    "Leakage" =~ /(.*)/;
    1
  }
  sub soarterdd($$) {
    $output .= $1;
    "Leakage" =~ /(.*)/;
    1
  }

  "Win" =~ /(.*)/;
  my @@b = sort soarter 0..2;

  like $output, qr/^(?:Win)+\z/,
   "Match vars do not leak from one plain sort sub to the next";

  $output = '';

  "Win" =~ /(.*)/;
  @@b = sort soarterdd 0..2;

  like $output, qr/^(?:Win)+\z/,
   'Match vars do not leak from one $$ sort sub to the next';
}

# [perl #30661] autoloading
AUTOLOAD { $b <=> $a }
sub stubbedsub;
is join("", sort stubbedsub split//, '04381091'), '98431100',
    'stubborn AUTOLOAD';
is join("", sort hopefullynonexistent split//, '04381091'), '98431100',
    'AUTOLOAD without stub';
my $stubref = \&givemeastub;
is join("", sort $stubref split//, '04381091'), '98431100',
    'AUTOLOAD with stubref';

# [perl #90030] sort without arguments
eval '@@x = (sort); 1';
is $@@, '', '(sort) does not die';
is @@x, 0, '(sort) returns empty list';
eval '@@x = sort; 1';
is $@@, '', 'sort; does not die';
is @@x, 0, 'sort; returns empty list';
eval '{@@x = sort} 1';
is $@@, '', '{sort} does not die';
is @@x, 0, '{sort} returns empty list';

# this happened while the padrange op was being added. Sort blocks
# are executed in void context, and the padrange op was skipping pushing
# the item in void cx. The net result was that the return value was
# whatever was on the stack last.

{
    my @@a = sort {
	my $r = $a <=> $b;
	if ($r) {
	    undef; # this got returned by mistake
	    return $r
	}
	return 0;
    } 5,1,3,6,0;
    is "@@a", "0 1 3 5 6", "padrange and void context";
}

# Fatal warnings an sort sub returning a non-number
# We need two evals, because the panic used to happen on scope exit.
eval { eval { use warnings FATAL => 'all'; () = sort { undef } 1,2 } };
is $@@, "",
  'no panic/crash with fatal warnings when sort sub returns undef';
eval { eval { use warnings FATAL => 'all'; () = sort { "no thin" } 1,2 } };
is $@@, "",
  'no panic/crash with fatal warnings when sort sub returns string';
sub notdef($$) { undef }
eval { eval { use warnings FATAL => 'all'; () = sort notdef 1,2 } };
is $@@, "",
  'no panic/crash with fatal warnings when sort sub($$) returns undef';
sub yarn($$) { "no thinking aloud" }
eval { eval { use warnings FATAL => 'all'; () = sort yarn 1,2 } };
is $@@, "",
  'no panic/crash with fatal warnings when sort sub($$) returns string';

$#a = -1;
() = [sort { $a = 10; $b = 10; 0 } $#a, $#a];
is $#a, 10, 'sort block modifying $a and $b';

() = sort {
    is \$a, \$a, '[perl #78194] op return values passed to sort'; 0
} "${\''}", "${\''}";

package deletions {
    @@_=sort { delete $deletions::{a}; delete $deletions::{b}; 3 } 1..3;
}
pass "no crash when sort block deletes *a and *b";

# make sure return args are always evaluated in scalar context

{
    package Ret;
    no warnings 'void';
    sub f0 { }
    sub f1 { $b <=> $a, $a <=> $b }
    sub f2 { return ($b <=> $a, $a <=> $b) }
    sub f3 { for ($b <=> $a) { return ($b <=> $a, $a <=> $b) } }

    {
        no warnings 'uninitialized';
        ::is (join('-', sort { () } 3,1,2,4), '3-1-2-4', "Ret: null blk");
    }
    ::is (join('-', sort { $b <=> $a, $a <=> $b } 3,1,2,4), '1-2-3-4', "Ret: blk");
    ::is (join('-', sort { for($b <=> $a) { return ($b <=> $a, $a <=> $b) } }
                            3,1,2,4), '1-2-3-4', "Ret: blk ret");
    {
        no warnings 'uninitialized';
        ::is (join('-', sort f0 3,1,2,4), '3-1-2-4', "Ret: f0");
    }
    ::is (join('-', sort f1 3,1,2,4), '1-2-3-4', "Ret: f1");
    ::is (join('-', sort f2 3,1,2,4), '1-2-3-4', "Ret: f2");
    ::is (join('-', sort f3 3,1,2,4), '1-2-3-4', "Ret: f3");
}

{
    @@a = sort{ *a=0; 1} 0..1;
    pass "No crash when GP deleted out from under us [perl 124097]";

    no warnings 'redefine';
    # some alternative non-solutions localized modifications to *a and *b
    sub a { 0 };
    @@a = sort { *a = sub { 1 }; $a <=> $b } 0 .. 1;
    ok(a(), "*a wasn't localized inadvertantly");
}
@


1.16
log
@Fix merge issues, remove excess files - match perl-5.20.2 dist
@
text
@d2 1
d6 2
a7 2
    @@INC = qw(. ../lib);
    require 'test.pl';
d10 1
a10 1
plan( tests => 183 );
d67 78
d860 10
a869 6
{
    local $TODO = "sort should make sure elements are not freed in the sort block";
    eval { @@nomodify_x=(1..8);
	   our @@copy = sort { undef @@nomodify_x; 1 } (@@nomodify_x, 3); };
    is($@@, "");
}
d941 1
a941 1
fresh_perl_is('sub w ($$) {my ($l, my $r) = @@_; my $v = \@@_; undef @@_; $l <=> $r}; print join q{ }, sort w 3, 1, 2, 0',
d946 1
a946 1
fresh_perl_is('sub w ($$) {my ($l, my $r) = @@_; my $v = \@@_; undef @@_; @@_ = 0..2; $l <=> $r}; print join q{ }, sort w 3, 1, 2, 0',
d1104 37
@


1.15
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d9 1
a9 1
plan( tests => 182 );
d125 2
@


1.14
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d9 1
a9 1
plan( tests => 176 );
d122 4
d290 2
d775 2
d1006 13
@


1.13
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d9 1
a9 1
plan( tests => 171 );
d773 2
a774 1
    eval { @@nomodify_x=(1..8); our @@copy = sort { @@nomodify_x = (0) } (@@nomodify_x, 3); };
d964 34
@


1.12
log
@merge in perl 5.12.2 plus local changes
@
text
@d9 1
a9 1
plan( tests => 148 );
d817 146
@


1.11
log
@Merge in perl 5.10.1; part two
@
text
@d9 1
a9 1
plan( tests => 144 );
d704 2
a705 2

{
d771 6
d780 3
a782 3
    sub foo {(1+$a) <=> (1+$b)}
    my $refcnt = &Internals::SvREFCNT(\&foo);
    @@output = sort foo 3,7,9;
d785 2
a786 2
        package Foo;
        ::is($refcnt, &Internals::SvREFCNT(\&foo), "sort sub refcnt");
d810 7
@


1.10
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d5 2
a6 1
    @@INC = qw(. ../lib); require 'test.pl';
d9 1
a9 1
plan( tests => 143 );
d264 5
a268 4
package Foo;
@@a = ( 5, 19, 1996, 255, 90 );
@@b = sort { $b <=> $a } @@a;
main::cmp_ok("@@b",'eq','1996 255 90 19 5','not in main:: 1');
d270 2
d273 6
a278 10
@@b = sort main::Backwards_stacked @@a;
main::cmp_ok("@@b",'eq','90 5 255 1996 19','not in main:: 2');


# check if context for sort arguments is handled right


sub test_if_list {
    my $gimme = wantarray;
    main::is($gimme,1,'wantarray 1');
d280 11
d292 7
a299 8
my $m = sub { $a <=> $b };

sub cxt_one { sort $m test_if_list() }
cxt_one();
sub cxt_two { sort { $a <=> $b } test_if_list() }
cxt_two();
sub cxt_three { sort &test_if_list() }
cxt_three();
a300 14
sub test_if_scalar {
    my $gimme = wantarray;
    main::is(!($gimme or !defined($gimme)),1,'wantarray 2');


}

$m = \&test_if_scalar;
sub cxt_four { sort $m 1,2 }
@@x = cxt_four();
sub cxt_five { sort { test_if_scalar($a,$b); } 1,2 }
@@x = cxt_five();
sub cxt_six { sort test_if_scalar 1,2 }
@@x = cxt_six();
d315 1
a315 1
    main::cmp_ok("@@b",'eq','1 2 3 4','reenter 1');
d317 1
a317 1
    main::ok(!$def,'reenter 2');
d324 1
a324 1
    main::cmp_ok("@@a",'eq',"one two",'bug id 19991001.003');
a327 8
#my $test = 59;
sub ok { main::cmp_ok($_[0],'eq',$_[1],$_[2]);
#    print "not " unless $_[0] eq $_[1];
#    print "ok $test - $_[2]\n";
#    print "#[$_[0]] ne [$_[1]]\n" unless $_[0] eq $_[1];
#    $test++;
}

d333 1
a333 1
    ok "$r1-@@g", "$r2-1 2 3", "inplace sort of global";
d336 1
a336 1
    ok "$r1-@@a", "$r2-a b c", "inplace sort of lexical";
d339 1
a339 1
    ok "$r1-@@g", "$r2-3 2 1", "inplace reversed sort of global";
d343 1
a343 1
    ok "$r1-@@g", "$r2-3 2 1", "inplace custom sort of global";
d347 1
a347 1
    ok "$r1-@@a", "$r2-c b a", "inplace sort with function of lexical";
d354 1
a354 1
    ok "@@t", "a b c", "inplace sort of tied array";
d357 1
a357 1
    ok "@@t", "c b a", "inplace sort of tied array with function";
d362 1
a362 1
    ok "@@g", "0 1 2 3", "un-inplace sort of global";
d364 1
a364 1
    ok "@@g", "1 2 3 4", "un-inplace sort of global 2";
d367 1
a367 1
    ok "@@a", "x a b c", "un-inplace sort of lexical";
d369 1
a369 1
    ok "@@a", "a b c x", "un-inplace sort of lexical 2";
d372 1
a372 1
    ok "@@g", "0 3 2 1", "un-inplace reversed sort of global";
d374 1
a374 1
    ok "@@g", "3 2 1 4", "un-inplace reversed sort of global 2";
d377 1
a377 1
    ok "@@g", "0 3 2 1", "un-inplace custom sort of global";
d379 1
a379 1
    ok "@@g", "3 2 1 4", "un-inplace custom sort of global 2";
d382 1
a382 1
    ok "@@a", "x c b a", "un-inplace sort with function of lexical";
d384 6
a389 1
    ok "@@a", "c b a x", "un-inplace sort with function of lexical 2";
d415 1
a415 1
ok join(" ", map {0+$_} @@output), "0 1 2 3 4 5 6 7 8", "Simple stable sort";
d419 1
a419 1
ok join(" ", map {0+$_} @@input), "0 1 2 3 4 5 6 7 8",
d425 1
a425 1
ok "@@output", "A A A B B B C C C", 'stable $a <=> $b sort';
d429 1
a429 1
ok join(" ", map {0+$_} @@output), "0 1 2 3 4 5 6 7 8", 'stable $a cmp $b sort';
d433 1
a433 1
ok join(" ", map {0+$_} @@input), "0 1 2 3 4 5 6 7 8",
d438 1
a438 1
ok join(" ", map {0+$_} @@output), "6 7 8 3 4 5 0 1 2", 'stable $b cmp $a sort';
d442 1
a442 1
ok join(" ", map {0+$_} @@input), "6 7 8 3 4 5 0 1 2",
d447 1
a447 1
ok join(" ", map {0+$_} @@output), "8 7 6 5 4 3 2 1 0", "Reversed stable sort";
d451 1
a451 1
ok join(" ", map {0+$_} @@input), "8 7 6 5 4 3 2 1 0",
d456 1
a456 1
ok $output, "CCCBBBAAA", "Reversed stable sort in scalar context";
d461 1
a461 1
ok join(" ", map {0+$_} @@output), "8 7 6 5 4 3 2 1 0",
d466 1
a466 1
ok join(" ", map {0+$_} @@input), "8 7 6 5 4 3 2 1 0",
d471 1
a471 1
ok $output, "CCCBBBAAA", 'Reversed stable $a cmp $b sort in scalar context';
d475 1
a475 1
ok join(" ", map {0+$_} @@output), "2 1 0 5 4 3 8 7 6",
d480 1
a480 1
ok join(" ", map {0+$_} @@input), "2 1 0 5 4 3 8 7 6",
d485 1
a485 1
ok $output, "AAABBBCCC", 'Reversed stable $b cmp $a sort in scalar context';
d494 1
a494 1
ok join(" ", map {0+$_} @@output), "8 7 6 5 4 3 2 1 0",
d499 1
a499 1
ok join(" ", map {0+$_} @@input), "8 7 6 5 4 3 2 1 0",
d504 1
a504 1
ok $output, "CCCBBBAAA", 'Reversed stable complex sort in scalar context';
d511 1
a511 1
ok join(" ", map {0+$_} @@output), "8 7 6 5 4 3 2 1 0",
d514 1
a514 1
ok $output, "CCCBBBAAA",
d522 1
a522 1
ok join(" ", map {0+$_} @@output), "8 7 6 5 4 3 2 1 0",
d525 1
a525 1
ok $output, "CCCBBBAAA",
d533 1
a533 1
ok join(" ", map {0+$_} @@output), "2 1 0 5 4 3 8 7 6",
d536 1
a536 1
ok $output, "AAABBBCCC",
d544 1
a544 1
ok join(" ", map {0+$_} @@output), "8 7 6 5 4 3 2 1 0",
d547 1
a547 1
ok $output, "CCCBBBAAA",
d560 1
a560 1
ok "@@output", "A B C D E F G H I", 'stable $a cmp $b sort';
d564 1
a564 1
ok "@@output", "A B C D E F G H I", 'stable $a <=> $b sort';
d568 1
a568 1
ok "@@input", "A B C D E F G H I", 'stable $a <=> $b in place sort';
d572 1
a572 1
ok "@@output", "G H I D E F A B C", 'stable $b <=> $a sort';
d576 1
a576 1
ok "@@input", "G H I D E F A B C", 'stable $b <=> $a in place sort';
d582 1
a582 1
ok "@@b" , "6first 6second 5first 5second", "optimized {$b <=> $a} without overloading" ;
d584 1
a584 1
ok "@@input" , "6first 6second 5first 5second","inline optimized {$b <=> $a} without overloading" ;
d590 1
a590 1
ok "@@output", "I H G F E D C B A", "Reversed stable sort";
d594 1
a594 1
ok "@@input", "I H G F E D C B A", "Reversed stable in place sort";
d598 1
a598 1
ok $output, "IHGFEDCBA", "Reversed stable sort in scalar context";
d602 1
a602 1
ok "@@output", "I H G F E D C B A", 'reversed stable $a <=> $b sort';
d606 1
a606 1
ok "@@input", "I H G F E D C B A", 'revesed stable $a <=> $b in place sort';
d610 1
a610 1
ok $output, "IHGFEDCBA", 'reversed stable $a <=> $b sort in scalar context';
d614 1
a614 1
ok "@@output", "C B A F E D I H G", 'reversed stable $b <=> $a sort';
d618 1
a618 1
ok "@@input", "C B A F E D I H G", 'revesed stable $b <=> $a in place sort';
d622 1
a622 1
ok $output, "CBAFEDIHG", 'reversed stable $b <=> $a sort in scalar context';
d626 1
a626 1
ok "@@output", "I H G F E D C B A", 'reversed stable complex sort';
d630 1
a630 1
ok "@@input", "I H G F E D C B A", 'revesed stable complex in place sort';
d634 1
a634 1
ok $output, "IHGFEDCBA", 'reversed stable complex sort in scalar context';
d641 1
a641 1
ok "@@output", "I H G F E D C B A",
d644 1
a644 1
ok $output, "IHGFEDCBA", 'reversed stable $a <=> $b sort return scalar context';
d651 1
a651 1
ok "@@output", "C B A F E D I H G",
d654 1
a654 1
ok $output, "CBAFEDIHG", 'reversed stable $b <=> $a sort return scalar context';
d661 1
a661 1
ok "@@output", "I H G F E D C B A",
d664 1
a664 1
ok $output, "IHGFEDCBA", 'reversed stable complex sort return scalar context';
d667 1
a667 1
ok "@@output", "0 C B A", 'reversed sort with trailing argument';
d670 1
a670 1
ok "@@output", "C B A 0", 'reversed sort with leading argument';
d674 1
a674 1
main::cmp_ok(substr($@@,0,length($fail_msg)),'eq',$fail_msg,'goto subr outside subr');
d681 1
a681 1
main::cmp_ok(substr($@@,0,length($fail_msg)),'eq',$fail_msg,'goto subr from a sort sub');
d687 1
a687 1
main::cmp_ok(substr($@@,0,length($fail_msg)),'eq',$fail_msg,'goto out of a pseudo block 1');
d694 1
a694 1
main::cmp_ok(substr($@@,0,length($fail_msg)),'eq',$fail_msg,'goto out of a pseudo block 2');
d701 1
a701 1
main::cmp_ok(substr($@@,0,length($fail_msg)),'eq',$fail_msg,'undef active subr');
d720 1
a720 1
    main::ok(!$failed, "sort from active sub");
a725 1
package main;
d739 1
a739 1
main::cmp_ok($answer,'eq','good','sort subr called from other package');
d744 16
a760 14
$answer = "good";
my @@list = sort { A::min(@@$a) <=> A::min(@@$b) }
  [3, 1, 5], [2, 4], [0];

main::cmp_ok($answer,'eq','good','bug 36430');

package A;
sub min {
  my @@list = sort {
    $answer = '$a and/or $b are not defined ' if !defined($a) || !defined($b);
    $a <=> $b;
  } @@_;
  $list[0];
}
d764 2
a765 4
eval { @@a=(1..8); @@a = sort { @@a = (0) } @@a; };

$fail_msg = q(Modification of a read-only value attempted);
main::cmp_ok(substr($@@,0,length($fail_msg)),'eq',$fail_msg,'bug 7567');
d767 3
d773 16
a788 13
sub foo {(1+$a) <=> (1+$b)}
my $refcnt = &Internals::SvREFCNT(\&foo);
@@output = sort foo 3,7,9;
package Foo;
ok($refcnt, &Internals::SvREFCNT(\&foo), "sort sub refcnt");
$fail_msg = q(Modification of a read-only value attempted);
# Sorting a read-only array in-place shouldn't be allowed
my @@readonly = (1..10);
Internals::SvREADONLY(@@readonly, 1);
eval { @@readonly = sort @@readonly; };
main::cmp_ok(substr($@@,0,length($fail_msg)),'eq',$fail_msg,'in-place sort of read-only array');


d793 1
a793 1
ok("@@b", "1 2 3 4 5 6 7 8 9 10", "return within loop");
d798 1
a798 1
ok("@@b", "10 9 8 7 6 5 4 3 2 1", "return with SVs on stack");
d803 1
a803 1
ok("@@b", "10 9 8 7 6 5 4 3 2 1", "return with SVs on stack");
@


1.9
log
@merge in perl 5.8.8
@
text
@d5 1
a5 1
    @@INC = '../lib';
d8 1
a8 1
print "1..129\n";
d24 1
d47 2
a48 2
print "# 1: x = '$x', expected = '$expected'\n";
print ($x eq $expected ? "ok 1\n" : "not ok 1\n");
d52 2
a53 2
print "# 2: x = '$x', expected = '$expected'\n";
print ($x eq $expected ? "ok 2\n" : "not ok 2\n");
d57 2
a58 2
print "# 3: x = '$x', expected = '$expected'\n";
print ($x eq $expected ? "ok 3\n" : "not ok 3\n");
a63 2
print "# 4: x = '$x', expected = '$expected'\n";
print ($x eq $expected ?"ok 4\n":"not ok 4\n");
d65 2
d69 1
a69 1
print ("@@b" eq "" ? "ok 5\n" : "not ok 5 (@@b)\n");
d73 1
a73 1
print ("@@b" eq "1" ? "ok 6\n" : "not ok 6 (@@b)\n");
d77 1
a77 1
print ("@@b" eq "2 1" ? "ok 7\n" : "not ok 7 (@@b)\n");
d81 1
a81 1
print ("@@b" eq "3 2 1" ? "ok 8\n" : "not ok 8 (@@b)\n");
d85 1
a85 1
print ("@@b" eq "4 3 2 1" ? "ok 9\n" : "not ok 9 (@@b)\n");
d89 1
a89 1
print ("@@b" eq "2 3 4 10" ? "ok 10\n" : "not ok 10 (@@b)\n");
d94 2
a95 2
print "# 11: x = $x, expected = '$expected'\n";
print ($x eq $expected ? "ok 11\n" : "not ok 11\n");
d100 2
a101 2
print "# 12: x = $x, expected = '$expected'\n";
print ($x eq $expected ? "ok 12\n" : "not ok 12\n");
d106 2
a107 2
print ("@@b" eq '1 2 3 4' ? "ok 13\n" : "not ok 13\n");
print "# x = '@@b'\n";
d110 2
a111 2
print ("@@b" eq '1 2 3 4' ? "ok 14\n" : "not ok 14\n");
print "# x = '@@b'\n";
d114 2
a115 2
print ("@@b" eq '1 2 3 4' ? "ok 15\n" : "not ok 15\n");
print "# x = '@@b'\n";
d118 3
a120 2
print ("@@b" eq '1 2 3 4' ? "ok 16\n" : "not ok 16\n");
print "# x = '@@b'\n";
d122 1
a122 2
# redefining sort sub inside the sort sub should fail
sub twoface { *twoface = sub { $a <=> $b }; &twoface }
d124 2
a125 1
print ($@@ =~ /redefine active sort/ ? "ok 17\n" : "not ok 17\n");
a126 1
# redefining sort subs outside the sort should not fail
d128 1
a128 1
print $@@ ? "not ok 18\n" : "ok 18\n";
d131 1
a131 1
print ("@@b" eq '4 3 2 1' ? "ok 19\n" : "not ok 19 |@@b|\n");
d135 1
a135 1
  *twoface = sub { *twoface = *Backwards; $a <=> $b };
d137 3
a139 2
eval { @@b = sort twoface 4,1 };
print ($@@ =~ /redefine active sort/ ? "ok 20\n" : "not ok 20\n");
d145 1
a145 1
		 die($@@ =~ /redefine active sort/ ? "ok 21\n" : "not ok 21\n");
d150 1
a150 1
print $@@ ? "$@@" : "not ok 21\n";
d155 1
a155 1
print $@@ ? "not ok 22\n# $@@" : "ok 22\n";
d161 1
a161 1
print $@@ ? "not ok 23\n# $@@" : "ok 23\n";
d169 1
a169 1
  print ("@@b" eq '4 3 2 1' ? "ok 24\n" : "not ok 24 |@@b|\n");
d171 1
a171 1
  print ("@@b" eq '4 3 2 1' ? "ok 25\n" : "not ok 25 |@@b|\n");
d173 1
a173 1
  print ("@@b" eq '4 3 2 1' ? "ok 26\n" : "not ok 26 |@@b|\n");
d175 1
a175 1
  print ("@@b" eq '4 3 2 1' ? "ok 27\n" : "not ok 27 |@@b|\n");
d184 1
a184 1
  print ("@@b" eq '4 3 2 1' ? "ok 28\n" : "not ok 28 |@@b|\n");
d186 1
a186 1
  print ("@@b" eq '4 3 2 1' ? "ok 29\n" : "not ok 29 |@@b|\n");
d188 1
a188 1
  print ("@@b" eq '4 3 2 1' ? "ok 30\n" : "not ok 30 |@@b|\n");
d190 1
a190 1
  print ("@@b" eq '4 3 2 1' ? "ok 31\n" : "not ok 31 |@@b|\n");
d199 1
a199 1
  print ("@@b" eq '4 3 2 1' ? "ok 32\n" : "not ok 32 |@@b|\n");
d201 1
a201 1
  print ("@@b" eq '4 3 2 1' ? "ok 33\n" : "not ok 33 |@@b|\n");
d203 1
a203 1
  print ("@@b" eq '4 3 2 1' ? "ok 34\n" : "not ok 34 |@@b|\n");
d205 1
a205 1
  print ("@@b" eq '4 3 2 1' ? "ok 35\n" : "not ok 35 |@@b|\n");
d214 1
a214 1
  print ("@@b" eq '4 3 2 1' ? "ok 36\n" : "not ok 36 |@@b|\n");
d216 1
a216 1
  print ("@@b" eq '4 3 2 1' ? "ok 37\n" : "not ok 37 |@@b|\n");
d218 1
a218 1
  print ("@@b" eq '4 3 2 1' ? "ok 38\n" : "not ok 38 |@@b|\n");
d220 1
a220 1
  print ("@@b" eq '4 3 2 1' ? "ok 39\n" : "not ok 39 |@@b|\n");
d229 2
a230 2
print ("@@b" eq '1996 255 90 19 5' ? "ok 40\n" : "not ok 40\n");
print "# x = '@@b'\n";
d233 2
a234 2
print ($x eq $expected ? "ok 41\n" : "not ok 41\n");
print "# x = '$x'; expected = '$expected'\n";
d237 2
a238 2
print ($x eq $expected ? "ok 42\n" : "not ok 42\n");
print "# x = '$x'; expected = '$expected'\n";
d242 2
a243 2
    print ("@@b" eq '5 19 90 255 1996' ? "ok 43\n" : "not ok 43\n");
    print "# x = '@@b'\n";
d245 2
a246 2
    print ("@@b" eq '1996 255 90 19 5' ? "ok 44\n" : "not ok 44\n");
    print "# x = '@@b'\n";
d249 2
a250 2
    print ($x eq $expected ? "ok 45\n" : "not ok 45\n");
    print "# x = '$x'; expected = '$expected'\n";
d253 2
a254 2
    print ($x eq $expected ? "ok 46\n" : "not ok 46\n");
    print "# x = '$x'; expected = '$expected'\n";
d257 2
a258 2
# test that an optimized-away comparison block doesn't take any other
# arguments away with it
d260 1
a260 1
print $x eq "123" ? "ok 47\n" : "not ok 47\n";
d266 2
a267 2
print ("@@b" eq '1996 255 90 19 5' ? "ok 48\n" : "not ok 48\n");
print "# x = '@@b'\n";
d270 2
a271 2
print ("@@b" eq '90 5 255 1996 19' ? "ok 49\n" : "not ok 49\n");
print "# x = '@@b'\n";
d275 1
a275 1
$test = 49;
d278 3
a280 3
    print "not " unless $gimme;
    ++$test;
    print "ok $test\n";
d293 3
a295 3
    print "not " if $gimme or !defined($gimme);
    ++$test;
    print "ok $test\n";
d319 3
a321 3
    print ("@@b" eq '1 2 3 4' ? "ok 56\n" : "not ok 56\n");
    print "# x = '@@b'\n";
    print !$def ? "ok 57\n" : "not ok 57\n";
d324 1
a324 1
# Bug 19991001.003
d328 1
a328 1
    print "@@a" eq "one two" ? "ok 58\n" : "not ok 58\n";
d332 6
a337 6
my $test = 59;
sub ok {
    print "not " unless $_[0] eq $_[1];
    print "ok $test - $_[2]\n";
    print "#[$_[0]] ne [$_[1]]\n" unless $_[0] eq $_[1];
    $test++;
d678 128
@


1.8
log
@sync in-tree perl with 5.8.6
@
text
@d17 3
@


1.7
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d8 1
a8 1
print "1..75\n";
d25 1
a25 1
# collation complications: qw(A a B c) can be sorted at least as
d394 2
d397 270
d668 2
d671 2
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d8 1
a8 1
print "1..58\n";
d325 72
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d8 1
a8 1
print "1..57\n";
d317 7
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d5 1
a5 1
    unshift @@INC, '../lib';
d8 1
a8 7
print "1..49\n";

# XXX known to leak scalars
{
  no warnings 'uninitialized';
  $ENV{PERL_DESTRUCT_LEVEL} = 0 unless $ENV{PERL_DESTRUCT_LEVEL} > 3;
}
d267 51
@


1.3
log
@perl5.005_03 (stock)
@
text
@d3 6
a8 1
print "1..29\n";
d11 4
a14 1
$ENV{PERL_DESTRUCT_LEVEL} = 0 unless $ENV{PERL_DESTRUCT_LEVEL} > 3;
d16 11
a26 1
sub backwards { $a lt $b ? 1 : $a gt $b ? -1 : 0 }
d52 1
a52 1
$x = join('', sort( backwards @@harry));
d57 5
d66 2
a67 2
print "# 3: x = '$x', expected = '$expected'\n";
print ($x eq $expected ?"ok 3\n":"not ok 3\n");
d71 1
a71 1
print ("@@b" eq "" ? "ok 4\n" : "not ok 4 (@@b)\n");
d75 1
a75 1
print ("@@b" eq "1" ? "ok 5\n" : "not ok 5 (@@b)\n");
d79 1
a79 1
print ("@@b" eq "2 1" ? "ok 6\n" : "not ok 6 (@@b)\n");
d83 1
a83 1
print ("@@b" eq "3 2 1" ? "ok 7\n" : "not ok 7 (@@b)\n");
d87 1
a87 1
print ("@@b" eq "4 3 2 1" ? "ok 8\n" : "not ok 8 (@@b)\n");
d91 1
a91 1
print ("@@b" eq "2 3 4 10" ? "ok 9\n" : "not ok 9 (@@b)\n");
d93 1
a93 1
$sub = 'backwards';
d96 8
a103 2
print "# 10: x = $x, expected = '$expected'\n";
print ($x eq $expected ? "ok 10\n" : "not ok 10\n");
d108 1
a108 1
print ("@@b" eq '1 2 3 4' ? "ok 11\n" : "not ok 11\n");
d112 1
a112 1
print ("@@b" eq '1 2 3 4' ? "ok 12\n" : "not ok 12\n");
d116 1
a116 1
print ("@@b" eq '1 2 3 4' ? "ok 13\n" : "not ok 13\n");
d120 1
a120 1
print ("@@b" eq '1 2 3 4' ? "ok 14\n" : "not ok 14\n");
a122 1
$^W = 0;
d126 1
a126 1
print ($@@ =~ /redefine active sort/ ? "ok 15\n" : "not ok 15\n");
d129 2
a130 2
eval { *twoface = sub { &backwards } };
print $@@ ? "not ok 16\n" : "ok 16\n";
d133 1
a133 1
print ("@@b" eq '4 3 2 1' ? "ok 17\n" : "not ok 17 |@@b|\n");
d135 4
a138 1
*twoface = sub { *twoface = *backwards; $a <=> $b };
d140 1
a140 1
print ($@@ =~ /redefine active sort/ ? "ok 18\n" : "not ok 18\n");
d142 3
a144 1
*twoface = sub {
d146 1
a146 1
		 die($@@ =~ /redefine active sort/ ? "ok 19\n" : "not ok 19\n");
d149 1
d151 1
a151 1
print $@@ ? "$@@" : "not ok 19\n";
d154 1
a154 1
    my @@result = sort main'backwards 'one', 'two';
d156 1
a156 1
print $@@ ? "not ok 20\n# $@@" : "ok 20\n";
d162 31
a192 1
print $@@ ? "not ok 21\n# $@@" : "ok 21\n";
d195 4
a198 4
  my $sortsub = \&backwards;
  my $sortglob = *backwards;
  my $sortglobr = \*backwards;
  my $sortname = 'backwards';
d200 1
a200 1
  print ("@@b" eq '4 3 2 1' ? "ok 22\n" : "not ok 22 |@@b|\n");
d202 1
a202 1
  print ("@@b" eq '4 3 2 1' ? "ok 23\n" : "not ok 23 |@@b|\n");
d204 1
a204 1
  print ("@@b" eq '4 3 2 1' ? "ok 24\n" : "not ok 24 |@@b|\n");
d206 1
a206 1
  print ("@@b" eq '4 3 2 1' ? "ok 25\n" : "not ok 25 |@@b|\n");
d210 4
a213 4
  local $sortsub = \&backwards;
  local $sortglob = *backwards;
  local $sortglobr = \*backwards;
  local $sortname = 'backwards';
d215 1
a215 1
  print ("@@b" eq '4 3 2 1' ? "ok 26\n" : "not ok 26 |@@b|\n");
d217 1
a217 1
  print ("@@b" eq '4 3 2 1' ? "ok 27\n" : "not ok 27 |@@b|\n");
d219 1
a219 1
  print ("@@b" eq '4 3 2 1' ? "ok 28\n" : "not ok 28 |@@b|\n");
d221 35
a255 1
  print ("@@b" eq '4 3 2 1' ? "ok 29\n" : "not ok 29 |@@b|\n");
d258 15
@


1.2
log
@perl 5.004_04
@
text
@d3 1
a3 1
# $RCSfile: sort.t,v $$Revision: 4.1 $$Date: 92/08/07 18:28:24 $
d5 2
a6 1
print "1..19\n";
d10 16
d30 3
a32 2
print ($x eq 'AbelCaincatdogx' ? "ok 1\n" : "not ok 1\n");
print "# x = '$x'\n";
d35 3
a37 2
print ($x eq 'xdogcatCainAbel' ? "ok 2\n" : "not ok 2\n");
print "# x = '$x'\n";
d40 5
a44 2
print ($x eq 'AbelAxedCaincatchaseddoggonepunishedtoxyz'?"ok 3\n":"not ok 3\n");
print "# x = '$x'\n";
d72 3
a74 1
print ($x eq 'xdogcatCainAbel' ? "ok 10\n" : "not ok 10\n");
d118 42
@


1.1
log
@Initial revision
@
text
@d5 1
a5 1
print "1..10\n";
d7 1
a7 1
sub backwards { $a lt $b ? 1 : $a gt $b ? -1 : 0; }
d10 1
a10 1
@@george = ('gone','chased','yz','Punished','Axed');
d14 1
d18 1
d21 2
a22 1
print ($x eq 'AbelAxedCainPunishedcatchaseddoggonetoxyz'?"ok 3\n":"not ok 3\n");
d52 42
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d3 1
a3 1
print "1..29\n";
d5 1
a5 2
# XXX known to leak scalars
$ENV{PERL_DESTRUCT_LEVEL} = 0 unless $ENV{PERL_DESTRUCT_LEVEL} > 3;
d7 1
a7 17
sub backwards { $a lt $b ? 1 : $a gt $b ? -1 : 0 }

my $upperfirst = 'A' lt 'a';

# Beware: in future this may become hairier because of possible
# collation complications: qw(A a B c) can be sorted at least as
# any of the following
#
#	A a B b
#	A B a b
#	a b A B
#	a A b B
#
# All the above orders make sense.
#
# That said, EBCDIC sorts all small letters first, as opposed
# to ASCII which sorts all big letters first.
d10 1
a10 1
@@george = ('gone','chased','yz','punished','Axed');
d13 1
a13 3
$expected = $upperfirst ? 'AbelCaincatdogx' : 'catdogxAbelCain';
print "# 1: x = '$x', expected = '$expected'\n";
print ($x eq $expected ? "ok 1\n" : "not ok 1\n");
d16 1
a16 3
$expected = $upperfirst ? 'xdogcatCainAbel' : 'CainAbelxdogcat';
print "# 2: x = '$x', expected = '$expected'\n";
print ($x eq $expected ? "ok 2\n" : "not ok 2\n");
d19 1
a19 5
$expected = $upperfirst ?
    'AbelAxedCaincatchaseddoggonepunishedtoxyz' :
    'catchaseddoggonepunishedtoxyzAbelAxedCain' ;
print "# 3: x = '$x', expected = '$expected'\n";
print ($x eq $expected ?"ok 3\n":"not ok 3\n");
d47 1
a47 87
$expected = $upperfirst ? 'xdogcatCainAbel' : 'CainAbelxdogcat';
print "# 10: x = $x, expected = '$expected'\n";
print ($x eq $expected ? "ok 10\n" : "not ok 10\n");

# literals, combinations

@@b = sort (4,1,3,2);
print ("@@b" eq '1 2 3 4' ? "ok 11\n" : "not ok 11\n");
print "# x = '@@b'\n";

@@b = sort grep { $_ } (4,1,3,2);
print ("@@b" eq '1 2 3 4' ? "ok 12\n" : "not ok 12\n");
print "# x = '@@b'\n";

@@b = sort map { $_ } (4,1,3,2);
print ("@@b" eq '1 2 3 4' ? "ok 13\n" : "not ok 13\n");
print "# x = '@@b'\n";

@@b = sort reverse (4,1,3,2);
print ("@@b" eq '1 2 3 4' ? "ok 14\n" : "not ok 14\n");
print "# x = '@@b'\n";

$^W = 0;
# redefining sort sub inside the sort sub should fail
sub twoface { *twoface = sub { $a <=> $b }; &twoface }
eval { @@b = sort twoface 4,1,3,2 };
print ($@@ =~ /redefine active sort/ ? "ok 15\n" : "not ok 15\n");

# redefining sort subs outside the sort should not fail
eval { *twoface = sub { &backwards } };
print $@@ ? "not ok 16\n" : "ok 16\n";

eval { @@b = sort twoface 4,1,3,2 };
print ("@@b" eq '4 3 2 1' ? "ok 17\n" : "not ok 17 |@@b|\n");

*twoface = sub { *twoface = *backwards; $a <=> $b };
eval { @@b = sort twoface 4,1 };
print ($@@ =~ /redefine active sort/ ? "ok 18\n" : "not ok 18\n");

*twoface = sub {
                 eval 'sub twoface { $a <=> $b }';
		 die($@@ =~ /redefine active sort/ ? "ok 19\n" : "not ok 19\n");
		 $a <=> $b;
	       };
eval { @@b = sort twoface 4,1 };
print $@@ ? "$@@" : "not ok 19\n";

eval <<'CODE';
    my @@result = sort main'backwards 'one', 'two';
CODE
print $@@ ? "not ok 20\n# $@@" : "ok 20\n";

eval <<'CODE';
    # "sort 'one', 'two'" should not try to parse "'one" as a sort sub
    my @@result = sort 'one', 'two';
CODE
print $@@ ? "not ok 21\n# $@@" : "ok 21\n";

{
  my $sortsub = \&backwards;
  my $sortglob = *backwards;
  my $sortglobr = \*backwards;
  my $sortname = 'backwards';
  @@b = sort $sortsub 4,1,3,2;
  print ("@@b" eq '4 3 2 1' ? "ok 22\n" : "not ok 22 |@@b|\n");
  @@b = sort $sortglob 4,1,3,2;
  print ("@@b" eq '4 3 2 1' ? "ok 23\n" : "not ok 23 |@@b|\n");
  @@b = sort $sortname 4,1,3,2;
  print ("@@b" eq '4 3 2 1' ? "ok 24\n" : "not ok 24 |@@b|\n");
  @@b = sort $sortglobr 4,1,3,2;
  print ("@@b" eq '4 3 2 1' ? "ok 25\n" : "not ok 25 |@@b|\n");
}

{
  local $sortsub = \&backwards;
  local $sortglob = *backwards;
  local $sortglobr = \*backwards;
  local $sortname = 'backwards';
  @@b = sort $sortsub 4,1,3,2;
  print ("@@b" eq '4 3 2 1' ? "ok 26\n" : "not ok 26 |@@b|\n");
  @@b = sort $sortglob 4,1,3,2;
  print ("@@b" eq '4 3 2 1' ? "ok 27\n" : "not ok 27 |@@b|\n");
  @@b = sort $sortname 4,1,3,2;
  print ("@@b" eq '4 3 2 1' ? "ok 28\n" : "not ok 28 |@@b|\n");
  @@b = sort $sortglobr 4,1,3,2;
  print ("@@b" eq '4 3 2 1' ? "ok 29\n" : "not ok 29 |@@b|\n");
}
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d3 1
a3 6
BEGIN {
    chdir 't' if -d 't';
    unshift @@INC, '../lib';
}
use warnings;
print "1..49\n";
d6 1
a6 4
{
  no warnings 'uninitialized';
  $ENV{PERL_DESTRUCT_LEVEL} = 0 unless $ENV{PERL_DESTRUCT_LEVEL} > 3;
}
d8 1
a8 11
# these shouldn't hang
{
    no warnings;
    sort { for ($_ = 0;; $_++) {} } @@a;
    sort { while(1) {}            } @@a;
    sort { while(1) { last; }     } @@a;
    sort { while(0) { last; }     } @@a;
}

sub Backwards { $a lt $b ? 1 : $a gt $b ? -1 : 0 }
sub Backwards_stacked($$) { my($a,$b) = @@_; $a lt $b ? 1 : $a gt $b ? -1 : 0 }
d34 1
a34 1
$x = join('', sort( Backwards @@harry));
a38 5
$x = join('', sort( Backwards_stacked @@harry));
$expected = $upperfirst ? 'xdogcatCainAbel' : 'CainAbelxdogcat';
print "# 3: x = '$x', expected = '$expected'\n";
print ($x eq $expected ? "ok 3\n" : "not ok 3\n");

d43 2
a44 2
print "# 4: x = '$x', expected = '$expected'\n";
print ($x eq $expected ?"ok 4\n":"not ok 4\n");
d48 1
a48 1
print ("@@b" eq "" ? "ok 5\n" : "not ok 5 (@@b)\n");
d52 1
a52 1
print ("@@b" eq "1" ? "ok 6\n" : "not ok 6 (@@b)\n");
d56 1
a56 1
print ("@@b" eq "2 1" ? "ok 7\n" : "not ok 7 (@@b)\n");
d60 1
a60 1
print ("@@b" eq "3 2 1" ? "ok 8\n" : "not ok 8 (@@b)\n");
d64 1
a64 1
print ("@@b" eq "4 3 2 1" ? "ok 9\n" : "not ok 9 (@@b)\n");
d68 1
a68 1
print ("@@b" eq "2 3 4 10" ? "ok 10\n" : "not ok 10 (@@b)\n");
d70 1
a70 1
$sub = 'Backwards';
d73 2
a74 8
print "# 11: x = $x, expected = '$expected'\n";
print ($x eq $expected ? "ok 11\n" : "not ok 11\n");

$sub = 'Backwards_stacked';
$x = join('', sort $sub @@harry);
$expected = $upperfirst ? 'xdogcatCainAbel' : 'CainAbelxdogcat';
print "# 12: x = $x, expected = '$expected'\n";
print ($x eq $expected ? "ok 12\n" : "not ok 12\n");
d79 1
a79 1
print ("@@b" eq '1 2 3 4' ? "ok 13\n" : "not ok 13\n");
d83 1
a83 1
print ("@@b" eq '1 2 3 4' ? "ok 14\n" : "not ok 14\n");
d87 1
a87 1
print ("@@b" eq '1 2 3 4' ? "ok 15\n" : "not ok 15\n");
d91 1
a91 1
print ("@@b" eq '1 2 3 4' ? "ok 16\n" : "not ok 16\n");
d94 1
d98 1
a98 1
print ($@@ =~ /redefine active sort/ ? "ok 17\n" : "not ok 17\n");
d101 2
a102 2
eval { no warnings 'redefine'; *twoface = sub { &Backwards } };
print $@@ ? "not ok 18\n" : "ok 18\n";
d105 1
a105 1
print ("@@b" eq '4 3 2 1' ? "ok 19\n" : "not ok 19 |@@b|\n");
d107 1
a107 4
{
  no warnings 'redefine';
  *twoface = sub { *twoface = *Backwards; $a <=> $b };
}
d109 1
a109 1
print ($@@ =~ /redefine active sort/ ? "ok 20\n" : "not ok 20\n");
d111 1
a111 3
{
  no warnings 'redefine';
  *twoface = sub {
d113 1
a113 1
		 die($@@ =~ /redefine active sort/ ? "ok 21\n" : "not ok 21\n");
a115 1
}
d117 1
a117 1
print $@@ ? "$@@" : "not ok 21\n";
d120 1
a120 1
    my @@result = sort main'Backwards 'one', 'two';
d122 1
a122 1
print $@@ ? "not ok 22\n# $@@" : "ok 22\n";
d128 1
a128 1
print $@@ ? "not ok 23\n# $@@" : "ok 23\n";
d131 4
a134 4
  my $sortsub = \&Backwards;
  my $sortglob = *Backwards;
  my $sortglobr = \*Backwards;
  my $sortname = 'Backwards';
d136 1
a136 1
  print ("@@b" eq '4 3 2 1' ? "ok 24\n" : "not ok 24 |@@b|\n");
d138 1
a138 1
  print ("@@b" eq '4 3 2 1' ? "ok 25\n" : "not ok 25 |@@b|\n");
d140 1
a140 1
  print ("@@b" eq '4 3 2 1' ? "ok 26\n" : "not ok 26 |@@b|\n");
d142 1
a142 1
  print ("@@b" eq '4 3 2 1' ? "ok 27\n" : "not ok 27 |@@b|\n");
d146 4
a149 4
  my $sortsub = \&Backwards_stacked;
  my $sortglob = *Backwards_stacked;
  my $sortglobr = \*Backwards_stacked;
  my $sortname = 'Backwards_stacked';
d151 1
a151 1
  print ("@@b" eq '4 3 2 1' ? "ok 28\n" : "not ok 28 |@@b|\n");
d153 1
a153 1
  print ("@@b" eq '4 3 2 1' ? "ok 29\n" : "not ok 29 |@@b|\n");
d155 1
a155 1
  print ("@@b" eq '4 3 2 1' ? "ok 30\n" : "not ok 30 |@@b|\n");
d157 1
a157 65
  print ("@@b" eq '4 3 2 1' ? "ok 31\n" : "not ok 31 |@@b|\n");
}

{
  local $sortsub = \&Backwards;
  local $sortglob = *Backwards;
  local $sortglobr = \*Backwards;
  local $sortname = 'Backwards';
  @@b = sort $sortsub 4,1,3,2;
  print ("@@b" eq '4 3 2 1' ? "ok 32\n" : "not ok 32 |@@b|\n");
  @@b = sort $sortglob 4,1,3,2;
  print ("@@b" eq '4 3 2 1' ? "ok 33\n" : "not ok 33 |@@b|\n");
  @@b = sort $sortname 4,1,3,2;
  print ("@@b" eq '4 3 2 1' ? "ok 34\n" : "not ok 34 |@@b|\n");
  @@b = sort $sortglobr 4,1,3,2;
  print ("@@b" eq '4 3 2 1' ? "ok 35\n" : "not ok 35 |@@b|\n");
}

{
  local $sortsub = \&Backwards_stacked;
  local $sortglob = *Backwards_stacked;
  local $sortglobr = \*Backwards_stacked;
  local $sortname = 'Backwards_stacked';
  @@b = sort $sortsub 4,1,3,2;
  print ("@@b" eq '4 3 2 1' ? "ok 36\n" : "not ok 36 |@@b|\n");
  @@b = sort $sortglob 4,1,3,2;
  print ("@@b" eq '4 3 2 1' ? "ok 37\n" : "not ok 37 |@@b|\n");
  @@b = sort $sortname 4,1,3,2;
  print ("@@b" eq '4 3 2 1' ? "ok 38\n" : "not ok 38 |@@b|\n");
  @@b = sort $sortglobr 4,1,3,2;
  print ("@@b" eq '4 3 2 1' ? "ok 39\n" : "not ok 39 |@@b|\n");
}

## exercise sort builtins... ($a <=> $b already tested)
@@a = ( 5, 19, 1996, 255, 90 );
@@b = sort {
    my $dummy;		# force blockness
    return $b <=> $a
} @@a;
print ("@@b" eq '1996 255 90 19 5' ? "ok 40\n" : "not ok 40\n");
print "# x = '@@b'\n";
$x = join('', sort { $a cmp $b } @@harry);
$expected = $upperfirst ? 'AbelCaincatdogx' : 'catdogxAbelCain';
print ($x eq $expected ? "ok 41\n" : "not ok 41\n");
print "# x = '$x'; expected = '$expected'\n";
$x = join('', sort { $b cmp $a } @@harry);
$expected = $upperfirst ? 'xdogcatCainAbel' : 'CainAbelxdogcat';
print ($x eq $expected ? "ok 42\n" : "not ok 42\n");
print "# x = '$x'; expected = '$expected'\n";
{
    use integer;
    @@b = sort { $a <=> $b } @@a;
    print ("@@b" eq '5 19 90 255 1996' ? "ok 43\n" : "not ok 43\n");
    print "# x = '@@b'\n";
    @@b = sort { $b <=> $a } @@a;
    print ("@@b" eq '1996 255 90 19 5' ? "ok 44\n" : "not ok 44\n");
    print "# x = '@@b'\n";
    $x = join('', sort { $a cmp $b } @@harry);
    $expected = $upperfirst ? 'AbelCaincatdogx' : 'catdogxAbelCain';
    print ($x eq $expected ? "ok 45\n" : "not ok 45\n");
    print "# x = '$x'; expected = '$expected'\n";
    $x = join('', sort { $b cmp $a } @@harry);
    $expected = $upperfirst ? 'xdogcatCainAbel' : 'CainAbelxdogcat';
    print ($x eq $expected ? "ok 46\n" : "not ok 46\n");
    print "# x = '$x'; expected = '$expected'\n";
a159 15
# test that an optimized-away comparison block doesn't take any other
# arguments away with it
$x = join('', sort { $a <=> $b } 3, 1, 2);
print $x eq "123" ? "ok 47\n" : "not ok 47\n";

# test sorting in non-main package
package Foo;
@@a = ( 5, 19, 1996, 255, 90 );
@@b = sort { $b <=> $a } @@a;
print ("@@b" eq '1996 255 90 19 5' ? "ok 48\n" : "not ok 48\n");
print "# x = '@@b'\n";

@@b = sort main::Backwards_stacked @@a;
print ("@@b" eq '90 5 255 1996 19' ? "ok 49\n" : "not ok 49\n");
print "# x = '@@b'\n";
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d5 1
a5 1
    @@INC = '../lib';
d8 7
a14 1
print "1..57\n";
a272 51

# check if context for sort arguments is handled right

$test = 49;
sub test_if_list {
    my $gimme = wantarray;
    print "not " unless $gimme;
    ++$test;
    print "ok $test\n";
}
my $m = sub { $a <=> $b };

sub cxt_one { sort $m test_if_list() }
cxt_one();
sub cxt_two { sort { $a <=> $b } test_if_list() }
cxt_two();
sub cxt_three { sort &test_if_list() }
cxt_three();

sub test_if_scalar {
    my $gimme = wantarray;
    print "not " if $gimme or !defined($gimme);
    ++$test;
    print "ok $test\n";
}

$m = \&test_if_scalar;
sub cxt_four { sort $m 1,2 }
@@x = cxt_four();
sub cxt_five { sort { test_if_scalar($a,$b); } 1,2 }
@@x = cxt_five();
sub cxt_six { sort test_if_scalar 1,2 }
@@x = cxt_six();

# test against a reentrancy bug
{
    package Bar;
    sub compare { $a cmp $b }
    sub reenter { my @@force = sort compare qw/a b/ }
}
{
    my($def, $init) = (0, 0);
    @@b = sort {
	$def = 1 if defined $Bar::a;
	Bar::reenter() unless $init++;
	$a <=> $b
    } qw/4 3 1 2/;
    print ("@@b" eq '1 2 3 4' ? "ok 56\n" : "not ok 56\n");
    print "# x = '@@b'\n";
    print !$def ? "ok 57\n" : "not ok 57\n";
}
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d8 1
a8 1
print "1..58\n";
a316 7
}

# Bug 19991001.003
{
    sub routine { "one", "two" };
    @@a = sort(routine(1));
    print "@@a" eq "one two" ? "ok 58\n" : "not ok 58\n";
@


1.1.1.6
log
@Import of stock perl 5.8.5
@
text
@d8 1
a8 1
print "1..75\n";
a324 72


my $test = 59;
sub ok {
    print "not " unless $_[0] eq $_[1];
    print "ok $test - $_[2]\n";
    print "#[$_[0]] ne [$_[1]]\n" unless $_[0] eq $_[1];
    $test++;
}

# check for in-place optimisation of @@a = sort @@a
{
    my ($r1,$r2,@@a);
    our @@g;
    @@g = (3,2,1); $r1 = \$g[2]; @@g = sort @@g; $r2 = \$g[0];
    ok "$r1-@@g", "$r2-1 2 3", "inplace sort of global";

    @@a = qw(b a c); $r1 = \$a[1]; @@a = sort @@a; $r2 = \$a[0];
    ok "$r1-@@a", "$r2-a b c", "inplace sort of lexical";

    @@g = (2,3,1); $r1 = \$g[1]; @@g = sort { $b <=> $a } @@g; $r2 = \$g[0];
    ok "$r1-@@g", "$r2-3 2 1", "inplace reversed sort of global";

    @@g = (2,3,1);
    $r1 = \$g[1]; @@g = sort { $a<$b?1:$a>$b?-1:0 } @@g; $r2 = \$g[0];
    ok "$r1-@@g", "$r2-3 2 1", "inplace custom sort of global";

    sub mysort { $b cmp $a };
    @@a = qw(b c a); $r1 = \$a[1]; @@a = sort mysort @@a; $r2 = \$a[0];
    ok "$r1-@@a", "$r2-c b a", "inplace sort with function of lexical";

    use Tie::Array;
    my @@t;
    tie @@t, 'Tie::StdArray';

    @@t = qw(b c a); @@t = sort @@t;
    ok "@@t", "a b c", "inplace sort of tied array";

    @@t = qw(b c a); @@t = sort mysort @@t;
    ok "@@t", "c b a", "inplace sort of tied array with function";

    #  [perl #29790] don't optimise @@a = ('a', sort @@a) !

    @@g = (3,2,1); @@g = ('0', sort @@g);
    ok "@@g", "0 1 2 3", "un-inplace sort of global";
    @@g = (3,2,1); @@g = (sort(@@g),'4');
    ok "@@g", "1 2 3 4", "un-inplace sort of global 2";

    @@a = qw(b a c); @@a = ('x', sort @@a);
    ok "@@a", "x a b c", "un-inplace sort of lexical";
    @@a = qw(b a c); @@a = ((sort @@a), 'x');
    ok "@@a", "a b c x", "un-inplace sort of lexical 2";

    @@g = (2,3,1); @@g = ('0', sort { $b <=> $a } @@g);
    ok "@@g", "0 3 2 1", "un-inplace reversed sort of global";
    @@g = (2,3,1); @@g = ((sort { $b <=> $a } @@g),'4');
    ok "@@g", "3 2 1 4", "un-inplace reversed sort of global 2";

    @@g = (2,3,1); @@g = ('0', sort { $a<$b?1:$a>$b?-1:0 } @@g);
    ok "@@g", "0 3 2 1", "un-inplace custom sort of global";
    @@g = (2,3,1); @@g = ((sort { $a<$b?1:$a>$b?-1:0 } @@g),'4');
    ok "@@g", "3 2 1 4", "un-inplace custom sort of global 2";

    @@a = qw(b c a); @@a = ('x', sort mysort @@a);
    ok "@@a", "x c b a", "un-inplace sort with function of lexical";
    @@a = qw(b c a); @@a = ((sort mysort @@a),'x');
    ok "@@a", "c b a x", "un-inplace sort with function of lexical 2";
}




@


1.1.1.7
log
@perl 5.8.6 from CPAN
@
text
@d8 1
a8 1
print "1..129\n";
d25 1
a25 1
# collation complications: qw(A a B b) can be sorted at least as
a393 2
# Test optimisations of reversed sorts. As we now guarantee stability by
# default, # optimisations which do not provide this are bogus.
a394 270
{
    package Oscalar;
    use overload (qw("" stringify 0+ numify fallback 1));

    sub new {
	bless [$_[1], $_[2]], $_[0];
    }

    sub stringify { $_[0]->[0] }

    sub numify { $_[0]->[1] }
}

sub generate {
    my $count = 0;
    map {new Oscalar $_, $count++} qw(A A A B B B C C C);
}

my @@input = &generate;
my @@output = sort @@input;
ok join(" ", map {0+$_} @@output), "0 1 2 3 4 5 6 7 8", "Simple stable sort";

@@input = &generate;
@@input = sort @@input;
ok join(" ", map {0+$_} @@input), "0 1 2 3 4 5 6 7 8",
    "Simple stable in place sort";

# This won't be very interesting
@@input = &generate;
@@output = sort {$a <=> $b} @@input;
ok "@@output", "A A A B B B C C C", 'stable $a <=> $b sort';

@@input = &generate;
@@output = sort {$a cmp $b} @@input;
ok join(" ", map {0+$_} @@output), "0 1 2 3 4 5 6 7 8", 'stable $a cmp $b sort';

@@input = &generate;
@@input = sort {$a cmp $b} @@input;
ok join(" ", map {0+$_} @@input), "0 1 2 3 4 5 6 7 8",
    'stable $a cmp $b in place sort';

@@input = &generate;
@@output = sort {$b cmp $a} @@input;
ok join(" ", map {0+$_} @@output), "6 7 8 3 4 5 0 1 2", 'stable $b cmp $a sort';

@@input = &generate;
@@input = sort {$b cmp $a} @@input;
ok join(" ", map {0+$_} @@input), "6 7 8 3 4 5 0 1 2",
    'stable $b cmp $a in place sort';

@@input = &generate;
@@output = reverse sort @@input;
ok join(" ", map {0+$_} @@output), "8 7 6 5 4 3 2 1 0", "Reversed stable sort";

@@input = &generate;
@@input = reverse sort @@input;
ok join(" ", map {0+$_} @@input), "8 7 6 5 4 3 2 1 0",
    "Reversed stable in place sort";

@@input = &generate;
my $output = reverse sort @@input;
ok $output, "CCCBBBAAA", "Reversed stable sort in scalar context";


@@input = &generate;
@@output = reverse sort {$a cmp $b} @@input;
ok join(" ", map {0+$_} @@output), "8 7 6 5 4 3 2 1 0",
    'reversed stable $a cmp $b sort';

@@input = &generate;
@@input = reverse sort {$a cmp $b} @@input;
ok join(" ", map {0+$_} @@input), "8 7 6 5 4 3 2 1 0",
    'revesed stable $a cmp $b in place sort';

@@input = &generate;
$output = reverse sort {$a cmp $b} @@input;
ok $output, "CCCBBBAAA", 'Reversed stable $a cmp $b sort in scalar context';

@@input = &generate;
@@output = reverse sort {$b cmp $a} @@input;
ok join(" ", map {0+$_} @@output), "2 1 0 5 4 3 8 7 6",
    'reversed stable $b cmp $a sort';

@@input = &generate;
@@input = reverse sort {$b cmp $a} @@input;
ok join(" ", map {0+$_} @@input), "2 1 0 5 4 3 8 7 6",
    'revesed stable $b cmp $a in place sort';

@@input = &generate;
$output = reverse sort {$b cmp $a} @@input;
ok $output, "AAABBBCCC", 'Reversed stable $b cmp $a sort in scalar context';

sub stuff {
    # Something complex enough to defeat any constant folding optimiser
    $$ - $$;
}

@@input = &generate;
@@output = reverse sort {stuff || $a cmp $b} @@input;
ok join(" ", map {0+$_} @@output), "8 7 6 5 4 3 2 1 0",
    'reversed stable complex sort';

@@input = &generate;
@@input = reverse sort {stuff || $a cmp $b} @@input;
ok join(" ", map {0+$_} @@input), "8 7 6 5 4 3 2 1 0",
    'revesed stable complex in place sort';

@@input = &generate;
$output = reverse sort {stuff || $a cmp $b } @@input;
ok $output, "CCCBBBAAA", 'Reversed stable complex sort in scalar context';

sub sortr {
    reverse sort @@_;
}

@@output = sortr &generate;
ok join(" ", map {0+$_} @@output), "8 7 6 5 4 3 2 1 0",
    'reversed stable sort return list context';
$output = sortr &generate;
ok $output, "CCCBBBAAA",
    'reversed stable sort return scalar context';

sub sortcmpr {
    reverse sort {$a cmp $b} @@_;
}

@@output = sortcmpr &generate;
ok join(" ", map {0+$_} @@output), "8 7 6 5 4 3 2 1 0",
    'reversed stable $a cmp $b sort return list context';
$output = sortcmpr &generate;
ok $output, "CCCBBBAAA",
    'reversed stable $a cmp $b sort return scalar context';

sub sortcmprba {
    reverse sort {$b cmp $a} @@_;
}

@@output = sortcmprba &generate;
ok join(" ", map {0+$_} @@output), "2 1 0 5 4 3 8 7 6",
    'reversed stable $b cmp $a sort return list context';
$output = sortcmprba &generate;
ok $output, "AAABBBCCC",
'reversed stable $b cmp $a sort return scalar context';

sub sortcmprq {
    reverse sort {stuff || $a cmp $b} @@_;
}

@@output = sortcmpr &generate;
ok join(" ", map {0+$_} @@output), "8 7 6 5 4 3 2 1 0",
    'reversed stable complex sort return list context';
$output = sortcmpr &generate;
ok $output, "CCCBBBAAA",
    'reversed stable complex sort return scalar context';

# And now with numbers

sub generate1 {
    my $count = 'A';
    map {new Oscalar $count++, $_} 0, 0, 0, 1, 1, 1, 2, 2, 2;
}

# This won't be very interesting
@@input = &generate1;
@@output = sort {$a cmp $b} @@input;
ok "@@output", "A B C D E F G H I", 'stable $a cmp $b sort';

@@input = &generate1;
@@output = sort {$a <=> $b} @@input;
ok "@@output", "A B C D E F G H I", 'stable $a <=> $b sort';

@@input = &generate1;
@@input = sort {$a <=> $b} @@input;
ok "@@input", "A B C D E F G H I", 'stable $a <=> $b in place sort';

@@input = &generate1;
@@output = sort {$b <=> $a} @@input;
ok "@@output", "G H I D E F A B C", 'stable $b <=> $a sort';

@@input = &generate1;
@@input = sort {$b <=> $a} @@input;
ok "@@input", "G H I D E F A B C", 'stable $b <=> $a in place sort';

# test that optimized {$b cmp $a} and {$b <=> $a} remain stable
# (new in 5.9) without overloading
{ no warnings;
@@b = sort { $b <=> $a } @@input = qw/5first 6first 5second 6second/;
ok "@@b" , "6first 6second 5first 5second", "optimized {$b <=> $a} without overloading" ;
@@input = sort {$b <=> $a} @@input;
ok "@@input" , "6first 6second 5first 5second","inline optimized {$b <=> $a} without overloading" ;
};

# These two are actually doing string cmp on 0 1 and 2
@@input = &generate1;
@@output = reverse sort @@input;
ok "@@output", "I H G F E D C B A", "Reversed stable sort";

@@input = &generate1;
@@input = reverse sort @@input;
ok "@@input", "I H G F E D C B A", "Reversed stable in place sort";

@@input = &generate1;
$output = reverse sort @@input;
ok $output, "IHGFEDCBA", "Reversed stable sort in scalar context";

@@input = &generate1;
@@output = reverse sort {$a <=> $b} @@input;
ok "@@output", "I H G F E D C B A", 'reversed stable $a <=> $b sort';

@@input = &generate1;
@@input = reverse sort {$a <=> $b} @@input;
ok "@@input", "I H G F E D C B A", 'revesed stable $a <=> $b in place sort';

@@input = &generate1;
$output = reverse sort {$a <=> $b} @@input;
ok $output, "IHGFEDCBA", 'reversed stable $a <=> $b sort in scalar context';

@@input = &generate1;
@@output = reverse sort {$b <=> $a} @@input;
ok "@@output", "C B A F E D I H G", 'reversed stable $b <=> $a sort';

@@input = &generate1;
@@input = reverse sort {$b <=> $a} @@input;
ok "@@input", "C B A F E D I H G", 'revesed stable $b <=> $a in place sort';

@@input = &generate1;
$output = reverse sort {$b <=> $a} @@input;
ok $output, "CBAFEDIHG", 'reversed stable $b <=> $a sort in scalar context';

@@input = &generate1;
@@output = reverse sort {stuff || $a <=> $b} @@input;
ok "@@output", "I H G F E D C B A", 'reversed stable complex sort';

@@input = &generate1;
@@input = reverse sort {stuff || $a <=> $b} @@input;
ok "@@input", "I H G F E D C B A", 'revesed stable complex in place sort';

@@input = &generate1;
$output = reverse sort {stuff || $a <=> $b} @@input;
ok $output, "IHGFEDCBA", 'reversed stable complex sort in scalar context';

sub sortnumr {
    reverse sort {$a <=> $b} @@_;
}

@@output = sortnumr &generate1;
ok "@@output", "I H G F E D C B A",
    'reversed stable $a <=> $b sort return list context';
$output = sortnumr &generate1;
ok $output, "IHGFEDCBA", 'reversed stable $a <=> $b sort return scalar context';

sub sortnumrba {
    reverse sort {$b <=> $a} @@_;
}

@@output = sortnumrba &generate1;
ok "@@output", "C B A F E D I H G",
    'reversed stable $b <=> $a sort return list context';
$output = sortnumrba &generate1;
ok $output, "CBAFEDIHG", 'reversed stable $b <=> $a sort return scalar context';

sub sortnumrq {
    reverse sort {stuff || $a <=> $b} @@_;
}

@@output = sortnumrq &generate1;
ok "@@output", "I H G F E D C B A",
    'reversed stable complex sort return list context';
$output = sortnumrq &generate1;
ok $output, "IHGFEDCBA", 'reversed stable complex sort return scalar context';
a395 2
@@output = reverse (sort(qw(C A B)), 0);
ok "@@output", "0 C B A", 'reversed sort with trailing argument';
a396 2
@@output = reverse (0, sort(qw(C A B)));
ok "@@output", "C B A 0", 'reversed sort with leading argument';
@


1.1.1.8
log
@perl 5.8.8 import
@
text
@a16 3

    # Change 26011: Re: A surprising segfault
    map scalar(sort(+())), ('')x68;
@


1.1.1.9
log
@import perl 5.10.0 from CPAN
@
text
@d5 1
a5 1
    @@INC = qw(. ../lib); require 'test.pl';
d8 1
a8 1
plan( tests => 143 );
a23 1
sub Backwards_other { $a lt $b ? 1 : $a gt $b ? -1 : 0 }
d46 2
a47 2

cmp_ok($x,'eq',$expected,'upper first 1');
d51 2
a52 2

cmp_ok($x,'eq',$expected,'upper first 2');
d56 2
a57 2

cmp_ok($x,'eq',$expected,'upper first 3');
d63 2
a65 2
cmp_ok($x,'eq',$expected,'upper first 4');
$" = ' ';
d68 1
a68 1
cmp_ok("@@b",'eq',"",'reverse 1');
d72 1
a72 1
cmp_ok("@@b",'eq',"1",'reverse 2');
d76 1
a76 1
cmp_ok("@@b",'eq',"2 1",'reverse 3');
d80 1
a80 1
cmp_ok("@@b",'eq',"3 2 1",'reverse 4');
d84 1
a84 1
cmp_ok("@@b",'eq',"4 3 2 1",'reverse 5');
d88 1
a88 1
cmp_ok("@@b",'eq',"2 3 4 10",'sort numeric');
d93 2
a94 2

cmp_ok($x,'eq',$expected,'sorter sub name in var 1');
d99 2
a100 2

cmp_ok($x,'eq',$expected,'sorter sub name in var 2');
d105 2
a106 2
cmp_ok("@@b",'eq','1 2 3 4','just sort');

d109 2
a110 2
cmp_ok("@@b",'eq','1 2 3 4','grep then sort');

d113 2
a114 2
cmp_ok("@@b",'eq','1 2 3 4','map then sort');

d117 2
a118 3
cmp_ok("@@b",'eq','1 2 3 4','reverse then sort');


d120 2
a121 1
sub twoface { no warnings 'redefine'; *twoface = sub { $a <=> $b }; &twoface }
d123 1
a123 2
cmp_ok("@@b",'eq','1 2 3 4','redefine sort sub inside the sort sub');

d125 1
d127 1
a127 1
ok(!$@@,"redefining sort subs outside the sort \$@@=[$@@]");
d130 1
a130 1
cmp_ok("@@b",'eq','4 3 2 1','twoface redefinition');
d134 1
a134 1
  *twoface = sub { *twoface = *Backwards_other; $a <=> $b };
d136 2
a137 3

eval { @@b = sort twoface 4,1,9,5 };
ok(($@@ eq "" && "@@b" eq "1 4 5 9"),'redefinition should not take effect during the sort');
d143 1
a143 1
		 die($@@ eq "" ? "good\n" : "bad\n");
d148 1
a148 1
cmp_ok(substr($@@,0,4), 'eq', 'good', 'twoface eval');
d153 1
a153 1
cmp_ok($@@,'eq','',q(old skool package));
d159 1
a159 1
cmp_ok($@@,'eq','',q(one is not a sub));
d167 1
a167 1
  cmp_ok("@@b",'eq','4 3 2 1','sortname 1');
d169 1
a169 1
  cmp_ok("@@b",'eq','4 3 2 1','sortname 2');
d171 1
a171 1
  cmp_ok("@@b",'eq','4 3 2 1','sortname 3');
d173 1
a173 1
  cmp_ok("@@b",'eq','4 3 2 1','sortname 4');
d182 1
a182 1
  cmp_ok("@@b",'eq','4 3 2 1','sortname 5');
d184 1
a184 1
  cmp_ok("@@b",'eq','4 3 2 1','sortname 6');
d186 1
a186 1
  cmp_ok("@@b",'eq','4 3 2 1','sortname 7');
d188 1
a188 1
  cmp_ok("@@b",'eq','4 3 2 1','sortname 8');
d197 1
a197 1
  cmp_ok("@@b",'eq','4 3 2 1','sortname local 1');
d199 1
a199 1
  cmp_ok("@@b",'eq','4 3 2 1','sortname local 2');
d201 1
a201 1
  cmp_ok("@@b",'eq','4 3 2 1','sortname local 3');
d203 1
a203 1
  cmp_ok("@@b",'eq','4 3 2 1','sortname local 4');
d212 1
a212 1
  cmp_ok("@@b",'eq','4 3 2 1','sortname local 5');
d214 1
a214 1
  cmp_ok("@@b",'eq','4 3 2 1','sortname local 6');
d216 1
a216 1
  cmp_ok("@@b",'eq','4 3 2 1','sortname local 7');
d218 1
a218 1
  cmp_ok("@@b",'eq','4 3 2 1','sortname local 8');
d227 2
a228 2
cmp_ok("@@b",'eq','1996 255 90 19 5','force blockness');

d231 2
a232 2
cmp_ok($x,'eq',$expected,'a cmp b');

d235 2
a236 2
cmp_ok($x,'eq',$expected,'b cmp a');

d240 2
a241 2
    cmp_ok("@@b",'eq','5 19 90 255 1996','integer a <=> b');

d243 2
a244 2
    cmp_ok("@@b",'eq','1996 255 90 19 5','integer b <=> a');

d247 2
a248 2
    cmp_ok($x,'eq',$expected,'integer a cmp b');

d251 2
a252 2
    cmp_ok($x,'eq',$expected,'integer b cmp a');

d255 2
a256 2


d258 1
a258 1
cmp_ok($x,'eq','123',q(optimized-away comparison block doesn't take any other arguments away with it));
d264 2
a265 2
main::cmp_ok("@@b",'eq','1996 255 90 19 5','not in main:: 1');

d268 2
a269 2
main::cmp_ok("@@b",'eq','90 5 255 1996 19','not in main:: 2');

d273 1
a273 1

d276 3
a278 3
    main::is($gimme,1,'wantarray 1');


d291 3
a293 3
    main::is(!($gimme or !defined($gimme)),1,'wantarray 2');


d317 3
a319 3
    main::cmp_ok("@@b",'eq','1 2 3 4','reenter 1');

    main::ok(!$def,'reenter 2');
d322 1
a322 1

d326 1
a326 1
    main::cmp_ok("@@a",'eq',"one two",'bug id 19991001.003');
d330 6
a335 6
#my $test = 59;
sub ok { main::cmp_ok($_[0],'eq',$_[1],$_[2]);
#    print "not " unless $_[0] eq $_[1];
#    print "ok $test - $_[2]\n";
#    print "#[$_[0]] ne [$_[1]]\n" unless $_[0] eq $_[1];
#    $test++;
a675 128

eval { @@output = sort {goto sub {}} 1,2; };
$fail_msg = q(Can't goto subroutine outside a subroutine);
main::cmp_ok(substr($@@,0,length($fail_msg)),'eq',$fail_msg,'goto subr outside subr');



sub goto_sub {goto sub{}}
eval { @@output = sort goto_sub 1,2; };
$fail_msg = q(Can't goto subroutine from a sort sub);
main::cmp_ok(substr($@@,0,length($fail_msg)),'eq',$fail_msg,'goto subr from a sort sub');



eval { @@output = sort {goto label} 1,2; };
$fail_msg = q(Can't "goto" out of a pseudo block);
main::cmp_ok(substr($@@,0,length($fail_msg)),'eq',$fail_msg,'goto out of a pseudo block 1');



sub goto_label {goto label}
label: eval { @@output = sort goto_label 1,2; };
$fail_msg = q(Can't "goto" out of a pseudo block);
main::cmp_ok(substr($@@,0,length($fail_msg)),'eq',$fail_msg,'goto out of a pseudo block 2');



sub self_immolate {undef &self_immolate; $a<=>$b}
eval { @@output = sort self_immolate 1,2,3 };
$fail_msg = q(Can't undef active subroutine);
main::cmp_ok(substr($@@,0,length($fail_msg)),'eq',$fail_msg,'undef active subr');



{
    my $failed = 0;

    sub rec {
	my $n = shift;
	if (!defined($n)) {  # No arg means we're being called by sort()
	    return 1;
	}
	if ($n<5) { rec($n+1); }
	else { () = sort rec 1,2; }

	$failed = 1 if !defined $n;
    }

    rec(1);
    main::ok(!$failed, "sort from active sub");
}

# $a and $b are set in the package the sort() is called from,
# *not* the package the sort sub is in. This is longstanding
# de facto behaviour that shouldn't be broken.
package main;
my $answer = "good";
() = sort OtherPack::foo 1,2,3,4;

{
    package OtherPack;
    no warnings 'once';
    sub foo {
	$answer = "something was unexpectedly defined or undefined" if
	defined($a) || defined($b) || !defined($main::a) || !defined($main::b);
	$main::a <=> $main::b;
    }
}

main::cmp_ok($answer,'eq','good','sort subr called from other package');


# Bug 36430 - sort called in package2 while a
# sort in package1 is active should set $package2::a/b.

$answer = "good";
my @@list = sort { A::min(@@$a) <=> A::min(@@$b) }
  [3, 1, 5], [2, 4], [0];

main::cmp_ok($answer,'eq','good','bug 36430');

package A;
sub min {
  my @@list = sort {
    $answer = '$a and/or $b are not defined ' if !defined($a) || !defined($b);
    $a <=> $b;
  } @@_;
  $list[0];
}

# Bug 7567 - an array shouldn't be modifiable while it's being
# sorted in-place.
eval { @@a=(1..8); @@a = sort { @@a = (0) } @@a; };

$fail_msg = q(Modification of a read-only value attempted);
main::cmp_ok(substr($@@,0,length($fail_msg)),'eq',$fail_msg,'bug 7567');



# Sorting shouldn't increase the refcount of a sub
sub foo {(1+$a) <=> (1+$b)}
my $refcnt = &Internals::SvREFCNT(\&foo);
@@output = sort foo 3,7,9;
package Foo;
ok($refcnt, &Internals::SvREFCNT(\&foo), "sort sub refcnt");
$fail_msg = q(Modification of a read-only value attempted);
# Sorting a read-only array in-place shouldn't be allowed
my @@readonly = (1..10);
Internals::SvREADONLY(@@readonly, 1);
eval { @@readonly = sort @@readonly; };
main::cmp_ok(substr($@@,0,length($fail_msg)),'eq',$fail_msg,'in-place sort of read-only array');




# Using return() should be okay even in a deeper context
@@b = sort {while (1) {return ($a <=> $b)} } 1..10;
ok("@@b", "1 2 3 4 5 6 7 8 9 10", "return within loop");

# Using return() should be okay even if there are other items
# on the stack at the time.
@@b = sort {$_ = ($a<=>$b) + do{return $b<=> $a}} 1..10;
ok("@@b", "10 9 8 7 6 5 4 3 2 1", "return with SVs on stack");

# As above, but with a sort sub rather than a sort block.
sub ret_with_stacked { $_ = ($a<=>$b) + do {return $b <=> $a} }
@@b = sort ret_with_stacked 1..10;
ok("@@b", "10 9 8 7 6 5 4 3 2 1", "return with SVs on stack");
@


1.1.1.10
log
@import perl 5.10.1
@
text
@d5 1
a5 2
    @@INC = qw(. ../lib);
    require 'test.pl';
d8 1
a8 1
plan( tests => 144 );
d263 20
a282 5
{
    package Foo;
    @@a = ( 5, 19, 1996, 255, 90 );
    @@b = sort { $b <=> $a } @@a;
    ::cmp_ok("@@b",'eq','1996 255 90 19 5','not in main:: 1');
d284 6
a289 2
    @@b = sort ::Backwards_stacked @@a;
    ::cmp_ok("@@b",'eq','90 5 255 1996 19','not in main:: 2');
d291 3
a293 6
    # check if context for sort arguments is handled right
    sub test_if_list {
        my $gimme = wantarray;
        ::is($gimme,1,'wantarray 1');
    }
    my $m = sub { $a <=> $b };
a294 11
    sub cxt_one { sort $m test_if_list() }
    cxt_one();
    sub cxt_two { sort { $a <=> $b } test_if_list() }
    cxt_two();
    sub cxt_three { sort &test_if_list() }
    cxt_three();

    sub test_if_scalar {
        my $gimme = wantarray;
        ::is(!($gimme or !defined($gimme)),1,'wantarray 2');
    }
a295 7
    $m = \&test_if_scalar;
    sub cxt_four { sort $m 1,2 }
    @@x = cxt_four();
    sub cxt_five { sort { test_if_scalar($a,$b); } 1,2 }
    @@x = cxt_five();
    sub cxt_six { sort test_if_scalar 1,2 }
    @@x = cxt_six();
d298 7
d319 1
a319 1
    cmp_ok("@@b",'eq','1 2 3 4','reenter 1');
d321 1
a321 1
    ok(!$def,'reenter 2');
d328 1
a328 1
    cmp_ok("@@a",'eq',"one two",'bug id 19991001.003');
d332 8
d345 1
a345 1
    is "$r1-@@g", "$r2-1 2 3", "inplace sort of global";
d348 1
a348 1
    is "$r1-@@a", "$r2-a b c", "inplace sort of lexical";
d351 1
a351 1
    is "$r1-@@g", "$r2-3 2 1", "inplace reversed sort of global";
d355 1
a355 1
    is "$r1-@@g", "$r2-3 2 1", "inplace custom sort of global";
d359 1
a359 1
    is "$r1-@@a", "$r2-c b a", "inplace sort with function of lexical";
d366 1
a366 1
    is "@@t", "a b c", "inplace sort of tied array";
d369 1
a369 1
    is "@@t", "c b a", "inplace sort of tied array with function";
d374 1
a374 1
    is "@@g", "0 1 2 3", "un-inplace sort of global";
d376 1
a376 1
    is "@@g", "1 2 3 4", "un-inplace sort of global 2";
d379 1
a379 1
    is "@@a", "x a b c", "un-inplace sort of lexical";
d381 1
a381 1
    is "@@a", "a b c x", "un-inplace sort of lexical 2";
d384 1
a384 1
    is "@@g", "0 3 2 1", "un-inplace reversed sort of global";
d386 1
a386 1
    is "@@g", "3 2 1 4", "un-inplace reversed sort of global 2";
d389 1
a389 1
    is "@@g", "0 3 2 1", "un-inplace custom sort of global";
d391 1
a391 1
    is "@@g", "3 2 1 4", "un-inplace custom sort of global 2";
d394 1
a394 1
    is "@@a", "x c b a", "un-inplace sort with function of lexical";
d396 1
a396 6
    is "@@a", "c b a x", "un-inplace sort with function of lexical 2";

    # RT#54758. Git 62b40d2474e7487e6909e1872b6bccdf812c6818
    no warnings 'void';
    my @@m; push @@m, 0 for 1 .. 1024; $#m; @@m = sort @@m;
    ::pass("in-place sorting segfault");
d422 1
a422 1
is join(" ", map {0+$_} @@output), "0 1 2 3 4 5 6 7 8", "Simple stable sort";
d426 1
a426 1
is join(" ", map {0+$_} @@input), "0 1 2 3 4 5 6 7 8",
d432 1
a432 1
is "@@output", "A A A B B B C C C", 'stable $a <=> $b sort';
d436 1
a436 1
is join(" ", map {0+$_} @@output), "0 1 2 3 4 5 6 7 8", 'stable $a cmp $b sort';
d440 1
a440 1
is join(" ", map {0+$_} @@input), "0 1 2 3 4 5 6 7 8",
d445 1
a445 1
is join(" ", map {0+$_} @@output), "6 7 8 3 4 5 0 1 2", 'stable $b cmp $a sort';
d449 1
a449 1
is join(" ", map {0+$_} @@input), "6 7 8 3 4 5 0 1 2",
d454 1
a454 1
is join(" ", map {0+$_} @@output), "8 7 6 5 4 3 2 1 0", "Reversed stable sort";
d458 1
a458 1
is join(" ", map {0+$_} @@input), "8 7 6 5 4 3 2 1 0",
d463 1
a463 1
is $output, "CCCBBBAAA", "Reversed stable sort in scalar context";
d468 1
a468 1
is join(" ", map {0+$_} @@output), "8 7 6 5 4 3 2 1 0",
d473 1
a473 1
is join(" ", map {0+$_} @@input), "8 7 6 5 4 3 2 1 0",
d478 1
a478 1
is $output, "CCCBBBAAA", 'Reversed stable $a cmp $b sort in scalar context';
d482 1
a482 1
is join(" ", map {0+$_} @@output), "2 1 0 5 4 3 8 7 6",
d487 1
a487 1
is join(" ", map {0+$_} @@input), "2 1 0 5 4 3 8 7 6",
d492 1
a492 1
is $output, "AAABBBCCC", 'Reversed stable $b cmp $a sort in scalar context';
d501 1
a501 1
is join(" ", map {0+$_} @@output), "8 7 6 5 4 3 2 1 0",
d506 1
a506 1
is join(" ", map {0+$_} @@input), "8 7 6 5 4 3 2 1 0",
d511 1
a511 1
is $output, "CCCBBBAAA", 'Reversed stable complex sort in scalar context';
d518 1
a518 1
is join(" ", map {0+$_} @@output), "8 7 6 5 4 3 2 1 0",
d521 1
a521 1
is $output, "CCCBBBAAA",
d529 1
a529 1
is join(" ", map {0+$_} @@output), "8 7 6 5 4 3 2 1 0",
d532 1
a532 1
is $output, "CCCBBBAAA",
d540 1
a540 1
is join(" ", map {0+$_} @@output), "2 1 0 5 4 3 8 7 6",
d543 1
a543 1
is $output, "AAABBBCCC",
d551 1
a551 1
is join(" ", map {0+$_} @@output), "8 7 6 5 4 3 2 1 0",
d554 1
a554 1
is $output, "CCCBBBAAA",
d567 1
a567 1
is "@@output", "A B C D E F G H I", 'stable $a cmp $b sort';
d571 1
a571 1
is "@@output", "A B C D E F G H I", 'stable $a <=> $b sort';
d575 1
a575 1
is "@@input", "A B C D E F G H I", 'stable $a <=> $b in place sort';
d579 1
a579 1
is "@@output", "G H I D E F A B C", 'stable $b <=> $a sort';
d583 1
a583 1
is "@@input", "G H I D E F A B C", 'stable $b <=> $a in place sort';
d589 1
a589 1
is "@@b" , "6first 6second 5first 5second", "optimized {$b <=> $a} without overloading" ;
d591 1
a591 1
is "@@input" , "6first 6second 5first 5second","inline optimized {$b <=> $a} without overloading" ;
d597 1
a597 1
is "@@output", "I H G F E D C B A", "Reversed stable sort";
d601 1
a601 1
is "@@input", "I H G F E D C B A", "Reversed stable in place sort";
d605 1
a605 1
is $output, "IHGFEDCBA", "Reversed stable sort in scalar context";
d609 1
a609 1
is "@@output", "I H G F E D C B A", 'reversed stable $a <=> $b sort';
d613 1
a613 1
is "@@input", "I H G F E D C B A", 'revesed stable $a <=> $b in place sort';
d617 1
a617 1
is $output, "IHGFEDCBA", 'reversed stable $a <=> $b sort in scalar context';
d621 1
a621 1
is "@@output", "C B A F E D I H G", 'reversed stable $b <=> $a sort';
d625 1
a625 1
is "@@input", "C B A F E D I H G", 'revesed stable $b <=> $a in place sort';
d629 1
a629 1
is $output, "CBAFEDIHG", 'reversed stable $b <=> $a sort in scalar context';
d633 1
a633 1
is "@@output", "I H G F E D C B A", 'reversed stable complex sort';
d637 1
a637 1
is "@@input", "I H G F E D C B A", 'revesed stable complex in place sort';
d641 1
a641 1
is $output, "IHGFEDCBA", 'reversed stable complex sort in scalar context';
d648 1
a648 1
is "@@output", "I H G F E D C B A",
d651 1
a651 1
is $output, "IHGFEDCBA", 'reversed stable $a <=> $b sort return scalar context';
d658 1
a658 1
is "@@output", "C B A F E D I H G",
d661 1
a661 1
is $output, "CBAFEDIHG", 'reversed stable $b <=> $a sort return scalar context';
d668 1
a668 1
is "@@output", "I H G F E D C B A",
d671 1
a671 1
is $output, "IHGFEDCBA", 'reversed stable complex sort return scalar context';
d674 1
a674 1
is "@@output", "0 C B A", 'reversed sort with trailing argument';
d677 1
a677 1
is "@@output", "C B A 0", 'reversed sort with leading argument';
d681 1
a681 1
cmp_ok(substr($@@,0,length($fail_msg)),'eq',$fail_msg,'goto subr outside subr');
d688 1
a688 1
cmp_ok(substr($@@,0,length($fail_msg)),'eq',$fail_msg,'goto subr from a sort sub');
d694 1
a694 1
cmp_ok(substr($@@,0,length($fail_msg)),'eq',$fail_msg,'goto out of a pseudo block 1');
d701 1
a701 1
cmp_ok(substr($@@,0,length($fail_msg)),'eq',$fail_msg,'goto out of a pseudo block 2');
d708 1
a708 1
cmp_ok(substr($@@,0,length($fail_msg)),'eq',$fail_msg,'undef active subr');
d727 1
a727 1
    ok(!$failed, "sort from active sub");
d733 1
d747 1
a747 1
cmp_ok($answer,'eq','good','sort subr called from other package');
d752 14
a765 15
{
    my $answer = "good";
    my @@list = sort { A::min(@@$a) <=> A::min(@@$b) }
      [3, 1, 5], [2, 4], [0];

    cmp_ok($answer,'eq','good','bug 36430');

    package A;
    sub min {
        my @@list = sort {
            $answer = '$a and/or $b are not defined ' if !defined($a) || !defined($b);
            $a <=> $b;
        } @@_;
        $list[0];
    }
a767 1

d770 4
a773 2
{
    eval { @@a=(1..8); @@a = sort { @@a = (0) } @@a; };
a774 3
    $fail_msg = q(Modification of a read-only value attempted);
    cmp_ok(substr($@@,0,length($fail_msg)),'eq',$fail_msg,'bug 7567');
}
d778 13
a790 16
{
    sub foo {(1+$a) <=> (1+$b)}
    my $refcnt = &Internals::SvREFCNT(\&foo);
    @@output = sort foo 3,7,9;

    {
        package Foo;
        ::is($refcnt, &Internals::SvREFCNT(\&foo), "sort sub refcnt");
        $fail_msg = q(Modification of a read-only value attempted);
        # Sorting a read-only array in-place shouldn't be allowed
        my @@readonly = (1..10);
        Internals::SvREADONLY(@@readonly, 1);
        eval { @@readonly = sort @@readonly; };
        ::cmp_ok(substr($@@,0,length($fail_msg)),'eq',$fail_msg,'in-place sort of read-only array');
    }
}
d795 1
a795 1
is("@@b", "1 2 3 4 5 6 7 8 9 10", "return within loop");
d800 1
a800 1
is("@@b", "10 9 8 7 6 5 4 3 2 1", "return with SVs on stack");
d805 1
a805 1
is("@@b", "10 9 8 7 6 5 4 3 2 1", "return with SVs on stack");
@


1.1.1.11
log
@Perl 5.12.2 from CPAN
@
text
@d9 1
a9 1
plan( tests => 148 );
d704 2
a705 2
for(1,2) # We run this twice, to make sure sort does not lower the ref
{        # count. See bug 71076.
a770 6
{
    local $TODO = "sort should make sure elements are not freed in the sort block";
    eval { @@nomodify_x=(1..8); our @@copy = sort { @@nomodify_x = (0) } (@@nomodify_x, 3); };
    is($@@, "");
}

d774 3
a776 3
    sub sportello {(1+$a) <=> (1+$b)}
    my $refcnt = &Internals::SvREFCNT(\&sportello);
    @@output = sort sportello 3,7,9;
d779 2
a780 2
        package Doc;
        ::is($refcnt, &Internals::SvREFCNT(\&::sportello), "sort sub refcnt");
a803 7

# Comparison code should be able to give result in non-integer representation.
sub cmp_as_string($$) { $_[0] < $_[1] ? "-1" : $_[0] == $_[1] ? "0" : "+1" }
@@b = sort { cmp_as_string($a, $b) } (1,5,4,7,3,2,3);
is("@@b", "1 2 3 3 4 5 7", "comparison result as string");
@@b = sort cmp_as_string (1,5,4,7,3,2,3);
is("@@b", "1 2 3 3 4 5 7", "comparison result as string");
@


1.1.1.12
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d9 1
a9 1
plan( tests => 171 );
a816 146

# RT #34604: sort didn't honour overloading if the overloaded elements
# were retrieved via tie

{
    package RT34604;

    sub TIEHASH { bless {
			p => bless({ val => 2 }),
			q => bless({ val => 1 }),
		    }
		}
    sub FETCH { $_[0]{$_[1] } }

    my $cc = 0;
    sub compare { $cc++; $_[0]{val} cmp $_[1]{val} }
    my $cs = 0;
    sub str { $cs++; $_[0]{val} }

    use overload 'cmp' => \&compare, '""' => \&str;

    package main;

    tie my %h, 'RT34604';
    my @@sorted = sort @@h{qw(p q)};
    is($cc, 1, 'overload compare called once');
    is("@@sorted","1 2", 'overload sort result');
    is($cs, 2, 'overload string called twice');
}

fresh_perl_is('sub w ($$) {my ($l, my $r) = @@_; my $v = \@@_; undef @@_; $l <=> $r}; print join q{ }, sort w 3, 1, 2, 0',
             '0 1 2 3',
             {stderr => 1, switches => ['-w']},
             'RT #72334');

fresh_perl_is('sub w ($$) {my ($l, my $r) = @@_; my $v = \@@_; undef @@_; @@_ = 0..2; $l <=> $r}; print join q{ }, sort w 3, 1, 2, 0',
             '0 1 2 3',
             {stderr => 1, switches => ['-w']},
             'RT #72334');

{
    my $count = 0;
    {
	package Counter;

	sub new {
	    ++$count;
	    bless [];
	}

	sub DESTROY {
	    --$count;
	}
    }

    sub sorter ($$) {
	my ($l, $r) = @@_;
	my $q = \@@_;
	$l <=> $r;
    }

    is($count, 0, 'None before we start');
    my @@a = map { Counter->new() } 0..1;
    is($count, 2, '2 here');

    my @@b = sort sorter @@a;

    is(scalar @@b, 2);
    cmp_ok($b[0], '<', $b[1], 'sorted!');

    is($count, 2, 'still the same 2 here');

    @@a = (); @@b = ();

    is($count, 0, 'all gone');
}

# [perl #77930] The context stack may be reallocated during a sort, as a
#               result of deeply-nested (or not-so-deeply-nested) calls
#               from a custom sort subroutine.
fresh_perl_is
 '
   $sub = sub {
    local $count = $count+1;
    ()->$sub if $count < 1000;
    $a cmp $b
   };
   () = sort $sub qw<a b c d e f g>;
   print "ok"
 ',
 'ok',
  {},
 '[perl #77930] cx_stack reallocation during sort'
;

# [perl #76026]
# Match vars should not leak from one sort sub call to the next
{
  my $output = '';
  sub soarter {
    $output .= $1;
    "Leakage" =~ /(.*)/;
    1
  }
  sub soarterdd($$) {
    $output .= $1;
    "Leakage" =~ /(.*)/;
    1
  }

  "Win" =~ /(.*)/;
  my @@b = sort soarter 0..2;

  like $output, qr/^(?:Win)+\z/,
   "Match vars do not leak from one plain sort sub to the next";

  $output = '';

  "Win" =~ /(.*)/;
  @@b = sort soarterdd 0..2;

  like $output, qr/^(?:Win)+\z/,
   'Match vars do not leak from one $$ sort sub to the next';
}

# [perl #30661] autoloading
AUTOLOAD { $b <=> $a }
sub stubbedsub;
is join("", sort stubbedsub split//, '04381091'), '98431100',
    'stubborn AUTOLOAD';
is join("", sort hopefullynonexistent split//, '04381091'), '98431100',
    'AUTOLOAD without stub';
my $stubref = \&givemeastub;
is join("", sort $stubref split//, '04381091'), '98431100',
    'AUTOLOAD with stubref';

# [perl #90030] sort without arguments
eval '@@x = (sort); 1';
is $@@, '', '(sort) does not die';
is @@x, 0, '(sort) returns empty list';
eval '@@x = sort; 1';
is $@@, '', 'sort; does not die';
is @@x, 0, 'sort; returns empty list';
eval '{@@x = sort} 1';
is $@@, '', '{sort} does not die';
is @@x, 0, '{sort} returns empty list';
@


1.1.1.13
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d9 1
a9 1
plan( tests => 176 );
d773 1
a773 2
    eval { @@nomodify_x=(1..8);
	   our @@copy = sort { undef @@nomodify_x; 1 } (@@nomodify_x, 3); };
a962 34

# this happened while the padrange op was being added. Sort blocks
# are executed in void context, and the padrange op was skipping pushing
# the item in void cx. The net result was that the return value was
# whatever was on the stack last.

{
    my @@a = sort {
	my $r = $a <=> $b;
	if ($r) {
	    undef; # this got returned by mistake
	    return $r
	}
	return 0;
    } 5,1,3,6,0;
    is "@@a", "0 1 3 5 6", "padrange and void context";
}

# Fatal warnings an sort sub returning a non-number
# We need two evals, because the panic used to happen on scope exit.
eval { eval { use warnings FATAL => 'all'; () = sort { undef } 1,2 } };
is $@@, "",
  'no panic/crash with fatal warnings when sort sub returns undef';
eval { eval { use warnings FATAL => 'all'; () = sort { "no thin" } 1,2 } };
is $@@, "",
  'no panic/crash with fatal warnings when sort sub returns string';
sub notdef($$) { undef }
eval { eval { use warnings FATAL => 'all'; () = sort notdef 1,2 } };
is $@@, "",
  'no panic/crash with fatal warnings when sort sub($$) returns undef';
sub yarn($$) { "no thinking aloud" }
eval { eval { use warnings FATAL => 'all'; () = sort yarn 1,2 } };
is $@@, "",
  'no panic/crash with fatal warnings when sort sub($$) returns string';
@


1.1.1.14
log
@Import perl-5.20.1
@
text
@d9 1
a9 1
plan( tests => 182 );
a121 4
@@b = sort CORE::reverse (4,1,3,2);
cmp_ok("@@b",'eq','1 2 3 4','CORE::reverse then sort');


a285 2
    sub cxt_three_anna_half { sort 0, test_if_list() }
    cxt_three_anna_half();
a768 2
    eval { @@a=1..3 };
    is $@@, "", 'abrupt scope exit turns off readonliness';
a997 13

$#a = -1;
() = [sort { $a = 10; $b = 10; 0 } $#a, $#a];
is $#a, 10, 'sort block modifying $a and $b';

() = sort {
    is \$a, \$a, '[perl #78194] op return values passed to sort'; 0
} "${\''}", "${\''}";

package deletions {
    @@_=sort { delete $deletions::{a}; delete $deletions::{b}; 3 } 1..3;
}
pass "no crash when sort block deletes *a and *b";
@


1.1.1.15
log
@Import perl-5.20.2
@
text
@d9 1
a9 1
plan( tests => 183 );
a124 2
eval  { @@b = sort CORE::revers (4,1,3,2); };
like($@@, qr/^Undefined sort subroutine "CORE::revers" called at /);
@


