head	1.2;
access;
symbols
	OPENBSD_6_2:1.2.0.6
	OPENBSD_6_2_BASE:1.2
	PERL_5_24_2:1.1.1.12
	OPENBSD_6_1:1.2.0.4
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.11.0.10
	OPENBSD_6_0_BASE:1.1.1.11
	OPENBSD_5_9:1.1.1.11.0.4
	OPENBSD_5_9_BASE:1.1.1.11
	OPENBSD_5_8:1.1.1.11.0.6
	OPENBSD_5_8_BASE:1.1.1.11
	PERL_5_20_2:1.1.1.11
	OPENBSD_5_7:1.1.1.11.0.2
	OPENBSD_5_7_BASE:1.1.1.11
	PERL_5_20_1:1.1.1.11
	OPENBSD_5_6:1.1.1.10.0.4
	OPENBSD_5_6_BASE:1.1.1.10
	PERL_5_18_2:1.1.1.10
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.9.0.6
	OPENBSD_5_5_BASE:1.1.1.9
	OPENBSD_5_4:1.1.1.9.0.2
	OPENBSD_5_4_BASE:1.1.1.9
	PERL_5_16_3:1.1.1.9
	OPENBSD_5_3:1.1.1.8.0.10
	OPENBSD_5_3_BASE:1.1.1.8
	OPENBSD_5_2:1.1.1.8.0.8
	OPENBSD_5_2_BASE:1.1.1.8
	OPENBSD_5_1_BASE:1.1.1.8
	OPENBSD_5_1:1.1.1.8.0.6
	OPENBSD_5_0:1.1.1.8.0.4
	OPENBSD_5_0_BASE:1.1.1.8
	OPENBSD_4_9:1.1.1.8.0.2
	OPENBSD_4_9_BASE:1.1.1.8
	PERL_5_12_2:1.1.1.8
	OPENBSD_4_8:1.1.1.7.0.4
	OPENBSD_4_8_BASE:1.1.1.7
	OPENBSD_4_7:1.1.1.7.0.2
	OPENBSD_4_7_BASE:1.1.1.7
	PERL_5_10_1:1.1.1.7
	OPENBSD_4_6:1.1.1.6.0.6
	OPENBSD_4_6_BASE:1.1.1.6
	OPENBSD_4_5:1.1.1.6.0.2
	OPENBSD_4_5_BASE:1.1.1.6
	PERL_5_10_0:1.1.1.6
	OPENBSD_4_4:1.1.1.5.0.10
	OPENBSD_4_4_BASE:1.1.1.5
	OPENBSD_4_3:1.1.1.5.0.8
	OPENBSD_4_3_BASE:1.1.1.5
	OPENBSD_4_2:1.1.1.5.0.6
	OPENBSD_4_2_BASE:1.1.1.5
	OPENBSD_4_1:1.1.1.5.0.4
	OPENBSD_4_1_BASE:1.1.1.5
	OPENBSD_4_0:1.1.1.5.0.2
	OPENBSD_4_0_BASE:1.1.1.5
	PERL_5_8_8:1.1.1.5
	OPENBSD_3_9:1.1.1.4.0.10
	OPENBSD_3_9_BASE:1.1.1.4
	OPENBSD_3_8:1.1.1.4.0.8
	OPENBSD_3_8_BASE:1.1.1.4
	OPENBSD_3_7:1.1.1.4.0.6
	OPENBSD_3_7_BASE:1.1.1.4
	PERL_5_8_6:1.1.1.4
	OPENBSD_3_6:1.1.1.4.0.4
	OPENBSD_3_6_BASE:1.1.1.4
	PERL_5_8_5:1.1.1.4
	PERL_5_8_3:1.1.1.4
	OPENBSD_3_5:1.1.1.4.0.2
	OPENBSD_3_5_BASE:1.1.1.4
	PERL_5_8_2:1.1.1.4
	OPENBSD_3_4:1.1.1.3.0.4
	OPENBSD_3_4_BASE:1.1.1.3
	OPENBSD_3_3:1.1.1.3.0.2
	OPENBSD_3_3_BASE:1.1.1.3
	PERL_5_8_0:1.1.1.3
	OPENBSD_3_2:1.1.1.2.0.6
	OPENBSD_3_2_BASE:1.1.1.2
	OPENBSD_3_1:1.1.1.2.0.4
	OPENBSD_3_1_BASE:1.1.1.2
	OPENBSD_3_0:1.1.1.2.0.2
	OPENBSD_3_0_BASE:1.1.1.2
	PERL_5_6_1:1.1.1.2
	OPENBSD_2_9:1.1.1.1.0.6
	OPENBSD_2_9_BASE:1.1.1.1
	OPENBSD_2_8:1.1.1.1.0.4
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.2
	OPENBSD_2_7_BASE:1.1.1.1
	PERL_5_6_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.32.20;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2000.04.06.16.10.47;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.04.06.16.10.47;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.05.24.18.25.33;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.10.27.22.15.10;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.12.03.02.44.31;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2006.03.28.18.49.44;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2008.09.29.17.19.00;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2009.10.12.18.10.45;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2010.09.24.14.49.18;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2013.03.25.20.09.35;	author sthen;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2014.03.24.14.59.10;	author afresh1;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2014.11.17.20.53.17;	author afresh1;	state Exp;
branches;
next	1.1.1.12;
commitid	B31cAbBIXiCqnL97;

1.1.1.12
date	2017.08.14.13.46.23;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl

# Regression tests for attributes.pm and the C< : attrs> syntax.

BEGIN {
    chdir 't' if -d 't';
    @@INC = '../lib';
    require './test.pl';
    skip_all_if_miniperl("miniperl can't load attributes");
}

use warnings;

$SIG{__WARN__} = sub { die @@_ };

sub eval_ok ($;$) {
    eval shift;
    is( $@@, '', @@_);
}

fresh_perl_is 'use attributes; print "ok"', 'ok', {},
   'attributes.pm can load without warnings.pm already loaded';

our $anon1; eval_ok '$anon1 = sub : method { $_[0]++ }';

eval 'sub e1 ($) : plugh ;';
like $@@, qr/^Invalid CODE attributes?: ["']?plugh["']? at/;

eval 'sub e2 ($) : plugh(0,0) xyzzy ;';
like $@@, qr/^Invalid CODE attributes: ["']?plugh\(0,0\)["']? /;

eval 'sub e3 ($) : plugh(0,0 xyzzy ;';
like $@@, qr/Unterminated attribute parameter in attribute list at/;

eval 'sub e4 ($) : plugh + XYZZY ;';
like $@@, qr/Invalid separator character '[+]' in attribute list at/;

eval_ok 'my main $x : = 0;';
eval_ok 'my $x : = 0;';
eval_ok 'my $x ;';
eval_ok 'my ($x) : = 0;';
eval_ok 'my ($x) ;';
eval_ok 'my ($x) : ;';
eval_ok 'my ($x,$y) : = 0;';
eval_ok 'my ($x,$y) ;';
eval_ok 'my ($x,$y) : ;';

eval 'my ($x,$y) : plugh;';
like $@@, qr/^Invalid SCALAR attribute: ["']?plugh["']? at/;

# bug #16080
eval '{my $x : plugh}';
like $@@, qr/^Invalid SCALAR attribute: ["']?plugh["']? at/;
eval '{my ($x,$y) : plugh(})}';
like $@@, qr/^Invalid SCALAR attribute: ["']?plugh\(}\)["']? at/;

# More syntax tests from the attributes manpage
eval 'my $x : switch(10,foo(7,3))  :  expensive;';
like $@@, qr/^Invalid SCALAR attributes: ["']?switch\(10,foo\(7,3\)\) : expensive["']? at/;
eval q/my $x : Ugly('\(") :Bad;/;
like $@@, qr/^Invalid SCALAR attributes: ["']?Ugly\('\\\("\) : Bad["']? at/;
eval 'my $x : _5x5;';
like $@@, qr/^Invalid SCALAR attribute: ["']?_5x5["']? at/;
eval 'my $x : locked method;';
like $@@, qr/^Invalid SCALAR attributes: ["']?locked : method["']? at/;
eval 'my $x : switch(10,foo();';
like $@@, qr/^Unterminated attribute parameter in attribute list at/;
eval q/my $x : Ugly('(');/;
like $@@, qr/^Unterminated attribute parameter in attribute list at/;
eval 'my $x : 5x5;';
like $@@, qr/error/;
eval 'my $x : Y2::north;';
like $@@, qr/Invalid separator character ':' in attribute list at/;

sub A::MODIFY_SCALAR_ATTRIBUTES { return }
eval 'my A $x : plugh;';
like $@@, qr/^SCALAR package attribute may clash with future reserved word: ["']?plugh["']? at/;

eval 'my A $x : plugh plover;';
like $@@, qr/^SCALAR package attributes may clash with future reserved words: ["']?plugh["']? /;

no warnings 'reserved';
eval 'my A $x : plugh;';
is $@@, '';

eval 'package Cat; my Cat @@socks;';
is $@@, '';

eval 'my Cat %nap;';
is $@@, '';

sub X::MODIFY_CODE_ATTRIBUTES { die "$_[0]" }
sub X::foo { 1 }
*Y::bar = \&X::foo;
*Y::bar = \&X::foo;	# second time for -w
eval 'package Z; sub Y::bar : foo';
like $@@, qr/^X at /;

@@attrs = eval 'attributes::get $anon1';
is "@@attrs", "method";

sub Z::DESTROY { }
sub Z::FETCH_CODE_ATTRIBUTES { return 'Z' }
my $thunk = eval 'bless +sub : method { 1 }, "Z"';
is ref($thunk), "Z";

@@attrs = eval 'attributes::get $thunk';
is "@@attrs", "method Z";

# Test attributes on predeclared subroutines:
eval 'package A; sub PS : lvalue';
@@attrs = eval 'attributes::get \&A::PS';
is "@@attrs", "lvalue";

# Test attributes on predeclared subroutines, after definition
eval 'package A; sub PS : lvalue; sub PS { }';
@@attrs = eval 'attributes::get \&A::PS';
is "@@attrs", "lvalue";

# Test ability to modify existing sub's (or XSUB's) attributes.
eval 'package A; sub X { $_[0] } sub X : method';
@@attrs = eval 'attributes::get \&A::X';
is "@@attrs", "method";

# Above not with just 'pure' built-in attributes.
sub Z::MODIFY_CODE_ATTRIBUTES { (); }
eval 'package Z; sub L { $_[0] } sub L : Z method';
@@attrs = eval 'attributes::get \&Z::L';
is "@@attrs", "method Z";

# Begin testing attributes that tie

{
    package Ttie;
    sub DESTROY {}
    sub TIESCALAR { my $x = $_[1]; bless \$x, $_[0]; }
    sub FETCH { ${$_[0]} }
    sub STORE {
	::pass;
	${$_[0]} = $_[1]*2;
    }
    package Tloop;
    sub MODIFY_SCALAR_ATTRIBUTES { tie ${$_[1]}, 'Ttie', -1; (); }
}

eval_ok '
    package Tloop;
    for my $i (0..2) {
	my $x : TieLoop = $i;
	$x != $i*2 and ::is $x, $i*2;
    }
';

# bug #15898
eval 'our ${""} : foo = 1';
like $@@, qr/Can't declare scalar dereference in "our"/;
eval 'my $$foo : bar = 1';
like $@@, qr/Can't declare scalar dereference in "my"/;


my @@code = qw(lvalue method);
my @@other = qw(shared);
my @@deprecated = qw(locked unique);
my %valid;
$valid{CODE} = {map {$_ => 1} @@code};
$valid{SCALAR} = {map {$_ => 1} @@other};
$valid{ARRAY} = $valid{HASH} = $valid{SCALAR};
my %deprecated;
$deprecated{CODE} = { locked => 1 };
$deprecated{ARRAY} = $deprecated{HASH} = $deprecated{SCALAR} = { unique => 1 };

our ($scalar, @@array, %hash);
foreach my $value (\&foo, \$scalar, \@@array, \%hash) {
    my $type = ref $value;
    foreach my $negate ('', '-') {
	foreach my $attr (@@code, @@other, @@deprecated) {
	    my $attribute = $negate . $attr;
	    eval "use attributes __PACKAGE__, \$value, '$attribute'";
	    if ($deprecated{$type}{$attr}) {
		like $@@, qr/^Attribute "$attr" is deprecated at \(eval \d+\)/,
		    "$type attribute $attribute deprecated";
	    } elsif ($valid{$type}{$attr}) {
		if ($attribute eq '-shared') {
		    like $@@, qr/^A variable may not be unshared/;
		} else {
		    is( $@@, '', "$type attribute $attribute");
		}
	    } else {
		like $@@, qr/^Invalid $type attribute: $attribute/,
		    "Bogus $type attribute $attribute should fail";
	    }
	}
    }
}

# this will segfault if it fails
sub PVBM () { 'foo' }
{ my $dummy = index 'foo', PVBM }

ok !defined(eval 'attributes::get(\PVBM)'), 
    'PVBMs don\'t segfault attributes::get';

{
    #  [perl #49472] Attributes + Unknown Error
    eval '
	use strict;
	sub MODIFY_CODE_ATTRIBUTE{}
	sub f:Blah {$nosuchvar};
    ';

    my $err = $@@;
    like ($err, qr/Global symbol "\$nosuchvar" requires /, 'perl #49472');
}

# Test that code attributes always get applied to the same CV that
# we're left with at the end (bug#66970).
{
	package bug66970;
	our $c;
	sub MODIFY_CODE_ATTRIBUTES { $c = $_[1]; () }
	$c=undef; eval 'sub t0 :Foo';
	main::ok $c == \&{"t0"};
	$c=undef; eval 'sub t1 :Foo { }';
	main::ok $c == \&{"t1"};
	$c=undef; eval 'sub t2';
	our $t2a = \&{"t2"};
	$c=undef; eval 'sub t2 :Foo';
	main::ok $c == \&{"t2"} && $c == $t2a;
	$c=undef; eval 'sub t3';
	our $t3a = \&{"t3"};
	$c=undef; eval 'sub t3 :Foo { }';
	main::ok $c == \&{"t3"} && $c == $t3a;
	$c=undef; eval 'sub t4 :Foo';
	our $t4a = \&{"t4"};
	our $t4b = $c;
	$c=undef; eval 'sub t4 :Foo';
	main::ok $c == \&{"t4"} && $c == $t4b && $c == $t4a;
	$c=undef; eval 'sub t5 :Foo';
	our $t5a = \&{"t5"};
	our $t5b = $c;
	$c=undef; eval 'sub t5 :Foo { }';
	main::ok $c == \&{"t5"} && $c == $t5b && $c == $t5a;
}

my @@tests = grep {/^[^#]/} split /\n/, <<'EOT';
# This one is fine as an empty attribute list
my $holy_Einstein : = '';
# This one is deprecated
my $krunch := 4;
our $FWISK_FWISK_FWIZZACH_FWACH_ZACHITTY_ZICH_SHAZZATZ_FWISK := '';
state $thump := 'Trumpets';
# Lather rinse repeat in my usual obsessive style
my @@holy_perfect_pitch : = ();
my @@zok := ();
our @@GUKGUK := ();
# state @@widget_mark := ();
my %holy_seditives : = ();
my %bang := ();
our %GIGAZING := ();
# state %hex := ();
my $holy_giveaways : = '';
my $eee_yow := [];
our $TWOYYOYYOING_THUK_UGH := 1 == 1;
state $octothorn := 'Tinky Winky';
my @@holy_Taj_Mahal : = ();
my @@touche := ();
our @@PLAK_DAK_THUK_FRIT := ();
# state @@hash_mark := ();
my %holy_priceless_collection_of_Etruscan_snoods : = ();
my %wham_eth := ();
our %THWUK := ();
# state %octalthorpe := ();
my $holy_sewer_pipe : = '';
my $thunk := undef;
our $BLIT := time;
state $crunch := 'Laa Laa';
my @@glurpp := ();
my @@holy_harem : = ();
our @@FABADAP := ();
# state @@square := ();
my %holy_pin_cushions : = ();
my %swoosh := ();
our %RRRRR := ();
# state %scratchmark := ();
EOT

foreach my $test (@@tests) {
    use feature 'state';
    eval $test;
    if ($test =~ /:=/) {
	like $@@, qr/Use of := for an empty attribute list is not allowed/,
	    "Parse error for q{$test}";
    } else {
	is $@@, '', "No error for q{$test}";
    }
}

# [perl #68560] Calling closure prototypes (only accessible via :attr)
{
  package brength;
  my $proto;
  sub MODIFY_CODE_ATTRIBUTES { $proto = $_[1]; _: }
  eval q{
     my $x;
     () = sub :a0 { $x };
  };
  package main;
  eval { $proto->() };               # used to crash in pp_entersub
  like $@@, qr/^Closure prototype called/,
     "Calling closure proto with (no) args";
  eval { () = &$proto };             # used to crash in pp_leavesub
  like $@@, qr/^Closure prototype called/,
     'Calling closure proto with no @@_ that returns a lexical';
}

# Referencing closure prototypes
{
  package buckbuck;
  my @@proto;
  sub MODIFY_CODE_ATTRIBUTES { push @@proto, $_[1], \&{$_[1]}; _: }
  my $id;
  () = sub :buck {$id};
  &::is(@@proto, 'referencing closure prototype');
}

# [perl #68658] Attributes on stately variables
{
  package thwext;
  sub MODIFY_SCALAR_ATTRIBUTES { () }
  my $i = 0;
  my $x_values = '';
  eval 'sub foo { use 5.01; state $x :A0 = $i++; $x_values .= $x }';
  foo(); foo();
  package main;
  is $x_values, '00', 'state with attributes';
}

{
  package ningnangnong;
  sub MODIFY_SCALAR_ATTRIBUTES{}
  sub MODIFY_ARRAY_ATTRIBUTES{  }
  sub MODIFY_HASH_ATTRIBUTES{    }
  my ($cows, @@go, %bong) : teapots = qw[ jibber jabber joo ];
  ::is $cows, 'jibber', 'list assignment to scalar with attrs';
  ::is "@@go", 'jabber joo', 'list assignment to array with attrs';
}

{
  my $w;
  local $SIG{__WARN__} = sub { $w = shift };
  sub  ent         {}
  sub lent :lvalue {}
  my $posmsg =
      'lvalue attribute applied to already-defined subroutine at '
     .'\(eval';
  my $negmsg =
      'lvalue attribute removed from already-defined subroutine at '
     .'\(eval';
  eval 'use attributes __PACKAGE__, \&ent, "lvalue"';
  like $w, qr/^$posmsg/, 'lvalue attr warning on def sub';
  is join("",&attributes::get(\&ent)), "lvalue",':lvalue applied anyway';
  $w = '';
  eval 'use attributes __PACKAGE__, \&lent, "lvalue"; 1' or die;
  is $w, "", 'no lvalue warning on def lvalue sub';
  eval 'use attributes __PACKAGE__, \&lent, "-lvalue"';
  like $w, qr/^$negmsg/, '-lvalue attr warning on def sub';
  is join("",&attributes::get(\&lent)), "",
       'lvalue attribute removed anyway';
  $w = '';
  eval 'use attributes __PACKAGE__, \&lent, "-lvalue"; 1' or die;
  is $w, "", 'no -lvalue warning on def non-lvalue sub';
  no warnings 'misc';
  eval 'use attributes __PACKAGE__, \&lent, "lvalue"';
  is $w, "", 'no lvalue warnings under no warnings misc';
  eval 'use attributes __PACKAGE__, \&ent, "-lvalue"';
  is $w, "", 'no -lvalue warnings under no warnings misc';
}

unlike runperl(
         prog => 'BEGIN {$^H{a}=b} sub foo:bar{1}',
         stderr => 1,
       ),
       qr/Unbalanced/,
      'attribute errors do not cause op trees to leak';

package ProtoTest {
    sub MODIFY_CODE_ATTRIBUTES { $Proto = prototype $_[1]; () }
    sub foo ($) : gelastic {}
}
is $ProtoTest::Proto, '$', 'prototypes are visible in attr handlers';

{
    my $w;
    local $SIG{__WARN__} = sub { $w = shift };
    attributes ->import(__PACKAGE__, \&foo, "const");
    like $w, qr/^Useless use of attribute "const" at /,
            'Warning for useless const via attributes.pm';
    $w = '';
    attributes ->import(__PACKAGE__, \&foo, "const");
    is $w, '', 'no warning for const if already applied';
    attributes ->import(__PACKAGE__, \&foo, "-const");
    is $w, '', 'no warning for -const with attr already applied';
    attributes ->import(__PACKAGE__, \&bar, "-const");
    is $w, '', 'no warning for -const with attr not already applied';
    package ConstTest;
    sub MODIFY_CODE_ATTRIBUTES {
        attributes->import(shift, shift, lc shift) if $_[2]; ()
    }
    $_ = 32487;
    my $sub = eval '+sub : Const { $_ }';
    ::is $w, '',
     'no warning for :const applied to closure protosub via attributes.pm';
    undef $_;
    ::is &$sub, 32487,
        'applying const attr via attributes.pm';
}

# [perl #123817] Attributes in list-type operators
# These tests used to fail an assertion because the list op generated by
# the lexical attribute declaration was converted to another op type with
# the OPpLVAL_INTRO flag still set.  These op types were not expecting that
# flag to be set, though it was harmless for non-debugging builds.
package _123817 {
    sub MODIFY_SCALAR_ATTRIBUTES {()}
    eval '{my $x : m}';
    eval '[(my $x : m)]';
    eval 'formline my $x : m';
    eval 'return my $x : m';
}

# [perl #126257]
# attributed lex var as function arg caused assertion failure

package P126257 {
    sub MODIFY_SCALAR_ATTRIBUTES {}
    sub MODIFY_ARRAY_ATTRIBUTES  {}
    sub MODIFY_HASH_ATTRIBUTES   {}
    sub MODIFY_CODE_ATTRIBUTES   {}
    sub foo {}
    eval { foo(my $x : bar); };
    ::is $@@, "", "RT 126257 scalar";
    eval { foo(my @@x : bar); };
    ::is $@@, "", "RT 126257 array";
    eval { foo(my %x : bar); };
    ::is $@@, "", "RT 126257 hash";
    eval { foo(sub : bar {}); };
    ::is $@@, "", "RT 126257 sub";
}

done_testing();
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
#!./perl -w
d7 3
a9 1
    unshift @@INC, '../lib';
d12 1
a12 8
sub NTESTS () ;

my ($test, $ntests);
BEGIN {$ntests=0}
$test=0;
my $failed = 0;

print "1..".NTESTS."\n";
d16 3
a18 26
sub mytest {
    if (!$@@ ne !$_[0] || $_[0] && $@@ !~ $_[0]) {
	if ($@@) {
	    my $x = $@@;
	    $x =~ s/\n.*\z//s;
	    print "# Got: $x\n"
	}
	else {
	    print "# Got unexpected success\n";
	}
	if ($_[0]) {
	    print "# Expected: $_[0]\n";
	}
	else {
	    print "# Expected success\n";
	}
	$failed = 1;
	print "not ";
    }
    elsif (@@_ == 3 && $_[1] ne $_[2]) {
	print "# Got: $_[1]\n";
	print "# Expected: $_[2]\n";
	$failed = 1;
	print "not ";
    }
    print "ok ",++$test,"\n";
d21 4
a24 30
eval 'sub t1 ($) : locked { $_[0]++ }';
mytest;
BEGIN {++$ntests}

eval 'sub t2 : locked { $_[0]++ }';
mytest;
BEGIN {++$ntests}

eval 'sub t3 ($) : locked ;';
mytest;
BEGIN {++$ntests}

eval 'sub t4 : locked ;';
mytest;
BEGIN {++$ntests}

my $anon1;
eval '$anon1 = sub ($) : locked:method { $_[0]++ }';
mytest;
BEGIN {++$ntests}

my $anon2;
eval '$anon2 = sub : locked : method { $_[0]++ }';
mytest;
BEGIN {++$ntests}

my $anon3;
eval '$anon3 = sub : method { $_[0]->[1] }';
mytest;
BEGIN {++$ntests}
d27 1
a27 2
mytest qr/^Invalid CODE attributes?: ["']?plugh["']? at/;
BEGIN {++$ntests}
d30 1
a30 2
mytest qr/^Invalid CODE attributes: ["']?plugh\(0,0\)["']? /;
BEGIN {++$ntests}
d33 4
a36 2
mytest qr/Unterminated attribute parameter in attribute list at/;
BEGIN {++$ntests}
d38 9
a46 39
eval 'sub e4 ($) : plugh + xyzzy ;';
mytest qr/Invalid separator character '[+]' in attribute list at/;
BEGIN {++$ntests}

eval 'my main $x : = 0;';
mytest;
BEGIN {++$ntests}

eval 'my $x : = 0;';
mytest;
BEGIN {++$ntests}

eval 'my $x ;';
mytest;
BEGIN {++$ntests}

eval 'my ($x) : = 0;';
mytest;
BEGIN {++$ntests}

eval 'my ($x) ;';
mytest;
BEGIN {++$ntests}

eval 'my ($x) : ;';
mytest;
BEGIN {++$ntests}

eval 'my ($x,$y) : = 0;';
mytest;
BEGIN {++$ntests}

eval 'my ($x,$y) ;';
mytest;
BEGIN {++$ntests}

eval 'my ($x,$y) : ;';
mytest;
BEGIN {++$ntests}
d49 25
a73 2
mytest qr/^Invalid SCALAR attribute: ["']?plugh["']? at/;
BEGIN {++$ntests}
d77 1
a77 2
mytest qr/^SCALAR package attribute may clash with future reserved word: ["']?plugh["']? at/;
BEGIN {++$ntests}
d80 11
a90 2
mytest qr/^SCALAR package attributes may clash with future reserved words: ["']?plugh["']? /;
BEGIN {++$ntests}
d96 2
a97 7
eval 'package Z; sub Y::bar : locked';
mytest qr/^X at /;
BEGIN {++$ntests}

my @@attrs = eval 'attributes::get \&Y::bar';
mytest '', "@@attrs", "locked";
BEGIN {++$ntests}
d100 1
a100 2
mytest '', "@@attrs", "locked method";
BEGIN {++$ntests}
d104 2
a105 3
my $thunk = eval 'bless +sub : method locked { 1 }, "Z"';
mytest '', ref($thunk), "Z";
BEGIN {++$ntests}
d108 87
a194 2
mytest '', "@@attrs", "locked method Z";
BEGIN {++$ntests}
d196 14
d211 3
a213 1
# Other tests should be added above this line
d215 234
a448 1
sub NTESTS () { $ntests }
d450 1
a450 1
exit $failed;
@


1.1.1.1
log
@virgin perl 5.6.0
@
text
@@


1.1.1.2
log
@stock perl 5.6.1
@
text
@d7 1
a7 1
    @@INC = '../lib';
@


1.1.1.3
log
@stock perl 5.8.0 from CPAN
@
text
@a21 1
    my $bad = '';
d38 1
a38 1
	$bad = 'not ';
d44 1
a44 1
	$bad = 'not ';
d46 1
a46 1
    print $bad."ok ".++$test."\n";
a144 4
eval 'package Cat; my Cat @@socks;';
mytest qr/^Can't declare class for non-scalar \@@socks in "my"/;
BEGIN {++$ntests}

d149 1
a149 1
eval 'package Z; sub Y::bar : foo';
d153 1
a153 2
eval 'package Z; sub Y::baz : locked {}';
my @@attrs = eval 'attributes::get \&Y::baz';
a170 39
# Test ability to modify existing sub's (or XSUB's) attributes.
eval 'package A; sub X { $_[0] } sub X : lvalue';
@@attrs = eval 'attributes::get \&A::X';
mytest '', "@@attrs", "lvalue";
BEGIN {++$ntests}

# Above not with just 'pure' built-in attributes.
sub Z::MODIFY_CODE_ATTRIBUTES { (); }
eval 'package Z; sub L { $_[0] } sub L : Z lvalue';
@@attrs = eval 'attributes::get \&Z::L';
mytest '', "@@attrs", "lvalue Z";
BEGIN {++$ntests}


# Begin testing attributes that tie

{
    package Ttie;
    sub DESTROY {}
    sub TIESCALAR { my $x = $_[1]; bless \$x, $_[0]; }
    sub FETCH { ${$_[0]} }
    sub STORE {
	#print "# In Ttie::STORE\n";
	::mytest '';
	${$_[0]} = $_[1]*2;
    }
    package Tloop;
    sub MODIFY_SCALAR_ATTRIBUTES { tie ${$_[1]}, 'Ttie', -1; (); }
}

eval '
    package Tloop;
    for my $i (0..2) {
	my $x : TieLoop = $i;
	$x != $i*2 and ::mytest "", $x, $i*2;
    }
';
mytest;
BEGIN {$ntests += 4}
@


1.1.1.4
log
@perl 5.8.2 from CPAN
@
text
@a7 1
    require './test.pl';
d10 8
a17 1
plan tests => 47;
d21 27
a47 3
sub eval_ok ($) {
    eval $_[0];
    is( $@@, '' );
d50 30
a79 7
eval_ok 'sub t1 ($) : locked { $_[0]++ }';
eval_ok 'sub t2 : locked { $_[0]++ }';
eval_ok 'sub t3 ($) : locked ;';
eval_ok 'sub t4 : locked ;';
our $anon1; eval_ok '$anon1 = sub ($) : locked:method { $_[0]++ }';
our $anon2; eval_ok '$anon2 = sub : locked : method { $_[0]++ }';
our $anon3; eval_ok '$anon3 = sub : method { $_[0]->[1] }';
d82 2
a83 1
like $@@, qr/^Invalid CODE attributes?: ["']?plugh["']? at/;
d86 2
a87 1
like $@@, qr/^Invalid CODE attributes: ["']?plugh\(0,0\)["']? /;
d90 2
a91 1
like $@@, qr/Unterminated attribute parameter in attribute list at/;
d94 2
a95 1
like $@@, qr/Invalid separator character '[+]' in attribute list at/;
d97 35
a131 9
eval_ok 'my main $x : = 0;';
eval_ok 'my $x : = 0;';
eval_ok 'my $x ;';
eval_ok 'my ($x) : = 0;';
eval_ok 'my ($x) ;';
eval_ok 'my ($x) : ;';
eval_ok 'my ($x,$y) : = 0;';
eval_ok 'my ($x,$y) ;';
eval_ok 'my ($x,$y) : ;';
d134 2
a135 25
like $@@, qr/^Invalid SCALAR attribute: ["']?plugh["']? at/;

# bug #16080
eval '{my $x : plugh}';
like $@@, qr/^Invalid SCALAR attribute: ["']?plugh["']? at/;
eval '{my ($x,$y) : plugh(})}';
like $@@, qr/^Invalid SCALAR attribute: ["']?plugh\(}\)["']? at/;

# More syntax tests from the attributes manpage
eval 'my $x : switch(10,foo(7,3))  :  expensive;';
like $@@, qr/^Invalid SCALAR attributes: ["']?switch\(10,foo\(7,3\)\) : expensive["']? at/;
eval q/my $x : Ugly('\(") :Bad;/;
like $@@, qr/^Invalid SCALAR attributes: ["']?Ugly\('\\\("\) : Bad["']? at/;
eval 'my $x : _5x5;';
like $@@, qr/^Invalid SCALAR attribute: ["']?_5x5["']? at/;
eval 'my $x : locked method;';
like $@@, qr/^Invalid SCALAR attributes: ["']?locked : method["']? at/;
eval 'my $x : switch(10,foo();';
like $@@, qr/^Unterminated attribute parameter in attribute list at/;
eval q/my $x : Ugly('(');/;
like $@@, qr/^Unterminated attribute parameter in attribute list at/;
eval 'my $x : 5x5;';
like $@@, qr/error/;
eval 'my $x : Y2::north;';
like $@@, qr/Invalid separator character ':' in attribute list at/;
d139 2
a140 1
like $@@, qr/^SCALAR package attribute may clash with future reserved word: ["']?plugh["']? at/;
d143 2
a144 1
like $@@, qr/^SCALAR package attributes may clash with future reserved words: ["']?plugh["']? /;
d147 2
a148 1
like $@@, qr/^Can't declare class for non-scalar \@@socks in "my"/;
d155 2
a156 1
like $@@, qr/^X at /;
d160 2
a161 1
is "@@attrs", "locked";
d164 2
a165 1
is "@@attrs", "locked method";
d170 2
a171 1
is ref($thunk), "Z";
d174 2
a175 1
is "@@attrs", "locked method Z";
d180 2
a181 1
is "@@attrs", "lvalue";
d187 3
a189 1
is "@@attrs", "lvalue Z";
d199 2
a200 1
	::pass;
d207 1
a207 1
eval_ok '
d211 1
a211 1
	$x != $i*2 and ::is $x, $i*2;
d214 6
d221 1
a221 5
# bug #15898
eval 'our ${""} : foo = 1';
like $@@, qr/Can't declare scalar dereference in our/;
eval 'my $$foo : bar = 1';
like $@@, qr/Can't declare scalar dereference in my/;
@


1.1.1.5
log
@perl 5.8.8 import
@
text
@d11 1
a11 1
plan 'no_plan';
d15 3
a17 3
sub eval_ok ($;$) {
    eval shift;
    is( $@@, '', @@_);
a108 5
# Test attributes on predeclared subroutines:
eval 'package A; sub PS : lvalue';
@@attrs = eval 'attributes::get \&A::PS';
is "@@attrs", "lvalue";

a147 30


my @@code = qw(lvalue locked method);
unshift @@code, 'assertion' if $] >= 5.009;
my @@other = qw(shared unique);
my %valid;
$valid{CODE} = {map {$_ => 1} @@code};
$valid{SCALAR} = {map {$_ => 1} @@other};
$valid{ARRAY} = $valid{HASH} = $valid{SCALAR};

our ($scalar, @@array, %hash);
foreach my $value (\&foo, \$scalar, \@@array, \%hash) {
    my $type = ref $value;
    foreach my $negate ('', '-') {
	foreach my $attr (@@code, @@other) {
	    my $attribute = $negate . $attr;
	    eval "use attributes __PACKAGE__, \$value, '$attribute'";
	    if ($valid{$type}{$attr}) {
		if ($attribute eq '-shared') {
		    like $@@, qr/^A variable may not be unshared/;
		} else {
		    is( $@@, '', "$type attribute $attribute");
		}
	    } else {
		like $@@, qr/^Invalid $type attribute: $attribute/,
		    "Bogus $type attribute $attribute should fail";
	    }
	}
    }
}
@


1.1.1.6
log
@import perl 5.10.0 from CPAN
@
text
@d1 1
a1 1
#!./perl
a4 2
use warnings;

a83 4
no warnings 'reserved';
eval 'my A $x : plugh;';
is $@@, '';

d150 1
a150 1
like $@@, qr/Can't declare scalar dereference in "our"/;
d152 1
a152 1
like $@@, qr/Can't declare scalar dereference in "my"/;
d156 1
@


1.1.1.7
log
@import perl 5.10.1
@
text
@d5 2
a7 4
    if ($ENV{PERL_CORE_MINITEST}) {
	print "1..0 # skip: miniperl can't load attributes\n";
	exit 0;
    }
d13 1
a13 3
use warnings;

plan 90;
a187 7

# this will segfault if it fails
sub PVBM () { 'foo' }
{ my $dummy = index 'foo', PVBM }

ok !defined(attributes::get(\PVBM)), 
    'PVBMs don\'t segfault attributes::get';
@


1.1.1.8
log
@Perl 5.12.2 from CPAN
@
text
@d17 1
a17 1
plan 92;
d26 7
a32 1
our $anon1; eval_ok '$anon1 = sub : method { $_[0]++ }';
d95 1
a95 4
like $@@, '';

eval 'my Cat %nap;';
like $@@, '';
d104 4
d109 1
a109 1
is "@@attrs", "method";
d113 1
a113 1
my $thunk = eval 'bless +sub : method { 1 }, "Z"';
d117 1
a117 1
is "@@attrs", "method Z";
a123 5
# Test attributes on predeclared subroutines, after definition
eval 'package A; sub PS : lvalue; sub PS { }';
@@attrs = eval 'attributes::get \&A::PS';
is "@@attrs", "lvalue";

d125 1
a125 1
eval 'package A; sub X { $_[0] } sub X : method';
d127 1
a127 1
is "@@attrs", "method";
d131 1
a131 1
eval 'package Z; sub L { $_[0] } sub L : Z method';
d133 1
a133 1
is "@@attrs", "method Z";
d165 2
a166 3
my @@code = qw(lvalue method);
my @@other = qw(shared);
my @@deprecated = qw(locked unique);
a170 3
my %deprecated;
$deprecated{CODE} = { locked => 1 };
$deprecated{ARRAY} = $deprecated{HASH} = $deprecated{SCALAR} = { unique => 1 };
d176 1
a176 1
	foreach my $attr (@@code, @@other, @@deprecated) {
d179 1
a179 4
	    if ($deprecated{$type}{$attr}) {
		like $@@, qr/^Attribute "$attr" is deprecated at \(eval \d+\)/,
		    "$type attribute $attribute deprecated";
	    } elsif ($valid{$type}{$attr}) {
a198 42

{
    #  [perl #49472] Attributes + Unkown Error
    eval '
	use strict;
	sub MODIFY_CODE_ATTRIBUTE{}
	sub f:Blah {$nosuchvar};
    ';

    my $err = $@@;
    like ($err, qr/Global symbol "\$nosuchvar" requires /, 'perl #49472');
}

# Test that code attributes always get applied to the same CV that
# we're left with at the end (bug#66970).
{
	package bug66970;
	our $c;
	sub MODIFY_CODE_ATTRIBUTES { $c = $_[1]; () }
	$c=undef; eval 'sub t0 :Foo';
	main::ok $c == \&{"t0"};
	$c=undef; eval 'sub t1 :Foo { }';
	main::ok $c == \&{"t1"};
	$c=undef; eval 'sub t2';
	our $t2a = \&{"t2"};
	$c=undef; eval 'sub t2 :Foo';
	main::ok $c == \&{"t2"} && $c == $t2a;
	$c=undef; eval 'sub t3';
	our $t3a = \&{"t3"};
	$c=undef; eval 'sub t3 :Foo { }';
	main::ok $c == \&{"t3"} && $c == $t3a;
	$c=undef; eval 'sub t4 :Foo';
	our $t4a = \&{"t4"};
	our $t4b = $c;
	$c=undef; eval 'sub t4 :Foo';
	main::ok $c == \&{"t4"} && $c == $t4b && $c == $t4a;
	$c=undef; eval 'sub t5 :Foo';
	our $t5a = \&{"t5"};
	our $t5b = $c;
	$c=undef; eval 'sub t5 :Foo { }';
	main::ok $c == \&{"t5"} && $c == $t5b && $c == $t5a;
}
@


1.1.1.9
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d6 4
a12 1
    skip_all_if_miniperl("miniperl can't load attributes");
d17 2
a25 3
fresh_perl_is 'use attributes; print "ok"', 'ok',
   'attributes.pm can load without warnings.pm already loaded';

d37 1
a37 1
eval 'sub e4 ($) : plugh + XYZZY ;';
d202 1
a202 1
ok !defined(eval 'attributes::get(\PVBM)'), 
d206 1
a206 1
    #  [perl #49472] Attributes + Unknown Error
a245 133

my @@tests = grep {/^[^#]/} split /\n/, <<'EOT';
# This one is fine as an empty attribute list
my $holy_Einstein : = '';
# This one is deprecated
my $krunch := 4;
our $FWISK_FWISK_FWIZZACH_FWACH_ZACHITTY_ZICH_SHAZZATZ_FWISK := '';
state $thump := 'Trumpets';
# Lather rinse repeat in my usual obsessive style
my @@holy_perfect_pitch : = ();
my @@zok := ();
our @@GUKGUK := ();
# state @@widget_mark := ();
my %holy_seditives : = ();
my %bang := ();
our %GIGAZING := ();
# state %hex := ();
my $holy_giveaways : = '';
my $eee_yow := [];
our $TWOYYOYYOING_THUK_UGH := 1 == 1;
state $octothorn := 'Tinky Winky';
my @@holy_Taj_Mahal : = ();
my @@touche := ();
our @@PLAK_DAK_THUK_FRIT := ();
# state @@hash_mark := ();
my %holy_priceless_collection_of_Etruscan_snoods : = ();
my %wham_eth := ();
our %THWUK := ();
# state %octalthorpe := ();
my $holy_sewer_pipe : = '';
my $thunk := undef;
our $BLIT := time;
state $crunch := 'Laa Laa';
my @@glurpp := ();
my @@holy_harem : = ();
our @@FABADAP := ();
# state @@square := ();
my %holy_pin_cushions : = ();
my %swoosh := ();
our %RRRRR := ();
# state %scratchmark := ();
EOT

foreach my $test (@@tests) {
    use feature 'state';
    eval $test;
    if ($test =~ /:=/) {
	like $@@, qr/Use of := for an empty attribute list is not allowed/,
	    "Parse error for q{$test}";
    } else {
	is $@@, '', "No error for q{$test}";
    }
}

# [perl #68560] Calling closure prototypes (only accessible via :attr)
{
  package brength;
  my $proto;
  sub MODIFY_CODE_ATTRIBUTES { $proto = $_[1]; _: }
  eval q{
     my $x;
     () = sub :a0 { $x };
  };
  package main;
  eval { $proto->() };               # used to crash in pp_entersub
  like $@@, qr/^Closure prototype called/,
     "Calling closure proto with (no) args";
  eval { () = &$proto };             # used to crash in pp_leavesub
  like $@@, qr/^Closure prototype called/,
     'Calling closure proto with no @@_ that returns a lexical';
}

# [perl #68658] Attributes on stately variables
{
  package thwext;
  sub MODIFY_SCALAR_ATTRIBUTES { () }
  my $i = 0;
  my $x_values = '';
  eval 'sub foo { use 5.01; state $x :A0 = $i++; $x_values .= $x }';
  foo(); foo();
  package main;
  is $x_values, '00', 'state with attributes';
}

{
  package ningnangnong;
  sub MODIFY_SCALAR_ATTRIBUTES{}
  sub MODIFY_ARRAY_ATTRIBUTES{  }
  sub MODIFY_HASH_ATTRIBUTES{    }
  my ($cows, @@go, %bong) : teapots = qw[ jibber jabber joo ];
  ::is $cows, 'jibber', 'list assignment to scalar with attrs';
  ::is "@@go", 'jabber joo', 'list assignment to array with attrs';
}

{
  my $w;
  local $SIG{__WARN__} = sub { $w = shift };
  sub  ent         {}
  sub lent :lvalue {}
  my $posmsg =
      'lvalue attribute applied to already-defined subroutine at '
     .'\(eval';
  my $negmsg =
      'lvalue attribute removed from already-defined subroutine at '
     .'\(eval';
  eval 'use attributes __PACKAGE__, \&ent, "lvalue"';
  like $w, qr/^$posmsg/, 'lvalue attr warning on def sub';
  is join("",&attributes::get(\&ent)), "lvalue",':lvalue applied anyway';
  $w = '';
  eval 'use attributes __PACKAGE__, \&lent, "lvalue"; 1' or die;
  is $w, "", 'no lvalue warning on def lvalue sub';
  eval 'use attributes __PACKAGE__, \&lent, "-lvalue"';
  like $w, qr/^$negmsg/, '-lvalue attr warning on def sub';
  is join("",&attributes::get(\&lent)), "",
       'lvalue attribute removed anyway';
  $w = '';
  eval 'use attributes __PACKAGE__, \&lent, "-lvalue"; 1' or die;
  is $w, "", 'no -lvalue warning on def non-lvalue sub';
  no warnings 'misc';
  eval 'use attributes __PACKAGE__, \&lent, "lvalue"';
  is $w, "", 'no lvalue warnings under no warnings misc';
  eval 'use attributes __PACKAGE__, \&ent, "-lvalue"';
  is $w, "", 'no -lvalue warnings under no warnings misc';
}

unlike runperl(
         prog => 'BEGIN {$^H{a}=b} sub foo:bar{1}',
         stderr => 1,
       ),
       qr/Unbalanced/,
      'attribute errors do not cause op trees to leak';

done_testing();
@


1.1.1.10
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@a315 10
# Referencing closure prototypes
{
  package buckbuck;
  my @@proto;
  sub MODIFY_CODE_ATTRIBUTES { push @@proto, $_[1], \&{$_[1]}; _: }
  my $id;
  () = sub :buck {$id};
  &::is(@@proto, 'referencing closure prototype');
}

@


1.1.1.11
log
@Import perl-5.20.1
@
text
@d21 1
a21 1
fresh_perl_is 'use attributes; print "ok"', 'ok', {},
@


1.1.1.12
log
@Import perl-5.24.2
@
text
@d87 1
a87 1
is $@@, '';
d90 1
a90 1
is $@@, '';
a384 64

package ProtoTest {
    sub MODIFY_CODE_ATTRIBUTES { $Proto = prototype $_[1]; () }
    sub foo ($) : gelastic {}
}
is $ProtoTest::Proto, '$', 'prototypes are visible in attr handlers';

{
    my $w;
    local $SIG{__WARN__} = sub { $w = shift };
    attributes ->import(__PACKAGE__, \&foo, "const");
    like $w, qr/^Useless use of attribute "const" at /,
            'Warning for useless const via attributes.pm';
    $w = '';
    attributes ->import(__PACKAGE__, \&foo, "const");
    is $w, '', 'no warning for const if already applied';
    attributes ->import(__PACKAGE__, \&foo, "-const");
    is $w, '', 'no warning for -const with attr already applied';
    attributes ->import(__PACKAGE__, \&bar, "-const");
    is $w, '', 'no warning for -const with attr not already applied';
    package ConstTest;
    sub MODIFY_CODE_ATTRIBUTES {
        attributes->import(shift, shift, lc shift) if $_[2]; ()
    }
    $_ = 32487;
    my $sub = eval '+sub : Const { $_ }';
    ::is $w, '',
     'no warning for :const applied to closure protosub via attributes.pm';
    undef $_;
    ::is &$sub, 32487,
        'applying const attr via attributes.pm';
}

# [perl #123817] Attributes in list-type operators
# These tests used to fail an assertion because the list op generated by
# the lexical attribute declaration was converted to another op type with
# the OPpLVAL_INTRO flag still set.  These op types were not expecting that
# flag to be set, though it was harmless for non-debugging builds.
package _123817 {
    sub MODIFY_SCALAR_ATTRIBUTES {()}
    eval '{my $x : m}';
    eval '[(my $x : m)]';
    eval 'formline my $x : m';
    eval 'return my $x : m';
}

# [perl #126257]
# attributed lex var as function arg caused assertion failure

package P126257 {
    sub MODIFY_SCALAR_ATTRIBUTES {}
    sub MODIFY_ARRAY_ATTRIBUTES  {}
    sub MODIFY_HASH_ATTRIBUTES   {}
    sub MODIFY_CODE_ATTRIBUTES   {}
    sub foo {}
    eval { foo(my $x : bar); };
    ::is $@@, "", "RT 126257 scalar";
    eval { foo(my @@x : bar); };
    ::is $@@, "", "RT 126257 array";
    eval { foo(my %x : bar); };
    ::is $@@, "", "RT 126257 hash";
    eval { foo(sub : bar {}); };
    ::is $@@, "", "RT 126257 sub";
}
@


