head	1.2;
access;
symbols
	OPENBSD_6_0:1.1.1.8.0.10
	OPENBSD_6_0_BASE:1.1.1.8
	OPENBSD_5_9:1.1.1.8.0.4
	OPENBSD_5_9_BASE:1.1.1.8
	OPENBSD_5_8:1.1.1.8.0.6
	OPENBSD_5_8_BASE:1.1.1.8
	PERL_5_20_2:1.1.1.8
	OPENBSD_5_7:1.1.1.8.0.2
	OPENBSD_5_7_BASE:1.1.1.8
	PERL_5_20_1:1.1.1.8
	OPENBSD_5_6:1.1.1.7.0.8
	OPENBSD_5_6_BASE:1.1.1.7
	PERL_5_18_2:1.1.1.7
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.7.0.6
	OPENBSD_5_5_BASE:1.1.1.7
	OPENBSD_5_4:1.1.1.7.0.2
	OPENBSD_5_4_BASE:1.1.1.7
	PERL_5_16_3:1.1.1.7
	OPENBSD_5_3:1.1.1.6.0.10
	OPENBSD_5_3_BASE:1.1.1.6
	OPENBSD_5_2:1.1.1.6.0.8
	OPENBSD_5_2_BASE:1.1.1.6
	OPENBSD_5_1_BASE:1.1.1.6
	OPENBSD_5_1:1.1.1.6.0.6
	OPENBSD_5_0:1.1.1.6.0.4
	OPENBSD_5_0_BASE:1.1.1.6
	OPENBSD_4_9:1.1.1.6.0.2
	OPENBSD_4_9_BASE:1.1.1.6
	PERL_5_12_2:1.1.1.6
	OPENBSD_4_8:1.1.1.5.0.8
	OPENBSD_4_8_BASE:1.1.1.5
	OPENBSD_4_7:1.1.1.5.0.4
	OPENBSD_4_7_BASE:1.1.1.5
	PERL_5_10_1:1.1.1.5
	OPENBSD_4_6:1.1.1.5.0.6
	OPENBSD_4_6_BASE:1.1.1.5
	OPENBSD_4_5:1.1.1.5.0.2
	OPENBSD_4_5_BASE:1.1.1.5
	PERL_5_10_0:1.1.1.5
	OPENBSD_4_4:1.1.1.4.0.18
	OPENBSD_4_4_BASE:1.1.1.4
	OPENBSD_4_3:1.1.1.4.0.16
	OPENBSD_4_3_BASE:1.1.1.4
	OPENBSD_4_2:1.1.1.4.0.14
	OPENBSD_4_2_BASE:1.1.1.4
	OPENBSD_4_1:1.1.1.4.0.12
	OPENBSD_4_1_BASE:1.1.1.4
	OPENBSD_4_0:1.1.1.4.0.10
	OPENBSD_4_0_BASE:1.1.1.4
	PERL_5_8_8:1.1.1.4
	OPENBSD_3_9:1.1.1.4.0.8
	OPENBSD_3_9_BASE:1.1.1.4
	OPENBSD_3_8:1.1.1.4.0.6
	OPENBSD_3_8_BASE:1.1.1.4
	OPENBSD_3_7:1.1.1.4.0.4
	OPENBSD_3_7_BASE:1.1.1.4
	PERL_5_8_6:1.1.1.4
	OPENBSD_3_6:1.1.1.4.0.2
	OPENBSD_3_6_BASE:1.1.1.4
	PERL_5_8_5:1.1.1.4
	PERL_5_8_3:1.1.1.3
	OPENBSD_3_5:1.1.1.3.0.2
	OPENBSD_3_5_BASE:1.1.1.3
	PERL_5_8_2:1.1.1.3
	OPENBSD_3_4:1.1.1.2.0.16
	OPENBSD_3_4_BASE:1.1.1.2
	OPENBSD_3_3:1.1.1.2.0.14
	OPENBSD_3_3_BASE:1.1.1.2
	PERL_5_8_0:1.1.1.2
	OPENBSD_3_2:1.1.1.2.0.12
	OPENBSD_3_2_BASE:1.1.1.2
	OPENBSD_3_1:1.1.1.2.0.10
	OPENBSD_3_1_BASE:1.1.1.2
	OPENBSD_3_0:1.1.1.2.0.8
	OPENBSD_3_0_BASE:1.1.1.2
	PERL_5_6_1:1.1.1.2
	OPENBSD_2_9:1.1.1.2.0.6
	OPENBSD_2_9_BASE:1.1.1.2
	OPENBSD_2_8:1.1.1.2.0.4
	OPENBSD_2_8_BASE:1.1.1.2
	OPENBSD_2_7:1.1.1.2.0.2
	OPENBSD_2_7_BASE:1.1.1.2
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.1.1.1.0.2
	OPENBSD_2_6_BASE:1.1.1.1
	PERL_500503:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.32.20;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	99.04.29.22.41.45;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.29.22.41.45;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.04.06.16.10.48;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.12.03.02.44.32;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.08.09.17.48.35;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2008.09.29.17.19.00;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2010.09.24.14.49.18;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2013.03.25.20.09.35;	author sthen;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2014.11.17.20.53.17;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl

#
# grep() and map() tests
#

BEGIN {
    chdir 't' if -d 't';
    @@INC = qw(. ../lib);
    require "./test.pl";
}

plan( tests => 67 );

{
    my @@lol = ([qw(a b c)], [], [qw(1 2 3)]);
    my @@mapped = map  {scalar @@$_} @@lol;
    cmp_ok("@@mapped", 'eq', "3 0 3", 'map scalar list of list');

    my @@grepped = grep {scalar @@$_} @@lol;
    cmp_ok("@@grepped", 'eq', "$lol[0] $lol[2]", 'grep scalar list of list');
    $test++;

    @@grepped = grep { $_ } @@mapped;
    cmp_ok( "@@grepped", 'eq',  "3 3", 'grep basic');
}

{
    my @@res;

    @@res = map({$_} ("geronimo"));
    cmp_ok( scalar(@@res), '==', 1, 'basic map nr');
    cmp_ok( $res[0], 'eq', 'geronimo', 'basic map is');

    @@res = map
             ({$_} ("yoyodyne"));
    cmp_ok( scalar(@@res), '==', 1, 'linefeed map nr');
    cmp_ok( $res[0], 'eq', 'yoyodyne', 'linefeed map is');

    @@res = (map(
       {a =>$_},
     ("chobb")))[0]->{a};
    cmp_ok( scalar(@@res), '==', 1, 'deref map nr');
    cmp_ok( $res[0], 'eq', 'chobb', 'deref map is');

    @@res = map {$_} ("geronimo");
    cmp_ok( scalar(@@res), '==', 1, 'no paren basic map nr');
    cmp_ok( $res[0], 'eq', 'geronimo', 'no paren basic map is');

    @@res = map
             {$_} ("yoyodyne");
    cmp_ok( scalar(@@res), '==', 1, 'no paren linefeed map nr');
    cmp_ok( $res[0], 'eq', 'yoyodyne', 'no paren linefeed map is');

    @@res = (map
           {a =>$_},
       ("chobb"))[0]->{a};
    cmp_ok( scalar(@@res), '==', 1, 'no paren deref map nr');
    cmp_ok( $res[0], 'eq', 'chobb', 'no paren deref map is');

    my $x = "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\n";

    @@res = map($_&$x,("sferics\n"));
    cmp_ok( scalar(@@res), '==', 1, 'binand map nr 1');
    cmp_ok( $res[0], 'eq', "sferics\n", 'binand map is 1');

    @@res = map
            ($_ & $x, ("sferics\n"));
    cmp_ok( scalar(@@res), '==', 1, 'binand map nr 2');
    cmp_ok( $res[0], 'eq', "sferics\n", 'binand map is 2');

    @@res = map { $_ & $x } ("sferics\n");
    cmp_ok( scalar(@@res), '==', 1, 'binand map nr 3');
    cmp_ok( $res[0], 'eq', "sferics\n", 'binand map is 3');

    @@res = map
             { $_&$x } ("sferics\n");
    cmp_ok( scalar(@@res), '==', 1, 'binand map nr 4');
    cmp_ok( $res[0], 'eq', "sferics\n", 'binand map is 4');

    @@res = grep({$_} ("geronimo"));
    cmp_ok( scalar(@@res), '==', 1, 'basic grep nr');
    cmp_ok( $res[0], 'eq', 'geronimo', 'basic grep is');

    @@res = grep
                ({$_} ("yoyodyne"));
    cmp_ok( scalar(@@res), '==', 1, 'linefeed grep nr');
    cmp_ok( $res[0], 'eq', 'yoyodyne', 'linefeed grep is');

    @@res = grep
        ({a=>$_}->{a},
        ("chobb"));
    cmp_ok( scalar(@@res), '==', 1, 'deref grep nr');
    cmp_ok( $res[0], 'eq', 'chobb', 'deref grep is');

    @@res = grep {$_} ("geronimo");
    cmp_ok( scalar(@@res), '==', 1, 'no paren basic grep nr');
    cmp_ok( $res[0], 'eq', 'geronimo', 'no paren basic grep is');

    @@res = grep
                {$_} ("yoyodyne");
    cmp_ok( scalar(@@res), '==', 1, 'no paren linefeed grep nr');
    cmp_ok( $res[0], 'eq', 'yoyodyne', 'no paren linefeed grep is');

    @@res = grep {a=>$_}->{a}, ("chobb");
    cmp_ok( scalar(@@res), '==', 1, 'no paren deref grep nr');
    cmp_ok( $res[0], 'eq', 'chobb', 'no paren deref grep is');

    @@res = grep
         {a=>$_}->{a}, ("chobb");
    cmp_ok( scalar(@@res), '==', 1, 'no paren deref linefeed  nr');
    cmp_ok( $res[0], 'eq', 'chobb', 'no paren deref linefeed  is');

    @@res = grep($_&"X", ("bodine"));
    cmp_ok( scalar(@@res), '==', 1, 'binand X grep nr');
    cmp_ok( $res[0], 'eq', 'bodine', 'binand X grep is');

    @@res = grep
           ($_&"X", ("bodine"));
    cmp_ok( scalar(@@res), '==', 1, 'binand X linefeed grep nr');
    cmp_ok( $res[0], 'eq', 'bodine', 'binand X linefeed grep is');

    @@res = grep {$_&"X"} ("bodine");
    cmp_ok( scalar(@@res), '==', 1, 'no paren binand X grep nr');
    cmp_ok( $res[0], 'eq', 'bodine', 'no paren binand X grep is');

    @@res = grep
           {$_&"X"} ("bodine");
    cmp_ok( scalar(@@res), '==', 1, 'no paren binand X linefeed grep nr');
    cmp_ok( $res[0], 'eq', 'bodine', 'no paren binand X linefeed grep is');
}

{
    # Tests for "for" in "map" and "grep"
    # Used to dump core, bug [perl #17771]

    my @@x;
    my $y = '';
    @@x = map { $y .= $_ for 1..2; 1 } 3..4;
    cmp_ok( "@@x,$y",'eq',"1 1,1212", '[perl #17771] for in map 1');

    $y = '';
    @@x = map { $y .= $_ for 1..2; $y .= $_ } 3..4;
    cmp_ok( "@@x,$y",'eq',"123 123124,123124", '[perl #17771] for in map 2');

    $y = '';
    @@x = map { for (1..2) { $y .= $_ } $y .= $_ } 3..4;
    cmp_ok( "@@x,$y",'eq',"123 123124,123124", '[perl #17771] for in map 3');

    $y = '';
    @@x = grep { $y .= $_ for 1..2; 1 } 3..4;
    cmp_ok( "@@x,$y",'eq',"3 4,1212", '[perl #17771] for in grep 1');

    $y = '';
    @@x = grep { for (1..2) { $y .= $_ } 1 } 3..4;
    cmp_ok( "@@x,$y",'eq',"3 4,1212", '[perl #17771] for in grep 2');

    # Add also a sample test from [perl #18153].  (The same bug).
    $a = 1; map {if ($a){}} (2);
    pass( '[perl #18153] (not dead yet)' ); # no core dump is all we need
}

{
    sub add_an_x(@@){
        map {"${_}x"} @@_;
    };
    cmp_ok( join("-",add_an_x(1,2,3,4)), 'eq', "1x-2x-3x-4x", 'add-an-x');
}

{
    my $gimme;

    sub gimme {
        my $want = wantarray();
        if (defined $want) {
            $gimme = $want ? 'list' : 'scalar';
        } else {
            $gimme = 'void';
        }
    }

    my @@list = 0..9;

    undef $gimme; gimme for @@list;      cmp_ok($gimme, 'eq', 'void',   'gimme a V!');
    undef $gimme; grep { gimme } @@list; cmp_ok($gimme, 'eq', 'scalar', 'gimme an S!');
    undef $gimme; map { gimme } @@list;  cmp_ok($gimme, 'eq', 'list',   'gimme an L!');
}

{
    # test scalar context return
    my @@list = (7, 14, 21);

    my $x = map {$_ *= 2} @@list;
    cmp_ok("@@list", 'eq', "14 28 42", 'map scalar return');
    cmp_ok($x, '==', 3, 'map scalar count');

    @@list = (9, 16, 25, 36);
    $x = grep {$_ % 2} @@list;
    cmp_ok($x, '==', 2, 'grep scalar count');

    my @@res = grep {$_ % 2} @@list;
    cmp_ok("@@res", 'eq', "9 25", 'grep extract');
}

{
    # This shouldn't loop indefinitely.
    my @@empty = map { while (1) {} } ();
    cmp_ok("@@empty", 'eq', '', 'staying alive');
}

{
    my $x;
    eval 'grep $x (1,2,3);';
    like($@@, qr/Missing comma after first argument to grep function/,
         "proper error on variable as block. [perl #37314]");
}

# [perl #78194] grep/map aliasing op return values
grep is(\$_, \$_, '[perl #78194] \$_ == \$_ inside grep ..., "$x"'),
     "${\''}", "${\''}";
map is(\$_, \$_, '[perl #78194] \$_ == \$_ inside map ..., "$x"'),
     "${\''}", "${\''}";

# [perl #92254] freeing $_ in gremap block
{
    my $y;
    grep { undef *_ } $y;
    map { undef *_ } $y;
}
pass 'no double frees with grep/map { undef *_ }';

# Don't mortalise PADTMPs.
# This failed while I was messing with leave stuff (but not in a simple
# test, so add one). The '1;' ensures the block is wrapped in ENTER/LEAVE;
# the stringify returns a PADTMP. DAPM.

{
    my @@a = map { 1; "$_" } 1,2;
    is("@@a", "1 2", "PADTMP");
}
@


1.1
log
@Initial revision
@
text
@d7 23
a29 1
print "1..3\n";
d31 105
a135 1
$test = 1;
d137 24
a160 4
sub ok {
    my ($got,$expect) = @@_;
    print "# expected [$expect], got [$got]\nnot " if $got ne $expect;
    print "ok $test\n";
d164 5
a168 4
   my @@lol = ([qw(a b c)], [], [qw(1 2 3)]);
   my @@mapped = map  {scalar @@$_} @@lol;
   ok "@@mapped", "3 0 3";
   $test++;
d170 2
a171 3
   my @@grepped = grep {scalar @@$_} @@lol;
   ok "@@grepped", "$lol[0] $lol[2]";
   $test++;
d173 14
a186 3
   @@grepped = grep { $_ } @@mapped;
   ok "@@grepped", "3 3";
   $test++;
d189 52
@


1.1.1.1
log
@perl5.005_03
@
text
@@


1.1.1.2
log
@virgin perl 5.6.0
@
text
@d7 1
a7 1
print "1..27\n";
a31 68
{
   print map({$_} ("ok $test\n"));
   $test++;
   print map
            ({$_} ("ok $test\n"));
   $test++;
   print((map({a => $_}, ("ok $test\n")))[0]->{a});
   $test++;
   print((map
            ({a=>$_},
	     ("ok $test\n")))[0]->{a});
   $test++;
   print map { $_ } ("ok $test\n");
   $test++;
   print map
            { $_ } ("ok $test\n");
   $test++;
   print((map {a => $_}, ("ok $test\n"))[0]->{a});
   $test++;
   print((map
            {a=>$_},
	     ("ok $test\n"))[0]->{a});
   $test++;
   my $x = "ok \xFF\xFF\n";
   print map($_&$x,("ok $test\n"));
   $test++;
   print map
            ($_ & $x, ("ok $test\n"));
   $test++;
   print map { $_ & $x } ("ok $test\n");
   $test++;
   print map
             { $_&$x } ("ok $test\n");
   $test++;

   print grep({$_} ("ok $test\n"));
   $test++;
   print grep
            ({$_} ("ok $test\n"));
   $test++;
   print grep({a => $_}->{a}, ("ok $test\n"));
   $test++;
   print grep
	     ({a => $_}->{a},
	     ("ok $test\n"));
   $test++;
   print grep { $_ } ("ok $test\n");
   $test++;
   print grep
             { $_ } ("ok $test\n");
   $test++;
   print grep {a => $_}->{a}, ("ok $test\n");
   $test++;
   print grep
	     {a => $_}->{a},
	     ("ok $test\n");
   $test++;
   print grep($_&"X",("ok $test\n"));
   $test++;
   print grep
            ($_&"X", ("ok $test\n"));
   $test++;
   print grep { $_ & "X" } ("ok $test\n");
   $test++;
   print grep
             { $_ & "X" } ("ok $test\n");
   $test++;
}
@


1.1.1.3
log
@perl 5.8.2 from CPAN
@
text
@d7 1
a7 1
print "1..37\n";
a99 65

# Tests for "for" in "map" and "grep"
# Used to dump core, bug [perl #17771]

{
    my @@x;
    my $y = '';
    @@x = map { $y .= $_ for 1..2; 1 } 3..4;
    print "# @@x,$y\n";
    print "@@x,$y" eq "1 1,1212" ? "ok $test\n" : "not ok $test\n";
    $test++;
    $y = '';
    @@x = map { $y .= $_ for 1..2; $y .= $_ } 3..4;
    print "# @@x,$y\n";
    print "@@x,$y" eq "123 123124,123124" ? "ok $test\n" : "not ok $test\n";
    $test++;
    $y = '';
    @@x = map { for (1..2) { $y .= $_ } $y .= $_ } 3..4;
    print "# @@x,$y\n";
    print "@@x,$y" eq "123 123124,123124" ? "ok $test\n" : "not ok $test\n";
    $test++;
    $y = '';
    @@x = grep { $y .= $_ for 1..2; 1 } 3..4;
    print "# @@x,$y\n";
    print "@@x,$y" eq "3 4,1212" ? "ok $test\n" : "not ok $test\n";
    $test++;
    $y = '';
    @@x = grep { for (1..2) { $y .= $_ } 1 } 3..4;
    print "# @@x,$y\n";
    print "@@x,$y" eq "3 4,1212" ? "ok $test\n" : "not ok $test\n";
    $test++;

    # Add also a sample test from [perl #18153].  (The same bug).
    $a = 1; map {if ($a){}} (2);
    print "ok $test\n"; # no core dump is all we need
    $test++;
}

{
    sub add_an_x(@@){
        map {"${_}x"} @@_;
    };
    ok join("-",add_an_x(1,2,3,4)), "1x-2x-3x-4x";
    $test++;
}

{
    my $gimme;

    sub gimme {
	my $want = wantarray();
	if (defined $want) {
	    $gimme = $want ? 'list' : 'scalar';
	} else {
	    $gimme = 'void';
	}
    }

    my @@list = 0..9;

    undef $gimme; gimme for @@list;      ok($gimme, 'void');   $test++;
    undef $gimme; grep { gimme } @@list; ok($gimme, 'scalar'); $test++;
    undef $gimme; map { gimme } @@list;  ok($gimme, 'list');   $test++;
}

@


1.1.1.4
log
@Import of stock perl 5.8.5
@
text
@d7 1
a7 1
print "1..38\n";
a164 5
{
    # This shouldn't loop indefinitively.
    my @@empty = map { while (1) {} } ();
    ok("@@empty", '');
}
@


1.1.1.5
log
@import perl 5.10.0 from CPAN
@
text
@d7 1
a7 12
BEGIN {
    chdir 't' if -d 't';
    @@INC = qw(. ../lib);
}

require "test.pl";
plan( tests => 60 );

{
    my @@lol = ([qw(a b c)], [], [qw(1 2 3)]);
    my @@mapped = map  {scalar @@$_} @@lol;
    cmp_ok("@@mapped", 'eq', "3 0 3", 'map scalar list of list');
d9 1
a9 3
    my @@grepped = grep {scalar @@$_} @@lol;
    cmp_ok("@@grepped", 'eq', "$lol[0] $lol[2]", 'grep scalar list of list');
    $test++;
d11 88
a98 2
    @@grepped = grep { $_ } @@mapped;
    cmp_ok( "@@grepped", 'eq',  "3 3", 'grep basic');
d101 2
a102 104
{
    my @@res;

    @@res = map({$_} ("geronimo"));
    cmp_ok( scalar(@@res), '==', 1, 'basic map nr');
    cmp_ok( $res[0], 'eq', 'geronimo', 'basic map is');

    @@res = map
             ({$_} ("yoyodyne"));
    cmp_ok( scalar(@@res), '==', 1, 'linefeed map nr');
    cmp_ok( $res[0], 'eq', 'yoyodyne', 'linefeed map is');

    @@res = (map(
       {a =>$_},
     ("chobb")))[0]->{a};
    cmp_ok( scalar(@@res), '==', 1, 'deref map nr');
    cmp_ok( $res[0], 'eq', 'chobb', 'deref map is');

    @@res = map {$_} ("geronimo");
    cmp_ok( scalar(@@res), '==', 1, 'no paren basic map nr');
    cmp_ok( $res[0], 'eq', 'geronimo', 'no paren basic map is');

    @@res = map
             {$_} ("yoyodyne");
    cmp_ok( scalar(@@res), '==', 1, 'no paren linefeed map nr');
    cmp_ok( $res[0], 'eq', 'yoyodyne', 'no paren linefeed map is');

    @@res = (map
           {a =>$_},
       ("chobb"))[0]->{a};
    cmp_ok( scalar(@@res), '==', 1, 'no paren deref map nr');
    cmp_ok( $res[0], 'eq', 'chobb', 'no paren deref map is');

    my $x = "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\n";

    @@res = map($_&$x,("sferics\n"));
    cmp_ok( scalar(@@res), '==', 1, 'binand map nr 1');
    cmp_ok( $res[0], 'eq', "sferics\n", 'binand map is 1');

    @@res = map
            ($_ & $x, ("sferics\n"));
    cmp_ok( scalar(@@res), '==', 1, 'binand map nr 2');
    cmp_ok( $res[0], 'eq', "sferics\n", 'binand map is 2');

    @@res = map { $_ & $x } ("sferics\n");
    cmp_ok( scalar(@@res), '==', 1, 'binand map nr 3');
    cmp_ok( $res[0], 'eq', "sferics\n", 'binand map is 3');

    @@res = map
             { $_&$x } ("sferics\n");
    cmp_ok( scalar(@@res), '==', 1, 'binand map nr 4');
    cmp_ok( $res[0], 'eq', "sferics\n", 'binand map is 4');

    @@res = grep({$_} ("geronimo"));
    cmp_ok( scalar(@@res), '==', 1, 'basic grep nr');
    cmp_ok( $res[0], 'eq', 'geronimo', 'basic grep is');

    @@res = grep
                ({$_} ("yoyodyne"));
    cmp_ok( scalar(@@res), '==', 1, 'linefeed grep nr');
    cmp_ok( $res[0], 'eq', 'yoyodyne', 'linefeed grep is');

    @@res = grep
        ({a=>$_}->{a},
        ("chobb"));
    cmp_ok( scalar(@@res), '==', 1, 'deref grep nr');
    cmp_ok( $res[0], 'eq', 'chobb', 'deref grep is');

    @@res = grep {$_} ("geronimo");
    cmp_ok( scalar(@@res), '==', 1, 'no paren basic grep nr');
    cmp_ok( $res[0], 'eq', 'geronimo', 'no paren basic grep is');

    @@res = grep
                {$_} ("yoyodyne");
    cmp_ok( scalar(@@res), '==', 1, 'no paren linefeed grep nr');
    cmp_ok( $res[0], 'eq', 'yoyodyne', 'no paren linefeed grep is');

    @@res = grep {a=>$_}->{a}, ("chobb");
    cmp_ok( scalar(@@res), '==', 1, 'no paren deref grep nr');
    cmp_ok( $res[0], 'eq', 'chobb', 'no paren deref grep is');

    @@res = grep
         {a=>$_}->{a}, ("chobb");
    cmp_ok( scalar(@@res), '==', 1, 'no paren deref linefeed  nr');
    cmp_ok( $res[0], 'eq', 'chobb', 'no paren deref linefeed  is');

    @@res = grep($_&"X", ("bodine"));
    cmp_ok( scalar(@@res), '==', 1, 'binand X grep nr');
    cmp_ok( $res[0], 'eq', 'bodine', 'binand X grep is');

    @@res = grep
           ($_&"X", ("bodine"));
    cmp_ok( scalar(@@res), '==', 1, 'binand X linefeed grep nr');
    cmp_ok( $res[0], 'eq', 'bodine', 'binand X linefeed grep is');

    @@res = grep {$_&"X"} ("bodine");
    cmp_ok( scalar(@@res), '==', 1, 'no paren binand X grep nr');
    cmp_ok( $res[0], 'eq', 'bodine', 'no paren binand X grep is');

    @@res = grep
           {$_&"X"} ("bodine");
    cmp_ok( scalar(@@res), '==', 1, 'no paren binand X linefeed grep nr');
    cmp_ok( $res[0], 'eq', 'bodine', 'no paren binand X linefeed grep is');
}
a104 3
    # Tests for "for" in "map" and "grep"
    # Used to dump core, bug [perl #17771]

d108 3
a110 2
    cmp_ok( "@@x,$y",'eq',"1 1,1212", '[perl #17771] for in map 1');

d113 3
a115 2
    cmp_ok( "@@x,$y",'eq',"123 123124,123124", '[perl #17771] for in map 2');

d118 3
a120 2
    cmp_ok( "@@x,$y",'eq',"123 123124,123124", '[perl #17771] for in map 3');

d123 3
a125 2
    cmp_ok( "@@x,$y",'eq',"3 4,1212", '[perl #17771] for in grep 1');

d128 3
a130 1
    cmp_ok( "@@x,$y",'eq',"3 4,1212", '[perl #17771] for in grep 2');
d134 2
a135 1
    pass( '[perl #18153] (not dead yet)' ); # no core dump is all we need
d142 2
a143 1
    cmp_ok( join("-",add_an_x(1,2,3,4)), 'eq', "1x-2x-3x-4x", 'add-an-x');
d150 6
a155 6
        my $want = wantarray();
        if (defined $want) {
            $gimme = $want ? 'list' : 'scalar';
        } else {
            $gimme = 'void';
        }
d160 3
a162 19
    undef $gimme; gimme for @@list;      cmp_ok($gimme, 'eq', 'void',   'gimme a V!');
    undef $gimme; grep { gimme } @@list; cmp_ok($gimme, 'eq', 'scalar', 'gimme an S!');
    undef $gimme; map { gimme } @@list;  cmp_ok($gimme, 'eq', 'list',   'gimme an L!');
}

{
    # test scalar context return
    my @@list = (7, 14, 21);

    my $x = map {$_ *= 2} @@list;
    cmp_ok("@@list", 'eq', "14 28 42", 'map scalar return');
    cmp_ok($x, '==', 3, 'map scalar count');

    @@list = (9, 16, 25, 36);
    $x = grep {$_ % 2} @@list;
    cmp_ok($x, '==', 2, 'grep scalar count');

    my @@res = grep {$_ % 2} @@list;
    cmp_ok("@@res", 'eq', "9 25", 'grep extract');
d168 1
a168 1
    cmp_ok("@@empty", 'eq', '', 'staying alive');
@


1.1.1.6
log
@Perl 5.12.2 from CPAN
@
text
@d13 1
a13 1
plan( tests => 61 );
a208 7
}

{
    my $x;
    eval 'grep $x (1,2,3);';
    like($@@, qr/Missing comma after first argument to grep function/,
         "proper error on variable as block. [perl #37314]");
@


1.1.1.7
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@a9 1
    require "test.pl";
d12 2
a13 1
plan( tests => 62 );
d206 1
a206 1
    # This shouldn't loop indefinitely.
a216 8

# [perl #92254] freeing $_ in gremap block
{
    my $y;
    grep { undef *_ } $y;
    map { undef *_ } $y;
}
pass 'no double frees with grep/map { undef *_ }';
@


1.1.1.8
log
@Import perl-5.20.1
@
text
@d13 1
a13 1
plan( tests => 66 );
a216 6

# [perl #78194] grep/map aliasing op return values
grep is(\$_, \$_, '[perl #78194] \$_ == \$_ inside grep ..., "$x"'),
     "${\''}", "${\''}";
map is(\$_, \$_, '[perl #78194] \$_ == \$_ inside map ..., "$x"'),
     "${\''}", "${\''}";
@


