head	1.2;
access;
symbols
	OPENBSD_6_2:1.2.0.6
	OPENBSD_6_2_BASE:1.2
	PERL_5_24_2:1.1.1.7
	OPENBSD_6_1:1.2.0.4
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.6.0.16
	OPENBSD_6_0_BASE:1.1.1.6
	OPENBSD_5_9:1.1.1.6.0.10
	OPENBSD_5_9_BASE:1.1.1.6
	OPENBSD_5_8:1.1.1.6.0.12
	OPENBSD_5_8_BASE:1.1.1.6
	PERL_5_20_2:1.1.1.6
	OPENBSD_5_7:1.1.1.6.0.4
	OPENBSD_5_7_BASE:1.1.1.6
	PERL_5_20_1:1.1.1.6
	OPENBSD_5_6:1.1.1.6.0.8
	OPENBSD_5_6_BASE:1.1.1.6
	PERL_5_18_2:1.1.1.6
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.6.0.6
	OPENBSD_5_5_BASE:1.1.1.6
	OPENBSD_5_4:1.1.1.6.0.2
	OPENBSD_5_4_BASE:1.1.1.6
	PERL_5_16_3:1.1.1.6
	OPENBSD_5_3:1.1.1.5.0.10
	OPENBSD_5_3_BASE:1.1.1.5
	OPENBSD_5_2:1.1.1.5.0.8
	OPENBSD_5_2_BASE:1.1.1.5
	OPENBSD_5_1_BASE:1.1.1.5
	OPENBSD_5_1:1.1.1.5.0.6
	OPENBSD_5_0:1.1.1.5.0.4
	OPENBSD_5_0_BASE:1.1.1.5
	OPENBSD_4_9:1.1.1.5.0.2
	OPENBSD_4_9_BASE:1.1.1.5
	PERL_5_12_2:1.1.1.5
	OPENBSD_4_8:1.1.1.4.0.8
	OPENBSD_4_8_BASE:1.1.1.4
	OPENBSD_4_7:1.1.1.4.0.4
	OPENBSD_4_7_BASE:1.1.1.4
	PERL_5_10_1:1.1.1.4
	OPENBSD_4_6:1.1.1.4.0.6
	OPENBSD_4_6_BASE:1.1.1.4
	OPENBSD_4_5:1.1.1.4.0.2
	OPENBSD_4_5_BASE:1.1.1.4
	PERL_5_10_0:1.1.1.4
	OPENBSD_4_4:1.1.1.3.0.18
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.16
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_2:1.1.1.3.0.14
	OPENBSD_4_2_BASE:1.1.1.3
	OPENBSD_4_1:1.1.1.3.0.12
	OPENBSD_4_1_BASE:1.1.1.3
	OPENBSD_4_0:1.1.1.3.0.10
	OPENBSD_4_0_BASE:1.1.1.3
	PERL_5_8_8:1.1.1.3
	OPENBSD_3_9:1.1.1.3.0.8
	OPENBSD_3_9_BASE:1.1.1.3
	OPENBSD_3_8:1.1.1.3.0.6
	OPENBSD_3_8_BASE:1.1.1.3
	OPENBSD_3_7:1.1.1.3.0.4
	OPENBSD_3_7_BASE:1.1.1.3
	PERL_5_8_6:1.1.1.3
	OPENBSD_3_6:1.1.1.3.0.2
	OPENBSD_3_6_BASE:1.1.1.3
	PERL_5_8_5:1.1.1.3
	PERL_5_8_3:1.1.1.2
	OPENBSD_3_5:1.1.1.2.0.2
	OPENBSD_3_5_BASE:1.1.1.2
	PERL_5_8_2:1.1.1.2
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	PERL_5_8_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.32.20;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2002.10.27.22.15.11;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.27.22.15.11;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.12.03.02.44.33;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.08.09.17.48.36;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2008.09.29.17.19.02;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2010.09.24.14.49.17;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2013.03.25.20.09.37;	author sthen;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2017.08.14.13.46.24;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl -w

BEGIN {
    chdir 't' if -d 't';
    @@INC = '../lib';
    require './test.pl';

    plan(tests => 99);
}

use strict;

# Two hashes one with all 8-bit possible keys (initially), other
# with a utf8 requiring key from the outset.

my %hash8 = ( "\xff" => 0xff,
              "\x7f" => 0x7f,
            );
my %hashu = ( "\xff" => 0xff,
              "\x7f" => 0x7f,
              "\x{1ff}" => 0x1ff,
            );

# Check that we can find the 8-bit things by various literals
is($hash8{"\x{00ff}"},0xFF);
is($hash8{"\x{007f}"},0x7F);
is($hash8{"\xff"},0xFF);
is($hash8{"\x7f"},0x7F);
is($hashu{"\x{00ff}"},0xFF);
is($hashu{"\x{007f}"},0x7F);
is($hashu{"\xff"},0xFF);
is($hashu{"\x7f"},0x7F);

# Now try same thing with variables forced into various forms.
foreach ("\x7f","\xff")
 {
  my $a = $_; # Force a copy
  utf8::upgrade($a);
  is($hash8{$a},ord($a));
  is($hashu{$a},ord($a));
  utf8::downgrade($a);
  is($hash8{$a},ord($a));
  is($hashu{$a},ord($a));
  my $b = $a.chr(100);
  chop($b);
  is($hash8{$b},ord($b));
  is($hashu{$b},ord($b));
 }

# Check we have not got an spurious extra keys
is(join('',sort { ord $a <=> ord $b } keys %hash8),"\x7f\xff");
is(join('',sort { ord $a <=> ord $b } keys %hashu),"\x7f\xff\x{1ff}");

# Now add a utf8 key to the 8-bit hash
$hash8{chr(0x1ff)} = 0x1ff;

# Check we have not got an spurious extra keys
is(join('',sort { ord $a <=> ord $b } keys %hash8),"\x7f\xff\x{1ff}");

foreach ("\x7f","\xff","\x{1ff}")
 {
  my $a = $_;
  utf8::upgrade($a);
  is($hash8{$a},ord($a));
  my $b = $a.chr(100);
  chop($b);
  is($hash8{$b},ord($b));
 }

# and remove utf8 from the other hash
is(delete $hashu{chr(0x1ff)},0x1ff);
is(join('',sort keys %hashu),"\x7f\xff");

foreach ("\x7f","\xff")
 {
  my $a = $_;
  utf8::upgrade($a);
  is($hashu{$a},ord($a));
  utf8::downgrade($a);
  is($hashu{$a},ord($a));
  my $b = $a.chr(100);
  chop($b);
  is($hashu{$b},ord($b));
 }



{
  print "# Unicode hash keys and \\w\n";
  # This is not really a regex test but regexes bring
  # out the issue nicely.
  use strict;
  my $u3 = "f\x{df}\x{100}";
  my $u2 = substr($u3,0,2);
  my $u1 = substr($u2,0,1);
  my $u0 = chr (0xdf)x4; # Make this 4 chars so that all lengths are distinct.

  my @@u = ($u0, $u1, $u2, $u3);

  while (@@u) {
    my %u = (map {( $_, $_)} @@u);
    my $keys = scalar @@u;
    $keys .= ($keys == 1) ? " key" : " keys";

    for (keys %u) {
        my $l = 0 + /^\w+$/;
        my $r = 0 + $u{$_} =~ /^\w+$/;
	is ($l, $r, "\\w on keys with $keys, key of length " . length $_);
    }

    my $more;
    do {
      $more = 0;
      # Want to do this direct, rather than copying to a temporary variable
      # The first time each will return key and value at the start of the hash.
      # each will return () after we've done the last pair. $more won't get
      # set then, and the do will exit.
      for (each %u) {
        $more = 1;
        my $l = 0 + /^\w+$/;
        my $r = 0 + $u{$_} =~ /^\w+$/;
        is ($l, $r, "\\w on each, with $keys, key of length " . length $_);
      }
    } while ($more);

    for (%u) {
      my $l = 0 + /^\w+$/;
      my $r = 0 + $u{$_} =~ /^\w+$/;
      is ($l, $r, "\\w on hash with $keys, key of length " . length $_);
    }
    pop @@u;
    undef %u;
  }
}

{
  my $utf8_sz = my $bytes_sz = "\x{df}";
  $utf8_sz .= chr 256;
  chop ($utf8_sz);

  my (%bytes_first, %utf8_first);

  $bytes_first{$bytes_sz} = $bytes_sz;

  for (keys %bytes_first) {
    my $l = 0 + /^\w+$/;
    my $r = 0 + $bytes_first{$_} =~ /^\w+$/;
    is ($l, $r, "\\w on each, bytes");
  }

  $bytes_first{$utf8_sz} = $utf8_sz;

  for (keys %bytes_first) {
    my $l = 0 + /^\w+$/;
    my $r = 0 + $bytes_first{$_} =~ /^\w+$/;
    is ($l, $r, "\\w on each, bytes now utf8");
  }

  $utf8_first{$utf8_sz} = $utf8_sz;

  for (keys %utf8_first) {
    my $l = 0 + /^\w+$/;
    my $r = 0 + $utf8_first{$_} =~ /^\w+$/;
    is ($l, $r, "\\w on each, utf8");
  }

  $utf8_first{$bytes_sz} = $bytes_sz;

  for (keys %utf8_first) {
    my $l = 0 + /^\w+$/;
    my $r = 0 + $utf8_first{$_} =~ /^\w+$/;
    is ($l, $r, "\\w on each, utf8 now bytes");
  }

}

{
    local $/; # Slurp.
    my $data = <DATA>;
    my ($utf8, $utf1047ebcdic) = split /__SPLIT__/, $data;
    $utf8 = $utf1047ebcdic if $::IS_EBCDIC;
    eval $utf8;
}
__END__
{
  # See if utf8 barewords work [perl #22969]
  use utf8;
  my %hash = (—Ç–µ—Å—Ç => 123);
  is($hash{—Ç–µ—Å—Ç}, $hash{'—Ç–µ—Å—Ç'});
  is($hash{—Ç–µ—Å—Ç}, 123);
  is($hash{'—Ç–µ—Å—Ç'}, 123);
  %hash = (—Ç–µ—Å—Ç => 123);
  is($hash{—Ç–µ—Å—Ç}, $hash{'—Ç–µ—Å—Ç'});
  is($hash{—Ç–µ—Å—Ç}, 123);
  is($hash{'—Ç–µ—Å—Ç'}, 123);

  # See if plain ASCII strings quoted with '=>' erroneously get utf8 flag [perl #68812]
  my %foo = (a => 'b', 'c' => 'd');
  for my $key (keys %foo) {
    ok !utf8::is_utf8($key), "'$key' shouldn't have utf8 flag";
  }
}
__SPLIT__
{   # This is 1047 UTF-EBCDIC; won't work on other code pages.
  # See if utf8 barewords work [perl #22969]
  use utf8; # UTF-EBCDIC, really.
  my %hash = (Ω‰‰Ω‚¿Ω‰‚Ω‰‰ => 123);
  is($hash{Ω‰‰Ω‚¿Ω‰‚Ω‰‰}, $hash{'Ω‰‰Ω‚¿Ω‰‚Ω‰‰'});
  is($hash{Ω‰‰Ω‚¿Ω‰‚Ω‰‰}, 123);
  is($hash{'Ω‰‰Ω‚¿Ω‰‚Ω‰‰'}, 123);
  %hash = (Ω‰‰Ω‚¿Ω‰‚Ω‰‰ => 123);
  is($hash{Ω‰‰Ω‚¿Ω‰‚Ω‰‰}, $hash{'Ω‰‰Ω‚¿Ω‰‚Ω‰‰'});
  is($hash{Ω‰‰Ω‚¿Ω‰‚Ω‰‰}, 123);
  is($hash{'Ω‰‰Ω‚¿Ω‰‚Ω‰‰'}, 123);

  # See if plain ASCII strings quoted with '=>' erroneously get utf8 flag [perl #68812]
  my %foo = (a => 'b', 'c' => 'd');
  for my $key (keys %foo) {
    ok !utf8::is_utf8($key), "'$key' shouldn't have utf8 flag";
  }
}
@


1.1
log
@Initial revision
@
text
@d8 1
a8 1
    plan(tests => 91);
d13 1
a13 1
# Two hashes one will all keys 8-bit possible (initially), other
d24 1
a24 1
# Check that we can find the 8-bit things by various litterals
d35 1
a35 1
foreach my $a ("\x7f","\xff")
d37 1
d60 1
a60 1
foreach my $a ("\x7f","\xff","\x{1ff}")
d62 1
d74 1
a74 1
foreach my $a ("\x7f","\xff")
d76 1
d175 46
@


1.1.1.1
log
@stock perl 5.8.0 from CPAN
@
text
@@


1.1.1.2
log
@perl 5.8.2 from CPAN
@
text
@d8 1
a8 1
    plan(tests => 97);
a171 13
}

{
  # See if utf8 barewords work [perl #22969]
  use utf8;
  my %hash = (—Ç–µ—Å—Ç => 123);
  is($hash{—Ç–µ—Å—Ç}, $hash{'—Ç–µ—Å—Ç'});
  is($hash{—Ç–µ—Å—Ç}, 123);
  is($hash{'—Ç–µ—Å—Ç'}, 123);
  %hash = (—Ç–µ—Å—Ç => 123);
  is($hash{—Ç–µ—Å—Ç}, $hash{'—Ç–µ—Å—Ç'});
  is($hash{—Ç–µ—Å—Ç}, 123);
  is($hash{'—Ç–µ—Å—Ç'}, 123);
@


1.1.1.3
log
@Import of stock perl 5.8.5
@
text
@d35 1
a35 1
foreach ("\x7f","\xff")
a36 1
  my $a = $_; # Force a copy
d59 1
a59 1
foreach ("\x7f","\xff","\x{1ff}")
a60 1
  my $a = $_;
d72 1
a72 1
foreach ("\x7f","\xff")
a73 1
  my $a = $_;
@


1.1.1.4
log
@import perl 5.10.0 from CPAN
@
text
@a177 11
    local $/; # Slurp.
    my $utf8      = <DATA>;
    my $utfebcdic = <DATA>;
    if (ord('A') == 65) {
	eval $utf8;
    } elsif (ord('A') == 193) {
	eval $utfebcdic;
    }
}
__END__
{
a187 13
}
__END__
{
  # See if utf8 barewords work [perl #22969]
  use utf8; # UTF-EBCDIC, really.
  my %hash = (Ω‰‰Ω‚¿Ω‰‚Ω‰‰ => 123);
  is($hash{Ω‰‰Ω‚¿Ω‰‚Ω‰‰}, $hash{'Ω‰‰Ω‚¿Ω‰‚Ω‰‰'});
  is($hash{Ω‰‰Ω‚¿Ω‰‚Ω‰‰}, 123);
  is($hash{'Ω‰‰Ω‚¿Ω‰‚Ω‰‰'}, 123);
  %hash = (Ω‰‰Ω‚¿Ω‰‚Ω‰‰ => 123);
  is($hash{Ω‰‰Ω‚¿Ω‰‚Ω‰‰}, $hash{'Ω‰‰Ω‚¿Ω‰‚Ω‰‰'});
  is($hash{Ω‰‰Ω‚¿Ω‰‚Ω‰‰}, 123);
  is($hash{'Ω‰‰Ω‚¿Ω‰‚Ω‰‰'}, 123);
@


1.1.1.5
log
@Perl 5.12.2 from CPAN
@
text
@d8 1
a8 1
    plan(tests => 99);
a198 6

  # See if plain ASCII strings quoted with '=>' erroneously get utf8 flag [perl #68812]
  my %foo = (a => 'b', 'c' => 'd');
  for my $key (keys %foo) {
    ok !utf8::is_utf8($key), "'$key' shouldn't have utf8 flag";
  }
a211 6

  # See if plain ASCII strings quoted with '=>' erroneously get utf8 flag [perl #68812]
  my %foo = (a => 'b', 'c' => 'd');
  for my $key (keys %foo) {
    ok !utf8::is_utf8($key), "'$key' shouldn't have utf8 flag";
  }
@


1.1.1.6
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d24 1
a24 1
# Check that we can find the 8-bit things by various literals
@


1.1.1.7
log
@Import perl-5.24.2
@
text
@d13 1
a13 1
# Two hashes one with all 8-bit possible keys (initially), other
d179 7
a185 4
    my $data = <DATA>;
    my ($utf8, $utf1047ebcdic) = split /__SPLIT__/, $data;
    $utf8 = $utf1047ebcdic if $::IS_EBCDIC;
    eval $utf8;
d206 2
a207 2
__SPLIT__
{   # This is 1047 UTF-EBCDIC; won't work on other code pages.
@


