head	1.2;
access;
symbols
	OPENBSD_6_1:1.2.0.2
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.8.0.10
	OPENBSD_6_0_BASE:1.1.1.8
	OPENBSD_5_9:1.1.1.8.0.4
	OPENBSD_5_9_BASE:1.1.1.8
	OPENBSD_5_8:1.1.1.8.0.6
	OPENBSD_5_8_BASE:1.1.1.8
	PERL_5_20_2:1.1.1.8
	OPENBSD_5_7:1.1.1.8.0.2
	OPENBSD_5_7_BASE:1.1.1.8
	PERL_5_20_1:1.1.1.8
	OPENBSD_5_6:1.1.1.7.0.18
	OPENBSD_5_6_BASE:1.1.1.7
	PERL_5_18_2:1.1.1.7
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.7.0.16
	OPENBSD_5_5_BASE:1.1.1.7
	OPENBSD_5_4:1.1.1.7.0.12
	OPENBSD_5_4_BASE:1.1.1.7
	PERL_5_16_3:1.1.1.7
	OPENBSD_5_3:1.1.1.7.0.10
	OPENBSD_5_3_BASE:1.1.1.7
	OPENBSD_5_2:1.1.1.7.0.8
	OPENBSD_5_2_BASE:1.1.1.7
	OPENBSD_5_1_BASE:1.1.1.7
	OPENBSD_5_1:1.1.1.7.0.6
	OPENBSD_5_0:1.1.1.7.0.4
	OPENBSD_5_0_BASE:1.1.1.7
	OPENBSD_4_9:1.1.1.7.0.2
	OPENBSD_4_9_BASE:1.1.1.7
	PERL_5_12_2:1.1.1.7
	OPENBSD_4_8:1.1.1.6.0.4
	OPENBSD_4_8_BASE:1.1.1.6
	OPENBSD_4_7:1.1.1.6.0.2
	OPENBSD_4_7_BASE:1.1.1.6
	PERL_5_10_1:1.1.1.6
	OPENBSD_4_6:1.1.1.5.0.26
	OPENBSD_4_6_BASE:1.1.1.5
	OPENBSD_4_5:1.1.1.5.0.22
	OPENBSD_4_5_BASE:1.1.1.5
	PERL_5_10_0:1.1.1.5
	OPENBSD_4_4:1.1.1.5.0.20
	OPENBSD_4_4_BASE:1.1.1.5
	OPENBSD_4_3:1.1.1.5.0.18
	OPENBSD_4_3_BASE:1.1.1.5
	OPENBSD_4_2:1.1.1.5.0.16
	OPENBSD_4_2_BASE:1.1.1.5
	OPENBSD_4_1:1.1.1.5.0.14
	OPENBSD_4_1_BASE:1.1.1.5
	OPENBSD_4_0:1.1.1.5.0.12
	OPENBSD_4_0_BASE:1.1.1.5
	PERL_5_8_8:1.1.1.5
	OPENBSD_3_9:1.1.1.5.0.10
	OPENBSD_3_9_BASE:1.1.1.5
	OPENBSD_3_8:1.1.1.5.0.8
	OPENBSD_3_8_BASE:1.1.1.5
	OPENBSD_3_7:1.1.1.5.0.6
	OPENBSD_3_7_BASE:1.1.1.5
	PERL_5_8_6:1.1.1.5
	OPENBSD_3_6:1.1.1.5.0.4
	OPENBSD_3_6_BASE:1.1.1.5
	PERL_5_8_5:1.1.1.5
	PERL_5_8_3:1.1.1.5
	OPENBSD_3_5:1.1.1.5.0.2
	OPENBSD_3_5_BASE:1.1.1.5
	PERL_5_8_2:1.1.1.5
	OPENBSD_3_4:1.1.1.4.0.4
	OPENBSD_3_4_BASE:1.1.1.4
	OPENBSD_3_3:1.1.1.4.0.2
	OPENBSD_3_3_BASE:1.1.1.4
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.1.1.3.0.6
	OPENBSD_3_2_BASE:1.1.1.3
	OPENBSD_3_1:1.1.1.3.0.4
	OPENBSD_3_1_BASE:1.1.1.3
	OPENBSD_3_0:1.1.1.3.0.2
	OPENBSD_3_0_BASE:1.1.1.3
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.1.1.2.0.6
	OPENBSD_2_9_BASE:1.1.1.2
	OPENBSD_2_8:1.1.1.2.0.4
	OPENBSD_2_8_BASE:1.1.1.2
	OPENBSD_2_7:1.1.1.2.0.2
	OPENBSD_2_7_BASE:1.1.1.2
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.1.1.1.0.2
	OPENBSD_2_6_BASE:1.1.1.1
	PERL_500503:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.32.20;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	99.04.29.22.41.53;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.29.22.41.53;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.04.06.16.10.52;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.05.24.18.25.49;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.27.22.15.11;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.12.03.02.44.33;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2009.10.12.18.10.45;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2010.09.24.14.49.17;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2014.11.17.20.53.18;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl -w

BEGIN {
    chdir 't' if -d 't';
    require './test.pl';
    set_up_inc(qw '../lib ../dist/base/lib');
}

my @@expect;
my $data = "";
my @@data = ();

plan(tests => 67);

sub compare {
    local $Level = $Level + 1;

    return unless @@expect;
    return ::fail() unless(@@_ == @@expect);

    for my $i (0..$#_) {
	next if $_[$i] eq $expect[$i];
	return ::fail();
    }

    ::pass();
}


package Implement;

sub TIEHANDLE {
    ::compare(TIEHANDLE => @@_);
    my ($class,@@val) = @@_;
    return bless \@@val,$class;
}

sub PRINT {
    ::compare(PRINT => @@_);
    1;
}

sub PRINTF {
    ::compare(PRINTF => @@_);
    2;
}

sub READLINE {
    ::compare(READLINE => @@_);
    wantarray ? @@data : shift @@data;
}

sub GETC {
    ::compare(GETC => @@_);
    substr($data,0,1);
}

sub READ {
    ::compare(READ => @@_);
    substr($_[1],$_[3] || 0) = substr($data,0,$_[2]);
    3;
}

sub EOF {
    ::compare(EOF => @@_);
    @@data ? '' : 1;
}

sub WRITE {
    ::compare(WRITE => @@_);
    $data = substr($_[1],$_[3] || 0, $_[2]);
    length($data);
}

sub CLOSE {
    ::compare(CLOSE => @@_);
    5;
}

package main;

use Symbol;

my $fh = gensym;

@@expect = (TIEHANDLE => 'Implement');
my $ob = tie *$fh,'Implement';
is(ref($ob),  'Implement');
is(tied(*$fh), $ob);

@@expect = (PRINT => $ob,"some","text");
$r = print $fh @@expect[2,3];
is($r, 1);

@@expect = (PRINTF => $ob,"%s","text");
$r = printf $fh @@expect[2,3];
is($r, 2);

@@data = ("the line\n");
@@expect = (EOF => $ob, 1);
is(eof($fh), '');

$text = $data[0];
@@expect = (READLINE => $ob);
$ln = <$fh>;
is($ln, $text);

@@expect = (EOF => $ob, 0);
is(eof, 1);

@@expect = ();
@@in = @@data = qw(a line at a time);
@@line = <$fh>;
@@expect = @@in;
compare(@@line);

@@expect = (GETC => $ob);
$data = "abc";
$ch = getc $fh;
is($ch, "a");

$buf = "xyz";
@@expect = (READ => $ob, $buf, 3);
$data = "abc";
$r = read $fh,$buf,3;
is($r, 3);
is($buf, "abc");


$buf = "xyzasd";
@@expect = (READ => $ob, $buf, 3,3);
$data = "abc";
$r = sysread $fh,$buf,3,3;
is($r, 3);
is($buf, "xyzabc");

$buf = "qwerty";
@@expect = (WRITE => $ob, $buf, 4,1);
$data = "";
$r = syswrite $fh,$buf,4,1;
is($r, 4);
is($data, "wert");

$buf = "qwerty";
@@expect = (WRITE => $ob, $buf, 4);
$data = "";
$r = syswrite $fh,$buf,4;
is($r, 4);
is($data, "qwer");

$buf = "qwerty";
@@expect = (WRITE => $ob, $buf, 6);
$data = "";
$r = syswrite $fh,$buf;
is($r, 6);
is($data, "qwerty");

@@expect = (CLOSE => $ob);
$r = close $fh;
is($r, 5);

# Does aliasing work with tied FHs?
*ALIAS = *$fh;
@@expect = (PRINT => $ob,"some","text");
$r = print ALIAS @@expect[2,3];
is($r, 1);

{
    use warnings;
    # Special case of aliasing STDERR, which used
    # to dump core when warnings were enabled
    local *STDERR = *$fh;
    @@expect = (PRINT => $ob,"some","text");
    $r = print STDERR @@expect[2,3];
    is($r, 1);
}

{
    package Bar::Say;
    use feature 'say';
    use base qw(Implement);

    my $ors;
    sub PRINT     {
        $ors = $\;
        my $self = shift;
        return $self->SUPER::PRINT(@@_);
    }

    my $fh = Symbol::gensym;
    @@expect = (TIEHANDLE => 'Bar::Say');
    ::ok( my $obj = tie *$fh, 'Bar::Say' );

    local $\ = 'something';
    @@expect = (PRINT => $obj, "stuff", "and", "things");
    ::ok( print $fh @@expect[2..4] );
    ::is( $ors, 'something' );
    
    ::ok( say $fh @@expect[2..4] );
    ::is( $ors, "\n",        'say sets $\ to \n in PRINT' );
    ::is( $\,   "something", "  and it's localized" );

    local $\;
    ::ok( say $fh @@expect[2..4] );
    ::is( $ors, "\n",        'say sets $\ to \n in PRINT' );
    ::is( $\,   undef, "  and it's localized, even for undef \$\\" );
}

{
    # Test for change #11536
    package Foo;
    use strict;
    sub TIEHANDLE { bless {} }
    my $cnt = 'a';
    sub READ {
	$_[1] = $cnt++;
	1;
    }
    sub do_read {
	my $fh = shift;
	read $fh, my $buff, 1;
	::pass();
    }
    $|=1;
    tie *STDIN, 'Foo';
    read STDIN, my $buff, 1;
    ::pass();
    do_read(\*STDIN);
    untie *STDIN;
}


{
    # test for change 11639: Can't localize *FH, then tie it
    {
	local *foo;
	tie %foo, 'Blah';
    }
    ok(!tied %foo);

    {
	local *bar;
	tie @@bar, 'Blah';
    }
    ok(!tied @@bar);

    {
	local *BAZ;
	tie *BAZ, 'Blah';
    }
    ok(!tied *BAZ);

    package Blah;

    sub TIEHANDLE {bless {}}
    sub TIEHASH   {bless {}}
    sub TIEARRAY  {bless {}}
}

{
    # warnings should pass to the PRINT method of tied STDERR
    my @@received;

    local *STDERR = *$fh;
    no warnings 'redefine';
    local *Implement::PRINT = sub { @@received = @@_ };

    $r = warn("some", "text", "\n");
    @@expect = (PRINT => $ob,"sometext\n");

    compare(PRINT => @@received);

    use warnings;
    print undef;

    like($received[1], qr/Use of uninitialized value/);
}

{
    # [ID 20020713.001] chomp($data=<tied_fh>)
    local *TEST;
    tie *TEST, 'CHOMP';
    my $data;
    chomp($data = <TEST>);
    is($data, 'foobar');

    package CHOMP;
    sub TIEHANDLE { bless {}, $_[0] }
    sub READLINE { "foobar\n" }
}

{
    # make sure the new eof() features work with @@ARGV magic
    local *ARGV;
    @@ARGV = ('haha');

    @@expect = (TIEHANDLE => 'Implement');
    $ob = tie *ARGV, 'Implement';
    is(ref($ob),  'Implement');
    is(tied(*ARGV), $ob);

    @@data = ("stuff\n");
    @@expect = (EOF => $ob, 1);
    is(eof(ARGV), '');
    @@expect = (EOF => $ob, 2);
    is(eof(), '');
    shift @@data;
    @@expect = (EOF => $ob, 0);
    is(eof, 1);
}
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
#!./perl
d5 2
a6 1
    @@INC = '../lib';
a11 1
my $test = 1;
d13 1
a13 1
sub ok { print "not " unless shift; print "ok ",$test++,"\n"; }
d15 2
a16 3
package Implement;

BEGIN { *ok = \*main::ok }
a17 1
sub compare {
d19 1
a19 1
    return ok(0) unless(@@_ == @@expect);
d21 1
a21 2
    my $i;
    for($i = 0 ; $i < @@_ ; $i++) {
d23 1
a23 1
	return ok(0);
d26 1
a26 1
    ok(1);
d29 3
d33 1
a33 1
    compare(TIEHANDLE => @@_);
d39 1
a39 1
    compare(PRINT => @@_);
d44 1
a44 1
    compare(PRINTF => @@_);
d49 1
a49 1
    compare(READLINE => @@_);
d54 1
a54 1
    compare(GETC => @@_);
d59 1
a59 1
    compare(READ => @@_);
d64 5
d70 1
a70 1
    compare(WRITE => @@_);
d76 1
a76 2
    compare(CLOSE => @@_);
    
a83 2
print "1..29\n";

d88 2
a89 2
ok(ref($ob) eq 'Implement');
ok(tied(*$fh) == $ob);
d93 1
a93 1
ok($r == 1);
d97 5
a101 1
ok($r == 2);
d103 1
a103 1
$text = (@@data = ("the line\n"))[0];
d106 4
a109 1
ok($ln eq $text);
d115 1
a115 1
Implement::compare(@@line);
d120 1
a120 1
ok($ch eq "a");
d126 2
a127 2
ok($r == 3);
ok($buf eq "abc");
d134 2
a135 2
ok($r == 3);
ok($buf eq "xyzabc");
d141 2
a142 2
ok($r == 4);
ok($data eq "wert");
d148 2
a149 2
ok($r == 4);
ok($data eq "qwer");
d155 2
a156 2
ok($r == 6);
ok($data eq "qwerty");
d160 151
a310 1
ok($r == 5);
@


1.1.1.1
log
@perl5.005_03
@
text
@@


1.1.1.2
log
@virgin perl 5.6.0
@
text
@d5 1
a5 1
    unshift @@INC, '../lib';
@


1.1.1.3
log
@stock perl 5.6.1
@
text
@d5 1
a5 1
    @@INC = '../lib';
d80 1
a80 1
print "1..33\n";
a151 16

# Does aliasing work with tied FHs?
*ALIAS = *$fh;
@@expect = (PRINT => $ob,"some","text");
$r = print ALIAS @@expect[2,3];
ok($r == 1);

{
    use warnings;
    # Special case of aliasing STDERR, which used
    # to dump core when warnings were enabled
    *STDERR = *$fh;
    @@expect = (PRINT => $ob,"some","text");
    $r = print STDERR @@expect[2,3];
    ok($r == 1);
}
@


1.1.1.4
log
@stock perl 5.8.0 from CPAN
@
text
@d80 1
a80 1
print "1..39\n";
d163 1
a163 1
    local *STDERR = *$fh;
a167 65

{
    # Test for change #11536
    package Foo;
    use strict;
    sub TIEHANDLE { bless {} }
    my $cnt = 'a';
    sub READ {
	$_[1] = $cnt++;
	1;
    }
    sub do_read {
	my $fh = shift;
	read $fh, my $buff, 1;
	main::ok(1);
    }
    $|=1;
    tie *STDIN, 'Foo';
    read STDIN, my $buff, 1;
    main::ok(1);
    do_read(\*STDIN);
    untie *STDIN;
}


{
    # test for change 11639: Can't localize *FH, then tie it
    {
	local *foo;
	tie %foo, 'Blah';
    }
    ok(!tied %foo);

    {
	local *bar;
	tie @@bar, 'Blah';
    }
    ok(!tied @@bar);

    {
	local *BAZ;
	tie *BAZ, 'Blah';
    }
    ok(!tied *BAZ);

    package Blah;

    sub TIEHANDLE {bless {}}
    sub TIEHASH   {bless {}}
    sub TIEARRAY  {bless {}}
}

{
    # warnings should pass to the PRINT method of tied STDERR
    my @@received;

    local *STDERR = *$fh;
    local *Implement::PRINT = sub { @@received = @@_ };

    $r = warn("some", "text", "\n");
    @@expect = (PRINT => $ob,"sometext\n");

    Implement::compare(PRINT => @@received);
}

@


1.1.1.5
log
@perl 5.8.2 from CPAN
@
text
@d1 1
a1 1
#!./perl -w
d11 1
d13 5
a17 2
require './test.pl';
plan(tests => 41);
d21 1
a21 1
    return ::fail() unless(@@_ == @@expect);
d23 2
a24 1
    for my $i (0..$#_) {
d26 1
a26 1
	return ::fail();
d29 1
a29 1
    ::pass();
a31 3

package Implement;

d33 1
a33 1
    ::compare(TIEHANDLE => @@_);
d39 1
a39 1
    ::compare(PRINT => @@_);
d44 1
a44 1
    ::compare(PRINTF => @@_);
d49 1
a49 1
    ::compare(READLINE => @@_);
d54 1
a54 1
    ::compare(GETC => @@_);
d59 1
a59 1
    ::compare(READ => @@_);
d65 1
a65 1
    ::compare(WRITE => @@_);
d71 1
a71 1
    ::compare(CLOSE => @@_);
d80 2
d86 2
a87 2
is(ref($ob),  'Implement');
is(tied(*$fh), $ob);
d91 1
a91 1
is($r, 1);
d95 1
a95 1
is($r, 2);
d100 1
a100 1
is($ln, $text);
d106 1
a106 1
compare(@@line);
d111 1
a111 1
is($ch, "a");
d117 2
a118 2
is($r, 3);
is($buf, "abc");
d125 2
a126 2
is($r, 3);
is($buf, "xyzabc");
d132 2
a133 2
is($r, 4);
is($data, "wert");
d139 2
a140 2
is($r, 4);
is($data, "qwer");
d146 2
a147 2
is($r, 6);
is($data, "qwerty");
d151 1
a151 1
is($r, 5);
d157 1
a157 1
is($r, 1);
d166 1
a166 1
    is($r, 1);
d182 1
a182 1
	::pass();
d187 1
a187 1
    ::pass();
a224 1
    no warnings 'redefine';
d230 1
a230 6
    compare(PRINT => @@received);

    use warnings;
    print undef;

    like($received[1], qr/Use of uninitialized value/);
a231 14

{
    # [ID 20020713.001] chomp($data=<tied_fh>)
    local *TEST;
    tie *TEST, 'CHOMP';
    my $data;
    chomp($data = <TEST>);
    is($data, 'foobar');

    package CHOMP;
    sub TIEHANDLE { bless {}, $_[0] }
    sub READLINE { "foobar\n" }
}

@


1.1.1.6
log
@import perl 5.10.1
@
text
@d13 1
a13 1
plan(tests => 50);
a15 2
    local $Level = $Level + 1;

a165 26
    package Bar::Say;
    use feature 'say';
    use base qw(Implement);

    my $ors;
    sub PRINT     {
        $ors = $\;
        my $self = shift;
        return $self->SUPER::PRINT(@@_);
    }

    my $fh = Symbol::gensym;
    @@expect = (TIEHANDLE => 'Bar::Say');
    ::ok( my $obj = tie *$fh, 'Bar::Say' );

    local $\ = 'something';
    @@expect = (PRINT => $obj, "stuff", "and", "things");
    ::ok( print $fh @@expect[2..4] );
    ::is( $ors, 'something' );
    
    ::ok( say $fh @@expect[2..4] );
    ::is( $ors, "\n",        'say sets $\ to \n in PRINT' );
    ::is( $\,   "something", "  and it's localized" );
}

{
d247 1
@


1.1.1.7
log
@Perl 5.12.2 from CPAN
@
text
@d13 1
a13 1
plan(tests => 63);
a63 5
sub EOF {
    ::compare(EOF => @@_);
    @@data ? '' : 1;
}

d72 1
d95 1
a95 5
@@data = ("the line\n");
@@expect = (EOF => $ob, 1);
is(eof($fh), '');

$text = $data[0];
a99 3
@@expect = (EOF => $ob, 0);
is(eof, 1);

a275 19
{
    # make sure the new eof() features work with @@ARGV magic
    local *ARGV;
    @@ARGV = ('haha');

    @@expect = (TIEHANDLE => 'Implement');
    $ob = tie *ARGV, 'Implement';
    is(ref($ob),  'Implement');
    is(tied(*ARGV), $ob);

    @@data = ("stuff\n");
    @@expect = (EOF => $ob, 1);
    is(eof(ARGV), '');
    @@expect = (EOF => $ob, 2);
    is(eof(), '');
    shift @@data;
    @@expect = (EOF => $ob, 0);
    is(eof, 1);
}
@


1.1.1.8
log
@Import perl-5.20.1
@
text
@d13 1
a13 1
plan(tests => 67);
a201 5

    local $\;
    ::ok( say $fh @@expect[2..4] );
    ::is( $ors, "\n",        'say sets $\ to \n in PRINT' );
    ::is( $\,   undef, "  and it's localized, even for undef \$\\" );
@


