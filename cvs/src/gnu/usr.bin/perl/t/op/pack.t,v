head	1.14;
access;
symbols
	OPENBSD_6_2:1.14.0.2
	OPENBSD_6_2_BASE:1.14
	PERL_5_24_2:1.1.1.13
	OPENBSD_6_1:1.14.0.4
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.13.0.12
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.6
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.13.0.8
	OPENBSD_5_8_BASE:1.13
	PERL_5_20_2:1.1.1.12
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	PERL_5_20_1:1.1.1.12
	OPENBSD_5_6:1.13.0.4
	OPENBSD_5_6_BASE:1.13
	PERL_5_18_2:1.1.1.12
	PERL:1.1.1
	OPENBSD_5_5:1.12.0.6
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.2
	OPENBSD_5_4_BASE:1.12
	PERL_5_16_3:1.1.1.11
	OPENBSD_5_3:1.11.0.10
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.8
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.6
	OPENBSD_5_0:1.11.0.4
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.2
	OPENBSD_4_9_BASE:1.11
	PERL_5_12_2:1.1.1.10
	OPENBSD_4_8:1.10.0.4
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.2
	OPENBSD_4_7_BASE:1.10
	PERL_5_10_1:1.1.1.9
	OPENBSD_4_6:1.9.0.6
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.2
	OPENBSD_4_5_BASE:1.9
	PERL_5_10_0:1.1.1.8
	OPENBSD_4_4:1.8.0.10
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.8
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.6
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.4
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.2
	OPENBSD_4_0_BASE:1.8
	PERL_5_8_8:1.1.1.7
	OPENBSD_3_9:1.7.0.10
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.8
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.6
	OPENBSD_3_7_BASE:1.7
	PERL_5_8_6:1.1.1.6
	OPENBSD_3_6:1.7.0.4
	OPENBSD_3_6_BASE:1.7
	PERL_5_8_5:1.1.1.6
	PERL_5_8_3:1.1.1.6
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.14
date	2017.02.05.00.32.20;	author afresh1;	state Exp;
branches;
next	1.13;
commitid	cxJ08BvJA9Pt2PTM;

1.13
date	2014.03.24.15.05.33;	author afresh1;	state Exp;
branches;
next	1.12;

1.12
date	2013.03.25.20.40.59;	author sthen;	state Exp;
branches;
next	1.11;

1.11
date	2010.09.24.15.07.08;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2009.10.12.18.30.27;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2008.09.29.17.36.19;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2006.03.28.19.23.12;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.49;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.37;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.36.20;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.08.28;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.52.36;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.08.05.32;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.13.20;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.13.20;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.41.47;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.10.50;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.25.43;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.15.10;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.44.32;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2006.03.28.18.49.45;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2008.09.29.17.19.01;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2009.10.12.18.10.44;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2010.09.24.14.49.18;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2013.03.25.20.09.36;	author sthen;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2014.03.24.14.59.10;	author afresh1;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2017.08.14.13.46.24;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.14
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl -w

BEGIN {
    chdir 't' if -d 't';
    require './test.pl'; require './charset_tools.pl';
    set_up_inc(qw '../lib ../dist/Math-BigInt/lib');
}

# This is truth in an if statement, and could be a skip message
my $no_endianness = $] > 5.009 ? '' :
  "Endianness pack modifiers not available on this perl";
my $no_signedness = $] > 5.009 ? '' :
  "Signed/unsigned pack modifiers not available on this perl";

plan tests => 14712;

use strict;
use warnings qw(FATAL all);
use Config;

my $Perl = which_perl();
my @@valid_errors = (qr/^Invalid type '\w'/);

my $ByteOrder = 'unknown';
my $maybe_not_avail = '(?:hto[bl]e|[bl]etoh)';
if ($no_endianness) {
  push @@valid_errors, qr/^Invalid type '[<>]'/;
} elsif ($Config{byteorder} =~ /^1234(?:5678)?$/) {
  $ByteOrder = 'little';
  $maybe_not_avail = '(?:htobe|betoh)';
}
elsif ($Config{byteorder} =~ /^(?:8765)?4321$/) {
  $ByteOrder = 'big';
  $maybe_not_avail = '(?:htole|letoh)';
}
else {
  push @@valid_errors, qr/^Can't (?:un)?pack (?:big|little)-endian .*? on this platform/;
}

if ($no_signedness) {
  push @@valid_errors, qr/^'!' allowed only after types sSiIlLxX in (?:un)?pack/;
}

for my $size ( 16, 32, 64 ) {
  if (defined $Config{"u${size}size"} and ($Config{"u${size}size"}||0) != ($size >> 3)) {
    push @@valid_errors, qr/^Perl_my_$maybe_not_avail$size\(\) not available/;
  }
}

my $IsTwosComplement = pack('i', -1) eq "\xFF" x $Config{intsize};
print "# \$IsTwosComplement = $IsTwosComplement\n";

sub is_valid_error
{
  my $err = shift;

  for my $e (@@valid_errors) {
    $err =~ $e and return 1;
  }

  return 0;
}

sub encode_list {
  my @@result = map {_qq($_)} @@_;
  if (@@result == 1) {
    return @@result;
  }
  return '(' . join (', ', @@result) . ')';
}


sub list_eq ($$) {
  my ($l, $r) = @@_;
  return 0 unless @@$l == @@$r;
  for my $i (0..$#$l) {
    if (defined $l->[$i]) {
      return 0 unless defined ($r->[$i]) && $l->[$i] eq $r->[$i];
    } else {
      return 0 if defined $r->[$i]
    }
  }
  return 1;
}

##############################################################################
#
# Here starteth the tests
#

{
    my $format = "c2 x5 C C x s d i l a6";
    # Need the expression in here to force ary[5] to be numeric.  This avoids
    # test2 failing because ary2 goes str->numeric->str and ary doesn't.
    my @@ary = (1,-100,127,128,32767,987.654321098 / 100.0,12345,123456,
               "abcdef");
    my $foo = pack($format,@@ary);
    my @@ary2 = unpack($format,$foo);

    is($#ary, $#ary2);

    my $out1=join(':',@@ary);
    my $out2=join(':',@@ary2);
    # Using long double NVs may introduce greater accuracy than wanted.
    $out1 =~ s/:9\.87654321097999\d*:/:9.87654321098:/;
    $out2 =~ s/:9\.87654321097999\d*:/:9.87654321098:/;
    is($out1, $out2);

    like($foo, qr/def/);
}
# How about counting bits?

{
    my $x;
    is( ($x = unpack("%32B*", "\001\002\004\010\020\040\100\200\377")), 16 );

    is( ($x = unpack("%32b69", "\001\002\004\010\020\040\100\200\017")), 12 );

    is( ($x = unpack("%32B69", "\001\002\004\010\020\040\100\200\017")), 9 );
}

{
    my $sum = 129; # ASCII
    $sum = 103 if $::IS_EBCDIC;

    my $x;
    is( ($x = unpack("%32B*", "Now is the time for all good blurfl")), $sum );

    my $foo;
    open(BIN, $Perl) || die "Can't open $Perl: $!\n";
    binmode BIN;
    sysread BIN, $foo, 8192;
    close BIN;

    $sum = unpack("%32b*", $foo);
    my $longway = unpack("b*", $foo);
    is( $sum, $longway =~ tr/1/1/ );
}

{
  my $x;
  is( ($x = unpack("I",pack("I", 0xFFFFFFFF))), 0xFFFFFFFF );
}

{
    # check 'w'
    my @@x = (5,130,256,560,32000,3097152,268435455,1073741844, 2**33,
             '4503599627365785','23728385234614992549757750638446');
    my $x = pack('w*', @@x);
    my $y = pack 'H*', '0581028200843081fa0081bd8440ffffff7f8480808014A0808'.
                       '0800087ffffffffffdb19caefe8e1eeeea0c2e1e3e8ede1ee6e';

    is($x, $y);

    my @@y = unpack('w*', $y);
    my $a;
    while ($a = pop @@x) {
        my $b = pop @@y;
        is($a, $b);
    }

    @@y = unpack('w2', $x);

    is(scalar(@@y), 2);
    is($y[1], 130);
    $x = pack('w*', 5000000000); $y = '';
    eval {
    use Math::BigInt;
    $y = pack('w*', Math::BigInt::->new(5000000000));
    };
    is($x, $y);

    $x = pack 'w', ~0;
    $y = pack 'w', (~0).'';
    is($x, $y);
    is(unpack ('w',$x), ~0);
    is(unpack ('w',$y), ~0);

    $x = pack 'w', ~0 - 1;
    $y = pack 'w', (~0) - 2;

    if (~0 - 1 == (~0) - 2) {
        is($x, $y, "NV arithmetic");
    } else {
        isnt($x, $y, "IV/NV arithmetic");
    }
    cmp_ok(unpack ('w',$x), '==', ~0 - 1);
    cmp_ok(unpack ('w',$y), '==', ~0 - 2);

    # These should spot that pack 'w' is using NV, not double, on platforms
    # where IVs are smaller than doubles, and harmlessly pass elsewhere.
    # (tests for change 16861)
    my $x0 = 2**54+3;
    my $y0 = 2**54-2;

    $x = pack 'w', $x0;
    $y = pack 'w', $y0;

    if ($x0 == $y0) {
        is($x, $y, "NV arithmetic");
    } else {
        isnt($x, $y, "IV/NV arithmetic");
    }
    cmp_ok(unpack ('w',$x), '==', $x0);
    cmp_ok(unpack ('w',$y), '==', $y0);
}


{
  print "# test exceptions\n";
  my $x;
  eval { $x = unpack 'w', pack 'C*', 0xff, 0xff};
  like($@@, qr/^Unterminated compressed integer/);

  eval { $x = unpack 'w', pack 'C*', 0xff, 0xff, 0xff, 0xff};
  like($@@, qr/^Unterminated compressed integer/);

  eval { $x = unpack 'w', pack 'C*', 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
  like($@@, qr/^Unterminated compressed integer/);

  eval { $x = pack 'w', -1 };
  like ($@@, qr/^Cannot compress negative numbers/);

  eval { $x = pack 'w', '1'x(1 + length ~0) . 'e0' };
  like ($@@, qr/^Can only compress unsigned integers/);

  # Check that the warning behaviour on the modifiers !, < and > is as we
  # expect it for this perl.
  my $can_endian = $no_endianness ? '' : 'sSiIlLqQjJfFdDpP';
  my $can_shriek = 'sSiIlL';
  $can_shriek .= 'nNvV' unless $no_signedness;
  # h and H can't do either, so act as sanity checks in blead
  foreach my $base (split '', 'hHsSiIlLqQjJfFdDpPnNvV') {
    foreach my $mod ('', '<', '>', '!', '<!', '>!', '!<', '!>') {
    SKIP: {
	# Avoid void context warnings.
	my $a = eval {pack "$base$mod"};
	skip "pack can't $base", 1 if $@@ =~ /^Invalid type '\w'/;
	# Which error you get when 2 would be possible seems to be emergent
	# behaviour of pack's format parser.

	my $fails_shriek = $mod =~ /!/ && index ($can_shriek, $base) == -1;
	my $fails_endian = $mod =~ /[<>]/ && index ($can_endian, $base) == -1;
	my $shriek_first = $mod =~ /^!/;

	if ($no_endianness and ($mod eq '<!' or $mod eq '>!')) {
	  # The ! isn't seem as part of $base. Instead it's seen as a modifier
	  # on > or <
	  $fails_shriek = 1;
	  undef $fails_endian;
	} elsif ($fails_shriek and $fails_endian) {
	  if ($shriek_first) {
	    undef $fails_endian;
	  }
	}

	if ($fails_endian) {
	  if ($no_endianness) {
	    # < and > are seen as pattern letters, not modifiers
	    like ($@@, qr/^Invalid type '[<>]'/, "pack can't $base$mod");
	  } else {
	    like ($@@, qr/^'[<>]' allowed only after types/,
		  "pack can't $base$mod");
	  }
	} elsif ($fails_shriek) {
	  like ($@@, qr/^'!' allowed only after types/,
		"pack can't $base$mod");
	} else {
	  is ($@@, '', "pack can $base$mod");
	}
      }
    }
  }

 SKIP: {
    skip $no_endianness, 2*3 + 2*8 if $no_endianness;
    for my $mod (qw( ! < > )) {
      eval { $x = pack "a$mod", 42 };
      like ($@@, qr/^'$mod' allowed only after types \S+ in pack/);

      eval { $x = unpack "a$mod", 'x'x8 };
      like ($@@, qr/^'$mod' allowed only after types \S+ in unpack/);
    }

    for my $mod (qw( <> >< !<> !>< <!> >!< <>! ><! )) {
      eval { $x = pack "sI${mod}s", 42, 47, 11 };
      like ($@@, qr/^Can't use both '<' and '>' after type 'I' in pack/);

      eval { $x = unpack "sI${mod}s", 'x'x16 };
      like ($@@, qr/^Can't use both '<' and '>' after type 'I' in unpack/);
    }
  }

 SKIP: {
    # Is this a stupid thing to do on VMS, VOS and other unusual platforms?

    skip("-- the IEEE infinity model is unavailable in this configuration.", 1)
       if (($^O eq 'VMS') && !defined($Config{useieee}));

    skip("-- $^O has serious fp indigestion on w-packed infinities", 1)
       if (
	   ($^O eq 'ultrix')
	   ||
	   ($^O =~ /^svr4/ && -f "/etc/issue" && -f "/etc/.relid") # NCR MP-RAS
	   );

    my $inf = eval '2**1000000';

    skip("Couldn't generate infinity - got error '$@@'", 1)
      unless defined $inf and $inf == $inf / 2 and $inf + 1 == $inf;

    local our $TODO;
    $TODO = "VOS needs a fix for posix-1022 to pass this test."
      if ($^O eq 'vos');

    eval { $x = pack 'w', $inf };
    like ($@@, qr/^Cannot compress Inf/, "Cannot compress infinity");
  }

 SKIP: {

    skip("-- the full range of an IEEE double may not be available in this configuration.", 3)
       if (($^O eq 'VMS') && !defined($Config{useieee}));

    skip("-- $^O does not like 2**1023", 3)
       if (($^O eq 'ultrix'));

    # This should be about the biggest thing possible on an IEEE double
    my $big = eval '2**1023';

    skip("Couldn't generate 2**1023 - got error '$@@'", 3)
      unless defined $big and $big != $big / 2;

    eval { $x = pack 'w', $big };
    is ($@@, '', "Should be able to pack 'w', $big # 2**1023");

    my $y = eval {unpack 'w', $x};
    is ($@@, '',
	"Should be able to unpack 'w' the result of pack 'w', $big # 2**1023");

    # I'm getting about 1e-16 on FreeBSD
    my $quotient = int (100 * ($y - $big) / $big);
    ok($quotient < 2 && $quotient > -2,
       "Round trip pack, unpack 'w' of $big is within 1% ($quotient%)");
  }

}

print "# test the 'p' template\n";

# literals
is(unpack("p",pack("p","foo")), "foo");
SKIP: {
  skip $no_endianness, 2 if $no_endianness;
  is(unpack("p<",pack("p<","foo")), "foo");
  is(unpack("p>",pack("p>","foo")), "foo");
}
# scalars
is(unpack("p",pack("p",239)), 239);
SKIP: {
  skip $no_endianness, 2 if $no_endianness;
  is(unpack("p<",pack("p<",239)), 239);
  is(unpack("p>",pack("p>",239)), 239);
}

# temps
sub foo { my $a = "a"; return $a . $a++ . $a++ }
{
  use warnings qw(NONFATAL all);;
  my $warning;
  local $SIG{__WARN__} = sub {
      $warning = $_[0];
  };
  my $junk = pack("p", &foo);

  like($warning, qr/temporary val/);
}

# undef should give null pointer
like(pack("p", undef), qr/^\0+$/);
SKIP: {
  skip $no_endianness, 2 if $no_endianness;
  like(pack("p<", undef), qr/^\0+$/);
  like(pack("p>", undef), qr/^\0+$/);
}

# Check for optimizer bug (e.g.  Digital Unix GEM cc with -O4 on DU V4.0B gives
#                                4294967295 instead of -1)
#				 see #ifdef __osf__ in pp.c pp_unpack
is((unpack("i",pack("i",-1))), -1);

print "# test the pack lengths of s S i I l L n N v V + modifiers\n";

my @@lengths = (
  qw(s 2 S 2 i -4 I -4 l 4 L 4 n 2 N 4 v 2 V 4 n! 2 N! 4 v! 2 V! 4),
  's!'  => $Config{shortsize}, 'S!'  => $Config{shortsize},
  'i!'  => $Config{intsize},   'I!'  => $Config{intsize},
  'l!'  => $Config{longsize},  'L!'  => $Config{longsize},
);

while (my ($base, $expect) = splice @@lengths, 0, 2) {
  my @@formats = ($base);
  $base =~ /^[nv]/i or push @@formats, "$base>", "$base<";
  for my $format (@@formats) {
  SKIP: {
      skip $no_endianness, 1 if $no_endianness && $format =~ m/[<>]/;
      skip $no_signedness, 1 if $no_signedness && $format =~ /[nNvV]!/;
      my $len = length(pack($format, 0));
      if ($expect > 0) {
	is($expect, $len, "format '$format'");
      } else {
	$expect = -$expect;
	ok ($len >= $expect, "format '$format'") ||
	  print "# format '$format' has length $len, expected >= $expect\n";
      }
    }
  }
}


print "# test unpack-pack lengths\n";

my @@templates = qw(c C W i I s S l L n N v V f d q Q);

foreach my $base (@@templates) {
    my @@tmpl = ($base);
    $base =~ /^[cwnv]/i or push @@tmpl, "$base>", "$base<";
    foreach my $t (@@tmpl) {
        SKIP: {
            my @@t = eval { unpack("$t*", pack("$t*", 12, 34)) };

            skip "cannot pack '$t' on this perl", 4
              if is_valid_error($@@);

            is( $@@, '', "Template $t works");
            is(scalar @@t, 2);

            is($t[0], 12);
            is($t[1], 34);
        }
    }
}

{
    # uuencode/decode

    # Note that first uuencoding known 'text' data and then checking the
    # binary values of the uuencoded version would not be portable between
    # character sets.  Uuencoding is meant for encoding binary data, not
    # text data.

    my $in = pack 'C*', 0 .. 255;

    # just to be anal, we do some random tr/`/ /
    my $uu = <<'EOUU';
M` $"`P0%!@@<("0H+# T.#Q`1$A,4%187&!D:&QP='A\@@(2(C)"4F)R@@I*BLL
M+2XO,#$R,S0U-C<X.3H[/#T^/T!!0D-$149'2$E*2TQ-3D]045)35%565UA9
M6EM<75Y?8&%B8V1E9F=H:6IK;&UN;W!Q<G-T=79W>'EZ>WQ]?G^`@@8*#A(6&
MAXB)BHN,C8Z/D)&2DY25EI>8F9J;G)V>GZ"AHJ.DI::GJ*FJJZRMKJ^PL;*S
MM+6VM[BYNKN\O;Z_P,'"P\3%QL?(R<K+S,W.S]#1TM/4U=;7V-G:V]S=WM_@@
?X>+CY.7FY^CIZNOL[>[O\/'R\_3U]O?X^?K[_/W^_P `
EOUU

    $_ = $uu;
    tr/ /`/;

    is(pack('u', $in), $_);

    is(unpack('u', $uu), $in);

    $in = "\x1f\x8b\x08\x08\x58\xdc\xc4\x35\x02\x03\x4a\x41\x50\x55\x00\xf3\x2a\x2d\x2e\x51\x48\xcc\xcb\x2f\xc9\x48\x2d\x52\x08\x48\x2d\xca\x51\x28\x2d\x4d\xce\x4f\x49\x2d\xe2\x02\x00\x64\x66\x60\x5c\x1a\x00\x00\x00";
    $uu = <<'EOUU';
M'XL("%C<Q#4"`TI!4%4`\RHM+E%(S,LOR4@@M4@@A(+<I1*"U-SD])+>("`&1F
&8%P:````
EOUU

    is(unpack('u', $uu), $in);

# This is identical to the above except that backquotes have been
# changed to spaces

    $uu = <<'EOUU';
M'XL("%C<Q#4" TI!4%4 \RHM+E%(S,LOR4@@M4@@A(+<I1*"U-SD])+>(" &1F
&8%P:
EOUU

    # ' # Grr
    is(unpack('u', $uu), $in);

}

# test the ascii template types (A, a, Z)

foreach (
['p', 'A*',  "foo\0bar\0 ", "foo\0bar\0 "],
['p', 'A11', "foo\0bar\0 ", "foo\0bar\0   "],
['u', 'A*',  "foo\0bar \0", "foo\0bar"],
['u', 'A8',  "foo\0bar \0", "foo\0bar"],
['p', 'a*',  "foo\0bar\0 ", "foo\0bar\0 "],
['p', 'a11', "foo\0bar\0 ", "foo\0bar\0 \0\0"],
['u', 'a*',  "foo\0bar \0", "foo\0bar \0"],
['u', 'a8',  "foo\0bar \0", "foo\0bar "],
['p', 'Z*',  "foo\0bar\0 ", "foo\0bar\0 \0"],
['p', 'Z11', "foo\0bar\0 ", "foo\0bar\0 \0\0"],
['p', 'Z3',  "foo",         "fo\0"],
['u', 'Z*',  "foo\0bar \0", "foo"],
['u', 'Z8',  "foo\0bar \0", "foo"],
)
{
    my ($what, $template, $in, $out) = @@$_;
    my $got = $what eq 'u' ? (unpack $template, $in) : (pack $template, $in);
    unless (is($got, $out)) {
        my $un = $what eq 'u' ? 'un' : '';
        print "# ${un}pack ('$template', "._qq($in).') gave '._qq($out).
            ' not '._qq($got)."\n";
    }
}

print "# packing native shorts/ints/longs\n";

is(length(pack("s!", 0)), $Config{shortsize});
is(length(pack("i!", 0)), $Config{intsize});
is(length(pack("l!", 0)), $Config{longsize});
ok(length(pack("s!", 0)) <= length(pack("i!", 0)));
ok(length(pack("i!", 0)) <= length(pack("l!", 0)));
is(length(pack("i!", 0)), length(pack("i", 0)));

sub numbers {
  my $base = shift;
  my @@formats = ($base);
  $base =~ /^[silqjfdp]/i and push @@formats, "$base>", "$base<";
  for my $format (@@formats) {
    numbers_with_total ($format, undef, @@_);
  }
}

sub numbers_with_total {
  my $format = shift;
  my $total = shift;
  if (!defined $total) {
    foreach (@@_) {
      $total += $_;
    }
  }
  print "# numbers test for $format\n";
  foreach (@@_) {
    SKIP: {
        my $out = eval {unpack($format, pack($format, $_))};
        skip "cannot pack '$format' on this perl", 2
          if is_valid_error($@@);

        is($@@, '', "no error");
        is($out, $_, "unpack pack $format $_");
    }
  }

  my $skip_if_longer_than = ~0; # "Infinity"
  if (~0 - 1 == ~0) {
    # If we're running with -DNO_PERLPRESERVE_IVUV and NVs don't preserve all
    # UVs (in which case ~0 is NV, ~0-1 will be the same NV) then we can't
    # correctly in perl calculate UV totals for long checksums, as pp_unpack
    # is using UV maths, and we've only got NVs.
    $skip_if_longer_than = $Config{nv_preserves_uv_bits};
  }

  foreach ('', 1, 2, 3, 15, 16, 17, 31, 32, 33, 53, 54, 63, 64, 65) {
    SKIP: {
      my $sum = eval {unpack "%$_$format*", pack "$format*", @@_};
      skip "cannot pack '$format' on this perl", 3
        if is_valid_error($@@);

      is($@@, '', "no error");
      ok(defined $sum, "sum bits $_, format $format defined");

      my $len = $_; # Copy, so that we can reassign ''
      $len = 16 unless length $len;

      SKIP: {
        skip "cannot test checksums over $skip_if_longer_than bits", 1
          if $len > $skip_if_longer_than;

        # Our problem with testing this portably is that the checksum code in
        # pp_unpack is able to cast signed to unsigned, and do modulo 2**n
        # arithmetic in unsigned ints, which perl has no operators to do.
        # (use integer; does signed ints, which won't wrap on UTS, which is just
        # fine with ANSI, but not with most people's assumptions.
        # This is why we need to supply the totals for 'Q' as there's no way in
        # perl to calculate them, short of unpack '%0Q' (is that documented?)
        # ** returns NVs; make sure it's IV.
        my $max = 1 + 2 * (int (2 ** ($len-1))-1); # The max possible checksum
        my $max_p1 = $max + 1;
        my ($max_is_integer, $max_p1_is_integer);
        $max_p1_is_integer = 1 unless $max_p1 + 1 == $max_p1;
        $max_is_integer = 1 if $max - 1 < ~0;

        my $calc_sum;
        if (ref $total) {
            $calc_sum = &$total($len);
        } else {
            $calc_sum = $total;
            # Shift into range by some multiple of the total
            my $mult = $max_p1 ? int ($total / $max_p1) : undef;
            # Need this to make sure that -1 + (~0+1) is ~0 (ie still integer)
            $calc_sum = $total - $mult;
            $calc_sum -= $mult * $max;
            if ($calc_sum < 0) {
                $calc_sum += 1;
                $calc_sum += $max;
            }
        }
        if ($calc_sum == $calc_sum - 1 && $calc_sum == $max_p1) {
            # we're into floating point (either by getting out of the range of
            # UV arithmetic, or because we're doing a floating point checksum)
            # and our calculation of the checksum has become rounded up to
            # max_checksum + 1
            $calc_sum = 0;
        }

        if ($calc_sum == $sum) { # HAS to be ==, not eq (so no is()).
            pass ("unpack '%$_$format' gave $sum");
        } else {
            my $delta = 1.000001;
            if ($format =~ tr /dDfF//
                && ($calc_sum <= $sum * $delta && $calc_sum >= $sum / $delta)) {
                pass ("unpack '%$_$format' gave $sum, expected $calc_sum");
            } else {
                my $text = ref $total ? &$total($len) : $total;
                fail;
                print "# For list (" . join (", ", @@_) . ") (total $text)"
                    . " packed with $format unpack '%$_$format' gave $sum,"
                    . " expected $calc_sum\n";
            }
        }
      }
    }
  }
}

numbers ('c', -128, -1, 0, 1, 127);
numbers ('C', 0, 1, 127, 128, 255);
numbers ('W', 0, 1, 127, 128, 255, 256, 0x7ff, 0x800, 0xfffd);
numbers ('s', -32768, -1, 0, 1, 32767);
numbers ('S', 0, 1, 32767, 32768, 65535);
numbers ('i', -2147483648, -1, 0, 1, 2147483647);
numbers ('I', 0, 1, 2147483647, 2147483648, 4294967295);
numbers ('l', -2147483648, -1, 0, 1, 2147483647);
numbers ('L', 0, 1, 2147483647, 2147483648, 4294967295);
numbers ('s!', -32768, -1, 0, 1, 32767);
numbers ('S!', 0, 1, 32767, 32768, 65535);
numbers ('i!', -2147483648, -1, 0, 1, 2147483647);
numbers ('I!', 0, 1, 2147483647, 2147483648, 4294967295);
numbers ('l!', -2147483648, -1, 0, 1, 2147483647);
numbers ('L!', 0, 1, 2147483647, 2147483648, 4294967295);
numbers ('n', 0, 1, 32767, 32768, 65535);
numbers ('v', 0, 1, 32767, 32768, 65535);
numbers ('N', 0, 1, 2147483647, 2147483648, 4294967295);
numbers ('V', 0, 1, 2147483647, 2147483648, 4294967295);
numbers ('n!', -32768, -1, 0, 1, 32767);
numbers ('v!', -32768, -1, 0, 1, 32767);
numbers ('N!', -2147483648, -1, 0, 1, 2147483647);
numbers ('V!', -2147483648, -1, 0, 1, 2147483647);
# All these should have exact binary representations:
numbers ('f', -1, 0, 0.5, 42, 2**34);
numbers ('d', -(2**34), -1, 0, 1, 2**34);
## These don't, but 'd' is NV.  XXX wrong, it's double
#numbers ('d', -1, 0, 1, 1-exp(-1), -exp(1));

numbers_with_total ('q', -1,
                    -9223372036854775808, -1, 0, 1,9223372036854775807);
# This total is icky, but the true total is 2**65-1, and need a way to generate
# the expected checksum on any system including those where NVs can preserve
# 65 bits. (long double is 128 bits on sparc, so they certainly can)
# or where rounding is down not up on binary conversion (crays)
numbers_with_total ('Q', sub {
                      my $len = shift;
                      $len = 65 if $len > 65; # unmasked total is 2**65-1 here
                      my $total = 1 + 2 * (int (2**($len - 1)) - 1);
                      return 0 if $total == $total - 1; # Overflowed integers
                      return $total; # NVs still accurate to nearest integer
                    },
                    0, 1,9223372036854775807, 9223372036854775808,
                    18446744073709551615);

print "# pack nvNV byteorders\n";

is(pack("n", 0xdead), "\xde\xad");
is(pack("v", 0xdead), "\xad\xde");
is(pack("N", 0xdeadbeef), "\xde\xad\xbe\xef");
is(pack("V", 0xdeadbeef), "\xef\xbe\xad\xde");

SKIP: {
  skip $no_signedness, 4 if $no_signedness;
  is(pack("n!", 0xdead), "\xde\xad");
  is(pack("v!", 0xdead), "\xad\xde");
  is(pack("N!", 0xdeadbeef), "\xde\xad\xbe\xef");
  is(pack("V!", 0xdeadbeef), "\xef\xbe\xad\xde");
}

print "# test big-/little-endian conversion\n";

sub byteorder
{
  my $format = shift;
  print "# byteorder test for $format\n";
  for my $value (@@_) {
    SKIP: {
      my($nat,$be,$le) = eval { map { pack $format.$_, $value } '', '>', '<' };
      skip "cannot pack '$format' on this perl", 5
        if is_valid_error($@@);

      {
        use warnings qw(NONFATAL utf8);
        print "# [$value][$nat][$be][$le][$@@]\n";
      }

      SKIP: {
        skip "cannot compare native byteorder with big-/little-endian", 1
            if $ByteOrder eq 'unknown';

        is($nat, $ByteOrder eq 'big' ? $be : $le);
      }
      is($be, reverse($le));
      my @@x = eval { unpack "$format$format>$format<", $nat.$be.$le };

      print "# [$value][", join('][', @@x), "][$@@]\n";

      is($@@, '');
      is($x[0], $x[1]);
      is($x[0], $x[2]);
    }
  }
}

byteorder('s', -32768, -1, 0, 1, 32767);
byteorder('S', 0, 1, 32767, 32768, 65535);
byteorder('i', -2147483648, -1, 0, 1, 2147483647);
byteorder('I', 0, 1, 2147483647, 2147483648, 4294967295);
byteorder('l', -2147483648, -1, 0, 1, 2147483647);
byteorder('L', 0, 1, 2147483647, 2147483648, 4294967295);
byteorder('j', -2147483648, -1, 0, 1, 2147483647);
byteorder('J', 0, 1, 2147483647, 2147483648, 4294967295);
byteorder('s!', -32768, -1, 0, 1, 32767);
byteorder('S!', 0, 1, 32767, 32768, 65535);
byteorder('i!', -2147483648, -1, 0, 1, 2147483647);
byteorder('I!', 0, 1, 2147483647, 2147483648, 4294967295);
byteorder('l!', -2147483648, -1, 0, 1, 2147483647);
byteorder('L!', 0, 1, 2147483647, 2147483648, 4294967295);
byteorder('q', -9223372036854775808, -1, 0, 1, 9223372036854775807);
byteorder('Q', 0, 1, 9223372036854775807, 9223372036854775808, 18446744073709551615);
byteorder('f', -1, 0, 0.5, 42, 2**34);
byteorder('F', -1, 0, 0.5, 42, 2**34);
byteorder('d', -(2**34), -1, 0, 1, 2**34);
byteorder('D', -(2**34), -1, 0, 1, 2**34);

print "# test negative numbers\n";

SKIP: {
  skip "platform is not using two's complement for negative integers", 120
    unless $IsTwosComplement;

  for my $format (qw(s i l j s! i! l! q)) {
    SKIP: {
      my($nat,$be,$le) = eval { map { pack $format.$_, -1 } '', '>', '<' };
      skip "cannot pack '$format' on this perl", 15
        if is_valid_error($@@);

      my $len = length $nat;
      is($_, "\xFF"x$len) for $nat, $be, $le;

      my(@@val,@@ref);
      if ($len >= 8) {
        @@val = (-2, -81985529216486896, -9223372036854775808);
        @@ref = ("\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFE",
                "\xFE\xDC\xBA\x98\x76\x54\x32\x10",
                "\x80\x00\x00\x00\x00\x00\x00\x00");
      }
      elsif ($len >= 4) {
        @@val = (-2, -19088744, -2147483648);
        @@ref = ("\xFF\xFF\xFF\xFE",
                "\xFE\xDC\xBA\x98",
                "\x80\x00\x00\x00");
      }
      else {
        @@val = (-2, -292, -32768);
        @@ref = ("\xFF\xFE",
                "\xFE\xDC",
                "\x80\x00");
      }
      for my $x (@@ref) {
        if ($len > length $x) {
          $x = $x . "\xFF" x ($len - length $x);
        }
      }

      for my $i (0 .. $#val) {
        my($nat,$be,$le) = eval { map { pack $format.$_, $val[$i] } '', '>', '<' };
        is($@@, '');

        SKIP: {
          skip "cannot compare native byteorder with big-/little-endian", 1
              if $ByteOrder eq 'unknown';

          is($nat, $ByteOrder eq 'big' ? $be : $le);
        }

        is($be, $ref[$i]);
        is($be, reverse($le));
      }
    }
  }
}

{
  # /

  my ($x, $y, $z, @@a);
  eval { ($x) = unpack '/a*','hello' };
  like($@@, qr!'/' must follow a numeric type!);
  undef $x;
  eval { $x = unpack '/a*','hello' };
  like($@@, qr!'/' must follow a numeric type!);

  # [perl #60204] Unhelpful error message from unpack
  eval { @@a = unpack 'v/a*','h' };
  is($@@, '');
  is(scalar @@a, 0);
  eval { $x = unpack 'v/a*','h' };
  is($@@, '');
  is($x, undef);

  undef $x;
  eval { ($z,$x,$y) = unpack 'a3/A C/a* C/Z', "003ok \003yes\004z\000abc" };
  is($@@, '');
  is($z, 'ok');
  is($x, 'yes');
  is($y, 'z');
  undef $z;
  eval { $z = unpack 'a3/A C/a* C/Z', "003ok \003yes\004z\000abc" };
  is($@@, '');
  is($z, 'ok');


  undef $x;
  eval { ($x) = pack '/a*','hello' };
  like($@@,  qr!Invalid type '/'!);
  undef $x;
  eval { $x = pack '/a*','hello' };
  like($@@,  qr!Invalid type '/'!);

  $z = pack 'n/a* N/Z* w/A*','string','hi there ','etc';
  my $expect = "\000\006string\0\0\0\012hi there \000\003etc";
  is($z, $expect);

  undef $x;
  $expect = 'hello world';
  eval { ($x) = unpack ("w/a", chr (11) . "hello world!")};
  is($x, $expect);
  is($@@, '');

  undef $x;
  # Doing this in scalar context used to fail.
  eval { $x = unpack ("w/a", chr (11) . "hello world!")};
  is($@@, '');
  is($x, $expect);

  foreach (
           ['a/a*/a*', '212ab345678901234567','ab3456789012'],
           ['a/a*/a*', '3012ab345678901234567', 'ab3456789012'],
           ['a/a*/b*', '212ab', $::IS_EBCDIC ? '100000010100' : '100001100100'],
  )
  {
    my ($pat, $in, $expect) = @@$_;
    undef $x;
    eval { ($x) = unpack $pat, $in };
    is($@@, '');
    is($x, $expect) ||
      printf "# list unpack ('$pat', '$in') gave %s, expected '$expect'\n",
             encode_list ($x);

    undef $x;
    eval { $x = unpack $pat, $in };
    is($@@, '');
    is($x, $expect) ||
      printf "# scalar unpack ('$pat', '$in') gave %s, expected '$expect'\n",
             encode_list ($x);
  }

  # / with #

  my $pattern = <<'EOU';
 a3/A			# Count in ASCII
 C/a*			# Count in a C char
 C/Z			# Count in a C char but skip after \0
EOU

  $x = $y = $z =undef;
  eval { ($z,$x,$y) = unpack $pattern, "003ok \003yes\004z\000abc" };
  is($@@, '');
  is($z, 'ok');
  is($x, 'yes');
  is($y, 'z');
  undef $x;
  eval { $z = unpack $pattern, "003ok \003yes\004z\000abc" };
  is($@@, '');
  is($z, 'ok');

  $pattern = <<'EOP';
  n/a*			# Count as network short
  w/A*			# Count a  BER integer
EOP
  $expect = "\000\006string\003etc";
  $z = pack $pattern,'string','etc';
  is($z, $expect);
}


{
    is("1.20.300.4000", sprintf "%vd", pack("U*",utf8::native_to_unicode(1),utf8::native_to_unicode(20),300,4000));
    is("1.20.300.4000", sprintf "%vd", pack("  U*",utf8::native_to_unicode(1),utf8::native_to_unicode(20),300,4000));
}
isnt(v1.20.300.4000, sprintf "%vd", pack("C0U*",utf8::native_to_unicode(1),utf8::native_to_unicode(20),300,4000));

my $rslt = join " ", map { ord } split "", byte_utf8a_to_utf8n("\xc7\xa2");
# The ASCII UTF-8 of U+1E2 is "\xc7\xa2"
is(join(" ", unpack("U0 C*", chr(0x1e2))), $rslt);

# does pack U create Unicode?
is(ord(pack('U', 300)), 300);

# does unpack U deref Unicode?
is((unpack('U', chr(300)))[0], 300);

# is unpack U the reverse of pack U for Unicode string?
is("@@{[unpack('U*', pack('U*', 100, 200, 300))]}", "100 200 300");

# is unpack U the reverse of pack U for byte string?
is("@@{[unpack('U*', pack('U*', 100, 200))]}", "100 200");

{
    # does pack U0C create Unicode?
    my $cp202 = chr(202);
    utf8::upgrade $cp202;
    my @@bytes202;
    {   # This is portable across character sets
        use bytes;
        @@bytes202 = map { ord } split "", $cp202;
    }

    # This test requires the first number to be invariant; 64 is invariant on
    # ASCII and EBCDIC.
    is("@@{[pack('U0C*', 64, @@bytes202)]}", v64.v202);

    # does pack C0U create characters?
    # The U* is expecting Unicode, so convert to that.
    is("@@{[pack('C0U*', map { utf8::native_to_unicode($_) } 64, 202)]}",
       pack("C*", 64, @@bytes202));

    # does unpack U0U on byte data warn?
    {
	use warnings qw(NONFATAL all);;

        my $bad = pack("U0C", 202);
        local $SIG{__WARN__} = sub { $@@ = "@@_" };
        my @@null = unpack('U0U', $bad);
        like($@@, qr/^Malformed UTF-8 character /);
    }
}

{
  my $p = pack 'i*', -2147483648, ~0, 0, 1, 2147483647;
  my (@@a);
  # bug - % had to be at the start of the pattern, no leading whitespace or
  # comments. %i! didn't work at all.
  foreach my $pat ('%32i*', ' %32i*', "# Muhahahaha\n%32i*", '%32i*  ',
                   '%32i!*', ' %32i!*', "\n#\n#\n\r \t\f%32i!*", '%32i!*#') {
    @@a = unpack $pat, $p;
    is($a[0], 0xFFFFFFFF) || print "# $pat\n";
    @@a = scalar unpack $pat, $p;
    is($a[0], 0xFFFFFFFF) || print "# $pat\n";
  }


  $p = pack 'I*', 42, 12;
  # Multiline patterns in scalar context failed.
  foreach my $pat ('I', <<EOPOEMSNIPPET, 'I#I', 'I # I', 'I # !!!') {
# On the Ning Nang Nong
# Where the Cows go Bong!
# And the Monkeys all say Boo!
I
EOPOEMSNIPPET
    @@a = unpack $pat, $p;
    is(scalar @@a, 1);
    is($a[0], 42);
    @@a = scalar unpack $pat, $p;
    is(scalar @@a, 1);
    is($a[0], 42);
  }

  # shorts (of all flavours) didn't calculate checksums > 32 bits with floating
  # point, so a pathologically long pattern would wrap at 32 bits.
  my $pat = "\xff\xff"x65538; # Start with it long, to save any copying.
  foreach (4,3,2,1,0) {
    my $len = 65534 + $_;
    is(unpack ("%33n$len", $pat), 65535 * $len);
  }
}


# pack x X @@
foreach (
         ['x', "N", "\0"],
         ['x4', "N", "\0"x4],
         ['xX', "N", ""],
         ['xXa*', "Nick", "Nick"],
         ['a5Xa5', "cameL", "llama", "camellama"],
         ['@@4', 'N', "\0"x4],
         ['a*@@8a*', 'Camel', 'Dromedary', "Camel\0\0\0Dromedary"],
         ['a*@@4a', 'Perl rules', '!', 'Perl!'],
)
{
  my ($template, @@in) = @@$_;
  my $out = pop @@in;
  my $got = eval {pack $template, @@in};
  is($@@, '');
  is($out, $got) ||
    printf "# pack ('$template', %s) gave %s expected %s\n",
           encode_list (@@in), encode_list ($got), encode_list ($out);
}

# unpack x X @@
foreach (
         ['x', "N"],
         ['xX', "N"],
         ['xXa*', "Nick", "Nick"],
         ['a5Xa5', "camellama", "camel", "llama"],
         ['@@3', "ice"],
         ['@@2a2', "water", "te"],
         ['a*@@1a3', "steam", "steam", "tea"],
)
{
  my ($template, $in, @@out) = @@$_;
  my @@got = eval {unpack $template, $in};
  is($@@, '');
  ok (list_eq (\@@got, \@@out)) ||
    printf "# list unpack ('$template', %s) gave %s expected %s\n",
           _qq($in), encode_list (@@got), encode_list (@@out);

  my $got = eval {unpack $template, $in};
  is($@@, '');
  @@out ? is( $got, $out[0] ) # 1 or more items; should get first
       : ok( !defined $got ) # 0 items; should get undef
    or printf "# scalar unpack ('$template', %s) gave %s expected %s\n",
              _qq($in), encode_list ($got), encode_list ($out[0]);
}

{
    my $t = 'Z*Z*';
    my ($u, $v) = qw(foo xyzzy);
    my $p = pack($t, $u, $v);
    my @@u = unpack($t, $p);
    is(scalar @@u, 2);
    is($u[0], $u);
    is($u[1], $v);
}

{
    is((unpack("w/a*", "\x02abc"))[0], "ab");

    # "w/a*" should be seen as one unit

    is(scalar unpack("w/a*", "\x02abc"), "ab");
}

SKIP: {
  print "# group modifiers\n";

  skip $no_endianness, 3 * 2 + 3 * 2 + 1 if $no_endianness;

  for my $t (qw{ (s<)< (sl>s)> (s(l(sl)<l)s)< }) {
    print "# testing pattern '$t'\n";
    eval { ($_) = unpack($t, 'x'x18); };
    is($@@, '');
    eval { $_ = pack($t, (0)x6); };
    is($@@, '');
  }

  for my $t (qw{ (s<)> (sl>s)< (s(l(sl)<l)s)> }) {
    print "# testing pattern '$t'\n";
    eval { ($_) = unpack($t, 'x'x18); };
    like($@@, qr/Can't use '[<>]' in a group with different byte-order in unpack/);
    eval { $_ = pack($t, (0)x6); };
    like($@@, qr/Can't use '[<>]' in a group with different byte-order in pack/);
  }

  is(pack('L<L>', (0x12345678)x2),
     pack('(((L1)1)<)(((L)1)1)>1', (0x12345678)x2));
}

{
  sub compress_template {
    my $t = shift;
    for my $mod (qw( < > )) {
      $t =~ s/((?:(?:[SILQJFDP]!?$mod|[^SILQJFDP\W]!?)(?:\d+|\*|\[(?:[^]]+)\])?\/?){2,})/
              my $x = $1; $x =~ s!$mod!!g ? "($x)$mod" : $x /ieg;
    }
    return $t;
  }

  my %templates = (
    's<'                  => [-42],
    's<c2x![S]S<'         => [-42, -11, 12, 4711],
    '(i<j<[s]l<)3'        => [-11, -22, -33, 1000000, 1100, 2201, 3302,
                              -1000000, 32767, -32768, 1, -123456789 ],
    '(I!<4(J<2L<)3)5'     => [1 .. 65],
    'q<Q<'                => [-50000000005, 60000000006],
    'f<F<d<'              => [3.14159, 111.11, 2222.22],
    'D<cCD<'              => [1e42, -128, 255, 1e-42],
    'n/a*'                => ['/usr/bin/perl'],
    'C/a*S</A*L</Z*I</a*' => [qw(Just another Perl hacker)],
  );

  for my $tle (sort keys %templates) {
    my @@d = @@{$templates{$tle}};
    my $tbe = $tle;
    $tbe =~ y/</>/;
    for my $t ($tbe, $tle) {
      my $c = compress_template($t);
      print "# '$t' -> '$c'\n";
      SKIP: {
        my $p1 = eval { pack $t, @@d };
        skip "cannot pack '$t' on this perl", 5 if is_valid_error($@@);
        my $p2 = eval { pack $c, @@d };
        is($@@, '');
        is($p1, $p2);
        s!(/[aAZ])\*!$1!g for $t, $c;
        my @@u1 = eval { unpack $t, $p1 };
        is($@@, '');
        my @@u2 = eval { unpack $c, $p2 };
        is($@@, '');
        is(join('!', @@u1), join('!', @@u2));
      }
    }
  }
}

{
    # from Wolfgang Laun: fix in change #13163

    my $s = 'ABC' x 10;
    my $t = '*';
    my $x = ord($t);
    my $buf = pack( 'Z*/A* C',  $s, $x );
    my $y;

    my $h = $buf;
    $h =~ s/[^[:print:]]/./g;
    ( $s, $y ) = unpack( "Z*/A* C", $buf );
    is($h, "30.ABCABCABCABCABCABCABCABCABCABC$t");
    is(length $buf, 34);
    is($s, "ABCABCABCABCABCABCABCABCABCABC");
    is($y, $x);
}

{
    # from Wolfgang Laun: fix in change #13288

    eval { my $t=unpack("P*", "abc") };
    like($@@, qr/'P' must have an explicit size/);
}

{   # Grouping constructs
    my (@@a, @@b);
    @@a = unpack '(SL)',   pack 'SLSLSL', 67..90;
    is("@@a", "67 68");
    @@a = unpack '(SL)3',   pack 'SLSLSL', 67..90;
    @@b = (67..72);
    is("@@a", "@@b");
    @@a = unpack '(SL)3',   pack 'SLSLSLSL', 67..90;
    is("@@a", "@@b");
    @@a = unpack '(SL)[3]', pack 'SLSLSLSL', 67..90;
    is("@@a", "@@b");
    @@a = unpack '(SL)[2] SL', pack 'SLSLSLSL', 67..90;
    is("@@a", "@@b");
    @@a = unpack 'A/(SL)',  pack 'ASLSLSLSL', 3, 67..90;
    is("@@a", "@@b");
    @@a = unpack 'A/(SL)SL',  pack 'ASLSLSLSL', 2, 67..90;
    is("@@a", "@@b");
    @@a = unpack '(SL)*',   pack 'SLSLSLSL', 67..90;
    @@b = (67..74);
    is("@@a", "@@b");
    @@a = unpack '(SL)*SL',   pack 'SLSLSLSL', 67..90;
    is("@@a", "@@b");
    eval { @@a = unpack '(*SL)',   '' };
    like($@@, qr/\(\)-group starts with a count/);
    eval { @@a = unpack '(3SL)',   '' };
    like($@@, qr/\(\)-group starts with a count/);
    eval { @@a = unpack '([3]SL)',   '' };
    like($@@, qr/\(\)-group starts with a count/);
    eval { @@a = pack '(*SL)' };
    like($@@, qr/\(\)-group starts with a count/);
    @@a = unpack '(SL)3 SL',   pack '(SL)4', 67..74;
    is("@@a", "@@b");
    @@a = unpack '(SL)3 SL',   pack '(SL)[4]', 67..74;
    is("@@a", "@@b");
    @@a = unpack '(SL)3 SL',   pack '(SL)*', 67..74;
    is("@@a", "@@b");
}

{  # more on grouping (W.Laun)
  # @@ absolute within ()-group
  my $badc = pack( '(a)*', unpack( '(@@1a @@0a @@2)*', 'abcd' ) );
  is( $badc, 'badc' );
  my @@b = ( 1, 2, 3 );
  my $buf = pack( '(@@1c)((@@2C)@@3c)', @@b );
  is( $buf, "\0\1\0\0\2\3" );
  my @@a = unpack( '(@@1c)((@@2c)@@3c)', $buf );
  is( "@@a", "@@b" );

  # various unpack count/code scenarios
  my @@Env = ( a => 'AAA', b => 'BBB' );
  my $env = pack( 'S(S/A*S/A*)*', @@Env/2, @@Env );

  # unpack full length - ok
  my @@pup = unpack( 'S/(S/A* S/A*)', $env );
  is( "@@pup", "@@Env" );

  # warn when count/code goes beyond end of string
  # \0002 \0001 a \0003 AAA \0001 b \0003 BBB
  #     2     4 5     7  10    1213
  eval { @@pup = unpack( 'S/(S/A* S/A*)', substr( $env, 0, 13 ) ) };
  like( $@@, qr{length/code after end of string} );

  # postfix repeat count
  $env = pack( '(S/A* S/A*)' . @@Env/2, @@Env );

  # warn when count/code goes beyond end of string
  # \0001 a \0003 AAA \0001  b \0003 BBB
  #     2 3c    5   8    10 11    13  16
  eval { @@pup = unpack( '(S/A* S/A*)' . @@Env/2, substr( $env, 0, 11 ) ) };
  like( $@@, qr{length/code after end of string} );

  # catch stack overflow/segfault
  eval { $_ = pack( ('(' x 105) . 'A' . (')' x 105) ); };
  like( $@@, qr{Too deeply nested \(\)-groups} );
}

{ # syntax checks (W.Laun)
  use warnings qw(NONFATAL all);;
  my @@warning;
  local $SIG{__WARN__} = sub {
      push( @@warning, $_[0] );
  };
  eval { my $s = pack( 'Ax![4c]A', 1..5 ); };
  like( $@@, qr{Malformed integer in \[\]} );

  eval { my $buf = pack( '(c/*a*)', 'AAA', 'BB' ); };
  like( $@@, qr{'/' does not take a repeat count} );

  eval { my @@inf = unpack( 'c/1a', "\x03AAA\x02BB" ); };
  like( $@@, qr{'/' does not take a repeat count} );

  eval { my @@inf = unpack( 'c/*a', "\x03AAA\x02BB" ); };
  like( $@@, qr{'/' does not take a repeat count} );

  # white space where possible
  my @@Env = ( a => 'AAA', b => 'BBB' );
  my $env = pack( ' S ( S / A*   S / A* )* ', @@Env/2, @@Env );
  my @@pup = unpack( ' S / ( S / A*   S / A* ) ', $env );
  is( "@@pup", "@@Env" );

  # white space in 4 wrong places
  for my $temp (  'A ![4]', 'A [4]', 'A *', 'A 4' ){
      eval { my $s = pack( $temp, 'B' ); };
      like( $@@, qr{Invalid type } );
  }

  # warning for commas
  @@warning = ();
  my $x = pack( 'I,A', 4, 'X' );
  like( $warning[0], qr{Invalid type ','} );

  # comma warning only once
  @@warning = ();
  $x = pack( 'C(C,C)C,C', 65..71  );
  cmp_ok( scalar(@@warning), '==', 1 );

  # forbidden code in []
  eval { my $x = pack( 'A[@@4]', 'XXXX' ); };
  like( $@@, qr{Within \[\]-length '\@@' not allowed} );

  # @@ repeat default 1
  my $s = pack( 'AA@@A', 'A', 'B', 'C' );
  my @@c = unpack( 'AA@@A', $s );
  is( $s, 'AC' );
  is( "@@c", "A C C" );

  # no unpack code after /
  eval { my @@a = unpack( "C/", "\3" ); };
  like( $@@, qr{Code missing after '/'} );

 SKIP: {
    skip $no_endianness, 6 if $no_endianness;

    # modifier warnings
    @@warning = ();
    $x = pack "I>>s!!", 47, 11;
    ($x) = unpack "I<<l!>!>", 'x'x20;
    is(scalar @@warning, 5);
    like($warning[0], qr/Duplicate modifier '>' after 'I' in pack/);
    like($warning[1], qr/Duplicate modifier '!' after 's' in pack/);
    like($warning[2], qr/Duplicate modifier '<' after 'I' in unpack/);
    like($warning[3], qr/Duplicate modifier '!' after 'l' in unpack/);
    like($warning[4], qr/Duplicate modifier '>' after 'l' in unpack/);
  }
}

{  # Repeat count [SUBEXPR]
   my @@codes = qw( x A Z a c C W B b H h s v n S i I l V N L p P f F d
		   s! S! i! I! l! L! j J);
   my $G;
   if (eval { pack 'q', 1 } ) {
     push @@codes, qw(q Q);
   } else {
     push @@codes, qw(s S);	# Keep the count the same
   }
   if (eval { pack 'D', 1 } ) {
     push @@codes, 'D';
   } else {
     push @@codes, 'd';	# Keep the count the same
   }

   push @@codes, map { /^[silqjfdp]/i ? ("$_<", "$_>") : () } @@codes;

   my %val;
   @@val{@@codes} = map { / [Xx]  (?{ undef })
			| [AZa] (?{ 'something' })
			| C     (?{ 214 })
			| W     (?{ 8188 })
			| c     (?{ 114 })
			| [Bb]  (?{ '101' })
			| [Hh]  (?{ 'b8' })
			| [svnSiIlVNLqQjJ]  (?{ 10111 })
			| [FfDd]  (?{ 1.36514538e67 })
			| [pP]  (?{ "try this buffer" })
			/x; $^R } @@codes;
   my @@end = (0x12345678, 0x23456781, 0x35465768, 0x15263748);
   my $end = "N4";

   for my $type (@@codes) {
     my @@list = $val{$type};
     @@list = () unless defined $list[0];
     for my $count ('', '3', '[11]') {
       my $c = 1;
       $c = $1 if $count =~ /(\d+)/;
       my @@list1 = @@list;
       @@list1 = (@@list1) x $c unless $type =~ /[XxAaZBbHhP]/;
       for my $groupend ('', ')2', ')[8]') {
	   my $groupbegin = ($groupend ? '(' : '');
	   $c = 1;
	   $c = $1 if $groupend =~ /(\d+)/;
	   my @@list2 = (@@list1) x $c;

           SKIP: {
	     my $junk1 = "$groupbegin $type$count $groupend";
	     # print "# junk1=$junk1\n";
	     my $p = eval { pack $junk1, @@list2 };
             skip "cannot pack '$type' on this perl", 12
               if is_valid_error($@@);
	     die "pack $junk1 failed: $@@" if $@@;

	     my $half = int( (length $p)/2 );
	     for my $move ('', "X$half", "X!$half", 'x1', 'x!8', "x$half") {
	       my $junk = "$junk1 $move";
	       # print "# junk='$junk', list=(@@list2)\n";
	       $p = pack "$junk $end", @@list2, @@end;
	       my @@l = unpack "x[$junk] $end", $p;
	       is(scalar @@l, scalar @@end);
	       is("@@l", "@@end", "skipping x[$junk]");
	     }
           }
       }
     }
   }
}

# / is recognized after spaces in scalar context
# XXXX no spaces are allowed in pack...  In pack only before the slash...
is(scalar unpack('A /A Z20', pack 'A/A* Z20', 'bcde', 'xxxxx'), 'bcde');
is(scalar unpack('A /A /A Z20', '3004bcde'), 'bcde');

{ # X! and x!
  my $t = 'C[3]  x!8 C[2]';
  my @@a = (0x73..0x77);
  my $p = pack($t, @@a);
  is($p, "\x73\x74\x75\0\0\0\0\0\x76\x77");
  my @@b = unpack $t, $p;
  is(scalar @@b, scalar @@a);
  is("@@b", "@@a", 'x!8');
  $t = 'x[5] C[6] X!8 C[2]';
  @@a = (0x73..0x7a);
  $p = pack($t, @@a);
  is($p, "\0\0\0\0\0\x73\x74\x75\x79\x7a");
  @@b = unpack $t, $p;
  @@a = (0x73..0x75, 0x79, 0x7a, 0x79, 0x7a);
  is(scalar @@b, scalar @@a);
  is("@@b", "@@a");
}

{ # struct {char c1; double d; char cc[2];}
  my $t = 'C x![d] d C[2]';
  my @@a = (173, 1.283476517e-45, 42, 215);
  my $p = pack $t, @@a;
  ok( length $p);
  my @@b = unpack "$t X[$t] $t", $p;	# Extract, step back, extract again
  is(scalar @@b, 2 * scalar @@a);
  $b = "@@b";
  $b =~ s/(?:17000+|16999+)\d+(e-45) /17$1 /gi; # stringification is gamble
  is($b, "@@a @@a");

  use warnings qw(NONFATAL all);;
  my $warning;
  local $SIG{__WARN__} = sub {
      $warning = $_[0];
  };
  @@b = unpack "x[C] x[$t] X[$t] X[C] $t", "$p\0";

  is($warning, undef);
  is(scalar @@b, scalar @@a);
  $b = "@@b";
  $b =~ s/(?:17000+|16999+)\d+(e-45) /17$1 /gi; # stringification is gamble
  is($b, "@@a");
}

is(length(pack("j", 0)), $Config{ivsize});
is(length(pack("J", 0)), $Config{uvsize});
is(length(pack("F", 0)), $Config{nvsize});

numbers ('j', -2147483648, -1, 0, 1, 2147483647);
numbers ('J', 0, 1, 2147483647, 2147483648, 4294967295);
numbers ('F', -(2**34), -1, 0, 1, 2**34);
SKIP: {
    my $t = eval { unpack("D*", pack("D", 12.34)) };

    skip "Long doubles not in use", 166 if $@@ =~ /Invalid type/;

    is(length(pack("D", 0)), $Config{longdblsize});
    numbers ('D', -(2**34), -1, 0, 1, 2**34);
}

# Maybe this knowledge needs to be "global" for all of pack.t
# Or a "can checksum" which would effectively be all the number types"
my %cant_checksum = map {$_=> 1} qw(A Z u w);
# not a b B h H
foreach my $template (qw(A Z c C s S i I l L n N v V q Q j J f d F D u U w)) {
  SKIP: {
    my $packed = eval {pack "${template}4", 1, 4, 9, 16};
    if ($@@) {
      die unless $@@ =~ /Invalid type '$template'/;
      skip ("$template not supported on this perl",
            $cant_checksum{$template} ? 4 : 8);
    }
    my @@unpack4 = unpack "${template}4", $packed;
    my @@unpack = unpack "${template}*", $packed;
    my @@unpack1 = unpack "${template}", $packed;
    my @@unpack1s = scalar unpack "${template}", $packed;
    my @@unpack4s = scalar unpack "${template}4", $packed;
    my @@unpacks = scalar unpack "${template}*", $packed;

    my @@tests = ( ["${template}4 vs ${template}*", \@@unpack4, \@@unpack],
                  ["scalar ${template} ${template}", \@@unpack1s, \@@unpack1],
                  ["scalar ${template}4 vs ${template}", \@@unpack4s, \@@unpack1],
                  ["scalar ${template}* vs ${template}", \@@unpacks, \@@unpack1],
                );

    unless ($cant_checksum{$template}) {
      my @@unpack4_c = unpack "\%${template}4", $packed;
      my @@unpack_c = unpack "\%${template}*", $packed;
      my @@unpack1_c = unpack "\%${template}", $packed;
      my @@unpack1s_c = scalar unpack "\%${template}", $packed;
      my @@unpack4s_c = scalar unpack "\%${template}4", $packed;
      my @@unpacks_c = scalar unpack "\%${template}*", $packed;

      push @@tests,
        ( ["% ${template}4 vs ${template}*", \@@unpack4_c, \@@unpack_c],
          ["% scalar ${template} ${template}", \@@unpack1s_c, \@@unpack1_c],
          ["% scalar ${template}4 vs ${template}*", \@@unpack4s_c, \@@unpack_c],
          ["% scalar ${template}* vs ${template}*", \@@unpacks_c, \@@unpack_c],
        );
    }
    foreach my $test (@@tests) {
      ok (list_eq ($test->[1], $test->[2]), $test->[0]) ||
        printf "# unpack gave %s expected %s\n",
          encode_list (@@{$test->[1]}), encode_list (@@{$test->[2]});
    }
  }
}

ok(pack('u2', 'AA'), "[perl #8026]"); # used to hang and eat RAM in perl 5.7.2

$_ = pack('c', 65); # 'A' would not be EBCDIC-friendly
is(unpack('c'), 65, "one-arg unpack (change #18751)"); # defaulting to $_

{
    my $a = "X\x0901234567\n" x 100; # \t would not be EBCDIC TAB
    my @@a = unpack("(a1 c/a)*", $a);
    is(scalar @@a, 200,       "[perl #15288]");
    is($a[-1], "01234567\n", "[perl #15288]");
    is($a[-2], "X",          "[perl #15288]");
}

{
    use warnings qw(NONFATAL all);;
    my $warning;
    local $SIG{__WARN__} = sub {
        $warning = $_[0];
    };

    # This test is looking for the encoding of the bit pattern "\x66\x6f\x6f",
    # which is ASCII "foo"
    my $out = pack("u99", native_to_uni("foo") x 99);
    like($warning, qr/Field too wide in 'u' format in pack at /,
         "Warn about too wide uuencode");
    is($out, ("_" . "9F]O" x 21 . "\n") x 4 . "M" . "9F]O" x 15 . "\n",
       "Use max width in case of too wide uuencode");
}

# checksums
{
    # verify that unpack advances correctly wrt a checksum
    my (@@x) = unpack("b10a", "abcd");
    my (@@y) = unpack("%b10a", "abcd");
    is($x[1], $y[1], "checksum advance ok");

    # verify that the checksum is not overflowed with C0
    is(unpack("C0%128U", "abcd"), unpack("U0%128U", "abcd"), "checksum not overflowed");
}

my $U_1FFC_bytes = byte_utf8a_to_utf8n("\341\277\274");
{
    # U0 and C0 must be scoped
    my (@@x) = unpack("a(U0)U", "b$U_1FFC_bytes");
    is($x[0], 'b', 'before scope');
    is($x[1], 8188, 'after scope');

    is(pack("a(U0)U", "b", 8188), "b$U_1FFC_bytes");
}

{
    # counted length prefixes shouldn't change C0/U0 mode
    # (note the length is actually 0 in this test, as the C/ is replaced by C0
    # due to the \0 in the string)
    is(join(',', unpack("aC/UU",   "b\0$U_1FFC_bytes")), 'b,8188');
    is(join(',', unpack("aC/CU",   "b\0$U_1FFC_bytes")), 'b,8188');

    # The U expects Unicode, so convert from native
    my $first_byte = utf8::native_to_unicode(ord substr($U_1FFC_bytes, 0, 1));

    is(join(',', unpack("aU0C/UU", "b\0$U_1FFC_bytes")), "b,$first_byte");
    is(join(',', unpack("aU0C/CU", "b\0$U_1FFC_bytes")), "b,$first_byte");
}

{
    # "Z0" (bug #34062)
    my (@@x) = unpack("C*", pack("CZ0", 1, "b"));
    is(join(',', @@x), '1', 'pack Z0 doesn\'t destroy the character before');
}

{
    # Encoding neutrality
    # String we will pull apart and rebuild in several ways:
    my $down = "\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff\x05\x06";
    my $up   = $down;
    utf8::upgrade($up);

    my %expect =
        # [expected result,
        #  how many chars it should progress,
        #  (optional) expected result of pack]
        (a5 => ["\xf8\xf9\xfa\xfb\xfc", 5],
         A5 => ["\xf8\xf9\xfa\xfb\xfc", 5],
         Z5 => ["\xf8\xf9\xfa\xfb\xfc", 5, "\xf8\xf9\xfa\xfb\x00\xfd"],
         b21 => ["000111111001111101011", 3, "\xf8\xf9\x1a\xfb"],
         B21 => ["111110001111100111111", 3, "\xf8\xf9\xf8\xfb"],
         H5 => ["f8f9f", 3, "\xf8\xf9\xf0\xfb"],
         h5 => ["8f9fa", 3, "\xf8\xf9\x0a\xfb"],
         "s<"  => [-1544, 2],
         "s>"  => [-1799, 2],
         "S<"  => [0xf9f8, 2],
         "S>"  => [0xf8f9, 2],
         "l<"  => [-67438088, 4],
         "l>"  => [-117835013, 4],
         "L>"  => [0xf8f9fafb, 4],
         "L<"  => [0xfbfaf9f8, 4],
         n     => [0xf8f9, 2],
         N     => [0xf8f9fafb, 4],
         v     => [63992, 2],
         V     => [0xfbfaf9f8, 4],
         c     => [-8, 1],
         U0U   => [0xf8, 1],
         w     => ["8715569050387726213", 9],
         q     => ["-283686952306184", 8],
         Q     => ["18446460386757245432", 8],
         );

    for my $string ($down, $up) {
        for my $format (sort {lc($a) cmp lc($b) || $a cmp $b } keys %expect) {
          SKIP: {
              my $expect = $expect{$format};
              # unpack upgraded and downgraded string
              my @@result = eval { unpack("$format C0 W", $string) };
              skip "cannot pack/unpack '$format C0 W' on this perl", 5 if
                  $@@ && is_valid_error($@@);
              is(@@result, 2, "Two results from unpack $format C0 W");

              # pack to downgraded
              my $new = pack("$format C0 W", @@result);
              is(length($new), $expect->[1]+1,
                 "pack $format C0 W should give $expect->[1]+1 chars");
              is($new, $expect->[2] || substr($string, 0, length $new),
                 "pack $format C0 W returns expected value");

              # pack to upgraded
              $new = pack("a0 $format C0 W", chr(256), @@result);
              is(length($new), $expect->[1]+1,
                 "pack a0 $format C0 W should give $expect->[1]+1 chars");
              is($new, $expect->[2] || substr($string, 0, length $new),
                 "pack a0 $format C0 W returns expected value");
          }
        }
    }
}

{
    # Encoding neutrality, numbers
    my $val = -2.68;
    for my $format (qw(s S i I l L j J f d F D q Q
                       s! S! i! I! l! L! n! N! v! V!)) {
      SKIP: {
          my $down = eval { pack($format, $val) };
          skip "cannot pack/unpack $format on this perl", 9 if
              $@@ && is_valid_error($@@);
          ok(!utf8::is_utf8($down), "Simple $format pack doesn't get upgraded");
          my $up = pack("a0 $format", chr(256), $val);
          ok(utf8::is_utf8($up), "a0 $format with high char leads to upgrade");
          is($down, $up, "$format generated strings are equal though");
          my @@down_expanded = unpack("$format W", $down . chr(0xce));
          is(@@down_expanded, 2, "Expand to two values");
          is($down_expanded[1], 0xce,
             "unpack $format left us at the expected position");
          my @@up_expanded   = unpack("$format W", $up   . chr(0xce));
          is(@@up_expanded, 2, "Expand to two values");
          is($up_expanded[1], 0xce,
             "unpack $format left us at the expected position");
          is($down_expanded[0], $up_expanded[0], "$format unpack was neutral");
          is(pack($format, $down_expanded[0]), $down, "Pack $format undoes unpack $format");
      }
    }
}

{
    # C *is* neutral
    my $down = "\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff\x05\x06";
    my $up   = $down;
    utf8::upgrade($up);
    my @@down = unpack("C*", $down);
    my @@expect_down = (0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff, 0x05, 0x06);
    is("@@down", "@@expect_down", "byte expand");
    is(pack("C*", @@down), $down, "byte join");

    my @@up   = unpack("C*", $up);
    my @@expect_up = (0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff, 0x05, 0x06);
    is("@@up", "@@expect_up", "UTF-8 expand");
    is(pack("U0C0C*", @@up), $up, "UTF-8 join");
}

{
    # Harder cases for the neutrality test

    # u format
    my $down = "\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff\x05\x06";
    my $up   = $down;
    utf8::upgrade($up);
    is(pack("u", $down), pack("u", $up), "u pack is neutral");
    is(unpack("u", pack("u", $down)), $down, "u unpack to downgraded works");
    is(unpack("U0C0u", pack("u", $down)), $up, "u unpack to upgraded works");

    # p/P format
    # This actually only tests something if the address contains a byte >= 0x80
    my $str = "abc\xa5\x00\xfede";
    $down = pack("p", $str);
    is(pack("P", $str), $down);
    is(pack("U0C0p", $str), $down);
    is(pack("U0C0P", $str), $down);
    is(unpack("p", $down), "abc\xa5", "unpack p downgraded");
    $up   = $down;
    utf8::upgrade($up);
    is(unpack("p", $up), "abc\xa5", "unpack p upgraded");

    is(unpack("P7", $down), "abc\xa5\x00\xfed", "unpack P downgraded");
    is(unpack("P7", $up),   "abc\xa5\x00\xfed", "unpack P upgraded");

    # x, X and @@
    $down = "\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff\x05\x06";
    $up   = $down;
    utf8::upgrade($up);

    is(unpack('@@4W', $down), 0xfc, "\@@positioning on downgraded string");
    is(unpack('@@4W', $up),   0xfc, "\@@positioning on upgraded string");

    is(unpack('@@4x2W', $down), 0xfe, "x moving on downgraded string");
    is(unpack('@@4x2W', $up),   0xfe, "x moving on upgraded string");
    is(unpack('@@4x!4W', $down), 0xfc, "x! moving on downgraded string");
    is(unpack('@@4x!4W', $up),   0xfc, "x! moving on upgraded string");
    is(unpack('@@5x!4W', $down), 0x05, "x! moving on downgraded string");
    is(unpack('@@5x!4W', $up),   0x05, "x! moving on upgraded string");

    is(unpack('@@4X2W', $down), 0xfa, "X moving on downgraded string");
    is(unpack('@@4X2W', $up),   0xfa, "X moving on upgraded string");
    is(unpack('@@4X!4W', $down), 0xfc, "X! moving on downgraded string");
    is(unpack('@@4X!4W', $up),   0xfc, "X! moving on upgraded string");
    is(unpack('@@5X!4W', $down), 0xfc, "X! moving on downgraded string");
    is(unpack('@@5X!4W', $up),   0xfc, "X! moving on upgraded string");
    is(unpack('@@5X!8W', $down), 0xf8, "X! moving on downgraded string");
    is(unpack('@@5X!8W', $up),   0xf8, "X! moving on upgraded string");

    is(pack("W2x", 0xfa, 0xe3), "\xfa\xe3\x00", "x on downgraded string");
    is(pack("W2x!4", 0xfa, 0xe3), "\xfa\xe3\x00\x00",
       "x! on downgraded string");
    is(pack("W2x!2", 0xfa, 0xe3), "\xfa\xe3", "x! on downgraded string");
    is(pack("U0C0W2x", 0xfa, 0xe3), "\xfa\xe3\x00", "x on upgraded string");
    is(pack("U0C0W2x!4", 0xfa, 0xe3), "\xfa\xe3\x00\x00",
       "x! on upgraded string");
    is(pack("U0C0W2x!2", 0xfa, 0xe3), "\xfa\xe3", "x! on upgraded string");
    is(pack("W2X", 0xfa, 0xe3), "\xfa", "X on downgraded string");
    is(pack("U0C0W2X", 0xfa, 0xe3), "\xfa", "X on upgraded string");
    is(pack("W2X!2", 0xfa, 0xe3), "\xfa\xe3", "X! on downgraded string");
    is(pack("U0C0W2X!2", 0xfa, 0xe3), "\xfa\xe3", "X! on upgraded string");
    is(pack("W3X!2", 0xfa, 0xe3, 0xa6), "\xfa\xe3", "X! on downgraded string");
    is(pack("U0C0W3X!2", 0xfa, 0xe3, 0xa6), "\xfa\xe3",
       "X! on upgraded string");

    # backward eating through a ( moves the group starting point backwards
    is(pack("a*(Xa)", "abc", "q"), "abq",
       "eating before strbeg moves it back");
    is(pack("a*(Xa)", "ab" . chr(512), "q"), "abq",
       "eating before strbeg moves it back");

    # Check marked_upgrade
    is(pack('W(W(Wa@@3W)@@6W)@@9W', 0xa1, 0xa2, 0xa3, "a", 0xa4, 0xa5, 0xa6),
       "\xa1\xa2\xa3a\x00\xa4\x00\xa5\x00\xa6");
    $up = "a";
    utf8::upgrade($up);
    is(pack('W(W(Wa@@3W)@@6W)@@9W', 0xa1, 0xa2, 0xa3, $up, 0xa4, 0xa5, 0xa6),
       "\xa1\xa2\xa3a\x00\xa4\x00\xa5\x00\xa6", "marked upgrade caused by a");
    is(pack('W(W(WW@@3W)@@6W)@@9W', 0xa1, 0xa2, 0xa3, 256, 0xa4, 0xa5, 0xa6),
       "\xa1\xa2\xa3\x{100}\x00\xa4\x00\xa5\x00\xa6",
       "marked upgrade caused by W");
    is(pack('W(W(WU0aC0@@3W)@@6W)@@9W', 0xa1, 0xa2, 0xa3, "a", 0xa4, 0xa5, 0xa6),
       "\xa1\xa2\xa3a\x00\xa4\x00\xa5\x00\xa6", "marked upgrade caused by U0");

    # a, A and Z
    $down = "\xa4\xa6\xa7";
    $up   = $down;
    utf8::upgrade($up);
    utf8::upgrade(my $high = "\xfeb");

    for my $format ("a0", "A0", "Z0", "U0a0C0", "U0A0C0", "U0Z0C0") {
        is(pack("a* $format a*", "ab", $down, "cd"), "abcd",
           "$format format on plain string");
        is(pack("a* $format a*", "ab", $up,   "cd"), "abcd",
           "$format format on upgraded string");
        is(pack("a* $format a*", $high, $down, "cd"), "\xfebcd",
           "$format format on plain string");
        is(pack("a* $format a*", $high, $up,   "cd"), "\xfebcd",
           "$format format on upgraded string");
        my @@down = unpack("a1 $format a*", "\xfeb");
        is("@@down", "\xfe  b", "unpack $format");
        my @@up = unpack("a1 $format a*", $high);
        is("@@up", "\xfe  b", "unpack $format");
    }
    is(pack("a1", $high), "\xfe");
    is(pack("A1", $high), "\xfe");
    is(pack("Z1", $high), "\x00");
    is(pack("a2", $high), "\xfeb");
    is(pack("A2", $high), "\xfeb");
    is(pack("Z2", $high), "\xfe\x00");
    is(pack("a5", $high), "\xfeb\x00\x00\x00");
    is(pack("A5", $high), "\xfeb   ");
    is(pack("Z5", $high), "\xfeb\x00\x00\x00");
    is(pack("a*", $high), "\xfeb");
    is(pack("A*", $high), "\xfeb");
    is(pack("Z*", $high), "\xfeb\x00");

    utf8::upgrade($high = byte_utf8a_to_utf8n("\xc3\xbe") . "b");
    is(pack("U0a2", $high), uni_to_native("\xfe"));
    is(pack("U0A2", $high), uni_to_native("\xfe"));
    is(pack("U0Z1", $high), uni_to_native("\x00"));
    is(pack("U0a3", $high), uni_to_native("\xfe") . "b");
    is(pack("U0A3", $high), uni_to_native("\xfe") . "b");
    is(pack("U0Z3", $high), uni_to_native("\xfe\x00"));
    is(pack("U0a6", $high), uni_to_native("\xfe") . "b" . uni_to_native("\x00\x00\x00"));
    is(pack("U0A6", $high), uni_to_native("\xfe") . "b   ");
    is(pack("U0Z6", $high), uni_to_native("\xfe") . "b" . uni_to_native("\x00\x00\x00"));
    is(pack("U0a*", $high), uni_to_native("\xfe") . "b");
    is(pack("U0A*", $high), uni_to_native("\xfe") . "b");
    is(pack("U0Z*", $high), uni_to_native("\xfe") . "b" . uni_to_native("\x00"));
}
{
    # pack /
    my @@array = 1..14;
    my @@out = unpack("N/S", pack("N/S", @@array) . "abcd");
    is("@@out", "@@array", "pack N/S works");
    @@out = unpack("N/S*", pack("N/S*", @@array) . "abcd");
    is("@@out", "@@array", "pack N/S* works");
    @@out = unpack("N/S*", pack("N/S14", @@array) . "abcd");
    is("@@out", "@@array", "pack N/S14 works");
    @@out = unpack("N/S*", pack("N/S15", @@array) . "abcd");
    is("@@out", "@@array", "pack N/S15 works");
    @@out = unpack("N/S*", pack("N/S13", @@array) . "abcd");
    is("@@out", "@@array[0..12]", "pack N/S13 works");
    @@out = unpack("N/S*", pack("N/S0", @@array) . "abcd");
    is("@@out", "", "pack N/S0 works");
    is(pack("Z*/a0", "abc"), "0\0", "pack Z*/a0 makes a short string");
    is(pack("Z*/Z0", "abc"), "0\0", "pack Z*/Z0 makes a short string");
    is(pack("Z*/a3", "abc"), "3\0abc", "pack Z*/a3 makes a full string");
    is(pack("Z*/Z3", "abc"), "3\0ab\0", "pack Z*/Z3 makes a short string");
    is(pack("Z*/a5", "abc"), "5\0abc\0\0", "pack Z*/a5 makes a long string");
    is(pack("Z*/Z5", "abc"), "5\0abc\0\0", "pack Z*/Z5 makes a long string");
    is(pack("Z*/Z"), "1\0\0", "pack Z*/Z makes an extended string");
    is(pack("Z*/Z", ""), "1\0\0", "pack Z*/Z makes an extended string");
    is(pack("Z*/a", ""), "0\0", "pack Z*/a makes an extended string");
}
{
    # unpack("A*", $unicode) strips general unicode spaces
    is(unpack("A*", "ab \n" . uni_to_native("\xa0") . " \0"), "ab \n" . uni_to_native("\xa0"),
       'normal A* strip leaves \xa0');
    is(unpack("U0C0A*", "ab \n" . uni_to_native("\xa0") . " \0"), "ab \n" . uni_to_native("\xa0"),
       'normal A* strip leaves \xa0 even if it got upgraded for technical reasons');
    is(unpack("A*", pack("a*(U0U)a*", "ab \n", 0xa0, " \0")), "ab",
       'upgraded strings A* removes \xa0');
    is(unpack("A*", pack("a*(U0UU)a*", "ab \n", 0xa0, 0x1680, " \0")), "ab",
       'upgraded strings A* removes all unicode whitespace');
    is(unpack("A5", pack("a*(U0U)a*", "ab \n", 0x1680, "def", "ab")), "ab",
       'upgraded strings A5 removes all unicode whitespace');
    is(unpack("A*", pack("U", 0x1680)), "",
       'upgraded strings A* with nothing left');
}
{
    # Testing unpack . and .!
    is(unpack(".", "ABCD"), 0, "offset at start of string is 0");
    is(unpack(".", ""), 0, "offset at start of empty string is 0");
    is(unpack("x3.", "ABCDEF"), 3, "simple offset works");
    is(unpack("x3.", "ABC"), 3, "simple offset at end of string works");
    is(unpack("x3.0", "ABC"), 0, "self offset is 0");
    is(unpack("x3(x2.)", "ABCDEF"), 2, "offset is relative to inner group");
    is(unpack("x3(X2.)", "ABCDEF"), -2,
       "negative offset relative to inner group");
    is(unpack("x3(X2.2)", "ABCDEF"), 1, "offset is relative to inner group");
    is(unpack("x3(x2.0)", "ABCDEF"), 0, "self offset in group is still 0");
    is(unpack("x3(x2.2)", "ABCDEF"), 5, "offset counts groups");
    is(unpack("x3(x2.*)", "ABCDEF"), 5, "star offset is relative to start");

    my $high = chr(8188) x 6;
    is(unpack("x3(x2.)", $high), 2, "utf8 offset is relative to inner group");
    is(unpack("x3(X2.)", $high), -2,
       "utf8 negative offset relative to inner group");
    is(unpack("x3(X2.2)", $high), 1, "utf8 offset counts groups");
    is(unpack("x3(x2.0)", $high), 0, "utf8 self offset in group is still 0");
    is(unpack("x3(x2.2)", $high), 5, "utf8 offset counts groups");
    is(unpack("x3(x2.*)", $high), 5, "utf8 star offset is relative to start");

    is(unpack("U0x3(x2.)", $high), 2,
       "U0 mode utf8 offset is relative to inner group");
    is(unpack("U0x3(X2.)", $high), -2,
       "U0 mode utf8 negative offset relative to inner group");
    is(unpack("U0x3(X2.2)", $high), 1,
       "U0 mode utf8 offset counts groups");
    is(unpack("U0x3(x2.0)", $high), 0,
       "U0 mode utf8 self offset in group is still 0");
    is(unpack("U0x3(x2.2)", $high), 5,
       "U0 mode utf8 offset counts groups");
    is(unpack("U0x3(x2.*)", $high), 5,
       "U0 mode utf8 star offset is relative to start");

    is(unpack("x3(x2.!)", $high), 2*3,
       "utf8 offset is relative to inner group");
    is(unpack("x3(X2.!)", $high), -2*3,
       "utf8 negative offset relative to inner group");
    is(unpack("x3(X2.!2)", $high), 1*3,
       "utf8 offset counts groups");
    is(unpack("x3(x2.!0)", $high), 0,
       "utf8 self offset in group is still 0");
    is(unpack("x3(x2.!2)", $high), 5*3,
       "utf8 offset counts groups");
    is(unpack("x3(x2.!*)", $high), 5*3,
       "utf8 star offset is relative to start");

    is(unpack("U0x3(x2.!)", $high), 2,
       "U0 mode utf8 offset is relative to inner group");
    is(unpack("U0x3(X2.!)", $high), -2,
       "U0 mode utf8 negative offset relative to inner group");
    is(unpack("U0x3(X2.!2)", $high), 1,
       "U0 mode utf8 offset counts groups");
    is(unpack("U0x3(x2.!0)", $high), 0,
       "U0 mode utf8 self offset in group is still 0");
    is(unpack("U0x3(x2.!2)", $high), 5,
       "U0 mode utf8 offset counts groups");
    is(unpack("U0x3(x2.!*)", $high), 5,
       "U0 mode utf8 star offset is relative to start");
}
{
    # Testing pack . and .!
    is(pack("(a)5 .", 1..5, 3), "123", ". relative to string start, shorten");
    eval { () = pack("(a)5 .", 1..5, -3) };
    like($@@, qr{'\.' outside of string in pack}, "Proper error message");
    is(pack("(a)5 .", 1..5, 8), "12345\x00\x00\x00",
       ". relative to string start, extend");
    is(pack("(a)5 .", 1..5, 5), "12345", ". relative to string start, keep");

    is(pack("(a)5 .0", 1..5, -3), "12",
       ". relative to string current, shorten");
    is(pack("(a)5 .0", 1..5, 2), "12345\x00\x00",
       ". relative to string current, extend");
    is(pack("(a)5 .0", 1..5, 0), "12345",
       ". relative to string current, keep");

    is(pack("(a)5 (.)", 1..5, -3), "12",
       ". relative to group, shorten");
    is(pack("(a)5 (.)", 1..5, 2), "12345\x00\x00",
       ". relative to group, extend");
    is(pack("(a)5 (.)", 1..5, 0), "12345",
       ". relative to group, keep");

    is(pack("(a)3 ((a)2 .)", 1..5, -2), "1",
       ". relative to group, shorten");
    is(pack("(a)3 ((a)2 .)", 1..5, 2), "12345",
       ". relative to group, keep");
    is(pack("(a)3 ((a)2 .)", 1..5, 4), "12345\x00\x00",
       ". relative to group, extend");

    is(pack("(a)3 ((a)2 .2)", 1..5, 2), "12",
       ". relative to counted group, shorten");
    is(pack("(a)3 ((a)2 .2)", 1..5, 7), "12345\x00\x00",
       ". relative to counted group, extend");
    is(pack("(a)3 ((a)2 .2)", 1..5, 5), "12345",
       ". relative to counted group, keep");

    is(pack("(a)3 ((a)2 .*)", 1..5, 2), "12",
       ". relative to start, shorten");
    is(pack("(a)3 ((a)2 .*)", 1..5, 7), "12345\x00\x00",
       ". relative to start, extend");
    is(pack("(a)3 ((a)2 .*)", 1..5, 5), "12345",
       ". relative to start, keep");

    is(pack('(a)5 (. @@2 a)', 1..5, -3, "a"), "12\x00\x00a",
       ". based shrink properly updates group starts");

    is(pack("(W)3 ((W)2 .)", 0x301..0x305, -2), "\x{301}",
       "utf8 . relative to group, shorten");
    is(pack("(W)3 ((W)2 .)", 0x301..0x305, 2),
       "\x{301}\x{302}\x{303}\x{304}\x{305}",
       "utf8 . relative to group, keep");
    is(pack("(W)3 ((W)2 .)", 0x301..0x305, 4),
       "\x{301}\x{302}\x{303}\x{304}\x{305}\x00\x00",
       "utf8 . relative to group, extend");

    is(pack("(W)3 ((W)2 .!)", 0x301..0x305, -2), "\x{301}\x{302}",
       "utf8 . relative to group, shorten");
    is(pack("(W)3 ((W)2 .!)", 0x301..0x305, 4),
       "\x{301}\x{302}\x{303}\x{304}\x{305}",
       "utf8 . relative to group, keep");
    is(pack("(W)3 ((W)2 .!)", 0x301..0x305, 6),
       "\x{301}\x{302}\x{303}\x{304}\x{305}\x00\x00",
       "utf8 . relative to group, extend");

    is(pack('(W)5 (. @@2 a)', 0x301..0x305, -3, "a"),
       "\x{301}\x{302}\x00\x00a",
       "utf8 . based shrink properly updates group starts");
}
{
    # Testing @@!
    is(pack('a* @@3',  "abcde"), "abc", 'Test basic @@');
    is(pack('a* @@!3', "abcde"), "abc", 'Test basic @@!');
    is(pack('a* @@2', "\x{301}\x{302}\x{303}\x{304}\x{305}"), "\x{301}\x{302}",
       'Test basic utf8 @@');
    is(pack('a* @@!2', "\x{301}\x{302}\x{303}\x{304}\x{305}"), "\x{301}",
       'Test basic utf8 @@!');

    is(unpack('@@4 a*',  "abcde"), "e", 'Test basic @@');
    is(unpack('@@!4 a*', "abcde"), "e", 'Test basic @@!');
    is(unpack('@@4 a*',  "\x{301}\x{302}\x{303}\x{304}\x{305}"), "\x{305}",
       'Test basic utf8 @@');
    is(unpack('@@!4 a*', "\x{301}\x{302}\x{303}\x{304}\x{305}"),
       "\x{303}\x{304}\x{305}", 'Test basic utf8 @@!');
}
{
    #50256
    # This test is for the bit pattern "\x61\x62", which is ASCII "ab"
    my ($v) = split //, unpack ('(B)*', native_to_uni('ab'));
    is($v, 0); # Doesn't SEGV :-)
}
{
    #73814
    my $x = runperl( prog => 'print split( /,/, unpack(q(%2H*), q(hello world))), qq(\n)' );
    is($x, "0\n", "split /a/, unpack('%2H*'...) didn't crash");

    my $y = runperl( prog => 'print split( /,/, unpack(q(%32u*), q(#,3,Q)), qq(\n)), qq(\n)' );
    is($y, "0\n", "split /a/, unpack('%32u*'...) didn't crash");
}

#90160
is(eval { () = unpack "C0 U*", ""; "ok" }, "ok",
  'medial U* on empty string');

package o {
    use overload
        '""' => sub { ++$o::str; "42" },
        '0+' => sub { ++$o::num; 42 };
}
is pack("c", bless [], "o"), chr(42), 'overloading called';
is $o::str, undef, 'pack "c" does not call string overloading';
is $o::num, 1,     'pack "c" does call num overloading';

#[perl #123874]: argument underflow leads to corrupt length
eval q{ pack "pi/x" };
ok(1, "argument underflow did not crash");

{
    # [perl #126325] pack [hH] with a unicode string
    # the hex encoders would read past the end of the string, using
    # invalid source bytes
    my $twenty_nuls = "\0" x 20;
    # This is the case that failed
    is(pack("WH40", 0x100, ""), "\x{100}$twenty_nuls",
       "check pack H zero fills (utf8 target)");
    my $up_nul = "\0";

    utf8::upgrade($up_nul);
    # check the other combinations too
    is(pack("WH40", 0x100, $up_nul), "\x{100}$twenty_nuls",
       "check pack H zero fills (utf8 target/source)");
    is(pack("H40", ""), $twenty_nuls,
       "check pack H zero fills (utf8 none)");
    is(pack("H40", $up_nul), $twenty_nuls,
       "check pack H zero fills (utf8 source)");
}
@


1.13
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d5 2
a6 2
    @@INC = '../lib';
    require './test.pl';
d15 1
a15 1
plan tests => 14704;
a20 1
my $Is_EBCDIC = (defined $Config{ebcdic} && $Config{ebcdic} eq 'define');
d124 1
a124 1
    $sum = 103 if $Is_EBCDIC;
d317 1
a317 1
    like ($@@, qr/^Cannot compress integer/, "Cannot compress integer");
d869 1
a869 1
           ['a/a*/b*', '212ab', $Is_EBCDIC ? '100000010100' : '100001100100'],
d917 3
a919 5
SKIP: {
    skip("(EBCDIC and) version strings are bad idea", 2) if $Is_EBCDIC;

    is("1.20.300.4000", sprintf "%vd", pack("U*",1,20,300,4000));
    is("1.20.300.4000", sprintf "%vd", pack("  U*",1,20,300,4000));
d921 1
a921 1
isnt(v1.20.300.4000, sprintf "%vd", pack("C0U*",1,20,300,4000));
d923 2
a924 1
my $rslt = $Is_EBCDIC ? "156 67" : "199 162";
d939 9
d949 3
a951 5
SKIP: {
    skip "Not for EBCDIC", 4 if $Is_EBCDIC;

    # does pack U0C create Unicode?
    is("@@{[pack('U0C*', 100, 195, 136)]}", v100.v200);
d954 3
a956 1
    is("@@{[pack('C0U*', 100, 200)]}", pack("C*", 100, 195, 136));
d962 1
a962 1
        my $bad = pack("U0C", 255);
d1285 1
a1285 1
  like( scalar @@warning, 1 );
d1517 4
a1520 1
    my $out = pack("u99", "foo" x 99);
d1535 1
a1535 5
    if (ord('A') == 193) {
	is(unpack("C0%128U", "/bcd"), unpack("U0%128U", "abcd"), "checksum not overflowed");
    } else {
	is(unpack("C0%128U", "abcd"), unpack("U0%128U", "abcd"), "checksum not overflowed");
    }
d1538 1
d1541 1
a1541 1
    my (@@x) = unpack("a(U0)U", "b\341\277\274");
d1545 1
a1545 1
    is(pack("a(U0)U", "b", 8188), "b\341\277\274");
d1550 10
a1559 10
    # (note the length is actually 0 in this test)
    if (ord('A') == 193) {
	is(join(',', unpack("aU0C/UU", "b\0\341\277\274")), 'b,0');
	is(join(',', unpack("aU0C/CU", "b\0\341\277\274")), 'b,0');
    } else {
	is(join(',', unpack("aC/UU",   "b\0\341\277\274")), 'b,8188');
	is(join(',', unpack("aC/CU",   "b\0\341\277\274")), 'b,8188');
	is(join(',', unpack("aU0C/UU", "b\0\341\277\274")), 'b,225');
	is(join(',', unpack("aU0C/CU", "b\0\341\277\274")), 'b,225');
    }
d1794 13
a1806 13
    utf8::upgrade($high = "\xc3\xbeb");
    is(pack("U0a2", $high), "\xfe");
    is(pack("U0A2", $high), "\xfe");
    is(pack("U0Z1", $high), "\x00");
    is(pack("U0a3", $high), "\xfeb");
    is(pack("U0A3", $high), "\xfeb");
    is(pack("U0Z3", $high), "\xfe\x00");
    is(pack("U0a6", $high), "\xfeb\x00\x00\x00");
    is(pack("U0A6", $high), "\xfeb   ");
    is(pack("U0Z6", $high), "\xfeb\x00\x00\x00");
    is(pack("U0a*", $high), "\xfeb");
    is(pack("U0A*", $high), "\xfeb");
    is(pack("U0Z*", $high), "\xfeb\x00");
d1835 1
a1835 1
    is(unpack("A*", "ab \n\xa0 \0"), "ab \n\xa0",
d1837 1
a1837 1
    is(unpack("U0C0A*", "ab \n\xa0 \0"), "ab \n\xa0",
d1998 2
a1999 1
    my ($v) = split //, unpack ('(B)*', 'ab');
d2014 33
@


1.12
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d15 1
a15 1
plan tests => 14700;
a302 2
	   ($^O eq 'mpeix')
	   ||
d817 1
a817 1
  my ($x, $y, $z);
d823 8
@


1.11
log
@merge in perl 5.12.2 plus local changes
@
text
@d15 1
a15 1
plan tests => 14699;
d674 1
a674 1
# the epxected checksum on any system including those where NVs can preserve
d1996 4
@


1.10
log
@Merge in perl 5.10.1; part two
@
text
@d15 1
a15 1
plan tests => 14697;
d1987 8
@


1.9
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d15 1
a15 1
plan tests => 14696;
d1982 5
@


1.8
log
@merge in perl 5.8.8
@
text
@d1 1
a1 2
#!./perl
# FIXME - why isn't this -w clean in maint?
d15 1
a15 1
plan tests => 13864;
d18 1
a18 1
# use warnings;
d46 1
a46 1
  if (defined $Config{"u${size}size"} and $Config{"u${size}size"} != ($size >> 3)) {
d132 1
d372 1
a372 1
  use warnings;
d426 1
a426 1
my @@templates = qw(c C i I s S l L n N v V f d q Q);
d430 1
a430 1
    $base =~ /^[cnv]/i or push @@tmpl, "$base>", "$base<";
d511 1
a511 1
) 
d616 1
a616 1
            # UV arithmetic, or because we're doing a floating point checksum) 
d644 1
d714 4
a717 1
      print "# [$value][$nat][$be][$le][$@@]\n";
d865 1
a865 1
  ) 
d871 1
a871 1
    is($x, $expect) || 
d921 1
a921 1
is(join(" ", unpack("C*", chr(0x1e2))), $rslt);
a938 3
    # does unpack C unravel pack U?
    is("@@{[unpack('C*', pack('U*', 100, 200))]}", "100 195 136");

d947 3
d951 1
a951 1
        my @@null = unpack('U0U', chr(255));
d1006 1
a1006 1
) 
d1026 1
a1026 1
) 
a1196 5
  use warnings;
  my $warning;
  local $SIG{__WARN__} = sub {
      $warning = $_[0];
  };
d1206 1
a1206 1
  # various unpack count/code scenarios 
d1219 1
a1219 1
  
d1235 1
a1235 1
  use warnings;
d1252 1
a1252 1
  # white space where possible 
d1281 2
a1282 2
  is( $s, 'AC' ); 
  is( "@@c", "A C C" ); 
d1305 1
a1305 1
   my @@codes = qw( x A Z a c C B b H h s v n S i I l V N L p P f F d
d1325 1
d1407 1
d1488 1
a1488 3
eval "unpack('c')";
like ($@@, qr/Not enough arguments for unpack/,
      "one-arg unpack (change #18751) is not in maint");
d1491 1
a1491 1
    my $a = "X\t01234567\n" x 100;
d1498 13
d1519 5
a1523 1
    is(unpack("C0%128U", "abcd"), unpack("U0%128U", "abcd"), "checksum not overflowed");
d1530 3
a1532 1
    is($x[1], 225, 'after scope');
d1538 9
a1546 4
    is(join(',', unpack("aC/UU",   "b\0\341\277\274")), 'b,225');
    is(join(',', unpack("aC/CU",   "b\0\341\277\274")), 'b,225');
    is(join(',', unpack("aU0C/UU", "b\0\341\277\274")), 'b,8188');
    is(join(',', unpack("aU0C/CU", "b\0\341\277\274")), 'b,8188');
d1553 429
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d1 2
a2 1
#!./perl -w
d10 7
a16 1
plan tests => 5852;
d19 1
a19 1
use warnings;
d24 41
d228 67
d310 1
a310 1
    my $inf = eval '2**10000';
d347 1
a347 1
       "Round trip pack, unpack 'w' of $big is withing 1% ($quotient%)");
d356 5
a360 1

d363 5
d383 6
a388 1
like(pack("p", undef), qr/^\0+/);
d395 1
a395 1
print "# test the pack lengths of s S i I l L n N v V\n";
d397 23
a419 9
my @@lengths = qw(s 2 S 2 i -4 I -4 l 4 L 4 n 2 N 4 v 2 V 4);
while (my ($format, $expect) = splice @@lengths, 0, 2) {
  my $len = length(pack($format, 0));
  if ($expect > 0) {
    is($expect, $len, "format '$format'");
  } else {
    $expect = -$expect;
    ok ($len >= $expect, "format '$format'") ||
      print "# format '$format' has length $len, expected >= $expect\n";
d428 6
a433 3
foreach my $t (@@templates) {
    SKIP: {
        my @@t = eval { unpack("$t*", pack("$t*", 12, 34)) };
d435 2
a436 3
        # quads not supported everywhere
        skip "Quads not supported", 4 if $@@ =~ /Invalid type/;
        is( $@@, '' );
d438 2
a439 4
        is(scalar @@t, 2);

        SKIP: {
            skip "$t not expected to work for some reason", 2 if $t =~ /[nv]/i;
d532 6
a537 2
  my $format = shift;
  return numbers_with_total ($format, undef, @@_);
d552 2
a553 2
        skip "cannot pack '$format' on this perl", 2 if
          $@@ =~ /Invalid type '$format'/;
d555 2
a556 2
        is($@@, '');
        is($out, $_);
d573 1
a573 1
        if $@@ =~ /Invalid type '$format'/;
d575 2
a576 2
      is($@@, '');
      ok(defined $sum);
d623 1
a623 1
            ok ("unpack '%$_$format' gave $sum");
d638 1
a638 1
    }   
d660 4
d693 119
d948 1
a948 1
        like($@@, /^Malformed UTF-8 character /);
d1057 72
d1289 14
d1312 1
a1312 1
     push @@codes, qw(c C);	# Keep the count the same
d1320 2
d1350 18
a1367 12
	   my $junk1 = "$groupbegin $type$count $groupend";
	   # print "# junk1=$junk1\n";
	   my $p = pack $junk1, @@list2;
	   my $half = int( (length $p)/2 );
	   for my $move ('', "X$half", "X!$half", 'x1', 'x!8', "x$half") {
	     my $junk = "$junk1 $move";
	     # print "# junk='$junk', list=(@@list2)\n";
	     $p = pack "$junk $end", @@list2, @@end;
	     my @@l = unpack "x[$junk] $end", $p;
	     is(scalar @@l, scalar @@end);
	     is("@@l", "@@end", "skipping x[$junk]");
	   }
d1430 1
a1430 1
    skip "Long doubles not in use", 56 if $@@ =~ /Invalid type/;
d1486 4
a1489 1
ok(1, "fake success (change #18751, feature not present in 5.8.1)");
d1497 33
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d9 1
a9 1
plan tests => 5819;
d163 1
a163 1
  # test exceptions
d173 62
d237 1
a237 2
#
# test the "p" template
d266 2
a267 2
# test the pack lengths of s S i I l L
# test the pack lengths of n N v V
d281 2
a282 1
# test unpack-pack lengths
d290 1
a290 1
        skip "Quads not supported", 4 if $@@ =~ /Invalid type in pack/;
d379 1
a379 1
# packing native shorts/ints/longs
d401 1
d406 1
a406 1
          $@@ =~ /Invalid type in pack: '$format'/;
d426 1
a426 1
        if $@@ =~ /Invalid type in pack: '$format'/;
d458 1
a458 1
            my $mult = int ($total / $max_p1);
d535 1
a535 1
# pack nvNV byteorders
d547 1
a547 1
  like($@@, qr!/ must follow a numeric type!);
d550 1
a550 1
  like($@@, qr!/ must follow a numeric type!);
d566 1
a566 1
  like($@@,  qr!Invalid type in pack: '/'!);
d569 1
a569 1
  like($@@,  qr!Invalid type in pack: '/'!);
d809 1
a809 1
    like($@@, qr/P must have an explicit size/);
d850 99
d1066 1
a1066 1
    skip "Long doubles not in use", 56 if $@@ =~ /Invalid type in pack/;
d1080 1
a1080 1
      die unless $@@ =~ /Invalid type in pack: '$template'/;
d1118 12
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d1 1
a1 1
#!./perl
d6 1
a6 1
    require Config; import Config;
d9 1
a9 1
print "1..159\n";
d11 3
a13 6
$format = "c2 x5 C C x s d i l a6";
# Need the expression in here to force ary[5] to be numeric.  This avoids
# test2 failing because ary2 goes str->numeric->str and ary doesn't.
@@ary = (1,-100,127,128,32767,987.654321098 / 100.0,12345,123456,"abcdef");
$foo = pack($format,@@ary);
@@ary2 = unpack($format,$foo);
d15 2
a16 1
print ($#ary == $#ary2 ? "ok 1\n" : "not ok 1\n");
d18 7
a24 6
$out1=join(':',@@ary);
$out2=join(':',@@ary2);
# Using long double NVs may introduce greater accuracy than wanted.
$out1 =~ s/:9\.87654321097999\d*:/:9.87654321098:/;
$out2 =~ s/:9\.87654321097999\d*:/:9.87654321098:/;
print ($out1 eq $out2? "ok 2\n" : "not ok 2\n");
a25 1
print ($foo =~ /def/ ? "ok 3\n" : "not ok 3\n");
d27 12
a38 1
# How about counting bits?
d40 4
a43 2
print +($x = unpack("%32B*", "\001\002\004\010\020\040\100\200\377")) == 16
	? "ok 4\n" : "not ok 4 $x\n";
d45 17
a61 2
print +($x = unpack("%32b69", "\001\002\004\010\020\040\100\200\017")) == 12
	? "ok 5\n" : "not ok 5 $x\n";
d63 3
a65 2
print +($x = unpack("%32B69", "\001\002\004\010\020\040\100\200\017")) == 9
	? "ok 6\n" : "not ok 6 $x\n";
d67 3
a69 2
my $sum = 129; # ASCII
$sum = 103 if ($Config{ebcdic} eq 'define');
d71 1
a71 2
print +($x = unpack("%32B*", "Now is the time for all good blurfl")) == $sum
	? "ok 7\n" : "not ok 7 $x\n";
d73 2
a74 4
open(BIN, "./perl") || open(BIN, "./perl.exe") 
    || die "Can't open ../perl or ../perl.exe: $!\n";
sysread BIN, $foo, 8192;
close BIN;
d76 3
a78 3
$sum = unpack("%32b*", $foo);
$longway = unpack("b*", $foo);
print $sum == $longway =~ tr/1/1/ ? "ok 8\n" : "not ok 8\n";
d80 2
a81 2
print +($x = unpack("I",pack("I", 0xFFFFFFFF))) == 0xFFFFFFFF
	? "ok 9\n" : "not ok 9 $x\n";
d83 9
a91 6
# check 'w'
my $test=10;
my @@x = (5,130,256,560,32000,3097152,268435455,1073741844,
         '4503599627365785','23728385234614992549757750638446');
my $x = pack('w*', @@x);
my $y = pack 'H*', '0581028200843081fa0081bd8440ffffff7f848080801487ffffffffffdb19caefe8e1eeeea0c2e1e3e8ede1ee6e';
d93 4
a96 1
print $x eq $y ? "ok $test\n" : "not ok $test\n"; $test++;
d98 61
a158 5
@@y = unpack('w*', $y);
my $a;
while ($a = pop @@x) {
  my $b = pop @@y;
  print $a eq $b ? "ok $test\n" : "not ok $test\n$a\n$b\n"; $test++;
a160 1
@@y = unpack('w2', $x);
d162 5
a166 2
print scalar(@@y) == 2 ? "ok $test\n" : "not ok $test\n"; $test++;
print $y[1] == 130 ? "ok $test\n" : "not ok $test\n"; $test++;
d168 2
a169 3
# test exeptions
eval { $x = unpack 'w', pack 'C*', 0xff, 0xff};
print $@@ ne '' ? "ok $test\n" : "not ok $test\n"; $test++;
d171 3
a173 5
eval { $x = unpack 'w', pack 'C*', 0xff, 0xff, 0xff, 0xff};
print $@@ ne '' ? "ok $test\n" : "not ok $test\n"; $test++;

eval { $x = unpack 'w', pack 'C*', 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
print $@@ ne '' ? "ok $test\n" : "not ok $test\n"; $test++;
d179 1
a179 1
print((unpack("p",pack("p","foo")) eq "foo" ? "ok " : "not ok "),$test++,"\n");
d182 1
a182 1
print((unpack("p",pack("p",$test)) == $test ? "ok " : "not ok "),$test++,"\n");
d188 1
a188 1
  my $last = $test;
d190 1
a190 1
	print "ok ",$test++,"\n" if $_[0] =~ /temporary val/
d193 2
a194 1
  print "not ok ", $test++, "\n" if $last == $test;
d198 1
a198 1
print((pack("p", undef) =~ /^\0+/ ? "ok " : "not ok "),$test++,"\n");
d203 1
a203 2
# Test 30:
print( ((unpack("i",pack("i",-1))) == -1 ? "ok " : "not ok "),$test++,"\n");
d205 13
a217 9
# 31..36: test the pack lengths of s S i I l L
print "not " unless length(pack("s", 0)) == 2;
print "ok ", $test++, "\n";
 
print "not " unless length(pack("S", 0)) == 2;
print "ok ", $test++, "\n";
 
print "not " unless length(pack("i", 0)) >= 4;
print "ok ", $test++, "\n";
a218 2
print "not " unless length(pack("I", 0)) >= 4;
print "ok ", $test++, "\n";
d220 2
a221 2
print "not " unless length(pack("l", 0)) == 4;
print "ok ", $test++, "\n";
d223 3
a225 2
print "not " unless length(pack("L", 0)) == 4;
print "ok ", $test++, "\n";
d227 14
a240 1
# 37..40: test the pack lengths of n N v V
d242 2
a243 8
print "not " unless length(pack("n", 0)) == 2;
print "ok ", $test++, "\n";

print "not " unless length(pack("N", 0)) == 4;
print "ok ", $test++, "\n";

print "not " unless length(pack("v", 0)) == 2;
print "ok ", $test++, "\n";
d245 4
a248 2
print "not " unless length(pack("V", 0)) == 4;
print "ok ", $test++, "\n";
d250 1
a250 1
# 41..56: test unpack-pack lengths
d252 2
a253 25
my @@templates = qw(c C i I s S l L n N v V f d);

# quads not supported everywhere: if not, retest floats/doubles
# to preserve the test count...
eval { my $q = pack("q",0) };
push @@templates, $@@ !~ /Invalid type in pack/ ? qw(q Q) : qw(f d);

foreach my $t (@@templates) {
    my @@t = unpack("$t*", pack("$t*", 12, 34));
    print "not "
      unless @@t == 2 and (($t[0] == 12 and $t[1] == 34) or ($t =~ /[nv]/i));
    print "ok ", $test++, "\n";
}

# 57..60: uuencode/decode

# Note that first uuencoding known 'text' data and then checking the
# binary values of the uuencoded version would not be portable between
# character sets.  Uuencoding is meant for encoding binary data, not
# text data.
 
$in = pack 'C*', 0 .. 255;

# just to be anal, we do some random tr/`/ /
$uu = <<'EOUU';
d262 4
a265 4
$_ = $uu;
tr/ /`/;
print "not " unless pack('u', $in) eq $_;
print "ok ", $test++, "\n";
d267 1
a267 2
print "not " unless unpack('u', $uu) eq $in;
print "ok ", $test++, "\n";
d269 2
a270 2
$in = "\x1f\x8b\x08\x08\x58\xdc\xc4\x35\x02\x03\x4a\x41\x50\x55\x00\xf3\x2a\x2d\x2e\x51\x48\xcc\xcb\x2f\xc9\x48\x2d\x52\x08\x48\x2d\xca\x51\x28\x2d\x4d\xce\x4f\x49\x2d\xe2\x02\x00\x64\x66\x60\x5c\x1a\x00\x00\x00";
$uu = <<'EOUU';
d275 1
a275 2
print "not " unless unpack('u', $uu) eq $in;
print "ok ", $test++, "\n";
d277 2
a278 1
# 60 identical to 59 except that backquotes have been changed to spaces
d280 1
a280 1
$uu = <<'EOUU';
d282 1
a282 1
&8%P:    
d285 2
a286 2
print "not " unless unpack('u', $uu) eq $in;
print "ok ", $test++, "\n";
d288 1
a288 1
# 61..73: test the ascii template types (A, a, Z)
d290 1
a290 2
print "not " unless pack('A*', "foo\0bar\0 ") eq "foo\0bar\0 ";
print "ok ", $test++, "\n";
d292 186
a477 2
print "not " unless pack('A11', "foo\0bar\0 ") eq "foo\0bar\0   ";
print "ok ", $test++, "\n";
d479 2
a480 2
print "not " unless unpack('A*', "foo\0bar \0") eq "foo\0bar";
print "ok ", $test++, "\n";
d482 63
a544 2
print "not " unless unpack('A8', "foo\0bar \0") eq "foo\0bar";
print "ok ", $test++, "\n";
d546 1
a546 2
print "not " unless pack('a*', "foo\0bar\0 ") eq "foo\0bar\0 ";
print "ok ", $test++, "\n";
d548 5
a552 2
print "not " unless pack('a11', "foo\0bar\0 ") eq "foo\0bar\0 \0\0";
print "ok ", $test++, "\n";
d554 10
a563 2
print "not " unless unpack('a*', "foo\0bar \0") eq "foo\0bar \0";
print "ok ", $test++, "\n";
d565 8
a572 2
print "not " unless unpack('a8', "foo\0bar \0") eq "foo\0bar ";
print "ok ", $test++, "\n";
a573 2
print "not " unless pack('Z*', "foo\0bar\0 ") eq "foo\0bar\0 \0";
print "ok ", $test++, "\n";
d575 2
a576 2
print "not " unless pack('Z11', "foo\0bar\0 ") eq "foo\0bar\0 \0\0";
print "ok ", $test++, "\n";
d578 4
a581 2
print "not " unless pack('Z3', "foo") eq "fo\0";
print "ok ", $test++, "\n";
d583 2
a584 2
print "not " unless unpack('Z*', "foo\0bar \0") eq "foo";
print "ok ", $test++, "\n";
d586 2
a587 2
print "not " unless unpack('Z8', "foo\0bar \0") eq "foo";
print "ok ", $test++, "\n";
d589 2
a590 1
# 74..79: packing native shorts/ints/longs
d592 2
a593 2
print "not " unless length(pack("s!", 0)) == $Config{shortsize};
print "ok ", $test++, "\n";
d595 2
a596 2
print "not " unless length(pack("i!", 0)) == $Config{intsize};
print "ok ", $test++, "\n";
a597 2
print "not " unless length(pack("l!", 0)) == $Config{longsize};
print "ok ", $test++, "\n";
d599 2
a600 2
print "not " unless length(pack("s!", 0)) <= length(pack("i!", 0));
print "ok ", $test++, "\n";
d602 2
a603 2
print "not " unless length(pack("i!", 0)) <= length(pack("l!", 0));
print "ok ", $test++, "\n";
d605 2
a606 2
print "not " unless length(pack("i!", 0)) == length(pack("i", 0));
print "ok ", $test++, "\n";
d608 2
a609 1
# 80..139: pack <-> unpack bijectionism
d611 6
a616 4
#  80.. 84 c
foreach my $c (-128, -1, 0, 1, 127) {
    print "not " unless unpack("c", pack("c", $c)) == $c;
    print "ok ", $test++, "\n";
d619 37
a655 4
#  85.. 89: C
foreach my $C (0, 1, 127, 128, 255) {
    print "not " unless unpack("C", pack("C", $C)) == $C;
    print "ok ", $test++, "\n";
a657 5
#  90.. 94: s
foreach my $s (-32768, -1, 0, 1, 32767) {
    print "not " unless unpack("s", pack("s", $s)) == $s;
    print "ok ", $test++, "\n";
}
d659 45
a703 4
#  95.. 99: S
foreach my $S (0, 1, 32767, 32768, 65535) {
    print "not " unless unpack("S", pack("S", $S)) == $S;
    print "ok ", $test++, "\n";
d706 8
a713 4
#  100..104: i
foreach my $i (-2147483648, -1, 0, 1, 2147483647) {
    print "not " unless unpack("i", pack("i", $i)) == $i;
    print "ok ", $test++, "\n";
d716 2
a717 5
# 105..109: I
foreach my $I (0, 1, 2147483647, 2147483648, 4294967295) {
    print "not " unless unpack("I", pack("I", $I)) == $I;
    print "ok ", $test++, "\n";
}
d719 1
a719 5
# 110..114: l
foreach my $l (-2147483648, -1, 0, 1, 2147483647) {
    print "not " unless unpack("l", pack("l", $l)) == $l;
    print "ok ", $test++, "\n";
}
d721 1
a721 4
# 115..119: L
foreach my $L (0, 1, 2147483647, 2147483648, 4294967295) {
    print "not " unless unpack("L", pack("L", $L)) == $L;
    print "ok ", $test++, "\n";
d724 2
a725 5
# 120..124: n
foreach my $n (0, 1, 32767, 32768, 65535) {
    print "not " unless unpack("n", pack("n", $n)) == $n;
    print "ok ", $test++, "\n";
}
d727 13
a739 4
# 125..129: v
foreach my $v (0, 1, 32767, 32768, 65535) {
    print "not " unless unpack("v", pack("v", $v)) == $v;
    print "ok ", $test++, "\n";
d742 2
a743 5
# 130..134: N
foreach my $N (0, 1, 2147483647, 2147483648, 4294967295) {
    print "not " unless unpack("N", pack("N", $N)) == $N;
    print "ok ", $test++, "\n";
}
d745 2
a746 4
# 135..139: V
foreach my $V (0, 1, 2147483647, 2147483648, 4294967295) {
    print "not " unless unpack("V", pack("V", $V)) == $V;
    print "ok ", $test++, "\n";
d749 131
a879 1
# 140..143: pack nvNV byteorders
d881 5
a885 67
print "not " unless pack("n", 0xdead) eq "\xde\xad";
print "ok ", $test++, "\n";

print "not " unless pack("v", 0xdead) eq "\xad\xde";
print "ok ", $test++, "\n";

print "not " unless pack("N", 0xdeadbeef) eq "\xde\xad\xbe\xef";
print "ok ", $test++, "\n";

print "not " unless pack("V", 0xdeadbeef) eq "\xef\xbe\xad\xde";
print "ok ", $test++, "\n";

# 144..152: /

my $z;
eval { ($x) = unpack '/a*','hello' };
print 'not ' unless $@@; print "ok $test\n"; $test++;
eval { ($z,$x,$y) = unpack 'a3/A C/a* C/Z', "003ok \003yes\004z\000abc" };
print $@@ eq '' && $z eq 'ok' ? "ok $test\n" : "not ok $test\n"; $test++;
print $@@ eq '' && $x eq 'yes' ? "ok $test\n" : "not ok $test\n"; $test++;
print $@@ eq '' && $y eq 'z' ? "ok $test\n" : "not ok $test\n"; $test++;

eval { ($x) = pack '/a*','hello' };
print 'not ' unless $@@; print "ok $test\n"; $test++;
$z = pack 'n/a* N/Z* w/A*','string','hi there ','etc';
print 'not ' unless $z eq "\000\006string\0\0\0\012hi there \000\003etc";
print "ok $test\n"; $test++;

eval { ($x) = unpack 'a/a*/a*', '212ab345678901234567' };
print $@@ eq '' && $x eq 'ab3456789012' ? "ok $test\n" : "#$x,$@@\nnot ok $test\n";
$test++;

eval { ($x) = unpack 'a/a*/a*', '3012ab345678901234567' };
print $@@ eq '' && $x eq 'ab3456789012' ? "ok $test\n" : "not ok $test\n";
$test++;

eval { ($x) = unpack 'a/a*/b*', '212ab' };
my $expected_x = '100001100100';
if ($Config{ebcdic} eq 'define') { $expected_x = '100000010100'; }
print $@@ eq '' && $x eq $expected_x ? "ok $test\n" : "#$x,$@@\nnot ok $test\n";
$test++;

# 153..156: / with #

eval { ($z,$x,$y) = unpack <<EOU, "003ok \003yes\004z\000abc" };
 a3/A			# Count in ASCII
 C/a*			# Count in a C char
 C/Z			# Count in a C char but skip after \0
EOU
print $@@ eq '' && $z eq 'ok' ? "ok $test\n" : "not ok $test\n"; $test++;
print $@@ eq '' && $x eq 'yes' ? "ok $test\n" : "not ok $test\n"; $test++;
print $@@ eq '' && $y eq 'z' ? "ok $test\n" : "not ok $test\n"; $test++;

$z = pack <<EOP,'string','etc';
  n/a*			# Count as network short
  w/A*			# Count a  BER integer
EOP
print 'not ' unless $z eq "\000\006string\003etc"; print "ok $test\n"; $test++;

print 'not ' unless "1.20.300.4000" eq sprintf "%vd", pack("U*",1,20,300,4000); 
print "ok $test\n"; $test++;
print 'not ' unless "1.20.300.4000" eq 
                    sprintf "%vd", pack("  U*",1,20,300,4000); 
print "ok $test\n"; $test++;
print 'not ' unless v1.20.300.4000 ne 
                    sprintf "%vd", pack("C0U*",1,20,300,4000); 
print "ok $test\n"; $test++;
d887 70
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d5 1
a5 1
    unshift @@INC, '../lib' if -d '../lib';
d9 1
a9 1
print "1..156\n";
d375 3
a377 2
$z = pack 'n/a* w/A*','string','etc';
print 'not ' unless $z eq "\000\006string\003etc"; print "ok $test\n"; $test++;
d409 10
@


1.3
log
@perl5.005_03 (stock)
@
text
@d9 1
a9 1
print "1..142\n";
d22 4
a25 1
print ($out1 eq $out2 ? "ok 2\n" : "not ok 2\n");
d101 1
a101 1
  local $^W = 1;
d214 1
a214 1
# 61..72: test the ascii template types (A, a, Z)
d240 1
a240 1
print "not " unless pack('Z*', "foo\0bar\0 ") eq "foo\0bar\0 ";
d246 3
d255 1
a255 1
# 73..78: packing native shorts/ints/longs
d257 1
a257 3
# integrated from mainline and don't want to change numbers all the way
# down. native ints are not supported in _0x so comment out checks
#print "not " unless length(pack("s!", 0)) == $Config{shortsize};
d260 1
a260 1
#print "not " unless length(pack("i!", 0)) == $Config{intsize};
d263 1
a263 1
#print "not " unless length(pack("l!", 0)) == $Config{longsize};
d266 1
a266 1
#print "not " unless length(pack("s!", 0)) <= length(pack("i!", 0));
d269 1
a269 1
#print "not " unless length(pack("i!", 0)) <= length(pack("l!", 0));
d272 1
a272 1
#print "not " unless length(pack("i!", 0)) == length(pack("i", 0));
d275 1
a275 1
# 79..138: pack <-> unpack bijectionism
d277 1
a277 1
#  79.. 83 c
d283 1
a283 1
#  84.. 88: C
d289 1
a289 1
#  89.. 93: s
d295 1
a295 1
#  94.. 98: S
d301 1
a301 1
#  99..103: i
d307 1
a307 1
# 104..108: I
d313 1
a313 1
# 109..113: l
d319 1
a319 1
# 114..118: L
d325 1
a325 1
# 119..123: n
d331 1
a331 1
# 124..128: v
d337 1
a337 1
# 129..133: N
d343 1
a343 1
# 134..138: V
d349 1
a349 1
# 139..142: pack nvNV byteorders
d362 46
@


1.2
log
@perl 5.004_04
@
text
@d3 5
a7 1
# $RCSfile: pack.t,v $$Revision: 4.1 $$Date: 92/08/07 18:28:11 $
d9 1
a9 1
print "1..29\n";
d37 4
a40 1
print +($x = unpack("%32B*", "Now is the time for all good blurfl")) == 129
d110 248
@


1.1
log
@Initial revision
@
text
@d5 1
a5 1
print "1..8\n";
d7 1
a7 1
$format = "c2x5CCxsdila6";
d44 59
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d3 1
a3 5
BEGIN {
    chdir 't' if -d 't';
    unshift @@INC, '../lib' if -d '../lib';
    require Config; import Config;
}
d5 1
a5 1
print "1..142\n";
d7 1
a7 1
$format = "c2 x5 C C x s d i l a6";
d33 1
a33 4
my $sum = 129; # ASCII
$sum = 103 if ($Config{ebcdic} eq 'define');

print +($x = unpack("%32B*", "Now is the time for all good blurfl")) == $sum
a43 307

print +($x = unpack("I",pack("I", 0xFFFFFFFF))) == 0xFFFFFFFF
	? "ok 9\n" : "not ok 9 $x\n";

# check 'w'
my $test=10;
my @@x = (5,130,256,560,32000,3097152,268435455,1073741844,
         '4503599627365785','23728385234614992549757750638446');
my $x = pack('w*', @@x);
my $y = pack 'H*', '0581028200843081fa0081bd8440ffffff7f848080801487ffffffffffdb19caefe8e1eeeea0c2e1e3e8ede1ee6e';

print $x eq $y ? "ok $test\n" : "not ok $test\n"; $test++;

@@y = unpack('w*', $y);
my $a;
while ($a = pop @@x) {
  my $b = pop @@y;
  print $a eq $b ? "ok $test\n" : "not ok $test\n$a\n$b\n"; $test++;
}

@@y = unpack('w2', $x);

print scalar(@@y) == 2 ? "ok $test\n" : "not ok $test\n"; $test++;
print $y[1] == 130 ? "ok $test\n" : "not ok $test\n"; $test++;

# test exeptions
eval { $x = unpack 'w', pack 'C*', 0xff, 0xff};
print $@@ ne '' ? "ok $test\n" : "not ok $test\n"; $test++;

eval { $x = unpack 'w', pack 'C*', 0xff, 0xff, 0xff, 0xff};
print $@@ ne '' ? "ok $test\n" : "not ok $test\n"; $test++;

eval { $x = unpack 'w', pack 'C*', 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
print $@@ ne '' ? "ok $test\n" : "not ok $test\n"; $test++;

#
# test the "p" template

# literals
print((unpack("p",pack("p","foo")) eq "foo" ? "ok " : "not ok "),$test++,"\n");

# scalars
print((unpack("p",pack("p",$test)) == $test ? "ok " : "not ok "),$test++,"\n");

# temps
sub foo { my $a = "a"; return $a . $a++ . $a++ }
{
  local $^W = 1;
  my $last = $test;
  local $SIG{__WARN__} = sub {
	print "ok ",$test++,"\n" if $_[0] =~ /temporary val/
  };
  my $junk = pack("p", &foo);
  print "not ok ", $test++, "\n" if $last == $test;
}

# undef should give null pointer
print((pack("p", undef) =~ /^\0+/ ? "ok " : "not ok "),$test++,"\n");

# Check for optimizer bug (e.g.  Digital Unix GEM cc with -O4 on DU V4.0B gives
#                                4294967295 instead of -1)
#				 see #ifdef __osf__ in pp.c pp_unpack
# Test 30:
print( ((unpack("i",pack("i",-1))) == -1 ? "ok " : "not ok "),$test++,"\n");

# 31..36: test the pack lengths of s S i I l L
print "not " unless length(pack("s", 0)) == 2;
print "ok ", $test++, "\n";
 
print "not " unless length(pack("S", 0)) == 2;
print "ok ", $test++, "\n";
 
print "not " unless length(pack("i", 0)) >= 4;
print "ok ", $test++, "\n";

print "not " unless length(pack("I", 0)) >= 4;
print "ok ", $test++, "\n";

print "not " unless length(pack("l", 0)) == 4;
print "ok ", $test++, "\n";

print "not " unless length(pack("L", 0)) == 4;
print "ok ", $test++, "\n";

# 37..40: test the pack lengths of n N v V

print "not " unless length(pack("n", 0)) == 2;
print "ok ", $test++, "\n";

print "not " unless length(pack("N", 0)) == 4;
print "ok ", $test++, "\n";

print "not " unless length(pack("v", 0)) == 2;
print "ok ", $test++, "\n";

print "not " unless length(pack("V", 0)) == 4;
print "ok ", $test++, "\n";

# 41..56: test unpack-pack lengths

my @@templates = qw(c C i I s S l L n N v V f d);

# quads not supported everywhere: if not, retest floats/doubles
# to preserve the test count...
eval { my $q = pack("q",0) };
push @@templates, $@@ !~ /Invalid type in pack/ ? qw(q Q) : qw(f d);

foreach my $t (@@templates) {
    my @@t = unpack("$t*", pack("$t*", 12, 34));
    print "not "
      unless @@t == 2 and (($t[0] == 12 and $t[1] == 34) or ($t =~ /[nv]/i));
    print "ok ", $test++, "\n";
}

# 57..60: uuencode/decode

# Note that first uuencoding known 'text' data and then checking the
# binary values of the uuencoded version would not be portable between
# character sets.  Uuencoding is meant for encoding binary data, not
# text data.
 
$in = pack 'C*', 0 .. 255;

# just to be anal, we do some random tr/`/ /
$uu = <<'EOUU';
M` $"`P0%!@@<("0H+# T.#Q`1$A,4%187&!D:&QP='A\@@(2(C)"4F)R@@I*BLL
M+2XO,#$R,S0U-C<X.3H[/#T^/T!!0D-$149'2$E*2TQ-3D]045)35%565UA9
M6EM<75Y?8&%B8V1E9F=H:6IK;&UN;W!Q<G-T=79W>'EZ>WQ]?G^`@@8*#A(6&
MAXB)BHN,C8Z/D)&2DY25EI>8F9J;G)V>GZ"AHJ.DI::GJ*FJJZRMKJ^PL;*S
MM+6VM[BYNKN\O;Z_P,'"P\3%QL?(R<K+S,W.S]#1TM/4U=;7V-G:V]S=WM_@@
?X>+CY.7FY^CIZNOL[>[O\/'R\_3U]O?X^?K[_/W^_P `
EOUU

$_ = $uu;
tr/ /`/;
print "not " unless pack('u', $in) eq $_;
print "ok ", $test++, "\n";

print "not " unless unpack('u', $uu) eq $in;
print "ok ", $test++, "\n";

$in = "\x1f\x8b\x08\x08\x58\xdc\xc4\x35\x02\x03\x4a\x41\x50\x55\x00\xf3\x2a\x2d\x2e\x51\x48\xcc\xcb\x2f\xc9\x48\x2d\x52\x08\x48\x2d\xca\x51\x28\x2d\x4d\xce\x4f\x49\x2d\xe2\x02\x00\x64\x66\x60\x5c\x1a\x00\x00\x00";
$uu = <<'EOUU';
M'XL("%C<Q#4"`TI!4%4`\RHM+E%(S,LOR4@@M4@@A(+<I1*"U-SD])+>("`&1F
&8%P:````
EOUU

print "not " unless unpack('u', $uu) eq $in;
print "ok ", $test++, "\n";

# 60 identical to 59 except that backquotes have been changed to spaces

$uu = <<'EOUU';
M'XL("%C<Q#4" TI!4%4 \RHM+E%(S,LOR4@@M4@@A(+<I1*"U-SD])+>(" &1F
&8%P:    
EOUU

print "not " unless unpack('u', $uu) eq $in;
print "ok ", $test++, "\n";

# 61..72: test the ascii template types (A, a, Z)

print "not " unless pack('A*', "foo\0bar\0 ") eq "foo\0bar\0 ";
print "ok ", $test++, "\n";

print "not " unless pack('A11', "foo\0bar\0 ") eq "foo\0bar\0   ";
print "ok ", $test++, "\n";

print "not " unless unpack('A*', "foo\0bar \0") eq "foo\0bar";
print "ok ", $test++, "\n";

print "not " unless unpack('A8', "foo\0bar \0") eq "foo\0bar";
print "ok ", $test++, "\n";

print "not " unless pack('a*', "foo\0bar\0 ") eq "foo\0bar\0 ";
print "ok ", $test++, "\n";

print "not " unless pack('a11', "foo\0bar\0 ") eq "foo\0bar\0 \0\0";
print "ok ", $test++, "\n";

print "not " unless unpack('a*', "foo\0bar \0") eq "foo\0bar \0";
print "ok ", $test++, "\n";

print "not " unless unpack('a8', "foo\0bar \0") eq "foo\0bar ";
print "ok ", $test++, "\n";

print "not " unless pack('Z*', "foo\0bar\0 ") eq "foo\0bar\0 ";
print "ok ", $test++, "\n";

print "not " unless pack('Z11', "foo\0bar\0 ") eq "foo\0bar\0 \0\0";
print "ok ", $test++, "\n";

print "not " unless unpack('Z*', "foo\0bar \0") eq "foo";
print "ok ", $test++, "\n";

print "not " unless unpack('Z8', "foo\0bar \0") eq "foo";
print "ok ", $test++, "\n";

# 73..78: packing native shorts/ints/longs

# integrated from mainline and don't want to change numbers all the way
# down. native ints are not supported in _0x so comment out checks
#print "not " unless length(pack("s!", 0)) == $Config{shortsize};
print "ok ", $test++, "\n";

#print "not " unless length(pack("i!", 0)) == $Config{intsize};
print "ok ", $test++, "\n";

#print "not " unless length(pack("l!", 0)) == $Config{longsize};
print "ok ", $test++, "\n";

#print "not " unless length(pack("s!", 0)) <= length(pack("i!", 0));
print "ok ", $test++, "\n";

#print "not " unless length(pack("i!", 0)) <= length(pack("l!", 0));
print "ok ", $test++, "\n";

#print "not " unless length(pack("i!", 0)) == length(pack("i", 0));
print "ok ", $test++, "\n";

# 79..138: pack <-> unpack bijectionism

#  79.. 83 c
foreach my $c (-128, -1, 0, 1, 127) {
    print "not " unless unpack("c", pack("c", $c)) == $c;
    print "ok ", $test++, "\n";
}

#  84.. 88: C
foreach my $C (0, 1, 127, 128, 255) {
    print "not " unless unpack("C", pack("C", $C)) == $C;
    print "ok ", $test++, "\n";
}

#  89.. 93: s
foreach my $s (-32768, -1, 0, 1, 32767) {
    print "not " unless unpack("s", pack("s", $s)) == $s;
    print "ok ", $test++, "\n";
}

#  94.. 98: S
foreach my $S (0, 1, 32767, 32768, 65535) {
    print "not " unless unpack("S", pack("S", $S)) == $S;
    print "ok ", $test++, "\n";
}

#  99..103: i
foreach my $i (-2147483648, -1, 0, 1, 2147483647) {
    print "not " unless unpack("i", pack("i", $i)) == $i;
    print "ok ", $test++, "\n";
}

# 104..108: I
foreach my $I (0, 1, 2147483647, 2147483648, 4294967295) {
    print "not " unless unpack("I", pack("I", $I)) == $I;
    print "ok ", $test++, "\n";
}

# 109..113: l
foreach my $l (-2147483648, -1, 0, 1, 2147483647) {
    print "not " unless unpack("l", pack("l", $l)) == $l;
    print "ok ", $test++, "\n";
}

# 114..118: L
foreach my $L (0, 1, 2147483647, 2147483648, 4294967295) {
    print "not " unless unpack("L", pack("L", $L)) == $L;
    print "ok ", $test++, "\n";
}

# 119..123: n
foreach my $n (0, 1, 32767, 32768, 65535) {
    print "not " unless unpack("n", pack("n", $n)) == $n;
    print "ok ", $test++, "\n";
}

# 124..128: v
foreach my $v (0, 1, 32767, 32768, 65535) {
    print "not " unless unpack("v", pack("v", $v)) == $v;
    print "ok ", $test++, "\n";
}

# 129..133: N
foreach my $N (0, 1, 2147483647, 2147483648, 4294967295) {
    print "not " unless unpack("N", pack("N", $N)) == $N;
    print "ok ", $test++, "\n";
}

# 134..138: V
foreach my $V (0, 1, 2147483647, 2147483648, 4294967295) {
    print "not " unless unpack("V", pack("V", $V)) == $V;
    print "ok ", $test++, "\n";
}

# 139..142: pack nvNV byteorders

print "not " unless pack("n", 0xdead) eq "\xde\xad";
print "ok ", $test++, "\n";

print "not " unless pack("v", 0xdead) eq "\xad\xde";
print "ok ", $test++, "\n";

print "not " unless pack("N", 0xdeadbeef) eq "\xde\xad\xbe\xef";
print "ok ", $test++, "\n";

print "not " unless pack("V", 0xdeadbeef) eq "\xef\xbe\xad\xde";
print "ok ", $test++, "\n";
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d9 1
a9 1
print "1..156\n";
d22 1
a22 4
# Using long double NVs may introduce greater accuracy than wanted.
$out1 =~ s/:9\.87654321097999\d*:/:9.87654321098:/;
$out2 =~ s/:9\.87654321097999\d*:/:9.87654321098:/;
print ($out1 eq $out2? "ok 2\n" : "not ok 2\n");
d98 1
a98 1
  use warnings;
d211 1
a211 1
# 61..73: test the ascii template types (A, a, Z)
d237 1
a237 1
print "not " unless pack('Z*', "foo\0bar\0 ") eq "foo\0bar\0 \0";
a242 3
print "not " unless pack('Z3', "foo") eq "fo\0";
print "ok ", $test++, "\n";

d249 1
a249 1
# 74..79: packing native shorts/ints/longs
d251 3
a253 1
print "not " unless length(pack("s!", 0)) == $Config{shortsize};
d256 1
a256 1
print "not " unless length(pack("i!", 0)) == $Config{intsize};
d259 1
a259 1
print "not " unless length(pack("l!", 0)) == $Config{longsize};
d262 1
a262 1
print "not " unless length(pack("s!", 0)) <= length(pack("i!", 0));
d265 1
a265 1
print "not " unless length(pack("i!", 0)) <= length(pack("l!", 0));
d268 1
a268 1
print "not " unless length(pack("i!", 0)) == length(pack("i", 0));
d271 1
a271 1
# 80..139: pack <-> unpack bijectionism
d273 1
a273 1
#  80.. 84 c
d279 1
a279 1
#  85.. 89: C
d285 1
a285 1
#  90.. 94: s
d291 1
a291 1
#  95.. 99: S
d297 1
a297 1
#  100..104: i
d303 1
a303 1
# 105..109: I
d309 1
a309 1
# 110..114: l
d315 1
a315 1
# 115..119: L
d321 1
a321 1
# 120..124: n
d327 1
a327 1
# 125..129: v
d333 1
a333 1
# 130..134: N
d339 1
a339 1
# 135..139: V
d345 1
a345 1
# 140..143: pack nvNV byteorders
a357 46

# 144..152: /

my $z;
eval { ($x) = unpack '/a*','hello' };
print 'not ' unless $@@; print "ok $test\n"; $test++;
eval { ($z,$x,$y) = unpack 'a3/A C/a* C/Z', "003ok \003yes\004z\000abc" };
print $@@ eq '' && $z eq 'ok' ? "ok $test\n" : "not ok $test\n"; $test++;
print $@@ eq '' && $x eq 'yes' ? "ok $test\n" : "not ok $test\n"; $test++;
print $@@ eq '' && $y eq 'z' ? "ok $test\n" : "not ok $test\n"; $test++;

eval { ($x) = pack '/a*','hello' };
print 'not ' unless $@@; print "ok $test\n"; $test++;
$z = pack 'n/a* w/A*','string','etc';
print 'not ' unless $z eq "\000\006string\003etc"; print "ok $test\n"; $test++;

eval { ($x) = unpack 'a/a*/a*', '212ab345678901234567' };
print $@@ eq '' && $x eq 'ab3456789012' ? "ok $test\n" : "#$x,$@@\nnot ok $test\n";
$test++;

eval { ($x) = unpack 'a/a*/a*', '3012ab345678901234567' };
print $@@ eq '' && $x eq 'ab3456789012' ? "ok $test\n" : "not ok $test\n";
$test++;

eval { ($x) = unpack 'a/a*/b*', '212ab' };
my $expected_x = '100001100100';
if ($Config{ebcdic} eq 'define') { $expected_x = '100000010100'; }
print $@@ eq '' && $x eq $expected_x ? "ok $test\n" : "#$x,$@@\nnot ok $test\n";
$test++;

# 153..156: / with #

eval { ($z,$x,$y) = unpack <<EOU, "003ok \003yes\004z\000abc" };
 a3/A			# Count in ASCII
 C/a*			# Count in a C char
 C/Z			# Count in a C char but skip after \0
EOU
print $@@ eq '' && $z eq 'ok' ? "ok $test\n" : "not ok $test\n"; $test++;
print $@@ eq '' && $x eq 'yes' ? "ok $test\n" : "not ok $test\n"; $test++;
print $@@ eq '' && $y eq 'z' ? "ok $test\n" : "not ok $test\n"; $test++;

$z = pack <<EOP,'string','etc';
  n/a*			# Count as network short
  w/A*			# Count a  BER integer
EOP
print 'not ' unless $z eq "\000\006string\003etc"; print "ok $test\n"; $test++;
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d5 1
a5 1
    @@INC = '../lib';
d9 1
a9 1
print "1..159\n";
d375 2
a376 3
$z = pack 'n/a* N/Z* w/A*','string','hi there ','etc';
print 'not ' unless $z eq "\000\006string\0\0\0\012hi there \000\003etc";
print "ok $test\n"; $test++;
a407 10

print 'not ' unless "1.20.300.4000" eq sprintf "%vd", pack("U*",1,20,300,4000); 
print "ok $test\n"; $test++;
print 'not ' unless "1.20.300.4000" eq 
                    sprintf "%vd", pack("  U*",1,20,300,4000); 
print "ok $test\n"; $test++;
print 'not ' unless v1.20.300.4000 ne 
                    sprintf "%vd", pack("C0U*",1,20,300,4000); 
print "ok $test\n"; $test++;

@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d1 1
a1 1
#!./perl -w
d6 1
a6 1
    require './test.pl';
d9 1
a9 1
plan tests => 5819;
d11 6
a16 3
use strict;
use warnings;
use Config;
d18 1
a18 2
my $Is_EBCDIC = (defined $Config{ebcdic} && $Config{ebcdic} eq 'define');
my $Perl = which_perl();
d20 8
a27 7
sub encode_list {
  my @@result = map {_qq($_)} @@_;
  if (@@result == 1) {
    return @@result;
  }
  return '(' . join (', ', @@result) . ')';
}
d29 1
d31 2
a32 12
sub list_eq ($$) {
  my ($l, $r) = @@_;
  return 0 unless @@$l == @@$r;
  for my $i (0..$#$l) {
    if (defined $l->[$i]) {
      return 0 unless defined ($r->[$i]) && $l->[$i] eq $r->[$i];
    } else {
      return 0 if defined $r->[$i]
    }
  }
  return 1;
}
d34 2
a35 4
##############################################################################
#
# Here starteth the tests
#
d37 2
a38 17
{
    my $format = "c2 x5 C C x s d i l a6";
    # Need the expression in here to force ary[5] to be numeric.  This avoids
    # test2 failing because ary2 goes str->numeric->str and ary doesn't.
    my @@ary = (1,-100,127,128,32767,987.654321098 / 100.0,12345,123456,
               "abcdef");
    my $foo = pack($format,@@ary);
    my @@ary2 = unpack($format,$foo);

    is($#ary, $#ary2);

    my $out1=join(':',@@ary);
    my $out2=join(':',@@ary2);
    # Using long double NVs may introduce greater accuracy than wanted.
    $out1 =~ s/:9\.87654321097999\d*:/:9.87654321098:/;
    $out2 =~ s/:9\.87654321097999\d*:/:9.87654321098:/;
    is($out1, $out2);
d40 2
a41 3
    like($foo, qr/def/);
}
# How about counting bits?
d43 2
a44 3
{
    my $x;
    is( ($x = unpack("%32B*", "\001\002\004\010\020\040\100\200\377")), 16 );
d46 4
a49 1
    is( ($x = unpack("%32b69", "\001\002\004\010\020\040\100\200\017")), 12 );
d51 3
a53 2
    is( ($x = unpack("%32B69", "\001\002\004\010\020\040\100\200\017")), 9 );
}
d55 2
a56 3
{
    my $sum = 129; # ASCII
    $sum = 103 if $Is_EBCDIC;
d58 6
a63 2
    my $x;
    is( ($x = unpack("%32B*", "Now is the time for all good blurfl")), $sum );
d65 1
a65 9
    my $foo;
    open(BIN, $Perl) || die "Can't open $Perl: $!\n";
    sysread BIN, $foo, 8192;
    close BIN;

    $sum = unpack("%32b*", $foo);
    my $longway = unpack("b*", $foo);
    is( $sum, $longway =~ tr/1/1/ );
}
d67 5
a71 3
{
  my $x;
  is( ($x = unpack("I",pack("I", 0xFFFFFFFF))), 0xFFFFFFFF );
d74 1
a74 62
{
    # check 'w'
    my @@x = (5,130,256,560,32000,3097152,268435455,1073741844, 2**33,
             '4503599627365785','23728385234614992549757750638446');
    my $x = pack('w*', @@x);
    my $y = pack 'H*', '0581028200843081fa0081bd8440ffffff7f8480808014A0808'.
                       '0800087ffffffffffdb19caefe8e1eeeea0c2e1e3e8ede1ee6e';

    is($x, $y);

    my @@y = unpack('w*', $y);
    my $a;
    while ($a = pop @@x) {
        my $b = pop @@y;
        is($a, $b);
    }

    @@y = unpack('w2', $x);

    is(scalar(@@y), 2);
    is($y[1], 130);
    $x = pack('w*', 5000000000); $y = '';
    eval {
    use Math::BigInt;
    $y = pack('w*', Math::BigInt::->new(5000000000));
    };
    is($x, $y);

    $x = pack 'w', ~0;
    $y = pack 'w', (~0).'';
    is($x, $y);
    is(unpack ('w',$x), ~0);
    is(unpack ('w',$y), ~0);

    $x = pack 'w', ~0 - 1;
    $y = pack 'w', (~0) - 2;

    if (~0 - 1 == (~0) - 2) {
        is($x, $y, "NV arithmetic");
    } else {
        isnt($x, $y, "IV/NV arithmetic");
    }
    cmp_ok(unpack ('w',$x), '==', ~0 - 1);
    cmp_ok(unpack ('w',$y), '==', ~0 - 2);

    # These should spot that pack 'w' is using NV, not double, on platforms
    # where IVs are smaller than doubles, and harmlessly pass elsewhere.
    # (tests for change 16861)
    my $x0 = 2**54+3;
    my $y0 = 2**54-2;

    $x = pack 'w', $x0;
    $y = pack 'w', $y0;

    if ($x0 == $y0) {
        is($x, $y, "NV arithmetic");
    } else {
        isnt($x, $y, "IV/NV arithmetic");
    }
    cmp_ok(unpack ('w',$x), '==', $x0);
    cmp_ok(unpack ('w',$y), '==', $y0);
}
d76 2
d79 3
a81 5
{
  # test exceptions
  my $x;
  eval { $x = unpack 'w', pack 'C*', 0xff, 0xff};
  like($@@, qr/^Unterminated compressed integer/);
d83 2
a84 2
  eval { $x = unpack 'w', pack 'C*', 0xff, 0xff, 0xff, 0xff};
  like($@@, qr/^Unterminated compressed integer/);
d86 2
a87 3
  eval { $x = unpack 'w', pack 'C*', 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
  like($@@, qr/^Unterminated compressed integer/);
}
d93 1
a93 1
is(unpack("p",pack("p","foo")), "foo");
d96 1
a96 1
is(unpack("p",pack("p",239)), 239);
d102 1
a102 1
  my $warning;
d104 1
a104 1
      $warning = $_[0];
d107 1
a107 2

  like($warning, qr/temporary val/);
d111 1
a111 1
like(pack("p", undef), qr/^\0+/);
d116 12
a127 1
is((unpack("i",pack("i",-1))), -1);
d129 13
a141 13
# test the pack lengths of s S i I l L
# test the pack lengths of n N v V
my @@lengths = qw(s 2 S 2 i -4 I -4 l 4 L 4 n 2 N 4 v 2 V 4);
while (my ($format, $expect) = splice @@lengths, 0, 2) {
  my $len = length(pack($format, 0));
  if ($expect > 0) {
    is($expect, $len, "format '$format'");
  } else {
    $expect = -$expect;
    ok ($len >= $expect, "format '$format'") ||
      print "# format '$format' has length $len, expected >= $expect\n";
  }
}
d143 2
d146 2
a147 2
# test unpack-pack lengths
my @@templates = qw(c C i I s S l L n N v V f d q Q);
d149 2
a150 3
foreach my $t (@@templates) {
    SKIP: {
        my @@t = eval { unpack("$t*", pack("$t*", 12, 34)) };
d152 1
a152 14
        # quads not supported everywhere
        skip "Quads not supported", 4 if $@@ =~ /Invalid type in pack/;
        is( $@@, '' );

        is(scalar @@t, 2);

        SKIP: {
            skip "$t not expected to work for some reason", 2 if $t =~ /[nv]/i;

            is($t[0], 12);
            is($t[1], 34);
        }
    }
}
d154 1
a154 2
{
    # uuencode/decode
d156 4
a159 4
    # Note that first uuencoding known 'text' data and then checking the
    # binary values of the uuencoded version would not be portable between
    # character sets.  Uuencoding is meant for encoding binary data, not
    # text data.
d161 15
a175 1
    my $in = pack 'C*', 0 .. 255;
d177 2
a178 2
    # just to be anal, we do some random tr/`/ /
    my $uu = <<'EOUU';
d187 4
a190 4
    $_ = $uu;
    tr/ /`/;

    is(pack('u', $in), $_);
d192 2
a193 1
    is(unpack('u', $uu), $in);
d195 2
a196 2
    $in = "\x1f\x8b\x08\x08\x58\xdc\xc4\x35\x02\x03\x4a\x41\x50\x55\x00\xf3\x2a\x2d\x2e\x51\x48\xcc\xcb\x2f\xc9\x48\x2d\x52\x08\x48\x2d\xca\x51\x28\x2d\x4d\xce\x4f\x49\x2d\xe2\x02\x00\x64\x66\x60\x5c\x1a\x00\x00\x00";
    $uu = <<'EOUU';
d201 2
a202 1
    is(unpack('u', $uu), $in);
d204 1
a204 2
# This is identical to the above except that backquotes have been
# changed to spaces
d206 1
a206 1
    $uu = <<'EOUU';
d208 1
a208 1
&8%P:
d211 2
a212 2
    # ' # Grr
    is(unpack('u', $uu), $in);
d214 1
a214 1
}
d216 2
a217 1
# test the ascii template types (A, a, Z)
d219 2
a220 186
foreach (
['p', 'A*',  "foo\0bar\0 ", "foo\0bar\0 "],
['p', 'A11', "foo\0bar\0 ", "foo\0bar\0   "],
['u', 'A*',  "foo\0bar \0", "foo\0bar"],
['u', 'A8',  "foo\0bar \0", "foo\0bar"],
['p', 'a*',  "foo\0bar\0 ", "foo\0bar\0 "],
['p', 'a11', "foo\0bar\0 ", "foo\0bar\0 \0\0"],
['u', 'a*',  "foo\0bar \0", "foo\0bar \0"],
['u', 'a8',  "foo\0bar \0", "foo\0bar "],
['p', 'Z*',  "foo\0bar\0 ", "foo\0bar\0 \0"],
['p', 'Z11', "foo\0bar\0 ", "foo\0bar\0 \0\0"],
['p', 'Z3',  "foo",         "fo\0"],
['u', 'Z*',  "foo\0bar \0", "foo"],
['u', 'Z8',  "foo\0bar \0", "foo"],
) 
{
    my ($what, $template, $in, $out) = @@$_;
    my $got = $what eq 'u' ? (unpack $template, $in) : (pack $template, $in);
    unless (is($got, $out)) {
        my $un = $what eq 'u' ? 'un' : '';
        print "# ${un}pack ('$template', "._qq($in).') gave '._qq($out).
            ' not '._qq($got)."\n";
    }
}

# packing native shorts/ints/longs

is(length(pack("s!", 0)), $Config{shortsize});
is(length(pack("i!", 0)), $Config{intsize});
is(length(pack("l!", 0)), $Config{longsize});
ok(length(pack("s!", 0)) <= length(pack("i!", 0)));
ok(length(pack("i!", 0)) <= length(pack("l!", 0)));
is(length(pack("i!", 0)), length(pack("i", 0)));

sub numbers {
  my $format = shift;
  return numbers_with_total ($format, undef, @@_);
}

sub numbers_with_total {
  my $format = shift;
  my $total = shift;
  if (!defined $total) {
    foreach (@@_) {
      $total += $_;
    }
  }
  foreach (@@_) {
    SKIP: {
        my $out = eval {unpack($format, pack($format, $_))};
        skip "cannot pack '$format' on this perl", 2 if
          $@@ =~ /Invalid type in pack: '$format'/;

        is($@@, '');
        is($out, $_);
    }
  }

  my $skip_if_longer_than = ~0; # "Infinity"
  if (~0 - 1 == ~0) {
    # If we're running with -DNO_PERLPRESERVE_IVUV and NVs don't preserve all
    # UVs (in which case ~0 is NV, ~0-1 will be the same NV) then we can't
    # correctly in perl calculate UV totals for long checksums, as pp_unpack
    # is using UV maths, and we've only got NVs.
    $skip_if_longer_than = $Config{nv_preserves_uv_bits};
  }

  foreach ('', 1, 2, 3, 15, 16, 17, 31, 32, 33, 53, 54, 63, 64, 65) {
    SKIP: {
      my $sum = eval {unpack "%$_$format*", pack "$format*", @@_};
      skip "cannot pack '$format' on this perl", 3
        if $@@ =~ /Invalid type in pack: '$format'/;

      is($@@, '');
      ok(defined $sum);

      my $len = $_; # Copy, so that we can reassign ''
      $len = 16 unless length $len;

      SKIP: {
        skip "cannot test checksums over $skip_if_longer_than bits", 1
          if $len > $skip_if_longer_than;

        # Our problem with testing this portably is that the checksum code in
        # pp_unpack is able to cast signed to unsigned, and do modulo 2**n
        # arithmetic in unsigned ints, which perl has no operators to do.
        # (use integer; does signed ints, which won't wrap on UTS, which is just
        # fine with ANSI, but not with most people's assumptions.
        # This is why we need to supply the totals for 'Q' as there's no way in
        # perl to calculate them, short of unpack '%0Q' (is that documented?)
        # ** returns NVs; make sure it's IV.
        my $max = 1 + 2 * (int (2 ** ($len-1))-1); # The max possible checksum
        my $max_p1 = $max + 1;
        my ($max_is_integer, $max_p1_is_integer);
        $max_p1_is_integer = 1 unless $max_p1 + 1 == $max_p1;
        $max_is_integer = 1 if $max - 1 < ~0;

        my $calc_sum;
        if (ref $total) {
            $calc_sum = &$total($len);
        } else {
            $calc_sum = $total;
            # Shift into range by some multiple of the total
            my $mult = int ($total / $max_p1);
            # Need this to make sure that -1 + (~0+1) is ~0 (ie still integer)
            $calc_sum = $total - $mult;
            $calc_sum -= $mult * $max;
            if ($calc_sum < 0) {
                $calc_sum += 1;
                $calc_sum += $max;
            }
        }
        if ($calc_sum == $calc_sum - 1 && $calc_sum == $max_p1) {
            # we're into floating point (either by getting out of the range of
            # UV arithmetic, or because we're doing a floating point checksum) 
            # and our calculation of the checksum has become rounded up to
            # max_checksum + 1
            $calc_sum = 0;
        }

        if ($calc_sum == $sum) { # HAS to be ==, not eq (so no is()).
            ok ("unpack '%$_$format' gave $sum");
        } else {
            my $delta = 1.000001;
            if ($format =~ tr /dDfF//
                && ($calc_sum <= $sum * $delta && $calc_sum >= $sum / $delta)) {
                pass ("unpack '%$_$format' gave $sum, expected $calc_sum");
            } else {
                my $text = ref $total ? &$total($len) : $total;
                fail;
                print "# For list (" . join (", ", @@_) . ") (total $text)"
                    . " packed with $format unpack '%$_$format' gave $sum,"
                    . " expected $calc_sum\n";
            }
        }
      }
    }   
  }
}

numbers ('c', -128, -1, 0, 1, 127);
numbers ('C', 0, 1, 127, 128, 255);
numbers ('s', -32768, -1, 0, 1, 32767);
numbers ('S', 0, 1, 32767, 32768, 65535);
numbers ('i', -2147483648, -1, 0, 1, 2147483647);
numbers ('I', 0, 1, 2147483647, 2147483648, 4294967295);
numbers ('l', -2147483648, -1, 0, 1, 2147483647);
numbers ('L', 0, 1, 2147483647, 2147483648, 4294967295);
numbers ('s!', -32768, -1, 0, 1, 32767);
numbers ('S!', 0, 1, 32767, 32768, 65535);
numbers ('i!', -2147483648, -1, 0, 1, 2147483647);
numbers ('I!', 0, 1, 2147483647, 2147483648, 4294967295);
numbers ('l!', -2147483648, -1, 0, 1, 2147483647);
numbers ('L!', 0, 1, 2147483647, 2147483648, 4294967295);
numbers ('n', 0, 1, 32767, 32768, 65535);
numbers ('v', 0, 1, 32767, 32768, 65535);
numbers ('N', 0, 1, 2147483647, 2147483648, 4294967295);
numbers ('V', 0, 1, 2147483647, 2147483648, 4294967295);
# All these should have exact binary representations:
numbers ('f', -1, 0, 0.5, 42, 2**34);
numbers ('d', -(2**34), -1, 0, 1, 2**34);
## These don't, but 'd' is NV.  XXX wrong, it's double
#numbers ('d', -1, 0, 1, 1-exp(-1), -exp(1));

numbers_with_total ('q', -1,
                    -9223372036854775808, -1, 0, 1,9223372036854775807);
# This total is icky, but the true total is 2**65-1, and need a way to generate
# the epxected checksum on any system including those where NVs can preserve
# 65 bits. (long double is 128 bits on sparc, so they certainly can)
# or where rounding is down not up on binary conversion (crays)
numbers_with_total ('Q', sub {
                      my $len = shift;
                      $len = 65 if $len > 65; # unmasked total is 2**65-1 here
                      my $total = 1 + 2 * (int (2**($len - 1)) - 1);
                      return 0 if $total == $total - 1; # Overflowed integers
                      return $total; # NVs still accurate to nearest integer
                    },
                    0, 1,9223372036854775807, 9223372036854775808,
                    18446744073709551615);

# pack nvNV byteorders

is(pack("n", 0xdead), "\xde\xad");
is(pack("v", 0xdead), "\xad\xde");
is(pack("N", 0xdeadbeef), "\xde\xad\xbe\xef");
is(pack("V", 0xdeadbeef), "\xef\xbe\xad\xde");
d222 2
a223 2
{
  # /
d225 2
a226 63
  my ($x, $y, $z);
  eval { ($x) = unpack '/a*','hello' };
  like($@@, qr!/ must follow a numeric type!);
  undef $x;
  eval { $x = unpack '/a*','hello' };
  like($@@, qr!/ must follow a numeric type!);

  undef $x;
  eval { ($z,$x,$y) = unpack 'a3/A C/a* C/Z', "003ok \003yes\004z\000abc" };
  is($@@, '');
  is($z, 'ok');
  is($x, 'yes');
  is($y, 'z');
  undef $z;
  eval { $z = unpack 'a3/A C/a* C/Z', "003ok \003yes\004z\000abc" };
  is($@@, '');
  is($z, 'ok');


  undef $x;
  eval { ($x) = pack '/a*','hello' };
  like($@@,  qr!Invalid type in pack: '/'!);
  undef $x;
  eval { $x = pack '/a*','hello' };
  like($@@,  qr!Invalid type in pack: '/'!);

  $z = pack 'n/a* N/Z* w/A*','string','hi there ','etc';
  my $expect = "\000\006string\0\0\0\012hi there \000\003etc";
  is($z, $expect);

  undef $x;
  $expect = 'hello world';
  eval { ($x) = unpack ("w/a", chr (11) . "hello world!")};
  is($x, $expect);
  is($@@, '');

  undef $x;
  # Doing this in scalar context used to fail.
  eval { $x = unpack ("w/a", chr (11) . "hello world!")};
  is($@@, '');
  is($x, $expect);

  foreach (
           ['a/a*/a*', '212ab345678901234567','ab3456789012'],
           ['a/a*/a*', '3012ab345678901234567', 'ab3456789012'],
           ['a/a*/b*', '212ab', $Is_EBCDIC ? '100000010100' : '100001100100'],
  ) 
  {
    my ($pat, $in, $expect) = @@$_;
    undef $x;
    eval { ($x) = unpack $pat, $in };
    is($@@, '');
    is($x, $expect) || 
      printf "# list unpack ('$pat', '$in') gave %s, expected '$expect'\n",
             encode_list ($x);

    undef $x;
    eval { $x = unpack $pat, $in };
    is($@@, '');
    is($x, $expect) ||
      printf "# scalar unpack ('$pat', '$in') gave %s, expected '$expect'\n",
             encode_list ($x);
  }
d228 2
a229 1
  # / with #
d231 2
a232 5
  my $pattern = <<'EOU';
 a3/A			# Count in ASCII
 C/a*			# Count in a C char
 C/Z			# Count in a C char but skip after \0
EOU
d234 2
a235 10
  $x = $y = $z =undef;
  eval { ($z,$x,$y) = unpack $pattern, "003ok \003yes\004z\000abc" };
  is($@@, '');
  is($z, 'ok');
  is($x, 'yes');
  is($y, 'z');
  undef $x;
  eval { $z = unpack $pattern, "003ok \003yes\004z\000abc" };
  is($@@, '');
  is($z, 'ok');
d237 2
a238 8
  $pattern = <<'EOP';
  n/a*			# Count as network short
  w/A*			# Count a  BER integer
EOP
  $expect = "\000\006string\003etc";
  $z = pack $pattern,'string','etc';
  is($z, $expect);
}
d240 2
d243 2
a244 2
SKIP: {
    skip("(EBCDIC and) version strings are bad idea", 2) if $Is_EBCDIC;
d246 2
a247 4
    is("1.20.300.4000", sprintf "%vd", pack("U*",1,20,300,4000));
    is("1.20.300.4000", sprintf "%vd", pack("  U*",1,20,300,4000));
}
isnt(v1.20.300.4000, sprintf "%vd", pack("C0U*",1,20,300,4000));
d249 2
a250 2
my $rslt = $Is_EBCDIC ? "156 67" : "199 162";
is(join(" ", unpack("C*", chr(0x1e2))), $rslt);
d252 2
a253 2
# does pack U create Unicode?
is(ord(pack('U', 300)), 300);
d255 1
a255 2
# does unpack U deref Unicode?
is((unpack('U', chr(300)))[0], 300);
d257 2
a258 2
# is unpack U the reverse of pack U for Unicode string?
is("@@{[unpack('U*', pack('U*', 100, 200, 300))]}", "100 200 300");
d260 2
a261 2
# is unpack U the reverse of pack U for byte string?
is("@@{[unpack('U*', pack('U*', 100, 200))]}", "100 200");
d263 2
d266 2
a267 2
SKIP: {
    skip "Not for EBCDIC", 4 if $Is_EBCDIC;
d269 2
a270 2
    # does unpack C unravel pack U?
    is("@@{[unpack('C*', pack('U*', 100, 200))]}", "100 195 136");
d272 2
a273 2
    # does pack U0C create Unicode?
    is("@@{[pack('U0C*', 100, 195, 136)]}", v100.v200);
d275 1
a275 2
    # does pack C0U create characters?
    is("@@{[pack('C0U*', 100, 200)]}", pack("C*", 100, 195, 136));
d277 4
a280 6
    # does unpack U0U on byte data warn?
    {
        local $SIG{__WARN__} = sub { $@@ = "@@_" };
        my @@null = unpack('U0U', chr(255));
        like($@@, /^Malformed UTF-8 character /);
    }
d283 4
a286 37
{
  my $p = pack 'i*', -2147483648, ~0, 0, 1, 2147483647;
  my (@@a);
  # bug - % had to be at the start of the pattern, no leading whitespace or
  # comments. %i! didn't work at all.
  foreach my $pat ('%32i*', ' %32i*', "# Muhahahaha\n%32i*", '%32i*  ',
                   '%32i!*', ' %32i!*', "\n#\n#\n\r \t\f%32i!*", '%32i!*#') {
    @@a = unpack $pat, $p;
    is($a[0], 0xFFFFFFFF) || print "# $pat\n";
    @@a = scalar unpack $pat, $p;
    is($a[0], 0xFFFFFFFF) || print "# $pat\n";
  }


  $p = pack 'I*', 42, 12;
  # Multiline patterns in scalar context failed.
  foreach my $pat ('I', <<EOPOEMSNIPPET, 'I#I', 'I # I', 'I # !!!') {
# On the Ning Nang Nong
# Where the Cows go Bong!
# And the Monkeys all say Boo!
I
EOPOEMSNIPPET
    @@a = unpack $pat, $p;
    is(scalar @@a, 1);
    is($a[0], 42);
    @@a = scalar unpack $pat, $p;
    is(scalar @@a, 1);
    is($a[0], 42);
  }

  # shorts (of all flavours) didn't calculate checksums > 32 bits with floating
  # point, so a pathologically long pattern would wrap at 32 bits.
  my $pat = "\xff\xff"x65538; # Start with it long, to save any copying.
  foreach (4,3,2,1,0) {
    my $len = 65534 + $_;
    is(unpack ("%33n$len", $pat), 65535 * $len);
  }
d289 5
d295 4
a298 45
# pack x X @@
foreach (
         ['x', "N", "\0"],
         ['x4', "N", "\0"x4],
         ['xX', "N", ""],
         ['xXa*', "Nick", "Nick"],
         ['a5Xa5', "cameL", "llama", "camellama"],
         ['@@4', 'N', "\0"x4],
         ['a*@@8a*', 'Camel', 'Dromedary', "Camel\0\0\0Dromedary"],
         ['a*@@4a', 'Perl rules', '!', 'Perl!'],
) 
{
  my ($template, @@in) = @@$_;
  my $out = pop @@in;
  my $got = eval {pack $template, @@in};
  is($@@, '');
  is($out, $got) ||
    printf "# pack ('$template', %s) gave %s expected %s\n",
           encode_list (@@in), encode_list ($got), encode_list ($out);
}

# unpack x X @@
foreach (
         ['x', "N"],
         ['xX', "N"],
         ['xXa*', "Nick", "Nick"],
         ['a5Xa5', "camellama", "camel", "llama"],
         ['@@3', "ice"],
         ['@@2a2', "water", "te"],
         ['a*@@1a3', "steam", "steam", "tea"],
) 
{
  my ($template, $in, @@out) = @@$_;
  my @@got = eval {unpack $template, $in};
  is($@@, '');
  ok (list_eq (\@@got, \@@out)) ||
    printf "# list unpack ('$template', %s) gave %s expected %s\n",
           _qq($in), encode_list (@@got), encode_list (@@out);

  my $got = eval {unpack $template, $in};
  is($@@, '');
  @@out ? is( $got, $out[0] ) # 1 or more items; should get first
       : ok( !defined $got ) # 0 items; should get undef
    or printf "# scalar unpack ('$template', %s) gave %s expected %s\n",
              _qq($in), encode_list ($got), encode_list ($out[0]);
d301 4
a304 8
{
    my $t = 'Z*Z*';
    my ($u, $v) = qw(foo xyzzy);
    my $p = pack($t, $u, $v);
    my @@u = unpack($t, $p);
    is(scalar @@u, 2);
    is($u[0], $u);
    is($u[1], $v);
d307 5
a311 2
{
    is((unpack("w/a*", "\x02abc"))[0], "ab");
d313 5
a317 1
    # "w/a*" should be seen as one unit
d319 4
a322 1
    is(scalar unpack("w/a*", "\x02abc"), "ab");
d325 5
a329 2
{
    # from Wolfgang Laun: fix in change #13163
d331 4
a334 13
    my $s = 'ABC' x 10;
    my $t = '*';
    my $x = ord($t);
    my $buf = pack( 'Z*/A* C',  $s, $x );
    my $y;

    my $h = $buf;
    $h =~ s/[^[:print:]]/./g;
    ( $s, $y ) = unpack( "Z*/A* C", $buf );
    is($h, "30.ABCABCABCABCABCABCABCABCABCABC$t");
    is(length $buf, 34);
    is($s, "ABCABCABCABCABCABCABCABCABCABC");
    is($y, $x);
d337 5
a341 2
{
    # from Wolfgang Laun: fix in change #13288
d343 4
a346 2
    eval { my $t=unpack("P*", "abc") };
    like($@@, qr/P must have an explicit size/);
d349 13
a361 131
{   # Grouping constructs
    my (@@a, @@b);
    @@a = unpack '(SL)',   pack 'SLSLSL', 67..90;
    is("@@a", "67 68");
    @@a = unpack '(SL)3',   pack 'SLSLSL', 67..90;
    @@b = (67..72);
    is("@@a", "@@b");
    @@a = unpack '(SL)3',   pack 'SLSLSLSL', 67..90;
    is("@@a", "@@b");
    @@a = unpack '(SL)[3]', pack 'SLSLSLSL', 67..90;
    is("@@a", "@@b");
    @@a = unpack '(SL)[2] SL', pack 'SLSLSLSL', 67..90;
    is("@@a", "@@b");
    @@a = unpack 'A/(SL)',  pack 'ASLSLSLSL', 3, 67..90;
    is("@@a", "@@b");
    @@a = unpack 'A/(SL)SL',  pack 'ASLSLSLSL', 2, 67..90;
    is("@@a", "@@b");
    @@a = unpack '(SL)*',   pack 'SLSLSLSL', 67..90;
    @@b = (67..74);
    is("@@a", "@@b");
    @@a = unpack '(SL)*SL',   pack 'SLSLSLSL', 67..90;
    is("@@a", "@@b");
    eval { @@a = unpack '(*SL)',   '' };
    like($@@, qr/\(\)-group starts with a count/);
    eval { @@a = unpack '(3SL)',   '' };
    like($@@, qr/\(\)-group starts with a count/);
    eval { @@a = unpack '([3]SL)',   '' };
    like($@@, qr/\(\)-group starts with a count/);
    eval { @@a = pack '(*SL)' };
    like($@@, qr/\(\)-group starts with a count/);
    @@a = unpack '(SL)3 SL',   pack '(SL)4', 67..74;
    is("@@a", "@@b");
    @@a = unpack '(SL)3 SL',   pack '(SL)[4]', 67..74;
    is("@@a", "@@b");
    @@a = unpack '(SL)3 SL',   pack '(SL)*', 67..74;
    is("@@a", "@@b");
}

{  # Repeat count [SUBEXPR]
   my @@codes = qw( x A Z a c C B b H h s v n S i I l V N L p P f F d
		   s! S! i! I! l! L! j J);
   my $G;
   if (eval { pack 'q', 1 } ) {
     push @@codes, qw(q Q);
   } else {
     push @@codes, qw(c C);	# Keep the count the same
   }
   if (eval { pack 'D', 1 } ) {
     push @@codes, 'D';
   } else {
     push @@codes, 'd';	# Keep the count the same
   }

   my %val;
   @@val{@@codes} = map { / [Xx]  (?{ undef })
			| [AZa] (?{ 'something' })
			| C     (?{ 214 })
			| c     (?{ 114 })
			| [Bb]  (?{ '101' })
			| [Hh]  (?{ 'b8' })
			| [svnSiIlVNLqQjJ]  (?{ 10111 })
			| [FfDd]  (?{ 1.36514538e67 })
			| [pP]  (?{ "try this buffer" })
			/x; $^R } @@codes;
   my @@end = (0x12345678, 0x23456781, 0x35465768, 0x15263748);
   my $end = "N4";

   for my $type (@@codes) {
     my @@list = $val{$type};
     @@list = () unless defined $list[0];
     for my $count ('', '3', '[11]') {
       my $c = 1;
       $c = $1 if $count =~ /(\d+)/;
       my @@list1 = @@list;
       @@list1 = (@@list1) x $c unless $type =~ /[XxAaZBbHhP]/;
       for my $groupend ('', ')2', ')[8]') {
	   my $groupbegin = ($groupend ? '(' : '');
	   $c = 1;
	   $c = $1 if $groupend =~ /(\d+)/;
	   my @@list2 = (@@list1) x $c;

	   my $junk1 = "$groupbegin $type$count $groupend";
	   # print "# junk1=$junk1\n";
	   my $p = pack $junk1, @@list2;
	   my $half = int( (length $p)/2 );
	   for my $move ('', "X$half", "X!$half", 'x1', 'x!8', "x$half") {
	     my $junk = "$junk1 $move";
	     # print "# junk='$junk', list=(@@list2)\n";
	     $p = pack "$junk $end", @@list2, @@end;
	     my @@l = unpack "x[$junk] $end", $p;
	     is(scalar @@l, scalar @@end);
	     is("@@l", "@@end", "skipping x[$junk]");
	   }
       }
     }
   }
}

# / is recognized after spaces in scalar context
# XXXX no spaces are allowed in pack...  In pack only before the slash...
is(scalar unpack('A /A Z20', pack 'A/A* Z20', 'bcde', 'xxxxx'), 'bcde');
is(scalar unpack('A /A /A Z20', '3004bcde'), 'bcde');

{ # X! and x!
  my $t = 'C[3]  x!8 C[2]';
  my @@a = (0x73..0x77);
  my $p = pack($t, @@a);
  is($p, "\x73\x74\x75\0\0\0\0\0\x76\x77");
  my @@b = unpack $t, $p;
  is(scalar @@b, scalar @@a);
  is("@@b", "@@a", 'x!8');
  $t = 'x[5] C[6] X!8 C[2]';
  @@a = (0x73..0x7a);
  $p = pack($t, @@a);
  is($p, "\0\0\0\0\0\x73\x74\x75\x79\x7a");
  @@b = unpack $t, $p;
  @@a = (0x73..0x75, 0x79, 0x7a, 0x79, 0x7a);
  is(scalar @@b, scalar @@a);
  is("@@b", "@@a");
}

{ # struct {char c1; double d; char cc[2];}
  my $t = 'C x![d] d C[2]';
  my @@a = (173, 1.283476517e-45, 42, 215);
  my $p = pack $t, @@a;
  ok( length $p);
  my @@b = unpack "$t X[$t] $t", $p;	# Extract, step back, extract again
  is(scalar @@b, 2 * scalar @@a);
  $b = "@@b";
  $b =~ s/(?:17000+|16999+)\d+(e-45) /17$1 /gi; # stringification is gamble
  is($b, "@@a @@a");
d363 55
a417 5
  my $warning;
  local $SIG{__WARN__} = sub {
      $warning = $_[0];
  };
  @@b = unpack "x[C] x[$t] X[$t] X[C] $t", "$p\0";
a418 70
  is($warning, undef);
  is(scalar @@b, scalar @@a);
  $b = "@@b";
  $b =~ s/(?:17000+|16999+)\d+(e-45) /17$1 /gi; # stringification is gamble
  is($b, "@@a");
}

is(length(pack("j", 0)), $Config{ivsize});
is(length(pack("J", 0)), $Config{uvsize});
is(length(pack("F", 0)), $Config{nvsize});

numbers ('j', -2147483648, -1, 0, 1, 2147483647);
numbers ('J', 0, 1, 2147483647, 2147483648, 4294967295);
numbers ('F', -(2**34), -1, 0, 1, 2**34);
SKIP: {
    my $t = eval { unpack("D*", pack("D", 12.34)) };

    skip "Long doubles not in use", 56 if $@@ =~ /Invalid type in pack/;

    is(length(pack("D", 0)), $Config{longdblsize});
    numbers ('D', -(2**34), -1, 0, 1, 2**34);
}

# Maybe this knowledge needs to be "global" for all of pack.t
# Or a "can checksum" which would effectively be all the number types"
my %cant_checksum = map {$_=> 1} qw(A Z u w);
# not a b B h H
foreach my $template (qw(A Z c C s S i I l L n N v V q Q j J f d F D u U w)) {
  SKIP: {
    my $packed = eval {pack "${template}4", 1, 4, 9, 16};
    if ($@@) {
      die unless $@@ =~ /Invalid type in pack: '$template'/;
      skip ("$template not supported on this perl",
            $cant_checksum{$template} ? 4 : 8);
    }
    my @@unpack4 = unpack "${template}4", $packed;
    my @@unpack = unpack "${template}*", $packed;
    my @@unpack1 = unpack "${template}", $packed;
    my @@unpack1s = scalar unpack "${template}", $packed;
    my @@unpack4s = scalar unpack "${template}4", $packed;
    my @@unpacks = scalar unpack "${template}*", $packed;

    my @@tests = ( ["${template}4 vs ${template}*", \@@unpack4, \@@unpack],
                  ["scalar ${template} ${template}", \@@unpack1s, \@@unpack1],
                  ["scalar ${template}4 vs ${template}", \@@unpack4s, \@@unpack1],
                  ["scalar ${template}* vs ${template}", \@@unpacks, \@@unpack1],
                );

    unless ($cant_checksum{$template}) {
      my @@unpack4_c = unpack "\%${template}4", $packed;
      my @@unpack_c = unpack "\%${template}*", $packed;
      my @@unpack1_c = unpack "\%${template}", $packed;
      my @@unpack1s_c = scalar unpack "\%${template}", $packed;
      my @@unpack4s_c = scalar unpack "\%${template}4", $packed;
      my @@unpacks_c = scalar unpack "\%${template}*", $packed;

      push @@tests,
        ( ["% ${template}4 vs ${template}*", \@@unpack4_c, \@@unpack_c],
          ["% scalar ${template} ${template}", \@@unpack1s_c, \@@unpack1_c],
          ["% scalar ${template}4 vs ${template}*", \@@unpack4s_c, \@@unpack_c],
          ["% scalar ${template}* vs ${template}*", \@@unpacks_c, \@@unpack_c],
        );
    }
    foreach my $test (@@tests) {
      ok (list_eq ($test->[1], $test->[2]), $test->[0]) ||
        printf "# unpack gave %s expected %s\n",
          encode_list (@@{$test->[1]}), encode_list (@@{$test->[2]});
    }
  }
}
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@d9 1
a9 1
plan tests => 5852;
d163 1
a163 1
  print "# test exceptions\n";
a172 62

  eval { $x = pack 'w', -1 };
  like ($@@, qr/^Cannot compress negative numbers/);

  eval { $x = pack 'w', '1'x(1 + length ~0) . 'e0' };
  like ($@@, qr/^Can only compress unsigned integers/);

 SKIP: {
    # Is this a stupid thing to do on VMS, VOS and other unusual platforms?

    skip("-- the IEEE infinity model is unavailable in this configuration.", 1)
       if (($^O eq 'VMS') && !defined($Config{useieee}));

    skip("-- $^O has serious fp indigestion on w-packed infinities", 1)
       if (
	   ($^O eq 'mpeix')
	   ||
	   ($^O eq 'ultrix')
	   ||
	   ($^O =~ /^svr4/ && -f "/etc/issue" && -f "/etc/.relid") # NCR MP-RAS
	   );

    my $inf = eval '2**10000';

    skip("Couldn't generate infinity - got error '$@@'", 1)
      unless defined $inf and $inf == $inf / 2 and $inf + 1 == $inf;

    local our $TODO;
    $TODO = "VOS needs a fix for posix-1022 to pass this test."
      if ($^O eq 'vos');

    eval { $x = pack 'w', $inf };
    like ($@@, qr/^Cannot compress integer/, "Cannot compress integer");
  }

 SKIP: {

    skip("-- the full range of an IEEE double may not be available in this configuration.", 3)
       if (($^O eq 'VMS') && !defined($Config{useieee}));

    skip("-- $^O does not like 2**1023", 3)
       if (($^O eq 'ultrix'));

    # This should be about the biggest thing possible on an IEEE double
    my $big = eval '2**1023';

    skip("Couldn't generate 2**1023 - got error '$@@'", 3)
      unless defined $big and $big != $big / 2;

    eval { $x = pack 'w', $big };
    is ($@@, '', "Should be able to pack 'w', $big # 2**1023");

    my $y = eval {unpack 'w', $x};
    is ($@@, '',
	"Should be able to unpack 'w' the result of pack 'w', $big # 2**1023");

    # I'm getting about 1e-16 on FreeBSD
    my $quotient = int (100 * ($y - $big) / $big);
    ok($quotient < 2 && $quotient > -2,
       "Round trip pack, unpack 'w' of $big is withing 1% ($quotient%)");
  }

d175 2
a176 1
print "# test the 'p' template\n";
d205 2
a206 2
print "# test the pack lengths of s S i I l L n N v V\n";

d220 1
a220 2
print "# test unpack-pack lengths\n";

d228 1
a228 1
        skip "Quads not supported", 4 if $@@ =~ /Invalid type/;
d317 1
a317 1
print "# packing native shorts/ints/longs\n";
a338 1
  print "# numbers test for $format\n";
d343 1
a343 1
          $@@ =~ /Invalid type '$format'/;
d363 1
a363 1
        if $@@ =~ /Invalid type '$format'/;
d395 1
a395 1
            my $mult = $max_p1 ? int ($total / $max_p1) : undef;
d472 1
a472 1
print "# pack nvNV byteorders\n";
d484 1
a484 1
  like($@@, qr!'/' must follow a numeric type!);
d487 1
a487 1
  like($@@, qr!'/' must follow a numeric type!);
d503 1
a503 1
  like($@@,  qr!Invalid type '/'!);
d506 1
a506 1
  like($@@,  qr!Invalid type '/'!);
d746 1
a746 1
    like($@@, qr/'P' must have an explicit size/);
a786 99
{  # more on grouping (W.Laun)
  use warnings;
  my $warning;
  local $SIG{__WARN__} = sub {
      $warning = $_[0];
  };
  # @@ absolute within ()-group
  my $badc = pack( '(a)*', unpack( '(@@1a @@0a @@2)*', 'abcd' ) );
  is( $badc, 'badc' );
  my @@b = ( 1, 2, 3 );
  my $buf = pack( '(@@1c)((@@2C)@@3c)', @@b );
  is( $buf, "\0\1\0\0\2\3" );
  my @@a = unpack( '(@@1c)((@@2c)@@3c)', $buf );
  is( "@@a", "@@b" );

  # various unpack count/code scenarios 
  my @@Env = ( a => 'AAA', b => 'BBB' );
  my $env = pack( 'S(S/A*S/A*)*', @@Env/2, @@Env );

  # unpack full length - ok
  my @@pup = unpack( 'S/(S/A* S/A*)', $env );
  is( "@@pup", "@@Env" );

  # warn when count/code goes beyond end of string
  # \0002 \0001 a \0003 AAA \0001 b \0003 BBB
  #     2     4 5     7  10    1213
  eval { @@pup = unpack( 'S/(S/A* S/A*)', substr( $env, 0, 13 ) ) };
  like( $@@, qr{length/code after end of string} );
  
  # postfix repeat count
  $env = pack( '(S/A* S/A*)' . @@Env/2, @@Env );

  # warn when count/code goes beyond end of string
  # \0001 a \0003 AAA \0001  b \0003 BBB
  #     2 3c    5   8    10 11    13  16
  eval { @@pup = unpack( '(S/A* S/A*)' . @@Env/2, substr( $env, 0, 11 ) ) };
  like( $@@, qr{length/code after end of string} );

  # catch stack overflow/segfault
  eval { $_ = pack( ('(' x 105) . 'A' . (')' x 105) ); };
  like( $@@, qr{Too deeply nested \(\)-groups} );
}

{ # syntax checks (W.Laun)
  use warnings;
  my @@warning;
  local $SIG{__WARN__} = sub {
      push( @@warning, $_[0] );
  };
  eval { my $s = pack( 'Ax![4c]A', 1..5 ); };
  like( $@@, qr{Malformed integer in \[\]} );

  eval { my $buf = pack( '(c/*a*)', 'AAA', 'BB' ); };
  like( $@@, qr{'/' does not take a repeat count} );

  eval { my @@inf = unpack( 'c/1a', "\x03AAA\x02BB" ); };
  like( $@@, qr{'/' does not take a repeat count} );

  eval { my @@inf = unpack( 'c/*a', "\x03AAA\x02BB" ); };
  like( $@@, qr{'/' does not take a repeat count} );

  # white space where possible 
  my @@Env = ( a => 'AAA', b => 'BBB' );
  my $env = pack( ' S ( S / A*   S / A* )* ', @@Env/2, @@Env );
  my @@pup = unpack( ' S / ( S / A*   S / A* ) ', $env );
  is( "@@pup", "@@Env" );

  # white space in 4 wrong places
  for my $temp (  'A ![4]', 'A [4]', 'A *', 'A 4' ){
      eval { my $s = pack( $temp, 'B' ); };
      like( $@@, qr{Invalid type } );
  }

  # warning for commas
  @@warning = ();
  my $x = pack( 'I,A', 4, 'X' );
  like( $warning[0], qr{Invalid type ','} );

  # comma warning only once
  @@warning = ();
  $x = pack( 'C(C,C)C,C', 65..71  );
  like( scalar @@warning, 1 );

  # forbidden code in []
  eval { my $x = pack( 'A[@@4]', 'XXXX' ); };
  like( $@@, qr{Within \[\]-length '\@@' not allowed} );

  # @@ repeat default 1
  my $s = pack( 'AA@@A', 'A', 'B', 'C' );
  my @@c = unpack( 'AA@@A', $s );
  is( $s, 'AC' ); 
  is( "@@c", "A C C" ); 

  # no unpack code after /
  eval { my @@a = unpack( "C/", "\3" ); };
  like( $@@, qr{Code missing after '/'} );

}

d904 1
a904 1
    skip "Long doubles not in use", 56 if $@@ =~ /Invalid type/;
d918 1
a918 1
      die unless $@@ =~ /Invalid type '$template'/;
a955 12
}

ok(pack('u2', 'AA'), "[perl #8026]"); # used to hang and eat RAM in perl 5.7.2

ok(1, "fake success (change #18751, feature not present in 5.8.1)");

{
    my $a = "X\t01234567\n" x 100;
    my @@a = unpack("(a1 c/a)*", $a);
    is(scalar @@a, 200,       "[perl #15288]");
    is($a[-1], "01234567\n", "[perl #15288]");
    is($a[-2], "X",          "[perl #15288]");
@


1.1.1.7
log
@perl 5.8.8 import
@
text
@d1 1
a1 2
#!./perl
# FIXME - why isn't this -w clean in maint?
d9 1
a9 7
# This is truth in an if statement, and could be a skip message
my $no_endianness = $] > 5.009 ? '' :
  "Endianness pack modifiers not available on this perl";
my $no_signedness = $] > 5.009 ? '' :
  "Signed/unsigned pack modifiers not available on this perl";

plan tests => 13864;
d12 1
a12 1
# use warnings;
a16 41
my @@valid_errors = (qr/^Invalid type '\w'/);

my $ByteOrder = 'unknown';
my $maybe_not_avail = '(?:hto[bl]e|[bl]etoh)';
if ($no_endianness) {
  push @@valid_errors, qr/^Invalid type '[<>]'/;
} elsif ($Config{byteorder} =~ /^1234(?:5678)?$/) {
  $ByteOrder = 'little';
  $maybe_not_avail = '(?:htobe|betoh)';
}
elsif ($Config{byteorder} =~ /^(?:8765)?4321$/) {
  $ByteOrder = 'big';
  $maybe_not_avail = '(?:htole|letoh)';
}
else {
  push @@valid_errors, qr/^Can't (?:un)?pack (?:big|little)-endian .*? on this platform/;
}

if ($no_signedness) {
  push @@valid_errors, qr/^'!' allowed only after types sSiIlLxX in (?:un)?pack/;
}

for my $size ( 16, 32, 64 ) {
  if (defined $Config{"u${size}size"} and $Config{"u${size}size"} != ($size >> 3)) {
    push @@valid_errors, qr/^Perl_my_$maybe_not_avail$size\(\) not available/;
  }
}

my $IsTwosComplement = pack('i', -1) eq "\xFF" x $Config{intsize};
print "# \$IsTwosComplement = $IsTwosComplement\n";

sub is_valid_error
{
  my $err = shift;

  for my $e (@@valid_errors) {
    $err =~ $e and return 1;
  }

  return 0;
}
a179 67
  # Check that the warning behaviour on the modifiers !, < and > is as we
  # expect it for this perl.
  my $can_endian = $no_endianness ? '' : 'sSiIlLqQjJfFdDpP';
  my $can_shriek = 'sSiIlL';
  $can_shriek .= 'nNvV' unless $no_signedness;
  # h and H can't do either, so act as sanity checks in blead
  foreach my $base (split '', 'hHsSiIlLqQjJfFdDpPnNvV') {
    foreach my $mod ('', '<', '>', '!', '<!', '>!', '!<', '!>') {
    SKIP: {
	# Avoid void context warnings.
	my $a = eval {pack "$base$mod"};
	skip "pack can't $base", 1 if $@@ =~ /^Invalid type '\w'/;
	# Which error you get when 2 would be possible seems to be emergent
	# behaviour of pack's format parser.

	my $fails_shriek = $mod =~ /!/ && index ($can_shriek, $base) == -1;
	my $fails_endian = $mod =~ /[<>]/ && index ($can_endian, $base) == -1;
	my $shriek_first = $mod =~ /^!/;

	if ($no_endianness and ($mod eq '<!' or $mod eq '>!')) {
	  # The ! isn't seem as part of $base. Instead it's seen as a modifier
	  # on > or <
	  $fails_shriek = 1;
	  undef $fails_endian;
	} elsif ($fails_shriek and $fails_endian) {
	  if ($shriek_first) {
	    undef $fails_endian;
	  }
	}

	if ($fails_endian) {
	  if ($no_endianness) {
	    # < and > are seen as pattern letters, not modifiers
	    like ($@@, qr/^Invalid type '[<>]'/, "pack can't $base$mod");
	  } else {
	    like ($@@, qr/^'[<>]' allowed only after types/,
		  "pack can't $base$mod");
	  }
	} elsif ($fails_shriek) {
	  like ($@@, qr/^'!' allowed only after types/,
		"pack can't $base$mod");
	} else {
	  is ($@@, '', "pack can $base$mod");
	}
      }
    }
  }

 SKIP: {
    skip $no_endianness, 2*3 + 2*8 if $no_endianness;
    for my $mod (qw( ! < > )) {
      eval { $x = pack "a$mod", 42 };
      like ($@@, qr/^'$mod' allowed only after types \S+ in pack/);

      eval { $x = unpack "a$mod", 'x'x8 };
      like ($@@, qr/^'$mod' allowed only after types \S+ in unpack/);
    }

    for my $mod (qw( <> >< !<> !>< <!> >!< <>! ><! )) {
      eval { $x = pack "sI${mod}s", 42, 47, 11 };
      like ($@@, qr/^Can't use both '<' and '>' after type 'I' in pack/);

      eval { $x = unpack "sI${mod}s", 'x'x16 };
      like ($@@, qr/^Can't use both '<' and '>' after type 'I' in unpack/);
    }
  }

d195 1
a195 1
    my $inf = eval '2**1000000';
d232 1
a232 1
       "Round trip pack, unpack 'w' of $big is within 1% ($quotient%)");
d241 1
a241 5
SKIP: {
  skip $no_endianness, 2 if $no_endianness;
  is(unpack("p<",pack("p<","foo")), "foo");
  is(unpack("p>",pack("p>","foo")), "foo");
}
a243 5
SKIP: {
  skip $no_endianness, 2 if $no_endianness;
  is(unpack("p<",pack("p<",239)), 239);
  is(unpack("p>",pack("p>",239)), 239);
}
d259 1
a259 6
like(pack("p", undef), qr/^\0+$/);
SKIP: {
  skip $no_endianness, 2 if $no_endianness;
  like(pack("p<", undef), qr/^\0+$/);
  like(pack("p>", undef), qr/^\0+$/);
}
d266 1
a266 1
print "# test the pack lengths of s S i I l L n N v V + modifiers\n";
d268 9
a276 23
my @@lengths = (
  qw(s 2 S 2 i -4 I -4 l 4 L 4 n 2 N 4 v 2 V 4 n! 2 N! 4 v! 2 V! 4),
  's!'  => $Config{shortsize}, 'S!'  => $Config{shortsize},
  'i!'  => $Config{intsize},   'I!'  => $Config{intsize},
  'l!'  => $Config{longsize},  'L!'  => $Config{longsize},
);

while (my ($base, $expect) = splice @@lengths, 0, 2) {
  my @@formats = ($base);
  $base =~ /^[nv]/i or push @@formats, "$base>", "$base<";
  for my $format (@@formats) {
  SKIP: {
      skip $no_endianness, 1 if $no_endianness && $format =~ m/[<>]/;
      skip $no_signedness, 1 if $no_signedness && $format =~ /[nNvV]!/;
      my $len = length(pack($format, 0));
      if ($expect > 0) {
	is($expect, $len, "format '$format'");
      } else {
	$expect = -$expect;
	ok ($len >= $expect, "format '$format'") ||
	  print "# format '$format' has length $len, expected >= $expect\n";
      }
    }
d285 7
a291 6
foreach my $base (@@templates) {
    my @@tmpl = ($base);
    $base =~ /^[cnv]/i or push @@tmpl, "$base>", "$base<";
    foreach my $t (@@tmpl) {
        SKIP: {
            my @@t = eval { unpack("$t*", pack("$t*", 12, 34)) };
d293 1
a293 2
            skip "cannot pack '$t' on this perl", 4
              if is_valid_error($@@);
d295 2
a296 2
            is( $@@, '', "Template $t works");
            is(scalar @@t, 2);
d389 2
a390 6
  my $base = shift;
  my @@formats = ($base);
  $base =~ /^[silqjfdp]/i and push @@formats, "$base>", "$base<";
  for my $format (@@formats) {
    numbers_with_total ($format, undef, @@_);
  }
d405 2
a406 2
        skip "cannot pack '$format' on this perl", 2
          if is_valid_error($@@);
d408 2
a409 2
        is($@@, '', "no error");
        is($out, $_, "unpack pack $format $_");
d426 1
a426 1
        if is_valid_error($@@);
d428 2
a429 2
      is($@@, '', "no error");
      ok(defined $sum, "sum bits $_, format $format defined");
d476 1
a476 1
            pass ("unpack '%$_$format' gave $sum");
d491 1
a491 1
    }
a512 4
numbers ('n!', -32768, -1, 0, 1, 32767);
numbers ('v!', -32768, -1, 0, 1, 32767);
numbers ('N!', -2147483648, -1, 0, 1, 2147483647);
numbers ('V!', -2147483648, -1, 0, 1, 2147483647);
a541 119
SKIP: {
  skip $no_signedness, 4 if $no_signedness;
  is(pack("n!", 0xdead), "\xde\xad");
  is(pack("v!", 0xdead), "\xad\xde");
  is(pack("N!", 0xdeadbeef), "\xde\xad\xbe\xef");
  is(pack("V!", 0xdeadbeef), "\xef\xbe\xad\xde");
}

print "# test big-/little-endian conversion\n";

sub byteorder
{
  my $format = shift;
  print "# byteorder test for $format\n";
  for my $value (@@_) {
    SKIP: {
      my($nat,$be,$le) = eval { map { pack $format.$_, $value } '', '>', '<' };
      skip "cannot pack '$format' on this perl", 5
        if is_valid_error($@@);

      print "# [$value][$nat][$be][$le][$@@]\n";

      SKIP: {
        skip "cannot compare native byteorder with big-/little-endian", 1
            if $ByteOrder eq 'unknown';

        is($nat, $ByteOrder eq 'big' ? $be : $le);
      }
      is($be, reverse($le));
      my @@x = eval { unpack "$format$format>$format<", $nat.$be.$le };

      print "# [$value][", join('][', @@x), "][$@@]\n";

      is($@@, '');
      is($x[0], $x[1]);
      is($x[0], $x[2]);
    }
  }
}

byteorder('s', -32768, -1, 0, 1, 32767);
byteorder('S', 0, 1, 32767, 32768, 65535);
byteorder('i', -2147483648, -1, 0, 1, 2147483647);
byteorder('I', 0, 1, 2147483647, 2147483648, 4294967295);
byteorder('l', -2147483648, -1, 0, 1, 2147483647);
byteorder('L', 0, 1, 2147483647, 2147483648, 4294967295);
byteorder('j', -2147483648, -1, 0, 1, 2147483647);
byteorder('J', 0, 1, 2147483647, 2147483648, 4294967295);
byteorder('s!', -32768, -1, 0, 1, 32767);
byteorder('S!', 0, 1, 32767, 32768, 65535);
byteorder('i!', -2147483648, -1, 0, 1, 2147483647);
byteorder('I!', 0, 1, 2147483647, 2147483648, 4294967295);
byteorder('l!', -2147483648, -1, 0, 1, 2147483647);
byteorder('L!', 0, 1, 2147483647, 2147483648, 4294967295);
byteorder('q', -9223372036854775808, -1, 0, 1, 9223372036854775807);
byteorder('Q', 0, 1, 9223372036854775807, 9223372036854775808, 18446744073709551615);
byteorder('f', -1, 0, 0.5, 42, 2**34);
byteorder('F', -1, 0, 0.5, 42, 2**34);
byteorder('d', -(2**34), -1, 0, 1, 2**34);
byteorder('D', -(2**34), -1, 0, 1, 2**34);

print "# test negative numbers\n";

SKIP: {
  skip "platform is not using two's complement for negative integers", 120
    unless $IsTwosComplement;

  for my $format (qw(s i l j s! i! l! q)) {
    SKIP: {
      my($nat,$be,$le) = eval { map { pack $format.$_, -1 } '', '>', '<' };
      skip "cannot pack '$format' on this perl", 15
        if is_valid_error($@@);

      my $len = length $nat;
      is($_, "\xFF"x$len) for $nat, $be, $le;

      my(@@val,@@ref);
      if ($len >= 8) {
        @@val = (-2, -81985529216486896, -9223372036854775808);
        @@ref = ("\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFE",
                "\xFE\xDC\xBA\x98\x76\x54\x32\x10",
                "\x80\x00\x00\x00\x00\x00\x00\x00");
      }
      elsif ($len >= 4) {
        @@val = (-2, -19088744, -2147483648);
        @@ref = ("\xFF\xFF\xFF\xFE",
                "\xFE\xDC\xBA\x98",
                "\x80\x00\x00\x00");
      }
      else {
        @@val = (-2, -292, -32768);
        @@ref = ("\xFF\xFE",
                "\xFE\xDC",
                "\x80\x00");
      }
      for my $x (@@ref) {
        if ($len > length $x) {
          $x = $x . "\xFF" x ($len - length $x);
        }
      }

      for my $i (0 .. $#val) {
        my($nat,$be,$le) = eval { map { pack $format.$_, $val[$i] } '', '>', '<' };
        is($@@, '');

        SKIP: {
          skip "cannot compare native byteorder with big-/little-endian", 1
              if $ByteOrder eq 'unknown';

          is($nat, $ByteOrder eq 'big' ? $be : $le);
        }

        is($be, $ref[$i]);
        is($be, reverse($le));
      }
    }
  }
}

d678 1
a678 1
        like($@@, qr/^Malformed UTF-8 character /);
a786 72
SKIP: {
  print "# group modifiers\n";

  skip $no_endianness, 3 * 2 + 3 * 2 + 1 if $no_endianness;

  for my $t (qw{ (s<)< (sl>s)> (s(l(sl)<l)s)< }) {
    print "# testing pattern '$t'\n";
    eval { ($_) = unpack($t, 'x'x18); };
    is($@@, '');
    eval { $_ = pack($t, (0)x6); };
    is($@@, '');
  }

  for my $t (qw{ (s<)> (sl>s)< (s(l(sl)<l)s)> }) {
    print "# testing pattern '$t'\n";
    eval { ($_) = unpack($t, 'x'x18); };
    like($@@, qr/Can't use '[<>]' in a group with different byte-order in unpack/);
    eval { $_ = pack($t, (0)x6); };
    like($@@, qr/Can't use '[<>]' in a group with different byte-order in pack/);
  }

  is(pack('L<L>', (0x12345678)x2),
     pack('(((L1)1)<)(((L)1)1)>1', (0x12345678)x2));
}

{
  sub compress_template {
    my $t = shift;
    for my $mod (qw( < > )) {
      $t =~ s/((?:(?:[SILQJFDP]!?$mod|[^SILQJFDP\W]!?)(?:\d+|\*|\[(?:[^]]+)\])?\/?){2,})/
              my $x = $1; $x =~ s!$mod!!g ? "($x)$mod" : $x /ieg;
    }
    return $t;
  }

  my %templates = (
    's<'                  => [-42],
    's<c2x![S]S<'         => [-42, -11, 12, 4711],
    '(i<j<[s]l<)3'        => [-11, -22, -33, 1000000, 1100, 2201, 3302,
                              -1000000, 32767, -32768, 1, -123456789 ],
    '(I!<4(J<2L<)3)5'     => [1 .. 65],
    'q<Q<'                => [-50000000005, 60000000006],
    'f<F<d<'              => [3.14159, 111.11, 2222.22],
    'D<cCD<'              => [1e42, -128, 255, 1e-42],
    'n/a*'                => ['/usr/bin/perl'],
    'C/a*S</A*L</Z*I</a*' => [qw(Just another Perl hacker)],
  );

  for my $tle (sort keys %templates) {
    my @@d = @@{$templates{$tle}};
    my $tbe = $tle;
    $tbe =~ y/</>/;
    for my $t ($tbe, $tle) {
      my $c = compress_template($t);
      print "# '$t' -> '$c'\n";
      SKIP: {
        my $p1 = eval { pack $t, @@d };
        skip "cannot pack '$t' on this perl", 5 if is_valid_error($@@);
        my $p2 = eval { pack $c, @@d };
        is($@@, '');
        is($p1, $p2);
        s!(/[aAZ])\*!$1!g for $t, $c;
        my @@u1 = eval { unpack $t, $p1 };
        is($@@, '');
        my @@u2 = eval { unpack $c, $p2 };
        is($@@, '');
        is(join('!', @@u1), join('!', @@u2));
      }
    }
  }
}

a946 14
 SKIP: {
    skip $no_endianness, 6 if $no_endianness;

    # modifier warnings
    @@warning = ();
    $x = pack "I>>s!!", 47, 11;
    ($x) = unpack "I<<l!>!>", 'x'x20;
    is(scalar @@warning, 5);
    like($warning[0], qr/Duplicate modifier '>' after 'I' in pack/);
    like($warning[1], qr/Duplicate modifier '!' after 's' in pack/);
    like($warning[2], qr/Duplicate modifier '<' after 'I' in unpack/);
    like($warning[3], qr/Duplicate modifier '!' after 'l' in unpack/);
    like($warning[4], qr/Duplicate modifier '>' after 'l' in unpack/);
  }
d956 1
a956 1
     push @@codes, qw(s S);	# Keep the count the same
a963 2
   push @@codes, map { /^[silqjfdp]/i ? ("$_<", "$_>") : () } @@codes;

d992 12
a1003 18
           SKIP: {
	     my $junk1 = "$groupbegin $type$count $groupend";
	     # print "# junk1=$junk1\n";
	     my $p = eval { pack $junk1, @@list2 };
             skip "cannot pack '$type' on this perl", 12
               if is_valid_error($@@);
	     die "pack $junk1 failed: $@@" if $@@;

	     my $half = int( (length $p)/2 );
	     for my $move ('', "X$half", "X!$half", 'x1', 'x!8', "x$half") {
	       my $junk = "$junk1 $move";
	       # print "# junk='$junk', list=(@@list2)\n";
	       $p = pack "$junk $end", @@list2, @@end;
	       my @@l = unpack "x[$junk] $end", $p;
	       is(scalar @@l, scalar @@end);
	       is("@@l", "@@end", "skipping x[$junk]");
	     }
           }
d1066 1
a1066 1
    skip "Long doubles not in use", 166 if $@@ =~ /Invalid type/;
d1122 1
a1122 4
$_ = pack('c', 65); # 'A' would not be EBCDIC-friendly
eval "unpack('c')";
like ($@@, qr/Not enough arguments for unpack/,
      "one-arg unpack (change #18751) is not in maint");
a1129 33
}

# checksums
{
    # verify that unpack advances correctly wrt a checksum
    my (@@x) = unpack("b10a", "abcd");
    my (@@y) = unpack("%b10a", "abcd");
    is($x[1], $y[1], "checksum advance ok");

    # verify that the checksum is not overflowed with C0
    is(unpack("C0%128U", "abcd"), unpack("U0%128U", "abcd"), "checksum not overflowed");
}

{
    # U0 and C0 must be scoped
    my (@@x) = unpack("a(U0)U", "b\341\277\274");
    is($x[0], 'b', 'before scope');
    is($x[1], 225, 'after scope');
}

{
    # counted length prefixes shouldn't change C0/U0 mode
    # (note the length is actually 0 in this test)
    is(join(',', unpack("aC/UU",   "b\0\341\277\274")), 'b,225');
    is(join(',', unpack("aC/CU",   "b\0\341\277\274")), 'b,225');
    is(join(',', unpack("aU0C/UU", "b\0\341\277\274")), 'b,8188');
    is(join(',', unpack("aU0C/CU", "b\0\341\277\274")), 'b,8188');
}

{
    # "Z0" (bug #34062)
    my (@@x) = unpack("C*", pack("CZ0", 1, "b"));
    is(join(',', @@x), '1', 'pack Z0 doesn\'t destroy the character before');
@


1.1.1.8
log
@import perl 5.10.0 from CPAN
@
text
@d1 2
a2 1
#!./perl -w
d16 1
a16 1
plan tests => 14696;
d19 1
a19 1
use warnings qw(FATAL all);
d47 1
a47 1
  if (defined $Config{"u${size}size"} and ($Config{"u${size}size"}||0) != ($size >> 3)) {
a132 1
    binmode BIN;
d372 1
a372 1
  use warnings qw(NONFATAL all);;
d426 1
a426 1
my @@templates = qw(c C W i I s S l L n N v V f d q Q);
d430 1
a430 1
    $base =~ /^[cwnv]/i or push @@tmpl, "$base>", "$base<";
d511 1
a511 1
)
d616 1
a616 1
            # UV arithmetic, or because we're doing a floating point checksum)
a643 1
numbers ('W', 0, 1, 127, 128, 255, 256, 0x7ff, 0x800, 0xfffd);
d713 1
a713 4
      {
        use warnings qw(NONFATAL utf8);
        print "# [$value][$nat][$be][$le][$@@]\n";
      }
d861 1
a861 1
  )
d867 1
a867 1
    is($x, $expect) ||
d917 1
a917 1
is(join(" ", unpack("U0 C*", chr(0x1e2))), $rslt);
d935 3
a945 3
	use warnings qw(NONFATAL all);;

        my $bad = pack("U0C", 255);
d947 1
a947 1
        my @@null = unpack('U0U', $bad);
d1002 1
a1002 1
)
d1022 1
a1022 1
)
d1193 5
d1207 1
a1207 1
  # various unpack count/code scenarios
d1220 1
a1220 1

d1236 1
a1236 1
  use warnings qw(NONFATAL all);;
d1253 1
a1253 1
  # white space where possible
d1282 2
a1283 2
  is( $s, 'AC' );
  is( "@@c", "A C C" );
d1306 1
a1306 1
   my @@codes = qw( x A Z a c C W B b H h s v n S i I l V N L p P f F d
a1325 1
			| W     (?{ 8188 })
a1406 1
  use warnings qw(NONFATAL all);;
d1487 3
a1489 1
is(unpack('c'), 65, "one-arg unpack (change #18751)"); # defaulting to $_
d1492 1
a1492 1
    my $a = "X\x0901234567\n" x 100; # \t would not be EBCDIC TAB
a1498 13
{
    use warnings qw(NONFATAL all);;
    my $warning;
    local $SIG{__WARN__} = sub {
        $warning = $_[0];
    };
    my $out = pack("u99", "foo" x 99);
    like($warning, qr/Field too wide in 'u' format in pack at /,
         "Warn about too wide uuencode");
    is($out, ("_" . "9F]O" x 21 . "\n") x 4 . "M" . "9F]O" x 15 . "\n",
       "Use max width in case of too wide uuencode");
}

d1507 1
a1507 5
    if (ord('A') == 193) {
	is(unpack("C0%128U", "/bcd"), unpack("U0%128U", "abcd"), "checksum not overflowed");
    } else {
	is(unpack("C0%128U", "abcd"), unpack("U0%128U", "abcd"), "checksum not overflowed");
    }
d1514 1
a1514 3
    is($x[1], 8188, 'after scope');

    is(pack("a(U0)U", "b", 8188), "b\341\277\274");
d1520 4
a1523 9
    if (ord('A') == 193) {
	is(join(',', unpack("aU0C/UU", "b\0\341\277\274")), 'b,0');
	is(join(',', unpack("aU0C/CU", "b\0\341\277\274")), 'b,0');
    } else {
	is(join(',', unpack("aC/UU",   "b\0\341\277\274")), 'b,8188');
	is(join(',', unpack("aC/CU",   "b\0\341\277\274")), 'b,8188');
	is(join(',', unpack("aU0C/UU", "b\0\341\277\274")), 'b,225');
	is(join(',', unpack("aU0C/CU", "b\0\341\277\274")), 'b,225');
    }
a1529 429
}

{
    # Encoding neutrality
    # String we will pull apart and rebuild in several ways:
    my $down = "\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff\x05\x06";
    my $up   = $down;
    utf8::upgrade($up);

    my %expect =
        # [expected result,
        #  how many chars it should progress,
        #  (optional) expected result of pack]
        (a5 => ["\xf8\xf9\xfa\xfb\xfc", 5],
         A5 => ["\xf8\xf9\xfa\xfb\xfc", 5],
         Z5 => ["\xf8\xf9\xfa\xfb\xfc", 5, "\xf8\xf9\xfa\xfb\x00\xfd"],
         b21 => ["000111111001111101011", 3, "\xf8\xf9\x1a\xfb"],
         B21 => ["111110001111100111111", 3, "\xf8\xf9\xf8\xfb"],
         H5 => ["f8f9f", 3, "\xf8\xf9\xf0\xfb"],
         h5 => ["8f9fa", 3, "\xf8\xf9\x0a\xfb"],
         "s<"  => [-1544, 2],
         "s>"  => [-1799, 2],
         "S<"  => [0xf9f8, 2],
         "S>"  => [0xf8f9, 2],
         "l<"  => [-67438088, 4],
         "l>"  => [-117835013, 4],
         "L>"  => [0xf8f9fafb, 4],
         "L<"  => [0xfbfaf9f8, 4],
         n     => [0xf8f9, 2],
         N     => [0xf8f9fafb, 4],
         v     => [63992, 2],
         V     => [0xfbfaf9f8, 4],
         c     => [-8, 1],
         U0U   => [0xf8, 1],
         w     => ["8715569050387726213", 9],
         q     => ["-283686952306184", 8],
         Q     => ["18446460386757245432", 8],
         );

    for my $string ($down, $up) {
        for my $format (sort {lc($a) cmp lc($b) || $a cmp $b } keys %expect) {
          SKIP: {
              my $expect = $expect{$format};
              # unpack upgraded and downgraded string
              my @@result = eval { unpack("$format C0 W", $string) };
              skip "cannot pack/unpack '$format C0 W' on this perl", 5 if
                  $@@ && is_valid_error($@@);
              is(@@result, 2, "Two results from unpack $format C0 W");

              # pack to downgraded
              my $new = pack("$format C0 W", @@result);
              is(length($new), $expect->[1]+1,
                 "pack $format C0 W should give $expect->[1]+1 chars");
              is($new, $expect->[2] || substr($string, 0, length $new),
                 "pack $format C0 W returns expected value");

              # pack to upgraded
              $new = pack("a0 $format C0 W", chr(256), @@result);
              is(length($new), $expect->[1]+1,
                 "pack a0 $format C0 W should give $expect->[1]+1 chars");
              is($new, $expect->[2] || substr($string, 0, length $new),
                 "pack a0 $format C0 W returns expected value");
          }
        }
    }
}

{
    # Encoding neutrality, numbers
    my $val = -2.68;
    for my $format (qw(s S i I l L j J f d F D q Q
                       s! S! i! I! l! L! n! N! v! V!)) {
      SKIP: {
          my $down = eval { pack($format, $val) };
          skip "cannot pack/unpack $format on this perl", 9 if
              $@@ && is_valid_error($@@);
          ok(!utf8::is_utf8($down), "Simple $format pack doesn't get upgraded");
          my $up = pack("a0 $format", chr(256), $val);
          ok(utf8::is_utf8($up), "a0 $format with high char leads to upgrade");
          is($down, $up, "$format generated strings are equal though");
          my @@down_expanded = unpack("$format W", $down . chr(0xce));
          is(@@down_expanded, 2, "Expand to two values");
          is($down_expanded[1], 0xce,
             "unpack $format left us at the expected position");
          my @@up_expanded   = unpack("$format W", $up   . chr(0xce));
          is(@@up_expanded, 2, "Expand to two values");
          is($up_expanded[1], 0xce,
             "unpack $format left us at the expected position");
          is($down_expanded[0], $up_expanded[0], "$format unpack was neutral");
          is(pack($format, $down_expanded[0]), $down, "Pack $format undoes unpack $format");
      }
    }
}

{
    # C *is* neutral
    my $down = "\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff\x05\x06";
    my $up   = $down;
    utf8::upgrade($up);
    my @@down = unpack("C*", $down);
    my @@expect_down = (0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff, 0x05, 0x06);
    is("@@down", "@@expect_down", "byte expand");
    is(pack("C*", @@down), $down, "byte join");

    my @@up   = unpack("C*", $up);
    my @@expect_up = (0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff, 0x05, 0x06);
    is("@@up", "@@expect_up", "UTF-8 expand");
    is(pack("U0C0C*", @@up), $up, "UTF-8 join");
}

{
    # Harder cases for the neutrality test

    # u format
    my $down = "\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff\x05\x06";
    my $up   = $down;
    utf8::upgrade($up);
    is(pack("u", $down), pack("u", $up), "u pack is neutral");
    is(unpack("u", pack("u", $down)), $down, "u unpack to downgraded works");
    is(unpack("U0C0u", pack("u", $down)), $up, "u unpack to upgraded works");

    # p/P format
    # This actually only tests something if the address contains a byte >= 0x80
    my $str = "abc\xa5\x00\xfede";
    $down = pack("p", $str);
    is(pack("P", $str), $down);
    is(pack("U0C0p", $str), $down);
    is(pack("U0C0P", $str), $down);
    is(unpack("p", $down), "abc\xa5", "unpack p downgraded");
    $up   = $down;
    utf8::upgrade($up);
    is(unpack("p", $up), "abc\xa5", "unpack p upgraded");

    is(unpack("P7", $down), "abc\xa5\x00\xfed", "unpack P downgraded");
    is(unpack("P7", $up),   "abc\xa5\x00\xfed", "unpack P upgraded");

    # x, X and @@
    $down = "\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff\x05\x06";
    $up   = $down;
    utf8::upgrade($up);

    is(unpack('@@4W', $down), 0xfc, "\@@positioning on downgraded string");
    is(unpack('@@4W', $up),   0xfc, "\@@positioning on upgraded string");

    is(unpack('@@4x2W', $down), 0xfe, "x moving on downgraded string");
    is(unpack('@@4x2W', $up),   0xfe, "x moving on upgraded string");
    is(unpack('@@4x!4W', $down), 0xfc, "x! moving on downgraded string");
    is(unpack('@@4x!4W', $up),   0xfc, "x! moving on upgraded string");
    is(unpack('@@5x!4W', $down), 0x05, "x! moving on downgraded string");
    is(unpack('@@5x!4W', $up),   0x05, "x! moving on upgraded string");

    is(unpack('@@4X2W', $down), 0xfa, "X moving on downgraded string");
    is(unpack('@@4X2W', $up),   0xfa, "X moving on upgraded string");
    is(unpack('@@4X!4W', $down), 0xfc, "X! moving on downgraded string");
    is(unpack('@@4X!4W', $up),   0xfc, "X! moving on upgraded string");
    is(unpack('@@5X!4W', $down), 0xfc, "X! moving on downgraded string");
    is(unpack('@@5X!4W', $up),   0xfc, "X! moving on upgraded string");
    is(unpack('@@5X!8W', $down), 0xf8, "X! moving on downgraded string");
    is(unpack('@@5X!8W', $up),   0xf8, "X! moving on upgraded string");

    is(pack("W2x", 0xfa, 0xe3), "\xfa\xe3\x00", "x on downgraded string");
    is(pack("W2x!4", 0xfa, 0xe3), "\xfa\xe3\x00\x00",
       "x! on downgraded string");
    is(pack("W2x!2", 0xfa, 0xe3), "\xfa\xe3", "x! on downgraded string");
    is(pack("U0C0W2x", 0xfa, 0xe3), "\xfa\xe3\x00", "x on upgraded string");
    is(pack("U0C0W2x!4", 0xfa, 0xe3), "\xfa\xe3\x00\x00",
       "x! on upgraded string");
    is(pack("U0C0W2x!2", 0xfa, 0xe3), "\xfa\xe3", "x! on upgraded string");
    is(pack("W2X", 0xfa, 0xe3), "\xfa", "X on downgraded string");
    is(pack("U0C0W2X", 0xfa, 0xe3), "\xfa", "X on upgraded string");
    is(pack("W2X!2", 0xfa, 0xe3), "\xfa\xe3", "X! on downgraded string");
    is(pack("U0C0W2X!2", 0xfa, 0xe3), "\xfa\xe3", "X! on upgraded string");
    is(pack("W3X!2", 0xfa, 0xe3, 0xa6), "\xfa\xe3", "X! on downgraded string");
    is(pack("U0C0W3X!2", 0xfa, 0xe3, 0xa6), "\xfa\xe3",
       "X! on upgraded string");

    # backward eating through a ( moves the group starting point backwards
    is(pack("a*(Xa)", "abc", "q"), "abq",
       "eating before strbeg moves it back");
    is(pack("a*(Xa)", "ab" . chr(512), "q"), "abq",
       "eating before strbeg moves it back");

    # Check marked_upgrade
    is(pack('W(W(Wa@@3W)@@6W)@@9W', 0xa1, 0xa2, 0xa3, "a", 0xa4, 0xa5, 0xa6),
       "\xa1\xa2\xa3a\x00\xa4\x00\xa5\x00\xa6");
    $up = "a";
    utf8::upgrade($up);
    is(pack('W(W(Wa@@3W)@@6W)@@9W', 0xa1, 0xa2, 0xa3, $up, 0xa4, 0xa5, 0xa6),
       "\xa1\xa2\xa3a\x00\xa4\x00\xa5\x00\xa6", "marked upgrade caused by a");
    is(pack('W(W(WW@@3W)@@6W)@@9W', 0xa1, 0xa2, 0xa3, 256, 0xa4, 0xa5, 0xa6),
       "\xa1\xa2\xa3\x{100}\x00\xa4\x00\xa5\x00\xa6",
       "marked upgrade caused by W");
    is(pack('W(W(WU0aC0@@3W)@@6W)@@9W', 0xa1, 0xa2, 0xa3, "a", 0xa4, 0xa5, 0xa6),
       "\xa1\xa2\xa3a\x00\xa4\x00\xa5\x00\xa6", "marked upgrade caused by U0");

    # a, A and Z
    $down = "\xa4\xa6\xa7";
    $up   = $down;
    utf8::upgrade($up);
    utf8::upgrade(my $high = "\xfeb");

    for my $format ("a0", "A0", "Z0", "U0a0C0", "U0A0C0", "U0Z0C0") {
        is(pack("a* $format a*", "ab", $down, "cd"), "abcd",
           "$format format on plain string");
        is(pack("a* $format a*", "ab", $up,   "cd"), "abcd",
           "$format format on upgraded string");
        is(pack("a* $format a*", $high, $down, "cd"), "\xfebcd",
           "$format format on plain string");
        is(pack("a* $format a*", $high, $up,   "cd"), "\xfebcd",
           "$format format on upgraded string");
        my @@down = unpack("a1 $format a*", "\xfeb");
        is("@@down", "\xfe  b", "unpack $format");
        my @@up = unpack("a1 $format a*", $high);
        is("@@up", "\xfe  b", "unpack $format");
    }
    is(pack("a1", $high), "\xfe");
    is(pack("A1", $high), "\xfe");
    is(pack("Z1", $high), "\x00");
    is(pack("a2", $high), "\xfeb");
    is(pack("A2", $high), "\xfeb");
    is(pack("Z2", $high), "\xfe\x00");
    is(pack("a5", $high), "\xfeb\x00\x00\x00");
    is(pack("A5", $high), "\xfeb   ");
    is(pack("Z5", $high), "\xfeb\x00\x00\x00");
    is(pack("a*", $high), "\xfeb");
    is(pack("A*", $high), "\xfeb");
    is(pack("Z*", $high), "\xfeb\x00");

    utf8::upgrade($high = "\xc3\xbeb");
    is(pack("U0a2", $high), "\xfe");
    is(pack("U0A2", $high), "\xfe");
    is(pack("U0Z1", $high), "\x00");
    is(pack("U0a3", $high), "\xfeb");
    is(pack("U0A3", $high), "\xfeb");
    is(pack("U0Z3", $high), "\xfe\x00");
    is(pack("U0a6", $high), "\xfeb\x00\x00\x00");
    is(pack("U0A6", $high), "\xfeb   ");
    is(pack("U0Z6", $high), "\xfeb\x00\x00\x00");
    is(pack("U0a*", $high), "\xfeb");
    is(pack("U0A*", $high), "\xfeb");
    is(pack("U0Z*", $high), "\xfeb\x00");
}
{
    # pack /
    my @@array = 1..14;
    my @@out = unpack("N/S", pack("N/S", @@array) . "abcd");
    is("@@out", "@@array", "pack N/S works");
    @@out = unpack("N/S*", pack("N/S*", @@array) . "abcd");
    is("@@out", "@@array", "pack N/S* works");
    @@out = unpack("N/S*", pack("N/S14", @@array) . "abcd");
    is("@@out", "@@array", "pack N/S14 works");
    @@out = unpack("N/S*", pack("N/S15", @@array) . "abcd");
    is("@@out", "@@array", "pack N/S15 works");
    @@out = unpack("N/S*", pack("N/S13", @@array) . "abcd");
    is("@@out", "@@array[0..12]", "pack N/S13 works");
    @@out = unpack("N/S*", pack("N/S0", @@array) . "abcd");
    is("@@out", "", "pack N/S0 works");
    is(pack("Z*/a0", "abc"), "0\0", "pack Z*/a0 makes a short string");
    is(pack("Z*/Z0", "abc"), "0\0", "pack Z*/Z0 makes a short string");
    is(pack("Z*/a3", "abc"), "3\0abc", "pack Z*/a3 makes a full string");
    is(pack("Z*/Z3", "abc"), "3\0ab\0", "pack Z*/Z3 makes a short string");
    is(pack("Z*/a5", "abc"), "5\0abc\0\0", "pack Z*/a5 makes a long string");
    is(pack("Z*/Z5", "abc"), "5\0abc\0\0", "pack Z*/Z5 makes a long string");
    is(pack("Z*/Z"), "1\0\0", "pack Z*/Z makes an extended string");
    is(pack("Z*/Z", ""), "1\0\0", "pack Z*/Z makes an extended string");
    is(pack("Z*/a", ""), "0\0", "pack Z*/a makes an extended string");
}
{
    # unpack("A*", $unicode) strips general unicode spaces
    is(unpack("A*", "ab \n\xa0 \0"), "ab \n\xa0",
       'normal A* strip leaves \xa0');
    is(unpack("U0C0A*", "ab \n\xa0 \0"), "ab \n\xa0",
       'normal A* strip leaves \xa0 even if it got upgraded for technical reasons');
    is(unpack("A*", pack("a*(U0U)a*", "ab \n", 0xa0, " \0")), "ab",
       'upgraded strings A* removes \xa0');
    is(unpack("A*", pack("a*(U0UU)a*", "ab \n", 0xa0, 0x1680, " \0")), "ab",
       'upgraded strings A* removes all unicode whitespace');
    is(unpack("A5", pack("a*(U0U)a*", "ab \n", 0x1680, "def", "ab")), "ab",
       'upgraded strings A5 removes all unicode whitespace');
    is(unpack("A*", pack("U", 0x1680)), "",
       'upgraded strings A* with nothing left');
}
{
    # Testing unpack . and .!
    is(unpack(".", "ABCD"), 0, "offset at start of string is 0");
    is(unpack(".", ""), 0, "offset at start of empty string is 0");
    is(unpack("x3.", "ABCDEF"), 3, "simple offset works");
    is(unpack("x3.", "ABC"), 3, "simple offset at end of string works");
    is(unpack("x3.0", "ABC"), 0, "self offset is 0");
    is(unpack("x3(x2.)", "ABCDEF"), 2, "offset is relative to inner group");
    is(unpack("x3(X2.)", "ABCDEF"), -2,
       "negative offset relative to inner group");
    is(unpack("x3(X2.2)", "ABCDEF"), 1, "offset is relative to inner group");
    is(unpack("x3(x2.0)", "ABCDEF"), 0, "self offset in group is still 0");
    is(unpack("x3(x2.2)", "ABCDEF"), 5, "offset counts groups");
    is(unpack("x3(x2.*)", "ABCDEF"), 5, "star offset is relative to start");

    my $high = chr(8188) x 6;
    is(unpack("x3(x2.)", $high), 2, "utf8 offset is relative to inner group");
    is(unpack("x3(X2.)", $high), -2,
       "utf8 negative offset relative to inner group");
    is(unpack("x3(X2.2)", $high), 1, "utf8 offset counts groups");
    is(unpack("x3(x2.0)", $high), 0, "utf8 self offset in group is still 0");
    is(unpack("x3(x2.2)", $high), 5, "utf8 offset counts groups");
    is(unpack("x3(x2.*)", $high), 5, "utf8 star offset is relative to start");

    is(unpack("U0x3(x2.)", $high), 2,
       "U0 mode utf8 offset is relative to inner group");
    is(unpack("U0x3(X2.)", $high), -2,
       "U0 mode utf8 negative offset relative to inner group");
    is(unpack("U0x3(X2.2)", $high), 1,
       "U0 mode utf8 offset counts groups");
    is(unpack("U0x3(x2.0)", $high), 0,
       "U0 mode utf8 self offset in group is still 0");
    is(unpack("U0x3(x2.2)", $high), 5,
       "U0 mode utf8 offset counts groups");
    is(unpack("U0x3(x2.*)", $high), 5,
       "U0 mode utf8 star offset is relative to start");

    is(unpack("x3(x2.!)", $high), 2*3,
       "utf8 offset is relative to inner group");
    is(unpack("x3(X2.!)", $high), -2*3,
       "utf8 negative offset relative to inner group");
    is(unpack("x3(X2.!2)", $high), 1*3,
       "utf8 offset counts groups");
    is(unpack("x3(x2.!0)", $high), 0,
       "utf8 self offset in group is still 0");
    is(unpack("x3(x2.!2)", $high), 5*3,
       "utf8 offset counts groups");
    is(unpack("x3(x2.!*)", $high), 5*3,
       "utf8 star offset is relative to start");

    is(unpack("U0x3(x2.!)", $high), 2,
       "U0 mode utf8 offset is relative to inner group");
    is(unpack("U0x3(X2.!)", $high), -2,
       "U0 mode utf8 negative offset relative to inner group");
    is(unpack("U0x3(X2.!2)", $high), 1,
       "U0 mode utf8 offset counts groups");
    is(unpack("U0x3(x2.!0)", $high), 0,
       "U0 mode utf8 self offset in group is still 0");
    is(unpack("U0x3(x2.!2)", $high), 5,
       "U0 mode utf8 offset counts groups");
    is(unpack("U0x3(x2.!*)", $high), 5,
       "U0 mode utf8 star offset is relative to start");
}
{
    # Testing pack . and .!
    is(pack("(a)5 .", 1..5, 3), "123", ". relative to string start, shorten");
    eval { () = pack("(a)5 .", 1..5, -3) };
    like($@@, qr{'\.' outside of string in pack}, "Proper error message");
    is(pack("(a)5 .", 1..5, 8), "12345\x00\x00\x00",
       ". relative to string start, extend");
    is(pack("(a)5 .", 1..5, 5), "12345", ". relative to string start, keep");

    is(pack("(a)5 .0", 1..5, -3), "12",
       ". relative to string current, shorten");
    is(pack("(a)5 .0", 1..5, 2), "12345\x00\x00",
       ". relative to string current, extend");
    is(pack("(a)5 .0", 1..5, 0), "12345",
       ". relative to string current, keep");

    is(pack("(a)5 (.)", 1..5, -3), "12",
       ". relative to group, shorten");
    is(pack("(a)5 (.)", 1..5, 2), "12345\x00\x00",
       ". relative to group, extend");
    is(pack("(a)5 (.)", 1..5, 0), "12345",
       ". relative to group, keep");

    is(pack("(a)3 ((a)2 .)", 1..5, -2), "1",
       ". relative to group, shorten");
    is(pack("(a)3 ((a)2 .)", 1..5, 2), "12345",
       ". relative to group, keep");
    is(pack("(a)3 ((a)2 .)", 1..5, 4), "12345\x00\x00",
       ". relative to group, extend");

    is(pack("(a)3 ((a)2 .2)", 1..5, 2), "12",
       ". relative to counted group, shorten");
    is(pack("(a)3 ((a)2 .2)", 1..5, 7), "12345\x00\x00",
       ". relative to counted group, extend");
    is(pack("(a)3 ((a)2 .2)", 1..5, 5), "12345",
       ". relative to counted group, keep");

    is(pack("(a)3 ((a)2 .*)", 1..5, 2), "12",
       ". relative to start, shorten");
    is(pack("(a)3 ((a)2 .*)", 1..5, 7), "12345\x00\x00",
       ". relative to start, extend");
    is(pack("(a)3 ((a)2 .*)", 1..5, 5), "12345",
       ". relative to start, keep");

    is(pack('(a)5 (. @@2 a)', 1..5, -3, "a"), "12\x00\x00a",
       ". based shrink properly updates group starts");

    is(pack("(W)3 ((W)2 .)", 0x301..0x305, -2), "\x{301}",
       "utf8 . relative to group, shorten");
    is(pack("(W)3 ((W)2 .)", 0x301..0x305, 2),
       "\x{301}\x{302}\x{303}\x{304}\x{305}",
       "utf8 . relative to group, keep");
    is(pack("(W)3 ((W)2 .)", 0x301..0x305, 4),
       "\x{301}\x{302}\x{303}\x{304}\x{305}\x00\x00",
       "utf8 . relative to group, extend");

    is(pack("(W)3 ((W)2 .!)", 0x301..0x305, -2), "\x{301}\x{302}",
       "utf8 . relative to group, shorten");
    is(pack("(W)3 ((W)2 .!)", 0x301..0x305, 4),
       "\x{301}\x{302}\x{303}\x{304}\x{305}",
       "utf8 . relative to group, keep");
    is(pack("(W)3 ((W)2 .!)", 0x301..0x305, 6),
       "\x{301}\x{302}\x{303}\x{304}\x{305}\x00\x00",
       "utf8 . relative to group, extend");

    is(pack('(W)5 (. @@2 a)', 0x301..0x305, -3, "a"),
       "\x{301}\x{302}\x00\x00a",
       "utf8 . based shrink properly updates group starts");
}
{
    # Testing @@!
    is(pack('a* @@3',  "abcde"), "abc", 'Test basic @@');
    is(pack('a* @@!3', "abcde"), "abc", 'Test basic @@!');
    is(pack('a* @@2', "\x{301}\x{302}\x{303}\x{304}\x{305}"), "\x{301}\x{302}",
       'Test basic utf8 @@');
    is(pack('a* @@!2', "\x{301}\x{302}\x{303}\x{304}\x{305}"), "\x{301}",
       'Test basic utf8 @@!');

    is(unpack('@@4 a*',  "abcde"), "e", 'Test basic @@');
    is(unpack('@@!4 a*', "abcde"), "e", 'Test basic @@!');
    is(unpack('@@4 a*',  "\x{301}\x{302}\x{303}\x{304}\x{305}"), "\x{305}",
       'Test basic utf8 @@');
    is(unpack('@@!4 a*', "\x{301}\x{302}\x{303}\x{304}\x{305}"),
       "\x{303}\x{304}\x{305}", 'Test basic utf8 @@!');
@


1.1.1.9
log
@import perl 5.10.1
@
text
@d15 1
a15 1
plan tests => 14697;
a1981 5
}
{
    #50256
    my ($v) = split //, unpack ('(B)*', 'ab');
    is($v, 0); # Doesn't SEGV :-)
@


1.1.1.10
log
@Perl 5.12.2 from CPAN
@
text
@d15 1
a15 1
plan tests => 14699;
a1986 8
}
{
    #73814
    my $x = runperl( prog => 'print split( /,/, unpack(q(%2H*), q(hello world))), qq(\n)' );
    is($x, "0\n", "split /a/, unpack('%2H*'...) didn't crash");

    my $y = runperl( prog => 'print split( /,/, unpack(q(%32u*), q(#,3,Q)), qq(\n)), qq(\n)' );
    is($y, "0\n", "split /a/, unpack('%32u*'...) didn't crash");
@


1.1.1.11
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d15 1
a15 1
plan tests => 14700;
d674 1
a674 1
# the expected checksum on any system including those where NVs can preserve
a1995 4

#90160
is(eval { () = unpack "C0 U*", ""; "ok" }, "ok",
  'medial U* on empty string');
@


1.1.1.12
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d15 1
a15 1
plan tests => 14704;
d303 2
d819 1
a819 1
  my ($x, $y, $z, @@a);
a824 8

  # [perl #60204] Unhelpful error message from unpack
  eval { @@a = unpack 'v/a*','h' };
  is($@@, '');
  is(scalar @@a, 0);
  eval { $x = unpack 'v/a*','h' };
  is($@@, '');
  is($x, undef);
@


1.1.1.13
log
@Import perl-5.24.2
@
text
@d5 2
a6 2
    require './test.pl'; require './charset_tools.pl';
    set_up_inc(qw '../lib ../dist/Math-BigInt/lib');
d15 1
a15 1
plan tests => 14712;
d21 1
d125 1
a125 1
    $sum = 103 if $::IS_EBCDIC;
d318 1
a318 1
    like ($@@, qr/^Cannot compress Inf/, "Cannot compress infinity");
d870 1
a870 1
           ['a/a*/b*', '212ab', $::IS_EBCDIC ? '100000010100' : '100001100100'],
d918 5
a922 3
{
    is("1.20.300.4000", sprintf "%vd", pack("U*",utf8::native_to_unicode(1),utf8::native_to_unicode(20),300,4000));
    is("1.20.300.4000", sprintf "%vd", pack("  U*",utf8::native_to_unicode(1),utf8::native_to_unicode(20),300,4000));
d924 1
a924 1
isnt(v1.20.300.4000, sprintf "%vd", pack("C0U*",utf8::native_to_unicode(1),utf8::native_to_unicode(20),300,4000));
d926 1
a926 2
my $rslt = join " ", map { ord } split "", byte_utf8a_to_utf8n("\xc7\xa2");
# The ASCII UTF-8 of U+1E2 is "\xc7\xa2"
d941 4
a944 1
{
d946 1
a946 11
    my $cp202 = chr(202);
    utf8::upgrade $cp202;
    my @@bytes202;
    {   # This is portable across character sets
        use bytes;
        @@bytes202 = map { ord } split "", $cp202;
    }

    # This test requires the first number to be invariant; 64 is invariant on
    # ASCII and EBCDIC.
    is("@@{[pack('U0C*', 64, @@bytes202)]}", v64.v202);
d949 1
a949 3
    # The U* is expecting Unicode, so convert to that.
    is("@@{[pack('C0U*', map { utf8::native_to_unicode($_) } 64, 202)]}",
       pack("C*", 64, @@bytes202));
d955 1
a955 1
        my $bad = pack("U0C", 202);
d1278 1
a1278 1
  cmp_ok( scalar(@@warning), '==', 1 );
d1510 1
a1510 4

    # This test is looking for the encoding of the bit pattern "\x66\x6f\x6f",
    # which is ASCII "foo"
    my $out = pack("u99", native_to_uni("foo") x 99);
d1525 5
a1529 1
    is(unpack("C0%128U", "abcd"), unpack("U0%128U", "abcd"), "checksum not overflowed");
a1531 1
my $U_1FFC_bytes = byte_utf8a_to_utf8n("\341\277\274");
d1534 1
a1534 1
    my (@@x) = unpack("a(U0)U", "b$U_1FFC_bytes");
d1538 1
a1538 1
    is(pack("a(U0)U", "b", 8188), "b$U_1FFC_bytes");
d1543 10
a1552 10
    # (note the length is actually 0 in this test, as the C/ is replaced by C0
    # due to the \0 in the string)
    is(join(',', unpack("aC/UU",   "b\0$U_1FFC_bytes")), 'b,8188');
    is(join(',', unpack("aC/CU",   "b\0$U_1FFC_bytes")), 'b,8188');

    # The U expects Unicode, so convert from native
    my $first_byte = utf8::native_to_unicode(ord substr($U_1FFC_bytes, 0, 1));

    is(join(',', unpack("aU0C/UU", "b\0$U_1FFC_bytes")), "b,$first_byte");
    is(join(',', unpack("aU0C/CU", "b\0$U_1FFC_bytes")), "b,$first_byte");
d1787 13
a1799 13
    utf8::upgrade($high = byte_utf8a_to_utf8n("\xc3\xbe") . "b");
    is(pack("U0a2", $high), uni_to_native("\xfe"));
    is(pack("U0A2", $high), uni_to_native("\xfe"));
    is(pack("U0Z1", $high), uni_to_native("\x00"));
    is(pack("U0a3", $high), uni_to_native("\xfe") . "b");
    is(pack("U0A3", $high), uni_to_native("\xfe") . "b");
    is(pack("U0Z3", $high), uni_to_native("\xfe\x00"));
    is(pack("U0a6", $high), uni_to_native("\xfe") . "b" . uni_to_native("\x00\x00\x00"));
    is(pack("U0A6", $high), uni_to_native("\xfe") . "b   ");
    is(pack("U0Z6", $high), uni_to_native("\xfe") . "b" . uni_to_native("\x00\x00\x00"));
    is(pack("U0a*", $high), uni_to_native("\xfe") . "b");
    is(pack("U0A*", $high), uni_to_native("\xfe") . "b");
    is(pack("U0Z*", $high), uni_to_native("\xfe") . "b" . uni_to_native("\x00"));
d1828 1
a1828 1
    is(unpack("A*", "ab \n" . uni_to_native("\xa0") . " \0"), "ab \n" . uni_to_native("\xa0"),
d1830 1
a1830 1
    is(unpack("U0C0A*", "ab \n" . uni_to_native("\xa0") . " \0"), "ab \n" . uni_to_native("\xa0"),
d1991 1
a1991 2
    # This test is for the bit pattern "\x61\x62", which is ASCII "ab"
    my ($v) = split //, unpack ('(B)*', native_to_uni('ab'));
a2005 33

package o {
    use overload
        '""' => sub { ++$o::str; "42" },
        '0+' => sub { ++$o::num; 42 };
}
is pack("c", bless [], "o"), chr(42), 'overloading called';
is $o::str, undef, 'pack "c" does not call string overloading';
is $o::num, 1,     'pack "c" does call num overloading';

#[perl #123874]: argument underflow leads to corrupt length
eval q{ pack "pi/x" };
ok(1, "argument underflow did not crash");

{
    # [perl #126325] pack [hH] with a unicode string
    # the hex encoders would read past the end of the string, using
    # invalid source bytes
    my $twenty_nuls = "\0" x 20;
    # This is the case that failed
    is(pack("WH40", 0x100, ""), "\x{100}$twenty_nuls",
       "check pack H zero fills (utf8 target)");
    my $up_nul = "\0";

    utf8::upgrade($up_nul);
    # check the other combinations too
    is(pack("WH40", 0x100, $up_nul), "\x{100}$twenty_nuls",
       "check pack H zero fills (utf8 target/source)");
    is(pack("H40", ""), $twenty_nuls,
       "check pack H zero fills (utf8 none)");
    is(pack("H40", $up_nul), $twenty_nuls,
       "check pack H zero fills (utf8 source)");
}
@


