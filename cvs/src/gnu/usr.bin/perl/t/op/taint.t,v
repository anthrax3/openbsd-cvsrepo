head	1.22;
access;
symbols
	OPENBSD_6_1:1.22.0.2
	OPENBSD_6_1_BASE:1.22
	OPENBSD_6_0:1.21.0.4
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.20.0.2
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.20.0.4
	OPENBSD_5_8_BASE:1.20
	PERL_5_20_2:1.1.1.16
	OPENBSD_5_7:1.18.0.2
	OPENBSD_5_7_BASE:1.18
	PERL_5_20_1:1.1.1.15
	OPENBSD_5_6:1.16.0.4
	OPENBSD_5_6_BASE:1.16
	PERL_5_18_2:1.1.1.14
	PERL:1.1.1
	OPENBSD_5_5:1.15.0.6
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.15.0.2
	OPENBSD_5_4_BASE:1.15
	PERL_5_16_3:1.1.1.13
	OPENBSD_5_3:1.14.0.8
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.6
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.4
	OPENBSD_5_0:1.14.0.2
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.13.0.2
	OPENBSD_4_9_BASE:1.13
	PERL_5_12_2:1.1.1.12
	OPENBSD_4_8:1.12.0.4
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	PERL_5_10_1:1.1.1.11
	OPENBSD_4_6:1.11.0.6
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.2
	OPENBSD_4_5_BASE:1.11
	PERL_5_10_0:1.1.1.10
	OPENBSD_4_4:1.10.0.10
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.8
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.6
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.4
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.2
	OPENBSD_4_0_BASE:1.10
	PERL_5_8_8:1.1.1.9
	OPENBSD_3_9:1.9.0.6
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.4
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.2
	OPENBSD_3_7_BASE:1.9
	PERL_5_8_6:1.1.1.8
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	PERL_5_8_5:1.1.1.7
	PERL_5_8_3:1.1.1.6
	OPENBSD_3_5:1.6.0.2
	OPENBSD_3_5_BASE:1.6
	PERL_5_8_2:1.1.1.5
	OPENBSD_3_4:1.5.0.4
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.4.0.6
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.4
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.3.0.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	PERL_500503:1.1.1.1
	CPAN:1.1.1
	OPENBSD_2_5:1.1.0.6
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.4
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.2
	OPENBSD_2_3_BASE:1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.22
date	2017.02.05.00.32.20;	author afresh1;	state Exp;
branches;
next	1.21;
commitid	cxJ08BvJA9Pt2PTM;

1.21
date	2016.07.03.01.08.04;	author afresh1;	state Exp;
branches;
next	1.20;
commitid	GzHqjSTnBjdF7Wcw;

1.20
date	2015.04.25.19.26.22;	author afresh1;	state Exp;
branches;
next	1.19;
commitid	3qGYFVvfrExB70FB;

1.19
date	2015.04.25.19.14.48;	author afresh1;	state Exp;
branches;
next	1.18;
commitid	XRK22kO4se3v2i2I;

1.18
date	2014.11.17.21.01.01;	author afresh1;	state Exp;
branches;
next	1.17;
commitid	LnErp1MFKSuew5Fr;

1.17
date	2014.11.17.20.57.07;	author afresh1;	state Exp;
branches;
next	1.16;
commitid	QP75iYx42Uo7mMxO;

1.16
date	2014.03.24.15.05.33;	author afresh1;	state Exp;
branches;
next	1.15;

1.15
date	2013.03.25.20.41.00;	author sthen;	state Exp;
branches;
next	1.14;

1.14
date	2011.04.18.21.29.51;	author bluhm;	state Exp;
branches;
next	1.13;

1.13
date	2010.09.24.15.07.09;	author millert;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	2009.10.12.18.30.28;	author millert;	state Exp;
branches
	1.12.4.1;
next	1.11;

1.11
date	2008.09.29.17.36.20;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2006.03.28.19.23.13;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2005.01.15.21.30.41;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2004.08.09.18.10.27;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2004.04.07.21.33.10;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2003.12.03.03.02.49;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.10.27.22.25.37;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.24.18.36.23;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.06.17.08.34;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	99.04.29.22.52.39;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	97.11.30.08.05.46;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.29.22.41.53;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.04.06.16.10.52;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.05.24.18.25.48;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.27.22.15.11;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.12.03.02.44.33;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.04.07.21.13.44;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.08.09.17.48.36;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2005.01.15.21.18.20;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2006.03.28.18.49.47;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2008.09.29.17.19.02;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2009.10.12.18.10.45;	author millert;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2010.09.24.14.49.17;	author millert;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2013.03.25.20.09.37;	author sthen;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2014.03.24.14.59.11;	author afresh1;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	2014.11.17.20.53.18;	author afresh1;	state Exp;
branches;
next	1.1.1.16;
commitid	B31cAbBIXiCqnL97;

1.1.1.16
date	2015.04.25.19.10.48;	author afresh1;	state Exp;
branches;
next	;
commitid	Wpcs5S8qILgEZC7F;

1.12.4.1
date	2011.04.20.13.58.54;	author bluhm;	state Exp;
branches;
next	;

1.13.2.1
date	2011.04.20.13.53.38;	author bluhm;	state Exp;
branches;
next	;


desc
@perl 5.004_04
@


1.22
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl -T
#
# Taint tests by Tom Phoenix <rootbeer@@teleport.com>.
#
# I don't claim to know all about tainting. If anyone sees
# tests that I've missed here, please add them. But this is
# better than having no tests at all, right?
#

BEGIN {
    chdir 't' if -d 't';
    require './test.pl';
    require './loc_tools.pl';
    set_up_inc('../lib');
}

use strict;
use Config;

plan tests => 808;

$| = 1;

use vars qw($ipcsysv); # did we manage to load IPC::SysV?

my ($old_env_path, $old_env_dcl_path, $old_env_term);
BEGIN {
   $old_env_path = $ENV{'PATH'};
   $old_env_dcl_path = $ENV{'DCL$PATH'};
   $old_env_term = $ENV{'TERM'};
  if ($^O eq 'VMS' && !defined($Config{d_setenv})) {
      $ENV{PATH} = $ENV{PATH};
      $ENV{TERM} = $ENV{TERM} ne ''? $ENV{TERM} : 'dummy';
  }
  if ($Config{'extensions'} =~ /\bIPC\/SysV\b/
      && ($Config{d_shm} || $Config{d_msg})) {
      eval { require IPC::SysV };
      unless ($@@) {
	  $ipcsysv++;
	  IPC::SysV->import(qw(IPC_PRIVATE IPC_RMID IPC_CREAT S_IRWXU IPC_NOWAIT));
      }
  }
}

my $Is_VMS      = $^O eq 'VMS';
my $Is_MSWin32  = $^O eq 'MSWin32';
my $Is_NetWare  = $^O eq 'NetWare';
my $Is_Dos      = $^O eq 'dos';
my $Is_Cygwin   = $^O eq 'cygwin';
my $Is_OpenBSD  = $^O eq 'openbsd';
my $Is_MirBSD   = $^O eq 'mirbsd';
my $Invoke_Perl = $Is_VMS      ? 'MCR Sys$Disk:[]Perl.exe' :
                  $Is_MSWin32  ? '.\perl'               :
                  $Is_NetWare  ? 'perl'                 :
                                 './perl'               ;
my @@MoreEnv = qw/IFS CDPATH ENV BASH_ENV/;

if ($Is_VMS) {
    my (%old, $x);
    for $x ('DCL$PATH', @@MoreEnv) {
	($old{$x}) = $ENV{$x} =~ /^(.*)$/ if exists $ENV{$x};
    }
    # VMS note:  PATH and TERM are automatically created by the C
    # library in VMS on reference to the their keys in %ENV.
    # There is currently no way to determine if they did not exist
    # before this test was run.
    eval <<EndOfCleanup;
	END {
	    \$ENV{PATH} = \$old_env_path;
	    warn "# Note: logical name 'PATH' may have been created\n";
	    \$ENV{'TERM'} = \$old_env_term;
	    warn "# Note: logical name 'TERM' may have been created\n";
	    \@@ENV{keys %old} = values %old;
	    if (defined \$old_env_dcl_path) {
		\$ENV{'DCL\$PATH'} = \$old_env_dcl_path;
	    } else {
		delete \$ENV{'DCL\$PATH'};
	    }
	}
EndOfCleanup
}

# Sources of taint:
#   The empty tainted value, for tainting strings
my $TAINT = substr($^X, 0, 0);
#   A tainted zero, useful for tainting numbers
my $TAINT0;
{
    no warnings;
    $TAINT0 = 0 + $TAINT;
}

# This taints each argument passed. All must be lvalues.
# Side effect: It also stringifies them. :-(
sub taint_these (@@) {
    for (@@_) { $_ .= $TAINT }
}

# How to identify taint when you see it
sub tainted ($) {
    local $@@;   # Don't pollute caller's value.
    not eval { join("",@@_), kill 0; 1 };
}

sub is_tainted {
    my $thing = shift;
    local $::Level = $::Level + 1;
    ok(tainted($thing), @@_);
}

sub isnt_tainted {
    my $thing = shift;
    local $::Level = $::Level + 1;
    ok(!tainted($thing), @@_);
}

sub violates_taint {
    my ($code, $what, $desc) = @@_;
    $desc //= $what;
    local $::Level = $::Level + 1;
    is(eval { $code->(); }, undef, $desc);
    like($@@, qr/^Insecure dependency in $what while running with -T switch/);
}

# We need an external program to call.
my $ECHO = ($Is_MSWin32 ? ".\\echo$$" : ($Is_NetWare ? "echo$$" : "./echo$$"));
END { unlink $ECHO }
open my $fh, '>', $ECHO or die "Can't create $ECHO: $!";
print $fh 'print "@@ARGV\n"', "\n";
close $fh;
my $echo = "$Invoke_Perl $ECHO";

my $TEST = 'TEST';

# First, let's make sure that Perl is checking the dangerous
# environment variables. Maybe they aren't set yet, so we'll
# taint them ourselves.
{
    $ENV{'DCL$PATH'} = '' if $Is_VMS;

    $ENV{PATH} = ($Is_Cygwin) ? '/usr/bin' : '';
    delete @@ENV{@@MoreEnv};
    $ENV{TERM} = 'dumb';

    is(eval { `$echo 1` }, "1\n");

    SKIP: {
        skip "Environment tainting tests skipped", 4
          if $Is_MSWin32 || $Is_NetWare || $Is_VMS || $Is_Dos;

	my @@vars = ('PATH', @@MoreEnv);
	while (my $v = $vars[0]) {
	    local $ENV{$v} = $TAINT;
	    last if eval { `$echo 1` };
	    last unless $@@ =~ /^Insecure \$ENV\{$v}/;
	    shift @@vars;
	}
	is("@@vars", "");

	# tainted $TERM is unsafe only if it contains metachars
	local $ENV{TERM};
	$ENV{TERM} = 'e=mc2';
	is(eval { `$echo 1` }, "1\n");
	$ENV{TERM} = 'e=mc2' . $TAINT;
	is(eval { `$echo 1` }, undef);
	like($@@, qr/^Insecure \$ENV\{TERM}/);
    }

    my $tmp;
    if ($^O eq 'os2' || $^O eq 'amigaos' || $Is_MSWin32 || $Is_NetWare || $Is_Dos) {
	print "# all directories are writeable\n";
    }
    else {
	$tmp = (grep { defined and -d and (stat _)[2] & 2 }
		     qw(sys$scratch /tmp /var/tmp /usr/tmp),
		     @@ENV{qw(TMP TEMP)})[0]
	    or print "# can't find world-writeable directory to test PATH\n";
    }

    SKIP: {
        skip "all directories are writeable", 2 unless $tmp;

	local $ENV{PATH} = $tmp;
	is(eval { `$echo 1` }, undef);
	# Message can be different depending on whether echo
	# is a builtin or not
	like($@@, qr/^Insecure (?:directory in )?\$ENV\{PATH}/);
    }

    SKIP: {
        skip "This is not VMS", 4 unless $Is_VMS;

	$ENV{'DCL$PATH'} = $TAINT;
	is(eval { `$echo 1` }, undef);
	like($@@, qr/^Insecure \$ENV\{DCL\$PATH}/);
	SKIP: {
            skip q[can't find world-writeable directory to test DCL$PATH], 2
              unless $tmp;

	    $ENV{'DCL$PATH'} = $tmp;
	    is(eval { `$echo 1` }, undef);
	    like($@@, qr/^Insecure directory in \$ENV\{DCL\$PATH}/);
	}
	$ENV{'DCL$PATH'} = '';
    }
}

# Let's see that we can taint and untaint as needed.
{
    my $foo = $TAINT;
    is_tainted($foo);

    # That was a sanity check. If it failed, stop the insanity!
    die "Taint checks don't seem to be enabled" unless tainted $foo;

    $foo = "foo";
    isnt_tainted($foo);

    taint_these($foo);
    is_tainted($foo);

    my @@list = 1..10;
    isnt_tainted($_) foreach @@list;
    taint_these @@list[1,3,5,7,9];
    is_tainted($_) foreach @@list[1,3,5,7,9];
    isnt_tainted($_) foreach @@list[0,2,4,6,8];

    ($foo) = $foo =~ /(.+)/;
    isnt_tainted($foo);

    my ($desc, $s, $res, $res2, $one);

    $desc = "match with string tainted";

    $s = 'abcd' . $TAINT;
    $res = $s =~ /(.+)/;
    $one = $1;
    is_tainted($s,     "$desc: s tainted");
    isnt_tainted($res, "$desc: res not tainted");
    isnt_tainted($one, "$desc: \$1 not tainted");
    is($res, 1,        "$desc: res value");
    is($one, 'abcd',   "$desc: \$1 value");

    $desc = "match /g with string tainted";

    $s = 'abcd' . $TAINT;
    $res = $s =~ /(.)/g;
    $one = $1;
    is_tainted($s,     "$desc: s tainted");
    isnt_tainted($res, "$desc: res not tainted");
    isnt_tainted($one, "$desc: \$1 not tainted");
    is($res, 1,        "$desc: res value");
    is($one, 'a',      "$desc: \$1 value");

    $desc = "match with string tainted, list cxt";

    $s = 'abcd' . $TAINT;
    ($res) = $s =~ /(.+)/;
    $one = $1;
    is_tainted($s,     "$desc: s tainted");
    isnt_tainted($res, "$desc: res not tainted");
    isnt_tainted($one, "$desc: \$1 not tainted");
    is($res, 'abcd',   "$desc: res value");
    is($one, 'abcd',   "$desc: \$1 value");

    $desc = "match /g with string tainted, list cxt";

    $s = 'abcd' . $TAINT;
    ($res, $res2) = $s =~ /(.)/g;
    $one = $1;
    is_tainted($s,     "$desc: s tainted");
    isnt_tainted($res, "$desc: res not tainted");
    isnt_tainted($res2,"$desc: res2 not tainted");
    isnt_tainted($one, "$desc: \$1 not tainted");
    is($res, 'a',      "$desc: res value");
    is($res2,'b',      "$desc: res2 value");
    is($one, 'd',      "$desc: \$1 value");

    $desc = "match with pattern tainted";

    $s = 'abcd';
    $res = $s =~ /$TAINT(.+)/;
    $one = $1;
    isnt_tainted($s,   "$desc: s not tainted");
    isnt_tainted($res, "$desc: res not tainted");
    is_tainted($one,   "$desc: \$1 tainted");
    is($res, 1,        "$desc: res value");
    is($one, 'abcd',   "$desc: \$1 value");

    $desc = "match /g with pattern tainted";

    $s = 'abcd';
    $res = $s =~ /$TAINT(.)/g;
    $one = $1;
    isnt_tainted($s,   "$desc: s not tainted");
    isnt_tainted($res, "$desc: res not tainted");
    is_tainted($one,   "$desc: \$1 tainted");
    is($res, 1,        "$desc: res value");
    is($one, 'a',      "$desc: \$1 value");

  SKIP: {
        skip 'Locales not available', 10 unless locales_enabled('LC_CTYPE');

        $desc = "match with pattern tainted via locale";

        $s = 'abcd';
        {
            use locale;
            $res = $s =~ /(\w+)/; $one = $1;
        }
        isnt_tainted($s,   "$desc: s not tainted");
        isnt_tainted($res, "$desc: res not tainted");
        is_tainted($one,   "$desc: \$1 tainted");
        is($res, 1,        "$desc: res value");
        is($one, 'abcd',   "$desc: \$1 value");

        $desc = "match /g with pattern tainted via locale";

        $s = 'abcd';
        {
            use locale;
            $res = $s =~ /(\w)/g; $one = $1;
        }
        isnt_tainted($s,   "$desc: s not tainted");
        isnt_tainted($res, "$desc: res not tainted");
        is_tainted($one,   "$desc: \$1 tainted");
        is($res, 1,        "$desc: res value");
        is($one, 'a',      "$desc: \$1 value");
    }

    $desc = "match with pattern tainted, list cxt";

    $s = 'abcd';
    ($res) = $s =~ /$TAINT(.+)/;
    $one = $1;
    isnt_tainted($s,   "$desc: s not tainted");
    is_tainted($res,   "$desc: res tainted");
    is_tainted($one,   "$desc: \$1 tainted");
    is($res, 'abcd',   "$desc: res value");
    is($one, 'abcd',   "$desc: \$1 value");

    $desc = "match /g with pattern tainted, list cxt";

    $s = 'abcd';
    ($res, $res2) = $s =~ /$TAINT(.)/g;
    $one = $1;
    isnt_tainted($s,   "$desc: s not tainted");
    is_tainted($res,   "$desc: res tainted");
    is_tainted($one,   "$desc: \$1 tainted");
    is($res, 'a',      "$desc: res value");
    is($res2,'b',      "$desc: res2 value");
    is($one, 'd',      "$desc: \$1 value");

  SKIP: {
        skip 'Locales not available', 12 unless locales_enabled('LC_CTYPE');

        $desc = "match with pattern tainted via locale, list cxt";

        $s = 'abcd';
        {
            use locale;
            ($res) = $s =~ /(\w+)/; $one = $1;
        }
        isnt_tainted($s,   "$desc: s not tainted");
        is_tainted($res,   "$desc: res tainted");
        is_tainted($one,   "$desc: \$1 tainted");
        is($res, 'abcd',   "$desc: res value");
        is($one, 'abcd',   "$desc: \$1 value");

        $desc = "match /g with pattern tainted via locale, list cxt";

        $s = 'abcd';
        {
            use locale;
            ($res, $res2) = $s =~ /(\w)/g; $one = $1;
        }
        isnt_tainted($s,   "$desc: s not tainted");
        is_tainted($res,   "$desc: res tainted");
        is_tainted($res2,  "$desc: res2 tainted");
        is_tainted($one,   "$desc: \$1 tainted");
        is($res, 'a',      "$desc: res value");
        is($res2,'b',      "$desc: res2 value");
        is($one, 'd',      "$desc: \$1 value");
    }

    $desc = "substitution with string tainted";

    $s = 'abcd' . $TAINT;
    $res = $s =~ s/(.+)/xyz/;
    $one = $1;
    is_tainted($s,     "$desc: s tainted");
    isnt_tainted($res, "$desc: res not tainted");
    isnt_tainted($one, "$desc: \$1 not tainted");
    is($s,   'xyz',    "$desc: s value");
    is($res, 1,        "$desc: res value");
    is($one, 'abcd',   "$desc: \$1 value");

    $desc = "substitution /g with string tainted";

    $s = 'abcd' . $TAINT;
    $res = $s =~ s/(.)/x/g;
    $one = $1;
    is_tainted($s,     "$desc: s tainted");
    is_tainted($res,   "$desc: res tainted");
    isnt_tainted($one, "$desc: \$1 not tainted");
    is($s,   'xxxx',   "$desc: s value");
    is($res, 4,        "$desc: res value");
    is($one, 'd',      "$desc: \$1 value");

    $desc = "substitution /r with string tainted";

    $s = 'abcd' . $TAINT;
    $res = $s =~ s/(.+)/xyz/r;
    $one = $1;
    is_tainted($s,     "$desc: s tainted");
    is_tainted($res,   "$desc: res tainted");
    isnt_tainted($one, "$desc: \$1 not tainted");
    is($s,   'abcd',   "$desc: s value");
    is($res, 'xyz',    "$desc: res value");
    is($one, 'abcd',   "$desc: \$1 value");

    $desc = "substitution /e with string tainted";

    $s = 'abcd' . $TAINT;
    $one = '';
    $res = $s =~ s{(.+)}{
		$one = $one . "x"; # make sure code not tainted
		isnt_tainted($one, "$desc: code not tainted within /e");
		$one = $1;
		isnt_tainted($one, "$desc: \$1 not tainted within /e");
		"xyz";
	    }e;
    $one = $1;
    is_tainted($s,     "$desc: s tainted");
    isnt_tainted($res, "$desc: res not tainted");
    isnt_tainted($one, "$desc: \$1 not tainted");
    is($s,   'xyz',    "$desc: s value");
    is($res, 1,        "$desc: res value");
    is($one, 'abcd',   "$desc: \$1 value");

    $desc = "substitution with pattern tainted";

    $s = 'abcd';
    $res = $s =~ s/$TAINT(.+)/xyz/;
    $one = $1;
    is_tainted($s,     "$desc: s tainted");
    isnt_tainted($res, "$desc: res not tainted");
    is_tainted($one,   "$desc: \$1 tainted");
    is($s,  'xyz',     "$desc: s value");
    is($res, 1,        "$desc: res value");
    is($one, 'abcd',   "$desc: \$1 value");

    $desc = "substitution /g with pattern tainted";

    $s = 'abcd';
    $res = $s =~ s/$TAINT(.)/x/g;
    $one = $1;
    is_tainted($s,     "$desc: s tainted");
    is_tainted($res,   "$desc: res tainted");
    is_tainted($one,   "$desc: \$1 tainted");
    is($s,  'xxxx',    "$desc: s value");
    is($res, 4,        "$desc: res value");
    is($one, 'd',      "$desc: \$1 value");

    $desc = "substitution /ge with pattern tainted";

    $s = 'abc';
    {
	my $i = 0;
	my $j;
	$res = $s =~ s{(.)$TAINT}{
		    $j = $i; # make sure code not tainted
		    $one = $1;
		    isnt_tainted($j, "$desc: code not tainted within /e");
		    $i++;
		    if ($i == 1) {
			isnt_tainted($s,   "$desc: s not tainted loop 1");
		    }
		    else {
			is_tainted($s,     "$desc: s tainted loop $i");
		    }
		    is_tainted($one,   "$desc: \$1 tainted loop $i");
		    $i.$TAINT;
		}ge;
	$one = $1;
    }
    is_tainted($s,     "$desc: s tainted");
    is_tainted($res,   "$desc: res tainted");
    is_tainted($one,   "$desc: \$1 tainted");
    is($s,  '123',     "$desc: s value");
    is($res, 3,        "$desc: res value");
    is($one, 'c',      "$desc: \$1 value");

    $desc = "substitution /r with pattern tainted";

    $s = 'abcd';
    $res = $s =~ s/$TAINT(.+)/xyz/r;
    $one = $1;
    isnt_tainted($s,   "$desc: s not tainted");
    is_tainted($res,   "$desc: res tainted");
    is_tainted($one,   "$desc: \$1 tainted");
    is($s,  'abcd',    "$desc: s value");
    is($res, 'xyz',    "$desc: res value");
    is($one, 'abcd',   "$desc: \$1 value");

  SKIP: {
        skip 'Locales not available', 18 unless locales_enabled('LC_CTYPE');

        $desc = "substitution with pattern tainted via locale";

        $s = 'abcd';
        {
            use locale;
            $res = $s =~ s/(\w+)/xyz/; $one = $1;
        }
        is_tainted($s,     "$desc: s tainted");
        isnt_tainted($res, "$desc: res not tainted");
        is_tainted($one,   "$desc: \$1 tainted");
        is($s,  'xyz',     "$desc: s value");
        is($res, 1,        "$desc: res value");
        is($one, 'abcd',   "$desc: \$1 value");

        $desc = "substitution /g with pattern tainted via locale";

        $s = 'abcd';
        {
            use locale;
            $res = $s =~ s/(\w)/x/g; $one = $1;
        }
        is_tainted($s,     "$desc: s tainted");
        is_tainted($res,   "$desc: res tainted");
        is_tainted($one,   "$desc: \$1 tainted");
        is($s,  'xxxx',    "$desc: s value");
        is($res, 4,        "$desc: res value");
        is($one, 'd',      "$desc: \$1 value");

        $desc = "substitution /r with pattern tainted via locale";

        $s = 'abcd';
        {
            use locale;
            $res = $s =~ s/(\w+)/xyz/r; $one = $1;
        }
        isnt_tainted($s,   "$desc: s not tainted");
        is_tainted($res,   "$desc: res tainted");
        is_tainted($one,   "$desc: \$1 tainted");
        is($s,  'abcd',    "$desc: s value");
        is($res, 'xyz',    "$desc: res value");
        is($one, 'abcd',   "$desc: \$1 value");
    }

    $desc = "substitution with replacement tainted";

    $s = 'abcd';
    $res = $s =~ s/(.+)/xyz$TAINT/;
    $one = $1;
    is_tainted($s,     "$desc: s tainted");
    isnt_tainted($res, "$desc: res not tainted");
    isnt_tainted($one, "$desc: \$1 not tainted");
    is($s,  'xyz',     "$desc: s value");
    is($res, 1,        "$desc: res value");
    is($one, 'abcd',   "$desc: \$1 value");

    $desc = "substitution /g with replacement tainted";

    $s = 'abcd';
    $res = $s =~ s/(.)/x$TAINT/g;
    $one = $1;
    is_tainted($s,     "$desc: s tainted");
    isnt_tainted($res, "$desc: res not tainted");
    isnt_tainted($one, "$desc: \$1 not tainted");
    is($s,  'xxxx',    "$desc: s value");
    is($res, 4,        "$desc: res value");
    is($one, 'd',      "$desc: \$1 value");

    $desc = "substitution /ge with replacement tainted";

    $s = 'abc';
    {
	my $i = 0;
	my $j;
	$res = $s =~ s{(.)}{
		    $j = $i; # make sure code not tainted
		    $one = $1;
		    isnt_tainted($j, "$desc: code not tainted within /e");
		    $i++;
		    if ($i == 1) {
			isnt_tainted($s,   "$desc: s not tainted loop 1");
		    }
		    else {
			is_tainted($s,     "$desc: s tainted loop $i");
		    }
		    isnt_tainted($one, "$desc: \$1 not tainted within /e");
		    $i.$TAINT;
		}ge;
	$one = $1;
    }
    is_tainted($s,     "$desc: s tainted");
    isnt_tainted($res, "$desc: res tainted");
    isnt_tainted($one, "$desc: \$1 not tainted");
    is($s,  '123',     "$desc: s value");
    is($res, 3,        "$desc: res value");
    is($one, 'c',      "$desc: \$1 value");

    $desc = "substitution /r with replacement tainted";

    $s = 'abcd';
    $res = $s =~ s/(.+)/xyz$TAINT/r;
    $one = $1;
    isnt_tainted($s,   "$desc: s not tainted");
    is_tainted($res,   "$desc: res tainted");
    isnt_tainted($one, "$desc: \$1 not tainted");
    is($s,   'abcd',   "$desc: s value");
    is($res, 'xyz',    "$desc: res value");
    is($one, 'abcd',   "$desc: \$1 value");

    {
	# now do them all again with "use re 'taint"

	use re 'taint';

	$desc = "use re 'taint': match with string tainted";

	$s = 'abcd' . $TAINT;
	$res = $s =~ /(.+)/;
	$one = $1;
	is_tainted($s,     "$desc: s tainted");
	isnt_tainted($res, "$desc: res not tainted");
	is_tainted($one,   "$desc: \$1 tainted");
	is($res, 1,        "$desc: res value");
	is($one, 'abcd',   "$desc: \$1 value");

	$desc = "use re 'taint': match /g with string tainted";

	$s = 'abcd' . $TAINT;
	$res = $s =~ /(.)/g;
	$one = $1;
	is_tainted($s,     "$desc: s tainted");
	isnt_tainted($res, "$desc: res not tainted");
	is_tainted($one,   "$desc: \$1 tainted");
	is($res, 1,        "$desc: res value");
	is($one, 'a',      "$desc: \$1 value");

	$desc = "use re 'taint': match with string tainted, list cxt";

	$s = 'abcd' . $TAINT;
	($res) = $s =~ /(.+)/;
	$one = $1;
	is_tainted($s,     "$desc: s tainted");
	is_tainted($res,   "$desc: res tainted");
	is_tainted($one,   "$desc: \$1 tainted");
	is($res, 'abcd',   "$desc: res value");
	is($one, 'abcd',   "$desc: \$1 value");

	$desc = "use re 'taint': match /g with string tainted, list cxt";

	$s = 'abcd' . $TAINT;
	($res, $res2) = $s =~ /(.)/g;
	$one = $1;
	is_tainted($s,     "$desc: s tainted");
	is_tainted($res,   "$desc: res tainted");
	is_tainted($res2,  "$desc: res2 tainted");
	is_tainted($one,   "$desc: \$1 not tainted");
	is($res, 'a',      "$desc: res value");
	is($res2,'b',      "$desc: res2 value");
	is($one, 'd',      "$desc: \$1 value");

	$desc = "use re 'taint': match with pattern tainted";

	$s = 'abcd';
	$res = $s =~ /$TAINT(.+)/;
	$one = $1;
	isnt_tainted($s,   "$desc: s not tainted");
	isnt_tainted($res, "$desc: res not tainted");
	is_tainted($one,   "$desc: \$1 tainted");
	is($res, 1,        "$desc: res value");
	is($one, 'abcd',   "$desc: \$1 value");

	$desc = "use re 'taint': match /g with pattern tainted";

	$s = 'abcd';
	$res = $s =~ /$TAINT(.)/g;
	$one = $1;
	isnt_tainted($s,   "$desc: s not tainted");
	isnt_tainted($res, "$desc: res not tainted");
	is_tainted($one,   "$desc: \$1 tainted");
	is($res, 1,        "$desc: res value");
	is($one, 'a',      "$desc: \$1 value");

  SKIP: {
        skip 'Locales not available', 10 unless locales_enabled('LC_CTYPE');

        $desc = "use re 'taint': match with pattern tainted via locale";

        $s = 'abcd';
        {
            use locale;
            $res = $s =~ /(\w+)/; $one = $1;
        }
        isnt_tainted($s,   "$desc: s not tainted");
        isnt_tainted($res, "$desc: res not tainted");
        is_tainted($one,   "$desc: \$1 tainted");
        is($res, 1,        "$desc: res value");
        is($one, 'abcd',   "$desc: \$1 value");

        $desc = "use re 'taint': match /g with pattern tainted via locale";

        $s = 'abcd';
        {
            use locale;
            $res = $s =~ /(\w)/g; $one = $1;
        }
        isnt_tainted($s,   "$desc: s not tainted");
        isnt_tainted($res, "$desc: res not tainted");
        is_tainted($one,   "$desc: \$1 tainted");
        is($res, 1,        "$desc: res value");
        is($one, 'a',      "$desc: \$1 value");
    }

	$desc = "use re 'taint': match with pattern tainted, list cxt";

	$s = 'abcd';
	($res) = $s =~ /$TAINT(.+)/;
	$one = $1;
	isnt_tainted($s,   "$desc: s not tainted");
	is_tainted($res,   "$desc: res tainted");
	is_tainted($one,   "$desc: \$1 tainted");
	is($res, 'abcd',   "$desc: res value");
	is($one, 'abcd',   "$desc: \$1 value");

	$desc = "use re 'taint': match /g with pattern tainted, list cxt";

	$s = 'abcd';
	($res, $res2) = $s =~ /$TAINT(.)/g;
	$one = $1;
	isnt_tainted($s,   "$desc: s not tainted");
	is_tainted($res,   "$desc: res tainted");
	is_tainted($one,   "$desc: \$1 tainted");
	is($res, 'a',      "$desc: res value");
	is($res2,'b',      "$desc: res2 value");
	is($one, 'd',      "$desc: \$1 value");

  SKIP: {
        skip 'Locales not available', 12 unless locales_enabled('LC_CTYPE');

        $desc = "use re 'taint': match with pattern tainted via locale, list cxt";

        $s = 'abcd';
        {
            use locale;
            ($res) = $s =~ /(\w+)/; $one = $1;
        }
        isnt_tainted($s,   "$desc: s not tainted");
        is_tainted($res,   "$desc: res tainted");
        is_tainted($one,   "$desc: \$1 tainted");
        is($res, 'abcd',   "$desc: res value");
        is($one, 'abcd',   "$desc: \$1 value");

        $desc = "use re 'taint': match /g with pattern tainted via locale, list cxt";

        $s = 'abcd';
        {
            use locale;
            ($res, $res2) = $s =~ /(\w)/g; $one = $1;
        }
        isnt_tainted($s,   "$desc: s not tainted");
        is_tainted($res,   "$desc: res tainted");
        is_tainted($res2,  "$desc: res2 tainted");
        is_tainted($one,   "$desc: \$1 tainted");
        is($res, 'a',      "$desc: res value");
        is($res2,'b',      "$desc: res2 value");
        is($one, 'd',      "$desc: \$1 value");
    }

	$desc = "use re 'taint': substitution with string tainted";

	$s = 'abcd' . $TAINT;
	$res = $s =~ s/(.+)/xyz/;
	$one = $1;
	is_tainted($s,     "$desc: s tainted");
	isnt_tainted($res, "$desc: res not tainted");
	is_tainted($one,   "$desc: \$1 tainted");
	is($s,   'xyz',    "$desc: s value");
	is($res, 1,        "$desc: res value");
	is($one, 'abcd',   "$desc: \$1 value");

	$desc = "use re 'taint': substitution /g with string tainted";

	$s = 'abcd' . $TAINT;
	$res = $s =~ s/(.)/x/g;
	$one = $1;
	is_tainted($s,     "$desc: s tainted");
	is_tainted($res,   "$desc: res tainted");
	is_tainted($one,   "$desc: \$1 tainted");
	is($s,   'xxxx',   "$desc: s value");
	is($res, 4,        "$desc: res value");
	is($one, 'd',      "$desc: \$1 value");

	$desc = "use re 'taint': substitution /r with string tainted";

	$s = 'abcd' . $TAINT;
	$res = $s =~ s/(.+)/xyz/r;
	$one = $1;
	is_tainted($s,     "$desc: s tainted");
	is_tainted($res,   "$desc: res tainted");
	is_tainted($one,   "$desc: \$1 tainted");
	is($s,   'abcd',   "$desc: s value");
	is($res, 'xyz',    "$desc: res value");
	is($one, 'abcd',   "$desc: \$1 value");

	$desc = "use re 'taint': substitution /e with string tainted";

	$s = 'abcd' . $TAINT;
	$one = '';
	$res = $s =~ s{(.+)}{
		    $one = $one . "x"; # make sure code not tainted
		    isnt_tainted($one, "$desc: code not tainted within /e");
		    $one = $1;
		    is_tainted($one, "$desc: $1 tainted within /e");
		    "xyz";
		}e;
	$one = $1;
	is_tainted($s,     "$desc: s tainted");
	isnt_tainted($res, "$desc: res not tainted");
	is_tainted($one,   "$desc: \$1 tainted");
	is($s,   'xyz',    "$desc: s value");
	is($res, 1,        "$desc: res value");
	is($one, 'abcd',   "$desc: \$1 value");

	$desc = "use re 'taint': substitution with pattern tainted";

	$s = 'abcd';
	$res = $s =~ s/$TAINT(.+)/xyz/;
	$one = $1;
	is_tainted($s,     "$desc: s tainted");
	isnt_tainted($res, "$desc: res not tainted");
	is_tainted($one,   "$desc: \$1 tainted");
	is($s,  'xyz',     "$desc: s value");
	is($res, 1,        "$desc: res value");
	is($one, 'abcd',   "$desc: \$1 value");

	$desc = "use re 'taint': substitution /g with pattern tainted";

	$s = 'abcd';
	$res = $s =~ s/$TAINT(.)/x/g;
	$one = $1;
	is_tainted($s,     "$desc: s tainted");
	is_tainted($res,   "$desc: res tainted");
	is_tainted($one,   "$desc: \$1 tainted");
	is($s,  'xxxx',    "$desc: s value");
	is($res, 4,        "$desc: res value");
	is($one, 'd',      "$desc: \$1 value");

	$desc = "use re 'taint': substitution /ge with pattern tainted";

	$s = 'abc';
	{
	    my $i = 0;
	    my $j;
	    $res = $s =~ s{(.)$TAINT}{
			$j = $i; # make sure code not tainted
			$one = $1;
			isnt_tainted($j, "$desc: code not tainted within /e");
			$i++;
			if ($i == 1) {
			    isnt_tainted($s,   "$desc: s not tainted loop 1");
			}
			else {
			    is_tainted($s,     "$desc: s tainted loop $i");
			}
			is_tainted($one,   "$desc: \$1 tainted loop $i");
			$i.$TAINT;
		    }ge;
	    $one = $1;
	}
	is_tainted($s,     "$desc: s tainted");
	is_tainted($res,   "$desc: res tainted");
	is_tainted($one,   "$desc: \$1 tainted");
	is($s,  '123',     "$desc: s value");
	is($res, 3,        "$desc: res value");
	is($one, 'c',      "$desc: \$1 value");


	$desc = "use re 'taint': substitution /r with pattern tainted";

	$s = 'abcd';
	$res = $s =~ s/$TAINT(.+)/xyz/r;
	$one = $1;
	isnt_tainted($s,   "$desc: s not tainted");
	is_tainted($res,   "$desc: res tainted");
	is_tainted($one,   "$desc: \$1 tainted");
	is($s,  'abcd',    "$desc: s value");
	is($res, 'xyz',    "$desc: res value");
	is($one, 'abcd',   "$desc: \$1 value");

  SKIP: {
        skip 'Locales not available', 18 unless locales_enabled('LC_CTYPE');

        $desc = "use re 'taint': substitution with pattern tainted via locale";

        $s = 'abcd';
        {
            use locale;
            $res = $s =~ s/(\w+)/xyz/; $one = $1;
        }
        is_tainted($s,     "$desc: s tainted");
        isnt_tainted($res, "$desc: res not tainted");
        is_tainted($one,   "$desc: \$1 tainted");
        is($s,  'xyz',     "$desc: s value");
        is($res, 1,        "$desc: res value");
        is($one, 'abcd',   "$desc: \$1 value");

        $desc = "use re 'taint': substitution /g with pattern tainted via locale";

        $s = 'abcd';
        {
            use locale;
            $res = $s =~ s/(\w)/x/g; $one = $1;
        }
        is_tainted($s,     "$desc: s tainted");
        is_tainted($res,   "$desc: res tainted");
        is_tainted($one,   "$desc: \$1 tainted");
        is($s,  'xxxx',    "$desc: s value");
        is($res, 4,        "$desc: res value");
        is($one, 'd',      "$desc: \$1 value");

        $desc = "use re 'taint': substitution /r with pattern tainted via locale";

        $s = 'abcd';
        {
            use locale;
            $res = $s =~ s/(\w+)/xyz/r; $one = $1;
        }
        isnt_tainted($s,   "$desc: s not tainted");
        is_tainted($res,   "$desc: res tainted");
        is_tainted($one,   "$desc: \$1 tainted");
        is($s,  'abcd',    "$desc: s value");
        is($res, 'xyz',    "$desc: res value");
        is($one, 'abcd',   "$desc: \$1 value");
    }

	$desc = "use re 'taint': substitution with replacement tainted";

	$s = 'abcd';
	$res = $s =~ s/(.+)/xyz$TAINT/;
	$one = $1;
	is_tainted($s,     "$desc: s tainted");
	isnt_tainted($res, "$desc: res not tainted");
	isnt_tainted($one, "$desc: \$1 not tainted");
	is($s,  'xyz',     "$desc: s value");
	is($res, 1,        "$desc: res value");
	is($one, 'abcd',   "$desc: \$1 value");

	$desc = "use re 'taint': substitution /g with replacement tainted";

	$s = 'abcd';
	$res = $s =~ s/(.)/x$TAINT/g;
	$one = $1;
	is_tainted($s,     "$desc: s tainted");
	isnt_tainted($res, "$desc: res not tainted");
	isnt_tainted($one, "$desc: \$1 not tainted");
	is($s,  'xxxx',    "$desc: s value");
	is($res, 4,        "$desc: res value");
	is($one, 'd',      "$desc: \$1 value");

	$desc = "use re 'taint': substitution /ge with replacement tainted";

	$s = 'abc';
	{
	    my $i = 0;
	    my $j;
	    $res = $s =~ s{(.)}{
			$j = $i; # make sure code not tainted
			$one = $1;
			isnt_tainted($j, "$desc: code not tainted within /e");
			$i++;
			if ($i == 1) {
			    isnt_tainted($s,   "$desc: s not tainted loop 1");
			}
			else {
			    is_tainted($s,     "$desc: s tainted loop $i");
			}
			    isnt_tainted($one, "$desc: \$1 not tainted");
			$i.$TAINT;
		    }ge;
	    $one = $1;
	}
	is_tainted($s,     "$desc: s tainted");
	isnt_tainted($res, "$desc: res tainted");
	isnt_tainted($one, "$desc: \$1 not tainted");
	is($s,  '123',     "$desc: s value");
	is($res, 3,        "$desc: res value");
	is($one, 'c',      "$desc: \$1 value");

	$desc = "use re 'taint': substitution /r with replacement tainted";

	$s = 'abcd';
	$res = $s =~ s/(.+)/xyz$TAINT/r;
	$one = $1;
	isnt_tainted($s,   "$desc: s not tainted");
	is_tainted($res,   "$desc: res tainted");
	isnt_tainted($one, "$desc: \$1 not tainted");
	is($s,   'abcd',   "$desc: s value");
	is($res, 'xyz',    "$desc: res value");
	is($one, 'abcd',   "$desc: \$1 value");

        # [perl #121854] match taintedness became sticky
        # when one match has a taintess result, subseqent matches
        # using the same pattern shouldn't necessarily be tainted

        {
            my $f = sub { $_[0] =~ /(.*)/ or die; $1 };
            $res = $f->($TAINT);
            is_tainted($res,   "121854: res tainted");
            $res = $f->("abc");
            isnt_tainted($res,   "121854: res not tainted");
        }
    }

    $foo = $1 if 'bar' =~ /(.+)$TAINT/;
    is_tainted($foo);
    is($foo, 'bar');

    my $pi = 4 * atan2(1,1) + $TAINT0;
    is_tainted($pi);

    ($pi) = $pi =~ /(\d+\.\d+)/;
    isnt_tainted($pi);
    is(sprintf("%.5f", $pi), '3.14159');
}

# How about command-line arguments? The problem is that we don't
# always get some, so we'll run another process with some.
SKIP: {
    my $arg = tempfile();
    open $fh, '>', $arg or die "Can't create $arg: $!";
    print $fh q{
	eval { join('', @@ARGV), kill 0 };
	exit 0 if $@@ =~ /^Insecure dependency/;
	print "# Oops: \$@@ was [$@@]\n";
	exit 1;
    };
    close $fh or die "Can't close $arg: $!";
    print `$Invoke_Perl "-T" $arg and some suspect arguments`;
    is($?, 0, "Exited with status $?");
    unlink $arg;
}

# Reading from a file should be tainted
{
    ok(open my $fh, '<', $TEST) or diag("Couldn't open '$TEST': $!");

    my $block;
    sysread($fh, $block, 100);
    my $line = <$fh>;
    close $fh;
    is_tainted($block);
    is_tainted($line);
}

# Output of commands should be tainted
{
    my $foo = `$echo abc`;
    is_tainted($foo);
}

# Certain system variables should be tainted
{
    is_tainted($^X);
    is_tainted($0);
}

# Results of matching should all be untainted
{
    my $foo = "abcdefghi" . $TAINT;
    is_tainted($foo);

    $foo =~ /def/;
    isnt_tainted($`);
    isnt_tainted($&);
    isnt_tainted($');

    $foo =~ /(...)(...)(...)/;
    isnt_tainted($1);
    isnt_tainted($2);
    isnt_tainted($3);
    isnt_tainted($+);

    my @@bar = $foo =~ /(...)(...)(...)/;
    isnt_tainted($_) foreach @@bar;

    is_tainted($foo);	# $foo should still be tainted!
    is($foo, "abcdefghi");
}

# Operations which affect files can't use tainted data.
{
    violates_taint(sub { chmod 0, $TAINT }, 'chmod');

    SKIP: {
        skip "truncate() is not available", 2 unless $Config{d_truncate};

	violates_taint(sub { truncate 'NoSuChFiLe', $TAINT0 }, 'truncate');
    }

    violates_taint(sub { rename '', $TAINT }, 'rename');
    violates_taint(sub { unlink $TAINT }, 'unlink');
    violates_taint(sub { utime $TAINT }, 'utime');

    SKIP: {
        skip "chown() is not available", 2 unless $Config{d_chown};

	violates_taint(sub { chown -1, -1, $TAINT }, 'chown');
    }

    SKIP: {
        skip "link() is not available", 2 unless $Config{d_link};

violates_taint(sub { link $TAINT, '' }, 'link');
    }

    SKIP: {
        skip "symlink() is not available", 2 unless $Config{d_symlink};

	violates_taint(sub { symlink $TAINT, '' }, 'symlink');
    }
}

# Operations which affect directories can't use tainted data.
{
    violates_taint(sub { mkdir "foo".$TAINT, 0755 . $TAINT0 }, 'mkdir');
    violates_taint(sub { rmdir $TAINT }, 'rmdir');
    violates_taint(sub { chdir "foo".$TAINT }, 'chdir');

    SKIP: {
        skip "chroot() is not available", 2 unless $Config{d_chroot};

	violates_taint(sub { chroot $TAINT }, 'chroot');
    }
}

# Some operations using files can't use tainted data.
{
    my $foo = "imaginary library" . $TAINT;
    violates_taint(sub { require $foo }, 'require');

    my $filename = tempfile();	# NB: $filename isn't tainted!
    $foo = $filename . $TAINT;
    unlink $filename;	# in any case

    is(eval { open FOO, $foo }, undef, 'open for read');
    is($@@, '');                # NB: This should be allowed
    is(eval { open my $fh, , '<', $foo }, undef, 'open for read');
    is($@@, '');                # NB: This should be allowed

    # Try first new style but allow also old style.
    # We do not want the whole taint.t to fail
    # just because Errno possibly failing.
    ok(eval('$!{ENOENT}') ||
	$! == 2 || # File not found
	($Is_Dos && $! == 22));

    violates_taint(sub { open FOO, "> $foo" }, 'open', 'open for write');
    violates_taint(sub { open my $fh, '>', $foo }, 'open', 'open for write');
}

# Commands to the system can't use tainted data
{
    my $foo = $TAINT;

    SKIP: {
        skip "open('|') is not available", 8 if $^O eq 'amigaos';

        violates_taint(sub { open FOO, "| x$foo" }, 'piped open', 'popen to');
        violates_taint(sub { open FOO, "x$foo |" }, 'piped open', 'popen from');
        violates_taint(sub { open my $fh, '|-', "x$foo" }, 'piped open', 'popen to');
        violates_taint(sub { open my $fh, '-|', "x$foo" }, 'piped open', 'popen from');
    }

    violates_taint(sub { exec $TAINT }, 'exec');
    violates_taint(sub { system $TAINT }, 'system');

    $foo = "*";
    taint_these $foo;

    violates_taint(sub { `$echo 1$foo` }, '``', 'backticks');

    SKIP: {
        # wildcard expansion doesn't invoke shell on VMS, so is safe
        skip "This is not VMS", 2 unless $Is_VMS;
    
	isnt(join('', eval { glob $foo } ), '', 'globbing');
	is($@@, '');
    }
}

# Operations which affect processes can't use tainted data.
{
    violates_taint(sub { kill 0, $TAINT }, 'kill');

    SKIP: {
        skip "setpgrp() is not available", 2 unless $Config{d_setpgrp};

	violates_taint(sub { setpgrp 0, $TAINT0 }, 'setpgrp');
    }

    SKIP: {
        skip "setpriority() is not available", 2 unless $Config{d_setprior};

	violates_taint(sub { setpriority 0, $TAINT0, $TAINT0 }, 'setpriority');
    }
}

# Some miscellaneous operations can't use tainted data.
{
    SKIP: {
        skip "syscall() is not available", 2 unless $Config{d_syscall};

	violates_taint(sub { syscall $TAINT }, 'syscall');
    }

    {
	my $foo = "x" x 979;
	taint_these $foo;
	local *FOO;
	my $temp = tempfile();
	ok(open FOO, "> $temp") or diag("Couldn't open $temp for write: $!");
	violates_taint(sub { ioctl FOO, $TAINT0, $foo }, 'ioctl');

	my $temp2 = tempfile();
	ok(open my $fh, '>', $temp2) or diag("Couldn't open $temp2 for write: $!");
	violates_taint(sub { ioctl $fh, $TAINT0, $foo }, 'ioctl');

        SKIP: {
            skip "fcntl() is not available", 4 unless $Config{d_fcntl};

	    violates_taint(sub { fcntl FOO, $TAINT0, $foo }, 'fcntl');
	    violates_taint(sub { fcntl $fh, $TAINT0, $foo }, 'fcntl');
	}

	close FOO;
    }
}

# Some tests involving references
{
    my $foo = 'abc' . $TAINT;
    my $fooref = \$foo;
    isnt_tainted($fooref);
    is_tainted($$fooref);
    is_tainted($foo);
}

# Some tests involving assignment
{
    my $foo = $TAINT0;
    my $bar = $foo;
    is_tainted($foo);
    is_tainted($bar);
    is_tainted($foo = $bar);
    is_tainted($bar = $bar);
    is_tainted($bar += $bar);
    is_tainted($bar -= $bar);
    is_tainted($bar *= $bar);
    is_tainted($bar++);
    is_tainted($bar /= $bar);
    is_tainted($bar += 0);
    is_tainted($bar -= 2);
    is_tainted($bar *= -1);
    is_tainted($bar /= 1);
    is_tainted($bar--);
    is($bar, 0);
}

# Test assignment and return of lists
{
    my @@foo = ("A", "tainted" . $TAINT, "B");
    isnt_tainted($foo[0]);
    is_tainted(    $foo[1]);
    isnt_tainted($foo[2]);
    my @@bar = @@foo;
    isnt_tainted($bar[0]);
    is_tainted(    $bar[1]);
    isnt_tainted($bar[2]);
    my @@baz = eval { "A", "tainted" . $TAINT, "B" };
    isnt_tainted($baz[0]);
    is_tainted(    $baz[1]);
    isnt_tainted($baz[2]);
    my @@plugh = eval q[ "A", "tainted" . $TAINT, "B" ];
    isnt_tainted($plugh[0]);
    is_tainted(    $plugh[1]);
    isnt_tainted($plugh[2]);
    my $nautilus = sub { "A", "tainted" . $TAINT, "B" };
    isnt_tainted(((&$nautilus)[0]));
    is_tainted(    ((&$nautilus)[1]));
    isnt_tainted(((&$nautilus)[2]));
    my @@xyzzy = &$nautilus;
    isnt_tainted($xyzzy[0]);
    is_tainted(    $xyzzy[1]);
    isnt_tainted($xyzzy[2]);
    my $red_october = sub { return "A", "tainted" . $TAINT, "B" };
    isnt_tainted(((&$red_october)[0]));
    is_tainted(    ((&$red_october)[1]));
    isnt_tainted(((&$red_october)[2]));
    my @@corge = &$red_october;
    isnt_tainted($corge[0]);
    is_tainted(    $corge[1]);
    isnt_tainted($corge[2]);
}

# Test for system/library calls returning string data of dubious origin.
{
    # No reliable %Config check for getpw*
    SKIP: {
        skip "getpwent() is not available", 9 unless 
          eval { setpwent(); getpwent() };

	setpwent();
	my @@getpwent = getpwent();
	die "getpwent: $!\n" unless (@@getpwent);
	isnt_tainted($getpwent[0]);
	is_tainted($getpwent[1]);
	isnt_tainted($getpwent[2]);
	isnt_tainted($getpwent[3]);
	isnt_tainted($getpwent[4]);
	isnt_tainted($getpwent[5]);
	is_tainted($getpwent[6], 'ge?cos');
	isnt_tainted($getpwent[7]);
	is_tainted($getpwent[8], 'shell');
	endpwent();
    }

    SKIP: {
        # pretty hard to imagine not
        skip "readdir() is not available", 1 unless $Config{d_readdir};

	opendir my $dh, "op" or die "opendir: $!\n";
	my $readdir = readdir $dh;
	is_tainted($readdir);
	closedir $dh;
    }

    SKIP: {
        skip "readlink() or symlink() is not available" unless 
          $Config{d_readlink} && $Config{d_symlink};

	my $symlink = "sl$$";
	unlink($symlink);
	my $sl = "/something/naughty";
	# it has to be a real path on Mac OS
	symlink($sl, $symlink) or die "symlink: $!\n";
	my $readlink = readlink($symlink);
	is_tainted($readlink);
	unlink($symlink);
    }
}

# test bitwise ops (regression bug)
{
    my $why = "y";
    my $j = "x" | $why;
    isnt_tainted($j);
    $why = $TAINT."y";
    $j = "x" | $why;
    is_tainted(    $j);
}

# test target of substitution (regression bug)
{
    my $why = $TAINT."y";
    $why =~ s/y/z/;
    is_tainted(    $why);

    my $z = "[z]";
    $why =~ s/$z/zee/;
    is_tainted(    $why);

    $why =~ s/e/'-'.$$/ge;
    is_tainted(    $why);
}


SKIP: {
    skip "no IPC::SysV", 2 unless $ipcsysv;

    # test shmread
    SKIP: {
        skip "shm*() not available", 1 unless $Config{d_shm};

        no strict 'subs';
        my $sent = "foobar";
        my $rcvd;
        my $size = 2000;
        my $id;
        eval {
            local $SIG{SYS} = sub { die "SIGSYS caught\n" };
            $id = shmget(IPC_PRIVATE, $size, S_IRWXU);
            1;
        } or do { chomp(my $msg = $@@); skip "shmget: $msg", 1; };

        if (defined $id) {
            if (shmwrite($id, $sent, 0, 60)) {
                if (shmread($id, $rcvd, 0, 60)) {
                    substr($rcvd, index($rcvd, "\0")) = '';
                } else {
                    warn "# shmread failed: $!\n";
                }
            } else {
                warn "# shmwrite failed: $!\n";
            }
            shmctl($id, IPC_RMID, 0) or warn "# shmctl failed: $!\n";
        } else {
            warn "# shmget failed: $!\n";
        }

        skip "SysV shared memory operation failed", 1 unless 
          $rcvd eq $sent;

        is_tainted($rcvd, "shmread");
    }


    # test msgrcv
    SKIP: {
        skip "msg*() not available", 1 unless $Config{d_msg};

	no strict 'subs';
        my $id;
        eval {
            local $SIG{SYS} = sub { die "SIGSYS caught\n" };
            $id = msgget(IPC_PRIVATE, IPC_CREAT | S_IRWXU);
            1;
        } or do { chomp(my $msg = $@@); skip "msgget: $msg", 1; };

	my $sent      = "message";
	my $type_sent = 1234;
	my $rcvd;
	my $type_rcvd;

	if (defined $id) {
	    if (msgsnd($id, pack("l! a*", $type_sent, $sent), IPC_NOWAIT)) {
		if (msgrcv($id, $rcvd, 60, 0, IPC_NOWAIT)) {
		    ($type_rcvd, $rcvd) = unpack("l! a*", $rcvd);
		} else {
		    warn "# msgrcv failed: $!\n";
		}
	    } else {
		warn "# msgsnd failed: $!\n";
	    }
	    msgctl($id, IPC_RMID, 0) or warn "# msgctl failed: $!\n";
	} else {
	    warn "# msgget failed\n";
	}

        SKIP: {
            skip "SysV message queue operation failed", 1
              unless $rcvd eq $sent && $type_sent == $type_rcvd;

	    is_tainted($rcvd, "msgrcv");
	}
    }
}

{
    # bug id 20001004.006

    open my $fh, '<', $TEST or warn "$0: cannot read $TEST: $!" ;
    local $/;
    my $a = <$fh>;
    my $b = <$fh>;

    is_tainted($a);
    is_tainted($b);
    is($b, undef);
}

{
    # bug id 20001004.007

    open my $fh, '<', $TEST or warn "$0: cannot read $TEST: $!" ;
    my $a = <$fh>;

    my $c = { a => 42,
	      b => $a };

    isnt_tainted($c->{a});
    is_tainted($c->{b});


    my $d = { a => $a,
	      b => 42 };
    is_tainted($d->{a});
    isnt_tainted($d->{b});


    my $e = { a => 42,
	      b => { c => $a, d => 42 } };
    isnt_tainted($e->{a});
    isnt_tainted($e->{b});
    is_tainted($e->{b}->{c});
    isnt_tainted($e->{b}->{d});
}

{
    # bug id 20010519.003

    BEGIN {
	use vars qw($has_fcntl);
	eval { require Fcntl; import Fcntl; };
	unless ($@@) {
	    $has_fcntl = 1;
	}
    }

    SKIP: {
        skip "no Fcntl", 36 unless $has_fcntl;

	my $foo = tempfile();
	my $evil = $foo . $TAINT;

	is(eval { sysopen(my $ro, $evil, &O_RDONLY) }, undef);
	is($@@, '');

	violates_taint(sub { sysopen(my $wo, $evil, &O_WRONLY) }, 'sysopen');
	violates_taint(sub { sysopen(my $rw, $evil, &O_RDWR) }, 'sysopen');
	violates_taint(sub { sysopen(my $ap, $evil, &O_APPEND) }, 'sysopen');
	violates_taint(sub { sysopen(my $cr, $evil, &O_CREAT) }, 'sysopen');
	violates_taint(sub { sysopen(my $tr, $evil, &O_TRUNC) }, 'sysopen');

	is(eval { sysopen(my $ro, $foo, &O_RDONLY | $TAINT0) }, undef);
	is($@@, '');

	violates_taint(sub { sysopen(my $wo, $foo, &O_WRONLY | $TAINT0) }, 'sysopen');
	violates_taint(sub { sysopen(my $rw, $foo, &O_RDWR | $TAINT0) }, 'sysopen');
	violates_taint(sub { sysopen(my $ap, $foo, &O_APPEND | $TAINT0) }, 'sysopen');
	violates_taint(sub { sysopen(my $cr, $foo, &O_CREAT | $TAINT0) }, 'sysopen');
	violates_taint(sub { sysopen(my $tr, $foo, &O_TRUNC | $TAINT0) }, 'sysopen');
	is(eval { sysopen(my $ro, $foo, &O_RDONLY, $TAINT0) }, undef);
	is($@@, '');

	violates_taint(sub { sysopen(my $wo, $foo, &O_WRONLY, $TAINT0) }, 'sysopen');
	violates_taint(sub { sysopen(my $rw, $foo, &O_RDWR, $TAINT0) }, 'sysopen');
	violates_taint(sub { sysopen(my $ap, $foo, &O_APPEND, $TAINT0) }, 'sysopen');
	violates_taint(sub { sysopen(my $cr, $foo, &O_CREAT, $TAINT0) }, 'sysopen');
	violates_taint(sub { sysopen(my $tr, $foo, &O_TRUNC, $TAINT0) }, 'sysopen');
    }
}

{
    # bug 20010526.004

    use warnings;

    my $saw_warning = 0;
    local $SIG{__WARN__} = sub { ++$saw_warning };

    sub fmi {
	my $divnum = shift()/1;
	sprintf("%1.1f\n", $divnum);
    }

    fmi(21 . $TAINT);
    fmi(37);
    fmi(248);

    is($saw_warning, 0);
}


{
    # Bug ID 20010730.010

    my $i = 0;

    sub Tie::TIESCALAR {
        my $class =  shift;
        my $arg   =  shift;

        bless \$arg => $class;
    }

    sub Tie::FETCH {
        $i ++;
        ${$_ [0]}
    }

 
    package main;
 
    my $bar = "The Big Bright Green Pleasure Machine";
    taint_these $bar;
    tie my ($foo), Tie => $bar;

    my $baz = $foo;

    ok $i == 1;
}

{
    # Check that all environment variables are tainted.
    my @@untainted;
    while (my ($k, $v) = each %ENV) {
	if (!tainted($v) &&
	    # These we have explicitly untainted or set earlier.
	    $k !~ /^(BASH_ENV|CDPATH|ENV|IFS|PATH|PERL_CORE|TEMP|TERM|TMP)$/) {
	    push @@untainted, "# '$k' = '$v'\n";
	}
    }
    is("@@untainted", "");
}


is(${^TAINT}, 1, '$^TAINT is on');

eval { ${^TAINT} = 0 };
is(${^TAINT}, 1, '$^TAINT is not assignable');
like($@@, qr/^Modification of a read-only value attempted/,
     'Assigning to ${^TAINT} fails');

{
    # bug 20011111.105
    
    my $re1 = qr/x$TAINT/;
    is_tainted($re1);
    
    my $re2 = qr/^$re1\z/;
    is_tainted($re2);
    
    my $re3 = "$re2";
    is_tainted($re3);
}

SKIP: {
    skip "system {} has different semantics on Win32", 1 if $Is_MSWin32;

    # bug 20010221.005
    local $ENV{PATH} .= $TAINT;
    eval { system { "echo" } "/arg0", "arg1" };
    like($@@, qr/^Insecure \$ENV/);
}

TODO: {
    todo_skip 'tainted %ENV warning occludes tainted arguments warning', 22
      if $Is_VMS;

    # bug 20020208.005 plus some single arg exec/system extras
    violates_taint(sub { exec $TAINT, $TAINT }, 'exec');
    violates_taint(sub { exec $TAINT $TAINT }, 'exec');
    violates_taint(sub { exec $TAINT $TAINT, $TAINT }, 'exec');
    violates_taint(sub { exec $TAINT 'notaint' }, 'exec');
    violates_taint(sub { exec {'notaint'} $TAINT }, 'exec');

    violates_taint(sub { system $TAINT, $TAINT }, 'system');
    violates_taint(sub { system $TAINT $TAINT }, 'system');
    violates_taint(sub { system $TAINT $TAINT, $TAINT }, 'system');
    violates_taint(sub { system $TAINT 'notaint' }, 'system');
    violates_taint(sub { system {'notaint'} $TAINT }, 'system');

    eval { 
        no warnings;
        system("lskdfj does not exist","with","args"); 
    };
    is($@@, "");

    eval {
	no warnings;
	exec("lskdfj does not exist","with","args"); 
    };
    is($@@, "");

    # If you add tests here update also the above skip block for VMS.
}

{
    # [ID 20020704.001] taint propagation failure
    use re 'taint';
    $TAINT =~ /(.*)/;
    is_tainted(my $foo = $1);
}

{
    # [perl #24291] this used to dump core
    our %nonmagicalenv = ( PATH => "util" );
    local *ENV = \%nonmagicalenv;
    eval { system("lskdfj"); };
    like($@@, qr/^%ENV is aliased to another variable while running with -T switch/);
    local *ENV = *nonmagicalenv;
    eval { system("lskdfj"); };
    like($@@, qr/^%ENV is aliased to %nonmagicalenv while running with -T switch/);
}
{
    # [perl #24248]
    $TAINT =~ /(.*)/;
    isnt_tainted($1);
    my $notaint = $1;
    isnt_tainted($notaint);

    my $l;
    $notaint =~ /($notaint)/;
    $l = $1;
    isnt_tainted($1);
    isnt_tainted($l);
    $notaint =~ /($TAINT)/;
    $l = $1;
    is_tainted($1);
    is_tainted($l);

    $TAINT =~ /($notaint)/;
    $l = $1;
    isnt_tainted($1);
    isnt_tainted($l);
    $TAINT =~ /($TAINT)/;
    $l = $1;
    is_tainted($1);
    is_tainted($l);

    my $r;
    ($r = $TAINT) =~ /($notaint)/;
    isnt_tainted($1);
    ($r = $TAINT) =~ /($TAINT)/;
    is_tainted($1);

    {
	use re 'eval'; # this shouldn't make any difference
	($r = $TAINT) =~ /($notaint)/;
	isnt_tainted($1);
	($r = $TAINT) =~ /($TAINT)/;
	is_tainted($1);
    }

    #  [perl #24674]
    # accessing $^O  shoudn't taint it as a side-effect;
    # assigning tainted data to it is now an error

    isnt_tainted($^O);
    if (!$^X) { } elsif ($^O eq 'bar') { }
    isnt_tainted($^O);
    local $^O;  # We're going to clobber something test infrastructure depends on.
    eval '$^O = $^X';
    like($@@, qr/Insecure dependency in/);
}

EFFECTIVELY_CONSTANTS: {
    my $tainted_number = 12 + $TAINT0;
    is_tainted( $tainted_number );

    # Even though it's always 0, it's still tainted
    my $tainted_product = $tainted_number * 0;
    is_tainted( $tainted_product );
    is($tainted_product, 0);
}

TERNARY_CONDITIONALS: {
    my $tainted_true  = $TAINT . "blah blah blah";
    my $tainted_false = $TAINT0;
    is_tainted( $tainted_true );
    is_tainted( $tainted_false );

    my $result = $tainted_true ? "True" : "False";
    is($result, "True");
    isnt_tainted( $result );

    $result = $tainted_false ? "True" : "False";
    is($result, "False");
    isnt_tainted( $result );

    my $untainted_whatever = "The Fabulous Johnny Cash";
    my $tainted_whatever = "Soft Cell" . $TAINT;

    $result = $tainted_true ? $tainted_whatever : $untainted_whatever;
    is($result, "Soft Cell");
    is_tainted( $result );

    $result = $tainted_false ? $tainted_whatever : $untainted_whatever;
    is($result, "The Fabulous Johnny Cash");
    isnt_tainted( $result );
}

{
    # rt.perl.org 5900  $1 remains tainted if...
    # 1) The regular expression contains a scalar variable AND
    # 2) The regular expression appears in an elsif clause

    my $foo = "abcdefghi" . $TAINT;

    my $valid_chars = 'a-z';
    if ( $foo eq '' ) {
    }
    elsif ( $foo =~ /([$valid_chars]+)/o ) {
	isnt_tainted($1);
	isnt($1, undef);
    }

    if ( $foo eq '' ) {
    }
    elsif ( my @@bar = $foo =~ /([$valid_chars]+)/o ) {
	isnt_tainted($bar[0]);
	is(scalar @@bar, 1);
    }
}

# at scope exit, a restored localised value should have its old
# taint status, not the taint status of the current statement

{
    our $x99 = $^X;
    is_tainted($x99);

    $x99 = '';
    isnt_tainted($x99);

    my $c = do { local $x99; $^X };
    isnt_tainted($x99);
}
{
    our $x99 = $^X;
    is_tainted($x99);

    my $c = do { local $x99; '' };
    is_tainted($x99);
}

# an mg_get of a tainted value during localization shouldn't taint the
# statement

{
    eval { local $0, eval '1' };
    is($@@, '');
}

# [perl #8262] //g loops infinitely on tainted data

{
    my @@a;
    $a[0] = $^X . '-';
    $a[0]=~ m/(.)/g;
    cmp_ok pos($a[0]), '>', 0, "infinite m//g on arrays (aelemfast)";

    my $i = 1;
    $a[$i] = $^X . '-';
    $a[$i]=~ m/(.)/g;
    cmp_ok pos($a[$i]), '>', 0, "infinite m//g on arrays (aelem)";

    my %h;
    $h{a} = $^X . '-';
    $h{a}=~ m/(.)/g;
    cmp_ok pos($h{a}), '>', 0, "infinite m//g on hashes (helem)";
}

SKIP:
{
    my $got_dualvar;
    eval 'use Scalar::Util "dualvar"; $got_dualvar++';
    skip "No Scalar::Util::dualvar" unless $got_dualvar;
    my $a = Scalar::Util::dualvar(3, $^X);
    my $b = $a + 5;
    is ($b, 8, "Arithmetic on tainted dualvars works");
}

# opening '|-' should not trigger $ENV{PATH} check

{
    SKIP: {
	skip "fork() is not available", 3 unless $Config{'d_fork'};
	skip "opening |- is not stable on threaded Open/MirBSD with taint", 3
            if $Config{useithreads} and $Is_OpenBSD || $Is_MirBSD;

	$ENV{'PATH'} = $TAINT;
	local $SIG{'PIPE'} = 'IGNORE';
	eval {
	    my $pid = open my $pipe, '|-';
	    if (!defined $pid) {
		die "open failed: $!";
	    }
	    if (!$pid) {
		kill 'KILL', $$;	# child suicide
	    }
	    close $pipe;
	};
	unlike($@@, qr/Insecure \$ENV/, 'fork triggers %ENV check');
	is($@@, '',               'pipe/fork/open/close failed');
	eval {
	    open my $pipe, "|$Invoke_Perl -e 1";
	    close $pipe;
	};
	like($@@, qr/Insecure \$ENV/, 'popen neglects %ENV check');
    }
}

{
    package AUTOLOAD_TAINT;
    sub AUTOLOAD {
        our $AUTOLOAD;
        return if $AUTOLOAD =~ /DESTROY/;
        if ($AUTOLOAD =~ /untainted/) {
            main::isnt_tainted($AUTOLOAD, '$AUTOLOAD can be untainted');
            my $copy = $AUTOLOAD;
            main::isnt_tainted($copy, '$AUTOLOAD can be untainted');
        } else {
            main::is_tainted($AUTOLOAD, '$AUTOLOAD can be tainted');
            my $copy = $AUTOLOAD;
            main::is_tainted($copy, '$AUTOLOAD can be tainted');
        }
    }

    package main;
    my $o = bless [], 'AUTOLOAD_TAINT';
    $o->untainted;
    $o->$TAINT;
    $o->untainted;
}

{
    # tests for tainted format in s?printf
    my $fmt = $TAINT . "# %s\n";
    violates_taint(sub { printf($fmt, "foo") }, 'printf',
		   q/printf doesn't like tainted formats/);
    violates_taint(sub { printf($TAINT . "# %s\n", "foo") }, 'printf',
		   q/printf doesn't like tainted format expressions/);
    eval { printf("# %s\n", $TAINT . "foo") };
    is($@@, '', q/printf accepts other tainted args/);
    violates_taint(sub { sprintf($fmt, "foo") }, 'sprintf',
		   q/sprintf doesn't like tainted formats/);
    violates_taint(sub { sprintf($TAINT . "# %s\n", "foo") }, 'sprintf',
		   q/sprintf doesn't like tainted format expressions/);
    eval { sprintf("# %s\n", $TAINT . "foo") };
    is($@@, '', q/sprintf accepts other tainted args/);
}

{
    # 40708
    my $n  = 7e9;
    8e9 - $n;

    my $val = $n;
    is ($val, '7000000000', 'Assignment to untainted variable');
    $val = $TAINT;
    $val = $n;
    is ($val, '7000000000', 'Assignment to tainted variable');
}

{
    my $val = 0;
    my $tainted = '1' . $TAINT;
    eval '$val = eval $tainted;';
    is ($val, 0, "eval doesn't like tainted strings");
    like ($@@, qr/^Insecure dependency in eval/);

    # Rather nice code to get a tainted undef by from Rick Delaney
    open my $fh, "test.pl" or die $!;
    seek $fh, 0, 2 or die $!;
    $tainted = <$fh>;

    eval 'eval $tainted';
    like ($@@, qr/^Insecure dependency in eval/);
}

foreach my $ord (78, 163, 256) {
    # 47195
    my $line = 'A1' . $TAINT . chr $ord;
    chop $line;
    is($line, 'A1');
    $line =~ /(A\S*)/;
    isnt_tainted($1, "\\S match with chr $ord");
}

{
  SKIP: {
      skip 'No crypt function, skipping crypt tests', 4 if(!$Config{d_crypt});
      # 59998
      sub cr {
          # On platforms implementing FIPS mode, using a weak algorithm
          # (including the default triple-DES algorithm) causes crypt(3) to
          # return a null pointer, which Perl converts into undef. We assume
          # for now that all such platforms support glibc-style selection of
          # a different hashing algorithm.
          # glibc supports MD5, but OpenBSD only supports Blowfish.
          my $alg = '';       # Use default algorithm
          if ( !defined(crypt("ab", $alg."cd")) ) {
              $alg = '$5$';   # Try SHA-256
          }
          if ( !defined(crypt("ab", $alg."cd")) ) {
              $alg = '$2b$12$FPWWO2RJ3CK4FINTw0Hi';  # Try Blowfish
          }
          if ( !defined(crypt("ab", $alg."cd")) ) {
              $alg = ''; # Nothing worked.  Back to default
          }
          my $x = crypt($_[0], $alg . $_[1]);
          $x
      }
      sub co { my $x = ~$_[0]; $x }
      my ($a, $b);
      $a = cr('hello', 'foo' . $TAINT);
      $b = cr('hello', 'foo');
      is_tainted($a,  "tainted crypt");
      isnt_tainted($b, "untainted crypt");
      $a = co('foo' . $TAINT);
      $b = co('foo');
      is_tainted($a,  "tainted complement");
      isnt_tainted($b, "untainted complement");
    }
}

{
    my @@data = qw(bonk zam zlonk qunckkk);
    # Clearly some sort of usenet bang-path
    my $string = $TAINT . join "!", @@data;

    is_tainted($string, "tainted data");

    my @@got = split /!|,/, $string;

    # each @@got would be useful here, but I want the test for earlier perls
    for my $i (0 .. $#data) {
	is_tainted($got[$i], "tainted result $i");
	is($got[$i], $data[$i], "correct content $i");
    }

    is_tainted($string, "still tainted data");

    my @@got = split /[!,]/, $string;

    # each @@got would be useful here, but I want the test for earlier perls
    for my $i (0 .. $#data) {
	is_tainted($got[$i], "tainted result $i");
	is($got[$i], $data[$i], "correct content $i");
    }

    is_tainted($string, "still tainted data");

    my @@got = split /!/, $string;

    # each @@got would be useful here, but I want the test for earlier perls
    for my $i (0 .. $#data) {
	is_tainted($got[$i], "tainted result $i");
	is($got[$i], $data[$i], "correct content $i");
    }
}

# Bug RT #52552 - broken by change at git commit id f337b08
{
    my $x = $TAINT. q{print "Hello world\n"};
    my $y = pack "a*", $x;
    is_tainted($y, "pack a* preserves tainting");

    my $z = pack "A*", q{print "Hello world\n"}.$TAINT;
    is_tainted($z, "pack A* preserves tainting");

    my $zz = pack "a*a*", q{print "Hello world\n"}, $TAINT;
    is_tainted($zz, "pack a*a* preserves tainting");
}

# Bug RT #61976 tainted $! would show numeric rather than string value

{
    my $tainted_path = substr($^X,0,0) . "/no/such/file";
    my $err;
    # $! is used in a tainted expression, so gets tainted
    open my $fh, $tainted_path or $err= "$!";
    unlike($err, qr/^\d+$/, 'tainted $!');
}

{
    # #6758: tainted values become untainted in tied hashes
    #         (also applies to other value magic such as pos)


    package P6758;

    sub TIEHASH { bless {} }
    sub TIEARRAY { bless {} }

    my $i = 0;

    sub STORE {
	main::is_tainted($_[1], "tied arg1 tainted");
	main::is_tainted($_[2], "tied arg2 tainted");
        $i++;
    }

    package main;

    my ($k,$v) = qw(1111 val);
    taint_these($k,$v);
    tie my @@array, 'P6758';
    tie my %hash , 'P6758';
    $array[$k] = $v;
    $hash{$k} = $v;
    ok $i == 2, "tied STORE called correct number of times";
}

# Bug RT #45167 the return value of sprintf sometimes wasn't tainted
# when the args were tainted. This only occurred on the first use of
# sprintf; after that, its TARG has taint magic attached, so setmagic
# at the end works.  That's why there are multiple sprintf's below, rather
# than just one wrapped in an inner loop. Also, any plaintext between
# format entries would correctly cause tainting to get set. so test with
# "%s%s" rather than eg "%s %s".

{
    for my $var1 ($TAINT, "123") {
	for my $var2 ($TAINT0, "456") {
	    is( tainted(sprintf '%s', $var1, $var2), tainted($var1),
		"sprintf '%s', '$var1', '$var2'" );
	    is( tainted(sprintf ' %s', $var1, $var2), tainted($var1),
		"sprintf ' %s', '$var1', '$var2'" );
	    is( tainted(sprintf '%s%s', $var1, $var2),
		tainted($var1) || tainted($var2),
		"sprintf '%s%s', '$var1', '$var2'" );
	}
    }
}


# Bug RT #67962: old tainted $1 gets treated as tainted
# in next untainted # match

{
    use re 'taint';
    "abc".$TAINT =~ /(.*)/; # make $1 tainted
    is_tainted($1, '$1 should be tainted');

    my $untainted = "abcdef";
    isnt_tainted($untainted, '$untainted should be untainted');
    $untainted =~ s/(abc)/$1/;
    isnt_tainted($untainted, '$untainted should still be untainted');
    $untainted =~ s/(abc)/x$1/;
    isnt_tainted($untainted, '$untainted should yet still be untainted');
}

{
    # On Windows we can't spawn a fresh Perl interpreter unless at
    # least the Windows system directory (usually C:\Windows\System32)
    # is still on the PATH.  There is however no way to determine the
    # actual path on the current system without loading the Win32
    # module, so we just restore the original $ENV{PATH} here.
    local $ENV{PATH} = $ENV{PATH};
    $ENV{PATH} = $old_env_path if $Is_MSWin32;

    fresh_perl_is(<<'end', "ok", { switches => [ '-T' ] },
    $TAINT = substr($^X, 0, 0);
    formline('@@'.('<'x("2000".$TAINT)).' | @@*', 'hallo', 'welt');
    print "ok";
end
    "formline survives a tainted dynamic picture");
}

{
    isnt_tainted($^A, "format accumulator not tainted yet");
    formline('@@ | @@*', 'hallo' . $TAINT, 'welt');
    is_tainted($^A, "tainted formline argument makes a tainted accumulator");
    $^A = "";
    isnt_tainted($^A, "accumulator can be explicitly untainted");
    formline('@@' .('<'*5) . ' | @@*', 'hallo', 'welt');
    isnt_tainted($^A, "accumulator still untainted");
    $^A = "" . $TAINT;
    is_tainted($^A, "accumulator can be explicitly tainted");
    formline('@@' .('<'*5) . ' | @@*', 'hallo', 'welt');
    is_tainted($^A, "accumulator still tainted");
    $^A = "";
    isnt_tainted($^A, "accumulator untainted again");
    formline('@@' .('<'*5) . ' | @@*', 'hallo', 'welt');
    isnt_tainted($^A, "accumulator still untainted");
    formline('@@' .('<'*(5+$TAINT0)) . ' | @@*', 'hallo', 'welt');
    is_tainted($^A, "the accumulator should be tainted already");
    is_tainted($^A, "tainted formline picture makes a tainted accumulator");
}

{   # Bug #80610
    "Constant(1)" =~ / ^ ([a-z_]\w*) (?: [(] (.*) [)] )? $ /xi;
    my $a = $1;
    my $b = $2;
    isnt_tainted($a, "regex optimization of single char /[]/i doesn't taint");
    isnt_tainted($b, "regex optimization of single char /[]/i doesn't taint");
}

{
    # RT 81230: tainted value during FETCH created extra ref to tied obj

    package P81230;
    use warnings;

    my %h;

    sub TIEHASH {
	my $x = $^X; # tainted
	bless  \$x;
    }
    sub FETCH { my $x = $_[0]; $$x . "" }

    tie %h, 'P81230';

    my $w = "";
    local $SIG{__WARN__} = sub { $w .= "@@_" };

    untie %h if $h{"k"};

    ::is($w, "", "RT 81230");
}

{
    # Compiling a subroutine inside a tainted expression does not make the
    # constant folded values tainted.
    my $x = sub { "x" . "y" };
    my $y = $ENV{PATH} . $x->(); # Compile $x inside a tainted expression
    my $z = $x->();
    isnt_tainted($z, "Constants folded value not tainted");
}

{
    # now that regexes are first class SVs, make sure that they themselves
    # as well as references to them are tainted

    my $rr = qr/(.)$TAINT/;
    my $r = $$rr; # bare REGEX
    my $s ="abc";
    ok($s =~ s/$r/x/, "match bare regex");
    is_tainted($s, "match bare regex taint");
    is($s, 'xbc', "match bare regex taint value");
}

{
    # [perl #82616] security Issues with user-defined \p{} properties
    # A using a tainted user-defined property should croak

    sub IsA { sprintf "%02x", ord("A") }

    my $prop = "IsA";
    ok("A" =~ /\p{$prop}/, "user-defined property: non-tainted case");
    $prop = "IsA$TAINT";
    eval { "A" =~ /\p{$prop}/};
    like($@@, qr/Insecure user-defined property \\p\{main::IsA}/,
	    "user-defined property: tainted case");
}

{
    # [perl #87336] lc/uc(first) failing to taint the returned string
    my $source = "foo$TAINT";
    my $dest = lc $source;
    is_tainted $dest, "lc(tainted) taints its return value";
    $dest = lcfirst $source;
    is_tainted $dest, "lcfirst(tainted) taints its return value";
    $dest = uc $source;
    is_tainted $dest, "uc(tainted) taints its return value";
    $dest = ucfirst $source;
    is_tainted $dest, "ucfirst(tainted) taints its return value";
}

{
    # Taintedness of values returned from given()
    use feature 'switch';
    no warnings 'experimental::smartmatch';

    my @@descriptions = ('when', 'given end', 'default');

    for (qw<x y z>) {
	my $letter = "$_$TAINT";

	my $desc = "tainted value returned from " . shift(@@descriptions);

	my $res = do {
	    given ($_) {
		when ('x') { $letter }
		when ('y') { goto leavegiven }
		default    { $letter }
		leavegiven:  $letter
	    }
	};
	is         $res, $letter, "$desc is correct";
	is_tainted $res,          "$desc stays tainted";
    }
}


# tainted constants and index()
#  RT 64804; http://bugs.debian.org/291450
{
    ok(tainted $old_env_path, "initial taintedness");
    BEGIN { no strict 'refs'; my $v = $old_env_path; *{"::C"} = sub () { $v }; }
    ok(tainted C, "constant is tainted properly");
    ok(!tainted "", "tainting not broken yet");
    index(undef, C);
    ok(!tainted "", "tainting still works after index() of the constant");
}

# Tainted values with smartmatch
# [perl #93590] S_do_smartmatch stealing its own string buffers
{
no warnings 'experimental::smartmatch';
ok "M$TAINT" ~~ ['m', 'M'], '$tainted ~~ ["whatever", "match"]';
ok !("M$TAINT" ~~ ['m', undef]), '$tainted ~~ ["whatever", undef]';
}

# Tainted values and ref()
for(1,2) {
  my $x = bless \"M$TAINT", ref(bless[], "main");
}
pass("no death when TARG of ref is tainted");

# $$ should not be tainted by being read in a tainted expression.
{
    isnt_tainted $$, "PID not tainted initially";
    my $x = $ENV{PATH}.$$;
    isnt_tainted $$, "PID not tainted when read in tainted expression";
}

SKIP: {
    skip 'Locales not available', 4 unless locales_enabled('LC_CTYPE');

    use feature 'fc';
    use locale;
    my ($latin1, $utf8) = ("\xDF") x 2;
    utf8::downgrade($latin1);
    utf8::upgrade($utf8);

    is_tainted fc($latin1), "under locale, lc(latin1) taints the result";
    is_tainted fc($utf8), "under locale, lc(utf8) taints the result";

    is_tainted "\F$latin1", "under locale, \\Flatin1 taints the result";
    is_tainted "\F$utf8", "under locale, \\Futf8 taints the result";
}

{ # 111654
  eval {
    eval { die "Test\n".substr($ENV{PATH}, 0, 0); };
    die;
  };
  like($@@, qr/^Test\n\t\.\.\.propagated at /, "error should be propagated");
}

# tainted run-time (?{}) should die

{
    my $code = '(?{})' . $TAINT;
    use re 'eval';
    eval { "a" =~ /$code/ };
    like($@@, qr/Eval-group in insecure regular expression/, "tainted (?{})");
}

# reset() and tainted undef (?!)
$::x = "foo";
$_ = "$TAINT".reset "x";
is eval { eval $::x.1 }, 1, 'reset does not taint undef';

# [perl #122669]
{
    # See the comment above the first formline test.
    local $ENV{PATH} = $ENV{PATH};
    $ENV{PATH} = $old_env_path if $Is_MSWin32;
    is runperl(
       switches => [ '-T' ],
       prog => 'use constant K=>$^X; 0 if K; BEGIN{} use strict; '
              .'print 122669, qq-\n-',
       stderr => 1,
     ), "122669\n",
        'tainted constant as logop condition should not prevent "use"';
}

# optimised SETi etc need to handle tainting

{
    my ($i1, $i2, $i3) = (1, 1, 1);
    my ($n1, $n2, $n3) = (1.1, 1.1, 1.1);
    my $tn = $TAINT0 + 1.1;

    $i1 = $TAINT0 + 2;
    is_tainted $i1, "+ SETi";
    $i2 = $TAINT0 - 2;
    is_tainted $i2, "- SETi";
    $i3 = $TAINT0 * 2;
    is_tainted $i3, "* SETi";

    $n1 = $tn + 2.2;
    is_tainted $n1, "+ SETn";
    $n2 = $tn - 2.2;
    is_tainted $n2, "- SETn";
    $n3 = $tn * 2.2;
    is_tainted $n3, "* SETn";
}

# check that localizing something with get magic (e.g. taint) doesn't
# upgrade pIOK to IOK

{
    local our $x = 1.1 + $TAINT0;  # $x should be NOK
    my $ix = int($x);          #          now NOK, pIOK
    {
        local $x = 0;
    }
    my $x1 = $x * 1;
    isnt($x, 1); # it should be 1.1, not 1
}


# This may bomb out with the alarm signal so keep it last
SKIP: {
    skip "No alarm()"  unless $Config{d_alarm};
    # Test from RT #41831]
    # [PATCH] Bug & fix: hang when using study + taint mode (perl 5.6.1, 5.8.x)

    my $DATA = <<'END' . $TAINT;
line1 is here
line2 is here
line3 is here
line4 is here

END

    #study $DATA;

    ## don't set $SIG{ALRM}, since we'd never get to a user-level handler as
    ## perl is stuck in a regexp infinite loop!

    alarm(10);

    if ($DATA =~ /^line2.*line4/m) {
	fail("Should not be a match")
    } else {
	pass("Match on tainted multiline data should fail promptly");
    }

    alarm(0);
}
__END__
# Keep the previous test last
@


1.21
log
@Update to perl 5.20.3

OK bluhm@@
@
text
@a11 1
    @@INC = '../lib';
d13 2
a14 1
    skip_all_if_miniperl("no dynamic loading on miniperl, no re");
d20 1
a20 1
plan tests => 817;
a300 6
    SKIP: {
    if (
        !$Config::Config{d_setlocale}
    || $Config::Config{ccflags} =~ /\bD?NO_LOCALE(_|\b)/
    ) {
        skip "no locale support", 10 }
d302 1
a302 1
        skip 'No locale testing without d_setlocale', 10 if(!$Config{d_setlocale});
d308 1
a308 5
            BEGIN {
                if($Config{d_setlocale}) {
                    require locale; import locale;
                }
            }
a315 1
    }
d321 1
a321 5
            BEGIN {
                if($Config{d_setlocale}) {
                    require locale; import locale;
                }
            }
a335 7
    SKIP: {
    if (
        !$Config::Config{d_setlocale}
    || $Config::Config{ccflags} =~ /\bD?NO_LOCALE(_|\b)/
    ) {
        skip "no locale support", 12
    }
a352 1
    }
d355 1
a355 1
        skip 'No locale testing without d_setlocale', 12 if(!$Config{d_setlocale}) || $Config::Config{ccflags} =~ /\bD?NO_LOCALE(_|\b)/;
d361 1
a361 5
            BEGIN {
                if($Config{d_setlocale}) {
                    require locale; import locale;
                }
            }
d374 1
a374 5
            BEGIN {
                if($Config{d_setlocale}) {
                    require locale; import locale;
                }
            }
a465 7
    SKIP: {
    if (
        !$Config::Config{d_setlocale}
    || $Config::Config{ccflags} =~ /\bD?NO_LOCALE(_|\b)/
    ) {
        skip "no locale support", 18
    }
a504 1
    }
d507 1
a507 1
        skip 'No locale testing without d_setlocale', 18 if(!$Config{d_setlocale} || $Config::Config{ccflags} =~ /\bD?NO_LOCALE(_|\b)/);
d513 1
a513 5
            BEGIN {
                if($Config{d_setlocale}) {
                    require locale; import locale;
                }
            }
d527 1
a527 5
            BEGIN {
                if($Config{d_setlocale}) {
                    require locale; import locale;
                }
            }
d541 1
a541 5
            BEGIN {
                if($Config{d_setlocale}) {
                    require locale; import locale;
                }
            }
a635 7
    SKIP: {
    if (
        !$Config::Config{d_setlocale}
    || $Config::Config{ccflags} =~ /\bD?NO_LOCALE(_|\b)/
    ) {
        skip "no locale support", 10
    }
a642 1
    }
a659 7
    SKIP: {
    if (
        !$Config::Config{d_setlocale}
    || $Config::Config{ccflags} =~ /\bD?NO_LOCALE(_|\b)/
    ) {
        skip "no locale support", 12
    }
a666 1
    }
d691 1
a691 1
        skip 'No locale testing without d_setlocale', 10 if(!$Config{d_setlocale} || $Config::Config{ccflags} =~ /\bD?NO_LOCALE(_|\b)/);
d697 1
a697 5
            BEGIN {
                if($Config{d_setlocale}) {
                    require locale; import locale;
                }
            }
d710 1
a710 5
            BEGIN {
                if($Config{d_setlocale}) {
                    require locale; import locale;
                }
            }
d744 1
a744 1
        skip 'No locale testing without d_setlocale', 12 if(!$Config{d_setlocale} || $Config::Config{ccflags} =~ /\bD?NO_LOCALE(_|\b)/);
d750 1
a750 5
            BEGIN {
                if($Config{d_setlocale}) {
                    require locale; import locale;
                }
            }
d763 1
a763 5
            BEGIN {
                if($Config{d_setlocale}) {
                    require locale; import locale;
                }
            }
a784 7
    SKIP: {
    if (
        !$Config::Config{d_setlocale}
    || $Config::Config{ccflags} =~ /\bD?NO_LOCALE(_|\b)/
    ) {
        skip "no locale support", 18
    }
a809 1
    }
d897 2
a898 1
        skip 'No locale testing without d_setlocale', 18 if(!$Config{d_setlocale} || $Config::Config{ccflags} =~ /\bD?NO_LOCALE(_|\b)/);
d903 1
a903 5
            BEGIN {
                if($Config{d_setlocale}) {
                    require locale; import locale;
                }
            }
d917 1
a917 5
            BEGIN {
                if($Config{d_setlocale}) {
                    require locale; import locale;
                }
            }
d931 1
a931 5
            BEGIN {
                if($Config{d_setlocale}) {
                    require locale; import locale;
                }
            }
d1516 1
a1516 1
        skip "no Fcntl", 18 unless $has_fcntl;
d1971 20
a1990 2
      my $alg = '$2b$12$12345678901234567890';   # Use Blowfish
      sub cr { my $x = crypt($_[0], $alg . $_[1]); $x }
d2093 1
a2093 1
# when the args were tainted. This only occured on the first use of
d2097 1
a2097 1
# fprmat entires would correctly cause tainting to get set. so test with
d2177 1
a2177 7
SKIP: {
    if (
        !$Config::Config{d_setlocale}
    || $Config::Config{ccflags} =~ /\bD?NO_LOCALE(_|\b)/
    ) {
        skip "no locale support", 4
    }
d2308 1
a2308 1
    skip 'No locale testing without d_setlocale', 4 if(!$Config{d_setlocale} || $Config::Config{ccflags} =~ /\bD?NO_LOCALE(_|\b)/);
d2311 1
a2311 5
    BEGIN {
        if($Config{d_setlocale}) {
            require locale; import locale;
        }
    }
d2358 36
@


1.20
log
@Apply local patches, remove excess files - perl-5.20.2
@
text
@d2073 2
a2074 1
      sub cr { my $x = crypt($_[0], $_[1]); $x }
@


1.19
log
@Fix merge issues, remove excess files - match perl-5.20.2 dist
@
text
@d20 1
a20 1
plan tests => 801;
d301 6
d326 1
d351 7
d375 1
d378 1
a378 1
        skip 'No locale testing without d_setlocale', 12 if(!$Config{d_setlocale});
d497 7
d543 1
d546 1
a546 1
        skip 'No locale testing without d_setlocale', 18 if(!$Config{d_setlocale});
d687 7
d701 1
d719 7
d733 1
d758 1
a758 1
        skip 'No locale testing without d_setlocale', 10 if(!$Config{d_setlocale});
d819 1
a819 1
        skip 'No locale testing without d_setlocale', 12 if(!$Config{d_setlocale});
d868 7
d900 1
d988 1
a988 2
        skip 'No locale testing without d_setlocale', 18 if(!$Config{d_setlocale});

d2260 7
a2266 1
{
d2397 1
a2397 1
    skip 'No locale testing without d_setlocale', 4 if(!$Config{d_setlocale});
@


1.18
log
@Apply local patches to perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d20 1
a20 1
plan tests => 816;
a300 6
    SKIP: {
    if (
        !$Config::Config{d_setlocale}
    || $Config::Config{ccflags} =~ /\bD?NO_LOCALE(_|\b)/
    ) {
        skip "no locale support", 10 }
a319 1
    }
a343 7
    SKIP: {
    if (
        !$Config::Config{d_setlocale}
    || $Config::Config{ccflags} =~ /\bD?NO_LOCALE(_|\b)/
    ) {
        skip "no locale support", 12
    }
a360 1
    }
d363 1
a363 1
        skip 'No locale testing without d_setlocale', 12 if(!$Config{d_setlocale}) || $Config::Config{ccflags} =~ /\bD?NO_LOCALE(_|\b)/;
a481 7
    SKIP: {
    if (
        !$Config::Config{d_setlocale}
    || $Config::Config{ccflags} =~ /\bD?NO_LOCALE(_|\b)/
    ) {
        skip "no locale support", 18
    }
a520 1
    }
d523 1
a523 1
        skip 'No locale testing without d_setlocale', 18 if(!$Config{d_setlocale} || $Config::Config{ccflags} =~ /\bD?NO_LOCALE(_|\b)/);
a663 7
    SKIP: {
    if (
        !$Config::Config{d_setlocale}
    || $Config::Config{ccflags} =~ /\bD?NO_LOCALE(_|\b)/
    ) {
        skip "no locale support", 10
    }
a670 1
    }
a687 7
    SKIP: {
    if (
        !$Config::Config{d_setlocale}
    || $Config::Config{ccflags} =~ /\bD?NO_LOCALE(_|\b)/
    ) {
        skip "no locale support", 12
    }
a694 1
    }
d719 1
a719 1
        skip 'No locale testing without d_setlocale', 10 if(!$Config{d_setlocale} || $Config::Config{ccflags} =~ /\bD?NO_LOCALE(_|\b)/);
d780 1
a780 1
        skip 'No locale testing without d_setlocale', 12 if(!$Config{d_setlocale} || $Config::Config{ccflags} =~ /\bD?NO_LOCALE(_|\b)/);
a828 7
    SKIP: {
    if (
        !$Config::Config{d_setlocale}
    || $Config::Config{ccflags} =~ /\bD?NO_LOCALE(_|\b)/
    ) {
        skip "no locale support", 18
    }
a853 1
    }
d941 2
a942 1
        skip 'No locale testing without d_setlocale', 18 if(!$Config{d_setlocale} || $Config::Config{ccflags} =~ /\bD?NO_LOCALE(_|\b)/);
d2214 1
a2214 7
SKIP: {
    if (
        !$Config::Config{d_setlocale}
    || $Config::Config{ccflags} =~ /\bD?NO_LOCALE(_|\b)/
    ) {
        skip "no locale support", 4
    }
d2345 1
a2345 1
    skip 'No locale testing without d_setlocale', 4 if(!$Config{d_setlocale} || $Config::Config{ccflags} =~ /\bD?NO_LOCALE(_|\b)/);
d2385 14
@


1.17
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d20 1
a20 1
plan tests => 800;
d301 6
d326 1
d351 7
d375 1
d378 1
a378 1
        skip 'No locale testing without d_setlocale', 12 if(!$Config{d_setlocale});
d497 7
d543 1
d546 1
a546 1
        skip 'No locale testing without d_setlocale', 18 if(!$Config{d_setlocale});
d687 7
d701 1
d719 7
d733 1
d758 1
a758 1
        skip 'No locale testing without d_setlocale', 10 if(!$Config{d_setlocale});
d819 1
a819 1
        skip 'No locale testing without d_setlocale', 12 if(!$Config{d_setlocale});
d868 7
d900 1
d988 1
a988 2
        skip 'No locale testing without d_setlocale', 18 if(!$Config{d_setlocale});

d2260 7
a2266 1
{
d2397 1
a2397 1
    skip 'No locale testing without d_setlocale', 4 if(!$Config{d_setlocale});
@


1.16
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d20 1
a20 1
plan tests => 813;
d185 3
a187 1
	like($@@, qr/^Insecure directory in \$ENV\{PATH}/);
a300 6
    SKIP: {
    if (
        !$Config::Config{d_setlocale}
    || $Config::Config{ccflags} =~ /\bD?NO_LOCALE(_|\b)/
    ) {
        skip "no locale support", 10 }
a319 1
    }
a343 7
    SKIP: {
    if (
        !$Config::Config{d_setlocale}
    || $Config::Config{ccflags} =~ /\bD?NO_LOCALE(_|\b)/
    ) {
        skip "no locale support", 12
    }
a360 1
    }
d363 1
a363 1
        skip 'No locale testing without d_setlocale', 12 if(!$Config{d_setlocale}) || $Config::Config{ccflags} =~ /\bD?NO_LOCALE(_|\b)/;
a481 7
    SKIP: {
    if (
        !$Config::Config{d_setlocale}
    || $Config::Config{ccflags} =~ /\bD?NO_LOCALE(_|\b)/
    ) {
        skip "no locale support", 18
    }
a520 1
    }
d523 1
a523 1
        skip 'No locale testing without d_setlocale', 18 if(!$Config{d_setlocale} || $Config::Config{ccflags} =~ /\bD?NO_LOCALE(_|\b)/);
a663 7
    SKIP: {
    if (
        !$Config::Config{d_setlocale}
    || $Config::Config{ccflags} =~ /\bD?NO_LOCALE(_|\b)/
    ) {
        skip "no locale support", 10
    }
a670 1
    }
a687 7
    SKIP: {
    if (
        !$Config::Config{d_setlocale}
    || $Config::Config{ccflags} =~ /\bD?NO_LOCALE(_|\b)/
    ) {
        skip "no locale support", 12
    }
a694 1
    }
d719 1
a719 1
        skip 'No locale testing without d_setlocale', 10 if(!$Config{d_setlocale} || $Config::Config{ccflags} =~ /\bD?NO_LOCALE(_|\b)/);
d780 1
a780 1
        skip 'No locale testing without d_setlocale', 12 if(!$Config{d_setlocale} || $Config::Config{ccflags} =~ /\bD?NO_LOCALE(_|\b)/);
a828 7
    SKIP: {
    if (
        !$Config::Config{d_setlocale}
    || $Config::Config{ccflags} =~ /\bD?NO_LOCALE(_|\b)/
    ) {
        skip "no locale support", 18
    }
a853 1
    }
d941 2
a942 1
        skip 'No locale testing without d_setlocale', 18 if(!$Config{d_setlocale} || $Config::Config{ccflags} =~ /\bD?NO_LOCALE(_|\b)/);
d1062 12
d1450 6
a1455 1
        my $id = shmget(IPC_PRIVATE, $size, S_IRWXU);
d1475 1
a1475 1
        is_tainted($rcvd);
d1484 6
a1489 1
	my $id = msgget(IPC_PRIVATE, IPC_CREAT | S_IRWXU);
d1515 1
a1515 1
	    is_tainted($rcvd);
d2024 15
a2038 12
    # 59998
    sub cr { my $x = crypt($_[0], $_[1]); $x }
    sub co { my $x = ~$_[0]; $x }
    my ($a, $b);
    $a = cr('hello', 'foo' . $TAINT);
    $b = cr('hello', 'foo');
    is_tainted($a,  "tainted crypt");
    isnt_tainted($b, "untainted crypt");
    $a = co('foo' . $TAINT);
    $b = co('foo');
    is_tainted($a,  "tainted complement");
    isnt_tainted($b, "untainted complement");
d2214 1
a2214 7
SKIP: {
    if (
        !$Config::Config{d_setlocale}
    || $Config::Config{ccflags} =~ /\bD?NO_LOCALE(_|\b)/
    ) {
        skip "no locale support", 4
    }
d2345 1
a2345 1
    skip 'No locale testing without d_setlocale', 4 if(!$Config{d_setlocale} || $Config::Config{ccflags} =~ /\bD?NO_LOCALE(_|\b)/);
d2380 5
@


1.15
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d20 1
a20 1
plan tests => 794;
d155 1
a155 1
	    last unless $@@ =~ /^Insecure \$ENV{$v}/;
d166 1
a166 1
	like($@@, qr/^Insecure \$ENV{TERM}/);
d185 1
a185 1
	like($@@, qr/^Insecure directory in \$ENV{PATH}/);
d193 1
a193 1
	like($@@, qr/^Insecure \$ENV{DCL\$PATH}/);
d200 1
a200 1
	    like($@@, qr/^Insecure directory in \$ENV{DCL\$PATH}/);
d304 20
a323 1
        skip "no locale support", 10
a324 1
    $desc = "match with pattern tainted via locale";
d326 16
a341 17
    $s = 'abcd';
    { use locale; $res = $s =~ /(\w+)/; $one = $1; }
    isnt_tainted($s,   "$desc: s not tainted");
    isnt_tainted($res, "$desc: res not tainted");
    is_tainted($one,   "$desc: \$1 tainted");
    is($res, 1,        "$desc: res value");
    is($one, 'abcd',   "$desc: \$1 value");

    $desc = "match /g with pattern tainted via locale";

    $s = 'abcd';
    { use locale; $res = $s =~ /(\w)/g; $one = $1; }
    isnt_tainted($s,   "$desc: s not tainted");
    isnt_tainted($res, "$desc: res not tainted");
    is_tainted($one,   "$desc: \$1 tainted");
    is($res, 1,        "$desc: res value");
    is($one, 'a',      "$desc: \$1 value");
d349 7
a372 7

    SKIP: {
    if (
        !$Config::Config{d_setlocale}
    || $Config::Config{ccflags} =~ /\bD?NO_LOCALE(_|\b)/
    ) {
        skip "no locale support", 12
a373 1
    $desc = "match with pattern tainted via locale, list cxt";
d375 2
a376 7
    $s = 'abcd';
    { use locale; ($res) = $s =~ /(\w+)/; $one = $1; }
    isnt_tainted($s,   "$desc: s not tainted");
    is_tainted($res,   "$desc: res tainted");
    is_tainted($one,   "$desc: \$1 tainted");
    is($res, 'abcd',   "$desc: res value");
    is($one, 'abcd',   "$desc: \$1 value");
d378 1
a378 1
    $desc = "match /g with pattern tainted via locale, list cxt";
d380 33
a412 9
    $s = 'abcd';
    { use locale; ($res, $res2) = $s =~ /(\w)/g; $one = $1; }
    isnt_tainted($s,   "$desc: s not tainted");
    is_tainted($res,   "$desc: res tainted");
    is_tainted($res2,  "$desc: res2 tainted");
    is_tainted($one,   "$desc: \$1 tainted");
    is($res, 'a',      "$desc: res value");
    is($res2,'b',      "$desc: res2 value");
    is($one, 'd',      "$desc: \$1 value");
d495 7
a540 7

    SKIP: {
    if (
        !$Config::Config{d_setlocale}
    || $Config::Config{ccflags} =~ /\bD?NO_LOCALE(_|\b)/
    ) {
        skip "no locale support", 18
a541 1
    $desc = "substitution with pattern tainted via locale";
d543 2
a544 8
    $s = 'abcd';
    { use locale;  $res = $s =~ s/(\w+)/xyz/; $one = $1; }
    is_tainted($s,     "$desc: s tainted");
    isnt_tainted($res, "$desc: res not tainted");
    is_tainted($one,   "$desc: \$1 tainted");
    is($s,  'xyz',     "$desc: s value");
    is($res, 1,        "$desc: res value");
    is($one, 'abcd',   "$desc: \$1 value");
d546 1
a546 1
    $desc = "substitution /g with pattern tainted via locale";
d548 51
a598 19
    $s = 'abcd';
    { use locale;  $res = $s =~ s/(\w)/x/g; $one = $1; }
    is_tainted($s,     "$desc: s tainted");
    is_tainted($res,   "$desc: res tainted");
    is_tainted($one,   "$desc: \$1 tainted");
    is($s,  'xxxx',    "$desc: s value");
    is($res, 4,        "$desc: res value");
    is($one, 'd',      "$desc: \$1 value");

    $desc = "substitution /r with pattern tainted via locale";

    $s = 'abcd';
    { use locale;  $res = $s =~ s/(\w+)/xyz/r; $one = $1; }
    isnt_tainted($s,   "$desc: s not tainted");
    is_tainted($res,   "$desc: res tainted");
    is_tainted($one,   "$desc: \$1 tainted");
    is($s,  'abcd',    "$desc: s value");
    is($res, 'xyz',    "$desc: res value");
    is($one, 'abcd',   "$desc: \$1 value");
d648 1
a648 1
    is_tainted($res,   "$desc: res tainted");
d685 7
d699 1
d717 7
d731 1
d755 2
a756 8
    SKIP: {
    if (
        !$Config::Config{d_setlocale}
    || $Config::Config{ccflags} =~ /\bD?NO_LOCALE(_|\b)/
    ) {
        skip "no locale support", 10
    }
	$desc = "use re 'taint': match with pattern tainted via locale";
d758 1
a758 7
	$s = 'abcd';
	{ use locale; $res = $s =~ /(\w+)/; $one = $1; }
	isnt_tainted($s,   "$desc: s not tainted");
	isnt_tainted($res, "$desc: res not tainted");
	is_tainted($one,   "$desc: \$1 tainted");
	is($res, 1,        "$desc: res value");
	is($one, 'abcd',   "$desc: \$1 value");
d760 31
a790 9
	$desc = "use re 'taint': match /g with pattern tainted via locale";

	$s = 'abcd';
	{ use locale; $res = $s =~ /(\w)/g; $one = $1; }
	isnt_tainted($s,   "$desc: s not tainted");
	isnt_tainted($res, "$desc: res not tainted");
	is_tainted($one,   "$desc: \$1 tainted");
	is($res, 1,        "$desc: res value");
	is($one, 'a',      "$desc: \$1 value");
d816 2
a817 8
    SKIP: {
    if (
        !$Config::Config{d_setlocale}
    || $Config::Config{ccflags} =~ /\bD?NO_LOCALE(_|\b)/
    ) {
        skip "no locale support", 12
    }
	$desc = "use re 'taint': match with pattern tainted via locale, list cxt";
d819 1
a819 7
	$s = 'abcd';
	{ use locale; ($res) = $s =~ /(\w+)/; $one = $1; }
	isnt_tainted($s,   "$desc: s not tainted");
	is_tainted($res,   "$desc: res tainted");
	is_tainted($one,   "$desc: \$1 tainted");
	is($res, 'abcd',   "$desc: res value");
	is($one, 'abcd',   "$desc: \$1 value");
d821 33
a853 11
	$desc = "use re 'taint': match /g with pattern tainted via locale, list cxt";

	$s = 'abcd';
	{ use locale; ($res, $res2) = $s =~ /(\w)/g; $one = $1; }
	isnt_tainted($s,   "$desc: s not tainted");
	is_tainted($res,   "$desc: res tainted");
	is_tainted($res2,  "$desc: res2 tainted");
	is_tainted($one,   "$desc: \$1 tainted");
	is($res, 'a',      "$desc: res value");
	is($res2,'b',      "$desc: res2 value");
	is($one, 'd',      "$desc: \$1 value");
d866 7
d898 1
d985 55
a1039 39
    SKIP: {
    if (
        !$Config::Config{d_setlocale}
    || $Config::Config{ccflags} =~ /\bD?NO_LOCALE(_|\b)/
    ) {
        skip "no locale support", 18
    }
	$desc = "use re 'taint': substitution with pattern tainted via locale";

	$s = 'abcd';
	{ use locale;  $res = $s =~ s/(\w+)/xyz/; $one = $1; }
	is_tainted($s,     "$desc: s tainted");
	isnt_tainted($res, "$desc: res not tainted");
	is_tainted($one,   "$desc: \$1 tainted");
	is($s,  'xyz',     "$desc: s value");
	is($res, 1,        "$desc: res value");
	is($one, 'abcd',   "$desc: \$1 value");

	$desc = "use re 'taint': substitution /g with pattern tainted via locale";

	$s = 'abcd';
	{ use locale;  $res = $s =~ s/(\w)/x/g; $one = $1; }
	is_tainted($s,     "$desc: s tainted");
	is_tainted($res,   "$desc: res tainted");
	is_tainted($one,   "$desc: \$1 tainted");
	is($s,  'xxxx',    "$desc: s value");
	is($res, 4,        "$desc: res value");
	is($one, 'd',      "$desc: \$1 value");

	$desc = "use re 'taint': substitution /r with pattern tainted via locale";

	$s = 'abcd';
	{ use locale;  $res = $s =~ s/(\w+)/xyz/r; $one = $1; }
	isnt_tainted($s,   "$desc: s not tainted");
	is_tainted($res,   "$desc: res tainted");
	is_tainted($one,   "$desc: \$1 tainted");
	is($s,  'abcd',    "$desc: s value");
	is($res, 'xyz',    "$desc: res value");
	is($one, 'abcd',   "$desc: \$1 value");
d1089 1
a1089 1
	is_tainted($res,   "$desc: res tainted");
d1801 8
d2221 1
a2221 4
    TODO: {
        local $::TODO = "get magic handled too late?";
        is_tainted($^A, "the accumulator should be tainted already");
    }
d2233 7
a2239 1
{
d2294 1
a2294 1
    like($@@, qr/Insecure user-defined property \\p{main::IsA}/,
d2314 1
d2350 2
d2354 1
d2370 7
a2376 5
    if (
        !$Config::Config{d_setlocale}
    || $Config::Config{ccflags} =~ /\bD?NO_LOCALE(_|\b)/
    ) {
        skip "no locale support", 4
a2377 2
    use feature 'fc';
    use locale;
d2395 9
@


1.14
log
@Perl security fix for CVE-2011-1487:
ucfirst(), uc() and lc() forget to set the tainted flag if input
was marked as tainted.

http://rt.perl.org/rt3/Public/Bug/Display.html?id=87336
http://perl5.git.perl.org/perl.git/commitdiff/539689e74a3bcb04d29e4cd9396de91a81045b99

ok millert@@
@
text
@d13 2
a18 1
use File::Spec::Functions;
d20 1
a20 2
BEGIN { require './test.pl'; }
plan tests => 306;
d51 1
d100 2
a101 1
sub any_tainted (@@) {
a103 26
sub tainted ($) {
    any_tainted @@_;
}
sub all_tainted (@@) {
    for (@@_) { return 0 unless tainted $_ }
    1;
}


sub test ($;$) {
    my($ok, $diag) = @@_;

    my $curr_test = curr_test();

    if ($ok) {
	print "ok $curr_test\n";
    } else {
	print "not ok $curr_test\n";
        printf "# Failed test at line %d\n", (caller)[2];
	for (split m/^/m, $diag) {
	    print "# $_";
	}
	print "\n" unless
	    $diag eq ''
	    or substr($diag, -1) eq "\n";
    }
d105 18
a122 3
    next_test();

    return $ok;
d128 3
a130 3
open PROG, "> $ECHO" or die "Can't create $ECHO: $!";
print PROG 'print "@@ARGV\n"', "\n";
close PROG;
d133 1
a133 1
my $TEST = catfile(curdir(), 'TEST');
a140 16
    if ($Is_MSWin32 && $Config{ccname} =~ /bcc32/ && ! -f 'cc3250mt.dll') {
	my $bcc_dir;
	foreach my $dir (split /$Config{path_sep}/, $ENV{PATH}) {
	    if (-f "$dir/cc3250mt.dll") {
		$bcc_dir = $dir and last;
	    }
	}
	if (defined $bcc_dir) {
	    require File::Copy;
	    File::Copy::copy("$bcc_dir/cc3250mt.dll", '.') or
		die "$0: failed to copy cc3250mt.dll: $!\n";
	    eval q{
		END { unlink "cc3250mt.dll" }
	    };
	}
    }
d145 1
a145 1
    test eval { `$echo 1` } eq "1\n";
d158 1
a158 1
	test !@@vars, "@@vars";
d163 1
a163 1
	test eval { `$echo 1` } eq "1\n";
d165 2
a166 2
	test !eval { `$echo 1` };
	test $@@ =~ /^Insecure \$ENV{TERM}/, $@@;
d184 2
a185 2
	test !eval { `$echo 1` };
	test $@@ =~ /^Insecure directory in \$ENV{PATH}/, $@@;
d192 2
a193 2
	test  eval { `$echo 1` } eq '';
	test $@@ =~ /^Insecure \$ENV{DCL\$PATH}/, $@@;
d199 2
a200 2
	    test eval { `$echo 1` } eq '';
	    test $@@ =~ /^Insecure directory in \$ENV{DCL\$PATH}/, $@@;
d209 1
a209 1
    test tainted $foo;
d215 1
a215 1
    test not tainted $foo;
d218 1
a218 1
    test tainted $foo;
d221 1
a221 1
    test not any_tainted @@list;
d223 2
a224 3
    test any_tainted @@list;
    test all_tainted @@list[1,3,5,7,9];
    test not any_tainted @@list[0,2,4,6,8];
d227 3
a229 1
    test not tainted $foo;
d231 374
a604 3
    $foo = $1 if ('bar' . $TAINT) =~ /(.+)/;
    test not tainted $foo;
    test $foo eq 'bar';
d607 71
a677 1
      use re 'taint';
d679 307
a985 7
      ($foo) = ('bar' . $TAINT) =~ /(.+)/;
      test tainted $foo;
      test $foo eq 'bar';

      $foo = $1 if ('bar' . $TAINT) =~ /(.+)/;
      test tainted $foo;
      test $foo eq 'bar';
d989 2
a990 2
    test tainted $foo;
    test $foo eq 'bar';
d993 1
a993 1
    test tainted $pi;
d996 2
a997 2
    test not tainted $pi;
    test sprintf("%.5f", $pi) eq '3.14159';
d1004 2
a1005 2
    open PROG, "> $arg" or die "Can't create $arg: $!";
    print PROG q{
d1011 1
a1011 1
    close PROG;
d1013 1
a1013 1
    test !$?, "Exited with status $?";
d1019 1
a1019 1
    test open(FILE, $TEST), "Couldn't open '$TEST': $!";
d1022 5
a1026 17
    sysread(FILE, $block, 100);
    my $line = <FILE>;
    close FILE;
    test tainted $block;
    test tainted $line;
}

# Globs should be forbidden, except under VMS,
#   which doesn't spawn an external program.
SKIP: {
    skip "globs should be forbidden", 2 if 1 or $Is_VMS;

    my @@globs = eval { <*> };
    test @@globs == 0 && $@@ =~ /^Insecure dependency/;

    @@globs = eval { glob '*' };
    test @@globs == 0 && $@@ =~ /^Insecure dependency/;
d1032 1
a1032 1
    test tainted $foo;
d1037 2
a1038 1
    test all_tainted $^X, $0;
d1044 1
a1044 1
    test tainted $foo;
d1047 3
a1049 1
    test not any_tainted $`, $&, $';
d1052 4
a1055 1
    test not any_tainted $1, $2, $3, $+;
d1058 1
a1058 1
    test not any_tainted @@bar;
d1060 2
a1061 2
    test tainted $foo;	# $foo should still be tainted!
    test $foo eq "abcdefghi";
d1066 1
a1066 2
    test !eval { chmod 0, $TAINT }, 'chmod';
    test $@@ =~ /^Insecure dependency/, $@@;
d1068 2
a1069 4
    # There is no feature test in $Config{} for truncate,
    #   so we allow for the possibility that it's missing.
    test !eval { truncate 'NoSuChFiLe', $TAINT0 }, 'truncate';
    test $@@ =~ /^(?:Insecure dependency|truncate not implemented)/, $@@;
d1071 2
a1072 2
    test !eval { rename '', $TAINT }, 'rename';
    test $@@ =~ /^Insecure dependency/, $@@;
d1074 3
a1076 5
    test !eval { unlink $TAINT }, 'unlink';
    test $@@ =~ /^Insecure dependency/, $@@;

    test !eval { utime $TAINT }, 'utime';
    test $@@ =~ /^Insecure dependency/, $@@;
d1081 1
a1081 2
	test !eval { chown -1, -1, $TAINT }, 'chown';
	test $@@ =~ /^Insecure dependency/, $@@;
d1087 1
a1087 2
	test !eval { link $TAINT, '' }, 'link';
	test $@@ =~ /^Insecure dependency/, $@@;
d1093 1
a1093 2
	test !eval { symlink $TAINT, '' }, 'symlink';
	test $@@ =~ /^Insecure dependency/, $@@;
d1099 3
a1101 8
    test !eval { mkdir "foo".$TAINT, 0755.$TAINT0 }, 'mkdir';
    test $@@ =~ /^Insecure dependency/, $@@;

    test !eval { rmdir $TAINT }, 'rmdir';
    test $@@ =~ /^Insecure dependency/, $@@;

    test !eval { chdir "foo".$TAINT }, 'chdir';
    test $@@ =~ /^Insecure dependency/, $@@;
d1106 1
a1106 2
	test !eval { chroot $TAINT }, 'chroot';
	test $@@ =~ /^Insecure dependency/, $@@;
d1113 1
a1113 2
    test !eval { require $foo }, 'require';
    test $@@ =~ /^Insecure dependency/, $@@;
d1119 4
a1122 2
    test !eval { open FOO, $foo }, 'open for read';
    test $@@ eq '', $@@;		# NB: This should be allowed
d1127 1
a1127 1
    test eval('$!{ENOENT}') ||
d1129 1
a1129 1
	($Is_Dos && $! == 22);
d1131 2
a1132 2
    test !eval { open FOO, "> $foo" }, 'open for write';
    test $@@ =~ /^Insecure dependency/, $@@;
d1140 1
a1140 4
        skip "open('|') is not available", 4 if $^O eq 'amigaos';

	test !eval { open FOO, "| x$foo" }, 'popen to';
	test $@@ =~ /^Insecure dependency/, $@@;
d1142 4
a1145 2
	test !eval { open FOO, "x$foo |" }, 'popen from';
	test $@@ =~ /^Insecure dependency/, $@@;
d1148 2
a1149 5
    test !eval { exec $TAINT }, 'exec';
    test $@@ =~ /^Insecure dependency/, $@@;

    test !eval { system $TAINT }, 'system';
    test $@@ =~ /^Insecure dependency/, $@@;
d1154 1
a1154 2
    test !eval { `$echo 1$foo` }, 'backticks';
    test $@@ =~ /^Insecure dependency/, $@@;
d1160 2
a1161 2
	test join('', eval { glob $foo } ) ne '', 'globbing';
	test $@@ eq '', $@@;
d1167 1
a1167 2
    test !eval { kill 0, $TAINT }, 'kill';
    test $@@ =~ /^Insecure dependency/, $@@;
d1172 1
a1172 2
	test !eval { setpgrp 0, $TAINT0 }, 'setpgrp';
	test $@@ =~ /^Insecure dependency/, $@@;
d1178 1
a1178 2
	test !eval { setpriority 0, $TAINT0, $TAINT0 }, 'setpriority';
	test $@@ =~ /^Insecure dependency/, $@@;
d1187 1
a1187 2
	test !eval { syscall $TAINT }, 'syscall';
	test $@@ =~ /^Insecure dependency/, $@@;
d1195 2
a1196 1
	test open(FOO, "> $temp"), "Couldn't open $temp for write: $!";
d1198 3
a1200 2
	test !eval { ioctl FOO, $TAINT0, $foo }, 'ioctl';
	test $@@ =~ /^Insecure dependency/, $@@;
d1203 1
a1203 1
            skip "fcntl() is not available", 2 unless $Config{d_fcntl};
d1205 2
a1206 2
	    test !eval { fcntl FOO, $TAINT0, $foo }, 'fcntl';
	    test $@@ =~ /^Insecure dependency/, $@@;
d1217 3
a1219 3
    test not tainted $fooref;
    test tainted $$fooref;
    test tainted $foo;
d1226 15
a1240 14
    test all_tainted $foo, $bar;
    test tainted($foo = $bar);
    test tainted($bar = $bar);
    test tainted($bar += $bar);
    test tainted($bar -= $bar);
    test tainted($bar *= $bar);
    test tainted($bar++);
    test tainted($bar /= $bar);
    test tainted($bar += 0);
    test tainted($bar -= 2);
    test tainted($bar *= -1);
    test tainted($bar /= 1);
    test tainted($bar--);
    test $bar == 0;
d1246 3
a1248 3
    test not tainted $foo[0];
    test     tainted $foo[1];
    test not tainted $foo[2];
d1250 3
a1252 3
    test not tainted $bar[0];
    test     tainted $bar[1];
    test not tainted $bar[2];
d1254 3
a1256 3
    test not tainted $baz[0];
    test     tainted $baz[1];
    test not tainted $baz[2];
d1258 3
a1260 3
    test not tainted $plugh[0];
    test     tainted $plugh[1];
    test not tainted $plugh[2];
d1262 3
a1264 3
    test not tainted ((&$nautilus)[0]);
    test     tainted ((&$nautilus)[1]);
    test not tainted ((&$nautilus)[2]);
d1266 3
a1268 3
    test not tainted $xyzzy[0];
    test     tainted $xyzzy[1];
    test not tainted $xyzzy[2];
d1270 3
a1272 3
    test not tainted ((&$red_october)[0]);
    test     tainted ((&$red_october)[1]);
    test not tainted ((&$red_october)[2]);
d1274 3
a1276 3
    test not tainted $corge[0];
    test     tainted $corge[1];
    test not tainted $corge[2];
d1283 1
a1283 1
        skip "getpwent() is not available", 1 unless 
d1289 9
a1297 9
	test (    not tainted $getpwent[0]
	          and     tainted $getpwent[1]
	          and not tainted $getpwent[2]
	          and not tainted $getpwent[3]
	          and not tainted $getpwent[4]
	          and not tainted $getpwent[5]
	          and     tainted $getpwent[6]		# ge?cos
	          and not tainted $getpwent[7]
		  and     tainted $getpwent[8]);	# shell
d1305 4
a1308 5
	local(*D);
	opendir(D, "op") or die "opendir: $!\n";
	my $readdir = readdir(D);
	test tainted $readdir;
	closedir(D);
d1321 1
a1321 1
	test tainted $readlink;
d1330 1
a1330 1
    test not tainted $j;
d1333 1
a1333 1
    test     tainted $j;
d1340 1
a1340 1
    test     tainted $why;
d1344 1
a1344 1
    test     tainted $why;
d1347 1
a1347 1
    test     tainted $why;
d1382 1
a1382 1
        test tainted $rcvd;
d1417 1
a1417 1
	    test tainted $rcvd;
d1425 1
a1425 1
    open IN, $TEST or warn "$0: cannot read $TEST: $!" ;
d1427 2
a1428 4
    my $a = <IN>;
    my $b = <IN>;

    ok tainted($a) && tainted($b) && !defined($b);
d1430 3
a1432 1
    close IN;
d1438 2
a1439 2
    open IN, $TEST or warn "$0: cannot read $TEST: $!" ;
    my $a = <IN>;
d1444 2
a1445 1
    ok !tainted($c->{a}) && tainted($c->{b});
d1450 2
a1451 1
    ok tainted($d->{a}) && !tainted($d->{b});
d1456 4
a1459 6
    ok !tainted($e->{a}) &&
       !tainted($e->{b}) &&
	tainted($e->{b}->{c}) &&
       !tainted($e->{b}->{d});

    close IN;
d1476 5
a1480 1
	my $evil = "foo" . $TAINT;
d1482 22
a1503 55
	eval { sysopen(my $ro, $evil, &O_RDONLY) };
	test $@@ !~ /^Insecure dependency/, $@@;
	
	eval { sysopen(my $wo, $evil, &O_WRONLY) };
	test $@@ =~ /^Insecure dependency/, $@@;
	
	eval { sysopen(my $rw, $evil, &O_RDWR) };
	test $@@ =~ /^Insecure dependency/, $@@;
	
	eval { sysopen(my $ap, $evil, &O_APPEND) };
	test $@@ =~ /^Insecure dependency/, $@@;
	
	eval { sysopen(my $cr, $evil, &O_CREAT) };
	test $@@ =~ /^Insecure dependency/, $@@;
	
	eval { sysopen(my $tr, $evil, &O_TRUNC) };
	test $@@ =~ /^Insecure dependency/, $@@;
	
	eval { sysopen(my $ro, "foo", &O_RDONLY | $TAINT0) };
	test $@@ !~ /^Insecure dependency/, $@@;
	
	eval { sysopen(my $wo, "foo", &O_WRONLY | $TAINT0) };
	test $@@ =~ /^Insecure dependency/, $@@;

	eval { sysopen(my $rw, "foo", &O_RDWR | $TAINT0) };
	test $@@ =~ /^Insecure dependency/, $@@;

	eval { sysopen(my $ap, "foo", &O_APPEND | $TAINT0) };
	test $@@ =~ /^Insecure dependency/, $@@;
	
	eval { sysopen(my $cr, "foo", &O_CREAT | $TAINT0) };
	test $@@ =~ /^Insecure dependency/, $@@;

	eval { sysopen(my $tr, "foo", &O_TRUNC | $TAINT0) };
	test $@@ =~ /^Insecure dependency/, $@@;

	eval { sysopen(my $ro, "foo", &O_RDONLY, $TAINT0) };
	test $@@ !~ /^Insecure dependency/, $@@;
	
	eval { sysopen(my $wo, "foo", &O_WRONLY, $TAINT0) };
	test $@@ =~ /^Insecure dependency/, $@@;
	
	eval { sysopen(my $rw, "foo", &O_RDWR, $TAINT0) };
	test $@@ =~ /^Insecure dependency/, $@@;
	
	eval { sysopen(my $ap, "foo", &O_APPEND, $TAINT0) };
	test $@@ =~ /^Insecure dependency/, $@@;
	
	eval { sysopen(my $cr, "foo", &O_CREAT, $TAINT0) };
	test $@@ =~ /^Insecure dependency/, $@@;

	eval { sysopen(my $tr, "foo", &O_TRUNC, $TAINT0) };
	test $@@ =~ /^Insecure dependency/, $@@;
	
	unlink("foo"); # not unlink($evil), because that would fail...
d1513 1
a1513 1
    local $SIG{__WARN__} = sub { $saw_warning = 1 };
d1524 1
a1524 1
    test !$saw_warning;
d1567 1
a1567 1
    test @@untainted == 0, "untainted:\n @@untainted";
d1571 1
a1571 1
ok( ${^TAINT} == 1, '$^TAINT is on' );
d1574 3
a1576 3
ok( ${^TAINT},  '$^TAINT is not assignable' );
ok( $@@ =~ /^Modification of a read-only value attempted/,
                                'Assigning to ${^TAINT} fails' );
d1582 1
a1582 1
    test tainted $re1;
d1585 1
a1585 1
    test tainted $re2;
d1588 1
a1588 1
    test tainted $re3;
d1597 1
a1597 1
    test $@@ =~ /^Insecure \$ENV/;
d1605 11
a1615 22
    my $err = qr/^Insecure dependency/ ;
    test !eval { exec $TAINT, $TAINT }, 'exec';
    test $@@ =~ $err, $@@;
    test !eval { exec $TAINT $TAINT }, 'exec';
    test $@@ =~ $err, $@@;
    test !eval { exec $TAINT $TAINT, $TAINT }, 'exec';
    test $@@ =~ $err, $@@;
    test !eval { exec $TAINT 'notaint' }, 'exec';
    test $@@ =~ $err, $@@;
    test !eval { exec {'notaint'} $TAINT }, 'exec';
    test $@@ =~ $err, $@@;

    test !eval { system $TAINT, $TAINT }, 'system';
    test $@@ =~ $err, $@@;
    test !eval { system $TAINT $TAINT }, 'system';
    test $@@ =~ $err, $@@;
    test !eval { system $TAINT $TAINT, $TAINT }, 'system';
    test $@@ =~ $err, $@@;
    test !eval { system $TAINT 'notaint' }, 'system';
    test $@@ =~ $err, $@@;
    test !eval { system {'notaint'} $TAINT }, 'system';
    test $@@ =~ $err, $@@;
d1621 1
a1621 1
    test !$@@;
d1627 1
a1627 1
    test !$@@;
d1636 1
a1636 1
    test tainted(my $foo = $1);
d1644 1
a1644 1
    test $@@ =~ /^%ENV is aliased to another variable while running with -T switch/;
d1647 1
a1647 1
    test $@@ =~ /^%ENV is aliased to %nonmagicalenv while running with -T switch/;
d1652 1
a1652 1
    test !tainted($1);
d1654 1
a1654 1
    test !tainted($notaint);
d1659 2
a1660 2
    test !tainted($1);
    test !tainted($l);
d1663 2
a1664 2
    test tainted($1);
    test tainted($l);
d1668 2
a1669 2
    test !tainted($1);
    test !tainted($l);
d1672 2
a1673 2
    test tainted($1);
    test tainted($l);
d1677 1
a1677 1
    test !tainted($1);
d1679 1
a1679 1
    test tainted($1);
d1685 1
a1685 1
    test !tainted($^O);
d1687 2
a1688 1
    test !tainted($^O);
d1690 1
a1690 1
    test $@@ =~ /Insecure dependency in/;
d1695 1
a1695 1
    test tainted( $tainted_number );
d1699 2
a1700 2
    test tainted( $tainted_product );
    test $tainted_product == 0;
d1706 2
a1707 2
    test tainted( $tainted_true );
    test tainted( $tainted_false );
d1710 2
a1711 2
    test $result eq "True";
    test !tainted( $result );
d1714 2
a1715 2
    test $result eq "False";
    test !tainted( $result );
d1721 2
a1722 2
    test $result eq "Soft Cell";
    test tainted( $result );
d1725 2
a1726 2
    test $result eq "The Fabulous Johnny Cash";
    test !tainted( $result );
d1740 2
a1741 1
        test not tainted $1;
d1747 2
a1748 1
        test not any_tainted @@bar;
d1757 1
a1757 1
    test tainted $x99;
d1760 1
a1760 1
    test not tainted $x99;
d1763 1
a1763 1
    test not tainted $x99;
d1767 1
a1767 1
    test tainted $x99;
d1770 1
a1770 1
    test tainted $x99;
d1778 1
a1778 1
    test $@@ eq '';
d1785 13
a1797 7
    local $::TODO = 1;
    $a[0] = $^X;
    my $i = 0;
    while($a[0]=~ m/(.)/g ) {
	last if $i++ > 10000;
    }
    cmp_ok $i, '<', 10000, "infinite m//g";
d1815 2
a1816 2
	skip "opening |- is not stable on threaded OpenBSD with taint", 3
            if $Config{useithreads} && $Is_OpenBSD;
d1830 2
a1831 2
	test $@@ !~ /Insecure \$ENV/, 'fork triggers %ENV check';
	test $@@ eq '',               'pipe/fork/open/close failed';
d1836 1
a1836 1
	test $@@ =~ /Insecure \$ENV/, 'popen neglects %ENV check';
d1846 3
a1848 1
            main::ok(!main::tainted($AUTOLOAD), '$AUTOLOAD can be untainted');
d1850 3
a1852 1
            main::ok(main::tainted($AUTOLOAD), '$AUTOLOAD can be tainted');
d1858 1
d1865 5
a1869 2
    eval { printf($TAINT . "# %s\n", "foo") };
    like($@@, qr/^Insecure dependency in printf/, q/printf doesn't like tainted formats/);
d1871 5
a1875 3
    ok(!$@@, q/printf accepts other tainted args/);
    eval { sprintf($TAINT . "# %s\n", "foo") };
    like($@@, qr/^Insecure dependency in sprintf/, q/sprintf doesn't like tainted formats/);
d1877 1
a1877 1
    ok(!$@@, q/sprintf accepts other tainted args/);
d1900 3
a1902 3
    open FH, "test.pl" or die $!;
    seek FH, 0, 2 or die $!;
    $tainted = <FH>;
d1914 1
a1914 1
    ok(!tainted($1), "\\S match with chr $ord");
d1924 2
a1925 2
    ok(tainted($a),  "tainted crypt");
    ok(!tainted($b), "untainted crypt");
d1928 2
a1929 2
    ok(tainted($a),  "tainted complement");
    ok(!tainted($b), "untainted complement");
d1937 1
a1937 1
    ok(tainted($string), "tainted data");
d1943 1
a1943 1
	ok(tainted($got[$i]), "tainted result $i");
d1947 1
a1947 1
    ok(tainted($string), "still tainted data");
d1953 1
a1953 1
	ok(tainted($got[$i]), "tainted result $i");
d1957 1
a1957 1
    ok(tainted($string), "still tainted data");
d1963 1
a1963 1
	ok(tainted($got[$i]), "tainted result $i");
d1972 1
a1972 1
    ok(tainted($y), "pack a* preserves tainting");
d1975 1
a1975 1
    ok(tainted($z), "pack A* preserves tainting");
d1978 1
a1978 1
    ok(tainted($zz), "pack a*a* preserves tainting");
d1992 176
d2171 1
a2171 1
    ok(tainted($dest), "lc(tainted) taints its return value");
d2173 1
a2173 1
    ok(tainted($dest), "lcfirst(tainted) taints its return value");
d2175 1
a2175 1
    ok(tainted($dest), "uc(tainted) taints its return value");
d2177 83
a2259 1
    ok(tainted($dest), "ucfirst(tainted) taints its return value");
@


1.13
log
@merge in perl 5.12.2 plus local changes
@
text
@d20 1
a20 1
plan tests => 302;
d1321 12
@


1.13.2.1
log
@Perl security fix for CVE-2011-1487.
ok sthen@@ jasper@@
@
text
@d20 1
a20 1
plan tests => 306;
a1320 12
{
    # [perl #87336] lc/uc(first) failing to taint the returned string
    my $source = "foo$TAINT";
    my $dest = lc $source;
    ok(tainted($dest), "lc(tainted) taints its return value");
    $dest = lcfirst $source;
    ok(tainted($dest), "lcfirst(tainted) taints its return value");
    $dest = uc $source;
    ok(tainted($dest), "uc(tainted) taints its return value");
    $dest = ucfirst $source;
    ok(tainted($dest), "ucfirst(tainted) taints its return value");
}
@


1.12
log
@Merge in perl 5.10.1; part two
@
text
@d20 1
a20 1
plan tests => 301;
a44 1
my $Is_MacOS    = $^O eq 'MacOS';
d53 1
a53 2
                  $Is_MacOS    ? ':perl'                :
                  $Is_NetWare  ? 'perl'                 : 
d135 1
a135 1
my $ECHO = ($Is_MSWin32 ? ".\\echo$$" : $Is_MacOS ? ":echo$$" : ($Is_NetWare ? "echo$$" : "./echo$$"));
d174 1
a174 1
          if $Is_MSWin32 || $Is_NetWare || $Is_VMS || $Is_Dos || $Is_MacOS;
d431 1
a431 2
	($Is_Dos && $! == 22) ||
	($^O eq 'mint' && $! == 33);
a627 1
	$sl = MacPerl::MakePath((MacPerl::Volumes())[0]) if $Is_MacOS;
d972 5
a976 9
    SKIP: {
        skip "no exec() on MacOS Classic" if $Is_MacOS;

	eval { 
            no warnings;
            exec("lskdfj does not exist","with","args"); 
        };
	test !$@@;
    }
d1310 11
@


1.12.4.1
log
@Perl security fix for CVE-2011-1487.
ok sthen@@ jasper@@
@
text
@d20 1
a20 1
plan tests => 305;
a1316 13
}

{
    # [perl #87336] lc/uc(first) failing to taint the returned string
    my $source = "foo$TAINT";
    my $dest = lc $source;
    ok(tainted($dest), "lc(tainted) taints its return value");
    $dest = lcfirst $source;
    ok(tainted($dest), "lcfirst(tainted) taints its return value");
    $dest = uc $source;
    ok(tainted($dest), "uc(tainted) taints its return value");
    $dest = ucfirst $source;
    ok(tainted($dest), "ucfirst(tainted) taints its return value");
@


1.11
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d20 1
a20 1
plan tests => 267;
d288 1
a288 1
    my $arg = catfile(curdir(), "arg$$");
d421 1
a421 2
    my $filename = "./taintB$$";	# NB: $filename isn't tainted!
    END { unlink $filename if defined $filename }
d508 1
a508 2
	my $temp = "./taintC$$";
	END { unlink $temp }
d1253 64
@


1.10
log
@merge in perl 5.8.8
@
text
@d20 1
a20 2
plan tests => 238;

d26 1
d28 3
d51 2
a52 1
my $Invoke_Perl = $Is_VMS      ? 'MCR Sys$Disk:[]Perl.' :
d64 4
d70 4
a73 2
	    \$ENV{PATH} = '' if $Config{d_setenv};
	    warn "# Note: logical name 'PATH' may have been deleted\n";
d75 5
d168 1
a168 2

    $ENV{PATH} = '';
a171 16
    if ($Is_Cygwin && ! -f 'cygwin1.dll') {
	system("/usr/bin/cp /usr/bin/cygwin1.dll .") &&
	    die "$0: failed to cp cygwin1.dll: $!\n";
	eval q{
	    END { unlink "cygwin1.dll" }
	};
    }

    if ($Is_Cygwin && ! -f 'cygcrypt-0.dll' && -f '/usr/bin/cygcrypt-0.dll') {
	system("/usr/bin/cp /usr/bin/cygcrypt-0.dll .") &&
	    die "$0: failed to cp cygcrypt-0.dll: $!\n";
	eval q{
	    END { unlink "cygcrypt-0.dll" }
	};
    }

d1107 181
@


1.9
log
@sync in-tree perl with 5.8.6
@
text
@d19 2
a20 13
my $total_tests = 236;
my $test = 177;
sub ok ($;$) {
    my($ok, $name) = @@_;

    # You have to do it this way or VMS will get confused.
    print $ok ? "ok $test - $name\n" : "not ok $test - $name\n";

    printf "# Failed test at line %d\n", (caller)[2] unless $ok;

    $test++;
    return $ok;
}
d42 11
a52 10
my $Is_MacOS = $^O eq 'MacOS';
my $Is_VMS = $^O eq 'VMS';
my $Is_MSWin32 = $^O eq 'MSWin32';
my $Is_NetWare = $^O eq 'NetWare';
my $Is_Dos = $^O eq 'dos';
my $Is_Cygwin = $^O eq 'cygwin';
my $Invoke_Perl = $Is_VMS ? 'MCR Sys$Disk:[]Perl.' :
                  ($Is_MSWin32 ? '.\perl' :
                  $Is_MacOS ? ':perl' :
                  ($Is_NetWare ? 'perl' : './perl'));
d73 5
a77 1
my $TAINT0 = 0 + $TAINT;
d97 8
a104 4
sub test ($$;$) {
    my($serial, $boolean, $diag) = @@_;
    if ($boolean) {
	print "ok $serial\n";
d106 2
a107 1
	print "not ok $serial\n";
d115 4
a130 2
print "1..$total_tests\n";

d137 17
d174 5
a178 1
    test 1, eval { `$echo 1` } eq "1\n";
a179 5
    if ($Is_MSWin32 || $Is_NetWare || $Is_VMS || $Is_Dos || $Is_MacOS) {
	print "# Environment tainting tests skipped\n";
	for (2..5) { print "ok $_\n" }
    }
    else {
d187 1
a187 1
	test 2, !@@vars, "\$$vars[0]";
d192 1
a192 1
	test 3, eval { `$echo 1` } eq "1\n";
d194 2
a195 2
	test 4, eval { `$echo 1` } eq '';
	test 5, $@@ =~ /^Insecure \$ENV{TERM}/, $@@;
d209 3
a211 1
    if ($tmp) {
d213 2
a214 5
	test 6, eval { `$echo 1` } eq '';
	test 7, $@@ =~ /^Insecure directory in \$ENV{PATH}/, $@@;
    }
    else {
	for (6..7) { print "ok $_ # Skipped: all directories are writeable\n" }
d217 3
a219 1
    if ($Is_VMS) {
d221 6
a226 3
	test 8,  eval { `$echo 1` } eq '';
	test 9, $@@ =~ /^Insecure \$ENV{DCL\$PATH}/, $@@;
	if ($tmp) {
d228 2
a229 5
	    test 10, eval { `$echo 1` } eq '';
	    test 11, $@@ =~ /^Insecure directory in \$ENV{DCL\$PATH}/, $@@;
	}
	else {
	    for (10..11) { print "ok $_ # Skipped: can't find world-writeable directory to test DCL\$PATH\n" }
a232 3
    else {
	for (8..11) { print "ok $_ # Skipped: This is not VMS\n"; }
    }
d238 1
a238 1
    test 12, tainted $foo;
d244 1
a244 1
    test 13, not tainted $foo;
d247 1
a247 1
    test 14, tainted $foo;
d250 1
a250 1
    test 15, not any_tainted @@list;
d252 3
a254 3
    test 16, any_tainted @@list;
    test 17, all_tainted @@list[1,3,5,7,9];
    test 18, not any_tainted @@list[0,2,4,6,8];
d257 1
a257 1
    test 19, not tainted $foo;
d260 2
a261 2
    test 20, not tainted $foo;
    test 21, $foo eq 'bar';
d267 2
a268 2
      test 22, tainted $foo;
      test 23, $foo eq 'bar';
d271 2
a272 2
      test 24, tainted $foo;
      test 25, $foo eq 'bar';
d276 2
a277 2
    test 26, tainted $foo;
    test 27, $foo eq 'bar';
d280 1
a280 1
    test 28, tainted $pi;
d283 2
a284 2
    test 29, not tainted $pi;
    test 30, sprintf("%.5f", $pi) eq '3.14159';
d300 1
a300 1
    test 31, !$?, "Exited with status $?";
d306 1
a306 1
    test 32, open(FILE, $TEST), "Couldn't open '$TEST': $!";
d312 2
a313 2
    test 33, tainted $block;
    test 34, tainted $line;
d318 3
a320 5
if (1  # built-in glob
    or $Is_VMS) {
    for (35..36) { print "ok $_\n"; }
}
else {
d322 1
a322 1
    test 35, @@globs == 0 && $@@ =~ /^Insecure dependency/;
d325 1
a325 1
    test 36, @@globs == 0 && $@@ =~ /^Insecure dependency/;
d331 1
a331 1
    test 37, tainted $foo;
d336 1
a336 1
    test 38, all_tainted $^X, $0;
d342 1
a342 1
    test 39, tainted $foo;
d345 1
a345 1
    test 40, not any_tainted $`, $&, $';
d348 1
a348 1
    test 41, not any_tainted $1, $2, $3, $+;
d351 1
a351 1
    test 42, not any_tainted @@bar;
d353 2
a354 2
    test 43, tainted $foo;	# $foo should still be tainted!
    test 44, $foo eq "abcdefghi";
d359 2
a360 2
    test 45, eval { chmod 0, $TAINT } eq '', 'chmod';
    test 46, $@@ =~ /^Insecure dependency/, $@@;
d364 5
a368 2
    test 47, eval { truncate 'NoSuChFiLe', $TAINT0 } eq '', 'truncate';
    test 48, $@@ =~ /^(?:Insecure dependency|truncate not implemented)/, $@@;
d370 2
a371 2
    test 49, eval { rename '', $TAINT } eq '', 'rename';
    test 50, $@@ =~ /^Insecure dependency/, $@@;
d373 2
a374 2
    test 51, eval { unlink $TAINT } eq '', 'unlink';
    test 52, $@@ =~ /^Insecure dependency/, $@@;
d376 2
a377 2
    test 53, eval { utime $TAINT } eq '', 'utime';
    test 54, $@@ =~ /^Insecure dependency/, $@@;
d379 2
a380 3
    if ($Config{d_chown}) {
	test 55, eval { chown -1, -1, $TAINT } eq '', 'chown';
	test 56, $@@ =~ /^Insecure dependency/, $@@;
d382 6
a387 2
    else {
	for (55..56) { print "ok $_ # Skipped: chown() is not available\n" }
d390 2
a391 7
    if ($Config{d_link}) {
	test 57, eval { link $TAINT, '' } eq '', 'link';
	test 58, $@@ =~ /^Insecure dependency/, $@@;
    }
    else {
	for (57..58) { print "ok $_ # Skipped: link() is not available\n" }
    }
d393 2
a394 6
    if ($Config{d_symlink}) {
	test 59, eval { symlink $TAINT, '' } eq '', 'symlink';
	test 60, $@@ =~ /^Insecure dependency/, $@@;
    }
    else {
	for (59..60) { print "ok $_ # Skipped: symlink() is not available\n" }
d400 2
a401 2
    test 61, eval { mkdir $TAINT0, $TAINT } eq '', 'mkdir';
    test 62, $@@ =~ /^Insecure dependency/, $@@;
d403 2
a404 2
    test 63, eval { rmdir $TAINT } eq '', 'rmdir';
    test 64, $@@ =~ /^Insecure dependency/, $@@;
d406 2
a407 2
    test 65, eval { chdir $TAINT } eq '', 'chdir';
    test 66, $@@ =~ /^Insecure dependency/, $@@;
d409 5
a413 6
    if ($Config{d_chroot}) {
	test 67, eval { chroot $TAINT } eq '', 'chroot';
	test 68, $@@ =~ /^Insecure dependency/, $@@;
    }
    else {
	for (67..68) { print "ok $_ # Skipped: chroot() is not available\n" }
d420 2
a421 2
    test 69, eval { require $foo } eq '', 'require';
    test 70, $@@ =~ /^Insecure dependency/, $@@;
d428 2
a429 2
    test 71, eval { open FOO, $foo } eq '', 'open for read';
    test 72, $@@ eq '', $@@;		# NB: This should be allowed
d434 1
a434 1
    test 73, eval('$!{ENOENT}') ||
d439 2
a440 2
    test 74, eval { open FOO, "> $foo" } eq '', 'open for write';
    test 75, $@@ =~ /^Insecure dependency/, $@@;
d447 5
a451 6
    if ($^O eq 'amigaos') {
	for (76..79) { print "ok $_ # Skipped: open('|') is not available\n" }
    }
    else {
	test 76, eval { open FOO, "| x$foo" } eq '', 'popen to';
	test 77, $@@ =~ /^Insecure dependency/, $@@;
d453 2
a454 2
	test 78, eval { open FOO, "x$foo |" } eq '', 'popen from';
	test 79, $@@ =~ /^Insecure dependency/, $@@;
d457 2
a458 2
    test 80, eval { exec $TAINT } eq '', 'exec';
    test 81, $@@ =~ /^Insecure dependency/, $@@;
d460 2
a461 2
    test 82, eval { system $TAINT } eq '', 'system';
    test 83, $@@ =~ /^Insecure dependency/, $@@;
d466 2
a467 2
    test 84, eval { `$echo 1$foo` } eq '', 'backticks';
    test 85, $@@ =~ /^Insecure dependency/, $@@;
d469 6
a474 6
    if ($Is_VMS) { # wildcard expansion doesn't invoke shell, so is safe
	test 86, join('', eval { glob $foo } ) ne '', 'globbing';
	test 87, $@@ eq '', $@@;
    }
    else {
	for (86..87) { print "ok $_ # Skipped: This is not VMS\n"; }
d480 5
a484 2
    test 88, eval { kill 0, $TAINT } eq '', 'kill';
    test 89, $@@ =~ /^Insecure dependency/, $@@;
d486 2
a487 6
    if ($Config{d_setpgrp}) {
	test 90, eval { setpgrp 0, $TAINT } eq '', 'setpgrp';
	test 91, $@@ =~ /^Insecure dependency/, $@@;
    }
    else {
	for (90..91) { print "ok $_ # Skipped: setpgrp() is not available\n" }
d490 5
a494 6
    if ($Config{d_setprior}) {
	test 92, eval { setpriority 0, $TAINT, $TAINT } eq '', 'setpriority';
	test 93, $@@ =~ /^Insecure dependency/, $@@;
    }
    else {
	for (92..93) { print "ok $_ # Skipped: setpriority() is not available\n" }
d500 5
a504 6
    if ($Config{d_syscall}) {
	test 94, eval { syscall $TAINT } eq '', 'syscall';
	test 95, $@@ =~ /^Insecure dependency/, $@@;
    }
    else {
	for (94..95) { print "ok $_ # Skipped: syscall() is not available\n" }
d513 1
a513 1
	test 96, open(FOO, "> $temp"), "Couldn't open $temp for write: $!";
d515 2
a516 2
	test 97, eval { ioctl FOO, $TAINT, $foo } eq '', 'ioctl';
	test 98, $@@ =~ /^Insecure dependency/, $@@;
d518 5
a522 6
	if ($Config{d_fcntl}) {
	    test 99, eval { fcntl FOO, $TAINT, $foo } eq '', 'fcntl';
	    test 100, $@@ =~ /^Insecure dependency/, $@@;
	}
	else {
	    for (99..100) { print "ok $_ # Skipped: fcntl() is not available\n" }
d533 3
a535 3
    test 101, not tainted $fooref;
    test 102, tainted $$fooref;
    test 103, tainted $foo;
d542 14
a555 14
    test 104, all_tainted $foo, $bar;
    test 105, tainted($foo = $bar);
    test 106, tainted($bar = $bar);
    test 107, tainted($bar += $bar);
    test 108, tainted($bar -= $bar);
    test 109, tainted($bar *= $bar);
    test 110, tainted($bar++);
    test 111, tainted($bar /= $bar);
    test 112, tainted($bar += 0);
    test 113, tainted($bar -= 2);
    test 114, tainted($bar *= -1);
    test 115, tainted($bar /= 1);
    test 116, tainted($bar--);
    test 117, $bar == 0;
d561 3
a563 3
    test 118, not tainted $foo[0];
    test 119,     tainted $foo[1];
    test 120, not tainted $foo[2];
d565 3
a567 3
    test 121, not tainted $bar[0];
    test 122,     tainted $bar[1];
    test 123, not tainted $bar[2];
d569 3
a571 3
    test 124, not tainted $baz[0];
    test 125,     tainted $baz[1];
    test 126, not tainted $baz[2];
d573 3
a575 3
    test 127, not tainted $plugh[0];
    test 128,     tainted $plugh[1];
    test 129, not tainted $plugh[2];
d577 3
a579 3
    test 130, not tainted ((&$nautilus)[0]);
    test 131,     tainted ((&$nautilus)[1]);
    test 132, not tainted ((&$nautilus)[2]);
d581 3
a583 3
    test 133, not tainted $xyzzy[0];
    test 134,     tainted $xyzzy[1];
    test 135, not tainted $xyzzy[2];
d585 3
a587 3
    test 136, not tainted ((&$red_october)[0]);
    test 137,     tainted ((&$red_october)[1]);
    test 138, not tainted ((&$red_october)[2]);
d589 3
a591 3
    test 139, not tainted $corge[0];
    test 140,     tainted $corge[1];
    test 141, not tainted $corge[2];
d597 4
a600 1
    if (eval { setpwent(); getpwent() }) {
d604 1
a604 1
	test 142,(    not tainted $getpwent[0]
a613 2
    } else {
	for (142) { print "ok $_ # Skipped: getpwent() is not available\n" }
d616 4
a619 1
    if ($Config{d_readdir}) { # pretty hard to imagine not
d623 2
a624 4
	test 143, tainted $readdir;
	closedir(OP);
    } else {
	for (143) { print "ok $_ # Skipped: readdir() is not available\n" }
d627 4
a630 1
    if ($Config{d_readlink} && $Config{d_symlink}) {
d638 1
a638 1
	test 144, tainted $readlink;
a639 2
    } else {
	for (144) { print "ok $_ # Skipped: readlink() or symlink() is not available\n"; }
d647 1
a647 1
    test 145, not tainted $j;
d650 1
a650 1
    test 146,     tainted $j;
d657 1
a657 1
    test 147,     tainted $why;
d661 1
a661 1
    test 148,     tainted $why;
d664 1
a664 1
    test 149,     tainted $why;
d667 33
a699 5
# test shmread
{
    unless ($ipcsysv) {
	print "ok 150 # skipped: no IPC::SysV\n";
	last;
a700 6
    if ($Config{'extensions'} =~ /\bIPC\/SysV\b/ && $Config{d_shm}) {
	no strict 'subs';
	my $sent = "foobar";
	my $rcvd;
	my $size = 2000;
	my $id = shmget(IPC_PRIVATE, $size, S_IRWXU);
a701 14
	if (defined $id) {
	    if (shmwrite($id, $sent, 0, 60)) {
		if (shmread($id, $rcvd, 0, 60)) {
		    substr($rcvd, index($rcvd, "\0")) = '';
		} else {
		    warn "# shmread failed: $!\n";
		}
	    } else {
		warn "# shmwrite failed: $!\n";
	    }
	    shmctl($id, IPC_RMID, 0) or warn "# shmctl failed: $!\n";
	} else {
	    warn "# shmget failed: $!\n";
	}
d703 3
a705 9
	if ($rcvd eq $sent) {
	    test 150, tainted $rcvd;
	} else {
	    print "ok 150 # Skipped: SysV shared memory operation failed\n";
	}
    } else {
	print "ok 150 # Skipped: SysV shared memory is not available\n";
    }
}
a706 7
# test msgrcv
{
    unless ($ipcsysv) {
	print "ok 151 # skipped: no IPC::SysV\n";
	last;
    }
    if ($Config{'extensions'} =~ /\bIPC\/SysV\b/ && $Config{d_msg}) {
d730 5
a734 4
	if ($rcvd eq $sent && $type_sent == $type_rcvd) {
	    test 151, tainted $rcvd;
	} else {
	    print "ok 151 # Skipped: SysV message queue operation failed\n";
a735 2
    } else {
	print "ok 151 # Skipped: SysV message queues are not available\n";
d746 3
a748 2
    print "not " unless tainted($a) && tainted($b) && !defined($b);
    print "ok 152\n";
d760 3
a762 2
    print "not " unless !tainted($c->{a}) && tainted($c->{b});
    print "ok 153\n";
d766 2
a767 2
    print "not " unless tainted($d->{a}) && !tainted($d->{b});
    print "ok 154\n";
d771 4
a774 5
    print "not " unless !tainted($e->{a}) &&
	                !tainted($e->{b}) &&
	                 tainted($e->{b}->{c}) &&
	                !tainted($e->{b}->{d});
    print "ok 155\n";
d790 3
a792 5
    unless ($has_fcntl) {
	for (156..173) {
	    print "ok $_ # Skip: no Fcntl (no dynaloading?)\n";
	}
    } else {
d796 1
a796 1
	test 156, $@@ !~ /^Insecure dependency/, $@@;
d799 1
a799 1
	test 157, $@@ =~ /^Insecure dependency/, $@@;
d802 1
a802 1
	test 158, $@@ =~ /^Insecure dependency/, $@@;
d805 1
a805 1
	test 159, $@@ =~ /^Insecure dependency/, $@@;
d808 1
a808 1
	test 160, $@@ =~ /^Insecure dependency/, $@@;
d811 1
a811 1
	test 161, $@@ =~ /^Insecure dependency/, $@@;
d813 2
a814 2
	eval { sysopen(my $ro, "foo", &O_RDONLY | $evil) };
	test 162, $@@ !~ /^Insecure dependency/, $@@;
d816 2
a817 2
	eval { sysopen(my $wo, "foo", &O_WRONLY | $evil) };
	test 163, $@@ =~ /^Insecure dependency/, $@@;
d819 2
a820 2
	eval { sysopen(my $rw, "foo", &O_RDWR | $evil) };
	test 164, $@@ =~ /^Insecure dependency/, $@@;
d822 2
a823 2
	eval { sysopen(my $ap, "foo", &O_APPEND | $evil) };
	test 165, $@@ =~ /^Insecure dependency/, $@@;
d825 2
a826 2
	eval { sysopen(my $cr, "foo", &O_CREAT | $evil) };
	test 166, $@@ =~ /^Insecure dependency/, $@@;
d828 2
a829 2
	eval { sysopen(my $tr, "foo", &O_TRUNC | $evil) };
	test 167, $@@ =~ /^Insecure dependency/, $@@;
d831 2
a832 2
	eval { sysopen(my $ro, "foo", &O_RDONLY, $evil) };
	test 168, $@@ !~ /^Insecure dependency/, $@@;
d834 2
a835 2
	eval { sysopen(my $wo, "foo", &O_WRONLY, $evil) };
	test 169, $@@ =~ /^Insecure dependency/, $@@;
d837 2
a838 2
	eval { sysopen(my $rw, "foo", &O_RDWR, $evil) };
	test 170, $@@ =~ /^Insecure dependency/, $@@;
d840 2
a841 2
	eval { sysopen(my $ap, "foo", &O_APPEND, $evil) };
	test 171, $@@ =~ /^Insecure dependency/, $@@;
d843 2
a844 2
	eval { sysopen(my $cr, "foo", &O_CREAT, $evil) };
	test 172, $@@ =~ /^Insecure dependency/, $@@;
d846 2
a847 2
	eval { sysopen(my $tr, "foo", &O_TRUNC, $evil) };
	test 173, $@@ =~ /^Insecure dependency/, $@@;
d858 2
a859 1
    local $SIG{__WARN__} = sub { print "not " };
d870 1
a870 1
    print "ok 174\n";
d900 1
a900 2
    print $i == 1 ? "ok 175\n" : "not ok 175\n"

d913 1
a913 2
    print @@untainted == 0 ? "ok 176\n" : "not ok 176\n";
    print "# untainted:\n", @@untainted if @@untainted; 
d928 1
a928 1
    test 180, tainted $re1;
d931 1
a931 1
    test 181, tainted $re2;
d934 1
a934 1
    test 182, tainted $re3;
d937 3
a939 5
if ($Is_MSWin32) {
    print "ok 183 # Skipped: system {} has different semantics\n"; 
}
else
{
d943 1
a943 1
    test 183, $@@ =~ /^Insecure \$ENV/;
d945 6
a950 7
if ($Is_VMS) {
    for (184..205) {print "not ok $_ # TODO tainted %ENV warning occludes tainted arguments warning\n";}
}
else 
{
    # bug 20020208.005 plus some extras
    # single arg exec/system are tests 80-83
d952 36
a987 29
    test 184, eval { exec $TAINT, $TAINT } eq '', 'exec';
    test 185, $@@ =~ $err, $@@;
    test 186, eval { exec $TAINT $TAINT } eq '', 'exec';
    test 187, $@@ =~ $err, $@@;
    test 188, eval { exec $TAINT $TAINT, $TAINT } eq '', 'exec';
    test 189, $@@ =~ $err, $@@;
    test 190, eval { exec $TAINT 'notaint' } eq '', 'exec';
    test 191, $@@ =~ $err, $@@;
    test 192, eval { exec {'notaint'} $TAINT } eq '', 'exec';
    test 193, $@@ =~ $err, $@@;

    test 194, eval { system $TAINT, $TAINT } eq '', 'system';
    test 195, $@@ =~ $err, $@@;
    test 196, eval { system $TAINT $TAINT } eq '', 'system';
    test 197, $@@ =~ $err, $@@;
    test 198, eval { system $TAINT $TAINT, $TAINT } eq '', 'system';
    test 199, $@@ =~ $err, $@@;
    test 200, eval { system $TAINT 'notaint' } eq '', 'system';
    test 201, $@@ =~ $err, $@@;
    test 202, eval { system {'notaint'} $TAINT } eq '', 'system';
    test 203, $@@ =~ $err, $@@;

    eval { system("lskdfj does not exist","with","args"); };
    test 204, $@@ eq '';
    if ($Is_MacOS) {
	print "ok 205 # no exec()\n";
    } else {
	eval { exec("lskdfj does not exist","with","args"); };
	test 205, $@@ eq '';
d997 1
a997 1
    test 206, tainted(my $foo = $1);
d1001 8
a1008 3
    # Remove this when changes 21542 and 21563 are integrated
    test 207, 1;
    test 208, 1;
a1009 1

d1013 1
a1013 1
    test 209, !tainted($1);
d1015 1
a1015 1
    test 210, !tainted($notaint);
d1020 2
a1021 2
    test 211, !tainted($1);
    test 212, !tainted($l);
d1024 2
a1025 2
    test 213, tainted($1);
    test 214, tainted($l);
d1029 2
a1030 2
    test 215, !tainted($1);
    test 216, !tainted($l);
d1033 2
a1034 2
    test 217, tainted($1);
    test 218, tainted($l);
d1038 1
a1038 1
    test 219, !tainted($1);
d1040 1
a1040 1
    test 220, tainted($1);
d1046 1
a1046 1
    test 221, !tainted($^O);
d1048 1
a1048 1
    test 222, !tainted($^O);
d1050 1
a1050 1
    test 223, $@@ =~ /Insecure dependency in/;
d1055 1
a1055 1
    test 224, tainted( $tainted_number );
d1059 2
a1060 2
    test 225, tainted( $tainted_product );
    test 226, $tainted_product == 0;
d1066 2
a1067 2
    test 227, tainted( $tainted_true );
    test 228, tainted( $tainted_false );
d1070 2
a1071 2
    test 229, $result eq "True";
    test 230, !tainted( $result );
d1074 2
a1075 2
    test 231, $result eq "False";
    test 232, !tainted( $result );
d1081 2
a1082 2
    test 233, $result eq "Soft Cell";
    test 234, tainted( $result );
d1085 23
a1107 2
    test 235, $result eq "The Fabulous Johnny Cash";
    test 236, !tainted( $result );
@


1.8
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d19 1
d128 1
a128 1
print "1..223\n";
d1044 36
@


1.7
log
@merge local changes into perl-5.8.3
@
text
@d127 1
a127 1
print "1..220\n";
d1033 10
@


1.6
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d127 1
a127 1
print "1..206\n";
d142 11
a152 1
	END { unlink "cygwin1.dll" } # yes, done for all platforms...
d994 39
@


1.5
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d47 1
a47 1
	  IPC::SysV->import(qw(IPC_PRIVATE IPC_RMID IPC_CREAT S_IRWXU));
d127 1
a127 1
print "1..205\n";
d703 2
a704 2
	    if (msgsnd($id, pack("l! a*", $type_sent, $sent), 0)) {
		if (msgrcv($id, $rcvd, 60, 0, 0)) {
d707 1
a707 1
		    warn "# msgrcv failed\n";
d710 1
a710 1
		warn "# msgsnd failed\n";
d897 2
a898 2
	    # These we have untainted explicitly earlier.
	    $k !~ /^(BASH_ENV|CDPATH|ENV|IFS|PATH|TEMP|TERM|TMP)$/) {
d907 1
a907 1
ok( ${^TAINT},  '$^TAINT is on' );
d944 1
a944 3
    use if $] lt '5.009', warnings => FATAL => 'taint';
    my $err = $] ge '5.009' ? qr/^Insecure dependency/ 
                            : qr/^Use of tainted arguments/;
d969 6
a974 2
    eval { exec("lskdfj does not exist","with","args"); };
    test 205, $@@ eq '';
d977 7
@


1.4
log
@merge in perl 5.6.1 with our local changes
@
text
@d17 1
d19 15
a33 3
# We do not want the whole taint.t to fail
# just because Errno possibly failing.
eval { require Errno; import Errno };
d52 1
d55 1
d57 1
d59 3
a61 1
                  $Is_MSWin32 ? '.\perl' : './perl';
d118 1
a118 1
my $ECHO = ($Is_MSWin32 ? ".\\echo$$" : "./echo$$");
d125 3
a127 1
print "1..155\n";
d139 6
d147 1
a147 1
    if ($Is_MSWin32 || $Is_VMS || $Is_Dos) {
d171 1
a171 1
    if ($^O eq 'os2' || $^O eq 'amigaos' || $Is_MSWin32 || $Is_Dos) {
d263 2
a264 2
{
    my $arg = "./arg$$";
d280 1
a280 2
    my $file = './TEST';
    test 32, open(FILE, $file), "Couldn't open '$file': $!";
d412 3
a414 1
    test 73, $!{ENOENT} ||
d455 1
a455 1
	for (86..87) { print "ok $_ # Skipped: this is not VMS\n"; }
d582 1
a582 1
    if (eval { setpwent(); getpwent(); 1 }) {
d613 4
a616 1
	symlink("/something/naughty", $symlink) or die "symlink: $!\n";
d730 1
a730 1
    open IN, "./TEST" or warn "$0: cannot read ./TEST: $!" ;
d742 1
a742 1
    open IN, "./TEST" or warn "$0: cannot read ./TEST: $!" ;
d766 210
@


1.3
log
@perl-5.6.0 + local changes
@
text
@d12 1
a12 1
    unshift @@INC, '../lib' if -d '../lib';
d22 2
d29 7
a35 3
  if ($Config{d_shm} || $Config{d_msg}) {
     require IPC::SysV;
     IPC::SysV->import(qw(IPC_PRIVATE IPC_RMID IPC_CREAT S_IRWXU));
d107 1
a107 1
print "1..151\n";
d621 5
a625 1
    if ($Config{d_shm}) {
d630 2
a631 2
	my $id = shmget(IPC_PRIVATE, $size, S_IRWXU) ||
	    warn "# shmget failed: $!\n";
d642 1
a642 1
	    shmctl($id, IPC_RMID, 0) || warn "# shmctl failed: $!\n";
d659 5
a663 1
    if ($Config{d_msg}) {
d682 1
a682 1
	    msgctl($id, IPC_RMID, 0) || warn "# msgctl failed: $!\n";
d695 39
@


1.2
log
@perl5.005_03 (stock)
@
text
@d12 1
a12 1
    @@INC = '../lib' if -d '../lib';
d22 11
d47 1
a47 1
	    \$ENV{PATH} = '';
d49 1
a49 1
	    @@ENV{keys %old} = values %old;
d101 1
a101 1
print "1..149\n";
d144 1
a144 1
		     qw(/tmp /var/tmp /usr/tmp /sys$scratch),
d261 2
a262 1
if ($Is_VMS) {
d398 1
a398 1
	test 76, eval { open FOO, "| $foo" } eq '', 'popen to';
d401 1
a401 1
	test 78, eval { open FOO, "$foo |" } eq '', 'popen from';
d554 1
a554 1
	          and not tainted $getpwent[1]
d559 1
a559 1
	          and     tainted $getpwent[6] # gecos
d561 1
a561 1
		  and not tainted $getpwent[8]);
d612 71
@


1.1
log
@perl 5.004_04
@
text
@d18 4
d24 1
d90 1
a90 1
print "1..140\n";
d104 1
a104 1
    if ($Is_MSWin32 || $Is_VMS) {
d128 1
a128 1
    if ($^O eq 'os2' || $^O eq 'amigaos' || $Is_MSWin32) {
d144 1
a144 1
	for (6..7) { print "ok $_\n" }
d157 1
a157 2
	    print "# can't find world-writeable directory to test DCL\$PATH\n";
	    for (10..11) { print "ok $_\n" }
d162 1
a162 2
	print "# This is not VMS\n";
	for (8..11) { print "ok $_\n"; }
d194 16
d211 1
a211 1
    test 22, tainted $pi;
d214 2
a215 2
    test 23, not tainted $pi;
    test 24, sprintf("%.5f", $pi) eq '3.14159';
d231 1
a231 1
    test 25, !$?, "Exited with status $?";
d238 1
a238 1
    test 26, open(FILE, $file), "Couldn't open '$file': $!";
d244 2
a245 2
    test 27, tainted $block;
    test 28, tainted $line;
d251 1
a251 1
    for (29..30) { print "ok $_\n"; }
d255 1
a255 1
    test 29, @@globs == 0 && $@@ =~ /^Insecure dependency/;
d258 1
a258 1
    test 30, @@globs == 0 && $@@ =~ /^Insecure dependency/;
d264 1
a264 1
    test 31, tainted $foo;
d269 1
a269 1
    test 32, all_tainted $^X, $0;
d275 1
a275 1
    test 33, tainted $foo;
d278 1
a278 1
    test 34, not any_tainted $`, $&, $';
d281 1
a281 1
    test 35, not any_tainted $1, $2, $3, $+;
d284 1
a284 1
    test 36, not any_tainted @@bar;
d286 2
a287 2
    test 37, tainted $foo;	# $foo should still be tainted!
    test 38, $foo eq "abcdefghi";
d292 2
a293 2
    test 39, eval { chmod 0, $TAINT } eq '', 'chmod';
    test 40, $@@ =~ /^Insecure dependency/, $@@;
d297 2
a298 2
    test 41, eval { truncate 'NoSuChFiLe', $TAINT0 } eq '', 'truncate';
    test 42, $@@ =~ /^(?:Insecure dependency|truncate not implemented)/, $@@;
d300 2
a301 2
    test 43, eval { rename '', $TAINT } eq '', 'rename';
    test 44, $@@ =~ /^Insecure dependency/, $@@;
d303 2
a304 2
    test 45, eval { unlink $TAINT } eq '', 'unlink';
    test 46, $@@ =~ /^Insecure dependency/, $@@;
d306 2
a307 2
    test 47, eval { utime $TAINT } eq '', 'utime';
    test 48, $@@ =~ /^Insecure dependency/, $@@;
d310 2
a311 2
	test 49, eval { chown -1, -1, $TAINT } eq '', 'chown';
	test 50, $@@ =~ /^Insecure dependency/, $@@;
d314 1
a314 2
	print "# chown() is not available\n";
	for (49..50) { print "ok $_\n" }
d318 2
a319 2
	test 51, eval { link $TAINT, '' } eq '', 'link';
	test 52, $@@ =~ /^Insecure dependency/, $@@;
d322 1
a322 2
	print "# link() is not available\n";
	for (51..52) { print "ok $_\n" }
d326 2
a327 2
	test 53, eval { symlink $TAINT, '' } eq '', 'symlink';
	test 54, $@@ =~ /^Insecure dependency/, $@@;
d330 1
a330 2
	print "# symlink() is not available\n";
	for (53..54) { print "ok $_\n" }
d336 2
a337 2
    test 55, eval { mkdir $TAINT0, $TAINT } eq '', 'mkdir';
    test 56, $@@ =~ /^Insecure dependency/, $@@;
d339 2
a340 2
    test 57, eval { rmdir $TAINT } eq '', 'rmdir';
    test 58, $@@ =~ /^Insecure dependency/, $@@;
d342 2
a343 2
    test 59, eval { chdir $TAINT } eq '', 'chdir';
    test 60, $@@ =~ /^Insecure dependency/, $@@;
d346 2
a347 2
	test 61, eval { chroot $TAINT } eq '', 'chroot';
	test 62, $@@ =~ /^Insecure dependency/, $@@;
d350 1
a350 2
	print "# chroot() is not available\n";
	for (61..62) { print "ok $_\n" }
d357 2
a358 2
    test 63, eval { require $foo } eq '', 'require';
    test 64, $@@ =~ /^Insecure dependency/, $@@;
d365 8
a372 3
    test 65, eval { open FOO, $foo } eq '', 'open for read';
    test 66, $@@ eq '', $@@;		# NB: This should be allowed
    test 67, $! == 2;			# File not found
d374 2
a375 2
    test 68, eval { open FOO, "> $foo" } eq '', 'open for write';
    test 69, $@@ =~ /^Insecure dependency/, $@@;
d383 1
a383 2
	print "# open(\"|\") is not available\n";
	for (70..73) { print "ok $_\n" }
d386 2
a387 2
	test 70, eval { open FOO, "| $foo" } eq '', 'popen to';
	test 71, $@@ =~ /^Insecure dependency/, $@@;
d389 2
a390 2
	test 72, eval { open FOO, "$foo |" } eq '', 'popen from';
	test 73, $@@ =~ /^Insecure dependency/, $@@;
d393 2
a394 2
    test 74, eval { exec $TAINT } eq '', 'exec';
    test 75, $@@ =~ /^Insecure dependency/, $@@;
d396 2
a397 2
    test 76, eval { system $TAINT } eq '', 'system';
    test 77, $@@ =~ /^Insecure dependency/, $@@;
d402 2
a403 2
    test 78, eval { `$echo 1$foo` } eq '', 'backticks';
    test 79, $@@ =~ /^Insecure dependency/, $@@;
d406 2
a407 2
	test 80, join('', eval { glob $foo } ) ne '', 'globbing';
	test 81, $@@ eq '', $@@;
d410 1
a410 1
	for (80..81) { print "ok $_\n"; }
d416 2
a417 2
    test 82, eval { kill 0, $TAINT } eq '', 'kill';
    test 83, $@@ =~ /^Insecure dependency/, $@@;
d420 2
a421 2
	test 84, eval { setpgrp 0, $TAINT } eq '', 'setpgrp';
	test 85, $@@ =~ /^Insecure dependency/, $@@;
d424 1
a424 2
	print "# setpgrp() is not available\n";
	for (84..85) { print "ok $_\n" }
d428 2
a429 2
	test 86, eval { setpriority 0, $TAINT, $TAINT } eq '', 'setpriority';
	test 87, $@@ =~ /^Insecure dependency/, $@@;
d432 1
a432 2
	print "# setpriority() is not available\n";
	for (86..87) { print "ok $_\n" }
d439 2
a440 2
	test 88, eval { syscall $TAINT } eq '', 'syscall';
	test 89, $@@ =~ /^Insecure dependency/, $@@;
d443 1
a443 2
	print "# syscall() is not available\n";
	for (88..89) { print "ok $_\n" }
d452 1
a452 1
	test 90, open(FOO, "> $temp"), "Couldn't open $temp for write: $!";
d454 2
a455 2
	test 91, eval { ioctl FOO, $TAINT, $foo } eq '', 'ioctl';
	test 92, $@@ =~ /^Insecure dependency/, $@@;
d458 2
a459 2
	    test 93, eval { fcntl FOO, $TAINT, $foo } eq '', 'fcntl';
	    test 94, $@@ =~ /^Insecure dependency/, $@@;
d462 1
a462 2
	    print "# fcntl() is not available\n";
	    for (93..94) { print "ok $_\n" }
d473 3
a475 3
    test 95, not tainted $fooref;
    test 96, tainted $$fooref;
    test 97, tainted $foo;
d482 14
a495 14
    test 98, all_tainted $foo, $bar;
    test 99, tainted($foo = $bar);
    test 100, tainted($bar = $bar);
    test 101, tainted($bar += $bar);
    test 102, tainted($bar -= $bar);
    test 103, tainted($bar *= $bar);
    test 104, tainted($bar++);
    test 105, tainted($bar /= $bar);
    test 106, tainted($bar += 0);
    test 107, tainted($bar -= 2);
    test 108, tainted($bar *= -1);
    test 109, tainted($bar /= 1);
    test 110, tainted($bar--);
    test 111, $bar == 0;
d501 3
a503 3
    test 112, not tainted $foo[0];
    test 113,     tainted $foo[1];
    test 114, not tainted $foo[2];
d505 3
a507 3
    test 115, not tainted $bar[0];
    test 116,     tainted $bar[1];
    test 117, not tainted $bar[2];
d509 3
a511 3
    test 118, not tainted $baz[0];
    test 119,     tainted $baz[1];
    test 120, not tainted $baz[2];
d513 3
a515 3
    test 121, not tainted $plugh[0];
    test 122,     tainted $plugh[1];
    test 123, not tainted $plugh[2];
d517 3
a519 3
    test 124, not tainted ((&$nautilus)[0]);
    test 125,     tainted ((&$nautilus)[1]);
    test 126, not tainted ((&$nautilus)[2]);
d521 3
a523 3
    test 127, not tainted $xyzzy[0];
    test 128,     tainted $xyzzy[1];
    test 129, not tainted $xyzzy[2];
d525 3
a527 3
    test 130, not tainted ((&$red_october)[0]);
    test 131,     tainted ((&$red_october)[1]);
    test 132, not tainted ((&$red_october)[2]);
d529 3
a531 3
    test 133, not tainted $corge[0];
    test 134,     tainted $corge[1];
    test 135, not tainted $corge[2];
d541 1
a541 1
	test 136,(    not tainted $getpwent[0]
d552 1
a552 2
	print "# getpwent() is not available\n";
	print "ok 136\n";
d559 1
a559 1
	test 137, tainted $readdir;
d562 1
a562 2
	print "# readdir() is not available\n";
	print "ok 137\n";
d570 1
a570 1
	test 138, tainted $readlink;
d573 1
a573 2
	print "# readlink() or symlink() is not available\n";
	print "ok 138\n";
d581 1
a581 1
    test 139, not tainted $j;
d584 1
a584 1
    test 140,     tainted $j;
d587 13
@


1.1.1.1
log
@perl5.005_03
@
text
@a17 4
# We do not want the whole taint.t to fail
# just because Errno possibly failing.
eval { require Errno; import Errno };

a19 1
my $Is_Dos = $^O eq 'dos';
d85 1
a85 1
print "1..149\n";
d99 1
a99 1
    if ($Is_MSWin32 || $Is_VMS || $Is_Dos) {
d123 1
a123 1
    if ($^O eq 'os2' || $^O eq 'amigaos' || $Is_MSWin32 || $Is_Dos) {
d139 1
a139 1
	for (6..7) { print "ok $_ # Skipped: all directories are writeable\n" }
d152 2
a153 1
	    for (10..11) { print "ok $_ # Skipped: can't find world-writeable directory to test DCL\$PATH\n" }
d158 2
a159 1
	for (8..11) { print "ok $_ # Skipped: This is not VMS\n"; }
a190 16
    {
      use re 'taint';

      ($foo) = ('bar' . $TAINT) =~ /(.+)/;
      test 22, tainted $foo;
      test 23, $foo eq 'bar';

      $foo = $1 if ('bar' . $TAINT) =~ /(.+)/;
      test 24, tainted $foo;
      test 25, $foo eq 'bar';
    }

    $foo = $1 if 'bar' =~ /(.+)$TAINT/;
    test 26, tainted $foo;
    test 27, $foo eq 'bar';

d192 1
a192 1
    test 28, tainted $pi;
d195 2
a196 2
    test 29, not tainted $pi;
    test 30, sprintf("%.5f", $pi) eq '3.14159';
d212 1
a212 1
    test 31, !$?, "Exited with status $?";
d219 1
a219 1
    test 32, open(FILE, $file), "Couldn't open '$file': $!";
d225 2
a226 2
    test 33, tainted $block;
    test 34, tainted $line;
d232 1
a232 1
    for (35..36) { print "ok $_\n"; }
d236 1
a236 1
    test 35, @@globs == 0 && $@@ =~ /^Insecure dependency/;
d239 1
a239 1
    test 36, @@globs == 0 && $@@ =~ /^Insecure dependency/;
d245 1
a245 1
    test 37, tainted $foo;
d250 1
a250 1
    test 38, all_tainted $^X, $0;
d256 1
a256 1
    test 39, tainted $foo;
d259 1
a259 1
    test 40, not any_tainted $`, $&, $';
d262 1
a262 1
    test 41, not any_tainted $1, $2, $3, $+;
d265 1
a265 1
    test 42, not any_tainted @@bar;
d267 2
a268 2
    test 43, tainted $foo;	# $foo should still be tainted!
    test 44, $foo eq "abcdefghi";
d273 2
a274 2
    test 45, eval { chmod 0, $TAINT } eq '', 'chmod';
    test 46, $@@ =~ /^Insecure dependency/, $@@;
d278 2
a279 2
    test 47, eval { truncate 'NoSuChFiLe', $TAINT0 } eq '', 'truncate';
    test 48, $@@ =~ /^(?:Insecure dependency|truncate not implemented)/, $@@;
d281 2
a282 2
    test 49, eval { rename '', $TAINT } eq '', 'rename';
    test 50, $@@ =~ /^Insecure dependency/, $@@;
d284 2
a285 2
    test 51, eval { unlink $TAINT } eq '', 'unlink';
    test 52, $@@ =~ /^Insecure dependency/, $@@;
d287 2
a288 2
    test 53, eval { utime $TAINT } eq '', 'utime';
    test 54, $@@ =~ /^Insecure dependency/, $@@;
d291 2
a292 2
	test 55, eval { chown -1, -1, $TAINT } eq '', 'chown';
	test 56, $@@ =~ /^Insecure dependency/, $@@;
d295 2
a296 1
	for (55..56) { print "ok $_ # Skipped: chown() is not available\n" }
d300 2
a301 2
	test 57, eval { link $TAINT, '' } eq '', 'link';
	test 58, $@@ =~ /^Insecure dependency/, $@@;
d304 2
a305 1
	for (57..58) { print "ok $_ # Skipped: link() is not available\n" }
d309 2
a310 2
	test 59, eval { symlink $TAINT, '' } eq '', 'symlink';
	test 60, $@@ =~ /^Insecure dependency/, $@@;
d313 2
a314 1
	for (59..60) { print "ok $_ # Skipped: symlink() is not available\n" }
d320 2
a321 2
    test 61, eval { mkdir $TAINT0, $TAINT } eq '', 'mkdir';
    test 62, $@@ =~ /^Insecure dependency/, $@@;
d323 2
a324 2
    test 63, eval { rmdir $TAINT } eq '', 'rmdir';
    test 64, $@@ =~ /^Insecure dependency/, $@@;
d326 2
a327 2
    test 65, eval { chdir $TAINT } eq '', 'chdir';
    test 66, $@@ =~ /^Insecure dependency/, $@@;
d330 2
a331 2
	test 67, eval { chroot $TAINT } eq '', 'chroot';
	test 68, $@@ =~ /^Insecure dependency/, $@@;
d334 2
a335 1
	for (67..68) { print "ok $_ # Skipped: chroot() is not available\n" }
d342 2
a343 2
    test 69, eval { require $foo } eq '', 'require';
    test 70, $@@ =~ /^Insecure dependency/, $@@;
d350 3
a352 8
    test 71, eval { open FOO, $foo } eq '', 'open for read';
    test 72, $@@ eq '', $@@;		# NB: This should be allowed

    # Try first new style but allow also old style.
    test 73, $!{ENOENT} ||
	$! == 2 || # File not found
	($Is_Dos && $! == 22) ||
	($^O eq 'mint' && $! == 33);
d354 2
a355 2
    test 74, eval { open FOO, "> $foo" } eq '', 'open for write';
    test 75, $@@ =~ /^Insecure dependency/, $@@;
d363 2
a364 1
	for (76..79) { print "ok $_ # Skipped: open('|') is not available\n" }
d367 2
a368 2
	test 76, eval { open FOO, "| $foo" } eq '', 'popen to';
	test 77, $@@ =~ /^Insecure dependency/, $@@;
d370 2
a371 2
	test 78, eval { open FOO, "$foo |" } eq '', 'popen from';
	test 79, $@@ =~ /^Insecure dependency/, $@@;
d374 2
a375 2
    test 80, eval { exec $TAINT } eq '', 'exec';
    test 81, $@@ =~ /^Insecure dependency/, $@@;
d377 2
a378 2
    test 82, eval { system $TAINT } eq '', 'system';
    test 83, $@@ =~ /^Insecure dependency/, $@@;
d383 2
a384 2
    test 84, eval { `$echo 1$foo` } eq '', 'backticks';
    test 85, $@@ =~ /^Insecure dependency/, $@@;
d387 2
a388 2
	test 86, join('', eval { glob $foo } ) ne '', 'globbing';
	test 87, $@@ eq '', $@@;
d391 1
a391 1
	for (86..87) { print "ok $_ # Skipped: this is not VMS\n"; }
d397 2
a398 2
    test 88, eval { kill 0, $TAINT } eq '', 'kill';
    test 89, $@@ =~ /^Insecure dependency/, $@@;
d401 2
a402 2
	test 90, eval { setpgrp 0, $TAINT } eq '', 'setpgrp';
	test 91, $@@ =~ /^Insecure dependency/, $@@;
d405 2
a406 1
	for (90..91) { print "ok $_ # Skipped: setpgrp() is not available\n" }
d410 2
a411 2
	test 92, eval { setpriority 0, $TAINT, $TAINT } eq '', 'setpriority';
	test 93, $@@ =~ /^Insecure dependency/, $@@;
d414 2
a415 1
	for (92..93) { print "ok $_ # Skipped: setpriority() is not available\n" }
d422 2
a423 2
	test 94, eval { syscall $TAINT } eq '', 'syscall';
	test 95, $@@ =~ /^Insecure dependency/, $@@;
d426 2
a427 1
	for (94..95) { print "ok $_ # Skipped: syscall() is not available\n" }
d436 1
a436 1
	test 96, open(FOO, "> $temp"), "Couldn't open $temp for write: $!";
d438 2
a439 2
	test 97, eval { ioctl FOO, $TAINT, $foo } eq '', 'ioctl';
	test 98, $@@ =~ /^Insecure dependency/, $@@;
d442 2
a443 2
	    test 99, eval { fcntl FOO, $TAINT, $foo } eq '', 'fcntl';
	    test 100, $@@ =~ /^Insecure dependency/, $@@;
d446 2
a447 1
	    for (99..100) { print "ok $_ # Skipped: fcntl() is not available\n" }
d458 3
a460 3
    test 101, not tainted $fooref;
    test 102, tainted $$fooref;
    test 103, tainted $foo;
d467 14
a480 14
    test 104, all_tainted $foo, $bar;
    test 105, tainted($foo = $bar);
    test 106, tainted($bar = $bar);
    test 107, tainted($bar += $bar);
    test 108, tainted($bar -= $bar);
    test 109, tainted($bar *= $bar);
    test 110, tainted($bar++);
    test 111, tainted($bar /= $bar);
    test 112, tainted($bar += 0);
    test 113, tainted($bar -= 2);
    test 114, tainted($bar *= -1);
    test 115, tainted($bar /= 1);
    test 116, tainted($bar--);
    test 117, $bar == 0;
d486 3
a488 3
    test 118, not tainted $foo[0];
    test 119,     tainted $foo[1];
    test 120, not tainted $foo[2];
d490 3
a492 3
    test 121, not tainted $bar[0];
    test 122,     tainted $bar[1];
    test 123, not tainted $bar[2];
d494 3
a496 3
    test 124, not tainted $baz[0];
    test 125,     tainted $baz[1];
    test 126, not tainted $baz[2];
d498 3
a500 3
    test 127, not tainted $plugh[0];
    test 128,     tainted $plugh[1];
    test 129, not tainted $plugh[2];
d502 3
a504 3
    test 130, not tainted ((&$nautilus)[0]);
    test 131,     tainted ((&$nautilus)[1]);
    test 132, not tainted ((&$nautilus)[2]);
d506 3
a508 3
    test 133, not tainted $xyzzy[0];
    test 134,     tainted $xyzzy[1];
    test 135, not tainted $xyzzy[2];
d510 3
a512 3
    test 136, not tainted ((&$red_october)[0]);
    test 137,     tainted ((&$red_october)[1]);
    test 138, not tainted ((&$red_october)[2]);
d514 3
a516 3
    test 139, not tainted $corge[0];
    test 140,     tainted $corge[1];
    test 141, not tainted $corge[2];
d526 1
a526 1
	test 142,(    not tainted $getpwent[0]
d537 2
a538 1
	for (142) { print "ok $_ # Skipped: getpwent() is not available\n" }
d545 1
a545 1
	test 143, tainted $readdir;
d548 2
a549 1
	for (143) { print "ok $_ # Skipped: readdir() is not available\n" }
d557 1
a557 1
	test 144, tainted $readlink;
d560 2
a561 1
	for (144) { print "ok $_ # Skipped: readlink() or symlink() is not available\n"; }
d569 1
a569 1
    test 145, not tainted $j;
d572 1
a572 1
    test 146,     tainted $j;
a574 13
# test target of substitution (regression bug)
{
    my $why = $TAINT."y";
    $why =~ s/y/z/;
    test 147,     tainted $why;

    my $z = "[z]";
    $why =~ s/$z/zee/;
    test 148,     tainted $why;

    $why =~ s/e/'-'.$$/ge;
    test 149,     tainted $why;
}
@


1.1.1.2
log
@virgin perl 5.6.0
@
text
@d12 1
a12 1
    unshift @@INC, '../lib' if -d '../lib';
a21 11
BEGIN {
  if ($^O eq 'VMS' && !defined($Config{d_setenv})) {
      $ENV{PATH} = $ENV{PATH};
      $ENV{TERM} = $ENV{TERM} ne ''? $ENV{TERM} : 'dummy';
  }
  if ($Config{d_shm} || $Config{d_msg}) {
     require IPC::SysV;
     IPC::SysV->import(qw(IPC_PRIVATE IPC_RMID IPC_CREAT S_IRWXU));
  }
}

d36 1
a36 1
	    \$ENV{PATH} = '' if $Config{d_setenv};
d38 1
a38 1
	    \@@ENV{keys %old} = values %old;
d90 1
a90 1
print "1..151\n";
d133 1
a133 1
		     qw(sys$scratch /tmp /var/tmp /usr/tmp),
d250 1
a250 2
if (1  # built-in glob
    or $Is_VMS) {
d386 1
a386 1
	test 76, eval { open FOO, "| x$foo" } eq '', 'popen to';
d389 1
a389 1
	test 78, eval { open FOO, "x$foo |" } eq '', 'popen from';
d542 1
a542 1
	          and     tainted $getpwent[1]
d547 1
a547 1
	          and     tainted $getpwent[6]		# ge?cos
d549 1
a549 1
		  and     tainted $getpwent[8]);	# shell
a599 71

# test shmread
{
    if ($Config{d_shm}) {
	no strict 'subs';
	my $sent = "foobar";
	my $rcvd;
	my $size = 2000;
	my $id = shmget(IPC_PRIVATE, $size, S_IRWXU) ||
	    warn "# shmget failed: $!\n";
	if (defined $id) {
	    if (shmwrite($id, $sent, 0, 60)) {
		if (shmread($id, $rcvd, 0, 60)) {
		    substr($rcvd, index($rcvd, "\0")) = '';
		} else {
		    warn "# shmread failed: $!\n";
		}
	    } else {
		warn "# shmwrite failed: $!\n";
	    }
	    shmctl($id, IPC_RMID, 0) || warn "# shmctl failed: $!\n";
	} else {
	    warn "# shmget failed: $!\n";
	}

	if ($rcvd eq $sent) {
	    test 150, tainted $rcvd;
	} else {
	    print "ok 150 # Skipped: SysV shared memory operation failed\n";
	}
    } else {
	print "ok 150 # Skipped: SysV shared memory is not available\n";
    }
}

# test msgrcv
{
    if ($Config{d_msg}) {
	no strict 'subs';
	my $id = msgget(IPC_PRIVATE, IPC_CREAT | S_IRWXU);

	my $sent      = "message";
	my $type_sent = 1234;
	my $rcvd;
	my $type_rcvd;

	if (defined $id) {
	    if (msgsnd($id, pack("l! a*", $type_sent, $sent), 0)) {
		if (msgrcv($id, $rcvd, 60, 0, 0)) {
		    ($type_rcvd, $rcvd) = unpack("l! a*", $rcvd);
		} else {
		    warn "# msgrcv failed\n";
		}
	    } else {
		warn "# msgsnd failed\n";
	    }
	    msgctl($id, IPC_RMID, 0) || warn "# msgctl failed: $!\n";
	} else {
	    warn "# msgget failed\n";
	}

	if ($rcvd eq $sent && $type_sent == $type_rcvd) {
	    test 151, tainted $rcvd;
	} else {
	    print "ok 151 # Skipped: SysV message queue operation failed\n";
	}
    } else {
	print "ok 151 # Skipped: SysV message queues are not available\n";
    }
}

@


1.1.1.3
log
@stock perl 5.6.1
@
text
@d12 1
a12 1
    @@INC = '../lib';
a21 2
use vars qw($ipcsysv); # did we manage to load IPC::SysV?

d27 3
a29 7
  if ($Config{'extensions'} =~ /\bIPC\/SysV\b/
      && ($Config{d_shm} || $Config{d_msg})) {
      eval { require IPC::SysV };
      unless ($@@) {
	  $ipcsysv++;
	  IPC::SysV->import(qw(IPC_PRIVATE IPC_RMID IPC_CREAT S_IRWXU));
      }
d101 1
a101 1
print "1..155\n";
d615 1
a615 5
    unless ($ipcsysv) {
	print "ok 150 # skipped: no IPC::SysV\n";
	last;
    }
    if ($Config{'extensions'} =~ /\bIPC\/SysV\b/ && $Config{d_shm}) {
d620 2
a621 2
	my $id = shmget(IPC_PRIVATE, $size, S_IRWXU);

d632 1
a632 1
	    shmctl($id, IPC_RMID, 0) or warn "# shmctl failed: $!\n";
d649 1
a649 5
    unless ($ipcsysv) {
	print "ok 151 # skipped: no IPC::SysV\n";
	last;
    }
    if ($Config{'extensions'} =~ /\bIPC\/SysV\b/ && $Config{d_msg}) {
d668 1
a668 1
	    msgctl($id, IPC_RMID, 0) or warn "# msgctl failed: $!\n";
a680 39
}

{
    # bug id 20001004.006

    open IN, "./TEST" or warn "$0: cannot read ./TEST: $!" ;
    local $/;
    my $a = <IN>;
    my $b = <IN>;
    print "not " unless tainted($a) && tainted($b) && !defined($b);
    print "ok 152\n";
    close IN;
}

{
    # bug id 20001004.007

    open IN, "./TEST" or warn "$0: cannot read ./TEST: $!" ;
    my $a = <IN>;

    my $c = { a => 42,
	      b => $a };
    print "not " unless !tainted($c->{a}) && tainted($c->{b});
    print "ok 153\n";

    my $d = { a => $a,
	      b => 42 };
    print "not " unless tainted($d->{a}) && !tainted($d->{b});
    print "ok 154\n";

    my $e = { a => 42,
	      b => { c => $a, d => 42 } };
    print "not " unless !tainted($e->{a}) &&
	                !tainted($e->{b}) &&
	                 tainted($e->{b}->{c}) &&
	                !tainted($e->{b}->{d});
    print "ok 155\n";

    close IN;
@


1.1.1.4
log
@stock perl 5.8.0 from CPAN
@
text
@a16 1
use File::Spec::Functions;
d18 3
a20 15
my $test = 177;
sub ok ($;$) {
    my($ok, $name) = @@_;

    # You have to do it this way or VMS will get confused.
    print $ok ? "ok $test - $name\n" : "not ok $test - $name\n";

    printf "# Failed test at line %d\n", (caller)[2] unless $ok;

    $test++;
    return $ok;
}


$| = 1;
a38 1
my $Is_MacOS = $^O eq 'MacOS';
a40 1
my $Is_NetWare = $^O eq 'NetWare';
a41 1
my $Is_Cygwin = $^O eq 'cygwin';
d43 1
a43 3
                  ($Is_MSWin32 ? '.\perl' :
                  $Is_MacOS ? ':perl' :
                  ($Is_NetWare ? 'perl' : './perl'));
d100 1
a100 1
my $ECHO = ($Is_MSWin32 ? ".\\echo$$" : $Is_MacOS ? ":echo$$" : ($Is_NetWare ? "echo$$" : "./echo$$"));
d107 1
a107 3
my $TEST = catfile(curdir(), 'TEST');

print "1..205\n";
a118 6
    if ($Is_Cygwin && ! -f 'cygwin1.dll') {
	system("/usr/bin/cp /usr/bin/cygwin1.dll .") &&
	    die "$0: failed to cp cygwin1.dll: $!\n";
	END { unlink "cygwin1.dll" } # yes, done for all platforms...
    }

d121 1
a121 1
    if ($Is_MSWin32 || $Is_NetWare || $Is_VMS || $Is_Dos || $Is_MacOS) {
d145 1
a145 1
    if ($^O eq 'os2' || $^O eq 'amigaos' || $Is_MSWin32 || $Is_NetWare || $Is_Dos) {
d237 2
a238 2
SKIP: {
    my $arg = catfile(curdir(), "arg$$");
d254 2
a255 1
    test 32, open(FILE, $TEST), "Couldn't open '$TEST': $!";
d387 1
a387 3
    # We do not want the whole taint.t to fail
    # just because Errno possibly failing.
    test 73, eval('$!{ENOENT}') ||
d428 1
a428 1
	for (86..87) { print "ok $_ # Skipped: This is not VMS\n"; }
d555 1
a555 1
    if (eval { setpwent(); getpwent() }) {
d586 1
a586 4
	my $sl = "/something/naughty";
	# it has to be a real path on Mac OS
	$sl = MacPerl::MakePath((MacPerl::Volumes())[0]) if $Is_MacOS;
	symlink($sl, $symlink) or die "symlink: $!\n";
d700 1
a700 1
    open IN, $TEST or warn "$0: cannot read $TEST: $!" ;
d712 1
a712 1
    open IN, $TEST or warn "$0: cannot read $TEST: $!" ;
a735 210
{
    # bug id 20010519.003

    BEGIN {
	use vars qw($has_fcntl);
	eval { require Fcntl; import Fcntl; };
	unless ($@@) {
	    $has_fcntl = 1;
	}
    }

    unless ($has_fcntl) {
	for (156..173) {
	    print "ok $_ # Skip: no Fcntl (no dynaloading?)\n";
	}
    } else {
	my $evil = "foo" . $TAINT;

	eval { sysopen(my $ro, $evil, &O_RDONLY) };
	test 156, $@@ !~ /^Insecure dependency/, $@@;
	
	eval { sysopen(my $wo, $evil, &O_WRONLY) };
	test 157, $@@ =~ /^Insecure dependency/, $@@;
	
	eval { sysopen(my $rw, $evil, &O_RDWR) };
	test 158, $@@ =~ /^Insecure dependency/, $@@;
	
	eval { sysopen(my $ap, $evil, &O_APPEND) };
	test 159, $@@ =~ /^Insecure dependency/, $@@;
	
	eval { sysopen(my $cr, $evil, &O_CREAT) };
	test 160, $@@ =~ /^Insecure dependency/, $@@;
	
	eval { sysopen(my $tr, $evil, &O_TRUNC) };
	test 161, $@@ =~ /^Insecure dependency/, $@@;
	
	eval { sysopen(my $ro, "foo", &O_RDONLY | $evil) };
	test 162, $@@ !~ /^Insecure dependency/, $@@;
	
	eval { sysopen(my $wo, "foo", &O_WRONLY | $evil) };
	test 163, $@@ =~ /^Insecure dependency/, $@@;

	eval { sysopen(my $rw, "foo", &O_RDWR | $evil) };
	test 164, $@@ =~ /^Insecure dependency/, $@@;

	eval { sysopen(my $ap, "foo", &O_APPEND | $evil) };
	test 165, $@@ =~ /^Insecure dependency/, $@@;
	
	eval { sysopen(my $cr, "foo", &O_CREAT | $evil) };
	test 166, $@@ =~ /^Insecure dependency/, $@@;

	eval { sysopen(my $tr, "foo", &O_TRUNC | $evil) };
	test 167, $@@ =~ /^Insecure dependency/, $@@;

	eval { sysopen(my $ro, "foo", &O_RDONLY, $evil) };
	test 168, $@@ !~ /^Insecure dependency/, $@@;
	
	eval { sysopen(my $wo, "foo", &O_WRONLY, $evil) };
	test 169, $@@ =~ /^Insecure dependency/, $@@;
	
	eval { sysopen(my $rw, "foo", &O_RDWR, $evil) };
	test 170, $@@ =~ /^Insecure dependency/, $@@;
	
	eval { sysopen(my $ap, "foo", &O_APPEND, $evil) };
	test 171, $@@ =~ /^Insecure dependency/, $@@;
	
	eval { sysopen(my $cr, "foo", &O_CREAT, $evil) };
	test 172, $@@ =~ /^Insecure dependency/, $@@;

	eval { sysopen(my $tr, "foo", &O_TRUNC, $evil) };
	test 173, $@@ =~ /^Insecure dependency/, $@@;
	
	unlink("foo"); # not unlink($evil), because that would fail...
    }
}

{
    # bug 20010526.004

    use warnings;

    local $SIG{__WARN__} = sub { print "not " };

    sub fmi {
	my $divnum = shift()/1;
	sprintf("%1.1f\n", $divnum);
    }

    fmi(21 . $TAINT);
    fmi(37);
    fmi(248);

    print "ok 174\n";
}


{
    # Bug ID 20010730.010

    my $i = 0;

    sub Tie::TIESCALAR {
        my $class =  shift;
        my $arg   =  shift;

        bless \$arg => $class;
    }

    sub Tie::FETCH {
        $i ++;
        ${$_ [0]}
    }

 
    package main;
 
    my $bar = "The Big Bright Green Pleasure Machine";
    taint_these $bar;
    tie my ($foo), Tie => $bar;

    my $baz = $foo;

    print $i == 1 ? "ok 175\n" : "not ok 175\n"

}

{
    # Check that all environment variables are tainted.
    my @@untainted;
    while (my ($k, $v) = each %ENV) {
	if (!tainted($v) &&
	    # These we have untainted explicitly earlier.
	    $k !~ /^(BASH_ENV|CDPATH|ENV|IFS|PATH|TEMP|TERM|TMP)$/) {
	    push @@untainted, "# '$k' = '$v'\n";
	}
    }
    print @@untainted == 0 ? "ok 176\n" : "not ok 176\n";
    print "# untainted:\n", @@untainted if @@untainted; 
}


ok( ${^TAINT},  '$^TAINT is on' );

eval { ${^TAINT} = 0 };
ok( ${^TAINT},  '$^TAINT is not assignable' );
ok( $@@ =~ /^Modification of a read-only value attempted/,
                                'Assigning to ${^TAINT} fails' );

{
    # bug 20011111.105
    
    my $re1 = qr/x$TAINT/;
    test 180, tainted $re1;
    
    my $re2 = qr/^$re1\z/;
    test 181, tainted $re2;
    
    my $re3 = "$re2";
    test 182, tainted $re3;
}

if ($Is_MSWin32) {
    print "ok 183 # Skipped: system {} has different semantics\n"; 
}
else
{
    # bug 20010221.005
    local $ENV{PATH} .= $TAINT;
    eval { system { "echo" } "/arg0", "arg1" };
    test 183, $@@ =~ /^Insecure \$ENV/;
}
if ($Is_VMS) {
    for (184..205) {print "not ok $_ # TODO tainted %ENV warning occludes tainted arguments warning\n";}
}
else 
{
    # bug 20020208.005 plus some extras
    # single arg exec/system are tests 80-83
    use if $] lt '5.009', warnings => FATAL => 'taint';
    my $err = $] ge '5.009' ? qr/^Insecure dependency/ 
                            : qr/^Use of tainted arguments/;
    test 184, eval { exec $TAINT, $TAINT } eq '', 'exec';
    test 185, $@@ =~ $err, $@@;
    test 186, eval { exec $TAINT $TAINT } eq '', 'exec';
    test 187, $@@ =~ $err, $@@;
    test 188, eval { exec $TAINT $TAINT, $TAINT } eq '', 'exec';
    test 189, $@@ =~ $err, $@@;
    test 190, eval { exec $TAINT 'notaint' } eq '', 'exec';
    test 191, $@@ =~ $err, $@@;
    test 192, eval { exec {'notaint'} $TAINT } eq '', 'exec';
    test 193, $@@ =~ $err, $@@;

    test 194, eval { system $TAINT, $TAINT } eq '', 'system';
    test 195, $@@ =~ $err, $@@;
    test 196, eval { system $TAINT $TAINT } eq '', 'system';
    test 197, $@@ =~ $err, $@@;
    test 198, eval { system $TAINT $TAINT, $TAINT } eq '', 'system';
    test 199, $@@ =~ $err, $@@;
    test 200, eval { system $TAINT 'notaint' } eq '', 'system';
    test 201, $@@ =~ $err, $@@;
    test 202, eval { system {'notaint'} $TAINT } eq '', 'system';
    test 203, $@@ =~ $err, $@@;

    eval { system("lskdfj does not exist","with","args"); };
    test 204, $@@ eq '';
    eval { exec("lskdfj does not exist","with","args"); };
    test 205, $@@ eq '';

    # If you add tests here update also the above skip block for VMS.
}
@


1.1.1.5
log
@perl 5.8.2 from CPAN
@
text
@d47 1
a47 1
	  IPC::SysV->import(qw(IPC_PRIVATE IPC_RMID IPC_CREAT S_IRWXU IPC_NOWAIT));
d127 1
a127 1
print "1..206\n";
d703 2
a704 2
	    if (msgsnd($id, pack("l! a*", $type_sent, $sent), IPC_NOWAIT)) {
		if (msgrcv($id, $rcvd, 60, 0, IPC_NOWAIT)) {
d707 1
a707 1
		    warn "# msgrcv failed: $!\n";
d710 1
a710 1
		warn "# msgsnd failed: $!\n";
d897 2
a898 2
	    # These we have explicitly untainted or set earlier.
	    $k !~ /^(BASH_ENV|CDPATH|ENV|IFS|PATH|PERL_CORE|TEMP|TERM|TMP)$/) {
d907 1
a907 1
ok( ${^TAINT} == 1, '$^TAINT is on' );
d944 3
a946 1
    my $err = qr/^Insecure dependency/ ;
d971 2
a972 6
    if ($Is_MacOS) {
	print "ok 205 # no exec()\n";
    } else {
	eval { exec("lskdfj does not exist","with","args"); };
	test 205, $@@ eq '';
    }
a974 7
}

{
    # [ID 20020704.001] taint propagation failure
    use re 'taint';
    $TAINT =~ /(.*)/;
    test 206, tainted(my $foo = $1);
@


1.1.1.6
log
@perl 5.8.3 from CPAN
@
text
@d127 1
a127 1
print "1..220\n";
d142 1
a142 11
	eval q{
	    END { unlink "cygwin1.dll" }
	};
    }

    if ($Is_Cygwin && ! -f 'cygcrypt-0.dll' && -f '/usr/bin/cygcrypt-0.dll') {
	system("/usr/bin/cp /usr/bin/cygcrypt-0.dll .") &&
	    die "$0: failed to cp cygcrypt-0.dll: $!\n";
	eval q{
	    END { unlink "cygcrypt-0.dll" }
	};
a983 39
}

{
    # Remove this when changes 21542 and 21563 are integrated
    test 207, 1;
    test 208, 1;
}

{
    # [perl #24248]
    $TAINT =~ /(.*)/;
    test 209, !tainted($1);
    my $notaint = $1;
    test 210, !tainted($notaint);

    my $l;
    $notaint =~ /($notaint)/;
    $l = $1;
    test 211, !tainted($1);
    test 212, !tainted($l);
    $notaint =~ /($TAINT)/;
    $l = $1;
    test 213, tainted($1);
    test 214, tainted($l);

    $TAINT =~ /($notaint)/;
    $l = $1;
    test 215, !tainted($1);
    test 216, !tainted($l);
    $TAINT =~ /($TAINT)/;
    $l = $1;
    test 217, tainted($1);
    test 218, tainted($l);

    my $r;
    ($r = $TAINT) =~ /($notaint)/;
    test 219, !tainted($1);
    ($r = $TAINT) =~ /($TAINT)/;
    test 220, tainted($1);
@


1.1.1.7
log
@Import of stock perl 5.8.5
@
text
@d127 1
a127 1
print "1..223\n";
a1032 10

    #  [perl #24674]
    # accessing $^O  shoudn't taint it as a side-effect;
    # assigning tainted data to it is now an error

    test 221, !tainted($^O);
    if (!$^X) { } elsif ($^O eq 'bar') { }
    test 222, !tainted($^O);
    eval '$^O = $^X';
    test 223, $@@ =~ /Insecure dependency in/;
@


1.1.1.8
log
@perl 5.8.6 from CPAN
@
text
@a18 1
my $total_tests = 236;
d127 1
a127 1
print "1..$total_tests\n";
a1042 36
}

EFFECTIVELY_CONSTANTS: {
    my $tainted_number = 12 + $TAINT0;
    test 224, tainted( $tainted_number );

    # Even though it's always 0, it's still tainted
    my $tainted_product = $tainted_number * 0;
    test 225, tainted( $tainted_product );
    test 226, $tainted_product == 0;
}

TERNARY_CONDITIONALS: {
    my $tainted_true  = $TAINT . "blah blah blah";
    my $tainted_false = $TAINT0;
    test 227, tainted( $tainted_true );
    test 228, tainted( $tainted_false );

    my $result = $tainted_true ? "True" : "False";
    test 229, $result eq "True";
    test 230, !tainted( $result );

    $result = $tainted_false ? "True" : "False";
    test 231, $result eq "False";
    test 232, !tainted( $result );

    my $untainted_whatever = "The Fabulous Johnny Cash";
    my $tainted_whatever = "Soft Cell" . $TAINT;

    $result = $tainted_true ? $tainted_whatever : $untainted_whatever;
    test 233, $result eq "Soft Cell";
    test 234, tainted( $result );

    $result = $tainted_false ? $tainted_whatever : $untainted_whatever;
    test 235, $result eq "The Fabulous Johnny Cash";
    test 236, !tainted( $result );
@


1.1.1.9
log
@perl 5.8.8 import
@
text
@d19 13
a31 2
BEGIN { require './test.pl'; }
plan tests => 238;
d53 10
a62 11
my $Is_MacOS    = $^O eq 'MacOS';
my $Is_VMS      = $^O eq 'VMS';
my $Is_MSWin32  = $^O eq 'MSWin32';
my $Is_NetWare  = $^O eq 'NetWare';
my $Is_Dos      = $^O eq 'dos';
my $Is_Cygwin   = $^O eq 'cygwin';
my $Invoke_Perl = $Is_VMS      ? 'MCR Sys$Disk:[]Perl.' :
                  $Is_MSWin32  ? '.\perl'               :
                  $Is_MacOS    ? ':perl'                :
                  $Is_NetWare  ? 'perl'                 : 
                                 './perl'               ;
d83 1
a83 5
my $TAINT0;
{
    no warnings;
    $TAINT0 = 0 + $TAINT;
}
d103 4
a106 8

sub test ($;$) {
    my($ok, $diag) = @@_;

    my $curr_test = curr_test();

    if ($ok) {
	print "ok $curr_test\n";
d108 1
a108 2
	print "not ok $curr_test\n";
        printf "# Failed test at line %d\n", (caller)[2];
a115 4

    next_test();

    return $ok;
d128 2
a135 17
    if ($Is_MSWin32 && $Config{ccname} =~ /bcc32/ && ! -f 'cc3250mt.dll') {
	my $bcc_dir;
	foreach my $dir (split /$Config{path_sep}/, $ENV{PATH}) {
	    if (-f "$dir/cc3250mt.dll") {
		$bcc_dir = $dir and last;
	    }
	}
	if (defined $bcc_dir) {
	    require File::Copy;
	    File::Copy::copy("$bcc_dir/cc3250mt.dll", '.') or
		die "$0: failed to copy cc3250mt.dll: $!\n";
	    eval q{
		END { unlink "cc3250mt.dll" }
	    };
	}
    }

d156 1
a156 5
    test eval { `$echo 1` } eq "1\n";

    SKIP: {
        skip "Environment tainting tests skipped", 4
          if $Is_MSWin32 || $Is_NetWare || $Is_VMS || $Is_Dos || $Is_MacOS;
d158 5
d170 1
a170 1
	test !@@vars, "@@vars";
d175 1
a175 1
	test eval { `$echo 1` } eq "1\n";
d177 2
a178 2
	test !eval { `$echo 1` };
	test $@@ =~ /^Insecure \$ENV{TERM}/, $@@;
d192 1
a192 3
    SKIP: {
        skip "all directories are writeable", 2 unless $tmp;

d194 5
a198 2
	test !eval { `$echo 1` };
	test $@@ =~ /^Insecure directory in \$ENV{PATH}/, $@@;
d201 1
a201 3
    SKIP: {
        skip "This is not VMS", 4 unless $Is_VMS;

d203 3
a205 6
	test  eval { `$echo 1` } eq '';
	test $@@ =~ /^Insecure \$ENV{DCL\$PATH}/, $@@;
	SKIP: {
            skip q[can't find world-writeable directory to test DCL$PATH], 2
              unless $tmp;

d207 5
a211 2
	    test eval { `$echo 1` } eq '';
	    test $@@ =~ /^Insecure directory in \$ENV{DCL\$PATH}/, $@@;
d215 3
d223 1
a223 1
    test tainted $foo;
d229 1
a229 1
    test not tainted $foo;
d232 1
a232 1
    test tainted $foo;
d235 1
a235 1
    test not any_tainted @@list;
d237 3
a239 3
    test any_tainted @@list;
    test all_tainted @@list[1,3,5,7,9];
    test not any_tainted @@list[0,2,4,6,8];
d242 1
a242 1
    test not tainted $foo;
d245 2
a246 2
    test not tainted $foo;
    test $foo eq 'bar';
d252 2
a253 2
      test tainted $foo;
      test $foo eq 'bar';
d256 2
a257 2
      test tainted $foo;
      test $foo eq 'bar';
d261 2
a262 2
    test tainted $foo;
    test $foo eq 'bar';
d265 1
a265 1
    test tainted $pi;
d268 2
a269 2
    test not tainted $pi;
    test sprintf("%.5f", $pi) eq '3.14159';
d285 1
a285 1
    test !$?, "Exited with status $?";
d291 1
a291 1
    test open(FILE, $TEST), "Couldn't open '$TEST': $!";
d297 2
a298 2
    test tainted $block;
    test tainted $line;
d303 5
a307 3
SKIP: {
    skip "globs should be forbidden", 2 if 1 or $Is_VMS;

d309 1
a309 1
    test @@globs == 0 && $@@ =~ /^Insecure dependency/;
d312 1
a312 1
    test @@globs == 0 && $@@ =~ /^Insecure dependency/;
d318 1
a318 1
    test tainted $foo;
d323 1
a323 1
    test all_tainted $^X, $0;
d329 1
a329 1
    test tainted $foo;
d332 1
a332 1
    test not any_tainted $`, $&, $';
d335 1
a335 1
    test not any_tainted $1, $2, $3, $+;
d338 1
a338 1
    test not any_tainted @@bar;
d340 2
a341 2
    test tainted $foo;	# $foo should still be tainted!
    test $foo eq "abcdefghi";
d346 2
a347 2
    test !eval { chmod 0, $TAINT }, 'chmod';
    test $@@ =~ /^Insecure dependency/, $@@;
d351 2
a352 2
    test !eval { truncate 'NoSuChFiLe', $TAINT0 }, 'truncate';
    test $@@ =~ /^(?:Insecure dependency|truncate not implemented)/, $@@;
d354 2
a355 2
    test !eval { rename '', $TAINT }, 'rename';
    test $@@ =~ /^Insecure dependency/, $@@;
d357 2
a358 2
    test !eval { unlink $TAINT }, 'unlink';
    test $@@ =~ /^Insecure dependency/, $@@;
d360 2
a361 2
    test !eval { utime $TAINT }, 'utime';
    test $@@ =~ /^Insecure dependency/, $@@;
d363 7
a369 2
    SKIP: {
        skip "chown() is not available", 2 unless $Config{d_chown};
d371 6
a376 2
	test !eval { chown -1, -1, $TAINT }, 'chown';
	test $@@ =~ /^Insecure dependency/, $@@;
d379 3
a381 5
    SKIP: {
        skip "link() is not available", 2 unless $Config{d_link};

	test !eval { link $TAINT, '' }, 'link';
	test $@@ =~ /^Insecure dependency/, $@@;
d383 2
a384 6

    SKIP: {
        skip "symlink() is not available", 2 unless $Config{d_symlink};

	test !eval { symlink $TAINT, '' }, 'symlink';
	test $@@ =~ /^Insecure dependency/, $@@;
d390 2
a391 2
    test !eval { mkdir "foo".$TAINT, 0755.$TAINT0 }, 'mkdir';
    test $@@ =~ /^Insecure dependency/, $@@;
d393 2
a394 2
    test !eval { rmdir $TAINT }, 'rmdir';
    test $@@ =~ /^Insecure dependency/, $@@;
d396 2
a397 2
    test !eval { chdir "foo".$TAINT }, 'chdir';
    test $@@ =~ /^Insecure dependency/, $@@;
d399 6
a404 5
    SKIP: {
        skip "chroot() is not available", 2 unless $Config{d_chroot};

	test !eval { chroot $TAINT }, 'chroot';
	test $@@ =~ /^Insecure dependency/, $@@;
d411 2
a412 2
    test !eval { require $foo }, 'require';
    test $@@ =~ /^Insecure dependency/, $@@;
d419 2
a420 2
    test !eval { open FOO, $foo }, 'open for read';
    test $@@ eq '', $@@;		# NB: This should be allowed
d425 1
a425 1
    test eval('$!{ENOENT}') ||
d430 2
a431 2
    test !eval { open FOO, "> $foo" }, 'open for write';
    test $@@ =~ /^Insecure dependency/, $@@;
d438 6
a443 5
    SKIP: {
        skip "open('|') is not available", 4 if $^O eq 'amigaos';

	test !eval { open FOO, "| x$foo" }, 'popen to';
	test $@@ =~ /^Insecure dependency/, $@@;
d445 2
a446 2
	test !eval { open FOO, "x$foo |" }, 'popen from';
	test $@@ =~ /^Insecure dependency/, $@@;
d449 2
a450 2
    test !eval { exec $TAINT }, 'exec';
    test $@@ =~ /^Insecure dependency/, $@@;
d452 2
a453 2
    test !eval { system $TAINT }, 'system';
    test $@@ =~ /^Insecure dependency/, $@@;
d458 2
a459 2
    test !eval { `$echo 1$foo` }, 'backticks';
    test $@@ =~ /^Insecure dependency/, $@@;
d461 6
a466 6
    SKIP: {
        # wildcard expansion doesn't invoke shell on VMS, so is safe
        skip "This is not VMS", 2 unless $Is_VMS;
    
	test join('', eval { glob $foo } ) ne '', 'globbing';
	test $@@ eq '', $@@;
d472 2
a473 2
    test !eval { kill 0, $TAINT }, 'kill';
    test $@@ =~ /^Insecure dependency/, $@@;
d475 7
a481 2
    SKIP: {
        skip "setpgrp() is not available", 2 unless $Config{d_setpgrp};
d483 3
a485 2
	test !eval { setpgrp 0, $TAINT0 }, 'setpgrp';
	test $@@ =~ /^Insecure dependency/, $@@;
d487 2
a488 6

    SKIP: {
        skip "setpriority() is not available", 2 unless $Config{d_setprior};

	test !eval { setpriority 0, $TAINT0, $TAINT0 }, 'setpriority';
	test $@@ =~ /^Insecure dependency/, $@@;
d494 6
a499 5
    SKIP: {
        skip "syscall() is not available", 2 unless $Config{d_syscall};

	test !eval { syscall $TAINT }, 'syscall';
	test $@@ =~ /^Insecure dependency/, $@@;
d508 1
a508 1
	test open(FOO, "> $temp"), "Couldn't open $temp for write: $!";
d510 2
a511 2
	test !eval { ioctl FOO, $TAINT0, $foo }, 'ioctl';
	test $@@ =~ /^Insecure dependency/, $@@;
d513 6
a518 5
        SKIP: {
            skip "fcntl() is not available", 2 unless $Config{d_fcntl};

	    test !eval { fcntl FOO, $TAINT0, $foo }, 'fcntl';
	    test $@@ =~ /^Insecure dependency/, $@@;
d529 3
a531 3
    test not tainted $fooref;
    test tainted $$fooref;
    test tainted $foo;
d538 14
a551 14
    test all_tainted $foo, $bar;
    test tainted($foo = $bar);
    test tainted($bar = $bar);
    test tainted($bar += $bar);
    test tainted($bar -= $bar);
    test tainted($bar *= $bar);
    test tainted($bar++);
    test tainted($bar /= $bar);
    test tainted($bar += 0);
    test tainted($bar -= 2);
    test tainted($bar *= -1);
    test tainted($bar /= 1);
    test tainted($bar--);
    test $bar == 0;
d557 3
a559 3
    test not tainted $foo[0];
    test     tainted $foo[1];
    test not tainted $foo[2];
d561 3
a563 3
    test not tainted $bar[0];
    test     tainted $bar[1];
    test not tainted $bar[2];
d565 3
a567 3
    test not tainted $baz[0];
    test     tainted $baz[1];
    test not tainted $baz[2];
d569 3
a571 3
    test not tainted $plugh[0];
    test     tainted $plugh[1];
    test not tainted $plugh[2];
d573 3
a575 3
    test not tainted ((&$nautilus)[0]);
    test     tainted ((&$nautilus)[1]);
    test not tainted ((&$nautilus)[2]);
d577 3
a579 3
    test not tainted $xyzzy[0];
    test     tainted $xyzzy[1];
    test not tainted $xyzzy[2];
d581 3
a583 3
    test not tainted ((&$red_october)[0]);
    test     tainted ((&$red_october)[1]);
    test not tainted ((&$red_october)[2]);
d585 3
a587 3
    test not tainted $corge[0];
    test     tainted $corge[1];
    test not tainted $corge[2];
d593 1
a593 4
    SKIP: {
        skip "getpwent() is not available", 1 unless 
          eval { setpwent(); getpwent() };

d597 1
a597 1
	test (    not tainted $getpwent[0]
d607 2
d611 1
a611 4
    SKIP: {
        # pretty hard to imagine not
        skip "readdir() is not available", 1 unless $Config{d_readdir};

d615 4
a618 2
	test tainted $readdir;
	closedir(D);
d621 1
a621 4
    SKIP: {
        skip "readlink() or symlink() is not available" unless 
          $Config{d_readlink} && $Config{d_symlink};

d629 1
a629 1
	test tainted $readlink;
d631 2
d640 1
a640 1
    test not tainted $j;
d643 1
a643 1
    test     tainted $j;
d650 1
a650 1
    test     tainted $why;
d654 1
a654 1
    test     tainted $why;
d657 1
a657 1
    test     tainted $why;
d660 12
d673 14
a686 2
SKIP: {
    skip "no IPC::SysV", 2 unless $ipcsysv;
d688 7
a694 29
    # test shmread
    SKIP: {
        skip "shm*() not available", 1 unless $Config{d_shm};

        no strict 'subs';
        my $sent = "foobar";
        my $rcvd;
        my $size = 2000;
        my $id = shmget(IPC_PRIVATE, $size, S_IRWXU);

        if (defined $id) {
            if (shmwrite($id, $sent, 0, 60)) {
                if (shmread($id, $rcvd, 0, 60)) {
                    substr($rcvd, index($rcvd, "\0")) = '';
                } else {
                    warn "# shmread failed: $!\n";
                }
            } else {
                warn "# shmwrite failed: $!\n";
            }
            shmctl($id, IPC_RMID, 0) or warn "# shmctl failed: $!\n";
        } else {
            warn "# shmget failed: $!\n";
        }

        skip "SysV shared memory operation failed", 1 unless 
          $rcvd eq $sent;

        test tainted $rcvd;
d696 1
d698 7
a704 5

    # test msgrcv
    SKIP: {
        skip "msg*() not available", 1 unless $Config{d_msg};

d728 4
a731 5
        SKIP: {
            skip "SysV message queue operation failed", 1
              unless $rcvd eq $sent && $type_sent == $type_rcvd;

	    test tainted $rcvd;
d733 2
d745 2
a746 3

    ok tainted($a) && tainted($b) && !defined($b);

d758 2
a759 3

    ok !tainted($c->{a}) && tainted($c->{b});

d763 2
a764 2
    ok tainted($d->{a}) && !tainted($d->{b});

d768 5
a772 4
    ok !tainted($e->{a}) &&
       !tainted($e->{b}) &&
	tainted($e->{b}->{c}) &&
       !tainted($e->{b}->{d});
d788 5
a792 3
    SKIP: {
        skip "no Fcntl", 18 unless $has_fcntl;

d796 1
a796 1
	test $@@ !~ /^Insecure dependency/, $@@;
d799 1
a799 1
	test $@@ =~ /^Insecure dependency/, $@@;
d802 1
a802 1
	test $@@ =~ /^Insecure dependency/, $@@;
d805 1
a805 1
	test $@@ =~ /^Insecure dependency/, $@@;
d808 1
a808 1
	test $@@ =~ /^Insecure dependency/, $@@;
d811 1
a811 1
	test $@@ =~ /^Insecure dependency/, $@@;
d813 2
a814 2
	eval { sysopen(my $ro, "foo", &O_RDONLY | $TAINT0) };
	test $@@ !~ /^Insecure dependency/, $@@;
d816 2
a817 2
	eval { sysopen(my $wo, "foo", &O_WRONLY | $TAINT0) };
	test $@@ =~ /^Insecure dependency/, $@@;
d819 2
a820 2
	eval { sysopen(my $rw, "foo", &O_RDWR | $TAINT0) };
	test $@@ =~ /^Insecure dependency/, $@@;
d822 2
a823 2
	eval { sysopen(my $ap, "foo", &O_APPEND | $TAINT0) };
	test $@@ =~ /^Insecure dependency/, $@@;
d825 2
a826 2
	eval { sysopen(my $cr, "foo", &O_CREAT | $TAINT0) };
	test $@@ =~ /^Insecure dependency/, $@@;
d828 2
a829 2
	eval { sysopen(my $tr, "foo", &O_TRUNC | $TAINT0) };
	test $@@ =~ /^Insecure dependency/, $@@;
d831 2
a832 2
	eval { sysopen(my $ro, "foo", &O_RDONLY, $TAINT0) };
	test $@@ !~ /^Insecure dependency/, $@@;
d834 2
a835 2
	eval { sysopen(my $wo, "foo", &O_WRONLY, $TAINT0) };
	test $@@ =~ /^Insecure dependency/, $@@;
d837 2
a838 2
	eval { sysopen(my $rw, "foo", &O_RDWR, $TAINT0) };
	test $@@ =~ /^Insecure dependency/, $@@;
d840 2
a841 2
	eval { sysopen(my $ap, "foo", &O_APPEND, $TAINT0) };
	test $@@ =~ /^Insecure dependency/, $@@;
d843 2
a844 2
	eval { sysopen(my $cr, "foo", &O_CREAT, $TAINT0) };
	test $@@ =~ /^Insecure dependency/, $@@;
d846 2
a847 2
	eval { sysopen(my $tr, "foo", &O_TRUNC, $TAINT0) };
	test $@@ =~ /^Insecure dependency/, $@@;
d858 1
a858 2
    my $saw_warning = 0;
    local $SIG{__WARN__} = sub { $saw_warning = 1 };
d869 1
a869 1
    test !$saw_warning;
d899 2
a900 1
    ok $i == 1;
d913 2
a914 1
    test @@untainted == 0, "untainted:\n @@untainted";
d929 1
a929 1
    test tainted $re1;
d932 1
a932 1
    test tainted $re2;
d935 1
a935 1
    test tainted $re3;
d938 5
a942 3
SKIP: {
    skip "system {} has different semantics on Win32", 1 if $Is_MSWin32;

d946 4
a949 1
    test $@@ =~ /^Insecure \$ENV/;
d951 4
a954 6

TODO: {
    todo_skip 'tainted %ENV warning occludes tainted arguments warning', 22
      if $Is_VMS;

    # bug 20020208.005 plus some single arg exec/system extras
d956 29
a984 36
    test !eval { exec $TAINT, $TAINT }, 'exec';
    test $@@ =~ $err, $@@;
    test !eval { exec $TAINT $TAINT }, 'exec';
    test $@@ =~ $err, $@@;
    test !eval { exec $TAINT $TAINT, $TAINT }, 'exec';
    test $@@ =~ $err, $@@;
    test !eval { exec $TAINT 'notaint' }, 'exec';
    test $@@ =~ $err, $@@;
    test !eval { exec {'notaint'} $TAINT }, 'exec';
    test $@@ =~ $err, $@@;

    test !eval { system $TAINT, $TAINT }, 'system';
    test $@@ =~ $err, $@@;
    test !eval { system $TAINT $TAINT }, 'system';
    test $@@ =~ $err, $@@;
    test !eval { system $TAINT $TAINT, $TAINT }, 'system';
    test $@@ =~ $err, $@@;
    test !eval { system $TAINT 'notaint' }, 'system';
    test $@@ =~ $err, $@@;
    test !eval { system {'notaint'} $TAINT }, 'system';
    test $@@ =~ $err, $@@;

    eval { 
        no warnings;
        system("lskdfj does not exist","with","args"); 
    };
    test !$@@;

    SKIP: {
        skip "no exec() on MacOS Classic" if $Is_MacOS;

	eval { 
            no warnings;
            exec("lskdfj does not exist","with","args"); 
        };
	test !$@@;
d994 1
a994 1
    test tainted(my $foo = $1);
d998 3
a1000 8
    # [perl #24291] this used to dump core
    our %nonmagicalenv = ( PATH => "util" );
    local *ENV = \%nonmagicalenv;
    eval { system("lskdfj"); };
    test $@@ =~ /^%ENV is aliased to another variable while running with -T switch/;
    local *ENV = *nonmagicalenv;
    eval { system("lskdfj"); };
    test $@@ =~ /^%ENV is aliased to %nonmagicalenv while running with -T switch/;
d1002 1
d1006 1
a1006 1
    test !tainted($1);
d1008 1
a1008 1
    test !tainted($notaint);
d1013 2
a1014 2
    test !tainted($1);
    test !tainted($l);
d1017 2
a1018 2
    test tainted($1);
    test tainted($l);
d1022 2
a1023 2
    test !tainted($1);
    test !tainted($l);
d1026 2
a1027 2
    test tainted($1);
    test tainted($l);
d1031 1
a1031 1
    test !tainted($1);
d1033 1
a1033 1
    test tainted($1);
d1039 1
a1039 1
    test !tainted($^O);
d1041 1
a1041 1
    test !tainted($^O);
d1043 1
a1043 1
    test $@@ =~ /Insecure dependency in/;
d1048 1
a1048 1
    test tainted( $tainted_number );
d1052 2
a1053 2
    test tainted( $tainted_product );
    test $tainted_product == 0;
d1059 2
a1060 2
    test tainted( $tainted_true );
    test tainted( $tainted_false );
d1063 2
a1064 2
    test $result eq "True";
    test !tainted( $result );
d1067 2
a1068 2
    test $result eq "False";
    test !tainted( $result );
d1074 2
a1075 2
    test $result eq "Soft Cell";
    test tainted( $result );
d1078 2
a1079 23
    test $result eq "The Fabulous Johnny Cash";
    test !tainted( $result );
}

{
    # rt.perl.org 5900  $1 remains tainted if...
    # 1) The regular expression contains a scalar variable AND
    # 2) The regular expression appears in an elsif clause

    my $foo = "abcdefghi" . $TAINT;

    my $valid_chars = 'a-z';
    if ( $foo eq '' ) {
    }
    elsif ( $foo =~ /([$valid_chars]+)/o ) {
        test not tainted $1;
    }

    if ( $foo eq '' ) {
    }
    elsif ( my @@bar = $foo =~ /([$valid_chars]+)/o ) {
        test not any_tainted @@bar;
    }
@


1.1.1.10
log
@import perl 5.10.0 from CPAN
@
text
@d20 2
a21 1
plan tests => 267;
a26 1
my ($old_env_path, $old_env_dcl_path, $old_env_term);
a27 3
   $old_env_path = $ENV{'PATH'};
   $old_env_dcl_path = $ENV{'DCL$PATH'};
   $old_env_term = $ENV{'TERM'};
d48 1
a48 2
my $Is_OpenBSD  = $^O eq 'openbsd';
my $Invoke_Perl = $Is_VMS      ? 'MCR Sys$Disk:[]Perl.exe' :
a59 4
    # VMS note:  PATH and TERM are automatically created by the C
    # library in VMS on reference to the their keys in %ENV.
    # There is currently no way to determine if they did not exist
    # before this test was run.
d62 2
a63 4
	    \$ENV{PATH} = \$old_env_path;
	    warn "# Note: logical name 'PATH' may have been created\n";
	    \$ENV{'TERM'} = \$old_env_term;
	    warn "# Note: logical name 'TERM' may have been created\n";
a64 5
	    if (defined \$old_env_dcl_path) {
		\$ENV{'DCL\$PATH'} = \$old_env_dcl_path;
	    } else {
		delete \$ENV{'DCL\$PATH'};
	    }
d153 2
a154 1
    $ENV{PATH} = ($Is_Cygwin) ? '/usr/bin' : '';
d158 16
a1108 181

# at scope exit, a restored localised value should have its old
# taint status, not the taint status of the current statement

{
    our $x99 = $^X;
    test tainted $x99;

    $x99 = '';
    test not tainted $x99;

    my $c = do { local $x99; $^X };
    test not tainted $x99;
}
{
    our $x99 = $^X;
    test tainted $x99;

    my $c = do { local $x99; '' };
    test tainted $x99;
}

# an mg_get of a tainted value during localization shouldn't taint the
# statement

{
    eval { local $0, eval '1' };
    test $@@ eq '';
}

# [perl #8262] //g loops infinitely on tainted data

{
    my @@a;
    local $::TODO = 1;
    $a[0] = $^X;
    my $i = 0;
    while($a[0]=~ m/(.)/g ) {
	last if $i++ > 10000;
    }
    cmp_ok $i, '<', 10000, "infinite m//g";
}

SKIP:
{
    my $got_dualvar;
    eval 'use Scalar::Util "dualvar"; $got_dualvar++';
    skip "No Scalar::Util::dualvar" unless $got_dualvar;
    my $a = Scalar::Util::dualvar(3, $^X);
    my $b = $a + 5;
    is ($b, 8, "Arithmetic on tainted dualvars works");
}

# opening '|-' should not trigger $ENV{PATH} check

{
    SKIP: {
	skip "fork() is not available", 3 unless $Config{'d_fork'};
	skip "opening |- is not stable on threaded OpenBSD with taint", 3
            if $Config{useithreads} && $Is_OpenBSD;

	$ENV{'PATH'} = $TAINT;
	local $SIG{'PIPE'} = 'IGNORE';
	eval {
	    my $pid = open my $pipe, '|-';
	    if (!defined $pid) {
		die "open failed: $!";
	    }
	    if (!$pid) {
		kill 'KILL', $$;	# child suicide
	    }
	    close $pipe;
	};
	test $@@ !~ /Insecure \$ENV/, 'fork triggers %ENV check';
	test $@@ eq '',               'pipe/fork/open/close failed';
	eval {
	    open my $pipe, "|$Invoke_Perl -e 1";
	    close $pipe;
	};
	test $@@ =~ /Insecure \$ENV/, 'popen neglects %ENV check';
    }
}

{
    package AUTOLOAD_TAINT;
    sub AUTOLOAD {
        our $AUTOLOAD;
        return if $AUTOLOAD =~ /DESTROY/;
        if ($AUTOLOAD =~ /untainted/) {
            main::ok(!main::tainted($AUTOLOAD), '$AUTOLOAD can be untainted');
        } else {
            main::ok(main::tainted($AUTOLOAD), '$AUTOLOAD can be tainted');
        }
    }

    package main;
    my $o = bless [], 'AUTOLOAD_TAINT';
    $o->$TAINT;
    $o->untainted;
}

{
    # tests for tainted format in s?printf
    eval { printf($TAINT . "# %s\n", "foo") };
    like($@@, qr/^Insecure dependency in printf/, q/printf doesn't like tainted formats/);
    eval { printf("# %s\n", $TAINT . "foo") };
    ok(!$@@, q/printf accepts other tainted args/);
    eval { sprintf($TAINT . "# %s\n", "foo") };
    like($@@, qr/^Insecure dependency in sprintf/, q/sprintf doesn't like tainted formats/);
    eval { sprintf("# %s\n", $TAINT . "foo") };
    ok(!$@@, q/sprintf accepts other tainted args/);
}

{
    # 40708
    my $n  = 7e9;
    8e9 - $n;

    my $val = $n;
    is ($val, '7000000000', 'Assignment to untainted variable');
    $val = $TAINT;
    $val = $n;
    is ($val, '7000000000', 'Assignment to tainted variable');
}

{
    my $val = 0;
    my $tainted = '1' . $TAINT;
    eval '$val = eval $tainted;';
    is ($val, 0, "eval doesn't like tainted strings");
    like ($@@, qr/^Insecure dependency in eval/);

    # Rather nice code to get a tainted undef by from Rick Delaney
    open FH, "test.pl" or die $!;
    seek FH, 0, 2 or die $!;
    $tainted = <FH>;

    eval 'eval $tainted';
    like ($@@, qr/^Insecure dependency in eval/);
}

foreach my $ord (78, 163, 256) {
    # 47195
    my $line = 'A1' . $TAINT . chr $ord;
    chop $line;
    is($line, 'A1');
    $line =~ /(A\S*)/;
    ok(!tainted($1), "\\S match with chr $ord");
}

# This may bomb out with the alarm signal so keep it last
SKIP: {
    skip "No alarm()"  unless $Config{d_alarm};
    # Test from RT #41831]
    # [PATCH] Bug & fix: hang when using study + taint mode (perl 5.6.1, 5.8.x)

    my $DATA = <<'END' . $TAINT;
line1 is here
line2 is here
line3 is here
line4 is here

END

    #study $DATA;

    ## don't set $SIG{ALRM}, since we'd never get to a user-level handler as
    ## perl is stuck in a regexp infinite loop!

    alarm(10);

    if ($DATA =~ /^line2.*line4/m) {
	fail("Should not be a match")
    } else {
	pass("Match on tainted multiline data should fail promptly");
    }

    alarm(0);
}
__END__
# Keep the previous test last
@


1.1.1.11
log
@import perl 5.10.1
@
text
@d20 1
a20 1
plan tests => 301;
d288 1
a288 1
    my $arg = tempfile();
d421 2
a422 1
    my $filename = tempfile();	# NB: $filename isn't tainted!
d509 2
a510 1
	my $temp = tempfile();
a1254 64
}

{
    # 59998
    sub cr { my $x = crypt($_[0], $_[1]); $x }
    sub co { my $x = ~$_[0]; $x }
    my ($a, $b);
    $a = cr('hello', 'foo' . $TAINT);
    $b = cr('hello', 'foo');
    ok(tainted($a),  "tainted crypt");
    ok(!tainted($b), "untainted crypt");
    $a = co('foo' . $TAINT);
    $b = co('foo');
    ok(tainted($a),  "tainted complement");
    ok(!tainted($b), "untainted complement");
}

{
    my @@data = qw(bonk zam zlonk qunckkk);
    # Clearly some sort of usenet bang-path
    my $string = $TAINT . join "!", @@data;

    ok(tainted($string), "tainted data");

    my @@got = split /!|,/, $string;

    # each @@got would be useful here, but I want the test for earlier perls
    for my $i (0 .. $#data) {
	ok(tainted($got[$i]), "tainted result $i");
	is($got[$i], $data[$i], "correct content $i");
    }

    ok(tainted($string), "still tainted data");

    my @@got = split /[!,]/, $string;

    # each @@got would be useful here, but I want the test for earlier perls
    for my $i (0 .. $#data) {
	ok(tainted($got[$i]), "tainted result $i");
	is($got[$i], $data[$i], "correct content $i");
    }

    ok(tainted($string), "still tainted data");

    my @@got = split /!/, $string;

    # each @@got would be useful here, but I want the test for earlier perls
    for my $i (0 .. $#data) {
	ok(tainted($got[$i]), "tainted result $i");
	is($got[$i], $data[$i], "correct content $i");
    }
}

# Bug RT #52552 - broken by change at git commit id f337b08
{
    my $x = $TAINT. q{print "Hello world\n"};
    my $y = pack "a*", $x;
    ok(tainted($y), "pack a* preserves tainting");

    my $z = pack "A*", q{print "Hello world\n"}.$TAINT;
    ok(tainted($z), "pack A* preserves tainting");

    my $zz = pack "a*a*", q{print "Hello world\n"}, $TAINT;
    ok(tainted($zz), "pack a*a* preserves tainting");
@


1.1.1.12
log
@Perl 5.12.2 from CPAN
@
text
@d20 1
a20 1
plan tests => 302;
d45 1
d54 2
a55 1
                  $Is_NetWare  ? 'perl'                 :
d137 1
a137 1
my $ECHO = ($Is_MSWin32 ? ".\\echo$$" : ($Is_NetWare ? "echo$$" : "./echo$$"));
d176 1
a176 1
          if $Is_MSWin32 || $Is_NetWare || $Is_VMS || $Is_Dos;
d433 2
a434 1
	($Is_Dos && $! == 22);
d631 1
d976 9
a984 5
    eval {
	no warnings;
	exec("lskdfj does not exist","with","args"); 
    };
    test !$@@;
a1317 11

# Bug RT #61976 tainted $! would show numeric rather than string value

{
    my $tainted_path = substr($^X,0,0) . "/no/such/file";
    my $err;
    # $! is used in a tainted expression, so gets tainted
    open my $fh, $tainted_path or $err= "$!";
    unlike($err, qr/^\d+$/, 'tainted $!');
}

@


1.1.1.13
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@a12 2
    require './test.pl';
    skip_all_if_miniperl("no dynamic loading on miniperl, no re");
d17 1
d19 2
a20 1
plan tests => 794;
a50 1
my $Is_MirBSD   = $^O eq 'mirbsd';
d99 3
d103 5
a107 2
    local $@@;   # Don't pollute caller's value.
    not eval { join("",@@_), kill 0; 1 };
d110 22
a131 18
sub is_tainted {
    my $thing = shift;
    local $::Level = $::Level + 1;
    ok(tainted($thing), @@_);
}

sub isnt_tainted {
    my $thing = shift;
    local $::Level = $::Level + 1;
    ok(!tainted($thing), @@_);
}

sub violates_taint {
    my ($code, $what, $desc) = @@_;
    $desc //= $what;
    local $::Level = $::Level + 1;
    is(eval { $code->(); }, undef, $desc);
    like($@@, qr/^Insecure dependency in $what while running with -T switch/);
d137 3
a139 3
open my $fh, '>', $ECHO or die "Can't create $ECHO: $!";
print $fh 'print "@@ARGV\n"', "\n";
close $fh;
d142 1
a142 1
my $TEST = 'TEST';
d150 16
d170 1
a170 1
    is(eval { `$echo 1` }, "1\n");
d183 1
a183 1
	is("@@vars", "");
d188 1
a188 1
	is(eval { `$echo 1` }, "1\n");
d190 2
a191 2
	is(eval { `$echo 1` }, undef);
	like($@@, qr/^Insecure \$ENV{TERM}/);
d209 2
a210 2
	is(eval { `$echo 1` }, undef);
	like($@@, qr/^Insecure directory in \$ENV{PATH}/);
d217 2
a218 2
	is(eval { `$echo 1` }, undef);
	like($@@, qr/^Insecure \$ENV{DCL\$PATH}/);
d224 2
a225 2
	    is(eval { `$echo 1` }, undef);
	    like($@@, qr/^Insecure directory in \$ENV{DCL\$PATH}/);
d234 1
a234 1
    is_tainted($foo);
d240 1
a240 1
    isnt_tainted($foo);
d243 1
a243 1
    is_tainted($foo);
d246 1
a246 1
    isnt_tainted($_) foreach @@list;
d248 3
a250 2
    is_tainted($_) foreach @@list[1,3,5,7,9];
    isnt_tainted($_) foreach @@list[0,2,4,6,8];
d253 1
a253 1
    isnt_tainted($foo);
d255 3
a257 352
    my ($desc, $s, $res, $res2, $one);

    $desc = "match with string tainted";

    $s = 'abcd' . $TAINT;
    $res = $s =~ /(.+)/;
    $one = $1;
    is_tainted($s,     "$desc: s tainted");
    isnt_tainted($res, "$desc: res not tainted");
    isnt_tainted($one, "$desc: \$1 not tainted");
    is($res, 1,        "$desc: res value");
    is($one, 'abcd',   "$desc: \$1 value");

    $desc = "match /g with string tainted";

    $s = 'abcd' . $TAINT;
    $res = $s =~ /(.)/g;
    $one = $1;
    is_tainted($s,     "$desc: s tainted");
    isnt_tainted($res, "$desc: res not tainted");
    isnt_tainted($one, "$desc: \$1 not tainted");
    is($res, 1,        "$desc: res value");
    is($one, 'a',      "$desc: \$1 value");

    $desc = "match with string tainted, list cxt";

    $s = 'abcd' . $TAINT;
    ($res) = $s =~ /(.+)/;
    $one = $1;
    is_tainted($s,     "$desc: s tainted");
    isnt_tainted($res, "$desc: res not tainted");
    isnt_tainted($one, "$desc: \$1 not tainted");
    is($res, 'abcd',   "$desc: res value");
    is($one, 'abcd',   "$desc: \$1 value");

    $desc = "match /g with string tainted, list cxt";

    $s = 'abcd' . $TAINT;
    ($res, $res2) = $s =~ /(.)/g;
    $one = $1;
    is_tainted($s,     "$desc: s tainted");
    isnt_tainted($res, "$desc: res not tainted");
    isnt_tainted($res2,"$desc: res2 not tainted");
    isnt_tainted($one, "$desc: \$1 not tainted");
    is($res, 'a',      "$desc: res value");
    is($res2,'b',      "$desc: res2 value");
    is($one, 'd',      "$desc: \$1 value");

    $desc = "match with pattern tainted";

    $s = 'abcd';
    $res = $s =~ /$TAINT(.+)/;
    $one = $1;
    isnt_tainted($s,   "$desc: s not tainted");
    isnt_tainted($res, "$desc: res not tainted");
    is_tainted($one,   "$desc: \$1 tainted");
    is($res, 1,        "$desc: res value");
    is($one, 'abcd',   "$desc: \$1 value");

    $desc = "match /g with pattern tainted";

    $s = 'abcd';
    $res = $s =~ /$TAINT(.)/g;
    $one = $1;
    isnt_tainted($s,   "$desc: s not tainted");
    isnt_tainted($res, "$desc: res not tainted");
    is_tainted($one,   "$desc: \$1 tainted");
    is($res, 1,        "$desc: res value");
    is($one, 'a',      "$desc: \$1 value");

    $desc = "match with pattern tainted via locale";

    $s = 'abcd';
    { use locale; $res = $s =~ /(\w+)/; $one = $1; }
    isnt_tainted($s,   "$desc: s not tainted");
    isnt_tainted($res, "$desc: res not tainted");
    is_tainted($one,   "$desc: \$1 tainted");
    is($res, 1,        "$desc: res value");
    is($one, 'abcd',   "$desc: \$1 value");

    $desc = "match /g with pattern tainted via locale";

    $s = 'abcd';
    { use locale; $res = $s =~ /(\w)/g; $one = $1; }
    isnt_tainted($s,   "$desc: s not tainted");
    isnt_tainted($res, "$desc: res not tainted");
    is_tainted($one,   "$desc: \$1 tainted");
    is($res, 1,        "$desc: res value");
    is($one, 'a',      "$desc: \$1 value");

    $desc = "match with pattern tainted, list cxt";

    $s = 'abcd';
    ($res) = $s =~ /$TAINT(.+)/;
    $one = $1;
    isnt_tainted($s,   "$desc: s not tainted");
    is_tainted($res,   "$desc: res tainted");
    is_tainted($one,   "$desc: \$1 tainted");
    is($res, 'abcd',   "$desc: res value");
    is($one, 'abcd',   "$desc: \$1 value");

    $desc = "match /g with pattern tainted, list cxt";

    $s = 'abcd';
    ($res, $res2) = $s =~ /$TAINT(.)/g;
    $one = $1;
    isnt_tainted($s,   "$desc: s not tainted");
    is_tainted($res,   "$desc: res tainted");
    is_tainted($one,   "$desc: \$1 tainted");
    is($res, 'a',      "$desc: res value");
    is($res2,'b',      "$desc: res2 value");
    is($one, 'd',      "$desc: \$1 value");

    $desc = "match with pattern tainted via locale, list cxt";

    $s = 'abcd';
    { use locale; ($res) = $s =~ /(\w+)/; $one = $1; }
    isnt_tainted($s,   "$desc: s not tainted");
    is_tainted($res,   "$desc: res tainted");
    is_tainted($one,   "$desc: \$1 tainted");
    is($res, 'abcd',   "$desc: res value");
    is($one, 'abcd',   "$desc: \$1 value");

    $desc = "match /g with pattern tainted via locale, list cxt";

    $s = 'abcd';
    { use locale; ($res, $res2) = $s =~ /(\w)/g; $one = $1; }
    isnt_tainted($s,   "$desc: s not tainted");
    is_tainted($res,   "$desc: res tainted");
    is_tainted($res2,  "$desc: res2 tainted");
    is_tainted($one,   "$desc: \$1 tainted");
    is($res, 'a',      "$desc: res value");
    is($res2,'b',      "$desc: res2 value");
    is($one, 'd',      "$desc: \$1 value");

    $desc = "substitution with string tainted";

    $s = 'abcd' . $TAINT;
    $res = $s =~ s/(.+)/xyz/;
    $one = $1;
    is_tainted($s,     "$desc: s tainted");
    isnt_tainted($res, "$desc: res not tainted");
    isnt_tainted($one, "$desc: \$1 not tainted");
    is($s,   'xyz',    "$desc: s value");
    is($res, 1,        "$desc: res value");
    is($one, 'abcd',   "$desc: \$1 value");

    $desc = "substitution /g with string tainted";

    $s = 'abcd' . $TAINT;
    $res = $s =~ s/(.)/x/g;
    $one = $1;
    is_tainted($s,     "$desc: s tainted");
    is_tainted($res,   "$desc: res tainted");
    isnt_tainted($one, "$desc: \$1 not tainted");
    is($s,   'xxxx',   "$desc: s value");
    is($res, 4,        "$desc: res value");
    is($one, 'd',      "$desc: \$1 value");

    $desc = "substitution /r with string tainted";

    $s = 'abcd' . $TAINT;
    $res = $s =~ s/(.+)/xyz/r;
    $one = $1;
    is_tainted($s,     "$desc: s tainted");
    is_tainted($res,   "$desc: res tainted");
    isnt_tainted($one, "$desc: \$1 not tainted");
    is($s,   'abcd',   "$desc: s value");
    is($res, 'xyz',    "$desc: res value");
    is($one, 'abcd',   "$desc: \$1 value");

    $desc = "substitution /e with string tainted";

    $s = 'abcd' . $TAINT;
    $one = '';
    $res = $s =~ s{(.+)}{
		$one = $one . "x"; # make sure code not tainted
		isnt_tainted($one, "$desc: code not tainted within /e");
		$one = $1;
		isnt_tainted($one, "$desc: \$1 not tainted within /e");
		"xyz";
	    }e;
    $one = $1;
    is_tainted($s,     "$desc: s tainted");
    isnt_tainted($res, "$desc: res not tainted");
    isnt_tainted($one, "$desc: \$1 not tainted");
    is($s,   'xyz',    "$desc: s value");
    is($res, 1,        "$desc: res value");
    is($one, 'abcd',   "$desc: \$1 value");

    $desc = "substitution with pattern tainted";

    $s = 'abcd';
    $res = $s =~ s/$TAINT(.+)/xyz/;
    $one = $1;
    is_tainted($s,     "$desc: s tainted");
    isnt_tainted($res, "$desc: res not tainted");
    is_tainted($one,   "$desc: \$1 tainted");
    is($s,  'xyz',     "$desc: s value");
    is($res, 1,        "$desc: res value");
    is($one, 'abcd',   "$desc: \$1 value");

    $desc = "substitution /g with pattern tainted";

    $s = 'abcd';
    $res = $s =~ s/$TAINT(.)/x/g;
    $one = $1;
    is_tainted($s,     "$desc: s tainted");
    is_tainted($res,   "$desc: res tainted");
    is_tainted($one,   "$desc: \$1 tainted");
    is($s,  'xxxx',    "$desc: s value");
    is($res, 4,        "$desc: res value");
    is($one, 'd',      "$desc: \$1 value");

    $desc = "substitution /ge with pattern tainted";

    $s = 'abc';
    {
	my $i = 0;
	my $j;
	$res = $s =~ s{(.)$TAINT}{
		    $j = $i; # make sure code not tainted
		    $one = $1;
		    isnt_tainted($j, "$desc: code not tainted within /e");
		    $i++;
		    if ($i == 1) {
			isnt_tainted($s,   "$desc: s not tainted loop 1");
		    }
		    else {
			is_tainted($s,     "$desc: s tainted loop $i");
		    }
		    is_tainted($one,   "$desc: \$1 tainted loop $i");
		    $i.$TAINT;
		}ge;
	$one = $1;
    }
    is_tainted($s,     "$desc: s tainted");
    is_tainted($res,   "$desc: res tainted");
    is_tainted($one,   "$desc: \$1 tainted");
    is($s,  '123',     "$desc: s value");
    is($res, 3,        "$desc: res value");
    is($one, 'c',      "$desc: \$1 value");

    $desc = "substitution /r with pattern tainted";

    $s = 'abcd';
    $res = $s =~ s/$TAINT(.+)/xyz/r;
    $one = $1;
    isnt_tainted($s,   "$desc: s not tainted");
    is_tainted($res,   "$desc: res tainted");
    is_tainted($one,   "$desc: \$1 tainted");
    is($s,  'abcd',    "$desc: s value");
    is($res, 'xyz',    "$desc: res value");
    is($one, 'abcd',   "$desc: \$1 value");

    $desc = "substitution with pattern tainted via locale";

    $s = 'abcd';
    { use locale;  $res = $s =~ s/(\w+)/xyz/; $one = $1; }
    is_tainted($s,     "$desc: s tainted");
    isnt_tainted($res, "$desc: res not tainted");
    is_tainted($one,   "$desc: \$1 tainted");
    is($s,  'xyz',     "$desc: s value");
    is($res, 1,        "$desc: res value");
    is($one, 'abcd',   "$desc: \$1 value");

    $desc = "substitution /g with pattern tainted via locale";

    $s = 'abcd';
    { use locale;  $res = $s =~ s/(\w)/x/g; $one = $1; }
    is_tainted($s,     "$desc: s tainted");
    is_tainted($res,   "$desc: res tainted");
    is_tainted($one,   "$desc: \$1 tainted");
    is($s,  'xxxx',    "$desc: s value");
    is($res, 4,        "$desc: res value");
    is($one, 'd',      "$desc: \$1 value");

    $desc = "substitution /r with pattern tainted via locale";

    $s = 'abcd';
    { use locale;  $res = $s =~ s/(\w+)/xyz/r; $one = $1; }
    isnt_tainted($s,   "$desc: s not tainted");
    is_tainted($res,   "$desc: res tainted");
    is_tainted($one,   "$desc: \$1 tainted");
    is($s,  'abcd',    "$desc: s value");
    is($res, 'xyz',    "$desc: res value");
    is($one, 'abcd',   "$desc: \$1 value");

    $desc = "substitution with replacement tainted";

    $s = 'abcd';
    $res = $s =~ s/(.+)/xyz$TAINT/;
    $one = $1;
    is_tainted($s,     "$desc: s tainted");
    isnt_tainted($res, "$desc: res not tainted");
    isnt_tainted($one, "$desc: \$1 not tainted");
    is($s,  'xyz',     "$desc: s value");
    is($res, 1,        "$desc: res value");
    is($one, 'abcd',   "$desc: \$1 value");

    $desc = "substitution /g with replacement tainted";

    $s = 'abcd';
    $res = $s =~ s/(.)/x$TAINT/g;
    $one = $1;
    is_tainted($s,     "$desc: s tainted");
    isnt_tainted($res, "$desc: res not tainted");
    isnt_tainted($one, "$desc: \$1 not tainted");
    is($s,  'xxxx',    "$desc: s value");
    is($res, 4,        "$desc: res value");
    is($one, 'd',      "$desc: \$1 value");

    $desc = "substitution /ge with replacement tainted";

    $s = 'abc';
    {
	my $i = 0;
	my $j;
	$res = $s =~ s{(.)}{
		    $j = $i; # make sure code not tainted
		    $one = $1;
		    isnt_tainted($j, "$desc: code not tainted within /e");
		    $i++;
		    if ($i == 1) {
			isnt_tainted($s,   "$desc: s not tainted loop 1");
		    }
		    else {
			is_tainted($s,     "$desc: s tainted loop $i");
		    }
		    isnt_tainted($one, "$desc: \$1 not tainted within /e");
		    $i.$TAINT;
		}ge;
	$one = $1;
    }
    is_tainted($s,     "$desc: s tainted");
    is_tainted($res,   "$desc: res tainted");
    isnt_tainted($one, "$desc: \$1 not tainted");
    is($s,  '123',     "$desc: s value");
    is($res, 3,        "$desc: res value");
    is($one, 'c',      "$desc: \$1 value");

    $desc = "substitution /r with replacement tainted";

    $s = 'abcd';
    $res = $s =~ s/(.+)/xyz$TAINT/r;
    $one = $1;
    isnt_tainted($s,   "$desc: s not tainted");
    is_tainted($res,   "$desc: res tainted");
    isnt_tainted($one, "$desc: \$1 not tainted");
    is($s,   'abcd',   "$desc: s value");
    is($res, 'xyz',    "$desc: res value");
    is($one, 'abcd',   "$desc: \$1 value");
d260 1
a260 1
	# now do them all again with "use re 'taint"
d262 7
a268 353
	use re 'taint';

	$desc = "use re 'taint': match with string tainted";

	$s = 'abcd' . $TAINT;
	$res = $s =~ /(.+)/;
	$one = $1;
	is_tainted($s,     "$desc: s tainted");
	isnt_tainted($res, "$desc: res not tainted");
	is_tainted($one,   "$desc: \$1 tainted");
	is($res, 1,        "$desc: res value");
	is($one, 'abcd',   "$desc: \$1 value");

	$desc = "use re 'taint': match /g with string tainted";

	$s = 'abcd' . $TAINT;
	$res = $s =~ /(.)/g;
	$one = $1;
	is_tainted($s,     "$desc: s tainted");
	isnt_tainted($res, "$desc: res not tainted");
	is_tainted($one,   "$desc: \$1 tainted");
	is($res, 1,        "$desc: res value");
	is($one, 'a',      "$desc: \$1 value");

	$desc = "use re 'taint': match with string tainted, list cxt";

	$s = 'abcd' . $TAINT;
	($res) = $s =~ /(.+)/;
	$one = $1;
	is_tainted($s,     "$desc: s tainted");
	is_tainted($res,   "$desc: res tainted");
	is_tainted($one,   "$desc: \$1 tainted");
	is($res, 'abcd',   "$desc: res value");
	is($one, 'abcd',   "$desc: \$1 value");

	$desc = "use re 'taint': match /g with string tainted, list cxt";

	$s = 'abcd' . $TAINT;
	($res, $res2) = $s =~ /(.)/g;
	$one = $1;
	is_tainted($s,     "$desc: s tainted");
	is_tainted($res,   "$desc: res tainted");
	is_tainted($res2,  "$desc: res2 tainted");
	is_tainted($one,   "$desc: \$1 not tainted");
	is($res, 'a',      "$desc: res value");
	is($res2,'b',      "$desc: res2 value");
	is($one, 'd',      "$desc: \$1 value");

	$desc = "use re 'taint': match with pattern tainted";

	$s = 'abcd';
	$res = $s =~ /$TAINT(.+)/;
	$one = $1;
	isnt_tainted($s,   "$desc: s not tainted");
	isnt_tainted($res, "$desc: res not tainted");
	is_tainted($one,   "$desc: \$1 tainted");
	is($res, 1,        "$desc: res value");
	is($one, 'abcd',   "$desc: \$1 value");

	$desc = "use re 'taint': match /g with pattern tainted";

	$s = 'abcd';
	$res = $s =~ /$TAINT(.)/g;
	$one = $1;
	isnt_tainted($s,   "$desc: s not tainted");
	isnt_tainted($res, "$desc: res not tainted");
	is_tainted($one,   "$desc: \$1 tainted");
	is($res, 1,        "$desc: res value");
	is($one, 'a',      "$desc: \$1 value");

	$desc = "use re 'taint': match with pattern tainted via locale";

	$s = 'abcd';
	{ use locale; $res = $s =~ /(\w+)/; $one = $1; }
	isnt_tainted($s,   "$desc: s not tainted");
	isnt_tainted($res, "$desc: res not tainted");
	is_tainted($one,   "$desc: \$1 tainted");
	is($res, 1,        "$desc: res value");
	is($one, 'abcd',   "$desc: \$1 value");

	$desc = "use re 'taint': match /g with pattern tainted via locale";

	$s = 'abcd';
	{ use locale; $res = $s =~ /(\w)/g; $one = $1; }
	isnt_tainted($s,   "$desc: s not tainted");
	isnt_tainted($res, "$desc: res not tainted");
	is_tainted($one,   "$desc: \$1 tainted");
	is($res, 1,        "$desc: res value");
	is($one, 'a',      "$desc: \$1 value");

	$desc = "use re 'taint': match with pattern tainted, list cxt";

	$s = 'abcd';
	($res) = $s =~ /$TAINT(.+)/;
	$one = $1;
	isnt_tainted($s,   "$desc: s not tainted");
	is_tainted($res,   "$desc: res tainted");
	is_tainted($one,   "$desc: \$1 tainted");
	is($res, 'abcd',   "$desc: res value");
	is($one, 'abcd',   "$desc: \$1 value");

	$desc = "use re 'taint': match /g with pattern tainted, list cxt";

	$s = 'abcd';
	($res, $res2) = $s =~ /$TAINT(.)/g;
	$one = $1;
	isnt_tainted($s,   "$desc: s not tainted");
	is_tainted($res,   "$desc: res tainted");
	is_tainted($one,   "$desc: \$1 tainted");
	is($res, 'a',      "$desc: res value");
	is($res2,'b',      "$desc: res2 value");
	is($one, 'd',      "$desc: \$1 value");

	$desc = "use re 'taint': match with pattern tainted via locale, list cxt";

	$s = 'abcd';
	{ use locale; ($res) = $s =~ /(\w+)/; $one = $1; }
	isnt_tainted($s,   "$desc: s not tainted");
	is_tainted($res,   "$desc: res tainted");
	is_tainted($one,   "$desc: \$1 tainted");
	is($res, 'abcd',   "$desc: res value");
	is($one, 'abcd',   "$desc: \$1 value");

	$desc = "use re 'taint': match /g with pattern tainted via locale, list cxt";

	$s = 'abcd';
	{ use locale; ($res, $res2) = $s =~ /(\w)/g; $one = $1; }
	isnt_tainted($s,   "$desc: s not tainted");
	is_tainted($res,   "$desc: res tainted");
	is_tainted($res2,  "$desc: res2 tainted");
	is_tainted($one,   "$desc: \$1 tainted");
	is($res, 'a',      "$desc: res value");
	is($res2,'b',      "$desc: res2 value");
	is($one, 'd',      "$desc: \$1 value");

	$desc = "use re 'taint': substitution with string tainted";

	$s = 'abcd' . $TAINT;
	$res = $s =~ s/(.+)/xyz/;
	$one = $1;
	is_tainted($s,     "$desc: s tainted");
	isnt_tainted($res, "$desc: res not tainted");
	is_tainted($one,   "$desc: \$1 tainted");
	is($s,   'xyz',    "$desc: s value");
	is($res, 1,        "$desc: res value");
	is($one, 'abcd',   "$desc: \$1 value");

	$desc = "use re 'taint': substitution /g with string tainted";

	$s = 'abcd' . $TAINT;
	$res = $s =~ s/(.)/x/g;
	$one = $1;
	is_tainted($s,     "$desc: s tainted");
	is_tainted($res,   "$desc: res tainted");
	is_tainted($one,   "$desc: \$1 tainted");
	is($s,   'xxxx',   "$desc: s value");
	is($res, 4,        "$desc: res value");
	is($one, 'd',      "$desc: \$1 value");

	$desc = "use re 'taint': substitution /r with string tainted";

	$s = 'abcd' . $TAINT;
	$res = $s =~ s/(.+)/xyz/r;
	$one = $1;
	is_tainted($s,     "$desc: s tainted");
	is_tainted($res,   "$desc: res tainted");
	is_tainted($one,   "$desc: \$1 tainted");
	is($s,   'abcd',   "$desc: s value");
	is($res, 'xyz',    "$desc: res value");
	is($one, 'abcd',   "$desc: \$1 value");

	$desc = "use re 'taint': substitution /e with string tainted";

	$s = 'abcd' . $TAINT;
	$one = '';
	$res = $s =~ s{(.+)}{
		    $one = $one . "x"; # make sure code not tainted
		    isnt_tainted($one, "$desc: code not tainted within /e");
		    $one = $1;
		    is_tainted($one, "$desc: $1 tainted within /e");
		    "xyz";
		}e;
	$one = $1;
	is_tainted($s,     "$desc: s tainted");
	isnt_tainted($res, "$desc: res not tainted");
	is_tainted($one,   "$desc: \$1 tainted");
	is($s,   'xyz',    "$desc: s value");
	is($res, 1,        "$desc: res value");
	is($one, 'abcd',   "$desc: \$1 value");

	$desc = "use re 'taint': substitution with pattern tainted";

	$s = 'abcd';
	$res = $s =~ s/$TAINT(.+)/xyz/;
	$one = $1;
	is_tainted($s,     "$desc: s tainted");
	isnt_tainted($res, "$desc: res not tainted");
	is_tainted($one,   "$desc: \$1 tainted");
	is($s,  'xyz',     "$desc: s value");
	is($res, 1,        "$desc: res value");
	is($one, 'abcd',   "$desc: \$1 value");

	$desc = "use re 'taint': substitution /g with pattern tainted";

	$s = 'abcd';
	$res = $s =~ s/$TAINT(.)/x/g;
	$one = $1;
	is_tainted($s,     "$desc: s tainted");
	is_tainted($res,   "$desc: res tainted");
	is_tainted($one,   "$desc: \$1 tainted");
	is($s,  'xxxx',    "$desc: s value");
	is($res, 4,        "$desc: res value");
	is($one, 'd',      "$desc: \$1 value");

	$desc = "use re 'taint': substitution /ge with pattern tainted";

	$s = 'abc';
	{
	    my $i = 0;
	    my $j;
	    $res = $s =~ s{(.)$TAINT}{
			$j = $i; # make sure code not tainted
			$one = $1;
			isnt_tainted($j, "$desc: code not tainted within /e");
			$i++;
			if ($i == 1) {
			    isnt_tainted($s,   "$desc: s not tainted loop 1");
			}
			else {
			    is_tainted($s,     "$desc: s tainted loop $i");
			}
			is_tainted($one,   "$desc: \$1 tainted loop $i");
			$i.$TAINT;
		    }ge;
	    $one = $1;
	}
	is_tainted($s,     "$desc: s tainted");
	is_tainted($res,   "$desc: res tainted");
	is_tainted($one,   "$desc: \$1 tainted");
	is($s,  '123',     "$desc: s value");
	is($res, 3,        "$desc: res value");
	is($one, 'c',      "$desc: \$1 value");


	$desc = "use re 'taint': substitution /r with pattern tainted";

	$s = 'abcd';
	$res = $s =~ s/$TAINT(.+)/xyz/r;
	$one = $1;
	isnt_tainted($s,   "$desc: s not tainted");
	is_tainted($res,   "$desc: res tainted");
	is_tainted($one,   "$desc: \$1 tainted");
	is($s,  'abcd',    "$desc: s value");
	is($res, 'xyz',    "$desc: res value");
	is($one, 'abcd',   "$desc: \$1 value");

	$desc = "use re 'taint': substitution with pattern tainted via locale";

	$s = 'abcd';
	{ use locale;  $res = $s =~ s/(\w+)/xyz/; $one = $1; }
	is_tainted($s,     "$desc: s tainted");
	isnt_tainted($res, "$desc: res not tainted");
	is_tainted($one,   "$desc: \$1 tainted");
	is($s,  'xyz',     "$desc: s value");
	is($res, 1,        "$desc: res value");
	is($one, 'abcd',   "$desc: \$1 value");

	$desc = "use re 'taint': substitution /g with pattern tainted via locale";

	$s = 'abcd';
	{ use locale;  $res = $s =~ s/(\w)/x/g; $one = $1; }
	is_tainted($s,     "$desc: s tainted");
	is_tainted($res,   "$desc: res tainted");
	is_tainted($one,   "$desc: \$1 tainted");
	is($s,  'xxxx',    "$desc: s value");
	is($res, 4,        "$desc: res value");
	is($one, 'd',      "$desc: \$1 value");

	$desc = "use re 'taint': substitution /r with pattern tainted via locale";

	$s = 'abcd';
	{ use locale;  $res = $s =~ s/(\w+)/xyz/r; $one = $1; }
	isnt_tainted($s,   "$desc: s not tainted");
	is_tainted($res,   "$desc: res tainted");
	is_tainted($one,   "$desc: \$1 tainted");
	is($s,  'abcd',    "$desc: s value");
	is($res, 'xyz',    "$desc: res value");
	is($one, 'abcd',   "$desc: \$1 value");

	$desc = "use re 'taint': substitution with replacement tainted";

	$s = 'abcd';
	$res = $s =~ s/(.+)/xyz$TAINT/;
	$one = $1;
	is_tainted($s,     "$desc: s tainted");
	isnt_tainted($res, "$desc: res not tainted");
	isnt_tainted($one, "$desc: \$1 not tainted");
	is($s,  'xyz',     "$desc: s value");
	is($res, 1,        "$desc: res value");
	is($one, 'abcd',   "$desc: \$1 value");

	$desc = "use re 'taint': substitution /g with replacement tainted";

	$s = 'abcd';
	$res = $s =~ s/(.)/x$TAINT/g;
	$one = $1;
	is_tainted($s,     "$desc: s tainted");
	isnt_tainted($res, "$desc: res not tainted");
	isnt_tainted($one, "$desc: \$1 not tainted");
	is($s,  'xxxx',    "$desc: s value");
	is($res, 4,        "$desc: res value");
	is($one, 'd',      "$desc: \$1 value");

	$desc = "use re 'taint': substitution /ge with replacement tainted";

	$s = 'abc';
	{
	    my $i = 0;
	    my $j;
	    $res = $s =~ s{(.)}{
			$j = $i; # make sure code not tainted
			$one = $1;
			isnt_tainted($j, "$desc: code not tainted within /e");
			$i++;
			if ($i == 1) {
			    isnt_tainted($s,   "$desc: s not tainted loop 1");
			}
			else {
			    is_tainted($s,     "$desc: s tainted loop $i");
			}
			    isnt_tainted($one, "$desc: \$1 not tainted");
			$i.$TAINT;
		    }ge;
	    $one = $1;
	}
	is_tainted($s,     "$desc: s tainted");
	is_tainted($res,   "$desc: res tainted");
	isnt_tainted($one, "$desc: \$1 not tainted");
	is($s,  '123',     "$desc: s value");
	is($res, 3,        "$desc: res value");
	is($one, 'c',      "$desc: \$1 value");

	$desc = "use re 'taint': substitution /r with replacement tainted";

	$s = 'abcd';
	$res = $s =~ s/(.+)/xyz$TAINT/r;
	$one = $1;
	isnt_tainted($s,   "$desc: s not tainted");
	is_tainted($res,   "$desc: res tainted");
	isnt_tainted($one, "$desc: \$1 not tainted");
	is($s,   'abcd',   "$desc: s value");
	is($res, 'xyz',    "$desc: res value");
	is($one, 'abcd',   "$desc: \$1 value");
d272 2
a273 2
    is_tainted($foo);
    is($foo, 'bar');
d276 1
a276 1
    is_tainted($pi);
d279 2
a280 2
    isnt_tainted($pi);
    is(sprintf("%.5f", $pi), '3.14159');
d287 2
a288 2
    open $fh, '>', $arg or die "Can't create $arg: $!";
    print $fh q{
d294 1
a294 1
    close $fh or die "Can't close $arg: $!";
d296 1
a296 1
    is($?, 0, "Exited with status $?");
d302 1
a302 1
    ok(open my $fh, '<', $TEST) or diag("Couldn't open '$TEST': $!");
d305 17
a321 5
    sysread($fh, $block, 100);
    my $line = <$fh>;
    close $fh;
    is_tainted($block);
    is_tainted($line);
d327 1
a327 1
    is_tainted($foo);
d332 1
a332 2
    is_tainted($^X);
    is_tainted($0);
d338 1
a338 1
    is_tainted($foo);
d341 1
a341 3
    isnt_tainted($`);
    isnt_tainted($&);
    isnt_tainted($');
d344 1
a344 4
    isnt_tainted($1);
    isnt_tainted($2);
    isnt_tainted($3);
    isnt_tainted($+);
d347 1
a347 1
    isnt_tainted($_) foreach @@bar;
d349 2
a350 2
    is_tainted($foo);	# $foo should still be tainted!
    is($foo, "abcdefghi");
d355 2
a356 1
    violates_taint(sub { chmod 0, $TAINT }, 'chmod');
d358 7
a364 2
    SKIP: {
        skip "truncate() is not available", 2 unless $Config{d_truncate};
d366 2
a367 2
	violates_taint(sub { truncate 'NoSuChFiLe', $TAINT0 }, 'truncate');
    }
d369 2
a370 3
    violates_taint(sub { rename '', $TAINT }, 'rename');
    violates_taint(sub { unlink $TAINT }, 'unlink');
    violates_taint(sub { utime $TAINT }, 'utime');
d375 2
a376 1
	violates_taint(sub { chown -1, -1, $TAINT }, 'chown');
d382 2
a383 1
violates_taint(sub { link $TAINT, '' }, 'link');
d389 2
a390 1
	violates_taint(sub { symlink $TAINT, '' }, 'symlink');
d396 8
a403 3
    violates_taint(sub { mkdir "foo".$TAINT, 0755 . $TAINT0 }, 'mkdir');
    violates_taint(sub { rmdir $TAINT }, 'rmdir');
    violates_taint(sub { chdir "foo".$TAINT }, 'chdir');
d408 2
a409 1
	violates_taint(sub { chroot $TAINT }, 'chroot');
d416 2
a417 1
    violates_taint(sub { require $foo }, 'require');
d423 2
a424 4
    is(eval { open FOO, $foo }, undef, 'open for read');
    is($@@, '');                # NB: This should be allowed
    is(eval { open my $fh, , '<', $foo }, undef, 'open for read');
    is($@@, '');                # NB: This should be allowed
d429 1
a429 1
    ok(eval('$!{ENOENT}') ||
d431 1
a431 1
	($Is_Dos && $! == 22));
d433 2
a434 2
    violates_taint(sub { open FOO, "> $foo" }, 'open', 'open for write');
    violates_taint(sub { open my $fh, '>', $foo }, 'open', 'open for write');
d442 4
a445 1
        skip "open('|') is not available", 8 if $^O eq 'amigaos';
d447 2
a448 4
        violates_taint(sub { open FOO, "| x$foo" }, 'piped open', 'popen to');
        violates_taint(sub { open FOO, "x$foo |" }, 'piped open', 'popen from');
        violates_taint(sub { open my $fh, '|-', "x$foo" }, 'piped open', 'popen to');
        violates_taint(sub { open my $fh, '-|', "x$foo" }, 'piped open', 'popen from');
d451 5
a455 2
    violates_taint(sub { exec $TAINT }, 'exec');
    violates_taint(sub { system $TAINT }, 'system');
d460 2
a461 1
    violates_taint(sub { `$echo 1$foo` }, '``', 'backticks');
d467 2
a468 2
	isnt(join('', eval { glob $foo } ), '', 'globbing');
	is($@@, '');
d474 2
a475 1
    violates_taint(sub { kill 0, $TAINT }, 'kill');
d480 2
a481 1
	violates_taint(sub { setpgrp 0, $TAINT0 }, 'setpgrp');
d487 2
a488 1
	violates_taint(sub { setpriority 0, $TAINT0, $TAINT0 }, 'setpriority');
d497 2
a498 1
	violates_taint(sub { syscall $TAINT }, 'syscall');
d506 1
a506 2
	ok(open FOO, "> $temp") or diag("Couldn't open $temp for write: $!");
	violates_taint(sub { ioctl FOO, $TAINT0, $foo }, 'ioctl');
d508 2
a509 3
	my $temp2 = tempfile();
	ok(open my $fh, '>', $temp2) or diag("Couldn't open $temp2 for write: $!");
	violates_taint(sub { ioctl $fh, $TAINT0, $foo }, 'ioctl');
d512 1
a512 1
            skip "fcntl() is not available", 4 unless $Config{d_fcntl};
d514 2
a515 2
	    violates_taint(sub { fcntl FOO, $TAINT0, $foo }, 'fcntl');
	    violates_taint(sub { fcntl $fh, $TAINT0, $foo }, 'fcntl');
d526 3
a528 3
    isnt_tainted($fooref);
    is_tainted($$fooref);
    is_tainted($foo);
d535 14
a548 15
    is_tainted($foo);
    is_tainted($bar);
    is_tainted($foo = $bar);
    is_tainted($bar = $bar);
    is_tainted($bar += $bar);
    is_tainted($bar -= $bar);
    is_tainted($bar *= $bar);
    is_tainted($bar++);
    is_tainted($bar /= $bar);
    is_tainted($bar += 0);
    is_tainted($bar -= 2);
    is_tainted($bar *= -1);
    is_tainted($bar /= 1);
    is_tainted($bar--);
    is($bar, 0);
d554 3
a556 3
    isnt_tainted($foo[0]);
    is_tainted(    $foo[1]);
    isnt_tainted($foo[2]);
d558 3
a560 3
    isnt_tainted($bar[0]);
    is_tainted(    $bar[1]);
    isnt_tainted($bar[2]);
d562 3
a564 3
    isnt_tainted($baz[0]);
    is_tainted(    $baz[1]);
    isnt_tainted($baz[2]);
d566 3
a568 3
    isnt_tainted($plugh[0]);
    is_tainted(    $plugh[1]);
    isnt_tainted($plugh[2]);
d570 3
a572 3
    isnt_tainted(((&$nautilus)[0]));
    is_tainted(    ((&$nautilus)[1]));
    isnt_tainted(((&$nautilus)[2]));
d574 3
a576 3
    isnt_tainted($xyzzy[0]);
    is_tainted(    $xyzzy[1]);
    isnt_tainted($xyzzy[2]);
d578 3
a580 3
    isnt_tainted(((&$red_october)[0]));
    is_tainted(    ((&$red_october)[1]));
    isnt_tainted(((&$red_october)[2]));
d582 3
a584 3
    isnt_tainted($corge[0]);
    is_tainted(    $corge[1]);
    isnt_tainted($corge[2]);
d591 1
a591 1
        skip "getpwent() is not available", 9 unless 
d597 9
a605 9
	isnt_tainted($getpwent[0]);
	is_tainted($getpwent[1]);
	isnt_tainted($getpwent[2]);
	isnt_tainted($getpwent[3]);
	isnt_tainted($getpwent[4]);
	isnt_tainted($getpwent[5]);
	is_tainted($getpwent[6], 'ge?cos');
	isnt_tainted($getpwent[7]);
	is_tainted($getpwent[8], 'shell');
d613 5
a617 4
	opendir my $dh, "op" or die "opendir: $!\n";
	my $readdir = readdir $dh;
	is_tainted($readdir);
	closedir $dh;
d630 1
a630 1
	is_tainted($readlink);
d639 1
a639 1
    isnt_tainted($j);
d642 1
a642 1
    is_tainted(    $j);
d649 1
a649 1
    is_tainted(    $why);
d653 1
a653 1
    is_tainted(    $why);
d656 1
a656 1
    is_tainted(    $why);
d691 1
a691 1
        is_tainted($rcvd);
d726 1
a726 1
	    is_tainted($rcvd);
d734 1
a734 1
    open my $fh, '<', $TEST or warn "$0: cannot read $TEST: $!" ;
d736 4
a739 2
    my $a = <$fh>;
    my $b = <$fh>;
d741 1
a741 3
    is_tainted($a);
    is_tainted($b);
    is($b, undef);
d747 2
a748 2
    open my $fh, '<', $TEST or warn "$0: cannot read $TEST: $!" ;
    my $a = <$fh>;
d753 1
a753 2
    isnt_tainted($c->{a});
    is_tainted($c->{b});
d758 1
a758 2
    is_tainted($d->{a});
    isnt_tainted($d->{b});
d763 6
a768 4
    isnt_tainted($e->{a});
    isnt_tainted($e->{b});
    is_tainted($e->{b}->{c});
    isnt_tainted($e->{b}->{d});
d785 1
a785 5
	my $foo = tempfile();
	my $evil = $foo . $TAINT;

	is(eval { sysopen(my $ro, $evil, &O_RDONLY) }, undef);
	is($@@, '');
d787 55
a841 22
	violates_taint(sub { sysopen(my $wo, $evil, &O_WRONLY) }, 'sysopen');
	violates_taint(sub { sysopen(my $rw, $evil, &O_RDWR) }, 'sysopen');
	violates_taint(sub { sysopen(my $ap, $evil, &O_APPEND) }, 'sysopen');
	violates_taint(sub { sysopen(my $cr, $evil, &O_CREAT) }, 'sysopen');
	violates_taint(sub { sysopen(my $tr, $evil, &O_TRUNC) }, 'sysopen');

	is(eval { sysopen(my $ro, $foo, &O_RDONLY | $TAINT0) }, undef);
	is($@@, '');

	violates_taint(sub { sysopen(my $wo, $foo, &O_WRONLY | $TAINT0) }, 'sysopen');
	violates_taint(sub { sysopen(my $rw, $foo, &O_RDWR | $TAINT0) }, 'sysopen');
	violates_taint(sub { sysopen(my $ap, $foo, &O_APPEND | $TAINT0) }, 'sysopen');
	violates_taint(sub { sysopen(my $cr, $foo, &O_CREAT | $TAINT0) }, 'sysopen');
	violates_taint(sub { sysopen(my $tr, $foo, &O_TRUNC | $TAINT0) }, 'sysopen');
	is(eval { sysopen(my $ro, $foo, &O_RDONLY, $TAINT0) }, undef);
	is($@@, '');

	violates_taint(sub { sysopen(my $wo, $foo, &O_WRONLY, $TAINT0) }, 'sysopen');
	violates_taint(sub { sysopen(my $rw, $foo, &O_RDWR, $TAINT0) }, 'sysopen');
	violates_taint(sub { sysopen(my $ap, $foo, &O_APPEND, $TAINT0) }, 'sysopen');
	violates_taint(sub { sysopen(my $cr, $foo, &O_CREAT, $TAINT0) }, 'sysopen');
	violates_taint(sub { sysopen(my $tr, $foo, &O_TRUNC, $TAINT0) }, 'sysopen');
d851 1
a851 1
    local $SIG{__WARN__} = sub { ++$saw_warning };
d862 1
a862 1
    is($saw_warning, 0);
d905 1
a905 1
    is("@@untainted", "");
d909 1
a909 1
is(${^TAINT}, 1, '$^TAINT is on');
d912 3
a914 3
is(${^TAINT}, 1, '$^TAINT is not assignable');
like($@@, qr/^Modification of a read-only value attempted/,
     'Assigning to ${^TAINT} fails');
d920 1
a920 1
    is_tainted($re1);
d923 1
a923 1
    is_tainted($re2);
d926 1
a926 1
    is_tainted($re3);
d935 1
a935 1
    like($@@, qr/^Insecure \$ENV/);
d943 22
a964 11
    violates_taint(sub { exec $TAINT, $TAINT }, 'exec');
    violates_taint(sub { exec $TAINT $TAINT }, 'exec');
    violates_taint(sub { exec $TAINT $TAINT, $TAINT }, 'exec');
    violates_taint(sub { exec $TAINT 'notaint' }, 'exec');
    violates_taint(sub { exec {'notaint'} $TAINT }, 'exec');

    violates_taint(sub { system $TAINT, $TAINT }, 'system');
    violates_taint(sub { system $TAINT $TAINT }, 'system');
    violates_taint(sub { system $TAINT $TAINT, $TAINT }, 'system');
    violates_taint(sub { system $TAINT 'notaint' }, 'system');
    violates_taint(sub { system {'notaint'} $TAINT }, 'system');
d970 1
a970 1
    is($@@, "");
d976 1
a976 1
    is($@@, "");
d985 1
a985 1
    is_tainted(my $foo = $1);
d993 1
a993 1
    like($@@, qr/^%ENV is aliased to another variable while running with -T switch/);
d996 1
a996 1
    like($@@, qr/^%ENV is aliased to %nonmagicalenv while running with -T switch/);
d1001 1
a1001 1
    isnt_tainted($1);
d1003 1
a1003 1
    isnt_tainted($notaint);
d1008 2
a1009 2
    isnt_tainted($1);
    isnt_tainted($l);
d1012 2
a1013 2
    is_tainted($1);
    is_tainted($l);
d1017 2
a1018 2
    isnt_tainted($1);
    isnt_tainted($l);
d1021 2
a1022 2
    is_tainted($1);
    is_tainted($l);
d1026 1
a1026 1
    isnt_tainted($1);
d1028 1
a1028 1
    is_tainted($1);
d1034 1
a1034 1
    isnt_tainted($^O);
d1036 1
a1036 2
    isnt_tainted($^O);
    local $^O;  # We're going to clobber something test infrastructure depends on.
d1038 1
a1038 1
    like($@@, qr/Insecure dependency in/);
d1043 1
a1043 1
    is_tainted( $tainted_number );
d1047 2
a1048 2
    is_tainted( $tainted_product );
    is($tainted_product, 0);
d1054 2
a1055 2
    is_tainted( $tainted_true );
    is_tainted( $tainted_false );
d1058 2
a1059 2
    is($result, "True");
    isnt_tainted( $result );
d1062 2
a1063 2
    is($result, "False");
    isnt_tainted( $result );
d1069 2
a1070 2
    is($result, "Soft Cell");
    is_tainted( $result );
d1073 2
a1074 2
    is($result, "The Fabulous Johnny Cash");
    isnt_tainted( $result );
d1088 1
a1088 2
	isnt_tainted($1);
	isnt($1, undef);
d1094 1
a1094 2
	isnt_tainted($bar[0]);
	is(scalar @@bar, 1);
d1103 1
a1103 1
    is_tainted($x99);
d1106 1
a1106 1
    isnt_tainted($x99);
d1109 1
a1109 1
    isnt_tainted($x99);
d1113 1
a1113 1
    is_tainted($x99);
d1116 1
a1116 1
    is_tainted($x99);
d1124 1
a1124 1
    is($@@, '');
d1131 7
a1137 13
    $a[0] = $^X . '-';
    $a[0]=~ m/(.)/g;
    cmp_ok pos($a[0]), '>', 0, "infinite m//g on arrays (aelemfast)";

    my $i = 1;
    $a[$i] = $^X . '-';
    $a[$i]=~ m/(.)/g;
    cmp_ok pos($a[$i]), '>', 0, "infinite m//g on arrays (aelem)";

    my %h;
    $h{a} = $^X . '-';
    $h{a}=~ m/(.)/g;
    cmp_ok pos($h{a}), '>', 0, "infinite m//g on hashes (helem)";
d1155 2
a1156 2
	skip "opening |- is not stable on threaded Open/MirBSD with taint", 3
            if $Config{useithreads} and $Is_OpenBSD || $Is_MirBSD;
d1170 2
a1171 2
	unlike($@@, qr/Insecure \$ENV/, 'fork triggers %ENV check');
	is($@@, '',               'pipe/fork/open/close failed');
d1176 1
a1176 1
	like($@@, qr/Insecure \$ENV/, 'popen neglects %ENV check');
d1186 1
a1186 3
            main::isnt_tainted($AUTOLOAD, '$AUTOLOAD can be untainted');
            my $copy = $AUTOLOAD;
            main::isnt_tainted($copy, '$AUTOLOAD can be untainted');
d1188 1
a1188 3
            main::is_tainted($AUTOLOAD, '$AUTOLOAD can be tainted');
            my $copy = $AUTOLOAD;
            main::is_tainted($copy, '$AUTOLOAD can be tainted');
a1193 1
    $o->untainted;
d1200 2
a1201 5
    my $fmt = $TAINT . "# %s\n";
    violates_taint(sub { printf($fmt, "foo") }, 'printf',
		   q/printf doesn't like tainted formats/);
    violates_taint(sub { printf($TAINT . "# %s\n", "foo") }, 'printf',
		   q/printf doesn't like tainted format expressions/);
d1203 3
a1205 5
    is($@@, '', q/printf accepts other tainted args/);
    violates_taint(sub { sprintf($fmt, "foo") }, 'sprintf',
		   q/sprintf doesn't like tainted formats/);
    violates_taint(sub { sprintf($TAINT . "# %s\n", "foo") }, 'sprintf',
		   q/sprintf doesn't like tainted format expressions/);
d1207 1
a1207 1
    is($@@, '', q/sprintf accepts other tainted args/);
d1230 3
a1232 3
    open my $fh, "test.pl" or die $!;
    seek $fh, 0, 2 or die $!;
    $tainted = <$fh>;
d1244 1
a1244 1
    isnt_tainted($1, "\\S match with chr $ord");
d1254 2
a1255 2
    is_tainted($a,  "tainted crypt");
    isnt_tainted($b, "untainted crypt");
d1258 2
a1259 2
    is_tainted($a,  "tainted complement");
    isnt_tainted($b, "untainted complement");
d1267 1
a1267 1
    is_tainted($string, "tainted data");
d1273 1
a1273 1
	is_tainted($got[$i], "tainted result $i");
d1277 1
a1277 1
    is_tainted($string, "still tainted data");
d1283 1
a1283 1
	is_tainted($got[$i], "tainted result $i");
d1287 1
a1287 1
    is_tainted($string, "still tainted data");
d1293 1
a1293 1
	is_tainted($got[$i], "tainted result $i");
d1302 1
a1302 1
    is_tainted($y, "pack a* preserves tainting");
d1305 1
a1305 1
    is_tainted($z, "pack A* preserves tainting");
d1308 1
a1308 1
    is_tainted($zz, "pack a*a* preserves tainting");
a1320 264
{
    # #6758: tainted values become untainted in tied hashes
    #         (also applies to other value magic such as pos)


    package P6758;

    sub TIEHASH { bless {} }
    sub TIEARRAY { bless {} }

    my $i = 0;

    sub STORE {
	main::is_tainted($_[1], "tied arg1 tainted");
	main::is_tainted($_[2], "tied arg2 tainted");
        $i++;
    }

    package main;

    my ($k,$v) = qw(1111 val);
    taint_these($k,$v);
    tie my @@array, 'P6758';
    tie my %hash , 'P6758';
    $array[$k] = $v;
    $hash{$k} = $v;
    ok $i == 2, "tied STORE called correct number of times";
}

# Bug RT #45167 the return value of sprintf sometimes wasn't tainted
# when the args were tainted. This only occured on the first use of
# sprintf; after that, its TARG has taint magic attached, so setmagic
# at the end works.  That's why there are multiple sprintf's below, rather
# than just one wrapped in an inner loop. Also, any plaintext between
# fprmat entires would correctly cause tainting to get set. so test with
# "%s%s" rather than eg "%s %s".

{
    for my $var1 ($TAINT, "123") {
	for my $var2 ($TAINT0, "456") {
	    is( tainted(sprintf '%s', $var1, $var2), tainted($var1),
		"sprintf '%s', '$var1', '$var2'" );
	    is( tainted(sprintf ' %s', $var1, $var2), tainted($var1),
		"sprintf ' %s', '$var1', '$var2'" );
	    is( tainted(sprintf '%s%s', $var1, $var2),
		tainted($var1) || tainted($var2),
		"sprintf '%s%s', '$var1', '$var2'" );
	}
    }
}


# Bug RT #67962: old tainted $1 gets treated as tainted
# in next untainted # match

{
    use re 'taint';
    "abc".$TAINT =~ /(.*)/; # make $1 tainted
    is_tainted($1, '$1 should be tainted');

    my $untainted = "abcdef";
    isnt_tainted($untainted, '$untainted should be untainted');
    $untainted =~ s/(abc)/$1/;
    isnt_tainted($untainted, '$untainted should still be untainted');
    $untainted =~ s/(abc)/x$1/;
    isnt_tainted($untainted, '$untainted should yet still be untainted');
}

{
    # On Windows we can't spawn a fresh Perl interpreter unless at
    # least the Windows system directory (usually C:\Windows\System32)
    # is still on the PATH.  There is however no way to determine the
    # actual path on the current system without loading the Win32
    # module, so we just restore the original $ENV{PATH} here.
    local $ENV{PATH} = $ENV{PATH};
    $ENV{PATH} = $old_env_path if $Is_MSWin32;

    fresh_perl_is(<<'end', "ok", { switches => [ '-T' ] },
    $TAINT = substr($^X, 0, 0);
    formline('@@'.('<'x("2000".$TAINT)).' | @@*', 'hallo', 'welt');
    print "ok";
end
    "formline survives a tainted dynamic picture");
}

{
    isnt_tainted($^A, "format accumulator not tainted yet");
    formline('@@ | @@*', 'hallo' . $TAINT, 'welt');
    is_tainted($^A, "tainted formline argument makes a tainted accumulator");
    $^A = "";
    isnt_tainted($^A, "accumulator can be explicitly untainted");
    formline('@@' .('<'*5) . ' | @@*', 'hallo', 'welt');
    isnt_tainted($^A, "accumulator still untainted");
    $^A = "" . $TAINT;
    is_tainted($^A, "accumulator can be explicitly tainted");
    formline('@@' .('<'*5) . ' | @@*', 'hallo', 'welt');
    is_tainted($^A, "accumulator still tainted");
    $^A = "";
    isnt_tainted($^A, "accumulator untainted again");
    formline('@@' .('<'*5) . ' | @@*', 'hallo', 'welt');
    isnt_tainted($^A, "accumulator still untainted");
    formline('@@' .('<'*(5+$TAINT0)) . ' | @@*', 'hallo', 'welt');
    TODO: {
        local $::TODO = "get magic handled too late?";
        is_tainted($^A, "the accumulator should be tainted already");
    }
    is_tainted($^A, "tainted formline picture makes a tainted accumulator");
}

{   # Bug #80610
    "Constant(1)" =~ / ^ ([a-z_]\w*) (?: [(] (.*) [)] )? $ /xi;
    my $a = $1;
    my $b = $2;
    isnt_tainted($a, "regex optimization of single char /[]/i doesn't taint");
    isnt_tainted($b, "regex optimization of single char /[]/i doesn't taint");
}

{
    # RT 81230: tainted value during FETCH created extra ref to tied obj

    package P81230;
    use warnings;

    my %h;

    sub TIEHASH {
	my $x = $^X; # tainted
	bless  \$x;
    }
    sub FETCH { my $x = $_[0]; $$x . "" }

    tie %h, 'P81230';

    my $w = "";
    local $SIG{__WARN__} = sub { $w .= "@@_" };

    untie %h if $h{"k"};

    ::is($w, "", "RT 81230");
}

{
    # Compiling a subroutine inside a tainted expression does not make the
    # constant folded values tainted.
    my $x = sub { "x" . "y" };
    my $y = $ENV{PATH} . $x->(); # Compile $x inside a tainted expression
    my $z = $x->();
    isnt_tainted($z, "Constants folded value not tainted");
}

{
    # now that regexes are first class SVs, make sure that they themselves
    # as well as references to them are tainted

    my $rr = qr/(.)$TAINT/;
    my $r = $$rr; # bare REGEX
    my $s ="abc";
    ok($s =~ s/$r/x/, "match bare regex");
    is_tainted($s, "match bare regex taint");
    is($s, 'xbc', "match bare regex taint value");
}

{
    # [perl #82616] security Issues with user-defined \p{} properties
    # A using a tainted user-defined property should croak

    sub IsA { sprintf "%02x", ord("A") }

    my $prop = "IsA";
    ok("A" =~ /\p{$prop}/, "user-defined property: non-tainted case");
    $prop = "IsA$TAINT";
    eval { "A" =~ /\p{$prop}/};
    like($@@, qr/Insecure user-defined property \\p{main::IsA}/,
	    "user-defined property: tainted case");
}

{
    # [perl #87336] lc/uc(first) failing to taint the returned string
    my $source = "foo$TAINT";
    my $dest = lc $source;
    is_tainted $dest, "lc(tainted) taints its return value";
    $dest = lcfirst $source;
    is_tainted $dest, "lcfirst(tainted) taints its return value";
    $dest = uc $source;
    is_tainted $dest, "uc(tainted) taints its return value";
    $dest = ucfirst $source;
    is_tainted $dest, "ucfirst(tainted) taints its return value";
}

{
    # Taintedness of values returned from given()
    use feature 'switch';

    my @@descriptions = ('when', 'given end', 'default');

    for (qw<x y z>) {
	my $letter = "$_$TAINT";

	my $desc = "tainted value returned from " . shift(@@descriptions);

	my $res = do {
	    given ($_) {
		when ('x') { $letter }
		when ('y') { goto leavegiven }
		default    { $letter }
		leavegiven:  $letter
	    }
	};
	is         $res, $letter, "$desc is correct";
	is_tainted $res,          "$desc stays tainted";
    }
}


# tainted constants and index()
#  RT 64804; http://bugs.debian.org/291450
{
    ok(tainted $old_env_path, "initial taintedness");
    BEGIN { no strict 'refs'; my $v = $old_env_path; *{"::C"} = sub () { $v }; }
    ok(tainted C, "constant is tainted properly");
    ok(!tainted "", "tainting not broken yet");
    index(undef, C);
    ok(!tainted "", "tainting still works after index() of the constant");
}

# Tainted values with smartmatch
# [perl #93590] S_do_smartmatch stealing its own string buffers
ok "M$TAINT" ~~ ['m', 'M'], '$tainted ~~ ["whatever", "match"]';
ok !("M$TAINT" ~~ ['m', undef]), '$tainted ~~ ["whatever", undef]';

# Tainted values and ref()
for(1,2) {
  my $x = bless \"M$TAINT", ref(bless[], "main");
}
pass("no death when TARG of ref is tainted");

# $$ should not be tainted by being read in a tainted expression.
{
    isnt_tainted $$, "PID not tainted initially";
    my $x = $ENV{PATH}.$$;
    isnt_tainted $$, "PID not tainted when read in tainted expression";
}

{
    use feature 'fc';
    use locale;
    my ($latin1, $utf8) = ("\xDF") x 2;
    utf8::downgrade($latin1);
    utf8::upgrade($utf8);

    is_tainted fc($latin1), "under locale, lc(latin1) taints the result";
    is_tainted fc($utf8), "under locale, lc(utf8) taints the result";

    is_tainted "\F$latin1", "under locale, \\Flatin1 taints the result";
    is_tainted "\F$utf8", "under locale, \\Futf8 taints the result";
}

{ # 111654
  eval {
    eval { die "Test\n".substr($ENV{PATH}, 0, 0); };
    die;
  };
  like($@@, qr/^Test\n\t\.\.\.propagated at /, "error should be propagated");
}
@


1.1.1.14
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d20 1
a20 1
plan tests => 797;
d155 1
a155 1
	    last unless $@@ =~ /^Insecure \$ENV\{$v}/;
d166 1
a166 1
	like($@@, qr/^Insecure \$ENV\{TERM}/);
d185 1
a185 1
	like($@@, qr/^Insecure directory in \$ENV\{PATH}/);
d193 1
a193 1
	like($@@, qr/^Insecure \$ENV\{DCL\$PATH}/);
d200 1
a200 1
	    like($@@, qr/^Insecure directory in \$ENV\{DCL\$PATH}/);
d299 1
a299 2
  SKIP: {
        skip 'No locale testing without d_setlocale', 10 if(!$Config{d_setlocale});
d301 7
a307 1
        $desc = "match with pattern tainted via locale";
d309 9
a317 32
        $s = 'abcd';
        {
            BEGIN {
                if($Config{d_setlocale}) {
                    require locale; import locale;
                }
            }
            $res = $s =~ /(\w+)/; $one = $1;
        }
        isnt_tainted($s,   "$desc: s not tainted");
        isnt_tainted($res, "$desc: res not tainted");
        is_tainted($one,   "$desc: \$1 tainted");
        is($res, 1,        "$desc: res value");
        is($one, 'abcd',   "$desc: \$1 value");

        $desc = "match /g with pattern tainted via locale";

        $s = 'abcd';
        {
            BEGIN {
                if($Config{d_setlocale}) {
                    require locale; import locale;
                }
            }
            $res = $s =~ /(\w)/g; $one = $1;
        }
        isnt_tainted($s,   "$desc: s not tainted");
        isnt_tainted($res, "$desc: res not tainted");
        is_tainted($one,   "$desc: \$1 tainted");
        is($res, 1,        "$desc: res value");
        is($one, 'a',      "$desc: \$1 value");
    }
d342 1
a342 2
  SKIP: {
        skip 'No locale testing without d_setlocale', 12 if(!$Config{d_setlocale});
d344 9
a352 1
        $desc = "match with pattern tainted via locale, list cxt";
d354 9
a362 34
        $s = 'abcd';
        {
            BEGIN {
                if($Config{d_setlocale}) {
                    require locale; import locale;
                }
            }
            ($res) = $s =~ /(\w+)/; $one = $1;
        }
        isnt_tainted($s,   "$desc: s not tainted");
        is_tainted($res,   "$desc: res tainted");
        is_tainted($one,   "$desc: \$1 tainted");
        is($res, 'abcd',   "$desc: res value");
        is($one, 'abcd',   "$desc: \$1 value");

        $desc = "match /g with pattern tainted via locale, list cxt";

        $s = 'abcd';
        {
            BEGIN {
                if($Config{d_setlocale}) {
                    require locale; import locale;
                }
            }
            ($res, $res2) = $s =~ /(\w)/g; $one = $1;
        }
        isnt_tainted($s,   "$desc: s not tainted");
        is_tainted($res,   "$desc: res tainted");
        is_tainted($res2,  "$desc: res2 tainted");
        is_tainted($one,   "$desc: \$1 tainted");
        is($res, 'a',      "$desc: res value");
        is($res2,'b',      "$desc: res2 value");
        is($one, 'd',      "$desc: \$1 value");
    }
d484 1
a484 2
  SKIP: {
        skip 'No locale testing without d_setlocale', 18 if(!$Config{d_setlocale});
d486 10
a495 1
        $desc = "substitution with pattern tainted via locale";
d497 19
a515 52
        $s = 'abcd';
        {
            BEGIN {
                if($Config{d_setlocale}) {
                    require locale; import locale;
                }
            }
            $res = $s =~ s/(\w+)/xyz/; $one = $1;
        }
        is_tainted($s,     "$desc: s tainted");
        isnt_tainted($res, "$desc: res not tainted");
        is_tainted($one,   "$desc: \$1 tainted");
        is($s,  'xyz',     "$desc: s value");
        is($res, 1,        "$desc: res value");
        is($one, 'abcd',   "$desc: \$1 value");

        $desc = "substitution /g with pattern tainted via locale";

        $s = 'abcd';
        {
            BEGIN {
                if($Config{d_setlocale}) {
                    require locale; import locale;
                }
            }
            $res = $s =~ s/(\w)/x/g; $one = $1;
        }
        is_tainted($s,     "$desc: s tainted");
        is_tainted($res,   "$desc: res tainted");
        is_tainted($one,   "$desc: \$1 tainted");
        is($s,  'xxxx',    "$desc: s value");
        is($res, 4,        "$desc: res value");
        is($one, 'd',      "$desc: \$1 value");

        $desc = "substitution /r with pattern tainted via locale";

        $s = 'abcd';
        {
            BEGIN {
                if($Config{d_setlocale}) {
                    require locale; import locale;
                }
            }
            $res = $s =~ s/(\w+)/xyz/r; $one = $1;
        }
        isnt_tainted($s,   "$desc: s not tainted");
        is_tainted($res,   "$desc: res tainted");
        is_tainted($one,   "$desc: \$1 tainted");
        is($s,  'abcd',    "$desc: s value");
        is($res, 'xyz',    "$desc: res value");
        is($one, 'abcd',   "$desc: \$1 value");
    }
d564 1
a564 1
    isnt_tainted($res, "$desc: res tainted");
d655 9
a663 2
  SKIP: {
        skip 'No locale testing without d_setlocale', 10 if(!$Config{d_setlocale});
d665 1
a665 1
        $desc = "use re 'taint': match with pattern tainted via locale";
d667 7
a673 32
        $s = 'abcd';
        {
            BEGIN {
                if($Config{d_setlocale}) {
                    require locale; import locale;
                }
            }
            $res = $s =~ /(\w+)/; $one = $1;
        }
        isnt_tainted($s,   "$desc: s not tainted");
        isnt_tainted($res, "$desc: res not tainted");
        is_tainted($one,   "$desc: \$1 tainted");
        is($res, 1,        "$desc: res value");
        is($one, 'abcd',   "$desc: \$1 value");

        $desc = "use re 'taint': match /g with pattern tainted via locale";

        $s = 'abcd';
        {
            BEGIN {
                if($Config{d_setlocale}) {
                    require locale; import locale;
                }
            }
            $res = $s =~ /(\w)/g; $one = $1;
        }
        isnt_tainted($s,   "$desc: s not tainted");
        isnt_tainted($res, "$desc: res not tainted");
        is_tainted($one,   "$desc: \$1 tainted");
        is($res, 1,        "$desc: res value");
        is($one, 'a',      "$desc: \$1 value");
    }
d698 1
a698 2
  SKIP: {
        skip 'No locale testing without d_setlocale', 12 if(!$Config{d_setlocale});
d700 7
a706 1
        $desc = "use re 'taint': match with pattern tainted via locale, list cxt";
d708 11
a718 34
        $s = 'abcd';
        {
            BEGIN {
                if($Config{d_setlocale}) {
                    require locale; import locale;
                }
            }
            ($res) = $s =~ /(\w+)/; $one = $1;
        }
        isnt_tainted($s,   "$desc: s not tainted");
        is_tainted($res,   "$desc: res tainted");
        is_tainted($one,   "$desc: \$1 tainted");
        is($res, 'abcd',   "$desc: res value");
        is($one, 'abcd',   "$desc: \$1 value");

        $desc = "use re 'taint': match /g with pattern tainted via locale, list cxt";

        $s = 'abcd';
        {
            BEGIN {
                if($Config{d_setlocale}) {
                    require locale; import locale;
                }
            }
            ($res, $res2) = $s =~ /(\w)/g; $one = $1;
        }
        isnt_tainted($s,   "$desc: s not tainted");
        is_tainted($res,   "$desc: res tainted");
        is_tainted($res2,  "$desc: res2 tainted");
        is_tainted($one,   "$desc: \$1 tainted");
        is($res, 'a',      "$desc: res value");
        is($res2,'b',      "$desc: res2 value");
        is($one, 'd',      "$desc: \$1 value");
    }
d841 1
a841 2
  SKIP: {
        skip 'No locale testing without d_setlocale', 18 if(!$Config{d_setlocale});
d843 10
a852 1
        $desc = "use re 'taint': substitution with pattern tainted via locale";
d854 19
a872 52
        $s = 'abcd';
        {
            BEGIN {
                if($Config{d_setlocale}) {
                    require locale; import locale;
                }
            }
            $res = $s =~ s/(\w+)/xyz/; $one = $1;
        }
        is_tainted($s,     "$desc: s tainted");
        isnt_tainted($res, "$desc: res not tainted");
        is_tainted($one,   "$desc: \$1 tainted");
        is($s,  'xyz',     "$desc: s value");
        is($res, 1,        "$desc: res value");
        is($one, 'abcd',   "$desc: \$1 value");

        $desc = "use re 'taint': substitution /g with pattern tainted via locale";

        $s = 'abcd';
        {
            BEGIN {
                if($Config{d_setlocale}) {
                    require locale; import locale;
                }
            }
            $res = $s =~ s/(\w)/x/g; $one = $1;
        }
        is_tainted($s,     "$desc: s tainted");
        is_tainted($res,   "$desc: res tainted");
        is_tainted($one,   "$desc: \$1 tainted");
        is($s,  'xxxx',    "$desc: s value");
        is($res, 4,        "$desc: res value");
        is($one, 'd',      "$desc: \$1 value");

        $desc = "use re 'taint': substitution /r with pattern tainted via locale";

        $s = 'abcd';
        {
            BEGIN {
                if($Config{d_setlocale}) {
                    require locale; import locale;
                }
            }
            $res = $s =~ s/(\w+)/xyz/r; $one = $1;
        }
        isnt_tainted($s,   "$desc: s not tainted");
        is_tainted($res,   "$desc: res tainted");
        is_tainted($one,   "$desc: \$1 tainted");
        is($s,  'abcd',    "$desc: s value");
        is($res, 'xyz',    "$desc: res value");
        is($one, 'abcd',   "$desc: \$1 value");
    }
d921 1
a921 1
	isnt_tainted($res, "$desc: res tainted");
a1632 8
    {
	use re 'eval'; # this shouldn't make any difference
	($r = $TAINT) =~ /($notaint)/;
	isnt_tainted($1);
	($r = $TAINT) =~ /($TAINT)/;
	is_tainted($1);
    }

d2045 4
a2048 1
    is_tainted($^A, "the accumulator should be tainted already");
d2115 1
a2115 1
    like($@@, qr/Insecure user-defined property \\p\{main::IsA}/,
a2134 1
    no warnings 'experimental::smartmatch';
a2169 2
{
no warnings 'experimental::smartmatch';
a2171 1
}
d2186 1
a2186 3
SKIP: {
    skip 'No locale testing without d_setlocale', 4 if(!$Config{d_setlocale});

d2188 1
a2188 5
    BEGIN {
        if($Config{d_setlocale}) {
            require locale; import locale;
        }
    }
a2205 9
}

# tainted run-time (?{}) should die

{
    my $code = '(?{})' . $TAINT;
    use re 'eval';
    eval { "a" =~ /$code/ };
    like($@@, qr/Eval-group in insecure regular expression/, "tainted (?{})");
@


1.1.1.15
log
@Import perl-5.20.1
@
text
@d20 1
a20 1
plan tests => 800;
d185 1
a185 3
	# Message can be different depending on whether echo
	# is a builtin or not
	like($@@, qr/^Insecure (?:directory in )?\$ENV\{PATH}/);
a1059 12

        # [perl #121854] match taintedness became sticky
        # when one match has a taintess result, subseqent matches
        # using the same pattern shouldn't necessarily be tainted

        {
            my $f = sub { $_[0] =~ /(.*)/ or die; $1 };
            $res = $f->($TAINT);
            is_tainted($res,   "121854: res tainted");
            $res = $f->("abc");
            isnt_tainted($res,   "121854: res not tainted");
        }
d1436 1
a1436 6
        my $id;
        eval {
            local $SIG{SYS} = sub { die "SIGSYS caught\n" };
            $id = shmget(IPC_PRIVATE, $size, S_IRWXU);
            1;
        } or do { chomp(my $msg = $@@); skip "shmget: $msg", 1; };
d1456 1
a1456 1
        is_tainted($rcvd, "shmread");
d1465 1
a1465 6
        my $id;
        eval {
            local $SIG{SYS} = sub { die "SIGSYS caught\n" };
            $id = msgget(IPC_PRIVATE, IPC_CREAT | S_IRWXU);
            1;
        } or do { chomp(my $msg = $@@); skip "msgget: $msg", 1; };
d1491 1
a1491 1
	    is_tainted($rcvd, "msgrcv");
d2000 12
a2011 15
  SKIP: {
      skip 'No crypt function, skipping crypt tests', 4 if(!$Config{d_crypt});
      # 59998
      sub cr { my $x = crypt($_[0], $_[1]); $x }
      sub co { my $x = ~$_[0]; $x }
      my ($a, $b);
      $a = cr('hello', 'foo' . $TAINT);
      $b = cr('hello', 'foo');
      is_tainted($a,  "tainted crypt");
      isnt_tainted($b, "untainted crypt");
      $a = co('foo' . $TAINT);
      $b = co('foo');
      is_tainted($a,  "tainted complement");
      isnt_tainted($b, "untainted complement");
    }
a2352 5

# reset() and tainted undef (?!)
$::x = "foo";
$_ = "$TAINT".reset "x";
is eval { eval $::x.1 }, 1, 'reset does not taint undef';
@


1.1.1.16
log
@Import perl-5.20.2
@
text
@d20 1
a20 1
plan tests => 801;
a2384 14

# [perl #122669]
{
    # See the comment above the first formline test.
    local $ENV{PATH} = $ENV{PATH};
    $ENV{PATH} = $old_env_path if $Is_MSWin32;
    is runperl(
       switches => [ '-T' ],
       prog => 'use constant K=>$^X; 0 if K; BEGIN{} use strict; '
              .'print 122669, qq-\n-',
       stderr => 1,
     ), "122669\n",
        'tainted constant as logop condition should not prevent "use"';
}
@


