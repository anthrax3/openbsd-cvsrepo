head	1.12;
access;
symbols
	PERL_5_24_2:1.1.1.11
	OPENBSD_6_1:1.12.0.4
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.11.0.10
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.4
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.11.0.6
	OPENBSD_5_8_BASE:1.11
	PERL_5_20_2:1.1.1.10
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	PERL_5_20_1:1.1.1.10
	OPENBSD_5_6:1.10.0.4
	OPENBSD_5_6_BASE:1.10
	PERL_5_18_2:1.1.1.9
	PERL:1.1.1
	OPENBSD_5_5:1.9.0.6
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.2
	OPENBSD_5_4_BASE:1.9
	PERL_5_16_3:1.1.1.8
	OPENBSD_5_3:1.8.0.10
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.8
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.6
	OPENBSD_5_0:1.8.0.4
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.2
	OPENBSD_4_9_BASE:1.8
	PERL_5_12_2:1.1.1.7
	OPENBSD_4_8:1.7.0.4
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.2
	OPENBSD_4_7_BASE:1.7
	PERL_5_10_1:1.1.1.6
	OPENBSD_4_6:1.6.0.26
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.22
	OPENBSD_4_5_BASE:1.6
	PERL_5_10_0:1.1.1.5
	OPENBSD_4_4:1.6.0.20
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.18
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.16
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.14
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.12
	OPENBSD_4_0_BASE:1.6
	PERL_5_8_8:1.1.1.5
	OPENBSD_3_9:1.6.0.10
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.8
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.6
	OPENBSD_3_7_BASE:1.6
	PERL_5_8_6:1.1.1.5
	OPENBSD_3_6:1.6.0.4
	OPENBSD_3_6_BASE:1.6
	PERL_5_8_5:1.1.1.5
	PERL_5_8_3:1.1.1.5
	OPENBSD_3_5:1.6.0.2
	OPENBSD_3_5_BASE:1.6
	PERL_5_8_2:1.1.1.5
	OPENBSD_3_4:1.5.0.4
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.4.0.6
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.4
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.3.0.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	PERL_500503:1.1.1.1
	CPAN:1.1.1
	OPENBSD_2_5:1.1.0.6
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.4
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.2
	OPENBSD_2_3_BASE:1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.12
date	2017.02.05.00.32.20;	author afresh1;	state Exp;
branches;
next	1.11;
commitid	cxJ08BvJA9Pt2PTM;

1.11
date	2014.11.17.20.57.07;	author afresh1;	state Exp;
branches;
next	1.10;
commitid	QP75iYx42Uo7mMxO;

1.10
date	2014.03.24.15.05.33;	author afresh1;	state Exp;
branches;
next	1.9;

1.9
date	2013.03.25.20.40.59;	author sthen;	state Exp;
branches;
next	1.8;

1.8
date	2010.09.24.15.07.08;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2009.10.12.18.30.27;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2003.12.03.03.02.48;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.10.27.22.25.37;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.24.18.36.19;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.06.17.08.26;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	99.04.29.22.52.36;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	97.11.30.08.05.28;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.29.22.41.46;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.04.06.16.10.49;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.05.24.18.25.41;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.27.22.15.10;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.12.03.02.44.32;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2009.10.12.18.10.44;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2010.09.24.14.49.18;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2013.03.25.20.09.36;	author sthen;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2014.03.24.14.59.10;	author afresh1;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2014.11.17.20.53.18;	author afresh1;	state Exp;
branches;
next	1.1.1.11;
commitid	B31cAbBIXiCqnL97;

1.1.1.11
date	2017.08.14.13.46.24;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@perl 5.004_04
@


1.12
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl -w

#
# test method calls and autoloading.
#

BEGIN {
    chdir 't' if -d 't';
    @@INC = qw(. ../lib lib ../dist/base/lib);
    require "./test.pl";
}

use strict;
no warnings 'once';

plan(tests => 150);

@@A::ISA = 'B';
@@B::ISA = 'C';

sub C::d {"C::d"}
sub D::d {"D::d"}

# First, some basic checks of method-calling syntax:
my $obj = bless [], "Pack";
sub Pack::method { shift; join(",", "method", @@_) }
my $mname = "method";

is(Pack->method("a","b","c"), "method,a,b,c");
is(Pack->$mname("a","b","c"), "method,a,b,c");
is(method Pack ("a","b","c"), "method,a,b,c");
is((method Pack "a","b","c"), "method,a,b,c");

is(Pack->method(), "method");
is(Pack->$mname(), "method");
is(method Pack (), "method");
is(Pack->method, "method");
is(Pack->$mname, "method");
is(method Pack, "method");

is($obj->method("a","b","c"), "method,a,b,c");
is($obj->$mname("a","b","c"), "method,a,b,c");
is((method $obj ("a","b","c")), "method,a,b,c");
is((method $obj "a","b","c"), "method,a,b,c");

is($obj->method(0), "method,0");
is($obj->method(1), "method,1");

is($obj->method(), "method");
is($obj->$mname(), "method");
is((method $obj ()), "method");
is($obj->method, "method");
is($obj->$mname, "method");
is(method $obj, "method");

is( A->d, "C::d");		# Update hash table;

*B::d = \&D::d;			# Import now.
is(A->d, "D::d");		# Update hash table;

{
    local @@A::ISA = qw(C);	# Update hash table with split() assignment
    is(A->d, "C::d");
    $#A::ISA = -1;
    is(eval { A->d } || "fail", "fail");
}
is(A->d, "D::d");

{
    local *B::d;
    eval 'sub B::d {"B::d1"}';	# Import now.
    is(A->d, "B::d1");	# Update hash table;
    undef &B::d;
    is((eval { A->d }, ($@@ =~ /Undefined subroutine/)), 1);
}

is(A->d, "D::d");		# Back to previous state

eval 'no warnings "redefine"; sub B::d {"B::d2"}';	# Import now.
is(A->d, "B::d2");		# Update hash table;

# What follows is hardly guarantied to work, since the names in scripts
# are already linked to "pruned" globs. Say, 'undef &B::d' if it were
# after 'delete $B::{d}; sub B::d {}' would reach an old subroutine.

undef &B::d;
delete $B::{d};
is(A->d, "C::d");

eval 'sub B::d {"B::d2.5"}';
A->d;				# Update hash table;
my $glob = \delete $B::{d};	# non-void context; hang on to the glob
is(A->d, "C::d");		# Update hash table;

eval 'sub B::d {"B::d3"}';	# Import now.
is(A->d, "B::d3");		# Update hash table;

delete $B::{d};
*dummy::dummy = sub {};		# Mark as updated
is(A->d, "C::d");

eval 'sub B::d {"B::d4"}';	# Import now.
is(A->d, "B::d4");		# Update hash table;

delete $B::{d};			# Should work without any help too
is(A->d, "C::d");

{
    local *C::d;
    is(eval { A->d } || "nope", "nope");
}
is(A->d, "C::d");

*A::x = *A::d;
A->d;
is(eval { A->x } || "nope", "nope", 'cache should not follow synonyms');

my $counter;

eval <<'EOF';
sub C::e;
BEGIN { *B::e = \&C::e }	# Shouldn't prevent AUTOLOAD in original pkg
sub Y::f;
$counter = 0;

@@X::ISA = 'Y';
@@Y::ISA = 'B';

sub B::AUTOLOAD {
  my $c = ++$counter;
  my $method = $B::AUTOLOAD; 
  my $msg = "B: In $method, $c";
  eval "sub $method { \$msg }";
  goto &$method;
}
sub C::AUTOLOAD {
  my $c = ++$counter;
  my $method = $C::AUTOLOAD; 
  my $msg = "C: In $method, $c";
  eval "sub $method { \$msg }";
  goto &$method;
}
EOF

is(A->e(), "C: In C::e, 1");	# We get a correct autoload
is(A->e(), "C: In C::e, 1");	# Which sticks

is(A->ee(), "B: In A::ee, 2"); # We get a generic autoload, method in top
is(A->ee(), "B: In A::ee, 2"); # Which sticks

is(Y->f(), "B: In Y::f, 3");	# We vivify a correct method
is(Y->f(), "B: In Y::f, 3");	# Which sticks

# This test is not intended to be reasonable. It is here just to let you
# know that you broke some old construction. Feel free to rewrite the test
# if your patch breaks it.

{
no warnings 'redefine';
*B::AUTOLOAD = sub {
  use warnings;
  my $c = ++$counter;
  my $method = $::AUTOLOAD; 
  no strict 'refs';
  *$::AUTOLOAD = sub { "new B: In $method, $c" };
  goto &$::AUTOLOAD;
};
}

is(A->eee(), "new B: In A::eee, 4");	# We get a correct $autoload
is(A->eee(), "new B: In A::eee, 4");	# Which sticks

# test that failed subroutine calls don't affect method calls
{
    package A1;
    sub foo { "foo" }
    package A2;
    @@A2::ISA = 'A1';
    package main;
    is(A2->foo(), "foo");
    is(do { eval 'A2::foo()'; $@@ ? 1 : 0}, 1);
    is(A2->foo(), "foo");
}

## This test was totally misguided.  It passed before only because the
## code to determine if a package was loaded used to look for the hash
## %Foo::Bar instead of the package Foo::Bar:: -- and Config.pm just
## happens to export %Config.
#  {
#      is(do { use Config; eval 'Config->foo()';
#  	      $@@ =~ /^\QCan't locate object method "foo" via package "Config" at/ ? 1 : $@@}, 1);
#      is(do { use Config; eval '$d = bless {}, "Config"; $d->foo()';
#  	      $@@ =~ /^\QCan't locate object method "foo" via package "Config" at/ ? 1 : $@@}, 1);
#  }

# test error messages if method loading fails
my $e;

eval '$e = bless {}, "E::A"; E::A->foo()';
like ($@@, qr/^\QCan't locate object method "foo" via package "E::A" at/);
eval '$e = bless {}, "E::B"; $e->foo()';  
like ($@@, qr/^\QCan't locate object method "foo" via package "E::B" at/);
eval 'E::C->foo()';
like ($@@, qr/^\QCan't locate object method "foo" via package "E::C" (perhaps /);

eval 'UNIVERSAL->E::D::foo()';
like ($@@, qr/^\QCan't locate object method "foo" via package "E::D" (perhaps /);
eval 'my $e = bless {}, "UNIVERSAL"; $e->E::E::foo()';
like ($@@, qr/^\QCan't locate object method "foo" via package "E::E" (perhaps /);

$e = bless {}, "E::F";  # force package to exist
eval 'UNIVERSAL->E::F::foo()';
like ($@@, qr/^\QCan't locate object method "foo" via package "E::F" at/);
eval '$e = bless {}, "UNIVERSAL"; $e->E::F::foo()';
like ($@@, qr/^\QCan't locate object method "foo" via package "E::F" at/);

# SUPER:: pseudoclass
@@Saab::ISA = "Souper";
sub Souper::method { @@_ }
@@OtherSaab::ISA = "OtherSouper";
sub OtherSouper::method { "Isidore Ropen, Draft Manager" }
{
   my $o = bless [], "Saab";
   package Saab;
   my @@ret = $o->SUPER::method('whatever');
   ::is $ret[0], $o, 'object passed to SUPER::method';
   ::is $ret[1], 'whatever', 'argument passed to SUPER::method';
   @@ret = $o->SUPER'method('whatever');
   ::is $ret[0], $o, "object passed to SUPER'method";
   ::is $ret[1], 'whatever', "argument passed to SUPER'method";
   @@ret = Saab->SUPER::method;
   ::is $ret[0], 'Saab', "package name passed to SUPER::method";
   @@ret = OtherSaab->SUPER::method;
   ::is $ret[0], 'OtherSaab',
      "->SUPER::method uses current package, not invocant";
}  
() = *SUPER::;
{
   local our @@ISA = "Souper";
   is eval { (main->SUPER::method)[0] }, 'main',
      'Mentioning *SUPER:: does not stop ->SUPER from working in main';
}
{
    BEGIN {
        *Mover:: = *Mover2::;
        *Mover2:: = *foo;
    }
    package Mover;
    no strict;
    # Not our(@@ISA), because the bug we are testing for interacts with an
    # our() bug that cancels this bug out.
    @@ISA = 'door';
    sub door::dohtem { 'dohtem' }
    ::is eval { Mover->SUPER::dohtem; }, 'dohtem',
        'SUPER inside moved package';
    undef *door::dohtem;
    *door::dohtem = sub { 'method' };
    ::is eval { Mover->SUPER::dohtem; }, 'method',
        'SUPER inside moved package respects method changes';
}

package foo120694 {
    BEGIN { our @@ISA = qw(bar120694) }

    sub AUTOLOAD {
        my $self = shift;
        local our $recursive = $recursive;
        return "recursive" if $recursive++;
        return if our $AUTOLOAD eq 'DESTROY';
        $AUTOLOAD = "SUPER:" . substr $AUTOLOAD, rindex($AUTOLOAD, ':');
        return $self->$AUTOLOAD(@@_);
    }
}
package bar120694 {
    sub AUTOLOAD {
        return "xyzzy";
    }
}
is bless( [] => "foo120694" )->plugh, 'xyzzy',
    '->SUPER::method autoloading uses parent of current pkg';


# failed method call or UNIVERSAL::can() should not autovivify packages
is( $::{"Foo::"} || "none", "none");  # sanity check 1
is( $::{"Foo::"} || "none", "none");  # sanity check 2

is( UNIVERSAL::can("Foo", "boogie") ? "yes":"no", "no" );
is( $::{"Foo::"} || "none", "none");  # still missing?

is( Foo->UNIVERSAL::can("boogie")   ? "yes":"no", "no" );
is( $::{"Foo::"} || "none", "none");  # still missing?

is( Foo->can("boogie")              ? "yes":"no", "no" );
is( $::{"Foo::"} || "none", "none");  # still missing?

is( eval 'Foo->boogie(); 1'         ? "yes":"no", "no" );
is( $::{"Foo::"} || "none", "none");  # still missing?

is(do { eval 'Foo->boogie()';
	  $@@ =~ /^\QCan't locate object method "boogie" via package "Foo" (perhaps / ? 1 : $@@}, 1);

eval 'sub Foo::boogie { "yes, sir!" }';
is( $::{"Foo::"} ? "ok" : "none", "ok");  # should exist now
is( Foo->boogie(), "yes, sir!");

# TODO: universal.t should test NoSuchPackage->isa()/can()

# This is actually testing parsing of indirect objects and undefined subs
#   print foo("bar") where foo does not exist is not an indirect object.
#   print foo "bar"  where foo does not exist is an indirect object.
eval 'sub AUTOLOAD { "ok ", shift, "\n"; }';
ok(1);

# Bug ID 20010902.002
is(
    eval q[
	my $x = 'x'; # Lexical or package variable, 5.6.1 panics.
	sub Foo::x : lvalue { $x }
	Foo->$x = 'ok';
    ] || $@@, 'ok'
);

# An autoloaded, inherited DESTROY may be invoked differently than normal
# methods, and has been known to give rise to spurious warnings
# eg <200203121600.QAA11064@@gizmo.fdgroup.co.uk>

{
    use warnings;
    my $w = '';
    local $SIG{__WARN__} = sub { $w = $_[0] };

    sub AutoDest::Base::AUTOLOAD {}
    @@AutoDest::ISA = qw(AutoDest::Base);
    { my $x = bless {}, 'AutoDest'; }
    $w =~ s/\n//g;
    is($w, '');
}

# [ID 20020305.025] PACKAGE::SUPER doesn't work anymore

package main;
our @@X;
package Amajor;
sub test {
    push @@main::X, 'Amajor', @@_;
}
package Bminor;
use base qw(Amajor);
package main;
sub Bminor::test {
    $_[0]->Bminor::SUPER::test('x', 'y');
    push @@main::X, 'Bminor', @@_;
}
Bminor->test('y', 'z');
is("@@X", "Amajor Bminor x y Bminor Bminor y z");

package main;
for my $meth (['Bar', 'Foo::Bar'],
	      ['SUPER::Bar', 'main::SUPER::Bar'],
	      ['Xyz::SUPER::Bar', 'Xyz::SUPER::Bar'])
{
    fresh_perl_is(<<EOT,
package UNIVERSAL; sub AUTOLOAD { my \$c = shift; print "\$c \$AUTOLOAD\\n" }
sub DESTROY {} # prevent AUTOLOAD being called on DESTROY
package Xyz;
package main; Foo->$meth->[0]();
EOT
	"Foo $meth->[1]",
	{ switches => [ '-w' ] },
	"check if UNIVERSAL::AUTOLOAD works",
    );
}

# Test for #71952: crash when looking for a nonexistent destructor
# Regression introduced by fbb3ee5af3d4
{
    fresh_perl_is(<<'EOT',
sub M::DESTROY; bless {}, "M" ; print "survived\n";
EOT
    "survived",
    {},
	"no crash with a declared but missing DESTROY method"
    );
}

# Test for calling a method on a packag name return by a magic variable
sub TIESCALAR{bless[]}
sub FETCH{"main"}
my $kalled;
sub bolgy { ++$kalled; }
tie my $a, "";
$a->bolgy;
is $kalled, 1, 'calling a class method via a magic variable';

{
    package NulTest;
    sub method { 1 }

    package main;
    eval {
        NulTest->${ \"method\0Whoops" };
    };
    like $@@, qr/Can't locate object method "method\0Whoops" via package "NulTest" at/,
            "method lookup is nul-clean";

    *NulTest::AUTOLOAD = sub { our $AUTOLOAD; return $AUTOLOAD };

    like(NulTest->${ \"nul\0test" }, qr/nul\0test/, "AUTOLOAD is nul-clean");
}


{
    fresh_perl_is(
    q! sub T::DESTROY { $x = $_[0]; } bless [], "T";!,
    "DESTROY created new reference to dead object 'T' during global destruction.",
    {},
	"DESTROY creating a new reference to the object generates a warning."
    );
}

# [perl #43663]
{
    $::{"Just"} = \1;
    sub Just::a_japh { return "$_[0] another Perl hacker," }
    is eval { "Just"->a_japh }, "Just another Perl hacker,",
	'constants do not interfere with class methods';
}

# [perl #109264]
{
    no strict 'vars';
    sub bliggles { 1 }
    sub lbiggles :lvalue { index "foo", "f" }
    ok eval { main->bliggles(my($foo,$bar)) },
      'foo->bar(my($foo,$bar)) is not called in lvalue context';
    ok eval { main->bliggles(our($foo,$bar)) },
      'foo->bar(our($foo,$bar)) is not called in lvalue context';
    ok eval { main->bliggles(local($foo,$bar)) },
      'foo->bar(local($foo,$bar)) is not called in lvalue context';
    ok eval { () = main->lbiggles(my($foo,$bar)); 1 },
      'foo->lv(my($foo,$bar)) is not called in lvalue context';
    ok eval { () = main->lbiggles(our($foo,$bar)); 1 },
      'foo->lv(our($foo,$bar)) is not called in lvalue context';
    ok eval { () = main->lbiggles(local($foo,$bar)); 1 },
      'foo->lv(local($foo,$bar)) is not called in lvalue context';
}

{
   # AUTOLOAD and DESTROY can be declared without a leading sub,
   # like BEGIN and friends.
   package NoSub;

   eval 'AUTOLOAD { our $AUTOLOAD; return $AUTOLOAD }';
   ::ok( !$@@, "AUTOLOAD without a leading sub is legal" );

   eval "DESTROY { ::pass( q!DESTROY without a leading sub is legal and gets called! ) }";
   {
      ::ok( NoSub->can("AUTOLOAD"), "...and sets up an AUTOLOAD normally" );
      ::is( eval { NoSub->bluh }, "NoSub::bluh", "...which works as expected" );
   }
   { bless {}, "NoSub"; }
}

{
    # [perl #124387]
    my $autoloaded;
    package AutoloadDestroy;
    sub AUTOLOAD { $autoloaded = 1 }
    package main;
    bless {}, "AutoloadDestroy";
    ok($autoloaded, "AUTOLOAD called for DESTROY");

    # 127494 - AUTOLOAD for DESTROY was called without setting $AUTOLOAD
    my %methods;
    package AutoloadDestroy2;
    sub AUTOLOAD {
        our $AUTOLOAD;
        (my $method = $AUTOLOAD) =~ s/.*:://;
        ++$methods{$method};
    }
    package main;
    # this cached AUTOLOAD as the DESTROY method
    bless {}, "AutoloadDestroy2";
    %methods = ();
    my $o = bless {}, "AutoloadDestroy2";
    # this sets $AUTOLOAD to "AutoloadDestroy2::foo"
    $o->foo;
    # this would call AUTOLOAD without setting $AUTOLOAD
    undef $o;
    ok($methods{DESTROY}, "\$AUTOLOAD set correctly for DESTROY");
}

eval { () = 3; new {} };
like $@@,
     qr/^Can't call method "new" without a package or object reference/,
    'Err msg from new{} when stack contains a number';
eval { () = "foo"; new {} };
like $@@,
     qr/^Can't call method "new" without a package or object reference/,
    'Err msg from new{} when stack contains a word';
eval { () = undef; new {} };
like $@@,
     qr/^Can't call method "new" without a package or object reference/,
    'Err msg from new{} when stack contains undef';

package egakacp {
  our @@ISA = 'ASI';
  sub ASI::m { shift; "@@_" };
  my @@a = (bless([]), 'arg');
  my $r = SUPER::m{@@a};
  ::is $r, 'arg', 'method{@@array}';
  $r = SUPER::m{}@@a;
  ::is $r, 'arg', 'method{}@@array';
  $r = SUPER::m{@@a}"b";
  ::is $r, 'arg b', 'method{@@array}$more_args';
}

# [perl #114924] SUPER->method
@@SUPER::ISA = "SUPPER";
sub SUPPER::foo { "supper" }
is "SUPER"->foo, 'supper', 'SUPER->method';

sub flomp { "flimp" }
sub main::::flomp { "flump" }
is "::"->flomp, 'flump', 'method call on ::';
is "::main"->flomp, 'flimp', 'method call on ::main';
eval { ""->flomp };
like $@@,
     qr/^Can't call method "flomp" without a package or object reference/,
    'method call on empty string';
is "3foo"->CORE::uc, '3FOO', '"3foo"->CORE::uc';
{ no strict; @@{"3foo::ISA"} = "CORE"; }
is "3foo"->uc, '3FOO', '"3foo"->uc (autobox style!)';

# *foo vs (\*foo)
sub myclass::squeak { 'eek' }
eval { *myclass->squeak };
like $@@,
     qr/^Can't call method "squeak" without a package or object reference/,
    'method call on typeglob ignores package';
eval { (\*myclass)->squeak };
like $@@,
     qr/^Can't call method "squeak" on unblessed reference/,
    'method call on \*typeglob';
*stdout2 = *STDOUT;  # stdout2 now stringifies as *main::STDOUT
sub IO::Handle::self { $_[0] }
# This used to stringify the glob:
is *stdout2->self, (\*stdout2)->self,
  '*glob->method is equiv to (\*glob)->method';
sub { $_[0] = *STDOUT; is $_[0]->self, \$::h{k}, '$pvlv_glob->method' }
 ->($::h{k});

# Test that PL_stashcache doesn't change the resolution behaviour for file
# handles and package names.
SKIP: {
    skip_if_miniperl('file handles as methods requires loading IO::File', 26);
    require Fcntl;

    foreach (qw (Count::DATA Count Colour::H1 Color::H1 C3::H1)) {
	eval qq{
            package $_;

            sub getline {
                return "method in $_";
            }

            1;
        } or die $@@;
    }

    BEGIN {
	*The::Count:: = \*Count::;
    }

    is(Count::DATA->getline(), 'method in Count::DATA',
       'initial resolution is a method');
    is(The::Count::DATA->getline(), 'method in Count::DATA',
       'initial resolution is a method in aliased classes');

    require Count;

    is(Count::DATA->getline(), "one! ha ha ha\n", 'file handles take priority');
    is(The::Count::DATA->getline(), "two! ha ha ha\n",
       'file handles take priority in aliased classes');

    eval q{close Count::DATA} or die $!;

    {
	no warnings 'io';
	is(Count::DATA->getline(), undef,
	   "closing a file handle doesn't change object resolution");
	is(The::Count::DATA->getline(), undef,
	   "closing a file handle doesn't change object resolution in aliased classes");
}

    undef *Count::DATA;
    is(Count::DATA->getline(), 'method in Count::DATA',
       'undefining the typeglob does change object resolution');
    is(The::Count::DATA->getline(), 'method in Count::DATA',
       'undefining the typeglob does change object resolution in aliased classes');

    is(Count->getline(), 'method in Count',
       'initial resolution is a method');
    is(The::Count->getline(), 'method in Count',
       'initial resolution is a method in aliased classes');

    eval q{
        open Count, '<', $INC{'Count.pm'}
            or die "Can't open $INC{'Count.pm'}: $!";
1;
    } or die $@@;

    is(Count->getline(), "# zero! ha ha ha\n", 'file handles take priority');
    is(The::Count->getline(), 'method in Count', 'but not in an aliased class');

    eval q{close Count} or die $!;

    {
	no warnings 'io';
	is(Count->getline(), undef,
	   "closing a file handle doesn't change object resolution");
    }

    undef *Count;
    is(Count->getline(), 'method in Count',
       'undefining the typeglob does change object resolution');

    open Colour::H1, 'op/method.t' or die $!;
    while (<Colour::H1>) {
	last if /^__END__/;
    }
    open CLOSED, 'TEST' or die $!;
    close CLOSED or die $!;

    my $fh_start = tell Colour::H1;
    my $data_start = tell DATA;
    is(Colour::H1->getline(), <DATA>, 'read from a file');
    is(Color::H1->getline(), 'method in Color::H1',
       'initial resolution is a method');

    *Color::H1 = *Colour::H1{IO};

    is(Colour::H1->getline(), <DATA>, 'read from a file');
    is(Color::H1->getline(), <DATA>,
       'file handles take priority after io-to-typeglob assignment');

    *Color::H1 = *CLOSED{IO};
    {
	no warnings 'io';
	is(Color::H1->getline(), undef,
	   "assigning a closed a file handle doesn't change object resolution");
    }

    undef *Color::H1;
    is(Color::H1->getline(), 'method in Color::H1',
       'undefining the typeglob does change object resolution');

    *Color::H1 = *Colour::H1;

    is(Color::H1->getline(), <DATA>,
       'file handles take priority after typeglob-to-typeglob assignment');

    seek Colour::H1, $fh_start, Fcntl::SEEK_SET() or die $!;
    seek DATA, $data_start, Fcntl::SEEK_SET() or die $!;

    is(Colour::H1->getline(), <DATA>, 'read from a file');
    is(C3::H1->getline(), 'method in C3::H1', 'initial resolution is a method');

    *Copy:: = \*C3::;
    *C3:: = \*Colour::;

    is(Colour::H1->getline(), <DATA>, 'read from a file');
    is(C3::H1->getline(), <DATA>,
       'file handles take priority after stash aliasing');

    *C3:: = \*Copy::;

    is(C3::H1->getline(), 'method in C3::H1',
       'restoring the stash returns to a method');
}

# RT #123619 constant class name should be read-only

{
    sub RT123619::f { chop $_[0] }
    eval { 'RT123619'->f(); };
    like ($@@, qr/Modification of a read-only value attempted/, 'RT #123619');
}

{
    # RT #126042 &{1==1} * &{1==1} would crash

    # pp_entersub and pp_method_named cooperate to prevent calls to an
    # undefined import() or unimport() method from croaking.
    # If pp_method_named can't find the method it pushes &PL_sv_yes, and
    # pp_entersub checks for that specific SV to avoid croaking.
    # Ideally they wouldn't use that hack but...
    # Unfortunately pp_entersub's handling of that case is broken in scalar context.

    # Rather than using the test case from the ticket, since &{1==1}
    # isn't documented (and may not be supported in future perls) test
    # calls to undefined import method, which also crashes.
    fresh_perl_is('Unknown->import() * Unknown->unimport(); print "ok\n"', "ok\n", {},
                  "check unknown import() methods don't corrupt the stack");
}

__END__
#FF9900
#F78C08
#FFA500
#FF4D00
#FC5100
#FF5D00
@


1.11
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d9 2
a10 2
    @@INC = qw(. ../lib lib);
    require "test.pl";
d16 1
a16 1
plan(tests => 147);
a172 9
{
    no strict 'refs';
    no warnings 'deprecated';
    # this test added due to bug discovery (in 5.004_04, fb73857aa0bfa8ed)
    # Possibly kill this test now that defined @@::array is finally properly
    # deprecated?
    is(defined(@@{"unknown_package::ISA"}) ? "defined" : "undefined", "undefined");
}

d364 1
d408 1
a408 1
    like(NulTest->${ \"nul\0test" }, "nul\0test", "AUTOLOAD is nul-clean");
d464 29
d667 1
a667 1
    is(C3::H1->getline(), 'method in C3::H1', 'intial resolution is a method');
d680 25
@


1.10
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d16 1
a16 1
plan(tests => 142);
d514 18
d535 1
a535 1
    skip_if_miniperl('file handles as methods requires loading IO::File', 25);
d624 1
a624 1
       'file handles take priority after typeglob assignment');
d636 5
@


1.9
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d9 1
a9 1
    @@INC = qw(. ../lib);
d16 1
a16 1
plan(tests => 95);
d226 65
a290 1
# TODO: we need some tests for the SUPER:: pseudoclass
d471 174
@


1.8
log
@merge in perl 5.12.2 plus local changes
@
text
@d1 1
a1 1
#!./perl
d13 4
a16 1
print "1..79\n";
d25 1
a25 1
$obj = bless [], "Pack";
d27 1
a27 1
$mname = "method";
d79 1
a79 1
eval 'sub B::d {"B::d2"}';	# Import now.
d83 2
a84 2
# are already linked to "pruned" globs. Say, `undef &B::d' if it were
# after `delete $B::{d}; sub B::d {}' would reach an old subroutine.
d88 5
d114 1
a114 1
*A::x = *A::d;			# See if cache incorrectly follows synonyms
d116 3
a118 1
is(eval { A->x } || "nope", "nope");
d158 2
d161 1
d163 4
a166 3
  my $method = $AUTOLOAD; 
  *$AUTOLOAD = sub { "new B: In $method, $c" };
  goto &$AUTOLOAD;
d168 1
d173 8
a180 2
# this test added due to bug discovery
is(defined(@@{"unknown_package::ISA"}) ? "defined" : "undefined", "undefined");
d187 1
a187 1
    @@ISA = 'A1';
d205 2
a207 1
# test error messages if method loading fails
d217 1
a217 1
eval '$e = bless {}, "UNIVERSAL"; $e->E::E::foo()';
d262 1
a262 1
	$x = 'x';
d330 77
@


1.7
log
@Merge in perl 5.10.1; part two
@
text
@d13 1
a13 1
print "1..78\n";
a286 1
sub DESTROY {} # IO object destructor called in MacOS, because of Mac::err
d295 13
@


1.6
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d186 6
a191 6
is(do { eval '$e = bless {}, "E::A"; E::A->foo()';
	  $@@ =~ /^\QCan't locate object method "foo" via package "E::A" at/ ? 1 : $@@}, 1);
is(do { eval '$e = bless {}, "E::B"; $e->foo()';  
	  $@@ =~ /^\QCan't locate object method "foo" via package "E::B" at/ ? 1 : $@@}, 1);
is(do { eval 'E::C->foo()';
	  $@@ =~ /^\QCan't locate object method "foo" via package "E::C" (perhaps / ? 1 : $@@}, 1);
d193 4
a196 4
is(do { eval 'UNIVERSAL->E::D::foo()';
	  $@@ =~ /^\QCan't locate object method "foo" via package "E::D" (perhaps / ? 1 : $@@}, 1);
is(do { eval '$e = bless {}, "UNIVERSAL"; $e->E::E::foo()';
	  $@@ =~ /^\QCan't locate object method "foo" via package "E::E" (perhaps / ? 1 : $@@}, 1);
d199 4
a202 4
is(do { eval 'UNIVERSAL->E::F::foo()';
	  $@@ =~ /^\QCan't locate object method "foo" via package "E::F" at/ ? 1 : $@@}, 1);
is(do { eval '$e = bless {}, "UNIVERSAL"; $e->E::F::foo()';
	  $@@ =~ /^\QCan't locate object method "foo" via package "E::F" at/ ? 1 : $@@}, 1);
@


1.5
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d13 1
a13 1
print "1..75\n";
d234 1
a234 1
eval { sub AUTOLOAD { "ok ", shift, "\n"; } };
d280 16
@


1.4
log
@merge in perl 5.6.1 with our local changes
@
text
@d9 2
a10 1
    @@INC = '../lib';
d13 1
a13 1
print "1..53\n";
a20 7
my $cnt = 0;
sub test {
  print "# got `$_[0]', expected `$_[1]'\nnot " unless $_[0] eq $_[1]; 
  # print "not " unless shift eq shift;
  print "ok ", ++$cnt, "\n"
}

d26 26
a51 23
test(Pack->method("a","b","c"), "method,a,b,c");
test(Pack->$mname("a","b","c"), "method,a,b,c");
test(method Pack ("a","b","c"), "method,a,b,c");
test((method Pack "a","b","c"), "method,a,b,c");

test(Pack->method(), "method");
test(Pack->$mname(), "method");
test(method Pack (), "method");
test(Pack->method, "method");
test(Pack->$mname, "method");
test(method Pack, "method");

test($obj->method("a","b","c"), "method,a,b,c");
test($obj->$mname("a","b","c"), "method,a,b,c");
test((method $obj ("a","b","c")), "method,a,b,c");
test((method $obj "a","b","c"), "method,a,b,c");

test($obj->method(), "method");
test($obj->$mname(), "method");
test((method $obj ()), "method");
test($obj->method, "method");
test($obj->$mname, "method");
test(method $obj, "method");
d53 1
a53 1
test( A->d, "C::d");		# Update hash table;
d56 1
a56 1
test (A->d, "D::d");		# Update hash table;
d60 1
a60 1
    test (A->d, "C::d");
d62 1
a62 1
    test (eval { A->d } || "fail", "fail");
d64 1
a64 1
test (A->d, "D::d");
d69 1
a69 1
    test (A->d, "B::d1");	# Update hash table;
d71 1
a71 1
    test ((eval { A->d }, ($@@ =~ /Undefined subroutine/)), 1);
d74 1
a74 1
test (A->d, "D::d");		# Back to previous state
d77 1
a77 1
test (A->d, "B::d2");		# Update hash table;
d85 1
a85 1
test (A->d, "C::d");		# Update hash table;
d88 1
a88 1
test (A->d, "B::d3");		# Update hash table;
d92 1
a92 1
test (A->d, "C::d");
d95 1
a95 1
test (A->d, "B::d4");		# Update hash table;
d98 1
a98 1
test (A->d, "C::d");
d102 1
a102 1
    test (eval { A->d } || "nope", "nope");
d104 1
a104 1
test (A->d, "C::d");
d108 1
a108 1
test (eval { A->x } || "nope", "nope");
d135 2
a136 2
test(A->e(), "C: In C::e, 1");	# We get a correct autoload
test(A->e(), "C: In C::e, 1");	# Which sticks
d138 2
a139 2
test(A->ee(), "B: In A::ee, 2"); # We get a generic autoload, method in top
test(A->ee(), "B: In A::ee, 2"); # Which sticks
d141 2
a142 2
test(Y->f(), "B: In Y::f, 3");	# We vivify a correct method
test(Y->f(), "B: In Y::f, 3");	# Which sticks
d155 2
a156 2
test(A->eee(), "new B: In A::eee, 4");	# We get a correct $autoload
test(A->eee(), "new B: In A::eee, 4");	# Which sticks
d159 1
a159 1
test(defined(@@{"unknown_package::ISA"}) ? "defined" : "undefined", "undefined");
d168 3
a170 3
    test(A2->foo(), "foo");
    test(do { eval 'A2::foo()'; $@@ ? 1 : 0}, 1);
    test(A2->foo(), "foo");
d173 77
d251 9
a259 4
    test(do { use Config; eval 'Config->foo()';
	      $@@ =~ /^\QCan't locate object method "foo" via package "Config" at/ ? 1 : $@@}, 1);
    test(do { use Config; eval '$d = bless {}, "Config"; $d->foo()';
	      $@@ =~ /^\QCan't locate object method "foo" via package "Config" at/ ? 1 : $@@}, 1);
d262 17
a278 4
test(do { eval 'E->foo()';
	  $@@ =~ /^\QCan't locate object method "foo" via package "E" (perhaps / ? 1 : $@@}, 1);
test(do { eval '$e = bless {}, "E"; $e->foo()';
	  $@@ =~ /^\QCan't locate object method "foo" via package "E" (perhaps / ? 1 : $@@}, 1);
@


1.3
log
@perl-5.6.0 + local changes
@
text
@d7 6
a12 1
print "1..49\n";
d175 13
@


1.2
log
@perl5.005_03 (stock)
@
text
@d7 1
a7 1
print "1..26\n";
d22 29
d158 12
@


1.1
log
@perl 5.004_04
@
text
@d7 1
a7 1
print "1..24\n";
d67 6
@


1.1.1.1
log
@perl5.005_03
@
text
@d7 1
a7 1
print "1..26\n";
a66 6
test (A->d, "C::d");

{
    local *C::d;
    test (eval { A->d } || "nope", "nope");
}
@


1.1.1.2
log
@virgin perl 5.6.0
@
text
@d7 1
a7 1
print "1..49\n";
a21 29
# First, some basic checks of method-calling syntax:
$obj = bless [], "Pack";
sub Pack::method { shift; join(",", "method", @@_) }
$mname = "method";

test(Pack->method("a","b","c"), "method,a,b,c");
test(Pack->$mname("a","b","c"), "method,a,b,c");
test(method Pack ("a","b","c"), "method,a,b,c");
test((method Pack "a","b","c"), "method,a,b,c");

test(Pack->method(), "method");
test(Pack->$mname(), "method");
test(method Pack (), "method");
test(Pack->method, "method");
test(Pack->$mname, "method");
test(method Pack, "method");

test($obj->method("a","b","c"), "method,a,b,c");
test($obj->$mname("a","b","c"), "method,a,b,c");
test((method $obj ("a","b","c")), "method,a,b,c");
test((method $obj "a","b","c"), "method,a,b,c");

test($obj->method(), "method");
test($obj->$mname(), "method");
test((method $obj ()), "method");
test($obj->method, "method");
test($obj->$mname, "method");
test(method $obj, "method");

a128 12

# test that failed subroutine calls don't affect method calls
{
    package A1;
    sub foo { "foo" }
    package A2;
    @@ISA = 'A1';
    package main;
    test(A2->foo(), "foo");
    test(do { eval 'A2::foo()'; $@@ ? 1 : 0}, 1);
    test(A2->foo(), "foo");
}
@


1.1.1.3
log
@stock perl 5.6.1
@
text
@d7 1
a7 6
BEGIN {
    chdir 't' if -d 't';
    @@INC = '../lib';
}

print "1..53\n";
a169 13

{
    test(do { use Config; eval 'Config->foo()';
	      $@@ =~ /^\QCan't locate object method "foo" via package "Config" at/ ? 1 : $@@}, 1);
    test(do { use Config; eval '$d = bless {}, "Config"; $d->foo()';
	      $@@ =~ /^\QCan't locate object method "foo" via package "Config" at/ ? 1 : $@@}, 1);
}

test(do { eval 'E->foo()';
	  $@@ =~ /^\QCan't locate object method "foo" via package "E" (perhaps / ? 1 : $@@}, 1);
test(do { eval '$e = bless {}, "E"; $e->foo()';
	  $@@ =~ /^\QCan't locate object method "foo" via package "E" (perhaps / ? 1 : $@@}, 1);

@


1.1.1.4
log
@stock perl 5.8.0 from CPAN
@
text
@d9 1
a9 2
    @@INC = qw(. ../lib);
    require "test.pl";
d12 1
a12 1
print "1..75\n";
d20 7
d32 23
a54 26
is(Pack->method("a","b","c"), "method,a,b,c");
is(Pack->$mname("a","b","c"), "method,a,b,c");
is(method Pack ("a","b","c"), "method,a,b,c");
is((method Pack "a","b","c"), "method,a,b,c");

is(Pack->method(), "method");
is(Pack->$mname(), "method");
is(method Pack (), "method");
is(Pack->method, "method");
is(Pack->$mname, "method");
is(method Pack, "method");

is($obj->method("a","b","c"), "method,a,b,c");
is($obj->$mname("a","b","c"), "method,a,b,c");
is((method $obj ("a","b","c")), "method,a,b,c");
is((method $obj "a","b","c"), "method,a,b,c");

is($obj->method(0), "method,0");
is($obj->method(1), "method,1");

is($obj->method(), "method");
is($obj->$mname(), "method");
is((method $obj ()), "method");
is($obj->method, "method");
is($obj->$mname, "method");
is(method $obj, "method");
d56 1
a56 1
is( A->d, "C::d");		# Update hash table;
d59 1
a59 1
is(A->d, "D::d");		# Update hash table;
d63 1
a63 1
    is(A->d, "C::d");
d65 1
a65 1
    is(eval { A->d } || "fail", "fail");
d67 1
a67 1
is(A->d, "D::d");
d72 1
a72 1
    is(A->d, "B::d1");	# Update hash table;
d74 1
a74 1
    is((eval { A->d }, ($@@ =~ /Undefined subroutine/)), 1);
d77 1
a77 1
is(A->d, "D::d");		# Back to previous state
d80 1
a80 1
is(A->d, "B::d2");		# Update hash table;
d88 1
a88 1
is(A->d, "C::d");		# Update hash table;
d91 1
a91 1
is(A->d, "B::d3");		# Update hash table;
d95 1
a95 1
is(A->d, "C::d");
d98 1
a98 1
is(A->d, "B::d4");		# Update hash table;
d101 1
a101 1
is(A->d, "C::d");
d105 1
a105 1
    is(eval { A->d } || "nope", "nope");
d107 1
a107 1
is(A->d, "C::d");
d111 1
a111 1
is(eval { A->x } || "nope", "nope");
d138 2
a139 2
is(A->e(), "C: In C::e, 1");	# We get a correct autoload
is(A->e(), "C: In C::e, 1");	# Which sticks
d141 2
a142 2
is(A->ee(), "B: In A::ee, 2"); # We get a generic autoload, method in top
is(A->ee(), "B: In A::ee, 2"); # Which sticks
d144 2
a145 2
is(Y->f(), "B: In Y::f, 3");	# We vivify a correct method
is(Y->f(), "B: In Y::f, 3");	# Which sticks
d158 2
a159 2
is(A->eee(), "new B: In A::eee, 4");	# We get a correct $autoload
is(A->eee(), "new B: In A::eee, 4");	# Which sticks
d162 1
a162 1
is(defined(@@{"unknown_package::ISA"}) ? "defined" : "undefined", "undefined");
d171 3
a173 3
    is(A2->foo(), "foo");
    is(do { eval 'A2::foo()'; $@@ ? 1 : 0}, 1);
    is(A2->foo(), "foo");
a175 77
## This test was totally misguided.  It passed before only because the
## code to determine if a package was loaded used to look for the hash
## %Foo::Bar instead of the package Foo::Bar:: -- and Config.pm just
## happens to export %Config.
#  {
#      is(do { use Config; eval 'Config->foo()';
#  	      $@@ =~ /^\QCan't locate object method "foo" via package "Config" at/ ? 1 : $@@}, 1);
#      is(do { use Config; eval '$d = bless {}, "Config"; $d->foo()';
#  	      $@@ =~ /^\QCan't locate object method "foo" via package "Config" at/ ? 1 : $@@}, 1);
#  }


# test error messages if method loading fails
is(do { eval '$e = bless {}, "E::A"; E::A->foo()';
	  $@@ =~ /^\QCan't locate object method "foo" via package "E::A" at/ ? 1 : $@@}, 1);
is(do { eval '$e = bless {}, "E::B"; $e->foo()';  
	  $@@ =~ /^\QCan't locate object method "foo" via package "E::B" at/ ? 1 : $@@}, 1);
is(do { eval 'E::C->foo()';
	  $@@ =~ /^\QCan't locate object method "foo" via package "E::C" (perhaps / ? 1 : $@@}, 1);

is(do { eval 'UNIVERSAL->E::D::foo()';
	  $@@ =~ /^\QCan't locate object method "foo" via package "E::D" (perhaps / ? 1 : $@@}, 1);
is(do { eval '$e = bless {}, "UNIVERSAL"; $e->E::E::foo()';
	  $@@ =~ /^\QCan't locate object method "foo" via package "E::E" (perhaps / ? 1 : $@@}, 1);

$e = bless {}, "E::F";  # force package to exist
is(do { eval 'UNIVERSAL->E::F::foo()';
	  $@@ =~ /^\QCan't locate object method "foo" via package "E::F" at/ ? 1 : $@@}, 1);
is(do { eval '$e = bless {}, "UNIVERSAL"; $e->E::F::foo()';
	  $@@ =~ /^\QCan't locate object method "foo" via package "E::F" at/ ? 1 : $@@}, 1);

# TODO: we need some tests for the SUPER:: pseudoclass

# failed method call or UNIVERSAL::can() should not autovivify packages
is( $::{"Foo::"} || "none", "none");  # sanity check 1
is( $::{"Foo::"} || "none", "none");  # sanity check 2

is( UNIVERSAL::can("Foo", "boogie") ? "yes":"no", "no" );
is( $::{"Foo::"} || "none", "none");  # still missing?

is( Foo->UNIVERSAL::can("boogie")   ? "yes":"no", "no" );
is( $::{"Foo::"} || "none", "none");  # still missing?

is( Foo->can("boogie")              ? "yes":"no", "no" );
is( $::{"Foo::"} || "none", "none");  # still missing?

is( eval 'Foo->boogie(); 1'         ? "yes":"no", "no" );
is( $::{"Foo::"} || "none", "none");  # still missing?

is(do { eval 'Foo->boogie()';
	  $@@ =~ /^\QCan't locate object method "boogie" via package "Foo" (perhaps / ? 1 : $@@}, 1);

eval 'sub Foo::boogie { "yes, sir!" }';
is( $::{"Foo::"} ? "ok" : "none", "ok");  # should exist now
is( Foo->boogie(), "yes, sir!");

# TODO: universal.t should test NoSuchPackage->isa()/can()

# This is actually testing parsing of indirect objects and undefined subs
#   print foo("bar") where foo does not exist is not an indirect object.
#   print foo "bar"  where foo does not exist is an indirect object.
eval { sub AUTOLOAD { "ok ", shift, "\n"; } };
ok(1);

# Bug ID 20010902.002
is(
    eval q[
	$x = 'x';
	sub Foo::x : lvalue { $x }
	Foo->$x = 'ok';
    ] || $@@, 'ok'
);

# An autoloaded, inherited DESTROY may be invoked differently than normal
# methods, and has been known to give rise to spurious warnings
# eg <200203121600.QAA11064@@gizmo.fdgroup.co.uk>

d177 4
a180 9
    use warnings;
    my $w = '';
    local $SIG{__WARN__} = sub { $w = $_[0] };

    sub AutoDest::Base::AUTOLOAD {}
    @@AutoDest::ISA = qw(AutoDest::Base);
    { my $x = bless {}, 'AutoDest'; }
    $w =~ s/\n//g;
    is($w, '');
d183 4
a186 17
# [ID 20020305.025] PACKAGE::SUPER doesn't work anymore

package main;
our @@X;
package Amajor;
sub test {
    push @@main::X, 'Amajor', @@_;
}
package Bminor;
use base qw(Amajor);
package main;
sub Bminor::test {
    $_[0]->Bminor::SUPER::test('x', 'y');
    push @@main::X, 'Bminor', @@_;
}
Bminor->test('y', 'z');
is("@@X", "Amajor Bminor x y Bminor Bminor y z");
@


1.1.1.5
log
@perl 5.8.2 from CPAN
@
text
@d13 1
a13 1
print "1..78\n";
d234 1
a234 1
eval 'sub AUTOLOAD { "ok ", shift, "\n"; }';
a279 16
package main;
for my $meth (['Bar', 'Foo::Bar'],
	      ['SUPER::Bar', 'main::SUPER::Bar'],
	      ['Xyz::SUPER::Bar', 'Xyz::SUPER::Bar'])
{
    fresh_perl_is(<<EOT,
package UNIVERSAL; sub AUTOLOAD { my \$c = shift; print "\$c \$AUTOLOAD\\n" }
sub DESTROY {} # IO object destructor called in MacOS, because of Mac::err
package Xyz;
package main; Foo->$meth->[0]();
EOT
	"Foo $meth->[1]",
	{ switches => [ '-w' ] },
	"check if UNIVERSAL::AUTOLOAD works",
    );
}
@


1.1.1.6
log
@import perl 5.10.1
@
text
@d186 6
a191 6
eval '$e = bless {}, "E::A"; E::A->foo()';
like ($@@, qr/^\QCan't locate object method "foo" via package "E::A" at/);
eval '$e = bless {}, "E::B"; $e->foo()';  
like ($@@, qr/^\QCan't locate object method "foo" via package "E::B" at/);
eval 'E::C->foo()';
like ($@@, qr/^\QCan't locate object method "foo" via package "E::C" (perhaps /);
d193 4
a196 4
eval 'UNIVERSAL->E::D::foo()';
like ($@@, qr/^\QCan't locate object method "foo" via package "E::D" (perhaps /);
eval '$e = bless {}, "UNIVERSAL"; $e->E::E::foo()';
like ($@@, qr/^\QCan't locate object method "foo" via package "E::E" (perhaps /);
d199 4
a202 4
eval 'UNIVERSAL->E::F::foo()';
like ($@@, qr/^\QCan't locate object method "foo" via package "E::F" at/);
eval '$e = bless {}, "UNIVERSAL"; $e->E::F::foo()';
like ($@@, qr/^\QCan't locate object method "foo" via package "E::F" at/);
@


1.1.1.7
log
@Perl 5.12.2 from CPAN
@
text
@d13 1
a13 1
print "1..79\n";
d287 1
a295 13

# Test for #71952: crash when looking for a nonexistent destructor
# Regression introduced by fbb3ee5af3d4
{
    fresh_perl_is(<<'EOT',
sub M::DESTROY; bless {}, "M" ; print "survived\n";
EOT
    "survived",
    {},
	"no crash with a declared but missing DESTROY method"
    );
}

@


1.1.1.8
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d1 1
a1 1
#!./perl -w
d13 1
a13 4
use strict;
no warnings 'once';

plan(tests => 95);
d22 1
a22 1
my $obj = bless [], "Pack";
d24 1
a24 1
my $mname = "method";
d76 1
a76 1
eval 'no warnings "redefine"; sub B::d {"B::d2"}';	# Import now.
d80 2
a81 2
# are already linked to "pruned" globs. Say, 'undef &B::d' if it were
# after 'delete $B::{d}; sub B::d {}' would reach an old subroutine.
a84 5
is(A->d, "C::d");

eval 'sub B::d {"B::d2.5"}';
A->d;				# Update hash table;
my $glob = \delete $B::{d};	# non-void context; hang on to the glob
d106 1
a106 1
*A::x = *A::d;
d108 1
a108 3
is(eval { A->x } || "nope", "nope", 'cache should not follow synonyms');

my $counter;
a147 2
{
no warnings 'redefine';
a148 1
  use warnings;
d150 3
a152 4
  my $method = $::AUTOLOAD; 
  no strict 'refs';
  *$::AUTOLOAD = sub { "new B: In $method, $c" };
  goto &$::AUTOLOAD;
a153 1
}
d158 2
a159 8
{
    no strict 'refs';
    no warnings 'deprecated';
    # this test added due to bug discovery (in 5.004_04, fb73857aa0bfa8ed)
    # Possibly kill this test now that defined @@::array is finally properly
    # deprecated?
    is(defined(@@{"unknown_package::ISA"}) ? "defined" : "undefined", "undefined");
}
d166 1
a166 1
    @@A2::ISA = 'A1';
d184 1
a185 2
my $e;

d195 1
a195 1
eval 'my $e = bless {}, "UNIVERSAL"; $e->E::E::foo()';
d240 1
a240 1
	my $x = 'x'; # Lexical or package variable, 5.6.1 panics.
a307 77
# Test for calling a method on a packag name return by a magic variable
sub TIESCALAR{bless[]}
sub FETCH{"main"}
my $kalled;
sub bolgy { ++$kalled; }
tie my $a, "";
$a->bolgy;
is $kalled, 1, 'calling a class method via a magic variable';

{
    package NulTest;
    sub method { 1 }

    package main;
    eval {
        NulTest->${ \"method\0Whoops" };
    };
    like $@@, qr/Can't locate object method "method\0Whoops" via package "NulTest" at/,
            "method lookup is nul-clean";

    *NulTest::AUTOLOAD = sub { our $AUTOLOAD; return $AUTOLOAD };

    like(NulTest->${ \"nul\0test" }, "nul\0test", "AUTOLOAD is nul-clean");
}


{
    fresh_perl_is(
    q! sub T::DESTROY { $x = $_[0]; } bless [], "T";!,
    "DESTROY created new reference to dead object 'T' during global destruction.",
    {},
	"DESTROY creating a new reference to the object generates a warning."
    );
}

# [perl #43663]
{
    $::{"Just"} = \1;
    sub Just::a_japh { return "$_[0] another Perl hacker," }
    is eval { "Just"->a_japh }, "Just another Perl hacker,",
	'constants do not interfere with class methods';
}

# [perl #109264]
{
    no strict 'vars';
    sub bliggles { 1 }
    sub lbiggles :lvalue { index "foo", "f" }
    ok eval { main->bliggles(my($foo,$bar)) },
      'foo->bar(my($foo,$bar)) is not called in lvalue context';
    ok eval { main->bliggles(our($foo,$bar)) },
      'foo->bar(our($foo,$bar)) is not called in lvalue context';
    ok eval { main->bliggles(local($foo,$bar)) },
      'foo->bar(local($foo,$bar)) is not called in lvalue context';
    ok eval { () = main->lbiggles(my($foo,$bar)); 1 },
      'foo->lv(my($foo,$bar)) is not called in lvalue context';
    ok eval { () = main->lbiggles(our($foo,$bar)); 1 },
      'foo->lv(our($foo,$bar)) is not called in lvalue context';
    ok eval { () = main->lbiggles(local($foo,$bar)); 1 },
      'foo->lv(local($foo,$bar)) is not called in lvalue context';
}

{
   # AUTOLOAD and DESTROY can be declared without a leading sub,
   # like BEGIN and friends.
   package NoSub;

   eval 'AUTOLOAD { our $AUTOLOAD; return $AUTOLOAD }';
   ::ok( !$@@, "AUTOLOAD without a leading sub is legal" );

   eval "DESTROY { ::pass( q!DESTROY without a leading sub is legal and gets called! ) }";
   {
      ::ok( NoSub->can("AUTOLOAD"), "...and sets up an AUTOLOAD normally" );
      ::is( eval { NoSub->bluh }, "NoSub::bluh", "...which works as expected" );
   }
   { bless {}, "NoSub"; }
}
@


1.1.1.9
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d9 1
a9 1
    @@INC = qw(. ../lib lib);
d16 1
a16 1
plan(tests => 142);
d226 1
a226 65
# SUPER:: pseudoclass
@@Saab::ISA = "Souper";
sub Souper::method { @@_ }
@@OtherSaab::ISA = "OtherSouper";
sub OtherSouper::method { "Isidore Ropen, Draft Manager" }
{
   my $o = bless [], "Saab";
   package Saab;
   my @@ret = $o->SUPER::method('whatever');
   ::is $ret[0], $o, 'object passed to SUPER::method';
   ::is $ret[1], 'whatever', 'argument passed to SUPER::method';
   @@ret = $o->SUPER'method('whatever');
   ::is $ret[0], $o, "object passed to SUPER'method";
   ::is $ret[1], 'whatever', "argument passed to SUPER'method";
   @@ret = Saab->SUPER::method;
   ::is $ret[0], 'Saab', "package name passed to SUPER::method";
   @@ret = OtherSaab->SUPER::method;
   ::is $ret[0], 'OtherSaab',
      "->SUPER::method uses current package, not invocant";
}  
() = *SUPER::;
{
   local our @@ISA = "Souper";
   is eval { (main->SUPER::method)[0] }, 'main',
      'Mentioning *SUPER:: does not stop ->SUPER from working in main';
}
{
    BEGIN {
        *Mover:: = *Mover2::;
        *Mover2:: = *foo;
    }
    package Mover;
    no strict;
    # Not our(@@ISA), because the bug we are testing for interacts with an
    # our() bug that cancels this bug out.
    @@ISA = 'door';
    sub door::dohtem { 'dohtem' }
    ::is eval { Mover->SUPER::dohtem; }, 'dohtem',
        'SUPER inside moved package';
    undef *door::dohtem;
    *door::dohtem = sub { 'method' };
    ::is eval { Mover->SUPER::dohtem; }, 'method',
        'SUPER inside moved package respects method changes';
}

package foo120694 {
    BEGIN { our @@ISA = qw(bar120694) }

    sub AUTOLOAD {
        my $self = shift;
        local our $recursive = $recursive;
        return "recursive" if $recursive++;
        return if our $AUTOLOAD eq 'DESTROY';
        $AUTOLOAD = "SUPER:" . substr $AUTOLOAD, rindex($AUTOLOAD, ':');
        return $self->$AUTOLOAD(@@_);
    }
}
package bar120694 {
    sub AUTOLOAD {
        return "xyzzy";
    }
}
is bless( [] => "foo120694" )->plugh, 'xyzzy',
    '->SUPER::method autoloading uses parent of current pkg';

a406 174

eval { () = 3; new {} };
like $@@,
     qr/^Can't call method "new" without a package or object reference/,
    'Err msg from new{} when stack contains a number';
eval { () = "foo"; new {} };
like $@@,
     qr/^Can't call method "new" without a package or object reference/,
    'Err msg from new{} when stack contains a word';
eval { () = undef; new {} };
like $@@,
     qr/^Can't call method "new" without a package or object reference/,
    'Err msg from new{} when stack contains undef';

package egakacp {
  our @@ISA = 'ASI';
  sub ASI::m { shift; "@@_" };
  my @@a = (bless([]), 'arg');
  my $r = SUPER::m{@@a};
  ::is $r, 'arg', 'method{@@array}';
  $r = SUPER::m{}@@a;
  ::is $r, 'arg', 'method{}@@array';
  $r = SUPER::m{@@a}"b";
  ::is $r, 'arg b', 'method{@@array}$more_args';
}

# [perl #114924] SUPER->method
@@SUPER::ISA = "SUPPER";
sub SUPPER::foo { "supper" }
is "SUPER"->foo, 'supper', 'SUPER->method';

sub flomp { "flimp" }
sub main::::flomp { "flump" }
is "::"->flomp, 'flump', 'method call on ::';
is "::main"->flomp, 'flimp', 'method call on ::main';
eval { ""->flomp };
like $@@,
     qr/^Can't call method "flomp" without a package or object reference/,
    'method call on empty string';
is "3foo"->CORE::uc, '3FOO', '"3foo"->CORE::uc';
{ no strict; @@{"3foo::ISA"} = "CORE"; }
is "3foo"->uc, '3FOO', '"3foo"->uc (autobox style!)';

# Test that PL_stashcache doesn't change the resolution behaviour for file
# handles and package names.
SKIP: {
    skip_if_miniperl('file handles as methods requires loading IO::File', 25);
    require Fcntl;

    foreach (qw (Count::DATA Count Colour::H1 Color::H1 C3::H1)) {
	eval qq{
            package $_;

            sub getline {
                return "method in $_";
            }

            1;
        } or die $@@;
    }

    BEGIN {
	*The::Count:: = \*Count::;
    }

    is(Count::DATA->getline(), 'method in Count::DATA',
       'initial resolution is a method');
    is(The::Count::DATA->getline(), 'method in Count::DATA',
       'initial resolution is a method in aliased classes');

    require Count;

    is(Count::DATA->getline(), "one! ha ha ha\n", 'file handles take priority');
    is(The::Count::DATA->getline(), "two! ha ha ha\n",
       'file handles take priority in aliased classes');

    eval q{close Count::DATA} or die $!;

    {
	no warnings 'io';
	is(Count::DATA->getline(), undef,
	   "closing a file handle doesn't change object resolution");
	is(The::Count::DATA->getline(), undef,
	   "closing a file handle doesn't change object resolution in aliased classes");
}

    undef *Count::DATA;
    is(Count::DATA->getline(), 'method in Count::DATA',
       'undefining the typeglob does change object resolution');
    is(The::Count::DATA->getline(), 'method in Count::DATA',
       'undefining the typeglob does change object resolution in aliased classes');

    is(Count->getline(), 'method in Count',
       'initial resolution is a method');
    is(The::Count->getline(), 'method in Count',
       'initial resolution is a method in aliased classes');

    eval q{
        open Count, '<', $INC{'Count.pm'}
            or die "Can't open $INC{'Count.pm'}: $!";
1;
    } or die $@@;

    is(Count->getline(), "# zero! ha ha ha\n", 'file handles take priority');
    is(The::Count->getline(), 'method in Count', 'but not in an aliased class');

    eval q{close Count} or die $!;

    {
	no warnings 'io';
	is(Count->getline(), undef,
	   "closing a file handle doesn't change object resolution");
    }

    undef *Count;
    is(Count->getline(), 'method in Count',
       'undefining the typeglob does change object resolution');

    open Colour::H1, 'op/method.t' or die $!;
    while (<Colour::H1>) {
	last if /^__END__/;
    }
    open CLOSED, 'TEST' or die $!;
    close CLOSED or die $!;

    my $fh_start = tell Colour::H1;
    my $data_start = tell DATA;
    is(Colour::H1->getline(), <DATA>, 'read from a file');
    is(Color::H1->getline(), 'method in Color::H1',
       'initial resolution is a method');

    *Color::H1 = *Colour::H1{IO};

    is(Colour::H1->getline(), <DATA>, 'read from a file');
    is(Color::H1->getline(), <DATA>,
       'file handles take priority after typeglob assignment');

    *Color::H1 = *CLOSED{IO};
    {
	no warnings 'io';
	is(Color::H1->getline(), undef,
	   "assigning a closed a file handle doesn't change object resolution");
    }

    undef *Color::H1;
    is(Color::H1->getline(), 'method in Color::H1',
       'undefining the typeglob does change object resolution');

    seek Colour::H1, $fh_start, Fcntl::SEEK_SET() or die $!;
    seek DATA, $data_start, Fcntl::SEEK_SET() or die $!;

    is(Colour::H1->getline(), <DATA>, 'read from a file');
    is(C3::H1->getline(), 'method in C3::H1', 'intial resolution is a method');

    *Copy:: = \*C3::;
    *C3:: = \*Colour::;

    is(Colour::H1->getline(), <DATA>, 'read from a file');
    is(C3::H1->getline(), <DATA>,
       'file handles take priority after stash aliasing');

    *C3:: = \*Copy::;

    is(C3::H1->getline(), 'method in C3::H1',
       'restoring the stash returns to a method');
}

__END__
#FF9900
#F78C08
#FFA500
#FF4D00
#FC5100
#FF5D00
@


1.1.1.10
log
@Import perl-5.20.1
@
text
@d16 1
a16 1
plan(tests => 147);
a513 18
# *foo vs (\*foo)
sub myclass::squeak { 'eek' }
eval { *myclass->squeak };
like $@@,
     qr/^Can't call method "squeak" without a package or object reference/,
    'method call on typeglob ignores package';
eval { (\*myclass)->squeak };
like $@@,
     qr/^Can't call method "squeak" on unblessed reference/,
    'method call on \*typeglob';
*stdout2 = *STDOUT;  # stdout2 now stringifies as *main::STDOUT
sub IO::Handle::self { $_[0] }
# This used to stringify the glob:
is *stdout2->self, (\*stdout2)->self,
  '*glob->method is equiv to (\*glob)->method';
sub { $_[0] = *STDOUT; is $_[0]->self, \$::h{k}, '$pvlv_glob->method' }
 ->($::h{k});

d517 1
a517 1
    skip_if_miniperl('file handles as methods requires loading IO::File', 26);
d606 1
a606 1
       'file handles take priority after io-to-typeglob assignment');
a617 5

    *Color::H1 = *Colour::H1;

    is(Color::H1->getline(), <DATA>,
       'file handles take priority after typeglob-to-typeglob assignment');
@


1.1.1.11
log
@Import perl-5.24.2
@
text
@d9 2
a10 2
    @@INC = qw(. ../lib lib ../dist/base/lib);
    require "./test.pl";
d16 1
a16 1
plan(tests => 150);
d173 9
a372 1
sub DESTROY {} # prevent AUTOLOAD being called on DESTROY
d416 1
a416 1
    like(NulTest->${ \"nul\0test" }, qr/nul\0test/, "AUTOLOAD is nul-clean");
a471 29
{
    # [perl #124387]
    my $autoloaded;
    package AutoloadDestroy;
    sub AUTOLOAD { $autoloaded = 1 }
    package main;
    bless {}, "AutoloadDestroy";
    ok($autoloaded, "AUTOLOAD called for DESTROY");

    # 127494 - AUTOLOAD for DESTROY was called without setting $AUTOLOAD
    my %methods;
    package AutoloadDestroy2;
    sub AUTOLOAD {
        our $AUTOLOAD;
        (my $method = $AUTOLOAD) =~ s/.*:://;
        ++$methods{$method};
    }
    package main;
    # this cached AUTOLOAD as the DESTROY method
    bless {}, "AutoloadDestroy2";
    %methods = ();
    my $o = bless {}, "AutoloadDestroy2";
    # this sets $AUTOLOAD to "AutoloadDestroy2::foo"
    $o->foo;
    # this would call AUTOLOAD without setting $AUTOLOAD
    undef $o;
    ok($methods{DESTROY}, "\$AUTOLOAD set correctly for DESTROY");
}

d646 1
a646 1
    is(C3::H1->getline(), 'method in C3::H1', 'initial resolution is a method');
a658 25
}

# RT #123619 constant class name should be read-only

{
    sub RT123619::f { chop $_[0] }
    eval { 'RT123619'->f(); };
    like ($@@, qr/Modification of a read-only value attempted/, 'RT #123619');
}

{
    # RT #126042 &{1==1} * &{1==1} would crash

    # pp_entersub and pp_method_named cooperate to prevent calls to an
    # undefined import() or unimport() method from croaking.
    # If pp_method_named can't find the method it pushes &PL_sv_yes, and
    # pp_entersub checks for that specific SV to avoid croaking.
    # Ideally they wouldn't use that hack but...
    # Unfortunately pp_entersub's handling of that case is broken in scalar context.

    # Rather than using the test case from the ticket, since &{1==1}
    # isn't documented (and may not be supported in future perls) test
    # calls to undefined import method, which also crashes.
    fresh_perl_is('Unknown->import() * Unknown->unimport(); print "ok\n"', "ok\n", {},
                  "check unknown import() methods don't corrupt the stack");
@


