head	1.16;
access;
symbols
	OPENBSD_6_1:1.16.0.2
	OPENBSD_6_1_BASE:1.16
	OPENBSD_6_0:1.15.0.10
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.15.0.4
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.15.0.6
	OPENBSD_5_8_BASE:1.15
	PERL_5_20_2:1.1.1.14
	OPENBSD_5_7:1.15.0.2
	OPENBSD_5_7_BASE:1.15
	PERL_5_20_1:1.1.1.14
	OPENBSD_5_6:1.14.0.4
	OPENBSD_5_6_BASE:1.14
	PERL_5_18_2:1.1.1.13
	PERL:1.1.1
	OPENBSD_5_5:1.13.0.6
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.2
	OPENBSD_5_4_BASE:1.13
	PERL_5_16_3:1.1.1.12
	OPENBSD_5_3:1.12.0.10
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.8
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.6
	OPENBSD_5_0:1.12.0.4
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.2
	OPENBSD_4_9_BASE:1.12
	PERL_5_12_2:1.1.1.11
	OPENBSD_4_8:1.11.0.4
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.2
	OPENBSD_4_7_BASE:1.11
	PERL_5_10_1:1.1.1.10
	OPENBSD_4_6:1.10.0.6
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.2
	OPENBSD_4_5_BASE:1.10
	PERL_5_10_0:1.1.1.9
	OPENBSD_4_4:1.9.0.10
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.8
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.6
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.4
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9
	PERL_5_8_8:1.1.1.8
	OPENBSD_3_9:1.8.0.8
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.6
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.4
	OPENBSD_3_7_BASE:1.8
	PERL_5_8_6:1.1.1.7
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	PERL_5_8_5:1.1.1.7
	PERL_5_8_3:1.1.1.6
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.16
date	2017.02.05.00.32.20;	author afresh1;	state Exp;
branches;
next	1.15;
commitid	cxJ08BvJA9Pt2PTM;

1.15
date	2014.11.17.20.57.07;	author afresh1;	state Exp;
branches;
next	1.14;
commitid	QP75iYx42Uo7mMxO;

1.14
date	2014.03.24.15.05.33;	author afresh1;	state Exp;
branches;
next	1.13;

1.13
date	2013.03.25.20.41.00;	author sthen;	state Exp;
branches;
next	1.12;

1.12
date	2010.09.24.15.07.09;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2009.10.12.18.30.28;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2008.09.29.17.36.20;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2006.03.28.19.23.13;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2004.08.09.18.10.27;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.49;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.37;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.36.22;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.08.32;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.52.38;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.08.05.42;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.13.22;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.13.22;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.41.51;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.10.51;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.25.47;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.15.11;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.44.32;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.08.09.17.48.35;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2006.03.28.18.49.46;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2008.09.29.17.19.01;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2009.10.12.18.10.44;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2010.09.24.14.49.17;	author millert;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2013.03.25.20.09.37;	author sthen;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2014.03.24.14.59.10;	author afresh1;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2014.11.17.20.53.18;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.16
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl

BEGIN {
    chdir 't' if -d 't';
    require './test.pl';
    require './charset_tools.pl';
    set_up_inc('../lib');
}

plan tests => 131;

$FS = ':';

$_ = 'a:b:c';

($a,$b,$c) = split($FS,$_);

is(join(';',$a,$b,$c), 'a;b;c', 'Split a simple string into scalars.');

@@ary = split(/:b:/);
$cnt = split(/:b:/);
is(join("$_",@@ary), 'aa:b:cc');
is($cnt, scalar(@@ary));

$_ = "abc\n";
my @@xyz = (@@ary = split(//));
$cnt = split(//);
is(join(".",@@ary), "a.b.c.\n");
is($cnt, scalar(@@ary));

$_ = "a:b:c::::";
@@ary = split(/:/);
$cnt = split(/:/);
is(join(".",@@ary), "a.b.c");
is($cnt, scalar(@@ary));

$_ = join(':',split(' ',"    a b\tc \t d "));
is($_, 'a:b:c:d');
@@ary = split(' ',"    a b\tc \t d ");
$cnt = split(' ',"    a b\tc \t d ");
is($cnt, scalar(@@ary));

$_ = join(':',split(/ */,"foo  bar bie\tdoll"));
is($_ , "f:o:o:b:a:r:b:i:e:\t:d:o:l:l");
@@ary = split(/ */,"foo  bar bie\tdoll");
$cnt = split(/ */,"foo  bar bie\tdoll");
is($cnt, scalar(@@ary));

$_ = join(':', 'foo', split(/ /,'a b  c'), 'bar');
is($_, "foo:a:b::c:bar");
@@ary = split(/ /,'a b  c');
$cnt = split(/ /,'a b  c');
is($cnt, scalar(@@ary));

# Can we say how many fields to split to?
$_ = join(':', split(' ','1 2 3 4 5 6', 3));
is($_, '1:2:3 4 5 6', "Split into a specified number of fields, defined by a literal");
@@ary = split(' ','1 2 3 4 5 6', 3);
$cnt = split(' ','1 2 3 4 5 6', 3);
is($cnt, scalar(@@ary), "Check element count from previous test");

# Can we do it as a variable?
$x = 4;
$_ = join(':', split(' ','1 2 3 4 5 6', $x));
is($_, '1:2:3:4 5 6', "Split into a specified number of fields, defined by a scalar variable");
@@ary = split(' ','1 2 3 4 5 6', $x);
$cnt = split(' ','1 2 3 4 5 6', $x);
is($cnt, scalar(@@ary), "Check element count from previous test");

# Does the 999 suppress null field chopping?
$_ = join(':', split(/:/,'1:2:3:4:5:6:::', 999));
is($_ , '1:2:3:4:5:6:::');
@@ary = split(/:/,'1:2:3:4:5:6:::', 999);
$cnt = split(/:/,'1:2:3:4:5:6:::', 999);
is($cnt, scalar(@@ary));

# Splitting without pattern
$_ = "1 2 3 4";
$_ = join(':', split);
is($_ , '1:2:3:4', "Split and join without specifying a split pattern");

# Does assignment to a list imply split to one more field than that?
$foo = runperl( switches => ['-Dt'], stderr => 1, prog => '($a,$b)=split;' );
ok($foo =~ /DEBUGGING/ || $foo =~ /const\n?\Q(IV(3))\E/);

# Can we say how many fields to split to when assigning to a list?
($a,$b) = split(' ','1 2 3 4 5 6', 2);
$_ = join(':',$a,$b);
is($_, '1:2 3 4 5 6', "Storing split output into list of scalars");

# do subpatterns generate additional fields (without trailing nulls)?
$_ = join '|', split(/,|(-)/, "1-10,20,,,");
is($_, "1|-|10||20");
@@ary = split(/,|(-)/, "1-10,20,,,");
$cnt = split(/,|(-)/, "1-10,20,,,");
is($cnt, scalar(@@ary));

# do subpatterns generate additional fields (with a limit)?
$_ = join '|', split(/,|(-)/, "1-10,20,,,", 10);
is($_, "1|-|10||20||||||");
@@ary = split(/,|(-)/, "1-10,20,,,", 10);
$cnt = split(/,|(-)/, "1-10,20,,,", 10);
is($cnt, scalar(@@ary));

# is the 'two undefs' bug fixed?
(undef, $a, undef, $b) = qw(1 2 3 4);
is("$a|$b", "2|4");

# .. even for locals?
{
  local(undef, $a, undef, $b) = qw(1 2 3 4);
  is("$a|$b", "2|4");
}

# check splitting of null string
$_ = join('|', split(/x/,   '',-1), 'Z');
is($_, "Z");
@@ary = split(/x/,   '',-1);
$cnt = split(/x/,   '',-1);
is($cnt, scalar(@@ary));

$_ = join('|', split(/x/,   '', 1), 'Z');
is($_, "Z");
@@ary = split(/x/,   '', 1);
$cnt = split(/x/,   '', 1);
is($cnt, scalar(@@ary));

$_ = join('|', split(/(p+)/,'',-1), 'Z');
is($_, "Z");
@@ary = split(/(p+)/,'',-1);
$cnt = split(/(p+)/,'',-1);
is($cnt, scalar(@@ary));

$_ = join('|', split(/.?/,  '',-1), 'Z');
is($_, "Z");
@@ary = split(/.?/,  '',-1);
$cnt = split(/.?/,  '',-1);
is($cnt, scalar(@@ary));


# Are /^/m patterns scanned?
$_ = join '|', split(/^a/m, "a b a\na d a", 20);
is($_, "| b a\n| d a");
@@ary = split(/^a/m, "a b a\na d a", 20);
$cnt = split(/^a/m, "a b a\na d a", 20);
is($cnt, scalar(@@ary));

# Are /$/m patterns scanned?
$_ = join '|', split(/a$/m, "a b a\na d a", 20);
is($_, "a b |\na d |");
@@ary = split(/a$/m, "a b a\na d a", 20);
$cnt = split(/a$/m, "a b a\na d a", 20);
is($cnt, scalar(@@ary));

# Are /^/m patterns scanned?
$_ = join '|', split(/^aa/m, "aa b aa\naa d aa", 20);
is($_, "| b aa\n| d aa");
@@ary = split(/^aa/m, "aa b aa\naa d aa", 20);
$cnt = split(/^aa/m, "aa b aa\naa d aa", 20);
is($cnt, scalar(@@ary));

# Are /$/m patterns scanned?
$_ = join '|', split(/aa$/m, "aa b aa\naa d aa", 20);
is($_, "aa b |\naa d |");
@@ary = split(/aa$/m, "aa b aa\naa d aa", 20);
$cnt = split(/aa$/m, "aa b aa\naa d aa", 20);
is($cnt, scalar(@@ary));

# Greedyness:
$_ = "a : b :c: d";
@@ary = split(/\s*:\s*/);
$cnt = split(/\s*:\s*/);
is(($res = join(".",@@ary)), "a.b.c.d", $res);
is($cnt, scalar(@@ary));

# use of match result as pattern (!)
is('p:q:r:s', join ':', split('abc' =~ /b/, 'p1q1r1s'));
@@ary = split('abc' =~ /b/, 'p1q1r1s');
$cnt = split('abc' =~ /b/, 'p1q1r1s');
is($cnt, scalar(@@ary));

# /^/ treated as /^/m
$_ = join ':', split /^/, "ab\ncd\nef\n";
is($_, "ab\n:cd\n:ef\n","check that split /^/ is treated as split /^/m");

$_ = join ':', split /\A/, "ab\ncd\nef\n";
is($_, "ab\ncd\nef\n","check that split /\A/ is NOT treated as split /^/m");

# see if @@a = @@b = split(...) optimization works
@@list1 = @@list2 = split ('p',"a p b c p");
ok(@@list1 == @@list2 &&
   "@@list1" eq "@@list2" &&
   @@list1 == 2 &&
   "@@list1" eq "a   b c ");

# zero-width assertion
$_ = join ':', split /(?=\w)/, "rm b";
is($_, "r:m :b");
@@ary = split /(?=\w)/, "rm b";
$cnt = split /(?=\w)/, "rm b";
is($cnt, scalar(@@ary));

# unicode splittage

@@ary = map {ord} split //, v1.20.300.4000.50000.4000.300.20.1;
$cnt =           split //, v1.20.300.4000.50000.4000.300.20.1;
is("@@ary", "1 20 300 4000 50000 4000 300 20 1");
is($cnt, scalar(@@ary));

@@ary = split(/\x{FE}/, "\x{FF}\x{FE}\x{FD}"); # bug id 20010105.016
$cnt = split(/\x{FE}/, "\x{FF}\x{FE}\x{FD}"); # bug id 20010105.016
ok(@@ary == 2 &&
   $ary[0] eq "\xFF"   && $ary[1] eq "\xFD" &&
   $ary[0] eq "\x{FF}" && $ary[1] eq "\x{FD}");
is($cnt, scalar(@@ary));

@@ary = split(/(\x{FE}\xFE)/, "\xFF\x{FF}\xFE\x{FE}\xFD\x{FD}"); # variant of 31
$cnt = split(/(\x{FE}\xFE)/, "\xFF\x{FF}\xFE\x{FE}\xFD\x{FD}"); # variant of 31
ok(@@ary == 3 &&
   $ary[0] eq "\xFF\xFF"     &&
   $ary[0] eq "\x{FF}\xFF"   &&
   $ary[0] eq "\x{FF}\x{FF}" &&
   $ary[1] eq "\xFE\xFE"     &&
   $ary[1] eq "\x{FE}\xFE"   &&
   $ary[1] eq "\x{FE}\x{FE}" &&
   $ary[2] eq "\xFD\xFD"     &&
   $ary[2] eq "\x{FD}\xFD"   &&
   $ary[2] eq "\x{FD}\x{FD}");
is($cnt, scalar(@@ary));

{
    my @@a = map ord, split(//, join("", map chr, (1234, 123, 2345)));
    my $c =          split(//, join("", map chr, (1234, 123, 2345)));
    is("@@a", "1234 123 2345");
    is($c, scalar(@@a));
}

{
    my $x = 'A';
    my @@a = map ord, split(/$x/, join("", map chr, (1234, ord($x), 2345)));
    my $c =          split(/$x/, join("", map chr, (1234, ord($x), 2345)));
    is("@@a", "1234 2345");
    is($c, scalar(@@a));
}

{
    # bug id 20000427.003 

    use warnings;
    use strict;

    my $sushi = "\x{b36c}\x{5a8c}\x{ff5b}\x{5079}\x{505b}";

    my @@charlist = split //, $sushi;
    my $charnum  = split //, $sushi;
    is($charnum, scalar(@@charlist));
    my $r = '';
    foreach my $ch (@@charlist) {
	$r = $r . " " . sprintf "U+%04X", ord($ch);
    }

    is($r, " U+B36C U+5A8C U+FF5B U+5079 U+505B");
}

{
    my $s = "\x20\x40\x{80}\x{100}\x{80}\x40\x20";

  {
	# bug id 20000426.003

	my ($a, $b, $c) = split(/\x40/, $s);
	ok($a eq "\x20" && $b eq "\x{80}\x{100}\x{80}" && $c eq $a);
  }

    my ($a, $b) = split(/\x{100}/, $s);
    ok($a eq "\x20\x40\x{80}" && $b eq "\x{80}\x40\x20");

    my ($a, $b) = split(/\x{80}\x{100}\x{80}/, $s);
    ok($a eq "\x20\x40" && $b eq "\x40\x20");

  {
	my ($a, $b) = split(/\x40\x{80}/, $s);
	ok($a eq "\x20" && $b eq "\x{100}\x{80}\x40\x20");
  }

    my ($a, $b, $c) = split(/[\x40\x{80}]+/, $s);
    ok($a eq "\x20" && $b eq "\x{100}" && $c eq "\x20");
}

{
    # 20001205.014

    my $a = "ABC\x{263A}";

    my @@b = split( //, $a );
    my $c = split( //, $a );
    is($c, scalar(@@b));

    is(scalar @@b, 4);

    ok(length($b[3]) == 1 && $b[3] eq "\x{263A}");

    $a =~ s/^A/Z/;
    ok(length($a) == 4 && $a eq "ZBC\x{263A}");
}

{
    my @@a = split(/\xFE/, "\xFF\xFE\xFD");
    my $b = split(/\xFE/, "\xFF\xFE\xFD");

    ok(@@a == 2 && $a[0] eq "\xFF" && $a[1] eq "\xFD");
    is($b, scalar(@@a));
}

{
    # check that PMf_WHITE is cleared after \s+ is used
    # reported in <20010627113312.RWGY6087.viemta06@@localhost>
    my $r;
    foreach my $pat ( qr/\s+/, qr/ll/ ) {
	$r = join ':' => split($pat, "hello cruel world");
    }
    is($r, "he:o cruel world");
}


{
    # split /(A)|B/, "1B2" should return (1, undef, 2)
    my @@x = split /(A)|B/, "1B2";
    my $y = split /(A)|B/, "1B2";
    is($y, scalar(@@x));
    ok($x[0] eq '1' and (not defined $x[1]) and $x[2] eq '2');
}

{
    # [perl #17064]
    my $warn;
    local $SIG{__WARN__} = sub { $warn = join '', @@_; chomp $warn };
    my $char = "\x{10f1ff}";
    my @@a = split /\r?\n/, "$char\n";
    my $b = split /\r?\n/, "$char\n";
    is($b, scalar(@@a));
    ok(@@a == 1 && $a[0] eq $char && !defined($warn));
}

{
    # [perl #18195]
    for my $u (0, 1) {
	for my $a (0, 1) {
	    $_ = 'readin,database,readout';
	    utf8::upgrade $_ if $u;
	    /(.+)/;
	    my @@d = split /[,]/,$1;
	    my $e = split /[,]/,$1;
	    is($e, scalar(@@d));
	    is(join (':',@@d), 'readin:database:readout', "[perl #18195]");
	}
    }
}

{
    $p="a,b";
    utf8::upgrade $p;
    eval { @@a=split(/[, ]+/,$p) };
    eval { $b=split(/[, ]+/,$p) };
    is($b, scalar(@@a));
    is ("$@@-@@a-", '-a b-', '#20912 - split() to array with /[]+/ and utf8');
}

{
    # LATIN SMALL LETTER A WITH DIAERESIS, CYRILLIC SMALL LETTER I
    for my $pattern ("\N{U+E4}", "\x{0437}") {
        utf8::upgrade $pattern;
        my @@res;
        for my $str ("a${pattern}b", "axb", "a${pattern}b") {
            @@split = split /$pattern/, $str;
            push @@res, scalar(@@split);
        }
        is($res[0], 2);
        is($res[1], 1);
        is($res[2], 2, '#123469 - split with utf8 pattern after handling non-utf8 EXPR');
    }
}

{
    is (\@@a, \@@{"a"}, '@@a must be global for following test');
    $p="";
    $n = @@a = split /,/,$p;
    is ($n, 0, '#21765 - pmreplroot hack used to return undef for 0 iters');
}

{
    # [perl #28938]
    # assigning off the end of the array after a split could leave garbage
    # in the inner elements

    my $x;
    @@a = split /,/, ',,,,,';
    $a[3]=1;
    $x = \$a[2];
    is (ref $x, 'SCALAR', '#28938 - garbage after extend');
}

{
    my $src = "ABC \0 FOO \0  XYZ";
    my @@s = split(" \0 ", $src);
    my @@r = split(/ \0 /, $src);
    my $cs = split(" \0 ", $src);
    my $cr = split(/ \0 /, $src);
    is(scalar(@@s), 3);
    is($cs, 3);
    is($cr, 3);
    is($s[0], "ABC");
    is($s[1], "FOO");
    is($s[2]," XYZ");
    is(join(':',@@s), join(':',@@r));
}

{
    use constant BANG => {};
    () = split m/,/, "", BANG;
    ok(1);
}

{
    # Bug #69875
    # 'Hybrid' scalar-and-array context
    scalar(our @@PATH = split /::/, "Font::GlyphNames");
           # 'my' doesn't trigger the bug
    is "@@PATH", "Font GlyphNames", "hybrid scalar-and-array context";
}

{
    my @@results;
    my $expr= "foo  bar";
    my $cond;

    @@results= split(0||" ", $expr);
    is @@results, 2, 'split(0||" ") is treated like split(" ")'; #'

    $cond= 0;
    @@results= split $cond ? " " : qr/ /, $expr;
    is @@results, 3, 'split($cond ? " " : qr/ /, $expr) works as expected (like qr/ /)';
    $cond= 1;
    @@results= split $cond ? " " : qr/ /, $expr;
    is @@results, 2, 'split($cond ? " " : qr/ /, $expr) works as expected (like " ")';

    $expr = ' a b c ';
    @@results = split /\s/, $expr;
    is @@results, 4,
        "split on regex of single space metacharacter: captured 4 elements";
    is $results[0], '',
        "split on regex of single space metacharacter: first element is empty string";

    @@results = split / /, $expr;
    is @@results, 4,
        "split on regex of single whitespace: captured 4 elements";
    is $results[0], '',
        "split on regex of single whitespace: first element is empty string";

    @@results = split " ", $expr;
    is @@results, 3,
        "split on string of single whitespace: captured 3 elements";
    is $results[0], 'a',
        "split on string of single whitespace: first element is non-empty";

    $expr = " a \tb c ";
    @@results = split " ", $expr;
    is @@results, 3,
        "split on string of single whitespace: captured 3 elements";
    is $results[0], 'a',
        "split on string of single whitespace: first element is non-empty; multiple contiguous space characters";

    my @@seq;
    for my $cond (0,1,0,1,0) {
        $expr = "  foo  ";
        @@results = split $cond ? qr/ / : " ", $expr;
        push @@seq, scalar(@@results) . ":" . $results[-1];
    }
    is join(" ", @@seq), "1:foo 3:foo 1:foo 3:foo 1:foo",
        qq{split(\$cond ? qr/ / : " ", "$exp") behaves as expected over repeated similar patterns};
}

{
    # 'RT #116086: split "\x20" does not work as documented';
    my @@results;
    my $expr;
    $expr = ' a b c ';
    @@results = split uni_to_native("\x20"), $expr;
    is @@results, 3,
        "RT #116086: split on string of single hex-20: captured 3 elements";
    is $results[0], 'a',
        "RT #116086: split on string of single hex-20: first element is non-empty";

    $expr = " a \tb c ";
    @@results = split uni_to_native("\x20"), $expr;
    is @@results, 3,
        "RT #116086: split on string of single hex-20: captured 3 elements";
    is $results[0], 'a',
        "RT #116086: split on string of single hex-20: first element is non-empty; multiple contiguous space characters";
}

# Nasty interaction between split and use constant
use constant nought => 0;
($a,$b,$c) = split //, $foo, nought;
is nought, 0, 'split does not mangle 0 constants';

*aaa = *bbb;
$aaa[1] = "foobarbaz";
$aaa[1] .= "";
@@aaa = split //, $bbb[1];
is "@@aaa", "f o o b a r b a z",
   'split-to-array does not free its own argument';

() = @@a = split //, "abc";
is "@@a", "a b c", '() = split-to-array';

(@@a = split //, "abc") = 1..10;
is "@@a", '1 2 3', 'assignment to split-to-array (pmtarget/package array)';
{
  my @@a;
  (@@a = split //, "abc") = 1..10;
  is "@@a", '1 2 3', 'assignment to split-to-array (targ/lexical)';
}
(@@{\@@a} = split //, "abc") = 1..10;
is "@@a", '1 2 3', 'assignment to split-to-array (stacked)';
@


1.15
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@a4 1
    @@INC = '../lib';
d6 2
d10 1
a10 1
plan tests => 119;
d184 4
a187 1
is($_, "ab\n:cd\n:ef\n");
d268 1
a268 4
  SKIP: {
    if (ord('A') == 193) {
	skip("EBCDIC", 1);
    } else {
a272 1
    }
d281 1
a281 4
  SKIP: {
    if (ord('A') == 193) {
	skip("EBCDIC", 1);
    }  else {
a283 1
    }
d370 15
d488 1
a488 1
    @@results = split "\x20", $expr;
d495 1
a495 1
    @@results = split "\x20", $expr;
d506 20
@


1.14
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d9 1
a9 1
plan tests => 118;
d491 4
@


1.13
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d9 1
a9 1
plan tests => 102;
d17 1
a17 1
is(join(';',$a,$b,$c), 'a;b;c');
d56 1
a56 1
is($_, '1:2:3 4 5 6');
d59 1
a59 1
is($cnt, scalar(@@ary));
d64 1
a64 1
is($_, '1:2:3:4 5 6');
d67 1
a67 1
is($cnt, scalar(@@ary));
d79 1
a79 1
is($_ , '1:2:3:4');
d88 1
a88 1
is($_, '1:2 3 4 5 6');
d420 71
@


1.12
log
@merge in perl 5.12.2 plus local changes
@
text
@d9 1
a9 1
plan tests => 251;
d76 5
a389 56
}
{
    # check the special casing of split /\s/ and unicode
    use charnames qw(:full);
    # below test data is extracted from
    # PropList-5.0.0.txt
    # Date: 2006-06-07, 23:22:52 GMT [MD]
    #
    # Unicode Character Database
    # Copyright (c) 1991-2006 Unicode, Inc.
    # For terms of use, see http://www.unicode.org/terms_of_use.html
    # For documentation, see UCD.html
    my @@spaces=(
	ord("\t"),      # Cc       <control-0009>
	ord("\n"),      # Cc       <control-000A>
	# not PerlSpace # Cc       <control-000B>
	ord("\f"),      # Cc       <control-000C>
	ord("\r"),      # Cc       <control-000D>
	ord(" "),       # Zs       SPACE
	ord("\N{NEL}"), # Cc       <control-0085>
	ord("\N{NO-BREAK SPACE}"),
			# Zs       NO-BREAK SPACE
        0x1680,         # Zs       OGHAM SPACE MARK
        0x180E,         # Zs       MONGOLIAN VOWEL SEPARATOR
        0x2000..0x200A, # Zs  [11] EN QUAD..HAIR SPACE
        0x2028,         # Zl       LINE SEPARATOR
        0x2029,         # Zp       PARAGRAPH SEPARATOR
        0x202F,         # Zs       NARROW NO-BREAK SPACE
        0x205F,         # Zs       MEDIUM MATHEMATICAL SPACE
        0x3000          # Zs       IDEOGRAPHIC SPACE
    );
    #diag "Have @@{[0+@@spaces]} to test\n";
    foreach my $cp (@@spaces) {
	my $msg = sprintf "Space: U+%04x", $cp;
        my $space = chr($cp);
        my $str="A:$space:B\x{FFFD}";
        chop $str;

        my @@res=split(/\s+/,$str);
        my $cnt=split(/\s+/,$str);
        ok(@@res == 2 && join('-',@@res) eq "A:-:B", "$msg - /\\s+/");
	is($cnt, scalar(@@res), "$msg - /\\s+/ (count)");

        my $s2 = "$space$space:A:$space$space:B\x{FFFD}";
        chop $s2;

        my @@r2 = split(' ',$s2);
	my $c2 = split(' ',$s2);
        ok(@@r2 == 2 && join('-', @@r2) eq ":A:-:B",  "$msg - ' '");
	is($c2, scalar(@@r2), "$msg - ' ' (count)");

        my @@r3 = split(/\s+/, $s2);
        my $c3 = split(/\s+/, $s2);
        ok(@@r3 == 3 && join('-', @@r3) eq "-:A:-:B", "$msg - /\\s+/ No.2");
	is($c3, scalar(@@r3), "$msg - /\\s+/ No.2 (count)");
    }
@


1.11
log
@Merge in perl 5.10.1; part two
@
text
@d9 1
a9 1
plan tests => 136;
d20 1
d22 1
d26 1
d28 1
d32 1
d34 1
d38 3
d44 3
d50 3
d57 3
d65 3
d72 3
d88 3
d95 3
d112 3
d118 3
d124 3
d130 3
d138 3
d145 3
d152 3
d159 3
d166 1
d168 1
d172 3
d190 3
d197 1
d199 1
d202 1
d206 1
d209 1
d220 1
d224 1
d226 1
d232 1
d234 1
d246 2
d295 2
d308 1
d311 1
d328 2
d339 2
d352 2
d363 2
d424 1
d426 1
d432 1
d434 1
d437 1
d439 1
d447 2
d450 2
d462 8
@


1.10
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d9 1
a9 1
plan tests => 135;
d360 6
@


1.9
log
@merge in perl 5.8.8
@
text
@d9 1
a9 1
plan tests => 55;
d300 50
d351 10
@


1.8
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d53 2
a54 6
if ($^O eq 'MSWin32') { $foo = `.\\perl -Dt -e "(\$a,\$b) = split;" 2>&1` }
elsif ($^O eq 'NetWare') { $foo = `perl -Dt -e "(\$a,\$b) = split;" 2>&1` }
elsif ($^O eq 'VMS')  { $foo = `./perl "-Dt" -e "(\$a,\$b) = split;" 2>&1` }
elsif ($^O eq 'MacOS'){ $foo = `$^X "-Dt" -e "(\$a,\$b) = split;"` }
else                  { $foo = `./perl -Dt -e '(\$a,\$b) = split;' 2>&1` }
ok($foo =~ /DEBUGGING/ || $foo =~ /\Qconst(IV(3))\E/);
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d9 1
a9 1
plan tests => 54;
d53 6
a58 6
if ($^O eq 'MSWin32') { $foo = `.\\perl -D1024 -e "(\$a,\$b) = split;" 2>&1` }
elsif ($^O eq 'NetWare') { $foo = `perl -D1024 -e "(\$a,\$b) = split;" 2>&1` }
elsif ($^O eq 'VMS')  { $foo = `./perl "-D1024" -e "(\$a,\$b) = split;" 2>&1` }
elsif ($^O eq 'MacOS'){ $foo = `$^X "-D1024" -e "(\$a,\$b) = split;"` }
else                  { $foo = `./perl -D1024 -e '(\$a,\$b) = split;' 2>&1` }
ok($foo =~ /DEBUGGING/ || $foo =~ /SV = (VOID|IV\(3\))/);
d292 13
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d6 1
d9 1
a9 1
print "1..46\n";
d17 1
a17 1
if (join(';',$a,$b,$c) eq 'a;b;c') {print "ok 1\n";} else {print "not ok 1\n";}
d20 1
a20 1
if (join("$_",@@ary) eq 'aa:b:cc') {print "ok 2\n";} else {print "not ok 2\n";}
d24 1
a24 1
if (join(".",@@ary) eq "a.b.c.\n") {print "ok 3\n";} else {print "not ok 3\n";}
d28 1
a28 1
if (join(".",@@ary) eq "a.b.c") {print "ok 4\n";} else {print "not ok 4\n";}
d31 1
a31 1
if ($_ eq 'a:b:c:d') {print "ok 5\n";} else {print "not ok 5 #$_#\n";}
d34 1
a34 2
if ($_ eq "f:o:o:b:a:r:b:i:e:\t:d:o:l:l")
	{print "ok 6\n";} else {print "not ok 6\n";}
d37 1
a37 1
if ($_ eq "foo:a:b::c:bar") {print "ok 7\n";} else {print "not ok 7 $_\n";}
d41 1
a41 1
print $_ eq '1:2:3 4 5 6' ? "ok 8\n" : "not ok 8 $_\n";
d46 1
a46 1
print $_ eq '1:2:3:4 5 6' ? "ok 9\n" : "not ok 9 $_\n";
d50 1
a50 1
print $_ eq '1:2:3:4:5:6:::' ? "ok 10\n" : "not ok 10 $_\n";
d58 1
a58 1
print $foo =~ /DEBUGGING/ || $foo =~ /SV = (VOID|IV\(3\))/ ? "ok 11\n" : "not ok 11\n";
d63 1
a63 1
print $_ eq '1:2 3 4 5 6' ? "ok 12\n" : "not ok 12 $_\n";
d67 1
a67 1
print $_ eq "1|-|10||20" ? "ok 13\n" : "not ok 13\n";
d71 1
a71 1
print $_ eq "1|-|10||20||||||" ? "ok 14\n" : "not ok 14\n";
d75 1
a75 1
print "$a|$b" eq "2|4" ? "ok 15\n" : "not ok 15\n";
d80 1
a80 1
  print "$a|$b" eq "2|4" ? "ok 16\n" : "not ok 16\n";
d85 1
a85 1
print $_ eq "Z" ? "ok 17\n" : "#$_\nnot ok 17\n";
d88 1
a88 1
print $_ eq "Z" ? "ok 18\n" : "#$_\nnot ok 18\n";
d91 1
a91 1
print $_ eq "Z" ? "ok 19\n" : "#$_\nnot ok 19\n";
d94 1
a94 1
print $_ eq "Z" ? "ok 20\n" : "#$_\nnot ok 20\n";
d99 1
a99 1
print $_ eq "| b a\n| d a" ? "ok 21\n" : "not ok 21\n# `$_'\n";
d103 1
a103 1
print $_ eq "a b |\na d |" ? "ok 22\n" : "not ok 22\n# `$_'\n";
d107 1
a107 1
print $_ eq "| b aa\n| d aa" ? "ok 23\n" : "not ok 23\n# `$_'\n";
d111 1
a111 1
print $_ eq "aa b |\naa d |" ? "ok 24\n" : "not ok 24\n# `$_'\n";
d116 1
a116 1
if (($res = join(".",@@ary)) eq "a.b.c.d") {print "ok 25\n";} else {print "not ok 25\n# res=`$res' != `a.b.c.d'\n";}
d119 1
a119 2
'p:q:r:s' eq join ':', split('abc' =~ /b/, 'p1q1r1s') or print "not ";
print "ok 26\n";
d123 1
a123 2
print "not " if $_ ne "ab\n:cd\n:ef\n";
print "ok 27\n";
d127 4
a130 3
print "not " if @@list1 != @@list2 or "@@list1" ne "@@list2"
             or @@list1 != 2 or "@@list1" ne "a   b c ";
print "ok 28\n";
d134 1
a134 2
print "not" if $_ ne "r:m :b";
print "ok 29\n";
d139 1
a139 2
print "not " unless "@@ary" eq "1 20 300 4000 50000 4000 300 20 1";
print "ok 30\n";
d142 3
a144 4
print "not " unless @@ary == 2 &&
                    $ary[0] eq "\xFF"   && $ary[1] eq "\xFD" &&
                    $ary[0] eq "\x{FF}" && $ary[1] eq "\x{FD}";
print "ok 31\n";
d147 10
a156 12
print "not " unless @@ary == 3 &&
                    $ary[0] eq "\xFF\xFF"     &&
                    $ary[0] eq "\x{FF}\xFF"   &&
                    $ary[0] eq "\x{FF}\x{FF}" &&
                    $ary[1] eq "\xFE\xFE"     &&
                    $ary[1] eq "\x{FE}\xFE"   &&
                    $ary[1] eq "\x{FE}\x{FE}" &&
                    $ary[2] eq "\xFD\xFD"     &&
                    $ary[2] eq "\x{FD}\xFD"   &&
                    $ary[2] eq "\x{FD}\x{FD}";
print "ok 32\n";

d160 1
a160 2
    print "not " unless "@@a" eq "1234 123 2345";
    print "ok 33\n";
d166 1
a166 2
    print "not " unless "@@a" eq "1234 2345";
    print "ok 34\n";
d183 1
a183 2
    print "not " unless $r eq " U+B36C U+5A8C U+FF5B U+5079 U+505B";
    print "ok 35\n";
d189 1
d191 1
a191 1
	print "ok 36 # Skip: EBCDIC\n";
a194 1

d196 1
a196 3
	print "not "
	    unless $a eq "\x20" && $b eq "\x{80}\x{100}\x{80}" && $c eq $a;
	print "ok 36\n";
d198 1
d201 1
a201 2
    print "not " unless $a eq "\x20\x40\x{80}" && $b eq "\x{80}\x40\x20";
    print "ok 37\n";
d204 1
a204 2
    print "not " unless $a eq "\x20\x40" && $b eq "\x40\x20";
    print "ok 38\n";
d206 1
d208 1
a208 1
	print "ok 39 # Skip: EBCDIC\n";
d211 1
a211 2
	print "not " unless $a eq "\x20" && $b eq "\x{100}\x{80}\x40\x20";
	print "ok 39\n";
d213 1
d216 1
a216 2
    print "not " unless $a eq "\x20" && $b eq "\x{100}" && $c eq "\x20";
    print "ok 40\n";
d226 1
a226 2
    print "not " unless @@b == 4;
    print "ok 41\n";
d228 1
a228 2
    print "not " unless length($b[3]) == 1 && $b[3] eq "\x{263A}";
    print "ok 42\n";
d231 1
a231 2
    print "not " unless length($a) == 4 && $a eq "ZBC\x{263A}";
    print "ok 43\n";
d237 1
a237 2
    print "not " unless @@a == 2 && $a[0] eq "\xFF" && $a[1] eq "\xFD";
    print "ok 44\n";
d247 1
a247 2
    print "not " unless $r eq "he:o cruel world";
    print "ok 45\n";
d254 37
a290 5
    print "not " unless
      $x[0] eq '1' and
      (not defined $x[1]) and
      $x[2] eq '2';
    print "ok 46\n";
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d3 6
a8 1
print "1..29\n";
d22 1
a22 1
@@xyz = (@@ary = split(//));
d54 1
d56 1
d137 140
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d3 1
a3 3
# $RCSfile: split.t,v $$Revision: 4.1 $$Date: 92/08/07 18:28:26 $

print "1..25\n";
d110 20
@


1.3
log
@perl5.005_03 (stock)
@
text
@d51 1
d53 1
a53 4
if ($foo =~ /DCL-W-NOCOMD/) {
  $foo = `\$ mcr sys\$disk:[]perl. "-D1024" -e "(\$a,\$b) = split;"`;
}
print $foo =~ /DEBUGGING/ || $foo =~ /SV = IV\(3\)/ ? "ok 11\n" : "not ok 11\n";
@


1.2
log
@perl 5.004_04
@
text
@d5 1
a5 1
print "1..20\n";
d93 21
@


1.1
log
@Initial revision
@
text
@d5 1
a5 1
print "1..12\n";
d50 2
a51 1
$foo = `./perl -D1024 -e '(\$a,\$b) = split;' 2>&1`;
d61 31
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d5 1
a5 1
print "1..25\n";
d50 1
a50 2
if ($^O eq 'MSWin32') { $foo = `.\\perl -D1024 -e "(\$a,\$b) = split;" 2>&1` }
else                  { $foo = `./perl -D1024 -e '(\$a,\$b) = split;' 2>&1` }
a60 52
# do subpatterns generate additional fields (without trailing nulls)?
$_ = join '|', split(/,|(-)/, "1-10,20,,,");
print $_ eq "1|-|10||20" ? "ok 13\n" : "not ok 13\n";

# do subpatterns generate additional fields (with a limit)?
$_ = join '|', split(/,|(-)/, "1-10,20,,,", 10);
print $_ eq "1|-|10||20||||||" ? "ok 14\n" : "not ok 14\n";

# is the 'two undefs' bug fixed?
(undef, $a, undef, $b) = qw(1 2 3 4);
print "$a|$b" eq "2|4" ? "ok 15\n" : "not ok 15\n";

# .. even for locals?
{
  local(undef, $a, undef, $b) = qw(1 2 3 4);
  print "$a|$b" eq "2|4" ? "ok 16\n" : "not ok 16\n";
}

# check splitting of null string
$_ = join('|', split(/x/,   '',-1), 'Z');
print $_ eq "Z" ? "ok 17\n" : "#$_\nnot ok 17\n";

$_ = join('|', split(/x/,   '', 1), 'Z');
print $_ eq "Z" ? "ok 18\n" : "#$_\nnot ok 18\n";

$_ = join('|', split(/(p+)/,'',-1), 'Z');
print $_ eq "Z" ? "ok 19\n" : "#$_\nnot ok 19\n";

$_ = join('|', split(/.?/,  '',-1), 'Z');
print $_ eq "Z" ? "ok 20\n" : "#$_\nnot ok 20\n";


# Are /^/m patterns scanned?
$_ = join '|', split(/^a/m, "a b a\na d a", 20);
print $_ eq "| b a\n| d a" ? "ok 21\n" : "not ok 21\n# `$_'\n";

# Are /$/m patterns scanned?
$_ = join '|', split(/a$/m, "a b a\na d a", 20);
print $_ eq "a b |\na d |" ? "ok 22\n" : "not ok 22\n# `$_'\n";

# Are /^/m patterns scanned?
$_ = join '|', split(/^aa/m, "aa b aa\naa d aa", 20);
print $_ eq "| b aa\n| d aa" ? "ok 23\n" : "not ok 23\n# `$_'\n";

# Are /$/m patterns scanned?
$_ = join '|', split(/aa$/m, "aa b aa\naa d aa", 20);
print $_ eq "aa b |\naa d |" ? "ok 24\n" : "not ok 24\n# `$_'\n";

# Greedyness:
$_ = "a : b :c: d";
@@ary = split(/\s*:\s*/);
if (($res = join(".",@@ary)) eq "a.b.c.d") {print "ok 25\n";} else {print "not ok 25\n# res=`$res' != `a.b.c.d'\n";}
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@a50 1
elsif ($^O eq 'VMS')  { $foo = `./perl "-D1024" -e "(\$a,\$b) = split;" 2>&1` }
d52 4
a55 1
print $foo =~ /DEBUGGING/ || $foo =~ /SV = (VOID|IV\(3\))/ ? "ok 11\n" : "not ok 11\n";
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d3 3
a5 1
print "1..29\n";
a111 20

# use of match result as pattern (!)
'p:q:r:s' eq join ':', split('abc' =~ /b/, 'p1q1r1s') or print "not ";
print "ok 26\n";

# /^/ treated as /^/m
$_ = join ':', split /^/, "ab\ncd\nef\n";
print "not " if $_ ne "ab\n:cd\n:ef\n";
print "ok 27\n";

# see if @@a = @@b = split(...) optimization works
@@list1 = @@list2 = split ('p',"a p b c p");
print "not " if @@list1 != @@list2 or "@@list1" ne "@@list2"
             or @@list1 != 2 or "@@list1" ne "a   b c ";
print "ok 28\n";

# zero-width assertion
$_ = join ':', split /(?=\w)/, "rm b";
print "not" if $_ ne "r:m :b";
print "ok 29\n";
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d3 1
a3 6
BEGIN {
    chdir 't' if -d 't';
    @@INC = '../lib';
}

print "1..46\n";
d17 1
a17 1
my @@xyz = (@@ary = split(//));
a48 1
elsif ($^O eq 'NetWare') { $foo = `perl -D1024 -e "(\$a,\$b) = split;" 2>&1` }
a49 1
elsif ($^O eq 'MacOS'){ $foo = `$^X "-D1024" -e "(\$a,\$b) = split;"` }
a129 140

# unicode splittage

@@ary = map {ord} split //, v1.20.300.4000.50000.4000.300.20.1;
print "not " unless "@@ary" eq "1 20 300 4000 50000 4000 300 20 1";
print "ok 30\n";

@@ary = split(/\x{FE}/, "\x{FF}\x{FE}\x{FD}"); # bug id 20010105.016
print "not " unless @@ary == 2 &&
                    $ary[0] eq "\xFF"   && $ary[1] eq "\xFD" &&
                    $ary[0] eq "\x{FF}" && $ary[1] eq "\x{FD}";
print "ok 31\n";

@@ary = split(/(\x{FE}\xFE)/, "\xFF\x{FF}\xFE\x{FE}\xFD\x{FD}"); # variant of 31
print "not " unless @@ary == 3 &&
                    $ary[0] eq "\xFF\xFF"     &&
                    $ary[0] eq "\x{FF}\xFF"   &&
                    $ary[0] eq "\x{FF}\x{FF}" &&
                    $ary[1] eq "\xFE\xFE"     &&
                    $ary[1] eq "\x{FE}\xFE"   &&
                    $ary[1] eq "\x{FE}\x{FE}" &&
                    $ary[2] eq "\xFD\xFD"     &&
                    $ary[2] eq "\x{FD}\xFD"   &&
                    $ary[2] eq "\x{FD}\x{FD}";
print "ok 32\n";


{
    my @@a = map ord, split(//, join("", map chr, (1234, 123, 2345)));
    print "not " unless "@@a" eq "1234 123 2345";
    print "ok 33\n";
}

{
    my $x = 'A';
    my @@a = map ord, split(/$x/, join("", map chr, (1234, ord($x), 2345)));
    print "not " unless "@@a" eq "1234 2345";
    print "ok 34\n";
}

{
    # bug id 20000427.003 

    use warnings;
    use strict;

    my $sushi = "\x{b36c}\x{5a8c}\x{ff5b}\x{5079}\x{505b}";

    my @@charlist = split //, $sushi;
    my $r = '';
    foreach my $ch (@@charlist) {
	$r = $r . " " . sprintf "U+%04X", ord($ch);
    }

    print "not " unless $r eq " U+B36C U+5A8C U+FF5B U+5079 U+505B";
    print "ok 35\n";
}

{
    my $s = "\x20\x40\x{80}\x{100}\x{80}\x40\x20";

    if (ord('A') == 193) {
	print "ok 36 # Skip: EBCDIC\n";
    } else {
	# bug id 20000426.003


	my ($a, $b, $c) = split(/\x40/, $s);
	print "not "
	    unless $a eq "\x20" && $b eq "\x{80}\x{100}\x{80}" && $c eq $a;
	print "ok 36\n";
    }

    my ($a, $b) = split(/\x{100}/, $s);
    print "not " unless $a eq "\x20\x40\x{80}" && $b eq "\x{80}\x40\x20";
    print "ok 37\n";

    my ($a, $b) = split(/\x{80}\x{100}\x{80}/, $s);
    print "not " unless $a eq "\x20\x40" && $b eq "\x40\x20";
    print "ok 38\n";

    if (ord('A') == 193) {
	print "ok 39 # Skip: EBCDIC\n";
    }  else {
	my ($a, $b) = split(/\x40\x{80}/, $s);
	print "not " unless $a eq "\x20" && $b eq "\x{100}\x{80}\x40\x20";
	print "ok 39\n";
    }

    my ($a, $b, $c) = split(/[\x40\x{80}]+/, $s);
    print "not " unless $a eq "\x20" && $b eq "\x{100}" && $c eq "\x20";
    print "ok 40\n";
}

{
    # 20001205.014

    my $a = "ABC\x{263A}";

    my @@b = split( //, $a );

    print "not " unless @@b == 4;
    print "ok 41\n";

    print "not " unless length($b[3]) == 1 && $b[3] eq "\x{263A}";
    print "ok 42\n";

    $a =~ s/^A/Z/;
    print "not " unless length($a) == 4 && $a eq "ZBC\x{263A}";
    print "ok 43\n";
}

{
    my @@a = split(/\xFE/, "\xFF\xFE\xFD");

    print "not " unless @@a == 2 && $a[0] eq "\xFF" && $a[1] eq "\xFD";
    print "ok 44\n";
}

{
    # check that PMf_WHITE is cleared after \s+ is used
    # reported in <20010627113312.RWGY6087.viemta06@@localhost>
    my $r;
    foreach my $pat ( qr/\s+/, qr/ll/ ) {
	$r = join ':' => split($pat, "hello cruel world");
    }
    print "not " unless $r eq "he:o cruel world";
    print "ok 45\n";
}


{
    # split /(A)|B/, "1B2" should return (1, undef, 2)
    my @@x = split /(A)|B/, "1B2";
    print "not " unless
      $x[0] eq '1' and
      (not defined $x[1]) and
      $x[2] eq '2';
    print "ok 46\n";
}
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@a5 1
    require './test.pl';
d8 1
a8 1
plan tests => 54;
d16 1
a16 1
is(join(';',$a,$b,$c), 'a;b;c');
d19 1
a19 1
is(join("$_",@@ary), 'aa:b:cc');
d23 1
a23 1
is(join(".",@@ary), "a.b.c.\n");
d27 1
a27 1
is(join(".",@@ary), "a.b.c");
d30 1
a30 1
is($_, 'a:b:c:d');
d33 2
a34 1
is($_ , "f:o:o:b:a:r:b:i:e:\t:d:o:l:l");
d37 1
a37 1
is($_, "foo:a:b::c:bar");
d41 1
a41 1
is($_, '1:2:3 4 5 6');
d46 1
a46 1
is($_, '1:2:3:4 5 6');
d50 1
a50 1
is($_ , '1:2:3:4:5:6:::');
d58 1
a58 1
ok($foo =~ /DEBUGGING/ || $foo =~ /SV = (VOID|IV\(3\))/);
d63 1
a63 1
is($_, '1:2 3 4 5 6');
d67 1
a67 1
is($_, "1|-|10||20");
d71 1
a71 1
is($_, "1|-|10||20||||||");
d75 1
a75 1
is("$a|$b", "2|4");
d80 1
a80 1
  is("$a|$b", "2|4");
d85 1
a85 1
is($_, "Z");
d88 1
a88 1
is($_, "Z");
d91 1
a91 1
is($_, "Z");
d94 1
a94 1
is($_, "Z");
d99 1
a99 1
is($_, "| b a\n| d a");
d103 1
a103 1
is($_, "a b |\na d |");
d107 1
a107 1
is($_, "| b aa\n| d aa");
d111 1
a111 1
is($_, "aa b |\naa d |");
d116 1
a116 1
is(($res = join(".",@@ary)), "a.b.c.d", $res);
d119 2
a120 1
is('p:q:r:s', join ':', split('abc' =~ /b/, 'p1q1r1s'));
d124 2
a125 1
is($_, "ab\n:cd\n:ef\n");
d129 3
a131 4
ok(@@list1 == @@list2 &&
   "@@list1" eq "@@list2" &&
   @@list1 == 2 &&
   "@@list1" eq "a   b c ");
d135 2
a136 1
is($_, "r:m :b");
d141 2
a142 1
is("@@ary", "1 20 300 4000 50000 4000 300 20 1");
d145 4
a148 3
ok(@@ary == 2 &&
   $ary[0] eq "\xFF"   && $ary[1] eq "\xFD" &&
   $ary[0] eq "\x{FF}" && $ary[1] eq "\x{FD}");
d151 12
a162 10
ok(@@ary == 3 &&
   $ary[0] eq "\xFF\xFF"     &&
   $ary[0] eq "\x{FF}\xFF"   &&
   $ary[0] eq "\x{FF}\x{FF}" &&
   $ary[1] eq "\xFE\xFE"     &&
   $ary[1] eq "\x{FE}\xFE"   &&
   $ary[1] eq "\x{FE}\x{FE}" &&
   $ary[2] eq "\xFD\xFD"     &&
   $ary[2] eq "\x{FD}\xFD"   &&
   $ary[2] eq "\x{FD}\x{FD}");
d166 2
a167 1
    is("@@a", "1234 123 2345");
d173 2
a174 1
    is("@@a", "1234 2345");
d191 2
a192 1
    is($r, " U+B36C U+5A8C U+FF5B U+5079 U+505B");
a197 1
  SKIP: {
d199 1
a199 1
	skip("EBCDIC", 1);
d203 1
d205 3
a207 1
	ok($a eq "\x20" && $b eq "\x{80}\x{100}\x{80}" && $c eq $a);
a208 1
  }
d211 2
a212 1
    ok($a eq "\x20\x40\x{80}" && $b eq "\x{80}\x40\x20");
d215 2
a216 1
    ok($a eq "\x20\x40" && $b eq "\x40\x20");
a217 1
  SKIP: {
d219 1
a219 1
	skip("EBCDIC", 1);
d222 2
a223 1
	ok($a eq "\x20" && $b eq "\x{100}\x{80}\x40\x20");
a224 1
  }
d227 2
a228 1
    ok($a eq "\x20" && $b eq "\x{100}" && $c eq "\x20");
d238 2
a239 1
    is(scalar @@b, 4);
d241 2
a242 1
    ok(length($b[3]) == 1 && $b[3] eq "\x{263A}");
d245 2
a246 1
    ok(length($a) == 4 && $a eq "ZBC\x{263A}");
d252 2
a253 1
    ok(@@a == 2 && $a[0] eq "\xFF" && $a[1] eq "\xFD");
d263 2
a264 1
    is($r, "he:o cruel world");
d271 5
a275 37
    ok($x[0] eq '1' and (not defined $x[1]) and $x[2] eq '2');
}

{
    # [perl #17064]
    my $warn;
    local $SIG{__WARN__} = sub { $warn = join '', @@_; chomp $warn };
    my $char = "\x{10f1ff}";
    my @@a = split /\r?\n/, "$char\n";
    ok(@@a == 1 && $a[0] eq $char && !defined($warn));
}

{
    # [perl #18195]
    for my $u (0, 1) {
	for my $a (0, 1) {
	    $_ = 'readin,database,readout';
	    utf8::upgrade $_ if $u;
	    /(.+)/;
	    my @@d = split /[,]/,$1;
	    is(join (':',@@d), 'readin:database:readout', "[perl #18195]");
	}
    }
}

{
    $p="a,b";
    utf8::upgrade $p;
    eval { @@a=split(/[, ]+/,$p) };
    is ("$@@-@@a-", '-a b-', '#20912 - split() to array with /[]+/ and utf8');
}

{
    is (\@@a, \@@{"a"}, '@@a must be global for following test');
    $p="";
    $n = @@a = split /,/,$p;
    is ($n, 0, '#21765 - pmreplroot hack used to return undef for 0 iters');
@


1.1.1.7
log
@Import of stock perl 5.8.5
@
text
@d9 1
a9 1
plan tests => 55;
d53 6
a58 6
if ($^O eq 'MSWin32') { $foo = `.\\perl -Dt -e "(\$a,\$b) = split;" 2>&1` }
elsif ($^O eq 'NetWare') { $foo = `perl -Dt -e "(\$a,\$b) = split;" 2>&1` }
elsif ($^O eq 'VMS')  { $foo = `./perl "-Dt" -e "(\$a,\$b) = split;" 2>&1` }
elsif ($^O eq 'MacOS'){ $foo = `$^X "-Dt" -e "(\$a,\$b) = split;"` }
else                  { $foo = `./perl -Dt -e '(\$a,\$b) = split;' 2>&1` }
ok($foo =~ /DEBUGGING/ || $foo =~ /\Qconst(IV(3))\E/);
a291 13

{
    # [perl #28938]
    # assigning off the end of the array after a split could leave garbage
    # in the inner elements

    my $x;
    @@a = split /,/, ',,,,,';
    $a[3]=1;
    $x = \$a[2];
    is (ref $x, 'SCALAR', '#28938 - garbage after extend');
}

@


1.1.1.8
log
@perl 5.8.8 import
@
text
@d53 6
a58 2
$foo = runperl( switches => ['-Dt'], stderr => 1, prog => '($a,$b)=split;' );
ok($foo =~ /DEBUGGING/ || $foo =~ /const\n?\Q(IV(3))\E/);
@


1.1.1.9
log
@import perl 5.10.0 from CPAN
@
text
@d9 1
a9 1
plan tests => 135;
a299 50
{
    # check the special casing of split /\s/ and unicode
    use charnames qw(:full);
    # below test data is extracted from
    # PropList-5.0.0.txt
    # Date: 2006-06-07, 23:22:52 GMT [MD]
    #
    # Unicode Character Database
    # Copyright (c) 1991-2006 Unicode, Inc.
    # For terms of use, see http://www.unicode.org/terms_of_use.html
    # For documentation, see UCD.html
    my @@spaces=(
	ord("\t"),      # Cc       <control-0009>
	ord("\n"),      # Cc       <control-000A>
	# not PerlSpace # Cc       <control-000B>
	ord("\f"),      # Cc       <control-000C>
	ord("\r"),      # Cc       <control-000D>
	ord(" "),       # Zs       SPACE
	ord("\N{NEL}"), # Cc       <control-0085>
	ord("\N{NO-BREAK SPACE}"),
			# Zs       NO-BREAK SPACE
        0x1680,         # Zs       OGHAM SPACE MARK
        0x180E,         # Zs       MONGOLIAN VOWEL SEPARATOR
        0x2000..0x200A, # Zs  [11] EN QUAD..HAIR SPACE
        0x2028,         # Zl       LINE SEPARATOR
        0x2029,         # Zp       PARAGRAPH SEPARATOR
        0x202F,         # Zs       NARROW NO-BREAK SPACE
        0x205F,         # Zs       MEDIUM MATHEMATICAL SPACE
        0x3000          # Zs       IDEOGRAPHIC SPACE
    );
    #diag "Have @@{[0+@@spaces]} to test\n";
    foreach my $cp (@@spaces) {
	my $msg = sprintf "Space: U+%04x", $cp;
        my $space = chr($cp);
        my $str="A:$space:B\x{FFFD}";
        chop $str;

        my @@res=split(/\s+/,$str);
        ok(@@res == 2 && join('-',@@res) eq "A:-:B", "$msg - /\\s+/");

        my $s2 = "$space$space:A:$space$space:B\x{FFFD}";
        chop $s2;

        my @@r2 = split(' ',$s2);
        ok(@@r2 == 2 && join('-', @@r2) eq ":A:-:B",  "$msg - ' '");

        my @@r3 = split(/\s+/, $s2);
        ok(@@r3 == 3 && join('-', @@r3) eq "-:A:-:B", "$msg - /\\s+/ No.2");
    }
}
a300 10
{
    my $src = "ABC \0 FOO \0  XYZ";
    my @@s = split(" \0 ", $src);
    my @@r = split(/ \0 /, $src);
    is(scalar(@@s), 3);
    is($s[0], "ABC");
    is($s[1], "FOO");
    is($s[2]," XYZ");
    is(join(':',@@s), join(':',@@r));
}
@


1.1.1.10
log
@import perl 5.10.1
@
text
@d9 1
a9 1
plan tests => 136;
a359 6
}

{
    use constant BANG => {};
    () = split m/,/, "", BANG;
    ok(1);
@


1.1.1.11
log
@Perl 5.12.2 from CPAN
@
text
@d9 1
a9 1
plan tests => 251;
a19 1
$cnt = split(/:b:/);
a20 1
is($cnt, scalar(@@ary));
a23 1
$cnt = split(//);
a24 1
is($cnt, scalar(@@ary));
a27 1
$cnt = split(/:/);
a28 1
is($cnt, scalar(@@ary));
a31 3
@@ary = split(' ',"    a b\tc \t d ");
$cnt = split(' ',"    a b\tc \t d ");
is($cnt, scalar(@@ary));
a34 3
@@ary = split(/ */,"foo  bar bie\tdoll");
$cnt = split(/ */,"foo  bar bie\tdoll");
is($cnt, scalar(@@ary));
a37 3
@@ary = split(/ /,'a b  c');
$cnt = split(/ /,'a b  c');
is($cnt, scalar(@@ary));
a41 3
@@ary = split(' ','1 2 3 4 5 6', 3);
$cnt = split(' ','1 2 3 4 5 6', 3);
is($cnt, scalar(@@ary));
a46 3
@@ary = split(' ','1 2 3 4 5 6', $x);
$cnt = split(' ','1 2 3 4 5 6', $x);
is($cnt, scalar(@@ary));
a50 3
@@ary = split(/:/,'1:2:3:4:5:6:::', 999);
$cnt = split(/:/,'1:2:3:4:5:6:::', 999);
is($cnt, scalar(@@ary));
a63 3
@@ary = split(/,|(-)/, "1-10,20,,,");
$cnt = split(/,|(-)/, "1-10,20,,,");
is($cnt, scalar(@@ary));
a67 3
@@ary = split(/,|(-)/, "1-10,20,,,", 10);
$cnt = split(/,|(-)/, "1-10,20,,,", 10);
is($cnt, scalar(@@ary));
a81 3
@@ary = split(/x/,   '',-1);
$cnt = split(/x/,   '',-1);
is($cnt, scalar(@@ary));
a84 3
@@ary = split(/x/,   '', 1);
$cnt = split(/x/,   '', 1);
is($cnt, scalar(@@ary));
a87 3
@@ary = split(/(p+)/,'',-1);
$cnt = split(/(p+)/,'',-1);
is($cnt, scalar(@@ary));
a90 3
@@ary = split(/.?/,  '',-1);
$cnt = split(/.?/,  '',-1);
is($cnt, scalar(@@ary));
a95 3
@@ary = split(/^a/m, "a b a\na d a", 20);
$cnt = split(/^a/m, "a b a\na d a", 20);
is($cnt, scalar(@@ary));
a99 3
@@ary = split(/a$/m, "a b a\na d a", 20);
$cnt = split(/a$/m, "a b a\na d a", 20);
is($cnt, scalar(@@ary));
a103 3
@@ary = split(/^aa/m, "aa b aa\naa d aa", 20);
$cnt = split(/^aa/m, "aa b aa\naa d aa", 20);
is($cnt, scalar(@@ary));
a107 3
@@ary = split(/aa$/m, "aa b aa\naa d aa", 20);
$cnt = split(/aa$/m, "aa b aa\naa d aa", 20);
is($cnt, scalar(@@ary));
a111 1
$cnt = split(/\s*:\s*/);
a112 1
is($cnt, scalar(@@ary));
a115 3
@@ary = split('abc' =~ /b/, 'p1q1r1s');
$cnt = split('abc' =~ /b/, 'p1q1r1s');
is($cnt, scalar(@@ary));
a130 3
@@ary = split /(?=\w)/, "rm b";
$cnt = split /(?=\w)/, "rm b";
is($cnt, scalar(@@ary));
a134 1
$cnt =           split //, v1.20.300.4000.50000.4000.300.20.1;
a135 1
is($cnt, scalar(@@ary));
a137 1
$cnt = split(/\x{FE}/, "\x{FF}\x{FE}\x{FD}"); # bug id 20010105.016
a140 1
is($cnt, scalar(@@ary));
a142 1
$cnt = split(/(\x{FE}\xFE)/, "\xFF\x{FF}\xFE\x{FE}\xFD\x{FD}"); # variant of 31
a152 1
is($cnt, scalar(@@ary));
a155 1
    my $c =          split(//, join("", map chr, (1234, 123, 2345)));
a156 1
    is($c, scalar(@@a));
a161 1
    my $c =          split(/$x/, join("", map chr, (1234, ord($x), 2345)));
a162 1
    is($c, scalar(@@a));
a173 2
    my $charnum  = split //, $sushi;
    is($charnum, scalar(@@charlist));
a220 2
    my $c = split( //, $a );
    is($c, scalar(@@b));
a231 1
    my $b = split(/\xFE/, "\xFF\xFE\xFD");
a233 1
    is($b, scalar(@@a));
a249 2
    my $y = split /(A)|B/, "1B2";
    is($y, scalar(@@x));
a258 2
    my $b = split /\r?\n/, "$char\n";
    is($b, scalar(@@a));
a269 2
	    my $e = split /[,]/,$1;
	    is($e, scalar(@@d));
a278 2
    eval { $b=split(/[, ]+/,$p) };
    is($b, scalar(@@a));
a337 1
        my $cnt=split(/\s+/,$str);
a338 1
	is($cnt, scalar(@@res), "$msg - /\\s+/ (count)");
a343 1
	my $c2 = split(' ',$s2);
a344 1
	is($c2, scalar(@@r2), "$msg - ' ' (count)");
a346 1
        my $c3 = split(/\s+/, $s2);
a347 1
	is($c3, scalar(@@r3), "$msg - /\\s+/ No.2 (count)");
a354 2
    my $cs = split(" \0 ", $src);
    my $cr = split(/ \0 /, $src);
a355 2
    is($cs, 3);
    is($cr, 3);
a365 8
}

{
    # Bug #69875
    # 'Hybrid' scalar-and-array context
    scalar(our @@PATH = split /::/, "Font::GlyphNames");
           # 'my' doesn't trigger the bug
    is "@@PATH", "Font GlyphNames", "hybrid scalar-and-array context";
@


1.1.1.12
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d9 1
a9 1
plan tests => 102;
a75 5
# Splitting without pattern
$_ = "1 2 3 4";
$_ = join(':', split);
is($_ , '1:2:3:4');

d385 56
@


1.1.1.13
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d9 1
a9 1
plan tests => 118;
d17 1
a17 1
is(join(';',$a,$b,$c), 'a;b;c', 'Split a simple string into scalars.');
d56 1
a56 1
is($_, '1:2:3 4 5 6', "Split into a specified number of fields, defined by a literal");
d59 1
a59 1
is($cnt, scalar(@@ary), "Check element count from previous test");
d64 1
a64 1
is($_, '1:2:3:4 5 6', "Split into a specified number of fields, defined by a scalar variable");
d67 1
a67 1
is($cnt, scalar(@@ary), "Check element count from previous test");
d79 1
a79 1
is($_ , '1:2:3:4', "Split and join without specifying a split pattern");
d88 1
a88 1
is($_, '1:2 3 4 5 6', "Storing split output into list of scalars");
a419 71

{
    my @@results;
    my $expr= "foo  bar";
    my $cond;

    @@results= split(0||" ", $expr);
    is @@results, 2, 'split(0||" ") is treated like split(" ")'; #'

    $cond= 0;
    @@results= split $cond ? " " : qr/ /, $expr;
    is @@results, 3, 'split($cond ? " " : qr/ /, $expr) works as expected (like qr/ /)';
    $cond= 1;
    @@results= split $cond ? " " : qr/ /, $expr;
    is @@results, 2, 'split($cond ? " " : qr/ /, $expr) works as expected (like " ")';

    $expr = ' a b c ';
    @@results = split /\s/, $expr;
    is @@results, 4,
        "split on regex of single space metacharacter: captured 4 elements";
    is $results[0], '',
        "split on regex of single space metacharacter: first element is empty string";

    @@results = split / /, $expr;
    is @@results, 4,
        "split on regex of single whitespace: captured 4 elements";
    is $results[0], '',
        "split on regex of single whitespace: first element is empty string";

    @@results = split " ", $expr;
    is @@results, 3,
        "split on string of single whitespace: captured 3 elements";
    is $results[0], 'a',
        "split on string of single whitespace: first element is non-empty";

    $expr = " a \tb c ";
    @@results = split " ", $expr;
    is @@results, 3,
        "split on string of single whitespace: captured 3 elements";
    is $results[0], 'a',
        "split on string of single whitespace: first element is non-empty; multiple contiguous space characters";

    my @@seq;
    for my $cond (0,1,0,1,0) {
        $expr = "  foo  ";
        @@results = split $cond ? qr/ / : " ", $expr;
        push @@seq, scalar(@@results) . ":" . $results[-1];
    }
    is join(" ", @@seq), "1:foo 3:foo 1:foo 3:foo 1:foo",
        qq{split(\$cond ? qr/ / : " ", "$exp") behaves as expected over repeated similar patterns};
}

{
    # 'RT #116086: split "\x20" does not work as documented';
    my @@results;
    my $expr;
    $expr = ' a b c ';
    @@results = split "\x20", $expr;
    is @@results, 3,
        "RT #116086: split on string of single hex-20: captured 3 elements";
    is $results[0], 'a',
        "RT #116086: split on string of single hex-20: first element is non-empty";

    $expr = " a \tb c ";
    @@results = split "\x20", $expr;
    is @@results, 3,
        "RT #116086: split on string of single hex-20: captured 3 elements";
    is $results[0], 'a',
        "RT #116086: split on string of single hex-20: first element is non-empty; multiple contiguous space characters";
}

@


1.1.1.14
log
@Import perl-5.20.1
@
text
@d9 1
a9 1
plan tests => 119;
a490 4
# Nasty interaction between split and use constant
use constant nought => 0;
($a,$b,$c) = split //, $foo, nought;
is nought, 0, 'split does not mangle 0 constants';
@


