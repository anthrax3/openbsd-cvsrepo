head	1.2;
access;
symbols
	OPENBSD_6_2_BASE:1.2
	PERL_5_24_2:1.1.1.4
	OPENBSD_6_1:1.2.0.4
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.3.0.16
	OPENBSD_6_0_BASE:1.1.1.3
	OPENBSD_5_9:1.1.1.3.0.10
	OPENBSD_5_9_BASE:1.1.1.3
	OPENBSD_5_8:1.1.1.3.0.12
	OPENBSD_5_8_BASE:1.1.1.3
	PERL_5_20_2:1.1.1.3
	OPENBSD_5_7:1.1.1.3.0.4
	OPENBSD_5_7_BASE:1.1.1.3
	PERL_5_20_1:1.1.1.3
	OPENBSD_5_6:1.1.1.3.0.8
	OPENBSD_5_6_BASE:1.1.1.3
	PERL_5_18_2:1.1.1.3
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.3.0.6
	OPENBSD_5_5_BASE:1.1.1.3
	OPENBSD_5_4:1.1.1.3.0.2
	OPENBSD_5_4_BASE:1.1.1.3
	PERL_5_16_3:1.1.1.3
	OPENBSD_5_3:1.1.1.2.0.14
	OPENBSD_5_3_BASE:1.1.1.2
	OPENBSD_5_2:1.1.1.2.0.12
	OPENBSD_5_2_BASE:1.1.1.2
	OPENBSD_5_1_BASE:1.1.1.2
	OPENBSD_5_1:1.1.1.2.0.10
	OPENBSD_5_0:1.1.1.2.0.8
	OPENBSD_5_0_BASE:1.1.1.2
	OPENBSD_4_9:1.1.1.2.0.6
	OPENBSD_4_9_BASE:1.1.1.2
	PERL_5_12_2:1.1.1.2
	OPENBSD_4_8:1.1.1.2.0.4
	OPENBSD_4_8_BASE:1.1.1.2
	OPENBSD_4_7:1.1.1.2.0.2
	OPENBSD_4_7_BASE:1.1.1.2
	PERL_5_10_1:1.1.1.2
	OPENBSD_4_6:1.1.1.1.0.30
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.26
	OPENBSD_4_5_BASE:1.1.1.1
	PERL_5_10_0:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.24
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.22
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.20
	OPENBSD_4_2_BASE:1.1.1.1
	OPENBSD_4_1:1.1.1.1.0.18
	OPENBSD_4_1_BASE:1.1.1.1
	OPENBSD_4_0:1.1.1.1.0.16
	OPENBSD_4_0_BASE:1.1.1.1
	PERL_5_8_8:1.1.1.1
	OPENBSD_3_9:1.1.1.1.0.14
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.12
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.10
	OPENBSD_3_7_BASE:1.1.1.1
	PERL_5_8_6:1.1.1.1
	OPENBSD_3_6:1.1.1.1.0.8
	OPENBSD_3_6_BASE:1.1.1.1
	PERL_5_8_5:1.1.1.1
	PERL_5_8_3:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.6
	OPENBSD_3_5_BASE:1.1.1.1
	PERL_5_8_2:1.1.1.1
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	PERL_5_8_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.32.20;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2002.10.27.22.15.10;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.27.22.15.10;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2009.10.12.18.10.45;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2013.03.25.20.09.35;	author sthen;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2017.08.14.13.46.23;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl -w

BEGIN {
    chdir 't' if -d 't';
    @@INC = '../lib';
    require './test.pl';
}

use strict;

tie my $c => 'Tie::Monitor';

sub expected_tie_calls {
    my ($obj, $rexp, $wexp, $tn) = @@_;
    local $::Level = $::Level + 1;
    my ($rgot, $wgot) = $obj->init();
    is ($rgot, $rexp, $tn ? "number of fetches when $tn" : ());
    is ($wgot, $wexp, $tn ? "number of stores when $tn" : ());
}

# Use ok() instead of is(), cmp_ok() etc, to strictly control number of accesses
my($r, $s);
ok($r = $c + 0 == 0, 'the thing itself');
expected_tie_calls(tied $c, 1, 0);
ok($r = "$c" eq '0', 'the thing itself');
expected_tie_calls(tied $c, 1, 0);

ok($c . 'x' eq '0x', 'concat');
expected_tie_calls(tied $c, 1, 0);
ok('x' . $c eq 'x0', 'concat');
expected_tie_calls(tied $c, 1, 0);
$s = $c . $c;
ok($s eq '00', 'concat');
expected_tie_calls(tied $c, 2, 0);
$r = 'x';
$s = $c = $r . 'y';
ok($s eq 'xy', 'concat');
expected_tie_calls(tied $c, 1, 1);
$s = $c = $c . 'x';
ok($s eq '0x', 'concat');
expected_tie_calls(tied $c, 2, 1);
$s = $c = 'x' . $c;
ok($s eq 'x0', 'concat');
expected_tie_calls(tied $c, 2, 1);
$s = $c = $c . $c;
ok($s eq '00', 'concat');
expected_tie_calls(tied $c, 3, 1);

$s = chop($c);
ok($s eq '0', 'multiple magic in core functions');
expected_tie_calls(tied $c, 1, 1);

$c = *strat;
$s = $c;
ok($s eq *strat,
   'Assignment should not ignore magic when the last thing assigned was a glob');
expected_tie_calls(tied $c, 1, 1);

package o { use overload '""' => sub { "foo\n" } }
$c = bless [], o::;
chomp $c;
expected_tie_calls(tied $c, 1, 2, 'chomping a ref');

{
    my $outfile = tempfile();
    open my $h, ">$outfile" or die  "$0 cannot close $outfile: $!";
    print $h "bar\n";
    close $h or die "$0 cannot close $outfile: $!";    

    $c = *foo;                                         # 1 write
    open $h, $outfile;
    sysread $h, $c, 3, 7;                              # 1 read; 1 write
    is $c, "*main::bar", 'what sysread wrote';         # 1 read
    expected_tie_calls(tied $c, 2, 2, 'calling sysread with tied buf');
    close $h or die "$0 cannot close $outfile: $!";

 # Do this again, with a utf8 handle
    $c = *foo;                                         # 1 write
    open $h, "<:utf8", $outfile;
    no warnings 'deprecated';
    sysread $h, $c, 3, 7;                              # 1 read; 1 write
    is $c, "*main::bar", 'what sysread wrote';         # 1 read
    expected_tie_calls(tied $c, 2, 2, 'calling sysread with tied buf');
    close $h or die "$0 cannot close $outfile: $!";

    unlink_all $outfile;
}

# autovivication of aelem, helem, of rv2sv combined with get-magic
{
    my $true = 1;
    my $s;
    tie $$s, "Tie::Monitor";
    $$s = undef;
    $$s->[0] = 73;
    is($$s->[0], 73);
    expected_tie_calls(tied $$s, 3, 2);

    my @@a;
    tie $a[0], "Tie::Monitor";
    $a[0] = undef;
    $a[0][0] = 73;
    is($a[0][0], 73);
    expected_tie_calls(tied $a[0], 3, 2);

    my %h;
    tie $h{foo}, "Tie::Monitor";
    $h{foo} = undef;
    $h{foo}{bar} = 73;
    is($h{foo}{bar}, 73);
    expected_tie_calls(tied $h{foo}, 3, 2);

    # Similar tests, but with obscured autovivication by using dummy list or "?:" operator
    $$s = undef;
    ${ (), $$s }[0] = 73;
    is( $$s->[0], 73);
    expected_tie_calls(tied $$s, 3, 2);

    $$s = undef;
    ( ! $true ? undef : $$s )->[0] = 73;
    is( $$s->[0], 73);
    expected_tie_calls(tied $$s, 3, 2);

    $$s = undef;
    ( $true ? $$s : undef )->[0] = 73;
    is( $$s->[0], 73);
    expected_tie_calls(tied $$s, 3, 2);
}

# A plain *foo should not call get-magic on *foo.
# This method of scalar-tying an immutable glob relies on details of the
# current implementation that are subject to change. This test may need to
# be rewritten if they do change.
my $tyre = tie $::{gelp} => 'Tie::Monitor';
# Compilation of this eval autovivifies the *gelp glob.
eval '$tyre->init(0); () = \*gelp';
my($rgot, $wgot) = $tyre->init(0);
ok($rgot == 0, 'a plain *foo causes no get-magic');
ok($wgot == 0, 'a plain *foo causes no set-magic');

# get-magic when exiting a non-lvalue sub in potentially autovivify-
# ing context
{
  no strict;

  my $tied_to = tie $_{elem}, "Tie::Monitor";
  () = sub { delete $_{elem} }->()->[3];
  expected_tie_calls $tied_to, 1, 0,
     'mortal magic var is implicitly returned in autoviv context';

  $tied_to = tie $_{elem}, "Tie::Monitor";
  () = sub { return delete $_{elem} }->()->[3];
  expected_tie_calls $tied_to, 1, 0,
      'mortal magic var is explicitly returned in autoviv context';

  $tied_to = tie $_{elem}, "Tie::Monitor";
  my $rsub;
  $rsub = sub { if ($_[0]) { delete $_{elem} } else { &$rsub(1)->[3] } };
  &$rsub;
  expected_tie_calls $tied_to, 1, 0,
    'mortal magic var is implicitly returned in recursive autoviv context';

  $tied_to = tie $_{elem}, "Tie::Monitor";
  $rsub = sub {
    if ($_[0]) { return delete $_{elem} } else { &$rsub(1)->[3] }
  };
  &$rsub;
  expected_tie_calls $tied_to, 1, 0,
    'mortal magic var is explicitly returned in recursive autoviv context';

  $tied_to = tie $_{elem}, "Tie::Monitor";
  my $x = \sub { delete $_{elem} }->();
  expected_tie_calls $tied_to, 1, 0,
     'mortal magic var is implicitly returned to refgen';
  is tied $$x, undef,
     'mortal magic var is copied when implicitly returned';

  $tied_to = tie $_{elem}, "Tie::Monitor";
  $x = \sub { return delete $_{elem} }->();
  expected_tie_calls $tied_to, 1, 0,
     'mortal magic var is explicitly returned to refgen';
  is tied $$x, undef,
     'mortal magic var is copied when explicitly returned';

  $tied_to = tie $_{elem}, "Tie::Monitor";
  $x = \do { 1; delete $_{elem} };
  expected_tie_calls $tied_to, 1, 0,
     'mortal magic var from do passed to refgen';
  is tied $$x, undef,
     'mortal magic var from do is copied';
}

done_testing();

# adapted from Tie::Counter by Abigail
package Tie::Monitor;

sub TIESCALAR {
    my($class, $value) = @@_;
    bless {
	read => 0,
	write => 0,
	values => [ 0 ],
    };
}

sub FETCH {
    my $self = shift;
    ++$self->{read};
    $self->{values}[$#{ $self->{values} }];
}

sub STORE {
    my($self, $value) = @@_;
    ++$self->{write};
    push @@{ $self->{values} }, $value;
}

sub init {
    my $self = shift;
    my @@results = ($self->{read}, $self->{write});
    $self->{read} = $self->{write} = 0;
    $self->{values} = [ 0 ];
    @@results;
}
@


1.1
log
@Initial revision
@
text
@a3 1
    $| = 1;
d6 1
d9 1
a9 1
print "1..18\n";
a10 1
my $t = 1;
d13 6
a18 13
sub ok {
    my($ok, $got, $exp, $rexp, $wexp) = @@_;
    my($rgot, $wgot) = (tied $c)->init(0);
    print $ok ? "ok $t\n" : "# expected $exp, got $got\nnot ok $t\n";
    ++$t;
    if ($rexp == $rgot && $wexp == $wgot) {
	print "ok $t\n";
    } else {
	print "# read $rgot expecting $rexp\n" if $rgot != $rexp;
	print "# wrote $wgot expecting $wexp\n" if $wgot != $wexp;
	print "not ok $t\n";
    }
    ++$t;
d21 1
a21 4
sub ok_undef { ok(!defined($_[0]), shift, "undef", @@_) }
sub ok_numeric { ok($_[0] == $_[1], @@_) }
sub ok_string { ok($_[0] eq $_[1], @@_) }

d23 9
a31 7
# the thing itself
ok_numeric($r = $c + 0, 0, 1, 0);
ok_string($r = "$c", '0', 1, 0);

# concat
ok_string($c . 'x', '0x', 1, 0);
ok_string('x' . $c, 'x0', 1, 0);
d33 2
a34 1
ok_string($s, '00', 2, 0);
d37 2
a38 1
ok_string($s, 'xy', 1, 1);
d40 2
a41 1
ok_string($s, '0x', 2, 1);
d43 2
a44 1
ok_string($s, 'x0', 2, 1);
d46 148
a193 1
ok_string($s, '00', 3, 1);
@


1.1.1.1
log
@stock perl 5.8.0 from CPAN
@
text
@@


1.1.1.2
log
@import perl 5.10.1
@
text
@d9 1
a9 1
print "1..20\n";
a51 4

# multiple magic in core functions
$s = chop($c);
ok_string($s, '0', 1, 1);
@


1.1.1.3
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d4 1
a6 1
    require './test.pl';
d9 1
a9 1
use strict;
d11 1
d14 13
a26 6
sub expected_tie_calls {
    my ($obj, $rexp, $wexp, $tn) = @@_;
    local $::Level = $::Level + 1;
    my ($rgot, $wgot) = $obj->init();
    is ($rgot, $rexp, $tn ? "number of fetches when $tn" : ());
    is ($wgot, $wexp, $tn ? "number of stores when $tn" : ());
d29 4
a32 1
# Use ok() instead of is(), cmp_ok() etc, to strictly control number of accesses
d34 7
a40 9
ok($r = $c + 0 == 0, 'the thing itself');
expected_tie_calls(tied $c, 1, 0);
ok($r = "$c" eq '0', 'the thing itself');
expected_tie_calls(tied $c, 1, 0);

ok($c . 'x' eq '0x', 'concat');
expected_tie_calls(tied $c, 1, 0);
ok('x' . $c eq 'x0', 'concat');
expected_tie_calls(tied $c, 1, 0);
d42 1
a42 2
ok($s eq '00', 'concat');
expected_tie_calls(tied $c, 2, 0);
d45 1
a45 2
ok($s eq 'xy', 'concat');
expected_tie_calls(tied $c, 1, 1);
d47 1
a47 2
ok($s eq '0x', 'concat');
expected_tie_calls(tied $c, 2, 1);
d49 1
a49 2
ok($s eq 'x0', 'concat');
expected_tie_calls(tied $c, 2, 1);
d51 1
a51 2
ok($s eq '00', 'concat');
expected_tie_calls(tied $c, 3, 1);
d53 1
d55 1
a55 136
ok($s eq '0', 'multiple magic in core functions');
expected_tie_calls(tied $c, 1, 1);

$c = *strat;
$s = $c;
ok($s eq *strat,
   'Assignment should not ignore magic when the last thing assigned was a glob');
expected_tie_calls(tied $c, 1, 1);

package o { use overload '""' => sub { "foo\n" } }
$c = bless [], o::;
chomp $c;
expected_tie_calls(tied $c, 1, 2, 'chomping a ref');

{
    my $outfile = tempfile();
    open my $h, ">$outfile" or die  "$0 cannot close $outfile: $!";
    print $h "bar\n";
    close $h or die "$0 cannot close $outfile: $!";    

    $c = *foo;                                         # 1 write
    open $h, $outfile;
    sysread $h, $c, 3, 7;                              # 1 read; 1 write
    is $c, "*main::bar", 'what sysread wrote';         # 1 read
    expected_tie_calls(tied $c, 2, 2, 'calling sysread with tied buf');
    close $h or die "$0 cannot close $outfile: $!";

 # Do this again, with a utf8 handle
    $c = *foo;                                         # 1 write
    open $h, "<:utf8", $outfile;
    sysread $h, $c, 3, 7;                              # 1 read; 1 write
    is $c, "*main::bar", 'what sysread wrote';         # 1 read
    expected_tie_calls(tied $c, 2, 2, 'calling sysread with tied buf');
    close $h or die "$0 cannot close $outfile: $!";

    unlink_all $outfile;
}

# autovivication of aelem, helem, of rv2sv combined with get-magic
{
    my $true = 1;
    my $s;
    tie $$s, "Tie::Monitor";
    $$s = undef;
    $$s->[0] = 73;
    is($$s->[0], 73);
    expected_tie_calls(tied $$s, 3, 2);

    my @@a;
    tie $a[0], "Tie::Monitor";
    $a[0] = undef;
    $a[0][0] = 73;
    is($a[0][0], 73);
    expected_tie_calls(tied $a[0], 3, 2);

    my %h;
    tie $h{foo}, "Tie::Monitor";
    $h{foo} = undef;
    $h{foo}{bar} = 73;
    is($h{foo}{bar}, 73);
    expected_tie_calls(tied $h{foo}, 3, 2);

    # Similar tests, but with obscured autovivication by using dummy list or "?:" operator
    $$s = undef;
    ${ (), $$s }[0] = 73;
    is( $$s->[0], 73);
    expected_tie_calls(tied $$s, 3, 2);

    $$s = undef;
    ( ! $true ? undef : $$s )->[0] = 73;
    is( $$s->[0], 73);
    expected_tie_calls(tied $$s, 3, 2);

    $$s = undef;
    ( $true ? $$s : undef )->[0] = 73;
    is( $$s->[0], 73);
    expected_tie_calls(tied $$s, 3, 2);
}

# A plain *foo should not call get-magic on *foo.
# This method of scalar-tying an immutable glob relies on details of the
# current implementation that are subject to change. This test may need to
# be rewritten if they do change.
my $tyre = tie $::{gelp} => 'Tie::Monitor';
# Compilation of this eval autovivifies the *gelp glob.
eval '$tyre->init(0); () = \*gelp';
my($rgot, $wgot) = $tyre->init(0);
ok($rgot == 0, 'a plain *foo causes no get-magic');
ok($wgot == 0, 'a plain *foo causes no set-magic');

# get-magic when exiting a non-lvalue sub in potentially autovivify-
# ing context
{
  no strict;

  my $tied_to = tie $_{elem}, "Tie::Monitor";
  () = sub { delete $_{elem} }->()->[3];
  expected_tie_calls $tied_to, 1, 0,
     'mortal magic var is implicitly returned in autoviv context';

  $tied_to = tie $_{elem}, "Tie::Monitor";
  () = sub { return delete $_{elem} }->()->[3];
  expected_tie_calls $tied_to, 1, 0,
      'mortal magic var is explicitly returned in autoviv context';

  $tied_to = tie $_{elem}, "Tie::Monitor";
  my $rsub;
  $rsub = sub { if ($_[0]) { delete $_{elem} } else { &$rsub(1)->[3] } };
  &$rsub;
  expected_tie_calls $tied_to, 1, 0,
    'mortal magic var is implicitly returned in recursive autoviv context';

  $tied_to = tie $_{elem}, "Tie::Monitor";
  $rsub = sub {
    if ($_[0]) { return delete $_{elem} } else { &$rsub(1)->[3] }
  };
  &$rsub;
  expected_tie_calls $tied_to, 1, 0,
    'mortal magic var is explicitly returned in recursive autoviv context';

  $tied_to = tie $_{elem}, "Tie::Monitor";
  my $x = \sub { delete $_{elem} }->();
  expected_tie_calls $tied_to, 1, 0,
     'mortal magic var is implicitly returned to refgen';
  is tied $$x, undef,
     'mortal magic var is copied when implicitly returned';

  $tied_to = tie $_{elem}, "Tie::Monitor";
  $x = \sub { return delete $_{elem} }->();
  expected_tie_calls $tied_to, 1, 0,
     'mortal magic var is explicitly returned to refgen';
  is tied $$x, undef,
     'mortal magic var is copied when explicitly returned';
}

done_testing();
@


1.1.1.4
log
@Import perl-5.24.2
@
text
@a79 1
    no warnings 'deprecated';
a182 7

  $tied_to = tie $_{elem}, "Tie::Monitor";
  $x = \do { 1; delete $_{elem} };
  expected_tie_calls $tied_to, 1, 0,
     'mortal magic var from do passed to refgen';
  is tied $$x, undef,
     'mortal magic var from do is copied';
@


