head	1.8;
access;
symbols
	PERL_5_24_2:1.1.1.7
	OPENBSD_6_1:1.8.0.4
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.7.0.34
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.28
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.30
	OPENBSD_5_8_BASE:1.7
	PERL_5_20_2:1.1.1.6
	OPENBSD_5_7:1.7.0.22
	OPENBSD_5_7_BASE:1.7
	PERL_5_20_1:1.1.1.6
	OPENBSD_5_6:1.7.0.26
	OPENBSD_5_6_BASE:1.7
	PERL_5_18_2:1.1.1.6
	PERL:1.1.1
	OPENBSD_5_5:1.7.0.24
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.20
	OPENBSD_5_4_BASE:1.7
	PERL_5_16_3:1.1.1.6
	OPENBSD_5_3:1.7.0.18
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.16
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.14
	OPENBSD_5_0:1.7.0.12
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.10
	OPENBSD_4_9_BASE:1.7
	PERL_5_12_2:1.1.1.6
	OPENBSD_4_8:1.7.0.8
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.4
	OPENBSD_4_7_BASE:1.7
	PERL_5_10_1:1.1.1.6
	OPENBSD_4_6:1.7.0.6
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.2
	OPENBSD_4_5_BASE:1.7
	PERL_5_10_0:1.1.1.6
	OPENBSD_4_4:1.6.0.16
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.14
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.12
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.10
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.8
	OPENBSD_4_0_BASE:1.6
	PERL_5_8_8:1.1.1.5
	OPENBSD_3_9:1.6.0.6
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.4
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.2
	OPENBSD_3_7_BASE:1.6
	PERL_5_8_6:1.1.1.5
	OPENBSD_3_6:1.5.0.2
	OPENBSD_3_6_BASE:1.5
	PERL_5_8_5:1.1.1.4
	PERL_5_8_3:1.1.1.3
	OPENBSD_3_5:1.4.0.18
	OPENBSD_3_5_BASE:1.4
	PERL_5_8_2:1.1.1.3
	OPENBSD_3_4:1.4.0.16
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.4.0.14
	OPENBSD_3_3_BASE:1.4
	PERL_5_8_0:1.1.1.3
	OPENBSD_3_2:1.4.0.12
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.10
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.8
	OPENBSD_3_0_BASE:1.4
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.8
date	2017.02.05.00.32.20;	author afresh1;	state Exp;
branches;
next	1.7;
commitid	cxJ08BvJA9Pt2PTM;

1.7
date	2008.09.29.17.36.19;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2005.01.15.21.30.40;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2004.08.09.18.10.27;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.08.21;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.52.34;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.08.05.17;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.13.17;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.13.17;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.41.43;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.10.48;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.08.09.17.48.34;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2005.01.15.21.18.18;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2008.09.29.17.19.00;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2017.08.14.13.46.23;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.8
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl

BEGIN {
    chdir 't' if -d 't';
    @@INC = qw(. ../lib);
}

require "./test.pl";
plan( tests => 38 );

# delete() on hash elements

$foo{1} = 'a';
$foo{2} = 'b';
$foo{3} = 'c';
$foo{4} = 'd';
$foo{5} = 'e';

$foo = delete $foo{2};

cmp_ok($foo,'eq','b','delete 2');
ok(!(exists $foo{2}),'b absent');
cmp_ok($foo{1},'eq','a','a exists');
cmp_ok($foo{3},'eq','c','c exists');
cmp_ok($foo{4},'eq','d','d exists');
cmp_ok($foo{5},'eq','e','e exists');

@@foo = delete @@foo{4, 5};

cmp_ok(scalar(@@foo),'==',2,'deleted slice');
cmp_ok($foo[0],'eq','d','slice 1');
cmp_ok($foo[1],'eq','e','slice 2');
ok(!(exists $foo{4}),'d absent');
ok(!(exists $foo{5}),'e absent');
cmp_ok($foo{1},'eq','a','a still exists');
cmp_ok($foo{3},'eq','c','c still exists');

$foo = join('',values(%foo));
ok($foo eq 'ac' || $foo eq 'ca','remaining keys');

foreach $key (keys %foo) {
    delete $foo{$key};
}

$foo{'foo'} = 'x';
$foo{'bar'} = 'y';

$foo = join('',values(%foo));
ok($foo eq 'xy' || $foo eq 'yx','fresh keys');

$refhash{"top"}->{"foo"} = "FOO";
$refhash{"top"}->{"bar"} = "BAR";

delete $refhash{"top"}->{"bar"};
@@list = keys %{$refhash{"top"}};

cmp_ok("@@list",'eq',"foo", 'autoviv and delete hashref');

{
    my %a = ('bar', 33);
    my($a) = \(values %a);
    my $b = \$a{bar};
    my $c = \delete $a{bar};

    ok($a == $b && $b == $c,'a b c equivalent');
}

# delete() on array elements

@@foo = ();
$foo[1] = 'a';
$foo[2] = 'b';
$foo[3] = 'c';
$foo[4] = 'd';
$foo[5] = 'e';

$foo = delete $foo[2];

cmp_ok($foo,'eq','b','ary delete 2');
ok(!(exists $foo[2]),'ary b absent');
cmp_ok($foo[1],'eq','a','ary a exists');
cmp_ok($foo[3],'eq','c','ary c exists');
cmp_ok($foo[4],'eq','d','ary d exists');
cmp_ok($foo[5],'eq','e','ary e exists');

@@bar = delete @@foo[4,5];

cmp_ok(scalar(@@bar),'==',2,'ary deleted slice');
cmp_ok($bar[0],'eq','d','ary slice 1');
cmp_ok($bar[1],'eq','e','ary slice 2');
ok(!(exists $foo[4]),'ary d absent');
ok(!(exists $foo[5]),'ary e absent');
cmp_ok($foo[1],'eq','a','ary a still exists');
cmp_ok($foo[3],'eq','c','ary c still exists');

$foo = join('',@@foo);
cmp_ok($foo,'eq','ac','ary elems');
cmp_ok(scalar(@@foo),'==',4,'four is the number thou shalt count');

foreach $key (0 .. $#foo) {
    delete $foo[$key];
}

cmp_ok(scalar(@@foo),'==',0,'and then there were none');

$foo[0] = 'x';
$foo[1] = 'y';

$foo = "@@foo";
cmp_ok($foo,'eq','x y','two fresh');

$refary[0]->[0] = "FOO";
$refary[0]->[3] = "BAR";

delete $refary[0]->[3];

cmp_ok( scalar(@@{$refary[0]}),'==',1,'one down');

{
    my @@a = 33;
    my($a) = \(@@a);
    my $b = \$a[0];
    my $c = \delete $a[bar];

    ok($a == $b && $b == $c,'a b c also equivalent');
}

{
    my %h;
    my ($x,$y) = (1, scalar delete @@h{()});
    ok(!defined($y),q([perl #29127] scalar delete of empty slice returned garbage));
}

{
    my $x = 0;
    sub X::DESTROY { $x++ }
    {
	my @@a;
	$a[0] = bless [], 'X';
	my $y = delete $a[0];
    }
    cmp_ok($x,'==',1,q([perl #30733] array delete didn't free returned element));
}
@


1.7
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d8 1
a8 1
require "test.pl";
@


1.6
log
@sync in-tree perl with 5.8.6
@
text
@d3 7
a9 1
print "1..38\n";
d21 6
a26 6
if ($foo eq 'b') {print "ok 1\n";} else {print "not ok 1 $foo\n";}
unless (exists $foo{2}) {print "ok 2\n";} else {print "not ok 2 $foo{2}\n";}
if ($foo{1} eq 'a') {print "ok 3\n";} else {print "not ok 3\n";}
if ($foo{3} eq 'c') {print "ok 4\n";} else {print "not ok 4\n";}
if ($foo{4} eq 'd') {print "ok 5\n";} else {print "not ok 5\n";}
if ($foo{5} eq 'e') {print "ok 6\n";} else {print "not ok 6\n";}
d30 7
a36 7
if (@@foo == 2) {print "ok 7\n";} else {print "not ok 7 ", @@foo+0, "\n";}
if ($foo[0] eq 'd') {print "ok 8\n";} else {print "not ok 8 ", $foo[0], "\n";}
if ($foo[1] eq 'e') {print "ok 9\n";} else {print "not ok 9 ", $foo[1], "\n";}
unless (exists $foo{4}) {print "ok 10\n";} else {print "not ok 10 $foo{4}\n";}
unless (exists $foo{5}) {print "ok 11\n";} else {print "not ok 11 $foo{5}\n";}
if ($foo{1} eq 'a') {print "ok 12\n";} else {print "not ok 12\n";}
if ($foo{3} eq 'c') {print "ok 13\n";} else {print "not ok 13\n";}
d39 1
a39 1
if ($foo eq 'ac' || $foo eq 'ca') {print "ok 14\n";} else {print "not ok 14\n";}
d49 1
a49 1
print +($foo eq 'xy' || $foo eq 'yx') ? "ok 15\n" : "not ok 15\n";
d57 1
a57 1
print "@@list" eq "foo" ? "ok 16\n" : "not ok 16 @@list\n";
d65 1
a65 2
    print "not " unless $a == $b && $b == $c;
    print "ok 17\n";
d79 6
a84 6
if ($foo eq 'b') {print "ok 18\n";} else {print "not ok 18 $foo\n";}
unless (exists $foo[2]) {print "ok 19\n";} else {print "not ok 19 $foo[2]\n";}
if ($foo[1] eq 'a') {print "ok 20\n";} else {print "not ok 20\n";}
if ($foo[3] eq 'c') {print "ok 21\n";} else {print "not ok 21\n";}
if ($foo[4] eq 'd') {print "ok 22\n";} else {print "not ok 22\n";}
if ($foo[5] eq 'e') {print "ok 23\n";} else {print "not ok 23\n";}
d88 7
a94 7
if (@@bar == 2) {print "ok 24\n";} else {print "not ok 24 ", @@bar+0, "\n";}
if ($bar[0] eq 'd') {print "ok 25\n";} else {print "not ok 25 ", $bar[0], "\n";}
if ($bar[1] eq 'e') {print "ok 26\n";} else {print "not ok 26 ", $bar[1], "\n";}
unless (exists $foo[4]) {print "ok 27\n";} else {print "not ok 27 $foo[4]\n";}
unless (exists $foo[5]) {print "ok 28\n";} else {print "not ok 28 $foo[5]\n";}
if ($foo[1] eq 'a') {print "ok 29\n";} else {print "not ok 29\n";}
if ($foo[3] eq 'c') {print "ok 30\n";} else {print "not ok 30\n";}
d97 2
a98 3
if ($foo eq 'ac') {print "ok 31\n";} else {print "not ok 31\n";}

if (@@foo == 4) {print "ok 32\n";} else {print "not ok 32\n";}
d104 1
a104 1
if (@@foo == 0) {print "ok 33\n";} else {print "not ok 33\n";}
d110 1
a110 1
print +($foo eq 'x y') ? "ok 34\n" : "not ok 34\n";
d117 1
a117 1
print @@{$refary[0]} == 1 ? "ok 35\n" : "not ok 35 @@list\n";
d125 1
a125 2
    print "not " unless $a == $b && $b == $c;
    print "ok 36\n";
a128 1
    # [perl #29127] scalar delete of empty slice returned garbage
d131 1
a131 2
    print "not " if defined $y;
    print "ok 37\n";
a134 1
    # [perl #30733] array delete didn't free returned element
d142 1
a142 2
    print "not " unless $x == 1;
    print "ok 38\n";
@


1.5
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d3 1
a3 1
print "1..37\n";
d131 13
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d3 1
a3 1
print "1..36\n";
d123 8
@


1.3
log
@perl5.005_03 (stock)
@
text
@d3 1
a3 1
# $RCSfile: delete.t,v $$Revision: 4.1 $$Date: 92/08/07 18:27:44 $
d5 1
a5 1
print "1..16\n";
d16 1
a16 1
if ($foo{2} eq '') {print "ok 2\n";} else {print "not ok 2 $foo{2}\n";}
d27 2
a28 2
if ($foo{4} eq '') {print "ok 10\n";} else {print "not ok 10 $foo{4}\n";}
if ($foo{5} eq '') {print "ok 11\n";} else {print "not ok 11 $foo{5}\n";}
d52 72
@


1.2
log
@perl 5.004_04
@
text
@d32 1
a32 1
$foo = join('',values(foo));
d35 1
a35 1
foreach $key (keys foo) {
d42 1
a42 1
$foo = join('',values(foo));
@


1.1
log
@Initial revision
@
text
@d5 1
a5 1
print "1..7\n";
d10 2
d19 12
d33 1
a33 1
if ($foo eq 'ac' || $foo eq 'ca') {print "ok 5\n";} else {print "not ok 5\n";}
d43 1
a43 1
if ($foo eq 'xy' || $foo eq 'yx') {print "ok 6\n";} else {print "not ok 6\n";}
d51 1
a51 1
print "@@list" eq "foo" ? "ok 7\n" : "not ok 7 @@list\n";
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d5 1
a5 1
print "1..16\n";
a9 2
$foo{4} = 'd';
$foo{5} = 'e';
a16 2
if ($foo{4} eq 'd') {print "ok 5\n";} else {print "not ok 5\n";}
if ($foo{5} eq 'e') {print "ok 6\n";} else {print "not ok 6\n";}
d18 2
a19 1
@@foo = delete @@foo{4, 5};
d21 1
a21 12
if (@@foo == 2) {print "ok 7\n";} else {print "not ok 7 ", @@foo+0, "\n";}
if ($foo[0] eq 'd') {print "ok 8\n";} else {print "not ok 8 ", $foo[0], "\n";}
if ($foo[1] eq 'e') {print "ok 9\n";} else {print "not ok 9 ", $foo[1], "\n";}
if ($foo{4} eq '') {print "ok 10\n";} else {print "not ok 10 $foo{4}\n";}
if ($foo{5} eq '') {print "ok 11\n";} else {print "not ok 11 $foo{5}\n";}
if ($foo{1} eq 'a') {print "ok 12\n";} else {print "not ok 12\n";}
if ($foo{3} eq 'c') {print "ok 13\n";} else {print "not ok 13\n";}

$foo = join('',values(%foo));
if ($foo eq 'ac' || $foo eq 'ca') {print "ok 14\n";} else {print "not ok 14\n";}

foreach $key (keys %foo) {
d28 2
a29 2
$foo = join('',values(%foo));
print +($foo eq 'xy' || $foo eq 'yx') ? "ok 15\n" : "not ok 15\n";
d37 1
a37 1
print "@@list" eq "foo" ? "ok 16\n" : "not ok 16 @@list\n";
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d3 1
a3 1
print "1..36\n";
d5 1
a5 1
# delete() on hash elements
d16 1
a16 1
unless (exists $foo{2}) {print "ok 2\n";} else {print "not ok 2 $foo{2}\n";}
d27 2
a28 2
unless (exists $foo{4}) {print "ok 10\n";} else {print "not ok 10 $foo{4}\n";}
unless (exists $foo{5}) {print "ok 11\n";} else {print "not ok 11 $foo{5}\n";}
a51 72

{
    my %a = ('bar', 33);
    my($a) = \(values %a);
    my $b = \$a{bar};
    my $c = \delete $a{bar};

    print "not " unless $a == $b && $b == $c;
    print "ok 17\n";
}

# delete() on array elements

@@foo = ();
$foo[1] = 'a';
$foo[2] = 'b';
$foo[3] = 'c';
$foo[4] = 'd';
$foo[5] = 'e';

$foo = delete $foo[2];

if ($foo eq 'b') {print "ok 18\n";} else {print "not ok 18 $foo\n";}
unless (exists $foo[2]) {print "ok 19\n";} else {print "not ok 19 $foo[2]\n";}
if ($foo[1] eq 'a') {print "ok 20\n";} else {print "not ok 20\n";}
if ($foo[3] eq 'c') {print "ok 21\n";} else {print "not ok 21\n";}
if ($foo[4] eq 'd') {print "ok 22\n";} else {print "not ok 22\n";}
if ($foo[5] eq 'e') {print "ok 23\n";} else {print "not ok 23\n";}

@@bar = delete @@foo[4,5];

if (@@bar == 2) {print "ok 24\n";} else {print "not ok 24 ", @@bar+0, "\n";}
if ($bar[0] eq 'd') {print "ok 25\n";} else {print "not ok 25 ", $bar[0], "\n";}
if ($bar[1] eq 'e') {print "ok 26\n";} else {print "not ok 26 ", $bar[1], "\n";}
unless (exists $foo[4]) {print "ok 27\n";} else {print "not ok 27 $foo[4]\n";}
unless (exists $foo[5]) {print "ok 28\n";} else {print "not ok 28 $foo[5]\n";}
if ($foo[1] eq 'a') {print "ok 29\n";} else {print "not ok 29\n";}
if ($foo[3] eq 'c') {print "ok 30\n";} else {print "not ok 30\n";}

$foo = join('',@@foo);
if ($foo eq 'ac') {print "ok 31\n";} else {print "not ok 31\n";}

if (@@foo == 4) {print "ok 32\n";} else {print "not ok 32\n";}

foreach $key (0 .. $#foo) {
    delete $foo[$key];
}

if (@@foo == 0) {print "ok 33\n";} else {print "not ok 33\n";}

$foo[0] = 'x';
$foo[1] = 'y';

$foo = "@@foo";
print +($foo eq 'x y') ? "ok 34\n" : "not ok 34\n";

$refary[0]->[0] = "FOO";
$refary[0]->[3] = "BAR";

delete $refary[0]->[3];

print @@{$refary[0]} == 1 ? "ok 35\n" : "not ok 35 @@list\n";

{
    my @@a = 33;
    my($a) = \(@@a);
    my $b = \$a[0];
    my $c = \delete $a[bar];

    print "not " unless $a == $b && $b == $c;
    print "ok 36\n";
}
@


1.1.1.4
log
@Import of stock perl 5.8.5
@
text
@d3 1
a3 1
print "1..37\n";
a122 8
}

{
    # [perl #29127] scalar delete of empty slice returned garbage
    my %h;
    my ($x,$y) = (1, scalar delete @@h{()});
    print "not " if defined $y;
    print "ok 37\n";
@


1.1.1.5
log
@perl 5.8.6 from CPAN
@
text
@d3 1
a3 1
print "1..38\n";
a130 13
}

{
    # [perl #30733] array delete didn't free returned element
    my $x = 0;
    sub X::DESTROY { $x++ }
    {
	my @@a;
	$a[0] = bless [], 'X';
	my $y = delete $a[0];
    }
    print "not " unless $x == 1;
    print "ok 38\n";
@


1.1.1.6
log
@import perl 5.10.0 from CPAN
@
text
@d3 1
a3 7
BEGIN {
    chdir 't' if -d 't';
    @@INC = qw(. ../lib);
}

require "test.pl";
plan( tests => 38 );
d15 6
a20 6
cmp_ok($foo,'eq','b','delete 2');
ok(!(exists $foo{2}),'b absent');
cmp_ok($foo{1},'eq','a','a exists');
cmp_ok($foo{3},'eq','c','c exists');
cmp_ok($foo{4},'eq','d','d exists');
cmp_ok($foo{5},'eq','e','e exists');
d24 7
a30 7
cmp_ok(scalar(@@foo),'==',2,'deleted slice');
cmp_ok($foo[0],'eq','d','slice 1');
cmp_ok($foo[1],'eq','e','slice 2');
ok(!(exists $foo{4}),'d absent');
ok(!(exists $foo{5}),'e absent');
cmp_ok($foo{1},'eq','a','a still exists');
cmp_ok($foo{3},'eq','c','c still exists');
d33 1
a33 1
ok($foo eq 'ac' || $foo eq 'ca','remaining keys');
d43 1
a43 1
ok($foo eq 'xy' || $foo eq 'yx','fresh keys');
d51 1
a51 1
cmp_ok("@@list",'eq',"foo", 'autoviv and delete hashref');
d59 2
a60 1
    ok($a == $b && $b == $c,'a b c equivalent');
d74 6
a79 6
cmp_ok($foo,'eq','b','ary delete 2');
ok(!(exists $foo[2]),'ary b absent');
cmp_ok($foo[1],'eq','a','ary a exists');
cmp_ok($foo[3],'eq','c','ary c exists');
cmp_ok($foo[4],'eq','d','ary d exists');
cmp_ok($foo[5],'eq','e','ary e exists');
d83 7
a89 7
cmp_ok(scalar(@@bar),'==',2,'ary deleted slice');
cmp_ok($bar[0],'eq','d','ary slice 1');
cmp_ok($bar[1],'eq','e','ary slice 2');
ok(!(exists $foo[4]),'ary d absent');
ok(!(exists $foo[5]),'ary e absent');
cmp_ok($foo[1],'eq','a','ary a still exists');
cmp_ok($foo[3],'eq','c','ary c still exists');
d92 3
a94 2
cmp_ok($foo,'eq','ac','ary elems');
cmp_ok(scalar(@@foo),'==',4,'four is the number thou shalt count');
d100 1
a100 1
cmp_ok(scalar(@@foo),'==',0,'and then there were none');
d106 1
a106 1
cmp_ok($foo,'eq','x y','two fresh');
d113 1
a113 1
cmp_ok( scalar(@@{$refary[0]}),'==',1,'one down');
d121 2
a122 1
    ok($a == $b && $b == $c,'a b c also equivalent');
d126 1
d129 2
a130 1
    ok(!defined($y),q([perl #29127] scalar delete of empty slice returned garbage));
d134 1
d142 2
a143 1
    cmp_ok($x,'==',1,q([perl #30733] array delete didn't free returned element));
@


1.1.1.7
log
@Import perl-5.24.2
@
text
@d8 1
a8 1
require "./test.pl";
@


