head	1.2;
access;
symbols
	PERL_5_24_2:1.1.1.7
	OPENBSD_6_1:1.2.0.4
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.6.0.10
	OPENBSD_6_0_BASE:1.1.1.6
	OPENBSD_5_9:1.1.1.6.0.4
	OPENBSD_5_9_BASE:1.1.1.6
	OPENBSD_5_8:1.1.1.6.0.6
	OPENBSD_5_8_BASE:1.1.1.6
	PERL_5_20_2:1.1.1.6
	OPENBSD_5_7:1.1.1.6.0.2
	OPENBSD_5_7_BASE:1.1.1.6
	PERL_5_20_1:1.1.1.6
	OPENBSD_5_6:1.1.1.5.0.4
	OPENBSD_5_6_BASE:1.1.1.5
	PERL_5_18_2:1.1.1.5
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.4.0.6
	OPENBSD_5_5_BASE:1.1.1.4
	OPENBSD_5_4:1.1.1.4.0.2
	OPENBSD_5_4_BASE:1.1.1.4
	PERL_5_16_3:1.1.1.4
	OPENBSD_5_3:1.1.1.3.0.18
	OPENBSD_5_3_BASE:1.1.1.3
	OPENBSD_5_2:1.1.1.3.0.16
	OPENBSD_5_2_BASE:1.1.1.3
	OPENBSD_5_1_BASE:1.1.1.3
	OPENBSD_5_1:1.1.1.3.0.14
	OPENBSD_5_0:1.1.1.3.0.12
	OPENBSD_5_0_BASE:1.1.1.3
	OPENBSD_4_9:1.1.1.3.0.10
	OPENBSD_4_9_BASE:1.1.1.3
	PERL_5_12_2:1.1.1.3
	OPENBSD_4_8:1.1.1.3.0.8
	OPENBSD_4_8_BASE:1.1.1.3
	OPENBSD_4_7:1.1.1.3.0.4
	OPENBSD_4_7_BASE:1.1.1.3
	PERL_5_10_1:1.1.1.3
	OPENBSD_4_6:1.1.1.3.0.6
	OPENBSD_4_6_BASE:1.1.1.3
	OPENBSD_4_5:1.1.1.3.0.2
	OPENBSD_4_5_BASE:1.1.1.3
	PERL_5_10_0:1.1.1.3
	OPENBSD_4_4:1.1.1.2.0.20
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.18
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_2:1.1.1.2.0.16
	OPENBSD_4_2_BASE:1.1.1.2
	OPENBSD_4_1:1.1.1.2.0.14
	OPENBSD_4_1_BASE:1.1.1.2
	OPENBSD_4_0:1.1.1.2.0.12
	OPENBSD_4_0_BASE:1.1.1.2
	PERL_5_8_8:1.1.1.2
	OPENBSD_3_9:1.1.1.2.0.10
	OPENBSD_3_9_BASE:1.1.1.2
	OPENBSD_3_8:1.1.1.2.0.8
	OPENBSD_3_8_BASE:1.1.1.2
	OPENBSD_3_7:1.1.1.2.0.6
	OPENBSD_3_7_BASE:1.1.1.2
	PERL_5_8_6:1.1.1.2
	OPENBSD_3_6:1.1.1.2.0.4
	OPENBSD_3_6_BASE:1.1.1.2
	PERL_5_8_5:1.1.1.2
	PERL_5_8_3:1.1.1.2
	OPENBSD_3_5:1.1.1.2.0.2
	OPENBSD_3_5_BASE:1.1.1.2
	PERL_5_8_2:1.1.1.2
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	PERL_5_8_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.32.20;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2002.10.27.22.15.10;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.27.22.15.10;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.12.03.02.44.32;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2008.09.29.17.19.01;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2013.03.25.20.09.36;	author sthen;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2014.03.24.14.59.10;	author afresh1;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2014.11.17.20.53.18;	author afresh1;	state Exp;
branches;
next	1.1.1.7;
commitid	B31cAbBIXiCqnL97;

1.1.1.7
date	2017.08.14.13.46.24;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl

BEGIN {
    chdir 't' if -d 't';
    require './test.pl';
    set_up_inc(qw '../lib ../cpan/Text-ParseWords/lib');
    require Config; # load these before we mess with *CORE::GLOBAL::require
    require 'Config_heavy.pl'; # since runperl will need them
}

plan tests => 36;

#
# This file tries to test builtin override using CORE::GLOBAL
#
my $dirsep = "/";

BEGIN { package Foo; *main::getlogin = sub { "kilroy"; } }

is( getlogin, "kilroy" );

my $t = 42;
BEGIN { *CORE::GLOBAL::time = sub () { $t; } }

is( 45, time + 3 );

#
# require has special behaviour
#
my $r;
BEGIN { *CORE::GLOBAL::require = sub { $r = shift; 1; } }

require Foo;
is( $r, "Foo.pm" );

require Foo::Bar;
is( $r, join($dirsep, "Foo", "Bar.pm") );

require 'Foo';
is( $r, "Foo" );

require 5.006;
is( $r, "5.006" );

require v5.6;
ok( abs($r - 5.006) < 0.001 && $r eq "\x05\x06" );

eval "use Foo";
is( $r, "Foo.pm" );

eval "use Foo::Bar";
is( $r, join($dirsep, "Foo", "Bar.pm") );

{
    my @@r;
    local *CORE::GLOBAL::require = sub { push @@r, shift; 1; };
    eval "use 5.006";
    like( " @@r ", qr " 5\.006 " );
}

{
    local $_ = 'foo.pm';
    require;
    is( $r, 'foo.pm' );
}

# localizing *CORE::GLOBAL::foo should revert to finding CORE::foo
{
    local(*CORE::GLOBAL::require);
    $r = '';
    eval "require NoNeXiSt;";
    ok( ! ( $r or $@@ !~ /^Can't locate NoNeXiSt/i ) );
}

#
# readline() has special behaviour too
#

$r = 11;
BEGIN { *CORE::GLOBAL::readline = sub (;*) { ++$r }; }
is( <FH>	, 12 );
is( <$fh>	, 13 );
my $pad_fh;
is( <$pad_fh>	, 14 );
{
    my $buf = ''; $buf .= <FH>;
    is( $buf, 15, 'rcatline' );
}

# Non-global readline() override
BEGIN { *Rgs::readline = sub (;*) { --$r }; }
{
    package Rgs;
    ::is( <FH>	, 14 );
    ::is( <$fh>	, 13 );
    ::is( <$pad_fh>	, 12 );
    my $buf = ''; $buf .= <FH>;
    ::is( $buf, 11, 'rcatline' );
}

# Global readpipe() override
BEGIN { *CORE::GLOBAL::readpipe = sub ($) { "$_[0] " . --$r }; }
is( `rm`,	    "rm 10", '``' );
is( qx/cp/,	    "cp 9", 'qx' );

# Non-global readpipe() override
BEGIN { *Rgs::readpipe = sub ($) { ++$r . " $_[0]" }; }
{
    package Rgs;
    ::is( `rm`,		  "10 rm", '``' );
    ::is( qx/cp/,	  "11 cp", 'qx' );
}

# Verify that the parsing of overridden keywords isn't messed up
# by the indirect object notation
{
    local $SIG{__WARN__} = sub {
	::like( $_[0], qr/^ok overriden at/ );
    };
    BEGIN { *OverridenWarn::warn = sub { CORE::warn "@@_ overriden"; }; }
    package OverridenWarn;
    sub foo { "ok" }
    warn( OverridenWarn->foo() );
    warn OverridenWarn->foo();
}
BEGIN { *OverridenPop::pop = sub { ::is( $_[0][0], "ok" ) }; }
{
    package OverridenPop;
    sub foo { [ "ok" ] }
    pop( OverridenPop->foo() );
    pop OverridenPop->foo();
}

{
    eval {
        local *CORE::GLOBAL::require = sub {
            CORE::require($_[0]);
        };
        require 5;
        require Text::ParseWords;
    };
    is $@@, '';
}

# Constant inlining should not countermand "use subs" overrides
BEGIN { package other; *::caller = \&::caller }
sub caller() { 42 }
caller; # inline the constant
is caller, 42, 'constant inlining does not undo "use subs" on keywords';

is runperl(prog => 'sub CORE::GLOBAL::do; do file; print qq-ok\n-'),
  "ok\n",
  'no crash with CORE::GLOBAL::do stub';
is runperl(prog => 'sub CORE::GLOBAL::glob; glob; print qq-ok\n-'),
  "ok\n",
  'no crash with CORE::GLOBAL::glob stub';
is runperl(prog => 'sub CORE::GLOBAL::require; require re; print qq-o\n-'),
  "o\n",
  'no crash with CORE::GLOBAL::require stub';

like runperl(prog => 'use constant foo=>1; '
                    .'BEGIN { *{q|CORE::GLOBAL::readpipe|} = \&{q|foo|};1}'
                    .'warn ``',
             stderr => 1),
     qr/Too many arguments/,
    '`` does not ignore &CORE::GLOBAL::readpipe aliased to a constant';
like runperl(prog => 'use constant foo=>1; '
                    .'BEGIN { *{q|CORE::GLOBAL::readline|} = \&{q|foo|};1}'
                    .'warn <a>',
             stderr => 1),
     qr/Too many arguments/,
    '<> does not ignore &CORE::GLOBAL::readline aliased to a constant';

is runperl(prog => 'use constant t=>42; '
                  .'BEGIN { *{q|CORE::GLOBAL::time|} = \&{q|t|};1}'
                  .'print time, chr utf8::unicode_to_native(10)',
          stderr => 1),
   "42\n",
   'keywords respect global constant overrides';
@


1.1
log
@Initial revision
@
text
@d5 4
a8 2
    @@INC = '.';
    push @@INC, '../lib';
d11 1
a11 1
print "1..17\n";
d20 1
a20 2
print "not " unless getlogin eq "kilroy";
print "ok 1\n";
d25 1
a25 2
print "not " unless 45 == time + 3;
print "ok 2\n";
d34 1
a34 2
print "not " unless $r eq "Foo.pm";
print "ok 3\n";
d37 1
a37 2
print "not " unless $r eq join($dirsep, "Foo", "Bar.pm");
print "ok 4\n";
d40 1
a40 2
print "not " unless $r eq "Foo";
print "ok 5\n";
d42 2
a43 3
require 5.6;
print "not " unless $r eq "5.6";
print "ok 6\n";
d46 1
a46 2
print "not " unless abs($r - 5.006) < 0.001 && $r eq "\x05\x06";
print "ok 7\n";
d49 1
a49 2
print "not " unless $r eq "Foo.pm";
print "ok 8\n";
d52 1
a52 2
print "not " unless $r eq join($dirsep, "Foo", "Bar.pm");
print "ok 9\n";
d54 12
a65 3
eval "use 5.6";
print "not " unless $r eq "5.6";
print "ok 10\n";
d72 1
a72 2
    print "not " if $r or $@@ !~ /^Can't locate NoNeXiSt/i;
    print "ok 11\n";
d81 2
a82 2
print <FH>	== 12 ? "ok 12\n" : "not ok 12\n";
print <$fh>	== 13 ? "ok 13\n" : "not ok 13\n";
d84 5
a88 1
print <$pad_fh>	== 14 ? "ok 14\n" : "not ok 14\n";
d92 88
a179 4
package Rgs;
print <FH>	== 13 ? "ok 15\n" : "not ok 15\n";
print <$fh>	== 12 ? "ok 16\n" : "not ok 16\n";
print <$pad_fh>	== 11 ? "ok 17\n" : "not ok 17\n";
@


1.1.1.1
log
@stock perl 5.8.0 from CPAN
@
text
@@


1.1.1.2
log
@perl 5.8.2 from CPAN
@
text
@d5 2
a6 2
    @@INC = '../lib';
    require './test.pl';
d9 1
a9 1
plan tests => 21;
d18 2
a19 1
is( getlogin, "kilroy" );
d24 2
a25 1
is( 45, time + 3 );
d34 2
a35 1
is( $r, "Foo.pm" );
d38 2
a39 1
is( $r, join($dirsep, "Foo", "Bar.pm") );
d42 2
a43 1
is( $r, "Foo" );
d46 2
a47 1
is( $r, "5.6" );
d50 2
a51 1
ok( abs($r - 5.006) < 0.001 && $r eq "\x05\x06" );
d54 2
a55 1
is( $r, "Foo.pm" );
d58 2
a59 1
is( $r, join($dirsep, "Foo", "Bar.pm") );
d62 2
a63 1
is( $r, "5.6" );
d70 2
a71 1
    ok( ! ( $r or $@@ !~ /^Can't locate NoNeXiSt/i ) );
d80 2
a81 2
is( <FH>	, 12 );
is( <$fh>	, 13 );
d83 1
a83 1
is( <$pad_fh>	, 14 );
d88 3
a90 21
::is( <FH>	, 13 );
::is( <$fh>	, 12 );
::is( <$pad_fh>	, 11 );

# Verify that the parsing of overriden keywords isn't messed up
# by the indirect object notation
{
    local $SIG{__WARN__} = sub {
	::like( $_[0], qr/^ok overriden at/ );
    };
    BEGIN { *OverridenWarn::warn = sub { CORE::warn "@@_ overriden"; }; }
    package OverridenWarn;
    sub foo { "ok" }
    warn( OverridenWarn->foo() );
    warn OverridenWarn->foo();
}
BEGIN { *OverridenPop::pop = sub { ::is( $_[0][0], "ok" ) }; }
package OverridenPop;
sub foo { [ "ok" ] }
pop( OverridenPop->foo() );
pop OverridenPop->foo();
@


1.1.1.3
log
@import perl 5.10.0 from CPAN
@
text
@d9 1
a9 1
plan tests => 26;
d76 4
a79 19
{
    package Rgs;
    ::is( <FH>	, 13 );
    ::is( <$fh>	, 12 );
    ::is( <$pad_fh>	, 11 );
}

# Global readpipe() override
BEGIN { *CORE::GLOBAL::readpipe = sub ($) { "$_[0] " . --$r }; }
is( `rm`,	    "rm 10", '``' );
is( qx/cp/,	    "cp 9", 'qx' );

# Non-global readpipe() override
BEGIN { *Rgs::readpipe = sub ($) { ++$r . " $_[0]" }; }
{
    package Rgs;
    ::is( `rm`,		  "10 rm", '``' );
    ::is( qx/cp/,	  "11 cp", 'qx' );
}
d94 4
a97 17
{
    package OverridenPop;
    sub foo { [ "ok" ] }
    pop( OverridenPop->foo() );
    pop OverridenPop->foo();
}

{
    eval {
        local *CORE::GLOBAL::require = sub {
            CORE::require($_[0]);
        };
        require 5;
        require Text::ParseWords;
    };
    is $@@, '';
}
@


1.1.1.4
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d9 1
a9 1
plan tests => 28;
d40 2
a41 2
require 5.006;
is( $r, "5.006" );
d52 2
a53 19
# use VERSION also loads feature.pm.
{
    my @@r;
    local *CORE::GLOBAL::require = sub { push @@r, shift; 1; };
    eval "use 5.006";
    like( " @@r ", qr " 5\.006 " );
}

{
    local $_ = 'foo.pm';
    require;
    is( $r, 'foo.pm' );
}

{
    my $_ = 'bar.pm';
    require;
    is( $r, 'bar.pm' );
}
d96 1
a96 1
# Verify that the parsing of overridden keywords isn't messed up
@


1.1.1.5
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d52 1
a66 5
    BEGIN {
        # Can’t do ‘no warnings’ with CORE::GLOBAL::require overridden. :-)
        CORE::require warnings;
        unimport warnings 'experimental::lexical_topic';
    }
@


1.1.1.6
log
@Import perl-5.20.1
@
text
@a6 2
    require Config; # load these before we mess with *CORE::GLOBAL::require
    require 'Config_heavy.pl'; # since runperl will need them
d9 1
a9 1
plan tests => 35;
a146 36

# Constant inlining should not countermand "use subs" overrides
BEGIN { package other; *::caller = \&::caller }
sub caller() { 42 }
caller; # inline the constant
is caller, 42, 'constant inlining does not undo "use subs" on keywords';

is runperl(prog => 'sub CORE::GLOBAL::do; do file; print qq-ok\n-'),
  "ok\n",
  'no crash with CORE::GLOBAL::do stub';
is runperl(prog => 'sub CORE::GLOBAL::glob; glob; print qq-ok\n-'),
  "ok\n",
  'no crash with CORE::GLOBAL::glob stub';
is runperl(prog => 'sub CORE::GLOBAL::require; require re; print qq-o\n-'),
  "o\n",
  'no crash with CORE::GLOBAL::require stub';

like runperl(prog => 'use constant foo=>1; '
                    .'BEGIN { *{q|CORE::GLOBAL::readpipe|} = \&{q|foo|};1}'
                    .'warn ``',
             stderr => 1),
     qr/Too many arguments/,
    '`` does not ignore &CORE::GLOBAL::readpipe aliased to a constant';
like runperl(prog => 'use constant foo=>1; '
                    .'BEGIN { *{q|CORE::GLOBAL::readline|} = \&{q|foo|};1}'
                    .'warn <a>',
             stderr => 1),
     qr/Too many arguments/,
    '<> does not ignore &CORE::GLOBAL::readline aliased to a constant';

is runperl(prog => 'use constant t=>42; '
                  .'BEGIN { *{q|CORE::GLOBAL::time|} = \&{q|t|};1}'
                  .'print time, chr 10',
          stderr => 1),
   "42\n",
   'keywords respect global constant overrides';
@


1.1.1.7
log
@Import perl-5.24.2
@
text
@d5 1
a6 1
    set_up_inc(qw '../lib ../cpan/Text-ParseWords/lib');
d11 1
a11 1
plan tests => 36;
d67 11
a95 4
{
    my $buf = ''; $buf .= <FH>;
    is( $buf, 15, 'rcatline' );
}
d101 3
a103 5
    ::is( <FH>	, 14 );
    ::is( <$fh>	, 13 );
    ::is( <$pad_fh>	, 12 );
    my $buf = ''; $buf .= <FH>;
    ::is( $buf, 11, 'rcatline' );
d181 1
a181 1
                  .'print time, chr utf8::unicode_to_native(10)',
@


