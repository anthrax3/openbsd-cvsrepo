head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1:1.1.1.8.0.14
	OPENBSD_6_1_BASE:1.1.1.8
	OPENBSD_6_0:1.1.1.8.0.16
	OPENBSD_6_0_BASE:1.1.1.8
	OPENBSD_5_9:1.1.1.8.0.10
	OPENBSD_5_9_BASE:1.1.1.8
	OPENBSD_5_8:1.1.1.8.0.12
	OPENBSD_5_8_BASE:1.1.1.8
	PERL_5_20_2:1.1.1.8
	OPENBSD_5_7:1.1.1.8.0.4
	OPENBSD_5_7_BASE:1.1.1.8
	PERL_5_20_1:1.1.1.8
	OPENBSD_5_6:1.1.1.8.0.8
	OPENBSD_5_6_BASE:1.1.1.8
	PERL_5_18_2:1.1.1.8
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.8.0.6
	OPENBSD_5_5_BASE:1.1.1.8
	OPENBSD_5_4:1.1.1.8.0.2
	OPENBSD_5_4_BASE:1.1.1.8
	PERL_5_16_3:1.1.1.8
	OPENBSD_5_3:1.1.1.7.0.10
	OPENBSD_5_3_BASE:1.1.1.7
	OPENBSD_5_2:1.1.1.7.0.8
	OPENBSD_5_2_BASE:1.1.1.7
	OPENBSD_5_1_BASE:1.1.1.7
	OPENBSD_5_1:1.1.1.7.0.6
	OPENBSD_5_0:1.1.1.7.0.4
	OPENBSD_5_0_BASE:1.1.1.7
	OPENBSD_4_9:1.1.1.7.0.2
	OPENBSD_4_9_BASE:1.1.1.7
	PERL_5_12_2:1.1.1.7
	OPENBSD_4_8:1.1.1.6.0.8
	OPENBSD_4_8_BASE:1.1.1.6
	OPENBSD_4_7:1.1.1.6.0.4
	OPENBSD_4_7_BASE:1.1.1.6
	PERL_5_10_1:1.1.1.6
	OPENBSD_4_6:1.1.1.6.0.6
	OPENBSD_4_6_BASE:1.1.1.6
	OPENBSD_4_5:1.1.1.6.0.2
	OPENBSD_4_5_BASE:1.1.1.6
	PERL_5_10_0:1.1.1.6
	OPENBSD_4_4:1.1.1.5.0.20
	OPENBSD_4_4_BASE:1.1.1.5
	OPENBSD_4_3:1.1.1.5.0.18
	OPENBSD_4_3_BASE:1.1.1.5
	OPENBSD_4_2:1.1.1.5.0.16
	OPENBSD_4_2_BASE:1.1.1.5
	OPENBSD_4_1:1.1.1.5.0.14
	OPENBSD_4_1_BASE:1.1.1.5
	OPENBSD_4_0:1.1.1.5.0.12
	OPENBSD_4_0_BASE:1.1.1.5
	PERL_5_8_8:1.1.1.5
	OPENBSD_3_9:1.1.1.5.0.10
	OPENBSD_3_9_BASE:1.1.1.5
	OPENBSD_3_8:1.1.1.5.0.8
	OPENBSD_3_8_BASE:1.1.1.5
	OPENBSD_3_7:1.1.1.5.0.6
	OPENBSD_3_7_BASE:1.1.1.5
	PERL_5_8_6:1.1.1.5
	OPENBSD_3_6:1.1.1.5.0.4
	OPENBSD_3_6_BASE:1.1.1.5
	PERL_5_8_5:1.1.1.5
	PERL_5_8_3:1.1.1.5
	OPENBSD_3_5:1.1.1.5.0.2
	OPENBSD_3_5_BASE:1.1.1.5
	PERL_5_8_2:1.1.1.5
	OPENBSD_3_4:1.1.1.4.0.4
	OPENBSD_3_4_BASE:1.1.1.4
	OPENBSD_3_3:1.1.1.4.0.2
	OPENBSD_3_3_BASE:1.1.1.4
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.1.1.3.0.6
	OPENBSD_3_2_BASE:1.1.1.3
	OPENBSD_3_1:1.1.1.3.0.4
	OPENBSD_3_1_BASE:1.1.1.3
	OPENBSD_3_0:1.1.1.3.0.2
	OPENBSD_3_0_BASE:1.1.1.3
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.1.1.2.0.6
	OPENBSD_2_9_BASE:1.1.1.2
	OPENBSD_2_8:1.1.1.2.0.4
	OPENBSD_2_8_BASE:1.1.1.2
	OPENBSD_2_7:1.1.1.2.0.2
	OPENBSD_2_7_BASE:1.1.1.2
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.1.1.1.0.2
	OPENBSD_2_6_BASE:1.1.1.1
	PERL_500503:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.1
date	99.04.29.22.41.53;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.29.22.41.53;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.04.06.16.10.52;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.05.24.18.25.48;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.27.22.15.11;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.12.03.02.44.33;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2008.09.29.17.19.02;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2010.09.24.14.49.17;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2013.03.25.20.09.37;	author sthen;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@#!./perl


BEGIN {
    chdir 't' if -d 't';
    @@INC = '../lib';
}

my %seen;

package Implement;

sub TIEARRAY
{
 $seen{'TIEARRAY'}++;
 my ($class,@@val) = @@_;
 return bless \@@val,$class;
}

sub STORESIZE
{        
 $seen{'STORESIZE'}++;
 my ($ob,$sz) = @@_; 
 return $#{$ob} = $sz-1;
}

sub EXTEND
{        
 $seen{'EXTEND'}++;
 my ($ob,$sz) = @@_; 
 return @@$ob = $sz;
}

sub FETCHSIZE
{        
 $seen{'FETCHSIZE'}++;
 return scalar(@@{$_[0]});
}

sub FETCH
{
 $seen{'FETCH'}++;
 my ($ob,$id) = @@_;
 return $ob->[$id]; 
}

sub STORE
{
 $seen{'STORE'}++;
 my ($ob,$id,$val) = @@_;
 $ob->[$id] = $val; 
}                 

sub UNSHIFT
{
 $seen{'UNSHIFT'}++;
 my $ob = shift;
 unshift(@@$ob,@@_);
}                 

sub PUSH
{
 $seen{'PUSH'}++;
 my $ob = shift;;
 push(@@$ob,@@_);
}                 

sub CLEAR
{
 $seen{'CLEAR'}++;
 @@{$_[0]} = ();
}

sub DESTROY
{
 $seen{'DESTROY'}++;
}

sub POP
{
 $seen{'POP'}++;
 my ($ob) = @@_;
 return pop(@@$ob);
}

sub SHIFT
{
 $seen{'SHIFT'}++;
 my ($ob) = @@_;
 return shift(@@$ob);
}

sub SPLICE
{
 $seen{'SPLICE'}++;
 my $ob  = shift;                    
 my $off = @@_ ? shift : 0;
 my $len = @@_ ? shift : @@$ob-1;
 return splice(@@$ob,$off,$len,@@_);
}

package main;

print "1..31\n";                   
my $test = 1;

{my @@ary;

{ my $ob = tie @@ary,'Implement',3,2,1;
  print "not " unless $ob;
  print "ok ", $test++,"\n";
  print "not " unless tied(@@ary) == $ob;
  print "ok ", $test++,"\n";
}


print "not " unless @@ary == 3;
print "ok ", $test++,"\n";

print "not " unless $#ary == 2;
print "ok ", $test++,"\n";

print "not " unless join(':',@@ary) eq '3:2:1';
print "ok ", $test++,"\n";         

print "not " unless $seen{'FETCH'} >= 3;
print "ok ", $test++,"\n";

@@ary = (1,2,3);

print "not " unless $seen{'STORE'} >= 3;
print "ok ", $test++,"\n";
print "not " unless join(':',@@ary) eq '1:2:3';
print "ok ", $test++,"\n";         

{my @@thing = @@ary;
print "not " unless join(':',@@thing) eq '1:2:3';
print "ok ", $test++,"\n";         

tie @@thing,'Implement';
@@thing = @@ary;
print "not " unless join(':',@@thing) eq '1:2:3';
print "ok ", $test++,"\n";
} 

print "not " unless pop(@@ary) == 3;
print "ok ", $test++,"\n";
print "not " unless $seen{'POP'} == 1;
print "ok ", $test++,"\n";
print "not " unless join(':',@@ary) eq '1:2';
print "ok ", $test++,"\n";

push(@@ary,4);
print "not " unless $seen{'PUSH'} == 1;
print "ok ", $test++,"\n";
print "not " unless join(':',@@ary) eq '1:2:4';
print "ok ", $test++,"\n";

my @@x = splice(@@ary,1,1,7);


print "not " unless $seen{'SPLICE'} == 1;
print "ok ", $test++,"\n";

print "not " unless @@x == 1;
print "ok ", $test++,"\n";
print "not " unless $x[0] == 2;
print "ok ", $test++,"\n";
print "not " unless join(':',@@ary) eq '1:7:4';
print "ok ", $test++,"\n";             

print "not " unless shift(@@ary) == 1;
print "ok ", $test++,"\n";
print "not " unless $seen{'SHIFT'} == 1;
print "ok ", $test++,"\n";
print "not " unless join(':',@@ary) eq '7:4';
print "ok ", $test++,"\n";             

my $n = unshift(@@ary,5,6);
print "not " unless $seen{'UNSHIFT'} == 1;
print "ok ", $test++,"\n";
print "not " unless $n == 4;
print "ok ", $test++,"\n";
print "not " unless join(':',@@ary) eq '5:6:7:4';
print "ok ", $test++,"\n";

@@ary = split(/:/,'1:2:3');
print "not " unless join(':',@@ary) eq '1:2:3';
print "ok ", $test++,"\n";         
  
my $t = 0;
foreach $n (@@ary)
 {
  print "not " unless $n == ++$t;
  print "ok ", $test++,"\n";         
 }

@@ary = qw(3 2 1);
print "not " unless join(':',@@ary) eq '3:2:1';
print "ok ", $test++,"\n";         

untie @@ary;   

}
                           
print "not " unless $seen{'DESTROY'} == 2;
print "ok ", $test++,"\n";         



@


1.1.1.1
log
@perl5.005_03
@
text
@@


1.1.1.2
log
@virgin perl 5.6.0
@
text
@d6 1
a6 1
    unshift @@INC, '../lib';
@


1.1.1.3
log
@stock perl 5.6.1
@
text
@d6 1
a6 1
    @@INC = '../lib';
@


1.1.1.4
log
@stock perl 5.8.0 from CPAN
@
text
@d104 1
a104 1
print "1..36\n";                   
a189 1

a197 19
# (30-33) 20020303 mjd-perl-patch+@@plover.com
@@ary = ();
$seen{POP} = 0;
pop @@ary;                       # this didn't used to call POP at all
print "not " unless $seen{POP} == 1;
print "ok ", $test++,"\n";         
$seen{SHIFT} = 0;
shift @@ary;                     # this didn't used to call SHIFT at  all
print "not " unless $seen{SHIFT} == 1;
print "ok ", $test++,"\n";         
$seen{PUSH} = 0;
push @@ary;                       # this didn't used to call PUSH at all
print "not " unless $seen{PUSH} == 1;
print "ok ", $test++,"\n";         
$seen{UNSHIFT} = 0;
unshift @@ary;                   # this didn't used to call UNSHIFT at all
print "not " unless $seen{UNSHIFT} == 1;
print "ok ", $test++,"\n";         

a204 18

# 20020401 mjd-perl-patch+@@plover.com
# Thanks to Dave Mitchell for the small test case and the fix
{
  my @@a;
  
  sub X::TIEARRAY { bless {}, 'X' }

  sub X::SPLICE {
    do '/dev/null';
    die;
  }

  tie @@a, 'X';
  eval { splice(@@a) };
  # If we survived this far.
  print "ok ", $test++, "\n";
}
d208 2
@


1.1.1.5
log
@perl 5.8.2 from CPAN
@
text
@d102 1
a102 27
package NegIndex;               # 20020220 MJD
@@ISA = 'Implement';

# simulate indices -2 .. 2
my $offset = 2;
$NegIndex::NEGATIVE_INDICES = 1;

sub FETCH {
  my ($ob,$id) = @@_;
#  print "# FETCH @@_\n";
  $id += $offset;
  $ob->[$id];
}

sub STORE {
  my ($ob,$id,$value) = @@_;
#  print "# STORE @@_\n";
  $id += $offset;
  $ob->[$id] = $value;
}

sub DELETE {
  my ($ob,$id) = @@_;
#  print "# DELETE @@_\n";
  $id += $offset;
  delete $ob->[$id];
}
d104 1
a104 10
sub EXISTS {
  my ($ob,$id) = @@_;
#  print "# EXISTS @@_\n";
  $id += $offset;
  exists $ob->[$id];
}

package main;
  
print "1..61\n";                   
a242 48


{ # 20020220 mjd-perl-patch+@@plover.com
  my @@n;
  tie @@n => 'NegIndex', ('A' .. 'E');

  # FETCH
  print "not " unless $n[0] eq 'C';
  print "ok ", $test++,"\n";
  print "not " unless $n[1] eq 'D';
  print "ok ", $test++,"\n";
  print "not " unless $n[2] eq 'E';
  print "ok ", $test++,"\n";
  print "not " unless $n[-1] eq 'B';
  print "ok ", $test++,"\n";
  print "not " unless $n[-2] eq 'A';
  print "ok ", $test++,"\n";

  # STORE
  $n[-2] = 'a';
  print "not " unless $n[-2] eq 'a';
  print "ok ", $test++,"\n";
  $n[-1] = 'b';
  print "not " unless $n[-1] eq 'b';
  print "ok ", $test++,"\n";
  $n[0] = 'c';
  print "not " unless $n[0] eq 'c';
  print "ok ", $test++,"\n";
  $n[1] = 'd';
  print "not " unless $n[1] eq 'd';
  print "ok ", $test++,"\n";
  $n[2] = 'e';
  print "not " unless $n[2] eq 'e';
  print "ok ", $test++,"\n";

  # DELETE and EXISTS
  for (-2 .. 2) {
    print exists($n[$_]) ? "ok $test\n" : "not ok $test\n";
    $test++;
    delete $n[$_];
    print defined($n[$_]) ? "not ok $test\n" : "ok $test\n";
    $test++;
    print exists($n[$_]) ? "not ok $test\n" : "ok $test\n";
    $test++;
  }
}
                           

d244 1
a244 1
print "not " unless $seen{'DESTROY'} == 3;
@


1.1.1.6
log
@import perl 5.10.0 from CPAN
@
text
@a136 11
#
# Returning -1 from FETCHSIZE used to get casted to U32 causing a
# segfault
#

package NegFetchsize;

sub TIEARRAY  { bless [] }
sub FETCH     { }
sub FETCHSIZE { -1 }

d139 1
a139 1
print "1..62\n";                   
a326 8
{
    tie my @@dummy, "NegFetchsize";
    eval { "@@dummy"; };
    print "# $@@" if $@@;
    print "not " unless $@@ =~ /^FETCHSIZE returned a negative value/;
    print "ok ", $test++, " - croak on negative FETCHSIZE\n";
}

@


1.1.1.7
log
@Perl 5.12.2 from CPAN
@
text
@d150 1
a150 1
print "1..66\n";                   
d237 1
a266 13

$#ary = 1;
print "not " unless $seen{'STORESIZE'} == 1;
print "ok ", $test++," -- seen STORESIZE\n";
print "not " unless join(':',@@ary) eq '3:2';
print "ok ", $test++,"\n";

sub arysize :lvalue { $#ary }
arysize()--;
print "not " unless $seen{'STORESIZE'} == 2;
print "ok ", $test++," -- seen STORESIZE\n";
print "not " unless join(':',@@ary) eq '3';
print "ok ", $test++,"\n";
@


1.1.1.8
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d3 1
a6 1
    require './test.pl';
d150 2
a151 1
plan(tests => 69);
d156 4
a159 2
  ok($ob);
  is(tied(@@ary), $ob);
d162 12
a173 4
is(@@ary, 3);
is($#ary, 2);
is(join(':',@@ary), '3:2:1');
cmp_ok($seen{'FETCH'}, '>=', 3);
d177 4
a180 2
cmp_ok($seen{'STORE'}, '>=', 3);
is(join(':',@@ary), '1:2:3');
d183 2
a184 1
is(join(':',@@thing), '1:2:3');
d188 2
a189 1
is(join(':',@@thing), '1:2:3');
d192 12
a203 7
is(pop(@@ary), 3);
is($seen{'POP'}, 1);
is(join(':',@@ary), '1:2');

is(push(@@ary,4), 3);
is($seen{'PUSH'}, 1);
is(join(':',@@ary), '1:2:4');
d207 17
a223 8
is($seen{'SPLICE'}, 1);
is(@@x, 1);
is($x[0], 2);
is(join(':',@@ary), '1:7:4');

is(shift(@@ary), 1);
is($seen{'SHIFT'}, 1);
is(join(':',@@ary), '7:4');
d226 6
a231 3
is($seen{'UNSHIFT'}, 1);
is($n, 4);
is(join(':',@@ary), '5:6:7:4');
d234 2
a235 1
is(join(':',@@ary), '1:2:3');
d240 2
a241 1
     is($n, ++$t);
d248 2
a249 1
is($seen{POP}, 1);
d252 2
a253 1
is($seen{SHIFT}, 1);
d255 3
a257 3
my $got = push @@ary;            # this didn't used to call PUSH at all
is($got, 0);
is($seen{PUSH}, 1);
d259 3
a261 3
$got = unshift @@ary;            # this didn't used to call UNSHIFT at all
is($got, 0);
is($seen{UNSHIFT}, 1);
d264 2
a265 1
is(join(':',@@ary), '3:2:1');
d268 4
a271 2
is($seen{'STORESIZE'}, 1, 'seen STORESIZE');
is(join(':',@@ary), '3:2');
d275 4
a278 2
is($seen{'STORESIZE'}, 2, 'seen STORESIZE');
is(join(':',@@ary), '3');
d299 1
a299 1
  pass();
d302 1
d308 10
a317 5
  is($n[0], 'C');
  is($n[1], 'D');
  is($n[2], 'E');
  is($n[-1], 'B');
  is($n[-2], 'A');
d321 2
a322 1
  is($n[-2], 'a');
d324 2
a325 1
  is($n[-1], 'b');
d327 2
a328 1
  is($n[0], 'c');
d330 2
a331 1
  is($n[1], 'd');
d333 2
a334 1
  is($n[2], 'e');
d338 2
a339 1
    ok($n[$_]);
d341 4
a344 2
    is(defined($n[$_]), '');
    is(exists($n[$_]), '');
d347 1
d349 1
d353 3
a355 2
    like($@@, qr/^FETCHSIZE returned a negative value/,
	 " - croak on negative FETCHSIZE");
d358 3
a360 1
is($seen{'DESTROY'}, 3);
@


