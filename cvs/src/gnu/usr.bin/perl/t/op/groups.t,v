head	1.12;
access;
symbols
	OPENBSD_6_1:1.12.0.4
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.11.0.12
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.6
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.11.0.8
	OPENBSD_5_8_BASE:1.11
	PERL_5_20_2:1.1.1.11
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	PERL_5_20_1:1.1.1.11
	OPENBSD_5_6:1.11.0.4
	OPENBSD_5_6_BASE:1.11
	PERL_5_18_2:1.1.1.11
	PERL:1.1.1
	OPENBSD_5_5:1.10.0.6
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.2
	OPENBSD_5_4_BASE:1.10
	PERL_5_16_3:1.1.1.10
	OPENBSD_5_3:1.9.0.10
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.8
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.6
	OPENBSD_5_0:1.9.0.4
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.2
	OPENBSD_4_9_BASE:1.9
	PERL_5_12_2:1.1.1.9
	OPENBSD_4_8:1.8.0.4
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	PERL_5_10_1:1.1.1.8
	OPENBSD_4_6:1.7.0.6
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.2
	OPENBSD_4_5_BASE:1.7
	PERL_5_10_0:1.1.1.7
	OPENBSD_4_4:1.6.0.10
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.8
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.6
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.4
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.2
	OPENBSD_4_0_BASE:1.6
	PERL_5_8_8:1.1.1.6
	OPENBSD_3_9:1.5.0.14
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.12
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.10
	OPENBSD_3_7_BASE:1.5
	PERL_5_8_6:1.1.1.5
	OPENBSD_3_6:1.5.0.8
	OPENBSD_3_6_BASE:1.5
	PERL_5_8_5:1.1.1.5
	PERL_5_8_3:1.1.1.5
	OPENBSD_3_5:1.5.0.6
	OPENBSD_3_5_BASE:1.5
	PERL_5_8_2:1.1.1.5
	OPENBSD_3_4:1.5.0.4
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.4.0.6
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.4
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.3.0.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.2.0.8
	OPENBSD_2_6_BASE:1.2
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.12
date	2017.02.05.00.32.20;	author afresh1;	state Exp;
branches;
next	1.11;
commitid	cxJ08BvJA9Pt2PTM;

1.11
date	2014.03.24.15.05.33;	author afresh1;	state Exp;
branches;
next	1.10;

1.10
date	2013.03.25.20.40.59;	author sthen;	state Exp;
branches;
next	1.9;

1.9
date	2010.09.24.15.07.08;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2009.10.12.18.30.27;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2008.09.29.17.36.19;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2006.03.28.19.23.12;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.10.27.22.25.37;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.24.18.36.18;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.06.17.08.24;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.08.05.23;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.13.18;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.13.18;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.41.45;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.10.48;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.25.38;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.15.10;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2006.03.28.18.49.45;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2008.09.29.17.19.00;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2009.10.12.18.10.44;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2010.09.24.14.49.16;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2013.03.25.20.09.35;	author sthen;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2014.03.24.14.59.10;	author afresh1;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl
BEGIN {
    if ( $^O eq 'VMS' ) {
        my $p = "/bin:/usr/bin:/usr/xpg4/bin:/usr/ucb";
        if ( $ENV{PATH} ) {
            $p .= ":$ENV{PATH}";
        }
        $ENV{PATH} = $p;
    }
    $ENV{LC_ALL} = "C"; # so that external utilities speak English
    $ENV{LANGUAGE} = 'C'; # GNU locale extension

    chdir 't' if -d 't';
    @@INC = '../lib';
    require './test.pl';
    skip_all_if_miniperl("no dynamic loading on miniperl, no POSIX");
}
use 5.010;
use strict;
use Config ();
use POSIX ();

skip_all('getgrgid() not implemented')
    unless eval { my($foo) = getgrgid(0); 1 };

skip_all("No 'id' or 'groups'") if
    $^O eq 'MSWin32' || $^O eq 'NetWare' || $^O eq 'VMS' || $^O =~ /lynxos/i;

Test();
exit;



sub Test {

    # Get our supplementary groups from the system by running commands
    # like `id -a'.
    my ( $groups_command, $groups_string ) = system_groups()
        or skip_all("No 'id' or 'groups'");
    my @@extracted_groups = extract_system_groups( $groups_string )
        or skip_all("Can't parse '${groups_command}'");

    my $pwgid = $( + 0;
    my ($pwgnam) = getgrgid($pwgid);
    $pwgnam //= '';
    print "# pwgid=$pwgid pwgnam=$pwgnam \$(=$(\n";

    # Get perl's supplementary groups by looking at $(
    my ( $gid_count, $all_perl_groups ) = perl_groups();
    my %basegroup = basegroups( $pwgid, $pwgnam );
    my @@extracted_supplementary_groups = remove_basegroup( \ %basegroup, \ @@extracted_groups );

    print "1..2\n";


    # Test: The supplementary groups in $( should match the
    # getgroups(2) kernal API call.
    #
    my $ngroups_max = posix_ngroups_max();
    if ( defined $ngroups_max && $ngroups_max < @@extracted_groups ) {
        # Some OSes (like darwin)but conceivably others might return
        # more groups from `id -a' than can be handled by the
        # kernel. On darwin, NGROUPS_MAX is 16 and 12 are taken up for
        # the system already.
        #
        # There is more fall-out from this than just Perl's unit
        # tests. You may be a member of a group according to Active
        # Directory (or whatever) but the OS won't respect it because
        # it's the 17th (or higher) group and there's no space to
        # store your membership.
        print "ok 1 # SKIP Your platform's `$groups_command' is broken\n";
    }

    elsif ( darwin() ) {
        # darwin uses getgrouplist(3) or an Open Directory API within
        # /usr/bin/id and /usr/bin/groups which while "nice" isn't
        # accurate for this test. The hard, real, list of groups we're
        # running in derives from getgroups(2) and is not dynamic but
        # the Libc API getgrouplist(3) is.
        #
        # In practical terms, this meant that while `id -a' can be
        # relied on in other OSes to purely use getgroups(2) and show
        # us what's real, darwin will use getgrouplist(3) to show us
        # what might be real if only we'd open a new console.
        #
        print "ok 1 # SKIP darwin's `${groups_command}' can't be trusted\n";
    }

    else {

        # Read $( but ignore any groups in $( that we failed to parse
        # successfully out of the `id -a` mess.
        #
        my @@perl_groups = remove_unparsed_entries( \ @@extracted_groups,
                                                   \ @@$all_perl_groups );
        my @@supplementary_groups = remove_basegroup( \ %basegroup,
                                                     \ @@perl_groups );

        my $ok1 = 0;
        if ( match_groups( \ @@supplementary_groups,
                           \ @@extracted_supplementary_groups,
                           $pwgid ) ) {
            print "ok 1\n";
            $ok1 = 1;
        }
        elsif ( cygwin_nt() ) {
            %basegroup = unixy_cygwin_basegroups();
            @@extracted_supplementary_groups = remove_basegroup( \ %basegroup, \ @@extracted_groups );

            if ( match_groups( \ @@supplementary_groups,
                               \ @@extracted_supplementary_groups,
                               $pwgid ) ) {
                print "ok 1 # This Cygwin behaves like Unix (Win2k?)\n";
                $ok1 = 1;
            }
        }

        unless ( $ok1 ) {

        }
    }

    # multiple 0's indicate GROUPSTYPE is currently long but should be short
    $gid_count->{0} //= 0;
    if ( 0 == $pwgid || $gid_count->{0} < 2 ) {
        print "ok 2\n";
    }
    else {
        print "not ok 2 (groupstype should be type short, not long)\n";
    }

    return;
}

# Get the system groups and the command used to fetch them.
#
sub system_groups {
    my ( $cmd, $groups_string ) = _system_groups();

    if ( $groups_string ) {
        chomp $groups_string;
        diag_variable( groups => $groups_string );
    }

    return ( $cmd, $groups_string );
}

# We have to find a command that prints all (effective
# and real) group names (not ids).  The known commands are:
# groups
# id -Gn
# id -a
# Beware 1: some systems do just 'id -G' even when 'id -Gn' is used.
# Beware 2: id -Gn or id -a format might be id(name) or name(id).
# Beware 3: the groups= might be anywhere in the id output.
# Beware 4: groups can have spaces ('id -a' being the only defense against this)
# Beware 5: id -a might not contain the groups= part.
#
# That is, we might meet the following:
#
# foo bar zot				# accept
# foo 22 42 bar zot			# accept
# 1 22 42 2 3				# reject
# groups=(42),foo(1),bar(2),zot me(3)	# parsed by $GROUP_RX1
# groups=22,42,1(foo),2(bar),3(zot(me))	# parsed by $GROUP_RX2
#
# and the groups= might be after, before, or between uid=... and gid=...
use constant GROUP_RX1 => qr/
    ^
    (?<gr_name>.+)
    \(
        (?<gid>\d+)
    \)
    $
/x;
use constant GROUP_RX2 => qr/
    ^
    (?<gid>\d+)
    \(
        (?<gr_name>.+)
    \)
    $
/x;
sub _system_groups {
    my $cmd;
    my $str;

    # prefer 'id' over 'groups' (is this ever wrong anywhere?)
    # and 'id -a' over 'id -Gn' (the former is good about spaces in group names)

    $cmd = 'id -a 2>/dev/null || id 2>/dev/null';
    $str = `$cmd`;
    if ( $str && $str =~ /groups=/ ) {
        # $str is of the form:
        # uid=39957(gsar) gid=22(users) groups=33536,39181,22(users),0(root),1067(dev)
        # FreeBSD since 6.2 has a fake id -a:
        # uid=1001(tobez) gid=20(staff) groups=20(staff), 0(wheel), 68(dialer)
        # On AIX it's id
        #
        # Linux may also have a context= field

        return ( $cmd, $str );
    }

    $cmd = 'id -Gn 2>/dev/null';
    $str = `$cmd`;
    if ( $str && $str !~ /^[\d\s]$/ ) {
        # $str could be of the form:
        # users 33536 39181 root dev
        return ( $cmd, $str );
    }

    $cmd = 'groups 2>/dev/null';
    $str = `$cmd`;
    if ( $str ) {
        # may not reflect all groups in some places, so do a sanity check
        if (-d '/afs') {
            print <<EOM;
# These test results *may* be bogus, as you appear to have AFS,
# and I can't find a working 'id' in your PATH (which I have set
# to '$ENV{PATH}').
#
# If these tests fail, report the particular incantation you use
# on this platform to find *all* the groups that an arbitrary
# user may belong to, using the 'perlbug' program.
EOM
        }
        return ( $cmd, $str );
    }

    return ();
}

# Convert the strings produced by parsing `id -a' into a list of group
# names
sub extract_system_groups {
    my ( $groups_string ) = @@_;

    # Remember that group names can contain whitespace, '-', '(parens)',
    # et cetera. That is: do not \w, do not \S.
    my @@extracted;

    my @@fields = split /\b(\w+=)/, $groups_string;
    my $gr;
    for my $i (0..@@fields-2) {
        if ($fields[$i] eq 'groups=') {
            $gr = $fields[$i+1];
            $gr =~ s/ $//;
            last;
        }
    }
    if (defined $gr) {
        my @@g = split m{, ?}, $gr;
        # prefer names over numbers
        for (@@g) {
            if ( $_ =~ GROUP_RX1() || $_ =~ GROUP_RX2() ) {
                push @@extracted, $+{gr_name} || $+{gid};
            }
            else {
                print "# ignoring group entry [$_]\n";
            }
        }

        diag_variable( gr => $gr );
        diag_variable( g => join ',', @@g );
        diag_variable( ex_gr => join ',', @@extracted );
    }

    return @@extracted;
}

# Get the POSIX value NGROUPS_MAX.
sub posix_ngroups_max {
    return eval {
        POSIX::NGROUPS_MAX();
    };
}

# Test if this is Apple's darwin
sub darwin {
    # Observed 'darwin-2level'
    return $Config::Config{myuname} =~ /^darwin/;
}

# Test if this is Cygwin
sub cygwin_nt {
    return $Config::Config{myuname} =~ /^cygwin_nt/i;
}

# Get perl's supplementary groups and the number of times each gid
# appeared.
sub perl_groups {
    # Lookup perl's own groups from $(
    my @@gids = split ' ', $(;
    my %gid_count;
    my @@gr_name;
    for my $gid ( @@gids ) {
        ++ $gid_count{$gid};

        my ($group) = getgrgid $gid;

        # Why does this test prefer to not test groups which we don't have
        # a name for? One possible answer is that my primary group comes
        # from from my entry in the user database but isn't mentioned in
        # the group database.  Are there more reasons?
        next if ! defined $group;


        push @@gr_name, $group;
    }

    diag_variable( gr_name => join ',', @@gr_name );

    return ( \ %gid_count, \ @@gr_name );
}

# Remove entries from our parsing of $( that don't appear in our
# parsing of `id -a`.
sub remove_unparsed_entries {
    my ( $extracted_groups, $perl_groups ) = @@_;

    my %was_extracted =
        map { $_ => 1 }
        @@$extracted_groups;

    return
        grep { $was_extracted{$_} }
        @@$perl_groups;
}

# Get a list of base groups. I'm not sure why cygwin by default is
# skipped here.
sub basegroups {
    my ( $pwgid, $pwgnam ) = @@_;

    if ( cygwin_nt() ) {
        return;
    }
    else {
        return (
            $pwgid  => 1,
            $pwgnam => 1,
        );
    }
}

# Cygwin might have another form of basegroup which we should actually use
sub unixy_cygwin_basegroups {
    my ( $pwgid, $pwgnam ) = @@_;
    return (
        $pwgid  => 1,
        $pwgnam => 1,
    );
}

# Filter a full list of groups and return only the supplementary
# gorups.
sub remove_basegroup {
    my ( $basegroups, $groups ) = @@_;

    return
        grep { ! $basegroups->{$_} }
        @@$groups;
}

# Test supplementary groups to see if they're a close enough match or
# if there aren't any supplementary groups then validate the current
# group against $(.
sub match_groups {
    my ( $supplementary_groups, $extracted_supplementary_groups, $pwgid ) = @@_;

    # Compare perl vs system groups
    my %g;
    $g{$_}[0] = 1 for @@$supplementary_groups;
    $g{$_}[1] = 1 for @@$extracted_supplementary_groups;

    # Find any mismatches
    my @@misses =
        grep { ! ( $g{$_}[0] && $g{$_}[1] ) }
        sort keys %g;

    return
        ! @@misses
        || ( ! @@$supplementary_groups
             && 1 == @@$extracted_supplementary_groups
             && $pwgid == $extracted_supplementary_groups->[0] );
}

# Print a nice little diagnostic.
sub diag_variable {
    my ( $label, $content ) = @@_;

    printf "# %-11s=%s\n", $label, $content;
    return;
}

# Removes duplicates from a list
sub uniq {
    my %seen;
    return
        grep { ! $seen{$_}++ }
        @@_;
}

# ex: set ts=8 sts=4 sw=4 et:
@


1.11
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d13 1
a13 1
    chdir 't';
a404 4
# Local variables:
# indent-tabs-mode: nil
# End:
#
@


1.10
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d409 1
a409 1
# ex: set ts=8 sts=4 sw=4 noet:
@


1.9
log
@merge in perl 5.12.2 plus local changes
@
text
@d15 2
d23 2
a24 3
unless (eval { my($foo) = getgrgid(0); 1 }) {
    quit( "getgrgid() not implemented" );
}
d26 2
a27 5
quit("No `id' or `groups'") if
    $^O eq 'MSWin32'
    || $^O eq 'NetWare'
    || $^O eq 'VMS'
    || $^O =~ /lynxos/i;
d39 1
a39 1
        or quit( "No `id' or `groups'" );
d41 1
a41 1
        or quit( "Can't parse `${groups_command}'" );
a132 6
}

# Cleanly abort this entire test file
sub quit {
    print "1..0 # SKIP: @@_\n";
    exit 0;
@


1.8
log
@Merge in perl 5.10.1; part two
@
text
@d2 10
a12 6
$ENV{PATH} ="/bin:/usr/bin:/usr/xpg4/bin:/usr/ucb" .
    exists $ENV{PATH} ? ":$ENV{PATH}" : "" unless $^O eq 'VMS';
$ENV{LC_ALL} = "C"; # so that external utilities speak English
$ENV{LANGUAGE} = 'C'; # GNU locale extension

BEGIN {
d15 20
d36 38
a73 5
    require Config;
    if ($@@) {
	print "1..0 # Skip: no Config\n";
    } else {
	Config->import;
d75 60
d137 1
d139 1
a139 1
    print "1..0 # Skip: no `id` or `groups`\n";
d143 11
a153 3
unless (eval { getgrgid(0); 1 }) {
    print "1..0 # Skip: getgrgid() not implemented\n";
    exit 0;
a155 3
quit() if (($^O eq 'MSWin32' || $^O eq 'NetWare' || $^O eq 'VMS')
           or $^O =~ /lynxos/i);

d172 2
a173 2
# groups=(42),foo(1),bar(2),zot me(3)	# parse
# groups=22,42,1(foo),2(bar),3(zot me)	# parse
d176 19
a195 1
GROUPS: {
d198 29
a226 16
    if (($groups = `id -a 2>/dev/null`) ne '') {
	# $groups is of the form:
	# uid=39957(gsar) gid=22(users) groups=33536,39181,22(users),0(root),1067(dev)
	# FreeBSD since 6.2 has a fake id -a:
	# uid=1001(tobez) gid=20(staff) groups=20(staff), 0(wheel), 68(dialer)
	last GROUPS if $groups =~ /groups=/;
    }
    if (($groups = `id -Gn 2>/dev/null`) ne '') {
	# $groups could be of the form:
	# users 33536 39181 root dev
	last GROUPS if $groups !~ /^(\d|\s)+$/;
    }
    if (($groups = `groups 2>/dev/null`) ne '') {
	# may not reflect all groups in some places, so do a sanity check
	if (-d '/afs') {
	    print <<EOM;
d235 2
a236 2
	}
	last GROUPS;
d238 2
a239 2
    # Okay, not today.
    quit();
d242 17
a258 43
chomp($groups);

print "# groups = $groups\n";

# Remember that group names can contain whitespace, '-', et cetera.
# That is: do not \w, do not \S.
if ($groups =~ /groups=(.+)( [ug]id=|$)/) {
    my $gr = $1;
    my @@g0 = split /, ?/, $gr;
    my @@g1;
    # prefer names over numbers
    for (@@g0) {
	# 42(zot me)
	if (/^(\d+)(?:\(([^)]+)\))?/) {
	    push @@g1, ($2 || $1);
	}
	# zot me(42)
	elsif (/^([^(]*)\((\d+)\)/) {
	    push @@g1, ($1 || $2);
	}
	else {
	    print "# ignoring group entry [$_]\n";
	}
    }
    print "# groups=$gr\n";
    print "# g0 = @@g0\n";
    print "# g1 = @@g1\n";
    $groups = "@@g1";
}

print "1..2\n";

$pwgid = $( + 0;
($pwgnam) = getgrgid($pwgid);
$seen{$pwgid}++;

print "# pwgid = $pwgid, pwgnam = $pwgnam\n";

for (split(' ', $()) {
    ($group) = getgrgid($_);
    next if (! defined $group or ! grep { $_ eq $group } @@gr) and $seen{$_}++;
    if (defined $group) {
	push(@@gr, $group);
d260 15
a274 2
    else {
	push(@@gr, $_);
d276 2
d280 6
a285 1
print "# gr = @@gr\n";
d287 4
a290 7
my %did;
if ($^O =~ /^(?:uwin|cygwin|interix|solaris|linux)$/) {
	# Or anybody else who can have spaces in group names.
	$gr1 = join(' ', grep(!$did{$_}++, sort split(' ', join(' ', @@gr))));
} else {
	# Don't assume that there aren't duplicate groups
	$gr1 = join(' ', sort grep defined $_ && !$did{$_}++, @@gr);
d293 3
a295 4
if ($Config{myuname} =~ /^cygwin_nt/i) { # basegroup on CYGWIN_NT has id = 0.
    @@basegroup{$pwgid,$pwgnam} = (0,0);
} else {
    @@basegroup{$pwgid,$pwgnam} = (1,1);
a296 1
$gr2 = join(' ', grep(!$basegroup{$_}++, sort split(' ',$groups)));
d298 20
a317 12
my $ok1 = 0;
if ($gr1 eq $gr2 || ($gr1 eq '' && $gr2 eq $pwgid)) {
    print "ok 1\n";
    $ok1++;
}
elsif ($Config{myuname} =~ /^cygwin_nt/i) { # basegroup on CYGWIN_NT has id = 0.
    # Retry in default unix mode
    %basegroup = ( $pwgid => 1, $pwgnam => 1 );
    $gr2 = join(' ', grep(!$basegroup{$_}++, sort split(' ',$groups)));
    if ($gr1 eq $gr2 || ($gr1 eq '' && $gr2 eq $pwgid)) {
	print "ok 1 # This Cygwin behaves like Unix (Win2k?)\n";
	$ok1++;
d319 4
d324 13
a336 4
unless ($ok1) {
    print "#gr1 is <$gr1>\n";
    print "#gr2 is <$gr2>\n";
    print "not ok 1\n";
d339 4
a342 1
# multiple 0's indicate GROUPSTYPE is currently long but should be short
d344 9
a352 5
if ($pwgid == 0 || $seen{0} < 2) {
    print "ok 2\n";
}
else {
    print "not ok 2 (groupstype should be type short, not long)\n";
d354 64
@


1.7
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d4 1
a4 1
    exists $ENV{PATH} ? ":$ENV{PATH}" : "";
d30 2
a31 1
quit() if (($^O eq 'MSWin32' || $^O eq 'NetWare') or $^O =~ /lynxos/i);
d140 1
a140 1
if ($^O =~ /^(?:uwin|cygwin|interix|solaris)$/) {
@


1.6
log
@merge in perl 5.8.8
@
text
@d59 2
d95 1
a95 1
    my @@g0 = split /,/, $gr;
@


1.5
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d97 1
a97 1
        # 42(zot me)
d101 1
a101 1
        # zot me(42)
d132 1
a132 1
} 
d136 2
a137 1
if ($^O =~ /^(?:uwin|cygwin|solaris)$/) {
d141 2
a142 1
	$gr1 = join(' ', sort @@gr);
@


1.4
log
@merge in perl 5.6.1 with our local changes
@
text
@d8 12
d25 6
a30 1
quit() if $^O eq 'MSWin32' or $^O =~ /lynxos/i;
d76 1
a76 1
# luser may belong to, using the 'perlbug' program.
d85 3
a87 4
unless (eval { getgrgid(0); 1 }) {
    print "1..0 # Skip: getgrgid() not implemented\n";
    exit 0;
}
d119 1
a119 1
@@basegroup{$pwgid,$pwgnam} = (1,1);
d121 1
a121 1
$seen{$pwgid}++;
a123 1
    next if $seen{$_}++;
d125 1
d134 3
a136 1
if ($^O =~ /^(?:uwin|solaris)$/) {
d143 5
d150 2
a151 1
if ($gr1 eq $gr2) {
d153 10
d164 1
a164 1
else {
@


1.3
log
@perl-5.6.0 + local changes
@
text
@d118 2
a119 1
if ($^O eq "uwin") { # Or anybody else who can have spaces in group names.
@


1.2
log
@perl 5.004_04
@
text
@d3 67
a69 5
if (! -x ($groups = '/usr/ucb/groups') &&
    ! -x ($groups = '/usr/bin/groups') &&
    ! -x ($groups = '/bin/groups')
) {
    print "1..0\n";
d73 26
d118 5
a122 1
$gr1 = join(' ', sort @@gr);
d124 1
a124 1
$gr2 = join(' ', grep(!$basegroup{$_}++, sort split(' ',`$groups`)));
@


1.1
log
@Initial revision
@
text
@d3 4
a6 1
if (! -x '/usr/ucb/groups') {
d32 1
a32 1
$gr2 = join(' ', grep(!$basegroup{$_}++, sort split(' ',`/usr/ucb/groups`)));
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d3 1
a3 4
if (! -x ($groups = '/usr/ucb/groups') &&
    ! -x ($groups = '/usr/bin/groups') &&
    ! -x ($groups = '/bin/groups')
) {
d29 1
a29 1
$gr2 = join(' ', grep(!$basegroup{$_}++, sort split(' ',`$groups`)));
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d3 5
a7 67
$ENV{PATH} ="/bin:/usr/bin:/usr/xpg4/bin:/usr/ucb" .
    exists $ENV{PATH} ? ":$ENV{PATH}" : "";
$ENV{LC_ALL} = "C"; # so that external utilities speak English
$ENV{LANGUAGE} = 'C'; # GNU locale extension

sub quit {
    print "1..0 # Skip: no `id` or `groups`\n";
    exit 0;
}

quit() if $^O eq 'MSWin32' or $^O =~ /lynxos/i;

# We have to find a command that prints all (effective
# and real) group names (not ids).  The known commands are:
# groups
# id -Gn
# id -a
# Beware 1: some systems do just 'id -G' even when 'id -Gn' is used.
# Beware 2: id -Gn or id -a format might be id(name) or name(id).
# Beware 3: the groups= might be anywhere in the id output.
# Beware 4: groups can have spaces ('id -a' being the only defense against this)
# Beware 5: id -a might not contain the groups= part.
#
# That is, we might meet the following:
#
# foo bar zot				# accept
# foo 22 42 bar zot			# accept
# 1 22 42 2 3				# reject
# groups=(42),foo(1),bar(2),zot me(3)	# parse
# groups=22,42,1(foo),2(bar),3(zot me)	# parse
#
# and the groups= might be after, before, or between uid=... and gid=...

GROUPS: {
    # prefer 'id' over 'groups' (is this ever wrong anywhere?)
    # and 'id -a' over 'id -Gn' (the former is good about spaces in group names)
    if (($groups = `id -a 2>/dev/null`) ne '') {
	# $groups is of the form:
	# uid=39957(gsar) gid=22(users) groups=33536,39181,22(users),0(root),1067(dev)
	last GROUPS if $groups =~ /groups=/;
    }
    if (($groups = `id -Gn 2>/dev/null`) ne '') {
	# $groups could be of the form:
	# users 33536 39181 root dev
	last GROUPS if $groups !~ /^(\d|\s)+$/;
    }
    if (($groups = `groups 2>/dev/null`) ne '') {
	# may not reflect all groups in some places, so do a sanity check
	if (-d '/afs') {
	    print <<EOM;
# These test results *may* be bogus, as you appear to have AFS,
# and I can't find a working 'id' in your PATH (which I have set
# to '$ENV{PATH}').
#
# If these tests fail, report the particular incantation you use
# on this platform to find *all* the groups that an arbitrary
# luser may belong to, using the 'perlbug' program.
EOM
	}
	last GROUPS;
    }
    # Okay, not today.
    quit();
}

unless (eval { getgrgid(0); 1 }) {
    print "1..0 # Skip: getgrgid() not implemented\n";
a10 26
# Remember that group names can contain whitespace, '-', et cetera.
# That is: do not \w, do not \S.
if ($groups =~ /groups=(.+)( [ug]id=|$)/) {
    my $gr = $1;
    my @@g0 = split /,/, $gr;
    my @@g1;
    # prefer names over numbers
    for (@@g0) {
        # 42(zot me)
	if (/^(\d+)(?:\(([^)]+)\))?/) {
	    push @@g1, ($2 || $1);
	}
        # zot me(42)
	elsif (/^([^(]*)\((\d+)\)/) {
	    push @@g1, ($1 || $2);
	}
	else {
	    print "# ignoring group entry [$_]\n";
	}
    }
    print "# groups=$gr\n";
    print "# g0 = @@g0\n";
    print "# g1 = @@g1\n";
    $groups = "@@g1";
}

d30 1
a30 5
if ($^O eq "uwin") { # Or anybody else who can have spaces in group names.
	$gr1 = join(' ', grep(!$did{$_}++, sort split(' ', join(' ', @@gr))));
} else {
	$gr1 = join(' ', sort @@gr);
}
d32 1
a32 1
$gr2 = join(' ', grep(!$basegroup{$_}++, sort split(' ',$groups)));
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d118 1
a118 2
if ($^O =~ /^(?:uwin|solaris)$/) {
	# Or anybody else who can have spaces in group names.
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@a7 12
BEGIN {
    chdir 't';
    @@INC = '../lib';

    require Config;
    if ($@@) {
	print "1..0 # Skip: no Config\n";
    } else {
	Config->import;
    }
}

d13 1
a13 6
unless (eval { getgrgid(0); 1 }) {
    print "1..0 # Skip: getgrgid() not implemented\n";
    exit 0;
}

quit() if (($^O eq 'MSWin32' || $^O eq 'NetWare') or $^O =~ /lynxos/i);
d59 1
a59 1
# user may belong to, using the 'perlbug' program.
d68 4
a71 3
chomp($groups);

print "# groups = $groups\n";
d103 2
a106 2
print "# pwgid = $pwgid, pwgnam = $pwgnam\n";

d108 1
a109 1
    next if (! defined $group or ! grep { $_ eq $group } @@gr) and $seen{$_}++;
d118 1
a118 3
print "# gr = @@gr\n";

if ($^O =~ /^(?:uwin|cygwin|solaris)$/) {
a124 5
if ($Config{myuname} =~ /^cygwin_nt/i) { # basegroup on CYGWIN_NT has id = 0.
    @@basegroup{$pwgid,$pwgnam} = (0,0);
} else {
    @@basegroup{$pwgid,$pwgnam} = (1,1);
}
d127 1
a127 2
my $ok1 = 0;
if ($gr1 eq $gr2 || ($gr1 eq '' && $gr2 eq $pwgid)) {
a128 10
    $ok1++;
}
elsif ($Config{myuname} =~ /^cygwin_nt/i) { # basegroup on CYGWIN_NT has id = 0.
    # Retry in default unix mode
    %basegroup = ( $pwgid => 1, $pwgnam => 1 );
    $gr2 = join(' ', grep(!$basegroup{$_}++, sort split(' ',$groups)));
    if ($gr1 eq $gr2 || ($gr1 eq '' && $gr2 eq $pwgid)) {
	print "ok 1 # This Cygwin behaves like Unix (Win2k?)\n";
	$ok1++;
    }
d130 1
a130 1
unless ($ok1) {
@


1.1.1.6
log
@perl 5.8.8 import
@
text
@d97 1
a97 1
	# 42(zot me)
d101 1
a101 1
	# zot me(42)
d132 1
a132 1
}
d136 1
a136 2
my %did;
if ($^O =~ /^(?:uwin|cygwin|interix|solaris)$/) {
d140 1
a140 2
	# Don't assume that there aren't duplicate groups
	$gr1 = join(' ', sort grep defined $_ && !$did{$_}++, @@gr);
@


1.1.1.7
log
@import perl 5.10.0 from CPAN
@
text
@a58 2
	# FreeBSD since 6.2 has a fake id -a:
	# uid=1001(tobez) gid=20(staff) groups=20(staff), 0(wheel), 68(dialer)
d93 1
a93 1
    my @@g0 = split /, ?/, $gr;
@


1.1.1.8
log
@import perl 5.10.1
@
text
@d4 1
a4 1
    exists $ENV{PATH} ? ":$ENV{PATH}" : "" unless $^O eq 'VMS';
d30 1
a30 2
quit() if (($^O eq 'MSWin32' || $^O eq 'NetWare' || $^O eq 'VMS')
           or $^O =~ /lynxos/i);
d139 1
a139 1
if ($^O =~ /^(?:uwin|cygwin|interix|solaris|linux)$/) {
@


1.1.1.9
log
@Perl 5.12.2 from CPAN
@
text
@d2 6
a8 10
    if ( $^O eq 'VMS' ) {
        my $p = "/bin:/usr/bin:/usr/xpg4/bin:/usr/ucb";
        if ( $ENV{PATH} ) {
            $p .= ":$ENV{PATH}";
        }
        $ENV{PATH} = $p;
    }
    $ENV{LC_ALL} = "C"; # so that external utilities speak English
    $ENV{LANGUAGE} = 'C'; # GNU locale extension

a10 20
}
use 5.010;
use strict;
use Config ();
use POSIX ();

unless (eval { my($foo) = getgrgid(0); 1 }) {
    quit( "getgrgid() not implemented" );
}

quit("No `id' or `groups'") if
    $^O eq 'MSWin32'
    || $^O eq 'NetWare'
    || $^O eq 'VMS'
    || $^O =~ /lynxos/i;

Test();
exit;


d12 5
a16 38
sub Test {

    # Get our supplementary groups from the system by running commands
    # like `id -a'.
    my ( $groups_command, $groups_string ) = system_groups()
        or quit( "No `id' or `groups'" );
    my @@extracted_groups = extract_system_groups( $groups_string )
        or quit( "Can't parse `${groups_command}'" );

    my $pwgid = $( + 0;
    my ($pwgnam) = getgrgid($pwgid);
    $pwgnam //= '';
    print "# pwgid=$pwgid pwgnam=$pwgnam \$(=$(\n";

    # Get perl's supplementary groups by looking at $(
    my ( $gid_count, $all_perl_groups ) = perl_groups();
    my %basegroup = basegroups( $pwgid, $pwgnam );
    my @@extracted_supplementary_groups = remove_basegroup( \ %basegroup, \ @@extracted_groups );

    print "1..2\n";


    # Test: The supplementary groups in $( should match the
    # getgroups(2) kernal API call.
    #
    my $ngroups_max = posix_ngroups_max();
    if ( defined $ngroups_max && $ngroups_max < @@extracted_groups ) {
        # Some OSes (like darwin)but conceivably others might return
        # more groups from `id -a' than can be handled by the
        # kernel. On darwin, NGROUPS_MAX is 16 and 12 are taken up for
        # the system already.
        #
        # There is more fall-out from this than just Perl's unit
        # tests. You may be a member of a group according to Active
        # Directory (or whatever) but the OS won't respect it because
        # it's the 17th (or higher) group and there's no space to
        # store your membership.
        print "ok 1 # SKIP Your platform's `$groups_command' is broken\n";
a17 60

    elsif ( darwin() ) {
        # darwin uses getgrouplist(3) or an Open Directory API within
        # /usr/bin/id and /usr/bin/groups which while "nice" isn't
        # accurate for this test. The hard, real, list of groups we're
        # running in derives from getgroups(2) and is not dynamic but
        # the Libc API getgrouplist(3) is.
        #
        # In practical terms, this meant that while `id -a' can be
        # relied on in other OSes to purely use getgroups(2) and show
        # us what's real, darwin will use getgrouplist(3) to show us
        # what might be real if only we'd open a new console.
        #
        print "ok 1 # SKIP darwin's `${groups_command}' can't be trusted\n";
    }

    else {

        # Read $( but ignore any groups in $( that we failed to parse
        # successfully out of the `id -a` mess.
        #
        my @@perl_groups = remove_unparsed_entries( \ @@extracted_groups,
                                                   \ @@$all_perl_groups );
        my @@supplementary_groups = remove_basegroup( \ %basegroup,
                                                     \ @@perl_groups );

        my $ok1 = 0;
        if ( match_groups( \ @@supplementary_groups,
                           \ @@extracted_supplementary_groups,
                           $pwgid ) ) {
            print "ok 1\n";
            $ok1 = 1;
        }
        elsif ( cygwin_nt() ) {
            %basegroup = unixy_cygwin_basegroups();
            @@extracted_supplementary_groups = remove_basegroup( \ %basegroup, \ @@extracted_groups );

            if ( match_groups( \ @@supplementary_groups,
                               \ @@extracted_supplementary_groups,
                               $pwgid ) ) {
                print "ok 1 # This Cygwin behaves like Unix (Win2k?)\n";
                $ok1 = 1;
            }
        }

        unless ( $ok1 ) {

        }
    }

    # multiple 0's indicate GROUPSTYPE is currently long but should be short
    $gid_count->{0} //= 0;
    if ( 0 == $pwgid || $gid_count->{0} < 2 ) {
        print "ok 2\n";
    }
    else {
        print "not ok 2 (groupstype should be type short, not long)\n";
    }

    return;
a19 1
# Cleanly abort this entire test file
d21 1
a21 1
    print "1..0 # SKIP: @@_\n";
d25 4
a28 9
# Get the system groups and the command used to fetch them.
#
sub system_groups {
    my ( $cmd, $groups_string ) = _system_groups();

    if ( $groups_string ) {
        chomp $groups_string;
        diag_variable( groups => $groups_string );
    }
d30 2
a31 2
    return ( $cmd, $groups_string );
}
d49 2
a50 2
# groups=(42),foo(1),bar(2),zot me(3)	# parsed by $GROUP_RX1
# groups=22,42,1(foo),2(bar),3(zot(me))	# parsed by $GROUP_RX2
a52 19
use constant GROUP_RX1 => qr/
    ^
    (?<gr_name>.+)
    \(
        (?<gid>\d+)
    \)
    $
/x;
use constant GROUP_RX2 => qr/
    ^
    (?<gid>\d+)
    \(
        (?<gr_name>.+)
    \)
    $
/x;
sub _system_groups {
    my $cmd;
    my $str;
d54 1
d57 16
a72 29

    $cmd = 'id -a 2>/dev/null || id 2>/dev/null';
    $str = `$cmd`;
    if ( $str && $str =~ /groups=/ ) {
        # $str is of the form:
        # uid=39957(gsar) gid=22(users) groups=33536,39181,22(users),0(root),1067(dev)
        # FreeBSD since 6.2 has a fake id -a:
        # uid=1001(tobez) gid=20(staff) groups=20(staff), 0(wheel), 68(dialer)
        # On AIX it's id
        #
        # Linux may also have a context= field

        return ( $cmd, $str );
    }

    $cmd = 'id -Gn 2>/dev/null';
    $str = `$cmd`;
    if ( $str && $str !~ /^[\d\s]$/ ) {
        # $str could be of the form:
        # users 33536 39181 root dev
        return ( $cmd, $str );
    }

    $cmd = 'groups 2>/dev/null';
    $str = `$cmd`;
    if ( $str ) {
        # may not reflect all groups in some places, so do a sanity check
        if (-d '/afs') {
            print <<EOM;
d81 2
a82 2
        }
        return ( $cmd, $str );
d84 3
d88 1
a88 2
    return ();
}
d90 41
a130 17
# Convert the strings produced by parsing `id -a' into a list of group
# names
sub extract_system_groups {
    my ( $groups_string ) = @@_;

    # Remember that group names can contain whitespace, '-', '(parens)',
    # et cetera. That is: do not \w, do not \S.
    my @@extracted;

    my @@fields = split /\b(\w+=)/, $groups_string;
    my $gr;
    for my $i (0..@@fields-2) {
        if ($fields[$i] eq 'groups=') {
            $gr = $fields[$i+1];
            $gr =~ s/ $//;
            last;
        }
d132 2
a133 15
    if (defined $gr) {
        my @@g = split m{, ?}, $gr;
        # prefer names over numbers
        for (@@g) {
            if ( $_ =~ GROUP_RX1() || $_ =~ GROUP_RX2() ) {
                push @@extracted, $+{gr_name} || $+{gid};
            }
            else {
                print "# ignoring group entry [$_]\n";
            }
        }

        diag_variable( gr => $gr );
        diag_variable( g => join ',', @@g );
        diag_variable( ex_gr => join ',', @@extracted );
d135 1
d137 1
a137 2
    return @@extracted;
}
d139 7
a145 5
# Get the POSIX value NGROUPS_MAX.
sub posix_ngroups_max {
    return eval {
        POSIX::NGROUPS_MAX();
    };
d148 4
a151 4
# Test if this is Apple's darwin
sub darwin {
    # Observed 'darwin-2level'
    return $Config::Config{myuname} =~ /^darwin/;
d153 1
d155 4
a158 3
# Test if this is Cygwin
sub cygwin_nt {
    return $Config::Config{myuname} =~ /^cygwin_nt/i;
d160 7
a166 21

# Get perl's supplementary groups and the number of times each gid
# appeared.
sub perl_groups {
    # Lookup perl's own groups from $(
    my @@gids = split ' ', $(;
    my %gid_count;
    my @@gr_name;
    for my $gid ( @@gids ) {
        ++ $gid_count{$gid};

        my ($group) = getgrgid $gid;

        # Why does this test prefer to not test groups which we don't have
        # a name for? One possible answer is that my primary group comes
        # from from my entry in the user database but isn't mentioned in
        # the group database.  Are there more reasons?
        next if ! defined $group;


        push @@gr_name, $group;
a167 4

    diag_variable( gr_name => join ',', @@gr_name );

    return ( \ %gid_count, \ @@gr_name );
d169 5
d175 1
a175 8
# Remove entries from our parsing of $( that don't appear in our
# parsing of `id -a`.
sub remove_unparsed_entries {
    my ( $extracted_groups, $perl_groups ) = @@_;

    my %was_extracted =
        map { $_ => 1 }
        @@$extracted_groups;
d177 2
a178 3
    return
        grep { $was_extracted{$_} }
        @@$perl_groups;
d180 2
a181 15

# Get a list of base groups. I'm not sure why cygwin by default is
# skipped here.
sub basegroups {
    my ( $pwgid, $pwgnam ) = @@_;

    if ( cygwin_nt() ) {
        return;
    }
    else {
        return (
            $pwgid  => 1,
            $pwgnam => 1,
        );
    }
a182 64

# Cygwin might have another form of basegroup which we should actually use
sub unixy_cygwin_basegroups {
    my ( $pwgid, $pwgnam ) = @@_;
    return (
        $pwgid  => 1,
        $pwgnam => 1,
    );
}

# Filter a full list of groups and return only the supplementary
# gorups.
sub remove_basegroup {
    my ( $basegroups, $groups ) = @@_;

    return
        grep { ! $basegroups->{$_} }
        @@$groups;
}

# Test supplementary groups to see if they're a close enough match or
# if there aren't any supplementary groups then validate the current
# group against $(.
sub match_groups {
    my ( $supplementary_groups, $extracted_supplementary_groups, $pwgid ) = @@_;

    # Compare perl vs system groups
    my %g;
    $g{$_}[0] = 1 for @@$supplementary_groups;
    $g{$_}[1] = 1 for @@$extracted_supplementary_groups;

    # Find any mismatches
    my @@misses =
        grep { ! ( $g{$_}[0] && $g{$_}[1] ) }
        sort keys %g;

    return
        ! @@misses
        || ( ! @@$supplementary_groups
             && 1 == @@$extracted_supplementary_groups
             && $pwgid == $extracted_supplementary_groups->[0] );
}

# Print a nice little diagnostic.
sub diag_variable {
    my ( $label, $content ) = @@_;

    printf "# %-11s=%s\n", $label, $content;
    return;
}

# Removes duplicates from a list
sub uniq {
    my %seen;
    return
        grep { ! $seen{$_}++ }
        @@_;
}

# Local variables:
# indent-tabs-mode: nil
# End:
#
# ex: set ts=8 sts=4 sw=4 noet:
@


1.1.1.10
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@a14 2
    require './test.pl';
    skip_all_if_miniperl("no dynamic loading on miniperl, no POSIX");
d21 3
a23 2
skip_all('getgrgid() not implemented')
    unless eval { my($foo) = getgrgid(0); 1 };
d25 5
a29 2
skip_all("No 'id' or 'groups'") if
    $^O eq 'MSWin32' || $^O eq 'NetWare' || $^O eq 'VMS' || $^O =~ /lynxos/i;
d41 1
a41 1
        or skip_all("No 'id' or 'groups'");
d43 1
a43 1
        or skip_all("Can't parse '${groups_command}'");
d135 6
@


1.1.1.11
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d409 1
a409 1
# ex: set ts=8 sts=4 sw=4 et:
@


