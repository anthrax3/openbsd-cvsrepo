head	1.13;
access;
symbols
	OPENBSD_4_8:1.12.0.4
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	PERL_5_10_1:1.1.1.11
	OPENBSD_4_6:1.11.0.6
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.2
	OPENBSD_4_5_BASE:1.11
	PERL_5_10_0:1.1.1.10
	OPENBSD_4_4:1.10.0.10
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.8
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.6
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.4
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.2
	OPENBSD_4_0_BASE:1.10
	PERL_5_8_8:1.1.1.9
	OPENBSD_3_9:1.9.0.8
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.6
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.4
	OPENBSD_3_7_BASE:1.9
	PERL_5_8_6:1.1.1.8
	OPENBSD_3_6:1.9.0.2
	OPENBSD_3_6_BASE:1.9
	PERL_5_8_5:1.1.1.8
	PERL_5_8_3:1.1.1.7
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;


1.13
date	2010.09.24.15.00.00;	author millert;	state dead;
branches;
next	1.12;

1.12
date	2009.10.12.18.30.27;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2008.09.29.17.36.19;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2006.03.28.19.23.13;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2004.08.09.18.10.27;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2004.04.07.21.33.10;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.49;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.37;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.36.20;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.08.28;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.52.37;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.08.05.33;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.13.20;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.13.20;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.41.48;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.10.50;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.25.43;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.15.10;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.44.32;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.04.07.21.13.43;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.08.09.17.48.35;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2006.03.28.18.49.46;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2008.09.29.17.19.01;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2009.10.12.18.10.44;	author millert;	state Exp;
branches;
next	;


desc
@@


1.13
log
@remove files no longer in perl 5.12.2 (or that have moved)
@
text
@#!./perl
#
# This is a home for regular expression tests that don't fit into
# the format supported by op/regexp.t.  If you want to add a test
# that does fit that format, add it to op/re_tests, not here.

use strict;
use warnings;
use 5.010;


sub run_tests;

$| = 1;

my $EXPECTED_TESTS = 4065;  # Update this when adding/deleting tests.

BEGIN {
    chdir 't' if -d 't';
    @@INC = '../lib';
}
our $TODO;
our $Message = "Noname test";
our $Error;
our $DiePattern;
our $WarnPattern;
our $BugId;
our $PatchId;
our $running_as_thread;

my $ordA = ord ('A');  # This defines ASCII/UTF-8 vs EBCDIC/UTF-EBCDIC
# This defined the platform.
my $IS_ASCII  = $ordA ==  65;
my $IS_EBCDIC = $ordA == 193;

use vars '%Config';
eval 'use Config';          #  Defaults assumed if this fails

my $test = 0;

print "1..$EXPECTED_TESTS\n";

run_tests unless caller ();

END {
}

sub pretty {
    my ($mess) = @@_;
    $mess =~ s/\n/\\n/g;
    $mess =~ s/\r/\\r/g;
    $mess =~ s/\t/\\t/g;
    $mess =~ s/([\00-\37\177])/sprintf '\%03o', ord $1/eg;
    $mess =~ s/#/\\#/g;
    $mess;
}

sub safe_globals {
    defined($_) and s/#/\\#/g for $BugId, $PatchId, $TODO;
}

sub _ok {
    my ($ok, $mess, $error) = @@_;
    safe_globals();
    $mess    = pretty ($mess // $Message);
    $mess   .= "; Bug $BugId"     if defined $BugId;
    $mess   .= "; Patch $PatchId" if defined $PatchId;
    $mess   .= " # TODO $TODO"     if defined $TODO;

    my $line_nr = (caller(1)) [2];

    printf "%sok %d - %s\n",
              ($ok ? "" : "not "),
              ++ $test,
              "$mess\tLine $line_nr";

    unless ($ok) {
        print "# Failed test at line $line_nr\n" unless defined $TODO;
        if ($error //= $Error) {
            no warnings 'utf8';
            chomp $error;
            $error = join "\n#", map {pretty $_} split /\n\h*#/ => $error;
            $error = "# $error" unless $error =~ /^\h*#/;
            print $error, "\n";
        }
    }

    return $ok;
}

# Force scalar context on the pattern match
sub  ok ($;$$) {_ok  $_ [0], $_ [1], $_ [2]}
sub nok ($;$$) {_ok !$_ [0], "Failed: " . ($_ [1] // $Message), $_ [2]}


sub skip {
    my $why = shift;
    safe_globals();
    $why =~ s/\n.*//s;
    $why .= "; Bug $BugId" if defined $BugId;
    # seems like the new harness code doesnt like todo and skip to be mixed.
    # which seems like a bug in the harness to me. -- dmq
    #$why .= " # TODO $TODO" if defined $TODO;
    
    my $n = shift // 1;
    my $line_nr = (caller(0)) [2];
    for (1 .. $n) {
        ++ $test;
        #print "not " if defined $TODO;
        print "ok $test # skip $why\tLine $line_nr\n";
    }
    no warnings "exiting";
    last SKIP;
}

sub iseq ($$;$) { 
    my ($got, $expect, $name) = @@_;
    
    $_ = defined ($_) ? "'$_'" : "undef" for $got, $expect;
        
    my $ok    = $got eq $expect;
    my $error = "# expected: $expect\n" .
                "#   result: $got";

    _ok $ok, $name, $error;
}   

sub isneq ($$;$) { 
    my ($got, $expect, $name) = @@_;
    my $todo = $TODO ? " # TODO $TODO" : '';
    
    $_ = defined ($_) ? "'$_'" : "undef" for $got, $expect;
        
    my $ok    = $got ne $expect;
    my $error = "# results are equal ($got)";

    _ok $ok, $name, $error;
}   


sub eval_ok ($;$) {
    my ($code, $name) = @@_;
    local $@@;
    if (ref $code) {
        _ok eval {&$code} && !$@@, $name;
    }
    else {
        _ok eval  ($code) && !$@@, $name;
    }
}

sub must_die {
    my ($code, $pattern, $name) = @@_;
    $pattern //= $DiePattern;
    undef $@@;
    ref $code ? &$code : eval $code;
    my  $r = $@@ && $@@ =~ /$pattern/;
    _ok $r, $name // $Message // "\$\@@ =~ /$pattern/";
}

sub must_warn {
    my ($code, $pattern, $name) = @@_;
    $pattern //= $WarnPattern;
    my $w;
    local $SIG {__WARN__} = sub {$w .= join "" => @@_};
    use warnings 'all';
    ref $code ? &$code : eval $code;
    my $r = $w && $w =~ /$pattern/;
    $w //= "UNDEF";
    _ok $r, $name // $Message // "Got warning /$pattern/",
            "# expected: /$pattern/\n" .
            "#   result: $w";
}

sub may_not_warn {
    my ($code, $name) = @@_;
    my $w;
    local $SIG {__WARN__} = sub {$w .= join "" => @@_};
    use warnings 'all';
    ref $code ? &$code : eval $code;
    _ok !$w, $name // ($Message ? "$Message (did not warn)"
                                : "Did not warn"),
             "Got warning '$w'";
}


#
# Tests start here.
#
sub run_tests {

    {

        my $x = "abc\ndef\n";

        ok $x =~ /^abc/,  qq ["$x" =~ /^abc/];
        ok $x !~ /^def/,  qq ["$x" !~ /^def/];

        # used to be a test for $*
        ok $x =~ /^def/m, qq ["$x" =~ /^def/m];

        nok $x =~ /^xxx/, qq ["$x" =~ /^xxx/];
        nok $x !~ /^abc/, qq ["$x" !~ /^abc/];

         ok $x =~ /def/, qq ["$x" =~ /def/];
        nok $x !~ /def/, qq ["$x" !~ /def/];

         ok $x !~ /.def/, qq ["$x" !~ /.def/];
        nok $x =~ /.def/, qq ["$x" =~ /.def/];

         ok $x =~ /\ndef/, qq ["$x" =~ /\ndef/];
        nok $x !~ /\ndef/, qq ["$x" !~ /\ndef/];
    }

    {
        $_ = '123';
        ok /^([0-9][0-9]*)/, qq [\$_ = '$_'; /^([0-9][0-9]*)/];
    }

    {
        $_ = 'aaabbbccc';
         ok /(a*b*)(c*)/ && $1 eq 'aaabbb' && $2 eq 'ccc',
                                             qq [\$_ = '$_'; /(a*b*)(c*)/];
         ok /(a+b+c+)/ && $1 eq 'aaabbbccc', qq [\$_ = '$_'; /(a+b+c+)/];
        nok /a+b?c+/,                        qq [\$_ = '$_'; /a+b?c+/];

        $_ = 'aaabccc';
         ok /a+b?c+/, qq [\$_ = '$_'; /a+b?c+/];
         ok /a*b?c*/, qq [\$_ = '$_'; /a*b?c*/];

        $_ = 'aaaccc';
         ok /a*b?c*/, qq [\$_ = '$_'; /a*b?c*/];
        nok /a*b+c*/, qq [\$_ = '$_'; /a*b+c*/];

        $_ = 'abcdef';
         ok /bcd|xyz/, qq [\$_ = '$_'; /bcd|xyz/];
         ok /xyz|bcd/, qq [\$_ = '$_'; /xyz|bcd/];
         ok m|bc/*d|,  qq [\$_ = '$_'; m|bc/*d|];
         ok /^$_$/,    qq [\$_ = '$_'; /^\$_\$/];
    }

    {
        # used to be a test for $*
        ok "ab\ncd\n" =~ /^cd/m, qq ["ab\ncd\n" =~ /^cd/m];
    }

    {
        our %XXX = map {($_ => $_)} 123, 234, 345;

        our @@XXX = ('ok 1','not ok 1', 'ok 2','not ok 2','not ok 3');
        while ($_ = shift(@@XXX)) {
            my $f = index ($_, 'not') >= 0 ? \&nok : \&ok;
            my $r = ?(.*)?;
            &$f ($r, "?(.*)?");
            /not/ && reset;
            if (/not ok 2/) {
                if ($^O eq 'VMS') {
                    $_ = shift(@@XXX);
                }
                else {
                    reset 'X';
                }
            }
        }

        SKIP: {
            if ($^O eq 'VMS') {
                skip "Reset 'X'", 1;
            }
            ok !keys %XXX, "%XXX is empty";
        }

    }

    {
        local $Message = "Test empty pattern";
        my $xyz = 'xyz';
        my $cde = 'cde';

        $cde =~ /[^ab]*/;
        $xyz =~ //;
        iseq $&, $xyz;

        my $foo = '[^ab]*';
        $cde =~ /$foo/;
        $xyz =~ //;
        iseq $&, $xyz;

        $cde =~ /$foo/;
        my $null;
        no warnings 'uninitialized';
        $xyz =~ /$null/;
        iseq $&, $xyz;

        $null = "";
        $xyz =~ /$null/;
        iseq $&, $xyz;
    }

    {
        local $Message = q !Check $`, $&, $'!;
        $_ = 'abcdefghi';
        /def/;		# optimized up to cmd
        iseq "$`:$&:$'", 'abc:def:ghi';

        no warnings 'void';
        /cde/ + 0;	# optimized only to spat
        iseq "$`:$&:$'", 'ab:cde:fghi';

        /[d][e][f]/;	# not optimized
        iseq "$`:$&:$'", 'abc:def:ghi';
    }

    {
        $_ = 'now is the {time for all} good men to come to.';
        / {([^}]*)}/;
        iseq $1, 'time for all', "Match braces";
    }

    {
        local $Message = "{N,M} quantifier";
        $_ = 'xxx {3,4}  yyy   zzz';
        ok /( {3,4})/;
        iseq $1, '   ';
        ok !/( {4,})/;
        ok /( {2,3}.)/;
        iseq $1, '  y';
        ok /(y{2,3}.)/;
        iseq $1, 'yyy ';
        ok !/x {3,4}/;
        ok !/^xxx {3,4}/;
    }

    {
        local $Message = "Test /g";
        local $" = ":";
        $_ = "now is the time for all good men to come to.";
        my @@words = /(\w+)/g;
        my $exp   = "now:is:the:time:for:all:good:men:to:come:to";

        iseq "@@words", $exp;

        @@words = ();
        while (/\w+/g) {
            push (@@words, $&);
        }
        iseq "@@words", $exp;

        @@words = ();
        pos = 0;
        while (/to/g) {
            push(@@words, $&);
        }
        iseq "@@words", "to:to";

        pos $_ = 0;
        @@words = /to/g;
        iseq "@@words", "to:to";
    }

    {
        $_ = "abcdefghi";

        my $pat1 = 'def';
        my $pat2 = '^def';
        my $pat3 = '.def.';
        my $pat4 = 'abc';
        my $pat5 = '^abc';
        my $pat6 = 'abc$';
        my $pat7 = 'ghi';
        my $pat8 = '\w*ghi';
        my $pat9 = 'ghi$';

        my $t1 = my $t2 = my $t3 = my $t4 = my $t5 =
        my $t6 = my $t7 = my $t8 = my $t9 = 0;

        for my $iter (1 .. 5) {
            $t1++ if /$pat1/o;
            $t2++ if /$pat2/o;
            $t3++ if /$pat3/o;
            $t4++ if /$pat4/o;
            $t5++ if /$pat5/o;
            $t6++ if /$pat6/o;
            $t7++ if /$pat7/o;
            $t8++ if /$pat8/o;
            $t9++ if /$pat9/o;
        }
        my $x = "$t1$t2$t3$t4$t5$t6$t7$t8$t9";
        iseq $x, '505550555', "Test /o";
    }


    SKIP: {
        my $xyz = 'xyz';
        ok "abc" =~ /^abc$|$xyz/, "| after \$";

        # perl 4.009 says "unmatched ()"
        local $Message = '$ inside ()';

        my $result;
        eval '"abc" =~ /a(bc$)|$xyz/; $result = "$&:$1"';
        iseq $@@, "" or skip "eval failed", 1;
        iseq $result, "abc:bc";
    }


    {
        local $Message = "Scalar /g";
        $_ = "abcfooabcbar";

        ok  /abc/g && $` eq "";
        ok  /abc/g && $` eq "abcfoo";
        ok !/abc/g;

        local $Message = "Scalar /gi";
        pos = 0;
        ok  /ABC/gi && $` eq "";
        ok  /ABC/gi && $` eq "abcfoo";
        ok !/ABC/gi;

        local $Message = "Scalar /g";
        pos = 0;
        ok  /abc/g && $' eq "fooabcbar";
        ok  /abc/g && $' eq "bar";

        $_ .= '';
        my @@x = /abc/g;
        iseq @@x, 2, "/g reset after assignment";
    }

    {
        local $Message = '/g, \G and pos';
        $_ = "abdc";
        pos $_ = 2;
        /\Gc/gc;
        iseq pos $_, 2;
        /\Gc/g;
        ok !defined pos $_;
    }

    {
        local $Message = '(?{ })';
        our $out = 1;
        'abc' =~ m'a(?{ $out = 2 })b';
        iseq $out, 2;

        $out = 1;
        'abc' =~ m'a(?{ $out = 3 })c';
        iseq $out, 1;
    }


    {
        $_ = 'foobar1 bar2 foobar3 barfoobar5 foobar6';
        my @@out = /(?<!foo)bar./g;
        iseq "@@out", 'bar2 barf', "Negative lookbehind";
    }

    {
        local $Message = "REG_INFTY tests";
        # Tests which depend on REG_INFTY
        $::reg_infty   = $Config {reg_infty} // 32767;
        $::reg_infty_m = $::reg_infty - 1;
        $::reg_infty_p = $::reg_infty + 1;
        $::reg_infty_m = $::reg_infty_m;   # Surpress warning.

        # As well as failing if the pattern matches do unexpected things, the
        # next three tests will fail if you should have picked up a lower-than-
        # default value for $reg_infty from Config.pm, but have not.

        eval_ok q (('aaa' =~ /(a{1,$::reg_infty_m})/)[0] eq 'aaa');
        eval_ok q (('a' x $::reg_infty_m) =~ /a{$::reg_infty_m}/);
        eval_ok q (('a' x ($::reg_infty_m - 1)) !~ /a{$::reg_infty_m}/);
        eval "'aaa' =~ /a{1,$::reg_infty}/";
        ok $@@ =~ /^\QQuantifier in {,} bigger than/;
        eval "'aaa' =~ /a{1,$::reg_infty_p}/";
        ok $@@ =~ /^\QQuantifier in {,} bigger than/;
    }

    {
        # Poke a couple more parse failures
        my $context = 'x' x 256;
        eval qq("${context}y" =~ /(?<=$context)y/);
        ok $@@ =~ /^\QLookbehind longer than 255 not/, "Lookbehind limit";
    }

    {
        # Long Monsters
        local $Message = "Long monster";
        for my $l (125, 140, 250, 270, 300000, 30) { # Ordered to free memory
            my $a = 'a' x $l;
            local $Error = "length = $l";
             ok "ba$a=" =~ /a$a=/;
            nok "b$a="  =~ /a$a=/;
             ok "b$a="  =~ /ba+=/;

             ok "ba$a=" =~ /b(?:a|b)+=/;
        }
    }


    {
        # 20000 nodes, each taking 3 words per string, and 1 per branch
        my $long_constant_len = join '|', 12120 .. 32645;
        my $long_var_len = join '|', 8120 .. 28645;
        my %ans = ( 'ax13876y25677lbc' => 1,
                    'ax13876y25677mcb' => 0, # not b.
                    'ax13876y35677nbc' => 0, # Num too big
                    'ax13876y25677y21378obc' => 1,
                    'ax13876y25677y21378zbc' => 0,	# Not followed by [k-o]
                    'ax13876y25677y21378y21378kbc' => 1,
                    'ax13876y25677y21378y21378kcb' => 0, # Not b.
                    'ax13876y25677y21378y21378y21378kbc' => 0, # 5 runs
                  );

        local $Message = "20000 nodes";
        for (keys %ans) {
            local $Error = "const-len '$_'";
            ok !($ans{$_} xor /a(?=([yx]($long_constant_len)){2,4}[k-o]).*b./o);

            local $Error = "var-len '$_'";
            ok !($ans{$_} xor /a(?=([yx]($long_var_len)){2,4}[k-o]).*b./o);
        }
    }

    {
        local $Message = "Complicated backtracking";
        $_ = " a (bla()) and x(y b((l)u((e))) and b(l(e)e)e";
        my $expect = "(bla()) ((l)u((e))) (l(e)e)";

        use vars '$c';
        sub matchit {
          m/
             (
               \(
               (?{ $c = 1 })	# Initialize
               (?:
                 (?(?{ $c == 0 })   # PREVIOUS iteration was OK, stop the loop
                   (?!
                   )		# Fail: will unwind one iteration back
                 )	
                 (?:
                   [^()]+		# Match a big chunk
                   (?=
                     [()]
                   )		# Do not try to match subchunks
                 |
                   \(
                   (?{ ++$c })
                 |
                   \)
                   (?{ --$c })
                 )
               )+		# This may not match with different subblocks
             )
             (?(?{ $c != 0 })
               (?!
               )		# Fail
             )			# Otherwise the chunk 1 may succeed with $c>0
           /xg;
        }

        my @@ans = ();
        my $res;
        push @@ans, $res while $res = matchit;
        iseq "@@ans", "1 1 1";

        @@ans = matchit;
        iseq "@@ans", $expect;

        local $Message = "Recursion with (??{ })";
        our $matched;
        $matched = qr/\((?:(?>[^()]+)|(??{$matched}))*\)/;

        @@ans = my @@ans1 = ();
        push (@@ans, $res), push (@@ans1, $&) while $res = m/$matched/g;

        iseq "@@ans", "1 1 1";
        iseq "@@ans1", $expect;

        @@ans = m/$matched/g;
        iseq "@@ans", $expect;

    }

    {
        ok "abc" =~ /^(??{"a"})b/, '"abc" =~ /^(??{"a"})b/';
    }

    {
        my @@ans = ('a/b' =~ m%(.*/)?(.*)%);	# Stack may be bad
        iseq "@@ans", 'a/ b', "Stack may be bad";
    }

    {
        local $Message = "Eval-group not allowed at runtime";
        my $code = '{$blah = 45}';
        our $blah = 12;
        eval { /(?$code)/ };
        ok $@@ && $@@ =~ /not allowed at runtime/ && $blah == 12;

        for $code ('{$blah = 45}','=xx') {
            $blah = 12;
            my $res = eval { "xx" =~ /(?$code)/o };
            no warnings 'uninitialized';
            local $Error = "'$@@', '$res', '$blah'";
            if ($code eq '=xx') {
                ok !$@@ && $res;
            }
            else {
                ok $@@ && $@@ =~ /not allowed at runtime/ && $blah == 12;
            }
        }

        $code = '{$blah = 45}';
        $blah = 12;
        eval "/(?$code)/";
        iseq $blah, 45;

        $blah = 12;
        /(?{$blah = 45})/;
        iseq $blah, 45;
    }

    {
        local $Message = "Pos checks";
        my $x = 'banana';
        $x =~ /.a/g;
        iseq pos ($x), 2;

        $x =~ /.z/gc;
        iseq pos ($x), 2;

        sub f {
            my $p = $_[0];
            return $p;
        }

        $x =~ /.a/g;
        iseq f (pos ($x)), 4;
    }

    {
        local $Message = 'Checking $^R';
        our $x = $^R = 67;
        'foot' =~ /foo(?{$x = 12; 75})[t]/;
        iseq $^R, 75;

        $x = $^R = 67;
        'foot' =~ /foo(?{$x = 12; 75})[xy]/;
        ok $^R eq '67' && $x eq '12';

        $x = $^R = 67;
        'foot' =~ /foo(?{ $^R + 12 })((?{ $x = 12; $^R + 17 })[xy])?/;
        ok $^R eq '79' && $x eq '12';
    }

    {
        iseq qr/\b\v$/i,    '(?i-xsm:\b\v$)', 'qr/\b\v$/i';
        iseq qr/\b\v$/s,    '(?s-xim:\b\v$)', 'qr/\b\v$/s';
        iseq qr/\b\v$/m,    '(?m-xis:\b\v$)', 'qr/\b\v$/m';
        iseq qr/\b\v$/x,    '(?x-ism:\b\v$)', 'qr/\b\v$/x';
        iseq qr/\b\v$/xism, '(?msix:\b\v$)',  'qr/\b\v$/xism';
        iseq qr/\b\v$/,     '(?-xism:\b\v$)', 'qr/\b\v$/';
    }


    {
        local $Message = "Look around";
        $_ = 'xabcx';
      SKIP:
        foreach my $ans ('', 'c') {
            ok /(?<=(?=a)..)((?=c)|.)/g or skip "Match failed", 1;
            iseq $1, $ans;
        }
    }

    {
        local $Message = "Empty clause";
        $_ = 'a';
        foreach my $ans ('', 'a', '') {
            ok /^|a|$/g or skip "Match failed", 1;
            iseq $&, $ans;
        }
    }

    {
        local $Message = "Prefixify";
        sub prefixify {
            SKIP: {
                my ($v, $a, $b, $res) = @@_;
                ok $v =~ s/\Q$a\E/$b/ or skip "Match failed", 1;
                iseq $v, $res;
            }
        }

        prefixify ('/a/b/lib/arch', "/a/b/lib", 'X/lib', 'X/lib/arch');
        prefixify ('/a/b/man/arch', "/a/b/man", 'X/man', 'X/man/arch');
    }

    {
        $_ = 'var="foo"';
        /(\")/;
        ok $1 && /$1/, "Capture a quote";
    }

    {
        local $Message =  "Call code from qr //";
        $a = qr/(?{++$b})/;
        $b = 7;
        ok /$a$a/ && $b eq '9';

        $c="$a";
        ok /$a$a/ && $b eq '11';

        undef $@@;
        eval {/$c/};
        ok $@@ && $@@ =~ /not allowed at runtime/;

        use re "eval";
        /$a$c$a/;
        iseq $b, '14';

        our $lex_a = 43;
        our $lex_b = 17;
        our $lex_c = 27;
        my $lex_res = ($lex_b =~ qr/$lex_b(?{ $lex_c = $lex_a++ })/);

        iseq $lex_res, 1;
        iseq $lex_a, 44;
        iseq $lex_c, 43;

        no re "eval";
        undef $@@;
        my $match = eval { /$a$c$a/ };
        ok $@@ && $@@ =~ /Eval-group not allowed/ && !$match;
        iseq $b, '14';
     
        $lex_a = 2;
        $lex_a = 43;
        $lex_b = 17;
        $lex_c = 27;
        $lex_res = ($lex_b =~ qr/17(?{ $lex_c = $lex_a++ })/);

        iseq $lex_res, 1;
        iseq $lex_a, 44;
        iseq $lex_c, 43;

    }


    {
        no warnings 'closure';
        local $Message = '(?{ $var } refers to package vars';
        package aa;
        our $c = 2;
        $::c = 3;
        '' =~ /(?{ $c = 4 })/;
        main::iseq $c, 4;
        main::iseq $::c, 3;
    }


    {
        must_die 'q(a:[b]:) =~ /[x[:foo:]]/',
                 'POSIX class \[:[^:]+:\] unknown in regex',
                 'POSIX class [: :] must have valid name';

        for my $d (qw [= .]) {
            must_die "/[[${d}foo${d}]]/",
                     "\QPOSIX syntax [$d $d] is reserved for future extensions",
                     "POSIX syntax [[$d $d]] is an error";
        }
    }


    {
        # test if failure of patterns returns empty list
        local $Message = "Failed pattern returns empty list";
        $_ = 'aaa';
        @@_ = /bbb/;
        iseq "@@_", "";

        @@_ = /bbb/g;
        iseq "@@_", "";

        @@_ = /(bbb)/;
        iseq "@@_", "";

        @@_ = /(bbb)/g;
        iseq "@@_", "";
    }

    
    {
        local $Message = '@@- and @@+ tests';

        /a(?=.$)/;
        iseq $#+, 0;
        iseq $#-, 0;
        iseq $+ [0], 2;
        iseq $- [0], 1;
        ok !defined $+ [1] && !defined $- [1] &&
           !defined $+ [2] && !defined $- [2];

        /a(a)(a)/;
        iseq $#+, 2;
        iseq $#-, 2;
        iseq $+ [0], 3;
        iseq $- [0], 0;
        iseq $+ [1], 2;
        iseq $- [1], 1;
        iseq $+ [2], 3;
        iseq $- [2], 2;
        ok !defined $+ [3] && !defined $- [3] &&
           !defined $+ [4] && !defined $- [4];


        /.(a)(b)?(a)/;
        iseq $#+, 3;
        iseq $#-, 3;
        iseq $+ [1], 2;
        iseq $- [1], 1;
        iseq $+ [3], 3;
        iseq $- [3], 2;
        ok !defined $+ [2] && !defined $- [2] &&
           !defined $+ [4] && !defined $- [4];


        /.(a)/;
        iseq $#+, 1;
        iseq $#-, 1;
        iseq $+ [0], 2;
        iseq $- [0], 0;
        iseq $+ [1], 2;
        iseq $- [1], 1;
        ok !defined $+ [2] && !defined $- [2] &&
           !defined $+ [3] && !defined $- [3];

        /.(a)(ba*)?/;
        iseq $#+, 2;
        iseq $#-, 1;
    }


    {
        local $DiePattern = '^Modification of a read-only value attempted';
        local $Message    = 'Elements of @@- and @@+ are read-only';
        must_die '$+[0] = 13';
        must_die '$-[0] = 13';
        must_die '@@+ = (7, 6, 5)';
        must_die '@@- = qw (foo bar)';
    }


    {
        local $Message = '\G testing';
        $_ = 'aaa';
        pos = 1;
        my @@a = /\Ga/g;
        iseq "@@a", "a a";

        my $str = 'abcde';
        pos $str = 2;
        ok $str !~ /^\G/;
        ok $str !~ /^.\G/;
        ok $str =~ /^..\G/;
        ok $str !~ /^...\G/;
        ok $str =~ /\G../ && $& eq 'cd';

        local $TODO = $running_as_thread;
        ok $str =~ /.\G./ && $& eq 'bc';
    }


    {
        local $Message = 'pos inside (?{ })';
        my $str = 'abcde';
        our ($foo, $bar);
        ok $str =~ /b(?{$foo = $_; $bar = pos})c/;
        iseq $foo, $str;
        iseq $bar, 2;
        ok !defined pos ($str);

        undef $foo;
        undef $bar;
        pos $str = undef;
        ok $str =~ /b(?{$foo = $_; $bar = pos})c/g;
        iseq $foo, $str;
        iseq $bar, 2;
        iseq pos ($str), 3;

        $_ = $str;
        undef $foo;
        undef $bar;
        ok /b(?{$foo = $_; $bar = pos})c/;
        iseq $foo, $str;
        iseq $bar, 2;

        undef $foo;
        undef $bar;
        ok /b(?{$foo = $_; $bar = pos})c/g;
        iseq $foo, $str;
        iseq $bar, 2;
        iseq pos, 3;

        undef $foo;
        undef $bar;
        pos = undef;
        1 while /b(?{$foo = $_; $bar = pos})c/g;
        iseq $foo, $str;
        iseq $bar, 2;
        ok !defined pos;

        undef $foo;
        undef $bar;
        $_ = 'abcde|abcde';
        ok s/b(?{$foo = $_; $bar = pos})c/x/g;
        iseq $foo, 'abcde|abcde';
        iseq $bar, 8;
        iseq $_, 'axde|axde';

        # List context:
        $_ = 'abcde|abcde';
        our @@res;
        () = /([ace]).(?{push @@res, $1,$2})([ce])(?{push @@res, $1,$2})/g;
        @@res = map {defined $_ ? "'$_'" : 'undef'} @@res;
        iseq "@@res", "'a' undef 'a' 'c' 'e' undef 'a' undef 'a' 'c'";

        @@res = ();
        () = /([ace]).(?{push @@res, $`,$&,$'})([ce])(?{push @@res, $`,$&,$'})/g;
        @@res = map {defined $_ ? "'$_'" : 'undef'} @@res;
        iseq "@@res", "'' 'ab' 'cde|abcde' " .
                     "'' 'abc' 'de|abcde' " .
                     "'abcd' 'e|' 'abcde' " .
                     "'abcde|' 'ab' 'cde' " .
                     "'abcde|' 'abc' 'de'" ;
    }


    {
        local $Message = '\G anchor checks';
        my $foo = 'aabbccddeeffgg';
        pos ($foo) = 1;
        {
            local $TODO = $running_as_thread;
            no warnings 'uninitialized';
            ok $foo =~ /.\G(..)/g;
            iseq $1, 'ab';

            pos ($foo) += 1;
            ok $foo =~ /.\G(..)/g;
            iseq $1, 'cc';

            pos ($foo) += 1;
            ok $foo =~ /.\G(..)/g;
            iseq $1, 'de';

            ok $foo =~ /\Gef/g;
        }

        undef pos $foo;
        ok $foo =~ /\G(..)/g;
        iseq $1, 'aa';

        ok $foo =~ /\G(..)/g;
        iseq $1, 'bb';

        pos ($foo) = 5;
        ok $foo =~ /\G(..)/g;
        iseq $1, 'cd';
    }


    {
        $_ = '123x123';
        my @@res = /(\d*|x)/g;
        local $" = '|';
        iseq "@@res", "123||x|123|", "0 match in alternation";
    }


    {
        local $Message = "Match against temporaries (created via pp_helem())" .
                         " is safe";
        ok {foo => "bar\n" . $^X} -> {foo} =~ /^(.*)\n/g;
        iseq $1, "bar";
    }


    {
        local $Message = 'package $i inside (?{ }), ' .
                         'saved substrings and changing $_';
        our @@a = qw [foo bar];
        our @@b = ();
        s/(\w)(?{push @@b, $1})/,$1,/g for @@a;
        iseq "@@b", "f o o b a r";
        iseq "@@a", ",f,,o,,o, ,b,,a,,r,";

        local $Message = 'lexical $i inside (?{ }), ' .
                         'saved substrings and changing $_';
        no warnings 'closure';
        my @@c = qw [foo bar];
        my @@d = ();
        s/(\w)(?{push @@d, $1})/,$1,/g for @@c;
        iseq "@@d", "f o o b a r";
        iseq "@@c", ",f,,o,,o, ,b,,a,,r,";
    }


    {
        local $Message = 'Brackets';
        our $brackets;
        $brackets = qr {
            {  (?> [^{}]+ | (??{ $brackets }) )* }
        }x;

        ok "{{}" =~ $brackets;
        iseq $&, "{}";
        ok "something { long { and } hairy" =~ $brackets;
        iseq $&, "{ and }";
        ok "something { long { and } hairy" =~ m/((??{ $brackets }))/;
        iseq $&, "{ and }";
    }


    {
        $_ = "a-a\nxbb";
        pos = 1;
        nok m/^-.*bb/mg, '$_ = "a-a\nxbb"; m/^-.*bb/mg';
    }


    {
        local $Message = '\G anchor checks';
        my $text = "aaXbXcc";
        pos ($text) = 0;
        ok $text !~ /\GXb*X/g;
    }


    {
        $_ = "xA\n" x 500;
        nok /^\s*A/m, '$_ = "xA\n" x 500; /^\s*A/m"';

        my $text = "abc dbf";
        my @@res = ($text =~ /.*?(b).*?\b/g);
        iseq "@@res", "b b", '\b is not special';
    }


    {
        local $Message = '\S, [\S], \s, [\s]';
        my @@a = map chr, 0 .. 255;
        my @@b = grep /\S/, @@a;
        my @@c = grep /[^\s]/, @@a;
        iseq "@@b", "@@c";

        @@b = grep /\S/, @@a;
        @@c = grep /[\S]/, @@a;
        iseq "@@b", "@@c";

        @@b = grep /\s/, @@a;
        @@c = grep /[^\S]/, @@a;
        iseq "@@b", "@@c";

        @@b = grep /\s/, @@a;
        @@c = grep /[\s]/, @@a;
        iseq "@@b", "@@c";
    }
    {
        local $Message = '\D, [\D], \d, [\d]';
        my @@a = map chr, 0 .. 255;
        my @@b = grep /\D/, @@a;
        my @@c = grep /[^\d]/, @@a;
        iseq "@@b", "@@c";

        @@b = grep /\D/, @@a;
        @@c = grep /[\D]/, @@a;
        iseq "@@b", "@@c";

        @@b = grep /\d/, @@a;
        @@c = grep /[^\D]/, @@a;
        iseq "@@b", "@@c";

        @@b = grep /\d/, @@a;
        @@c = grep /[\d]/, @@a;
        iseq "@@b", "@@c";
    }
    {
        local $Message = '\W, [\W], \w, [\w]';
        my @@a = map chr, 0 .. 255;
        my @@b = grep /\W/, @@a;
        my @@c = grep /[^\w]/, @@a;
        iseq "@@b", "@@c";

        @@b = grep /\W/, @@a;
        @@c = grep /[\W]/, @@a;
        iseq "@@b", "@@c";

        @@b = grep /\w/, @@a;
        @@c = grep /[^\W]/, @@a;
        iseq "@@b", "@@c";

        @@b = grep /\w/, @@a;
        @@c = grep /[\w]/, @@a;
        iseq "@@b", "@@c";
    }


    {
        # see if backtracking optimization works correctly
        local $Message = 'Backtrack optimization';
        ok "\n\n" =~ /\n   $ \n/x;
        ok "\n\n" =~ /\n*  $ \n/x;
        ok "\n\n" =~ /\n+  $ \n/x;
        ok "\n\n" =~ /\n?  $ \n/x;
        ok "\n\n" =~ /\n*? $ \n/x;
        ok "\n\n" =~ /\n+? $ \n/x;
        ok "\n\n" =~ /\n?? $ \n/x;
        ok "\n\n" !~ /\n*+ $ \n/x;
        ok "\n\n" !~ /\n++ $ \n/x;
        ok "\n\n" =~ /\n?+ $ \n/x;
    }


    {
        package S;
        use overload '""' => sub {'Object S'};
        sub new {bless []}
     
        local $Message  = "Ref stringification";
      ::ok do { \my $v} =~ /^SCALAR/,   "Scalar ref stringification";
      ::ok do {\\my $v} =~ /^REF/,      "Ref ref stringification";
      ::ok []           =~ /^ARRAY/,    "Array ref stringification";
      ::ok {}           =~ /^HASH/,     "Hash ref stringification";
      ::ok 'S' -> new   =~ /^Object S/, "Object stringification";
    }


    {
        local $Message = "Test result of match used as match";
        ok 'a1b' =~ ('xyz' =~ /y/);
        iseq $`, 'a';
        ok 'a1b' =~ ('xyz' =~ /t/);
        iseq $`, 'a';
    }


    {
        local $Message = '"1" is not \s';
        may_not_warn sub {ok ("1\n" x 102) !~ /^\s*\n/m};
    }


    {
        local $Message = '\s, [[:space:]] and [[:blank:]]';
        my %space = (spc   => " ",
                     tab   => "\t",
                     cr    => "\r",
                     lf    => "\n",
                     ff    => "\f",
        # There's no \v but the vertical tabulator seems miraculously
        # be 11 both in ASCII and EBCDIC.
                     vt    => chr(11),
                     false => "space");

        my @@space0 = sort grep {$space {$_} =~ /\s/         } keys %space;
        my @@space1 = sort grep {$space {$_} =~ /[[:space:]]/} keys %space;
        my @@space2 = sort grep {$space {$_} =~ /[[:blank:]]/} keys %space;

        iseq "@@space0", "cr ff lf spc tab";
        iseq "@@space1", "cr ff lf spc tab vt";
        iseq "@@space2", "spc tab";
    }


    {
        local $BugId = '20000731.001';
        ok "A \x{263a} B z C" =~ /A . B (??{ "z" }) C/,
           "Match UTF-8 char in presense of (??{ })";
    }


    {
        local $BugId = '20001021.005';
        no warnings 'uninitialized';
        ok undef =~ /^([^\/]*)(.*)$/, "Used to cause a SEGV";
    }


  SKIP:
    {
        local $Message = '\C matches octet';
        $_ = "a\x{100}b";
        ok /(.)(\C)(\C)(.)/ or skip q [\C doesn't match], 4;
        iseq $1, "a";
        if ($IS_ASCII) {     # ASCII (or equivalent), should be UTF-8
            iseq $2, "\xC4";
            iseq $3, "\x80";
        }
        elsif ($IS_EBCDIC) { # EBCDIC (or equivalent), should be UTF-EBCDIC
            iseq $2, "\x8C";
            iseq $3, "\x41";
        }
        else {
            SKIP: {
                ok 0, "Unexpected platform", "ord ('A') = $ordA";
                skip "Unexpected platform";
            }
        }
        iseq $4, "b";
    }


  SKIP:
    {
        local $Message = '\C matches octet';
        $_ = "\x{100}";
        ok /(\C)/g or skip q [\C doesn't match], 2;
        if ($IS_ASCII) {
            iseq $1, "\xC4";
        }
        elsif ($IS_EBCDIC) {
            iseq $1, "\x8C";
        }
        else {
            ok 0, "Unexpected platform", "ord ('A') = $ordA";
        }
        ok /(\C)/g or skip q [\C doesn't match];
        if ($IS_ASCII) {
            iseq $1, "\x80";
        }
        elsif ($IS_EBCDIC) {
            iseq $1, "\x41";
        }
        else {
            ok 0, "Unexpected platform", "ord ('A') = $ordA";
        }
    }


    {
        # Japhy -- added 03/03/2001
        () = (my $str = "abc") =~ /(...)/;
        $str = "def";
        iseq $1, "abc", 'Changing subject does not modify $1';
    }


  SKIP:
    {
        # The trick is that in EBCDIC the explicit numeric range should
        # match (as also in non-EBCDIC) but the explicit alphabetic range
        # should not match.
        ok "\x8e" =~ /[\x89-\x91]/, '"\x8e" =~ /[\x89-\x91]/';
        ok "\xce" =~ /[\xc9-\xd1]/, '"\xce" =~ /[\xc9-\xd1]/';

        skip "Not an EBCDIC platform", 2 unless ord ('i') == 0x89 &&
                                                ord ('J') == 0xd1;

        # In most places these tests would succeed since \x8e does not
        # in most character sets match 'i' or 'j' nor would \xce match
        # 'I' or 'J', but strictly speaking these tests are here for
        # the good of EBCDIC, so let's test these only there.
        nok "\x8e" !~ /[i-j]/, '"\x8e" !~ /[i-j]/';
        nok "\xce" !~ /[I-J]/, '"\xce" !~ /[I-J]/';
    }


    {
        ok "\x{ab}"   =~ /\x{ab}/,   '"\x{ab}"   =~ /\x{ab}/  ';
        ok "\x{abcd}" =~ /\x{abcd}/, '"\x{abcd}" =~ /\x{abcd}/';
    }


    {
        local $Message = 'bug id 20001008.001';

        my @@x = ("stra\337e 138", "stra\337e 138");
        for (@@x) {
            ok s/(\d+)\s*([\w\-]+)/$1 . uc $2/e;
            ok my ($latin) = /^(.+)(?:\s+\d)/;
            iseq $latin, "stra\337e";
	    ok $latin =~ s/stra\337e/straße/;
            #
            # Previous code follows, but outcommented - there were no tests.
            #
            # $latin =~ s/stra\337e/straße/; # \303\237 after the 2nd a
            # use utf8; # needed for the raw UTF-8
            # $latin =~ s!(s)tr(?:aß|s+e)!$1tr.!; # \303\237 after the a
        }
    }


    {
        local $Message = 'Test \x escapes';
        ok "ba\xd4c" =~ /([a\xd4]+)/ && $1 eq "a\xd4";
        ok "ba\xd4c" =~ /([a\xd4]+)/ && $1 eq "a\x{d4}";
        ok "ba\x{d4}c" =~ /([a\xd4]+)/ && $1 eq "a\x{d4}";
        ok "ba\x{d4}c" =~ /([a\xd4]+)/ && $1 eq "a\xd4";
        ok "ba\xd4c" =~ /([a\x{d4}]+)/ && $1 eq "a\xd4";
        ok "ba\xd4c" =~ /([a\x{d4}]+)/ && $1 eq "a\x{d4}";
        ok "ba\x{d4}c" =~ /([a\x{d4}]+)/ && $1 eq "a\x{d4}";
        ok "ba\x{d4}c" =~ /([a\x{d4}]+)/ && $1 eq "a\xd4";
    }


    {
        local $BugId   = '20001028.003';

        # Fist half of the bug.
        local $Message = 'HEBREW ACCENT QADMA matched by .*';
        my $X = chr (1448);
        ok my ($Y) = $X =~ /(.*)/;
        iseq $Y, v1448;
        iseq length ($Y), 1;

        # Second half of the bug.
        $Message = 'HEBREW ACCENT QADMA in replacement';
        $X = '';
        $X =~ s/^/chr(1488)/e;
        iseq length $X, 1;
        iseq ord ($X), 1488;
    }


    {   
        local $BugId   = '20001108.001';
        local $Message = 'Repeated s///';
        my $X = "Szab\x{f3},Bal\x{e1}zs";
        my $Y = $X;
        $Y =~ s/(B)/$1/ for 0 .. 3;
        iseq $Y, $X;
        iseq $X, "Szab\x{f3},Bal\x{e1}zs";
    }


    {
        local $BugId   = '20000517.001';
        local $Message = 's/// on UTF-8 string';
        my $x = "\x{100}A";
        $x =~ s/A/B/;
        iseq $x, "\x{100}B";
        iseq length $x, 2;
    }


    {
        local $BugId   = '20001230.002';
        local $Message = '\C and É';
        ok "École" =~ /^\C\C(.)/ && $1 eq 'c';
        ok "École" =~ /^\C\C(c)/;
    }


  SKIP:
    {
        local $Message = 'Match code points > 255';
        $_ = "abc\x{100}\x{200}\x{300}\x{380}\x{400}defg";
        ok /(.\x{300})./ or skip "No match", 4;
        ok $` eq "abc\x{100}"            && length ($`) == 4;
        ok $& eq "\x{200}\x{300}\x{380}" && length ($&) == 3;
        ok $' eq "\x{400}defg"           && length ($') == 5;
        ok $1 eq "\x{200}\x{300}"        && length ($1) == 2;
    }


    {
        # The original bug report had 'no utf8' here but that was irrelevant.
        local $BugId   = '20010306.008';
        local $Message = "Don't dump core";
        my $a = "a\x{1234}";
        ok $a =~ m/\w/;  # used to core dump.
    }


    {
        local $BugId = '20010410.006';
        local $Message = '/g in scalar context';
        for my $rx ('/(.*?)\{(.*?)\}/csg',
		    '/(.*?)\{(.*?)\}/cg',
		    '/(.*?)\{(.*?)\}/sg',
		    '/(.*?)\{(.*?)\}/g',
		    '/(.+?)\{(.+?)\}/csg',) {
            my $i = 0;
            my $input = "a{b}c{d}";
            eval <<"            --";
                while (eval \$input =~ $rx) {
                    \$i ++;
                }
            --
            iseq $i, 2;
        }
    }


    {
        my $x = "\x{10FFFD}";
        $x =~ s/(.)/$1/g;
        ok ord($x) == 0x10FFFD && length($x) == 1, "From Robin Houston";
    }


    {
        my %d = (
            "7f" => [0, 0, 0],
            "80" => [1, 1, 0],
            "ff" => [1, 1, 0],
           "100" => [0, 1, 1],
        );
      SKIP:
        while (my ($code, $match) = each %d) {
            local $Message = "Properties of \\x$code";
            my $char = eval qq ["\\x{$code}"];
            my $i = 0;
            ok (($char =~ /[\x80-\xff]/)            xor !$$match [$i ++]);
            ok (($char =~ /[\x80-\x{100}]/)         xor !$$match [$i ++]);
            ok (($char =~ /[\x{100}]/)              xor !$$match [$i ++]);
        }
    }


    {
        # From Japhy
        local $Message;
        must_warn 'qr/(?c)/',    '^Useless \(\?c\)';
        must_warn 'qr/(?-c)/',   '^Useless \(\?-c\)';
        must_warn 'qr/(?g)/',    '^Useless \(\?g\)';
        must_warn 'qr/(?-g)/',   '^Useless \(\?-g\)';
        must_warn 'qr/(?o)/',    '^Useless \(\?o\)';
        must_warn 'qr/(?-o)/',   '^Useless \(\?-o\)';

        # Now test multi-error regexes
        must_warn 'qr/(?g-o)/',  '^Useless \(\?g\).*\nUseless \(\?-o\)';
        must_warn 'qr/(?g-c)/',  '^Useless \(\?g\).*\nUseless \(\?-c\)';
        # (?c) means (?g) error won't be thrown
        must_warn 'qr/(?o-cg)/', '^Useless \(\?o\).*\nUseless \(\?-c\)';
        must_warn 'qr/(?ogc)/',  '^Useless \(\?o\).*\nUseless \(\?g\).*\n' .
                                  'Useless \(\?c\)';
    }


    {
        local $Message = "/x tests";
        $_ = "foo";
        eval_ok <<"        --";
          /f
           o\r
           o
           \$
          /x
        --
        eval_ok <<"        --";
          /f
           o
           o
           \$\r
          /x
        --
    }


    {
        local $Message = "/o feature";
        sub test_o {$_ [0] =~ /$_[1]/o; return $1}
        iseq test_o ('abc', '(.)..'), 'a';
        iseq test_o ('abc', '..(.)'), 'a';
    }


    {
        local $BugId = "20010619.003";
        # Amazingly vertical tabulator is the same in ASCII and EBCDIC.
        for ("\n", "\t", "\014", "\r") {
            ok !/[[:print:]]/, "'$_' not in [[:print:]]";
        }
        for (" ") {
            ok  /[[:print:]]/, "'$_' in [[:print:]]";
        }
    }


    {
        # Test basic $^N usage outside of a regex
        local $Message = '$^N usage outside of a regex';
        my $x = "abcdef";
        ok ($x =~ /cde/                  and !defined $^N);
        ok ($x =~ /(cde)/                and $^N eq "cde");
        ok ($x =~ /(c)(d)(e)/            and $^N eq   "e");
        ok ($x =~ /(c(d)e)/              and $^N eq "cde");
        ok ($x =~ /(foo)|(c(d)e)/        and $^N eq "cde");
        ok ($x =~ /(c(d)e)|(foo)/        and $^N eq "cde");
        ok ($x =~ /(c(d)e)|(abc)/        and $^N eq "abc");
        ok ($x =~ /(c(d)e)|(abc)x/       and $^N eq "cde");
        ok ($x =~ /(c(d)e)(abc)?/        and $^N eq "cde");
        ok ($x =~ /(?:c(d)e)/            and $^N eq   "d");
        ok ($x =~ /(?:c(d)e)(?:f)/       and $^N eq   "d");
        ok ($x =~ /(?:([abc])|([def]))*/ and $^N eq   "f");
        ok ($x =~ /(?:([ace])|([bdf]))*/ and $^N eq   "f");
        ok ($x =~ /(([ace])|([bd]))*/    and $^N eq   "e");
       {ok ($x =~ /(([ace])|([bdf]))*/   and $^N eq   "f");}
        ## Test to see if $^N is automatically localized -- it should now
        ## have the value set in the previous test.
        iseq $^N, "e", '$^N is automatically localized';

        # Now test inside (?{ ... })
        local $Message = '$^N usage inside (?{ ... })';
        our ($y, $z);
        ok ($x =~ /a([abc])(?{$y=$^N})c/                    and $y eq  "b");
        ok ($x =~ /a([abc]+)(?{$y=$^N})d/                   and $y eq  "bc");
        ok ($x =~ /a([abcdefg]+)(?{$y=$^N})d/               and $y eq  "bc");
        ok ($x =~ /(a([abcdefg]+)(?{$y=$^N})d)(?{$z=$^N})e/ and $y eq  "bc"
                                                            and $z eq "abcd");
        ok ($x =~ /(a([abcdefg]+)(?{$y=$^N})de)(?{$z=$^N})/ and $y eq  "bc"
                                                            and $z eq "abcde");

    }


  SKIP:
    {
        ## Should probably put in tests for all the POSIX stuff,
        ## but not sure how to guarantee a specific locale......

        skip "Not an ASCII platform", 2 unless $IS_ASCII;
        local $Message = 'Test [[:cntrl:]]';
        my $AllBytes = join "" => map {chr} 0 .. 255;
        (my $x = $AllBytes) =~ s/[[:cntrl:]]//g;
        iseq $x, join "", map {chr} 0x20 .. 0x7E, 0x80 .. 0xFF;

        ($x = $AllBytes) =~ s/[^[:cntrl:]]//g;
        iseq $x, join "", map {chr} 0x00 .. 0x1F, 0x7F;
    }


    {
        # With /s modifier UTF8 chars were interpreted as bytes
        local $Message = "UTF-8 chars aren't bytes";
        my $a = "Hello \x{263A} World";
        my @@a = ($a =~ /./gs);
        iseq $#a, 12;
    }


    {
        local $Message = '. matches \n with /s';
        my $str1 = "foo\nbar";
        my $str2 = "foo\n\x{100}bar";
        my ($a, $b) = map {chr} $IS_ASCII ? (0xc4, 0x80) : (0x8c, 0x41);
        my @@a;
        @@a = $str1 =~ /./g;   iseq @@a, 6; iseq "@@a", "f o o b a r";
        @@a = $str1 =~ /./gs;  iseq @@a, 7; iseq "@@a", "f o o \n b a r";
        @@a = $str1 =~ /\C/g;  iseq @@a, 7; iseq "@@a", "f o o \n b a r";
        @@a = $str1 =~ /\C/gs; iseq @@a, 7; iseq "@@a", "f o o \n b a r";
        @@a = $str2 =~ /./g;   iseq @@a, 7; iseq "@@a", "f o o \x{100} b a r";
        @@a = $str2 =~ /./gs;  iseq @@a, 8; iseq "@@a", "f o o \n \x{100} b a r";
        @@a = $str2 =~ /\C/g;  iseq @@a, 9; iseq "@@a", "f o o \n $a $b b a r";
        @@a = $str2 =~ /\C/gs; iseq @@a, 9; iseq "@@a", "f o o \n $a $b b a r";
    }


    {
        # [ID 20010814.004] pos() doesn't work when using =~m// in list context
        local $BugId = '20010814.004';
        $_ = "ababacadaea";
        my $a = join ":", /b./gc;
        my $b = join ":", /a./gc;
        my $c = pos;
        iseq "$a $b $c", 'ba:ba ad:ae 10', "pos() works with () = m//";
    }


    {
        # [ID 20010407.006] matching utf8 return values from
        # functions does not work
        local $BugId   = '20010407.006';
        local $Message = 'UTF-8 return values from functions';
        package ID_20010407_006;
        sub x {"a\x{1234}"}
        my $x = x;
        my $y;
      ::ok $x =~ /(..)/;
        $y = $1;
      ::ok length ($y) == 2 && $y eq $x;
      ::ok x =~ /(..)/;
        $y = $1;
      ::ok length ($y) == 2 && $y eq $x;
    }


    {
        no warnings 'digit';
        # Check that \x## works. 5.6.1 and 5.005_03 fail some of these.
        my $x;
        $x = "\x4e" . "E";
        ok ($x =~ /^\x4EE$/, "Check only 2 bytes of hex are matched.");

        $x = "\x4e" . "i";
        ok ($x =~ /^\x4Ei$/, "Check that invalid hex digit stops it (2)");

        $x = "\x4" . "j";
        ok ($x =~ /^\x4j$/,  "Check that invalid hex digit stops it (1)");

        $x = "\x0" . "k";
        ok ($x =~ /^\xk$/,   "Check that invalid hex digit stops it (0)");

        $x = "\x0" . "x";
        ok ($x =~ /^\xx$/, "\\xx isn't to be treated as \\0");

        $x = "\x0" . "xa";
        ok ($x =~ /^\xxa$/, "\\xxa isn't to be treated as \\xa");

        $x = "\x9" . "_b";
        ok ($x =~ /^\x9_b$/, "\\x9_b isn't to be treated as \\x9b");

        # and now again in [] ranges

        $x = "\x4e" . "E";
        ok ($x =~ /^[\x4EE]{2}$/, "Check only 2 bytes of hex are matched.");

        $x = "\x4e" . "i";
        ok ($x =~ /^[\x4Ei]{2}$/, "Check that invalid hex digit stops it (2)");

        $x = "\x4" . "j";
        ok ($x =~ /^[\x4j]{2}$/,  "Check that invalid hex digit stops it (1)");

        $x = "\x0" . "k";
        ok ($x =~ /^[\xk]{2}$/,   "Check that invalid hex digit stops it (0)");

        $x = "\x0" . "x";
        ok ($x =~ /^[\xx]{2}$/, "\\xx isn't to be treated as \\0");

        $x = "\x0" . "xa";
        ok ($x =~ /^[\xxa]{3}$/, "\\xxa isn't to be treated as \\xa");

        $x = "\x9" . "_b";
        ok ($x =~ /^[\x9_b]{3}$/, "\\x9_b isn't to be treated as \\x9b");

        # Check that \x{##} works. 5.6.1 fails quite a few of these.

        $x = "\x9b";
        ok ($x =~ /^\x{9_b}$/, "\\x{9_b} is to be treated as \\x9b");

        $x = "\x9b" . "y";
        ok ($x =~ /^\x{9_b}y$/, "\\x{9_b} is to be treated as \\x9b (again)");

        $x = "\x9b" . "y";
        ok ($x =~ /^\x{9b_}y$/, "\\x{9b_} is to be treated as \\x9b");

        $x = "\x9b" . "y";
        ok ($x =~ /^\x{9_bq}y$/, "\\x{9_bc} is to be treated as \\x9b");

        $x = "\x0" . "y";
        ok ($x =~ /^\x{x9b}y$/, "\\x{x9b} is to be treated as \\x0");

        $x = "\x0" . "y";
        ok ($x =~ /^\x{0x9b}y$/, "\\x{0x9b} is to be treated as \\x0");

        $x = "\x9b" . "y";
        ok ($x =~ /^\x{09b}y$/, "\\x{09b} is to be treated as \\x9b");

        $x = "\x9b";
        ok ($x =~ /^[\x{9_b}]$/, "\\x{9_b} is to be treated as \\x9b");

        $x = "\x9b" . "y";
        ok ($x =~ /^[\x{9_b}y]{2}$/,
                                 "\\x{9_b} is to be treated as \\x9b (again)");

        $x = "\x9b" . "y";
        ok ($x =~ /^[\x{9b_}y]{2}$/, "\\x{9b_} is to be treated as \\x9b");

        $x = "\x9b" . "y";
        ok ($x =~ /^[\x{9_bq}y]{2}$/, "\\x{9_bc} is to be treated as \\x9b");

        $x = "\x0" . "y";
        ok ($x =~ /^[\x{x9b}y]{2}$/, "\\x{x9b} is to be treated as \\x0");

        $x = "\x0" . "y";
        ok ($x =~ /^[\x{0x9b}y]{2}$/, "\\x{0x9b} is to be treated as \\x0");

        $x = "\x9b" . "y";
        ok ($x =~ /^[\x{09b}y]{2}$/, "\\x{09b} is to be treated as \\x9b");

    }


    {
        # High bit bug -- japhy
        my $x = "ab\200d";
        ok $x =~ /.*?\200/, "High bit fine";
    }


    {
        # The basic character classes and Unicode
        ok "\x{0100}" =~ /\w/, 'LATIN CAPITAL LETTER A WITH MACRON in /\w/';
        ok "\x{0660}" =~ /\d/, 'ARABIC-INDIC DIGIT ZERO in /\d/';
        ok "\x{1680}" =~ /\s/, 'OGHAM SPACE MARK in /\s/';
    }


    {
        local $Message = "Folding matches and Unicode";
        ok "a\x{100}" =~ /A/i;
        ok "A\x{100}" =~ /a/i;
        ok "a\x{100}" =~ /a/i;
        ok "A\x{100}" =~ /A/i;
        ok "\x{101}a" =~ /\x{100}/i;
        ok "\x{100}a" =~ /\x{100}/i;
        ok "\x{101}a" =~ /\x{101}/i;
        ok "\x{100}a" =~ /\x{101}/i;
        ok "a\x{100}" =~ /A\x{100}/i;
        ok "A\x{100}" =~ /a\x{100}/i;
        ok "a\x{100}" =~ /a\x{100}/i;
        ok "A\x{100}" =~ /A\x{100}/i;
        ok "a\x{100}" =~ /[A]/i;
        ok "A\x{100}" =~ /[a]/i;
        ok "a\x{100}" =~ /[a]/i;
        ok "A\x{100}" =~ /[A]/i;
        ok "\x{101}a" =~ /[\x{100}]/i;
        ok "\x{100}a" =~ /[\x{100}]/i;
        ok "\x{101}a" =~ /[\x{101}]/i;
        ok "\x{100}a" =~ /[\x{101}]/i;
    }


    {
        use charnames ':full';
        local $Message = "Folding 'LATIN LETTER A WITH GRAVE'";

        my $lower = "\N{LATIN SMALL LETTER A WITH GRAVE}";
        my $UPPER = "\N{LATIN CAPITAL LETTER A WITH GRAVE}";
        
        ok $lower =~ m/$UPPER/i;
        ok $UPPER =~ m/$lower/i;
        ok $lower =~ m/[$UPPER]/i;
        ok $UPPER =~ m/[$lower]/i;

        local $Message = "Folding 'GREEK LETTER ALPHA WITH VRACHY'";

        $lower = "\N{GREEK CAPITAL LETTER ALPHA WITH VRACHY}";
        $UPPER = "\N{GREEK SMALL LETTER ALPHA WITH VRACHY}";

        ok $lower =~ m/$UPPER/i;
        ok $UPPER =~ m/$lower/i;
        ok $lower =~ m/[$UPPER]/i;
        ok $UPPER =~ m/[$lower]/i;

        local $Message = "Folding 'LATIN LETTER Y WITH DIAERESIS'";

        $lower = "\N{LATIN SMALL LETTER Y WITH DIAERESIS}";
        $UPPER = "\N{LATIN CAPITAL LETTER Y WITH DIAERESIS}";

        ok $lower =~ m/$UPPER/i;
        ok $UPPER =~ m/$lower/i;
        ok $lower =~ m/[$UPPER]/i;
        ok $UPPER =~ m/[$lower]/i;
    }


    {
        use charnames ':full';
        local $PatchId = "13843";
        local $Message = "GREEK CAPITAL LETTER SIGMA vs " .
                         "COMBINING GREEK PERISPOMENI";

        my $SIGMA = "\N{GREEK CAPITAL LETTER SIGMA}";
        my $char  = "\N{COMBINING GREEK PERISPOMENI}";

        may_not_warn sub {ok "_:$char:_" !~ m/_:$SIGMA:_/i};
    }


    {
        local $Message = '\X';
        use charnames ':full';

        ok "a!"                          =~ /^(\X)!/ && $1 eq "a";
        ok "\xDF!"                       =~ /^(\X)!/ && $1 eq "\xDF";
        ok "\x{100}!"                    =~ /^(\X)!/ && $1 eq "\x{100}";
        ok "\x{100}\x{300}!"             =~ /^(\X)!/ && $1 eq "\x{100}\x{300}";
        ok "\N{LATIN CAPITAL LETTER E}!" =~ /^(\X)!/ &&
               $1 eq "\N{LATIN CAPITAL LETTER E}";
        ok "\N{LATIN CAPITAL LETTER E}\N{COMBINING GRAVE ACCENT}!"
                                         =~ /^(\X)!/ &&
               $1 eq "\N{LATIN CAPITAL LETTER E}\N{COMBINING GRAVE ACCENT}";

        local $Message = '\C and \X';
        ok "!abc!" =~ /a\Cc/;
        ok "!abc!" =~ /a\Xc/;
    }


    {
        local $Message = "Final Sigma";

        my $SIGMA = "\x{03A3}"; # CAPITAL
        my $Sigma = "\x{03C2}"; # SMALL FINAL
        my $sigma = "\x{03C3}"; # SMALL

        ok $SIGMA =~ /$SIGMA/i;
        ok $SIGMA =~ /$Sigma/i;
        ok $SIGMA =~ /$sigma/i;

        ok $Sigma =~ /$SIGMA/i;
        ok $Sigma =~ /$Sigma/i;
        ok $Sigma =~ /$sigma/i;

        ok $sigma =~ /$SIGMA/i;
        ok $sigma =~ /$Sigma/i;
        ok $sigma =~ /$sigma/i;
        
        ok $SIGMA =~ /[$SIGMA]/i;
        ok $SIGMA =~ /[$Sigma]/i;
        ok $SIGMA =~ /[$sigma]/i;

        ok $Sigma =~ /[$SIGMA]/i;
        ok $Sigma =~ /[$Sigma]/i;
        ok $Sigma =~ /[$sigma]/i;

        ok $sigma =~ /[$SIGMA]/i;
        ok $sigma =~ /[$Sigma]/i;
        ok $sigma =~ /[$sigma]/i;

        local $Message = "More final Sigma";

        my $S3 = "$SIGMA$Sigma$sigma";

        ok ":$S3:" =~ /:(($SIGMA)+):/i   && $1 eq $S3 && $2 eq $sigma;
        ok ":$S3:" =~ /:(($Sigma)+):/i   && $1 eq $S3 && $2 eq $sigma;
        ok ":$S3:" =~ /:(($sigma)+):/i   && $1 eq $S3 && $2 eq $sigma;

        ok ":$S3:" =~ /:(([$SIGMA])+):/i && $1 eq $S3 && $2 eq $sigma;
        ok ":$S3:" =~ /:(([$Sigma])+):/i && $1 eq $S3 && $2 eq $sigma;
        ok ":$S3:" =~ /:(([$sigma])+):/i && $1 eq $S3 && $2 eq $sigma;
    }


    {
        use charnames ':full';
        local $Message = "Parlez-Vous " .
                         "Fran\N{LATIN SMALL LETTER C WITH CEDILLA}ais?";

        ok "Fran\N{LATIN SMALL LETTER C}ais" =~ /Fran.ais/ &&
            $& eq "Francais";
        ok "Fran\N{LATIN SMALL LETTER C WITH CEDILLA}ais" =~ /Fran.ais/ &&
            $& eq "Fran\N{LATIN SMALL LETTER C WITH CEDILLA}ais";
        ok "Fran\N{LATIN SMALL LETTER C}ais" =~ /Fran\Cais/ &&
            $& eq "Francais";
        # COMBINING CEDILLA is two bytes when encoded
        ok "Franc\N{COMBINING CEDILLA}ais" =~ /Franc\C\Cais/;
        ok "Fran\N{LATIN SMALL LETTER C}ais" =~ /Fran\Xais/ &&
            $& eq "Francais";
        ok "Fran\N{LATIN SMALL LETTER C WITH CEDILLA}ais" =~ /Fran\Xais/  &&
            $& eq "Fran\N{LATIN SMALL LETTER C WITH CEDILLA}ais";
        ok "Franc\N{COMBINING CEDILLA}ais" =~ /Fran\Xais/ &&
            $& eq "Franc\N{COMBINING CEDILLA}ais";
        ok "Fran\N{LATIN SMALL LETTER C WITH CEDILLA}ais" =~
           /Fran\N{LATIN SMALL LETTER C WITH CEDILLA}ais/  &&
            $& eq "Fran\N{LATIN SMALL LETTER C WITH CEDILLA}ais";
        ok "Franc\N{COMBINING CEDILLA}ais" =~ /Franc\N{COMBINING CEDILLA}ais/ &&
            $& eq "Franc\N{COMBINING CEDILLA}ais";

        my @@f = (
            ["Fran\N{LATIN SMALL LETTER C}ais",                    "Francais"],
            ["Fran\N{LATIN SMALL LETTER C WITH CEDILLA}ais",
                               "Fran\N{LATIN SMALL LETTER C WITH CEDILLA}ais"],
            ["Franc\N{COMBINING CEDILLA}ais", "Franc\N{COMBINING CEDILLA}ais"],
        );
        foreach my $entry (@@f) {
            my ($subject, $match) = @@$entry;
            ok $subject =~ /Fran(?:c\N{COMBINING CEDILLA}?|
                    \N{LATIN SMALL LETTER C WITH CEDILLA})ais/x &&
               $& eq $match;
        }
    }


    {
        local $Message = "Lingering (and useless) UTF8 flag doesn't mess up /i";
        my $pat = "ABcde";
        my $str = "abcDE\x{100}";
        chop $str;
        ok $str =~ /$pat/i;

        $pat = "ABcde\x{100}";
        $str = "abcDE";
        chop $pat;
        ok $str =~ /$pat/i;

        $pat = "ABcde\x{100}";
        $str = "abcDE\x{100}";
        chop $pat;
        chop $str;
        ok $str =~ /$pat/i;
    }


    {
        use charnames ':full';
        local $Message = "LATIN SMALL LETTER SHARP S " .
                         "(\N{LATIN SMALL LETTER SHARP S})";

        ok "\N{LATIN SMALL LETTER SHARP S}" =~
                                            /\N{LATIN SMALL LETTER SHARP S}/;
        ok "\N{LATIN SMALL LETTER SHARP S}" =~
                                            /\N{LATIN SMALL LETTER SHARP S}/i;
        ok "\N{LATIN SMALL LETTER SHARP S}" =~
                                           /[\N{LATIN SMALL LETTER SHARP S}]/;
        ok "\N{LATIN SMALL LETTER SHARP S}" =~
                                           /[\N{LATIN SMALL LETTER SHARP S}]/i;

        ok "ss" =~  /\N{LATIN SMALL LETTER SHARP S}/i;
        ok "SS" =~  /\N{LATIN SMALL LETTER SHARP S}/i;
        ok "ss" =~ /[\N{LATIN SMALL LETTER SHARP S}]/i;
        ok "SS" =~ /[\N{LATIN SMALL LETTER SHARP S}]/i;

        ok "\N{LATIN SMALL LETTER SHARP S}" =~ /ss/i;
        ok "\N{LATIN SMALL LETTER SHARP S}" =~ /SS/i;
 
        local $Message = "Unoptimized named sequence in class";
        ok "ss" =~ /[\N{LATIN SMALL LETTER SHARP S}x]/i;
        ok "SS" =~ /[\N{LATIN SMALL LETTER SHARP S}x]/i;
        ok "\N{LATIN SMALL LETTER SHARP S}" =~
          /[\N{LATIN SMALL LETTER SHARP S}x]/;
        ok "\N{LATIN SMALL LETTER SHARP S}" =~
          /[\N{LATIN SMALL LETTER SHARP S}x]/i;
    }


    {
        # More whitespace: U+0085, U+2028, U+2029\n";

        # U+0085, U+00A0 need to be forced to be Unicode, the \x{100} does that.
      SKIP: {
          skip "EBCDIC platform", 4 if $IS_EBCDIC;
          # Do \x{0015} and \x{0041} match \s in EBCDIC?
          ok "<\x{100}\x{0085}>" =~ /<\x{100}\s>/, '\x{0085} in \s';
          ok        "<\x{0085}>" =~        /<\v>/, '\x{0085} in \v';
          ok "<\x{100}\x{00A0}>" =~ /<\x{100}\s>/, '\x{00A0} in \s';
          ok        "<\x{00A0}>" =~        /<\h>/, '\x{00A0} in \h';
        }
        my @@h = map {sprintf "%05x" => $_} 0x01680, 0x0180E, 0x02000 .. 0x0200A,
                                           0x0202F, 0x0205F, 0x03000;
        my @@v = map {sprintf "%05x" => $_} 0x02028, 0x02029;

        my @@H = map {sprintf "%05x" => $_} 0x01361,   0x0200B, 0x02408, 0x02420,
                                           0x0303F,   0xE0020;
        my @@V = map {sprintf "%05x" => $_} 0x0008A .. 0x0008D, 0x00348, 0x10100,
                                           0xE005F,   0xE007C;

        for my $hex (@@h) {
            my $str = eval qq ["<\\x{$hex}>"];
            ok $str =~ /<\s>/, "\\x{$hex} in \\s";
            ok $str =~ /<\h>/, "\\x{$hex} in \\h";
            ok $str !~ /<\v>/, "\\x{$hex} not in \\v";
        }

        for my $hex (@@v) {
            my $str = eval qq ["<\\x{$hex}>"];
            ok $str =~ /<\s>/, "\\x{$hex} in \\s";
            ok $str =~ /<\v>/, "\\x{$hex} in \\v";
            ok $str !~ /<\h>/, "\\x{$hex} not in \\h";
        }

        for my $hex (@@H) {
            my $str = eval qq ["<\\x{$hex}>"];
            ok $str =~ /<\S>/, "\\x{$hex} in \\S";
            ok $str =~ /<\H>/, "\\x{$hex} in \\H";
        }

        for my $hex (@@V) {
            my $str = eval qq ["<\\x{$hex}>"];
            ok $str =~ /<\S>/, "\\x{$hex} in \\S";
            ok $str =~ /<\V>/, "\\x{$hex} in \\V";
        }
    }


    {
        # . with /s should work on characters, as opposed to bytes
        local $Message = ". with /s works on characters, not bytes";

        my $s = "\x{e4}\x{100}";
        # This is not expected to match: the point is that
        # neither should we get "Malformed UTF-8" warnings.
        may_not_warn sub {$s =~ /\G(.+?)\n/gcs}, "No 'Malformed UTF-8' warning";

        my @@c;
        push @@c => $1 while $s =~ /\G(.)/gs;

        local $" = "";
        iseq "@@c", $s;

        # Test only chars < 256
        my $t1 = "Q003\n\n\x{e4}\x{f6}\n\nQ004\n\n\x{e7}";
        my $r1 = "";
        while ($t1 =~ / \G ( .+? ) \n\s+ ( .+? ) ( $ | \n\s+ ) /xgcs) {
	    $r1 .= $1 . $2;
        }

        my $t2 = $t1 . "\x{100}"; # Repeat with a larger char
        my $r2 = "";
        while ($t2 =~ / \G ( .+? ) \n\s+ ( .+? ) ( $ | \n\s+ ) /xgcs) {
	    $r2 .= $1 . $2;
        }
        $r2 =~ s/\x{100}//;

        iseq $r1, $r2;
    }


    {
        local $Message = "Unicode lookbehind";
        ok "A\x{100}B"        =~ /(?<=A.)B/;
        ok "A\x{200}\x{300}B" =~ /(?<=A..)B/;
        ok "\x{400}AB"        =~ /(?<=\x{400}.)B/;
        ok "\x{500}\x{600}B"  =~ /(?<=\x{500}.)B/;

        # Original code also contained:
        # ok "\x{500\x{600}}B"  =~ /(?<=\x{500}.)B/;
        # but that looks like a typo.
    }


    {
        local $Message = 'UTF-8 hash keys and /$/';
        # http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters
        #                                         /2002-01/msg01327.html

        my $u = "a\x{100}";
        my $v = substr ($u, 0, 1);
        my $w = substr ($u, 1, 1);
        my %u = ($u => $u, $v => $v, $w => $w);
        for (keys %u) {
            my $m1 =            /^\w*$/ ? 1 : 0;
            my $m2 = $u {$_} =~ /^\w*$/ ? 1 : 0;
            iseq $m1, $m2;
        }
    }


    {
        local $BugId   = "20020124.005";
        local $PatchId = "14795";
        local $Message = "s///eg";

        for my $char ("a", "\x{df}", "\x{100}") {
            my $x = "$char b $char";
            $x =~ s{($char)}{
                  "c" =~ /c/;
                  "x";
            }ge;
            iseq substr ($x, 0, 1), substr ($x, -1, 1);
        }
    }


    {
        local $Message = "No SEGV in s/// and UTF-8";
        my $s = "s#\x{100}" x 4;
        ok $s =~ s/[^\w]/ /g;
        if ($ENV {REAL_POSIX_CC}) {
            iseq $s, "s  " x 4;
        }
        else {
            iseq $s, "s \x{100}" x 4;
        }
    }


    {
        local $Message = "UTF-8 bug (maybe already known?)";
        my $u = "foo";
        $u =~ s/./\x{100}/g;
        iseq $u, "\x{100}\x{100}\x{100}";

        $u = "foobar";
        $u =~ s/[ao]/\x{100}/g;
        iseq $u, "f\x{100}\x{100}b\x{100}r";

        $u =~ s/\x{100}/e/g;
        iseq $u, "feeber";
    }


    {
        local $Message = "UTF-8 bug with s///";
        # check utf8/non-utf8 mixtures
        # try to force all float/anchored check combinations

        my $c = "\x{100}";
        my $subst;
        for my $re ("xx.*$c", "x.*$c$c", "$c.*xx", "$c$c.*x",
                    "xx.*(?=$c)", "(?=$c).*xx",) {
            ok "xxx" !~ /$re/;
            ok +($subst = "xxx") !~ s/$re//;
        }
        for my $re ("xx.*$c*", "$c*.*xx") {
            ok "xxx" =~ /$re/;
            ok +($subst = "xxx") =~ s/$re//;
            iseq $subst, "";
        }
        for my $re ("xxy*", "y*xx") {
            ok "xx$c" =~ /$re/;
            ok +($subst = "xx$c") =~ s/$re//;
            iseq $subst, $c;
            ok "xy$c" !~ /$re/;
            ok +($subst = "xy$c") !~ s/$re//;
        }
        for my $re ("xy$c*z", "x$c*yz") {
            ok "xyz" =~ /$re/;
            ok +($subst = "xyz") =~ s/$re//;
            iseq $subst, "";
        }
    }


    {
        local $Message = "qr /.../x";
        my $R = qr / A B C # D E/x;
        ok "ABCDE" =~    $R   && $& eq "ABC";
        ok "ABCDE" =~   /$R/  && $& eq "ABC";
        ok "ABCDE" =~  m/$R/  && $& eq "ABC";
        ok "ABCDE" =~  /($R)/ && $1 eq "ABC";
        ok "ABCDE" =~ m/($R)/ && $1 eq "ABC";
    }


    {
        local $BugId = "20020412.005";
        local $Message = "Correct pmop flags checked when empty pattern";

        # Requires reuse of last successful pattern.
        my $num = 123;
        $num =~ /\d/;
        for (0 .. 1) {
            my $match = ?? + 0;
            ok $match != $_, $Message, 
                sprintf "'match one' %s on %s iteration" =>
                               $match ? 'succeeded' : 'failed',
                               $_     ? 'second'    : 'first';
        }
        $num =~ /(\d)/;
        my $result = join "" => $num =~ //g;
        iseq $result, $num;
    }


    {
        local $BugId   = '20020630.002';
        local $Message = 'UTF-8 regex matches above 32k';
        for (['byte', "\x{ff}"], ['utf8', "\x{1ff}"]) {
            my ($type, $char) = @@$_;
            for my $len (32000, 32768, 33000) {
                my  $s = $char . "f" x $len;
                my  $r = $s =~ /$char([f]*)/gc;
                ok  $r, $Message, "<$type x $len>";
                ok !$r || pos ($s) == $len + 1, $Message,
                        "<$type x $len>; pos = @@{[pos $s]}";
            }
        }
    }


    {
        our $a = bless qr /foo/ => 'Foo';
        ok 'goodfood' =~ $a,     "Reblessed qr // matches";
        iseq $a, '(?-xism:foo)', "Reblessed qr // stringifies";
        my $x = "\x{3fe}";
        my $z = my $y = "\317\276";  # Byte representation of $x
        $a = qr /$x/;
        ok $x =~ $a, "UTF-8 interpolation in qr //";
        ok "a$a" =~ $x, "Stringified qr // preserves UTF-8";
        ok "a$x" =~ /^a$a\z/, "Interpolated qr // preserves UTF-8";
        ok "a$x" =~ /^a(??{$a})\z/,
                        "Postponed interpolation of qr // preserves UTF-8";
        {
            local $BugId = '17776';
            iseq length qr /##/x, 12, "## in qr // doesn't corrupt memory";
        }
        {
            use re 'eval';
            ok "$x$x" =~ /^$x(??{$x})\z/,
               "Postponed UTF-8 string in UTF-8 re matches UTF-8";
            ok "$y$x" =~ /^$y(??{$x})\z/, 
               "Postponed UTF-8 string in non-UTF-8 re matches UTF-8";
            ok "$y$x" !~ /^$y(??{$y})\z/,
               "Postponed non-UTF-8 string in non-UTF-8 re doesn't match UTF-8";
            ok "$x$x" !~ /^$x(??{$y})\z/,
               "Postponed non-UTF-8 string in UTF-8 re doesn't match UTF-8";
            ok "$y$y" =~ /^$y(??{$y})\z/,
               "Postponed non-UTF-8 string in non-UTF-8 re matches non-UTF8";
            ok "$x$y" =~ /^$x(??{$y})\z/,
               "Postponed non-UTF-8 string in UTF-8 re matches non-UTF8";

            $y = $z;  # Reset $y after upgrade.
            ok "$x$y" !~ /^$x(??{$x})\z/,
               "Postponed UTF-8 string in UTF-8 re doesn't match non-UTF-8";
            ok "$y$y" !~ /^$y(??{$x})\z/,
               "Postponed UTF-8 string in non-UTF-8 re doesn't match non-UTF-8";
        }
    }


    {
        local $PatchId = '18179';
        my $s = "\x{100}" x 5;
        my $ok = $s =~ /(\x{100}{4})/;
        my ($ord, $len) = (ord $1, length $1);
        ok $ok && $ord == 0x100 && $len == 4, "No panic: end_shift";
    }


    {
        local $BugId = '15763';
        our $a = "x\x{100}";
        chop $a;    # Leaves the UTF-8 flag
        $a .= "y";  # 1 byte before 'y'.

        ok $a =~ /^\C/,        'match one \C on 1-byte UTF-8';
        ok $a =~ /^\C{1}/,     'match \C{1}';

        ok $a =~ /^\Cy/,       'match \Cy';
        ok $a =~ /^\C{1}y/,    'match \C{1}y';

        ok $a !~ /^\C\Cy/,     q {don't match two \Cy};
        ok $a !~ /^\C{2}y/,    q {don't match \C{2}y};

        $a = "\x{100}y"; # 2 bytes before "y"

        ok $a =~ /^\C/,        'match one \C on 2-byte UTF-8';
        ok $a =~ /^\C{1}/,     'match \C{1}';
        ok $a =~ /^\C\C/,      'match two \C';
        ok $a =~ /^\C{2}/,     'match \C{2}';

        ok $a =~ /^\C\C\C/,    'match three \C on 2-byte UTF-8 and a byte';
        ok $a =~ /^\C{3}/,     'match \C{3}';

        ok $a =~ /^\C\Cy/,     'match two \C';
        ok $a =~ /^\C{2}y/,    'match \C{2}';

        ok $a !~ /^\C\C\Cy/,   q {don't match three \Cy};
        ok $a !~ /^\C{2}\Cy/,  q {don't match \C{2}\Cy};
        ok $a !~ /^\C{3}y/,    q {don't match \C{3}y};

        $a = "\x{1000}y"; # 3 bytes before "y"

        ok $a =~ /^\C/,        'match one \C on three-byte UTF-8';
        ok $a =~ /^\C{1}/,     'match \C{1}';
        ok $a =~ /^\C\C/,      'match two \C';
        ok $a =~ /^\C{2}/,     'match \C{2}';
        ok $a =~ /^\C\C\C/,    'match three \C';
        ok $a =~ /^\C{3}/,     'match \C{3}';

        ok $a =~ /^\C\C\C\C/,  'match four \C on three-byte UTF-8 and a byte';
        ok $a =~ /^\C{4}/,     'match \C{4}';

        ok $a =~ /^\C\C\Cy/,   'match three \Cy';
        ok $a =~ /^\C{3}y/,    'match \C{3}y';

        ok $a !~ /^\C\C\C\Cy/, q {don't match four \Cy};
        ok $a !~ /^\C{4}y/,    q {don't match \C{4}y};
    }

    
    {
        local $\;
        $_ = 'aaaaaaaaaa';
        utf8::upgrade($_); chop $_; $\="\n";
        ok /[^\s]+/, 'm/[^\s]/ utf8';
        ok /[^\d]+/, 'm/[^\d]/ utf8';
        ok +($a = $_, $_ =~ s/[^\s]+/./g), 's/[^\s]/ utf8';
        ok +($a = $_, $a =~ s/[^\d]+/./g), 's/[^\s]/ utf8';
    }


    {
        local $BugId   = '15397';
        local $Message = 'UTF-8 matching';
        ok "\x{100}" =~ /\x{100}/;
        ok "\x{100}" =~ /(\x{100})/;
        ok "\x{100}" =~ /(\x{100}){1}/;
        ok "\x{100}\x{100}" =~ /(\x{100}){2}/;
        ok "\x{100}\x{100}" =~ /(\x{100})(\x{100})/;
    }


    {
        local $BugId   = '7471';
        local $Message = 'Neither ()* nor ()*? sets $1 when matched 0 times';
        local $_       = 'CD';
        ok /(AB)*?CD/ && !defined $1;
        ok /(AB)*CD/  && !defined $1;
    }


    {
        local $BugId   = '3547';
        local $Message = "Caching shouldn't prevent match";
        my $pattern = "^(b+?|a){1,2}c";
        ok "bac"    =~ /$pattern/ && $1 eq 'a';
        ok "bbac"   =~ /$pattern/ && $1 eq 'a';
        ok "bbbac"  =~ /$pattern/ && $1 eq 'a';
        ok "bbbbac" =~ /$pattern/ && $1 eq 'a';
    }



    {
        local $BugId   = '18232';
        local $Message = '$1 should keep UTF-8 ness';
        ok "\x{100}" =~ /(.)/;
        iseq  $1, "\x{100}",  '$1 is UTF-8';
        { 'a' =~ /./; }
        iseq  $1, "\x{100}",  '$1 is still UTF-8';
        isneq $1, "\xC4\x80", '$1 is not non-UTF-8';
    }


    {
        local $BugId   = '19767';
        local $Message = "Optimizer doesn't prematurely reject match";
        use utf8;

        my $attr = 'Name-1';
        my $NormalChar      = qr /[\p{IsDigit}\p{IsLower}\p{IsUpper}]/;
        my $NormalWord      = qr /${NormalChar}+?/;
        my $PredNameHyphen  = qr /^${NormalWord}(\-${NormalWord})*?$/;

        $attr =~ /^$/;
        ok $attr =~ $PredNameHyphen;  # Original test.

        "a" =~ m/[b]/;
        ok "0" =~ /\p{N}+\z/;         # Variant.
    }


    {
        local $BugId   = '20683';
        local $Message = "(??{ }) doesn't return stale values";
        our $p = 1;
        foreach (1, 2, 3, 4) {
            $p ++ if /(??{ $p })/
        }
        iseq $p, 5;

        {
            package P;
            $a = 1;
            sub TIESCALAR {bless []}
            sub FETCH     {$a ++}
        }
        tie $p, "P";
        foreach (1, 2, 3, 4) {
            /(??{ $p })/
        }
        iseq $p, 5;
    }


    {
        # Subject: Odd regexp behavior
        # From: Markus Kuhn <Markus.Kuhn@@cl.cam.ac.uk>
        # Date: Wed, 26 Feb 2003 16:53:12 +0000
        # Message-Id: <E18o4nw-0008Ly-00@@wisbech.cl.cam.ac.uk>
        # To: perl-unicode@@perl.org

        local $Message = 'Markus Kuhn 2003-02-26';
    
        my $x = "\x{2019}\nk";
        ok $x =~ s/(\S)\n(\S)/$1 $2/sg;
        ok $x eq "\x{2019} k";

        $x = "b\nk";
        ok $x =~ s/(\S)\n(\S)/$1 $2/sg;
        ok $x eq "b k";

        ok "\x{2019}" =~ /\S/;
    }


    {
        local $BugId = '21411';
        local $Message = "(??{ .. }) in split doesn't corrupt its stack";
        our $i;
        ok '-1-3-5-' eq join '', split /((??{$i++}))/, '-1-3-5-';
        no warnings 'deprecated', 'syntax';
        split /(?{'WOW'})/, 'abc';
        local $" = "|";
        iseq "@@_", "a|b|c";
    }


    {
        # XXX DAPM 13-Apr-06. Recursive split is still broken. It's only luck it
        # hasn't been crashing. Disable this test until it is fixed properly.
        # XXX also check what it returns rather than just doing ok(1,...)
        # split /(?{ split "" })/, "abc";
        local $TODO = "Recursive split is still broken";
        ok 0, 'cache_re & "(?{": it dumps core in 5.6.1 & 5.8.0';
    }


    {
        ok "\x{100}\n" =~ /\x{100}\n$/, "UTF-8 length cache and fbm_compile";
    }


    {
        package Str;
        use overload q /""/ => sub {${$_ [0]};};
        sub new {my ($c, $v) = @@_; bless \$v, $c;}

        package main;
        $_ = Str -> new ("a\x{100}/\x{100}b");
        ok join (":", /\b(.)\x{100}/g) eq "a:/", "re_intuit_start and PL_bostr";
    }


    {
        local $BugId = '17757';
        $_ = "code:   'x' { '...' }\n"; study;
        my @@x; push @@x, $& while m/'[^\']*'/gx;
        local $" = ":";
        iseq "@@x", "'x':'...'", "Parse::RecDescent triggered infinite loop";
    }


    {
        my $re = qq /^([^X]*)X/;
        utf8::upgrade ($re);
        ok "\x{100}X" =~ /$re/, "S_cl_and ANYOF_UNICODE & ANYOF_INVERTED";
    }


    {
        local $BugId = '22354';
        sub func ($) {
            ok "a\nb" !~ /^b/,  "Propagated modifier; $_[0]";
            ok "a\nb" =~ /^b/m, "Propagated modifier; $_[0] - with /m";
        }
        func "standalone";
        $_ = "x"; s/x/func "in subst"/e;
        $_ = "x"; s/x/func "in multiline subst"/em;

        #
        # Next two give 'panic: malloc'.
        # Outcommented, using two TODOs.
        #
        local $TODO    = 'panic: malloc';
        local $Message = 'Postponed regexp and propaged modifier';
      # ok 0 for 1 .. 2;
      SKIP: {
            skip "panic: malloc", 2;
            $_ = "x"; /x(?{func "in regexp"})/;
            $_ = "x"; /x(?{func "in multiline regexp"})/m;
        }
    }


    {
        local $BugId = '19049';
        $_    = "abcdef\n";
        my @@x = m/./g;
        iseq "abcde", $`, 'Global match sets $`';
    }


    {
        ok "123\x{100}" =~ /^.*1.*23\x{100}$/,
           'UTF-8 + multiple floating substr';
    }


    {
        local $Message = '<20030808193656.5109.1@@llama.ni-s.u-net.com>';

        # LATIN SMALL/CAPITAL LETTER A WITH MACRON
        ok "  \x{101}" =~ qr/\x{100}/i;

        # LATIN SMALL/CAPITAL LETTER A WITH RING BELOW
        ok "  \x{1E01}" =~ qr/\x{1E00}/i;

        # DESERET SMALL/CAPITAL LETTER LONG I
        ok "  \x{10428}" =~ qr/\x{10400}/i;

        # LATIN SMALL/CAPITAL LETTER A WITH RING BELOW + 'X'
        ok "  \x{1E01}x" =~ qr/\x{1E00}X/i;
    }


    {
        # [perl #23769] Unicode regex broken on simple example
        # regrepeat() didn't handle UTF-8 EXACT case right.
        local $BugId   = '23769';
        my $Mess       = 'regrepeat() handles UTF-8 EXACT case right';
        local $Message = $Mess;

        my $s = "\x{a0}\x{a0}\x{a0}\x{100}"; chop $s;

        ok $s =~ /\x{a0}/;
        ok $s =~ /\x{a0}+/;
        ok $s =~ /\x{a0}\x{a0}/;

        $Message = "$Mess (easy variant)";
        ok "aaa\x{100}" =~ /(a+)/;
        iseq $1, "aaa";

        $Message = "$Mess (easy invariant)";
        ok "aaa\x{100}     " =~ /(a+?)/;
        iseq $1, "a";

        $Message = "$Mess (regrepeat variant)";
        ok "\xa0\xa0\xa0\x{100}    " =~ /(\xa0+?)/;
        iseq $1, "\xa0";

        $Message = "$Mess (regrepeat invariant)";
        ok "\xa0\xa0\xa0\x{100}" =~ /(\xa0+)/;
        iseq $1, "\xa0\xa0\xa0";

        $Message = "$Mess (hard variant)";
        ok "\xa0\xa1\xa0\xa1\xa0\xa1\x{100}" =~ /((?:\xa0\xa1)+?)/;
        iseq $1, "\xa0\xa1";

        $Message = "$Mess (hard invariant)";
        ok "ababab\x{100}  " =~ /((?:ab)+)/;
        iseq $1, 'ababab';

        ok "\xa0\xa1\xa0\xa1\xa0\xa1\x{100}" =~ /((?:\xa0\xa1)+)/;
        iseq $1, "\xa0\xa1\xa0\xa1\xa0\xa1";

        ok "ababab\x{100}  " =~ /((?:ab)+?)/;
        iseq $1, "ab";

        $Message = "Don't match first byte of UTF-8 representation";
        ok "\xc4\xc4\xc4" !~ /(\x{100}+)/;
        ok "\xc4\xc4\xc4" !~ /(\x{100}+?)/;
        ok "\xc4\xc4\xc4" !~ /(\x{100}++)/;
    }


    {
        for (120 .. 130) {
            my $head = 'x' x $_;
            local $Message = q [Don't misparse \x{...} in regexp ] .
                             q [near 127 char EXACT limit];
            for my $tail ('\x{0061}', '\x{1234}', '\x61') {
                eval_ok qq ["$head$tail" =~ /$head$tail/];
            }
            local $Message = q [Don't misparse \N{...} in regexp ] .
                             q [near 127 char EXACT limit];
            for my $tail ('\N{SNOWFLAKE}') {
                eval_ok qq [use charnames ':full';
                           "$head$tail" =~ /$head$tail/];
            }
        }
    }


    {
        # perl panic: pp_match start/end pointers
        local $BugId = '25269';
        iseq "a-bc", eval {my ($x, $y) = "bca" =~ /^(?=.*(a)).*(bc)/; "$x-$y"},
             'Captures can move backwards in string';
    }


    {
        local $BugId   = '27940'; # \cA not recognized in character classes
        ok "a\cAb" =~ /\cA/, '\cA in pattern';
        ok "a\cAb" =~ /[\cA]/, '\cA in character class';
        ok "a\cAb" =~ /[\cA-\cB]/, '\cA in character class range';
        ok "abc" =~ /[^\cA-\cB]/, '\cA in negated character class range';
        ok "a\cBb" =~ /[\cA-\cC]/, '\cB in character class range';
        ok "a\cCbc" =~ /[^\cA-\cB]/, '\cC in negated character class range';
        ok "a\cAb" =~ /(??{"\cA"})/, '\cA in ??{} pattern';
        ok "ab" !~ /a\cIb/x, '\cI in pattern';
    }


    {
        # perl #28532: optional zero-width match at end of string is ignored
        local $BugId = '28532';
        ok "abc" =~ /^abc(\z)?/ && defined($1),
           'Optional zero-width match at end of string';
        ok "abc" =~ /^abc(\z)??/ && !defined($1),
           'Optional zero-width match at end of string';
    }



    {   # TRIE related
        our @@got = ();
        "words" =~ /(word|word|word)(?{push @@got, $1})s$/;
        iseq @@got, 1, "TRIE optimation";

        @@got = ();
        "words" =~ /(word|word|word)(?{push @@got,$1})s$/i;
        iseq @@got, 1,"TRIEF optimisation";

        my @@nums = map {int rand 1000} 1 .. 100;
        my $re = "(" . (join "|", @@nums) . ")";
        $re = qr/\b$re\b/;

        foreach (@@nums) {
            ok $_ =~ /$re/, "Trie nums";
        }

        $_ = join " ", @@nums;
        @@got = ();
        push @@got, $1 while /$re/g;

        my %count;
        $count {$_} ++ for @@got;
        my $ok = 1;
        for (@@nums) {
            $ok = 0 if --$count {$_} < 0;
        }
        ok $ok, "Trie min count matches";
    }


    {
        # TRIE related
        # LATIN SMALL/CAPITAL LETTER A WITH MACRON
        ok "foba  \x{101}foo" =~ qr/(foo|\x{100}foo|bar)/i &&
           $1 eq "\x{101}foo",
           "TRIEF + LATIN SMALL/CAPITAL LETTER A WITH MACRON";

        # LATIN SMALL/CAPITAL LETTER A WITH RING BELOW
        ok "foba  \x{1E01}foo" =~ qr/(foo|\x{1E00}foo|bar)/i &&
           $1 eq "\x{1E01}foo",
           "TRIEF + LATIN SMALL/CAPITAL LETTER A WITH RING BELOW";

        # DESERET SMALL/CAPITAL LETTER LONG I
        ok "foba  \x{10428}foo" =~ qr/(foo|\x{10400}foo|bar)/i &&
           $1 eq "\x{10428}foo",
           "TRIEF + DESERET SMALL/CAPITAL LETTER LONG I";

        # LATIN SMALL/CAPITAL LETTER A WITH RING BELOW + 'X'
        ok "foba  \x{1E01}xfoo" =~ qr/(foo|\x{1E00}Xfoo|bar)/i &&
           $1 eq "\x{1E01}xfoo",
           "TRIEF + LATIN SMALL/CAPITAL LETTER A WITH RING BELOW + 'X'";

        use charnames ':full';

        my $s = "\N{LATIN SMALL LETTER SHARP S}";
        ok "foba  ba$s" =~ qr/(foo|Ba$s|bar)/i &&  $1 eq "ba$s",
           "TRIEF + LATIN SMALL LETTER SHARP S =~ ss";
        ok "foba  ba$s" =~ qr/(Ba$s|foo|bar)/i &&  $1 eq "ba$s",
           "TRIEF + LATIN SMALL LETTER SHARP S =~ ss";
        ok "foba  ba$s" =~ qr/(foo|bar|Ba$s)/i &&  $1 eq "ba$s",
           "TRIEF + LATIN SMALL LETTER SHARP S =~ ss";

        ok "foba  ba$s" =~ qr/(foo|Bass|bar)/i &&  $1 eq "ba$s",
           "TRIEF + LATIN SMALL LETTER SHARP S =~ ss";

        ok "foba  ba$s" =~ qr/(foo|BaSS|bar)/i &&  $1 eq "ba$s",
           "TRIEF + LATIN SMALL LETTER SHARP S =~ SS";

        ok "foba  ba${s}pxySS$s$s" =~ qr/(b(?:a${s}t|a${s}f|a${s}p)[xy]+$s*)/i
            &&  $1 eq "ba${s}pxySS$s$s",
           "COMMON PREFIX TRIEF + LATIN SMALL LETTER SHARP S";
    }


  SKIP:
    {
        print "# Set PERL_SKIP_PSYCHO_TEST to skip this test\n";
        my @@normal = qw [the are some normal words];

        skip "Skipped Psycho", 2 * @@normal if $ENV {PERL_SKIP_PSYCHO_TEST};

        local $" = "|";

        my @@psycho = (@@normal, map chr $_, 255 .. 20000);
        my $psycho1 = "@@psycho";
        for (my $i = @@psycho; -- $i;) {
            my $j = int rand (1 + $i);
            @@psycho [$i, $j] = @@psycho [$j, $i];
        }
        my $psycho2 = "@@psycho";

        foreach my $word (@@normal) {
            ok $word =~ /($psycho1)/ && $1 eq $word, 'Psycho';
            ok $word =~ /($psycho2)/ && $1 eq $word, 'Psycho';
        }
    }


    {
        local $BugId = '36207';
        my $utf8 = "\xe9\x{100}"; chop $utf8;
        my $latin1 = "\xe9";

        ok $utf8 =~ /\xe9/i, "utf8/latin";
        ok $utf8 =~ /$latin1/i, "utf8/latin runtime";
        ok $utf8 =~ /(abc|\xe9)/i, "utf8/latin trie";
        ok $utf8 =~ /(abc|$latin1)/i, "utf8/latin trie runtime";

        ok "\xe9" =~ /$utf8/i, "latin/utf8";
        ok "\xe9" =~ /(abc|$utf8)/i, "latin/utf8 trie";
        ok $latin1 =~ /$utf8/i, "latin/utf8 runtime";
        ok $latin1 =~ /(abc|$utf8)/i, "latin/utf8 trie runtime";
    }


    {
        local $BugId = '37038';
        my $s = "abcd";
        $s =~ /(..)(..)/g;
        $s = $1;
        $s = $2;
        iseq $2, 'cd',
             "Assigning to original string does not corrupt match vars";
    }


    {
        {
            package wooosh;
            sub gloople {"!"}
        }
        my $aeek = bless {} => 'wooosh';
        eval_ok sub {$aeek -> gloople () =~ /(.)/g},
               "//g match against return value of sub";

        sub gloople {"!"}
        eval_ok sub {gloople () =~ /(.)/g},
               "26410 didn't affect sub calls for some reason";
    }


    {
        local $TODO = "See changes 26925-26928, which reverted change 26410";
        {
            package lv;
            our $var = "abc";
            sub variable : lvalue {$var}
        }
        my $o = bless [] => 'lv';
        my $f = "";
        my $r = eval {
            for (1 .. 2) {
                $f .= $1 if $o -> variable =~ /(.)/g;
            }
            1;
        };
        if ($r) {
            iseq $f, "ab", "pos() retained between calls";
        }
        else {
            local $TODO;
            ok 0, "Code failed: $@@";
        }

        our $var = "abc";
        sub variable : lvalue {$var}
        my $g = "";
        my $s = eval {
            for (1 .. 2) {
                $g .= $1 if variable =~ /(.)/g;
            }
            1;
        };
        if ($s) {
            iseq $g, "ab", "pos() retained between calls";
        }
        else {
            local $TODO;
            ok 0, "Code failed: $@@";
        }
    }


  SKIP:
    {
        local $BugId = '37836';
        skip "In EBCDIC" if $IS_EBCDIC;
        no warnings 'utf8';
        $_ = pack 'U0C2', 0xa2, 0xf8;  # Ill-formed UTF-8
        my $ret = 0;
        eval_ok sub {!($ret = s/[\0]+//g)},
                "Ill-formed UTF-8 doesn't match NUL in class";
    }


    {
        # chr(65535) should be allowed in regexes
        local $BugId = '38293';
        no warnings 'utf8'; # To allow non-characters
        my ($c, $r, $s);

        $c = chr 0xffff;
        $c =~ s/$c//g;
        ok $c eq "", "U+FFFF, parsed as atom";

        $c = chr 0xffff;
        $r = "\\$c";
        $c =~ s/$r//g;
        ok $c eq "", "U+FFFF backslashed, parsed as atom";

        $c = chr 0xffff;
        $c =~ s/[$c]//g;
        ok $c eq "", "U+FFFF, parsed in class";

        $c = chr 0xffff;
        $r = "[\\$c]";
        $c =~ s/$r//g;
        ok $c eq "", "U+FFFF backslashed, parsed in class";

        $s = "A\x{ffff}B";
        $s =~ s/\x{ffff}//i;
        ok $s eq "AB", "U+FFFF, EXACTF";

        $s = "\x{ffff}A";
        $s =~ s/\bA//;
        ok $s eq "\x{ffff}", "U+FFFF, BOUND";

        $s = "\x{ffff}!";
        $s =~ s/\B!//;
        ok $s eq "\x{ffff}", "U+FFFF, NBOUND";
    }


    {
        local $BugId = '39583';
        
        # The printing characters
        my @@chars = ("A" .. "Z");
        my $delim = ",";
        my $size = 32771 - 4;
        my $str = '';

        # Create some random junk. Inefficient, but it works.
        for (my $i = 0; $i < $size; $ i++) {
            $str .= $chars [rand @@chars];
        }

        $str .= ($delim x 4);
        my $res;
        my $matched;
        ok $str =~ s/^(.*?)${delim}{4}//s, "Pattern matches";
        iseq $str, "", "Empty string";
        ok defined $1 && length ($1) == $size, '$1 is correct size';
    }


    {
        local $BugId = '27940';
        ok "\0-A"  =~ /\c@@-A/, '@@- should not be interpolated in a pattern';
        ok "\0\0A" =~ /\c@@+A/, '@@+ should not be interpolated in a pattern';
        ok "X\@@-A"  =~ /X@@-A/, '@@- should not be interpolated in a pattern';
        ok "X\@@\@@A" =~ /X@@+A/, '@@+ should not be interpolated in a pattern';

        ok "X\0A" =~ /X\c@@?A/,  '\c@@?';
        ok "X\0A" =~ /X\c@@*A/,  '\c@@*';
        ok "X\0A" =~ /X\c@@(A)/, '\c@@(';
        ok "X\0A" =~ /X(\c@@)A/, '\c@@)';
        ok "X\0A" =~ /X\c@@|ZA/, '\c@@|';

        ok "X\@@A" =~ /X@@?A/,  '@@?';
        ok "X\@@A" =~ /X@@*A/,  '@@*';
        ok "X\@@A" =~ /X@@(A)/, '@@(';
        ok "X\@@A" =~ /X(@@)A/, '@@)';
        ok "X\@@A" =~ /X@@|ZA/, '@@|';

        local $" = ','; # non-whitespace and non-RE-specific
        ok 'abc' =~ /(.)(.)(.)/, 'The last successful match is bogus';
        ok "A@@+B"  =~ /A@@{+}B/,  'Interpolation of @@+ in /@@{+}/';
        ok "A@@-B"  =~ /A@@{-}B/,  'Interpolation of @@- in /@@{-}/';
        ok "A@@+B"  =~ /A@@{+}B/x, 'Interpolation of @@+ in /@@{+}/x';
        ok "A@@-B"  =~ /A@@{-}B/x, 'Interpolation of @@- in /@@{-}/x';
    }


    {
        use lib 'lib';
        use Cname;
        
        ok 'fooB'  =~ /\N{foo}[\N{B}\N{b}]/, "Passthrough charname";
        my $test   = 1233;
        #
        # Why doesn't must_warn work here?
        #
        my $w;
        local $SIG {__WARN__} = sub {$w .= "@@_"};
        eval 'q(xxWxx) =~ /[\N{WARN}]/';
        ok $w && $w =~ /^Ignoring excess chars from/,
                 "Ignoring excess chars warning";

        undef $w;
        eval q [ok "\0" !~ /[\N{EMPTY-STR}XY]/,
                   "Zerolength charname in charclass doesn't match \\0"];
        ok $w && $w =~ /^Ignoring zero length/,
                 'Ignoring zero length \N{%} in character class warning';

        ok 'AB'  =~ /(\N{EVIL})/ && $1 eq 'A', 'Charname caching $1';
        ok 'ABC' =~ /(\N{EVIL})/,              'Charname caching $1';
        ok 'xy'  =~ /x\N{EMPTY-STR}y/,
                    'Empty string charname produces NOTHING node';
        ok ''    =~ /\N{EMPTY-STR}/,
                    'Empty string charname produces NOTHING node';
            
    }


    {
        use charnames ':full';

        ok 'aabc' !~ /a\N{PLUS SIGN}b/, '/a\N{PLUS SIGN}b/ against aabc';
        ok 'a+bc' =~ /a\N{PLUS SIGN}b/, '/a\N{PLUS SIGN}b/ against a+bc';

        ok ' A B' =~ /\N{SPACE}\N{U+0041}\N{SPACE}\N{U+0042}/,
            'Intermixed named and unicode escapes';
        ok "\N{SPACE}\N{U+0041}\N{SPACE}\N{U+0042}" =~
           /\N{SPACE}\N{U+0041}\N{SPACE}\N{U+0042}/,
            'Intermixed named and unicode escapes';
        ok "\N{SPACE}\N{U+0041}\N{SPACE}\N{U+0042}" =~
           /[\N{SPACE}\N{U+0041}][\N{SPACE}\N{U+0042}]/,
            'Intermixed named and unicode escapes';     
    }


    {
        our $brackets;
        $brackets = qr{
            {  (?> [^{}]+ | (??{ $brackets }) )* }
        }x;

        ok "{b{c}d" !~ m/^((??{ $brackets }))/, "Bracket mismatch";

        SKIP: {
            our @@stack = ();
            my @@expect = qw(
                stuff1
                stuff2
                <stuff1>and<stuff2>
                right
                <right>
                <<right>>
                <<<right>>>
                <<stuff1>and<stuff2>><<<<right>>>>
            );

            local $_ = '<<<stuff1>and<stuff2>><<<<right>>>>>';
            ok /^(<((?:(?>[^<>]+)|(?1))*)>(?{push @@stack, $2 }))$/,
                "Recursion matches";
            iseq @@stack, @@expect, "Right amount of matches"
                 or skip "Won't test individual results as count isn't equal",
                          0 + @@expect;
            my $idx = 0;
            foreach my $expect (@@expect) {
                iseq $stack [$idx], $expect,
                    "Expecting '$expect' at stack pos #$idx";
                $idx ++;
            }
        }
    }


    {
        my $s = '123453456';
        $s =~ s/(?<digits>\d+)\k<digits>/$+{digits}/;
        ok $s eq '123456', 'Named capture (angle brackets) s///';
        $s = '123453456';
        $s =~ s/(?'digits'\d+)\k'digits'/$+{digits}/;
        ok $s eq '123456', 'Named capture (single quotes) s///';    
    }


    {
        my @@ary = (
            pack('U', 0x00F1),            # n-tilde
            '_'.pack('U', 0x00F1),        # _ + n-tilde
            'c'.pack('U', 0x0327),        # c + cedilla
            pack('U*', 0x00F1, 0x0327),   # n-tilde + cedilla
            'a'.pack('U', 0x00B2),        # a + superscript two
            pack('U', 0x0391),            # ALPHA
            pack('U', 0x0391).'2',        # ALPHA + 2
            pack('U', 0x0391).'_',        # ALPHA + _
        );

        for my $uni (@@ary) {
            my ($r1, $c1, $r2, $c2) = eval qq {
                use utf8;
                scalar ("..foo foo.." =~ /(?'${uni}'foo) \\k'${uni}'/),
                        \$+{${uni}},
                scalar ("..bar bar.." =~ /(?<${uni}>bar) \\k<${uni}>/),
                        \$+{${uni}};
            };
            ok $r1,                         "Named capture UTF (?'')";
            ok defined $c1 && $c1 eq 'foo', "Named capture UTF \%+";
            ok $r2,                         "Named capture UTF (?<>)";
            ok defined $c2 && $c2 eq 'bar', "Named capture UTF \%+";
        }
    }


    {
        my $s = 'foo bar baz';
        my (@@k, @@v, @@fetch, $res);
        my $count = 0;
        my @@names = qw ($+{A} $+{B} $+{C});
        if ($s =~ /(?<A>foo)\s+(?<B>bar)?\s+(?<C>baz)/) {
            while (my ($k, $v) = each (%+)) {
                $count++;
            }
            @@k = sort keys   (%+);
            @@v = sort values (%+);
            $res = 1;
            push @@fetch,
                ["$+{A}", "$1"],
                ["$+{B}", "$2"],
                ["$+{C}", "$3"],
            ;
        } 
        foreach (0 .. 2) {
            if ($fetch [$_]) {
                iseq $fetch [$_] [0], $fetch [$_] [1], $names [$_];
            } else {
                ok 0, $names[$_];
            }
        }
        iseq $res, 1, "'$s' =~ /(?<A>foo)\\s+(?<B>bar)?\\s+(?<C>baz)/";
        iseq $count, 3, "Got 3 keys in %+ via each";
        iseq 0 + @@k, 3, 'Got 3 keys in %+ via keys';
        iseq "@@k", "A B C", "Got expected keys";
        iseq "@@v", "bar baz foo", "Got expected values";
        eval '
            no warnings "uninitialized";
            print for $+ {this_key_doesnt_exist};
        ';
        ok !$@@, 'lvalue $+ {...} should not throw an exception';
    }


    {
        #
        # Almost the same as the block above, except that the capture is nested.
        #
        local $BugId = '50496';
        my $s = 'foo bar baz';
        my (@@k, @@v, @@fetch, $res);
        my $count = 0;
        my @@names = qw ($+{A} $+{B} $+{C} $+{D});
        if ($s =~ /(?<D>(?<A>foo)\s+(?<B>bar)?\s+(?<C>baz))/) {
            while (my ($k,$v) = each(%+)) {
                $count++;
            }
            @@k = sort keys   (%+);
            @@v = sort values (%+);
            $res = 1;
            push @@fetch,
                ["$+{A}", "$2"],
                ["$+{B}", "$3"],
                ["$+{C}", "$4"],
                ["$+{D}", "$1"],
            ;
        }
        foreach (0 .. 3) {
            if ($fetch [$_]) {
                iseq $fetch [$_] [0], $fetch [$_] [1], $names [$_];
            } else {
                ok 0, $names [$_];
            }
        }
        iseq $res, 1, "'$s' =~ /(?<D>(?<A>foo)\\s+(?<B>bar)?\\s+(?<C>baz))/";
        iseq $count, 4, "Got 4 keys in %+ via each";
        iseq @@k, 4, 'Got 4 keys in %+ via keys';
        iseq "@@k", "A B C D", "Got expected keys";
        iseq "@@v", "bar baz foo foo bar baz", "Got expected values";
        eval '
            no warnings "uninitialized";
            print for $+ {this_key_doesnt_exist};
        ';
        ok !$@@,'lvalue $+ {...} should not throw an exception';
    }


    {
        my $s = 'foo bar baz';
        my @@res;
        if ('1234' =~ /(?<A>1)(?<B>2)(?<A>3)(?<B>4)/) {
            foreach my $name (sort keys(%-)) {
                my $ary = $- {$name};
                foreach my $idx (0 .. $#$ary) {
                    push @@res, "$name:$idx:$ary->[$idx]";
                }
            }
        }
        my @@expect = qw (A:0:1 A:1:3 B:0:2 B:1:4);
        iseq "@@res", "@@expect", "Check %-";
        eval'
            no warnings "uninitialized";
            print for $- {this_key_doesnt_exist};
        ';
        ok !$@@,'lvalue $- {...} should not throw an exception';
    }


  SKIP:
    {
        # stress test CURLYX/WHILEM.
        #
        # This test includes varying levels of nesting, and according to
        # profiling done against build 28905, exercises every code line in the
        # CURLYX and WHILEM blocks, except those related to LONGJMP, the
        # super-linear cache and warnings. It executes about 0.5M regexes

        skip "No psycho tests" if $ENV {PERL_SKIP_PSYCHO_TEST};
        print "# Set PERL_SKIP_PSYCHO_TEST to skip this test\n";
        my $r = qr/^
                    (?:
                        ( (?:a|z+)+ )
                        (?:
                            ( (?:b|z+){3,}? )
                            (
                                (?:
                                    (?:
                                        (?:c|z+){1,1}?z
                                    )?
                                    (?:c|z+){1,1}
                                )*
                            )
                            (?:z*){2,}
                            ( (?:z+|d)+ )
                            (?:
                                ( (?:e|z+)+ )
                            )*
                            ( (?:f|z+)+ )
                        )*
                        ( (?:z+|g)+ )
                        (?:
                            ( (?:h|z+)+ )
                        )*
                        ( (?:i|z+)+ )
                    )+
                    ( (?:j|z+)+ )
                    (?:
                        ( (?:k|z+)+ )
                    )*
                    ( (?:l|z+)+ )
              $/x;
          
        my $ok = 1;
        my $msg = "CURLYX stress test";
        OUTER:
          for my $a ("x","a","aa") {
            for my $b ("x","bbb","bbbb") {
              my $bs = $a.$b;
              for my $c ("x","c","cc") {
                my $cs = $bs.$c;
                for my $d ("x","d","dd") {
                  my $ds = $cs.$d;
                  for my $e ("x","e","ee") {
                    my $es = $ds.$e;
                    for my $f ("x","f","ff") {
                      my $fs = $es.$f;
                      for my $g ("x","g","gg") {
                        my $gs = $fs.$g;
                        for my $h ("x","h","hh") {
                          my $hs = $gs.$h;
                          for my $i ("x","i","ii") {
                            my $is = $hs.$i;
                            for my $j ("x","j","jj") {
                              my $js = $is.$j;
                              for my $k ("x","k","kk") {
                                my $ks = $js.$k;
                                for my $l ("x","l","ll") {
                                  my $ls = $ks.$l;
                                  if ($ls =~ $r) {
                                    if ($ls =~ /x/) {
                                      $msg .= ": unexpected match for [$ls]";
                                      $ok = 0;
                                      last OUTER;
                                    }
                                    my $cap = "$1$2$3$4$5$6$7$8$9$10$11$12";
                                    unless ($ls eq $cap) {
                                      $msg .= ": capture: [$ls], got [$cap]";
                                      $ok = 0;
                                      last OUTER;
                                    }
                                  }
                                  else {
                                    unless ($ls =~ /x/) {
                                      $msg = ": failed for [$ls]";
                                      $ok = 0;
                                      last OUTER;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
        }
        ok($ok, $msg);
    }


    {
        # \, breaks {3,4}
        ok "xaaay"    !~ /xa{3\,4}y/, '\, in a pattern';
        ok "xa{3,4}y" =~ /xa{3\,4}y/, '\, in a pattern';

        # \c\ followed by _
        ok "x\c_y"    !~ /x\c\_y/,    '\_ in a pattern';
        ok "x\c\_y"   =~ /x\c\_y/,    '\_ in a pattern';

        # \c\ followed by other characters
        for my $c ("z", "\0", "!", chr(254), chr(256)) {
            my $targ = "a\034$c";
            my $reg  = "a\\c\\$c";
            ok eval ("qq/$targ/ =~ /$reg/"), "\\c\\ in pattern";
        }
    }


    {
        local $BugId = '36046';
        my $str = 'abc'; 
        my $count = 0;
        my $mval = 0;
        my $pval = 0;
        while ($str =~ /b/g) {$mval = $#-; $pval = $#+; $count ++}
        iseq $mval,  0, '@@- should be empty';
        iseq $pval,  0, '@@+ should be empty';
        iseq $count, 1, 'Should have matched once only';
    }


    {   # Test the (*PRUNE) pattern
        our $count = 0;
        'aaab' =~ /a+b?(?{$count++})(*FAIL)/;
        iseq $count, 9, "Expect 9 for no (*PRUNE)";
        $count = 0;
        'aaab' =~ /a+b?(*PRUNE)(?{$count++})(*FAIL)/;
        iseq $count, 3, "Expect 3 with (*PRUNE)";
        local $_ = 'aaab';
        $count = 0;
        1 while /.(*PRUNE)(?{$count++})(*FAIL)/g;
        iseq $count, 4, "/.(*PRUNE)/";
        $count = 0;
        'aaab' =~ /a+b?(??{'(*PRUNE)'})(?{$count++})(*FAIL)/;
        iseq $count, 3, "Expect 3 with (*PRUNE)";
        local $_ = 'aaab';
        $count = 0;
        1 while /.(??{'(*PRUNE)'})(?{$count++})(*FAIL)/g;
        iseq $count, 4, "/.(*PRUNE)/";
    }


    {   # Test the (*SKIP) pattern
        our $count = 0;
        'aaab' =~ /a+b?(*SKIP)(?{$count++})(*FAIL)/;
        iseq $count, 1, "Expect 1 with (*SKIP)";
        local $_ = 'aaab';
        $count = 0;
        1 while /.(*SKIP)(?{$count++})(*FAIL)/g;
        iseq $count, 4, "/.(*SKIP)/";
        $_ = 'aaabaaab';
        $count = 0;
        our @@res = ();
        1 while /(a+b?)(*SKIP)(?{$count++; push @@res,$1})(*FAIL)/g;
        iseq $count, 2, "Expect 2 with (*SKIP)";
        iseq "@@res", "aaab aaab", "Adjacent (*SKIP) works as expected";
    }


    {   # Test the (*SKIP) pattern
        our $count = 0;
        'aaab' =~ /a+b?(*MARK:foo)(*SKIP)(?{$count++})(*FAIL)/;
        iseq $count, 1, "Expect 1 with (*SKIP)";
        local $_ = 'aaab';
        $count = 0;
        1 while /.(*MARK:foo)(*SKIP)(?{$count++})(*FAIL)/g;
        iseq $count, 4, "/.(*SKIP)/";
        $_ = 'aaabaaab';
        $count = 0;
        our @@res = ();
        1 while /(a+b?)(*MARK:foo)(*SKIP)(?{$count++; push @@res,$1})(*FAIL)/g;
        iseq $count, 2, "Expect 2 with (*SKIP)";
        iseq "@@res", "aaab aaab", "Adjacent (*SKIP) works as expected";
    }


    {   # Test the (*SKIP) pattern
        our $count = 0;
        'aaab' =~ /a*(*MARK:a)b?(*MARK:b)(*SKIP:a)(?{$count++})(*FAIL)/;
        iseq $count, 3, "Expect 3 with *MARK:a)b?(*MARK:b)(*SKIP:a)";
        local $_ = 'aaabaaab';
        $count = 0;
        our @@res = ();
        1 while
        /(a*(*MARK:a)b?)(*MARK:x)(*SKIP:a)(?{$count++; push @@res,$1})(*FAIL)/g;
        iseq $count, 5, "Expect 5 with (*MARK:a)b?)(*MARK:x)(*SKIP:a)";
        iseq "@@res", "aaab b aaab b ",
             "Adjacent (*MARK:a)b?)(*MARK:x)(*SKIP:a) works as expected";
    }


    {   # Test the (*COMMIT) pattern
        our $count = 0;
        'aaabaaab' =~ /a+b?(*COMMIT)(?{$count++})(*FAIL)/;
        iseq $count, 1, "Expect 1 with (*COMMIT)";
        local $_ = 'aaab';
        $count = 0;
        1 while /.(*COMMIT)(?{$count++})(*FAIL)/g;
        iseq $count, 1, "/.(*COMMIT)/";
        $_ = 'aaabaaab';
        $count = 0;
        our @@res = ();
        1 while /(a+b?)(*COMMIT)(?{$count++; push @@res,$1})(*FAIL)/g;
        iseq $count, 1, "Expect 1 with (*COMMIT)";
        iseq "@@res", "aaab", "Adjacent (*COMMIT) works as expected";
    }


    {
        # Test named commits and the $REGERROR var
        our $REGERROR;
        for my $name ('', ':foo') {
            for my $pat ("(*PRUNE$name)",
                         ($name ? "(*MARK$name)" : "") . "(*SKIP$name)",
                         "(*COMMIT$name)") {                         
                for my $suffix ('(*FAIL)', '') {
                    'aaaab' =~ /a+b$pat$suffix/;
                    iseq $REGERROR,
                         ($suffix ? ($name ? 'foo' : "1") : ""),
                        "Test $pat and \$REGERROR $suffix";
                }
            }
        }
    }


    {
        # Test named commits and the $REGERROR var
        package Fnorble;
        our $REGERROR;
        for my $name ('', ':foo') {
            for my $pat ("(*PRUNE$name)",
                         ($name ? "(*MARK$name)" : "") . "(*SKIP$name)",
                         "(*COMMIT$name)") {                         
                for my $suffix ('(*FAIL)','') {
                    'aaaab' =~ /a+b$pat$suffix/;
                  ::iseq $REGERROR,
                         ($suffix ? ($name ? 'foo' : "1") : ""),
                        "Test $pat and \$REGERROR $suffix";
                }
            }
        }      
    }    


    {
        # Test named commits and the $REGERROR var
        local $Message = '$REGERROR';
        our $REGERROR;
        for my $word (qw (bar baz bop)) {
            $REGERROR = "";
            "aaaaa$word" =~
              /a+(?:bar(*COMMIT:bar)|baz(*COMMIT:baz)|bop(*COMMIT:bop))(*FAIL)/;
            iseq $REGERROR, $word;
        }    
    }


    {
        local $BugId = '40684';
        local $Message = '/m in precompiled regexp';
        my $s = "abc\ndef";
        my $rex = qr'^abc$'m;
        ok $s =~ m/$rex/;
        ok $s =~ m/^abc$/m;
    }


    {
        #Mindnumbingly simple test of (*THEN)
        for ("ABC","BAX") {
            ok /A (*THEN) X | B (*THEN) C/x, "Simple (*THEN) test";
        }
    }


    {
        local $Message = "Relative Recursion";
        my $parens = qr/(\((?:[^()]++|(?-1))*+\))/;
        local $_ = 'foo((2*3)+4-3) + bar(2*(3+4)-1*(2-3))';
        my ($all, $one, $two) = ('', '', '');
        ok /foo $parens \s* \+ \s* bar $parens/x;
        iseq $1, '((2*3)+4-3)';
        iseq $2, '(2*(3+4)-1*(2-3))';
        iseq $&, 'foo((2*3)+4-3) + bar(2*(3+4)-1*(2-3))';
        iseq $&, $_;
    }

    {
        my $spaces="      ";
        local $_ = join 'bar', $spaces, $spaces;
        our $count = 0;
        s/(?>\s+bar)(?{$count++})//g;
        iseq $_, $spaces, "SUSPEND final string";
        iseq $count, 1, "Optimiser should have prevented more than one match";
    }

    {
        local $BugId   = '36909';
        local $Message = '(?: ... )? should not lose $^R';
        $^R = 'Nothing';
        {
            local $^R = "Bad";
            ok 'x foofoo y' =~ m {
                      (foo) # $^R correctly set
                      (?{ "last regexp code result" })
            }x;
            iseq $^R, 'last regexp code result';
        }
        iseq $^R, 'Nothing';

        {
            local $^R = "Bad";

            ok 'x foofoo y' =~ m {
                      (?:foo|bar)+ # $^R correctly set
                      (?{ "last regexp code result" })
            }x;
            iseq $^R, 'last regexp code result';
        }
        iseq $^R, 'Nothing';

        {
            local $^R = "Bad";
            ok 'x foofoo y' =~ m {
                      (foo|bar)\1+ # $^R undefined
                      (?{ "last regexp code result" })
            }x;
            iseq $^R, 'last regexp code result';
        }
        iseq $^R, 'Nothing';

        {
            local $^R = "Bad";
            ok 'x foofoo y' =~ m {
                      (foo|bar)\1 # This time without the +
                      (?{"last regexp code result"})
            }x;
            iseq $^R, 'last regexp code result';
        }
        iseq $^R, 'Nothing';
    }


    {
        local $BugId   = '22395';
        local $Message = 'Match is linear, not quadratic';
        our $count;
        for my $l (10, 100, 1000) {
            $count = 0;
            ('a' x $l) =~ /(.*)(?{$count++})[bc]/;
            local $TODO = "Should be L+1 not L*(L+3)/2 (L=$l)";
            iseq $count, $l + 1;
        }
    }


    {
        local $BugId   = '22614';
        local $Message = '@@-/@@+ should not have undefined values';
        local $_ = 'ab';
        our @@len = ();
        /(.){1,}(?{push @@len,0+@@-})(.){1,}(?{})^/;
        iseq "@@len", "2 2 2";
    }


    {
        local $BugId   = '18209';
        local $Message = '$& set on s///';
        my $text = ' word1 word2 word3 word4 word5 word6 ';

        my @@words = ('word1', 'word3', 'word5');
        my $count;
        foreach my $word (@@words) {
            $text =~ s/$word\s//gi; # Leave a space to seperate words
                                    # in the resultant str.
            # The following block is not working.
            if ($&) {
                $count ++;
            }
            # End bad block
        }
        iseq $count, 3;
        iseq $text, ' word2 word4 word6 ';
    }


    {
        # RT#6893
        local $BugId = '6893';
        local $_ = qq (A\nB\nC\n); 
        my @@res;
        while (m#(\G|\n)([^\n]*)\n#gsx) { 
            push @@res, "$2"; 
            last if @@res > 3;
        }
        iseq "@@res", "A B C", "/g pattern shouldn't infinite loop";
    }


    {
        # From Message-ID: <877ixs6oa6.fsf@@k75.linux.bogus>
        my $dow_name = "nada";
        my $parser = "(\$dow_name) = \$time_string =~ /(D\x{e9}\\ " .
                     "C\x{e9}adaoin|D\x{e9}\\ Sathairn|\\w+|\x{100})/";
        my $time_string = "D\x{e9} C\x{e9}adaoin";
        eval $parser;
        ok !$@@, "Test Eval worked";
        iseq $dow_name, $time_string, "UTF-8 trie common prefix extraction";
    }


    {
        my $v;
        ($v = 'bar') =~ /(\w+)/g;
        $v = 'foo';
        iseq "$1", 'bar', '$1 is safe after /g - may fail due ' .
                          'to specialized config in pp_hot.c'
    }


    {
        local $Message = "http://nntp.perl.org/group/perl.perl5.porters/118663";
        my $qr_barR1 = qr/(bar)\g-1/;
        ok "foobarbarxyz" =~ $qr_barR1;
        ok "foobarbarxyz" =~ qr/foo${qr_barR1}xyz/;
        ok "foobarbarxyz" =~ qr/(foo)${qr_barR1}xyz/;
        ok "foobarbarxyz" =~ qr/(foo)(bar)\g{-1}xyz/;
        ok "foobarbarxyz" =~ qr/(foo${qr_barR1})xyz/;
        ok "foobarbarxyz" =~ qr/(foo(bar)\g{-1})xyz/;
    } 


    {
        local $BugId   = '41010';
        local $Message = 'No optimizer bug';
        my @@tails  = ('', '(?(1))', '(|)', '()?');    
        my @@quants = ('*','+');
        my $doit = sub {
            my $pats = shift;
            for (@@_) {
                for my $pat (@@$pats) {
                    for my $quant (@@quants) {
                        for my $tail (@@tails) {
                            my $re = "($pat$quant\$)$tail";
                            ok /$re/  && $1 eq $_, "'$_' =~ /$re/";
                            ok /$re/m && $1 eq $_, "'$_' =~ /$re/m";
                        }
                    }
                }
            }
        };    
        
        my @@dpats = ('\d',
                     '[1234567890]',
                     '(1|[23]|4|[56]|[78]|[90])',
                     '(?:1|[23]|4|[56]|[78]|[90])',
                     '(1|2|3|4|5|6|7|8|9|0)',
                     '(?:1|2|3|4|5|6|7|8|9|0)');
        my @@spats = ('[ ]', ' ', '( |\t)', '(?: |\t)', '[ \t]', '\s');
        my @@sstrs = ('  ');
        my @@dstrs = ('12345');
        $doit -> (\@@spats, @@sstrs);
        $doit -> (\@@dpats, @@dstrs);
    }


    {
        local $Message = '$REGMARK';
        our @@r = ();
        our ($REGMARK, $REGERROR);
        ok 'foofoo' =~ /foo (*MARK:foo) (?{push @@r,$REGMARK}) /x;
        iseq "@@r","foo";           
        iseq $REGMARK, "foo";
        ok 'foofoo' !~ /foo (*MARK:foo) (*FAIL) /x;
        ok !$REGMARK;
        iseq $REGERROR, 'foo';
    }


    {
        local $Message = '\K test';
        my $x;
        $x = "abc.def.ghi.jkl";
        $x =~ s/.*\K\..*//;
        iseq $x, "abc.def.ghi";
        
        $x = "one two three four";
        $x =~ s/o+ \Kthree//g;
        iseq $x, "one two  four";
        
        $x = "abcde";
        $x =~ s/(.)\K/$1/g;
        iseq $x, "aabbccddee";
    }


    {
        sub kt {
            return '4' if $_[0] eq '09028623';
        }
        # Nested EVAL using PL_curpm (via $1 or friends)
        my $re;
        our $grabit = qr/ ([0-6][0-9]{7}) (??{ kt $1 }) [890] /x;
        $re = qr/^ ( (??{ $grabit }) ) $ /x;
        my @@res = '0902862349' =~ $re;
        iseq join ("-", @@res), "0902862349",
            'PL_curpm is set properly on nested eval';

        our $qr = qr/ (o) (??{ $1 }) /x;
        ok 'boob'=~/( b (??{ $qr }) b )/x && 1, "PL_curpm, nested eval";
    }


    {
        use charnames ":full";
        ok "\N{ROMAN NUMERAL ONE}" =~ /\p{Alphabetic}/, "I =~ Alphabetic";
        ok "\N{ROMAN NUMERAL ONE}" =~ /\p{Uppercase}/,  "I =~ Uppercase";
        ok "\N{ROMAN NUMERAL ONE}" !~ /\p{Lowercase}/,  "I !~ Lowercase";
        ok "\N{ROMAN NUMERAL ONE}" =~ /\p{IDStart}/,    "I =~ ID_Start";
        ok "\N{ROMAN NUMERAL ONE}" =~ /\p{IDContinue}/, "I =~ ID_Continue";
        ok "\N{SMALL ROMAN NUMERAL ONE}" =~ /\p{Alphabetic}/, "i =~ Alphabetic";
        ok "\N{SMALL ROMAN NUMERAL ONE}" !~ /\p{Uppercase}/,  "i !~ Uppercase";
        ok "\N{SMALL ROMAN NUMERAL ONE}" =~ /\p{Lowercase}/,  "i =~ Lowercase";
        ok "\N{SMALL ROMAN NUMERAL ONE}" =~ /\p{IDStart}/,    "i =~ ID_Start";
        ok "\N{SMALL ROMAN NUMERAL ONE}" =~ /\p{IDContinue}/, "i =~ ID_Continue"
    }


    {
        # requirement of Unicode Technical Standard #18, 1.7 Code Points
        # cf. http://www.unicode.org/reports/tr18/#Supplementary_Characters
        for my $u (0x7FF, 0x800, 0xFFFF, 0x10000) {
            no warnings 'utf8'; # oops
            my $c = chr $u;
            my $x = sprintf '%04X', $u;
            ok "A${c}B" =~ /A[\0-\x{10000}]B/, "Unicode range - $x";
        }
    }


    {
        my $res="";

        if ('1' =~ /(?|(?<digit>1)|(?<digit>2))/) {
            $res = "@@{$- {digit}}";
        }
        iseq $res, "1",
            "Check that (?|...) doesnt cause dupe entries in the names array";
        
        $res = "";
        if ('11' =~ /(?|(?<digit>1)|(?<digit>2))(?&digit)/) {
            $res = "@@{$- {digit}}";
        }
        iseq $res, "1", "Check that (?&..) to a buffer inside " .
                        "a (?|...) goes to the leftmost";
    }


    {
        use warnings;
        local $Message = "ASCII pattern that really is UTF-8";
        my @@w;
        local $SIG {__WARN__} = sub {push @@w, "@@_"};
        my $c = qq (\x{DF}); 
        ok $c =~ /${c}|\x{100}/;
        ok @@w == 0;
    }    


    {
        local $Message = "Corruption of match results of qr// across scopes";
        my $qr = qr/(fo+)(ba+r)/;
        'foobar' =~ /$qr/;
        iseq "$1$2", "foobar";
        {
            'foooooobaaaaar' =~ /$qr/;
            iseq "$1$2", 'foooooobaaaaar';    
        }
        iseq "$1$2", "foobar";
    }


    {
        local $Message = "HORIZWS";
        local $_ = "\t \r\n \n \t".chr(11)."\n";
        s/\H/H/g;
        s/\h/h/g;
        iseq $_, "hhHHhHhhHH";
        $_ = "\t \r\n \n \t" . chr (11) . "\n";
        utf8::upgrade ($_);
        s/\H/H/g;
        s/\h/h/g;
        iseq $_, "hhHHhHhhHH";
    }    


    {
        local $Message = "Various whitespace special patterns";
        my @@h = map {chr $_}   0x09,   0x20,   0xa0, 0x1680, 0x180e, 0x2000,
                             0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006,
                             0x2007, 0x2008, 0x2009, 0x200a, 0x202f, 0x205f,
                             0x3000;
        my @@v = map {chr $_}   0x0a,   0x0b,   0x0c,   0x0d,   0x85, 0x2028,
                             0x2029;
        my @@lb = ("\x0D\x0A", map {chr $_} 0x0A .. 0x0D, 0x85, 0x2028, 0x2029);
        foreach my $t ([\@@h,  qr/\h/, qr/\h+/],
                       [\@@v,  qr/\v/, qr/\v+/],
                       [\@@lb, qr/\R/, qr/\R+/],) {
            my $ary = shift @@$t;
            foreach my $pat (@@$t) {
                foreach my $str (@@$ary) {
                    ok $str =~ /($pat)/, $pat;
                    iseq $1, $str, $pat;
                    utf8::upgrade ($str);
                    ok $str =~ /($pat)/, "Upgraded string - $pat";
                    iseq $1, $str, "Upgraded string - $pat";
                }
            }
        }
    }


    {
        local $Message = "Check that \\xDF match properly in its various forms";
        # Test that \xDF matches properly. this is pretty hacky stuff,
        # but its actually needed. The malarky with '-' is to prevent
        # compilation caching from playing any role in the test.
        my @@df = (chr (0xDF), '-', chr (0xDF));
        utf8::upgrade ($df [2]);
        my @@strs = ('ss', 'sS', 'Ss', 'SS', chr (0xDF));
        my @@ss = map {("$_", "$_")} @@strs;
        utf8::upgrade ($ss [$_ * 2 + 1]) for 0 .. $#strs;

        for my $ssi (0 .. $#ss) {
            for my $dfi (0 .. $#df) {
                my $pat = $df [$dfi];
                my $str = $ss [$ssi];
                my $utf_df = ($dfi > 1) ? 'utf8' : '';
                my $utf_ss = ($ssi % 2) ? 'utf8' : '';
                (my $sstr = $str) =~ s/\xDF/\\xDF/;

                if ($utf_df || $utf_ss || length ($ss [$ssi]) == 1) {
                    my $ret = $str =~ /$pat/i;
                    next if $pat eq '-';
                    ok $ret, "\"$sstr\" =~ /\\xDF/i " .
                             "(str is @@{[$utf_ss||'latin']}, pat is " .
                             "@@{[$utf_df||'latin']})";
                }
                else {
                    my $ret = $str !~ /$pat/i;
                    next if $pat eq '-';
                    ok $ret, "\"$sstr\" !~ /\\xDF/i " .
                             "(str is @@{[$utf_ss||'latin']}, pat is " .
                             "@@{[$utf_df||'latin']})";
                }
            }
        }
    }


    {
        local $Message = "BBC(Bleadperl Breaks CPAN) Today: String::Multibyte";
        my $re  = qr/(?:[\x00-\xFF]{4})/;
        my $hyp = "\0\0\0-";
        my $esc = "\0\0\0\\";

        my $str = "$esc$hyp$hyp$esc$esc";
        my @@a = ($str =~ /\G(?:\Q$esc$esc\E|\Q$esc$hyp\E|$re)/g);

        iseq @@a,3;
        local $" = "=";
        iseq "@@a","$esc$hyp=$hyp=$esc$esc";
    }


    {
        # Test for keys in %+ and %-
        local $Message = 'Test keys in %+ and %-';
        no warnings 'uninitialized';
        my $_ = "abcdef";
        /(?<foo>a)|(?<foo>b)/;
        iseq ((join ",", sort keys %+), "foo");
        iseq ((join ",", sort keys %-), "foo");
        iseq ((join ",", sort values %+), "a");
        iseq ((join ",", sort map "@@$_", values %-), "a ");
        /(?<bar>a)(?<bar>b)(?<quux>.)/;
        iseq ((join ",", sort keys %+), "bar,quux");
        iseq ((join ",", sort keys %-), "bar,quux");
        iseq ((join ",", sort values %+), "a,c"); # leftmost
        iseq ((join ",", sort map "@@$_", values %-), "a b,c");
        /(?<un>a)(?<deux>c)?/; # second buffer won't capture
        iseq ((join ",", sort keys %+), "un");
        iseq ((join ",", sort keys %-), "deux,un");
        iseq ((join ",", sort values %+), "a");
        iseq ((join ",", sort map "@@$_", values %-), ",a");
    }


    {
        # length() on captures, the numbered ones end up in Perl_magic_len
        my $_ = "aoeu \xe6var ook";
        /^ \w+ \s (?<eek>\S+)/x;

        iseq length ($`),      0, q[length $`];
        iseq length ($'),      4, q[length $'];
        iseq length ($&),      9, q[length $&];
        iseq length ($1),      4, q[length $1];
        iseq length ($+{eek}), 4, q[length $+{eek} == length $1];
    }


    {
        my $ok = -1;

        $ok = exists ($-{x}) ? 1 : 0 if 'bar' =~ /(?<x>foo)|bar/;
        iseq $ok, 1, '$-{x} exists after "bar"=~/(?<x>foo)|bar/';
        iseq scalar (%+), 0, 'scalar %+ == 0 after "bar"=~/(?<x>foo)|bar/';
        iseq scalar (%-), 1, 'scalar %- == 1 after "bar"=~/(?<x>foo)|bar/';

        $ok = -1;
        $ok = exists ($+{x}) ? 1 : 0 if 'bar' =~ /(?<x>foo)|bar/;
        iseq $ok, 0, '$+{x} not exists after "bar"=~/(?<x>foo)|bar/';
        iseq scalar (%+), 0, 'scalar %+ == 0 after "bar"=~/(?<x>foo)|bar/';
        iseq scalar (%-), 1, 'scalar %- == 1 after "bar"=~/(?<x>foo)|bar/';

        $ok = -1;
        $ok = exists ($-{x}) ? 1 : 0 if 'foo' =~ /(?<x>foo)|bar/;
        iseq $ok, 1, '$-{x} exists after "foo"=~/(?<x>foo)|bar/';
        iseq scalar (%+), 1, 'scalar %+ == 1 after "foo"=~/(?<x>foo)|bar/';
        iseq scalar (%-), 1, 'scalar %- == 1 after "foo"=~/(?<x>foo)|bar/';

        $ok = -1;
        $ok = exists ($+{x}) ? 1 : 0 if 'foo'=~/(?<x>foo)|bar/;
        iseq $ok, 1, '$+{x} exists after "foo"=~/(?<x>foo)|bar/';
    }


    {
        local $_;
        ($_ = 'abc') =~ /(abc)/g;
        $_ = '123'; 
        iseq "$1", 'abc', "/g leads to unsafe match vars: $1";
    }


    {
        local $Message = 'Message-ID: <20070818091501.7eff4831@@r2d2>';
        my $str = "";
        for (0 .. 5) {
            my @@x;
            $str .= "@@x"; # this should ALWAYS be the empty string
            'a' =~ /(a|)/;
            push @@x, 1;
        }
        iseq length ($str), 0, "Trie scope error, string should be empty";
        $str = "";
        my @@foo = ('a') x 5;
        for (@@foo) {
            my @@bar;
            $str .= "@@bar";
            s/a|/push @@bar, 1/e;
        }
        iseq length ($str), 0, "Trie scope error, string should be empty";
    }


    {
        local $BugId = '45605';
        # [perl #45605] Regexp failure with utf8-flagged and byte-flagged string

        my $utf_8 = "\xd6schel";
        utf8::upgrade ($utf_8);
        $utf_8 =~ m {(\xd6|&Ouml;)schel};
        iseq $1, "\xd6", "Upgrade error";
    }

    {
# more TRIE/AHOCORASICK problems with mixed utf8 / latin-1 and case folding
	for my $chr (160 .. 255) {
	    my $chr_byte = chr($chr);
	    my $chr_utf8 = chr($chr); utf8::upgrade($chr_utf8);
	    my $rx = qr{$chr_byte|X}i;
	    ok($chr_utf8 =~ $rx, "utf8/latin, codepoint $chr");
	}
    }

    {
        # Regardless of utf8ness any character matches itself when 
        # doing a case insensitive match. See also [perl #36207] 
        local $BugId = '36207';
        for my $o (0 .. 255) {
            my @@ch = (chr ($o), chr ($o));
            utf8::upgrade ($ch [1]);
            for my $u_str (0, 1) {
                for my $u_pat (0, 1) {
                    ok $ch [$u_str] =~ /\Q$ch[$u_pat]\E/i,
                    "\$c =~ /\$c/i : chr ($o) : u_str = $u_str u_pat = $u_pat";
                    ok $ch [$u_str] =~ /\Q$ch[$u_pat]\E|xyz/i,
                    "\$c=~/\$c|xyz/i : chr($o) : u_str = $u_str u_pat = $u_pat";
                }
            }
        }
    }


    {
        our $a = 3; "" =~ /(??{ $a })/;
        our $b = $a;
        iseq $b, $a, "Copy of scalar used for postponed subexpression";
    }


    {
         local $BugId   = '49190';
         local $Message = '$REGMARK in replacement';
         our $REGMARK;
         my $_ = "A";
         ok s/(*:B)A/$REGMARK/;
         iseq $_, "B";
         $_ = "CCCCBAA";
         ok s/(*:X)A+|(*:Y)B+|(*:Z)C+/$REGMARK/g;
         iseq $_, "ZYX";
    }


    {
        our @@ctl_n = ();
        our @@plus = ();
        our $nested_tags;
        $nested_tags = qr{
            <
               (\w+)
               (?{
                       push @@ctl_n,$^N;
                       push @@plus,$+;
               })
            >
            (??{$nested_tags})*
            </\s* \w+ \s*>
        }x;

        my $match = '<bla><blubb></blubb></bla>' =~ m/^$nested_tags$/;
        ok $match, 'nested construct matches';
        iseq "@@ctl_n", "bla blubb", '$^N inside of (?{}) works as expected';
        iseq "@@plus",  "bla blubb", '$+  inside of (?{}) works as expected';
    }


    {
        local $BugId   = '52658';
        local $Message = 'Substitution evaluation in list context';
        my $reg = '../xxx/';
        my @@te  = ($reg =~ m{^(/?(?:\.\./)*)},
                   $reg =~ s/(x)/'b'/eg > 1 ? '##' : '++');
        iseq $reg, '../bbb/';
        iseq $te [0], '../';
    }

	# This currently has to come before any "use encoding" in this file.
    {
        local $Message;
        local $BugId   = '59342';
	# for 5.10.x, add a dummy test indead
        #must_warn 'qr/\400/', '^Use of octal value above 377';
	$Message=""; ok 1;
    }


    SKIP: {
        # XXX: This set of tests is essentially broken, POSIX character classes
        # should not have differing definitions under Unicode. 
        # There are property names for that.
        skip "Tests assume ASCII", 4 unless $IS_ASCII;

        my @@notIsPunct = grep {/[[:punct:]]/ and not /\p{IsPunct}/}
                                map {chr} 0x20 .. 0x7f;
        iseq join ('', @@notIsPunct), '$+<=>^`|~',
            '[:punct:] disagress with IsPunct on Symbols';

        my @@isPrint = grep {not /[[:print:]]/ and /\p{IsPrint}/}
                            map {chr} 0 .. 0x1f, 0x7f .. 0x9f;
        iseq join ('', @@isPrint), "\x09\x0a\x0b\x0c\x0d\x85",
            'IsPrint disagrees with [:print:] on control characters';

        my @@isPunct = grep {/[[:punct:]]/ != /\p{IsPunct}/}
                            map {chr} 0x80 .. 0xff;
        iseq join ('', @@isPunct), "\xa1\xab\xb7\xbb\xbf",	# ¡ « · » ¿
            'IsPunct disagrees with [:punct:] outside ASCII';

        my @@isPunctLatin1 = eval q {
            use encoding 'latin1';
            grep {/[[:punct:]]/ != /\p{IsPunct}/} map {chr} 0x80 .. 0xff;
        };
        skip "Eval failed ($@@)", 1 if $@@;
        skip "PERL_LEGACY_UNICODE_CHARCLASS_MAPPINGS set to 0", 1
              if $ENV {REAL_POSIX_CC};
        iseq join ('', @@isPunctLatin1), '', 
            'IsPunct agrees with [:punct:] with explicit Latin1';
    } 


    {
        local $BugId =  '60034';
        my $a = "xyzt" x 8192;
        ok $a =~ /\A(?>[a-z])*\z/,
                '(?>) does not cause wrongness on long string';
        my $b = $a . chr 256;
        chop $b;
        {
            iseq $a, $b;
        }
        ok $b =~ /\A(?>[a-z])*\z/,
           '(?>) does not cause wrongness on long string with UTF-8';
    }


    #
    # Keep the following tests last -- they may crash perl
    #
    print "# Tests that follow may crash perl\n";
    {   
        local $BugId   = '19049/38869';
        local $Message = 'Pattern in a loop, failure should not ' .
                         'affect previous success';
        my @@list = (
            'ab cdef',             # Matches regex
            ('e' x 40000 ) .'ab c' # Matches not, but 'ab c' matches part of it
        );
        my $y;
        my $x;
        foreach (@@list) {
            m/ab(.+)cd/i; # The ignore-case seems to be important
            $y = $1;      # Use $1, which might not be from the last match!
            $x = substr ($list [0], $- [0], $+ [0] - $- [0]);
        }
        iseq $y, ' ';
        iseq $x, 'ab cd';
    }


    {
        local $BugId = '24274';

        ok (("a" x (2 ** 15 - 10)) =~ /^()(a|bb)*$/, "Recursive stack cracker");
        ok ((q(a)x 100) =~ /^(??{'(.)'x 100})/, 
            "Regexp /^(??{'(.)'x 100})/ crashes older perls");
    }


    {
        eval '/\k/';
        ok $@@ =~ /\QSequence \k... not terminated in regex;\E/,
           'Lone \k not allowed';
    }


    {
        local $Message = "Substitution with lookahead (possible segv)";
        $_ = "ns1ns1ns1";
        s/ns(?=\d)/ns_/g;
        iseq $_, "ns_1ns_1ns_1";
        $_ = "ns1";
        s/ns(?=\d)/ns_/;
        iseq $_, "ns_1";
        $_ = "123";
        s/(?=\d+)|(?<=\d)/!Bang!/g;
        iseq $_, "!Bang!1!Bang!2!Bang!3!Bang!";
    }


    {
        # [perl #45337] utf8 + "[a]a{2}" + /$.../ = panic: sv_len_utf8 cache
        local $BugId = '45337';
        local ${^UTF8CACHE} = -1;
        local $Message = "Shouldn't panic";
        my $s = "[a]a{2}";
        utf8::upgrade $s;
        ok "aaa" =~ /$s/;
    }
    {
        local $BugId = '57042';
	local $Message = "Check if tree logic breaks \$^R";
	my $cond_re = qr/\s*
	    \s* (?:
		   \( \s* A  (?{1})
		 | \( \s* B  (?{2})
	       )
	   /x;
	my @@res;
	for my $line ("(A)","(B)") {
	   if ($line =~ m/$cond_re/) {
	       push @@res, $^R ? "#$^R" : "UNDEF";
	   }
	}
	iseq "@@res","#1 #2";
    }
    {
	no warnings 'closure';
	my $re = qr/A(??{"1"})/;
	ok "A1B" =~ m/^((??{ $re }))((??{"B"}))$/;
	ok $1 eq "A1";
	ok $2 eq "B";
    }


    {
        use re 'eval';
        local $Message = 'Test if $^N and $+ work in (?{{})';
        our @@ctl_n = ();
        our @@plus = ();
        our $nested_tags;
        $nested_tags = qr{
            <
               ((\w)+)
               (?{
                       push @@ctl_n, (defined $^N ? $^N : "undef");
                       push @@plus, (defined $+ ? $+ : "undef");
               })
            >
            (??{$nested_tags})*
            </\s* \w+ \s*>
        }x;


        my $c = 0;
        for my $test (
            # Test structure:
            #  [ Expected result, Regex, Expected value(s) of $^N, Expected value(s) of $+ ]
            [ 1, qr#^$nested_tags$#, "bla blubb bla", "a b a" ],
            [ 1, qr#^($nested_tags)$#, "bla blubb <bla><blubb></blubb></bla>", "a b a" ],
            [ 1, qr#^(|)$nested_tags$#, "bla blubb bla", "a b a" ],
            [ 1, qr#^(?:|)$nested_tags$#, "bla blubb bla", "a b a" ],
            [ 1, qr#^<(bl|bla)>$nested_tags<(/\1)>$#, "blubb /bla", "b /bla" ],
            [ 1, qr#(??{"(|)"})$nested_tags$#, "bla blubb bla", "a b a" ],
            [ 1, qr#^(??{"(bla|)"})$nested_tags$#, "bla blubb bla", "a b a" ],
            [ 1, qr#^(??{"(|)"})(??{$nested_tags})$#, "bla blubb undef", "a b undef" ],
            [ 1, qr#^(??{"(?:|)"})$nested_tags$#, "bla blubb bla", "a b a" ],
            [ 1, qr#^((??{"(?:bla|)"}))((??{$nested_tags}))$#, "bla blubb <bla><blubb></blubb></bla>", "a b <bla><blubb></blubb></bla>" ],
            [ 1, qr#^((??{"(?!)?"}))((??{$nested_tags}))$#, "bla blubb <bla><blubb></blubb></bla>", "a b <bla><blubb></blubb></bla>" ],
            [ 1, qr#^((??{"(?:|<(/?bla)>)"}))((??{$nested_tags}))\1$#, "bla blubb <bla><blubb></blubb></bla>", "a b <bla><blubb></blubb></bla>" ],
            [ 0, qr#^((??{"(?!)"}))?((??{$nested_tags}))(?!)$#, "bla blubb undef", "a b undef" ],

        ) { #"#silence vim highlighting
            $c++;
            @@ctl_n = ();
            @@plus = ();
            my $match = (("<bla><blubb></blubb></bla>" =~ $test->[1]) ? 1 : 0);
            push @@ctl_n, (defined $^N ? $^N : "undef");
            push @@plus, (defined $+ ? $+ : "undef");
            ok($test->[0] == $match, "match $c");
            if ($test->[0] != $match) {
              # unset @@ctl_n and @@plus
              @@ctl_n = @@plus = ();
            }
            iseq("@@ctl_n", $test->[2], "ctl_n $c");
            iseq("@@plus", $test->[3], "plus $c");
        }
    }

    {
        use re 'eval';
        local $BugId = '56194';

	our $f;
	local $f;
	$f = sub {
            defined $_[0] ? $_[0] : "undef";
        };

        ok("123" =~ m/^(\d)(((??{1 + $^N})))+$/);

        our @@ctl_n;
        our @@plus;

        my $re  = qr#(1)((??{ push @@ctl_n, $f->($^N); push @@plus, $f->($+); $^N + 1}))*(?{$^N})#;
        my $re2 = qr#(1)((??{ push @@ctl_n, $f->($^N); push @@plus, $f->($+); $^N + 1}))*(?{$^N})(|a(b)c|def)(??{"$^R"})#;
        my $re3 = qr#(1)((??{ push @@ctl_n, $f->($^N); push @@plus, $f->($+); $^N + 1})){2}(?{$^N})(|a(b)c|def)(??{"$^R"})#;
        our $re5;
        local $re5 = qr#(1)((??{ push @@ctl_n, $f->($^N); push @@plus, $f->($+); $^N + 1})){2}(?{$^N})#;
        my $re6 = qr#(??{ push @@ctl_n, $f->($^N); push @@plus, $f->($+); $^N + 1})#;
        my $re7 = qr#(??{ push @@ctl_n, $f->($^N); push @@plus, $f->($+); $^N + 1})#;
        my $re8 = qr/(\d+)/;
        my $c = 0;
        for my $test (
             # Test structure:
             #  [
             #    String to match
             #    Regex too match
             #    Expected values of $^N
             #    Expected values of $+
             #    Expected values of $1, $2, $3, $4 and $5
             #  ]
             [
                  "1233",
                  qr#^(1)((??{ push @@ctl_n, $f->($^N); push @@plus, $f->($+); $^N + 1}))+(??{$^N})$#,
                  "1 2 3 3",
                  "1 2 3 3",
                  "\$1 = 1, \$2 = 3, \$3 = undef, \$4 = undef, \$5 = undef",
             ],
             [
                  "1233",
                  qr#^(1)((??{ push @@ctl_n, $f->($^N); push @@plus, $f->($+); $^N + 1}))+(abc|def|)?(??{$+})$#,
                  "1 2 3 3",
                  "1 2 3 3",
                  "\$1 = 1, \$2 = 3, \$3 = undef, \$4 = undef, \$5 = undef",
             ],
             [
                  "1233",
                  qr#^(1)((??{ push @@ctl_n, $f->($^N); push @@plus, $f->($+); $^N + 1}))+(|abc|def)?(??{$+})$#,
                  "1 2 3 3",
                  "1 2 3 3",
                  "\$1 = 1, \$2 = 3, \$3 = undef, \$4 = undef, \$5 = undef",
             ],
             [
                  "1233",
                  qr#^(1)((??{ push @@ctl_n, $f->($^N); push @@plus, $f->($+); $^N + 1}))+(abc|def|)?(??{$^N})$#,
                  "1 2 3 3",
                  "1 2 3 3",
                  "\$1 = 1, \$2 = 3, \$3 = undef, \$4 = undef, \$5 = undef",
             ],
             [
                  "1233",
                  qr#^(1)((??{ push @@ctl_n, $f->($^N); push @@plus, $f->($+); $^N + 1}))+(|abc|def)?(??{$^N})$#,
                  "1 2 3 3",
                  "1 2 3 3",
                  "\$1 = 1, \$2 = 3, \$3 = undef, \$4 = undef, \$5 = undef",
              ],
              [
                  "123abc3",
                   qr#^($re)(|a(b)c|def)(??{$^R})$#,
                   "1 2 3 abc",
                   "1 2 3 b",
                   "\$1 = 123, \$2 = 1, \$3 = 3, \$4 = abc, \$5 = b",
              ],
              [
                  "123abc3",
                   qr#^($re2)$#,
                   "1 2 3 123abc3",
                   "1 2 3 b",
                   "\$1 = 123abc3, \$2 = 1, \$3 = 3, \$4 = abc, \$5 = b",
              ],
              [
                  "123abc3",
                   qr#^($re3)$#,
                   "1 2 123abc3",
                   "1 2 b",
                   "\$1 = 123abc3, \$2 = 1, \$3 = 3, \$4 = abc, \$5 = b",
              ],
              [
                  "123abc3",
                   qr#^(??{$re5})(|abc|def)(??{"$^R"})$#,
                   "1 2 abc",
                   "1 2 abc",
                   "\$1 = abc, \$2 = undef, \$3 = undef, \$4 = undef, \$5 = undef",
              ],
              [
                  "123abc3",
                   qr#^(??{$re5})(|a(b)c|def)(??{"$^R"})$#,
                   "1 2 abc",
                   "1 2 b",
                   "\$1 = abc, \$2 = b, \$3 = undef, \$4 = undef, \$5 = undef",
              ],
              [
                  "1234",
                   qr#^((\d+)((??{push @@ctl_n, $f->($^N); push @@plus, $f->($+);$^N + 1}))((??{push @@ctl_n, $f->($^N); push @@plus, $f->($+);$^N + 1}))((??{push @@ctl_n, $f->($^N); push @@plus, $f->($+);$^N + 1})))$#,
                   "1234 123 12 1 2 3 1234",
                   "1234 123 12 1 2 3 4",
                   "\$1 = 1234, \$2 = 1, \$3 = 2, \$4 = 3, \$5 = 4",
              ],
              [
                   "1234556",
                   qr#^(\d+)($re6)($re6)($re6)$re6(($re6)$re6)$#,
                   "1234556 123455 12345 1234 123 12 1 2 3 4 4 5 56",
                   "1234556 123455 12345 1234 123 12 1 2 3 4 4 5 5",
                   "\$1 = 1, \$2 = 2, \$3 = 3, \$4 = 4, \$5 = 56",
              ],
              [
                  "12345562",
                   qr#^((??{$re8}))($re7)($re7)($re7)$re7($re7)($re7(\2))$#,
                   "12345562 1234556 123455 12345 1234 123 12 1 2 3 4 4 5 62",
                   "12345562 1234556 123455 12345 1234 123 12 1 2 3 4 4 5 2",
                   "\$1 = 1, \$2 = 2, \$3 = 3, \$4 = 4, \$5 = 5",
              ],
        ) {
            $c++;
            @@ctl_n = ();
            @@plus = ();
            undef $^R;
            my $match = $test->[0] =~ $test->[1];
            my $str = join(", ", '$1 = '.$f->($1), '$2 = '.$f->($2), '$3 = '.$f->($3), '$4 = '.$f->($4),'$5 = '.$f->($5));
            push @@ctl_n, $f->($^N);
            push @@plus, $f->($+);
            ok($match, "match $c");
            if (not $match) {
                # unset $str, @@ctl_n and @@plus
                $str = "";
                @@ctl_n = @@plus = ();
            }
            iseq("@@ctl_n", $test->[2], "ctl_n $c");
            iseq("@@plus", $test->[3], "plus $c");
            iseq($str, $test->[4], "str $c");
        }
        SKIP: {
            if ($] le '5.010') {
                skip "test segfaults on perl < 5.10", 4;
            }

            @@ctl_n = ();
            @@plus = ();

            our $re4;
            local $re4 = qr#(1)((??{push @@ctl_n, $f->($^N); push @@plus, $f->($+);$^N + 1})){2}(?{$^N})(|abc|def)(??{"$^R"})#;
            undef $^R;
            my $match = "123abc3" =~ m/^(??{$re4})$/;
            my $str = join(", ", '$1 = '.$f->($1), '$2 = '.$f->($2), '$3 = '.$f->($3), '$4 = '.$f->($4),'$5 = '.$f->($5),'$^R = '.$f->($^R));
            push @@ctl_n, $f->($^N);
            push @@plus, $f->($+);
            ok($match);
            if (not $match) {
                # unset $str
                @@ctl_n = ();
                @@plus = ();
                $str = "";
            }
            iseq("@@ctl_n", "1 2 undef");
            iseq("@@plus", "1 2 undef");
            iseq($str, "\$1 = undef, \$2 = undef, \$3 = undef, \$4 = undef, \$5 = undef, \$^R = undef");
       }
    }

    {
	local $BugId = 65372;	# minimal CURLYM limited to 32767 matches
	my @@pat = (
	    qr{a(x|y)*b},	# CURLYM
	    qr{a(x|y)*?b},	# .. with minmod
	    qr{a([wx]|[yz])*b},	# .. and without tries
	    qr{a([wx]|[yz])*?b},
	);
	my $len = 32768;
	my $s = join '', 'a', 'x' x $len, 'b';
	for my $pat (@@pat) {
	    ok($s =~ $pat, $pat);
	}
    }
    #
    # This should be the last test.
    #
    iseq $test + 1, $EXPECTED_TESTS, "Got the right number of tests!";

} # End of sub run_tests

1;
@


1.12
log
@Merge in perl 5.10.1; part two
@
text
@@


1.11
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d7 7
d16 1
a16 1
# Test counter output is generated by a BEGIN block at bottom of file
d22 1
d24 11
d36 1
d39 1
a39 1
$x = "abc\ndef\n";
d41 1
a41 2
if ($x =~ /^abc/) {print "ok 1\n";} else {print "not ok 1\n";}
if ($x !~ /^def/) {print "ok 2\n";} else {print "not ok 2\n";}
d43 1
a43 2
# used to be a test for $*
if ($x =~ /^def/m) {print "ok 3\n";} else {print "not ok 3\n";}
d45 2
a46 2
$_ = '123';
if (/^([0-9][0-9]*)/) {print "ok 4\n";} else {print "not ok 4\n";}
d48 9
a56 2
if ($x =~ /^xxx/) {print "not ok 5\n";} else {print "ok 5\n";}
if ($x !~ /^abc/) {print "not ok 6\n";} else {print "ok 6\n";}
d58 3
a60 2
if ($x =~ /def/) {print "ok 7\n";} else {print "not ok 7\n";}
if ($x !~ /def/) {print "not ok 8\n";} else {print "ok 8\n";}
d62 7
a68 2
if ($x !~ /.def/) {print "ok 9\n";} else {print "not ok 9\n";}
if ($x =~ /.def/) {print "not ok 10\n";} else {print "ok 10\n";}
d70 1
a70 2
if ($x =~ /\ndef/) {print "ok 11\n";} else {print "not ok 11\n";}
if ($x !~ /\ndef/) {print "not ok 12\n";} else {print "ok 12\n";}
d72 4
a75 11
$_ = 'aaabbbccc';
if (/(a*b*)(c*)/ && $1 eq 'aaabbb' && $2 eq 'ccc') {
	print "ok 13\n";
} else {
	print "not ok 13\n";
}
if (/(a+b+c+)/ && $1 eq 'aaabbbccc') {
	print "ok 14\n";
} else {
	print "not ok 14\n";
}
d77 10
a86 1
if (/a+b?c+/) {print "not ok 15\n";} else {print "ok 15\n";}
d88 1
a88 35
$_ = 'aaabccc';
if (/a+b?c+/) {print "ok 16\n";} else {print "not ok 16\n";}
if (/a*b+c*/) {print "ok 17\n";} else {print "not ok 17\n";}

$_ = 'aaaccc';
if (/a*b?c*/) {print "ok 18\n";} else {print "not ok 18\n";}
if (/a*b+c*/) {print "not ok 19\n";} else {print "ok 19\n";}

$_ = 'abcdef';
if (/bcd|xyz/) {print "ok 20\n";} else {print "not ok 20\n";}
if (/xyz|bcd/) {print "ok 21\n";} else {print "not ok 21\n";}

if (m|bc/*d|) {print "ok 22\n";} else {print "not ok 22\n";}

if (/^$_$/) {print "ok 23\n";} else {print "not ok 23\n";}

# used to be a test for $*
if ("ab\ncd\n" =~ /^cd/m) {print "ok 24\n";} else {print "not ok 24\n";}

$XXX{123} = 123;
$XXX{234} = 234;
$XXX{345} = 345;

@@XXX = ('ok 25','not ok 25', 'ok 26','not ok 26','not ok 27');
while ($_ = shift(@@XXX)) {
    ?(.*)? && (print $1,"\n");
    /not/ && reset;
    if (/not ok 26/) {
      if ($^O eq 'VMS') {
	$_ = shift(@@XXX);
      }
      else {
	reset 'X';
      }
   }
d91 3
a93 6
if ($^O ne 'VMS') {
  while (($key,$val) = each(%XXX)) {
    print "not ok 27\n";
    exit;
  }
}
a94 1
print "ok 27\n";
d96 18
a113 92
'cde' =~ /[^ab]*/;
'xyz' =~ //;
if ($& eq 'xyz') {print "ok 28\n";} else {print "not ok 28\n";}

$foo = '[^ab]*';
'cde' =~ /$foo/;
'xyz' =~ //;
if ($& eq 'xyz') {print "ok 29\n";} else {print "not ok 29\n";}

$foo = '[^ab]*';
'cde' =~ /$foo/;
'xyz' =~ /$null/;
if ($& eq 'xyz') {print "ok 30\n";} else {print "not ok 30\n";}

$_ = 'abcdefghi';
/def/;		# optimized up to cmd
if ("$`:$&:$'" eq 'abc:def:ghi') {print "ok 31\n";} else {print "not ok 31\n";}

/cde/ + 0;	# optimized only to spat
if ("$`:$&:$'" eq 'ab:cde:fghi') {print "ok 32\n";} else {print "not ok 32\n";}

/[d][e][f]/;	# not optimized
if ("$`:$&:$'" eq 'abc:def:ghi') {print "ok 33\n";} else {print "not ok 33\n";}

$_ = 'now is the {time for all} good men to come to.';
/ {([^}]*)}/;
if ($1 eq 'time for all') {print "ok 34\n";} else {print "not ok 34 $1\n";}

$_ = 'xxx {3,4}  yyy   zzz';
print /( {3,4})/ ? "ok 35\n" : "not ok 35\n";
print $1 eq '   ' ? "ok 36\n" : "not ok 36\n";
print /( {4,})/ ? "not ok 37\n" : "ok 37\n";
print /( {2,3}.)/ ? "ok 38\n" : "not ok 38\n";
print $1 eq '  y' ? "ok 39\n" : "not ok 39\n";
print /(y{2,3}.)/ ? "ok 40\n" : "not ok 40\n";
print $1 eq 'yyy ' ? "ok 41\n" : "not ok 41\n";
print /x {3,4}/ ? "not ok 42\n" : "ok 42\n";
print /^xxx {3,4}/ ? "not ok 43\n" : "ok 43\n";

$_ = "now is the time for all good men to come to.";
@@words = /(\w+)/g;
print join(':',@@words) eq "now:is:the:time:for:all:good:men:to:come:to"
    ? "ok 44\n"
    : "not ok 44\n";

@@words = ();
while (/\w+/g) {
    push(@@words, $&);
}
print join(':',@@words) eq "now:is:the:time:for:all:good:men:to:come:to"
    ? "ok 45\n"
    : "not ok 45\n";

@@words = ();
pos = 0;
while (/to/g) {
    push(@@words, $&);
}
print join(':',@@words) eq "to:to"
    ? "ok 46\n"
    : "not ok 46 `@@words'\n";

pos $_ = 0;
@@words = /to/g;
print join(':',@@words) eq "to:to"
    ? "ok 47\n"
    : "not ok 47 `@@words'\n";

$_ = "abcdefghi";

$pat1 = 'def';
$pat2 = '^def';
$pat3 = '.def.';
$pat4 = 'abc';
$pat5 = '^abc';
$pat6 = 'abc$';
$pat7 = 'ghi';
$pat8 = '\w*ghi';
$pat9 = 'ghi$';

$t1=$t2=$t3=$t4=$t5=$t6=$t7=$t8=$t9=0;

for $iter (1..5) {
    $t1++ if /$pat1/o;
    $t2++ if /$pat2/o;
    $t3++ if /$pat3/o;
    $t4++ if /$pat4/o;
    $t5++ if /$pat5/o;
    $t6++ if /$pat6/o;
    $t7++ if /$pat7/o;
    $t8++ if /$pat8/o;
    $t9++ if /$pat9/o;
d116 8
a123 2
$x = "$t1$t2$t3$t4$t5$t6$t7$t8$t9";
print $x eq '505550555' ? "ok 48\n" : "not ok 48 $x\n";
d125 2
a126 2
$xyz = 'xyz';
print "abc" =~ /^abc$|$xyz/ ? "ok 49\n" : "not ok 49\n";
d128 8
a135 106
# perl 4.009 says "unmatched ()"
eval '"abc" =~ /a(bc$)|$xyz/; $result = "$&:$1"';
print $@@ eq "" ? "ok 50\n" : "not ok 50\n";
print $result eq "abc:bc" ? "ok 51\n" : "not ok 51\n";


$_="abcfooabcbar";
$x=/abc/g;
print $` eq "" ? "ok 52\n" : "not ok 52\n" if $x;
$x=/abc/g;
print $` eq "abcfoo" ? "ok 53\n" : "not ok 53\n" if $x;
$x=/abc/g;
print $x == 0 ? "ok 54\n" : "not ok 54\n";
pos = 0;
$x=/ABC/gi;
print $` eq "" ? "ok 55\n" : "not ok 55\n" if $x;
$x=/ABC/gi;
print $` eq "abcfoo" ? "ok 56\n" : "not ok 56\n" if $x;
$x=/ABC/gi;
print $x == 0 ? "ok 57\n" : "not ok 57\n";
pos = 0;
$x=/abc/g;
print $' eq "fooabcbar" ? "ok 58\n" : "not ok 58\n" if $x;
$x=/abc/g;
print $' eq "bar" ? "ok 59\n" : "not ok 59\n" if $x;
$_ .= '';
@@x=/abc/g;
print scalar @@x == 2 ? "ok 60\n" : "not ok 60\n";

$_ = "abdc";
pos $_ = 2;
/\Gc/gc;
print "not " if (pos $_) != 2;
print "ok 61\n";
/\Gc/g;
print "not " if defined pos $_;
print "ok 62\n";

$out = 1;
'abc' =~ m'a(?{ $out = 2 })b';
print "not " if $out != 2;
print "ok 63\n";

$out = 1;
'abc' =~ m'a(?{ $out = 3 })c';
print "not " if $out != 1;
print "ok 64\n";

$_ = 'foobar1 bar2 foobar3 barfoobar5 foobar6';
@@out = /(?<!foo)bar./g;
print "not " if "@@out" ne 'bar2 barf';
print "ok 65\n";

# Tests which depend on REG_INFTY
$reg_infty = defined $Config{reg_infty} ? $Config{reg_infty} : 32767;
$reg_infty_m = $reg_infty - 1; $reg_infty_p = $reg_infty + 1;

# As well as failing if the pattern matches do unexpected things, the
# next three tests will fail if you should have picked up a lower-than-
# default value for $reg_infty from Config.pm, but have not.

undef $@@;
print "not " if eval q(('aaa' =~ /(a{1,$reg_infty_m})/)[0] ne 'aaa') || $@@;
print "ok 66\n";

undef $@@;
print "not " if eval q(('a' x $reg_infty_m) !~ /a{$reg_infty_m}/) || $@@;
print "ok 67\n";

undef $@@;
print "not " if eval q(('a' x ($reg_infty_m - 1)) =~ /a{$reg_infty_m}/) || $@@;
print "ok 68\n";

undef $@@;
eval "'aaa' =~ /a{1,$reg_infty}/";
print "not " if $@@ !~ m%^\QQuantifier in {,} bigger than%;
print "ok 69\n";

eval "'aaa' =~ /a{1,$reg_infty_p}/";
print "not "
	if $@@ !~ m%^\QQuantifier in {,} bigger than%;
print "ok 70\n";
undef $@@;

# Poke a couple more parse failures

$context = 'x' x 256;
eval qq("${context}y" =~ /(?<=$context)y/);
print "not " if $@@ !~ m%^\QLookbehind longer than 255 not%;
print "ok 71\n";

# removed test
print "ok 72\n";

# Long Monsters
$test = 73;
for $l (125, 140, 250, 270, 300000, 30) { # Ordered to free memory
  $a = 'a' x $l;
  print "# length=$l\nnot " unless "ba$a=" =~ /a$a=/;
  print "ok $test\n";
  $test++;

  print "not " if "b$a=" =~ /a$a=/;
  print "ok $test\n";
  $test++;
}
d137 2
a138 23
# 20000 nodes, each taking 3 words per string, and 1 per branch
$long_constant_len = join '|', 12120 .. 32645;
$long_var_len = join '|', 8120 .. 28645;
%ans = ( 'ax13876y25677lbc' => 1,
	 'ax13876y25677mcb' => 0, # not b.
	 'ax13876y35677nbc' => 0, # Num too big
	 'ax13876y25677y21378obc' => 1,
	 'ax13876y25677y21378zbc' => 0,	# Not followed by [k-o]
	 'ax13876y25677y21378y21378kbc' => 1,
	 'ax13876y25677y21378y21378kcb' => 0, # Not b.
	 'ax13876y25677y21378y21378y21378kbc' => 0, # 5 runs
       );

for ( keys %ans ) {
  print "# const-len `$_' not =>  $ans{$_}\nnot "
    if $ans{$_} xor /a(?=([yx]($long_constant_len)){2,4}[k-o]).*b./o;
  print "ok $test\n";
  $test++;
  print "# var-len   `$_' not =>  $ans{$_}\nnot "
    if $ans{$_} xor /a(?=([yx]($long_var_len)){2,4}[k-o]).*b./o;
  print "ok $test\n";
  $test++;
}
a139 2
$_ = " a (bla()) and x(y b((l)u((e))) and b(l(e)e)e";
$expect = "(bla()) ((l)u((e))) (l(e)e)";
d141 9
a149 29
sub matchit {
  m/
     (
       \(
       (?{ $c = 1 })		# Initialize
       (?:
	 (?(?{ $c == 0 })       # PREVIOUS iteration was OK, stop the loop
	   (?!
	   )			# Fail: will unwind one iteration back
	 )	
	 (?:
	   [^()]+		# Match a big chunk
	   (?=
	     [()]
	   )			# Do not try to match subchunks
	 |
	   \(
	   (?{ ++$c })
	 |
	   \)
	   (?{ --$c })
	 )
       )+			# This may not match with different subblocks
     )
     (?(?{ $c != 0 })
       (?!
       )			# Fail
     )				# Otherwise the chunk 1 may succeed with $c>0
   /xg;
d152 7
a158 59
@@ans = ();
push @@ans, $res while $res = matchit;

print "# ans='@@ans'\n# expect='$expect'\nnot " if "@@ans" ne "1 1 1";
print "ok $test\n";
$test++;

@@ans = matchit;

print "# ans='@@ans'\n# expect='$expect'\nnot " if "@@ans" ne $expect;
print "ok $test\n";
$test++;

print "not " unless "abc" =~ /^(??{"a"})b/;
print "ok $test\n";
$test++;

my $matched;
$matched = qr/\((?:(?>[^()]+)|(??{$matched}))*\)/;

@@ans = @@ans1 = ();
push(@@ans, $res), push(@@ans1, $&) while $res = m/$matched/g;

print "# ans='@@ans'\n# expect='$expect'\nnot " if "@@ans" ne "1 1 1";
print "ok $test\n";
$test++;

print "# ans1='@@ans1'\n# expect='$expect'\nnot " if "@@ans1" ne $expect;
print "ok $test\n";
$test++;

@@ans = m/$matched/g;

print "# ans='@@ans'\n# expect='$expect'\nnot " if "@@ans" ne $expect;
print "ok $test\n";
$test++;

@@ans = ('a/b' =~ m%(.*/)?(.*)%);	# Stack may be bad
print "not " if "@@ans" ne 'a/ b';
print "ok $test\n";
$test++;

$code = '{$blah = 45}';
$blah = 12;
eval { /(?$code)/ };
print "not " unless $@@ and $@@ =~ /not allowed at runtime/ and $blah == 12;
print "ok $test\n";
$test++;

for $code ('{$blah = 45}','=xx') {
  $blah = 12;
  $res = eval { "xx" =~ /(?$code)/o };
  if ($code eq '=xx') {
    print "#'$@@','$res','$blah'\nnot " unless not $@@ and $res;
  } else {
    print "#'$@@','$res','$blah'\nnot " unless $@@ and $@@ =~ /not allowed at runtime/ and $blah == 12;
  }
  print "ok $test\n";
  $test++;
d161 12
a172 27
$code = '{$blah = 45}';
$blah = 12;
eval "/(?$code)/";			
print "not " if $blah != 45;
print "ok $test\n";
$test++;

$blah = 12;
/(?{$blah = 45})/;			
print "not " if $blah != 45;
print "ok $test\n";
$test++;

$x = 'banana';
$x =~ /.a/g;
print "not " unless pos($x) == 2;
print "ok $test\n";
$test++;

$x =~ /.z/gc;
print "not " unless pos($x) == 2;
print "ok $test\n";
$test++;

sub f {
    my $p = $_[0];
    return $p;
d175 9
a183 53
$x =~ /.a/g;
print "not " unless f(pos($x)) == 4;
print "ok $test\n";
$test++;

$x = $^R = 67;
'foot' =~ /foo(?{$x = 12; 75})[t]/;
print "not " unless $^R eq '75';
print "ok $test\n";
$test++;

$x = $^R = 67;
'foot' =~ /foo(?{$x = 12; 75})[xy]/;
print "not " unless $^R eq '67' and $x eq '12';
print "ok $test\n";
$test++;

$x = $^R = 67;
'foot' =~ /foo(?{ $^R + 12 })((?{ $x = 12; $^R + 17 })[xy])?/;
print "not " unless $^R eq '79' and $x eq '12';
print "ok $test\n";
$test++;

print "not " unless qr/\b\v$/i eq '(?i-xsm:\b\v$)';
print "ok $test\n";
$test++;

print "not " unless qr/\b\v$/s eq '(?s-xim:\b\v$)';
print "ok $test\n";
$test++;

print "not " unless qr/\b\v$/m eq '(?m-xis:\b\v$)';
print "ok $test\n";
$test++;

print "not " unless qr/\b\v$/x eq '(?x-ism:\b\v$)';
print "ok $test\n";
$test++;

print "not " unless qr/\b\v$/xism eq '(?msix:\b\v$)';
print "ok $test\n";
$test++;

print "not " unless qr/\b\v$/ eq '(?-xism:\b\v$)';
print "ok $test\n";
$test++;

$_ = 'xabcx';
foreach $ans ('', 'c') {
  /(?<=(?=a)..)((?=c)|.)/g;
  print "# \$1  ='$1'\n# \$ans='$ans'\nnot " unless $1 eq $ans;
  print "ok $test\n";
  $test++;
a185 7
$_ = 'a';
foreach $ans ('', 'a', '') {
  /^|a|$/g;
  print "# \$&  ='$&'\n# \$ans='$ans'\nnot " unless $& eq $ans;
  print "ok $test\n";
  $test++;
}
d187 4
a190 9
sub prefixify {
  my($v,$a,$b,$res) = @@_;
  $v =~ s/\Q$a\E/$b/;
  print "not " unless $res eq $v;
  print "ok $test\n";
  $test++;
}
prefixify('/a/b/lib/arch', "/a/b/lib", 'X/lib', 'X/lib/arch');
prefixify('/a/b/man/arch', "/a/b/man", 'X/man', 'X/man/arch');
d192 1
a192 49
$_ = 'var="foo"';
/(\")/;
print "not " unless $1 and /$1/;
print "ok $test\n";
$test++;

$a=qr/(?{++$b})/;
$b = 7;
/$a$a/;
print "not " unless $b eq '9';
print "ok $test\n";
$test++;

$c="$a";
/$a$a/;
print "not " unless $b eq '11';
print "ok $test\n";
$test++;

{
  use re "eval";
  /$a$c$a/;
  print "not " unless $b eq '14';
  print "ok $test\n";
  $test++;

  local $lex_a = 2;
  my $lex_a = 43;
  my $lex_b = 17;
  my $lex_c = 27;
  my $lex_res = ($lex_b =~ qr/$lex_b(?{ $lex_c = $lex_a++ })/);
  print "not " unless $lex_res eq '1';
  print "ok $test\n";
  $test++;
  print "not " unless $lex_a eq '44';
  print "ok $test\n";
  $test++;
  print "not " unless $lex_c eq '43';
  print "ok $test\n";
  $test++;


  no re "eval";
  $match = eval { /$a$c$a/ };
  print "not "
    unless $b eq '14' and $@@ =~ /Eval-group not allowed/ and not $match;
  print "ok $test\n";
  $test++;
}
d194 1
a194 16
{
  local $lex_a = 2;
  my $lex_a = 43;
  my $lex_b = 17;
  my $lex_c = 27;
  my $lex_res = ($lex_b =~ qr/17(?{ $lex_c = $lex_a++ })/);
  print "not " unless $lex_res eq '1';
  print "ok $test\n";
  $test++;
  print "not " unless $lex_a eq '44';
  print "ok $test\n";
  $test++;
  print "not " unless $lex_c eq '43';
  print "ok $test\n";
  $test++;
}
d196 2
a197 17
{
  package aa;
  $c = 2;
  $::c = 3;
  '' =~ /(?{ $c = 4 })/;
  print "not " unless $c == 4;
}
print "ok $test\n";
$test++;
print "not " unless $c == 3;
print "ok $test\n";
$test++;

sub must_warn_pat {
    my $warn_pat = shift;
    return sub { print "not " unless $_[0] =~ /$warn_pat/ }
}
d199 2
a200 7
sub must_warn {
    my ($warn_pat, $code) = @@_;
    local %SIG;
    eval 'BEGIN { use warnings; $SIG{__WARN__} = $warn_pat };' . $code;
    print "ok $test\n";
    $test++;
}
d202 2
d205 2
a206 4
sub make_must_warn {
    my $warn_pat = shift;
    return sub { must_warn(must_warn_pat($warn_pat)) }
}
d208 2
a209 1
my $for_future = make_must_warn('reserved for future extensions');
d211 3
a213 1
&$for_future('q(a:[b]:) =~ /[x[:foo:]]/');
d215 4
a218 2
#&$for_future('q(a=[b]=) =~ /[x[=foo=]]/');
print "ok $test\n"; $test++; # now a fatal croak
d220 21
a240 440
#&$for_future('q(a.[b].) =~ /[x[.foo.]]/');
print "ok $test\n"; $test++; # now a fatal croak

# test if failure of patterns returns empty list
$_ = 'aaa';
@@_ = /bbb/;
print "not " if @@_;
print "ok $test\n";
$test++;

@@_ = /bbb/g;
print "not " if @@_;
print "ok $test\n";
$test++;

@@_ = /(bbb)/;
print "not " if @@_;
print "ok $test\n";
$test++;

@@_ = /(bbb)/g;
print "not " if @@_;
print "ok $test\n";
$test++;

/a(?=.$)/;
print "not " if $#+ != 0 or $#- != 0;
print "ok $test\n";
$test++;

print "not " if $+[0] != 2 or $-[0] != 1;
print "ok $test\n";
$test++;

print "not "
   if defined $+[1] or defined $-[1] or defined $+[2] or defined $-[2];
print "ok $test\n";
$test++;

/a(a)(a)/;
print "not " if $#+ != 2 or $#- != 2;
print "ok $test\n";
$test++;

print "not " if $+[0] != 3 or $-[0] != 0;
print "ok $test\n";
$test++;

print "not " if $+[1] != 2 or $-[1] != 1;
print "ok $test\n";
$test++;

print "not " if $+[2] != 3 or $-[2] != 2;
print "ok $test\n";
$test++;

print "not "
   if defined $+[3] or defined $-[3] or defined $+[4] or defined $-[4];
print "ok $test\n";
$test++;

/.(a)(b)?(a)/;
print "not " if $#+ != 3 or $#- != 3;
print "ok $test\n";
$test++;

print "not " if $+[0] != 3 or $-[0] != 0;
print "ok $test\n";
$test++;

print "not " if $+[1] != 2 or $-[1] != 1;
print "ok $test\n";
$test++;

print "not " if $+[3] != 3 or $-[3] != 2;
print "ok $test\n";
$test++;

print "not "
   if defined $+[2] or defined $-[2] or defined $+[4] or defined $-[4];
print "ok $test\n";
$test++;

/.(a)/;
print "not " if $#+ != 1 or $#- != 1;
print "ok $test\n";
$test++;

print "not " if $+[0] != 2 or $-[0] != 0;
print "ok $test\n";
$test++;

print "not " if $+[1] != 2 or $-[1] != 1;
print "ok $test\n";
$test++;

print "not "
   if defined $+[2] or defined $-[2] or defined $+[3] or defined $-[3];
print "ok $test\n";
$test++;

eval { $+[0] = 13; };
print "not "
   if $@@ !~ /^Modification of a read-only value attempted/;
print "ok $test\n";
$test++;

eval { $-[0] = 13; };
print "not "
   if $@@ !~ /^Modification of a read-only value attempted/;
print "ok $test\n";
$test++;

eval { @@+ = (7, 6, 5); };
print "not "
   if $@@ !~ /^Modification of a read-only value attempted/;
print "ok $test\n";
$test++;

eval { @@- = qw(foo bar); };
print "not "
   if $@@ !~ /^Modification of a read-only value attempted/;
print "ok $test\n";
$test++;

/.(a)(ba*)?/;
print "#$#-..$#+\nnot " if $#+ != 2 or $#- != 1;
print "ok $test\n";
$test++;

$_ = 'aaa';
pos = 1;
@@a = /\Ga/g;
print "not " unless "@@a" eq "a a";
print "ok $test\n";
$test++;

$str = 'abcde';
pos $str = 2;

print "not " if $str =~ /^\G/;
print "ok $test\n";
$test++;

print "not " if $str =~ /^.\G/;
print "ok $test\n";
$test++;

print "not " unless $str =~ /^..\G/;
print "ok $test\n";
$test++;

print "not " if $str =~ /^...\G/;
print "ok $test\n";
$test++;

print "not " unless $str =~ /.\G./ and $& eq 'bc';
print "ok $test\n";
$test++;

print "not " unless $str =~ /\G../ and $& eq 'cd';
print "ok $test\n";
$test++;

undef $foo; undef $bar;
print "#'$str','$foo','$bar'\nnot "
    unless $str =~ /b(?{$foo = $_; $bar = pos})c/
	and $foo eq 'abcde' and $bar eq 2;
print "ok $test\n";
$test++;

undef $foo; undef $bar;
pos $str = undef;
print "#'$str','$foo','$bar'\nnot "
    unless $str =~ /b(?{$foo = $_; $bar = pos})c/g
	and $foo eq 'abcde' and $bar eq 2 and pos $str eq 3;
print "ok $test\n";
$test++;

$_ = $str;

undef $foo; undef $bar;
print "#'$str','$foo','$bar'\nnot "
    unless /b(?{$foo = $_; $bar = pos})c/
	and $foo eq 'abcde' and $bar eq 2;
print "ok $test\n";
$test++;

undef $foo; undef $bar;
print "#'$str','$foo','$bar'\nnot "
    unless /b(?{$foo = $_; $bar = pos})c/g
	and $foo eq 'abcde' and $bar eq 2 and pos eq 3;
print "ok $test\n";
$test++;

undef $foo; undef $bar;
pos = undef;
1 while /b(?{$foo = $_; $bar = pos})c/g;
print "#'$str','$foo','$bar'\nnot "
    unless $foo eq 'abcde' and $bar eq 2 and not defined pos;
print "ok $test\n";
$test++;

undef $foo; undef $bar;
$_ = 'abcde|abcde';
print "#'$str','$foo','$bar','$_'\nnot "
    unless s/b(?{$foo = $_; $bar = pos})c/x/g and $foo eq 'abcde|abcde'
	and $bar eq 8 and $_ eq 'axde|axde';
print "ok $test\n";
$test++;

@@res = ();
# List context:
$_ = 'abcde|abcde';
@@dummy = /([ace]).(?{push @@res, $1,$2})([ce])(?{push @@res, $1,$2})/g;
@@res = map {defined $_ ? "'$_'" : 'undef'} @@res;
$res = "@@res";
print "#'@@res' '$_'\nnot "
    unless "@@res" eq "'a' undef 'a' 'c' 'e' undef 'a' undef 'a' 'c'";
print "ok $test\n";
$test++;

@@res = ();
@@dummy = /([ace]).(?{push @@res, $`,$&,$'})([ce])(?{push @@res, $`,$&,$'})/g;
@@res = map {defined $_ ? "'$_'" : 'undef'} @@res;
$res = "@@res";
print "#'@@res' '$_'\nnot "
    unless "@@res" eq
  "'' 'ab' 'cde|abcde' " .
  "'' 'abc' 'de|abcde' " .
  "'abcd' 'e|' 'abcde' " .
  "'abcde|' 'ab' 'cde' " .
  "'abcde|' 'abc' 'de'" ;
print "ok $test\n";
$test++;

#Some more \G anchor checks
$foo='aabbccddeeffgg';

pos($foo)=1;

$foo=~/.\G(..)/g;
iseq($1,'ab');

pos($foo) += 1;
$foo=~/.\G(..)/g;
print "not " unless($1 eq 'cc');
print "ok $test\n";
$test++;

pos($foo) += 1;
$foo=~/.\G(..)/g;
print "not " unless($1 eq 'de');
print "ok $test\n";
$test++;

print "not " unless $foo =~ /\Gef/g;
print "ok $test\n";
$test++;

undef pos $foo;

$foo=~/\G(..)/g;
print "not " unless($1  eq 'aa');
print "ok $test\n";
$test++;

$foo=~/\G(..)/g;
print "not " unless($1  eq 'bb');
print "ok $test\n";
$test++;

pos($foo)=5;
$foo=~/\G(..)/g;
print "not " unless($1  eq 'cd');
print "ok $test\n";
$test++;

$_='123x123';
@@res = /(\d*|x)/g;
print "not " unless('123||x|123|' eq join '|', @@res);
print "ok $test\n";
$test++;

# see if matching against temporaries (created via pp_helem()) is safe
{ foo => "ok $test\n".$^X }->{foo} =~ /^(.*)\n/g;
print "$1\n";
$test++;

# See if $i work inside (?{}) in the presense of saved substrings and
# changing $_
@@a = qw(foo bar);
@@b = ();
s/(\w)(?{push @@b, $1})/,$1,/g for @@a;

print "# \@@b='@@b', expect 'f o o b a r'\nnot " unless("@@b" eq "f o o b a r");
print "ok $test\n";
$test++;

print "not " unless("@@a" eq ",f,,o,,o, ,b,,a,,r,");
print "ok $test\n";
$test++;

$brackets = qr{
	         {  (?> [^{}]+ | (??{ $brackets }) )* }
	      }x;

"{{}" =~ $brackets;
print "ok $test\n";		# Did we survive?
$test++;

"something { long { and } hairy" =~ $brackets;
print "ok $test\n";		# Did we survive?
$test++;

"something { long { and } hairy" =~ m/((??{ $brackets }))/;
print "not " unless $1 eq "{ and }";
print "ok $test\n";
$test++;

$_ = "a-a\nxbb";
pos=1;
m/^-.*bb/mg and print "not ";
print "ok $test\n";
$test++;

$text = "aaXbXcc";
pos($text)=0;
$text =~ /\GXb*X/g and print 'not ';
print "ok $test\n";
$test++;

$text = "xA\n" x 500;
$text =~ /^\s*A/m and print 'not ';
print "ok $test\n";
$test++;

$text = "abc dbf";
@@res = ($text =~ /.*?(b).*?\b/g);
"@@res" eq 'b b' or print 'not ';
print "ok $test\n";
$test++;

@@a = map chr,0..255;

@@b = grep(/\S/,@@a);
@@c = grep(/[^\s]/,@@a);
print "not " if "@@b" ne "@@c";
print "ok $test\n";
$test++;

@@b = grep(/\S/,@@a);
@@c = grep(/[\S]/,@@a);
print "not " if "@@b" ne "@@c";
print "ok $test\n";
$test++;

@@b = grep(/\s/,@@a);
@@c = grep(/[^\S]/,@@a);
print "not " if "@@b" ne "@@c";
print "ok $test\n";
$test++;

@@b = grep(/\s/,@@a);
@@c = grep(/[\s]/,@@a);
print "not " if "@@b" ne "@@c";
print "ok $test\n";
$test++;

@@b = grep(/\D/,@@a);
@@c = grep(/[^\d]/,@@a);
print "not " if "@@b" ne "@@c";
print "ok $test\n";
$test++;

@@b = grep(/\D/,@@a);
@@c = grep(/[\D]/,@@a);
print "not " if "@@b" ne "@@c";
print "ok $test\n";
$test++;

@@b = grep(/\d/,@@a);
@@c = grep(/[^\D]/,@@a);
print "not " if "@@b" ne "@@c";
print "ok $test\n";
$test++;

@@b = grep(/\d/,@@a);
@@c = grep(/[\d]/,@@a);
print "not " if "@@b" ne "@@c";
print "ok $test\n";
$test++;

@@b = grep(/\W/,@@a);
@@c = grep(/[^\w]/,@@a);
print "not " if "@@b" ne "@@c";
print "ok $test\n";
$test++;

@@b = grep(/\W/,@@a);
@@c = grep(/[\W]/,@@a);
print "not " if "@@b" ne "@@c";
print "ok $test\n";
$test++;

@@b = grep(/\w/,@@a);
@@c = grep(/[^\W]/,@@a);
print "not " if "@@b" ne "@@c";
print "ok $test\n";
$test++;

@@b = grep(/\w/,@@a);
@@c = grep(/[\w]/,@@a);
iseq("@@b","@@c");

# see if backtracking optimization works correctly
"\n\n" =~ /\n  $ \n/x or print "not ";
print "ok $test\n";
$test++;

"\n\n" =~ /\n* $ \n/x or print "not ";
print "ok $test\n";
$test++;

"\n\n" =~ /\n+ $ \n/x or print "not ";
print "ok $test\n";
$test++;

[] =~ /^ARRAY/ or print "# [] \nnot ";
print "ok $test\n";
$test++;

eval << 'EOE';
{
 package S;
 use overload '""' => sub { 'Object S' };
 sub new { bless [] }
}
$a = 'S'->new;
EOE
d242 4
a245 21
$a and $a =~ /^Object\sS/ or print "# '$a' \nnot ";
print "ok $test\n";
$test++;

# test result of match used as match (!)
'a1b' =~ ('xyz' =~ /y/) and $` eq 'a' or print "not ";
print "ok $test\n";
$test++;

'a1b' =~ ('xyz' =~ /t/) and $` eq 'a' or print "not ";
print "ok $test\n";
$test++;

$w = 0;
{
    local $SIG{__WARN__} = sub { $w = 1 };
    local $^W = 1;
	$w = 1 if ("1\n" x 102) =~ /^\s*\n/m;
}
print $w ? "not " : "", "ok $test\n";
$test++;
d247 2
a248 131
my %space = ( spc   => " ",
	      tab   => "\t",
	      cr    => "\r",
	      lf    => "\n",
	      ff    => "\f",
# There's no \v but the vertical tabulator seems miraculously
# be 11 both in ASCII and EBCDIC.
	      vt    => chr(11),
	      false => "space" );

my @@space0 = sort grep { $space{$_} =~ /\s/ }          keys %space;
my @@space1 = sort grep { $space{$_} =~ /[[:space:]]/ } keys %space;
my @@space2 = sort grep { $space{$_} =~ /[[:blank:]]/ } keys %space;

print "not " unless "@@space0" eq "cr ff lf spc tab";
print "ok $test # @@space0\n";
$test++;

print "not " unless "@@space1" eq "cr ff lf spc tab vt";
print "ok $test # @@space1\n";
$test++;

print "not " unless "@@space2" eq "spc tab";
print "ok $test # @@space2\n";
$test++;

# bugid 20001021.005 - this caused a SEGV
print "not " unless undef =~ /^([^\/]*)(.*)$/;
print "ok $test\n";
$test++;

# bugid 20000731.001

print "not " unless "A \x{263a} B z C" =~ /A . B (??{ "z" }) C/;
print "ok $test\n";
$test++;

my $ordA = ord('A');

$_ = "a\x{100}b";
if (/(.)(\C)(\C)(.)/) {
  print "ok 232\n";
  if ($1 eq "a") {
    print "ok 233\n";
  } else {
    print "not ok 233\n";
  }
  if ($ordA == 65) { # ASCII (or equivalent), should be UTF-8
      if ($2 eq "\xC4") {
	  print "ok 234\n";
      } else {
	  print "not ok 234\n";
      }
      if ($3 eq "\x80") {
	  print "ok 235\n";
      } else {
	  print "not ok 235\n";
      }
  } elsif ($ordA == 193) { # EBCDIC (or equivalent), should be UTF-EBCDIC
      if ($2 eq "\x8C") {
	  print "ok 234\n";
      } else {
	  print "not ok 234\n";
      }
      if ($3 eq "\x41") {
	  print "ok 235\n";
      } else {
	  print "not ok 235\n";
      }
  } else {
      for (234..235) {
	  print "not ok $_ # ord('A') == $ordA\n";
      }
  }
  if ($4 eq "b") {
    print "ok 236\n";
  } else {
    print "not ok 236\n";
  }
} else {
  for (232..236) {
    print "not ok $_\n";
  }
}
$_ = "\x{100}";
if (/(\C)/g) {
  print "ok 237\n";
  # currently \C are still tagged as UTF-8
  if ($ordA == 65) {
      if ($1 eq "\xC4") {
	  print "ok 238\n";
      } else {
	  print "not ok 238\n";
      }
  } elsif ($ordA == 193) {
      if ($1 eq "\x8C") {
	  print "ok 238\n";
      } else {
	  print "not ok 238\n";
      }
  } else {
      print "not ok 238 # ord('A') == $ordA\n";
  }
} else {
  for (237..238) {
    print "not ok $_\n";
  }
}
if (/(\C)/g) {
  print "ok 239\n";
  # currently \C are still tagged as UTF-8
  if ($ordA == 65) {
      if ($1 eq "\x80") {
	  print "ok 240\n";
      } else {
	  print "not ok 240\n";
      }
  } elsif ($ordA == 193) {
      if ($1 eq "\x41") {
	  print "ok 240\n";
      } else {
	  print "not ok 240\n";
      }
  } else {
      print "not ok 240 # ord('A') == $ordA\n";
  }
} else {
  for (239..240) {
    print "not ok $_\n";
  }
}
d250 15
a264 7
{
  # japhy -- added 03/03/2001
  () = (my $str = "abc") =~ /(...)/;
  $str = "def";
  print "not " if $1 ne "abc";
  print "ok 241\n";
}
d266 6
a271 9
# The 242 and 243 go with the 244 and 245.
# The trick is that in EBCDIC the explicit numeric range should match
# (as also in non-EBCDIC) but the explicit alphabetic range should not match.

if ("\x8e" =~ /[\x89-\x91]/) {
  print "ok 242\n";
} else {
  print "not ok 242\n";
}
d273 1
a273 5
if ("\xce" =~ /[\xc9-\xd1]/) {
  print "ok 243\n";
} else {
  print "not ok 243\n";
}
d275 24
a298 20
# In most places these tests would succeed since \x8e does not
# in most character sets match 'i' or 'j' nor would \xce match
# 'I' or 'J', but strictly speaking these tests are here for
# the good of EBCDIC, so let's test these only there.
if (ord('i') == 0x89 && ord('J') == 0xd1) { # EBCDIC
  if ("\x8e" !~ /[i-j]/) {
    print "ok 244\n";
  } else {
    print "not ok 244\n";
  }
  if ("\xce" !~ /[I-J]/) {
    print "ok 245\n";
  } else {
    print "not ok 245\n";
  }
} else {
  for (244..245) {
    print "ok $_ # Skip: only in EBCDIC\n";
  }
}
d300 9
a308 2
print "not " unless "\x{ab}" =~ /\x{ab}/;
print "ok 246\n";
d310 3
a312 2
print "not " unless "\x{abcd}" =~ /\x{abcd}/;
print "ok 247\n";
d314 5
a318 2
{
    # bug id 20001008.001
d320 12
a331 11
    $test = 248;
    my @@x = ("stra\337e 138","stra\337e 138");
    for (@@x) {
	s/(\d+)\s*([\w\-]+)/$1 . uc $2/e;
	my($latin) = /^(.+)(?:\s+\d)/;
	print $latin eq "stra\337e" ? "ok $test\n" :	# 248,249
	    "#latin[$latin]\nnot ok $test\n";
	$test++;
	$latin =~ s/stra\337e/straße/; # \303\237 after the 2nd a
	use utf8; # needed for the raw UTF-8
	$latin =~ s!(s)tr(?:aß|s+e)!$1tr.!; # \303\237 after the a
a332 1
}
d334 14
a347 3
{
    print "not " unless "ba\xd4c" =~ /([a\xd4]+)/ && $1 eq "a\xd4";
    print "ok 250\n";
d349 6
a354 2
    print "not " unless "ba\xd4c" =~ /([a\xd4]+)/ && $1 eq "a\x{d4}";
    print "ok 251\n";
d356 4
a359 2
    print "not " unless "ba\x{d4}c" =~ /([a\xd4]+)/ && $1 eq "a\x{d4}";
    print "ok 252\n";
d361 2
a362 2
    print "not " unless "ba\x{d4}c" =~ /([a\xd4]+)/ && $1 eq "a\xd4";
    print "ok 253\n";
d364 27
a390 2
    print "not " unless "ba\xd4c" =~ /([a\x{d4}]+)/ && $1 eq "a\xd4";
    print "ok 254\n";
a391 2
    print "not " unless "ba\xd4c" =~ /([a\x{d4}]+)/ && $1 eq "a\x{d4}";
    print "ok 255\n";
d393 3
a395 2
    print "not " unless "ba\x{d4}c" =~ /([a\x{d4}]+)/ && $1 eq "a\x{d4}";
    print "ok 256\n";
d397 2
a398 3
    print "not " unless "ba\x{d4}c" =~ /([a\x{d4}]+)/ && $1 eq "a\xd4";
    print "ok 257\n";
}
d400 5
a404 2
{
    # the first half of 20001028.003
a405 5
    my $X = chr(1448);
    my ($Y) = $X =~ /(.*)/;
    print "not " unless $Y eq v1448 && length($Y) == 1;
    print "ok 258\n";
}
d407 3
a409 2
{
    # 20001108.001
d411 19
a429 6
    my $X = "Szab\x{f3},Bal\x{e1}zs";
    my $Y = $X;
    $Y =~ s/(B)/$1/ for 0..3;
    print "not " unless $Y eq $X && $X eq "Szab\x{f3},Bal\x{e1}zs";
    print "ok 259\n";
}
d431 9
a439 2
{
    # the second half of 20001028.003
d441 10
a450 5
    my $X = '';
    $X =~ s/^/chr(1488)/e;
    print "not " unless length $X == 1 && ord($X) == 1488;
    print "ok 260\n";
}
a451 2
{
    # 20000517.001
d453 5
a457 1
    my $x = "\x{100}A";
d459 20
a478 1
    $x =~ s/A/B/;
d480 6
a485 3
    print "not " unless $x eq "\x{100}B" && length($x) == 2;
    print "ok 261\n";
}
d487 9
a495 2
{
    # bug id 20001230.002
d497 3
a499 2
    print "not " unless "École" =~ /^\C\C(.)/ && $1 eq 'c';
    print "ok 262\n";
a500 3
    print "not " unless "École" =~ /^\C\C(c)/;
    print "ok 263\n";
}
d502 18
a519 2
SKIP: {
    $test = 264; # till 575
d521 3
a523 188
    use charnames ":full";

    # This is far from complete testing, there are dozens of character
    # classes in Unicode.  The mixing of literals and \N{...} is
    # intentional so that in non-Latin-1 places we test the native
    # characters, not the Unicode code points.

    my %s = (
	     "a" 				=> 'Ll',
	     "\N{CYRILLIC SMALL LETTER A}"	=> 'Ll',
	     "A" 				=> 'Lu',
	     "\N{GREEK CAPITAL LETTER ALPHA}"	=> 'Lu',
	     "\N{HIRAGANA LETTER SMALL A}"	=> 'Lo',
	     "\N{COMBINING GRAVE ACCENT}"	=> 'Mn',
	     "0"				=> 'Nd',
	     "\N{ARABIC-INDIC DIGIT ZERO}"	=> 'Nd',
	     "_"				=> 'N',
	     "!"				=> 'P',
	     " "				=> 'Zs',
	     "\0"				=> 'Cc',
	     );
	
    for my $char (map { s/^\S+ //; $_ }
                    sort map { sprintf("%06x", ord($_))." $_" } keys %s) {
	my $class = $s{$char};
	my $code  = sprintf("%06x", ord($char));
	printf "#\n# 0x$code\n#\n";
	print "# IsAlpha\n";
	if ($class =~ /^[LM]/) {
	    print "not " unless $char =~ /\p{IsAlpha}/;
	    print "ok $test\n"; $test++;
	    print "not " if     $char =~ /\P{IsAlpha}/;
	    print "ok $test\n"; $test++;
	} else {
	    print "not " if     $char =~ /\p{IsAlpha}/;
	    print "ok $test\n"; $test++;
	    print "not " unless $char =~ /\P{IsAlpha}/;
	    print "ok $test\n"; $test++;
	}
	print "# IsAlnum\n";
	if ($class =~ /^[LMN]/ && $char ne "_") {
	    print "not " unless $char =~ /\p{IsAlnum}/;
	    print "ok $test\n"; $test++;
	    print "not " if     $char =~ /\P{IsAlnum}/;
	    print "ok $test\n"; $test++;
	} else {
	    print "not " if     $char =~ /\p{IsAlnum}/;
	    print "ok $test\n"; $test++;
	    print "not " unless $char =~ /\P{IsAlnum}/;
	    print "ok $test\n"; $test++;
	}
	print "# IsASCII\n";
	if (ord("A") == 193) {
	    print "ok $test # Skip: in EBCDIC\n"; $test++;
	    print "ok $test # Skip: in EBCDIC\n"; $test++;
	} else {
	    if ($code le '00007f') {
		print "not " unless $char =~ /\p{IsASCII}/;
		print "ok $test\n"; $test++;
		print "not " if     $char =~ /\P{IsASCII}/;
		print "ok $test\n"; $test++;
	    } else {
		print "not " if     $char =~ /\p{IsASCII}/;
		print "ok $test\n"; $test++;
		print "not " unless $char =~ /\P{IsASCII}/;
		print "ok $test\n"; $test++;
	    }
	}
	print "# IsCntrl\n";
	if ($class =~ /^C/) {
	    print "not " unless $char =~ /\p{IsCntrl}/;
	    print "ok $test\n"; $test++;
	    print "not " if     $char =~ /\P{IsCntrl}/;
	    print "ok $test\n"; $test++;
	} else {
	    print "not " if     $char =~ /\p{IsCntrl}/;
	    print "ok $test\n"; $test++;
	    print "not " unless $char =~ /\P{IsCntrl}/;
	    print "ok $test\n"; $test++;
	}
	print "# IsBlank\n";
	if ($class =~ /^Z[lp]/ || $char eq " ") {
	    print "not " unless $char =~ /\p{IsBlank}/;
	    print "ok $test\n"; $test++;
	    print "not " if     $char =~ /\P{IsBlank}/;
	    print "ok $test\n"; $test++;
	} else {
	    print "not " if     $char =~ /\p{IsBlank}/;
	    print "ok $test\n"; $test++;
	    print "not " unless $char =~ /\P{IsBlank}/;
	    print "ok $test\n"; $test++;
	}
	print "# IsDigit\n";
	if ($class =~ /^Nd$/) {
	    print "not " unless $char =~ /\p{IsDigit}/;
	    print "ok $test\n"; $test++;
	    print "not " if     $char =~ /\P{IsDigit}/;
	    print "ok $test\n"; $test++;
	} else {
	    print "not " if     $char =~ /\p{IsDigit}/;
	    print "ok $test\n"; $test++;
	    print "not " unless $char =~ /\P{IsDigit}/;
	    print "ok $test\n"; $test++;
	}
	print "# IsGraph\n";
	if ($class =~ /^([LMNPS])|Co/) {
	    print "not " unless $char =~ /\p{IsGraph}/;
	    print "ok $test\n"; $test++;
	    print "not " if     $char =~ /\P{IsGraph}/;
	    print "ok $test\n"; $test++;
	} else {
	    print "not " if     $char =~ /\p{IsGraph}/;
	    print "ok $test\n"; $test++;
	    print "not " unless $char =~ /\P{IsGraph}/;
	    print "ok $test\n"; $test++;
	}
	print "# IsLower\n";
	if ($class =~ /^Ll$/) {
	    print "not " unless $char =~ /\p{IsLower}/;
	    print "ok $test\n"; $test++;
	    print "not " if     $char =~ /\P{IsLower}/;
	    print "ok $test\n"; $test++;
	} else {
	    print "not " if     $char =~ /\p{IsLower}/;
	    print "ok $test\n"; $test++;
	    print "not " unless $char =~ /\P{IsLower}/;
	    print "ok $test\n"; $test++;
	}
	print "# IsPrint\n";
	if ($class =~ /^([LMNPS])|Co|Zs/) {
	    print "not " unless $char =~ /\p{IsPrint}/;
	    print "ok $test\n"; $test++;
	    print "not " if     $char =~ /\P{IsPrint}/;
	    print "ok $test\n"; $test++;
	} else {
	    print "not " if     $char =~ /\p{IsPrint}/;
	    print "ok $test\n"; $test++;
	    print "not " unless $char =~ /\P{IsPrint}/;
	    print "ok $test\n"; $test++;
	}
	print "# IsPunct\n";
	if ($class =~ /^P/ || $char eq "_") {
	    print "not " unless $char =~ /\p{IsPunct}/;
	    print "ok $test\n"; $test++;
	    print "not " if     $char =~ /\P{IsPunct}/;
	    print "ok $test\n"; $test++;
	} else {
	    print "not " if     $char =~ /\p{IsPunct}/;
	    print "ok $test\n"; $test++;
	    print "not " unless $char =~ /\P{IsPunct}/;
	    print "ok $test\n"; $test++;
	}
	print "# IsSpace\n";
	if ($class =~ /^Z/ || ($code =~ /^(0009|000A|000B|000C|000D)$/)) {
	    print "not " unless $char =~ /\p{IsSpace}/;
	    print "ok $test\n"; $test++;
	    print "not " if     $char =~ /\P{IsSpace}/;
	    print "ok $test\n"; $test++;
	} else {
	    print "not " if     $char =~ /\p{IsSpace}/;
	    print "ok $test\n"; $test++;
	    print "not " unless $char =~ /\P{IsSpace}/;
	    print "ok $test\n"; $test++;
	}
	print "# IsUpper\n";
	if ($class =~ /^L[ut]/) {
	    print "not " unless $char =~ /\p{IsUpper}/;
	    print "ok $test\n"; $test++;
	    print "not " if     $char =~ /\P{IsUpper}/;
	    print "ok $test\n"; $test++;
	} else {
	    print "not " if     $char =~ /\p{IsUpper}/;
	    print "ok $test\n"; $test++;
	    print "not " unless $char =~ /\P{IsUpper}/;
	    print "ok $test\n"; $test++;
	}
	print "# IsWord\n";
	if ($class =~ /^[LMN]/ || $char eq "_") {
	    print "not " unless $char =~ /\p{IsWord}/;
	    print "ok $test\n"; $test++;
	    print "not " if     $char =~ /\P{IsWord}/;
	    print "ok $test\n"; $test++;
	} else {
	    print "not " if     $char =~ /\p{IsWord}/;
	    print "ok $test\n"; $test++;
	    print "not " unless $char =~ /\P{IsWord}/;
	    print "ok $test\n"; $test++;
	}
a524 1
}
d526 36
a561 2
{
    $_ = "abc\x{100}\x{200}\x{300}\x{380}\x{400}defg";
d563 11
a573 2
    if (/(.\x{300})./) {
	print "ok 576\n";
d575 2
a576 2
	print "not " unless $` eq "abc\x{100}" && length($`) == 4;
	print "ok 577\n";
d578 2
a579 2
	print "not " unless $& eq "\x{200}\x{300}\x{380}" && length($&) == 3;
	print "ok 578\n";
d581 2
a582 2
	print "not " unless $' eq "\x{400}defg" && length($') == 5;
	print "ok 579\n";
a583 4
	print "not " unless $1 eq "\x{200}\x{300}" && length($1) == 2;
	print "ok 580\n";
    } else {
	for (576..580) { print "not ok $_\n" }
a584 1
}
d586 3
a588 2
{
    # bug id 20010306.008
d590 4
a593 3
    $a = "a\x{1234}";
    # The original bug report had 'no utf8' here but that was irrelevant.
    $a =~ m/\w/; # used to core dump
d595 19
a613 2
    print "ok 581\n";
}
d615 9
a623 2
{
    $test = 582;
a624 8
    # bugid 20010410.006
    for my $rx (
		'/(.*?)\{(.*?)\}/csg',
		'/(.*?)\{(.*?)\}/cg',
		'/(.*?)\{(.*?)\}/sg',
		'/(.*?)\{(.*?)\}/g',
		'/(.+?)\{(.+?)\}/csg',
	       )
d626 12
a637 1
	my($input, $i);
d639 2
a640 10
	$i = 0;
	$input = "a{b}c{d}";
        eval <<EOT;
	while (eval \$input =~ $rx) {
	    print "# \\\$1 = '\$1' \\\$2 = '\$2'\n";
	    ++\$i;
	}
EOT
	print "not " unless $i == 2;
	print "ok " . $test++ . "\n";
a641 1
}
d643 14
a656 2
{
    # from Robin Houston
d658 8
a665 5
    my $x = "\x{10FFFD}";
    $x =~ s/(.)/$1/g;
    print "not " unless ord($x) == 0x10FFFD && length($x) == 1;
    print "ok 587\n";
}
a666 2
{
    my $x = "\x7f";
d668 9
a676 2
    print "not " if     $x =~ /[\x80-\xff]/;
    print "ok 588\n";
d678 8
a685 2
    print "not " if     $x =~ /[\x80-\x{100}]/;
    print "ok 589\n";
d687 9
a695 2
    print "not " if     $x =~ /[\x{100}]/;
    print "ok 590\n";
d697 3
a699 2
    print "not " if     $x =~ /\p{InLatin1Supplement}/;
    print "ok 591\n";
d701 5
a705 2
    print "not " unless $x =~ /\P{InLatin1Supplement}/;
    print "ok 592\n";
d707 41
a747 2
    print "not " if     $x =~ /\p{InLatinExtendedA}/;
    print "ok 593\n";
d749 1
a749 3
    print "not " unless $x =~ /\P{InLatinExtendedA}/;
    print "ok 594\n";
}
a750 2
{
    my $x = "\x80";
d752 10
a761 2
    print "not " unless $x =~ /[\x80-\xff]/;
    print "ok 595\n";
a762 2
    print "not " unless $x =~ /[\x80-\x{100}]/;
    print "ok 596\n";
d764 11
a774 2
    print "not " if     $x =~ /[\x{100}]/;
    print "ok 597\n";
a775 2
    print "not " unless $x =~ /\p{InLatin1Supplement}/;
    print "ok 598\n";
d777 6
a782 2
    print "not " if    $x =~ /\P{InLatin1Supplement}/;
    print "ok 599\n";
d784 2
a785 2
    print "not " if     $x =~ /\p{InLatinExtendedA}/;
    print "ok 600\n";
d787 2
a788 3
    print "not " unless $x =~ /\P{InLatinExtendedA}/;
    print "ok 601\n";
}
d790 3
a792 2
{
    my $x = "\xff";
d794 3
a796 2
    print "not " unless $x =~ /[\x80-\xff]/;
    print "ok 602\n";
d798 46
a843 2
    print "not " unless $x =~ /[\x80-\x{100}]/;
    print "ok 603\n";
a844 2
    print "not " if     $x =~ /[\x{100}]/;
    print "ok 604\n";
d846 8
a853 3
    # the next two tests must be ignored on EBCDIC
    print "not " unless $x =~ /\p{InLatin1Supplement}/ or ord("A") == 193;
    print "ok 605\n";
a854 2
    print "not " if     $x =~ /\P{InLatin1Supplement}/ and ord("A") != 193;
    print "ok 606\n";
d856 14
a869 2
    print "not " if     $x =~ /\p{InLatinExtendedA}/;
    print "ok 607\n";
d871 3
a873 3
    print "not " unless $x =~ /\P{InLatinExtendedA}/;
    print "ok 608\n";
}
a874 2
{
    my $x = "\x{100}";
d876 63
a938 2
    print "not " if     $x =~ /[\x80-\xff]/;
    print "ok 609\n";
a939 2
    print "not " unless $x =~ /[\x80-\x{100}]/;
    print "ok 610\n";
d941 17
a957 2
    print "not " unless $x =~ /[\x{100}]/;
    print "ok 611\n";
d959 2
a960 2
    print "not " if     $x =~ /\p{InLatin1Supplement}/;
    print "ok 612\n";
d962 11
a972 2
    print "not " unless $x =~ /\P{InLatin1Supplement}/;
    print "ok 613\n";
a973 2
    print "not " unless $x =~ /\p{InLatinExtendedA}/;
    print "ok 614\n";
d975 6
a980 3
    print "not " if     $x =~ /\P{InLatinExtendedA}/;
    print "ok 615\n";
}
a981 5
{
    # from japhy
    my $w;
    use warnings;    
    local $SIG{__WARN__} = sub { $w .= shift };
d983 6
a988 52
    $w = "";
    eval 'qr/(?c)/';
    print "not " if $w !~ /^Useless \(\?c\)/;
    print "ok 616\n";

    $w = "";
    eval 'qr/(?-c)/';
    print "not " if $w !~ /^Useless \(\?-c\)/;
    print "ok 617\n";

    $w = "";
    eval 'qr/(?g)/';
    print "not " if $w !~ /^Useless \(\?g\)/;
    print "ok 618\n";

    $w = "";
    eval 'qr/(?-g)/';
    print "not " if $w !~ /^Useless \(\?-g\)/;
    print "ok 619\n";

    $w = "";
    eval 'qr/(?o)/';
    print "not " if $w !~ /^Useless \(\?o\)/;
    print "ok 620\n";

    $w = "";
    eval 'qr/(?-o)/';
    print "not " if $w !~ /^Useless \(\?-o\)/;
    print "ok 621\n";

    # now test multi-error regexes

    $w = "";
    eval 'qr/(?g-o)/';
    print "not " if $w !~ /^Useless \(\?g\).*\nUseless \(\?-o\)/;
    print "ok 622\n";

    $w = "";
    eval 'qr/(?g-c)/';
    print "not " if $w !~ /^Useless \(\?g\).*\nUseless \(\?-c\)/;
    print "ok 623\n";

    $w = "";
    eval 'qr/(?o-cg)/';  # (?c) means (?g) error won't be thrown
    print "not " if $w !~ /^Useless \(\?o\).*\nUseless \(\?-c\)/;
    print "ok 624\n";

    $w = "";
    eval 'qr/(?ogc)/';
    print "not " if $w !~ /^Useless \(\?o\).*\nUseless \(\?g\).*\nUseless \(\?c\)/;
    print "ok 625\n";
}
a989 1
# More Unicode "class" tests
d991 18
a1008 2
{
    use charnames ':full';
a1009 2
    print "not " unless "\N{LATIN CAPITAL LETTER A}" =~ /\p{InBasicLatin}/;
    print "ok 626\n";
d1011 14
a1024 2
    print "not " unless "\N{LATIN CAPITAL LETTER A WITH GRAVE}" =~ /\p{InLatin1Supplement}/;
    print "ok 627\n";
a1025 2
    print "not " unless "\N{LATIN CAPITAL LETTER A WITH MACRON}" =~ /\p{InLatinExtendedA}/;
    print "ok 628\n";
d1027 5
a1031 2
    print "not " unless "\N{LATIN SMALL LETTER B WITH STROKE}" =~ /\p{InLatinExtendedB}/;
    print "ok 629\n";
a1032 3
    print "not " unless "\N{KATAKANA LETTER SMALL A}" =~ /\p{InKatakana}/;
    print "ok 630\n";
}
d1034 6
a1039 1
$_ = "foo";
a1040 28
eval <<"EOT"; die if $@@;
  /f
   o\r
   o
   \$
  /x && print "ok 631\n";
EOT

eval <<"EOT"; die if $@@;
  /f
   o
   o
   \$\r
  /x && print "ok 632\n";
EOT

#test /o feature
sub test_o { $_[0] =~/$_[1]/o; return $1}
if(test_o('abc','(.)..') eq 'a') {
    print "ok 633\n";
} else {
    print "not ok 633\n";
}
if(test_o('abc','..(.)') eq 'a') {
    print "ok 634\n";
} else {
    print "not ok 634\n";
}
d1042 3
a1044 2
# 635..639: ID 20010619.003 (only the space character is
# supposed to be [:print:], not the whole isprint()).
d1046 4
a1049 2
print "not " if "\n"     =~ /[[:print:]]/;
print "ok 635\n";
a1050 2
print "not " if "\t"     =~ /[[:print:]]/;
print "ok 636\n";
d1052 57
a1108 106
# Amazingly vertical tabulator is the same in ASCII and EBCDIC.
print "not " if "\014"  =~ /[[:print:]]/;
print "ok 637\n";

print "not " if "\r"    =~ /[[:print:]]/;
print "ok 638\n";

print "not " unless " " =~ /[[:print:]]/;
print "ok 639\n";

##
## Test basic $^N usage outside of a regex
##
$x = "abcdef";
$T="ok 640\n";if ($x =~ /cde/ and not defined $^N)         {print $T} else {print "not $T"};
$T="ok 641\n";if ($x =~ /(cde)/          and $^N eq "cde") {print $T} else {print "not $T"};
$T="ok 642\n";if ($x =~ /(c)(d)(e)/      and $^N eq   "e") {print $T} else {print "not $T"};
$T="ok 643\n";if ($x =~ /(c(d)e)/        and $^N eq "cde") {print $T} else {print "not $T"};
$T="ok 644\n";if ($x =~ /(foo)|(c(d)e)/  and $^N eq "cde") {print $T} else {print "not $T"};
$T="ok 645\n";if ($x =~ /(c(d)e)|(foo)/  and $^N eq "cde") {print $T} else {print "not $T"};
$T="ok 646\n";if ($x =~ /(c(d)e)|(abc)/  and $^N eq "abc") {print $T} else {print "not $T"};
$T="ok 647\n";if ($x =~ /(c(d)e)|(abc)x/ and $^N eq "cde") {print $T} else {print "not $T"};
$T="ok 648\n";if ($x =~ /(c(d)e)(abc)?/  and $^N eq "cde") {print $T} else {print "not $T"};
$T="ok 649\n";if ($x =~ /(?:c(d)e)/      and $^N eq  "d" ) {print $T} else {print "not $T"};
$T="ok 650\n";if ($x =~ /(?:c(d)e)(?:f)/ and $^N eq  "d" ) {print $T} else {print "not $T"};
$T="ok 651\n";if ($x =~ /(?:([abc])|([def]))*/ and $^N eq  "f" ){print $T} else {print "not $T"};
$T="ok 652\n";if ($x =~ /(?:([ace])|([bdf]))*/ and $^N eq  "f" ){print $T} else {print "not $T"};
$T="ok 653\n";if ($x =~ /(([ace])|([bd]))*/    and $^N eq  "e" ){print $T} else {print "not $T"};
{
 $T="ok 654\n";if($x =~ /(([ace])|([bdf]))*/   and $^N eq  "f" ){print $T} else {print "not $T"};
}
## test to see if $^N is automatically localized -- it should now
## have the value set in test 653
$T="ok 655\n";if ($^N eq  "e" ){print $T} else {print "not $T"};

##
## Now test inside (?{...})
##
$T="ok 656\n";if ($x =~ /a([abc])(?{$y=$^N})c/      and $y eq "b" ){print $T} else {print "not $T"};
$T="ok 657\n";if ($x =~ /a([abc]+)(?{$y=$^N})d/     and $y eq "bc"){print $T} else {print "not $T"};
$T="ok 658\n";if ($x =~ /a([abcdefg]+)(?{$y=$^N})d/ and $y eq "bc"){print $T} else {print "not $T"};
$T="ok 659\n";if ($x =~ /(a([abcdefg]+)(?{$y=$^N})d)(?{$z=$^N})e/ and $y eq "bc" and $z eq "abcd")
              {print $T} else {print "not $T"};
$T="ok 660\n";if ($x =~ /(a([abcdefg]+)(?{$y=$^N})de)(?{$z=$^N})/ and $y eq "bc" and $z eq "abcde")
              {print $T} else {print "not $T"};

# Test the Unicode script classes

print "not " unless chr(0x100) =~ /\p{IsLatin}/; # outside Latin-1
print "ok 661\n";

print "not " unless chr(0x212b) =~ /\p{IsLatin}/; # Angstrom sign, very outside
print "ok 662\n";

print "not " unless chr(0x5d0) =~ /\p{IsHebrew}/; # inside InHebrew
print "ok 663\n";

print "not " unless chr(0xfb4f) =~ /\p{IsHebrew}/; # outside InHebrew
print "ok 664\n";

# # singleton (not in a range, this test must be ignored on EBCDIC)
# print "not " unless chr(0xb5) =~ /\p{IsGreek}/ or ord("A") == 193;
# print "ok 665\n";
print "ok 665 # 0xb5 moved from Greek to Common with Unicode 4.0.1\n";

print "not " unless chr(0x37a) =~ /\p{IsGreek}/; # singleton
print "ok 666\n";

print "not " unless chr(0x386) =~ /\p{IsGreek}/; # singleton
print "ok 667\n";

print "not " unless chr(0x387) =~ /\P{IsGreek}/; # not there
print "ok 668\n";

print "not " unless chr(0x388) =~ /\p{IsGreek}/; # range
print "ok 669\n";

print "not " unless chr(0x38a) =~ /\p{IsGreek}/; # range
print "ok 670\n";

print "not " unless chr(0x38b) =~ /\P{IsGreek}/; # not there
print "ok 671\n";

print "not " unless chr(0x38c) =~ /\p{IsGreek}/; # singleton
print "ok 672\n";

if (ord("A") == 65) {
##
## Test [:cntrl:]...
##
## Should probably put in tests for all the POSIX stuff, but not sure how to
## guarantee a specific locale......
##
    $AllBytes = join('', map { chr($_) } 0..255);
    ($x = $AllBytes) =~ s/[[:cntrl:]]//g;
    if ($x ne join('', map { chr($_) } 0x20..0x7E, 0x80..0xFF)) {
	print "not ";
    }
    print "ok 673\n";

    ($x = $AllBytes) =~ s/[^[:cntrl:]]//g;
    if ($x ne join('', map { chr($_) } 0..0x1F, 0x7F)) { print "not " }
    print "ok 674\n";
} else {
    print "ok $_ # Skip: EBCDIC\n" for 673..674;
}
a1109 9
# With /s modifier UTF8 chars were interpreted as bytes
{
    my $a = "Hello \x{263A} World";
    
    my @@a = ($a =~ /./gs);
    
    print "not " unless $#a == 12;
    print "ok 675\n";
}
d1111 14
a1124 2
@@a = ("foo\nbar" =~ /./g);
print "ok 676\n" if @@a == 6 && "@@a" eq "f o o b a r";
a1125 2
@@a = ("foo\nbar" =~ /./gs);
print "ok 677\n" if @@a == 7 && "@@a" eq "f o o \n b a r";
d1127 12
a1138 2
@@a = ("foo\nbar" =~ /\C/g);
print "ok 678\n" if @@a == 7 && "@@a" eq "f o o \n b a r";
a1139 2
@@a = ("foo\nbar" =~ /\C/gs);
print "ok 679\n" if @@a == 7 && "@@a" eq "f o o \n b a r";
d1141 7
a1147 2
@@a = ("foo\n\x{100}bar" =~ /./g);
print "ok 680\n" if @@a == 7 && "@@a" eq "f o o \x{100} b a r";
a1148 2
@@a = ("foo\n\x{100}bar" =~ /./gs);
print "ok 681\n" if @@a == 8 && "@@a" eq "f o o \n \x{100} b a r";
d1150 4
a1153 1
($a, $b) = map { chr } ord('A') == 65 ? (0xc4, 0x80) : (0x8c, 0x41);
a1154 2
@@a = ("foo\n\x{100}bar" =~ /\C/g);
print "ok 682\n" if @@a == 9 && "@@a" eq "f o o \n $a $b b a r";
d1156 20
a1175 2
@@a = ("foo\n\x{100}bar" =~ /\C/gs);
print "ok 683\n" if @@a == 9 && "@@a" eq "f o o \n $a $b b a r";
a1176 8
{
    # [ID 20010814.004] pos() doesn't work when using =~m// in list context
    $_ = "ababacadaea";
    $a = join ":", /b./gc;
    $b = join ":", /a./gc;
    $c = pos;
    print "$a $b $c" eq 'ba:ba ad:ae 10' ? "ok 684\n" : "not ok 684\t# $a $b $c\n";
}
d1178 5
a1182 2
{
    # [ID 20010407.006] matching utf8 return values from functions does not work
a1183 1
    package ID_20010407_006;
d1185 4
a1188 2
    sub x {
	"a\x{1234}";
a1190 2
    my $x = x;
    my $y;
d1192 22
a1213 3
    $x =~ /(..)/; $y = $1;
    print "not " unless length($y) == 2 && $y eq $x;
    print "ok 685\n";
a1214 4
    x  =~ /(..)/; $y = $1;
    print "not " unless length($y) == 2 && $y eq $x;
    print "ok 686\n";
}
d1216 25
a1241 1
$test = 687;
d1243 6
a1248 3
# Force scalar context on the patern match
sub ok ($;$) {
    my($ok, $name) = @@_;
a1249 2
    printf "%sok %d - %s\n", ($ok ? "" : "not "), $test,
        ($name||$Message)."\tLine ".((caller)[2]);
d1251 18
a1268 1
    printf "# Failed test at line %d\n", (caller)[2] unless $ok;
a1269 3
    $test++;
    return $ok;
}
d1271 4
a1274 4
{
    # Check that \x## works. 5.6.1 and 5.005_03 fail some of these.
    $x = "\x4e" . "E";
    ok ($x =~ /^\x4EE$/, "Check only 2 bytes of hex are matched.");
a1275 2
    $x = "\x4e" . "i";
    ok ($x =~ /^\x4Ei$/, "Check that invalid hex digit stops it (2)");
d1277 2
a1278 2
    $x = "\x4" . "j";
    ok ($x =~ /^\x4j$/,  "Check that invalid hex digit stops it (1)");
d1280 14
a1293 2
    $x = "\x0" . "k";
    ok ($x =~ /^\xk$/,   "Check that invalid hex digit stops it (0)");
a1294 2
    $x = "\x0" . "x";
    ok ($x =~ /^\xx$/, "\\xx isn't to be treated as \\0");
d1296 11
a1306 2
    $x = "\x0" . "xa";
    ok ($x =~ /^\xxa$/, "\\xxa isn't to be treated as \\xa");
a1307 2
    $x = "\x9" . "_b";
    ok ($x =~ /^\x9_b$/, "\\x9_b isn't to be treated as \\x9b");
d1309 2
a1310 1
    print "# and now again in [] ranges\n";
d1312 14
a1325 2
    $x = "\x4e" . "E";
    ok ($x =~ /^[\x4EE]{2}$/, "Check only 2 bytes of hex are matched.");
a1326 2
    $x = "\x4e" . "i";
    ok ($x =~ /^[\x4Ei]{2}$/, "Check that invalid hex digit stops it (2)");
d1328 9
a1336 2
    $x = "\x4" . "j";
    ok ($x =~ /^[\x4j]{2}$/,  "Check that invalid hex digit stops it (1)");
a1337 2
    $x = "\x0" . "k";
    ok ($x =~ /^[\xk]{2}$/,   "Check that invalid hex digit stops it (0)");
d1339 8
a1346 2
    $x = "\x0" . "x";
    ok ($x =~ /^[\xx]{2}$/, "\\xx isn't to be treated as \\0");
a1347 2
    $x = "\x0" . "xa";
    ok ($x =~ /^[\xxa]{3}$/, "\\xxa isn't to be treated as \\xa");
d1349 6
a1354 2
    $x = "\x9" . "_b";
    ok ($x =~ /^[\x9_b]{3}$/, "\\x9_b isn't to be treated as \\x9b");
a1355 1
}
d1357 10
a1366 2
{
    # Check that \x{##} works. 5.6.1 fails quite a few of these.
a1367 2
    $x = "\x9b";
    ok ($x =~ /^\x{9_b}$/, "\\x{9_b} is to be treated as \\x9b");
d1369 7
a1375 2
    $x = "\x9b" . "y";
    ok ($x =~ /^\x{9_b}y$/, "\\x{9_b} is to be treated as \\x9b (again)");
a1376 2
    $x = "\x9b" . "y";
    ok ($x =~ /^\x{9b_}y$/, "\\x{9b_} is to be treated as \\x9b");
d1378 18
a1395 2
    $x = "\x9b" . "y";
    ok ($x =~ /^\x{9_bq}y$/, "\\x{9_bc} is to be treated as \\x9b");
a1396 2
    $x = "\x0" . "y";
    ok ($x =~ /^\x{x9b}y$/, "\\x{x9b} is to be treated as \\x0");
d1398 5
a1402 2
    $x = "\x0" . "y";
    ok ($x =~ /^\x{0x9b}y$/, "\\x{0x9b} is to be treated as \\x0");
a1403 2
    $x = "\x9b" . "y";
    ok ($x =~ /^\x{09b}y$/, "\\x{09b} is to be treated as \\x9b");
d1405 17
a1421 1
    print "# and now again in [] ranges\n";
a1422 2
    $x = "\x9b";
    ok ($x =~ /^[\x{9_b}]$/, "\\x{9_b} is to be treated as \\x9b");
d1424 18
a1441 2
    $x = "\x9b" . "y";
    ok ($x =~ /^[\x{9_b}y]{2}$/, "\\x{9_b} is to be treated as \\x9b (again)");
a1442 2
    $x = "\x9b" . "y";
    ok ($x =~ /^[\x{9b_}y]{2}$/, "\\x{9b_} is to be treated as \\x9b");
d1444 18
a1461 2
    $x = "\x9b" . "y";
    ok ($x =~ /^[\x{9_bq}y]{2}$/, "\\x{9_bc} is to be treated as \\x9b");
a1462 2
    $x = "\x0" . "y";
    ok ($x =~ /^[\x{x9b}y]{2}$/, "\\x{x9b} is to be treated as \\x0");
d1464 6
a1469 2
    $x = "\x0" . "y";
    ok ($x =~ /^[\x{0x9b}y]{2}$/, "\\x{0x9b} is to be treated as \\x0");
a1470 3
    $x = "\x9b" . "y";
    ok ($x =~ /^[\x{09b}y]{2}$/, "\\x{09b} is to be treated as \\x9b");
}
d1472 10
a1481 6
{
    # high bit bug -- japhy
    my $x = "ab\200d";
    $x =~ /.*?\200/ or print "not ";
    print "ok 715\n";
}
a1482 1
print "# some Unicode properties\n";
d1484 33
a1516 14
{
    # Dashes, underbars, case.
    print "not " unless "\x80" =~ /\p{in-latin1_SUPPLEMENT}/;
    print "ok 716\n";

    # Complement, leading and trailing whitespace.
    print "not " unless "\x80" =~ /\P{  ^  In Latin 1 Supplement  }/;
    print "ok 717\n";

    # No ^In, dashes, case, dash, any intervening (word-break) whitespace.
    # (well, newlines don't work...)
    print "not " unless "\x80" =~ /\p{latin-1   supplement}/;
    print "ok 718\n";
}
d1518 1
a1518 3
{
    print "not " unless "a" =~ /\pL/;
    print "ok 719\n";
a1519 2
    print "not " unless "a" =~ /\p{IsLl}/;
    print "ok 720\n";
d1521 4
a1524 2
    print "not " if     "a" =~ /\p{IsLu}/;
    print "ok 721\n";
d1526 5
a1530 2
    print "not " unless "a" =~ /\p{Ll}/;
    print "ok 722\n";
d1532 3
a1534 2
    print "not " if     "a" =~ /\p{Lu}/;
    print "ok 723\n";
a1535 2
    print "not " unless "A" =~ /\pL/;
    print "ok 724\n";
d1537 7
a1543 2
    print "not " unless "A" =~ /\p{IsLu}/;
    print "ok 725\n";
a1544 2
    print "not " if     "A" =~ /\p{IsLl}/;
    print "ok 726\n";
d1546 15
a1560 2
    print "not " unless "A" =~ /\p{Lu}/;
    print "ok 727\n";
a1561 2
    print "not " if     "A" =~ /\p{Ll}/;
    print "ok 728\n";
d1563 9
a1571 2
    print "not " if     "a" =~ /\PL/;
    print "ok 729\n";
a1572 2
    print "not " if     "a" =~ /\P{IsLl}/;
    print "ok 730\n";
d1574 16
a1589 2
    print "not " unless "a" =~ /\P{IsLu}/;
    print "ok 731\n";
a1590 2
    print "not " if     "a" =~ /\P{Ll}/;
    print "ok 732\n";
d1592 6
a1597 2
    print "not " unless "a" =~ /\P{Lu}/;
    print "ok 733\n";
d1599 2
a1600 2
    print "not " if     "A" =~ /\PL/;
    print "ok 734\n";
d1602 2
a1603 2
    print "not " if     "A" =~ /\P{IsLu}/;
    print "ok 735\n";
d1605 2
a1606 2
    print "not " unless "A" =~ /\P{IsLl}/;
    print "ok 736\n";
d1608 2
a1609 2
    print "not " if     "A" =~ /\P{Lu}/;
    print "ok 737\n";
d1611 2
a1612 2
    print "not " unless "A" =~ /\P{Ll}/;
    print "ok 738\n";
d1614 2
a1615 1
}
d1617 1
a1617 3
{
    print "not " if     "a" =~ /\p{Common}/;
    print "ok 739\n";
d1619 2
a1620 3
    print "not " unless "1" =~ /\p{Common}/;
    print "ok 740\n";
}
d1622 2
a1623 3
{
    print "not " if     "a"       =~ /\p{Inherited}/;
    print "ok 741\n";
d1625 2
a1626 3
    print "not " unless "\x{300}" =~ /\p{Inherited}/;
    print "ok 742\n";
}
d1628 2
a1629 4
{
    # L& and LC are the same
    print "not " unless "a" =~ /\p{LC}/ and "a" =~ /\p{L&}/;
    print "ok 743\n";
d1631 2
a1632 3
    print "not " if     "1" =~ /\p{LC}/ or "1" =~ /\p{L&}/;
    print "ok 744\n";
}
d1634 2
a1635 3
{
    print "not " unless "a" =~ /\p{Lowercase Letter}/;
    print "ok 745\n";
d1637 2
a1638 3
    print "not " if     "A" =~ /\p{lowercaseletter}/;
    print "ok 746\n";
}
d1640 1
a1640 4
{
    print "not " unless "\x{AC00}" =~ /\p{HangulSyllables}/;
    print "ok 747\n";
}
d1642 2
a1643 2
{
    # Script=, Block=, Category=
d1645 2
a1646 2
    print "not " unless "\x{0100}" =~ /\p{Script=Latin}/;
    print "ok 748\n";
d1648 2
a1649 2
    print "not " unless "\x{0100}" =~ /\p{Block=LatinExtendedA}/;
    print "ok 749\n";
d1651 2
a1652 3
    print "not " unless "\x{0100}" =~ /\p{Category=UppercaseLetter}/;
    print "ok 750\n";
}
d1654 2
a1655 2
{
    print "# the basic character classes and Unicode \n";
d1657 2
a1658 12
    # 0100;LATIN CAPITAL LETTER A WITH MACRON;Lu;0;L;0041 0304;;;;N;LATIN CAPITAL LETTER A MACRON;;;0101;
    print "not " unless "\x{0100}" =~ /\w/;
    print "ok 751\n";

    # 0660;ARABIC-INDIC DIGIT ZERO;Nd;0;AN;;0;0;0;N;;;;;
    print "not " unless "\x{0660}" =~ /\d/;
    print "ok 752\n";

    # 1680;OGHAM SPACE MARK;Zs;0;WS;;;;;N;;;;;
    print "not " unless "\x{1680}" =~ /\s/;
    print "ok 753\n";
}
d1660 2
a1661 2
{
    print "# folding matches and Unicode\n";
d1663 2
a1664 2
    print "not " unless "a\x{100}" =~ /A/i;
    print "ok 754\n";
d1666 3
a1668 2
    print "not " unless "A\x{100}" =~ /a/i;
    print "ok 755\n";
d1670 2
a1671 2
    print "not " unless "a\x{100}" =~ /a/i;
    print "ok 756\n";
d1673 2
a1674 2
    print "not " unless "A\x{100}" =~ /A/i;
    print "ok 757\n";
d1676 2
a1677 2
    print "not " unless "\x{101}a" =~ /\x{100}/i;
    print "ok 758\n";
d1679 2
a1680 2
    print "not " unless "\x{100}a" =~ /\x{100}/i;
    print "ok 759\n";
d1682 2
a1683 2
    print "not " unless "\x{101}a" =~ /\x{101}/i;
    print "ok 760\n";
d1685 1
a1685 2
    print "not " unless "\x{100}a" =~ /\x{101}/i;
    print "ok 761\n";
a1686 2
    print "not " unless "a\x{100}" =~ /A\x{100}/i;
    print "ok 762\n";
d1688 5
a1692 2
    print "not " unless "A\x{100}" =~ /a\x{100}/i;
    print "ok 763\n";
a1693 2
    print "not " unless "a\x{100}" =~ /a\x{100}/i;
    print "ok 764\n";
d1695 6
a1700 2
    print "not " unless "A\x{100}" =~ /A\x{100}/i;
    print "ok 765\n";
a1701 2
    print "not " unless "a\x{100}" =~ /[A]/i;
    print "ok 766\n";
d1703 23
a1725 2
    print "not " unless "A\x{100}" =~ /[a]/i;
    print "ok 767\n";
a1726 2
    print "not " unless "a\x{100}" =~ /[a]/i;
    print "ok 768\n";
d1728 3
a1730 2
    print "not " unless "A\x{100}" =~ /[A]/i;
    print "ok 769\n";
d1732 28
a1759 2
    print "not " unless "\x{101}a" =~ /[\x{100}]/i;
    print "ok 770\n";
a1760 2
    print "not " unless "\x{100}a" =~ /[\x{100}]/i;
    print "ok 771\n";
d1762 5
a1766 2
    print "not " unless "\x{101}a" =~ /[\x{101}]/i;
    print "ok 772\n";
d1768 2
a1769 2
    print "not " unless "\x{100}a" =~ /[\x{101}]/i;
    print "ok 773\n";
d1771 2
a1772 1
}
a1773 2
{
    use charnames ':full';
d1775 3
a1777 28
    print "# LATIN LETTER A WITH GRAVE\n";
    my $lower = "\N{LATIN SMALL LETTER A WITH GRAVE}";
    my $UPPER = "\N{LATIN CAPITAL LETTER A WITH GRAVE}";

    print $lower =~ m/$UPPER/i   ? "ok 774\n" : "not ok 774\n";
    print $UPPER =~ m/$lower/i   ? "ok 775\n" : "not ok 775\n";
    print $lower =~ m/[$UPPER]/i ? "ok 776\n" : "not ok 776\n";
    print $UPPER =~ m/[$lower]/i ? "ok 777\n" : "not ok 777\n";

    print "# GREEK LETTER ALPHA WITH VRACHY\n";

    $lower = "\N{GREEK CAPITAL LETTER ALPHA WITH VRACHY}";
    $UPPER = "\N{GREEK SMALL LETTER ALPHA WITH VRACHY}";

    print $lower =~ m/$UPPER/i   ? "ok 778\n" : "not ok 778\n";
    print $UPPER =~ m/$lower/i   ? "ok 779\n" : "not ok 779\n";
    print $lower =~ m/[$UPPER]/i ? "ok 780\n" : "not ok 780\n";
    print $UPPER =~ m/[$lower]/i ? "ok 781\n" : "not ok 781\n";

    print "# LATIN LETTER Y WITH DIAERESIS\n";

    $lower = "\N{LATIN CAPITAL LETTER Y WITH DIAERESIS}";
    $UPPER = "\N{LATIN SMALL LETTER Y WITH DIAERESIS}";
    print $lower =~ m/$UPPER/i   ? "ok 782\n" : "not ok 782\n";
    print $UPPER =~ m/$lower/i   ? "ok 783\n" : "not ok 783\n";
    print $lower =~ m/[$UPPER]/i ? "ok 784\n" : "not ok 784\n";
    print $UPPER =~ m/[$lower]/i ? "ok 785\n" : "not ok 785\n";
}
d1779 14
a1792 5
{
    use warnings;
    use charnames ':full';
    
    print "# GREEK CAPITAL LETTER SIGMA vs COMBINING GREEK PERISPOMENI\n";
a1793 2
    my $SIGMA = "\N{GREEK CAPITAL LETTER SIGMA}";
    my $char  = "\N{COMBINING GREEK PERISPOMENI}";
d1795 2
a1796 3
    # Before #13843 this was failing by matching falsely.
    print "_:$char:_" =~ m/_:$SIGMA:_/i ? "not ok 786\n" : "ok 786\n";
}
d1798 19
a1816 2
{
    print "# \\X\n";
d1818 3
a1820 18
    use charnames ':full';

    print "a!"              =~ /^(\X)!/ && $1 eq "a" ?
	"ok 787\n" : "not ok 787 # $1\n";
    print "\xDF!"           =~ /^(\X)!/ && $1 eq "\xDF" ?
	"ok 788\n" : "not ok 788 # $1\n";
    print "\x{100}!"        =~ /^(\X)!/ && $1 eq "\x{100}" ?
	"ok 789\n" : "not ok 789 # $1\n";
    print "\x{100}\x{300}!" =~ /^(\X)!/ && $1 eq "\x{100}\x{300}" ?
	"ok 790\n" : "not ok 790 # $1\n";
    print "\N{LATIN CAPITAL LETTER E}!" =~ /^(\X)!/ &&
	$1 eq "\N{LATIN CAPITAL LETTER E}" ?
	"ok 791\n" : "not ok 791 # $1\n";
    print "\N{LATIN CAPITAL LETTER E}\N{COMBINING GRAVE ACCENT}!" =~
	/^(\X)!/ &&
	$1 eq "\N{LATIN CAPITAL LETTER E}\N{COMBINING GRAVE ACCENT}" ?
	"ok 792\n" : "not ok 792 # $1\n";
}
d1822 3
a1824 2
{
    print "#\\C and \\X\n";
d1826 1
a1826 3
    print "!abc!" =~ /a\Cc/ ? "ok 793\n" : "not ok 793\n";
    print "!abc!" =~ /a\Xc/ ? "ok 794\n" : "not ok 794\n";
}
d1828 1
a1828 2
{
    print "# FINAL SIGMA\n";
d1830 3
a1832 28
    my $SIGMA = "\x{03A3}"; # CAPITAL
    my $Sigma = "\x{03C2}"; # SMALL FINAL
    my $sigma = "\x{03C3}"; # SMALL

    print $SIGMA =~ /$SIGMA/i ? "ok 795\n" : "not ok 795\n";
    print $SIGMA =~ /$Sigma/i ? "ok 796\n" : "not ok 796\n";
    print $SIGMA =~ /$sigma/i ? "ok 797\n" : "not ok 797\n";

    print $Sigma =~ /$SIGMA/i ? "ok 798\n" : "not ok 798\n";
    print $Sigma =~ /$Sigma/i ? "ok 799\n" : "not ok 799\n";
    print $Sigma =~ /$sigma/i ? "ok 800\n" : "not ok 800\n";

    print $sigma =~ /$SIGMA/i ? "ok 801\n" : "not ok 801\n";
    print $sigma =~ /$Sigma/i ? "ok 802\n" : "not ok 802\n";
    print $sigma =~ /$sigma/i ? "ok 803\n" : "not ok 803\n";
    
    print $SIGMA =~ /[$SIGMA]/i ? "ok 804\n" : "not ok 804\n";
    print $SIGMA =~ /[$Sigma]/i ? "ok 805\n" : "not ok 805\n";
    print $SIGMA =~ /[$sigma]/i ? "ok 806\n" : "not ok 806\n";

    print $Sigma =~ /[$SIGMA]/i ? "ok 807\n" : "not ok 807\n";
    print $Sigma =~ /[$Sigma]/i ? "ok 808\n" : "not ok 808\n";
    print $Sigma =~ /[$sigma]/i ? "ok 809\n" : "not ok 809\n";

    print $sigma =~ /[$SIGMA]/i ? "ok 810\n" : "not ok 810\n";
    print $sigma =~ /[$Sigma]/i ? "ok 811\n" : "not ok 811\n";
    print $sigma =~ /[$sigma]/i ? "ok 812\n" : "not ok 812\n";
}
d1834 4
a1837 2
{
    print "# parlez-vous?\n";
a1838 1
    use charnames ':full';
d1840 38
a1877 64
    print "fran\N{LATIN SMALL LETTER C}ais" =~
	  /fran.ais/ &&
	$& eq "francais" ?
	"ok 813\n" : "not ok 813\n";

    print "fran\N{LATIN SMALL LETTER C WITH CEDILLA}ais" =~
	  /fran.ais/ &&
	$& eq "fran\N{LATIN SMALL LETTER C WITH CEDILLA}ais" ?
	"ok 814\n" : "not ok 814\n";

    print "fran\N{LATIN SMALL LETTER C}ais" =~
	   /fran\Cais/ &&
        $& eq "francais" ?
	"ok 815\n" : "not ok 815\n";

    print "franc\N{COMBINING CEDILLA}ais" =~
	  /franc\C\Cais/ ? # COMBINING CEDILLA is two bytes when encoded
	"ok 816\n" : "not ok 816\n";

    print "fran\N{LATIN SMALL LETTER C}ais" =~
	  /fran\Xais/ &&
	$& eq "francais" ?
	"ok 817\n" : "not ok 817\n";

    print "fran\N{LATIN SMALL LETTER C WITH CEDILLA}ais" =~
	  /fran\Xais/  &&
        $& eq "fran\N{LATIN SMALL LETTER C WITH CEDILLA}ais" ?
	"ok 818\n" : "not ok 818\n";

    print "franc\N{COMBINING CEDILLA}ais" =~
	  /fran\Xais/ &&
         $& eq "franc\N{COMBINING CEDILLA}ais" ?
	 "ok 819\n" : "not ok 819\n";

    print "fran\N{LATIN SMALL LETTER C WITH CEDILLA}ais" =~
	  /fran\N{LATIN SMALL LETTER C WITH CEDILLA}ais/  &&
        $& eq "fran\N{LATIN SMALL LETTER C WITH CEDILLA}ais" ?
	"ok 820\n" : "not ok 820\n";

    print "franc\N{COMBINING CEDILLA}ais" =~
	  /franc\N{COMBINING CEDILLA}ais/  &&
        $& eq "franc\N{COMBINING CEDILLA}ais" ?
	"ok 821\n" : "not ok 821\n";

    print "fran\N{LATIN SMALL LETTER C}ais" =~
	  /fran(?:c\N{COMBINING CEDILLA}?|\N{LATIN SMALL LETTER C WITH CEDILLA})ais/ &&
	$& eq "francais" ?
	"ok 822\n" : "not ok 822\n";

    print "fran\N{LATIN SMALL LETTER C}ais" =~
	  /fran(?:c\N{COMBINING CEDILLA}?|\N{LATIN SMALL LETTER C WITH CEDILLA})ais/ &&
	$& eq "francais" ?
	"ok 823\n" : "not ok 823\n";

    print "fran\N{LATIN SMALL LETTER C WITH CEDILLA}ais" =~
	  /fran(?:c\N{COMBINING CEDILLA}?|\N{LATIN SMALL LETTER C WITH CEDILLA})ais/ &&
	$& eq "fran\N{LATIN SMALL LETTER C WITH CEDILLA}ais" ?
	"ok 824\n" : "not ok 824\n";

    print "franc\N{COMBINING CEDILLA}ais" =~
	  /fran(?:c\N{COMBINING CEDILLA}?|\N{LATIN SMALL LETTER C WITH CEDILLA})ais/ &&
	$& eq "franc\N{COMBINING CEDILLA}ais" ?
	"ok 825\n" : "not ok 825\n";
}
a1878 2
{
    print "# Does lingering (and useless) UTF8 flag mess up /i matching?\n";
d1881 16
a1896 8
	my $regex  = "ABcde";
	my $string = "abcDE\x{100}";
	chop($string);
	if ($string =~ m/$regex/i) {
	    print "ok 826\n";
	} else {
	    print "not ok 826\n";
	}
a1898 10
    {
	my $regex  = "ABcde\x{100}";
	my $string = "abcDE";
	chop($regex);
	if ($string =~ m/$regex/i) {
	    print "ok 827\n";
	} else {
	    print "not ok 827\n";
	}
    }
d1901 28
a1928 9
	my $regex  = "ABcde\x{100}";
	my $string = "abcDE\x{100}";
	chop($regex);
	chop($string);
	if ($string =~ m/$regex/i) {
	    print "ok 828\n";
	} else {
	    print "not ok 828\n";
	}
a1929 1
}
a1930 2
{
    print "# more SIGMAs\n";
d1932 2
a1933 20
    my $SIGMA = "\x{03A3}"; # CAPITAL
    my $Sigma = "\x{03C2}"; # SMALL FINAL
    my $sigma = "\x{03C3}"; # SMALL

    my $S3 = "$SIGMA$Sigma$sigma";

    print ":$S3:" =~ /:(($SIGMA)+):/i   && $1 eq $S3 && $2 eq $sigma ?
	"ok 829\n" : "not ok 829\n";
    print ":$S3:" =~ /:(($Sigma)+):/i   && $1 eq $S3 && $2 eq $sigma ?
	"ok 830\n" : "not ok 830\n";
    print ":$S3:" =~ /:(($sigma)+):/i   && $1 eq $S3 && $2 eq $sigma ?
	"ok 831\n" : "not ok 831\n";

    print ":$S3:" =~ /:(([$SIGMA])+):/i && $1 eq $S3 && $2 eq $sigma ?
	"ok 832\n" : "not ok 832\n";
    print ":$S3:" =~ /:(([$Sigma])+):/i && $1 eq $S3 && $2 eq $sigma ?
	"ok 833\n" : "not ok 833\n";
    print ":$S3:" =~ /:(([$sigma])+):/i && $1 eq $S3 && $2 eq $sigma ?
	"ok 834\n" : "not ok 834\n";
}
d1935 24
a1958 2
{
    print "# LATIN SMALL LETTER SHARP S\n";
d1960 6
a1965 1
    use charnames ':full';
d1967 5
a1971 1
    $test= 835;
d1973 6
a1978 2
    ok("\N{LATIN SMALL LETTER SHARP S}" =~ /\N{LATIN SMALL LETTER SHARP S}/);
    ok("\N{LATIN SMALL LETTER SHARP S}" =~ /\N{LATIN SMALL LETTER SHARP S}/i);
a1979 2
    ok("\N{LATIN SMALL LETTER SHARP S}" =~ /[\N{LATIN SMALL LETTER SHARP S}]/);
    ok("\N{LATIN SMALL LETTER SHARP S}" =~ /[\N{LATIN SMALL LETTER SHARP S}]/i);
d1981 3
a1983 4
    ok("ss" =~ /\N{LATIN SMALL LETTER SHARP S}/i);
    ok("SS" =~ /\N{LATIN SMALL LETTER SHARP S}/i);
    ok("ss" =~ /[\N{LATIN SMALL LETTER SHARP S}]/i);
    ok("SS" =~ /[\N{LATIN SMALL LETTER SHARP S}]/i);
d1985 17
a2001 3
    ok("\N{LATIN SMALL LETTER SHARP S}" =~ /ss/i);
    ok("\N{LATIN SMALL LETTER SHARP S}" =~ /SS/i);
}
d2003 6
a2008 2
{
    print "# more whitespace: U+0085, U+2028, U+2029\n";
d2010 1
a2010 5
    # U+0085 needs to be forced to be Unicode, the \x{100} does that.
    if ($ordA == 193) {
	print "<\x{100}\x{0085}>" =~ /<\x{100}e>/ ? "ok 845\n" : "not ok 845\n";
    } else {
	print "<\x{100}\x{0085}>" =~ /<\x{100}\s>/ ? "ok 845\n" : "not ok 845\n";
a2011 3
    print "<\x{2028}>" =~ /<\s>/ ? "ok 846\n" : "not ok 846\n";
    print "<\x{2029}>" =~ /<\s>/ ? "ok 847\n" : "not ok 847\n";
}
a2012 2
{
    print "# . with /s should work on characters, as opposed to bytes\n";
d2014 11
a2024 1
    my $s = "\x{e4}\x{100}";
a2025 4
    # This is not expected to match: the point is that
    # neither should we get "Malformed UTF-8" warnings.
    print $s =~ /\G(.+?)\n/gcs ?
	"not ok 848\n" : "ok 848\n";
d2027 14
a2040 4
    my @@c;

    while ($s =~ /\G(.)/gs) {
	push @@c, $1;
a2042 1
    print join("", @@c) eq $s ? "ok 849\n" : "not ok 849\n";
d2044 13
a2056 4
    my $t1 = "Q003\n\n\x{e4}\x{f6}\n\nQ004\n\n\x{e7}"; # test only chars < 256
    my $r1 = "";
    while ($t1 =~ / \G ( .+? ) \n\s+ ( .+? ) ( $ | \n\s+ ) /xgcs) {
	$r1 .= $1 . $2;
d2059 11
a2069 4
    my $t2 = $t1 . "\x{100}"; # repeat with a larger char
    my $r2 = "";
    while ($t2 =~ / \G ( .+? ) \n\s+ ( .+? ) ( $ | \n\s+ ) /xgcs) {
	$r2 .= $1 . $2;
a2070 3
    $r2 =~ s/\x{100}//;
    print $r1 eq $r2 ? "ok 850\n" : "not ok 850\n";
}
a2071 2
{
    print "# Unicode lookbehind\n";
d2073 9
a2081 5
    print "A\x{100}B"        =~ /(?<=A.)B/  ? "ok 851\n" : "not ok 851\n";
    print "A\x{200}\x{300}B" =~ /(?<=A..)B/ ? "ok 852\n" : "not ok 852\n";
    print "\x{400}AB"        =~ /(?<=\x{400}.)B/ ? "ok 853\n" : "not ok 853\n";
    print "\x{500\x{600}}B"  =~ /(?<=\x{500}.)B/ ? "ok 854\n" : "not ok 854\n";
}
d2083 2
a2084 14
{
    print "# UTF-8 hash keys and /\$/\n";
    # http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/2002-01/msg01327.html

    my $u = "a\x{100}";
    my $v = substr($u,0,1);
    my $w = substr($u,1,1);
    my %u = ( $u => $u, $v => $v, $w => $w );
    my $i = 855; 
    for (keys %u) {
	my $m1 = /^\w*$/ ? 1 : 0;
	my $m2 = $u{$_}=~/^\w*$/ ? 1 : 0;
	print $m1 == $m2 ? "ok $i\n" : "not ok $i # $m1 $m2\n";
	$i++;
a2085 1
}
a2086 15
{
    print "# [ID 20020124.005]\n";
    # Fixed by #14795.
    my $i = 858;
    for my $char ("a", "\x{df}", "\x{100}"){
	$x = "$char b $char";
	$x =~ s{($char)}{
	    "c" =~ /c/;
	    "x";
	}ge;
	print substr($x,0,1) eq substr($x,-1,1) ?
	    "ok $i\n" : "not ok $i # debug: $x\n";
 	$i++;
   }
}
d2088 30
a2117 6
{
    print "# SEGV in s/// and UTF-8\n";
    $s = "s#\x{100}" x 4;
    $s =~ s/[^\w]/ /g;
    print $s eq "s \x{100}" x 4 ? "ok 861\n" : "not ok 861\n";
}
a2118 11
{
    print "# UTF-8 bug (maybe alreayd known?)\n";
    my $u;

    $u = "foo";
    $u =~ s/./\x{100}/g;
    print $u eq "\x{100}\x{100}\x{100}" ? "ok 862\n" : "not ok 862\n";

    $u = "foobar";
    $u =~ s/[ao]/\x{100}/g;
    print $u eq "f\x{100}\x{100}b\x{100}r" ? "ok 863\n" : "not ok 863\n";
d2120 8
a2127 43
    $u =~ s/\x{100}/e/g;
    print $u eq "feeber" ? "ok 864\n" : "not ok 864\n";
}

{
    print "# UTF-8 bug with s///\n";
    # check utf8/non-utf8 mixtures
    # try to force all float/anchored check combinations
    my $c = "\x{100}";
    $test = 865;
    my $subst;
    for my $re (
	"xx.*$c", "x.*$c$c", "$c.*xx", "$c$c.*x", "xx.*(?=$c)", "(?=$c).*xx",
    ) {
	print "xxx" =~ /$re/ ? "not ok $test\n" : "ok $test\n";
	++$test;
	print +($subst = "xxx") =~ s/$re// ? "not ok $test\n" : "ok $test\n";
	++$test;
    }
    for my $re ("xx.*$c*", "$c*.*xx") {
	print "xxx" =~ /$re/ ? "ok $test\n" : "not ok $test\n";
	++$test;
	($subst = "xxx") =~ s/$re//;
	print $subst eq '' ? "ok $test\n" : "not ok $test\t# $subst\n";
	++$test;
    }
    for my $re ("xxy*", "y*xx") {
	print "xx$c" =~ /$re/ ? "ok $test\n" : "not ok $test\n";
	++$test;
	($subst = "xx$c") =~ s/$re//;
	print $subst eq $c ? "ok $test\n" : "not ok $test\n";
	++$test;
	print "xy$c" =~ /$re/ ? "not ok $test\n" : "ok $test\n";
	++$test;
	print +($subst = "xy$c") =~ /$re/ ? "not ok $test\n" : "ok $test\n";
	++$test;
    }
    for my $re ("xy$c*z", "x$c*yz") {
	print "xyz" =~ /$re/ ? "ok $test\n" : "not ok $test\n";
	++$test;
	($subst = "xyz") =~ s/$re//;
	print $subst eq '' ? "ok $test\n" : "not ok $test\n";
	++$test;
a2128 1
}
a2129 3
{
    print "# qr/.../x\n";
    $test = 893;
d2131 3
a2133 1
    my $R = qr/ A B C # D E/x;
d2135 14
a2148 2
    print eval {"ABCDE" =~ $R} ? "ok $test\n" : "not ok $test\n";
    $test++;
a2149 2
    print eval {"ABCDE" =~ m/$R/} ? "ok $test\n" : "not ok $test\n";
    $test++;
d2151 14
a2164 3
    print eval {"ABCDE" =~ m/($R)/} ? "ok $test\n" : "not ok $test\n";
    $test++;
}
a2165 3
{
    print "# illegal Unicode properties\n";
    $test = 896;
d2167 38
a2204 2
    print eval { "a" =~ /\pq / }      ? "not ok $test\n" : "ok $test\n";
    $test++;
a2205 3
    print eval { "a" =~ /\p{qrst} / } ? "not ok $test\n" : "ok $test\n";
    $test++;
}
d2207 6
a2212 21
{
    print "# [ID 20020412.005] wrong pmop flags checked when empty pattern\n";
    # requires reuse of last successful pattern
    $test = 898;
    $test =~ /\d/;
    for (0 .. 1) {
	my $match = ?? + 0;
	if ($match != $_) {
	    print "ok $test\n";
	} else {
	    printf "not ok %s\t# 'match once' %s on %s iteration\n", $test,
		    $match ? 'succeeded' : 'failed', $_ ? 'second' : 'first';
	}
	++$test;
    }
    $test =~ /(\d)/;
    my $result = join '', $test =~ //g;
    if ($result eq $test) {
	print "ok $test\n";
    } else {
	printf "not ok %s\t# expected '%s', got '%s'\n", $test, $test, $result;
a2213 2
    ++$test;
}
a2214 1
print "# user-defined character properties\n";
d2216 5
a2220 6
sub InKana1 {
    return <<'END';
3040	309F
30A0	30FF
END
}
d2222 2
a2223 6
sub InKana2 {
    return <<'END';
+utf8::InHiragana
+utf8::InKatakana
END
}
d2225 2
a2226 7
sub InKana3 {
    return <<'END';
+utf8::InHiragana
+utf8::InKatakana
-utf8::IsCn
END
}
d2228 2
a2229 7
sub InNotKana {
    return <<'END';
!utf8::InHiragana
-utf8::InKatakana
+utf8::IsCn
END
}
d2231 1
a2231 1
$test = 901;
d2233 4
a2236 2
print "\x{3040}" =~ /\p{InKana1}/ ? "ok $test\n" : "not ok $test\n"; $test++;
print "\x{303F}" =~ /\P{InKana1}/ ? "ok $test\n" : "not ok $test\n"; $test++;
d2238 2
a2239 2
print "\x{3040}" =~ /\p{InKana2}/ ? "ok $test\n" : "not ok $test\n"; $test++;
print "\x{303F}" =~ /\P{InKana2}/ ? "ok $test\n" : "not ok $test\n"; $test++;
d2241 2
a2242 16
print "\x{3041}" =~ /\p{InKana3}/ ? "ok $test\n" : "not ok $test\n"; $test++;
print "\x{3040}" =~ /\P{InKana3}/ ? "ok $test\n" : "not ok $test\n"; $test++;

print "\x{3040}" =~ /\p{InNotKana}/ ? "ok $test\n" : "not ok $test\n"; $test++;
print "\x{3041}" =~ /\P{InNotKana}/ ? "ok $test\n" : "not ok $test\n"; $test++;

sub InConsonant { # Not EBCDIC-aware.
    return <<EOF;
0061	007f
-0061
-0065
-0069
-006f
-0075
EOF
}
d2244 3
a2246 2
print "d" =~ /\p{InConsonant}/ ? "ok $test\n" : "not ok $test\n"; $test++;
print "e" =~ /\P{InConsonant}/ ? "ok $test\n" : "not ok $test\n"; $test++;
d2248 1
a2248 16
{
    print "# [ID 20020630.002] utf8 regex only matches 32k\n";
    $test = 911;
    for ([ 'byte', "\x{ff}" ], [ 'utf8', "\x{1ff}" ]) {
	my($type, $char) = @@$_;
	for my $len (32000, 32768, 33000) {
	    my $s = $char . "f" x $len;
	    my $r = $s =~ /$char([f]*)/gc;
	    print $r ? "ok $test\n" : "not ok $test\t# <$type x $len> fail\n";
	    ++$test;
	    print +(!$r or pos($s) == $len + 1) ? "ok $test\n"
		: "not ok $test\t# <$type x $len> pos @@{[ pos($s) ]}\n";
	    ++$test;
	}
    }
}
d2250 6
a2255 1
$test = 923;
d2257 2
a2258 4
$a = bless qr/foo/, 'Foo';
print(('goodfood' =~ $a ? '' : 'not '),
	"ok $test\t# reblessed qr// matches\n");
++$test;
d2260 2
a2261 3
print(($a eq '(?-xism:foo)' ? '' : 'not '),
	"ok $test\t# reblessed qr// stringizes\n");
++$test;
d2263 3
a2265 2
$x = "\x{3fe}";
$z=$y = "\317\276"; # $y is byte representation of $x
d2267 10
a2276 3
$a = qr/$x/;
print(($x =~ $a ? '' : 'not '), "ok $test - utf8 interpolation in qr//\n");
++$test;
a2277 3
print(("a$a" =~ $x ? '' : 'not '),
      "ok $test - stringifed qr// preserves utf8\n");
++$test;
d2279 9
a2287 3
print(("a$x" =~ /^a$a\z/ ? '' : 'not '),
      "ok $test - interpolated qr// preserves utf8\n");
++$test;
a2288 3
print(("a$x" =~ /^a(??{$a})\z/ ? '' : 'not '),
      "ok $test - postponed interpolation of qr// preserves utf8\n");
++$test;
d2290 7
a2296 3
print((length(qr/##/x) == 12 ? '' : 'not '),
      "ok $test - ## in qr// doesn't corrupt memory [perl #17776]\n");
++$test;
a2297 1
{ use re 'eval';
d2299 9
a2307 3
print(("$x$x" =~ /^$x(??{$x})\z/ ? '' : 'not '),
      "ok $test - postponed utf8 string in utf8 re matches utf8\n");
++$test;
a2308 3
print(("$y$x" =~ /^$y(??{$x})\z/ ? '' : 'not '),
      "ok $test - postponed utf8 string in non-utf8 re matches utf8\n");
++$test;
a2309 3
print(("$y$x" !~ /^$y(??{$y})\z/ ? '' : 'not '),
      "ok $test - postponed non-utf8 string in non-utf8 re doesn't match utf8\n");
++$test;
d2311 9
a2319 3
print(("$x$x" !~ /^$x(??{$y})\z/ ? '' : 'not '),
      "ok $test - postponed non-utf8 string in utf8 re doesn't match utf8\n");
++$test;
a2320 3
print(("$y$y" =~ /^$y(??{$y})\z/ ? '' : 'not '),
      "ok $test - postponed non-utf8 string in non-utf8 re matches non-utf8\n");
++$test;
d2322 9
a2330 4
print(("$x$y" =~ /^$x(??{$y})\z/ ? '' : 'not '),
      "ok $test - postponed non-utf8 string in utf8 re matches non-utf8\n");
++$test;
$y = $z; # reset $y after upgrade
d2332 2
a2333 4
print(("$x$y" !~ /^$x(??{$x})\z/ ? '' : 'not '),
      "ok $test - postponed utf8 string in utf8 re doesn't match non-utf8\n");
++$test;
$y = $z; # reset $y after upgrade
d2335 3
a2337 3
print(("$y$y" !~ /^$y(??{$x})\z/ ? '' : 'not '),
      "ok $test - postponed utf8 string in non-utf8 re doesn't match non-utf8\n");
++$test;
a2338 1
} # no re 'eval'
d2340 8
a2347 1
print "# more user-defined character properties\n";
d2349 12
a2360 6
sub IsSyriac1 {
    return <<'END';
0712	072C
0730	074A
END
}
a2361 2
ok("\x{0712}" =~ /\p{IsSyriac1}/, '\x{0712}, \p{IsSyriac1}');
ok("\x{072F}" =~ /\P{IsSyriac1}/, '\x{072F}, \P{IsSyriac1}');
d2363 6
a2368 6
sub Syriac1 {
    return <<'END';
0712	072C
0730	074A
END
}
d2370 9
a2378 2
ok("\x{0712}" =~ /\p{Syriac1}/, '\x{0712}, \p{Syriac1}');
ok("\x{072F}" =~ /\P{Syriac1}/, '\x{072F}, \p{Syriac1}');
d2380 2
a2381 15
print "# user-defined character properties may lack \\n at the end\n";
sub InGreekSmall   { return "03B1\t03C9" }
sub InGreekCapital { return "0391\t03A9\n-03A2" }

ok("\x{03C0}" =~ /\p{InGreekSmall}/,   "Small pi");
ok("\x{03C2}" =~ /\p{InGreekSmall}/,   "Final sigma");
ok("\x{03A0}" =~ /\p{InGreekCapital}/, "Capital PI");
ok("\x{03A2}" =~ /\P{InGreekCapital}/, "Reserved");

sub AsciiHexAndDash {
    return <<'END';
+utf8::ASCII_Hex_Digit
+utf8::Dash
END
}
a2382 15
ok("-" =~ /\p{Dash}/,            "'-' is Dash");
ok("A" =~ /\p{ASCII_Hex_Digit}/, "'A' is ASCII_Hex_Digit");
ok("-" =~ /\p{AsciiHexAndDash}/, "'-' is AsciiHexAndDash");
ok("A" =~ /\p{AsciiHexAndDash}/, "'A' is AsciiHexAndDash");

{
    print "# Change #18179\n";
    # previously failed with "panic: end_shift
    my $s = "\x{100}" x 5;
    my $ok = $s =~ /(\x{100}{4})/;
    my($ord, $len) = (ord $1, length $1);
    print +($ok && $ord == 0x100 && $len == 4)
	    ? "ok $test\n" : "not ok $test\t# [#18179] $ok/$ord/$len\n";
    ++$test;
}
d2384 10
a2393 2
{
    print "# [perl #15763]\n";
a2394 3
    $a = "x\x{100}";
    chop $a; # but leaves the UTF-8 flag
    $a .= "y"; # 1 byte before "y"
d2396 8
a2403 2
    ok($a =~ /^\C/,      'match one \C on 1-byte UTF-8');
    ok($a =~ /^\C{1}/,   'match \C{1}');
a2404 2
    ok($a =~ /^\Cy/,      'match \Cy');
    ok($a =~ /^\C{1}y/,   'match \C{1}y');
d2406 3
a2408 1
    $a = "\x{100}y"; # 2 bytes before "y"
a2409 4
    ok($a =~ /^\C/,       'match one \C on 2-byte UTF-8');
    ok($a =~ /^\C{1}/,    'match \C{1}');
    ok($a =~ /^\C\C/,     'match two \C');
    ok($a =~ /^\C{2}/,    'match \C{2}');
d2411 9
a2419 2
    ok($a =~ /^\C\C\C/,    'match three \C on 2-byte UTF-8 and a byte');
    ok($a =~ /^\C{3}/,     'match \C{3}');
a2420 2
    ok($a =~ /^\C\Cy/,     'match two \C');
    ok($a =~ /^\C{2}y/,    'match \C{2}');
d2422 7
a2428 2
    ok($a !~ /^\C\C\Cy/,    q{don't match three \Cy});
    ok($a !~ /^\C{2}\Cy/,   q{don't match \C{3}y});
a2429 1
    $a = "\x{1000}y"; # 3 bytes before "y"
d2431 5
a2435 6
    ok($a =~ /^\C/,         'match one \C on three-byte UTF-8');
    ok($a =~ /^\C{1}/,      'match \C{1}');
    ok($a =~ /^\C\C/,       'match two \C');
    ok($a =~ /^\C{2}/,      'match \C{2}');
    ok($a =~ /^\C\C\C/,     'match three \C');
    ok($a =~ /^\C{3}/,      'match \C{3}');
a2436 2
    ok($a =~ /^\C\C\C\C/,   'match four \C on three-byte UTF-8 and a byte');
    ok($a =~ /^\C{4}/,      'match \C{4}');
d2438 23
a2460 2
    ok($a =~ /^\C\C\Cy/,    'match three \Cy');
    ok($a =~ /^\C{3}y/,     'match \C{3}y');
a2461 3
    ok($a !~ /^\C\C\C\C\y/, q{don't match four \Cy});
    ok($a !~ /^\C{4}y/,     q{don't match \C{4}y});
}
d2463 6
a2468 35
$_ = 'aaaaaaaaaa';
utf8::upgrade($_); chop $_; $\="\n";
ok(/[^\s]+/, "m/[^\s]/ utf8");
ok(/[^\d]+/, "m/[^\d]/ utf8");
ok(($a = $_, $_ =~ s/[^\s]+/./g), "s/[^\s]/ utf8");
ok(($a = $_, $a =~ s/[^\d]+/./g), "s/[^\s]/ utf8");

ok("\x{100}" =~ /\x{100}/, "[perl #15397]");
ok("\x{100}" =~ /(\x{100})/, "[perl #15397]");
ok("\x{100}" =~ /(\x{100}){1}/, "[perl #15397]");
ok("\x{100}\x{100}" =~ /(\x{100}){2}/, "[perl #15397]");
ok("\x{100}\x{100}" =~ /(\x{100})(\x{100})/, "[perl #15397]");

$x = "CD";
$x =~ /(AB)*?CD/;
ok(!defined $1, "[perl #7471]");

$x = "CD";
$x =~ /(AB)*CD/;
ok(!defined $1, "[perl #7471]");

$pattern = "^(b+?|a){1,2}c";
ok("bac"    =~ /$pattern/ && $1 eq 'a', "[perl #3547]");
ok("bbac"   =~ /$pattern/ && $1 eq 'a', "[perl #3547]");
ok("bbbac"  =~ /$pattern/ && $1 eq 'a', "[perl #3547]");
ok("bbbbac" =~ /$pattern/ && $1 eq 'a', "[perl #3547]");

{
    # [perl #18232]
    "\x{100}" =~ /(.)/;
    ok( $1 eq "\x{100}", '$1 is utf-8 [perl #18232]' );
    { 'a' =~ /./; }
    ok( $1 eq "\x{100}", '$1 is still utf-8' );
    ok( $1 ne "\xC4\x80", '$1 is not non-utf-8' );
}
a2469 7
{
    use utf8;
    my $attr = 'Name-1' ;

    my $NormalChar          = qr/[\p{IsDigit}\p{IsLower}\p{IsUpper}]/;
    my $NormalWord          = qr/${NormalChar}+?/;
    my $PredNameHyphen      = qr/^${NormalWord}(\-${NormalWord})*?$/;
d2471 4
a2474 3
    $attr =~ /^$/;
    ok( $attr =~ $PredNameHyphen, "[perl #19767] original test" );
}
a2475 5
{
    use utf8;
    "a" =~ m/[b]/;
    ok ( "0" =~ /\p{N}+\z/, "[perl #19767] variant test" );
}
d2477 2
a2478 1
{
d2480 2
a2481 12
    $p = 1;
    foreach (1,2,3,4) {
	    $p++ if /(??{ $p })/
    }
    ok ($p == 5, "[perl #20683] (??{ }) returns stale values");
    { package P; $a=1; sub TIESCALAR { bless[] } sub FETCH { $a++ } }
    tie $p, P;
    foreach (1,2,3,4) {
	    /(??{ $p })/
    }
    ok ( $p == 5, "(??{ }) returns stale values");
}
d2483 2
a2484 9
{
  # Subject: Odd regexp behavior
  # From: Markus Kuhn <Markus.Kuhn@@cl.cam.ac.uk>
  # Date: Wed, 26 Feb 2003 16:53:12 +0000
  # Message-Id: <E18o4nw-0008Ly-00@@wisbech.cl.cam.ac.uk>
  # To: perl-unicode@@perl.org
    
  $x = "\x{2019}\nk"; $x =~ s/(\S)\n(\S)/$1 $2/sg;
  ok($x eq "\x{2019} k", "Markus Kuhn 2003-02-26");
d2486 2
a2487 2
  $x = "b\nk"; $x =~ s/(\S)\n(\S)/$1 $2/sg;
  ok($x eq "b k", "Markus Kuhn 2003-02-26");
d2489 3
a2491 2
  ok("\x{2019}" =~ /\S/, "Markus Kuhn 2003-02-26");
}
a2492 8
{
    my $i;
    ok('-1-3-5-' eq join('', split /((??{$i++}))/, '-1-3-5-'),
	"[perl #21411] (??{ .. }) corrupts split's stack");
    split /(?{'WOW'})/, 'abc';
    ok('a|b|c' eq join ('|', @@_),
       "[perl #21411] (?{ .. }) version of the above");
}
d2494 48
a2541 7
{
    # XXX DAPM 13-Apr-06. Recursive split is still broken. It's only luck it
    # hasn't been crashing. Disable this test until it is fixed properly.
    # XXX also check what it returns rather than just doing ok(1,...)
    # split /(?{ split "" })/, "abc";
    ok(1,'cache_re & "(?{": it dumps core in 5.6.1 & 5.8.0');
}
a2542 3
{
    ok("\x{100}\n" =~ /\x{100}\n$/, "UTF8 length cache and fbm_compile");  
}
d2544 16
a2559 9
{
    package Str;
    use overload q/""/ => sub { ${$_[0]}; };
    sub new { my ($c, $v) = @@_; bless \$v, $c; }

    package main;
    $_ = Str->new("a\x{100}/\x{100}b");
    ok(join(":", /\b(.)\x{100}/g) eq "a:/", "re_intuit_start and PL_bostr");
}
a2560 6
{
    $_ = "code:   'x' { '...' }\n"; study;
    my @@x; push @@x, $& while m/'[^\']*'/gx;
    ok(join(":", @@x) eq "'x':'...'",
       "[perl #17757] Parse::RecDescent triggers infinite loop");
}
d2562 6
a2567 5
{
    my $re = qq/^([^X]*)X/;
    utf8::upgrade($re);
    ok("\x{100}X" =~ /$re/, "S_cl_and ANYOF_UNICODE & ANYOF_INVERTED");
}
a2568 10
# bug #22354
sub func ($) {
    ok( "a\nb" !~ /^b/, $_[0] );
    ok( "a\nb" =~ /^b/m, "$_[0] - with /m" );
}
func "standalone";
$_ = "x"; s/x/func "in subst"/e;
$_ = "x"; s/x/func "in multiline subst"/em;
#$_ = "x"; /x(?{func "in regexp"})/;
#$_ = "x"; /x(?{func "in multiline regexp"})/m;
d2570 11
a2580 4
# bug RT#19049
$_="abcdef\n";
@@x = m/./g;
ok("abcde" eq "$`", 'RT#19049 - global match not setting $`');
a2581 1
ok("123\x{100}" =~ /^.*1.*23\x{100}$/, 'uft8 + multiple floating substr');
d2583 8
a2590 3
# LATIN SMALL/CAPITAL LETTER A WITH MACRON
ok("  \x{101}" =~ qr/\x{100}/i,
   "<20030808193656.5109.1@@llama.ni-s.u-net.com>");
a2591 3
# LATIN SMALL/CAPITAL LETTER A WITH RING BELOW
ok("  \x{1E01}" =~ qr/\x{1E00}/i,
   "<20030808193656.5109.1@@llama.ni-s.u-net.com>");
a2592 3
# DESERET SMALL/CAPITAL LETTER LONG I
ok("  \x{10428}" =~ qr/\x{10400}/i,
   "<20030808193656.5109.1@@llama.ni-s.u-net.com>");
d2594 4
a2597 3
# LATIN SMALL/CAPITAL LETTER A WITH RING BELOW + 'X'
ok("  \x{1E01}x" =~ qr/\x{1E00}X/i,
   "<20030808193656.5109.1@@llama.ni-s.u-net.com>");
d2599 3
a2601 3
{
    # [perl #23769] Unicode regex broken on simple example
    # regrepeat() didn't handle UTF-8 EXACT case right.
d2603 3
a2605 1
    my $s = "\x{a0}\x{a0}\x{a0}\x{100}"; chop $s;
d2607 3
a2609 3
    ok($s =~ /\x{a0}/,       "[perl #23769]");
    ok($s =~ /\x{a0}+/,      "[perl #23769]");
    ok($s =~ /\x{a0}\x{a0}/, "[perl #23769]");
d2611 12
a2622 2
    ok("aaa\x{100}" =~ /(a+)/, "[perl #23769] easy invariant");
    ok($1 eq "aaa", "[perl #23769]");
a2623 2
    ok("\xa0\xa0\xa0\x{100}" =~ /(\xa0+)/, "[perl #23769] regrepeat invariant");
    ok($1 eq "\xa0\xa0\xa0", "[perl #23769]");
d2625 42
a2666 2
    ok("ababab\x{100}  " =~ /((?:ab)+)/, "[perl #23769] hard invariant");
    ok($1 eq "ababab", "[perl #23769]");
a2667 2
    ok("\xa0\xa1\xa0\xa1\xa0\xa1\x{100}" =~ /((?:\xa0\xa1)+)/, "[perl #23769] hard variant");
    ok($1 eq "\xa0\xa1\xa0\xa1\xa0\xa1", "[perl #23769]");
d2669 4
a2672 2
    ok("aaa\x{100}     " =~ /(a+?)/, "[perl #23769] easy invariant");
    ok($1 eq "a", "[perl #23769]");
d2674 1
a2674 2
    ok("\xa0\xa0\xa0\x{100}    " =~ /(\xa0+?)/, "[perl #23769] regrepeat variant");
    ok($1 eq "\xa0", "[perl #23769]");
d2676 1
a2676 2
    ok("ababab\x{100}  " =~ /((?:ab)+?)/, "[perl #23769] hard invariant");
    ok($1 eq "ab", "[perl #23769]");
d2678 7
a2684 2
    ok("\xa0\xa1\xa0\xa1\xa0\xa1\x{100}" =~ /((?:\xa0\xa1)+?)/, "[perl #23769] hard variant");
    ok($1 eq "\xa0\xa1", "[perl #23769]");
d2686 4
a2689 11
    ok("\xc4\xc4\xc4" !~ /(\x{100}+)/, "[perl #23769] don't match first byte of utf8 representation");
    ok("\xc4\xc4\xc4" !~ /(\x{100}+?)/, "[perl #23769] don't match first byte of utf8 representation");
}

for (120 .. 130) {
    my $head = 'x' x $_;
    for my $tail ('\x{0061}', '\x{1234}') {
	ok(
	    eval qq{ "$head$tail" =~ /$head$tail/ },
	    '\x{...} misparsed in regexp near 127 char EXACT limit'
	);
a2690 1
}
a2691 21
# perl #25269: panic: pp_match start/end pointers
ok("a-bc" eq eval {
	my($x, $y) = "bca" =~ /^(?=.*(a)).*(bc)/;
	"$x-$y";
}, 'captures can move backwards in string');

# perl #27940: \cA not recognized in character classes
ok("a\cAb" =~ /\cA/, '\cA in pattern');
ok("a\cAb" =~ /[\cA]/, '\cA in character class');
ok("a\cAb" =~ /[\cA-\cB]/, '\cA in character class range');
ok("abc" =~ /[^\cA-\cB]/, '\cA in negated character class range');
ok("a\cBb" =~ /[\cA-\cC]/, '\cB in character class range');
ok("a\cCbc" =~ /[^\cA-\cB]/, '\cC in negated character class range');
ok("a\cAb" =~ /(??{"\cA"})/, '\cA in ??{} pattern');
ok("ab" !~ /a\cIb/x, '\cI in pattern');

# perl #28532: optional zero-width match at end of string is ignored
ok(("abc" =~ /^abc(\z)?/) && defined($1),
    'optional zero-width match at end of string');
ok(("abc" =~ /^abc(\z)??/) && !defined($1),
    'optional zero-width match at end of string');
d2693 15
d2710 8
a2717 24
{ # TRIE related
    my @@got=();
    "words"=~/(word|word|word)(?{push @@got,$1})s$/;
    ok(@@got==1,"TRIE optimation is working") or warn "# @@got";
    @@got=();
    "words"=~/(word|word|word)(?{push @@got,$1})s$/i;
    ok(@@got==1,"TRIEF optimisation is working") or warn "# @@got";

    my @@nums=map {int rand 1000} 1..100;
    my $re="(".(join "|",@@nums).")";
    $re=qr/\b$re\b/;

    foreach (@@nums) {
        ok($_=~/$re/,"Trie nums");
    }
    $_=join " ", @@nums;
    @@got=();
    push @@got,$1 while /$re/g;

    my %count;
    $count{$_}++ for @@got;
    my $ok=1;
    for (@@nums) {
        $ok=0 if --$count{$_}<0;
a2718 2
    ok($ok,"Trie min count matches");
}
d2721 13
a2733 43
# TRIE related
# LATIN SMALL/CAPITAL LETTER A WITH MACRON
ok(("foba  \x{101}foo" =~ qr/(foo|\x{100}foo|bar)/i) && $1 eq "\x{101}foo",
   "TRIEF + LATIN SMALL/CAPITAL LETTER A WITH MACRON");

# LATIN SMALL/CAPITAL LETTER A WITH RING BELOW
ok(("foba  \x{1E01}foo" =~ qr/(foo|\x{1E00}foo|bar)/i) && $1 eq "\x{1E01}foo",
   "TRIEF + LATIN SMALL/CAPITAL LETTER A WITH RING BELOW");

# DESERET SMALL/CAPITAL LETTER LONG I
ok(("foba  \x{10428}foo" =~ qr/(foo|\x{10400}foo|bar)/i) &&  $1 eq "\x{10428}foo",
   "TRIEF + DESERET SMALL/CAPITAL LETTER LONG I");

# LATIN SMALL/CAPITAL LETTER A WITH RING BELOW + 'X'
ok(("foba  \x{1E01}xfoo" =~ qr/(foo|\x{1E00}Xfoo|bar)/i) &&  $1 eq "\x{1E01}xfoo",
   "TRIEF + LATIN SMALL/CAPITAL LETTER A WITH RING BELOW + 'X'");

{# TRIE related

use charnames ':full';

$s="\N{LATIN SMALL LETTER SHARP S}";
ok(("foba  ba$s" =~ qr/(foo|Ba$s|bar)/i)
    &&  $1 eq "ba$s",
   "TRIEF + LATIN SMALL LETTER SHARP S =~ ss");
ok(("foba  ba$s" =~ qr/(Ba$s|foo|bar)/i)
    &&  $1 eq "ba$s",
   "TRIEF + LATIN SMALL LETTER SHARP S =~ ss");
ok(("foba  ba$s" =~ qr/(foo|bar|Ba$s)/i)
    &&  $1 eq "ba$s",
   "TRIEF + LATIN SMALL LETTER SHARP S =~ ss");

ok(("foba  ba$s" =~ qr/(foo|Bass|bar)/i)
    &&  $1 eq "ba$s",
   "TRIEF + LATIN SMALL LETTER SHARP S =~ ss");

ok(("foba  ba$s" =~ qr/(foo|BaSS|bar)/i)
    &&  $1 eq "ba$s",
   "TRIEF + LATIN SMALL LETTER SHARP S =~ SS");

ok(("foba  ba${s}pxySS$s$s" =~ qr/(b(?:a${s}t|a${s}f|a${s}p)[xy]+$s*)/i)
    &&  $1 eq "ba${s}pxySS$s$s",
   "COMMON PREFIX TRIEF + LATIN SMALL LETTER SHARP S");
a2734 2
   
}
d2736 40
a2776 8
print "# set PERL_SKIP_PSYCHO_TEST to skip this test\n";
if (!$ENV{PERL_SKIP_PSYCHO_TEST}){
    my @@normal=qw(these are some normal words);
    my $psycho=join "|",@@normal,map chr $_,255..20000;
    ok(('these'=~/($psycho)/) && $1 eq 'these','Pyscho');
} else {
    ok(1,'Skipped Psycho');
}
d2778 11
a2788 1
# [perl #36207] mixed utf8 / latin-1 and case folding
d2790 36
a2825 14
{
    my $utf8 = "\xe9\x{100}"; chop $utf8;
    my $latin1 = "\xe9";

    ok($utf8 =~ /\xe9/i, "utf8/latin");
    ok($utf8 =~ /$latin1/i, "utf8/latin runtime");
    ok($utf8 =~ /(abc|\xe9)/i, "utf8/latin trie");
    ok($utf8 =~ /(abc|$latin1)/i, "utf8/latin trie runtime");

    ok("\xe9" =~ /$utf8/i, "# latin/utf8");
    ok("\xe9" =~ /(abc|$utf8)/i, "# latin/utf8 trie");
    ok($latin1 =~ /$utf8/i, "# latin/utf8 runtime");
    ok($latin1 =~ /(abc|$utf8)/i, "# latin/utf8 trie runtime");
}
a2826 1
# [perl #37038] Global regular matches generate invalid pointers
d2828 13
a2840 8
{
    my $s = "abcd";
    $s =~ /(..)(..)/g;
    $s = $1;
    $s = $2;
    ok($s eq 'cd',
       "# assigning to original string should not corrupt match vars");
}
d2842 34
a2875 4
{
    package wooosh;
    sub gloople {
      "!";
a2876 6
    package main;
    
    my $aeek = bless {}, 'wooosh';
    eval {$aeek->gloople() =~ /(.)/g;};
    ok($@@ eq "", "//g match against return value of sub") or print "# $@@\n";
}
a2877 8
{
    sub gloople {
      "!";
    }
    eval {gloople() =~ /(.)/g;};
    ok($@@ eq "", "# 26410 didn't affect sub calls for some reason")
	or print "# $@@\n";
}
d2879 29
a2907 11
{
    package lv;
    $var = "abc";
    sub variable : lvalue { $var }

    package main;
    my $o = bless [], "lv";
    my $f = "";
    eval { for (1..2) { $f .= $1 if $o->variable =~ /(.)/g } };
    ok($f eq "ab", "pos retained between calls # TODO") or print "# $@@\n";
}
a2908 8
{
    $var = "abc";
    sub variable : lvalue { $var }

    my $f = "";
    eval { for (1..2) { $f .= $1 if variable() =~ /(.)/g } };
    ok($f eq "ab", "pos retained between calls # TODO") or print "# $@@\n";
}
d2910 2
a2911 10
# [perl #37836] Simple Regex causes SEGV when run on specific data
if ($ordA == 193) {
    print "ok $test # Skip: in EBCDIC\n"; $test++;
} else {
    no warnings 'utf8';
    $_ = pack('U0C2', 0xa2, 0xf8); # ill-formed UTF-8
    my $ret = 0;
    eval { $ret = s/[\0]+//g };
    ok($ret == 0, "ill-formed UTF-8 doesn't match NUL in class");
}
d2913 2
a2914 34
{ # [perl #38293] chr(65535) should be allowed in regexes
    no warnings 'utf8'; # to allow non-characters
    my($c, $r, $s);

    $c = chr 0xffff;
    $c =~ s/$c//g;
    ok($c eq "", "U+FFFF, parsed as atom");

    $c = chr 0xffff;
    $r = "\\$c";
    $c =~ s/$r//g;
    ok($c eq "", "U+FFFF backslashed, parsed as atom");

    $c = chr 0xffff;
    $c =~ s/[$c]//g;
    ok($c eq "", "U+FFFF, parsed in class");

    $c = chr 0xffff;
    $r = "[\\$c]";
    $c =~ s/$r//g;
    ok($c eq "", "U+FFFF backslashed, parsed in class");

    $s = "A\x{ffff}B";
    $s =~ s/\x{ffff}//i;
    ok($s eq "AB", "U+FFFF, EXACTF");

    $s = "\x{ffff}A";
    $s =~ s/\bA//;
    ok($s eq "\x{ffff}", "U+FFFF, BOUND");

    $s = "\x{ffff}!";
    $s =~ s/\B!//;
    ok($s eq "\x{ffff}", "U+FFFF, NBOUND");
} # non-characters end
d2916 9
a2924 25
{
    # https://rt.perl.org/rt3/Ticket/Display.html?id=39583
    
    # The printing characters
    my @@chars = ("A".."Z");
    my $delim = ",";
    my $size = 32771 - 4;
    my $str = '';

    # create some random junk. Inefficient, but it works.
    for ($i = 0 ; $i < $size ; $i++) {
        $str .= $chars[int(rand(@@chars))];
    }

    $str .= ($delim x 4);
    my $res;
    my $matched;
    if ($str =~ s/^(.*?)${delim}{4}//s) {
        $res = $1;
        $matched=1;
    } 
    ok($matched,'pattern matches');
    ok(length($str)==0,"Empty string");
    ok(defined($res) && length($res)==$size,"\$1 is correct size");
}
a2925 25
{ # related to [perl #27940]
    ok("\0-A"  =~ /\c@@-A/, '@@- should not be interpolated in a pattern');
    ok("\0\0A" =~ /\c@@+A/, '@@+ should not be interpolated in a pattern');
    ok("X\@@-A"  =~ /X@@-A/, '@@- should not be interpolated in a pattern');
    ok("X\@@\@@A" =~ /X@@+A/, '@@+ should not be interpolated in a pattern');

    ok("X\0A" =~ /X\c@@?A/,  '\c@@?');
    ok("X\0A" =~ /X\c@@*A/,  '\c@@*');
    ok("X\0A" =~ /X\c@@(A)/, '\c@@(');
    ok("X\0A" =~ /X(\c@@)A/, '\c@@)');
    ok("X\0A" =~ /X\c@@|ZA/, '\c@@|');

    ok("X\@@A" =~ /X@@?A/,  '@@?');
    ok("X\@@A" =~ /X@@*A/,  '@@*');
    ok("X\@@A" =~ /X@@(A)/, '@@(');
    ok("X\@@A" =~ /X(@@)A/, '@@)');
    ok("X\@@A" =~ /X@@|ZA/, '@@|');

    local $" = ','; # non-whitespace and non-RE-specific
    ok('abc' =~ /(.)(.)(.)/, 'the last successful match is bogus');
    ok("A@@+B"  =~ /A@@{+}B/,  'interpolation of @@+ in /@@{+}/');
    ok("A@@-B"  =~ /A@@{-}B/,  'interpolation of @@- in /@@{-}/');
    ok("A@@+B"  =~ /A@@{+}B/x, 'interpolation of @@+ in /@@{+}/x');
    ok("A@@-B"  =~ /A@@{-}B/x, 'interpolation of @@- in /@@{-}/x');
}
d2927 33
a2959 19
{
    use lib 'lib';
    use Cname;
    
    ok('fooB'=~/\N{foo}[\N{B}\N{b}]/,"Passthrough charname");
    $test=1233; my $handle=make_must_warn('Ignoring excess chars from');
    $handle->('q(xxWxx) =~ /[\N{WARN}]/');
    {
        my $code;
        my $w="";
        local $SIG{__WARN__} = sub { $w.=shift };
        eval($code=<<'EOFTEST') or die "$@@\n$code\n";
        {
            use warnings;
            
            #1234
            ok("\0" !~ /[\N{EMPTY-STR}XY]/,
                "Zerolength charname in charclass doesnt match \0");
            1;
a2960 5
EOFTEST
        ok($w=~/Ignoring zero length/,
            "Got expected zero length warning");
        warn $code;                    
        
a2961 10
    $handle= make_must_warn('Ignoring zero length');
    $handle->('qq(\\0) =~ /[\N{EMPTY-STR}XY]/');
    ok('AB'=~/(\N{EVIL})/ && $1 eq 'A',"Charname caching $1");
    ok('ABC'=~/(\N{EVIL})/,"Charname caching $1");    
    ok('xy'=~/x\N{EMPTY-STR}y/, 'Empty string charname produces NOTHING node');
    ok(''=~/\N{EMPTY-STR}/, 'Empty string charname produces NOTHING node 2');
        
}
{
    print "# MORE LATIN SMALL LETTER SHARP S\n";
a2962 1
    use charnames ':full';
d2964 35
a2998 50
    #see also test #835
    ok("ss" =~ /[\N{LATIN SMALL LETTER SHARP S}x]/i,
        "unoptimized named sequence in class 1");
    ok("SS" =~ /[\N{LATIN SMALL LETTER SHARP S}x]/i,
        "unoptimized named sequence in class 2");        
    ok("\N{LATIN SMALL LETTER SHARP S}" =~ /[\N{LATIN SMALL LETTER SHARP S}x]/,
        "unoptimized named sequence in class 3");
    ok("\N{LATIN SMALL LETTER SHARP S}" =~ /[\N{LATIN SMALL LETTER SHARP S}x]/i,
        "unoptimized named sequence in class 4");        
    
    ok('aabc' !~ /a\N{PLUS SIGN}b/,'/a\N{PLUS SIGN}b/ against aabc');
    ok('a+bc' =~ /a\N{PLUS SIGN}b/,'/a\N{PLUS SIGN}b/ against a+bc');
    ok('a+bc' =~ /a\N{PLUS SIGN}b/,'/a\N{PLUS SIGN}b/ against a+bc');

    ok(' A B'=~/\N{SPACE}\N{U+0041}\N{SPACE}\N{U+0042}/,
        'Intermixed named and unicode escapes 1');
    ok("\N{SPACE}\N{U+0041}\N{SPACE}\N{U+0042}"=~
       /\N{SPACE}\N{U+0041}\N{SPACE}\N{U+0042}/,
        'Intermixed named and unicode escapes 2');
    ok("\N{SPACE}\N{U+0041}\N{SPACE}\N{U+0042} 3"=~
       /[\N{SPACE}\N{U+0041}][\N{SPACE}\N{U+0042}]/,
        'Intermixed named and unicode escapes');     
}
$brackets = qr{
	         {  (?> [^{}]+ | (??{ $brackets }) )* }
	      }x;
ok("{b{c}d" !~ m/^((??{ $brackets }))/, "bracket mismatch");

SKIP:{
    our @@stack=();
    my @@expect=qw(
        stuff1
        stuff2
        <stuff1>and<stuff2>
        right
        <right>
        <<right>>
        <<<right>>>
        <<stuff1>and<stuff2>><<<<right>>>>
    );

    local $_='<<<stuff1>and<stuff2>><<<<right>>>>>';
    ok(/^(<((?:(?>[^<>]+)|(?1))*)>(?{push @@stack, $2 }))$/,
        "Recursion should match");
    ok(@@stack==@@expect)
        or skip("Won't test individual results as count isn't equal",
                0+@@expect);
    foreach my $idx (@@expect) {
        ok($expect[$idx] eq $stack[$idx], 
            "Expecting '$expect' at stack pos #$idx");
a2999 10
        
}
{
    my $s='123453456';
    $s=~s/(?<digits>\d+)\k<digits>/$+{digits}/;
    ok($s eq '123456','Named capture (angle brackets) s///');
    $s='123453456';
    $s=~s/(?'digits'\d+)\k'digits'/$+{digits}/;
    ok($s eq '123456','Named capture (single quotes) s///');    
}
d3001 36
a3036 23
{
    my @@ary = (
	pack('U', 0x00F1),            # n-tilde
	'_'.pack('U', 0x00F1),        # _ + n-tilde
	'c'.pack('U', 0x0327),        # c + cedilla
	pack('U*', 0x00F1, 0x0327),   # n-tilde + cedilla
	'a'.pack('U', 0x00B2),        # a + superscript two
	pack('U', 0x0391),            # ALPHA
	pack('U', 0x0391).'2',        # ALPHA + 2
	pack('U', 0x0391).'_',        # ALPHA + _
    );
    for my $uni (@@ary) {
	my ($r1, $c1, $r2, $c2) = eval qq{
	    use utf8;
	    scalar("..foo foo.." =~ /(?'${uni}'foo) \\k'${uni}'/),
		\$+{${uni}},
	    scalar("..bar bar.." =~ /(?<${uni}>bar) \\k<${uni}>/),
		\$+{${uni}};
	};
	ok($r1,                         "Named capture UTF (?'')");
	ok(defined $c1 && $c1 eq 'foo', "Named capture UTF \%+");
	ok($r2,                         "Named capture UTF (?<>)");
	ok(defined $c2 && $c2 eq 'bar', "Named capture UTF \%+");
a3037 1
}
a3038 10
sub iseq($$;$) { 
    my ( $got, $expect, $name)=@@_;
    
    $_=defined($_) ? "'$_'" : "undef"
        for $got, $expect;
        
    my $ok=  $got eq $expect;
        
    printf "%sok %d - %s\n", ($ok ? "" : "not "), $test,
        ($name||$Message)."\tLine ".((caller)[2]);
d3040 42
a3081 5
    printf "# Failed test at line %d\n".
           "# expected: %s\n". 
           "#   result: %s\n", 
           (caller)[2], $expect, $got
        unless $ok;
d3083 9
a3091 46
    $test++;
    return $ok;
}   
{
    my $s='foo bar baz';
    my (@@k,@@v,@@fetch,$res);
    my $count= 0;
    my @@names=qw($+{A} $+{B} $+{C});
    if ($s=~/(?<A>foo)\s+(?<B>bar)?\s+(?<C>baz)/) {
        while (my ($k,$v)=each(%+)) {
            $count++;
        }
        @@k=sort keys(%+);
        @@v=sort values(%+);
        $res=1;
        push @@fetch,
            [ "$+{A}", "$1" ],
            [ "$+{B}", "$2" ],
            [ "$+{C}", "$3" ],
        ;
    } 
    foreach (0..2) {
        if ($fetch[$_]) {
            iseq($fetch[$_][0],$fetch[$_][1],$names[$_]);
        } else {
            ok(0, $names[$_]);
        }
    }
    iseq($res,1,"$s~=/(?<A>foo)\s+(?<B>bar)?\s+(?<C>baz)/");
    iseq($count,3,"Got 3 keys in %+ via each");
    iseq(0+@@k, 3, 'Got 3 keys in %+ via keys');
    iseq("@@k","A B C", "Got expected keys");
    iseq("@@v","bar baz foo", "Got expected values");
    eval'
        print for $+{this_key_doesnt_exist};
    ';
    ok(!$@@,'lvalue $+{...} should not throw an exception');
}
{
    my $s='foo bar baz';
    my @@res;
    if ('1234'=~/(?<A>1)(?<B>2)(?<A>3)(?<B>4)/) {
        foreach my $name (sort keys(%-)) {
            my $ary = $-{$name};
            foreach my $idx (0..$#$ary) {
                push @@res,"$name:$idx:$ary->[$idx]";
d3094 7
d3102 94
a3195 96
    my @@expect=qw(A:0:1 A:1:3 B:0:2 B:1:4);
    iseq("@@res","@@expect","Check %-");
    eval'
        print for $-{this_key_doesnt_exist};
    ';
    ok(!$@@,'lvalue $-{...} should not throw an exception');
}
# stress test CURLYX/WHILEM.
#
# This test includes varying levels of nesting, and according to
# profiling done against build 28905, exercises every code line in the
# CURLYX and WHILEM blocks, except those related to LONGJMP, the
# super-linear cache and warnings. It executes about 0.5M regexes

if ($ENV{PERL_SKIP_PSYCHO_TEST}){
  printf "ok %d Skip: No psycho tests\n", $test++;
} else {    
  print "# set PERL_SKIP_PSYCHO_TEST to skip this test\n";
  my $r = qr/^
  	    (?:
  		( (?:a|z+)+ )
  		(?:
  		    ( (?:b|z+){3,}? )
  		    (
  			(?:
  			    (?:
				(?:c|z+){1,1}?z
			    )?
  			    (?:c|z+){1,1}
  			)*
  		    )
  		    (?:z*){2,}
  		    ( (?:z+|d)+ )
  		    (?:
  			( (?:e|z+)+ )
  		    )*
  		    ( (?:f|z+)+ )
  		)*
  		( (?:z+|g)+ )
  		(?:
  		    ( (?:h|z+)+ )
  		)*
  		( (?:i|z+)+ )
  	    )+
  	    ( (?:j|z+)+ )
  	    (?:
  		( (?:k|z+)+ )
  	    )*
  	    ( (?:l|z+)+ )
  	$/x;
  
  
  my $ok = 1;
  my $msg = "CURLYX stress test";
  OUTER:
  for my $a ("x","a","aa") {
    for my $b ("x","bbb","bbbb") {
      my $bs = $a.$b;
      for my $c ("x","c","cc") {
        my $cs = $bs.$c;
        for my $d ("x","d","dd") {
          my $ds = $cs.$d;
          for my $e ("x","e","ee") {
            my $es = $ds.$e;
            for my $f ("x","f","ff") {
              my $fs = $es.$f;
              for my $g ("x","g","gg") {
                my $gs = $fs.$g;
                for my $h ("x","h","hh") {
                  my $hs = $gs.$h;
                  for my $i ("x","i","ii") {
                    my $is = $hs.$i;
                    for my $j ("x","j","jj") {
                      my $js = $is.$j;
                      for my $k ("x","k","kk") {
                        my $ks = $js.$k;
                        for my $l ("x","l","ll") {
                          my $ls = $ks.$l;
                          if ($ls =~ $r) {
                            if ($ls =~ /x/) {
                              $msg .= ": unexpected match for [$ls]";
			      $ok = 0;
                              last OUTER;
                            }
                            my $cap = "$1$2$3$4$5$6$7$8$9$10$11$12";
                            unless ($ls eq $cap) {
                              $msg .= ": capture: [$ls], got [$cap]";
			      $ok = 0;
                              last OUTER;
                            }
                          }
                          else {
                            unless ($ls =~ /x/) {
                              $msg = ": failed for [$ls]";
			      $ok = 0;
                              last OUTER;
a3204 1
          }
d3206 19
a3224 1
      }
a3225 3
  }
  ok($ok, $msg);
}
a3226 14
# \, breaks {3,4}
ok("xaaay"    !~ /xa{3\,4}y/, "\, in a pattern");
ok("xa{3,4}y" =~ /xa{3\,4}y/, "\, in a pattern");

# \c\ followed by _
ok("x\c_y"    !~ /x\c\_y/,    "\_ in a pattern");
ok("x\c\_y"   =~ /x\c\_y/,    "\_ in a pattern");

# \c\ followed by other characters
for my $c ("z", "\0", "!", chr(254), chr(256)) {
    my $targ = "a\034$c";
    my $reg  = "a\\c\\$c";
    ok(eval("qq/$targ/ =~ /$reg/"), "\\c\\ in pattern");
}
d3228 99
a3326 10
{
    my $str='abc'; 
    my $count=0;
    my $mval=0;
    my $pval=0;
    while ($str=~/b/g) { $mval=$#-; $pval=$#+; $count++ }
    iseq($mval,0,"\@@- should be empty [RT#36046]");
    iseq($pval,0,"\@@+ should be empty [RT#36046]");
    iseq($count,1,"should have matched once only [RT#36046]");
}
d3328 13
a3340 93
{   # Test the (*PRUNE) pattern
    our $count = 0;
    'aaab'=~/a+b?(?{$count++})(*FAIL)/;
    iseq($count,9,"expect 9 for no (*PRUNE)");
    $count = 0;
    'aaab'=~/a+b?(*PRUNE)(?{$count++})(*FAIL)/;
    iseq($count,3,"expect 3 with (*PRUNE)");
    local $_='aaab';
    $count=0;
    1 while /.(*PRUNE)(?{$count++})(*FAIL)/g;
    iseq($count,4,"/.(*PRUNE)/");
    $count = 0;
    'aaab'=~/a+b?(??{'(*PRUNE)'})(?{$count++})(*FAIL)/;
    iseq($count,3,"expect 3 with (*PRUNE)");
    local $_='aaab';
    $count=0;
    1 while /.(??{'(*PRUNE)'})(?{$count++})(*FAIL)/g;
    iseq($count,4,"/.(*PRUNE)/");
}
{   # Test the (*SKIP) pattern
    our $count = 0;
    'aaab'=~/a+b?(*SKIP)(?{$count++})(*FAIL)/;
    iseq($count,1,"expect 1 with (*SKIP)");
    local $_='aaab';
    $count=0;
    1 while /.(*SKIP)(?{$count++})(*FAIL)/g;
    iseq($count,4,"/.(*SKIP)/");
    $_='aaabaaab';
    $count=0;
    our @@res=();
    1 while /(a+b?)(*SKIP)(?{$count++; push @@res,$1})(*FAIL)/g;
    iseq($count,2,"Expect 2 with (*SKIP)" );
    iseq("@@res","aaab aaab","adjacent (*SKIP) works as expected" );
}
{   # Test the (*SKIP) pattern
    our $count = 0;
    'aaab'=~/a+b?(*MARK:foo)(*SKIP)(?{$count++})(*FAIL)/;
    iseq($count,1,"expect 1 with (*SKIP)");
    local $_='aaab';
    $count=0;
    1 while /.(*MARK:foo)(*SKIP)(?{$count++})(*FAIL)/g;
    iseq($count,4,"/.(*SKIP)/");
    $_='aaabaaab';
    $count=0;
    our @@res=();
    1 while /(a+b?)(*MARK:foo)(*SKIP)(?{$count++; push @@res,$1})(*FAIL)/g;
    iseq($count,2,"Expect 2 with (*SKIP)" );
    iseq("@@res","aaab aaab","adjacent (*SKIP) works as expected" );
}
{   # Test the (*SKIP) pattern
    our $count = 0;
    'aaab'=~/a*(*MARK:a)b?(*MARK:b)(*SKIP:a)(?{$count++})(*FAIL)/;
    iseq($count,3,"expect 3 with *MARK:a)b?(*MARK:b)(*SKIP:a)");
    local $_='aaabaaab';
    $count=0;
    our @@res=();
    1 while /(a*(*MARK:a)b?)(*MARK:x)(*SKIP:a)(?{$count++; push @@res,$1})(*FAIL)/g;
    iseq($count,5,"Expect 5 with (*MARK:a)b?)(*MARK:x)(*SKIP:a)" );
    iseq("@@res","aaab b aaab b ","adjacent (*MARK:a)b?)(*MARK:x)(*SKIP:a) works as expected" );
}
{   # Test the (*COMMIT) pattern
    our $count = 0;
    'aaabaaab'=~/a+b?(*COMMIT)(?{$count++})(*FAIL)/;
    iseq($count,1,"expect 1 with (*COMMIT)");
    local $_='aaab';
    $count=0;
    1 while /.(*COMMIT)(?{$count++})(*FAIL)/g;
    iseq($count,1,"/.(*COMMIT)/");
    $_='aaabaaab';
    $count=0;
    our @@res=();
    1 while /(a+b?)(*COMMIT)(?{$count++; push @@res,$1})(*FAIL)/g;
    iseq($count,1,"Expect 1 with (*COMMIT)" );
    iseq("@@res","aaab","adjacent (*COMMIT) works as expected" );
}
{
    # Test named commits and the $REGERROR var
    our $REGERROR;
    for my $name ('',':foo') 
    {
        for my $pat ("(*PRUNE$name)",
                     ($name? "(*MARK$name)" : "")
                     . "(*SKIP$name)",
                     "(*COMMIT$name)")
        {                         
            for my $suffix ('(*FAIL)','') 
            {
                'aaaab'=~/a+b$pat$suffix/;
                iseq(
                    $REGERROR,
                    ($suffix ? ($name ? 'foo' : "1") : ""),
                    "Test $pat and \$REGERROR $suffix"
                );
d3343 17
a3359 21
    }      
}    
{
    # Test named commits and the $REGERROR var
    package Fnorble;
    our $REGERROR;
    for my $name ('',':foo') 
    {
        for my $pat ("(*PRUNE$name)",
                     ($name? "(*MARK$name)" : "")
                     . "(*SKIP$name)",
                     "(*COMMIT$name)")
        {                         
            for my $suffix ('(*FAIL)','') 
            {
                'aaaab'=~/a+b$pat$suffix/;
                ::iseq(
                    $REGERROR,
                    ($suffix ? ($name ? 'foo' : "1") : ""),
                    "Test $pat and \$REGERROR $suffix"
                );
d3361 31
a3392 23
    }      
}    
{
    # Test named commits and the $REGERROR var
    local $Message = "\$REGERROR";
    our $REGERROR;
    for $word (qw(bar baz bop)) {
        $REGERROR="";
        "aaaaa$word"=~/a+(?:bar(*COMMIT:bar)|baz(*COMMIT:baz)|bop(*COMMIT:bop))(*FAIL)/;
        iseq($REGERROR,$word);
    }    
}
{   #Regression test for perlbug 40684
    local $Message = "RT#40684 tests:";
    my $s = "abc\ndef";
    my $rex = qr'^abc$'m;
    ok($s =~ m/$rex/);
    ok($s =~ m/^abc$/m);
}
{
    #Mindnumbingly simple test of (*THEN)
    for ("ABC","BAX") {
        ok(/A (*THEN) X | B (*THEN) C/x,"Simple (*THEN) test");
a3393 1
}
d3395 13
a3407 26
{
    local $Message = "Relative Recursion";
    my $parens=qr/(\((?:[^()]++|(?-1))*+\))/;
    local $_='foo((2*3)+4-3) + bar(2*(3+4)-1*(2-3))';
    my ($all,$one,$two)=('','','');
    if (/foo $parens \s* \+ \s* bar $parens/x) {
       $all=$&;
       $one=$1;
       $two=$2;
    }
    iseq($one, '((2*3)+4-3)');
    iseq($two, '(2*(3+4)-1*(2-3))');
    iseq($all, 'foo((2*3)+4-3) + bar(2*(3+4)-1*(2-3))');
    iseq($all, $_);
}
{
    my $spaces="      ";
    local $_=join 'bar',$spaces,$spaces;
    our $count=0;
    s/(?>\s+bar)(?{$count++})//g;
    iseq($_,$spaces,"SUSPEND final string");
    iseq($count,1,"Optimiser should have prevented more than one match");
}
{
    local $Message = "RT#36909 test";
    $^R = 'Nothing';
d3409 6
a3414 6
        local $^R = "Bad";
        ok('x foofoo y' =~ m{
         (foo) # $^R correctly set
        (?{ "last regexp code result" })
        }x);
        iseq($^R,'last regexp code result');
d3416 1
a3416 1
    iseq($^R,'Nothing');
d3418 33
a3450 1
        local $^R = "Bad";
d3452 9
a3460 5
        ok('x foofoo y' =~ m{
         (?:foo|bar)+ # $^R correctly set
        (?{"last regexp code result"})
        }x);
        iseq($^R,'last regexp code result');
d3462 1
a3462 1
    iseq($^R,'Nothing');
d3465 9
a3473 6
        local $^R = "Bad";
        ok('x foofoo y' =~ m{
         (foo|bar)\1+ # $^R undefined
        (?{"last regexp code result"})
        }x);
        iseq($^R,'last regexp code result');
d3475 1
a3475 1
    iseq($^R,'Nothing');
d3478 6
a3483 6
        local $^R = "Bad";
        ok('x foofoo y' =~ m{
         (foo|bar)\1 # this time without the +
        (?{"last regexp code result"})
        }x);
        iseq($^R,'last regexp code result');
d3485 20
a3504 9
    iseq($^R,'Nothing');
}
{
    local $Message="RT#22395";
    our $count;
    for my $l (10,100,1000) {
	$count=0;
	('a' x $l) =~ /(.*)(?{$count++})[bc]/;
	iseq( $count, $l + 1, "# TODO Should be L+1 not L*(L+3)/2 (L=$l)");
d3506 10
a3515 19
}
{
    local $Message = "RT#22614";
    local $_='ab';
    our @@len=();
    /(.){1,}(?{push @@len,0+@@-})(.){1,}(?{})^/;
    iseq("@@len","2 2 2");
}
{
    local $Message = "RT#18209";
    my $text = ' word1 word2 word3 word4 word5 word6 ';

    my @@words = ('word1', 'word3', 'word5');
    my $count;
    foreach my $word (@@words){
        $text =~ s/$word\s//gi; # Leave a space to seperate words in the resultant str.
        # The following block is not working.
        if($&){
            $count++;
d3517 1
a3517 1
        # End bad block
d3519 20
a3538 11
    iseq($count,3);
    iseq($text,' word2 word4 word6 ');
}
{
    # RT#6893
    local $_= qq(A\nB\nC\n); 
    my @@res;
    while (m#(\G|\n)([^\n]*)\n#gsx) 
    { 
        push @@res,"$2"; 
        last if @@res>3;
a3539 2
    iseq("@@res","A B C","RT#6893: /g pattern shouldn't infinite loop");
}
a3540 9
{
    # From Message-ID: <877ixs6oa6.fsf@@k75.linux.bogus>
    my $dow_name= "nada";
    my $parser = "(\$dow_name) = \$time_string =~ /(D\x{e9}\\ C\x{e9}adaoin|D\x{e9}\\ Sathairn|\\w+|\x{100})/";
    my $time_string = "D\x{e9} C\x{e9}adaoin";
    eval $parser;
    ok(!$@@,"Test Eval worked");
    iseq($dow_name,$time_string,"UTF8 trie common prefix extraction");
}
d3542 27
a3568 29
{
    my $v;
    ($v='bar')=~/(\w+)/g;
    $v='foo';
    iseq("$1",'bar','$1 is safe after /g - may fail due to specialized config in pp_hot.c')
}
{
    local $Message = "http://nntp.perl.org/group/perl.perl5.porters/118663";
    my $qr_barR1 = qr/(bar)\g-1/;
    ok("foobarbarxyz" =~ $qr_barR1);
    ok("foobarbarxyz" =~ qr/foo${qr_barR1}xyz/);
    ok("foobarbarxyz" =~ qr/(foo)${qr_barR1}xyz/);
    ok("foobarbarxyz" =~ qr/(foo)(bar)\g{-1}xyz/);
    ok("foobarbarxyz" =~ qr/(foo${qr_barR1})xyz/);
    ok("foobarbarxyz" =~ qr/(foo(bar)\g{-1})xyz/);
} 
{
    local $Message = "RT#41010";
    my @@tails=('','(?(1))','(|)','()?');    
    my @@quants=('*','+');
    my $doit=sub {
        my $pats= shift;
        for (@@_) {
            for my $pat (@@$pats) {
                for my $quant (@@quants) {
                    for my $tail (@@tails) {
                        my $re = "($pat$quant\$)$tail";
                        ok(/$re/ && $1 eq $_,"'$_'=~/$re/");
                        ok(/$re/m && $1 eq $_,"'$_'=~/$re/m");
d3572 62
a3633 45
       }
    };    
    
    my @@dpats=( 
                '\d',
                '[1234567890]',
                '(1|[23]|4|[56]|[78]|[90])',
                '(?:1|[23]|4|[56]|[78]|[90])',
                '(1|2|3|4|5|6|7|8|9|0)',
                '(?:1|2|3|4|5|6|7|8|9|0)',
             );
    my @@spats=('[ ]',' ','( |\t)','(?: |\t)','[ \t]','\s');
    my @@sstrs=('  ');
    my @@dstrs=('12345');
    $doit->(\@@spats,@@sstrs);
    $doit->(\@@dpats,@@dstrs);
}
{
    local $Message = "\$REGMARK";
    our @@r=();
    ok('foofoo' =~ /foo (*MARK:foo) (?{push @@r,$REGMARK}) /x);
    iseq("@@r","foo");           
    iseq($REGMARK,"foo");
    ok('foofoo' !~ /foo (*MARK:foo) (*FAIL) /x);
    ok(!$REGMARK);
    iseq($REGERROR,'foo');
}
{
    my $x;
    $x = "abc.def.ghi.jkl";
    $x =~ s/.*\K\..*//;
    ok($x eq "abc.def.ghi");
    
    $x = "one two three four";
    $x =~ s/o+ \Kthree//g;
    ok($x eq "one two  four");
    
    $x = "abcde";
    $x =~ s/(.)\K/$1/g;
    ok($x eq "aabbccddee");
}
sub kt
{
    return '4' if $_[0] eq '09028623';
}
d3635 13
a3647 12
{   # Nested EVAL using PL_curpm (via $1 or friends)
    my $re;
    our $grabit = qr/ ([0-6][0-9]{7}) (??{ kt $1 }) [890] /x;
    $re = qr/^ ( (??{ $grabit }) ) $ /x;
    my @@res = '0902862349' =~ $re;
    iseq(join("-",@@res),"0902862349",
        'PL_curpm is set properly on nested eval');

    our $qr = qr/ (o) (??{ $1 }) /x;
    ok( 'boob'=~/( b (??{ $qr }) b )/x && 1,
        "PL_curpm, nested eval");
}
a3648 13
{
    use charnames ":full";
    ok("\N{ROMAN NUMERAL ONE}" =~ /\p{Alphabetic}/, "I =~ Alphabetic");
    ok("\N{ROMAN NUMERAL ONE}" =~ /\p{Uppercase}/,  "I =~ Uppercase");
    ok("\N{ROMAN NUMERAL ONE}" !~ /\p{Lowercase}/,  "I !~ Lowercase");
    ok("\N{ROMAN NUMERAL ONE}" =~ /\p{IDStart}/,    "I =~ ID_Start");
    ok("\N{ROMAN NUMERAL ONE}" =~ /\p{IDContinue}/, "I =~ ID_Continue");
    ok("\N{SMALL ROMAN NUMERAL ONE}" =~ /\p{Alphabetic}/, "i =~ Alphabetic");
    ok("\N{SMALL ROMAN NUMERAL ONE}" !~ /\p{Uppercase}/,  "i !~ Uppercase");
    ok("\N{SMALL ROMAN NUMERAL ONE}" =~ /\p{Lowercase}/,  "i =~ Lowercase");
    ok("\N{SMALL ROMAN NUMERAL ONE}" =~ /\p{IDStart}/,    "i =~ ID_Start");
    ok("\N{SMALL ROMAN NUMERAL ONE}" =~ /\p{IDContinue}/, "i =~ ID_Continue");
}
d3650 9
a3658 8
{
# requirement of Unicode Technical Standard #18, 1.7 Code Points
# cf. http://www.unicode.org/reports/tr18/#Supplementary_Characters
    for my $u (0x7FF, 0x800, 0xFFFF, 0x10000) {
        no warnings 'utf8'; # oops
        my $c = chr $u;
        my $x = sprintf '%04X', $u;
        ok( "A${c}B" =~ /A[\0-\x{10000}]B/, "unicode range - $x");
a3659 1
}
a3660 2
{
    my $res="";
d3662 15
a3676 2
    if ('1' =~ /(?|(?<digit>1)|(?<digit>2))/) {
      $res = "@@{$- {digit}}";
d3678 23
a3700 6
    iseq($res,"1",
        "Check that (?|...) doesnt cause dupe entries in the names array");
    #---
    $res="";
    if ('11' =~ /(?|(?<digit>1)|(?<digit>2))(?&digit)/) {
      $res = "@@{$- {digit}}";
a3701 3
    iseq($res, "1",
        "Check that (?&..) to a buffer inside a (?|...) goes to the leftmost");
}
d3703 15
a3717 14
{
    use warnings;
    local $Message = "ASCII pattern that really is utf8";
    my @@w;
    local $SIG{__WARN__}=sub{push @@w,"@@_"};
    my $c=qq(\x{DF}); 
    ok($c=~/${c}|\x{100}/);
    ok(@@w==0);
}    
{
    local $Message = "corruption of match results of qr// across scopes";
    my $qr=qr/(fo+)(ba+r)/;
    'foobar'=~/$qr/;
    iseq("$1$2","foobar");
d3719 22
a3740 2
        'foooooobaaaaar'=~/$qr/;
        iseq("$1$2",'foooooobaaaaar');    
d3742 35
a3776 33
    iseq("$1$2","foobar");
}
{
    local $Message = "HORIZWS";
    local $_="\t \r\n \n \t".chr(11)."\n";
    s/\H/H/g;
    s/\h/h/g;
    iseq($_,"hhHHhHhhHH");
    $_="\t \r\n \n \t".chr(11)."\n";
    utf8::upgrade($_);
    s/\H/H/g;
    s/\h/h/g;
    iseq($_,"hhHHhHhhHH");
}    
{
    local $Message = "Various whitespace special patterns";
    my @@h=map { chr( $_ ) } (
        0x09,   0x20,   0xa0,   0x1680, 0x180e, 0x2000, 0x2001, 0x2002,
        0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200a,
        0x202f, 0x205f, 0x3000
    );
    my @@v=map { chr( $_ ) } ( 0x0a, 0x0b, 0x0c, 0x0d, 0x85, 0x2028, 0x2029 );
    my @@lb=( "\x0D\x0A",
             map { chr( $_ ) } ( 0x0A..0x0D,0x85,0x2028,0x2029 ));
    foreach my $t ([\@@h,qr/\h/,qr/\h+/],[\@@v,qr/\v/,qr/\v+/],[\@@lb,qr/\R/,qr/\R+/],){
        my $ary=shift @@$t;
        foreach my $pat (@@$t) {
            foreach my $str (@@$ary) {
                ok($str=~/($pat)/,$pat);
                iseq($1,$str,$pat);
                utf8::upgrade($str);
                ok($str=~/($pat)/,"Upgraded string - $pat");
                iseq($1,$str,"Upgraded string - $pat");
d3780 142
a3921 30
}
{
    local $Message = "Check that \\xDF match properly in its various forms";
    # test that \xDF matches properly. this is pretty hacky stuff,
    # but its actually needed. the malarky with '-' is to prevent
    # compilation caching from playing any role in the test.
    my @@df= (chr(0xDF),'-',chr(0xDF));
    utf8::upgrade($df[2]);
    my @@strs= ('ss','sS','Ss','SS',chr(0xDF));
    my @@ss= map { ("$_", "$_") } @@strs;
    utf8::upgrade($ss[$_*2+1]) for 0..$#strs;

    for my $ssi (0..$#ss) {
        for my $dfi (0..$#df) {
            my $pat= $df[$dfi];
            my $str= $ss[$ssi];
            my $utf_df= ($dfi > 1) ? 'utf8' : '';
            my $utf_ss= ($ssi % 2) ? 'utf8' : '';
            (my $sstr=$str)=~s/\xDF/\\xDF/;

            if ($utf_df || $utf_ss || length($ss[$ssi])==1) {
                my $ret= $str=~/$pat/i;
                next if $pat eq '-';
                ok($ret, 
                    "\"$sstr\"=~/\\xDF/i (str is @@{[$utf_ss||'latin']}, pat is @@{[$utf_df||'latin']})");
            } else {
                my $ret= $str !~ /$pat/i;
                next if $pat eq '-';
                ok($ret, 
                    "\"$sstr\"!~/\\xDF/i (str is @@{[$utf_ss||'latin']}, pat is @@{[$utf_df||'latin']})");
a3924 6
}
{
    local $Message = "BBC(Bleadperl Breaks CPAN) Today: String::Multibyte";
    my $re  = qr/(?:[\x00-\xFF]{4})/;
    my $hyp = "\0\0\0-";
    my $esc = "\0\0\0\\";
a3925 2
    my $str = "$esc$hyp$hyp$esc$esc";
    my @@a = ($str =~ /\G(?:\Q$esc$esc\E|\Q$esc$hyp\E|$re)/g);
d3927 150
a4076 22
    iseq(0+@@a,3);
    iseq(join('=', @@a),"$esc$hyp=$hyp=$esc$esc");
}
# test for keys in %+ and %-
{
    my $_ = "abcdef";
    /(?<foo>a)|(?<foo>b)/;
    iseq( (join ",", sort keys %+), "foo" );
    iseq( (join ",", sort keys %-), "foo" );
    iseq( (join ",", sort values %+), "a" );
    iseq( (join ",", sort map "@@$_", values %-), "a " );
    /(?<bar>a)(?<bar>b)(?<quux>.)/;
    iseq( (join ",", sort keys %+), "bar,quux" );
    iseq( (join ",", sort keys %-), "bar,quux" );
    iseq( (join ",", sort values %+), "a,c" ); # leftmost
    iseq( (join ",", sort map "@@$_", values %-), "a b,c" );
    /(?<un>a)(?<deux>c)?/; # second buffer won't capture
    iseq( (join ",", sort keys %+), "un" );
    iseq( (join ",", sort keys %-), "deux,un" );
    iseq( (join ",", sort values %+), "a" );
    iseq( (join ",", sort map "@@$_", values %-), ",a" );
}
d4078 12
a4089 11
# length() on captures, the numbered ones end up in Perl_magic_len
{
    my $_ = "aoeu \xe6var ook";
    /^ \w+ \s (?<eek>\S+)/x;

    iseq( length($`), 0, 'length $`' );
    iseq( length($'), 4, q[length $'] );
    iseq( length($&), 9, 'length $&' );
    iseq( length($1), 4, 'length $1' );
    iseq( length($+{eek}), 4, 'length $+{eek} == length $1' );
}
a4090 2
{
    my $ok=-1;
d4092 32
a4123 47
    $ok=exists($-{x}) ? 1 : 0
        if 'bar'=~/(?<x>foo)|bar/;
    iseq($ok,1,'$-{x} exists after "bar"=~/(?<x>foo)|bar/');
    iseq(scalar(%+), 0, 'scalar %+ == 0 after "bar"=~/(?<x>foo)|bar/');
    iseq(scalar(%-), 1, 'scalar %- == 1 after "bar"=~/(?<x>foo)|bar/');

    $ok=-1;
    $ok=exists($+{x}) ? 1 : 0
        if 'bar'=~/(?<x>foo)|bar/;
    iseq($ok,0,'$+{x} not exists after "bar"=~/(?<x>foo)|bar/');
    iseq(scalar(%+), 0, 'scalar %+ == 0 after "bar"=~/(?<x>foo)|bar/');
    iseq(scalar(%-), 1, 'scalar %- == 1 after "bar"=~/(?<x>foo)|bar/');

    $ok=-1;
    $ok=exists($-{x}) ? 1 : 0
        if 'foo'=~/(?<x>foo)|bar/;
    iseq($ok,1,'$-{x} exists after "foo"=~/(?<x>foo)|bar/');
    iseq(scalar(%+), 1, 'scalar %+ == 1 after "foo"=~/(?<x>foo)|bar/');
    iseq(scalar(%-), 1, 'scalar %- == 1 after "foo"=~/(?<x>foo)|bar/');

    $ok=-1;
    $ok=exists($+{x}) ? 1 : 0
        if 'foo'=~/(?<x>foo)|bar/;
    iseq($ok,1,'$+{x} exists after "foo"=~/(?<x>foo)|bar/');
}
{
    local $_;
    ($_ = 'abc')=~/(abc)/g;
    $_ = '123'; 
    iseq("$1",'abc',"/g leads to unsafe match vars: $1");
}
{
    local $Message="Message-ID: <20070818091501.7eff4831@@r2d2>";
    my $str= "";
    for(0..5){
        my @@x;
        $str .= "@@x"; # this should ALWAYS be the empty string
        'a'=~/(a|)/;
        push @@x,1;
    }
    iseq(length($str),"0","Trie scope error, string should be empty");
    $str="";
    my @@foo = ('a')x5;
    for (@@foo) {
        my @@bar;
        $str .= "@@bar";
        s/a|/push @@bar, 1/e;
a4124 4
    iseq(length($str),"0","Trie scope error, string should be empty");
}
{
# [perl #45605] Regexp failure with utf8-flagged and byte-flagged string
a4125 5
    my $utf_8 = "\xd6schel";
    utf8::upgrade($utf_8);
    $utf_8 =~ m{(\xd6|&Ouml;)schel};
    iseq($1,"\xd6","#45605");
}
d4127 48
a4174 12
{
    # Regardless of utf8ness any character matches itself when 
    # doing a case insensitive match. See also [perl #36207] 
    for my $o (0..255) {
        my @@ch=(chr($o),chr($o));
        utf8::upgrade($ch[1]);
        for my $u_str (0,1) {
            for my $u_pat (0,1) {
                ok( $ch[$u_str]=~/\Q$ch[$u_pat]\E/i,
                    "\$c=~/\$c/i : chr($o) : u_str=$u_str u_pat=$u_pat");
                ok( $ch[$u_str]=~/\Q$ch[$u_pat]\E|xyz/i,
                "# \$c=~/\$c|xyz/i : chr($o) : u_str=$u_str u_pat=$u_pat");
d4176 2
a4179 1
}
d4181 147
a4327 21
# Test counter is at bottom of file. Put new tests above here.
#-------------------------------------------------------------------
# Keep the following tests last -- they may crash perl
{   
    # RT#19049 / RT#38869
    my @@list = (
        'ab cdef', # matches regex
        ( 'e' x 40000 ) .'ab c' # matches not, but 'ab c' matches part of it
    );
    my $y;
    my $x;
    foreach (@@list) {
        m/ab(.+)cd/i; # the ignore-case seems to be important
        $y = $1; # use $1, which might not be from the last match!
        $x = substr($list[0],$-[0],$+[0]-$-[0]);
    }
    iseq($y,' ',
        'pattern in a loop, failure should not affect previous success');
    iseq($x,'ab cd',
        'pattern in a loop, failure should not affect previous success');
}
d4329 2
a4330 2
ok(("a" x (2**15 - 10)) =~ /^()(a|bb)*$/, "Recursive stack cracker: #24274")
    or print "# Unexpected outcome: should pass or crash perl\n";
d4332 19
a4350 19
ok((q(a)x 100) =~ /^(??{'(.)'x 100})/, 
        "Regexp /^(??{'(.)'x 100})/ crashes older perls")
    or print "# Unexpected outcome: should pass or crash perl\n";

eval '/\k/';
ok($@@=~/\QSequence \k... not terminated in regex;\E/);

{
    local $Message = "substitution with lookahead (possible segv)";
    $_="ns1ns1ns1";
    s/ns(?=\d)/ns_/g;
    iseq($_,"ns_1ns_1ns_1");
    $_="ns1";
    s/ns(?=\d)/ns_/;
    iseq($_,"ns_1");
    $_="123";
    s/(?=\d+)|(?<=\d)/!Bang!/g;
    iseq($_,"!Bang!1!Bang!2!Bang!3!Bang!");
}
d4352 18
a4369 1
# [perl #45337] utf8 + "[a]a{2}" + /$.../ = panic: sv_len_utf8 cache
d4371 1
a4371 6
{
    local ${^UTF8CACHE} = -1;
    my $s="[a]a{2}";
    utf8::upgrade $s;
    ok("aaa" =~ /$s/, "#45337");
}
d4373 1
a4373 7
# Put new tests above the dotted line about a page above this comment
iseq(0+$::test,$::TestCount,"Got the right number of tests!");
# Don't forget to update this!
BEGIN {
    $::TestCount = 4013;
    print "1..$::TestCount\n";
}
@


1.10
log
@merge in perl 5.8.8
@
text
@d9 1
a9 1
print "1..1187\n";
d15 1
d24 2
a25 3
$* = 1;
if ($x =~ /^def/) {print "ok 3\n";} else {print "not ok 3\n";}
$* = 0;
d72 2
a73 3
$* = 1;		# test 3 only tested the optimized version--this one is for real
if ("ab\ncd\n" =~ /^cd/) {print "ok 24\n";} else {print "not ok 24\n";}
$* = 0;
d480 1
a480 1
print "not " unless qr/\b\v$/i eq '(?i-xsm:\bv$)';
d484 1
a484 1
print "not " unless qr/\b\v$/s eq '(?s-xim:\bv$)';
d488 1
a488 1
print "not " unless qr/\b\v$/m eq '(?m-xis:\bv$)';
d492 1
a492 1
print "not " unless qr/\b\v$/x eq '(?x-ism:\bv$)';
d496 1
a496 1
print "not " unless qr/\b\v$/xism eq '(?msix:\bv$)';
d500 1
a500 1
print "not " unless qr/\b\v$/ eq '(?-xism:\bv$)';
d878 1
a878 3
print "not " unless($1 eq 'ab');
print "ok $test\n";
$test++;
d1049 1
a1049 3
print "not " if "@@b" ne "@@c";
print "ok $test\n";
$test++;
d1285 1
a1285 1
    my $test = 248;
d1375 1
a1375 1
    my $test = 264; # till 575
d2031 1
a2031 1
my $test = 687;
d2034 1
a2034 1
sub ok ($$) {
d2037 2
a2038 1
    printf "%sok %d - %s\n", ($ok ? "" : "not "), $test, $name;
d2604 1
a2604 5
    print "\N{LATIN SMALL LETTER SHARP S}" =~
	/\N{LATIN SMALL LETTER SHARP S}/    ? "ok 835\n" : "not ok 835\n";

    print "\N{LATIN SMALL LETTER SHARP S}" =~
	/\N{LATIN SMALL LETTER SHARP S}/i   ? "ok 836\n" : "not ok 836\n";
d2606 2
a2607 2
    print "\N{LATIN SMALL LETTER SHARP S}" =~
	/[\N{LATIN SMALL LETTER SHARP S}]/  ? "ok 837\n" : "not ok 837\n";
d2609 2
a2610 2
    print "\N{LATIN SMALL LETTER SHARP S}" =~
	/[\N{LATIN SMALL LETTER SHARP S}]/i ? "ok 838\n" : "not ok 838\n";
d2612 4
a2615 2
    print "ss" =~
	/\N{LATIN SMALL LETTER SHARP S}/i   ? "ok 839\n" : "not ok 839\n";
d2617 2
a2618 14
    print "SS" =~
	/\N{LATIN SMALL LETTER SHARP S}/i   ? "ok 840\n" : "not ok 840\n";

    print "ss" =~
	/[\N{LATIN SMALL LETTER SHARP S}]/i ? "ok 841\n" : "not ok 841\n";

    print "SS" =~
	/[\N{LATIN SMALL LETTER SHARP S}]/i ? "ok 842\n" : "not ok 842\n";

    print "\N{LATIN SMALL LETTER SHARP S}" =~ /ss/i ?
	"ok 843\n" : "not ok 843\n";

    print "\N{LATIN SMALL LETTER SHARP S}" =~ /SS/i ?
	"ok 844\n" : "not ok 844\n";
d2625 5
a2629 1
    print "<\x{100}\x{0085}>" =~ /<\x{100}\s>/ ? "ok 845\n" : "not ok 845\n";
d2737 1
a2737 1
    my $test = 865;
d2776 1
a2776 1
    my $test = 893;
d2792 1
a2792 1
    my $test = 896;
d2804 1
a2804 1
    my $test = 898;
d2984 2
a2985 2
print "\x{0712}" =~ /\p{IsSyriac1}/ ? "ok $test\n" : "not ok $test\n"; $test++;
print "\x{072F}" =~ /\P{IsSyriac1}/ ? "ok $test\n" : "not ok $test\n"; $test++;
d2994 23
a3016 2
print "\x{0712}" =~ /\p{Syriac1}/ ? "ok $test\n" : "not ok $test\n"; $test++;
print "\x{072F}" =~ /\P{Syriac1}/ ? "ok $test\n" : "not ok $test\n"; $test++;
d3025 1
a3025 1
	    ? "ok $test\n" : "not ok $test\t# $ok/$ord/$len\n";
d3172 4
a3175 1
    split /(?{ split "" })/, "abc";
d3206 10
a3215 1
ok(1, 'skip - $* not deprecated in Perl 5.8') for 1..6;
d3217 1
a3217 1
# bug #19049
d3220 1
a3220 1
ok("abcde" eq "$`", '# TODO #19049 - global match not setting $`');
d3302 1
d3380 6
d3389 2
a3390 2

{
d3394 2
d3409 1
a3409 1
    ok("\xe9" =~ /$utf8/i, "# TODO latin/utf8");
d3411 1
a3411 1
    ok($latin1 =~ /$utf8/i, "# TODO latin/utf8 runtime");
d3426 661
a4086 1
# last test 1187
d4088 480
@


1.9
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d9 1
a9 1
print "1..1065\n";
d84 8
a91 1
    /not ok 26/ && reset 'X';
d94 2
a95 1
while (($key,$val) = each(%XXX)) {
d98 1
d3290 110
a3399 1
# last test 1065
@


1.8
log
@merge local changes into perl-5.8.3
@
text
@d9 1
a9 1
print "1..1055\n";
d1913 4
a1916 3
# singleton (not in a range, this test must be ignored on EBCDIC)
print "not " unless chr(0xb5) =~ /\p{IsGreek}/ or ord("A") == 193;
print "ok 665\n";
d2241 2
a2242 1
    print "not " unless "a" =~ /\p{L&}/;
d2245 1
a2245 1
    print "not " if     "1" =~ /\p{L&}/;
d3260 20
a3279 1
# last test 1055
d3281 1
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d1694 2
a1695 1
    print "not " unless $x =~ /\p{InLatin1Supplement}/;
d1698 1
a1698 1
    print "not " if     $x =~ /\P{InLatin1Supplement}/;
d1913 2
a1914 1
print "not " unless chr(0xb5) =~ /\p{IsGreek}/; # singleton (not in a range)
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d9 1
a9 1
print "1..922\n";
d1370 1
a1370 1
{
d1373 1
a1373 1
    use charnames ':full';
d2905 353
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d7 3
a9 1
print "1..231\n";
d15 1
d295 1
a295 1
  
d315 1
a315 1
  print "# const-len `$_' not =>  $ans{$_}\nnot " 
d319 1
a319 1
  print "# var-len   `$_' not =>  $ans{$_}\nnot " 
d328 1
a328 1
sub matchit { 
d331 1
a331 1
       \( 
d337 1
a337 1
	 )	    
d344 1
a344 1
	   \( 
d347 1
a347 1
	   \) 
d414 1
a414 1
    print "#'$@@','$res','$blah'\nnot " unless $@@ and $@@ =~ /not allowed at runtime/ and $blah == 12;    
d513 3
a515 3
  my($v,$a,$b,$res) = @@_; 
  $v =~ s/\Q$a\E/$b/; 
  print "not " unless $res eq $v; 
d528 1
a528 1
$a=qr/(?{++$b})/; 
d530 2
a531 2
/$a$a/; 
print "not " unless $b eq '9'; 
d535 3
a537 3
$c="$a"; 
/$a$a/; 
print "not " unless $b eq '11'; 
d542 3
a544 3
  use re "eval"; 
  /$a$c$a/; 
  print "not " unless $b eq '14'; 
d564 1
a564 1
  no re "eval"; 
d566 1
a566 1
  print "not " 
d600 2
a601 2
$test++;  
  
d662 1
a662 1
print "not " 
d684 1
a684 1
print "not " 
d706 1
a706 1
print "not " 
d724 1
a724 1
print "not " 
d730 1
a730 1
print "not " 
d736 1
a736 1
print "not " 
d742 1
a742 1
print "not " 
d748 1
a748 1
print "not " 
d794 1
a794 1
    unless $str =~ /b(?{$foo = $_; $bar = pos})c/ 
d802 1
a802 1
    unless $str =~ /b(?{$foo = $_; $bar = pos})c/g 
d811 1
a811 1
    unless /b(?{$foo = $_; $bar = pos})c/ 
d818 1
a818 1
    unless /b(?{$foo = $_; $bar = pos})c/g 
d834 1
a834 1
    unless s/b(?{$foo = $_; $bar = pos})c/x/g and $foo eq 'abcde|abcde' 
d908 1
a908 1
$_='123x123'; 
d1120 1
a1120 1
 
d1126 101
d1232 1670
a2901 2
  print "ok $test\n";
  $test++;
d2903 2
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d7 1
a7 1
print "1..211\n";
d11 1
a11 1
    unshift @@INC, "../lib" if -d "../lib";
a14 3
# XXX known to leak scalars
$ENV{PERL_DESTRUCT_LEVEL} = 0 unless $ENV{PERL_DESTRUCT_LEVEL} > 3;

d266 1
a266 1
print "not " if $@@ !~ m%^\Q/a{1,$reg_infty}/: Quantifier in {,} bigger than%;
d271 1
a271 1
	if $@@ !~ m%^\Q/a{1,$reg_infty_p}/: Quantifier in {,} bigger than%;
d279 1
a279 1
print "not " if $@@ !~ m%^\Q/(?<=\Ex+/: lookbehind longer than 255 not%;
d496 1
a496 1
  print "not " unless $1 eq $ans;
d504 1
a504 1
  print "not " unless $& eq $ans;
d545 16
d570 17
d621 6
a626 2
&$for_future('q(a=[b]=) =~ /[x[=foo=]]/');
&$for_future('q(a.[b].) =~ /[x[.foo.]]/');
d726 24
d1056 75
@


1.3
log
@perl5.005_03 (stock)
@
text
@d7 1
a7 1
print "1..142\n";
d11 1
a11 1
    @@INC = "../lib" if -d "../lib";
d285 1
a285 8
# This one will fail when POSIX character classes do get implemented
{
	my $w;
	local $^W = 1;
	local $SIG{__WARN__} = sub{$w = shift};
	eval q('a' =~ /[[:alpha:]]/);
	print "not " if $w !~ /^\QCharacter class syntax [: :] is reserved/;
}
d359 1
d372 24
d576 2
a577 2
    local $^W; local %SIG;
    eval 'BEGIN { $^W = 1; $SIG{__WARN__} = $warn_pat };' . $code;
d616 237
d858 140
@


1.2
log
@perl 5.004_04
@
text
@d2 12
d15 2
a16 3
# $RCSfile: pat.t,v $$Revision: 4.1 $$Date: 92/08/07 18:28:12 $

print "1..62\n";
d81 1
a81 1
while ($_ = shift(XXX)) {
d231 372
@


1.1
log
@Initial revision
@
text
@d5 1
a5 1
print "1..60\n";
d137 1
d143 1
a143 1
    : "not ok 46 @@words\n";
d145 1
d149 1
a149 1
    : "not ok 47 @@words\n";
d196 1
d203 1
d211 9
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@a1 12
#
# This is a home for regular expression tests that don't fit into
# the format supported by op/regexp.t.  If you want to add a test
# that does fit that format, add it to op/re_tests, not here.

print "1..142\n";

BEGIN {
    chdir 't' if -d 't';
    @@INC = "../lib" if -d "../lib";
}
eval 'use Config';          #  Defaults assumed if this fails
d3 3
a5 2
# XXX known to leak scalars
$ENV{PERL_DESTRUCT_LEVEL} = 0 unless $ENV{PERL_DESTRUCT_LEVEL} > 3;
d70 1
a70 1
while ($_ = shift(@@XXX)) {
a136 1
pos = 0;
d142 1
a142 1
    : "not ok 46 `@@words'\n";
a143 1
pos $_ = 0;
d147 1
a147 1
    : "not ok 47 `@@words'\n";
a193 1
pos = 0;
a199 1
pos = 0;
a206 381

$_ = "abdc";
pos $_ = 2;
/\Gc/gc;
print "not " if (pos $_) != 2;
print "ok 61\n";
/\Gc/g;
print "not " if defined pos $_;
print "ok 62\n";

$out = 1;
'abc' =~ m'a(?{ $out = 2 })b';
print "not " if $out != 2;
print "ok 63\n";

$out = 1;
'abc' =~ m'a(?{ $out = 3 })c';
print "not " if $out != 1;
print "ok 64\n";

$_ = 'foobar1 bar2 foobar3 barfoobar5 foobar6';
@@out = /(?<!foo)bar./g;
print "not " if "@@out" ne 'bar2 barf';
print "ok 65\n";

# Tests which depend on REG_INFTY
$reg_infty = defined $Config{reg_infty} ? $Config{reg_infty} : 32767;
$reg_infty_m = $reg_infty - 1; $reg_infty_p = $reg_infty + 1;

# As well as failing if the pattern matches do unexpected things, the
# next three tests will fail if you should have picked up a lower-than-
# default value for $reg_infty from Config.pm, but have not.

undef $@@;
print "not " if eval q(('aaa' =~ /(a{1,$reg_infty_m})/)[0] ne 'aaa') || $@@;
print "ok 66\n";

undef $@@;
print "not " if eval q(('a' x $reg_infty_m) !~ /a{$reg_infty_m}/) || $@@;
print "ok 67\n";

undef $@@;
print "not " if eval q(('a' x ($reg_infty_m - 1)) =~ /a{$reg_infty_m}/) || $@@;
print "ok 68\n";

undef $@@;
eval "'aaa' =~ /a{1,$reg_infty}/";
print "not " if $@@ !~ m%^\Q/a{1,$reg_infty}/: Quantifier in {,} bigger than%;
print "ok 69\n";

eval "'aaa' =~ /a{1,$reg_infty_p}/";
print "not "
	if $@@ !~ m%^\Q/a{1,$reg_infty_p}/: Quantifier in {,} bigger than%;
print "ok 70\n";
undef $@@;

# Poke a couple more parse failures

$context = 'x' x 256;
eval qq("${context}y" =~ /(?<=$context)y/);
print "not " if $@@ !~ m%^\Q/(?<=\Ex+/: lookbehind longer than 255 not%;
print "ok 71\n";

# This one will fail when POSIX character classes do get implemented
{
	my $w;
	local $^W = 1;
	local $SIG{__WARN__} = sub{$w = shift};
	eval q('a' =~ /[[:alpha:]]/);
	print "not " if $w !~ /^\QCharacter class syntax [: :] is reserved/;
}
print "ok 72\n";

# Long Monsters
$test = 73;
for $l (125, 140, 250, 270, 300000, 30) { # Ordered to free memory
  $a = 'a' x $l;
  print "# length=$l\nnot " unless "ba$a=" =~ /a$a=/;
  print "ok $test\n";
  $test++;
  
  print "not " if "b$a=" =~ /a$a=/;
  print "ok $test\n";
  $test++;
}

# 20000 nodes, each taking 3 words per string, and 1 per branch
$long_constant_len = join '|', 12120 .. 32645;
$long_var_len = join '|', 8120 .. 28645;
%ans = ( 'ax13876y25677lbc' => 1,
	 'ax13876y25677mcb' => 0, # not b.
	 'ax13876y35677nbc' => 0, # Num too big
	 'ax13876y25677y21378obc' => 1,
	 'ax13876y25677y21378zbc' => 0,	# Not followed by [k-o]
	 'ax13876y25677y21378y21378kbc' => 1,
	 'ax13876y25677y21378y21378kcb' => 0, # Not b.
	 'ax13876y25677y21378y21378y21378kbc' => 0, # 5 runs
       );

for ( keys %ans ) {
  print "# const-len `$_' not =>  $ans{$_}\nnot " 
    if $ans{$_} xor /a(?=([yx]($long_constant_len)){2,4}[k-o]).*b./o;
  print "ok $test\n";
  $test++;
  print "# var-len   `$_' not =>  $ans{$_}\nnot " 
    if $ans{$_} xor /a(?=([yx]($long_var_len)){2,4}[k-o]).*b./o;
  print "ok $test\n";
  $test++;
}

$_ = " a (bla()) and x(y b((l)u((e))) and b(l(e)e)e";
$expect = "(bla()) ((l)u((e))) (l(e)e)";

sub matchit { 
  m/
     (
       \( 
       (?{ $c = 1 })		# Initialize
       (?:
	 (?(?{ $c == 0 })       # PREVIOUS iteration was OK, stop the loop
	   (?!
	   )			# Fail: will unwind one iteration back
	 )	    
	 (?:
	   [^()]+		# Match a big chunk
	   (?=
	     [()]
	   )			# Do not try to match subchunks
	 |
	   \( 
	   (?{ ++$c })
	 |
	   \) 
	   (?{ --$c })
	 )
       )+			# This may not match with different subblocks
     )
     (?(?{ $c != 0 })
       (?!
       )			# Fail
     )				# Otherwise the chunk 1 may succeed with $c>0
   /xg;
}

push @@ans, $res while $res = matchit;

print "# ans='@@ans'\n# expect='$expect'\nnot " if "@@ans" ne "1 1 1";
print "ok $test\n";
$test++;

@@ans = matchit;

print "# ans='@@ans'\n# expect='$expect'\nnot " if "@@ans" ne $expect;
print "ok $test\n";
$test++;

@@ans = ('a/b' =~ m%(.*/)?(.*)%);	# Stack may be bad
print "not " if "@@ans" ne 'a/ b';
print "ok $test\n";
$test++;

$code = '{$blah = 45}';
$blah = 12;
eval { /(?$code)/ };
print "not " unless $@@ and $@@ =~ /not allowed at runtime/ and $blah == 12;
print "ok $test\n";
$test++;

for $code ('{$blah = 45}','=xx') {
  $blah = 12;
  $res = eval { "xx" =~ /(?$code)/o };
  if ($code eq '=xx') {
    print "#'$@@','$res','$blah'\nnot " unless not $@@ and $res;
  } else {
    print "#'$@@','$res','$blah'\nnot " unless $@@ and $@@ =~ /not allowed at runtime/ and $blah == 12;    
  }
  print "ok $test\n";
  $test++;
}

$code = '{$blah = 45}';
$blah = 12;
eval "/(?$code)/";			
print "not " if $blah != 45;
print "ok $test\n";
$test++;

$blah = 12;
/(?{$blah = 45})/;			
print "not " if $blah != 45;
print "ok $test\n";
$test++;

$x = 'banana';
$x =~ /.a/g;
print "not " unless pos($x) == 2;
print "ok $test\n";
$test++;

$x =~ /.z/gc;
print "not " unless pos($x) == 2;
print "ok $test\n";
$test++;

sub f {
    my $p = $_[0];
    return $p;
}

$x =~ /.a/g;
print "not " unless f(pos($x)) == 4;
print "ok $test\n";
$test++;

$x = $^R = 67;
'foot' =~ /foo(?{$x = 12; 75})[t]/;
print "not " unless $^R eq '75';
print "ok $test\n";
$test++;

$x = $^R = 67;
'foot' =~ /foo(?{$x = 12; 75})[xy]/;
print "not " unless $^R eq '67' and $x eq '12';
print "ok $test\n";
$test++;

$x = $^R = 67;
'foot' =~ /foo(?{ $^R + 12 })((?{ $x = 12; $^R + 17 })[xy])?/;
print "not " unless $^R eq '79' and $x eq '12';
print "ok $test\n";
$test++;

print "not " unless qr/\b\v$/i eq '(?i-xsm:\bv$)';
print "ok $test\n";
$test++;

print "not " unless qr/\b\v$/s eq '(?s-xim:\bv$)';
print "ok $test\n";
$test++;

print "not " unless qr/\b\v$/m eq '(?m-xis:\bv$)';
print "ok $test\n";
$test++;

print "not " unless qr/\b\v$/x eq '(?x-ism:\bv$)';
print "ok $test\n";
$test++;

print "not " unless qr/\b\v$/xism eq '(?msix:\bv$)';
print "ok $test\n";
$test++;

print "not " unless qr/\b\v$/ eq '(?-xism:\bv$)';
print "ok $test\n";
$test++;

$_ = 'xabcx';
foreach $ans ('', 'c') {
  /(?<=(?=a)..)((?=c)|.)/g;
  print "not " unless $1 eq $ans;
  print "ok $test\n";
  $test++;
}

$_ = 'a';
foreach $ans ('', 'a', '') {
  /^|a|$/g;
  print "not " unless $& eq $ans;
  print "ok $test\n";
  $test++;
}

sub prefixify {
  my($v,$a,$b,$res) = @@_; 
  $v =~ s/\Q$a\E/$b/; 
  print "not " unless $res eq $v; 
  print "ok $test\n";
  $test++;
}
prefixify('/a/b/lib/arch', "/a/b/lib", 'X/lib', 'X/lib/arch');
prefixify('/a/b/man/arch', "/a/b/man", 'X/man', 'X/man/arch');

$_ = 'var="foo"';
/(\")/;
print "not " unless $1 and /$1/;
print "ok $test\n";
$test++;

$a=qr/(?{++$b})/; 
$b = 7;
/$a$a/; 
print "not " unless $b eq '9'; 
print "ok $test\n";
$test++;

$c="$a"; 
/$a$a/; 
print "not " unless $b eq '11'; 
print "ok $test\n";
$test++;

{
  use re "eval"; 
  /$a$c$a/; 
  print "not " unless $b eq '14'; 
  print "ok $test\n";
  $test++;

  no re "eval"; 
  $match = eval { /$a$c$a/ };
  print "not " 
    unless $b eq '14' and $@@ =~ /Eval-group not allowed/ and not $match;
  print "ok $test\n";
  $test++;
}

{
  package aa;
  $c = 2;
  $::c = 3;
  '' =~ /(?{ $c = 4 })/;
  print "not " unless $c == 4;
}
print "ok $test\n";
$test++;
print "not " unless $c == 3;
print "ok $test\n";
$test++;  
  
sub must_warn_pat {
    my $warn_pat = shift;
    return sub { print "not " unless $_[0] =~ /$warn_pat/ }
}

sub must_warn {
    my ($warn_pat, $code) = @@_;
    local $^W; local %SIG;
    eval 'BEGIN { $^W = 1; $SIG{__WARN__} = $warn_pat };' . $code;
    print "ok $test\n";
    $test++;
}


sub make_must_warn {
    my $warn_pat = shift;
    return sub { must_warn(must_warn_pat($warn_pat)) }
}

my $for_future = make_must_warn('reserved for future extensions');

&$for_future('q(a:[b]:) =~ /[x[:foo:]]/');
&$for_future('q(a=[b]=) =~ /[x[=foo=]]/');
&$for_future('q(a.[b].) =~ /[x[.foo.]]/');

# test if failure of patterns returns empty list
$_ = 'aaa';
@@_ = /bbb/;
print "not " if @@_;
print "ok $test\n";
$test++;

@@_ = /bbb/g;
print "not " if @@_;
print "ok $test\n";
$test++;

@@_ = /(bbb)/;
print "not " if @@_;
print "ok $test\n";
$test++;

@@_ = /(bbb)/g;
print "not " if @@_;
print "ok $test\n";
$test++;

# see if matching against temporaries (created via pp_helem()) is safe
{ foo => "ok $test\n".$^X }->{foo} =~ /^(.*)\n/g;
print "$1\n";
$test++;

@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d7 1
a7 1
print "1..211\n";
d11 1
a11 1
    unshift @@INC, "../lib" if -d "../lib";
d285 8
a292 1
# removed test
a365 1
@@ans = ();
a377 24
print "not " unless "abc" =~ /^(??{"a"})b/;
print "ok $test\n";
$test++;

my $matched;
$matched = qr/\((?:(?>[^()]+)|(??{$matched}))*\)/;

@@ans = @@ans1 = ();
push(@@ans, $res), push(@@ans1, $&) while $res = m/$matched/g;

print "# ans='@@ans'\n# expect='$expect'\nnot " if "@@ans" ne "1 1 1";
print "ok $test\n";
$test++;

print "# ans1='@@ans1'\n# expect='$expect'\nnot " if "@@ans1" ne $expect;
print "ok $test\n";
$test++;

@@ans = m/$matched/g;

print "# ans='@@ans'\n# expect='$expect'\nnot " if "@@ans" ne $expect;
print "ok $test\n";
$test++;

d558 2
a559 2
    local %SIG;
    eval 'BEGIN { use warnings; $SIG{__WARN__} = $warn_pat };' . $code;
a597 237
/a(?=.$)/;
print "not " if $#+ != 0 or $#- != 0;
print "ok $test\n";
$test++;

print "not " if $+[0] != 2 or $-[0] != 1;
print "ok $test\n";
$test++;

print "not " 
   if defined $+[1] or defined $-[1] or defined $+[2] or defined $-[2];
print "ok $test\n";
$test++;

/a(a)(a)/;
print "not " if $#+ != 2 or $#- != 2;
print "ok $test\n";
$test++;

print "not " if $+[0] != 3 or $-[0] != 0;
print "ok $test\n";
$test++;

print "not " if $+[1] != 2 or $-[1] != 1;
print "ok $test\n";
$test++;

print "not " if $+[2] != 3 or $-[2] != 2;
print "ok $test\n";
$test++;

print "not " 
   if defined $+[3] or defined $-[3] or defined $+[4] or defined $-[4];
print "ok $test\n";
$test++;

/.(a)(b)?(a)/;
print "not " if $#+ != 3 or $#- != 3;
print "ok $test\n";
$test++;

print "not " if $+[0] != 3 or $-[0] != 0;
print "ok $test\n";
$test++;

print "not " if $+[1] != 2 or $-[1] != 1;
print "ok $test\n";
$test++;

print "not " if $+[3] != 3 or $-[3] != 2;
print "ok $test\n";
$test++;

print "not " 
   if defined $+[2] or defined $-[2] or defined $+[4] or defined $-[4];
print "ok $test\n";
$test++;

/.(a)/;
print "not " if $#+ != 1 or $#- != 1;
print "ok $test\n";
$test++;

print "not " if $+[0] != 2 or $-[0] != 0;
print "ok $test\n";
$test++;

print "not " if $+[1] != 2 or $-[1] != 1;
print "ok $test\n";
$test++;

print "not " 
   if defined $+[2] or defined $-[2] or defined $+[3] or defined $-[3];
print "ok $test\n";
$test++;

/.(a)(ba*)?/;
print "#$#-..$#+\nnot " if $#+ != 2 or $#- != 1;
print "ok $test\n";
$test++;

$_ = 'aaa';
pos = 1;
@@a = /\Ga/g;
print "not " unless "@@a" eq "a a";
print "ok $test\n";
$test++;

$str = 'abcde';
pos $str = 2;

print "not " if $str =~ /^\G/;
print "ok $test\n";
$test++;

print "not " if $str =~ /^.\G/;
print "ok $test\n";
$test++;

print "not " unless $str =~ /^..\G/;
print "ok $test\n";
$test++;

print "not " if $str =~ /^...\G/;
print "ok $test\n";
$test++;

print "not " unless $str =~ /.\G./ and $& eq 'bc';
print "ok $test\n";
$test++;

print "not " unless $str =~ /\G../ and $& eq 'cd';
print "ok $test\n";
$test++;

undef $foo; undef $bar;
print "#'$str','$foo','$bar'\nnot "
    unless $str =~ /b(?{$foo = $_; $bar = pos})c/ 
	and $foo eq 'abcde' and $bar eq 2;
print "ok $test\n";
$test++;

undef $foo; undef $bar;
pos $str = undef;
print "#'$str','$foo','$bar'\nnot "
    unless $str =~ /b(?{$foo = $_; $bar = pos})c/g 
	and $foo eq 'abcde' and $bar eq 2 and pos $str eq 3;
print "ok $test\n";
$test++;

$_ = $str;

undef $foo; undef $bar;
print "#'$str','$foo','$bar'\nnot "
    unless /b(?{$foo = $_; $bar = pos})c/ 
	and $foo eq 'abcde' and $bar eq 2;
print "ok $test\n";
$test++;

undef $foo; undef $bar;
print "#'$str','$foo','$bar'\nnot "
    unless /b(?{$foo = $_; $bar = pos})c/g 
	and $foo eq 'abcde' and $bar eq 2 and pos eq 3;
print "ok $test\n";
$test++;

undef $foo; undef $bar;
pos = undef;
1 while /b(?{$foo = $_; $bar = pos})c/g;
print "#'$str','$foo','$bar'\nnot "
    unless $foo eq 'abcde' and $bar eq 2 and not defined pos;
print "ok $test\n";
$test++;

undef $foo; undef $bar;
$_ = 'abcde|abcde';
print "#'$str','$foo','$bar','$_'\nnot "
    unless s/b(?{$foo = $_; $bar = pos})c/x/g and $foo eq 'abcde|abcde' 
	and $bar eq 8 and $_ eq 'axde|axde';
print "ok $test\n";
$test++;

@@res = ();
# List context:
$_ = 'abcde|abcde';
@@dummy = /([ace]).(?{push @@res, $1,$2})([ce])(?{push @@res, $1,$2})/g;
@@res = map {defined $_ ? "'$_'" : 'undef'} @@res;
$res = "@@res";
print "#'@@res' '$_'\nnot "
    unless "@@res" eq "'a' undef 'a' 'c' 'e' undef 'a' undef 'a' 'c'";
print "ok $test\n";
$test++;

@@res = ();
@@dummy = /([ace]).(?{push @@res, $`,$&,$'})([ce])(?{push @@res, $`,$&,$'})/g;
@@res = map {defined $_ ? "'$_'" : 'undef'} @@res;
$res = "@@res";
print "#'@@res' '$_'\nnot "
    unless "@@res" eq
  "'' 'ab' 'cde|abcde' " .
  "'' 'abc' 'de|abcde' " .
  "'abcd' 'e|' 'abcde' " .
  "'abcde|' 'ab' 'cde' " .
  "'abcde|' 'abc' 'de'" ;
print "ok $test\n";
$test++;

#Some more \G anchor checks
$foo='aabbccddeeffgg';

pos($foo)=1;

$foo=~/.\G(..)/g;
print "not " unless($1 eq 'ab');
print "ok $test\n";
$test++;

pos($foo) += 1;
$foo=~/.\G(..)/g;
print "not " unless($1 eq 'cc');
print "ok $test\n";
$test++;

pos($foo) += 1;
$foo=~/.\G(..)/g;
print "not " unless($1 eq 'de');
print "ok $test\n";
$test++;

print "not " unless $foo =~ /\Gef/g;
print "ok $test\n";
$test++;

undef pos $foo;

$foo=~/\G(..)/g;
print "not " unless($1  eq 'aa');
print "ok $test\n";
$test++;

$foo=~/\G(..)/g;
print "not " unless($1  eq 'bb');
print "ok $test\n";
$test++;

pos($foo)=5;
$foo=~/\G(..)/g;
print "not " unless($1  eq 'cd');
print "ok $test\n";
$test++;

$_='123x123'; 
@@res = /(\d*|x)/g;
print "not " unless('123||x|123|' eq join '|', @@res);
print "ok $test\n";
$test++;

a602 140
# See if $i work inside (?{}) in the presense of saved substrings and
# changing $_
@@a = qw(foo bar);
@@b = ();
s/(\w)(?{push @@b, $1})/,$1,/g for @@a;

print "# \@@b='@@b', expect 'f o o b a r'\nnot " unless("@@b" eq "f o o b a r");
print "ok $test\n";
$test++;

print "not " unless("@@a" eq ",f,,o,,o, ,b,,a,,r,");
print "ok $test\n";
$test++;

$brackets = qr{
	         {  (?> [^{}]+ | (??{ $brackets }) )* }
	      }x;

"{{}" =~ $brackets;
print "ok $test\n";		# Did we survive?
$test++;

"something { long { and } hairy" =~ $brackets;
print "ok $test\n";		# Did we survive?
$test++;

"something { long { and } hairy" =~ m/((??{ $brackets }))/;
print "not " unless $1 eq "{ and }";
print "ok $test\n";
$test++;

$_ = "a-a\nxbb";
pos=1;
m/^-.*bb/mg and print "not ";
print "ok $test\n";
$test++;

$text = "aaXbXcc";
pos($text)=0;
$text =~ /\GXb*X/g and print 'not ';
print "ok $test\n";
$test++;

$text = "xA\n" x 500;
$text =~ /^\s*A/m and print 'not ';
print "ok $test\n";
$test++;

$text = "abc dbf";
@@res = ($text =~ /.*?(b).*?\b/g);
"@@res" eq 'b b' or print 'not ';
print "ok $test\n";
$test++;

@@a = map chr,0..255;

@@b = grep(/\S/,@@a);
@@c = grep(/[^\s]/,@@a);
print "not " if "@@b" ne "@@c";
print "ok $test\n";
$test++;

@@b = grep(/\S/,@@a);
@@c = grep(/[\S]/,@@a);
print "not " if "@@b" ne "@@c";
print "ok $test\n";
$test++;

@@b = grep(/\s/,@@a);
@@c = grep(/[^\S]/,@@a);
print "not " if "@@b" ne "@@c";
print "ok $test\n";
$test++;

@@b = grep(/\s/,@@a);
@@c = grep(/[\s]/,@@a);
print "not " if "@@b" ne "@@c";
print "ok $test\n";
$test++;

@@b = grep(/\D/,@@a);
@@c = grep(/[^\d]/,@@a);
print "not " if "@@b" ne "@@c";
print "ok $test\n";
$test++;

@@b = grep(/\D/,@@a);
@@c = grep(/[\D]/,@@a);
print "not " if "@@b" ne "@@c";
print "ok $test\n";
$test++;

@@b = grep(/\d/,@@a);
@@c = grep(/[^\D]/,@@a);
print "not " if "@@b" ne "@@c";
print "ok $test\n";
$test++;

@@b = grep(/\d/,@@a);
@@c = grep(/[\d]/,@@a);
print "not " if "@@b" ne "@@c";
print "ok $test\n";
$test++;

@@b = grep(/\W/,@@a);
@@c = grep(/[^\w]/,@@a);
print "not " if "@@b" ne "@@c";
print "ok $test\n";
$test++;

@@b = grep(/\W/,@@a);
@@c = grep(/[\W]/,@@a);
print "not " if "@@b" ne "@@c";
print "ok $test\n";
$test++;

@@b = grep(/\w/,@@a);
@@c = grep(/[^\W]/,@@a);
print "not " if "@@b" ne "@@c";
print "ok $test\n";
$test++;

@@b = grep(/\w/,@@a);
@@c = grep(/[\w]/,@@a);
print "not " if "@@b" ne "@@c";
print "ok $test\n";
$test++;

# see if backtracking optimization works correctly
"\n\n" =~ /\n  $ \n/x or print "not ";
print "ok $test\n";
$test++;

"\n\n" =~ /\n* $ \n/x or print "not ";
print "ok $test\n";
$test++;

"\n\n" =~ /\n+ $ \n/x or print "not ";
print "ok $test\n";
$test++;
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d7 1
a7 1
print "1..231\n";
d11 1
a11 1
    @@INC = '../lib';
d15 3
d269 1
a269 1
print "not " if $@@ !~ m%^\QQuantifier in {,} bigger than%;
d274 1
a274 1
	if $@@ !~ m%^\QQuantifier in {,} bigger than%;
d282 1
a282 1
print "not " if $@@ !~ m%^\QLookbehind longer than 255 not%;
d499 1
a499 1
  print "# \$1  ='$1'\n# \$ans='$ans'\nnot " unless $1 eq $ans;
d507 1
a507 1
  print "# \$&  ='$&'\n# \$ans='$ans'\nnot " unless $& eq $ans;
a547 16
  local $lex_a = 2;
  my $lex_a = 43;
  my $lex_b = 17;
  my $lex_c = 27;
  my $lex_res = ($lex_b =~ qr/$lex_b(?{ $lex_c = $lex_a++ })/);
  print "not " unless $lex_res eq '1';
  print "ok $test\n";
  $test++;
  print "not " unless $lex_a eq '44';
  print "ok $test\n";
  $test++;
  print "not " unless $lex_c eq '43';
  print "ok $test\n";
  $test++;


a556 17
  local $lex_a = 2;
  my $lex_a = 43;
  my $lex_b = 17;
  my $lex_c = 27;
  my $lex_res = ($lex_b =~ qr/17(?{ $lex_c = $lex_a++ })/);
  print "not " unless $lex_res eq '1';
  print "ok $test\n";
  $test++;
  print "not " unless $lex_a eq '44';
  print "ok $test\n";
  $test++;
  print "not " unless $lex_c eq '43';
  print "ok $test\n";
  $test++;
}

{
d591 2
a592 6

#&$for_future('q(a=[b]=) =~ /[x[=foo=]]/');
print "ok $test\n"; $test++; # now a fatal croak

#&$for_future('q(a.[b].) =~ /[x[.foo.]]/');
print "ok $test\n"; $test++; # now a fatal croak
a691 24
eval { $+[0] = 13; };
print "not " 
   if $@@ !~ /^Modification of a read-only value attempted/;
print "ok $test\n";
$test++;

eval { $-[0] = 13; };
print "not " 
   if $@@ !~ /^Modification of a read-only value attempted/;
print "ok $test\n";
$test++;

eval { @@+ = (7, 6, 5); };
print "not " 
   if $@@ !~ /^Modification of a read-only value attempted/;
print "ok $test\n";
$test++;

eval { @@- = qw(foo bar); };
print "not " 
   if $@@ !~ /^Modification of a read-only value attempted/;
print "ok $test\n";
$test++;

a997 75

[] =~ /^ARRAY/ or print "# [] \nnot ";
print "ok $test\n";
$test++;

eval << 'EOE';
{
 package S;
 use overload '""' => sub { 'Object S' };
 sub new { bless [] }
}
$a = 'S'->new;
EOE

$a and $a =~ /^Object\sS/ or print "# '$a' \nnot ";
print "ok $test\n";
$test++;

# test result of match used as match (!)
'a1b' =~ ('xyz' =~ /y/) and $` eq 'a' or print "not ";
print "ok $test\n";
$test++;

'a1b' =~ ('xyz' =~ /t/) and $` eq 'a' or print "not ";
print "ok $test\n";
$test++;

$w = 0;
{
    local $SIG{__WARN__} = sub { $w = 1 };
    local $^W = 1;
	$w = 1 if ("1\n" x 102) =~ /^\s*\n/m;
}
print $w ? "not " : "", "ok $test\n";
$test++;

my %space = ( spc   => " ",
	      tab   => "\t",
	      cr    => "\r",
	      lf    => "\n",
	      ff    => "\f",
# There's no \v but the vertical tabulator seems miraculously
# be 11 both in ASCII and EBCDIC.
	      vt    => chr(11),
	      false => "space" );

my @@space0 = sort grep { $space{$_} =~ /\s/ }          keys %space;
my @@space1 = sort grep { $space{$_} =~ /[[:space:]]/ } keys %space;
my @@space2 = sort grep { $space{$_} =~ /[[:blank:]]/ } keys %space;

print "not " unless "@@space0" eq "cr ff lf spc tab";
print "ok $test # @@space0\n";
$test++;

print "not " unless "@@space1" eq "cr ff lf spc tab vt";
print "ok $test # @@space1\n";
$test++;

print "not " unless "@@space2" eq "spc tab";
print "ok $test # @@space2\n";
$test++;
 
# bugid 20001021.005 - this caused a SEGV
print "not " unless undef =~ /^([^\/]*)(.*)$/;
print "ok $test\n";
$test++;

{
  # japhy -- added 03/03/2001
  () = (my $str = "abc") =~ /(...)/;
  $str = "def";
  print "not " if $1 ne "abc";
  print "ok $test\n";
  $test++;
}
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d7 1
a7 3
$| = 1;

print "1..922\n";
a12 1

d292 1
a292 1

d312 1
a312 1
  print "# const-len `$_' not =>  $ans{$_}\nnot "
d316 1
a316 1
  print "# var-len   `$_' not =>  $ans{$_}\nnot "
d325 1
a325 1
sub matchit {
d328 1
a328 1
       \(
d334 1
a334 1
	 )	
d341 1
a341 1
	   \(
d344 1
a344 1
	   \)
d411 1
a411 1
    print "#'$@@','$res','$blah'\nnot " unless $@@ and $@@ =~ /not allowed at runtime/ and $blah == 12;
d510 3
a512 3
  my($v,$a,$b,$res) = @@_;
  $v =~ s/\Q$a\E/$b/;
  print "not " unless $res eq $v;
d525 1
a525 1
$a=qr/(?{++$b})/;
d527 2
a528 2
/$a$a/;
print "not " unless $b eq '9';
d532 3
a534 3
$c="$a";
/$a$a/;
print "not " unless $b eq '11';
d539 3
a541 3
  use re "eval";
  /$a$c$a/;
  print "not " unless $b eq '14';
d561 1
a561 1
  no re "eval";
d563 1
a563 1
  print "not "
d597 2
a598 2
$test++;

d659 1
a659 1
print "not "
d681 1
a681 1
print "not "
d703 1
a703 1
print "not "
d721 1
a721 1
print "not "
d727 1
a727 1
print "not "
d733 1
a733 1
print "not "
d739 1
a739 1
print "not "
d745 1
a745 1
print "not "
d791 1
a791 1
    unless $str =~ /b(?{$foo = $_; $bar = pos})c/
d799 1
a799 1
    unless $str =~ /b(?{$foo = $_; $bar = pos})c/g
d808 1
a808 1
    unless /b(?{$foo = $_; $bar = pos})c/
d815 1
a815 1
    unless /b(?{$foo = $_; $bar = pos})c/g
d831 1
a831 1
    unless s/b(?{$foo = $_; $bar = pos})c/x/g and $foo eq 'abcde|abcde'
d905 1
a905 1
$_='123x123';
d1117 1
a1117 1

a1122 101
# bugid 20000731.001

print "not " unless "A \x{263a} B z C" =~ /A . B (??{ "z" }) C/;
print "ok $test\n";
$test++;

my $ordA = ord('A');

$_ = "a\x{100}b";
if (/(.)(\C)(\C)(.)/) {
  print "ok 232\n";
  if ($1 eq "a") {
    print "ok 233\n";
  } else {
    print "not ok 233\n";
  }
  if ($ordA == 65) { # ASCII (or equivalent), should be UTF-8
      if ($2 eq "\xC4") {
	  print "ok 234\n";
      } else {
	  print "not ok 234\n";
      }
      if ($3 eq "\x80") {
	  print "ok 235\n";
      } else {
	  print "not ok 235\n";
      }
  } elsif ($ordA == 193) { # EBCDIC (or equivalent), should be UTF-EBCDIC
      if ($2 eq "\x8C") {
	  print "ok 234\n";
      } else {
	  print "not ok 234\n";
      }
      if ($3 eq "\x41") {
	  print "ok 235\n";
      } else {
	  print "not ok 235\n";
      }
  } else {
      for (234..235) {
	  print "not ok $_ # ord('A') == $ordA\n";
      }
  }
  if ($4 eq "b") {
    print "ok 236\n";
  } else {
    print "not ok 236\n";
  }
} else {
  for (232..236) {
    print "not ok $_\n";
  }
}
$_ = "\x{100}";
if (/(\C)/g) {
  print "ok 237\n";
  # currently \C are still tagged as UTF-8
  if ($ordA == 65) {
      if ($1 eq "\xC4") {
	  print "ok 238\n";
      } else {
	  print "not ok 238\n";
      }
  } elsif ($ordA == 193) {
      if ($1 eq "\x8C") {
	  print "ok 238\n";
      } else {
	  print "not ok 238\n";
      }
  } else {
      print "not ok 238 # ord('A') == $ordA\n";
  }
} else {
  for (237..238) {
    print "not ok $_\n";
  }
}
if (/(\C)/g) {
  print "ok 239\n";
  # currently \C are still tagged as UTF-8
  if ($ordA == 65) {
      if ($1 eq "\x80") {
	  print "ok 240\n";
      } else {
	  print "not ok 240\n";
      }
  } elsif ($ordA == 193) {
      if ($1 eq "\x41") {
	  print "ok 240\n";
      } else {
	  print "not ok 240\n";
      }
  } else {
      print "not ok 240 # ord('A') == $ordA\n";
  }
} else {
  for (239..240) {
    print "not ok $_\n";
  }
}

d1128 2
a1129 1192
  print "ok 241\n";
}

# The 242 and 243 go with the 244 and 245.
# The trick is that in EBCDIC the explicit numeric range should match
# (as also in non-EBCDIC) but the explicit alphabetic range should not match.

if ("\x8e" =~ /[\x89-\x91]/) {
  print "ok 242\n";
} else {
  print "not ok 242\n";
}

if ("\xce" =~ /[\xc9-\xd1]/) {
  print "ok 243\n";
} else {
  print "not ok 243\n";
}

# In most places these tests would succeed since \x8e does not
# in most character sets match 'i' or 'j' nor would \xce match
# 'I' or 'J', but strictly speaking these tests are here for
# the good of EBCDIC, so let's test these only there.
if (ord('i') == 0x89 && ord('J') == 0xd1) { # EBCDIC
  if ("\x8e" !~ /[i-j]/) {
    print "ok 244\n";
  } else {
    print "not ok 244\n";
  }
  if ("\xce" !~ /[I-J]/) {
    print "ok 245\n";
  } else {
    print "not ok 245\n";
  }
} else {
  for (244..245) {
    print "ok $_ # Skip: only in EBCDIC\n";
  }
}

print "not " unless "\x{ab}" =~ /\x{ab}/;
print "ok 246\n";

print "not " unless "\x{abcd}" =~ /\x{abcd}/;
print "ok 247\n";

{
    # bug id 20001008.001

    my $test = 248;
    my @@x = ("stra\337e 138","stra\337e 138");
    for (@@x) {
	s/(\d+)\s*([\w\-]+)/$1 . uc $2/e;
	my($latin) = /^(.+)(?:\s+\d)/;
	print $latin eq "stra\337e" ? "ok $test\n" :	# 248,249
	    "#latin[$latin]\nnot ok $test\n";
	$test++;
	$latin =~ s/stra\337e/straße/; # \303\237 after the 2nd a
	use utf8; # needed for the raw UTF-8
	$latin =~ s!(s)tr(?:aß|s+e)!$1tr.!; # \303\237 after the a
    }
}

{
    print "not " unless "ba\xd4c" =~ /([a\xd4]+)/ && $1 eq "a\xd4";
    print "ok 250\n";

    print "not " unless "ba\xd4c" =~ /([a\xd4]+)/ && $1 eq "a\x{d4}";
    print "ok 251\n";

    print "not " unless "ba\x{d4}c" =~ /([a\xd4]+)/ && $1 eq "a\x{d4}";
    print "ok 252\n";

    print "not " unless "ba\x{d4}c" =~ /([a\xd4]+)/ && $1 eq "a\xd4";
    print "ok 253\n";

    print "not " unless "ba\xd4c" =~ /([a\x{d4}]+)/ && $1 eq "a\xd4";
    print "ok 254\n";

    print "not " unless "ba\xd4c" =~ /([a\x{d4}]+)/ && $1 eq "a\x{d4}";
    print "ok 255\n";

    print "not " unless "ba\x{d4}c" =~ /([a\x{d4}]+)/ && $1 eq "a\x{d4}";
    print "ok 256\n";

    print "not " unless "ba\x{d4}c" =~ /([a\x{d4}]+)/ && $1 eq "a\xd4";
    print "ok 257\n";
}

{
    # the first half of 20001028.003

    my $X = chr(1448);
    my ($Y) = $X =~ /(.*)/;
    print "not " unless $Y eq v1448 && length($Y) == 1;
    print "ok 258\n";
}

{
    # 20001108.001

    my $X = "Szab\x{f3},Bal\x{e1}zs";
    my $Y = $X;
    $Y =~ s/(B)/$1/ for 0..3;
    print "not " unless $Y eq $X && $X eq "Szab\x{f3},Bal\x{e1}zs";
    print "ok 259\n";
}

{
    # the second half of 20001028.003

    my $X = '';
    $X =~ s/^/chr(1488)/e;
    print "not " unless length $X == 1 && ord($X) == 1488;
    print "ok 260\n";
}

{
    # 20000517.001

    my $x = "\x{100}A";

    $x =~ s/A/B/;

    print "not " unless $x eq "\x{100}B" && length($x) == 2;
    print "ok 261\n";
}

{
    # bug id 20001230.002

    print "not " unless "École" =~ /^\C\C(.)/ && $1 eq 'c';
    print "ok 262\n";

    print "not " unless "École" =~ /^\C\C(c)/;
    print "ok 263\n";
}

{
    my $test = 264; # till 575

    use charnames ':full';

    # This is far from complete testing, there are dozens of character
    # classes in Unicode.  The mixing of literals and \N{...} is
    # intentional so that in non-Latin-1 places we test the native
    # characters, not the Unicode code points.

    my %s = (
	     "a" 				=> 'Ll',
	     "\N{CYRILLIC SMALL LETTER A}"	=> 'Ll',
	     "A" 				=> 'Lu',
	     "\N{GREEK CAPITAL LETTER ALPHA}"	=> 'Lu',
	     "\N{HIRAGANA LETTER SMALL A}"	=> 'Lo',
	     "\N{COMBINING GRAVE ACCENT}"	=> 'Mn',
	     "0"				=> 'Nd',
	     "\N{ARABIC-INDIC DIGIT ZERO}"	=> 'Nd',
	     "_"				=> 'N',
	     "!"				=> 'P',
	     " "				=> 'Zs',
	     "\0"				=> 'Cc',
	     );
	
    for my $char (map { s/^\S+ //; $_ }
                    sort map { sprintf("%06x", ord($_))." $_" } keys %s) {
	my $class = $s{$char};
	my $code  = sprintf("%06x", ord($char));
	printf "#\n# 0x$code\n#\n";
	print "# IsAlpha\n";
	if ($class =~ /^[LM]/) {
	    print "not " unless $char =~ /\p{IsAlpha}/;
	    print "ok $test\n"; $test++;
	    print "not " if     $char =~ /\P{IsAlpha}/;
	    print "ok $test\n"; $test++;
	} else {
	    print "not " if     $char =~ /\p{IsAlpha}/;
	    print "ok $test\n"; $test++;
	    print "not " unless $char =~ /\P{IsAlpha}/;
	    print "ok $test\n"; $test++;
	}
	print "# IsAlnum\n";
	if ($class =~ /^[LMN]/ && $char ne "_") {
	    print "not " unless $char =~ /\p{IsAlnum}/;
	    print "ok $test\n"; $test++;
	    print "not " if     $char =~ /\P{IsAlnum}/;
	    print "ok $test\n"; $test++;
	} else {
	    print "not " if     $char =~ /\p{IsAlnum}/;
	    print "ok $test\n"; $test++;
	    print "not " unless $char =~ /\P{IsAlnum}/;
	    print "ok $test\n"; $test++;
	}
	print "# IsASCII\n";
	if (ord("A") == 193) {
	    print "ok $test # Skip: in EBCDIC\n"; $test++;
	    print "ok $test # Skip: in EBCDIC\n"; $test++;
	} else {
	    if ($code le '00007f') {
		print "not " unless $char =~ /\p{IsASCII}/;
		print "ok $test\n"; $test++;
		print "not " if     $char =~ /\P{IsASCII}/;
		print "ok $test\n"; $test++;
	    } else {
		print "not " if     $char =~ /\p{IsASCII}/;
		print "ok $test\n"; $test++;
		print "not " unless $char =~ /\P{IsASCII}/;
		print "ok $test\n"; $test++;
	    }
	}
	print "# IsCntrl\n";
	if ($class =~ /^C/) {
	    print "not " unless $char =~ /\p{IsCntrl}/;
	    print "ok $test\n"; $test++;
	    print "not " if     $char =~ /\P{IsCntrl}/;
	    print "ok $test\n"; $test++;
	} else {
	    print "not " if     $char =~ /\p{IsCntrl}/;
	    print "ok $test\n"; $test++;
	    print "not " unless $char =~ /\P{IsCntrl}/;
	    print "ok $test\n"; $test++;
	}
	print "# IsBlank\n";
	if ($class =~ /^Z[lp]/ || $char eq " ") {
	    print "not " unless $char =~ /\p{IsBlank}/;
	    print "ok $test\n"; $test++;
	    print "not " if     $char =~ /\P{IsBlank}/;
	    print "ok $test\n"; $test++;
	} else {
	    print "not " if     $char =~ /\p{IsBlank}/;
	    print "ok $test\n"; $test++;
	    print "not " unless $char =~ /\P{IsBlank}/;
	    print "ok $test\n"; $test++;
	}
	print "# IsDigit\n";
	if ($class =~ /^Nd$/) {
	    print "not " unless $char =~ /\p{IsDigit}/;
	    print "ok $test\n"; $test++;
	    print "not " if     $char =~ /\P{IsDigit}/;
	    print "ok $test\n"; $test++;
	} else {
	    print "not " if     $char =~ /\p{IsDigit}/;
	    print "ok $test\n"; $test++;
	    print "not " unless $char =~ /\P{IsDigit}/;
	    print "ok $test\n"; $test++;
	}
	print "# IsGraph\n";
	if ($class =~ /^([LMNPS])|Co/) {
	    print "not " unless $char =~ /\p{IsGraph}/;
	    print "ok $test\n"; $test++;
	    print "not " if     $char =~ /\P{IsGraph}/;
	    print "ok $test\n"; $test++;
	} else {
	    print "not " if     $char =~ /\p{IsGraph}/;
	    print "ok $test\n"; $test++;
	    print "not " unless $char =~ /\P{IsGraph}/;
	    print "ok $test\n"; $test++;
	}
	print "# IsLower\n";
	if ($class =~ /^Ll$/) {
	    print "not " unless $char =~ /\p{IsLower}/;
	    print "ok $test\n"; $test++;
	    print "not " if     $char =~ /\P{IsLower}/;
	    print "ok $test\n"; $test++;
	} else {
	    print "not " if     $char =~ /\p{IsLower}/;
	    print "ok $test\n"; $test++;
	    print "not " unless $char =~ /\P{IsLower}/;
	    print "ok $test\n"; $test++;
	}
	print "# IsPrint\n";
	if ($class =~ /^([LMNPS])|Co|Zs/) {
	    print "not " unless $char =~ /\p{IsPrint}/;
	    print "ok $test\n"; $test++;
	    print "not " if     $char =~ /\P{IsPrint}/;
	    print "ok $test\n"; $test++;
	} else {
	    print "not " if     $char =~ /\p{IsPrint}/;
	    print "ok $test\n"; $test++;
	    print "not " unless $char =~ /\P{IsPrint}/;
	    print "ok $test\n"; $test++;
	}
	print "# IsPunct\n";
	if ($class =~ /^P/ || $char eq "_") {
	    print "not " unless $char =~ /\p{IsPunct}/;
	    print "ok $test\n"; $test++;
	    print "not " if     $char =~ /\P{IsPunct}/;
	    print "ok $test\n"; $test++;
	} else {
	    print "not " if     $char =~ /\p{IsPunct}/;
	    print "ok $test\n"; $test++;
	    print "not " unless $char =~ /\P{IsPunct}/;
	    print "ok $test\n"; $test++;
	}
	print "# IsSpace\n";
	if ($class =~ /^Z/ || ($code =~ /^(0009|000A|000B|000C|000D)$/)) {
	    print "not " unless $char =~ /\p{IsSpace}/;
	    print "ok $test\n"; $test++;
	    print "not " if     $char =~ /\P{IsSpace}/;
	    print "ok $test\n"; $test++;
	} else {
	    print "not " if     $char =~ /\p{IsSpace}/;
	    print "ok $test\n"; $test++;
	    print "not " unless $char =~ /\P{IsSpace}/;
	    print "ok $test\n"; $test++;
	}
	print "# IsUpper\n";
	if ($class =~ /^L[ut]/) {
	    print "not " unless $char =~ /\p{IsUpper}/;
	    print "ok $test\n"; $test++;
	    print "not " if     $char =~ /\P{IsUpper}/;
	    print "ok $test\n"; $test++;
	} else {
	    print "not " if     $char =~ /\p{IsUpper}/;
	    print "ok $test\n"; $test++;
	    print "not " unless $char =~ /\P{IsUpper}/;
	    print "ok $test\n"; $test++;
	}
	print "# IsWord\n";
	if ($class =~ /^[LMN]/ || $char eq "_") {
	    print "not " unless $char =~ /\p{IsWord}/;
	    print "ok $test\n"; $test++;
	    print "not " if     $char =~ /\P{IsWord}/;
	    print "ok $test\n"; $test++;
	} else {
	    print "not " if     $char =~ /\p{IsWord}/;
	    print "ok $test\n"; $test++;
	    print "not " unless $char =~ /\P{IsWord}/;
	    print "ok $test\n"; $test++;
	}
    }
}

{
    $_ = "abc\x{100}\x{200}\x{300}\x{380}\x{400}defg";

    if (/(.\x{300})./) {
	print "ok 576\n";

	print "not " unless $` eq "abc\x{100}" && length($`) == 4;
	print "ok 577\n";

	print "not " unless $& eq "\x{200}\x{300}\x{380}" && length($&) == 3;
	print "ok 578\n";

	print "not " unless $' eq "\x{400}defg" && length($') == 5;
	print "ok 579\n";

	print "not " unless $1 eq "\x{200}\x{300}" && length($1) == 2;
	print "ok 580\n";
    } else {
	for (576..580) { print "not ok $_\n" }
    }
}

{
    # bug id 20010306.008

    $a = "a\x{1234}";
    # The original bug report had 'no utf8' here but that was irrelevant.
    $a =~ m/\w/; # used to core dump

    print "ok 581\n";
}

{
    $test = 582;

    # bugid 20010410.006
    for my $rx (
		'/(.*?)\{(.*?)\}/csg',
		'/(.*?)\{(.*?)\}/cg',
		'/(.*?)\{(.*?)\}/sg',
		'/(.*?)\{(.*?)\}/g',
		'/(.+?)\{(.+?)\}/csg',
	       )
    {
	my($input, $i);

	$i = 0;
	$input = "a{b}c{d}";
        eval <<EOT;
	while (eval \$input =~ $rx) {
	    print "# \\\$1 = '\$1' \\\$2 = '\$2'\n";
	    ++\$i;
	}
EOT
	print "not " unless $i == 2;
	print "ok " . $test++ . "\n";
    }
}

{
    # from Robin Houston

    my $x = "\x{10FFFD}";
    $x =~ s/(.)/$1/g;
    print "not " unless ord($x) == 0x10FFFD && length($x) == 1;
    print "ok 587\n";
}

{
    my $x = "\x7f";

    print "not " if     $x =~ /[\x80-\xff]/;
    print "ok 588\n";

    print "not " if     $x =~ /[\x80-\x{100}]/;
    print "ok 589\n";

    print "not " if     $x =~ /[\x{100}]/;
    print "ok 590\n";

    print "not " if     $x =~ /\p{InLatin1Supplement}/;
    print "ok 591\n";

    print "not " unless $x =~ /\P{InLatin1Supplement}/;
    print "ok 592\n";

    print "not " if     $x =~ /\p{InLatinExtendedA}/;
    print "ok 593\n";

    print "not " unless $x =~ /\P{InLatinExtendedA}/;
    print "ok 594\n";
}

{
    my $x = "\x80";

    print "not " unless $x =~ /[\x80-\xff]/;
    print "ok 595\n";

    print "not " unless $x =~ /[\x80-\x{100}]/;
    print "ok 596\n";

    print "not " if     $x =~ /[\x{100}]/;
    print "ok 597\n";

    print "not " unless $x =~ /\p{InLatin1Supplement}/;
    print "ok 598\n";

    print "not " if    $x =~ /\P{InLatin1Supplement}/;
    print "ok 599\n";

    print "not " if     $x =~ /\p{InLatinExtendedA}/;
    print "ok 600\n";

    print "not " unless $x =~ /\P{InLatinExtendedA}/;
    print "ok 601\n";
}

{
    my $x = "\xff";

    print "not " unless $x =~ /[\x80-\xff]/;
    print "ok 602\n";

    print "not " unless $x =~ /[\x80-\x{100}]/;
    print "ok 603\n";

    print "not " if     $x =~ /[\x{100}]/;
    print "ok 604\n";

    print "not " unless $x =~ /\p{InLatin1Supplement}/;
    print "ok 605\n";

    print "not " if     $x =~ /\P{InLatin1Supplement}/;
    print "ok 606\n";

    print "not " if     $x =~ /\p{InLatinExtendedA}/;
    print "ok 607\n";

    print "not " unless $x =~ /\P{InLatinExtendedA}/;
    print "ok 608\n";
}

{
    my $x = "\x{100}";

    print "not " if     $x =~ /[\x80-\xff]/;
    print "ok 609\n";

    print "not " unless $x =~ /[\x80-\x{100}]/;
    print "ok 610\n";

    print "not " unless $x =~ /[\x{100}]/;
    print "ok 611\n";

    print "not " if     $x =~ /\p{InLatin1Supplement}/;
    print "ok 612\n";

    print "not " unless $x =~ /\P{InLatin1Supplement}/;
    print "ok 613\n";

    print "not " unless $x =~ /\p{InLatinExtendedA}/;
    print "ok 614\n";

    print "not " if     $x =~ /\P{InLatinExtendedA}/;
    print "ok 615\n";
}

{
    # from japhy
    my $w;
    use warnings;    
    local $SIG{__WARN__} = sub { $w .= shift };

    $w = "";
    eval 'qr/(?c)/';
    print "not " if $w !~ /^Useless \(\?c\)/;
    print "ok 616\n";

    $w = "";
    eval 'qr/(?-c)/';
    print "not " if $w !~ /^Useless \(\?-c\)/;
    print "ok 617\n";

    $w = "";
    eval 'qr/(?g)/';
    print "not " if $w !~ /^Useless \(\?g\)/;
    print "ok 618\n";

    $w = "";
    eval 'qr/(?-g)/';
    print "not " if $w !~ /^Useless \(\?-g\)/;
    print "ok 619\n";

    $w = "";
    eval 'qr/(?o)/';
    print "not " if $w !~ /^Useless \(\?o\)/;
    print "ok 620\n";

    $w = "";
    eval 'qr/(?-o)/';
    print "not " if $w !~ /^Useless \(\?-o\)/;
    print "ok 621\n";

    # now test multi-error regexes

    $w = "";
    eval 'qr/(?g-o)/';
    print "not " if $w !~ /^Useless \(\?g\).*\nUseless \(\?-o\)/;
    print "ok 622\n";

    $w = "";
    eval 'qr/(?g-c)/';
    print "not " if $w !~ /^Useless \(\?g\).*\nUseless \(\?-c\)/;
    print "ok 623\n";

    $w = "";
    eval 'qr/(?o-cg)/';  # (?c) means (?g) error won't be thrown
    print "not " if $w !~ /^Useless \(\?o\).*\nUseless \(\?-c\)/;
    print "ok 624\n";

    $w = "";
    eval 'qr/(?ogc)/';
    print "not " if $w !~ /^Useless \(\?o\).*\nUseless \(\?g\).*\nUseless \(\?c\)/;
    print "ok 625\n";
}

# More Unicode "class" tests

{
    use charnames ':full';

    print "not " unless "\N{LATIN CAPITAL LETTER A}" =~ /\p{InBasicLatin}/;
    print "ok 626\n";

    print "not " unless "\N{LATIN CAPITAL LETTER A WITH GRAVE}" =~ /\p{InLatin1Supplement}/;
    print "ok 627\n";

    print "not " unless "\N{LATIN CAPITAL LETTER A WITH MACRON}" =~ /\p{InLatinExtendedA}/;
    print "ok 628\n";

    print "not " unless "\N{LATIN SMALL LETTER B WITH STROKE}" =~ /\p{InLatinExtendedB}/;
    print "ok 629\n";

    print "not " unless "\N{KATAKANA LETTER SMALL A}" =~ /\p{InKatakana}/;
    print "ok 630\n";
}

$_ = "foo";

eval <<"EOT"; die if $@@;
  /f
   o\r
   o
   \$
  /x && print "ok 631\n";
EOT

eval <<"EOT"; die if $@@;
  /f
   o
   o
   \$\r
  /x && print "ok 632\n";
EOT

#test /o feature
sub test_o { $_[0] =~/$_[1]/o; return $1}
if(test_o('abc','(.)..') eq 'a') {
    print "ok 633\n";
} else {
    print "not ok 633\n";
}
if(test_o('abc','..(.)') eq 'a') {
    print "ok 634\n";
} else {
    print "not ok 634\n";
}

# 635..639: ID 20010619.003 (only the space character is
# supposed to be [:print:], not the whole isprint()).

print "not " if "\n"     =~ /[[:print:]]/;
print "ok 635\n";

print "not " if "\t"     =~ /[[:print:]]/;
print "ok 636\n";

# Amazingly vertical tabulator is the same in ASCII and EBCDIC.
print "not " if "\014"  =~ /[[:print:]]/;
print "ok 637\n";

print "not " if "\r"    =~ /[[:print:]]/;
print "ok 638\n";

print "not " unless " " =~ /[[:print:]]/;
print "ok 639\n";

##
## Test basic $^N usage outside of a regex
##
$x = "abcdef";
$T="ok 640\n";if ($x =~ /cde/ and not defined $^N)         {print $T} else {print "not $T"};
$T="ok 641\n";if ($x =~ /(cde)/          and $^N eq "cde") {print $T} else {print "not $T"};
$T="ok 642\n";if ($x =~ /(c)(d)(e)/      and $^N eq   "e") {print $T} else {print "not $T"};
$T="ok 643\n";if ($x =~ /(c(d)e)/        and $^N eq "cde") {print $T} else {print "not $T"};
$T="ok 644\n";if ($x =~ /(foo)|(c(d)e)/  and $^N eq "cde") {print $T} else {print "not $T"};
$T="ok 645\n";if ($x =~ /(c(d)e)|(foo)/  and $^N eq "cde") {print $T} else {print "not $T"};
$T="ok 646\n";if ($x =~ /(c(d)e)|(abc)/  and $^N eq "abc") {print $T} else {print "not $T"};
$T="ok 647\n";if ($x =~ /(c(d)e)|(abc)x/ and $^N eq "cde") {print $T} else {print "not $T"};
$T="ok 648\n";if ($x =~ /(c(d)e)(abc)?/  and $^N eq "cde") {print $T} else {print "not $T"};
$T="ok 649\n";if ($x =~ /(?:c(d)e)/      and $^N eq  "d" ) {print $T} else {print "not $T"};
$T="ok 650\n";if ($x =~ /(?:c(d)e)(?:f)/ and $^N eq  "d" ) {print $T} else {print "not $T"};
$T="ok 651\n";if ($x =~ /(?:([abc])|([def]))*/ and $^N eq  "f" ){print $T} else {print "not $T"};
$T="ok 652\n";if ($x =~ /(?:([ace])|([bdf]))*/ and $^N eq  "f" ){print $T} else {print "not $T"};
$T="ok 653\n";if ($x =~ /(([ace])|([bd]))*/    and $^N eq  "e" ){print $T} else {print "not $T"};
{
 $T="ok 654\n";if($x =~ /(([ace])|([bdf]))*/   and $^N eq  "f" ){print $T} else {print "not $T"};
}
## test to see if $^N is automatically localized -- it should now
## have the value set in test 653
$T="ok 655\n";if ($^N eq  "e" ){print $T} else {print "not $T"};

##
## Now test inside (?{...})
##
$T="ok 656\n";if ($x =~ /a([abc])(?{$y=$^N})c/      and $y eq "b" ){print $T} else {print "not $T"};
$T="ok 657\n";if ($x =~ /a([abc]+)(?{$y=$^N})d/     and $y eq "bc"){print $T} else {print "not $T"};
$T="ok 658\n";if ($x =~ /a([abcdefg]+)(?{$y=$^N})d/ and $y eq "bc"){print $T} else {print "not $T"};
$T="ok 659\n";if ($x =~ /(a([abcdefg]+)(?{$y=$^N})d)(?{$z=$^N})e/ and $y eq "bc" and $z eq "abcd")
              {print $T} else {print "not $T"};
$T="ok 660\n";if ($x =~ /(a([abcdefg]+)(?{$y=$^N})de)(?{$z=$^N})/ and $y eq "bc" and $z eq "abcde")
              {print $T} else {print "not $T"};

# Test the Unicode script classes

print "not " unless chr(0x100) =~ /\p{IsLatin}/; # outside Latin-1
print "ok 661\n";

print "not " unless chr(0x212b) =~ /\p{IsLatin}/; # Angstrom sign, very outside
print "ok 662\n";

print "not " unless chr(0x5d0) =~ /\p{IsHebrew}/; # inside InHebrew
print "ok 663\n";

print "not " unless chr(0xfb4f) =~ /\p{IsHebrew}/; # outside InHebrew
print "ok 664\n";

print "not " unless chr(0xb5) =~ /\p{IsGreek}/; # singleton (not in a range)
print "ok 665\n";

print "not " unless chr(0x37a) =~ /\p{IsGreek}/; # singleton
print "ok 666\n";

print "not " unless chr(0x386) =~ /\p{IsGreek}/; # singleton
print "ok 667\n";

print "not " unless chr(0x387) =~ /\P{IsGreek}/; # not there
print "ok 668\n";

print "not " unless chr(0x388) =~ /\p{IsGreek}/; # range
print "ok 669\n";

print "not " unless chr(0x38a) =~ /\p{IsGreek}/; # range
print "ok 670\n";

print "not " unless chr(0x38b) =~ /\P{IsGreek}/; # not there
print "ok 671\n";

print "not " unless chr(0x38c) =~ /\p{IsGreek}/; # singleton
print "ok 672\n";

if (ord("A") == 65) {
##
## Test [:cntrl:]...
##
## Should probably put in tests for all the POSIX stuff, but not sure how to
## guarantee a specific locale......
##
    $AllBytes = join('', map { chr($_) } 0..255);
    ($x = $AllBytes) =~ s/[[:cntrl:]]//g;
    if ($x ne join('', map { chr($_) } 0x20..0x7E, 0x80..0xFF)) {
	print "not ";
    }
    print "ok 673\n";

    ($x = $AllBytes) =~ s/[^[:cntrl:]]//g;
    if ($x ne join('', map { chr($_) } 0..0x1F, 0x7F)) { print "not " }
    print "ok 674\n";
} else {
    print "ok $_ # Skip: EBCDIC\n" for 673..674;
}

# With /s modifier UTF8 chars were interpreted as bytes
{
    my $a = "Hello \x{263A} World";
    
    my @@a = ($a =~ /./gs);
    
    print "not " unless $#a == 12;
    print "ok 675\n";
}

@@a = ("foo\nbar" =~ /./g);
print "ok 676\n" if @@a == 6 && "@@a" eq "f o o b a r";

@@a = ("foo\nbar" =~ /./gs);
print "ok 677\n" if @@a == 7 && "@@a" eq "f o o \n b a r";

@@a = ("foo\nbar" =~ /\C/g);
print "ok 678\n" if @@a == 7 && "@@a" eq "f o o \n b a r";

@@a = ("foo\nbar" =~ /\C/gs);
print "ok 679\n" if @@a == 7 && "@@a" eq "f o o \n b a r";

@@a = ("foo\n\x{100}bar" =~ /./g);
print "ok 680\n" if @@a == 7 && "@@a" eq "f o o \x{100} b a r";

@@a = ("foo\n\x{100}bar" =~ /./gs);
print "ok 681\n" if @@a == 8 && "@@a" eq "f o o \n \x{100} b a r";

($a, $b) = map { chr } ord('A') == 65 ? (0xc4, 0x80) : (0x8c, 0x41);

@@a = ("foo\n\x{100}bar" =~ /\C/g);
print "ok 682\n" if @@a == 9 && "@@a" eq "f o o \n $a $b b a r";

@@a = ("foo\n\x{100}bar" =~ /\C/gs);
print "ok 683\n" if @@a == 9 && "@@a" eq "f o o \n $a $b b a r";

{
    # [ID 20010814.004] pos() doesn't work when using =~m// in list context
    $_ = "ababacadaea";
    $a = join ":", /b./gc;
    $b = join ":", /a./gc;
    $c = pos;
    print "$a $b $c" eq 'ba:ba ad:ae 10' ? "ok 684\n" : "not ok 684\t# $a $b $c\n";
}

{
    # [ID 20010407.006] matching utf8 return values from functions does not work

    package ID_20010407_006;

    sub x {
	"a\x{1234}";
    }

    my $x = x;
    my $y;

    $x =~ /(..)/; $y = $1;
    print "not " unless length($y) == 2 && $y eq $x;
    print "ok 685\n";

    x  =~ /(..)/; $y = $1;
    print "not " unless length($y) == 2 && $y eq $x;
    print "ok 686\n";
}


my $test = 687;

# Force scalar context on the patern match
sub ok ($$) {
    my($ok, $name) = @@_;

    printf "%sok %d - %s\n", ($ok ? "" : "not "), $test, $name;

    printf "# Failed test at line %d\n", (caller)[2] unless $ok;

    $test++;
    return $ok;
}

{
    # Check that \x## works. 5.6.1 and 5.005_03 fail some of these.
    $x = "\x4e" . "E";
    ok ($x =~ /^\x4EE$/, "Check only 2 bytes of hex are matched.");

    $x = "\x4e" . "i";
    ok ($x =~ /^\x4Ei$/, "Check that invalid hex digit stops it (2)");

    $x = "\x4" . "j";
    ok ($x =~ /^\x4j$/,  "Check that invalid hex digit stops it (1)");

    $x = "\x0" . "k";
    ok ($x =~ /^\xk$/,   "Check that invalid hex digit stops it (0)");

    $x = "\x0" . "x";
    ok ($x =~ /^\xx$/, "\\xx isn't to be treated as \\0");

    $x = "\x0" . "xa";
    ok ($x =~ /^\xxa$/, "\\xxa isn't to be treated as \\xa");

    $x = "\x9" . "_b";
    ok ($x =~ /^\x9_b$/, "\\x9_b isn't to be treated as \\x9b");

    print "# and now again in [] ranges\n";

    $x = "\x4e" . "E";
    ok ($x =~ /^[\x4EE]{2}$/, "Check only 2 bytes of hex are matched.");

    $x = "\x4e" . "i";
    ok ($x =~ /^[\x4Ei]{2}$/, "Check that invalid hex digit stops it (2)");

    $x = "\x4" . "j";
    ok ($x =~ /^[\x4j]{2}$/,  "Check that invalid hex digit stops it (1)");

    $x = "\x0" . "k";
    ok ($x =~ /^[\xk]{2}$/,   "Check that invalid hex digit stops it (0)");

    $x = "\x0" . "x";
    ok ($x =~ /^[\xx]{2}$/, "\\xx isn't to be treated as \\0");

    $x = "\x0" . "xa";
    ok ($x =~ /^[\xxa]{3}$/, "\\xxa isn't to be treated as \\xa");

    $x = "\x9" . "_b";
    ok ($x =~ /^[\x9_b]{3}$/, "\\x9_b isn't to be treated as \\x9b");

}

{
    # Check that \x{##} works. 5.6.1 fails quite a few of these.

    $x = "\x9b";
    ok ($x =~ /^\x{9_b}$/, "\\x{9_b} is to be treated as \\x9b");

    $x = "\x9b" . "y";
    ok ($x =~ /^\x{9_b}y$/, "\\x{9_b} is to be treated as \\x9b (again)");

    $x = "\x9b" . "y";
    ok ($x =~ /^\x{9b_}y$/, "\\x{9b_} is to be treated as \\x9b");

    $x = "\x9b" . "y";
    ok ($x =~ /^\x{9_bq}y$/, "\\x{9_bc} is to be treated as \\x9b");

    $x = "\x0" . "y";
    ok ($x =~ /^\x{x9b}y$/, "\\x{x9b} is to be treated as \\x0");

    $x = "\x0" . "y";
    ok ($x =~ /^\x{0x9b}y$/, "\\x{0x9b} is to be treated as \\x0");

    $x = "\x9b" . "y";
    ok ($x =~ /^\x{09b}y$/, "\\x{09b} is to be treated as \\x9b");

    print "# and now again in [] ranges\n";

    $x = "\x9b";
    ok ($x =~ /^[\x{9_b}]$/, "\\x{9_b} is to be treated as \\x9b");

    $x = "\x9b" . "y";
    ok ($x =~ /^[\x{9_b}y]{2}$/, "\\x{9_b} is to be treated as \\x9b (again)");

    $x = "\x9b" . "y";
    ok ($x =~ /^[\x{9b_}y]{2}$/, "\\x{9b_} is to be treated as \\x9b");

    $x = "\x9b" . "y";
    ok ($x =~ /^[\x{9_bq}y]{2}$/, "\\x{9_bc} is to be treated as \\x9b");

    $x = "\x0" . "y";
    ok ($x =~ /^[\x{x9b}y]{2}$/, "\\x{x9b} is to be treated as \\x0");

    $x = "\x0" . "y";
    ok ($x =~ /^[\x{0x9b}y]{2}$/, "\\x{0x9b} is to be treated as \\x0");

    $x = "\x9b" . "y";
    ok ($x =~ /^[\x{09b}y]{2}$/, "\\x{09b} is to be treated as \\x9b");
}

{
    # high bit bug -- japhy
    my $x = "ab\200d";
    $x =~ /.*?\200/ or print "not ";
    print "ok 715\n";
}

print "# some Unicode properties\n";

{
    # Dashes, underbars, case.
    print "not " unless "\x80" =~ /\p{in-latin1_SUPPLEMENT}/;
    print "ok 716\n";

    # Complement, leading and trailing whitespace.
    print "not " unless "\x80" =~ /\P{  ^  In Latin 1 Supplement  }/;
    print "ok 717\n";

    # No ^In, dashes, case, dash, any intervening (word-break) whitespace.
    # (well, newlines don't work...)
    print "not " unless "\x80" =~ /\p{latin-1   supplement}/;
    print "ok 718\n";
}

{
    print "not " unless "a" =~ /\pL/;
    print "ok 719\n";

    print "not " unless "a" =~ /\p{IsLl}/;
    print "ok 720\n";

    print "not " if     "a" =~ /\p{IsLu}/;
    print "ok 721\n";

    print "not " unless "a" =~ /\p{Ll}/;
    print "ok 722\n";

    print "not " if     "a" =~ /\p{Lu}/;
    print "ok 723\n";

    print "not " unless "A" =~ /\pL/;
    print "ok 724\n";

    print "not " unless "A" =~ /\p{IsLu}/;
    print "ok 725\n";

    print "not " if     "A" =~ /\p{IsLl}/;
    print "ok 726\n";

    print "not " unless "A" =~ /\p{Lu}/;
    print "ok 727\n";

    print "not " if     "A" =~ /\p{Ll}/;
    print "ok 728\n";

    print "not " if     "a" =~ /\PL/;
    print "ok 729\n";

    print "not " if     "a" =~ /\P{IsLl}/;
    print "ok 730\n";

    print "not " unless "a" =~ /\P{IsLu}/;
    print "ok 731\n";

    print "not " if     "a" =~ /\P{Ll}/;
    print "ok 732\n";

    print "not " unless "a" =~ /\P{Lu}/;
    print "ok 733\n";

    print "not " if     "A" =~ /\PL/;
    print "ok 734\n";

    print "not " if     "A" =~ /\P{IsLu}/;
    print "ok 735\n";

    print "not " unless "A" =~ /\P{IsLl}/;
    print "ok 736\n";

    print "not " if     "A" =~ /\P{Lu}/;
    print "ok 737\n";

    print "not " unless "A" =~ /\P{Ll}/;
    print "ok 738\n";

}

{
    print "not " if     "a" =~ /\p{Common}/;
    print "ok 739\n";

    print "not " unless "1" =~ /\p{Common}/;
    print "ok 740\n";
}

{
    print "not " if     "a"       =~ /\p{Inherited}/;
    print "ok 741\n";

    print "not " unless "\x{300}" =~ /\p{Inherited}/;
    print "ok 742\n";
}

{
    print "not " unless "a" =~ /\p{L&}/;
    print "ok 743\n";

    print "not " if     "1" =~ /\p{L&}/;
    print "ok 744\n";
}

{
    print "not " unless "a" =~ /\p{Lowercase Letter}/;
    print "ok 745\n";

    print "not " if     "A" =~ /\p{lowercaseletter}/;
    print "ok 746\n";
}

{
    print "not " unless "\x{AC00}" =~ /\p{HangulSyllables}/;
    print "ok 747\n";
}

{
    # Script=, Block=, Category=

    print "not " unless "\x{0100}" =~ /\p{Script=Latin}/;
    print "ok 748\n";

    print "not " unless "\x{0100}" =~ /\p{Block=LatinExtendedA}/;
    print "ok 749\n";

    print "not " unless "\x{0100}" =~ /\p{Category=UppercaseLetter}/;
    print "ok 750\n";
}

{
    print "# the basic character classes and Unicode \n";

    # 0100;LATIN CAPITAL LETTER A WITH MACRON;Lu;0;L;0041 0304;;;;N;LATIN CAPITAL LETTER A MACRON;;;0101;
    print "not " unless "\x{0100}" =~ /\w/;
    print "ok 751\n";

    # 0660;ARABIC-INDIC DIGIT ZERO;Nd;0;AN;;0;0;0;N;;;;;
    print "not " unless "\x{0660}" =~ /\d/;
    print "ok 752\n";

    # 1680;OGHAM SPACE MARK;Zs;0;WS;;;;;N;;;;;
    print "not " unless "\x{1680}" =~ /\s/;
    print "ok 753\n";
}

{
    print "# folding matches and Unicode\n";

    print "not " unless "a\x{100}" =~ /A/i;
    print "ok 754\n";

    print "not " unless "A\x{100}" =~ /a/i;
    print "ok 755\n";

    print "not " unless "a\x{100}" =~ /a/i;
    print "ok 756\n";

    print "not " unless "A\x{100}" =~ /A/i;
    print "ok 757\n";

    print "not " unless "\x{101}a" =~ /\x{100}/i;
    print "ok 758\n";

    print "not " unless "\x{100}a" =~ /\x{100}/i;
    print "ok 759\n";

    print "not " unless "\x{101}a" =~ /\x{101}/i;
    print "ok 760\n";

    print "not " unless "\x{100}a" =~ /\x{101}/i;
    print "ok 761\n";

    print "not " unless "a\x{100}" =~ /A\x{100}/i;
    print "ok 762\n";

    print "not " unless "A\x{100}" =~ /a\x{100}/i;
    print "ok 763\n";

    print "not " unless "a\x{100}" =~ /a\x{100}/i;
    print "ok 764\n";

    print "not " unless "A\x{100}" =~ /A\x{100}/i;
    print "ok 765\n";

    print "not " unless "a\x{100}" =~ /[A]/i;
    print "ok 766\n";

    print "not " unless "A\x{100}" =~ /[a]/i;
    print "ok 767\n";

    print "not " unless "a\x{100}" =~ /[a]/i;
    print "ok 768\n";

    print "not " unless "A\x{100}" =~ /[A]/i;
    print "ok 769\n";

    print "not " unless "\x{101}a" =~ /[\x{100}]/i;
    print "ok 770\n";

    print "not " unless "\x{100}a" =~ /[\x{100}]/i;
    print "ok 771\n";

    print "not " unless "\x{101}a" =~ /[\x{101}]/i;
    print "ok 772\n";

    print "not " unless "\x{100}a" =~ /[\x{101}]/i;
    print "ok 773\n";

}

{
    use charnames ':full';

    print "# LATIN LETTER A WITH GRAVE\n";
    my $lower = "\N{LATIN SMALL LETTER A WITH GRAVE}";
    my $UPPER = "\N{LATIN CAPITAL LETTER A WITH GRAVE}";

    print $lower =~ m/$UPPER/i   ? "ok 774\n" : "not ok 774\n";
    print $UPPER =~ m/$lower/i   ? "ok 775\n" : "not ok 775\n";
    print $lower =~ m/[$UPPER]/i ? "ok 776\n" : "not ok 776\n";
    print $UPPER =~ m/[$lower]/i ? "ok 777\n" : "not ok 777\n";

    print "# GREEK LETTER ALPHA WITH VRACHY\n";

    $lower = "\N{GREEK CAPITAL LETTER ALPHA WITH VRACHY}";
    $UPPER = "\N{GREEK SMALL LETTER ALPHA WITH VRACHY}";

    print $lower =~ m/$UPPER/i   ? "ok 778\n" : "not ok 778\n";
    print $UPPER =~ m/$lower/i   ? "ok 779\n" : "not ok 779\n";
    print $lower =~ m/[$UPPER]/i ? "ok 780\n" : "not ok 780\n";
    print $UPPER =~ m/[$lower]/i ? "ok 781\n" : "not ok 781\n";

    print "# LATIN LETTER Y WITH DIAERESIS\n";

    $lower = "\N{LATIN CAPITAL LETTER Y WITH DIAERESIS}";
    $UPPER = "\N{LATIN SMALL LETTER Y WITH DIAERESIS}";
    print $lower =~ m/$UPPER/i   ? "ok 782\n" : "not ok 782\n";
    print $UPPER =~ m/$lower/i   ? "ok 783\n" : "not ok 783\n";
    print $lower =~ m/[$UPPER]/i ? "ok 784\n" : "not ok 784\n";
    print $UPPER =~ m/[$lower]/i ? "ok 785\n" : "not ok 785\n";
}

{
    use warnings;
    use charnames ':full';
    
    print "# GREEK CAPITAL LETTER SIGMA vs COMBINING GREEK PERISPOMENI\n";

    my $SIGMA = "\N{GREEK CAPITAL LETTER SIGMA}";
    my $char  = "\N{COMBINING GREEK PERISPOMENI}";

    # Before #13843 this was failing by matching falsely.
    print "_:$char:_" =~ m/_:$SIGMA:_/i ? "not ok 786\n" : "ok 786\n";
}

{
    print "# \\X\n";

    use charnames ':full';

    print "a!"              =~ /^(\X)!/ && $1 eq "a" ?
	"ok 787\n" : "not ok 787 # $1\n";
    print "\xDF!"           =~ /^(\X)!/ && $1 eq "\xDF" ?
	"ok 788\n" : "not ok 788 # $1\n";
    print "\x{100}!"        =~ /^(\X)!/ && $1 eq "\x{100}" ?
	"ok 789\n" : "not ok 789 # $1\n";
    print "\x{100}\x{300}!" =~ /^(\X)!/ && $1 eq "\x{100}\x{300}" ?
	"ok 790\n" : "not ok 790 # $1\n";
    print "\N{LATIN CAPITAL LETTER E}!" =~ /^(\X)!/ &&
	$1 eq "\N{LATIN CAPITAL LETTER E}" ?
	"ok 791\n" : "not ok 791 # $1\n";
    print "\N{LATIN CAPITAL LETTER E}\N{COMBINING GRAVE ACCENT}!" =~
	/^(\X)!/ &&
	$1 eq "\N{LATIN CAPITAL LETTER E}\N{COMBINING GRAVE ACCENT}" ?
	"ok 792\n" : "not ok 792 # $1\n";
}

{
    print "#\\C and \\X\n";

    print "!abc!" =~ /a\Cc/ ? "ok 793\n" : "not ok 793\n";
    print "!abc!" =~ /a\Xc/ ? "ok 794\n" : "not ok 794\n";
a1130 480

{
    print "# FINAL SIGMA\n";

    my $SIGMA = "\x{03A3}"; # CAPITAL
    my $Sigma = "\x{03C2}"; # SMALL FINAL
    my $sigma = "\x{03C3}"; # SMALL

    print $SIGMA =~ /$SIGMA/i ? "ok 795\n" : "not ok 795\n";
    print $SIGMA =~ /$Sigma/i ? "ok 796\n" : "not ok 796\n";
    print $SIGMA =~ /$sigma/i ? "ok 797\n" : "not ok 797\n";

    print $Sigma =~ /$SIGMA/i ? "ok 798\n" : "not ok 798\n";
    print $Sigma =~ /$Sigma/i ? "ok 799\n" : "not ok 799\n";
    print $Sigma =~ /$sigma/i ? "ok 800\n" : "not ok 800\n";

    print $sigma =~ /$SIGMA/i ? "ok 801\n" : "not ok 801\n";
    print $sigma =~ /$Sigma/i ? "ok 802\n" : "not ok 802\n";
    print $sigma =~ /$sigma/i ? "ok 803\n" : "not ok 803\n";
    
    print $SIGMA =~ /[$SIGMA]/i ? "ok 804\n" : "not ok 804\n";
    print $SIGMA =~ /[$Sigma]/i ? "ok 805\n" : "not ok 805\n";
    print $SIGMA =~ /[$sigma]/i ? "ok 806\n" : "not ok 806\n";

    print $Sigma =~ /[$SIGMA]/i ? "ok 807\n" : "not ok 807\n";
    print $Sigma =~ /[$Sigma]/i ? "ok 808\n" : "not ok 808\n";
    print $Sigma =~ /[$sigma]/i ? "ok 809\n" : "not ok 809\n";

    print $sigma =~ /[$SIGMA]/i ? "ok 810\n" : "not ok 810\n";
    print $sigma =~ /[$Sigma]/i ? "ok 811\n" : "not ok 811\n";
    print $sigma =~ /[$sigma]/i ? "ok 812\n" : "not ok 812\n";
}

{
    print "# parlez-vous?\n";

    use charnames ':full';

    print "fran\N{LATIN SMALL LETTER C}ais" =~
	  /fran.ais/ &&
	$& eq "francais" ?
	"ok 813\n" : "not ok 813\n";

    print "fran\N{LATIN SMALL LETTER C WITH CEDILLA}ais" =~
	  /fran.ais/ &&
	$& eq "fran\N{LATIN SMALL LETTER C WITH CEDILLA}ais" ?
	"ok 814\n" : "not ok 814\n";

    print "fran\N{LATIN SMALL LETTER C}ais" =~
	   /fran\Cais/ &&
        $& eq "francais" ?
	"ok 815\n" : "not ok 815\n";

    print "franc\N{COMBINING CEDILLA}ais" =~
	  /franc\C\Cais/ ? # COMBINING CEDILLA is two bytes when encoded
	"ok 816\n" : "not ok 816\n";

    print "fran\N{LATIN SMALL LETTER C}ais" =~
	  /fran\Xais/ &&
	$& eq "francais" ?
	"ok 817\n" : "not ok 817\n";

    print "fran\N{LATIN SMALL LETTER C WITH CEDILLA}ais" =~
	  /fran\Xais/  &&
        $& eq "fran\N{LATIN SMALL LETTER C WITH CEDILLA}ais" ?
	"ok 818\n" : "not ok 818\n";

    print "franc\N{COMBINING CEDILLA}ais" =~
	  /fran\Xais/ &&
         $& eq "franc\N{COMBINING CEDILLA}ais" ?
	 "ok 819\n" : "not ok 819\n";

    print "fran\N{LATIN SMALL LETTER C WITH CEDILLA}ais" =~
	  /fran\N{LATIN SMALL LETTER C WITH CEDILLA}ais/  &&
        $& eq "fran\N{LATIN SMALL LETTER C WITH CEDILLA}ais" ?
	"ok 820\n" : "not ok 820\n";

    print "franc\N{COMBINING CEDILLA}ais" =~
	  /franc\N{COMBINING CEDILLA}ais/  &&
        $& eq "franc\N{COMBINING CEDILLA}ais" ?
	"ok 821\n" : "not ok 821\n";

    print "fran\N{LATIN SMALL LETTER C}ais" =~
	  /fran(?:c\N{COMBINING CEDILLA}?|\N{LATIN SMALL LETTER C WITH CEDILLA})ais/ &&
	$& eq "francais" ?
	"ok 822\n" : "not ok 822\n";

    print "fran\N{LATIN SMALL LETTER C}ais" =~
	  /fran(?:c\N{COMBINING CEDILLA}?|\N{LATIN SMALL LETTER C WITH CEDILLA})ais/ &&
	$& eq "francais" ?
	"ok 823\n" : "not ok 823\n";

    print "fran\N{LATIN SMALL LETTER C WITH CEDILLA}ais" =~
	  /fran(?:c\N{COMBINING CEDILLA}?|\N{LATIN SMALL LETTER C WITH CEDILLA})ais/ &&
	$& eq "fran\N{LATIN SMALL LETTER C WITH CEDILLA}ais" ?
	"ok 824\n" : "not ok 824\n";

    print "franc\N{COMBINING CEDILLA}ais" =~
	  /fran(?:c\N{COMBINING CEDILLA}?|\N{LATIN SMALL LETTER C WITH CEDILLA})ais/ &&
	$& eq "franc\N{COMBINING CEDILLA}ais" ?
	"ok 825\n" : "not ok 825\n";
}

{
    print "# Does lingering (and useless) UTF8 flag mess up /i matching?\n";

    {
	my $regex  = "ABcde";
	my $string = "abcDE\x{100}";
	chop($string);
	if ($string =~ m/$regex/i) {
	    print "ok 826\n";
	} else {
	    print "not ok 826\n";
	}
    }

    {
	my $regex  = "ABcde\x{100}";
	my $string = "abcDE";
	chop($regex);
	if ($string =~ m/$regex/i) {
	    print "ok 827\n";
	} else {
	    print "not ok 827\n";
	}
    }

    {
	my $regex  = "ABcde\x{100}";
	my $string = "abcDE\x{100}";
	chop($regex);
	chop($string);
	if ($string =~ m/$regex/i) {
	    print "ok 828\n";
	} else {
	    print "not ok 828\n";
	}
    }
}

{
    print "# more SIGMAs\n";

    my $SIGMA = "\x{03A3}"; # CAPITAL
    my $Sigma = "\x{03C2}"; # SMALL FINAL
    my $sigma = "\x{03C3}"; # SMALL

    my $S3 = "$SIGMA$Sigma$sigma";

    print ":$S3:" =~ /:(($SIGMA)+):/i   && $1 eq $S3 && $2 eq $sigma ?
	"ok 829\n" : "not ok 829\n";
    print ":$S3:" =~ /:(($Sigma)+):/i   && $1 eq $S3 && $2 eq $sigma ?
	"ok 830\n" : "not ok 830\n";
    print ":$S3:" =~ /:(($sigma)+):/i   && $1 eq $S3 && $2 eq $sigma ?
	"ok 831\n" : "not ok 831\n";

    print ":$S3:" =~ /:(([$SIGMA])+):/i && $1 eq $S3 && $2 eq $sigma ?
	"ok 832\n" : "not ok 832\n";
    print ":$S3:" =~ /:(([$Sigma])+):/i && $1 eq $S3 && $2 eq $sigma ?
	"ok 833\n" : "not ok 833\n";
    print ":$S3:" =~ /:(([$sigma])+):/i && $1 eq $S3 && $2 eq $sigma ?
	"ok 834\n" : "not ok 834\n";
}

{
    print "# LATIN SMALL LETTER SHARP S\n";

    use charnames ':full';

    print "\N{LATIN SMALL LETTER SHARP S}" =~
	/\N{LATIN SMALL LETTER SHARP S}/    ? "ok 835\n" : "not ok 835\n";

    print "\N{LATIN SMALL LETTER SHARP S}" =~
	/\N{LATIN SMALL LETTER SHARP S}/i   ? "ok 836\n" : "not ok 836\n";

    print "\N{LATIN SMALL LETTER SHARP S}" =~
	/[\N{LATIN SMALL LETTER SHARP S}]/  ? "ok 837\n" : "not ok 837\n";

    print "\N{LATIN SMALL LETTER SHARP S}" =~
	/[\N{LATIN SMALL LETTER SHARP S}]/i ? "ok 838\n" : "not ok 838\n";

    print "ss" =~
	/\N{LATIN SMALL LETTER SHARP S}/i   ? "ok 839\n" : "not ok 839\n";

    print "SS" =~
	/\N{LATIN SMALL LETTER SHARP S}/i   ? "ok 840\n" : "not ok 840\n";

    print "ss" =~
	/[\N{LATIN SMALL LETTER SHARP S}]/i ? "ok 841\n" : "not ok 841\n";

    print "SS" =~
	/[\N{LATIN SMALL LETTER SHARP S}]/i ? "ok 842\n" : "not ok 842\n";

    print "\N{LATIN SMALL LETTER SHARP S}" =~ /ss/i ?
	"ok 843\n" : "not ok 843\n";

    print "\N{LATIN SMALL LETTER SHARP S}" =~ /SS/i ?
	"ok 844\n" : "not ok 844\n";
}

{
    print "# more whitespace: U+0085, U+2028, U+2029\n";

    # U+0085 needs to be forced to be Unicode, the \x{100} does that.
    print "<\x{100}\x{0085}>" =~ /<\x{100}\s>/ ? "ok 845\n" : "not ok 845\n";
    print "<\x{2028}>" =~ /<\s>/ ? "ok 846\n" : "not ok 846\n";
    print "<\x{2029}>" =~ /<\s>/ ? "ok 847\n" : "not ok 847\n";
}

{
    print "# . with /s should work on characters, as opposed to bytes\n";

    my $s = "\x{e4}\x{100}";

    # This is not expected to match: the point is that
    # neither should we get "Malformed UTF-8" warnings.
    print $s =~ /\G(.+?)\n/gcs ?
	"not ok 848\n" : "ok 848\n";

    my @@c;

    while ($s =~ /\G(.)/gs) {
	push @@c, $1;
    }

    print join("", @@c) eq $s ? "ok 849\n" : "not ok 849\n";

    my $t1 = "Q003\n\n\x{e4}\x{f6}\n\nQ004\n\n\x{e7}"; # test only chars < 256
    my $r1 = "";
    while ($t1 =~ / \G ( .+? ) \n\s+ ( .+? ) ( $ | \n\s+ ) /xgcs) {
	$r1 .= $1 . $2;
    }

    my $t2 = $t1 . "\x{100}"; # repeat with a larger char
    my $r2 = "";
    while ($t2 =~ / \G ( .+? ) \n\s+ ( .+? ) ( $ | \n\s+ ) /xgcs) {
	$r2 .= $1 . $2;
    }
    $r2 =~ s/\x{100}//;
    print $r1 eq $r2 ? "ok 850\n" : "not ok 850\n";
}

{
    print "# Unicode lookbehind\n";

    print "A\x{100}B"        =~ /(?<=A.)B/  ? "ok 851\n" : "not ok 851\n";
    print "A\x{200}\x{300}B" =~ /(?<=A..)B/ ? "ok 852\n" : "not ok 852\n";
    print "\x{400}AB"        =~ /(?<=\x{400}.)B/ ? "ok 853\n" : "not ok 853\n";
    print "\x{500\x{600}}B"  =~ /(?<=\x{500}.)B/ ? "ok 854\n" : "not ok 854\n";
}

{
    print "# UTF-8 hash keys and /\$/\n";
    # http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/2002-01/msg01327.html

    my $u = "a\x{100}";
    my $v = substr($u,0,1);
    my $w = substr($u,1,1);
    my %u = ( $u => $u, $v => $v, $w => $w );
    my $i = 855; 
    for (keys %u) {
	my $m1 = /^\w*$/ ? 1 : 0;
	my $m2 = $u{$_}=~/^\w*$/ ? 1 : 0;
	print $m1 == $m2 ? "ok $i\n" : "not ok $i # $m1 $m2\n";
	$i++;
    }
}

{
    print "# [ID 20020124.005]\n";
    # Fixed by #14795.
    my $i = 858;
    for my $char ("a", "\x{df}", "\x{100}"){
	$x = "$char b $char";
	$x =~ s{($char)}{
	    "c" =~ /c/;
	    "x";
	}ge;
	print substr($x,0,1) eq substr($x,-1,1) ?
	    "ok $i\n" : "not ok $i # debug: $x\n";
 	$i++;
   }
}

{
    print "# SEGV in s/// and UTF-8\n";
    $s = "s#\x{100}" x 4;
    $s =~ s/[^\w]/ /g;
    print $s eq "s \x{100}" x 4 ? "ok 861\n" : "not ok 861\n";
}

{
    print "# UTF-8 bug (maybe alreayd known?)\n";
    my $u;

    $u = "foo";
    $u =~ s/./\x{100}/g;
    print $u eq "\x{100}\x{100}\x{100}" ? "ok 862\n" : "not ok 862\n";

    $u = "foobar";
    $u =~ s/[ao]/\x{100}/g;
    print $u eq "f\x{100}\x{100}b\x{100}r" ? "ok 863\n" : "not ok 863\n";

    $u =~ s/\x{100}/e/g;
    print $u eq "feeber" ? "ok 864\n" : "not ok 864\n";
}

{
    print "# UTF-8 bug with s///\n";
    # check utf8/non-utf8 mixtures
    # try to force all float/anchored check combinations
    my $c = "\x{100}";
    my $test = 865;
    my $subst;
    for my $re (
	"xx.*$c", "x.*$c$c", "$c.*xx", "$c$c.*x", "xx.*(?=$c)", "(?=$c).*xx",
    ) {
	print "xxx" =~ /$re/ ? "not ok $test\n" : "ok $test\n";
	++$test;
	print +($subst = "xxx") =~ s/$re// ? "not ok $test\n" : "ok $test\n";
	++$test;
    }
    for my $re ("xx.*$c*", "$c*.*xx") {
	print "xxx" =~ /$re/ ? "ok $test\n" : "not ok $test\n";
	++$test;
	($subst = "xxx") =~ s/$re//;
	print $subst eq '' ? "ok $test\n" : "not ok $test\t# $subst\n";
	++$test;
    }
    for my $re ("xxy*", "y*xx") {
	print "xx$c" =~ /$re/ ? "ok $test\n" : "not ok $test\n";
	++$test;
	($subst = "xx$c") =~ s/$re//;
	print $subst eq $c ? "ok $test\n" : "not ok $test\n";
	++$test;
	print "xy$c" =~ /$re/ ? "not ok $test\n" : "ok $test\n";
	++$test;
	print +($subst = "xy$c") =~ /$re/ ? "not ok $test\n" : "ok $test\n";
	++$test;
    }
    for my $re ("xy$c*z", "x$c*yz") {
	print "xyz" =~ /$re/ ? "ok $test\n" : "not ok $test\n";
	++$test;
	($subst = "xyz") =~ s/$re//;
	print $subst eq '' ? "ok $test\n" : "not ok $test\n";
	++$test;
    }
}

{
    print "# qr/.../x\n";
    my $test = 893;

    my $R = qr/ A B C # D E/x;

    print eval {"ABCDE" =~ $R} ? "ok $test\n" : "not ok $test\n";
    $test++;

    print eval {"ABCDE" =~ m/$R/} ? "ok $test\n" : "not ok $test\n";
    $test++;

    print eval {"ABCDE" =~ m/($R)/} ? "ok $test\n" : "not ok $test\n";
    $test++;
}

{
    print "# illegal Unicode properties\n";
    my $test = 896;

    print eval { "a" =~ /\pq / }      ? "not ok $test\n" : "ok $test\n";
    $test++;

    print eval { "a" =~ /\p{qrst} / } ? "not ok $test\n" : "ok $test\n";
    $test++;
}

{
    print "# [ID 20020412.005] wrong pmop flags checked when empty pattern\n";
    # requires reuse of last successful pattern
    my $test = 898;
    $test =~ /\d/;
    for (0 .. 1) {
	my $match = ?? + 0;
	if ($match != $_) {
	    print "ok $test\n";
	} else {
	    printf "not ok %s\t# 'match once' %s on %s iteration\n", $test,
		    $match ? 'succeeded' : 'failed', $_ ? 'second' : 'first';
	}
	++$test;
    }
    $test =~ /(\d)/;
    my $result = join '', $test =~ //g;
    if ($result eq $test) {
	print "ok $test\n";
    } else {
	printf "not ok %s\t# expected '%s', got '%s'\n", $test, $test, $result;
    }
    ++$test;
}

print "# user-defined character properties\n";

sub InKana1 {
    return <<'END';
3040	309F
30A0	30FF
END
}

sub InKana2 {
    return <<'END';
+utf8::InHiragana
+utf8::InKatakana
END
}

sub InKana3 {
    return <<'END';
+utf8::InHiragana
+utf8::InKatakana
-utf8::IsCn
END
}

sub InNotKana {
    return <<'END';
!utf8::InHiragana
-utf8::InKatakana
+utf8::IsCn
END
}

$test = 901;

print "\x{3040}" =~ /\p{InKana1}/ ? "ok $test\n" : "not ok $test\n"; $test++;
print "\x{303F}" =~ /\P{InKana1}/ ? "ok $test\n" : "not ok $test\n"; $test++;

print "\x{3040}" =~ /\p{InKana2}/ ? "ok $test\n" : "not ok $test\n"; $test++;
print "\x{303F}" =~ /\P{InKana2}/ ? "ok $test\n" : "not ok $test\n"; $test++;

print "\x{3041}" =~ /\p{InKana3}/ ? "ok $test\n" : "not ok $test\n"; $test++;
print "\x{3040}" =~ /\P{InKana3}/ ? "ok $test\n" : "not ok $test\n"; $test++;

print "\x{3040}" =~ /\p{InNotKana}/ ? "ok $test\n" : "not ok $test\n"; $test++;
print "\x{3041}" =~ /\P{InNotKana}/ ? "ok $test\n" : "not ok $test\n"; $test++;

sub InConsonant { # Not EBCDIC-aware.
    return <<EOF;
0061	007f
-0061
-0065
-0069
-006f
-0075
EOF
}

print "d" =~ /\p{InConsonant}/ ? "ok $test\n" : "not ok $test\n"; $test++;
print "e" =~ /\P{InConsonant}/ ? "ok $test\n" : "not ok $test\n"; $test++;

{
    print "# [ID 20020630.002] utf8 regex only matches 32k\n";
    $test = 911;
    for ([ 'byte', "\x{ff}" ], [ 'utf8', "\x{1ff}" ]) {
	my($type, $char) = @@$_;
	for my $len (32000, 32768, 33000) {
	    my $s = $char . "f" x $len;
	    my $r = $s =~ /$char([f]*)/gc;
	    print $r ? "ok $test\n" : "not ok $test\t# <$type x $len> fail\n";
	    ++$test;
	    print +(!$r or pos($s) == $len + 1) ? "ok $test\n"
		: "not ok $test\t# <$type x $len> pos @@{[ pos($s) ]}\n";
	    ++$test;
	}
    }
}

$test = 923;
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@d9 1
a9 1
print "1..1055\n";
d1370 1
a1370 1
SKIP: {
d1373 1
a1373 1
    use charnames ":full";
a2904 353

$a = bless qr/foo/, 'Foo';
print(('goodfood' =~ $a ? '' : 'not '),
	"ok $test\t# reblessed qr// matches\n");
++$test;

print(($a eq '(?-xism:foo)' ? '' : 'not '),
	"ok $test\t# reblessed qr// stringizes\n");
++$test;

$x = "\x{3fe}";
$z=$y = "\317\276"; # $y is byte representation of $x

$a = qr/$x/;
print(($x =~ $a ? '' : 'not '), "ok $test - utf8 interpolation in qr//\n");
++$test;

print(("a$a" =~ $x ? '' : 'not '),
      "ok $test - stringifed qr// preserves utf8\n");
++$test;

print(("a$x" =~ /^a$a\z/ ? '' : 'not '),
      "ok $test - interpolated qr// preserves utf8\n");
++$test;

print(("a$x" =~ /^a(??{$a})\z/ ? '' : 'not '),
      "ok $test - postponed interpolation of qr// preserves utf8\n");
++$test;

print((length(qr/##/x) == 12 ? '' : 'not '),
      "ok $test - ## in qr// doesn't corrupt memory [perl #17776]\n");
++$test;

{ use re 'eval';

print(("$x$x" =~ /^$x(??{$x})\z/ ? '' : 'not '),
      "ok $test - postponed utf8 string in utf8 re matches utf8\n");
++$test;

print(("$y$x" =~ /^$y(??{$x})\z/ ? '' : 'not '),
      "ok $test - postponed utf8 string in non-utf8 re matches utf8\n");
++$test;

print(("$y$x" !~ /^$y(??{$y})\z/ ? '' : 'not '),
      "ok $test - postponed non-utf8 string in non-utf8 re doesn't match utf8\n");
++$test;

print(("$x$x" !~ /^$x(??{$y})\z/ ? '' : 'not '),
      "ok $test - postponed non-utf8 string in utf8 re doesn't match utf8\n");
++$test;

print(("$y$y" =~ /^$y(??{$y})\z/ ? '' : 'not '),
      "ok $test - postponed non-utf8 string in non-utf8 re matches non-utf8\n");
++$test;

print(("$x$y" =~ /^$x(??{$y})\z/ ? '' : 'not '),
      "ok $test - postponed non-utf8 string in utf8 re matches non-utf8\n");
++$test;
$y = $z; # reset $y after upgrade

print(("$x$y" !~ /^$x(??{$x})\z/ ? '' : 'not '),
      "ok $test - postponed utf8 string in utf8 re doesn't match non-utf8\n");
++$test;
$y = $z; # reset $y after upgrade

print(("$y$y" !~ /^$y(??{$x})\z/ ? '' : 'not '),
      "ok $test - postponed utf8 string in non-utf8 re doesn't match non-utf8\n");
++$test;

} # no re 'eval'

print "# more user-defined character properties\n";

sub IsSyriac1 {
    return <<'END';
0712	072C
0730	074A
END
}

print "\x{0712}" =~ /\p{IsSyriac1}/ ? "ok $test\n" : "not ok $test\n"; $test++;
print "\x{072F}" =~ /\P{IsSyriac1}/ ? "ok $test\n" : "not ok $test\n"; $test++;

sub Syriac1 {
    return <<'END';
0712	072C
0730	074A
END
}

print "\x{0712}" =~ /\p{Syriac1}/ ? "ok $test\n" : "not ok $test\n"; $test++;
print "\x{072F}" =~ /\P{Syriac1}/ ? "ok $test\n" : "not ok $test\n"; $test++;

{
    print "# Change #18179\n";
    # previously failed with "panic: end_shift
    my $s = "\x{100}" x 5;
    my $ok = $s =~ /(\x{100}{4})/;
    my($ord, $len) = (ord $1, length $1);
    print +($ok && $ord == 0x100 && $len == 4)
	    ? "ok $test\n" : "not ok $test\t# $ok/$ord/$len\n";
    ++$test;
}

{
    print "# [perl #15763]\n";

    $a = "x\x{100}";
    chop $a; # but leaves the UTF-8 flag
    $a .= "y"; # 1 byte before "y"

    ok($a =~ /^\C/,      'match one \C on 1-byte UTF-8');
    ok($a =~ /^\C{1}/,   'match \C{1}');

    ok($a =~ /^\Cy/,      'match \Cy');
    ok($a =~ /^\C{1}y/,   'match \C{1}y');

    $a = "\x{100}y"; # 2 bytes before "y"

    ok($a =~ /^\C/,       'match one \C on 2-byte UTF-8');
    ok($a =~ /^\C{1}/,    'match \C{1}');
    ok($a =~ /^\C\C/,     'match two \C');
    ok($a =~ /^\C{2}/,    'match \C{2}');

    ok($a =~ /^\C\C\C/,    'match three \C on 2-byte UTF-8 and a byte');
    ok($a =~ /^\C{3}/,     'match \C{3}');

    ok($a =~ /^\C\Cy/,     'match two \C');
    ok($a =~ /^\C{2}y/,    'match \C{2}');

    ok($a !~ /^\C\C\Cy/,    q{don't match three \Cy});
    ok($a !~ /^\C{2}\Cy/,   q{don't match \C{3}y});

    $a = "\x{1000}y"; # 3 bytes before "y"

    ok($a =~ /^\C/,         'match one \C on three-byte UTF-8');
    ok($a =~ /^\C{1}/,      'match \C{1}');
    ok($a =~ /^\C\C/,       'match two \C');
    ok($a =~ /^\C{2}/,      'match \C{2}');
    ok($a =~ /^\C\C\C/,     'match three \C');
    ok($a =~ /^\C{3}/,      'match \C{3}');

    ok($a =~ /^\C\C\C\C/,   'match four \C on three-byte UTF-8 and a byte');
    ok($a =~ /^\C{4}/,      'match \C{4}');

    ok($a =~ /^\C\C\Cy/,    'match three \Cy');
    ok($a =~ /^\C{3}y/,     'match \C{3}y');

    ok($a !~ /^\C\C\C\C\y/, q{don't match four \Cy});
    ok($a !~ /^\C{4}y/,     q{don't match \C{4}y});
}

$_ = 'aaaaaaaaaa';
utf8::upgrade($_); chop $_; $\="\n";
ok(/[^\s]+/, "m/[^\s]/ utf8");
ok(/[^\d]+/, "m/[^\d]/ utf8");
ok(($a = $_, $_ =~ s/[^\s]+/./g), "s/[^\s]/ utf8");
ok(($a = $_, $a =~ s/[^\d]+/./g), "s/[^\s]/ utf8");

ok("\x{100}" =~ /\x{100}/, "[perl #15397]");
ok("\x{100}" =~ /(\x{100})/, "[perl #15397]");
ok("\x{100}" =~ /(\x{100}){1}/, "[perl #15397]");
ok("\x{100}\x{100}" =~ /(\x{100}){2}/, "[perl #15397]");
ok("\x{100}\x{100}" =~ /(\x{100})(\x{100})/, "[perl #15397]");

$x = "CD";
$x =~ /(AB)*?CD/;
ok(!defined $1, "[perl #7471]");

$x = "CD";
$x =~ /(AB)*CD/;
ok(!defined $1, "[perl #7471]");

$pattern = "^(b+?|a){1,2}c";
ok("bac"    =~ /$pattern/ && $1 eq 'a', "[perl #3547]");
ok("bbac"   =~ /$pattern/ && $1 eq 'a', "[perl #3547]");
ok("bbbac"  =~ /$pattern/ && $1 eq 'a', "[perl #3547]");
ok("bbbbac" =~ /$pattern/ && $1 eq 'a', "[perl #3547]");

{
    # [perl #18232]
    "\x{100}" =~ /(.)/;
    ok( $1 eq "\x{100}", '$1 is utf-8 [perl #18232]' );
    { 'a' =~ /./; }
    ok( $1 eq "\x{100}", '$1 is still utf-8' );
    ok( $1 ne "\xC4\x80", '$1 is not non-utf-8' );
}

{
    use utf8;
    my $attr = 'Name-1' ;

    my $NormalChar          = qr/[\p{IsDigit}\p{IsLower}\p{IsUpper}]/;
    my $NormalWord          = qr/${NormalChar}+?/;
    my $PredNameHyphen      = qr/^${NormalWord}(\-${NormalWord})*?$/;

    $attr =~ /^$/;
    ok( $attr =~ $PredNameHyphen, "[perl #19767] original test" );
}

{
    use utf8;
    "a" =~ m/[b]/;
    ok ( "0" =~ /\p{N}+\z/, "[perl #19767] variant test" );
}

{

    $p = 1;
    foreach (1,2,3,4) {
	    $p++ if /(??{ $p })/
    }
    ok ($p == 5, "[perl #20683] (??{ }) returns stale values");
    { package P; $a=1; sub TIESCALAR { bless[] } sub FETCH { $a++ } }
    tie $p, P;
    foreach (1,2,3,4) {
	    /(??{ $p })/
    }
    ok ( $p == 5, "(??{ }) returns stale values");
}

{
  # Subject: Odd regexp behavior
  # From: Markus Kuhn <Markus.Kuhn@@cl.cam.ac.uk>
  # Date: Wed, 26 Feb 2003 16:53:12 +0000
  # Message-Id: <E18o4nw-0008Ly-00@@wisbech.cl.cam.ac.uk>
  # To: perl-unicode@@perl.org
    
  $x = "\x{2019}\nk"; $x =~ s/(\S)\n(\S)/$1 $2/sg;
  ok($x eq "\x{2019} k", "Markus Kuhn 2003-02-26");

  $x = "b\nk"; $x =~ s/(\S)\n(\S)/$1 $2/sg;
  ok($x eq "b k", "Markus Kuhn 2003-02-26");

  ok("\x{2019}" =~ /\S/, "Markus Kuhn 2003-02-26");
}

{
    my $i;
    ok('-1-3-5-' eq join('', split /((??{$i++}))/, '-1-3-5-'),
	"[perl #21411] (??{ .. }) corrupts split's stack");
    split /(?{'WOW'})/, 'abc';
    ok('a|b|c' eq join ('|', @@_),
       "[perl #21411] (?{ .. }) version of the above");
}

{
    split /(?{ split "" })/, "abc";
    ok(1,'cache_re & "(?{": it dumps core in 5.6.1 & 5.8.0');
}

{
    ok("\x{100}\n" =~ /\x{100}\n$/, "UTF8 length cache and fbm_compile");  
}

{
    package Str;
    use overload q/""/ => sub { ${$_[0]}; };
    sub new { my ($c, $v) = @@_; bless \$v, $c; }

    package main;
    $_ = Str->new("a\x{100}/\x{100}b");
    ok(join(":", /\b(.)\x{100}/g) eq "a:/", "re_intuit_start and PL_bostr");
}

{
    $_ = "code:   'x' { '...' }\n"; study;
    my @@x; push @@x, $& while m/'[^\']*'/gx;
    ok(join(":", @@x) eq "'x':'...'",
       "[perl #17757] Parse::RecDescent triggers infinite loop");
}

{
    my $re = qq/^([^X]*)X/;
    utf8::upgrade($re);
    ok("\x{100}X" =~ /$re/, "S_cl_and ANYOF_UNICODE & ANYOF_INVERTED");
}

ok(1, 'skip - $* not deprecated in Perl 5.8') for 1..6;

# bug #19049
$_="abcdef\n";
@@x = m/./g;
ok("abcde" eq "$`", '# TODO #19049 - global match not setting $`');

ok("123\x{100}" =~ /^.*1.*23\x{100}$/, 'uft8 + multiple floating substr');

# LATIN SMALL/CAPITAL LETTER A WITH MACRON
ok("  \x{101}" =~ qr/\x{100}/i,
   "<20030808193656.5109.1@@llama.ni-s.u-net.com>");

# LATIN SMALL/CAPITAL LETTER A WITH RING BELOW
ok("  \x{1E01}" =~ qr/\x{1E00}/i,
   "<20030808193656.5109.1@@llama.ni-s.u-net.com>");

# DESERET SMALL/CAPITAL LETTER LONG I
ok("  \x{10428}" =~ qr/\x{10400}/i,
   "<20030808193656.5109.1@@llama.ni-s.u-net.com>");

# LATIN SMALL/CAPITAL LETTER A WITH RING BELOW + 'X'
ok("  \x{1E01}x" =~ qr/\x{1E00}X/i,
   "<20030808193656.5109.1@@llama.ni-s.u-net.com>");

{
    # [perl #23769] Unicode regex broken on simple example
    # regrepeat() didn't handle UTF-8 EXACT case right.

    my $s = "\x{a0}\x{a0}\x{a0}\x{100}"; chop $s;

    ok($s =~ /\x{a0}/,       "[perl #23769]");
    ok($s =~ /\x{a0}+/,      "[perl #23769]");
    ok($s =~ /\x{a0}\x{a0}/, "[perl #23769]");

    ok("aaa\x{100}" =~ /(a+)/, "[perl #23769] easy invariant");
    ok($1 eq "aaa", "[perl #23769]");

    ok("\xa0\xa0\xa0\x{100}" =~ /(\xa0+)/, "[perl #23769] regrepeat invariant");
    ok($1 eq "\xa0\xa0\xa0", "[perl #23769]");

    ok("ababab\x{100}  " =~ /((?:ab)+)/, "[perl #23769] hard invariant");
    ok($1 eq "ababab", "[perl #23769]");

    ok("\xa0\xa1\xa0\xa1\xa0\xa1\x{100}" =~ /((?:\xa0\xa1)+)/, "[perl #23769] hard variant");
    ok($1 eq "\xa0\xa1\xa0\xa1\xa0\xa1", "[perl #23769]");

    ok("aaa\x{100}     " =~ /(a+?)/, "[perl #23769] easy invariant");
    ok($1 eq "a", "[perl #23769]");

    ok("\xa0\xa0\xa0\x{100}    " =~ /(\xa0+?)/, "[perl #23769] regrepeat variant");
    ok($1 eq "\xa0", "[perl #23769]");

    ok("ababab\x{100}  " =~ /((?:ab)+?)/, "[perl #23769] hard invariant");
    ok($1 eq "ab", "[perl #23769]");

    ok("\xa0\xa1\xa0\xa1\xa0\xa1\x{100}" =~ /((?:\xa0\xa1)+?)/, "[perl #23769] hard variant");
    ok($1 eq "\xa0\xa1", "[perl #23769]");

    ok("\xc4\xc4\xc4" !~ /(\x{100}+)/, "[perl #23769] don't match first byte of utf8 representation");
    ok("\xc4\xc4\xc4" !~ /(\x{100}+?)/, "[perl #23769] don't match first byte of utf8 representation");
}

for (120 .. 130) {
    my $head = 'x' x $_;
    for my $tail ('\x{0061}', '\x{1234}') {
	ok(
	    eval qq{ "$head$tail" =~ /$head$tail/ },
	    '\x{...} misparsed in regexp near 127 char EXACT limit'
	);
    }
}

# last test 1055

@


1.1.1.7
log
@perl 5.8.3 from CPAN
@
text
@d1694 1
a1694 2
    # the next two tests must be ignored on EBCDIC
    print "not " unless $x =~ /\p{InLatin1Supplement}/ or ord("A") == 193;
d1697 1
a1697 1
    print "not " if     $x =~ /\P{InLatin1Supplement}/ and ord("A") != 193;
d1912 1
a1912 2
# singleton (not in a range, this test must be ignored on EBCDIC)
print "not " unless chr(0xb5) =~ /\p{IsGreek}/ or ord("A") == 193;
@


1.1.1.8
log
@Import of stock perl 5.8.5
@
text
@d9 1
a9 1
print "1..1065\n";
d1913 3
a1915 4
# # singleton (not in a range, this test must be ignored on EBCDIC)
# print "not " unless chr(0xb5) =~ /\p{IsGreek}/ or ord("A") == 193;
# print "ok 665\n";
print "ok 665 # 0xb5 moved from Greek to Common with Unicode 4.0.1\n";
d2240 1
a2240 2
    # L& and LC are the same
    print "not " unless "a" =~ /\p{LC}/ and "a" =~ /\p{L&}/;
d2243 1
a2243 1
    print "not " if     "1" =~ /\p{LC}/ or "1" =~ /\p{L&}/;
d3258 1
a3258 20
# perl #25269: panic: pp_match start/end pointers
ok("a-bc" eq eval {
	my($x, $y) = "bca" =~ /^(?=.*(a)).*(bc)/;
	"$x-$y";
}, 'captures can move backwards in string');

# perl #27940: \cA not recognized in character classes
ok("a\cAb" =~ /\cA/, '\cA in pattern');
ok("a\cAb" =~ /[\cA]/, '\cA in character class');
ok("a\cAb" =~ /[\cA-\cB]/, '\cA in character class range');
ok("abc" =~ /[^\cA-\cB]/, '\cA in negated character class range');
ok("a\cBb" =~ /[\cA-\cC]/, '\cB in character class range');
ok("a\cCbc" =~ /[^\cA-\cB]/, '\cC in negated character class range');
ok("a\cAb" =~ /(??{"\cA"})/, '\cA in ??{} pattern');

# perl #28532: optional zero-width match at end of string is ignored
ok(("abc" =~ /^abc(\z)?/) && defined($1),
    'optional zero-width match at end of string');
ok(("abc" =~ /^abc(\z)??/) && !defined($1),
    'optional zero-width match at end of string');
a3259 1
# last test 1065
@


1.1.1.9
log
@perl 5.8.8 import
@
text
@d9 1
a9 1
print "1..1187\n";
d84 1
a84 8
    if (/not ok 26/) {
      if ($^O eq 'VMS') {
	$_ = shift(@@XXX);
      }
      else {
	reset 'X';
      }
   }
d87 1
a87 2
if ($^O ne 'VMS') {
  while (($key,$val) = each(%XXX)) {
a89 1
  }
d3281 1
a3281 110


{ # TRIE related
    my @@got=();
    "words"=~/(word|word|word)(?{push @@got,$1})s$/;
    ok(@@got==1,"TRIE optimation is working") or warn "# @@got";
    @@got=();
    "words"=~/(word|word|word)(?{push @@got,$1})s$/i;
    ok(@@got==1,"TRIEF optimisation is working") or warn "# @@got";

    my @@nums=map {int rand 1000} 1..100;
    my $re="(".(join "|",@@nums).")";
    $re=qr/\b$re\b/;

    foreach (@@nums) {
        ok($_=~/$re/,"Trie nums");
    }
    $_=join " ", @@nums;
    @@got=();
    push @@got,$1 while /$re/g;

    my %count;
    $count{$_}++ for @@got;
    my $ok=1;
    for (@@nums) {
        $ok=0 if --$count{$_}<0;
    }
    ok($ok,"Trie min count matches");
}


# TRIE related
# LATIN SMALL/CAPITAL LETTER A WITH MACRON
ok(("foba  \x{101}foo" =~ qr/(foo|\x{100}foo|bar)/i) && $1 eq "\x{101}foo",
   "TRIEF + LATIN SMALL/CAPITAL LETTER A WITH MACRON");

# LATIN SMALL/CAPITAL LETTER A WITH RING BELOW
ok(("foba  \x{1E01}foo" =~ qr/(foo|\x{1E00}foo|bar)/i) && $1 eq "\x{1E01}foo",
   "TRIEF + LATIN SMALL/CAPITAL LETTER A WITH RING BELOW");

# DESERET SMALL/CAPITAL LETTER LONG I
ok(("foba  \x{10428}foo" =~ qr/(foo|\x{10400}foo|bar)/i) &&  $1 eq "\x{10428}foo",
   "TRIEF + DESERET SMALL/CAPITAL LETTER LONG I");

# LATIN SMALL/CAPITAL LETTER A WITH RING BELOW + 'X'
ok(("foba  \x{1E01}xfoo" =~ qr/(foo|\x{1E00}Xfoo|bar)/i) &&  $1 eq "\x{1E01}xfoo",
   "TRIEF + LATIN SMALL/CAPITAL LETTER A WITH RING BELOW + 'X'");

{# TRIE related

use charnames ':full';

$s="\N{LATIN SMALL LETTER SHARP S}";
ok(("foba  ba$s" =~ qr/(foo|Ba$s|bar)/i)
    &&  $1 eq "ba$s",
   "TRIEF + LATIN SMALL LETTER SHARP S =~ ss");
ok(("foba  ba$s" =~ qr/(Ba$s|foo|bar)/i)
    &&  $1 eq "ba$s",
   "TRIEF + LATIN SMALL LETTER SHARP S =~ ss");
ok(("foba  ba$s" =~ qr/(foo|bar|Ba$s)/i)
    &&  $1 eq "ba$s",
   "TRIEF + LATIN SMALL LETTER SHARP S =~ ss");

ok(("foba  ba$s" =~ qr/(foo|Bass|bar)/i)
    &&  $1 eq "ba$s",
   "TRIEF + LATIN SMALL LETTER SHARP S =~ ss");

ok(("foba  ba$s" =~ qr/(foo|BaSS|bar)/i)
    &&  $1 eq "ba$s",
   "TRIEF + LATIN SMALL LETTER SHARP S =~ SS");
}



{
    my @@normal=qw(these are some normal words);
    my $psycho=join "|",@@normal,map chr $_,255..20000;
    ok(('these'=~/($psycho)/) && $1 eq 'these','Pyscho');
}

# [perl #36207] mixed utf8 / latin-1 and case folding

{
    my $utf8 = "\xe9\x{100}"; chop $utf8;
    my $latin1 = "\xe9";

    ok($utf8 =~ /\xe9/i, "utf8/latin");
    ok($utf8 =~ /$latin1/i, "utf8/latin runtime");
    ok($utf8 =~ /(abc|\xe9)/i, "utf8/latin trie");
    ok($utf8 =~ /(abc|$latin1)/i, "utf8/latin trie runtime");

    ok("\xe9" =~ /$utf8/i, "# TODO latin/utf8");
    ok("\xe9" =~ /(abc|$utf8)/i, "# latin/utf8 trie");
    ok($latin1 =~ /$utf8/i, "# TODO latin/utf8 runtime");
    ok($latin1 =~ /(abc|$utf8)/i, "# latin/utf8 trie runtime");
}

# [perl #37038] Global regular matches generate invalid pointers

{
    my $s = "abcd";
    $s =~ /(..)(..)/g;
    $s = $1;
    $s = $2;
    ok($s eq 'cd',
       "# assigning to original string should not corrupt match vars");
}

# last test 1187

@


1.1.1.10
log
@import perl 5.10.0 from CPAN
@
text
@d9 1
a9 1
# Test counter output is generated by a BEGIN block at bottom of file
a14 1
our $Message = "Noname test";
d23 3
a25 2
# used to be a test for $*
if ($x =~ /^def/m) {print "ok 3\n";} else {print "not ok 3\n";}
d72 3
a74 2
# used to be a test for $*
if ("ab\ncd\n" =~ /^cd/m) {print "ok 24\n";} else {print "not ok 24\n";}
d481 1
a481 1
print "not " unless qr/\b\v$/i eq '(?i-xsm:\b\v$)';
d485 1
a485 1
print "not " unless qr/\b\v$/s eq '(?s-xim:\b\v$)';
d489 1
a489 1
print "not " unless qr/\b\v$/m eq '(?m-xis:\b\v$)';
d493 1
a493 1
print "not " unless qr/\b\v$/x eq '(?x-ism:\b\v$)';
d497 1
a497 1
print "not " unless qr/\b\v$/xism eq '(?msix:\b\v$)';
d501 1
a501 1
print "not " unless qr/\b\v$/ eq '(?-xism:\b\v$)';
d879 3
a881 1
iseq($1,'ab');
d1052 3
a1054 1
iseq("@@b","@@c");
d1290 1
a1290 1
    $test = 248;
d1380 1
a1380 1
    $test = 264; # till 575
d2036 1
a2036 1
$test = 687;
d2039 1
a2039 1
sub ok ($;$) {
d2042 1
a2042 2
    printf "%sok %d - %s\n", ($ok ? "" : "not "), $test,
        ($name||$Message)."\tLine ".((caller)[2]);
d2608 5
a2612 1
    $test= 835;
d2614 2
a2615 2
    ok("\N{LATIN SMALL LETTER SHARP S}" =~ /\N{LATIN SMALL LETTER SHARP S}/);
    ok("\N{LATIN SMALL LETTER SHARP S}" =~ /\N{LATIN SMALL LETTER SHARP S}/i);
d2617 2
a2618 2
    ok("\N{LATIN SMALL LETTER SHARP S}" =~ /[\N{LATIN SMALL LETTER SHARP S}]/);
    ok("\N{LATIN SMALL LETTER SHARP S}" =~ /[\N{LATIN SMALL LETTER SHARP S}]/i);
d2620 2
a2621 4
    ok("ss" =~ /\N{LATIN SMALL LETTER SHARP S}/i);
    ok("SS" =~ /\N{LATIN SMALL LETTER SHARP S}/i);
    ok("ss" =~ /[\N{LATIN SMALL LETTER SHARP S}]/i);
    ok("SS" =~ /[\N{LATIN SMALL LETTER SHARP S}]/i);
d2623 14
a2636 2
    ok("\N{LATIN SMALL LETTER SHARP S}" =~ /ss/i);
    ok("\N{LATIN SMALL LETTER SHARP S}" =~ /SS/i);
d2643 1
a2643 5
    if ($ordA == 193) {
	print "<\x{100}\x{0085}>" =~ /<\x{100}e>/ ? "ok 845\n" : "not ok 845\n";
    } else {
	print "<\x{100}\x{0085}>" =~ /<\x{100}\s>/ ? "ok 845\n" : "not ok 845\n";
    }
d2751 1
a2751 1
    $test = 865;
d2790 1
a2790 1
    $test = 893;
d2806 1
a2806 1
    $test = 896;
d2818 1
a2818 1
    $test = 898;
d2998 2
a2999 2
ok("\x{0712}" =~ /\p{IsSyriac1}/, '\x{0712}, \p{IsSyriac1}');
ok("\x{072F}" =~ /\P{IsSyriac1}/, '\x{072F}, \P{IsSyriac1}');
d3008 2
a3009 23
ok("\x{0712}" =~ /\p{Syriac1}/, '\x{0712}, \p{Syriac1}');
ok("\x{072F}" =~ /\P{Syriac1}/, '\x{072F}, \p{Syriac1}');

print "# user-defined character properties may lack \\n at the end\n";
sub InGreekSmall   { return "03B1\t03C9" }
sub InGreekCapital { return "0391\t03A9\n-03A2" }

ok("\x{03C0}" =~ /\p{InGreekSmall}/,   "Small pi");
ok("\x{03C2}" =~ /\p{InGreekSmall}/,   "Final sigma");
ok("\x{03A0}" =~ /\p{InGreekCapital}/, "Capital PI");
ok("\x{03A2}" =~ /\P{InGreekCapital}/, "Reserved");

sub AsciiHexAndDash {
    return <<'END';
+utf8::ASCII_Hex_Digit
+utf8::Dash
END
}

ok("-" =~ /\p{Dash}/,            "'-' is Dash");
ok("A" =~ /\p{ASCII_Hex_Digit}/, "'A' is ASCII_Hex_Digit");
ok("-" =~ /\p{AsciiHexAndDash}/, "'-' is AsciiHexAndDash");
ok("A" =~ /\p{AsciiHexAndDash}/, "'A' is AsciiHexAndDash");
d3018 1
a3018 1
	    ? "ok $test\n" : "not ok $test\t# [#18179] $ok/$ord/$len\n";
d3165 1
a3165 4
    # XXX DAPM 13-Apr-06. Recursive split is still broken. It's only luck it
    # hasn't been crashing. Disable this test until it is fixed properly.
    # XXX also check what it returns rather than just doing ok(1,...)
    # split /(?{ split "" })/, "abc";
d3196 1
a3196 10
# bug #22354
sub func ($) {
    ok( "a\nb" !~ /^b/, $_[0] );
    ok( "a\nb" =~ /^b/m, "$_[0] - with /m" );
}
func "standalone";
$_ = "x"; s/x/func "in subst"/e;
$_ = "x"; s/x/func "in multiline subst"/em;
#$_ = "x"; /x(?{func "in regexp"})/;
#$_ = "x"; /x(?{func "in multiline regexp"})/m;
d3198 1
a3198 1
# bug RT#19049
d3201 1
a3201 1
ok("abcde" eq "$`", 'RT#19049 - global match not setting $`');
a3282 1
ok("ab" !~ /a\cIb/x, '\cI in pattern');
d3360 1
a3361 3
ok(("foba  ba${s}pxySS$s$s" =~ qr/(b(?:a${s}t|a${s}f|a${s}p)[xy]+$s*)/i)
    &&  $1 eq "ba${s}pxySS$s$s",
   "COMMON PREFIX TRIEF + LATIN SMALL LETTER SHARP S");
a3362 2
   
}
d3364 1
a3364 3

print "# set PERL_SKIP_PSYCHO_TEST to skip this test\n";
if (!$ENV{PERL_SKIP_PSYCHO_TEST}){
a3367 2
} else {
    ok(1,'Skipped Psycho');
d3381 1
a3381 1
    ok("\xe9" =~ /$utf8/i, "# latin/utf8");
d3383 1
a3383 1
    ok($latin1 =~ /$utf8/i, "# latin/utf8 runtime");
d3398 1
a3398 661
{
    package wooosh;
    sub gloople {
      "!";
    }
    package main;
    
    my $aeek = bless {}, 'wooosh';
    eval {$aeek->gloople() =~ /(.)/g;};
    ok($@@ eq "", "//g match against return value of sub") or print "# $@@\n";
}

{
    sub gloople {
      "!";
    }
    eval {gloople() =~ /(.)/g;};
    ok($@@ eq "", "# 26410 didn't affect sub calls for some reason")
	or print "# $@@\n";
}

{
    package lv;
    $var = "abc";
    sub variable : lvalue { $var }

    package main;
    my $o = bless [], "lv";
    my $f = "";
    eval { for (1..2) { $f .= $1 if $o->variable =~ /(.)/g } };
    ok($f eq "ab", "pos retained between calls # TODO") or print "# $@@\n";
}

{
    $var = "abc";
    sub variable : lvalue { $var }

    my $f = "";
    eval { for (1..2) { $f .= $1 if variable() =~ /(.)/g } };
    ok($f eq "ab", "pos retained between calls # TODO") or print "# $@@\n";
}

# [perl #37836] Simple Regex causes SEGV when run on specific data
if ($ordA == 193) {
    print "ok $test # Skip: in EBCDIC\n"; $test++;
} else {
    no warnings 'utf8';
    $_ = pack('U0C2', 0xa2, 0xf8); # ill-formed UTF-8
    my $ret = 0;
    eval { $ret = s/[\0]+//g };
    ok($ret == 0, "ill-formed UTF-8 doesn't match NUL in class");
}

{ # [perl #38293] chr(65535) should be allowed in regexes
    no warnings 'utf8'; # to allow non-characters
    my($c, $r, $s);

    $c = chr 0xffff;
    $c =~ s/$c//g;
    ok($c eq "", "U+FFFF, parsed as atom");

    $c = chr 0xffff;
    $r = "\\$c";
    $c =~ s/$r//g;
    ok($c eq "", "U+FFFF backslashed, parsed as atom");

    $c = chr 0xffff;
    $c =~ s/[$c]//g;
    ok($c eq "", "U+FFFF, parsed in class");

    $c = chr 0xffff;
    $r = "[\\$c]";
    $c =~ s/$r//g;
    ok($c eq "", "U+FFFF backslashed, parsed in class");

    $s = "A\x{ffff}B";
    $s =~ s/\x{ffff}//i;
    ok($s eq "AB", "U+FFFF, EXACTF");

    $s = "\x{ffff}A";
    $s =~ s/\bA//;
    ok($s eq "\x{ffff}", "U+FFFF, BOUND");

    $s = "\x{ffff}!";
    $s =~ s/\B!//;
    ok($s eq "\x{ffff}", "U+FFFF, NBOUND");
} # non-characters end

{
    # https://rt.perl.org/rt3/Ticket/Display.html?id=39583
    
    # The printing characters
    my @@chars = ("A".."Z");
    my $delim = ",";
    my $size = 32771 - 4;
    my $str = '';

    # create some random junk. Inefficient, but it works.
    for ($i = 0 ; $i < $size ; $i++) {
        $str .= $chars[int(rand(@@chars))];
    }

    $str .= ($delim x 4);
    my $res;
    my $matched;
    if ($str =~ s/^(.*?)${delim}{4}//s) {
        $res = $1;
        $matched=1;
    } 
    ok($matched,'pattern matches');
    ok(length($str)==0,"Empty string");
    ok(defined($res) && length($res)==$size,"\$1 is correct size");
}

{ # related to [perl #27940]
    ok("\0-A"  =~ /\c@@-A/, '@@- should not be interpolated in a pattern');
    ok("\0\0A" =~ /\c@@+A/, '@@+ should not be interpolated in a pattern');
    ok("X\@@-A"  =~ /X@@-A/, '@@- should not be interpolated in a pattern');
    ok("X\@@\@@A" =~ /X@@+A/, '@@+ should not be interpolated in a pattern');

    ok("X\0A" =~ /X\c@@?A/,  '\c@@?');
    ok("X\0A" =~ /X\c@@*A/,  '\c@@*');
    ok("X\0A" =~ /X\c@@(A)/, '\c@@(');
    ok("X\0A" =~ /X(\c@@)A/, '\c@@)');
    ok("X\0A" =~ /X\c@@|ZA/, '\c@@|');

    ok("X\@@A" =~ /X@@?A/,  '@@?');
    ok("X\@@A" =~ /X@@*A/,  '@@*');
    ok("X\@@A" =~ /X@@(A)/, '@@(');
    ok("X\@@A" =~ /X(@@)A/, '@@)');
    ok("X\@@A" =~ /X@@|ZA/, '@@|');

    local $" = ','; # non-whitespace and non-RE-specific
    ok('abc' =~ /(.)(.)(.)/, 'the last successful match is bogus');
    ok("A@@+B"  =~ /A@@{+}B/,  'interpolation of @@+ in /@@{+}/');
    ok("A@@-B"  =~ /A@@{-}B/,  'interpolation of @@- in /@@{-}/');
    ok("A@@+B"  =~ /A@@{+}B/x, 'interpolation of @@+ in /@@{+}/x');
    ok("A@@-B"  =~ /A@@{-}B/x, 'interpolation of @@- in /@@{-}/x');
}

{
    use lib 'lib';
    use Cname;
    
    ok('fooB'=~/\N{foo}[\N{B}\N{b}]/,"Passthrough charname");
    $test=1233; my $handle=make_must_warn('Ignoring excess chars from');
    $handle->('q(xxWxx) =~ /[\N{WARN}]/');
    {
        my $code;
        my $w="";
        local $SIG{__WARN__} = sub { $w.=shift };
        eval($code=<<'EOFTEST') or die "$@@\n$code\n";
        {
            use warnings;
            
            #1234
            ok("\0" !~ /[\N{EMPTY-STR}XY]/,
                "Zerolength charname in charclass doesnt match \0");
            1;
        }
EOFTEST
        ok($w=~/Ignoring zero length/,
            "Got expected zero length warning");
        warn $code;                    
        
    }
    $handle= make_must_warn('Ignoring zero length');
    $handle->('qq(\\0) =~ /[\N{EMPTY-STR}XY]/');
    ok('AB'=~/(\N{EVIL})/ && $1 eq 'A',"Charname caching $1");
    ok('ABC'=~/(\N{EVIL})/,"Charname caching $1");    
    ok('xy'=~/x\N{EMPTY-STR}y/, 'Empty string charname produces NOTHING node');
    ok(''=~/\N{EMPTY-STR}/, 'Empty string charname produces NOTHING node 2');
        
}
{
    print "# MORE LATIN SMALL LETTER SHARP S\n";

    use charnames ':full';

    #see also test #835
    ok("ss" =~ /[\N{LATIN SMALL LETTER SHARP S}x]/i,
        "unoptimized named sequence in class 1");
    ok("SS" =~ /[\N{LATIN SMALL LETTER SHARP S}x]/i,
        "unoptimized named sequence in class 2");        
    ok("\N{LATIN SMALL LETTER SHARP S}" =~ /[\N{LATIN SMALL LETTER SHARP S}x]/,
        "unoptimized named sequence in class 3");
    ok("\N{LATIN SMALL LETTER SHARP S}" =~ /[\N{LATIN SMALL LETTER SHARP S}x]/i,
        "unoptimized named sequence in class 4");        
    
    ok('aabc' !~ /a\N{PLUS SIGN}b/,'/a\N{PLUS SIGN}b/ against aabc');
    ok('a+bc' =~ /a\N{PLUS SIGN}b/,'/a\N{PLUS SIGN}b/ against a+bc');
    ok('a+bc' =~ /a\N{PLUS SIGN}b/,'/a\N{PLUS SIGN}b/ against a+bc');

    ok(' A B'=~/\N{SPACE}\N{U+0041}\N{SPACE}\N{U+0042}/,
        'Intermixed named and unicode escapes 1');
    ok("\N{SPACE}\N{U+0041}\N{SPACE}\N{U+0042}"=~
       /\N{SPACE}\N{U+0041}\N{SPACE}\N{U+0042}/,
        'Intermixed named and unicode escapes 2');
    ok("\N{SPACE}\N{U+0041}\N{SPACE}\N{U+0042} 3"=~
       /[\N{SPACE}\N{U+0041}][\N{SPACE}\N{U+0042}]/,
        'Intermixed named and unicode escapes');     
}
$brackets = qr{
	         {  (?> [^{}]+ | (??{ $brackets }) )* }
	      }x;
ok("{b{c}d" !~ m/^((??{ $brackets }))/, "bracket mismatch");

SKIP:{
    our @@stack=();
    my @@expect=qw(
        stuff1
        stuff2
        <stuff1>and<stuff2>
        right
        <right>
        <<right>>
        <<<right>>>
        <<stuff1>and<stuff2>><<<<right>>>>
    );

    local $_='<<<stuff1>and<stuff2>><<<<right>>>>>';
    ok(/^(<((?:(?>[^<>]+)|(?1))*)>(?{push @@stack, $2 }))$/,
        "Recursion should match");
    ok(@@stack==@@expect)
        or skip("Won't test individual results as count isn't equal",
                0+@@expect);
    foreach my $idx (@@expect) {
        ok($expect[$idx] eq $stack[$idx], 
            "Expecting '$expect' at stack pos #$idx");
    }
        
}
{
    my $s='123453456';
    $s=~s/(?<digits>\d+)\k<digits>/$+{digits}/;
    ok($s eq '123456','Named capture (angle brackets) s///');
    $s='123453456';
    $s=~s/(?'digits'\d+)\k'digits'/$+{digits}/;
    ok($s eq '123456','Named capture (single quotes) s///');    
}

{
    my @@ary = (
	pack('U', 0x00F1),            # n-tilde
	'_'.pack('U', 0x00F1),        # _ + n-tilde
	'c'.pack('U', 0x0327),        # c + cedilla
	pack('U*', 0x00F1, 0x0327),   # n-tilde + cedilla
	'a'.pack('U', 0x00B2),        # a + superscript two
	pack('U', 0x0391),            # ALPHA
	pack('U', 0x0391).'2',        # ALPHA + 2
	pack('U', 0x0391).'_',        # ALPHA + _
    );
    for my $uni (@@ary) {
	my ($r1, $c1, $r2, $c2) = eval qq{
	    use utf8;
	    scalar("..foo foo.." =~ /(?'${uni}'foo) \\k'${uni}'/),
		\$+{${uni}},
	    scalar("..bar bar.." =~ /(?<${uni}>bar) \\k<${uni}>/),
		\$+{${uni}};
	};
	ok($r1,                         "Named capture UTF (?'')");
	ok(defined $c1 && $c1 eq 'foo', "Named capture UTF \%+");
	ok($r2,                         "Named capture UTF (?<>)");
	ok(defined $c2 && $c2 eq 'bar', "Named capture UTF \%+");
    }
}

sub iseq($$;$) { 
    my ( $got, $expect, $name)=@@_;
    
    $_=defined($_) ? "'$_'" : "undef"
        for $got, $expect;
        
    my $ok=  $got eq $expect;
        
    printf "%sok %d - %s\n", ($ok ? "" : "not "), $test,
        ($name||$Message)."\tLine ".((caller)[2]);

    printf "# Failed test at line %d\n".
           "# expected: %s\n". 
           "#   result: %s\n", 
           (caller)[2], $expect, $got
        unless $ok;

    $test++;
    return $ok;
}   
{
    my $s='foo bar baz';
    my (@@k,@@v,@@fetch,$res);
    my $count= 0;
    my @@names=qw($+{A} $+{B} $+{C});
    if ($s=~/(?<A>foo)\s+(?<B>bar)?\s+(?<C>baz)/) {
        while (my ($k,$v)=each(%+)) {
            $count++;
        }
        @@k=sort keys(%+);
        @@v=sort values(%+);
        $res=1;
        push @@fetch,
            [ "$+{A}", "$1" ],
            [ "$+{B}", "$2" ],
            [ "$+{C}", "$3" ],
        ;
    } 
    foreach (0..2) {
        if ($fetch[$_]) {
            iseq($fetch[$_][0],$fetch[$_][1],$names[$_]);
        } else {
            ok(0, $names[$_]);
        }
    }
    iseq($res,1,"$s~=/(?<A>foo)\s+(?<B>bar)?\s+(?<C>baz)/");
    iseq($count,3,"Got 3 keys in %+ via each");
    iseq(0+@@k, 3, 'Got 3 keys in %+ via keys');
    iseq("@@k","A B C", "Got expected keys");
    iseq("@@v","bar baz foo", "Got expected values");
    eval'
        print for $+{this_key_doesnt_exist};
    ';
    ok(!$@@,'lvalue $+{...} should not throw an exception');
}
{
    my $s='foo bar baz';
    my @@res;
    if ('1234'=~/(?<A>1)(?<B>2)(?<A>3)(?<B>4)/) {
        foreach my $name (sort keys(%-)) {
            my $ary = $-{$name};
            foreach my $idx (0..$#$ary) {
                push @@res,"$name:$idx:$ary->[$idx]";
            }
        }
    }
    my @@expect=qw(A:0:1 A:1:3 B:0:2 B:1:4);
    iseq("@@res","@@expect","Check %-");
    eval'
        print for $-{this_key_doesnt_exist};
    ';
    ok(!$@@,'lvalue $-{...} should not throw an exception');
}
# stress test CURLYX/WHILEM.
#
# This test includes varying levels of nesting, and according to
# profiling done against build 28905, exercises every code line in the
# CURLYX and WHILEM blocks, except those related to LONGJMP, the
# super-linear cache and warnings. It executes about 0.5M regexes

if ($ENV{PERL_SKIP_PSYCHO_TEST}){
  printf "ok %d Skip: No psycho tests\n", $test++;
} else {    
  print "# set PERL_SKIP_PSYCHO_TEST to skip this test\n";
  my $r = qr/^
  	    (?:
  		( (?:a|z+)+ )
  		(?:
  		    ( (?:b|z+){3,}? )
  		    (
  			(?:
  			    (?:
				(?:c|z+){1,1}?z
			    )?
  			    (?:c|z+){1,1}
  			)*
  		    )
  		    (?:z*){2,}
  		    ( (?:z+|d)+ )
  		    (?:
  			( (?:e|z+)+ )
  		    )*
  		    ( (?:f|z+)+ )
  		)*
  		( (?:z+|g)+ )
  		(?:
  		    ( (?:h|z+)+ )
  		)*
  		( (?:i|z+)+ )
  	    )+
  	    ( (?:j|z+)+ )
  	    (?:
  		( (?:k|z+)+ )
  	    )*
  	    ( (?:l|z+)+ )
  	$/x;
  
  
  my $ok = 1;
  my $msg = "CURLYX stress test";
  OUTER:
  for my $a ("x","a","aa") {
    for my $b ("x","bbb","bbbb") {
      my $bs = $a.$b;
      for my $c ("x","c","cc") {
        my $cs = $bs.$c;
        for my $d ("x","d","dd") {
          my $ds = $cs.$d;
          for my $e ("x","e","ee") {
            my $es = $ds.$e;
            for my $f ("x","f","ff") {
              my $fs = $es.$f;
              for my $g ("x","g","gg") {
                my $gs = $fs.$g;
                for my $h ("x","h","hh") {
                  my $hs = $gs.$h;
                  for my $i ("x","i","ii") {
                    my $is = $hs.$i;
                    for my $j ("x","j","jj") {
                      my $js = $is.$j;
                      for my $k ("x","k","kk") {
                        my $ks = $js.$k;
                        for my $l ("x","l","ll") {
                          my $ls = $ks.$l;
                          if ($ls =~ $r) {
                            if ($ls =~ /x/) {
                              $msg .= ": unexpected match for [$ls]";
			      $ok = 0;
                              last OUTER;
                            }
                            my $cap = "$1$2$3$4$5$6$7$8$9$10$11$12";
                            unless ($ls eq $cap) {
                              $msg .= ": capture: [$ls], got [$cap]";
			      $ok = 0;
                              last OUTER;
                            }
                          }
                          else {
                            unless ($ls =~ /x/) {
                              $msg = ": failed for [$ls]";
			      $ok = 0;
                              last OUTER;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  ok($ok, $msg);
}

# \, breaks {3,4}
ok("xaaay"    !~ /xa{3\,4}y/, "\, in a pattern");
ok("xa{3,4}y" =~ /xa{3\,4}y/, "\, in a pattern");

# \c\ followed by _
ok("x\c_y"    !~ /x\c\_y/,    "\_ in a pattern");
ok("x\c\_y"   =~ /x\c\_y/,    "\_ in a pattern");

# \c\ followed by other characters
for my $c ("z", "\0", "!", chr(254), chr(256)) {
    my $targ = "a\034$c";
    my $reg  = "a\\c\\$c";
    ok(eval("qq/$targ/ =~ /$reg/"), "\\c\\ in pattern");
}

{
    my $str='abc'; 
    my $count=0;
    my $mval=0;
    my $pval=0;
    while ($str=~/b/g) { $mval=$#-; $pval=$#+; $count++ }
    iseq($mval,0,"\@@- should be empty [RT#36046]");
    iseq($pval,0,"\@@+ should be empty [RT#36046]");
    iseq($count,1,"should have matched once only [RT#36046]");
}

{   # Test the (*PRUNE) pattern
    our $count = 0;
    'aaab'=~/a+b?(?{$count++})(*FAIL)/;
    iseq($count,9,"expect 9 for no (*PRUNE)");
    $count = 0;
    'aaab'=~/a+b?(*PRUNE)(?{$count++})(*FAIL)/;
    iseq($count,3,"expect 3 with (*PRUNE)");
    local $_='aaab';
    $count=0;
    1 while /.(*PRUNE)(?{$count++})(*FAIL)/g;
    iseq($count,4,"/.(*PRUNE)/");
    $count = 0;
    'aaab'=~/a+b?(??{'(*PRUNE)'})(?{$count++})(*FAIL)/;
    iseq($count,3,"expect 3 with (*PRUNE)");
    local $_='aaab';
    $count=0;
    1 while /.(??{'(*PRUNE)'})(?{$count++})(*FAIL)/g;
    iseq($count,4,"/.(*PRUNE)/");
}
{   # Test the (*SKIP) pattern
    our $count = 0;
    'aaab'=~/a+b?(*SKIP)(?{$count++})(*FAIL)/;
    iseq($count,1,"expect 1 with (*SKIP)");
    local $_='aaab';
    $count=0;
    1 while /.(*SKIP)(?{$count++})(*FAIL)/g;
    iseq($count,4,"/.(*SKIP)/");
    $_='aaabaaab';
    $count=0;
    our @@res=();
    1 while /(a+b?)(*SKIP)(?{$count++; push @@res,$1})(*FAIL)/g;
    iseq($count,2,"Expect 2 with (*SKIP)" );
    iseq("@@res","aaab aaab","adjacent (*SKIP) works as expected" );
}
{   # Test the (*SKIP) pattern
    our $count = 0;
    'aaab'=~/a+b?(*MARK:foo)(*SKIP)(?{$count++})(*FAIL)/;
    iseq($count,1,"expect 1 with (*SKIP)");
    local $_='aaab';
    $count=0;
    1 while /.(*MARK:foo)(*SKIP)(?{$count++})(*FAIL)/g;
    iseq($count,4,"/.(*SKIP)/");
    $_='aaabaaab';
    $count=0;
    our @@res=();
    1 while /(a+b?)(*MARK:foo)(*SKIP)(?{$count++; push @@res,$1})(*FAIL)/g;
    iseq($count,2,"Expect 2 with (*SKIP)" );
    iseq("@@res","aaab aaab","adjacent (*SKIP) works as expected" );
}
{   # Test the (*SKIP) pattern
    our $count = 0;
    'aaab'=~/a*(*MARK:a)b?(*MARK:b)(*SKIP:a)(?{$count++})(*FAIL)/;
    iseq($count,3,"expect 3 with *MARK:a)b?(*MARK:b)(*SKIP:a)");
    local $_='aaabaaab';
    $count=0;
    our @@res=();
    1 while /(a*(*MARK:a)b?)(*MARK:x)(*SKIP:a)(?{$count++; push @@res,$1})(*FAIL)/g;
    iseq($count,5,"Expect 5 with (*MARK:a)b?)(*MARK:x)(*SKIP:a)" );
    iseq("@@res","aaab b aaab b ","adjacent (*MARK:a)b?)(*MARK:x)(*SKIP:a) works as expected" );
}
{   # Test the (*COMMIT) pattern
    our $count = 0;
    'aaabaaab'=~/a+b?(*COMMIT)(?{$count++})(*FAIL)/;
    iseq($count,1,"expect 1 with (*COMMIT)");
    local $_='aaab';
    $count=0;
    1 while /.(*COMMIT)(?{$count++})(*FAIL)/g;
    iseq($count,1,"/.(*COMMIT)/");
    $_='aaabaaab';
    $count=0;
    our @@res=();
    1 while /(a+b?)(*COMMIT)(?{$count++; push @@res,$1})(*FAIL)/g;
    iseq($count,1,"Expect 1 with (*COMMIT)" );
    iseq("@@res","aaab","adjacent (*COMMIT) works as expected" );
}
{
    # Test named commits and the $REGERROR var
    our $REGERROR;
    for my $name ('',':foo') 
    {
        for my $pat ("(*PRUNE$name)",
                     ($name? "(*MARK$name)" : "")
                     . "(*SKIP$name)",
                     "(*COMMIT$name)")
        {                         
            for my $suffix ('(*FAIL)','') 
            {
                'aaaab'=~/a+b$pat$suffix/;
                iseq(
                    $REGERROR,
                    ($suffix ? ($name ? 'foo' : "1") : ""),
                    "Test $pat and \$REGERROR $suffix"
                );
            }
        }
    }      
}    
{
    # Test named commits and the $REGERROR var
    package Fnorble;
    our $REGERROR;
    for my $name ('',':foo') 
    {
        for my $pat ("(*PRUNE$name)",
                     ($name? "(*MARK$name)" : "")
                     . "(*SKIP$name)",
                     "(*COMMIT$name)")
        {                         
            for my $suffix ('(*FAIL)','') 
            {
                'aaaab'=~/a+b$pat$suffix/;
                ::iseq(
                    $REGERROR,
                    ($suffix ? ($name ? 'foo' : "1") : ""),
                    "Test $pat and \$REGERROR $suffix"
                );
            }
        }
    }      
}    
{
    # Test named commits and the $REGERROR var
    local $Message = "\$REGERROR";
    our $REGERROR;
    for $word (qw(bar baz bop)) {
        $REGERROR="";
        "aaaaa$word"=~/a+(?:bar(*COMMIT:bar)|baz(*COMMIT:baz)|bop(*COMMIT:bop))(*FAIL)/;
        iseq($REGERROR,$word);
    }    
}
{   #Regression test for perlbug 40684
    local $Message = "RT#40684 tests:";
    my $s = "abc\ndef";
    my $rex = qr'^abc$'m;
    ok($s =~ m/$rex/);
    ok($s =~ m/^abc$/m);
}
{
    #Mindnumbingly simple test of (*THEN)
    for ("ABC","BAX") {
        ok(/A (*THEN) X | B (*THEN) C/x,"Simple (*THEN) test");
    }
}

{
    local $Message = "Relative Recursion";
    my $parens=qr/(\((?:[^()]++|(?-1))*+\))/;
    local $_='foo((2*3)+4-3) + bar(2*(3+4)-1*(2-3))';
    my ($all,$one,$two)=('','','');
    if (/foo $parens \s* \+ \s* bar $parens/x) {
       $all=$&;
       $one=$1;
       $two=$2;
    }
    iseq($one, '((2*3)+4-3)');
    iseq($two, '(2*(3+4)-1*(2-3))');
    iseq($all, 'foo((2*3)+4-3) + bar(2*(3+4)-1*(2-3))');
    iseq($all, $_);
}
{
    my $spaces="      ";
    local $_=join 'bar',$spaces,$spaces;
    our $count=0;
    s/(?>\s+bar)(?{$count++})//g;
    iseq($_,$spaces,"SUSPEND final string");
    iseq($count,1,"Optimiser should have prevented more than one match");
}
{
    local $Message = "RT#36909 test";
    $^R = 'Nothing';
    {
        local $^R = "Bad";
        ok('x foofoo y' =~ m{
         (foo) # $^R correctly set
        (?{ "last regexp code result" })
        }x);
        iseq($^R,'last regexp code result');
    }
    iseq($^R,'Nothing');
    {
        local $^R = "Bad";

        ok('x foofoo y' =~ m{
         (?:foo|bar)+ # $^R correctly set
        (?{"last regexp code result"})
        }x);
        iseq($^R,'last regexp code result');
    }
    iseq($^R,'Nothing');
a3399 480
    {
        local $^R = "Bad";
        ok('x foofoo y' =~ m{
         (foo|bar)\1+ # $^R undefined
        (?{"last regexp code result"})
        }x);
        iseq($^R,'last regexp code result');
    }
    iseq($^R,'Nothing');

    {
        local $^R = "Bad";
        ok('x foofoo y' =~ m{
         (foo|bar)\1 # this time without the +
        (?{"last regexp code result"})
        }x);
        iseq($^R,'last regexp code result');
    }
    iseq($^R,'Nothing');
}
{
    local $Message="RT#22395";
    our $count;
    for my $l (10,100,1000) {
	$count=0;
	('a' x $l) =~ /(.*)(?{$count++})[bc]/;
	iseq( $count, $l + 1, "# TODO Should be L+1 not L*(L+3)/2 (L=$l)");
    }
}
{
    local $Message = "RT#22614";
    local $_='ab';
    our @@len=();
    /(.){1,}(?{push @@len,0+@@-})(.){1,}(?{})^/;
    iseq("@@len","2 2 2");
}
{
    local $Message = "RT#18209";
    my $text = ' word1 word2 word3 word4 word5 word6 ';

    my @@words = ('word1', 'word3', 'word5');
    my $count;
    foreach my $word (@@words){
        $text =~ s/$word\s//gi; # Leave a space to seperate words in the resultant str.
        # The following block is not working.
        if($&){
            $count++;
        }
        # End bad block
    }
    iseq($count,3);
    iseq($text,' word2 word4 word6 ');
}
{
    # RT#6893
    local $_= qq(A\nB\nC\n); 
    my @@res;
    while (m#(\G|\n)([^\n]*)\n#gsx) 
    { 
        push @@res,"$2"; 
        last if @@res>3;
    }
    iseq("@@res","A B C","RT#6893: /g pattern shouldn't infinite loop");
}

{
    # From Message-ID: <877ixs6oa6.fsf@@k75.linux.bogus>
    my $dow_name= "nada";
    my $parser = "(\$dow_name) = \$time_string =~ /(D\x{e9}\\ C\x{e9}adaoin|D\x{e9}\\ Sathairn|\\w+|\x{100})/";
    my $time_string = "D\x{e9} C\x{e9}adaoin";
    eval $parser;
    ok(!$@@,"Test Eval worked");
    iseq($dow_name,$time_string,"UTF8 trie common prefix extraction");
}

{
    my $v;
    ($v='bar')=~/(\w+)/g;
    $v='foo';
    iseq("$1",'bar','$1 is safe after /g - may fail due to specialized config in pp_hot.c')
}
{
    local $Message = "http://nntp.perl.org/group/perl.perl5.porters/118663";
    my $qr_barR1 = qr/(bar)\g-1/;
    ok("foobarbarxyz" =~ $qr_barR1);
    ok("foobarbarxyz" =~ qr/foo${qr_barR1}xyz/);
    ok("foobarbarxyz" =~ qr/(foo)${qr_barR1}xyz/);
    ok("foobarbarxyz" =~ qr/(foo)(bar)\g{-1}xyz/);
    ok("foobarbarxyz" =~ qr/(foo${qr_barR1})xyz/);
    ok("foobarbarxyz" =~ qr/(foo(bar)\g{-1})xyz/);
} 
{
    local $Message = "RT#41010";
    my @@tails=('','(?(1))','(|)','()?');    
    my @@quants=('*','+');
    my $doit=sub {
        my $pats= shift;
        for (@@_) {
            for my $pat (@@$pats) {
                for my $quant (@@quants) {
                    for my $tail (@@tails) {
                        my $re = "($pat$quant\$)$tail";
                        ok(/$re/ && $1 eq $_,"'$_'=~/$re/");
                        ok(/$re/m && $1 eq $_,"'$_'=~/$re/m");
                    }
                }
            }
       }
    };    
    
    my @@dpats=( 
                '\d',
                '[1234567890]',
                '(1|[23]|4|[56]|[78]|[90])',
                '(?:1|[23]|4|[56]|[78]|[90])',
                '(1|2|3|4|5|6|7|8|9|0)',
                '(?:1|2|3|4|5|6|7|8|9|0)',
             );
    my @@spats=('[ ]',' ','( |\t)','(?: |\t)','[ \t]','\s');
    my @@sstrs=('  ');
    my @@dstrs=('12345');
    $doit->(\@@spats,@@sstrs);
    $doit->(\@@dpats,@@dstrs);
}
{
    local $Message = "\$REGMARK";
    our @@r=();
    ok('foofoo' =~ /foo (*MARK:foo) (?{push @@r,$REGMARK}) /x);
    iseq("@@r","foo");           
    iseq($REGMARK,"foo");
    ok('foofoo' !~ /foo (*MARK:foo) (*FAIL) /x);
    ok(!$REGMARK);
    iseq($REGERROR,'foo');
}
{
    my $x;
    $x = "abc.def.ghi.jkl";
    $x =~ s/.*\K\..*//;
    ok($x eq "abc.def.ghi");
    
    $x = "one two three four";
    $x =~ s/o+ \Kthree//g;
    ok($x eq "one two  four");
    
    $x = "abcde";
    $x =~ s/(.)\K/$1/g;
    ok($x eq "aabbccddee");
}
sub kt
{
    return '4' if $_[0] eq '09028623';
}

{   # Nested EVAL using PL_curpm (via $1 or friends)
    my $re;
    our $grabit = qr/ ([0-6][0-9]{7}) (??{ kt $1 }) [890] /x;
    $re = qr/^ ( (??{ $grabit }) ) $ /x;
    my @@res = '0902862349' =~ $re;
    iseq(join("-",@@res),"0902862349",
        'PL_curpm is set properly on nested eval');

    our $qr = qr/ (o) (??{ $1 }) /x;
    ok( 'boob'=~/( b (??{ $qr }) b )/x && 1,
        "PL_curpm, nested eval");
}

{
    use charnames ":full";
    ok("\N{ROMAN NUMERAL ONE}" =~ /\p{Alphabetic}/, "I =~ Alphabetic");
    ok("\N{ROMAN NUMERAL ONE}" =~ /\p{Uppercase}/,  "I =~ Uppercase");
    ok("\N{ROMAN NUMERAL ONE}" !~ /\p{Lowercase}/,  "I !~ Lowercase");
    ok("\N{ROMAN NUMERAL ONE}" =~ /\p{IDStart}/,    "I =~ ID_Start");
    ok("\N{ROMAN NUMERAL ONE}" =~ /\p{IDContinue}/, "I =~ ID_Continue");
    ok("\N{SMALL ROMAN NUMERAL ONE}" =~ /\p{Alphabetic}/, "i =~ Alphabetic");
    ok("\N{SMALL ROMAN NUMERAL ONE}" !~ /\p{Uppercase}/,  "i !~ Uppercase");
    ok("\N{SMALL ROMAN NUMERAL ONE}" =~ /\p{Lowercase}/,  "i =~ Lowercase");
    ok("\N{SMALL ROMAN NUMERAL ONE}" =~ /\p{IDStart}/,    "i =~ ID_Start");
    ok("\N{SMALL ROMAN NUMERAL ONE}" =~ /\p{IDContinue}/, "i =~ ID_Continue");
}

{
# requirement of Unicode Technical Standard #18, 1.7 Code Points
# cf. http://www.unicode.org/reports/tr18/#Supplementary_Characters
    for my $u (0x7FF, 0x800, 0xFFFF, 0x10000) {
        no warnings 'utf8'; # oops
        my $c = chr $u;
        my $x = sprintf '%04X', $u;
        ok( "A${c}B" =~ /A[\0-\x{10000}]B/, "unicode range - $x");
    }
}

{
    my $res="";

    if ('1' =~ /(?|(?<digit>1)|(?<digit>2))/) {
      $res = "@@{$- {digit}}";
    }
    iseq($res,"1",
        "Check that (?|...) doesnt cause dupe entries in the names array");
    #---
    $res="";
    if ('11' =~ /(?|(?<digit>1)|(?<digit>2))(?&digit)/) {
      $res = "@@{$- {digit}}";
    }
    iseq($res, "1",
        "Check that (?&..) to a buffer inside a (?|...) goes to the leftmost");
}

{
    use warnings;
    local $Message = "ASCII pattern that really is utf8";
    my @@w;
    local $SIG{__WARN__}=sub{push @@w,"@@_"};
    my $c=qq(\x{DF}); 
    ok($c=~/${c}|\x{100}/);
    ok(@@w==0);
}    
{
    local $Message = "corruption of match results of qr// across scopes";
    my $qr=qr/(fo+)(ba+r)/;
    'foobar'=~/$qr/;
    iseq("$1$2","foobar");
    {
        'foooooobaaaaar'=~/$qr/;
        iseq("$1$2",'foooooobaaaaar');    
    }
    iseq("$1$2","foobar");
}
{
    local $Message = "HORIZWS";
    local $_="\t \r\n \n \t".chr(11)."\n";
    s/\H/H/g;
    s/\h/h/g;
    iseq($_,"hhHHhHhhHH");
    $_="\t \r\n \n \t".chr(11)."\n";
    utf8::upgrade($_);
    s/\H/H/g;
    s/\h/h/g;
    iseq($_,"hhHHhHhhHH");
}    
{
    local $Message = "Various whitespace special patterns";
    my @@h=map { chr( $_ ) } (
        0x09,   0x20,   0xa0,   0x1680, 0x180e, 0x2000, 0x2001, 0x2002,
        0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200a,
        0x202f, 0x205f, 0x3000
    );
    my @@v=map { chr( $_ ) } ( 0x0a, 0x0b, 0x0c, 0x0d, 0x85, 0x2028, 0x2029 );
    my @@lb=( "\x0D\x0A",
             map { chr( $_ ) } ( 0x0A..0x0D,0x85,0x2028,0x2029 ));
    foreach my $t ([\@@h,qr/\h/,qr/\h+/],[\@@v,qr/\v/,qr/\v+/],[\@@lb,qr/\R/,qr/\R+/],){
        my $ary=shift @@$t;
        foreach my $pat (@@$t) {
            foreach my $str (@@$ary) {
                ok($str=~/($pat)/,$pat);
                iseq($1,$str,$pat);
                utf8::upgrade($str);
                ok($str=~/($pat)/,"Upgraded string - $pat");
                iseq($1,$str,"Upgraded string - $pat");
            }
        }
    }
}
{
    local $Message = "Check that \\xDF match properly in its various forms";
    # test that \xDF matches properly. this is pretty hacky stuff,
    # but its actually needed. the malarky with '-' is to prevent
    # compilation caching from playing any role in the test.
    my @@df= (chr(0xDF),'-',chr(0xDF));
    utf8::upgrade($df[2]);
    my @@strs= ('ss','sS','Ss','SS',chr(0xDF));
    my @@ss= map { ("$_", "$_") } @@strs;
    utf8::upgrade($ss[$_*2+1]) for 0..$#strs;

    for my $ssi (0..$#ss) {
        for my $dfi (0..$#df) {
            my $pat= $df[$dfi];
            my $str= $ss[$ssi];
            my $utf_df= ($dfi > 1) ? 'utf8' : '';
            my $utf_ss= ($ssi % 2) ? 'utf8' : '';
            (my $sstr=$str)=~s/\xDF/\\xDF/;

            if ($utf_df || $utf_ss || length($ss[$ssi])==1) {
                my $ret= $str=~/$pat/i;
                next if $pat eq '-';
                ok($ret, 
                    "\"$sstr\"=~/\\xDF/i (str is @@{[$utf_ss||'latin']}, pat is @@{[$utf_df||'latin']})");
            } else {
                my $ret= $str !~ /$pat/i;
                next if $pat eq '-';
                ok($ret, 
                    "\"$sstr\"!~/\\xDF/i (str is @@{[$utf_ss||'latin']}, pat is @@{[$utf_df||'latin']})");
            }
        }
    }
}
{
    local $Message = "BBC(Bleadperl Breaks CPAN) Today: String::Multibyte";
    my $re  = qr/(?:[\x00-\xFF]{4})/;
    my $hyp = "\0\0\0-";
    my $esc = "\0\0\0\\";

    my $str = "$esc$hyp$hyp$esc$esc";
    my @@a = ($str =~ /\G(?:\Q$esc$esc\E|\Q$esc$hyp\E|$re)/g);

    iseq(0+@@a,3);
    iseq(join('=', @@a),"$esc$hyp=$hyp=$esc$esc");
}
# test for keys in %+ and %-
{
    my $_ = "abcdef";
    /(?<foo>a)|(?<foo>b)/;
    iseq( (join ",", sort keys %+), "foo" );
    iseq( (join ",", sort keys %-), "foo" );
    iseq( (join ",", sort values %+), "a" );
    iseq( (join ",", sort map "@@$_", values %-), "a " );
    /(?<bar>a)(?<bar>b)(?<quux>.)/;
    iseq( (join ",", sort keys %+), "bar,quux" );
    iseq( (join ",", sort keys %-), "bar,quux" );
    iseq( (join ",", sort values %+), "a,c" ); # leftmost
    iseq( (join ",", sort map "@@$_", values %-), "a b,c" );
    /(?<un>a)(?<deux>c)?/; # second buffer won't capture
    iseq( (join ",", sort keys %+), "un" );
    iseq( (join ",", sort keys %-), "deux,un" );
    iseq( (join ",", sort values %+), "a" );
    iseq( (join ",", sort map "@@$_", values %-), ",a" );
}

# length() on captures, the numbered ones end up in Perl_magic_len
{
    my $_ = "aoeu \xe6var ook";
    /^ \w+ \s (?<eek>\S+)/x;

    iseq( length($`), 0, 'length $`' );
    iseq( length($'), 4, q[length $'] );
    iseq( length($&), 9, 'length $&' );
    iseq( length($1), 4, 'length $1' );
    iseq( length($+{eek}), 4, 'length $+{eek} == length $1' );
}

{
    my $ok=-1;

    $ok=exists($-{x}) ? 1 : 0
        if 'bar'=~/(?<x>foo)|bar/;
    iseq($ok,1,'$-{x} exists after "bar"=~/(?<x>foo)|bar/');
    iseq(scalar(%+), 0, 'scalar %+ == 0 after "bar"=~/(?<x>foo)|bar/');
    iseq(scalar(%-), 1, 'scalar %- == 1 after "bar"=~/(?<x>foo)|bar/');

    $ok=-1;
    $ok=exists($+{x}) ? 1 : 0
        if 'bar'=~/(?<x>foo)|bar/;
    iseq($ok,0,'$+{x} not exists after "bar"=~/(?<x>foo)|bar/');
    iseq(scalar(%+), 0, 'scalar %+ == 0 after "bar"=~/(?<x>foo)|bar/');
    iseq(scalar(%-), 1, 'scalar %- == 1 after "bar"=~/(?<x>foo)|bar/');

    $ok=-1;
    $ok=exists($-{x}) ? 1 : 0
        if 'foo'=~/(?<x>foo)|bar/;
    iseq($ok,1,'$-{x} exists after "foo"=~/(?<x>foo)|bar/');
    iseq(scalar(%+), 1, 'scalar %+ == 1 after "foo"=~/(?<x>foo)|bar/');
    iseq(scalar(%-), 1, 'scalar %- == 1 after "foo"=~/(?<x>foo)|bar/');

    $ok=-1;
    $ok=exists($+{x}) ? 1 : 0
        if 'foo'=~/(?<x>foo)|bar/;
    iseq($ok,1,'$+{x} exists after "foo"=~/(?<x>foo)|bar/');
}
{
    local $_;
    ($_ = 'abc')=~/(abc)/g;
    $_ = '123'; 
    iseq("$1",'abc',"/g leads to unsafe match vars: $1");
}
{
    local $Message="Message-ID: <20070818091501.7eff4831@@r2d2>";
    my $str= "";
    for(0..5){
        my @@x;
        $str .= "@@x"; # this should ALWAYS be the empty string
        'a'=~/(a|)/;
        push @@x,1;
    }
    iseq(length($str),"0","Trie scope error, string should be empty");
    $str="";
    my @@foo = ('a')x5;
    for (@@foo) {
        my @@bar;
        $str .= "@@bar";
        s/a|/push @@bar, 1/e;
    }
    iseq(length($str),"0","Trie scope error, string should be empty");
}
{
# [perl #45605] Regexp failure with utf8-flagged and byte-flagged string

    my $utf_8 = "\xd6schel";
    utf8::upgrade($utf_8);
    $utf_8 =~ m{(\xd6|&Ouml;)schel};
    iseq($1,"\xd6","#45605");
}

{
    # Regardless of utf8ness any character matches itself when 
    # doing a case insensitive match. See also [perl #36207] 
    for my $o (0..255) {
        my @@ch=(chr($o),chr($o));
        utf8::upgrade($ch[1]);
        for my $u_str (0,1) {
            for my $u_pat (0,1) {
                ok( $ch[$u_str]=~/\Q$ch[$u_pat]\E/i,
                    "\$c=~/\$c/i : chr($o) : u_str=$u_str u_pat=$u_pat");
                ok( $ch[$u_str]=~/\Q$ch[$u_pat]\E|xyz/i,
                "# \$c=~/\$c|xyz/i : chr($o) : u_str=$u_str u_pat=$u_pat");
            }
        }
    }
}

# Test counter is at bottom of file. Put new tests above here.
#-------------------------------------------------------------------
# Keep the following tests last -- they may crash perl
{   
    # RT#19049 / RT#38869
    my @@list = (
        'ab cdef', # matches regex
        ( 'e' x 40000 ) .'ab c' # matches not, but 'ab c' matches part of it
    );
    my $y;
    my $x;
    foreach (@@list) {
        m/ab(.+)cd/i; # the ignore-case seems to be important
        $y = $1; # use $1, which might not be from the last match!
        $x = substr($list[0],$-[0],$+[0]-$-[0]);
    }
    iseq($y,' ',
        'pattern in a loop, failure should not affect previous success');
    iseq($x,'ab cd',
        'pattern in a loop, failure should not affect previous success');
}

ok(("a" x (2**15 - 10)) =~ /^()(a|bb)*$/, "Recursive stack cracker: #24274")
    or print "# Unexpected outcome: should pass or crash perl\n";

ok((q(a)x 100) =~ /^(??{'(.)'x 100})/, 
        "Regexp /^(??{'(.)'x 100})/ crashes older perls")
    or print "# Unexpected outcome: should pass or crash perl\n";

eval '/\k/';
ok($@@=~/\QSequence \k... not terminated in regex;\E/);

{
    local $Message = "substitution with lookahead (possible segv)";
    $_="ns1ns1ns1";
    s/ns(?=\d)/ns_/g;
    iseq($_,"ns_1ns_1ns_1");
    $_="ns1";
    s/ns(?=\d)/ns_/;
    iseq($_,"ns_1");
    $_="123";
    s/(?=\d+)|(?<=\d)/!Bang!/g;
    iseq($_,"!Bang!1!Bang!2!Bang!3!Bang!");
}

# [perl #45337] utf8 + "[a]a{2}" + /$.../ = panic: sv_len_utf8 cache

{
    local ${^UTF8CACHE} = -1;
    my $s="[a]a{2}";
    utf8::upgrade $s;
    ok("aaa" =~ /$s/, "#45337");
}

# Put new tests above the dotted line about a page above this comment
iseq(0+$::test,$::TestCount,"Got the right number of tests!");
# Don't forget to update this!
BEGIN {
    $::TestCount = 4013;
    print "1..$::TestCount\n";
}
@


1.1.1.11
log
@import perl 5.10.1
@
text
@a6 7
use strict;
use warnings;
use 5.010;


sub run_tests;

d9 1
a9 1
my $EXPECTED_TESTS = 4065;  # Update this when adding/deleting tests.
a14 1
our $TODO;
a15 11
our $Error;
our $DiePattern;
our $WarnPattern;
our $BugId;
our $PatchId;
our $running_as_thread;

my $ordA = ord ('A');  # This defines ASCII/UTF-8 vs EBCDIC/UTF-EBCDIC
# This defined the platform.
my $IS_ASCII  = $ordA ==  65;
my $IS_EBCDIC = $ordA == 193;
a16 1
use vars '%Config';
d19 4
a22 1
my $test = 0;
d24 2
a25 1
print "1..$EXPECTED_TESTS\n";
d27 2
a28 1
run_tests unless caller ();
d30 11
a40 2
END {
}
d42 5
a46 8
sub pretty {
    my ($mess) = @@_;
    $mess =~ s/\n/\\n/g;
    $mess =~ s/\r/\\r/g;
    $mess =~ s/\t/\\t/g;
    $mess =~ s/([\00-\37\177])/sprintf '\%03o', ord $1/eg;
    $mess =~ s/#/\\#/g;
    $mess;
d48 4
a51 3

sub safe_globals {
    defined($_) and s/#/\\#/g for $BugId, $PatchId, $TODO;
d54 1
a54 7
sub _ok {
    my ($ok, $mess, $error) = @@_;
    safe_globals();
    $mess    = pretty ($mess // $Message);
    $mess   .= "; Bug $BugId"     if defined $BugId;
    $mess   .= "; Patch $PatchId" if defined $PatchId;
    $mess   .= " # TODO $TODO"     if defined $TODO;
d56 36
a91 1
    my $line_nr = (caller(1)) [2];
d93 6
a98 4
    printf "%sok %d - %s\n",
              ($ok ? "" : "not "),
              ++ $test,
              "$mess\tLine $line_nr";
d100 1
a100 10
    unless ($ok) {
        print "# Failed test at line $line_nr\n" unless defined $TODO;
        if ($error //= $Error) {
            no warnings 'utf8';
            chomp $error;
            $error = join "\n#", map {pretty $_} split /\n\h*#/ => $error;
            $error = "# $error" unless $error =~ /^\h*#/;
            print $error, "\n";
        }
    }
d102 92
a193 1
    return $ok;
d196 2
a197 3
# Force scalar context on the pattern match
sub  ok ($;$$) {_ok  $_ [0], $_ [1], $_ [2]}
sub nok ($;$$) {_ok !$_ [0], "Failed: " . ($_ [1] // $Message), $_ [2]}
d199 2
d202 105
a306 18
sub skip {
    my $why = shift;
    safe_globals();
    $why =~ s/\n.*//s;
    $why .= "; Bug $BugId" if defined $BugId;
    # seems like the new harness code doesnt like todo and skip to be mixed.
    # which seems like a bug in the harness to me. -- dmq
    #$why .= " # TODO $TODO" if defined $TODO;
    
    my $n = shift // 1;
    my $line_nr = (caller(0)) [2];
    for (1 .. $n) {
        ++ $test;
        #print "not " if defined $TODO;
        print "ok $test # skip $why\tLine $line_nr\n";
    }
    no warnings "exiting";
    last SKIP;
d309 23
a331 8
sub iseq ($$;$) { 
    my ($got, $expect, $name) = @@_;
    
    $_ = defined ($_) ? "'$_'" : "undef" for $got, $expect;
        
    my $ok    = $got eq $expect;
    my $error = "# expected: $expect\n" .
                "#   result: $got";
d333 2
a334 2
    _ok $ok, $name, $error;
}   
d336 30
a365 8
sub isneq ($$;$) { 
    my ($got, $expect, $name) = @@_;
    my $todo = $TODO ? " # TODO $TODO" : '';
    
    $_ = defined ($_) ? "'$_'" : "undef" for $got, $expect;
        
    my $ok    = $got ne $expect;
    my $error = "# results are equal ($got)";
d367 2
a368 2
    _ok $ok, $name, $error;
}   
d370 57
d428 27
a454 9
sub eval_ok ($;$) {
    my ($code, $name) = @@_;
    local $@@;
    if (ref $code) {
        _ok eval {&$code} && !$@@, $name;
    }
    else {
        _ok eval  ($code) && !$@@, $name;
    }
d457 53
a509 7
sub must_die {
    my ($code, $pattern, $name) = @@_;
    $pattern //= $DiePattern;
    undef $@@;
    ref $code ? &$code : eval $code;
    my  $r = $@@ && $@@ =~ /$pattern/;
    _ok $r, $name // $Message // "\$\@@ =~ /$pattern/";
d512 6
a517 12
sub must_warn {
    my ($code, $pattern, $name) = @@_;
    $pattern //= $WarnPattern;
    my $w;
    local $SIG {__WARN__} = sub {$w .= join "" => @@_};
    use warnings 'all';
    ref $code ? &$code : eval $code;
    my $r = $w && $w =~ /$pattern/;
    $w //= "UNDEF";
    _ok $r, $name // $Message // "Got warning /$pattern/",
            "# expected: /$pattern/\n" .
            "#   result: $w";
d520 6
a525 9
sub may_not_warn {
    my ($code, $name) = @@_;
    my $w;
    local $SIG {__WARN__} = sub {$w .= join "" => @@_};
    use warnings 'all';
    ref $code ? &$code : eval $code;
    _ok !$w, $name // ($Message ? "$Message (did not warn)"
                                : "Did not warn"),
             "Got warning '$w'";
d527 2
d530 49
d580 16
a595 4
#
# Tests start here.
#
sub run_tests {
d597 17
a613 1
    {
d615 7
a621 1
        my $x = "abc\ndef\n";
a622 2
        ok $x =~ /^abc/,  qq ["$x" =~ /^abc/];
        ok $x !~ /^def/,  qq ["$x" !~ /^def/];
d624 4
a627 2
        # used to be a test for $*
        ok $x =~ /^def/m, qq ["$x" =~ /^def/m];
d629 1
a629 2
        nok $x =~ /^xxx/, qq ["$x" =~ /^xxx/];
        nok $x !~ /^abc/, qq ["$x" !~ /^abc/];
d631 1
a631 2
         ok $x =~ /def/, qq ["$x" =~ /def/];
        nok $x !~ /def/, qq ["$x" !~ /def/];
d633 2
a634 2
         ok $x !~ /.def/, qq ["$x" !~ /.def/];
        nok $x =~ /.def/, qq ["$x" =~ /.def/];
d636 440
a1075 3
         ok $x =~ /\ndef/, qq ["$x" =~ /\ndef/];
        nok $x !~ /\ndef/, qq ["$x" !~ /\ndef/];
    }
d1077 21
a1097 4
    {
        $_ = '123';
        ok /^([0-9][0-9]*)/, qq [\$_ = '$_'; /^([0-9][0-9]*)/];
    }
d1099 131
a1229 21
    {
        $_ = 'aaabbbccc';
         ok /(a*b*)(c*)/ && $1 eq 'aaabbb' && $2 eq 'ccc',
                                             qq [\$_ = '$_'; /(a*b*)(c*)/];
         ok /(a+b+c+)/ && $1 eq 'aaabbbccc', qq [\$_ = '$_'; /(a+b+c+)/];
        nok /a+b?c+/,                        qq [\$_ = '$_'; /a+b?c+/];

        $_ = 'aaabccc';
         ok /a+b?c+/, qq [\$_ = '$_'; /a+b?c+/];
         ok /a*b?c*/, qq [\$_ = '$_'; /a*b?c*/];

        $_ = 'aaaccc';
         ok /a*b?c*/, qq [\$_ = '$_'; /a*b?c*/];
        nok /a*b+c*/, qq [\$_ = '$_'; /a*b+c*/];

        $_ = 'abcdef';
         ok /bcd|xyz/, qq [\$_ = '$_'; /bcd|xyz/];
         ok /xyz|bcd/, qq [\$_ = '$_'; /xyz|bcd/];
         ok m|bc/*d|,  qq [\$_ = '$_'; m|bc/*d|];
         ok /^$_$/,    qq [\$_ = '$_'; /^\$_\$/];
    }
d1231 7
a1237 4
    {
        # used to be a test for $*
        ok "ab\ncd\n" =~ /^cd/m, qq ["ab\ncd\n" =~ /^cd/m];
    }
d1239 9
a1247 2
    {
        our %XXX = map {($_ => $_)} 123, 234, 345;
d1249 5
a1253 15
        our @@XXX = ('ok 1','not ok 1', 'ok 2','not ok 2','not ok 3');
        while ($_ = shift(@@XXX)) {
            my $f = index ($_, 'not') >= 0 ? \&nok : \&ok;
            my $r = ?(.*)?;
            &$f ($r, "?(.*)?");
            /not/ && reset;
            if (/not ok 2/) {
                if ($^O eq 'VMS') {
                    $_ = shift(@@XXX);
                }
                else {
                    reset 'X';
                }
            }
        }
d1255 20
a1274 6
        SKIP: {
            if ($^O eq 'VMS') {
                skip "Reset 'X'", 1;
            }
            ok !keys %XXX, "%XXX is empty";
        }
d1276 2
a1277 26
    }

    {
        local $Message = "Test empty pattern";
        my $xyz = 'xyz';
        my $cde = 'cde';

        $cde =~ /[^ab]*/;
        $xyz =~ //;
        iseq $&, $xyz;

        my $foo = '[^ab]*';
        $cde =~ /$foo/;
        $xyz =~ //;
        iseq $&, $xyz;

        $cde =~ /$foo/;
        my $null;
        no warnings 'uninitialized';
        $xyz =~ /$null/;
        iseq $&, $xyz;

        $null = "";
        $xyz =~ /$null/;
        iseq $&, $xyz;
    }
d1279 2
a1280 9
    {
        local $Message = q !Check $`, $&, $'!;
        $_ = 'abcdefghi';
        /def/;		# optimized up to cmd
        iseq "$`:$&:$'", 'abc:def:ghi';

        no warnings 'void';
        /cde/ + 0;	# optimized only to spat
        iseq "$`:$&:$'", 'ab:cde:fghi';
d1282 2
a1283 3
        /[d][e][f]/;	# not optimized
        iseq "$`:$&:$'", 'abc:def:ghi';
    }
d1285 11
a1295 4
    {
        $_ = 'now is the {time for all} good men to come to.';
        / {([^}]*)}/;
        iseq $1, 'time for all', "Match braces";
d1297 1
d1299 3
a1301 13
    {
        local $Message = "{N,M} quantifier";
        $_ = 'xxx {3,4}  yyy   zzz';
        ok /( {3,4})/;
        iseq $1, '   ';
        ok !/( {4,})/;
        ok /( {2,3}.)/;
        iseq $1, '  y';
        ok /(y{2,3}.)/;
        iseq $1, 'yyy ';
        ok !/x {3,4}/;
        ok !/^xxx {3,4}/;
    }
d1303 2
a1304 14
    {
        local $Message = "Test /g";
        local $" = ":";
        $_ = "now is the time for all good men to come to.";
        my @@words = /(\w+)/g;
        my $exp   = "now:is:the:time:for:all:good:men:to:come:to";

        iseq "@@words", $exp;

        @@words = ();
        while (/\w+/g) {
            push (@@words, $&);
        }
        iseq "@@words", $exp;
d1306 2
a1307 6
        @@words = ();
        pos = 0;
        while (/to/g) {
            push(@@words, $&);
        }
        iseq "@@words", "to:to";
d1309 2
a1310 4
        pos $_ = 0;
        @@words = /to/g;
        iseq "@@words", "to:to";
    }
d1312 2
a1313 2
    {
        $_ = "abcdefghi";
d1315 2
a1316 27
        my $pat1 = 'def';
        my $pat2 = '^def';
        my $pat3 = '.def.';
        my $pat4 = 'abc';
        my $pat5 = '^abc';
        my $pat6 = 'abc$';
        my $pat7 = 'ghi';
        my $pat8 = '\w*ghi';
        my $pat9 = 'ghi$';

        my $t1 = my $t2 = my $t3 = my $t4 = my $t5 =
        my $t6 = my $t7 = my $t8 = my $t9 = 0;

        for my $iter (1 .. 5) {
            $t1++ if /$pat1/o;
            $t2++ if /$pat2/o;
            $t3++ if /$pat3/o;
            $t4++ if /$pat4/o;
            $t5++ if /$pat5/o;
            $t6++ if /$pat6/o;
            $t7++ if /$pat7/o;
            $t8++ if /$pat8/o;
            $t9++ if /$pat9/o;
        }
        my $x = "$t1$t2$t3$t4$t5$t6$t7$t8$t9";
        iseq $x, '505550555', "Test /o";
    }
d1318 2
d1321 3
a1323 3
    SKIP: {
        my $xyz = 'xyz';
        ok "abc" =~ /^abc$|$xyz/, "| after \$";
d1325 2
a1326 2
        # perl 4.009 says "unmatched ()"
        local $Message = '$ inside ()';
d1328 5
a1332 5
        my $result;
        eval '"abc" =~ /a(bc$)|$xyz/; $result = "$&:$1"';
        iseq $@@, "" or skip "eval failed", 1;
        iseq $result, "abc:bc";
    }
d1334 2
d1337 6
a1342 3
    {
        local $Message = "Scalar /g";
        $_ = "abcfooabcbar";
d1344 2
a1345 19
        ok  /abc/g && $` eq "";
        ok  /abc/g && $` eq "abcfoo";
        ok !/abc/g;

        local $Message = "Scalar /gi";
        pos = 0;
        ok  /ABC/gi && $` eq "";
        ok  /ABC/gi && $` eq "abcfoo";
        ok !/ABC/gi;

        local $Message = "Scalar /g";
        pos = 0;
        ok  /abc/g && $' eq "fooabcbar";
        ok  /abc/g && $' eq "bar";

        $_ .= '';
        my @@x = /abc/g;
        iseq @@x, 2, "/g reset after assignment";
    }
d1347 5
a1351 9
    {
        local $Message = '/g, \G and pos';
        $_ = "abdc";
        pos $_ = 2;
        /\Gc/gc;
        iseq pos $_, 2;
        /\Gc/g;
        ok !defined pos $_;
    }
d1353 2
a1354 10
    {
        local $Message = '(?{ })';
        our $out = 1;
        'abc' =~ m'a(?{ $out = 2 })b';
        iseq $out, 2;

        $out = 1;
        'abc' =~ m'a(?{ $out = 3 })c';
        iseq $out, 1;
    }
d1356 1
d1358 1
a1358 5
    {
        $_ = 'foobar1 bar2 foobar3 barfoobar5 foobar6';
        my @@out = /(?<!foo)bar./g;
        iseq "@@out", 'bar2 barf', "Negative lookbehind";
    }
d1360 3
a1362 20
    {
        local $Message = "REG_INFTY tests";
        # Tests which depend on REG_INFTY
        $::reg_infty   = $Config {reg_infty} // 32767;
        $::reg_infty_m = $::reg_infty - 1;
        $::reg_infty_p = $::reg_infty + 1;
        $::reg_infty_m = $::reg_infty_m;   # Surpress warning.

        # As well as failing if the pattern matches do unexpected things, the
        # next three tests will fail if you should have picked up a lower-than-
        # default value for $reg_infty from Config.pm, but have not.

        eval_ok q (('aaa' =~ /(a{1,$::reg_infty_m})/)[0] eq 'aaa');
        eval_ok q (('a' x $::reg_infty_m) =~ /a{$::reg_infty_m}/);
        eval_ok q (('a' x ($::reg_infty_m - 1)) !~ /a{$::reg_infty_m}/);
        eval "'aaa' =~ /a{1,$::reg_infty}/";
        ok $@@ =~ /^\QQuantifier in {,} bigger than/;
        eval "'aaa' =~ /a{1,$::reg_infty_p}/";
        ok $@@ =~ /^\QQuantifier in {,} bigger than/;
    }
d1364 2
a1365 6
    {
        # Poke a couple more parse failures
        my $context = 'x' x 256;
        eval qq("${context}y" =~ /(?<=$context)y/);
        ok $@@ =~ /^\QLookbehind longer than 255 not/, "Lookbehind limit";
    }
d1367 2
a1368 9
    {
        # Long Monsters
        local $Message = "Long monster";
        for my $l (125, 140, 250, 270, 300000, 30) { # Ordered to free memory
            my $a = 'a' x $l;
            local $Error = "length = $l";
             ok "ba$a=" =~ /a$a=/;
            nok "b$a="  =~ /a$a=/;
             ok "b$a="  =~ /ba+=/;
d1370 3
a1372 3
             ok "ba$a=" =~ /b(?:a|b)+=/;
        }
    }
d1374 2
d1377 1
a1377 18
    {
        # 20000 nodes, each taking 3 words per string, and 1 per branch
        my $long_constant_len = join '|', 12120 .. 32645;
        my $long_var_len = join '|', 8120 .. 28645;
        my %ans = ( 'ax13876y25677lbc' => 1,
                    'ax13876y25677mcb' => 0, # not b.
                    'ax13876y35677nbc' => 0, # Num too big
                    'ax13876y25677y21378obc' => 1,
                    'ax13876y25677y21378zbc' => 0,	# Not followed by [k-o]
                    'ax13876y25677y21378y21378kbc' => 1,
                    'ax13876y25677y21378y21378kcb' => 0, # Not b.
                    'ax13876y25677y21378y21378y21378kbc' => 0, # 5 runs
                  );

        local $Message = "20000 nodes";
        for (keys %ans) {
            local $Error = "const-len '$_'";
            ok !($ans{$_} xor /a(?=([yx]($long_constant_len)){2,4}[k-o]).*b./o);
d1379 186
a1564 3
            local $Error = "var-len '$_'";
            ok !($ans{$_} xor /a(?=([yx]($long_var_len)){2,4}[k-o]).*b./o);
        }
d1566 1
d1568 2
a1569 36
    {
        local $Message = "Complicated backtracking";
        $_ = " a (bla()) and x(y b((l)u((e))) and b(l(e)e)e";
        my $expect = "(bla()) ((l)u((e))) (l(e)e)";

        use vars '$c';
        sub matchit {
          m/
             (
               \(
               (?{ $c = 1 })	# Initialize
               (?:
                 (?(?{ $c == 0 })   # PREVIOUS iteration was OK, stop the loop
                   (?!
                   )		# Fail: will unwind one iteration back
                 )	
                 (?:
                   [^()]+		# Match a big chunk
                   (?=
                     [()]
                   )		# Do not try to match subchunks
                 |
                   \(
                   (?{ ++$c })
                 |
                   \)
                   (?{ --$c })
                 )
               )+		# This may not match with different subblocks
             )
             (?(?{ $c != 0 })
               (?!
               )		# Fail
             )			# Otherwise the chunk 1 may succeed with $c>0
           /xg;
        }
d1571 2
a1572 11
        my @@ans = ();
        my $res;
        push @@ans, $res while $res = matchit;
        iseq "@@ans", "1 1 1";

        @@ans = matchit;
        iseq "@@ans", $expect;

        local $Message = "Recursion with (??{ })";
        our $matched;
        $matched = qr/\((?:(?>[^()]+)|(??{$matched}))*\)/;
d1574 2
a1575 2
        @@ans = my @@ans1 = ();
        push (@@ans, $res), push (@@ans1, $&) while $res = m/$matched/g;
d1577 2
a1578 2
        iseq "@@ans", "1 1 1";
        iseq "@@ans1", $expect;
d1580 2
a1581 2
        @@ans = m/$matched/g;
        iseq "@@ans", $expect;
d1583 4
d1588 1
d1590 2
a1591 3
    {
        ok "abc" =~ /^(??{"a"})b/, '"abc" =~ /^(??{"a"})b/';
    }
d1593 3
a1595 4
    {
        my @@ans = ('a/b' =~ m%(.*/)?(.*)%);	# Stack may be bad
        iseq "@@ans", 'a/ b', "Stack may be bad";
    }
d1597 2
a1598 19
    {
        local $Message = "Eval-group not allowed at runtime";
        my $code = '{$blah = 45}';
        our $blah = 12;
        eval { /(?$code)/ };
        ok $@@ && $@@ =~ /not allowed at runtime/ && $blah == 12;

        for $code ('{$blah = 45}','=xx') {
            $blah = 12;
            my $res = eval { "xx" =~ /(?$code)/o };
            no warnings 'uninitialized';
            local $Error = "'$@@', '$res', '$blah'";
            if ($code eq '=xx') {
                ok !$@@ && $res;
            }
            else {
                ok $@@ && $@@ =~ /not allowed at runtime/ && $blah == 12;
            }
        }
d1600 2
a1601 9
        $code = '{$blah = 45}';
        $blah = 12;
        eval "/(?$code)/";
        iseq $blah, 45;

        $blah = 12;
        /(?{$blah = 45})/;
        iseq $blah, 45;
    }
d1603 8
d1612 1
a1612 12
        local $Message = "Pos checks";
        my $x = 'banana';
        $x =~ /.a/g;
        iseq pos ($x), 2;

        $x =~ /.z/gc;
        iseq pos ($x), 2;

        sub f {
            my $p = $_[0];
            return $p;
        }
d1614 10
a1623 2
        $x =~ /.a/g;
        iseq f (pos ($x)), 4;
d1625 1
d1627 2
a1628 14
    {
        local $Message = 'Checking $^R';
        our $x = $^R = 67;
        'foot' =~ /foo(?{$x = 12; 75})[t]/;
        iseq $^R, 75;

        $x = $^R = 67;
        'foot' =~ /foo(?{$x = 12; 75})[xy]/;
        ok $^R eq '67' && $x eq '12';

        $x = $^R = 67;
        'foot' =~ /foo(?{ $^R + 12 })((?{ $x = 12; $^R + 17 })[xy])?/;
        ok $^R eq '79' && $x eq '12';
    }
d1630 5
a1634 8
    {
        iseq qr/\b\v$/i,    '(?i-xsm:\b\v$)', 'qr/\b\v$/i';
        iseq qr/\b\v$/s,    '(?s-xim:\b\v$)', 'qr/\b\v$/s';
        iseq qr/\b\v$/m,    '(?m-xis:\b\v$)', 'qr/\b\v$/m';
        iseq qr/\b\v$/x,    '(?x-ism:\b\v$)', 'qr/\b\v$/x';
        iseq qr/\b\v$/xism, '(?msix:\b\v$)',  'qr/\b\v$/xism';
        iseq qr/\b\v$/,     '(?-xism:\b\v$)', 'qr/\b\v$/';
    }
d1636 2
d1639 2
a1640 9
    {
        local $Message = "Look around";
        $_ = 'xabcx';
      SKIP:
        foreach my $ans ('', 'c') {
            ok /(?<=(?=a)..)((?=c)|.)/g or skip "Match failed", 1;
            iseq $1, $ans;
        }
    }
d1642 2
a1643 8
    {
        local $Message = "Empty clause";
        $_ = 'a';
        foreach my $ans ('', 'a', '') {
            ok /^|a|$/g or skip "Match failed", 1;
            iseq $&, $ans;
        }
    }
d1645 2
a1646 9
    {
        local $Message = "Prefixify";
        sub prefixify {
            SKIP: {
                my ($v, $a, $b, $res) = @@_;
                ok $v =~ s/\Q$a\E/$b/ or skip "Match failed", 1;
                iseq $v, $res;
            }
        }
d1648 2
a1649 3
        prefixify ('/a/b/lib/arch', "/a/b/lib", 'X/lib', 'X/lib/arch');
        prefixify ('/a/b/man/arch', "/a/b/man", 'X/man', 'X/man/arch');
    }
d1651 2
a1652 5
    {
        $_ = 'var="foo"';
        /(\")/;
        ok $1 && /$1/, "Capture a quote";
    }
d1654 2
a1655 41
    {
        local $Message =  "Call code from qr //";
        $a = qr/(?{++$b})/;
        $b = 7;
        ok /$a$a/ && $b eq '9';

        $c="$a";
        ok /$a$a/ && $b eq '11';

        undef $@@;
        eval {/$c/};
        ok $@@ && $@@ =~ /not allowed at runtime/;

        use re "eval";
        /$a$c$a/;
        iseq $b, '14';

        our $lex_a = 43;
        our $lex_b = 17;
        our $lex_c = 27;
        my $lex_res = ($lex_b =~ qr/$lex_b(?{ $lex_c = $lex_a++ })/);

        iseq $lex_res, 1;
        iseq $lex_a, 44;
        iseq $lex_c, 43;

        no re "eval";
        undef $@@;
        my $match = eval { /$a$c$a/ };
        ok $@@ && $@@ =~ /Eval-group not allowed/ && !$match;
        iseq $b, '14';
     
        $lex_a = 2;
        $lex_a = 43;
        $lex_b = 17;
        $lex_c = 27;
        $lex_res = ($lex_b =~ qr/17(?{ $lex_c = $lex_a++ })/);

        iseq $lex_res, 1;
        iseq $lex_a, 44;
        iseq $lex_c, 43;
d1657 3
a1659 1
    }
d1661 2
d1664 2
a1665 10
    {
        no warnings 'closure';
        local $Message = '(?{ $var } refers to package vars';
        package aa;
        our $c = 2;
        $::c = 3;
        '' =~ /(?{ $c = 4 })/;
        main::iseq $c, 4;
        main::iseq $::c, 3;
    }
d1667 2
d1670 2
a1671 11
    {
        must_die 'q(a:[b]:) =~ /[x[:foo:]]/',
                 'POSIX class \[:[^:]+:\] unknown in regex',
                 'POSIX class [: :] must have valid name';

        for my $d (qw [= .]) {
            must_die "/[[${d}foo${d}]]/",
                     "\QPOSIX syntax [$d $d] is reserved for future extensions",
                     "POSIX syntax [[$d $d]] is an error";
        }
    }
d1673 2
d1676 2
a1677 6
    {
        # test if failure of patterns returns empty list
        local $Message = "Failed pattern returns empty list";
        $_ = 'aaa';
        @@_ = /bbb/;
        iseq "@@_", "";
d1679 2
a1680 2
        @@_ = /bbb/g;
        iseq "@@_", "";
d1682 3
a1684 2
        @@_ = /(bbb)/;
        iseq "@@_", "";
d1686 2
a1687 3
        @@_ = /(bbb)/g;
        iseq "@@_", "";
    }
d1689 2
a1690 3
    
    {
        local $Message = '@@- and @@+ tests';
d1692 2
a1693 46
        /a(?=.$)/;
        iseq $#+, 0;
        iseq $#-, 0;
        iseq $+ [0], 2;
        iseq $- [0], 1;
        ok !defined $+ [1] && !defined $- [1] &&
           !defined $+ [2] && !defined $- [2];

        /a(a)(a)/;
        iseq $#+, 2;
        iseq $#-, 2;
        iseq $+ [0], 3;
        iseq $- [0], 0;
        iseq $+ [1], 2;
        iseq $- [1], 1;
        iseq $+ [2], 3;
        iseq $- [2], 2;
        ok !defined $+ [3] && !defined $- [3] &&
           !defined $+ [4] && !defined $- [4];


        /.(a)(b)?(a)/;
        iseq $#+, 3;
        iseq $#-, 3;
        iseq $+ [1], 2;
        iseq $- [1], 1;
        iseq $+ [3], 3;
        iseq $- [3], 2;
        ok !defined $+ [2] && !defined $- [2] &&
           !defined $+ [4] && !defined $- [4];


        /.(a)/;
        iseq $#+, 1;
        iseq $#-, 1;
        iseq $+ [0], 2;
        iseq $- [0], 0;
        iseq $+ [1], 2;
        iseq $- [1], 1;
        ok !defined $+ [2] && !defined $- [2] &&
           !defined $+ [3] && !defined $- [3];

        /.(a)(ba*)?/;
        iseq $#+, 2;
        iseq $#-, 1;
    }
d1695 2
d1698 3
a1700 8
    {
        local $DiePattern = '^Modification of a read-only value attempted';
        local $Message    = 'Elements of @@- and @@+ are read-only';
        must_die '$+[0] = 13';
        must_die '$-[0] = 13';
        must_die '@@+ = (7, 6, 5)';
        must_die '@@- = qw (foo bar)';
    }
d1702 2
d1705 2
a1706 14
    {
        local $Message = '\G testing';
        $_ = 'aaa';
        pos = 1;
        my @@a = /\Ga/g;
        iseq "@@a", "a a";

        my $str = 'abcde';
        pos $str = 2;
        ok $str !~ /^\G/;
        ok $str !~ /^.\G/;
        ok $str =~ /^..\G/;
        ok $str !~ /^...\G/;
        ok $str =~ /\G../ && $& eq 'cd';
d1708 3
a1710 3
        local $TODO = $running_as_thread;
        ok $str =~ /.\G./ && $& eq 'bc';
    }
d1712 2
d1715 2
a1716 63
    {
        local $Message = 'pos inside (?{ })';
        my $str = 'abcde';
        our ($foo, $bar);
        ok $str =~ /b(?{$foo = $_; $bar = pos})c/;
        iseq $foo, $str;
        iseq $bar, 2;
        ok !defined pos ($str);

        undef $foo;
        undef $bar;
        pos $str = undef;
        ok $str =~ /b(?{$foo = $_; $bar = pos})c/g;
        iseq $foo, $str;
        iseq $bar, 2;
        iseq pos ($str), 3;

        $_ = $str;
        undef $foo;
        undef $bar;
        ok /b(?{$foo = $_; $bar = pos})c/;
        iseq $foo, $str;
        iseq $bar, 2;

        undef $foo;
        undef $bar;
        ok /b(?{$foo = $_; $bar = pos})c/g;
        iseq $foo, $str;
        iseq $bar, 2;
        iseq pos, 3;

        undef $foo;
        undef $bar;
        pos = undef;
        1 while /b(?{$foo = $_; $bar = pos})c/g;
        iseq $foo, $str;
        iseq $bar, 2;
        ok !defined pos;

        undef $foo;
        undef $bar;
        $_ = 'abcde|abcde';
        ok s/b(?{$foo = $_; $bar = pos})c/x/g;
        iseq $foo, 'abcde|abcde';
        iseq $bar, 8;
        iseq $_, 'axde|axde';

        # List context:
        $_ = 'abcde|abcde';
        our @@res;
        () = /([ace]).(?{push @@res, $1,$2})([ce])(?{push @@res, $1,$2})/g;
        @@res = map {defined $_ ? "'$_'" : 'undef'} @@res;
        iseq "@@res", "'a' undef 'a' 'c' 'e' undef 'a' undef 'a' 'c'";

        @@res = ();
        () = /([ace]).(?{push @@res, $`,$&,$'})([ce])(?{push @@res, $`,$&,$'})/g;
        @@res = map {defined $_ ? "'$_'" : 'undef'} @@res;
        iseq "@@res", "'' 'ab' 'cde|abcde' " .
                     "'' 'abc' 'de|abcde' " .
                     "'abcd' 'e|' 'abcde' " .
                     "'abcde|' 'ab' 'cde' " .
                     "'abcde|' 'abc' 'de'" ;
    }
d1718 2
d1721 2
a1722 17
    {
        local $Message = '\G anchor checks';
        my $foo = 'aabbccddeeffgg';
        pos ($foo) = 1;
        {
            local $TODO = $running_as_thread;
            no warnings 'uninitialized';
            ok $foo =~ /.\G(..)/g;
            iseq $1, 'ab';

            pos ($foo) += 1;
            ok $foo =~ /.\G(..)/g;
            iseq $1, 'cc';

            pos ($foo) += 1;
            ok $foo =~ /.\G(..)/g;
            iseq $1, 'de';
d1724 2
a1725 2
            ok $foo =~ /\Gef/g;
        }
d1727 2
a1728 11
        undef pos $foo;
        ok $foo =~ /\G(..)/g;
        iseq $1, 'aa';

        ok $foo =~ /\G(..)/g;
        iseq $1, 'bb';

        pos ($foo) = 5;
        ok $foo =~ /\G(..)/g;
        iseq $1, 'cd';
    }
d1730 2
d1733 3
a1735 6
    {
        $_ = '123x123';
        my @@res = /(\d*|x)/g;
        local $" = '|';
        iseq "@@res", "123||x|123|", "0 match in alternation";
    }
d1737 5
d1743 52
a1794 6
    {
        local $Message = "Match against temporaries (created via pp_helem())" .
                         " is safe";
        ok {foo => "bar\n" . $^X} -> {foo} =~ /^(.*)\n/g;
        iseq $1, "bar";
    }
d1796 1
d1798 2
a1799 18
    {
        local $Message = 'package $i inside (?{ }), ' .
                         'saved substrings and changing $_';
        our @@a = qw [foo bar];
        our @@b = ();
        s/(\w)(?{push @@b, $1})/,$1,/g for @@a;
        iseq "@@b", "f o o b a r";
        iseq "@@a", ",f,,o,,o, ,b,,a,,r,";

        local $Message = 'lexical $i inside (?{ }), ' .
                         'saved substrings and changing $_';
        no warnings 'closure';
        my @@c = qw [foo bar];
        my @@d = ();
        s/(\w)(?{push @@d, $1})/,$1,/g for @@c;
        iseq "@@d", "f o o b a r";
        iseq "@@c", ",f,,o,,o, ,b,,a,,r,";
    }
d1801 2
d1804 2
a1805 14
    {
        local $Message = 'Brackets';
        our $brackets;
        $brackets = qr {
            {  (?> [^{}]+ | (??{ $brackets }) )* }
        }x;

        ok "{{}" =~ $brackets;
        iseq $&, "{}";
        ok "something { long { and } hairy" =~ $brackets;
        iseq $&, "{ and }";
        ok "something { long { and } hairy" =~ m/((??{ $brackets }))/;
        iseq $&, "{ and }";
    }
d1807 2
d1810 2
a1811 5
    {
        $_ = "a-a\nxbb";
        pos = 1;
        nok m/^-.*bb/mg, '$_ = "a-a\nxbb"; m/^-.*bb/mg';
    }
d1813 3
d1817 1
a1817 6
    {
        local $Message = '\G anchor checks';
        my $text = "aaXbXcc";
        pos ($text) = 0;
        ok $text !~ /\GXb*X/g;
    }
d1819 28
d1848 2
a1849 3
    {
        $_ = "xA\n" x 500;
        nok /^\s*A/m, '$_ = "xA\n" x 500; /^\s*A/m"';
d1851 2
a1852 4
        my $text = "abc dbf";
        my @@res = ($text =~ /.*?(b).*?\b/g);
        iseq "@@res", "b b", '\b is not special';
    }
d1854 2
d1857 106
a1962 57
    {
        local $Message = '\S, [\S], \s, [\s]';
        my @@a = map chr, 0 .. 255;
        my @@b = grep /\S/, @@a;
        my @@c = grep /[^\s]/, @@a;
        iseq "@@b", "@@c";

        @@b = grep /\S/, @@a;
        @@c = grep /[\S]/, @@a;
        iseq "@@b", "@@c";

        @@b = grep /\s/, @@a;
        @@c = grep /[^\S]/, @@a;
        iseq "@@b", "@@c";

        @@b = grep /\s/, @@a;
        @@c = grep /[\s]/, @@a;
        iseq "@@b", "@@c";
    }
    {
        local $Message = '\D, [\D], \d, [\d]';
        my @@a = map chr, 0 .. 255;
        my @@b = grep /\D/, @@a;
        my @@c = grep /[^\d]/, @@a;
        iseq "@@b", "@@c";

        @@b = grep /\D/, @@a;
        @@c = grep /[\D]/, @@a;
        iseq "@@b", "@@c";

        @@b = grep /\d/, @@a;
        @@c = grep /[^\D]/, @@a;
        iseq "@@b", "@@c";

        @@b = grep /\d/, @@a;
        @@c = grep /[\d]/, @@a;
        iseq "@@b", "@@c";
    }
    {
        local $Message = '\W, [\W], \w, [\w]';
        my @@a = map chr, 0 .. 255;
        my @@b = grep /\W/, @@a;
        my @@c = grep /[^\w]/, @@a;
        iseq "@@b", "@@c";

        @@b = grep /\W/, @@a;
        @@c = grep /[\W]/, @@a;
        iseq "@@b", "@@c";

        @@b = grep /\w/, @@a;
        @@c = grep /[^\W]/, @@a;
        iseq "@@b", "@@c";

        @@b = grep /\w/, @@a;
        @@c = grep /[\w]/, @@a;
        iseq "@@b", "@@c";
    }
d1964 9
d1974 2
a1975 14
    {
        # see if backtracking optimization works correctly
        local $Message = 'Backtrack optimization';
        ok "\n\n" =~ /\n   $ \n/x;
        ok "\n\n" =~ /\n*  $ \n/x;
        ok "\n\n" =~ /\n+  $ \n/x;
        ok "\n\n" =~ /\n?  $ \n/x;
        ok "\n\n" =~ /\n*? $ \n/x;
        ok "\n\n" =~ /\n+? $ \n/x;
        ok "\n\n" =~ /\n?? $ \n/x;
        ok "\n\n" !~ /\n*+ $ \n/x;
        ok "\n\n" !~ /\n++ $ \n/x;
        ok "\n\n" =~ /\n?+ $ \n/x;
    }
d1977 2
d1980 2
a1981 12
    {
        package S;
        use overload '""' => sub {'Object S'};
        sub new {bless []}
     
        local $Message  = "Ref stringification";
      ::ok do { \my $v} =~ /^SCALAR/,   "Scalar ref stringification";
      ::ok do {\\my $v} =~ /^REF/,      "Ref ref stringification";
      ::ok []           =~ /^ARRAY/,    "Array ref stringification";
      ::ok {}           =~ /^HASH/,     "Hash ref stringification";
      ::ok 'S' -> new   =~ /^Object S/, "Object stringification";
    }
d1983 2
d1986 2
a1987 7
    {
        local $Message = "Test result of match used as match";
        ok 'a1b' =~ ('xyz' =~ /y/);
        iseq $`, 'a';
        ok 'a1b' =~ ('xyz' =~ /t/);
        iseq $`, 'a';
    }
d1989 2
d1992 1
a1992 4
    {
        local $Message = '"1" is not \s';
        may_not_warn sub {ok ("1\n" x 102) !~ /^\s*\n/m};
    }
d1994 2
d1997 2
a1998 20
    {
        local $Message = '\s, [[:space:]] and [[:blank:]]';
        my %space = (spc   => " ",
                     tab   => "\t",
                     cr    => "\r",
                     lf    => "\n",
                     ff    => "\f",
        # There's no \v but the vertical tabulator seems miraculously
        # be 11 both in ASCII and EBCDIC.
                     vt    => chr(11),
                     false => "space");

        my @@space0 = sort grep {$space {$_} =~ /\s/         } keys %space;
        my @@space1 = sort grep {$space {$_} =~ /[[:space:]]/} keys %space;
        my @@space2 = sort grep {$space {$_} =~ /[[:blank:]]/} keys %space;

        iseq "@@space0", "cr ff lf spc tab";
        iseq "@@space1", "cr ff lf spc tab vt";
        iseq "@@space2", "spc tab";
    }
d2000 8
d2009 2
a2010 5
    {
        local $BugId = '20000731.001';
        ok "A \x{263a} B z C" =~ /A . B (??{ "z" }) C/,
           "Match UTF-8 char in presense of (??{ })";
    }
d2012 1
d2014 2
a2015 4
    {
        local $BugId = '20001021.005';
        no warnings 'uninitialized';
        ok undef =~ /^([^\/]*)(.*)$/, "Used to cause a SEGV";
d2018 2
d2021 3
a2023 22
  SKIP:
    {
        local $Message = '\C matches octet';
        $_ = "a\x{100}b";
        ok /(.)(\C)(\C)(.)/ or skip q [\C doesn't match], 4;
        iseq $1, "a";
        if ($IS_ASCII) {     # ASCII (or equivalent), should be UTF-8
            iseq $2, "\xC4";
            iseq $3, "\x80";
        }
        elsif ($IS_EBCDIC) { # EBCDIC (or equivalent), should be UTF-EBCDIC
            iseq $2, "\x8C";
            iseq $3, "\x41";
        }
        else {
            SKIP: {
                ok 0, "Unexpected platform", "ord ('A') = $ordA";
                skip "Unexpected platform";
            }
        }
        iseq $4, "b";
    }
d2025 4
a2029 25
  SKIP:
    {
        local $Message = '\C matches octet';
        $_ = "\x{100}";
        ok /(\C)/g or skip q [\C doesn't match], 2;
        if ($IS_ASCII) {
            iseq $1, "\xC4";
        }
        elsif ($IS_EBCDIC) {
            iseq $1, "\x8C";
        }
        else {
            ok 0, "Unexpected platform", "ord ('A') = $ordA";
        }
        ok /(\C)/g or skip q [\C doesn't match];
        if ($IS_ASCII) {
            iseq $1, "\x80";
        }
        elsif ($IS_EBCDIC) {
            iseq $1, "\x41";
        }
        else {
            ok 0, "Unexpected platform", "ord ('A') = $ordA";
        }
    }
d2031 1
d2033 3
a2035 6
    {
        # Japhy -- added 03/03/2001
        () = (my $str = "abc") =~ /(...)/;
        $str = "def";
        iseq $1, "abc", 'Changing subject does not modify $1';
    }
d2037 2
d2040 1
a2040 18
  SKIP:
    {
        # The trick is that in EBCDIC the explicit numeric range should
        # match (as also in non-EBCDIC) but the explicit alphabetic range
        # should not match.
        ok "\x8e" =~ /[\x89-\x91]/, '"\x8e" =~ /[\x89-\x91]/';
        ok "\xce" =~ /[\xc9-\xd1]/, '"\xce" =~ /[\xc9-\xd1]/';

        skip "Not an EBCDIC platform", 2 unless ord ('i') == 0x89 &&
                                                ord ('J') == 0xd1;

        # In most places these tests would succeed since \x8e does not
        # in most character sets match 'i' or 'j' nor would \xce match
        # 'I' or 'J', but strictly speaking these tests are here for
        # the good of EBCDIC, so let's test these only there.
        nok "\x8e" !~ /[i-j]/, '"\x8e" !~ /[i-j]/';
        nok "\xce" !~ /[I-J]/, '"\xce" !~ /[I-J]/';
    }
d2042 3
d2046 4
a2049 4
    {
        ok "\x{ab}"   =~ /\x{ab}/,   '"\x{ab}"   =~ /\x{ab}/  ';
        ok "\x{abcd}" =~ /\x{abcd}/, '"\x{abcd}" =~ /\x{abcd}/';
    }
d2051 2
d2054 2
a2055 2
    {
        local $Message = 'bug id 20001008.001';
d2057 2
a2058 14
        my @@x = ("stra\337e 138", "stra\337e 138");
        for (@@x) {
            ok s/(\d+)\s*([\w\-]+)/$1 . uc $2/e;
            ok my ($latin) = /^(.+)(?:\s+\d)/;
            iseq $latin, "stra\337e";
	    ok $latin =~ s/stra\337e/straße/;
            #
            # Previous code follows, but outcommented - there were no tests.
            #
            # $latin =~ s/stra\337e/straße/; # \303\237 after the 2nd a
            # use utf8; # needed for the raw UTF-8
            # $latin =~ s!(s)tr(?:aß|s+e)!$1tr.!; # \303\237 after the a
        }
    }
d2060 2
d2063 2
a2064 11
    {
        local $Message = 'Test \x escapes';
        ok "ba\xd4c" =~ /([a\xd4]+)/ && $1 eq "a\xd4";
        ok "ba\xd4c" =~ /([a\xd4]+)/ && $1 eq "a\x{d4}";
        ok "ba\x{d4}c" =~ /([a\xd4]+)/ && $1 eq "a\x{d4}";
        ok "ba\x{d4}c" =~ /([a\xd4]+)/ && $1 eq "a\xd4";
        ok "ba\xd4c" =~ /([a\x{d4}]+)/ && $1 eq "a\xd4";
        ok "ba\xd4c" =~ /([a\x{d4}]+)/ && $1 eq "a\x{d4}";
        ok "ba\x{d4}c" =~ /([a\x{d4}]+)/ && $1 eq "a\x{d4}";
        ok "ba\x{d4}c" =~ /([a\x{d4}]+)/ && $1 eq "a\xd4";
    }
d2066 2
d2069 1
a2069 2
    {
        local $BugId   = '20001028.003';
d2071 2
a2072 14
        # Fist half of the bug.
        local $Message = 'HEBREW ACCENT QADMA matched by .*';
        my $X = chr (1448);
        ok my ($Y) = $X =~ /(.*)/;
        iseq $Y, v1448;
        iseq length ($Y), 1;

        # Second half of the bug.
        $Message = 'HEBREW ACCENT QADMA in replacement';
        $X = '';
        $X =~ s/^/chr(1488)/e;
        iseq length $X, 1;
        iseq ord ($X), 1488;
    }
d2074 2
d2077 2
a2078 9
    {   
        local $BugId   = '20001108.001';
        local $Message = 'Repeated s///';
        my $X = "Szab\x{f3},Bal\x{e1}zs";
        my $Y = $X;
        $Y =~ s/(B)/$1/ for 0 .. 3;
        iseq $Y, $X;
        iseq $X, "Szab\x{f3},Bal\x{e1}zs";
    }
d2080 2
d2083 2
a2084 8
    {
        local $BugId   = '20000517.001';
        local $Message = 's/// on UTF-8 string';
        my $x = "\x{100}A";
        $x =~ s/A/B/;
        iseq $x, "\x{100}B";
        iseq length $x, 2;
    }
d2086 2
d2089 10
a2098 6
    {
        local $BugId   = '20001230.002';
        local $Message = '\C and É';
        ok "École" =~ /^\C\C(.)/ && $1 eq 'c';
        ok "École" =~ /^\C\C(c)/;
    }
d2100 2
d2103 2
a2104 10
  SKIP:
    {
        local $Message = 'Match code points > 255';
        $_ = "abc\x{100}\x{200}\x{300}\x{380}\x{400}defg";
        ok /(.\x{300})./ or skip "No match", 4;
        ok $` eq "abc\x{100}"            && length ($`) == 4;
        ok $& eq "\x{200}\x{300}\x{380}" && length ($&) == 3;
        ok $' eq "\x{400}defg"           && length ($') == 5;
        ok $1 eq "\x{200}\x{300}"        && length ($1) == 2;
    }
d2106 2
d2109 2
a2110 7
    {
        # The original bug report had 'no utf8' here but that was irrelevant.
        local $BugId   = '20010306.008';
        local $Message = "Don't dump core";
        my $a = "a\x{1234}";
        ok $a =~ m/\w/;  # used to core dump.
    }
d2112 2
d2115 2
a2116 18
    {
        local $BugId = '20010410.006';
        local $Message = '/g in scalar context';
        for my $rx ('/(.*?)\{(.*?)\}/csg',
		    '/(.*?)\{(.*?)\}/cg',
		    '/(.*?)\{(.*?)\}/sg',
		    '/(.*?)\{(.*?)\}/g',
		    '/(.+?)\{(.+?)\}/csg',) {
            my $i = 0;
            my $input = "a{b}c{d}";
            eval <<"            --";
                while (eval \$input =~ $rx) {
                    \$i ++;
                }
            --
            iseq $i, 2;
        }
    }
d2118 1
d2120 2
a2121 5
    {
        my $x = "\x{10FFFD}";
        $x =~ s/(.)/$1/g;
        ok ord($x) == 0x10FFFD && length($x) == 1, "From Robin Houston";
    }
d2123 2
d2126 2
a2127 17
    {
        my %d = (
            "7f" => [0, 0, 0],
            "80" => [1, 1, 0],
            "ff" => [1, 1, 0],
           "100" => [0, 1, 1],
        );
      SKIP:
        while (my ($code, $match) = each %d) {
            local $Message = "Properties of \\x$code";
            my $char = eval qq ["\\x{$code}"];
            my $i = 0;
            ok (($char =~ /[\x80-\xff]/)            xor !$$match [$i ++]);
            ok (($char =~ /[\x80-\x{100}]/)         xor !$$match [$i ++]);
            ok (($char =~ /[\x{100}]/)              xor !$$match [$i ++]);
        }
    }
d2129 2
d2132 2
a2133 18
    {
        # From Japhy
        local $Message;
        must_warn 'qr/(?c)/',    '^Useless \(\?c\)';
        must_warn 'qr/(?-c)/',   '^Useless \(\?-c\)';
        must_warn 'qr/(?g)/',    '^Useless \(\?g\)';
        must_warn 'qr/(?-g)/',   '^Useless \(\?-g\)';
        must_warn 'qr/(?o)/',    '^Useless \(\?o\)';
        must_warn 'qr/(?-o)/',   '^Useless \(\?-o\)';

        # Now test multi-error regexes
        must_warn 'qr/(?g-o)/',  '^Useless \(\?g\).*\nUseless \(\?-o\)';
        must_warn 'qr/(?g-c)/',  '^Useless \(\?g\).*\nUseless \(\?-c\)';
        # (?c) means (?g) error won't be thrown
        must_warn 'qr/(?o-cg)/', '^Useless \(\?o\).*\nUseless \(\?-c\)';
        must_warn 'qr/(?ogc)/',  '^Useless \(\?o\).*\nUseless \(\?g\).*\n' .
                                  'Useless \(\?c\)';
    }
d2135 2
d2138 3
a2140 18
    {
        local $Message = "/x tests";
        $_ = "foo";
        eval_ok <<"        --";
          /f
           o\r
           o
           \$
          /x
        --
        eval_ok <<"        --";
          /f
           o
           o
           \$\r
          /x
        --
    }
d2142 6
d2149 1
a2149 6
    {
        local $Message = "/o feature";
        sub test_o {$_ [0] =~ /$_[1]/o; return $1}
        iseq test_o ('abc', '(.)..'), 'a';
        iseq test_o ('abc', '..(.)'), 'a';
    }
d2151 14
d2166 3
a2168 10
    {
        local $BugId = "20010619.003";
        # Amazingly vertical tabulator is the same in ASCII and EBCDIC.
        for ("\n", "\t", "\014", "\r") {
            ok !/[[:print:]]/, "'$_' not in [[:print:]]";
        }
        for (" ") {
            ok  /[[:print:]]/, "'$_' in [[:print:]]";
        }
    }
d2170 2
d2173 2
a2174 33
    {
        # Test basic $^N usage outside of a regex
        local $Message = '$^N usage outside of a regex';
        my $x = "abcdef";
        ok ($x =~ /cde/                  and !defined $^N);
        ok ($x =~ /(cde)/                and $^N eq "cde");
        ok ($x =~ /(c)(d)(e)/            and $^N eq   "e");
        ok ($x =~ /(c(d)e)/              and $^N eq "cde");
        ok ($x =~ /(foo)|(c(d)e)/        and $^N eq "cde");
        ok ($x =~ /(c(d)e)|(foo)/        and $^N eq "cde");
        ok ($x =~ /(c(d)e)|(abc)/        and $^N eq "abc");
        ok ($x =~ /(c(d)e)|(abc)x/       and $^N eq "cde");
        ok ($x =~ /(c(d)e)(abc)?/        and $^N eq "cde");
        ok ($x =~ /(?:c(d)e)/            and $^N eq   "d");
        ok ($x =~ /(?:c(d)e)(?:f)/       and $^N eq   "d");
        ok ($x =~ /(?:([abc])|([def]))*/ and $^N eq   "f");
        ok ($x =~ /(?:([ace])|([bdf]))*/ and $^N eq   "f");
        ok ($x =~ /(([ace])|([bd]))*/    and $^N eq   "e");
       {ok ($x =~ /(([ace])|([bdf]))*/   and $^N eq   "f");}
        ## Test to see if $^N is automatically localized -- it should now
        ## have the value set in the previous test.
        iseq $^N, "e", '$^N is automatically localized';

        # Now test inside (?{ ... })
        local $Message = '$^N usage inside (?{ ... })';
        our ($y, $z);
        ok ($x =~ /a([abc])(?{$y=$^N})c/                    and $y eq  "b");
        ok ($x =~ /a([abc]+)(?{$y=$^N})d/                   and $y eq  "bc");
        ok ($x =~ /a([abcdefg]+)(?{$y=$^N})d/               and $y eq  "bc");
        ok ($x =~ /(a([abcdefg]+)(?{$y=$^N})d)(?{$z=$^N})e/ and $y eq  "bc"
                                                            and $z eq "abcd");
        ok ($x =~ /(a([abcdefg]+)(?{$y=$^N})de)(?{$z=$^N})/ and $y eq  "bc"
                                                            and $z eq "abcde");
d2176 2
a2177 1
    }
d2179 2
d2182 2
a2183 4
  SKIP:
    {
        ## Should probably put in tests for all the POSIX stuff,
        ## but not sure how to guarantee a specific locale......
d2185 2
a2186 5
        skip "Not an ASCII platform", 2 unless $IS_ASCII;
        local $Message = 'Test [[:cntrl:]]';
        my $AllBytes = join "" => map {chr} 0 .. 255;
        (my $x = $AllBytes) =~ s/[[:cntrl:]]//g;
        iseq $x, join "", map {chr} 0x20 .. 0x7E, 0x80 .. 0xFF;
d2188 2
a2189 3
        ($x = $AllBytes) =~ s/[^[:cntrl:]]//g;
        iseq $x, join "", map {chr} 0x00 .. 0x1F, 0x7F;
    }
d2191 2
d2194 2
a2195 7
    {
        # With /s modifier UTF8 chars were interpreted as bytes
        local $Message = "UTF-8 chars aren't bytes";
        my $a = "Hello \x{263A} World";
        my @@a = ($a =~ /./gs);
        iseq $#a, 12;
    }
d2197 2
d2200 2
a2201 15
    {
        local $Message = '. matches \n with /s';
        my $str1 = "foo\nbar";
        my $str2 = "foo\n\x{100}bar";
        my ($a, $b) = map {chr} $IS_ASCII ? (0xc4, 0x80) : (0x8c, 0x41);
        my @@a;
        @@a = $str1 =~ /./g;   iseq @@a, 6; iseq "@@a", "f o o b a r";
        @@a = $str1 =~ /./gs;  iseq @@a, 7; iseq "@@a", "f o o \n b a r";
        @@a = $str1 =~ /\C/g;  iseq @@a, 7; iseq "@@a", "f o o \n b a r";
        @@a = $str1 =~ /\C/gs; iseq @@a, 7; iseq "@@a", "f o o \n b a r";
        @@a = $str2 =~ /./g;   iseq @@a, 7; iseq "@@a", "f o o \x{100} b a r";
        @@a = $str2 =~ /./gs;  iseq @@a, 8; iseq "@@a", "f o o \n \x{100} b a r";
        @@a = $str2 =~ /\C/g;  iseq @@a, 9; iseq "@@a", "f o o \n $a $b b a r";
        @@a = $str2 =~ /\C/gs; iseq @@a, 9; iseq "@@a", "f o o \n $a $b b a r";
    }
d2203 2
d2206 2
a2207 9
    {
        # [ID 20010814.004] pos() doesn't work when using =~m// in list context
        local $BugId = '20010814.004';
        $_ = "ababacadaea";
        my $a = join ":", /b./gc;
        my $b = join ":", /a./gc;
        my $c = pos;
        iseq "$a $b $c", 'ba:ba ad:ae 10', "pos() works with () = m//";
    }
d2209 2
d2212 2
a2213 16
    {
        # [ID 20010407.006] matching utf8 return values from
        # functions does not work
        local $BugId   = '20010407.006';
        local $Message = 'UTF-8 return values from functions';
        package ID_20010407_006;
        sub x {"a\x{1234}"}
        my $x = x;
        my $y;
      ::ok $x =~ /(..)/;
        $y = $1;
      ::ok length ($y) == 2 && $y eq $x;
      ::ok x =~ /(..)/;
        $y = $1;
      ::ok length ($y) == 2 && $y eq $x;
    }
d2215 2
d2218 2
a2219 6
    {
        no warnings 'digit';
        # Check that \x## works. 5.6.1 and 5.005_03 fail some of these.
        my $x;
        $x = "\x4e" . "E";
        ok ($x =~ /^\x4EE$/, "Check only 2 bytes of hex are matched.");
d2221 2
a2222 2
        $x = "\x4e" . "i";
        ok ($x =~ /^\x4Ei$/, "Check that invalid hex digit stops it (2)");
d2224 2
a2225 2
        $x = "\x4" . "j";
        ok ($x =~ /^\x4j$/,  "Check that invalid hex digit stops it (1)");
d2227 1
a2227 2
        $x = "\x0" . "k";
        ok ($x =~ /^\xk$/,   "Check that invalid hex digit stops it (0)");
d2229 3
a2231 2
        $x = "\x0" . "x";
        ok ($x =~ /^\xx$/, "\\xx isn't to be treated as \\0");
d2233 3
a2235 2
        $x = "\x0" . "xa";
        ok ($x =~ /^\xxa$/, "\\xxa isn't to be treated as \\xa");
d2237 3
a2239 2
        $x = "\x9" . "_b";
        ok ($x =~ /^\x9_b$/, "\\x9_b isn't to be treated as \\x9b");
d2241 3
a2243 1
        # and now again in [] ranges
d2245 4
a2248 2
        $x = "\x4e" . "E";
        ok ($x =~ /^[\x4EE]{2}$/, "Check only 2 bytes of hex are matched.");
d2250 3
a2252 2
        $x = "\x4e" . "i";
        ok ($x =~ /^[\x4Ei]{2}$/, "Check that invalid hex digit stops it (2)");
d2254 3
a2256 2
        $x = "\x4" . "j";
        ok ($x =~ /^[\x4j]{2}$/,  "Check that invalid hex digit stops it (1)");
d2258 3
a2260 2
        $x = "\x0" . "k";
        ok ($x =~ /^[\xk]{2}$/,   "Check that invalid hex digit stops it (0)");
d2262 4
a2265 2
        $x = "\x0" . "x";
        ok ($x =~ /^[\xx]{2}$/, "\\xx isn't to be treated as \\0");
d2267 2
a2268 2
        $x = "\x0" . "xa";
        ok ($x =~ /^[\xxa]{3}$/, "\\xxa isn't to be treated as \\xa");
d2270 2
a2271 2
        $x = "\x9" . "_b";
        ok ($x =~ /^[\x9_b]{3}$/, "\\x9_b isn't to be treated as \\x9b");
d2273 2
a2274 1
        # Check that \x{##} works. 5.6.1 fails quite a few of these.
d2276 3
a2278 2
        $x = "\x9b";
        ok ($x =~ /^\x{9_b}$/, "\\x{9_b} is to be treated as \\x9b");
d2280 2
a2281 2
        $x = "\x9b" . "y";
        ok ($x =~ /^\x{9_b}y$/, "\\x{9_b} is to be treated as \\x9b (again)");
d2283 12
a2294 2
        $x = "\x9b" . "y";
        ok ($x =~ /^\x{9b_}y$/, "\\x{9b_} is to be treated as \\x9b");
d2296 2
a2297 2
        $x = "\x9b" . "y";
        ok ($x =~ /^\x{9_bq}y$/, "\\x{9_bc} is to be treated as \\x9b");
d2299 2
a2300 2
        $x = "\x0" . "y";
        ok ($x =~ /^\x{x9b}y$/, "\\x{x9b} is to be treated as \\x0");
d2302 2
a2303 2
        $x = "\x0" . "y";
        ok ($x =~ /^\x{0x9b}y$/, "\\x{0x9b} is to be treated as \\x0");
d2305 2
a2306 2
        $x = "\x9b" . "y";
        ok ($x =~ /^\x{09b}y$/, "\\x{09b} is to be treated as \\x9b");
d2308 2
a2309 2
        $x = "\x9b";
        ok ($x =~ /^[\x{9_b}]$/, "\\x{9_b} is to be treated as \\x9b");
d2311 2
a2312 3
        $x = "\x9b" . "y";
        ok ($x =~ /^[\x{9_b}y]{2}$/,
                                 "\\x{9_b} is to be treated as \\x9b (again)");
d2314 2
a2315 2
        $x = "\x9b" . "y";
        ok ($x =~ /^[\x{9b_}y]{2}$/, "\\x{9b_} is to be treated as \\x9b");
d2317 2
a2318 2
        $x = "\x9b" . "y";
        ok ($x =~ /^[\x{9_bq}y]{2}$/, "\\x{9_bc} is to be treated as \\x9b");
d2320 2
a2321 2
        $x = "\x0" . "y";
        ok ($x =~ /^[\x{x9b}y]{2}$/, "\\x{x9b} is to be treated as \\x0");
d2323 2
a2324 2
        $x = "\x0" . "y";
        ok ($x =~ /^[\x{0x9b}y]{2}$/, "\\x{0x9b} is to be treated as \\x0");
d2326 2
a2327 2
        $x = "\x9b" . "y";
        ok ($x =~ /^[\x{09b}y]{2}$/, "\\x{09b} is to be treated as \\x9b");
d2329 2
a2330 1
    }
d2332 2
d2335 2
a2336 5
    {
        # High bit bug -- japhy
        my $x = "ab\200d";
        ok $x =~ /.*?\200/, "High bit fine";
    }
d2338 2
d2341 2
a2342 6
    {
        # The basic character classes and Unicode
        ok "\x{0100}" =~ /\w/, 'LATIN CAPITAL LETTER A WITH MACRON in /\w/';
        ok "\x{0660}" =~ /\d/, 'ARABIC-INDIC DIGIT ZERO in /\d/';
        ok "\x{1680}" =~ /\s/, 'OGHAM SPACE MARK in /\s/';
    }
d2344 2
d2347 2
a2348 23
    {
        local $Message = "Folding matches and Unicode";
        ok "a\x{100}" =~ /A/i;
        ok "A\x{100}" =~ /a/i;
        ok "a\x{100}" =~ /a/i;
        ok "A\x{100}" =~ /A/i;
        ok "\x{101}a" =~ /\x{100}/i;
        ok "\x{100}a" =~ /\x{100}/i;
        ok "\x{101}a" =~ /\x{101}/i;
        ok "\x{100}a" =~ /\x{101}/i;
        ok "a\x{100}" =~ /A\x{100}/i;
        ok "A\x{100}" =~ /a\x{100}/i;
        ok "a\x{100}" =~ /a\x{100}/i;
        ok "A\x{100}" =~ /A\x{100}/i;
        ok "a\x{100}" =~ /[A]/i;
        ok "A\x{100}" =~ /[a]/i;
        ok "a\x{100}" =~ /[a]/i;
        ok "A\x{100}" =~ /[A]/i;
        ok "\x{101}a" =~ /[\x{100}]/i;
        ok "\x{100}a" =~ /[\x{100}]/i;
        ok "\x{101}a" =~ /[\x{101}]/i;
        ok "\x{100}a" =~ /[\x{101}]/i;
    }
d2350 2
d2353 2
a2354 3
    {
        use charnames ':full';
        local $Message = "Folding 'LATIN LETTER A WITH GRAVE'";
d2356 2
a2357 28
        my $lower = "\N{LATIN SMALL LETTER A WITH GRAVE}";
        my $UPPER = "\N{LATIN CAPITAL LETTER A WITH GRAVE}";
        
        ok $lower =~ m/$UPPER/i;
        ok $UPPER =~ m/$lower/i;
        ok $lower =~ m/[$UPPER]/i;
        ok $UPPER =~ m/[$lower]/i;

        local $Message = "Folding 'GREEK LETTER ALPHA WITH VRACHY'";

        $lower = "\N{GREEK CAPITAL LETTER ALPHA WITH VRACHY}";
        $UPPER = "\N{GREEK SMALL LETTER ALPHA WITH VRACHY}";

        ok $lower =~ m/$UPPER/i;
        ok $UPPER =~ m/$lower/i;
        ok $lower =~ m/[$UPPER]/i;
        ok $UPPER =~ m/[$lower]/i;

        local $Message = "Folding 'LATIN LETTER Y WITH DIAERESIS'";

        $lower = "\N{LATIN SMALL LETTER Y WITH DIAERESIS}";
        $UPPER = "\N{LATIN CAPITAL LETTER Y WITH DIAERESIS}";

        ok $lower =~ m/$UPPER/i;
        ok $UPPER =~ m/$lower/i;
        ok $lower =~ m/[$UPPER]/i;
        ok $UPPER =~ m/[$lower]/i;
    }
d2359 1
d2361 2
a2362 5
    {
        use charnames ':full';
        local $PatchId = "13843";
        local $Message = "GREEK CAPITAL LETTER SIGMA vs " .
                         "COMBINING GREEK PERISPOMENI";
d2364 28
a2391 2
        my $SIGMA = "\N{GREEK CAPITAL LETTER SIGMA}";
        my $char  = "\N{COMBINING GREEK PERISPOMENI}";
d2393 5
a2397 2
        may_not_warn sub {ok "_:$char:_" !~ m/_:$SIGMA:_/i};
    }
d2399 2
d2402 3
a2404 3
    {
        local $Message = '\X';
        use charnames ':full';
d2406 2
a2407 14
        ok "a!"                          =~ /^(\X)!/ && $1 eq "a";
        ok "\xDF!"                       =~ /^(\X)!/ && $1 eq "\xDF";
        ok "\x{100}!"                    =~ /^(\X)!/ && $1 eq "\x{100}";
        ok "\x{100}\x{300}!"             =~ /^(\X)!/ && $1 eq "\x{100}\x{300}";
        ok "\N{LATIN CAPITAL LETTER E}!" =~ /^(\X)!/ &&
               $1 eq "\N{LATIN CAPITAL LETTER E}";
        ok "\N{LATIN CAPITAL LETTER E}\N{COMBINING GRAVE ACCENT}!"
                                         =~ /^(\X)!/ &&
               $1 eq "\N{LATIN CAPITAL LETTER E}\N{COMBINING GRAVE ACCENT}";

        local $Message = '\C and \X';
        ok "!abc!" =~ /a\Cc/;
        ok "!abc!" =~ /a\Xc/;
    }
d2409 1
d2411 16
a2426 2
    {
        local $Message = "Final Sigma";
d2428 2
a2429 19
        my $SIGMA = "\x{03A3}"; # CAPITAL
        my $Sigma = "\x{03C2}"; # SMALL FINAL
        my $sigma = "\x{03C3}"; # SMALL

        ok $SIGMA =~ /$SIGMA/i;
        ok $SIGMA =~ /$Sigma/i;
        ok $SIGMA =~ /$sigma/i;

        ok $Sigma =~ /$SIGMA/i;
        ok $Sigma =~ /$Sigma/i;
        ok $Sigma =~ /$sigma/i;

        ok $sigma =~ /$SIGMA/i;
        ok $sigma =~ /$Sigma/i;
        ok $sigma =~ /$sigma/i;
        
        ok $SIGMA =~ /[$SIGMA]/i;
        ok $SIGMA =~ /[$Sigma]/i;
        ok $SIGMA =~ /[$sigma]/i;
d2431 3
a2433 3
        ok $Sigma =~ /[$SIGMA]/i;
        ok $Sigma =~ /[$Sigma]/i;
        ok $Sigma =~ /[$sigma]/i;
d2435 2
a2436 3
        ok $sigma =~ /[$SIGMA]/i;
        ok $sigma =~ /[$Sigma]/i;
        ok $sigma =~ /[$sigma]/i;
d2438 28
a2465 1
        local $Message = "More final Sigma";
d2467 2
a2468 1
        my $S3 = "$SIGMA$Sigma$sigma";
d2470 1
a2470 3
        ok ":$S3:" =~ /:(($SIGMA)+):/i   && $1 eq $S3 && $2 eq $sigma;
        ok ":$S3:" =~ /:(($Sigma)+):/i   && $1 eq $S3 && $2 eq $sigma;
        ok ":$S3:" =~ /:(($sigma)+):/i   && $1 eq $S3 && $2 eq $sigma;
d2472 64
a2535 4
        ok ":$S3:" =~ /:(([$SIGMA])+):/i && $1 eq $S3 && $2 eq $sigma;
        ok ":$S3:" =~ /:(([$Sigma])+):/i && $1 eq $S3 && $2 eq $sigma;
        ok ":$S3:" =~ /:(([$sigma])+):/i && $1 eq $S3 && $2 eq $sigma;
    }
d2537 2
d2541 8
a2548 36
        use charnames ':full';
        local $Message = "Parlez-Vous " .
                         "Fran\N{LATIN SMALL LETTER C WITH CEDILLA}ais?";

        ok "Fran\N{LATIN SMALL LETTER C}ais" =~ /Fran.ais/ &&
            $& eq "Francais";
        ok "Fran\N{LATIN SMALL LETTER C WITH CEDILLA}ais" =~ /Fran.ais/ &&
            $& eq "Fran\N{LATIN SMALL LETTER C WITH CEDILLA}ais";
        ok "Fran\N{LATIN SMALL LETTER C}ais" =~ /Fran\Cais/ &&
            $& eq "Francais";
        # COMBINING CEDILLA is two bytes when encoded
        ok "Franc\N{COMBINING CEDILLA}ais" =~ /Franc\C\Cais/;
        ok "Fran\N{LATIN SMALL LETTER C}ais" =~ /Fran\Xais/ &&
            $& eq "Francais";
        ok "Fran\N{LATIN SMALL LETTER C WITH CEDILLA}ais" =~ /Fran\Xais/  &&
            $& eq "Fran\N{LATIN SMALL LETTER C WITH CEDILLA}ais";
        ok "Franc\N{COMBINING CEDILLA}ais" =~ /Fran\Xais/ &&
            $& eq "Franc\N{COMBINING CEDILLA}ais";
        ok "Fran\N{LATIN SMALL LETTER C WITH CEDILLA}ais" =~
           /Fran\N{LATIN SMALL LETTER C WITH CEDILLA}ais/  &&
            $& eq "Fran\N{LATIN SMALL LETTER C WITH CEDILLA}ais";
        ok "Franc\N{COMBINING CEDILLA}ais" =~ /Franc\N{COMBINING CEDILLA}ais/ &&
            $& eq "Franc\N{COMBINING CEDILLA}ais";

        my @@f = (
            ["Fran\N{LATIN SMALL LETTER C}ais",                    "Francais"],
            ["Fran\N{LATIN SMALL LETTER C WITH CEDILLA}ais",
                               "Fran\N{LATIN SMALL LETTER C WITH CEDILLA}ais"],
            ["Franc\N{COMBINING CEDILLA}ais", "Franc\N{COMBINING CEDILLA}ais"],
        );
        foreach my $entry (@@f) {
            my ($subject, $match) = @@$entry;
            ok $subject =~ /Fran(?:c\N{COMBINING CEDILLA}?|
                    \N{LATIN SMALL LETTER C WITH CEDILLA})ais/x &&
               $& eq $match;
        }
a2550 1

d2552 8
a2559 16
        local $Message = "Lingering (and useless) UTF8 flag doesn't mess up /i";
        my $pat = "ABcde";
        my $str = "abcDE\x{100}";
        chop $str;
        ok $str =~ /$pat/i;

        $pat = "ABcde\x{100}";
        $str = "abcDE";
        chop $pat;
        ok $str =~ /$pat/i;

        $pat = "ABcde\x{100}";
        $str = "abcDE\x{100}";
        chop $pat;
        chop $str;
        ok $str =~ /$pat/i;
a2561 1

d2563 9
a2571 28
        use charnames ':full';
        local $Message = "LATIN SMALL LETTER SHARP S " .
                         "(\N{LATIN SMALL LETTER SHARP S})";

        ok "\N{LATIN SMALL LETTER SHARP S}" =~
                                            /\N{LATIN SMALL LETTER SHARP S}/;
        ok "\N{LATIN SMALL LETTER SHARP S}" =~
                                            /\N{LATIN SMALL LETTER SHARP S}/i;
        ok "\N{LATIN SMALL LETTER SHARP S}" =~
                                           /[\N{LATIN SMALL LETTER SHARP S}]/;
        ok "\N{LATIN SMALL LETTER SHARP S}" =~
                                           /[\N{LATIN SMALL LETTER SHARP S}]/i;

        ok "ss" =~  /\N{LATIN SMALL LETTER SHARP S}/i;
        ok "SS" =~  /\N{LATIN SMALL LETTER SHARP S}/i;
        ok "ss" =~ /[\N{LATIN SMALL LETTER SHARP S}]/i;
        ok "SS" =~ /[\N{LATIN SMALL LETTER SHARP S}]/i;

        ok "\N{LATIN SMALL LETTER SHARP S}" =~ /ss/i;
        ok "\N{LATIN SMALL LETTER SHARP S}" =~ /SS/i;
 
        local $Message = "Unoptimized named sequence in class";
        ok "ss" =~ /[\N{LATIN SMALL LETTER SHARP S}x]/i;
        ok "SS" =~ /[\N{LATIN SMALL LETTER SHARP S}x]/i;
        ok "\N{LATIN SMALL LETTER SHARP S}" =~
          /[\N{LATIN SMALL LETTER SHARP S}x]/;
        ok "\N{LATIN SMALL LETTER SHARP S}" =~
          /[\N{LATIN SMALL LETTER SHARP S}x]/i;
d2573 1
d2575 2
d2578 20
a2597 2
    {
        # More whitespace: U+0085, U+2028, U+2029\n";
d2599 2
a2600 24
        # U+0085, U+00A0 need to be forced to be Unicode, the \x{100} does that.
      SKIP: {
          skip "EBCDIC platform", 4 if $IS_EBCDIC;
          # Do \x{0015} and \x{0041} match \s in EBCDIC?
          ok "<\x{100}\x{0085}>" =~ /<\x{100}\s>/, '\x{0085} in \s';
          ok        "<\x{0085}>" =~        /<\v>/, '\x{0085} in \v';
          ok "<\x{100}\x{00A0}>" =~ /<\x{100}\s>/, '\x{00A0} in \s';
          ok        "<\x{00A0}>" =~        /<\h>/, '\x{00A0} in \h';
        }
        my @@h = map {sprintf "%05x" => $_} 0x01680, 0x0180E, 0x02000 .. 0x0200A,
                                           0x0202F, 0x0205F, 0x03000;
        my @@v = map {sprintf "%05x" => $_} 0x02028, 0x02029;

        my @@H = map {sprintf "%05x" => $_} 0x01361,   0x0200B, 0x02408, 0x02420,
                                           0x0303F,   0xE0020;
        my @@V = map {sprintf "%05x" => $_} 0x0008A .. 0x0008D, 0x00348, 0x10100,
                                           0xE005F,   0xE007C;

        for my $hex (@@h) {
            my $str = eval qq ["<\\x{$hex}>"];
            ok $str =~ /<\s>/, "\\x{$hex} in \\s";
            ok $str =~ /<\h>/, "\\x{$hex} in \\h";
            ok $str !~ /<\v>/, "\\x{$hex} not in \\v";
        }
d2602 1
a2602 6
        for my $hex (@@v) {
            my $str = eval qq ["<\\x{$hex}>"];
            ok $str =~ /<\s>/, "\\x{$hex} in \\s";
            ok $str =~ /<\v>/, "\\x{$hex} in \\v";
            ok $str !~ /<\h>/, "\\x{$hex} not in \\h";
        }
d2604 1
a2604 5
        for my $hex (@@H) {
            my $str = eval qq ["<\\x{$hex}>"];
            ok $str =~ /<\S>/, "\\x{$hex} in \\S";
            ok $str =~ /<\H>/, "\\x{$hex} in \\H";
        }
d2606 2
a2607 6
        for my $hex (@@V) {
            my $str = eval qq ["<\\x{$hex}>"];
            ok $str =~ /<\S>/, "\\x{$hex} in \\S";
            ok $str =~ /<\V>/, "\\x{$hex} in \\V";
        }
    }
d2609 2
d2612 4
a2615 3
    {
        # . with /s should work on characters, as opposed to bytes
        local $Message = ". with /s works on characters, not bytes";
d2617 3
a2619 17
        my $s = "\x{e4}\x{100}";
        # This is not expected to match: the point is that
        # neither should we get "Malformed UTF-8" warnings.
        may_not_warn sub {$s =~ /\G(.+?)\n/gcs}, "No 'Malformed UTF-8' warning";

        my @@c;
        push @@c => $1 while $s =~ /\G(.)/gs;

        local $" = "";
        iseq "@@c", $s;

        # Test only chars < 256
        my $t1 = "Q003\n\n\x{e4}\x{f6}\n\nQ004\n\n\x{e7}";
        my $r1 = "";
        while ($t1 =~ / \G ( .+? ) \n\s+ ( .+? ) ( $ | \n\s+ ) /xgcs) {
	    $r1 .= $1 . $2;
        }
d2621 2
a2622 6
        my $t2 = $t1 . "\x{100}"; # Repeat with a larger char
        my $r2 = "";
        while ($t2 =~ / \G ( .+? ) \n\s+ ( .+? ) ( $ | \n\s+ ) /xgcs) {
	    $r2 .= $1 . $2;
        }
        $r2 =~ s/\x{100}//;
d2624 5
a2628 1
        iseq $r1, $r2;
d2630 6
d2637 1
d2639 9
a2647 10
    {
        local $Message = "Unicode lookbehind";
        ok "A\x{100}B"        =~ /(?<=A.)B/;
        ok "A\x{200}\x{300}B" =~ /(?<=A..)B/;
        ok "\x{400}AB"        =~ /(?<=\x{400}.)B/;
        ok "\x{500}\x{600}B"  =~ /(?<=\x{500}.)B/;

        # Original code also contained:
        # ok "\x{500\x{600}}B"  =~ /(?<=\x{500}.)B/;
        # but that looks like a typo.
d2650 1
d2652 4
a2655 14
    {
        local $Message = 'UTF-8 hash keys and /$/';
        # http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters
        #                                         /2002-01/msg01327.html

        my $u = "a\x{100}";
        my $v = substr ($u, 0, 1);
        my $w = substr ($u, 1, 1);
        my %u = ($u => $u, $v => $v, $w => $w);
        for (keys %u) {
            my $m1 =            /^\w*$/ ? 1 : 0;
            my $m2 = $u {$_} =~ /^\w*$/ ? 1 : 0;
            iseq $m1, $m2;
        }
d2658 8
d2667 2
a2668 14
    {
        local $BugId   = "20020124.005";
        local $PatchId = "14795";
        local $Message = "s///eg";

        for my $char ("a", "\x{df}", "\x{100}") {
            my $x = "$char b $char";
            $x =~ s{($char)}{
                  "c" =~ /c/;
                  "x";
            }ge;
            iseq substr ($x, 0, 1), substr ($x, -1, 1);
        }
    }
d2670 5
d2676 14
a2689 10
    {
        local $Message = "No SEGV in s/// and UTF-8";
        my $s = "s#\x{100}" x 4;
        ok $s =~ s/[^\w]/ /g;
        if ($ENV {REAL_POSIX_CC}) {
            iseq $s, "s  " x 4;
        }
        else {
            iseq $s, "s \x{100}" x 4;
        }
d2691 1
d2693 15
d2709 6
a2714 9
    {
        local $Message = "UTF-8 bug (maybe already known?)";
        my $u = "foo";
        $u =~ s/./\x{100}/g;
        iseq $u, "\x{100}\x{100}\x{100}";

        $u = "foobar";
        $u =~ s/[ao]/\x{100}/g;
        iseq $u, "f\x{100}\x{100}b\x{100}r";
d2716 11
a2726 3
        $u =~ s/\x{100}/e/g;
        iseq $u, "feeber";
    }
d2728 3
d2732 39
a2770 29
    {
        local $Message = "UTF-8 bug with s///";
        # check utf8/non-utf8 mixtures
        # try to force all float/anchored check combinations

        my $c = "\x{100}";
        my $subst;
        for my $re ("xx.*$c", "x.*$c$c", "$c.*xx", "$c$c.*x",
                    "xx.*(?=$c)", "(?=$c).*xx",) {
            ok "xxx" !~ /$re/;
            ok +($subst = "xxx") !~ s/$re//;
        }
        for my $re ("xx.*$c*", "$c*.*xx") {
            ok "xxx" =~ /$re/;
            ok +($subst = "xxx") =~ s/$re//;
            iseq $subst, "";
        }
        for my $re ("xxy*", "y*xx") {
            ok "xx$c" =~ /$re/;
            ok +($subst = "xx$c") =~ s/$re//;
            iseq $subst, $c;
            ok "xy$c" !~ /$re/;
            ok +($subst = "xy$c") !~ s/$re//;
        }
        for my $re ("xy$c*z", "x$c*yz") {
            ok "xyz" =~ /$re/;
            ok +($subst = "xyz") =~ s/$re//;
            iseq $subst, "";
        }
d2772 1
d2774 3
d2778 1
a2778 9
    {
        local $Message = "qr /.../x";
        my $R = qr / A B C # D E/x;
        ok "ABCDE" =~    $R   && $& eq "ABC";
        ok "ABCDE" =~   /$R/  && $& eq "ABC";
        ok "ABCDE" =~  m/$R/  && $& eq "ABC";
        ok "ABCDE" =~  /($R)/ && $1 eq "ABC";
        ok "ABCDE" =~ m/($R)/ && $1 eq "ABC";
    }
d2780 2
d2783 2
a2784 3
    {
        local $BugId = "20020412.005";
        local $Message = "Correct pmop flags checked when empty pattern";
d2786 3
a2788 14
        # Requires reuse of last successful pattern.
        my $num = 123;
        $num =~ /\d/;
        for (0 .. 1) {
            my $match = ?? + 0;
            ok $match != $_, $Message, 
                sprintf "'match one' %s on %s iteration" =>
                               $match ? 'succeeded' : 'failed',
                               $_     ? 'second'    : 'first';
        }
        $num =~ /(\d)/;
        my $result = join "" => $num =~ //g;
        iseq $result, $num;
    }
d2790 3
d2794 2
a2795 14
    {
        local $BugId   = '20020630.002';
        local $Message = 'UTF-8 regex matches above 32k';
        for (['byte', "\x{ff}"], ['utf8', "\x{1ff}"]) {
            my ($type, $char) = @@$_;
            for my $len (32000, 32768, 33000) {
                my  $s = $char . "f" x $len;
                my  $r = $s =~ /$char([f]*)/gc;
                ok  $r, $Message, "<$type x $len>";
                ok !$r || pos ($s) == $len + 1, $Message,
                        "<$type x $len>; pos = @@{[pos $s]}";
            }
        }
    }
d2797 3
d2801 21
a2821 37
    {
        our $a = bless qr /foo/ => 'Foo';
        ok 'goodfood' =~ $a,     "Reblessed qr // matches";
        iseq $a, '(?-xism:foo)', "Reblessed qr // stringifies";
        my $x = "\x{3fe}";
        my $z = my $y = "\317\276";  # Byte representation of $x
        $a = qr /$x/;
        ok $x =~ $a, "UTF-8 interpolation in qr //";
        ok "a$a" =~ $x, "Stringified qr // preserves UTF-8";
        ok "a$x" =~ /^a$a\z/, "Interpolated qr // preserves UTF-8";
        ok "a$x" =~ /^a(??{$a})\z/,
                        "Postponed interpolation of qr // preserves UTF-8";
        {
            local $BugId = '17776';
            iseq length qr /##/x, 12, "## in qr // doesn't corrupt memory";
        }
        {
            use re 'eval';
            ok "$x$x" =~ /^$x(??{$x})\z/,
               "Postponed UTF-8 string in UTF-8 re matches UTF-8";
            ok "$y$x" =~ /^$y(??{$x})\z/, 
               "Postponed UTF-8 string in non-UTF-8 re matches UTF-8";
            ok "$y$x" !~ /^$y(??{$y})\z/,
               "Postponed non-UTF-8 string in non-UTF-8 re doesn't match UTF-8";
            ok "$x$x" !~ /^$x(??{$y})\z/,
               "Postponed non-UTF-8 string in UTF-8 re doesn't match UTF-8";
            ok "$y$y" =~ /^$y(??{$y})\z/,
               "Postponed non-UTF-8 string in non-UTF-8 re matches non-UTF8";
            ok "$x$y" =~ /^$x(??{$y})\z/,
               "Postponed non-UTF-8 string in UTF-8 re matches non-UTF8";

            $y = $z;  # Reset $y after upgrade.
            ok "$x$y" !~ /^$x(??{$x})\z/,
               "Postponed UTF-8 string in UTF-8 re doesn't match non-UTF-8";
            ok "$y$y" !~ /^$y(??{$x})\z/,
               "Postponed UTF-8 string in non-UTF-8 re doesn't match non-UTF-8";
        }
d2823 4
d2828 6
d2835 6
a2840 7
    {
        local $PatchId = '18179';
        my $s = "\x{100}" x 5;
        my $ok = $s =~ /(\x{100}{4})/;
        my ($ord, $len) = (ord $1, length $1);
        ok $ok && $ord == 0x100 && $len == 4, "No panic: end_shift";
    }
d2842 7
d2850 7
a2856 5
    {
        local $BugId = '15763';
        our $a = "x\x{100}";
        chop $a;    # Leaves the UTF-8 flag
        $a .= "y";  # 1 byte before 'y'.
d2858 1
a2858 2
        ok $a =~ /^\C/,        'match one \C on 1-byte UTF-8';
        ok $a =~ /^\C{1}/,     'match \C{1}';
d2860 2
a2861 2
        ok $a =~ /^\Cy/,       'match \Cy';
        ok $a =~ /^\C{1}y/,    'match \C{1}y';
d2863 2
a2864 2
        ok $a !~ /^\C\Cy/,     q {don't match two \Cy};
        ok $a !~ /^\C{2}y/,    q {don't match \C{2}y};
d2866 16
a2881 1
        $a = "\x{100}y"; # 2 bytes before "y"
d2883 2
a2884 4
        ok $a =~ /^\C/,        'match one \C on 2-byte UTF-8';
        ok $a =~ /^\C{1}/,     'match \C{1}';
        ok $a =~ /^\C\C/,      'match two \C';
        ok $a =~ /^\C{2}/,     'match \C{2}';
d2886 16
a2901 2
        ok $a =~ /^\C\C\C/,    'match three \C on 2-byte UTF-8 and a byte';
        ok $a =~ /^\C{3}/,     'match \C{3}';
d2903 1
a2903 2
        ok $a =~ /^\C\Cy/,     'match two \C';
        ok $a =~ /^\C{2}y/,    'match \C{2}';
d2905 4
a2908 3
        ok $a !~ /^\C\C\Cy/,   q {don't match three \Cy};
        ok $a !~ /^\C{2}\Cy/,  q {don't match \C{2}\Cy};
        ok $a !~ /^\C{3}y/,    q {don't match \C{3}y};
d2910 3
a2912 1
        $a = "\x{1000}y"; # 3 bytes before "y"
d2914 2
a2915 6
        ok $a =~ /^\C/,        'match one \C on three-byte UTF-8';
        ok $a =~ /^\C{1}/,     'match \C{1}';
        ok $a =~ /^\C\C/,      'match two \C';
        ok $a =~ /^\C{2}/,     'match \C{2}';
        ok $a =~ /^\C\C\C/,    'match three \C';
        ok $a =~ /^\C{3}/,     'match \C{3}';
d2917 3
a2919 2
        ok $a =~ /^\C\C\C\C/,  'match four \C on three-byte UTF-8 and a byte';
        ok $a =~ /^\C{4}/,     'match \C{4}';
d2921 3
a2923 2
        ok $a =~ /^\C\C\Cy/,   'match three \Cy';
        ok $a =~ /^\C{3}y/,    'match \C{3}y';
d2925 3
a2927 3
        ok $a !~ /^\C\C\C\Cy/, q {don't match four \Cy};
        ok $a !~ /^\C{4}y/,    q {don't match \C{4}y};
    }
d2929 3
a2931 10
    
    {
        local $\;
        $_ = 'aaaaaaaaaa';
        utf8::upgrade($_); chop $_; $\="\n";
        ok /[^\s]+/, 'm/[^\s]/ utf8';
        ok /[^\d]+/, 'm/[^\d]/ utf8';
        ok +($a = $_, $_ =~ s/[^\s]+/./g), 's/[^\s]/ utf8';
        ok +($a = $_, $a =~ s/[^\d]+/./g), 's/[^\s]/ utf8';
    }
d2933 3
d2937 1
a2937 9
    {
        local $BugId   = '15397';
        local $Message = 'UTF-8 matching';
        ok "\x{100}" =~ /\x{100}/;
        ok "\x{100}" =~ /(\x{100})/;
        ok "\x{100}" =~ /(\x{100}){1}/;
        ok "\x{100}\x{100}" =~ /(\x{100}){2}/;
        ok "\x{100}\x{100}" =~ /(\x{100})(\x{100})/;
    }
d2939 3
d2943 3
a2945 7
    {
        local $BugId   = '7471';
        local $Message = 'Neither ()* nor ()*? sets $1 when matched 0 times';
        local $_       = 'CD';
        ok /(AB)*?CD/ && !defined $1;
        ok /(AB)*CD/  && !defined $1;
    }
d2947 3
d2951 3
a2953 9
    {
        local $BugId   = '3547';
        local $Message = "Caching shouldn't prevent match";
        my $pattern = "^(b+?|a){1,2}c";
        ok "bac"    =~ /$pattern/ && $1 eq 'a';
        ok "bbac"   =~ /$pattern/ && $1 eq 'a';
        ok "bbbac"  =~ /$pattern/ && $1 eq 'a';
        ok "bbbbac" =~ /$pattern/ && $1 eq 'a';
    }
d2955 3
d2959 4
d2964 4
a2967 9
    {
        local $BugId   = '18232';
        local $Message = '$1 should keep UTF-8 ness';
        ok "\x{100}" =~ /(.)/;
        iseq  $1, "\x{100}",  '$1 is UTF-8';
        { 'a' =~ /./; }
        iseq  $1, "\x{100}",  '$1 is still UTF-8';
        isneq $1, "\xC4\x80", '$1 is not non-UTF-8';
    }
d2969 3
d2973 1
a2973 9
    {
        local $BugId   = '19767';
        local $Message = "Optimizer doesn't prematurely reject match";
        use utf8;

        my $attr = 'Name-1';
        my $NormalChar      = qr /[\p{IsDigit}\p{IsLower}\p{IsUpper}]/;
        my $NormalWord      = qr /${NormalChar}+?/;
        my $PredNameHyphen  = qr /^${NormalWord}(\-${NormalWord})*?$/;
d2975 1
a2975 2
        $attr =~ /^$/;
        ok $attr =~ $PredNameHyphen;  # Original test.
d2977 6
a2982 3
        "a" =~ m/[b]/;
        ok "0" =~ /\p{N}+\z/;         # Variant.
    }
d2984 2
d2987 6
a2992 8
    {
        local $BugId   = '20683';
        local $Message = "(??{ }) doesn't return stale values";
        our $p = 1;
        foreach (1, 2, 3, 4) {
            $p ++ if /(??{ $p })/
        }
        iseq $p, 5;
d2994 2
a2995 12
        {
            package P;
            $a = 1;
            sub TIESCALAR {bless []}
            sub FETCH     {$a ++}
        }
        tie $p, "P";
        foreach (1, 2, 3, 4) {
            /(??{ $p })/
        }
        iseq $p, 5;
    }
d2997 15
d3013 15
a3027 6
    {
        # Subject: Odd regexp behavior
        # From: Markus Kuhn <Markus.Kuhn@@cl.cam.ac.uk>
        # Date: Wed, 26 Feb 2003 16:53:12 +0000
        # Message-Id: <E18o4nw-0008Ly-00@@wisbech.cl.cam.ac.uk>
        # To: perl-unicode@@perl.org
d3029 2
a3030 9
        local $Message = 'Markus Kuhn 2003-02-26';
    
        my $x = "\x{2019}\nk";
        ok $x =~ s/(\S)\n(\S)/$1 $2/sg;
        ok $x eq "\x{2019} k";

        $x = "b\nk";
        ok $x =~ s/(\S)\n(\S)/$1 $2/sg;
        ok $x eq "b k";
d3032 3
a3034 2
        ok "\x{2019}" =~ /\S/;
    }
d3036 2
d3039 2
a3040 10
    {
        local $BugId = '21411';
        local $Message = "(??{ .. }) in split doesn't corrupt its stack";
        our $i;
        ok '-1-3-5-' eq join '', split /((??{$i++}))/, '-1-3-5-';
        no warnings 'deprecated', 'syntax';
        split /(?{'WOW'})/, 'abc';
        local $" = "|";
        iseq "@@_", "a|b|c";
    }
d3042 1
d3044 4
a3047 8
    {
        # XXX DAPM 13-Apr-06. Recursive split is still broken. It's only luck it
        # hasn't been crashing. Disable this test until it is fixed properly.
        # XXX also check what it returns rather than just doing ok(1,...)
        # split /(?{ split "" })/, "abc";
        local $TODO = "Recursive split is still broken";
        ok 0, 'cache_re & "(?{": it dumps core in 5.6.1 & 5.8.0';
    }
d3049 2
d3052 2
a3053 3
    {
        ok "\x{100}\n" =~ /\x{100}\n$/, "UTF-8 length cache and fbm_compile";
    }
d3055 2
d3058 1
a3058 9
    {
        package Str;
        use overload q /""/ => sub {${$_ [0]};};
        sub new {my ($c, $v) = @@_; bless \$v, $c;}

        package main;
        $_ = Str -> new ("a\x{100}/\x{100}b");
        ok join (":", /\b(.)\x{100}/g) eq "a:/", "re_intuit_start and PL_bostr";
    }
d3060 6
d3067 2
a3068 7
    {
        local $BugId = '17757';
        $_ = "code:   'x' { '...' }\n"; study;
        my @@x; push @@x, $& while m/'[^\']*'/gx;
        local $" = ":";
        iseq "@@x", "'x':'...'", "Parse::RecDescent triggered infinite loop";
    }
d3070 2
d3073 3
a3075 5
    {
        my $re = qq /^([^X]*)X/;
        utf8::upgrade ($re);
        ok "\x{100}X" =~ /$re/, "S_cl_and ANYOF_UNICODE & ANYOF_INVERTED";
    }
d3077 35
d3113 7
a3119 23
    {
        local $BugId = '22354';
        sub func ($) {
            ok "a\nb" !~ /^b/,  "Propagated modifier; $_[0]";
            ok "a\nb" =~ /^b/m, "Propagated modifier; $_[0] - with /m";
        }
        func "standalone";
        $_ = "x"; s/x/func "in subst"/e;
        $_ = "x"; s/x/func "in multiline subst"/em;

        #
        # Next two give 'panic: malloc'.
        # Outcommented, using two TODOs.
        #
        local $TODO    = 'panic: malloc';
        local $Message = 'Postponed regexp and propaged modifier';
      # ok 0 for 1 .. 2;
      SKIP: {
            skip "panic: malloc", 2;
            $_ = "x"; /x(?{func "in regexp"})/;
            $_ = "x"; /x(?{func "in multiline regexp"})/m;
        }
    }
d3121 3
d3125 5
a3129 6
    {
        local $BugId = '19049';
        $_    = "abcdef\n";
        my @@x = m/./g;
        iseq "abcde", $`, 'Global match sets $`';
    }
d3131 1
d3133 9
a3141 3
    {
        ok "123\x{100}" =~ /^.*1.*23\x{100}$/,
           'UTF-8 + multiple floating substr';
d3143 2
d3146 9
d3156 2
a3157 2
    {
        local $Message = '<20030808193656.5109.1@@llama.ni-s.u-net.com>';
d3159 2
a3160 2
        # LATIN SMALL/CAPITAL LETTER A WITH MACRON
        ok "  \x{101}" =~ qr/\x{100}/i;
d3162 8
a3169 2
        # LATIN SMALL/CAPITAL LETTER A WITH RING BELOW
        ok "  \x{1E01}" =~ qr/\x{1E00}/i;
d3171 7
a3177 2
        # DESERET SMALL/CAPITAL LETTER LONG I
        ok "  \x{10428}" =~ qr/\x{10400}/i;
d3179 3
a3181 3
        # LATIN SMALL/CAPITAL LETTER A WITH RING BELOW + 'X'
        ok "  \x{1E01}x" =~ qr/\x{1E00}X/i;
    }
d3183 9
d3193 6
a3198 48
    {
        # [perl #23769] Unicode regex broken on simple example
        # regrepeat() didn't handle UTF-8 EXACT case right.
        local $BugId   = '23769';
        my $Mess       = 'regrepeat() handles UTF-8 EXACT case right';
        local $Message = $Mess;

        my $s = "\x{a0}\x{a0}\x{a0}\x{100}"; chop $s;

        ok $s =~ /\x{a0}/;
        ok $s =~ /\x{a0}+/;
        ok $s =~ /\x{a0}\x{a0}/;

        $Message = "$Mess (easy variant)";
        ok "aaa\x{100}" =~ /(a+)/;
        iseq $1, "aaa";

        $Message = "$Mess (easy invariant)";
        ok "aaa\x{100}     " =~ /(a+?)/;
        iseq $1, "a";

        $Message = "$Mess (regrepeat variant)";
        ok "\xa0\xa0\xa0\x{100}    " =~ /(\xa0+?)/;
        iseq $1, "\xa0";

        $Message = "$Mess (regrepeat invariant)";
        ok "\xa0\xa0\xa0\x{100}" =~ /(\xa0+)/;
        iseq $1, "\xa0\xa0\xa0";

        $Message = "$Mess (hard variant)";
        ok "\xa0\xa1\xa0\xa1\xa0\xa1\x{100}" =~ /((?:\xa0\xa1)+?)/;
        iseq $1, "\xa0\xa1";

        $Message = "$Mess (hard invariant)";
        ok "ababab\x{100}  " =~ /((?:ab)+)/;
        iseq $1, 'ababab';

        ok "\xa0\xa1\xa0\xa1\xa0\xa1\x{100}" =~ /((?:\xa0\xa1)+)/;
        iseq $1, "\xa0\xa1\xa0\xa1\xa0\xa1";

        ok "ababab\x{100}  " =~ /((?:ab)+?)/;
        iseq $1, "ab";

        $Message = "Don't match first byte of UTF-8 representation";
        ok "\xc4\xc4\xc4" !~ /(\x{100}+)/;
        ok "\xc4\xc4\xc4" !~ /(\x{100}+?)/;
        ok "\xc4\xc4\xc4" !~ /(\x{100}++)/;
    }
d3200 5
d3206 10
a3215 16
    {
        for (120 .. 130) {
            my $head = 'x' x $_;
            local $Message = q [Don't misparse \x{...} in regexp ] .
                             q [near 127 char EXACT limit];
            for my $tail ('\x{0061}', '\x{1234}', '\x61') {
                eval_ok qq ["$head$tail" =~ /$head$tail/];
            }
            local $Message = q [Don't misparse \N{...} in regexp ] .
                             q [near 127 char EXACT limit];
            for my $tail ('\N{SNOWFLAKE}') {
                eval_ok qq [use charnames ':full';
                           "$head$tail" =~ /$head$tail/];
            }
        }
    }
d3217 4
d3222 1
a3222 6
    {
        # perl panic: pp_match start/end pointers
        local $BugId = '25269';
        iseq "a-bc", eval {my ($x, $y) = "bca" =~ /^(?=.*(a)).*(bc)/; "$x-$y"},
             'Captures can move backwards in string';
    }
d3224 3
d3228 3
a3230 11
    {
        local $BugId   = '27940'; # \cA not recognized in character classes
        ok "a\cAb" =~ /\cA/, '\cA in pattern';
        ok "a\cAb" =~ /[\cA]/, '\cA in character class';
        ok "a\cAb" =~ /[\cA-\cB]/, '\cA in character class range';
        ok "abc" =~ /[^\cA-\cB]/, '\cA in negated character class range';
        ok "a\cBb" =~ /[\cA-\cC]/, '\cB in character class range';
        ok "a\cCbc" =~ /[^\cA-\cB]/, '\cC in negated character class range';
        ok "a\cAb" =~ /(??{"\cA"})/, '\cA in ??{} pattern';
        ok "ab" !~ /a\cIb/x, '\cI in pattern';
    }
d3232 3
d3236 3
a3238 8
    {
        # perl #28532: optional zero-width match at end of string is ignored
        local $BugId = '28532';
        ok "abc" =~ /^abc(\z)?/ && defined($1),
           'Optional zero-width match at end of string';
        ok "abc" =~ /^abc(\z)??/ && !defined($1),
           'Optional zero-width match at end of string';
    }
d3240 3
d3244 1
d3246 3
a3248 4
    {   # TRIE related
        our @@got = ();
        "words" =~ /(word|word|word)(?{push @@got, $1})s$/;
        iseq @@got, 1, "TRIE optimation";
d3250 2
a3251 3
        @@got = ();
        "words" =~ /(word|word|word)(?{push @@got,$1})s$/i;
        iseq @@got, 1,"TRIEF optimisation";
d3253 2
a3254 3
        my @@nums = map {int rand 1000} 1 .. 100;
        my $re = "(" . (join "|", @@nums) . ")";
        $re = qr/\b$re\b/;
d3256 2
a3257 3
        foreach (@@nums) {
            ok $_ =~ /$re/, "Trie nums";
        }
d3259 2
a3260 12
        $_ = join " ", @@nums;
        @@got = ();
        push @@got, $1 while /$re/g;

        my %count;
        $count {$_} ++ for @@got;
        my $ok = 1;
        for (@@nums) {
            $ok = 0 if --$count {$_} < 0;
        }
        ok $ok, "Trie min count matches";
    }
d3262 2
d3265 2
a3266 42
    {
        # TRIE related
        # LATIN SMALL/CAPITAL LETTER A WITH MACRON
        ok "foba  \x{101}foo" =~ qr/(foo|\x{100}foo|bar)/i &&
           $1 eq "\x{101}foo",
           "TRIEF + LATIN SMALL/CAPITAL LETTER A WITH MACRON";

        # LATIN SMALL/CAPITAL LETTER A WITH RING BELOW
        ok "foba  \x{1E01}foo" =~ qr/(foo|\x{1E00}foo|bar)/i &&
           $1 eq "\x{1E01}foo",
           "TRIEF + LATIN SMALL/CAPITAL LETTER A WITH RING BELOW";

        # DESERET SMALL/CAPITAL LETTER LONG I
        ok "foba  \x{10428}foo" =~ qr/(foo|\x{10400}foo|bar)/i &&
           $1 eq "\x{10428}foo",
           "TRIEF + DESERET SMALL/CAPITAL LETTER LONG I";

        # LATIN SMALL/CAPITAL LETTER A WITH RING BELOW + 'X'
        ok "foba  \x{1E01}xfoo" =~ qr/(foo|\x{1E00}Xfoo|bar)/i &&
           $1 eq "\x{1E01}xfoo",
           "TRIEF + LATIN SMALL/CAPITAL LETTER A WITH RING BELOW + 'X'";

        use charnames ':full';

        my $s = "\N{LATIN SMALL LETTER SHARP S}";
        ok "foba  ba$s" =~ qr/(foo|Ba$s|bar)/i &&  $1 eq "ba$s",
           "TRIEF + LATIN SMALL LETTER SHARP S =~ ss";
        ok "foba  ba$s" =~ qr/(Ba$s|foo|bar)/i &&  $1 eq "ba$s",
           "TRIEF + LATIN SMALL LETTER SHARP S =~ ss";
        ok "foba  ba$s" =~ qr/(foo|bar|Ba$s)/i &&  $1 eq "ba$s",
           "TRIEF + LATIN SMALL LETTER SHARP S =~ ss";

        ok "foba  ba$s" =~ qr/(foo|Bass|bar)/i &&  $1 eq "ba$s",
           "TRIEF + LATIN SMALL LETTER SHARP S =~ ss";

        ok "foba  ba$s" =~ qr/(foo|BaSS|bar)/i &&  $1 eq "ba$s",
           "TRIEF + LATIN SMALL LETTER SHARP S =~ SS";

        ok "foba  ba${s}pxySS$s$s" =~ qr/(b(?:a${s}t|a${s}f|a${s}p)[xy]+$s*)/i
            &&  $1 eq "ba${s}pxySS$s$s",
           "COMMON PREFIX TRIEF + LATIN SMALL LETTER SHARP S";
    }
d3268 2
d3271 2
a3272 4
  SKIP:
    {
        print "# Set PERL_SKIP_PSYCHO_TEST to skip this test\n";
        my @@normal = qw [the are some normal words];
d3274 3
a3276 1
        skip "Skipped Psycho", 2 * @@normal if $ENV {PERL_SKIP_PSYCHO_TEST};
d3278 9
a3286 1
        local $" = "|";
d3288 21
a3308 7
        my @@psycho = (@@normal, map chr $_, 255 .. 20000);
        my $psycho1 = "@@psycho";
        for (my $i = @@psycho; -- $i;) {
            my $j = int rand (1 + $i);
            @@psycho [$i, $j] = @@psycho [$j, $i];
        }
        my $psycho2 = "@@psycho";
a3309 5
        foreach my $word (@@normal) {
            ok $word =~ /($psycho1)/ && $1 eq $word, 'Psycho';
            ok $word =~ /($psycho2)/ && $1 eq $word, 'Psycho';
        }
    }
d3312 24
a3335 14
    {
        local $BugId = '36207';
        my $utf8 = "\xe9\x{100}"; chop $utf8;
        my $latin1 = "\xe9";

        ok $utf8 =~ /\xe9/i, "utf8/latin";
        ok $utf8 =~ /$latin1/i, "utf8/latin runtime";
        ok $utf8 =~ /(abc|\xe9)/i, "utf8/latin trie";
        ok $utf8 =~ /(abc|$latin1)/i, "utf8/latin trie runtime";

        ok "\xe9" =~ /$utf8/i, "latin/utf8";
        ok "\xe9" =~ /(abc|$utf8)/i, "latin/utf8 trie";
        ok $latin1 =~ /$utf8/i, "latin/utf8 runtime";
        ok $latin1 =~ /(abc|$utf8)/i, "latin/utf8 trie runtime";
d3337 3
d3341 43
d3385 2
a3386 9
    {
        local $BugId = '37038';
        my $s = "abcd";
        $s =~ /(..)(..)/g;
        $s = $1;
        $s = $2;
        iseq $2, 'cd',
             "Assigning to original string does not corrupt match vars";
    }
d3389 8
a3396 13
    {
        {
            package wooosh;
            sub gloople {"!"}
        }
        my $aeek = bless {} => 'wooosh';
        eval_ok sub {$aeek -> gloople () =~ /(.)/g},
               "//g match against return value of sub";

        sub gloople {"!"}
        eval_ok sub {gloople () =~ /(.)/g},
               "26410 didn't affect sub calls for some reason";
    }
d3398 1
d3400 14
a3413 22
    {
        local $TODO = "See changes 26925-26928, which reverted change 26410";
        {
            package lv;
            our $var = "abc";
            sub variable : lvalue {$var}
        }
        my $o = bless [] => 'lv';
        my $f = "";
        my $r = eval {
            for (1 .. 2) {
                $f .= $1 if $o -> variable =~ /(.)/g;
            }
            1;
        };
        if ($r) {
            iseq $f, "ab", "pos() retained between calls";
        }
        else {
            local $TODO;
            ok 0, "Code failed: $@@";
        }
d3415 1
a3415 17
        our $var = "abc";
        sub variable : lvalue {$var}
        my $g = "";
        my $s = eval {
            for (1 .. 2) {
                $g .= $1 if variable =~ /(.)/g;
            }
            1;
        };
        if ($s) {
            iseq $g, "ab", "pos() retained between calls";
        }
        else {
            local $TODO;
            ok 0, "Code failed: $@@";
        }
    }
d3417 8
d3426 4
a3429 9
  SKIP:
    {
        local $BugId = '37836';
        skip "In EBCDIC" if $IS_EBCDIC;
        no warnings 'utf8';
        $_ = pack 'U0C2', 0xa2, 0xf8;  # Ill-formed UTF-8
        my $ret = 0;
        eval_ok sub {!($ret = s/[\0]+//g)},
                "Ill-formed UTF-8 doesn't match NUL in class";
d3431 6
d3438 8
d3447 11
a3457 36
    {
        # chr(65535) should be allowed in regexes
        local $BugId = '38293';
        no warnings 'utf8'; # To allow non-characters
        my ($c, $r, $s);

        $c = chr 0xffff;
        $c =~ s/$c//g;
        ok $c eq "", "U+FFFF, parsed as atom";

        $c = chr 0xffff;
        $r = "\\$c";
        $c =~ s/$r//g;
        ok $c eq "", "U+FFFF backslashed, parsed as atom";

        $c = chr 0xffff;
        $c =~ s/[$c]//g;
        ok $c eq "", "U+FFFF, parsed in class";

        $c = chr 0xffff;
        $r = "[\\$c]";
        $c =~ s/$r//g;
        ok $c eq "", "U+FFFF backslashed, parsed in class";

        $s = "A\x{ffff}B";
        $s =~ s/\x{ffff}//i;
        ok $s eq "AB", "U+FFFF, EXACTF";

        $s = "\x{ffff}A";
        $s =~ s/\bA//;
        ok $s eq "\x{ffff}", "U+FFFF, BOUND";

        $s = "\x{ffff}!";
        $s =~ s/\B!//;
        ok $s eq "\x{ffff}", "U+FFFF, NBOUND";
    }
d3459 8
d3468 10
a3477 13
    {
        local $BugId = '39583';
        
        # The printing characters
        my @@chars = ("A" .. "Z");
        my $delim = ",";
        my $size = 32771 - 4;
        my $str = '';

        # Create some random junk. Inefficient, but it works.
        for (my $i = 0; $i < $size; $ i++) {
            $str .= $chars [rand @@chars];
        }
d3479 34
a3512 7
        $str .= ($delim x 4);
        my $res;
        my $matched;
        ok $str =~ s/^(.*?)${delim}{4}//s, "Pattern matches";
        iseq $str, "", "Empty string";
        ok defined $1 && length ($1) == $size, '$1 is correct size';
    }
d3514 25
d3540 25
a3564 26
    {
        local $BugId = '27940';
        ok "\0-A"  =~ /\c@@-A/, '@@- should not be interpolated in a pattern';
        ok "\0\0A" =~ /\c@@+A/, '@@+ should not be interpolated in a pattern';
        ok "X\@@-A"  =~ /X@@-A/, '@@- should not be interpolated in a pattern';
        ok "X\@@\@@A" =~ /X@@+A/, '@@+ should not be interpolated in a pattern';

        ok "X\0A" =~ /X\c@@?A/,  '\c@@?';
        ok "X\0A" =~ /X\c@@*A/,  '\c@@*';
        ok "X\0A" =~ /X\c@@(A)/, '\c@@(';
        ok "X\0A" =~ /X(\c@@)A/, '\c@@)';
        ok "X\0A" =~ /X\c@@|ZA/, '\c@@|';

        ok "X\@@A" =~ /X@@?A/,  '@@?';
        ok "X\@@A" =~ /X@@*A/,  '@@*';
        ok "X\@@A" =~ /X@@(A)/, '@@(';
        ok "X\@@A" =~ /X(@@)A/, '@@)';
        ok "X\@@A" =~ /X@@|ZA/, '@@|';

        local $" = ','; # non-whitespace and non-RE-specific
        ok 'abc' =~ /(.)(.)(.)/, 'The last successful match is bogus';
        ok "A@@+B"  =~ /A@@{+}B/,  'Interpolation of @@+ in /@@{+}/';
        ok "A@@-B"  =~ /A@@{-}B/,  'Interpolation of @@- in /@@{-}/';
        ok "A@@+B"  =~ /A@@{+}B/x, 'Interpolation of @@+ in /@@{+}/x';
        ok "A@@-B"  =~ /A@@{-}B/x, 'Interpolation of @@- in /@@{-}/x';
    }
d3566 14
a3579 28

    {
        use lib 'lib';
        use Cname;
        
        ok 'fooB'  =~ /\N{foo}[\N{B}\N{b}]/, "Passthrough charname";
        my $test   = 1233;
        #
        # Why doesn't must_warn work here?
        #
        my $w;
        local $SIG {__WARN__} = sub {$w .= "@@_"};
        eval 'q(xxWxx) =~ /[\N{WARN}]/';
        ok $w && $w =~ /^Ignoring excess chars from/,
                 "Ignoring excess chars warning";

        undef $w;
        eval q [ok "\0" !~ /[\N{EMPTY-STR}XY]/,
                   "Zerolength charname in charclass doesn't match \\0"];
        ok $w && $w =~ /^Ignoring zero length/,
                 'Ignoring zero length \N{%} in character class warning';

        ok 'AB'  =~ /(\N{EVIL})/ && $1 eq 'A', 'Charname caching $1';
        ok 'ABC' =~ /(\N{EVIL})/,              'Charname caching $1';
        ok 'xy'  =~ /x\N{EMPTY-STR}y/,
                    'Empty string charname produces NOTHING node';
        ok ''    =~ /\N{EMPTY-STR}/,
                    'Empty string charname produces NOTHING node';
d3581 4
a3584 53
    }


    {
        use charnames ':full';

        ok 'aabc' !~ /a\N{PLUS SIGN}b/, '/a\N{PLUS SIGN}b/ against aabc';
        ok 'a+bc' =~ /a\N{PLUS SIGN}b/, '/a\N{PLUS SIGN}b/ against a+bc';

        ok ' A B' =~ /\N{SPACE}\N{U+0041}\N{SPACE}\N{U+0042}/,
            'Intermixed named and unicode escapes';
        ok "\N{SPACE}\N{U+0041}\N{SPACE}\N{U+0042}" =~
           /\N{SPACE}\N{U+0041}\N{SPACE}\N{U+0042}/,
            'Intermixed named and unicode escapes';
        ok "\N{SPACE}\N{U+0041}\N{SPACE}\N{U+0042}" =~
           /[\N{SPACE}\N{U+0041}][\N{SPACE}\N{U+0042}]/,
            'Intermixed named and unicode escapes';     
    }


    {
        our $brackets;
        $brackets = qr{
            {  (?> [^{}]+ | (??{ $brackets }) )* }
        }x;

        ok "{b{c}d" !~ m/^((??{ $brackets }))/, "Bracket mismatch";

        SKIP: {
            our @@stack = ();
            my @@expect = qw(
                stuff1
                stuff2
                <stuff1>and<stuff2>
                right
                <right>
                <<right>>
                <<<right>>>
                <<stuff1>and<stuff2>><<<<right>>>>
            );

            local $_ = '<<<stuff1>and<stuff2>><<<<right>>>>>';
            ok /^(<((?:(?>[^<>]+)|(?1))*)>(?{push @@stack, $2 }))$/,
                "Recursion matches";
            iseq @@stack, @@expect, "Right amount of matches"
                 or skip "Won't test individual results as count isn't equal",
                          0 + @@expect;
            my $idx = 0;
            foreach my $expect (@@expect) {
                iseq $stack [$idx], $expect,
                    "Expecting '$expect' at stack pos #$idx";
                $idx ++;
            }
d3586 5
d3592 10
d3603 1
d3605 50
a3654 7
    {
        my $s = '123453456';
        $s =~ s/(?<digits>\d+)\k<digits>/$+{digits}/;
        ok $s eq '123456', 'Named capture (angle brackets) s///';
        $s = '123453456';
        $s =~ s/(?'digits'\d+)\k'digits'/$+{digits}/;
        ok $s eq '123456', 'Named capture (single quotes) s///';    
d3656 10
d3667 23
a3689 26

    {
        my @@ary = (
            pack('U', 0x00F1),            # n-tilde
            '_'.pack('U', 0x00F1),        # _ + n-tilde
            'c'.pack('U', 0x0327),        # c + cedilla
            pack('U*', 0x00F1, 0x0327),   # n-tilde + cedilla
            'a'.pack('U', 0x00B2),        # a + superscript two
            pack('U', 0x0391),            # ALPHA
            pack('U', 0x0391).'2',        # ALPHA + 2
            pack('U', 0x0391).'_',        # ALPHA + _
        );

        for my $uni (@@ary) {
            my ($r1, $c1, $r2, $c2) = eval qq {
                use utf8;
                scalar ("..foo foo.." =~ /(?'${uni}'foo) \\k'${uni}'/),
                        \$+{${uni}},
                scalar ("..bar bar.." =~ /(?<${uni}>bar) \\k<${uni}>/),
                        \$+{${uni}};
            };
            ok $r1,                         "Named capture UTF (?'')";
            ok defined $c1 && $c1 eq 'foo', "Named capture UTF \%+";
            ok $r2,                         "Named capture UTF (?<>)";
            ok defined $c2 && $c2 eq 'bar', "Named capture UTF \%+";
        }
d3691 1
d3693 10
d3704 5
a3708 36
    {
        my $s = 'foo bar baz';
        my (@@k, @@v, @@fetch, $res);
        my $count = 0;
        my @@names = qw ($+{A} $+{B} $+{C});
        if ($s =~ /(?<A>foo)\s+(?<B>bar)?\s+(?<C>baz)/) {
            while (my ($k, $v) = each (%+)) {
                $count++;
            }
            @@k = sort keys   (%+);
            @@v = sort values (%+);
            $res = 1;
            push @@fetch,
                ["$+{A}", "$1"],
                ["$+{B}", "$2"],
                ["$+{C}", "$3"],
            ;
        } 
        foreach (0 .. 2) {
            if ($fetch [$_]) {
                iseq $fetch [$_] [0], $fetch [$_] [1], $names [$_];
            } else {
                ok 0, $names[$_];
            }
        }
        iseq $res, 1, "'$s' =~ /(?<A>foo)\\s+(?<B>bar)?\\s+(?<C>baz)/";
        iseq $count, 3, "Got 3 keys in %+ via each";
        iseq 0 + @@k, 3, 'Got 3 keys in %+ via keys';
        iseq "@@k", "A B C", "Got expected keys";
        iseq "@@v", "bar baz foo", "Got expected values";
        eval '
            no warnings "uninitialized";
            print for $+ {this_key_doesnt_exist};
        ';
        ok !$@@, 'lvalue $+ {...} should not throw an exception';
    }
d3710 46
a3755 29

    {
        #
        # Almost the same as the block above, except that the capture is nested.
        #
        local $BugId = '50496';
        my $s = 'foo bar baz';
        my (@@k, @@v, @@fetch, $res);
        my $count = 0;
        my @@names = qw ($+{A} $+{B} $+{C} $+{D});
        if ($s =~ /(?<D>(?<A>foo)\s+(?<B>bar)?\s+(?<C>baz))/) {
            while (my ($k,$v) = each(%+)) {
                $count++;
            }
            @@k = sort keys   (%+);
            @@v = sort values (%+);
            $res = 1;
            push @@fetch,
                ["$+{A}", "$2"],
                ["$+{B}", "$3"],
                ["$+{C}", "$4"],
                ["$+{D}", "$1"],
            ;
        }
        foreach (0 .. 3) {
            if ($fetch [$_]) {
                iseq $fetch [$_] [0], $fetch [$_] [1], $names [$_];
            } else {
                ok 0, $names [$_];
a3757 10
        iseq $res, 1, "'$s' =~ /(?<D>(?<A>foo)\\s+(?<B>bar)?\\s+(?<C>baz))/";
        iseq $count, 4, "Got 4 keys in %+ via each";
        iseq @@k, 4, 'Got 4 keys in %+ via keys';
        iseq "@@k", "A B C D", "Got expected keys";
        iseq "@@v", "bar baz foo foo bar baz", "Got expected values";
        eval '
            no warnings "uninitialized";
            print for $+ {this_key_doesnt_exist};
        ';
        ok !$@@,'lvalue $+ {...} should not throw an exception';
d3759 96
a3854 115


    {
        my $s = 'foo bar baz';
        my @@res;
        if ('1234' =~ /(?<A>1)(?<B>2)(?<A>3)(?<B>4)/) {
            foreach my $name (sort keys(%-)) {
                my $ary = $- {$name};
                foreach my $idx (0 .. $#$ary) {
                    push @@res, "$name:$idx:$ary->[$idx]";
                }
            }
        }
        my @@expect = qw (A:0:1 A:1:3 B:0:2 B:1:4);
        iseq "@@res", "@@expect", "Check %-";
        eval'
            no warnings "uninitialized";
            print for $- {this_key_doesnt_exist};
        ';
        ok !$@@,'lvalue $- {...} should not throw an exception';
    }


  SKIP:
    {
        # stress test CURLYX/WHILEM.
        #
        # This test includes varying levels of nesting, and according to
        # profiling done against build 28905, exercises every code line in the
        # CURLYX and WHILEM blocks, except those related to LONGJMP, the
        # super-linear cache and warnings. It executes about 0.5M regexes

        skip "No psycho tests" if $ENV {PERL_SKIP_PSYCHO_TEST};
        print "# Set PERL_SKIP_PSYCHO_TEST to skip this test\n";
        my $r = qr/^
                    (?:
                        ( (?:a|z+)+ )
                        (?:
                            ( (?:b|z+){3,}? )
                            (
                                (?:
                                    (?:
                                        (?:c|z+){1,1}?z
                                    )?
                                    (?:c|z+){1,1}
                                )*
                            )
                            (?:z*){2,}
                            ( (?:z+|d)+ )
                            (?:
                                ( (?:e|z+)+ )
                            )*
                            ( (?:f|z+)+ )
                        )*
                        ( (?:z+|g)+ )
                        (?:
                            ( (?:h|z+)+ )
                        )*
                        ( (?:i|z+)+ )
                    )+
                    ( (?:j|z+)+ )
                    (?:
                        ( (?:k|z+)+ )
                    )*
                    ( (?:l|z+)+ )
              $/x;
          
        my $ok = 1;
        my $msg = "CURLYX stress test";
        OUTER:
          for my $a ("x","a","aa") {
            for my $b ("x","bbb","bbbb") {
              my $bs = $a.$b;
              for my $c ("x","c","cc") {
                my $cs = $bs.$c;
                for my $d ("x","d","dd") {
                  my $ds = $cs.$d;
                  for my $e ("x","e","ee") {
                    my $es = $ds.$e;
                    for my $f ("x","f","ff") {
                      my $fs = $es.$f;
                      for my $g ("x","g","gg") {
                        my $gs = $fs.$g;
                        for my $h ("x","h","hh") {
                          my $hs = $gs.$h;
                          for my $i ("x","i","ii") {
                            my $is = $hs.$i;
                            for my $j ("x","j","jj") {
                              my $js = $is.$j;
                              for my $k ("x","k","kk") {
                                my $ks = $js.$k;
                                for my $l ("x","l","ll") {
                                  my $ls = $ks.$l;
                                  if ($ls =~ $r) {
                                    if ($ls =~ /x/) {
                                      $msg .= ": unexpected match for [$ls]";
                                      $ok = 0;
                                      last OUTER;
                                    }
                                    my $cap = "$1$2$3$4$5$6$7$8$9$10$11$12";
                                    unless ($ls eq $cap) {
                                      $msg .= ": capture: [$ls], got [$cap]";
                                      $ok = 0;
                                      last OUTER;
                                    }
                                  }
                                  else {
                                    unless ($ls =~ /x/) {
                                      $msg = ": failed for [$ls]";
                                      $ok = 0;
                                      last OUTER;
                                    }
                                  }
                                }
                              }
d3864 1
d3866 1
a3866 1
        ok($ok, $msg);
d3868 3
d3872 14
d3887 10
a3896 16
    {
        # \, breaks {3,4}
        ok "xaaay"    !~ /xa{3\,4}y/, '\, in a pattern';
        ok "xa{3,4}y" =~ /xa{3\,4}y/, '\, in a pattern';

        # \c\ followed by _
        ok "x\c_y"    !~ /x\c\_y/,    '\_ in a pattern';
        ok "x\c\_y"   =~ /x\c\_y/,    '\_ in a pattern';

        # \c\ followed by other characters
        for my $c ("z", "\0", "!", chr(254), chr(256)) {
            my $targ = "a\034$c";
            my $reg  = "a\\c\\$c";
            ok eval ("qq/$targ/ =~ /$reg/"), "\\c\\ in pattern";
        }
    }
d3898 93
a3990 114

    {
        local $BugId = '36046';
        my $str = 'abc'; 
        my $count = 0;
        my $mval = 0;
        my $pval = 0;
        while ($str =~ /b/g) {$mval = $#-; $pval = $#+; $count ++}
        iseq $mval,  0, '@@- should be empty';
        iseq $pval,  0, '@@+ should be empty';
        iseq $count, 1, 'Should have matched once only';
    }


    {   # Test the (*PRUNE) pattern
        our $count = 0;
        'aaab' =~ /a+b?(?{$count++})(*FAIL)/;
        iseq $count, 9, "Expect 9 for no (*PRUNE)";
        $count = 0;
        'aaab' =~ /a+b?(*PRUNE)(?{$count++})(*FAIL)/;
        iseq $count, 3, "Expect 3 with (*PRUNE)";
        local $_ = 'aaab';
        $count = 0;
        1 while /.(*PRUNE)(?{$count++})(*FAIL)/g;
        iseq $count, 4, "/.(*PRUNE)/";
        $count = 0;
        'aaab' =~ /a+b?(??{'(*PRUNE)'})(?{$count++})(*FAIL)/;
        iseq $count, 3, "Expect 3 with (*PRUNE)";
        local $_ = 'aaab';
        $count = 0;
        1 while /.(??{'(*PRUNE)'})(?{$count++})(*FAIL)/g;
        iseq $count, 4, "/.(*PRUNE)/";
    }


    {   # Test the (*SKIP) pattern
        our $count = 0;
        'aaab' =~ /a+b?(*SKIP)(?{$count++})(*FAIL)/;
        iseq $count, 1, "Expect 1 with (*SKIP)";
        local $_ = 'aaab';
        $count = 0;
        1 while /.(*SKIP)(?{$count++})(*FAIL)/g;
        iseq $count, 4, "/.(*SKIP)/";
        $_ = 'aaabaaab';
        $count = 0;
        our @@res = ();
        1 while /(a+b?)(*SKIP)(?{$count++; push @@res,$1})(*FAIL)/g;
        iseq $count, 2, "Expect 2 with (*SKIP)";
        iseq "@@res", "aaab aaab", "Adjacent (*SKIP) works as expected";
    }


    {   # Test the (*SKIP) pattern
        our $count = 0;
        'aaab' =~ /a+b?(*MARK:foo)(*SKIP)(?{$count++})(*FAIL)/;
        iseq $count, 1, "Expect 1 with (*SKIP)";
        local $_ = 'aaab';
        $count = 0;
        1 while /.(*MARK:foo)(*SKIP)(?{$count++})(*FAIL)/g;
        iseq $count, 4, "/.(*SKIP)/";
        $_ = 'aaabaaab';
        $count = 0;
        our @@res = ();
        1 while /(a+b?)(*MARK:foo)(*SKIP)(?{$count++; push @@res,$1})(*FAIL)/g;
        iseq $count, 2, "Expect 2 with (*SKIP)";
        iseq "@@res", "aaab aaab", "Adjacent (*SKIP) works as expected";
    }


    {   # Test the (*SKIP) pattern
        our $count = 0;
        'aaab' =~ /a*(*MARK:a)b?(*MARK:b)(*SKIP:a)(?{$count++})(*FAIL)/;
        iseq $count, 3, "Expect 3 with *MARK:a)b?(*MARK:b)(*SKIP:a)";
        local $_ = 'aaabaaab';
        $count = 0;
        our @@res = ();
        1 while
        /(a*(*MARK:a)b?)(*MARK:x)(*SKIP:a)(?{$count++; push @@res,$1})(*FAIL)/g;
        iseq $count, 5, "Expect 5 with (*MARK:a)b?)(*MARK:x)(*SKIP:a)";
        iseq "@@res", "aaab b aaab b ",
             "Adjacent (*MARK:a)b?)(*MARK:x)(*SKIP:a) works as expected";
    }


    {   # Test the (*COMMIT) pattern
        our $count = 0;
        'aaabaaab' =~ /a+b?(*COMMIT)(?{$count++})(*FAIL)/;
        iseq $count, 1, "Expect 1 with (*COMMIT)";
        local $_ = 'aaab';
        $count = 0;
        1 while /.(*COMMIT)(?{$count++})(*FAIL)/g;
        iseq $count, 1, "/.(*COMMIT)/";
        $_ = 'aaabaaab';
        $count = 0;
        our @@res = ();
        1 while /(a+b?)(*COMMIT)(?{$count++; push @@res,$1})(*FAIL)/g;
        iseq $count, 1, "Expect 1 with (*COMMIT)";
        iseq "@@res", "aaab", "Adjacent (*COMMIT) works as expected";
    }


    {
        # Test named commits and the $REGERROR var
        our $REGERROR;
        for my $name ('', ':foo') {
            for my $pat ("(*PRUNE$name)",
                         ($name ? "(*MARK$name)" : "") . "(*SKIP$name)",
                         "(*COMMIT$name)") {                         
                for my $suffix ('(*FAIL)', '') {
                    'aaaab' =~ /a+b$pat$suffix/;
                    iseq $REGERROR,
                         ($suffix ? ($name ? 'foo' : "1") : ""),
                        "Test $pat and \$REGERROR $suffix";
                }
d3993 21
a4013 17
    }


    {
        # Test named commits and the $REGERROR var
        package Fnorble;
        our $REGERROR;
        for my $name ('', ':foo') {
            for my $pat ("(*PRUNE$name)",
                         ($name ? "(*MARK$name)" : "") . "(*SKIP$name)",
                         "(*COMMIT$name)") {                         
                for my $suffix ('(*FAIL)','') {
                    'aaaab' =~ /a+b$pat$suffix/;
                  ::iseq $REGERROR,
                         ($suffix ? ($name ? 'foo' : "1") : ""),
                        "Test $pat and \$REGERROR $suffix";
                }
d4015 11
a4025 1
        }      
d4027 12
a4038 12


    {
        # Test named commits and the $REGERROR var
        local $Message = '$REGERROR';
        our $REGERROR;
        for my $word (qw (bar baz bop)) {
            $REGERROR = "";
            "aaaaa$word" =~
              /a+(?:bar(*COMMIT:bar)|baz(*COMMIT:baz)|bop(*COMMIT:bop))(*FAIL)/;
            iseq $REGERROR, $word;
        }    
d4040 1
d4042 26
a4067 1

d4069 6
a4074 6
        local $BugId = '40684';
        local $Message = '/m in precompiled regexp';
        my $s = "abc\ndef";
        my $rex = qr'^abc$'m;
        ok $s =~ m/$rex/;
        ok $s =~ m/^abc$/m;
d4076 1
a4076 2


d4078 1
a4078 6
        #Mindnumbingly simple test of (*THEN)
        for ("ABC","BAX") {
            ok /A (*THEN) X | B (*THEN) C/x, "Simple (*THEN) test";
        }
    }

d4080 5
a4084 10
    {
        local $Message = "Relative Recursion";
        my $parens = qr/(\((?:[^()]++|(?-1))*+\))/;
        local $_ = 'foo((2*3)+4-3) + bar(2*(3+4)-1*(2-3))';
        my ($all, $one, $two) = ('', '', '');
        ok /foo $parens \s* \+ \s* bar $parens/x;
        iseq $1, '((2*3)+4-3)';
        iseq $2, '(2*(3+4)-1*(2-3))';
        iseq $&, 'foo((2*3)+4-3) + bar(2*(3+4)-1*(2-3))';
        iseq $&, $_;
d4086 1
d4089 6
a4094 6
        my $spaces="      ";
        local $_ = join 'bar', $spaces, $spaces;
        our $count = 0;
        s/(?>\s+bar)(?{$count++})//g;
        iseq $_, $spaces, "SUSPEND final string";
        iseq $count, 1, "Optimiser should have prevented more than one match";
d4096 1
d4099 6
a4104 43
        local $BugId   = '36909';
        local $Message = '(?: ... )? should not lose $^R';
        $^R = 'Nothing';
        {
            local $^R = "Bad";
            ok 'x foofoo y' =~ m {
                      (foo) # $^R correctly set
                      (?{ "last regexp code result" })
            }x;
            iseq $^R, 'last regexp code result';
        }
        iseq $^R, 'Nothing';

        {
            local $^R = "Bad";

            ok 'x foofoo y' =~ m {
                      (?:foo|bar)+ # $^R correctly set
                      (?{ "last regexp code result" })
            }x;
            iseq $^R, 'last regexp code result';
        }
        iseq $^R, 'Nothing';

        {
            local $^R = "Bad";
            ok 'x foofoo y' =~ m {
                      (foo|bar)\1+ # $^R undefined
                      (?{ "last regexp code result" })
            }x;
            iseq $^R, 'last regexp code result';
        }
        iseq $^R, 'Nothing';

        {
            local $^R = "Bad";
            ok 'x foofoo y' =~ m {
                      (foo|bar)\1 # This time without the +
                      (?{"last regexp code result"})
            }x;
            iseq $^R, 'last regexp code result';
        }
        iseq $^R, 'Nothing';
d4106 9
a4114 12


    {
        local $BugId   = '22395';
        local $Message = 'Match is linear, not quadratic';
        our $count;
        for my $l (10, 100, 1000) {
            $count = 0;
            ('a' x $l) =~ /(.*)(?{$count++})[bc]/;
            local $TODO = "Should be L+1 not L*(L+3)/2 (L=$l)";
            iseq $count, $l + 1;
        }
d4116 19
a4134 27


    {
        local $BugId   = '22614';
        local $Message = '@@-/@@+ should not have undefined values';
        local $_ = 'ab';
        our @@len = ();
        /(.){1,}(?{push @@len,0+@@-})(.){1,}(?{})^/;
        iseq "@@len", "2 2 2";
    }


    {
        local $BugId   = '18209';
        local $Message = '$& set on s///';
        my $text = ' word1 word2 word3 word4 word5 word6 ';

        my @@words = ('word1', 'word3', 'word5');
        my $count;
        foreach my $word (@@words) {
            $text =~ s/$word\s//gi; # Leave a space to seperate words
                                    # in the resultant str.
            # The following block is not working.
            if ($&) {
                $count ++;
            }
            # End bad block
d4136 1
a4136 2
        iseq $count, 3;
        iseq $text, ' word2 word4 word6 ';
d4138 11
a4148 12


    {
        # RT#6893
        local $BugId = '6893';
        local $_ = qq (A\nB\nC\n); 
        my @@res;
        while (m#(\G|\n)([^\n]*)\n#gsx) { 
            push @@res, "$2"; 
            last if @@res > 3;
        }
        iseq "@@res", "A B C", "/g pattern shouldn't infinite loop";
d4150 2
d4153 9
d4163 29
a4191 48
    {
        # From Message-ID: <877ixs6oa6.fsf@@k75.linux.bogus>
        my $dow_name = "nada";
        my $parser = "(\$dow_name) = \$time_string =~ /(D\x{e9}\\ " .
                     "C\x{e9}adaoin|D\x{e9}\\ Sathairn|\\w+|\x{100})/";
        my $time_string = "D\x{e9} C\x{e9}adaoin";
        eval $parser;
        ok !$@@, "Test Eval worked";
        iseq $dow_name, $time_string, "UTF-8 trie common prefix extraction";
    }


    {
        my $v;
        ($v = 'bar') =~ /(\w+)/g;
        $v = 'foo';
        iseq "$1", 'bar', '$1 is safe after /g - may fail due ' .
                          'to specialized config in pp_hot.c'
    }


    {
        local $Message = "http://nntp.perl.org/group/perl.perl5.porters/118663";
        my $qr_barR1 = qr/(bar)\g-1/;
        ok "foobarbarxyz" =~ $qr_barR1;
        ok "foobarbarxyz" =~ qr/foo${qr_barR1}xyz/;
        ok "foobarbarxyz" =~ qr/(foo)${qr_barR1}xyz/;
        ok "foobarbarxyz" =~ qr/(foo)(bar)\g{-1}xyz/;
        ok "foobarbarxyz" =~ qr/(foo${qr_barR1})xyz/;
        ok "foobarbarxyz" =~ qr/(foo(bar)\g{-1})xyz/;
    } 


    {
        local $BugId   = '41010';
        local $Message = 'No optimizer bug';
        my @@tails  = ('', '(?(1))', '(|)', '()?');    
        my @@quants = ('*','+');
        my $doit = sub {
            my $pats = shift;
            for (@@_) {
                for my $pat (@@$pats) {
                    for my $quant (@@quants) {
                        for my $tail (@@tails) {
                            my $re = "($pat$quant\$)$tail";
                            ok /$re/  && $1 eq $_, "'$_' =~ /$re/";
                            ok /$re/m && $1 eq $_, "'$_' =~ /$re/m";
                        }
d4195 45
a4239 14
        };    
        
        my @@dpats = ('\d',
                     '[1234567890]',
                     '(1|[23]|4|[56]|[78]|[90])',
                     '(?:1|[23]|4|[56]|[78]|[90])',
                     '(1|2|3|4|5|6|7|8|9|0)',
                     '(?:1|2|3|4|5|6|7|8|9|0)');
        my @@spats = ('[ ]', ' ', '( |\t)', '(?: |\t)', '[ \t]', '\s');
        my @@sstrs = ('  ');
        my @@dstrs = ('12345');
        $doit -> (\@@spats, @@sstrs);
        $doit -> (\@@dpats, @@dstrs);
    }
d4241 12
d4254 13
a4266 12
    {
        local $Message = '$REGMARK';
        our @@r = ();
        our ($REGMARK, $REGERROR);
        ok 'foofoo' =~ /foo (*MARK:foo) (?{push @@r,$REGMARK}) /x;
        iseq "@@r","foo";           
        iseq $REGMARK, "foo";
        ok 'foofoo' !~ /foo (*MARK:foo) (*FAIL) /x;
        ok !$REGMARK;
        iseq $REGERROR, 'foo';
    }

d4268 8
a4275 31
    {
        local $Message = '\K test';
        my $x;
        $x = "abc.def.ghi.jkl";
        $x =~ s/.*\K\..*//;
        iseq $x, "abc.def.ghi";
        
        $x = "one two three four";
        $x =~ s/o+ \Kthree//g;
        iseq $x, "one two  four";
        
        $x = "abcde";
        $x =~ s/(.)\K/$1/g;
        iseq $x, "aabbccddee";
    }


    {
        sub kt {
            return '4' if $_[0] eq '09028623';
        }
        # Nested EVAL using PL_curpm (via $1 or friends)
        my $re;
        our $grabit = qr/ ([0-6][0-9]{7}) (??{ kt $1 }) [890] /x;
        $re = qr/^ ( (??{ $grabit }) ) $ /x;
        my @@res = '0902862349' =~ $re;
        iseq join ("-", @@res), "0902862349",
            'PL_curpm is set properly on nested eval';

        our $qr = qr/ (o) (??{ $1 }) /x;
        ok 'boob'=~/( b (??{ $qr }) b )/x && 1, "PL_curpm, nested eval";
d4277 1
d4279 2
d4282 2
a4283 12
    {
        use charnames ":full";
        ok "\N{ROMAN NUMERAL ONE}" =~ /\p{Alphabetic}/, "I =~ Alphabetic";
        ok "\N{ROMAN NUMERAL ONE}" =~ /\p{Uppercase}/,  "I =~ Uppercase";
        ok "\N{ROMAN NUMERAL ONE}" !~ /\p{Lowercase}/,  "I !~ Lowercase";
        ok "\N{ROMAN NUMERAL ONE}" =~ /\p{IDStart}/,    "I =~ ID_Start";
        ok "\N{ROMAN NUMERAL ONE}" =~ /\p{IDContinue}/, "I =~ ID_Continue";
        ok "\N{SMALL ROMAN NUMERAL ONE}" =~ /\p{Alphabetic}/, "i =~ Alphabetic";
        ok "\N{SMALL ROMAN NUMERAL ONE}" !~ /\p{Uppercase}/,  "i !~ Uppercase";
        ok "\N{SMALL ROMAN NUMERAL ONE}" =~ /\p{Lowercase}/,  "i =~ Lowercase";
        ok "\N{SMALL ROMAN NUMERAL ONE}" =~ /\p{IDStart}/,    "i =~ ID_Start";
        ok "\N{SMALL ROMAN NUMERAL ONE}" =~ /\p{IDContinue}/, "i =~ ID_Continue"
d4285 6
a4290 11


    {
        # requirement of Unicode Technical Standard #18, 1.7 Code Points
        # cf. http://www.unicode.org/reports/tr18/#Supplementary_Characters
        for my $u (0x7FF, 0x800, 0xFFFF, 0x10000) {
            no warnings 'utf8'; # oops
            my $c = chr $u;
            my $x = sprintf '%04X', $u;
            ok "A${c}B" =~ /A[\0-\x{10000}]B/, "Unicode range - $x";
        }
d4292 3
d4296 14
a4309 1

d4311 2
a4312 14
        my $res="";

        if ('1' =~ /(?|(?<digit>1)|(?<digit>2))/) {
            $res = "@@{$- {digit}}";
        }
        iseq $res, "1",
            "Check that (?|...) doesnt cause dupe entries in the names array";
        
        $res = "";
        if ('11' =~ /(?|(?<digit>1)|(?<digit>2))(?&digit)/) {
            $res = "@@{$- {digit}}";
        }
        iseq $res, "1", "Check that (?&..) to a buffer inside " .
                        "a (?|...) goes to the leftmost";
d4314 33
a4346 61


    {
        use warnings;
        local $Message = "ASCII pattern that really is UTF-8";
        my @@w;
        local $SIG {__WARN__} = sub {push @@w, "@@_"};
        my $c = qq (\x{DF}); 
        ok $c =~ /${c}|\x{100}/;
        ok @@w == 0;
    }    


    {
        local $Message = "Corruption of match results of qr// across scopes";
        my $qr = qr/(fo+)(ba+r)/;
        'foobar' =~ /$qr/;
        iseq "$1$2", "foobar";
        {
            'foooooobaaaaar' =~ /$qr/;
            iseq "$1$2", 'foooooobaaaaar';    
        }
        iseq "$1$2", "foobar";
    }


    {
        local $Message = "HORIZWS";
        local $_ = "\t \r\n \n \t".chr(11)."\n";
        s/\H/H/g;
        s/\h/h/g;
        iseq $_, "hhHHhHhhHH";
        $_ = "\t \r\n \n \t" . chr (11) . "\n";
        utf8::upgrade ($_);
        s/\H/H/g;
        s/\h/h/g;
        iseq $_, "hhHHhHhhHH";
    }    


    {
        local $Message = "Various whitespace special patterns";
        my @@h = map {chr $_}   0x09,   0x20,   0xa0, 0x1680, 0x180e, 0x2000,
                             0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006,
                             0x2007, 0x2008, 0x2009, 0x200a, 0x202f, 0x205f,
                             0x3000;
        my @@v = map {chr $_}   0x0a,   0x0b,   0x0c,   0x0d,   0x85, 0x2028,
                             0x2029;
        my @@lb = ("\x0D\x0A", map {chr $_} 0x0A .. 0x0D, 0x85, 0x2028, 0x2029);
        foreach my $t ([\@@h,  qr/\h/, qr/\h+/],
                       [\@@v,  qr/\v/, qr/\v+/],
                       [\@@lb, qr/\R/, qr/\R+/],) {
            my $ary = shift @@$t;
            foreach my $pat (@@$t) {
                foreach my $str (@@$ary) {
                    ok $str =~ /($pat)/, $pat;
                    iseq $1, $str, $pat;
                    utf8::upgrade ($str);
                    ok $str =~ /($pat)/, "Upgraded string - $pat";
                    iseq $1, $str, "Upgraded string - $pat";
                }
d4350 30
a4379 35


    {
        local $Message = "Check that \\xDF match properly in its various forms";
        # Test that \xDF matches properly. this is pretty hacky stuff,
        # but its actually needed. The malarky with '-' is to prevent
        # compilation caching from playing any role in the test.
        my @@df = (chr (0xDF), '-', chr (0xDF));
        utf8::upgrade ($df [2]);
        my @@strs = ('ss', 'sS', 'Ss', 'SS', chr (0xDF));
        my @@ss = map {("$_", "$_")} @@strs;
        utf8::upgrade ($ss [$_ * 2 + 1]) for 0 .. $#strs;

        for my $ssi (0 .. $#ss) {
            for my $dfi (0 .. $#df) {
                my $pat = $df [$dfi];
                my $str = $ss [$ssi];
                my $utf_df = ($dfi > 1) ? 'utf8' : '';
                my $utf_ss = ($ssi % 2) ? 'utf8' : '';
                (my $sstr = $str) =~ s/\xDF/\\xDF/;

                if ($utf_df || $utf_ss || length ($ss [$ssi]) == 1) {
                    my $ret = $str =~ /$pat/i;
                    next if $pat eq '-';
                    ok $ret, "\"$sstr\" =~ /\\xDF/i " .
                             "(str is @@{[$utf_ss||'latin']}, pat is " .
                             "@@{[$utf_df||'latin']})";
                }
                else {
                    my $ret = $str !~ /$pat/i;
                    next if $pat eq '-';
                    ok $ret, "\"$sstr\" !~ /\\xDF/i " .
                             "(str is @@{[$utf_ss||'latin']}, pat is " .
                             "@@{[$utf_df||'latin']})";
                }
d4383 6
d4390 2
d4393 22
a4414 13
    {
        local $Message = "BBC(Bleadperl Breaks CPAN) Today: String::Multibyte";
        my $re  = qr/(?:[\x00-\xFF]{4})/;
        my $hyp = "\0\0\0-";
        my $esc = "\0\0\0\\";

        my $str = "$esc$hyp$hyp$esc$esc";
        my @@a = ($str =~ /\G(?:\Q$esc$esc\E|\Q$esc$hyp\E|$re)/g);

        iseq @@a,3;
        local $" = "=";
        iseq "@@a","$esc$hyp=$hyp=$esc$esc";
    }
d4416 11
d4428 2
a4429 22
    {
        # Test for keys in %+ and %-
        local $Message = 'Test keys in %+ and %-';
        no warnings 'uninitialized';
        my $_ = "abcdef";
        /(?<foo>a)|(?<foo>b)/;
        iseq ((join ",", sort keys %+), "foo");
        iseq ((join ",", sort keys %-), "foo");
        iseq ((join ",", sort values %+), "a");
        iseq ((join ",", sort map "@@$_", values %-), "a ");
        /(?<bar>a)(?<bar>b)(?<quux>.)/;
        iseq ((join ",", sort keys %+), "bar,quux");
        iseq ((join ",", sort keys %-), "bar,quux");
        iseq ((join ",", sort values %+), "a,c"); # leftmost
        iseq ((join ",", sort map "@@$_", values %-), "a b,c");
        /(?<un>a)(?<deux>c)?/; # second buffer won't capture
        iseq ((join ",", sort keys %+), "un");
        iseq ((join ",", sort keys %-), "deux,un");
        iseq ((join ",", sort values %+), "a");
        iseq ((join ",", sort map "@@$_", values %-), ",a");
    }

d4431 47
a4477 10
    {
        # length() on captures, the numbered ones end up in Perl_magic_len
        my $_ = "aoeu \xe6var ook";
        /^ \w+ \s (?<eek>\S+)/x;

        iseq length ($`),      0, q[length $`];
        iseq length ($'),      4, q[length $'];
        iseq length ($&),      9, q[length $&];
        iseq length ($1),      4, q[length $1];
        iseq length ($+{eek}), 4, q[length $+{eek} == length $1];
d4479 4
d4484 5
d4490 12
a4501 89
    {
        my $ok = -1;

        $ok = exists ($-{x}) ? 1 : 0 if 'bar' =~ /(?<x>foo)|bar/;
        iseq $ok, 1, '$-{x} exists after "bar"=~/(?<x>foo)|bar/';
        iseq scalar (%+), 0, 'scalar %+ == 0 after "bar"=~/(?<x>foo)|bar/';
        iseq scalar (%-), 1, 'scalar %- == 1 after "bar"=~/(?<x>foo)|bar/';

        $ok = -1;
        $ok = exists ($+{x}) ? 1 : 0 if 'bar' =~ /(?<x>foo)|bar/;
        iseq $ok, 0, '$+{x} not exists after "bar"=~/(?<x>foo)|bar/';
        iseq scalar (%+), 0, 'scalar %+ == 0 after "bar"=~/(?<x>foo)|bar/';
        iseq scalar (%-), 1, 'scalar %- == 1 after "bar"=~/(?<x>foo)|bar/';

        $ok = -1;
        $ok = exists ($-{x}) ? 1 : 0 if 'foo' =~ /(?<x>foo)|bar/;
        iseq $ok, 1, '$-{x} exists after "foo"=~/(?<x>foo)|bar/';
        iseq scalar (%+), 1, 'scalar %+ == 1 after "foo"=~/(?<x>foo)|bar/';
        iseq scalar (%-), 1, 'scalar %- == 1 after "foo"=~/(?<x>foo)|bar/';

        $ok = -1;
        $ok = exists ($+{x}) ? 1 : 0 if 'foo'=~/(?<x>foo)|bar/;
        iseq $ok, 1, '$+{x} exists after "foo"=~/(?<x>foo)|bar/';
    }


    {
        local $_;
        ($_ = 'abc') =~ /(abc)/g;
        $_ = '123'; 
        iseq "$1", 'abc', "/g leads to unsafe match vars: $1";
    }


    {
        local $Message = 'Message-ID: <20070818091501.7eff4831@@r2d2>';
        my $str = "";
        for (0 .. 5) {
            my @@x;
            $str .= "@@x"; # this should ALWAYS be the empty string
            'a' =~ /(a|)/;
            push @@x, 1;
        }
        iseq length ($str), 0, "Trie scope error, string should be empty";
        $str = "";
        my @@foo = ('a') x 5;
        for (@@foo) {
            my @@bar;
            $str .= "@@bar";
            s/a|/push @@bar, 1/e;
        }
        iseq length ($str), 0, "Trie scope error, string should be empty";
    }


    {
        local $BugId = '45605';
        # [perl #45605] Regexp failure with utf8-flagged and byte-flagged string

        my $utf_8 = "\xd6schel";
        utf8::upgrade ($utf_8);
        $utf_8 =~ m {(\xd6|&Ouml;)schel};
        iseq $1, "\xd6", "Upgrade error";
    }

    {
# more TRIE/AHOCORASICK problems with mixed utf8 / latin-1 and case folding
	for my $chr (160 .. 255) {
	    my $chr_byte = chr($chr);
	    my $chr_utf8 = chr($chr); utf8::upgrade($chr_utf8);
	    my $rx = qr{$chr_byte|X}i;
	    ok($chr_utf8 =~ $rx, "utf8/latin, codepoint $chr");
	}
    }

    {
        # Regardless of utf8ness any character matches itself when 
        # doing a case insensitive match. See also [perl #36207] 
        local $BugId = '36207';
        for my $o (0 .. 255) {
            my @@ch = (chr ($o), chr ($o));
            utf8::upgrade ($ch [1]);
            for my $u_str (0, 1) {
                for my $u_pat (0, 1) {
                    ok $ch [$u_str] =~ /\Q$ch[$u_pat]\E/i,
                    "\$c =~ /\$c/i : chr ($o) : u_str = $u_str u_pat = $u_pat";
                    ok $ch [$u_str] =~ /\Q$ch[$u_pat]\E|xyz/i,
                    "\$c=~/\$c|xyz/i : chr($o) : u_str = $u_str u_pat = $u_pat";
                }
d4505 1
d4507 21
d4529 2
a4530 5
    {
        our $a = 3; "" =~ /(??{ $a })/;
        our $b = $a;
        iseq $b, $a, "Copy of scalar used for postponed subexpression";
    }
d4532 19
d4552 1
a4552 11
    {
         local $BugId   = '49190';
         local $Message = '$REGMARK in replacement';
         our $REGMARK;
         my $_ = "A";
         ok s/(*:B)A/$REGMARK/;
         iseq $_, "B";
         $_ = "CCCCBAA";
         ok s/(*:X)A+|(*:Y)B+|(*:Z)C+/$REGMARK/g;
         iseq $_, "ZYX";
    }
d4554 6
d4561 7
a4567 427
    {
        our @@ctl_n = ();
        our @@plus = ();
        our $nested_tags;
        $nested_tags = qr{
            <
               (\w+)
               (?{
                       push @@ctl_n,$^N;
                       push @@plus,$+;
               })
            >
            (??{$nested_tags})*
            </\s* \w+ \s*>
        }x;

        my $match = '<bla><blubb></blubb></bla>' =~ m/^$nested_tags$/;
        ok $match, 'nested construct matches';
        iseq "@@ctl_n", "bla blubb", '$^N inside of (?{}) works as expected';
        iseq "@@plus",  "bla blubb", '$+  inside of (?{}) works as expected';
    }


    {
        local $BugId   = '52658';
        local $Message = 'Substitution evaluation in list context';
        my $reg = '../xxx/';
        my @@te  = ($reg =~ m{^(/?(?:\.\./)*)},
                   $reg =~ s/(x)/'b'/eg > 1 ? '##' : '++');
        iseq $reg, '../bbb/';
        iseq $te [0], '../';
    }

	# This currently has to come before any "use encoding" in this file.
    {
        local $Message;
        local $BugId   = '59342';
	# for 5.10.x, add a dummy test indead
        #must_warn 'qr/\400/', '^Use of octal value above 377';
	$Message=""; ok 1;
    }


    SKIP: {
        # XXX: This set of tests is essentially broken, POSIX character classes
        # should not have differing definitions under Unicode. 
        # There are property names for that.
        skip "Tests assume ASCII", 4 unless $IS_ASCII;

        my @@notIsPunct = grep {/[[:punct:]]/ and not /\p{IsPunct}/}
                                map {chr} 0x20 .. 0x7f;
        iseq join ('', @@notIsPunct), '$+<=>^`|~',
            '[:punct:] disagress with IsPunct on Symbols';

        my @@isPrint = grep {not /[[:print:]]/ and /\p{IsPrint}/}
                            map {chr} 0 .. 0x1f, 0x7f .. 0x9f;
        iseq join ('', @@isPrint), "\x09\x0a\x0b\x0c\x0d\x85",
            'IsPrint disagrees with [:print:] on control characters';

        my @@isPunct = grep {/[[:punct:]]/ != /\p{IsPunct}/}
                            map {chr} 0x80 .. 0xff;
        iseq join ('', @@isPunct), "\xa1\xab\xb7\xbb\xbf",	# ¡ « · » ¿
            'IsPunct disagrees with [:punct:] outside ASCII';

        my @@isPunctLatin1 = eval q {
            use encoding 'latin1';
            grep {/[[:punct:]]/ != /\p{IsPunct}/} map {chr} 0x80 .. 0xff;
        };
        skip "Eval failed ($@@)", 1 if $@@;
        skip "PERL_LEGACY_UNICODE_CHARCLASS_MAPPINGS set to 0", 1
              if $ENV {REAL_POSIX_CC};
        iseq join ('', @@isPunctLatin1), '', 
            'IsPunct agrees with [:punct:] with explicit Latin1';
    } 


    {
        local $BugId =  '60034';
        my $a = "xyzt" x 8192;
        ok $a =~ /\A(?>[a-z])*\z/,
                '(?>) does not cause wrongness on long string';
        my $b = $a . chr 256;
        chop $b;
        {
            iseq $a, $b;
        }
        ok $b =~ /\A(?>[a-z])*\z/,
           '(?>) does not cause wrongness on long string with UTF-8';
    }


    #
    # Keep the following tests last -- they may crash perl
    #
    print "# Tests that follow may crash perl\n";
    {   
        local $BugId   = '19049/38869';
        local $Message = 'Pattern in a loop, failure should not ' .
                         'affect previous success';
        my @@list = (
            'ab cdef',             # Matches regex
            ('e' x 40000 ) .'ab c' # Matches not, but 'ab c' matches part of it
        );
        my $y;
        my $x;
        foreach (@@list) {
            m/ab(.+)cd/i; # The ignore-case seems to be important
            $y = $1;      # Use $1, which might not be from the last match!
            $x = substr ($list [0], $- [0], $+ [0] - $- [0]);
        }
        iseq $y, ' ';
        iseq $x, 'ab cd';
    }


    {
        local $BugId = '24274';

        ok (("a" x (2 ** 15 - 10)) =~ /^()(a|bb)*$/, "Recursive stack cracker");
        ok ((q(a)x 100) =~ /^(??{'(.)'x 100})/, 
            "Regexp /^(??{'(.)'x 100})/ crashes older perls");
    }


    {
        eval '/\k/';
        ok $@@ =~ /\QSequence \k... not terminated in regex;\E/,
           'Lone \k not allowed';
    }


    {
        local $Message = "Substitution with lookahead (possible segv)";
        $_ = "ns1ns1ns1";
        s/ns(?=\d)/ns_/g;
        iseq $_, "ns_1ns_1ns_1";
        $_ = "ns1";
        s/ns(?=\d)/ns_/;
        iseq $_, "ns_1";
        $_ = "123";
        s/(?=\d+)|(?<=\d)/!Bang!/g;
        iseq $_, "!Bang!1!Bang!2!Bang!3!Bang!";
    }


    {
        # [perl #45337] utf8 + "[a]a{2}" + /$.../ = panic: sv_len_utf8 cache
        local $BugId = '45337';
        local ${^UTF8CACHE} = -1;
        local $Message = "Shouldn't panic";
        my $s = "[a]a{2}";
        utf8::upgrade $s;
        ok "aaa" =~ /$s/;
    }
    {
        local $BugId = '57042';
	local $Message = "Check if tree logic breaks \$^R";
	my $cond_re = qr/\s*
	    \s* (?:
		   \( \s* A  (?{1})
		 | \( \s* B  (?{2})
	       )
	   /x;
	my @@res;
	for my $line ("(A)","(B)") {
	   if ($line =~ m/$cond_re/) {
	       push @@res, $^R ? "#$^R" : "UNDEF";
	   }
	}
	iseq "@@res","#1 #2";
    }
    {
	no warnings 'closure';
	my $re = qr/A(??{"1"})/;
	ok "A1B" =~ m/^((??{ $re }))((??{"B"}))$/;
	ok $1 eq "A1";
	ok $2 eq "B";
    }


    {
        use re 'eval';
        local $Message = 'Test if $^N and $+ work in (?{{})';
        our @@ctl_n = ();
        our @@plus = ();
        our $nested_tags;
        $nested_tags = qr{
            <
               ((\w)+)
               (?{
                       push @@ctl_n, (defined $^N ? $^N : "undef");
                       push @@plus, (defined $+ ? $+ : "undef");
               })
            >
            (??{$nested_tags})*
            </\s* \w+ \s*>
        }x;


        my $c = 0;
        for my $test (
            # Test structure:
            #  [ Expected result, Regex, Expected value(s) of $^N, Expected value(s) of $+ ]
            [ 1, qr#^$nested_tags$#, "bla blubb bla", "a b a" ],
            [ 1, qr#^($nested_tags)$#, "bla blubb <bla><blubb></blubb></bla>", "a b a" ],
            [ 1, qr#^(|)$nested_tags$#, "bla blubb bla", "a b a" ],
            [ 1, qr#^(?:|)$nested_tags$#, "bla blubb bla", "a b a" ],
            [ 1, qr#^<(bl|bla)>$nested_tags<(/\1)>$#, "blubb /bla", "b /bla" ],
            [ 1, qr#(??{"(|)"})$nested_tags$#, "bla blubb bla", "a b a" ],
            [ 1, qr#^(??{"(bla|)"})$nested_tags$#, "bla blubb bla", "a b a" ],
            [ 1, qr#^(??{"(|)"})(??{$nested_tags})$#, "bla blubb undef", "a b undef" ],
            [ 1, qr#^(??{"(?:|)"})$nested_tags$#, "bla blubb bla", "a b a" ],
            [ 1, qr#^((??{"(?:bla|)"}))((??{$nested_tags}))$#, "bla blubb <bla><blubb></blubb></bla>", "a b <bla><blubb></blubb></bla>" ],
            [ 1, qr#^((??{"(?!)?"}))((??{$nested_tags}))$#, "bla blubb <bla><blubb></blubb></bla>", "a b <bla><blubb></blubb></bla>" ],
            [ 1, qr#^((??{"(?:|<(/?bla)>)"}))((??{$nested_tags}))\1$#, "bla blubb <bla><blubb></blubb></bla>", "a b <bla><blubb></blubb></bla>" ],
            [ 0, qr#^((??{"(?!)"}))?((??{$nested_tags}))(?!)$#, "bla blubb undef", "a b undef" ],

        ) { #"#silence vim highlighting
            $c++;
            @@ctl_n = ();
            @@plus = ();
            my $match = (("<bla><blubb></blubb></bla>" =~ $test->[1]) ? 1 : 0);
            push @@ctl_n, (defined $^N ? $^N : "undef");
            push @@plus, (defined $+ ? $+ : "undef");
            ok($test->[0] == $match, "match $c");
            if ($test->[0] != $match) {
              # unset @@ctl_n and @@plus
              @@ctl_n = @@plus = ();
            }
            iseq("@@ctl_n", $test->[2], "ctl_n $c");
            iseq("@@plus", $test->[3], "plus $c");
        }
    }

    {
        use re 'eval';
        local $BugId = '56194';

	our $f;
	local $f;
	$f = sub {
            defined $_[0] ? $_[0] : "undef";
        };

        ok("123" =~ m/^(\d)(((??{1 + $^N})))+$/);

        our @@ctl_n;
        our @@plus;

        my $re  = qr#(1)((??{ push @@ctl_n, $f->($^N); push @@plus, $f->($+); $^N + 1}))*(?{$^N})#;
        my $re2 = qr#(1)((??{ push @@ctl_n, $f->($^N); push @@plus, $f->($+); $^N + 1}))*(?{$^N})(|a(b)c|def)(??{"$^R"})#;
        my $re3 = qr#(1)((??{ push @@ctl_n, $f->($^N); push @@plus, $f->($+); $^N + 1})){2}(?{$^N})(|a(b)c|def)(??{"$^R"})#;
        our $re5;
        local $re5 = qr#(1)((??{ push @@ctl_n, $f->($^N); push @@plus, $f->($+); $^N + 1})){2}(?{$^N})#;
        my $re6 = qr#(??{ push @@ctl_n, $f->($^N); push @@plus, $f->($+); $^N + 1})#;
        my $re7 = qr#(??{ push @@ctl_n, $f->($^N); push @@plus, $f->($+); $^N + 1})#;
        my $re8 = qr/(\d+)/;
        my $c = 0;
        for my $test (
             # Test structure:
             #  [
             #    String to match
             #    Regex too match
             #    Expected values of $^N
             #    Expected values of $+
             #    Expected values of $1, $2, $3, $4 and $5
             #  ]
             [
                  "1233",
                  qr#^(1)((??{ push @@ctl_n, $f->($^N); push @@plus, $f->($+); $^N + 1}))+(??{$^N})$#,
                  "1 2 3 3",
                  "1 2 3 3",
                  "\$1 = 1, \$2 = 3, \$3 = undef, \$4 = undef, \$5 = undef",
             ],
             [
                  "1233",
                  qr#^(1)((??{ push @@ctl_n, $f->($^N); push @@plus, $f->($+); $^N + 1}))+(abc|def|)?(??{$+})$#,
                  "1 2 3 3",
                  "1 2 3 3",
                  "\$1 = 1, \$2 = 3, \$3 = undef, \$4 = undef, \$5 = undef",
             ],
             [
                  "1233",
                  qr#^(1)((??{ push @@ctl_n, $f->($^N); push @@plus, $f->($+); $^N + 1}))+(|abc|def)?(??{$+})$#,
                  "1 2 3 3",
                  "1 2 3 3",
                  "\$1 = 1, \$2 = 3, \$3 = undef, \$4 = undef, \$5 = undef",
             ],
             [
                  "1233",
                  qr#^(1)((??{ push @@ctl_n, $f->($^N); push @@plus, $f->($+); $^N + 1}))+(abc|def|)?(??{$^N})$#,
                  "1 2 3 3",
                  "1 2 3 3",
                  "\$1 = 1, \$2 = 3, \$3 = undef, \$4 = undef, \$5 = undef",
             ],
             [
                  "1233",
                  qr#^(1)((??{ push @@ctl_n, $f->($^N); push @@plus, $f->($+); $^N + 1}))+(|abc|def)?(??{$^N})$#,
                  "1 2 3 3",
                  "1 2 3 3",
                  "\$1 = 1, \$2 = 3, \$3 = undef, \$4 = undef, \$5 = undef",
              ],
              [
                  "123abc3",
                   qr#^($re)(|a(b)c|def)(??{$^R})$#,
                   "1 2 3 abc",
                   "1 2 3 b",
                   "\$1 = 123, \$2 = 1, \$3 = 3, \$4 = abc, \$5 = b",
              ],
              [
                  "123abc3",
                   qr#^($re2)$#,
                   "1 2 3 123abc3",
                   "1 2 3 b",
                   "\$1 = 123abc3, \$2 = 1, \$3 = 3, \$4 = abc, \$5 = b",
              ],
              [
                  "123abc3",
                   qr#^($re3)$#,
                   "1 2 123abc3",
                   "1 2 b",
                   "\$1 = 123abc3, \$2 = 1, \$3 = 3, \$4 = abc, \$5 = b",
              ],
              [
                  "123abc3",
                   qr#^(??{$re5})(|abc|def)(??{"$^R"})$#,
                   "1 2 abc",
                   "1 2 abc",
                   "\$1 = abc, \$2 = undef, \$3 = undef, \$4 = undef, \$5 = undef",
              ],
              [
                  "123abc3",
                   qr#^(??{$re5})(|a(b)c|def)(??{"$^R"})$#,
                   "1 2 abc",
                   "1 2 b",
                   "\$1 = abc, \$2 = b, \$3 = undef, \$4 = undef, \$5 = undef",
              ],
              [
                  "1234",
                   qr#^((\d+)((??{push @@ctl_n, $f->($^N); push @@plus, $f->($+);$^N + 1}))((??{push @@ctl_n, $f->($^N); push @@plus, $f->($+);$^N + 1}))((??{push @@ctl_n, $f->($^N); push @@plus, $f->($+);$^N + 1})))$#,
                   "1234 123 12 1 2 3 1234",
                   "1234 123 12 1 2 3 4",
                   "\$1 = 1234, \$2 = 1, \$3 = 2, \$4 = 3, \$5 = 4",
              ],
              [
                   "1234556",
                   qr#^(\d+)($re6)($re6)($re6)$re6(($re6)$re6)$#,
                   "1234556 123455 12345 1234 123 12 1 2 3 4 4 5 56",
                   "1234556 123455 12345 1234 123 12 1 2 3 4 4 5 5",
                   "\$1 = 1, \$2 = 2, \$3 = 3, \$4 = 4, \$5 = 56",
              ],
              [
                  "12345562",
                   qr#^((??{$re8}))($re7)($re7)($re7)$re7($re7)($re7(\2))$#,
                   "12345562 1234556 123455 12345 1234 123 12 1 2 3 4 4 5 62",
                   "12345562 1234556 123455 12345 1234 123 12 1 2 3 4 4 5 2",
                   "\$1 = 1, \$2 = 2, \$3 = 3, \$4 = 4, \$5 = 5",
              ],
        ) {
            $c++;
            @@ctl_n = ();
            @@plus = ();
            undef $^R;
            my $match = $test->[0] =~ $test->[1];
            my $str = join(", ", '$1 = '.$f->($1), '$2 = '.$f->($2), '$3 = '.$f->($3), '$4 = '.$f->($4),'$5 = '.$f->($5));
            push @@ctl_n, $f->($^N);
            push @@plus, $f->($+);
            ok($match, "match $c");
            if (not $match) {
                # unset $str, @@ctl_n and @@plus
                $str = "";
                @@ctl_n = @@plus = ();
            }
            iseq("@@ctl_n", $test->[2], "ctl_n $c");
            iseq("@@plus", $test->[3], "plus $c");
            iseq($str, $test->[4], "str $c");
        }
        SKIP: {
            if ($] le '5.010') {
                skip "test segfaults on perl < 5.10", 4;
            }

            @@ctl_n = ();
            @@plus = ();

            our $re4;
            local $re4 = qr#(1)((??{push @@ctl_n, $f->($^N); push @@plus, $f->($+);$^N + 1})){2}(?{$^N})(|abc|def)(??{"$^R"})#;
            undef $^R;
            my $match = "123abc3" =~ m/^(??{$re4})$/;
            my $str = join(", ", '$1 = '.$f->($1), '$2 = '.$f->($2), '$3 = '.$f->($3), '$4 = '.$f->($4),'$5 = '.$f->($5),'$^R = '.$f->($^R));
            push @@ctl_n, $f->($^N);
            push @@plus, $f->($+);
            ok($match);
            if (not $match) {
                # unset $str
                @@ctl_n = ();
                @@plus = ();
                $str = "";
            }
            iseq("@@ctl_n", "1 2 undef");
            iseq("@@plus", "1 2 undef");
            iseq($str, "\$1 = undef, \$2 = undef, \$3 = undef, \$4 = undef, \$5 = undef, \$^R = undef");
       }
    }

    {
	local $BugId = 65372;	# minimal CURLYM limited to 32767 matches
	my @@pat = (
	    qr{a(x|y)*b},	# CURLYM
	    qr{a(x|y)*?b},	# .. with minmod
	    qr{a([wx]|[yz])*b},	# .. and without tries
	    qr{a([wx]|[yz])*?b},
	);
	my $len = 32768;
	my $s = join '', 'a', 'x' x $len, 'b';
	for my $pat (@@pat) {
	    ok($s =~ $pat, $pat);
	}
    }
    #
    # This should be the last test.
    #
    iseq $test + 1, $EXPECTED_TESTS, "Got the right number of tests!";

} # End of sub run_tests

1;
@


