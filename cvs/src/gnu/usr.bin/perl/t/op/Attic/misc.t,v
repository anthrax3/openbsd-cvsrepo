head	1.6;
access;
symbols
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;


1.6
date	2002.10.27.22.25.37;	author millert;	state dead;
branches;
next	1.5;

1.5
date	2001.05.24.18.36.19;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.08.26;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.52.36;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.08.05.28;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.13.19;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.13.19;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.41.46;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.10.49;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.25.41;	author millert;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@#!./perl

# NOTE: Please don't add tests to this file unless they *need* to be run in
# separate executable and can't simply use eval.

chdir 't' if -d 't';
@@INC = '../lib';
$ENV{PERL5LIB} = "../lib";

$|=1;

undef $/;
@@prgs = split "\n########\n", <DATA>;
print "1..", scalar @@prgs, "\n";

$tmpfile = "misctmp000";
1 while -f ++$tmpfile;
END { while($tmpfile && unlink $tmpfile){} }

$CAT = (($^O eq 'MSWin32') ? '.\perl -e "print <>"' : 'cat');

for (@@prgs){
    my $switch;
    if (s/^\s*(-\w.*)//){
	$switch = $1;
    }
    my($prog,$expected) = split(/\nEXPECT\n/, $_);
    open TEST, ">$tmpfile" or die "Cannot open $tmpfile: $!";
    $prog =~ s#/dev/null#NL:# if $^O eq 'VMS';     
    $prog =~ s#if \(-e _ and -f _ and -r _\)#if (-e _ and -f _)# if $^O eq 'VMS';  # VMS file locking 

    print TEST $prog, "\n";
    close TEST or die "Cannot close $tmpfile: $!";

    if ($^O eq 'MSWin32') {
      $results = `.\\perl -I../lib $switch $tmpfile 2>&1`;
    }
    else {
      $results = `./perl $switch $tmpfile 2>&1`;
    }
    $status = $?;
    $results =~ s/\n+$//;
    $results =~ s/at\s+misctmp\d+\s+line/at - line/g;
    $results =~ s/of\s+misctmp\d+\s+aborted/of - aborted/g;
# bison says 'parse error' instead of 'syntax error',
# various yaccs may or may not capitalize 'syntax'.
    $results =~ s/^(syntax|parse) error/syntax error/mig;
    $expected =~ s/\n+$//;
    if ( $results ne $expected ) {
	print STDERR "PROG: $switch\n$prog\n";
	print STDERR "EXPECTED:\n$expected\n";
	print STDERR "GOT:\n$results\n";
	print "not ";
    }
    print "ok ", ++$i, "\n";
}

__END__
()=()
########
$a = ":="; split /($a)/o, "a:=b:=c"; print "@@_"
EXPECT
a := b := c
########
$cusp = ~0 ^ (~0 >> 1);
use integer;
$, = " ";
print +($cusp - 1) % 8, $cusp % 8, -$cusp % 8, 8 | (($cusp + 1) % 8 + 7), "!\n";
EXPECT
7 0 0 8 !
########
$foo=undef; $foo->go;
EXPECT
Can't call method "go" on an undefined value at - line 1.
########
BEGIN
        {
	    "foo";
        }
########
$array[128]=1
########
$x=0x0eabcd; print $x->ref;
EXPECT
Can't call method "ref" without a package or object reference at - line 1.
########
chop ($str .= <DATA>);
########
close ($banana);
########
$x=2;$y=3;$x<$y ? $x : $y += 23;print $x;
EXPECT
25
########
eval {sub bar {print "In bar";}}
########
system './perl -ne "print if eof" /dev/null'
########
chop($file = <DATA>);
########
package N;
sub new {my ($obj,$n)=@@_; bless \$n}  
$aa=new N 1;
$aa=12345;
print $aa;
EXPECT
12345
########
%@@x=0;
EXPECT
Can't modify hash dereference in repeat (x) at - line 1, near "0;"
Execution of - aborted due to compilation errors.
########
$_="foo";
printf(STDOUT "%s\n", $_);
EXPECT
foo
########
push(@@a, 1, 2, 3,)
########
quotemeta ""
########
for ("ABCDE") {
 &sub;
s/./&sub($&)/eg;
print;}
sub sub {local($_) = @@_;
$_ x 4;}
EXPECT
Modification of a read-only value attempted at - line 3.
########
package FOO;sub new {bless {FOO => BAR}};
package main;
use strict vars;   
my $self = new FOO;
print $$self{FOO};
EXPECT
BAR
########
$_="foo";
s/.{1}//s;
print;
EXPECT
oo
########
print scalar ("foo","bar")
EXPECT
bar
########
sub by_number { $a <=> $b; };# inline function for sort below
$as_ary{0}="a0";
@@ordered_array=sort by_number keys(%as_ary);
########
sub NewShell
{
  local($Host) = @@_;
  my($m2) = $#Shells++;
  $Shells[$m2]{HOST} = $Host;
  return $m2;
}
 
sub ShowShell
{
  local($i) = @@_;
}
 
&ShowShell(&NewShell(beach,Work,"+0+0"));
&ShowShell(&NewShell(beach,Work,"+0+0"));
&ShowShell(&NewShell(beach,Work,"+0+0"));
########
   {
       package FAKEARRAY;
   
       sub TIEARRAY
       { print "TIEARRAY @@_\n"; 
         die "bomb out\n" unless $count ++ ;
         bless ['foo'] 
       }
       sub FETCH { print "fetch @@_\n"; $_[0]->[$_[1]] }
       sub STORE { print "store @@_\n"; $_[0]->[$_[1]] = $_[2] }
       sub DESTROY { print "DESTROY \n"; undef @@{$_[0]}; }
   }
   
eval 'tie @@h, FAKEARRAY, fred' ;
tie @@h, FAKEARRAY, fred ;
EXPECT
TIEARRAY FAKEARRAY fred
TIEARRAY FAKEARRAY fred
DESTROY 
########
BEGIN { die "phooey\n" }
EXPECT
phooey
BEGIN failed--compilation aborted at - line 1.
########
BEGIN { 1/$zero }
EXPECT
Illegal division by zero at - line 1.
BEGIN failed--compilation aborted at - line 1.
########
BEGIN { undef = 0 }
EXPECT
Modification of a read-only value attempted at - line 1.
BEGIN failed--compilation aborted at - line 1.
########
{
    package foo;
    sub PRINT {
        shift;
        print join(' ', reverse @@_)."\n";
    }
    sub PRINTF {
        shift;
	  my $fmt = shift;
        print sprintf($fmt, @@_)."\n";
    }
    sub TIEHANDLE {
        bless {}, shift;
    }
    sub READLINE {
	"Out of inspiration";
    }
    sub DESTROY {
	print "and destroyed as well\n";
  }
  sub READ {
      shift;
      print STDOUT "foo->can(READ)(@@_)\n";
      return 100; 
  }
  sub GETC {
      shift;
      print STDOUT "Don't GETC, Get Perl\n";
      return "a"; 
  }    
}
{
    local(*FOO);
    tie(*FOO,'foo');
    print FOO "sentence.", "reversed", "a", "is", "This";
    print "-- ", <FOO>, " --\n";
    my($buf,$len,$offset);
    $buf = "string";
    $len = 10; $offset = 1;
    read(FOO, $buf, $len, $offset) == 100 or die "foo->READ failed";
    getc(FOO) eq "a" or die "foo->GETC failed";
    printf "%s is number %d\n", "Perl", 1;
}
EXPECT
This is a reversed sentence.
-- Out of inspiration --
foo->can(READ)(string 10 1)
Don't GETC, Get Perl
Perl is number 1
and destroyed as well
########
my @@a; $a[2] = 1; for (@@a) { $_ = 2 } print "@@a\n"
EXPECT
2 2 2
########
@@a = ($a, $b, $c, $d) = (5, 6);
print "ok\n"
  if ($a[0] == 5 and $a[1] == 6 and !defined $a[2] and !defined $a[3]);
EXPECT
ok
########
print "ok\n" if (1E2<<1 == 200 and 3E4<<3 == 240000);
EXPECT
ok
########
print "ok\n" if ("\0" lt "\xFF");
EXPECT
ok
########
open(H,'op/misc.t'); # must be in the 't' directory
stat(H);
print "ok\n" if (-e _ and -f _ and -r _);
EXPECT
ok
########
sub thing { 0 || return qw(now is the time) }
print thing(), "\n";
EXPECT
nowisthetime
########
$ren = 'joy';
$stimpy = 'happy';
{ local $main::{ren} = *stimpy; print $ren, ' ' }
print $ren, "\n";
EXPECT
happy joy
########
$stimpy = 'happy';
{ local $main::{ren} = *stimpy; print ${'ren'}, ' ' }
print +(defined(${'ren'}) ? 'oops' : 'joy'), "\n";
EXPECT
happy joy
########
package p;
sub func { print 'really ' unless wantarray; 'p' }
sub groovy { 'groovy' }
package main;
print p::func()->groovy(), "\n"
EXPECT
really groovy
########
@@list = ([ 'one', 1 ], [ 'two', 2 ]);
sub func { $num = shift; (grep $_->[1] == $num, @@list)[0] }
print scalar(map &func($_), 1 .. 3), " ",
      scalar(map scalar &func($_), 1 .. 3), "\n";
EXPECT
2 3
########
($k, $s)  = qw(x 0);
@@{$h{$k}} = qw(1 2 4);
for (@@{$h{$k}}) { $s += $_; delete $h{$k} if ($_ == 2) }
print "bogus\n" unless $s == 7;
########
my $a = 'outer';
eval q[ my $a = 'inner'; eval q[ print "$a " ] ];
eval { my $x = 'peace'; eval q[ print "$x\n" ] }
EXPECT
inner peace
########
-w
$| = 1;
sub foo {
    print "In foo1\n";
    eval 'sub foo { print "In foo2\n" }';
    print "Exiting foo1\n";
}
foo;
foo;
EXPECT
In foo1
Subroutine foo redefined at (eval 1) line 1.
Exiting foo1
In foo2
########
$s = 0;
map {#this newline here tickles the bug
$s += $_} (1,2,4);
print "eat flaming death\n" unless ($s == 7);
########
sub foo { local $_ = shift; split; @@_ }
@@x = foo(' x  y  z ');
print "you die joe!\n" unless "@@x" eq 'x y z';
########
/(?{"{"})/	# Check it outside of eval too
EXPECT
Sequence (?{...}) not terminated or not {}-balanced at - line 1, within pattern
Sequence (?{...}) not terminated or not {}-balanced before HERE mark in regex m/(?{ << HERE "{"})/ at - line 1.
########
/(?{"{"}})/	# Check it outside of eval too
EXPECT
Unmatched right curly bracket at (re_eval 1) line 1, at end of line
syntax error at (re_eval 1) line 1, near ""{"}"
Compilation failed in regexp at - line 1.
########
BEGIN { @@ARGV = qw(a b c d e) }
BEGIN { print "argv <@@ARGV>\nbegin <",shift,">\n" }
END { print "end <",shift,">\nargv <@@ARGV>\n" }
INIT { print "init <",shift,">\n" }
CHECK { print "check <",shift,">\n" }
EXPECT
argv <a b c d e>
begin <a>
check <b>
init <c>
end <d>
argv <e>
########
-l
# fdopen from a system descriptor to a system descriptor used to close
# the former.
open STDERR, '>&=STDOUT' or die $!;
select STDOUT; $| = 1; print fileno STDOUT or die $!;
select STDERR; $| = 1; print fileno STDERR or die $!;
EXPECT
1
2
########
-w
sub testme { my $a = "test"; { local $a = "new test"; print $a }}
EXPECT
Can't localize lexical variable $a at - line 2.
########
package X;
sub ascalar { my $r; bless \$r }
sub DESTROY { print "destroyed\n" };
package main;
*s = ascalar X;
EXPECT
destroyed
########
package X;
sub anarray { bless [] }
sub DESTROY { print "destroyed\n" };
package main;
*a = anarray X;
EXPECT
destroyed
########
package X;
sub ahash { bless {} }
sub DESTROY { print "destroyed\n" };
package main;
*h = ahash X;
EXPECT
destroyed
########
package X;
sub aclosure { my $x; bless sub { ++$x } }
sub DESTROY { print "destroyed\n" };
package main;
*c = aclosure X;
EXPECT
destroyed
########
package X;
sub any { bless {} }
my $f = "FH000"; # just to thwart any future optimisations
sub afh { select select ++$f; my $r = *{$f}{IO}; delete $X::{$f}; bless $r }
sub DESTROY { print "destroyed\n" }
package main;
$x = any X; # to bump sv_objcount. IO objs aren't counted??
*f = afh X;
EXPECT
destroyed
destroyed
########
BEGIN {
  $| = 1;
  $SIG{__WARN__} = sub {
    eval { print $_[0] };
    die "bar\n";
  };
  warn "foo\n";
}
EXPECT
foo
bar
BEGIN failed--compilation aborted at - line 8.
########
package X;
@@ISA='Y';
sub new {
    my $class = shift;
    my $self = { };
    bless $self, $class;
    my $init = shift;
    $self->foo($init);
    print "new", $init;
    return $self;
}
sub DESTROY {
    my $self = shift;
    print "DESTROY", $self->foo;
}
package Y;
sub attribute {
    my $self = shift;
    my $var = shift;
    if (@@_ == 0) {
	return $self->{$var};
    } elsif (@@_ == 1) {
	$self->{$var} = shift;
    }
}
sub AUTOLOAD {
    $AUTOLOAD =~ /::([^:]+)$/;
    my $method = $1;
    splice @@_, 1, 0, $method;
    goto &attribute;
}
package main;
my $x = X->new(1);
for (2..3) {
    my $y = X->new($_);
    print $y->foo;
}
print $x->foo;
EXPECT
new1new22DESTROY2new33DESTROY31DESTROY1
########
re();
sub re {
    my $re = join '', eval 'qr/(??{ $obj->method })/';
    $re;
}
EXPECT
########
use strict;
my $foo = "ZZZ\n";
END { print $foo }
EXPECT
ZZZ
########
eval '
use strict;
my $foo = "ZZZ\n";
END { print $foo }
';
EXPECT
ZZZ
########
-w
if (@@ARGV) { print "" }
else {
  if ($x == 0) { print "" } else { print $x }
}
EXPECT
Use of uninitialized value in numeric eq (==) at - line 4.
########
$x = sub {};
foo();
sub foo { eval { return }; }
print "ok\n";
EXPECT
ok
########
my @@l = qw(hello.* world);
my $x;

foreach $x (@@l) {
    print "before - $x\n";
    $x = "\Q$x\E";
    print "quotemeta - $x\n";
    $x = "\u$x";
    print "ucfirst - $x\n";
    $x = "\l$x";
    print "lcfirst - $x\n";
    $x = "\U$x\E";
    print "uc - $x\n";
    $x = "\L$x\E";
    print "lc - $x\n";
}
EXPECT
before - hello.*
quotemeta - hello\.\*
ucfirst - Hello\.\*
lcfirst - hello\.\*
uc - HELLO\.\*
lc - hello\.\*
before - world
quotemeta - world
ucfirst - World
lcfirst - world
uc - WORLD
lc - world
########
sub f { my $a = 1; my $b = 2; my $c = 3; my $d = 4; next }
my $x = "foo";
{ f } continue { print $x, "\n" }
EXPECT
foo
########
sub C () { 1 }
sub M { $_[0] = 2; }
eval "C";
M(C);
EXPECT
Modification of a read-only value attempted at - line 2.
########
print qw(ab a\b a\\b);
EXPECT
aba\ba\b
########
# This test is here instead of pragma/locale.t because
# the bug depends on in the internal state of the locale
# settings and pragma/locale messes up that state pretty badly.
# We need a "fresh run".
BEGIN {
    eval { require POSIX };
    if ($@@) {
	exit(0); # running minitest?
    }
}
use Config;
my $have_setlocale = $Config{d_setlocale} eq 'define';
$have_setlocale = 0 if $@@;
# Visual C's CRT goes silly on strings of the form "en_US.ISO8859-1"
# and mingw32 uses said silly CRT
$have_setlocale = 0 if $^O eq 'MSWin32' && $Config{cc} =~ /^(cl|gcc)/i;
exit(0) unless $have_setlocale;
my @@locales;
if (-x "/usr/bin/locale" && open(LOCALES, "/usr/bin/locale -a|")) {
    while(<LOCALES>) {
        chomp;
        push(@@locales, $_);
    }
    close(LOCALES);
}
exit(0) unless @@locales;
for (@@locales) {
    use POSIX qw(locale_h);
    use locale;
    setlocale(LC_NUMERIC, $_) or next;
    my $s = sprintf "%g %g", 3.1, 3.1;
    next if $s eq '3.1 3.1' || $s =~ /^(3.+1) \1$/;
    print "$_ $s\n";
}
EXPECT
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@@


1.4
log
@perl-5.6.0 + local changes
@
text
@d7 1
a7 1
unshift @@INC, "../lib";
d18 1
a18 1
END { unlink $tmpfile if $tmpfile; }
d29 3
d65 1
a66 1
$cusp = ~0 ^ (~0 >> 1);
d68 1
a68 1
print +($cusp - 1) % 8, $cusp % 8, -$cusp % 8, ($cusp + 1) % 8, "!\n";
d70 1
a70 1
-1 0 0 1 !
d352 1
a352 1
/(?{"{"})/: Sequence (?{...}) not terminated or not {}-balanced at - line 1.
d377 2
a378 2
select STDOUT; $| = 1; print fileno STDOUT;
select STDERR; $| = 1; print fileno STDERR;
d551 53
@


1.3
log
@perl5.005_03 (stock)
@
text
@d7 1
a7 1
@@INC = "../lib";
d28 4
d33 1
a33 1
      open TEST, "| .\\perl -I../lib $switch >$tmpfile 2>&1";
d36 1
a36 1
      open TEST, "| sh -c './perl $switch' >$tmpfile 2>&1";
a37 2
    print TEST $prog, "\n";
    close TEST;
a38 1
    $results = `$CAT $tmpfile`;
d40 2
d46 1
a46 1
    if ( $results ne $expected){
d62 1
d67 1
a67 1
7 0 0 1 !
d84 1
a84 1
chop ($str .= <STDIN>);
d96 1
a96 1
chop($file = <>);
d108 1
a108 1
Can't modify hash deref in repeat at - line 1, near "0;"
d353 1
a353 1
Unmatched right bracket at (re_eval 1) line 1, at end of line
d357 1
a357 1
BEGIN { @@ARGV = qw(a b c) }
d361 1
d363 1
a363 1
argv <a b c>
d365 4
a368 3
init <b>
end <c>
argv <>
d442 48
d503 45
@


1.2
log
@perl 5.004_04
@
text
@d39 3
d67 1
a67 1
Can't call method "go" without a package or object reference at - line 1.
d342 107
a448 8
sub foo { local(@@_) = ('p', 'q', 'r'); }
sub bar { unshift @@_, 'D'; @@_ }
sub baz { push @@_, 'E'; return @@_ }
for (1..3) { print foo('a', 'b', 'c'), bar('d'), baz('e'), "\n" }
EXPECT
pqrDdeE
pqrDdeE
pqrDdeE
@


1.1
log
@Initial revision
@
text
@d3 3
d20 2
d24 2
a25 2
    if (s/^\s*-\w+//){
	$switch = $&;
d28 6
a33 1
    open TEST, "| sh -c './perl $switch' >$tmpfile 2>&1";
d37 1
a37 1
    $results = `cat $tmpfile`;
d50 12
d87 1
a87 1
system "./perl -ne 'print if eof' /dev/null"
d101 2
a102 1
Can't coerce HASH to string in repeat at - line 1.
d195 152
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@a2 3
# NOTE: Please don't add tests to this file unless they *need* to be run in
# separate executable and can't simply use eval.

a16 2
$CAT = (($^O eq 'MSWin32') ? '.\perl -e "print <>"' : 'cat');

d19 2
a20 2
    if (s/^\s*(-\w.*)//){
	$switch = $1;
d23 1
a23 6
    if ($^O eq 'MSWin32') {
      open TEST, "| .\\perl -I../lib $switch >$tmpfile 2>&1";
    }
    else {
      open TEST, "| sh -c './perl $switch' >$tmpfile 2>&1";
    }
d27 1
a27 1
    $results = `$CAT $tmpfile`;
a28 3
# bison says 'parse error' instead of 'syntax error',
# various yaccs may or may not capitalize 'syntax'.
    $results =~ s/^(syntax|parse) error/syntax error/mig;
a39 12
()=()
########
$a = ":="; split /($a)/o, "a:=b:=c"; print "@@_"
EXPECT
a := b := c
########
$cusp = ~0 ^ (~0 >> 1);
$, = " ";
print +($cusp - 1) % 8, $cusp % 8, -$cusp % 8, ($cusp + 1) % 8, "!\n";
EXPECT
7 0 0 1 !
########
d42 1
a42 1
Can't call method "go" on an undefined value at - line 1.
d65 1
a65 1
system './perl -ne "print if eof" /dev/null'
d79 1
a79 2
Can't modify hash deref in repeat at - line 1, near "0;"
Execution of - aborted due to compilation errors.
a171 251
########
{
    package foo;
    sub PRINT {
        shift;
        print join(' ', reverse @@_)."\n";
    }
    sub PRINTF {
        shift;
	  my $fmt = shift;
        print sprintf($fmt, @@_)."\n";
    }
    sub TIEHANDLE {
        bless {}, shift;
    }
    sub READLINE {
	"Out of inspiration";
    }
    sub DESTROY {
	print "and destroyed as well\n";
  }
  sub READ {
      shift;
      print STDOUT "foo->can(READ)(@@_)\n";
      return 100; 
  }
  sub GETC {
      shift;
      print STDOUT "Don't GETC, Get Perl\n";
      return "a"; 
  }    
}
{
    local(*FOO);
    tie(*FOO,'foo');
    print FOO "sentence.", "reversed", "a", "is", "This";
    print "-- ", <FOO>, " --\n";
    my($buf,$len,$offset);
    $buf = "string";
    $len = 10; $offset = 1;
    read(FOO, $buf, $len, $offset) == 100 or die "foo->READ failed";
    getc(FOO) eq "a" or die "foo->GETC failed";
    printf "%s is number %d\n", "Perl", 1;
}
EXPECT
This is a reversed sentence.
-- Out of inspiration --
foo->can(READ)(string 10 1)
Don't GETC, Get Perl
Perl is number 1
and destroyed as well
########
my @@a; $a[2] = 1; for (@@a) { $_ = 2 } print "@@a\n"
EXPECT
2 2 2
########
@@a = ($a, $b, $c, $d) = (5, 6);
print "ok\n"
  if ($a[0] == 5 and $a[1] == 6 and !defined $a[2] and !defined $a[3]);
EXPECT
ok
########
print "ok\n" if (1E2<<1 == 200 and 3E4<<3 == 240000);
EXPECT
ok
########
print "ok\n" if ("\0" lt "\xFF");
EXPECT
ok
########
open(H,'op/misc.t'); # must be in the 't' directory
stat(H);
print "ok\n" if (-e _ and -f _ and -r _);
EXPECT
ok
########
sub thing { 0 || return qw(now is the time) }
print thing(), "\n";
EXPECT
nowisthetime
########
$ren = 'joy';
$stimpy = 'happy';
{ local $main::{ren} = *stimpy; print $ren, ' ' }
print $ren, "\n";
EXPECT
happy joy
########
$stimpy = 'happy';
{ local $main::{ren} = *stimpy; print ${'ren'}, ' ' }
print +(defined(${'ren'}) ? 'oops' : 'joy'), "\n";
EXPECT
happy joy
########
package p;
sub func { print 'really ' unless wantarray; 'p' }
sub groovy { 'groovy' }
package main;
print p::func()->groovy(), "\n"
EXPECT
really groovy
########
@@list = ([ 'one', 1 ], [ 'two', 2 ]);
sub func { $num = shift; (grep $_->[1] == $num, @@list)[0] }
print scalar(map &func($_), 1 .. 3), " ",
      scalar(map scalar &func($_), 1 .. 3), "\n";
EXPECT
2 3
########
($k, $s)  = qw(x 0);
@@{$h{$k}} = qw(1 2 4);
for (@@{$h{$k}}) { $s += $_; delete $h{$k} if ($_ == 2) }
print "bogus\n" unless $s == 7;
########
my $a = 'outer';
eval q[ my $a = 'inner'; eval q[ print "$a " ] ];
eval { my $x = 'peace'; eval q[ print "$x\n" ] }
EXPECT
inner peace
########
-w
$| = 1;
sub foo {
    print "In foo1\n";
    eval 'sub foo { print "In foo2\n" }';
    print "Exiting foo1\n";
}
foo;
foo;
EXPECT
In foo1
Subroutine foo redefined at (eval 1) line 1.
Exiting foo1
In foo2
########
$s = 0;
map {#this newline here tickles the bug
$s += $_} (1,2,4);
print "eat flaming death\n" unless ($s == 7);
########
sub foo { local $_ = shift; split; @@_ }
@@x = foo(' x  y  z ');
print "you die joe!\n" unless "@@x" eq 'x y z';
########
/(?{"{"})/	# Check it outside of eval too
EXPECT
Sequence (?{...}) not terminated or not {}-balanced at - line 1, within pattern
/(?{"{"})/: Sequence (?{...}) not terminated or not {}-balanced at - line 1.
########
/(?{"{"}})/	# Check it outside of eval too
EXPECT
Unmatched right bracket at (re_eval 1) line 1, at end of line
syntax error at (re_eval 1) line 1, near ""{"}"
Compilation failed in regexp at - line 1.
########
BEGIN { @@ARGV = qw(a b c) }
BEGIN { print "argv <@@ARGV>\nbegin <",shift,">\n" }
END { print "end <",shift,">\nargv <@@ARGV>\n" }
INIT { print "init <",shift,">\n" }
EXPECT
argv <a b c>
begin <a>
init <b>
end <c>
argv <>
########
-l
# fdopen from a system descriptor to a system descriptor used to close
# the former.
open STDERR, '>&=STDOUT' or die $!;
select STDOUT; $| = 1; print fileno STDOUT;
select STDERR; $| = 1; print fileno STDERR;
EXPECT
1
2
########
-w
sub testme { my $a = "test"; { local $a = "new test"; print $a }}
EXPECT
Can't localize lexical variable $a at - line 2.
########
package X;
sub ascalar { my $r; bless \$r }
sub DESTROY { print "destroyed\n" };
package main;
*s = ascalar X;
EXPECT
destroyed
########
package X;
sub anarray { bless [] }
sub DESTROY { print "destroyed\n" };
package main;
*a = anarray X;
EXPECT
destroyed
########
package X;
sub ahash { bless {} }
sub DESTROY { print "destroyed\n" };
package main;
*h = ahash X;
EXPECT
destroyed
########
package X;
sub aclosure { my $x; bless sub { ++$x } }
sub DESTROY { print "destroyed\n" };
package main;
*c = aclosure X;
EXPECT
destroyed
########
package X;
sub any { bless {} }
my $f = "FH000"; # just to thwart any future optimisations
sub afh { select select ++$f; my $r = *{$f}{IO}; delete $X::{$f}; bless $r }
sub DESTROY { print "destroyed\n" }
package main;
$x = any X; # to bump sv_objcount. IO objs aren't counted??
*f = afh X;
EXPECT
destroyed
destroyed
########
BEGIN {
  $| = 1;
  $SIG{__WARN__} = sub {
    eval { print $_[0] };
    die "bar\n";
  };
  warn "foo\n";
}
EXPECT
foo
bar
BEGIN failed--compilation aborted at - line 8.
########
use strict;
my $foo = "ZZZ\n";
END { print $foo }
EXPECT
ZZZ
########
eval '
use strict;
my $foo = "ZZZ\n";
END { print $foo }
';
EXPECT
ZZZ
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d7 1
a7 1
unshift @@INC, "../lib";
a27 4
    open TEST, ">$tmpfile" or die "Cannot open $tmpfile: $!";
    print TEST $prog, "\n";
    close TEST or die "Cannot close $tmpfile: $!";

d29 1
a29 1
      $results = `.\\perl -I../lib $switch $tmpfile 2>&1`;
d32 1
a32 1
      $results = `./perl $switch $tmpfile 2>&1`;
d34 2
d37 1
a38 2
    $results =~ s/at\s+misctmp\d+\s+line/at - line/g;
    $results =~ s/of\s+misctmp\d+\s+aborted/of - aborted/g;
d43 1
a43 1
    if ( $results ne $expected ) {
a58 1
use integer;
d63 1
a63 1
-1 0 0 1 !
d80 1
a80 1
chop ($str .= <DATA>);
d92 1
a92 1
chop($file = <DATA>);
d104 1
a104 1
Can't modify hash dereference in repeat (x) at - line 1, near "0;"
d349 1
a349 1
Unmatched right curly bracket at (re_eval 1) line 1, at end of line
d353 1
a353 1
BEGIN { @@ARGV = qw(a b c d e) }
a356 1
CHECK { print "check <",shift,">\n" }
d358 1
a358 1
argv <a b c d e>
d360 3
a362 4
check <b>
init <c>
end <d>
argv <e>
a435 48
package X;
@@ISA='Y';
sub new {
    my $class = shift;
    my $self = { };
    bless $self, $class;
    my $init = shift;
    $self->foo($init);
    print "new", $init;
    return $self;
}
sub DESTROY {
    my $self = shift;
    print "DESTROY", $self->foo;
}
package Y;
sub attribute {
    my $self = shift;
    my $var = shift;
    if (@@_ == 0) {
	return $self->{$var};
    } elsif (@@_ == 1) {
	$self->{$var} = shift;
    }
}
sub AUTOLOAD {
    $AUTOLOAD =~ /::([^:]+)$/;
    my $method = $1;
    splice @@_, 1, 0, $method;
    goto &attribute;
}
package main;
my $x = X->new(1);
for (2..3) {
    my $y = X->new($_);
    print $y->foo;
}
print $x->foo;
EXPECT
new1new22DESTROY2new33DESTROY31DESTROY1
########
re();
sub re {
    my $re = join '', eval 'qr/(??{ $obj->method })/';
    $re;
}
EXPECT
########
a448 45
########
-w
if (@@ARGV) { print "" }
else {
  if ($x == 0) { print "" } else { print $x }
}
EXPECT
Use of uninitialized value in numeric eq (==) at - line 4.
########
$x = sub {};
foo();
sub foo { eval { return }; }
print "ok\n";
EXPECT
ok
########
my @@l = qw(hello.* world);
my $x;

foreach $x (@@l) {
    print "before - $x\n";
    $x = "\Q$x\E";
    print "quotemeta - $x\n";
    $x = "\u$x";
    print "ucfirst - $x\n";
    $x = "\l$x";
    print "lcfirst - $x\n";
    $x = "\U$x\E";
    print "uc - $x\n";
    $x = "\L$x\E";
    print "lc - $x\n";
}
EXPECT
before - hello.*
quotemeta - hello\.\*
ucfirst - Hello\.\*
lcfirst - hello\.\*
uc - HELLO\.\*
lc - hello\.\*
before - world
quotemeta - world
ucfirst - World
lcfirst - world
uc - WORLD
lc - world
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d7 1
a7 1
@@INC = '../lib';
d18 1
a18 1
END { while($tmpfile && unlink $tmpfile){} }
a28 3
    $prog =~ s#/dev/null#NL:# if $^O eq 'VMS';     
    $prog =~ s#if \(-e _ and -f _ and -r _\)#if (-e _ and -f _)# if $^O eq 'VMS';  # VMS file locking 

d62 1
a63 1
use integer;
d65 1
a65 1
print +($cusp - 1) % 8, $cusp % 8, -$cusp % 8, 8 | (($cusp + 1) % 8 + 7), "!\n";
d67 1
a67 1
7 0 0 8 !
d349 1
a349 1
Sequence (?{...}) not terminated or not {}-balanced before HERE mark in regex m/(?{ << HERE "{"})/ at - line 1.
d374 2
a375 2
select STDOUT; $| = 1; print fileno STDOUT or die $!;
select STDERR; $| = 1; print fileno STDERR or die $!;
a547 53
########
sub f { my $a = 1; my $b = 2; my $c = 3; my $d = 4; next }
my $x = "foo";
{ f } continue { print $x, "\n" }
EXPECT
foo
########
sub C () { 1 }
sub M { $_[0] = 2; }
eval "C";
M(C);
EXPECT
Modification of a read-only value attempted at - line 2.
########
print qw(ab a\b a\\b);
EXPECT
aba\ba\b
########
# This test is here instead of pragma/locale.t because
# the bug depends on in the internal state of the locale
# settings and pragma/locale messes up that state pretty badly.
# We need a "fresh run".
BEGIN {
    eval { require POSIX };
    if ($@@) {
	exit(0); # running minitest?
    }
}
use Config;
my $have_setlocale = $Config{d_setlocale} eq 'define';
$have_setlocale = 0 if $@@;
# Visual C's CRT goes silly on strings of the form "en_US.ISO8859-1"
# and mingw32 uses said silly CRT
$have_setlocale = 0 if $^O eq 'MSWin32' && $Config{cc} =~ /^(cl|gcc)/i;
exit(0) unless $have_setlocale;
my @@locales;
if (-x "/usr/bin/locale" && open(LOCALES, "/usr/bin/locale -a|")) {
    while(<LOCALES>) {
        chomp;
        push(@@locales, $_);
    }
    close(LOCALES);
}
exit(0) unless @@locales;
for (@@locales) {
    use POSIX qw(locale_h);
    use locale;
    setlocale(LC_NUMERIC, $_) or next;
    my $s = sprintf "%g %g", 3.1, 3.1;
    next if $s eq '3.1 3.1' || $s =~ /^(3.+1) \1$/;
    print "$_ $s\n";
}
EXPECT
@


