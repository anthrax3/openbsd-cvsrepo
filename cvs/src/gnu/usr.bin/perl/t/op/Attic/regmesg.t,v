head	1.2;
access;
symbols
	OPENBSD_4_4:1.1.1.4.0.18
	OPENBSD_4_4_BASE:1.1.1.4
	OPENBSD_4_3:1.1.1.4.0.16
	OPENBSD_4_3_BASE:1.1.1.4
	OPENBSD_4_2:1.1.1.4.0.14
	OPENBSD_4_2_BASE:1.1.1.4
	OPENBSD_4_1:1.1.1.4.0.12
	OPENBSD_4_1_BASE:1.1.1.4
	OPENBSD_4_0:1.1.1.4.0.10
	OPENBSD_4_0_BASE:1.1.1.4
	PERL_5_8_8:1.1.1.4
	OPENBSD_3_9:1.1.1.4.0.8
	OPENBSD_3_9_BASE:1.1.1.4
	OPENBSD_3_8:1.1.1.4.0.6
	OPENBSD_3_8_BASE:1.1.1.4
	OPENBSD_3_7:1.1.1.4.0.4
	OPENBSD_3_7_BASE:1.1.1.4
	PERL_5_8_6:1.1.1.4
	OPENBSD_3_6:1.1.1.4.0.2
	OPENBSD_3_6_BASE:1.1.1.4
	PERL_5_8_5:1.1.1.4
	PERL_5_8_3:1.1.1.3
	OPENBSD_3_5:1.1.1.3.0.2
	OPENBSD_3_5_BASE:1.1.1.3
	PERL_5_8_2:1.1.1.3
	OPENBSD_3_4:1.1.1.2.0.4
	OPENBSD_3_4_BASE:1.1.1.2
	OPENBSD_3_3:1.1.1.2.0.2
	OPENBSD_3_3_BASE:1.1.1.2
	PERL_5_8_0:1.1.1.2
	OPENBSD_3_2:1.1.1.1.0.6
	OPENBSD_3_2_BASE:1.1.1.1
	OPENBSD_3_1:1.1.1.1.0.4
	OPENBSD_3_1_BASE:1.1.1.1
	OPENBSD_3_0:1.1.1.1.0.2
	OPENBSD_3_0_BASE:1.1.1.1
	PERL_5_6_1:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;


1.2
date	2008.09.29.17.36.20;	author millert;	state dead;
branches;
next	1.1;

1.1
date	2001.05.24.18.25.46;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.05.24.18.25.46;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.10.27.22.15.11;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.12.03.02.44.32;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.08.09.17.48.35;	author millert;	state Exp;
branches;
next	;


desc
@@


1.2
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@#!./perl -w

BEGIN {
	chdir 't' if -d 't';
	@@INC = '../lib';
}

my $debug = 1;

##
## If the markers used are changed (search for "MARKER1" in regcomp.c),
## update only these two variables, and leave the {#} in the @@death/@@warning
## arrays below. The {#} is a meta-marker -- it marks where the marker should
## go.

my $marker1 = "HERE";
my $marker2 = " << HERE ";

##
## Key-value pairs of code/error of code that should have fatal errors.
##

eval 'use Config';         # assume defaults if fail
our %Config;
my $inf_m1 = ($Config{reg_infty} || 32767) - 1;
my $inf_p1 = $inf_m1 + 2;
my @@death =
(
 '/[[=foo=]]/' => 'POSIX syntax [= =] is reserved for future extensions before {#} mark in regex m/[[=foo=]{#}]/',

 '/(?<= .*)/' =>  'Variable length lookbehind not implemented before {#} mark in regex m/(?<= .*){#}/',

 '/(?<= x{1000})/' => 'Lookbehind longer than 255 not implemented before {#} mark in regex m/(?<= x{1000}){#}/',

 '/(?@@)/' => 'Sequence (?@@...) not implemented before {#} mark in regex m/(?@@{#})/',

 '/(?{ 1/' => 'Sequence (?{...}) not terminated or not {}-balanced before {#} mark in regex m/(?{{#} 1/',

 '/(?(1x))/' => 'Switch condition not recognized before {#} mark in regex m/(?(1x{#}))/',

 '/(?(1)x|y|z)/' => 'Switch (?(condition)... contains too many branches before {#} mark in regex m/(?(1)x|y|{#}z)/',

 '/(?(x)y|x)/' => 'Unknown switch condition (?(x) before {#} mark in regex m/(?({#}x)y|x)/',

 '/(?/' => 'Sequence (? incomplete before {#} mark in regex m/(?{#}/',

 '/(?;x/' => 'Sequence (?;...) not recognized before {#} mark in regex m/(?;{#}x/',
 '/(?<;x/' => 'Sequence (?<;...) not recognized before {#} mark in regex m/(?<;{#}x/',

 '/((x)/' => 'Unmatched ( before {#} mark in regex m/({#}(x)/',

 "/x{$inf_p1}/" => "Quantifier in {,} bigger than $inf_m1 before {#} mark in regex m/x{{#}$inf_p1}/",

 '/x{3,1}/' => 'Can\'t do {n,m} with n > m before {#} mark in regex m/x{3,1}{#}/',

 '/x**/' => 'Nested quantifiers before {#} mark in regex m/x**{#}/',

 '/x[/' => 'Unmatched [ before {#} mark in regex m/x[{#}/',

 '/*/', => 'Quantifier follows nothing before {#} mark in regex m/*{#}/',

 '/\p{x/' => 'Missing right brace on \p{} before {#} mark in regex m/\p{{#}x/',

 'use utf8; /[\p{x]/' => 'Missing right brace on \p{} before {#} mark in regex m/[\p{{#}x]/',

 '/(x)\2/' => 'Reference to nonexistent group before {#} mark in regex m/(x)\2{#}/',

 'my $m = "\\\"; $m =~ $m', => 'Trailing \ in regex m/\/',

 '/\x{1/' => 'Missing right brace on \x{} before {#} mark in regex m/\x{{#}1/',

 'use utf8; /[\x{X]/' => 'Missing right brace on \x{} before {#} mark in regex m/[\x{{#}X]/',

 '/[[:barf:]]/' => 'POSIX class [:barf:] unknown before {#} mark in regex m/[[:barf:]{#}]/',

 '/[[=barf=]]/' => 'POSIX syntax [= =] is reserved for future extensions before {#} mark in regex m/[[=barf=]{#}]/',

 '/[[.barf.]]/' => 'POSIX syntax [. .] is reserved for future extensions before {#} mark in regex m/[[.barf.]{#}]/',
  
 '/[z-a]/' => 'Invalid [] range "z-a" before {#} mark in regex m/[z-a{#}]/',
);

##
## Key-value pairs of code/error of code that should have non-fatal warnings.
##
@@warning = (
    "m/(?p{ 'a' })/" => "(?p{}) is deprecated - use (??{}) before {#} mark in regex m/(?p{#}{ 'a' })/",

    'm/\b*/' => '\b* matches null string many times before {#} mark in regex m/\b*{#}/',

    'm/[:blank:]/' => 'POSIX syntax [: :] belongs inside character classes before {#} mark in regex m/[:blank:]{#}/',

    "m'[\\y]'"     => 'Unrecognized escape \y in character class passed through before {#} mark in regex m/[\y{#}]/',

    'm/[a-\d]/' => 'False [] range "a-\d" before {#} mark in regex m/[a-\d{#}]/',
    'm/[\w-x]/' => 'False [] range "\w-" before {#} mark in regex m/[\w-{#}x]/',
    "m'\\y'"     => 'Unrecognized escape \y passed through before {#} mark in regex m/\y{#}/',
);

my $total = (@@death + @@warning)/2;

# utf8 is a noop on EBCDIC platforms, it is not fatal
my $Is_EBCDIC = (ord('A') == 193);
if ($Is_EBCDIC) {
    my @@utf8_death = grep(/utf8/, @@death); 
    $total = $total - scalar(@@utf8_death);
}

print "1..$total\n";

my $count = 0;

while (@@death)
{
    my $regex = shift @@death;
    my $result = shift @@death;
    # skip the utf8 test on EBCDIC since they do not die
    next if ($Is_EBCDIC && $regex =~ /utf8/);
    $count++;

    $_ = "x";
    eval $regex;
    if (not $@@) {
	print "# oops, $regex didn't die\nnot ok $count\n";
	next;
    }
    chomp $@@;
    $result =~ s/{\#}/$marker1/;
    $result =~ s/{\#}/$marker2/;
    if ($@@ !~ /^\Q$result/) {
	print "# For $regex, expected:\n#  $result\n# Got:\n#  $@@\n#\nnot ";
    }
    print "ok $count\n";
}


our $warning;
$SIG{__WARN__} = sub { $warning = shift };

while (@@warning)
{
    $count++;
    my $regex = shift @@warning;
    my $result = shift @@warning;

    undef $warning;
    $_ = "x";
    eval $regex;

    if ($@@)
    {
	print "# oops, $regex died with:\n#\t$@@#\nnot ok $count\n";
	next;
    }

    if (not $warning)
    {
	print "# oops, $regex didn't generate a warning\nnot ok $count\n";
	next;
    }
    $result =~ s/{\#}/$marker1/;
    $result =~ s/{\#}/$marker2/;
    if ($warning !~ /^\Q$result/)
    {
	print <<"EOM";
# For $regex, expected:
#   $result
# Got:
#   $warning
#
not ok $count
EOM
	next;
    }
    print "ok $count\n";
}



@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@stock perl 5.6.1
@
text
@@


1.1.1.2
log
@stock perl 5.8.0 from CPAN
@
text
@d16 2
a17 2
my $marker1 = "<-- HERE";
my $marker2 = " <-- HERE ";
d29 1
a29 1
 '/[[=foo=]]/' => 'POSIX syntax [= =] is reserved for future extensions in regex; marked by {#} in m/[[=foo=]{#}]/',
d31 1
a31 1
 '/(?<= .*)/' =>  'Variable length lookbehind not implemented in regex; marked by {#} in m/(?<= .*){#}/',
d33 1
a33 1
 '/(?<= x{1000})/' => 'Lookbehind longer than 255 not implemented in regex; marked by {#} in m/(?<= x{1000}){#}/',
d35 1
a35 1
 '/(?@@)/' => 'Sequence (?@@...) not implemented in regex; marked by {#} in m/(?@@{#})/',
d37 1
a37 1
 '/(?{ 1/' => 'Sequence (?{...}) not terminated or not {}-balanced in regex; marked by {#} in m/(?{{#} 1/',
d39 1
a39 1
 '/(?(1x))/' => 'Switch condition not recognized in regex; marked by {#} in m/(?(1x{#}))/',
d41 1
a41 1
 '/(?(1)x|y|z)/' => 'Switch (?(condition)... contains too many branches in regex; marked by {#} in m/(?(1)x|y|{#}z)/',
d43 1
a43 1
 '/(?(x)y|x)/' => 'Unknown switch condition (?(x) in regex; marked by {#} in m/(?({#}x)y|x)/',
d45 1
a45 1
 '/(?/' => 'Sequence (? incomplete in regex; marked by {#} in m/(?{#}/',
d47 2
a48 2
 '/(?;x/' => 'Sequence (?;...) not recognized in regex; marked by {#} in m/(?;{#}x/',
 '/(?<;x/' => 'Sequence (?<;...) not recognized in regex; marked by {#} in m/(?<;{#}x/',
d50 1
a50 1
 '/((x)/' => 'Unmatched ( in regex; marked by {#} in m/({#}(x)/',
d52 1
a52 1
 "/x{$inf_p1}/" => "Quantifier in {,} bigger than $inf_m1 in regex; marked by {#} in m/x{{#}$inf_p1}/",
d54 1
a54 1
 '/x{3,1}/' => 'Can\'t do {n,m} with n > m in regex; marked by {#} in m/x{3,1}{#}/',
d56 1
a56 1
 '/x**/' => 'Nested quantifiers in regex; marked by {#} in m/x**{#}/',
d58 1
a58 1
 '/x[/' => 'Unmatched [ in regex; marked by {#} in m/x[{#}/',
d60 1
a60 1
 '/*/', => 'Quantifier follows nothing in regex; marked by {#} in m/*{#}/',
d62 1
a62 1
 '/\p{x/' => 'Missing right brace on \p{} in regex; marked by {#} in m/\p{{#}x/',
d64 1
a64 1
 '/[\p{x]/' => 'Missing right brace on \p{} in regex; marked by {#} in m/[\p{{#}x]/',
d66 1
a66 1
 '/(x)\2/' => 'Reference to nonexistent group in regex; marked by {#} in m/(x)\2{#}/',
d70 1
a70 1
 '/\x{1/' => 'Missing right brace on \x{} in regex; marked by {#} in m/\x{{#}1/',
d72 1
a72 1
 '/[\x{X]/' => 'Missing right brace on \x{} in regex; marked by {#} in m/[\x{{#}X]/',
d74 1
a74 1
 '/[[:barf:]]/' => 'POSIX class [:barf:] unknown in regex; marked by {#} in m/[[:barf:]{#}]/',
d76 1
a76 1
 '/[[=barf=]]/' => 'POSIX syntax [= =] is reserved for future extensions in regex; marked by {#} in m/[[=barf=]{#}]/',
d78 1
a78 1
 '/[[.barf.]]/' => 'POSIX syntax [. .] is reserved for future extensions in regex; marked by {#} in m/[[.barf.]{#}]/',
d80 1
a80 5
 '/[z-a]/' => 'Invalid [] range "z-a" in regex; marked by {#} in m/[z-a{#}]/',

 '/\p/' => 'Empty \p{} in regex; marked by {#} in m/\p{#}/',

 '/\P{}/' => 'Empty \P{} in regex; marked by {#} in m/\P{{#}}/',
d87 1
a87 1
    "m/(?p{ 'a' })/" => "(?p{}) is deprecated - use (??{}) in regex; marked by {#} in m/(?p{#}{ 'a' })/",
d89 1
a89 1
    'm/\b*/' => '\b* matches null string many times in regex; marked by {#} in m/\b*{#}/',
d91 1
a91 1
    'm/[:blank:]/' => 'POSIX syntax [: :] belongs inside character classes in regex; marked by {#} in m/[:blank:]{#}/',
d93 1
a93 1
    "m'[\\y]'"     => 'Unrecognized escape \y in character class passed through in regex; marked by {#} in m/[\y{#}]/',
d95 3
a97 3
    'm/[a-\d]/' => 'False [] range "a-\d" in regex; marked by {#} in m/[a-\d{#}]/',
    'm/[\w-x]/' => 'False [] range "\w-" in regex; marked by {#} in m/[\w-{#}x]/',
    "m'\\y'"     => 'Unrecognized escape \y passed through in regex; marked by {#} in m/\y{#}/',
d106 1
a106 1
    $total = $total - @@utf8_death;
d133 1
a133 1
    print "ok $count - $regex\n";
d175 1
a175 1
    print "ok $count - $regex\n";
@


1.1.1.3
log
@perl 5.8.2 from CPAN
@
text
@a133 1
    $result .= " at ";
a166 1
    $result .= " at ";
@


1.1.1.4
log
@Import of stock perl 5.8.5
@
text
@a100 2
    'm/[a-\pM]/' => 'False [] range "a-\pM" in regex; marked by {#} in m/[a-\pM{#}]/',
    'm/[\pM-x]/' => 'False [] range "\pM-" in regex; marked by {#} in m/[\pM-{#}x]/',
@


