head	1.11;
access;
symbols
	OPENBSD_4_8:1.10.0.4
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.2
	OPENBSD_4_7_BASE:1.10
	PERL_5_10_1:1.1.1.9
	OPENBSD_4_6:1.9.0.6
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.2
	OPENBSD_4_5_BASE:1.9
	PERL_5_10_0:1.1.1.8
	OPENBSD_4_4:1.8.0.10
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.8
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.6
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.4
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.2
	OPENBSD_4_0_BASE:1.8
	PERL_5_8_8:1.1.1.7
	OPENBSD_3_9:1.7.0.10
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.8
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.6
	OPENBSD_3_7_BASE:1.7
	PERL_5_8_6:1.1.1.6
	OPENBSD_3_6:1.7.0.4
	OPENBSD_3_6_BASE:1.7
	PERL_5_8_5:1.1.1.6
	PERL_5_8_3:1.1.1.6
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;


1.11
date	2010.09.24.15.00.00;	author millert;	state dead;
branches;
next	1.10;

1.10
date	2009.10.12.18.30.28;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2008.09.29.17.36.20;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2006.03.28.19.23.13;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.49;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.37;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.36.23;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.08.33;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.52.39;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.08.05.45;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.13.23;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.13.23;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.41.52;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.10.51;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.25.47;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.15.11;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.44.33;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2006.03.28.18.49.47;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2008.09.29.17.19.02;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2009.10.12.18.10.44;	author millert;	state Exp;
branches;
next	;


desc
@@


1.11
log
@remove files no longer in perl 5.12.2 (or that have moved)
@
text
@#!./perl -w

BEGIN {
    chdir 't' if -d 't';
    @@INC = '../lib';
    require Config; import Config;
}

require './test.pl';
plan( tests => 139 );

$x = 'foo';
$_ = "x";
s/x/\$x/;
ok( $_ eq '$x', ":$_: eq :\$x:" );

$_ = "x";
s/x/$x/;
ok( $_ eq 'foo', ":$_: eq :foo:" );

$_ = "x";
s/x/\$x $x/;
ok( $_ eq '$x foo', ":$_: eq :\$x foo:" );

$b = 'cd';
($a = 'abcdef') =~ s<(b${b}e)>'\n$1';
ok( $1 eq 'bcde' && $a eq 'a\n$1f', ":$1: eq :bcde: ; :$a: eq :a\\n\$1f:" );

$a = 'abacada';
ok( ($a =~ s/a/x/g) == 4 && $a eq 'xbxcxdx' );

ok( ($a =~ s/a/y/g) == 0 && $a eq 'xbxcxdx' );

ok( ($a =~ s/b/y/g) == 1 && $a eq 'xyxcxdx' );

$_ = 'ABACADA';
ok( /a/i && s///gi && $_ eq 'BCD' );

$_ = '\\' x 4;
ok( length($_) == 4 );
$snum = s/\\/\\\\/g;
ok( $_ eq '\\' x 8 && $snum == 4 );

$_ = '\/' x 4;
ok( length($_) == 8 );
$snum = s/\//\/\//g;
ok( $_ eq '\\//' x 4 && $snum == 4 );
ok( length($_) == 12 );

$_ = 'aaaXXXXbbb';
s/^a//;
ok( $_ eq 'aaXXXXbbb' );

$_ = 'aaaXXXXbbb';
s/a//;
ok( $_ eq 'aaXXXXbbb' );

$_ = 'aaaXXXXbbb';
s/^a/b/;
ok( $_ eq 'baaXXXXbbb' );

$_ = 'aaaXXXXbbb';
s/a/b/;
ok( $_ eq 'baaXXXXbbb' );

$_ = 'aaaXXXXbbb';
s/aa//;
ok( $_ eq 'aXXXXbbb' );

$_ = 'aaaXXXXbbb';
s/aa/b/;
ok( $_ eq 'baXXXXbbb' );

$_ = 'aaaXXXXbbb';
s/b$//;
ok( $_ eq 'aaaXXXXbb' );

$_ = 'aaaXXXXbbb';
s/b//;
ok( $_ eq 'aaaXXXXbb' );

$_ = 'aaaXXXXbbb';
s/bb//;
ok( $_ eq 'aaaXXXXb' );

$_ = 'aaaXXXXbbb';
s/aX/y/;
ok( $_ eq 'aayXXXbbb' );

$_ = 'aaaXXXXbbb';
s/Xb/z/;
ok( $_ eq 'aaaXXXzbb' );

$_ = 'aaaXXXXbbb';
s/aaX.*Xbb//;
ok( $_ eq 'ab' );

$_ = 'aaaXXXXbbb';
s/bb/x/;
ok( $_ eq 'aaaXXXXxb' );

# now for some unoptimized versions of the same.

$_ = 'aaaXXXXbbb';
$x ne $x || s/^a//;
ok( $_ eq 'aaXXXXbbb' );

$_ = 'aaaXXXXbbb';
$x ne $x || s/a//;
ok( $_ eq 'aaXXXXbbb' );

$_ = 'aaaXXXXbbb';
$x ne $x || s/^a/b/;
ok( $_ eq 'baaXXXXbbb' );

$_ = 'aaaXXXXbbb';
$x ne $x || s/a/b/;
ok( $_ eq 'baaXXXXbbb' );

$_ = 'aaaXXXXbbb';
$x ne $x || s/aa//;
ok( $_ eq 'aXXXXbbb' );

$_ = 'aaaXXXXbbb';
$x ne $x || s/aa/b/;
ok( $_ eq 'baXXXXbbb' );

$_ = 'aaaXXXXbbb';
$x ne $x || s/b$//;
ok( $_ eq 'aaaXXXXbb' );

$_ = 'aaaXXXXbbb';
$x ne $x || s/b//;
ok( $_ eq 'aaaXXXXbb' );

$_ = 'aaaXXXXbbb';
$x ne $x || s/bb//;
ok( $_ eq 'aaaXXXXb' );

$_ = 'aaaXXXXbbb';
$x ne $x || s/aX/y/;
ok( $_ eq 'aayXXXbbb' );

$_ = 'aaaXXXXbbb';
$x ne $x || s/Xb/z/;
ok( $_ eq 'aaaXXXzbb' );

$_ = 'aaaXXXXbbb';
$x ne $x || s/aaX.*Xbb//;
ok( $_ eq 'ab' );

$_ = 'aaaXXXXbbb';
$x ne $x || s/bb/x/;
ok( $_ eq 'aaaXXXXxb' );

$_ = 'abc123xyz';
s/(\d+)/$1*2/e;              # yields 'abc246xyz'
ok( $_ eq 'abc246xyz' );
s/(\d+)/sprintf("%5d",$1)/e; # yields 'abc  246xyz'
ok( $_ eq 'abc  246xyz' );
s/(\w)/$1 x 2/eg;            # yields 'aabbcc  224466xxyyzz'
ok( $_ eq 'aabbcc  224466xxyyzz' );

$_ = "aaaaa";
ok( y/a/b/ == 5 );
ok( y/a/b/ == 0 );
ok( y/b// == 5 );
ok( y/b/c/s == 5 );
ok( y/c// == 1 );
ok( y/c//d == 1 );
ok( $_ eq "" );

$_ = "Now is the %#*! time for all good men...";
ok( ($x=(y/a-zA-Z //cd)) == 7 );
ok( y/ / /s == 8 );

$_ = 'abcdefghijklmnopqrstuvwxyz0123456789';
tr/a-z/A-Z/;

ok( $_ eq 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789' );

# same as tr/A-Z/a-z/;
if (defined $Config{ebcdic} && $Config{ebcdic} eq 'define') {	# EBCDIC.
    no utf8;
    y[\301-\351][\201-\251];
} else {		# Ye Olde ASCII.  Or something like it.
    y[\101-\132][\141-\172];
}

ok( $_ eq 'abcdefghijklmnopqrstuvwxyz0123456789' );

SKIP: {
    skip("not ASCII",1) unless (ord("+") == ord(",") - 1
			     && ord(",") == ord("-") - 1
			     && ord("a") == ord("b") - 1
			     && ord("b") == ord("c") - 1);
    $_ = '+,-';
    tr/+--/a-c/;
    ok( $_ eq 'abc' );
}

$_ = '+,-';
tr/+\--/a\/c/;
ok( $_ eq 'a,/' );

$_ = '+,-';
tr/-+,/ab\-/;
ok( $_ eq 'b-a' );


# test recursive substitutions
# code based on the recursive expansion of makefile variables

my %MK = (
    AAAAA => '$(B)', B=>'$(C)', C => 'D',			# long->short
    E     => '$(F)', F=>'p $(G) q', G => 'HHHHH',	# short->long
    DIR => '$(UNDEFINEDNAME)/xxx',
);
sub var { 
    my($var,$level) = @@_;
    return "\$($var)" unless exists $MK{$var};
    return exp_vars($MK{$var}, $level+1); # can recurse
}
sub exp_vars { 
    my($str,$level) = @@_;
    $str =~ s/\$\((\w+)\)/var($1, $level+1)/ge; # can recurse
    #warn "exp_vars $level = '$str'\n";
    $str;
}

ok( exp_vars('$(AAAAA)',0)           eq 'D' );
ok( exp_vars('$(E)',0)               eq 'p HHHHH q' );
ok( exp_vars('$(DIR)',0)             eq '$(UNDEFINEDNAME)/xxx' );
ok( exp_vars('foo $(DIR)/yyy bar',0) eq 'foo $(UNDEFINEDNAME)/xxx/yyy bar' );

$_ = "abcd";
s/(..)/$x = $1, m#.#/eg;
ok( $x eq "cd", 'a match nested in the RHS of a substitution' );

# Subst and lookbehind

$_="ccccc";
$snum = s/(?<!x)c/x/g;
ok( $_ eq "xxxxx" && $snum == 5 );

$_="ccccc";
$snum = s/(?<!x)(c)/x/g;
ok( $_ eq "xxxxx" && $snum == 5 );

$_="foobbarfoobbar";
$snum = s/(?<!r)foobbar/foobar/g;
ok( $_ eq "foobarfoobbar" && $snum == 1 );

$_="foobbarfoobbar";
$snum = s/(?<!ar)(foobbar)/foobar/g;
ok( $_ eq "foobarfoobbar" && $snum == 1 );

$_="foobbarfoobbar";
$snum = s/(?<!ar)foobbar/foobar/g;
ok( $_ eq "foobarfoobbar" && $snum == 1 );

eval 's{foo} # this is a comment, not a delimiter
       {bar};';
ok( ! @@?, 'parsing of split subst with comment' );

$_="baacbaa";
$snum = tr/a/b/s;
ok( $_ eq "bbcbb" && $snum == 4,
    'check if squashing works at the end of string' );

$_ = "ab";
ok( s/a/b/ == 1 );

$_ = <<'EOL';
     $url = new URI::URL "http://www/";   die if $url eq "xXx";
EOL
$^R = 'junk';

$foo = ' $@@%#lowercase $@@%# lowercase UPPERCASE$@@%#UPPERCASE' .
  ' $@@%#lowercase$@@%#lowercase$@@%# lowercase lowercase $@@%#lowercase' .
  ' lowercase $@@%#MiXeD$@@%# ';

$snum =
s{  \d+          \b [,.;]? (?{ 'digits' })
   |
    [a-z]+       \b [,.;]? (?{ 'lowercase' })
   |
    [A-Z]+       \b [,.;]? (?{ 'UPPERCASE' })
   |
    [A-Z] [a-z]+ \b [,.;]? (?{ 'Capitalized' })
   |
    [A-Za-z]+    \b [,.;]? (?{ 'MiXeD' })
   |
    [A-Za-z0-9]+ \b [,.;]? (?{ 'alphanumeric' })
   |
    \s+                    (?{ ' ' })
   |
    [^A-Za-z0-9\s]+          (?{ '$@@%#' })
}{$^R}xg;
ok( $_ eq $foo );
ok( $snum == 31 );

$_ = 'a' x 6;
$snum = s/a(?{})//g;
ok( $_ eq '' && $snum == 6 );

$_ = 'x' x 20; 
$snum = s/(\d*|x)/<$1>/g; 
$foo = '<>' . ('<x><>' x 20) ;
ok( $_ eq $foo && $snum == 41 );

$t = 'aaaaaaaaa'; 

$_ = $t;
pos = 6;
$snum = s/\Ga/xx/g;
ok( $_ eq 'aaaaaaxxxxxx' && $snum == 3 );

$_ = $t;
pos = 6;
$snum = s/\Ga/x/g;
ok( $_ eq 'aaaaaaxxx' && $snum == 3 );

$_ = $t;
pos = 6;
s/\Ga/xx/;
ok( $_ eq 'aaaaaaxxaa' );

$_ = $t;
pos = 6;
s/\Ga/x/;
ok( $_ eq 'aaaaaaxaa' );

$_ = $t;
$snum = s/\Ga/xx/g;
ok( $_ eq 'xxxxxxxxxxxxxxxxxx' && $snum == 9 );

$_ = $t;
$snum = s/\Ga/x/g;
ok( $_ eq 'xxxxxxxxx' && $snum == 9 );

$_ = $t;
s/\Ga/xx/;
ok( $_ eq 'xxaaaaaaaa' );

$_ = $t;
s/\Ga/x/;
ok( $_ eq 'xaaaaaaaa' );

$_ = 'aaaa';
$snum = s/\ba/./g;
ok( $_ eq '.aaa' && $snum == 1 );

eval q% s/a/"b"}/e %;
ok( $@@ =~ /Bad evalled substitution/ );
eval q% ($_ = "x") =~ s/(.)/"$1 "/e %;
ok( $_ eq "x " and !length $@@ );
$x = $x = 'interp';
eval q% ($_ = "x") =~ s/x(($x)*)/"$1"/e %;
ok( $_ eq '' and !length $@@ );

$_ = "C:/";
ok( !s/^([a-z]:)/\u$1/ );

$_ = "Charles Bronson";
$snum = s/\B\w//g;
ok( $_ eq "C B" && $snum == 12 );

{
    use utf8;
    my $s = "H\303\266he";
    my $l = my $r = $s;
    $l =~ s/[^\w]//g;
    $r =~ s/[^\w\.]//g;
    is($l, $r, "use utf8 \\w");
}

my $pv1 = my $pv2  = "Andreas J. K\303\266nig";
$pv1 =~ s/A/\x{100}/;
substr($pv2,0,1) = "\x{100}";
is($pv1, $pv2);

SKIP: {
    skip("EBCDIC", 3) if ord("A") == 193; 

    {   
	# Gregor Chrupala <gregor.chrupala@@star-group.net>
	use utf8;
	$a = 'Espa&ntilde;a';
	$a =~ s/&ntilde;/ñ/;
	like($a, qr/ñ/, "use utf8 RHS");
    }

    {
	use utf8;
	$a = 'España España';
	$a =~ s/ñ/&ntilde;/;
	like($a, qr/ñ/, "use utf8 LHS");
    }

    {
	use utf8;
	$a = 'España';
	$a =~ s/ñ/ñ/;
	like($a, qr/ñ/, "use utf8 LHS and RHS");
    }
}

{
    # SADAHIRO Tomoyuki <bqw10602@@nifty.com>

    $a = "\x{100}\x{101}";
    $a =~ s/\x{101}/\xFF/;
    like($a, qr/\xFF/);
    is(length($a), 2, "SADAHIRO utf8 s///");

    $a = "\x{100}\x{101}";
    $a =~ s/\x{101}/"\xFF"/e;
    like($a, qr/\xFF/);
    is(length($a), 2);

    $a = "\x{100}\x{101}";
    $a =~ s/\x{101}/\xFF\xFF\xFF/;
    like($a, qr/\xFF\xFF\xFF/);
    is(length($a), 4);

    $a = "\x{100}\x{101}";
    $a =~ s/\x{101}/"\xFF\xFF\xFF"/e;
    like($a, qr/\xFF\xFF\xFF/);
    is(length($a), 4);

    $a = "\xFF\x{101}";
    $a =~ s/\xFF/\x{100}/;
    like($a, qr/\x{100}/);
    is(length($a), 2);

    $a = "\xFF\x{101}";
    $a =~ s/\xFF/"\x{100}"/e;
    like($a, qr/\x{100}/);
    is(length($a), 2);

    $a = "\xFF";
    $a =~ s/\xFF/\x{100}/;
    like($a, qr/\x{100}/);
    is(length($a), 1);

    $a = "\xFF";
    $a =~ s/\xFF/"\x{100}"/e;
    like($a, qr/\x{100}/);
    is(length($a), 1);
}

{
    # subst with mixed utf8/non-utf8 type
    my($ua, $ub, $uc, $ud) = ("\x{101}", "\x{102}", "\x{103}", "\x{104}");
    my($na, $nb) = ("\x{ff}", "\x{fe}");
    my $a = "$ua--$ub";
    my $b;
    ($b = $a) =~ s/--/$na/;
    is($b, "$ua$na$ub", "s///: replace non-utf8 into utf8");
    ($b = $a) =~ s/--/--$na--/;
    is($b, "$ua--$na--$ub", "s///: replace long non-utf8 into utf8");
    ($b = $a) =~ s/--/$uc/;
    is($b, "$ua$uc$ub", "s///: replace utf8 into utf8");
    ($b = $a) =~ s/--/--$uc--/;
    is($b, "$ua--$uc--$ub", "s///: replace long utf8 into utf8");
    $a = "$na--$nb";
    ($b = $a) =~ s/--/$ua/;
    is($b, "$na$ua$nb", "s///: replace utf8 into non-utf8");
    ($b = $a) =~ s/--/--$ua--/;
    is($b, "$na--$ua--$nb", "s///: replace long utf8 into non-utf8");

    # now with utf8 pattern
    $a = "$ua--$ub";
    ($b = $a) =~ s/-($ud)?-/$na/;
    is($b, "$ua$na$ub", "s///: replace non-utf8 into utf8 (utf8 pattern)");
    ($b = $a) =~ s/-($ud)?-/--$na--/;
    is($b, "$ua--$na--$ub", "s///: replace long non-utf8 into utf8 (utf8 pattern)");
    ($b = $a) =~ s/-($ud)?-/$uc/;
    is($b, "$ua$uc$ub", "s///: replace utf8 into utf8 (utf8 pattern)");
    ($b = $a) =~ s/-($ud)?-/--$uc--/;
    is($b, "$ua--$uc--$ub", "s///: replace long utf8 into utf8 (utf8 pattern)");
    $a = "$na--$nb";
    ($b = $a) =~ s/-($ud)?-/$ua/;
    is($b, "$na$ua$nb", "s///: replace utf8 into non-utf8 (utf8 pattern)");
    ($b = $a) =~ s/-($ud)?-/--$ua--/;
    is($b, "$na--$ua--$nb", "s///: replace long utf8 into non-utf8 (utf8 pattern)");
    ($b = $a) =~ s/-($ud)?-/$na/;
    is($b, "$na$na$nb", "s///: replace non-utf8 into non-utf8 (utf8 pattern)");
    ($b = $a) =~ s/-($ud)?-/--$na--/;
    is($b, "$na--$na--$nb", "s///: replace long non-utf8 into non-utf8 (utf8 pattern)");
}

$_ = 'aaaa';
$r = 'x';
$s = s/a(?{})/$r/g;
is("<$_> <$s>", "<xxxx> <4>", "[perl #7806]");

$_ = 'aaaa';
$s = s/a(?{})//g;
is("<$_> <$s>", "<> <4>", "[perl #7806]");

# [perl #19048] Coredump in silly replacement
{
    local $^W = 0;
    $_="abcdef\n";
    s!.!!eg;
    is($_, "\n", "[perl #19048]");
}

# [perl #17757] interaction between saw_ampersand and study
{
    my $f = eval q{ $& };
    $f = "xx";
    study $f;
    $f =~ s/x/y/g;
    is($f, "yy", "[perl #17757]");
}

# [perl #20684] returned a zero count
$_ = "1111";
is(s/(??{1})/2/eg, 4, '#20684 s/// with (??{..}) inside');

# [perl #20682] @@- not visible in replacement
$_ = "123";
/(2)/;	# seed @@- with something else
s/(1)(2)(3)/$#- (@@-)/;
is($_, "3 (0 0 1 2)", '#20682 @@- not visible in replacement');

# [perl #20682] $^N not visible in replacement
$_ = "abc";
/(a)/; s/(b)|(c)/-$^N/g;
is($_,'a-b-c','#20682 $^N not visible in replacement');

# [perl #22351] perl bug with 'e' substitution modifier
my $name = "chris";
{
    no warnings 'uninitialized';
    $name =~ s/hr//e;
}
is($name, "cis", q[#22351 bug with 'e' substitution modifier]);


# [perl #34171] $1 didn't honour 'use bytes' in s//e
{
    my $s="\x{100}";
    my $x;
    {
	use bytes;
	$s=~ s/(..)/$x=$1/e
    }
    is(length($x), 2, '[perl #34171]');
}


{ # [perl #27940] perlbug: [\x00-\x1f] works, [\c@@-\c_] does not
    my $c;

    ($c = "\x20\c@@\x30\cA\x40\cZ\x50\c_\x60") =~ s/[\c@@-\c_]//g;
    is($c, "\x20\x30\x40\x50\x60", "s/[\\c\@@-\\c_]//g");

    ($c = "\x20\x00\x30\x01\x40\x1A\x50\x1F\x60") =~ s/[\x00-\x1f]//g;
    is($c, "\x20\x30\x40\x50\x60", "s/[\\x00-\\x1f]//g");
}
{
    $_ = "xy";
    no warnings 'uninitialized';
    /(((((((((x)))))))))(z)/;	# clear $10
    s/(((((((((x)))))))))(y)/${10}/;
    is($_,"y","RT#6006: \$_ eq '$_'");
    $_ = "xr";
    s/(((((((((x)))))))))(r)/fooba${10}/;
    is($_,"foobar","RT#6006: \$_ eq '$_'");
}
{
    my $want=("\n" x 11).("B\n" x 11)."B";
    $_="B";
    our $i;
    for $i(1..11){
	s/^.*$/$&/gm;
	$_="\n$_\n$&";
    }
    is($want,$_,"RT#17542");
}

{
    my @@tests = ('ABC', "\xA3\xA4\xA5", "\x{410}\x{411}\x{412}");
    foreach (@@tests) {
	my $id = ord $_;
	s/./pos/ge;
	is($_, "012", "RT#52104: $id");
    }
}
@


1.10
log
@Merge in perl 5.10.1; part two
@
text
@@


1.9
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d10 1
a10 1
plan( tests => 136 );
d586 8
@


1.8
log
@merge in perl 5.8.8
@
text
@d1 1
a1 1
#!./perl -wT
d10 1
a10 1
plan( tests => 131 );
d555 30
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d10 1
a10 1
plan( tests => 130 );
d542 14
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d10 1
a10 1
plan( tests => 122 );
d494 48
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d1 1
a1 1
#!./perl
d9 2
a10 1
print "1..84\n";
d15 1
a15 2
print "#1\t:$_: eq :\$x:\n";
if ($_ eq '$x') {print "ok 1\n";} else {print "not ok 1\n";}
d19 1
a19 2
print "#2\t:$_: eq :foo:\n";
if ($_ eq 'foo') {print "ok 2\n";} else {print "not ok 2\n";}
d23 1
a23 2
print "#3\t:$_: eq :\$x foo:\n";
if ($_ eq '$x foo') {print "ok 3\n";} else {print "not ok 3\n";}
d27 1
a27 3
print "#4\t:$1: eq :bcde:\n";
print "#4\t:$a: eq :a\\n\$1f:\n";
if ($1 eq 'bcde' && $a eq 'a\n$1f') {print "ok 4\n";} else {print "not ok 4\n";}
d30 1
a30 2
if (($a =~ s/a/x/g) == 4 && $a eq 'xbxcxdx')
    {print "ok 5\n";} else {print "not ok 5\n";}
d32 1
a32 2
if (($a =~ s/a/y/g) == 0 && $a eq 'xbxcxdx')
    {print "ok 6\n";} else {print "not ok 6 $a\n";}
d34 1
a34 2
if (($a =~ s/b/y/g) == 1 && $a eq 'xyxcxdx')
    {print "ok 7\n";} else {print "not ok 7 $a\n";}
d37 1
a37 1
if (/a/i && s///gi && $_ eq 'BCD') {print "ok 8\n";} else {print "not ok 8 $_\n";}
d40 3
a42 3
if (length($_) == 4) {print "ok 9\n";} else {print "not ok 9\n";}
s/\\/\\\\/g;
if ($_ eq '\\' x 8) {print "ok 10\n";} else {print "not ok 10 $_\n";}
d45 4
a48 4
if (length($_) == 8) {print "ok 11\n";} else {print "not ok 11\n";}
s/\//\/\//g;
if ($_ eq '\\//' x 4) {print "ok 12\n";} else {print "not ok 12\n";}
if (length($_) == 12) {print "ok 13\n";} else {print "not ok 13\n";}
d52 1
a52 1
print $_ eq 'aaXXXXbbb' ? "ok 14\n" : "not ok 14\n";
d56 1
a56 1
print $_ eq 'aaXXXXbbb' ? "ok 15\n" : "not ok 15\n";
d60 1
a60 1
print $_ eq 'baaXXXXbbb' ? "ok 16\n" : "not ok 16\n";
d64 1
a64 1
print $_ eq 'baaXXXXbbb' ? "ok 17\n" : "not ok 17\n";
d68 1
a68 1
print $_ eq 'aXXXXbbb' ? "ok 18\n" : "not ok 18\n";
d72 1
a72 1
print $_ eq 'baXXXXbbb' ? "ok 19\n" : "not ok 19\n";
d76 1
a76 1
print $_ eq 'aaaXXXXbb' ? "ok 20\n" : "not ok 20\n";
d80 1
a80 1
print $_ eq 'aaaXXXXbb' ? "ok 21\n" : "not ok 21\n";
d84 1
a84 1
print $_ eq 'aaaXXXXb' ? "ok 22\n" : "not ok 22\n";
d88 1
a88 1
print $_ eq 'aayXXXbbb' ? "ok 23\n" : "not ok 23\n";
d92 1
a92 1
print $_ eq 'aaaXXXzbb' ? "ok 24\n" : "not ok 24\n";
d96 1
a96 1
print $_ eq 'ab' ? "ok 25\n" : "not ok 25\n";
d100 1
a100 1
print $_ eq 'aaaXXXXxb' ? "ok 26\n" : "not ok 26\n";
d106 1
a106 1
print $_ eq 'aaXXXXbbb' ? "ok 27\n" : "not ok 27\n";
d110 1
a110 1
print $_ eq 'aaXXXXbbb' ? "ok 28\n" : "not ok 28\n";
d114 1
a114 1
print $_ eq 'baaXXXXbbb' ? "ok 29\n" : "not ok 29\n";
d118 1
a118 1
print $_ eq 'baaXXXXbbb' ? "ok 30\n" : "not ok 30\n";
d122 1
a122 1
print $_ eq 'aXXXXbbb' ? "ok 31\n" : "not ok 31\n";
d126 1
a126 1
print $_ eq 'baXXXXbbb' ? "ok 32\n" : "not ok 32\n";
d130 1
a130 1
print $_ eq 'aaaXXXXbb' ? "ok 33\n" : "not ok 33\n";
d134 1
a134 1
print $_ eq 'aaaXXXXbb' ? "ok 34\n" : "not ok 34\n";
d138 1
a138 1
print $_ eq 'aaaXXXXb' ? "ok 35\n" : "not ok 35\n";
d142 1
a142 1
print $_ eq 'aayXXXbbb' ? "ok 36\n" : "not ok 36\n";
d146 1
a146 1
print $_ eq 'aaaXXXzbb' ? "ok 37\n" : "not ok 37\n";
d150 1
a150 1
print $_ eq 'ab' ? "ok 38\n" : "not ok 38\n";
d154 1
a154 1
print $_ eq 'aaaXXXXxb' ? "ok 39\n" : "not ok 39\n";
d158 1
a158 1
print $_ eq 'abc246xyz' ? "ok 40\n" : "not ok 40\n";
d160 1
a160 1
print $_ eq 'abc  246xyz' ? "ok 41\n" : "not ok 41\n";
d162 1
a162 1
print $_ eq 'aabbcc  224466xxyyzz' ? "ok 42\n" : "not ok 42\n";
d165 7
a171 7
print y/a/b/ == 5 ? "ok 43\n" : "not ok 43\n";
print y/a/b/ == 0 ? "ok 44\n" : "not ok 44\n";
print y/b// == 5 ? "ok 45\n" : "not ok 45\n";
print y/b/c/s == 5 ? "ok 46\n" : "not ok 46\n";
print y/c// == 1 ? "ok 47\n" : "not ok 47\n";
print y/c//d == 1 ? "ok 48\n" : "not ok 48\n";
print $_ eq "" ? "ok 49\n" : "not ok 49\n";
d174 2
a175 2
print (($x=(y/a-zA-Z //cd)) == 7 ? "ok 50\n" : "not ok 50\n");
print y/ / /s == 8 ? "ok 51\n" : "not ok 51\n";
d180 1
a180 1
print $_ eq 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789' ? "ok 52\n" : "not ok 52\n";
d183 1
a183 1
if ($Config{ebcdic} eq 'define') {	# EBCDIC.
d190 1
a190 1
print $_ eq 'abcdefghijklmnopqrstuvwxyz0123456789' ? "ok 53\n" : "not ok 53\n";
d192 8
a199 5
if (ord("+") == ord(",") - 1 && ord(",") == ord("-") - 1 &&
    ord("a") == ord("b") - 1 && ord("b") == ord("c") - 1) {
  $_ = '+,-';
  tr/+--/a-c/;
  print "not " unless $_ eq 'abc';
a200 1
print "ok 54\n";
d204 1
a204 1
print $_ eq 'a,/' ? "ok 55\n" : "not ok 55\n";
d208 1
a208 1
print $_ eq 'b-a' ? "ok 56\n" : "not ok 56\n";
d231 4
a234 10
print exp_vars('$(AAAAA)',0)           eq 'D'
	? "ok 57\n" : "not ok 57\n";
print exp_vars('$(E)',0)               eq 'p HHHHH q'
	? "ok 58\n" : "not ok 58\n";
print exp_vars('$(DIR)',0)             eq '$(UNDEFINEDNAME)/xxx'
	? "ok 59\n" : "not ok 59\n";
print exp_vars('foo $(DIR)/yyy bar',0) eq 'foo $(UNDEFINEDNAME)/xxx/yyy bar'
	? "ok 60\n" : "not ok 60\n";

# a match nested in the RHS of a substitution:
d238 1
a238 1
print $x eq "cd" ? "ok 61\n" : "not ok 61\n";
d243 2
a244 2
s/(?<!x)c/x/g;
print $_ eq "xxxxx" ? "ok 62\n" : "not ok 62 # `$_' ne `xxxxx'\n";
d247 2
a248 2
s/(?<!x)(c)/x/g;
print $_ eq "xxxxx" ? "ok 63\n" : "not ok 63 # `$_' ne `xxxxx'\n";
d251 2
a252 2
s/(?<!r)foobbar/foobar/g;
print $_ eq "foobarfoobbar" ? "ok 64\n" : "not ok 64 # `$_' ne `foobarfoobbar'\n";
d255 2
a256 2
s/(?<!ar)(foobbar)/foobar/g;
print $_ eq "foobarfoobbar" ? "ok 65\n" : "not ok 65 # `$_' ne `foobarfoobbar'\n";
d259 2
a260 2
s/(?<!ar)foobbar/foobar/g;
print $_ eq "foobarfoobbar" ? "ok 66\n" : "not ok 66 # `$_' ne `foobarfoobbar'\n";
a261 1
# check parsing of split subst with comment
d264 1
a264 1
print @@? ? "not ok 67\n" : "ok 67\n";
a265 1
# check if squashing works at the end of string
d267 3
a269 2
tr/a/b/s;
print $_ eq "bbcbb" ? "ok 68\n" : "not ok 68 # `$_' ne `bbcbb'\n";
a270 1
# XXX TODO: Most tests above don't test return values of the ops. They should.
d272 1
a272 1
print (s/a/b/ == 1 ? "ok 69\n" : "not ok 69\n");
d283 1
d300 6
a305 1
print ($_ eq $foo ? "ok 70\n" : "not ok 70\n#'$_'\n#'$foo'\n");
d308 1
a308 1
s/(\d*|x)/<$1>/g; 
d310 1
a310 1
print ($_ eq $foo ? "ok 71\n" : "not ok 71\n#'$_'\n#'$foo'\n");
d316 2
a317 3
s/\Ga/xx/g;
print "not " unless $_ eq 'aaaaaaxxxxxx';
print "ok 72\n";
d321 2
a322 3
s/\Ga/x/g;
print "not " unless $_ eq 'aaaaaaxxx';
print "ok 73\n";
d327 1
a327 2
print "not " unless $_ eq 'aaaaaaxxaa';
print "ok 74\n";
d332 1
a332 2
print "not " unless $_ eq 'aaaaaaxaa';
print "ok 75\n";
d335 2
a336 3
s/\Ga/xx/g;
print "not " unless $_ eq 'xxxxxxxxxxxxxxxxxx';
print "ok 76\n";
d339 2
a340 3
s/\Ga/x/g;
print "not " unless $_ eq 'xxxxxxxxx';
print "ok 77\n";
d344 1
a344 2
print "not " unless $_ eq 'xxaaaaaaaa';
print "ok 78\n";
d348 1
a348 2
print "not " unless $_ eq 'xaaaaaaaa';
print "ok 79\n";
d351 2
a352 3
s/\ba/./g;
print "#'$_'\nnot " unless $_ eq '.aaa';
print "ok 80\n";
d355 1
a355 1
print ($@@ =~ /Bad evalled substitution/ ? "ok 81\n" : "not ok 81\n");
d357 1
a357 1
print +($_ eq "x " and !length $@@) ? "ok 82\n" : "not ok 82\n# \$_ eq $_, $@@\n";
d360 1
a360 1
print +($_ eq '' and !length $@@) ? "ok 83\n" : "not ok 83\n# \$_ eq $_, $@@\n";
d363 130
a492 2
s/^([a-z]:)/\u$1/ and print "not ";
print "ok 84\n";
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d5 1
a5 1
    unshift @@INC, '../lib' if -d '../lib';
@


1.3
log
@perl5.005_03 (stock)
@
text
@d3 7
a9 1
print "1..71\n";
d190 2
a191 1
if ($^O eq 'os390') {	# An EBCDIC variant.
d315 1
a315 1
s/\d*|x/<$&>/g; 
d318 64
@


1.2
log
@perl 5.004_04
@
text
@d3 1
a3 3
# $RCSfile: s.t,v $$Revision: 4.1 $$Date: 92/08/07 18:28:22 $

print "1..62\n";
d158 1
a158 1
s/\d+/$&*2/e;              # yields 'abc246xyz'
d160 1
a160 1
s/\d+/sprintf("%5d",$&)/e; # yields 'abc  246xyz'
d162 1
a162 1
s/\w/$& x 2/eg;            # yields 'aabbcc  224466xxyyzz'
d184 5
a188 1
y[\101-\132][\141-\172];
d192 7
a198 3
$_ = '+,-';
tr/+--/a-c/;
print $_ eq 'abc' ? "ok 54\n" : "not ok 54\n";
d241 1
a241 1
s/../$x = $&, m#.#/eg;
d244 22
d269 42
a310 1
print @@? ? "not ok 62\n" : "ok 62\n";
@


1.1
log
@Initial revision
@
text
@d5 1
a5 1
print "1..56\n";
d201 41
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d3 3
a5 1
print "1..71\n";
d160 1
a160 1
s/(\d+)/$1*2/e;              # yields 'abc246xyz'
d162 1
a162 1
s/(\d+)/sprintf("%5d",$1)/e; # yields 'abc  246xyz'
d164 1
a164 1
s/(\w)/$1 x 2/eg;            # yields 'aabbcc  224466xxyyzz'
d186 1
a186 5
if ($^O eq 'os390') {	# An EBCDIC variant.
    y[\301-\351][\201-\251];
} else {		# Ye Olde ASCII.  Or something like it.
    y[\101-\132][\141-\172];
}
d190 3
a192 7
if (ord("+") == ord(",") - 1 && ord(",") == ord("-") - 1 &&
    ord("a") == ord("b") - 1 && ord("b") == ord("c") - 1) {
  $_ = '+,-';
  tr/+--/a-c/;
  print "not " unless $_ eq 'abc';
}
print "ok 54\n";
a200 104


# test recursive substitutions
# code based on the recursive expansion of makefile variables

my %MK = (
    AAAAA => '$(B)', B=>'$(C)', C => 'D',			# long->short
    E     => '$(F)', F=>'p $(G) q', G => 'HHHHH',	# short->long
    DIR => '$(UNDEFINEDNAME)/xxx',
);
sub var { 
    my($var,$level) = @@_;
    return "\$($var)" unless exists $MK{$var};
    return exp_vars($MK{$var}, $level+1); # can recurse
}
sub exp_vars { 
    my($str,$level) = @@_;
    $str =~ s/\$\((\w+)\)/var($1, $level+1)/ge; # can recurse
    #warn "exp_vars $level = '$str'\n";
    $str;
}

print exp_vars('$(AAAAA)',0)           eq 'D'
	? "ok 57\n" : "not ok 57\n";
print exp_vars('$(E)',0)               eq 'p HHHHH q'
	? "ok 58\n" : "not ok 58\n";
print exp_vars('$(DIR)',0)             eq '$(UNDEFINEDNAME)/xxx'
	? "ok 59\n" : "not ok 59\n";
print exp_vars('foo $(DIR)/yyy bar',0) eq 'foo $(UNDEFINEDNAME)/xxx/yyy bar'
	? "ok 60\n" : "not ok 60\n";

# a match nested in the RHS of a substitution:

$_ = "abcd";
s/(..)/$x = $1, m#.#/eg;
print $x eq "cd" ? "ok 61\n" : "not ok 61\n";

# Subst and lookbehind

$_="ccccc";
s/(?<!x)c/x/g;
print $_ eq "xxxxx" ? "ok 62\n" : "not ok 62 # `$_' ne `xxxxx'\n";

$_="ccccc";
s/(?<!x)(c)/x/g;
print $_ eq "xxxxx" ? "ok 63\n" : "not ok 63 # `$_' ne `xxxxx'\n";

$_="foobbarfoobbar";
s/(?<!r)foobbar/foobar/g;
print $_ eq "foobarfoobbar" ? "ok 64\n" : "not ok 64 # `$_' ne `foobarfoobbar'\n";

$_="foobbarfoobbar";
s/(?<!ar)(foobbar)/foobar/g;
print $_ eq "foobarfoobbar" ? "ok 65\n" : "not ok 65 # `$_' ne `foobarfoobbar'\n";

$_="foobbarfoobbar";
s/(?<!ar)foobbar/foobar/g;
print $_ eq "foobarfoobbar" ? "ok 66\n" : "not ok 66 # `$_' ne `foobarfoobbar'\n";

# check parsing of split subst with comment
eval 's{foo} # this is a comment, not a delimiter
       {bar};';
print @@? ? "not ok 67\n" : "ok 67\n";

# check if squashing works at the end of string
$_="baacbaa";
tr/a/b/s;
print $_ eq "bbcbb" ? "ok 68\n" : "not ok 68 # `$_' ne `bbcbb'\n";

# XXX TODO: Most tests above don't test return values of the ops. They should.
$_ = "ab";
print (s/a/b/ == 1 ? "ok 69\n" : "not ok 69\n");

$_ = <<'EOL';
     $url = new URI::URL "http://www/";   die if $url eq "xXx";
EOL
$^R = 'junk';

$foo = ' $@@%#lowercase $@@%# lowercase UPPERCASE$@@%#UPPERCASE' .
  ' $@@%#lowercase$@@%#lowercase$@@%# lowercase lowercase $@@%#lowercase' .
  ' lowercase $@@%#MiXeD$@@%# ';

s{  \d+          \b [,.;]? (?{ 'digits' })
   |
    [a-z]+       \b [,.;]? (?{ 'lowercase' })
   |
    [A-Z]+       \b [,.;]? (?{ 'UPPERCASE' })
   |
    [A-Z] [a-z]+ \b [,.;]? (?{ 'Capitalized' })
   |
    [A-Za-z]+    \b [,.;]? (?{ 'MiXeD' })
   |
    [A-Za-z0-9]+ \b [,.;]? (?{ 'alphanumeric' })
   |
    \s+                    (?{ ' ' })
   |
    [^A-Za-z0-9\s]+          (?{ '$@@%#' })
}{$^R}xg;
print ($_ eq $foo ? "ok 70\n" : "not ok 70\n#'$_'\n#'$foo'\n");

$_ = 'x' x 20; 
s/\d*|x/<$&>/g; 
$foo = '<>' . ('<x><>' x 20) ;
print ($_ eq $foo ? "ok 71\n" : "not ok 71\n#'$_'\n#'$foo'\n");
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d3 1
a3 7
BEGIN {
    chdir 't' if -d 't';
    unshift @@INC, '../lib' if -d '../lib';
    require Config; import Config;
}

print "1..84\n";
d184 1
a184 2
if ($Config{ebcdic} eq 'define') {	# EBCDIC.
    no utf8;
d308 1
a308 1
s/(\d*|x)/<$1>/g; 
a310 64

$t = 'aaaaaaaaa'; 

$_ = $t;
pos = 6;
s/\Ga/xx/g;
print "not " unless $_ eq 'aaaaaaxxxxxx';
print "ok 72\n";

$_ = $t;
pos = 6;
s/\Ga/x/g;
print "not " unless $_ eq 'aaaaaaxxx';
print "ok 73\n";

$_ = $t;
pos = 6;
s/\Ga/xx/;
print "not " unless $_ eq 'aaaaaaxxaa';
print "ok 74\n";

$_ = $t;
pos = 6;
s/\Ga/x/;
print "not " unless $_ eq 'aaaaaaxaa';
print "ok 75\n";

$_ = $t;
s/\Ga/xx/g;
print "not " unless $_ eq 'xxxxxxxxxxxxxxxxxx';
print "ok 76\n";

$_ = $t;
s/\Ga/x/g;
print "not " unless $_ eq 'xxxxxxxxx';
print "ok 77\n";

$_ = $t;
s/\Ga/xx/;
print "not " unless $_ eq 'xxaaaaaaaa';
print "ok 78\n";

$_ = $t;
s/\Ga/x/;
print "not " unless $_ eq 'xaaaaaaaa';
print "ok 79\n";

$_ = 'aaaa';
s/\ba/./g;
print "#'$_'\nnot " unless $_ eq '.aaa';
print "ok 80\n";

eval q% s/a/"b"}/e %;
print ($@@ =~ /Bad evalled substitution/ ? "ok 81\n" : "not ok 81\n");
eval q% ($_ = "x") =~ s/(.)/"$1 "/e %;
print +($_ eq "x " and !length $@@) ? "ok 82\n" : "not ok 82\n# \$_ eq $_, $@@\n";
$x = $x = 'interp';
eval q% ($_ = "x") =~ s/x(($x)*)/"$1"/e %;
print +($_ eq '' and !length $@@) ? "ok 83\n" : "not ok 83\n# \$_ eq $_, $@@\n";

$_ = "C:/";
s/^([a-z]:)/\u$1/ and print "not ";
print "ok 84\n";

@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d5 1
a5 1
    @@INC = '../lib';
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d1 1
a1 1
#!./perl -wT
d9 1
a9 2
require './test.pl';
plan( tests => 122 );
d14 2
a15 1
ok( $_ eq '$x', ":$_: eq :\$x:" );
d19 2
a20 1
ok( $_ eq 'foo', ":$_: eq :foo:" );
d24 2
a25 1
ok( $_ eq '$x foo', ":$_: eq :\$x foo:" );
d29 3
a31 1
ok( $1 eq 'bcde' && $a eq 'a\n$1f', ":$1: eq :bcde: ; :$a: eq :a\\n\$1f:" );
d34 2
a35 1
ok( ($a =~ s/a/x/g) == 4 && $a eq 'xbxcxdx' );
d37 2
a38 1
ok( ($a =~ s/a/y/g) == 0 && $a eq 'xbxcxdx' );
d40 2
a41 1
ok( ($a =~ s/b/y/g) == 1 && $a eq 'xyxcxdx' );
d44 1
a44 1
ok( /a/i && s///gi && $_ eq 'BCD' );
d47 3
a49 3
ok( length($_) == 4 );
$snum = s/\\/\\\\/g;
ok( $_ eq '\\' x 8 && $snum == 4 );
d52 4
a55 4
ok( length($_) == 8 );
$snum = s/\//\/\//g;
ok( $_ eq '\\//' x 4 && $snum == 4 );
ok( length($_) == 12 );
d59 1
a59 1
ok( $_ eq 'aaXXXXbbb' );
d63 1
a63 1
ok( $_ eq 'aaXXXXbbb' );
d67 1
a67 1
ok( $_ eq 'baaXXXXbbb' );
d71 1
a71 1
ok( $_ eq 'baaXXXXbbb' );
d75 1
a75 1
ok( $_ eq 'aXXXXbbb' );
d79 1
a79 1
ok( $_ eq 'baXXXXbbb' );
d83 1
a83 1
ok( $_ eq 'aaaXXXXbb' );
d87 1
a87 1
ok( $_ eq 'aaaXXXXbb' );
d91 1
a91 1
ok( $_ eq 'aaaXXXXb' );
d95 1
a95 1
ok( $_ eq 'aayXXXbbb' );
d99 1
a99 1
ok( $_ eq 'aaaXXXzbb' );
d103 1
a103 1
ok( $_ eq 'ab' );
d107 1
a107 1
ok( $_ eq 'aaaXXXXxb' );
d113 1
a113 1
ok( $_ eq 'aaXXXXbbb' );
d117 1
a117 1
ok( $_ eq 'aaXXXXbbb' );
d121 1
a121 1
ok( $_ eq 'baaXXXXbbb' );
d125 1
a125 1
ok( $_ eq 'baaXXXXbbb' );
d129 1
a129 1
ok( $_ eq 'aXXXXbbb' );
d133 1
a133 1
ok( $_ eq 'baXXXXbbb' );
d137 1
a137 1
ok( $_ eq 'aaaXXXXbb' );
d141 1
a141 1
ok( $_ eq 'aaaXXXXbb' );
d145 1
a145 1
ok( $_ eq 'aaaXXXXb' );
d149 1
a149 1
ok( $_ eq 'aayXXXbbb' );
d153 1
a153 1
ok( $_ eq 'aaaXXXzbb' );
d157 1
a157 1
ok( $_ eq 'ab' );
d161 1
a161 1
ok( $_ eq 'aaaXXXXxb' );
d165 1
a165 1
ok( $_ eq 'abc246xyz' );
d167 1
a167 1
ok( $_ eq 'abc  246xyz' );
d169 1
a169 1
ok( $_ eq 'aabbcc  224466xxyyzz' );
d172 7
a178 7
ok( y/a/b/ == 5 );
ok( y/a/b/ == 0 );
ok( y/b// == 5 );
ok( y/b/c/s == 5 );
ok( y/c// == 1 );
ok( y/c//d == 1 );
ok( $_ eq "" );
d181 2
a182 2
ok( ($x=(y/a-zA-Z //cd)) == 7 );
ok( y/ / /s == 8 );
d187 1
a187 1
ok( $_ eq 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789' );
d190 1
a190 1
if (defined $Config{ebcdic} && $Config{ebcdic} eq 'define') {	# EBCDIC.
d197 1
a197 1
ok( $_ eq 'abcdefghijklmnopqrstuvwxyz0123456789' );
d199 5
a203 8
SKIP: {
    skip("not ASCII",1) unless (ord("+") == ord(",") - 1
			     && ord(",") == ord("-") - 1
			     && ord("a") == ord("b") - 1
			     && ord("b") == ord("c") - 1);
    $_ = '+,-';
    tr/+--/a-c/;
    ok( $_ eq 'abc' );
d205 1
d209 1
a209 1
ok( $_ eq 'a,/' );
d213 1
a213 1
ok( $_ eq 'b-a' );
d236 10
a245 4
ok( exp_vars('$(AAAAA)',0)           eq 'D' );
ok( exp_vars('$(E)',0)               eq 'p HHHHH q' );
ok( exp_vars('$(DIR)',0)             eq '$(UNDEFINEDNAME)/xxx' );
ok( exp_vars('foo $(DIR)/yyy bar',0) eq 'foo $(UNDEFINEDNAME)/xxx/yyy bar' );
d249 1
a249 1
ok( $x eq "cd", 'a match nested in the RHS of a substitution' );
d254 2
a255 2
$snum = s/(?<!x)c/x/g;
ok( $_ eq "xxxxx" && $snum == 5 );
d258 2
a259 2
$snum = s/(?<!x)(c)/x/g;
ok( $_ eq "xxxxx" && $snum == 5 );
d262 2
a263 2
$snum = s/(?<!r)foobbar/foobar/g;
ok( $_ eq "foobarfoobbar" && $snum == 1 );
d266 2
a267 2
$snum = s/(?<!ar)(foobbar)/foobar/g;
ok( $_ eq "foobarfoobbar" && $snum == 1 );
d270 2
a271 2
$snum = s/(?<!ar)foobbar/foobar/g;
ok( $_ eq "foobarfoobbar" && $snum == 1 );
d273 1
d276 1
a276 1
ok( ! @@?, 'parsing of split subst with comment' );
d278 1
d280 2
a281 3
$snum = tr/a/b/s;
ok( $_ eq "bbcbb" && $snum == 4,
    'check if squashing works at the end of string' );
d283 1
d285 1
a285 1
ok( s/a/b/ == 1 );
a295 1
$snum =
d312 1
a312 6
ok( $_ eq $foo );
ok( $snum == 31 );

$_ = 'a' x 6;
$snum = s/a(?{})//g;
ok( $_ eq '' && $snum == 6 );
d315 1
a315 1
$snum = s/(\d*|x)/<$1>/g; 
d317 1
a317 1
ok( $_ eq $foo && $snum == 41 );
d323 3
a325 2
$snum = s/\Ga/xx/g;
ok( $_ eq 'aaaaaaxxxxxx' && $snum == 3 );
d329 3
a331 2
$snum = s/\Ga/x/g;
ok( $_ eq 'aaaaaaxxx' && $snum == 3 );
d336 2
a337 1
ok( $_ eq 'aaaaaaxxaa' );
d342 2
a343 1
ok( $_ eq 'aaaaaaxaa' );
d346 3
a348 2
$snum = s/\Ga/xx/g;
ok( $_ eq 'xxxxxxxxxxxxxxxxxx' && $snum == 9 );
d351 3
a353 2
$snum = s/\Ga/x/g;
ok( $_ eq 'xxxxxxxxx' && $snum == 9 );
d357 2
a358 1
ok( $_ eq 'xxaaaaaaaa' );
d362 2
a363 1
ok( $_ eq 'xaaaaaaaa' );
d366 3
a368 2
$snum = s/\ba/./g;
ok( $_ eq '.aaa' && $snum == 1 );
d371 1
a371 1
ok( $@@ =~ /Bad evalled substitution/ );
d373 1
a373 1
ok( $_ eq "x " and !length $@@ );
d376 1
a376 1
ok( $_ eq '' and !length $@@ );
d379 2
a380 130
ok( !s/^([a-z]:)/\u$1/ );

$_ = "Charles Bronson";
$snum = s/\B\w//g;
ok( $_ eq "C B" && $snum == 12 );

{
    use utf8;
    my $s = "H\303\266he";
    my $l = my $r = $s;
    $l =~ s/[^\w]//g;
    $r =~ s/[^\w\.]//g;
    is($l, $r, "use utf8 \\w");
}

my $pv1 = my $pv2  = "Andreas J. K\303\266nig";
$pv1 =~ s/A/\x{100}/;
substr($pv2,0,1) = "\x{100}";
is($pv1, $pv2);

SKIP: {
    skip("EBCDIC", 3) if ord("A") == 193; 

    {   
	# Gregor Chrupala <gregor.chrupala@@star-group.net>
	use utf8;
	$a = 'Espa&ntilde;a';
	$a =~ s/&ntilde;/ñ/;
	like($a, qr/ñ/, "use utf8 RHS");
    }

    {
	use utf8;
	$a = 'España España';
	$a =~ s/ñ/&ntilde;/;
	like($a, qr/ñ/, "use utf8 LHS");
    }

    {
	use utf8;
	$a = 'España';
	$a =~ s/ñ/ñ/;
	like($a, qr/ñ/, "use utf8 LHS and RHS");
    }
}

{
    # SADAHIRO Tomoyuki <bqw10602@@nifty.com>

    $a = "\x{100}\x{101}";
    $a =~ s/\x{101}/\xFF/;
    like($a, qr/\xFF/);
    is(length($a), 2, "SADAHIRO utf8 s///");

    $a = "\x{100}\x{101}";
    $a =~ s/\x{101}/"\xFF"/e;
    like($a, qr/\xFF/);
    is(length($a), 2);

    $a = "\x{100}\x{101}";
    $a =~ s/\x{101}/\xFF\xFF\xFF/;
    like($a, qr/\xFF\xFF\xFF/);
    is(length($a), 4);

    $a = "\x{100}\x{101}";
    $a =~ s/\x{101}/"\xFF\xFF\xFF"/e;
    like($a, qr/\xFF\xFF\xFF/);
    is(length($a), 4);

    $a = "\xFF\x{101}";
    $a =~ s/\xFF/\x{100}/;
    like($a, qr/\x{100}/);
    is(length($a), 2);

    $a = "\xFF\x{101}";
    $a =~ s/\xFF/"\x{100}"/e;
    like($a, qr/\x{100}/);
    is(length($a), 2);

    $a = "\xFF";
    $a =~ s/\xFF/\x{100}/;
    like($a, qr/\x{100}/);
    is(length($a), 1);

    $a = "\xFF";
    $a =~ s/\xFF/"\x{100}"/e;
    like($a, qr/\x{100}/);
    is(length($a), 1);
}

{
    # subst with mixed utf8/non-utf8 type
    my($ua, $ub, $uc, $ud) = ("\x{101}", "\x{102}", "\x{103}", "\x{104}");
    my($na, $nb) = ("\x{ff}", "\x{fe}");
    my $a = "$ua--$ub";
    my $b;
    ($b = $a) =~ s/--/$na/;
    is($b, "$ua$na$ub", "s///: replace non-utf8 into utf8");
    ($b = $a) =~ s/--/--$na--/;
    is($b, "$ua--$na--$ub", "s///: replace long non-utf8 into utf8");
    ($b = $a) =~ s/--/$uc/;
    is($b, "$ua$uc$ub", "s///: replace utf8 into utf8");
    ($b = $a) =~ s/--/--$uc--/;
    is($b, "$ua--$uc--$ub", "s///: replace long utf8 into utf8");
    $a = "$na--$nb";
    ($b = $a) =~ s/--/$ua/;
    is($b, "$na$ua$nb", "s///: replace utf8 into non-utf8");
    ($b = $a) =~ s/--/--$ua--/;
    is($b, "$na--$ua--$nb", "s///: replace long utf8 into non-utf8");

    # now with utf8 pattern
    $a = "$ua--$ub";
    ($b = $a) =~ s/-($ud)?-/$na/;
    is($b, "$ua$na$ub", "s///: replace non-utf8 into utf8 (utf8 pattern)");
    ($b = $a) =~ s/-($ud)?-/--$na--/;
    is($b, "$ua--$na--$ub", "s///: replace long non-utf8 into utf8 (utf8 pattern)");
    ($b = $a) =~ s/-($ud)?-/$uc/;
    is($b, "$ua$uc$ub", "s///: replace utf8 into utf8 (utf8 pattern)");
    ($b = $a) =~ s/-($ud)?-/--$uc--/;
    is($b, "$ua--$uc--$ub", "s///: replace long utf8 into utf8 (utf8 pattern)");
    $a = "$na--$nb";
    ($b = $a) =~ s/-($ud)?-/$ua/;
    is($b, "$na$ua$nb", "s///: replace utf8 into non-utf8 (utf8 pattern)");
    ($b = $a) =~ s/-($ud)?-/--$ua--/;
    is($b, "$na--$ua--$nb", "s///: replace long utf8 into non-utf8 (utf8 pattern)");
    ($b = $a) =~ s/-($ud)?-/$na/;
    is($b, "$na$na$nb", "s///: replace non-utf8 into non-utf8 (utf8 pattern)");
    ($b = $a) =~ s/-($ud)?-/--$na--/;
    is($b, "$na--$na--$nb", "s///: replace long non-utf8 into non-utf8 (utf8 pattern)");
}
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@d10 1
a10 1
plan( tests => 130 );
a493 48
$_ = 'aaaa';
$r = 'x';
$s = s/a(?{})/$r/g;
is("<$_> <$s>", "<xxxx> <4>", "[perl #7806]");

$_ = 'aaaa';
$s = s/a(?{})//g;
is("<$_> <$s>", "<> <4>", "[perl #7806]");

# [perl #19048] Coredump in silly replacement
{
    local $^W = 0;
    $_="abcdef\n";
    s!.!!eg;
    is($_, "\n", "[perl #19048]");
}

# [perl #17757] interaction between saw_ampersand and study
{
    my $f = eval q{ $& };
    $f = "xx";
    study $f;
    $f =~ s/x/y/g;
    is($f, "yy", "[perl #17757]");
}

# [perl #20684] returned a zero count
$_ = "1111";
is(s/(??{1})/2/eg, 4, '#20684 s/// with (??{..}) inside');

# [perl #20682] @@- not visible in replacement
$_ = "123";
/(2)/;	# seed @@- with something else
s/(1)(2)(3)/$#- (@@-)/;
is($_, "3 (0 0 1 2)", '#20682 @@- not visible in replacement');

# [perl #20682] $^N not visible in replacement
$_ = "abc";
/(a)/; s/(b)|(c)/-$^N/g;
is($_,'a-b-c','#20682 $^N not visible in replacement');

# [perl #22351] perl bug with 'e' substitution modifier
my $name = "chris";
{
    no warnings 'uninitialized';
    $name =~ s/hr//e;
}
is($name, "cis", q[#22351 bug with 'e' substitution modifier]);
@


1.1.1.7
log
@perl 5.8.8 import
@
text
@d10 1
a10 1
plan( tests => 131 );
a541 14


# [perl #34171] $1 didn't honour 'use bytes' in s//e
{
    my $s="\x{100}";
    my $x;
    {
	use bytes;
	$s=~ s/(..)/$x=$1/e
    }
    is(length($x), 2, '[perl #34171]');
}


@


1.1.1.8
log
@import perl 5.10.0 from CPAN
@
text
@d1 1
a1 1
#!./perl -w
d10 1
a10 1
plan( tests => 136 );
a554 30

{ # [perl #27940] perlbug: [\x00-\x1f] works, [\c@@-\c_] does not
    my $c;

    ($c = "\x20\c@@\x30\cA\x40\cZ\x50\c_\x60") =~ s/[\c@@-\c_]//g;
    is($c, "\x20\x30\x40\x50\x60", "s/[\\c\@@-\\c_]//g");

    ($c = "\x20\x00\x30\x01\x40\x1A\x50\x1F\x60") =~ s/[\x00-\x1f]//g;
    is($c, "\x20\x30\x40\x50\x60", "s/[\\x00-\\x1f]//g");
}
{
    $_ = "xy";
    no warnings 'uninitialized';
    /(((((((((x)))))))))(z)/;	# clear $10
    s/(((((((((x)))))))))(y)/${10}/;
    is($_,"y","RT#6006: \$_ eq '$_'");
    $_ = "xr";
    s/(((((((((x)))))))))(r)/fooba${10}/;
    is($_,"foobar","RT#6006: \$_ eq '$_'");
}
{
    my $want=("\n" x 11).("B\n" x 11)."B";
    $_="B";
    our $i;
    for $i(1..11){
	s/^.*$/$&/gm;
	$_="\n$_\n$&";
    }
    is($want,$_,"RT#17542");
}
@


1.1.1.9
log
@import perl 5.10.1
@
text
@d10 1
a10 1
plan( tests => 139 );
a585 8
{
    my @@tests = ('ABC', "\xA3\xA4\xA5", "\x{410}\x{411}\x{412}");
    foreach (@@tests) {
	my $id = ord $_;
	s/./pos/ge;
	is($_, "012", "RT#52104: $id");
    }
}
@


