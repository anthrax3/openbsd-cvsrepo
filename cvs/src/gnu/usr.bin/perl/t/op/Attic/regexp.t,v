head	1.9;
access;
symbols
	OPENBSD_4_8:1.8.0.4
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	PERL_5_10_1:1.1.1.7
	OPENBSD_4_6:1.7.0.6
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.2
	OPENBSD_4_5_BASE:1.7
	PERL_5_10_0:1.1.1.6
	OPENBSD_4_4:1.6.0.24
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.22
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.20
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.18
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.16
	OPENBSD_4_0_BASE:1.6
	PERL_5_8_8:1.1.1.5
	OPENBSD_3_9:1.6.0.14
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.12
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.10
	OPENBSD_3_7_BASE:1.6
	PERL_5_8_6:1.1.1.5
	OPENBSD_3_6:1.6.0.8
	OPENBSD_3_6_BASE:1.6
	PERL_5_8_5:1.1.1.5
	PERL_5_8_3:1.1.1.5
	OPENBSD_3_5:1.6.0.6
	OPENBSD_3_5_BASE:1.6
	PERL_5_8_2:1.1.1.5
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;


1.9
date	2010.09.24.15.00.00;	author millert;	state dead;
branches;
next	1.8;

1.8
date	2009.10.12.18.30.28;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2008.09.29.17.36.20;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.37;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.36.21;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.08.31;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.52.37;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.08.05.39;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.13.22;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.13.22;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.41.50;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.10.51;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.25.46;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.15.11;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2008.09.29.17.19.01;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2009.10.12.18.10.44;	author millert;	state Exp;
branches;
next	;


desc
@@


1.9
log
@remove files no longer in perl 5.12.2 (or that have moved)
@
text
@#!./perl

# The tests are in a separate file 't/op/re_tests'.
# Each line in that file is a separate test.
# There are five columns, separated by tabs.
#
# Column 1 contains the pattern, optionally enclosed in C<''>.
# Modifiers can be put after the closing C<'>.
#
# Column 2 contains the string to be matched.
#
# Column 3 contains the expected result:
# 	y	expect a match
# 	n	expect no match
# 	c	expect an error
#	T	the test is a TODO (can be combined with y/n/c)
#	B	test exposes a known bug in Perl, should be skipped
#	b	test exposes a known bug in Perl, should be skipped if noamp
#	t	test exposes a bug with threading, TODO if qr_embed_thr
#
# Columns 4 and 5 are used only if column 3 contains C<y> or C<c>.
#
# Column 4 contains a string, usually C<$&>.
#
# Column 5 contains the expected result of double-quote
# interpolating that string after the match, or start of error message.
#
# Column 6, if present, contains a reason why the test is skipped.
# This is printed with "skipped", for harness to pick up.
#
# \n in the tests are interpolated, as are variables of the form ${\w+}.
#
# Blanks lines are treated as PASSING tests to keep the line numbers
# linked to the test number.
#
# If you want to add a regular expression test that can't be expressed
# in this format, don't add it here: put it in op/pat.t instead.
#
# Note that columns 2,3 and 5 are all enclosed in double quotes and then
# evalled; so something like a\"\x{100}$1 has length 3+length($1).

my $file;
BEGIN {
    $iters = shift || 1;	# Poor man performance suite, 10000 is OK.

    # Do this open before any chdir
    $file = shift;
    if (defined $file) {
	open TESTS, $file or die "Can't open $file";
    }

    chdir 't' if -d 't';
    @@INC = '../lib';

    if ($qr_embed_thr) {
	require Config;
	if (!$Config::Config{useithreads}) {
	    print "1..0 # Skip: no ithreads\n";
		exit 0;
	}
	if ($ENV{PERL_CORE_MINITEST}) {
	    print "1..0 # Skip: no dynamic loading on miniperl, no threads\n";
		exit 0;
	}
	require threads;
    }
}

use strict;
use warnings FATAL=>"all";
use vars qw($iters $numtests $bang $ffff $nulnul $OP);
use vars qw($qr $skip_amp $qr_embed $qr_embed_thr); # set by our callers


if (!defined $file) {
    open(TESTS,'op/re_tests') || open(TESTS,'t/op/re_tests')
	|| open(TESTS,':op:re_tests') || die "Can't open re_tests";
}

my @@tests = <TESTS>;

close TESTS;

$bang = sprintf "\\%03o", ord "!"; # \41 would not be portable.
$ffff  = chr(0xff) x 2;
$nulnul = "\0" x 2;
$OP = $qr ? 'qr' : 'm';

$| = 1;
printf "1..%d\n# $iters iterations\n", scalar @@tests;

my $test;
TEST:
foreach (@@tests) {
    $test++;
    if (!/\S/ || /^\s*#/ || /^__END__$/) {
        print "ok $test # (Blank line or comment)\n";
        if (/#/) { print $_ };
        next;
    }
    chomp;
    s/\\n/\n/g;
    my ($pat, $subject, $result, $repl, $expect, $reason) = split(/\t/,$_,6);
    $reason = '' unless defined $reason;
    my $input = join(':',$pat,$subject,$result,$repl,$expect);
    # the double '' below keeps simple syntax highlighters from going crazy
    $pat = "'$pat'" unless $pat =~ /^[:''\/]/; 
    $pat =~ s/(\$\{\w+\})/$1/eeg;
    $pat =~ s/\\n/\n/g;
    $subject = eval qq("$subject"); die $@@ if $@@;
    $expect  = eval qq("$expect"); die $@@ if $@@;
    $expect = $repl = '-' if $skip_amp and $input =~ /\$[&\`\']/;
    my $todo_qr = $qr_embed_thr && ($result =~ s/t//);
    my $skip = ($skip_amp ? ($result =~ s/B//i) : ($result =~ s/B//));
    $reason = 'skipping $&' if $reason eq  '' && $skip_amp;
    $result =~ s/B//i unless $skip;
    my $todo= $result =~ s/T// ? " # TODO" : "";
    

    for my $study ('', 'study $subject', 'utf8::upgrade($subject)',
		   'utf8::upgrade($subject); study $subject') {
	# Need to make a copy, else the utf8::upgrade of an alreay studied
	# scalar confuses things.
	my $subject = $subject;
	my $c = $iters;
	my ($code, $match, $got);
        if ($repl eq 'pos') {
            $code= <<EOFCODE;
                $study;
                pos(\$subject)=0;
                \$match = ( \$subject =~ m${pat}g );
                \$got = pos(\$subject);
EOFCODE
        }
        elsif ($qr_embed) {
            $code= <<EOFCODE;
                my \$RE = qr$pat;
                $study;
                \$match = (\$subject =~ /(?:)\$RE(?:)/) while \$c--;
                \$got = "$repl";
EOFCODE
        }
        elsif ($qr_embed_thr) {
            $code= <<EOFCODE;
		# Can't run the match in a subthread, but can do this and
	 	# clone the pattern the other way.
                my \$RE = threads->new(sub {qr$pat})->join();
                $study;
                \$match = (\$subject =~ /(?:)\$RE(?:)/) while \$c--;
                \$got = "$repl";
EOFCODE
        }
        else {
            $code= <<EOFCODE;
                $study;
                \$match = (\$subject =~ $OP$pat) while \$c--;
                \$got = "$repl";
EOFCODE
        }
        #$code.=qq[\n\$expect="$expect";\n];
        #use Devel::Peek;
        #die Dump($code) if $pat=~/\\h/ and $subject=~/\x{A0}/;
	{
	    # Probably we should annotate specific tests with which warnings
	    # categories they're known to trigger, and hence should be
	    # disabled just for that test
	    no warnings qw(uninitialized regexp);
	    eval $code;
	}
	chomp( my $err = $@@ );
	if ($result eq 'c') {
	    if ($err !~ m!^\Q$expect!) { print "not ok $test$todo (compile) $input => `$err'\n"; next TEST }
	    last;  # no need to study a syntax error
	}
	elsif ( $skip ) {
	    print "ok $test # skipped", length($reason) ? " $reason" : '', "\n";
	    next TEST;
	}
	elsif ( $todo_qr ) {
	    print "not ok $test # TODO", length($reason) ? " - $reason" : '', "\n";
	    next TEST;
	}
	elsif ($@@) {
	    print "not ok $test$todo $input => error `$err'\n$code\n$@@\n"; next TEST;
	}
	elsif ($result =~ /^n/) {
	    if ($match) { print "not ok $test$todo ($study) $input => false positive\n"; next TEST }
	}
	else {
	    if (!$match || $got ne $expect) {
	        eval { require Data::Dumper };
		if ($@@) {
		    print "not ok $test$todo ($study) $input => `$got', match=$match\n$code\n";
		}
		else { # better diagnostics
		    my $s = Data::Dumper->new([$subject],['subject'])->Useqq(1)->Dump;
		    my $g = Data::Dumper->new([$got],['got'])->Useqq(1)->Dump;
		    print "not ok $test$todo ($study) $input => `$got', match=$match\n$s\n$g\n$code\n";
		}
		next TEST;
	    }
	}
    }
    print "ok $test$todo\n";
}

1;
@


1.8
log
@Merge in perl 5.10.1; part two
@
text
@@


1.7
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d16 1
d19 1
d54 13
d72 1
a72 1
use vars qw($qr $skip_amp $qr_embed); # set by our callers
d91 1
d96 1
a96 1
    if (!/\S/ || /^\s*#/) {
d98 1
a98 1
        if (/\S/) { print $_ };
d106 2
a107 1
    $pat = "'$pat'" unless $pat =~ /^[:'\/]/;
d113 1
d117 2
d143 10
d172 1
a172 1
	    if ($err !~ m!^\Q$expect!) { print "not ok $test (compile) $input => `$err'\n"; next TEST }
d179 4
d184 1
a184 1
	    print "not ok $test $input => error `$err'\n$code\n$@@\n"; next TEST;
d186 2
a187 2
	elsif ($result eq 'n') {
	    if ($match) { print "not ok $test ($study) $input => false positive\n"; next TEST }
d193 1
a193 1
		    print "not ok $test ($study) $input => `$got', match=$match\n$code\n";
d198 1
a198 1
		    print "not ok $test ($study) $input => `$got', match=$match\n$s\n$g\n$code\n";
d204 1
a204 1
    print "ok $test\n";
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d31 3
d36 3
d40 1
d42 8
d54 10
a63 1
$iters = shift || 1;		# Poor man performance suite, 10000 is OK.
d65 1
a65 2
open(TESTS,'op/re_tests') || open(TESTS,'t/op/re_tests') || open(TESTS,':op:re_tests') ||
	die "Can't open re_tests";
d67 1
a67 4
while (<TESTS>) { }
$numtests = $.;
seek(TESTS,0,0);
$. = 0;
d72 1
d75 2
a76 1
print "1..$numtests\n# $iters iterations\n";
d78 7
a84 1
while (<TESTS>) {
d87 4
a90 5
    ($pat, $subject, $result, $repl, $expect, $reason) = split(/\t/,$_,6);
    $input = join(':',$pat,$subject,$result,$repl,$expect);
    infty_subst(\$pat);
    infty_subst(\$expect);
    $pat = "'$pat'" unless $pat =~ /^[:']/;
d93 2
a94 4
    $subject =~ s/(\$\{\w+\})/$1/eeg;
    $subject =~ s/\\n/\n/g;
    $expect =~ s/(\$\{\w+\})/$1/eeg;
    $expect =~ s/\\n/\n/g;
d96 1
a96 1
    $skip = ($skip_amp ? ($result =~ s/B//i) : ($result =~ s/B//));
d99 42
a140 4
    for $study ('', 'study \$subject') {
 	$c = $iters;
 	eval "$study; \$match = (\$subject =~ m$pat) while \$c--; \$got = \"$repl\";";
	chomp( $err = $@@ );
d142 1
a142 1
	    if ($err !~ m!^\Q$expect!) { print "not ok $. (compile) $input => `$err'\n"; next TEST }
d146 1
a146 1
	    print "ok $. # skipped", length($reason) ? " $reason" : '', "\n";
d150 1
a150 1
	    print "not ok $. $input => error `$err'\n"; next TEST;
d153 1
a153 1
	    if ($match) { print "not ok $. ($study) $input => false positive\n"; next TEST }
d157 9
a165 1
 		print "not ok $. ($study) $input => `$got', match=$match\n";
d170 1
a170 1
    print "ok $.\n";
d173 1
a173 9
close(TESTS);

sub infty_subst                             # Special-case substitution
{                                           #  of $reg_infty and friends
    my $tp = shift;
    $$tp =~ s/,\$reg_infty_m}/,$reg_infty_m}/o;
    $$tp =~ s/,\$reg_infty_p}/,$reg_infty_p}/o;
    $$tp =~ s/,\$reg_infty}/,$reg_infty}/o;
}
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d41 1
a41 1
open(TESTS,'op/re_tests') || open(TESTS,'t/op/re_tests') ||
d72 1
a72 3
    # Certain tests don't work with utf8 (the re_test should be in UTF8)
    $skip = 1, $reason = 'utf8'
      if ($^H &= ~0x00000008) && $pat =~ /\[:\^(alnum|print|word|ascii|xdigit):\]/;
@


1.4
log
@perl-5.6.0 + local changes
@
text
@a2 3
# XXX known to leak scalars
$ENV{PERL_DESTRUCT_LEVEL} = 0 unless $ENV{PERL_DESTRUCT_LEVEL} > 3;

d26 3
d36 1
a36 1
    unshift @@INC, '../lib' if -d '../lib';
d59 1
a59 1
    ($pat, $subject, $result, $repl, $expect) = split(/\t/,$_);
d73 2
a74 1
    $skip = 1 if ($^H &= ~0x00000008) && $pat =~ /\[:\^(alnum|print|word):\]/;
d85 2
a86 1
	    print "ok $. # skipped\n"; next TEST;
@


1.3
log
@perl5.005_03 (stock)
@
text
@d19 2
d36 1
a36 1
    @@INC = '../lib' if -d '../lib';
d50 2
d64 1
d66 1
a66 1
    $pat =~ s/(\$\{\w+\})/$1/eeg;
d68 1
d71 5
a75 1
    for $study ("", "study \$subject") {
d82 3
@


1.2
log
@perl 5.004_04
@
text
@d3 3
d25 11
a35 1
# interpolating that string after the match.
d37 4
a40 2
open(TESTS,'op/re_tests') || open(TESTS,'t/op/re_tests')
    || die "Can't open re_tests";
d47 2
d50 1
a50 1
print "1..$numtests\n";
d53 3
a55 1
    ($pat, $subject, $result, $repl, $expect) = split(/[\t\n]/,$_);
d57 2
d60 5
d66 3
a68 1
	eval "$study; \$match = (\$subject =~ m$pat); \$got = \"$repl\";";
d70 1
a70 1
	    if ($@@ !~ m!^\Q$expect!) { print "not ok $.\n"; next TEST }
d73 3
d77 1
a77 1
	    if ($match) { print "not ok $. $input => $got\n"; next TEST }
d81 1
a81 1
		print "not ok $. $input => $got\n";
d90 8
@


1.1
log
@Initial revision
@
text
@d3 20
a22 1
# $RCSfile: regexp.t,v $$Revision: 4.1 $$Date: 92/08/07 18:28:20 $
d26 1
d29 2
a30 1
close(TESTS);
d32 1
d34 1
a34 3
open(TESTS,'op/re_tests') || open(TESTS,'t/op/re_tests')
    || die "Can't open re_tests";
$| = 1;
d38 9
a46 11
    $pat = "'$pat'" unless $pat =~ /^'/;
    eval "\$match = (\$subject =~ m$pat); \$got = \"$repl\";";
    if ($result eq 'c') {
	if ($@@ ne '') {print "ok $.\n";} else {print "not ok $.\n";}
    }
    elsif ($result eq 'n') {
	if (!$match) {print "ok $.\n";} else {print "not ok $. $input => $got\n";}
    }
    else {
	if ($match && $got eq $expect) {
	    print "ok $.\n";
d49 4
a52 1
	    print "not ok $. $input => $got\n";
d55 1
d57 1
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d3 1
a3 38
# XXX known to leak scalars
$ENV{PERL_DESTRUCT_LEVEL} = 0 unless $ENV{PERL_DESTRUCT_LEVEL} > 3;

# The tests are in a separate file 't/op/re_tests'.
# Each line in that file is a separate test.
# There are five columns, separated by tabs.
#
# Column 1 contains the pattern, optionally enclosed in C<''>.
# Modifiers can be put after the closing C<'>.
#
# Column 2 contains the string to be matched.
#
# Column 3 contains the expected result:
# 	y	expect a match
# 	n	expect no match
# 	c	expect an error
#
# Columns 4 and 5 are used only if column 3 contains C<y> or C<c>.
#
# Column 4 contains a string, usually C<$&>.
#
# Column 5 contains the expected result of double-quote
# interpolating that string after the match, or start of error message.
#
# \n in the tests are interpolated, as are variables of the form ${\w+}.
#
# If you want to add a regular expression test that can't be expressed
# in this format, don't add it here: put it in op/pat.t instead.

BEGIN {
    chdir 't' if -d 't';
    @@INC = '../lib' if -d '../lib';
}

$iters = shift || 1;		# Poor man performance suite, 10000 is OK.

open(TESTS,'op/re_tests') || open(TESTS,'t/op/re_tests') ||
	die "Can't open re_tests";
d5 2
d9 1
a9 4
seek(TESTS,0,0);
$. = 0;

$bang = sprintf "\\%03o", ord "!"; # \41 would not be portable.
d11 3
a14 2
print "1..$numtests\n# $iters iterations\n";
TEST:
d16 1
a16 3
    chomp;
    s/\\n/\n/g;
    ($pat, $subject, $result, $repl, $expect) = split(/\t/,$_);
d18 11
a28 21
    infty_subst(\$pat);
    infty_subst(\$expect);
    $pat = "'$pat'" unless $pat =~ /^[:']/;
    $pat =~ s/\\n/\n/g;
    $pat =~ s/(\$\{\w+\})/$1/eeg;
    $subject =~ s/\\n/\n/g;
    $expect =~ s/\\n/\n/g;
    $expect = $repl = '-' if $skip_amp and $input =~ /\$[&\`\']/;
    for $study ("", "study \$subject") {
 	$c = $iters;
 	eval "$study; \$match = (\$subject =~ m$pat) while \$c--; \$got = \"$repl\";";
	chomp( $err = $@@ );
	if ($result eq 'c') {
	    if ($err !~ m!^\Q$expect!) { print "not ok $. (compile) $input => `$err'\n"; next TEST }
	    last;  # no need to study a syntax error
	}
	elsif ($@@) {
	    print "not ok $. $input => error `$err'\n"; next TEST;
	}
	elsif ($result eq 'n') {
	    if ($match) { print "not ok $. ($study) $input => false positive\n"; next TEST }
d31 1
a31 4
	    if (!$match || $got ne $expect) {
 		print "not ok $. ($study) $input => `$got', match=$match\n";
		next TEST;
	    }
a33 1
    print "ok $.\n";
a34 1

a35 8

sub infty_subst                             # Special-case substitution
{                                           #  of $reg_infty and friends
    my $tp = shift;
    $$tp =~ s/,\$reg_infty_m}/,$reg_infty_m}/o;
    $$tp =~ s/,\$reg_infty_p}/,$reg_infty_p}/o;
    $$tp =~ s/,\$reg_infty}/,$reg_infty}/o;
}
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@a18 2
#	B	test exposes a known bug in Perl, should be skipped
#	b	test exposes a known bug in Perl, should be skipped if noamp
d34 1
a34 1
    unshift @@INC, '../lib' if -d '../lib';
a47 2
$ffff  = chr(0xff) x 2;
$nulnul = "\0" x 2;
d60 1
a61 2
    $pat =~ s/\\n/\n/g;
    $subject =~ s/(\$\{\w+\})/$1/eeg;
a62 1
    $expect =~ s/(\$\{\w+\})/$1/eeg;
d65 1
a65 5
    $skip = ($skip_amp ? ($result =~ s/B//i) : ($result =~ s/B//));
    # Certain tests don't work with utf8 (the re_test should be in UTF8)
    $skip = 1 if ($^H &= ~0x00000008) && $pat =~ /\[:\^(alnum|print|word):\]/;
    $result =~ s/B//i unless $skip;
    for $study ('', 'study \$subject') {
a71 3
	}
	elsif ( $skip ) {
	    print "ok $. # skipped\n"; next TEST;
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d3 3
a28 3
# Column 6, if present, contains a reason why the test is skipped.
# This is printed with "skipped", for harness to pick up.
#
d36 1
a36 1
    @@INC = '../lib';
d59 1
a59 1
    ($pat, $subject, $result, $repl, $expect, $reason) = split(/\t/,$_,6);
d73 1
a73 2
    $skip = 1, $reason = 'utf8'
      if ($^H &= ~0x00000008) && $pat =~ /\[:\^(alnum|print|word|ascii|xdigit):\]/;
d84 1
a84 2
	    print "ok $. # skipped", length($reason) ? " $reason" : '', "\n";
	    next TEST;
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d41 1
a41 1
open(TESTS,'op/re_tests') || open(TESTS,'t/op/re_tests') || open(TESTS,':op:re_tests') ||
d72 3
a74 1
    $reason = 'skipping $&' if $reason eq  '' && $skip_amp;
@


1.1.1.6
log
@import perl 5.10.0 from CPAN
@
text
@a30 3
# Blanks lines are treated as PASSING tests to keep the line numbers
# linked to the test number.
#
a32 3
#
# Note that columns 2,3 and 5 are all enclosed in double quotes and then
# evalled; so something like a\"\x{100}$1 has length 3+length($1).
a33 1
my $file;
a34 8
    $iters = shift || 1;	# Poor man performance suite, 10000 is OK.

    # Do this open before any chdir
    $file = shift;
    if (defined $file) {
	open TESTS, $file or die "Can't open $file";
    }

d39 1
a39 10
use strict;
use warnings FATAL=>"all";
use vars qw($iters $numtests $bang $ffff $nulnul $OP);
use vars qw($qr $skip_amp $qr_embed); # set by our callers


if (!defined $file) {
    open(TESTS,'op/re_tests') || open(TESTS,'t/op/re_tests')
	|| open(TESTS,':op:re_tests') || die "Can't open re_tests";
}
d41 2
a42 1
my @@tests = <TESTS>;
d44 4
a47 1
close TESTS;
a51 1
$OP = $qr ? 'qr' : 'm';
d54 1
a54 2
printf "1..%d\n# $iters iterations\n", scalar @@tests;
my $test;
d56 1
a56 7
foreach (@@tests) {
    $test++;
    if (!/\S/ || /^\s*#/) {
        print "ok $test # (Blank line or comment)\n";
        if (/\S/) { print $_ };
        next;
    }
d59 5
a63 4
    my ($pat, $subject, $result, $repl, $expect, $reason) = split(/\t/,$_,6);
    $reason = '' unless defined $reason;
    my $input = join(':',$pat,$subject,$result,$repl,$expect);
    $pat = "'$pat'" unless $pat =~ /^[:'\/]/;
d66 4
a69 2
    $subject = eval qq("$subject"); die $@@ if $@@;
    $expect  = eval qq("$expect"); die $@@ if $@@;
d71 1
a71 1
    my $skip = ($skip_amp ? ($result =~ s/B//i) : ($result =~ s/B//));
d74 4
a77 42

    for my $study ('', 'study $subject', 'utf8::upgrade($subject)',
		   'utf8::upgrade($subject); study $subject') {
	# Need to make a copy, else the utf8::upgrade of an alreay studied
	# scalar confuses things.
	my $subject = $subject;
	my $c = $iters;
	my ($code, $match, $got);
        if ($repl eq 'pos') {
            $code= <<EOFCODE;
                $study;
                pos(\$subject)=0;
                \$match = ( \$subject =~ m${pat}g );
                \$got = pos(\$subject);
EOFCODE
        }
        elsif ($qr_embed) {
            $code= <<EOFCODE;
                my \$RE = qr$pat;
                $study;
                \$match = (\$subject =~ /(?:)\$RE(?:)/) while \$c--;
                \$got = "$repl";
EOFCODE
        }
        else {
            $code= <<EOFCODE;
                $study;
                \$match = (\$subject =~ $OP$pat) while \$c--;
                \$got = "$repl";
EOFCODE
        }
        #$code.=qq[\n\$expect="$expect";\n];
        #use Devel::Peek;
        #die Dump($code) if $pat=~/\\h/ and $subject=~/\x{A0}/;
	{
	    # Probably we should annotate specific tests with which warnings
	    # categories they're known to trigger, and hence should be
	    # disabled just for that test
	    no warnings qw(uninitialized regexp);
	    eval $code;
	}
	chomp( my $err = $@@ );
d79 1
a79 1
	    if ($err !~ m!^\Q$expect!) { print "not ok $test (compile) $input => `$err'\n"; next TEST }
d83 1
a83 1
	    print "ok $test # skipped", length($reason) ? " $reason" : '', "\n";
d87 1
a87 1
	    print "not ok $test $input => error `$err'\n$code\n$@@\n"; next TEST;
d90 1
a90 1
	    if ($match) { print "not ok $test ($study) $input => false positive\n"; next TEST }
d94 1
a94 9
	        eval { require Data::Dumper };
		if ($@@) {
		    print "not ok $test ($study) $input => `$got', match=$match\n$code\n";
		}
		else { # better diagnostics
		    my $s = Data::Dumper->new([$subject],['subject'])->Useqq(1)->Dump;
		    my $g = Data::Dumper->new([$got],['got'])->Useqq(1)->Dump;
		    print "not ok $test ($study) $input => `$got', match=$match\n$s\n$g\n$code\n";
		}
d99 1
a99 1
    print "ok $test\n";
d102 9
a110 1
1;
@


1.1.1.7
log
@import perl 5.10.1
@
text
@a15 1
#	T	the test is a TODO (can be combined with y/n/c)
a17 1
#	t	test exposes a bug with threading, TODO if qr_embed_thr
a51 13

    if ($qr_embed_thr) {
	require Config;
	if (!$Config::Config{useithreads}) {
	    print "1..0 # Skip: no ithreads\n";
		exit 0;
	}
	if ($ENV{PERL_CORE_MINITEST}) {
	    print "1..0 # Skip: no dynamic loading on miniperl, no threads\n";
		exit 0;
	}
	require threads;
    }
d57 1
a57 1
use vars qw($qr $skip_amp $qr_embed $qr_embed_thr); # set by our callers
a75 1

d80 1
a80 1
    if (!/\S/ || /^\s*#/ || /^__END__$/) {
d82 1
a82 1
        if (/#/) { print $_ };
d90 1
a90 2
    # the double '' below keeps simple syntax highlighters from going crazy
    $pat = "'$pat'" unless $pat =~ /^[:''\/]/; 
a95 1
    my $todo_qr = $qr_embed_thr && ($result =~ s/t//);
a98 2
    my $todo= $result =~ s/T// ? " # TODO" : "";
    
a122 10
        elsif ($qr_embed_thr) {
            $code= <<EOFCODE;
		# Can't run the match in a subthread, but can do this and
	 	# clone the pattern the other way.
                my \$RE = threads->new(sub {qr$pat})->join();
                $study;
                \$match = (\$subject =~ /(?:)\$RE(?:)/) while \$c--;
                \$got = "$repl";
EOFCODE
        }
d142 1
a142 1
	    if ($err !~ m!^\Q$expect!) { print "not ok $test$todo (compile) $input => `$err'\n"; next TEST }
a148 4
	elsif ( $todo_qr ) {
	    print "not ok $test # TODO", length($reason) ? " - $reason" : '', "\n";
	    next TEST;
	}
d150 1
a150 1
	    print "not ok $test$todo $input => error `$err'\n$code\n$@@\n"; next TEST;
d152 2
a153 2
	elsif ($result =~ /^n/) {
	    if ($match) { print "not ok $test$todo ($study) $input => false positive\n"; next TEST }
d159 1
a159 1
		    print "not ok $test$todo ($study) $input => `$got', match=$match\n$code\n";
d164 1
a164 1
		    print "not ok $test$todo ($study) $input => `$got', match=$match\n$s\n$g\n$code\n";
d170 1
a170 1
    print "ok $test$todo\n";
@


