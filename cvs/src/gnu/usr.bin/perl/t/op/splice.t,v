head	1.2;
access;
symbols
	PERL_5_24_2:1.1.1.7
	OPENBSD_6_1:1.2.0.4
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.6.0.10
	OPENBSD_6_0_BASE:1.1.1.6
	OPENBSD_5_9:1.1.1.6.0.4
	OPENBSD_5_9_BASE:1.1.1.6
	OPENBSD_5_8:1.1.1.6.0.6
	OPENBSD_5_8_BASE:1.1.1.6
	PERL_5_20_2:1.1.1.6
	OPENBSD_5_7:1.1.1.6.0.2
	OPENBSD_5_7_BASE:1.1.1.6
	PERL_5_20_1:1.1.1.6
	OPENBSD_5_6:1.1.1.5.0.4
	OPENBSD_5_6_BASE:1.1.1.5
	PERL_5_18_2:1.1.1.5
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.4.0.6
	OPENBSD_5_5_BASE:1.1.1.4
	OPENBSD_5_4:1.1.1.4.0.2
	OPENBSD_5_4_BASE:1.1.1.4
	PERL_5_16_3:1.1.1.4
	OPENBSD_5_3:1.1.1.3.0.34
	OPENBSD_5_3_BASE:1.1.1.3
	OPENBSD_5_2:1.1.1.3.0.32
	OPENBSD_5_2_BASE:1.1.1.3
	OPENBSD_5_1_BASE:1.1.1.3
	OPENBSD_5_1:1.1.1.3.0.30
	OPENBSD_5_0:1.1.1.3.0.28
	OPENBSD_5_0_BASE:1.1.1.3
	OPENBSD_4_9:1.1.1.3.0.26
	OPENBSD_4_9_BASE:1.1.1.3
	PERL_5_12_2:1.1.1.3
	OPENBSD_4_8:1.1.1.3.0.24
	OPENBSD_4_8_BASE:1.1.1.3
	OPENBSD_4_7:1.1.1.3.0.20
	OPENBSD_4_7_BASE:1.1.1.3
	PERL_5_10_1:1.1.1.3
	OPENBSD_4_6:1.1.1.3.0.22
	OPENBSD_4_6_BASE:1.1.1.3
	OPENBSD_4_5:1.1.1.3.0.18
	OPENBSD_4_5_BASE:1.1.1.3
	PERL_5_10_0:1.1.1.3
	OPENBSD_4_4:1.1.1.3.0.16
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.14
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_2:1.1.1.3.0.12
	OPENBSD_4_2_BASE:1.1.1.3
	OPENBSD_4_1:1.1.1.3.0.10
	OPENBSD_4_1_BASE:1.1.1.3
	OPENBSD_4_0:1.1.1.3.0.8
	OPENBSD_4_0_BASE:1.1.1.3
	PERL_5_8_8:1.1.1.3
	OPENBSD_3_9:1.1.1.3.0.6
	OPENBSD_3_9_BASE:1.1.1.3
	OPENBSD_3_8:1.1.1.3.0.4
	OPENBSD_3_8_BASE:1.1.1.3
	OPENBSD_3_7:1.1.1.3.0.2
	OPENBSD_3_7_BASE:1.1.1.3
	PERL_5_8_6:1.1.1.3
	OPENBSD_3_6:1.1.1.2.0.8
	OPENBSD_3_6_BASE:1.1.1.2
	PERL_5_8_5:1.1.1.2
	PERL_5_8_3:1.1.1.2
	OPENBSD_3_5:1.1.1.2.0.6
	OPENBSD_3_5_BASE:1.1.1.2
	PERL_5_8_2:1.1.1.2
	OPENBSD_3_4:1.1.1.2.0.4
	OPENBSD_3_4_BASE:1.1.1.2
	OPENBSD_3_3:1.1.1.2.0.2
	OPENBSD_3_3_BASE:1.1.1.2
	PERL_5_8_0:1.1.1.2
	OPENBSD_3_2:1.1.1.1.0.14
	OPENBSD_3_2_BASE:1.1.1.1
	OPENBSD_3_1:1.1.1.1.0.12
	OPENBSD_3_1_BASE:1.1.1.1
	OPENBSD_3_0:1.1.1.1.0.10
	OPENBSD_3_0_BASE:1.1.1.1
	PERL_5_6_1:1.1.1.1
	OPENBSD_2_9:1.1.1.1.0.8
	OPENBSD_2_9_BASE:1.1.1.1
	OPENBSD_2_8:1.1.1.1.0.6
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.4
	OPENBSD_2_7_BASE:1.1.1.1
	PERL_5_6_0:1.1.1.1
	OPENBSD_2_6:1.1.1.1.0.2
	OPENBSD_2_6_BASE:1.1.1.1
	PERL_500503:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.32.20;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	99.04.29.22.41.51;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.29.22.41.51;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.10.27.22.15.11;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2005.01.15.21.18.19;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2013.03.25.20.09.37;	author sthen;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2014.03.24.14.59.10;	author afresh1;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2014.11.17.20.53.18;	author afresh1;	state Exp;
branches;
next	1.1.1.7;
commitid	B31cAbBIXiCqnL97;

1.1.1.7
date	2017.08.14.13.46.24;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl

BEGIN {
    chdir 't' if -d 't';
    @@INC = '../lib';
    require './test.pl';
}

$|  = 1;

@@a = (1..10);

sub j { join(":",@@_) }

is( j(splice(@@a,@@a,0,11,12)), '', 'return value of splice when nothing is removed, only added');
is( j(@@a), j(1..12), '... added two elements');

is( j(splice(@@a,-1)), "12", 'remove last element, return value');
is( j(@@a), j(1..11), '... removed last element');

is( j(splice(@@a,0,1)), "1", 'remove first element, return value');
is( j(@@a), j(2..11), '... first element removed');

is( j(splice(@@a,0,0,0,1)), "", 'emulate shift, return value is empty');
is( j(@@a), j(0..11), '... added two elements to beginning of the list');

is( j(splice(@@a,5,1,5)), "5", 'remove and replace an element to the end of the list, return value is the element');
is( j(@@a), j(0..11), '... list remains the same');

is( j(splice(@@a, @@a, 0, 12, 13)), "", 'push two elements onto the end of the list, return value is empty');
is( j(@@a), j(0..13), '... added two elements to the end of the list');

is( j(splice(@@a, -@@a, @@a, 1, 2, 3)), j(0..13), 'splice the whole list out, add 3 elements, return value is @@a');
is( j(@@a), j(1..3), '... array only contains new elements');

is( j(splice(@@a, 1, -1, 7, 7)), "2", 'replace middle element with two elements, negative offset, return value is the element' );
is( j(@@a), j(1,7,7,3), '... array 1,7,7,3');

is( j(splice(@@a,-3,-2,2)), j(7), 'replace first 7 with a 2, negative offset, negative length, return value is 7');
is( j(@@a), j(1,2,7,3), '... array has 1,2,7,3');

# Bug 20000223.001 - no test for splice(@@array).  Destructive test!
is( j(splice(@@a)), j(1,2,7,3), 'bare splice empties the array, return value is the array');
is( j(@@a),  '', 'array is empty');

# Tests 11 and 12:
# [ID 20010711.005] in Tie::Array, SPLICE ignores context, breaking SHIFT

my $foo;

@@a = ('red', 'green', 'blue');
$foo = splice @@a, 1, 2;
is( $foo, 'blue', 'remove a single element in scalar context');

@@a = ('red', 'green', 'blue');
$foo = shift @@a;
is( $foo, 'red', 'do the same with shift');

# Bug [perl #30568] - insertions of deleted elements
@@a = (1, 2, 3);
splice( @@a, 0, 3, $a[1], $a[0] );
is( j(@@a), j(2,1), 'splice and replace with indexes 1, 0');

@@a = (1, 2, 3);
splice( @@a, 0, 3 ,$a[0], $a[1] );
is( j(@@a), j(1,2), 'splice and replace with indexes 0, 1');

@@a = (1, 2, 3);
splice( @@a, 0, 3 ,$a[2], $a[1], $a[0] );
is( j(@@a), j(3,2,1), 'splice and replace with indexes 2, 1, 0');

@@a = (1, 2, 3);
splice( @@a, 0, 3, $a[0], $a[1], $a[2], $a[0], $a[1], $a[2] );
is( j(@@a), j(1,2,3,1,2,3), 'splice and replace with a whole bunch');

@@a = (1, 2, 3);
splice( @@a, 1, 2, $a[2], $a[1] );
is( j(@@a), j(1,3,2), 'swap last two elements');

@@a = (1, 2, 3);
splice( @@a, 1, 2, $a[1], $a[1] );
is( j(@@a), j(1,2,2), 'duplicate middle element on the end');

# splice should invoke get magic

ok( ! Foo->isa('Bar'), 'Foo is not a Bar');

splice @@Foo::ISA, 0, 0, 'Bar';
ok( Foo->isa('Bar'), 'splice @@ISA and make Foo a Bar');

# Test arrays with nonexistent elements (crashes when it fails)
@@a = ();
$#a++;
is sprintf("%s", splice @@a, 0, 1), "",
  'splice handles nonexistent elems when shrinking the array';
@@a = ();
$#a++;
is sprintf("%s", splice @@a, 0, 1, undef), "",
  'splice handles nonexistent elems when array len stays the same';

done_testing;
@


1.1
log
@Initial revision
@
text
@d3 7
a9 1
print "1..9\n";
d15 56
a70 2
print "not " unless j(splice(@@a,@@a,0,11,12)) eq "" && j(@@a) eq j(1..12);
print "ok 1\n";
d72 3
a74 2
print "not " unless j(splice(@@a,-1)) eq "12" && j(@@a) eq j(1..11);
print "ok 2\n";
d76 3
a78 2
print "not " unless j(splice(@@a,0,1)) eq "1" && j(@@a) eq j(2..11);
print "ok 3\n";
d80 3
a82 2
print "not " unless j(splice(@@a,0,0,0,1)) eq "" && j(@@a) eq j(0..11);
print "ok 4\n";
d84 1
a84 2
print "not " unless j(splice(@@a,5,1,5)) eq "5" && j(@@a) eq j(0..11);
print "ok 5\n";
d86 1
a86 2
print "not " unless j(splice(@@a, 20, 0, 12, 13)) eq "" && j(@@a) eq j(0..13);
print "ok 6\n";
d88 2
a89 2
print "not " unless j(splice(@@a, -@@a, @@a, 1, 2, 3)) eq j(0..13) && j(@@a) eq j(1..3);
print "ok 7\n";
d91 9
a99 2
print "not " unless j(splice(@@a, 1, -1, 7, 7)) eq "2" && j(@@a) eq j(1,7,7,3);
print "ok 8\n";
d101 1
a101 2
print "not " unless j(splice(@@a,-3,-2,2)) eq j(7) && j(@@a) eq j(1,2,7,3);
print "ok 9\n";
@


1.1.1.1
log
@perl5.005_03
@
text
@@


1.1.1.2
log
@stock perl 5.8.0 from CPAN
@
text
@d3 1
a3 1
print "1..12\n";
d24 1
a24 1
print "not " unless j(splice(@@a, @@a, 0, 12, 13)) eq "" && j(@@a) eq j(0..13);
a34 20

# Bug 20000223.001 - no test for splice(@@array).  Destructive test!
print "not " unless j(splice(@@a)) eq j(1,2,7,3) && j(@@a) eq '';
print "ok 10\n";

# Tests 11 and 12:
# [ID 20010711.005] in Tie::Array, SPLICE ignores context, breaking SHIFT

my $foo;

@@a = ('red', 'green', 'blue');
$foo = splice @@a, 1, 2;
print "not " unless $foo eq 'blue';
print "ok 11\n";

@@a = ('red', 'green', 'blue');
$foo = shift @@a;
print "not " unless $foo eq 'red';
print "ok 12\n";

@


1.1.1.3
log
@perl 5.8.6 from CPAN
@
text
@d3 1
a3 1
print "1..18\n";
a54 30
# Bug [perl #30568] - insertions of deleted elements
@@a = (1, 2, 3);
splice( @@a, 0, 3, $a[1], $a[0] );
print "not " unless j(@@a) eq j(2,1);
print "ok 13\n";

@@a = (1, 2, 3);
splice( @@a, 0, 3 ,$a[0], $a[1] );
print "not " unless j(@@a) eq j(1,2);
print "ok 14\n";

@@a = (1, 2, 3);
splice( @@a, 0, 3 ,$a[2], $a[1], $a[0] );
print "not " unless j(@@a) eq j(3,2,1);
print "ok 15\n";

@@a = (1, 2, 3);
splice( @@a, 0, 3, $a[0], $a[1], $a[2], $a[0], $a[1], $a[2] );
print "not " unless j(@@a) eq j(1,2,3,1,2,3);
print "ok 16\n";

@@a = (1, 2, 3);
splice( @@a, 1, 2, $a[2], $a[1] );
print "not " unless j(@@a) eq j(1,3,2);
print "ok 17\n";

@@a = (1, 2, 3);
splice( @@a, 1, 2, $a[1], $a[1] );
print "not " unless j(@@a) eq j(1,2,2);
print "ok 18\n";
@


1.1.1.4
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d3 1
a3 1
print "1..21\n";
a84 15

# splice should invoke get magic

print "not " if Foo->isa('Bar');
print "ok 19\n";

splice @@Foo::ISA, 0, 0, 'Bar';

print "not " if !Foo->isa('Bar');
print "ok 20\n";

# Test undef first arg
eval { splice( $new_arrayref, 0, 0, 1, 2, 3 ) };
print "not " unless $@@ && $@@ =~ /Not an ARRAY/;
print "ok 21\n";
@


1.1.1.5
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d3 1
a3 7
BEGIN {
    chdir 't' if -d 't';
    @@INC = '../lib';
    require './test.pl';
}

$|  = 1;
d9 2
a10 2
is( j(splice(@@a,@@a,0,11,12)), '', 'return value of splice when nothing is removed, only added');
is( j(@@a), j(1..12), '... added two elements');
d12 2
a13 2
is( j(splice(@@a,-1)), "12", 'remove last element, return value');
is( j(@@a), j(1..11), '... removed last element');
d15 2
a16 2
is( j(splice(@@a,0,1)), "1", 'remove first element, return value');
is( j(@@a), j(2..11), '... first element removed');
d18 2
a19 2
is( j(splice(@@a,0,0,0,1)), "", 'emulate shift, return value is empty');
is( j(@@a), j(0..11), '... added two elements to beginning of the list');
d21 2
a22 2
is( j(splice(@@a,5,1,5)), "5", 'remove and replace an element to the end of the list, return value is the element');
is( j(@@a), j(0..11), '... list remains the same');
d24 2
a25 2
is( j(splice(@@a, @@a, 0, 12, 13)), "", 'push two elements onto the end of the list, return value is empty');
is( j(@@a), j(0..13), '... added two elements to the end of the list');
d27 2
a28 2
is( j(splice(@@a, -@@a, @@a, 1, 2, 3)), j(0..13), 'splice the whole list out, add 3 elements, return value is @@a');
is( j(@@a), j(1..3), '... array only contains new elements');
d30 2
a31 2
is( j(splice(@@a, 1, -1, 7, 7)), "2", 'replace middle element with two elements, negative offset, return value is the element' );
is( j(@@a), j(1,7,7,3), '... array 1,7,7,3');
d33 2
a34 2
is( j(splice(@@a,-3,-2,2)), j(7), 'replace first 7 with a 2, negative offset, negative length, return value is 7');
is( j(@@a), j(1,2,7,3), '... array has 1,2,7,3');
d37 2
a38 2
is( j(splice(@@a)), j(1,2,7,3), 'bare splice empties the array, return value is the array');
is( j(@@a),  '', 'array is empty');
d47 2
a48 1
is( $foo, 'blue', 'remove a single element in scalar context');
d52 2
a53 1
is( $foo, 'red', 'do the same with shift');
d58 2
a59 1
is( j(@@a), j(2,1), 'splice and replace with indexes 1, 0');
d63 2
a64 1
is( j(@@a), j(1,2), 'splice and replace with indexes 0, 1');
d68 2
a69 1
is( j(@@a), j(3,2,1), 'splice and replace with indexes 2, 1, 0');
d73 2
a74 1
is( j(@@a), j(1,2,3,1,2,3), 'splice and replace with a whole bunch');
d78 2
a79 1
is( j(@@a), j(1,3,2), 'swap last two elements');
d83 2
a84 1
is( j(@@a), j(1,2,2), 'duplicate middle element on the end');
d88 2
a89 1
ok( ! Foo->isa('Bar'), 'Foo is not a Bar');
d92 3
a94 1
ok( !oo->isa('Bar'), 'splice @@ISA and make Foo a Bar');
d98 2
a99 3
like($@@, qr/Not an ARRAY/, 'undefined first argument to splice');

done_testing;
@


1.1.1.6
log
@Import perl-5.20.1
@
text
@d89 1
a89 1
ok( Foo->isa('Bar'), 'splice @@ISA and make Foo a Bar');
d92 1
a92 1
eval { no warnings 'experimental';splice( $new_arrayref, 0, 0, 1, 2, 3 ) };
a93 10

# Test arrays with nonexistent elements (crashes when it fails)
@@a = ();
$#a++;
is sprintf("%s", splice @@a, 0, 1), "",
  'splice handles nonexistent elems when shrinking the array';
@@a = ();
$#a++;
is sprintf("%s", splice @@a, 0, 1, undef), "",
  'splice handles nonexistent elems when array len stays the same';
@


1.1.1.7
log
@Import perl-5.24.2
@
text
@d91 4
@


