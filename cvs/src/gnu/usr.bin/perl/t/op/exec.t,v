head	1.12;
access;
symbols
	OPENBSD_6_2:1.12.0.2
	OPENBSD_6_2_BASE:1.12
	PERL_5_24_2:1.1.1.11
	OPENBSD_6_1:1.12.0.4
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.11.0.10
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.4
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.11.0.6
	OPENBSD_5_8_BASE:1.11
	PERL_5_20_2:1.1.1.10
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	PERL_5_20_1:1.1.1.10
	OPENBSD_5_6:1.10.0.4
	OPENBSD_5_6_BASE:1.10
	PERL_5_18_2:1.1.1.9
	PERL:1.1.1
	OPENBSD_5_5:1.9.0.6
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.2
	OPENBSD_5_4_BASE:1.9
	PERL_5_16_3:1.1.1.8
	OPENBSD_5_3:1.8.0.10
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.8
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.6
	OPENBSD_5_0:1.8.0.4
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.2
	OPENBSD_4_9_BASE:1.8
	PERL_5_12_2:1.1.1.7
	OPENBSD_4_8:1.7.0.4
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.2
	OPENBSD_4_7_BASE:1.7
	PERL_5_10_1:1.1.1.6
	OPENBSD_4_6:1.6.0.6
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.2
	OPENBSD_4_5_BASE:1.6
	PERL_5_10_0:1.1.1.5
	OPENBSD_4_4:1.5.0.24
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.22
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.20
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.18
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.16
	OPENBSD_4_0_BASE:1.5
	PERL_5_8_8:1.1.1.4
	OPENBSD_3_9:1.5.0.14
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.12
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.10
	OPENBSD_3_7_BASE:1.5
	PERL_5_8_6:1.1.1.4
	OPENBSD_3_6:1.5.0.8
	OPENBSD_3_6_BASE:1.5
	PERL_5_8_5:1.1.1.4
	PERL_5_8_3:1.1.1.4
	OPENBSD_3_5:1.5.0.6
	OPENBSD_3_5_BASE:1.5
	PERL_5_8_2:1.1.1.4
	OPENBSD_3_4:1.5.0.4
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.4.0.12
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.10
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.8
	OPENBSD_3_0_BASE:1.4
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.12
date	2017.02.05.00.32.20;	author afresh1;	state Exp;
branches;
next	1.11;
commitid	cxJ08BvJA9Pt2PTM;

1.11
date	2014.11.17.20.57.07;	author afresh1;	state Exp;
branches;
next	1.10;
commitid	QP75iYx42Uo7mMxO;

1.10
date	2014.03.24.15.05.33;	author afresh1;	state Exp;
branches;
next	1.9;

1.9
date	2013.03.25.20.40.59;	author sthen;	state Exp;
branches;
next	1.8;

1.8
date	2010.09.24.15.07.08;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2009.10.12.18.30.27;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2008.09.29.17.36.19;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.10.27.22.25.37;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.08.22;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.52.35;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.08.05.19;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.13.17;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.13.17;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.41.44;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.10.48;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.27.22.15.10;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2008.09.29.17.19.00;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2009.10.12.18.10.45;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2010.09.24.14.49.18;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2013.03.25.20.09.35;	author sthen;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2014.03.24.14.59.10;	author afresh1;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2014.11.17.20.53.17;	author afresh1;	state Exp;
branches;
next	1.1.1.11;
commitid	B31cAbBIXiCqnL97;

1.1.1.11
date	2017.08.14.13.46.23;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.12
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl

BEGIN {
    chdir 't' if -d 't';
    @@INC = ('../lib');
    require './test.pl';
}

my $vms_exit_mode = 0;

if ($^O eq 'VMS') {
    if (eval 'require VMS::Feature') {
        $vms_exit_mode = !(VMS::Feature::current("posix_exit"));
    } else {
        my $env_unix_rpt = $ENV{'DECC$FILENAME_UNIX_REPORT'} || '';
        my $env_posix_ex = $ENV{'PERL_VMS_POSIX_EXIT'} || '';
        my $unix_rpt = $env_unix_rpt =~ /^[ET1]/i; 
        my $posix_ex = $env_posix_ex =~ /^[ET1]/i;
        if (($unix_rpt || $posix_ex) ) {
            $vms_exit_mode = 0;
        } else {
            $vms_exit_mode = 1;
        }
    }
}


# suppress VMS whinging about bad execs.
use vmsish qw(hushed);

$| = 1;				# flush stdout

$ENV{LC_ALL}   = 'C';		# Forge English error messages.
$ENV{LANGUAGE} = 'C';		# Ditto in GNU.

my $Is_VMS   = $^O eq 'VMS';
my $Is_Win32 = $^O eq 'MSWin32';

plan(tests => 24);

my $Perl = which_perl();

my $exit;
SKIP: {
    skip("bug/feature of pdksh", 2) if $^O eq 'os2';

    my $tnum = curr_test();
    $exit = system qq{$Perl -le "print q{ok $tnum - interp system(EXPR)"}};
    next_test();
    is( $exit, 0, '  exited 0' );
}

my $tnum = curr_test();
$exit = system qq{$Perl -le "print q{ok $tnum - split & direct system(EXPR)"}};
next_test();
is( $exit, 0, '  exited 0' );

# On VMS and Win32 you need the quotes around the program or it won't work.
# On Unix its the opposite.
my $quote = $Is_VMS || $Is_Win32 ? '"' : '';
$tnum = curr_test();
$exit = system $Perl, '-le', 
               "${quote}print q{ok $tnum - system(PROG, LIST)}${quote}";
next_test();
is( $exit, 0, '  exited 0' );


# Some basic piped commands.  Some OS's have trouble with "helpfully"
# putting newlines on the end of piped output.  So we split this into
# newline insensitive and newline sensitive tests.
my $echo_out = `$Perl -e "print 'ok'" | $Perl -le "print <STDIN>"`;
$echo_out =~ s/\n\n/\n/g;
is( $echo_out, "ok\n", 'piped echo emulation');

{
    # here we check if extra newlines are going to be slapped on
    # piped output.
    local $TODO = 'VMS sticks newlines on everything' if $Is_VMS;

    is( scalar `$Perl -e "print 'ok'"`,
        "ok", 'no extra newlines on ``' );

    is( scalar `$Perl -e "print 'ok'" | $Perl -e "print <STDIN>"`, 
        "ok", 'no extra newlines on pipes');

    is( scalar `$Perl -le "print 'ok'" | $Perl -le "print <STDIN>"`, 
        "ok\n\n", 'doubled up newlines');

    is( scalar `$Perl -e "print 'ok'" | $Perl -le "print <STDIN>"`, 
        "ok\n", 'extra newlines on inside pipes');

    is( scalar `$Perl -le "print 'ok'" | $Perl -e "print <STDIN>"`, 
        "ok\n", 'extra newlines on outgoing pipes');

    {
	local($/) = \2;       
	$out = runperl(prog => 'print q{1234}');
	is($out, "1234", 'ignore $/ when capturing output in scalar context');
    }
}


is( system(qq{$Perl -e "exit 0"}), 0,     'Explicit exit of 0' );

my $exit_one = $vms_exit_mode ? 4 << 8 : 1 << 8;
is( system(qq{$Perl "-I../lib" -e "use vmsish qw(hushed); exit 1"}), $exit_one,
    'Explicit exit of 1' );

$rc = system { "lskdfj" } "lskdfj";
unless( ok($rc == 255 << 8 or $rc == -1 or $rc == 256 or $rc == 512) ) {
    print "# \$rc == $rc\n";
}

unless ( ok( $! == 2  or  $! =~ /\bno\b.*\bfile/i or  
             $! == 13 or  $! =~ /permission denied/i or
             $! == 22 or  $! =~ /invalid argument/i  ) ) {
    printf "# \$! eq %d, '%s'\n", $!, $!;
}


is( `$Perl -le "print 'ok'"`,   "ok\n",     'basic ``' );
is( <<`END`,                    "ok\n",     '<<`HEREDOC`' );
$Perl -le "print 'ok'"
END

{
    local $_ = qq($Perl -le "print 'ok'");
    is( readpipe, "ok\n", 'readpipe default argument' );
}

package o {
    use subs "readpipe";
    sub readpipe { pop }
    ::is `${\"hello"}`, 'hello',
         'overridden `` interpolates [perl #115330]';
    ::is <<`119827`, "ls\n",
l${\"s"}
119827
        '<<`` respects overrides and interpolates [perl #119827]';
}

TODO: {
    my $tnum = curr_test();
    if( $^O =~ /Win32/ ) {
        print "not ok $tnum - exec failure doesn't terminate process " .
              "# TODO Win32 exec failure waits for user input\n";
        next_test();
        last TODO;
    }

    ok( !exec("lskdjfalksdjfdjfkls"), 
        "exec failure doesn't terminate process");
}

my $test = curr_test();
exec $Perl, '-le', qq{${quote}print 'ok $test - exec PROG, LIST'${quote}};
fail("This should never be reached if the exec() worked");
@


1.11
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d127 1
a127 2
    no warnings 'experimental::lexical_topic';
    my $_ = qq($Perl -le "print 'ok'");
@


1.10
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d39 1
a39 1
plan(tests => 22);
d130 11
@


1.9
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d127 1
@


1.8
log
@merge in perl 5.12.2 plus local changes
@
text
@d28 1
a28 1
# supress VMS whinging about bad execs.
@


1.7
log
@Merge in perl 5.10.1; part two
@
text
@a38 2
skip_all("Tests mostly usesless on MacOS") if $^O eq 'MacOS';

@


1.6
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d9 19
d107 1
a107 1
my $exit_one = $Is_VMS ? 4 << 8 : 1 << 8;
@


1.5
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d3 1
a3 1
BEGIN: {
d22 1
a22 1
plan(tests => 21);
d99 1
a99 1
             $! == 22 or  $! =~ /invalid argument/           ) ) {
d109 4
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d3 9
d17 79
a95 37
if ($^O eq 'MSWin32') {
    # XXX the system tests could be written to use ./perl and so work on Win32
    print "1..0 # Skip: shh, win32\n";
    exit(0);
}

print "1..8\n";

if ($^O ne 'os2') {
  print "not ok 1\n" if system "echo ok \\1";	# shell interpreted
} 
else {
  print "ok 1 # skipped: bug/feature of pdksh\n"; # shell interpreted
}
print "not ok 2\n" if system "echo ok 2";	# split and directly called
print "not ok 3\n" if system "echo", "ok", "3"; # directly called

# these should probably be rewritten to match the examples in perlfunc.pod
if (system "true") {print "not ok 4\n";} else {print "ok 4\n";}

if ($^O eq 'mpeix') {
    print "ok 5 # skipped: status broken on MPE/iX\n";
} else {
    if ((system "/bin/sh -c 'exit 1'") != 256) { print "not "; }
    print "ok 5\n";
}

$rc = system "lskdfj";
if ($rc == 255 << 8 or $rc == -1 and
     (
      $! == 2 or
      $! =~ /\bno\b.*\bfile/i or
      $! == 13 or
      $! =~ /permission denied/i
     )
   )
 {print "ok 6\n";} else {print "not ok 6\n";}
d97 25
a121 1
unless (exec "lskdjfalksdjfdjfkls") {print "ok 7\n";} else {print "not ok 7\n";}
d123 3
a125 1
exec "echo","ok","8";
@


1.3
log
@perl5.005_03 (stock)
@
text
@d3 1
a3 1
# $RCSfile: exec.t,v $$Revision: 4.1 $$Date: 92/08/07 18:27:49 $
d5 2
a6 1
$| = 1;				# flush stdout
a8 1
    print "# exec is unsupported on Win32\n";
d10 1
a10 1
    print "1..0\n";
d28 6
a33 2
if ((system "/bin/sh -c 'exit 1'") != 256) { print "not "; }
print "ok 5\n";
d35 10
a44 1
if ((system "lskdfj") == 255 << 8) {print "ok 6\n";} else {print "not ok 6\n";}
@


1.2
log
@perl 5.004_04
@
text
@d9 1
d16 6
a21 1
print "not ok 1\n" if system "echo ok \\1";	# shell interpreted
d25 1
@


1.1
log
@Initial revision
@
text
@d6 7
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@a5 8

if ($^O eq 'MSWin32') {
    print "# exec is unsupported on Win32\n";
    # XXX the system tests could be written to use ./perl and so work on Win32
    print "1..0\n";
    exit(0);
}

d8 1
a8 6
if ($^O ne 'os2') {
  print "not ok 1\n" if system "echo ok \\1";	# shell interpreted
} 
else {
  print "ok 1 # skipped: bug/feature of pdksh\n"; # shell interpreted
}
a11 1
# these should probably be rewritten to match the examples in perlfunc.pod
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d3 2
a6 3
$ENV{LC_ALL}   = 'C';		# Forge English error messages.
$ENV{LANGUAGE} = 'C';		# Ditto in GNU.

d8 1
d10 1
a10 1
    print "1..0 # Skip: shh, win32\n";
d28 2
a29 6
if ($^O eq 'mpeix') {
    print "ok 5 # skipped: status broken on MPE/iX\n";
} else {
    if ((system "/bin/sh -c 'exit 1'") != 256) { print "not "; }
    print "ok 5\n";
}
d31 1
a31 10
$rc = system "lskdfj";
if ($rc == 255 << 8 or $rc == -1 and
     (
      $! == 2 or
      $! =~ /\bno\b.*\bfile/i or
      $! == 13 or
      $! =~ /permission denied/i
     )
   )
 {print "ok 6\n";} else {print "not ok 6\n";}
@


1.1.1.4
log
@stock perl 5.8.0 from CPAN
@
text
@a2 9
BEGIN: {
    chdir 't' if -d 't';
    @@INC = ('../lib');
    require './test.pl';
}

# supress VMS whinging about bad execs.
use vmsish qw(hushed);

d8 37
a44 79
my $Is_VMS   = $^O eq 'VMS';
my $Is_Win32 = $^O eq 'MSWin32';

skip_all("Tests mostly usesless on MacOS") if $^O eq 'MacOS';

plan(tests => 21);

my $Perl = which_perl();

my $exit;
SKIP: {
    skip("bug/feature of pdksh", 2) if $^O eq 'os2';

    my $tnum = curr_test();
    $exit = system qq{$Perl -le "print q{ok $tnum - interp system(EXPR)"}};
    next_test();
    is( $exit, 0, '  exited 0' );
}

my $tnum = curr_test();
$exit = system qq{$Perl -le "print q{ok $tnum - split & direct system(EXPR)"}};
next_test();
is( $exit, 0, '  exited 0' );

# On VMS and Win32 you need the quotes around the program or it won't work.
# On Unix its the opposite.
my $quote = $Is_VMS || $Is_Win32 ? '"' : '';
$tnum = curr_test();
$exit = system $Perl, '-le', 
               "${quote}print q{ok $tnum - system(PROG, LIST)}${quote}";
next_test();
is( $exit, 0, '  exited 0' );


# Some basic piped commands.  Some OS's have trouble with "helpfully"
# putting newlines on the end of piped output.  So we split this into
# newline insensitive and newline sensitive tests.
my $echo_out = `$Perl -e "print 'ok'" | $Perl -le "print <STDIN>"`;
$echo_out =~ s/\n\n/\n/g;
is( $echo_out, "ok\n", 'piped echo emulation');

{
    # here we check if extra newlines are going to be slapped on
    # piped output.
    local $TODO = 'VMS sticks newlines on everything' if $Is_VMS;

    is( scalar `$Perl -e "print 'ok'"`,
        "ok", 'no extra newlines on ``' );

    is( scalar `$Perl -e "print 'ok'" | $Perl -e "print <STDIN>"`, 
        "ok", 'no extra newlines on pipes');

    is( scalar `$Perl -le "print 'ok'" | $Perl -le "print <STDIN>"`, 
        "ok\n\n", 'doubled up newlines');

    is( scalar `$Perl -e "print 'ok'" | $Perl -le "print <STDIN>"`, 
        "ok\n", 'extra newlines on inside pipes');

    is( scalar `$Perl -le "print 'ok'" | $Perl -e "print <STDIN>"`, 
        "ok\n", 'extra newlines on outgoing pipes');

    {
	local($/) = \2;       
	$out = runperl(prog => 'print q{1234}');
	is($out, "1234", 'ignore $/ when capturing output in scalar context');
    }
}


is( system(qq{$Perl -e "exit 0"}), 0,     'Explicit exit of 0' );

my $exit_one = $Is_VMS ? 4 << 8 : 1 << 8;
is( system(qq{$Perl "-I../lib" -e "use vmsish qw(hushed); exit 1"}), $exit_one,
    'Explicit exit of 1' );

$rc = system { "lskdfj" } "lskdfj";
unless( ok($rc == 255 << 8 or $rc == -1 or $rc == 256 or $rc == 512) ) {
    print "# \$rc == $rc\n";
}
d46 1
a46 25
unless ( ok( $! == 2  or  $! =~ /\bno\b.*\bfile/i or  
             $! == 13 or  $! =~ /permission denied/i or
             $! == 22 or  $! =~ /invalid argument/           ) ) {
    printf "# \$! eq %d, '%s'\n", $!, $!;
}


is( `$Perl -le "print 'ok'"`,   "ok\n",     'basic ``' );
is( <<`END`,                    "ok\n",     '<<`HEREDOC`' );
$Perl -le "print 'ok'"
END


TODO: {
    my $tnum = curr_test();
    if( $^O =~ /Win32/ ) {
        print "not ok $tnum - exec failure doesn't terminate process " .
              "# TODO Win32 exec failure waits for user input\n";
        next_test();
        last TODO;
    }

    ok( !exec("lskdjfalksdjfdjfkls"), 
        "exec failure doesn't terminate process");
}
d48 1
a48 3
my $test = curr_test();
exec $Perl, '-le', qq{${quote}print 'ok $test - exec PROG, LIST'${quote}};
fail("This should never be reached if the exec() worked");
@


1.1.1.5
log
@import perl 5.10.0 from CPAN
@
text
@d3 1
a3 1
BEGIN {
d22 1
a22 1
plan(tests => 22);
d99 1
a99 1
             $! == 22 or  $! =~ /invalid argument/i  ) ) {
a108 4
{
    my $_ = qq($Perl -le "print 'ok'");
    is( readpipe, "ok\n", 'readpipe default argument' );
}
@


1.1.1.6
log
@import perl 5.10.1
@
text
@a8 19
my $vms_exit_mode = 0;

if ($^O eq 'VMS') {
    if (eval 'require VMS::Feature') {
        $vms_exit_mode = !(VMS::Feature::current("posix_exit"));
    } else {
        my $env_unix_rpt = $ENV{'DECC$FILENAME_UNIX_REPORT'} || '';
        my $env_posix_ex = $ENV{'PERL_VMS_POSIX_EXIT'} || '';
        my $unix_rpt = $env_unix_rpt =~ /^[ET1]/i; 
        my $posix_ex = $env_posix_ex =~ /^[ET1]/i;
        if (($unix_rpt || $posix_ex) ) {
            $vms_exit_mode = 0;
        } else {
            $vms_exit_mode = 1;
        }
    }
}


d88 1
a88 1
my $exit_one = $vms_exit_mode ? 4 << 8 : 1 << 8;
@


1.1.1.7
log
@Perl 5.12.2 from CPAN
@
text
@d39 2
@


1.1.1.8
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d28 1
a28 1
# suppress VMS whinging about bad execs.
@


1.1.1.9
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@a126 1
    no warnings 'experimental::lexical_topic';
@


1.1.1.10
log
@Import perl-5.20.1
@
text
@d39 1
a39 1
plan(tests => 24);
a129 11
}

package o {
    use subs "readpipe";
    sub readpipe { pop }
    ::is `${\"hello"}`, 'hello',
         'overridden `` interpolates [perl #115330]';
    ::is <<`119827`, "ls\n",
l${\"s"}
119827
        '<<`` respects overrides and interpolates [perl #119827]';
@


1.1.1.11
log
@Import perl-5.24.2
@
text
@d127 2
a128 1
    local $_ = qq($Perl -le "print 'ok'");
@


