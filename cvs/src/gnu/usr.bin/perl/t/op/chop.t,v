head	1.14;
access;
symbols
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.13.0.12
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.6
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.13.0.8
	OPENBSD_5_8_BASE:1.13
	PERL_5_20_2:1.1.1.12
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	PERL_5_20_1:1.1.1.12
	OPENBSD_5_6:1.13.0.4
	OPENBSD_5_6_BASE:1.13
	PERL_5_18_2:1.1.1.12
	PERL:1.1.1
	OPENBSD_5_5:1.12.0.6
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.2
	OPENBSD_5_4_BASE:1.12
	PERL_5_16_3:1.1.1.11
	OPENBSD_5_3:1.11.0.10
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.8
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.6
	OPENBSD_5_0:1.11.0.4
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.2
	OPENBSD_4_9_BASE:1.11
	PERL_5_12_2:1.1.1.10
	OPENBSD_4_8:1.10.0.8
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.4
	OPENBSD_4_7_BASE:1.10
	PERL_5_10_1:1.1.1.9
	OPENBSD_4_6:1.10.0.6
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.2
	OPENBSD_4_5_BASE:1.10
	PERL_5_10_0:1.1.1.9
	OPENBSD_4_4:1.9.0.10
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.8
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.6
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.4
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9
	PERL_5_8_8:1.1.1.8
	OPENBSD_3_9:1.8.0.8
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.6
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.4
	OPENBSD_3_7_BASE:1.8
	PERL_5_8_6:1.1.1.7
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	PERL_5_8_5:1.1.1.7
	PERL_5_8_3:1.1.1.6
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.14
date	2017.02.05.00.32.20;	author afresh1;	state Exp;
branches;
next	1.13;
commitid	cxJ08BvJA9Pt2PTM;

1.13
date	2014.03.24.15.05.33;	author afresh1;	state Exp;
branches;
next	1.12;

1.12
date	2013.03.25.20.40.59;	author sthen;	state Exp;
branches;
next	1.11;

1.11
date	2010.09.24.15.07.08;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2008.09.29.17.36.19;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2006.03.28.19.23.12;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2004.08.09.18.10.27;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.48;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.37;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.36.17;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.08.20;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.52.34;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.08.05.15;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.13.16;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.13.16;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.41.43;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.10.47;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.25.34;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.15.10;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.44.31;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.08.09.17.48.34;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2006.03.28.18.49.44;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2008.09.29.17.19.00;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2010.09.24.14.49.17;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2013.03.25.20.09.35;	author sthen;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2014.03.24.14.59.10;	author afresh1;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl

BEGIN {
    chdir 't' if -d 't';
    @@INC = '../lib';
    require './test.pl'; require './charset_tools.pl';
}

my $tests_count = 148;
plan tests => $tests_count;

$_ = 'abc';
$c = foo();
is ($c . $_, 'cab', 'optimized');

$_ = 'abc';
$c = chop($_);
is ($c . $_ , 'cab', 'unoptimized');

sub foo {
    chop;
}

@@foo = ("hi \n","there\n","!\n");
@@bar = @@foo;
chop(@@bar);
is (join('',@@bar), 'hi there!', 'chop list of strings');

$foo = "\n";
chop($foo,@@foo);
is (join('',$foo,@@foo), 'hi there!', 'chop on list reduces one-character element to an empty string');

$_ = "foo\n\n";
$got = chomp();
is($got, 1, 'check return value when chomp string ending with two newlines; $/ is set to default of one newline');
is ($_, "foo\n", 'chomp string ending with two newlines while $/ is set to one newline' );

$_ = "foo\n";
$got = chomp();
is($got, 1, 'check return value chomp string ending with one newline while $/ is set to a newline');
is ($_, "foo", 'test typical use of chomp; chomp a string ending in a single newline while $/ is set to default of one newline');

$_ = "foo";
$got = chomp();
is($got, 0, 'check return value when chomp a string that does not end with current value of $/, 0 should be returned');
is ($_, "foo", 'chomp a string that does not end with the current value of $/');

$_ = "foo";
$/ = "oo";
$got = chomp();
is ($got, "2", 'check return value when chomp string with $/ consisting of more than one character, and with the ending of the string matching $/');
is ($_, "f", 'chomp a string when $/ consists of two characters that are at the end of the string, check that chomped string contains remnant of original string');

$_ = "bar";
$/ = "oo";
$got = chomp();
is($got, "0", 'check return value when call chomp with $/ consisting of more than one character, and with the ending of the string NOT matching $/');
is ($_, "bar", 'chomp a string when $/ consists of two characters that are NOT at the end of the string');

$_ = "f\n\n\n\n\n";
$/ = "";
$got = chomp();
is ($got, 5, 'check return value when chomp in paragraph mode on string ending with 5 newlines');
is ($_, "f", 'chomp in paragraph mode on string ending with 5 newlines');

$_ = "f\n\n";
$/ = "";
$got = chomp();
is ($got, 2, 'check return value when chomp in paragraph mode on string ending with 2 newlines');
is ($_, "f", 'chomp in paragraph mode on string ending with 2 newlines');

$_ = "f\n";
$/ = "";
$got = chomp();
is ($got, 1, 'check return value when chomp in paragraph mode on string ending with 1 newline');
is ($_, "f", 'chomp in paragraph mode on string ending with 1 newlines');

$_ = "f";
$/ = "";
$got = chomp();
is ($got, 0, 'check return value when chomp in paragraph mode on string ending with no newlines');
is ($_, "f", 'chomp in paragraph mode on string lacking trailing newlines');

$_ = "xx";
$/ = "xx";
$got = chomp();
is ($got, 2, 'check return value when chomp string that consists solely of current value of $/');
is ($_, "", 'chomp on string that consists solely of current value of $/; check that empty string remains');

$_ = "axx";
$/ = "xx";
$got = chomp();
is ($got, 2, 'check return value when chomp string that ends with current value of $/. $/ contains two characters');
is ($_, "a", 'check that when chomp string that ends with currnt value of $/, the part of original string that wasn\'t in $/ remains');

$_ = "axx";
$/ = "yy";
$got = chomp();
is ($got, 0, 'check return value when chomp string that does not end with $/');
is ($_, "axx", 'chomp a string that does not end with $/, the entire string should remain intact');

# This case once mistakenly behaved like paragraph mode.
$_ = "ab\n";
$/ = \3;
$got = chomp();
is ($got, 0, 'check return value when call chomp with $_ = "ab\\n", $/ = \3' );
is ($_, "ab\n", 'chomp with $_ = "ab\\n", $/ = \3' );

# Go Unicode.

$_ = "abc\x{1234}";
chop;
is ($_, "abc", 'Go Unicode');

$_ = "abc\x{1234}d";
chop;
is ($_, "abc\x{1234}");

$_ = "\x{1234}\x{2345}";
chop;
is ($_, "\x{1234}");

my @@stuff = qw(this that);
is (chop(@@stuff[0,1]), 't');

# bug id 20010305.012
@@stuff = qw(ab cd ef);
is (chop(@@stuff = @@stuff), 'f');

@@stuff = qw(ab cd ef);
is (chop(@@stuff[0, 2]), 'f');

my %stuff = (1..4);
is (chop(@@stuff{1, 3}), '4');

# chomp should not stringify references unless it decides to modify them
$_ = [];
$/ = "\n";
$got = chomp();
ok ($got == 0) or print "# got $got\n";
is (ref($_), "ARRAY", "chomp ref (modify)");

$/ = ")";  # the last char of something like "ARRAY(0x80ff6e4)"
$got = chomp();
ok ($got == 1) or print "# got $got\n";
ok (!ref($_), "chomp ref (no modify)");

$/ = "\n";

%chomp = ("One" => "One", "Two\n" => "Two", "" => "");
%chop = ("One" => "On", "Two\n" => "Two", "" => "");

foreach (keys %chomp) {
  my $key = $_;
  eval {chomp $_};
  if ($@@) {
    my $err = $@@;
    $err =~ s/\n$//s;
    fail ("\$\@@ = \"$err\"");
  } else {
    is ($_, $chomp{$key}, "chomp hash key");
  }
}

foreach (keys %chop) {
  my $key = $_;
  eval {chop $_};
  if ($@@) {
    my $err = $@@;
    $err =~ s/\n$//s;
    fail ("\$\@@ = \"$err\"");
  } else {
    is ($_, $chop{$key}, "chop hash key");
  }
}

# chop and chomp can't be lvalues
eval 'chop($x) = 1;';
ok($@@ =~ /Can\'t modify.*chop.*in.*assignment/);
eval 'chomp($x) = 1;';
ok($@@ =~ /Can\'t modify.*chom?p.*in.*assignment/);
eval 'chop($x, $y) = (1, 2);';
ok($@@ =~ /Can\'t modify.*chop.*in.*assignment/);
eval 'chomp($x, $y) = (1, 2);';
ok($@@ =~ /Can\'t modify.*chom?p.*in.*assignment/);

my @@chars = ("N",
             uni_to_native("\xd3"),
             substr (uni_to_native("\xd4") . "\x{100}", 0, 1),
             chr 1296);
foreach my $start (@@chars) {
  foreach my $end (@@chars) {
    local $/ = $end;
    my $message = "start=" . ord ($start) . " end=" . ord $end;
    my $string = $start . $end;
    is (chomp ($string), 1, "$message [returns 1]");
    is ($string, $start, $message);

    my $end_utf8 = $end;
    utf8::encode ($end_utf8);
    next if $end_utf8 eq $end;

    # $end ne $end_utf8, so these should not chomp.
    $string = $start . $end_utf8;
    my $chomped = $string;
    is (chomp ($chomped), 0, "$message (end as bytes) [returns 0]");
    is ($chomped, $string, "$message (end as bytes)");

    $/ = $end_utf8;
    $string = $start . $end;
    $chomped = $string;
    is (chomp ($chomped), 0, "$message (\$/ as bytes) [returns 0]");
    is ($chomped, $string, "$message (\$/ as bytes)");
  }
}

{
    # returns length in characters, but not in bytes.
    $/ = "\x{100}";
    $a = "A$/";
    $b = chomp $a;
    is ($b, 1);

    $/ = "\x{100}\x{101}";
    $a = "A$/";
    $b = chomp $a;
    is ($b, 2);
}

{
    # [perl #36569] chop fails on decoded string with trailing nul
    my $asc = "perl\0";
    my $utf = "perl".pack('U',0); # marked as utf8
    is(chop($asc), "\0", "chopping ascii NUL");
    is(chop($utf), "\0", "chopping utf8 NUL");
    is($asc, "perl", "chopped ascii NUL");
    is($utf, "perl", "chopped utf8 NUL");
}

{
    # Change 26011: Re: A surprising segfault
    # to make sure only that these obfuscated sentences will not crash.

    map chop(+()), ('')x68;
    ok(1, "extend sp in pp_chop");

    map chomp(+()), ('')x68;
    ok(1, "extend sp in pp_chomp");
}

{
    # [perl #73246] chop doesn't support utf8
    # the problem was UTF8_IS_START() didn't handle perl's extended UTF8

    no warnings 'deprecated'; # This is above IV_MAX on 32 bit machines
    my $utf = "\x{80000001}\x{80000000}";
    my $result = chop($utf);
    is($utf, "\x{80000001}", "chopping high 'unicode'- remnant");
    is($result, "\x{80000000}", "chopping high 'unicode' - result");

    SKIP: {
        no warnings 'overflow'; # avoid compile-time warnings below on 32-bit architectures
        use Config;
        $Config{ivsize} >= 8
	  or skip("this build can't handle very large characters", 2);
        my $utf = "\x{ffffffffffffffff}\x{fffffffffffffffe}";
        my $result = chop $utf;
        is($utf, "\x{ffffffffffffffff}", "chop even higher 'unicode' - remnant");
        is($result, "\x{fffffffffffffffe}", "chop even higher 'unicode' - result");
    }
}

$/ = "\n";
{
    my $expected = 99999;
    my $input = "UserID\talpha $expected\n";
    my $uid = '';
    chomp(my @@line = split (/ |\t/,$input));
    $uid = $line[-1];
    is($uid, $expected,
        "RT #123057: chomp works as expected on split");
}

{
    my $a = local $/ = 7;
    $a = chomp $a;
    is $a, 1, 'lexical $a = chomp $a when $a eq $/ eq 7';
    $a = $/ = 0;
    $a = chomp $a;
    is $a, 1, 'lexical $a = chomp $a when $a eq $/ eq 0';
    my @@a = "7";
    for my $b($a[0]) {
        $/ = 7;
        $b = chomp @@a;
        is $b, 1,
          'lexical $b = chomp @@a when $b eq $/ eq 7 and \$a[0] == \$b';
        $b = $/ = 0;
        $b = chomp @@a;
        is $b, 1,
          'lexical $b = chomp @@a when $b eq $/ eq 0 and \$a[0] == \$b';
    }
}
@


1.13
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d6 1
a6 1
    require './test.pl';
d9 2
a10 1
plan tests => 143;
d187 4
a190 1
my @@chars = ("N", latin1_to_native("\xd3"), substr ("\xd4\x{100}", 0, 1), chr 1296);
d254 2
d270 31
@


1.12
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d26 1
a26 1
is (join('',@@bar), 'hi there!');
d30 1
a30 1
is (join('',$foo,@@foo), 'hi there!');
d34 2
a35 2
ok ($got == 1) or print "# got $got\n";
is ($_, "foo\n");
d39 2
a40 2
ok ($got == 1) or print "# got $got\n";
is ($_, "foo");
d44 2
a45 2
ok ($got == 0) or print "# got $got\n";
is ($_, "foo");
d50 2
a51 2
ok ($got == 2) or print "# got $got\n";
is ($_, "f");
d56 2
a57 2
ok ($got == 0) or print "# got $got\n";
is ($_, "bar");
d62 2
a63 2
ok ($got == 5) or print "# got $got\n";
is ($_, "f");
d68 2
a69 2
ok ($got == 2) or print "# got $got\n";
is ($_, "f");
d74 2
a75 2
ok ($got == 1) or print "# got $got\n";
is ($_, "f");
d80 2
a81 2
ok ($got == 0) or print "# got $got\n";
is ($_, "f");
d86 2
a87 2
ok ($got == 2) or print "# got $got\n";
is ($_, "");
d92 2
a93 2
ok ($got == 2) or print "# got $got\n";
is ($_, "a");
d98 2
a99 2
ok ($got == 0) or print "# got $got\n";
is ($_, "axx");
d105 2
a106 2
ok ($got == 0) or print "# got $got\n";
is ($_, "ab\n");
d112 1
a112 1
is ($_, "abc", "Go Unicode");
@


1.11
log
@merge in perl 5.12.2 plus local changes
@
text
@d9 1
a9 1
plan tests => 139;
d186 1
a186 1
my @@chars = ("N", ord('A') == 193 ? "\xee" : "\xd3", substr ("\xd4\x{100}", 0, 1), chr 1296);
d245 20
@


1.10
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d12 1
a12 1
$c = do foo();
@


1.9
log
@merge in perl 5.8.8
@
text
@d186 1
a186 1
my @@chars = ("N", "\xd3", substr ("\xd4\x{100}", 0, 1), chr 1296);
@


1.8
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d9 1
a9 1
plan tests => 133;
d224 21
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d9 1
a9 1
plan tests => 51;
d186 39
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d9 1
a9 1
plan tests => 47;
d175 11
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d3 5
a7 1
print "1..37\n";
d9 1
a9 1
# optimized
d13 1
a13 3
if ($c . $_ eq 'cab') {print "ok 1\n";} else {print "not ok 1 $c$_\n";}

# unoptimized
d17 1
a17 1
if ($c . $_ eq 'cab') {print "ok 2\n";} else {print "not ok 2\n";}
d26 1
a26 1
print join('',@@bar) eq 'hi there!' ? "ok 3\n" : "not ok 3\n";
d30 1
a30 1
print join('',$foo,@@foo) eq 'hi there!' ? "ok 4\n" : "not ok 4\n";
d33 3
a35 2
print chomp() == 1 ? "ok 5\n" : "not ok 5\n";
print $_ eq "foo\n" ? "ok 6\n" : "not ok 6\n";
d38 3
a40 2
print chomp() == 1 ? "ok 7\n" : "not ok 7\n";
print $_ eq "foo" ? "ok 8\n" : "not ok 8\n";
d43 3
a45 2
print chomp() == 0 ? "ok 9\n" : "not ok 9\n";
print $_ eq "foo" ? "ok 10\n" : "not ok 10\n";
d49 3
a51 2
print chomp() == 2 ? "ok 11\n" : "not ok 11\n";
print $_ eq "f" ? "ok 12\n" : "not ok 12\n";
d55 3
a57 2
print chomp() == 0 ? "ok 13\n" : "not ok 13\n";
print $_ eq "bar" ? "ok 14\n" : "not ok 14\n";
d61 3
a63 2
print chomp() == 5 ? "ok 15\n" : "not ok 15\n";
print $_ eq "f" ? "ok 16\n" : "not ok 16\n";
d67 3
a69 2
print chomp() == 2 ? "ok 17\n" : "not ok 17\n";
print $_ eq "f" ? "ok 18\n" : "not ok 18\n";
d73 3
a75 2
print chomp() == 1 ? "ok 19\n" : "not ok 19\n";
print $_ eq "f" ? "ok 20\n" : "not ok 20\n";
d79 3
a81 2
print chomp() == 0 ? "ok 21\n" : "not ok 21\n";
print $_ eq "f" ? "ok 22\n" : "not ok 22\n";
d85 3
a87 2
print chomp() == 2 ? "ok 23\n" : "not ok 23\n";
print $_ eq "" ? "ok 24\n" : "not ok 24\n";
d91 3
a93 2
print chomp() == 2 ? "ok 25\n" : "not ok 25\n";
print $_ eq "a" ? "ok 26\n" : "not ok 26\n";
d97 3
a99 2
print chomp() == 0 ? "ok 27\n" : "not ok 27\n";
print $_ eq "axx" ? "ok 28\n" : "not ok 28\n";
d104 3
a106 2
print chomp() == 0 ? "ok 29\n" : "not ok 29\n";
print $_ eq "ab\n" ? "ok 30\n" : "not ok 30\n";
d112 1
a112 1
print $_ eq "abc" ? "ok 31\n" : "not ok 31\n";
d116 1
a116 1
print $_ eq "abc\x{1234}" ? "ok 32\n" : "not ok 32\n";
d120 1
a120 1
print $_ eq "\x{1234}" ? "ok 33\n" : "not ok 33\n";
d123 1
a123 1
print chop(@@stuff[0,1]) eq 't' ? "ok 34\n" : "not ok 34\n";
d127 1
a127 1
print chop(@@stuff = @@stuff) eq 'f' ? "ok 35\n" : "not ok 35\n";
d130 1
a130 1
print chop(@@stuff[0, 2]) eq 'f' ? "ok 36\n" : "not ok 36\n";
d133 42
a174 1
print chop(@@stuff{1, 3}) eq '4' ? "ok 37\n" : "not ok 37\n";
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d3 1
a3 1
print "1..30\n";
d92 27
@


1.3
log
@perl5.005_03 (stock)
@
text
@d3 1
a3 3
# $RCSfile: chop.t,v $$Revision: 4.1 $$Date: 92/08/07 18:27:40 $

print "1..28\n";
d86 6
@


1.2
log
@perl 5.004_04
@
text
@@


1.1
log
@Initial revision
@
text
@d5 1
a5 1
print "1..22\n";
d73 15
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d5 1
a5 1
print "1..28\n";
a72 15

$_ = "xx";
$/ = "xx";
print chomp() == 2 ? "ok 23\n" : "not ok 23\n";
print $_ eq "" ? "ok 24\n" : "not ok 24\n";

$_ = "axx";
$/ = "xx";
print chomp() == 2 ? "ok 25\n" : "not ok 25\n";
print $_ eq "a" ? "ok 26\n" : "not ok 26\n";

$_ = "axx";
$/ = "yy";
print chomp() == 0 ? "ok 27\n" : "not ok 27\n";
print $_ eq "axx" ? "ok 28\n" : "not ok 28\n";
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d3 3
a5 1
print "1..30\n";
a87 6

# This case once mistakenly behaved like paragraph mode.
$_ = "ab\n";
$/ = \3;
print chomp() == 0 ? "ok 29\n" : "not ok 29\n";
print $_ eq "ab\n" ? "ok 30\n" : "not ok 30\n";
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d3 1
a3 1
print "1..37\n";
a91 27

# Go Unicode.

$_ = "abc\x{1234}";
chop;
print $_ eq "abc" ? "ok 31\n" : "not ok 31\n";

$_ = "abc\x{1234}d";
chop;
print $_ eq "abc\x{1234}" ? "ok 32\n" : "not ok 32\n";

$_ = "\x{1234}\x{2345}";
chop;
print $_ eq "\x{1234}" ? "ok 33\n" : "not ok 33\n";

my @@stuff = qw(this that);
print chop(@@stuff[0,1]) eq 't' ? "ok 34\n" : "not ok 34\n";

# bug id 20010305.012
@@stuff = qw(ab cd ef);
print chop(@@stuff = @@stuff) eq 'f' ? "ok 35\n" : "not ok 35\n";

@@stuff = qw(ab cd ef);
print chop(@@stuff[0, 2]) eq 'f' ? "ok 36\n" : "not ok 36\n";

my %stuff = (1..4);
print chop(@@stuff{1, 3}) eq '4' ? "ok 37\n" : "not ok 37\n";
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d3 1
a3 5
BEGIN {
    chdir 't' if -d 't';
    @@INC = '../lib';
    require './test.pl';
}
d5 1
a5 1
plan tests => 47;
d9 3
a11 1
is ($c . $_, 'cab', 'optimized');
d15 1
a15 1
is ($c . $_ , 'cab', 'unoptimized');
d24 1
a24 1
is (join('',@@bar), 'hi there!');
d28 1
a28 1
is (join('',$foo,@@foo), 'hi there!');
d31 2
a32 3
$got = chomp();
ok ($got == 1) or print "# got $got\n";
is ($_, "foo\n");
d35 2
a36 3
$got = chomp();
ok ($got == 1) or print "# got $got\n";
is ($_, "foo");
d39 2
a40 3
$got = chomp();
ok ($got == 0) or print "# got $got\n";
is ($_, "foo");
d44 2
a45 3
$got = chomp();
ok ($got == 2) or print "# got $got\n";
is ($_, "f");
d49 2
a50 3
$got = chomp();
ok ($got == 0) or print "# got $got\n";
is ($_, "bar");
d54 2
a55 3
$got = chomp();
ok ($got == 5) or print "# got $got\n";
is ($_, "f");
d59 2
a60 3
$got = chomp();
ok ($got == 2) or print "# got $got\n";
is ($_, "f");
d64 2
a65 3
$got = chomp();
ok ($got == 1) or print "# got $got\n";
is ($_, "f");
d69 2
a70 3
$got = chomp();
ok ($got == 0) or print "# got $got\n";
is ($_, "f");
d74 2
a75 3
$got = chomp();
ok ($got == 2) or print "# got $got\n";
is ($_, "");
d79 2
a80 3
$got = chomp();
ok ($got == 2) or print "# got $got\n";
is ($_, "a");
d84 2
a85 3
$got = chomp();
ok ($got == 0) or print "# got $got\n";
is ($_, "axx");
d90 2
a91 3
$got = chomp();
ok ($got == 0) or print "# got $got\n";
is ($_, "ab\n");
d97 1
a97 1
is ($_, "abc", "Go Unicode");
d101 1
a101 1
is ($_, "abc\x{1234}");
d105 1
a105 1
is ($_, "\x{1234}");
d108 1
a108 1
is (chop(@@stuff[0,1]), 't');
d112 1
a112 1
is (chop(@@stuff = @@stuff), 'f');
d115 1
a115 1
is (chop(@@stuff[0, 2]), 'f');
d118 1
a118 42
is (chop(@@stuff{1, 3}), '4');

# chomp should not stringify references unless it decides to modify them
$_ = [];
$/ = "\n";
$got = chomp();
ok ($got == 0) or print "# got $got\n";
is (ref($_), "ARRAY", "chomp ref (modify)");

$/ = ")";  # the last char of something like "ARRAY(0x80ff6e4)"
$got = chomp();
ok ($got == 1) or print "# got $got\n";
ok (!ref($_), "chomp ref (no modify)");

$/ = "\n";

%chomp = ("One" => "One", "Two\n" => "Two", "" => "");
%chop = ("One" => "On", "Two\n" => "Two", "" => "");

foreach (keys %chomp) {
  my $key = $_;
  eval {chomp $_};
  if ($@@) {
    my $err = $@@;
    $err =~ s/\n$//s;
    fail ("\$\@@ = \"$err\"");
  } else {
    is ($_, $chomp{$key}, "chomp hash key");
  }
}

foreach (keys %chop) {
  my $key = $_;
  eval {chop $_};
  if ($@@) {
    my $err = $@@;
    $err =~ s/\n$//s;
    fail ("\$\@@ = \"$err\"");
  } else {
    is ($_, $chop{$key}, "chop hash key");
  }
}
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@d9 1
a9 1
plan tests => 51;
a174 11

# chop and chomp can't be lvalues
eval 'chop($x) = 1;';
ok($@@ =~ /Can\'t modify.*chop.*in.*assignment/);
eval 'chomp($x) = 1;';
ok($@@ =~ /Can\'t modify.*chom?p.*in.*assignment/);
eval 'chop($x, $y) = (1, 2);';
ok($@@ =~ /Can\'t modify.*chop.*in.*assignment/);
eval 'chomp($x, $y) = (1, 2);';
ok($@@ =~ /Can\'t modify.*chom?p.*in.*assignment/);

@


1.1.1.7
log
@Import of stock perl 5.8.5
@
text
@d9 1
a9 1
plan tests => 133;
a185 39
my @@chars = ("N", "\xd3", substr ("\xd4\x{100}", 0, 1), chr 1296);
foreach my $start (@@chars) {
  foreach my $end (@@chars) {
    local $/ = $end;
    my $message = "start=" . ord ($start) . " end=" . ord $end;
    my $string = $start . $end;
    is (chomp ($string), 1, "$message [returns 1]");
    is ($string, $start, $message);

    my $end_utf8 = $end;
    utf8::encode ($end_utf8);
    next if $end_utf8 eq $end;

    # $end ne $end_utf8, so these should not chomp.
    $string = $start . $end_utf8;
    my $chomped = $string;
    is (chomp ($chomped), 0, "$message (end as bytes) [returns 0]");
    is ($chomped, $string, "$message (end as bytes)");

    $/ = $end_utf8;
    $string = $start . $end;
    $chomped = $string;
    is (chomp ($chomped), 0, "$message (\$/ as bytes) [returns 0]");
    is ($chomped, $string, "$message (\$/ as bytes)");
  }
}

{
    # returns length in characters, but not in bytes.
    $/ = "\x{100}";
    $a = "A$/";
    $b = chomp $a;
    is ($b, 1);

    $/ = "\x{100}\x{101}";
    $a = "A$/";
    $b = chomp $a;
    is ($b, 2);
}
@


1.1.1.8
log
@perl 5.8.8 import
@
text
@d9 1
a9 1
plan tests => 139;
a223 21
}

{
    # [perl #36569] chop fails on decoded string with trailing nul
    my $asc = "perl\0";
    my $utf = "perl".pack('U',0); # marked as utf8
    is(chop($asc), "\0", "chopping ascii NUL");
    is(chop($utf), "\0", "chopping utf8 NUL");
    is($asc, "perl", "chopped ascii NUL");
    is($utf, "perl", "chopped utf8 NUL");
}

{
    # Change 26011: Re: A surprising segfault
    # to make sure only that these obfuscated sentences will not crash.

    map chop(+()), ('')x68;
    ok(1, "extend sp in pp_chop");

    map chomp(+()), ('')x68;
    ok(1, "extend sp in pp_chomp");
@


1.1.1.9
log
@import perl 5.10.0 from CPAN
@
text
@d186 1
a186 1
my @@chars = ("N", ord('A') == 193 ? "\xee" : "\xd3", substr ("\xd4\x{100}", 0, 1), chr 1296);
@


1.1.1.10
log
@Perl 5.12.2 from CPAN
@
text
@d12 1
a12 1
$c = foo();
@


1.1.1.11
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d9 1
a9 1
plan tests => 143;
d186 1
a186 1
my @@chars = ("N", latin1_to_native("\xd3"), substr ("\xd4\x{100}", 0, 1), chr 1296);
a244 20
}

{
    # [perl #73246] chop doesn't support utf8
    # the problem was UTF8_IS_START() didn't handle perl's extended UTF8
    my $utf = "\x{80000001}\x{80000000}";
    my $result = chop($utf);
    is($utf, "\x{80000001}", "chopping high 'unicode'- remnant");
    is($result, "\x{80000000}", "chopping high 'unicode' - result");

    SKIP: {
        no warnings 'overflow'; # avoid compile-time warnings below on 32-bit architectures
        use Config;
        $Config{ivsize} >= 8
	  or skip("this build can't handle very large characters", 2);
        my $utf = "\x{ffffffffffffffff}\x{fffffffffffffffe}";
        my $result = chop $utf;
        is($utf, "\x{ffffffffffffffff}", "chop even higher 'unicode' - remnant");
        is($result, "\x{fffffffffffffffe}", "chop even higher 'unicode' - result");
    }
@


1.1.1.12
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d26 1
a26 1
is (join('',@@bar), 'hi there!', 'chop list of strings');
d30 1
a30 1
is (join('',$foo,@@foo), 'hi there!', 'chop on list reduces one-character element to an empty string');
d34 2
a35 2
is($got, 1, 'check return value when chomp string ending with two newlines; $/ is set to default of one newline');
is ($_, "foo\n", 'chomp string ending with two newlines while $/ is set to one newline' );
d39 2
a40 2
is($got, 1, 'check return value chomp string ending with one newline while $/ is set to a newline');
is ($_, "foo", 'test typical use of chomp; chomp a string ending in a single newline while $/ is set to default of one newline');
d44 2
a45 2
is($got, 0, 'check return value when chomp a string that does not end with current value of $/, 0 should be returned');
is ($_, "foo", 'chomp a string that does not end with the current value of $/');
d50 2
a51 2
is ($got, "2", 'check return value when chomp string with $/ consisting of more than one character, and with the ending of the string matching $/');
is ($_, "f", 'chomp a string when $/ consists of two characters that are at the end of the string, check that chomped string contains remnant of original string');
d56 2
a57 2
is($got, "0", 'check return value when call chomp with $/ consisting of more than one character, and with the ending of the string NOT matching $/');
is ($_, "bar", 'chomp a string when $/ consists of two characters that are NOT at the end of the string');
d62 2
a63 2
is ($got, 5, 'check return value when chomp in paragraph mode on string ending with 5 newlines');
is ($_, "f", 'chomp in paragraph mode on string ending with 5 newlines');
d68 2
a69 2
is ($got, 2, 'check return value when chomp in paragraph mode on string ending with 2 newlines');
is ($_, "f", 'chomp in paragraph mode on string ending with 2 newlines');
d74 2
a75 2
is ($got, 1, 'check return value when chomp in paragraph mode on string ending with 1 newline');
is ($_, "f", 'chomp in paragraph mode on string ending with 1 newlines');
d80 2
a81 2
is ($got, 0, 'check return value when chomp in paragraph mode on string ending with no newlines');
is ($_, "f", 'chomp in paragraph mode on string lacking trailing newlines');
d86 2
a87 2
is ($got, 2, 'check return value when chomp string that consists solely of current value of $/');
is ($_, "", 'chomp on string that consists solely of current value of $/; check that empty string remains');
d92 2
a93 2
is ($got, 2, 'check return value when chomp string that ends with current value of $/. $/ contains two characters');
is ($_, "a", 'check that when chomp string that ends with currnt value of $/, the part of original string that wasn\'t in $/ remains');
d98 2
a99 2
is ($got, 0, 'check return value when chomp string that does not end with $/');
is ($_, "axx", 'chomp a string that does not end with $/, the entire string should remain intact');
d105 2
a106 2
is ($got, 0, 'check return value when call chomp with $_ = "ab\\n", $/ = \3' );
is ($_, "ab\n", 'chomp with $_ = "ab\\n", $/ = \3' );
d112 1
a112 1
is ($_, "abc", 'Go Unicode');
@


