head	1.9;
access;
symbols
	OPENBSD_6_0:1.9.0.16
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.10
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.9.0.12
	OPENBSD_5_8_BASE:1.9
	PERL_5_20_2:1.1.1.9
	OPENBSD_5_7:1.9.0.4
	OPENBSD_5_7_BASE:1.9
	PERL_5_20_1:1.1.1.9
	OPENBSD_5_6:1.9.0.8
	OPENBSD_5_6_BASE:1.9
	PERL_5_18_2:1.1.1.9
	PERL:1.1.1
	OPENBSD_5_5:1.9.0.6
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.2
	OPENBSD_5_4_BASE:1.9
	PERL_5_16_3:1.1.1.9
	OPENBSD_5_3:1.8.0.18
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.16
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.14
	OPENBSD_5_0:1.8.0.12
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.10
	OPENBSD_4_9_BASE:1.8
	PERL_5_12_2:1.1.1.8
	OPENBSD_4_8:1.8.0.8
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.4
	OPENBSD_4_7_BASE:1.8
	PERL_5_10_1:1.1.1.8
	OPENBSD_4_6:1.8.0.6
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.2
	OPENBSD_4_5_BASE:1.8
	PERL_5_10_0:1.1.1.8
	OPENBSD_4_4:1.7.0.10
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.8
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.6
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.4
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.2
	OPENBSD_4_0_BASE:1.7
	PERL_5_8_8:1.1.1.7
	OPENBSD_3_9:1.6.0.10
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.8
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.6
	OPENBSD_3_7_BASE:1.6
	PERL_5_8_6:1.1.1.6
	OPENBSD_3_6:1.6.0.4
	OPENBSD_3_6_BASE:1.6
	PERL_5_8_5:1.1.1.5
	PERL_5_8_3:1.1.1.4
	OPENBSD_3_5:1.6.0.2
	OPENBSD_3_5_BASE:1.6
	PERL_5_8_2:1.1.1.4
	OPENBSD_3_4:1.5.0.4
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.4.0.6
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.4
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.3.0.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	PERL_500503:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.9
date	2013.03.25.20.40.59;	author sthen;	state Exp;
branches;
next	1.8;

1.8
date	2008.09.29.17.36.19;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2006.03.28.19.23.12;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2003.12.03.03.02.48;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.10.27.22.25.37;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.24.18.36.18;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.06.17.08.23;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	99.04.29.22.52.35;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	99.04.29.22.41.45;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.29.22.41.45;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.04.06.16.10.48;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.05.24.18.25.37;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.27.22.15.10;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.08.09.17.48.35;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2005.01.15.21.18.18;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2006.03.28.18.49.45;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2008.09.29.17.19.00;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2013.03.25.20.09.35;	author sthen;	state Exp;
branches;
next	;


desc
@@


1.9
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@#!./perl
# tests for "goto &sub"-ing into XSUBs

# Note: This only tests things that should *work*.  At some point, it may
#       be worth while to write some failure tests for things that should
#       *break* (such as calls with wrong number of args).  For now, I'm
#       guessing that if all of these work correctly, the bad ones will
#       break correctly as well.

BEGIN {
    chdir 't' if -d 't';
    require './test.pl';
# turn warnings into fatal errors
    $SIG{__WARN__} = sub { die "WARNING: @@_" } ;

    skip_all_if_miniperl("no dynamic loading on miniperl, no Fcntl");
    require Fcntl;
}
use strict;
use warnings;
use vars '$VALID';

plan(tests => 11);

# We don't know what symbols are defined in platform X's system headers.
# We don't even want to guess, because some platform out there will
# likely do the unthinkable.  However, Fcntl::S_IMODE(0)
# should always return a value.
# If this ceases to be the case, we're in trouble. =)
$VALID = 0;

### First, we check whether Fcntl::S_IMODE returns sane answers.
# Fcntl::S_IMODE(0) should always succeed.

my $value = Fcntl::S_IMODE($VALID);
isnt($value, undef, 'Sanity check broke, remaining tests will fail');

### OK, we're ready to do real tests.

sub goto_const { goto &Fcntl::S_IMODE; }

my $ret = goto_const($VALID);
is($ret, $value, 'goto &function_constant');

my $FNAME1 = 'Fcntl::S_IMODE';
sub goto_name1 { goto &$FNAME1; }

$ret = goto_name1($VALID);
is($ret, $value, 'goto &$function_package_and_name');

$ret = goto_name1($VALID);
is($ret, $value, 'goto &$function_package_and_name; again, with dirtier stack');
$ret = goto_name1($VALID);
is($ret, $value, 'goto &$function_package_and_name; again, with dirtier stack');

# test 
package Fcntl;
my $FNAME2 = 'S_IMODE';
sub goto_name2 { goto &$FNAME2; }
package main;

$ret = Fcntl::goto_name2($VALID);
is($ret, $value, 'goto &$function_name; from local package');

my $FREF = \&Fcntl::S_IMODE;
sub goto_ref { goto &$FREF; }

$ret = goto_ref($VALID);
is($ret, $value, 'goto &$function_ref');

### tests where the args are not on stack but in GvAV(defgv) (ie, @@_)

sub call_goto_const { &goto_const; }

$ret = call_goto_const($VALID);
is($ret, $value, 'goto &function_constant; from a sub called without arglist');

# test "goto &$function_package_and_name" from a sub called without arglist
sub call_goto_name1 { &goto_name1; }

$ret = call_goto_name1($VALID);
is($ret, $value,
   'goto &$function_package_and_name; from a sub called without arglist');

sub call_goto_ref { &goto_ref; }

$ret = call_goto_ref($VALID);
is($ret, $value, 'goto &$function_ref; from a sub called without arglist');


BEGIN {
    use Config;
    if ($Config{extensions} =~ m{XS/APItest}) {
	eval q[use XS::APItest qw(mycroak); 1]
	    or die "use XS::APItest: $@@\n";
    }
    else {
	*mycroak = sub { die @@_ };
    }
}

sub goto_croak { goto &mycroak }

{
    my $e;
    for (1..4) {
	eval { goto_croak("boo$_\n") };
	$e .= $@@;
    }
    is($e, "boo1\nboo2\nboo3\nboo4\n",
       '[perl #35878] croak in XS after goto segfaulted')
}

@


1.8
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@a9 1
BEGIN { $| = 1; }
d12 1
a12 3
    @@INC = '../lib';
    $ENV{PERL5LIB} = "../lib";

d16 2
a17 4
    foreach (qw(Fcntl XS::APItest)) {
	eval "require $_"
	or do { print "1..0\n# $_ unavailable, can't test XS goto.\n"; exit 0 }
    }
d19 5
a23 1
print "1..11\n";
d27 2
a28 5
# likely do the unthinkable.  However, Fcntl::constant("LOCK_SH",0)
# should always return a value, even on platforms which don't define the
# cpp symbol; Fcntl.xs says:
#           /* We support flock() on systems which don't have it, so
#              always supply the constants. */
d30 1
a30 1
$VALID = 'LOCK_SH';
d32 2
a33 2
### First, we check whether Fcntl::constant returns sane answers.
# Fcntl::constant("LOCK_SH",0) should always succeed.
d35 2
a36 4
$value = Fcntl::constant($VALID);
print((!defined $value)
      ? "not ok 1\n# Sanity check broke, remaining tests will fail.\n"
      : "ok 1\n");
d40 1
a40 2
# test "goto &function_constant"
sub goto_const { goto &Fcntl::constant; }
d42 2
a43 2
$ret = goto_const($VALID);
print(($ret == $value) ? "ok 2\n" : "not ok 2\n# ($ret != $value)\n");
d45 1
a45 2
# test "goto &$function_package_and_name"
$FNAME1 = 'Fcntl::constant';
d49 1
a49 1
print(($ret == $value) ? "ok 3\n" : "not ok 3\n# ($ret != $value)\n");
a50 1
# test "goto &$function_package_and_name" again, with dirtier stack
d52 1
a52 1
print(($ret == $value) ? "ok 4\n" : "not ok 4\n# ($ret != $value)\n");
d54 1
a54 1
print(($ret == $value) ? "ok 5\n" : "not ok 5\n# ($ret != $value)\n");
d56 1
a56 1
# test "goto &$function_name" from local package
d58 1
a58 1
$FNAME2 = 'constant';
d63 1
a63 1
print(($ret == $value) ? "ok 6\n" : "not ok 6\n# ($ret != $value)\n");
d65 1
a65 2
# test "goto &$function_ref"
$FREF = \&Fcntl::constant;
d69 1
a69 1
print(($ret == $value) ? "ok 7\n" : "not ok 7\n# ($ret != $value)\n");
a72 1
# test "goto &function_constant" from a sub called without arglist
d76 1
a76 1
print(($ret == $value) ? "ok 8\n" : "not ok 8\n# ($ret != $value)\n");
d82 2
a83 1
print(($ret == $value) ? "ok 9\n" : "not ok 9\n# ($ret != $value)\n");
a84 1
# test "goto &$function_ref" from a sub called without arglist
d88 1
a88 1
print(($ret == $value) ? "ok 10\n" : "not ok 10\n# ($ret != $value)\n");
d91 10
a100 3
# [perl #35878] croak in XS after goto segfaulted

use XS::APItest qw(mycroak);
d110 2
a111 1
    print $e eq "boo1\nboo2\nboo3\nboo4\n" ? "ok 11\n" : "not ok 11\n";
@


1.7
log
@merge in perl 5.8.8
@
text
@a3 2
# $RCSfile: goto_xs.t,v $$Revision: 1.6 $$Date: 2003/12/03 03:02:48 $

d24 1
a24 1
print "1..10\n";
d100 17
@


1.6
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d4 1
a4 1
# $RCSfile$$Revision$$Date$
d12 5
a16 3
chdir 't' if -d 't';
@@INC = '../lib';
$ENV{PERL5LIB} = "../lib";
d19 1
a19 5
$SIG{__WARN__} = sub { die "WARNING: @@_" } ;

BEGIN { $| = 1; }
eval 'require Fcntl'
  or do { print "1..0\n# Fcntl unavailable, can't test XS goto.\n"; exit 0 };
d21 5
@


1.5
log
@Resolve conflicts, remove old files, merge local changes
@
text
@@


1.4
log
@merge in perl 5.6.1 with our local changes
@
text
@d38 1
a38 1
$value = Fcntl::constant($VALID,0);
d48 1
a48 1
$ret = goto_const($VALID,0);
d55 1
a55 1
$ret = goto_name1($VALID,0);
d59 1
a59 1
$ret = goto_name1($VALID,0);
d61 1
a61 1
$ret = goto_name1($VALID,0);
d70 1
a70 1
$ret = Fcntl::goto_name2($VALID,0);
d77 1
a77 1
$ret = goto_ref($VALID,0);
d85 1
a85 1
$ret = call_goto_const($VALID,0);
d91 1
a91 1
$ret = call_goto_name1($VALID,0);
d97 1
a97 1
$ret = call_goto_ref($VALID,0);
@


1.3
log
@perl-5.6.0 + local changes
@
text
@d13 1
a13 1
unshift @@INC, "../lib";
@


1.2
log
@perl5.005_03 (stock)
@
text
@d13 1
a13 1
@@INC = "../lib";
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@perl5.005_03
@
text
@@


1.1.1.2
log
@virgin perl 5.6.0
@
text
@d13 1
a13 1
unshift @@INC, "../lib";
@


1.1.1.3
log
@stock perl 5.6.1
@
text
@d13 1
a13 1
@@INC = '../lib';
@


1.1.1.4
log
@stock perl 5.8.0 from CPAN
@
text
@d38 1
a38 1
$value = Fcntl::constant($VALID);
d48 1
a48 1
$ret = goto_const($VALID);
d55 1
a55 1
$ret = goto_name1($VALID);
d59 1
a59 1
$ret = goto_name1($VALID);
d61 1
a61 1
$ret = goto_name1($VALID);
d70 1
a70 1
$ret = Fcntl::goto_name2($VALID);
d77 1
a77 1
$ret = goto_ref($VALID);
d85 1
a85 1
$ret = call_goto_const($VALID);
d91 1
a91 1
$ret = call_goto_name1($VALID);
d97 1
a97 1
$ret = call_goto_ref($VALID);
@


1.1.1.5
log
@Import of stock perl 5.8.5
@
text
@d4 1
a4 1
# $RCSfile: goto_xs.t,v $$Revision: 1.6 $$Date: 2003/12/03 03:02:48 $
@


1.1.1.6
log
@perl 5.8.6 from CPAN
@
text
@d4 1
a4 1
# $RCSfile$$Revision$$Date$
@


1.1.1.7
log
@perl 5.8.8 import
@
text
@d12 3
a14 5
BEGIN { $| = 1; }
BEGIN {
    chdir 't' if -d 't';
    @@INC = '../lib';
    $ENV{PERL5LIB} = "../lib";
d17 5
a21 1
    $SIG{__WARN__} = sub { die "WARNING: @@_" } ;
a22 5
    foreach (qw(Fcntl XS::APItest)) {
	eval "require $_"
	or do { print "1..0\n# $_ unavailable, can't test XS goto.\n"; exit 0 }
    }
}
@


1.1.1.8
log
@import perl 5.10.0 from CPAN
@
text
@d4 2
d26 1
a26 1
print "1..11\n";
a101 17


# [perl #35878] croak in XS after goto segfaulted

use XS::APItest qw(mycroak);

sub goto_croak { goto &mycroak }

{
    my $e;
    for (1..4) {
	eval { goto_croak("boo$_\n") };
	$e .= $@@;
    }
    print $e eq "boo1\nboo2\nboo3\nboo4\n" ? "ok 11\n" : "not ok 11\n";
}

@


1.1.1.9
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d10 1
d13 3
a15 1
    require './test.pl';
d19 4
a22 2
    skip_all_if_miniperl("no dynamic loading on miniperl, no Fcntl");
    require Fcntl;
d24 1
a24 5
use strict;
use warnings;
use vars '$VALID';

plan(tests => 11);
d28 5
a32 2
# likely do the unthinkable.  However, Fcntl::S_IMODE(0)
# should always return a value.
d34 1
a34 1
$VALID = 0;
d36 2
a37 2
### First, we check whether Fcntl::S_IMODE returns sane answers.
# Fcntl::S_IMODE(0) should always succeed.
d39 4
a42 2
my $value = Fcntl::S_IMODE($VALID);
isnt($value, undef, 'Sanity check broke, remaining tests will fail');
d46 2
a47 1
sub goto_const { goto &Fcntl::S_IMODE; }
d49 2
a50 2
my $ret = goto_const($VALID);
is($ret, $value, 'goto &function_constant');
d52 2
a53 1
my $FNAME1 = 'Fcntl::S_IMODE';
d57 1
a57 1
is($ret, $value, 'goto &$function_package_and_name');
d59 1
d61 1
a61 1
is($ret, $value, 'goto &$function_package_and_name; again, with dirtier stack');
d63 1
a63 1
is($ret, $value, 'goto &$function_package_and_name; again, with dirtier stack');
d65 1
a65 1
# test 
d67 1
a67 1
my $FNAME2 = 'S_IMODE';
d72 1
a72 1
is($ret, $value, 'goto &$function_name; from local package');
d74 2
a75 1
my $FREF = \&Fcntl::S_IMODE;
d79 1
a79 1
is($ret, $value, 'goto &$function_ref');
d83 1
d87 1
a87 1
is($ret, $value, 'goto &function_constant; from a sub called without arglist');
d93 1
a93 2
is($ret, $value,
   'goto &$function_package_and_name; from a sub called without arglist');
d95 1
d99 2
a100 1
is($ret, $value, 'goto &$function_ref; from a sub called without arglist');
d102 1
d104 1
a104 10
BEGIN {
    use Config;
    if ($Config{extensions} =~ m{XS/APItest}) {
	eval q[use XS::APItest qw(mycroak); 1]
	    or die "use XS::APItest: $@@\n";
    }
    else {
	*mycroak = sub { die @@_ };
    }
}
d114 1
a114 2
    is($e, "boo1\nboo2\nboo3\nboo4\n",
       '[perl #35878] croak in XS after goto segfaulted')
@


