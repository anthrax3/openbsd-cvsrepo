head	1.14;
access;
symbols
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.13.0.10
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.4
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.13.0.6
	OPENBSD_5_8_BASE:1.13
	PERL_5_20_2:1.1.1.12
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	PERL_5_20_1:1.1.1.12
	OPENBSD_5_6:1.12.0.8
	OPENBSD_5_6_BASE:1.12
	PERL_5_18_2:1.1.1.11
	PERL:1.1.1
	OPENBSD_5_5:1.12.0.6
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.2
	OPENBSD_5_4_BASE:1.12
	PERL_5_16_3:1.1.1.11
	OPENBSD_5_3:1.11.0.10
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.8
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.6
	OPENBSD_5_0:1.11.0.4
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.2
	OPENBSD_4_9_BASE:1.11
	PERL_5_12_2:1.1.1.10
	OPENBSD_4_8:1.10.0.4
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.2
	OPENBSD_4_7_BASE:1.10
	PERL_5_10_1:1.1.1.9
	OPENBSD_4_6:1.9.0.6
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.2
	OPENBSD_4_5_BASE:1.9
	PERL_5_10_0:1.1.1.8
	OPENBSD_4_4:1.8.0.10
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.8
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.6
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.4
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.2
	OPENBSD_4_0_BASE:1.8
	PERL_5_8_8:1.1.1.7
	OPENBSD_3_9:1.7.0.8
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.6
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.4
	OPENBSD_3_7_BASE:1.7
	PERL_5_8_6:1.1.1.6
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7
	PERL_5_8_5:1.1.1.6
	PERL_5_8_3:1.1.1.5
	OPENBSD_3_5:1.5.0.2
	OPENBSD_3_5_BASE:1.5
	PERL_5_8_2:1.1.1.4
	OPENBSD_3_4:1.4.0.16
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.4.0.14
	OPENBSD_3_3_BASE:1.4
	PERL_5_8_0:1.1.1.3
	OPENBSD_3_2:1.4.0.12
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.10
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.8
	OPENBSD_3_0_BASE:1.4
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.14
date	2017.02.05.00.32.20;	author afresh1;	state Exp;
branches;
next	1.13;
commitid	cxJ08BvJA9Pt2PTM;

1.13
date	2014.11.17.20.57.07;	author afresh1;	state Exp;
branches;
next	1.12;
commitid	QP75iYx42Uo7mMxO;

1.12
date	2013.03.25.20.40.59;	author sthen;	state Exp;
branches;
next	1.11;

1.11
date	2010.09.24.15.07.09;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2009.10.12.18.30.27;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2008.09.29.17.36.20;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2006.03.28.19.23.13;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2004.08.09.18.10.27;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2004.04.07.21.33.10;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2003.12.03.03.02.49;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.08.29;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.52.37;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.08.05.36;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.13.21;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.13.21;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.41.49;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.10.50;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.12.03.02.44.32;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.04.07.21.13.43;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.08.09.17.48.35;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2006.03.28.18.49.46;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2008.09.29.17.19.01;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2009.10.12.18.10.45;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2010.09.24.14.49.17;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2013.03.25.20.09.36;	author sthen;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2014.11.17.20.53.18;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.14
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl

BEGIN {
    chdir 't' if -d 't';
    @@INC = ('../lib', '.');
}   
# Avoid using eq_array below as it uses .. internally.
require './test.pl';

use Config;

plan (141);

is(join(':',1..5), '1:2:3:4:5');

@@foo = (1,2,3,4,5,6,7,8,9);
@@foo[2..4] = ('c','d','e');

is(join(':',@@foo[$foo[0]..5]), '2:c:d:e:6');

@@bar[2..4] = ('c','d','e');
is(join(':',@@bar[1..5]), ':c:d:e:');

($a,@@bcd[0..2],$e) = ('a','b','c','d','e');
is(join(':',$a,@@bcd[0..2],$e), 'a:b:c:d:e');

$x = 0;
for (1..100) {
    $x += $_;
}
is($x, 5050);

$x = 0;
for ((100,2..99,1)) {
    $x += $_;
}
is($x, 5050);

$x = join('','a'..'z');
is($x, 'abcdefghijklmnopqrstuvwxyz');

@@x = 'A'..'ZZ';
is (scalar @@x, 27 * 26);

@@x = '09' .. '08';  # should produce '09', '10',... '99' (strange but true)
is(join(",", @@x), join(",", map {sprintf "%02d",$_} 9..99));

# same test with foreach (which is a separate implementation)
@@y = ();
foreach ('09'..'08') {
    push(@@y, $_);
}
is(join(",", @@y), join(",", @@x));

# check bounds
if ($Config{ivsize} == 8) {
  @@a = eval "0x7ffffffffffffffe..0x7fffffffffffffff";
  $a = "9223372036854775806 9223372036854775807";
  @@b = eval "-0x7fffffffffffffff..-0x7ffffffffffffffe";
  $b = "-9223372036854775807 -9223372036854775806";
}
else {
  @@a = eval "0x7ffffffe..0x7fffffff";
  $a = "2147483646 2147483647";
  @@b = eval "-0x7fffffff..-0x7ffffffe";
  $b = "-2147483647 -2147483646";
}

is ("@@a", $a);

is ("@@b", $b);

# check magic
{
    my $bad = 0;
    local $SIG{'__WARN__'} = sub { $bad = 1 };
    my $x = 'a-e';
    $x =~ s/(\w)-(\w)/join ':', $1 .. $2/e;
    is ($x, 'a:b:c:d:e');
}

# Should use magical autoinc only when both are strings
{
    my $scalar = (() = "0"..-1);
    is ($scalar, 0);
}
{
    my $fail = 0;
    for my $x ("0"..-1) {
	$fail++;
    }
    is ($fail, 0);
}

# [#18165] Should allow "-4".."0", broken by #4730. (AMS 20021031)
is(join(":","-4".."0")     , "-4:-3:-2:-1:0");
is(join(":","-4".."-0")    , "-4:-3:-2:-1:0");
is(join(":","-4\n".."0\n") , "-4:-3:-2:-1:0");
is(join(":","-4\n".."-0\n"), "-4:-3:-2:-1:0");

# undef should be treated as 0 for numerical range
is(join(":",undef..2), '0:1:2');
is(join(":",-2..undef), '-2:-1:0');
is(join(":",undef..'2'), '0:1:2');
is(join(":",'-2'..undef), '-2:-1:0');

# undef should be treated as "" for magical range
is(join(":", map "[$_]", "".."B"), '[]');
is(join(":", map "[$_]", undef.."B"), '[]');
is(join(":", map "[$_]", "B"..""), '');
is(join(":", map "[$_]", "B"..undef), '');

# undef..undef used to segfault
is(join(":", map "[$_]", undef..undef), '[]');

# also test undef in foreach loops
@@foo=(); push @@foo, $_ for undef..2;
is(join(":", @@foo), '0:1:2');

@@foo=(); push @@foo, $_ for -2..undef;
is(join(":", @@foo), '-2:-1:0');

@@foo=(); push @@foo, $_ for undef..'2';
is(join(":", @@foo), '0:1:2');

@@foo=(); push @@foo, $_ for '-2'..undef;
is(join(":", @@foo), '-2:-1:0');

@@foo=(); push @@foo, $_ for undef.."B";
is(join(":", map "[$_]", @@foo), '[]');

@@foo=(); push @@foo, $_ for "".."B";
is(join(":", map "[$_]", @@foo), '[]');

@@foo=(); push @@foo, $_ for "B"..undef;
is(join(":", map "[$_]", @@foo), '');

@@foo=(); push @@foo, $_ for "B".."";
is(join(":", map "[$_]", @@foo), '');

@@foo=(); push @@foo, $_ for undef..undef;
is(join(":", map "[$_]", @@foo), '[]');

# again with magic
{
    my @@a = (1..3);
    @@foo=(); push @@foo, $_ for undef..$#a;
    is(join(":", @@foo), '0:1:2');
}
{
    my @@a = ();
    @@foo=(); push @@foo, $_ for $#a..undef;
    is(join(":", @@foo), '-1:0');
}
{
    local $1;
    "2" =~ /(.+)/;
    @@foo=(); push @@foo, $_ for undef..$1;
    is(join(":", @@foo), '0:1:2');
}
{
    local $1;
    "-2" =~ /(.+)/;
    @@foo=(); push @@foo, $_ for $1..undef;
    is(join(":", @@foo), '-2:-1:0');
}
{
    local $1;
    "B" =~ /(.+)/;
    @@foo=(); push @@foo, $_ for undef..$1;
    is(join(":", map "[$_]", @@foo), '[]');
}
{
    local $1;
    "B" =~ /(.+)/;
    @@foo=(); push @@foo, $_ for ""..$1;
    is(join(":", map "[$_]", @@foo), '[]');
}
{
    local $1;
    "B" =~ /(.+)/;
    @@foo=(); push @@foo, $_ for $1..undef;
    is(join(":", map "[$_]", @@foo), '');
}
{
    local $1;
    "B" =~ /(.+)/;
    @@foo=(); push @@foo, $_ for $1.."";
    is(join(":", map "[$_]", @@foo), '');
}

# Test upper range limit
my $MAX_INT = ~0>>1;

foreach my $ii (-3 .. 3) {
    my ($first, $last);
    eval {
        my $lim=0;
        for ($MAX_INT-10 .. $MAX_INT+$ii) {
            if (! defined($first)) {
                $first = $_;
            }
            $last = $_;
            last if ($lim++ > 100);   # Protect against integer wrap
        }
    };
    if ($ii <= 0) {
        ok(! $@@, 'Upper bound accepted: ' . ($MAX_INT+$ii));
        is($first, $MAX_INT-10, 'Lower bound okay');
        is($last, $MAX_INT+$ii, 'Upper bound okay');
    } else {
        ok($@@, 'Upper bound rejected: ' . ($MAX_INT+$ii));
    }
}

foreach my $ii (-3 .. 3) {
    my ($first, $last);
    eval {
        my $lim=0;
        for ($MAX_INT+$ii .. $MAX_INT) {
            if (! defined($first)) {
                $first = $_;
            }
            $last = $_;
            last if ($lim++ > 100);
        }
    };
    if ($ii <= 0) {
        ok(! $@@, 'Lower bound accepted: ' . ($MAX_INT+$ii));
        is($first, $MAX_INT+$ii, 'Lower bound okay');
        is($last, $MAX_INT, 'Upper bound okay');
    } else {
        ok($@@, 'Lower bound rejected: ' . ($MAX_INT+$ii));
    }
}

{
    my $first;
    eval {
        my $lim=0;
        for ($MAX_INT .. $MAX_INT-1) {
            if (! defined($first)) {
                $first = $_;
            }
            $last = $_;
            last if ($lim++ > 100);
        }
    };
    ok(! $@@, 'Range accepted');
    ok(! defined($first), 'Range ineffectual');
}

foreach my $ii (~0, ~0+1, ~0+(~0>>4)) {
    eval {
        my $lim=0;
        for ($MAX_INT-10 .. $ii) {
            last if ($lim++ > 100);
        }
    };
    ok($@@, 'Upper bound rejected: ' . $ii);
}

# Test lower range limit
my $MIN_INT = -1-$MAX_INT;

if (! $Config{d_nv_preserves_uv}) {
    # $MIN_INT needs adjustment when IV won't fit into an NV
    my $NV = $MIN_INT - 1;
    my $OFFSET = 1;
    while (($NV + $OFFSET) == $MIN_INT) {
        $OFFSET++
    }
    $MIN_INT += $OFFSET;
}

foreach my $ii (-3 .. 3) {
    my ($first, $last);
    eval {
        my $lim=0;
        for ($MIN_INT+$ii .. $MIN_INT+10) {
            if (! defined($first)) {
                $first = $_;
            }
            $last = $_;
            last if ($lim++ > 100);
        }
    };
    if ($ii >= 0) {
        ok(! $@@, 'Lower bound accepted: ' . ($MIN_INT+$ii));
        is($first, $MIN_INT+$ii, 'Lower bound okay');
        is($last, $MIN_INT+10, 'Upper bound okay');
    } else {
        ok($@@, 'Lower bound rejected: ' . ($MIN_INT+$ii));
    }
}

foreach my $ii (-3 .. 3) {
    my ($first, $last);
    eval {
        my $lim=0;
        for ($MIN_INT .. $MIN_INT+$ii) {
            if (! defined($first)) {
                $first = $_;
            }
            $last = $_;
            last if ($lim++ > 100);
        }
    };
    if ($ii >= 0) {
        ok(! $@@, 'Upper bound accepted: ' . ($MIN_INT+$ii));
        is($first, $MIN_INT, 'Lower bound okay');
        is($last, $MIN_INT+$ii, 'Upper bound okay');
    } else {
        ok($@@, 'Upper bound rejected: ' . ($MIN_INT+$ii));
    }
}

{
    my $first;
    eval {
        my $lim=0;
        for ($MIN_INT+1 .. $MIN_INT) {
            if (! defined($first)) {
                $first = $_;
            }
            $last = $_;
            last if ($lim++ > 100);
        }
    };
    ok(! $@@, 'Range accepted');
    ok(! defined($first), 'Range ineffectual');
}

foreach my $ii (~0, ~0+1, ~0+(~0>>4)) {
    eval {
        my $lim=0;
        for (-$ii .. $MIN_INT+10) {
            last if ($lim++ > 100);
        }
    };
    ok($@@, 'Lower bound rejected: ' . -$ii);
}

# double/triple magic tests
sub TIESCALAR { bless { value => $_[1], orig => $_[1] } }
sub STORE { $_[0]{store}++; $_[0]{value} = $_[1] }
sub FETCH { $_[0]{fetch}++; $_[0]{value} }
sub stores { tied($_[0])->{value} = tied($_[0])->{orig};
             delete(tied($_[0])->{store}) || 0 }
sub fetches { delete(tied($_[0])->{fetch}) || 0 }
    
tie $x, "main", 6;

my @@foo;
@@foo = 4 .. $x;
is(scalar @@foo, 3);
is("@@foo", "4 5 6");
is(fetches($x), 1);
is(stores($x), 0);

@@foo = $x .. 8;
is(scalar @@foo, 3);
is("@@foo", "6 7 8");
is(fetches($x), 1);
is(stores($x), 0);

@@foo = $x .. $x + 1;
is(scalar @@foo, 2);
is("@@foo", "6 7");
is(fetches($x), 2);
is(stores($x), 0);

@@foo = ();
for (4 .. $x) {
  push @@foo, $_;
}
is(scalar @@foo, 3);
is("@@foo", "4 5 6");
is(fetches($x), 1);
is(stores($x), 0);

@@foo = ();
for (reverse 4 .. $x) {
  push @@foo, $_;
}
is(scalar @@foo, 3);
is("@@foo", "6 5 4");
is(fetches($x), 1);
is(stores($x), 0);

is( ( join ' ', map { join '', map ++$_, ($x=1)..4 } 1..2 ), '2345 2345',
    'modifiable variable num range' );
is( ( join ' ', map { join '', map ++$_, 1..4      } 1..2 ), '2345 2345',
    'modifiable const num range' );  # RT#3105
$s = ''; for (1..2) { for (1..4) { $s .= ++$_ } $s.=' ' if $_==1; }
is( $s, '2345 2345','modifiable num counting loop counter' );


is( ( join ' ', map { join '', map ++$_, ($x='a')..'d' } 1..2 ), 'bcde bcde',
    'modifiable variable alpha range' );
is( ( join ' ', map { join '', map ++$_, 'a'..'d'      } 1..2 ), 'bcde bcde',
    'modifiable const alpha range' );  # RT#3105
$s = ''; for (1..2) { for ('a'..'d') { $s .= ++$_ } $s.=' ' if $_==1; }
is( $s, 'bcde bcde','modifiable alpha counting loop counter' );

# EOF
@


1.13
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d8 1
a8 1
require 'test.pl';
@


1.12
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d393 2
a394 2
is( ( join ' ', map { join '', map ++$_, 1..4      } 1..2 ), '2345 3456',
    'modifiable const num range' );  # Unresolved bug RT#3105
d401 2
a402 2
is( ( join ' ', map { join '', map ++$_, 'a'..'d'      } 1..2 ), 'bcde cdef',
    'modifiable const alpha range' );  # Unresolved bug RT#3105
@


1.11
log
@merge in perl 5.12.2 plus local changes
@
text
@d344 1
a344 1
# double/tripple magic tests
d358 1
a358 4
{
  local $TODO = "test for double magic with range operator";
  is(fetches($x), 1);
}
d364 1
a364 4
{
  local $TODO = "test for double magic with range operator";
  is(fetches($x), 1);
}
d370 1
a370 4
{
  local $TODO = "test for double magic with range operator";
  is(fetches($x), 2);
}
d379 1
a379 4
{
  local $TODO = "test for double magic with range operator";
  is(fetches($x), 1);
}
d388 1
a388 4
{
  local $TODO = "test for double magic with range operator";
  is(fetches($x), 1);
}
@


1.10
log
@Merge in perl 5.10.1; part two
@
text
@d12 1
a12 1
plan (135);
d405 15
@


1.9
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d12 1
a12 1
plan (45);
d191 216
@


1.8
log
@merge in perl 5.8.8
@
text
@d5 1
a5 1
    @@INC = '../lib';
d7 2
d12 1
a12 1
print "1..45\n";
d14 1
a14 1
print join(':',1..5) eq '1:2:3:4:5' ? "ok 1\n" : "not ok 1\n";
d19 1
a19 1
print join(':',@@foo[$foo[0]..5]) eq '2:c:d:e:6' ? "ok 2\n" : "not ok 2\n";
d22 1
a22 1
print join(':',@@bar[1..5]) eq ':c:d:e:' ? "ok 3\n" : "not ok 3\n";
d25 1
a25 1
print join(':',$a,@@bcd[0..2],$e) eq 'a:b:c:d:e' ? "ok 4\n" : "not ok 4\n";
d31 1
a31 1
print $x == 5050 ? "ok 5\n" : "not ok 5 $x\n";
d37 1
a37 1
print $x == 5050 ? "ok 6\n" : "not ok 6 $x\n";
d40 1
a40 1
print $x eq 'abcdefghijklmnopqrstuvwxyz' ? "ok 7\n" : "not ok 7 $x\n";
d43 1
a43 1
print @@x == 27 * 26 ? "ok 8\n" : "not ok 8\n";
d46 1
a46 3
print "not " unless join(",", @@x) eq
                    join(",", map {sprintf "%02d",$_} 9..99);
print "ok 9\n";
d53 1
a53 2
print "not " unless join(",", @@y) eq join(",", @@x);
print "ok 10\n";
d69 1
a69 2
print "not " unless "@@a" eq $a;
print "ok 11\n";
d71 1
a71 2
print "not " unless "@@b" eq $b;
print "ok 12\n";
d79 1
a79 2
    $bad = 1 unless $x eq 'a:b:c:d:e';
    print $bad ? "not ok 13\n" : "ok 13\n";
d83 10
a92 5
print "not " unless 0 == (() = "0"..-1);
print "ok 14\n";

for my $x ("0"..-1) {
    print "not ";
a93 1
print "ok 15\n";
d96 4
a99 4
print join(":","-4".."0")      eq "-4:-3:-2:-1:0" ? "ok 16\n" : "not ok 16\n";
print join(":","-4".."-0")     eq "-4:-3:-2:-1:0" ? "ok 17\n" : "not ok 17\n";
print join(":","-4\n".."0\n")  eq "-4:-3:-2:-1:0" ? "ok 18\n" : "not ok 18\n";
print join(":","-4\n".."-0\n") eq "-4:-3:-2:-1:0" ? "ok 19\n" : "not ok 19\n";
d102 4
a105 4
print join(":",undef..2) eq '0:1:2' ? "ok 20\n" : "not ok 20\n";
print join(":",-2..undef) eq '-2:-1:0' ? "ok 21\n" : "not ok 21\n";
print join(":",undef..'2') eq '0:1:2' ? "ok 22\n" : "not ok 22\n";
print join(":",'-2'..undef) eq '-2:-1:0' ? "ok 23\n" : "not ok 23\n";
d108 4
a111 4
print join(":", map "[$_]", "".."B") eq '[]' ? "ok 24\n" : "not ok 24\n";
print join(":", map "[$_]", undef.."B") eq '[]' ? "ok 25\n" : "not ok 25\n";
print join(":", map "[$_]", "B".."") eq '' ? "ok 26\n" : "not ok 26\n";
print join(":", map "[$_]", "B"..undef) eq '' ? "ok 27\n" : "not ok 27\n";
d114 1
a114 1
print join(":", map "[$_]", undef..undef) eq '[]' ? "ok 28\n" : "not ok 28\n";
d118 1
a118 1
print join(":", @@foo) eq '0:1:2' ? "ok 29\n" : "not ok 29\n";
d121 1
a121 1
print join(":", @@foo) eq '-2:-1:0' ? "ok 30\n" : "not ok 30\n";
d124 1
a124 1
print join(":", @@foo) eq '0:1:2' ? "ok 31\n" : "not ok 31\n";
d127 1
a127 1
print join(":", @@foo) eq '-2:-1:0' ? "ok 32\n" : "not ok 32\n";
d130 1
a130 1
print join(":", map "[$_]", @@foo) eq '[]' ? "ok 33\n" : "not ok 33\n";
d133 1
a133 1
print join(":", map "[$_]", @@foo) eq '[]' ? "ok 34\n" : "not ok 34\n";
d136 1
a136 1
print join(":", map "[$_]", @@foo) eq '' ? "ok 35\n" : "not ok 35\n";
d139 1
a139 1
print join(":", map "[$_]", @@foo) eq '' ? "ok 36\n" : "not ok 36\n";
d142 1
a142 1
print join(":", map "[$_]", @@foo) eq '[]' ? "ok 37\n" : "not ok 37\n";
d148 1
a148 1
    print join(":", @@foo) eq '0:1:2' ? "ok 38\n" : "not ok 38\n";
d153 1
a153 1
    print join(":", @@foo) eq '-1:0' ? "ok 39\n" : "not ok 39\n";
d159 1
a159 1
    print join(":", @@foo) eq '0:1:2' ? "ok 40\n" : "not ok 40\n";
d165 1
a165 1
    print join(":", @@foo) eq '-2:-1:0' ? "ok 41\n" : "not ok 41\n";
d171 1
a171 1
    print join(":", map "[$_]", @@foo) eq '[]' ? "ok 42\n" : "not ok 42\n";
d177 1
a177 1
    print join(":", map "[$_]", @@foo) eq '[]' ? "ok 43\n" : "not ok 43\n";
d183 1
a183 1
    print join(":", map "[$_]", @@foo) eq '' ? "ok 44\n" : "not ok 44\n";
d189 1
a189 1
    print join(":", map "[$_]", @@foo) eq '' ? "ok 45\n" : "not ok 45\n";
@


1.7
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d10 1
a10 1
print "1..37\n";
d143 48
@


1.6
log
@merge local changes into perl-5.8.3
@
text
@d3 8
a10 1
print "1..25\n";
d57 14
a70 2
@@a = 0x7ffffffe..0x7fffffff;
print "not " unless "@@a" eq "2147483646 2147483647";
d73 1
a73 2
@@a = -0x7fffffff..-0x7ffffffe;
print "not " unless "@@a" eq "-2147483647 -2147483646";
d104 2
d108 35
a142 4
print join(":","".."B") eq '' ? "ok 22\n" : "not ok 22\n";
print join(":",undef.."B") eq '' ? "ok 23\n" : "not ok 23\n";
print join(":","B".."") eq '' ? "ok 24\n" : "not ok 24\n";
print join(":","B"..undef) eq '' ? "ok 25\n" : "not ok 25\n";
@


1.5
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d3 1
a3 1
print "1..19\n";
d82 10
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d3 1
a3 1
print "1..15\n";
d76 6
@


1.3
log
@perl5.005_03 (stock)
@
text
@d3 1
a3 1
print "1..12\n";
d58 18
@


1.2
log
@perl 5.004_04
@
text
@d3 1
a3 3
# $RCSfile: range.t,v $$Revision: 4.1 $$Date: 92/08/07 18:28:14 $

print "1..8\n";
d35 23
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d3 3
a5 1
print "1..12\n";
a36 23

@@x = '09' .. '08';  # should produce '09', '10',... '99' (strange but true)
print "not " unless join(",", @@x) eq
                    join(",", map {sprintf "%02d",$_} 9..99);
print "ok 9\n";

# same test with foreach (which is a separate implementation)
@@y = ();
foreach ('09'..'08') {
    push(@@y, $_);
}
print "not " unless join(",", @@y) eq join(",", @@x);
print "ok 10\n";

# check bounds
@@a = 0x7ffffffe..0x7fffffff;
print "not " unless "@@a" eq "2147483646 2147483647";
print "ok 11\n";

@@a = -0x7fffffff..-0x7ffffffe;
print "not " unless "@@a" eq "-2147483647 -2147483646";
print "ok 12\n";

@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d3 1
a3 1
print "1..15\n";
a57 18
# check magic
{
    my $bad = 0;
    local $SIG{'__WARN__'} = sub { $bad = 1 };
    my $x = 'a-e';
    $x =~ s/(\w)-(\w)/join ':', $1 .. $2/e;
    $bad = 1 unless $x eq 'a:b:c:d:e';
    print $bad ? "not ok 13\n" : "ok 13\n";
}

# Should use magical autoinc only when both are strings
print "not " unless 0 == (() = "0"..-1);
print "ok 14\n";

for my $x ("0"..-1) {
    print "not ";
}
print "ok 15\n";
@


1.1.1.4
log
@perl 5.8.2 from CPAN
@
text
@d3 1
a3 1
print "1..19\n";
a75 6

# [#18165] Should allow "-4".."0", broken by #4730. (AMS 20021031)
print join(":","-4".."0")      eq "-4:-3:-2:-1:0" ? "ok 16\n" : "not ok 16\n";
print join(":","-4".."-0")     eq "-4:-3:-2:-1:0" ? "ok 17\n" : "not ok 17\n";
print join(":","-4\n".."0\n")  eq "-4:-3:-2:-1:0" ? "ok 18\n" : "not ok 18\n";
print join(":","-4\n".."-0\n") eq "-4:-3:-2:-1:0" ? "ok 19\n" : "not ok 19\n";
@


1.1.1.5
log
@perl 5.8.3 from CPAN
@
text
@d3 1
a3 1
print "1..25\n";
a81 10

# undef should be treated as 0 for numerical range
print join(":",undef..2) eq '0:1:2' ? "ok 20\n" : "not ok 20\n";
print join(":",-2..undef) eq '-2:-1:0' ? "ok 21\n" : "not ok 21\n";

# undef should be treated as "" for magical range
print join(":","".."B") eq '' ? "ok 22\n" : "not ok 22\n";
print join(":",undef.."B") eq '' ? "ok 23\n" : "not ok 23\n";
print join(":","B".."") eq '' ? "ok 24\n" : "not ok 24\n";
print join(":","B"..undef) eq '' ? "ok 25\n" : "not ok 25\n";
@


1.1.1.6
log
@Import of stock perl 5.8.5
@
text
@d3 1
a3 8
BEGIN {
    chdir 't' if -d 't';
    @@INC = '../lib';
}   

use Config;

print "1..37\n";
d50 2
a51 14
if ($Config{ivsize} == 8) {
  @@a = eval "0x7ffffffffffffffe..0x7fffffffffffffff";
  $a = "9223372036854775806 9223372036854775807";
  @@b = eval "-0x7fffffffffffffff..-0x7ffffffffffffffe";
  $b = "-9223372036854775807 -9223372036854775806";
}
else {
  @@a = eval "0x7ffffffe..0x7fffffff";
  $a = "2147483646 2147483647";
  @@b = eval "-0x7fffffff..-0x7ffffffe";
  $b = "-2147483647 -2147483646";
}

print "not " unless "@@a" eq $a;
d54 2
a55 1
print "not " unless "@@b" eq $b;
a85 2
print join(":",undef..'2') eq '0:1:2' ? "ok 22\n" : "not ok 22\n";
print join(":",'-2'..undef) eq '-2:-1:0' ? "ok 23\n" : "not ok 23\n";
d88 4
a91 35
print join(":", map "[$_]", "".."B") eq '[]' ? "ok 24\n" : "not ok 24\n";
print join(":", map "[$_]", undef.."B") eq '[]' ? "ok 25\n" : "not ok 25\n";
print join(":", map "[$_]", "B".."") eq '' ? "ok 26\n" : "not ok 26\n";
print join(":", map "[$_]", "B"..undef) eq '' ? "ok 27\n" : "not ok 27\n";

# undef..undef used to segfault
print join(":", map "[$_]", undef..undef) eq '[]' ? "ok 28\n" : "not ok 28\n";

# also test undef in foreach loops
@@foo=(); push @@foo, $_ for undef..2;
print join(":", @@foo) eq '0:1:2' ? "ok 29\n" : "not ok 29\n";

@@foo=(); push @@foo, $_ for -2..undef;
print join(":", @@foo) eq '-2:-1:0' ? "ok 30\n" : "not ok 30\n";

@@foo=(); push @@foo, $_ for undef..'2';
print join(":", @@foo) eq '0:1:2' ? "ok 31\n" : "not ok 31\n";

@@foo=(); push @@foo, $_ for '-2'..undef;
print join(":", @@foo) eq '-2:-1:0' ? "ok 32\n" : "not ok 32\n";

@@foo=(); push @@foo, $_ for undef.."B";
print join(":", map "[$_]", @@foo) eq '[]' ? "ok 33\n" : "not ok 33\n";

@@foo=(); push @@foo, $_ for "".."B";
print join(":", map "[$_]", @@foo) eq '[]' ? "ok 34\n" : "not ok 34\n";

@@foo=(); push @@foo, $_ for "B"..undef;
print join(":", map "[$_]", @@foo) eq '' ? "ok 35\n" : "not ok 35\n";

@@foo=(); push @@foo, $_ for "B".."";
print join(":", map "[$_]", @@foo) eq '' ? "ok 36\n" : "not ok 36\n";

@@foo=(); push @@foo, $_ for undef..undef;
print join(":", map "[$_]", @@foo) eq '[]' ? "ok 37\n" : "not ok 37\n";
@


1.1.1.7
log
@perl 5.8.8 import
@
text
@d10 1
a10 1
print "1..45\n";
a142 48

# again with magic
{
    my @@a = (1..3);
    @@foo=(); push @@foo, $_ for undef..$#a;
    print join(":", @@foo) eq '0:1:2' ? "ok 38\n" : "not ok 38\n";
}
{
    my @@a = ();
    @@foo=(); push @@foo, $_ for $#a..undef;
    print join(":", @@foo) eq '-1:0' ? "ok 39\n" : "not ok 39\n";
}
{
    local $1;
    "2" =~ /(.+)/;
    @@foo=(); push @@foo, $_ for undef..$1;
    print join(":", @@foo) eq '0:1:2' ? "ok 40\n" : "not ok 40\n";
}
{
    local $1;
    "-2" =~ /(.+)/;
    @@foo=(); push @@foo, $_ for $1..undef;
    print join(":", @@foo) eq '-2:-1:0' ? "ok 41\n" : "not ok 41\n";
}
{
    local $1;
    "B" =~ /(.+)/;
    @@foo=(); push @@foo, $_ for undef..$1;
    print join(":", map "[$_]", @@foo) eq '[]' ? "ok 42\n" : "not ok 42\n";
}
{
    local $1;
    "B" =~ /(.+)/;
    @@foo=(); push @@foo, $_ for ""..$1;
    print join(":", map "[$_]", @@foo) eq '[]' ? "ok 43\n" : "not ok 43\n";
}
{
    local $1;
    "B" =~ /(.+)/;
    @@foo=(); push @@foo, $_ for $1..undef;
    print join(":", map "[$_]", @@foo) eq '' ? "ok 44\n" : "not ok 44\n";
}
{
    local $1;
    "B" =~ /(.+)/;
    @@foo=(); push @@foo, $_ for $1.."";
    print join(":", map "[$_]", @@foo) eq '' ? "ok 45\n" : "not ok 45\n";
}
@


1.1.1.8
log
@import perl 5.10.0 from CPAN
@
text
@d5 1
a5 1
    @@INC = ('../lib', '.');
a6 2
# Avoid using eq_array below as it uses .. internally.
require 'test.pl';
d10 1
a10 1
plan (45);
d12 1
a12 1
is(join(':',1..5), '1:2:3:4:5');
d17 1
a17 1
is(join(':',@@foo[$foo[0]..5]), '2:c:d:e:6');
d20 1
a20 1
is(join(':',@@bar[1..5]), ':c:d:e:');
d23 1
a23 1
is(join(':',$a,@@bcd[0..2],$e), 'a:b:c:d:e');
d29 1
a29 1
is($x, 5050);
d35 1
a35 1
is($x, 5050);
d38 1
a38 1
is($x, 'abcdefghijklmnopqrstuvwxyz');
d41 1
a41 1
is (scalar @@x, 27 * 26);
d44 3
a46 1
is(join(",", @@x), join(",", map {sprintf "%02d",$_} 9..99));
d53 2
a54 1
is(join(",", @@y), join(",", @@x));
d70 2
a71 1
is ("@@a", $a);
d73 2
a74 1
is ("@@b", $b);
d82 2
a83 1
    is ($x, 'a:b:c:d:e');
d87 5
a91 10
{
    my $scalar = (() = "0"..-1);
    is ($scalar, 0);
}
{
    my $fail = 0;
    for my $x ("0"..-1) {
	$fail++;
    }
    is ($fail, 0);
d93 1
d96 4
a99 4
is(join(":","-4".."0")     , "-4:-3:-2:-1:0");
is(join(":","-4".."-0")    , "-4:-3:-2:-1:0");
is(join(":","-4\n".."0\n") , "-4:-3:-2:-1:0");
is(join(":","-4\n".."-0\n"), "-4:-3:-2:-1:0");
d102 4
a105 4
is(join(":",undef..2), '0:1:2');
is(join(":",-2..undef), '-2:-1:0');
is(join(":",undef..'2'), '0:1:2');
is(join(":",'-2'..undef), '-2:-1:0');
d108 4
a111 4
is(join(":", map "[$_]", "".."B"), '[]');
is(join(":", map "[$_]", undef.."B"), '[]');
is(join(":", map "[$_]", "B"..""), '');
is(join(":", map "[$_]", "B"..undef), '');
d114 1
a114 1
is(join(":", map "[$_]", undef..undef), '[]');
d118 1
a118 1
is(join(":", @@foo), '0:1:2');
d121 1
a121 1
is(join(":", @@foo), '-2:-1:0');
d124 1
a124 1
is(join(":", @@foo), '0:1:2');
d127 1
a127 1
is(join(":", @@foo), '-2:-1:0');
d130 1
a130 1
is(join(":", map "[$_]", @@foo), '[]');
d133 1
a133 1
is(join(":", map "[$_]", @@foo), '[]');
d136 1
a136 1
is(join(":", map "[$_]", @@foo), '');
d139 1
a139 1
is(join(":", map "[$_]", @@foo), '');
d142 1
a142 1
is(join(":", map "[$_]", @@foo), '[]');
d148 1
a148 1
    is(join(":", @@foo), '0:1:2');
d153 1
a153 1
    is(join(":", @@foo), '-1:0');
d159 1
a159 1
    is(join(":", @@foo), '0:1:2');
d165 1
a165 1
    is(join(":", @@foo), '-2:-1:0');
d171 1
a171 1
    is(join(":", map "[$_]", @@foo), '[]');
d177 1
a177 1
    is(join(":", map "[$_]", @@foo), '[]');
d183 1
a183 1
    is(join(":", map "[$_]", @@foo), '');
d189 1
a189 1
    is(join(":", map "[$_]", @@foo), '');
@


1.1.1.9
log
@import perl 5.10.1
@
text
@d12 1
a12 1
plan (135);
a190 216

# Test upper range limit
my $MAX_INT = ~0>>1;

foreach my $ii (-3 .. 3) {
    my ($first, $last);
    eval {
        my $lim=0;
        for ($MAX_INT-10 .. $MAX_INT+$ii) {
            if (! defined($first)) {
                $first = $_;
            }
            $last = $_;
            last if ($lim++ > 100);   # Protect against integer wrap
        }
    };
    if ($ii <= 0) {
        ok(! $@@, 'Upper bound accepted: ' . ($MAX_INT+$ii));
        is($first, $MAX_INT-10, 'Lower bound okay');
        is($last, $MAX_INT+$ii, 'Upper bound okay');
    } else {
        ok($@@, 'Upper bound rejected: ' . ($MAX_INT+$ii));
    }
}

foreach my $ii (-3 .. 3) {
    my ($first, $last);
    eval {
        my $lim=0;
        for ($MAX_INT+$ii .. $MAX_INT) {
            if (! defined($first)) {
                $first = $_;
            }
            $last = $_;
            last if ($lim++ > 100);
        }
    };
    if ($ii <= 0) {
        ok(! $@@, 'Lower bound accepted: ' . ($MAX_INT+$ii));
        is($first, $MAX_INT+$ii, 'Lower bound okay');
        is($last, $MAX_INT, 'Upper bound okay');
    } else {
        ok($@@, 'Lower bound rejected: ' . ($MAX_INT+$ii));
    }
}

{
    my $first;
    eval {
        my $lim=0;
        for ($MAX_INT .. $MAX_INT-1) {
            if (! defined($first)) {
                $first = $_;
            }
            $last = $_;
            last if ($lim++ > 100);
        }
    };
    ok(! $@@, 'Range accepted');
    ok(! defined($first), 'Range ineffectual');
}

foreach my $ii (~0, ~0+1, ~0+(~0>>4)) {
    eval {
        my $lim=0;
        for ($MAX_INT-10 .. $ii) {
            last if ($lim++ > 100);
        }
    };
    ok($@@, 'Upper bound rejected: ' . $ii);
}

# Test lower range limit
my $MIN_INT = -1-$MAX_INT;

if (! $Config{d_nv_preserves_uv}) {
    # $MIN_INT needs adjustment when IV won't fit into an NV
    my $NV = $MIN_INT - 1;
    my $OFFSET = 1;
    while (($NV + $OFFSET) == $MIN_INT) {
        $OFFSET++
    }
    $MIN_INT += $OFFSET;
}

foreach my $ii (-3 .. 3) {
    my ($first, $last);
    eval {
        my $lim=0;
        for ($MIN_INT+$ii .. $MIN_INT+10) {
            if (! defined($first)) {
                $first = $_;
            }
            $last = $_;
            last if ($lim++ > 100);
        }
    };
    if ($ii >= 0) {
        ok(! $@@, 'Lower bound accepted: ' . ($MIN_INT+$ii));
        is($first, $MIN_INT+$ii, 'Lower bound okay');
        is($last, $MIN_INT+10, 'Upper bound okay');
    } else {
        ok($@@, 'Lower bound rejected: ' . ($MIN_INT+$ii));
    }
}

foreach my $ii (-3 .. 3) {
    my ($first, $last);
    eval {
        my $lim=0;
        for ($MIN_INT .. $MIN_INT+$ii) {
            if (! defined($first)) {
                $first = $_;
            }
            $last = $_;
            last if ($lim++ > 100);
        }
    };
    if ($ii >= 0) {
        ok(! $@@, 'Upper bound accepted: ' . ($MIN_INT+$ii));
        is($first, $MIN_INT, 'Lower bound okay');
        is($last, $MIN_INT+$ii, 'Upper bound okay');
    } else {
        ok($@@, 'Upper bound rejected: ' . ($MIN_INT+$ii));
    }
}

{
    my $first;
    eval {
        my $lim=0;
        for ($MIN_INT+1 .. $MIN_INT) {
            if (! defined($first)) {
                $first = $_;
            }
            $last = $_;
            last if ($lim++ > 100);
        }
    };
    ok(! $@@, 'Range accepted');
    ok(! defined($first), 'Range ineffectual');
}

foreach my $ii (~0, ~0+1, ~0+(~0>>4)) {
    eval {
        my $lim=0;
        for (-$ii .. $MIN_INT+10) {
            last if ($lim++ > 100);
        }
    };
    ok($@@, 'Lower bound rejected: ' . -$ii);
}

# double/tripple magic tests
sub TIESCALAR { bless { value => $_[1], orig => $_[1] } }
sub STORE { $_[0]{store}++; $_[0]{value} = $_[1] }
sub FETCH { $_[0]{fetch}++; $_[0]{value} }
sub stores { tied($_[0])->{value} = tied($_[0])->{orig};
             delete(tied($_[0])->{store}) || 0 }
sub fetches { delete(tied($_[0])->{fetch}) || 0 }
    
tie $x, "main", 6;

my @@foo;
@@foo = 4 .. $x;
is(scalar @@foo, 3);
is("@@foo", "4 5 6");
{
  local $TODO = "test for double magic with range operator";
  is(fetches($x), 1);
}
is(stores($x), 0);

@@foo = $x .. 8;
is(scalar @@foo, 3);
is("@@foo", "6 7 8");
{
  local $TODO = "test for double magic with range operator";
  is(fetches($x), 1);
}
is(stores($x), 0);

@@foo = $x .. $x + 1;
is(scalar @@foo, 2);
is("@@foo", "6 7");
{
  local $TODO = "test for double magic with range operator";
  is(fetches($x), 2);
}
is(stores($x), 0);

@@foo = ();
for (4 .. $x) {
  push @@foo, $_;
}
is(scalar @@foo, 3);
is("@@foo", "4 5 6");
{
  local $TODO = "test for double magic with range operator";
  is(fetches($x), 1);
}
is(stores($x), 0);

@@foo = ();
for (reverse 4 .. $x) {
  push @@foo, $_;
}
is(scalar @@foo, 3);
is("@@foo", "6 5 4");
{
  local $TODO = "test for double magic with range operator";
  is(fetches($x), 1);
}
is(stores($x), 0);

# EOF
@


1.1.1.10
log
@Perl 5.12.2 from CPAN
@
text
@d12 1
a12 1
plan (141);
a404 15

is( ( join ' ', map { join '', map ++$_, ($x=1)..4 } 1..2 ), '2345 2345',
    'modifiable variable num range' );
is( ( join ' ', map { join '', map ++$_, 1..4      } 1..2 ), '2345 3456',
    'modifiable const num range' );  # Unresolved bug RT#3105
$s = ''; for (1..2) { for (1..4) { $s .= ++$_ } $s.=' ' if $_==1; }
is( $s, '2345 2345','modifiable num counting loop counter' );


is( ( join ' ', map { join '', map ++$_, ($x='a')..'d' } 1..2 ), 'bcde bcde',
    'modifiable variable alpha range' );
is( ( join ' ', map { join '', map ++$_, 'a'..'d'      } 1..2 ), 'bcde cdef',
    'modifiable const alpha range' );  # Unresolved bug RT#3105
$s = ''; for (1..2) { for ('a'..'d') { $s .= ++$_ } $s.=' ' if $_==1; }
is( $s, 'bcde bcde','modifiable alpha counting loop counter' );
@


1.1.1.11
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d344 1
a344 1
# double/triple magic tests
d358 4
a361 1
is(fetches($x), 1);
d367 4
a370 1
is(fetches($x), 1);
d376 4
a379 1
is(fetches($x), 2);
d388 4
a391 1
is(fetches($x), 1);
d400 4
a403 1
is(fetches($x), 1);
@


1.1.1.12
log
@Import perl-5.20.1
@
text
@d393 2
a394 2
is( ( join ' ', map { join '', map ++$_, 1..4      } 1..2 ), '2345 2345',
    'modifiable const num range' );  # RT#3105
d401 2
a402 2
is( ( join ' ', map { join '', map ++$_, 'a'..'d'      } 1..2 ), 'bcde bcde',
    'modifiable const alpha range' );  # RT#3105
@


