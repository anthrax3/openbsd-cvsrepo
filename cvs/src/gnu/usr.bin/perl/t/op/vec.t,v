head	1.13;
access;
symbols
	OPENBSD_6_2:1.13.0.2
	OPENBSD_6_2_BASE:1.13
	PERL_5_24_2:1.1.1.12
	OPENBSD_6_1:1.13.0.4
	OPENBSD_6_1_BASE:1.13
	OPENBSD_6_0:1.12.0.10
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.12.0.4
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.12.0.6
	OPENBSD_5_8_BASE:1.12
	PERL_5_20_2:1.1.1.11
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	PERL_5_20_1:1.1.1.11
	OPENBSD_5_6:1.11.0.8
	OPENBSD_5_6_BASE:1.11
	PERL_5_18_2:1.1.1.10
	PERL:1.1.1
	OPENBSD_5_5:1.11.0.6
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.2
	OPENBSD_5_4_BASE:1.11
	PERL_5_16_3:1.1.1.10
	OPENBSD_5_3:1.10.0.10
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.8
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.6
	OPENBSD_5_0:1.10.0.4
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.2
	OPENBSD_4_9_BASE:1.10
	PERL_5_12_2:1.1.1.9
	OPENBSD_4_8:1.9.0.8
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.4
	OPENBSD_4_7_BASE:1.9
	PERL_5_10_1:1.1.1.8
	OPENBSD_4_6:1.9.0.6
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.2
	OPENBSD_4_5_BASE:1.9
	PERL_5_10_0:1.1.1.8
	OPENBSD_4_4:1.8.0.10
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.8
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.6
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.4
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.2
	OPENBSD_4_0_BASE:1.8
	PERL_5_8_8:1.1.1.7
	OPENBSD_3_9:1.7.0.10
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.8
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.6
	OPENBSD_3_7_BASE:1.7
	PERL_5_8_6:1.1.1.6
	OPENBSD_3_6:1.7.0.4
	OPENBSD_3_6_BASE:1.7
	PERL_5_8_5:1.1.1.6
	PERL_5_8_3:1.1.1.6
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.13
date	2017.02.05.00.32.20;	author afresh1;	state Exp;
branches;
next	1.12;
commitid	cxJ08BvJA9Pt2PTM;

1.12
date	2014.11.17.20.57.07;	author afresh1;	state Exp;
branches;
next	1.11;
commitid	QP75iYx42Uo7mMxO;

1.11
date	2013.03.25.20.41.00;	author sthen;	state Exp;
branches;
next	1.10;

1.10
date	2010.09.24.15.07.09;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2008.09.29.17.36.20;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2006.03.28.19.23.13;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.49;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.37;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.36.24;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.08.35;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.52.40;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.08.05.50;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.13.23;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.13.23;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.41.54;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.10.53;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.25.49;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.15.11;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.44.33;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2006.03.28.18.49.47;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2008.09.29.17.19.02;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2010.09.24.14.49.18;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2013.03.25.20.09.37;	author sthen;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2014.11.17.20.53.18;	author afresh1;	state Exp;
branches;
next	1.1.1.12;
commitid	B31cAbBIXiCqnL97;

1.1.1.12
date	2017.08.14.13.46.24;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.13
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl

BEGIN {
    chdir 't' if -d 't';
    require './test.pl';
    set_up_inc('../lib');
}

plan( tests => 35 );


is(vec($foo,0,1), 0);
is(length($foo), undef);
vec($foo,0,1) = 1;
is(length($foo), 1);
is(unpack('C',$foo), 1);
is(vec($foo,0,1), 1);

is(vec($foo,20,1), 0);
vec($foo,20,1) = 1;
is(vec($foo,20,1), 1);
is(length($foo), 3);
is(vec($foo,1,8), 0);
vec($foo,1,8) = 0xf1;
is(vec($foo,1,8), 0xf1);
is((unpack('C',substr($foo,1,1)) & 255), 0xf1);
is(vec($foo,2,4), 1);;
is(vec($foo,3,4), 15);
vec($Vec, 0, 32) = 0xbaddacab;
is($Vec, "\xba\xdd\xac\xab");
is(vec($Vec, 0, 32), 3135089835);

# ensure vec() handles numericalness correctly
$foo = $bar = $baz = 0;
vec($foo = 0,0,1) = 1;
vec($bar = 0,1,1) = 1;
$baz = $foo | $bar;
ok($foo eq "1" && $foo == 1);
ok($bar eq "2" && $bar == 2);
ok("$foo $bar $baz" eq "1 2 3");

# error cases

$x = eval { vec $foo, 0, 3 };
like($@@, qr/^Illegal number of bits in vec/);
$@@ = undef;
$x = eval { vec $foo, 0, 0 };
like($@@, qr/^Illegal number of bits in vec/);
$@@ = undef;
$x = eval { vec $foo, 0, -13 };
like($@@, qr/^Illegal number of bits in vec/);
$@@ = undef;
$x = eval { vec($foo, -1, 4) = 2 };
like($@@, qr/^Negative offset to vec in lvalue context/);
$@@ = undef;
ok(! vec('abcd', 7, 8));

# UTF8
# N.B. currently curiously coded to circumvent bugs elswhere in UTF8 handling

$foo = "\x{100}" . "\xff\xfe";
$x = substr $foo, 1;
is(vec($x, 0, 8), 255);
$@@ = undef;
eval { vec($foo, 1, 8) };
ok(! $@@);
$@@ = undef;
eval { vec($foo, 1, 8) = 13 };
ok(! $@@);
if ($::IS_EBCDIC) {
    is($foo, "\x8c\x0d\xff\x8a\x69"); 
}
else {
    is($foo, "\xc4\x0d\xc3\xbf\xc3\xbe");
}
$foo = "\x{100}" . "\xff\xfe";
$x = substr $foo, 1;
vec($x, 2, 4) = 7;
is($x, "\xff\xf7");

# mixed magic

$foo = "\x61\x62\x63\x64\x65\x66";
is(vec(substr($foo, 2, 2), 0, 16), 25444);
vec(substr($foo, 1,3), 5, 4) = 3;
is($foo, "\x61\x62\x63\x34\x65\x66");

# A variation of [perl #20933]
{
    my $s = "";
    vec($s, 0, 1) = 0;
    vec($s, 1, 1) = 1;
    my @@r;
    $r[$_] = \ vec $s, $_, 1 for (0, 1);
    ok(!(${ $r[0] } != 0 || ${ $r[1] } != 1)); 
}


my $destroyed;
{ package Class; DESTROY { ++$destroyed; } }

$destroyed = 0;
{
    my $x = '';
    vec($x,0,1) = 0;
    $x = bless({}, 'Class');
}
is($destroyed, 1, 'Timely scalar destruction with lvalue vec');

use constant roref => \1;
eval { for (roref) { vec($_,0,1) = 1 } };
like($@@, qr/^Modification of a read-only value attempted at /,
        'err msg when modifying read-only refs');


{
    # downgradeable utf8 strings should be downgraded before accessing
    # the byte string.
    # See the p5p thread with Message-ID:
    # <CAMx+QJ6SAv05nmpnc7bmp0Wo+sjcx=ssxCcE-P_PZ8HDuCQd9A@@mail.gmail.com>


    my $x = substr "\x{100}\xff\xfe", 1; # a utf8 string with all ords < 256
    my $v;
    $v = vec($x, 0, 8);
    is($v, 255, "downgraded utf8 try 1");
    $v = vec($x, 0, 8);
    is($v, 255, "downgraded utf8 try 2");
}
@


1.12
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d5 2
a6 1
    @@INC = qw(. ../lib);
a8 1
require "test.pl";
a10 1
my $Is_EBCDIC = (ord('A') == 193) ? 1 : 0;
d70 1
a70 1
if ($Is_EBCDIC) {
@


1.11
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d9 1
a9 1
plan( tests => 32 );
d110 21
@


1.10
log
@merge in perl 5.12.2 plus local changes
@
text
@d9 1
a9 1
plan( tests => 31 );
d98 12
@


1.9
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d14 1
a14 1
is(length($foo), 0);
@


1.8
log
@merge in perl 5.8.8
@
text
@d46 1
a46 1
like($@@, /^Illegal number of bits in vec/);
d49 1
a49 1
like($@@, /^Illegal number of bits in vec/);
d52 1
a52 1
like($@@, /^Illegal number of bits in vec/);
d55 1
a55 1
like($@@, /^Illegal number of bits in vec/);
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d3 7
a9 1
print "1..31\n";
d13 2
a14 2
print vec($foo,0,1) == 0 ? "ok 1\n" : "not ok 1\n";
print length($foo) == 0 ? "ok 2\n" : "not ok 2\n";
d16 3
a18 3
print length($foo) == 1 ? "ok 3\n" : "not ok 3\n";
print unpack('C',$foo) == 1 ? "ok 4\n" : "not ok 4\n";
print vec($foo,0,1) == 1 ? "ok 5\n" : "not ok 5\n";
d20 1
a20 1
print vec($foo,20,1) == 0 ? "ok 6\n" : "not ok 6\n";
d22 3
a24 3
print vec($foo,20,1) == 1 ? "ok 7\n" : "not ok 7\n";
print length($foo) == 3 ? "ok 8\n" : "not ok 8\n";
print vec($foo,1,8) == 0 ? "ok 9\n" : "not ok 9\n";
d26 4
a29 4
print vec($foo,1,8) == 0xf1 ? "ok 10\n" : "not ok 10\n";
print ((unpack('C',substr($foo,1,1)) & 255) == 0xf1 ? "ok 11\n" : "not ok 11\n");
print vec($foo,2,4) == 1 ? "ok 12\n" : "not ok 12\n";
print vec($foo,3,4) == 15 ? "ok 13\n" : "not ok 13\n";
d31 2
a32 2
print $Vec eq "\xba\xdd\xac\xab" ? "ok 14\n" : "not ok 14\n";
print vec($Vec, 0, 32) == 3135089835 ? "ok 15\n" : "not ok 15\n";
d39 3
a41 3
print $foo eq "1" && $foo == 1 ? "ok 16\n" : "not ok 16\n";
print $bar eq "2" && $bar == 2 ? "ok 17\n" : "not ok 17\n";
print "$foo $bar $baz" eq "1 2 3" ? "ok 18\n" : "not ok 18\n";
d46 2
a47 2
print "not " if defined $x or $@@ !~ /^Illegal number of bits in vec/;
print "ok 19\n";
d49 2
a50 2
print "not " if defined $x or $@@ !~ /^Illegal number of bits in vec/;
print "ok 20\n";
d52 2
a53 2
print "not " if defined $x or $@@ !~ /^Illegal number of bits in vec/;
print "ok 21\n";
d55 3
a57 4
print "not " if defined $x or $@@ !~ /^Negative offset to vec in lvalue context/;
print "ok 22\n";
print "not " if vec('abcd', 7, 8);
print "ok 23\n";
d64 2
a65 2
print "not " if vec($x, 0, 8) != 255;
print "ok 24\n";
d67 2
a68 2
print "not " if $@@;
print "ok 25\n";
d70 1
a70 2
print "not " if $@@;
print "ok 26\n";
d72 1
a72 2
    print "not " if $foo ne "\x8c\x0d\xff\x8a\x69";
    print "ok 27\n";
d75 1
a75 2
    print "not " if $foo ne "\xc4\x0d\xc3\xbf\xc3\xbe";
    print "ok 27\n";
d80 1
a80 2
print "not " if $x ne "\xff\xf7";
print "ok 28\n";
d85 1
a85 2
print "not " if vec(substr($foo, 2, 2), 0, 16) != 25444;
print "ok 29\n";
d87 1
a87 2
print "not " if $foo ne "\x61\x62\x63\x34\x65\x66";
print "ok 30\n";
d96 1
a96 2
    print "not " if (${ $r[0] } != 0 || ${ $r[1] } != 1);
    print "ok 31\n";
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d3 1
a3 1
print "1..30\n";
d89 11
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d5 2
d49 1
a49 1
print "not " if defined $x or $@@ !~ /^Assigning to negative offset in vec/;
d67 8
a74 2
print "not " if $foo ne "\xc4\x0d\xc3\xbf\xc3\xbe";
print "ok 27\n";
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d3 1
a3 3
# $RCSfile: vec.t,v $$Revision: 4.1 $$Date: 92/08/07 18:28:36 $

print "1..15\n";
d26 55
@


1.3
log
@perl5.005_03 (stock)
@
text
@d11 1
a11 1
print ord($foo) == 1 ? "ok 4\n" : "not ok 4\n";
d21 1
a21 1
print ((ord(substr($foo,1,1)) & 255) == 0xf1 ? "ok 11\n" : "not ok 11\n");
@


1.2
log
@perl 5.004_04
@
text
@d5 1
a5 1
print "1..13\n";
d24 3
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d5 1
a5 1
print "1..15\n";
a23 3
vec($Vec, 0, 32) = 0xbaddacab;
print $Vec eq "\xba\xdd\xac\xab" ? "ok 14\n" : "not ok 14\n";
print vec($Vec, 0, 32) == 3135089835 ? "ok 15\n" : "not ok 15\n";
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d11 1
a11 1
print unpack('C',$foo) == 1 ? "ok 4\n" : "not ok 4\n";
d21 1
a21 1
print ((unpack('C',substr($foo,1,1)) & 255) == 0xf1 ? "ok 11\n" : "not ok 11\n");
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d3 3
a5 1
print "1..30\n";
a27 55
# ensure vec() handles numericalness correctly
$foo = $bar = $baz = 0;
vec($foo = 0,0,1) = 1;
vec($bar = 0,1,1) = 1;
$baz = $foo | $bar;
print $foo eq "1" && $foo == 1 ? "ok 16\n" : "not ok 16\n";
print $bar eq "2" && $bar == 2 ? "ok 17\n" : "not ok 17\n";
print "$foo $bar $baz" eq "1 2 3" ? "ok 18\n" : "not ok 18\n";

# error cases

$x = eval { vec $foo, 0, 3 };
print "not " if defined $x or $@@ !~ /^Illegal number of bits in vec/;
print "ok 19\n";
$x = eval { vec $foo, 0, 0 };
print "not " if defined $x or $@@ !~ /^Illegal number of bits in vec/;
print "ok 20\n";
$x = eval { vec $foo, 0, -13 };
print "not " if defined $x or $@@ !~ /^Illegal number of bits in vec/;
print "ok 21\n";
$x = eval { vec($foo, -1, 4) = 2 };
print "not " if defined $x or $@@ !~ /^Assigning to negative offset in vec/;
print "ok 22\n";
print "not " if vec('abcd', 7, 8);
print "ok 23\n";

# UTF8
# N.B. currently curiously coded to circumvent bugs elswhere in UTF8 handling

$foo = "\x{100}" . "\xff\xfe";
$x = substr $foo, 1;
print "not " if vec($x, 0, 8) != 255;
print "ok 24\n";
eval { vec($foo, 1, 8) };
print "not " if $@@;
print "ok 25\n";
eval { vec($foo, 1, 8) = 13 };
print "not " if $@@;
print "ok 26\n";
print "not " if $foo ne "\xc4\x0d\xc3\xbf\xc3\xbe";
print "ok 27\n";
$foo = "\x{100}" . "\xff\xfe";
$x = substr $foo, 1;
vec($x, 2, 4) = 7;
print "not " if $x ne "\xff\xf7";
print "ok 28\n";

# mixed magic

$foo = "\x61\x62\x63\x64\x65\x66";
print "not " if vec(substr($foo, 2, 2), 0, 16) != 25444;
print "ok 29\n";
vec(substr($foo, 1,3), 5, 4) = 3;
print "not " if $foo ne "\x61\x62\x63\x34\x65\x66";
print "ok 30\n";
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@a4 2
my $Is_EBCDIC = (ord('A') == 193) ? 1 : 0;

d47 1
a47 1
print "not " if defined $x or $@@ !~ /^Negative offset to vec in lvalue context/;
d65 2
a66 8
if ($Is_EBCDIC) {
    print "not " if $foo ne "\x8c\x0d\xff\x8a\x69";
    print "ok 27\n";
}
else {
    print "not " if $foo ne "\xc4\x0d\xc3\xbf\xc3\xbe";
    print "ok 27\n";
}
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@d3 1
a3 1
print "1..31\n";
a88 11

# A variation of [perl #20933]
{
    my $s = "";
    vec($s, 0, 1) = 0;
    vec($s, 1, 1) = 1;
    my @@r;
    $r[$_] = \ vec $s, $_, 1 for (0, 1);
    print "not " if (${ $r[0] } != 0 || ${ $r[1] } != 1);
    print "ok 31\n";
}
@


1.1.1.7
log
@perl 5.8.8 import
@
text
@d3 1
a3 7
BEGIN {
    chdir 't' if -d 't';
    @@INC = qw(. ../lib);
}

require "test.pl";
plan( tests => 31 );
d7 2
a8 2
is(vec($foo,0,1), 0);
is(length($foo), 0);
d10 3
a12 3
is(length($foo), 1);
is(unpack('C',$foo), 1);
is(vec($foo,0,1), 1);
d14 1
a14 1
is(vec($foo,20,1), 0);
d16 3
a18 3
is(vec($foo,20,1), 1);
is(length($foo), 3);
is(vec($foo,1,8), 0);
d20 4
a23 4
is(vec($foo,1,8), 0xf1);
is((unpack('C',substr($foo,1,1)) & 255), 0xf1);
is(vec($foo,2,4), 1);;
is(vec($foo,3,4), 15);
d25 2
a26 2
is($Vec, "\xba\xdd\xac\xab");
is(vec($Vec, 0, 32), 3135089835);
d33 3
a35 3
ok($foo eq "1" && $foo == 1);
ok($bar eq "2" && $bar == 2);
ok("$foo $bar $baz" eq "1 2 3");
d40 2
a41 2
like($@@, /^Illegal number of bits in vec/);
$@@ = undef;
d43 2
a44 2
like($@@, /^Illegal number of bits in vec/);
$@@ = undef;
d46 2
a47 2
like($@@, /^Illegal number of bits in vec/);
$@@ = undef;
d49 4
a52 3
like($@@, /^Illegal number of bits in vec/);
$@@ = undef;
ok(! vec('abcd', 7, 8));
d59 2
a60 2
is(vec($x, 0, 8), 255);
$@@ = undef;
d62 2
a63 2
ok(! $@@);
$@@ = undef;
d65 2
a66 1
ok(! $@@);
d68 2
a69 1
    is($foo, "\x8c\x0d\xff\x8a\x69"); 
d72 2
a73 1
    is($foo, "\xc4\x0d\xc3\xbf\xc3\xbe");
d78 2
a79 1
is($x, "\xff\xf7");
d84 2
a85 1
is(vec(substr($foo, 2, 2), 0, 16), 25444);
d87 2
a88 1
is($foo, "\x61\x62\x63\x34\x65\x66");
d97 2
a98 1
    ok(!(${ $r[0] } != 0 || ${ $r[1] } != 1)); 
@


1.1.1.8
log
@import perl 5.10.0 from CPAN
@
text
@d46 1
a46 1
like($@@, qr/^Illegal number of bits in vec/);
d49 1
a49 1
like($@@, qr/^Illegal number of bits in vec/);
d52 1
a52 1
like($@@, qr/^Illegal number of bits in vec/);
d55 1
a55 1
like($@@, qr/^Negative offset to vec in lvalue context/);
@


1.1.1.9
log
@Perl 5.12.2 from CPAN
@
text
@d14 1
a14 1
is(length($foo), undef);
@


1.1.1.10
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d9 1
a9 1
plan( tests => 32 );
a97 12


my $destroyed;
{ package Class; DESTROY { ++$destroyed; } }

$destroyed = 0;
{
    my $x = '';
    vec($x,0,1) = 0;
    $x = bless({}, 'Class');
}
is($destroyed, 1, 'Timely scalar destruction with lvalue vec');
@


1.1.1.11
log
@Import perl-5.20.1
@
text
@d9 1
a9 1
plan( tests => 35 );
a109 21

use constant roref => \1;
eval { for (roref) { vec($_,0,1) = 1 } };
like($@@, qr/^Modification of a read-only value attempted at /,
        'err msg when modifying read-only refs');


{
    # downgradeable utf8 strings should be downgraded before accessing
    # the byte string.
    # See the p5p thread with Message-ID:
    # <CAMx+QJ6SAv05nmpnc7bmp0Wo+sjcx=ssxCcE-P_PZ8HDuCQd9A@@mail.gmail.com>


    my $x = substr "\x{100}\xff\xfe", 1; # a utf8 string with all ords < 256
    my $v;
    $v = vec($x, 0, 8);
    is($v, 255, "downgraded utf8 try 1");
    $v = vec($x, 0, 8);
    is($v, 255, "downgraded utf8 try 2");
}
@


1.1.1.12
log
@Import perl-5.24.2
@
text
@d5 1
a5 2
    require './test.pl';
    set_up_inc('../lib');
d8 1
d11 1
d71 1
a71 1
if ($::IS_EBCDIC) {
@


