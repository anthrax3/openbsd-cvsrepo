head	1.2;
access;
symbols
	OPENBSD_6_1:1.2.0.2
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.3.0.10
	OPENBSD_6_0_BASE:1.1.1.3
	OPENBSD_5_9:1.1.1.3.0.4
	OPENBSD_5_9_BASE:1.1.1.3
	OPENBSD_5_8:1.1.1.3.0.6
	OPENBSD_5_8_BASE:1.1.1.3
	PERL_5_20_2:1.1.1.3
	OPENBSD_5_7:1.1.1.3.0.2
	OPENBSD_5_7_BASE:1.1.1.3
	PERL_5_20_1:1.1.1.3
	OPENBSD_5_6:1.1.1.2.0.26
	OPENBSD_5_6_BASE:1.1.1.2
	PERL_5_18_2:1.1.1.2
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.2.0.24
	OPENBSD_5_5_BASE:1.1.1.2
	OPENBSD_5_4:1.1.1.2.0.20
	OPENBSD_5_4_BASE:1.1.1.2
	PERL_5_16_3:1.1.1.2
	OPENBSD_5_3:1.1.1.2.0.18
	OPENBSD_5_3_BASE:1.1.1.2
	OPENBSD_5_2:1.1.1.2.0.16
	OPENBSD_5_2_BASE:1.1.1.2
	OPENBSD_5_1_BASE:1.1.1.2
	OPENBSD_5_1:1.1.1.2.0.14
	OPENBSD_5_0:1.1.1.2.0.12
	OPENBSD_5_0_BASE:1.1.1.2
	OPENBSD_4_9:1.1.1.2.0.10
	OPENBSD_4_9_BASE:1.1.1.2
	PERL_5_12_2:1.1.1.2
	OPENBSD_4_8:1.1.1.2.0.8
	OPENBSD_4_8_BASE:1.1.1.2
	OPENBSD_4_7:1.1.1.2.0.4
	OPENBSD_4_7_BASE:1.1.1.2
	PERL_5_10_1:1.1.1.2
	OPENBSD_4_6:1.1.1.2.0.6
	OPENBSD_4_6_BASE:1.1.1.2
	OPENBSD_4_5:1.1.1.2.0.2
	OPENBSD_4_5_BASE:1.1.1.2
	PERL_5_10_0:1.1.1.2
	OPENBSD_4_4:1.1.1.1.0.18
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.16
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.14
	OPENBSD_4_2_BASE:1.1.1.1
	OPENBSD_4_1:1.1.1.1.0.12
	OPENBSD_4_1_BASE:1.1.1.1
	OPENBSD_4_0:1.1.1.1.0.10
	OPENBSD_4_0_BASE:1.1.1.1
	PERL_5_8_8:1.1.1.1
	OPENBSD_3_9:1.1.1.1.0.8
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.6
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.4
	OPENBSD_3_7_BASE:1.1.1.1
	PERL_5_8_6:1.1.1.1
	OPENBSD_3_6:1.1.1.1.0.2
	OPENBSD_3_6_BASE:1.1.1.1
	PERL_5_8_5:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.32.20;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2004.08.09.17.48.36;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2004.08.09.17.48.36;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2008.09.29.17.19.02;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.11.17.20.53.18;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl -T
# tests whether tainting works with UTF-8

BEGIN {
    chdir 't' if -d 't';
    require './test.pl';
    set_up_inc('../lib');
}

use strict;
use Config;

# How to identify taint when you see it
sub any_tainted (@@) {
    not eval { join("",@@_), kill 0; 1 };
}
sub tainted ($) {
    any_tainted @@_;
}

plan(tests => 3*10 + 3*8 + 2*16 + 3);

my $arg = $ENV{PATH}; # a tainted value
use constant UTF8 => "\x{1234}";

*is_utf8 = \&utf8::is_utf8;

for my $ary ([ascii => 'perl'], [latin1 => "\xB6"], [utf8 => "\x{100}"]) {
    my $encode = $ary->[0];
    my $string = $ary->[1];

    my $taint = $arg; substr($taint, 0) = $ary->[1];

    is(tainted($taint), tainted($arg), "tainted: $encode, before test");

    my $lconcat = $taint;
       $lconcat .= UTF8;
    is($lconcat, $string.UTF8, "compare: $encode, concat left");

    is(tainted($lconcat), tainted($arg), "tainted: $encode, concat left");

    my $rconcat = UTF8;
       $rconcat .= $taint;
    is($rconcat, UTF8.$string, "compare: $encode, concat right");

    is(tainted($rconcat), tainted($arg), "tainted: $encode, concat right");

    my $ljoin = join('!', $taint, UTF8);
    is($ljoin, join('!', $string, UTF8), "compare: $encode, join left");

    is(tainted($ljoin), tainted($arg), "tainted: $encode, join left");

    my $rjoin = join('!', UTF8, $taint);
    is($rjoin, join('!', UTF8, $string), "compare: $encode, join right");

    is(tainted($rjoin), tainted($arg), "tainted: $encode, join right");

    is(tainted($taint), tainted($arg), "tainted: $encode, after test");
}


for my $ary ([ascii => 'perl'], [latin1 => "\xB6"], [utf8 => "\x{100}"]) {
    my $encode = $ary->[0];

    my $utf8 = pack('U*') . $ary->[1];
    my $byte = unpack('U0a*', $utf8);

    my $taint = $arg; substr($taint, 0) = $utf8;
    utf8::encode($taint);

    is($taint, $byte, "compare: $encode, encode utf8");

    is(pack('a*',$taint), pack('a*',$byte), "bytecmp: $encode, encode utf8");

    ok(!is_utf8($taint), "is_utf8: $encode, encode utf8");

    is(tainted($taint), tainted($arg), "tainted: $encode, encode utf8");

    my $taint = $arg; substr($taint, 0) = $byte;
    utf8::decode($taint);

    is($taint, $utf8, "compare: $encode, decode byte");

    is(pack('a*',$taint), pack('a*',$utf8), "bytecmp: $encode, decode byte");

    is(is_utf8($taint), ($encode ne 'ascii'), "is_utf8: $encode, decode byte");

    is(tainted($taint), tainted($arg), "tainted: $encode, decode byte");
}


for my $ary ([ascii => 'perl'], [latin1 => "\xB6"]) {
    my $encode = $ary->[0];

    my $up   = pack('U*') . $ary->[1];
    my $down = pack("a*", $ary->[1]);

    my $taint = $arg; substr($taint, 0) = $up;
    utf8::upgrade($taint);

    is($taint, $up, "compare: $encode, upgrade up");

    is(pack('a*',$taint), pack('a*',$up), "bytecmp: $encode, upgrade up");

    ok(is_utf8($taint), "is_utf8: $encode, upgrade up");

    is(tainted($taint), tainted($arg), "tainted: $encode, upgrade up");

    my $taint = $arg; substr($taint, 0) = $down;
    utf8::upgrade($taint);

    is($taint, $up, "compare: $encode, upgrade down");

    is(pack('a*',$taint), pack('a*',$up), "bytecmp: $encode, upgrade down");

    ok(is_utf8($taint), "is_utf8: $encode, upgrade down");

    is(tainted($taint), tainted($arg), "tainted: $encode, upgrade down");

    my $taint = $arg; substr($taint, 0) = $up;
    utf8::downgrade($taint);

    is($taint, $down, "compare: $encode, downgrade up");

    is(pack('a*',$taint), pack('a*',$down), "bytecmp: $encode, downgrade up");

    ok(!is_utf8($taint), "is_utf8: $encode, downgrade up");

    is(tainted($taint), tainted($arg), "tainted: $encode, downgrade up");

    my $taint = $arg; substr($taint, 0) = $down;
    utf8::downgrade($taint);

    is($taint, $down, "compare: $encode, downgrade down");

    is(pack('a*',$taint), pack('a*',$down), "bytecmp: $encode, downgrade down");

    ok(!is_utf8($taint), "is_utf8: $encode, downgrade down");

    is(tainted($taint), tainted($arg), "tainted: $encode, downgrade down");
}

SKIP: {
    if (is_miniperl()) {
        skip_if_miniperl("Unicode tables not built yet", 2)
            unless eval 'require "unicore/Heavy.pl"';
    }
    fresh_perl_is('$a = substr $^X, 0, 0; /\x{100}/i; /$a\x{100}/i || print q,ok,',
		  'ok', {switches => ["-T", "-l"]},
		  "matching a regexp is taint agnostic");

    fresh_perl_is('$a = substr $^X, 0, 0; /$a\x{100}/i || print q,ok,',
		  'ok', {switches => ["-T", "-l"]},
		  "therefore swash_init should be taint agnostic");
}

{
    # RT #122148: s///e on tainted utf8 strings got pos() messed up in 5.20

    my @@p;
    my $s = "\x{100}\x{100}\x{100}\x{100}". $^X;
    $s =~ s/\x{100}/push @@p, pos($s); "xxxx";/eg;
    is("@@p", "0 1 2 3", "RT #122148");
}
@


1.1
log
@Initial revision
@
text
@a4 4
    if ($ENV{PERL_CORE_MINITEST}) {
        print "1..0 # Skip: no dynamic loading on miniperl, no threads\n";
        exit 0;
    }
d6 2
a7 1
    @@INC = qw(../lib);
d13 6
a18 5
BEGIN {
    if ($Config{extensions} !~ m(\bList/Util\b)) {
        print "1..0 # Skip: no Scalar::Util module\n";
        exit 0;
    }
d21 1
a21 5
use Scalar::Util qw(tainted);

use Test;
plan tests => 3*10 + 3*8 + 2*16;
my $cnt = 0;
d26 1
a26 4
sub is_utf8 {
    my $s = shift;
    return 0xB6 != ord pack('a*', chr(0xB6).$s);
}
d34 1
a34 2
    print tainted($taint) == tainted($arg)
	? "ok " : "not ok ", ++$cnt, " # tainted: $encode, before test\n";
d38 1
a38 2
    print $lconcat eq $string.UTF8
	? "ok " : "not ok ", ++$cnt, " # compare: $encode, concat left\n";
d40 1
a40 2
    print tainted($lconcat) == tainted($arg)
	? "ok " : "not ok ", ++$cnt, " # tainted: $encode, concat left\n";
d44 1
a44 2
    print $rconcat eq UTF8.$string
	? "ok " : "not ok ", ++$cnt, " # compare: $encode, concat right\n";
d46 1
a46 2
    print tainted($rconcat) == tainted($arg)
	? "ok " : "not ok ", ++$cnt, " # tainted: $encode, concat right\n";
d49 1
a49 2
    print $ljoin eq join('!', $string, UTF8)
	? "ok " : "not ok ", ++$cnt, " # compare: $encode, join left\n";
d51 1
a51 2
    print tainted($ljoin) == tainted($arg)
	? "ok " : "not ok ", ++$cnt, " # tainted: $encode, join left\n";
d54 1
a54 2
    print $rjoin eq join('!', UTF8, $string)
	? "ok " : "not ok ", ++$cnt, " # compare: $encode, join right\n";
d56 1
a56 2
    print tainted($rjoin) == tainted($arg)
	? "ok " : "not ok ", ++$cnt, " # tainted: $encode, join right\n";
d58 1
a58 2
    print tainted($taint) == tainted($arg)
	? "ok " : "not ok ", ++$cnt, " # tainted: $encode, after test\n";
d66 1
a66 1
    my $byte = pack('C0a*', $utf8);
d71 1
a71 2
    print $taint eq $byte
	? "ok " : "not ok ", ++$cnt, " # compare: $encode, encode utf8\n";
d73 1
a73 2
    print pack('a*',$taint) eq pack('a*',$byte)
	? "ok " : "not ok ", ++$cnt, " # bytecmp: $encode, encode utf8\n";
d75 1
a75 2
    print !is_utf8($taint)
	? "ok " : "not ok ", ++$cnt, " # is_utf8: $encode, encode utf8\n";
d77 1
a77 2
    print tainted($taint) == tainted($arg)
	? "ok " : "not ok ", ++$cnt, " # tainted: $encode, encode utf8\n";
d82 1
a82 2
    print $taint eq $utf8
	? "ok " : "not ok ", ++$cnt, " # compare: $encode, decode byte\n";
d84 1
a84 2
    print pack('a*',$taint) eq pack('a*',$utf8)
	? "ok " : "not ok ", ++$cnt, " # bytecmp: $encode, decode byte\n";
d86 1
a86 2
    print is_utf8($taint) eq ($encode ne 'ascii')
	? "ok " : "not ok ", ++$cnt, " # is_utf8: $encode, decode byte\n";
d88 1
a88 2
    print tainted($taint) == tainted($arg)
	? "ok " : "not ok ", ++$cnt, " # tainted: $encode, decode byte\n";
d96 1
a96 1
    my $down = pack('C0a*', $ary->[1]);
d101 1
a101 2
    print $taint eq $up
	? "ok " : "not ok ", ++$cnt, " # compare: $encode, upgrade up\n";
d103 1
a103 2
    print pack('a*',$taint) eq pack('a*',$up)
	? "ok " : "not ok ", ++$cnt, " # bytecmp: $encode, upgrade up\n";
d105 1
a105 2
    print is_utf8($taint)
	? "ok " : "not ok ", ++$cnt, " # is_utf8: $encode, upgrade up\n";
d107 1
a107 2
    print tainted($taint) == tainted($arg)
	? "ok " : "not ok ", ++$cnt, " # tainted: $encode, upgrade up\n";
d112 1
a112 2
    print $taint eq $up
	? "ok " : "not ok ", ++$cnt, " # compare: $encode, upgrade down\n";
d114 1
a114 2
    print pack('a*',$taint) eq pack('a*',$up)
	? "ok " : "not ok ", ++$cnt, " # bytecmp: $encode, upgrade down\n";
d116 1
a116 2
    print is_utf8($taint)
	? "ok " : "not ok ", ++$cnt, " # is_utf8: $encode, upgrade down\n";
d118 1
a118 2
    print tainted($taint) == tainted($arg)
	? "ok " : "not ok ", ++$cnt, " # tainted: $encode, upgrade down\n";
d123 1
a123 2
    print $taint eq $down
	? "ok " : "not ok ", ++$cnt, " # compare: $encode, downgrade up\n";
d125 1
a125 2
    print pack('a*',$taint) eq pack('a*',$down)
	? "ok " : "not ok ", ++$cnt, " # bytecmp: $encode, downgrade up\n";
d127 1
a127 2
    print !is_utf8($taint)
	? "ok " : "not ok ", ++$cnt, " # is_utf8: $encode, downgrade up\n";
d129 1
a129 2
    print tainted($taint) == tainted($arg)
	? "ok " : "not ok ", ++$cnt, " # tainted: $encode, downgrade up\n";
d134 1
a134 2
    print $taint eq $down
	? "ok " : "not ok ", ++$cnt, " # compare: $encode, downgrade down\n";
d136 1
a136 2
    print pack('a*',$taint) eq pack('a*',$down)
	? "ok " : "not ok ", ++$cnt, " # bytecmp: $encode, downgrade down\n";
d138 1
a138 2
    print !is_utf8($taint)
	? "ok " : "not ok ", ++$cnt, " # is_utf8: $encode, downgrade down\n";
d140 1
a140 2
    print tainted($taint) == tainted($arg)
	? "ok " : "not ok ", ++$cnt, " # tainted: $encode, downgrade down\n";
d143 22
a164 1

@


1.1.1.1
log
@Import of stock perl 5.8.5
@
text
@@


1.1.1.2
log
@import perl 5.10.0 from CPAN
@
text
@d5 4
d16 5
a20 6
# How to identify taint when you see it
sub any_tainted (@@) {
    not eval { join("",@@_), kill 0; 1 };
}
sub tainted ($) {
    any_tainted @@_;
d23 5
a27 2
require './test.pl';
plan(tests => 3*10 + 3*8 + 2*16 + 2);
d32 4
a35 1
*is_utf8 = \&utf8::is_utf8;
d43 2
a44 1
    is(tainted($taint), tainted($arg), "tainted: $encode, before test");
d48 2
a49 1
    is($lconcat, $string.UTF8, "compare: $encode, concat left");
d51 2
a52 1
    is(tainted($lconcat), tainted($arg), "tainted: $encode, concat left");
d56 2
a57 1
    is($rconcat, UTF8.$string, "compare: $encode, concat right");
d59 2
a60 1
    is(tainted($rconcat), tainted($arg), "tainted: $encode, concat right");
d63 2
a64 1
    is($ljoin, join('!', $string, UTF8), "compare: $encode, join left");
d66 2
a67 1
    is(tainted($ljoin), tainted($arg), "tainted: $encode, join left");
d70 2
a71 1
    is($rjoin, join('!', UTF8, $string), "compare: $encode, join right");
d73 2
a74 1
    is(tainted($rjoin), tainted($arg), "tainted: $encode, join right");
d76 2
a77 1
    is(tainted($taint), tainted($arg), "tainted: $encode, after test");
d85 1
a85 1
    my $byte = unpack('U0a*', $utf8);
d90 2
a91 1
    is($taint, $byte, "compare: $encode, encode utf8");
d93 2
a94 1
    is(pack('a*',$taint), pack('a*',$byte), "bytecmp: $encode, encode utf8");
d96 2
a97 1
    ok(!is_utf8($taint), "is_utf8: $encode, encode utf8");
d99 2
a100 1
    is(tainted($taint), tainted($arg), "tainted: $encode, encode utf8");
d105 2
a106 1
    is($taint, $utf8, "compare: $encode, decode byte");
d108 2
a109 1
    is(pack('a*',$taint), pack('a*',$utf8), "bytecmp: $encode, decode byte");
d111 2
a112 1
    is(is_utf8($taint), ($encode ne 'ascii'), "is_utf8: $encode, decode byte");
d114 2
a115 1
    is(tainted($taint), tainted($arg), "tainted: $encode, decode byte");
d123 1
a123 1
    my $down = pack("a*", $ary->[1]);
d128 2
a129 1
    is($taint, $up, "compare: $encode, upgrade up");
d131 2
a132 1
    is(pack('a*',$taint), pack('a*',$up), "bytecmp: $encode, upgrade up");
d134 2
a135 1
    ok(is_utf8($taint), "is_utf8: $encode, upgrade up");
d137 2
a138 1
    is(tainted($taint), tainted($arg), "tainted: $encode, upgrade up");
d143 2
a144 1
    is($taint, $up, "compare: $encode, upgrade down");
d146 2
a147 1
    is(pack('a*',$taint), pack('a*',$up), "bytecmp: $encode, upgrade down");
d149 2
a150 1
    ok(is_utf8($taint), "is_utf8: $encode, upgrade down");
d152 2
a153 1
    is(tainted($taint), tainted($arg), "tainted: $encode, upgrade down");
d158 2
a159 1
    is($taint, $down, "compare: $encode, downgrade up");
d161 2
a162 1
    is(pack('a*',$taint), pack('a*',$down), "bytecmp: $encode, downgrade up");
d164 2
a165 1
    ok(!is_utf8($taint), "is_utf8: $encode, downgrade up");
d167 2
a168 1
    is(tainted($taint), tainted($arg), "tainted: $encode, downgrade up");
d173 2
a174 1
    is($taint, $down, "compare: $encode, downgrade down");
d176 2
a177 1
    is(pack('a*',$taint), pack('a*',$down), "bytecmp: $encode, downgrade down");
d179 2
a180 1
    ok(!is_utf8($taint), "is_utf8: $encode, downgrade down");
d182 2
a183 1
    is(tainted($taint), tainted($arg), "tainted: $encode, downgrade down");
a185 4
{
    fresh_perl_is('$a = substr $^X, 0, 0; /\x{100}/i; /$a\x{100}/i || print q,ok,',
		  'ok', {switches => ["-T", "-l"]},
		  "matching a regexp is taint agnostic");
a186 4
    fresh_perl_is('$a = substr $^X, 0, 0; /$a\x{100}/i || print q,ok,',
		  'ok', {switches => ["-T", "-l"]},
		  "therefore swash_init should be taint agnostic");
}
@


1.1.1.3
log
@Import perl-5.20.1
@
text
@d21 1
a21 1
plan(tests => 3*10 + 3*8 + 2*16 + 3);
a150 9
}

{
    # RT #122148: s///e on tainted utf8 strings got pos() messed up in 5.20

    my @@p;
    my $s = "\x{100}\x{100}\x{100}\x{100}". $^X;
    $s =~ s/\x{100}/push @@p, pos($s); "xxxx";/eg;
    is("@@p", "0 1 2 3", "RT #122148");
@


