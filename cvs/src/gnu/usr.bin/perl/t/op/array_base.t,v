head	1.2;
access;
symbols
	OPENBSD_6_1:1.2.0.2
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.2.0.16
	OPENBSD_6_0_BASE:1.1.1.2
	OPENBSD_5_9:1.1.1.2.0.10
	OPENBSD_5_9_BASE:1.1.1.2
	OPENBSD_5_8:1.1.1.2.0.12
	OPENBSD_5_8_BASE:1.1.1.2
	PERL_5_20_2:1.1.1.2
	OPENBSD_5_7:1.1.1.2.0.4
	OPENBSD_5_7_BASE:1.1.1.2
	PERL_5_20_1:1.1.1.2
	OPENBSD_5_6:1.1.1.2.0.8
	OPENBSD_5_6_BASE:1.1.1.2
	PERL_5_18_2:1.1.1.2
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.2.0.6
	OPENBSD_5_5_BASE:1.1.1.2
	OPENBSD_5_4:1.1.1.2.0.2
	OPENBSD_5_4_BASE:1.1.1.2
	PERL_5_16_3:1.1.1.2
	OPENBSD_5_3:1.1.1.1.0.10
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.8
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.6
	OPENBSD_5_0:1.1.1.1.0.4
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.2
	OPENBSD_4_9_BASE:1.1.1.1
	PERL_5_12_2:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.32.20;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2010.09.24.14.49.18;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.09.24.14.49.18;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.03.25.20.09.35;	author sthen;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!perl -w
use strict;

BEGIN {
 chdir 't' if -d 't';
 require './test.pl';

 plan (tests => my $tests = 11);

 # Run these at BEGIN time, before arybase loads
 use v5.15;
 is(eval('$[ = 1; 123'), undef);
 like($@@, qr/\AAssigning non-zero to \$\[ is no longer possible/);

 if (is_miniperl()) {
   # skip the rest
   SKIP: { skip ("no arybase.xs on miniperl", $tests-2) }
   exit;
 }
}

no warnings 'deprecated';

is(eval('$['), 0);
is(eval('$[ = 0; 123'), 123);
is(eval('$[ = 1; 123'), 123);
$[ = 1;
ok $INC{'arybase.pm'};

use v5.15;
is(eval('$[ = 1; 123'), undef);
like($@@, qr/\AAssigning non-zero to \$\[ is no longer possible/);
is $[, 0, '$[ is 0 under 5.16';
$_ = "hello";
/l/g;
my $pos = \pos;
is $$pos, 3;
$$pos = 1;
is $$pos, 1;

1;
@


1.1
log
@Initial revision
@
text
@d4 17
a20 1
require './test.pl';
a21 1
plan (tests => 24);
d24 16
a39 52
# Bug #27024
{
    # this used to segfault (because $[=1 is optimized away to a null block)
    my $x;
    $[ = 1 while $x;
    pass('#27204');
    $[ = 0; # restore the original value for less side-effects
}

# [perl #36313] perl -e "1for$[=0" crash
{
    my $x;
    $x = 1 for ($[) = 0;
    pass('optimized assignment to $[ used to segfault in list context');
    if ($[ = 0) { $x = 1 }
    pass('optimized assignment to $[ used to segfault in scalar context');
    $x = ($[=2.4);
    is($x, 2, 'scalar assignment to $[ behaves like other variables');
    $x = (($[) = 0);
    is($x, 1, 'list assignment to $[ behaves like other variables');
    $x = eval q{ ($[, $x) = (0) };
    like($@@, qr/That use of \$\[ is unsupported/,
             'cannot assign to $[ in a list');
    eval q{ ($[) = (0, 1) };
    like($@@, qr/That use of \$\[ is unsupported/,
             'cannot assign list of >1 elements to $[');
    eval q{ ($[) = () };
    like($@@, qr/That use of \$\[ is unsupported/,
             'cannot assign list of <1 elements to $[');
}


{
    $[ = 11;
    cmp_ok($[ + 0, '==', 11, 'setting $[ affects $[');
    our $t11; BEGIN { $t11 = $^H{'$['} }
    cmp_ok($t11, '==', 11, 'setting $[ affects $^H{\'$[\'}');

    BEGIN { $^H{'$['} = 22 }
    cmp_ok($[ + 0, '==', 22, 'setting $^H{\'$\'} affects $[');
    our $t22; BEGIN { $t22 = $^H{'$['} }
    cmp_ok($t22, '==', 22, 'setting $^H{\'$[\'} affects $^H{\'$[\'}');

    BEGIN { %^H = () }
    my $val = do {
	no warnings 'uninitialized';
	$[;
    };
    cmp_ok($val, '==', 0, 'clearing %^H affects $[');
    our $t0; BEGIN { $t0 = $^H{'$['} }
    cmp_ok($t0, '==', 0, 'clearing %^H affects $^H{\'$[\'}');
}
d41 1
a41 21
{
    $[ = 13;
    BEGIN { $^H |= 0x04000000; $^H{foo} = "z"; }

    our($ri0, $rf0); BEGIN { $ri0 = $^H; $rf0 = $^H{foo}; }
    cmp_ok($[ + 0, '==', 13, '$[ correct before require');
    ok($ri0 & 0x04000000, '$^H correct before require');
    is($rf0, "z", '$^H{foo} correct before require');

    our($ra1, $ri1, $rf1, $rfe1);
    BEGIN { require "op/array_base.aux"; }
    cmp_ok($ra1, '==', 0, '$[ cleared for require');
    ok(!($ri1 & 0x04000000), '$^H cleared for require');
    is($rf1, undef, '$^H{foo} cleared for require');
    ok(!$rfe1, '$^H{foo} cleared for require');

    our($ri2, $rf2); BEGIN { $ri2 = $^H; $rf2 = $^H{foo}; }
    cmp_ok($[ + 0, '==', 13, '$[ correct after require');
    ok($ri2 & 0x04000000, '$^H correct after require');
    is($rf2, "z", '$^H{foo} correct after require');
}
@


1.1.1.1
log
@Perl 5.12.2 from CPAN
@
text
@@


1.1.1.2
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d4 1
a4 2
BEGIN {
 require './test.pl';
d6 11
a16 1
 plan (tests => my $tests = 11);
d18 20
a37 10
 # Run these at BEGIN time, before arybase loads
 use v5.15;
 is(eval('$[ = 1; 123'), undef);
 like($@@, qr/\AAssigning non-zero to \$\[ is no longer possible/);

 if (is_miniperl()) {
   # skip the rest
   SKIP: { skip ("no arybase.xs on miniperl", $tests-2) }
   exit;
 }
a39 1
no warnings 'deprecated';
d41 20
a60 16
is(eval('$['), 0);
is(eval('$[ = 0; 123'), 123);
is(eval('$[ = 1; 123'), 123);
$[ = 1;
ok $INC{'arybase.pm'};

use v5.15;
is(eval('$[ = 1; 123'), undef);
like($@@, qr/\AAssigning non-zero to \$\[ is no longer possible/);
is $[, 0, '$[ is 0 under 5.16';
$_ = "hello";
/l/g;
my $pos = \pos;
is $$pos, 3;
$$pos = 1;
is $$pos, 1;
d62 21
a82 1
1;
@

