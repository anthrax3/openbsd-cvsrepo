head	1.12;
access;
symbols
	OPENBSD_6_1:1.12.0.8
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.12.0.10
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.12.0.4
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.12.0.6
	OPENBSD_5_8_BASE:1.12
	PERL_5_20_2:1.1.1.12
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	PERL_5_20_1:1.1.1.12
	OPENBSD_5_6:1.11.0.8
	OPENBSD_5_6_BASE:1.11
	PERL_5_18_2:1.1.1.11
	PERL:1.1.1
	OPENBSD_5_5:1.11.0.6
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.2
	OPENBSD_5_4_BASE:1.11
	PERL_5_16_3:1.1.1.11
	OPENBSD_5_3:1.10.0.10
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.8
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.6
	OPENBSD_5_0:1.10.0.4
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.2
	OPENBSD_4_9_BASE:1.10
	PERL_5_12_2:1.1.1.10
	OPENBSD_4_8:1.9.0.4
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.2
	OPENBSD_4_7_BASE:1.9
	PERL_5_10_1:1.1.1.9
	OPENBSD_4_6:1.8.0.6
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.2
	OPENBSD_4_5_BASE:1.8
	PERL_5_10_0:1.1.1.8
	OPENBSD_4_4:1.7.0.10
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.8
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.6
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.4
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.2
	OPENBSD_4_0_BASE:1.7
	PERL_5_8_8:1.1.1.7
	OPENBSD_3_9:1.6.0.10
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.8
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.6
	OPENBSD_3_7_BASE:1.6
	PERL_5_8_6:1.1.1.6
	OPENBSD_3_6:1.6.0.4
	OPENBSD_3_6_BASE:1.6
	PERL_5_8_5:1.1.1.6
	PERL_5_8_3:1.1.1.6
	OPENBSD_3_5:1.6.0.2
	OPENBSD_3_5_BASE:1.6
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.5.0.4
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.4.0.6
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.4
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.3.0.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.2.0.8
	OPENBSD_2_6_BASE:1.2
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.12
date	2014.11.17.20.57.07;	author afresh1;	state Exp;
branches;
next	1.11;
commitid	QP75iYx42Uo7mMxO;

1.11
date	2013.03.25.20.40.59;	author sthen;	state Exp;
branches;
next	1.10;

1.10
date	2010.09.24.15.07.09;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2009.10.12.18.30.27;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2008.09.29.17.36.20;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2006.03.28.19.23.13;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2003.12.03.03.02.49;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.10.27.22.25.37;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.24.18.36.21;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.06.17.08.30;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.08.05.38;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.13.21;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.13.21;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.41.49;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.10.50;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.25.45;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.15.11;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.44.32;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2006.03.28.18.49.46;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2008.09.29.17.19.01;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2009.10.12.18.10.45;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2010.09.24.14.49.17;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2013.03.25.20.09.36;	author sthen;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2014.11.17.20.53.18;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.12
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@#!./perl

BEGIN {
    chdir 't' if -d 't';
    @@INC = '../lib';
    require './test.pl';
}

use strict;
use warnings;
use vars qw($fh @@fh %fh);

eval 'opendir(NOSUCH, "no/such/directory");';
skip_all($@@) if $@@;

for my $i (1..2000) {
    local *OP;
    opendir(OP, "op") or die "can't opendir: $!";
    # should auto-closedir() here
}

is(opendir(OP, "op"), 1);
my @@D = grep(/^[^\.].*\.t$/i, readdir(OP));
closedir(OP);

my $expect;
{
    open my $man, '<', '../MANIFEST' or die "Can't open ../MANIFEST: $!";
    while (<$man>) {
	++$expect if m!^t/op/[^/]+\t!;
    }
}

my ($min, $max) = ($expect - 10, $expect + 10);
within(scalar @@D, $expect, 10, 'counting op/*.t');

my @@R = sort @@D;
my @@G = sort <op/*.t>;
if ($G[0] =~ m#.*\](\w+\.t)#i) {
    # grep is to convert filespecs returned from glob under VMS to format
    # identical to that returned by readdir
    @@G = grep(s#.*\](\w+\.t).*#op/$1#i,<op/*.t>);
}
while (@@R && @@G && $G[0] eq 'op/'.$R[0]) {
	shift(@@R);
	shift(@@G);
}
is(scalar @@R, 0, 'readdir results all accounted for');
is(scalar @@G, 0, 'glob results all accounted for');

is(opendir($fh, "op"), 1);
is(ref $fh, 'GLOB');
is(opendir($fh[0], "op"), 1);
is(ref $fh[0], 'GLOB');
is(opendir($fh{abc}, "op"), 1);
is(ref $fh{abc}, 'GLOB');
isnt("$fh", "$fh[0]");
isnt("$fh", "$fh{abc}");

# See that perl does not segfault upon readdir($x="."); 
# http://rt.perl.org/rt3/Ticket/Display.html?id=68182
fresh_perl_like(<<'EOP', qr/^no crash/, {}, 'RT #68182');
  eval {
    my $x = ".";
    my @@files = readdir($x);
  };
  print "no crash";
EOP

SKIP:
{ # [perl #118651]
  # test that readdir doesn't modify errno on successfully reaching the end of the list
  # in scalar context, POSIX requires that readdir() not modify errno on end-of-directory
  my @@s;
  ok(opendir(OP, "op"), "opendir op");
  $! = 0;
  while (defined(my $f = readdir OP)) {
    push @@s, $f
      if $f =~ /^[^\.].*\.t$/i;
  }
  my $errno = $! + 0;
  closedir OP;
  is(@@s, @@D, "should be the same number of files, scalar or list")
    or skip "mismatch on file count - presumably a readdir error", 1;
  is($errno, 0, "errno preserved");
}

done_testing();
@


1.11
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d70 18
@


1.10
log
@merge in perl 5.12.2 plus local changes
@
text
@d6 1
d9 4
d14 1
a14 3
if ($@@) { print "1..0\n"; exit; }

print "1..12\n";
d16 1
a16 1
for $i (1..2000) {
d22 2
a23 2
if (opendir(OP, "op")) { print "ok 1\n"; } else { print "not ok 1\n"; }
@@D = grep(/^[^\.].*\.t$/i, readdir(OP));
a25 1
open $man, "<../MANIFEST" or die "Can't open ../MANIFEST: $!";
d27 5
a31 2
while (<$man>) {
    ++$expect if m!^t/op/[^/]+\t!;
d33 1
d35 1
a35 5
if (@@D > $min && @@D < $max) { print "ok 2\n"; }
else {
    printf "not ok 2 # counting op/*.t, expect $min < %d < $max files\n",
      scalar @@D;
}
d37 2
a38 2
@@R = sort @@D;
@@G = sort <op/*.t>;
d48 11
a58 1
if (@@R == 0 && @@G == 0) { print "ok 3\n"; } else { print "not ok 3\n"; }
a59 8
if (opendir($fh, "op")) { print "ok 4\n"; } else { print "not ok 4\n"; }
if (ref($fh) eq 'GLOB') { print "ok 5\n"; } else { print "not ok 5\n"; }
if (opendir($fh[0], "op")) { print "ok 6\n"; } else { print "not ok 6\n"; }
if (ref($fh[0]) eq 'GLOB') { print "ok 7\n"; } else { print "not ok 7\n"; }
if (opendir($fh{abc}, "op")) { print "ok 8\n"; } else { print "not ok 8\n"; }
if (ref($fh{abc}) eq 'GLOB') { print "ok 9\n"; } else { print "not ok 9\n"; }
if ("$fh" ne "$fh[0]") { print "ok 10\n"; } else { print "not ok 10\n"; }
if ("$fh" ne "$fh{abc}") { print "ok 11\n"; } else { print "not ok 11\n"; }
d62 2
a63 1
eval {
d66 5
a70 2
};
print "ok 12\n";
@


1.9
log
@Merge in perl 5.10.1; part two
@
text
@d11 1
a11 1
print "1..11\n";
a36 1
@@G = sort <:op:*.t> if $^O eq 'MacOS';
d42 1
a42 1
while (@@R && @@G && $G[0] eq ($^O eq 'MacOS' ? ':op:' : 'op/').$R[0]) {
d56 7
@


1.8
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d23 6
a28 5
##
## This range will have to adjust as the number of tests expands,
## as it's counting the number of .t files in src/t
##
my ($min, $max) = (150, 170);
@


1.7
log
@merge in perl 5.8.8
@
text
@d27 1
a27 1
my ($min, $max) = (125, 145);
@


1.6
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d27 1
a27 1
my ($min, $max) = (115, 135);
@


1.5
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d11 1
a11 1
print "1..3\n";
d47 9
@


1.4
log
@merge in perl 5.6.1 with our local changes
@
text
@d27 6
a32 1
if (@@D > 90 && @@D < 110) { print "ok 2\n"; } else { print "not ok 2\n"; }
d36 1
d42 1
a42 1
while (@@R && @@G && "op/".$R[0] eq $G[0]) {
@


1.3
log
@perl-5.6.0 + local changes
@
text
@d5 1
a5 1
    unshift @@INC, '../lib';
d23 5
a27 1
if (@@D > 20 && @@D < 100) { print "ok 2\n"; } else { print "not ok 2\n"; }
@


1.2
log
@perl 5.004_04
@
text
@d3 5
d12 6
@


1.1
log
@Initial revision
@
text
@d15 1
a15 1
@@G = <op/*.t>;
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d15 1
a15 1
@@G = sort <op/*.t>;
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@a2 5
BEGIN {
    chdir 't' if -d 't';
    unshift @@INC, '../lib';
}

a6 6

for $i (1..2000) {
    local *OP;
    opendir(OP, "op") or die "can't opendir: $!";
    # should auto-closedir() here
}
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d5 1
a5 1
    @@INC = '../lib';
d23 1
a23 5
##
## This range will have to adjust as the number of tests expands,
## as it's counting the number of .t files in src/t
##
if (@@D > 90 && @@D < 110) { print "ok 2\n"; } else { print "not ok 2\n"; }
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d27 1
a27 6
my ($min, $max) = (115, 135);
if (@@D > $min && @@D < $max) { print "ok 2\n"; }
else {
    printf "not ok 2 # counting op/*.t, expect $min < %d < $max files\n",
      scalar @@D;
}
a30 1
@@G = sort <:op:*.t> if $^O eq 'MacOS';
d36 1
a36 1
while (@@R && @@G && $G[0] eq ($^O eq 'MacOS' ? ':op:' : 'op/').$R[0]) {
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@d11 1
a11 1
print "1..11\n";
a46 9

if (opendir($fh, "op")) { print "ok 4\n"; } else { print "not ok 4\n"; }
if (ref($fh) eq 'GLOB') { print "ok 5\n"; } else { print "not ok 5\n"; }
if (opendir($fh[0], "op")) { print "ok 6\n"; } else { print "not ok 6\n"; }
if (ref($fh[0]) eq 'GLOB') { print "ok 7\n"; } else { print "not ok 7\n"; }
if (opendir($fh{abc}, "op")) { print "ok 8\n"; } else { print "not ok 8\n"; }
if (ref($fh{abc}) eq 'GLOB') { print "ok 9\n"; } else { print "not ok 9\n"; }
if ("$fh" ne "$fh[0]") { print "ok 10\n"; } else { print "not ok 10\n"; }
if ("$fh" ne "$fh{abc}") { print "ok 11\n"; } else { print "not ok 11\n"; }
@


1.1.1.7
log
@perl 5.8.8 import
@
text
@d27 1
a27 1
my ($min, $max) = (125, 145);
@


1.1.1.8
log
@import perl 5.10.0 from CPAN
@
text
@d27 1
a27 1
my ($min, $max) = (150, 170);
@


1.1.1.9
log
@import perl 5.10.1
@
text
@d23 5
a27 6
open $man, "<../MANIFEST" or die "Can't open ../MANIFEST: $!";
my $expect;
while (<$man>) {
    ++$expect if m!^t/op/[^/]+\t!;
}
my ($min, $max) = ($expect - 10, $expect + 10);
@


1.1.1.10
log
@Perl 5.12.2 from CPAN
@
text
@d11 1
a11 1
print "1..12\n";
d37 1
d43 1
a43 1
while (@@R && @@G && $G[0] eq 'op/'.$R[0]) {
a56 7
# See that perl does not segfault upon readdir($x="."); 
# http://rt.perl.org/rt3/Ticket/Display.html?id=68182
eval {
    my $x = ".";
    my @@files = readdir($x);
};
print "ok 12\n";
@


1.1.1.11
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@a5 1
    require './test.pl';
d8 2
a9 3
use strict;
use warnings;
use vars qw($fh @@fh %fh);
d11 1
a11 2
eval 'opendir(NOSUCH, "no/such/directory");';
skip_all($@@) if $@@;
d13 1
a13 1
for my $i (1..2000) {
d19 2
a20 2
is(opendir(OP, "op"), 1);
my @@D = grep(/^[^\.].*\.t$/i, readdir(OP));
d23 1
d25 2
a26 5
{
    open my $man, '<', '../MANIFEST' or die "Can't open ../MANIFEST: $!";
    while (<$man>) {
	++$expect if m!^t/op/[^/]+\t!;
    }
a27 1

d29 5
a33 1
within(scalar @@D, $expect, 10, 'counting op/*.t');
d35 2
a36 2
my @@R = sort @@D;
my @@G = sort <op/*.t>;
d46 1
a46 11
is(scalar @@R, 0, 'readdir results all accounted for');
is(scalar @@G, 0, 'glob results all accounted for');

is(opendir($fh, "op"), 1);
is(ref $fh, 'GLOB');
is(opendir($fh[0], "op"), 1);
is(ref $fh[0], 'GLOB');
is(opendir($fh{abc}, "op"), 1);
is(ref $fh{abc}, 'GLOB');
isnt("$fh", "$fh[0]");
isnt("$fh", "$fh{abc}");
d48 8
d58 1
a58 2
fresh_perl_like(<<'EOP', qr/^no crash/, {}, 'RT #68182');
  eval {
d61 2
a62 5
  };
  print "no crash";
EOP

done_testing();
@


1.1.1.12
log
@Import perl-5.20.1
@
text
@a69 18
SKIP:
{ # [perl #118651]
  # test that readdir doesn't modify errno on successfully reaching the end of the list
  # in scalar context, POSIX requires that readdir() not modify errno on end-of-directory
  my @@s;
  ok(opendir(OP, "op"), "opendir op");
  $! = 0;
  while (defined(my $f = readdir OP)) {
    push @@s, $f
      if $f =~ /^[^\.].*\.t$/i;
  }
  my $errno = $! + 0;
  closedir OP;
  is(@@s, @@D, "should be the same number of files, scalar or list")
    or skip "mismatch on file count - presumably a readdir error", 1;
  is($errno, 0, "errno preserved");
}

@


