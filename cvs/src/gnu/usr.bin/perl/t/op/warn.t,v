head	1.2;
access;
symbols
	OPENBSD_6_0:1.1.1.3.0.10
	OPENBSD_6_0_BASE:1.1.1.3
	OPENBSD_5_9:1.1.1.3.0.4
	OPENBSD_5_9_BASE:1.1.1.3
	OPENBSD_5_8:1.1.1.3.0.6
	OPENBSD_5_8_BASE:1.1.1.3
	PERL_5_20_2:1.1.1.3
	OPENBSD_5_7:1.1.1.3.0.2
	OPENBSD_5_7_BASE:1.1.1.3
	PERL_5_20_1:1.1.1.3
	OPENBSD_5_6:1.1.1.2.0.4
	OPENBSD_5_6_BASE:1.1.1.2
	PERL_5_18_2:1.1.1.2
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.1.0.6
	OPENBSD_5_5_BASE:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.2
	OPENBSD_5_4_BASE:1.1.1.1
	PERL_5_16_3:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.32.20;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2013.03.25.20.09.37;	author sthen;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2013.03.25.20.09.37;	author sthen;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2014.03.24.14.59.11;	author afresh1;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.11.17.20.53.18;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl
#line 3 warn.t

BEGIN {
    chdir 't' if -d 't';
    require './test.pl'; require './charset_tools.pl';
    set_up_inc('../lib');
}

plan 32;

my @@warnings;
my $wa = []; my $ea = [];
$SIG{__WARN__} = sub { push @@warnings, $_[0] };

@@warnings = ();
$@@ = "";
warn "foo\n";
ok @@warnings==1 && $warnings[0] eq "foo\n";

@@warnings = ();
$@@ = "";
warn "foo", "bar\n";
ok @@warnings==1 && $warnings[0] eq "foobar\n";

@@warnings = ();
$@@ = "";
warn "foo";
ok @@warnings==1 && $warnings[0] eq "foo at warn.t line 28.\n";

@@warnings = ();
$@@ = "";
warn $wa;
ok @@warnings==1 && ref($warnings[0]) eq "ARRAY" && $warnings[0] == $wa;

@@warnings = ();
$@@ = "";
warn "";
ok @@warnings==1 &&
    $warnings[0] eq "Warning: something's wrong at warn.t line 38.\n";

@@warnings = ();
$@@ = "";
warn;
ok @@warnings==1 &&
    $warnings[0] eq "Warning: something's wrong at warn.t line 44.\n";

@@warnings = ();
$@@ = "ERR\n";
warn "foo\n";
ok @@warnings==1 && $warnings[0] eq "foo\n";

@@warnings = ();
$@@ = "ERR\n";
warn "foo", "bar\n";
ok @@warnings==1 && $warnings[0] eq "foobar\n";

@@warnings = ();
$@@ = "ERR\n";
warn "foo";
ok @@warnings==1 && $warnings[0] eq "foo at warn.t line 60.\n";

@@warnings = ();
$@@ = "ERR\n";
warn $wa;
ok @@warnings==1 && ref($warnings[0]) eq "ARRAY" && $warnings[0] == $wa;

@@warnings = ();
$@@ = "ERR\n";
warn "";
ok @@warnings==1 &&
    $warnings[0] eq "ERR\n\t...caught at warn.t line 70.\n";

@@warnings = ();
$@@ = "ERR\n";
warn;
ok @@warnings==1 &&
    $warnings[0] eq "ERR\n\t...caught at warn.t line 76.\n";

@@warnings = ();
$@@ = $ea;
warn "foo\n";
ok @@warnings==1 && $warnings[0] eq "foo\n";

@@warnings = ();
$@@ = $ea;
warn "foo", "bar\n";
ok @@warnings==1 && $warnings[0] eq "foobar\n";

@@warnings = ();
$@@ = $ea;
warn "foo";
ok @@warnings==1 && $warnings[0] eq "foo at warn.t line 92.\n";

@@warnings = ();
$@@ = $ea;
warn $wa;
ok @@warnings==1 && ref($warnings[0]) eq "ARRAY" && $warnings[0] == $wa;

@@warnings = ();
$@@ = $ea;
warn "";
ok @@warnings==1 && ref($warnings[0]) eq "ARRAY" && $warnings[0] == $ea;

@@warnings = ();
$@@ = $ea;
warn;
ok @@warnings==1 && ref($warnings[0]) eq "ARRAY" && $warnings[0] == $ea;

fresh_perl_like(
 '
   $a = "\xee\n";
   print STDERR $a; warn $a;
   utf8::upgrade($a);
   print STDERR $a; warn $a;
 ',
  qr/^\xee(?:\r?\n\xee){3}/,
  { switches => [ "-C0" ] },
 'warn emits logical characters, not internal bytes [perl #45549]'  
);

SKIP: {
    skip_if_miniperl('miniperl ignores -C', 1);
   $ee = uni_to_native("\xee");
   $bytes = byte_utf8a_to_utf8n("\xc3\xae");
fresh_perl_like(
 "
   \$a = \"$ee\n\";
   print STDERR \$a; warn \$a;
   utf8::upgrade(\$a);
   print STDERR \$a; warn \$a;
 ",
  qr/^$bytes(?:\r?\n$bytes){3}/,
  { switches => ['-CE'] },
 'warn respects :utf8 layer'
);
}

$bytes = byte_utf8a_to_utf8n("\xc4\xac");
fresh_perl_like(
 'warn chr 300',
  qr/^Wide character in warn .*\n$bytes at /,
  { switches => [ "-C0" ] },
 'Wide character in warn (not print)'
);

fresh_perl_like(
 'warn []',
  qr/^ARRAY\(0x[\da-f]+\) at /a,
  { },
 'warn stringifies in the absence of $SIG{__WARN__}'
);

use Tie::Scalar;
tie $@@, "Tie::StdScalar";

$@@ = "foo\n";
@@warnings = ();
warn;
is @@warnings, 1;
like $warnings[0], qr/^foo\n\t\.\.\.caught at warn\.t /,
    '...caught is appended to tied $@@';

$@@ = \$_;
@@warnings = ();
{
  local *{ref(tied $@@) . "::STORE"} = sub {};
  undef $@@;
}
warn;
is @@warnings, 1;
is $warnings[0], \$_, '!SvOK tied $@@ that returns ref is used';

untie $@@;

@@warnings = ();
{
  package o;
  use overload '""' => sub { "" };
}
tie $t, Tie::StdScalar;
$t = bless [], o;
{
  local *{ref(tied $t) . "::STORE"} = sub {};
  undef $t;
}
warn $t;
is @@warnings, 1;
object_ok $warnings[0], 'o',
  'warn $tie_returning_object_that_stringifes_emptily';

@@warnings = ();
eval "#line 42 Cholmondeley\n \$\@@ = '3'; warn";
eval "#line 42 Cholmondeley\n \$\@@ = 3; warn";
is @@warnings, 2;
is $warnings[1], $warnings[0], 'warn treats $@@=3 and $@@="3" the same way';

fresh_perl_is(<<'EOF', "should be line 4 at - line 4.\n", {stderr => 1}, "");
${
    foo
} = "should be line 4";
warn $foo;
EOF

TODO: {
    local $::TODO = "Line numbers don't yet match up for \${ EXPR }";
    my $expected = <<'EOF';
line 1 at - line 1.
line 4 at - line 3.
also line 4 at - line 4.
line 5 at - line 5.
EOF
    fresh_perl_is(<<'EOF', $expected, {stderr => 1}, "");
warn "line 1";
(${
    foo
} = "line 5") && warn("line 4"); warn("also line 4");
warn $foo;
EOF
}

1;
@


1.1
log
@Initial revision
@
text
@d6 2
a7 2
    @@INC = '../lib';
    require './test.pl';
d10 1
a10 1
plan 22;
d124 2
d127 7
a133 7
 '
   $a = "\xee\n";
   print STDERR $a; warn $a;
   utf8::upgrade($a);
   print STDERR $a; warn $a;
 ',
  qr/^\xc3\xae(?:\r?\n\xc3\xae){3}/,
d139 1
d142 1
a142 1
  qr/^Wide character in warn .*\n\xc4\xac at /,
d153 68
@


1.1.1.1
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@@


1.1.1.2
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d10 1
a10 1
plan 30;
a149 44

use Tie::Scalar;
tie $@@, "Tie::StdScalar";

$@@ = "foo\n";
@@warnings = ();
warn;
is @@warnings, 1;
like $warnings[0], qr/^foo\n\t\.\.\.caught at warn\.t /,
    '...caught is appended to tied $@@';

$@@ = \$_;
@@warnings = ();
{
  local *{ref(tied $@@) . "::STORE"} = sub {};
  undef $@@;
}
warn;
is @@warnings, 1;
is $warnings[0], \$_, '!SvOK tied $@@ that returns ref is used';

untie $@@;

@@warnings = ();
{
  package o;
  use overload '""' => sub { "" };
}
tie $t, Tie::StdScalar;
$t = bless [], o;
{
  local *{ref(tied $t) . "::STORE"} = sub {};
  undef $t;
}
warn $t;
is @@warnings, 1;
object_ok $warnings[0], 'o',
  'warn $tie_returning_object_that_stringifes_emptily';

@@warnings = ();
eval "#line 42 Cholmondeley\n \$\@@ = '3'; warn";
eval "#line 42 Cholmondeley\n \$\@@ = 3; warn";
is @@warnings, 2;
is $warnings[1], $warnings[0], 'warn treats $@@=3 and $@@="3" the same way';
@


1.1.1.3
log
@Import perl-5.20.1
@
text
@d10 1
a10 1
plan 32;
a193 24

fresh_perl_is(<<'EOF', "should be line 4 at - line 4.\n", {stderr => 1}, "");
${
    foo
} = "should be line 4";
warn $foo;
EOF

TODO: {
    local $::TODO = "Line numbers don't yet match up for \${ EXPR }";
    my $expected = <<'EOF';
line 1 at - line 1.
line 4 at - line 3.
also line 4 at - line 4.
line 5 at - line 5.
EOF
    fresh_perl_is(<<'EOF', $expected, {stderr => 1}, "");
warn "line 1";
(${
    foo
} = "line 5") && warn("line 4"); warn("also line 4");
warn $foo;
EOF
}
@


