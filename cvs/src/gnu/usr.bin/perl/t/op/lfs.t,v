head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2_BASE:1.1.1.9
	PERL_5_24_2:1.1.1.9
	OPENBSD_6_1:1.1.1.9.0.12
	OPENBSD_6_1_BASE:1.1.1.9
	OPENBSD_6_0:1.1.1.9.0.10
	OPENBSD_6_0_BASE:1.1.1.9
	OPENBSD_5_9:1.1.1.9.0.4
	OPENBSD_5_9_BASE:1.1.1.9
	OPENBSD_5_8:1.1.1.9.0.6
	OPENBSD_5_8_BASE:1.1.1.9
	PERL_5_20_2:1.1.1.9
	OPENBSD_5_7:1.1.1.9.0.2
	OPENBSD_5_7_BASE:1.1.1.9
	PERL_5_20_1:1.1.1.9
	OPENBSD_5_6:1.1.1.8.0.8
	OPENBSD_5_6_BASE:1.1.1.8
	PERL_5_18_2:1.1.1.8
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.8.0.6
	OPENBSD_5_5_BASE:1.1.1.8
	OPENBSD_5_4:1.1.1.8.0.2
	OPENBSD_5_4_BASE:1.1.1.8
	PERL_5_16_3:1.1.1.8
	OPENBSD_5_3:1.1.1.7.0.10
	OPENBSD_5_3_BASE:1.1.1.7
	OPENBSD_5_2:1.1.1.7.0.8
	OPENBSD_5_2_BASE:1.1.1.7
	OPENBSD_5_1_BASE:1.1.1.7
	OPENBSD_5_1:1.1.1.7.0.6
	OPENBSD_5_0:1.1.1.7.0.4
	OPENBSD_5_0_BASE:1.1.1.7
	OPENBSD_4_9:1.1.1.7.0.2
	OPENBSD_4_9_BASE:1.1.1.7
	PERL_5_12_2:1.1.1.7
	OPENBSD_4_8:1.1.1.6.0.4
	OPENBSD_4_8_BASE:1.1.1.6
	OPENBSD_4_7:1.1.1.6.0.2
	OPENBSD_4_7_BASE:1.1.1.6
	PERL_5_10_1:1.1.1.6
	OPENBSD_4_6:1.1.1.5.0.16
	OPENBSD_4_6_BASE:1.1.1.5
	OPENBSD_4_5:1.1.1.5.0.12
	OPENBSD_4_5_BASE:1.1.1.5
	PERL_5_10_0:1.1.1.5
	OPENBSD_4_4:1.1.1.5.0.10
	OPENBSD_4_4_BASE:1.1.1.5
	OPENBSD_4_3:1.1.1.5.0.8
	OPENBSD_4_3_BASE:1.1.1.5
	OPENBSD_4_2:1.1.1.5.0.6
	OPENBSD_4_2_BASE:1.1.1.5
	OPENBSD_4_1:1.1.1.5.0.4
	OPENBSD_4_1_BASE:1.1.1.5
	OPENBSD_4_0:1.1.1.5.0.2
	OPENBSD_4_0_BASE:1.1.1.5
	PERL_5_8_8:1.1.1.5
	OPENBSD_3_9:1.1.1.4.0.10
	OPENBSD_3_9_BASE:1.1.1.4
	OPENBSD_3_8:1.1.1.4.0.8
	OPENBSD_3_8_BASE:1.1.1.4
	OPENBSD_3_7:1.1.1.4.0.6
	OPENBSD_3_7_BASE:1.1.1.4
	PERL_5_8_6:1.1.1.4
	OPENBSD_3_6:1.1.1.4.0.4
	OPENBSD_3_6_BASE:1.1.1.4
	PERL_5_8_5:1.1.1.4
	PERL_5_8_3:1.1.1.4
	OPENBSD_3_5:1.1.1.4.0.2
	OPENBSD_3_5_BASE:1.1.1.4
	PERL_5_8_2:1.1.1.4
	OPENBSD_3_4:1.1.1.3.0.4
	OPENBSD_3_4_BASE:1.1.1.3
	OPENBSD_3_3:1.1.1.3.0.2
	OPENBSD_3_3_BASE:1.1.1.3
	PERL_5_8_0:1.1.1.3
	OPENBSD_3_2:1.1.1.2.0.6
	OPENBSD_3_2_BASE:1.1.1.2
	OPENBSD_3_1:1.1.1.2.0.4
	OPENBSD_3_1_BASE:1.1.1.2
	OPENBSD_3_0:1.1.1.2.0.2
	OPENBSD_3_0_BASE:1.1.1.2
	PERL_5_6_1:1.1.1.2
	OPENBSD_2_9:1.1.1.1.0.6
	OPENBSD_2_9_BASE:1.1.1.1
	OPENBSD_2_8:1.1.1.1.0.4
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.2
	OPENBSD_2_7_BASE:1.1.1.1
	PERL_5_6_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.1
date	2000.04.06.16.10.49;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.04.06.16.10.49;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.05.24.18.25.39;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.10.27.22.15.10;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.12.03.02.44.32;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2006.03.28.18.49.45;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2009.10.12.18.10.45;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2010.09.24.14.49.17;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2013.03.25.20.09.36;	author sthen;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2014.11.17.20.53.18;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.1
log
@Initial revision
@
text
@# NOTE: this file tests how large files (>2GB) work with perlio (stdio/sfio).
# sysopen(), sysseek(), syswrite(), sysread() are tested in t/lib/syslfs.t.
# If you modify/add tests here, remember to update also t/lib/syslfs.t.

BEGIN {
	chdir 't' if -d 't';
	unshift @@INC, '../lib';
	# Don't bother if there are no quad offsets.
	require Config; import Config;
	if ($Config{lseeksize} < 8) {
		print "1..0\n# no 64-bit file offsets\n";
		exit(0);
	}
}

sub zap {
    close(BIG);
    unlink("big");
    unlink("big1");
    unlink("big2");
}

sub bye {
    zap();	
    exit(0);
}

sub explain {
    print <<EOM;
#
# If the lfs (large file support: large meaning larger than two gigabytes)
# tests are skipped or fail, it may mean either that your process
# (or process group) is not allowed to write large files (resource
# limits) or that the file system you are running the tests on doesn't
# let your user/group have large files (quota) or the filesystem simply
# doesn't support large files.  You may even need to reconfigure your kernel.
# (This is all very operating system and site-dependent.)
#
# Perl may still be able to support large files, once you have
# such a process, enough quota, and such a (file) system.
#
EOM
}

print "# checking whether we have sparse files...\n";

# Known have-nots.
if ($^O eq 'win32' || $^O eq 'vms') {
    print "1..0\n# no sparse files (because this is $^O) \n";
    bye();
}

# Known haves that have problems running this test
# (for example because they do not support sparse files, like UNICOS)
if ($^O eq 'unicos') {
    print "1..0\n# large files known to work but unable to test them here ($^O)\n";
    bye();
}

# Then try to heuristically deduce whether we have sparse files.

# Let's not depend on Fcntl or any other extension.

my ($SEEK_SET, $SEEK_CUR, $SEEK_END) = (0, 1, 2);

# We'll start off by creating a one megabyte file which has
# only three "true" bytes.  If we have sparseness, we should
# consume less blocks than one megabyte (assuming nobody has
# one megabyte blocks...)

open(BIG, ">big1") or
    do { warn "open big1 failed: $!\n"; bye };
binmode(BIG) or
    do { warn "binmode big1 failed: $!\n"; bye };
seek(BIG, 1_000_000, $SEEK_SET) or
    do { warn "seek big1 failed: $!\n"; bye };
print BIG "big" or
    do { warn "print big1 failed: $!\n"; bye };
close(BIG) or
    do { warn "close big1 failed: $!\n"; bye };

my @@s1 = stat("big1");

print "# s1 = @@s1\n";

open(BIG, ">big2") or
    do { warn "open big2 failed: $!\n"; bye };
binmode(BIG) or
    do { warn "binmode big2 failed: $!\n"; bye };
seek(BIG, 2_000_000, $SEEK_SET) or
    do { warn "seek big2 failed; $!\n"; bye };
print BIG "big" or
    do { warn "print big2 failed; $!\n"; bye };
close(BIG) or
    do { warn "close big2 failed; $!\n"; bye };

my @@s2 = stat("big2");

print "# s2 = @@s2\n";

zap();

unless ($s1[7] == 1_000_003 && $s2[7] == 2_000_003 &&
	$s1[11] == $s2[11] && $s1[12] == $s2[12]) {
	print "1..0\n#no sparse files?\n";
	bye;
}

print "# we seem to have sparse files...\n";

# By now we better be sure that we do have sparse files:
# if we are not, the following will hog 5 gigabytes of disk.  Ooops.

$ENV{LC_ALL} = "C";

open(BIG, ">big") or do { warn "open failed: $!\n"; bye };
binmode BIG;
unless (seek(BIG, 5_000_000_000, $SEEK_SET)) {
    print "1..0\n# seeking past 2GB failed: $!\n";
    explain();
    bye();
}

# Either the print or (more likely, thanks to buffering) the close will
# fail if there are are filesize limitations (process or fs).
my $print = print BIG "big";
print "# print failed: $!\n" unless $print;
my $close = close BIG;
print "# close failed: $!\n" unless $close;
unless ($print && $close) {
    if ($! =~/too large/i) {
	print "1..0\n# writing past 2GB failed: process limits?\n";
    } elsif ($! =~ /quota/i) {
	print "1..0\n# filesystem quota limits?\n";
    }
    explain();
    bye();
}

@@s = stat("big");

print "# @@s\n";

unless ($s[7] == 5_000_000_003) {
    print "1..0\n# not configured to use large files?\n";
    explain();
    bye();
}

sub fail () {
    print "not ";
    $fail++;
}

print "1..17\n";

my $fail = 0;

fail unless $s[7] == 5_000_000_003;	# exercizes pp_stat
print "ok 1\n";

fail unless -s "big" == 5_000_000_003;	# exercizes pp_ftsize
print "ok 2\n";

fail unless -e "big";
print "ok 3\n";

fail unless -f "big";
print "ok 4\n";

open(BIG, "big") or do { warn "open failed: $!\n"; bye };
binmode BIG;

fail unless seek(BIG, 4_500_000_000, $SEEK_SET);
print "ok 5\n";

fail unless tell(BIG) == 4_500_000_000;
print "ok 6\n";

fail unless seek(BIG, 1, $SEEK_CUR);
print "ok 7\n";

fail unless tell(BIG) == 4_500_000_001;
print "ok 8\n";

fail unless seek(BIG, -1, $SEEK_CUR);
print "ok 9\n";

fail unless tell(BIG) == 4_500_000_000;
print "ok 10\n";

fail unless seek(BIG, -3, $SEEK_END);
print "ok 11\n";

fail unless tell(BIG) == 5_000_000_000;
print "ok 12\n";

my $big;

fail unless read(BIG, $big, 3) == 3;
print "ok 13\n";

fail unless $big eq "big";
print "ok 14\n";

# 705_032_704 = (I32)5_000_000_000
fail unless seek(BIG, 705_032_704, $SEEK_SET);
print "ok 15\n";

my $zero;

fail unless read(BIG, $zero, 3) == 3;
print "ok 16\n";

fail unless $zero eq "\0\0\0";
print "ok 17\n";

explain if $fail;

bye(); # does the necessary cleanup

END {
   unlink "big"; # be paranoid about leaving 5 gig files lying around
}

# eof
@


1.1.1.1
log
@virgin perl 5.6.0
@
text
@@


1.1.1.2
log
@stock perl 5.6.1
@
text
@d7 1
a7 1
	@@INC = '../lib';
d11 1
a11 1
		print "1..0 # Skip: no 64-bit file offsets\n";
a15 5
use strict;

our @@s;
our $fail;

a27 2
my $explained;

d29 1
a29 2
    unless ($explained++) {
	print <<EOM;
d31 7
a37 8
# If the lfs (large file support: large meaning larger than two
# gigabytes) tests are skipped or fail, it may mean either that your
# process (or process group) is not allowed to write large files
# (resource limits) or that the file system (the network filesystem?)
# you are running the tests on doesn't let your user/group have large
# files (quota) or the filesystem simply doesn't support large files.
# You may even need to reconfigure your kernel.  (This is all very
# operating system and site-dependent.)
a40 1
# It is just that the test failed now.
a42 2
    }
    print "1..0 # Skip: @@_\n" if @@_;
d48 2
a49 2
if ($^O eq 'MSWin32' || $^O eq 'VMS') {
    print "1..0 # Skip: no sparse files in $^O\n";
d56 1
a56 1
    print "1..0 # Skip: no sparse files in $^0, unable to test large files\n";
d105 1
a105 1
	print "1..0 # Skip: no sparse files?\n";
a112 1
# This may fail by producing some signal; run in a subprocess first for safety
a115 7
my $r = system '../perl', '-e', <<'EOF';
open(BIG, ">big");
seek(BIG, 5_000_000_000, 0);
print BIG "big";
exit 0;
EOF

d118 3
a120 3
if ($r or not seek(BIG, 5_000_000_000, $SEEK_SET)) {
    my $err = $r ? 'signal '.($r & 0x7f) : $!;
    explain("seeking past 2GB failed: $err");
d132 1
a132 1
	explain("writing past 2GB failed: process limits?");
d134 1
a134 3
	explain("filesystem quota limits?");
    } else {
	explain("error: $!");
d136 1
d145 2
a146 1
    explain("kernel/fs not configured to use large files?");
a154 21
sub offset ($$) {
    my ($offset_will_be, $offset_want) = @@_;
    my $offset_is = eval $offset_will_be;
    unless ($offset_is == $offset_want) {
        print "# bad offset $offset_is, want $offset_want\n";
	my ($offset_func) = ($offset_will_be =~ /^(\w+)/);
	if (unpack("L", pack("L", $offset_want)) == $offset_is) {
	    print "# 32-bit wraparound suspected in $offset_func() since\n";
	    print "# $offset_want cast into 32 bits equals $offset_is.\n";
	} elsif ($offset_want - unpack("L", pack("L", $offset_want)) - 1
	         == $offset_is) {
	    print "# 32-bit wraparound suspected in $offset_func() since\n";
	    printf "# %s - unpack('L', pack('L', %s)) - 1 equals %s.\n",
	        $offset_want,
	        $offset_want,
	        $offset_is;
        }
        fail;
    }
}

d157 1
a157 1
$fail = 0;
d177 1
a177 1
offset('tell(BIG)', 4_500_000_000);
d183 1
a183 4
# If you get 205_032_705 from here it means that
# your tell() is returning 32-bit values since (I32)4_500_000_001
# is exactly 205_032_705.
offset('tell(BIG)', 4_500_000_001);
d189 1
a189 1
offset('tell(BIG)', 4_500_000_000);
d195 1
a195 1
offset('tell(BIG)', 5_000_000_000);
a206 2
# See that we don't have "big" in the 705_... spot:
# that would mean that we have a wraparound.
d218 1
a218 1
explain() if $fail;
@


1.1.1.3
log
@stock perl 5.8.0 from CPAN
@
text
@d3 1
a3 1
# If you modify/add tests here, remember to update also ext/Fcntl/t/syslfs.t.
a56 2
$| = 1;

d60 1
a60 1
if ($^O eq 'MSWin32' || $^O eq 'NetWare' || $^O eq 'VMS') {
@


1.1.1.4
log
@perl 5.8.2 from CPAN
@
text
@d271 1
a271 5
    # unlink may fail if applied directly to a large file
    # be paranoid about leaving 5 gig files lying around
    open(BIG, ">big"); # truncate
    close(BIG);
    1 while unlink "big"; # standard portable idiom
@


1.1.1.5
log
@perl 5.8.8 import
@
text
@d70 1
a70 1
    print "1..0 # Skip: no sparse files in $^O, unable to test large files\n";
@


1.1.1.6
log
@import perl 5.10.1
@
text
@a13 1
	require './test.pl';
a20 4
my $big0 = tempfile();
my $big1 = tempfile();
my $big2 = tempfile();

d23 3
d85 2
a86 2
open(BIG, ">$big1") or
    do { warn "open $big1 failed: $!\n"; bye };
d88 1
a88 1
    do { warn "binmode $big1 failed: $!\n"; bye };
d90 1
a90 1
    do { warn "seek $big1 failed: $!\n"; bye };
d92 1
a92 1
    do { warn "print $big1 failed: $!\n"; bye };
d94 1
a94 1
    do { warn "close $big1 failed: $!\n"; bye };
d96 1
a96 1
my @@s1 = stat($big1);
d100 2
a101 2
open(BIG, ">$big2") or
    do { warn "open $big2 failed: $!\n"; bye };
d103 1
a103 1
    do { warn "binmode $big2 failed: $!\n"; bye };
d105 1
a105 1
    do { warn "seek $big2 failed; $!\n"; bye };
d107 1
a107 1
    do { warn "print $big2 failed; $!\n"; bye };
d109 1
a109 1
    do { warn "close $big2 failed; $!\n"; bye };
d111 1
a111 1
my @@s2 = stat($big2);
d132 1
a132 1
open(BIG, ">$big0");
d134 1
a134 1
print BIG $big0;
d138 1
a138 1
open(BIG, ">$big0") or do { warn "open failed: $!\n"; bye };
d163 1
a163 1
@@s = stat($big0);
d172 1
a172 1
sub fail {
d205 1
a205 1
fail unless -s $big0 == 5_000_000_003;	# exercizes pp_ftsize
d208 1
a208 1
fail unless -e $big0;
d211 1
a211 1
fail unless -f $big0;
d214 1
a214 1
open(BIG, $big0) or do { warn "open failed: $!\n"; bye };
d273 1
a273 1
    open(BIG, ">$big0"); # truncate
d275 1
@


1.1.1.7
log
@Perl 5.12.2 from CPAN
@
text
@d120 1
a120 2
	$s1[11] == $s2[11] && $s1[12] == $s2[12] &&
	$s1[12] > 0) {
@


1.1.1.8
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d8 6
a14 4
	require Config;
	# Don't bother if there are no quad offsets.
	skip_all('no 64-bit file offsets')
		if $Config::Config{lseeksize} < 8;
d20 1
d26 9
d56 1
a56 3
    if (@@_) {
	skip_all(@@_);
    }
d65 2
a66 1
    skip_all("no sparse files in $^O");
d72 2
a73 1
    skip_all("no sparse files in $^O, unable to test large files");
d76 1
a76 1
# Then try heuristically to deduce whether we have sparse files.
d80 1
a80 3
sub SEEK_SET () {0}
sub SEEK_CUR () {1}
sub SEEK_END () {2}
d88 1
a88 1
    die "open $big1 failed: $!";
d90 3
a92 3
    die "binmode $big1 failed: $!";
seek(BIG, 1_000_000, SEEK_SET) or
    die "seek $big1 failed: $!";
d94 1
a94 1
    die "print $big1 failed: $!";
d96 1
a96 1
    die "close $big1 failed: $!";
d103 1
a103 1
    die "open $big2 failed: $!";
d105 3
a107 3
    die "binmode $big2 failed: $!";
seek(BIG, 2_000_000, SEEK_SET) or
    die "seek $big2 failed: $!";
d109 1
a109 1
    die "print $big2 failed: $!";
d111 1
a111 1
    die "close $big2 failed: $!";
d117 2
d122 2
a123 1
    skip_all("no sparse files?");
d134 4
a137 5
my $r = system '../perl', '-e', <<"EOF";
open my \$big, '>', q{$big0} or die qq{open $big0: $!};
seek \$big, 5_000_000_000, 0 or die qq{seek $big0: $!};
print \$big "big" or die qq{print $big0: $!};
close \$big or die qq{close $big0: $!};
d141 1
a141 1
open(BIG, ">$big0") or die "open failed: $!";
d143 1
a143 1
if ($r or not seek(BIG, 5_000_000_000, SEEK_SET)) {
d146 1
d163 1
d172 6
a180 1
    local $::Level = $::Level + 1;
d197 1
a197 3
        fail($offset_will_be);
    } else {
	pass($offset_will_be);
d201 3
a203 1
plan(tests => 17);
d205 2
a206 2
is($s[7], 5_000_000_003, 'exercises pp_stat');
is(-s $big0, 5_000_000_003, 'exercises pp_ftsize');
d208 2
a209 2
is(-e $big0, 1);
is(-f $big0, 1);
d211 7
a217 1
open(BIG, $big0) or die "open failed: $!";
d220 2
a221 1
isnt(seek(BIG, 4_500_000_000, SEEK_SET), undef);
d224 1
d226 2
a227 1
isnt(seek(BIG, 1, SEEK_CUR), undef);
d233 1
d235 2
a236 1
isnt(seek(BIG, -1, SEEK_CUR), undef);
d239 1
d241 2
a242 1
isnt(seek(BIG, -3, SEEK_END), undef);
d245 1
d249 2
a250 1
is(read(BIG, $big, 3), 3);
d252 2
a253 1
is($big, "big");
d258 2
a259 1
isnt(seek(BIG, 705_032_704, SEEK_SET), undef);
d263 5
a267 1
is(read(BIG, $zero, 3), 3);
d269 1
a269 1
is($zero, "\0\0\0");
d271 1
a271 1
explain() unless $::Tests_Are_Passing;
@


1.1.1.9
log
@Import perl-5.20.1
@
text
@d1 1
a1 1
# NOTE: this file tests how large files (>2GB) work with perlio (or stdio).
@


