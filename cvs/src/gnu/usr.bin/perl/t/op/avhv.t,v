head	1.2;
access;
symbols
	OPENBSD_6_2:1.2.0.2
	OPENBSD_6_2_BASE:1.2
	PERL_5_24_2:1.1.1.7
	OPENBSD_6_1:1.2.0.4
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.6.0.34
	OPENBSD_6_0_BASE:1.1.1.6
	OPENBSD_5_9:1.1.1.6.0.28
	OPENBSD_5_9_BASE:1.1.1.6
	OPENBSD_5_8:1.1.1.6.0.30
	OPENBSD_5_8_BASE:1.1.1.6
	PERL_5_20_2:1.1.1.6
	OPENBSD_5_7:1.1.1.6.0.22
	OPENBSD_5_7_BASE:1.1.1.6
	PERL_5_20_1:1.1.1.6
	OPENBSD_5_6:1.1.1.6.0.26
	OPENBSD_5_6_BASE:1.1.1.6
	PERL_5_18_2:1.1.1.6
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.6.0.24
	OPENBSD_5_5_BASE:1.1.1.6
	OPENBSD_5_4:1.1.1.6.0.20
	OPENBSD_5_4_BASE:1.1.1.6
	PERL_5_16_3:1.1.1.6
	OPENBSD_5_3:1.1.1.6.0.18
	OPENBSD_5_3_BASE:1.1.1.6
	OPENBSD_5_2:1.1.1.6.0.16
	OPENBSD_5_2_BASE:1.1.1.6
	OPENBSD_5_1_BASE:1.1.1.6
	OPENBSD_5_1:1.1.1.6.0.14
	OPENBSD_5_0:1.1.1.6.0.12
	OPENBSD_5_0_BASE:1.1.1.6
	OPENBSD_4_9:1.1.1.6.0.10
	OPENBSD_4_9_BASE:1.1.1.6
	PERL_5_12_2:1.1.1.6
	OPENBSD_4_8:1.1.1.6.0.8
	OPENBSD_4_8_BASE:1.1.1.6
	OPENBSD_4_7:1.1.1.6.0.4
	OPENBSD_4_7_BASE:1.1.1.6
	PERL_5_10_1:1.1.1.6
	OPENBSD_4_6:1.1.1.6.0.6
	OPENBSD_4_6_BASE:1.1.1.6
	OPENBSD_4_5:1.1.1.6.0.2
	OPENBSD_4_5_BASE:1.1.1.6
	PERL_5_10_0:1.1.1.6
	OPENBSD_4_4:1.1.1.5.0.18
	OPENBSD_4_4_BASE:1.1.1.5
	OPENBSD_4_3:1.1.1.5.0.16
	OPENBSD_4_3_BASE:1.1.1.5
	OPENBSD_4_2:1.1.1.5.0.14
	OPENBSD_4_2_BASE:1.1.1.5
	OPENBSD_4_1:1.1.1.5.0.12
	OPENBSD_4_1_BASE:1.1.1.5
	OPENBSD_4_0:1.1.1.5.0.10
	OPENBSD_4_0_BASE:1.1.1.5
	PERL_5_8_8:1.1.1.5
	OPENBSD_3_9:1.1.1.5.0.8
	OPENBSD_3_9_BASE:1.1.1.5
	OPENBSD_3_8:1.1.1.5.0.6
	OPENBSD_3_8_BASE:1.1.1.5
	OPENBSD_3_7:1.1.1.5.0.4
	OPENBSD_3_7_BASE:1.1.1.5
	PERL_5_8_6:1.1.1.5
	OPENBSD_3_6:1.1.1.5.0.2
	OPENBSD_3_6_BASE:1.1.1.5
	PERL_5_8_5:1.1.1.5
	PERL_5_8_3:1.1.1.5
	OPENBSD_3_5:1.1.1.4.0.6
	OPENBSD_3_5_BASE:1.1.1.4
	PERL_5_8_2:1.1.1.4
	OPENBSD_3_4:1.1.1.4.0.4
	OPENBSD_3_4_BASE:1.1.1.4
	OPENBSD_3_3:1.1.1.4.0.2
	OPENBSD_3_3_BASE:1.1.1.4
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.1.1.3.0.6
	OPENBSD_3_2_BASE:1.1.1.3
	OPENBSD_3_1:1.1.1.3.0.4
	OPENBSD_3_1_BASE:1.1.1.3
	OPENBSD_3_0:1.1.1.3.0.2
	OPENBSD_3_0_BASE:1.1.1.3
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.1.1.2.0.6
	OPENBSD_2_9_BASE:1.1.1.2
	OPENBSD_2_8:1.1.1.2.0.4
	OPENBSD_2_8_BASE:1.1.1.2
	OPENBSD_2_7:1.1.1.2.0.2
	OPENBSD_2_7_BASE:1.1.1.2
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.1.1.1.0.2
	OPENBSD_2_6_BASE:1.1.1.1
	PERL_500503:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.32.20;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	99.04.29.22.41.42;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.29.22.41.42;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.04.06.16.10.47;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.05.24.18.25.34;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.27.22.15.10;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.04.07.21.13.43;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2008.09.29.17.19.00;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2017.08.14.13.46.23;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl

# This test was originally for pseudo-hashes.  It now exists to ensure
# they were properly removed in 5.9.

BEGIN {
    chdir 't' if -d 't';
    require './test.pl';
    set_up_inc('../lib');
}

require Tie::Array;

package Tie::BasicArray;
@@ISA = 'Tie::Array';
sub TIEARRAY  { bless [], $_[0] }
sub STORE     { $_[0]->[$_[1]] = $_[2] }
sub FETCH     { $_[0]->[$_[1]] }
sub FETCHSIZE { scalar(@@{$_[0]})} 
sub STORESIZE { $#{$_[0]} = $_[1]+1 }

package main;

plan(tests => 40);

# Helper function to check the typical error message.
sub not_hash {
    my($err) = shift;
    like( $err, qr/^Not a HASH reference / ) ||
      printf STDERR "# at %s line %d.\n", (caller)[1,2];
}

# Something to place inside if blocks and while loops that won't get
# compiled out.
my $foo = 42;
sub no_op { $foo++ }


$sch = {
    'abc' => 1,
    'def' => 2,
    'jkl' => 3,
};

# basic normal array
$a = [];
$a->[0] = $sch;

eval {
    $a->{'abc'} = 'ABC';
};
not_hash($@@);

eval {
    $a->{'def'} = 'DEF';
};
not_hash($@@);

eval {
    $a->{'jkl'} = 'JKL';
};
not_hash($@@);

eval {
    @@keys = keys %$a;
};
not_hash($@@);

eval {
    @@values = values %$a;
};
not_hash($@@);

eval {
    while( my($k,$v) = each %$a ) {
        no_op;
    }
};
not_hash($@@);


# quick check with tied array
tie @@fake, 'Tie::StdArray';
$a = \@@fake;
$a->[0] = $sch;

eval {
    $a->{'abc'} = 'ABC';
};
not_hash($@@);

eval {
    if ($a->{'abc'} eq 'ABC') { no_op(23) } else { no_op(42) }
};
not_hash($@@);

# quick check with tied array
tie @@fake, 'Tie::BasicArray';
$a = \@@fake;
$a->[0] = $sch;

eval {
    $a->{'abc'} = 'ABC';
};
not_hash($@@);

eval {
    if ($a->{'abc'} eq 'ABC') { no_op(23) } else { no_op(42) }
};
not_hash($@@);

# quick check with tied array & tied hash
require Tie::Hash;
tie %fake, Tie::StdHash;
%fake = %$sch;
$a->[0] = \%fake;

eval {
    $a->{'abc'} = 'ABC';
};
not_hash($@@);

eval {
    if ($a->{'abc'} eq 'ABC') { no_op(23) } else { no_op(42) }
};
not_hash($@@);


# hash slice
eval {
    my $slice = join('', 'x',@@$a{'abc','def'},'x');
};
not_hash($@@);


# evaluation in scalar context
my $avhv = [{}];

eval {
    () = %$avhv;
};
not_hash($@@);

push @@$avhv, "a";
eval {
    () = %$avhv;
};
not_hash($@@);

$avhv = [];
eval { $a = %$avhv };
not_hash($@@);

$avhv = [{foo=>1, bar=>2}];
eval {
    %$avhv =~ m,^\d+/\d+,;
};
not_hash($@@);

# check if defelem magic works
sub f {
    print "not " unless $_[0] eq 'a';
    $_[0] = 'b';
    print "ok 11\n";
}
$a = [{key => 1}, 'a'];
eval {
    f($a->{key});
};
not_hash($@@);

# check if exists() is behaving properly
$avhv = [{foo=>1,bar=>2,pants=>3}];
eval {
    no_op if exists $avhv->{bar};
};
not_hash($@@);

eval {
    $avhv->{pants} = undef;
};
not_hash($@@);

eval {
    no_op if exists $avhv->{pants};
};
not_hash($@@);

eval {
    no_op if exists $avhv->{bar};
};
not_hash($@@);

eval {
    $avhv->{bar} = 10;
};
not_hash($@@);

eval {
    no_op unless exists $avhv->{bar} and $avhv->{bar} == 10;
};
not_hash($@@);

eval {
    $v = delete $avhv->{bar};
};
not_hash($@@);

eval {
    no_op if exists $avhv->{bar};
};
not_hash($@@);

eval {
    $avhv->{foo} = 'xxx';
};
not_hash($@@);
eval {
    $avhv->{bar} = 'yyy';
};
not_hash($@@);
eval {
    $avhv->{pants} = 'zzz';
};
not_hash($@@);
eval {
    @@x = delete @@{$avhv}{'foo','pants'};
};
not_hash($@@);
eval {
    no_op unless "$avhv->{bar}" eq "yyy";
};
not_hash($@@);

# hash assignment
eval {
    %$avhv = ();
};
not_hash($@@);

eval {
    %hv = %$avhv;
};
not_hash($@@);

eval {
    %$avhv = (foo => 29, pants => 2, bar => 0);
};
not_hash($@@);

my $extra;
my @@extra;
eval {
    ($extra, %$avhv) = ("moo", foo => 42, pants => 53, bar => "HIKE!");
};
not_hash($@@);

eval {
    %$avhv = ();
    (%$avhv, $extra) = (foo => 42, pants => 53, bar => "HIKE!");
};
not_hash($@@);

eval {
    @@extra = qw(whatever and stuff);
    %$avhv = ();
};
not_hash($@@);
eval {
    (%$avhv, @@extra) = (foo => 42, pants => 53, bar => "HIKE!");
};
not_hash($@@);

eval {
    (@@extra, %$avhv) = (foo => 42, pants => 53, bar => "HIKE!");
};
not_hash($@@);

# Check hash slices (BUG ID 20010423.002)
$avhv = [{foo=>1, bar=>2}];
eval {
    @@$avhv{"foo", "bar"} = (42, 53);
};
not_hash($@@);
@


1.1
log
@Initial revision
@
text
@d2 4
a5 1
      
d8 2
a9 1
    @@INC = '../lib';
d20 1
a20 1
sub STORESIZE { $#{$_[0]} = $_[1]+1 } 
d24 14
a37 1
print "1..12\n";
d49 9
a57 3
$a->{'abc'} = 'ABC';
$a->{'def'} = 'DEF';
$a->{'jkl'} = 'JKL';
d59 4
a62 2
@@keys = keys %$a;
@@values = values %$a;
d64 4
a67 1
if ($#keys == 2 && $#values == 2) {print "ok 1\n";} else {print "not ok 1\n";}
d69 4
a72 1
$i = 0;		# stop -w complaints
d74 3
a76 4
while (($key,$value) = each %$a) {
    if ($key eq $keys[$i] && $value eq $values[$i] && $key eq lc($value)) {
	$key =~ y/a-z/A-Z/;
	$i++ if $key eq $value;
d78 2
a79 1
}
a80 1
if ($i == 3) {print "ok 2\n";} else {print "not ok 2\n";}
d87 9
a95 2
$a->{'abc'} = 'ABC';
if ($a->{'abc'} eq 'ABC') {print "ok 3\n";} else {print "not ok 3\n";}
d102 9
a110 2
$a->{'abc'} = 'ABC';
if ($a->{'abc'} eq 'ABC') {print "ok 4\n";} else {print "not ok 4\n";}
d118 10
a127 2
$a->{'abc'} = 'ABC';
if ($a->{'abc'} eq 'ABC') {print "ok 5\n";} else {print "not ok 5\n";}
d130 5
a134 3
my $slice = join('', 'x',@@$a{'abc','def'},'x');
print "not " if $slice ne 'xABCx';
print "ok 6\n";
d138 5
a142 2
print "not " if %$avhv;
print "ok 7\n";
d145 4
a148 2
print "not " if %$avhv;
print "ok 8\n";
d152 1
a152 2
print "not " unless $@@ and $@@ =~ /^Can't coerce array into hash/;
print "ok 9\n";
d155 4
a158 2
print "not " unless %$avhv =~ m,^\d+/\d+,;
print "ok 10\n";
d167 16
a182 3
f($a->{key});
print "not " unless $a->[1] eq 'b';
print "ok 12\n";
d184 101
@


1.1.1.1
log
@perl5.005_03
@
text
@@


1.1.1.2
log
@virgin perl 5.6.0
@
text
@d2 1
a2 1

d5 1
a5 1
    unshift @@INC, '../lib';
d20 1
a20 1
print "1..28\n";
a110 68
# check if exists() is behaving properly
$avhv = [{foo=>1,bar=>2,pants=>3}];
print "not " if exists $avhv->{bar};
print "ok 13\n";

$avhv->{pants} = undef;
print "not " unless exists $avhv->{pants};
print "ok 14\n";
print "not " if exists $avhv->{bar};
print "ok 15\n";

$avhv->{bar} = 10;
print "not " unless exists $avhv->{bar} and $avhv->{bar} == 10;
print "ok 16\n";

$v = delete $avhv->{bar};
print "not " unless $v == 10;
print "ok 17\n";

print "not " if exists $avhv->{bar};
print "ok 18\n";

$avhv->{foo} = 'xxx';
$avhv->{bar} = 'yyy';
$avhv->{pants} = 'zzz';
@@x = delete @@{$avhv}{'foo','pants'};
print "# @@x\nnot " unless "@@x" eq "xxx zzz";
print "ok 19\n";

print "not " unless "$avhv->{bar}" eq "yyy";
print "ok 20\n";

# hash assignment
%$avhv = ();
print "not " unless ref($avhv->[0]) eq 'HASH';
print "ok 21\n";

%hv = %$avhv;
print "not " if grep defined, values %hv;
print "ok 22\n";
print "not " if grep ref, keys %hv;
print "ok 23\n";

%$avhv = (foo => 29, pants => 2, bar => 0);
print "not " unless "@@$avhv[1..3]" eq '29 0 2';
print "ok 24\n";

my $extra;
my @@extra;
($extra, %$avhv) = ("moo", foo => 42, pants => 53, bar => "HIKE!");
print "not " unless "@@$avhv[1..3]" eq '42 HIKE! 53' and $extra eq 'moo';
print "ok 25\n";

%$avhv = ();
(%$avhv, $extra) = (foo => 42, pants => 53, bar => "HIKE!");
print "not " unless "@@$avhv[1..3]" eq '42 HIKE! 53' and !defined $extra;
print "ok 26\n";

@@extra = qw(whatever and stuff);
%$avhv = ();
(%$avhv, @@extra) = (foo => 42, pants => 53, bar => "HIKE!");
print "not " unless "@@$avhv[1..3]" eq '42 HIKE! 53' and @@extra == 0;
print "ok 27\n";

%$avhv = ();
(@@extra, %$avhv) = (foo => 42, pants => 53, bar => "HIKE!");
print "not " unless ref $avhv->[0] eq 'HASH' and @@extra == 6;
print "ok 28\n";
@


1.1.1.3
log
@stock perl 5.6.1
@
text
@d5 1
a5 1
    @@INC = '../lib';
@


1.1.1.4
log
@stock perl 5.8.0 from CPAN
@
text
@d20 1
a20 1
print "1..29\n";
a178 6

# Check hash slices (BUG ID 20010423.002)
$avhv = [{foo=>1, bar=>2}];
@@$avhv{"foo", "bar"} = (42, 53);
print "not " unless $avhv->{foo} == 42 && $avhv->{bar} == 53;
print "ok 29\n";
@


1.1.1.5
log
@perl 5.8.3 from CPAN
@
text
@a5 1
    require './test.pl';
a7 5
use warnings;
no warnings 'deprecated';
use strict;
use vars qw(@@fake %fake);

d11 1
a11 1
@@Tie::BasicArray::ISA = 'Tie::Array';
d20 1
a20 1
plan tests => 36;
d22 1
a22 1
my $sch = {
d36 2
a37 2
my @@keys = keys %$a;
my @@values = values %$a;
d39 1
a39 2
is ($#keys, 2);
is ($#values, 2);
d41 1
a41 1
my $i = 0;	# stop -w complaints
d43 1
a43 1
while (my ($key,$value) = each %$a) {
d50 1
a50 1
is ($i, 3);
d58 1
a58 1
is ($a->{'abc'}, 'ABC');
d66 1
a66 1
is ($a->{'abc'}, 'ABC');
d70 1
a70 1
tie %fake, 'Tie::StdHash';
d75 1
a75 1
is ($a->{'abc'}, 'ABC');
d78 3
a80 5
{
  no warnings 'uninitialized';
  my $slice = join('', 'x',@@$a{'abc','def'},'x');
  is ($slice, 'xABCx');
}
d84 2
a85 1
ok (!%$avhv);
d88 2
a89 1
ok (!%$avhv);
d93 2
a94 1
like ($@@, qr/^Can't coerce array into hash/);
d97 2
a98 1
like (%$avhv, qr,^\d+/\d+,);
d102 1
a102 1
    is ($_[0], 'a');
d104 1
d108 2
a109 1
is ($a->[1], 'b');
d113 2
a114 1
ok (!exists $avhv->{bar});
d117 4
a120 2
ok (exists $avhv->{pants});
ok (!exists $avhv->{bar});
d123 2
a124 2
ok (exists $avhv->{bar});
is ($avhv->{bar}, 10);
d126 3
a128 2
my $v = delete $avhv->{bar};
is ($v, 10);
d130 2
a131 1
ok (!exists $avhv->{bar});
d136 3
a138 2
my @@x = delete @@{$avhv}{'foo','pants'};
is ("@@x", "xxx zzz");
d140 2
a141 1
is ("$avhv->{bar}", "yyy");
d145 2
a146 1
is (ref($avhv->[0]), 'HASH');
d148 5
a152 3
my %hv = %$avhv;
ok (!grep defined, values %hv);
ok (!grep ref, keys %hv);
d155 2
a156 1
is ("@@$avhv[1..3]", '29 0 2');
d161 2
a162 2
is ("@@$avhv[1..3]", '42 HIKE! 53');
is ($extra, 'moo');
d166 2
a167 2
is ("@@$avhv[1..3]", '42 HIKE! 53');
ok (!defined $extra);
d172 2
a173 2
is ("@@$avhv[1..3]", '42 HIKE! 53');
is (@@extra, 0);
d177 2
a178 2
is (ref $avhv->[0], 'HASH');
is (@@extra, 6);
d183 2
a184 2
is ($avhv->{foo}, 42);
is ($avhv->{bar}, 53);
@


1.1.1.6
log
@import perl 5.10.0 from CPAN
@
text
@a2 3
# This test was originally for pseudo-hashes.  It now exists to ensure
# they were properly removed in 5.9.

d6 1
d9 5
d17 1
a17 1
@@ISA = 'Tie::Array';
d22 1
a22 1
sub STORESIZE { $#{$_[0]} = $_[1]+1 }
d26 1
a26 15
require './test.pl';
plan(tests => 40);

# Helper function to check the typical error message.
sub not_hash {
    my($err) = shift;
    like( $err, qr/^Not a HASH reference / ) ||
      printf STDERR "# at %s line %d.\n", (caller)[1,2];
}

# Something to place inside if blocks and while loops that won't get
# compiled out.
my $foo = 42;
sub no_op { $foo++ }

d28 1
a28 1
$sch = {
d38 16
a53 28
eval {
    $a->{'abc'} = 'ABC';
};
not_hash($@@);

eval {
    $a->{'def'} = 'DEF';
};
not_hash($@@);

eval {
    $a->{'jkl'} = 'JKL';
};
not_hash($@@);

eval {
    @@keys = keys %$a;
};
not_hash($@@);

eval {
    @@values = values %$a;
};
not_hash($@@);

eval {
    while( my($k,$v) = each %$a ) {
        no_op;
d55 1
a55 2
};
not_hash($@@);
d57 1
d64 2
a65 9
eval {
    $a->{'abc'} = 'ABC';
};
not_hash($@@);

eval {
    if ($a->{'abc'} eq 'ABC') { no_op(23) } else { no_op(42) }
};
not_hash($@@);
d72 2
a73 9
eval {
    $a->{'abc'} = 'ABC';
};
not_hash($@@);

eval {
    if ($a->{'abc'} eq 'ABC') { no_op(23) } else { no_op(42) }
};
not_hash($@@);
d77 1
a77 1
tie %fake, Tie::StdHash;
d81 2
a82 10
eval {
    $a->{'abc'} = 'ABC';
};
not_hash($@@);

eval {
    if ($a->{'abc'} eq 'ABC') { no_op(23) } else { no_op(42) }
};
not_hash($@@);

d85 5
a89 5
eval {
    my $slice = join('', 'x',@@$a{'abc','def'},'x');
};
not_hash($@@);

d93 1
a93 5

eval {
    () = %$avhv;
};
not_hash($@@);
d96 1
a96 4
eval {
    () = %$avhv;
};
not_hash($@@);
d100 1
a100 1
not_hash($@@);
d103 1
a103 4
eval {
    %$avhv =~ m,^\d+/\d+,;
};
not_hash($@@);
d107 1
a107 1
    print "not " unless $_[0] eq 'a';
a108 1
    print "ok 11\n";
d111 2
a112 4
eval {
    f($a->{key});
};
not_hash($@@);
d116 1
a116 9
eval {
    no_op if exists $avhv->{bar};
};
not_hash($@@);

eval {
    $avhv->{pants} = undef;
};
not_hash($@@);
d118 3
a120 4
eval {
    no_op if exists $avhv->{pants};
};
not_hash($@@);
d122 3
a124 4
eval {
    no_op if exists $avhv->{bar};
};
not_hash($@@);
d126 2
a127 4
eval {
    $avhv->{bar} = 10;
};
not_hash($@@);
d129 1
a129 4
eval {
    no_op unless exists $avhv->{bar} and $avhv->{bar} == 10;
};
not_hash($@@);
d131 5
a135 4
eval {
    $v = delete $avhv->{bar};
};
not_hash($@@);
d137 1
a137 25
eval {
    no_op if exists $avhv->{bar};
};
not_hash($@@);

eval {
    $avhv->{foo} = 'xxx';
};
not_hash($@@);
eval {
    $avhv->{bar} = 'yyy';
};
not_hash($@@);
eval {
    $avhv->{pants} = 'zzz';
};
not_hash($@@);
eval {
    @@x = delete @@{$avhv}{'foo','pants'};
};
not_hash($@@);
eval {
    no_op unless "$avhv->{bar}" eq "yyy";
};
not_hash($@@);
d140 2
a141 4
eval {
    %$avhv = ();
};
not_hash($@@);
d143 3
a145 4
eval {
    %hv = %$avhv;
};
not_hash($@@);
d147 2
a148 4
eval {
    %$avhv = (foo => 29, pants => 2, bar => 0);
};
not_hash($@@);
d152 19
a170 25
eval {
    ($extra, %$avhv) = ("moo", foo => 42, pants => 53, bar => "HIKE!");
};
not_hash($@@);

eval {
    %$avhv = ();
    (%$avhv, $extra) = (foo => 42, pants => 53, bar => "HIKE!");
};
not_hash($@@);

eval {
    @@extra = qw(whatever and stuff);
    %$avhv = ();
};
not_hash($@@);
eval {
    (%$avhv, @@extra) = (foo => 42, pants => 53, bar => "HIKE!");
};
not_hash($@@);

eval {
    (@@extra, %$avhv) = (foo => 42, pants => 53, bar => "HIKE!");
};
not_hash($@@);
d174 3
a176 4
eval {
    @@$avhv{"foo", "bar"} = (42, 53);
};
not_hash($@@);
@


1.1.1.7
log
@Import perl-5.24.2
@
text
@d8 1
a8 2
    require './test.pl';
    set_up_inc('../lib');
d23 1
@


