head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2:1.1.1.3.0.14
	OPENBSD_6_2_BASE:1.1.1.3
	PERL_5_24_2:1.1.1.3
	OPENBSD_6_1:1.1.1.3.0.12
	OPENBSD_6_1_BASE:1.1.1.3
	OPENBSD_6_0:1.1.1.3.0.10
	OPENBSD_6_0_BASE:1.1.1.3
	OPENBSD_5_9:1.1.1.3.0.4
	OPENBSD_5_9_BASE:1.1.1.3
	OPENBSD_5_8:1.1.1.3.0.6
	OPENBSD_5_8_BASE:1.1.1.3
	PERL_5_20_2:1.1.1.3
	OPENBSD_5_7:1.1.1.3.0.2
	OPENBSD_5_7_BASE:1.1.1.3
	PERL_5_20_1:1.1.1.3
	OPENBSD_5_6:1.1.1.2.0.4
	OPENBSD_5_6_BASE:1.1.1.2
	PERL_5_18_2:1.1.1.2
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.1.0.34
	OPENBSD_5_5_BASE:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.30
	OPENBSD_5_4_BASE:1.1.1.1
	PERL_5_16_3:1.1.1.1
	OPENBSD_5_3:1.1.1.1.0.28
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.26
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.24
	OPENBSD_5_0:1.1.1.1.0.22
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.20
	OPENBSD_4_9_BASE:1.1.1.1
	PERL_5_12_2:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.18
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.14
	OPENBSD_4_7_BASE:1.1.1.1
	PERL_5_10_1:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.16
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.12
	OPENBSD_4_5_BASE:1.1.1.1
	PERL_5_10_0:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.10
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.8
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.6
	OPENBSD_4_2_BASE:1.1.1.1
	OPENBSD_4_1:1.1.1.1.0.4
	OPENBSD_4_1_BASE:1.1.1.1
	OPENBSD_4_0:1.1.1.1.0.2
	OPENBSD_4_0_BASE:1.1.1.1
	PERL_5_8_8:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.1
date	2006.03.28.18.49.45;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.03.28.18.49.45;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2014.03.24.14.59.10;	author afresh1;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.11.17.20.53.18;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.1
log
@Initial revision
@
text
@#!./perl -w

BEGIN {
    chdir 't' if -d 't';
    @@INC = '../lib';
    require './test.pl';
}

plan tests => 16;

# not() tests
pass() if not();
is(not(), 1);
is(not(), not(0));

# test not(..) and !
is(! 1, not 1);
is(! 0, not 0);
is(! (0, 0), not(0, 0));

# test the return of !
{
    my $not0 = ! 0;
    my $not1 = ! 1;

    no warnings;
    ok($not1 == undef);
    ok($not1 == ());

    use warnings;
    ok($not1 eq '');
    ok($not1 == 0);
    ok($not0 == 1);
}

# test the return of not
{
    my $not0 = not 0;
    my $not1 = not 1;

    no warnings;
    ok($not1 == undef);
    ok($not1 == ());

    use warnings;
    ok($not1 eq '');
    ok($not1 == 0);
    ok($not0 == 1);
}
@


1.1.1.1
log
@perl 5.8.8 import
@
text
@@


1.1.1.2
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d9 1
a9 1
plan tests => 19;
d12 3
a14 4
pass("logical negation of empty list") if not();
is(not(), 1, "logical negation of empty list in numeric comparison");
is(not(), not(0),
    "logical negation of empty list compared with logical negation of false value");
d17 3
a19 7
note("parens needed around second argument in next two tests\nto preserve list context inside function call");
is(! 1, (not 1),
    "high- and low-precedence logical negation of true value");
is(! 0, (not 0),
    "high- and low-precedence logical negation of false value");
is(! (0, 0), not(0, 0),
    "high- and low-precedence logical negation of lists");
d27 2
a28 4
    ok($not1 == undef,
        "logical negation (high-precedence) of true value is numerically equal to undefined value");
    ok($not1 == (),
        "logical negation (high-precedence) of true value is numerically equal to empty list");
d31 3
a33 6
    ok($not1 eq '',
        "logical negation (high-precedence) of true value in string context is equal to empty string");
    ok($not1 == 0,
        "logical negation (high-precedence) of true value is false in numeric context");
    ok($not0 == 1,
        "logical negation (high-precedence) of false value is true in numeric context");
d42 2
a43 4
    ok($not1 == undef,
        "logical negation (low-precedence) of true value is numerically equal to undefined value");
    ok($not1 == (),
        "logical negation (low-precedence) of true value is numerically equal to empty list");
d46 3
a48 20
    ok($not1 eq '',
        "logical negation (low-precedence) of true value in string context is equal to empty string");
    ok($not1 == 0,
        "logical negation (low-precedence) of true value is false in numeric context");
    ok($not0 == 1,
        "logical negation (low-precedence) of false value is true in numeric context");
}

# test truth of dualvars
SKIP:
{
    my $got_dualvar;
    eval 'use Scalar::Util "dualvar"; $got_dualvar++';
    skip "No Scalar::Util::dualvar", 3 unless $got_dualvar;
    my $a = Scalar::Util::dualvar(3, "");
    is not($a), 1, 'not(dualvar) ignores int when string is false';
    my $b = Scalar::Util::dualvar(3.3,"");
    is not($b), 1, 'not(dualvar) ignores float when string is false';
    my $c = Scalar::Util::dualvar(0,"1");
    is not($c), "", 'not(dualvar) ignores false int when string is true';
@


1.1.1.3
log
@Import perl-5.20.1
@
text
@d9 1
a9 1
plan tests => 24;
a78 17

# test truth of regexps
is not(${qr//}), "", 'dereferenced regexps are true';

# notâ€™s return value should be read-only, as it is the same global scalar
# each time (and test that it is, too).
*yes = \not 0;
*no  = \not 1;
for (!0) { eval { $_ = 43 } }
like $@@, qr/^Modification of a read-only value attempted at /,
   'not 0 is read-only';
for (!1) { eval { $_ = 43 } }
like $@@, qr/^Modification of a read-only value attempted at /,
   'not 1 is read-only';
require Config;
is \!0, \$yes, '!0 returns the same value each time [perl #114838]';
is \!1, \$no,  '!1 returns the same value each time [perl #114838]';
@


