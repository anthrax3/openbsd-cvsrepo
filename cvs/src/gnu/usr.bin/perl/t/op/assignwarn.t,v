head	1.6;
access;
symbols
	PERL_5_24_2:1.1.1.6
	OPENBSD_6_1:1.6.0.18
	OPENBSD_6_1_BASE:1.6
	OPENBSD_6_0:1.6.0.16
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.10
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.12
	OPENBSD_5_8_BASE:1.6
	PERL_5_20_2:1.1.1.6
	OPENBSD_5_7:1.6.0.4
	OPENBSD_5_7_BASE:1.6
	PERL_5_20_1:1.1.1.6
	OPENBSD_5_6:1.6.0.8
	OPENBSD_5_6_BASE:1.6
	PERL_5_18_2:1.1.1.6
	PERL:1.1.1
	OPENBSD_5_5:1.6.0.6
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.2
	OPENBSD_5_4_BASE:1.6
	PERL_5_16_3:1.1.1.6
	OPENBSD_5_3:1.5.0.10
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.8
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.6
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	PERL_5_12_2:1.1.1.5
	OPENBSD_4_8:1.4.0.28
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.24
	OPENBSD_4_7_BASE:1.4
	PERL_5_10_1:1.1.1.4
	OPENBSD_4_6:1.4.0.26
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.22
	OPENBSD_4_5_BASE:1.4
	PERL_5_10_0:1.1.1.4
	OPENBSD_4_4:1.4.0.20
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.18
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.16
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.14
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.12
	OPENBSD_4_0_BASE:1.4
	PERL_5_8_8:1.1.1.4
	OPENBSD_3_9:1.4.0.10
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.8
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.6
	OPENBSD_3_7_BASE:1.4
	PERL_5_8_6:1.1.1.4
	OPENBSD_3_6:1.4.0.4
	OPENBSD_3_6_BASE:1.4
	PERL_5_8_5:1.1.1.4
	PERL_5_8_3:1.1.1.4
	OPENBSD_3_5:1.4.0.2
	OPENBSD_3_5_BASE:1.4
	PERL_5_8_2:1.1.1.4
	OPENBSD_3_4:1.3.0.10
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.3.0.8
	OPENBSD_3_3_BASE:1.3
	PERL_5_8_0:1.1.1.3
	OPENBSD_3_2:1.3.0.6
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.4
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.2
	OPENBSD_3_0_BASE:1.3
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.2.0.6
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.1.0.8
	OPENBSD_2_6_BASE:1.1
	PERL_500503:1.1.1.1
	CPAN:1.1.1
	OPENBSD_2_5:1.1.0.6
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.4
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.2
	OPENBSD_2_3_BASE:1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.6
date	2013.03.25.20.40.59;	author sthen;	state Exp;
branches;
next	1.5;

1.5
date	2010.09.24.15.07.08;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2003.12.03.03.02.48;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.05.24.18.36.16;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.06.17.08.19;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	97.11.30.08.05.13;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.29.22.41.42;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.04.06.16.10.47;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.05.24.18.25.33;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.12.03.02.44.31;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2010.09.24.14.49.17;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2013.03.25.20.09.35;	author sthen;	state Exp;
branches;
next	;


desc
@perl 5.004_04
@


1.6
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@#!./perl -w

#
# Verify which OP= operators warn if their targets are undefined.
# Based on redef.t, contributed by Graham Barr <Graham.Barr@@tiuk.ti.com>
#	-- Robin Barker 
#
# Now almost completely rewritten.

BEGIN {
    chdir 't' if -d 't';
    @@INC = '../lib';
    require './test.pl';
}

use strict;

my (%should_warn, %should_not);
++$should_warn{$_} foreach qw(* / x & ** << >>);
++$should_not{$_} foreach qw(+ - . | ^ && ||);

my %integer;
$integer{$_} = 0 foreach qw(* / % + -);

sub TIESCALAR { my $x; bless \$x }
sub FETCH { ${$_[0]} }
sub STORE { ${$_[0]} = $_[1] }

sub test_op {
    my ($tie, $int, $op_seq, $warn) = @@_;
    my $code = "sub {\n";
    $code .= "use integer;" if $int;
    $code .= "my \$x;\n";
    $code .= "tie \$x, 'main';\n" if $tie;
    $code .= "$op_seq;\n}\n";

    my $sub = eval $code;
    is($@@, '', "Can eval code for $op_seq");
    if ($warn) {
	warning_like($sub, qr/^Use of uninitialized value/,
		     "$op_seq$tie$int warns");
    } else {
	warning_is($sub, undef, "$op_seq$tie$int does not warn");
    }
}

# go through all tests once normally and once with tied $x
for my $tie ("", ", tied") {
    foreach my $integer ('', ', int') {
	test_op($tie, $integer, $_, 0) foreach qw($x++ $x-- ++$x --$x);
    }

    foreach (keys %should_warn, keys %should_not) {
	test_op($tie, '', "\$x $_= 1", $should_warn{$_});
	next unless exists $integer{$_};
	test_op($tie, ', int', "\$x $_= 1", $should_warn{$_});
    }

    foreach (qw(| ^ &)) {
	test_op($tie, '', "\$x $_= 'x'", $should_warn{$_});
    }
}

done_testing();
@


1.5
log
@merge in perl 5.12.2 plus local changes
@
text
@d1 1
a1 1
#!./perl
d8 1
a16 1
use warnings;
d18 6
a23 2
my $warn = "";
$SIG{q(__WARN__)} = sub { print $warn; $warn .= join("",@@_) };
a24 2
sub uninitialized { $warn =~ s/Use of uninitialized value[^\n]+\n//s; }
sub tiex { tie $_[0], 'main' }
a27 1
our $TODO;
d29 17
a45 1
print "1..63\n";
d49 13
a61 11

{ my $x; tiex $x if $tie; $x ++;     ok ! uninitialized, "postinc$tie"; }
{ my $x; tiex $x if $tie; $x --;     ok ! uninitialized, "postdec$tie"; }
{ my $x; tiex $x if $tie; ++ $x;     ok ! uninitialized, "preinc$tie"; }
{ my $x; tiex $x if $tie; -- $x;     ok ! uninitialized, "predec$tie"; }

{ my $x; tiex $x if $tie; $x **= 1;  ok uninitialized,   "**=$tie"; }

{ local $TODO = $tie && '[perl #17809] pp_add & pp_subtract';
    { my $x; tiex $x if $tie; $x += 1;   ok ! uninitialized, "+=$tie"; }
    { my $x; tiex $x if $tie; $x -= 1;   ok ! uninitialized, "-=$tie"; }
d64 1
a64 49
{ my $x; tiex $x if $tie; $x .= 1;   ok ! uninitialized, ".=$tie"; }

{ my $x; tiex $x if $tie; $x *= 1;   ok uninitialized,   "*=$tie"; }
{ my $x; tiex $x if $tie; $x /= 1;   ok uninitialized,   "/=$tie"; }
{ my $x; tiex $x if $tie; $x %= 1;   ok uninitialized,   "\%=$tie"; }

{ my $x; tiex $x if $tie; $x x= 1;   ok uninitialized, "x=$tie"; }

{ my $x; tiex $x if $tie; $x &= 1;   ok uninitialized, "&=$tie"; }

{ local $TODO = $tie && '[perl #17809] pp_bit_or & pp_bit_xor';
    { my $x; tiex $x if $tie; $x |= 1;   ok ! uninitialized, "|=$tie"; }
    { my $x; tiex $x if $tie; $x ^= 1;   ok ! uninitialized, "^=$tie"; }
}

{ my $x; tiex $x if $tie; $x &&= 1;  ok ! uninitialized, "&&=$tie"; }
{ my $x; tiex $x if $tie; $x ||= 1;  ok ! uninitialized, "||=$tie"; }

{ my $x; tiex $x if $tie; $x <<= 1;  ok uninitialized, "<<=$tie"; }
{ my $x; tiex $x if $tie; $x >>= 1;  ok uninitialized, ">>=$tie"; }

{ my $x; tiex $x if $tie; $x &= "x"; ok uninitialized, "&=$tie, string"; }

{ local $TODO = $tie && '[perl #17809] pp_bit_or & pp_bit_xor';
    { my $x; tiex $x if $tie; $x |= "x"; ok ! uninitialized, "|=$tie, string"; }
    { my $x; tiex $x if $tie; $x ^= "x"; ok ! uninitialized, "^=$tie, string"; }
}

{ use integer;

{ local $TODO = $tie && '[perl #17809] pp_i_add & pp_i_subtract';
    { my $x; tiex $x if $tie; $x += 1; ok ! uninitialized, "+=$tie, int"; }
    { my $x; tiex $x if $tie; $x -= 1; ok ! uninitialized, "-=$tie, int"; }
}

{ my $x; tiex $x if $tie; $x *= 1; ok uninitialized, "*=$tie, int"; }
{ my $x; tiex $x if $tie; $x /= 1; ok uninitialized, "/=$tie, int"; }
{ my $x; tiex $x if $tie; $x %= 1; ok uninitialized, "\%=$tie, int"; }

{ my $x; tiex $x if $tie; $x ++;   ok ! uninitialized, "postinc$tie, int"; }
{ my $x; tiex $x if $tie; $x --;   ok ! uninitialized, "postdec$tie, int"; }
{ my $x; tiex $x if $tie; ++ $x;   ok ! uninitialized, "preinc$tie, int"; }
{ my $x; tiex $x if $tie; -- $x;   ok ! uninitialized, "predec$tie, int"; }

} # end of use integer;

} # end of for $tie

is $warn, '', "no spurious warnings";
@


1.4
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d6 1
a6 1
#	-- Robin Barker <rmb@@cise.npl.co.uk>
@


1.3
log
@merge in perl 5.6.1 with our local changes
@
text
@d12 1
d21 23
a43 1
sub ok { print $_[1] ? "ok " : "not ok ", $_[0], "\n"; }
d45 1
a45 3
sub uninitialized { $warn =~ s/Use of uninitialized value[^\n]+\n//s; }
    
print "1..32\n";
d47 3
a49 4
{ my $x; $x ++;     ok  1, ! uninitialized; }
{ my $x; $x --;     ok  2, ! uninitialized; }
{ my $x; ++ $x;     ok  3, ! uninitialized; }
{ my $x; -- $x;	    ok  4, ! uninitialized; }
d51 1
a51 1
{ my $x; $x **= 1;  ok  5,  uninitialized; }
d53 1
a53 2
{ my $x; $x += 1;   ok  6, ! uninitialized; }
{ my $x; $x -= 1;   ok  7, ! uninitialized; }
d55 4
a58 1
{ my $x; $x .= 1;   ok  8, ! uninitialized; }
d60 2
a61 3
{ my $x; $x *= 1;   ok  9,  uninitialized; }
{ my $x; $x /= 1;   ok 10,  uninitialized; }
{ my $x; $x %= 1;   ok 11,  uninitialized; }
d63 2
a64 1
{ my $x; $x x= 1;   ok 12,  uninitialized; }
d66 1
a66 3
{ my $x; $x &= 1;   ok 13,  uninitialized; }
{ my $x; $x |= 1;   ok 14, ! uninitialized; }
{ my $x; $x ^= 1;   ok 15, ! uninitialized; }
d68 4
a71 2
{ my $x; $x &&= 1;  ok 16, ! uninitialized; }
{ my $x; $x ||= 1;  ok 17, ! uninitialized; }
d73 1
a73 2
{ my $x; $x <<= 1;  ok 18,  uninitialized; }
{ my $x; $x >>= 1;  ok 19,  uninitialized; }
d75 4
a78 3
{ my $x; $x &= "x"; ok 20,  uninitialized; }
{ my $x; $x |= "x"; ok 21, ! uninitialized; }
{ my $x; $x ^= "x"; ok 22, ! uninitialized; }
d80 3
a82 2
{ use integer; my $x; $x += 1; ok 23, ! uninitialized; }
{ use integer; my $x; $x -= 1; ok 24, ! uninitialized; }
d84 4
a87 3
{ use integer; my $x; $x *= 1; ok 25,  uninitialized; }
{ use integer; my $x; $x /= 1; ok 26,  uninitialized; }
{ use integer; my $x; $x %= 1; ok 27,  uninitialized; }
d89 1
a89 4
{ use integer; my $x; $x ++;   ok 28, ! uninitialized; }
{ use integer; my $x; $x --;   ok 29, ! uninitialized; }
{ use integer; my $x; ++ $x;   ok 30, ! uninitialized; }
{ use integer; my $x; -- $x;   ok 31, ! uninitialized; }
d91 1
a91 1
ok 32, $warn eq '';
d93 1
a93 2
# If we got any errors that we were not expecting, then print them
print map "#$_\n", split /\n/, $warn if length $warn;
@


1.2
log
@perl-5.6.0 + local changes
@
text
@d11 1
a11 1
    unshift @@INC, '../lib';
d24 1
a24 1
print "1..23\n";
d58 13
a70 1
ok 23, $warn eq '';
@


1.1
log
@perl 5.004_04
@
text
@d11 1
a11 1
    @@INC = '../lib';
d15 1
a16 1
$^W = 1;
@


1.1.1.1
log
@perl5.005_03
@
text
@@


1.1.1.2
log
@virgin perl 5.6.0
@
text
@d11 1
a11 1
    unshift @@INC, '../lib';
a14 1
use warnings;
d16 1
@


1.1.1.3
log
@stock perl 5.6.1
@
text
@d11 1
a11 1
    @@INC = '../lib';
d24 1
a24 1
print "1..32\n";
d58 1
a58 13
{ use integer; my $x; $x += 1; ok 23, ! uninitialized; }
{ use integer; my $x; $x -= 1; ok 24, ! uninitialized; }

{ use integer; my $x; $x *= 1; ok 25,  uninitialized; }
{ use integer; my $x; $x /= 1; ok 26,  uninitialized; }
{ use integer; my $x; $x %= 1; ok 27,  uninitialized; }

{ use integer; my $x; $x ++;   ok 28, ! uninitialized; }
{ use integer; my $x; $x --;   ok 29, ! uninitialized; }
{ use integer; my $x; ++ $x;   ok 30, ! uninitialized; }
{ use integer; my $x; -- $x;   ok 31, ! uninitialized; }

ok 32, $warn eq '';
@


1.1.1.4
log
@perl 5.8.2 from CPAN
@
text
@a11 1
    require './test.pl';
d20 2
d23 2
a24 24
sub tiex { tie $_[0], 'main' }
sub TIESCALAR { my $x; bless \$x }
sub FETCH { ${$_[0]} }
sub STORE { ${$_[0]} = $_[1] }
our $TODO;

print "1..63\n";

# go through all tests once normally and once with tied $x
for my $tie ("", ", tied") {

{ my $x; tiex $x if $tie; $x ++;     ok ! uninitialized, "postinc$tie"; }
{ my $x; tiex $x if $tie; $x --;     ok ! uninitialized, "postdec$tie"; }
{ my $x; tiex $x if $tie; ++ $x;     ok ! uninitialized, "preinc$tie"; }
{ my $x; tiex $x if $tie; -- $x;     ok ! uninitialized, "predec$tie"; }

{ my $x; tiex $x if $tie; $x **= 1;  ok uninitialized,   "**=$tie"; }

{ local $TODO = $tie && '[perl #17809] pp_add & pp_subtract';
    { my $x; tiex $x if $tie; $x += 1;   ok ! uninitialized, "+=$tie"; }
    { my $x; tiex $x if $tie; $x -= 1;   ok ! uninitialized, "-=$tie"; }
}

{ my $x; tiex $x if $tie; $x .= 1;   ok ! uninitialized, ".=$tie"; }
d26 4
a29 3
{ my $x; tiex $x if $tie; $x *= 1;   ok uninitialized,   "*=$tie"; }
{ my $x; tiex $x if $tie; $x /= 1;   ok uninitialized,   "/=$tie"; }
{ my $x; tiex $x if $tie; $x %= 1;   ok uninitialized,   "\%=$tie"; }
d31 1
a31 1
{ my $x; tiex $x if $tie; $x x= 1;   ok uninitialized, "x=$tie"; }
d33 2
a34 1
{ my $x; tiex $x if $tie; $x &= 1;   ok uninitialized, "&=$tie"; }
d36 1
a36 4
{ local $TODO = $tie && '[perl #17809] pp_bit_or & pp_bit_xor';
    { my $x; tiex $x if $tie; $x |= 1;   ok ! uninitialized, "|=$tie"; }
    { my $x; tiex $x if $tie; $x ^= 1;   ok ! uninitialized, "^=$tie"; }
}
d38 3
a40 2
{ my $x; tiex $x if $tie; $x &&= 1;  ok ! uninitialized, "&&=$tie"; }
{ my $x; tiex $x if $tie; $x ||= 1;  ok ! uninitialized, "||=$tie"; }
d42 1
a42 2
{ my $x; tiex $x if $tie; $x <<= 1;  ok uninitialized, "<<=$tie"; }
{ my $x; tiex $x if $tie; $x >>= 1;  ok uninitialized, ">>=$tie"; }
d44 3
a46 1
{ my $x; tiex $x if $tie; $x &= "x"; ok uninitialized, "&=$tie, string"; }
d48 2
a49 4
{ local $TODO = $tie && '[perl #17809] pp_bit_or & pp_bit_xor';
    { my $x; tiex $x if $tie; $x |= "x"; ok ! uninitialized, "|=$tie, string"; }
    { my $x; tiex $x if $tie; $x ^= "x"; ok ! uninitialized, "^=$tie, string"; }
}
d51 2
a52 1
{ use integer;
d54 3
a56 4
{ local $TODO = $tie && '[perl #17809] pp_i_add & pp_i_subtract';
    { my $x; tiex $x if $tie; $x += 1; ok ! uninitialized, "+=$tie, int"; }
    { my $x; tiex $x if $tie; $x -= 1; ok ! uninitialized, "-=$tie, int"; }
}
d58 2
a59 3
{ my $x; tiex $x if $tie; $x *= 1; ok uninitialized, "*=$tie, int"; }
{ my $x; tiex $x if $tie; $x /= 1; ok uninitialized, "/=$tie, int"; }
{ my $x; tiex $x if $tie; $x %= 1; ok uninitialized, "\%=$tie, int"; }
d61 3
a63 4
{ my $x; tiex $x if $tie; $x ++;   ok ! uninitialized, "postinc$tie, int"; }
{ my $x; tiex $x if $tie; $x --;   ok ! uninitialized, "postdec$tie, int"; }
{ my $x; tiex $x if $tie; ++ $x;   ok ! uninitialized, "preinc$tie, int"; }
{ my $x; tiex $x if $tie; -- $x;   ok ! uninitialized, "predec$tie, int"; }
d65 4
a68 1
} # end of use integer;
d70 1
a70 1
} # end of for $tie
d72 2
a73 1
is $warn, '', "no spurious warnings";
@


1.1.1.5
log
@Perl 5.12.2 from CPAN
@
text
@d6 1
a6 1
#	-- Robin Barker 
@


1.1.1.6
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d1 1
a1 1
#!./perl -w
a7 1
# Now almost completely rewritten.
d16 1
d18 2
a19 6
my (%should_warn, %should_not);
++$should_warn{$_} foreach qw(* / x & ** << >>);
++$should_not{$_} foreach qw(+ - . | ^ && ||);

my %integer;
$integer{$_} = 0 foreach qw(* / % + -);
d21 2
d26 1
d28 1
a28 17
sub test_op {
    my ($tie, $int, $op_seq, $warn) = @@_;
    my $code = "sub {\n";
    $code .= "use integer;" if $int;
    $code .= "my \$x;\n";
    $code .= "tie \$x, 'main';\n" if $tie;
    $code .= "$op_seq;\n}\n";

    my $sub = eval $code;
    is($@@, '', "Can eval code for $op_seq");
    if ($warn) {
	warning_like($sub, qr/^Use of uninitialized value/,
		     "$op_seq$tie$int warns");
    } else {
	warning_is($sub, undef, "$op_seq$tie$int does not warn");
    }
}
d32 11
a42 13
    foreach my $integer ('', ', int') {
	test_op($tie, $integer, $_, 0) foreach qw($x++ $x-- ++$x --$x);
    }

    foreach (keys %should_warn, keys %should_not) {
	test_op($tie, '', "\$x $_= 1", $should_warn{$_});
	next unless exists $integer{$_};
	test_op($tie, ', int', "\$x $_= 1", $should_warn{$_});
    }

    foreach (qw(| ^ &)) {
	test_op($tie, '', "\$x $_= 'x'", $should_warn{$_});
    }
d45 49
a93 1
done_testing();
@


