head	1.13;
access;
symbols
	OPENBSD_6_0:1.12.0.12
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.12.0.6
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.12.0.8
	OPENBSD_5_8_BASE:1.12
	PERL_5_20_2:1.1.1.11
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	PERL_5_20_1:1.1.1.11
	OPENBSD_5_6:1.12.0.4
	OPENBSD_5_6_BASE:1.12
	PERL_5_18_2:1.1.1.11
	PERL:1.1.1
	OPENBSD_5_5:1.11.0.6
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.2
	OPENBSD_5_4_BASE:1.11
	PERL_5_16_3:1.1.1.10
	OPENBSD_5_3:1.10.0.14
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.12
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.10
	OPENBSD_5_0:1.10.0.8
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.6
	OPENBSD_4_9_BASE:1.10
	PERL_5_12_2:1.1.1.9
	OPENBSD_4_8:1.10.0.4
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.2
	OPENBSD_4_7_BASE:1.10
	PERL_5_10_1:1.1.1.9
	OPENBSD_4_6:1.9.0.6
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.2
	OPENBSD_4_5_BASE:1.9
	PERL_5_10_0:1.1.1.8
	OPENBSD_4_4:1.8.0.10
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.8
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.6
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.4
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.2
	OPENBSD_4_0_BASE:1.8
	PERL_5_8_8:1.1.1.7
	OPENBSD_3_9:1.7.0.8
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.6
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.4
	OPENBSD_3_7_BASE:1.7
	PERL_5_8_6:1.1.1.6
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7
	PERL_5_8_5:1.1.1.6
	PERL_5_8_3:1.1.1.5
	OPENBSD_3_5:1.6.0.2
	OPENBSD_3_5_BASE:1.6
	PERL_5_8_2:1.1.1.5
	OPENBSD_3_4:1.5.0.4
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.4.0.6
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.4
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.3.0.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	PERL_500503:1.1.1.1
	CPAN:1.1.1
	OPENBSD_2_5:1.1.0.6
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.4
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.2
	OPENBSD_2_3_BASE:1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.13
date	2017.02.05.00.32.20;	author afresh1;	state Exp;
branches;
next	1.12;
commitid	cxJ08BvJA9Pt2PTM;

1.12
date	2014.03.24.15.05.33;	author afresh1;	state Exp;
branches;
next	1.11;

1.11
date	2013.03.25.20.40.59;	author sthen;	state Exp;
branches;
next	1.10;

1.10
date	2009.10.12.18.30.27;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2008.09.29.17.36.19;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2006.03.28.19.23.12;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2004.08.09.18.10.27;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2003.12.03.03.02.48;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.10.27.22.25.37;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.24.18.36.17;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.06.17.08.20;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	99.04.29.22.52.34;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	97.11.30.08.05.15;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.29.22.41.43;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.04.06.16.10.47;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.05.24.18.25.34;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.27.22.15.10;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.12.03.02.44.31;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.08.09.17.48.34;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2006.03.28.18.49.44;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2008.09.29.17.19.00;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2009.10.12.18.10.45;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2013.03.25.20.09.35;	author sthen;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2014.03.24.14.59.10;	author afresh1;	state Exp;
branches;
next	;


desc
@perl 5.004_04
@


1.13
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl
#                              -*- Mode: Perl -*-
# closure.t:
#   Original written by Ulrich Pfeifer on 2 Jan 1997.
#   Greatly extended by Tom Phoenix <rootbeer@@teleport.com> on 28 Jan 1997.
#
#   Run with -debug for debugging output.

BEGIN {
    chdir 't' if -d 't';
    require './test.pl';
    set_up_inc('../lib');
}

use Config;

my $i = 1;
sub foo { $i = shift if @@_; $i }

# no closure
is(foo, 1);
foo(2);
is(foo, 2);

# closure: lexical outside sub
my $foo = sub {$i = shift if @@_; $i };
my $bar = sub {$i = shift if @@_; $i };
is(&$foo(), 2);
&$foo(3);
is(&$foo(), 3);
# did the lexical change?
is(foo, 3, 'lexical changed');
is($i, 3, 'lexical changed');
# did the second closure notice?
is(&$bar(), 3, 'second closure noticed');

# closure: lexical inside sub
sub bar {
  my $i = shift;
  sub { $i = shift if @@_; $i }
}

$foo = bar(4);
$bar = bar(5);
is(&$foo(), 4);
&$foo(6);
is(&$foo(), 6);
is(&$bar(), 5);

# nested closures
sub bizz {
  my $i = 7;
  if (@@_) {
    my $i = shift;
    sub {$i = shift if @@_; $i };
  } else {
    my $i = $i;
    sub {$i = shift if @@_; $i };
  }
}
$foo = bizz();
$bar = bizz();
is(&$foo(), 7);
&$foo(8);
is(&$foo(), 8);
is(&$bar(), 7);

$foo = bizz(9);
$bar = bizz(10);
is(&$foo(11)-1, &$bar());

my @@foo;
for (qw(0 1 2 3 4)) {
  my $i = $_;
  $foo[$_] = sub {$i = shift if @@_; $i };
}

is(&{$foo[0]}(), 0);
is(&{$foo[1]}(), 1);
is(&{$foo[2]}(), 2);
is(&{$foo[3]}(), 3);
is(&{$foo[4]}(), 4);

for (0 .. 4) {
  &{$foo[$_]}(4-$_);
}

is(&{$foo[0]}(), 4);
is(&{$foo[1]}(), 3);
is(&{$foo[2]}(), 2);
is(&{$foo[3]}(), 1);
is(&{$foo[4]}(), 0);

sub barf {
  my @@foo;
  for (qw(0 1 2 3 4)) {
    my $i = $_;
    $foo[$_] = sub {$i = shift if @@_; $i };
  }
  @@foo;
}

@@foo = barf();
is(&{$foo[0]}(), 0);
is(&{$foo[1]}(), 1);
is(&{$foo[2]}(), 2);
is(&{$foo[3]}(), 3);
is(&{$foo[4]}(), 4);

for (0 .. 4) {
  &{$foo[$_]}(4-$_);
}

is(&{$foo[0]}(), 4);
is(&{$foo[1]}(), 3);
is(&{$foo[2]}(), 2);
is(&{$foo[3]}(), 1);
is(&{$foo[4]}(), 0);

# test if closures get created in optimized for loops

my %foo;
for my $n ('A'..'E') {
    $foo{$n} = sub { $n eq $_[0] };
}

ok(&{$foo{A}}('A'));
ok(&{$foo{B}}('B'));
ok(&{$foo{C}}('C'));
ok(&{$foo{D}}('D'));
ok(&{$foo{E}}('E'));

for my $n (0..4) {
    $foo[$n] = sub { $n == $_[0] };
}

ok(&{$foo[0]}(0));
ok(&{$foo[1]}(1));
ok(&{$foo[2]}(2));
ok(&{$foo[3]}(3));
ok(&{$foo[4]}(4));

for my $n (0..4) {
    $foo[$n] = sub {
                     # no intervening reference to $n here
                     sub { $n == $_[0] }
		   };
}

ok($foo[0]->()->(0));
ok($foo[1]->()->(1));
ok($foo[2]->()->(2));
ok($foo[3]->()->(3));
ok($foo[4]->()->(4));

{
    my $w;
    $w = sub {
	my ($i) = @@_;
	is($i, 10);
	sub { $w };
    };
    $w->(10);
}

# Additional tests by Tom Phoenix <rootbeer@@teleport.com>.

{
    use strict;

    use vars qw!$test!;
    my($debugging, %expected, $inner_type, $where_declared, $within);
    my($nc_attempt, $call_outer, $call_inner, $undef_outer);
    my($code, $inner_sub_test, $expected, $line, $errors, $output);
    my(@@inners, $sub_test, $pid);
    $debugging = 1 if defined($ARGV[0]) and $ARGV[0] eq '-debug';

    # The expected values for these tests
    %expected = (
	'global_scalar'	=> 1001,
	'global_array'	=> 2101,
	'global_hash'	=> 3004,
	'fs_scalar'	=> 4001,
	'fs_array'	=> 5101,
	'fs_hash'	=> 6004,
	'sub_scalar'	=> 7001,
	'sub_array'	=> 8101,
	'sub_hash'	=> 9004,
	'foreach'	=> 10011,
    );

    # Our innermost sub is either named or anonymous
    for $inner_type (qw!named anon!) {
      # And it may be declared at filescope, within a named
      # sub, or within an anon sub
      for $where_declared (qw!filescope in_named in_anon!) {
	# And that, in turn, may be within a foreach loop,
	# a naked block, or another named sub
	for $within (qw!foreach naked other_sub!) {

	  my $test = curr_test();
	  # Here are a number of variables which show what's
	  # going on, in a way.
	  $nc_attempt = 0+		# Named closure attempted
	      ( ($inner_type eq 'named') ||
	      ($within eq 'other_sub') ) ;
	  $call_inner = 0+		# Need to call &inner
	      ( ($inner_type eq 'anon') &&
	      ($within eq 'other_sub') ) ;
	  $call_outer = 0+		# Need to call &outer or &$outer
	      ( ($inner_type eq 'anon') &&
	      ($within ne 'other_sub') ) ;
	  $undef_outer = 0+		# $outer is created but unused
	      ( ($where_declared eq 'in_anon') &&
	      (not $call_outer) ) ;

	  $code = "# This is a test script built by t/op/closure.t\n\n";

	  print <<"DEBUG_INFO" if $debugging;
# inner_type:     $inner_type 
# where_declared: $where_declared 
# within:         $within
# nc_attempt:     $nc_attempt
# call_inner:     $call_inner
# call_outer:     $call_outer
# undef_outer:    $undef_outer
DEBUG_INFO

	  $code .= <<"END_MARK_ONE";

BEGIN { \$SIG{__WARN__} = sub { 
    my \$msg = \$_[0];
END_MARK_ONE

	  $code .=  <<"END_MARK_TWO" if $nc_attempt;
    return if index(\$msg, 'will not stay shared') != -1;
    return if index(\$msg, 'is not available') != -1;
END_MARK_TWO

	  $code .= <<"END_MARK_THREE";		# Backwhack a lot!
    print "not ok: got unexpected warning \$msg\\n";
} }

require './test.pl';
curr_test($test);

# some of the variables which the closure will access
\$global_scalar = 1000;
\@@global_array = (2000, 2100, 2200, 2300);
%global_hash = 3000..3009;

my \$fs_scalar = 4000;
my \@@fs_array = (5000, 5100, 5200, 5300);
my %fs_hash = 6000..6009;

END_MARK_THREE

	  if ($where_declared eq 'filescope') {
	    # Nothing here
	  } elsif ($where_declared eq 'in_named') {
	    $code .= <<'END';
sub outer {
  my $sub_scalar = 7000;
  my @@sub_array = (8000, 8100, 8200, 8300);
  my %sub_hash = 9000..9009;
END
    # }
	  } elsif ($where_declared eq 'in_anon') {
	    $code .= <<'END';
$outer = sub {
  my $sub_scalar = 7000;
  my @@sub_array = (8000, 8100, 8200, 8300);
  my %sub_hash = 9000..9009;
END
    # }
	  } else {
	    die "What was $where_declared?"
	  }

	  if ($within eq 'foreach') {
	    $code .= "
      my \$foreach = 12000;
      my \@@list = (10000, 10010);
      foreach \$foreach (\@@list) {
    " # }
	  } elsif ($within eq 'naked') {
	    $code .= "  { # naked block\n"	# }
	  } elsif ($within eq 'other_sub') {
	    $code .= "  sub inner_sub {\n"	# }
	  } else {
	    die "What was $within?"
	  }

	  $sub_test = $test;
	  @@inners = ( qw!global_scalar global_array global_hash! ,
	    qw!fs_scalar fs_array fs_hash! );
	  push @@inners, 'foreach' if $within eq 'foreach';
	  if ($where_declared ne 'filescope') {
	    push @@inners, qw!sub_scalar sub_array sub_hash!;
	  }
	  for $inner_sub_test (@@inners) {

	    if ($inner_type eq 'named') {
	      $code .= "    sub named_$sub_test "
	    } elsif ($inner_type eq 'anon') {
	      $code .= "    \$anon_$sub_test = sub "
	    } else {
	      die "What was $inner_type?"
	    }

	    # Now to write the body of the test sub
	    if ($inner_sub_test eq 'global_scalar') {
	      $code .= '{ ++$global_scalar }'
	    } elsif ($inner_sub_test eq 'fs_scalar') {
	      $code .= '{ ++$fs_scalar }'
	    } elsif ($inner_sub_test eq 'sub_scalar') {
	      $code .= '{ ++$sub_scalar }'
	    } elsif ($inner_sub_test eq 'global_array') {
	      $code .= '{ ++$global_array[1] }'
	    } elsif ($inner_sub_test eq 'fs_array') {
	      $code .= '{ ++$fs_array[1] }'
	    } elsif ($inner_sub_test eq 'sub_array') {
	      $code .= '{ ++$sub_array[1] }'
	    } elsif ($inner_sub_test eq 'global_hash') {
	      $code .= '{ ++$global_hash{3002} }'
	    } elsif ($inner_sub_test eq 'fs_hash') {
	      $code .= '{ ++$fs_hash{6002} }'
	    } elsif ($inner_sub_test eq 'sub_hash') {
	      $code .= '{ ++$sub_hash{9002} }'
	    } elsif ($inner_sub_test eq 'foreach') {
	      $code .= '{ ++$foreach }'
	    } else {
	      die "What was $inner_sub_test?"
	    }
	  
	    # Close up
	    if ($inner_type eq 'anon') {
	      $code .= ';'
	    }
	    $code .= "\n";
	    $sub_test++;	# sub name sequence number

	  } # End of foreach $inner_sub_test

	  # Close up $within block		# {
	  $code .= "  }\n\n";

	  # Close up $where_declared block
	  if ($where_declared eq 'in_named') {	# {
	    $code .= "}\n\n";
	  } elsif ($where_declared eq 'in_anon') {	# {
	    $code .= "};\n\n";
	  }

	  # We may need to do something with the sub we just made...
	  $code .= "undef \$outer;\n" if $undef_outer;
	  $code .= "&inner_sub;\n" if $call_inner;
	  if ($call_outer) {
	    if ($where_declared eq 'in_named') {
	      $code .= "&outer;\n\n";
	    } elsif ($where_declared eq 'in_anon') {
	      $code .= "&\$outer;\n\n"
	    }
	  }

	  # Now, we can actually prep to run the tests.
	  for $inner_sub_test (@@inners) {
	    $expected = $expected{$inner_sub_test} or
	      die "expected $inner_sub_test missing";

	    # Named closures won't access the expected vars
	    if ( $nc_attempt and 
		substr($inner_sub_test, 0, 4) eq "sub_" ) {
	      $expected = 1;
	    }

	    # If you make a sub within a foreach loop,
	    # what happens if it tries to access the 
	    # foreach index variable? If it's a named
	    # sub, it gets the var from "outside" the loop,
	    # but if it's anon, it gets the value to which
	    # the index variable is aliased.
	    #
	    # Of course, if the value was set only
	    # within another sub which was never called,
	    # the value has not been set yet.
	    #
	    if ($inner_sub_test eq 'foreach') {
	      if ($inner_type eq 'named') {
		if ($call_outer || ($where_declared eq 'filescope')) {
		  $expected = 12001
		} else {
		  $expected = 1
		}
	      }
	    }

	    # Here's the test:
	    my $desc = "$inner_type $where_declared $within $inner_sub_test";
	    if ($inner_type eq 'anon') {
	      $code .= "is(&\$anon_$test, $expected, '$desc');\n"
	    } else {
	      $code .= "is(&named_$test, $expected, '$desc');\n"
	    }
	    $test++;
	  }

	  if ($Config{d_fork} and $^O ne 'VMS' and $^O ne 'MSWin32' and $^O ne 'NetWare') {
	    # Fork off a new perl to run the tests.
	    # (This is so we can catch spurious warnings.)
	    $| = 1; print ""; $| = 0; # flush output before forking
	    pipe READ, WRITE or die "Can't make pipe: $!";
	    pipe READ2, WRITE2 or die "Can't make second pipe: $!";
	    die "Can't fork: $!" unless defined($pid = open PERL, "|-");
	    unless ($pid) {
	      # Child process here. We're going to send errors back
	      # through the extra pipe.
	      close READ;
	      close READ2;
	      open STDOUT, ">&WRITE"  or die "Can't redirect STDOUT: $!";
	      open STDERR, ">&WRITE2" or die "Can't redirect STDERR: $!";
	      exec which_perl(), '-w', '-'
		or die "Can't exec perl: $!";
	    } else {
	      # Parent process here.
	      close WRITE;
	      close WRITE2;
	      print PERL $code;
	      close PERL;
	      { local $/;
	        $output = join '', <READ>;
	        $errors = join '', <READ2>; }
	      close READ;
	      close READ2;
	    }
	  } else {
	    # No fork().  Do it the hard way.
	    my $cmdfile = tempfile();
	    my $errfile = tempfile();
	    open CMD, ">$cmdfile"; print CMD $code; close CMD;
	    my $cmd = which_perl();
	    $cmd .= " -w $cmdfile 2>$errfile";
	    if ($^O eq 'VMS' or $^O eq 'MSWin32' or $^O eq 'NetWare') {
	      # Use pipe instead of system so we don't inherit STD* from
	      # this process, and then foul our pipe back to parent by
	      # redirecting output in the child.
	      open PERL,"$cmd |" or die "Can't open pipe: $!\n";
	      { local $/; $output = join '', <PERL> }
	      close PERL;
	    } else {
	      my $outfile = tempfile();
	      system "$cmd >$outfile";
	      { local $/; open IN, $outfile; $output = <IN>; close IN }
	    }
	    if ($?) {
	      printf "not ok: exited with error code %04X\n", $?;
	      exit;
	    }
	    { local $/; open IN, $errfile; $errors = <IN>; close IN }
	  }
	  print $output;
	  curr_test($test);
	  print STDERR $errors;
	  # This has the side effect of alerting *our* test.pl to the state of
	  # what has just been passed to STDOUT, so that if anything there has
	  # failed, our test.pl will print a diagnostic and exit uncleanly.
	  unlike($output, qr/not ok/, 'All good');
	  is($errors, '', 'STDERR is silent');
	  if ($debugging && ($errors || $? || ($output =~ /not ok/))) {
	    my $lnum = 0;
	    for $line (split '\n', $code) {
	      printf "%3d:  %s\n", ++$lnum, $line;
	    }
	  }
	  is($?, 0, 'exited cleanly') or diag(sprintf "Error code $? = 0x%X", $?);
	  print '#', "-" x 30, "\n" if $debugging;

	}	# End of foreach $within
      }	# End of foreach $where_declared
    }	# End of foreach $inner_type

}

# The following dumps core with perl <= 5.8.0 (bugid 9535) ...
BEGIN { $vanishing_pad = sub { eval $_[0] } }
$some_var = 123;
is($vanishing_pad->('$some_var'), 123, 'RT #9535');

# ... and here's another coredump variant - this time we explicitly
# delete the sub rather than using a BEGIN ...

sub deleteme { $a = sub { eval '$newvar' } }
deleteme();
*deleteme = sub {}; # delete the sub
$newvar = 123; # realloc the SV of the freed CV
is($a->(), 123, 'RT #9535');

# ... and a further coredump variant - the fixup of the anon sub's
# CvOUTSIDE pointer when the middle eval is freed, wasn't good enough to
# survive the outer eval also being freed.

$x = 123;
$a = eval q(
    eval q[
	sub { eval '$x' }
    ]
);
@@a = ('\1\1\1\1\1\1\1') x 100; # realloc recently-freed CVs
is($a->(), 123, 'RT #9535');

# this coredumped on <= 5.8.0 because evaling the closure caused
# an SvFAKE to be added to the outer anon's pad, which was then grown.
my $outer;
sub {
    my $x;
    $x = eval 'sub { $outer }';
    $x->();
    $a = [ 99 ];
    $x->();
}->();
pass();

# [perl #17605] found that an empty block called in scalar context
# can lead to stack corruption
{
    my $x = "foooobar";
    $x =~ s/o//eg;
    is($x, 'fbar', 'RT #17605');
}

# DAPM 24-Nov-02
# SvFAKE lexicals should be visible thoughout a function.
# On <= 5.8.0, the third test failed,  eg bugid #18286

{
    my $x = 1;
    sub fake {
		is(sub {eval'$x'}->(), 1, 'RT #18286');
	{ $x;	is(sub {eval'$x'}->(), 1, 'RT #18286'); }
		is(sub {eval'$x'}->(), 1, 'RT #18286');
    }
}
fake();

{
    $x = 1;
    my $x = 2;
    sub tmp { sub { eval '$x' } }
    my $a = tmp();
    undef &tmp;
    is($a->(), 2,
       "undefining a sub shouldn't alter visibility of outer lexicals");
}

# handy class: $x = Watch->new(\$foo,'bar')
# causes 'bar' to be appended to $foo when $x is destroyed
sub Watch::new { bless [ $_[1], $_[2] ], $_[0] }
sub Watch::DESTROY { ${$_[0][0]} .= $_[0][1] }

# bugid 1028:
# nested anon subs (and associated lexicals) not freed early enough

sub linger {
    my $x = Watch->new($_[0], '2');
    sub {
	$x;
	my $y;
	sub { $y; };
    };
}
{
    my $watch = '1';
    linger(\$watch);
    is($watch, '12', 'RT #1028');
}

# bugid 10085
# obj not freed early enough

sub linger2 { 
    my $obj = Watch->new($_[0], '2');
    sub { sub { $obj } };
}   
{
    my $watch = '1';
    linger2(\$watch);
    is($watch, 12, 'RT #10085');
}

# bugid 16302 - named subs didn't capture lexicals on behalf of inner subs

{
    my $x = 1;
    sub f16302 {
	sub {
	    is($x, 1, 'RT #16302');
	}->();
    }
}
f16302();

# The presence of an eval should turn cloneless anon subs into clonable
# subs - otherwise the CvOUTSIDE of that sub may be wrong

{
    my %a;
    for my $x (7,11) {
	$a{$x} = sub { $x=$x; sub { eval '$x' } };
    }
    is($a{7}->()->() + $a{11}->()->(), 18);
}

{
   # bugid #23265 - this used to coredump during destruction of PL_maincv
   # and its children

    fresh_perl_is(<< '__EOF__', "yxx\n", {stderr => 1}, 'RT #23265');
        print
            sub {$_[0]->(@@_)} -> (
                sub {
                    $_[1]
                        ?  $_[0]->($_[0], $_[1] - 1) .  sub {"x"}->()
                        : "y"
                },   
                2
            )
            , "\n"
        ;
__EOF__
}

{
    # bugid #24914 = used to coredump restoring PL_comppad in the
    # savestack, due to the early freeing of the anon closure

    fresh_perl_is('sub d {die} my $f; $f = sub {my $x=1; $f = 0; d}; eval{$f->()}; print qq(ok\n)',
		  "ok\n", {stderr => 1}, 'RT #24914');
}


# After newsub is redefined outside the BEGIN, its CvOUTSIDE should point
# to main rather than BEGIN, and BEGIN should be freed.

{
    my $flag = 0;
    sub  X::DESTROY { $flag = 1 }
    {
	my $x;
	BEGIN {$x = \&newsub }
	sub newsub {};
	$x = bless {}, 'X';
    }
    is($flag, 1);
}

sub f {
    my $x;
    format ff =
@@
$r = \$x
.
}

{
    fileno ff;
    write ff;
    my $r1 = $r;
    write ff;
    my $r2 = $r;
    isnt($r1, $r2,
	 "don't copy a stale lexical; create a fresh undef one instead");
}

# test PL_cv_has_eval.  Any anon sub that could conceivably contain an
# eval, should be marked as cloneable

{

    my @@s;
    push @@s, sub {  eval '1' } for 1,2;
    isnt($s[0], $s[1], "cloneable with eval");
    @@s = ();
    push @@s, sub { use re 'eval'; my $x; s/$x/1/; } for 1,2;
    isnt($s[0], $s[1], "cloneable with use re eval");
    @@s = ();
    push @@s, sub { s/1/1/ee; } for 1,2;
    isnt($s[0], $s[1], "cloneable with //ee");
}

# [perl #89544]
{
   sub trace::DESTROY {
       push @@trace::trace, "destroyed";
   }

   my $outer2 = sub {
       my $a = bless \my $dummy, trace::;

       my $outer = sub {
	   my $b;
	   my $inner = sub {
	       undef $b;
	   };

	   $a;

	   $inner
       };

       $outer->()
   };

   my $inner = $outer2->();
   is "@@trace::trace", "destroyed",
      'closures only close over named variables, not entire subs';
}

# [perl #113812] Closure prototypes with no CvOUTSIDE (crash caused by the
#                fix for #89544)
do "./op/closure_test.pl" or die $@@||$!;
is $closure_test::s2->()(), '10 cubes',
  'cloning closure proto with no CvOUTSIDE';

# Also brought up in #113812: Even when being cloned, a closure prototype
# might have its CvOUTSIDE pointing to the wrong thing.
{
    package main::113812;
    $s1 = sub {
	my $x = 3;
	$s2 = sub {
	    $x;
	    $s3 = sub { $x };
	};
    };
    $s1->();
    undef &$s1; # frees $s2's prototype, causing the $s3 proto to have its
                # CvOUTSIDE point to $s1
    ::is $s2->()(), 3, 'cloning closure proto whose CvOUTSIDE has changed';
}

# This should never emit two different values:
#     print $x, "\n";
#     print sub { $x }->(), "\n";
# This test case started to do just that in commit 33894c1aa3e
# (5.10.1/5.12.0):
sub mosquito {
    my $x if @@_;
    return if @@_;

    $x = 17;
    is sub { $x }->(), $x, 'closing over stale var in 2nd sub call';
}
mosquito(1);
mosquito;
# And this case in commit adf8f095c588 (5.14):
sub anything {
    my $x;
    sub gnat {
	$x = 3;
	is sub { $x }->(), $x,
	    'closing over stale var before 1st sub call';
    }
}
gnat();

# [perl #114018] Similar to the above, but with string eval
sub staleval {
    my $x if @@_;
    return if @@_;

    $x = 3;
    is eval '$x', $x, 'eval closing over stale var in active sub';
    return # 
}
staleval 1;
staleval;

# [perl #114888]
# Test that closure creation localises PL_comppad_name properly.  Usually
# at compile time a BEGIN block will localise PL_comppad_name for use, so
# pp_anoncode can mess with it without any visible effects.
# But inside a source filter, it affects the directly enclosing compila-
# tion scope.
SKIP: {
    skip_if_miniperl("no XS on miniperl (for source filters)");
    fresh_perl_is <<'    [perl #114888]', "ok\n", {stderr=>1},
	use strict;
	BEGIN {
	    package Foo;
	    use Filter::Util::Call;
	    sub import { filter_add( sub {
		my $status = filter_read();
		sub { $status };
		$status;
	    })}
	    Foo->import
	}
	my $x = "ok\n";	# stores $x in the wrong padnamelist
	print $x;	# cannot find it - strict violation
    [perl #114888]
        'closures in source filters do not interfere with pad names';
}

sub {
    my $f;
    sub test_ref_to_unavailable {
	my $ref = \$f;
        $$ref = 7;
        is $f, 7, 'taking a ref to unavailable var should not copy it';
    }
};
test_ref_to_unavailable();

done_testing();
@


1.12
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@a10 1
    @@INC = '../lib';
d12 1
a673 14
# [perl #63540] Don’t treat sub { if(){.....}; "constant" } as a constant

BEGIN {
  my $x = 7;
  *baz = sub() { if($x){ () = "tralala"; blonk() }; 0 }
}
{
  my $blonk_was_called;
  *blonk = sub { ++$blonk_was_called };
  my $ret = baz();
  is($ret, 0, 'RT #63540');
  is($blonk_was_called, 1, 'RT #63540');
}

d736 1
a736 1
    undef &$s1; # frees $s2’s prototype, causing the $s3 proto to have its
d803 10
@


1.11
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d12 1
a15 1
require './test.pl';
d657 5
a661 2
    my $x if $_[0];
    sub { \$x }
d665 5
a669 6
    f(1);
    my $c1= f(0);
    my $c2= f(0);

    my $r1 = $c1->();
    my $r2 = $c2->();
d671 1
a671 1
	 "don't copy a stale lexical; crate a fresh undef one instead");
d686 130
@


1.10
log
@Merge in perl 5.10.1; part two
@
text
@d15 1
a15 11
require './test.pl'; # for runperl()

print "1..188\n";

my $test = 1;
sub test (&) {
  my $ok = &{$_[0]};
  print $ok ? "ok $test\n" : "not ok $test\n";
  printf "# Failed at line %d\n", (caller)[2] unless $ok;
  $test++;
}
d21 1
a21 1
test { foo == 1 };
d23 1
a23 1
test { foo == 2 };
d28 1
a28 1
test {&$foo() == 2 };
d30 1
a30 1
test {&$foo() == 3 };
d32 2
a33 1
test { foo == 3 and $i == 3};
d35 1
a35 1
test {&$bar() == 3 };
d45 1
a45 1
test {&$foo() == 4 };
d47 2
a48 2
test {&$foo() == 6 };
test {&$bar() == 5 };
d63 1
a63 1
test {&$foo() == 7 };
d65 2
a66 2
test {&$foo() == 8 };
test {&$bar() == 7 };
d70 1
a70 1
test {&$foo(11)-1 == &$bar()};
d78 5
a82 7
test {
  &{$foo[0]}() == 0 and
  &{$foo[1]}() == 1 and
  &{$foo[2]}() == 2 and
  &{$foo[3]}() == 3 and
  &{$foo[4]}() == 4
  };
d88 5
a92 7
test {
  &{$foo[0]}() == 4 and
  &{$foo[1]}() == 3 and
  &{$foo[2]}() == 2 and
  &{$foo[3]}() == 1 and
  &{$foo[4]}() == 0
  };
d104 5
a108 7
test {
  &{$foo[0]}() == 0 and
  &{$foo[1]}() == 1 and
  &{$foo[2]}() == 2 and
  &{$foo[3]}() == 3 and
  &{$foo[4]}() == 4
  };
d114 5
a118 7
test {
  &{$foo[0]}() == 4 and
  &{$foo[1]}() == 3 and
  &{$foo[2]}() == 2 and
  &{$foo[3]}() == 1 and
  &{$foo[4]}() == 0
  };
d127 5
a131 7
test {
  &{$foo{A}}('A') and
  &{$foo{B}}('B') and
  &{$foo{C}}('C') and
  &{$foo{D}}('D') and
  &{$foo{E}}('E')
};
d137 5
a141 7
test {
  &{$foo[0]}(0) and
  &{$foo[1]}(1) and
  &{$foo[2]}(2) and
  &{$foo[3]}(3) and
  &{$foo[4]}(4)
};
d150 5
a154 7
test {
  $foo[0]->()->(0) and
  $foo[1]->()->(1) and
  $foo[2]->()->(2) and
  $foo[3]->()->(3) and
  $foo[4]->()->(4)
};
d160 1
a160 1
	test { $i == 10 };
d201 1
d244 2
a245 9
{
    my \$test = $test;
    sub test (&) {
      my \$ok = &{\$_[0]};
      print \$ok ? "ok \$test\n" : "not ok \$test\n";
      printf "# Failed at line %d\n", (caller)[2] unless \$ok;
      \$test++;
    }
}
d399 1
d401 1
a401 1
	      $code .= "test { &\$anon_$test == $expected };\n"
d403 1
a403 1
	      $code .= "test { &named_$test == $expected };\n"
d462 1
d464 5
d475 1
a475 1
	  printf "not ok: exited with error code %04X\n", $? if $?;
d487 1
a487 1
test { $vanishing_pad->( '$some_var' ) == 123 };
d496 1
a496 1
test { $a->() == 123 };
d509 1
a509 1
test { $a->() == 123 };
d521 1
a521 1
test {1};
d528 1
a528 1
    test { $x eq 'fbar' }
d538 3
a540 3
		test { sub {eval'$x'}->() == 1 };
	{ $x;	test { sub {eval'$x'}->() == 1 } }
		test { sub {eval'$x'}->() == 1 };
a544 2
# undefining a sub shouldn't alter visibility of outer lexicals

d551 2
a552 1
    test { $a->() == 2 };
a559 1

d574 1
a574 1
    test { $watch eq '12' }
d587 1
a587 1
    test { $watch eq '12' }
d596 1
a596 1
	    test { defined $x and $x == 1 }
d610 1
a610 1
    test { $a{7}->()->() + $a{11}->()->() == 18 };
d617 1
a617 3
    my $progfile = "b23265.pl";
    open(T, ">$progfile") or die "$0: $!\n";
    print T << '__EOF__';
a629 4
    close T;
    my $got = runperl(progfile => $progfile);
    test { chomp $got; $got eq "yxx" };
    END { 1 while unlink $progfile }
d636 2
a637 4
    my $got = runperl(stderr => 1, prog => 
'sub d {die} my $f; $f = sub {my $x=1; $f = 0; d}; eval{$f->()}; print qq(ok\n)'
    );
    test { $got eq "ok\n" };
d640 2
a641 1
# After newsub is redefined outside the BEGIN, it's CvOUTSIDE should point
d653 1
a653 1
    test { $flag == 1 };
a655 2
# don't copy a stale lexical; crate a fresh undef one instead

d668 2
a669 1
    test { $r1 != $r2 };
d672 1
d674 11
d686 1
a686 1

@


1.9
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d17 1
a17 1
print "1..187\n";
d466 2
a467 3
	    my $cmdfile = "tcmd$$";  $cmdfile++ while -e $cmdfile;
	    my $errfile = "terr$$";  $errfile++ while -e $errfile;
	    my @@tmpfiles = ($cmdfile, $errfile);
d479 1
a479 2
	      my $outfile = "tout$$";  $outfile++ while -e $outfile;
	      push @@tmpfiles, $outfile;
a484 1
	      $debugging or do { 1 while unlink @@tmpfiles };
a487 1
	    1 while unlink @@tmpfiles;
d687 1
d689 14
@


1.8
log
@merge in perl 5.8.8
@
text
@d259 1
a259 1
    return if index(\$msg, 'may be unavailable') != -1;
d605 2
a606 1
require "./test.pl";
d608 11
a618 1
curr_test(182);
d620 9
a628 2
# Because change #19637 was not applied to 5.8.1.
SKIP: { skip("tests not in 5.8.", 3) }
d630 10
a639 1
$test= 185;
d690 6
@


1.7
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d15 1
d450 2
a451 2
	      exec './perl', '-w', '-'
		or die "Can't exec ./perl: $!";
d470 1
a470 5
	    my $cmd = (($^O eq 'VMS') ? "MCR $^X"
		       : ($^O eq 'MSWin32') ? '.\perl'
		       : ($^O eq 'MacOS') ? $^X
		       : ($^O eq 'NetWare') ? 'perl'
		       : './perl');
a612 2

require './test.pl'; # for runperl()
@


1.6
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d16 1
a16 1
print "1..185\n";
d644 9
d654 14
@


1.5
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d16 1
a16 1
print "1..171\n";
d512 132
@


1.4
log
@merge in perl 5.6.1 with our local changes
@
text
@d7 1
d20 3
a22 1
  print ((&{$_[0]})?"ok $test\n":"not ok $test\n");
d240 2
a241 2
	  $code .= <<"DEBUG_INFO" if $debugging;
# inner_type: $inner_type 
d243 5
a247 5
# within: $within
# nc_attempt: $nc_attempt
# call_inner: $call_inner
# call_outer: $call_outer
# undef_outer: $undef_outer
d268 3
a270 3
      my \$result = &{\$_[0]};
      print "not " unless \$result;
      print "ok \$test\\n";
d435 1
a435 1
	  if ($Config{d_fork} and $^O ne 'VMS' and $^O ne 'MSWin32') {
d471 2
d475 1
a475 1
	    if ($^O eq 'VMS' or $^O eq 'MSWin32') {
d505 1
a505 1
	  print "-" x 30, "\n" if $debugging;
@


1.3
log
@perl-5.6.0 + local changes
@
text
@d10 1
a10 1
    unshift @@INC, '../lib';
@


1.2
log
@perl5.005_03 (stock)
@
text
@d10 1
a10 1
    @@INC = '../lib';
d15 1
a15 1
print "1..169\n";
d159 25
@


1.1
log
@perl 5.004_04
@
text
@d15 1
a15 1
print "1..167\n";
d133 27
d482 1
@


1.1.1.1
log
@perl5.005_03
@
text
@d15 1
a15 1
print "1..169\n";
a132 27
# test if closures get created in optimized for loops

my %foo;
for my $n ('A'..'E') {
    $foo{$n} = sub { $n eq $_[0] };
}

test {
  &{$foo{A}}('A') and
  &{$foo{B}}('B') and
  &{$foo{C}}('C') and
  &{$foo{D}}('D') and
  &{$foo{E}}('E')
};

for my $n (0..4) {
    $foo[$n] = sub { $n == $_[0] };
}

test {
  &{$foo[0]}(0) and
  &{$foo[1]}(1) and
  &{$foo[2]}(2) and
  &{$foo[3]}(3) and
  &{$foo[4]}(4)
};

a454 1

@


1.1.1.2
log
@virgin perl 5.6.0
@
text
@d10 1
a10 1
    unshift @@INC, '../lib';
d15 1
a15 1
print "1..171\n";
a158 25

for my $n (0..4) {
    $foo[$n] = sub {
                     # no intervening reference to $n here
                     sub { $n == $_[0] }
		   };
}

test {
  $foo[0]->()->(0) and
  $foo[1]->()->(1) and
  $foo[2]->()->(2) and
  $foo[3]->()->(3) and
  $foo[4]->()->(4)
};

{
    my $w;
    $w = sub {
	my ($i) = @@_;
	test { $i == 10 };
	sub { $w };
    };
    $w->(10);
}
@


1.1.1.3
log
@stock perl 5.6.1
@
text
@d10 1
a10 1
    @@INC = '../lib';
@


1.1.1.4
log
@stock perl 5.8.0 from CPAN
@
text
@a6 1
#   Run with -debug for debugging output.
d19 1
a19 3
  my $ok = &{$_[0]};
  print $ok ? "ok $test\n" : "not ok $test\n";
  printf "# Failed at line %d\n", (caller)[2] unless $ok;
d237 2
a238 2
	  print <<"DEBUG_INFO" if $debugging;
# inner_type:     $inner_type 
d240 5
a244 5
# within:         $within
# nc_attempt:     $nc_attempt
# call_inner:     $call_inner
# call_outer:     $call_outer
# undef_outer:    $undef_outer
d265 3
a267 3
      my \$ok = &{\$_[0]};
      print \$ok ? "ok \$test\n" : "not ok \$test\n";
      printf "# Failed at line %d\n", (caller)[2] unless \$ok;
d432 1
a432 1
	  if ($Config{d_fork} and $^O ne 'VMS' and $^O ne 'MSWin32' and $^O ne 'NetWare') {
a467 2
		       : ($^O eq 'MacOS') ? $^X
		       : ($^O eq 'NetWare') ? 'perl'
d470 1
a470 1
	    if ($^O eq 'VMS' or $^O eq 'MSWin32' or $^O eq 'NetWare') {
d500 1
a500 1
	  print '#', "-" x 30, "\n" if $debugging;
@


1.1.1.5
log
@perl 5.8.2 from CPAN
@
text
@d16 1
a16 1
print "1..185\n";
a511 132

# The following dumps core with perl <= 5.8.0 (bugid 9535) ...
BEGIN { $vanishing_pad = sub { eval $_[0] } }
$some_var = 123;
test { $vanishing_pad->( '$some_var' ) == 123 };

# ... and here's another coredump variant - this time we explicitly
# delete the sub rather than using a BEGIN ...

sub deleteme { $a = sub { eval '$newvar' } }
deleteme();
*deleteme = sub {}; # delete the sub
$newvar = 123; # realloc the SV of the freed CV
test { $a->() == 123 };

# ... and a further coredump variant - the fixup of the anon sub's
# CvOUTSIDE pointer when the middle eval is freed, wasn't good enough to
# survive the outer eval also being freed.

$x = 123;
$a = eval q(
    eval q[
	sub { eval '$x' }
    ]
);
@@a = ('\1\1\1\1\1\1\1') x 100; # realloc recently-freed CVs
test { $a->() == 123 };

# this coredumped on <= 5.8.0 because evaling the closure caused
# an SvFAKE to be added to the outer anon's pad, which was then grown.
my $outer;
sub {
    my $x;
    $x = eval 'sub { $outer }';
    $x->();
    $a = [ 99 ];
    $x->();
}->();
test {1};

# [perl #17605] found that an empty block called in scalar context
# can lead to stack corruption
{
    my $x = "foooobar";
    $x =~ s/o//eg;
    test { $x eq 'fbar' }
}

# DAPM 24-Nov-02
# SvFAKE lexicals should be visible thoughout a function.
# On <= 5.8.0, the third test failed,  eg bugid #18286

{
    my $x = 1;
    sub fake {
		test { sub {eval'$x'}->() == 1 };
	{ $x;	test { sub {eval'$x'}->() == 1 } }
		test { sub {eval'$x'}->() == 1 };
    }
}
fake();

# undefining a sub shouldn't alter visibility of outer lexicals

{
    $x = 1;
    my $x = 2;
    sub tmp { sub { eval '$x' } }
    my $a = tmp();
    undef &tmp;
    test { $a->() == 2 };
}

# handy class: $x = Watch->new(\$foo,'bar')
# causes 'bar' to be appended to $foo when $x is destroyed
sub Watch::new { bless [ $_[1], $_[2] ], $_[0] }
sub Watch::DESTROY { ${$_[0][0]} .= $_[0][1] }


# bugid 1028:
# nested anon subs (and associated lexicals) not freed early enough

sub linger {
    my $x = Watch->new($_[0], '2');
    sub {
	$x;
	my $y;
	sub { $y; };
    };
}
{
    my $watch = '1';
    linger(\$watch);
    test { $watch eq '12' }
}

require "./test.pl";

curr_test(182);

# Because change #19637 was not applied to 5.8.1.
SKIP: { skip("tests not in 5.8.", 3) }

$test= 185;

require './test.pl'; # for runperl()

{
   # bugid #23265 - this used to coredump during destruction of PL_maincv
   # and its children

    my $progfile = "b23265.pl";
    open(T, ">$progfile") or die "$0: $!\n";
    print T << '__EOF__';
        print
            sub {$_[0]->(@@_)} -> (
                sub {
                    $_[1]
                        ?  $_[0]->($_[0], $_[1] - 1) .  sub {"x"}->()
                        : "y"
                },   
                2
            )
            , "\n"
        ;
__EOF__
    close T;
    my $got = runperl(progfile => $progfile);
    test { chomp $got; $got eq "yxx" };
    END { 1 while unlink $progfile }
}

@


1.1.1.6
log
@Import of stock perl 5.8.5
@
text
@d16 1
a16 1
print "1..187\n";
a643 9
{
    # bugid #24914 = used to coredump restoring PL_comppad in the
    # savestack, due to the early freeing of the anon closure

    my $got = runperl(stderr => 1, prog => 
'sub d {die} my $f; $f = sub {my $x=1; $f = 0; d}; eval{$f->()}; print qq(ok\n)'
    );
    test { $got eq "ok\n" };
}
a644 14
# After newsub is redefined outside the BEGIN, it's CvOUTSIDE should point
# to main rather than BEGIN, and BEGIN should be freed.

{
    my $flag = 0;
    sub  X::DESTROY { $flag = 1 }
    {
	my $x;
	BEGIN {$x = \&newsub }
	sub newsub {};
	$x = bless {}, 'X';
    }
    test { $flag == 1 };
}
@


1.1.1.7
log
@perl 5.8.8 import
@
text
@a14 1
require './test.pl'; # for runperl()
d449 2
a450 2
	      exec which_perl(), '-w', '-'
		or die "Can't exec perl: $!";
d469 5
a473 1
	    my $cmd = which_perl();
d616 2
@


1.1.1.8
log
@import perl 5.10.0 from CPAN
@
text
@d259 1
a259 1
    return if index(\$msg, 'is not available') != -1;
d605 1
a605 2
# bugid 10085
# obj not freed early enough
d607 1
a607 11
sub linger2 { 
    my $obj = Watch->new($_[0], '2');
    sub { sub { $obj } };
}   
{
    my $watch = '1';
    linger2(\$watch);
    test { $watch eq '12' }
}

# bugid 16302 - named subs didn't capture lexicals on behalf of inner subs
d609 2
a610 9
{
    my $x = 1;
    sub f16302 {
	sub {
	    test { defined $x and $x == 1 }
	}->();
    }
}
f16302();
d612 1
a612 10
# The presence of an eval should turn cloneless anon subs into clonable
# subs - otherwise the CvOUTSIDE of that sub may be wrong

{
    my %a;
    for my $x (7,11) {
	$a{$x} = sub { $x=$x; sub { eval '$x' } };
    }
    test { $a{7}->()->() + $a{11}->()->() == 18 };
}
a662 6






@


1.1.1.9
log
@import perl 5.10.1
@
text
@d17 1
a17 1
print "1..188\n";
d466 3
a468 2
	    my $cmdfile = tempfile();
	    my $errfile = tempfile();
d480 2
a481 1
	      my $outfile = tempfile();
d487 1
d491 1
a690 1
# don't copy a stale lexical; crate a fresh undef one instead
a691 14
sub f {
    my $x if $_[0];
    sub { \$x }
}

{
    f(1);
    my $c1= f(0);
    my $c2= f(0);

    my $r1 = $c1->();
    my $r2 = $c2->();
    test { $r1 != $r2 };
}
@


1.1.1.10
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d15 11
a25 1
require './test.pl';
d31 1
a31 1
is(foo, 1);
d33 1
a33 1
is(foo, 2);
d38 1
a38 1
is(&$foo(), 2);
d40 1
a40 1
is(&$foo(), 3);
d42 1
a42 2
is(foo, 3, 'lexical changed');
is($i, 3, 'lexical changed');
d44 1
a44 1
is(&$bar(), 3, 'second closure noticed');
d54 1
a54 1
is(&$foo(), 4);
d56 2
a57 2
is(&$foo(), 6);
is(&$bar(), 5);
d72 1
a72 1
is(&$foo(), 7);
d74 2
a75 2
is(&$foo(), 8);
is(&$bar(), 7);
d79 1
a79 1
is(&$foo(11)-1, &$bar());
d87 7
a93 5
is(&{$foo[0]}(), 0);
is(&{$foo[1]}(), 1);
is(&{$foo[2]}(), 2);
is(&{$foo[3]}(), 3);
is(&{$foo[4]}(), 4);
d99 7
a105 5
is(&{$foo[0]}(), 4);
is(&{$foo[1]}(), 3);
is(&{$foo[2]}(), 2);
is(&{$foo[3]}(), 1);
is(&{$foo[4]}(), 0);
d117 7
a123 5
is(&{$foo[0]}(), 0);
is(&{$foo[1]}(), 1);
is(&{$foo[2]}(), 2);
is(&{$foo[3]}(), 3);
is(&{$foo[4]}(), 4);
d129 7
a135 5
is(&{$foo[0]}(), 4);
is(&{$foo[1]}(), 3);
is(&{$foo[2]}(), 2);
is(&{$foo[3]}(), 1);
is(&{$foo[4]}(), 0);
d144 7
a150 5
ok(&{$foo{A}}('A'));
ok(&{$foo{B}}('B'));
ok(&{$foo{C}}('C'));
ok(&{$foo{D}}('D'));
ok(&{$foo{E}}('E'));
d156 7
a162 5
ok(&{$foo[0]}(0));
ok(&{$foo[1]}(1));
ok(&{$foo[2]}(2));
ok(&{$foo[3]}(3));
ok(&{$foo[4]}(4));
d171 7
a177 5
ok($foo[0]->()->(0));
ok($foo[1]->()->(1));
ok($foo[2]->()->(2));
ok($foo[3]->()->(3));
ok($foo[4]->()->(4));
d183 1
a183 1
	is($i, 10);
a223 1
	  my $test = curr_test();
d266 9
a274 2
require './test.pl';
curr_test($test);
a427 1
	    my $desc = "$inner_type $where_declared $within $inner_sub_test";
d429 1
a429 1
	      $code .= "is(&\$anon_$test, $expected, '$desc');\n"
d431 1
a431 1
	      $code .= "is(&named_$test, $expected, '$desc');\n"
a489 1
	  curr_test($test);
a490 5
	  # This has the side effect of alerting *our* test.pl to the state of
	  # what has just been passed to STDOUT, so that if anything there has
	  # failed, our test.pl will print a diagnostic and exit uncleanly.
	  unlike($output, qr/not ok/, 'All good');
	  is($errors, '', 'STDERR is silent');
d497 1
a497 1
	  is($?, 0, 'exited cleanly') or diag(sprintf "Error code $? = 0x%X", $?);
d509 1
a509 1
is($vanishing_pad->('$some_var'), 123, 'RT #9535');
d518 1
a518 1
is($a->(), 123, 'RT #9535');
d531 1
a531 1
is($a->(), 123, 'RT #9535');
d543 1
a543 1
pass();
d550 1
a550 1
    is($x, 'fbar', 'RT #17605');
d560 3
a562 3
		is(sub {eval'$x'}->(), 1, 'RT #18286');
	{ $x;	is(sub {eval'$x'}->(), 1, 'RT #18286'); }
		is(sub {eval'$x'}->(), 1, 'RT #18286');
d567 2
d575 1
a575 2
    is($a->(), 2,
       "undefining a sub shouldn't alter visibility of outer lexicals");
d583 1
d598 1
a598 1
    is($watch, '12', 'RT #1028');
d611 1
a611 1
    is($watch, 12, 'RT #10085');
d620 1
a620 1
	    is($x, 1, 'RT #16302');
d634 1
a634 1
    is($a{7}->()->() + $a{11}->()->(), 18);
d641 3
a643 1
    fresh_perl_is(<< '__EOF__', "yxx\n", {stderr => 1}, 'RT #23265');
d656 4
d666 4
a669 2
    fresh_perl_is('sub d {die} my $f; $f = sub {my $x=1; $f = 0; d}; eval{$f->()}; print qq(ok\n)',
		  "ok\n", {stderr => 1}, 'RT #24914');
d672 1
a672 2

# After newsub is redefined outside the BEGIN, its CvOUTSIDE should point
d684 1
a684 1
    is($flag, 1);
d687 2
d701 1
a701 2
    isnt($r1, $r2,
	 "don't copy a stale lexical; crate a fresh undef one instead");
a703 1
# [perl #63540] Don’t treat sub { if(){.....}; "constant" } as a constant
a704 11
BEGIN {
  my $x = 7;
  *baz = sub() { if($x){ () = "tralala"; blonk() }; 0 }
}
{
  my $blonk_was_called;
  *blonk = sub { ++$blonk_was_called };
  my $ret = baz();
  is($ret, 0, 'RT #63540');
  is($blonk_was_called, 1, 'RT #63540');
}
d706 1
a706 1
done_testing();
@


1.1.1.11
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@a11 1
    require './test.pl';
d15 1
d657 2
a658 5
    my $x;
    format ff =
@@
$r = \$x
.
d662 6
a667 5
    fileno ff;
    write ff;
    my $r1 = $r;
    write ff;
    my $r2 = $r;
d669 1
a669 1
	 "don't copy a stale lexical; create a fresh undef one instead");
a683 130
}

# test PL_cv_has_eval.  Any anon sub that could conceivably contain an
# eval, should be marked as cloneable

{

    my @@s;
    push @@s, sub {  eval '1' } for 1,2;
    isnt($s[0], $s[1], "cloneable with eval");
    @@s = ();
    push @@s, sub { use re 'eval'; my $x; s/$x/1/; } for 1,2;
    isnt($s[0], $s[1], "cloneable with use re eval");
    @@s = ();
    push @@s, sub { s/1/1/ee; } for 1,2;
    isnt($s[0], $s[1], "cloneable with //ee");
}

# [perl #89544]
{
   sub trace::DESTROY {
       push @@trace::trace, "destroyed";
   }

   my $outer2 = sub {
       my $a = bless \my $dummy, trace::;

       my $outer = sub {
	   my $b;
	   my $inner = sub {
	       undef $b;
	   };

	   $a;

	   $inner
       };

       $outer->()
   };

   my $inner = $outer2->();
   is "@@trace::trace", "destroyed",
      'closures only close over named variables, not entire subs';
}

# [perl #113812] Closure prototypes with no CvOUTSIDE (crash caused by the
#                fix for #89544)
do "./op/closure_test.pl" or die $@@||$!;
is $closure_test::s2->()(), '10 cubes',
  'cloning closure proto with no CvOUTSIDE';

# Also brought up in #113812: Even when being cloned, a closure prototype
# might have its CvOUTSIDE pointing to the wrong thing.
{
    package main::113812;
    $s1 = sub {
	my $x = 3;
	$s2 = sub {
	    $x;
	    $s3 = sub { $x };
	};
    };
    $s1->();
    undef &$s1; # frees $s2’s prototype, causing the $s3 proto to have its
                # CvOUTSIDE point to $s1
    ::is $s2->()(), 3, 'cloning closure proto whose CvOUTSIDE has changed';
}

# This should never emit two different values:
#     print $x, "\n";
#     print sub { $x }->(), "\n";
# This test case started to do just that in commit 33894c1aa3e
# (5.10.1/5.12.0):
sub mosquito {
    my $x if @@_;
    return if @@_;

    $x = 17;
    is sub { $x }->(), $x, 'closing over stale var in 2nd sub call';
}
mosquito(1);
mosquito;
# And this case in commit adf8f095c588 (5.14):
sub anything {
    my $x;
    sub gnat {
	$x = 3;
	is sub { $x }->(), $x,
	    'closing over stale var before 1st sub call';
    }
}
gnat();

# [perl #114018] Similar to the above, but with string eval
sub staleval {
    my $x if @@_;
    return if @@_;

    $x = 3;
    is eval '$x', $x, 'eval closing over stale var in active sub';
    return # 
}
staleval 1;
staleval;

# [perl #114888]
# Test that closure creation localises PL_comppad_name properly.  Usually
# at compile time a BEGIN block will localise PL_comppad_name for use, so
# pp_anoncode can mess with it without any visible effects.
# But inside a source filter, it affects the directly enclosing compila-
# tion scope.
SKIP: {
    skip_if_miniperl("no XS on miniperl (for source filters)");
    fresh_perl_is <<'    [perl #114888]', "ok\n", {stderr=>1},
	use strict;
	BEGIN {
	    package Foo;
	    use Filter::Util::Call;
	    sub import { filter_add( sub {
		my $status = filter_read();
		sub { $status };
		$status;
	    })}
	    Foo->import
	}
	my $x = "ok\n";	# stores $x in the wrong padnamelist
	print $x;	# cannot find it - strict violation
    [perl #114888]
        'closures in source filters do not interfere with pad names';
@


