head	1.2;
access;
symbols
	OPENBSD_6_2_BASE:1.2
	PERL_5_24_2:1.1.1.7
	OPENBSD_6_1:1.2.0.4
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.6.0.10
	OPENBSD_6_0_BASE:1.1.1.6
	OPENBSD_5_9:1.1.1.6.0.4
	OPENBSD_5_9_BASE:1.1.1.6
	OPENBSD_5_8:1.1.1.6.0.6
	OPENBSD_5_8_BASE:1.1.1.6
	PERL_5_20_2:1.1.1.6
	OPENBSD_5_7:1.1.1.6.0.2
	OPENBSD_5_7_BASE:1.1.1.6
	PERL_5_20_1:1.1.1.6
	OPENBSD_5_6:1.1.1.5.0.4
	OPENBSD_5_6_BASE:1.1.1.5
	PERL_5_18_2:1.1.1.5
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.4.0.6
	OPENBSD_5_5_BASE:1.1.1.4
	OPENBSD_5_4:1.1.1.4.0.2
	OPENBSD_5_4_BASE:1.1.1.4
	PERL_5_16_3:1.1.1.4
	OPENBSD_5_3:1.1.1.3.0.10
	OPENBSD_5_3_BASE:1.1.1.3
	OPENBSD_5_2:1.1.1.3.0.8
	OPENBSD_5_2_BASE:1.1.1.3
	OPENBSD_5_1_BASE:1.1.1.3
	OPENBSD_5_1:1.1.1.3.0.6
	OPENBSD_5_0:1.1.1.3.0.4
	OPENBSD_5_0_BASE:1.1.1.3
	OPENBSD_4_9:1.1.1.3.0.2
	OPENBSD_4_9_BASE:1.1.1.3
	PERL_5_12_2:1.1.1.3
	OPENBSD_4_8:1.1.1.2.0.8
	OPENBSD_4_8_BASE:1.1.1.2
	OPENBSD_4_7:1.1.1.2.0.4
	OPENBSD_4_7_BASE:1.1.1.2
	PERL_5_10_1:1.1.1.2
	OPENBSD_4_6:1.1.1.2.0.6
	OPENBSD_4_6_BASE:1.1.1.2
	OPENBSD_4_5:1.1.1.2.0.2
	OPENBSD_4_5_BASE:1.1.1.2
	PERL_5_10_0:1.1.1.2
	OPENBSD_4_4:1.1.1.1.0.20
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.18
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.16
	OPENBSD_4_2_BASE:1.1.1.1
	OPENBSD_4_1:1.1.1.1.0.14
	OPENBSD_4_1_BASE:1.1.1.1
	OPENBSD_4_0:1.1.1.1.0.12
	OPENBSD_4_0_BASE:1.1.1.1
	PERL_5_8_8:1.1.1.1
	OPENBSD_3_9:1.1.1.1.0.10
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.8
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.6
	OPENBSD_3_7_BASE:1.1.1.1
	PERL_5_8_6:1.1.1.1
	OPENBSD_3_6:1.1.1.1.0.4
	OPENBSD_3_6_BASE:1.1.1.1
	PERL_5_8_5:1.1.1.1
	PERL_5_8_3:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.2
	OPENBSD_3_5_BASE:1.1.1.1
	PERL_5_8_2:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.32.20;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2003.12.03.02.44.32;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.12.03.02.44.32;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2008.09.29.17.19.02;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2010.09.24.14.49.16;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2013.03.25.20.09.37;	author sthen;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2014.03.24.14.59.10;	author afresh1;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2014.11.17.20.53.18;	author afresh1;	state Exp;
branches;
next	1.1.1.7;
commitid	B31cAbBIXiCqnL97;

1.1.1.7
date	2017.08.14.13.46.24;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl

BEGIN {
    chdir 't' if -d 't';
    @@INC = qw(../lib);
}

BEGIN { require "./test.pl"; }

plan( tests => 51 );

# Used to segfault (bug #15479)
fresh_perl_like(
    'delete $::{STDERR}; my %a = ""',
    qr/Odd number of elements in hash assignment at - line 1\./,
    { switches => [ '-w' ] },
    'delete $::{STDERR} and print a warning',
);

# Used to segfault
fresh_perl_is(
    'BEGIN { $::{"X::"} = 2 }',
    '',
    { switches => [ '-w' ] },
    q(Insert a non-GV in a stash, under warnings 'once'),
);

# Used to segfault, too
SKIP: {
 skip_if_miniperl('requires XS');
  fresh_perl_like(
    'sub foo::bar{}; $mro::{get_mro}=*foo::bar; undef %foo::; require mro',
     qr/^Subroutine mro::get_mro redefined at /,
    { switches => [ '-w' ] },
    q(Defining an XSUB over an existing sub with no stash under warnings),
  );
}

package tyrone::slothrop;
$bongo::shaftsbury::scalar = 1;

package main;

# Used to warn
# Unbalanced string table refcount: (1) for "A::" during global destruction.
# for ithreads.
{
    local $ENV{PERL_DESTRUCT_LEVEL} = 2;
    fresh_perl_is(
		  'package A::B; sub a { // }; %A::=""',
		  '',
		  {},
		  );
    # Variant of the above which creates an object that persists until global
    # destruction, and triggers an assertion failure prior to change
    # a420522db95b7762
    fresh_perl_is(
		  'use Exporter; package A; sub a { // }; delete $::{$_} for keys %::',
		  '',
		  {},
		  );
}

# now tests with strictures

{
    use strict;
    ok( !exists $pig::{bodine}, q(referencing a non-existent stash element doesn't produce stricture errors) );
}

SKIP: {
    eval { require B; 1 } or skip "no B", 29;

    *b = \&B::svref_2object;
    my $CVf_ANON = B::CVf_ANON();

    my $sub = do {
        package one;
        \&{"one"};
    };
    delete $one::{one};
    my $gv = b($sub)->GV;

    object_ok( $gv, "B::GV", "deleted stash entry leaves CV with valid GV");
    is( b($sub)->CvFLAGS & $CVf_ANON, $CVf_ANON, "...and CVf_ANON set");
    is( eval { $gv->NAME }, "__ANON__", "...and an __ANON__ name");
    is( eval { $gv->STASH->NAME }, "one", "...but leaves stash intact");

    $sub = do {
        package two;
        \&{"two"};
    };
    %two:: = ();
    $gv = b($sub)->GV;

    object_ok( $gv, "B::GV", "cleared stash leaves CV with valid GV");
    is( b($sub)->CvFLAGS & $CVf_ANON, $CVf_ANON, "...and CVf_ANON set");
    is( eval { $gv->NAME }, "__ANON__", "...and an __ANON__ name");
    is( eval { $gv->STASH->NAME }, "two", "...but leaves stash intact");

    $sub = do {
        package three;
        \&{"three"};
    };
    undef %three::;
    $gv = b($sub)->GV;

    object_ok( $gv, "B::GV", "undefed stash leaves CV with valid GV");
    is( b($sub)->CvFLAGS & $CVf_ANON, $CVf_ANON, "...and CVf_ANON set");
    is( eval { $gv->NAME }, "__ANON__", "...and an __ANON__ name");
    is( eval { $gv->STASH->NAME }, "__ANON__", "...and an __ANON__ stash");

    my $sub = do {
	package four;
	sub { 1 };
    };
    %four:: = ();

    my $gv = B::svref_2object($sub)->GV;
    ok($gv->isa(q/B::GV/), "cleared stash leaves anon CV with valid GV");

    my $st = eval { $gv->STASH->NAME };
    is($st, q/four/, "...but leaves the stash intact");

    my $sub = do {
	package five;
	sub { 1 };
    };
    undef %five::;

    $gv = B::svref_2object($sub)->GV;
    ok($gv->isa(q/B::GV/), "undefed stash leaves anon CV with valid GV");

    $st = eval { $gv->STASH->NAME };
    { local $TODO = 'STASHES not anonymized';
	is($st, q/__ANON__/, "...and an __ANON__ stash");
    }

    my $sub = do {
	package six;
	\&{"six"}
    };
    my $stash_glob = delete $::{"six::"};
    # Now free the GV while the stash still exists (though detached)
    delete $$stash_glob{"six"};
    $gv = B::svref_2object($sub)->GV;
    ok($gv->isa(q/B::GV/),
       'anonymised CV whose stash is detached still has a GV');
    is $gv->STASH->NAME, '__ANON__',
     'CV anonymised when its stash is detached becomes __ANON__::__ANON__';

    # CvSTASH should be null on a named sub if the stash has been deleted
    {
	package FOO;
	sub foo {}
	my $rfoo = \&foo;
	package main;
	delete $::{'FOO::'};
	my $cv = B::svref_2object($rfoo);
	# (is there a better way of testing for NULL ?)
	my $stash = $cv->STASH;
	like($stash, qr/B::SPECIAL/, "NULL CvSTASH on named sub");
    }

    # on glob reassignment, orphaned CV should have anon CvGV

    {
	my $r;
	eval q[
	    package FOO2;
	    sub f{};
	    $r = \&f;
	    *f = sub {};
	];
	delete $FOO2::{f};
	my $cv = B::svref_2object($r);
	my $gv = $cv->GV;
	ok($gv->isa(q/B::GV/), "orphaned CV has valid GV");
	is($gv->NAME, '__ANON__', "orphaned CV has anon GV");
    }

    # deleting __ANON__ glob shouldn't break things

    {
	package FOO3;
	sub named {};
	my $anon = sub {};
	my $named = eval q[\&named];
	package main;
	delete $FOO3::{named}; # make named anonymous

	delete $FOO3::{__ANON__}; # whoops!
	my ($cv,$gv);
	$cv = B::svref_2object($named);
	$gv = $cv->GV;
	ok($gv->isa(q/B::GV/), "ex-named CV has valid GV");
	is($gv->NAME, '__ANON__', "ex-named CV has anon GV");

	$cv = B::svref_2object($anon);
	$gv = $cv->GV;
	ok($gv->isa(q/B::GV/), "anon CV has valid GV");
	is($gv->NAME, '__ANON__', "anon CV has anon GV");
    }

    {
	my $r;
	{
	    package bloop;

	    BEGIN {
		$r = \&main::whack;
	    }
	}

	my $br = B::svref_2object($r);
	is ($br->STASH->NAME, 'bloop',
	    'stub records the package it was compiled in');
	# Arguably this shouldn't quite be here, but it's easy to add it
	# here, and tricky to figure out a different good place for it.
	like ($br->FILE, qr/stash/i,
	      'stub records the file it was compiled in');

	# We need to take this reference "late", after the subroutine is
	# defined.
	$br = B::svref_2object(eval 'sub whack {}; \&whack');
	die $@@ if $@@;

	is ($br->STASH->NAME, 'main',
	    'definition overrides the package it was compiled in');
	like ($br->FILE, qr/eval/,
	      'definition overrides the file it was compiled in');
    }
}

# [perl #58530]
fresh_perl_is(
    'sub foo { 1 }; use overload q/""/ => \&foo;' .
        'delete $main::{foo}; bless []',
    "",
    {},
    "no segfault with overload/deleted stash entry [#58530]",
);

# make sure having a sub called __ANON__ doesn't confuse perl.

{
    my $c;
    sub __ANON__ { $c = (caller(0))[3]; }
    __ANON__();
    is ($c, 'main::__ANON__', '__ANON__ sub called ok');
}


# Stashes that are effectively renamed
{
    package rile;

    use Config;

    my $obj  = bless [];
    my $globref = \*tat;

    # effectively rename a stash
    *slin:: = *rile::; *rile:: = *zor::;
    
    ::is *$globref, "*rile::tat",
     'globs stringify the same way when stashes are moved';
    ::is ref $obj, "rile",
     'ref() returns the same thing when an object\'s stash is moved';
    ::like "$obj", qr "^rile=ARRAY\(0x[\da-f]+\)\z",
     'objects stringify the same way when their stashes are moved';
    ::is eval '__PACKAGE__', 'rile',
	 '__PACKAGE__ returns the same when the current stash is moved';

    # Now detach it completely from the symtab, making it effect-
    # ively anonymous
    my $life_raft = \%slin::;
    *slin:: = *zor::;

    ::is *$globref, "*rile::tat",
     'globs stringify the same way when stashes are detached';
    ::is ref $obj, "rile",
     'ref() returns the same thing when an object\'s stash is detached';
    ::like "$obj", qr "^rile=ARRAY\(0x[\da-f]+\)\z",
     'objects stringify the same way when their stashes are detached';
    ::is eval '__PACKAGE__', 'rile',
	 '__PACKAGE__ returns the same when the current stash is detached';
}

# Setting the name during undef %stash:: should have no effect.
{
    my $glob = \*Phoo::glob;
    sub o::DESTROY { eval '++$Phoo::bar' }
    no strict 'refs';
    ${"Phoo::thing1"} = bless [], "o";
    undef %Phoo::;
    is "$$glob", "*__ANON__::glob",
      "setting stash name during undef has no effect";
}

# [perl #88134] incorrect package structure
{
    package Bear::;
    sub baz{1}
    package main;
    ok eval { Bear::::baz() },
     'packages ending with :: are self-consistent';
}

# [perl #88138] ' not equivalent to :: before a null
${"a'\0b"} = "c";
is ${"a::\0b"}, "c", "' is equivalent to :: before a null";

# [perl #101486] Clobbering the current package
ok eval '
     package Do;
     BEGIN { *Do:: = *Re:: }
     sub foo{};
     1
  ', 'no crashing or errors when clobbering the current package';

# Bareword lookup should not vivify stashes
is runperl(
    prog =>
      'sub foo { print shift, qq-\n- } SUPER::foo bar if 0; foo SUPER',
    stderr => 1,
   ),
   "SUPER\n",
   'bareword lookup does not vivify stashes';

is runperl(
    prog => '%0; *bar::=*foo::=0; print qq|ok\n|',
    stderr => 1,
   ),
   "ok\n",
   '[perl #123847] no crash from *foo::=*bar::=*glob_with_hash';
@


1.1
log
@Initial revision
@
text
@d8 1
a8 1
require "./test.pl";
d10 1
a10 1
plan( tests => 2 );
d13 3
a15 3
fresh_perl_is(
    '%:: = ""',
    'Odd number of elements in hash assignment at - line 1.',
d27 310
@


1.1.1.1
log
@perl 5.8.2 from CPAN
@
text
@@


1.1.1.2
log
@import perl 5.10.0 from CPAN
@
text
@d8 1
a8 1
BEGIN { require "./test.pl"; }
d10 1
a10 1
plan( tests => 13 );
a26 37

ok( !defined %oedipa::maas::, q(stashes aren't defined if not used) );
ok( !defined %{"oedipa::maas::"}, q(- work with hard refs too) );

ok( defined %tyrone::slothrop::, q(stashes are defined if seen at compile time) );
ok( defined %{"tyrone::slothrop::"}, q(- work with hard refs too) );

ok( defined %bongo::shaftsbury::, q(stashes are defined if a var is seen at compile time) );
ok( defined %{"bongo::shaftsbury::"}, q(- work with hard refs too) );

package tyrone::slothrop;
$bongo::shaftsbury::scalar = 1;

package main;

# Used to warn
# Unbalanced string table refcount: (1) for "A::" during global destruction.
# for ithreads.
{
    local $ENV{PERL_DESTRUCT_LEVEL} = 2;
    fresh_perl_is(
		  'package A; sub a { // }; %::=""',
		  '',
		  '',
		  );
}

# now tests in eval

ok( !eval  { defined %achtfaden:: },   'works in eval{}' );
ok( !eval q{ defined %schoenmaker:: }, 'works in eval("")' );

# now tests with strictures

use strict;
ok( !defined %pig::, q(referencing a non-existent stash doesn't produce stricture errors) );
ok( !exists $pig::{bodine}, q(referencing a non-existent stash element doesn't produce stricture errors) );
@


1.1.1.3
log
@Perl 5.12.2 from CPAN
@
text
@d10 1
a10 1
plan( tests => 31 );
d13 1
a13 1
fresh_perl_like(
d15 1
a15 1
    qr/Odd number of elements in hash assignment at - line 1\./,
d28 2
a29 4
{
    no warnings 'deprecated';
    ok( !defined %oedipa::maas::, q(stashes aren't defined if not used) );
    ok( !defined %{"oedipa::maas::"}, q(- work with hard refs too) );
d31 2
a32 2
    ok( defined %tyrone::slothrop::, q(stashes are defined if seen at compile time) );
    ok( defined %{"tyrone::slothrop::"}, q(- work with hard refs too) );
d34 2
a35 3
    ok( defined %bongo::shaftsbury::, q(stashes are defined if a var is seen at compile time) );
    ok( defined %{"bongo::shaftsbury::"}, q(- work with hard refs too) );
}
d56 2
a57 2
ok( !eval  { no warnings 'deprecated'; defined %achtfaden:: },   'works in eval{}' );
ok( !eval q{ no warnings 'deprecated'; defined %schoenmaker:: }, 'works in eval("")' );
d61 3
a63 108
{
    use strict;
    no warnings 'deprecated';
    ok( !defined %pig::, q(referencing a non-existent stash doesn't produce stricture errors) );
    ok( !exists $pig::{bodine}, q(referencing a non-existent stash element doesn't produce stricture errors) );
}

SKIP: {
    eval { require B; 1 } or skip "no B", 18;

    *b = \&B::svref_2object;
    my $CVf_ANON = B::CVf_ANON();

    my $sub = do {
        package one;
        \&{"one"};
    };
    delete $one::{one};
    my $gv = b($sub)->GV;

    isa_ok( $gv, "B::GV", "deleted stash entry leaves CV with valid GV");
    is( b($sub)->CvFLAGS & $CVf_ANON, $CVf_ANON, "...and CVf_ANON set");
    is( eval { $gv->NAME }, "__ANON__", "...and an __ANON__ name");
    is( eval { $gv->STASH->NAME }, "one", "...but leaves stash intact");

    $sub = do {
        package two;
        \&{"two"};
    };
    %two:: = ();
    $gv = b($sub)->GV;

    isa_ok( $gv, "B::GV", "cleared stash leaves CV with valid GV");
    is( b($sub)->CvFLAGS & $CVf_ANON, $CVf_ANON, "...and CVf_ANON set");
    is( eval { $gv->NAME }, "__ANON__", "...and an __ANON__ name");
    is( eval { $gv->STASH->NAME }, "__ANON__", "...and an __ANON__ stash");

    $sub = do {
        package three;
        \&{"three"};
    };
    undef %three::;
    $gv = b($sub)->GV;

    isa_ok( $gv, "B::GV", "undefed stash leaves CV with valid GV");
    is( b($sub)->CvFLAGS & $CVf_ANON, $CVf_ANON, "...and CVf_ANON set");
    is( eval { $gv->NAME }, "__ANON__", "...and an __ANON__ name");
    is( eval { $gv->STASH->NAME }, "__ANON__", "...and an __ANON__ stash");

    TODO: {
        local $TODO = "anon CVs not accounted for yet";

        my @@results = split "\n", runperl(
            switches    => [ "-MB", "-l" ],
            prog        => q{
                my $sub = do {
                    package four;
                    sub { 1 };
                };
                %four:: = ();

                my $gv = B::svref_2object($sub)->GV;
                print $gv->isa(q/B::GV/) ? q/ok/ : q/not ok/;

                my $st = eval { $gv->STASH->NAME };
                print $st eq q/__ANON__/ ? q/ok/ : q/not ok/;

                my $sub = do {
                    package five;
                    sub { 1 };
                };
                undef %five::;

                $gv = B::svref_2object($sub)->GV;
                print $gv->isa(q/B::GV/) ? q/ok/ : q/not ok/;

                $st = eval { $gv->STASH->NAME };
                print $st eq q/__ANON__/ ? q/ok/ : q/not ok/;

                print q/done/;
            },
            ($^O eq 'VMS') ? (stderr => 1) : ()
        );

        ok( @@results == 5 && $results[4] eq "done",
            "anon CVs in undefed stash don't segfault" )
            or todo_skip $TODO, 4;

        ok( $results[0] eq "ok", 
            "cleared stash leaves anon CV with valid GV");
        ok( $results[1] eq "ok",
            "...and an __ANON__ stash");
            
        ok( $results[2] eq "ok", 
            "undefed stash leaves anon CV with valid GV");
        ok( $results[3] eq "ok",
            "...and an __ANON__ stash");
    }
    
    # [perl #58530]
    fresh_perl_is(
        'sub foo { 1 }; use overload q/""/ => \&foo;' .
            'delete $main::{foo}; bless []',
        "",
        {},
        "no segfault with overload/deleted stash entry [#58530]",
    );
}
@


1.1.1.4
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d10 1
a10 1
plan( tests => 57 );
a27 11
# Used to segfault, too
SKIP: {
 skip_if_miniperl('requires XS');
  fresh_perl_like(
    'sub foo::bar{}; $mro::{get_mro}=*foo::bar; undef %foo::; require mro',
     qr/^Subroutine mro::get_mro redefined at /,
    { switches => [ '-w' ] },
    q(Defining an XSUB over an existing sub with no stash under warnings),
  );
}

d30 2
a31 2
    ok( defined %oedipa::maas::, q(stashes happen to be defined if not used) );
    ok( defined %{"oedipa::maas::"}, q(- work with hard refs too) );
d59 2
a60 2
ok( eval  { no warnings 'deprecated'; defined %achtfaden:: },   'works in eval{}' );
ok( eval q{ no warnings 'deprecated'; defined %schoenmaker:: }, 'works in eval("")' );
d67 1
a67 1
    ok( defined %pig::, q(referencing a non-existent stash doesn't produce stricture errors) );
d72 1
a72 1
    eval { require B; 1 } or skip "no B", 29;
d84 1
a84 1
    object_ok( $gv, "B::GV", "deleted stash entry leaves CV with valid GV");
d96 1
a96 1
    object_ok( $gv, "B::GV", "cleared stash leaves CV with valid GV");
d99 1
a99 1
    is( eval { $gv->STASH->NAME }, "two", "...but leaves stash intact");
d108 1
a108 1
    object_ok( $gv, "B::GV", "undefed stash leaves CV with valid GV");
d113 2
a114 91
    my $sub = do {
	package four;
	sub { 1 };
    };
    %four:: = ();

    my $gv = B::svref_2object($sub)->GV;
    ok($gv->isa(q/B::GV/), "cleared stash leaves anon CV with valid GV");

    my $st = eval { $gv->STASH->NAME };
    is($st, q/four/, "...but leaves the stash intact");

    my $sub = do {
	package five;
	sub { 1 };
    };
    undef %five::;

    $gv = B::svref_2object($sub)->GV;
    ok($gv->isa(q/B::GV/), "undefed stash leaves anon CV with valid GV");

    $st = eval { $gv->STASH->NAME };
    { local $TODO = 'STASHES not anonymized';
	is($st, q/__ANON__/, "...and an __ANON__ stash");
    }

    my $sub = do {
	package six;
	\&{"six"}
    };
    my $stash_glob = delete $::{"six::"};
    # Now free the GV while the stash still exists (though detached)
    delete $$stash_glob{"six"};
    $gv = B::svref_2object($sub)->GV;
    ok($gv->isa(q/B::GV/),
       'anonymised CV whose stash is detached still has a GV');
    is $gv->STASH->NAME, '__ANON__',
     'CV anonymised when its stash is detached becomes __ANON__::__ANON__';

    # CvSTASH should be null on a named sub if the stash has been deleted
    {
	package FOO;
	sub foo {}
	my $rfoo = \&foo;
	package main;
	delete $::{'FOO::'};
	my $cv = B::svref_2object($rfoo);
	# (is there a better way of testing for NULL ?)
	my $stash = $cv->STASH;
	like($stash, qr/B::SPECIAL/, "NULL CvSTASH on named sub");
    }

    # on glob reassignment, orphaned CV should have anon CvGV

    {
	my $r;
	eval q[
	    package FOO2;
	    sub f{};
	    $r = \&f;
	    *f = sub {};
	];
	delete $FOO2::{f};
	my $cv = B::svref_2object($r);
	my $gv = $cv->GV;
	ok($gv->isa(q/B::GV/), "orphaned CV has valid GV");
	is($gv->NAME, '__ANON__', "orphaned CV has anon GV");
    }

    # deleting __ANON__ glob shouldn't break things

    {
	package FOO3;
	sub named {};
	my $anon = sub {};
	my $named = eval q[\&named];
	package main;
	delete $FOO3::{named}; # make named anonymous

	delete $FOO3::{__ANON__}; # whoops!
	my ($cv,$gv);
	$cv = B::svref_2object($named);
	$gv = $cv->GV;
	ok($gv->isa(q/B::GV/), "ex-named CV has valid GV");
	is($gv->NAME, '__ANON__', "ex-named CV has anon GV");

	$cv = B::svref_2object($anon);
	$gv = $cv->GV;
	ok($gv->isa(q/B::GV/), "anon CV has valid GV");
	is($gv->NAME, '__ANON__', "anon CV has anon GV");
    }
d116 45
a160 27
    {
	my $r;
	{
	    package bloop;

	    BEGIN {
		$r = \&main::whack;
	    }
	}

	my $br = B::svref_2object($r);
	is ($br->STASH->NAME, 'bloop',
	    'stub records the package it was compiled in');
	# Arguably this shouldn't quite be here, but it's easy to add it
	# here, and tricky to figure out a different good place for it.
	like ($br->FILE, qr/stash/i,
	      'stub records the file it was compiled in');

	# We need to take this reference "late", after the subroutine is
	# defined.
	$br = B::svref_2object(eval 'sub whack {}; \&whack');
	die $@@ if $@@;

	is ($br->STASH->NAME, 'main',
	    'definition overrides the package it was compiled in');
	like ($br->FILE, qr/eval/,
	      'definition overrides the file it was compiled in');
a161 32
}

# [perl #58530]
fresh_perl_is(
    'sub foo { 1 }; use overload q/""/ => \&foo;' .
        'delete $main::{foo}; bless []',
    "",
    {},
    "no segfault with overload/deleted stash entry [#58530]",
);

# make sure having a sub called __ANON__ doesn't confuse perl.

{
    my $c;
    sub __ANON__ { $c = (caller(0))[3]; }
    __ANON__();
    is ($c, 'main::__ANON__', '__ANON__ sub called ok');
}


# Stashes that are effectively renamed
{
    package rile;

    use Config;

    my $obj  = bless [];
    my $globref = \*tat;

    # effectively rename a stash
    *slin:: = *rile::; *rile:: = *zor::;
d163 8
a170 48
    ::is *$globref, "*rile::tat",
     'globs stringify the same way when stashes are moved';
    ::is ref $obj, "rile",
     'ref() returns the same thing when an object’s stash is moved';
    ::like "$obj", qr "^rile=ARRAY\(0x[\da-f]+\)\z",
     'objects stringify the same way when their stashes are moved';
    {
	local $::TODO =  $Config{useithreads} ? "fails under threads" : undef;
	::is eval '__PACKAGE__', 'rile',
	 '__PACKAGE__ returns the same when the current stash is moved';
    }

    # Now detach it completely from the symtab, making it effect-
    # ively anonymous
    my $life_raft = \%slin::;
    *slin:: = *zor::;

    ::is *$globref, "*rile::tat",
     'globs stringify the same way when stashes are detached';
    ::is ref $obj, "rile",
     'ref() returns the same thing when an object’s stash is detached';
    ::like "$obj", qr "^rile=ARRAY\(0x[\da-f]+\)\z",
     'objects stringify the same way when their stashes are detached';
    {
	local $::TODO =  $Config{useithreads} ? "fails under threads" : undef;
	::is eval '__PACKAGE__', 'rile',
	 '__PACKAGE__ returns the same when the current stash is detached';
    }
}

# Setting the name during undef %stash:: should have no effect.
{
    my $glob = \*Phoo::glob;
    sub o::DESTROY { eval '++$Phoo::bar' }
    no strict 'refs';
    ${"Phoo::thing1"} = bless [], "o";
    undef %Phoo::;
    is "$$glob", "*__ANON__::glob",
      "setting stash name during undef has no effect";
}

# [perl #88134] incorrect package structure
{
    package Bear::;
    sub baz{1}
    package main;
    ok eval { Bear::::baz() },
     'packages ending with :: are self-consistent';
a171 12

# [perl #88138] ' not equivalent to :: before a null
${"a'\0b"} = "c";
is ${"a::\0b"}, "c", "' is equivalent to :: before a null";

# [perl #101486] Clobbering the current package
ok eval '
     package Do;
     BEGIN { *Do:: = *Re:: }
     sub foo{};
     1
  ', 'no crashing or errors when clobbering the current package';
@


1.1.1.5
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d10 1
a10 1
plan( tests => 58 );
a65 7
    # Variant of the above which creates an object that persists until global
    # destruction.
    fresh_perl_is(
		  'use Exporter; package A; sub a { // }; %::=""',
		  '',
		  '',
		  );
d283 3
a285 1
    ::is eval '__PACKAGE__', 'rile',
d287 1
d300 3
a302 1
    ::is eval '__PACKAGE__', 'rile',
d304 1
@


1.1.1.6
log
@Import perl-5.20.1
@
text
@d14 1
a14 1
    'delete $::{STDERR}; my %a = ""',
d62 2
a63 1
		  'package A::B; sub a { // }; %A::=""',
a64 1
		  {},
d67 1
a67 2
    # destruction, and triggers an assertion failure prior to change
    # a420522db95b7762
d69 2
a70 1
		  'use Exporter; package A; sub a { // }; delete $::{$_} for keys %::',
a71 1
		  {},
@


1.1.1.7
log
@Import perl-5.24.2
@
text
@d10 1
a10 1
plan( tests => 51 );
d39 12
d76 5
d85 2
d288 1
a288 1
     'ref() returns the same thing when an object\'s stash is moved';
d302 1
a302 1
     'ref() returns the same thing when an object\'s stash is detached';
a339 16

# Bareword lookup should not vivify stashes
is runperl(
    prog =>
      'sub foo { print shift, qq-\n- } SUPER::foo bar if 0; foo SUPER',
    stderr => 1,
   ),
   "SUPER\n",
   'bareword lookup does not vivify stashes';

is runperl(
    prog => '%0; *bar::=*foo::=0; print qq|ok\n|',
    stderr => 1,
   ),
   "ok\n",
   '[perl #123847] no crash from *foo::=*bar::=*glob_with_hash';
@


