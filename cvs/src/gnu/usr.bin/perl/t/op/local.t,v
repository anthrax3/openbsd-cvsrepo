head	1.14;
access;
symbols
	OPENBSD_6_2_BASE:1.14
	PERL_5_24_2:1.1.1.13
	OPENBSD_6_1:1.14.0.4
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.13.0.10
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.4
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.13.0.6
	OPENBSD_5_8_BASE:1.13
	PERL_5_20_2:1.1.1.12
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	PERL_5_20_1:1.1.1.12
	OPENBSD_5_6:1.12.0.4
	OPENBSD_5_6_BASE:1.12
	PERL_5_18_2:1.1.1.11
	PERL:1.1.1
	OPENBSD_5_5:1.11.0.6
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.2
	OPENBSD_5_4_BASE:1.11
	PERL_5_16_3:1.1.1.10
	OPENBSD_5_3:1.10.0.10
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.8
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.6
	OPENBSD_5_0:1.10.0.4
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.2
	OPENBSD_4_9_BASE:1.10
	PERL_5_12_2:1.1.1.9
	OPENBSD_4_8:1.9.0.4
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.2
	OPENBSD_4_7_BASE:1.9
	PERL_5_10_1:1.1.1.8
	OPENBSD_4_6:1.8.0.6
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.2
	OPENBSD_4_5_BASE:1.8
	PERL_5_10_0:1.1.1.7
	OPENBSD_4_4:1.7.0.10
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.8
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.6
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.4
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.2
	OPENBSD_4_0_BASE:1.7
	PERL_5_8_8:1.1.1.6
	OPENBSD_3_9:1.6.0.10
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.8
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.6
	OPENBSD_3_7_BASE:1.6
	PERL_5_8_6:1.1.1.5
	OPENBSD_3_6:1.6.0.4
	OPENBSD_3_6_BASE:1.6
	PERL_5_8_5:1.1.1.5
	PERL_5_8_3:1.1.1.5
	OPENBSD_3_5:1.6.0.2
	OPENBSD_3_5_BASE:1.6
	PERL_5_8_2:1.1.1.5
	OPENBSD_3_4:1.5.0.4
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.4.0.6
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.4
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.3.0.8
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.6
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.4
	OPENBSD_2_7_BASE:1.3
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.14
date	2017.02.05.00.32.20;	author afresh1;	state Exp;
branches;
next	1.13;
commitid	cxJ08BvJA9Pt2PTM;

1.13
date	2014.11.17.20.57.07;	author afresh1;	state Exp;
branches;
next	1.12;
commitid	QP75iYx42Uo7mMxO;

1.12
date	2014.03.24.15.05.33;	author afresh1;	state Exp;
branches;
next	1.11;

1.11
date	2013.03.25.20.40.59;	author sthen;	state Exp;
branches;
next	1.10;

1.10
date	2010.09.24.15.07.08;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2009.10.12.18.30.27;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2008.09.29.17.36.19;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2006.03.28.19.23.12;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2003.12.03.03.02.48;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.10.27.22.25.37;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.24.18.36.19;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.52.36;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.08.05.27;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.13.19;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.13.19;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.41.46;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.05.24.18.25.40;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.27.22.15.10;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.12.03.02.44.32;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2006.03.28.18.49.45;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2008.09.29.17.19.01;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2009.10.12.18.10.44;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2010.09.24.14.49.17;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2013.03.25.20.09.36;	author sthen;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2014.03.24.14.59.10;	author afresh1;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2014.11.17.20.53.18;	author afresh1;	state Exp;
branches;
next	1.1.1.13;
commitid	B31cAbBIXiCqnL97;

1.1.1.13
date	2017.08.14.13.46.24;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.14
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl

BEGIN {
    chdir 't' if -d 't';
    @@INC = qw(. ../lib);
    require './test.pl';
}
plan tests => 310;

my $list_assignment_supported = 1;

#mg.c says list assignment not supported on VMS and SYMBIAN.
$list_assignment_supported = 0 if ($^O eq 'VMS');


sub foo {
    local($a, $b) = @@_;
    local($c, $d);
    $c = "c 3";
    $d = "d 4";
    { local($a,$c) = ("a 9", "c 10"); ($x, $y) = ($a, $c); }
    is($a, "a 1");
    is($b, "b 2");
    $c, $d;
}

$a = "a 5";
$b = "b 6";
$c = "c 7";
$d = "d 8";

my @@res;
@@res =  &foo("a 1","b 2");
is($res[0], "c 3");
is($res[1], "d 4");

is($a, "a 5");
is($b, "b 6");
is($c, "c 7");
is($d, "d 8");
is($x, "a 9");
is($y, "c 10");

# same thing, only with arrays and associative arrays

sub foo2 {
    local($a, @@b) = @@_;
    local(@@c, %d);
    @@c = "c 3";
    $d{''} = "d 4";
    { local($a,@@c) = ("a 19", "c 20"); ($x, $y) = ($a, @@c); }
    is($a, "a 1");
    is("@@b", "b 2");
    $c[0], $d{''};
}

$a = "a 5";
@@b = "b 6";
@@c = "c 7";
$d{''} = "d 8";

@@res = &foo2("a 1","b 2");
is($res[0], "c 3");
is($res[1], "d 4");

is($a, "a 5");
is("@@b", "b 6");
is($c[0], "c 7");
is($d{''}, "d 8");
is($x, "a 19");
is($y, "c 20");


eval 'local($$e)';
like($@@, qr/Can't localize through a reference/);

eval '$e = []; local(@@$e)';
like($@@, qr/Can't localize through a reference/);

eval '$e = {}; local(%$e)';
like($@@, qr/Can't localize through a reference/);

# Array and hash elements

@@a = ('a', 'b', 'c');
{
    local($a[1]) = 'foo';
    local($a[2]) = $a[2];
    is($a[1], 'foo');
    is($a[2], 'c');
    undef @@a;
}
is($a[1], 'b');
is($a[2], 'c');
ok(!defined $a[0]);

@@a = ('a', 'b', 'c');
{
    local($a[4]) = 'x';
    ok(!defined $a[3]);
    is($a[4], 'x');
}
is(scalar(@@a), 3);
ok(!exists $a[3]);
ok(!exists $a[4]);

@@a = ('a', 'b', 'c');
{
    local($a[5]) = 'z';
    $a[4] = 'y';
    ok(!defined $a[3]);
    is($a[4], 'y');
    is($a[5], 'z');
}
is(scalar(@@a), 5);
ok(!defined $a[3]);
is($a[4], 'y');
ok(!exists $a[5]);

@@a = ('a', 'b', 'c');
{
    local(@@a[4,6]) = ('x', 'z');
    ok(!defined $a[3]);
    is($a[4], 'x');
    ok(!defined $a[5]);
    is($a[6], 'z');
}
is(scalar(@@a), 3);
ok(!exists $a[3]);
ok(!exists $a[4]);
ok(!exists $a[5]);
ok(!exists $a[6]);

@@a = ('a', 'b', 'c');
{
    local(@@a[4,6]) = ('x', 'z');
    $a[5] = 'y';
    ok(!defined $a[3]);
    is($a[4], 'x');
    is($a[5], 'y');
    is($a[6], 'z');
}
is(scalar(@@a), 6);
ok(!defined $a[3]);
ok(!defined $a[4]);
is($a[5], 'y');
ok(!exists $a[6]);

@@a = ('a', 'b', 'c');
{
    local($a[1]) = "X";
    shift @@a;
}
is($a[0].$a[1], "Xb");
{
    my $d = "@@a";
    local @@a = @@a;
    is("@@a", $d);
}

@@a = ('a', 'b', 'c');
$a[4] = 'd';
{
    delete local $a[1];
    is(scalar(@@a), 5);
    is($a[0], 'a');
    ok(!exists($a[1]));
    is($a[2], 'c');
    ok(!exists($a[3]));
    is($a[4], 'd');

    ok(!exists($a[888]));
    delete local $a[888];
    is(scalar(@@a), 5);
    ok(!exists($a[888]));

    ok(!exists($a[999]));
    my ($d, $zzz) = delete local @@a[4, 999];
    is(scalar(@@a), 3);
    ok(!exists($a[4]));
    ok(!exists($a[999]));
    is($d, 'd');
    is($zzz, undef);

    my $c = delete local $a[2];
    is(scalar(@@a), 1);
    ok(!exists($a[2]));
    is($c, 'c');

    $a[888] = 'yyy';
    $a[999] = 'zzz';
}
is(scalar(@@a), 5);
is($a[0], 'a');
is($a[1], 'b');
is($a[2], 'c');
ok(!defined($a[3]));
is($a[4], 'd');
ok(!exists($a[5]));
ok(!exists($a[888]));
ok(!exists($a[999]));

%h = (a => 1, b => 2, c => 3, d => 4);
{
    delete local $h{b};
    is(scalar(keys(%h)), 3);
    is($h{a}, 1);
    ok(!exists($h{b}));
    is($h{c}, 3);
    is($h{d}, 4);

    ok(!exists($h{yyy}));
    delete local $h{yyy};
    is(scalar(keys(%h)), 3);
    ok(!exists($h{yyy}));

    ok(!exists($h{zzz}));
    my ($d, $zzz) = delete local @@h{qw/d zzz/};
    is(scalar(keys(%h)), 2);
    ok(!exists($h{d}));
    ok(!exists($h{zzz}));
    is($d, 4);
    is($zzz, undef);

    my $c = delete local $h{c};
    is(scalar(keys(%h)), 1);
    ok(!exists($h{c}));
    is($c, 3);

    $h{yyy} = 888;
    $h{zzz} = 999;
}
is(scalar(keys(%h)), 4);
is($h{a}, 1);
is($h{b}, 2);
is($h{c}, 3);
ok($h{d}, 4);
ok(!exists($h{yyy}));
ok(!exists($h{zzz}));

%h = ('a' => { 'b' => 1 }, 'c' => 2);
{
    my $a = delete local $h{a};
    is(scalar(keys(%h)), 1);
    ok(!exists($h{a}));
    is($h{c}, 2);
    is(scalar(keys(%$a)), 1);

    my $b = delete local $a->{b};
    is(scalar(keys(%$a)), 0);
    is($b, 1);

    $a->{d} = 3;
}
is(scalar(keys(%h)), 2);
{
    my $a = $h{a};
    is(scalar(keys(%$a)), 2);
    is($a->{b}, 1);
    is($a->{d}, 3);
}
is($h{c}, 2);

%h = ('a' => 1, 'b' => 2, 'c' => 3);
{
    local($h{'a'}) = 'foo';
    local($h{'b'}) = $h{'b'};
    is($h{'a'}, 'foo');
    is($h{'b'}, 2);
    local($h{'c'});
    delete $h{'c'};
}
is($h{'a'}, 1);
is($h{'b'}, 2);
{
    my $d = join("\n", map { "$_=>$h{$_}" } sort keys %h);
    local %h = %h;
    is(join("\n", map { "$_=>$h{$_}" } sort keys %h), $d);
}
is($h{'c'}, 3);

# check for scope leakage
$a = 'outer';
if (1) { local $a = 'inner' }
is($a, 'outer');

# see if localization works when scope unwinds
local $m = 5;
eval {
    for $m (6) {
	local $m = 7;
	die "bye";
    }
};
is($m, 5);

# see if localization works on tied arrays
{
    package TA;
    sub TIEARRAY { bless [], $_[0] }
    sub STORE { print "# STORE [@@_]\n"; $_[0]->[$_[1]] = $_[2] }
    sub FETCH { my $v = $_[0]->[$_[1]]; print "# FETCH [@@_=$v]\n"; $v }
    sub EXISTS { print "# EXISTS [@@_]\n"; exists $_[0]->[$_[1]]; }
    sub DELETE { print "# DELETE [@@_]\n"; delete $_[0]->[$_[1]]; }
    sub CLEAR { print "# CLEAR [@@_]\n"; @@{$_[0]} = (); }
    sub FETCHSIZE { scalar(@@{$_[0]}) }
    sub SHIFT { shift (@@{$_[0]}) }
    sub EXTEND {}
}

tie @@a, 'TA';
@@a = ('a', 'b', 'c');
{
    local($a[1]) = 'foo';
    local($a[2]) = $a[2];
    is($a[1], 'foo');
    is($a[2], 'c');
    @@a = ();
}
is($a[1], 'b');
is($a[2], 'c');
ok(!defined $a[0]);
{
    my $d = "@@a";
    local @@a = @@a;
    is("@@a", $d);
}
# RT #7938: localising an array should make it temporarily untied
{
    @@a = qw(a b c);
    local @@a = (6,7,8);
    is("@@a", "6 7 8", 'local @@a assigned 6,7,8');
    {
	my $c = 0;
	local *TA::STORE = sub { $c++ };
	$a[0] = 9;
	is($c, 0, 'STORE not called after array localised');
    }
    is("@@a", "9 7 8", 'local @@a should now be 9 7 8');
}
is("@@a", "a b c", '@@a should now contain original value');


# local() should preserve the existenceness of tied array elements
@@a = ('a', 'b', 'c');
{
    local($a[4]) = 'x';
    ok(!defined $a[3]);
    is($a[4], 'x');
}
is(scalar(@@a), 3);
ok(!exists $a[3]);
ok(!exists $a[4]);

@@a = ('a', 'b', 'c');
{
    local($a[5]) = 'z';
    $a[4] = 'y';
    ok(!defined $a[3]);
    is($a[4], 'y');
    is($a[5], 'z');
}
is(scalar(@@a), 5);
ok(!defined $a[3]);
is($a[4], 'y');
ok(!exists $a[5]);

@@a = ('a', 'b', 'c');
{
    local(@@a[4,6]) = ('x', 'z');
    ok(!defined $a[3]);
    is($a[4], 'x');
    ok(!defined $a[5]);
    is($a[6], 'z');
}
is(scalar(@@a), 3);
ok(!exists $a[3]);
ok(!exists $a[4]);
ok(!exists $a[5]);
ok(!exists $a[6]);

@@a = ('a', 'b', 'c');
{
    local(@@a[4,6]) = ('x', 'z');
    $a[5] = 'y';
    ok(!defined $a[3]);
    is($a[4], 'x');
    is($a[5], 'y');
    is($a[6], 'z');
}
is(scalar(@@a), 6);
ok(!defined $a[3]);
ok(!defined $a[4]);
is($a[5], 'y');
ok(!exists $a[6]);

@@a = ('a', 'b', 'c');
$a[4] = 'd';
{
    delete local $a[1];
    is(scalar(@@a), 5);
    is($a[0], 'a');
    ok(!exists($a[1]));
    is($a[2], 'c');
    ok(!exists($a[3]));
    is($a[4], 'd');

    ok(!exists($a[888]));
    delete local $a[888];
    is(scalar(@@a), 5);
    ok(!exists($a[888]));

    ok(!exists($a[999]));
    my ($d, $zzz) = delete local @@a[4, 999];
    is(scalar(@@a), 3);
    ok(!exists($a[4]));
    ok(!exists($a[999]));
    is($d, 'd');
    is($zzz, undef);

    my $c = delete local $a[2];
    is(scalar(@@a), 1);
    ok(!exists($a[2]));
    is($c, 'c');

    $a[888] = 'yyy';
    $a[999] = 'zzz';
}
is(scalar(@@a), 5);
is($a[0], 'a');
is($a[1], 'b');
is($a[2], 'c');
ok(!defined($a[3]));
is($a[4], 'd');
ok(!exists($a[5]));
ok(!exists($a[888]));
ok(!exists($a[999]));

# see if localization works on tied hashes
{
    package TH;
    sub TIEHASH { bless {}, $_[0] }
    sub STORE { print "# STORE [@@_]\n"; $_[0]->{$_[1]} = $_[2] }
    sub FETCH { my $v = $_[0]->{$_[1]}; print "# FETCH [@@_=$v]\n"; $v }
    sub EXISTS { print "# EXISTS [@@_]\n"; exists $_[0]->{$_[1]}; }
    sub DELETE { print "# DELETE [@@_]\n"; delete $_[0]->{$_[1]}; }
    sub CLEAR { print "# CLEAR [@@_]\n"; %{$_[0]} = (); }
    sub FIRSTKEY { print "# FIRSTKEY [@@_]\n"; keys %{$_[0]}; each %{$_[0]} }
    sub NEXTKEY { print "# NEXTKEY [@@_]\n"; each %{$_[0]} }
}

tie %h, 'TH';
%h = ('a' => 1, 'b' => 2, 'c' => 3);

{
    local($h{'a'}) = 'foo';
    local($h{'b'}) = $h{'b'};
    local($h{'y'});
    local($h{'z'}) = 33;
    is($h{'a'}, 'foo');
    is($h{'b'}, 2);
    local($h{'c'});
    delete $h{'c'};
}
is($h{'a'}, 1);
is($h{'b'}, 2);
is($h{'c'}, 3);

# local() should preserve the existenceness of tied hash elements
ok(! exists $h{'y'});
ok(! exists $h{'z'});
TODO: {
    todo_skip("Localize entire tied hash");
    my $d = join("\n", map { "$_=>$h{$_}" } sort keys %h);
    local %h = %h;
    is(join("\n", map { "$_=>$h{$_}" } sort keys %h), $d);
}

# RT #7939: localising a hash should make it temporarily untied
{
    %h = qw(a 1 b 2 c 3);
    local %h = qw(x 6 y 7 z 8);
    is(join('', sort keys   %h), "xyz", 'local %h has new keys');
    is(join('', sort values %h), "678", 'local %h has new values');
    {
	my $c = 0;
	local *TH::STORE = sub { $c++ };
	$h{x} = 9;
	is($c, 0, 'STORE not called after hash localised');
    }
    is($h{x}, 9, '$h{x} should now be 9');
}
is(join('', sort keys   %h), "abc", 'restored %h has original keys');
is(join('', sort values %h), "123", 'restored %h has original values');


%h = (a => 1, b => 2, c => 3, d => 4);
{
    delete local $h{b};
    is(scalar(keys(%h)), 3);
    is($h{a}, 1);
    ok(!exists($h{b}));
    is($h{c}, 3);
    is($h{d}, 4);

    ok(!exists($h{yyy}));
    delete local $h{yyy};
    is(scalar(keys(%h)), 3);
    ok(!exists($h{yyy}));

    ok(!exists($h{zzz}));
    my ($d, $zzz) = delete local @@h{qw/d zzz/};
    is(scalar(keys(%h)), 2);
    ok(!exists($h{d}));
    ok(!exists($h{zzz}));
    is($d, 4);
    is($zzz, undef);

    my $c = delete local $h{c};
    is(scalar(keys(%h)), 1);
    ok(!exists($h{c}));
    is($c, 3);

    $h{yyy} = 888;
    $h{zzz} = 999;
}
is(scalar(keys(%h)), 4);
is($h{a}, 1);
is($h{b}, 2);
is($h{c}, 3);
ok($h{d}, 4);
ok(!exists($h{yyy}));
ok(!exists($h{zzz}));

@@a = ('a', 'b', 'c');
{
    local($a[1]) = "X";
    shift @@a;
}
is($a[0].$a[1], "Xb");

# now try the same for %SIG

$SIG{TERM} = 'foo';
$SIG{INT} = \&foo;
$SIG{__WARN__} = $SIG{INT};
{
    local($SIG{TERM}) = $SIG{TERM};
    local($SIG{INT}) = $SIG{INT};
    local($SIG{__WARN__}) = $SIG{__WARN__};
    is($SIG{TERM}, 'main::foo');
    is($SIG{INT}, \&foo);
    is($SIG{__WARN__}, \&foo);
    local($SIG{INT});
    delete $SIG{__WARN__};
}
is($SIG{TERM}, 'main::foo');
is($SIG{INT}, \&foo);
is($SIG{__WARN__}, \&foo);
{
    my $d = join("\n", map { "$_=>$SIG{$_}" } sort keys %SIG);
    local %SIG = %SIG;
    is(join("\n", map { "$_=>$SIG{$_}" } sort keys %SIG), $d);
}

# and for %ENV

$ENV{_X_} = 'a';
$ENV{_Y_} = 'b';
$ENV{_Z_} = 'c';
{
    local($ENV{_A_});
    local($ENV{_B_}) = 'foo';
    local($ENV{_X_}) = 'foo';
    local($ENV{_Y_}) = $ENV{_Y_};
    is($ENV{_X_}, 'foo');
    is($ENV{_Y_}, 'b');
    local($ENV{_Z_});
    delete $ENV{_Z_};
}
is($ENV{_X_}, 'a');
is($ENV{_Y_}, 'b');
is($ENV{_Z_}, 'c');
# local() should preserve the existenceness of %ENV elements
ok(! exists $ENV{_A_});
ok(! exists $ENV{_B_});

SKIP: {
    skip("Can't make list assignment to \%ENV on this system")
	unless $list_assignment_supported;
    my $d = join("\n", map { "$_=>$ENV{$_}" } sort keys %ENV);
    local %ENV = %ENV;
    is(join("\n", map { "$_=>$ENV{$_}" } sort keys %ENV), $d);
}

# does implicit localization in foreach skip magic?

$_ = "o 0,o 1,";
my $iter = 0;
while (/(o.+?),/gc) {
    is($1, "o $iter");
    foreach (1..1) { $iter++ }
    if ($iter > 2) { fail("endless loop"); last; }
}

{
    package UnderScore;
    sub TIESCALAR { bless \my $self, shift }
    sub FETCH { die "read  \$_ forbidden" }
    sub STORE { die "write \$_ forbidden" }
    tie $_, __PACKAGE__;
    my @@tests = (
	"Nesting"     => sub { print '#'; for (1..3) { print }
			       print "\n" },			1,
	"Reading"     => sub { print },				0,
	"Matching"    => sub { $x = /badness/ },		0,
	"Concat"      => sub { $_ .= "a" },			0,
	"Chop"        => sub { chop },				0,
	"Filetest"    => sub { -x },				0,
	"Assignment"  => sub { $_ = "Bad" },			0,
	"for local"   => sub { for("#ok?\n"){ print } },	1,
    );
    while ( ($name, $code, $ok) = splice(@@tests, 0, 3) ) {
	eval { &$code };
        main::ok(($ok xor $@@), "Underscore '$name'");
    }
    untie $_;
}

{
    # BUG 20001205.022 (RT #4852)
    my %x;
    $x{a} = 1;
    { local $x{b} = 1; }
    ok(! exists $x{b});
    { local @@x{c,d,e}; }
    ok(! exists $x{c});
}

# local() and readonly magic variables

eval { local $1 = 1 };
like($@@, qr/Modification of a read-only value attempted/);

# local($_) always strips all magic
eval { for ($1) { local $_ = 1 } };
is($@@, "");

{
    my $STORE = my $FETCH = 0;
    package TieHash;
    sub TIEHASH { bless $_[1], $_[0] }
    sub FETCH   { ++$FETCH; 42 }
    sub STORE   { ++$STORE }

    package main;
    tie my %hash, "TieHash", {};

    eval { for ($hash{key}) {local $_ = 2} };
    is($STORE, 0);
    is($FETCH, 0);
}

# The s/// adds 'g' magic to $_, but it should remain non-readonly
eval { for("a") { for $x (1,2) { local $_="b"; s/(.*)/+$1/ } } };
is($@@, "");

# sub localisation
{
	package Other;

	sub f1 { "f1" }
	sub f2 { "f2" }

	no warnings "redefine";
	{
		local *f1 = sub  { "g1" };
		::ok(f1() eq "g1", "localised sub via glob");
	}
	::ok(f1() eq "f1", "localised sub restored");
	{
		local $Other::{"f1"} = sub { "h1" };
		::ok(f1() eq "h1", "localised sub via stash");
	}
	::ok(f1() eq "f1", "localised sub restored");
	{
		local @@Other::{qw/ f1 f2 /} = (sub { "j1" }, sub { "j2" });
		::ok(f1() eq "j1", "localised sub via stash slice");
		::ok(f2() eq "j2", "localised sub via stash slice");
	}
	::ok(f1() eq "f1", "localised sub restored");
	::ok(f2() eq "f2", "localised sub restored");
}

# Localising unicode keys (bug #38815)
{
    my %h;
    $h{"\243"} = "pound";
    $h{"\302\240"} = "octects";
    is(scalar keys %h, 2);
    {
	my $unicode = chr 256;
	my $ambigous = "\240" . $unicode;
	chop $ambigous;
	local $h{$unicode} = 256;
	local $h{$ambigous} = 160;

	is(scalar keys %h, 4);
	is($h{"\243"}, "pound");
	is($h{$unicode}, 256);
	is($h{$ambigous}, 160);
	is($h{"\302\240"}, "octects");
    }
    is(scalar keys %h, 2);
    is($h{"\243"}, "pound");
    is($h{"\302\240"}, "octects");
}

# And with slices
{
    my %h;
    $h{"\243"} = "pound";
    $h{"\302\240"} = "octects";
    is(scalar keys %h, 2);
    {
	my $unicode = chr 256;
	my $ambigous = "\240" . $unicode;
	chop $ambigous;
	local @@h{$unicode, $ambigous} = (256, 160);

	is(scalar keys %h, 4);
	is($h{"\243"}, "pound");
	is($h{$unicode}, 256);
	is($h{$ambigous}, 160);
	is($h{"\302\240"}, "octects");
    }
    is(scalar keys %h, 2);
    is($h{"\243"}, "pound");
    is($h{"\302\240"}, "octects");
}

# [perl #39012] localizing @@_ element then shifting frees element too # soon

{
    my $x;
    my $y = bless [], 'X39012';
    sub X39012::DESTROY { $x++ }
    sub { local $_[0]; shift }->($y);
    ok(!$x,  '[perl #39012]');
    
}

# when localising a hash element, the key should be copied, not referenced

{
    my %h=('k1' => 111);
    my $k='k1';
    {
	local $h{$k}=222;

	is($h{'k1'},222);
	$k='k2';
    }
    ok(! exists($h{'k2'}));
    is($h{'k1'},111);
}
{
    my %h=('k1' => 111);
    our $k = 'k1';  # try dynamic too
    {
	local $h{$k}=222;
	is($h{'k1'},222);
	$k='k2';
    }
    ok(! exists($h{'k2'}));
    is($h{'k1'},111);
}

like( runperl(stderr => 1,
              prog => 'use constant foo => q(a);' .
                      'index(q(a), foo);' .
                      'local *g=${::}{foo};print q(ok);'), qr/^ok$/, "[perl #52740]");

# related to perl #112966
# Magic should not cause elements not to be deleted after scope unwinding
# when they did not exist before local()
() = \$#squinch; # $#foo in lvalue context makes array magical
{
    local $squinch[0];
    local @@squinch[1..2];
    package Flibbert;
    m??; # makes stash magical
    local $Flibbert::{foo};
    local @@Flibbert::{<bar baz>};
}
ok !exists $Flibbert::{foo},
  'local helem on magic hash does not leave elems on scope exit';
ok !exists $Flibbert::{bar},
  'local hslice on magic hash does not leave elems on scope exit';
ok !exists $squinch[0],
  'local aelem on magic hash does not leave elems on scope exit';
ok !exists $squinch[1],
  'local aslice on magic hash does not leave elems on scope exit';

# Keep these tests last, as they can SEGV
{
    local *@@;
    pass("Localised *@@");
    eval {1};
    pass("Can eval with *@@ localised");

    local @@{"nugguton"};
    local %{"netgonch"};
    delete $::{$_} for 'nugguton','netgonch';
}
pass ('localised arrays and hashes do not crash if glob is deleted');

# [perl #112966] Rmagic can cause delete local to crash
package Grompits {
local $SIG{__WARN__};
    delete local $ISA[0];
    delete local @@ISA[1..10];
    m??; # makes stash magical
    delete local $Grompits::{foo};
    delete local @@Grompits::{<foo bar>};
}
pass 'rmagic does not cause delete local to crash on nonexistent elems';
@


1.13
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d782 1
a782 1
                      'local *g=${::}{foo};print q(ok);'), "ok", "[perl #52740]");
@


1.12
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d631 1
a631 1
    # BUG 20001205.22
@


1.11
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d8 1
a8 1
plan tests => 305;
d12 1
a12 1
#mg.c says list assignment not supported on VMS, EPOC, and SYMBIAN.
d784 21
d817 11
@


1.10
log
@merge in perl 5.12.2 plus local changes
@
text
@d8 1
a8 1
plan tests => 296;
d328 15
d468 1
d479 18
a620 2
	# XXX whether next one should fail is debatable
	"Local \$_"   => sub { local $_  = 'ok?'; print },	0,
d645 1
d647 1
a647 1
like($@@, qr/Modification of a read-only value attempted/);
d649 14
a662 3
# make sure $1 is still read-only
eval { for ($1) { local $_ = 1 } };
like($@@, qr/Modification of a read-only value attempted/);
a667 10
# RT #4342 Special local() behavior for $[
{
    no warnings 'deprecated';
    local $[ = 1;
    ok(1 == $[, 'lexcical scope of local $[');
    f();
}

sub f { ok(0 == $[); }

d784 1
a784 1
# Keep this test last, as it can SEGV
d790 4
d795 1
a795 1

@


1.9
log
@Merge in perl 5.10.1; part two
@
text
@d8 1
a8 1
plan tests => 123;
d99 52
d161 103
d303 2
d329 96
a436 1
# see if localization works on tied hashes
d463 38
d626 1
@


1.8
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d8 1
a8 1
plan tests => 122;
d453 5
@


1.7
log
@merge in perl 5.8.8
@
text
@d5 1
d8 1
a8 1
plan tests => 81;
d317 145
@


1.6
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d3 11
a13 1
print "1..75\n";
d18 24
a41 15
    $c = "ok 3\n";
    $d = "ok 4\n";
    { local($a,$c) = ("ok 9\n", "ok 10\n"); ($x, $y) = ($a, $c); }
    print $a, $b;
    $c . $d;
}

$a = "ok 5\n";
$b = "ok 6\n";
$c = "ok 7\n";
$d = "ok 8\n";

print &foo("ok 1\n","ok 2\n");

print $a,$b,$c,$d,$x,$y;
d48 23
a70 13
    @@c = "ok 13\n";
    $d{''} = "ok 14\n";
    { local($a,@@c) = ("ok 19\n", "ok 20\n"); ($x, $y) = ($a, @@c); }
    print $a, @@b;
    $c[0] . $d{''};
}

$a = "ok 15\n";
@@b = "ok 16\n";
@@c = "ok 17\n";
$d{''} = "ok 18\n";

print &foo2("ok 11\n","ok 12\n");
a71 1
print $a,@@b,@@c,%d,$x,$y;
d74 1
a74 1
print +($@@ =~ /Can't localize through a reference/) ? "" : "not ", "ok 21\n";
d77 1
a77 1
print +($@@ =~ /Can't localize through a reference/) ? "" : "not ", "ok 22\n";
d80 1
a80 1
print +($@@ =~ /Can't localize through a reference/) ? "" : "not ", "ok 23\n";
d88 2
a89 2
    print +($a[1] eq 'foo') ? "" : "not ", "ok 24\n";
    print +($a[2] eq 'c') ? "" : "not ", "ok 25\n";
d92 3
a94 3
print +($a[1] eq 'b') ? "" : "not ", "ok 26\n";
print +($a[2] eq 'c') ? "" : "not ", "ok 27\n";
print +(!defined $a[0]) ? "" : "not ", "ok 28\n";
d101 6
a106 1
print +($a[0].$a[1] eq "Xb") ? "" : "not ", "ok 29\n";
d112 2
a113 2
    print +($h{'a'} eq 'foo') ? "" : "not ", "ok 30\n";
    print +($h{'b'} == 2) ? "" : "not ", "ok 31\n";
d117 8
a124 3
print +($h{'a'} == 1) ? "" : "not ", "ok 32\n";
print +($h{'b'} == 2) ? "" : "not ", "ok 33\n";
print +($h{'c'} == 3) ? "" : "not ", "ok 34\n";
d129 1
a129 1
print +($a eq 'outer') ? "" : "not ", "ok 35\n";
d139 1
a139 1
print $m == 5 ? "" : "not ", "ok 36\n";
d158 2
a159 2
    print +($a[1] eq 'foo') ? "" : "not ", "ok 37\n";
    print +($a[2] eq 'c') ? "" : "not ", "ok 38\n";
d162 8
a169 3
print +($a[1] eq 'b') ? "" : "not ", "ok 39\n";
print +($a[2] eq 'c') ? "" : "not ", "ok 40\n";
print +(!defined $a[0]) ? "" : "not ", "ok 41\n";
d179 2
d192 2
a193 2
    print +($h{'a'} eq 'foo') ? "" : "not ", "ok 42\n";
    print +($h{'b'} == 2) ? "" : "not ", "ok 43\n";
d197 12
a208 3
print +($h{'a'} == 1) ? "" : "not ", "ok 44\n";
print +($h{'b'} == 2) ? "" : "not ", "ok 45\n";
print +($h{'c'} == 3) ? "" : "not ", "ok 46\n";
d215 1
a215 1
print +($a[0].$a[1] eq "Xb") ? "" : "not ", "ok 47\n";
d226 3
a228 3
    print +($SIG{TERM}		eq 'main::foo') ? "" : "not ", "ok 48\n";
    print +($SIG{INT}		eq \&foo) ? "" : "not ", "ok 49\n";
    print +($SIG{__WARN__}	eq \&foo) ? "" : "not ", "ok 50\n";
d232 8
a239 3
print +($SIG{TERM}	eq 'main::foo') ? "" : "not ", "ok 51\n";
print +($SIG{INT}	eq \&foo) ? "" : "not ", "ok 52\n";
print +($SIG{__WARN__}	eq \&foo) ? "" : "not ", "ok 53\n";
d251 2
a252 2
    print +($ENV{_X_} eq 'foo') ? "" : "not ", "ok 54\n";
    print +($ENV{_Y_} eq 'b') ? "" : "not ", "ok 55\n";
d256 14
a269 3
print +($ENV{_X_} eq 'a') ? "" : "not ", "ok 56\n";
print +($ENV{_Y_} eq 'b') ? "" : "not ", "ok 57\n";
print +($ENV{_Z_} eq 'c') ? "" : "not ", "ok 58\n";
d273 1
a273 1
$_ = "ok 59,ok 60,";
d276 1
a276 1
    print "$1\n";
d278 1
a278 1
    if ($iter > 2) { print "not ok 60\n"; last; }
a286 1
    my $t = 61;
a300 1
	print "# Testing $name\n";
d302 1
a302 2
	print(($ok xor $@@) ? "ok $t\n" : "not ok $t\n");
	++$t;
d312 1
a312 2
    print "not " if exists $x{b};
    print "ok 70\n";
d314 1
a314 2
    print "not " if exists $x{c};
    print "ok 71\n"; 
a315 9

# these tests should be physically located after tests 46 and 58,
# but are here instead to avoid renumbering everything. 

# local() should preserve the existenceness of tied hashes and %ENV
print "not " if exists $h{'y'}; print "ok 72\n";
print "not " if exists $h{'z'}; print "ok 73\n";
print "not " if exists $ENV{_A_}; print "ok 74\n";
print "not " if exists $ENV{_B_}; print "ok 75\n";
@


1.5
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d48 1
a48 1
eval 'local(@@$e)';
d51 1
a51 1
eval 'local(%$e)';
@


1.4
log
@merge in perl 5.6.1 with our local changes
@
text
@d3 1
a3 1
print "1..69\n";
d133 1
d145 2
d188 2
d240 20
@


1.3
log
@perl5.005_03 (stock)
@
text
@a4 3
# XXX known to leak scalars
$ENV{PERL_DESTRUCT_LEVEL} = 0 unless $ENV{PERL_DESTRUCT_LEVEL} > 3;

@


1.2
log
@perl 5.004_04
@
text
@d3 1
a3 1
# $RCSfile: local.t,v $$Revision: 4.1 $$Date: 92/08/07 18:28:04 $
d5 2
a6 1
print "1..23\n";
d56 182
@


1.1
log
@Initial revision
@
text
@d5 1
a5 1
print "1..20\n";
d46 9
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d3 1
a3 1
print "1..69\n";
d5 1
a5 2
# XXX known to leak scalars
$ENV{PERL_DESTRUCT_LEVEL} = 0 unless $ENV{PERL_DESTRUCT_LEVEL} > 3;
a45 191

eval 'local($$e)';
print +($@@ =~ /Can't localize through a reference/) ? "" : "not ", "ok 21\n";

eval 'local(@@$e)';
print +($@@ =~ /Can't localize through a reference/) ? "" : "not ", "ok 22\n";

eval 'local(%$e)';
print +($@@ =~ /Can't localize through a reference/) ? "" : "not ", "ok 23\n";

# Array and hash elements

@@a = ('a', 'b', 'c');
{
    local($a[1]) = 'foo';
    local($a[2]) = $a[2];
    print +($a[1] eq 'foo') ? "" : "not ", "ok 24\n";
    print +($a[2] eq 'c') ? "" : "not ", "ok 25\n";
    undef @@a;
}
print +($a[1] eq 'b') ? "" : "not ", "ok 26\n";
print +($a[2] eq 'c') ? "" : "not ", "ok 27\n";
print +(!defined $a[0]) ? "" : "not ", "ok 28\n";

@@a = ('a', 'b', 'c');
{
    local($a[1]) = "X";
    shift @@a;
}
print +($a[0].$a[1] eq "Xb") ? "" : "not ", "ok 29\n";

%h = ('a' => 1, 'b' => 2, 'c' => 3);
{
    local($h{'a'}) = 'foo';
    local($h{'b'}) = $h{'b'};
    print +($h{'a'} eq 'foo') ? "" : "not ", "ok 30\n";
    print +($h{'b'} == 2) ? "" : "not ", "ok 31\n";
    local($h{'c'});
    delete $h{'c'};
}
print +($h{'a'} == 1) ? "" : "not ", "ok 32\n";
print +($h{'b'} == 2) ? "" : "not ", "ok 33\n";
print +($h{'c'} == 3) ? "" : "not ", "ok 34\n";

# check for scope leakage
$a = 'outer';
if (1) { local $a = 'inner' }
print +($a eq 'outer') ? "" : "not ", "ok 35\n";

# see if localization works when scope unwinds
local $m = 5;
eval {
    for $m (6) {
	local $m = 7;
	die "bye";
    }
};
print $m == 5 ? "" : "not ", "ok 36\n";

# see if localization works on tied arrays
{
    package TA;
    sub TIEARRAY { bless [], $_[0] }
    sub STORE { print "# STORE [@@_]\n"; $_[0]->[$_[1]] = $_[2] }
    sub FETCH { my $v = $_[0]->[$_[1]]; print "# FETCH [@@_=$v]\n"; $v }
    sub CLEAR { print "# CLEAR [@@_]\n"; @@{$_[0]} = (); }
    sub FETCHSIZE { scalar(@@{$_[0]}) }
    sub SHIFT { shift (@@{$_[0]}) }
    sub EXTEND {}
}

tie @@a, 'TA';
@@a = ('a', 'b', 'c');
{
    local($a[1]) = 'foo';
    local($a[2]) = $a[2];
    print +($a[1] eq 'foo') ? "" : "not ", "ok 37\n";
    print +($a[2] eq 'c') ? "" : "not ", "ok 38\n";
    @@a = ();
}
print +($a[1] eq 'b') ? "" : "not ", "ok 39\n";
print +($a[2] eq 'c') ? "" : "not ", "ok 40\n";
print +(!defined $a[0]) ? "" : "not ", "ok 41\n";

{
    package TH;
    sub TIEHASH { bless {}, $_[0] }
    sub STORE { print "# STORE [@@_]\n"; $_[0]->{$_[1]} = $_[2] }
    sub FETCH { my $v = $_[0]->{$_[1]}; print "# FETCH [@@_=$v]\n"; $v }
    sub DELETE { print "# DELETE [@@_]\n"; delete $_[0]->{$_[1]}; }
    sub CLEAR { print "# CLEAR [@@_]\n"; %{$_[0]} = (); }
}

# see if localization works on tied hashes
tie %h, 'TH';
%h = ('a' => 1, 'b' => 2, 'c' => 3);

{
    local($h{'a'}) = 'foo';
    local($h{'b'}) = $h{'b'};
    print +($h{'a'} eq 'foo') ? "" : "not ", "ok 42\n";
    print +($h{'b'} == 2) ? "" : "not ", "ok 43\n";
    local($h{'c'});
    delete $h{'c'};
}
print +($h{'a'} == 1) ? "" : "not ", "ok 44\n";
print +($h{'b'} == 2) ? "" : "not ", "ok 45\n";
print +($h{'c'} == 3) ? "" : "not ", "ok 46\n";

@@a = ('a', 'b', 'c');
{
    local($a[1]) = "X";
    shift @@a;
}
print +($a[0].$a[1] eq "Xb") ? "" : "not ", "ok 47\n";

# now try the same for %SIG

$SIG{TERM} = 'foo';
$SIG{INT} = \&foo;
$SIG{__WARN__} = $SIG{INT};
{
    local($SIG{TERM}) = $SIG{TERM};
    local($SIG{INT}) = $SIG{INT};
    local($SIG{__WARN__}) = $SIG{__WARN__};
    print +($SIG{TERM}		eq 'main::foo') ? "" : "not ", "ok 48\n";
    print +($SIG{INT}		eq \&foo) ? "" : "not ", "ok 49\n";
    print +($SIG{__WARN__}	eq \&foo) ? "" : "not ", "ok 50\n";
    local($SIG{INT});
    delete $SIG{__WARN__};
}
print +($SIG{TERM}	eq 'main::foo') ? "" : "not ", "ok 51\n";
print +($SIG{INT}	eq \&foo) ? "" : "not ", "ok 52\n";
print +($SIG{__WARN__}	eq \&foo) ? "" : "not ", "ok 53\n";

# and for %ENV

$ENV{_X_} = 'a';
$ENV{_Y_} = 'b';
$ENV{_Z_} = 'c';
{
    local($ENV{_X_}) = 'foo';
    local($ENV{_Y_}) = $ENV{_Y_};
    print +($ENV{_X_} eq 'foo') ? "" : "not ", "ok 54\n";
    print +($ENV{_Y_} eq 'b') ? "" : "not ", "ok 55\n";
    local($ENV{_Z_});
    delete $ENV{_Z_};
}
print +($ENV{_X_} eq 'a') ? "" : "not ", "ok 56\n";
print +($ENV{_Y_} eq 'b') ? "" : "not ", "ok 57\n";
print +($ENV{_Z_} eq 'c') ? "" : "not ", "ok 58\n";

# does implicit localization in foreach skip magic?

$_ = "ok 59,ok 60,";
my $iter = 0;
while (/(o.+?),/gc) {
    print "$1\n";
    foreach (1..1) { $iter++ }
    if ($iter > 2) { print "not ok 60\n"; last; }
}

{
    package UnderScore;
    sub TIESCALAR { bless \my $self, shift }
    sub FETCH { die "read  \$_ forbidden" }
    sub STORE { die "write \$_ forbidden" }
    tie $_, __PACKAGE__;
    my $t = 61;
    my @@tests = (
	"Nesting"     => sub { print '#'; for (1..3) { print }
			       print "\n" },			1,
	"Reading"     => sub { print },				0,
	"Matching"    => sub { $x = /badness/ },		0,
	"Concat"      => sub { $_ .= "a" },			0,
	"Chop"        => sub { chop },				0,
	"Filetest"    => sub { -x },				0,
	"Assignment"  => sub { $_ = "Bad" },			0,
	# XXX whether next one should fail is debatable
	"Local \$_"   => sub { local $_  = 'ok?'; print },	0,
	"for local"   => sub { for("#ok?\n"){ print } },	1,
    );
    while ( ($name, $code, $ok) = splice(@@tests, 0, 3) ) {
	print "# Testing $name\n";
	eval { &$code };
	print(($ok xor $@@) ? "ok $t\n" : "not ok $t\n");
	++$t;
    }
    untie $_;
}

@


1.1.1.3
log
@stock perl 5.6.1
@
text
@d5 3
@


1.1.1.4
log
@stock perl 5.8.0 from CPAN
@
text
@d3 1
a3 1
print "1..75\n";
a132 1
    sub EXISTS { print "# EXISTS [@@_]\n"; exists $_[0]->{$_[1]}; }
a143 2
    local($h{'y'});
    local($h{'z'}) = 33;
a184 2
    local($ENV{_A_});
    local($ENV{_B_}) = 'foo';
a234 20
{
    # BUG 20001205.22
    my %x;
    $x{a} = 1;
    { local $x{b} = 1; }
    print "not " if exists $x{b};
    print "ok 70\n";
    { local @@x{c,d,e}; }
    print "not " if exists $x{c};
    print "ok 71\n"; 
}

# these tests should be physically located after tests 46 and 58,
# but are here instead to avoid renumbering everything. 

# local() should preserve the existenceness of tied hashes and %ENV
print "not " if exists $h{'y'}; print "ok 72\n";
print "not " if exists $h{'z'}; print "ok 73\n";
print "not " if exists $ENV{_A_}; print "ok 74\n";
print "not " if exists $ENV{_B_}; print "ok 75\n";
@


1.1.1.5
log
@perl 5.8.2 from CPAN
@
text
@d48 1
a48 1
eval '$e = []; local(@@$e)';
d51 1
a51 1
eval '$e = {}; local(%$e)';
@


1.1.1.6
log
@perl 5.8.8 import
@
text
@d3 10
a12 3
BEGIN {
    chdir 't' if -d 't';
    require './test.pl';
a13 1
plan tests => 81;
d15 4
a18 1
my $list_assignment_supported = 1;
d20 1
a20 2
#mg.c says list assignment not supported on VMS, EPOC, and SYMBIAN.
$list_assignment_supported = 0 if ($^O eq 'VMS');
d22 1
a22 28

sub foo {
    local($a, $b) = @@_;
    local($c, $d);
    $c = "c 3";
    $d = "d 4";
    { local($a,$c) = ("a 9", "c 10"); ($x, $y) = ($a, $c); }
    is($a, "a 1");
    is($b, "b 2");
    $c, $d;
}

$a = "a 5";
$b = "b 6";
$c = "c 7";
$d = "d 8";

my @@res;
@@res =  &foo("a 1","b 2");
is($res[0], "c 3");
is($res[1], "d 4");

is($a, "a 5");
is($b, "b 6");
is($c, "c 7");
is($d, "d 8");
is($x, "a 9");
is($y, "c 10");
d29 13
a41 23
    @@c = "c 3";
    $d{''} = "d 4";
    { local($a,@@c) = ("a 19", "c 20"); ($x, $y) = ($a, @@c); }
    is($a, "a 1");
    is("@@b", "b 2");
    $c[0], $d{''};
}

$a = "a 5";
@@b = "b 6";
@@c = "c 7";
$d{''} = "d 8";

@@res = &foo2("a 1","b 2");
is($res[0], "c 3");
is($res[1], "d 4");

is($a, "a 5");
is("@@b", "b 6");
is($c[0], "c 7");
is($d{''}, "d 8");
is($x, "a 19");
is($y, "c 20");
d43 1
d46 1
a46 1
like($@@, qr/Can't localize through a reference/);
d49 1
a49 1
like($@@, qr/Can't localize through a reference/);
d52 1
a52 1
like($@@, qr/Can't localize through a reference/);
d60 2
a61 2
    is($a[1], 'foo');
    is($a[2], 'c');
d64 3
a66 3
is($a[1], 'b');
is($a[2], 'c');
ok(!defined $a[0]);
d73 1
a73 6
is($a[0].$a[1], "Xb");
{
    my $d = "@@a";
    local @@a = @@a;
    is("@@a", $d);
}
d79 2
a80 2
    is($h{'a'}, 'foo');
    is($h{'b'}, 2);
d84 3
a86 8
is($h{'a'}, 1);
is($h{'b'}, 2);
{
    my $d = join("\n", map { "$_=>$h{$_}" } sort keys %h);
    local %h = %h;
    is(join("\n", map { "$_=>$h{$_}" } sort keys %h), $d);
}
is($h{'c'}, 3);
d91 1
a91 1
is($a, 'outer');
d101 1
a101 1
is($m, 5);
d120 2
a121 2
    is($a[1], 'foo');
    is($a[2], 'c');
d124 3
a126 8
is($a[1], 'b');
is($a[2], 'c');
ok(!defined $a[0]);
{
    my $d = "@@a";
    local @@a = @@a;
    is("@@a", $d);
}
a135 2
    sub FIRSTKEY { print "# FIRSTKEY [@@_]\n"; keys %{$_[0]}; each %{$_[0]} }
    sub NEXTKEY { print "# NEXTKEY [@@_]\n"; each %{$_[0]} }
d147 2
a148 2
    is($h{'a'}, 'foo');
    is($h{'b'}, 2);
d152 3
a154 12
is($h{'a'}, 1);
is($h{'b'}, 2);
is($h{'c'}, 3);
# local() should preserve the existenceness of tied hash elements
ok(! exists $h{'y'});
ok(! exists $h{'z'});
TODO: {
    todo_skip("Localize entire tied hash");
    my $d = join("\n", map { "$_=>$h{$_}" } sort keys %h);
    local %h = %h;
    is(join("\n", map { "$_=>$h{$_}" } sort keys %h), $d);
}
d161 1
a161 1
is($a[0].$a[1], "Xb");
d172 3
a174 3
    is($SIG{TERM}, 'main::foo');
    is($SIG{INT}, \&foo);
    is($SIG{__WARN__}, \&foo);
d178 3
a180 8
is($SIG{TERM}, 'main::foo');
is($SIG{INT}, \&foo);
is($SIG{__WARN__}, \&foo);
{
    my $d = join("\n", map { "$_=>$SIG{$_}" } sort keys %SIG);
    local %SIG = %SIG;
    is(join("\n", map { "$_=>$SIG{$_}" } sort keys %SIG), $d);
}
d192 2
a193 2
    is($ENV{_X_}, 'foo');
    is($ENV{_Y_}, 'b');
d197 3
a199 14
is($ENV{_X_}, 'a');
is($ENV{_Y_}, 'b');
is($ENV{_Z_}, 'c');
# local() should preserve the existenceness of %ENV elements
ok(! exists $ENV{_A_});
ok(! exists $ENV{_B_});

SKIP: {
    skip("Can't make list assignment to \%ENV on this system")
	unless $list_assignment_supported;
    my $d = join("\n", map { "$_=>$ENV{$_}" } sort keys %ENV);
    local %ENV = %ENV;
    is(join("\n", map { "$_=>$ENV{$_}" } sort keys %ENV), $d);
}
d203 1
a203 1
$_ = "o 0,o 1,";
d206 1
a206 1
    is($1, "o $iter");
d208 1
a208 1
    if ($iter > 2) { fail("endless loop"); last; }
d217 1
d232 1
d234 2
a235 1
        main::ok(($ok xor $@@), "Underscore '$name'");
d245 2
a246 1
    ok(! exists $x{b});
d248 2
a249 1
    ok(! exists $x{c});
d251 9
@


1.1.1.7
log
@import perl 5.10.0 from CPAN
@
text
@a4 1
    @@INC = qw(. ../lib);
d7 1
a7 1
plan tests => 122;
a315 145

# local() and readonly magic variables

eval { local $1 = 1 };
like($@@, qr/Modification of a read-only value attempted/);

eval { for ($1) { local $_ = 1 } };
like($@@, qr/Modification of a read-only value attempted/);

# make sure $1 is still read-only
eval { for ($1) { local $_ = 1 } };
like($@@, qr/Modification of a read-only value attempted/);

# The s/// adds 'g' magic to $_, but it should remain non-readonly
eval { for("a") { for $x (1,2) { local $_="b"; s/(.*)/+$1/ } } };
is($@@, "");

# RT #4342 Special local() behavior for $[
{
    local $[ = 1;
    ok(1 == $[, 'lexcical scope of local $[');
    f();
}

sub f { ok(0 == $[); }

# sub localisation
{
	package Other;

	sub f1 { "f1" }
	sub f2 { "f2" }

	no warnings "redefine";
	{
		local *f1 = sub  { "g1" };
		::ok(f1() eq "g1", "localised sub via glob");
	}
	::ok(f1() eq "f1", "localised sub restored");
	{
		local $Other::{"f1"} = sub { "h1" };
		::ok(f1() eq "h1", "localised sub via stash");
	}
	::ok(f1() eq "f1", "localised sub restored");
	{
		local @@Other::{qw/ f1 f2 /} = (sub { "j1" }, sub { "j2" });
		::ok(f1() eq "j1", "localised sub via stash slice");
		::ok(f2() eq "j2", "localised sub via stash slice");
	}
	::ok(f1() eq "f1", "localised sub restored");
	::ok(f2() eq "f2", "localised sub restored");
}

# Localising unicode keys (bug #38815)
{
    my %h;
    $h{"\243"} = "pound";
    $h{"\302\240"} = "octects";
    is(scalar keys %h, 2);
    {
	my $unicode = chr 256;
	my $ambigous = "\240" . $unicode;
	chop $ambigous;
	local $h{$unicode} = 256;
	local $h{$ambigous} = 160;

	is(scalar keys %h, 4);
	is($h{"\243"}, "pound");
	is($h{$unicode}, 256);
	is($h{$ambigous}, 160);
	is($h{"\302\240"}, "octects");
    }
    is(scalar keys %h, 2);
    is($h{"\243"}, "pound");
    is($h{"\302\240"}, "octects");
}

# And with slices
{
    my %h;
    $h{"\243"} = "pound";
    $h{"\302\240"} = "octects";
    is(scalar keys %h, 2);
    {
	my $unicode = chr 256;
	my $ambigous = "\240" . $unicode;
	chop $ambigous;
	local @@h{$unicode, $ambigous} = (256, 160);

	is(scalar keys %h, 4);
	is($h{"\243"}, "pound");
	is($h{$unicode}, 256);
	is($h{$ambigous}, 160);
	is($h{"\302\240"}, "octects");
    }
    is(scalar keys %h, 2);
    is($h{"\243"}, "pound");
    is($h{"\302\240"}, "octects");
}

# [perl #39012] localizing @@_ element then shifting frees element too # soon

{
    my $x;
    my $y = bless [], 'X39012';
    sub X39012::DESTROY { $x++ }
    sub { local $_[0]; shift }->($y);
    ok(!$x,  '[perl #39012]');
    
}

# when localising a hash element, the key should be copied, not referenced

{
    my %h=('k1' => 111);
    my $k='k1';
    {
	local $h{$k}=222;

	is($h{'k1'},222);
	$k='k2';
    }
    ok(! exists($h{'k2'}));
    is($h{'k1'},111);
}
{
    my %h=('k1' => 111);
    our $k = 'k1';  # try dynamic too
    {
	local $h{$k}=222;
	is($h{'k1'},222);
	$k='k2';
    }
    ok(! exists($h{'k2'}));
    is($h{'k1'},111);
}

# Keep this test last, as it can SEGV
{
    local *@@;
    pass("Localised *@@");
    eval {1};
    pass("Can eval with *@@ localised");
}

@


1.1.1.8
log
@import perl 5.10.1
@
text
@d8 1
a8 1
plan tests => 123;
a452 5

like( runperl(stderr => 1,
              prog => 'use constant foo => q(a);' .
                      'index(q(a), foo);' .
                      'local *g=${::}{foo};print q(ok);'), "ok", "[perl #52740]");
@


1.1.1.9
log
@Perl 5.12.2 from CPAN
@
text
@d8 1
a8 1
plan tests => 296;
a98 52
    local($a[4]) = 'x';
    ok(!defined $a[3]);
    is($a[4], 'x');
}
is(scalar(@@a), 3);
ok(!exists $a[3]);
ok(!exists $a[4]);

@@a = ('a', 'b', 'c');
{
    local($a[5]) = 'z';
    $a[4] = 'y';
    ok(!defined $a[3]);
    is($a[4], 'y');
    is($a[5], 'z');
}
is(scalar(@@a), 5);
ok(!defined $a[3]);
is($a[4], 'y');
ok(!exists $a[5]);

@@a = ('a', 'b', 'c');
{
    local(@@a[4,6]) = ('x', 'z');
    ok(!defined $a[3]);
    is($a[4], 'x');
    ok(!defined $a[5]);
    is($a[6], 'z');
}
is(scalar(@@a), 3);
ok(!exists $a[3]);
ok(!exists $a[4]);
ok(!exists $a[5]);
ok(!exists $a[6]);

@@a = ('a', 'b', 'c');
{
    local(@@a[4,6]) = ('x', 'z');
    $a[5] = 'y';
    ok(!defined $a[3]);
    is($a[4], 'x');
    is($a[5], 'y');
    is($a[6], 'z');
}
is(scalar(@@a), 6);
ok(!defined $a[3]);
ok(!defined $a[4]);
is($a[5], 'y');
ok(!exists $a[6]);

@@a = ('a', 'b', 'c');
{
a108 103
@@a = ('a', 'b', 'c');
$a[4] = 'd';
{
    delete local $a[1];
    is(scalar(@@a), 5);
    is($a[0], 'a');
    ok(!exists($a[1]));
    is($a[2], 'c');
    ok(!exists($a[3]));
    is($a[4], 'd');

    ok(!exists($a[888]));
    delete local $a[888];
    is(scalar(@@a), 5);
    ok(!exists($a[888]));

    ok(!exists($a[999]));
    my ($d, $zzz) = delete local @@a[4, 999];
    is(scalar(@@a), 3);
    ok(!exists($a[4]));
    ok(!exists($a[999]));
    is($d, 'd');
    is($zzz, undef);

    my $c = delete local $a[2];
    is(scalar(@@a), 1);
    ok(!exists($a[2]));
    is($c, 'c');

    $a[888] = 'yyy';
    $a[999] = 'zzz';
}
is(scalar(@@a), 5);
is($a[0], 'a');
is($a[1], 'b');
is($a[2], 'c');
ok(!defined($a[3]));
is($a[4], 'd');
ok(!exists($a[5]));
ok(!exists($a[888]));
ok(!exists($a[999]));

%h = (a => 1, b => 2, c => 3, d => 4);
{
    delete local $h{b};
    is(scalar(keys(%h)), 3);
    is($h{a}, 1);
    ok(!exists($h{b}));
    is($h{c}, 3);
    is($h{d}, 4);

    ok(!exists($h{yyy}));
    delete local $h{yyy};
    is(scalar(keys(%h)), 3);
    ok(!exists($h{yyy}));

    ok(!exists($h{zzz}));
    my ($d, $zzz) = delete local @@h{qw/d zzz/};
    is(scalar(keys(%h)), 2);
    ok(!exists($h{d}));
    ok(!exists($h{zzz}));
    is($d, 4);
    is($zzz, undef);

    my $c = delete local $h{c};
    is(scalar(keys(%h)), 1);
    ok(!exists($h{c}));
    is($c, 3);

    $h{yyy} = 888;
    $h{zzz} = 999;
}
is(scalar(keys(%h)), 4);
is($h{a}, 1);
is($h{b}, 2);
is($h{c}, 3);
ok($h{d}, 4);
ok(!exists($h{yyy}));
ok(!exists($h{zzz}));

%h = ('a' => { 'b' => 1 }, 'c' => 2);
{
    my $a = delete local $h{a};
    is(scalar(keys(%h)), 1);
    ok(!exists($h{a}));
    is($h{c}, 2);
    is(scalar(keys(%$a)), 1);

    my $b = delete local $a->{b};
    is(scalar(keys(%$a)), 0);
    is($b, 1);

    $a->{d} = 3;
}
is(scalar(keys(%h)), 2);
{
    my $a = $h{a};
    is(scalar(keys(%$a)), 2);
    is($a->{b}, 1);
    is($a->{d}, 3);
}
is($h{c}, 2);

a147 2
    sub EXISTS { print "# EXISTS [@@_]\n"; exists $_[0]->[$_[1]]; }
    sub DELETE { print "# DELETE [@@_]\n"; delete $_[0]->[$_[1]]; }
a171 96
# local() should preserve the existenceness of tied array elements
@@a = ('a', 'b', 'c');
{
    local($a[4]) = 'x';
    ok(!defined $a[3]);
    is($a[4], 'x');
}
is(scalar(@@a), 3);
ok(!exists $a[3]);
ok(!exists $a[4]);

@@a = ('a', 'b', 'c');
{
    local($a[5]) = 'z';
    $a[4] = 'y';
    ok(!defined $a[3]);
    is($a[4], 'y');
    is($a[5], 'z');
}
is(scalar(@@a), 5);
ok(!defined $a[3]);
is($a[4], 'y');
ok(!exists $a[5]);

@@a = ('a', 'b', 'c');
{
    local(@@a[4,6]) = ('x', 'z');
    ok(!defined $a[3]);
    is($a[4], 'x');
    ok(!defined $a[5]);
    is($a[6], 'z');
}
is(scalar(@@a), 3);
ok(!exists $a[3]);
ok(!exists $a[4]);
ok(!exists $a[5]);
ok(!exists $a[6]);

@@a = ('a', 'b', 'c');
{
    local(@@a[4,6]) = ('x', 'z');
    $a[5] = 'y';
    ok(!defined $a[3]);
    is($a[4], 'x');
    is($a[5], 'y');
    is($a[6], 'z');
}
is(scalar(@@a), 6);
ok(!defined $a[3]);
ok(!defined $a[4]);
is($a[5], 'y');
ok(!exists $a[6]);

@@a = ('a', 'b', 'c');
$a[4] = 'd';
{
    delete local $a[1];
    is(scalar(@@a), 5);
    is($a[0], 'a');
    ok(!exists($a[1]));
    is($a[2], 'c');
    ok(!exists($a[3]));
    is($a[4], 'd');

    ok(!exists($a[888]));
    delete local $a[888];
    is(scalar(@@a), 5);
    ok(!exists($a[888]));

    ok(!exists($a[999]));
    my ($d, $zzz) = delete local @@a[4, 999];
    is(scalar(@@a), 3);
    ok(!exists($a[4]));
    ok(!exists($a[999]));
    is($d, 'd');
    is($zzz, undef);

    my $c = delete local $a[2];
    is(scalar(@@a), 1);
    ok(!exists($a[2]));
    is($c, 'c');

    $a[888] = 'yyy';
    $a[999] = 'zzz';
}
is(scalar(@@a), 5);
is($a[0], 'a');
is($a[1], 'b');
is($a[2], 'c');
ok(!defined($a[3]));
is($a[4], 'd');
ok(!exists($a[5]));
ok(!exists($a[888]));
ok(!exists($a[999]));

# see if localization works on tied hashes
d184 1
a210 38
%h = (a => 1, b => 2, c => 3, d => 4);
{
    delete local $h{b};
    is(scalar(keys(%h)), 3);
    is($h{a}, 1);
    ok(!exists($h{b}));
    is($h{c}, 3);
    is($h{d}, 4);

    ok(!exists($h{yyy}));
    delete local $h{yyy};
    is(scalar(keys(%h)), 3);
    ok(!exists($h{yyy}));

    ok(!exists($h{zzz}));
    my ($d, $zzz) = delete local @@h{qw/d zzz/};
    is(scalar(keys(%h)), 2);
    ok(!exists($h{d}));
    ok(!exists($h{zzz}));
    is($d, 4);
    is($zzz, undef);

    my $c = delete local $h{c};
    is(scalar(keys(%h)), 1);
    ok(!exists($h{c}));
    is($c, 3);

    $h{yyy} = 888;
    $h{zzz} = 999;
}
is(scalar(keys(%h)), 4);
is($h{a}, 1);
is($h{b}, 2);
is($h{c}, 3);
ok($h{d}, 4);
ok(!exists($h{yyy}));
ok(!exists($h{zzz}));

a335 1
    no warnings 'deprecated';
@


1.1.1.10
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d8 1
a8 1
plan tests => 305;
a327 15
# RT #7938: localising an array should make it temporarily untied
{
    @@a = qw(a b c);
    local @@a = (6,7,8);
    is("@@a", "6 7 8", 'local @@a assigned 6,7,8');
    {
	my $c = 0;
	local *TA::STORE = sub { $c++ };
	$a[0] = 9;
	is($c, 0, 'STORE not called after array localised');
    }
    is("@@a", "9 7 8", 'local @@a should now be 9 7 8');
}
is("@@a", "a b c", '@@a should now contain original value');

a452 1

a462 18
# RT #7939: localising a hash should make it temporarily untied
{
    %h = qw(a 1 b 2 c 3);
    local %h = qw(x 6 y 7 z 8);
    is(join('', sort keys   %h), "xyz", 'local %h has new keys');
    is(join('', sort values %h), "678", 'local %h has new values');
    {
	my $c = 0;
	local *TH::STORE = sub { $c++ };
	$h{x} = 9;
	is($c, 0, 'STORE not called after hash localised');
    }
    is($h{x}, 9, '$h{x} should now be 9');
}
is(join('', sort keys   %h), "abc", 'restored %h has original keys');
is(join('', sort values %h), "123", 'restored %h has original values');


d587 2
a612 1
# local($_) always strips all magic
d614 8
d624 1
d626 4
a629 12
    my $STORE = my $FETCH = 0;
    package TieHash;
    sub TIEHASH { bless $_[1], $_[0] }
    sub FETCH   { ++$FETCH; 42 }
    sub STORE   { ++$STORE }

    package main;
    tie my %hash, "TieHash", {};

    eval { for ($hash{key}) {local $_ = 2} };
    is($STORE, 0);
    is($FETCH, 0);
d632 1
a632 3
# The s/// adds 'g' magic to $_, but it should remain non-readonly
eval { for("a") { for $x (1,2) { local $_="b"; s/(.*)/+$1/ } } };
is($@@, "");
d750 1
a750 1
# Keep these tests last, as they can SEGV
d756 1
a757 5
    local @@{"nugguton"};
    local %{"netgonch"};
    delete $::{$_} for 'nugguton','netgonch';
}
pass ('localised arrays and hashes do not crash if glob is deleted');
@


1.1.1.11
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d8 1
a8 1
plan tests => 310;
d12 1
a12 1
#mg.c says list assignment not supported on VMS and SYMBIAN.
a783 21
# related to perl #112966
# Magic should not cause elements not to be deleted after scope unwinding
# when they did not exist before local()
() = \$#squinch; # $#foo in lvalue context makes array magical
{
    local $squinch[0];
    local @@squinch[1..2];
    package Flibbert;
    m??; # makes stash magical
    local $Flibbert::{foo};
    local @@Flibbert::{<bar baz>};
}
ok !exists $Flibbert::{foo},
  'local helem on magic hash does not leave elems on scope exit';
ok !exists $Flibbert::{bar},
  'local hslice on magic hash does not leave elems on scope exit';
ok !exists $squinch[0],
  'local aelem on magic hash does not leave elems on scope exit';
ok !exists $squinch[1],
  'local aslice on magic hash does not leave elems on scope exit';

a795 11

# [perl #112966] Rmagic can cause delete local to crash
package Grompits {
local $SIG{__WARN__};
    delete local $ISA[0];
    delete local @@ISA[1..10];
    m??; # makes stash magical
    delete local $Grompits::{foo};
    delete local @@Grompits::{<foo bar>};
}
pass 'rmagic does not cause delete local to crash on nonexistent elems';
@


1.1.1.12
log
@Import perl-5.20.1
@
text
@d631 1
a631 1
    # BUG 20001205.022 (RT #4852)
@


1.1.1.13
log
@Import perl-5.24.2
@
text
@d782 1
a782 1
                      'local *g=${::}{foo};print q(ok);'), qr/^ok$/, "[perl #52740]");
@


