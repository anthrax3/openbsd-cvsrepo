head	1.9;
access;
symbols
	OPENBSD_6_0:1.8.0.10
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.4
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.6
	OPENBSD_5_8_BASE:1.8
	PERL_5_20_2:1.1.1.8
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	PERL_5_20_1:1.1.1.8
	OPENBSD_5_6:1.7.0.8
	OPENBSD_5_6_BASE:1.7
	PERL_5_18_2:1.1.1.7
	PERL:1.1.1
	OPENBSD_5_5:1.7.0.6
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.2
	OPENBSD_5_4_BASE:1.7
	PERL_5_16_3:1.1.1.7
	OPENBSD_5_3:1.6.0.28
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.26
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.24
	OPENBSD_5_0:1.6.0.22
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.20
	OPENBSD_4_9_BASE:1.6
	PERL_5_12_2:1.1.1.6
	OPENBSD_4_8:1.6.0.18
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.14
	OPENBSD_4_7_BASE:1.6
	PERL_5_10_1:1.1.1.6
	OPENBSD_4_6:1.6.0.16
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.12
	OPENBSD_4_5_BASE:1.6
	PERL_5_10_0:1.1.1.6
	OPENBSD_4_4:1.6.0.10
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.8
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.6
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.4
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.2
	OPENBSD_4_0_BASE:1.6
	PERL_5_8_8:1.1.1.6
	OPENBSD_3_9:1.5.0.14
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.12
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.10
	OPENBSD_3_7_BASE:1.5
	PERL_5_8_6:1.1.1.5
	OPENBSD_3_6:1.5.0.8
	OPENBSD_3_6_BASE:1.5
	PERL_5_8_5:1.1.1.5
	PERL_5_8_3:1.1.1.5
	OPENBSD_3_5:1.5.0.6
	OPENBSD_3_5_BASE:1.5
	PERL_5_8_2:1.1.1.5
	OPENBSD_3_4:1.5.0.4
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.4.0.6
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.4
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.3.0.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.2.0.8
	OPENBSD_2_6_BASE:1.2
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.9
date	2017.02.05.00.32.20;	author afresh1;	state Exp;
branches;
next	1.8;
commitid	cxJ08BvJA9Pt2PTM;

1.8
date	2014.11.17.20.57.07;	author afresh1;	state Exp;
branches;
next	1.7;
commitid	QP75iYx42Uo7mMxO;

1.7
date	2013.03.25.20.40.59;	author sthen;	state Exp;
branches;
next	1.6;

1.6
date	2006.03.28.19.23.13;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.10.27.22.25.37;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.24.18.36.20;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.06.17.08.29;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.08.05.35;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.13.21;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.13.21;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.41.49;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.10.50;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.25.44;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.15.10;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2006.03.28.18.49.46;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2013.03.25.20.09.36;	author sthen;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2014.11.17.20.53.18;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.9
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl

# From Tom Phoenix <rootbeer@@teleport.com> 22 Feb 1997
# Based upon a test script by kgb@@ast.cam.ac.uk (Karl Glazebrook)

# Looking for the hints? You're in the right place. 
# The hints are near each test, so search for "TEST #", where
# the pound sign is replaced by the number of the test.

# I'd like to include some more robust tests, but anything
# too subtle to be detected here would require a time-consuming
# test. Also, of course, we're here to detect only flaws in Perl;
# if there are flaws in the underlying system rand, that's not
# our responsibility. But if you want better tests, see
# The Art of Computer Programming, Donald E. Knuth, volume 2,
# chapter 3. ISBN 0-201-03822-6 (v. 2)

BEGIN {
    chdir "t" if -d "t";
    @@INC = qw(. ../lib);
}

use strict;
use Config;

require "./test.pl";


my $reps = 100_000;	# How many times to try rand each time.
			# May be changed, but should be over 500.
			# The more the better! (But slower.)

my $bits = 8;  # how many significant bits we check on each random number
my $nslots = (1<< $bits); # how many different numbers

plan(tests => 7 + $nslots);

# First, let's see whether randbits is set right and that rand() returns
# an even distribution of values
{
    my $sum;
    my @@slots = (0) x $nslots;
    my $prob = 1/$nslots;     # probability of a particular slot being
                              # on a particular iteration

    # We are going to generate $reps random numbers, each in the range
    # 0..$nslots-1. They should be evenly distributed. We use @@slots to
    # count the number of occurrences of each number. For each count, we
    # check that it is in the range we expect. For example for reps =
    # 100_000 and using 8 bits, we expect each count to be around
    # 100_000/256 = 390. How much around it we tolerate depends on the
    # standard deviation, and how many deviations we allow. If we allow
    # 6-sigmas, then that means that in only 1 run in 506e6 will be get a
    # failure by chance, assuming a fair random number generator. Given
    # that we test each slot, the overall chance of a false negative in
    # this test script is about 1 in 2e6, assuming 256 slots.
    #
    # the actual count in a slot should follow a binomial distribution
    # (e.g. rolling 18 dice, we 'expect' to see 3 sixes, but there's
    # actually a 24% chance of 3, a 20% change of 2 or 4, a 12%
    # chance of 1 or 5, and a 4% chance of 0 or 6 of them).
    #
    # This makes it easy to calculate the expected mean a standard
    # deviation; see
    #     https://en.wikipedia.org/wiki/Binomial_distribution#Variance

    my $mean   = $reps * $prob;
    my $stddev = sqrt($reps * $prob * (1 - $prob));
    my $sigma6 = $stddev * 6.0; # very unlikely to be outside that range
    my $min = $mean - $sigma6;
    my $max = $mean + $sigma6;

    note("reps=$reps; slots=$nslots; min=$min mean=$mean max=$max");

    for (1..$reps) {
	my $n = rand(1);
	if ($n < 0.0 or $n >= 1.0) {
	    diag(<<EOM);
WHOA THERE!  \$Config{drand01} is set to '$Config{drand01}',
but that apparently produces values ($n) < 0.0 or >= 1.0.
Make sure \$Config{drand01} is a valid expression in the
C-language, and produces values in the range [0.0,1.0).

I give up.
EOM
	    exit;
	}
        $slots[int($n * $nslots)]++;
    }

    for my $i (0..$nslots - 1) {
        # this test should randomly fail very rarely. If it fails
        # for you, try re-running this test script a few more times;
        # if it goes away, it was likely a random (ha ha!) glitch.
        # If you keep seeing failures, it means your random number
        # generator is producing a very uneven spread of values.
        ok($slots[$i] >= $min && $slots[$i] <= $max, "checking slot $i")
            or diag("slot $i; count $slots[$i] outside expected range $min..$max");
    }
}


# Now, let's see whether rand accepts its argument
{
    my($max, $min);
    $max = $min = rand(100);
    for (1..$reps) {
	my $n = rand(100);
	$max = $n if $n > $max;
	$min = $n if $n < $min;
    }

    # This test checks to see that rand(100) really falls 
    # within the range 0 - 100, and that the numbers produced
    # have a reasonably-large range among them.
    #
    cmp_ok($min,        '>=',  0, "rand(100) >= 0");
    cmp_ok($max,        '<', 100, "rand(100) < 100");
    cmp_ok($max - $min, '>=', 65, "rand(100) in 65 range");


    # This test checks that rand without an argument
    # is equivalent to rand(1).
    #
    $_ = 12345;		# Just for fun.
    srand 12345;
    my $r = rand;
    srand 12345;
    is(rand(1),  $r,  'rand() without args is rand(1)');


    # This checks that rand without an argument is not
    # rand($_). (In case somebody got overzealous.)
    # 
    cmp_ok($r, '<', 1,   'rand() without args is under 1');
}

{ # [perl #115928] use a standard rand() implementation
    srand(1);
    is(int rand(1000), 41, "our own implementation behaves consistently");
    is(int rand(1000), 454, "and still consistently");
}
@


1.8
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d26 1
a26 2
require "test.pl";
plan(tests => 10);
d29 1
a29 1
my $reps = 15000;	# How many times to try rand each time.
d33 4
a36 9
sub bits ($) {
    # Takes a small integer and returns the number of one-bits in it.
    my $total;
    my $bits = sprintf "%o", $_[0];
    while (length $bits) {
	$total += (0,1,1,2,1,2,2,3)[chop $bits];	# Oct to bits
    }
    $total;
}
d38 2
a39 1
# First, let's see whether randbits is set right
d41 34
a74 5
    my($max, $min, $sum);	# Characteristics of rand
    my($off, $shouldbe);	# Problems with randbits
    my($dev, $bits);		# Number of one bits
    my $randbits = $Config{randbits};
    $max = $min = rand(1);
d78 7
a84 7
	    print <<EOM;
# WHOA THERE!  \$Config{drand01} is set to '$Config{drand01}',
# but that apparently produces values < 0.0 or >= 1.0.
# Make sure \$Config{drand01} is a valid expression in the
# C-language, and produces values in the range [0.0,1.0).
#
# I give up.
d88 1
a88 8
	$sum += $n;
	$bits += bits($n * 256);	# Don't be greedy; 8 is enough
		    # It's too many if randbits is less than 8!
		    # But that should never be the case... I hope.
		    # Note: If you change this, you must adapt the
		    # formula for absolute standard deviation, below.
	$max = $n if $n > $max;
	$min = $n if $n < $min;
d91 8
a98 46

    # This test checks for one of Perl's most frequent
    # mis-configurations. Your system's documentation
    # for rand(2) should tell you what value you need
    # for randbits. Usually the diagnostic message
    # has the right value as well. Just fix it and
    # recompile, and you'll usually be fine. (The main 
    # reason that the diagnostic message might get the
    # wrong value is that Config.pm is incorrect.)
    #
    unless (ok( !$max <= 0 or $max >= (2 ** $randbits))) {# Just in case...
	print <<DIAG;
# max=[$max] min=[$min]
# This perl was compiled with randbits=$randbits
# which is _way_ off. Or maybe your system rand is broken,
# or your C compiler can't multiply, or maybe Martians
# have taken over your computer. For starters, see about
# trying a better value for randbits, probably smaller.
DIAG

	# If that isn't the problem, we'll have
	# to put d_martians into Config.pm 
	print "# Skipping remaining tests until randbits is fixed.\n";
	exit;
    }

    $off = log($max) / log(2);			# log2
    $off = int($off) + ($off > 0);		# Next more positive int
    unless (is( $off, 0 )) {
	$shouldbe = $Config{randbits} + $off;
	print "# max=[$max] min=[$min]\n";
	print "# This perl was compiled with randbits=$randbits on $^O.\n";
	print "# Consider using randbits=$shouldbe instead.\n";
	# And skip the remaining tests; they would be pointless now.
	print "# Skipping remaining tests until randbits is fixed.\n";
	exit;
    }


    # This should always be true: 0 <= rand(1) < 1
    # If this test is failing, something is seriously wrong,
    # either in perl or your system's rand function.
    #
    unless (ok( !($min < 0 or $max >= 1) )) {	# Slightly redundant...
	print "# min too low\n" if $min < 0;
	print "# max too high\n" if $max >= 1;
a99 84


    # This is just a crude test. The average number produced
    # by rand should be about one-half. But once in a while
    # it will be relatively far away. Note: This test will
    # occasionally fail on a perfectly good system!
    # See the hints for test 4 to see why.
    #
    $sum /= $reps;
    unless (ok( !($sum < 0.4 or $sum > 0.6) )) {
	print "# Average random number is far from 0.5\n";
    }


    #   NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE
    # This test will fail .006% of the time on a normal system.
    #				also
    # This test asks you to see these hints 100% of the time!
    #   NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE
    #
    # There is probably no reason to be alarmed that
    # something is wrong with your rand function. But,
    # if you're curious or if you can't help being 
    # alarmed, keep reading.
    #
    # This is a less-crude test than test 3. But it has
    # the same basic flaw: Unusually distributed random
    # values should occasionally appear in every good
    # random number sequence. (If you flip a fair coin
    # twenty times every day, you'll see it land all
    # heads about one time in a million days, on the
    # average. That might alarm you if you saw it happen
    # on the first day!)
    #
    # So, if this test failed on you once, run it a dozen
    # times. If it keeps failing, it's likely that your
    # rand is bogus. If it keeps passing, it's likely
    # that the one failure was bogus. If it's a mix,
    # read on to see about how to interpret the tests.
    #
    # The number printed in square brackets is the
    # standard deviation, a statistical measure
    # of how unusual rand's behavior seemed. It should
    # fall in these ranges with these *approximate*
    # probabilities:
    #
    #		under 1		68.26% of the time
    #		1-2		27.18% of the time
    #		2-3		 4.30% of the time
    #		over 3		 0.26% of the time
    #
    # If the numbers you see are not scattered approximately
    # (not exactly!) like that table, check with your vendor
    # to find out what's wrong with your rand. Or with this
    # algorithm. :-)
    #
    # Calculating absolute standard deviation for number of bits set
    # (eight bits per rep)
    $dev = abs ($bits - $reps * 4) / sqrt($reps * 2);

    ok( $dev < 4.0 );

    if ($dev < 1.96) {
	print "# Your rand seems fine. If this test failed\n";
	print "# previously, you may want to run it again.\n";
    } elsif ($dev < 2.575) {
	print "# This is ok, but suspicious. But it will happen\n";
	print "# one time out of 25, more or less.\n";
	print "# You should run this test again to be sure.\n";
    } elsif ($dev < 3.3) {
	print "# This is very suspicious. It will happen only\n";
	print "# about one time out of 100, more or less.\n";
	print "# You should run this test again to be sure.\n";
    } elsif ($dev < 3.9) {
	print "# This is VERY suspicious. It will happen only\n";
	print "# about one time out of 1000, more or less.\n";
	print "# You should run this test again to be sure.\n";
    } else {
	print "# This is VERY VERY suspicious.\n";
	print "# Your rand seems to be bogus.\n";
    }
    print "#\n# If you are having random number troubles,\n";
    print "# see the hints within the test script for more\n";
    printf "# information on why this might fail. [ %.3f ]\n", $dev;
d117 3
a119 5
    unless ( ok( !($min < 0 or $max >= 100 or ($max - $min) < 65) ) ) {
	print "# min too low\n" if $min < 0;
	print "# max too high\n" if $max >= 100;
	print "# range too narrow\n" if ($max - $min) < 65;
    }
d135 1
a135 1
    ok($r < 1,        'rand() without args is under 1');
@


1.7
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d27 1
a27 1
plan(tests => 8);
d245 5
@


1.6
log
@merge in perl 5.8.8
@
text
@d136 1
a136 1
    # This test will fail .1% of the time on a normal system.
d177 1
a177 1
    # Calculating absoulute standard deviation for number of bits set
d181 1
a181 1
    ok( $dev < 3.3 );
@


1.5
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d30 1
a30 1
my $reps = 10000;	# How many times to try rand each time.
@


1.4
log
@merge in perl 5.6.1 with our local changes
@
text
@d20 1
a20 1
    @@INC = '../lib';
d26 2
a27 1
print "1..11\n";
a28 3
srand;			# Shouldn't need this with 5.004...
			# But I'll include it now and test for
			# whether we needed it later.
d30 1
a30 1
my $reps = 1000;	# How many times to try rand each time.
a74 2
    # Hints for TEST 1
    #
d84 10
a93 7
    if ($max <= 0 or $max >= (2 ** $randbits)) {# Just in case...
	print "# max=[$max] min=[$min]\nnot ok 1\n";
	print "# This perl was compiled with randbits=$randbits\n";
	print "# which is _way_ off. Or maybe your system rand is broken,\n";
	print "# or your C compiler can't multiply, or maybe Martians\n";
	print "# have taken over your computer. For starters, see about\n";
	print "# trying a better value for randbits, probably smaller.\n";
d102 1
a102 1
    if ($off) {
d104 1
a104 1
	print "# max=[$max] min=[$min]\nnot ok 1\n";
a109 2
    } else {
	print "ok 1\n";
d112 1
a112 2
    # Hints for TEST 2
    #
d117 1
a117 2
    if ($min < 0 or $max >= 1) {	# Slightly redundant...
	print "not ok 2\n";
a119 2
    } else {
	print "ok 2\n";
d122 1
a122 2
    # Hints for TEST 3
    #
d130 2
a131 4
    if ($sum < 0.4 or $sum > 0.6) {
	print "not ok 3\n# Average random number is far from 0.5\n";
    } else {
	print "ok 3\n";
d134 1
a134 2
    # Hints for TEST 4
    #
d181 2
a183 1
	print "ok 4\n";		# 95% of the time.
a186 1
	print "ok 4\n# In here about 4% of the time. Hmmm...\n";
a190 1
	print "ok 4\n# In this range about 1% of the time.\n";
a194 1
	print "not ok 4\n# In this range very rarely.\n";
a198 1
	print "not ok 4\n# Seriously whacked.\n";
a206 51
{
    srand;		# These three lines are for test 7
    my $time = time;	# It's just faster to do them here.
    my $rand = join ", ", rand, rand, rand;

    # Hints for TEST 5
    # 
    # This test checks that the argument to srand actually 
    # sets the seed for generating random numbers. 
    #
    srand(3.14159);
    my $r = rand;
    srand(3.14159);
    if (rand != $r) {
	print "not ok 5\n";
	print "# srand is not consistent.\n";
    } else {
	print "ok 5\n";
    }

    # Hints for TEST 6
    # 
    # This test just checks that the previous one didn't 
    # give us false confidence!
    #
    if (rand == $r) {
	print "not ok 6\n";
	print "# rand is now unchanging!\n";
    } else {
	print "ok 6\n";
    }

    # Hints for TEST 7
    #
    # This checks that srand without arguments gives
    # different sequences each time. Note: You shouldn't
    # be calling srand more than once unless you know
    # what you're doing! But if this fails on your 
    # system, run perlbug and let the developers know
    # what other sources of randomness srand should
    # tap into.
    #
    while ($time == time) { }	# Wait for new second, just in case.
    srand;
    if ((join ", ", rand, rand, rand) eq $rand) {
	print "not ok 7\n";
	print "# srand without args isn't varying.\n";
    } else {
	print "ok 7\n";
    }
}
a217 2
    # Hints for TEST 8
    #
d222 1
a222 2
    if ($min < 0 or $max >= 100 or ($max - $min) < 65) {
	print "not ok 8\n";
a225 2
    } else {
	print "ok 8\n";
d228 1
a228 2
    # Hints for TEST 9
    #
d236 2
a237 6
    if (rand(1) == $r) {
	print "ok 9\n";
    } else {
	print "not ok 9\n";
	print "# rand without arguments isn't rand(1)!\n";
    }
a238 2
    # Hints for TEST 10
    #
d242 1
a242 6
    if ($r >= 1) {
	print "not ok 10\n";
	print "# rand without arguments isn't under 1!\n";
    } else {
	print "ok 10\n";
    }
a244 33
# Hints for TEST 11
#
# This test checks whether Perl called srand for you. This should
# be the case in version 5.004 and later. Note: You must still
# call srand if your code might ever be run on a pre-5.004 system!
#
AUTOSRAND:
{
    unless ($Config{d_fork}) {
	# Skip this test. It's not likely to be system-specific, anyway.
	print "ok 11\n# Skipping this test on this platform.\n";
	last;
    }

    my($pid, $first);
    for (1..5) {
	my $PERL = (($^O eq 'VMS') ? "MCR $^X"
		    : ($^O eq 'MSWin32') ? '.\perl'
		    : './perl');
	$pid = open PERL, qq[$PERL -e "print rand"|];
	die "Couldn't pipe from perl: $!" unless defined $pid;
	if (defined $first) {
	    if ($first ne <PERL>) {
		print "ok 11\n";
		last AUTOSRAND;
	    }
	} else {
	    $first = <PERL>;
	}
	close PERL or die "perl returned error code $?";
    }
    print "not ok 11\n# srand isn't being autocalled.\n";
}
@


1.3
log
@perl-5.6.0 + local changes
@
text
@d20 1
a20 1
    unshift @@INC, "../lib" if -d "../lib";
@


1.2
log
@perl 5.004_04
@
text
@d20 1
a20 1
    @@INC = "../lib" if -d "../lib";
d55 11
d88 2
a89 2
    if ($max <= 0 or $max >= (1 << $randbits)) {	# Just in case...
	print "not ok 1\n";
d105 1
a105 1
	print "not ok 1\n";
@


1.1
log
@Initial revision
@
text
@d3 2
a4 1
# From: kgb@@ast.cam.ac.uk (Karl Glazebrook)
d6 16
a21 1
print "1..4\n";
d23 2
a24 1
srand;
d26 1
a26 8
$m=0; 
for(1..1000){ 
   $n = rand(1);
   if ($n<0 || $n>=1) {
       print "not ok 1\n# The value of randbits is likely too low in config.sh\n";
       exit
   }
   $m += $n;
d28 16
a44 2
$m=$m/1000;
print "ok 1\n";
d46 162
a207 2
if ($m<0.4) {
    print "not ok 2\n# The value of randbits is likely too high in config.sh\n";
d209 51
a259 4
elsif ($m>0.6) {
    print "not ok 2\n# Something's really weird about rand()'s distribution.\n";
}else{
    print "ok 2\n";
d262 52
a313 11
srand;

$m=0; 
for(1..1000){ 
   $n = rand(100);
   if ($n<0 || $n>=100) {
       print "not ok 3\n";
       exit
   }
   $m += $n;

a314 2
$m=$m/1000;
print "ok 3\n";
d316 32
a347 4
if ($m<40 || $m>60) {
    print "not ok 4\n";
}else{
    print "ok 4\n";
a348 2


@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d3 1
a3 2
# From Tom Phoenix <rootbeer@@teleport.com> 22 Feb 1997
# Based upon a test script by kgb@@ast.cam.ac.uk (Karl Glazebrook)
d5 1
a5 16
# Looking for the hints? You're in the right place. 
# The hints are near each test, so search for "TEST #", where
# the pound sign is replaced by the number of the test.

# I'd like to include some more robust tests, but anything
# too subtle to be detected here would require a time-consuming
# test. Also, of course, we're here to detect only flaws in Perl;
# if there are flaws in the underlying system rand, that's not
# our responsibility. But if you want better tests, see
# The Art of Computer Programming, Donald E. Knuth, volume 2,
# chapter 3. ISBN 0-201-03822-6 (v. 2)

BEGIN {
    chdir "t" if -d "t";
    @@INC = "../lib" if -d "../lib";
}
d7 1
a7 2
use strict;
use Config;
d9 8
a16 1
print "1..11\n";
a17 16
srand;			# Shouldn't need this with 5.004...
			# But I'll include it now and test for
			# whether we needed it later.

my $reps = 1000;	# How many times to try rand each time.
			# May be changed, but should be over 500.
			# The more the better! (But slower.)

sub bits ($) {
    # Takes a small integer and returns the number of one-bits in it.
    my $total;
    my $bits = sprintf "%o", $_[0];
    while (length $bits) {
	$total += (0,1,1,2,1,2,2,3)[chop $bits];	# Oct to bits
    }
    $total;
d19 2
d22 7
a28 162
# First, let's see whether randbits is set right
{
    my($max, $min, $sum);	# Characteristics of rand
    my($off, $shouldbe);	# Problems with randbits
    my($dev, $bits);		# Number of one bits
    my $randbits = $Config{randbits};
    $max = $min = rand(1);
    for (1..$reps) {
	my $n = rand(1);
	$sum += $n;
	$bits += bits($n * 256);	# Don't be greedy; 8 is enough
		    # It's too many if randbits is less than 8!
		    # But that should never be the case... I hope.
		    # Note: If you change this, you must adapt the
		    # formula for absolute standard deviation, below.
	$max = $n if $n > $max;
	$min = $n if $n < $min;
    }


    # Hints for TEST 1
    #
    # This test checks for one of Perl's most frequent
    # mis-configurations. Your system's documentation
    # for rand(2) should tell you what value you need
    # for randbits. Usually the diagnostic message
    # has the right value as well. Just fix it and
    # recompile, and you'll usually be fine. (The main 
    # reason that the diagnostic message might get the
    # wrong value is that Config.pm is incorrect.)
    #
    if ($max <= 0 or $max >= (1 << $randbits)) {	# Just in case...
	print "not ok 1\n";
	print "# This perl was compiled with randbits=$randbits\n";
	print "# which is _way_ off. Or maybe your system rand is broken,\n";
	print "# or your C compiler can't multiply, or maybe Martians\n";
	print "# have taken over your computer. For starters, see about\n";
	print "# trying a better value for randbits, probably smaller.\n";
	# If that isn't the problem, we'll have
	# to put d_martians into Config.pm 
	print "# Skipping remaining tests until randbits is fixed.\n";
	exit;
    }

    $off = log($max) / log(2);			# log2
    $off = int($off) + ($off > 0);		# Next more positive int
    if ($off) {
	$shouldbe = $Config{randbits} + $off;
	print "not ok 1\n";
	print "# This perl was compiled with randbits=$randbits on $^O.\n";
	print "# Consider using randbits=$shouldbe instead.\n";
	# And skip the remaining tests; they would be pointless now.
	print "# Skipping remaining tests until randbits is fixed.\n";
	exit;
    } else {
	print "ok 1\n";
    }

    # Hints for TEST 2
    #
    # This should always be true: 0 <= rand(1) < 1
    # If this test is failing, something is seriously wrong,
    # either in perl or your system's rand function.
    #
    if ($min < 0 or $max >= 1) {	# Slightly redundant...
	print "not ok 2\n";
	print "# min too low\n" if $min < 0;
	print "# max too high\n" if $max >= 1;
    } else {
	print "ok 2\n";
    }

    # Hints for TEST 3
    #
    # This is just a crude test. The average number produced
    # by rand should be about one-half. But once in a while
    # it will be relatively far away. Note: This test will
    # occasionally fail on a perfectly good system!
    # See the hints for test 4 to see why.
    #
    $sum /= $reps;
    if ($sum < 0.4 or $sum > 0.6) {
	print "not ok 3\n# Average random number is far from 0.5\n";
    } else {
	print "ok 3\n";
    }

    # Hints for TEST 4
    #
    #   NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE
    # This test will fail .1% of the time on a normal system.
    #				also
    # This test asks you to see these hints 100% of the time!
    #   NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE
    #
    # There is probably no reason to be alarmed that
    # something is wrong with your rand function. But,
    # if you're curious or if you can't help being 
    # alarmed, keep reading.
    #
    # This is a less-crude test than test 3. But it has
    # the same basic flaw: Unusually distributed random
    # values should occasionally appear in every good
    # random number sequence. (If you flip a fair coin
    # twenty times every day, you'll see it land all
    # heads about one time in a million days, on the
    # average. That might alarm you if you saw it happen
    # on the first day!)
    #
    # So, if this test failed on you once, run it a dozen
    # times. If it keeps failing, it's likely that your
    # rand is bogus. If it keeps passing, it's likely
    # that the one failure was bogus. If it's a mix,
    # read on to see about how to interpret the tests.
    #
    # The number printed in square brackets is the
    # standard deviation, a statistical measure
    # of how unusual rand's behavior seemed. It should
    # fall in these ranges with these *approximate*
    # probabilities:
    #
    #		under 1		68.26% of the time
    #		1-2		27.18% of the time
    #		2-3		 4.30% of the time
    #		over 3		 0.26% of the time
    #
    # If the numbers you see are not scattered approximately
    # (not exactly!) like that table, check with your vendor
    # to find out what's wrong with your rand. Or with this
    # algorithm. :-)
    #
    # Calculating absoulute standard deviation for number of bits set
    # (eight bits per rep)
    $dev = abs ($bits - $reps * 4) / sqrt($reps * 2);

    if ($dev < 1.96) {
	print "ok 4\n";		# 95% of the time.
	print "# Your rand seems fine. If this test failed\n";
	print "# previously, you may want to run it again.\n";
    } elsif ($dev < 2.575) {
	print "ok 4\n# In here about 4% of the time. Hmmm...\n";
	print "# This is ok, but suspicious. But it will happen\n";
	print "# one time out of 25, more or less.\n";
	print "# You should run this test again to be sure.\n";
    } elsif ($dev < 3.3) {
	print "ok 4\n# In this range about 1% of the time.\n";
	print "# This is very suspicious. It will happen only\n";
	print "# about one time out of 100, more or less.\n";
	print "# You should run this test again to be sure.\n";
    } elsif ($dev < 3.9) {
	print "not ok 4\n# In this range very rarely.\n";
	print "# This is VERY suspicious. It will happen only\n";
	print "# about one time out of 1000, more or less.\n";
	print "# You should run this test again to be sure.\n";
    } else {
	print "not ok 4\n# Seriously whacked.\n";
	print "# This is VERY VERY suspicious.\n";
	print "# Your rand seems to be bogus.\n";
    }
    print "#\n# If you are having random number troubles,\n";
    print "# see the hints within the test script for more\n";
    printf "# information on why this might fail. [ %.3f ]\n", $dev;
d31 11
a41 50
{
    srand;		# These three lines are for test 7
    my $time = time;	# It's just faster to do them here.
    my $rand = join ", ", rand, rand, rand;

    # Hints for TEST 5
    # 
    # This test checks that the argument to srand actually 
    # sets the seed for generating random numbers. 
    #
    srand(3.14159);
    my $r = rand;
    srand(3.14159);
    if (rand != $r) {
	print "not ok 5\n";
	print "# srand is not consistent.\n";
    } else {
	print "ok 5\n";
    }

    # Hints for TEST 6
    # 
    # This test just checks that the previous one didn't 
    # give us false confidence!
    #
    if (rand == $r) {
	print "not ok 6\n";
	print "# rand is now unchanging!\n";
    } else {
	print "ok 6\n";
    }

    # Hints for TEST 7
    #
    # This checks that srand without arguments gives
    # different sequences each time. Note: You shouldn't
    # be calling srand more than once unless you know
    # what you're doing! But if this fails on your 
    # system, run perlbug and let the developers know
    # what other sources of randomness srand should
    # tap into.
    #
    while ($time == time) { }	# Wait for new second, just in case.
    srand;
    if ((join ", ", rand, rand, rand) eq $rand) {
	print "not ok 7\n";
	print "# srand without args isn't varying.\n";
    } else {
	print "ok 7\n";
    }
d43 2
d46 4
a49 52
# Now, let's see whether rand accepts its argument
{
    my($max, $min);
    $max = $min = rand(100);
    for (1..$reps) {
	my $n = rand(100);
	$max = $n if $n > $max;
	$min = $n if $n < $min;
    }

    # Hints for TEST 8
    #
    # This test checks to see that rand(100) really falls 
    # within the range 0 - 100, and that the numbers produced
    # have a reasonably-large range among them.
    #
    if ($min < 0 or $max >= 100 or ($max - $min) < 65) {
	print "not ok 8\n";
	print "# min too low\n" if $min < 0;
	print "# max too high\n" if $max >= 100;
	print "# range too narrow\n" if ($max - $min) < 65;
    } else {
	print "ok 8\n";
    }

    # Hints for TEST 9
    #
    # This test checks that rand without an argument
    # is equivalent to rand(1).
    #
    $_ = 12345;		# Just for fun.
    srand 12345;
    my $r = rand;
    srand 12345;
    if (rand(1) == $r) {
	print "ok 9\n";
    } else {
	print "not ok 9\n";
	print "# rand without arguments isn't rand(1)!\n";
    }

    # Hints for TEST 10
    #
    # This checks that rand without an argument is not
    # rand($_). (In case somebody got overzealous.)
    # 
    if ($r >= 1) {
	print "not ok 10\n";
	print "# rand without arguments isn't under 1!\n";
    } else {
	print "ok 10\n";
    }
d52 1
a52 33
# Hints for TEST 11
#
# This test checks whether Perl called srand for you. This should
# be the case in version 5.004 and later. Note: You must still
# call srand if your code might ever be run on a pre-5.004 system!
#
AUTOSRAND:
{
    unless ($Config{d_fork}) {
	# Skip this test. It's not likely to be system-specific, anyway.
	print "ok 11\n# Skipping this test on this platform.\n";
	last;
    }

    my($pid, $first);
    for (1..5) {
	my $PERL = (($^O eq 'VMS') ? "MCR $^X"
		    : ($^O eq 'MSWin32') ? '.\perl'
		    : './perl');
	$pid = open PERL, qq[$PERL -e "print rand"|];
	die "Couldn't pipe from perl: $!" unless defined $pid;
	if (defined $first) {
	    if ($first ne <PERL>) {
		print "ok 11\n";
		last AUTOSRAND;
	    }
	} else {
	    $first = <PERL>;
	}
	close PERL or die "perl returned error code $?";
    }
    print "not ok 11\n# srand isn't being autocalled.\n";
}
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d20 1
a20 1
    unshift @@INC, "../lib" if -d "../lib";
a54 11
	if ($n < 0.0 or $n >= 1.0) {
	    print <<EOM;
# WHOA THERE!  \$Config{drand01} is set to '$Config{drand01}',
# but that apparently produces values < 0.0 or >= 1.0.
# Make sure \$Config{drand01} is a valid expression in the
# C-language, and produces values in the range [0.0,1.0).
#
# I give up.
EOM
	    exit;
	}
d77 2
a78 2
    if ($max <= 0 or $max >= (2 ** $randbits)) {# Just in case...
	print "# max=[$max] min=[$min]\nnot ok 1\n";
d94 1
a94 1
	print "# max=[$max] min=[$min]\nnot ok 1\n";
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d20 1
a20 1
    @@INC = '../lib';
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d20 1
a20 1
    @@INC = qw(. ../lib);
d26 1
a26 2
require "test.pl";
plan(tests => 8);
d28 3
d32 1
a32 1
my $reps = 10000;	# How many times to try rand each time.
d77 2
d88 7
a94 10
    unless (ok( !$max <= 0 or $max >= (2 ** $randbits))) {# Just in case...
	print <<DIAG;
# max=[$max] min=[$min]
# This perl was compiled with randbits=$randbits
# which is _way_ off. Or maybe your system rand is broken,
# or your C compiler can't multiply, or maybe Martians
# have taken over your computer. For starters, see about
# trying a better value for randbits, probably smaller.
DIAG

d103 1
a103 1
    unless (is( $off, 0 )) {
d105 1
a105 1
	print "# max=[$max] min=[$min]\n";
d111 2
d115 2
a116 1

d121 2
a122 1
    unless (ok( !($min < 0 or $max >= 1) )) {	# Slightly redundant...
d125 2
d129 2
a130 1

d138 4
a141 2
    unless (ok( !($sum < 0.4 or $sum > 0.6) )) {
	print "# Average random number is far from 0.5\n";
d144 2
a145 1

a191 2
    ok( $dev < 3.3 );

d193 1
d197 1
d202 1
d207 1
d212 1
d221 51
d283 2
d289 2
a290 1
    unless ( ok( !($min < 0 or $max >= 100 or ($max - $min) < 65) ) ) {
d294 2
d298 2
a299 1

d307 6
a312 2
    is(rand(1),  $r,  'rand() without args is rand(1)');

d314 2
d319 6
a324 1
    ok($r < 1,        'rand() without args is under 1');
d327 33
@


1.1.1.6
log
@perl 5.8.8 import
@
text
@d30 1
a30 1
my $reps = 15000;	# How many times to try rand each time.
@


1.1.1.7
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d136 1
a136 1
    # This test will fail .006% of the time on a normal system.
d177 1
a177 1
    # Calculating absolute standard deviation for number of bits set
d181 1
a181 1
    ok( $dev < 4.0 );
@


1.1.1.8
log
@Import perl-5.20.1
@
text
@d27 1
a27 1
plan(tests => 10);
a244 5
{ # [perl #115928] use a standard rand() implementation
    srand(1);
    is(int rand(1000), 41, "our own implementation behaves consistently");
    is(int rand(1000), 454, "and still consistently");
}
@


