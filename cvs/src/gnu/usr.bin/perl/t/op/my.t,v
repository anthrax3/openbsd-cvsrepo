head	1.9;
access;
symbols
	OPENBSD_6_0:1.8.0.12
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.6
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.8
	OPENBSD_5_8_BASE:1.8
	PERL_5_20_2:1.1.1.7
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	PERL_5_20_1:1.1.1.7
	OPENBSD_5_6:1.8.0.4
	OPENBSD_5_6_BASE:1.8
	PERL_5_18_2:1.1.1.7
	PERL:1.1.1
	OPENBSD_5_5:1.7.0.24
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.20
	OPENBSD_5_4_BASE:1.7
	PERL_5_16_3:1.1.1.6
	OPENBSD_5_3:1.7.0.18
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.16
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.14
	OPENBSD_5_0:1.7.0.12
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.10
	OPENBSD_4_9_BASE:1.7
	PERL_5_12_2:1.1.1.6
	OPENBSD_4_8:1.7.0.8
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.4
	OPENBSD_4_7_BASE:1.7
	PERL_5_10_1:1.1.1.6
	OPENBSD_4_6:1.7.0.6
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.2
	OPENBSD_4_5_BASE:1.7
	PERL_5_10_0:1.1.1.6
	OPENBSD_4_4:1.6.0.10
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.8
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.6
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.4
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.2
	OPENBSD_4_0_BASE:1.6
	PERL_5_8_8:1.1.1.5
	OPENBSD_3_9:1.5.0.8
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.6
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.4
	OPENBSD_3_7_BASE:1.5
	PERL_5_8_6:1.1.1.4
	OPENBSD_3_6:1.5.0.2
	OPENBSD_3_6_BASE:1.5
	PERL_5_8_5:1.1.1.4
	PERL_5_8_3:1.1.1.3
	OPENBSD_3_5:1.4.0.12
	OPENBSD_3_5_BASE:1.4
	PERL_5_8_2:1.1.1.3
	OPENBSD_3_4:1.4.0.10
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.4.0.8
	OPENBSD_3_3_BASE:1.4
	PERL_5_8_0:1.1.1.3
	OPENBSD_3_2:1.4.0.6
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.4
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.3.0.8
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.6
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.4
	OPENBSD_2_7_BASE:1.3
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.9
date	2017.02.05.00.32.20;	author afresh1;	state Exp;
branches;
next	1.8;
commitid	cxJ08BvJA9Pt2PTM;

1.8
date	2014.03.24.15.05.33;	author afresh1;	state Exp;
branches;
next	1.7;

1.7
date	2008.09.29.17.36.19;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2006.03.28.19.23.12;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2004.08.09.18.10.27;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.24.18.36.20;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.52.36;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.08.05.30;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.13.19;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.13.19;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.41.47;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.05.24.18.25.41;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.08.09.17.48.35;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2006.03.28.18.49.45;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2008.09.29.17.19.01;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2014.03.24.14.59.10;	author afresh1;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl
BEGIN {
    chdir 't' if -d 't';
    @@INC = '../lib';
    require './test.pl';
}

sub foo {
    my($a, $b) = @@_;
    my $c;
    my $d;
    $c = "ok 3\n";
    $d = "ok 4\n";
    { my($a, undef, $c) = ("ok 9\n", "not ok 10\n", "ok 10\n");
      ($x, $y) = ($a, $c); }
    is($a, "ok 1\n", 'value of sub argument maintained outside of block');
    is($b, "ok 2\n", 'sub argument maintained');
    is($c, "ok 3\n", 'variable value maintained outside of block');
    is($d, "ok 4\n", 'variable value maintained');
}

$a = "ok 5\n";
$b = "ok 6\n";
$c = "ok 7\n";
$d = "ok 8\n";

&foo("ok 1\n","ok 2\n");

is($a, "ok 5\n", 'global was not affected by duplicate names inside subroutine');
is($b, "ok 6\n", '...');
is($c, "ok 7\n", '...');
is($d, "ok 8\n", '...');
is($x, "ok 9\n", 'globals modified inside of block keeps its value outside of block');
is($y, "ok 10\n", '...');

# same thing, only with arrays and associative arrays

sub foo2 {
    my($a, @@b) = @@_;
    my(@@c, %d);
    @@c = "ok 13\n";
    $d{''} = "ok 14\n";
    { my($a,@@c) = ("ok 19\n", "ok 20\n", "ok 21\n"); ($x, $y) = ($a, @@c); }
    is($a, "ok 11\n", 'value of sub argument maintained outside of block');
    is(scalar @@b, 1, 'did not add any elements to @@b');
    is($b[0], "ok 12\n", 'did not alter @@b');
    is(scalar @@c, 1, 'did not add arguments to @@c');
    is($c[0], "ok 13\n", 'did not alter @@c');
    is($d{''}, "ok 14\n", 'did not touch %d');
}

$a = "ok 15\n";
@@b = "ok 16\n";
@@c = "ok 17\n";
$d{''} = "ok 18\n";

&foo2("ok 11\n", "ok 12\n");

is($a, "ok 15\n", 'Global was not modifed out of scope');
is(scalar @@b, 1, 'correct number of elements in array');
is($b[0], "ok 16\n", 'array value was not modified out of scope');
is(scalar @@c, 1, 'correct number of elements in array');
is($c[0], "ok 17\n", 'array value was not modified out of scope');
is($d{''}, "ok 18\n", 'hash key/value pair is correct');
is($x, "ok 19\n", 'global was modified');
is($y, "ok 20\n", 'this one too');

my $i = "outer";

if (my $i = "inner") {
    is( $i, 'inner', 'my variable inside conditional propagates inside block');
}

if ((my $i = 1) == 0) {
    fail("nested parens do not propagate variable outside");
}
else {
    is($i, 1, 'lexical variable lives available inside else block');
}

my $j = 5;
while (my $i = --$j) {
    last unless is( $i, $j, 'lexical inside while block');
}
continue {
    last unless is( $i, $j, 'lexical inside continue block');
}
is( $j, 0, 'went through the previous while/continue loop all 4 times' );

$j = 5;
for (my $i = 0; (my $k = $i) < $j; ++$i) {
    fail(""), last unless $i >= 0 && $i < $j && $i == $k;
}
ok( ! defined $k, '$k is only defined in the scope of the previous for loop' );

curr_test(37);
$jj = 0;
foreach my $i (30, 31) {
    is( $i, $jj+30, 'assignment inside the foreach loop variable definition');
    $jj++;
}
is( $jj, 2, 'foreach loop executed twice');

is( $i, 'outer', '$i not modified by while/for/foreach using same variable name');

# Ensure that C<my @@y> (without parens) doesn't force scalar context.
my @@x;
{ @@x = my @@y }
is(scalar @@x, 0, 'my @@y without parens does not force scalar context');
{ @@x = my %y }
is(scalar @@x, 0, 'my %y without parens does not force scalar context');

# Found in HTML::FormatPS
my %fonts = qw(nok 35);
for my $full (keys %fonts) {
    $full =~ s/^n//;
    is( $fonts{nok}, 35, 'Supposed to be copy-on-write via force_normal after a THINKFIRST check.' );
}

#  [perl #29340] optimising away the = () left the padav returning the
# array rather than the contents, leading to 'Bizarre copy of array' error

sub opta { my @@a=() }
sub opth { my %h=() }
eval { my $x = opta };
is($@@, '', ' perl #29340, No bizarre copy of array error');
eval { my $x = opth };
is($@@, '', ' perl #29340, No bizarre copy of array error via hash');

sub foo3 {
    ++my $x->{foo};
    ok(! defined $x->{bar}, '$x->{bar} is not defined');
    ++$x->{bar};
}
eval { foo3(); foo3(); };
is( $@@, '', 'no errors while checking autovivification and persistence of hash refs inside subs' );

# my $foo = undef should always assign [perl #37776]
{
    my $count = 35;
    loop:
    my $test = undef;
    is($test, undef, 'var is undef, repeated test');
    $test = 42;
    goto loop if ++$count < 37;
}

# [perl #113554]
eval "my ()";
is( $@@, '', "eval of my() passes");

# RT #126844
# This triggered a compile-time assert failure in rpeep()
eval 'my($a,$b),$x,my($c,$d)';
pass("RT #126844");

#Variable number of tests due to the way the while/for loops are tested now
done_testing();
@


1.8
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d152 5
@


1.7
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d2 5
a6 2

print "1..36\n";
d16 4
a19 2
    print $a, $b;
    $c . $d;
d27 1
a27 1
print &foo("ok 1\n","ok 2\n");
d29 6
a34 1
print $a,$b,$c,$d,$x,$y;
d43 7
a49 3
    { my($a,@@c) = ("ok 19\n", "ok 20\n"); ($x, $y) = ($a, @@c); }
    print $a, @@b;
    $c[0] . $d{''};
d57 1
a57 1
print &foo2("ok 11\n","ok 12\n");
d59 8
a66 1
print $a,@@b,@@c,%d,$x,$y;
d71 1
a71 1
    print "not " if $i ne "inner";
a72 1
print "ok 21\n";
d75 1
a75 1
    print "not ";
d78 1
a78 1
    print "not" if $i != 1;
a79 1
print "ok 22\n";
d83 1
a83 1
    print("not "), last unless $i > 0;
d86 1
a86 1
    print("not "), last unless $i > 0;
d88 1
a88 1
print "ok 23\n";
d92 1
a92 1
    print("not "), last unless $i >= 0 && $i < $j && $i == $k;
d94 1
a94 3
print "ok 24\n";
print "not " if defined $k;
print "ok 25\n";
d96 5
a100 2
foreach my $i (26, 27) {
    print "ok $i\n";
d102 1
d104 1
a104 2
print "not " if $i ne "outer";
print "ok 28\n";
d109 1
a109 1
print +(@@x ? "not " : ""), "ok 29\n";
d111 1
a111 1
print +(@@x ? "not " : ""), "ok 30\n";
d114 1
a114 1
my %fonts = qw(nok 31);
d117 1
a117 2
    # Supposed to be copy-on-write via force_normal after a THINKFIRST check.
    print "$full $fonts{nok}\n";
d126 1
a126 2
print "not " if $@@;
print "ok 32\n";
d128 1
a128 3
print "not " if $@@;
print "ok 33\n";

d132 1
a132 1
    print "not " if defined $x->{bar};
d136 1
a136 2
print "not " if $@@;
print "ok 34\n";
d143 1
a143 2
    print "not " if defined $test;
    print "ok $count\n";
d147 7
@


1.6
log
@merge in perl 5.8.8
@
text
@a2 2
# $RCSfile: my.t,v $

d112 11
d125 1
a125 1
    my $count = 34;
@


1.5
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d5 1
a5 1
print "1..33\n";
d114 10
@


1.4
log
@merge in perl 5.6.1 with our local changes
@
text
@d5 1
a5 1
print "1..31\n";
d102 12
@


1.3
log
@perl5.005_03 (stock)
@
text
@d5 1
a5 1
print "1..30\n";
d95 7
@


1.2
log
@perl 5.004_04
@
text
@d5 1
a5 1
print "1..28\n";
d13 2
a14 1
    { my($a,$c) = ("ok 9\n", "ok 10\n"); ($x, $y) = ($a, $c); }
d87 8
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
# $RCSfile: local.t,v $$Revision: 4.1 $$Date: 92/08/07 18:28:04 $
d5 1
a5 1
print "1..20\n";
d47 39
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d3 1
a3 1
# $RCSfile: my.t,v $
d5 1
a5 1
print "1..30\n";
d13 1
a13 2
    { my($a, undef, $c) = ("ok 9\n", "not ok 10\n", "ok 10\n");
      ($x, $y) = ($a, $c); }
a46 47

my $i = "outer";

if (my $i = "inner") {
    print "not " if $i ne "inner";
}
print "ok 21\n";

if ((my $i = 1) == 0) {
    print "not ";
}
else {
    print "not" if $i != 1;
}
print "ok 22\n";

my $j = 5;
while (my $i = --$j) {
    print("not "), last unless $i > 0;
}
continue {
    print("not "), last unless $i > 0;
}
print "ok 23\n";

$j = 5;
for (my $i = 0; (my $k = $i) < $j; ++$i) {
    print("not "), last unless $i >= 0 && $i < $j && $i == $k;
}
print "ok 24\n";
print "not " if defined $k;
print "ok 25\n";

foreach my $i (26, 27) {
    print "ok $i\n";
}

print "not " if $i ne "outer";
print "ok 28\n";

# Ensure that C<my @@y> (without parens) doesn't force scalar context.
my @@x;
{ @@x = my @@y }
print +(@@x ? "not " : ""), "ok 29\n";
{ @@x = my %y }
print +(@@x ? "not " : ""), "ok 30\n";

@


1.1.1.3
log
@stock perl 5.6.1
@
text
@d5 1
a5 1
print "1..31\n";
a94 7
# Found in HTML::FormatPS
my %fonts = qw(nok 31);
for my $full (keys %fonts) {
    $full =~ s/^n//;
    # Supposed to be copy-on-write via force_normal after a THINKFIRST check.
    print "$full $fonts{nok}\n";
}
@


1.1.1.4
log
@Import of stock perl 5.8.5
@
text
@d5 1
a5 1
print "1..33\n";
a101 12

#  [perl #29340] optimising away the = () left the padav returning the
# array rather than the contents, leading to 'Bizarre copy of array' error

sub opta { my @@a=() }
sub opth { my %h=() }
eval { my $x = opta };
print "not " if $@@;
print "ok 32\n";
eval { my $x = opth };
print "not " if $@@;
print "ok 33\n";
@


1.1.1.5
log
@perl 5.8.8 import
@
text
@d5 1
a5 1
print "1..36\n";
a113 10
# my $foo = undef should always assign [perl #37776]
{
    my $count = 34;
    loop:
    my $test = undef;
    print "not " if defined $test;
    print "ok $count\n";
    $test = 42;
    goto loop if ++$count < 37;
}
@


1.1.1.6
log
@import perl 5.10.0 from CPAN
@
text
@d3 2
a113 11


sub foo3 {
    ++my $x->{foo};
    print "not " if defined $x->{bar};
    ++$x->{bar};
}
eval { foo3(); foo3(); };
print "not " if $@@;
print "ok 34\n";

d116 1
a116 1
    my $count = 35;
@


1.1.1.7
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d2 2
a3 5
BEGIN {
    chdir 't' if -d 't';
    @@INC = '../lib';
    require './test.pl';
}
d13 2
a14 4
    is($a, "ok 1\n", 'value of sub argument maintained outside of block');
    is($b, "ok 2\n", 'sub argument maintained');
    is($c, "ok 3\n", 'variable value maintained outside of block');
    is($d, "ok 4\n", 'variable value maintained');
d22 1
a22 1
&foo("ok 1\n","ok 2\n");
d24 1
a24 6
is($a, "ok 5\n", 'global was not affected by duplicate names inside subroutine');
is($b, "ok 6\n", '...');
is($c, "ok 7\n", '...');
is($d, "ok 8\n", '...');
is($x, "ok 9\n", 'globals modified inside of block keeps its value outside of block');
is($y, "ok 10\n", '...');
d33 3
a35 7
    { my($a,@@c) = ("ok 19\n", "ok 20\n", "ok 21\n"); ($x, $y) = ($a, @@c); }
    is($a, "ok 11\n", 'value of sub argument maintained outside of block');
    is(scalar @@b, 1, 'did not add any elements to @@b');
    is($b[0], "ok 12\n", 'did not alter @@b');
    is(scalar @@c, 1, 'did not add arguments to @@c');
    is($c[0], "ok 13\n", 'did not alter @@c');
    is($d{''}, "ok 14\n", 'did not touch %d');
d43 1
a43 1
&foo2("ok 11\n", "ok 12\n");
d45 1
a45 8
is($a, "ok 15\n", 'Global was not modifed out of scope');
is(scalar @@b, 1, 'correct number of elements in array');
is($b[0], "ok 16\n", 'array value was not modified out of scope');
is(scalar @@c, 1, 'correct number of elements in array');
is($c[0], "ok 17\n", 'array value was not modified out of scope');
is($d{''}, "ok 18\n", 'hash key/value pair is correct');
is($x, "ok 19\n", 'global was modified');
is($y, "ok 20\n", 'this one too');
d50 1
a50 1
    is( $i, 'inner', 'my variable inside conditional propagates inside block');
d52 1
d55 1
a55 1
    fail("nested parens do not propagate variable outside");
d58 1
a58 1
    is($i, 1, 'lexical variable lives available inside else block');
d60 1
d64 1
a64 1
    last unless is( $i, $j, 'lexical inside while block');
d67 1
a67 1
    last unless is( $i, $j, 'lexical inside continue block');
d69 1
a69 1
is( $j, 0, 'went through the previous while/continue loop all 4 times' );
d73 1
a73 1
    fail(""), last unless $i >= 0 && $i < $j && $i == $k;
d75 3
a77 1
ok( ! defined $k, '$k is only defined in the scope of the previous for loop' );
d79 2
a80 5
curr_test(37);
$jj = 0;
foreach my $i (30, 31) {
    is( $i, $jj+30, 'assignment inside the foreach loop variable definition');
    $jj++;
a81 1
is( $jj, 2, 'foreach loop executed twice');
d83 2
a84 1
is( $i, 'outer', '$i not modified by while/for/foreach using same variable name');
d89 1
a89 1
is(scalar @@x, 0, 'my @@y without parens does not force scalar context');
d91 1
a91 1
is(scalar @@x, 0, 'my %y without parens does not force scalar context');
d94 1
a94 1
my %fonts = qw(nok 35);
d97 2
a98 1
    is( $fonts{nok}, 35, 'Supposed to be copy-on-write via force_normal after a THINKFIRST check.' );
d107 2
a108 1
is($@@, '', ' perl #29340, No bizarre copy of array error');
d110 3
a112 1
is($@@, '', ' perl #29340, No bizarre copy of array error via hash');
d116 1
a116 1
    ok(! defined $x->{bar}, '$x->{bar} is not defined');
d120 2
a121 1
is( $@@, '', 'no errors while checking autovivification and persistence of hash refs inside subs' );
d128 2
a129 1
    is($test, undef, 'var is undef, repeated test');
a132 7

# [perl #113554]
eval "my ()";
is( $@@, '', "eval of my() passes");

#Variable number of tests due to the way the while/for loops are tested now
done_testing();
@


