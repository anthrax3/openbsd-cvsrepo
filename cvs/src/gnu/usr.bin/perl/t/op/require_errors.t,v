head	1.2;
access;
symbols
	OPENBSD_6_1:1.2.0.2
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.3.0.10
	OPENBSD_6_0_BASE:1.1.1.3
	OPENBSD_5_9:1.1.1.3.0.4
	OPENBSD_5_9_BASE:1.1.1.3
	OPENBSD_5_8:1.1.1.3.0.6
	OPENBSD_5_8_BASE:1.1.1.3
	PERL_5_20_2:1.1.1.3
	OPENBSD_5_7:1.1.1.3.0.2
	OPENBSD_5_7_BASE:1.1.1.3
	PERL_5_20_1:1.1.1.3
	OPENBSD_5_6:1.1.1.2.0.4
	OPENBSD_5_6_BASE:1.1.1.2
	PERL_5_18_2:1.1.1.2
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.1.0.6
	OPENBSD_5_5_BASE:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.2
	OPENBSD_5_4_BASE:1.1.1.1
	PERL_5_16_3:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.32.20;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2013.03.25.20.09.36;	author sthen;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2013.03.25.20.09.36;	author sthen;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2014.03.24.14.59.10;	author afresh1;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.11.17.20.53.18;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!perl

BEGIN {
    chdir 't' if -d 't';
    require './test.pl';
}

use strict;
use warnings;

plan(tests => 17);

my $nonfile = tempfile();

@@INC = qw(Perl Rules);

# The tests for ' ' and '.h' never did fail, but previously the error reporting
# code would read memory before the start of the SV's buffer

for my $file ($nonfile, ' ') {
    eval {
	require $file;
    };

    like $@@, qr/^Can't locate $file in \@@INC \(\@@INC contains: @@INC\) at/,
	"correct error message for require '$file'";
}

eval "require $nonfile";

like $@@, qr/^Can't locate $nonfile\.pm in \@@INC \(you may need to install the $nonfile module\) \(\@@INC contains: @@INC\) at/,
    "correct error message for require $nonfile";

eval {
    require "$nonfile.ph";
};

like $@@, qr/^Can't locate $nonfile\.ph in \@@INC \(did you run h2ph\?\) \(\@@INC contains: @@INC\) at/;

for my $file ("$nonfile.h", ".h") {
    eval {
	require $file
    };

    like $@@, qr/^Can't locate \Q$file\E in \@@INC \(change \.h to \.ph maybe\?\) \(did you run h2ph\?\) \(\@@INC contains: @@INC\) at/,
	"correct error message for require '$file'";
}

for my $file ("$nonfile.ph", ".ph") {
    eval {
	require $file
    };

    like $@@, qr/^Can't locate \Q$file\E in \@@INC \(did you run h2ph\?\) \(\@@INC contains: @@INC\) at/,
	"correct error message for require '$file'";
}

eval 'require <foom>';
like $@@, qr/^<> at require-statement should be quotes at /, 'require <> error';

my $module   = tempfile();
my $mod_file = "$module.pm";

open my $module_fh, ">", $mod_file or die $!;
print { $module_fh } "print 1; 1;\n";
close $module_fh;

chmod 0333, $mod_file;

SKIP: {
    skip_if_miniperl("these modules may not be available to miniperl", 2);

    push @@INC, '../lib';
    require Cwd;
    require File::Spec::Functions;
    if ($^O eq 'cygwin') {
        require Win32;
    }

    # Going to try to switch away from root.  Might not work.
    # (stolen from t/op/stat.t)
    my $olduid = $>;
    eval { $> = 1; };
    skip "Can't test permissions meaningfully if you're superuser", 2
        if ($^O eq 'cygwin' ? Win32::IsAdminUser() : $> == 0);

    local @@INC = ".";
    eval "use $module";
    like $@@,
        qr<^\QCan't locate $mod_file:>,
        "special error message if the file exists but can't be opened";

    SKIP: {
        skip "Can't make the path absolute", 1
            if !defined(Cwd::getcwd());

        my $file = File::Spec::Functions::catfile(Cwd::getcwd(), $mod_file);
        eval {
            require($file);
        };
        like $@@,
            qr<^\QCan't locate $file:>,
            "...even if we use a full path";
    }

    # switch uid back (may not be implemented)
    eval { $> = $olduid; };
}

1 while unlink $mod_file;

# I can't see how to test the EMFILE case
# I can't see how to test the case of not displaying @@INC in the message.
# (and does that only happen on VMS?)

# fail and print the full filename
eval { no warnings 'syscalls'; require "strict.pm\0invalid"; };
like $@@, qr/^Can't locate strict\.pm\\0invalid: /, 'require nul check [perl #117265]';
eval { no warnings 'syscalls'; do "strict.pm\0invalid"; };
like $@@, qr/^Can't locate strict\.pm\\0invalid: /, 'do nul check';
{
  my $WARN;
  local $SIG{__WARN__} = sub { $WARN = shift };
  eval { require "strict.pm\0invalid"; };
  like $WARN, qr{^Invalid \\0 character in pathname for require: strict\.pm\\0invalid at }, 'nul warning';
  like $@@, qr{^Can't locate strict\.pm\\0invalid: }, 'nul error';

  $WARN = '';
  local @@INC = @@INC;
  unshift @@INC, "lib\0invalid";
  eval { require "unknown.pm" };
  like $WARN, qr{^Invalid \\0 character in \@@INC entry for require: lib\\0invalid at }, 'nul warning';
}
eval "require strict\0::invalid;";
like $@@, qr/^syntax error at \(eval \d+\) line 1/, 'parse error with \0 in barewords module names';

@


1.1
log
@Initial revision
@
text
@a1 2
use strict;
use warnings;
d4 1
d8 4
a11 1
plan(tests => 3);
d17 13
a29 3
eval {
    require $nonfile;
};
d31 2
a32 1
like $@@, qr/^Can't locate $nonfile in \@@INC \(\@@INC contains: @@INC\) at/;
d40 69
a108 3
eval {
    require "$nonfile.h";
};
d110 1
a110 1
like $@@, qr/^Can't locate $nonfile\.h in \@@INC \(change \.h to \.ph maybe\?\) \(did you run h2ph\?\) \(\@@INC contains: @@INC\) at/;
d115 22
@


1.1.1.1
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@@


1.1.1.2
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@a5 1
    chdir 't';
d9 1
a9 1
plan(tests => 11);
d15 3
a17 11
# The tests for ' ' and '.h' never did fail, but previously the error reporting
# code would read memory before the start of the SV's buffer

for my $file ($nonfile, ' ') {
    eval {
	require $file;
    };

    like $@@, qr/^Can't locate $file in \@@INC \(\@@INC contains: @@INC\) at/,
	"correct error message for require '$file'";
}
d19 1
a19 4
eval "require $nonfile";

like $@@, qr/^Can't locate $nonfile\.pm in \@@INC \(you may need to install the $nonfile module\) \(\@@INC contains: @@INC\) at/,
    "correct error message for require $nonfile";
d27 3
a29 69
for my $file ("$nonfile.h", ".h") {
    eval {
	require $file
    };

    like $@@, qr/^Can't locate \Q$file\E in \@@INC \(change \.h to \.ph maybe\?\) \(did you run h2ph\?\) \(\@@INC contains: @@INC\) at/,
	"correct error message for require '$file'";
}

for my $file ("$nonfile.ph", ".ph") {
    eval {
	require $file
    };

    like $@@, qr/^Can't locate \Q$file\E in \@@INC \(did you run h2ph\?\) \(\@@INC contains: @@INC\) at/,
	"correct error message for require '$file'";
}

eval 'require <foom>';
like $@@, qr/^<> should be quotes at /, 'require <> error';

my $module   = tempfile();
my $mod_file = "$module.pm";

open my $module_fh, ">", $mod_file or die $!;
print { $module_fh } "print 1; 1;\n";
close $module_fh;

chmod 0333, $mod_file;

SKIP: {
    skip_if_miniperl("these modules may not be available to miniperl", 2);

    push @@INC, '../lib';
    require Cwd;
    require File::Spec::Functions;
    if ($^O eq 'cygwin') {
        require Win32;
    }

    # Going to try to switch away from root.  Might not work.
    # (stolen from t/op/stat.t)
    my $olduid = $>;
    eval { $> = 1; };
    skip "Can't test permissions meaningfully if you're superuser", 2
        if ($^O eq 'cygwin' ? Win32::IsAdminUser() : $> == 0);

    local @@INC = ".";
    eval "use $module";
    like $@@,
        qr<^\QCan't locate $mod_file:>,
        "special error message if the file exists but can't be opened";

    SKIP: {
        skip "Can't make the path absolute", 1
            if !defined(Cwd::getcwd());

        my $file = File::Spec::Functions::catfile(Cwd::getcwd(), $mod_file);
        eval {
            require($file);
        };
        like $@@,
            qr<^\QCan't locate $file:>,
            "...even if we use a full path";
    }

    # switch uid back (may not be implemented)
    eval { $> = $olduid; };
}
d31 1
a31 1
1 while unlink $mod_file;
@


1.1.1.3
log
@Import perl-5.20.1
@
text
@d10 1
a10 1
plan(tests => 17);
a113 22

# fail and print the full filename
eval { no warnings 'syscalls'; require "strict.pm\0invalid"; };
like $@@, qr/^Can't locate strict\.pm\\0invalid: /, 'require nul check [perl #117265]';
eval { no warnings 'syscalls'; do "strict.pm\0invalid"; };
like $@@, qr/^Can't locate strict\.pm\\0invalid: /, 'do nul check';
{
  my $WARN;
  local $SIG{__WARN__} = sub { $WARN = shift };
  eval { require "strict.pm\0invalid"; };
  like $WARN, qr{^Invalid \\0 character in pathname for require: strict\.pm\\0invalid at }, 'nul warning';
  like $@@, qr{^Can't locate strict\.pm\\0invalid: }, 'nul error';

  $WARN = '';
  local @@INC = @@INC;
  unshift @@INC, "lib\0invalid";
  eval { require "unknown.pm" };
  like $WARN, qr{^Invalid \\0 character in \@@INC entry for require: lib\\0invalid at }, 'nul warning';
}
eval "require strict\0::invalid;";
like $@@, qr/^syntax error at \(eval \d+\) line 1/, 'parse error with \0 in barewords module names';

@


