head	1.16;
access;
symbols
	OPENBSD_6_2:1.16.0.2
	OPENBSD_6_2_BASE:1.16
	PERL_5_24_2:1.1.1.15
	OPENBSD_6_1:1.16.0.4
	OPENBSD_6_1_BASE:1.16
	OPENBSD_6_0:1.15.0.10
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.15.0.4
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.15.0.6
	OPENBSD_5_8_BASE:1.15
	PERL_5_20_2:1.1.1.14
	OPENBSD_5_7:1.15.0.2
	OPENBSD_5_7_BASE:1.15
	PERL_5_20_1:1.1.1.14
	OPENBSD_5_6:1.14.0.4
	OPENBSD_5_6_BASE:1.14
	PERL_5_18_2:1.1.1.13
	PERL:1.1.1
	OPENBSD_5_5:1.13.0.6
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.2
	OPENBSD_5_4_BASE:1.13
	PERL_5_16_3:1.1.1.12
	OPENBSD_5_3:1.12.0.10
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.8
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.6
	OPENBSD_5_0:1.12.0.4
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.2
	OPENBSD_4_9_BASE:1.12
	PERL_5_12_2:1.1.1.11
	OPENBSD_4_8:1.11.0.4
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.2
	OPENBSD_4_7_BASE:1.11
	PERL_5_10_1:1.1.1.10
	OPENBSD_4_6:1.10.0.6
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.2
	OPENBSD_4_5_BASE:1.10
	PERL_5_10_0:1.1.1.9
	OPENBSD_4_4:1.9.0.10
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.8
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.6
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.4
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9
	PERL_5_8_8:1.1.1.8
	OPENBSD_3_9:1.8.0.6
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.4
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.2
	OPENBSD_3_7_BASE:1.8
	PERL_5_8_6:1.1.1.7
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7
	PERL_5_8_5:1.1.1.6
	PERL_5_8_3:1.1.1.5
	OPENBSD_3_5:1.6.0.2
	OPENBSD_3_5_BASE:1.6
	PERL_5_8_2:1.1.1.5
	OPENBSD_3_4:1.5.0.4
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.4.0.12
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.10
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.8
	OPENBSD_3_0_BASE:1.4
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.16
date	2017.02.05.00.32.20;	author afresh1;	state Exp;
branches;
next	1.15;
commitid	cxJ08BvJA9Pt2PTM;

1.15
date	2014.11.17.20.57.07;	author afresh1;	state Exp;
branches;
next	1.14;
commitid	QP75iYx42Uo7mMxO;

1.14
date	2014.03.24.15.05.33;	author afresh1;	state Exp;
branches;
next	1.13;

1.13
date	2013.03.25.20.40.59;	author sthen;	state Exp;
branches;
next	1.12;

1.12
date	2010.09.24.15.07.09;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2009.10.12.18.30.27;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2008.09.29.17.36.20;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2006.03.28.19.23.13;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2005.01.15.21.30.40;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2004.08.09.18.10.27;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2003.12.03.03.02.49;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.10.27.22.25.37;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.08.30;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.52.37;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.08.05.39;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.13.21;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.13.21;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.41.50;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.10.51;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.27.22.15.11;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.12.03.02.44.32;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.08.09.17.48.35;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2005.01.15.21.18.19;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2006.03.28.18.49.46;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2008.09.29.17.19.01;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2009.10.12.18.10.45;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2010.09.24.14.49.16;	author millert;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2013.03.25.20.09.36;	author sthen;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2014.03.24.14.59.10;	author afresh1;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2014.11.17.20.53.18;	author afresh1;	state Exp;
branches;
next	1.1.1.15;
commitid	B31cAbBIXiCqnL97;

1.1.1.15
date	2017.08.14.13.46.24;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.16
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl

BEGIN {
    chdir 't' if -d 't';
    @@INC = qw(. ../lib);
    require './test.pl';
}

use strict qw(refs subs);

plan(235);

# Test this first before we extend the stack with other operations.
# This caused an asan failure due to a bad write past the end of the stack.
eval { die  1..127, $_=\() };

# Test glob operations.

$bar = "one";
$foo = "two";
{
    local(*foo) = *bar;
    is($foo, 'one');
}
is ($foo, 'two');

$baz = "three";
$foo = "four";
{
    local(*foo) = 'baz';
    is ($foo, 'three');
}
is ($foo, 'four');

$foo = "global";
{
    local(*foo);
    is ($foo, undef);
    $foo = "local";
    is ($foo, 'local');
}
is ($foo, 'global');

{
    no strict 'refs';
# Test fake references.

    $baz = "valid";
    $bar = 'baz';
    $foo = 'bar';
    is ($$$foo, 'valid');
}

# Test real references.

$FOO = \$BAR;
$BAR = \$BAZ;
$BAZ = "hit";
is ($$$FOO, 'hit');

# Test references to real arrays.

my $test = curr_test();
@@ary = ($test,$test+1,$test+2,$test+3);
$ref[0] = \@@a;
$ref[1] = \@@b;
$ref[2] = \@@c;
$ref[3] = \@@d;
for $i (3,1,2,0) {
    push(@@{$ref[$i]}, "ok $ary[$i]\n");
}
print @@a;
print ${$ref[1]}[0];
print @@{$ref[2]}[0];
{
    no strict 'refs';
    print @@{'d'};
}
curr_test($test+4);

# Test references to references.

$refref = \\$x;
$x = "Good";
is ($$$refref, 'Good');

# Test nested anonymous arrays.

$ref = [[],2,[3,4,5,]];
is (scalar @@$ref, 3);
is ($$ref[1], 2);
is (${$$ref[2]}[2], 5);
is (scalar @@{$$ref[0]}, 0);

is ($ref->[1], 2);
is ($ref->[2]->[0], 3);

# Test references to hashes of references.

$refref = \%whatever;
$refref->{"key"} = $ref;
is ($refref->{"key"}->[2]->[0], 3);

# Test to see if anonymous subarrays spring into existence.

$spring[5]->[0] = 123;
$spring[5]->[1] = 456;
push(@@{$spring[5]}, 789);
is (join(':',@@{$spring[5]}), "123:456:789");

# Test to see if anonymous subhashes spring into existence.

@@{$spring2{"foo"}} = (1,2,3);
$spring2{"foo"}->[3] = 4;
is (join(':',@@{$spring2{"foo"}}), "1:2:3:4");

# Test references to subroutines.

{
    my $called;
    sub mysub { $called++; }
    $subref = \&mysub;
    &$subref;
    is ($called, 1);
}
is ref eval {\&{""}}, "CODE", 'reference to &{""} [perl #94476]';

# Test references to return values of operators (TARGs/PADTMPs)
{
    my @@refs;
    for("a", "b") {
        push @@refs, \"$_"
    }
    is join(" ", map $$_, @@refs), "a b", 'refgen+PADTMP';
}

$subrefref = \\&mysub2;
is ($$subrefref->("GOOD"), "good");
sub mysub2 { lc shift }

# Test REGEXP assignment

SKIP: {
    skip_if_miniperl("no dynamic loading on miniperl, so can't load re", 5);
    require re;
    my $x = qr/x/;
    my $str = "$x"; # regex stringification may change

    my $y = $$x;
    is ($y, $str, "bare REGEXP stringifies correctly");
    ok (eval { "x" =~ $y }, "bare REGEXP matches correctly");
    
    my $z = \$y;
    ok (re::is_regexp($z), "new ref to REXEXP passes is_regexp");
    is ($z, $str, "new ref to REGEXP stringifies correctly");
    ok (eval { "x" =~ $z }, "new ref to REGEXP matches correctly");
}
{
    my ($x, $str);
    {
        my $y = qr/x/;
        $str = "$y";
        $x = $$y;
    }
    is ($x, $str, "REGEXP keeps a ref to its mother_re");
    ok (eval { "x" =~ $x }, "REGEXP with mother_re still matches");
}

# Test the ref operator.

sub PVBM () { 'foo' }
{ my $dummy = index 'foo', PVBM }

my $pviv = 1; "$pviv";
my $pvnv = 1.0; "$pvnv";
my $x;

# we don't test
#   tied lvalue => SCALAR, as we haven't tested tie yet
#   BIND, 'cos we can't create them yet
#   REGEXP, 'cos that requires overload or Scalar::Util

for (
    [ 'undef',          SCALAR  => \undef               ],
    [ 'constant IV',    SCALAR  => \1                   ],
    [ 'constant NV',    SCALAR  => \1.0                 ],
    [ 'constant PV',    SCALAR  => \'f'                 ],
    [ 'scalar',         SCALAR  => \$x                  ],
    [ 'PVIV',           SCALAR  => \$pviv               ],
    [ 'PVNV',           SCALAR  => \$pvnv               ],
    [ 'PVMG',           SCALAR  => \$0                  ],
    [ 'PVBM',           SCALAR  => \PVBM                ],
    [ 'scalar @@array',  SCALAR  => \scalar @@array       ],
    [ 'scalar %hash',   SCALAR  => \scalar %hash        ],
    [ 'vstring',        VSTRING => \v1                  ],
    [ 'ref',            REF     => \\1                  ],
    [ 'substr lvalue',  LVALUE  => \substr($x, 0, 0)    ],
    [ 'pos lvalue',     LVALUE  => \pos                 ],
    [ 'vec lvalue',     LVALUE  => \vec($x,0,1)         ],     
    [ 'named array',    ARRAY   => \@@ary                ],
    [ 'anon array',     ARRAY   => [ 1 ]                ],
    [ 'named hash',     HASH    => \%whatever           ],
    [ 'anon hash',      HASH    => { a => 1 }           ],
    [ 'named sub',      CODE    => \&mysub,             ],
    [ 'anon sub',       CODE    => sub { 1; }           ],
    [ 'glob',           GLOB    => \*foo                ],
    [ 'format',         FORMAT  => *STDERR{FORMAT}      ],
) {
    my ($desc, $type, $ref) = @@$_;
    is (ref $ref, $type, "ref() for ref to $desc");
    like ("$ref", qr/^$type\(0x[0-9a-f]+\)$/, "stringify for ref to $desc");
}

is (ref *STDOUT{IO}, 'IO::File', 'IO refs are blessed into IO::File');
like (*STDOUT{IO}, qr/^IO::File=IO\(0x[0-9a-f]+\)$/,
    'stringify for IO refs');

{ # Test re-use of ref's TARG [perl #101738]
  my $obj = bless [], '____';
  my $uniobj = bless [], chr 256;
  my $get_ref = sub { ref shift };
  my $dummy = &$get_ref($uniobj);
     $dummy = &$get_ref($obj);
  ok exists { ____ => undef }->{$dummy}, 'ref sets UTF8 flag correctly';
}

# Test anonymous hash syntax.

$anonhash = {};
is (ref $anonhash, 'HASH');
$anonhash2 = {FOO => 'BAR', ABC => 'XYZ',};
is (join('', sort values %$anonhash2), 'BARXYZ');

# Test bless operator.

package MYHASH;

$object = bless $main'anonhash2;
main::is (ref $object, 'MYHASH');
main::is ($object->{ABC}, 'XYZ');

$object2 = bless {};
main::is (ref $object2,	'MYHASH');

# Test ordinary call on object method.

&mymethod($object,"argument");

sub mymethod {
    local($THIS, @@ARGS) = @@_;
    die 'Got a "' . ref($THIS). '" instead of a MYHASH'
	unless ref $THIS eq 'MYHASH';
    main::is ($ARGS[0], "argument");
    main::is ($THIS->{FOO}, 'BAR');
}

# Test automatic destructor call.

$string = "bad";
$object = "foo";
$string = "good";
$main'anonhash2 = "foo";
$string = "";

DESTROY {
    return unless $string;
    main::is ($string, 'good');

    # Test that the object has not already been "cursed".
    main::isnt (ref shift, 'HASH');
}

# Now test inheritance of methods.

package OBJ;

@@ISA = ('BASEOBJ');

$main'object = bless {FOO => 'foo', BAR => 'bar'};

package main;

# Test arrow-style method invocation.

is ($object->doit("BAR"), 'bar');

# Test indirect-object-style method invocation.

$foo = doit $object "FOO";
main::is ($foo, 'foo');

sub BASEOBJ'doit {
    local $ref = shift;
    die "Not an OBJ" unless ref $ref eq 'OBJ';
    $ref->{shift()};
}

package UNIVERSAL;
@@ISA = 'LASTCHANCE';

package LASTCHANCE;
sub foo { main::is ($_[1], 'works') }

package WHATEVER;
foo WHATEVER "works";

#
# test the \(@@foo) construct
#
package main;
@@foo = \(1..3);
@@bar = \(@@foo);
@@baz = \(1,@@foo,@@bar);
is (scalar (@@bar), 3);
is (scalar grep(ref($_), @@bar), 3);
is (scalar (@@baz), 3);

my(@@fuu) = \(1..2,3);
my(@@baa) = \(@@fuu);
my(@@bzz) = \(1,@@fuu,@@baa);
is (scalar (@@baa), 3);
is (scalar grep(ref($_), @@baa), 3);
is (scalar (@@bzz), 3);

# also, it can't be an lvalue
# (That’s what *you* think!  --sprout)
eval '\\($x, $y) = (1, 2);';
like ($@@, qr/Can\'t modify.*ref.*in.*assignment(?x:
           )|Experimental aliasing via reference not enabled/);

# test for proper destruction of lexical objects
$test = curr_test();
sub larry::DESTROY { print "# larry\nok $test\n"; }
sub curly::DESTROY { print "# curly\nok ", $test + 1, "\n"; }
sub moe::DESTROY   { print "# moe\nok ", $test + 2, "\n"; }

{
    my ($joe, @@curly, %larry);
    my $moe = bless \$joe, 'moe';
    my $curly = bless \@@curly, 'curly';
    my $larry = bless \%larry, 'larry';
    print "# leaving block\n";
}

print "# left block\n";
curr_test($test + 3);

# another glob test


$foo = "garbage";
{ local(*bar) = "foo" }
$bar = "glob 3";
local(*bar) = *bar;
is ($bar, "glob 3");

$var = "glob 4";
$_   = \$var;
is ($$_, 'glob 4');


# test if reblessing during destruction results in more destruction
$test = curr_test();
{
    package A;
    sub new { bless {}, shift }
    DESTROY { print "# destroying 'A'\nok ", $test + 1, "\n" }
    package _B;
    sub new { bless {}, shift }
    DESTROY { print "# destroying '_B'\nok $test\n"; bless shift, 'A' }
    package main;
    my $b = _B->new;
}
curr_test($test + 2);

# test if $_[0] is properly protected in DESTROY()

{
    my $test = curr_test();
    my $i = 0;
    local $SIG{'__DIE__'} = sub {
	my $m = shift;
	if ($i++ > 4) {
	    print "# infinite recursion, bailing\nnot ok $test\n";
	    exit 1;
        }
	like ($m, qr/^Modification of a read-only/);
    };
    package C;
    sub new { bless {}, shift }
    DESTROY { $_[0] = 'foo' }
    {
	print "# should generate an error...\n";
	my $c = C->new;
    }
    print "# good, didn't recurse\n";
}

# test that DESTROY is called on all objects during global destruction,
# even those without hard references [perl #36347]

is(
  runperl(
   stderr => 1, prog => 'sub DESTROY { print qq-aaa\n- } bless \$a[0]'
  ),
 "aaa\n", 'DESTROY called on array elem'
);
is(
  runperl(
   stderr => 1,
   prog => '{ bless \my@@x; *a=sub{@@x}}sub DESTROY { print qq-aaa\n- }'
  ),
 "aaa\n",
 'DESTROY called on closure variable'
);

# But cursing objects must not result in double frees
# This caused "Attempt to free unreferenced scalar" in 5.16.
fresh_perl_is(
  'bless \%foo::, bar::; bless \%bar::, foo::; print "ok\n"', "ok\n",
   { stderr => 1 },
  'no double free when stashes are blessed into each other');


# test if refgen behaves with autoviv magic
{
    my @@a;
    $a[1] = "good";
    my $got;
    for (@@a) {
	$got .= ${\$_};
	$got .= ';';
    }
    is ($got, ";good;");
}

# This test is the reason for postponed destruction in sv_unref
$a = [1,2,3];
$a = $a->[1];
is ($a, 2);

# This test used to coredump. The BEGIN block is important as it causes the
# op that created the constant reference to be freed. Hence the only
# reference to the constant string "pass" is in $a. The hack that made
# sure $a = $a->[1] would work didn't work with references to constants.


foreach my $lexical ('', 'my $a; ') {
  my $expect = "pass\n";
  my $result = runperl (switches => ['-wl'], stderr => 1,
    prog => $lexical . 'BEGIN {$a = \q{pass}}; $a = $$a; print $a');

  is ($?, 0);
  is ($result, $expect);
}

$test = curr_test();
sub x::DESTROY {print "ok ", $test + shift->[0], "\n"}
{ my $a1 = bless [3],"x";
  my $a2 = bless [2],"x";
  { my $a3 = bless [1],"x";
    my $a4 = bless [0],"x";
    567;
  }
}
curr_test($test+4);

is (runperl (switches=>['-l'],
	     prog=> 'print 1; print qq-*$\*-;print 1;'),
    "1\n*\n*\n1\n");

# bug #21347

runperl(prog => 'sub UNIVERSAL::AUTOLOAD { qr// } a->p' );
is ($?, 0, 'UNIVERSAL::AUTOLOAD called when freeing qr//');

runperl(prog => 'sub UNIVERSAL::DESTROY { warn } bless \$a, A', stderr => 1);
is ($?, 0, 'warn called inside UNIVERSAL::DESTROY');


# bug #22719

runperl(prog => 'sub f { my $x = shift; *z = $x; } f({}); f();');
is ($?, 0, 'coredump on typeglob = (SvRV && !SvROK)');

# bug #27268: freeing self-referential typeglobs could trigger
# "Attempt to free unreferenced scalar" warnings

is (runperl(
    prog => 'use Symbol;my $x=bless \gensym,q{t}; print;*$$x=$x',
    stderr => 1
), '', 'freeing self-referential typeglob');

# using a regex in the destructor for STDOUT segfaulted because the
# REGEX pad had already been freed (ithreads build only). The
# object is required to trigger the early freeing of GV refs to to STDOUT

TODO: {
    local $TODO = "works but output through pipe is mangled" if $^O eq 'VMS';
    like (runperl(
        prog => '$x=bless[]; sub IO::Handle::DESTROY{$_=q{bad};s/bad/ok/;print}',
        stderr => 1
          ), qr/^(ok)+$/, 'STDOUT destructor');
}

{
    no strict 'refs';
    $name8 = chr 163;
    $name_utf8 = $name8 . chr 256;
    chop $name_utf8;

    is ($$name8, undef, 'Nothing before we start');
    is ($$name_utf8, undef, 'Nothing before we start');
    $$name8 = "Pound";
    is ($$name8, "Pound", 'Accessing via 8 bit symref works');
    is ($$name_utf8, "Pound", 'Accessing via UTF8 symref works');
}

{
    no strict 'refs';
    $name_utf8 = $name = chr 9787;
    utf8::encode $name_utf8;

    is (length $name, 1, "Name is 1 char");
    is (length $name_utf8, 3, "UTF8 representation is 3 chars");

    is ($$name, undef, 'Nothing before we start');
    is ($$name_utf8, undef, 'Nothing before we start');
    $$name = "Face";
    is ($$name, "Face", 'Accessing via Unicode symref works');
    is ($$name_utf8, undef,
	'Accessing via the UTF8 byte sequence gives nothing');
}

{
    no strict 'refs';
    $name1 = "\0Chalk";
    $name2 = "\0Cheese";

    isnt ($name1, $name2, "They differ");

    is ($$name1, undef, 'Nothing before we start (scalars)');
    is ($$name2, undef, 'Nothing before we start');
    $$name1 = "Yummy";
    is ($$name1, "Yummy", 'Accessing via the correct name works');
    is ($$name2, undef,
	'Accessing via a different NUL-containing name gives nothing');
    # defined uses a different code path
    ok (defined $$name1, 'defined via the correct name works');
    ok (!defined $$name2,
	'defined via a different NUL-containing name gives nothing');

    is ($name1->[0], undef, 'Nothing before we start (arrays)');
    is ($name2->[0], undef, 'Nothing before we start');
    $name1->[0] = "Yummy";
    is ($name1->[0], "Yummy", 'Accessing via the correct name works');
    is ($name2->[0], undef,
	'Accessing via a different NUL-containing name gives nothing');
    ok (defined $name1->[0], 'defined via the correct name works');
    ok (!defined$name2->[0],
	'defined via a different NUL-containing name gives nothing');

    my (undef, $one) = @@{$name1}[2,3];
    my (undef, $two) = @@{$name2}[2,3];
    is ($one, undef, 'Nothing before we start (array slices)');
    is ($two, undef, 'Nothing before we start');
    @@{$name1}[2,3] = ("Very", "Yummy");
    (undef, $one) = @@{$name1}[2,3];
    (undef, $two) = @@{$name2}[2,3];
    is ($one, "Yummy", 'Accessing via the correct name works');
    is ($two, undef,
	'Accessing via a different NUL-containing name gives nothing');
    ok (defined $one, 'defined via the correct name works');
    ok (!defined $two,
	'defined via a different NUL-containing name gives nothing');

    is ($name1->{PWOF}, undef, 'Nothing before we start (hashes)');
    is ($name2->{PWOF}, undef, 'Nothing before we start');
    $name1->{PWOF} = "Yummy";
    is ($name1->{PWOF}, "Yummy", 'Accessing via the correct name works');
    is ($name2->{PWOF}, undef,
	'Accessing via a different NUL-containing name gives nothing');
    ok (defined $name1->{PWOF}, 'defined via the correct name works');
    ok (!defined $name2->{PWOF},
	'defined via a different NUL-containing name gives nothing');

    my (undef, $one) = @@{$name1}{'SNIF', 'BEEYOOP'};
    my (undef, $two) = @@{$name2}{'SNIF', 'BEEYOOP'};
    is ($one, undef, 'Nothing before we start (hash slices)');
    is ($two, undef, 'Nothing before we start');
    @@{$name1}{'SNIF', 'BEEYOOP'} = ("Very", "Yummy");
    (undef, $one) = @@{$name1}{'SNIF', 'BEEYOOP'};
    (undef, $two) = @@{$name2}{'SNIF', 'BEEYOOP'};
    is ($one, "Yummy", 'Accessing via the correct name works');
    is ($two, undef,
	'Accessing via a different NUL-containing name gives nothing');
    ok (defined $one, 'defined via the correct name works');
    ok (!defined $two,
	'defined via a different NUL-containing name gives nothing');

    $name1 = "Left"; $name2 = "Left\0Right";
    my $glob2 = *{$name2};

    is ($glob1, undef, "We get different typeglobs. In fact, undef");

    *{$name1} = sub {"One"};
    *{$name2} = sub {"Two"};

    is (&{$name1}, "One");
    is (&{$name2}, "Two");
}

# test derefs after list slice

is ( ({foo => "bar"})[0]{foo}, "bar", 'hash deref from list slice w/o ->' );
is ( ({foo => "bar"})[0]->{foo}, "bar", 'hash deref from list slice w/ ->' );
is ( ([qw/foo bar/])[0][1], "bar", 'array deref from list slice w/o ->' );
is ( ([qw/foo bar/])[0]->[1], "bar", 'array deref from list slice w/ ->' );
is ( (sub {"bar"})[0](), "bar", 'code deref from list slice w/o ->' );
is ( (sub {"bar"})[0]->(), "bar", 'code deref from list slice w/ ->' );

# deref on empty list shouldn't autovivify
{
    local $@@;
    eval { ()[0]{foo} };
    like ( "$@@", qr/Can't use an undefined value as a HASH reference/,
           "deref of undef from list slice fails" );
}

# test dereferencing errors
{
    format STDERR =
.
    my $ref;
    foreach $ref (*STDOUT{IO}, *STDERR{FORMAT}) {
	eval q/ $$ref /;
	like($@@, qr/Not a SCALAR reference/, "Scalar dereference");
	eval q/ @@$ref /;
	like($@@, qr/Not an ARRAY reference/, "Array dereference");
	eval q/ %$ref /;
	like($@@, qr/Not a HASH reference/, "Hash dereference");
	eval q/ &$ref /;
	like($@@, qr/Not a CODE reference/, "Code dereference");
    }

    $ref = *STDERR{FORMAT};
    eval q/ *$ref /;
    like($@@, qr/Not a GLOB reference/, "Glob dereference");

    $ref = *STDOUT{IO};
    eval q/ *$ref /;
    is($@@, '', "Glob dereference of PVIO is acceptable");

    is($ref, *{$ref}{IO}, "IO slot of the temporary glob is set correctly");
}

# these will segfault if they fail

my $pvbm = PVBM;
my $rpvbm = \$pvbm;

ok (!eval { *$rpvbm }, 'PVBM ref is not a GLOB ref');
ok (!eval { *$pvbm }, 'PVBM is not a GLOB ref');
ok (!eval { $$pvbm }, 'PVBM is not a SCALAR ref');
ok (!eval { @@$pvbm }, 'PVBM is not an ARRAY ref');
ok (!eval { %$pvbm }, 'PVBM is not a HASH ref');
ok (!eval { $pvbm->() }, 'PVBM is not a CODE ref');
ok (!eval { $rpvbm->foo }, 'PVBM is not an object');

# bug 24254
is( runperl(stderr => 1, prog => 'map eval qq(exit),1 for 1'), "");
is( runperl(stderr => 1, prog => 'eval { for (1) { map { die } 2 } };'), "");
is( runperl(stderr => 1, prog => 'for (125) { map { exit } (213)}'), "");
my $hushed = $^O eq 'VMS' ? 'use vmsish qw(hushed);' : '';
is( runperl(stderr => 1, prog => $hushed . 'map die,4 for 3'), "Died at -e line 1.\n");
is( runperl(stderr => 1, prog => $hushed . 'grep die,4 for 3'), "Died at -e line 1.\n");
is( runperl(stderr => 1, prog => $hushed . 'for $a (3) {@@b=sort {die} 4,5}'), "Died at -e line 1.\n");

# bug 57564
is( runperl(stderr => 1, prog => 'my $i;for $i (1) { for $i (2) { } }'), "");

# The mechanism for freeing objects in globs used to leave dangling
# pointers to freed SVs. To test this, we construct this nested structure:
#    GV => blessed(AV) => RV => GV => blessed(SV)
# all with a refcnt of 1, and hope that the second GV gets processed first
# by do_clean_named_objs.  Then when the first GV is processed, it mustn't
# find anything nasty left by the previous GV processing.
# The eval is stop things in the main body of the code holding a reference
# to a GV, and the print at the end seems to bee necessary to ensure
# the correct freeing order of *x and *y (no, I don't know why - DAPM).

is (runperl(
	prog => 'eval q[bless \@@y; bless \$x; $y[0] = \*x; $z = \*y; ]; '
		. 'delete $::{x}; delete $::{y}; print qq{ok\n};',
	stderr => 1),
    "ok\n", 'freeing freed glob in global destruction');


# Test undefined hash references as arguments to %{} in boolean context
# [perl #81750]
{
 no strict 'refs';
 eval { my $foo; %$foo;             }; ok !$@@, '%$undef';
 eval { my $foo; scalar %$foo;      }; ok !$@@, 'scalar %$undef';
 eval { my $foo; !%$foo;            }; ok !$@@, '!%$undef';
 eval { my $foo; if ( %$foo) {}     }; ok !$@@, 'if ( %$undef) {}';
 eval { my $foo; if (!%$foo) {}     }; ok !$@@, 'if (!%$undef) {}';
 eval { my $foo; unless ( %$foo) {} }; ok !$@@, 'unless ( %$undef) {}';
 eval { my $foo; unless (!%$foo) {} }; ok !$@@, 'unless (!%$undef) {}';
 eval { my $foo; 1 if %$foo;        }; ok !$@@, '1 if %$undef';
 eval { my $foo; 1 if !%$foo;       }; ok !$@@, '1 if !%$undef';
 eval { my $foo; 1 unless %$foo;    }; ok !$@@, '1 unless %$undef;';
 eval { my $foo; 1 unless ! %$foo;  }; ok !$@@, '1 unless ! %$undef';
 eval { my $foo;  %$foo ? 1 : 0;    }; ok !$@@, ' %$undef ? 1 : 0';
 eval { my $foo; !%$foo ? 1 : 0;    }; ok !$@@, '!%$undef ? 1 : 0';
}

# RT #88330
# Make sure that a leaked thinggy with multiple weak references to
# it doesn't trigger a panic with multiple rounds of global cleanup
# (Perl_sv_clean_all).

SKIP: {
    skip_if_miniperl('no Scalar::Util under miniperl', 4);

    local $ENV{PERL_DESTRUCT_LEVEL} = 2;

    # we do all permutations of array/hash, 1ref/2ref, to account
    # for the different way backref magic is stored

    fresh_perl_is(<<'EOF', 'ok', { stderr => 1 }, 'array with 1 weak ref');
use Scalar::Util qw(weaken);
my $r = [];
Internals::SvREFCNT(@@$r, 9);
my $r1 = $r;
weaken($r1);
print "ok";
EOF

    fresh_perl_is(<<'EOF', 'ok', { stderr => 1 }, 'array with 2 weak refs');
use Scalar::Util qw(weaken);
my $r = [];
Internals::SvREFCNT(@@$r, 9);
my $r1 = $r;
weaken($r1);
my $r2 = $r;
weaken($r2);
print "ok";
EOF

    fresh_perl_is(<<'EOF', 'ok', { stderr => 1 }, 'hash with 1 weak ref');
use Scalar::Util qw(weaken);
my $r = {};
Internals::SvREFCNT(%$r, 9);
my $r1 = $r;
weaken($r1);
print "ok";
EOF

    fresh_perl_is(<<'EOF', 'ok', { stderr => 1 }, 'hash with 2 weak refs');
use Scalar::Util qw(weaken);
my $r = {};
Internals::SvREFCNT(%$r, 9);
my $r1 = $r;
weaken($r1);
my $r2 = $r;
weaken($r2);
print "ok";
EOF

}

SKIP:{
    skip_if_miniperl "no Scalar::Util on miniperl", 1;
    my $error;
    *hassgropper::DESTROY = sub {
        require Scalar::Util;
        eval { Scalar::Util::weaken($_[0]) };
        $error = $@@;
        # This line caused a crash before weaken refused to weaken a
        # read-only reference:
        $do::not::overwrite::this = $_[0];
    };
    my $xs = bless [], "hassgropper";
    undef $xs;
    like $error, qr/^Modification of a read-only/,
       'weaken refuses to weaken a read-only ref';
    # Now that the test has passed, avoid sabotaging global destruction:
    undef *hassgropper::DESTROY;
    undef $do::not::overwrite::this;
}


is ref( bless {}, "nul\0clean" ), "nul\0clean", "ref() is nul-clean";

# Test constants and references thereto.
for (3) {
    eval { $_ = 4 };
    like $@@, qr/^Modification of a read-only/,
       'assignment to value aliased to literal number';
    eval { ${\$_} = 4 };
    like $@@, qr/^Modification of a read-only/,
       'refgen does not allow assignment to value aliased to literal number';
}
for ("4eounthouonth") {
    eval { $_ = 4 };
    like $@@, qr/^Modification of a read-only/,
       'assignment to value aliased to literal string';
    eval { ${\$_} = 4 };
    like $@@, qr/^Modification of a read-only/,
       'refgen does not allow assignment to value aliased to literal string';
}
{
    my $aref = \123;
    is \$$aref, $aref,
	'[perl #109746] referential identity of \literal under threads+mad'
}

# Bit of a hack to make test.pl happy. There are 3 more tests after it leaves.
$test = curr_test();
curr_test($test + 3);
# test global destruction

my $test1 = $test + 1;
my $test2 = $test + 2;

package FINALE;

{
    $ref3 = bless ["ok $test2\n"];	# package destruction
    my $ref2 = bless ["ok $test1\n"];	# lexical destruction
    local $ref1 = bless ["ok $test\n"];	# dynamic destruction
    1;					# flush any temp values on stack
}

DESTROY {
    print $_[0][0];
}

@


1.15
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d6 1
a6 1
    require 'test.pl';
d13 4
d87 1
a87 1
# Test nested anonymous lists.
d326 1
d328 2
a329 1
like ($@@, qr/Can\'t modify.*ref.*in.*assignment/);
d626 1
a626 1
    like ( "$@@", "Can't use an undefined value as a HASH reference",
a800 1
    require Config;
a808 1
    require Config;
@


1.14
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d11 1
a11 1
plan(230);
d789 25
@


1.13
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d11 1
a11 1
plan(228);
d122 1
d410 7
@


1.12
log
@merge in perl 5.12.2 plus local changes
@
text
@d6 1
a8 1
require 'test.pl';
a9 1
use re ();
d11 1
a11 1
plan(196);
d123 9
d138 3
a140 1
{
a176 1
#   LVALUE ref, 'cos I can't work out how to create one :)
d188 2
d192 3
a194 1
    [ 'lvalue',         LVALUE  => \substr($x, 0, 0)    ],
d213 9
d392 19
d476 1
a476 1
    prog => 'use Symbol;my $x=bless \gensym,"t"; print;*$$x=$x',
d487 1
a487 1
        prog => '$x=bless[]; sub IO::Handle::DESTROY{$_="bad";s/bad/ok/;print}',
d492 1
a492 1
TODO: {
a501 1
    local $TODO = "UTF8 mangled in symrefs";
d505 1
a505 1
TODO: {
a516 1
    local $TODO = "UTF8 mangled in symrefs";
d668 113
@


1.11
log
@Merge in perl 5.10.1; part two
@
text
@d10 1
d12 1
a12 1
plan(189);
d128 26
d196 2
a197 2
is (ref *STDOUT{IO}, 'IO::Handle', 'IO refs are blessed into IO::Handle');
like (*STDOUT{IO}, qr/^IO::Handle=IO\(0x[0-9a-f]+\)$/,
d443 7
a449 4
like (runperl(
    prog => '$x=bless[]; sub IO::Handle::DESTROY{$_="bad";s/bad/ok/;print}',
    stderr => 1
      ), qr/^(ok)+$/, 'STDOUT destructor');
@


1.10
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d11 1
a11 1
plan(138);
a56 5
# test that ref(vstring) makes sense
my $vstref = \v1;
is (ref($vstref), "VSTRING", "ref(vstr) eq VSTRING");
like ( $vstref, qr/VSTRING\(0x[0-9a-f]+\)/, '\vstr is also VSTRING');

d129 43
a171 3
is (ref $subref, 'CODE');
is (ref $ref, 'ARRAY');
is (ref $refref, 'HASH');
d573 26
@


1.9
log
@merge in perl 5.8.8
@
text
@d11 1
a11 1
plan (74);
d57 5
d385 153
@


1.8
log
@sync in-tree perl with 5.8.6
@
text
@d8 2
a9 1
print "1..70\n";
d11 1
a11 1
require 'test.pl';
d15 2
a16 2
$bar = "ok 1\n";
$foo = "ok 2\n";
d19 1
a19 1
    print $foo;
d21 1
a21 1
print $foo;
d23 2
a24 2
$baz = "ok 3\n";
$foo = "ok 4\n";
d27 1
a27 1
    print $foo;
d29 1
a29 1
print $foo;
d31 1
a31 1
$foo = "ok 6\n";
d34 3
a36 3
    print $foo;
    $foo = "ok 5\n";
    print $foo;
d38 1
a38 1
print $foo;
d40 2
d44 5
a48 4
$baz = "ok 7\n";
$bar = 'baz';
$foo = 'bar';
print $$$foo;
d54 2
a55 2
$BAZ = "ok 8\n";
print $$$FOO;
d59 2
a60 1
@@ary = (9,10,11,12);
d71 5
a75 1
print @@{'d'};
d80 2
a81 2
$x = "ok 13\n";
print $$$refref;
d86 4
a89 4
print scalar @@$ref == 3 ? "ok 14\n" : "not ok 14\n";
print $$ref[1] == 2 ? "ok 15\n" : "not ok 15\n";
print ${$$ref[2]}[2] == 5 ? "ok 16\n" : "not ok 16\n";
print scalar @@{$$ref[0]} == 0 ? "ok 17\n" : "not ok 17\n";
d91 2
a92 2
print $ref->[1] == 2 ? "ok 18\n" : "not ok 18\n";
print $ref->[2]->[0] == 3 ? "ok 19\n" : "not ok 19\n";
d98 1
a98 1
print $refref->{"key"}->[2]->[0] == 3 ? "ok 20\n" : "not ok 20\n";
d105 1
a105 1
print join(':',@@{$spring[5]}) eq "123:456:789" ? "ok 21\n" : "not ok 21\n";
d111 1
a111 1
print join(':',@@{$spring2{"foo"}}) eq "1:2:3:4" ? "ok 22\n" : "not ok 22\n";
d115 7
a121 3
sub mysub { print "ok 23\n" }
$subref = \&mysub;
&$subref;
d124 2
a125 2
$$subrefref->("ok 24\n");
sub mysub2 { print shift }
d129 3
a131 3
print ref $subref	eq CODE  ? "ok 25\n" : "not ok 25\n";
print ref $ref		eq ARRAY ? "ok 26\n" : "not ok 26\n";
print ref $refref	eq HASH  ? "ok 27\n" : "not ok 27\n";
d136 3
a138 3
print ref $anonhash	eq HASH  ? "ok 28\n" : "not ok 28\n";
$anonhash2 = {FOO => BAR, ABC => XYZ,};
print join('', sort values %$anonhash2) eq BARXYZ ? "ok 29\n" : "not ok 29\n";
d145 2
a146 2
print ref $object	eq MYHASH  ? "ok 30\n" : "not ok 30\n";
print $object->{ABC}	eq XYZ     ? "ok 31\n" : "not ok 31\n";
d149 1
a149 1
print ref $object2	eq MYHASH  ? "ok 32\n" : "not ok 32\n";
d153 1
a153 1
&mymethod($object,33);
d158 3
a160 2
	unless ref $THIS eq MYHASH;
    print $THIS->{FOO} eq BAR  ? "ok $ARGS[0]\n" : "not ok $ARGS[0]\n";
d165 1
a165 1
$string = "not ok 34\n";
d167 1
a167 1
$string = "ok 34\n";
d173 1
a173 1
    print $string;
d176 1
a176 1
    print ref shift ne HASH ? "ok 35\n" : "not ok 35\n";
d183 1
a183 1
@@ISA = (BASEOBJ);
d185 1
a185 1
$main'object = bless {FOO => foo, BAR => bar};
d191 1
a191 1
print $object->doit("BAR") eq bar ? "ok 36\n" : "not ok 36\n";
d196 1
a196 1
print $foo eq foo ? "ok 37\n" : "not ok 37\n";
d200 1
a200 1
    die "Not an OBJ" unless ref $ref eq OBJ;
d208 1
a208 1
sub foo { print $_[1] }
d211 1
a211 1
foo WHATEVER "ok 38\n";
d220 3
a222 3
print @@bar == 3 ? "ok 39\n" : "not ok 39\n";
print grep(ref($_), @@bar) == 3 ? "ok 40\n" : "not ok 40\n";
print @@baz == 3 ? "ok 41\n" : "not ok 41\n";
d227 3
a229 3
print @@baa == 3 ? "ok 42\n" : "not ok 42\n";
print grep(ref($_), @@baa) == 3 ? "ok 43\n" : "not ok 43\n";
print @@bzz == 3 ? "ok 44\n" : "not ok 44\n";
d233 1
a233 1
print $@@ =~ /Can\'t modify.*ref.*in.*assignment/ ? "ok 45\n" : "not ok 45\n";
d236 4
a239 4

sub larry::DESTROY { print "# larry\nok 46\n"; }
sub curly::DESTROY { print "# curly\nok 47\n"; }
sub moe::DESTROY   { print "# moe\nok 48\n"; }
d250 1
d254 2
a255 1
$foo = "not ok 49";
d257 1
a257 1
$bar = "ok 49";
d259 1
a259 1
print "$bar\n";
d261 1
a261 1
$var = "ok 50";
d263 2
a264 1
print $$_,"\n";
d267 1
a267 1

d271 1
a271 1
    DESTROY { print "# destroying 'A'\nok 52\n" }
d274 1
a274 1
    DESTROY { print "# destroying '_B'\nok 51\n"; bless shift, 'A' }
d278 1
d283 1
d288 1
a288 1
	    print "# infinite recursion, bailing\nnot ok 53\n";
d291 1
a291 2
	print "# $m";
	if ($m =~ /^Modification of a read-only/) { print "ok 53\n" }
a303 1

d306 7
a312 2
    $a[1] = "ok 54\n";
    print ${\$_} for @@a;
d318 1
a318 2
print "not " unless $a == 2;
print "ok 55\n";
a324 1
my $test = 56;
d331 2
a332 7
  if ($? == 0 and $result eq $expect) {
    print "ok $test\n";
  } else {
    print "not ok $test # \$? = $?\n";
    print "# expected ", _qq ($expect), ", got ", _qq ($result), "\n";
  }
  $test++;
d335 1
d344 1
a344 1
$test+=4;
d346 3
a348 12
my $result = runperl (switches=>['-l'],
                      prog=> 'print 1; print qq-*$\*-;print 1;');
my $expect = "1\n*\n*\n1\n";
if ($result eq $expect) {
  print "ok $test\n";
} else {
  print "not ok $test\n";
  foreach ($expect, $result) {
    s/\n/\\n/gs;
  }
  print "# expected \"$expect\", got \"$result\"\n";
}
d353 1
a353 2
if ($? != 0) { print "not " };
print "ok ",++$test," - UNIVERSAL::AUTOLOAD called when freeing qr//\n";
d356 1
a356 2
if ($? != 0) { print "not " };
print "ok ",++$test," - warn called inside UNIVERSAL::DESTROY\n";
d362 1
a362 2
if ($? != 0) { print "not " };
print "ok ",++$test," - coredump on typeglob = (SvRV && !SvROK)\n";
d367 1
a367 1
$result = runperl(
d370 1
a370 4
);
print "not " if length $result;
print "ok ",++$test," - freeing self-referential typeglob\n";
print "# got: $result\n" if length $result;
d376 1
a376 1
$result = runperl(
d379 1
a379 4
);
print "not " unless $result =~ /^(ok)+$/;
print "ok ",++$test," - STDOUT destructor\n";
print "# got: $result\n" unless $result =~ /^(ok)+$/;
d381 3
a385 1
++$test;
@


1.7
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d8 1
a8 1
print "1..69\n";
d371 12
d401 1
@


1.6
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d8 1
a8 1
print "1..68\n";
d360 10
@


1.5
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d8 1
a8 1
print "1..62\n";
d203 1
a203 1
@@foo = (1,2,3);
d210 1
a210 1
my(@@fuu) = (1,2,3);
d217 4
d223 3
a225 3
sub larry::DESTROY { print "# larry\nok 45\n"; }
sub curly::DESTROY { print "# curly\nok 46\n"; }
sub moe::DESTROY   { print "# moe\nok 47\n"; }
d239 1
a239 1
$foo = "not ok 48";
d241 1
a241 1
$bar = "ok 48";
d245 1
a245 1
$var = "ok 49";
d254 1
a254 1
    DESTROY { print "# destroying 'A'\nok 51\n" }
d257 1
a257 1
    DESTROY { print "# destroying '_B'\nok 50\n"; bless shift, 'A' }
d269 1
a269 1
	    print "# infinite recursion, bailing\nnot ok 52\n";
d273 1
a273 1
	if ($m =~ /^Modification of a read-only/) { print "ok 52\n" }
d289 1
a289 1
    $a[1] = "ok 53\n";
d297 22
a318 1
print "ok 54\n";
d320 5
a324 5
sub x::DESTROY {print "ok ", 54 + shift->[0], "\n"}
{ my $a1 = bless [4],"x";
  my $a2 = bless [3],"x";
  { my $a3 = bless [2],"x";
    my $a4 = bless [1],"x";
d328 1
a328 1

d334 1
a334 1
  print "ok 59\n";
d336 1
a336 1
  print "not ok 59\n";
d343 18
d363 1
a363 1
my $test = 60;
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d3 8
a10 1
print "1..56\n";
d289 29
d320 4
d327 3
a329 3
    $ref3 = bless ["ok 56\n"];		# package destruction
    my $ref2 = bless ["ok 55\n"];	# lexical destruction
    local $ref1 = bless ["ok 54\n"];	# dynamic destruction
@


1.3
log
@perl5.005_03 (stock)
@
text
@d3 1
a3 1
print "1..55\n";
d244 1
a244 1
    package B;
d246 1
a246 1
    DESTROY { print "# destroying 'B'\nok 50\n"; bless shift, 'A' }
d248 1
a248 1
    my $b = B->new;
d274 8
d287 3
a289 3
    $ref3 = bless ["ok 55\n"];		# package destruction
    my $ref2 = bless ["ok 54\n"];	# lexical destruction
    local $ref1 = bless ["ok 53\n"];	# dynamic destruction
@


1.2
log
@perl 5.004_04
@
text
@d3 1
a3 1
print "1..51\n";
d234 42
d279 3
a281 3
    $ref3 = bless ["ok 51\n"];		# package destruction
    my $ref2 = bless ["ok 50\n"];	# lexical destruction
    local $ref1 = bless ["ok 49\n"];	# dynamic destruction
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
print "1..41\n";
d104 1
a104 1
&$$subrefref("ok 24\n");
d192 42
d237 3
a239 3
    $ref3 = bless ["ok 41\n"];		# package destruction
    my $ref2 = bless ["ok 40\n"];	# lexical destruction
    local $ref1 = bless ["ok 39\n"];	# dynamic destruction
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d3 1
a3 1
print "1..55\n";
d104 1
a104 1
$$subrefref->("ok 24\n");
a191 84
#
# test the \(@@foo) construct
#
package main;
@@foo = (1,2,3);
@@bar = \(@@foo);
@@baz = \(1,@@foo,@@bar);
print @@bar == 3 ? "ok 39\n" : "not ok 39\n";
print grep(ref($_), @@bar) == 3 ? "ok 40\n" : "not ok 40\n";
print @@baz == 3 ? "ok 41\n" : "not ok 41\n";

my(@@fuu) = (1,2,3);
my(@@baa) = \(@@fuu);
my(@@bzz) = \(1,@@fuu,@@baa);
print @@baa == 3 ? "ok 42\n" : "not ok 42\n";
print grep(ref($_), @@baa) == 3 ? "ok 43\n" : "not ok 43\n";
print @@bzz == 3 ? "ok 44\n" : "not ok 44\n";

# test for proper destruction of lexical objects

sub larry::DESTROY { print "# larry\nok 45\n"; }
sub curly::DESTROY { print "# curly\nok 46\n"; }
sub moe::DESTROY   { print "# moe\nok 47\n"; }

{
    my ($joe, @@curly, %larry);
    my $moe = bless \$joe, 'moe';
    my $curly = bless \@@curly, 'curly';
    my $larry = bless \%larry, 'larry';
    print "# leaving block\n";
}

print "# left block\n";

# another glob test

$foo = "not ok 48";
{ local(*bar) = "foo" }
$bar = "ok 48";
local(*bar) = *bar;
print "$bar\n";

$var = "ok 49";
$_   = \$var;
print $$_,"\n";

# test if reblessing during destruction results in more destruction

{
    package A;
    sub new { bless {}, shift }
    DESTROY { print "# destroying 'A'\nok 51\n" }
    package B;
    sub new { bless {}, shift }
    DESTROY { print "# destroying 'B'\nok 50\n"; bless shift, 'A' }
    package main;
    my $b = B->new;
}

# test if $_[0] is properly protected in DESTROY()

{
    my $i = 0;
    local $SIG{'__DIE__'} = sub {
	my $m = shift;
	if ($i++ > 4) {
	    print "# infinite recursion, bailing\nnot ok 52\n";
	    exit 1;
        }
	print "# $m";
	if ($m =~ /^Modification of a read-only/) { print "ok 52\n" }
    };
    package C;
    sub new { bless {}, shift }
    DESTROY { $_[0] = 'foo' }
    {
	print "# should generate an error...\n";
	my $c = C->new;
    }
    print "# good, didn't recurse\n";
}

# test global destruction

d195 3
a197 3
    $ref3 = bless ["ok 55\n"];		# package destruction
    my $ref2 = bless ["ok 54\n"];	# lexical destruction
    local $ref1 = bless ["ok 53\n"];	# dynamic destruction
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d3 1
a3 1
print "1..56\n";
d244 1
a244 1
    package _B;
d246 1
a246 1
    DESTROY { print "# destroying '_B'\nok 50\n"; bless shift, 'A' }
d248 1
a248 1
    my $b = _B->new;
a273 8
# test if refgen behaves with autoviv magic

{
    my @@a;
    $a[1] = "ok 53\n";
    print ${\$_} for @@a;
}

d279 3
a281 3
    $ref3 = bless ["ok 56\n"];		# package destruction
    my $ref2 = bless ["ok 55\n"];	# lexical destruction
    local $ref1 = bless ["ok 54\n"];	# dynamic destruction
@


1.1.1.4
log
@stock perl 5.8.0 from CPAN
@
text
@d3 1
a3 8
BEGIN {
    chdir 't' if -d 't';
    @@INC = qw(. ../lib);
}

print "1..62\n";

require 'test.pl';
a281 29
# This test is the reason for postponed destruction in sv_unref
$a = [1,2,3];
$a = $a->[1];
print "not " unless $a == 2;
print "ok 54\n";

sub x::DESTROY {print "ok ", 54 + shift->[0], "\n"}
{ my $a1 = bless [4],"x";
  my $a2 = bless [3],"x";
  { my $a3 = bless [2],"x";
    my $a4 = bless [1],"x";
    567;
  }
}


my $result = runperl (switches=>['-l'],
                      prog=> 'print 1; print qq-*$\*-;print 1;');
my $expect = "1\n*\n*\n1\n";
if ($result eq $expect) {
  print "ok 59\n";
} else {
  print "not ok 59\n";
  foreach ($expect, $result) {
    s/\n/\\n/gs;
  }
  print "# expected \"$expect\", got \"$result\"\n";
}

a283 4
my $test = 60;
my $test1 = $test + 1;
my $test2 = $test + 2;

d287 3
a289 3
    $ref3 = bless ["ok $test2\n"];	# package destruction
    my $ref2 = bless ["ok $test1\n"];	# lexical destruction
    local $ref1 = bless ["ok $test\n"];	# dynamic destruction
@


1.1.1.5
log
@perl 5.8.2 from CPAN
@
text
@d8 1
a8 1
print "1..68\n";
d203 1
a203 1
@@foo = \(1..3);
d210 1
a210 1
my(@@fuu) = \(1..2,3);
a216 4
# also, it can't be an lvalue
eval '\\($x, $y) = (1, 2);';
print $@@ =~ /Can\'t modify.*ref.*in.*assignment/ ? "ok 45\n" : "not ok 45\n";

d219 3
a221 3
sub larry::DESTROY { print "# larry\nok 46\n"; }
sub curly::DESTROY { print "# curly\nok 47\n"; }
sub moe::DESTROY   { print "# moe\nok 48\n"; }
d235 1
a235 1
$foo = "not ok 49";
d237 1
a237 1
$bar = "ok 49";
d241 1
a241 1
$var = "ok 50";
d250 1
a250 1
    DESTROY { print "# destroying 'A'\nok 52\n" }
d253 1
a253 1
    DESTROY { print "# destroying '_B'\nok 51\n"; bless shift, 'A' }
d265 1
a265 1
	    print "# infinite recursion, bailing\nnot ok 53\n";
d269 1
a269 1
	if ($m =~ /^Modification of a read-only/) { print "ok 53\n" }
d285 1
a285 1
    $a[1] = "ok 54\n";
d293 1
a293 1
print "ok 55\n";
d295 6
a300 17
# This test used to coredump. The BEGIN block is important as it causes the
# op that created the constant reference to be freed. Hence the only
# reference to the constant string "pass" is in $a. The hack that made
# sure $a = $a->[1] would work didn't work with references to constants.

my $test = 56;

foreach my $lexical ('', 'my $a; ') {
  my $expect = "pass\n";
  my $result = runperl (switches => ['-wl'], stderr => 1,
    prog => $lexical . 'BEGIN {$a = \q{pass}}; $a = $$a; print $a');

  if ($? == 0 and $result eq $expect) {
    print "ok $test\n";
  } else {
    print "not ok $test # \$? = $?\n";
    print "# expected ", _qq ($expect), ", got ", _qq ($result), "\n";
a301 1
  $test++;
a303 9
sub x::DESTROY {print "ok ", $test + shift->[0], "\n"}
{ my $a1 = bless [3],"x";
  my $a2 = bless [2],"x";
  { my $a3 = bless [1],"x";
    my $a4 = bless [0],"x";
    567;
  }
}
$test+=4;
d309 1
a309 1
  print "ok $test\n";
d311 1
a311 1
  print "not ok $test\n";
a317 18
# bug #21347

runperl(prog => 'sub UNIVERSAL::AUTOLOAD { qr// } a->p' );
if ($? != 0) { print "not " };
print "ok ",++$test," - UNIVERSAL::AUTOLOAD called when freeing qr//\n";

runperl(prog => 'sub UNIVERSAL::DESTROY { warn } bless \$a, A', stderr => 1);
if ($? != 0) { print "not " };
print "ok ",++$test," - warn called inside UNIVERSAL::DESTROY\n";


# bug #22719

runperl(prog => 'sub f { my $x = shift; *z = $x; } f({}); f();');
if ($? != 0) { print "not " };
print "ok ",++$test," - coredump on typeglob = (SvRV && !SvROK)\n";


d320 1
a320 1
++$test;
@


1.1.1.6
log
@Import of stock perl 5.8.5
@
text
@d8 1
a8 1
print "1..69\n";
a359 10
# bug #27268: freeing self-referential typeglobs could trigger
# "Attempt to free unreferenced scalar" warnings

$result = runperl(
    prog => 'use Symbol;my $x=bless \gensym,"t"; print;*$$x=$x',
    stderr => 1
);
print "not " if length $result;
print "ok ",++$test," - freeing self-referential typeglob\n";
print "# got: $result\n" if length $result;
@


1.1.1.7
log
@perl 5.8.6 from CPAN
@
text
@d8 1
a8 1
print "1..70\n";
a370 12
# using a regex in the destructor for STDOUT segfaulted because the
# REGEX pad had already been freed (ithreads build only). The
# object is required to trigger the early freeing of GV refs to to STDOUT

$result = runperl(
    prog => '$x=bless[]; sub IO::Handle::DESTROY{$_="bad";s/bad/ok/;print}',
    stderr => 1
);
print "not " unless $result =~ /^(ok)+$/;
print "ok ",++$test," - STDOUT destructor\n";
print "# got: $result\n" unless $result =~ /^(ok)+$/;

a388 1

@


1.1.1.8
log
@perl 5.8.8 import
@
text
@d8 2
a10 3
use strict qw(refs subs);

plan (74);
d14 2
a15 2
$bar = "one";
$foo = "two";
d18 1
a18 1
    is($foo, 'one');
d20 1
a20 1
is ($foo, 'two');
d22 2
a23 2
$baz = "three";
$foo = "four";
d26 1
a26 1
    is ($foo, 'three');
d28 1
a28 1
is ($foo, 'four');
d30 1
a30 1
$foo = "global";
d33 3
a35 3
    is ($foo, undef);
    $foo = "local";
    is ($foo, 'local');
d37 1
a37 1
is ($foo, 'global');
a38 2
{
    no strict 'refs';
d41 4
a44 5
    $baz = "valid";
    $bar = 'baz';
    $foo = 'bar';
    is ($$$foo, 'valid');
}
d50 2
a51 2
$BAZ = "hit";
is ($$$FOO, 'hit');
d55 1
a55 2
my $test = curr_test();
@@ary = ($test,$test+1,$test+2,$test+3);
d66 1
a66 5
{
    no strict 'refs';
    print @@{'d'};
}
curr_test($test+4);
d71 2
a72 2
$x = "Good";
is ($$$refref, 'Good');
d77 4
a80 4
is (scalar @@$ref, 3);
is ($$ref[1], 2);
is (${$$ref[2]}[2], 5);
is (scalar @@{$$ref[0]}, 0);
d82 2
a83 2
is ($ref->[1], 2);
is ($ref->[2]->[0], 3);
d89 1
a89 1
is ($refref->{"key"}->[2]->[0], 3);
d96 1
a96 1
is (join(':',@@{$spring[5]}), "123:456:789");
d102 1
a102 1
is (join(':',@@{$spring2{"foo"}}), "1:2:3:4");
d106 3
a108 7
{
    my $called;
    sub mysub { $called++; }
    $subref = \&mysub;
    &$subref;
    is ($called, 1);
}
d111 2
a112 2
is ($$subrefref->("GOOD"), "good");
sub mysub2 { lc shift }
d116 3
a118 3
is (ref $subref, 'CODE');
is (ref $ref, 'ARRAY');
is (ref $refref, 'HASH');
d123 3
a125 3
is (ref $anonhash, 'HASH');
$anonhash2 = {FOO => 'BAR', ABC => 'XYZ',};
is (join('', sort values %$anonhash2), 'BARXYZ');
d132 2
a133 2
main::is (ref $object, 'MYHASH');
main::is ($object->{ABC}, 'XYZ');
d136 1
a136 1
main::is (ref $object2,	'MYHASH');
d140 1
a140 1
&mymethod($object,"argument");
d145 2
a146 3
	unless ref $THIS eq 'MYHASH';
    main::is ($ARGS[0], "argument");
    main::is ($THIS->{FOO}, 'BAR');
d151 1
a151 1
$string = "bad";
d153 1
a153 1
$string = "good";
d159 1
a159 1
    main::is ($string, 'good');
d162 1
a162 1
    main::isnt (ref shift, 'HASH');
d169 1
a169 1
@@ISA = ('BASEOBJ');
d171 1
a171 1
$main'object = bless {FOO => 'foo', BAR => 'bar'};
d177 1
a177 1
is ($object->doit("BAR"), 'bar');
d182 1
a182 1
main::is ($foo, 'foo');
d186 1
a186 1
    die "Not an OBJ" unless ref $ref eq 'OBJ';
d194 1
a194 1
sub foo { main::is ($_[1], 'works') }
d197 1
a197 1
foo WHATEVER "works";
d206 3
a208 3
is (scalar (@@bar), 3);
is (scalar grep(ref($_), @@bar), 3);
is (scalar (@@baz), 3);
d213 3
a215 3
is (scalar (@@baa), 3);
is (scalar grep(ref($_), @@baa), 3);
is (scalar (@@bzz), 3);
d219 1
a219 1
like ($@@, qr/Can\'t modify.*ref.*in.*assignment/);
d222 4
a225 4
$test = curr_test();
sub larry::DESTROY { print "# larry\nok $test\n"; }
sub curly::DESTROY { print "# curly\nok ", $test + 1, "\n"; }
sub moe::DESTROY   { print "# moe\nok ", $test + 2, "\n"; }
a235 1
curr_test($test + 3);
d239 1
a239 2

$foo = "garbage";
d241 1
a241 1
$bar = "glob 3";
d243 1
a243 1
is ($bar, "glob 3");
d245 1
a245 1
$var = "glob 4";
d247 1
a247 1
is ($$_, 'glob 4');
d249 1
a250 2
# test if reblessing during destruction results in more destruction
$test = curr_test();
d254 1
a254 1
    DESTROY { print "# destroying 'A'\nok ", $test + 1, "\n" }
d257 1
a257 1
    DESTROY { print "# destroying '_B'\nok $test\n"; bless shift, 'A' }
a260 1
curr_test($test + 2);
a264 1
    my $test = curr_test();
d269 1
a269 1
	    print "# infinite recursion, bailing\nnot ok $test\n";
d272 2
a273 1
	like ($m, qr/^Modification of a read-only/);
d286 1
d289 2
a290 7
    $a[1] = "good";
    my $got;
    for (@@a) {
	$got .= ${\$_};
	$got .= ';';
    }
    is ($got, ";good;");
d296 2
a297 1
is ($a, 2);
d304 1
d311 7
a317 2
  is ($?, 0);
  is ($result, $expect);
a319 1
$test = curr_test();
d328 1
a328 1
curr_test($test+4);
d330 12
a341 3
is (runperl (switches=>['-l'],
	     prog=> 'print 1; print qq-*$\*-;print 1;'),
    "1\n*\n*\n1\n");
d346 2
a347 1
is ($?, 0, 'UNIVERSAL::AUTOLOAD called when freeing qr//');
d350 2
a351 1
is ($?, 0, 'warn called inside UNIVERSAL::DESTROY');
d357 2
a358 1
is ($?, 0, 'coredump on typeglob = (SvRV && !SvROK)');
d363 1
a363 1
is (runperl(
d366 4
a369 1
), '', 'freeing self-referential typeglob');
d375 1
a375 1
like (runperl(
d378 4
a381 1
      ), qr/^(ok)+$/, 'STDOUT destructor');
a382 3
# Bit of a hack to make test.pl happy. There are 3 more tests after it leaves.
$test = curr_test();
curr_test($test + 3);
d385 1
@


1.1.1.9
log
@import perl 5.10.0 from CPAN
@
text
@d11 1
a11 1
plan(138);
a56 5
# test that ref(vstring) makes sense
my $vstref = \v1;
is (ref($vstref), "VSTRING", "ref(vstr) eq VSTRING");
like ( $vstref, qr/VSTRING\(0x[0-9a-f]+\)/, '\vstr is also VSTRING');

a379 153

TODO: {
    no strict 'refs';
    $name8 = chr 163;
    $name_utf8 = $name8 . chr 256;
    chop $name_utf8;

    is ($$name8, undef, 'Nothing before we start');
    is ($$name_utf8, undef, 'Nothing before we start');
    $$name8 = "Pound";
    is ($$name8, "Pound", 'Accessing via 8 bit symref works');
    local $TODO = "UTF8 mangled in symrefs";
    is ($$name_utf8, "Pound", 'Accessing via UTF8 symref works');
}

TODO: {
    no strict 'refs';
    $name_utf8 = $name = chr 9787;
    utf8::encode $name_utf8;

    is (length $name, 1, "Name is 1 char");
    is (length $name_utf8, 3, "UTF8 representation is 3 chars");

    is ($$name, undef, 'Nothing before we start');
    is ($$name_utf8, undef, 'Nothing before we start');
    $$name = "Face";
    is ($$name, "Face", 'Accessing via Unicode symref works');
    local $TODO = "UTF8 mangled in symrefs";
    is ($$name_utf8, undef,
	'Accessing via the UTF8 byte sequence gives nothing');
}

{
    no strict 'refs';
    $name1 = "\0Chalk";
    $name2 = "\0Cheese";

    isnt ($name1, $name2, "They differ");

    is ($$name1, undef, 'Nothing before we start (scalars)');
    is ($$name2, undef, 'Nothing before we start');
    $$name1 = "Yummy";
    is ($$name1, "Yummy", 'Accessing via the correct name works');
    is ($$name2, undef,
	'Accessing via a different NUL-containing name gives nothing');
    # defined uses a different code path
    ok (defined $$name1, 'defined via the correct name works');
    ok (!defined $$name2,
	'defined via a different NUL-containing name gives nothing');

    is ($name1->[0], undef, 'Nothing before we start (arrays)');
    is ($name2->[0], undef, 'Nothing before we start');
    $name1->[0] = "Yummy";
    is ($name1->[0], "Yummy", 'Accessing via the correct name works');
    is ($name2->[0], undef,
	'Accessing via a different NUL-containing name gives nothing');
    ok (defined $name1->[0], 'defined via the correct name works');
    ok (!defined$name2->[0],
	'defined via a different NUL-containing name gives nothing');

    my (undef, $one) = @@{$name1}[2,3];
    my (undef, $two) = @@{$name2}[2,3];
    is ($one, undef, 'Nothing before we start (array slices)');
    is ($two, undef, 'Nothing before we start');
    @@{$name1}[2,3] = ("Very", "Yummy");
    (undef, $one) = @@{$name1}[2,3];
    (undef, $two) = @@{$name2}[2,3];
    is ($one, "Yummy", 'Accessing via the correct name works');
    is ($two, undef,
	'Accessing via a different NUL-containing name gives nothing');
    ok (defined $one, 'defined via the correct name works');
    ok (!defined $two,
	'defined via a different NUL-containing name gives nothing');

    is ($name1->{PWOF}, undef, 'Nothing before we start (hashes)');
    is ($name2->{PWOF}, undef, 'Nothing before we start');
    $name1->{PWOF} = "Yummy";
    is ($name1->{PWOF}, "Yummy", 'Accessing via the correct name works');
    is ($name2->{PWOF}, undef,
	'Accessing via a different NUL-containing name gives nothing');
    ok (defined $name1->{PWOF}, 'defined via the correct name works');
    ok (!defined $name2->{PWOF},
	'defined via a different NUL-containing name gives nothing');

    my (undef, $one) = @@{$name1}{'SNIF', 'BEEYOOP'};
    my (undef, $two) = @@{$name2}{'SNIF', 'BEEYOOP'};
    is ($one, undef, 'Nothing before we start (hash slices)');
    is ($two, undef, 'Nothing before we start');
    @@{$name1}{'SNIF', 'BEEYOOP'} = ("Very", "Yummy");
    (undef, $one) = @@{$name1}{'SNIF', 'BEEYOOP'};
    (undef, $two) = @@{$name2}{'SNIF', 'BEEYOOP'};
    is ($one, "Yummy", 'Accessing via the correct name works');
    is ($two, undef,
	'Accessing via a different NUL-containing name gives nothing');
    ok (defined $one, 'defined via the correct name works');
    ok (!defined $two,
	'defined via a different NUL-containing name gives nothing');

    $name1 = "Left"; $name2 = "Left\0Right";
    my $glob2 = *{$name2};

    is ($glob1, undef, "We get different typeglobs. In fact, undef");

    *{$name1} = sub {"One"};
    *{$name2} = sub {"Two"};

    is (&{$name1}, "One");
    is (&{$name2}, "Two");
}

# test derefs after list slice

is ( ({foo => "bar"})[0]{foo}, "bar", 'hash deref from list slice w/o ->' );
is ( ({foo => "bar"})[0]->{foo}, "bar", 'hash deref from list slice w/ ->' );
is ( ([qw/foo bar/])[0][1], "bar", 'array deref from list slice w/o ->' );
is ( ([qw/foo bar/])[0]->[1], "bar", 'array deref from list slice w/ ->' );
is ( (sub {"bar"})[0](), "bar", 'code deref from list slice w/o ->' );
is ( (sub {"bar"})[0]->(), "bar", 'code deref from list slice w/ ->' );

# deref on empty list shouldn't autovivify
{
    local $@@;
    eval { ()[0]{foo} };
    like ( "$@@", "Can't use an undefined value as a HASH reference",
           "deref of undef from list slice fails" );
}

# test dereferencing errors
{
    format STDERR =
.
    my $ref;
    foreach $ref (*STDOUT{IO}, *STDERR{FORMAT}) {
	eval q/ $$ref /;
	like($@@, qr/Not a SCALAR reference/, "Scalar dereference");
	eval q/ @@$ref /;
	like($@@, qr/Not an ARRAY reference/, "Array dereference");
	eval q/ %$ref /;
	like($@@, qr/Not a HASH reference/, "Hash dereference");
	eval q/ &$ref /;
	like($@@, qr/Not a CODE reference/, "Code dereference");
    }

    $ref = *STDERR{FORMAT};
    eval q/ *$ref /;
    like($@@, qr/Not a GLOB reference/, "Glob dereference");

    $ref = *STDOUT{IO};
    eval q/ *$ref /;
    is($@@, '', "Glob dereference of PVIO is acceptable");

    is($ref, *{$ref}{IO}, "IO slot of the temporary glob is set correctly");
}
@


1.1.1.10
log
@import perl 5.10.1
@
text
@d11 1
a11 1
plan(189);
d57 5
d134 3
a136 43
sub PVBM () { 'foo' }
{ my $dummy = index 'foo', PVBM }

my $pviv = 1; "$pviv";
my $pvnv = 1.0; "$pvnv";
my $x;

# we don't test
#   tied lvalue => SCALAR, as we haven't tested tie yet
#   BIND, 'cos we can't create them yet
#   REGEXP, 'cos that requires overload or Scalar::Util
#   LVALUE ref, 'cos I can't work out how to create one :)

for (
    [ 'undef',          SCALAR  => \undef               ],
    [ 'constant IV',    SCALAR  => \1                   ],
    [ 'constant NV',    SCALAR  => \1.0                 ],
    [ 'constant PV',    SCALAR  => \'f'                 ],
    [ 'scalar',         SCALAR  => \$x                  ],
    [ 'PVIV',           SCALAR  => \$pviv               ],
    [ 'PVNV',           SCALAR  => \$pvnv               ],
    [ 'PVMG',           SCALAR  => \$0                  ],
    [ 'PVBM',           SCALAR  => \PVBM                ],
    [ 'vstring',        VSTRING => \v1                  ],
    [ 'ref',            REF     => \\1                  ],
    [ 'lvalue',         LVALUE  => \substr($x, 0, 0)    ],
    [ 'named array',    ARRAY   => \@@ary                ],
    [ 'anon array',     ARRAY   => [ 1 ]                ],
    [ 'named hash',     HASH    => \%whatever           ],
    [ 'anon hash',      HASH    => { a => 1 }           ],
    [ 'named sub',      CODE    => \&mysub,             ],
    [ 'anon sub',       CODE    => sub { 1; }           ],
    [ 'glob',           GLOB    => \*foo                ],
    [ 'format',         FORMAT  => *STDERR{FORMAT}      ],
) {
    my ($desc, $type, $ref) = @@$_;
    is (ref $ref, $type, "ref() for ref to $desc");
    like ("$ref", qr/^$type\(0x[0-9a-f]+\)$/, "stringify for ref to $desc");
}

is (ref *STDOUT{IO}, 'IO::Handle', 'IO refs are blessed into IO::Handle');
like (*STDOUT{IO}, qr/^IO::Handle=IO\(0x[0-9a-f]+\)$/,
    'stringify for IO refs');
a537 26

# these will segfault if they fail

my $pvbm = PVBM;
my $rpvbm = \$pvbm;

ok (!eval { *$rpvbm }, 'PVBM ref is not a GLOB ref');
ok (!eval { *$pvbm }, 'PVBM is not a GLOB ref');
ok (!eval { $$pvbm }, 'PVBM is not a SCALAR ref');
ok (!eval { @@$pvbm }, 'PVBM is not an ARRAY ref');
ok (!eval { %$pvbm }, 'PVBM is not a HASH ref');
ok (!eval { $pvbm->() }, 'PVBM is not a CODE ref');
ok (!eval { $rpvbm->foo }, 'PVBM is not an object');

# bug 24254
is( runperl(stderr => 1, prog => 'map eval qq(exit),1 for 1'), "");
is( runperl(stderr => 1, prog => 'eval { for (1) { map { die } 2 } };'), "");
is( runperl(stderr => 1, prog => 'for (125) { map { exit } (213)}'), "");
my $hushed = $^O eq 'VMS' ? 'use vmsish qw(hushed);' : '';
is( runperl(stderr => 1, prog => $hushed . 'map die,4 for 3'), "Died at -e line 1.\n");
is( runperl(stderr => 1, prog => $hushed . 'grep die,4 for 3'), "Died at -e line 1.\n");
is( runperl(stderr => 1, prog => $hushed . 'for $a (3) {@@b=sort {die} 4,5}'), "Died at -e line 1.\n");

# bug 57564
is( runperl(stderr => 1, prog => 'my $i;for $i (1) { for $i (2) { } }'), "");

@


1.1.1.11
log
@Perl 5.12.2 from CPAN
@
text
@a9 1
use re ();
d11 1
a11 1
plan(196);
a126 26
# Test REGEXP assignment

{
    my $x = qr/x/;
    my $str = "$x"; # regex stringification may change

    my $y = $$x;
    is ($y, $str, "bare REGEXP stringifies correctly");
    ok (eval { "x" =~ $y }, "bare REGEXP matches correctly");
    
    my $z = \$y;
    ok (re::is_regexp($z), "new ref to REXEXP passes is_regexp");
    is ($z, $str, "new ref to REGEXP stringifies correctly");
    ok (eval { "x" =~ $z }, "new ref to REGEXP matches correctly");
}
{
    my ($x, $str);
    {
        my $y = qr/x/;
        $str = "$y";
        $x = $$y;
    }
    is ($x, $str, "REGEXP keeps a ref to its mother_re");
    ok (eval { "x" =~ $x }, "REGEXP with mother_re still matches");
}

d169 2
a170 2
is (ref *STDOUT{IO}, 'IO::File', 'IO refs are blessed into IO::File');
like (*STDOUT{IO}, qr/^IO::File=IO\(0x[0-9a-f]+\)$/,
d416 4
a419 7
TODO: {
    local $TODO = "works but output through pipe is mangled" if $^O eq 'VMS';
    like (runperl(
        prog => '$x=bless[]; sub IO::Handle::DESTROY{$_="bad";s/bad/ok/;print}',
        stderr => 1
          ), qr/^(ok)+$/, 'STDOUT destructor');
}
@


1.1.1.12
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@a5 1
    require 'test.pl';
d8 1
d10 1
d12 1
a12 1
plan(228);
a123 9
# Test references to return values of operators (TARGs/PADTMPs)
{
    my @@refs;
    for("a", "b") {
        push @@refs, \"$_"
    }
    is join(" ", map $$_, @@refs), "a b", 'refgen+PADTMP';
}

d130 1
a130 3
SKIP: {
    skip_if_miniperl("no dynamic loading on miniperl, so can't load re", 5);
    require re;
d167 1
a178 2
    [ 'scalar @@array',  SCALAR  => \scalar @@array       ],
    [ 'scalar %hash',   SCALAR  => \scalar %hash        ],
d181 1
a181 3
    [ 'substr lvalue',  LVALUE  => \substr($x, 0, 0)    ],
    [ 'pos lvalue',     LVALUE  => \pos                 ],
    [ 'vec lvalue',     LVALUE  => \vec($x,0,1)         ],     
a199 9
{ # Test re-use of ref's TARG [perl #101738]
  my $obj = bless [], '____';
  my $uniobj = bless [], chr 256;
  my $get_ref = sub { ref shift };
  my $dummy = &$get_ref($uniobj);
     $dummy = &$get_ref($obj);
  ok exists { ____ => undef }->{$dummy}, 'ref sets UTF8 flag correctly';
}

a369 19
# test that DESTROY is called on all objects during global destruction,
# even those without hard references [perl #36347]

is(
  runperl(
   stderr => 1, prog => 'sub DESTROY { print qq-aaa\n- } bless \$a[0]'
  ),
 "aaa\n", 'DESTROY called on array elem'
);
is(
  runperl(
   stderr => 1,
   prog => '{ bless \my@@x; *a=sub{@@x}}sub DESTROY { print qq-aaa\n- }'
  ),
 "aaa\n",
 'DESTROY called on closure variable'
);


d435 1
a435 1
    prog => 'use Symbol;my $x=bless \gensym,q{t}; print;*$$x=$x',
d446 1
a446 1
        prog => '$x=bless[]; sub IO::Handle::DESTROY{$_=q{bad};s/bad/ok/;print}',
d451 1
a451 1
{
d461 1
d465 1
a465 1
{
d477 1
a628 113
# The mechanism for freeing objects in globs used to leave dangling
# pointers to freed SVs. To test this, we construct this nested structure:
#    GV => blessed(AV) => RV => GV => blessed(SV)
# all with a refcnt of 1, and hope that the second GV gets processed first
# by do_clean_named_objs.  Then when the first GV is processed, it mustn't
# find anything nasty left by the previous GV processing.
# The eval is stop things in the main body of the code holding a reference
# to a GV, and the print at the end seems to bee necessary to ensure
# the correct freeing order of *x and *y (no, I don't know why - DAPM).

is (runperl(
	prog => 'eval q[bless \@@y; bless \$x; $y[0] = \*x; $z = \*y; ]; '
		. 'delete $::{x}; delete $::{y}; print qq{ok\n};',
	stderr => 1),
    "ok\n", 'freeing freed glob in global destruction');


# Test undefined hash references as arguments to %{} in boolean context
# [perl #81750]
{
 no strict 'refs';
 eval { my $foo; %$foo;             }; ok !$@@, '%$undef';
 eval { my $foo; scalar %$foo;      }; ok !$@@, 'scalar %$undef';
 eval { my $foo; !%$foo;            }; ok !$@@, '!%$undef';
 eval { my $foo; if ( %$foo) {}     }; ok !$@@, 'if ( %$undef) {}';
 eval { my $foo; if (!%$foo) {}     }; ok !$@@, 'if (!%$undef) {}';
 eval { my $foo; unless ( %$foo) {} }; ok !$@@, 'unless ( %$undef) {}';
 eval { my $foo; unless (!%$foo) {} }; ok !$@@, 'unless (!%$undef) {}';
 eval { my $foo; 1 if %$foo;        }; ok !$@@, '1 if %$undef';
 eval { my $foo; 1 if !%$foo;       }; ok !$@@, '1 if !%$undef';
 eval { my $foo; 1 unless %$foo;    }; ok !$@@, '1 unless %$undef;';
 eval { my $foo; 1 unless ! %$foo;  }; ok !$@@, '1 unless ! %$undef';
 eval { my $foo;  %$foo ? 1 : 0;    }; ok !$@@, ' %$undef ? 1 : 0';
 eval { my $foo; !%$foo ? 1 : 0;    }; ok !$@@, '!%$undef ? 1 : 0';
}

# RT #88330
# Make sure that a leaked thinggy with multiple weak references to
# it doesn't trigger a panic with multiple rounds of global cleanup
# (Perl_sv_clean_all).

SKIP: {
    skip_if_miniperl('no Scalar::Util under miniperl', 4);

    local $ENV{PERL_DESTRUCT_LEVEL} = 2;

    # we do all permutations of array/hash, 1ref/2ref, to account
    # for the different way backref magic is stored

    fresh_perl_is(<<'EOF', 'ok', { stderr => 1 }, 'array with 1 weak ref');
use Scalar::Util qw(weaken);
my $r = [];
Internals::SvREFCNT(@@$r, 9);
my $r1 = $r;
weaken($r1);
print "ok";
EOF

    fresh_perl_is(<<'EOF', 'ok', { stderr => 1 }, 'array with 2 weak refs');
use Scalar::Util qw(weaken);
my $r = [];
Internals::SvREFCNT(@@$r, 9);
my $r1 = $r;
weaken($r1);
my $r2 = $r;
weaken($r2);
print "ok";
EOF

    fresh_perl_is(<<'EOF', 'ok', { stderr => 1 }, 'hash with 1 weak ref');
use Scalar::Util qw(weaken);
my $r = {};
Internals::SvREFCNT(%$r, 9);
my $r1 = $r;
weaken($r1);
print "ok";
EOF

    fresh_perl_is(<<'EOF', 'ok', { stderr => 1 }, 'hash with 2 weak refs');
use Scalar::Util qw(weaken);
my $r = {};
Internals::SvREFCNT(%$r, 9);
my $r1 = $r;
weaken($r1);
my $r2 = $r;
weaken($r2);
print "ok";
EOF

}

SKIP:{
    skip_if_miniperl "no Scalar::Util on miniperl", 1;
    my $error;
    *hassgropper::DESTROY = sub {
        require Scalar::Util;
        eval { Scalar::Util::weaken($_[0]) };
        $error = $@@;
        # This line caused a crash before weaken refused to weaken a
        # read-only reference:
        $do::not::overwrite::this = $_[0];
    };
    my $xs = bless [], "hassgropper";
    undef $xs;
    like $error, qr/^Modification of a read-only/,
       'weaken refuses to weaken a read-only ref';
    # Now that the test has passed, avoid sabotaging global destruction:
    undef *hassgropper::DESTROY;
    undef $do::not::overwrite::this;
}


is ref( bless {}, "nul\0clean" ), "nul\0clean", "ref() is nul-clean";
@


1.1.1.13
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d11 1
a11 1
plan(230);
a121 1
is ref eval {\&{""}}, "CODE", 'reference to &{""} [perl #94476]';
a408 7

# But cursing objects must not result in double frees
# This caused "Attempt to free unreferenced scalar" in 5.16.
fresh_perl_is(
  'bless \%foo::, bar::; bless \%bar::, foo::; print "ok\n"', "ok\n",
   { stderr => 1 },
  'no double free when stashes are blessed into each other');
@


1.1.1.14
log
@Import perl-5.20.1
@
text
@d11 1
a11 1
plan(235);
a788 25

# Test constants and references thereto.
for (3) {
    eval { $_ = 4 };
    like $@@, qr/^Modification of a read-only/,
       'assignment to value aliased to literal number';
    require Config;
    eval { ${\$_} = 4 };
    like $@@, qr/^Modification of a read-only/,
       'refgen does not allow assignment to value aliased to literal number';
}
for ("4eounthouonth") {
    eval { $_ = 4 };
    like $@@, qr/^Modification of a read-only/,
       'assignment to value aliased to literal string';
    require Config;
    eval { ${\$_} = 4 };
    like $@@, qr/^Modification of a read-only/,
       'refgen does not allow assignment to value aliased to literal string';
}
{
    my $aref = \123;
    is \$$aref, $aref,
	'[perl #109746] referential identity of \literal under threads+mad'
}
@


1.1.1.15
log
@Import perl-5.24.2
@
text
@d6 1
a6 1
    require './test.pl';
a12 4
# Test this first before we extend the stack with other operations.
# This caused an asan failure due to a bad write past the end of the stack.
eval { die  1..127, $_=\() };

d83 1
a83 1
# Test nested anonymous arrays.
a321 1
# (That’s what *you* think!  --sprout)
d323 1
a323 2
like ($@@, qr/Can\'t modify.*ref.*in.*assignment(?x:
           )|Experimental aliasing via reference not enabled/);
d620 1
a620 1
    like ( "$@@", qr/Can't use an undefined value as a HASH reference/,
d795 1
d804 1
@


