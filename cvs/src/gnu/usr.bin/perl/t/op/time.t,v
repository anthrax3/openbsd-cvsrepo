head	1.15;
access;
symbols
	OPENBSD_6_0:1.14.0.8
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.14.0.2
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.14.0.4
	OPENBSD_5_8_BASE:1.14
	PERL_5_20_2:1.1.1.12
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	PERL_5_20_1:1.1.1.11
	OPENBSD_5_6:1.12.0.8
	OPENBSD_5_6_BASE:1.12
	PERL_5_18_2:1.1.1.10
	PERL:1.1.1
	OPENBSD_5_5:1.12.0.6
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.2
	OPENBSD_5_4_BASE:1.12
	PERL_5_16_3:1.1.1.10
	OPENBSD_5_3:1.11.0.10
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.8
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.6
	OPENBSD_5_0:1.11.0.4
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.2
	OPENBSD_4_9_BASE:1.11
	PERL_5_12_2:1.1.1.9
	OPENBSD_4_8:1.10.0.8
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.4
	OPENBSD_4_7_BASE:1.10
	PERL_5_10_1:1.1.1.8
	OPENBSD_4_6:1.10.0.6
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.2
	OPENBSD_4_5_BASE:1.10
	PERL_5_10_0:1.1.1.8
	OPENBSD_4_4:1.9.0.10
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.8
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.6
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.4
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9
	PERL_5_8_8:1.1.1.7
	OPENBSD_3_9:1.8.0.10
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.8
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.6
	OPENBSD_3_7_BASE:1.8
	PERL_5_8_6:1.1.1.6
	OPENBSD_3_6:1.8.0.4
	OPENBSD_3_6_BASE:1.8
	PERL_5_8_5:1.1.1.5
	PERL_5_8_3:1.1.1.4
	OPENBSD_3_5:1.8.0.2
	OPENBSD_3_5_BASE:1.8
	PERL_5_8_2:1.1.1.4
	OPENBSD_3_4:1.7.0.4
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.7.0.2
	OPENBSD_3_3_BASE:1.7
	PERL_5_8_0:1.1.1.3
	OPENBSD_3_2:1.6.0.6
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.4
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	PERL_5_6_1:1.1.1.2
	OPENBSD_2_9:1.5.0.6
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.4
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.2
	OPENBSD_2_7_BASE:1.5
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.4.0.2
	OPENBSD_2_6_BASE:1.4
	PERL_500503:1.1.1.1
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.15
date	2017.02.05.00.32.20;	author afresh1;	state Exp;
branches;
next	1.14;
commitid	cxJ08BvJA9Pt2PTM;

1.14
date	2015.04.25.19.14.48;	author afresh1;	state Exp;
branches;
next	1.13;
commitid	XRK22kO4se3v2i2I;

1.13
date	2014.11.17.20.57.07;	author afresh1;	state Exp;
branches;
next	1.12;
commitid	QP75iYx42Uo7mMxO;

1.12
date	2013.03.25.20.41.00;	author sthen;	state Exp;
branches;
next	1.11;

1.11
date	2010.09.24.15.07.09;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2008.09.29.17.36.20;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2006.03.28.19.23.13;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2003.12.03.03.02.49;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.10.27.22.25.37;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.05.24.18.36.23;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2000.04.06.17.08.34;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	99.04.30.18.23.14;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.52.39;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.08.05.47;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.13.23;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.13.23;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.04.06.16.10.52;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.10.27.22.15.11;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.12.03.02.44.33;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.08.09.17.48.36;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2005.01.15.21.18.20;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2006.03.28.18.49.47;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2008.09.29.17.19.02;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2010.09.24.14.49.17;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2013.03.25.20.09.37;	author sthen;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2014.11.17.20.53.18;	author afresh1;	state Exp;
branches;
next	1.1.1.12;
commitid	B31cAbBIXiCqnL97;

1.1.1.12
date	2015.04.25.19.10.48;	author afresh1;	state Exp;
branches;
next	;
commitid	Wpcs5S8qILgEZC7F;


desc
@@


1.15
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl -w

BEGIN {
    chdir 't' if -d 't';
    @@INC = '../lib';
    require './test.pl';
}

plan tests => 72;

# These tests make sure, among other things, that we don't end up
# burning tons of CPU for dates far in the future.
# watchdog() makes sure that the test script eventually exits if
# the tests are triggering the failing behavior
watchdog(25);

($beguser,$begsys) = times;

$beg = time;

while (($now = time) == $beg) { sleep 1 }

ok($now > $beg && $now - $beg < 10,             'very basic time test');
my $x = "aaaa";
for ($i = 0; $i < 1_000_000; $i++) {
    for my $j (1..1000) { ++$x; }; # burn some user cycles
    ($nowuser, $nowsys) = times;
    $i = 2_000_000 if $nowuser > $beguser && ( $nowsys >= $begsys ||
                                            (!$nowsys && !$begsys));
    last if time - $beg > 20;
}

ok($i >= 2_000_000, 'very basic times test');

($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime($beg);
($xsec,$foo) = localtime($now);
$localyday = $yday;

isnt($sec, $xsec,      'localtime() list context');
ok $mday,              '  month day';
ok $year,              '  year';

ok(localtime() =~ /^(Sun|Mon|Tue|Wed|Thu|Fri|Sat)[ ]
                    (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[ ]
                    ([ \d]\d)\ (\d\d):(\d\d):(\d\d)\ (\d{4})$
                  /x,
   'localtime(), scalar context'
  );

SKIP: {
    # This conditional of "No tzset()" is stolen from ext/POSIX/t/time.t
    skip "No tzset()", 1
        if $^O eq "VMS" || $^O eq "cygwin" ||
           $^O eq "djgpp" || $^O eq "MSWin32" || $^O eq "dos" ||
           $^O eq "interix";

# check that localtime respects changes to $ENV{TZ}
$ENV{TZ} = "GMT-5";
($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime($beg);
$ENV{TZ} = "GMT+5";
($sec,$min,$hour2,$mday,$mon,$year,$wday,$yday,$isdst) = localtime($beg);
ok($hour != $hour2,                             'changes to $ENV{TZ} respected');
}


($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = gmtime($beg);
($xsec,$foo) = localtime($now);

isnt($sec, $xsec,      'gmtime() list conext');
ok $mday,              '  month day';
ok $year,              '  year';

my $day_diff = $localyday - $yday;
ok( grep({ $day_diff == $_ } (0, 1, -1, 364, 365, -364, -365)),
                     'gmtime() and localtime() agree what day of year');


# This could be stricter.
ok(gmtime() =~ /^(Sun|Mon|Tue|Wed|Thu|Fri|Sat)[ ]
                 (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[ ]
                 ([ \d]\d)\ (\d\d):(\d\d):(\d\d)\ (\d{4})$
               /x,
   'gmtime(), scalar context'
  );



# Test gmtime over a range of times.
{
    # The range should be limited only by the 53-bit mantissa of an IEEE double (or 
    # whatever kind of double you've got).  Here we just prove that we're comfortably 
    # beyond the range possible with 32-bit time_t.
    my %tests = (
        # time_t         gmtime list                          scalar
        -2**35  => [52, 13, 20, 7, 2, -1019, 5, 65, 0, "Fri Mar  7 20:13:52 881"],
        -2**32  => [44, 31, 17, 24, 10, -67, 0, 327, 0, "Sun Nov 24 17:31:44 1833"],
        -2**31  => [52, 45, 20, 13, 11, 1, 5, 346, 0, "Fri Dec 13 20:45:52 1901"],
        -1      => [59, 59, 23, 31, 11, 69, 3, 364, 0, "Wed Dec 31 23:59:59 1969"],
        0       => [0, 0, 0, 1, 0, 70, 4, 0, 0, "Thu Jan  1 00:00:00 1970"],
        1       => [1, 0, 0, 1, 0, 70, 4, 0, 0, "Thu Jan  1 00:00:01 1970"],
        2**30   => [4, 37, 13, 10, 0, 104, 6, 9, 0, "Sat Jan 10 13:37:04 2004"],
        2**31   => [8, 14, 3, 19, 0, 138, 2, 18, 0, "Tue Jan 19 03:14:08 2038"],
        2**32   => [16, 28, 6, 7, 1, 206, 0, 37, 0, "Sun Feb  7 06:28:16 2106"],
        2**39   => [8, 18, 12, 25, 0, 17491, 2, 24, 0, "Tue Jan 25 12:18:08 19391"],
    );

    for my $time (keys %tests) {
        my @@expected  = @@{$tests{$time}};
        my $scalar    = pop @@expected;

        ok eq_array([gmtime($time)], \@@expected),  "gmtime($time) list context";
        is scalar gmtime($time), $scalar,       "  scalar";
    }
}


# Test localtime
{
    # We pick times which fall in the middle of a month, so the month and year should be
    # the same regardless of the time zone.
    my %tests = (
        # time_t           month, year,  scalar
        -8589934592     => [9,    -203,                 qr/Oct \d+ .* 1697$/],
        -1296000        => [11,   69,                   qr/Dec \d+ .* 1969$/],
        1296000         => [0,    70,                   qr/Jan \d+ .* 1970$/],
        5000000000      => [5,    228,                  qr/Jun \d+ .* 2128$/],
        1163500000      => [10,   106,                  qr/Nov \d+ .* 2006$/],
    );

    for my $time (keys %tests) {
        my @@expected  = @@{$tests{$time}};
        my $scalar    = pop @@expected;

        my @@time = (localtime($time))[4,5];
        ok( eq_array(\@@time, \@@expected),  "localtime($time) list context" )
          or diag("@@time");
        like scalar localtime($time), $scalar,       "  scalar";
    }
}

# Test floating point args
{
    warning_is(sub {is( (localtime(1296000.23))[5] + 1900, 1970 )},
	       undef, 'Ignore fractional time');
    warning_is(sub {is( (gmtime(1.23))[5] + 1900, 1970 )},
	       undef, 'Ignore fractional time');
}


# Some sanity tests for the far, far future and far, far past
{
    my %time2year = (
        -2**52  => -142711421,
        -2**48  => -8917617,
        -2**46  => -2227927,
         2**46  => 2231866,
         2**48  => 8921556,
         2**52  => 142715360,
    );

    for my $time (sort keys %time2year) {
        my $want = $time2year{$time};

        my $have = (gmtime($time))[5] + 1900;
        is $have, $want, "year check, gmtime($time)";

        $have = (localtime($time))[5] + 1900;
        is $have, $want, "year check, localtime($time)";
    }
}


# Test that Perl warns properly when it can't handle a time.
{
    my $warning;
    local $SIG{__WARN__} = sub { $warning .= join "\n", @@_; };

    my $big_time   = 2**60;
    my $small_time = -2**60;

    $warning = '';
    my $date = gmtime($big_time);
    like $warning, qr/^gmtime(.*) too large/;

    $warning = '';
    $date = localtime($big_time);
    like $warning, qr/^localtime(.*) too large/;

    $warning = '';
    $date = gmtime($small_time);
    like $warning, qr/^gmtime(.*) too small/;

    $warning = '';
    $date = localtime($small_time);
    like $warning, qr/^localtime(.*) too small/;
}

SKIP: { #rt #73040
    # these are from the definitions of TIME_LOWER_BOUND AND TIME_UPPER_BOUND
    my $smallest = -67768100567755200.0;
    my $biggest = 67767976233316800.0;

    # offset to a value that will fail
    my $small_time = $smallest - 200;
    my $big_time = $biggest + 200;

    # check they're representable - typically means NV is
    # long double
    if ($small_time + 200 != $smallest
	|| $small_time == $smallest
        || $big_time - 200 != $biggest
	|| $big_time == $biggest) {
	skip "Can't represent test values", 8;
    }
    my $small_time_f = sprintf("%.0f", $small_time);
    my $big_time_f = sprintf("%.0f", $big_time);

    # check the numbers in the warning are correct
    my $warning;
    local $SIG{__WARN__} = sub { $warning .= join "\n", @@_; };
    $warning = '';
    my $date = gmtime($big_time);
    like $warning, qr/^gmtime\($big_time_f\) too large/;
    like $warning, qr/^gmtime\($big_time_f\) failed/m;

    $warning = '';
    $date = localtime($big_time);
    like $warning, qr/^localtime\($big_time_f\) too large/;
    like $warning, qr/^localtime\($big_time_f\) failed/m;

    $warning = '';
    $date = gmtime($small_time);
    like $warning, qr/^gmtime\($small_time_f\) too small/;
    like $warning, qr/^gmtime\($small_time_f\) failed/m;

    $warning = '';
    $date = localtime($small_time);
    like $warning, qr/^localtime\($small_time_f\) too small/;
    like $warning, qr/^localtime\($small_time_f\) failed/m;
}

{
    local $^W;
    is scalar gmtime("NaN"), undef, '[perl #123495] gmtime(NaN)';
    is scalar localtime("NaN"), undef, 'localtime(NaN)';
}
@


1.14
log
@Fix merge issues, remove excess files - match perl-5.20.2 dist
@
text
@d15 1
a15 1
watchdog(15);
d24 1
a24 1

d26 1
a26 1
    for my $j (1..100) {}; # burn some user cycles
d244 2
a245 4
    scalar gmtime("NaN");
    pass('[perl #123495] gmtime(NaN) does not crash');
    scalar localtime("NaN");
    pass('localtime(NaN) does not crash');
@


1.13
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d9 1
a9 1
plan tests => 70;
d240 8
@


1.12
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d9 1
a9 1
plan tests => 66;
d213 1
a213 1
	skip "Can't represent test values", 4;
d224 1
d229 1
d234 1
d239 1
a239 1
  
@


1.11
log
@merge in perl 5.12.2 plus local changes
@
text
@d9 1
a9 1
plan tests => 62;
d143 4
a146 10
    eval {
        $SIG{__WARN__} = sub { die @@_; };
        is( (localtime(1296000.23))[5] + 1900, 1970 );
    };
    is($@@, '', 'Ignore fractional time');
    eval {
        $SIG{__WARN__} = sub { die @@_; };
        is( (gmtime(1.23))[5] + 1900, 1970 );
    };
    is($@@, '', 'Ignore fractional time');
d196 41
@


1.10
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d1 1
a1 3
#!./perl

$does_gmtime = gmtime(time);
d9 7
a15 1
plan tests => 8;
d39 3
a41 1
ok($sec != $xsec && $mday && $year,             'localtime() list context');
d53 1
a53 1
        if $^O eq "MacOS" || $^O eq "VMS" || $^O eq "cygwin" ||
a64 2
SKIP: {
    skip "No gmtime()", 3 unless $does_gmtime;
d69 3
a71 1
ok($sec != $xsec && $mday && $year,             'gmtime() list context');
d85 117
@


1.9
log
@merge in perl 5.8.8
@
text
@d3 1
a3 1
# $RCSfile: time.t,v $$Revision: 1.8 $$Date: 2003/12/03 03:02:49 $
d5 4
a8 19
if ( $does_gmtime = gmtime(time) ) { 
    print "1..7\n" 
}
else { 
    print "1..4\n" 
}


my $test = 1;
sub ok ($$) {
    my($ok, $name) = @@_;

    # You have to do it this way or VMS will get confused.
    print $ok ? "ok $test - $name\n" : "not ok $test - $name\n";

    printf "# Failed test at line %d\n", (caller)[2] unless $ok;

    $test++;
    return $ok;
d11 1
d22 1
d44 17
a60 1
exit 0 unless $does_gmtime;
d79 1
@


1.8
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d3 1
a3 1
# $RCSfile: time.t,v $$Revision: 4.1 $$Date: 92/08/07 18:28:32 $
d35 1
a35 1
for ($i = 0; $i < 100000; $i++) {
d37 1
a37 1
    $i = 200000 if $nowuser > $beguser && ( $nowsys >= $begsys || 
d42 1
a42 1
ok($i >= 200000,                                'very basic times test');
@


1.7
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d37 1
a37 1
    $i = 200000 if $nowuser > $beguser && ( $nowsys > $begsys || 
@


1.6
log
@merge in perl 5.6.1 with our local changes
@
text
@d5 21
a25 2
if ($does_gmtime = gmtime(time)) { print "1..6\n" }
else { print "1..3\n" }
d33 1
a33 1
if ($now > $beg && $now - $beg < 10){print "ok 1\n";} else {print "not ok 1\n";}
d42 1
a42 1
if ($i >= 200000) {print "ok 2\n";} else {print "not ok 2\n";}
d48 8
a55 4
if ($sec != $xsec && $mday && $year)
    {print "ok 3\n";}
else
    {print "not ok 3\n";}
d62 6
a67 9
if ($sec != $xsec && $mday && $year)
    {print "ok 4\n";}
else
    {print "not ok 4\n";}

if (index(" :0:1:-1:364:365:-364:-365:",':' . ($localyday - $yday) . ':') > 0)
    {print "ok 5\n";}
else
    {print "not ok 5\n";}
d70 6
a75 4
if (gmtime() =~ /^(Sun|Mon|Tue|Wed|Thu|Fri|Sat) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ([ \d]\d) (\d\d):(\d\d):(\d\d) (\d\d\d\d)$/)
    {print "ok 6\n";}
else
    {print "not ok 6\n";}
@


1.5
log
@perl-5.6.0 + local changes
@
text
@@


1.4
log
@Crank the for loop max index so test #2 succeeds on fast machines.  Total test running time is still limited to 10sec.  I still think this is a bogus test though.
@
text
@d3 1
a3 1
# $RCSfile: time.t,v $$Revision: 1.3 $$Date: 1999/04/29 22:52:39 $
d5 1
a5 1
if ($does_gmtime = gmtime(time)) { print "1..5\n" }
d16 1
a16 1
for ($i = 0; $i < 10000000; $i++) {
d18 1
a18 1
    $i = 20000000 if $nowuser > $beguser && ( $nowsys > $begsys || 
d23 1
a23 1
if ($i >= 20000000) {print "ok 2\n";} else {print "not ok 2\n";}
d48 6
@


1.3
log
@perl5.005_03 (stock)
@
text
@d3 1
a3 1
# $RCSfile: time.t,v $$Revision: 4.1 $$Date: 92/08/07 18:28:32 $
d16 1
a16 1
for ($i = 0; $i < 100000; $i++) {
d18 1
a18 1
    $i = 200000 if $nowuser > $beguser && ( $nowsys > $begsys || 
d23 1
a23 1
if ($i >= 200000) {print "ok 2\n";} else {print "not ok 2\n";}
@


1.2
log
@perl 5.004_04
@
text
@@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@virgin perl 5.6.0
@
text
@d5 1
a5 1
if ($does_gmtime = gmtime(time)) { print "1..6\n" }
a47 6

# This could be stricter.
if (gmtime() =~ /^(Sun|Mon|Tue|Wed|Thu|Fri|Sat) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ([ \d]\d) (\d\d):(\d\d):(\d\d) (\d\d\d\d)$/)
    {print "ok 6\n";}
else
    {print "not ok 6\n";}
@


1.1.1.3
log
@stock perl 5.8.0 from CPAN
@
text
@d5 2
a6 21
if ( $does_gmtime = gmtime(time) ) { 
    print "1..7\n" 
}
else { 
    print "1..4\n" 
}


my $test = 1;
sub ok ($$) {
    my($ok, $name) = @@_;

    # You have to do it this way or VMS will get confused.
    print $ok ? "ok $test - $name\n" : "not ok $test - $name\n";

    printf "# Failed test at line %d\n", (caller)[2] unless $ok;

    $test++;
    return $ok;
}

d14 1
a14 1
ok($now > $beg && $now - $beg < 10,             'very basic time test');
d23 1
a23 1
ok($i >= 200000,                                'very basic times test');
d29 4
a32 8
ok($sec != $xsec && $mday && $year,             'localtime() list context');

ok(localtime() =~ /^(Sun|Mon|Tue|Wed|Thu|Fri|Sat)[ ]
                    (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[ ]
                    ([ \d]\d)\ (\d\d):(\d\d):(\d\d)\ (\d{4})$
                  /x,
   'localtime(), scalar context'
  );
d39 9
a47 6
ok($sec != $xsec && $mday && $year,             'gmtime() list context');

my $day_diff = $localyday - $yday;
ok( grep({ $day_diff == $_ } (0, 1, -1, 364, 365, -364, -365)),
                     'gmtime() and localtime() agree what day of year');

d50 4
a53 6
ok(gmtime() =~ /^(Sun|Mon|Tue|Wed|Thu|Fri|Sat)[ ]
                 (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[ ]
                 ([ \d]\d)\ (\d\d):(\d\d):(\d\d)\ (\d{4})$
               /x,
   'gmtime(), scalar context'
  );
@


1.1.1.4
log
@perl 5.8.2 from CPAN
@
text
@d37 1
a37 1
    $i = 200000 if $nowuser > $beguser && ( $nowsys >= $begsys || 
@


1.1.1.5
log
@Import of stock perl 5.8.5
@
text
@d3 1
a3 1
# $RCSfile: time.t,v $$Revision: 1.8 $$Date: 2003/12/03 03:02:49 $
@


1.1.1.6
log
@perl 5.8.6 from CPAN
@
text
@d3 1
a3 1
# $RCSfile: time.t,v $$Revision: 4.1 $$Date: 92/08/07 18:28:32 $
@


1.1.1.7
log
@perl 5.8.8 import
@
text
@d35 1
a35 1
for ($i = 0; $i < 1_000_000; $i++) {
d37 1
a37 1
    $i = 2_000_000 if $nowuser > $beguser && ( $nowsys >= $begsys ||
d42 1
a42 1
ok($i >= 2_000_000, 'very basic times test');
@


1.1.1.8
log
@import perl 5.10.0 from CPAN
@
text
@d3 1
a3 1
$does_gmtime = gmtime(time);
d5 19
a23 4
BEGIN {
    chdir 't' if -d 't';
    @@INC = '../lib';
    require './test.pl';
a25 1
plan tests => 8;
a35 1
    for my $j (1..100) {}; # burn some user cycles
d57 1
a57 17
SKIP: {
    # This conditional of "No tzset()" is stolen from ext/POSIX/t/time.t
    skip "No tzset()", 1
        if $^O eq "MacOS" || $^O eq "VMS" || $^O eq "cygwin" ||
           $^O eq "djgpp" || $^O eq "MSWin32" || $^O eq "dos" ||
           $^O eq "interix";

# check that localtime respects changes to $ENV{TZ}
$ENV{TZ} = "GMT-5";
($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime($beg);
$ENV{TZ} = "GMT+5";
($sec,$min,$hour2,$mday,$mon,$year,$wday,$yday,$isdst) = localtime($beg);
ok($hour != $hour2,                             'changes to $ENV{TZ} respected');
}

SKIP: {
    skip "No gmtime()", 3 unless $does_gmtime;
a75 1
}
@


1.1.1.9
log
@Perl 5.12.2 from CPAN
@
text
@d1 3
a3 1
#!./perl -w
d11 1
a11 7
plan tests => 62;

# These tests make sure, among other things, that we don't end up
# burning tons of CPU for dates far in the future.
# watchdog() makes sure that the test script eventually exits if
# the tests are triggering the failing behavior
watchdog(15);
d35 1
a35 3
isnt($sec, $xsec,      'localtime() list context');
ok $mday,              '  month day';
ok $year,              '  year';
d47 1
a47 1
        if $^O eq "VMS" || $^O eq "cygwin" ||
d59 2
d65 1
a65 3
isnt($sec, $xsec,      'gmtime() list conext');
ok $mday,              '  month day';
ok $year,              '  year';
a78 117



# Test gmtime over a range of times.
{
    # The range should be limited only by the 53-bit mantissa of an IEEE double (or 
    # whatever kind of double you've got).  Here we just prove that we're comfortably 
    # beyond the range possible with 32-bit time_t.
    my %tests = (
        # time_t         gmtime list                          scalar
        -2**35  => [52, 13, 20, 7, 2, -1019, 5, 65, 0, "Fri Mar  7 20:13:52 881"],
        -2**32  => [44, 31, 17, 24, 10, -67, 0, 327, 0, "Sun Nov 24 17:31:44 1833"],
        -2**31  => [52, 45, 20, 13, 11, 1, 5, 346, 0, "Fri Dec 13 20:45:52 1901"],
        -1      => [59, 59, 23, 31, 11, 69, 3, 364, 0, "Wed Dec 31 23:59:59 1969"],
        0       => [0, 0, 0, 1, 0, 70, 4, 0, 0, "Thu Jan  1 00:00:00 1970"],
        1       => [1, 0, 0, 1, 0, 70, 4, 0, 0, "Thu Jan  1 00:00:01 1970"],
        2**30   => [4, 37, 13, 10, 0, 104, 6, 9, 0, "Sat Jan 10 13:37:04 2004"],
        2**31   => [8, 14, 3, 19, 0, 138, 2, 18, 0, "Tue Jan 19 03:14:08 2038"],
        2**32   => [16, 28, 6, 7, 1, 206, 0, 37, 0, "Sun Feb  7 06:28:16 2106"],
        2**39   => [8, 18, 12, 25, 0, 17491, 2, 24, 0, "Tue Jan 25 12:18:08 19391"],
    );

    for my $time (keys %tests) {
        my @@expected  = @@{$tests{$time}};
        my $scalar    = pop @@expected;

        ok eq_array([gmtime($time)], \@@expected),  "gmtime($time) list context";
        is scalar gmtime($time), $scalar,       "  scalar";
    }
}


# Test localtime
{
    # We pick times which fall in the middle of a month, so the month and year should be
    # the same regardless of the time zone.
    my %tests = (
        # time_t           month, year,  scalar
        -8589934592     => [9,    -203,                 qr/Oct \d+ .* 1697$/],
        -1296000        => [11,   69,                   qr/Dec \d+ .* 1969$/],
        1296000         => [0,    70,                   qr/Jan \d+ .* 1970$/],
        5000000000      => [5,    228,                  qr/Jun \d+ .* 2128$/],
        1163500000      => [10,   106,                  qr/Nov \d+ .* 2006$/],
    );

    for my $time (keys %tests) {
        my @@expected  = @@{$tests{$time}};
        my $scalar    = pop @@expected;

        my @@time = (localtime($time))[4,5];
        ok( eq_array(\@@time, \@@expected),  "localtime($time) list context" )
          or diag("@@time");
        like scalar localtime($time), $scalar,       "  scalar";
    }
}

# Test floating point args
{
    eval {
        $SIG{__WARN__} = sub { die @@_; };
        is( (localtime(1296000.23))[5] + 1900, 1970 );
    };
    is($@@, '', 'Ignore fractional time');
    eval {
        $SIG{__WARN__} = sub { die @@_; };
        is( (gmtime(1.23))[5] + 1900, 1970 );
    };
    is($@@, '', 'Ignore fractional time');
}


# Some sanity tests for the far, far future and far, far past
{
    my %time2year = (
        -2**52  => -142711421,
        -2**48  => -8917617,
        -2**46  => -2227927,
         2**46  => 2231866,
         2**48  => 8921556,
         2**52  => 142715360,
    );

    for my $time (sort keys %time2year) {
        my $want = $time2year{$time};

        my $have = (gmtime($time))[5] + 1900;
        is $have, $want, "year check, gmtime($time)";

        $have = (localtime($time))[5] + 1900;
        is $have, $want, "year check, localtime($time)";
    }
}


# Test that Perl warns properly when it can't handle a time.
{
    my $warning;
    local $SIG{__WARN__} = sub { $warning .= join "\n", @@_; };

    my $big_time   = 2**60;
    my $small_time = -2**60;

    $warning = '';
    my $date = gmtime($big_time);
    like $warning, qr/^gmtime(.*) too large/;

    $warning = '';
    $date = localtime($big_time);
    like $warning, qr/^localtime(.*) too large/;

    $warning = '';
    $date = gmtime($small_time);
    like $warning, qr/^gmtime(.*) too small/;

    $warning = '';
    $date = localtime($small_time);
    like $warning, qr/^localtime(.*) too small/;
@


1.1.1.10
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d9 1
a9 1
plan tests => 66;
d143 10
a152 4
    warning_is(sub {is( (localtime(1296000.23))[5] + 1900, 1970 )},
	       undef, 'Ignore fractional time');
    warning_is(sub {is( (gmtime(1.23))[5] + 1900, 1970 )},
	       undef, 'Ignore fractional time');
a201 41
}

SKIP: { #rt #73040
    # these are from the definitions of TIME_LOWER_BOUND AND TIME_UPPER_BOUND
    my $smallest = -67768100567755200.0;
    my $biggest = 67767976233316800.0;

    # offset to a value that will fail
    my $small_time = $smallest - 200;
    my $big_time = $biggest + 200;

    # check they're representable - typically means NV is
    # long double
    if ($small_time + 200 != $smallest
	|| $small_time == $smallest
        || $big_time - 200 != $biggest
	|| $big_time == $biggest) {
	skip "Can't represent test values", 4;
    }
    my $small_time_f = sprintf("%.0f", $small_time);
    my $big_time_f = sprintf("%.0f", $big_time);

    # check the numbers in the warning are correct
    my $warning;
    local $SIG{__WARN__} = sub { $warning .= join "\n", @@_; };
    $warning = '';
    my $date = gmtime($big_time);
    like $warning, qr/^gmtime\($big_time_f\) too large/;

    $warning = '';
    $date = localtime($big_time);
    like $warning, qr/^localtime\($big_time_f\) too large/;

    $warning = '';
    $date = gmtime($small_time);
    like $warning, qr/^gmtime\($small_time_f\) too small/;

    $warning = '';
    $date = localtime($small_time);
    like $warning, qr/^localtime\($small_time_f\) too small/;
  
@


1.1.1.11
log
@Import perl-5.20.1
@
text
@d9 1
a9 1
plan tests => 70;
d213 1
a213 1
	skip "Can't represent test values", 8;
a223 1
    like $warning, qr/^gmtime\($big_time_f\) failed/m;
a227 1
    like $warning, qr/^localtime\($big_time_f\) failed/m;
a231 1
    like $warning, qr/^gmtime\($small_time_f\) failed/m;
d236 1
a236 1
    like $warning, qr/^localtime\($small_time_f\) failed/m;
@


1.1.1.12
log
@Import perl-5.20.2
@
text
@d9 1
a9 1
plan tests => 72;
a239 8
}

{
    local $^W;
    scalar gmtime("NaN");
    pass('[perl #123495] gmtime(NaN) does not crash');
    scalar localtime("NaN");
    pass('localtime(NaN) does not crash');
@


