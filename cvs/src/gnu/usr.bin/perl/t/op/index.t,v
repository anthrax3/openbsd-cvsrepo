head	1.14;
access;
symbols
	OPENBSD_6_1:1.14.0.2
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.13.0.10
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.4
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.13.0.6
	OPENBSD_5_8_BASE:1.13
	PERL_5_20_2:1.1.1.9
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	PERL_5_20_1:1.1.1.9
	OPENBSD_5_6:1.12.0.8
	OPENBSD_5_6_BASE:1.12
	PERL_5_18_2:1.1.1.8
	PERL:1.1.1
	OPENBSD_5_5:1.12.0.6
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.2
	OPENBSD_5_4_BASE:1.12
	PERL_5_16_3:1.1.1.8
	OPENBSD_5_3:1.11.0.10
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.8
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.6
	OPENBSD_5_0:1.11.0.4
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.2
	OPENBSD_4_9_BASE:1.11
	PERL_5_12_2:1.1.1.7
	OPENBSD_4_8:1.10.0.4
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.2
	OPENBSD_4_7_BASE:1.10
	PERL_5_10_1:1.1.1.6
	OPENBSD_4_6:1.9.0.6
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.2
	OPENBSD_4_5_BASE:1.9
	PERL_5_10_0:1.1.1.5
	OPENBSD_4_4:1.8.0.10
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.8
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.6
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.4
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.2
	OPENBSD_4_0_BASE:1.8
	PERL_5_8_8:1.1.1.4
	OPENBSD_3_9:1.7.0.10
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.8
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.6
	OPENBSD_3_7_BASE:1.7
	PERL_5_8_6:1.1.1.3
	OPENBSD_3_6:1.7.0.4
	OPENBSD_3_6_BASE:1.7
	PERL_5_8_5:1.1.1.3
	PERL_5_8_3:1.1.1.3
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.3
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.2
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.1
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.1
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.1
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.14
date	2017.02.05.00.32.20;	author afresh1;	state Exp;
branches;
next	1.13;
commitid	cxJ08BvJA9Pt2PTM;

1.13
date	2014.11.17.20.57.07;	author afresh1;	state Exp;
branches;
next	1.12;
commitid	QP75iYx42Uo7mMxO;

1.12
date	2013.03.25.20.40.59;	author sthen;	state Exp;
branches;
next	1.11;

1.11
date	2010.09.24.15.07.08;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2009.10.12.18.30.27;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2008.09.29.17.36.19;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2006.03.28.19.23.12;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.48;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.37;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.36.18;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.08.24;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.52.35;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.08.05.24;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.13.18;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.13.18;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.10.27.22.15.10;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.12.03.02.44.32;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2006.03.28.18.49.45;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2008.09.29.17.19.01;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2009.10.12.18.10.45;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2010.09.24.14.49.17;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2013.03.25.20.09.36;	author sthen;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2014.11.17.20.53.17;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.14
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl

BEGIN {
    chdir 't' if -d 't';
    require './test.pl';
    set_up_inc('../lib');
    require './charset_tools.pl';
}

use strict;
plan( tests => 122 );

run_tests() unless caller;

sub run_tests {

my $foo = 'Now is the time for all good men to come to the aid of their country.';

my $first = substr($foo,0,index($foo,'the'));
is($first, "Now is ");

my $last = substr($foo,rindex($foo,'the'),100);
is($last, "their country.");

$last = substr($foo,index($foo,'Now'),2);
is($last, "No");

$last = substr($foo,rindex($foo,'Now'),2);
is($last, "No");

$last = substr($foo,index($foo,'.'),100);
is($last, ".");

$last = substr($foo,rindex($foo,'.'),100);
is($last, ".");

is(index("ababa","a",-1), 0);
is(index("ababa","a",0), 0);
is(index("ababa","a",1), 2);
is(index("ababa","a",2), 2);
is(index("ababa","a",3), 4);
is(index("ababa","a",4), 4);
is(index("ababa","a",5), -1);

is(rindex("ababa","a",-1), -1);
is(rindex("ababa","a",0), 0);
is(rindex("ababa","a",1), 0);
is(rindex("ababa","a",2), 2);
is(rindex("ababa","a",3), 2);
is(rindex("ababa","a",4), 4);
is(rindex("ababa","a",5), 4);

# tests for empty search string
is(index("abc", "", -1), 0);
is(index("abc", "", 0), 0);
is(index("abc", "", 1), 1);
is(index("abc", "", 2), 2);
is(index("abc", "", 3), 3);
is(index("abc", "", 4), 3);
is(rindex("abc", "", -1), 0);
is(rindex("abc", "", 0), 0);
is(rindex("abc", "", 1), 1);
is(rindex("abc", "", 2), 2);
is(rindex("abc", "", 3), 3);
is(rindex("abc", "", 4), 3);

$a = "foo \x{1234}bar";

is(index($a, "\x{1234}"), 4);
is(index($a, "bar",    ), 5);

is(rindex($a, "\x{1234}"), 4);
is(rindex($a, "foo",    ), 0);

{
    my $needle = "\x{1230}\x{1270}";
    my @@needles = split ( //, $needle );
    my $haystack = "\x{1228}\x{1228}\x{1230}\x{1270}";
    foreach ( @@needles ) {
	my $a = index ( "\x{1228}\x{1228}\x{1230}\x{1270}", $_ );
	my $b = index ( $haystack, $_ );
	is($a, $b, q{[perl #22375] 'split'/'index' problem for utf8});
    }
    $needle = "\x{1270}\x{1230}"; # Transpose them.
    @@needles = split ( //, $needle );
    foreach ( @@needles ) {
	my $a = index ( "\x{1228}\x{1228}\x{1230}\x{1270}", $_ );
	my $b = index ( $haystack, $_ );
	is($a, $b, q{[perl #22375] 'split'/'index' problem for utf8});
    }
}

{
    my $search;
    my $text;
    $search = "foo " . uni_to_native("\xc9") . " bar";
    $text = "a" . uni_to_native("\xa3\xa3") . "a $search    $search quux";

    my $text_utf8 = $text;
    utf8::upgrade($text_utf8);
    my $search_utf8 = $search;
    utf8::upgrade($search_utf8);

    is (index($text, $search), 5);
    is (rindex($text, $search), 18);
    is (index($text, $search_utf8), 5);
    is (rindex($text, $search_utf8), 18);
    is (index($text_utf8, $search), 5);
    is (rindex($text_utf8, $search), 18);
    is (index($text_utf8, $search_utf8), 5);
    is (rindex($text_utf8, $search_utf8), 18);

    my $text_octets = $text_utf8;
    utf8::encode ($text_octets);
    my $search_octets = $search_utf8;
    utf8::encode ($search_octets);

    is (index($text_octets, $search_octets), 7, "index octets, octets")
	or _diag ($text_octets, $search_octets);
    is (rindex($text_octets, $search_octets), 21, "rindex octets, octets");
    is (index($text_octets, $search_utf8), -1);
    is (rindex($text_octets, $search_utf8), -1);
    is (index($text_utf8, $search_octets), -1);
    is (rindex($text_utf8, $search_octets), -1);

    is (index($text_octets, $search), -1);
    is (rindex($text_octets, $search), -1);
    is (index($text, $search_octets), -1);
    is (rindex($text, $search_octets), -1);
}

{
    no warnings 'deprecated'; # These are above IV_MAX on 32 bit machines
    my $a = eval q{"\x{80000000}"};
    my $s = $a.'defxyz';
    is(index($s, 'def'), 1, "0x80000000 is a single character");

    my $b = eval q{"\x{fffffffd}"};
    my $t = $b.'pqrxyz';
    is(index($t, 'pqr'), 1, "0xfffffffd is a single character");

    local ${^UTF8CACHE} = -1;
    is(index($t, 'xyz'), 4, "0xfffffffd and utf8cache");
}


# Tests for NUL characters.
{
    my @@tests = (
        ["",            -1, -1, -1],
        ["foo",         -1, -1, -1],
        ["\0",           0, -1, -1],
        ["\0\0",         0,  0, -1],
        ["\0\0\0",       0,  0,  0],
        ["foo\0",        3, -1, -1],
        ["foo\0foo\0\0", 3,  7, -1],
    );
    foreach my $l (1 .. 3) {
        my $q = "\0" x $l;
        my $i = 0;
        foreach my $test (@@tests) {
            $i ++;
            my $str = $$test [0];
            my $res = $$test [$l];

            {
                is (index ($str, $q), $res, "Find NUL character(s)");
            }

            #
            # Bug #53746 shows a difference between variables and literals,
            # so test literals as well.
            #
            my $test_str = qq {is (index ("$str", "$q"), $res, } .
                           qq {"Find NUL character(s)")};
               $test_str =~ s/\0/\\0/g;

            eval $test_str;
            die $@@ if $@@;
        }
    }
}

{
    # RT#75898
    is(eval { utf8::upgrade($_ = " "); index $_, " ", 72 }, -1,
       'UTF-8 cache handles offset beyond the end of the string');
    $_ = "\x{100}BC";
    is(index($_, "C", 4), -1,
       'UTF-8 cache handles offset beyond the end of the string');
}

# RT #89218
use constant {PVBM => 'galumphing', PVBM2 => 'bang'};

sub index_it {
    is(index('galumphing', PVBM), 0,
       "index isn't confused by format compilation");
}
 
index_it();
is($^A, '', '$^A is empty');
formline PVBM;
is($^A, 'galumphing', "formline isn't confused by index compilation");
index_it();

$^A = '';
# must not do index here before formline.
is($^A, '', '$^A is empty');
formline PVBM2;
is($^A, 'bang', "formline isn't confused by index compilation");
is(index('bang', PVBM2), 0, "index isn't confused by format compilation");

{
    use constant perl => "rules";
    is(index("perl rules", perl), 5, 'first index of a constant works');
    is(index("rules 1 & 2", perl), 0, 'second index of the same constant works');
}

# PVBM compilation should not flatten ref constants
use constant riffraff => \our $referent;
index "foo", riffraff;
is ref riffraff, 'SCALAR', 'index does not flatten ref constants';

package o { use overload '""' => sub { "foo" } }
bless \our $referent, o::;
is index("foo", riffraff), 0,
    'index respects changes in ref stringification';

use constant quire => ${qr/(?{})/}; # A REGEXP, not a reference to one
index "foo", quire;
eval ' "" =~ quire ';
is $@@, "", 'regexp constants containing code blocks are not flattened';

use constant bang => $! = 8;
index "foo", bang;
cmp_ok bang, '==', 8, 'dualvar constants are not flattened';

use constant u => undef;
{
    my $w;
    local $SIG{__WARN__} = sub { $w .= shift };
    eval '
        use warnings;
        sub { () = index "foo", u; }
    ';
    is $w, undef, 'no warnings from compiling index($foo, undef_constant)';
}
is u, undef, 'undef constant is still undef';

is index('the main road', __PACKAGE__), 4,
    '[perl #119169] __PACKAGE__ as 2nd argument';

} # end of sub run_tests

utf8::upgrade my $substr = "\x{a3}a";

is index($substr, 'a'), 1, 'index reply reflects characters not octets';
@


1.13
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@a4 1
    @@INC = '../lib';
d6 2
d11 1
a11 1
plan( tests => 121 );
d96 2
a97 2
    $search = latin1_to_native("foo \xc9 bar");
    $text = latin1_to_native("a\xa3\xa3a $search    $search quux");
d132 3
a134 4
SKIP: {
    skip "UTF-EBCDIC is limited to 0x7fffffff", 3 if ord("A") == 193;

    my $a = "\x{80000000}";
d138 1
a138 1
    my $b = "\x{fffffffd}";
d255 4
@


1.12
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d10 1
a10 1
plan( tests => 114 );
d220 28
d249 6
@


1.11
log
@merge in perl 5.12.2 plus local changes
@
text
@d10 1
a10 1
plan( tests => 111 );
d95 2
a96 7
    if (ord('A') == 193) {
	$search = "foo \x71 bar";
	$text = "a\xb1\xb1a $search    $search quux";
    } else {
	$search = "foo \xc9 bar";
	$text = "a\xa3\xa3a $search    $search quux";
    }
a130 13
foreach my $utf8 ('', ', utf-8') {
    foreach my $arraybase (0, 1, -1, -2) {
	my $expect_pos = 2 + $arraybase;

	my $prog = "no warnings 'deprecated';\n";
	$prog .= "\$[ = $arraybase; \$big = \"N\\xabN\\xab\"; ";
	$prog .= '$big .= chr 256; chop $big; ' if $utf8;
	$prog .= 'print rindex $big, "N", 2 + $[';

	fresh_perl_is($prog, $expect_pos, {}, "\$[ = $arraybase$utf8");
    }
}

d182 36
@


1.10
log
@Merge in perl 5.10.1; part two
@
text
@d140 2
a141 1
	my $prog = "\$[ = $arraybase; \$big = \"N\\xabN\\xab\"; ";
@


1.9
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d10 5
a14 1
plan( tests => 69 );
d161 40
@


1.8
log
@merge in perl 5.8.8
@
text
@d6 1
d10 1
a10 2
require './test.pl';
plan( tests => 58 );
d89 9
a97 2
    my $search = "foo \xc9 bar";
    my $text = "a\xa3\xa3a $search    $search quux";
d130 27
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d8 1
d10 1
a10 1
plan( tests => 28 );
d12 1
a12 1
$foo = 'Now is the time for all good men to come to the aid of their country.';
d14 1
a14 1
$first = substr($foo,0,index($foo,'the'));
d17 1
a17 1
$last = substr($foo,rindex($foo,'the'),100);
d48 14
d86 37
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d3 4
a6 1
# $RCSfile: index.t,v $$Revision: 4.1 $$Date: 92/08/07 18:27:59 $
d8 2
a9 1
print "1..24\n";
d14 1
a14 1
print ($first eq "Now is " ? "ok 1\n" : "not ok 1\n");
d17 1
a17 1
print ($last eq "their country." ? "ok 2\n" : "not ok 2\n");
d20 1
a20 1
print ($last eq "No" ? "ok 3\n" : "not ok 3\n");
d23 1
a23 1
print ($last eq "No" ? "ok 4\n" : "not ok 4\n");
d26 1
a26 1
print ($last eq "." ? "ok 5\n" : "not ok 5\n");
d29 1
a29 1
print ($last eq "." ? "ok 6\n" : "not ok 6\n");
d31 15
a45 15
print index("ababa","a",-1) == 0 ? "ok 7\n" : "not ok 7\n";
print index("ababa","a",0) == 0 ? "ok 8\n" : "not ok 8\n";
print index("ababa","a",1) == 2 ? "ok 9\n" : "not ok 9\n";
print index("ababa","a",2) == 2 ? "ok 10\n" : "not ok 10\n";
print index("ababa","a",3) == 4 ? "ok 11\n" : "not ok 11\n";
print index("ababa","a",4) == 4 ? "ok 12\n" : "not ok 12\n";
print index("ababa","a",5) == -1 ? "ok 13\n" : "not ok 13\n";

print rindex("ababa","a",-1) == -1 ? "ok 14\n" : "not ok 14\n";
print rindex("ababa","a",0) == 0 ? "ok 15\n" : "not ok 15\n";
print rindex("ababa","a",1) == 0 ? "ok 16\n" : "not ok 16\n";
print rindex("ababa","a",2) == 2 ? "ok 17\n" : "not ok 17\n";
print rindex("ababa","a",3) == 2 ? "ok 18\n" : "not ok 18\n";
print rindex("ababa","a",4) == 4 ? "ok 19\n" : "not ok 19\n";
print rindex("ababa","a",5) == 4 ? "ok 20\n" : "not ok 20\n";
d49 2
a50 2
print index($a, "\x{1234}") == 4 ? "ok 21\n" : "not ok 21\n";
print index($a, "bar",    ) == 5 ? "ok 22\n" : "not ok 22\n";
d52 20
a71 2
print rindex($a, "\x{1234}") == 4 ? "ok 23\n" : "not ok 23\n";
print rindex($a, "foo",    ) == 0 ? "ok 24\n" : "not ok 24\n";
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d5 1
a5 2
print "1..20\n";

d42 8
@


1.4
log
@perl-5.6.0 + local changes
@
text
@@


1.3
log
@perl5.005_03 (stock)
@
text
@@


1.2
log
@perl 5.004_04
@
text
@@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@stock perl 5.8.0 from CPAN
@
text
@d5 2
a6 1
print "1..24\n";
a42 8

$a = "foo \x{1234}bar";

print index($a, "\x{1234}") == 4 ? "ok 21\n" : "not ok 21\n";
print index($a, "bar",    ) == 5 ? "ok 22\n" : "not ok 22\n";

print rindex($a, "\x{1234}") == 4 ? "ok 23\n" : "not ok 23\n";
print rindex($a, "foo",    ) == 0 ? "ok 24\n" : "not ok 24\n";
@


1.1.1.3
log
@perl 5.8.2 from CPAN
@
text
@d3 1
a3 4
BEGIN {
    chdir 't' if -d 't';
    @@INC = '../lib';
}
d5 1
a5 2
require './test.pl';
plan( tests => 28 );
d10 1
a10 1
is($first, "Now is ");
d13 1
a13 1
is($last, "their country.");
d16 1
a16 1
is($last, "No");
d19 1
a19 1
is($last, "No");
d22 1
a22 1
is($last, ".");
d25 1
a25 1
is($last, ".");
d27 15
a41 15
is(index("ababa","a",-1), 0);
is(index("ababa","a",0), 0);
is(index("ababa","a",1), 2);
is(index("ababa","a",2), 2);
is(index("ababa","a",3), 4);
is(index("ababa","a",4), 4);
is(index("ababa","a",5), -1);

is(rindex("ababa","a",-1), -1);
is(rindex("ababa","a",0), 0);
is(rindex("ababa","a",1), 0);
is(rindex("ababa","a",2), 2);
is(rindex("ababa","a",3), 2);
is(rindex("ababa","a",4), 4);
is(rindex("ababa","a",5), 4);
d45 2
a46 2
is(index($a, "\x{1234}"), 4);
is(index($a, "bar",    ), 5);
d48 2
a49 20
is(rindex($a, "\x{1234}"), 4);
is(rindex($a, "foo",    ), 0);

{
    my $needle = "\x{1230}\x{1270}";
    my @@needles = split ( //, $needle );
    my $haystack = "\x{1228}\x{1228}\x{1230}\x{1270}";
    foreach ( @@needles ) {
	my $a = index ( "\x{1228}\x{1228}\x{1230}\x{1270}", $_ );
	my $b = index ( $haystack, $_ );
	is($a, $b, q{[perl #22375] 'split'/'index' problem for utf8});
    }
    $needle = "\x{1270}\x{1230}"; # Transpose them.
    @@needles = split ( //, $needle );
    foreach ( @@needles ) {
	my $a = index ( "\x{1228}\x{1228}\x{1230}\x{1270}", $_ );
	my $b = index ( $haystack, $_ );
	is($a, $b, q{[perl #22375] 'split'/'index' problem for utf8});
    }
}
@


1.1.1.4
log
@perl 5.8.8 import
@
text
@a7 1
use strict;
d9 1
a9 1
plan( tests => 58 );
d11 1
a11 1
my $foo = 'Now is the time for all good men to come to the aid of their country.';
d13 1
a13 1
my $first = substr($foo,0,index($foo,'the'));
d16 1
a16 1
my $last = substr($foo,rindex($foo,'the'),100);
a46 14
# tests for empty search string
is(index("abc", "", -1), 0);
is(index("abc", "", 0), 0);
is(index("abc", "", 1), 1);
is(index("abc", "", 2), 2);
is(index("abc", "", 3), 3);
is(index("abc", "", 4), 3);
is(rindex("abc", "", -1), 0);
is(rindex("abc", "", 0), 0);
is(rindex("abc", "", 1), 1);
is(rindex("abc", "", 2), 2);
is(rindex("abc", "", 3), 3);
is(rindex("abc", "", 4), 3);

a70 37
}

{
    my $search = "foo \xc9 bar";
    my $text = "a\xa3\xa3a $search    $search quux";

    my $text_utf8 = $text;
    utf8::upgrade($text_utf8);
    my $search_utf8 = $search;
    utf8::upgrade($search_utf8);

    is (index($text, $search), 5);
    is (rindex($text, $search), 18);
    is (index($text, $search_utf8), 5);
    is (rindex($text, $search_utf8), 18);
    is (index($text_utf8, $search), 5);
    is (rindex($text_utf8, $search), 18);
    is (index($text_utf8, $search_utf8), 5);
    is (rindex($text_utf8, $search_utf8), 18);

    my $text_octets = $text_utf8;
    utf8::encode ($text_octets);
    my $search_octets = $search_utf8;
    utf8::encode ($search_octets);

    is (index($text_octets, $search_octets), 7, "index octets, octets")
	or _diag ($text_octets, $search_octets);
    is (rindex($text_octets, $search_octets), 21, "rindex octets, octets");
    is (index($text_octets, $search_utf8), -1);
    is (rindex($text_octets, $search_utf8), -1);
    is (index($text_utf8, $search_octets), -1);
    is (rindex($text_utf8, $search_octets), -1);

    is (index($text_octets, $search), -1);
    is (rindex($text_octets, $search), -1);
    is (index($text, $search_octets), -1);
    is (rindex($text, $search_octets), -1);
@


1.1.1.5
log
@import perl 5.10.0 from CPAN
@
text
@a5 1
    require './test.pl';
d9 2
a10 1
plan( tests => 69 );
d89 2
a90 9
    my $search;
    my $text;
    if (ord('A') == 193) {
	$search = "foo \x71 bar";
	$text = "a\xb1\xb1a $search    $search quux";
    } else {
	$search = "foo \xc9 bar";
	$text = "a\xa3\xa3a $search    $search quux";
    }
a122 27
}

foreach my $utf8 ('', ', utf-8') {
    foreach my $arraybase (0, 1, -1, -2) {
	my $expect_pos = 2 + $arraybase;

	my $prog = "\$[ = $arraybase; \$big = \"N\\xabN\\xab\"; ";
	$prog .= '$big .= chr 256; chop $big; ' if $utf8;
	$prog .= 'print rindex $big, "N", 2 + $[';

	fresh_perl_is($prog, $expect_pos, {}, "\$[ = $arraybase$utf8");
    }
}

SKIP: {
    skip "UTF-EBCDIC is limited to 0x7fffffff", 3 if ord("A") == 193;

    my $a = "\x{80000000}";
    my $s = $a.'defxyz';
    is(index($s, 'def'), 1, "0x80000000 is a single character");

    my $b = "\x{fffffffd}";
    my $t = $b.'pqrxyz';
    is(index($t, 'pqr'), 1, "0xfffffffd is a single character");

    local ${^UTF8CACHE} = -1;
    is(index($t, 'xyz'), 4, "0xfffffffd and utf8cache");
@


1.1.1.6
log
@import perl 5.10.1
@
text
@d10 1
a10 5
plan( tests => 111 );

run_tests() unless caller;

sub run_tests {
a156 40
}


# Tests for NUL characters.
{
    my @@tests = (
        ["",            -1, -1, -1],
        ["foo",         -1, -1, -1],
        ["\0",           0, -1, -1],
        ["\0\0",         0,  0, -1],
        ["\0\0\0",       0,  0,  0],
        ["foo\0",        3, -1, -1],
        ["foo\0foo\0\0", 3,  7, -1],
    );
    foreach my $l (1 .. 3) {
        my $q = "\0" x $l;
        my $i = 0;
        foreach my $test (@@tests) {
            $i ++;
            my $str = $$test [0];
            my $res = $$test [$l];

            {
                is (index ($str, $q), $res, "Find NUL character(s)");
            }

            #
            # Bug #53746 shows a difference between variables and literals,
            # so test literals as well.
            #
            my $test_str = qq {is (index ("$str", "$q"), $res, } .
                           qq {"Find NUL character(s)")};
               $test_str =~ s/\0/\\0/g;

            eval $test_str;
            die $@@ if $@@;
        }
    }
}

@


1.1.1.7
log
@Perl 5.12.2 from CPAN
@
text
@d140 1
a140 2
	my $prog = "no warnings 'deprecated';\n";
	$prog .= "\$[ = $arraybase; \$big = \"N\\xabN\\xab\"; ";
@


1.1.1.8
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d10 1
a10 1
plan( tests => 114 );
d95 7
a101 2
    $search = latin1_to_native("foo \xc9 bar");
    $text = latin1_to_native("a\xa3\xa3a $search    $search quux");
d136 13
a199 36
}

{
    # RT#75898
    is(eval { utf8::upgrade($_ = " "); index $_, " ", 72 }, -1,
       'UTF-8 cache handles offset beyond the end of the string');
    $_ = "\x{100}BC";
    is(index($_, "C", 4), -1,
       'UTF-8 cache handles offset beyond the end of the string');
}

# RT #89218
use constant {PVBM => 'galumphing', PVBM2 => 'bang'};

sub index_it {
    is(index('galumphing', PVBM), 0,
       "index isn't confused by format compilation");
}
 
index_it();
is($^A, '', '$^A is empty');
formline PVBM;
is($^A, 'galumphing', "formline isn't confused by index compilation");
index_it();

$^A = '';
# must not do index here before formline.
is($^A, '', '$^A is empty');
formline PVBM2;
is($^A, 'bang', "formline isn't confused by index compilation");
is(index('bang', PVBM2), 0, "index isn't confused by format compilation");

{
    use constant perl => "rules";
    is(index("perl rules", perl), 5, 'first index of a constant works');
    is(index("rules 1 & 2", perl), 0, 'second index of the same constant works');
@


1.1.1.9
log
@Import perl-5.20.1
@
text
@d10 1
a10 1
plan( tests => 121 );
a219 28
# PVBM compilation should not flatten ref constants
use constant riffraff => \our $referent;
index "foo", riffraff;
is ref riffraff, 'SCALAR', 'index does not flatten ref constants';

package o { use overload '""' => sub { "foo" } }
bless \our $referent, o::;
is index("foo", riffraff), 0,
    'index respects changes in ref stringification';

use constant quire => ${qr/(?{})/}; # A REGEXP, not a reference to one
index "foo", quire;
eval ' "" =~ quire ';
is $@@, "", 'regexp constants containing code blocks are not flattened';

use constant bang => $! = 8;
index "foo", bang;
cmp_ok bang, '==', 8, 'dualvar constants are not flattened';

use constant u => undef;
{
    my $w;
    local $SIG{__WARN__} = sub { $w .= shift };
    eval '
        use warnings;
        sub { () = index "foo", u; }
    ';
    is $w, undef, 'no warnings from compiling index($foo, undef_constant)';
a220 6
is u, undef, 'undef constant is still undef';

is index('the main road', __PACKAGE__), 4,
    '[perl #119169] __PACKAGE__ as 2nd argument';

} # end of sub run_tests
@


