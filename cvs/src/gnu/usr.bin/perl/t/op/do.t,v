head	1.13;
access;
symbols
	OPENBSD_6_1_BASE:1.13
	OPENBSD_6_0:1.12.0.10
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.12.0.4
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.12.0.6
	OPENBSD_5_8_BASE:1.12
	PERL_5_20_2:1.1.1.11
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	PERL_5_20_1:1.1.1.11
	OPENBSD_5_6:1.11.0.4
	OPENBSD_5_6_BASE:1.11
	PERL_5_18_2:1.1.1.10
	PERL:1.1.1
	OPENBSD_5_5:1.10.0.6
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.2
	OPENBSD_5_4_BASE:1.10
	PERL_5_16_3:1.1.1.9
	OPENBSD_5_3:1.9.0.10
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.8
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.6
	OPENBSD_5_0:1.9.0.4
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.2
	OPENBSD_4_9_BASE:1.9
	PERL_5_12_2:1.1.1.8
	OPENBSD_4_8:1.8.0.8
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.4
	OPENBSD_4_7_BASE:1.8
	PERL_5_10_1:1.1.1.7
	OPENBSD_4_6:1.8.0.6
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.2
	OPENBSD_4_5_BASE:1.8
	PERL_5_10_0:1.1.1.7
	OPENBSD_4_4:1.7.0.20
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.18
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.16
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.14
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.12
	OPENBSD_4_0_BASE:1.7
	PERL_5_8_8:1.1.1.6
	OPENBSD_3_9:1.7.0.10
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.8
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.6
	OPENBSD_3_7_BASE:1.7
	PERL_5_8_6:1.1.1.6
	OPENBSD_3_6:1.7.0.4
	OPENBSD_3_6_BASE:1.7
	PERL_5_8_5:1.1.1.5
	PERL_5_8_3:1.1.1.4
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.4
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.3
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.2
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.13
date	2017.02.05.00.32.20;	author afresh1;	state Exp;
branches;
next	1.12;
commitid	cxJ08BvJA9Pt2PTM;

1.12
date	2014.11.17.20.57.07;	author afresh1;	state Exp;
branches;
next	1.11;
commitid	QP75iYx42Uo7mMxO;

1.11
date	2014.03.24.15.05.33;	author afresh1;	state Exp;
branches;
next	1.10;

1.10
date	2013.03.25.20.40.59;	author sthen;	state Exp;
branches;
next	1.9;

1.9
date	2010.09.24.15.07.08;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2008.09.29.17.36.19;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.48;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.37;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.36.17;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.08.21;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.52.34;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.08.05.17;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.13.17;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.13.17;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.41.44;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.10.27.22.15.10;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.12.03.02.44.31;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.08.09.17.48.34;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2005.01.15.21.18.18;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2008.09.29.17.19.00;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2010.09.24.14.49.18;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2013.03.25.20.09.35;	author sthen;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2014.03.24.14.59.10;	author afresh1;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2014.11.17.20.53.17;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.13
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl -w

BEGIN {
    chdir 't' if -d 't';
    @@INC = '../lib';
    require './test.pl';
}
use strict;
no warnings 'void';

my $called;
my $result = do{ ++$called; 'value';};
is($called, 1, 'do block called');
is($result, 'value', 'do block returns correct value');

unshift @@INC, '.';

my $file16 = tempfile();
if (open my $do, '>', $file16) {
    print $do "isnt(wantarray, undef, 'do in scalar context');\n";
    print $do "cmp_ok(wantarray, '==', 0, 'do in scalar context');\n";
    close $do or die "Could not close: $!";
}

my $a = do $file16; die $@@ if $@@;

my $file17 = tempfile();
if (open my $do, '>', $file17) {
    print $do "isnt(wantarray, undef, 'do in list context');\n";
    print $do "cmp_ok(wantarray, '!=', 0, 'do in list context');\n";
    close $do or die "Could not close: $!";
}

my @@a = do $file17; die $@@ if $@@;

my $file18 = tempfile();
if (open my $do, '>', $file18) {
    print $do "is(wantarray, undef, 'do in void context');\n";
    close $do or die "Could not close: $!";
}

do $file18; die $@@ if $@@;

# bug ID 20010920.007
eval qq{ do qq(a file that does not exist); };
is($@@, '', "do on a non-existing file, first try");

eval qq{ do uc qq(a file that does not exist); };
is($@@, '', "do on a non-existing file, second try");

# 6 must be interpreted as a file name here
$! = 0;
my $do6 = do 6;
my $errno = $1;
is($do6, undef, 'do 6 must be interpreted as a filename');
isnt($!, 0, 'and should set $!');

# [perl #19545]
my ($u, @@t);
{
    no warnings 'uninitialized';
    push @@t, ($u = (do {} . "This should be pushed."));
}
is($#t, 0, "empty do result value" );

my $zok = '';
my $owww = do { 1 if $zok };
is($owww, '', 'last is unless');
$owww = do { 2 unless not $zok };
is($owww, 1, 'last is if not');

$zok = 'swish';
$owww = do { 3 unless $zok };
is($owww, 'swish', 'last is unless');
$owww = do { 4 if not $zok };
is($owww, '', 'last is if not');

# [perl #38809]
@@a = (7);
my $x = sub { do { return do { @@a } }; 2 }->();
is($x, 1, 'return do { } receives caller scalar context');
my @@x = sub { do { return do { @@a } }; 2 }->();
is("@@x", "7", 'return do { } receives caller list context');

@@a = (7, 8);
$x = sub { do { return do { 1; @@a } }; 3 }->();
is($x, 2, 'return do { ; } receives caller scalar context');
@@x = sub { do { return do { 1; @@a } }; 3 }->();
is("@@x", "7 8", 'return do { ; } receives caller list context');

my @@b = (11 .. 15);
$x = sub { do { return do { 1; @@a, @@b } }; 3 }->();
is($x, 5, 'return do { ; , } receives caller scalar context');
@@x = sub { do { return do { 1; @@a, @@b } }; 3 }->();
is("@@x", "7 8 11 12 13 14 15", 'return do { ; , } receives caller list context');

$x = sub { do { return do { 1; @@a }, do { 2; @@b } }; 3 }->();
is($x, 5, 'return do { ; }, do { ; } receives caller scalar context');
@@x = sub { do { return do { 1; @@a }, do { 2; @@b } }; 3 }->();
is("@@x", "7 8 11 12 13 14 15", 'return do { ; }, do { ; } receives caller list context');

@@a = (7, 8, 9);
$x = sub { do { do { 1; return @@a } }; 4 }->();
is($x, 3, 'do { return } receives caller scalar context');
@@x = sub { do { do { 1; return @@a } }; 4 }->();
is("@@x", "7 8 9", 'do { return } receives caller list context');

@@a = (7, 8, 9, 10);
$x = sub { do { return do { 1; do { 2; @@a } } }; 5 }->();
is($x, 4, 'return do { do { ; } } receives caller scalar context');
@@x = sub { do { return do { 1; do { 2; @@a } } }; 5 }->();
is("@@x", "7 8 9 10", 'return do { do { ; } } receives caller list context');

# More tests about context propagation below return()
@@a = (11, 12);
@@b = (21, 22, 23);

my $test_code = sub {
    my ($x, $y) = @@_;
    if ($x) {
	return $y ? do { my $z; @@a } : do { my $z; @@b };
    } else {
	return (
	    do { my $z; @@a },
	    (do { my$z; @@b }) x $y
	);
    }
    'xxx';
};

$x = $test_code->(1, 1);
is($x, 2, 'return $y ? do { } : do { } - scalar context 1');
$x = $test_code->(1, 0);
is($x, 3, 'return $y ? do { } : do { } - scalar context 2');
@@x = $test_code->(1, 1);
is("@@x", '11 12', 'return $y ? do { } : do { } - list context 1');
@@x = $test_code->(1, 0);
is("@@x", '21 22 23', 'return $y ? do { } : do { } - list context 2');

$x = $test_code->(0, 0);
is($x, "", 'return (do { }, (do { }) x ...) - scalar context 1');
$x = $test_code->(0, 1);
is($x, 3, 'return (do { }, (do { }) x ...) - scalar context 2');
@@x = $test_code->(0, 0);
is("@@x", '11 12', 'return (do { }, (do { }) x ...) - list context 1');
@@x = $test_code->(0, 1);
is("@@x", '11 12 21 22 23', 'return (do { }, (do { }) x ...) - list context 2');

$test_code = sub {
    my ($x, $y) = @@_;
    if ($x) {
	return do {
	    if ($y == 0) {
		my $z;
		@@a;
	    } elsif ($y == 1) {
		my $z;
		@@b;
	    } else {
		my $z;
		(wantarray ? reverse(@@a) : '99');
	    }
	};
    }
    'xxx';
};

$x = $test_code->(1, 0);
is($x, 2, 'return do { if () { } elsif () { } else { } } - scalar 1');
$x = $test_code->(1, 1);
is($x, 3, 'return do { if () { } elsif () { } else { } } - scalar 2');
$x = $test_code->(1, 2);
is($x, 99, 'return do { if () { } elsif () { } else { } } - scalar 3');
@@x = $test_code->(1, 0);
is("@@x", '11 12', 'return do { if () { } elsif () { } else { } } - list 1');
@@x = $test_code->(1, 1);
is("@@x", '21 22 23', 'return do { if () { } elsif () { } else { } } - list 2');
@@x = $test_code->(1, 2);
is("@@x", '12 11', 'return do { if () { } elsif () { } else { } } - list 3');

# Do blocks created by constant folding
# [perl #68108]
$x = sub { if (1) { 20 } }->();
is($x, 20, 'if (1) { $x } receives caller scalar context');

@@a = (21 .. 23);
$x = sub { if (1) { @@a } }->();
is($x, 3, 'if (1) { @@a } receives caller scalar context');
@@x = sub { if (1) { @@a } }->();
is("@@x", "21 22 23", 'if (1) { @@a } receives caller list context');

$x = sub { if (1) { 0; 20 } }->();
is($x, 20, 'if (1) { ...; $x } receives caller scalar context');

@@a = (24 .. 27);
$x = sub { if (1) { 0; @@a } }->();
is($x, 4, 'if (1) { ...; @@a } receives caller scalar context');
@@x = sub { if (1) { 0; @@a } }->();
is("@@x", "24 25 26 27", 'if (1) { ...; @@a } receives caller list context');

$x = sub { if (1) { 0; 20 } else{} }->();
is($x, 20, 'if (1) { ...; $x } else{} receives caller scalar context');

@@a = (24 .. 27);
$x = sub { if (1) { 0; @@a } else{} }->();
is($x, 4, 'if (1) { ...; @@a } else{} receives caller scalar context');
@@x = sub { if (1) { 0; @@a } else{} }->();
is("@@x", "24 25 26 27", 'if (1) { ...; @@a } else{} receives caller list context');

$x = sub { if (0){} else { 0; 20 } }->();
is($x, 20, 'if (0){} else { ...; $x } receives caller scalar context');

@@a = (24 .. 27);
$x = sub { if (0){} else { 0; @@a } }->();
is($x, 4, 'if (0){} else { ...; @@a } receives caller scalar context');
@@x = sub { if (0){} else { 0; @@a } }->();
is("@@x", "24 25 26 27", 'if (0){} else { ...; @@a } receives caller list context');

# [rt.cpan.org #72767] do "string" should not propagate warning hints
SKIP: {
  skip_if_miniperl("no in-memory files under miniperl", 1);

  my $code = '42; 1';
  # Based on Eval::WithLexicals::_eval_do
  local @@INC = (sub {
    if ($_[1] eq '/eval_do') {
      open my $fh, '<', \$code;
      $fh;
    } else {
      ();
    }
  }, @@INC);
  local $^W;
  use warnings;
  my $w;
  local $SIG{__WARN__} = sub { warn shift; ++$w };
  do '/eval_do' or die $@@;
  is($w, undef, 'do STRING does not propagate warning hints');
}

# RT#113730 - $@@ should be cleared on IO error.
{
    $@@ = "should not see";
    $! = 0;
    my $rv = do("some nonexistent file");
    my $saved_error = $@@;
    my $saved_errno = $!;
    ok(!$rv,          "do returns false on io errror");
    ok(!$saved_error, "\$\@@ not set on io error");
    ok($saved_errno,  "\$! set on io error");
}

# do subname should not be do "subname"
{
    my $called;
    sub fungi { $called .= "fungible" }
    $@@ = "scrimptious scrobblings";
    do fungi;
    is $called, "fungible", "do-file does not force bareword";
    isnt $@@, "scrimptious scrobblings", "It was interpreted as do-file";
}

# do CORE () has always been do-file
{
    my $called;
    sub CORE { $called .= "fungible" }
    $@@ = "scromptious scrimblings";
    do CORE();
    is $called, "fungible", "do CORE() calls &CORE";
    isnt $@@, "scromptious scrimblings", "It was interpreted as do-file";
}

# do subname() and $subname() are no longer allowed
{
    sub subname { fail('do subname('. ($_[0] || '') .') called') };
    my $subref = sub { fail('do $subref('. ($_[0] || '') .') called') };
    foreach my $mode (qw(subname("arg") subname() $subref("arg") $subref())) {
        eval "do $mode";
        like $@@, qr/\Asyntax error/, "do $mode is syntax error";
    }
}

{
    # follow-up to [perl #91844]: a do should always return a copy,
    # not the original

    my %foo;
    $foo{bar} = 7;
    my $r = \$foo{bar};
    sub {
        $$r++;
        isnt($_[0], $$r, "result of delete(helem) is copied: practical test");
    }->(do { 1; delete $foo{bar} });
}

# A do block should FREETMPS on exit
# RT #124248

{
    package p124248;
    my $d = 0;
    sub DESTROY { $d++ }
    sub f { ::is($d, 1, "RT 124248"); }
    f(do { 1; !!(my $x = bless []); });
}


done_testing();
@


1.12
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d4 1
a4 1
    chdir 't';
d282 25
@


1.11
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@a10 32
sub foo1
{
    ok($_[0], 'in foo1');
    'value';
}

sub foo2
{
    shift;
    ok($_[0], 'in foo2');
    my $x = 'value';
    $x;
}

my $result;
$_[0] = 0;
{
    no warnings 'deprecated';
    $result = do foo1(1);
}

is($result, 'value', 'do &sub and proper @@_ handling');
cmp_ok($_[0], '==', 0, 'do &sub and proper @@_ handling');

$_[0] = 0;
{
    no warnings 'deprecated';
    $result = do foo2(0,1,0);
}
is($result, 'value', 'do &sub and proper @@_ handling');
cmp_ok($_[0], '==', 0, 'do &sub and proper @@_ handling');

d12 1
a12 1
$result = do{ ++$called; 'value';};
a15 20
my @@blathered;
sub blather {
    push @@blathered, $_ foreach @@_;
}

{
    no warnings 'deprecated';
    do blather("ayep","sho nuff");
    is("@@blathered", "ayep sho nuff", 'blathered called with list');
}
@@blathered = ();

my @@x = ("jeepers", "okydoke");
my @@y = ("uhhuh", "yeppers");
{
    no warnings 'deprecated';
    do blather(@@x,"noofie",@@y);
    is("@@blathered", "@@x noofie @@y", 'blathered called with arrays too');
}

d82 1
a82 1
@@x = sub { do { return do { @@a } }; 2 }->();
d261 20
@


1.10
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d3 5
a7 1
require './test.pl';
d291 22
@


1.9
log
@merge in perl 5.12.2 plus local changes
@
text
@d1 5
a5 1
#!./perl
d9 1
a9 1
    ok($_[0]);
d16 2
a17 2
    ok($_[0]);
    $x = 'value';
d21 1
a21 18
my $test = 1;
sub ok {
    my($ok, $name) = @@_;

    # You have to do it this way or VMS will get confused.
    printf "%s %d%s\n", $ok ? "ok" : "not ok", 
                        $test,
                        defined $name ? " - $name" : '';

    printf "# Failed test at line %d\n", (caller)[2] unless $ok;

    $test++;
    return $ok;
}

print "1..50\n";

# Test do &sub and proper @@_ handling.
d28 2
a29 2
ok( $result eq 'value',  ":$result: eq :value:" );
ok( $_[0] == 0 );
d36 2
a37 2
ok( $result eq 'value', ":$result: eq :value:" );
ok( $_[0] == 0 );
d39 4
a42 2
$result = do{ ok 1; 'value';};
ok( $result eq 'value',  ":$result: eq :value:" );
d44 1
d46 1
a46 1
    ok 1 foreach @@_;
d52 1
d54 4
a57 2
@@x = ("jeepers", "okydoke");
@@y = ("uhhuh", "yeppers");
d61 1
d66 5
a70 3
if (open(DO, ">$$.16")) {
    print DO "ok(1, 'do in scalar context') if defined wantarray && not wantarray\n";
    close DO or die "Could not close: $!";
d73 1
a73 1
my $a = do "$$.16"; die $@@ if $@@;
d75 5
a79 3
if (open(DO, ">$$.17")) {
    print DO "ok(1, 'do in list context') if defined wantarray &&     wantarray\n";
    close DO or die "Could not close: $!";
d82 1
a82 1
my @@a = do "$$.17"; die $@@ if $@@;
d84 4
a87 3
if (open(DO, ">$$.18")) {
    print DO "ok(1, 'do in void context') if not defined wantarray\n";
    close DO or die "Could not close: $!";
d90 1
a90 1
do "$$.18"; die $@@ if $@@;
d94 1
a94 1
ok( !$@@, "do on a non-existing file, first try" );
d97 1
a97 1
ok( !$@@, "do on a non-existing file, second try"  );
d100 5
a104 1
ok( (!defined do 6) && $!, "'do 6' : $!" );
d107 6
a112 2
push @@t, ($u = (do {} . "This should be pushed."));
ok( $#t == 0, "empty do result value" );
d114 3
a116 3
$zok = '';
$owww = do { 1 if $zok };
ok( $owww eq '', 'last is unless' );
d118 1
a118 1
ok( $owww == 1, 'last is if not' );
d122 1
a122 1
ok( $owww eq 'swish', 'last is unless' );
d124 1
a124 1
ok( $owww eq '', 'last is if not' );
d128 2
a129 2
$x = sub { do { return do { @@a } }; 2 }->();
ok(defined $x && $x == 1, 'return do { } receives caller scalar context');
d131 1
a131 1
ok("@@x" eq "7", 'return do { } receives caller list context');
d135 1
a135 1
ok(defined $x && $x == 2, 'return do { ; } receives caller scalar context');
d137 1
a137 1
ok("@@x" eq "7 8", 'return do { ; } receives caller list context');
d139 1
a139 1
@@b = (11 .. 15);
d141 1
a141 1
ok(defined $x && $x == 5, 'return do { ; , } receives caller scalar context');
d143 1
a143 1
ok("@@x" eq "7 8 11 12 13 14 15", 'return do { ; , } receives caller list context');
d146 1
a146 1
ok(defined $x && $x == 5, 'return do { ; }, do { ; } receives caller scalar context');
d148 1
a148 1
ok("@@x" eq "7 8 11 12 13 14 15", 'return do { ; }, do { ; } receives caller list context');
d152 1
a152 1
ok(defined $x && $x == 3, 'do { return } receives caller scalar context');
d154 1
a154 1
ok("@@x" eq "7 8 9", 'do { return } receives caller list context');
d158 1
a158 1
ok(defined $x && $x == 4, 'return do { do { ; } } receives caller scalar context');
d160 68
a227 1
ok("@@x" eq "7 8 9 10", 'return do { do { ; } } receives caller list context');
d232 1
a232 1
ok($x == 20, 'if (1) { $x } receives caller scalar context');
d236 1
a236 1
ok($x == 3, 'if (1) { @@a } receives caller scalar context');
d238 1
a238 1
ok("@@x" eq "21 22 23", 'if (1) { @@a } receives caller list context');
d241 1
a241 1
ok($x == 20, 'if (1) { ...; $x } receives caller scalar context');
d245 1
a245 1
ok($x == 4, 'if (1) { ...; @@a } receives caller scalar context');
d247 1
a247 1
ok("@@x" eq "24 25 26 27", 'if (1) { ...; @@a } receives caller list context');
d250 1
a250 1
ok($x == 20, 'if (1) { ...; $x } else{} receives caller scalar context');
d254 1
a254 1
ok($x == 4, 'if (1) { ...; @@a } else{} receives caller scalar context');
d256 1
a256 1
ok("@@x" eq "24 25 26 27", 'if (1) { ...; @@a } else{} receives caller list context');
d259 1
a259 1
ok($x == 20, 'if (0){} else { ...; $x } receives caller scalar context');
d263 1
a263 1
ok($x == 4, 'if (0){} else { ...; @@a } receives caller scalar context');
d265 1
a265 1
ok("@@x" eq "24 25 26 27", 'if (0){} else { ...; @@a } receives caller list context');
d267 21
d289 1
a289 3
END {
    1 while unlink("$$.16", "$$.17", "$$.18");
}
@


1.8
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d32 1
a32 1
print "1..22\n";
d36 4
a39 1
$result = do foo1(1);
d45 4
a48 1
$result = do foo2(0,1,0);
d59 4
a62 1
do blather("ayep","sho nuff");
d65 4
a68 1
do blather(@@x,"noofie",@@y);
d106 87
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@a2 2
# $RCSfile: do.t,v $$Revision: 4.1 $$Date: 92/08/07 18:27:45 $

d65 1
a65 1
my $a = do "$$.16";
d72 1
a72 1
my @@a = do "$$.17";
d79 1
a79 1
do "$$.18";
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d34 1
a34 1
print "1..21\n";
d92 4
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d7 1
a7 1
    print $_[0];
d14 1
a14 1
    print $_[0];
d19 8
a26 1
print "1..15\n";
d28 22
a49 15
$_[0] = "not ok 1\n";
$result = do foo1("ok 1\n");
print "#2\t:$result: eq :value:\n";
if ($result EQ 'value') { print "ok 2\n"; } else { print "not ok 2\n"; }
if ($_[0] EQ "not ok 1\n") { print "ok 3\n"; } else { print "not ok 3\n"; }

$_[0] = "not ok 4\n";
$result = do foo2("not ok 4\n","ok 4\n","not ok 4\n");
print "#5\t:$result: eq :value:\n";
if ($result EQ 'value') { print "ok 5\n"; } else { print "not ok 5\n"; }
if ($_[0] EQ "not ok 4\n") { print "ok 6\n"; } else { print "not ok 6\n"; }

$result = do{print "ok 7\n"; 'value';};
print "#8\t:$result: eq :value:\n";
if ($result EQ 'value') { print "ok 8\n"; } else { print "not ok 8\n"; }
d52 20
a71 1
    print @@_;
d74 22
a95 4
do blather("ok 9\n","ok 10\n");
@@x = ("ok 11\n", "ok 12\n");
@@y = ("ok 14\n", "ok 15\n");
do blather(@@x,"ok 13\n",@@y);
@


1.4
log
@perl-5.6.0 + local changes
@
text
@@


1.3
log
@perl5.005_03 (stock)
@
text
@@


1.2
log
@perl 5.004_04
@
text
@d13 1
a13 1
    shift(_);
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d13 1
a13 1
    shift;
@


1.1.1.3
log
@stock perl 5.8.0 from CPAN
@
text
@d7 1
a7 1
    ok($_[0]);
d14 1
a14 1
    ok($_[0]);
d19 1
a19 8
my $test = 1;
sub ok {
    my($ok, $name) = @@_;

    # You have to do it this way or VMS will get confused.
    printf "%s %d%s\n", $ok ? "ok" : "not ok", 
                        $test,
                        defined $name ? " - $name" : '';
d21 15
a35 22
    printf "# Failed test at line %d\n", (caller)[2] unless $ok;

    $test++;
    return $ok;
}

print "1..21\n";

# Test do &sub and proper @@_ handling.
$_[0] = 0;
$result = do foo1(1);

ok( $result eq 'value',  ":$result: eq :value:" );
ok( $_[0] == 0 );

$_[0] = 0;
$result = do foo2(0,1,0);
ok( $result eq 'value', ":$result: eq :value:" );
ok( $_[0] == 0 );

$result = do{ ok 1; 'value';};
ok( $result eq 'value',  ":$result: eq :value:" );
d38 1
a38 20
    ok 1 foreach @@_;
}

do blather("ayep","sho nuff");
@@x = ("jeepers", "okydoke");
@@y = ("uhhuh", "yeppers");
do blather(@@x,"noofie",@@y);

unshift @@INC, '.';

if (open(DO, ">$$.16")) {
    print DO "ok(1, 'do in scalar context') if defined wantarray && not wantarray\n";
    close DO or die "Could not close: $!";
}

my $a = do "$$.16";

if (open(DO, ">$$.17")) {
    print DO "ok(1, 'do in list context') if defined wantarray &&     wantarray\n";
    close DO or die "Could not close: $!";
d41 4
a44 22
my @@a = do "$$.17";

if (open(DO, ">$$.18")) {
    print DO "ok(1, 'do in void context') if not defined wantarray\n";
    close DO or die "Could not close: $!";
}

do "$$.18";

# bug ID 20010920.007
eval qq{ do qq(a file that does not exist); };
ok( !$@@, "do on a non-existing file, first try" );

eval qq{ do uc qq(a file that does not exist); };
ok( !$@@, "do on a non-existing file, second try"  );

# 6 must be interpreted as a file name here
ok( (!defined do 6) && $!, "'do 6' : $!" );

END {
    1 while unlink("$$.16", "$$.17", "$$.18");
}
@


1.1.1.4
log
@perl 5.8.2 from CPAN
@
text
@d34 1
a34 1
print "1..22\n";
a91 4

# [perl #19545]
push @@t, ($u = (do {} . "This should be pushed."));
ok( $#t == 0, "empty do result value" );
@


1.1.1.5
log
@Import of stock perl 5.8.5
@
text
@d3 1
a3 1
# $RCSfile: do.t,v $$Revision: 1.7 $$Date: 2003/12/03 03:02:48 $
@


1.1.1.6
log
@perl 5.8.6 from CPAN
@
text
@d3 1
a3 1
# $RCSfile: do.t,v $$Revision: 4.1 $$Date: 92/08/07 18:27:45 $
@


1.1.1.7
log
@import perl 5.10.0 from CPAN
@
text
@d3 2
d67 1
a67 1
my $a = do "$$.16"; die $@@ if $@@;
d74 1
a74 1
my @@a = do "$$.17"; die $@@ if $@@;
d81 1
a81 1
do "$$.18"; die $@@ if $@@;
@


1.1.1.8
log
@Perl 5.12.2 from CPAN
@
text
@d32 1
a32 1
print "1..50\n";
d36 1
a36 4
{
    no warnings 'deprecated';
    $result = do foo1(1);
}
d42 1
a42 4
{
    no warnings 'deprecated';
    $result = do foo2(0,1,0);
}
d53 1
a53 4
{
    no warnings 'deprecated';
    do blather("ayep","sho nuff");
}
d56 1
a56 4
{
    no warnings 'deprecated';
    do blather(@@x,"noofie",@@y);
}
a93 87

$zok = '';
$owww = do { 1 if $zok };
ok( $owww eq '', 'last is unless' );
$owww = do { 2 unless not $zok };
ok( $owww == 1, 'last is if not' );

$zok = 'swish';
$owww = do { 3 unless $zok };
ok( $owww eq 'swish', 'last is unless' );
$owww = do { 4 if not $zok };
ok( $owww eq '', 'last is if not' );

# [perl #38809]
@@a = (7);
$x = sub { do { return do { @@a } }; 2 }->();
ok(defined $x && $x == 1, 'return do { } receives caller scalar context');
@@x = sub { do { return do { @@a } }; 2 }->();
ok("@@x" eq "7", 'return do { } receives caller list context');

@@a = (7, 8);
$x = sub { do { return do { 1; @@a } }; 3 }->();
ok(defined $x && $x == 2, 'return do { ; } receives caller scalar context');
@@x = sub { do { return do { 1; @@a } }; 3 }->();
ok("@@x" eq "7 8", 'return do { ; } receives caller list context');

@@b = (11 .. 15);
$x = sub { do { return do { 1; @@a, @@b } }; 3 }->();
ok(defined $x && $x == 5, 'return do { ; , } receives caller scalar context');
@@x = sub { do { return do { 1; @@a, @@b } }; 3 }->();
ok("@@x" eq "7 8 11 12 13 14 15", 'return do { ; , } receives caller list context');

$x = sub { do { return do { 1; @@a }, do { 2; @@b } }; 3 }->();
ok(defined $x && $x == 5, 'return do { ; }, do { ; } receives caller scalar context');
@@x = sub { do { return do { 1; @@a }, do { 2; @@b } }; 3 }->();
ok("@@x" eq "7 8 11 12 13 14 15", 'return do { ; }, do { ; } receives caller list context');

@@a = (7, 8, 9);
$x = sub { do { do { 1; return @@a } }; 4 }->();
ok(defined $x && $x == 3, 'do { return } receives caller scalar context');
@@x = sub { do { do { 1; return @@a } }; 4 }->();
ok("@@x" eq "7 8 9", 'do { return } receives caller list context');

@@a = (7, 8, 9, 10);
$x = sub { do { return do { 1; do { 2; @@a } } }; 5 }->();
ok(defined $x && $x == 4, 'return do { do { ; } } receives caller scalar context');
@@x = sub { do { return do { 1; do { 2; @@a } } }; 5 }->();
ok("@@x" eq "7 8 9 10", 'return do { do { ; } } receives caller list context');

# Do blocks created by constant folding
# [perl #68108]
$x = sub { if (1) { 20 } }->();
ok($x == 20, 'if (1) { $x } receives caller scalar context');

@@a = (21 .. 23);
$x = sub { if (1) { @@a } }->();
ok($x == 3, 'if (1) { @@a } receives caller scalar context');
@@x = sub { if (1) { @@a } }->();
ok("@@x" eq "21 22 23", 'if (1) { @@a } receives caller list context');

$x = sub { if (1) { 0; 20 } }->();
ok($x == 20, 'if (1) { ...; $x } receives caller scalar context');

@@a = (24 .. 27);
$x = sub { if (1) { 0; @@a } }->();
ok($x == 4, 'if (1) { ...; @@a } receives caller scalar context');
@@x = sub { if (1) { 0; @@a } }->();
ok("@@x" eq "24 25 26 27", 'if (1) { ...; @@a } receives caller list context');

$x = sub { if (1) { 0; 20 } else{} }->();
ok($x == 20, 'if (1) { ...; $x } else{} receives caller scalar context');

@@a = (24 .. 27);
$x = sub { if (1) { 0; @@a } else{} }->();
ok($x == 4, 'if (1) { ...; @@a } else{} receives caller scalar context');
@@x = sub { if (1) { 0; @@a } else{} }->();
ok("@@x" eq "24 25 26 27", 'if (1) { ...; @@a } else{} receives caller list context');

$x = sub { if (0){} else { 0; 20 } }->();
ok($x == 20, 'if (0){} else { ...; $x } receives caller scalar context');

@@a = (24 .. 27);
$x = sub { if (0){} else { 0; @@a } }->();
ok($x == 4, 'if (0){} else { ...; @@a } receives caller scalar context');
@@x = sub { if (0){} else { 0; @@a } }->();
ok("@@x" eq "24 25 26 27", 'if (0){} else { ...; @@a } receives caller list context');

@


1.1.1.9
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d1 1
a1 5
#!./perl -w

require './test.pl';
use strict;
no warnings 'void';
d5 1
a5 1
    ok($_[0], 'in foo1');
d12 2
a13 2
    ok($_[0], 'in foo2');
    my $x = 'value';
d17 18
a34 1
my $result;
d41 2
a42 2
is($result, 'value', 'do &sub and proper @@_ handling');
cmp_ok($_[0], '==', 0, 'do &sub and proper @@_ handling');
d49 2
a50 2
is($result, 'value', 'do &sub and proper @@_ handling');
cmp_ok($_[0], '==', 0, 'do &sub and proper @@_ handling');
d52 2
a53 4
my $called;
$result = do{ ++$called; 'value';};
is($called, 1, 'do block called');
is($result, 'value', 'do block returns correct value');
a54 1
my @@blathered;
d56 1
a56 1
    push @@blathered, $_ foreach @@_;
a61 1
    is("@@blathered", "ayep sho nuff", 'blathered called with list');
d63 2
a64 4
@@blathered = ();

my @@x = ("jeepers", "okydoke");
my @@y = ("uhhuh", "yeppers");
a67 1
    is("@@blathered", "@@x noofie @@y", 'blathered called with arrays too');
d72 3
a74 5
my $file16 = tempfile();
if (open my $do, '>', $file16) {
    print $do "isnt(wantarray, undef, 'do in scalar context');\n";
    print $do "cmp_ok(wantarray, '==', 0, 'do in scalar context');\n";
    close $do or die "Could not close: $!";
d77 1
a77 1
my $a = do $file16; die $@@ if $@@;
d79 3
a81 5
my $file17 = tempfile();
if (open my $do, '>', $file17) {
    print $do "isnt(wantarray, undef, 'do in list context');\n";
    print $do "cmp_ok(wantarray, '!=', 0, 'do in list context');\n";
    close $do or die "Could not close: $!";
d84 1
a84 1
my @@a = do $file17; die $@@ if $@@;
d86 3
a88 4
my $file18 = tempfile();
if (open my $do, '>', $file18) {
    print $do "is(wantarray, undef, 'do in void context');\n";
    close $do or die "Could not close: $!";
d91 1
a91 1
do $file18; die $@@ if $@@;
d95 1
a95 1
is($@@, '', "do on a non-existing file, first try");
d98 1
a98 1
is($@@, '', "do on a non-existing file, second try");
d101 1
a101 5
$! = 0;
my $do6 = do 6;
my $errno = $1;
is($do6, undef, 'do 6 must be interpreted as a filename');
isnt($!, 0, 'and should set $!');
d104 2
a105 6
my ($u, @@t);
{
    no warnings 'uninitialized';
    push @@t, ($u = (do {} . "This should be pushed."));
}
is($#t, 0, "empty do result value" );
d107 3
a109 3
my $zok = '';
my $owww = do { 1 if $zok };
is($owww, '', 'last is unless');
d111 1
a111 1
is($owww, 1, 'last is if not');
d115 1
a115 1
is($owww, 'swish', 'last is unless');
d117 1
a117 1
is($owww, '', 'last is if not');
d121 2
a122 2
my $x = sub { do { return do { @@a } }; 2 }->();
is($x, 1, 'return do { } receives caller scalar context');
d124 1
a124 1
is("@@x", "7", 'return do { } receives caller list context');
d128 1
a128 1
is($x, 2, 'return do { ; } receives caller scalar context');
d130 1
a130 1
is("@@x", "7 8", 'return do { ; } receives caller list context');
d132 1
a132 1
my @@b = (11 .. 15);
d134 1
a134 1
is($x, 5, 'return do { ; , } receives caller scalar context');
d136 1
a136 1
is("@@x", "7 8 11 12 13 14 15", 'return do { ; , } receives caller list context');
d139 1
a139 1
is($x, 5, 'return do { ; }, do { ; } receives caller scalar context');
d141 1
a141 1
is("@@x", "7 8 11 12 13 14 15", 'return do { ; }, do { ; } receives caller list context');
d145 1
a145 1
is($x, 3, 'do { return } receives caller scalar context');
d147 1
a147 1
is("@@x", "7 8 9", 'do { return } receives caller list context');
d151 1
a151 1
is($x, 4, 'return do { do { ; } } receives caller scalar context');
d153 1
a153 68
is("@@x", "7 8 9 10", 'return do { do { ; } } receives caller list context');

# More tests about context propagation below return()
@@a = (11, 12);
@@b = (21, 22, 23);

my $test_code = sub {
    my ($x, $y) = @@_;
    if ($x) {
	return $y ? do { my $z; @@a } : do { my $z; @@b };
    } else {
	return (
	    do { my $z; @@a },
	    (do { my$z; @@b }) x $y
	);
    }
    'xxx';
};

$x = $test_code->(1, 1);
is($x, 2, 'return $y ? do { } : do { } - scalar context 1');
$x = $test_code->(1, 0);
is($x, 3, 'return $y ? do { } : do { } - scalar context 2');
@@x = $test_code->(1, 1);
is("@@x", '11 12', 'return $y ? do { } : do { } - list context 1');
@@x = $test_code->(1, 0);
is("@@x", '21 22 23', 'return $y ? do { } : do { } - list context 2');

$x = $test_code->(0, 0);
is($x, "", 'return (do { }, (do { }) x ...) - scalar context 1');
$x = $test_code->(0, 1);
is($x, 3, 'return (do { }, (do { }) x ...) - scalar context 2');
@@x = $test_code->(0, 0);
is("@@x", '11 12', 'return (do { }, (do { }) x ...) - list context 1');
@@x = $test_code->(0, 1);
is("@@x", '11 12 21 22 23', 'return (do { }, (do { }) x ...) - list context 2');

$test_code = sub {
    my ($x, $y) = @@_;
    if ($x) {
	return do {
	    if ($y == 0) {
		my $z;
		@@a;
	    } elsif ($y == 1) {
		my $z;
		@@b;
	    } else {
		my $z;
		(wantarray ? reverse(@@a) : '99');
	    }
	};
    }
    'xxx';
};

$x = $test_code->(1, 0);
is($x, 2, 'return do { if () { } elsif () { } else { } } - scalar 1');
$x = $test_code->(1, 1);
is($x, 3, 'return do { if () { } elsif () { } else { } } - scalar 2');
$x = $test_code->(1, 2);
is($x, 99, 'return do { if () { } elsif () { } else { } } - scalar 3');
@@x = $test_code->(1, 0);
is("@@x", '11 12', 'return do { if () { } elsif () { } else { } } - list 1');
@@x = $test_code->(1, 1);
is("@@x", '21 22 23', 'return do { if () { } elsif () { } else { } } - list 2');
@@x = $test_code->(1, 2);
is("@@x", '12 11', 'return do { if () { } elsif () { } else { } } - list 3');
d158 1
a158 1
is($x, 20, 'if (1) { $x } receives caller scalar context');
d162 1
a162 1
is($x, 3, 'if (1) { @@a } receives caller scalar context');
d164 1
a164 1
is("@@x", "21 22 23", 'if (1) { @@a } receives caller list context');
d167 1
a167 1
is($x, 20, 'if (1) { ...; $x } receives caller scalar context');
d171 1
a171 1
is($x, 4, 'if (1) { ...; @@a } receives caller scalar context');
d173 1
a173 1
is("@@x", "24 25 26 27", 'if (1) { ...; @@a } receives caller list context');
d176 1
a176 1
is($x, 20, 'if (1) { ...; $x } else{} receives caller scalar context');
d180 1
a180 1
is($x, 4, 'if (1) { ...; @@a } else{} receives caller scalar context');
d182 1
a182 1
is("@@x", "24 25 26 27", 'if (1) { ...; @@a } else{} receives caller list context');
d185 1
a185 1
is($x, 20, 'if (0){} else { ...; $x } receives caller scalar context');
d189 1
a189 1
is($x, 4, 'if (0){} else { ...; @@a } receives caller scalar context');
d191 2
a192 1
is("@@x", "24 25 26 27", 'if (0){} else { ...; @@a } receives caller list context');
d194 2
a195 20
# [rt.cpan.org #72767] do "string" should not propagate warning hints
SKIP: {
  skip_if_miniperl("no in-memory files under miniperl", 1);

  my $code = '42; 1';
  # Based on Eval::WithLexicals::_eval_do
  local @@INC = (sub {
    if ($_[1] eq '/eval_do') {
      open my $fh, '<', \$code;
      $fh;
    } else {
      ();
    }
  }, @@INC);
  local $^W;
  use warnings;
  my $w;
  local $SIG{__WARN__} = sub { warn shift; ++$w };
  do '/eval_do' or die $@@;
  is($w, undef, 'do STRING does not propagate warning hints');
a196 2

done_testing();
@


1.1.1.10
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d3 1
a3 5
BEGIN {
    chdir 't';
    @@INC = '../lib';
    require './test.pl';
}
a286 22
}

# RT#113730 - $@@ should be cleared on IO error.
{
    $@@ = "should not see";
    $! = 0;
    my $rv = do("some nonexistent file");
    my $saved_error = $@@;
    my $saved_errno = $!;
    ok(!$rv,          "do returns false on io errror");
    ok(!$saved_error, "\$\@@ not set on io error");
    ok($saved_errno,  "\$! set on io error");
}

# do subname should not be do "subname"
{
    my $called;
    sub fungi { $called .= "fungible" }
    $@@ = "scrimptious scrobblings";
    do fungi;
    is $called, "fungible", "do-file does not force bareword";
    isnt $@@, "scrimptious scrobblings", "It was interpreted as do-file";
@


1.1.1.11
log
@Import perl-5.20.1
@
text
@d11 32
d44 1
a44 1
my $result = do{ ++$called; 'value';};
d48 20
d134 1
a134 1
my @@x = sub { do { return do { @@a } }; 2 }->();
a312 20
}

# do CORE () has always been do-file
{
    my $called;
    sub CORE { $called .= "fungible" }
    $@@ = "scromptious scrimblings";
    do CORE();
    is $called, "fungible", "do CORE() calls &CORE";
    isnt $@@, "scromptious scrimblings", "It was interpreted as do-file";
}

# do subname() and $subname() are no longer allowed
{
    sub subname { fail('do subname('. ($_[0] || '') .') called') };
    my $subref = sub { fail('do $subref('. ($_[0] || '') .') called') };
    foreach my $mode (qw(subname("arg") subname() $subref("arg") $subref())) {
        eval "do $mode";
        like $@@, qr/\Asyntax error/, "do $mode is syntax error";
    }
@


