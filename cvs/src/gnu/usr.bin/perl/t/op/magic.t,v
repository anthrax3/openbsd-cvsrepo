head	1.16;
access;
symbols
	OPENBSD_6_2_BASE:1.16
	PERL_5_24_2:1.1.1.15
	OPENBSD_6_1:1.16.0.4
	OPENBSD_6_1_BASE:1.16
	OPENBSD_6_0:1.15.0.10
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.15.0.4
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.15.0.6
	OPENBSD_5_8_BASE:1.15
	PERL_5_20_2:1.1.1.14
	OPENBSD_5_7:1.15.0.2
	OPENBSD_5_7_BASE:1.15
	PERL_5_20_1:1.1.1.14
	OPENBSD_5_6:1.14.0.4
	OPENBSD_5_6_BASE:1.14
	PERL_5_18_2:1.1.1.13
	PERL:1.1.1
	OPENBSD_5_5:1.13.0.6
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.2
	OPENBSD_5_4_BASE:1.13
	PERL_5_16_3:1.1.1.12
	OPENBSD_5_3:1.12.0.10
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.8
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.6
	OPENBSD_5_0:1.12.0.4
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.2
	OPENBSD_4_9_BASE:1.12
	PERL_5_12_2:1.1.1.11
	OPENBSD_4_8:1.11.0.4
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.2
	OPENBSD_4_7_BASE:1.11
	PERL_5_10_1:1.1.1.10
	OPENBSD_4_6:1.10.0.6
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.2
	OPENBSD_4_5_BASE:1.10
	PERL_5_10_0:1.1.1.9
	OPENBSD_4_4:1.9.0.10
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.8
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.6
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.4
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9
	PERL_5_8_8:1.1.1.8
	OPENBSD_3_9:1.8.0.8
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.6
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.4
	OPENBSD_3_7_BASE:1.8
	PERL_5_8_6:1.1.1.7
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	PERL_5_8_5:1.1.1.7
	PERL_5_8_3:1.1.1.6
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.16
date	2017.02.05.00.32.20;	author afresh1;	state Exp;
branches;
next	1.15;
commitid	cxJ08BvJA9Pt2PTM;

1.15
date	2014.11.17.20.57.07;	author afresh1;	state Exp;
branches;
next	1.14;
commitid	QP75iYx42Uo7mMxO;

1.14
date	2014.03.24.15.05.33;	author afresh1;	state Exp;
branches;
next	1.13;

1.13
date	2013.03.25.20.40.59;	author sthen;	state Exp;
branches;
next	1.12;

1.12
date	2010.09.24.15.07.08;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2009.10.12.18.30.27;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2008.09.29.17.36.19;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2006.03.28.19.23.12;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2004.08.09.18.10.27;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.48;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.37;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.36.19;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.08.26;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.52.36;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.08.05.27;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.13.19;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.13.19;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.41.46;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.10.49;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.25.40;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.15.10;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.44.32;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.08.09.17.48.35;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2006.03.28.18.49.45;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2008.09.29.17.19.01;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2009.10.12.18.10.44;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2010.09.24.14.49.18;	author millert;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2013.03.25.20.09.36;	author sthen;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2014.03.24.14.59.10;	author afresh1;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2014.11.17.20.53.18;	author afresh1;	state Exp;
branches;
next	1.1.1.15;
commitid	B31cAbBIXiCqnL97;

1.1.1.15
date	2017.08.14.13.46.24;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.16
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl

BEGIN {
    $| = 1;
    chdir 't' if -d 't';
    @@INC = '../lib';
    require './test.pl';
    plan (tests => 192);
}

# Test that defined() returns true for magic variables created on the fly,
# even before they have been created.
# This must come first, even before turning on warnings or setting up
# $SIG{__WARN__}, to avoid invalidating the tests.  warnings.pm currently
# does not mention any special variables, but that could easily change.
BEGIN {
    # not available in miniperl
    my %non_mini = map { $_ => 1 } qw(+ - [);
    for (qw(
	SIG ^OPEN ^TAINT ^UNICODE ^UTF8LOCALE ^WARNING_BITS 1 2 3 4 5 6 7 8
	9 42 & ` ' : ? ! _ - [ ^ ~ = % . ( ) < > \ / $ | + ; ] ^A ^C ^D
	^E ^F ^H ^I ^L ^N ^O ^P ^S ^T ^V ^W ^UTF8CACHE ::12345 main::98732
	^LAST_FH
    )) {
	my $v = $_;
	# avoid using any global vars here:
	if ($v =~ s/^\^(?=.)//) {
	    for(substr $v, 0, 1) {
		$_ = chr(utf8::native_to_unicode(ord($_)) - 64);
	    }
	}
	SKIP:
	{
	    skip_if_miniperl("the module for *$_ may not be available in "
			     . "miniperl", 1) if $non_mini{$_};
	    ok defined *$v, "*$_ appears to be defined at the outset";
	}
    }
}

# This must be in a separate BEGIN block, as the mere mention of ${^TAINT}
# will invalidate the test for it.
BEGIN {
    $ENV{PATH} = '/bin' if ${^TAINT};
    $SIG{__WARN__} = sub { die "Dying on warning: ", @@_ };
}

use warnings;
use Config;


$Is_MSWin32  = $^O eq 'MSWin32';
$Is_NetWare  = $^O eq 'NetWare';
$Is_VMS      = $^O eq 'VMS';
$Is_Dos      = $^O eq 'dos';
$Is_os2      = $^O eq 'os2';
$Is_Cygwin   = $^O eq 'cygwin';

$PERL =
   ($Is_NetWare ? 'perl'   :
    $Is_VMS     ? $^X      :
    $Is_MSWin32 ? '.\perl' :
                  './perl');

sub env_is {
    my ($key, $val, $desc) = @@_;

    use open IN => ":raw";
    if ($Is_MSWin32) {
        # cmd.exe will echo 'variable=value' but 4nt will echo just the value
        # -- Nikola Knezevic
	require Win32;
	my $cp = Win32::GetConsoleOutputCP();
	Win32::SetConsoleOutputCP(Win32::GetACP());
        (my $set = `set $key 2>nul`) =~ s/\r\n$/\n/;
	Win32::SetConsoleOutputCP($cp);
        like $set, qr/^(?:\Q$key\E=)?\Q$val\E$/, $desc;
    } elsif ($Is_VMS) {
        my $eqv = `write sys\$output f\$trnlnm("\Q$key\E")`;
        # A single null byte in the equivalence string means
        # an undef value for Perl, so mimic that here.
        $eqv = "\n" if length($eqv) == 2 and $eqv eq "\000\n";
        is $eqv, "$val\n", $desc;
    } else {
        my @@env = `env`;
        SKIP: {
            skip("env doesn't work on this android", 1) if !@@env && $^O =~ /android/;
            chomp (my @@env = grep { s/^$key=// } @@env);
            is "@@env", $val, $desc;
        }
    }
}

END {
    # On VMS, environment variable changes are peristent after perl exits
    if ($Is_VMS) {
        delete $ENV{'FOO'};
        delete $ENV{'__NoNeSuCh'};
        delete $ENV{'__NoNeSuCh2'};
    }
}

eval '$ENV{"FOO"} = "hi there";';	# check that ENV is inited inside eval
# cmd.exe will echo 'variable=value' but 4nt will echo just the value
# -- Nikola Knezevic
if ($Is_MSWin32)  { like `set FOO`, qr/^(?:FOO=)?hi there$/; }
elsif ($Is_VMS)   { is `write sys\$output f\$trnlnm("FOO")`, "hi there\n"; }
else              { is `echo \$FOO`, "hi there\n"; }

unlink_all 'ajslkdfpqjsjfk';
$! = 0;
open(FOO,'ajslkdfpqjsjfk');
isnt($!, 0, "Unlinked file can't be opened");
close FOO; # just mention it, squelch used-only-once

SKIP: {
    skip('SIGINT not safe on this platform', 5)
	if $Is_MSWin32 || $Is_NetWare || $Is_Dos;
  # the next tests are done in a subprocess because sh spits out a
  # newline onto stderr when a child process kills itself with SIGINT.
  # We use a pipe rather than system() because the VMS command buffer
  # would overflow with a command that long.

    # For easy interpolation of test numbers:
    $next_test = curr_test() - 1;
    sub TIEARRAY {bless[]}
    sub FETCH { $next_test + pop }
    tie my @@tn, __PACKAGE__;

    open( CMDPIPE, "|-", $PERL);

    print CMDPIPE "\$t1 = $tn[1]; \$t2 = $tn[2];\n", <<'END';

    $| = 1;		# command buffering

    $SIG{"INT"} = "ok1";     kill "INT",$$; sleep 1;
    $SIG{"INT"} = "IGNORE";  kill "INT",$$; sleep 1; print "ok $t2\n";
    $SIG{"INT"} = "DEFAULT"; kill "INT",$$; sleep 1; print" not ok $t2\n";

    sub ok1 {
	if (($x = pop(@@_)) eq "INT") {
	    print "ok $t1\n";
	}
	else {
	    print "not ok $t1 ($x @@_)\n";
	}
    }

END

    close CMDPIPE;

    open( CMDPIPE, "|-", $PERL);
    print CMDPIPE "\$t3 = $tn[3];\n", <<'END';

    { package X;
	sub DESTROY {
	    kill "INT",$$;
	}
    }
    sub x {
	my $x=bless [], 'X';
	return sub { $x };
    }
    $| = 1;		# command buffering
    $SIG{"INT"} = "ok3";
    {
	local $SIG{"INT"}=x();
	print ""; # Needed to expose failure in 5.8.0 (why?)
    }
    sleep 1;
    delete $SIG{"INT"};
    kill "INT",$$; sleep 1;
    sub ok3 {
	print "ok $t3\n";
    }
END
    close CMDPIPE;
    $? >>= 8 if $^O eq 'VMS'; # POSIX status hiding in 2nd byte
    my $todo = ($^O eq 'os2' ? ' # TODO: EMX v0.9d_fix4 bug: wrong nibble? ' : '');
    $todo = ($Config{usecrosscompile} ? '# TODO: Not sure whats going on here when cross-compiling' : '');
    print $? & 0xFF ? "ok $tn[4]$todo\n" : "not ok $tn[4]$todo\n";

    open(CMDPIPE, "|-", $PERL);
    print CMDPIPE <<'END';

    sub PVBM () { 'foo' }
    index 'foo', PVBM;
    my $pvbm = PVBM;

    sub foo { exit 0 }

    $SIG{"INT"} = $pvbm;
    kill "INT", $$; sleep 1;
END
    close CMDPIPE;
    $? >>= 8 if $^O eq 'VMS';
    print $? ? "not ok $tn[5]\n" : "ok $tn[5]\n";

    curr_test(curr_test() + 5);
}

# can we slice ENV?
@@val1 = @@ENV{keys(%ENV)};
@@val2 = values(%ENV);
is join(':',@@val1), join(':',@@val2);
cmp_ok @@val1, '>', 1;

# deleting $::{ENV}
is runperl(prog => 'delete $::{ENV}; chdir; print qq-ok\n-'), "ok\n",
  'deleting $::{ENV}';

# regex vars
'foobarbaz' =~ /b(a)r/;
is $`, 'foo';
is $&, 'bar';
is $', 'baz';
is $+, 'a';

# [perl #24237]
for (qw < ` & ' >) {
 fresh_perl_is
  qq < \@@$_; q "fff" =~ /(?!^)./; print "[\$$_]\\n" >,
  "[f]\n", {},
  "referencing \@@$_ before \$$_ etc. still saws off ampersands";
}

# $"
@@a = qw(foo bar baz);
is "@@a", "foo bar baz";
{
    local $" = ',';
    is "@@a", "foo,bar,baz";
}

# $;
%h = ();
$h{'foo', 'bar'} = 1;
is((keys %h)[0], "foo\034bar");
{
    local $; = 'x';
    %h = ();
    $h{'foo', 'bar'} = 1;
    is((keys %h)[0], 'fooxbar');
}

# $?, $@@, $$
system qq[$PERL "-I../lib" -e "use vmsish qw(hushed); exit(0)"];
is $?, 0;
system qq[$PERL "-I../lib" -e "use vmsish qw(hushed); exit(1)"];
isnt $?, 0;

eval { die "foo\n" };
is $@@, "foo\n";

ok !*@@{HASH}, 'no %@@';

cmp_ok($$, '>', 0);
my $pid = $$;
eval { $$ = 42 };
is $$, 42, '$$ can be modified';
SKIP: {
    skip "no fork", 1 unless $Config{d_fork};
    (my $kidpid = open my $fh, "-|") // skip "cannot fork: $!", 1;
    if($kidpid) { # parent
	my $kiddollars = <$fh>;
	close $fh or die "cannot close pipe from kid proc: $!";
	is $kiddollars, $kidpid, '$$ is reset on fork';
    }
    else { # child
	print $$;
	$::NO_ENDING = 1; # silence "Looks like you only ran..."
	exit;
    }
}
$$ = $pid; # Tests below use $$

# $^X and $0
{
    my $is_abs = $Config{d_procselfexe} || $Config{usekernprocpathname}
      || $Config{usensgetexecutablepath};
    if ($^O eq 'qnx') {
	chomp($wd = `/usr/bin/fullpath -t`);
    }
    elsif($^O =~ /android/) {
        chomp($wd = `sh -c 'pwd'`);
    }
    elsif($Is_Cygwin || $is_abs) {
       # Cygwin turns the symlink into the real file
       chomp($wd = `pwd`);
       $wd =~ s#/t$##;
       $wd =~ /(.*)/; $wd = $1; # untaint
       if ($Is_Cygwin) {
	   $wd = Cygwin::win_to_posix_path(Cygwin::posix_to_win_path($wd, 1));
       }
    }
    elsif($Is_os2) {
       $wd = Cwd::sys_cwd();
    }
    else {
	$wd = '.';
    }
    my $perl = $Is_VMS || $is_abs ? $^X : "$wd/perl";
    my $headmaybe = '';
    my $middlemaybe = '';
    my $tailmaybe = '';
    $script = "$wd/show-shebang";
    if ($Is_MSWin32) {
	chomp($wd = `cd`);
	$wd =~ s|\\|/|g;
	$perl = "$wd/perl.exe";
	$script = "$wd/show-shebang.bat";
	$headmaybe = <<EOH ;
\@@rem ='
\@@echo off
$perl -x \%0
goto endofperl
\@@rem ';
EOH
	$tailmaybe = <<EOT ;

__END__
:endofperl
EOT
    }
    elsif ($Is_os2) {
      $script = "./show-shebang";
    }
    elsif ($Is_VMS) {
      $script = "[]show-shebang";
    }
    elsif ($Is_Cygwin) {
      $middlemaybe = <<'EOX'
$^X = Cygwin::win_to_posix_path(Cygwin::posix_to_win_path($^X, 1));
$0 = Cygwin::win_to_posix_path(Cygwin::posix_to_win_path($0, 1));
EOX
    }
    if ($^O eq 'os390' or $^O eq 'posix-bc') {  # no shebang
	$headmaybe = <<EOH ;
    eval 'exec ./perl -S \$0 \${1+"\$\@@"}'
        if 0;
EOH
    }
    $s1 = "\$^X is $perl, \$0 is $script\n";
    ok open(SCRIPT, ">$script") or diag "Can't write to $script: $!";
    ok print(SCRIPT $headmaybe . <<EOB . $middlemaybe . <<'EOF' . $tailmaybe) or diag $!;
#!$perl
EOB
print "\$^X is $^X, \$0 is $0\n";
EOF
    ok close(SCRIPT) or diag $!;
    ok chmod(0755, $script) or diag $!;
    $_ = $Is_VMS ? `$perl $script` : `$script`;
    s/\.exe//i if $Is_Dos or $Is_Cygwin or $Is_os2;
    s{is perl}{is $perl}; # for systems where $^X is only a basename
    s{\\}{/}g;
    if ($Is_MSWin32 || $Is_os2) {
	is uc $_, uc $s1;
    } else {
  SKIP:
     {
	  skip "# TODO: Hit bug posix-2058; exec does not setup argv[0] correctly." if ($^O eq "vos");
	  is $_, $s1;
     }
    }
    $_ = `$perl $script`;
    s/\.exe//i if $Is_Dos or $Is_os2 or $Is_Cygwin;
    s{\\}{/}g;
    if ($Is_MSWin32 || $Is_os2) {
	is uc $_, uc $s1;
    } else {
	is $_, $s1;
    }
    ok unlink($script) or diag $!;
    # CHECK
    # Could this be replaced with:
    # unlink_all($script);
}

# $], $^O, $^T
cmp_ok $], '>=', 5.00319;
ok $^O;
cmp_ok $^T, '>', 850000000;

# Test change 25062 is working
my $orig_osname = $^O;
{
local $^I = '.bak';
is $^O, $orig_osname, 'Assigning $^I does not clobber $^O';
}
$^O = $orig_osname;

{
    #RT #72422
    foreach my $p (0, 1) {
	fresh_perl_is(<<"EOP", '2 4 8', undef, "test \$^P = $p");
\$DB::single = 2;
\$DB::trace = 4;
\$DB::signal = 8;
\$^P = $p;
print "\$DB::single \$DB::trace \$DB::signal";
EOP
    }
}

# Check that assigning to $0 on Linux sets the process name with both
# argv[0] assignment and by calling prctl()
{
  SKIP: {
    skip "We don't have prctl() here, or we're on Android", 2 unless $Config{d_prctl_set_name} && $^O ne 'android';

    # We don't really need these tests. prctl() is tested in the
    # Kernel, but test it anyway for our sanity. If something doesn't
    # work (like if the system doesn't have a ps(1) for whatever
    # reason) just bail out gracefully.
    my $maybe_ps = sub {
        my ($cmd) = @@_;
        local ($?, $!);

        no warnings;
        my $res = `$cmd`;
        skip "Couldn't shell out to '$cmd', returned code $?", 2 if $?;
        return $res;
    };

    my $name = "Good Morning, Dave";
    $0 = $name;

    chomp(my $argv0 = $maybe_ps->("ps h $$"));
    chomp(my $prctl = $maybe_ps->("ps hc $$"));

    like($argv0, qr/$name/, "Set process name through argv[0] ($argv0)");
    my $name_substr = substr($name, 0, 15);
    like($prctl, qr/$name_substr/, "Set process name through prctl() ($prctl)");
  }
}

{
    my $ok = 1;
    my $warn = '';
    local $SIG{'__WARN__'} = sub { $ok = 0; $warn = join '', @@_; $warn =~ s/\n$//; };
    $! = undef;
    local $TODO = $Is_VMS ? "'\$!=undef' does throw a warning" : '';
    ok($ok, $warn);
}

SKIP: {
    skip_if_miniperl("miniperl can't rely on loading %Errno", 2);
   no warnings 'void';

# Make sure Errno hasn't been prematurely autoloaded

   ok !keys %Errno::;

# Test auto-loading of Errno when %! is used

   ok scalar eval q{
      %!;
      scalar %Errno::;
   }, $@@;
}

SKIP:  {
    skip_if_miniperl("miniperl can't rely on loading %Errno", 2);
    # Make sure that Errno loading doesn't clobber $!

    undef %Errno::;
    delete $INC{"Errno.pm"};

    open(FOO, "nonesuch"); # Generate ENOENT
    my %errs = %{"!"}; # Cause Errno.pm to be loaded at run-time
    ok ${"!"}{ENOENT};

    # Make sure defined(*{"!"}) before %! does not stop %! from working
    is
      runperl(
	prog => 'BEGIN { defined *{q-!-} } print qq-ok\n- if tied %!',
      ),
     "ok\n",
     'defined *{"!"} does not stop %! from working';
}

# Check that we don't auto-load packages
foreach (['powie::!', 'Errno'],
	 ['powie::+', 'Tie::Hash::NamedCapture']) {
    my ($symbol, $package) = @@$_;
    SKIP: {
	(my $extension = $package) =~ s|::|/|g;
	skip "$package is statically linked", 2
	    if $Config{static_ext} =~ m|\b\Q$extension\E\b|;
	foreach my $scalar_first ('', '$$symbol;') {
	    my $desc = qq{Referencing %{"$symbol"}};
	    $desc .= qq{ after mentioning \${"$symbol"}} if $scalar_first;
	    $desc .= " doesn't load $package";

	    fresh_perl_is(<<"EOP", 0, {}, $desc);
use strict qw(vars subs);
my \$symbol = '$symbol';
$scalar_first;
1 if %{\$symbol};
print scalar %${package}::;
EOP
	}
    }
}

is $^S, 0;
eval { is $^S,1 };
eval " BEGIN { ok ! defined \$^S } ";
is $^S, 0;

my $taint = ${^TAINT};
is ${^TAINT}, $taint;
eval { ${^TAINT} = 1 };
is ${^TAINT}, $taint;

# 5.6.1 had a bug: @@+ and @@- were not properly interpolated
# into double-quoted strings
# 20020414 mjd-perl-patch+@@plover.com
"I like pie" =~ /(I) (like) (pie)/;
is "@@-",  "0 0 2 7";
is "@@+", "10 1 6 10";

# Tests for the magic get of $\
{
    my $ok = 0;
    # [perl #19330]
    {
	local $\ = undef;
	$\++; $\++;
	$ok = $\ eq 2;
    }
    ok $ok;
    $ok = 0;
    {
	local $\ = "a\0b";
	$ok = "a$\b" eq "aa\0bb";
    }
    ok $ok;
}

# Test for bug [perl #36434]
# Can not do this test on VMS, and SYMBIAN according to comments
# in mg.c/Perl_magic_clear_all_env()
SKIP: {
    skip('Can\'t make assignment to \%ENV on this system', 3) if $Is_VMS;

    local @@ISA;
    local %ENV;
    # This used to be __PACKAGE__, but that causes recursive
    #  inheritance, which is detected earlier now and broke
    #  this test
    eval { push @@ISA, __FILE__ };
    is $@@, '', 'Push a constant on a magic array';
    $@@ and print "# $@@";
    eval { %ENV = (PATH => __PACKAGE__) };
    is $@@, '', 'Assign a constant to a magic hash';
    $@@ and print "# $@@";
    eval { my %h = qw(A B); %ENV = (PATH => (keys %h)[0]) };
    is $@@, '', 'Assign a shared key to a magic hash';
    $@@ and print "# $@@";
}

# Tests for Perl_magic_clearsig
foreach my $sig (qw(__WARN__ INT)) {
    $SIG{$sig} = lc $sig;
    is $SIG{$sig}, 'main::' . lc $sig, "Can assign to $sig";
    is delete $SIG{$sig}, 'main::' . lc $sig, "Can delete from $sig";
    is $SIG{$sig}, undef, "$sig is now gone";
    is delete $SIG{$sig}, undef, "$sig remains gone";
}

# And now one which doesn't exist;
{
    no warnings 'signal';
    $SIG{HUNGRY} = 'mmm, pie';
}
is $SIG{HUNGRY}, 'mmm, pie', 'Can assign to HUNGRY';
is delete $SIG{HUNGRY}, 'mmm, pie', 'Can delete from HUNGRY';
is $SIG{HUNGRY}, undef, "HUNGRY is now gone";
is delete $SIG{HUNGRY}, undef, "HUNGRY remains gone";

# Test deleting signals that we never set
foreach my $sig (qw(__DIE__ _BOGUS_HOOK KILL THIRSTY)) {
    is $SIG{$sig}, undef, "$sig is not present";
    is delete $SIG{$sig}, undef, "delete of $sig returns undef";
}

{
    $! = 9999;
    is int $!, 9999, q{[perl #72850] Core dump in bleadperl from perl -e '$! = 9999; $a = $!;'};

}

# %+ %-
SKIP: {
    skip_if_miniperl("No XS in miniperl", 2);
    # Make sure defined(*{"+"}) before %+ does not stop %+ from working
    is
      runperl(
	prog => 'BEGIN { defined *{q-+-} } print qq-ok\n- if tied %+',
      ),
     "ok\n",
     'defined *{"+"} does not stop %+ from working';
    is
      runperl(
	prog => 'BEGIN { defined *{q=-=} } print qq-ok\n- if tied %-',
      ),
     "ok\n",
     'defined *{"-"} does not stop %- from working';
}

SKIP: {
    skip_if_miniperl("No XS in miniperl", 3);

    for ( [qw( %- Tie::Hash::NamedCapture )], [qw( $[ arybase )],
          [qw( %! Errno )] ) {
	my ($var, $mod) = @@$_;
	my $modfile = $mod =~ s|::|/|gr . ".pm";
	fresh_perl_is
	   qq 'sub UNIVERSAL::AUTOLOAD{}
	       $mod\::foo() if 0;
	       $var;
	       print "ok\\n" if \$INC{"$modfile"}',
	  "ok\n",
	   { switches => [ '-X' ] },
	  "$var still loads $mod when stash and UNIVERSAL::AUTOLOAD exist";
    }
}

# ${^LAST_FH}
() = tell STDOUT;
is ${^LAST_FH}, \*STDOUT, '${^LAST_FH} after tell';
() = tell STDIN;
is ${^LAST_FH}, \*STDIN, '${^LAST_FH} after another tell';
{
    my $fh = *STDOUT;
    () = tell $fh;
    is ${^LAST_FH}, \$fh, '${^LAST_FH} referencing lexical coercible glob';
}
# This also tests that ${^LAST_FH} is a weak reference:
is ${^LAST_FH}, undef, '${^LAST_FH} is undef when PL_last_in_gv is NULL';


# $|
fresh_perl_is 'print $| = ~$|', "1\n", {switches => ['-l']},
 '[perl #4760] print $| = ~$|';
fresh_perl_is
 'select f; undef *f; ${q/|/}; print STDOUT qq|ok\n|', "ok\n", {},
 '[perl #115206] no crash when vivifying $| while *{+select}{IO} is undef';

# ${^OPEN} and $^H interaction
# Setting ${^OPEN} causes $^H to change, but setting $^H would only some-
# times make ${^OPEN} change, depending on whether it was in the same BEGIN
# block.  Don’t test actual values (subject to change); just test for
# consistency.
my @@stuff;
eval '
    BEGIN { ${^OPEN} = "a\0b"; $^H = 0;          push @@stuff, ${^OPEN} }
    BEGIN { ${^OPEN} = "a\0b"; $^H = 0 } BEGIN { push @@stuff, ${^OPEN} }
1' or die $@@;
is $stuff[0], $stuff[1], '$^H modifies ${^OPEN} consistently';

# deleting $::{"\cH"}
is runperl(prog => 'delete $::{qq-\cH-}; ${^OPEN}=foo; print qq-ok\n-'),
  "ok\n",
  'deleting $::{"\cH"}';

# Tests for some non-magic names:
is ${^MPE}, undef, '${^MPE} starts undefined';
is ++${^MPE}, 1, '${^MPE} can be incremented';

# This one used to behave as ${^MATCH} due to a missing break:
is ${^MPEN}, undef, '${^MPEN} starts undefined';
# This one used to croak due to that missing break:
is ++${^MPEN}, 1, '${^MPEN} can be incremented';

eval { ${^E_NCODING} = 1 };
like $@@, qr/^Modification of a /, 'Setting ${^E_NCODING} croaks';
$_ = ${^E_NCODING};
pass('can read ${^E_NCODING} without blowing up');
is $_, undef, '${^E_NCODING} is undef';

{
    my $warned = 0;
    local $SIG{__WARN__} = sub { ++$warned if $_[0] =~ /Use of uninitialized value in unshift/; print "# @@_"; };
    unshift @@RT12608::A::ISA, qw(RT12608::B RT12608::C);
    is $warned, 0, '[perl #126082] unshifting onto @@ISA doesn\'t trigger set magic for each item';
}

{
    my $warned = 0;
    local $SIG{__WARN__} = sub { ++$warned if $_[0] =~ /Use of uninitialized value in unshift/; print "# @@_"; };

    my $x; tie $x, 'RT12608::F';
    unshift @@RT12608::X::ISA, $x, "RT12608::Z";
    is $warned, 0, '[perl #126082] PL_delaymagic correctly/saved restored when pushing/unshifting onto @@ISA';

    package RT12608::F;
    use parent 'Tie::Scalar';
    sub TIESCALAR { bless {}; }
    sub FETCH { push @@RT12608::G::ISA, "RT12608::H"; "RT12608::Y"; }
}

# ^^^^^^^^^ New tests go here ^^^^^^^^^

SKIP: {
    skip("%ENV manipulations fail or aren't safe on $^O", 20)
	if $Is_Dos;
    skip "Win32 needs XS for env/shell tests", 20
        if $Is_MSWin32 && is_miniperl;

 SKIP: {
	skip("clearing \%ENV is not safe when running under valgrind or on VMS")
	    if $ENV{PERL_VALGRIND} || $Is_VMS;

	    $PATH = $ENV{PATH};
	    $PDL = $ENV{PERL_DESTRUCT_LEVEL} || 0;
	    $ENV{foo} = "bar";
	    %ENV = ();
	    $ENV{PATH} = $PATH;
	    $ENV{PERL_DESTRUCT_LEVEL} = $PDL || 0;
	    if ($Is_MSWin32) {
		is `set foo 2>NUL`, "";
	    } else {
		is `echo \$foo`, "\n";
	    }
	}

	$ENV{__NoNeSuCh} = 'foo';
	$0 = 'bar';
	env_is(__NoNeSuCh => 'foo', 'setting $0 does not break %ENV');

	$ENV{__NoNeSuCh2} = 'foo';
	$ENV{__NoNeSuCh2} = undef;
	env_is(__NoNeSuCh2 => '', 'setting a key as undef does not delete it');

	# stringify a glob
	$ENV{foo} = *TODO;
	env_is(foo => '*main::TODO', 'ENV store of stringified glob');

	# stringify a ref
	my $ref = [];
	$ENV{foo} = $ref;
	env_is(foo => "$ref", 'ENV store of stringified ref');

	# downgrade utf8 when possible
	$bytes = "eh zero \x{A0}";
	utf8::upgrade($chars = $bytes);
	$forced = $ENV{foo} = $chars;
	ok(!utf8::is_utf8($forced) && $forced eq $bytes, 'ENV store downgrades utf8 in SV');
	env_is(foo => $bytes, 'ENV store downgrades utf8 in setenv');

	# warn when downgrading utf8 is not possible
	$chars = "X-Day \x{1998}";
	utf8::encode($bytes = $chars);
	{
	  my $warned = 0;
	  local $SIG{__WARN__} = sub { ++$warned if $_[0] =~ /^Wide character in setenv/; print "# @@_" };
	  $forced = $ENV{foo} = $chars;
	  ok($warned == 1, 'ENV store warns about wide characters');
	}
	ok(!utf8::is_utf8($forced) && $forced eq $bytes, 'ENV store encodes high utf8 in SV');
	env_is(foo => $bytes, 'ENV store encodes high utf8 in SV');

	# test local $ENV{foo} on existing foo
	{
	  local $ENV{__NoNeSuCh};
	  { local $TODO = 'exists on %ENV should reflect real env';
	    ok(!exists $ENV{__NoNeSuCh}, 'not exists $ENV{existing} during local $ENV{existing}'); }
	  env_is(__NoNeLoCaL => '');
	}
	ok(exists $ENV{__NoNeSuCh}, 'exists $ENV{existing} after local $ENV{existing}');
	env_is(__NoNeSuCh => 'foo');

	# test local $ENV{foo} on new foo
	{
	  local $ENV{__NoNeLoCaL} = 'foo';
	  ok(exists $ENV{__NoNeLoCaL}, 'exists $ENV{new} during local $ENV{new}');
	  env_is(__NoNeLoCaL => 'foo');
	}
	ok(!exists $ENV{__NoNeLoCaL}, 'not exists $ENV{new} after local $ENV{new}');
	env_is(__NoNeLoCaL => '');

    SKIP: {
	    skip("\$0 check only on Linux and FreeBSD", 2)
		unless $^O =~ /^(linux|android|freebsd)$/
		    && open CMDLINE, "/proc/$$/cmdline";

	    chomp(my $line = scalar <CMDLINE>);
	    my $me = (split /\0/, $line)[0];
	    is $me, $0, 'altering $0 is effective (testing with /proc/)';
	    close CMDLINE;
            skip("\$0 check with 'ps' only on Linux (but not Android) and FreeBSD", 1) if $^O eq 'android';
            # perlbug #22811
            my $mydollarzero = sub {
              my($arg) = shift;
              $0 = $arg if defined $arg;
	      # In FreeBSD the ps -o command= will cause
	      # an empty header line, grab only the last line.
              my $ps = (`ps -o command= -p $$`)[-1];
              return if $?;
              chomp $ps;
              printf "# 0[%s]ps[%s]\n", $0, $ps;
              $ps;
            };
            my $ps = $mydollarzero->("x");
            ok(!$ps  # we allow that something goes wrong with the ps command
	       # In Linux 2.4 we would get an exact match ($ps eq 'x') but
	       # in Linux 2.2 there seems to be something funny going on:
	       # it seems as if the original length of the argv[] would
	       # be stored in the proc struct and then used by ps(1),
	       # no matter what characters we use to pad the argv[].
	       # (And if we use \0:s, they are shown as spaces.)  Sigh.
               || $ps =~ /^x\s*$/
	       # FreeBSD cannot get rid of both the leading "perl :"
	       # and the trailing " (perl)": some FreeBSD versions
	       # can get rid of the first one.
	       || ($^O eq 'freebsd' && $ps =~ m/^(?:perl: )?x(?: \(perl\))?$/),
		       'altering $0 is effective (testing with `ps`)');
	}
}

# test case-insignificance of %ENV (these tests must be enabled only
# when perl is compiled with -DENV_IS_CASELESS)
SKIP: {
    skip('no caseless %ENV support', 4) unless $Is_MSWin32 || $Is_NetWare;

    %ENV = ();
    $ENV{'Foo'} = 'bar';
    $ENV{'fOo'} = 'baz';
    is scalar(keys(%ENV)), 1;
    ok exists $ENV{'FOo'};
    is delete $ENV{'foO'}, 'baz';
    is scalar(keys(%ENV)), 0;
}

__END__

# Put new tests before the various ENV tests, as they blow %ENV away.
@


1.15
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d8 1
a8 1
    plan (tests => 187);
d29 1
a29 1
		$_ = chr ord() - 64;
d432 3
a434 2
    like($argv0, $name, "Set process name through argv[0] ($argv0)");
    like($prctl, substr($name, 0, 15), "Set process name through prctl() ($prctl)");
d678 27
d708 1
a708 1
    skip("%ENV manipulations fail or aren't safe on $^O", 19)
d710 2
@


1.14
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d8 1
a8 1
    plan (tests => 179);
d59 5
a63 5
$PERL = $ENV{PERL}
    || ($Is_NetWare           ? 'perl'   :
       $Is_VMS                ? $^X      :
       $Is_MSWin32            ? '.\perl' :
       './perl');
d85 6
a90 1
        is `echo \$\Q$key\E`, "$val\n", $desc;
d113 1
a113 1
isnt($!, 0);
d130 1
a130 1
    open( CMDPIPE, "| $PERL");
d153 1
a153 1
    open( CMDPIPE, "| $PERL");
d181 1
d184 1
a184 1
    open(CMDPIPE, "| $PERL");
d209 4
d256 2
d285 3
d360 5
a364 1
	is $_, $s1;
d410 1
a410 1
    skip "We don't have prctl() here", 2 unless $Config{d_prctl_set_name};
d483 7
a489 5
SKIP: {
    skip "staticly linked; may be preloaded", 4 unless $Config{usedl};
    foreach (['powie::!', 'Errno'],
	     ['powie::+', 'Tie::Hash::NamedCapture']) {
	my ($symbol, $package) = @@$_;
d645 1
a645 1
fresh_perl_is 'print $| = ~$|', "1\n", {switches => ['-l']}, 
d648 1
a648 1
 'select f; undef *f; ${q/|/}; print STDOUT qq|ok\n|', "ok\n", {}, 
d651 25
d757 1
a757 1
		unless $^O =~ /^(linux|freebsd)$/
d764 1
@


1.13
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d8 1
a8 1
    plan (tests => 156);
d23 1
a57 2
$Is_MPE      = $^O eq 'mpeix';		
$Is_BeOS     = $^O eq 'beos';
d65 24
d91 5
a95 1
    delete $ENV{'FOO'} if $Is_VMS;
d113 1
a113 1
	if $Is_MSWin32 || $Is_NetWare || $Is_Dos || $Is_MPE;
d323 1
a323 1
    if ($^O eq 'os390' or $^O eq 'posix-bc' or $^O eq 'vmesa') {  # no shebang
a339 1
    s{./$script}{$script} if $Is_BeOS; # revert BeOS execvp() side-effect
a348 1
    s{./$perl}{$perl} if $Is_BeOS; # revert BeOS execvp() side-effect
d521 1
a521 1
# Can not do this test on VMS, EPOC, and SYMBIAN according to comments
d609 22
d634 2
a635 2
    skip("%ENV manipulations fail or aren't safe on $^O", 4)
	if $Is_VMS || $Is_Dos;
d638 2
a639 2
	skip("clearing \%ENV is not safe when running under valgrind")
	    if $ENV{PERL_VALGRIND};
d654 51
a704 8
	$ENV{__NoNeSuCh} = "foo";
	$0 = "bar";
# cmd.exe will echo 'variable=value' but 4nt will echo just the value
# -- Nikola Knezevic
    	if ($Is_MSWin32) {
	    like `set __NoNeSuCh`, qr/^(?:__NoNeSuCh=)?foo$/;
	} else {
	    is `echo \$__NoNeSuCh`, "foo\n";
d706 3
@


1.12
log
@merge in perl 5.12.2 plus local changes
@
text
@d7 36
a44 1
    require './test.pl';
a49 1
plan (tests => 80);
a57 1
$Is_miniperl = $ENV{PERL_CORE_MINITEST};
d78 1
a78 1
unlink 'ajslkdfpqjsjfk';
d92 6
d100 1
a100 1
    print CMDPIPE <<'END';
d104 3
a106 3
    $SIG{"INT"} = "ok3";     kill "INT",$$; sleep 1;
    $SIG{"INT"} = "IGNORE";  kill "INT",$$; sleep 1; print "ok 4\n";
    $SIG{"INT"} = "DEFAULT"; kill "INT",$$; sleep 1; print "not ok 4\n";
d108 1
a108 1
    sub ok3 {
d110 1
a110 1
	    print "ok 3\n";
d113 1
a113 1
	    print "not ok 3 ($x @@_)\n";
d122 1
a122 1
    print CMDPIPE <<'END';
d134 1
a134 1
    $SIG{"INT"} = "ok5";
d142 2
a143 2
    sub ok5 {
	print "ok 5\n";
d149 1
a149 1
    print $? & 0xFF ? "ok 6$todo\n" : "not ok 6$todo\n";
d165 1
a165 1
    print $? ? "not ok 7\n" : "ok 7\n";
d183 8
d220 18
a237 2
eval { $$++ };
like ($@@, qr/^Modification of a read-only value attempted/);
d241 2
d246 1
a246 1
    elsif($Is_Cygwin || $Config{'d_procselfexe'}) {
d261 1
a261 1
    my $perl = $Is_VMS ? $^X : "$wd/perl";
d305 1
a305 1
#!$wd/perl
a313 1
    s{\bminiperl\b}{perl}; # so that test doesn't fail with miniperl
d331 3
d349 18
a366 3
SKIP: {
    skip("%ENV manipulations fail or aren't safe on $^O", 4)
	if $Is_VMS || $Is_Dos;
d368 13
a380 3
 SKIP: {
	skip("clearing \%ENV is not safe when running under valgrind")
	    if $ENV{PERL_VALGRIND};
d382 2
a383 12
	    $PATH = $ENV{PATH};
	    $PDL = $ENV{PERL_DESTRUCT_LEVEL} || 0;
	    $ENV{foo} = "bar";
	    %ENV = ();
	    $ENV{PATH} = $PATH;
	    $ENV{PERL_DESTRUCT_LEVEL} = $PDL || 0;
	    if ($Is_MSWin32) {
		is `set foo 2>NUL`, "";
	    } else {
		is `echo \$foo`, "\n";
	    }
	}
d385 2
a386 13
	$ENV{__NoNeSuCh} = "foo";
	$0 = "bar";
# cmd.exe will echo 'variable=value' but 4nt will echo just the value
# -- Nikola Knezevic
    	if ($Is_MSWin32) {
	    like `set __NoNeSuCh`, qr/^(?:__NoNeSuCh=)?foo$/;
	} else {
	    is `echo \$__NoNeSuCh`, "foo\n";
	}
    SKIP: {
	    skip("\$0 check only on Linux and FreeBSD", 2)
		unless $^O =~ /^(linux|freebsd)$/
		    && open CMDLINE, "/proc/$$/cmdline";
d388 3
a390 31
	    chomp(my $line = scalar <CMDLINE>);
	    my $me = (split /\0/, $line)[0];
	    is $me, $0, 'altering $0 is effective (testing with /proc/)';
	    close CMDLINE;
            # perlbug #22811
            my $mydollarzero = sub {
              my($arg) = shift;
              $0 = $arg if defined $arg;
	      # In FreeBSD the ps -o command= will cause
	      # an empty header line, grab only the last line.
              my $ps = (`ps -o command= -p $$`)[-1];
              return if $?;
              chomp $ps;
              printf "# 0[%s]ps[%s]\n", $0, $ps;
              $ps;
            };
            my $ps = $mydollarzero->("x");
            ok(!$ps  # we allow that something goes wrong with the ps command
	       # In Linux 2.4 we would get an exact match ($ps eq 'x') but
	       # in Linux 2.2 there seems to be something funny going on:
	       # it seems as if the original length of the argv[] would
	       # be stored in the proc struct and then used by ps(1),
	       # no matter what characters we use to pad the argv[].
	       # (And if we use \0:s, they are shown as spaces.)  Sigh.
               || $ps =~ /^x\s*$/
	       # FreeBSD cannot get rid of both the leading "perl :"
	       # and the trailing " (perl)": some FreeBSD versions
	       # can get rid of the first one.
	       || ($^O eq 'freebsd' && $ps =~ m/^(?:perl: )?x(?: \(perl\))?$/),
		       'altering $0 is effective (testing with `ps`)');
	}
a401 2
# test case-insignificance of %ENV (these tests must be enabled only
# when perl is compiled with -DENV_IS_CASELESS)
d403 1
a403 13
    skip('no caseless %ENV support', 4) unless $Is_MSWin32 || $Is_NetWare;

    %ENV = ();
    $ENV{'Foo'} = 'bar';
    $ENV{'fOo'} = 'baz';
    is scalar(keys(%ENV)), 1;
    ok exists $ENV{'FOo'};
    is delete $ENV{'foO'}, 'baz';
    is scalar(keys(%ENV)), 0;
}

SKIP: {
    skip ("miniperl can't rely on loading %Errno", 2) if $Is_miniperl;
d419 1
a419 1
    skip ("miniperl can't rely on loading %Errno") if $Is_miniperl;
d428 30
a494 12
# Test for bug [perl #27839]
{
    my $x;
    sub f {
	"abc" =~ /(.)./;
	$x = "@@+";
	return @@+;
    };
    my @@y = f();
    is $x, "@@y", "return a magic array ($x) vs (@@y)";
}

d547 124
@


1.11
log
@Merge in perl 5.10.1; part two
@
text
@d7 1
d15 1
a15 2

plan (tests => 59);
a22 1
$Is_MacOS    = $^O eq 'MacOS';
d29 1
a29 1
       ($Is_MacOS || $Is_VMS) ? $^X      :
a41 1
elsif ($Is_MacOS) { ok "1 # skipped", 1; }
d53 1
a53 1
	if $Is_MSWin32 || $Is_NetWare || $Is_Dos || $Is_MPE || $Is_MacOS;
d164 4
a167 7
SKIP:  {
    skip('$? + system are broken on MacPerl', 2) if $Is_MacOS;
    system qq[$PERL "-I../lib" -e "use vmsish qw(hushed); exit(0)"];
    is $?, 0;
    system qq[$PERL "-I../lib" -e "use vmsish qw(hushed); exit(1)"];
    isnt $?, 0;
}
d185 1
a192 3
    elsif($Is_MacOS) {
       $wd = ':';
    }
d196 1
a196 1
    my $perl = ($Is_MacOS || $Is_VMS) ? $^X : "$wd/perl";
a221 3
    elsif ($Is_MacOS) {
      $script = ":show-shebang";
    }
d238 1
a238 1
    ok open(SCRIPT, ">$script") or diag $!;
d246 1
a246 1
    $_ = ($Is_MacOS || $Is_VMS) ? `$perl $script` : `$script`;
d284 1
a284 1
	if $Is_VMS || $Is_Dos || $Is_MacOS;
d385 1
a385 1
      defined %Errno::;
d406 2
a407 1
is ${^TAINT}, 0;
d409 1
a409 1
is ${^TAINT}, 0;
d468 31
@


1.10
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d8 1
a13 3
my $test = 1;
sub ok {
    my($ok, $info, $todo) = @@_;
d15 1
a15 23
    # You have to do it this way or VMS will get confused.
    printf "%s $test%s\n", $ok ? "ok" : "not ok",
                           $todo ? " # TODO $todo" : '';

    unless( $ok ) {
        printf "# Failed test at line %d\n", (caller)[2];
        print  "# $info\n" if defined $info;
    }

    $test++;
    return $ok;
}

sub skip {
    my($reason) = @@_;

    printf "ok $test # skipped%s\n", defined $reason ? ": $reason" : '';

    $test++;
    return 1;
}

print "1..58\n";
d34 5
d42 1
a42 1
if ($Is_MSWin32)  { ok `set FOO` =~ /^(?:FOO=)?hi there$/; }
d44 2
a45 2
elsif ($Is_VMS)   { ok `write sys\$output f\$trnlnm("FOO")` eq "hi there\n"; }
else              { ok `echo \$FOO` eq "hi there\n"; }
d50 1
a50 1
ok $!, $!;
d53 3
a55 4
if ($Is_MSWin32 || $Is_NetWare || $Is_Dos || $Is_MPE || $Is_MacOS) {
    skip('SIGINT not safe on this platform') for 1..4;
}
else {
d114 17
a130 1
    $test += 4;
d136 2
a137 2
ok join(':',@@val1) eq join(':',@@val2);
ok @@val1 > 1;
d141 4
a144 4
ok $` eq 'foo', $`;
ok $& eq 'bar', $&;
ok $' eq 'baz', $';
ok $+ eq 'a', $+;
d148 1
a148 1
ok "@@a" eq "foo bar baz", "@@a";
d151 1
a151 1
    ok "@@a" eq "foo,bar,baz", "@@a";
d157 1
a157 1
ok((keys %h)[0] eq "foo\034bar", (keys %h)[0]);
d162 1
a162 1
    ok((keys %h)[0] eq 'fooxbar', (keys %h)[0]);
d166 2
a167 4
if ($Is_MacOS) {
    skip('$? + system are broken on MacPerl') for 1..2;
}
else {
d169 1
a169 1
    ok $? == 0, $?;
d171 1
a171 1
    ok $? != 0, $?;
d175 1
a175 1
ok $@@ eq "foo\n", $@@;
d177 1
a177 1
ok $$ > 0, $$;
d179 1
a179 1
ok $@@ =~ /^Modification of a read-only value attempted/;
d248 2
a249 2
    ok open(SCRIPT, ">$script"), $!;
    ok print(SCRIPT $headmaybe . <<EOB . $middlemaybe . <<'EOF' . $tailmaybe), $!;
d254 2
a255 2
    ok close(SCRIPT), $!;
    ok chmod(0755, $script), $!;
d262 5
a266 1
    ok((($Is_MSWin32 || $Is_os2) ? uc($_) eq uc($s1) : $_ eq $s1), " :$_:!=:$s1:");
d271 6
a276 2
    ok((($Is_MSWin32 || $Is_os2) ? uc($_) eq uc($s1) : $_ eq $s1), " :$_:!=:$s1: after `$perl $script`");
    ok unlink($script), $!;
d280 1
a280 1
ok $] >= 5.00319, $];
d282 1
a282 1
ok $^T > 850000000, $^T;
d288 1
a288 1
ok($^O eq $orig_osname, 'Assigning $^I does not clobber $^O');
d292 8
a299 7
if ($Is_VMS || $Is_Dos || $Is_MacOS) {
    skip("%ENV manipulations fail or aren't safe on $^O") for 1..4;
}
else {
	if ($ENV{PERL_VALGRIND}) {
	    skip("clearing \%ENV is not safe when running under valgrind");
	} else {
d306 5
a310 2
	    ok ($Is_MSWin32 ? (`set foo 2>NUL` eq "")
			    : (`echo \$foo` eq "\n") );
d317 10
a326 4
       ok ($Is_MSWin32 ? (`set __NoNeSuCh` =~ /^(?:__NoNeSuCh=)?foo$/)
			    : (`echo \$__NoNeSuCh` eq "foo\n") );
	if ($^O =~ /^(linux|freebsd)$/ &&
	    open CMDLINE, "/proc/$$/cmdline") {
d329 1
a329 1
	    ok($me eq $0, 'altering $0 is effective (testing with /proc/)');
a356 2
	} else {
	    skip("\$0 check only on Linux and FreeBSD") for 0, 1;
d363 1
a363 1
    local $SIG{'__WARN__'} = sub { $ok = 0; $warn = join '', @@_; };
d365 2
a366 1
    ok($ok, $warn, $Is_VMS ? "'\$!=undef' does throw a warning" : '');
d371 3
a373 1
if ($Is_MSWin32 || $Is_NetWare) {
d377 4
a380 7
    ok (scalar(keys(%ENV)) == 1);
    ok exists($ENV{'FOo'});
    ok (delete($ENV{'foO'}) eq 'baz');
    ok (scalar(keys(%ENV)) == 0);
}
else {
    skip('no caseless %ENV support') for 1..4;
d383 2
a384 3
if ($Is_miniperl) {
    skip ("miniperl can't rely on loading %Errno") for 1..2;
} else {
d399 2
a400 3
if ($Is_miniperl) {
    skip ("miniperl can't rely on loading %Errno");
} else {
d411 2
a412 2
ok $^S == 0 && defined $^S;
eval { ok $^S == 1 };
d414 1
a414 1
ok $^S == 0 && defined $^S;
d416 1
a416 1
ok ${^TAINT} == 0;
d418 1
a418 1
ok ${^TAINT} == 0;
d424 2
a425 2
ok "@@-" eq  "0 0 2 7";
ok "@@+" eq "10 1 6 10";
d454 1
a454 1
    ok( $x eq "@@y", "return a magic array ($x) vs (@@y)" );
d458 5
a462 1
if (!$Is_VMS) {
d469 1
a469 1
    ok( $@@ eq '', 'Push a constant on a magic array');
d472 1
a472 1
    ok( $@@ eq '', 'Assign a constant to a magic hash');
d475 1
a475 1
    ok( $@@ eq '', 'Assign a shared key to a magic hash');
a476 6
}
else {
# Can not do this test on VMS, EPOC, and SYMBIAN according to comments
# in mg.c/Perl_magic_clear_all_env()
#
    skip('Can\'t make assignment to \%ENV on this system') for 1..3;
@


1.9
log
@merge in perl 5.8.8
@
text
@d196 3
d211 1
d241 6
d255 1
a255 1
    ok print(SCRIPT $headmaybe . <<EOB . <<'EOF' . $tailmaybe), $!;
d270 1
a270 1
    s/\.exe//i if $Is_Dos or $Is_os2;
d453 4
a456 1
    eval { push @@ISA, __PACKAGE__ };
@


1.8
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d39 1
a39 1
print "1..54\n";
d50 1
d52 5
a56 4
$PERL = ($Is_NetWare            ? 'perl'   :
	 ($Is_MacOS || $Is_VMS) ? $^X      :
	 $Is_MSWin32            ? '.\perl' :
	 './perl');
d254 1
d261 1
d272 8
d370 1
a370 1
   ok !defined %Errno::;
d437 21
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d39 1
a39 1
print "1..53\n";
d41 9
a49 8
$Is_MSWin32 = $^O eq 'MSWin32';
$Is_NetWare = $^O eq 'NetWare';
$Is_VMS     = $^O eq 'VMS';
$Is_Dos     = $^O eq 'dos';
$Is_os2     = $^O eq 'os2';
$Is_Cygwin  = $^O eq 'cygwin';
$Is_MacOS   = $^O eq 'MacOS';
$Is_MPE     = $^O eq 'mpeix';		
d351 5
d358 1
a358 1
ok !defined %Errno::;
d362 18
a379 14
ok scalar eval q{
   my $errs = %!;
   defined %Errno::;
}, $@@;


# Make sure that Errno loading doesn't clobber $!

undef %Errno::;
delete $INC{"Errno.pm"};

open(FOO, "nonesuch"); # Generate ENOENT
my %errs = %{"!"}; # Cause Errno.pm to be loaded at run-time
ok ${"!"}{ENOENT};
d413 12
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d23 1
a23 1
        print  "# $info" if defined $info;
d39 1
a39 1
print "1..46\n";
d70 1
a70 1
    skip('SIGINT not safe on this platform') for 1..2;
d101 31
a131 1
    $test += 2;
d268 1
a268 1
    skip("%ENV manipulations fail or aren't safe on $^O") for 1..2;
d271 12
a282 8
	$PATH = $ENV{PATH};
	$PDL = $ENV{PERL_DESTRUCT_LEVEL} || 0;
	$ENV{foo} = "bar";
	%ENV = ();
	$ENV{PATH} = $PATH;
	$ENV{PERL_DESTRUCT_LEVEL} = $PDL || 0;
	ok ($Is_MSWin32 ? (`set foo 2>NUL` eq "")
				: (`echo \$foo` eq "\n") );
d290 35
d371 1
a371 1
ok $^S == 0;
d373 2
a374 1
ok $^S == 0;
d387 17
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d11 1
d13 1
d15 9
a23 7
    my ($n, $result, $info) = @@_;
    if ($result) {
	print "ok $n\n";
    }
    else {
    	print "not ok $n\n";
	print "# $info\n" if $info;
d25 12
d39 2
d42 1
d44 10
a53 6
$Is_Dos   = $^O eq 'dos';
$Is_os2   = $^O eq 'os2';
$Is_Cygwin   = $^O eq 'cygwin';
$PERL = ($Is_MSWin32 ? '.\perl' : './perl');

print "1..35\n";
d56 6
a61 2
if ($Is_MSWin32) { ok 1, `cmd /x /c set FOO` eq "FOO=hi there\n"; }
else             { ok 1, `echo \$FOO` eq "hi there\n"; }
d66 1
a66 1
ok 2, $!, $!;
d69 2
a70 3
if ($Is_MSWin32 || $Is_Dos) {
    ok "3 # skipped",1;
    ok "4 # skipped",1;
d73 8
a80 3
  # the next tests are embedded inside system simply because sh spits out
  # a newline onto stderr when a child process kills itself with SIGINT.
  system './perl', '-e', <<'END';
d86 1
a86 1
    $SIG{"INT"} = "DEFAULT"; kill "INT",$$; sleep 1; print "not ok\n";
d98 4
d107 2
a108 2
ok 5, join(':',@@val1) eq join(':',@@val2);
ok 6, @@val1 > 1;
d112 4
a115 4
ok 7, $` eq 'foo', $`;
ok 8, $& eq 'bar', $&;
ok 9, $' eq 'baz', $';
ok 10, $+ eq 'a', $+;
d119 1
a119 1
ok 11, "@@a" eq "foo bar baz", "@@a";
d122 1
a122 1
    ok 12, "@@a" eq "foo,bar,baz", "@@a";
d128 1
a128 1
ok 13, (keys %h)[0] eq "foo\034bar", (keys %h)[0];
d133 1
a133 1
    ok 14, (keys %h)[0] eq 'fooxbar', (keys %h)[0];
d137 9
a145 4
system qq[$PERL -e "exit(0)"];
ok 15, $? == 0, $?;
system qq[$PERL -e "exit(1)"];
ok 16, $? != 0, $?;
d148 1
a148 1
ok 17, $@@ eq "foo\n", $@@;
d150 3
a152 1
ok 18, $$ > 0, $$;
d159 1
a159 1
    elsif($Is_Cygwin) {
d167 3
d173 1
a173 1
    my $perl = "$wd/perl";
d198 6
d211 2
a212 2
    ok 19, open(SCRIPT, ">$script"), $!;
    ok 20, print(SCRIPT $headmaybe . <<EOB . <<'EOF' . $tailmaybe), $!;
d217 3
a219 3
    ok 21, close(SCRIPT), $!;
    ok 22, chmod(0755, $script), $!;
    $_ = `$script`;
d224 1
a224 1
    ok 23, (($Is_MSWin32 || $Is_os2) ? uc($_) eq uc($s1) : $_ eq $s1), " :$_:!=:$s1:";
d228 2
a229 2
    ok 24, (($Is_MSWin32 || $Is_os2) ? uc($_) eq uc($s1) : $_ eq $s1), " :$_:!=:$s1: after `$perl $script`";
    ok 25, unlink($script), $!;
d233 6
a238 7
ok 26, $] >= 5.00319, $];
ok 27, $^O;
ok 28, $^T > 850000000, $^T;

if ($Is_VMS || $Is_Dos) {
	ok "29 # skipped", 1;
	ok "30 # skipped", 1;
d247 1
a247 1
	ok 29, ($Is_MSWin32 ? (`cmd /x /c set foo 2>NUL` eq "")
d252 3
a254 1
	ok 30, ($Is_MSWin32 ? (`cmd /x /c set __NoNeSuCh` eq "__NoNeSuCh=foo\n")
d259 3
a261 1
    local $SIG{'__WARN__'} = sub { print "# @@_\nnot " };
d263 1
a263 1
    print "ok 31\n";
d268 1
a268 1
if ($Is_MSWin32) {
d272 4
a275 4
    ok 32, (scalar(keys(%ENV)) == 1);
    ok 33, exists($ENV{'FOo'});
    ok 34, (delete($ENV{'foO'}) eq 'baz');
    ok 35, (scalar(keys(%ENV)) == 0);
d278 1
a278 4
    ok "32 # skipped: no caseless %ENV support",1;
    ok "33 # skipped: no caseless %ENV support",1;
    ok "34 # skipped: no caseless %ENV support",1;
    ok "35 # skipped: no caseless %ENV support",1;
d280 37
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d6 1
a6 1
    unshift @@INC, '../lib';
d192 1
d196 1
d200 1
a200 1
	$ENV{NoNeSuCh} = "foo";
d202 2
a203 2
	ok 30, ($Is_MSWin32 ? (`cmd /x /c set NoNeSuCh` eq "NoNeSuCh=foo\n")
						: (`echo \$NoNeSuCh` eq "foo\n") );
@


1.3
log
@perl5.005_03 (stock)
@
text
@a3 1
    $^W = 1;
d6 1
a6 1
    @@INC = '../lib';
d10 2
d26 2
d117 8
d134 3
a136 2
	$perl = "$wd\\perl.exe";
	$script = "$wd\\show-shebang.bat";
d150 4
a153 1
    if ($^O eq 'os390') {  # no shebang
d159 1
a159 1
    $s1 = $s2 = "\$^X is $perl, \$0 is $script\n";
d169 1
a169 1
    s/.exe//i if $Is_Dos;
d172 2
a173 1
    ok 23, ($Is_MSWin32 ? uc($_) eq uc($s2) : $_ eq $s2), ":$_:!=:$s2:";
d175 3
a177 2
    s/.exe//i if $Is_Dos;
    ok 24, ($Is_MSWin32 ? uc($_) eq uc($s1) : $_ eq $s1), ":$_:!=:$s1: after `$perl $script`";
d205 1
a205 1
    local $SIG{'__WARN__'} = sub { print "not " };
d222 4
a225 4
    ok "32 # skipped",1;
    ok "33 # skipped",1;
    ok "34 # skipped",1;
    ok "35 # skipped",1;
@


1.2
log
@perl 5.004_04
@
text
@d24 1
d27 1
a27 1
print "1..30\n";
d29 3
a31 3
eval '$ENV{"foo"} = "hi there";';	# check that ENV is inited inside eval
if ($Is_MSWin32) { ok 1, `cmd /x /c set foo` eq "foo=hi there\n"; }
else             { ok 1, `echo \$foo` eq "hi there\n"; }
d39 3
a41 3
if ($Is_MSWin32) {
    ok 3,1;
    ok 4,1;
d50 3
a52 3
    $SIG{"INT"} = "ok3";     kill "INT",$$;
    $SIG{"INT"} = "IGNORE";  kill "INT",$$; print "ok 4\n";
    $SIG{"INT"} = "DEFAULT"; kill "INT",$$; print "not ok\n";
d112 1
a112 1
	chomp($wd = `pwd`);
d138 6
a144 4
    if ($^O eq 'os2') {
	# Started by ksh, which adds suffixes '.exe' and '.' to perl and script
	$s2 = "\$^X is $wd/perl.exe, \$0 is $script.\n";
    }
d154 1
d159 1
d169 3
a171 3
if ($Is_VMS) {
	ok 29, 1;
	ok 30, 1;
d187 23
@


1.1
log
@Initial revision
@
text
@d3 18
a20 1
# $RCSfile: magic.t,v $$Revision: 4.1 $$Date: 92/08/07 18:28:05 $
d22 3
a24 1
$| = 1;		# command buffering
d26 1
a26 1
print "1..6\n";
d29 2
a30 1
if (`echo \$foo` eq "hi there\n") {print "ok 1\n";} else {print "not ok 1\n";}
d34 12
a45 7
open(foo,'ajslkdfpqjsjfk');
if ($!) {print "ok 2\n";} else {print "not ok 2\n";}

# the next tests are embedded inside system simply because sh spits out
# a newline onto stderr when a child process kills itself with SIGINT.

system './perl', '-e', <<'END';
d49 3
a51 3
    $SIG{"INT"} = "ok3"; kill "INT",$$;
    $SIG{"INT"} = "IGNORE"; kill 2,$$; print "ok 4\n";
    $SIG{"INT"} = "DEFAULT"; kill 2,$$; print "not ok\n";
d58 1
a58 1
	    print "not ok 3 $a\n";
d63 1
d65 2
a66 1
@@val1 = @@ENV{keys(%ENV)};	# can we slice ENV?
d68 2
d71 110
a180 3
print join(':',@@val1) eq join(':',@@val2) ? "ok 5\n" : "not ok 5\n";

print @@val1 > 1 ? "ok 6\n" : "not ok 6\n";
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d3 5
a7 18
BEGIN {
    $^W = 1;
    $| = 1;
    chdir 't' if -d 't';
    @@INC = '../lib';
    $SIG{__WARN__} = sub { die "Dying on warning: ", @@_ };
}

sub ok {
    my ($n, $result, $info) = @@_;
    if ($result) {
	print "ok $n\n";
    }
    else {
    	print "not ok $n\n";
	print "# $info\n" if $info;
    }
}
d9 2
a10 10
$Is_MSWin32 = $^O eq 'MSWin32';
$Is_VMS     = $^O eq 'VMS';
$Is_Dos   = $^O eq 'dos';
$PERL = ($Is_MSWin32 ? '.\perl' : './perl');

print "1..35\n";

eval '$ENV{"FOO"} = "hi there";';	# check that ENV is inited inside eval
if ($Is_MSWin32) { ok 1, `cmd /x /c set FOO` eq "FOO=hi there\n"; }
else             { ok 1, `echo \$FOO` eq "hi there\n"; }
d14 7
a20 12
open(FOO,'ajslkdfpqjsjfk');
ok 2, $!, $!;
close FOO; # just mention it, squelch used-only-once

if ($Is_MSWin32 || $Is_Dos) {
    ok "3 # skipped",1;
    ok "4 # skipped",1;
}
else {
  # the next tests are embedded inside system simply because sh spits out
  # a newline onto stderr when a child process kills itself with SIGINT.
  system './perl', '-e', <<'END';
d24 3
a26 3
    $SIG{"INT"} = "ok3";     kill "INT",$$; sleep 1;
    $SIG{"INT"} = "IGNORE";  kill "INT",$$; sleep 1; print "ok 4\n";
    $SIG{"INT"} = "DEFAULT"; kill "INT",$$; sleep 1; print "not ok\n";
d33 1
a33 1
	    print "not ok 3 ($x @@_)\n";
a37 1
}
d39 1
a39 2
# can we slice ENV?
@@val1 = @@ENV{keys(%ENV)};
a40 2
ok 5, join(':',@@val1) eq join(':',@@val2);
ok 6, @@val1 > 1;
d42 4
a45 138
# regex vars
'foobarbaz' =~ /b(a)r/;
ok 7, $` eq 'foo', $`;
ok 8, $& eq 'bar', $&;
ok 9, $' eq 'baz', $';
ok 10, $+ eq 'a', $+;

# $"
@@a = qw(foo bar baz);
ok 11, "@@a" eq "foo bar baz", "@@a";
{
    local $" = ',';
    ok 12, "@@a" eq "foo,bar,baz", "@@a";
}

# $;
%h = ();
$h{'foo', 'bar'} = 1;
ok 13, (keys %h)[0] eq "foo\034bar", (keys %h)[0];
{
    local $; = 'x';
    %h = ();
    $h{'foo', 'bar'} = 1;
    ok 14, (keys %h)[0] eq 'fooxbar', (keys %h)[0];
}

# $?, $@@, $$
system qq[$PERL -e "exit(0)"];
ok 15, $? == 0, $?;
system qq[$PERL -e "exit(1)"];
ok 16, $? != 0, $?;

eval { die "foo\n" };
ok 17, $@@ eq "foo\n", $@@;

ok 18, $$ > 0, $$;

# $^X and $0
{
    if ($^O eq 'qnx') {
	chomp($wd = `/usr/bin/fullpath -t`);
    }
    else {
	$wd = '.';
    }
    my $perl = "$wd/perl";
    my $headmaybe = '';
    my $tailmaybe = '';
    $script = "$wd/show-shebang";
    if ($Is_MSWin32) {
	chomp($wd = `cd`);
	$perl = "$wd\\perl.exe";
	$script = "$wd\\show-shebang.bat";
	$headmaybe = <<EOH ;
\@@rem ='
\@@echo off
$perl -x \%0
goto endofperl
\@@rem ';
EOH
	$tailmaybe = <<EOT ;

__END__
:endofperl
EOT
    }
    if ($^O eq 'os390') {  # no shebang
	$headmaybe = <<EOH ;
    eval 'exec ./perl -S \$0 \${1+"\$\@@"}'
        if 0;
EOH
    }
    $s1 = $s2 = "\$^X is $perl, \$0 is $script\n";
    ok 19, open(SCRIPT, ">$script"), $!;
    ok 20, print(SCRIPT $headmaybe . <<EOB . <<'EOF' . $tailmaybe), $!;
#!$wd/perl
EOB
print "\$^X is $^X, \$0 is $0\n";
EOF
    ok 21, close(SCRIPT), $!;
    ok 22, chmod(0755, $script), $!;
    $_ = `$script`;
    s/.exe//i if $Is_Dos;
    s{\bminiperl\b}{perl}; # so that test doesn't fail with miniperl
    s{is perl}{is $perl}; # for systems where $^X is only a basename
    ok 23, ($Is_MSWin32 ? uc($_) eq uc($s2) : $_ eq $s2), ":$_:!=:$s2:";
    $_ = `$perl $script`;
    s/.exe//i if $Is_Dos;
    ok 24, ($Is_MSWin32 ? uc($_) eq uc($s1) : $_ eq $s1), ":$_:!=:$s1: after `$perl $script`";
    ok 25, unlink($script), $!;
}

# $], $^O, $^T
ok 26, $] >= 5.00319, $];
ok 27, $^O;
ok 28, $^T > 850000000, $^T;

if ($Is_VMS || $Is_Dos) {
	ok "29 # skipped", 1;
	ok "30 # skipped", 1;
}
else {
	$PATH = $ENV{PATH};
	$ENV{foo} = "bar";
	%ENV = ();
	$ENV{PATH} = $PATH;
	ok 29, ($Is_MSWin32 ? (`cmd /x /c set foo 2>NUL` eq "")
				: (`echo \$foo` eq "\n") );

	$ENV{NoNeSuCh} = "foo";
	$0 = "bar";
	ok 30, ($Is_MSWin32 ? (`cmd /x /c set NoNeSuCh` eq "NoNeSuCh=foo\n")
						: (`echo \$NoNeSuCh` eq "foo\n") );
}

{
    local $SIG{'__WARN__'} = sub { print "not " };
    $! = undef;
    print "ok 31\n";
}

# test case-insignificance of %ENV (these tests must be enabled only
# when perl is compiled with -DENV_IS_CASELESS)
if ($Is_MSWin32) {
    %ENV = ();
    $ENV{'Foo'} = 'bar';
    $ENV{'fOo'} = 'baz';
    ok 32, (scalar(keys(%ENV)) == 1);
    ok 33, exists($ENV{'FOo'});
    ok 34, (delete($ENV{'foO'}) eq 'baz');
    ok 35, (scalar(keys(%ENV)) == 0);
}
else {
    ok "32 # skipped",1;
    ok "33 # skipped",1;
    ok "34 # skipped",1;
    ok "35 # skipped",1;
}
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d4 1
d7 1
a7 1
    unshift @@INC, '../lib';
a10 2
use warnings;

a24 2
$Is_os2   = $^O eq 'os2';
$Is_Cygwin   = $^O eq 'cygwin';
a113 8
    elsif($Is_Cygwin) {
       # Cygwin turns the symlink into the real file
       chomp($wd = `pwd`);
       $wd =~ s#/t$##;
    }
    elsif($Is_os2) {
       $wd = Cwd::sys_cwd();
    }
d123 2
a124 3
	$wd =~ s|\\|/|g;
	$perl = "$wd/perl.exe";
	$script = "$wd/show-shebang.bat";
d138 1
a138 4
    elsif ($Is_os2) {
      $script = "./show-shebang";
    }
    if ($^O eq 'os390' or $^O eq 'posix-bc' or $^O eq 'vmesa') {  # no shebang
d144 1
a144 1
    $s1 = "\$^X is $perl, \$0 is $script\n";
d154 1
a154 1
    s/\.exe//i if $Is_Dos or $Is_Cygwin or $Is_os2;
d157 1
a157 2
    s{\\}{/}g;
    ok 23, (($Is_MSWin32 || $Is_os2) ? uc($_) eq uc($s1) : $_ eq $s1), " :$_:!=:$s1:";
d159 2
a160 3
    s/\.exe//i if $Is_Dos or $Is_os2;
    s{\\}{/}g;
    ok 24, (($Is_MSWin32 || $Is_os2) ? uc($_) eq uc($s1) : $_ eq $s1), " :$_:!=:$s1: after `$perl $script`";
d188 1
a188 1
    local $SIG{'__WARN__'} = sub { print "# @@_\nnot " };
d205 4
a208 4
    ok "32 # skipped: no caseless %ENV support",1;
    ok "33 # skipped: no caseless %ENV support",1;
    ok "34 # skipped: no caseless %ENV support",1;
    ok "35 # skipped: no caseless %ENV support",1;
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d6 1
a6 1
    @@INC = '../lib';
a191 1
	$PDL = $ENV{PERL_DESTRUCT_LEVEL} || 0;
a194 1
	$ENV{PERL_DESTRUCT_LEVEL} = $PDL || 0;
d198 1
a198 1
	$ENV{__NoNeSuCh} = "foo";
d200 2
a201 2
	ok 30, ($Is_MSWin32 ? (`cmd /x /c set __NoNeSuCh` eq "__NoNeSuCh=foo\n")
			    : (`echo \$__NoNeSuCh` eq "foo\n") );
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@a10 1
use Config;
a11 1
my $test = 1;
d13 7
a19 9
    my($ok, $info, $todo) = @@_;

    # You have to do it this way or VMS will get confused.
    printf "%s $test%s\n", $ok ? "ok" : "not ok",
                           $todo ? " # TODO $todo" : '';

    unless( $ok ) {
        printf "# Failed test at line %d\n", (caller)[2];
        print  "# $info" if defined $info;
a20 3

    $test++;
    return $ok;
a22 11
sub skip {
    my($reason) = @@_;

    printf "ok $test # skipped%s\n", defined $reason ? ": $reason" : '';

    $test++;
    return 1;
}

print "1..46\n";

a23 1
$Is_NetWare = $^O eq 'NetWare';
d25 6
a30 10
$Is_Dos     = $^O eq 'dos';
$Is_os2     = $^O eq 'os2';
$Is_Cygwin  = $^O eq 'cygwin';
$Is_MacOS   = $^O eq 'MacOS';
$Is_MPE     = $^O eq 'mpeix';		

$PERL = ($Is_NetWare            ? 'perl'   :
	 ($Is_MacOS || $Is_VMS) ? $^X      :
	 $Is_MSWin32            ? '.\perl' :
	 './perl');
d33 2
a34 6
# cmd.exe will echo 'variable=value' but 4nt will echo just the value
# -- Nikola Knezevic
if ($Is_MSWin32)  { ok `set FOO` =~ /^(?:FOO=)?hi there$/; }
elsif ($Is_MacOS) { ok "1 # skipped", 1; }
elsif ($Is_VMS)   { ok `write sys\$output f\$trnlnm("FOO")` eq "hi there\n"; }
else              { ok `echo \$FOO` eq "hi there\n"; }
d39 1
a39 1
ok $!, $!;
d42 3
a44 2
if ($Is_MSWin32 || $Is_NetWare || $Is_Dos || $Is_MPE || $Is_MacOS) {
    skip('SIGINT not safe on this platform') for 1..2;
d47 3
a49 8
  # the next tests are done in a subprocess because sh spits out a
  # newline onto stderr when a child process kills itself with SIGINT.
  # We use a pipe rather than system() because the VMS command buffer
  # would overflow with a command that long.

    open( CMDPIPE, "| $PERL");

    print CMDPIPE <<'END';
d55 1
a55 1
    $SIG{"INT"} = "DEFAULT"; kill "INT",$$; sleep 1; print "not ok 4\n";
a66 4

    close CMDPIPE;

    $test += 2;
d72 2
a73 2
ok join(':',@@val1) eq join(':',@@val2);
ok @@val1 > 1;
d77 4
a80 4
ok $` eq 'foo', $`;
ok $& eq 'bar', $&;
ok $' eq 'baz', $';
ok $+ eq 'a', $+;
d84 1
a84 1
ok "@@a" eq "foo bar baz", "@@a";
d87 1
a87 1
    ok "@@a" eq "foo,bar,baz", "@@a";
d93 1
a93 1
ok((keys %h)[0] eq "foo\034bar", (keys %h)[0]);
d98 1
a98 1
    ok((keys %h)[0] eq 'fooxbar', (keys %h)[0]);
d102 4
a105 9
if ($Is_MacOS) {
    skip('$? + system are broken on MacPerl') for 1..2;
}
else {
    system qq[$PERL "-I../lib" -e "use vmsish qw(hushed); exit(0)"];
    ok $? == 0, $?;
    system qq[$PERL "-I../lib" -e "use vmsish qw(hushed); exit(1)"];
    ok $? != 0, $?;
}
d108 1
a108 1
ok $@@ eq "foo\n", $@@;
d110 1
a110 3
ok $$ > 0, $$;
eval { $$++ };
ok $@@ =~ /^Modification of a read-only value attempted/;
d117 1
a117 1
    elsif($Is_Cygwin || $Config{'d_procselfexe'}) {
a124 3
    elsif($Is_MacOS) {
       $wd = ':';
    }
d128 1
a128 1
    my $perl = ($Is_MacOS || $Is_VMS) ? $^X : "$wd/perl";
a152 6
    elsif ($Is_MacOS) {
      $script = ":show-shebang";
    }
    elsif ($Is_VMS) {
      $script = "[]show-shebang";
    }
d160 2
a161 2
    ok open(SCRIPT, ">$script"), $!;
    ok print(SCRIPT $headmaybe . <<EOB . <<'EOF' . $tailmaybe), $!;
d166 3
a168 3
    ok close(SCRIPT), $!;
    ok chmod(0755, $script), $!;
    $_ = ($Is_MacOS || $Is_VMS) ? `$perl $script` : `$script`;
d173 1
a173 1
    ok((($Is_MSWin32 || $Is_os2) ? uc($_) eq uc($s1) : $_ eq $s1), " :$_:!=:$s1:");
d177 2
a178 2
    ok((($Is_MSWin32 || $Is_os2) ? uc($_) eq uc($s1) : $_ eq $s1), " :$_:!=:$s1: after `$perl $script`");
    ok unlink($script), $!;
d182 7
a188 6
ok $] >= 5.00319, $];
ok $^O;
ok $^T > 850000000, $^T;

if ($Is_VMS || $Is_Dos || $Is_MacOS) {
    skip("%ENV manipulations fail or aren't safe on $^O") for 1..2;
d197 1
a197 1
	ok ($Is_MSWin32 ? (`set foo 2>NUL` eq "")
d202 1
a202 3
# cmd.exe will echo 'variable=value' but 4nt will echo just the value
# -- Nikola Knezevic
       ok ($Is_MSWin32 ? (`set __NoNeSuCh` =~ /^(?:__NoNeSuCh=)?foo$/)
d207 1
a207 3
    my $ok = 1;
    my $warn = '';
    local $SIG{'__WARN__'} = sub { $ok = 0; $warn = join '', @@_; };
d209 1
a209 1
    ok($ok, $warn, $Is_VMS ? "'\$!=undef' does throw a warning" : '');
d214 1
a214 1
if ($Is_MSWin32 || $Is_NetWare) {
d218 4
a221 4
    ok (scalar(keys(%ENV)) == 1);
    ok exists($ENV{'FOo'});
    ok (delete($ENV{'foO'}) eq 'baz');
    ok (scalar(keys(%ENV)) == 0);
d224 4
a227 1
    skip('no caseless %ENV support') for 1..4;
a228 37

# Make sure Errno hasn't been prematurely autoloaded

ok !defined %Errno::;

# Test auto-loading of Errno when %! is used

ok scalar eval q{
   my $errs = %!;
   defined %Errno::;
}, $@@;


# Make sure that Errno loading doesn't clobber $!

undef %Errno::;
delete $INC{"Errno.pm"};

open(FOO, "nonesuch"); # Generate ENOENT
my %errs = %{"!"}; # Cause Errno.pm to be loaded at run-time
ok ${"!"}{ENOENT};

ok $^S == 0;
eval { ok $^S == 1 };
ok $^S == 0;

ok ${^TAINT} == 0;
eval { ${^TAINT} = 1 };
ok ${^TAINT} == 0;

# 5.6.1 had a bug: @@+ and @@- were not properly interpolated
# into double-quoted strings
# 20020414 mjd-perl-patch+@@plover.com
"I like pie" =~ /(I) (like) (pie)/;
ok "@@-" eq  "0 0 2 7";
ok "@@+" eq "10 1 6 10";

@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@d23 1
a23 1
        print  "# $info\n" if defined $info;
d39 1
a39 1
print "1..53\n";
d70 1
a70 1
    skip('SIGINT not safe on this platform') for 1..4;
d101 1
a101 31
    open( CMDPIPE, "| $PERL");
    print CMDPIPE <<'END';

    { package X;
	sub DESTROY {
	    kill "INT",$$;
	}
    }
    sub x {
	my $x=bless [], 'X';
	return sub { $x };
    }
    $| = 1;		# command buffering
    $SIG{"INT"} = "ok5";
    {
	local $SIG{"INT"}=x();
	print ""; # Needed to expose failure in 5.8.0 (why?)
    }
    sleep 1;
    delete $SIG{"INT"};
    kill "INT",$$; sleep 1;
    sub ok5 {
	print "ok 5\n";
    }
END
    close CMDPIPE;
    $? >>= 8 if $^O eq 'VMS'; # POSIX status hiding in 2nd byte
    my $todo = ($^O eq 'os2' ? ' # TODO: EMX v0.9d_fix4 bug: wrong nibble? ' : '');
    print $? & 0xFF ? "ok 6$todo\n" : "not ok 6$todo\n";

    $test += 4;
d238 1
a238 1
    skip("%ENV manipulations fail or aren't safe on $^O") for 1..4;
d241 8
a248 12
	if ($ENV{PERL_VALGRIND}) {
	    skip("clearing \%ENV is not safe when running under valgrind");
	} else {
	    $PATH = $ENV{PATH};
	    $PDL = $ENV{PERL_DESTRUCT_LEVEL} || 0;
	    $ENV{foo} = "bar";
	    %ENV = ();
	    $ENV{PATH} = $PATH;
	    $ENV{PERL_DESTRUCT_LEVEL} = $PDL || 0;
	    ok ($Is_MSWin32 ? (`set foo 2>NUL` eq "")
			    : (`echo \$foo` eq "\n") );
	}
a255 35
	if ($^O =~ /^(linux|freebsd)$/ &&
	    open CMDLINE, "/proc/$$/cmdline") {
	    chomp(my $line = scalar <CMDLINE>);
	    my $me = (split /\0/, $line)[0];
	    ok($me eq $0, 'altering $0 is effective (testing with /proc/)');
	    close CMDLINE;
            # perlbug #22811
            my $mydollarzero = sub {
              my($arg) = shift;
              $0 = $arg if defined $arg;
	      # In FreeBSD the ps -o command= will cause
	      # an empty header line, grab only the last line.
              my $ps = (`ps -o command= -p $$`)[-1];
              return if $?;
              chomp $ps;
              printf "# 0[%s]ps[%s]\n", $0, $ps;
              $ps;
            };
            my $ps = $mydollarzero->("x");
            ok(!$ps  # we allow that something goes wrong with the ps command
	       # In Linux 2.4 we would get an exact match ($ps eq 'x') but
	       # in Linux 2.2 there seems to be something funny going on:
	       # it seems as if the original length of the argv[] would
	       # be stored in the proc struct and then used by ps(1),
	       # no matter what characters we use to pad the argv[].
	       # (And if we use \0:s, they are shown as spaces.)  Sigh.
               || $ps =~ /^x\s*$/
	       # FreeBSD cannot get rid of both the leading "perl :"
	       # and the trailing " (perl)": some FreeBSD versions
	       # can get rid of the first one.
	       || ($^O eq 'freebsd' && $ps =~ m/^(?:perl: )?x(?: \(perl\))?$/),
		       'altering $0 is effective (testing with `ps`)');
	} else {
	    skip("\$0 check only on Linux and FreeBSD") for 0, 1;
	}
d302 1
a302 1
ok $^S == 0 && defined $^S;
d304 1
a304 2
eval " BEGIN { ok ! defined \$^S } ";
ok $^S == 0 && defined $^S;
a316 17
# Tests for the magic get of $\
{
    my $ok = 0;
    # [perl #19330]
    {
	local $\ = undef;
	$\++; $\++;
	$ok = $\ eq 2;
    }
    ok $ok;
    $ok = 0;
    {
	local $\ = "a\0b";
	$ok = "a$\b" eq "aa\0bb";
    }
    ok $ok;
}
@


1.1.1.7
log
@Import of stock perl 5.8.5
@
text
@d39 1
a39 1
print "1..54\n";
d41 8
a48 9
$Is_MSWin32  = $^O eq 'MSWin32';
$Is_NetWare  = $^O eq 'NetWare';
$Is_VMS      = $^O eq 'VMS';
$Is_Dos      = $^O eq 'dos';
$Is_os2      = $^O eq 'os2';
$Is_Cygwin   = $^O eq 'cygwin';
$Is_MacOS    = $^O eq 'MacOS';
$Is_MPE      = $^O eq 'mpeix';		
$Is_miniperl = $ENV{PERL_CORE_MINITEST};
a349 5
if ($Is_miniperl) {
    skip ("miniperl can't rely on loading %Errno") for 1..2;
} else {
   no warnings 'void';

d352 1
a352 1
   ok !defined %Errno::;
d356 14
a369 18
   ok scalar eval q{
      %!;
      defined %Errno::;
   }, $@@;
}

if ($Is_miniperl) {
    skip ("miniperl can't rely on loading %Errno");
} else {
    # Make sure that Errno loading doesn't clobber $!

    undef %Errno::;
    delete $INC{"Errno.pm"};

    open(FOO, "nonesuch"); # Generate ENOENT
    my %errs = %{"!"}; # Cause Errno.pm to be loaded at run-time
    ok ${"!"}{ENOENT};
}
a402 12
}

# Test for bug [perl #27839]
{
    my $x;
    sub f {
	"abc" =~ /(.)./;
	$x = "@@+";
	return @@+;
    };
    my @@y = f();
    ok( $x eq "@@y", "return a magic array ($x) vs (@@y)" );
@


1.1.1.8
log
@perl 5.8.8 import
@
text
@d39 1
a39 1
print "1..58\n";
a49 1
$Is_BeOS     = $^O eq 'beos';
d51 4
a54 5
$PERL = $ENV{PERL}
    || ($Is_NetWare           ? 'perl'   :
       ($Is_MacOS || $Is_VMS) ? $^X      :
       $Is_MSWin32            ? '.\perl' :
       './perl');
a251 1
    s{./$script}{$script} if $Is_BeOS; # revert BeOS execvp() side-effect
a257 1
    s{./$perl}{$perl} if $Is_BeOS; # revert BeOS execvp() side-effect
a267 8
# Test change 25062 is working
my $orig_osname = $^O;
{
local $^I = '.bak';
ok($^O eq $orig_osname, 'Assigning $^I does not clobber $^O');
}
$^O = $orig_osname;

d358 1
a358 1
   ok !keys %Errno::;
a424 21
}

# Test for bug [perl #36434]
if (!$Is_VMS) {
    local @@ISA;
    local %ENV;
    eval { push @@ISA, __PACKAGE__ };
    ok( $@@ eq '', 'Push a constant on a magic array');
    $@@ and print "# $@@";
    eval { %ENV = (PATH => __PACKAGE__) };
    ok( $@@ eq '', 'Assign a constant to a magic hash');
    $@@ and print "# $@@";
    eval { my %h = qw(A B); %ENV = (PATH => (keys %h)[0]) };
    ok( $@@ eq '', 'Assign a shared key to a magic hash');
    $@@ and print "# $@@";
}
else {
# Can not do this test on VMS, EPOC, and SYMBIAN according to comments
# in mg.c/Perl_magic_clear_all_env()
#
    skip('Can\'t make assignment to \%ENV on this system') for 1..3;
@


1.1.1.9
log
@import perl 5.10.0 from CPAN
@
text
@a195 3
       if ($Is_Cygwin) {
	   $wd = Cygwin::win_to_posix_path(Cygwin::posix_to_win_path($wd, 1));
       }
a207 1
    my $middlemaybe = '';
a236 6
    elsif ($Is_Cygwin) {
      $middlemaybe = <<'EOX'
$^X = Cygwin::win_to_posix_path(Cygwin::posix_to_win_path($^X, 1));
$0 = Cygwin::win_to_posix_path(Cygwin::posix_to_win_path($0, 1));
EOX
    }
d245 1
a245 1
    ok print(SCRIPT $headmaybe . <<EOB . $middlemaybe . <<'EOF' . $tailmaybe), $!;
d260 1
a260 1
    s/\.exe//i if $Is_Dos or $Is_os2 or $Is_Cygwin;
d443 1
a443 4
    # This used to be __PACKAGE__, but that causes recursive
    #  inheritance, which is detected earlier now and broke
    #  this test
    eval { push @@ISA, __FILE__ };
@


1.1.1.10
log
@import perl 5.10.1
@
text
@a7 1
    require './test.pl';
d13 3
d17 23
a39 1
plan (tests => 59);
a57 5
END {
    # On VMS, environment variable changes are peristent after perl exits
    delete $ENV{'FOO'} if $Is_VMS;
}

d61 1
a61 1
if ($Is_MSWin32)  { like `set FOO`, qr/^(?:FOO=)?hi there$/; }
d63 2
a64 2
elsif ($Is_VMS)   { is `write sys\$output f\$trnlnm("FOO")`, "hi there\n"; }
else              { is `echo \$FOO`, "hi there\n"; }
d69 1
a69 1
isnt($!, 0);
d72 4
a75 3
SKIP: {
    skip('SIGINT not safe on this platform', 5)
	if $Is_MSWin32 || $Is_NetWare || $Is_Dos || $Is_MPE || $Is_MacOS;
d134 1
a134 17
    open(CMDPIPE, "| $PERL");
    print CMDPIPE <<'END';

    sub PVBM () { 'foo' }
    index 'foo', PVBM;
    my $pvbm = PVBM;

    sub foo { exit 0 }

    $SIG{"INT"} = $pvbm;
    kill "INT", $$; sleep 1;
END
    close CMDPIPE;
    $? >>= 8 if $^O eq 'VMS';
    print $? ? "not ok 7\n" : "ok 7\n";

    curr_test(curr_test() + 5);
d140 2
a141 2
is join(':',@@val1), join(':',@@val2);
cmp_ok @@val1, '>', 1;
d145 4
a148 4
is $`, 'foo';
is $&, 'bar';
is $', 'baz';
is $+, 'a';
d152 1
a152 1
is "@@a", "foo bar baz";
d155 1
a155 1
    is "@@a", "foo,bar,baz";
d161 1
a161 1
is((keys %h)[0], "foo\034bar");
d166 1
a166 1
    is((keys %h)[0], 'fooxbar');
d170 4
a173 2
SKIP:  {
    skip('$? + system are broken on MacPerl', 2) if $Is_MacOS;
d175 1
a175 1
    is $?, 0;
d177 1
a177 1
    isnt $?, 0;
d181 1
a181 1
is $@@, "foo\n";
d183 1
a183 1
cmp_ok($$, '>', 0);
d185 1
a185 1
like ($@@, qr/^Modification of a read-only value attempted/);
d254 2
a255 2
    ok open(SCRIPT, ">$script") or diag $!;
    ok print(SCRIPT $headmaybe . <<EOB . $middlemaybe . <<'EOF' . $tailmaybe) or diag $!;
d260 2
a261 2
    ok close(SCRIPT) or diag $!;
    ok chmod(0755, $script) or diag $!;
d268 1
a268 5
    if ($Is_MSWin32 || $Is_os2) {
	is uc $_, uc $s1;
    } else {
	is $_, $s1;
    }
d273 2
a274 6
    if ($Is_MSWin32 || $Is_os2) {
	is uc $_, uc $s1;
    } else {
	is $_, $s1;
    }
    ok unlink($script) or diag $!;
d278 1
a278 1
cmp_ok $], '>=', 5.00319;
d280 1
a280 1
cmp_ok $^T, '>', 850000000;
d286 1
a286 1
is $^O, $orig_osname, 'Assigning $^I does not clobber $^O';
d290 7
a296 8
SKIP: {
    skip("%ENV manipulations fail or aren't safe on $^O", 4)
	if $Is_VMS || $Is_Dos || $Is_MacOS;

 SKIP: {
	skip("clearing \%ENV is not safe when running under valgrind")
	    if $ENV{PERL_VALGRIND};

d303 2
a304 5
	    if ($Is_MSWin32) {
		is `set foo 2>NUL`, "";
	    } else {
		is `echo \$foo`, "\n";
	    }
d311 4
a314 10
    	if ($Is_MSWin32) {
	    like `set __NoNeSuCh`, qr/^(?:__NoNeSuCh=)?foo$/;
	} else {
	    is `echo \$__NoNeSuCh`, "foo\n";
	}
    SKIP: {
	    skip("\$0 check only on Linux and FreeBSD", 2)
		unless $^O =~ /^(linux|freebsd)$/
		    && open CMDLINE, "/proc/$$/cmdline";

d317 1
a317 1
	    is $me, $0, 'altering $0 is effective (testing with /proc/)';
d345 2
d353 1
a353 1
    local $SIG{'__WARN__'} = sub { $ok = 0; $warn = join '', @@_; $warn =~ s/\n$//; };
d355 1
a355 2
    local $TODO = $Is_VMS ? "'\$!=undef' does throw a warning" : '';
    ok($ok, $warn);
d360 1
a360 3
SKIP: {
    skip('no caseless %ENV support', 4) unless $Is_MSWin32 || $Is_NetWare;

d364 7
a370 4
    is scalar(keys(%ENV)), 1;
    ok exists $ENV{'FOo'};
    is delete $ENV{'foO'}, 'baz';
    is scalar(keys(%ENV)), 0;
d373 3
a375 2
SKIP: {
    skip ("miniperl can't rely on loading %Errno", 2) if $Is_miniperl;
d390 3
a392 2
SKIP:  {
    skip ("miniperl can't rely on loading %Errno") if $Is_miniperl;
d403 2
a404 2
is $^S, 0;
eval { is $^S,1 };
d406 1
a406 1
is $^S, 0;
d408 1
a408 1
is ${^TAINT}, 0;
d410 1
a410 1
is ${^TAINT}, 0;
d416 2
a417 2
is "@@-",  "0 0 2 7";
is "@@+", "10 1 6 10";
d446 1
a446 1
    is $x, "@@y", "return a magic array ($x) vs (@@y)";
d450 1
a450 5
# Can not do this test on VMS, EPOC, and SYMBIAN according to comments
# in mg.c/Perl_magic_clear_all_env()
SKIP: {
    skip('Can\'t make assignment to \%ENV on this system', 3) if $Is_VMS;

d457 1
a457 1
    is $@@, '', 'Push a constant on a magic array';
d460 1
a460 1
    is $@@, '', 'Assign a constant to a magic hash';
d463 1
a463 1
    is $@@, '', 'Assign a shared key to a magic hash';
d465 6
@


1.1.1.11
log
@Perl 5.12.2 from CPAN
@
text
@a6 1
    $ENV{PATH} = '/bin' if ${^TAINT};
d14 2
a15 1
plan (tests => 80);
d23 1
d30 1
a30 1
       $Is_VMS                ? $^X      :
d43 1
d55 1
a55 1
	if $Is_MSWin32 || $Is_NetWare || $Is_Dos || $Is_MPE;
d166 7
a172 4
system qq[$PERL "-I../lib" -e "use vmsish qw(hushed); exit(0)"];
is $?, 0;
system qq[$PERL "-I../lib" -e "use vmsish qw(hushed); exit(1)"];
isnt $?, 0;
a189 1
       $wd =~ /(.*)/; $wd = $1; # untaint
d197 3
d203 1
a203 1
    my $perl = $Is_VMS ? $^X : "$wd/perl";
d229 3
d248 1
a248 1
    ok open(SCRIPT, ">$script") or diag "Can't write to $script: $!";
d256 1
a256 1
    $_ = $Is_VMS ? `$perl $script` : `$script`;
d294 1
a294 1
	if $Is_VMS || $Is_Dos;
d395 1
a395 1
      scalar %Errno::;
d416 1
a416 2
my $taint = ${^TAINT};
is ${^TAINT}, $taint;
d418 1
a418 1
is ${^TAINT}, $taint;
a476 31
}

# Tests for Perl_magic_clearsig
foreach my $sig (qw(__WARN__ INT)) {
    $SIG{$sig} = lc $sig;
    is $SIG{$sig}, 'main::' . lc $sig, "Can assign to $sig";
    is delete $SIG{$sig}, 'main::' . lc $sig, "Can delete from $sig";
    is $SIG{$sig}, undef, "$sig is now gone";
    is delete $SIG{$sig}, undef, "$sig remains gone";
}

# And now one which doesn't exist;
{
    no warnings 'signal';
    $SIG{HUNGRY} = 'mmm, pie';
}
is $SIG{HUNGRY}, 'mmm, pie', 'Can assign to HUNGRY';
is delete $SIG{HUNGRY}, 'mmm, pie', 'Can delete from HUNGRY';
is $SIG{HUNGRY}, undef, "HUNGRY is now gone";
is delete $SIG{HUNGRY}, undef, "HUNGRY remains gone";

# Test deleting signals that we never set
foreach my $sig (qw(__DIE__ _BOGUS_HOOK KILL THIRSTY)) {
    is $SIG{$sig}, undef, "$sig is not present";
    is delete $SIG{$sig}, undef, "delete of $sig returns undef";
}

{
    $! = 9999;
    is int $!, 9999, q{[perl #72850] Core dump in bleadperl from perl -e '$! = 9999; $a = $!;'};

@


1.1.1.12
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@a6 36
    require './test.pl';
    plan (tests => 156);
}

# Test that defined() returns true for magic variables created on the fly,
# even before they have been created.
# This must come first, even before turning on warnings or setting up
# $SIG{__WARN__}, to avoid invalidating the tests.  warnings.pm currently
# does not mention any special variables, but that could easily change.
BEGIN {
    # not available in miniperl
    my %non_mini = map { $_ => 1 } qw(+ - [);
    for (qw(
	SIG ^OPEN ^TAINT ^UNICODE ^UTF8LOCALE ^WARNING_BITS 1 2 3 4 5 6 7 8
	9 42 & ` ' : ? ! _ - [ ^ ~ = % . ( ) < > \ / $ | + ; ] ^A ^C ^D
	^E ^F ^H ^I ^L ^N ^O ^P ^S ^T ^V ^W ^UTF8CACHE ::12345 main::98732
    )) {
	my $v = $_;
	# avoid using any global vars here:
	if ($v =~ s/^\^(?=.)//) {
	    for(substr $v, 0, 1) {
		$_ = chr ord() - 64;
	    }
	}
	SKIP:
	{
	    skip_if_miniperl("the module for *$_ may not be available in "
			     . "miniperl", 1) if $non_mini{$_};
	    ok defined *$v, "*$_ appears to be defined at the outset";
	}
    }
}

# This must be in a separate BEGIN block, as the mere mention of ${^TAINT}
# will invalidate the test for it.
BEGIN {
d9 1
d15 1
d24 1
d45 1
a45 1
unlink_all 'ajslkdfpqjsjfk';
a58 6
    # For easy interpolation of test numbers:
    $next_test = curr_test() - 1;
    sub TIEARRAY {bless[]}
    sub FETCH { $next_test + pop }
    tie my @@tn, __PACKAGE__;

d61 1
a61 1
    print CMDPIPE "\$t1 = $tn[1]; \$t2 = $tn[2];\n", <<'END';
d65 3
a67 3
    $SIG{"INT"} = "ok1";     kill "INT",$$; sleep 1;
    $SIG{"INT"} = "IGNORE";  kill "INT",$$; sleep 1; print "ok $t2\n";
    $SIG{"INT"} = "DEFAULT"; kill "INT",$$; sleep 1; print" not ok $t2\n";
d69 1
a69 1
    sub ok1 {
d71 1
a71 1
	    print "ok $t1\n";
d74 1
a74 1
	    print "not ok $t1 ($x @@_)\n";
d83 1
a83 1
    print CMDPIPE "\$t3 = $tn[3];\n", <<'END';
d95 1
a95 1
    $SIG{"INT"} = "ok3";
d103 2
a104 2
    sub ok3 {
	print "ok $t3\n";
d110 1
a110 1
    print $? & 0xFF ? "ok $tn[4]$todo\n" : "not ok $tn[4]$todo\n";
d126 1
a126 1
    print $? ? "not ok $tn[5]\n" : "ok $tn[5]\n";
a143 8
# [perl #24237]
for (qw < ` & ' >) {
 fresh_perl_is
  qq < \@@$_; q "fff" =~ /(?!^)./; print "[\$$_]\\n" >,
  "[f]\n", {},
  "referencing \@@$_ before \$$_ etc. still saws off ampersands";
}

d173 2
a174 18
my $pid = $$;
eval { $$ = 42 };
is $$, 42, '$$ can be modified';
SKIP: {
    skip "no fork", 1 unless $Config{d_fork};
    (my $kidpid = open my $fh, "-|") // skip "cannot fork: $!", 1;
    if($kidpid) { # parent
	my $kiddollars = <$fh>;
	close $fh or die "cannot close pipe from kid proc: $!";
	is $kiddollars, $kidpid, '$$ is reset on fork';
    }
    else { # child
	print $$;
	$::NO_ENDING = 1; # silence "Looks like you only ran..."
	exit;
    }
}
$$ = $pid; # Tests below use $$
a177 2
    my $is_abs = $Config{d_procselfexe} || $Config{usekernprocpathname}
      || $Config{usensgetexecutablepath};
d181 1
a181 1
    elsif($Is_Cygwin || $is_abs) {
d196 1
a196 1
    my $perl = $Is_VMS || $is_abs ? $^X : "$wd/perl";
d240 1
a240 1
#!$perl
d249 1
a266 3
    # CHECK
    # Could this be replaced with:
    # unlink_all($script);
d282 3
a284 12
{
    #RT #72422
    foreach my $p (0, 1) {
	fresh_perl_is(<<"EOP", '2 4 8', undef, "test \$^P = $p");
\$DB::single = 2;
\$DB::trace = 4;
\$DB::signal = 8;
\$^P = $p;
print "\$DB::single \$DB::trace \$DB::signal";
EOP
    }
}
d286 3
a288 5
# Check that assigning to $0 on Linux sets the process name with both
# argv[0] assignment and by calling prctl()
{
  SKIP: {
    skip "We don't have prctl() here", 2 unless $Config{d_prctl_set_name};
d290 12
a301 13
    # We don't really need these tests. prctl() is tested in the
    # Kernel, but test it anyway for our sanity. If something doesn't
    # work (like if the system doesn't have a ps(1) for whatever
    # reason) just bail out gracefully.
    my $maybe_ps = sub {
        my ($cmd) = @@_;
        local ($?, $!);

        no warnings;
        my $res = `$cmd`;
        skip "Couldn't shell out to '$cmd', returned code $?", 2 if $?;
        return $res;
    };
d303 13
a315 2
    my $name = "Good Morning, Dave";
    $0 = $name;
d317 31
a347 6
    chomp(my $argv0 = $maybe_ps->("ps h $$"));
    chomp(my $prctl = $maybe_ps->("ps hc $$"));

    like($argv0, $name, "Set process name through argv[0] ($argv0)");
    like($prctl, substr($name, 0, 15), "Set process name through prctl() ($prctl)");
  }
d359 2
d362 13
a374 1
    skip_if_miniperl("miniperl can't rely on loading %Errno", 2);
d390 1
a390 1
    skip_if_miniperl("miniperl can't rely on loading %Errno", 2);
a398 30

    # Make sure defined(*{"!"}) before %! does not stop %! from working
    is
      runperl(
	prog => 'BEGIN { defined *{q-!-} } print qq-ok\n- if tied %!',
      ),
     "ok\n",
     'defined *{"!"} does not stop %! from working';
}

# Check that we don't auto-load packages
SKIP: {
    skip "staticly linked; may be preloaded", 4 unless $Config{usedl};
    foreach (['powie::!', 'Errno'],
	     ['powie::+', 'Tie::Hash::NamedCapture']) {
	my ($symbol, $package) = @@$_;
	foreach my $scalar_first ('', '$$symbol;') {
	    my $desc = qq{Referencing %{"$symbol"}};
	    $desc .= qq{ after mentioning \${"$symbol"}} if $scalar_first;
	    $desc .= " doesn't load $package";

	    fresh_perl_is(<<"EOP", 0, {}, $desc);
use strict qw(vars subs);
my \$symbol = '$symbol';
$scalar_first;
1 if %{\$symbol};
print scalar %${package}::;
EOP
	}
    }
d436 12
a499 124

# %+ %-
SKIP: {
    skip_if_miniperl("No XS in miniperl", 2);
    # Make sure defined(*{"+"}) before %+ does not stop %+ from working
    is
      runperl(
	prog => 'BEGIN { defined *{q-+-} } print qq-ok\n- if tied %+',
      ),
     "ok\n",
     'defined *{"+"} does not stop %+ from working';
    is
      runperl(
	prog => 'BEGIN { defined *{q=-=} } print qq-ok\n- if tied %-',
      ),
     "ok\n",
     'defined *{"-"} does not stop %- from working';
}

SKIP: {
    skip_if_miniperl("No XS in miniperl", 3);

    for ( [qw( %- Tie::Hash::NamedCapture )], [qw( $[ arybase )],
          [qw( %! Errno )] ) {
	my ($var, $mod) = @@$_;
	my $modfile = $mod =~ s|::|/|gr . ".pm";
	fresh_perl_is
	   qq 'sub UNIVERSAL::AUTOLOAD{}
	       $mod\::foo() if 0;
	       $var;
	       print "ok\\n" if \$INC{"$modfile"}',
	  "ok\n",
	   { switches => [ '-X' ] },
	  "$var still loads $mod when stash and UNIVERSAL::AUTOLOAD exist";
    }
}

# ^^^^^^^^^ New tests go here ^^^^^^^^^

SKIP: {
    skip("%ENV manipulations fail or aren't safe on $^O", 4)
	if $Is_VMS || $Is_Dos;

 SKIP: {
	skip("clearing \%ENV is not safe when running under valgrind")
	    if $ENV{PERL_VALGRIND};

	    $PATH = $ENV{PATH};
	    $PDL = $ENV{PERL_DESTRUCT_LEVEL} || 0;
	    $ENV{foo} = "bar";
	    %ENV = ();
	    $ENV{PATH} = $PATH;
	    $ENV{PERL_DESTRUCT_LEVEL} = $PDL || 0;
	    if ($Is_MSWin32) {
		is `set foo 2>NUL`, "";
	    } else {
		is `echo \$foo`, "\n";
	    }
	}

	$ENV{__NoNeSuCh} = "foo";
	$0 = "bar";
# cmd.exe will echo 'variable=value' but 4nt will echo just the value
# -- Nikola Knezevic
    	if ($Is_MSWin32) {
	    like `set __NoNeSuCh`, qr/^(?:__NoNeSuCh=)?foo$/;
	} else {
	    is `echo \$__NoNeSuCh`, "foo\n";
	}
    SKIP: {
	    skip("\$0 check only on Linux and FreeBSD", 2)
		unless $^O =~ /^(linux|freebsd)$/
		    && open CMDLINE, "/proc/$$/cmdline";

	    chomp(my $line = scalar <CMDLINE>);
	    my $me = (split /\0/, $line)[0];
	    is $me, $0, 'altering $0 is effective (testing with /proc/)';
	    close CMDLINE;
            # perlbug #22811
            my $mydollarzero = sub {
              my($arg) = shift;
              $0 = $arg if defined $arg;
	      # In FreeBSD the ps -o command= will cause
	      # an empty header line, grab only the last line.
              my $ps = (`ps -o command= -p $$`)[-1];
              return if $?;
              chomp $ps;
              printf "# 0[%s]ps[%s]\n", $0, $ps;
              $ps;
            };
            my $ps = $mydollarzero->("x");
            ok(!$ps  # we allow that something goes wrong with the ps command
	       # In Linux 2.4 we would get an exact match ($ps eq 'x') but
	       # in Linux 2.2 there seems to be something funny going on:
	       # it seems as if the original length of the argv[] would
	       # be stored in the proc struct and then used by ps(1),
	       # no matter what characters we use to pad the argv[].
	       # (And if we use \0:s, they are shown as spaces.)  Sigh.
               || $ps =~ /^x\s*$/
	       # FreeBSD cannot get rid of both the leading "perl :"
	       # and the trailing " (perl)": some FreeBSD versions
	       # can get rid of the first one.
	       || ($^O eq 'freebsd' && $ps =~ m/^(?:perl: )?x(?: \(perl\))?$/),
		       'altering $0 is effective (testing with `ps`)');
	}
}

# test case-insignificance of %ENV (these tests must be enabled only
# when perl is compiled with -DENV_IS_CASELESS)
SKIP: {
    skip('no caseless %ENV support', 4) unless $Is_MSWin32 || $Is_NetWare;

    %ENV = ();
    $ENV{'Foo'} = 'bar';
    $ENV{'fOo'} = 'baz';
    is scalar(keys(%ENV)), 1;
    ok exists $ENV{'FOo'};
    is delete $ENV{'foO'}, 'baz';
    is scalar(keys(%ENV)), 0;
}

__END__

# Put new tests before the various ENV tests, as they blow %ENV away.
@


1.1.1.13
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d8 1
a8 1
    plan (tests => 179);
a22 1
	^LAST_FH
d57 2
a65 24
sub env_is {
    my ($key, $val, $desc) = @@_;

    use open IN => ":raw";
    if ($Is_MSWin32) {
        # cmd.exe will echo 'variable=value' but 4nt will echo just the value
        # -- Nikola Knezevic
	require Win32;
	my $cp = Win32::GetConsoleOutputCP();
	Win32::SetConsoleOutputCP(Win32::GetACP());
        (my $set = `set $key 2>nul`) =~ s/\r\n$/\n/;
	Win32::SetConsoleOutputCP($cp);
        like $set, qr/^(?:\Q$key\E=)?\Q$val\E$/, $desc;
    } elsif ($Is_VMS) {
        my $eqv = `write sys\$output f\$trnlnm("\Q$key\E")`;
        # A single null byte in the equivalence string means
        # an undef value for Perl, so mimic that here.
        $eqv = "\n" if length($eqv) == 2 and $eqv eq "\000\n";
        is $eqv, "$val\n", $desc;
    } else {
        is `echo \$\Q$key\E`, "$val\n", $desc;
    }
}

d68 1
a68 5
    if ($Is_VMS) {
        delete $ENV{'FOO'};
        delete $ENV{'__NoNeSuCh'};
        delete $ENV{'__NoNeSuCh2'};
    }
d86 1
a86 1
	if $Is_MSWin32 || $Is_NetWare || $Is_Dos;
d296 1
a296 1
    if ($^O eq 'os390' or $^O eq 'posix-bc') {  # no shebang
d313 1
d323 1
d496 1
a496 1
# Can not do this test on VMS, and SYMBIAN according to comments
a583 22
# ${^LAST_FH}
() = tell STDOUT;
is ${^LAST_FH}, \*STDOUT, '${^LAST_FH} after tell';
() = tell STDIN;
is ${^LAST_FH}, \*STDIN, '${^LAST_FH} after another tell';
{
    my $fh = *STDOUT;
    () = tell $fh;
    is ${^LAST_FH}, \$fh, '${^LAST_FH} referencing lexical coercible glob';
}
# This also tests that ${^LAST_FH} is a weak reference:
is ${^LAST_FH}, undef, '${^LAST_FH} is undef when PL_last_in_gv is NULL';


# $|
fresh_perl_is 'print $| = ~$|', "1\n", {switches => ['-l']}, 
 '[perl #4760] print $| = ~$|';
fresh_perl_is
 'select f; undef *f; ${q/|/}; print STDOUT qq|ok\n|', "ok\n", {}, 
 '[perl #115206] no crash when vivifying $| while *{+select}{IO} is undef';


d587 2
a588 2
    skip("%ENV manipulations fail or aren't safe on $^O", 19)
	if $Is_Dos;
d591 2
a592 2
	skip("clearing \%ENV is not safe when running under valgrind or on VMS")
	    if $ENV{PERL_VALGRIND} || $Is_VMS;
d607 8
a614 32
	$ENV{__NoNeSuCh} = 'foo';
	$0 = 'bar';
	env_is(__NoNeSuCh => 'foo', 'setting $0 does not break %ENV');

	$ENV{__NoNeSuCh2} = 'foo';
	$ENV{__NoNeSuCh2} = undef;
	env_is(__NoNeSuCh2 => '', 'setting a key as undef does not delete it');

	# stringify a glob
	$ENV{foo} = *TODO;
	env_is(foo => '*main::TODO', 'ENV store of stringified glob');

	# stringify a ref
	my $ref = [];
	$ENV{foo} = $ref;
	env_is(foo => "$ref", 'ENV store of stringified ref');

	# downgrade utf8 when possible
	$bytes = "eh zero \x{A0}";
	utf8::upgrade($chars = $bytes);
	$forced = $ENV{foo} = $chars;
	ok(!utf8::is_utf8($forced) && $forced eq $bytes, 'ENV store downgrades utf8 in SV');
	env_is(foo => $bytes, 'ENV store downgrades utf8 in setenv');

	# warn when downgrading utf8 is not possible
	$chars = "X-Day \x{1998}";
	utf8::encode($bytes = $chars);
	{
	  my $warned = 0;
	  local $SIG{__WARN__} = sub { ++$warned if $_[0] =~ /^Wide character in setenv/; print "# @@_" };
	  $forced = $ENV{foo} = $chars;
	  ok($warned == 1, 'ENV store warns about wide characters');
a615 22
	ok(!utf8::is_utf8($forced) && $forced eq $bytes, 'ENV store encodes high utf8 in SV');
	env_is(foo => $bytes, 'ENV store encodes high utf8 in SV');

	# test local $ENV{foo} on existing foo
	{
	  local $ENV{__NoNeSuCh};
	  { local $TODO = 'exists on %ENV should reflect real env';
	    ok(!exists $ENV{__NoNeSuCh}, 'not exists $ENV{existing} during local $ENV{existing}'); }
	  env_is(__NoNeLoCaL => '');
	}
	ok(exists $ENV{__NoNeSuCh}, 'exists $ENV{existing} after local $ENV{existing}');
	env_is(__NoNeSuCh => 'foo');

	# test local $ENV{foo} on new foo
	{
	  local $ENV{__NoNeLoCaL} = 'foo';
	  ok(exists $ENV{__NoNeLoCaL}, 'exists $ENV{new} during local $ENV{new}');
	  env_is(__NoNeLoCaL => 'foo');
	}
	ok(!exists $ENV{__NoNeLoCaL}, 'not exists $ENV{new} after local $ENV{new}');
	env_is(__NoNeLoCaL => '');

@


1.1.1.14
log
@Import perl-5.20.1
@
text
@d8 1
a8 1
    plan (tests => 187);
d59 5
a63 5
$PERL =
   ($Is_NetWare ? 'perl'   :
    $Is_VMS     ? $^X      :
    $Is_MSWin32 ? '.\perl' :
                  './perl');
d85 1
a85 6
        my @@env = `env`;
        SKIP: {
            skip("env doesn't work on this android", 1) if !@@env && $^O =~ /android/;
            chomp (my @@env = grep { s/^$key=// } @@env);
            is "@@env", $val, $desc;
        }
d108 1
a108 1
isnt($!, 0, "Unlinked file can't be opened");
d125 1
a125 1
    open( CMDPIPE, "|-", $PERL);
d148 1
a148 1
    open( CMDPIPE, "|-", $PERL);
a175 1
    $todo = ($Config{usecrosscompile} ? '# TODO: Not sure whats going on here when cross-compiling' : '');
d178 1
a178 1
    open(CMDPIPE, "|-", $PERL);
a202 4
# deleting $::{ENV}
is runperl(prog => 'delete $::{ENV}; chdir; print qq-ok\n-'), "ok\n",
  'deleting $::{ENV}';

a245 2
ok !*@@{HASH}, 'no %@@';

a272 3
    elsif($^O =~ /android/) {
        chomp($wd = `sh -c 'pwd'`);
    }
d345 1
a345 5
  SKIP:
     {
	  skip "# TODO: Hit bug posix-2058; exec does not setup argv[0] correctly." if ($^O eq "vos");
	  is $_, $s1;
     }
d391 1
a391 1
    skip "We don't have prctl() here, or we're on Android", 2 unless $Config{d_prctl_set_name} && $^O ne 'android';
d464 5
a468 7
foreach (['powie::!', 'Errno'],
	 ['powie::+', 'Tie::Hash::NamedCapture']) {
    my ($symbol, $package) = @@$_;
    SKIP: {
	(my $extension = $package) =~ s|::|/|g;
	skip "$package is statically linked", 2
	    if $Config{static_ext} =~ m|\b\Q$extension\E\b|;
d624 1
a624 1
fresh_perl_is 'print $| = ~$|', "1\n", {switches => ['-l']},
d627 1
a627 1
 'select f; undef *f; ${q/|/}; print STDOUT qq|ok\n|', "ok\n", {},
a629 25
# ${^OPEN} and $^H interaction
# Setting ${^OPEN} causes $^H to change, but setting $^H would only some-
# times make ${^OPEN} change, depending on whether it was in the same BEGIN
# block.  Don’t test actual values (subject to change); just test for
# consistency.
my @@stuff;
eval '
    BEGIN { ${^OPEN} = "a\0b"; $^H = 0;          push @@stuff, ${^OPEN} }
    BEGIN { ${^OPEN} = "a\0b"; $^H = 0 } BEGIN { push @@stuff, ${^OPEN} }
1' or die $@@;
is $stuff[0], $stuff[1], '$^H modifies ${^OPEN} consistently';

# deleting $::{"\cH"}
is runperl(prog => 'delete $::{qq-\cH-}; ${^OPEN}=foo; print qq-ok\n-'),
  "ok\n",
  'deleting $::{"\cH"}';

# Tests for some non-magic names:
is ${^MPE}, undef, '${^MPE} starts undefined';
is ++${^MPE}, 1, '${^MPE} can be incremented';

# This one used to behave as ${^MATCH} due to a missing break:
is ${^MPEN}, undef, '${^MPEN} starts undefined';
# This one used to croak due to that missing break:
is ++${^MPEN}, 1, '${^MPEN} can be incremented';
d711 1
a711 1
		unless $^O =~ /^(linux|android|freebsd)$/
a717 1
            skip("\$0 check with 'ps' only on Linux (but not Android) and FreeBSD", 1) if $^O eq 'android';
@


1.1.1.15
log
@Import perl-5.24.2
@
text
@d8 1
a8 1
    plan (tests => 192);
d29 1
a29 1
		$_ = chr(utf8::native_to_unicode(ord($_)) - 64);
d432 2
a433 3
    like($argv0, qr/$name/, "Set process name through argv[0] ($argv0)");
    my $name_substr = substr($name, 0, 15);
    like($prctl, qr/$name_substr/, "Set process name through prctl() ($prctl)");
a676 27
eval { ${^E_NCODING} = 1 };
like $@@, qr/^Modification of a /, 'Setting ${^E_NCODING} croaks';
$_ = ${^E_NCODING};
pass('can read ${^E_NCODING} without blowing up');
is $_, undef, '${^E_NCODING} is undef';

{
    my $warned = 0;
    local $SIG{__WARN__} = sub { ++$warned if $_[0] =~ /Use of uninitialized value in unshift/; print "# @@_"; };
    unshift @@RT12608::A::ISA, qw(RT12608::B RT12608::C);
    is $warned, 0, '[perl #126082] unshifting onto @@ISA doesn\'t trigger set magic for each item';
}

{
    my $warned = 0;
    local $SIG{__WARN__} = sub { ++$warned if $_[0] =~ /Use of uninitialized value in unshift/; print "# @@_"; };

    my $x; tie $x, 'RT12608::F';
    unshift @@RT12608::X::ISA, $x, "RT12608::Z";
    is $warned, 0, '[perl #126082] PL_delaymagic correctly/saved restored when pushing/unshifting onto @@ISA';

    package RT12608::F;
    use parent 'Tie::Scalar';
    sub TIESCALAR { bless {}; }
    sub FETCH { push @@RT12608::G::ISA, "RT12608::H"; "RT12608::Y"; }
}

d680 1
a680 1
    skip("%ENV manipulations fail or aren't safe on $^O", 20)
a681 2
    skip "Win32 needs XS for env/shell tests", 20
        if $Is_MSWin32 && is_miniperl;
@


