head	1.17;
access;
symbols
	OPENBSD_6_0:1.16.0.8
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.16.0.2
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.16.0.4
	OPENBSD_5_8_BASE:1.16
	PERL_5_20_2:1.1.1.15
	OPENBSD_5_7:1.15.0.2
	OPENBSD_5_7_BASE:1.15
	PERL_5_20_1:1.1.1.14
	OPENBSD_5_6:1.14.0.4
	OPENBSD_5_6_BASE:1.14
	PERL_5_18_2:1.1.1.13
	PERL:1.1.1
	OPENBSD_5_5:1.13.0.6
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.2
	OPENBSD_5_4_BASE:1.13
	PERL_5_16_3:1.1.1.12
	OPENBSD_5_3:1.12.0.10
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.8
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.6
	OPENBSD_5_0:1.12.0.4
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.2
	OPENBSD_4_9_BASE:1.12
	PERL_5_12_2:1.1.1.11
	OPENBSD_4_8:1.11.0.4
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.2
	OPENBSD_4_7_BASE:1.11
	PERL_5_10_1:1.1.1.10
	OPENBSD_4_6:1.10.0.6
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.2
	OPENBSD_4_5_BASE:1.10
	PERL_5_10_0:1.1.1.9
	OPENBSD_4_4:1.9.0.18
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.16
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.14
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.12
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.10
	OPENBSD_4_0_BASE:1.9
	PERL_5_8_8:1.1.1.8
	OPENBSD_3_9:1.9.0.8
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.6
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.4
	OPENBSD_3_7_BASE:1.9
	PERL_5_8_6:1.1.1.8
	OPENBSD_3_6:1.9.0.2
	OPENBSD_3_6_BASE:1.9
	PERL_5_8_5:1.1.1.8
	PERL_5_8_3:1.1.1.7
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.17
date	2017.02.05.00.32.20;	author afresh1;	state Exp;
branches;
next	1.16;
commitid	cxJ08BvJA9Pt2PTM;

1.16
date	2015.04.25.19.14.48;	author afresh1;	state Exp;
branches;
next	1.15;
commitid	XRK22kO4se3v2i2I;

1.15
date	2014.11.17.20.57.07;	author afresh1;	state Exp;
branches;
next	1.14;
commitid	QP75iYx42Uo7mMxO;

1.14
date	2014.03.24.15.05.33;	author afresh1;	state Exp;
branches;
next	1.13;

1.13
date	2013.03.25.20.41.00;	author sthen;	state Exp;
branches;
next	1.12;

1.12
date	2010.09.24.15.07.09;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2009.10.12.18.30.28;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2008.09.29.17.36.20;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2004.08.09.18.10.27;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2004.04.07.21.33.10;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.49;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.37;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.36.24;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.08.35;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.52.40;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.08.05.50;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.13.23;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.13.23;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.41.54;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.10.53;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.25.50;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.15.11;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.44.33;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.04.07.21.13.44;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.08.09.17.48.36;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2008.09.29.17.19.02;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2009.10.12.18.10.44;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2010.09.24.14.49.18;	author millert;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2013.03.25.20.09.37;	author sthen;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2014.03.24.14.59.11;	author afresh1;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2014.11.17.20.53.18;	author afresh1;	state Exp;
branches;
next	1.1.1.15;
commitid	B31cAbBIXiCqnL97;

1.1.1.15
date	2015.04.25.19.10.48;	author afresh1;	state Exp;
branches;
next	;
commitid	Wpcs5S8qILgEZC7F;


desc
@@


1.17
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl

BEGIN {
    chdir 't' if -d 't';
    require './test.pl';
    set_up_inc('../lib');
}

use strict;	# Amazed that this hackery can be made strict ...
use Tie::Scalar;

# read in a file
sub cat {
    my $file = shift;
    local $/;
    open my $fh, $file or die "can't open '$file': $!";
    my $data = <$fh>;
    close $fh;
    $data;
}

# read in a utf-8 file
#
sub cat_utf8 {
    my $file = shift;
    local $/;
    open my $fh, '<', $file or die "can't open '$file': $!";
    binmode $fh, ':utf8';
    my $data = <$fh> // die "Can't read from '$file': $!";
    close $fh or die "error closing '$file': $!";
    $data;
}

# write a format to a utf8 file, then read it back in and compare

sub is_format_utf8 {
    my ($glob, $want, $desc) = @@_;
    local $::Level = $::Level + 1;
    my $file = 'Op_write.tmp';
    open $glob, '>:utf8', $file or die "Can't create '$file': $!";
    write $glob;
    close $glob or die "Could not close '$file': $!";
    is(cat_utf8($file), $want, $desc);
}

sub like_format_utf8 {
    my ($glob, $want, $desc) = @@_;
    local $::Level = $::Level + 1;
    my $file = 'Op_write.tmp';
    open $glob, '>:utf8', $file or die "Can't create '$file': $!";
    write $glob;
    close $glob or die "Could not close '$file': $!";
    like(cat_utf8($file), $want, $desc);
}



#-- testing numeric fields in all variants (WL)

sub swrite {
    my $format = shift;
    local $^A = ""; # don't litter, use a local bin
    formline( $format, @@_ );
    return $^A;
}

my @@NumTests = (
    # [ format, value1, expected1, value2, expected2, .... ]
    [ '@@###',           0,   '   0',         1, '   1',     9999.6, '####',
		9999.4999,   '9999',    -999.6, '####',     1e+100, '####' ],

    [ '@@0##',           0,   '0000',         1, '0001',     9999.6, '####',
		-999.4999,   '-999',    -999.6, '####',     1e+100, '####' ],

    [ '^###',           0,   '   0',     undef, '    ' ],

    [ '^0##',           0,   '0000',     undef, '    ' ],

    [ '@@###.',          0,  '   0.',         1, '   1.',    9999.6, '#####',
                9999.4999,  '9999.',    -999.6, '#####' ],

    [ '@@##.##',         0, '  0.00',         1, '  1.00',  999.996, '######',
                999.99499, '999.99',      -100, '######' ],

    [ '@@0#.##',         0, '000.00',         1, '001.00',       10, '010.00',
                  -0.0001, qr/^[\-0]00\.00$/ ],

);


my $num_tests = 0;
for my $tref ( @@NumTests ){
    $num_tests += (@@$tref - 1)/2;
}
#---------------------------------------------------------

# number of tests in section 1
my $bas_tests = 21;

# number of tests in section 3
my $bug_tests = 66 + 3 * 3 * 5 * 2 * 3 + 2 + 66 + 4 + 2 + 3 + 96 + 11 + 3;

# number of tests in section 4
my $hmb_tests = 37;

my $tests = $bas_tests + $num_tests + $bug_tests + $hmb_tests;

plan $tests;

############
## Section 1
############

use vars qw($fox $multiline $foo $good);

format OUT =
the quick brown @@<<
$fox
jumped
@@*
$multiline
^<<<<<<<<<
$foo
^<<<<<<<<<
$foo
^<<<<<<...
$foo
now @@<<the@@>>>> for all@@|||||men to come @@<<<<
{
    'i' . 's', "time\n", $good, 'to'
}
.

open(OUT, '>Op_write.tmp') || die "Can't create Op_write.tmp";
END { unlink_all 'Op_write.tmp' }

$fox = 'foxiness';
$good = 'good';
$multiline = "forescore\nand\nseven years\n";
$foo = 'when in the course of human events it becomes necessary';
write(OUT);
close OUT or die "Could not close: $!";

my $right =
"the quick brown fox
jumped
forescore
and
seven years
when in
the course
of huma...
now is the time for all good men to come to\n";

is cat('Op_write.tmp'), $right and unlink_all 'Op_write.tmp';

$fox = 'wolfishness';
my $fox = 'foxiness';		# Test a lexical variable.

format OUT2 =
the quick brown @@<<
$fox
jumped
@@*
$multiline
^<<<<<<<<< ~~
$foo
now @@<<the@@>>>> for all@@|||||men to come @@<<<<
'i' . 's', "time\n", $good, 'to'
.

open OUT2, '>Op_write.tmp' or die "Can't create Op_write.tmp";

$good = 'good';
$multiline = "forescore\nand\nseven years\n";
$foo = 'when in the course of human events it becomes necessary';
write(OUT2);
close OUT2 or die "Could not close: $!";

$right =
"the quick brown fox
jumped
forescore
and
seven years
when in
the course
of human
events it
becomes
necessary
now is the time for all good men to come to\n";

is cat('Op_write.tmp'), $right and unlink_all 'Op_write.tmp';

eval <<'EOFORMAT';
format OUT2 =
the brown quick @@<<
$fox
jumped
@@*
$multiline
and
^<<<<<<<<< ~~
$foo
now @@<<the@@>>>> for all@@|||||men to come @@<<<<
'i' . 's', "time\n", $good, 'to'
.
EOFORMAT

open(OUT2, '>Op_write.tmp') || die "Can't create Op_write.tmp";

$fox = 'foxiness';
$good = 'good';
$multiline = "forescore\nand\nseven years\n";
$foo = 'when in the course of human events it becomes necessary';
write(OUT2);
close OUT2 or die "Could not close: $!";

$right =
"the brown quick fox
jumped
forescore
and
seven years
and
when in
the course
of human
events it
becomes
necessary
now is the time for all good men to come to\n";

is cat('Op_write.tmp'), $right and unlink_all 'Op_write.tmp';

# formline tests

$right = <<EOT;
@@ a
@@> ab
@@>> abc
@@>>>  abc
@@>>>>   abc
@@>>>>>    abc
@@>>>>>>     abc
@@>>>>>>>      abc
@@>>>>>>>>       abc
@@>>>>>>>>>        abc
@@>>>>>>>>>>         abc
EOT

my $was1 = my $was2 = '';
use vars '$format2';
for (0..10) {           
  # lexical picture
  $^A = '';
  my $format1 = '@@' . '>' x $_;
  formline $format1, 'abc';
  $was1 .= "$format1 $^A\n";
  # global
  $^A = '';
  local $format2 = '@@' . '>' x $_;
  formline $format2, 'abc';
  $was2 .= "$format2 $^A\n";
}
is $was1, $right;
is $was2, $right;

$^A = '';

# more test

format OUT3 =
^<<<<<<...
$foo
.

open(OUT3, '>Op_write.tmp') || die "Can't create Op_write.tmp";

$foo = 'fit          ';
write(OUT3);
close OUT3 or die "Could not close: $!";

$right =
"fit\n";

is cat('Op_write.tmp'), $right and unlink_all 'Op_write.tmp';


# test lexicals and globals
{
    my $test = curr_test();
    my $this = "ok";
    our $that = $test;
    format LEX =
@@<<@@|
$this,$that
.
    open(LEX, ">&STDOUT") or die;
    write LEX;
    $that = ++$test;
    write LEX;
    close LEX or die "Could not close: $!";
    curr_test($test + 1);
}
# LEX_INTERPNORMAL test
my %e = ( a => 1 );
format OUT4 =
@@<<<<<<
"$e{a}"
.
open   OUT4, ">Op_write.tmp" or die "Can't create Op_write.tmp";
write (OUT4);
close  OUT4 or die "Could not close: $!";
is cat('Op_write.tmp'), "1\n" and unlink_all "Op_write.tmp";

# More LEX_INTERPNORMAL
format OUT4a=
@@<<<<<<<<<<<<<<<
"${; use
     strict; \'Nasdaq dropping like flies'}"
.
open   OUT4a, ">Op_write.tmp" or die "Can't create Op_write.tmp";
write (OUT4a);
close  OUT4a or die "Could not close: $!";
is cat('Op_write.tmp'), "Nasdaq dropping\n", 'skipspace inside "${...}"'
    and unlink_all "Op_write.tmp";

eval <<'EOFORMAT';
format OUT10 =
@@####.## @@0###.##
$test1, $test1
.
EOFORMAT

open(OUT10, '>Op_write.tmp') || die "Can't create Op_write.tmp";

use vars '$test1';
$test1 = 12.95;
write(OUT10);
close OUT10 or die "Could not close: $!";

$right = "   12.95 00012.95\n";
is cat('Op_write.tmp'), $right and unlink_all 'Op_write.tmp';

eval <<'EOFORMAT';
format OUT11 =
@@0###.## 
$test1
@@ 0#
$test1
@@0 # 
$test1
.
EOFORMAT

open(OUT11, '>Op_write.tmp') || die "Can't create Op_write.tmp";

$test1 = 12.95;
write(OUT11);
close OUT11 or die "Could not close: $!";

$right = 
"00012.95
1 0#
10 #\n";
is cat('Op_write.tmp'), $right and unlink_all 'Op_write.tmp';

{
    my $test = curr_test();
    my $el;
    format OUT12 =
ok ^<<<<<<<<<<<<<<~~ # sv_chop() naze
$el
.
    my %hash = ($test => 3);
    open(OUT12, '>Op_write.tmp') || die "Can't create Op_write.tmp";

    for $el (keys %hash) {
	write(OUT12);
    }
    close OUT12 or die "Could not close: $!";
    print cat('Op_write.tmp');
    curr_test($test + 1);
}

{
    my $test = curr_test();
    # Bug report and testcase by Alexey Tourbin
    my $v;
    tie $v, 'Tie::StdScalar';
    $v = $test;
    format OUT13 =
ok ^<<<<<<<<< ~~
$v
.
    open(OUT13, '>Op_write.tmp') || die "Can't create Op_write.tmp";
    write(OUT13);
    close OUT13 or die "Could not close: $!";
    print cat('Op_write.tmp');
    curr_test($test + 1);
}

{   # test 14
    # Bug #24774 format without trailing \n failed assertion, but this
    # must fail since we have a trailing ; in the eval'ed string (WL)
    my @@v = ('k');
    eval "format OUT14 = \n@@\n\@@v";
    like $@@, qr/Format not terminated/;
}

{   # test 15
    # text lost in ^<<< field with \r in value (WL)
    my $txt = "line 1\rline 2";
    format OUT15 =
^<<<<<<<<<<<<<<<<<<
$txt
^<<<<<<<<<<<<<<<<<<
$txt
.
    open(OUT15, '>Op_write.tmp') || die "Can't create Op_write.tmp";
    write(OUT15);
    close OUT15 or die "Could not close: $!";
    my $res = cat('Op_write.tmp');
    is $res, "line 1\nline 2\n";
}

{   # test 16: multiple use of a variable in same line with ^<
    my $txt = "this_is_block_1 this_is_block_2 this_is_block_3 this_is_block_4";
    format OUT16 =
^<<<<<<<<<<<<<<<< ^<<<<<<<<<<<<<<<<
$txt,             $txt
^<<<<<<<<<<<<<<<< ^<<<<<<<<<<<<<<<<
$txt,             $txt
.
    open(OUT16, '>Op_write.tmp') || die "Can't create Op_write.tmp";
    write(OUT16);
    close OUT16 or die "Could not close: $!";
    my $res = cat('Op_write.tmp');
    is $res, <<EOD;
this_is_block_1   this_is_block_2
this_is_block_3   this_is_block_4
EOD
}

{   # test 17: @@* "should be on a line of its own", but it should work
    # cleanly with literals before and after. (WL)

    my $txt = "This is line 1.\nThis is the second line.\nThird and last.\n";
    format OUT17 =
Here we go: @@* That's all, folks!
            $txt
.
    open(OUT17, '>Op_write.tmp') || die "Can't create Op_write.tmp";
    write(OUT17);
    close OUT17 or die "Could not close: $!";
    my $res = cat('Op_write.tmp');
    chomp( $txt );
    my $exp = <<EOD;
Here we go: $txt That's all, folks!
EOD
    is $res, $exp;
}

{   # test 18: @@# and ~~ would cause runaway format, but we now
    # catch this while compiling (WL)

    format OUT18 =
@@######## ~~
10
.
    open(OUT18, '>Op_write.tmp') || die "Can't create Op_write.tmp";
    eval { write(OUT18); };
    like $@@,  qr/Repeated format line will never terminate/;
    close OUT18 or die "Could not close: $!";
}

{   # test 19: \0 in an evel'ed format, doesn't cause empty lines (WL)
    my $v = 'gaga';
    eval "format OUT19 = \n" .
         '@@<<<' . "\0\n" .
         '$v' .   "\n" .
         '@@<<<' . "\0\n" .
         '$v' . "\n.\n";
    open(OUT19, '>Op_write.tmp') || die "Can't create Op_write.tmp";
    write(OUT19);
    close OUT19 or die "Could not close: $!";
    my $res = cat('Op_write.tmp');
    is $res, <<EOD;
gaga\0
gaga\0
EOD
}

{   # test 20: hash accesses; single '}' must not terminate format '}' (WL)
    my %h = ( xkey => 'xval', ykey => 'yval' );
    format OUT20 =
@@>>>> @@<<<< ~~
each %h
@@>>>> @@<<<<
$h{xkey}, $h{ykey}
@@>>>> @@<<<<
{ $h{xkey}, $h{ykey}
}
}
.
    my $exp = '';
    while( my( $k, $v ) = each( %h ) ){
	$exp .= sprintf( "%5s %s\n", $k, $v );
    }
    $exp .= sprintf( "%5s %s\n", $h{xkey}, $h{ykey} );
    $exp .= sprintf( "%5s %s\n", $h{xkey}, $h{ykey} );
    $exp .= "}\n";
    open(OUT20, '>Op_write.tmp') || die "Can't create Op_write.tmp";
    write(OUT20);
    close OUT20 or die "Could not close: $!";
    my $res = cat('Op_write.tmp');
    is $res, $exp;
}


#####################
## Section 2
## numeric formatting
#####################

curr_test($bas_tests + 1);

for my $tref ( @@NumTests ){
    my $writefmt = shift( @@$tref );
    while (@@$tref) {
	my $val      = shift @@$tref;
	my $expected = shift @@$tref;
        my $writeres = swrite( $writefmt, $val );
	if (ref $expected) {
	    like $writeres, $expected, $writefmt;
	} else {
	    is $writeres, $expected, $writefmt;
	}	
    }
}


#####################################
## Section 3
## Easiest to add new tests just here
#####################################

# DAPM. Exercise a couple of error codepaths

{
    local $~ = '';
    eval { write };
    like $@@, qr/Undefined format ""/, 'format with 0-length name';

    $~ = "\0foo";
    eval { write };
    like $@@, qr/Undefined format "\0foo"/,
	'no such format beginning with null';

    $~ = "NOSUCHFORMAT";
    eval { write };
    like $@@, qr/Undefined format "NOSUCHFORMAT"/, 'no such format';
}

select +(select(OUT21), do {
    open(OUT21, '>Op_write.tmp') || die "Can't create Op_write.tmp";

    format OUT21 =
@@<<
$_
.

    local $^ = '';
    local $= = 1;
    $_ = "aataaaaaaaaaaaaaa"; eval { write(OUT21) };
    like $@@, qr/Undefined top format ""/, 'top format with 0-length name';

    $^ = "\0foo";
    # For some reason, we have to do this twice to get the error again.
    $_ = "aataaaaaaaaaaaaaa"; eval { write(OUT21) };
    $_ = "aataaaaaaaaaaaaaa"; eval { write(OUT21) };
    like $@@, qr/Undefined top format "\0foo"/,
	'no such top format beginning with null';

    $^ = "NOSUCHFORMAT";
    $_ = "aataaaaaaaaaaaaaa"; eval { write(OUT21) };
    $_ = "aataaaaaaaaaaaaaa"; eval { write(OUT21) };
    like $@@, qr/Undefined top format "NOSUCHFORMAT"/, 'no such top format';

    # reset things;
    eval { write(OUT21) };
    undef $^A;

    close OUT21 or die "Could not close: $!";
})[0];



# [perl #119847],  [perl #119849], [perl #119851]
# Non-real vars like tied, overloaded and refs could, when stringified,
# fail to be processed properly, causing infinite loops on ~~, utf8
# warnings etc, ad nauseum.


my $u22a = "N" x 8;

format OUT22a =
'^<<<<<<<<'~~
$u22a
.

is_format_utf8(\*OUT22a,
               "'NNNNNNNN '\n");


my $u22b = "N" x 8;
utf8::upgrade($u22b);

format OUT22b =
'^<<<<<<<<'~~
$u22b
.

is_format_utf8(\*OUT22b,
               "'NNNNNNNN '\n");

my $u22c = "\x{FF}" x 8;

format OUT22c =
'^<<<<<<<<'~~
$u22c
.

is_format_utf8(\*OUT22c,
               "'\x{FF}\x{FF}\x{FF}\x{FF}\x{FF}\x{FF}\x{FF}\x{FF} '\n");

my $u22d = "\x{FF}" x 8;
utf8::upgrade($u22d);

format OUT22d =
'^<<<<<<<<'~~
$u22d
.

is_format_utf8(\*OUT22d,
               "'\x{FF}\x{FF}\x{FF}\x{FF}\x{FF}\x{FF}\x{FF}\x{FF} '\n");

my $u22e = "\x{100}" x 8;

format OUT22e =
'^<<<<<<<<'~~
$u22e
.

is_format_utf8(\*OUT22e,
               "'\x{100}\x{100}\x{100}\x{100}\x{100}\x{100}\x{100}\x{100} '\n");


my $u22f = "N" x 8;

format OUT22f =
'^<'~~
$u22f
.

is_format_utf8(\*OUT22f,
               "'NN'\n"x4);


my $u22g = "N" x 8;
utf8::upgrade($u22g);

format OUT22g =
'^<'~~
$u22g
.

is_format_utf8(\*OUT22g,
               "'NN'\n"x4);

my $u22h = "\x{FF}" x 8;

format OUT22h =
'^<'~~
$u22h
.

is_format_utf8(\*OUT22h,
               "'\x{FF}\x{FF}'\n"x4);

my $u22i = "\x{FF}" x 8;
utf8::upgrade($u22i);

format OUT22i =
'^<'~~
$u22i
.

is_format_utf8(\*OUT22i,
               "'\x{FF}\x{FF}'\n"x4);

my $u22j = "\x{100}" x 8;

format OUT22j =
'^<'~~
$u22j
.

is_format_utf8(\*OUT22j,
               "'\x{100}\x{100}'\n"x4);


tie my $u23a, 'Tie::StdScalar';
$u23a = "N" x 8;

format OUT23a =
'^<<<<<<<<'~~
$u23a
.

is_format_utf8(\*OUT23a,
               "'NNNNNNNN '\n");


tie my $u23b, 'Tie::StdScalar';
$u23b = "N" x 8;
utf8::upgrade($u23b);

format OUT23b =
'^<<<<<<<<'~~
$u23b
.

is_format_utf8(\*OUT23b,
               "'NNNNNNNN '\n");

tie my $u23c, 'Tie::StdScalar';
$u23c = "\x{FF}" x 8;

format OUT23c =
'^<<<<<<<<'~~
$u23c
.

is_format_utf8(\*OUT23c,
               "'\x{FF}\x{FF}\x{FF}\x{FF}\x{FF}\x{FF}\x{FF}\x{FF} '\n");

tie my $u23d, 'Tie::StdScalar';
my $temp = "\x{FF}" x 8;
utf8::upgrade($temp);
$u23d = $temp;

format OUT23d =
'^<<<<<<<<'~~
$u23d
.

is_format_utf8(\*OUT23d,
               "'\x{FF}\x{FF}\x{FF}\x{FF}\x{FF}\x{FF}\x{FF}\x{FF} '\n");

tie my $u23e, 'Tie::StdScalar';
$u23e = "\x{100}" x 8;

format OUT23e =
'^<<<<<<<<'~~
$u23e
.

is_format_utf8(\*OUT23e,
               "'\x{100}\x{100}\x{100}\x{100}\x{100}\x{100}\x{100}\x{100} '\n");

tie my $u23f, 'Tie::StdScalar';
$u23f = "N" x 8;

format OUT23f =
'^<'~~
$u23f
.

is_format_utf8(\*OUT23f,
               "'NN'\n"x4);


tie my $u23g, 'Tie::StdScalar';
my $temp = "N" x 8;
utf8::upgrade($temp);
$u23g = $temp;

format OUT23g =
'^<'~~
$u23g
.

is_format_utf8(\*OUT23g,
               "'NN'\n"x4);

tie my $u23h, 'Tie::StdScalar';
$u23h = "\x{FF}" x 8;

format OUT23h =
'^<'~~
$u23h
.

is_format_utf8(\*OUT23h,
               "'\x{FF}\x{FF}'\n"x4);

$temp = "\x{FF}" x 8;
utf8::upgrade($temp);
tie my $u23i, 'Tie::StdScalar';
$u23i = $temp;

format OUT23i =
'^<'~~
$u23i
.

is_format_utf8(\*OUT23i,
               "'\x{FF}\x{FF}'\n"x4);

tie my $u23j, 'Tie::StdScalar';
$u23j = "\x{100}" x 8;

format OUT23j =
'^<'~~
$u23j
.

is_format_utf8(\*OUT23j,
               "'\x{100}\x{100}'\n"x4);

{
    package UTF8Toggle;

    sub TIESCALAR {
        my $class = shift;
        my $value = shift;
        my $state = shift||0;
        return bless [$value, $state], $class;
    }

    sub FETCH {
        my $self = shift;
        $self->[1] = ! $self->[1];
        if ($self->[1]) {
           utf8::downgrade($self->[0]);
        } else {
           utf8::upgrade($self->[0]);
        }
        $self->[0];
    }

   sub STORE {
       my $self = shift;
       $self->[0] = shift;
    }
}

tie my $u24a, 'UTF8Toggle';
$u24a = "N" x 8;

format OUT24a =
'^<<<<<<<<'~~
$u24a
.

is_format_utf8(\*OUT24a,
               "'NNNNNNNN '\n");


tie my $u24b, 'UTF8Toggle';
$u24b = "N" x 8;
utf8::upgrade($u24b);

format OUT24b =
'^<<<<<<<<'~~
$u24b
.

is_format_utf8(\*OUT24b,
               "'NNNNNNNN '\n");

tie my $u24c, 'UTF8Toggle';
$u24c = "\x{FF}" x 8;

format OUT24c =
'^<<<<<<<<'~~
$u24c
.

is_format_utf8(\*OUT24c,
               "'\x{FF}\x{FF}\x{FF}\x{FF}\x{FF}\x{FF}\x{FF}\x{FF} '\n");

tie my $u24d, 'UTF8Toggle', 1;
$u24d = "\x{FF}" x 8;

format OUT24d =
'^<<<<<<<<'~~
$u24d
.

is_format_utf8(\*OUT24d,
               "'\x{FF}\x{FF}\x{FF}\x{FF}\x{FF}\x{FF}\x{FF}\x{FF} '\n");



tie my $u24f, 'UTF8Toggle';
$u24f = "N" x 8;

format OUT24f =
'^<'~~
$u24f
.

is_format_utf8(\*OUT24f,
               "'NN'\n"x4);


tie my $u24g, 'UTF8Toggle';
my $temp = "N" x 8;
utf8::upgrade($temp);
$u24g = $temp;

format OUT24g =
'^<'~~
$u24g
.

is_format_utf8(\*OUT24g,
               "'NN'\n"x4);

tie my $u24h, 'UTF8Toggle';
$u24h = "\x{FF}" x 8;

format OUT24h =
'^<'~~
$u24h
.

is_format_utf8(\*OUT24h,
               "'\x{FF}\x{FF}'\n"x4);

tie my $u24i, 'UTF8Toggle', 1;
$u24i = "\x{FF}" x 8;

format OUT24i =
'^<'~~
$u24i
.

is_format_utf8(\*OUT24i,
               "'\x{FF}\x{FF}'\n"x4);

{
    package OS;
    use overload '""' => sub { ${$_[0]}; };

    sub new {
        my ($class, $value) = @@_;
        bless \$value, $class;
    }
}

my $u25a = OS->new("N" x 8);

format OUT25a =
'^<<<<<<<<'~~
$u25a
.

is_format_utf8(\*OUT25a,
               "'NNNNNNNN '\n");


my $temp = "N" x 8;
utf8::upgrade($temp);
my $u25b = OS->new($temp);

format OUT25b =
'^<<<<<<<<'~~
$u25b
.

is_format_utf8(\*OUT25b,
               "'NNNNNNNN '\n");

my $u25c = OS->new("\x{FF}" x 8);

format OUT25c =
'^<<<<<<<<'~~
$u25c
.

is_format_utf8(\*OUT25c,
               "'\x{FF}\x{FF}\x{FF}\x{FF}\x{FF}\x{FF}\x{FF}\x{FF} '\n");

$temp = "\x{FF}" x 8;
utf8::upgrade($temp);
my $u25d = OS->new($temp);

format OUT25d =
'^<<<<<<<<'~~
$u25d
.

is_format_utf8(\*OUT25d,
               "'\x{FF}\x{FF}\x{FF}\x{FF}\x{FF}\x{FF}\x{FF}\x{FF} '\n");

my $u25e = OS->new("\x{100}" x 8);

format OUT25e =
'^<<<<<<<<'~~
$u25e
.

is_format_utf8(\*OUT25e,
               "'\x{100}\x{100}\x{100}\x{100}\x{100}\x{100}\x{100}\x{100} '\n");


my $u25f = OS->new("N" x 8);

format OUT25f =
'^<'~~
$u25f
.

is_format_utf8(\*OUT25f,
               "'NN'\n"x4);


$temp = "N" x 8;
utf8::upgrade($temp);
my $u25g = OS->new($temp);

format OUT25g =
'^<'~~
$u25g
.

is_format_utf8(\*OUT25g,
               "'NN'\n"x4);

my $u25h = OS->new("\x{FF}" x 8);

format OUT25h =
'^<'~~
$u25h
.

is_format_utf8(\*OUT25h,
               "'\x{FF}\x{FF}'\n"x4);

$temp = "\x{FF}" x 8;
utf8::upgrade($temp);
my $u25i = OS->new($temp);

format OUT25i =
'^<'~~
$u25i
.

is_format_utf8(\*OUT25i,
               "'\x{FF}\x{FF}'\n"x4);

my $u25j = OS->new("\x{100}" x 8);

format OUT25j =
'^<'~~
$u25j
.

is_format_utf8(\*OUT25j,
               "'\x{100}\x{100}'\n"x4);

{
    package OS::UTF8Toggle;
    use overload '""' => sub {
        my $self = shift;
        $self->[1] = ! $self->[1];
        if ($self->[1]) {
            utf8::downgrade($self->[0]);
        } else {
            utf8::upgrade($self->[0]);
        }
        $self->[0];
    };

    sub new {
        my ($class, $value, $state) = @@_;
        bless [$value, $state], $class;
    }
}


my $u26a = OS::UTF8Toggle->new("N" x 8);

format OUT26a =
'^<<<<<<<<'~~
$u26a
.

is_format_utf8(\*OUT26a,
               "'NNNNNNNN '\n");


my $u26b = OS::UTF8Toggle->new("N" x 8, 1);

format OUT26b =
'^<<<<<<<<'~~
$u26b
.

is_format_utf8(\*OUT26b,
               "'NNNNNNNN '\n");

my $u26c = OS::UTF8Toggle->new("\x{FF}" x 8);

format OUT26c =
'^<<<<<<<<'~~
$u26c
.

is_format_utf8(\*OUT26c,
               "'\x{FF}\x{FF}\x{FF}\x{FF}\x{FF}\x{FF}\x{FF}\x{FF} '\n");

my $u26d = OS::UTF8Toggle->new("\x{FF}" x 8, 1);

format OUT26d =
'^<<<<<<<<'~~
$u26d
.

is_format_utf8(\*OUT26d,
               "'\x{FF}\x{FF}\x{FF}\x{FF}\x{FF}\x{FF}\x{FF}\x{FF} '\n");


my $u26f = OS::UTF8Toggle->new("N" x 8);

format OUT26f =
'^<'~~
$u26f
.

is_format_utf8(\*OUT26f,
               "'NN'\n"x4);


my $u26g = OS::UTF8Toggle->new("N" x 8, 1);

format OUT26g =
'^<'~~
$u26g
.

is_format_utf8(\*OUT26g,
               "'NN'\n"x4);

my $u26h = OS::UTF8Toggle->new("\x{FF}" x 8);

format OUT26h =
'^<'~~
$u26h
.

is_format_utf8(\*OUT26h,
               "'\x{FF}\x{FF}'\n"x4);

my $u26i = OS::UTF8Toggle->new("\x{FF}" x 8, 1);

format OUT26i =
'^<'~~
$u26i
.

is_format_utf8(\*OUT26i,
               "'\x{FF}\x{FF}'\n"x4);



{
    my $zero = $$ - $$;

    package Number;

    sub TIESCALAR {
        my $class = shift;
        my $value = shift;
        return bless \$value, $class;
    }

    # The return value should always be SvNOK() only:
    sub FETCH {
        my $self = shift;
        # avoid "" getting converted to "0" and thus
        # causing an infinite loop
        return "" unless length ($$self);
        return $$self - 0.5 + $zero + 0.5;
    }

   sub STORE {
       my $self = shift;
       $$self = shift;
    }

   package ONumber;

   use overload '""' => sub {
        my $self = shift;
        return $$self - 0.5 + $zero + 0.5;
    };

    sub new {
       my $class = shift;
       my $value = shift;
       return bless \$value, $class;
   }
}

my $v27a = 1/256;

format OUT27a =
'^<<<<<<<<<'~~
$v27a
.

is_format_utf8(\*OUT27a,
               "'0.00390625'\n");

my $v27b = 1/256;

format OUT27b =
'^<'~~
$v27b
.

is_format_utf8(\*OUT27b,
               "'0.'\n'00'\n'39'\n'06'\n'25'\n");

tie my $v27c, 'Number', 1/256;

format OUT27c =
'^<<<<<<<<<'~~
$v27c
.

is_format_utf8(\*OUT27c,
               "'0.00390625'\n");

my $v27d = 1/256;

format OUT27d =
'^<'~~
$v27d
.

is_format_utf8(\*OUT27d,
               "'0.'\n'00'\n'39'\n'06'\n'25'\n");

my $v27e = ONumber->new(1/256);

format OUT27e =
'^<<<<<<<<<'~~
$v27e
.

is_format_utf8(\*OUT27e,
               "'0.00390625'\n");

my $v27f = ONumber->new(1/256);

format OUT27f =
'^<'~~
$v27f
.

is_format_utf8(\*OUT27f,
               "'0.'\n'00'\n'39'\n'06'\n'25'\n");

{
    package Ref;
    use overload '""' => sub {
	return ${$_[0]};
    };

    sub new {
       my $class = shift;
       my $value = shift;
       return bless \$value, $class;
   }
}

my $v28a = {};

format OUT28a =
'^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<'~~
$v28a
.


# 'HASH(0x1716b60)     '
my $qr_hash   = qr/^'HASH\(0x[0-9a-f]+\)\s+'\n$/;

# 'HASH'
# '(0x1'
# '716b'
# 'c0) '
my $qr_hash_m = qr/^'HASH'\n('[0-9a-fx() ]{4}'\n)+$/;

like_format_utf8(\*OUT28a, $qr_hash);

my $v28b = {};

format OUT28b =
'^<<<'~~
$v28b
.

like_format_utf8(\*OUT28b, $qr_hash_m);


tie my $v28c, 'Tie::StdScalar';
$v28c = {};

format OUT28c =
'^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<'~~
$v28c
.

like_format_utf8(\*OUT28c, $qr_hash);

tie my $v28d, 'Tie::StdScalar';
$v28d = {};

format OUT28d =
'^<<<'~~
$v28d
.

like_format_utf8(\*OUT28d, $qr_hash_m);

my $v28e = Ref->new({});

format OUT28e =
'^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<'~~
$v28e
.

like_format_utf8(\*OUT28e, $qr_hash);

my $v28f = Ref->new({});

format OUT28f =
'^<<<'~~
$v28f
.

like_format_utf8(\*OUT28f, $qr_hash_m);



{
  package Count;

  sub TIESCALAR {
    my $class = shift;
    bless [shift, 0, 0], $class;
  }

  sub FETCH {
    my $self = shift;
    ++$self->[1];
    $self->[0];
  }

  sub STORE {
    my $self = shift;
    ++$self->[2];
    $self->[0] = shift;
  }
}

{
  my ($pound_utf8, $pm_utf8) = map { my $a = "$_\x{100}"; chop $a; $a}
    my ($pound, $pm) = ("\xA3", "\xB1");

  foreach my $first ('N', $pound, $pound_utf8) {
    foreach my $base ('N', $pm, $pm_utf8) {
      foreach my $second ($base, "$base\n", "$base\nMoo!", "$base\nMoo!\n",
			  "$base\nMoo!\n",) {
	foreach (['^*', qr/(.+)/], ['@@*', qr/(.*?)$/s]) {
	  my ($format, $re) = @@$_;
	  $format = "1^*2 3${format}4";
	  foreach my $class ('', 'Count') {
	    my $name = qq{swrite("$format", "$first", "$second") class="$class"};
	    $name =~ s/\n/\\n/g;
	    $name =~ s{(.)}{
			ord($1) > 126 ? sprintf("\\x{%x}",ord($1)) : $1
		    }ge;

	    $first =~ /(.+)/ or die $first;
	    my $expect = "1${1}2";
	    $second =~ $re or die $second;
	    $expect .= " 3${1}4";

	    if ($class) {
	      my $copy1 = $first;
	      my $copy2;
	      tie $copy2, $class, $second;
	      is swrite("$format", $copy1, $copy2), $expect, $name;
	      my $obj = tied $copy2;
	      is $obj->[1], 1, 'value read exactly once';
	    } else {
	      my ($copy1, $copy2) = ($first, $second);
	      is swrite("$format", $copy1, $copy2), $expect, $name;
	    }
	  }
	}
      }
    }
  }
}

{
  # This will fail an assertion in 5.10.0 built with -DDEBUGGING (because
  # pp_formline attempts to set SvCUR() on an SVt_RV). I suspect that it will
  # be doing something similarly out of bounds on everything from 5.000
  my $ref = [];
  my $exp = ">$ref<";
  is swrite('>^*<', $ref), $exp;
  $ref = [];
  my $exp = ">$ref<";
  is swrite('>@@*<', $ref), $exp;
}

format EMPTY =
.

my $test = curr_test();

format Comment =
ok @@<<<<<
$test
.


# RT #8698 format bug with undefined _TOP

open STDOUT_DUP, ">&STDOUT";
my $oldfh = select STDOUT_DUP;
$= = 10;
{
  local $~ = "Comment";
  write;
  curr_test($test + 1);
  is $-, 9;
  is $^, "STDOUT_DUP_TOP";
}
select $oldfh;
close STDOUT_DUP;

*CmT =  *{$::{Comment}}{FORMAT};
ok  defined *{$::{CmT}}{FORMAT}, "glob assign";


# RT #91032: Check that "non-real" strings like tie and overload work,
# especially that they re-compile the pattern on each FETCH, and that
# they don't overrun the buffer


{
    package RT91032;

    sub TIESCALAR { bless [] }
    my $i = 0;
    sub FETCH { $i++; "A$i @@> Z\n" }

    use overload '""' => \&FETCH;

    tie my $f, 'RT91032';

    formline $f, "a";
    formline $f, "bc";
    ::is $^A, "A1  a Z\nA2 bc Z\n", "RT 91032: tied";
    $^A = '';

    my $g = bless []; # has overloaded stringify
    formline $g, "de";
    formline $g, "f";
    ::is $^A, "A3 de Z\nA4  f Z\n", "RT 91032: overloaded";
    $^A = '';

    my $h = [];
    formline $h, "junk1";
    formline $h, "junk2";
    ::is ref($h), 'ARRAY', "RT 91032: array ref still a ref";
    ::like "$h", qr/^ARRAY\(0x[0-9a-f]+\)$/, "RT 91032: array stringifies ok";
    ::is $^A, "$h$h","RT 91032: stringified array";
    $^A = '';

    # used to overwrite the ~~ in the *original SV with spaces. Naughty!

    my $orig = my $format = "^<<<<< ~~\n";
    my $abc = "abc";
    formline $format, $abc;
    $^A ='';
    ::is $format, $orig, "RT91032: don't overwrite orig format string";

    # check that ~ and ~~ are displayed correctly as whitespace,
    # under the influence of various different types of border

    for my $n (1,2) {
	for my $lhs (' ', 'Y', '^<<<', '^|||', '^>>>') {
	    for my $rhs ('', ' ', 'Z', '^<<<', '^|||', '^>>>') {
		my $fmt = "^<B$lhs" . ('~' x $n) . "$rhs\n";
		my $sfmt = ($fmt =~ s/~/ /gr);
		my ($a, $bc, $stop);
		($a, $bc, $stop) = ('a', 'bc', 's');
		# $stop is to stop '~~' deleting the whole line
		formline $sfmt, $stop, $a, $bc;
		my $exp = $^A;
		$^A = '';
		($a, $bc, $stop) = ('a', 'bc', 's');
		formline $fmt, $stop, $a, $bc;
		my $got = $^A;
		$^A = '';
		$fmt =~ s/\n/\\n/;
		::is($got, $exp, "chop munging: [$fmt]");
	    }
	}
    }
}

# check that '~  (delete current line if empty) works when
# the target gets upgraded to uft8 (and re-allocated) midstream.

{
    my $format = "\x{100}@@~\n"; # format is utf8
    # this target is not utf8, but will expand (and get reallocated)
    # when upgraded to utf8.
    my $orig = "\x80\x81\x82";
    local $^A = $orig;
    my $empty = "";
    formline $format, $empty;
    is $^A , $orig, "~ and realloc";

    # check similarly that trailing blank removal works ok

    $format = "@@<\n\x{100}"; # format is utf8
    chop $format;
    $orig = "   ";
    $^A = $orig;
    formline $format, "  ";
    is $^A, "$orig\n", "end-of-line blanks and realloc";

    # and check this doesn't overflow the buffer

    local $^A = '';
    $format = "@@* @@####\n";
    $orig = "x" x 100 . "\n";
    formline $format, $orig, 12345;
    is $^A, ("x" x 100) . " 12345\n", "\@@* doesn't overflow";

    # make sure it can cope with formats > 64k

    $format = 'x' x 65537;
    $^A = '';
    formline $format;
    # don't use 'is' here, as the diag output will be too long!
    ok $^A eq $format, ">64K";
}


SKIP: {
    skip_if_miniperl('miniperl does not support scalario');
    my $buf = "";
    open my $fh, ">", \$buf;
    my $old_fh = select $fh;
    local $~ = "CmT";
    write;
    select $old_fh;
    close $fh;
    is $buf, "ok $test\n", "write to duplicated format";
}

format caret_A_test_TOP =
T
.

format caret_A_test =
L1
L2
L3
L4
.

SKIP: {
    skip_if_miniperl('miniperl does not support scalario');
    my $buf = "";
    open my $fh, ">", \$buf;
    my $old_fh = select $fh;
    local $^ = "caret_A_test_TOP";
    local $~ = "caret_A_test";
    local $= = 3;
    local $^A = "A1\nA2\nA3\nA4\n";
    write;
    select $old_fh;
    close $fh;
    is $buf, "T\nA1\nA2\n\fT\nA3\nA4\n\fT\nL1\nL2\n\fT\nL3\nL4\n",
		    "assign to ^A sets FmLINES";
}

fresh_perl_like(<<'EOP', qr/^Format STDOUT redefined at/, {stderr => 1}, '#64562 - Segmentation fault with redefined formats and warnings');
#!./perl

use strict;
use warnings; # crashes!

format =
.

write;

format =
.

write;
EOP

fresh_perl_is(<<'EOP', ">ARRAY<\ncrunch_eth\n", {stderr => 1}, '#79532 - formline coerces its arguments');
use strict;
use warnings;
my $zamm = ['crunch_eth'];
formline $zamm;
printf ">%s<\n", ref $zamm;
print "$zamm->[0]\n";
EOP

# [perl #73690]

select +(select(RT73690), do {
    open(RT73690, '>Op_write.tmp') || die "Can't create Op_write.tmp";
    format RT73690 =
@@<< @@<<
11, 22
.

    my @@ret;

    @@ret = write;
    is(scalar(@@ret), 1);
    ok($ret[0]);
    @@ret = scalar(write);
    is(scalar(@@ret), 1);
    ok($ret[0]);
    @@ret = write(RT73690);
    is(scalar(@@ret), 1);
    ok($ret[0]);
    @@ret = scalar(write(RT73690));
    is(scalar(@@ret), 1);
    ok($ret[0]);

    @@ret = ('a', write, 'z');
    is(scalar(@@ret), 3);
    is($ret[0], 'a');
    ok($ret[1]);
    is($ret[2], 'z');
    @@ret = ('b', scalar(write), 'y');
    is(scalar(@@ret), 3);
    is($ret[0], 'b');
    ok($ret[1]);
    is($ret[2], 'y');
    @@ret = ('c', write(RT73690), 'x');
    is(scalar(@@ret), 3);
    is($ret[0], 'c');
    ok($ret[1]);
    is($ret[2], 'x');
    @@ret = ('d', scalar(write(RT73690)), 'w');
    is(scalar(@@ret), 3);
    is($ret[0], 'd');
    ok($ret[1]);
    is($ret[2], 'w');

    @@ret = do { write; 'foo' };
    is(scalar(@@ret), 1);
    is($ret[0], 'foo');
    @@ret = do { scalar(write); 'bar' };
    is(scalar(@@ret), 1);
    is($ret[0], 'bar');
    @@ret = do { write(RT73690); 'baz' };
    is(scalar(@@ret), 1);
    is($ret[0], 'baz');
    @@ret = do { scalar(write(RT73690)); 'quux' };
    is(scalar(@@ret), 1);
    is($ret[0], 'quux');

    @@ret = ('a', do { write; 'foo' }, 'z');
    is(scalar(@@ret), 3);
    is($ret[0], 'a');
    is($ret[1], 'foo');
    is($ret[2], 'z');
    @@ret = ('b', do { scalar(write); 'bar' }, 'y');
    is(scalar(@@ret), 3);
    is($ret[0], 'b');
    is($ret[1], 'bar');
    is($ret[2], 'y');
    @@ret = ('c', do { write(RT73690); 'baz' }, 'x');
    is(scalar(@@ret), 3);
    is($ret[0], 'c');
    is($ret[1], 'baz');
    is($ret[2], 'x');
    @@ret = ('d', do { scalar(write(RT73690)); 'quux' }, 'w');
    is(scalar(@@ret), 3);
    is($ret[0], 'd');
    is($ret[1], 'quux');
    is($ret[2], 'w');

    close RT73690 or die "Could not close: $!";
})[0];

select +(select(RT73690_2), do {
    open(RT73690_2, '>Op_write.tmp') || die "Can't create Op_write.tmp";
    format RT73690_2 =
@@<< @@<<
return
.

    my @@ret;

    @@ret = write;
    is(scalar(@@ret), 1);
    ok(!$ret[0]);
    @@ret = scalar(write);
    is(scalar(@@ret), 1);
    ok(!$ret[0]);
    @@ret = write(RT73690_2);
    is(scalar(@@ret), 1);
    ok(!$ret[0]);
    @@ret = scalar(write(RT73690_2));
    is(scalar(@@ret), 1);
    ok(!$ret[0]);

    @@ret = ('a', write, 'z');
    is(scalar(@@ret), 3);
    is($ret[0], 'a');
    ok(!$ret[1]);
    is($ret[2], 'z');
    @@ret = ('b', scalar(write), 'y');
    is(scalar(@@ret), 3);
    is($ret[0], 'b');
    ok(!$ret[1]);
    is($ret[2], 'y');
    @@ret = ('c', write(RT73690_2), 'x');
    is(scalar(@@ret), 3);
    is($ret[0], 'c');
    ok(!$ret[1]);
    is($ret[2], 'x');
    @@ret = ('d', scalar(write(RT73690_2)), 'w');
    is(scalar(@@ret), 3);
    is($ret[0], 'd');
    ok(!$ret[1]);
    is($ret[2], 'w');

    @@ret = do { write; 'foo' };
    is(scalar(@@ret), 1);
    is($ret[0], 'foo');
    @@ret = do { scalar(write); 'bar' };
    is(scalar(@@ret), 1);
    is($ret[0], 'bar');
    @@ret = do { write(RT73690_2); 'baz' };
    is(scalar(@@ret), 1);
    is($ret[0], 'baz');
    @@ret = do { scalar(write(RT73690_2)); 'quux' };
    is(scalar(@@ret), 1);
    is($ret[0], 'quux');

    @@ret = ('a', do { write; 'foo' }, 'z');
    is(scalar(@@ret), 3);
    is($ret[0], 'a');
    is($ret[1], 'foo');
    is($ret[2], 'z');
    @@ret = ('b', do { scalar(write); 'bar' }, 'y');
    is(scalar(@@ret), 3);
    is($ret[0], 'b');
    is($ret[1], 'bar');
    is($ret[2], 'y');
    @@ret = ('c', do { write(RT73690_2); 'baz' }, 'x');
    is(scalar(@@ret), 3);
    is($ret[0], 'c');
    is($ret[1], 'baz');
    is($ret[2], 'x');
    @@ret = ('d', do { scalar(write(RT73690_2)); 'quux' }, 'w');
    is(scalar(@@ret), 3);
    is($ret[0], 'd');
    is($ret[1], 'quux');
    is($ret[2], 'w');

    close RT73690_2 or die "Could not close: $!";
})[0];

open(UNDEF, '>Op_write.tmp') || die "Can't create Op_write.tmp";
select +(select(UNDEF), $~ = "UNDEFFORMAT")[0];
format UNDEFFORMAT =
@@
undef *UNDEFFORMAT
.
write UNDEF;
pass "active format cannot be freed";

select +(select(UNDEF), $~ = "UNDEFFORMAT2")[0];
format UNDEFFORMAT2 =
@@
close UNDEF or die "Could not close: $!"; undef *UNDEF
.
write UNDEF;
pass "freeing current handle in format";
undef $^A;

ok !eval q|
format foo {
@@<<<
$a
}
;1
|, 'format foo { ... } is not allowed';

ok !eval q|
format =
@@<<<
}
;1
|, 'format = ... } is not allowed';

open(NEST, '>Op_write.tmp') || die "Can't create Op_write.tmp";
format NEST =
@@<<<
{
    my $birds = "birds";
    local *NEST = *BIRDS{FORMAT};
    write NEST;
    format BIRDS =
@@<<<<<
$birds;
.
    "nest"
}
.
write NEST;
close NEST or die "Could not close: $!";
is cat('Op_write.tmp'), "birds\nnest\n", 'nested formats';

# A compilation error should not create a format
eval q|
format ERROR =
@@
@@_ =~ s///
.
|;
eval { write ERROR };
like $@@, qr'Undefined format',
    'formats with compilation errors are not created';

# This syntax error used to cause a crash, double free, or a least
# a bad read.
# See the long-winded explanation at:
#   https://rt.perl.org/rt3/Ticket/Display.html?id=43425#txn-1144500
eval q|
format =
@@
use;format
strict
.
|;
pass('no crash with invalid use/format inside format');


# Low-precedence operators on argument line
format AND =
@@
0 and die
.
$- = $=;
ok eval { local $~ = "AND"; print "# "; write; 1 },
    "low-prec ops on arg line" or diag $@@;

# Anonymous hashes
open(HASH, '>Op_write.tmp') || die "Can't create Op_write.tmp";
format HASH =
@@<<<
${{qw[ Sun 0 Mon 1 Tue 2 Wed 3 Thu 4 Fri 5 Sat 6 ]}}{"Wed"}
.
write HASH;
close HASH or die "Could not close: $!";
is cat('Op_write.tmp'), "3\n", 'anonymous hashes';

open(HASH2, '>Op_write.tmp') || die "Can't create Op_write.tmp";
format HASH2 =
@@<<<
+{foo=>"bar"}
.
write HASH2;
close HASH2 or die "Could not close: $!";
is cat('Op_write.tmp'), "HASH\n", '+{...} is interpreted as anon hash';

# Anonymous hashes
open(BLOCK, '>Op_write.tmp') || die "Can't create Op_write.tmp";
format BLOCK =
@@<<< @@<<<
{foo=>"bar"} # this is a block, not a hash!
.
write BLOCK;
close BLOCK or die "Could not close: $!";
is cat('Op_write.tmp'), "foo  bar\n", 'initial { is always BLOCK';

# pragmata inside argument line
open(STRICT, '>Op_write.tmp') || die "Can't create Op_write.tmp";
format STRICT =
@@<<<
no strict; $foo
.
$::foo = 'oof::$';
write STRICT;
close STRICT or die "Could not close: $!";
is cat('Op_write.tmp'), "oof:\n", 'pragmata on format line';

SKIP: {
   skip "no weak refs" unless eval { require Scalar::Util };
   sub Potshriggley {
format Potshriggley =
.
   }
   Scalar::Util::weaken(my $x = *Potshriggley{FORMAT});
   undef *Potshriggley;
   is $x, undef, 'formats in subs do not leak';
}

fresh_perl_is(<<'EOP', <<'EXPECT',
use warnings 'syntax' ;
format STDOUT =
^*|^*
my $x = q/dd/, $x
.
write;
EOP
dd|
EXPECT
	      { stderr => 1 }, '#123245 panic in sv_chop');

fresh_perl_is(<<'EOP', <<'EXPECT',
use warnings 'syntax' ;
format STDOUT =
^*|^*
my $x = q/dd/
.
write;
EOP
Not enough format arguments at - line 4.
dd|
EXPECT
	      { stderr => 1 }, '#123245 different panic in sv_chop');

fresh_perl_is(<<'EOP', <<'EXPECT',
format STDOUT =
# x at the end to make the spaces visible
@@... x
q/a/
.
write;
EOP
a    x
EXPECT
	      { stderr => 1 }, '#123538 crash in FF_MORE');

#############################
## Section 4
## Add new tests *above* here
#############################

# scary format testing from H.Merijn Brand

# Just a complete test for format, including top-, left- and bottom marging
# and format detection through glob entries

if ($^O eq 'VMS' || $^O eq 'MSWin32' || $^O eq 'dos' ||
    ($^O eq 'os2' and not eval '$OS2::can_fork')) {
  $test = curr_test();
 SKIP: {
      skip "'|-' and '-|' not supported", $tests - $test + 1;
  }
  exit(0);
}


$^  = "STDOUT_TOP";
$=  =  7;		# Page length
$-  =  0;		# Lines left
my $ps = $^L; $^L = "";	# Catch the page separator
my $tm =  1;		# Top margin (empty lines before first output)
my $bm =  2;		# Bottom marging (empty lines between last text and footer)
my $lm =  4;		# Left margin (indent in spaces)

# -----------------------------------------------------------------------
#
# execute the rest of the script in a child process. The parent reads the
# output from the child and compares it with <DATA>.

my @@data = <DATA>;

select ((select (STDOUT), $| = 1)[0]); # flush STDOUT

my $opened = open FROM_CHILD, "-|";
unless (defined $opened) {
    fail "open gave $!";
    exit 0;
}

if ($opened) {
    # in parent here

    pass 'open';
    my $s = " " x $lm;
    while (<FROM_CHILD>) {
	unless (@@data) {
	    fail 'too much output';
	    exit;
	}
	s/^/$s/;
	my $exp = shift @@data;
	is $_, $exp;
    }
    close FROM_CHILD;
    is "@@data", "", "correct length of output";
    exit;
}

# in child here
$::NO_ENDING = 1;

    select ((select (STDOUT), $| = 1)[0]);
$tm = "\n" x $tm;
$= -= $bm + 1; # count one for the trailing "----"
my $lastmin = 0;

my @@E;

sub wryte
{
    $lastmin = $-;
    write;
    } # wryte;

sub footer
{
    $% == 1 and return "";

    $lastmin < $= and print "\n" x $lastmin;
    print "\n" x $bm, "----\n", $ps;
    $lastmin = $-;
    "";
    } # footer

# Yes, this is sick ;-)
format TOP =
@@* ~
@@{[footer]}
@@* ~
$tm
.

format ENTRY =
@@ @@<<<<~~
@@{(shift @@E)||["",""]}
.

format EOR =
- -----
.

sub has_format ($)
{
    my $fmt = shift;
    exists $::{$fmt} or return 0;
    $^O eq "MSWin32" or return defined *{$::{$fmt}}{FORMAT};
    open my $null, "> /dev/null" or die;
    my $fh = select $null;
    local $~ = $fmt;
    eval "write";
    select $fh;
    $@@?0:1;
    } # has_format

$^ = has_format ("TOP") ? "TOP" : "EMPTY";
has_format ("ENTRY") or die "No format defined for ENTRY";
foreach my $e ( [ map { [ $_, "Test$_"   ] } 1 .. 7 ],
		[ map { [ $_, "${_}tseT" ] } 1 .. 5 ]) {
    @@E = @@$e;
    local $~ = "ENTRY";
    wryte;
    has_format ("EOR") or next;
    local $~ = "EOR";
    wryte;
    }
if (has_format ("EOF")) {
    local $~ = "EOF";
    wryte;
    }

close STDOUT;

# That was test 48.

__END__
    
    1 Test1
    2 Test2
    3 Test3
    
    
    ----
    
    4 Test4
    5 Test5
    6 Test6
    
    
    ----
    
    7 Test7
    - -----
    
    
    
    ----
    
    1 1tseT
    2 2tseT
    3 3tseT
    
    
    ----
    
    4 4tseT
    5 5tseT
    - -----
@


1.16
log
@Fix merge issues, remove excess files - match perl-5.20.2 dist
@
text
@a4 1
    @@INC = '../lib';
d6 1
@


1.15
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d101 1
a101 1
my $bug_tests = 66 + 3 * 3 * 5 * 2 * 3 + 2 + 66 + 4 + 2 + 3 + 96 + 11;
d1938 36
@


1.14
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d10 1
d22 36
d101 1
a101 1
my $bug_tests = 8 + 3 * 3 * 5 * 2 * 3 + 2 + 66 + 4 + 2 + 3 + 96 + 11;
d104 1
a104 1
my $hmb_tests = 35;
a390 1
    use Tie::Scalar;
d599 764
d1430 5
a1434 2
  is swrite('>^*<', $ref), ">$ref<";
  is swrite('>@@*<', $ref), ">$ref<";
d1896 19
@


1.13
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d61 1
a61 1
my $bas_tests = 20;
d64 1
a64 1
my $bug_tests = 4 + 3 * 3 * 5 * 2 * 3 + 2 + 66 + 4 + 2 + 3;
d281 12
d519 6
a524 1
    like $@@, qr/Not a format reference/, 'format reference';
d528 1
a528 1
    like $@@, qr/Undefined format/, 'no such format';
d531 32
d836 280
@


1.12
log
@merge in perl 5.12.2 plus local changes
@
text
@d64 1
a64 1
my $bug_tests = 4 + 3 * 3 * 5 * 2 * 3 + 2 + 1 + 1;
d98 1
a98 1
END { 1 while unlink 'Op_write.tmp' }
d118 1
a118 1
is cat('Op_write.tmp'), $right and do { 1 while unlink 'Op_write.tmp'; };
d157 1
a157 1
is cat('Op_write.tmp'), $right and do { 1 while unlink 'Op_write.tmp'; };
d198 1
a198 1
is cat('Op_write.tmp'), $right and do { 1 while unlink 'Op_write.tmp' };
d251 1
a251 1
is cat('Op_write.tmp'), $right and do { 1 while unlink 'Op_write.tmp' };
d279 1
a279 1
is cat('Op_write.tmp'), "1\n" and do { 1 while unlink "Op_write.tmp" };
d296 1
a296 1
is cat('Op_write.tmp'), $right and do { 1 while unlink 'Op_write.tmp' };
d319 1
a319 1
is cat('Op_write.tmp'), $right and do { 1 while unlink 'Op_write.tmp' };
d545 1
d547 1
a547 1
	    my $name = "$first, $second $format $class";
d549 3
d562 1
a562 1
	      is swrite("1^*2 3${format}4", $copy1, $copy2), $expect, $name;
d567 1
a567 1
	      is swrite("1^*2 3${format}4", $copy1, $copy2), $expect, $name;
d596 1
a596 1
# [ID 20020227.005] format bug with undefined _TOP
d605 1
a605 4
  {
    local $::TODO = '[ID 20020227.005] format bug with undefined _TOP';
    is $-, 9;
  }
d614 148
d777 9
@


1.11
log
@Merge in perl 5.10.1; part two
@
text
@d640 1
a640 1
if ($^O eq 'VMS' || $^O eq 'MSWin32' || $^O eq 'dos' || $^O eq 'MacOS' ||
@


1.10
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d6 1
d9 2
d64 4
a67 1
my $hmb_tests = 39;
d69 3
a71 1
printf "1..%d\n", $bas_tests + $num_tests + $hmb_tests;
d77 2
d107 1
a107 1
$right =
d118 1
a118 4
if (cat('Op_write.tmp') eq $right)
    { print "ok 1\n"; 1 while unlink 'Op_write.tmp'; }
else
    { print "not ok 1\n"; }
d157 1
a157 4
if (cat('Op_write.tmp') eq $right)
    { print "ok 2\n"; 1 while unlink 'Op_write.tmp'; }
else
    { print "not ok 2\n"; }
d198 1
a198 4
if (cat('Op_write.tmp') eq $right)
    { print "ok 3\n"; 1 while unlink 'Op_write.tmp'; }
else
    { print "not ok 3\n"; }
d202 1
a202 1
$mustbe = <<EOT;
d216 2
a217 1
$was1 = $was2 = '';
d230 2
a231 2
print $was1 eq $mustbe ? "ok 4\n" : "not ok 4\n";
print $was2 eq $mustbe ? "ok 5\n" : "not ok 5\n";
d251 2
a252 4
if (cat('Op_write.tmp') eq $right)
    { print "ok 6\n"; 1 while unlink 'Op_write.tmp'; }
else
    { print "not ok 6\n"; }
d256 1
d258 1
a258 1
    our $that = 7;
d265 1
a265 1
    $that = 8;
d268 1
d279 1
a279 7
if (cat('Op_write.tmp') eq "1\n") {
    print "ok 9\n";
    1 while unlink "Op_write.tmp";
    }
else {
    print "not ok 9\n";
    }
d290 1
d296 1
a296 4
if (cat('Op_write.tmp') eq $right)
    { print "ok 10\n"; 1 while unlink 'Op_write.tmp'; }
else
    { print "not ok 10\n"; }
d319 1
a319 4
if (cat('Op_write.tmp') eq $right)
    { print "ok 11\n"; 1 while unlink 'Op_write.tmp'; }
else
    { print "not ok 11\n"; }
d322 1
d328 1
a328 1
    my %hash = (12 => 3);
d336 1
a336 1

d340 1
d345 1
a345 1
    $v = 13;
d354 1
d362 1
a362 3
    print +($@@ && $@@ =~ /Format not terminated/)
      ? "ok 14\n" : "not ok 14 $@@\n";

d378 1
a378 1
    print $res eq "line 1\nline 2\n" ? "ok 15\n" : "not ok 15\n";
d393 1
a393 1
    print $res eq <<EOD ? "ok 16\n" : "not ok 16\n";
d415 1
a415 1
    print $res eq $exp ? "ok 17\n" : "not ok 17\n";
d427 1
a427 2
    print +($@@ && $@@ =~ /Repeated format line will never terminate/)
      ? "ok 18\n" : "not ok 18: $@@\n";
d442 1
a442 1
    print $res eq <<EOD ? "ok 19\n" : "not ok 19\n";
d471 1
a471 1
    print $res eq $exp ? "ok 20\n" : "not ok 20 res=[$res]exp=[$exp]\n";
d480 2
a481 1
my $nt = $bas_tests;
d488 5
a492 8
        $nt++;
	my $ok = ref($expected)
		 ? $writeres =~ $expected
		 : $writeres eq $expected;
	
        print $ok
	    ? "ok $nt - $writefmt\n"
	    : "not ok $nt\n# f=[$writefmt] exp=[$expected] got=[$writeres]\n";
d499 2
a500 2
## Easiest to add new tests above here
#######################################
d502 1
a502 1
# scary format testing from H.Merijn Brand
d504 4
a507 2
my $test = $bas_tests + $num_tests + 1;
my $tests = $bas_tests + $num_tests + $hmb_tests;
d509 3
a511 6
if ($^O eq 'VMS' || $^O eq 'MSWin32' || $^O eq 'dos' || $^O eq 'MacOS' ||
    ($^O eq 'os2' and not eval '$OS2::can_fork')) {
  foreach ($test..$tests) {
      print "ok $_ # skipped: '|-' and '-|' not supported\n";
  }
  exit(0);
d514 7
d522 5
a526 1
use strict;	# Amazed that this hackery can be made strict ...
d528 6
a533 1
# DAPM. Exercise a couple of error codepaths
d536 2
a537 5
    local $~ = '';
    eval { write };
    print "not " unless $@@ and $@@ =~ /Not a format reference/;
    print "ok $test - Not a format reference\n";
    $test++;
d539 31
a569 5
    $~ = "NOSUCHFORMAT";
    eval { write };
    print "not " unless $@@ and $@@ =~ /Undefined format/;
    print "ok $test - Undefined format\n";
    $test++;
d572 8
a579 2
# Just a complete test for format, including top-, left- and bottom marging
# and format detection through glob entries
d584 2
d597 9
a605 9
{   local $~ = "Comment";
    write;
    $test++;
    print $- == 9
	? "ok $test # TODO\n" : "not ok $test # TODO \$- = $- instead of 9\n";
    $test++;
    print $^ eq "STDOUT_DUP_TOP"
	? "ok $test\n" : "not ok $test\n# \$^ = $^ instead of 'STDOUT_DUP_TOP'\n";
    $test++;
d610 40
d669 2
a670 1
    print "not ok $test - open gave $!\n"; exit 0;
d676 1
a676 1
    print "ok $test - open\n"; $test++;
d680 1
a680 1
	    print "not ok $test - too much output\n";
d685 1
a685 5
	print + ($_ eq $exp ? "" : "not "), "ok ", $test++, " \n";
	if ($_ ne $exp) {
	    s/\n/\\n/g for $_, $exp;
	    print "#expected: $exp\n#got:      $_\n";
	}
d688 1
a688 1
    print + (@@data?"not ":""), "ok ", $test++, " - too little output\n";
d693 1
@


1.9
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d61 1
a61 1
my $hmb_tests = 37;
d331 1
a331 1
    our $el;
d529 16
d616 1
a616 1
    print + (@@data?"not ":""), "ok ", $test++, " - too litle output\n";
@


1.8
log
@merge local changes into perl-5.8.3
@
text
@d8 51
a58 1
print "1..50\n";
d60 8
a67 3
my $CAT = ($^O eq 'MSWin32' || $^O eq 'NetWare' || $^O eq 'VMS') ? 'type'
	: ($^O eq 'MacOS') ? 'catenate'
        : 'cat';
d108 1
a108 1
if (`$CAT Op_write.tmp` eq $right)
d150 1
a150 1
if (`$CAT Op_write.tmp` eq $right)
d194 1
a194 1
if (`$CAT Op_write.tmp` eq $right)
d249 1
a249 1
if (`$CAT Op_write.tmp` eq $right)
d277 1
a277 1
if (`$CAT Op_write.tmp` eq "1\n") {
d299 1
a299 1
if (`$CAT Op_write.tmp` eq $right)
d325 1
a325 1
if (`$CAT Op_write.tmp` eq $right)
d332 1
a332 1
    format STDOUT =
d337 2
d340 1
a340 1
	write;
d342 3
d360 1
a360 1
    print `$CAT Op_write.tmp`;
d363 3
a365 2
{
    # Bug #24774 format without trailing \n failed assertion
d368 137
a504 4
    open(OUT14, '>Op_write.tmp') || die "Can't create Op_write.tmp";
    write(OUT14);
    close OUT14 or die "Could not close: $!";
    print "ok 14\n";
d507 4
a510 2
#######################################
# Easiest to add new tests above here #
d513 1
a513 1
# 15..50: scary format testing from Merijn H. Brand
d515 2
a516 2
my $test = 15;
my $tests = 50;
a539 1
$= = 10;
d542 4
d550 1
a550 1
	? "ok $test\n" : "not ok $test # TODO \$- = $- instead of 9\n";
d552 2
a553 2
    print $^ ne "Comment_TOP"
	? "ok $test\n" : "not ok $test # TODO \$^ = $^ instead of 'STDOUT_TOP'\n";
d555 3
a557 1
    }
d559 3
a561 3
   $^  = "STDOUT_TOP";
   $=  =  7;		# Page length
   $-  =  0;		# Lines left
d567 18
a584 3
select ((select (STDOUT), $| = 1)[0]);
if ($lm > 0 and !open STDOUT, "|-") {	# Left margin (in this test ALWAYS set)
    select ((select (STDOUT), $| = 1)[0]);
d586 5
a590 1
    while (<STDIN>) {
d592 5
a596 1
	print + ($_ eq <DATA> ? "" : "not "), "ok ", $test++, "\n";
d598 3
a600 3
    close STDIN;
    print + (<DATA>?"not ":""), "ok ", $test++, "\n";
    close STDOUT;
d602 5
a606 1
    }
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d8 1
a8 1
print "1..49\n";
d303 10
d317 1
a317 1
# 14..49: scary format testing from Merijn H. Brand
d319 2
a320 2
my $test = 14;
my $tests = 49;
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d8 1
a8 1
print "1..47\n";
d33 1
d275 36
a310 1
# 12..47: scary format testing from Merijn H. Brand
d314 3
a316 1
  foreach (12..47) { print "ok $_ # skipped: '|-' and '-|' not supported\n"; }
d320 1
a322 2
my $test = 12;

d439 1
a439 1
# That was test 47.
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d3 6
a8 1
print "1..9\n";
d10 3
a12 1
my $CAT = ($^O eq 'MSWin32') ? 'type' : 'cat';
d39 1
a39 1
close OUT;
d53 1
a53 1
    { print "ok 1\n"; unlink 'Op_write.tmp'; }
d78 1
a78 1
close OUT2;
d95 1
a95 1
    { print "ok 2\n"; unlink 'Op_write.tmp'; }
d121 1
a121 1
close OUT2;
d139 1
a139 1
    { print "ok 3\n"; unlink 'Op_write.tmp'; }
d188 1
a188 1
close OUT3;
d194 1
a194 1
    { print "ok 6\n"; unlink 'Op_write.tmp'; }
d210 1
a210 1
    close LEX;
d220 1
a220 1
close  OUT4;
d223 1
a223 1
    unlink "Op_write.tmp";
d228 209
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d3 1
a3 1
print "1..8\n";
d203 1
d205 16
@


1.3
log
@perl5.005_03 (stock)
@
text
@d3 1
a3 3
# $RCSfile: write.t,v $$Revision: 4.1 $$Date: 92/08/07 18:28:38 $

print "1..6\n";
d191 13
@


1.2
log
@perl 5.004_04
@
text
@d5 1
a5 1
print "1..5\n";
d169 23
@


1.1
log
@Initial revision
@
text
@d5 3
a7 1
print "1..3\n";
d47 1
a47 1
if (`cat Op_write.tmp` eq $right)
d89 1
a89 1
if (`cat Op_write.tmp` eq $right)
d133 1
a133 1
if (`cat Op_write.tmp` eq $right)
d137 32
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d5 1
a5 3
print "1..6\n";

my $CAT = ($^O eq 'MSWin32') ? 'type' : 'cat';
d45 1
a45 1
if (`$CAT Op_write.tmp` eq $right)
d87 1
a87 1
if (`$CAT Op_write.tmp` eq $right)
d131 1
a131 1
if (`$CAT Op_write.tmp` eq $right)
a134 55

# formline tests

$mustbe = <<EOT;
@@ a
@@> ab
@@>> abc
@@>>>  abc
@@>>>>   abc
@@>>>>>    abc
@@>>>>>>     abc
@@>>>>>>>      abc
@@>>>>>>>>       abc
@@>>>>>>>>>        abc
@@>>>>>>>>>>         abc
EOT

$was1 = $was2 = '';
for (0..10) {           
  # lexical picture
  $^A = '';
  my $format1 = '@@' . '>' x $_;
  formline $format1, 'abc';
  $was1 .= "$format1 $^A\n";
  # global
  $^A = '';
  local $format2 = '@@' . '>' x $_;
  formline $format2, 'abc';
  $was2 .= "$format2 $^A\n";
}
print $was1 eq $mustbe ? "ok 4\n" : "not ok 4\n";
print $was2 eq $mustbe ? "ok 5\n" : "not ok 5\n";

$^A = '';

# more test

format OUT3 =
^<<<<<<...
$foo
.

open(OUT3, '>Op_write.tmp') || die "Can't create Op_write.tmp";

$foo = 'fit          ';
write(OUT3);
close OUT3;

$right =
"fit\n";

if (`$CAT Op_write.tmp` eq $right)
    { print "ok 6\n"; unlink 'Op_write.tmp'; }
else
    { print "not ok 6\n"; }
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d3 3
a5 1
print "1..8\n";
a192 13
# test lexicals and globals
{
    my $this = "ok";
    our $that = 7;
    format LEX =
@@<<@@|
$this,$that
.
    open(LEX, ">&STDOUT") or die;
    write LEX;
    $that = 8;
    write LEX;
}
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d3 1
a3 1
print "1..9\n";
a202 1
    close LEX;
a203 16
# LEX_INTERPNORMAL test
my %e = ( a => 1 );
format OUT4 =
@@<<<<<<
"$e{a}"
.
open   OUT4, ">Op_write.tmp" or die "Can't create Op_write.tmp";
write (OUT4);
close  OUT4;
if (`$CAT Op_write.tmp` eq "1\n") {
    print "ok 9\n";
    unlink "Op_write.tmp";
    }
else {
    print "not ok 9\n";
    }
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d3 1
a3 6
BEGIN {
    chdir 't' if -d 't';
    @@INC = '../lib';
}

print "1..47\n";
d5 1
a5 3
my $CAT = ($^O eq 'MSWin32' || $^O eq 'NetWare' || $^O eq 'VMS') ? 'type'
	: ($^O eq 'MacOS') ? 'catenate'
        : 'cat';
d32 1
a32 1
close OUT or die "Could not close: $!";
d46 1
a46 1
    { print "ok 1\n"; 1 while unlink 'Op_write.tmp'; }
d71 1
a71 1
close OUT2 or die "Could not close: $!";
d88 1
a88 1
    { print "ok 2\n"; 1 while unlink 'Op_write.tmp'; }
d114 1
a114 1
close OUT2 or die "Could not close: $!";
d132 1
a132 1
    { print "ok 3\n"; 1 while unlink 'Op_write.tmp'; }
d181 1
a181 1
close OUT3 or die "Could not close: $!";
d187 1
a187 1
    { print "ok 6\n"; 1 while unlink 'Op_write.tmp'; }
d203 1
a203 1
    close LEX or die "Could not close: $!";
d213 1
a213 1
close  OUT4 or die "Could not close: $!";
d216 1
a216 1
    1 while unlink "Op_write.tmp";
a220 209

eval <<'EOFORMAT';
format OUT10 =
@@####.## @@0###.##
$test1, $test1
.
EOFORMAT

open(OUT10, '>Op_write.tmp') || die "Can't create Op_write.tmp";

$test1 = 12.95;
write(OUT10);
close OUT10 or die "Could not close: $!";

$right = "   12.95 00012.95\n";
if (`$CAT Op_write.tmp` eq $right)
    { print "ok 10\n"; 1 while unlink 'Op_write.tmp'; }
else
    { print "not ok 10\n"; }

eval <<'EOFORMAT';
format OUT11 =
@@0###.## 
$test1
@@ 0#
$test1
@@0 # 
$test1
.
EOFORMAT

open(OUT11, '>Op_write.tmp') || die "Can't create Op_write.tmp";

$test1 = 12.95;
write(OUT11);
close OUT11 or die "Could not close: $!";

$right = 
"00012.95
1 0#
10 #\n";
if (`$CAT Op_write.tmp` eq $right)
    { print "ok 11\n"; 1 while unlink 'Op_write.tmp'; }
else
    { print "not ok 11\n"; }

# 12..47: scary format testing from Merijn H. Brand

if ($^O eq 'VMS' || $^O eq 'MSWin32' || $^O eq 'dos' || $^O eq 'MacOS' ||
    ($^O eq 'os2' and not eval '$OS2::can_fork')) {
  foreach (12..47) { print "ok $_ # skipped: '|-' and '-|' not supported\n"; }
  exit(0);
}

use strict;	# Amazed that this hackery can be made strict ...

my $test = 12;

# Just a complete test for format, including top-, left- and bottom marging
# and format detection through glob entries

format EMPTY =
.

format Comment =
ok @@<<<<<
$test
.

$= = 10;

# [ID 20020227.005] format bug with undefined _TOP
{   local $~ = "Comment";
    write;
    $test++;
    print $- == 9
	? "ok $test\n" : "not ok $test # TODO \$- = $- instead of 9\n";
    $test++;
    print $^ ne "Comment_TOP"
	? "ok $test\n" : "not ok $test # TODO \$^ = $^ instead of 'STDOUT_TOP'\n";
    $test++;
    }

   $^  = "STDOUT_TOP";
   $=  =  7;		# Page length
   $-  =  0;		# Lines left
my $ps = $^L; $^L = "";	# Catch the page separator
my $tm =  1;		# Top margin (empty lines before first output)
my $bm =  2;		# Bottom marging (empty lines between last text and footer)
my $lm =  4;		# Left margin (indent in spaces)

select ((select (STDOUT), $| = 1)[0]);
if ($lm > 0 and !open STDOUT, "|-") {	# Left margin (in this test ALWAYS set)
    select ((select (STDOUT), $| = 1)[0]);
    my $s = " " x $lm;
    while (<STDIN>) {
	s/^/$s/;
	print + ($_ eq <DATA> ? "" : "not "), "ok ", $test++, "\n";
	}
    close STDIN;
    print + (<DATA>?"not ":""), "ok ", $test++, "\n";
    close STDOUT;
    exit;
    }
$tm = "\n" x $tm;
$= -= $bm + 1; # count one for the trailing "----"
my $lastmin = 0;

my @@E;

sub wryte
{
    $lastmin = $-;
    write;
    } # wryte;

sub footer
{
    $% == 1 and return "";

    $lastmin < $= and print "\n" x $lastmin;
    print "\n" x $bm, "----\n", $ps;
    $lastmin = $-;
    "";
    } # footer

# Yes, this is sick ;-)
format TOP =
@@* ~
@@{[footer]}
@@* ~
$tm
.

format ENTRY =
@@ @@<<<<~~
@@{(shift @@E)||["",""]}
.

format EOR =
- -----
.

sub has_format ($)
{
    my $fmt = shift;
    exists $::{$fmt} or return 0;
    $^O eq "MSWin32" or return defined *{$::{$fmt}}{FORMAT};
    open my $null, "> /dev/null" or die;
    my $fh = select $null;
    local $~ = $fmt;
    eval "write";
    select $fh;
    $@@?0:1;
    } # has_format

$^ = has_format ("TOP") ? "TOP" : "EMPTY";
has_format ("ENTRY") or die "No format defined for ENTRY";
foreach my $e ( [ map { [ $_, "Test$_"   ] } 1 .. 7 ],
		[ map { [ $_, "${_}tseT" ] } 1 .. 5 ]) {
    @@E = @@$e;
    local $~ = "ENTRY";
    wryte;
    has_format ("EOR") or next;
    local $~ = "EOR";
    wryte;
    }
if (has_format ("EOF")) {
    local $~ = "EOF";
    wryte;
    }

close STDOUT;

# That was test 47.

__END__
    
    1 Test1
    2 Test2
    3 Test3
    
    
    ----
    
    4 Test4
    5 Test5
    6 Test6
    
    
    ----
    
    7 Test7
    - -----
    
    
    
    ----
    
    1 1tseT
    2 2tseT
    3 3tseT
    
    
    ----
    
    4 4tseT
    5 5tseT
    - -----
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@d8 1
a8 1
print "1..49\n";
a32 1
END { 1 while unlink 'Op_write.tmp' }
d274 1
a274 36
{
    our $el;
    format STDOUT =
ok ^<<<<<<<<<<<<<<~~ # sv_chop() naze
$el
.
    my %hash = (12 => 3);
    for $el (keys %hash) {
	write;
    }
}

{
    # Bug report and testcase by Alexey Tourbin
    use Tie::Scalar;
    my $v;
    tie $v, 'Tie::StdScalar';
    $v = 13;
    format OUT13 =
ok ^<<<<<<<<< ~~
$v
.
    open(OUT13, '>Op_write.tmp') || die "Can't create Op_write.tmp";
    write(OUT13);
    close OUT13 or die "Could not close: $!";
    print `$CAT Op_write.tmp`;
}

#######################################
# Easiest to add new tests above here #
#######################################

# 14..49: scary format testing from Merijn H. Brand

my $test = 14;
my $tests = 49;
d278 1
a278 3
  foreach ($test..$tests) {
      print "ok $_ # skipped: '|-' and '-|' not supported\n";
  }
d282 1
d284 1
a284 1
use strict;	# Amazed that this hackery can be made strict ...
d402 1
a402 1
# That was test 48.
@


1.1.1.7
log
@perl 5.8.3 from CPAN
@
text
@d8 1
a8 1
print "1..50\n";
a302 10
{
    # Bug #24774 format without trailing \n failed assertion
    my @@v = ('k');
    eval "format OUT14 = \n@@\n\@@v";
    open(OUT14, '>Op_write.tmp') || die "Can't create Op_write.tmp";
    write(OUT14);
    close OUT14 or die "Could not close: $!";
    print "ok 14\n";
}

d307 1
a307 1
# 15..50: scary format testing from Merijn H. Brand
d309 2
a310 2
my $test = 15;
my $tests = 50;
@


1.1.1.8
log
@Import of stock perl 5.8.5
@
text
@d8 1
a8 51
# read in a file
sub cat {
    my $file = shift;
    local $/;
    open my $fh, $file or die "can't open '$file': $!";
    my $data = <$fh>;
    close $fh;
    $data;
}

#-- testing numeric fields in all variants (WL)

sub swrite {
    my $format = shift;
    local $^A = ""; # don't litter, use a local bin
    formline( $format, @@_ );
    return $^A;
}

my @@NumTests = (
    # [ format, value1, expected1, value2, expected2, .... ]
    [ '@@###',           0,   '   0',         1, '   1',     9999.6, '####',
		9999.4999,   '9999',    -999.6, '####',     1e+100, '####' ],

    [ '@@0##',           0,   '0000',         1, '0001',     9999.6, '####',
		-999.4999,   '-999',    -999.6, '####',     1e+100, '####' ],

    [ '^###',           0,   '   0',     undef, '    ' ],

    [ '^0##',           0,   '0000',     undef, '    ' ],

    [ '@@###.',          0,  '   0.',         1, '   1.',    9999.6, '#####',
                9999.4999,  '9999.',    -999.6, '#####' ],

    [ '@@##.##',         0, '  0.00',         1, '  1.00',  999.996, '######',
                999.99499, '999.99',      -100, '######' ],

    [ '@@0#.##',         0, '000.00',         1, '001.00',       10, '010.00',
                  -0.0001, qr/^[\-0]00\.00$/ ],

);


my $num_tests = 0;
for my $tref ( @@NumTests ){
    $num_tests += (@@$tref - 1)/2;
}
#---------------------------------------------------------

# number of tests in section 1
my $bas_tests = 20;
d10 3
a12 8
# number of tests in section 3
my $hmb_tests = 37;

printf "1..%d\n", $bas_tests + $num_tests + $hmb_tests;

############
## Section 1
############
d53 1
a53 1
if (cat('Op_write.tmp') eq $right)
d95 1
a95 1
if (cat('Op_write.tmp') eq $right)
d139 1
a139 1
if (cat('Op_write.tmp') eq $right)
d194 1
a194 1
if (cat('Op_write.tmp') eq $right)
d222 1
a222 1
if (cat('Op_write.tmp') eq "1\n") {
d244 1
a244 1
if (cat('Op_write.tmp') eq $right)
d270 1
a270 1
if (cat('Op_write.tmp') eq $right)
d277 1
a277 1
    format OUT12 =
a281 2
    open(OUT12, '>Op_write.tmp') || die "Can't create Op_write.tmp";

d283 1
a283 1
	write(OUT12);
a284 3
    close OUT12 or die "Could not close: $!";
    print cat('Op_write.tmp');

d300 1
a300 1
    print cat('Op_write.tmp');
d303 2
a304 3
{   # test 14
    # Bug #24774 format without trailing \n failed assertion, but this
    # must fail since we have a trailing ; in the eval'ed string (WL)
d307 4
a310 3
    print +($@@ && $@@ =~ /Format not terminated/)
      ? "ok 14\n" : "not ok 14 $@@\n";

d313 2
a314 138
{   # test 15
    # text lost in ^<<< field with \r in value (WL)
    my $txt = "line 1\rline 2";
    format OUT15 =
^<<<<<<<<<<<<<<<<<<
$txt
^<<<<<<<<<<<<<<<<<<
$txt
.
    open(OUT15, '>Op_write.tmp') || die "Can't create Op_write.tmp";
    write(OUT15);
    close OUT15 or die "Could not close: $!";
    my $res = cat('Op_write.tmp');
    print $res eq "line 1\nline 2\n" ? "ok 15\n" : "not ok 15\n";
}

{   # test 16: multiple use of a variable in same line with ^<
    my $txt = "this_is_block_1 this_is_block_2 this_is_block_3 this_is_block_4";
    format OUT16 =
^<<<<<<<<<<<<<<<< ^<<<<<<<<<<<<<<<<
$txt,             $txt
^<<<<<<<<<<<<<<<< ^<<<<<<<<<<<<<<<<
$txt,             $txt
.
    open(OUT16, '>Op_write.tmp') || die "Can't create Op_write.tmp";
    write(OUT16);
    close OUT16 or die "Could not close: $!";
    my $res = cat('Op_write.tmp');
    print $res eq <<EOD ? "ok 16\n" : "not ok 16\n";
this_is_block_1   this_is_block_2
this_is_block_3   this_is_block_4
EOD
}

{   # test 17: @@* "should be on a line of its own", but it should work
    # cleanly with literals before and after. (WL)

    my $txt = "This is line 1.\nThis is the second line.\nThird and last.\n";
    format OUT17 =
Here we go: @@* That's all, folks!
            $txt
.
    open(OUT17, '>Op_write.tmp') || die "Can't create Op_write.tmp";
    write(OUT17);
    close OUT17 or die "Could not close: $!";
    my $res = cat('Op_write.tmp');
    chomp( $txt );
    my $exp = <<EOD;
Here we go: $txt That's all, folks!
EOD
    print $res eq $exp ? "ok 17\n" : "not ok 17\n";
}

{   # test 18: @@# and ~~ would cause runaway format, but we now
    # catch this while compiling (WL)

    format OUT18 =
@@######## ~~
10
.
    open(OUT18, '>Op_write.tmp') || die "Can't create Op_write.tmp";
    eval { write(OUT18); };
    print +($@@ && $@@ =~ /Repeated format line will never terminate/)
      ? "ok 18\n" : "not ok 18: $@@\n";
    close OUT18 or die "Could not close: $!";
}

{   # test 19: \0 in an evel'ed format, doesn't cause empty lines (WL)
    my $v = 'gaga';
    eval "format OUT19 = \n" .
         '@@<<<' . "\0\n" .
         '$v' .   "\n" .
         '@@<<<' . "\0\n" .
         '$v' . "\n.\n";
    open(OUT19, '>Op_write.tmp') || die "Can't create Op_write.tmp";
    write(OUT19);
    close OUT19 or die "Could not close: $!";
    my $res = cat('Op_write.tmp');
    print $res eq <<EOD ? "ok 19\n" : "not ok 19\n";
gaga\0
gaga\0
EOD
}

{   # test 20: hash accesses; single '}' must not terminate format '}' (WL)
    my %h = ( xkey => 'xval', ykey => 'yval' );
    format OUT20 =
@@>>>> @@<<<< ~~
each %h
@@>>>> @@<<<<
$h{xkey}, $h{ykey}
@@>>>> @@<<<<
{ $h{xkey}, $h{ykey}
}
}
.
    my $exp = '';
    while( my( $k, $v ) = each( %h ) ){
	$exp .= sprintf( "%5s %s\n", $k, $v );
    }
    $exp .= sprintf( "%5s %s\n", $h{xkey}, $h{ykey} );
    $exp .= sprintf( "%5s %s\n", $h{xkey}, $h{ykey} );
    $exp .= "}\n";
    open(OUT20, '>Op_write.tmp') || die "Can't create Op_write.tmp";
    write(OUT20);
    close OUT20 or die "Could not close: $!";
    my $res = cat('Op_write.tmp');
    print $res eq $exp ? "ok 20\n" : "not ok 20 res=[$res]exp=[$exp]\n";
}


#####################
## Section 2
## numeric formatting
#####################

my $nt = $bas_tests;
for my $tref ( @@NumTests ){
    my $writefmt = shift( @@$tref );
    while (@@$tref) {
	my $val      = shift @@$tref;
	my $expected = shift @@$tref;
        my $writeres = swrite( $writefmt, $val );
        $nt++;
	my $ok = ref($expected)
		 ? $writeres =~ $expected
		 : $writeres eq $expected;
	
        print $ok
	    ? "ok $nt - $writefmt\n"
	    : "not ok $nt\n# f=[$writefmt] exp=[$expected] got=[$writeres]\n";
    }
}


#####################################
## Section 3
## Easiest to add new tests above here
d317 1
a317 1
# scary format testing from H.Merijn Brand
d319 2
a320 2
my $test = $bas_tests + $num_tests + 1;
my $tests = $bas_tests + $num_tests + $hmb_tests;
d344 1
a346 4

open STDOUT_DUP, ">&STDOUT";
my $oldfh = select STDOUT_DUP;
$= = 10;
d351 1
a351 1
	? "ok $test # TODO\n" : "not ok $test # TODO \$- = $- instead of 9\n";
d353 2
a354 2
    print $^ eq "STDOUT_DUP_TOP"
	? "ok $test\n" : "not ok $test\n# \$^ = $^ instead of 'STDOUT_DUP_TOP'\n";
d356 1
a356 3
}
select $oldfh;
close STDOUT_DUP;
d358 3
a360 3
$^  = "STDOUT_TOP";
$=  =  7;		# Page length
$-  =  0;		# Lines left
d366 3
a368 18
# -----------------------------------------------------------------------
#
# execute the rest of the script in a child process. The parent reads the
# output from the child and compares it with <DATA>.

my @@data = <DATA>;

select ((select (STDOUT), $| = 1)[0]); # flush STDOUT

my $opened = open FROM_CHILD, "-|";
unless (defined $opened) {
    print "not ok $test - open gave $!\n"; exit 0;
}

if ($opened) {
    # in parent here

    print "ok $test - open\n"; $test++;
d370 1
a370 5
    while (<FROM_CHILD>) {
	unless (@@data) {
	    print "not ok $test - too much output\n";
	    exit;
	}
d372 1
a372 5
	my $exp = shift @@data;
	print + ($_ eq $exp ? "" : "not "), "ok ", $test++, " \n";
	if ($_ ne $exp) {
	    s/\n/\\n/g for $_, $exp;
	    print "#expected: $exp\n#got:      $_\n";
d374 4
a378 8
    close FROM_CHILD;
    print + (@@data?"not ":""), "ok ", $test++, " - too litle output\n";
    exit;
}

# in child here

    select ((select (STDOUT), $| = 1)[0]);
@


1.1.1.9
log
@import perl 5.10.0 from CPAN
@
text
@d61 1
a61 1
my $hmb_tests = 39;
d331 1
a331 1
    my $el;
a528 16
# DAPM. Exercise a couple of error codepaths

{
    local $~ = '';
    eval { write };
    print "not " unless $@@ and $@@ =~ /Not a format reference/;
    print "ok $test - Not a format reference\n";
    $test++;

    $~ = "NOSUCHFORMAT";
    eval { write };
    print "not " unless $@@ and $@@ =~ /Undefined format/;
    print "ok $test - Undefined format\n";
    $test++;
}

d600 1
a600 1
    print + (@@data?"not ":""), "ok ", $test++, " - too little output\n";
@


1.1.1.10
log
@import perl 5.10.1
@
text
@a5 1
    require './test.pl';
a7 2
use strict;	# Amazed that this hackery can be made strict ...

d61 1
a61 4
my $bug_tests = 4 + 3 * 3 * 5 * 2 * 3 + 2 + 1 + 1;

# number of tests in section 4
my $hmb_tests = 35;
d63 1
a63 3
my $tests = $bas_tests + $num_tests + $bug_tests + $hmb_tests;

plan $tests;
a68 2
use vars qw($fox $multiline $foo $good);

d97 1
a97 1
my $right =
d108 4
a111 1
is cat('Op_write.tmp'), $right and do { 1 while unlink 'Op_write.tmp'; };
d150 4
a153 1
is cat('Op_write.tmp'), $right and do { 1 while unlink 'Op_write.tmp'; };
d194 4
a197 1
is cat('Op_write.tmp'), $right and do { 1 while unlink 'Op_write.tmp' };
d201 1
a201 1
$right = <<EOT;
d215 1
a215 2
my $was1 = my $was2 = '';
use vars '$format2';
d228 2
a229 2
is $was1, $right;
is $was2, $right;
d249 4
a252 2
is cat('Op_write.tmp'), $right and do { 1 while unlink 'Op_write.tmp' };

a255 1
    my $test = curr_test();
d257 1
a257 1
    our $that = $test;
d264 1
a264 1
    $that = ++$test;
a266 1
    curr_test($test + 1);
d277 7
a283 1
is cat('Op_write.tmp'), "1\n" and do { 1 while unlink "Op_write.tmp" };
a293 1
use vars '$test1';
d299 4
a302 1
is cat('Op_write.tmp'), $right and do { 1 while unlink 'Op_write.tmp' };
d325 4
a328 1
is cat('Op_write.tmp'), $right and do { 1 while unlink 'Op_write.tmp' };
a330 1
    my $test = curr_test();
d336 1
a336 1
    my %hash = ($test => 3);
d344 1
a344 1
    curr_test($test + 1);
a347 1
    my $test = curr_test();
d352 1
a352 1
    $v = $test;
a360 1
    curr_test($test + 1);
d368 3
a370 1
    like $@@, qr/Format not terminated/;
d386 1
a386 1
    is $res, "line 1\nline 2\n";
d401 1
a401 1
    is $res, <<EOD;
d423 1
a423 1
    is $res, $exp;
d435 2
a436 1
    like $@@,  qr/Repeated format line will never terminate/;
d451 1
a451 1
    is $res, <<EOD;
d480 1
a480 1
    is $res, $exp;
d489 1
a489 2
curr_test($bas_tests + 1);

d496 8
a503 5
	if (ref $expected) {
	    like $writeres, $expected, $writefmt;
	} else {
	    is $writeres, $expected, $writefmt;
	}	
d510 2
a511 2
## Easiest to add new tests just here
#####################################
d513 1
a513 1
# DAPM. Exercise a couple of error codepaths
d515 2
a516 4
{
    local $~ = '';
    eval { write };
    like $@@, qr/Not a format reference/, 'format reference';
d518 6
a523 3
    $~ = "NOSUCHFORMAT";
    eval { write };
    like $@@, qr/Undefined format/, 'no such format';
a525 2
{
  package Count;
d527 1
a527 4
  sub TIESCALAR {
    my $class = shift;
    bless [shift, 0, 0], $class;
  }
d529 1
a529 12
  sub FETCH {
    my $self = shift;
    ++$self->[1];
    $self->[0];
  }

  sub STORE {
    my $self = shift;
    ++$self->[2];
    $self->[0] = shift;
  }
}
d532 5
a536 2
  my ($pound_utf8, $pm_utf8) = map { my $a = "$_\x{100}"; chop $a; $a}
    my ($pound, $pm) = ("\xA3", "\xB1");
d538 5
a542 31
  foreach my $first ('N', $pound, $pound_utf8) {
    foreach my $base ('N', $pm, $pm_utf8) {
      foreach my $second ($base, "$base\n", "$base\nMoo!", "$base\nMoo!\n",
			  "$base\nMoo!\n",) {
	foreach (['^*', qr/(.+)/], ['@@*', qr/(.*?)$/s]) {
	  my ($format, $re) = @@$_;
	  foreach my $class ('', 'Count') {
	    my $name = "$first, $second $format $class";
	    $name =~ s/\n/\\n/g;

	    $first =~ /(.+)/ or die $first;
	    my $expect = "1${1}2";
	    $second =~ $re or die $second;
	    $expect .= " 3${1}4";

	    if ($class) {
	      my $copy1 = $first;
	      my $copy2;
	      tie $copy2, $class, $second;
	      is swrite("1^*2 3${format}4", $copy1, $copy2), $expect, $name;
	      my $obj = tied $copy2;
	      is $obj->[1], 1, 'value read exactly once';
	    } else {
	      my ($copy1, $copy2) = ($first, $second);
	      is swrite("1^*2 3${format}4", $copy1, $copy2), $expect, $name;
	    }
	  }
	}
      }
    }
  }
d545 2
a546 8
{
  # This will fail an assertion in 5.10.0 built with -DDEBUGGING (because
  # pp_formline attempts to set SvCUR() on an SVt_RV). I suspect that it will
  # be doing something similarly out of bounds on everything from 5.000
  my $ref = [];
  is swrite('>^*<', $ref), ">$ref<";
  is swrite('>@@*<', $ref), ">$ref<";
}
a550 2
my $test = curr_test();

d562 9
a570 9
{
  local $~ = "Comment";
  write;
  curr_test($test + 1);
  {
    local $::TODO = '[ID 20020227.005] format bug with undefined _TOP';
    is $-, 9;
  }
  is $^, "STDOUT_DUP_TOP";
a574 40
*CmT =  *{$::{Comment}}{FORMAT};
ok  defined *{$::{CmT}}{FORMAT}, "glob assign";

fresh_perl_like(<<'EOP', qr/^Format STDOUT redefined at/, {stderr => 1}, '#64562 - Segmentation fault with redefined formats and warnings');
#!./perl

use strict;
use warnings; # crashes!

format =
.

write;

format =
.

write;
EOP

#############################
## Section 4
## Add new tests *above* here
#############################

# scary format testing from H.Merijn Brand

# Just a complete test for format, including top-, left- and bottom marging
# and format detection through glob entries

if ($^O eq 'VMS' || $^O eq 'MSWin32' || $^O eq 'dos' || $^O eq 'MacOS' ||
    ($^O eq 'os2' and not eval '$OS2::can_fork')) {
  $test = curr_test();
 SKIP: {
      skip "'|-' and '-|' not supported", $tests - $test + 1;
  }
  exit(0);
}


d594 1
a594 2
    fail "open gave $!";
    exit 0;
d600 1
a600 1
    pass 'open';
d604 1
a604 1
	    fail 'too much output';
d609 5
a613 1
	is $_, $exp;
d616 1
a616 1
    is "@@data", "", "correct length of output";
a620 1
$::NO_ENDING = 1;
@


1.1.1.11
log
@Perl 5.12.2 from CPAN
@
text
@d640 1
a640 1
if ($^O eq 'VMS' || $^O eq 'MSWin32' || $^O eq 'dos' ||
@


1.1.1.12
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d64 1
a64 1
my $bug_tests = 4 + 3 * 3 * 5 * 2 * 3 + 2 + 66 + 4 + 2 + 3;
d98 1
a98 1
END { unlink_all 'Op_write.tmp' }
d118 1
a118 1
is cat('Op_write.tmp'), $right and unlink_all 'Op_write.tmp';
d157 1
a157 1
is cat('Op_write.tmp'), $right and unlink_all 'Op_write.tmp';
d198 1
a198 1
is cat('Op_write.tmp'), $right and unlink_all 'Op_write.tmp';
d251 1
a251 1
is cat('Op_write.tmp'), $right and unlink_all 'Op_write.tmp';
d279 1
a279 1
is cat('Op_write.tmp'), "1\n" and unlink_all "Op_write.tmp";
d296 1
a296 1
is cat('Op_write.tmp'), $right and unlink_all 'Op_write.tmp';
d319 1
a319 1
is cat('Op_write.tmp'), $right and unlink_all 'Op_write.tmp';
a544 1
	  $format = "1^*2 3${format}4";
d546 1
a546 1
	    my $name = qq{swrite("$format", "$first", "$second") class="$class"};
a547 3
	    $name =~ s{(.)}{
			ord($1) > 126 ? sprintf("\\x{%x}",ord($1)) : $1
		    }ge;
d558 1
a558 1
	      is swrite("$format", $copy1, $copy2), $expect, $name;
d563 1
a563 1
	      is swrite("$format", $copy1, $copy2), $expect, $name;
d592 1
a592 1
# RT #8698 format bug with undefined _TOP
d601 4
a604 1
  is $-, 9;
a612 148

# RT #91032: Check that "non-real" strings like tie and overload work,
# especially that they re-compile the pattern on each FETCH, and that
# they don't overrun the buffer


{
    package RT91032;

    sub TIESCALAR { bless [] }
    my $i = 0;
    sub FETCH { $i++; "A$i @@> Z\n" }

    use overload '""' => \&FETCH;

    tie my $f, 'RT91032';

    formline $f, "a";
    formline $f, "bc";
    ::is $^A, "A1  a Z\nA2 bc Z\n", "RT 91032: tied";
    $^A = '';

    my $g = bless []; # has overloaded stringify
    formline $g, "de";
    formline $g, "f";
    ::is $^A, "A3 de Z\nA4  f Z\n", "RT 91032: overloaded";
    $^A = '';

    my $h = [];
    formline $h, "junk1";
    formline $h, "junk2";
    ::is ref($h), 'ARRAY', "RT 91032: array ref still a ref";
    ::like "$h", qr/^ARRAY\(0x[0-9a-f]+\)$/, "RT 91032: array stringifies ok";
    ::is $^A, "$h$h","RT 91032: stringified array";
    $^A = '';

    # used to overwrite the ~~ in the *original SV with spaces. Naughty!

    my $orig = my $format = "^<<<<< ~~\n";
    my $abc = "abc";
    formline $format, $abc;
    $^A ='';
    ::is $format, $orig, "RT91032: don't overwrite orig format string";

    # check that ~ and ~~ are displayed correctly as whitespace,
    # under the influence of various different types of border

    for my $n (1,2) {
	for my $lhs (' ', 'Y', '^<<<', '^|||', '^>>>') {
	    for my $rhs ('', ' ', 'Z', '^<<<', '^|||', '^>>>') {
		my $fmt = "^<B$lhs" . ('~' x $n) . "$rhs\n";
		my $sfmt = ($fmt =~ s/~/ /gr);
		my ($a, $bc, $stop);
		($a, $bc, $stop) = ('a', 'bc', 's');
		# $stop is to stop '~~' deleting the whole line
		formline $sfmt, $stop, $a, $bc;
		my $exp = $^A;
		$^A = '';
		($a, $bc, $stop) = ('a', 'bc', 's');
		formline $fmt, $stop, $a, $bc;
		my $got = $^A;
		$^A = '';
		$fmt =~ s/\n/\\n/;
		::is($got, $exp, "chop munging: [$fmt]");
	    }
	}
    }
}

# check that '~  (delete current line if empty) works when
# the target gets upgraded to uft8 (and re-allocated) midstream.

{
    my $format = "\x{100}@@~\n"; # format is utf8
    # this target is not utf8, but will expand (and get reallocated)
    # when upgraded to utf8.
    my $orig = "\x80\x81\x82";
    local $^A = $orig;
    my $empty = "";
    formline $format, $empty;
    is $^A , $orig, "~ and realloc";

    # check similarly that trailing blank removal works ok

    $format = "@@<\n\x{100}"; # format is utf8
    chop $format;
    $orig = "   ";
    $^A = $orig;
    formline $format, "  ";
    is $^A, "$orig\n", "end-of-line blanks and realloc";

    # and check this doesn't overflow the buffer

    local $^A = '';
    $format = "@@* @@####\n";
    $orig = "x" x 100 . "\n";
    formline $format, $orig, 12345;
    is $^A, ("x" x 100) . " 12345\n", "\@@* doesn't overflow";

    # make sure it can cope with formats > 64k

    $format = 'x' x 65537;
    $^A = '';
    formline $format;
    # don't use 'is' here, as the diag output will be too long!
    ok $^A eq $format, ">64K";
}


SKIP: {
    skip_if_miniperl('miniperl does not support scalario');
    my $buf = "";
    open my $fh, ">", \$buf;
    my $old_fh = select $fh;
    local $~ = "CmT";
    write;
    select $old_fh;
    close $fh;
    is $buf, "ok $test\n", "write to duplicated format";
}

format caret_A_test_TOP =
T
.

format caret_A_test =
L1
L2
L3
L4
.

SKIP: {
    skip_if_miniperl('miniperl does not support scalario');
    my $buf = "";
    open my $fh, ">", \$buf;
    my $old_fh = select $fh;
    local $^ = "caret_A_test_TOP";
    local $~ = "caret_A_test";
    local $= = 3;
    local $^A = "A1\nA2\nA3\nA4\n";
    write;
    select $old_fh;
    close $fh;
    is $buf, "T\nA1\nA2\n\fT\nA3\nA4\n\fT\nL1\nL2\n\fT\nL3\nL4\n",
		    "assign to ^A sets FmLINES";
}

a627 9
EOP

fresh_perl_is(<<'EOP', ">ARRAY<\ncrunch_eth\n", {stderr => 1}, '#79532 - formline coerces its arguments');
use strict;
use warnings;
my $zamm = ['crunch_eth'];
formline $zamm;
printf ">%s<\n", ref $zamm;
print "$zamm->[0]\n";
@


1.1.1.13
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d61 1
a61 1
my $bas_tests = 21;
d64 1
a64 1
my $bug_tests = 8 + 3 * 3 * 5 * 2 * 3 + 2 + 66 + 4 + 2 + 3 + 96 + 11;
a280 12
# More LEX_INTERPNORMAL
format OUT4a=
@@<<<<<<<<<<<<<<<
"${; use
     strict; \'Nasdaq dropping like flies'}"
.
open   OUT4a, ">Op_write.tmp" or die "Can't create Op_write.tmp";
write (OUT4a);
close  OUT4a or die "Could not close: $!";
is cat('Op_write.tmp'), "Nasdaq dropping\n", 'skipspace inside "${...}"'
    and unlink_all "Op_write.tmp";

d507 1
a507 6
    like $@@, qr/Undefined format ""/, 'format with 0-length name';

    $~ = "\0foo";
    eval { write };
    like $@@, qr/Undefined format "\0foo"/,
	'no such format beginning with null';
d511 1
a511 1
    like $@@, qr/Undefined format "NOSUCHFORMAT"/, 'no such format';
a513 32
select +(select(OUT21), do {
    open(OUT21, '>Op_write.tmp') || die "Can't create Op_write.tmp";

    format OUT21 =
@@<<
$_
.

    local $^ = '';
    local $= = 1;
    $_ = "aataaaaaaaaaaaaaa"; eval { write(OUT21) };
    like $@@, qr/Undefined top format ""/, 'top format with 0-length name';

    $^ = "\0foo";
    # For some reason, we have to do this twice to get the error again.
    $_ = "aataaaaaaaaaaaaaa"; eval { write(OUT21) };
    $_ = "aataaaaaaaaaaaaaa"; eval { write(OUT21) };
    like $@@, qr/Undefined top format "\0foo"/,
	'no such top format beginning with null';

    $^ = "NOSUCHFORMAT";
    $_ = "aataaaaaaaaaaaaaa"; eval { write(OUT21) };
    $_ = "aataaaaaaaaaaaaaa"; eval { write(OUT21) };
    like $@@, qr/Undefined top format "NOSUCHFORMAT"/, 'no such top format';

    # reset things;
    eval { write(OUT21) };
    undef $^A;

    close OUT21 or die "Could not close: $!";
})[0];

a786 280

# [perl #73690]

select +(select(RT73690), do {
    open(RT73690, '>Op_write.tmp') || die "Can't create Op_write.tmp";
    format RT73690 =
@@<< @@<<
11, 22
.

    my @@ret;

    @@ret = write;
    is(scalar(@@ret), 1);
    ok($ret[0]);
    @@ret = scalar(write);
    is(scalar(@@ret), 1);
    ok($ret[0]);
    @@ret = write(RT73690);
    is(scalar(@@ret), 1);
    ok($ret[0]);
    @@ret = scalar(write(RT73690));
    is(scalar(@@ret), 1);
    ok($ret[0]);

    @@ret = ('a', write, 'z');
    is(scalar(@@ret), 3);
    is($ret[0], 'a');
    ok($ret[1]);
    is($ret[2], 'z');
    @@ret = ('b', scalar(write), 'y');
    is(scalar(@@ret), 3);
    is($ret[0], 'b');
    ok($ret[1]);
    is($ret[2], 'y');
    @@ret = ('c', write(RT73690), 'x');
    is(scalar(@@ret), 3);
    is($ret[0], 'c');
    ok($ret[1]);
    is($ret[2], 'x');
    @@ret = ('d', scalar(write(RT73690)), 'w');
    is(scalar(@@ret), 3);
    is($ret[0], 'd');
    ok($ret[1]);
    is($ret[2], 'w');

    @@ret = do { write; 'foo' };
    is(scalar(@@ret), 1);
    is($ret[0], 'foo');
    @@ret = do { scalar(write); 'bar' };
    is(scalar(@@ret), 1);
    is($ret[0], 'bar');
    @@ret = do { write(RT73690); 'baz' };
    is(scalar(@@ret), 1);
    is($ret[0], 'baz');
    @@ret = do { scalar(write(RT73690)); 'quux' };
    is(scalar(@@ret), 1);
    is($ret[0], 'quux');

    @@ret = ('a', do { write; 'foo' }, 'z');
    is(scalar(@@ret), 3);
    is($ret[0], 'a');
    is($ret[1], 'foo');
    is($ret[2], 'z');
    @@ret = ('b', do { scalar(write); 'bar' }, 'y');
    is(scalar(@@ret), 3);
    is($ret[0], 'b');
    is($ret[1], 'bar');
    is($ret[2], 'y');
    @@ret = ('c', do { write(RT73690); 'baz' }, 'x');
    is(scalar(@@ret), 3);
    is($ret[0], 'c');
    is($ret[1], 'baz');
    is($ret[2], 'x');
    @@ret = ('d', do { scalar(write(RT73690)); 'quux' }, 'w');
    is(scalar(@@ret), 3);
    is($ret[0], 'd');
    is($ret[1], 'quux');
    is($ret[2], 'w');

    close RT73690 or die "Could not close: $!";
})[0];

select +(select(RT73690_2), do {
    open(RT73690_2, '>Op_write.tmp') || die "Can't create Op_write.tmp";
    format RT73690_2 =
@@<< @@<<
return
.

    my @@ret;

    @@ret = write;
    is(scalar(@@ret), 1);
    ok(!$ret[0]);
    @@ret = scalar(write);
    is(scalar(@@ret), 1);
    ok(!$ret[0]);
    @@ret = write(RT73690_2);
    is(scalar(@@ret), 1);
    ok(!$ret[0]);
    @@ret = scalar(write(RT73690_2));
    is(scalar(@@ret), 1);
    ok(!$ret[0]);

    @@ret = ('a', write, 'z');
    is(scalar(@@ret), 3);
    is($ret[0], 'a');
    ok(!$ret[1]);
    is($ret[2], 'z');
    @@ret = ('b', scalar(write), 'y');
    is(scalar(@@ret), 3);
    is($ret[0], 'b');
    ok(!$ret[1]);
    is($ret[2], 'y');
    @@ret = ('c', write(RT73690_2), 'x');
    is(scalar(@@ret), 3);
    is($ret[0], 'c');
    ok(!$ret[1]);
    is($ret[2], 'x');
    @@ret = ('d', scalar(write(RT73690_2)), 'w');
    is(scalar(@@ret), 3);
    is($ret[0], 'd');
    ok(!$ret[1]);
    is($ret[2], 'w');

    @@ret = do { write; 'foo' };
    is(scalar(@@ret), 1);
    is($ret[0], 'foo');
    @@ret = do { scalar(write); 'bar' };
    is(scalar(@@ret), 1);
    is($ret[0], 'bar');
    @@ret = do { write(RT73690_2); 'baz' };
    is(scalar(@@ret), 1);
    is($ret[0], 'baz');
    @@ret = do { scalar(write(RT73690_2)); 'quux' };
    is(scalar(@@ret), 1);
    is($ret[0], 'quux');

    @@ret = ('a', do { write; 'foo' }, 'z');
    is(scalar(@@ret), 3);
    is($ret[0], 'a');
    is($ret[1], 'foo');
    is($ret[2], 'z');
    @@ret = ('b', do { scalar(write); 'bar' }, 'y');
    is(scalar(@@ret), 3);
    is($ret[0], 'b');
    is($ret[1], 'bar');
    is($ret[2], 'y');
    @@ret = ('c', do { write(RT73690_2); 'baz' }, 'x');
    is(scalar(@@ret), 3);
    is($ret[0], 'c');
    is($ret[1], 'baz');
    is($ret[2], 'x');
    @@ret = ('d', do { scalar(write(RT73690_2)); 'quux' }, 'w');
    is(scalar(@@ret), 3);
    is($ret[0], 'd');
    is($ret[1], 'quux');
    is($ret[2], 'w');

    close RT73690_2 or die "Could not close: $!";
})[0];

open(UNDEF, '>Op_write.tmp') || die "Can't create Op_write.tmp";
select +(select(UNDEF), $~ = "UNDEFFORMAT")[0];
format UNDEFFORMAT =
@@
undef *UNDEFFORMAT
.
write UNDEF;
pass "active format cannot be freed";

select +(select(UNDEF), $~ = "UNDEFFORMAT2")[0];
format UNDEFFORMAT2 =
@@
close UNDEF or die "Could not close: $!"; undef *UNDEF
.
write UNDEF;
pass "freeing current handle in format";
undef $^A;

ok !eval q|
format foo {
@@<<<
$a
}
;1
|, 'format foo { ... } is not allowed';

ok !eval q|
format =
@@<<<
}
;1
|, 'format = ... } is not allowed';

open(NEST, '>Op_write.tmp') || die "Can't create Op_write.tmp";
format NEST =
@@<<<
{
    my $birds = "birds";
    local *NEST = *BIRDS{FORMAT};
    write NEST;
    format BIRDS =
@@<<<<<
$birds;
.
    "nest"
}
.
write NEST;
close NEST or die "Could not close: $!";
is cat('Op_write.tmp'), "birds\nnest\n", 'nested formats';

# A compilation error should not create a format
eval q|
format ERROR =
@@
@@_ =~ s///
.
|;
eval { write ERROR };
like $@@, qr'Undefined format',
    'formats with compilation errors are not created';

# This syntax error used to cause a crash, double free, or a least
# a bad read.
# See the long-winded explanation at:
#   https://rt.perl.org/rt3/Ticket/Display.html?id=43425#txn-1144500
eval q|
format =
@@
use;format
strict
.
|;
pass('no crash with invalid use/format inside format');


# Low-precedence operators on argument line
format AND =
@@
0 and die
.
$- = $=;
ok eval { local $~ = "AND"; print "# "; write; 1 },
    "low-prec ops on arg line" or diag $@@;

# Anonymous hashes
open(HASH, '>Op_write.tmp') || die "Can't create Op_write.tmp";
format HASH =
@@<<<
${{qw[ Sun 0 Mon 1 Tue 2 Wed 3 Thu 4 Fri 5 Sat 6 ]}}{"Wed"}
.
write HASH;
close HASH or die "Could not close: $!";
is cat('Op_write.tmp'), "3\n", 'anonymous hashes';

# pragmata inside argument line
open(STRICT, '>Op_write.tmp') || die "Can't create Op_write.tmp";
format STRICT =
@@<<<
no strict; $foo
.
$::foo = 'oof::$';
write STRICT;
close STRICT or die "Could not close: $!";
is cat('Op_write.tmp'), "oof:\n", 'pragmata on format line';

SKIP: {
   skip "no weak refs" unless eval { require Scalar::Util };
   sub Potshriggley {
format Potshriggley =
.
   }
   Scalar::Util::weaken(my $x = *Potshriggley{FORMAT});
   undef *Potshriggley;
   is $x, undef, 'formats in subs do not leak';
}

@


1.1.1.14
log
@Import perl-5.20.1
@
text
@a9 1
use Tie::Scalar;
a20 36
# read in a utf-8 file
#
sub cat_utf8 {
    my $file = shift;
    local $/;
    open my $fh, '<', $file or die "can't open '$file': $!";
    binmode $fh, ':utf8';
    my $data = <$fh> // die "Can't read from '$file': $!";
    close $fh or die "error closing '$file': $!";
    $data;
}

# write a format to a utf8 file, then read it back in and compare

sub is_format_utf8 {
    my ($glob, $want, $desc) = @@_;
    local $::Level = $::Level + 1;
    my $file = 'Op_write.tmp';
    open $glob, '>:utf8', $file or die "Can't create '$file': $!";
    write $glob;
    close $glob or die "Could not close '$file': $!";
    is(cat_utf8($file), $want, $desc);
}

sub like_format_utf8 {
    my ($glob, $want, $desc) = @@_;
    local $::Level = $::Level + 1;
    my $file = 'Op_write.tmp';
    open $glob, '>:utf8', $file or die "Can't create '$file': $!";
    write $glob;
    close $glob or die "Could not close '$file': $!";
    like(cat_utf8($file), $want, $desc);
}



d64 1
a64 1
my $bug_tests = 66 + 3 * 3 * 5 * 2 * 3 + 2 + 66 + 4 + 2 + 3 + 96 + 11;
d67 1
a67 1
my $hmb_tests = 37;
d354 1
a562 764


# [perl #119847],  [perl #119849], [perl #119851]
# Non-real vars like tied, overloaded and refs could, when stringified,
# fail to be processed properly, causing infinite loops on ~~, utf8
# warnings etc, ad nauseum.


my $u22a = "N" x 8;

format OUT22a =
'^<<<<<<<<'~~
$u22a
.

is_format_utf8(\*OUT22a,
               "'NNNNNNNN '\n");


my $u22b = "N" x 8;
utf8::upgrade($u22b);

format OUT22b =
'^<<<<<<<<'~~
$u22b
.

is_format_utf8(\*OUT22b,
               "'NNNNNNNN '\n");

my $u22c = "\x{FF}" x 8;

format OUT22c =
'^<<<<<<<<'~~
$u22c
.

is_format_utf8(\*OUT22c,
               "'\x{FF}\x{FF}\x{FF}\x{FF}\x{FF}\x{FF}\x{FF}\x{FF} '\n");

my $u22d = "\x{FF}" x 8;
utf8::upgrade($u22d);

format OUT22d =
'^<<<<<<<<'~~
$u22d
.

is_format_utf8(\*OUT22d,
               "'\x{FF}\x{FF}\x{FF}\x{FF}\x{FF}\x{FF}\x{FF}\x{FF} '\n");

my $u22e = "\x{100}" x 8;

format OUT22e =
'^<<<<<<<<'~~
$u22e
.

is_format_utf8(\*OUT22e,
               "'\x{100}\x{100}\x{100}\x{100}\x{100}\x{100}\x{100}\x{100} '\n");


my $u22f = "N" x 8;

format OUT22f =
'^<'~~
$u22f
.

is_format_utf8(\*OUT22f,
               "'NN'\n"x4);


my $u22g = "N" x 8;
utf8::upgrade($u22g);

format OUT22g =
'^<'~~
$u22g
.

is_format_utf8(\*OUT22g,
               "'NN'\n"x4);

my $u22h = "\x{FF}" x 8;

format OUT22h =
'^<'~~
$u22h
.

is_format_utf8(\*OUT22h,
               "'\x{FF}\x{FF}'\n"x4);

my $u22i = "\x{FF}" x 8;
utf8::upgrade($u22i);

format OUT22i =
'^<'~~
$u22i
.

is_format_utf8(\*OUT22i,
               "'\x{FF}\x{FF}'\n"x4);

my $u22j = "\x{100}" x 8;

format OUT22j =
'^<'~~
$u22j
.

is_format_utf8(\*OUT22j,
               "'\x{100}\x{100}'\n"x4);


tie my $u23a, 'Tie::StdScalar';
$u23a = "N" x 8;

format OUT23a =
'^<<<<<<<<'~~
$u23a
.

is_format_utf8(\*OUT23a,
               "'NNNNNNNN '\n");


tie my $u23b, 'Tie::StdScalar';
$u23b = "N" x 8;
utf8::upgrade($u23b);

format OUT23b =
'^<<<<<<<<'~~
$u23b
.

is_format_utf8(\*OUT23b,
               "'NNNNNNNN '\n");

tie my $u23c, 'Tie::StdScalar';
$u23c = "\x{FF}" x 8;

format OUT23c =
'^<<<<<<<<'~~
$u23c
.

is_format_utf8(\*OUT23c,
               "'\x{FF}\x{FF}\x{FF}\x{FF}\x{FF}\x{FF}\x{FF}\x{FF} '\n");

tie my $u23d, 'Tie::StdScalar';
my $temp = "\x{FF}" x 8;
utf8::upgrade($temp);
$u23d = $temp;

format OUT23d =
'^<<<<<<<<'~~
$u23d
.

is_format_utf8(\*OUT23d,
               "'\x{FF}\x{FF}\x{FF}\x{FF}\x{FF}\x{FF}\x{FF}\x{FF} '\n");

tie my $u23e, 'Tie::StdScalar';
$u23e = "\x{100}" x 8;

format OUT23e =
'^<<<<<<<<'~~
$u23e
.

is_format_utf8(\*OUT23e,
               "'\x{100}\x{100}\x{100}\x{100}\x{100}\x{100}\x{100}\x{100} '\n");

tie my $u23f, 'Tie::StdScalar';
$u23f = "N" x 8;

format OUT23f =
'^<'~~
$u23f
.

is_format_utf8(\*OUT23f,
               "'NN'\n"x4);


tie my $u23g, 'Tie::StdScalar';
my $temp = "N" x 8;
utf8::upgrade($temp);
$u23g = $temp;

format OUT23g =
'^<'~~
$u23g
.

is_format_utf8(\*OUT23g,
               "'NN'\n"x4);

tie my $u23h, 'Tie::StdScalar';
$u23h = "\x{FF}" x 8;

format OUT23h =
'^<'~~
$u23h
.

is_format_utf8(\*OUT23h,
               "'\x{FF}\x{FF}'\n"x4);

$temp = "\x{FF}" x 8;
utf8::upgrade($temp);
tie my $u23i, 'Tie::StdScalar';
$u23i = $temp;

format OUT23i =
'^<'~~
$u23i
.

is_format_utf8(\*OUT23i,
               "'\x{FF}\x{FF}'\n"x4);

tie my $u23j, 'Tie::StdScalar';
$u23j = "\x{100}" x 8;

format OUT23j =
'^<'~~
$u23j
.

is_format_utf8(\*OUT23j,
               "'\x{100}\x{100}'\n"x4);

{
    package UTF8Toggle;

    sub TIESCALAR {
        my $class = shift;
        my $value = shift;
        my $state = shift||0;
        return bless [$value, $state], $class;
    }

    sub FETCH {
        my $self = shift;
        $self->[1] = ! $self->[1];
        if ($self->[1]) {
           utf8::downgrade($self->[0]);
        } else {
           utf8::upgrade($self->[0]);
        }
        $self->[0];
    }

   sub STORE {
       my $self = shift;
       $self->[0] = shift;
    }
}

tie my $u24a, 'UTF8Toggle';
$u24a = "N" x 8;

format OUT24a =
'^<<<<<<<<'~~
$u24a
.

is_format_utf8(\*OUT24a,
               "'NNNNNNNN '\n");


tie my $u24b, 'UTF8Toggle';
$u24b = "N" x 8;
utf8::upgrade($u24b);

format OUT24b =
'^<<<<<<<<'~~
$u24b
.

is_format_utf8(\*OUT24b,
               "'NNNNNNNN '\n");

tie my $u24c, 'UTF8Toggle';
$u24c = "\x{FF}" x 8;

format OUT24c =
'^<<<<<<<<'~~
$u24c
.

is_format_utf8(\*OUT24c,
               "'\x{FF}\x{FF}\x{FF}\x{FF}\x{FF}\x{FF}\x{FF}\x{FF} '\n");

tie my $u24d, 'UTF8Toggle', 1;
$u24d = "\x{FF}" x 8;

format OUT24d =
'^<<<<<<<<'~~
$u24d
.

is_format_utf8(\*OUT24d,
               "'\x{FF}\x{FF}\x{FF}\x{FF}\x{FF}\x{FF}\x{FF}\x{FF} '\n");



tie my $u24f, 'UTF8Toggle';
$u24f = "N" x 8;

format OUT24f =
'^<'~~
$u24f
.

is_format_utf8(\*OUT24f,
               "'NN'\n"x4);


tie my $u24g, 'UTF8Toggle';
my $temp = "N" x 8;
utf8::upgrade($temp);
$u24g = $temp;

format OUT24g =
'^<'~~
$u24g
.

is_format_utf8(\*OUT24g,
               "'NN'\n"x4);

tie my $u24h, 'UTF8Toggle';
$u24h = "\x{FF}" x 8;

format OUT24h =
'^<'~~
$u24h
.

is_format_utf8(\*OUT24h,
               "'\x{FF}\x{FF}'\n"x4);

tie my $u24i, 'UTF8Toggle', 1;
$u24i = "\x{FF}" x 8;

format OUT24i =
'^<'~~
$u24i
.

is_format_utf8(\*OUT24i,
               "'\x{FF}\x{FF}'\n"x4);

{
    package OS;
    use overload '""' => sub { ${$_[0]}; };

    sub new {
        my ($class, $value) = @@_;
        bless \$value, $class;
    }
}

my $u25a = OS->new("N" x 8);

format OUT25a =
'^<<<<<<<<'~~
$u25a
.

is_format_utf8(\*OUT25a,
               "'NNNNNNNN '\n");


my $temp = "N" x 8;
utf8::upgrade($temp);
my $u25b = OS->new($temp);

format OUT25b =
'^<<<<<<<<'~~
$u25b
.

is_format_utf8(\*OUT25b,
               "'NNNNNNNN '\n");

my $u25c = OS->new("\x{FF}" x 8);

format OUT25c =
'^<<<<<<<<'~~
$u25c
.

is_format_utf8(\*OUT25c,
               "'\x{FF}\x{FF}\x{FF}\x{FF}\x{FF}\x{FF}\x{FF}\x{FF} '\n");

$temp = "\x{FF}" x 8;
utf8::upgrade($temp);
my $u25d = OS->new($temp);

format OUT25d =
'^<<<<<<<<'~~
$u25d
.

is_format_utf8(\*OUT25d,
               "'\x{FF}\x{FF}\x{FF}\x{FF}\x{FF}\x{FF}\x{FF}\x{FF} '\n");

my $u25e = OS->new("\x{100}" x 8);

format OUT25e =
'^<<<<<<<<'~~
$u25e
.

is_format_utf8(\*OUT25e,
               "'\x{100}\x{100}\x{100}\x{100}\x{100}\x{100}\x{100}\x{100} '\n");


my $u25f = OS->new("N" x 8);

format OUT25f =
'^<'~~
$u25f
.

is_format_utf8(\*OUT25f,
               "'NN'\n"x4);


$temp = "N" x 8;
utf8::upgrade($temp);
my $u25g = OS->new($temp);

format OUT25g =
'^<'~~
$u25g
.

is_format_utf8(\*OUT25g,
               "'NN'\n"x4);

my $u25h = OS->new("\x{FF}" x 8);

format OUT25h =
'^<'~~
$u25h
.

is_format_utf8(\*OUT25h,
               "'\x{FF}\x{FF}'\n"x4);

$temp = "\x{FF}" x 8;
utf8::upgrade($temp);
my $u25i = OS->new($temp);

format OUT25i =
'^<'~~
$u25i
.

is_format_utf8(\*OUT25i,
               "'\x{FF}\x{FF}'\n"x4);

my $u25j = OS->new("\x{100}" x 8);

format OUT25j =
'^<'~~
$u25j
.

is_format_utf8(\*OUT25j,
               "'\x{100}\x{100}'\n"x4);

{
    package OS::UTF8Toggle;
    use overload '""' => sub {
        my $self = shift;
        $self->[1] = ! $self->[1];
        if ($self->[1]) {
            utf8::downgrade($self->[0]);
        } else {
            utf8::upgrade($self->[0]);
        }
        $self->[0];
    };

    sub new {
        my ($class, $value, $state) = @@_;
        bless [$value, $state], $class;
    }
}


my $u26a = OS::UTF8Toggle->new("N" x 8);

format OUT26a =
'^<<<<<<<<'~~
$u26a
.

is_format_utf8(\*OUT26a,
               "'NNNNNNNN '\n");


my $u26b = OS::UTF8Toggle->new("N" x 8, 1);

format OUT26b =
'^<<<<<<<<'~~
$u26b
.

is_format_utf8(\*OUT26b,
               "'NNNNNNNN '\n");

my $u26c = OS::UTF8Toggle->new("\x{FF}" x 8);

format OUT26c =
'^<<<<<<<<'~~
$u26c
.

is_format_utf8(\*OUT26c,
               "'\x{FF}\x{FF}\x{FF}\x{FF}\x{FF}\x{FF}\x{FF}\x{FF} '\n");

my $u26d = OS::UTF8Toggle->new("\x{FF}" x 8, 1);

format OUT26d =
'^<<<<<<<<'~~
$u26d
.

is_format_utf8(\*OUT26d,
               "'\x{FF}\x{FF}\x{FF}\x{FF}\x{FF}\x{FF}\x{FF}\x{FF} '\n");


my $u26f = OS::UTF8Toggle->new("N" x 8);

format OUT26f =
'^<'~~
$u26f
.

is_format_utf8(\*OUT26f,
               "'NN'\n"x4);


my $u26g = OS::UTF8Toggle->new("N" x 8, 1);

format OUT26g =
'^<'~~
$u26g
.

is_format_utf8(\*OUT26g,
               "'NN'\n"x4);

my $u26h = OS::UTF8Toggle->new("\x{FF}" x 8);

format OUT26h =
'^<'~~
$u26h
.

is_format_utf8(\*OUT26h,
               "'\x{FF}\x{FF}'\n"x4);

my $u26i = OS::UTF8Toggle->new("\x{FF}" x 8, 1);

format OUT26i =
'^<'~~
$u26i
.

is_format_utf8(\*OUT26i,
               "'\x{FF}\x{FF}'\n"x4);



{
    my $zero = $$ - $$;

    package Number;

    sub TIESCALAR {
        my $class = shift;
        my $value = shift;
        return bless \$value, $class;
    }

    # The return value should always be SvNOK() only:
    sub FETCH {
        my $self = shift;
        # avoid "" getting converted to "0" and thus
        # causing an infinite loop
        return "" unless length ($$self);
        return $$self - 0.5 + $zero + 0.5;
    }

   sub STORE {
       my $self = shift;
       $$self = shift;
    }

   package ONumber;

   use overload '""' => sub {
        my $self = shift;
        return $$self - 0.5 + $zero + 0.5;
    };

    sub new {
       my $class = shift;
       my $value = shift;
       return bless \$value, $class;
   }
}

my $v27a = 1/256;

format OUT27a =
'^<<<<<<<<<'~~
$v27a
.

is_format_utf8(\*OUT27a,
               "'0.00390625'\n");

my $v27b = 1/256;

format OUT27b =
'^<'~~
$v27b
.

is_format_utf8(\*OUT27b,
               "'0.'\n'00'\n'39'\n'06'\n'25'\n");

tie my $v27c, 'Number', 1/256;

format OUT27c =
'^<<<<<<<<<'~~
$v27c
.

is_format_utf8(\*OUT27c,
               "'0.00390625'\n");

my $v27d = 1/256;

format OUT27d =
'^<'~~
$v27d
.

is_format_utf8(\*OUT27d,
               "'0.'\n'00'\n'39'\n'06'\n'25'\n");

my $v27e = ONumber->new(1/256);

format OUT27e =
'^<<<<<<<<<'~~
$v27e
.

is_format_utf8(\*OUT27e,
               "'0.00390625'\n");

my $v27f = ONumber->new(1/256);

format OUT27f =
'^<'~~
$v27f
.

is_format_utf8(\*OUT27f,
               "'0.'\n'00'\n'39'\n'06'\n'25'\n");

{
    package Ref;
    use overload '""' => sub {
	return ${$_[0]};
    };

    sub new {
       my $class = shift;
       my $value = shift;
       return bless \$value, $class;
   }
}

my $v28a = {};

format OUT28a =
'^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<'~~
$v28a
.


# 'HASH(0x1716b60)     '
my $qr_hash   = qr/^'HASH\(0x[0-9a-f]+\)\s+'\n$/;

# 'HASH'
# '(0x1'
# '716b'
# 'c0) '
my $qr_hash_m = qr/^'HASH'\n('[0-9a-fx() ]{4}'\n)+$/;

like_format_utf8(\*OUT28a, $qr_hash);

my $v28b = {};

format OUT28b =
'^<<<'~~
$v28b
.

like_format_utf8(\*OUT28b, $qr_hash_m);


tie my $v28c, 'Tie::StdScalar';
$v28c = {};

format OUT28c =
'^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<'~~
$v28c
.

like_format_utf8(\*OUT28c, $qr_hash);

tie my $v28d, 'Tie::StdScalar';
$v28d = {};

format OUT28d =
'^<<<'~~
$v28d
.

like_format_utf8(\*OUT28d, $qr_hash_m);

my $v28e = Ref->new({});

format OUT28e =
'^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<'~~
$v28e
.

like_format_utf8(\*OUT28e, $qr_hash);

my $v28f = Ref->new({});

format OUT28f =
'^<<<'~~
$v28f
.

like_format_utf8(\*OUT28f, $qr_hash_m);



d630 2
a631 5
  my $exp = ">$ref<";
  is swrite('>^*<', $ref), $exp;
  $ref = [];
  my $exp = ">$ref<";
  is swrite('>@@*<', $ref), $exp;
a1092 19

open(HASH2, '>Op_write.tmp') || die "Can't create Op_write.tmp";
format HASH2 =
@@<<<
+{foo=>"bar"}
.
write HASH2;
close HASH2 or die "Could not close: $!";
is cat('Op_write.tmp'), "HASH\n", '+{...} is interpreted as anon hash';

# Anonymous hashes
open(BLOCK, '>Op_write.tmp') || die "Can't create Op_write.tmp";
format BLOCK =
@@<<< @@<<<
{foo=>"bar"} # this is a block, not a hash!
.
write BLOCK;
close BLOCK or die "Could not close: $!";
is cat('Op_write.tmp'), "foo  bar\n", 'initial { is always BLOCK';
@


1.1.1.15
log
@Import perl-5.20.2
@
text
@d101 1
a101 1
my $bug_tests = 66 + 3 * 3 * 5 * 2 * 3 + 2 + 66 + 4 + 2 + 3 + 96 + 11 + 3;
a1937 36
fresh_perl_is(<<'EOP', <<'EXPECT',
use warnings 'syntax' ;
format STDOUT =
^*|^*
my $x = q/dd/, $x
.
write;
EOP
dd|
EXPECT
	      { stderr => 1 }, '#123245 panic in sv_chop');

fresh_perl_is(<<'EOP', <<'EXPECT',
use warnings 'syntax' ;
format STDOUT =
^*|^*
my $x = q/dd/
.
write;
EOP
Not enough format arguments at - line 4.
dd|
EXPECT
	      { stderr => 1 }, '#123245 different panic in sv_chop');

fresh_perl_is(<<'EOP', <<'EXPECT',
format STDOUT =
# x at the end to make the spaces visible
@@... x
q/a/
.
write;
EOP
a    x
EXPECT
	      { stderr => 1 }, '#123538 crash in FF_MORE');
@


