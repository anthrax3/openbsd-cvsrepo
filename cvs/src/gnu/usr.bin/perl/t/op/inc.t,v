head	1.12;
access;
symbols
	OPENBSD_6_2_BASE:1.12
	PERL_5_24_2:1.1.1.11
	OPENBSD_6_1:1.12.0.4
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.11.0.10
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.4
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.11.0.6
	OPENBSD_5_8_BASE:1.11
	PERL_5_20_2:1.1.1.10
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	PERL_5_20_1:1.1.1.10
	OPENBSD_5_6:1.10.0.4
	OPENBSD_5_6_BASE:1.10
	PERL_5_18_2:1.1.1.9
	PERL:1.1.1
	OPENBSD_5_5:1.9.0.6
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.2
	OPENBSD_5_4_BASE:1.9
	PERL_5_16_3:1.1.1.8
	OPENBSD_5_3:1.8.0.10
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.8
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.6
	OPENBSD_5_0:1.8.0.4
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.2
	OPENBSD_4_9_BASE:1.8
	PERL_5_12_2:1.1.1.7
	OPENBSD_4_8:1.7.0.4
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.2
	OPENBSD_4_7_BASE:1.7
	PERL_5_10_1:1.1.1.6
	OPENBSD_4_6:1.6.0.16
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.12
	OPENBSD_4_5_BASE:1.6
	PERL_5_10_0:1.1.1.5
	OPENBSD_4_4:1.6.0.10
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.8
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.6
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.4
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.2
	OPENBSD_4_0_BASE:1.6
	PERL_5_8_8:1.1.1.5
	OPENBSD_3_9:1.5.0.10
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.8
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.6
	OPENBSD_3_7_BASE:1.5
	PERL_5_8_6:1.1.1.4
	OPENBSD_3_6:1.5.0.4
	OPENBSD_3_6_BASE:1.5
	PERL_5_8_5:1.1.1.4
	PERL_5_8_3:1.1.1.4
	OPENBSD_3_5:1.5.0.2
	OPENBSD_3_5_BASE:1.5
	PERL_5_8_2:1.1.1.4
	OPENBSD_3_4:1.4.0.4
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.4.0.2
	OPENBSD_3_3_BASE:1.4
	PERL_5_8_0:1.1.1.3
	OPENBSD_3_2:1.3.0.12
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.10
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.8
	OPENBSD_3_0_BASE:1.3
	PERL_5_6_1:1.1.1.2
	OPENBSD_2_9:1.3.0.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	PERL_500503:1.1.1.1
	CPAN:1.1.1
	OPENBSD_2_5:1.1.0.6
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.4
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.2
	OPENBSD_2_3_BASE:1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.12
date	2017.02.05.00.32.20;	author afresh1;	state Exp;
branches;
next	1.11;
commitid	cxJ08BvJA9Pt2PTM;

1.11
date	2014.11.17.20.57.07;	author afresh1;	state Exp;
branches;
next	1.10;
commitid	QP75iYx42Uo7mMxO;

1.10
date	2014.03.24.15.05.33;	author afresh1;	state Exp;
branches;
next	1.9;

1.9
date	2013.03.25.20.40.59;	author sthen;	state Exp;
branches;
next	1.8;

1.8
date	2010.09.24.15.07.08;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2009.10.12.18.30.27;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2006.03.28.19.23.12;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2003.12.03.03.02.48;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2002.10.27.22.25.37;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.06.17.08.24;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	99.04.29.22.52.35;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	97.11.30.08.05.24;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.29.22.41.46;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.04.06.16.10.48;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.10.27.22.15.10;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.12.03.02.44.32;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2006.03.28.18.49.45;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2009.10.12.18.10.44;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2010.09.24.14.49.18;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2013.03.25.20.09.35;	author sthen;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2014.03.24.14.59.10;	author afresh1;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2014.11.17.20.53.17;	author afresh1;	state Exp;
branches;
next	1.1.1.11;
commitid	B31cAbBIXiCqnL97;

1.1.1.11
date	2017.08.14.13.46.24;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@perl 5.004_04
@


1.12
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl -w

BEGIN {
    chdir 't' if -d 't';
    @@INC = '../lib';
    require './test.pl';
}

use strict;

use Config;

# Tests of post/pre - increment/decrement operators.

# Verify that addition/subtraction properly upgrade to doubles.
# These tests are only significant on machines with 32 bit longs,
# and two's complement negation, but shouldn't fail anywhere.

my $a = 2147483647;
my $c=$a++;
cmp_ok($a, '==', 2147483648, "postincrement properly upgrades to double");

$a = 2147483647;
$c=++$a;
cmp_ok($a, '==', 2147483648, "preincrement properly upgrades to double");

$a = 2147483647;
$a=$a+1;
cmp_ok($a, '==', 2147483648, "addition properly upgrades to double");

$a = -2147483648;
$c=$a--;
cmp_ok($a, '==', -2147483649, "postdecrement properly upgrades to double");

$a = -2147483648;
$c=--$a;
cmp_ok($a, '==', -2147483649, "predecrement properly upgrades to double");

$a = -2147483648;
$a=$a-1;
cmp_ok($a, '==', -2147483649, "subtraction properly upgrades to double");

$a = 2147483648;
$a = -$a;
$c=$a--;
cmp_ok($a, '==', -2147483649,
    "negation and postdecrement properly upgrade to double");

$a = 2147483648;
$a = -$a;
$c=--$a;
cmp_ok($a, '==', -2147483649,
    "negation and predecrement properly upgrade to double");

$a = 2147483648;
$a = -$a;
$a=$a-1;
cmp_ok($a, '==', -2147483649,
    "negation and subtraction properly upgrade to double");

$a = 2147483648;
$b = -$a;
$c=$b--;
cmp_ok($b, '==', -$a-1, "negation, postdecrement and additional negation");

$a = 2147483648;
$b = -$a;
$c=--$b;
cmp_ok($b, '==', -$a-1, "negation, predecrement and additional negation");

$a = 2147483648;
$b = -$a;
$b=$b-1;
cmp_ok($b, '==', -(++$a),
    "negation, subtraction, preincrement and additional negation");

$a = undef;
is($a++, '0', "postinc undef returns '0'");

$a = undef;
is($a--, undef, "postdec undef returns undef");

# Verify that shared hash keys become unshared.

sub check_same {
  my ($orig, $suspect) = @@_;
  my $fail;
  while (my ($key, $value) = each %$suspect) {
    if (exists $orig->{$key}) {
      if ($orig->{$key} ne $value) {
        print "# key '$key' was '$orig->{$key}' now '$value'\n";
        $fail = 1;
      }
    } else {
      print "# key '$key' is '$orig->{$key}', unexpect.\n";
      $fail = 1;
    }
  }
  foreach (keys %$orig) {
    next if (exists $suspect->{$_});
    print "# key '$_' was '$orig->{$_}' now missing\n";
    $fail = 1;
  }
  ok (!$fail, "original hashes unchanged");
}

my (%orig) = my (%inc) = my (%dec) = my (%postinc) = my (%postdec)
  = (1 => 1, ab => "ab");
my %up = (1=>2, ab => 'ac');
my %down = (1=>0, ab => -1);

foreach (keys %inc) {
  my $ans = $up{$_};
  my $up;
  eval {$up = ++$_};
  is($up, $ans, "key '$_' incremented correctly");
  is($@@, '', "no error condition");
}

check_same (\%orig, \%inc);

foreach (keys %dec) {
  my $ans = $down{$_};
  my $down;
  eval {$down = --$_};
  is($down, $ans, "key '$_' decremented correctly");
  is($@@, '', "no error condition");
}

check_same (\%orig, \%dec);

foreach (keys %postinc) {
  my $ans = $postinc{$_};
  my $up;
  eval {$up = $_++};
  is($up, $ans, "assignment preceded postincrement");
  is($@@, '', "no error condition");
}

check_same (\%orig, \%postinc);

foreach (keys %postdec) {
  my $ans = $postdec{$_};
  my $down;
  eval {$down = $_--};
  is($down, $ans, "assignment preceded postdecrement");
  is($@@, '', "no error condition");
}

check_same (\%orig, \%postdec);

{
    no warnings 'uninitialized';
    my ($x, $y);
    eval {
	$y ="$x\n";
	++$x;
    };
    cmp_ok($x, '==', 1, "preincrement of previously uninitialized variable");
    is($@@, '', "no error condition");

    my ($p, $q);
    eval {
	$q ="$p\n";
	--$p;
    };
    cmp_ok($p, '==', -1, "predecrement of previously uninitialized variable");
    is($@@, '', "no error condition");
}

$a = 2147483648;
$c=--$a;
cmp_ok($a, '==', 2147483647, "predecrement properly downgrades from double");


$a = 2147483648;
$c=$a--;
cmp_ok($a, '==', 2147483647, "postdecrement properly downgrades from double");

{
    use integer;
    my $x = 0;
    $x++;
    cmp_ok($x, '==', 1, "(void) i_postinc");
    $x--;
    cmp_ok($x, '==', 0, "(void) i_postdec");
}

SKIP: {
    if ($Config{uselongdouble} &&
        ($Config{longdblkind} == 6 || $Config{longdblkind} == 5)) {
        skip "the double-double format is weird", 1;
    }

# I'm sure that there's an IBM format with a 48 bit mantissa
# IEEE doubles have a 53 bit mantissa
# 80 bit long doubles have a 64 bit mantissa
# sparcs have a 112 bit mantissa for their long doubles. Just to be awkward :-)

my $h_uv_max = 1 + (~0 >> 1);
my $found;
for my $n (47..113) {
    my $power_of_2 = 2**$n;
    my $plus_1 = $power_of_2 + 1;
    next if $plus_1 != $power_of_2;
    my ($start_p, $start_n);
    if ($h_uv_max > $power_of_2 / 2) {
	my $uv_max = 1 + 2 * (~0 >> 1);
	# UV_MAX is 2**$something - 1, so subtract 1 to get the start value
	$start_p = $uv_max - 1;
	# whereas IV_MIN is -(2**$something), so subtract 2
	$start_n = -$h_uv_max + 2;
	print "# Mantissa overflows at 2**$n ($power_of_2)\n";
	print "# But max UV ($uv_max) is greater so testing that\n";
    } else {
	print "# Testing 2**$n ($power_of_2) which overflows the mantissa\n";
	$start_p = int($power_of_2 - 2);
	$start_n = -$start_p;
	my $check = $power_of_2 - 2;
	die "Something wrong with our rounding assumptions: $check vs $start_p"
	    unless $start_p == $check;
    }

    foreach ([$start_p, '++$i', 'pre-inc', 'inc'],
	     [$start_p, '$i++', 'post-inc', 'inc'],
	     [$start_n, '--$i', 'pre-dec', 'dec'],
	     [$start_n, '$i--', 'post-dec', 'dec']) {
	my ($start, $action, $description, $act) = @@$_;
	my $code = eval << "EOC" or die $@@;
sub {
    no warnings 'imprecision';
    my \$i = \$start;
    for(0 .. 3) {
        my \$a = $action;
    }
}
EOC

	warning_is($code, undef, "$description under no warnings 'imprecision'");

	$code = eval << "EOC" or die $@@;
sub {
    use warnings 'imprecision';
    my \$i = \$start;
    for(0 .. 3) {
        my \$a = $action;
    }
}
EOC

	warnings_like($code, [(qr/Lost precision when ${act}rementing -?\d+/) x 2],
		      "$description under use warnings 'imprecision'");
    }

    $found = 1;
    last;
}

ok($found, "found a NV value which overflows the mantissa");

} # SKIP

# these will segfault if they fail

sub PVBM () { 'foo' }
{ my $dummy = index 'foo', PVBM }

isnt(scalar eval { my $pvbm = PVBM; $pvbm++ }, undef, "postincrement defined");
isnt(scalar eval { my $pvbm = PVBM; $pvbm-- }, undef, "postdecrement defined");
isnt(scalar eval { my $pvbm = PVBM; ++$pvbm }, undef, "preincrement defined");
isnt(scalar eval { my $pvbm = PVBM; --$pvbm }, undef, "predecrement defined");

# #9466

# don't use pad TARG when the thing you're copying is a ref, or the referent
# won't get freed.
{
    package P9466;
    my $x;
    sub DESTROY { $x = 1 }
    for (0..1) {
	$x = 0;
	my $a = bless {};
	my $b = $_ ? $a++ : $a--;
	undef $a; undef $b;
	::is($x, 1, "9466 case $_");
    }
}

# *Do* use pad TARG if it is actually a named variable, even when the thing
# you’re copying is a ref.  The fix for #9466 broke this.
{
    package P9466_2;
    my $x;
    sub DESTROY { $x = 1 }
    for (2..3) {
	$x = 0;
	my $a = bless {};
	my $b;
	use integer;
	if ($_ == 2) {
	    $b = $a--; # sassign optimised away
	}
	else {
	    $b = $a++;
	}
	::is(ref $b, __PACKAGE__, 'i_post(in|de)c/TARGMY on ref');
	undef $a; undef $b;
	::is($x, 1, "9466 case $_");
    }
}

$_ = ${qr //};
$_--;
is($_, -1, 'regexp--');
{
    no warnings 'numeric';
    $_ = ${qr //};
    $_++;
    is($_, 1, 'regexp++');
}

if ($::IS_EBCDIC) {
    $_ = v129;
    $_++;
    isnt(ref\$_, 'VSTRING', '++ flattens vstrings');
}
else {
    $_ = v97;
    $_++;
    isnt(ref\$_, 'VSTRING', '++ flattens vstrings');
}

sub TIESCALAR {bless\my $x}
sub STORE { ++$store::called }
tie my $t, "";
{
    $t = $_++;
    $t = $_--;
    use integer;
    $t = $_++;
    $t = $_--;
}
is $store::called, 4, 'STORE called on "my" target';

{
    # Temporarily broken between before 5.6.0 (b162f9ea/21f5b33c) and
    # between 5.21.5 and 5.21.6 (9e319cc4fd)
    my $x = 7;
    $x = $x++;
    is $x, 7, '$lex = $lex++';
    $x = 7;
    # broken in b162f9ea (5.6.0); fixed in 5.21.6
    use integer;
    $x = $x++;
    is $x, 7, '$lex = $lex++ under use integer';
}

{
    # RT #126637 - it should refuse to modify globs
    no warnings 'once';
    *GLOB126637 = [];

    eval 'my $y = ++$_ for *GLOB126637';
    like $@@, qr/Modification of a read-only value/, '++*GLOB126637';
    eval 'my $y = --$_ for *GLOB126637';
    like $@@, qr/Modification of a read-only value/, '--*GLOB126637';
    eval 'my $y = $_++ for *GLOB126637';
    like $@@, qr/Modification of a read-only value/, '*GLOB126637++';
    eval 'my $y = $_-- for *GLOB126637';
    like $@@, qr/Modification of a read-only value/, '*GLOB126637--';

    use integer;

    eval 'my $y = ++$_ for *GLOB126637';
    like $@@, qr/Modification of a read-only value/, 'use int; ++*GLOB126637';
    eval 'my $y = --$_ for *GLOB126637';
    like $@@, qr/Modification of a read-only value/, 'use int; --*GLOB126637';
    eval 'my $y = $_++ for *GLOB126637';
    like $@@, qr/Modification of a read-only value/, 'use int; *GLOB126637++';
    eval 'my $y = $_-- for *GLOB126637';
    like $@@, qr/Modification of a read-only value/, 'use int; *GLOB126637--';
}

done_testing();
@


1.11
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d3 6
a8 1
require './test.pl';
d11 2
d189 6
d258 4
a261 1
die "Could not find a value which overflows the mantissa" unless $found;
d290 23
d316 58
a373 3
$_ = ${qr //};
$_++;
is($_, 1, 'regexp++');
d375 9
a383 3
$_ = v97;
$_++;
isnt(ref\$_, 'VSTRING', '++ flattens vstrings');
@


1.10
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d274 11
@


1.9
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d6 2
d14 1
a14 1
cmp_ok($a, '==', 2147483648);
d18 1
a18 1
cmp_ok($a, '==', 2147483648);
d22 1
a22 1
cmp_ok($a, '==', 2147483648);
d26 1
a26 1
cmp_ok($a, '==', -2147483649);
d30 1
a30 1
cmp_ok($a, '==', -2147483649);
d34 1
a34 1
cmp_ok($a, '==', -2147483649);
d39 2
a40 1
cmp_ok($a, '==', -2147483649);
d45 2
a46 1
cmp_ok($a, '==', -2147483649);
d51 2
a52 1
cmp_ok($a, '==', -2147483649);
d57 1
a57 1
cmp_ok($b, '==', -$a-1);
d62 1
a62 1
cmp_ok($b, '==', -$a-1);
d67 2
a68 1
cmp_ok($b, '==', -(++$a));
d97 1
a97 1
  ok (!$fail);
d109 2
a110 2
  is($up, $ans);
  is($@@, '');
d119 2
a120 2
  is($down, $ans);
  is($@@, '');
d129 2
a130 2
  is($up, $ans);
  is($@@, '');
d139 2
a140 2
  is($down, $ans);
  is($@@, '');
d152 2
a153 2
    cmp_ok($x, '==', 1);
    is($@@, '');
d160 2
a161 2
    cmp_ok($p, '==', -1);
    is($@@, '');
d166 1
a166 1
cmp_ok($a, '==', 2147483647);
d171 1
a171 1
cmp_ok($a, '==', 2147483647);
d252 4
a255 4
isnt(scalar eval { my $pvbm = PVBM; $pvbm++ }, undef);
isnt(scalar eval { my $pvbm = PVBM; $pvbm-- }, undef);
isnt(scalar eval { my $pvbm = PVBM; ++$pvbm }, undef);
isnt(scalar eval { my $pvbm = PVBM; --$pvbm }, undef);
@


1.8
log
@merge in perl 5.12.2 plus local changes
@
text
@d3 2
a4 28
# use strict;

print "1..54\n";

my $test = 1;

sub ok {
  my ($pass, $wrong, $err) = @@_;
  if ($pass) {
    print "ok $test\n";
    $test = $test + 1; # Would be doubleplusbad to use ++ in the ++ test.
    return 1;
  } else {
    if ($err) {
      chomp $err;
      print "not ok $test # $err\n";
    } else {
      if (defined $wrong) {
        $wrong = ", got $wrong";
      } else {
        $wrong = '';
      }
      printf "not ok $test # line %d$wrong\n", (caller)[2];
    }
  }
  $test = $test + 1;
  return;
}
d12 1
a12 1
ok ($a == 2147483648, $a);
d16 1
a16 1
ok ($a == 2147483648, $a);
d20 1
a20 1
ok ($a == 2147483648, $a);
d24 1
a24 1
ok ($a == -2147483649, $a);
d28 1
a28 1
ok ($a == -2147483649, $a);
d32 1
a32 1
ok ($a == -2147483649, $a);
d37 1
a37 1
ok ($a == -2147483649, $a);
d42 1
a42 1
ok ($a == -2147483649, $a);
d47 1
a47 1
ok ($a == -2147483649, $a);
d52 1
a52 1
ok ($b == -$a-1, $a);
d57 1
a57 1
ok ($b == -$a-1, $a);
d62 1
a62 1
ok ($b == -(++$a), $a);
d65 1
a65 1
ok ($a++ eq '0', do { $a=undef; $a++ }, "postinc undef returns '0'");
d68 1
a68 1
ok (!defined($a--), do { $a=undef; $a-- }, "postdec undef returns undef");
d103 2
a104 1
  ok ((defined $up and $up eq $ans), $up, $@@);
d113 2
a114 1
  ok ((defined $down and $down eq $ans), $down, $@@);
d123 2
a124 1
  ok ((defined $up and $up eq $ans), $up, $@@);
d133 2
a134 1
  ok ((defined $down and $down eq $ans), $down, $@@);
d146 2
a147 2
    ok($x == 1, $x);
    ok($@@ eq '', $@@);
d154 2
a155 2
    ok($p == -1, $p);
    ok($@@ eq '', $@@);
d160 1
a160 1
ok ($a == 2147483647, $a);
d165 1
a165 1
ok ($a == 2147483647, $a);
d171 1
a171 1
    ok ($x == 1, "(void) i_postinc");
d173 1
a173 1
    ok ($x == 0, "(void) i_postdec");
a180 33
sub check_some_code {
    my ($start, $warn, $action, $description) = @@_;
    my $warn_line = ($warn ? 'use' : 'no') . " warnings 'imprecision';";
    my @@warnings;
    local $SIG{__WARN__} = sub {push @@warnings, "@@_"};

    print "# checking $action under $warn_line\n";
    my $code = <<"EOC";
$warn_line
my \$i = \$start;
for(0 .. 3) {
    my \$a = $action;
}
1;
EOC
    eval $code or die "# $@@\n$code";

    if ($warn) {
	unless (ok (scalar @@warnings == 2, scalar @@warnings)) {
	    print STDERR "# $_" foreach @@warnings;
	}
	foreach (@@warnings) {
	    unless (ok (/Lost precision when incrementing \d+/, $_)) {
		print STDERR "# $_"
	    }
	}
    } else {
	unless (ok (scalar @@warnings == 0)) {
	    print STDERR "# @@$_" foreach @@warnings;
	}
    }
}

d205 29
a233 7
    foreach my $warn (0, 1) {
	foreach (['++$i', 'pre-inc'], ['$i++', 'post-inc']) {
	    check_some_code($start_p, $warn, @@$_);
	}
	foreach (['--$i', 'pre-dec'], ['$i--', 'post-dec']) {
	    check_some_code($start_n, $warn, @@$_);
	}
d246 21
a266 4
ok (scalar eval { my $pvbm = PVBM; $pvbm++ });
ok (scalar eval { my $pvbm = PVBM; $pvbm-- });
ok (scalar eval { my $pvbm = PVBM; ++$pvbm });
ok (scalar eval { my $pvbm = PVBM; --$pvbm });
d268 1
@


1.7
log
@Merge in perl 5.10.1; part two
@
text
@d5 1
a5 1
print "1..38\n";
d197 76
@


1.6
log
@merge in perl 5.8.8
@
text
@d5 1
a5 1
print "1..34\n";
d197 11
@


1.5
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d5 1
a5 1
print "1..26\n";
d160 37
@


1.4
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d5 1
a5 1
print "1..24\n";
d89 6
@


1.3
log
@perl-5.6.0 + local changes
@
text
@d1 1
a1 1
#!./perl
d3 28
a30 1
print "1..12\n";
d36 3
a38 6
$a = 2147483647;
$c=$a++;
if ($a == 2147483648) 
	{print "ok 1\n"}
else
	{print "not ok 1\n";}
d42 1
a42 4
if ($a == 2147483648) 
	{print "ok 2\n"}
else
	{print "not ok 2\n";}
d46 1
a46 4
if ($a == 2147483648) 
	{print "ok 3\n"}
else
	{print "not ok 3\n";}
d50 1
a50 4
if ($a == -2147483649) 
	{print "ok 4\n"}
else
	{print "not ok 4\n";}
d54 1
a54 4
if ($a == -2147483649) 
	{print "ok 5\n"}
else
	{print "not ok 5\n";}
d58 1
a58 4
if ($a == -2147483649) 
	{print "ok 6\n"}
else
	{print "not ok 6\n";}
d63 1
a63 4
if ($a == -2147483649) 
	{print "ok 7\n"}
else
	{print "not ok 7\n";}
d68 1
a68 4
if ($a == -2147483649) 
	{print "ok 8\n"}
else
	{print "not ok 8\n";}
d73 1
a73 4
if ($a == -2147483649) 
	{print "ok 9\n"}
else
	{print "not ok 9\n";}
d78 1
a78 4
if ($b == -$a-1) 
	{print "ok 10\n"}
else
	{print "not ok 10\n";}
d83 1
a83 4
if ($b == -$a-1) 
	{print "ok 11\n"}
else
	{print "not ok 11\n";}
d88 66
a153 4
if ($b == -(++$a)) 
	{print "ok 12\n"}
else
	{print "not ok 12\n";}
@


1.2
log
@perl5.005_03 (stock)
@
text
@d3 1
a3 4

# $RCSfile$

print "1..6\n";
d50 48
@


1.1
log
@perl 5.004_04
@
text
@@


1.1.1.1
log
@perl5.005_03
@
text
@@


1.1.1.2
log
@virgin perl 5.6.0
@
text
@d3 4
a6 1
print "1..12\n";
a52 48

$a = 2147483648;
$a = -$a;
$c=$a--;
if ($a == -2147483649) 
	{print "ok 7\n"}
else
	{print "not ok 7\n";}

$a = 2147483648;
$a = -$a;
$c=--$a;
if ($a == -2147483649) 
	{print "ok 8\n"}
else
	{print "not ok 8\n";}

$a = 2147483648;
$a = -$a;
$a=$a-1;
if ($a == -2147483649) 
	{print "ok 9\n"}
else
	{print "not ok 9\n";}

$a = 2147483648;
$b = -$a;
$c=$b--;
if ($b == -$a-1) 
	{print "ok 10\n"}
else
	{print "not ok 10\n";}

$a = 2147483648;
$b = -$a;
$c=--$b;
if ($b == -$a-1) 
	{print "ok 11\n"}
else
	{print "not ok 11\n";}

$a = 2147483648;
$b = -$a;
$b=$b-1;
if ($b == -(++$a)) 
	{print "ok 12\n"}
else
	{print "not ok 12\n";}
@


1.1.1.3
log
@stock perl 5.8.0 from CPAN
@
text
@d1 1
a1 1
#!./perl -w
d3 1
a3 28
# use strict;

print "1..24\n";

my $test = 1;

sub ok {
  my ($pass, $wrong, $err) = @@_;
  if ($pass) {
    print "ok $test\n";
    $test = $test + 1; # Would be doubleplusbad to use ++ in the ++ test.
    return 1;
  } else {
    if ($err) {
      chomp $err;
      print "not ok $test # $err\n";
    } else {
      if (defined $wrong) {
        $wrong = ", got $wrong";
      } else {
        $wrong = '';
      }
      printf "not ok $test # line %d$wrong\n", (caller)[2];
    }
  }
  $test = $test + 1;
  return;
}
d9 6
a14 3
my $a = 2147483647;
my $c=$a++;
ok ($a == 2147483648, $a);
d18 4
a21 1
ok ($a == 2147483648, $a);
d25 4
a28 1
ok ($a == 2147483648, $a);
d32 4
a35 1
ok ($a == -2147483649, $a);
d39 4
a42 1
ok ($a == -2147483649, $a);
d46 4
a49 1
ok ($a == -2147483649, $a);
d54 4
a57 1
ok ($a == -2147483649, $a);
d62 4
a65 1
ok ($a == -2147483649, $a);
d70 4
a73 1
ok ($a == -2147483649, $a);
d78 4
a81 1
ok ($b == -$a-1, $a);
d86 4
a89 1
ok ($b == -$a-1, $a);
d94 4
a97 66
ok ($b == -(++$a), $a);

# Verify that shared hash keys become unshared.

sub check_same {
  my ($orig, $suspect) = @@_;
  my $fail;
  while (my ($key, $value) = each %$suspect) {
    if (exists $orig->{$key}) {
      if ($orig->{$key} ne $value) {
        print "# key '$key' was '$orig->{$key}' now '$value'\n";
        $fail = 1;
      }
    } else {
      print "# key '$key' is '$orig->{$key}', unexpect.\n";
      $fail = 1;
    }
  }
  foreach (keys %$orig) {
    next if (exists $suspect->{$_});
    print "# key '$_' was '$orig->{$_}' now missing\n";
    $fail = 1;
  }
  ok (!$fail);
}

my (%orig) = my (%inc) = my (%dec) = my (%postinc) = my (%postdec)
  = (1 => 1, ab => "ab");
my %up = (1=>2, ab => 'ac');
my %down = (1=>0, ab => -1);

foreach (keys %inc) {
  my $ans = $up{$_};
  my $up;
  eval {$up = ++$_};
  ok ((defined $up and $up eq $ans), $up, $@@);
}

check_same (\%orig, \%inc);

foreach (keys %dec) {
  my $ans = $down{$_};
  my $down;
  eval {$down = --$_};
  ok ((defined $down and $down eq $ans), $down, $@@);
}

check_same (\%orig, \%dec);

foreach (keys %postinc) {
  my $ans = $postinc{$_};
  my $up;
  eval {$up = $_++};
  ok ((defined $up and $up eq $ans), $up, $@@);
}

check_same (\%orig, \%postinc);

foreach (keys %postdec) {
  my $ans = $postdec{$_};
  my $down;
  eval {$down = $_--};
  ok ((defined $down and $down eq $ans), $down, $@@);
}

check_same (\%orig, \%postdec);
@


1.1.1.4
log
@perl 5.8.2 from CPAN
@
text
@d5 1
a5 1
print "1..26\n";
a88 6

$a = undef;
ok ($a++ eq '0', do { $a=undef; $a++ }, "postinc undef returns '0'");

$a = undef;
ok (!defined($a--), do { $a=undef; $a-- }, "postdec undef returns undef");
@


1.1.1.5
log
@perl 5.8.8 import
@
text
@d5 1
a5 1
print "1..34\n";
a159 37

{
    no warnings 'uninitialized';
    my ($x, $y);
    eval {
	$y ="$x\n";
	++$x;
    };
    ok($x == 1, $x);
    ok($@@ eq '', $@@);

    my ($p, $q);
    eval {
	$q ="$p\n";
	--$p;
    };
    ok($p == -1, $p);
    ok($@@ eq '', $@@);
}

$a = 2147483648;
$c=--$a;
ok ($a == 2147483647, $a);


$a = 2147483648;
$c=$a--;
ok ($a == 2147483647, $a);

{
    use integer;
    my $x = 0;
    $x++;
    ok ($x == 1, "(void) i_postinc");
    $x--;
    ok ($x == 0, "(void) i_postdec");
}
@


1.1.1.6
log
@import perl 5.10.1
@
text
@d5 1
a5 1
print "1..38\n";
a196 11

# these will segfault if they fail

sub PVBM () { 'foo' }
{ my $dummy = index 'foo', PVBM }

ok (scalar eval { my $pvbm = PVBM; $pvbm++ });
ok (scalar eval { my $pvbm = PVBM; $pvbm-- });
ok (scalar eval { my $pvbm = PVBM; ++$pvbm });
ok (scalar eval { my $pvbm = PVBM; --$pvbm });

@


1.1.1.7
log
@Perl 5.12.2 from CPAN
@
text
@d5 1
a5 1
print "1..54\n";
a196 76

# I'm sure that there's an IBM format with a 48 bit mantissa
# IEEE doubles have a 53 bit mantissa
# 80 bit long doubles have a 64 bit mantissa
# sparcs have a 112 bit mantissa for their long doubles. Just to be awkward :-)

sub check_some_code {
    my ($start, $warn, $action, $description) = @@_;
    my $warn_line = ($warn ? 'use' : 'no') . " warnings 'imprecision';";
    my @@warnings;
    local $SIG{__WARN__} = sub {push @@warnings, "@@_"};

    print "# checking $action under $warn_line\n";
    my $code = <<"EOC";
$warn_line
my \$i = \$start;
for(0 .. 3) {
    my \$a = $action;
}
1;
EOC
    eval $code or die "# $@@\n$code";

    if ($warn) {
	unless (ok (scalar @@warnings == 2, scalar @@warnings)) {
	    print STDERR "# $_" foreach @@warnings;
	}
	foreach (@@warnings) {
	    unless (ok (/Lost precision when incrementing \d+/, $_)) {
		print STDERR "# $_"
	    }
	}
    } else {
	unless (ok (scalar @@warnings == 0)) {
	    print STDERR "# @@$_" foreach @@warnings;
	}
    }
}

my $h_uv_max = 1 + (~0 >> 1);
my $found;
for my $n (47..113) {
    my $power_of_2 = 2**$n;
    my $plus_1 = $power_of_2 + 1;
    next if $plus_1 != $power_of_2;
    my ($start_p, $start_n);
    if ($h_uv_max > $power_of_2 / 2) {
	my $uv_max = 1 + 2 * (~0 >> 1);
	# UV_MAX is 2**$something - 1, so subtract 1 to get the start value
	$start_p = $uv_max - 1;
	# whereas IV_MIN is -(2**$something), so subtract 2
	$start_n = -$h_uv_max + 2;
	print "# Mantissa overflows at 2**$n ($power_of_2)\n";
	print "# But max UV ($uv_max) is greater so testing that\n";
    } else {
	print "# Testing 2**$n ($power_of_2) which overflows the mantissa\n";
	$start_p = int($power_of_2 - 2);
	$start_n = -$start_p;
	my $check = $power_of_2 - 2;
	die "Something wrong with our rounding assumptions: $check vs $start_p"
	    unless $start_p == $check;
    }

    foreach my $warn (0, 1) {
	foreach (['++$i', 'pre-inc'], ['$i++', 'post-inc']) {
	    check_some_code($start_p, $warn, @@$_);
	}
	foreach (['--$i', 'pre-dec'], ['$i--', 'post-dec']) {
	    check_some_code($start_n, $warn, @@$_);
	}
    }

    $found = 1;
    last;
}
die "Could not find a value which overflows the mantissa" unless $found;
@


1.1.1.8
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d3 28
a30 2
require './test.pl';
use strict;
d38 1
a38 1
cmp_ok($a, '==', 2147483648);
d42 1
a42 1
cmp_ok($a, '==', 2147483648);
d46 1
a46 1
cmp_ok($a, '==', 2147483648);
d50 1
a50 1
cmp_ok($a, '==', -2147483649);
d54 1
a54 1
cmp_ok($a, '==', -2147483649);
d58 1
a58 1
cmp_ok($a, '==', -2147483649);
d63 1
a63 1
cmp_ok($a, '==', -2147483649);
d68 1
a68 1
cmp_ok($a, '==', -2147483649);
d73 1
a73 1
cmp_ok($a, '==', -2147483649);
d78 1
a78 1
cmp_ok($b, '==', -$a-1);
d83 1
a83 1
cmp_ok($b, '==', -$a-1);
d88 1
a88 1
cmp_ok($b, '==', -(++$a));
d91 1
a91 1
is($a++, '0', "postinc undef returns '0'");
d94 1
a94 1
is($a--, undef, "postdec undef returns undef");
d129 1
a129 2
  is($up, $ans);
  is($@@, '');
d138 1
a138 2
  is($down, $ans);
  is($@@, '');
d147 1
a147 2
  is($up, $ans);
  is($@@, '');
d156 1
a156 2
  is($down, $ans);
  is($@@, '');
d168 2
a169 2
    cmp_ok($x, '==', 1);
    is($@@, '');
d176 2
a177 2
    cmp_ok($p, '==', -1);
    is($@@, '');
d182 1
a182 1
cmp_ok($a, '==', 2147483647);
d187 1
a187 1
cmp_ok($a, '==', 2147483647);
d193 1
a193 1
    cmp_ok($x, '==', 1, "(void) i_postinc");
d195 1
a195 1
    cmp_ok($x, '==', 0, "(void) i_postdec");
d203 33
d260 7
a266 29
    foreach ([$start_p, '++$i', 'pre-inc', 'inc'],
	     [$start_p, '$i++', 'post-inc', 'inc'],
	     [$start_n, '--$i', 'pre-dec', 'dec'],
	     [$start_n, '$i--', 'post-dec', 'dec']) {
	my ($start, $action, $description, $act) = @@$_;
	my $code = eval << "EOC" or die $@@;
sub {
    no warnings 'imprecision';
    my \$i = \$start;
    for(0 .. 3) {
        my \$a = $action;
    }
}
EOC

	warning_is($code, undef, "$description under no warnings 'imprecision'");

	$code = eval << "EOC" or die $@@;
sub {
    use warnings 'imprecision';
    my \$i = \$start;
    for(0 .. 3) {
        my \$a = $action;
    }
}
EOC

	warnings_like($code, [(qr/Lost precision when ${act}rementing -?\d+/) x 2],
		      "$description under use warnings 'imprecision'");
d279 4
a282 21
isnt(scalar eval { my $pvbm = PVBM; $pvbm++ }, undef);
isnt(scalar eval { my $pvbm = PVBM; $pvbm-- }, undef);
isnt(scalar eval { my $pvbm = PVBM; ++$pvbm }, undef);
isnt(scalar eval { my $pvbm = PVBM; --$pvbm }, undef);

# #9466

# don't use pad TARG when the thing you're copying is a ref, or the referent
# won't get freed.
{
    package P9466;
    my $x;
    sub DESTROY { $x = 1 }
    for (0..1) {
	$x = 0;
	my $a = bless {};
	my $b = $_ ? $a++ : $a--;
	undef $a; undef $b;
	::is($x, 1, "9466 case $_");
    }
}
a283 1
done_testing();
@


1.1.1.9
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@a5 2
# Tests of post/pre - increment/decrement operators.

d12 1
a12 1
cmp_ok($a, '==', 2147483648, "postincrement properly upgrades to double");
d16 1
a16 1
cmp_ok($a, '==', 2147483648, "preincrement properly upgrades to double");
d20 1
a20 1
cmp_ok($a, '==', 2147483648, "addition properly upgrades to double");
d24 1
a24 1
cmp_ok($a, '==', -2147483649, "postdecrement properly upgrades to double");
d28 1
a28 1
cmp_ok($a, '==', -2147483649, "predecrement properly upgrades to double");
d32 1
a32 1
cmp_ok($a, '==', -2147483649, "subtraction properly upgrades to double");
d37 1
a37 2
cmp_ok($a, '==', -2147483649,
    "negation and postdecrement properly upgrade to double");
d42 1
a42 2
cmp_ok($a, '==', -2147483649,
    "negation and predecrement properly upgrade to double");
d47 1
a47 2
cmp_ok($a, '==', -2147483649,
    "negation and subtraction properly upgrade to double");
d52 1
a52 1
cmp_ok($b, '==', -$a-1, "negation, postdecrement and additional negation");
d57 1
a57 1
cmp_ok($b, '==', -$a-1, "negation, predecrement and additional negation");
d62 1
a62 2
cmp_ok($b, '==', -(++$a),
    "negation, subtraction, preincrement and additional negation");
d91 1
a91 1
  ok (!$fail, "original hashes unchanged");
d103 2
a104 2
  is($up, $ans, "key '$_' incremented correctly");
  is($@@, '', "no error condition");
d113 2
a114 2
  is($down, $ans, "key '$_' decremented correctly");
  is($@@, '', "no error condition");
d123 2
a124 2
  is($up, $ans, "assignment preceded postincrement");
  is($@@, '', "no error condition");
d133 2
a134 2
  is($down, $ans, "assignment preceded postdecrement");
  is($@@, '', "no error condition");
d146 2
a147 2
    cmp_ok($x, '==', 1, "preincrement of previously uninitialized variable");
    is($@@, '', "no error condition");
d154 2
a155 2
    cmp_ok($p, '==', -1, "predecrement of previously uninitialized variable");
    is($@@, '', "no error condition");
d160 1
a160 1
cmp_ok($a, '==', 2147483647, "predecrement properly downgrades from double");
d165 1
a165 1
cmp_ok($a, '==', 2147483647, "postdecrement properly downgrades from double");
d246 4
a249 4
isnt(scalar eval { my $pvbm = PVBM; $pvbm++ }, undef, "postincrement defined");
isnt(scalar eval { my $pvbm = PVBM; $pvbm-- }, undef, "postdecrement defined");
isnt(scalar eval { my $pvbm = PVBM; ++$pvbm }, undef, "preincrement defined");
isnt(scalar eval { my $pvbm = PVBM; --$pvbm }, undef, "predecrement defined");
@


1.1.1.10
log
@Import perl-5.20.1
@
text
@a273 11
$_ = ${qr //};
$_--;
is($_, -1, 'regexp--');
$_ = ${qr //};
$_++;
is($_, 1, 'regexp++');

$_ = v97;
$_++;
isnt(ref\$_, 'VSTRING', '++ flattens vstrings');

@


1.1.1.11
log
@Import perl-5.24.2
@
text
@d3 1
a3 6
BEGIN {
    chdir 't' if -d 't';
    @@INC = '../lib';
    require './test.pl';
}

a5 2
use Config;

a181 6
SKIP: {
    if ($Config{uselongdouble} &&
        ($Config{longdblkind} == 6 || $Config{longdblkind} == 5)) {
        skip "the double-double format is weird", 1;
    }

d245 1
a245 4

ok($found, "found a NV value which overflows the mantissa");

} # SKIP
a273 23
# *Do* use pad TARG if it is actually a named variable, even when the thing
# you’re copying is a ref.  The fix for #9466 broke this.
{
    package P9466_2;
    my $x;
    sub DESTROY { $x = 1 }
    for (2..3) {
	$x = 0;
	my $a = bless {};
	my $b;
	use integer;
	if ($_ == 2) {
	    $b = $a--; # sassign optimised away
	}
	else {
	    $b = $a++;
	}
	::is(ref $b, __PACKAGE__, 'i_post(in|de)c/TARGMY on ref');
	undef $a; undef $b;
	::is($x, 1, "9466 case $_");
    }
}

d277 3
a279 29
{
    no warnings 'numeric';
    $_ = ${qr //};
    $_++;
    is($_, 1, 'regexp++');
}

if ($::IS_EBCDIC) {
    $_ = v129;
    $_++;
    isnt(ref\$_, 'VSTRING', '++ flattens vstrings');
}
else {
    $_ = v97;
    $_++;
    isnt(ref\$_, 'VSTRING', '++ flattens vstrings');
}

sub TIESCALAR {bless\my $x}
sub STORE { ++$store::called }
tie my $t, "";
{
    $t = $_++;
    $t = $_--;
    use integer;
    $t = $_++;
    $t = $_--;
}
is $store::called, 4, 'STORE called on "my" target';
d281 3
a283 38
{
    # Temporarily broken between before 5.6.0 (b162f9ea/21f5b33c) and
    # between 5.21.5 and 5.21.6 (9e319cc4fd)
    my $x = 7;
    $x = $x++;
    is $x, 7, '$lex = $lex++';
    $x = 7;
    # broken in b162f9ea (5.6.0); fixed in 5.21.6
    use integer;
    $x = $x++;
    is $x, 7, '$lex = $lex++ under use integer';
}

{
    # RT #126637 - it should refuse to modify globs
    no warnings 'once';
    *GLOB126637 = [];

    eval 'my $y = ++$_ for *GLOB126637';
    like $@@, qr/Modification of a read-only value/, '++*GLOB126637';
    eval 'my $y = --$_ for *GLOB126637';
    like $@@, qr/Modification of a read-only value/, '--*GLOB126637';
    eval 'my $y = $_++ for *GLOB126637';
    like $@@, qr/Modification of a read-only value/, '*GLOB126637++';
    eval 'my $y = $_-- for *GLOB126637';
    like $@@, qr/Modification of a read-only value/, '*GLOB126637--';

    use integer;

    eval 'my $y = ++$_ for *GLOB126637';
    like $@@, qr/Modification of a read-only value/, 'use int; ++*GLOB126637';
    eval 'my $y = --$_ for *GLOB126637';
    like $@@, qr/Modification of a read-only value/, 'use int; --*GLOB126637';
    eval 'my $y = $_++ for *GLOB126637';
    like $@@, qr/Modification of a read-only value/, 'use int; *GLOB126637++';
    eval 'my $y = $_-- for *GLOB126637';
    like $@@, qr/Modification of a read-only value/, 'use int; *GLOB126637--';
}
@


