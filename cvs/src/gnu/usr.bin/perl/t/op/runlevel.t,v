head	1.12;
access;
symbols
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.11.0.16
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.10
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.11.0.12
	OPENBSD_5_8_BASE:1.11
	PERL_5_20_2:1.1.1.9
	OPENBSD_5_7:1.11.0.4
	OPENBSD_5_7_BASE:1.11
	PERL_5_20_1:1.1.1.9
	OPENBSD_5_6:1.11.0.8
	OPENBSD_5_6_BASE:1.11
	PERL_5_18_2:1.1.1.9
	PERL:1.1.1
	OPENBSD_5_5:1.11.0.6
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.2
	OPENBSD_5_4_BASE:1.11
	PERL_5_16_3:1.1.1.9
	OPENBSD_5_3:1.10.0.10
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.8
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.6
	OPENBSD_5_0:1.10.0.4
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.2
	OPENBSD_4_9_BASE:1.10
	PERL_5_12_2:1.1.1.8
	OPENBSD_4_8:1.9.0.4
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.2
	OPENBSD_4_7_BASE:1.9
	PERL_5_10_1:1.1.1.7
	OPENBSD_4_6:1.8.0.6
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.2
	OPENBSD_4_5_BASE:1.8
	PERL_5_10_0:1.1.1.6
	OPENBSD_4_4:1.7.0.20
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.18
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.16
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.14
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.12
	OPENBSD_4_0_BASE:1.7
	PERL_5_8_8:1.1.1.5
	OPENBSD_3_9:1.7.0.10
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.8
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.6
	OPENBSD_3_7_BASE:1.7
	PERL_5_8_6:1.1.1.5
	OPENBSD_3_6:1.7.0.4
	OPENBSD_3_6_BASE:1.7
	PERL_5_8_5:1.1.1.5
	PERL_5_8_3:1.1.1.5
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.5
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	PERL_500503:1.1.1.1
	CPAN:1.1.1
	OPENBSD_2_5:1.1.0.6
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.4
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.2
	OPENBSD_2_3_BASE:1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.12
date	2017.02.05.00.32.20;	author afresh1;	state Exp;
branches;
next	1.11;
commitid	cxJ08BvJA9Pt2PTM;

1.11
date	2013.03.25.20.41.00;	author sthen;	state Exp;
branches;
next	1.10;

1.10
date	2010.09.24.15.07.09;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2009.10.12.18.30.28;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2008.09.29.17.36.20;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.49;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.37;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.36.22;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.02.07.17.51.05;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.06.17.08.31;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	99.04.29.22.52.38;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	97.11.30.08.05.41;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.29.22.41.51;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.04.06.16.10.51;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.05.24.18.25.46;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.27.22.15.11;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.12.03.02.44.32;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2008.09.29.17.19.01;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2009.10.12.18.10.45;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2010.09.24.14.49.16;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2013.03.25.20.09.36;	author sthen;	state Exp;
branches;
next	;


desc
@perl 5.004_04
@


1.12
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl

##
## Many of these tests are originally from Michael Schroeder
## <Michael.Schroeder@@informatik.uni-erlangen.de>
## Adapted and expanded by Gurusamy Sarathy <gsar@@activestate.com>
##

chdir 't' if -d 't';
@@INC = '../lib';
require './test.pl';

$|=1;

run_multiple_progs('', \*DATA);

done_testing();

__END__
@@a = (1, 2, 3);
{
  @@a = sort { last ; } @@a;
}
EXPECT
Can't "last" outside a loop block at - line 3.
########
package TEST;
 
sub TIESCALAR {
  my $foo;
  return bless \$foo;
}
sub FETCH {
  eval 'die("test")';
  print "still in fetch\n";
  return ">$@@<";
}
package main;
 
tie $bar, TEST;
print "- $bar\n";
EXPECT
still in fetch
- >test at (eval 1) line 1.
<
########
package TEST;
 
sub TIESCALAR {
  my $foo;
  eval('die("foo\n")');
  print "after eval\n";
  return bless \$foo;
}
sub FETCH {
  return "ZZZ";
}
 
package main;
 
tie $bar, TEST;
print "- $bar\n";
print "OK\n";
EXPECT
after eval
- ZZZ
OK
########
package TEST;
 
sub TIEHANDLE {
  my $foo;
  return bless \$foo;
}
sub PRINT {
print STDERR "PRINT CALLED\n";
(split(/./, 'x'x10000))[0];
eval('die("test\n")');
}
 
package main;
 
open FH, ">&STDOUT";
tie *FH, TEST;
print FH "OK\n";
print STDERR "DONE\n";
EXPECT
PRINT CALLED
DONE
########
sub warnhook {
  print "WARNHOOK\n";
  eval('die("foooo\n")');
}
$SIG{'__WARN__'} = 'warnhook';
warn("dfsds\n");
print "END\n";
EXPECT
WARNHOOK
END
########
package TEST;
 
use overload
     "\"\""   =>  \&str
;
 
sub str {
  eval('die("test\n")');
  return "STR";
}
 
package main;
 
$bar = bless {}, TEST;
print "$bar\n";
print "OK\n";
EXPECT
STR
OK
########
sub foo {
  $a <=> $b unless eval('$a == 0 ? bless undef : ($a <=> $b)');
}
@@a = (3, 2, 0, 1);
@@a = sort foo @@a;
print join(', ', @@a)."\n";
EXPECT
0, 1, 2, 3
########
sub foo {
  goto bar if $a == 0 || $b == 0;
  $a <=> $b;
}
@@a = (3, 2, 0, 1);
@@a = sort foo @@a;
print join(', ', @@a)."\n";
exit;
bar:
print "bar reached\n";
EXPECT
Can't "goto" out of a pseudo block at - line 2.
########
%seen = ();
sub sortfn {
  (split(/./, 'x'x10000))[0];
  my (@@y) = ( 4, 6, 5);
  @@y = sort { $a <=> $b } @@y;
  my $t = "sortfn ".join(', ', @@y)."\n";
  print $t if ($seen{$t}++ == 0);
  return $_[0] <=> $_[1];
}
@@x = ( 3, 2, 1 );
@@x = sort { &sortfn($a, $b) } @@x;
print "---- ".join(', ', @@x)."\n";
EXPECT
sortfn 4, 5, 6
---- 1, 2, 3
########
@@a = (3, 2, 1);
@@a = sort { eval('die("no way")') ,  $a <=> $b} @@a;
print join(", ", @@a)."\n";
EXPECT
1, 2, 3
########
@@a = (1, 2, 3);
foo:
{
  @@a = sort { last foo; } @@a;
}
EXPECT
Label not found for "last foo" at - line 4.
########
package TEST;
 
sub TIESCALAR {
  my $foo;
  return bless \$foo;
}
sub FETCH {
  next;
  return "ZZZ";
}
sub STORE {
}
 
package main;
 
tie $bar, TEST;
{
  print "- $bar\n";
}
print "OK\n";
EXPECT
Can't "next" outside a loop block at - line 8.
########
package TEST;
 
sub TIESCALAR {
  my $foo;
  return bless \$foo;
}
sub FETCH {
  goto bbb;
  return "ZZZ";
}
 
package main;
 
tie $bar, TEST;
print "- $bar\n";
exit;
bbb:
print "bbb\n";
EXPECT
Can't find label bbb at - line 8.
########
sub foo {
  $a <=> $b unless eval('$a == 0 ? die("foo\n") : ($a <=> $b)');
}
@@a = (3, 2, 0, 1);
@@a = sort foo @@a;
print join(', ', @@a)."\n";
EXPECT
0, 1, 2, 3
########
package TEST;
sub TIESCALAR {
  my $foo;
  return bless \$foo;
}
sub FETCH {
  return "fetch";
}
sub STORE {
(split(/./, 'x'x10000))[0];
}
package main;
tie $bar, TEST;
$bar = "x";
########
package TEST;
sub TIESCALAR {
  my $foo;
  next;
  return bless \$foo;
}
package main;
{
tie $bar, TEST;
}
EXPECT
Can't "next" outside a loop block at - line 4.
########
@@a = (1, 2, 3);
foo:
{
  @@a = sort { exit(0) } @@a;
}
END { print "foobar\n" }
EXPECT
foobar
########
$SIG{__DIE__} = sub {
    print "In DIE\n";
    $i = 0;
    while (($p,$f,$l,$s) = caller(++$i)) {
        print "$p|$f|$l|$s\n";
    }
};
eval { die };
&{sub { eval 'die' }}();
sub foo { eval { die } } foo();
{package rmb; sub{ eval{die} } ->() };	# check __ANON__ knows package	
EXPECT
In DIE
main|-|8|(eval)
In DIE
main|-|9|(eval)
main|-|9|main::__ANON__
In DIE
main|-|10|(eval)
main|-|10|main::foo
In DIE
rmb|-|11|(eval)
rmb|-|11|rmb::__ANON__
########
package TEST;
 
sub TIEARRAY {
  return bless [qw(foo fee fie foe)], $_[0];
}
sub FETCH {
  my ($s,$i) = @@_;
  if ($i) {
    goto bbb;
  }
bbb:
  return $s->[$i];
}
 
package main;
tie my @@bar, 'TEST';
print join('|', @@bar[0..3]), "\n"; 
EXPECT
foo|fee|fie|foe
########
package TH;
sub TIEHASH { bless {}, TH }
sub STORE { eval { print "@@_[1,2]\n" }; die "bar\n" }
tie %h, TH;
eval { $h{A} = 1; print "never\n"; };
print $@@;
eval { $h{B} = 2; };
print $@@;
EXPECT
A 1
bar
B 2
bar
########
sub n { 0 }
sub f { my $x = shift; d(); }
f(n());
f();

sub d {
    my $i = 0; my @@a;
    while (do { { package DB; @@a = caller($i++) } } ) {
        @@a = @@DB::args;
        for (@@a) { print "$_\n"; $_ = '' }
    }
}
EXPECT
0
########
sub TIEHANDLE { bless {} }
sub PRINT { next }

tie *STDERR, '';
{ map ++$_, 1 }

EXPECT
Can't "next" outside a loop block at - line 2.
########
sub TIEHANDLE { bless {} }
sub PRINT { print "[TIE] $_[1]" }

tie *STDERR, '';
die "DIE\n";

EXPECT
[TIE] DIE
########
sub TIEHANDLE { bless {} }
sub PRINT { 
    (split(/./, 'x'x10000))[0];
    eval('die("test\n")');
    warn "[TIE] $_[1]";
}
open OLDERR, '>&STDERR';
tie *STDERR, '';

use warnings FATAL => qw(uninitialized);
print undef;

EXPECT
[TIE] Use of uninitialized value in print at - line 11.
@


1.11
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d172 1
a172 1
Label not found for "last foo" at - line 2.
@


1.10
log
@merge in perl 5.12.2 plus local changes
@
text
@a11 4
$Is_VMS = $^O eq 'VMS';
$Is_MSWin32 = $^O eq 'MSWin32';
$Is_NetWare = $^O eq 'NetWare';
$ENV{PERL5LIB} = "../lib" unless $Is_VMS;
d15 1
a15 3
undef $/;
@@prgs = split "\n########\n", <DATA>;
print "1..", scalar @@prgs, "\n";
d17 1
a17 32
$tmpfile = tempfile();

for (@@prgs){
    my $switch = "";
    if (s/^\s*(-\w+)//){
       $switch = $1;
    }
    my($prog,$expected) = split(/\nEXPECT\n/, $_);
    open TEST, ">$tmpfile";
    print TEST "$prog\n";
    close TEST or die "Could not close: $!";
    my $results = $Is_VMS ?
                      `$^X "-I[-.lib]" $switch $tmpfile 2>&1` :
		  $Is_MSWin32 ?  
		      `.\\perl -I../lib $switch $tmpfile 2>&1` :
		  $Is_NetWare ?  
		      `perl -I../lib $switch $tmpfile 2>&1` :
		  `./perl $switch $tmpfile 2>&1`;
    my $status = $?;
    $results =~ s/\n+$//;
    # allow expected output to be written as if $prog is on STDIN
    $results =~ s/$::tempfile_regexp/-/ig;
    $results =~ s/\n%[A-Z]+-[SIWEF]-.*$// if $Is_VMS;  # clip off DCL status msg
    $expected =~ s/\n+$//;
    if ($results ne $expected) {
       print STDERR "PROG: $switch\n$prog\n";
       print STDERR "EXPECTED:\n$expected\n";
       print STDERR "GOT:\n$results\n";
       print "not ";
    }
    print "ok ", ++$i, "\n";
}
@


1.9
log
@Merge in perl 5.10.1; part two
@
text
@a14 1
$Is_MacOS = $^O eq 'MacOS';
a39 2
		  $Is_MacOS ?
		      `$^X -I::lib -MMac::err=unix $switch $tmpfile` :
@


1.8
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d11 1
d24 1
a24 3
$tmpfile = "runltmp000";
1 while -f ++$tmpfile;
END { if ($tmpfile) { 1 while unlink $tmpfile; } }
d47 1
a47 1
    $results =~ s/runltmp\d+/-/g;
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d37 1
a37 1
                      `MCR $^X "-I[-.lib]" $switch $tmpfile 2>&1` :
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d377 33
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d13 2
d35 1
a35 1
    close TEST;
d37 8
a44 4
                  `MCR $^X "-I[-.lib]" $switch $tmpfile 2>&1` :
		      $Is_MSWin32 ?  
			  `.\\perl -I../lib $switch $tmpfile 2>&1` :
			      `./perl $switch $tmpfile 2>&1`;
d185 1
d190 2
a191 1
  print "sortfn ".join(', ', @@y)."\n";
a198 2
sortfn 4, 5, 6
sortfn 4, 5, 6
d315 1
d325 3
@


1.4
log
@Change 6214 by gsar@@auger on 2000/06/08 13:57:54
    @@_ can't have junk in it even in the non-USE_ITHREADS case because
    caller() wants to populate @@DB::args with it (causes a coredump
    in Carp::confess())
@
text
@d10 1
a10 1
unshift @@INC, "../lib";
@


1.3
log
@perl-5.6.0 + local changes
@
text
@d352 15
@


1.2
log
@perl5.005_03 (stock)
@
text
@d6 1
a6 1
## Adapted and expanded by Gurusamy Sarathy <gsar@@umich.edu>
d10 1
a10 1
@@INC = "../lib";
d35 1
a35 1
		  `MCR $^X "-I[-.lib]" $switch $tmpfile` :
d38 1
a38 1
			      `sh -c './perl $switch $tmpfile' 2>&1`;
d60 1
a60 1
Can't "last" outside a block at - line 3.
d177 1
a177 1
Can't "goto" outside a block at - line 2.
d230 1
a230 1
Can't "next" outside a block at - line 8.
d288 1
a288 1
Can't "next" outside a block at - line 4.
d338 14
@


1.1
log
@perl 5.004_04
@
text
@d4 1
a4 1
## all of these tests are from Michael Schroeder
d6 1
a6 9
##
## The more esoteric failure modes require Michael's
## stack-of-stacks patch (so we don't test them here,
## and they are commented out before the __END__).
##
## The remaining tests pass with a simpler fix
## intended for 5.004
##
## Gurusamy Sarathy <gsar@@umich.edu> 97-02-24
d26 1
a26 1
    my $switch;
a53 132
=head2 stay out of here (the real tests are after __END__)

##
## these tests don't pass yet (need the full stack-of-stacks patch)
## GSAR 97-02-24
##

########
# sort within sort
sub sortfn {
  (split(/./, 'x'x10000))[0];
  my (@@y) = ( 4, 6, 5);
  @@y = sort { $a <=> $b } @@y;
  print "sortfn ".join(', ', @@y)."\n";
  return $_[0] <=> $_[1];
}
@@x = ( 3, 2, 1 );
@@x = sort { &sortfn($a, $b) } @@x;
print "---- ".join(', ', @@x)."\n";
EXPECT
sortfn 4, 5, 6
---- 1, 2, 3
########
# trapping eval within sort (doesn't work currently because
# die does a SWITCHSTACK())
@@a = (3, 2, 1);
@@a = sort { eval('die("no way")') ,  $a <=> $b} @@a;
print join(", ", @@a)."\n";
EXPECT
1, 2, 3
########
# this actually works fine, but results in a poor error message
@@a = (1, 2, 3);
foo:
{
  @@a = sort { last foo; } @@a;
}
EXPECT
cannot reach destination block at - line 2.
########
package TEST;
 
sub TIESCALAR {
  my $foo;
  return bless \$foo;
}
sub FETCH {
  next;
  return "ZZZ";
}
sub STORE {
}
 
package main;
 
tie $bar, TEST;
{
  print "- $bar\n";
}
print "OK\n";
EXPECT
cannot reach destination block at - line 8.
########
package TEST;
 
sub TIESCALAR {
  my $foo;
  return bless \$foo;
}
sub FETCH {
  goto bbb;
  return "ZZZ";
}
 
package main;
 
tie $bar, TEST;
print "- $bar\n";
exit;
bbb:
print "bbb\n";
EXPECT
bbb
########
# trapping eval within sort (doesn't work currently because
# die does a SWITCHSTACK())
sub foo {
  $a <=> $b unless eval('$a == 0 ? die("foo\n") : ($a <=> $b)');
}
@@a = (3, 2, 0, 1);
@@a = sort foo @@a;
print join(', ', @@a)."\n";
EXPECT
0, 1, 2, 3
########
package TEST;
sub TIESCALAR {
  my $foo;
  next;
  return bless \$foo;
}
package main;
{
tie $bar, TEST;
}
EXPECT
cannot reach destination block at - line 4.
########
# large stack extension causes realloc, and segfault
package TEST;
sub TIESCALAR {
  my $foo;
  return bless \$foo;
}
sub FETCH {
  return "fetch";
}
sub STORE {
(split(/./, 'x'x10000))[0];
}
package main;
tie $bar, TEST;
$bar = "x";

=cut

##
##
## The real tests begin here
##
##

d178 160
@


1.1.1.1
log
@perl5.005_03
@
text
@d4 1
a4 1
## Many of these tests are originally from Michael Schroeder
d6 9
a14 1
## Adapted and expanded by Gurusamy Sarathy <gsar@@umich.edu>
d34 1
a34 1
    my $switch = "";
d62 132
a317 160
########
sub sortfn {
  (split(/./, 'x'x10000))[0];
  my (@@y) = ( 4, 6, 5);
  @@y = sort { $a <=> $b } @@y;
  print "sortfn ".join(', ', @@y)."\n";
  return $_[0] <=> $_[1];
}
@@x = ( 3, 2, 1 );
@@x = sort { &sortfn($a, $b) } @@x;
print "---- ".join(', ', @@x)."\n";
EXPECT
sortfn 4, 5, 6
sortfn 4, 5, 6
sortfn 4, 5, 6
---- 1, 2, 3
########
@@a = (3, 2, 1);
@@a = sort { eval('die("no way")') ,  $a <=> $b} @@a;
print join(", ", @@a)."\n";
EXPECT
1, 2, 3
########
@@a = (1, 2, 3);
foo:
{
  @@a = sort { last foo; } @@a;
}
EXPECT
Label not found for "last foo" at - line 2.
########
package TEST;
 
sub TIESCALAR {
  my $foo;
  return bless \$foo;
}
sub FETCH {
  next;
  return "ZZZ";
}
sub STORE {
}
 
package main;
 
tie $bar, TEST;
{
  print "- $bar\n";
}
print "OK\n";
EXPECT
Can't "next" outside a block at - line 8.
########
package TEST;
 
sub TIESCALAR {
  my $foo;
  return bless \$foo;
}
sub FETCH {
  goto bbb;
  return "ZZZ";
}
 
package main;
 
tie $bar, TEST;
print "- $bar\n";
exit;
bbb:
print "bbb\n";
EXPECT
Can't find label bbb at - line 8.
########
sub foo {
  $a <=> $b unless eval('$a == 0 ? die("foo\n") : ($a <=> $b)');
}
@@a = (3, 2, 0, 1);
@@a = sort foo @@a;
print join(', ', @@a)."\n";
EXPECT
0, 1, 2, 3
########
package TEST;
sub TIESCALAR {
  my $foo;
  return bless \$foo;
}
sub FETCH {
  return "fetch";
}
sub STORE {
(split(/./, 'x'x10000))[0];
}
package main;
tie $bar, TEST;
$bar = "x";
########
package TEST;
sub TIESCALAR {
  my $foo;
  next;
  return bless \$foo;
}
package main;
{
tie $bar, TEST;
}
EXPECT
Can't "next" outside a block at - line 4.
########
@@a = (1, 2, 3);
foo:
{
  @@a = sort { exit(0) } @@a;
}
END { print "foobar\n" }
EXPECT
foobar
########
$SIG{__DIE__} = sub {
    print "In DIE\n";
    $i = 0;
    while (($p,$f,$l,$s) = caller(++$i)) {
        print "$p|$f|$l|$s\n";
    }
};
eval { die };
&{sub { eval 'die' }}();
sub foo { eval { die } } foo();
EXPECT
In DIE
main|-|8|(eval)
In DIE
main|-|9|(eval)
main|-|9|main::__ANON__
In DIE
main|-|10|(eval)
main|-|10|main::foo
########
package TEST;
 
sub TIEARRAY {
  return bless [qw(foo fee fie foe)], $_[0];
}
sub FETCH {
  my ($s,$i) = @@_;
  if ($i) {
    goto bbb;
  }
bbb:
  return $s->[$i];
}
 
package main;
tie my @@bar, 'TEST';
print join('|', @@bar[0..3]), "\n"; 
EXPECT
foo|fee|fie|foe
@


1.1.1.2
log
@virgin perl 5.6.0
@
text
@d6 1
a6 1
## Adapted and expanded by Gurusamy Sarathy <gsar@@activestate.com>
d10 1
a10 1
unshift @@INC, "../lib";
d35 1
a35 1
                  `MCR $^X "-I[-.lib]" $switch $tmpfile 2>&1` :
d38 1
a38 1
			      `./perl $switch $tmpfile 2>&1`;
d60 1
a60 1
Can't "last" outside a loop block at - line 3.
d177 1
a177 1
Can't "goto" out of a pseudo block at - line 2.
d230 1
a230 1
Can't "next" outside a loop block at - line 8.
d288 1
a288 1
Can't "next" outside a loop block at - line 4.
a337 14
########
package TH;
sub TIEHASH { bless {}, TH }
sub STORE { eval { print "@@_[1,2]\n" }; die "bar\n" }
tie %h, TH;
eval { $h{A} = 1; print "never\n"; };
print $@@;
eval { $h{B} = 2; };
print $@@;
EXPECT
A 1
bar
B 2
bar
@


1.1.1.3
log
@stock perl 5.6.1
@
text
@d10 1
a10 1
@@INC = '../lib';
a351 15
########
sub n { 0 }
sub f { my $x = shift; d(); }
f(n());
f();

sub d {
    my $i = 0; my @@a;
    while (do { { package DB; @@a = caller($i++) } } ) {
        @@a = @@DB::args;
        for (@@a) { print "$_\n"; $_ = '' }
    }
}
EXPECT
0
@


1.1.1.4
log
@stock perl 5.8.0 from CPAN
@
text
@a12 2
$Is_NetWare = $^O eq 'NetWare';
$Is_MacOS = $^O eq 'MacOS';
d33 1
a33 1
    close TEST or die "Could not close: $!";
d35 4
a38 8
                      `MCR $^X "-I[-.lib]" $switch $tmpfile 2>&1` :
		  $Is_MSWin32 ?  
		      `.\\perl -I../lib $switch $tmpfile 2>&1` :
		  $Is_NetWare ?  
		      `perl -I../lib $switch $tmpfile 2>&1` :
		  $Is_MacOS ?
		      `$^X -I::lib -MMac::err=unix $switch $tmpfile` :
		  `./perl $switch $tmpfile 2>&1`;
a178 1
%seen = ();
d183 1
a183 2
  my $t = "sortfn ".join(', ', @@y)."\n";
  print $t if ($seen{$t}++ == 0);
d191 2
a308 1
{package rmb; sub{ eval{die} } ->() };	# check __ANON__ knows package	
a317 3
In DIE
rmb|-|11|(eval)
rmb|-|11|rmb::__ANON__
@


1.1.1.5
log
@perl 5.8.2 from CPAN
@
text
@a376 33
########
sub TIEHANDLE { bless {} }
sub PRINT { next }

tie *STDERR, '';
{ map ++$_, 1 }

EXPECT
Can't "next" outside a loop block at - line 2.
########
sub TIEHANDLE { bless {} }
sub PRINT { print "[TIE] $_[1]" }

tie *STDERR, '';
die "DIE\n";

EXPECT
[TIE] DIE
########
sub TIEHANDLE { bless {} }
sub PRINT { 
    (split(/./, 'x'x10000))[0];
    eval('die("test\n")');
    warn "[TIE] $_[1]";
}
open OLDERR, '>&STDERR';
tie *STDERR, '';

use warnings FATAL => qw(uninitialized);
print undef;

EXPECT
[TIE] Use of uninitialized value in print at - line 11.
@


1.1.1.6
log
@import perl 5.10.0 from CPAN
@
text
@d37 1
a37 1
                      `$^X "-I[-.lib]" $switch $tmpfile 2>&1` :
@


1.1.1.7
log
@import perl 5.10.1
@
text
@a10 1
require './test.pl';
d23 3
a25 1
$tmpfile = tempfile();
d48 1
a48 1
    $results =~ s/$::tempfile_regexp/-/ig;
@


1.1.1.8
log
@Perl 5.12.2 from CPAN
@
text
@d15 1
d41 2
@


1.1.1.9
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d12 4
d19 3
a21 1
run_multiple_progs('', \*DATA);
d23 32
a54 1
done_testing();
@


