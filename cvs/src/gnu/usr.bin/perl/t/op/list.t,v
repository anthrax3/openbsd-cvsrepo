head	1.12;
access;
symbols
	OPENBSD_6_2:1.12.0.2
	OPENBSD_6_2_BASE:1.12
	PERL_5_24_2:1.1.1.10
	OPENBSD_6_1:1.12.0.4
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.11.0.8
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.2
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.11.0.4
	OPENBSD_5_8_BASE:1.11
	PERL_5_20_2:1.1.1.9
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	PERL_5_20_1:1.1.1.8
	OPENBSD_5_6:1.9.0.8
	OPENBSD_5_6_BASE:1.9
	PERL_5_18_2:1.1.1.7
	PERL:1.1.1
	OPENBSD_5_5:1.9.0.6
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.2
	OPENBSD_5_4_BASE:1.9
	PERL_5_16_3:1.1.1.7
	OPENBSD_5_3:1.8.0.10
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.8
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.6
	OPENBSD_5_0:1.8.0.4
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.2
	OPENBSD_4_9_BASE:1.8
	PERL_5_12_2:1.1.1.6
	OPENBSD_4_8:1.7.0.8
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.4
	OPENBSD_4_7_BASE:1.7
	PERL_5_10_1:1.1.1.5
	OPENBSD_4_6:1.7.0.6
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.2
	OPENBSD_4_5_BASE:1.7
	PERL_5_10_0:1.1.1.5
	OPENBSD_4_4:1.6.0.10
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.8
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.6
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.4
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.2
	OPENBSD_4_0_BASE:1.6
	PERL_5_8_8:1.1.1.4
	OPENBSD_3_9:1.5.0.6
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.4
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.2
	OPENBSD_3_7_BASE:1.5
	PERL_5_8_6:1.1.1.3
	OPENBSD_3_6:1.4.0.20
	OPENBSD_3_6_BASE:1.4
	PERL_5_8_5:1.1.1.2
	PERL_5_8_3:1.1.1.2
	OPENBSD_3_5:1.4.0.18
	OPENBSD_3_5_BASE:1.4
	PERL_5_8_2:1.1.1.2
	OPENBSD_3_4:1.4.0.16
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.4.0.14
	OPENBSD_3_3_BASE:1.4
	PERL_5_8_0:1.1.1.2
	OPENBSD_3_2:1.4.0.12
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.10
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.8
	OPENBSD_3_0_BASE:1.4
	PERL_5_6_1:1.1.1.2
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.1
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.12
date	2017.02.05.00.32.20;	author afresh1;	state Exp;
branches;
next	1.11;
commitid	cxJ08BvJA9Pt2PTM;

1.11
date	2015.04.25.19.14.48;	author afresh1;	state Exp;
branches;
next	1.10;
commitid	XRK22kO4se3v2i2I;

1.10
date	2014.11.17.20.57.07;	author afresh1;	state Exp;
branches;
next	1.9;
commitid	QP75iYx42Uo7mMxO;

1.9
date	2013.03.25.20.40.59;	author sthen;	state Exp;
branches;
next	1.8;

1.8
date	2010.09.24.15.07.08;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2008.09.29.17.36.19;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2006.03.28.19.23.12;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2005.01.15.21.30.40;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.08.25;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.52.36;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.08.05.26;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.13.19;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.13.19;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.04.06.16.10.49;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2005.01.15.21.18.18;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2006.03.28.18.49.45;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2008.09.29.17.19.01;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2010.09.24.14.49.17;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2013.03.25.20.09.36;	author sthen;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2014.11.17.20.53.18;	author afresh1;	state Exp;
branches;
next	1.1.1.9;
commitid	B31cAbBIXiCqnL97;

1.1.1.9
date	2015.04.25.19.10.47;	author afresh1;	state Exp;
branches;
next	1.1.1.10;
commitid	Wpcs5S8qILgEZC7F;

1.1.1.10
date	2017.08.14.13.46.24;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.12
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl

BEGIN {
    chdir 't' if -d 't';
    @@INC = qw(. ../lib);
    require "./test.pl";
}

plan( tests => 70 );

@@foo = (1, 2, 3, 4);
cmp_ok($foo[0], '==', 1, 'first elem');
cmp_ok($foo[3], '==', 4, 'last elem');

$_ = join(':',@@foo);
cmp_ok($_, 'eq', '1:2:3:4', 'join list');

($a,$b,$c,$d) = (1,2,3,4);
cmp_ok("$a;$b;$c;$d", 'eq', '1;2;3;4', 'list assign');

($c,$b,$a) = split(/ /,"111 222 333");
cmp_ok("$a;$b;$c",'eq','333;222;111','list split on space');

($a,$b,$c) = ($c,$b,$a);
cmp_ok("$a;$b;$c",'eq','111;222;333','trio rotate');

($a, $b) = ($b, $a);
cmp_ok("$a-$b",'eq','222-111','duo swap');

($a, $b) = ($b, $a) = ($a, $b);
cmp_ok("$a-$b",'eq','222-111','duo swap swap');

($a, $b[1], $c{2}, $d) = (1, 2, 3, 4);
cmp_ok($a,'==',1,'assign scalar in list');
cmp_ok($b[1],'==',2,'assign aelem in list');
cmp_ok($c{2},'==',3,'assign helem in list');
cmp_ok($d,'==',4,'assign last scalar in list');

@@foo = (1,2,3,4,5,6,7,8);
($a, $b, $c, $d) = @@foo;
cmp_ok("$a/$b/$c/$d",'eq','1/2/3/4','long list assign');

@@foo = (1,2);
($a, $b, $c, $d) = @@foo;
cmp_ok($a,'==',1,'short list 1 defined');
cmp_ok($b,'==',2,'short list 2 defined');
ok(!defined($c),'short list 3 undef');
ok(!defined($d),'short list 4 undef');

@@foo = @@bar = (1);
cmp_ok(join(':',@@foo,@@bar),'eq','1:1','list reassign');

@@foo = @@bar = (2,3);
cmp_ok(join(':',join('+',@@foo),join('-',@@bar)),'eq','2+3:2-3','long list reassign');

@@foo = ();
@@foo = 1+2+3;
cmp_ok(join(':',@@foo),'eq','6','scalar assign to array');

{
    my ($a, $b, $c);
    for ($x = 0; $x < 3; $x = $x + 1) {
        ($a, $b, $c) = 
              $x == 0 ?  ('a','b','c')
            : $x == 1 ?  ('d','e','f')
            :            ('g','h','i')
        ;
        if ($x == 0) {
            cmp_ok($a,'eq','a','ternary for a 1');
            cmp_ok($b,'eq','b','ternary for b 1');
            cmp_ok($c,'eq','c','ternary for c 1');
        }
        if ($x == 1) {
            cmp_ok($a,'eq','d','ternary for a 2');
            cmp_ok($b,'eq','e','ternary for b 2');
            cmp_ok($c,'eq','f','ternary for c 2');
        }
        if ($x == 2) {
            cmp_ok($a,'eq','g','ternary for a 3');
            cmp_ok($b,'eq','h','ternary for b 3');
            cmp_ok($c,'eq','i','ternary for c 3');
        }
    }
}

{
    my ($a, $b, $c);
    for ($x = 0; $x < 3; $x = $x + 1) {
        ($a, $b, $c) = do {
            if ($x == 0) {
                ('a','b','c');
            }
            elsif ($x == 1) {
                ('d','e','f');
            }
            else {
                ('g','h','i');
            }
        };
        if ($x == 0) {
            cmp_ok($a,'eq','a','block for a 1');
            cmp_ok($b,'eq','b','block for b 1');
            cmp_ok($c,'eq','c','block for c 1');
        }
        if ($x == 1) {
            cmp_ok($a,'eq','d','block for a 2');
            cmp_ok($b,'eq','e','block for b 2');
            cmp_ok($c,'eq','f','block for c 2');
        }
        if ($x == 2) {
            cmp_ok($a,'eq','g','block for a 3');
            cmp_ok($b,'eq','h','block for b 3');
            cmp_ok($c,'eq','i','block for c 3');
        }
    }
}

$x = 666;
@@a = ($x == 12345 || (1,2,3));
cmp_ok(join('*',@@a),'eq','1*2*3','logical or f');

@@a = ($x == $x || (4,5,6));
cmp_ok(join('*',@@a),'eq','1','logical or t');

cmp_ok(join('',1,2,(3,4,5)),'eq','12345','list ..(...)');
cmp_ok(join('',(1,2,3,4,5)),'eq','12345','list (.....)');
cmp_ok(join('',(1,2,3,4),5),'eq','12345','list (....).');
cmp_ok(join('',1,(2,3,4),5),'eq','12345','list .(...).');
cmp_ok(join('',1,2,(3,4),5),'eq','12345','list ..(..).');
cmp_ok(join('',1,2,3,(4),5),'eq','12345','list ...(.).');
cmp_ok(join('',(1,2),3,(4,5)),'eq','12345','list (..).(..)');

{
    my @@a = (0, undef, undef, 3);
    my @@b = @@a[1,2];
    my @@c = (0, undef, undef, 3)[1, 2];
    cmp_ok(scalar(@@b),'==',scalar(@@c),'slice and slice');
    cmp_ok(scalar(@@c),'==',2,'slice len');

    @@b = (29, scalar @@c[()]);
    cmp_ok(join(':',@@b),'eq','29:','slice ary nil');

    my %h = (a => 1);
    @@b = (30, scalar @@h{()});
    cmp_ok(join(':',@@b),'eq','30:','slice hash nil');

    my $size = scalar(()[1..1]);
    cmp_ok($size,'==','0','size nil');

    $size = scalar(()=((1,2,3,4,5)[()])[2,3,4]);
    is $size, 0, 'slice of empty list from complex expr is empty list';

    @@a = (1)[2,3,4];
    is "@@{[ map $_//'undef', @@a ]}", "undef undef undef",
       'slice beyond the end of non-empty list returns undefs';
}

{
    # perl #39882
    sub test_two_args {
        my $test_name = shift;
        is(scalar(@@_), 2, $test_name);
    }
    test_two_args("simple list slice",      (10,11)[2,3]);
    test_two_args("grepped list slice",     grep(1, (10,11)[2,3]));
    test_two_args("sorted list slice",      sort((10,11)[2,3]));
    test_two_args("assigned list slice",    my @@tmp = (10,11)[2,3]);
    test_two_args("do-returned list slice", do { (10,11)[2,3]; });
    test_two_args("list literal slice",     qw(a b)[2,3]);
    is (()=qw()[2,3], 0, "empty literal slice");
}

{
    # perl #20321
    is (join('', @@{[('abc'=~/./g)[0,1,2,1,0]]}), "abcba");
}

{
    is(join('', qw(a b c)[2,0,1]), "cab");
    my @@a = qw(a b c);
    is(join(":", @@a), "a:b:c");
    my @@b = qw();
    is($#b, -1);
}

{
    # comma operator with lvalue only propagates the lvalue context to
    # the last operand.
    ("const", my $x) ||= 1;
    is( $x, 1 );
}

# [perl #78194] list slice aliasing op return values
sub {
 is(\$_[0], \$_[1],
  '[perl #78194] \$_[0] == \$_[1] when @@_ aliases elems repeated by lslice'
 )
}
 ->(("${\''}")[0,0]);

# [perl #122995] Hang when compiling while(1) in a sub-list
# No ok() or is() necessary.
sub foo { () = ($a, my $b, ($c, do { while(1) {} })) }

# List assignment and OPpTARGET_MY
{
    my ($a,$b);
    my $foo = "foo";
    my $bar = "bar";
    ($a,$b) = ($b = $foo."", $a = $bar . "");
    is("$a,$b", "foo,bar", 'common vars check accounts for OPpTARGET_MY');
}

sub TIESCALAR {bless{}}
sub FETCH {$_[0]{fetched}++}
sub empty {}
tie $t, "";
() = (empty(), ($t)x10); # empty() since sub calls usually result in copies
is(tied($t)->{fetched}, undef, 'assignment to empty list makes no copies');

# this was passing a trash SV at the top of the stack to SvIV()
ok(($0[()[()]],1), "[perl #126193] list slice with zero indexes");
@


1.11
log
@Fix merge issues, remove excess files - match perl-5.20.2 dist
@
text
@d6 1
d9 1
a9 2
require "test.pl";
plan( tests => 65 );
d149 7
d160 1
a160 1
    sub test_zero_args {
d162 1
a162 1
        is(scalar(@@_), 0, $test_name);
d164 7
a170 7
    test_zero_args("simple list slice",      (10,11)[2,3]);
    test_zero_args("grepped list slice",     grep(1, (10,11)[2,3]));
    test_zero_args("sorted list slice",      sort((10,11)[2,3]));
    test_zero_args("assigned list slice",    my @@tmp = (10,11)[2,3]);
    test_zero_args("do-returned list slice", do { (10,11)[2,3]; });
    test_zero_args("list literal slice",     qw(a b)[2,3]);
    test_zero_args("empty literal slice",    qw()[2,3]);
d204 19
@


1.10
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d193 4
@


1.9
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d9 1
a9 1
plan( tests => 64 );
d185 8
@


1.8
log
@merge in perl 5.12.2 plus local changes
@
text
@d9 1
a9 1
plan( tests => 58 );
d162 2
d169 15
@


1.7
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d9 1
a9 1
plan( tests => 57 );
d164 4
@


1.6
log
@merge in perl 5.8.8
@
text
@d3 7
a9 1
print "1..31\n";
d12 2
a13 1
if ($foo[0] == 1 && $foo[3] == 4) {print "ok 1\n";} else {print "not ok 1\n";}
d16 1
a16 1
if ($_ eq '1:2:3:4') {print "ok 2\n";} else {print "not ok 2\n";}
d19 1
a19 1
if ("$a;$b;$c;$d" eq '1;2;3;4') {print "ok 3\n";} else {print "not ok 3\n";}
d22 1
a22 1
if ("$a;$b;$c" eq '333;222;111') {print "ok 4\n";} else {print "not ok 4\n";}
d25 1
a25 1
if ("$a;$b;$c" eq '111;222;333') {print "ok 5\n";} else {print "not ok 5 $a;$b;$c\n";}
d28 4
a31 1
if ("$a;$b;$c" eq '222;111;333') {print "ok 6\n";} else {print "not ok 6\n";}
d34 4
a37 4
if ($a eq 1) {print "ok 7\n";} else {print "not ok 7\n";}
if ($b[1] eq 2) {print "ok 8\n";} else {print "not ok 8\n";}
if ($c{2} eq 3) {print "ok 9\n";} else {print "not ok 9\n";}
if ($d eq 4) {print "ok 10\n";} else {print "not ok 10\n";}
d41 8
a48 2
print "#11	$a;$b;$c;$d eq 1;2;3;4\n";
if ("$a;$b;$c;$d" eq '1;2;3;4') {print "ok 11\n";} else {print "not ok 11\n";}
d51 4
a54 1
if (join(':',@@foo,@@bar) eq '1:1') {print "ok 12\n";} else {print "not ok 12\n";}
d58 1
a58 1
if (join(':',@@foo) eq '6') {print "ok 13\n";} else {print "not ok 13\n";}
d60 25
a84 8
for ($x = 0; $x < 3; $x++) {
    ($a, $b, $c) = 
	    $x == 0?
		    ('ok ', 14, "\n"):
	    $x == 1?
		    ('ok ', 15, "\n"):
	    # default
		    ('ok ', 16, "\n");
d86 30
a115 1
    print $a,$b,$c;
d118 1
d120 1
a120 1
if (join('',@@a) eq '123') {print "ok 17\n";} else {print "not ok 17\n";}
d123 1
a123 21
if (join('',@@a) eq '1') {print "ok 18\n";} else {print "not ok 18\n";}

if (join('',1,2,(3,4,5)) eq '12345'){print "ok 19\n";}else{print "not ok 19\n";}
if (join('',(1,2,3,4,5)) eq '12345'){print "ok 20\n";}else{print "not ok 20\n";}
if (join('',(1,2,3,4),5) eq '12345'){print "ok 21\n";}else{print "not ok 21\n";}
if (join('',1,(2,3,4),5) eq '12345'){print "ok 22\n";}else{print "not ok 22\n";}
if (join('',1,2,(3,4),5) eq '12345'){print "ok 23\n";}else{print "not ok 23\n";}
if (join('',1,2,3,(4),5) eq '12345'){print "ok 24\n";}else{print "not ok 24\n";}

for ($x = 0; $x < 3; $x++) {
    ($a, $b, $c) = do {
	    if ($x == 0) {
		('ok ', 25, "\n");
	    }
	    elsif ($x == 1) {
		('ok ', 26, "\n");
	    }
	    else {
		('ok ', 27, "\n");
	    }
	};
d125 7
a131 2
    print $a,$b,$c;
}
a132 1
# slices
d137 2
a138 2
    print "not " unless @@b == @@c and @@c == 2;
    print "ok 28\n";
d141 1
a141 2
    print "not " if join(':',@@b) ne '29:';
    print "ok 29\n";
d145 1
a145 2
    print "not " if join(':',@@b) ne '30:';
    print "ok 30\n";
d148 1
a148 2
    print "not " if $size != 0;
    print "ok 31\n";
d150 14
@


1.5
log
@sync in-tree perl with 5.8.6
@
text
@d3 1
a3 1
print "1..30\n";
d98 4
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d3 1
a3 1
print "1..28\n";
d89 9
@


1.3
log
@perl5.005_03 (stock)
@
text
@d3 1
a3 3
# $RCSfile: list.t,v $$Revision: 4.1 $$Date: 92/08/07 18:28:02 $

print "1..27\n";
d82 8
@


1.2
log
@perl 5.004_04
@
text
@@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@virgin perl 5.6.0
@
text
@d3 3
a5 1
print "1..28\n";
a83 8
# slices
{
    my @@a = (0, undef, undef, 3);
    my @@b = @@a[1,2];
    my @@c = (0, undef, undef, 3)[1, 2];
    print "not " unless @@b == @@c and @@c == 2;
    print "ok 28\n";
}
@


1.1.1.3
log
@perl 5.8.6 from CPAN
@
text
@d3 1
a3 1
print "1..30\n";
a88 9

    @@b = (29, scalar @@c[()]);
    print "not " if join(':',@@b) ne '29:';
    print "ok 29\n";

    my %h = (a => 1);
    @@b = (30, scalar @@h{()});
    print "not " if join(':',@@b) ne '30:';
    print "ok 30\n";
@


1.1.1.4
log
@perl 5.8.8 import
@
text
@d3 1
a3 1
print "1..31\n";
a97 4

    my $size = scalar(()[1..1]);
    print "not " if $size != 0;
    print "ok 31\n";
@


1.1.1.5
log
@import perl 5.10.0 from CPAN
@
text
@d3 1
a3 7
BEGIN {
    chdir 't' if -d 't';
    @@INC = qw(. ../lib);
}

require "test.pl";
plan( tests => 57 );
d6 1
a6 2
cmp_ok($foo[0], '==', 1, 'first elem');
cmp_ok($foo[3], '==', 4, 'last elem');
d9 1
a9 1
cmp_ok($_, 'eq', '1:2:3:4', 'join list');
d12 1
a12 1
cmp_ok("$a;$b;$c;$d", 'eq', '1;2;3;4', 'list assign');
d15 1
a15 1
cmp_ok("$a;$b;$c",'eq','333;222;111','list split on space');
d18 1
a18 1
cmp_ok("$a;$b;$c",'eq','111;222;333','trio rotate');
d21 1
a21 4
cmp_ok("$a-$b",'eq','222-111','duo swap');

($a, $b) = ($b, $a) = ($a, $b);
cmp_ok("$a-$b",'eq','222-111','duo swap swap');
d24 4
a27 4
cmp_ok($a,'==',1,'assign scalar in list');
cmp_ok($b[1],'==',2,'assign aelem in list');
cmp_ok($c{2},'==',3,'assign helem in list');
cmp_ok($d,'==',4,'assign last scalar in list');
d31 2
a32 8
cmp_ok("$a/$b/$c/$d",'eq','1/2/3/4','long list assign');

@@foo = (1,2);
($a, $b, $c, $d) = @@foo;
cmp_ok($a,'==',1,'short list 1 defined');
cmp_ok($b,'==',2,'short list 2 defined');
ok(!defined($c),'short list 3 undef');
ok(!defined($d),'short list 4 undef');
d35 1
a35 4
cmp_ok(join(':',@@foo,@@bar),'eq','1:1','list reassign');

@@foo = @@bar = (2,3);
cmp_ok(join(':',join('+',@@foo),join('-',@@bar)),'eq','2+3:2-3','long list reassign');
d39 1
a39 1
cmp_ok(join(':',@@foo),'eq','6','scalar assign to array');
d41 8
a48 25
{
    my ($a, $b, $c);
    for ($x = 0; $x < 3; $x = $x + 1) {
        ($a, $b, $c) = 
              $x == 0 ?  ('a','b','c')
            : $x == 1 ?  ('d','e','f')
            :            ('g','h','i')
        ;
        if ($x == 0) {
            cmp_ok($a,'eq','a','ternary for a 1');
            cmp_ok($b,'eq','b','ternary for b 1');
            cmp_ok($c,'eq','c','ternary for c 1');
        }
        if ($x == 1) {
            cmp_ok($a,'eq','d','ternary for a 2');
            cmp_ok($b,'eq','e','ternary for b 2');
            cmp_ok($c,'eq','f','ternary for c 2');
        }
        if ($x == 2) {
            cmp_ok($a,'eq','g','ternary for a 3');
            cmp_ok($b,'eq','h','ternary for b 3');
            cmp_ok($c,'eq','i','ternary for c 3');
        }
    }
}
d50 1
a50 30
{
    my ($a, $b, $c);
    for ($x = 0; $x < 3; $x = $x + 1) {
        ($a, $b, $c) = do {
            if ($x == 0) {
                ('a','b','c');
            }
            elsif ($x == 1) {
                ('d','e','f');
            }
            else {
                ('g','h','i');
            }
        };
        if ($x == 0) {
            cmp_ok($a,'eq','a','block for a 1');
            cmp_ok($b,'eq','b','block for b 1');
            cmp_ok($c,'eq','c','block for c 1');
        }
        if ($x == 1) {
            cmp_ok($a,'eq','d','block for a 2');
            cmp_ok($b,'eq','e','block for b 2');
            cmp_ok($c,'eq','f','block for c 2');
        }
        if ($x == 2) {
            cmp_ok($a,'eq','g','block for a 3');
            cmp_ok($b,'eq','h','block for b 3');
            cmp_ok($c,'eq','i','block for c 3');
        }
    }
a52 1
$x = 666;
d54 1
a54 1
cmp_ok(join('*',@@a),'eq','1*2*3','logical or f');
d57 21
a77 1
cmp_ok(join('*',@@a),'eq','1','logical or t');
d79 2
a80 7
cmp_ok(join('',1,2,(3,4,5)),'eq','12345','list ..(...)');
cmp_ok(join('',(1,2,3,4,5)),'eq','12345','list (.....)');
cmp_ok(join('',(1,2,3,4),5),'eq','12345','list (....).');
cmp_ok(join('',1,(2,3,4),5),'eq','12345','list .(...).');
cmp_ok(join('',1,2,(3,4),5),'eq','12345','list ..(..).');
cmp_ok(join('',1,2,3,(4),5),'eq','12345','list ...(.).');
cmp_ok(join('',(1,2),3,(4,5)),'eq','12345','list (..).(..)');
d82 1
d87 2
a88 2
    cmp_ok(scalar(@@b),'==',scalar(@@c),'slice and slice');
    cmp_ok(scalar(@@c),'==',2,'slice len');
d91 2
a92 1
    cmp_ok(join(':',@@b),'eq','29:','slice ary nil');
d96 2
a97 1
    cmp_ok(join(':',@@b),'eq','30:','slice hash nil');
d100 2
a101 1
    cmp_ok($size,'==','0','size nil');
a102 14

{
    # perl #39882
    sub test_zero_args {
        my $test_name = shift;
        is(scalar(@@_), 0, $test_name);
    }
    test_zero_args("simple list slice",      (10,11)[2,3]);
    test_zero_args("grepped list slice",     grep(1, (10,11)[2,3]));
    test_zero_args("sorted list slice",      sort((10,11)[2,3]));
    test_zero_args("assigned list slice",    my @@tmp = (10,11)[2,3]);
    test_zero_args("do-returned list slice", do { (10,11)[2,3]; });
}

@


1.1.1.6
log
@Perl 5.12.2 from CPAN
@
text
@d9 1
a9 1
plan( tests => 58 );
a163 4
{
    # perl #20321
    is (join('', @@{[('abc'=~/./g)[0,1,2,1,0]]}), "abcba");
}
@


1.1.1.7
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d9 1
a9 1
plan( tests => 64 );
a161 2
    test_zero_args("list literal slice",     qw(a b)[2,3]);
    test_zero_args("empty literal slice",    qw()[2,3]);
a166 15
}

{
    is(join('', qw(a b c)[2,0,1]), "cab");
    my @@a = qw(a b c);
    is(join(":", @@a), "a:b:c");
    my @@b = qw();
    is($#b, -1);
}

{
    # comma operator with lvalue only propagates the lvalue context to
    # the last operand.
    ("const", my $x) ||= 1;
    is( $x, 1 );
@


1.1.1.8
log
@Import perl-5.20.1
@
text
@d9 1
a9 1
plan( tests => 65 );
a184 8

# [perl #78194] list slice aliasing op return values
sub {
 is(\$_[0], \$_[1],
  '[perl #78194] \$_[0] == \$_[1] when @@_ aliases elems repeated by lslice'
 )
}
 ->(("${\''}")[0,0]);
@


1.1.1.9
log
@Import perl-5.20.2
@
text
@a192 4

# [perl #122995] Hang when compiling while(1) in a sub-list
# No ok() or is() necessary.
sub foo { () = ($a, my $b, ($c, do { while(1) {} })) }
@


1.1.1.10
log
@Import perl-5.24.2
@
text
@a5 1
    require "./test.pl";
d8 2
a9 1
plan( tests => 70 );
a148 7

    $size = scalar(()=((1,2,3,4,5)[()])[2,3,4]);
    is $size, 0, 'slice of empty list from complex expr is empty list';

    @@a = (1)[2,3,4];
    is "@@{[ map $_//'undef', @@a ]}", "undef undef undef",
       'slice beyond the end of non-empty list returns undefs';
d153 1
a153 1
    sub test_two_args {
d155 1
a155 1
        is(scalar(@@_), 2, $test_name);
d157 7
a163 7
    test_two_args("simple list slice",      (10,11)[2,3]);
    test_two_args("grepped list slice",     grep(1, (10,11)[2,3]));
    test_two_args("sorted list slice",      sort((10,11)[2,3]));
    test_two_args("assigned list slice",    my @@tmp = (10,11)[2,3]);
    test_two_args("do-returned list slice", do { (10,11)[2,3]; });
    test_two_args("list literal slice",     qw(a b)[2,3]);
    is (()=qw()[2,3], 0, "empty literal slice");
a196 19

# List assignment and OPpTARGET_MY
{
    my ($a,$b);
    my $foo = "foo";
    my $bar = "bar";
    ($a,$b) = ($b = $foo."", $a = $bar . "");
    is("$a,$b", "foo,bar", 'common vars check accounts for OPpTARGET_MY');
}

sub TIESCALAR {bless{}}
sub FETCH {$_[0]{fetched}++}
sub empty {}
tie $t, "";
() = (empty(), ($t)x10); # empty() since sub calls usually result in copies
is(tied($t)->{fetched}, undef, 'assignment to empty list makes no copies');

# this was passing a trash SV at the top of the stack to SvIV()
ok(($0[()[()]],1), "[perl #126193] list slice with zero indexes");
@


