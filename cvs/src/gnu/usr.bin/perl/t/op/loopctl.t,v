head	1.2;
access;
symbols
	OPENBSD_6_1:1.2.0.4
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.7.0.10
	OPENBSD_6_0_BASE:1.1.1.7
	OPENBSD_5_9:1.1.1.7.0.4
	OPENBSD_5_9_BASE:1.1.1.7
	OPENBSD_5_8:1.1.1.7.0.6
	OPENBSD_5_8_BASE:1.1.1.7
	PERL_5_20_2:1.1.1.7
	OPENBSD_5_7:1.1.1.7.0.2
	OPENBSD_5_7_BASE:1.1.1.7
	PERL_5_20_1:1.1.1.7
	OPENBSD_5_6:1.1.1.6.0.4
	OPENBSD_5_6_BASE:1.1.1.6
	PERL_5_18_2:1.1.1.6
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.5.0.6
	OPENBSD_5_5_BASE:1.1.1.5
	OPENBSD_5_4:1.1.1.5.0.2
	OPENBSD_5_4_BASE:1.1.1.5
	PERL_5_16_3:1.1.1.5
	OPENBSD_5_3:1.1.1.4.0.18
	OPENBSD_5_3_BASE:1.1.1.4
	OPENBSD_5_2:1.1.1.4.0.16
	OPENBSD_5_2_BASE:1.1.1.4
	OPENBSD_5_1_BASE:1.1.1.4
	OPENBSD_5_1:1.1.1.4.0.14
	OPENBSD_5_0:1.1.1.4.0.12
	OPENBSD_5_0_BASE:1.1.1.4
	OPENBSD_4_9:1.1.1.4.0.10
	OPENBSD_4_9_BASE:1.1.1.4
	PERL_5_12_2:1.1.1.4
	OPENBSD_4_8:1.1.1.4.0.8
	OPENBSD_4_8_BASE:1.1.1.4
	OPENBSD_4_7:1.1.1.4.0.4
	OPENBSD_4_7_BASE:1.1.1.4
	PERL_5_10_1:1.1.1.4
	OPENBSD_4_6:1.1.1.4.0.6
	OPENBSD_4_6_BASE:1.1.1.4
	OPENBSD_4_5:1.1.1.4.0.2
	OPENBSD_4_5_BASE:1.1.1.4
	PERL_5_10_0:1.1.1.4
	OPENBSD_4_4:1.1.1.3.0.10
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.8
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_2:1.1.1.3.0.6
	OPENBSD_4_2_BASE:1.1.1.3
	OPENBSD_4_1:1.1.1.3.0.4
	OPENBSD_4_1_BASE:1.1.1.3
	OPENBSD_4_0:1.1.1.3.0.2
	OPENBSD_4_0_BASE:1.1.1.3
	PERL_5_8_8:1.1.1.3
	OPENBSD_3_9:1.1.1.2.0.8
	OPENBSD_3_9_BASE:1.1.1.2
	OPENBSD_3_8:1.1.1.2.0.6
	OPENBSD_3_8_BASE:1.1.1.2
	OPENBSD_3_7:1.1.1.2.0.4
	OPENBSD_3_7_BASE:1.1.1.2
	PERL_5_8_6:1.1.1.2
	OPENBSD_3_6:1.1.1.2.0.2
	OPENBSD_3_6_BASE:1.1.1.2
	PERL_5_8_5:1.1.1.2
	PERL_5_8_3:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.6
	OPENBSD_3_5_BASE:1.1.1.1
	PERL_5_8_2:1.1.1.1
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	PERL_5_8_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.32.20;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2002.10.27.22.15.10;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.27.22.15.10;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.08.09.17.48.35;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2006.03.28.18.49.45;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2008.09.29.17.19.01;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.03.25.20.09.36;	author sthen;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2014.03.24.14.59.10;	author afresh1;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2014.11.17.20.53.18;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl

# We have the following types of loop:
#
# 1a)  while(A) {B}
# 1b)  B while A;
#
# 2a)  until(A) {B}
# 2b)  B until A;
#
# 3a)  for(@@A)  {B}
# 3b)  B for A;
#
# 4a)  for (A;B;C) {D}
#
# 5a)  { A }        # a bare block is a loop which runs once
#
# Loops of type (b) don't allow for next/last/redo style
#  control, so we ignore them here. Type (a) loops can
#  all be labelled, so there are ten possibilities (each
#  of 5 types, labelled/unlabelled). We therefore need
#  thirty tests to try the three control statements against
#  the ten types of loop. For the first four types it's useful
#  to distinguish the case where next re-iterates from the case
#  where it leaves the loop. That makes 38.
# All these tests rely on "last LABEL"
#  so if they've *all* failed, maybe you broke that...
#
# These tests are followed by an extra test of nested loops.
# Feel free to add more here.
#
#  -- .robin. <robin@@kitsite.com>  2001-03-13
BEGIN {
    chdir 't' if -d 't';
    @@INC = qw(. ../lib);
    require "./test.pl";
}

plan( tests => 67 );

my $ok;

TEST1: {

  $ok = 0;

  my $x = 1;
  my $first_time = 1;
  while($x--) {
    if (!$first_time) {
      $ok = 1;
      last TEST1;
    }
    $ok = 0;
    $first_time = 0;
    redo;
    last TEST1;
  }
  continue {
    $ok = 0;
    last TEST1;
  }
  $ok = 0;
}
cmp_ok($ok,'==',1,'no label on while()');

TEST2: {

  $ok = 0;

  my $x = 2;
  my $first_time = 1;
  my $been_in_continue = 0;
  while($x--) {
    if (!$first_time) {
      $ok = $been_in_continue;
      last TEST2;
    }
    $ok = 0;
    $first_time = 0;
    next;
    last TEST2;
  }
  continue {
    $been_in_continue = 1;
  }
  $ok = 0;
}
cmp_ok($ok,'==',1,'no label on while() successful next');

TEST3: {

  $ok = 0;

  my $x = 1;
  my $first_time = 1;
  my $been_in_loop = 0;
  my $been_in_continue = 0;
  while($x--) {
    $been_in_loop = 1;
    if (!$first_time) {
      $ok = 0;
      last TEST3;
    }
    $ok = 0;
    $first_time = 0;
    next;
    last TEST3;
  }
  continue {
    $been_in_continue = 1;
  }
  $ok = $been_in_loop && $been_in_continue;
}
cmp_ok($ok,'==',1,'no label on while() unsuccessful next');

TEST4: {

  $ok = 0;

  my $x = 1;
  my $first_time = 1;
  while($x++) {
    if (!$first_time) {
      $ok = 0;
      last TEST4;
    }
    $ok = 0;
    $first_time = 0;
    last;
    last TEST4;
  }
  continue {
    $ok = 0;
    last TEST4;
  }
  $ok = 1;
}
cmp_ok($ok,'==',1,'no label on while() last');

TEST5: {

  $ok = 0;

  my $x = 0;
  my $first_time = 1;
  until($x++) {
    if (!$first_time) {
      $ok = 1;
      last TEST5;
    }
    $ok = 0;
    $first_time = 0;
    redo;
    last TEST5;
  }
  continue {
    $ok = 0;
    last TEST5;
  }
  $ok = 0;
}
cmp_ok($ok,'==',1,'no label on until()');

TEST6: {

  $ok = 0;

  my $x = 0;
  my $first_time = 1;
  my $been_in_continue = 0;
  until($x++ >= 2) {
    if (!$first_time) {
      $ok = $been_in_continue;
      last TEST6;
    }
    $ok = 0;
    $first_time = 0;
    next;
    last TEST6;
  }
  continue {
    $been_in_continue = 1;
  }
  $ok = 0;
}
cmp_ok($ok,'==',1,'no label on until() successful next');

TEST7: {

  $ok = 0;

  my $x = 0;
  my $first_time = 1;
  my $been_in_loop = 0;
  my $been_in_continue = 0;
  until($x++) {
    $been_in_loop = 1;
    if (!$first_time) {
      $ok = 0;
      last TEST7;
    }
    $ok = 0;
    $first_time = 0;
    next;
    last TEST7;
  }
  continue {
    $been_in_continue = 1;
  }
  $ok = $been_in_loop && $been_in_continue;
}
cmp_ok($ok,'==',1,'no label on until() unsuccessful next');

TEST8: {

  $ok = 0;

  my $x = 0;
  my $first_time = 1;
  until($x++ == 10) {
    if (!$first_time) {
      $ok = 0;
      last TEST8;
    }
    $ok = 0;
    $first_time = 0;
    last;
    last TEST8;
  }
  continue {
    $ok = 0;
    last TEST8;
  }
  $ok = 1;
}
cmp_ok($ok,'==',1,'no label on until() last');

TEST9: {

  $ok = 0;

  my $first_time = 1;
  for(1) {
    if (!$first_time) {
      $ok = 1;
      last TEST9;
    }
    $ok = 0;
    $first_time = 0;
    redo;
    last TEST9;
  }
  continue {
    $ok = 0;
    last TEST9;
  }
  $ok = 0;
}
cmp_ok($ok,'==',1,'no label on for(@@array)');

TEST10: {

  $ok = 0;

  my $first_time = 1;
  my $been_in_continue = 0;
  for(1,2) {
    if (!$first_time) {
      $ok = $been_in_continue;
      last TEST10;
    }
    $ok = 0;
    $first_time = 0;
    next;
    last TEST10;
  }
  continue {
    $been_in_continue = 1;
  }
  $ok = 0;
}
cmp_ok($ok,'==',1,'no label on for(@@array) successful next');

TEST11: {

  $ok = 0;

  my $first_time = 1;
  my $been_in_loop = 0;
  my $been_in_continue = 0;
  for(1) {
    $been_in_loop = 1;
    if (!$first_time) {
      $ok = 0;
      last TEST11;
    }
    $ok = 0;
    $first_time = 0;
    next;
    last TEST11;
  }
  continue {
    $been_in_continue = 1;
  }
  $ok = $been_in_loop && $been_in_continue;
}
cmp_ok($ok,'==',1,'no label on for(@@array) unsuccessful next');

TEST12: {

  $ok = 0;

  my $first_time = 1;
  for(1..10) {
    if (!$first_time) {
      $ok = 0;
      last TEST12;
    }
    $ok = 0;
    $first_time = 0;
    last;
    last TEST12;
  }
  continue {
    $ok=0;
    last TEST12;
  }
  $ok = 1;
}
cmp_ok($ok,'==',1,'no label on for(@@array) last');

TEST13: {

  $ok = 0;

  for(my $first_time = 1; 1;) {
    if (!$first_time) {
      $ok = 1;
      last TEST13;
    }
    $ok = 0;
    $first_time=0;

    redo;
    last TEST13;
  }
  $ok = 0;
}
cmp_ok($ok,'==',1,'no label on for(;;)');

TEST14: {

  $ok = 0;

  for(my $first_time = 1; 1; $first_time=0) {
    if (!$first_time) {
      $ok = 1;
      last TEST14;
    }
    $ok = 0;
    next;
    last TEST14;
  }
  $ok = 0;
}
cmp_ok($ok,'==',1,'no label on for(;;) successful next');

TEST15: {

  $ok = 0;

  my $x=1;
  my $been_in_loop = 0;
  for(my $first_time = 1; $x--;) {
    $been_in_loop = 1;
    if (!$first_time) {
      $ok = 0;
      last TEST15;
    }
    $ok = 0;
    $first_time = 0;
    next;
    last TEST15;
  }
  $ok = $been_in_loop;
}
cmp_ok($ok,'==',1,'no label on for(;;) unsuccessful next');

TEST16: {

  $ok = 0;

  for(my $first_time = 1; 1; last TEST16) {
    if (!$first_time) {
      $ok = 0;
      last TEST16;
    }
    $ok = 0;
    $first_time = 0;
    last;
    last TEST16;
  }
  $ok = 1;
}
cmp_ok($ok,'==',1,'no label on for(;;) last');

TEST17: {

  $ok = 0;
  my $first_time = 1;

  {
    if (!$first_time) {
      $ok = 1;
      last TEST17;
    }
    $ok = 0;
    $first_time=0;

    redo;
    last TEST17;
  }
  continue {
    $ok = 0;
    last TEST17;
  }
  $ok = 0;
}
cmp_ok($ok,'==',1,'no label on bare block');

TEST18: {

  $ok = 0;
  {
    next;
    last TEST18;
  }
  continue {
    $ok = 1;
    last TEST18;
  }
  $ok = 0;
}
cmp_ok($ok,'==',1,'no label on bare block next');

TEST19: {

  $ok = 0;
  {
    last;
    last TEST19;
  }
  continue {
    $ok = 0;
    last TEST19;
  }
  $ok = 1;
}
cmp_ok($ok,'==',1,'no label on bare block last');

### Now do it all again with labels

TEST20: {

  $ok = 0;

  my $x = 1;
  my $first_time = 1;
  LABEL20: while($x--) {
    if (!$first_time) {
      $ok = 1;
      last TEST20;
    }
    $ok = 0;
    $first_time = 0;
    redo LABEL20;
    last TEST20;
  }
  continue {
    $ok = 0;
    last TEST20;
  }
  $ok = 0;
}
cmp_ok($ok,'==',1,'label on while()');

TEST21: {

  $ok = 0;

  my $x = 2;
  my $first_time = 1;
  my $been_in_continue = 0;
  LABEL21: while($x--) {
    if (!$first_time) {
      $ok = $been_in_continue;
      last TEST21;
    }
    $ok = 0;
    $first_time = 0;
    next LABEL21;
    last TEST21;
  }
  continue {
    $been_in_continue = 1;
  }
  $ok = 0;
}
cmp_ok($ok,'==',1,'label on while() successful next');

TEST22: {

  $ok = 0;

  my $x = 1;
  my $first_time = 1;
  my $been_in_loop = 0;
  my $been_in_continue = 0;
  LABEL22: while($x--) {
    $been_in_loop = 1;
    if (!$first_time) {
      $ok = 0;
      last TEST22;
    }
    $ok = 0;
    $first_time = 0;
    next LABEL22;
    last TEST22;
  }
  continue {
    $been_in_continue = 1;
  }
  $ok = $been_in_loop && $been_in_continue;
}
cmp_ok($ok,'==',1,'label on while() unsuccessful next');

TEST23: {

  $ok = 0;

  my $x = 1;
  my $first_time = 1;
  LABEL23: while($x++) {
    if (!$first_time) {
      $ok = 0;
      last TEST23;
    }
    $ok = 0;
    $first_time = 0;
    last LABEL23;
    last TEST23;
  }
  continue {
    $ok = 0;
    last TEST23;
  }
  $ok = 1;
}
cmp_ok($ok,'==',1,'label on while() last');

TEST24: {

  $ok = 0;

  my $x = 0;
  my $first_time = 1;
  LABEL24: until($x++) {
    if (!$first_time) {
      $ok = 1;
      last TEST24;
    }
    $ok = 0;
    $first_time = 0;
    redo LABEL24;
    last TEST24;
  }
  continue {
    $ok = 0;
    last TEST24;
  }
  $ok = 0;
}
cmp_ok($ok,'==',1,'label on until()');

TEST25: {

  $ok = 0;

  my $x = 0;
  my $first_time = 1;
  my $been_in_continue = 0;
  LABEL25: until($x++ >= 2) {
    if (!$first_time) {
      $ok = $been_in_continue;
      last TEST25;
    }
    $ok = 0;
    $first_time = 0;
    next LABEL25;
    last TEST25;
  }
  continue {
    $been_in_continue = 1;
  }
  $ok = 0;
}
cmp_ok($ok,'==',1,'label on until() successful next');

TEST26: {

  $ok = 0;

  my $x = 0;
  my $first_time = 1;
  my $been_in_loop = 0;
  my $been_in_continue = 0;
  LABEL26: until($x++) {
    $been_in_loop = 1;
    if (!$first_time) {
      $ok = 0;
      last TEST26;
    }
    $ok = 0;
    $first_time = 0;
    next LABEL26;
    last TEST26;
  }
  continue {
    $been_in_continue = 1;
  }
  $ok = $been_in_loop && $been_in_continue;
}
cmp_ok($ok,'==',1,'label on until() unsuccessful next');

TEST27: {

  $ok = 0;

  my $x = 0;
  my $first_time = 1;
  LABEL27: until($x++ == 10) {
    if (!$first_time) {
      $ok = 0;
      last TEST27;
    }
    $ok = 0;
    $first_time = 0;
    last LABEL27;
    last TEST27;
  }
  continue {
    $ok = 0;
    last TEST8;
  }
  $ok = 1;
}
cmp_ok($ok,'==',1,'label on until() last');

TEST28: {

  $ok = 0;

  my $first_time = 1;
  LABEL28: for(1) {
    if (!$first_time) {
      $ok = 1;
      last TEST28;
    }
    $ok = 0;
    $first_time = 0;
    redo LABEL28;
    last TEST28;
  }
  continue {
    $ok = 0;
    last TEST28;
  }
  $ok = 0;
}
cmp_ok($ok,'==',1,'label on for(@@array)');

TEST29: {

  $ok = 0;

  my $first_time = 1;
  my $been_in_continue = 0;
  LABEL29: for(1,2) {
    if (!$first_time) {
      $ok = $been_in_continue;
      last TEST29;
    }
    $ok = 0;
    $first_time = 0;
    next LABEL29;
    last TEST29;
  }
  continue {
    $been_in_continue = 1;
  }
  $ok = 0;
}
cmp_ok($ok,'==',1,'label on for(@@array) successful next');

TEST30: {

  $ok = 0;

  my $first_time = 1;
  my $been_in_loop = 0;
  my $been_in_continue = 0;
  LABEL30: for(1) {
    $been_in_loop = 1;
    if (!$first_time) {
      $ok = 0;
      last TEST30;
    }
    $ok = 0;
    $first_time = 0;
    next LABEL30;
    last TEST30;
  }
  continue {
    $been_in_continue = 1;
  }
  $ok = $been_in_loop && $been_in_continue;
}
cmp_ok($ok,'==',1,'label on for(@@array) unsuccessful next');

TEST31: {

  $ok = 0;

  my $first_time = 1;
  LABEL31: for(1..10) {
    if (!$first_time) {
      $ok = 0;
      last TEST31;
    }
    $ok = 0;
    $first_time = 0;
    last LABEL31;
    last TEST31;
  }
  continue {
    $ok=0;
    last TEST31;
  }
  $ok = 1;
}
cmp_ok($ok,'==',1,'label on for(@@array) last');

TEST32: {

  $ok = 0;

  LABEL32: for(my $first_time = 1; 1;) {
    if (!$first_time) {
      $ok = 1;
      last TEST32;
    }
    $ok = 0;
    $first_time=0;

    redo LABEL32;
    last TEST32;
  }
  $ok = 0;
}
cmp_ok($ok,'==',1,'label on for(;;)');

TEST33: {

  $ok = 0;

  LABEL33: for(my $first_time = 1; 1; $first_time=0) {
    if (!$first_time) {
      $ok = 1;
      last TEST33;
    }
    $ok = 0;
    next LABEL33;
    last TEST33;
  }
  $ok = 0;
}
cmp_ok($ok,'==',1,'label on for(;;) successful next');

TEST34: {

  $ok = 0;

  my $x=1;
  my $been_in_loop = 0;
  LABEL34: for(my $first_time = 1; $x--;) {
    $been_in_loop = 1;
    if (!$first_time) {
      $ok = 0;
      last TEST34;
    }
    $ok = 0;
    $first_time = 0;
    next LABEL34;
    last TEST34;
  }
  $ok = $been_in_loop;
}
cmp_ok($ok,'==',1,'label on for(;;) unsuccessful next');

TEST35: {

  $ok = 0;

  LABEL35: for(my $first_time = 1; 1; last TEST16) {
    if (!$first_time) {
      $ok = 0;
      last TEST35;
    }
    $ok = 0;
    $first_time = 0;
    last LABEL35;
    last TEST35;
  }
  $ok = 1;
}
cmp_ok($ok,'==',1,'label on for(;;) last');

TEST36: {

  $ok = 0;
  my $first_time = 1;

  LABEL36: {
    if (!$first_time) {
      $ok = 1;
      last TEST36;
    }
    $ok = 0;
    $first_time=0;

    redo LABEL36;
    last TEST36;
  }
  continue {
    $ok = 0;
    last TEST36;
  }
  $ok = 0;
}
cmp_ok($ok,'==',1,'label on bare block');

TEST37: {

  $ok = 0;
  LABEL37: {
    next LABEL37;
    last TEST37;
  }
  continue {
    $ok = 1;
    last TEST37;
  }
  $ok = 0;
}
cmp_ok($ok,'==',1,'label on bare block next');

TEST38: {

  $ok = 0;
  LABEL38: {
    last LABEL38;
    last TEST38;
  }
  continue {
    $ok = 0;
    last TEST38;
  }
  $ok = 1;
}
cmp_ok($ok,'==',1,'label on bare block last');

TEST39: {
    $ok = 0;
    my ($x, $y, $z) = (1,1,1);
    one39: while ($x--) {
      $ok = 0;
      two39: while ($y--) {
        $ok = 0;
        three39: while ($z--) {
           next two39;
        }
        continue {
          $ok = 0;
          last TEST39;
        }
      }
      continue {
        $ok = 1;
        last TEST39;
      }
      $ok = 0;
    }
}
cmp_ok($ok,'==',1,'nested constructs');

sub test_last_label { last TEST40 }

TEST40: {
    $ok = 1;
    test_last_label();
    $ok = 0;
}
cmp_ok($ok,'==',1,'dynamically scoped label');

sub test_last { last }

TEST41: {
    $ok = 1;
    test_last();
    $ok = 0;
}
cmp_ok($ok,'==',1,'dynamically scoped');


# [perl #27206] Memory leak in continue loop
# Ensure that the temporary object is freed each time round the loop,
# rather then all 10 of them all being freed right at the end

{
    my $n=10; my $late_free = 0;
    sub X::DESTROY { $late_free++ if $n < 0 };
    {
	($n-- && bless {}, 'X') && redo;
    }
    cmp_ok($late_free,'==',0,"bug 27206: redo memory leak");

    $n = 10; $late_free = 0;
    {
	($n-- && bless {}, 'X') && redo;
    }
    continue { }
    cmp_ok($late_free,'==',0,"bug 27206: redo with continue memory leak");
}

# ensure that redo doesn't clear a lexical declared in the condition

{
    my $i = 1;
    while (my $x = $i) {
	$i++;
	redo if $i == 2;
	cmp_ok($x,'==',1,"while/redo lexical life");
	last;
    }
    $i = 1;
    until (! (my $x = $i)) {
	$i++;
	redo if $i == 2;
	cmp_ok($x,'==',1,"until/redo lexical life");
	last;
    }
    for ($i = 1; my $x = $i; ) {
	$i++;
	redo if $i == 2;
	cmp_ok($x,'==',1,"for/redo lexical life");
	last;
    }

}

{
    $a37725[3] = 1; # use package var
    $i = 2;
    for my $x (reverse @@a37725) {
	$x = $i++;
    }
    cmp_ok("@@a37725",'eq',"5 4 3 2",'bug 37725: reverse with empty slots bug');
}

# [perl #21469] bad things happened with for $x (...) { *x = *y }

{
    my $i = 1;
    $x_21469  = 'X';
    $y1_21469 = 'Y1';
    $y2_21469 = 'Y2';
    $y3_21469 = 'Y3';
    for $x_21469 (1,2,3) {
	is($x_21469, $i, "bug 21469: correct at start of loop $i");
	*x_21469 = (*y1_21469, *y2_21469, *y3_21469)[$i-1];
	is($x_21469, "Y$i", "bug 21469: correct at tail of loop $i");
	$i++;
    }
    is($x_21469, 'X', "bug 21469: X okay at end of loop");
}

# [perl #112316] Wrong behavior regarding labels with same prefix
{
    my $fail;
    CATCH: {
    CATCHLOOP: {
            last CATCH;
        }
        $fail = 1;
    }
    ok(!$fail, "perl 112316: Labels with the same prefix don't get mixed up.");
}

# [perl #73618]
{
    sub foo_73618_0 {
        while (0) { }
    }
    sub bar_73618_0 {
        my $i = 0;
        while ($i) { }
    }
    sub foo_73618_undef {
        while (undef) { }
    }
    sub bar_73618_undef {
        my $i = undef;
        while ($i) { }
    }
    sub foo_73618_emptystring {
        while ("") { }
    }
    sub bar_73618_emptystring {
        my $i = "";
        while ($i) { }
    }
    sub foo_73618_0float {
        while (0.0) { }
    }
    sub bar_73618_0float {
        my $i = 0.0;
        while ($i) { }
    }
    sub foo_73618_0string {
        while ("0") { }
    }
    sub bar_73618_0string {
        my $i = "0";
        while ($i) { }
    }
    sub foo_73618_until {
        until (1) { }
    }
    sub bar_73618_until {
        my $i = 1;
        until ($i) { }
    }

    is(scalar(foo_73618_0()), scalar(bar_73618_0()),
       "constant optimization doesn't change return value");
    is(scalar(foo_73618_undef()), scalar(bar_73618_undef()),
       "constant optimization doesn't change return value");
    is(scalar(foo_73618_emptystring()), scalar(bar_73618_emptystring()),
       "constant optimization doesn't change return value");
    is(scalar(foo_73618_0float()), scalar(bar_73618_0float()),
       "constant optimization doesn't change return value");
    is(scalar(foo_73618_0string()), scalar(bar_73618_0string()),
       "constant optimization doesn't change return value");
    { local $TODO = "until is still wrongly optimized";
    is(scalar(foo_73618_until()), scalar(bar_73618_until()),
       "constant optimization doesn't change return value");
    }
}

# [perl #113684]
last_113684:
{
    label1:
    {
        my $label = "label1";
        eval { last $label };
        fail("last with non-constant label");
        last last_113684;
    }
    pass("last with non-constant label");
}
next_113684:
{
    label2:
    {
        my $label = "label2";
        eval { next $label };
        fail("next with non-constant label");
        next next_113684;
    }
    pass("next with non-constant label");
}
redo_113684:
{
    my $count;
    label3:
    {
        if ($count++) {
            pass("redo with non-constant label"); last redo_113684
        }
        my $label = "label3";
        eval { redo $label };
        fail("redo with non-constant label");
    }
}

# [perl #3112]
# The original report, which produced a Bizarre copy
@@a  = ();
eval {
    for (1) {
        push @@a, last;
    }
};
is @@a, 0, 'push @@a, last;  does not push';
is $@@, "", 'no error, either';
# And my japh, which relied on the misbehaviour
is do{{&{sub{"Just another Perl hacker,\n"}},last}}, undef,
  'last returns nothing';
@


1.1
log
@Initial revision
@
text
@d33 5
d39 1
a39 1
print "1..41\n";
d43 1
a43 3
## while() loop without a label

TEST1: { # redo
d65 1
a65 1
print ($ok ? "ok 1\n" : "not ok 1\n");
d67 1
a67 1
TEST2: { # next (succesful)
d89 1
a89 1
print ($ok ? "ok 2\n" : "not ok 2\n");
d91 1
a91 1
TEST3: { # next (unsuccesful)
d115 1
a115 1
print ($ok ? "ok 3\n" : "not ok 3\n");
d117 1
a117 1
TEST4: { # last
d139 1
a139 2
print ($ok ? "ok 4\n" : "not ok 4\n");

d141 1
a141 3
## until() loop without a label

TEST5: { # redo
d163 1
a163 1
print ($ok ? "ok 5\n" : "not ok 5\n");
d165 1
a165 1
TEST6: { # next (succesful)
d187 1
a187 1
print ($ok ? "ok 6\n" : "not ok 6\n");
d189 1
a189 1
TEST7: { # next (unsuccesful)
d213 1
a213 1
print ($ok ? "ok 7\n" : "not ok 7\n");
d215 1
a215 1
TEST8: { # last
d237 1
a237 3
print ($ok ? "ok 8\n" : "not ok 8\n");

## for(@@array) loop without a label
d239 1
a239 1
TEST9: { # redo
d260 1
a260 1
print ($ok ? "ok 9\n" : "not ok 9\n");
d262 1
a262 1
TEST10: { # next (succesful)
d283 1
a283 1
print ($ok ? "ok 10\n" : "not ok 10\n");
d285 1
a285 1
TEST11: { # next (unsuccesful)
d308 1
a308 1
print ($ok ? "ok 11\n" : "not ok 11\n");
d310 1
a310 1
TEST12: { # last
d331 1
a331 3
print ($ok ? "ok 12\n" : "not ok 12\n");

## for(;;) loop without a label
d333 1
a333 1
TEST13: { # redo
d350 1
a350 1
print ($ok ? "ok 13\n" : "not ok 13\n");
d352 1
a352 1
TEST14: { # next (successful)
d367 1
a367 1
print ($ok ? "ok 14\n" : "not ok 14\n");
d369 1
a369 1
TEST15: { # next (unsuccesful)
d388 1
a388 1
print ($ok ? "ok 15\n" : "not ok 15\n");
d390 1
a390 1
TEST16: { # last
d406 1
a406 1
print ($ok ? "ok 16\n" : "not ok 16\n");
d408 1
a408 3
## bare block without a label

TEST17: { # redo
d430 1
a430 1
print ($ok ? "ok 17\n" : "not ok 17\n");
d432 1
a432 1
TEST18: { # next
d445 1
a445 1
print ($ok ? "ok 18\n" : "not ok 18\n");
d447 1
a447 1
TEST19: { # last
d460 1
a460 2
print ($ok ? "ok 19\n" : "not ok 19\n");

d464 1
a464 3
## while() loop with a label

TEST20: { # redo
d486 1
a486 1
print ($ok ? "ok 20\n" : "not ok 20\n");
d488 1
a488 1
TEST21: { # next (succesful)
d510 1
a510 1
print ($ok ? "ok 21\n" : "not ok 21\n");
d512 1
a512 1
TEST22: { # next (unsuccesful)
d536 1
a536 1
print ($ok ? "ok 22\n" : "not ok 22\n");
d538 1
a538 1
TEST23: { # last
d560 1
a560 1
print ($ok ? "ok 23\n" : "not ok 23\n");
d562 1
a562 4

## until() loop with a label

TEST24: { # redo
d584 1
a584 1
print ($ok ? "ok 24\n" : "not ok 24\n");
d586 1
a586 1
TEST25: { # next (succesful)
d608 1
a608 1
print ($ok ? "ok 25\n" : "not ok 25\n");
d610 1
a610 1
TEST26: { # next (unsuccesful)
d634 1
a634 1
print ($ok ? "ok 26\n" : "not ok 26\n");
d636 1
a636 1
TEST27: { # last
d658 1
a658 3
print ($ok ? "ok 27\n" : "not ok 27\n");

## for(@@array) loop with a label
d660 1
a660 1
TEST28: { # redo
d681 1
a681 1
print ($ok ? "ok 28\n" : "not ok 28\n");
d683 1
a683 1
TEST29: { # next (succesful)
d704 1
a704 1
print ($ok ? "ok 29\n" : "not ok 29\n");
d706 1
a706 1
TEST30: { # next (unsuccesful)
d729 1
a729 1
print ($ok ? "ok 30\n" : "not ok 30\n");
d731 1
a731 1
TEST31: { # last
d752 1
a752 1
print ($ok ? "ok 31\n" : "not ok 31\n");
d754 1
a754 3
## for(;;) loop with a label

TEST32: { # redo
d771 1
a771 1
print ($ok ? "ok 32\n" : "not ok 32\n");
d773 1
a773 1
TEST33: { # next (successful)
d788 1
a788 1
print ($ok ? "ok 33\n" : "not ok 33\n");
d790 1
a790 1
TEST34: { # next (unsuccesful)
d809 1
a809 1
print ($ok ? "ok 34\n" : "not ok 34\n");
d811 1
a811 1
TEST35: { # last
d827 1
a827 3
print ($ok ? "ok 35\n" : "not ok 35\n");

## bare block with a label
d829 1
a829 1
TEST36: { # redo
d851 1
a851 1
print ($ok ? "ok 36\n" : "not ok 36\n");
d853 1
a853 1
TEST37: { # next
d866 1
a866 1
print ($ok ? "ok 37\n" : "not ok 37\n");
d868 1
a868 1
TEST38: { # last
d881 1
a881 3
print ($ok ? "ok 38\n" : "not ok 38\n");

### Now test nested constructs
d905 1
a905 4
print ($ok ? "ok 39\n" : "not ok 39\n");


### Test that loop control is dynamicly scoped.
d914 1
a914 1
print ($ok ? "ok 40\n" : "not ok 40\n");
d923 198
a1120 1
print ($ok ? "ok 41\n" : "not ok 41\n");
@


1.1.1.1
log
@stock perl 5.8.0 from CPAN
@
text
@@


1.1.1.2
log
@Import of stock perl 5.8.5
@
text
@d34 1
a34 1
print "1..43\n";
a946 23


# [perl #27206] Memory leak in continue loop
# Ensure that the temporary object is freed each time round the loop,
# rather then all 10 of them all being freed right at the end

{
    my $n=10; my $late_free = 0;
    sub X::DESTROY { $late_free++ if $n < 0 };
    {
	($n-- && bless {}, 'X') && redo;
    }
    print $late_free ? "not " : "", "ok 42 - redo memory leak\n";

    $n = 10; $late_free = 0;
    {
	($n-- && bless {}, 'X') && redo;
    }
    continue { }
    print $late_free ? "not " : "", "ok 43 - redo with continue memory leak\n";
}


@


1.1.1.3
log
@perl 5.8.8 import
@
text
@d34 1
a34 1
print "1..44\n";
a968 13


{
    # [perl #37725]

    $a37725[3] = 1; # use package var
    $i = 2;
    for my $x (reverse @@a37725) {
	$x = $i++;
    }
    print "@@a37725" == "5 4 3 2" ? "" : "not ",
	"ok 44 - reverse with empty slots (@@a37725)\n";
}
@


1.1.1.4
log
@import perl 5.10.0 from CPAN
@
text
@a32 4
BEGIN {
    chdir 't' if -d 't';
    @@INC = qw(. ../lib);
}
d34 1
a34 2
require "test.pl";
plan( tests => 47 );
d38 3
a40 1
TEST1: {
d62 1
a62 1
cmp_ok($ok,'==',1,'no label on while()');
d64 1
a64 1
TEST2: {
d86 1
a86 1
cmp_ok($ok,'==',1,'no label on while() successful next');
d88 1
a88 1
TEST3: {
d112 1
a112 1
cmp_ok($ok,'==',1,'no label on while() unsuccessful next');
d114 1
a114 1
TEST4: {
d136 2
a137 1
cmp_ok($ok,'==',1,'no label on while() last');
d139 3
a141 1
TEST5: {
d163 1
a163 1
cmp_ok($ok,'==',1,'no label on until()');
d165 1
a165 1
TEST6: {
d187 1
a187 1
cmp_ok($ok,'==',1,'no label on until() successful next');
d189 1
a189 1
TEST7: {
d213 1
a213 1
cmp_ok($ok,'==',1,'no label on until() unsuccessful next');
d215 1
a215 1
TEST8: {
d237 3
a239 1
cmp_ok($ok,'==',1,'no label on until() last');
d241 1
a241 1
TEST9: {
d262 1
a262 1
cmp_ok($ok,'==',1,'no label on for(@@array)');
d264 1
a264 1
TEST10: {
d285 1
a285 1
cmp_ok($ok,'==',1,'no label on for(@@array) successful next');
d287 1
a287 1
TEST11: {
d310 1
a310 1
cmp_ok($ok,'==',1,'no label on for(@@array) unsuccessful next');
d312 1
a312 1
TEST12: {
d333 3
a335 1
cmp_ok($ok,'==',1,'no label on for(@@array) last');
d337 1
a337 1
TEST13: {
d354 1
a354 1
cmp_ok($ok,'==',1,'no label on for(;;)');
d356 1
a356 1
TEST14: {
d371 1
a371 1
cmp_ok($ok,'==',1,'no label on for(;;) successful next');
d373 1
a373 1
TEST15: {
d392 1
a392 1
cmp_ok($ok,'==',1,'no label on for(;;) unsuccessful next');
d394 1
a394 1
TEST16: {
d410 1
a410 1
cmp_ok($ok,'==',1,'no label on for(;;) last');
d412 3
a414 1
TEST17: {
d436 1
a436 1
cmp_ok($ok,'==',1,'no label on bare block');
d438 1
a438 1
TEST18: {
d451 1
a451 1
cmp_ok($ok,'==',1,'no label on bare block next');
d453 1
a453 1
TEST19: {
d466 2
a467 1
cmp_ok($ok,'==',1,'no label on bare block last');
d471 3
a473 1
TEST20: {
d495 1
a495 1
cmp_ok($ok,'==',1,'label on while()');
d497 1
a497 1
TEST21: {
d519 1
a519 1
cmp_ok($ok,'==',1,'label on while() successful next');
d521 1
a521 1
TEST22: {
d545 1
a545 1
cmp_ok($ok,'==',1,'label on while() unsuccessful next');
d547 1
a547 1
TEST23: {
d569 4
a572 1
cmp_ok($ok,'==',1,'label on while() last');
d574 1
a574 1
TEST24: {
d596 1
a596 1
cmp_ok($ok,'==',1,'label on until()');
d598 1
a598 1
TEST25: {
d620 1
a620 1
cmp_ok($ok,'==',1,'label on until() successful next');
d622 1
a622 1
TEST26: {
d646 1
a646 1
cmp_ok($ok,'==',1,'label on until() unsuccessful next');
d648 1
a648 1
TEST27: {
d670 1
a670 1
cmp_ok($ok,'==',1,'label on until() last');
d672 3
a674 1
TEST28: {
d695 1
a695 1
cmp_ok($ok,'==',1,'label on for(@@array)');
d697 1
a697 1
TEST29: {
d718 1
a718 1
cmp_ok($ok,'==',1,'label on for(@@array) successful next');
d720 1
a720 1
TEST30: {
d743 1
a743 1
cmp_ok($ok,'==',1,'label on for(@@array) unsuccessful next');
d745 1
a745 1
TEST31: {
d766 3
a768 1
cmp_ok($ok,'==',1,'label on for(@@array) last');
d770 1
a770 1
TEST32: {
d787 1
a787 1
cmp_ok($ok,'==',1,'label on for(;;)');
d789 1
a789 1
TEST33: {
d804 1
a804 1
cmp_ok($ok,'==',1,'label on for(;;) successful next');
d806 1
a806 1
TEST34: {
d825 1
a825 1
cmp_ok($ok,'==',1,'label on for(;;) unsuccessful next');
d827 1
a827 1
TEST35: {
d843 3
a845 1
cmp_ok($ok,'==',1,'label on for(;;) last');
d847 1
a847 1
TEST36: {
d869 1
a869 1
cmp_ok($ok,'==',1,'label on bare block');
d871 1
a871 1
TEST37: {
d884 1
a884 1
cmp_ok($ok,'==',1,'label on bare block next');
d886 1
a886 1
TEST38: {
d899 3
a901 1
cmp_ok($ok,'==',1,'label on bare block last');
d925 4
a928 1
cmp_ok($ok,'==',1,'nested constructs');
d937 1
a937 1
cmp_ok($ok,'==',1,'dynamically scoped label');
d946 1
a946 1
cmp_ok($ok,'==',1,'dynamically scoped');
d959 1
a959 1
    cmp_ok($late_free,'==',0,"bug 27206: redo memory leak");
d966 1
a966 1
    cmp_ok($late_free,'==',0,"bug 27206: redo with continue memory leak");
d969 1
a969 1
# ensure that redo doesn't clear a lexical declared in the condition
d972 1
a972 20
    my $i = 1;
    while (my $x = $i) {
	$i++;
	redo if $i == 2;
	cmp_ok($x,'==',1,"while/redo lexical life");
	last;
    }
    $i = 1;
    until (! (my $x = $i)) {
	$i++;
	redo if $i == 2;
	cmp_ok($x,'==',1,"until/redo lexical life");
	last;
    }
    for ($i = 1; my $x = $i; ) {
	$i++;
	redo if $i == 2;
	cmp_ok($x,'==',1,"for/redo lexical life");
	last;
    }
a973 3
}

{
d979 2
a980 1
    cmp_ok("@@a37725",'eq',"5 4 3 2",'bug 27725: reverse with empty slots bug');
@


1.1.1.5
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d39 1
a39 1
plan( tests => 55 );
a980 28
# [perl #21469] bad things happened with for $x (...) { *x = *y }

{
    my $i = 1;
    $x_21469  = 'X';
    $y1_21469 = 'Y1';
    $y2_21469 = 'Y2';
    $y3_21469 = 'Y3';
    for $x_21469 (1,2,3) {
	is($x_21469, $i, "bug 21469: correct at start of loop $i");
	*x_21469 = (*y1_21469, *y2_21469, *y3_21469)[$i-1];
	is($x_21469, "Y$i", "bug 21469: correct at tail of loop $i");
	$i++;
    }
    is($x_21469, 'X', "bug 21469: X okay at end of loop");
}

# [perl #112316] Wrong behavior regarding labels with same prefix
{
    my $fail;
    CATCH: {
    CATCHLOOP: {
            last CATCH;
        }
        $fail = 1;
    }
    ok(!$fail, "perl 112316: Labels with the same prefix don't get mixed up.");
}
@


1.1.1.6
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d39 1
a39 1
plan( tests => 64 );
a1007 98
}

# [perl #73618]
{
    sub foo_73618_0 {
        while (0) { }
    }
    sub bar_73618_0 {
        my $i = 0;
        while ($i) { }
    }
    sub foo_73618_undef {
        while (undef) { }
    }
    sub bar_73618_undef {
        my $i = undef;
        while ($i) { }
    }
    sub foo_73618_emptystring {
        while ("") { }
    }
    sub bar_73618_emptystring {
        my $i = "";
        while ($i) { }
    }
    sub foo_73618_0float {
        while (0.0) { }
    }
    sub bar_73618_0float {
        my $i = 0.0;
        while ($i) { }
    }
    sub foo_73618_0string {
        while ("0") { }
    }
    sub bar_73618_0string {
        my $i = "0";
        while ($i) { }
    }
    sub foo_73618_until {
        until (1) { }
    }
    sub bar_73618_until {
        my $i = 1;
        until ($i) { }
    }

    is(scalar(foo_73618_0()), scalar(bar_73618_0()),
       "constant optimization doesn't change return value");
    is(scalar(foo_73618_undef()), scalar(bar_73618_undef()),
       "constant optimization doesn't change return value");
    is(scalar(foo_73618_emptystring()), scalar(bar_73618_emptystring()),
       "constant optimization doesn't change return value");
    is(scalar(foo_73618_0float()), scalar(bar_73618_0float()),
       "constant optimization doesn't change return value");
    is(scalar(foo_73618_0string()), scalar(bar_73618_0string()),
       "constant optimization doesn't change return value");
    { local $TODO = "until is still wrongly optimized";
    is(scalar(foo_73618_until()), scalar(bar_73618_until()),
       "constant optimization doesn't change return value");
    }
}

# [perl #113684]
last_113684:
{
    label1:
    {
        my $label = "label1";
        eval { last $label };
        fail("last with non-constant label");
        last last_113684;
    }
    pass("last with non-constant label");
}
next_113684:
{
    label2:
    {
        my $label = "label2";
        eval { next $label };
        fail("next with non-constant label");
        next next_113684;
    }
    pass("next with non-constant label");
}
redo_113684:
{
    my $count;
    label3:
    {
        if ($count++) {
            pass("redo with non-constant label"); last redo_113684
        }
        my $label = "label3";
        eval { redo $label };
        fail("redo with non-constant label");
    }
@


1.1.1.7
log
@Import perl-5.20.1
@
text
@a35 1
    require "test.pl";
d38 2
a39 1
plan( tests => 67 );
a1106 14

# [perl #3112]
# The original report, which produced a Bizarre copy
@@a  = ();
eval {
    for (1) {
        push @@a, last;
    }
};
is @@a, 0, 'push @@a, last;  does not push';
is $@@, "", 'no error, either';
# And my japh, which relied on the misbehaviour
is do{{&{sub{"Just another Perl hacker,\n"}},last}}, undef,
  'last returns nothing';
@


