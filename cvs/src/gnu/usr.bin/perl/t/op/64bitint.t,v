head	1.2;
access;
symbols
	OPENBSD_6_2:1.2.0.6
	OPENBSD_6_2_BASE:1.2
	PERL_5_24_2:1.1.1.6
	OPENBSD_6_1:1.2.0.4
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.5.0.16
	OPENBSD_6_0_BASE:1.1.1.5
	OPENBSD_5_9:1.1.1.5.0.10
	OPENBSD_5_9_BASE:1.1.1.5
	OPENBSD_5_8:1.1.1.5.0.12
	OPENBSD_5_8_BASE:1.1.1.5
	PERL_5_20_2:1.1.1.5
	OPENBSD_5_7:1.1.1.5.0.4
	OPENBSD_5_7_BASE:1.1.1.5
	PERL_5_20_1:1.1.1.5
	OPENBSD_5_6:1.1.1.5.0.8
	OPENBSD_5_6_BASE:1.1.1.5
	PERL_5_18_2:1.1.1.5
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.5.0.6
	OPENBSD_5_5_BASE:1.1.1.5
	OPENBSD_5_4:1.1.1.5.0.2
	OPENBSD_5_4_BASE:1.1.1.5
	PERL_5_16_3:1.1.1.5
	OPENBSD_5_3:1.1.1.4.0.10
	OPENBSD_5_3_BASE:1.1.1.4
	OPENBSD_5_2:1.1.1.4.0.8
	OPENBSD_5_2_BASE:1.1.1.4
	OPENBSD_5_1_BASE:1.1.1.4
	OPENBSD_5_1:1.1.1.4.0.6
	OPENBSD_5_0:1.1.1.4.0.4
	OPENBSD_5_0_BASE:1.1.1.4
	OPENBSD_4_9:1.1.1.4.0.2
	OPENBSD_4_9_BASE:1.1.1.4
	PERL_5_12_2:1.1.1.4
	OPENBSD_4_8:1.1.1.3.0.32
	OPENBSD_4_8_BASE:1.1.1.3
	OPENBSD_4_7:1.1.1.3.0.28
	OPENBSD_4_7_BASE:1.1.1.3
	PERL_5_10_1:1.1.1.3
	OPENBSD_4_6:1.1.1.3.0.30
	OPENBSD_4_6_BASE:1.1.1.3
	OPENBSD_4_5:1.1.1.3.0.26
	OPENBSD_4_5_BASE:1.1.1.3
	PERL_5_10_0:1.1.1.3
	OPENBSD_4_4:1.1.1.3.0.24
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.22
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_2:1.1.1.3.0.20
	OPENBSD_4_2_BASE:1.1.1.3
	OPENBSD_4_1:1.1.1.3.0.18
	OPENBSD_4_1_BASE:1.1.1.3
	OPENBSD_4_0:1.1.1.3.0.16
	OPENBSD_4_0_BASE:1.1.1.3
	PERL_5_8_8:1.1.1.3
	OPENBSD_3_9:1.1.1.3.0.14
	OPENBSD_3_9_BASE:1.1.1.3
	OPENBSD_3_8:1.1.1.3.0.12
	OPENBSD_3_8_BASE:1.1.1.3
	OPENBSD_3_7:1.1.1.3.0.10
	OPENBSD_3_7_BASE:1.1.1.3
	PERL_5_8_6:1.1.1.3
	OPENBSD_3_6:1.1.1.3.0.8
	OPENBSD_3_6_BASE:1.1.1.3
	PERL_5_8_5:1.1.1.3
	PERL_5_8_3:1.1.1.3
	OPENBSD_3_5:1.1.1.3.0.6
	OPENBSD_3_5_BASE:1.1.1.3
	PERL_5_8_2:1.1.1.3
	OPENBSD_3_4:1.1.1.3.0.4
	OPENBSD_3_4_BASE:1.1.1.3
	OPENBSD_3_3:1.1.1.3.0.2
	OPENBSD_3_3_BASE:1.1.1.3
	PERL_5_8_0:1.1.1.3
	OPENBSD_3_2:1.1.1.2.0.6
	OPENBSD_3_2_BASE:1.1.1.2
	OPENBSD_3_1:1.1.1.2.0.4
	OPENBSD_3_1_BASE:1.1.1.2
	OPENBSD_3_0:1.1.1.2.0.2
	OPENBSD_3_0_BASE:1.1.1.2
	PERL_5_6_1:1.1.1.2
	OPENBSD_2_9:1.1.1.1.0.6
	OPENBSD_2_9_BASE:1.1.1.1
	OPENBSD_2_8:1.1.1.1.0.4
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.2
	OPENBSD_2_7_BASE:1.1.1.1
	PERL_5_6_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.32.20;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2000.04.06.16.10.47;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.04.06.16.10.47;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.05.24.18.25.32;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.10.27.22.15.10;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2010.09.24.14.49.18;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.03.25.20.09.35;	author sthen;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2017.08.14.13.46.23;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl

BEGIN {
    chdir 't' if -d 't';
    @@INC = '../lib';
    require './test.pl';
    eval { my $q = pack "q", 0 };
    skip_all('no 64-bit types') if $@@;
}

# This could use many more tests.

# so that using > 0xfffffff constants and
# 32+ bit integers don't cause noise
use warnings;
no warnings qw(overflow portable);
use Config;

# as 6 * 6 = 36, the last digit of 6**n will always be six. Hence the last
# digit of 16**n will always be six. Hence 16**n - 1 will always end in 5.
# Assumption is that UVs will always be a multiple of 4 bits long.

my $UV_max = ~0;
die "UV_max eq '$UV_max', doesn't end in 5; your UV isn't 4n bits long :-(."
  unless $UV_max =~ /5$/;
my $UV_max_less3 = $UV_max - 3;
my $maths_preserves_UVs = $UV_max_less3 =~ /^\d+2$/;   # 5 - 3 is 2.
if ($maths_preserves_UVs) {
  print "# This perl's maths preserves all bits of a UV.\n";
} else {
  print "# This perl's maths does not preserve all bits of a UV.\n";
}

my $q = 12345678901;
my $r = 23456789012;
my $f = 0xffffffff;
my $x;
my $y;

$x = unpack "q", pack "q", $q;
cmp_ok($x, '==', $q);
cmp_ok($x, '>', $f);


$x = sprintf("%lld", 12345678901);
is($x, $q);
cmp_ok($x, '>', $f);

$x = sprintf("%lld", $q);
cmp_ok($x, '==', $q);
is($x, $q);
cmp_ok($x, '>', $f);

$x = sprintf("%Ld", $q);
cmp_ok($x, '==', $q);
is($x, $q);
cmp_ok($x, '>', $f);

$x = sprintf("%qd", $q);
cmp_ok($x, '==', $q);
is($x, $q);
cmp_ok($x, '>', $f);


$x = sprintf("%llx", $q);
cmp_ok(hex $x, '==', 0x2dfdc1c35);
cmp_ok(hex $x, '>', $f);

$x = sprintf("%Lx", $q);
cmp_ok(hex $x, '==', 0x2dfdc1c35);
cmp_ok(hex $x, '>', $f);

$x = sprintf("%qx", $q);
cmp_ok(hex $x, '==', 0x2dfdc1c35);
cmp_ok(hex $x, '>', $f);

$x = sprintf("%llo", $q);
cmp_ok(oct "0$x", '==', 0133767016065);
cmp_ok(oct $x, '>', $f);

$x = sprintf("%Lo", $q);
cmp_ok(oct "0$x", '==', 0133767016065);
cmp_ok(oct $x, '>', $f);

$x = sprintf("%qo", $q);
cmp_ok(oct "0$x", '==', 0133767016065);
cmp_ok(oct $x, '>', $f);

$x = sprintf("%llb", $q);
cmp_ok(oct "0b$x", '==', 0b1011011111110111000001110000110101);
cmp_ok(oct "0b$x", '>', $f);

$x = sprintf("%Lb", $q);
cmp_ok(oct "0b$x", '==', 0b1011011111110111000001110000110101);
cmp_ok(oct "0b$x", '>', $f);

$x = sprintf("%qb", $q);
cmp_ok(oct "0b$x", '==', 0b1011011111110111000001110000110101);
cmp_ok(oct "0b$x", '>', $f);


$x = sprintf("%llu", $q);
is($x, $q);
cmp_ok($x, '>', $f);

$x = sprintf("%Lu", $q);
cmp_ok($x, '==', $q);
is($x, $q);
cmp_ok($x, '>', $f);

$x = sprintf("%qu", $q);
cmp_ok($x, '==', $q);
is($x, $q);
cmp_ok($x, '>', $f);


$x = sprintf("%D", $q);
cmp_ok($x, '==', $q);
is($x, $q);
cmp_ok($x, '>', $f);

$x = sprintf("%U", $q);
cmp_ok($x, '==', $q);
is($x, $q);
cmp_ok($x, '>', $f);

$x = sprintf("%O", $q);
cmp_ok(oct $x, '==', $q);
cmp_ok(oct $x, '>', $f);


$x = $q + $r;
cmp_ok($x, '==', 35802467913);
cmp_ok($x, '>', $f);

$x = $q - $r;
cmp_ok($x, '==', -11111110111);
cmp_ok(-$x, '>', $f);

SKIP: {
    # Unicos has imprecise doubles (14 decimal digits or so),
    # especially if operating near the UV/IV limits the low-order bits
    # become mangled even by simple arithmetic operations.
    skip('too imprecise numbers on unicos') if $^O eq 'unicos';

    $x = $q * 1234567;
    cmp_ok($x, '==', 15241567763770867);
    cmp_ok($x, '>', $f);

    $x /= 1234567;
    cmp_ok($x, '==', $q);
    cmp_ok($x, '>', $f);

    $x = 98765432109 % 12345678901;
    cmp_ok($x, '==', 901);

    # The following 12 tests adapted from op/inc.

    $a = 9223372036854775807;
    $c = $a++;
    cmp_ok($a, '==', 9223372036854775808);

    $a = 9223372036854775807;
    $c = ++$a;
    cmp_ok($a, '==', 9223372036854775808);
    cmp_ok($c, '==', $a);

    $a = 9223372036854775807;
    $c = $a + 1;
    cmp_ok($a, '==', 9223372036854775807);
    cmp_ok($c, '==', 9223372036854775808);

    $a = -9223372036854775808;
    {
	no warnings 'imprecision';
	$c = $a--;
    }
    cmp_ok($a, '==', -9223372036854775809);
    cmp_ok($c, '==', -9223372036854775808);

    $a = -9223372036854775808;
    {
	no warnings 'imprecision';
	$c = --$a;
    }
    cmp_ok($a, '==', -9223372036854775809);
    cmp_ok($c, '==', $a);

    $a = -9223372036854775808;
    $c = $a - 1;
    cmp_ok($a, '==', -9223372036854775808);
    cmp_ok($c, '==', -9223372036854775809);

    $a = 9223372036854775808;
    $a = -$a;
    {
	no warnings 'imprecision';
	$c = $a--;
    }
    cmp_ok($a, '==', -9223372036854775809);
    cmp_ok($c, '==', -9223372036854775808);

    $a = 9223372036854775808;
    $a = -$a;
    {
	no warnings 'imprecision';
	$c = --$a;
    }
    cmp_ok($a, '==', -9223372036854775809);
    cmp_ok($c, '==', $a);

    $a = 9223372036854775808;
    $a = -$a;
    $c = $a - 1;
    cmp_ok($a, '==', -9223372036854775808);
    cmp_ok($c, '==', -9223372036854775809);

    $a = 9223372036854775808;
    $b = -$a;
    {
	no warnings 'imprecision';
	$c = $b--;
    }
    cmp_ok($b, '==', -$a-1);
    cmp_ok($c, '==', -$a);

    $a = 9223372036854775808;
    $b = -$a;
    {
	no warnings 'imprecision';
	$c = --$b;
    }
    cmp_ok($b, '==', -$a-1);
    cmp_ok($c, '==', $b);

    $a = 9223372036854775808;
    $b = -$a;
    $b = $b - 1;
    cmp_ok($b, '==', -(++$a));
}


$x = '';
cmp_ok((vec($x, 1, 64) = $q), '==', $q);

cmp_ok(vec($x, 1, 64), '==', $q);
cmp_ok(vec($x, 1, 64), '>', $f);

cmp_ok(vec($x, 0, 64), '==', 0);
cmp_ok(vec($x, 2, 64), '==', 0);

cmp_ok(~0, '==', 0xffffffffffffffff);

cmp_ok((0xffffffff<<32), '==', 0xffffffff00000000);

cmp_ok(((0xffffffff)<<32)>>32, '==', 0xffffffff);

cmp_ok(1<<63, '==', 0x8000000000000000);

is((sprintf "%#Vx", 1<<63), '0x8000000000000000');

cmp_ok((0x8000000000000000 | 1), '==', 0x8000000000000001);

cmp_ok((0xf000000000000000 & 0x8000000000000000), '==', 0x8000000000000000);
cmp_ok((0xf000000000000000 ^ 0xfffffffffffffff0), '==', 0x0ffffffffffffff0);


is((sprintf "%b", ~0),
   '1111111111111111111111111111111111111111111111111111111111111111');


is((sprintf "%64b", ~0),
   '1111111111111111111111111111111111111111111111111111111111111111');

is((sprintf "%d", ~0>>1),'9223372036854775807');
is((sprintf "%u", ~0),'18446744073709551615');

# If the 53..55 fail you have problems in the parser's string->int conversion,
# see toke.c:scan_num().

$q = -9223372036854775808;
is("$q","-9223372036854775808");

$q =  9223372036854775807;
is("$q","9223372036854775807");

$q = 18446744073709551615;
is("$q","18446744073709551615");

# Test that sv_2nv then sv_2iv is the same as sv_2iv direct
# fails if whatever Atol is defined as can't actually cope with >32 bits.
my $num = 4294967297;
my $string = "4294967297";
{
  use integer;
  $num += 0;
  $string += 0;
}
is($num, $string);

# Test that sv_2nv then sv_2uv is the same as sv_2uv direct
$num = 4294967297;
$string = "4294967297";
$num &= 0;
$string &= 0;
is($num, $string);

$q = "18446744073709551616e0";
$q += 0;
isnt($q, "18446744073709551615");

# 0xFFFFFFFFFFFFFFFF ==  1 * 3 * 5 * 17 * 257 * 641 * 65537 * 6700417'
$q = 0xFFFFFFFFFFFFFFFF / 3;
cmp_ok($q, '==', 0x5555555555555555);
SKIP: {
    skip("Maths does not preserve UVs", 2) unless $maths_preserves_UVs;
    cmp_ok($q, '!=', 0x5555555555555556);
    skip("All UV division is precise as NVs, so is done as NVs", 1)
	if $Config{d_nv_preserves_uv};
    unlike($q, qr/[e.]/);
}

$q = 0xFFFFFFFFFFFFFFFF % 0x5555555555555555;
cmp_ok($q, '==', 0);

$q = 0xFFFFFFFFFFFFFFFF % 0xFFFFFFFFFFFFFFF0;
cmp_ok($q, '==', 0xF);

$q = 0x8000000000000000 % 9223372036854775807;
cmp_ok($q, '==', 1);

$q = 0x8000000000000000 % -9223372036854775807;
cmp_ok($q, '==', -9223372036854775806);

{
    use integer;
    $q = hex "0x123456789abcdef0";
    cmp_ok($q, '==', 0x123456789abcdef0);
    cmp_ok($q, '!=', 0x123456789abcdef1);
    unlike($q, qr/[e.]/, 'Should not be floating point');

    $q = oct "0x123456789abcdef0";
    cmp_ok($q, '==', 0x123456789abcdef0);
    cmp_ok($q, '!=', 0x123456789abcdef1);
    unlike($q, qr/[e.]/, 'Should not be floating point');

    $q = oct "765432176543217654321";
    cmp_ok($q, '==', 0765432176543217654321);
    cmp_ok($q, '!=', 0765432176543217654322);
    unlike($q, qr/[e.]/, 'Should not be floating point');

    $q = oct "0b0101010101010101010101010101010101010101010101010101010101010101";
    cmp_ok($q, '==', 0x5555555555555555);
    cmp_ok($q, '!=', 0x5555555555555556);
    unlike($q, qr/[e.]/, 'Should not be floating point');
}

# trigger various attempts to negate IV_MIN

cmp_ok  0x8000000000000000 / -0x8000000000000000, '==', -1, '(IV_MAX+1) / IV_MIN';
cmp_ok -0x8000000000000000 /  0x8000000000000000, '==', -1, 'IV_MIN / (IV_MAX+1)';
cmp_ok  0x8000000000000000 / -1, '==', -0x8000000000000000, '(IV_MAX+1) / -1';
cmp_ok                   0 % -0x8000000000000000, '==',  0, '0 % IV_MIN';
cmp_ok -0x8000000000000000 % -0x8000000000000000, '==',  0, 'IV_MIN % IV_MIN';

# check addition/subtraction with values 1 bit below max ranges
{
    my $a_3ff = 0x3fffffffffffffff;
    my $a_400 = 0x4000000000000000;
    my $a_7fe = 0x7ffffffffffffffe;
    my $a_7ff = 0x7fffffffffffffff;
    my $a_800 = 0x8000000000000000;

    my $m_3ff = -$a_3ff;
    my $m_400 = -$a_400;
    my $m_7fe = -$a_7fe;
    my $m_7ff = -$a_7ff;

    cmp_ok $a_3ff, '==',  4611686018427387903, "1bit  a_3ff";
    cmp_ok $m_3ff, '==', -4611686018427387903, "1bit -a_3ff";
    cmp_ok $a_400, '==',  4611686018427387904, "1bit  a_400";
    cmp_ok $m_400, '==', -4611686018427387904, "1bit -a_400";
    cmp_ok $a_7fe, '==',  9223372036854775806, "1bit  a_7fe";
    cmp_ok $m_7fe, '==', -9223372036854775806, "1bit -a_7fe";
    cmp_ok $a_7ff, '==',  9223372036854775807, "1bit  a_7ff";
    cmp_ok $m_7ff, '==', -9223372036854775807, "1bit -a_7ff";
    cmp_ok $a_800, '==',  9223372036854775808, "1bit  a_800";

    cmp_ok $a_3ff + $a_3ff, '==',  $a_7fe, "1bit  a_3ff +  a_3ff";
    cmp_ok $m_3ff + $a_3ff, '==',       0, "1bit -a_3ff +  a_3ff";
    cmp_ok $a_3ff + $m_3ff, '==',       0, "1bit  a_3ff + -a_3ff";
    cmp_ok $m_3ff + $m_3ff, '==',  $m_7fe, "1bit -a_3ff + -a_3ff";

    cmp_ok $a_3ff - $a_3ff, '==',       0, "1bit  a_3ff -  a_3ff";
    cmp_ok $m_3ff - $a_3ff, '==',  $m_7fe, "1bit -a_3ff -  a_3ff";
    cmp_ok $a_3ff - $m_3ff, '==',  $a_7fe, "1bit  a_3ff - -a_3ff";
    cmp_ok $m_3ff - $m_3ff, '==',       0, "1bit -a_3ff - -a_3ff";

    cmp_ok $a_3ff + $a_400, '==',  $a_7ff, "1bit  a_3ff +  a_400";
    cmp_ok $m_3ff + $a_400, '==',       1, "1bit -a_3ff +  a_400";
    cmp_ok $a_3ff + $m_400, '==',      -1, "1bit  a_3ff + -a_400";
    cmp_ok $m_3ff + $m_400, '==',  $m_7ff, "1bit -a_3ff + -a_400";

    cmp_ok $a_3ff - $a_400, '==',      -1, "1bit  a_3ff -  a_400";
    cmp_ok $m_3ff - $a_400, '==',  $m_7ff, "1bit -a_3ff -  a_400";
    cmp_ok $a_3ff - $m_400, '==',  $a_7ff, "1bit  a_3ff - -a_400";
    cmp_ok $m_3ff - $m_400, '==',       1, "1bit -a_3ff - -a_400";

    cmp_ok $a_400 + $a_3ff, '==',  $a_7ff, "1bit  a_400 +  a_3ff";
    cmp_ok $m_400 + $a_3ff, '==',      -1, "1bit -a_400 +  a_3ff";
    cmp_ok $a_400 + $m_3ff, '==',       1, "1bit  a_400 + -a_3ff";
    cmp_ok $m_400 + $m_3ff, '==',  $m_7ff, "1bit -a_400 + -a_3ff";

    cmp_ok $a_400 - $a_3ff, '==',       1, "1bit  a_400 -  a_3ff";
    cmp_ok $m_400 - $a_3ff, '==',  $m_7ff, "1bit -a_400 -  a_3ff";
    cmp_ok $a_400 - $m_3ff, '==',  $a_7ff, "1bit  a_400 - -a_3ff";
    cmp_ok $m_400 - $m_3ff, '==',      -1, "1bit -a_400 - -a_3ff";
}

# check multiplication with values using approx half the total bits
{
    my $a  =         0xffffffff;
    my $aa = 0xfffffffe00000001;
    my $m  = -$a;
    my $mm = -$aa;

    cmp_ok $a,      '==',            4294967295, "halfbits   a";
    cmp_ok $m,      '==',           -4294967295, "halfbits  -a";
    cmp_ok $aa,     '==',  18446744065119617025, "halfbits  aa";
    cmp_ok $mm,     '==', -18446744065119617025, "halfbits -aa";
    cmp_ok $a * $a, '==',                   $aa, "halfbits  a *  a";
    cmp_ok $m * $a, '==',                   $mm, "halfbits -a *  a";
    cmp_ok $a * $m, '==',                   $mm, "halfbits  a * -a";
    cmp_ok $m * $m, '==',                   $aa, "halfbits -a * -a";
}

# check multiplication where the 2 args multiply to 2^62 .. 2^65

{
    my $exp62 = (2**62);
    my $exp63 = (2**63);
    my $exp64 = (2**64);
    my $exp65 = (2**65);
    cmp_ok $exp62, '==',  4611686018427387904, "2**62";
    cmp_ok $exp63, '==',  9223372036854775808, "2**63";
    cmp_ok $exp64, '==', 18446744073709551616, "2**64";
    cmp_ok $exp65, '==', 36893488147419103232, "2**65";

    my @@exp = ($exp62, $exp63, $exp64, $exp65);
    for my $i (0..63) {
        for my $x (0..3) {
            my $j = 62 - $i + $x;
            next if $j < 0 or $j > 63;

            my $a = (1 << $i);
            my $b = (1 << $j);
            my $c = $a * $b;
            cmp_ok $c, '==', $exp[$x], "(1<<$i) * (1<<$j)";
        }
    }
}

done_testing();
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
#./perl
d4 5
a8 7
	eval { my $q = pack "q", 0 };
	if ($@@) {
		print "1..0\n# no 64-bit types\n";
		exit(0);
	}
	chdir 't' if -d 't';
	unshift @@INC, '../lib';
d11 1
a11 1
# This could use a lot of more tests.
d15 1
d17 1
d19 14
a32 1
print "1..48\n";
d41 2
a42 2
print "not " unless $x == $q && $x > $f;
print "ok 1\n";
d46 2
a47 3
print "not " unless $x eq $q && $x > $f;
print "ok 2\n";

d50 3
a52 2
print "not " unless $x == $q && $x eq $q && $x > $f;
print "ok 3\n";
d55 3
a57 2
print "not " unless $x == $q && $x eq $q && $x > $f;
print "ok 4\n";
d60 3
a62 2
print "not " unless $x == $q && $x eq $q && $x > $f;
print "ok 5\n";
d66 2
a67 2
print "not " unless hex($x) == 0x2dfdc1c35 && hex($x) > $f;
print "ok 6\n";
d70 2
a71 2
print "not " unless hex($x) == 0x2dfdc1c35 && hex($x) > $f;
print "ok 7\n";
d74 2
a75 3
print "not " unless hex($x) == 0x2dfdc1c35 && hex($x) > $f;
print "ok 8\n";

d78 2
a79 2
print "not " unless oct("0$x") == 0133767016065 && oct($x) > $f;
print "ok 9\n";
d82 2
a83 2
print "not " unless oct("0$x") == 0133767016065 && oct($x) > $f;
print "ok 10\n";
d86 2
a87 3
print "not " unless oct("0$x") == 0133767016065 && oct($x) > $f;
print "ok 11\n";

d90 2
a91 3
print "not " unless oct("0b$x") == 0b1011011111110111000001110000110101 &&
                    oct("0b$x") > $f;
print "ok 12\n";
d94 2
a95 3
print "not " unless oct("0b$x") == 0b1011011111110111000001110000110101 &&
                                   oct("0b$x") > $f;
print "ok 13\n";
d98 2
a99 3
print "not " unless oct("0b$x") == 0b1011011111110111000001110000110101 &&
                    oct("0b$x") > $f;
print "ok 14\n";
d103 2
a104 2
print "not " unless $x eq $q && $x > $f;
print "ok 15\n";
d107 3
a109 2
print "not " unless $x == $q && $x eq $q && $x > $f;
print "ok 16\n";
d112 3
a114 2
print "not " unless $x == $q && $x eq $q && $x > $f;
print "ok 17\n";
d118 3
a120 2
print "not " unless $x == $q && $x eq $q && $x > $f;
print "ok 18\n";
d123 3
a125 2
print "not " unless $x == $q && $x eq $q && $x > $f;
print "ok 19\n";
d128 2
a129 2
print "not " unless oct($x) == $q && oct($x) > $f;
print "ok 20\n";
d133 2
a134 2
print "not " unless $x == 35802467913 && $x > $f;
print "ok 21\n";
d137 2
a138 2
print "not " unless $x == -11111110111 && -$x > $f;
print "ok 22\n";
d140 101
a240 79
$x = $q * 1234567;
print "not " unless $x == 15241567763770867 && $x > $f;
print "ok 23\n";

$x /= 1234567;
print "not " unless $x == $q && $x > $f;
print "ok 24\n";

$x = 98765432109 % 12345678901;
print "not " unless $x == 901;
print "ok 25\n";

# The following 12 tests adapted from op/inc.

$a = 9223372036854775807;
$c = $a++;
print "not " unless $a == 9223372036854775808;
print "ok 26\n";

$a = 9223372036854775807;
$c = ++$a;
print "not " unless $a == 9223372036854775808 && $c == $a;
print "ok 27\n";

$a = 9223372036854775807;
$c = $a + 1;
print "not " unless $a == 9223372036854775807 && $c == 9223372036854775808;
print "ok 28\n";

$a = -9223372036854775808;
$c = $a--;
print "not " unless $a == -9223372036854775809 && $c == -9223372036854775808;
print "ok 29\n";

$a = -9223372036854775808;
$c = --$a;
print "not " unless $a == -9223372036854775809 && $c == $a;
print "ok 30\n";

$a = -9223372036854775808;
$c = $a - 1;
print "not " unless $a == -9223372036854775808 && $c == -9223372036854775809;
print "ok 31\n";

$a = 9223372036854775808;
$a = -$a;
$c = $a--;
print "not " unless $a == -9223372036854775809 && $c == -9223372036854775808;
print "ok 32\n";

$a = 9223372036854775808;
$a = -$a;
$c = --$a;
print "not " unless $a == -9223372036854775809 && $c == $a;
print "ok 33\n";

$a = 9223372036854775808;
$a = -$a;
$c = $a - 1;
print "not " unless $a == -9223372036854775808 && $c == -9223372036854775809;
print "ok 34\n";

$a = 9223372036854775808;
$b = -$a;
$c = $b--;
print "not " unless $b == -$a-1 && $c == -$a;
print "ok 35\n";

$a = 9223372036854775808;
$b = -$a;
$c = --$b;
print "not " unless $b == -$a-1 && $c == $b;
print "ok 36\n";

$a = 9223372036854775808;
$b = -$a;
$b = $b - 1;
print "not " unless $b == -(++$a);
print "ok 37\n";
d244 9
a252 2
print "not " unless (vec($x, 1, 64) = $q) == $q;
print "ok 38\n";
d254 1
a254 2
print "not " unless vec($x, 1, 64) == $q && vec($x, 1, 64) > $f;
print "ok 39\n";
d256 1
a256 2
print "not " unless vec($x, 0, 64) == 0 && vec($x, 2, 64) == 0;
print "ok 40\n";
d258 1
d260 1
a260 2
print "not " unless ~0 == 0xffffffffffffffff;
print "ok 41\n";
d262 1
a262 2
print "not " unless (0xffffffff<<32) == 0xffffffff00000000;
print "ok 42\n";
d264 2
a265 2
print "not " unless ((0xffffffff)<<32)>>32 == 0xffffffff;
print "ok 43\n";
a266 2
print "not " unless 1<<63 == 0x8000000000000000;
print "ok 44\n";
d268 2
a269 2
print "not " unless (sprintf "%#Vx", 1<<63) eq '0x8000000000000000';
print "ok 45\n";
a270 2
print "not " unless (0x8000000000000000 | 1) == 0x8000000000000001;
print "ok 46\n";
d272 28
a299 2
print "not " unless (0xf000000000000000 & 0x8000000000000000) == 0x8000000000000000;
print "ok 47\n";
d301 161
a461 2
print "not " unless (0xf000000000000000 ^ 0xfffffffffffffff0) == 0x0ffffffffffffff0;
print "ok 48\n";
d463 1
a463 1
# eof
@


1.1.1.1
log
@virgin perl 5.6.0
@
text
@@


1.1.1.2
log
@stock perl 5.6.1
@
text
@d6 1
a6 1
		print "1..0\n# Skip: no 64-bit types\n";
d10 1
a10 1
	@@INC = '../lib';
d13 1
a13 1
# This could use many more tests.
d19 1
a19 1
print "1..55\n";
d126 79
a204 100
if ($^O ne 'unicos') {
    $x = $q * 1234567;
    print "not " unless $x == 15241567763770867 && $x > $f;
    print "ok 23\n";

    $x /= 1234567;
    print "not " unless $x == $q && $x > $f;
    print "ok 24\n";

    $x = 98765432109 % 12345678901;
    print "not " unless $x == 901;
    print "ok 25\n";
    
    # The following 12 tests adapted from op/inc.

    $a = 9223372036854775807;
    $c = $a++;
    print "not " unless $a == 9223372036854775808;
    print "ok 26\n";

    $a = 9223372036854775807;
    $c = ++$a;
    print "not "
	unless $a == 9223372036854775808 && $c == $a;
    print "ok 27\n";

    $a = 9223372036854775807;
    $c = $a + 1;
    print "not "
	unless $a == 9223372036854775807 && $c == 9223372036854775808;
    print "ok 28\n";

    $a = -9223372036854775808;
    $c = $a--;
    print "not "
	unless $a == -9223372036854775809 && $c == -9223372036854775808;
    print "ok 29\n";

    $a = -9223372036854775808;
    $c = --$a;
    print "not "
	unless $a == -9223372036854775809 && $c == $a;
    print "ok 30\n";

    $a = -9223372036854775808;
    $c = $a - 1;
    print "not "
	unless $a == -9223372036854775808 && $c == -9223372036854775809;
    print "ok 31\n";
    
    $a = 9223372036854775808;
    $a = -$a;
    $c = $a--;
    print "not "
	unless $a == -9223372036854775809 && $c == -9223372036854775808;
    print "ok 32\n";
    
    $a = 9223372036854775808;
    $a = -$a;
    $c = --$a;
    print "not "
	unless $a == -9223372036854775809 && $c == $a;
    print "ok 33\n";
    
    $a = 9223372036854775808;
    $a = -$a;
    $c = $a - 1;
    print "not "
	unless $a == -9223372036854775808 && $c == -9223372036854775809;
    print "ok 34\n";

    $a = 9223372036854775808;
    $b = -$a;
    $c = $b--;
    print "not "
	unless $b == -$a-1 && $c == -$a;
    print "ok 35\n";

    $a = 9223372036854775808;
    $b = -$a;
    $c = --$b;
    print "not "
	unless $b == -$a-1 && $c == $b;
    print "ok 36\n";

    $a = 9223372036854775808;
    $b = -$a;
    $b = $b - 1;
    print "not "
	unless $b == -(++$a);
    print "ok 37\n";

} else {
    # Unicos has imprecise doubles (14 decimal digits or so),
    # especially if operating near the UV/IV limits the low-order bits
    # become mangled even by simple arithmetic operations.
    for (23..37) {
	print "ok $_ # skipped: too imprecise numbers\n";
    }
}
d236 1
a236 2
print "not "
    unless (0xf000000000000000 & 0x8000000000000000) == 0x8000000000000000;
d239 1
a239 2
print "not "
    unless (0xf000000000000000 ^ 0xfffffffffffffff0) == 0x0ffffffffffffff0;
a240 32


print "not "
    unless (sprintf "%b", ~0)   eq
           '1111111111111111111111111111111111111111111111111111111111111111';
print "ok 49\n";

print "not "
    unless (sprintf "%64b", ~0) eq
           '1111111111111111111111111111111111111111111111111111111111111111';
print "ok 50\n";

print "not " unless (sprintf "%d", ~0>>1) eq '9223372036854775807';
print "ok 51\n";

print "not " unless (sprintf "%u", ~0)    eq '18446744073709551615';
print "ok 52\n";

# If the 53..55 fail you have problems in the parser's string->int conversion,
# see toke.c:scan_num().

$q = -9223372036854775808;
print "# $q ne\n# -9223372036854775808\nnot " unless "$q" eq "-9223372036854775808";
print "ok 53\n";

$q =  9223372036854775807;
print "# $q ne\n# 9223372036854775807\nnot " unless "$q" eq "9223372036854775807";
print "ok 54\n";

$q = 18446744073709551615;
print "# $q ne\n# 18446744073709551615\nnot " unless "$q" eq "18446744073709551615";
print "ok 55\n";
@


1.1.1.3
log
@stock perl 5.8.0 from CPAN
@
text
@d6 1
a6 1
		print "1..0 # Skip: no 64-bit types\n";
a16 1
use warnings;
d19 1
a19 16
print "1..67\n";

# as 6 * 6 = 36, the last digit of 6**n will always be six. Hence the last
# digit of 16**n will always be six. Hence 16**n - 1 will always end in 5.
# Assumption is that UVs will always be a multiple of 4 bits long.

my $UV_max = ~0;
die "UV_max eq '$UV_max', doesn't end in 5; your UV isn't 4n bits long :-(."
  unless $UV_max =~ /5$/;
my $UV_max_less3 = $UV_max - 3;
my $maths_preserves_UVs = $UV_max_less3 =~ /^\d+2$/;   # 5 - 3 is 2.
if ($maths_preserves_UVs) {
  print "# This perl's maths preserves all bits of a UV.\n";
} else {
  print "# This perl's maths does not preserve all bits of a UV.\n";
}
a295 104

# Test that sv_2nv then sv_2iv is the same as sv_2iv direct
# fails if whatever Atol is defined as can't actually cope with >32 bits.
my $num = 4294967297;
my $string = "4294967297";
{
  use integer;
  $num += 0;
  $string += 0;
}
if ($num eq $string) {
  print "ok 56\n";
} else {
  print "not ok 56 # \"$num\" ne \"$string\"\n";
}

# Test that sv_2nv then sv_2uv is the same as sv_2uv direct
$num = 4294967297;
$string = "4294967297";
$num &= 0;
$string &= 0;
if ($num eq $string) {
  print "ok 57\n";
} else {
  print "not ok 57 # \"$num\" ne \"$string\"\n";
}

$q = "18446744073709551616e0";
$q += 0;
print "# \"18446744073709551616e0\" += 0 gives $q\nnot " if "$q" eq "18446744073709551615";
print "ok 58\n";

# 0xFFFFFFFFFFFFFFFF ==  1 * 3 * 5 * 17 * 257 * 641 * 65537 * 6700417'
$q = 0xFFFFFFFFFFFFFFFF / 3;
if ($q == 0x5555555555555555 and ($q != 0x5555555555555556
                                  or !$maths_preserves_UVs)) {
  print "ok 59\n";
} else {
  print "not ok 59 # 0xFFFFFFFFFFFFFFFF / 3 = $q\n";
  print "# Should not be floating point\n" if $q =~ tr/e.//;
}

$q = 0xFFFFFFFFFFFFFFFF % 0x5555555555555555;
if ($q == 0) {
  print "ok 60\n";
} else {
  print "not ok 60 # 0xFFFFFFFFFFFFFFFF % 0x5555555555555555 => $q\n";
}

$q = 0xFFFFFFFFFFFFFFFF % 0xFFFFFFFFFFFFFFF0;
if ($q == 0xF) {
  print "ok 61\n";
} else {
  print "not ok 61 # 0xFFFFFFFFFFFFFFFF % 0xFFFFFFFFFFFFFFF0 => $q\n";
}

$q = 0x8000000000000000 % 9223372036854775807;
if ($q == 1) {
  print "ok 62\n";
} else {
  print "not ok 62 # 0x8000000000000000 % 9223372036854775807 => $q\n";
}

$q = 0x8000000000000000 % -9223372036854775807;
if ($q == -9223372036854775806) {
  print "ok 63\n";
} else {
  print "not ok 63 # 0x8000000000000000 % -9223372036854775807 => $q\n";
}

{
  use integer;
  $q = hex "0x123456789abcdef0";
  if ($q == 0x123456789abcdef0 and $q != 0x123456789abcdef1) {
    print "ok 64\n";
  } else {
    printf "not ok 64 # hex \"0x123456789abcdef0\" = $q (%X)\n", $q;
    print "# Should not be floating point\n" if $q =~ tr/e.//;
  }

  $q = oct "0x123456789abcdef0";
  if ($q == 0x123456789abcdef0 and $q != 0x123456789abcdef1) {
    print "ok 65\n";
  } else {
    printf "not ok 65 # oct \"0x123456789abcdef0\" = $q (%X)\n", $q;
    print "# Should not be floating point\n" if $q =~ tr/e.//;
  }

  $q = oct "765432176543217654321";
  if ($q == 0765432176543217654321 and $q != 0765432176543217654322) {
    print "ok 66\n";
  } else {
    printf "not ok 66 # oct \"765432176543217654321\" = $q (%o)\n", $q;
    print "# Should not be floating point\n" if $q =~ tr/e.//;
  }

  $q = oct "0b0101010101010101010101010101010101010101010101010101010101010101";
  if ($q == 0x5555555555555555 and $q != 0x5555555555555556) {
    print "ok 67\n";
  } else {
    printf "not ok 67 # oct \"0b0101010101010101010101010101010101010101010101010101010101010101\" = $q (%b)\n", $q;
    print "# Should not be floating point\n" if $q =~ tr/e.//;
  }
}
@


1.1.1.4
log
@Perl 5.12.2 from CPAN
@
text
@d175 1
a175 4
    {
	no warnings 'imprecision';
	$c = $a--;
    }
d181 1
a181 4
    {
	no warnings 'imprecision';
	$c = --$a;
    }
d194 1
a194 4
    {
	no warnings 'imprecision';
	$c = $a--;
    }
d201 1
a201 4
    {
	no warnings 'imprecision';
	$c = --$a;
    }
d215 1
a215 4
    {
	no warnings 'imprecision';
	$c = $b--;
    }
d222 1
a222 4
    {
	no warnings 'imprecision';
	$c = --$b;
    }
@


1.1.1.5
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d1 1
a1 1
#!./perl
d4 7
a10 5
    chdir 't' if -d 't';
    @@INC = '../lib';
    require './test.pl';
    eval { my $q = pack "q", 0 };
    skip_all('no 64-bit types') if $@@;
d19 2
a20 1
use Config;
d44 2
a45 2
cmp_ok($x, '==', $q);
cmp_ok($x, '>', $f);
d49 3
a51 2
is($x, $q);
cmp_ok($x, '>', $f);
d54 2
a55 3
cmp_ok($x, '==', $q);
is($x, $q);
cmp_ok($x, '>', $f);
d58 2
a59 3
cmp_ok($x, '==', $q);
is($x, $q);
cmp_ok($x, '>', $f);
d62 2
a63 3
cmp_ok($x, '==', $q);
is($x, $q);
cmp_ok($x, '>', $f);
d67 2
a68 2
cmp_ok(hex $x, '==', 0x2dfdc1c35);
cmp_ok(hex $x, '>', $f);
d71 2
a72 2
cmp_ok(hex $x, '==', 0x2dfdc1c35);
cmp_ok(hex $x, '>', $f);
d75 3
a77 2
cmp_ok(hex $x, '==', 0x2dfdc1c35);
cmp_ok(hex $x, '>', $f);
d80 2
a81 2
cmp_ok(oct "0$x", '==', 0133767016065);
cmp_ok(oct $x, '>', $f);
d84 2
a85 2
cmp_ok(oct "0$x", '==', 0133767016065);
cmp_ok(oct $x, '>', $f);
d88 3
a90 2
cmp_ok(oct "0$x", '==', 0133767016065);
cmp_ok(oct $x, '>', $f);
d93 3
a95 2
cmp_ok(oct "0b$x", '==', 0b1011011111110111000001110000110101);
cmp_ok(oct "0b$x", '>', $f);
d98 3
a100 2
cmp_ok(oct "0b$x", '==', 0b1011011111110111000001110000110101);
cmp_ok(oct "0b$x", '>', $f);
d103 3
a105 2
cmp_ok(oct "0b$x", '==', 0b1011011111110111000001110000110101);
cmp_ok(oct "0b$x", '>', $f);
d109 2
a110 2
is($x, $q);
cmp_ok($x, '>', $f);
d113 2
a114 3
cmp_ok($x, '==', $q);
is($x, $q);
cmp_ok($x, '>', $f);
d117 2
a118 3
cmp_ok($x, '==', $q);
is($x, $q);
cmp_ok($x, '>', $f);
d122 2
a123 3
cmp_ok($x, '==', $q);
is($x, $q);
cmp_ok($x, '>', $f);
d126 2
a127 3
cmp_ok($x, '==', $q);
is($x, $q);
cmp_ok($x, '>', $f);
d130 2
a131 2
cmp_ok(oct $x, '==', $q);
cmp_ok(oct $x, '>', $f);
d135 2
a136 2
cmp_ok($x, '==', 35802467913);
cmp_ok($x, '>', $f);
d139 2
a140 8
cmp_ok($x, '==', -11111110111);
cmp_ok(-$x, '>', $f);

SKIP: {
    # Unicos has imprecise doubles (14 decimal digits or so),
    # especially if operating near the UV/IV limits the low-order bits
    # become mangled even by simple arithmetic operations.
    skip('too imprecise numbers on unicos') if $^O eq 'unicos';
d142 1
d144 2
a145 2
    cmp_ok($x, '==', 15241567763770867);
    cmp_ok($x, '>', $f);
d148 2
a149 2
    cmp_ok($x, '==', $q);
    cmp_ok($x, '>', $f);
d152 3
a154 2
    cmp_ok($x, '==', 901);

d159 2
a160 1
    cmp_ok($a, '==', 9223372036854775808);
d164 3
a166 2
    cmp_ok($a, '==', 9223372036854775808);
    cmp_ok($c, '==', $a);
d170 3
a172 2
    cmp_ok($a, '==', 9223372036854775807);
    cmp_ok($c, '==', 9223372036854775808);
d179 3
a181 2
    cmp_ok($a, '==', -9223372036854775809);
    cmp_ok($c, '==', -9223372036854775808);
d188 3
a190 2
    cmp_ok($a, '==', -9223372036854775809);
    cmp_ok($c, '==', $a);
d194 4
a197 3
    cmp_ok($a, '==', -9223372036854775808);
    cmp_ok($c, '==', -9223372036854775809);

d204 4
a207 3
    cmp_ok($a, '==', -9223372036854775809);
    cmp_ok($c, '==', -9223372036854775808);

d214 4
a217 3
    cmp_ok($a, '==', -9223372036854775809);
    cmp_ok($c, '==', $a);

d221 3
a223 2
    cmp_ok($a, '==', -9223372036854775808);
    cmp_ok($c, '==', -9223372036854775809);
d231 3
a233 2
    cmp_ok($b, '==', -$a-1);
    cmp_ok($c, '==', -$a);
d241 3
a243 2
    cmp_ok($b, '==', -$a-1);
    cmp_ok($c, '==', $b);
d248 11
a258 1
    cmp_ok($b, '==', -(++$a));
d263 8
a270 1
cmp_ok((vec($x, 1, 64) = $q), '==', $q);
a271 2
cmp_ok(vec($x, 1, 64), '==', $q);
cmp_ok(vec($x, 1, 64), '>', $f);
d273 2
a274 2
cmp_ok(vec($x, 0, 64), '==', 0);
cmp_ok(vec($x, 2, 64), '==', 0);
d276 2
a277 1
cmp_ok(~0, '==', 0xffffffffffffffff);
d279 2
a280 1
cmp_ok((0xffffffff<<32), '==', 0xffffffff00000000);
d282 2
a283 1
cmp_ok(((0xffffffff)<<32)>>32, '==', 0xffffffff);
d285 2
a286 1
cmp_ok(1<<63, '==', 0x8000000000000000);
d288 2
a289 1
is((sprintf "%#Vx", 1<<63), '0x8000000000000000');
d291 3
a293 1
cmp_ok((0x8000000000000000 | 1), '==', 0x8000000000000001);
d295 3
a297 2
cmp_ok((0xf000000000000000 & 0x8000000000000000), '==', 0x8000000000000000);
cmp_ok((0xf000000000000000 ^ 0xfffffffffffffff0), '==', 0x0ffffffffffffff0);
d300 4
a303 2
is((sprintf "%b", ~0),
   '1111111111111111111111111111111111111111111111111111111111111111');
d305 4
d310 2
a311 2
is((sprintf "%64b", ~0),
   '1111111111111111111111111111111111111111111111111111111111111111');
d313 2
a314 2
is((sprintf "%d", ~0>>1),'9223372036854775807');
is((sprintf "%u", ~0),'18446744073709551615');
d320 2
a321 1
is("$q","-9223372036854775808");
d324 2
a325 1
is("$q","9223372036854775807");
d328 2
a329 1
is("$q","18446744073709551615");
d340 5
a344 1
is($num, $string);
d351 5
a355 1
is($num, $string);
d359 2
a360 1
isnt($q, "18446744073709551615");
d364 6
a369 7
cmp_ok($q, '==', 0x5555555555555555);
SKIP: {
    skip("Maths does not preserve UVs", 2) unless $maths_preserves_UVs;
    cmp_ok($q, '!=', 0x5555555555555556);
    skip("All UV division is precise as NVs, so is done as NVs", 1)
	if $Config{d_nv_preserves_uv};
    unlike($q, qr/[e.]/);
d373 5
a377 1
cmp_ok($q, '==', 0);
d380 5
a384 1
cmp_ok($q, '==', 0xF);
d387 5
a391 1
cmp_ok($q, '==', 1);
d394 5
a398 1
cmp_ok($q, '==', -9223372036854775806);
d401 32
a432 20
    use integer;
    $q = hex "0x123456789abcdef0";
    cmp_ok($q, '==', 0x123456789abcdef0);
    cmp_ok($q, '!=', 0x123456789abcdef1);
    unlike($q, qr/[e.]/, 'Should not be floating point');

    $q = oct "0x123456789abcdef0";
    cmp_ok($q, '==', 0x123456789abcdef0);
    cmp_ok($q, '!=', 0x123456789abcdef1);
    unlike($q, qr/[e.]/, 'Should not be floating point');

    $q = oct "765432176543217654321";
    cmp_ok($q, '==', 0765432176543217654321);
    cmp_ok($q, '!=', 0765432176543217654322);
    unlike($q, qr/[e.]/, 'Should not be floating point');

    $q = oct "0b0101010101010101010101010101010101010101010101010101010101010101";
    cmp_ok($q, '==', 0x5555555555555555);
    cmp_ok($q, '!=', 0x5555555555555556);
    unlike($q, qr/[e.]/, 'Should not be floating point');
d435 1
a435 1
done_testing();
@


1.1.1.6
log
@Import perl-5.24.2
@
text
@a357 105
# trigger various attempts to negate IV_MIN

cmp_ok  0x8000000000000000 / -0x8000000000000000, '==', -1, '(IV_MAX+1) / IV_MIN';
cmp_ok -0x8000000000000000 /  0x8000000000000000, '==', -1, 'IV_MIN / (IV_MAX+1)';
cmp_ok  0x8000000000000000 / -1, '==', -0x8000000000000000, '(IV_MAX+1) / -1';
cmp_ok                   0 % -0x8000000000000000, '==',  0, '0 % IV_MIN';
cmp_ok -0x8000000000000000 % -0x8000000000000000, '==',  0, 'IV_MIN % IV_MIN';

# check addition/subtraction with values 1 bit below max ranges
{
    my $a_3ff = 0x3fffffffffffffff;
    my $a_400 = 0x4000000000000000;
    my $a_7fe = 0x7ffffffffffffffe;
    my $a_7ff = 0x7fffffffffffffff;
    my $a_800 = 0x8000000000000000;

    my $m_3ff = -$a_3ff;
    my $m_400 = -$a_400;
    my $m_7fe = -$a_7fe;
    my $m_7ff = -$a_7ff;

    cmp_ok $a_3ff, '==',  4611686018427387903, "1bit  a_3ff";
    cmp_ok $m_3ff, '==', -4611686018427387903, "1bit -a_3ff";
    cmp_ok $a_400, '==',  4611686018427387904, "1bit  a_400";
    cmp_ok $m_400, '==', -4611686018427387904, "1bit -a_400";
    cmp_ok $a_7fe, '==',  9223372036854775806, "1bit  a_7fe";
    cmp_ok $m_7fe, '==', -9223372036854775806, "1bit -a_7fe";
    cmp_ok $a_7ff, '==',  9223372036854775807, "1bit  a_7ff";
    cmp_ok $m_7ff, '==', -9223372036854775807, "1bit -a_7ff";
    cmp_ok $a_800, '==',  9223372036854775808, "1bit  a_800";

    cmp_ok $a_3ff + $a_3ff, '==',  $a_7fe, "1bit  a_3ff +  a_3ff";
    cmp_ok $m_3ff + $a_3ff, '==',       0, "1bit -a_3ff +  a_3ff";
    cmp_ok $a_3ff + $m_3ff, '==',       0, "1bit  a_3ff + -a_3ff";
    cmp_ok $m_3ff + $m_3ff, '==',  $m_7fe, "1bit -a_3ff + -a_3ff";

    cmp_ok $a_3ff - $a_3ff, '==',       0, "1bit  a_3ff -  a_3ff";
    cmp_ok $m_3ff - $a_3ff, '==',  $m_7fe, "1bit -a_3ff -  a_3ff";
    cmp_ok $a_3ff - $m_3ff, '==',  $a_7fe, "1bit  a_3ff - -a_3ff";
    cmp_ok $m_3ff - $m_3ff, '==',       0, "1bit -a_3ff - -a_3ff";

    cmp_ok $a_3ff + $a_400, '==',  $a_7ff, "1bit  a_3ff +  a_400";
    cmp_ok $m_3ff + $a_400, '==',       1, "1bit -a_3ff +  a_400";
    cmp_ok $a_3ff + $m_400, '==',      -1, "1bit  a_3ff + -a_400";
    cmp_ok $m_3ff + $m_400, '==',  $m_7ff, "1bit -a_3ff + -a_400";

    cmp_ok $a_3ff - $a_400, '==',      -1, "1bit  a_3ff -  a_400";
    cmp_ok $m_3ff - $a_400, '==',  $m_7ff, "1bit -a_3ff -  a_400";
    cmp_ok $a_3ff - $m_400, '==',  $a_7ff, "1bit  a_3ff - -a_400";
    cmp_ok $m_3ff - $m_400, '==',       1, "1bit -a_3ff - -a_400";

    cmp_ok $a_400 + $a_3ff, '==',  $a_7ff, "1bit  a_400 +  a_3ff";
    cmp_ok $m_400 + $a_3ff, '==',      -1, "1bit -a_400 +  a_3ff";
    cmp_ok $a_400 + $m_3ff, '==',       1, "1bit  a_400 + -a_3ff";
    cmp_ok $m_400 + $m_3ff, '==',  $m_7ff, "1bit -a_400 + -a_3ff";

    cmp_ok $a_400 - $a_3ff, '==',       1, "1bit  a_400 -  a_3ff";
    cmp_ok $m_400 - $a_3ff, '==',  $m_7ff, "1bit -a_400 -  a_3ff";
    cmp_ok $a_400 - $m_3ff, '==',  $a_7ff, "1bit  a_400 - -a_3ff";
    cmp_ok $m_400 - $m_3ff, '==',      -1, "1bit -a_400 - -a_3ff";
}

# check multiplication with values using approx half the total bits
{
    my $a  =         0xffffffff;
    my $aa = 0xfffffffe00000001;
    my $m  = -$a;
    my $mm = -$aa;

    cmp_ok $a,      '==',            4294967295, "halfbits   a";
    cmp_ok $m,      '==',           -4294967295, "halfbits  -a";
    cmp_ok $aa,     '==',  18446744065119617025, "halfbits  aa";
    cmp_ok $mm,     '==', -18446744065119617025, "halfbits -aa";
    cmp_ok $a * $a, '==',                   $aa, "halfbits  a *  a";
    cmp_ok $m * $a, '==',                   $mm, "halfbits -a *  a";
    cmp_ok $a * $m, '==',                   $mm, "halfbits  a * -a";
    cmp_ok $m * $m, '==',                   $aa, "halfbits -a * -a";
}

# check multiplication where the 2 args multiply to 2^62 .. 2^65

{
    my $exp62 = (2**62);
    my $exp63 = (2**63);
    my $exp64 = (2**64);
    my $exp65 = (2**65);
    cmp_ok $exp62, '==',  4611686018427387904, "2**62";
    cmp_ok $exp63, '==',  9223372036854775808, "2**63";
    cmp_ok $exp64, '==', 18446744073709551616, "2**64";
    cmp_ok $exp65, '==', 36893488147419103232, "2**65";

    my @@exp = ($exp62, $exp63, $exp64, $exp65);
    for my $i (0..63) {
        for my $x (0..3) {
            my $j = 62 - $i + $x;
            next if $j < 0 or $j > 63;

            my $a = (1 << $i);
            my $b = (1 << $j);
            my $c = $a * $b;
            cmp_ok $c, '==', $exp[$x], "(1<<$i) * (1<<$j)";
        }
    }
}

@


