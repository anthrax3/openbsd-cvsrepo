head	1.6;
access;
symbols
	OPENBSD_6_2_BASE:1.6
	PERL_5_24_2:1.1.1.7
	OPENBSD_6_1:1.6.0.4
	OPENBSD_6_1_BASE:1.6
	OPENBSD_6_0:1.5.0.10
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.4
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.6
	OPENBSD_5_8_BASE:1.5
	PERL_5_20_2:1.1.1.6
	OPENBSD_5_7:1.5.0.2
	OPENBSD_5_7_BASE:1.5
	PERL_5_20_1:1.1.1.6
	OPENBSD_5_6:1.4.0.4
	OPENBSD_5_6_BASE:1.4
	PERL_5_18_2:1.1.1.5
	PERL:1.1.1
	OPENBSD_5_5:1.3.0.6
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.2
	OPENBSD_5_4_BASE:1.3
	PERL_5_16_3:1.1.1.4
	OPENBSD_5_3:1.1.1.3.0.18
	OPENBSD_5_3_BASE:1.1.1.3
	OPENBSD_5_2:1.1.1.3.0.16
	OPENBSD_5_2_BASE:1.1.1.3
	OPENBSD_5_1_BASE:1.1.1.3
	OPENBSD_5_1:1.1.1.3.0.14
	OPENBSD_5_0:1.1.1.3.0.12
	OPENBSD_5_0_BASE:1.1.1.3
	OPENBSD_4_9:1.1.1.3.0.10
	OPENBSD_4_9_BASE:1.1.1.3
	PERL_5_12_2:1.1.1.3
	OPENBSD_4_8:1.1.1.3.0.8
	OPENBSD_4_8_BASE:1.1.1.3
	OPENBSD_4_7:1.1.1.3.0.4
	OPENBSD_4_7_BASE:1.1.1.3
	PERL_5_10_1:1.1.1.3
	OPENBSD_4_6:1.1.1.3.0.6
	OPENBSD_4_6_BASE:1.1.1.3
	OPENBSD_4_5:1.1.1.3.0.2
	OPENBSD_4_5_BASE:1.1.1.3
	PERL_5_10_0:1.1.1.3
	OPENBSD_4_4:1.1.1.2.0.18
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.16
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_2:1.1.1.2.0.14
	OPENBSD_4_2_BASE:1.1.1.2
	OPENBSD_4_1:1.1.1.2.0.12
	OPENBSD_4_1_BASE:1.1.1.2
	OPENBSD_4_0:1.1.1.2.0.10
	OPENBSD_4_0_BASE:1.1.1.2
	PERL_5_8_8:1.1.1.2
	OPENBSD_3_9:1.1.1.2.0.8
	OPENBSD_3_9_BASE:1.1.1.2
	OPENBSD_3_8:1.1.1.2.0.6
	OPENBSD_3_8_BASE:1.1.1.2
	OPENBSD_3_7:1.1.1.2.0.4
	OPENBSD_3_7_BASE:1.1.1.2
	PERL_5_8_6:1.1.1.2
	OPENBSD_3_6:1.1.1.2.0.2
	OPENBSD_3_6_BASE:1.1.1.2
	PERL_5_8_5:1.1.1.2
	PERL_5_8_3:1.1.1.2
	OPENBSD_3_5:1.1.1.1.0.2
	OPENBSD_3_5_BASE:1.1.1.1
	PERL_5_8_2:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.6
date	2017.02.05.00.32.20;	author afresh1;	state Exp;
branches;
next	1.5;
commitid	cxJ08BvJA9Pt2PTM;

1.5
date	2014.11.17.20.57.07;	author afresh1;	state Exp;
branches;
next	1.4;
commitid	QP75iYx42Uo7mMxO;

1.4
date	2014.03.24.15.05.33;	author afresh1;	state Exp;
branches;
next	1.3;

1.3
date	2013.03.25.20.40.59;	author sthen;	state Exp;
branches;
next	1.2;

1.2
date	2013.03.06.19.21.08;	author jasper;	state Exp;
branches;
next	1.1;

1.1
date	2003.12.03.02.44.32;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.12.03.02.44.32;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.04.07.21.13.43;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2008.09.29.17.19.00;	author millert;	state Exp;
branches
	1.1.1.3.16.1;
next	1.1.1.4;

1.1.1.4
date	2013.03.25.20.09.35;	author sthen;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2014.03.24.14.59.10;	author afresh1;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2014.11.17.20.53.17;	author afresh1;	state Exp;
branches;
next	1.1.1.7;
commitid	B31cAbBIXiCqnL97;

1.1.1.7
date	2017.08.14.13.46.24;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;

1.1.1.3.16.1
date	2013.03.06.19.23.52;	author jasper;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl -w

BEGIN {
    chdir 't' if -d 't';
    require './test.pl';
    set_up_inc('../lib');
}

use strict;

# This will crash perl if it fails

use constant PVBM => 'foo';

my $dummy = index 'foo', PVBM;
eval { my %h = (a => PVBM); 1 };

ok (!$@@, 'fbm scalar can be inserted into a hash');


my $destroyed;
{ package Class; DESTROY { ++$destroyed; } }

$destroyed = 0;
{
    my %h;
    keys(%h) = 1;
    $h{key} = bless({}, 'Class');
}
is($destroyed, 1, 'Timely hash destruction with lvalue keys');


# [perl #79178] Hash keys must not be stringified during compilation
# Run perl -MO=Concise -e '$a{\"foo"}' on a non-threaded pre-5.13.8 version
# to see why.
{
    my $key;
    package bar;
    sub TIEHASH { bless {}, $_[0] }
    sub FETCH { $key = $_[1] }
    package main;
    tie my %h, "bar";
    () = $h{\'foo'};
    is ref $key, SCALAR =>
     'ref hash keys are not stringified during compilation';
    use constant u => undef;
    no warnings 'uninitialized'; # work around unfixed bug #105918
    () = $h{+u};
    is $key, undef,
      'undef hash keys are not stringified during compilation, either';
}

# Part of RT #85026: Deleting the current iterator in void context does not
# free it.
{
    my $gone;
    no warnings 'once';
    local *::DESTROY = sub { ++$gone };
    my %a=(a=>bless[]);
    each %a;   # make the entry with the obj the current iterator
    delete $a{a};
    ok $gone, 'deleting the current iterator in void context frees the val'
}

# [perl #99660] Deleted hash element visible to destructor
{
    my %h;
    $h{k} = bless [];
    my $normal_exit;
    local *::DESTROY = sub { my $x = $h{k}; ++$normal_exit };
    delete $h{k}; # must be in void context to trigger the bug
    ok $normal_exit, 'freed hash elems are not visible to DESTROY';
}

# [perl #100340] Similar bug: freeing a hash elem during a delete
sub guard::DESTROY {
   ${$_[0]}->();
};
*guard = sub (&) {
   my $callback = shift;
   return bless \$callback, "guard"
};
{
  my $ok;
  my %t; %t = (
    stash => {
        guard => guard(sub{
            $ok++;
            delete $t{stash};
        }),
        foo => "bar",
        bar => "baz",
    },
  );
  ok eval { delete $t{stash}{guard}; # must be in void context
            1 },
    'freeing a hash elem from destructor called by delete does not die';
  diag $@@ if $@@; # panic: free from wrong pool
  is $ok, 1, 'the destructor was called';
}

# Weak references to pad hashes
SKIP: {
    skip_if_miniperl("No Scalar::Util::weaken under miniperl", 1);
    my $ref;
    require Scalar::Util;
    {
        my %hash;
        Scalar::Util::weaken($ref = \%hash);
        1;  # the previous statement must not be the last
    }
    is $ref, undef, 'weak refs to pad hashes go stale on scope exit';
}

# [perl #107440]
sub A::DESTROY { $::ra = 0 }
$::ra = {a=>bless [], 'A'};
undef %$::ra;
pass 'no crash when freeing hash that is being undeffed';
$::ra = {a=>bless [], 'A'};
%$::ra = ('a'..'z');
pass 'no crash when freeing hash that is being exonerated, ahem, cleared';

# If I have these correct then removing any part of the lazy hash fill handling
# code in hv.c will cause some of these tests to start failing.
sub validate_hash {
  my ($desc, $h) = @@_;
  local $::Level = $::Level + 1;

  my $scalar = %$h;
  my $expect = qr!\A(\d+)/(\d+)\z!;
  like($scalar, $expect, "$desc in scalar context matches pattern");
  my ($used, $total) = $scalar =~ $expect;
  cmp_ok($total, '>', 0, "$desc has >0 array size ($total)");
  cmp_ok($used, '>', 0, "$desc uses >0 heads ($used)");
  cmp_ok($used, '<=', $total,
         "$desc doesn't use more heads than are available");
  return ($used, $total);
}

sub torture_hash {
  my $desc = shift;
  # Intentionally use an anon hash rather than a lexical, as lexicals default
  # to getting reused on subsequent calls
  my $h = {};
  ++$h->{$_} foreach @@_;

  my ($used0, $total0) = validate_hash($desc, $h);
  # Remove half the keys each time round, until there are only 1 or 2 left
  my @@groups;
  my ($h2, $h3, $h4);
  while (keys %$h > 2) {
    my $take = (keys %$h) / 2 - 1;
    my @@keys = (keys %$h)[0 .. $take];
    my $scalar = %$h;
    delete @@$h{@@keys};
    push @@groups, $scalar, \@@keys;

    my $count = keys %$h;
    my ($used, $total) = validate_hash("$desc (-$count)", $h);
    is($total, $total0, "$desc ($count) has same array size");
    cmp_ok($used, '<=', $used0, "$desc ($count) has same or fewer heads");
    ++$h2->{$_} foreach @@keys;
    my (undef, $total2) = validate_hash("$desc (+$count)", $h2);
    cmp_ok($total2, '<=', $total0, "$desc ($count) array size no larger");

    # Each time this will get emptied then repopulated. If the fill isn't reset
    # when the hash is emptied, the used count will likely exceed the array
    %$h3 = %$h2;
    my (undef, $total3) = validate_hash("$desc (+$count copy)", $h3);
    is($total3, $total2, "$desc (+$count copy) has same array size");

    # This might use fewer buckets than the original
    %$h4 = %$h;
    my (undef, $total4) = validate_hash("$desc ($count copy)", $h4);
    cmp_ok($total4, '<=', $total0, "$desc ($count copy) array size no larger");
  }

  my $scalar = %$h;
  my @@keys = keys %$h;
  delete @@$h{@@keys};
  is(scalar %$h, 0, "scalar keys for empty $desc");

  # Rebuild the original hash, and build a copy
  # These will fail if hash key addition and deletion aren't handled correctly
  my $h1;
  foreach (@@keys) {
    ++$h->{$_};
    ++$h1->{$_};
  }
  is(scalar %$h, $scalar, "scalar keys restored when rebuilding");

  while (@@groups) {
    my $keys = pop @@groups;
    ++$h->{$_} foreach @@$keys;
    my (undef, $total) = validate_hash("$desc " . keys %$h, $h);
    is($total, $total0, "bucket count is constant when rebuilding");
    is(scalar %$h, pop @@groups, "scalar keys is identical when rebuilding");
    ++$h1->{$_} foreach @@$keys;
    validate_hash("$desc copy " . keys %$h1, $h1);
  }
  # This will fail if the fill count isn't handled correctly on hash split
  is(scalar %$h1, scalar %$h, "scalar keys is identical on copy and original");
}

torture_hash('a .. zz', 'a' .. 'zz');
torture_hash('0 .. 9', 0 .. 9);
torture_hash("'Perl'", 'Rules');

{
    my %h = qw(a x b y c z);
    no warnings qw(misc uninitialized);
    %h = $h{a};
    is(join(':', %h), 'x:', 'hash self-assign');
}

done_testing();
@


1.5
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@a4 1
    @@INC = '../lib';
d6 1
d209 7
@


1.4
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@a10 2
plan tests => 10;

d45 6
a50 1
     'hash keys are not stringified during compilation';
d123 88
@


1.3
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d11 1
a11 115
plan tests => 15;

my %h;

ok (!Internals::HvREHASH(%h), "hash doesn't start with rehash flag on");

foreach (1..10) {
  $h{"\0"x$_}++;
}

ok (!Internals::HvREHASH(%h), "10 entries doesn't trigger rehash");

foreach (11..20) {
  $h{"\0"x$_}++;
}

ok (Internals::HvREHASH(%h), "20 entries triggers rehash");




# second part using an emulation of the PERL_HASH in perl, mounting an
# attack on a pre-populated hash. This is also useful if you need normal
# keys which don't contain \0 -- suitable for stashes

use constant MASK_U32  => 2**32;
use constant HASH_SEED => 0;
use constant THRESHOLD => 14;
use constant START     => "a";

# some initial hash data
my %h2;
my $counter= "a";
$h2{$counter++}++ while $counter ne 'cd';

ok (!Internals::HvREHASH(%h2), 
    "starting with pre-populated non-pathological hash (rehash flag if off)");

my @@keys = get_keys(\%h2);
my $buckets= buckets(\%h2);
$h2{$_}++ for @@keys;
$h2{$counter++}++ while buckets(\%h2) == $buckets; # force a split
ok (Internals::HvREHASH(%h2), 
    scalar(@@keys) . " colliding into the same bucket keys are triggering rehash after split");

# returns the number of buckets in a hash
sub buckets {
    my $hr = shift;
    my $keys_buckets= scalar(%$hr);
    if ($keys_buckets=~m!/([0-9]+)\z!) {
        return 0+$1;
    } else {
        return 8;
    }
}

sub get_keys {
    my $hr = shift;

    # the minimum of bits required to mount the attack on a hash
    my $min_bits = log(THRESHOLD)/log(2);
    # if the hash has already been populated with a significant amount
    # of entries the number of mask bits can be higher
    my $keys = scalar keys %$hr;
    my $bits = $keys ? log($keys)/log(2) : 0;
    $bits = $min_bits if $min_bits > $bits;

    $bits = int($bits) < $bits ? int($bits) + 1 : int($bits);
    # need to add 2 bits to cover the internal split cases
    $bits += 2;
    my $mask = 2**$bits-1;
    print "# using mask: $mask ($bits)\n";

    my @@keys;
    my $s = START;
    my $c = 0;
    # get 2 keys on top of the THRESHOLD
    my $hash;
    while (@@keys < THRESHOLD+2) {
        # next if exists $hash->{$s};
        $hash = hash($s);
        next unless ($hash & $mask) == 0;
        $c++;
        printf "# %2d: %5s, %10s\n", $c, $s, $hash;
        push @@keys, $s;
    } continue {
        $s++;
    }

    return @@keys;
}


# trying to provide the fastest equivalent of C macro's PERL_HASH in
# Perl - the main complication is that it uses U32 integer, which we
# can't do it perl, without doing some tricks
sub hash {
    my $s = shift;
    my @@c = split //, $s;
    my $u = HASH_SEED;
    for (@@c) {
        # (A % M) + (B % M) == (A + B) % M
        # This works because '+' produces a NV, which is big enough to hold
        # the intermediate result. We only need the % before any "^" and "&"
        # to get the result in the range for an I32.
        # and << doesn't work on NV, so using 1 << 10
        $u += ord;
        $u += $u * (1 << 10); $u %= MASK_U32;
        $u ^= $u >> 6;
    }
    $u += $u << 3;  $u %= MASK_U32;
    $u ^= $u >> 11; $u %= MASK_U32;
    $u += $u << 15; $u %= MASK_U32;
    $u;
}
@


1.2
log
@Apply patch from RedHat to address CVE-2013-1667, perl: DoS in rehashing code
For more information please refer to: http://code.activestate.com/lists/perl5-porters/191311/

ok millert@@
@
text
@d11 1
a11 1
plan tests => 6;
d135 99
@


1.1
log
@Initial revision
@
text
@d11 1
a11 1
plan tests => 3;
d28 107
@


1.1.1.1
log
@perl 5.8.2 from CPAN
@
text
@@


1.1.1.2
log
@perl 5.8.3 from CPAN
@
text
@d11 1
a11 1
plan tests => 5;
a27 84




# second part using an emulation of the PERL_HASH in perl, mounting an
# attack on a prepopulated hash. This is also useful if you need normal
# keys which don't contain \0 -- suitable for stashes

use constant MASK_U32  => 2**32;
use constant HASH_SEED => 0;
use constant THRESHOLD => 14;
use constant START     => "a";

# some initial hash data
my %h2 = map {$_ => 1} 'a'..'cc';

ok (!Internals::HvREHASH(%h2), 
    "starting with pre-populated non-pathalogical hash (rehash flag if off)");

my @@keys = get_keys(\%h2);
$h2{$_}++ for @@keys;
ok (Internals::HvREHASH(%h2), 
    scalar(@@keys) . " colliding into the same bucket keys are triggerring rehash");

sub get_keys {
    my $hr = shift;

    # the minimum of bits required to mount the attack on a hash
    my $min_bits = log(THRESHOLD)/log(2);

    # if the hash has already been populated with a significant amount
    # of entries the number of mask bits can be higher
    my $keys = scalar keys %$hr;
    my $bits = $keys ? log($keys)/log(2) : 0;
    $bits = $min_bits if $min_bits > $bits;

    $bits = int($bits) < $bits ? int($bits) + 1 : int($bits);
    # need to add 2 bits to cover the internal split cases
    $bits += 2;
    my $mask = 2**$bits-1;
    print "# using mask: $mask ($bits)\n";

    my @@keys;
    my $s = START;
    my $c = 0;
    # get 2 keys on top of the THRESHOLD
    my $hash;
    while (@@keys < THRESHOLD+2) {
        # next if exists $hash->{$s};
        $hash = hash($s);
        next unless ($hash & $mask) == 0;
        $c++;
        printf "# %2d: %5s, %10s\n", $c, $s, $hash;
        push @@keys, $s;
    } continue {
        $s++;
    }

    return @@keys;
}


# trying to provide the fastest equivalent of C macro's PERL_HASH in
# Perl - the main complication is that it uses U32 integer, which we
# can't do it perl, without doing some tricks
sub hash {
    my $s = shift;
    my @@c = split //, $s;
    my $u = HASH_SEED;
    for (@@c) {
        # (A % M) + (B % M) == (A + B) % M
        # This works because '+' produces a NV, which is big enough to hold
        # the intermidiate result. We only need the % before any "^" and "&"
        # to get the result in the range for an I32.
        # and << doesn't work on NV, so using 1 << 10
        $u += ord;
        $u += $u * (1 << 10); $u %= MASK_U32;
        $u ^= $u >> 6;
    }
    $u += $u << 3;  $u %= MASK_U32;
    $u ^= $u >> 11; $u %= MASK_U32;
    $u += $u << 15; $u %= MASK_U32;
    $u;
}
@


1.1.1.3
log
@import perl 5.10.0 from CPAN
@
text
@d11 1
a11 1
plan tests => 6;
d33 1
a33 1
# attack on a pre-populated hash. This is also useful if you need normal
d45 1
a45 1
    "starting with pre-populated non-pathological hash (rehash flag if off)");
d50 1
a50 1
    scalar(@@keys) . " colliding into the same bucket keys are triggering rehash");
d100 1
a100 1
        # the intermediate result. We only need the % before any "^" and "&"
a111 9

# This will crash perl if it fails

use constant PVBM => 'foo';

my $dummy = index 'foo', PVBM;
eval { my %h = (a => PVBM); 1 };

ok (!$@@, 'fbm scalar can be inserted into a hash');
@


1.1.1.4
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d11 1
a11 1
plan tests => 15;
d42 1
a42 3
my %h2;
my $counter= "a";
$h2{$counter++}++ while $counter ne 'cd';
a47 1
my $buckets= buckets(\%h2);
a48 1
$h2{$counter++}++ while buckets(\%h2) == $buckets; # force a split
d50 1
a50 12
    scalar(@@keys) . " colliding into the same bucket keys are triggering rehash after split");

# returns the number of buckets in a hash
sub buckets {
    my $hr = shift;
    my $keys_buckets= scalar(%$hr);
    if ($keys_buckets=~m!/([0-9]+)\z!) {
        return 0+$1;
    } else {
        return 8;
    }
}
d57 1
a120 99


my $destroyed;
{ package Class; DESTROY { ++$destroyed; } }

$destroyed = 0;
{
    my %h;
    keys(%h) = 1;
    $h{key} = bless({}, 'Class');
}
is($destroyed, 1, 'Timely hash destruction with lvalue keys');


# [perl #79178] Hash keys must not be stringified during compilation
# Run perl -MO=Concise -e '$a{\"foo"}' on a non-threaded pre-5.13.8 version
# to see why.
{
    my $key;
    package bar;
    sub TIEHASH { bless {}, $_[0] }
    sub FETCH { $key = $_[1] }
    package main;
    tie my %h, "bar";
    () = $h{\'foo'};
    is ref $key, SCALAR =>
     'hash keys are not stringified during compilation';
}

# Part of RT #85026: Deleting the current iterator in void context does not
# free it.
{
    my $gone;
    no warnings 'once';
    local *::DESTROY = sub { ++$gone };
    my %a=(a=>bless[]);
    each %a;   # make the entry with the obj the current iterator
    delete $a{a};
    ok $gone, 'deleting the current iterator in void context frees the val'
}

# [perl #99660] Deleted hash element visible to destructor
{
    my %h;
    $h{k} = bless [];
    my $normal_exit;
    local *::DESTROY = sub { my $x = $h{k}; ++$normal_exit };
    delete $h{k}; # must be in void context to trigger the bug
    ok $normal_exit, 'freed hash elems are not visible to DESTROY';
}

# [perl #100340] Similar bug: freeing a hash elem during a delete
sub guard::DESTROY {
   ${$_[0]}->();
};
*guard = sub (&) {
   my $callback = shift;
   return bless \$callback, "guard"
};
{
  my $ok;
  my %t; %t = (
    stash => {
        guard => guard(sub{
            $ok++;
            delete $t{stash};
        }),
        foo => "bar",
        bar => "baz",
    },
  );
  ok eval { delete $t{stash}{guard}; # must be in void context
            1 },
    'freeing a hash elem from destructor called by delete does not die';
  diag $@@ if $@@; # panic: free from wrong pool
  is $ok, 1, 'the destructor was called';
}

# Weak references to pad hashes
SKIP: {
    skip_if_miniperl("No Scalar::Util::weaken under miniperl", 1);
    my $ref;
    require Scalar::Util;
    {
        my %hash;
        Scalar::Util::weaken($ref = \%hash);
        1;  # the previous statement must not be the last
    }
    is $ref, undef, 'weak refs to pad hashes go stale on scope exit';
}

# [perl #107440]
sub A::DESTROY { $::ra = 0 }
$::ra = {a=>bless [], 'A'};
undef %$::ra;
pass 'no crash when freeing hash that is being undeffed';
$::ra = {a=>bless [], 'A'};
%$::ra = ('a'..'z');
pass 'no crash when freeing hash that is being exonerated, ahem, cleared';
@


1.1.1.5
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d11 115
a125 1
plan tests => 10;
@


1.1.1.6
log
@Import perl-5.20.1
@
text
@d11 2
d47 1
a47 6
     'ref hash keys are not stringified during compilation';
    use constant u => undef;
    no warnings 'uninitialized'; # work around unfixed bug #105918
    () = $h{+u};
    is $key, undef,
      'undef hash keys are not stringified during compilation, either';
a119 88

# If I have these correct then removing any part of the lazy hash fill handling
# code in hv.c will cause some of these tests to start failing.
sub validate_hash {
  my ($desc, $h) = @@_;
  local $::Level = $::Level + 1;

  my $scalar = %$h;
  my $expect = qr!\A(\d+)/(\d+)\z!;
  like($scalar, $expect, "$desc in scalar context matches pattern");
  my ($used, $total) = $scalar =~ $expect;
  cmp_ok($total, '>', 0, "$desc has >0 array size ($total)");
  cmp_ok($used, '>', 0, "$desc uses >0 heads ($used)");
  cmp_ok($used, '<=', $total,
         "$desc doesn't use more heads than are available");
  return ($used, $total);
}

sub torture_hash {
  my $desc = shift;
  # Intentionally use an anon hash rather than a lexical, as lexicals default
  # to getting reused on subsequent calls
  my $h = {};
  ++$h->{$_} foreach @@_;

  my ($used0, $total0) = validate_hash($desc, $h);
  # Remove half the keys each time round, until there are only 1 or 2 left
  my @@groups;
  my ($h2, $h3, $h4);
  while (keys %$h > 2) {
    my $take = (keys %$h) / 2 - 1;
    my @@keys = (keys %$h)[0 .. $take];
    my $scalar = %$h;
    delete @@$h{@@keys};
    push @@groups, $scalar, \@@keys;

    my $count = keys %$h;
    my ($used, $total) = validate_hash("$desc (-$count)", $h);
    is($total, $total0, "$desc ($count) has same array size");
    cmp_ok($used, '<=', $used0, "$desc ($count) has same or fewer heads");
    ++$h2->{$_} foreach @@keys;
    my (undef, $total2) = validate_hash("$desc (+$count)", $h2);
    cmp_ok($total2, '<=', $total0, "$desc ($count) array size no larger");

    # Each time this will get emptied then repopulated. If the fill isn't reset
    # when the hash is emptied, the used count will likely exceed the array
    %$h3 = %$h2;
    my (undef, $total3) = validate_hash("$desc (+$count copy)", $h3);
    is($total3, $total2, "$desc (+$count copy) has same array size");

    # This might use fewer buckets than the original
    %$h4 = %$h;
    my (undef, $total4) = validate_hash("$desc ($count copy)", $h4);
    cmp_ok($total4, '<=', $total0, "$desc ($count copy) array size no larger");
  }

  my $scalar = %$h;
  my @@keys = keys %$h;
  delete @@$h{@@keys};
  is(scalar %$h, 0, "scalar keys for empty $desc");

  # Rebuild the original hash, and build a copy
  # These will fail if hash key addition and deletion aren't handled correctly
  my $h1;
  foreach (@@keys) {
    ++$h->{$_};
    ++$h1->{$_};
  }
  is(scalar %$h, $scalar, "scalar keys restored when rebuilding");

  while (@@groups) {
    my $keys = pop @@groups;
    ++$h->{$_} foreach @@$keys;
    my (undef, $total) = validate_hash("$desc " . keys %$h, $h);
    is($total, $total0, "bucket count is constant when rebuilding");
    is(scalar %$h, pop @@groups, "scalar keys is identical when rebuilding");
    ++$h1->{$_} foreach @@$keys;
    validate_hash("$desc copy " . keys %$h1, $h1);
  }
  # This will fail if the fill count isn't handled correctly on hash split
  is(scalar %$h1, scalar %$h, "scalar keys is identical on copy and original");
}

torture_hash('a .. zz', 'a' .. 'zz');
torture_hash('0 .. 9', 0 .. 9);
torture_hash("'Perl'", 'Rules');

done_testing();
@


1.1.1.7
log
@Import perl-5.24.2
@
text
@d5 1
a6 1
    set_up_inc('../lib');
a208 7

{
    my %h = qw(a x b y c z);
    no warnings qw(misc uninitialized);
    %h = $h{a};
    is(join(':', %h), 'x:', 'hash self-assign');
}
@


1.1.1.3.16.1
log
@Apply patch from RedHat to address CVE-2013-1667, perl: DoS in rehashing code
For more information please refer to: http://code.activestate.com/lists/perl5-porters/191311/

ok millert@@
@
text
@d42 1
a42 3
my %h2;
my $counter= "a";
$h2{$counter++}++ while $counter ne 'cd';
a47 1
my $buckets= buckets(\%h2);
a48 1
$h2{$counter++}++ while buckets(\%h2) == $buckets; # force a split
d50 1
a50 12
    scalar(@@keys) . " colliding into the same bucket keys are triggering rehash after split");

# returns the number of buckets in a hash
sub buckets {
    my $hr = shift;
    my $keys_buckets= scalar(%$hr);
    if ($keys_buckets=~m!/([0-9]+)\z!) {
        return 0+$1;
    } else {
        return 8;
    }
}
d57 1
@


