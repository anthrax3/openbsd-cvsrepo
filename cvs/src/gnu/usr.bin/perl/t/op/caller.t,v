head	1.2;
access;
symbols
	OPENBSD_6_1:1.2.0.2
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.8.0.10
	OPENBSD_6_0_BASE:1.1.1.8
	OPENBSD_5_9:1.1.1.8.0.4
	OPENBSD_5_9_BASE:1.1.1.8
	OPENBSD_5_8:1.1.1.8.0.6
	OPENBSD_5_8_BASE:1.1.1.8
	PERL_5_20_2:1.1.1.8
	OPENBSD_5_7:1.1.1.8.0.2
	OPENBSD_5_7_BASE:1.1.1.8
	PERL_5_20_1:1.1.1.8
	OPENBSD_5_6:1.1.1.7.0.4
	OPENBSD_5_6_BASE:1.1.1.7
	PERL_5_18_2:1.1.1.7
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.6.0.6
	OPENBSD_5_5_BASE:1.1.1.6
	OPENBSD_5_4:1.1.1.6.0.2
	OPENBSD_5_4_BASE:1.1.1.6
	PERL_5_16_3:1.1.1.6
	OPENBSD_5_3:1.1.1.5.0.10
	OPENBSD_5_3_BASE:1.1.1.5
	OPENBSD_5_2:1.1.1.5.0.8
	OPENBSD_5_2_BASE:1.1.1.5
	OPENBSD_5_1_BASE:1.1.1.5
	OPENBSD_5_1:1.1.1.5.0.6
	OPENBSD_5_0:1.1.1.5.0.4
	OPENBSD_5_0_BASE:1.1.1.5
	OPENBSD_4_9:1.1.1.5.0.2
	OPENBSD_4_9_BASE:1.1.1.5
	PERL_5_12_2:1.1.1.5
	OPENBSD_4_8:1.1.1.4.0.4
	OPENBSD_4_8_BASE:1.1.1.4
	OPENBSD_4_7:1.1.1.4.0.2
	OPENBSD_4_7_BASE:1.1.1.4
	PERL_5_10_1:1.1.1.4
	OPENBSD_4_6:1.1.1.3.0.6
	OPENBSD_4_6_BASE:1.1.1.3
	OPENBSD_4_5:1.1.1.3.0.2
	OPENBSD_4_5_BASE:1.1.1.3
	PERL_5_10_0:1.1.1.3
	OPENBSD_4_4:1.1.1.2.0.10
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.8
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_2:1.1.1.2.0.6
	OPENBSD_4_2_BASE:1.1.1.2
	OPENBSD_4_1:1.1.1.2.0.4
	OPENBSD_4_1_BASE:1.1.1.2
	OPENBSD_4_0:1.1.1.2.0.2
	OPENBSD_4_0_BASE:1.1.1.2
	PERL_5_8_8:1.1.1.2
	OPENBSD_3_9:1.1.1.1.0.14
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.12
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.10
	OPENBSD_3_7_BASE:1.1.1.1
	PERL_5_8_6:1.1.1.1
	OPENBSD_3_6:1.1.1.1.0.8
	OPENBSD_3_6_BASE:1.1.1.1
	PERL_5_8_5:1.1.1.1
	PERL_5_8_3:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.6
	OPENBSD_3_5_BASE:1.1.1.1
	PERL_5_8_2:1.1.1.1
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	PERL_5_8_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.32.20;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2002.10.27.22.15.10;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.27.22.15.10;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2006.03.28.18.49.44;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2008.09.29.17.19.00;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2009.10.12.18.10.45;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2010.09.24.14.49.17;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2013.03.25.20.09.35;	author sthen;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2014.03.24.14.59.10;	author afresh1;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2014.11.17.20.53.17;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl
# Tests for caller()

BEGIN {
    chdir 't' if -d 't';
    @@INC = '../lib';
    require './test.pl';
    plan( tests => 96 );
}

my @@c;

BEGIN { print "# Tests with caller(0)\n"; }

@@c = caller(0);
ok( (!@@c), "caller(0) in main program" );

eval { @@c = caller(0) };
is( $c[3], "(eval)", "subroutine name in an eval {}" );
ok( !$c[4], "hasargs false in an eval {}" );

eval q{ @@c = caller(0) };
is( $c[3], "(eval)", "subroutine name in an eval ''" );
ok( !$c[4], "hasargs false in an eval ''" );

sub { @@c = caller(0) } -> ();
is( $c[3], "main::__ANON__", "anonymous subroutine name" );
ok( $c[4], "hasargs true with anon sub" );

# Bug 20020517.003, used to dump core
sub foo { @@c = caller(0) }
my $fooref = delete $::{foo};
$fooref -> ();
is( $c[3], "main::foo", "deleted subroutine name" );
ok( $c[4], "hasargs true with deleted sub" );

BEGIN {
 require strict;
 is +(caller 0)[1], __FILE__,
  "[perl #68712] filenames after require in a BEGIN block"
}

print "# Tests with caller(1)\n";

sub f { @@c = caller(1) }

sub callf { f(); }
callf();
is( $c[3], "main::callf", "subroutine name" );
ok( $c[4], "hasargs true with callf()" );
&callf;
ok( !$c[4], "hasargs false with &callf" );

eval { f() };
is( $c[3], "(eval)", "subroutine name in an eval {}" );
ok( !$c[4], "hasargs false in an eval {}" );

eval q{ f() };
is( $c[3], "(eval)", "subroutine name in an eval ''" );
ok( !$c[4], "hasargs false in an eval ''" );

sub { f() } -> ();
is( $c[3], "main::__ANON__", "anonymous subroutine name" );
ok( $c[4], "hasargs true with anon sub" );

sub foo2 { f() }
my $fooref2 = delete $::{foo2};
$fooref2 -> ();
is( $c[3], "main::foo2", "deleted subroutine name" );
ok( $c[4], "hasargs true with deleted sub" );

# See if caller() returns the correct warning mask

sub show_bits
{
    my $in = shift;
    my $out = '';
    foreach (unpack('W*', $in)) {
        $out .= sprintf('\x%02x', $_);
    }
    return $out;
}

sub check_bits
{
    local $Level = $Level + 2;
    my ($got, $exp, $desc) = @@_;
    if (! ok($got eq $exp, $desc)) {
        diag('     got: ' . show_bits($got));
        diag('expected: ' . show_bits($exp));
    }
}

sub testwarn {
    my $w = shift;
    my $id = shift;
    check_bits( (caller(0))[9], $w, "warnings match caller ($id)");
}

{
    no warnings;
    # Build the warnings mask dynamically
    my ($default, $registered);
    BEGIN {
	for my $i (0..$warnings::LAST_BIT/2 - 1) {
	    vec($default, $i, 2) = 1;
	}
	$registered = $default;
	vec($registered, $warnings::LAST_BIT/2, 2) = 1;
    }

    BEGIN { check_bits( ${^WARNING_BITS}, "\0" x $warnings::BYTES, 'all bits off via "no warnings"' ) }
    testwarn("\0" x $warnings::BYTES, 'no bits');

    use warnings;
    BEGIN { check_bits( ${^WARNING_BITS}, $default,
			'default bits on via "use warnings"' ); }
    BEGIN { testwarn($default, 'all'); }
    # run-time :
    # the warning mask has been extended by warnings::register
    testwarn($registered, 'ahead of w::r');

    use warnings::register;
    BEGIN { check_bits( ${^WARNING_BITS}, $registered,
			'warning bits on via "use warnings::register"' ) }
    testwarn($registered, 'following w::r');
}


# The next two cases test for a bug where caller ignored evals if
# the DB::sub glob existed but &DB::sub did not (for example, if 
# $^P had been set but no debugger has been loaded).  The tests
# thus assume that there is no &DB::sub: if there is one, they 
# should both pass  no matter whether or not this bug has been
# fixed.

my $debugger_test =  q<
    my @@stackinfo = caller(0);
    return scalar @@stackinfo;
>;

sub pb { return (caller(0))[3] }

my $i = eval $debugger_test;
is( $i, 11, "do not skip over eval (and caller returns 10 elements)" );

is( eval 'pb()', 'main::pb', "actually return the right function name" );

my $saved_perldb = $^P;
$^P = 16;
$^P = $saved_perldb;

$i = eval $debugger_test;
is( $i, 11, 'do not skip over eval even if $^P had been on at some point' );
is( eval 'pb()', 'main::pb', 'actually return the right function name even if $^P had been on at some point' );

print "# caller can now return the compile time state of %^H\n";

sub hint_exists {
    my $key = shift;
    my $level = shift;
    my @@results = caller($level||0);
    exists $results[10]->{$key};
}

sub hint_fetch {
    my $key = shift;
    my $level = shift;
    my @@results = caller($level||0);
    $results[10]->{$key};
}

{
    my $tmpfile = tempfile();

    open my $fh, '>', $tmpfile or die "open $tmpfile: $!";
    print $fh <<'EOP';
#!perl -wl
use strict;

{
    package KAZASH ;

    sub DESTROY {
	print "DESTROY";
    }
}

@@DB::args = bless [], 'KAZASH';

print $^P;
print scalar @@DB::args;

{
    local $^P = shift;
}

@@DB::args = (); # At this point, the object should be freed.

print $^P;
print scalar @@DB::args;

# It shouldn't leak.
EOP
    close $fh;

    foreach (0, 1) {
        my $got = runperl(progfile => $tmpfile, args => [$_]);
        $got =~ s/\s+/ /gs;
        like($got, qr/\s*0 1 DESTROY 0 0\s*/,
             "\@@DB::args doesn't leak with \$^P = $_");
    }
}

# This also used to leak [perl #97010]:
{
    my $gone;
    sub fwib::DESTROY { ++$gone }
    package DB;
    sub { () = caller(0) }->(); # initialise PL_dbargs
    @@args = bless[],'fwib';
    sub { () = caller(0) }->(); # clobber @@args without initialisation
    ::is $gone, 1, 'caller does not leak @@DB::args elems when AvREAL';
}

# And this crashed [perl #93320]:
sub {
  package DB;
  ()=caller(0);
  undef *DB::args;
  ()=caller(0);
}->();
pass 'No crash when @@DB::args is freed between caller calls';

# This also crashed:
package glelp;
sub TIEARRAY { bless [] }
sub EXTEND   {         }
sub CLEAR    {        }
sub FETCH    { $_[0][$_[1]] }
sub STORE    { $_[0][$_[1]] = $_[2] }
package DB;
tie @@args, 'glelp';
eval { sub { () = caller 0; } ->(1..3) };
::like $@@, qr "^Cannot set tied \@@DB::args at ",
              'caller dies with tie @@DB::args';
::ok tied @@args, '@@DB::args is still tied';
untie @@args;
package main;

# [perl #113486]
fresh_perl_is <<'END', "ok\n", {},
  { package foo; sub bar { main::bar() } }
  sub bar {
    delete $::{"foo::"};
    my $x = \($1+2);
    my $y = \($1+2); # this is the one that reuses the mem addr, but
    my $z = \($1+2);  # try the others just in case
    s/2// for $$x, $$y, $$z; # now SvOOK
    $x = caller;
    print "ok\n";
};
foo::bar
END
    "No crash when freed stash is reused for PV with offset hack";

is eval "(caller 0)[6]", "(caller 0)[6]",
  'eval text returned by caller does not include \n;';

if (1) {
    is (sub { (caller)[2] }->(), __LINE__,
      '[perl #115768] caller gets line numbers from nulled cops');
}
# Test it at the end of the program, too.
fresh_perl_is(<<'115768', 2, {},
  if (1) {
    foo();
  }
  sub foo { print +(caller)[2] }
115768
    '[perl #115768] caller gets line numbers from nulled cops (2)');

# PL_linestr should not be modifiable
eval '"${;BEGIN{  ${\(caller 2)[6]} = *foo  }}"';
pass "no assertion failure after modifying eval text via caller";

is eval "<<END;\nfoo\nEND\n(caller 0)[6]",
        "<<END;\nfoo\nEND\n(caller 0)[6]",
        'here-docs do not gut eval text';
is eval "s//<<END/e;\nfoo\nEND\n(caller 0)[6]",
        "s//<<END/e;\nfoo\nEND\n(caller 0)[6]",
        'here-docs in quote-like ops do not gut eval text';

# The bitmask should be assignable to ${^WARNING_BITS} without resulting in
# different warnings settings.
{
 my $ bits = sub { (caller 0)[9] }->();
 my $w;
 local $SIG{__WARN__} = sub { $w++ };
 eval '
   use warnings;
   BEGIN { ${^WARNING_BITS} = $bits }
   local $^W = 1;
   () = 1 + undef;
   $^W = 0;
   () = 1 + undef;
 ';
 is $w, 1, 'value from (caller 0)[9] (bitmask) works in ${^WARNING_BITS}';
}

# [perl #126991]
sub getlineno { (caller)[2] }
my $line = eval "\n#line 3000000000\ngetlineno();";
is $line, "3000000000", "check large line numbers are preserved";

# This was fixed with commit d4d03940c58a0177, which fixed bug #78742
fresh_perl_is <<'END', "__ANON__::doof\n", {},
package foo;
BEGIN {undef %foo::}
sub doof { caller(0) }
print +(doof())[3];
END
    "caller should not SEGV when the current package is undefined";

# caller should not SEGV when the eval entry has been cleared #120998
fresh_perl_is <<'END', 'main', {},
$SIG{__DIE__} = \&dbdie;
eval '/x';
sub dbdie {
    @@x = caller(1);
    print $x[0];
}
END
    "caller should not SEGV for eval '' stack frames";

$::testing_caller = 1;

do './op/caller.pl' or die $@@;
@


1.1
log
@Initial revision
@
text
@d8 1
a10 2
plan( tests => 20 );

d13 1
a13 1
print "# Tests with caller(0)\n";
d22 1
a22 1
eval q{ @@c = (Caller(0))[3] };
d34 8
a41 2
is( $c[3], "(unknown)", "unknown subroutine name" );
ok( $c[4], "hasargs true with unknown sub" );
d69 270
a338 2
is( $c[3], "(unknown)", "unknown subroutine name" );
ok( $c[4], "hasargs true with unknown sub" );
@


1.1.1.1
log
@stock perl 5.8.0 from CPAN
@
text
@@


1.1.1.2
log
@perl 5.8.8 import
@
text
@a7 1
    plan( tests => 31 );
d10 2
a65 52

# See if caller() returns the correct warning mask

sub testwarn {
    my $w = shift;
    is( (caller(0))[9], $w, "warnings");
}

# NB : extend the warning mask values below when new warnings are added
{
    no warnings;
    BEGIN { is( ${^WARNING_BITS}, "\0" x 12, 'warning bits' ) }
    testwarn("\0" x 12);
    use warnings;
    BEGIN { is( ${^WARNING_BITS}, "UUUUUUUUUUU\25", 'warning bits' ) }
    BEGIN { testwarn("UUUUUUUUUUU\25"); }
    # run-time :
    # the warning mask has been extended by warnings::register
    testwarn("UUUUUUUUUUUU");
    use warnings::register;
    BEGIN { is( ${^WARNING_BITS}, "UUUUUUUUUUUU", 'warning bits' ) }
    testwarn("UUUUUUUUUUUU");
}


# The next two cases test for a bug where caller ignored evals if
# the DB::sub glob existed but &DB::sub did not (for example, if 
# $^P had been set but no debugger has been loaded).  The tests
# thus assume that there is no &DB::sub: if there is one, they 
# should both pass  no matter whether or not this bug has been
# fixed.

my $debugger_test =  q<
    my @@stackinfo = caller(0);
    return scalar @@stackinfo;
>;

sub pb { return (caller(0))[3] }

my $i = eval $debugger_test;
is( $i, 10, "do not skip over eval (and caller returns 10 elements)" );

is( eval 'pb()', 'main::pb', "actually return the right function name" );

my $saved_perldb = $^P;
$^P = 16;
$^P = $saved_perldb;

$i = eval $debugger_test;
is( $i, 10, 'do not skip over eval even if $^P had been on at some point' );
is( eval 'pb()', 'main::pb', 'actually return the right function name even if $^P had been on at some point' );

@


1.1.1.3
log
@import perl 5.10.0 from CPAN
@
text
@d8 1
a8 1
    plan( tests => 78 );
a67 19
sub show_bits
{
    my $in = shift;
    my $out = '';
    foreach (unpack('W*', $in)) {
        $out .= sprintf('\x%02x', $_);
    }
    return $out;
}

sub check_bits
{
    my ($got, $exp, $desc) = @@_;
    if (! ok($got eq $exp, $desc)) {
        diag('     got: ' . show_bits($got));
        diag('expected: ' . show_bits($exp));
    }
}

d70 1
a70 2
    my $id = shift;
    check_bits( (caller(0))[9], $w, "warnings match caller ($id)");
d76 2
a77 3
    BEGIN { check_bits( ${^WARNING_BITS}, "\0" x 12, 'all bits off via "no warnings"' ) }
    testwarn("\0" x 12, 'no bits');

d79 2
a80 2
    BEGIN { check_bits( ${^WARNING_BITS}, "\x55\x55\x55\x55\x55\x55\x55\x55\x55\x55\x55\x05", 'default bits on via "use warnings"' ); }
    BEGIN { testwarn("\x55\x55\x55\x55\x55\x55\x55\x55\x55\x55\x55\x05", 'all'); }
d83 1
a83 2
    testwarn("\x55\x55\x55\x55\x55\x55\x55\x55\x55\x55\x55\x15", 'ahead of w::r');

d85 2
a86 2
    BEGIN { check_bits( ${^WARNING_BITS}, "\x55\x55\x55\x55\x55\x55\x55\x55\x55\x55\x55\x15", 'warning bits on via "use warnings::register"' ) }
    testwarn("\x55\x55\x55\x55\x55\x55\x55\x55\x55\x55\x55\x15", 'following w::r');
d105 1
a105 1
is( $i, 11, "do not skip over eval (and caller returns 10 elements)" );
d114 1
a114 1
is( $i, 11, 'do not skip over eval even if $^P had been on at some point' );
a116 19
print "# caller can now return the compile time state of %^H\n";

sub hint_exists {
    my $key = shift;
    my $level = shift;
    my @@results = caller($level||0);
    exists $results[10]->{$key};
}

sub hint_fetch {
    my $key = shift;
    my $level = shift;
    my @@results = caller($level||0);
    $results[10]->{$key};
}

$::testing_caller = 1;

do './op/caller.pl' or die $@@;
@


1.1.1.4
log
@import perl 5.10.1
@
text
@a79 1
    local $Level = $Level + 2;
d93 1
a95 9
    # Build the warnings mask dynamically
    my ($default, $registered);
    BEGIN {
	for my $i (0..$warnings::LAST_BIT/2 - 1) {
	    vec($default, $i, 2) = 1;
	}
	$registered = $default;
	vec($registered, $warnings::LAST_BIT/2, 2) = 1;
    }
d100 2
a101 3
    BEGIN { check_bits( ${^WARNING_BITS}, $default,
			'default bits on via "use warnings"' ); }
    BEGIN { testwarn($default, 'all'); }
d104 1
a104 1
    testwarn($registered, 'ahead of w::r');
d107 2
a108 3
    BEGIN { check_bits( ${^WARNING_BITS}, $registered,
			'warning bits on via "use warnings::register"' ) }
    testwarn($registered, 'following w::r');
@


1.1.1.5
log
@Perl 5.12.2 from CPAN
@
text
@d8 1
a8 1
    plan( tests => 80 );
a163 42
}

{
    my $tmpfile = tempfile();

    open my $fh, '>', $tmpfile or die "open $tmpfile: $!";
    print $fh <<'EOP';
#!perl -wl
use strict;

{
    package KAZASH ;

    sub DESTROY {
	print "DESTROY";
    }
}

@@DB::args = bless [], 'KAZASH';

print $^P;
print scalar @@DB::args;

{
    local $^P = shift;
}

@@DB::args = (); # At this point, the object should be freed.

print $^P;
print scalar @@DB::args;

# It shouldn't leak.
EOP
    close $fh;

    foreach (0, 1) {
        my $got = runperl(progfile => $tmpfile, args => [$_]);
        $got =~ s/\s+/ /gs;
        like($got, qr/\s*0 1 DESTROY 0 0\s*/,
             "\@@DB::args doesn't leak with \$^P = $_");
    }
@


1.1.1.6
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d8 1
a8 1
    plan( tests => 85 );
d13 1
a13 1
BEGIN { print "# Tests with caller(0)\n"; }
d34 2
a35 8
is( $c[3], "main::__ANON__", "deleted subroutine name" );
ok( $c[4], "hasargs true with deleted sub" );

BEGIN {
 require strict;
 is +(caller 0)[1], __FILE__,
  "[perl #68712] filenames after require in a BEGIN block"
}
d63 2
a64 2
is( $c[3], "main::__ANON__", "deleted subroutine name" );
ok( $c[4], "hasargs true with deleted sub" );
d105 2
a106 5

    # The repetition number must be set to the value of $BYTES in
    # lib/warnings.pm
    BEGIN { check_bits( ${^WARNING_BITS}, "\0" x 13, 'all bits off via "no warnings"' ) }
    testwarn("\0" x 13, 'no bits');
a206 36

# This also used to leak [perl #97010]:
{
    my $gone;
    sub fwib::DESTROY { ++$gone }
    package DB;
    sub { () = caller(0) }->(); # initialise PL_dbargs
    @@args = bless[],'fwib';
    sub { () = caller(0) }->(); # clobber @@args without initialisation
    ::is $gone, 1, 'caller does not leak @@DB::args elems when AvREAL';
}

# And this crashed [perl #93320]:
sub {
  package DB;
  ()=caller(0);
  undef *DB::args;
  ()=caller(0);
}->();
pass 'No crash when @@DB::args is freed between caller calls';

# This also crashed:
package glelp;
sub TIEARRAY { bless [] }
sub EXTEND   {         }
sub CLEAR    {        }
sub FETCH    { $_[0][$_[1]] }
sub STORE    { $_[0][$_[1]] = $_[2] }
package DB;
tie @@args, 'glelp';
eval { sub { () = caller 0; } ->(1..3) };
::like $@@, qr "^Cannot set tied \@@DB::args at ",
              'caller dies with tie @@DB::args';
::ok tied @@args, '@@DB::args is still tied';
untie @@args;
package main;
@


1.1.1.7
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d8 1
a8 1
    plan( tests => 91 );
d22 1
a22 1
eval q{ @@c = caller(0) };
d114 2
a115 2
    BEGIN { check_bits( ${^WARNING_BITS}, "\0" x 14, 'all bits off via "no warnings"' ) }
    testwarn("\0" x 14, 'no bits');
a251 47

# [perl #113486]
fresh_perl_is <<'END', "ok\n", {},
  { package foo; sub bar { main::bar() } }
  sub bar {
    delete $::{"foo::"};
    my $x = \($1+2);
    my $y = \($1+2); # this is the one that reuses the mem addr, but
    my $z = \($1+2);  # try the others just in case
    s/2// for $$x, $$y, $$z; # now SvOOK
    $x = caller;
    print "ok\n";
};
foo::bar
END
    "No crash when freed stash is reused for PV with offset hack";

is eval "(caller 0)[6]", "(caller 0)[6]",
  'eval text returned by caller does not include \n;';

# PL_linestr should not be modifiable
eval '"${;BEGIN{  ${\(caller 2)[6]} = *foo  }}"';
pass "no assertion failure after modifying eval text via caller";

is eval "<<END;\nfoo\nEND\n(caller 0)[6]",
        "<<END;\nfoo\nEND\n(caller 0)[6]",
        'here-docs do not gut eval text';
is eval "s//<<END/e;\nfoo\nEND\n(caller 0)[6]",
        "s//<<END/e;\nfoo\nEND\n(caller 0)[6]",
        'here-docs in quote-like ops do not gut eval text';

# The bitmask should be assignable to ${^WARNING_BITS} without resulting in
# different warnings settings.
{
 my $ bits = sub { (caller 0)[9] }->();
 my $w;
 local $SIG{__WARN__} = sub { $w++ };
 eval '
   use warnings;
   BEGIN { ${^WARNING_BITS} = $bits }
   local $^W = 1;
   () = 1 + undef;
   $^W = 0;
   () = 1 + undef;
 ';
 is $w, 1, 'value from (caller 0)[9] (bitmask) works in ${^WARNING_BITS}';
}
@


1.1.1.8
log
@Import perl-5.20.1
@
text
@d8 1
a8 1
    plan( tests => 95 );
d114 2
a115 2
    BEGIN { check_bits( ${^WARNING_BITS}, "\0" x 15, 'all bits off via "no warnings"' ) }
    testwarn("\0" x 15, 'no bits');
a271 13
if (1) {
    is (sub { (caller)[2] }->(), __LINE__,
      '[perl #115768] caller gets line numbers from nulled cops');
}
# Test it at the end of the program, too.
fresh_perl_is(<<'115768', 2, {},
  if (1) {
    foo();
  }
  sub foo { print +(caller)[2] }
115768
    '[perl #115768] caller gets line numbers from nulled cops (2)');

a298 20

# This was fixed with commit d4d03940c58a0177, which fixed bug #78742
fresh_perl_is <<'END', "__ANON__::doof\n", {},
package foo;
BEGIN {undef %foo::}
sub doof { caller(0) }
print +(doof())[3];
END
    "caller should not SEGV when the current package is undefined";

# caller should not SEGV when the eval entry has been cleared #120998
fresh_perl_is <<'END', 'main', {},
$SIG{__DIE__} = \&dbdie;
eval '/x';
sub dbdie {
    @@x = caller(1);
    print $x[0];
}
END
    "caller should not SEGV for eval '' stack frames";
@


