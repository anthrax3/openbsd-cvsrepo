head	1.9;
access;
symbols
	OPENBSD_6_2:1.9.0.20
	OPENBSD_6_2_BASE:1.9
	PERL_5_24_2:1.1.1.5
	OPENBSD_6_1:1.9.0.18
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.16
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.10
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.9.0.12
	OPENBSD_5_8_BASE:1.9
	PERL_5_20_2:1.1.1.5
	OPENBSD_5_7:1.9.0.4
	OPENBSD_5_7_BASE:1.9
	PERL_5_20_1:1.1.1.5
	OPENBSD_5_6:1.9.0.8
	OPENBSD_5_6_BASE:1.9
	PERL_5_18_2:1.1.1.5
	PERL:1.1.1
	OPENBSD_5_5:1.9.0.6
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.2
	OPENBSD_5_4_BASE:1.9
	PERL_5_16_3:1.1.1.5
	OPENBSD_5_3:1.8.0.10
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.8
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.6
	OPENBSD_5_0:1.8.0.4
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.2
	OPENBSD_4_9_BASE:1.8
	PERL_5_12_2:1.1.1.4
	OPENBSD_4_8:1.7.0.8
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.4
	OPENBSD_4_7_BASE:1.7
	PERL_5_10_1:1.1.1.3
	OPENBSD_4_6:1.7.0.6
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.2
	OPENBSD_4_5_BASE:1.7
	PERL_5_10_0:1.1.1.3
	OPENBSD_4_4:1.6.0.24
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.22
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.20
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.18
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.16
	OPENBSD_4_0_BASE:1.6
	PERL_5_8_8:1.1.1.2
	OPENBSD_3_9:1.6.0.14
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.12
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.10
	OPENBSD_3_7_BASE:1.6
	PERL_5_8_6:1.1.1.2
	OPENBSD_3_6:1.6.0.8
	OPENBSD_3_6_BASE:1.6
	PERL_5_8_5:1.1.1.2
	PERL_5_8_3:1.1.1.2
	OPENBSD_3_5:1.6.0.6
	OPENBSD_3_5_BASE:1.6
	PERL_5_8_2:1.1.1.2
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.2
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.1
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.1
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.1
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.9
date	2013.03.25.20.41.00;	author sthen;	state Exp;
branches;
next	1.8;

1.8
date	2010.09.24.15.07.09;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2008.09.29.17.36.20;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.37;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.36.23;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.08.33;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.52.39;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.08.05.44;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.13.23;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.13.23;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.10.27.22.15.11;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2008.09.29.17.19.02;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2010.09.24.14.49.16;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.03.25.20.09.37;	author sthen;	state Exp;
branches;
next	;


desc
@@


1.9
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@#!./perl -w

BEGIN {
    chdir 't' if -d 't';
    @@INC = '../lib';
    require './test.pl';
}

watchdog(10);
plan(tests => 43);
use strict;
use vars '$x';

use Config;
my $have_alarm = $Config{d_alarm};

$x = "abc\ndef\n";
study($x);

ok($x =~ /^abc/);
ok($x !~ /^def/);

# used to be a test for $*
ok($x =~ /^def/m);

$_ = '123';
study;
ok(/^([0-9][0-9]*)/);

ok(!($x =~ /^xxx/));
ok(!($x !~ /^abc/));

ok($x =~ /def/);
ok(!($x !~ /def/));

study($x);
ok($x !~ /.def/);
ok(!($x =~ /.def/));

ok($x =~ /\ndef/);
ok(!($x !~ /\ndef/));

$_ = 'aaabbbccc';
study;
ok(/(a*b*)(c*)/);
is($1, 'aaabbb');
is($2,'ccc');
ok(/(a+b+c+)/);
is($1, 'aaabbbccc');

ok(!/a+b?c+/);

$_ = 'aaabccc';
study;
ok(/a+b?c+/);
ok(/a*b+c*/);

$_ = 'aaaccc';
study;
ok(/a*b?c*/);
ok(!/a*b+c*/);

$_ = 'abcdef';
study;
ok(/bcd|xyz/);
ok(/xyz|bcd/);

ok(m|bc/*d|);

ok(/^$_$/);

# used to be a test for $*
ok("ab\ncd\n" =~ /^cd/m);

TODO: {
    # Even with the alarm() OS/390 and BS2000 can't manage these tests
    # (Perl just goes into a busy loop, luckily an interruptable one)
    todo_skip('busy loop - compiler bug?', 2)
	      if $^O eq 'os390' or $^O eq 'posix-bc';

    # [ID ] tests 25..26 may loop

    $_ = 'FGF';
    study;
    ok(!/G.F$/, 'bug 20010618.006');
    ok(!/[F]F$/, 'bug 20010618.006');
}

{
    my $a = 'QaaQaabQaabbQ';
    study $a;
    my @@a = split /aab*/, $a;
    is("@@a", 'Q Q Q Q', 'split with studied string passed to the regep engine');
}

{
    $_ = "AABBAABB";
    study;
    is(s/AB+/1/ge, 2, 'studied scalar passed to pp_substconst');
    is($_, 'A1A1');
}

{
    $_ = "AABBAABB";
    study;
    is(s/(A)B+/1/ge, 2,
       'studied scalar passed to pp_substconst with RX_MATCH_COPIED() true');
    is($1, 'A');
    is($2, undef);
    is($_, 'A1A1');
}

{
    my @@got;
    $a = "ydydydyd";
    $b = "xdx";
    push @@got, $_ foreach $a =~ /[^x]d(?{})[^x]d/g;
    is("@@got", 'ydyd ydyd', '#92696 control');

    @@got = ();
    $a = "ydydydyd";
    $b = "xdx";
    study $a;
    push @@got, $_ foreach $a =~ /[^x]d(?{})[^x]d/g;
    is("@@got", 'ydyd ydyd', '#92696 study $a');

    @@got = ();
    $a = "ydydydyd";
    $b = "xdx";
    study $b;
    push @@got, $_ foreach $a =~ /[^x]d(?{})[^x]d/g;
    is("@@got", 'ydyd ydyd', '#92696 study $b');

    @@got = ();
    $a = "ydydydyd";
    $b = "xdx";
    push @@got, $_ foreach $a =~ /[^x]d(?{study $b})[^x]d/g;
    is("@@got", 'ydyd ydyd', '#92696 study $b inside (?{}), nothing studied');

    @@got = ();
    $a = "ydydydyd";
    $b = "xdx";
    my $c = 'zz';
    study $c;
    push @@got, $_ foreach $a =~ /[^x]d(?{study $b})[^x]d/g;
    is("@@got", 'ydyd ydyd', '#92696 study $b inside (?{}), $c studied');

    @@got = ();
    $a = "ydydydyd";
    $b = "xdx";
    study $a;
    push @@got, $_ foreach $a =~ /[^x]d(?{study $b})[^x]d/g;
    is("@@got", 'ydyd ydyd', '#92696 study $b inside (?{}), $a studied');

    @@got = ();
    $a = "ydydydyd";
    $b = "xdx";
    study $a;
    push @@got, $_ foreach $a =~ /[^x]d(?{$a .= ''})[^x]d/g;
    is("@@got", 'ydyd ydyd', '#92696 $a .= \'\' inside (?{}), $a studied');
}
@


1.8
log
@merge in perl 5.12.2 plus local changes
@
text
@d1 1
a1 1
#!./perl
d6 1
d9 4
a12 22
$Ok_Level = 0;
my $test = 1;
sub ok ($;$) {
    my($ok, $name) = @@_;

    local $_;

    # You have to do it this way or VMS will get confused.
    printf "%s $test%s\n", $ok   ? 'ok' : 'not ok',
                           $name ? " - $name" : '';

    printf "# Failed test at line %d\n", (caller($Ok_Level))[2] unless $ok;

    $test++;
    return $ok;
}

sub nok ($;$) {
    my($nok, $name) = @@_;
    local $Ok_Level = 1;
    ok( !$nok, $name );
}
a15 18
sub alarm_ok (&) {
    my $test = shift;

    local $SIG{ALRM} = sub { die "timeout\n" };
    
    my $match;
    eval { 
        alarm(2) if $have_alarm;
        $match = $test->();
        alarm(0) if $have_alarm;
    };

    local $Ok_Level = 1;
    ok( !$match && !$@@, 'testing studys that used to hang' );
}


print "1..26\n";
d30 2
a31 2
nok($x =~ /^xxx/);
nok($x !~ /^abc/);
d34 1
a34 1
nok($x !~ /def/);
d38 1
a38 1
nok($x =~ /.def/);
d41 1
a41 1
nok($x !~ /\ndef/);
d45 5
a49 2
ok(/(a*b*)(c*)/ && $1 eq 'aaabbb' && $2 eq 'ccc');
ok(/(a+b+c+)/ && $1 eq 'aaabbbccc');
d51 1
a51 1
nok(/a+b?c+/);
d61 1
a61 1
nok(/a*b+c*/);
d75 1
a75 1
if ($^O eq 'os390' or $^O eq 'posix-bc') {
d78 4
a81 4
    for (25..26) { print "not ok $_ # TODO compiler bug?\n" }
    $test += 2;
} else {
    # [ID 20010618.006] tests 25..26 may loop
d85 9
a93 2
    alarm_ok { /G.F$/ };
    alarm_ok { /[F]F$/ };
d96 66
@


1.7
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d107 1
a107 1
if ($^O eq 'os390' or $^O eq 'posix-bc' or $^O eq 'MacOS') {
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d58 2
a59 3
$* = 1;
ok($x =~ /^def/);
$* = 0;
d104 2
a105 2
$* = 1;	    # test 3 only tested the optimized version--this one is for real
ok("ab\ncd\n" =~ /^cd/);
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d3 46
a48 1
# $RCSfile: study.t,v $$Revision: 4.1 $$Date: 92/08/07 18:28:30 $
d50 1
a50 1
print "1..24\n";
d55 2
a56 2
if ($x =~ /^abc/) {print "ok 1\n";} else {print "not ok 1\n";}
if ($x !~ /^def/) {print "ok 2\n";} else {print "not ok 2\n";}
d59 1
a59 1
if ($x =~ /^def/) {print "ok 3\n";} else {print "not ok 3\n";}
d64 1
a64 1
if (/^([0-9][0-9]*)/) {print "ok 4\n";} else {print "not ok 4\n";}
d66 2
a67 2
if ($x =~ /^xxx/) {print "not ok 5\n";} else {print "ok 5\n";}
if ($x !~ /^abc/) {print "not ok 6\n";} else {print "ok 6\n";}
d69 2
a70 2
if ($x =~ /def/) {print "ok 7\n";} else {print "not ok 7\n";}
if ($x !~ /def/) {print "not ok 8\n";} else {print "ok 8\n";}
d73 2
a74 2
if ($x !~ /.def/) {print "ok 9\n";} else {print "not ok 9\n";}
if ($x =~ /.def/) {print "not ok 10\n";} else {print "ok 10\n";}
d76 2
a77 2
if ($x =~ /\ndef/) {print "ok 11\n";} else {print "not ok 11\n";}
if ($x !~ /\ndef/) {print "not ok 12\n";} else {print "ok 12\n";}
d81 2
a82 10
if (/(a*b*)(c*)/ && $1 eq 'aaabbb' && $2 eq 'ccc') {
	print "ok 13\n";
} else {
	print "not ok 13\n";
}
if (/(a+b+c+)/ && $1 eq 'aaabbbccc') {
	print "ok 14\n";
} else {
	print "not ok 14\n";
}
d84 1
a84 1
if (/a+b?c+/) {print "not ok 15\n";} else {print "ok 15\n";}
d88 2
a89 2
if (/a+b?c+/) {print "ok 16\n";} else {print "not ok 16\n";}
if (/a*b+c*/) {print "ok 17\n";} else {print "not ok 17\n";}
d93 2
a94 2
if (/a*b?c*/) {print "ok 18\n";} else {print "not ok 18\n";}
if (/a*b+c*/) {print "not ok 19\n";} else {print "ok 19\n";}
d98 2
a99 2
if (/bcd|xyz/) {print "ok 20\n";} else {print "not ok 20\n";}
if (/xyz|bcd/) {print "ok 21\n";} else {print "not ok 21\n";}
d101 1
a101 1
if (m|bc/*d|) {print "ok 22\n";} else {print "not ok 22\n";}
d103 18
a120 1
if (/^$_$/) {print "ok 23\n";} else {print "not ok 23\n";}
a121 2
$* = 1;		# test 3 only tested the optimized version--this one is for real
if ("ab\ncd\n" =~ /^cd/) {print "ok 24\n";} else {print "not ok 24\n";}
@


1.4
log
@perl-5.6.0 + local changes
@
text
@@


1.3
log
@perl5.005_03 (stock)
@
text
@@


1.2
log
@perl 5.004_04
@
text
@@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@stock perl 5.8.0 from CPAN
@
text
@d3 1
a3 46
BEGIN {
    chdir 't' if -d 't';
    @@INC = '../lib';
}

$Ok_Level = 0;
my $test = 1;
sub ok ($;$) {
    my($ok, $name) = @@_;

    local $_;

    # You have to do it this way or VMS will get confused.
    printf "%s $test%s\n", $ok   ? 'ok' : 'not ok',
                           $name ? " - $name" : '';

    printf "# Failed test at line %d\n", (caller($Ok_Level))[2] unless $ok;

    $test++;
    return $ok;
}

sub nok ($;$) {
    my($nok, $name) = @@_;
    local $Ok_Level = 1;
    ok( !$nok, $name );
}

use Config;
my $have_alarm = $Config{d_alarm};
sub alarm_ok (&) {
    my $test = shift;

    local $SIG{ALRM} = sub { die "timeout\n" };
    
    my $match;
    eval { 
        alarm(2) if $have_alarm;
        $match = $test->();
        alarm(0) if $have_alarm;
    };

    local $Ok_Level = 1;
    ok( !$match && !$@@, 'testing studys that used to hang' );
}

d5 1
a5 1
print "1..26\n";
d10 2
a11 2
ok($x =~ /^abc/);
ok($x !~ /^def/);
d14 1
a14 1
ok($x =~ /^def/);
d19 1
a19 1
ok(/^([0-9][0-9]*)/);
d21 2
a22 2
nok($x =~ /^xxx/);
nok($x !~ /^abc/);
d24 2
a25 2
ok($x =~ /def/);
nok($x !~ /def/);
d28 2
a29 2
ok($x !~ /.def/);
nok($x =~ /.def/);
d31 2
a32 2
ok($x =~ /\ndef/);
nok($x !~ /\ndef/);
d36 10
a45 2
ok(/(a*b*)(c*)/ && $1 eq 'aaabbb' && $2 eq 'ccc');
ok(/(a+b+c+)/ && $1 eq 'aaabbbccc');
d47 1
a47 1
nok(/a+b?c+/);
d51 2
a52 2
ok(/a+b?c+/);
ok(/a*b+c*/);
d56 2
a57 2
ok(/a*b?c*/);
nok(/a*b+c*/);
d61 2
a62 2
ok(/bcd|xyz/);
ok(/xyz|bcd/);
d64 1
a64 1
ok(m|bc/*d|);
d66 1
a66 18
ok(/^$_$/);

$* = 1;	    # test 3 only tested the optimized version--this one is for real
ok("ab\ncd\n" =~ /^cd/);

if ($^O eq 'os390' or $^O eq 'posix-bc' or $^O eq 'MacOS') {
    # Even with the alarm() OS/390 and BS2000 can't manage these tests
    # (Perl just goes into a busy loop, luckily an interruptable one)
    for (25..26) { print "not ok $_ # TODO compiler bug?\n" }
    $test += 2;
} else {
    # [ID 20010618.006] tests 25..26 may loop

    $_ = 'FGF';
    study;
    alarm_ok { /G.F$/ };
    alarm_ok { /[F]F$/ };
}
d68 2
@


1.1.1.3
log
@import perl 5.10.0 from CPAN
@
text
@d58 3
a60 2
# used to be a test for $*
ok($x =~ /^def/m);
d105 2
a106 2
# used to be a test for $*
ok("ab\ncd\n" =~ /^cd/m);
@


1.1.1.4
log
@Perl 5.12.2 from CPAN
@
text
@d107 1
a107 1
if ($^O eq 'os390' or $^O eq 'posix-bc') {
@


1.1.1.5
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d1 1
a1 1
#!./perl -w
a5 1
    require './test.pl';
d8 22
a29 4
watchdog(10);
plan(tests => 43);
use strict;
use vars '$x';
d33 18
d65 2
a66 2
ok(!($x =~ /^xxx/));
ok(!($x !~ /^abc/));
d69 1
a69 1
ok(!($x !~ /def/));
d73 1
a73 1
ok(!($x =~ /.def/));
d76 1
a76 1
ok(!($x !~ /\ndef/));
d80 2
a81 5
ok(/(a*b*)(c*)/);
is($1, 'aaabbb');
is($2,'ccc');
ok(/(a+b+c+)/);
is($1, 'aaabbbccc');
d83 1
a83 1
ok(!/a+b?c+/);
d93 1
a93 1
ok(!/a*b+c*/);
d107 1
a107 1
TODO: {
d110 4
a113 4
    todo_skip('busy loop - compiler bug?', 2)
	      if $^O eq 'os390' or $^O eq 'posix-bc';

    # [ID ] tests 25..26 may loop
d117 2
a118 9
    ok(!/G.F$/, 'bug 20010618.006');
    ok(!/[F]F$/, 'bug 20010618.006');
}

{
    my $a = 'QaaQaabQaabbQ';
    study $a;
    my @@a = split /aab*/, $a;
    is("@@a", 'Q Q Q Q', 'split with studied string passed to the regep engine');
a120 66
{
    $_ = "AABBAABB";
    study;
    is(s/AB+/1/ge, 2, 'studied scalar passed to pp_substconst');
    is($_, 'A1A1');
}

{
    $_ = "AABBAABB";
    study;
    is(s/(A)B+/1/ge, 2,
       'studied scalar passed to pp_substconst with RX_MATCH_COPIED() true');
    is($1, 'A');
    is($2, undef);
    is($_, 'A1A1');
}

{
    my @@got;
    $a = "ydydydyd";
    $b = "xdx";
    push @@got, $_ foreach $a =~ /[^x]d(?{})[^x]d/g;
    is("@@got", 'ydyd ydyd', '#92696 control');

    @@got = ();
    $a = "ydydydyd";
    $b = "xdx";
    study $a;
    push @@got, $_ foreach $a =~ /[^x]d(?{})[^x]d/g;
    is("@@got", 'ydyd ydyd', '#92696 study $a');

    @@got = ();
    $a = "ydydydyd";
    $b = "xdx";
    study $b;
    push @@got, $_ foreach $a =~ /[^x]d(?{})[^x]d/g;
    is("@@got", 'ydyd ydyd', '#92696 study $b');

    @@got = ();
    $a = "ydydydyd";
    $b = "xdx";
    push @@got, $_ foreach $a =~ /[^x]d(?{study $b})[^x]d/g;
    is("@@got", 'ydyd ydyd', '#92696 study $b inside (?{}), nothing studied');

    @@got = ();
    $a = "ydydydyd";
    $b = "xdx";
    my $c = 'zz';
    study $c;
    push @@got, $_ foreach $a =~ /[^x]d(?{study $b})[^x]d/g;
    is("@@got", 'ydyd ydyd', '#92696 study $b inside (?{}), $c studied');

    @@got = ();
    $a = "ydydydyd";
    $b = "xdx";
    study $a;
    push @@got, $_ foreach $a =~ /[^x]d(?{study $b})[^x]d/g;
    is("@@got", 'ydyd ydyd', '#92696 study $b inside (?{}), $a studied');

    @@got = ();
    $a = "ydydydyd";
    $b = "xdx";
    study $a;
    push @@got, $_ foreach $a =~ /[^x]d(?{$a .= ''})[^x]d/g;
    is("@@got", 'ydyd ydyd', '#92696 $a .= \'\' inside (?{}), $a studied');
}
@


