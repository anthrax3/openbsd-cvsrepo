head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1:1.1.1.6.0.8
	OPENBSD_6_1_BASE:1.1.1.6
	OPENBSD_6_0:1.1.1.6.0.10
	OPENBSD_6_0_BASE:1.1.1.6
	OPENBSD_5_9:1.1.1.6.0.4
	OPENBSD_5_9_BASE:1.1.1.6
	OPENBSD_5_8:1.1.1.6.0.6
	OPENBSD_5_8_BASE:1.1.1.6
	PERL_5_20_2:1.1.1.6
	OPENBSD_5_7:1.1.1.6.0.2
	OPENBSD_5_7_BASE:1.1.1.6
	PERL_5_20_1:1.1.1.6
	OPENBSD_5_6:1.1.1.5.0.4
	OPENBSD_5_6_BASE:1.1.1.5
	PERL_5_18_2:1.1.1.5
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.4.0.6
	OPENBSD_5_5_BASE:1.1.1.4
	OPENBSD_5_4:1.1.1.4.0.2
	OPENBSD_5_4_BASE:1.1.1.4
	PERL_5_16_3:1.1.1.4
	OPENBSD_5_3:1.1.1.3.0.18
	OPENBSD_5_3_BASE:1.1.1.3
	OPENBSD_5_2:1.1.1.3.0.16
	OPENBSD_5_2_BASE:1.1.1.3
	OPENBSD_5_1_BASE:1.1.1.3
	OPENBSD_5_1:1.1.1.3.0.14
	OPENBSD_5_0:1.1.1.3.0.12
	OPENBSD_5_0_BASE:1.1.1.3
	OPENBSD_4_9:1.1.1.3.0.10
	OPENBSD_4_9_BASE:1.1.1.3
	PERL_5_12_2:1.1.1.3
	OPENBSD_4_8:1.1.1.3.0.8
	OPENBSD_4_8_BASE:1.1.1.3
	OPENBSD_4_7:1.1.1.3.0.4
	OPENBSD_4_7_BASE:1.1.1.3
	PERL_5_10_1:1.1.1.3
	OPENBSD_4_6:1.1.1.3.0.6
	OPENBSD_4_6_BASE:1.1.1.3
	OPENBSD_4_5:1.1.1.3.0.2
	OPENBSD_4_5_BASE:1.1.1.3
	PERL_5_10_0:1.1.1.3
	OPENBSD_4_4:1.1.1.2.0.30
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.28
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_2:1.1.1.2.0.26
	OPENBSD_4_2_BASE:1.1.1.2
	OPENBSD_4_1:1.1.1.2.0.24
	OPENBSD_4_1_BASE:1.1.1.2
	OPENBSD_4_0:1.1.1.2.0.22
	OPENBSD_4_0_BASE:1.1.1.2
	PERL_5_8_8:1.1.1.2
	OPENBSD_3_9:1.1.1.2.0.20
	OPENBSD_3_9_BASE:1.1.1.2
	OPENBSD_3_8:1.1.1.2.0.18
	OPENBSD_3_8_BASE:1.1.1.2
	OPENBSD_3_7:1.1.1.2.0.16
	OPENBSD_3_7_BASE:1.1.1.2
	PERL_5_8_6:1.1.1.2
	OPENBSD_3_6:1.1.1.2.0.14
	OPENBSD_3_6_BASE:1.1.1.2
	PERL_5_8_5:1.1.1.2
	PERL_5_8_3:1.1.1.2
	OPENBSD_3_5:1.1.1.2.0.12
	OPENBSD_3_5_BASE:1.1.1.2
	PERL_5_8_2:1.1.1.2
	OPENBSD_3_4:1.1.1.2.0.10
	OPENBSD_3_4_BASE:1.1.1.2
	OPENBSD_3_3:1.1.1.2.0.8
	OPENBSD_3_3_BASE:1.1.1.2
	PERL_5_8_0:1.1.1.2
	OPENBSD_3_2:1.1.1.2.0.6
	OPENBSD_3_2_BASE:1.1.1.2
	OPENBSD_3_1:1.1.1.2.0.4
	OPENBSD_3_1_BASE:1.1.1.2
	OPENBSD_3_0:1.1.1.2.0.2
	OPENBSD_3_0_BASE:1.1.1.2
	PERL_5_6_1:1.1.1.2
	OPENBSD_2_9:1.1.1.1.0.8
	OPENBSD_2_9_BASE:1.1.1.1
	OPENBSD_2_8:1.1.1.1.0.6
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.4
	OPENBSD_2_7_BASE:1.1.1.1
	PERL_5_6_0:1.1.1.1
	OPENBSD_2_6:1.1.1.1.0.2
	OPENBSD_2_6_BASE:1.1.1.1
	PERL_500503:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.1
date	99.04.29.22.41.48;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.29.22.41.48;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.05.24.18.25.43;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2008.09.29.17.19.01;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2013.03.25.20.09.36;	author sthen;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2014.03.24.14.59.10;	author afresh1;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2014.11.17.20.53.18;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.1
log
@Initial revision
@
text
@#!./perl

print "1..3\n";

$x='banana';
$x=~/.a/g;
if (pos($x)==2) {print "ok 1\n"} else {print "not ok 1\n";}

$x=~/.z/gc;
if (pos($x)==2) {print "ok 2\n"} else {print "not ok 2\n";}

sub f { my $p=$_[0]; return $p }

$x=~/.a/g;
if (f(pos($x))==4) {print "ok 3\n"} else {print "not ok 3\n";}

@


1.1.1.1
log
@perl5.005_03
@
text
@@


1.1.1.2
log
@stock perl 5.6.1
@
text
@d3 1
a3 1
print "1..4\n";
a15 7

# Is pos() set inside //g? (bug id 19990615.008)
$x = "test string?"; $x =~ s/\w/pos($x)/eg;
print "not " unless $x eq "0123 5678910?";
print "ok 4\n";


@


1.1.1.3
log
@import perl 5.10.0 from CPAN
@
text
@d3 1
a3 7
BEGIN {
    chdir 't' if -d 't';
    @@INC = '../lib';
    require './test.pl';
}

plan tests => 6;
d7 1
a7 1
is(pos($x), 2);
d10 1
a10 1
is(pos($x), 2);
d15 1
a15 1
is(f(pos($x)), 4);
d19 4
a22 1
is($x, "0123 5678910?");
a23 4
$x = "123 56"; $x =~ / /g;
is(pos($x), 4);
{ local $x }
is(pos($x), 4);
@


1.1.1.4
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d9 1
a9 1
plan tests => 8;
a30 19

# Explicit test that triggers the utf8_mg_len_cache_update() code path in
# Perl_sv_pos_b2u().

$x = "\x{100}BC";
$x =~ m/.*/g;
is(pos $x, 3);


my $destroyed;
{ package Class; DESTROY { ++$destroyed; } }

$destroyed = 0;
{
    my $x = '';
    pos($x) = 0;
    $x = bless({}, 'Class');
}
is($destroyed, 1, 'Timely scalar destruction with lvalue pos');
@


1.1.1.5
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d9 1
a9 1
plan tests => 12;
d13 1
a13 1
is(pos($x), 2, "matching, pos() leaves off at offset 2");
d16 1
a16 1
is(pos($x), 2, "not matching, pos() remains at offset 2");
d21 1
a21 1
is(f(pos($x)), 4, "matching again, pos() next leaves off at offset 4");
d25 1
a25 1
is($x, "0123 5678910?", "pos() set inside //g");
d28 1
a28 1
is(pos($x), 4, "matching, pos() leaves off at offset 4");
d30 1
a30 1
is(pos($x), 4, "value of pos() unaffected by intermediate localization");
d37 1
a37 1
is(pos $x, 3, "utf8_mg_len_cache_update() test");
a49 16

eval 'pos @@a = 1';
like $@@, qr/^Can't modify array dereference in match position at /,
  'pos refuses @@arrays';
eval 'pos %a = 1';
like $@@, qr/^Can't modify hash dereference in match position at /,
  'pos refuses %hashes';
eval 'pos *a = 1';
is eval 'pos *a', 1, 'pos *glob works';

# Test that UTF8-ness of $1 changing does not confuse pos
"f" =~ /(f)/; "$1";	# first make sure UTF8-ness is off
"\x{100}a" =~ /(..)/;	# give PL_curpm a UTF8 string; $1 does not know yet
pos($1) = 2;		# set pos; was ignoring UTF8-ness
"$1";			# turn on UTF8 flag
is pos($1), 2, 'pos is not confused about changing UTF8-ness';
@


1.1.1.6
log
@Import perl-5.20.1
@
text
@d9 1
a9 1
plan tests => 29;
a38 2
is(scalar pos $x, 3, "rvalue pos() utf8 test");

a65 66

sub {
    $_[0] = "hello";
    pos $_[0] = 3;
    is pos $h{k}, 3, 'defelems can propagate pos assignment';
    $_[0] =~ /./g;
    is pos $h{k}, 4, 'defelems can propagate implicit pos (via //g)';
    $_[0] =~ /oentuhoetn/g;
    is pos $h{k}, undef, 'failed //g sets pos through defelem';
    $_[1] = "hello";
    pos $h{l} = 3;
    is pos $_[1], 3, 'reading pos through a defelem';
    pos $h{l} = 4;
    $_[1] =~ /(.)/g;
    is "$1", 'o', '//g can read pos through a defelem';
    $_[2] = "hello";
    () = $_[2] =~ /l/gc;
    is pos $h{m}, 4, '//gc in list cx can set pos through a defelem';
    $_[3] = "hello";
    $_[3] =~
        s<e><is pos($h{n}), 1, 's///g setting pos through a defelem'>egg;
    $h{n} = 'hello';
    $_[3] =~ /e(?{ is pos $h{n},2, 're-evals set pos through defelems' })/;
    pos $h{n} = 1;
    ok $_[3] =~ /\Ge/, '\G works with defelem scalars';
}->($h{k}, $h{l}, $h{m}, $h{n});

$x = bless [], chr 256;
pos $x=1;
bless $x, a;
is pos($x), 1, 'pos is not affected by reference stringification changing';
{
    my $w;
    local $SIG{__WARN__} = sub { $w .= shift };
    $x = bless [], chr 256;
    pos $x=1;
    bless $x, "\x{1000}";
    is pos $x, 1,
       'pos unchanged after increasing size of chars in stringification';
    is $w, undef, 'and no malformed utf8 warning';
}
$x = bless [], chr 256;
$x =~ /.(?{
     bless $x, a;
     is pos($x), 1, 'pos unaffected by ref str changing (in re-eval)';
})/;
{
    my $w;
    local $SIG{__WARN__} = sub { $w .= shift };
    $x = bless [], chr(256);
    $x =~ /.(?{
        bless $x, "\x{1000}";
        is pos $x, 1,
         'pos unchanged in re-eval after increasing size of chars in str';
    })/;
    is $w, undef, 'and no malformed utf8 warning';
}

for my $one(pos $x) {
    for my $two(pos $x) {
        $one = \1;
        $two = undef;
        is $one, undef,
           'no assertion failure when getting pos clobbers ref with undef';
    }
}
@


