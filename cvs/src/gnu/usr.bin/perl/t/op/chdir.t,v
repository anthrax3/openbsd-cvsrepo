head	1.2;
access;
symbols
	PERL_5_24_2:1.1.1.8
	OPENBSD_6_1:1.2.0.4
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.7.0.16
	OPENBSD_6_0_BASE:1.1.1.7
	OPENBSD_5_9:1.1.1.7.0.10
	OPENBSD_5_9_BASE:1.1.1.7
	OPENBSD_5_8:1.1.1.7.0.12
	OPENBSD_5_8_BASE:1.1.1.7
	PERL_5_20_2:1.1.1.7
	OPENBSD_5_7:1.1.1.7.0.4
	OPENBSD_5_7_BASE:1.1.1.7
	PERL_5_20_1:1.1.1.7
	OPENBSD_5_6:1.1.1.7.0.8
	OPENBSD_5_6_BASE:1.1.1.7
	PERL_5_18_2:1.1.1.7
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.7.0.6
	OPENBSD_5_5_BASE:1.1.1.7
	OPENBSD_5_4:1.1.1.7.0.2
	OPENBSD_5_4_BASE:1.1.1.7
	PERL_5_16_3:1.1.1.7
	OPENBSD_5_3:1.1.1.6.0.10
	OPENBSD_5_3_BASE:1.1.1.6
	OPENBSD_5_2:1.1.1.6.0.8
	OPENBSD_5_2_BASE:1.1.1.6
	OPENBSD_5_1_BASE:1.1.1.6
	OPENBSD_5_1:1.1.1.6.0.6
	OPENBSD_5_0:1.1.1.6.0.4
	OPENBSD_5_0_BASE:1.1.1.6
	OPENBSD_4_9:1.1.1.6.0.2
	OPENBSD_4_9_BASE:1.1.1.6
	PERL_5_12_2:1.1.1.6
	OPENBSD_4_8:1.1.1.5.0.4
	OPENBSD_4_8_BASE:1.1.1.5
	OPENBSD_4_7:1.1.1.5.0.2
	OPENBSD_4_7_BASE:1.1.1.5
	PERL_5_10_1:1.1.1.5
	OPENBSD_4_6:1.1.1.4.0.6
	OPENBSD_4_6_BASE:1.1.1.4
	OPENBSD_4_5:1.1.1.4.0.2
	OPENBSD_4_5_BASE:1.1.1.4
	PERL_5_10_0:1.1.1.4
	OPENBSD_4_4:1.1.1.3.0.10
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.8
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_2:1.1.1.3.0.6
	OPENBSD_4_2_BASE:1.1.1.3
	OPENBSD_4_1:1.1.1.3.0.4
	OPENBSD_4_1_BASE:1.1.1.3
	OPENBSD_4_0:1.1.1.3.0.2
	OPENBSD_4_0_BASE:1.1.1.3
	PERL_5_8_8:1.1.1.3
	OPENBSD_3_9:1.1.1.2.0.10
	OPENBSD_3_9_BASE:1.1.1.2
	OPENBSD_3_8:1.1.1.2.0.8
	OPENBSD_3_8_BASE:1.1.1.2
	OPENBSD_3_7:1.1.1.2.0.6
	OPENBSD_3_7_BASE:1.1.1.2
	PERL_5_8_6:1.1.1.2
	OPENBSD_3_6:1.1.1.2.0.4
	OPENBSD_3_6_BASE:1.1.1.2
	PERL_5_8_5:1.1.1.2
	PERL_5_8_3:1.1.1.2
	OPENBSD_3_5:1.1.1.2.0.2
	OPENBSD_3_5_BASE:1.1.1.2
	PERL_5_8_2:1.1.1.2
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	PERL_5_8_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.32.20;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2002.10.27.22.15.10;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.27.22.15.10;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.12.03.02.44.31;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2006.03.28.18.49.44;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2008.09.29.17.19.00;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2009.10.12.18.10.44;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2010.09.24.14.49.17;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2013.03.25.20.09.35;	author sthen;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2017.08.14.13.46.23;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl -w

BEGIN {
    # We really want to know if chdir is working, as the build process will
    # all go wrong if it is not.  So avoid clearing @@INC under miniperl.
    @@INC = () if defined &DynaLoader::boot_DynaLoader;

    # We're not going to chdir() into 't' because we don't know if
    # chdir() works!  Instead, we'll hedge our bets and put both
    # possibilities into @@INC.
    unshift @@INC, qw(t . lib ../lib);
    require "test.pl";
    plan(tests => 47);
}

use Config;
use Errno qw(ENOENT EBADF EINVAL);

my $IsVMS   = $^O eq 'VMS';

# For an op regression test, I don't want to rely on "use constant" working.
my $has_fchdir = ($Config{d_fchdir} || "") eq "define";

# Might be a little early in the testing process to start using these,
# but I can't think of a way to write this test without them.
use File::Spec::Functions qw(:DEFAULT splitdir rel2abs splitpath);

# Can't use Cwd::abs_path() because it has different ideas about
# path separators than File::Spec.
sub abs_path {
    my $d = rel2abs(curdir);
    $d = lc($d) if $^O =~ /^uwin/;
    $d;
}

my $Cwd = abs_path;

# Let's get to a known position
SKIP: {
    my ($vol,$dir) = splitpath(abs_path,1);
    my $test_dir = 't';
    my $compare_dir = (splitdir($dir))[-1];

    # VMS is case insensitive but will preserve case in EFS mode.
    # So we must normalize the case for the compare.
 
    $compare_dir = lc($compare_dir) if $IsVMS;
    skip("Already in t/", 2) if $compare_dir eq $test_dir;

    ok( chdir($test_dir),     'chdir($test_dir)');
    is( abs_path, catdir($Cwd, $test_dir),    '  abs_path() agrees' );
}

$Cwd = abs_path;

SKIP: {
    skip("no fchdir", 23) unless $has_fchdir;
    my $has_dirfd = ($Config{d_dirfd} || $Config{d_dir_dd_fd} || "") eq "define";
    ok(opendir(my $dh, "."), "opendir .");
    ok(open(my $fh, "<", "op"), "open op");
    ok(chdir($fh), "fchdir op");
    ok(-f "chdir.t", "verify that we are in op");
    if ($has_dirfd) {
       ok(chdir($dh), "fchdir back");
    }
    else {
       eval { chdir($dh); };
       like($@@, qr/^The dirfd function is unimplemented at/, "dirfd is unimplemented");
       chdir ".." or die $!;
    }

    # same with bareword file handles
    no warnings 'once';
    *DH = $dh;
    *FH = $fh;
    ok(chdir FH, "fchdir op bareword");
    ok(-f "chdir.t", "verify that we are in op");
    if ($has_dirfd) {
       ok(chdir DH, "fchdir back bareword");
    }
    else {
       eval { chdir(DH); };
       like($@@, qr/^The dirfd function is unimplemented at/, "dirfd is unimplemented");
       chdir ".." or die $!;
    }
    ok(-d "op", "verify that we are back");

    # And now the ambiguous case
    {
	no warnings qw<io deprecated>;
	ok(opendir(H, "op"), "opendir op") or diag $!;
	ok(open(H, "<", "base"), "open base") or diag $!;
    }
    if ($has_dirfd) {
	ok(chdir(H), "fchdir to op");
	ok(-f "chdir.t", "verify that we are in 'op'");
	chdir ".." or die $!;
    }
    else {
	eval { chdir(H); };
	like($@@, qr/^The dirfd function is unimplemented at/,
	     "dirfd is unimplemented");
	SKIP: {
	    skip("dirfd is unimplemented");
	}
    }
    ok(closedir(H), "closedir");
    ok(chdir(H), "fchdir to base");
    ok(-f "cond.t", "verify that we are in 'base'");
    ok(close(H), "close");
    $! = 0;
    {
        my $warn;
        local $SIG{__WARN__} = sub { $warn = shift };
        ok(!chdir(H), "check we can't chdir to closed handle");
        is(0+$!, EBADF, 'check $! set appropriately');
        like($warn, qr/on closed filehandle H/, 'like closed');
        $! = 0;
    }
    {
        my $warn;
        local $SIG{__WARN__} = sub { $warn = shift };
        ok(!chdir(NEVEROPENED), "check we can't chdir to never opened handle");
        is(0+$!, EBADF, 'check $! set appropriately');
        like($warn, qr/on unopened filehandle NEVEROPENED/, 'like never opened');
        chdir ".." or die $!;
    }
}

SKIP: {
    skip("has fchdir", 1) if $has_fchdir;
    opendir(my $dh, "op");
    eval { chdir($dh); };
    like($@@, qr/^The fchdir function is unimplemented at/, "fchdir is unimplemented");
}

# The environment variables chdir() pays attention to.
my @@magic_envs = qw(HOME LOGDIR SYS$LOGIN);

sub check_env {
    my($key) = @@_;

    # Make sure $ENV{'SYS$LOGIN'} is only honored on VMS.
    if( $key eq 'SYS$LOGIN' && !$IsVMS ) {
        ok( !chdir(),         "chdir() on $^O ignores only \$ENV{$key} set" );
        is( abs_path, $Cwd,   '  abs_path() did not change' );
        pass( "  no need to test SYS\$LOGIN on $^O" ) for 1..4;
    }
    else {
        ok( chdir(),              "chdir() w/ only \$ENV{$key} set" );
        is( abs_path, $ENV{$key}, '  abs_path() agrees' );
        chdir($Cwd);
        is( abs_path, $Cwd,       '  and back again' );

        my $warning = '';
        local $SIG{__WARN__} = sub { $warning .= join '', @@_ };
        $! = 0;
        ok(!chdir(''), "chdir('') no longer implied chdir()");
        is($!+0, ENOENT, 'check $! set appropriately');
        is($warning, '', 'should no longer warn about deprecation');
    }
}

my %Saved_Env = ();
sub clean_env {
    foreach my $env (@@magic_envs) {
        $Saved_Env{$env} = $ENV{$env};

        # Can't actually delete SYS$ stuff on VMS.
        next if $IsVMS && $env eq 'SYS$LOGIN';

	# On VMS, %ENV is many layered.
	delete $ENV{$env} while exists $ENV{$env};
    }

    # The following means we won't really be testing for non-existence,
    # but in Perl we can only delete from the process table, not the job 
    # table.
    $ENV{'SYS$LOGIN'} = '' if $IsVMS;
}

END {
    no warnings 'uninitialized';

    # Restore the environment for VMS (and doesn't hurt for anyone else)
    @@ENV{@@magic_envs} = @@Saved_Env{@@magic_envs};

    # On VMS this must be deleted or process table is wrong on exit
    # when this script is run interactively.
    delete $ENV{'SYS$LOGIN'} if $IsVMS;
}


foreach my $key (@@magic_envs) {
    # We're going to be using undefs a lot here.
    no warnings 'uninitialized';

    clean_env;
    $ENV{$key} = catdir $Cwd, 'op';

    check_env($key);
}

{
    clean_env;
  SKIP:
    {
        $IsVMS
          and skip "Can't delete SYS\$LOGIN, so chdir() test meaningless", 2;
        $! = 0;
        ok( !chdir(),                   'chdir() w/o any ENV set' );
        is( $!+0, EINVAL,               'check $! set to EINVAL');
    }
    is( abs_path, $Cwd,             '  abs_path() agrees' );
}
@


1.1
log
@Initial revision
@
text
@d4 4
d11 3
a13 1
    @@INC = qw(t . lib ../lib);
d17 1
a17 2
require "test.pl";
plan(tests => 31);
d20 3
a22 1
my $IsMacOS = $^O eq 'MacOS';
d31 3
a33 1
    $IsVMS ? uc(rel2abs(curdir)) : rel2abs(curdir);
d41 8
a48 2
    my $test_dir = $IsVMS ? 'T' : 't';
    skip("Already in t/", 2) if (splitdir($dir))[-1] eq $test_dir;
d56 81
d144 1
a144 1
    if( $key eq 'SYS$LOGIN' && !$IsVMS && !$IsMacOS ) {
d147 1
a147 1
        pass( "  no need to test SYS\$LOGIN on $^O" ) for 1..7;
d157 4
a160 23


        # Check the deprecated chdir(undef) feature.
#line 64
        ok( chdir(undef),           "chdir(undef) w/ only \$ENV{$key} set" );
        is( abs_path, $ENV{$key},   '  abs_path() agrees' );
        is( $warning,  <<WARNING,   '  got uninit & deprecation warning' );
Use of uninitialized value in chdir at $0 line 64.
Use of chdir('') or chdir(undef) as chdir() is deprecated at $0 line 64.
WARNING

        chdir($Cwd);

        # Ditto chdir('').
        $warning = '';
#line 76
        ok( chdir(''),              "chdir('') w/ only \$ENV{$key} set" );
        is( abs_path, $ENV{$key},   '  abs_path() agrees' );
        is( $warning,  <<WARNING,   '  got deprecation warning' );
Use of chdir('') or chdir(undef) as chdir() is deprecated at $0 line 76.
WARNING

        chdir($Cwd);
a170 1
        next if $IsVMS && $env eq 'HOME' && !$Config{'d_setenv'};
d172 2
a173 4
        unless ($IsMacOS) { # ENV on MacOS is "special" :-)
            # On VMS, %ENV is many layered.
            delete $ENV{$env} while exists $ENV{$env};
        }
d187 4
d199 1
a199 1
    $ENV{$key} = catdir $Cwd, ($IsVMS ? 'OP' : 'op');
d206 5
a210 3
    if (($IsVMS || $IsMacOS) && !$Config{'d_setenv'}) {
        pass("Can't reset HOME, so chdir() test meaningless");
    } else {
d212 1
@


1.1.1.1
log
@stock perl 5.8.0 from CPAN
@
text
@@


1.1.1.2
log
@perl 5.8.2 from CPAN
@
text
@d24 1
a24 5
    my $d = rel2abs(curdir);

    $d = uc($d) if $IsVMS;
    $d = lc($d) if $^O =~ /^uwin/;
    $d;
@


1.1.1.3
log
@perl 5.8.8 import
@
text
@d12 1
a12 1
plan(tests => 38);
a43 24

SKIP: {
    skip("no fchdir", 6) unless ($Config{d_fchdir} || "") eq "define";
    ok(opendir(my $dh, "."), "opendir .");
    ok(open(my $fh, "<", "op"), "open op");
    ok(chdir($fh), "fchdir op");
    ok(-f "chdir.t", "verify that we are in op");
    if (($Config{d_dirfd} || "") eq "define") {
       ok(chdir($dh), "fchdir back");
    }
    else {
       eval { chdir($dh); };
       like($@@, qr/^The dirfd function is unimplemented at/, "dirfd is unimplemented");
       chdir "..";
    }
    ok(-d "op", "verify that we are back");
}

SKIP: {
    skip("has fchdir", 1) if ($Config{d_fchdir} || "") eq "define";
    opendir(my $dh, "op");
    eval { chdir($dh); };
    like($@@, qr/^The fchdir function is unimplemented at/, "fchdir is unimplemented");
}
@


1.1.1.4
log
@import perl 5.10.0 from CPAN
@
text
@d12 1
a12 1
plan(tests => 48);
a16 3
# For an op regression test, I don't want to rely on "use constant" working.
my $has_fchdir = ($Config{d_fchdir} || "") eq "define";

d46 1
a46 2
    skip("no fchdir", 16) unless $has_fchdir;
    my $has_dirfd = ($Config{d_dirfd} || $Config{d_dir_dd_fd} || "") eq "define";
d51 1
a51 1
    if ($has_dirfd) {
d57 1
a57 16
       chdir ".." or die $!;
    }

    # same with bareword file handles
    no warnings 'once';
    *DH = $dh;
    *FH = $fh;
    ok(chdir FH, "fchdir op bareword");
    ok(-f "chdir.t", "verify that we are in op");
    if ($has_dirfd) {
       ok(chdir DH, "fchdir back bareword");
    }
    else {
       eval { chdir(DH); };
       like($@@, qr/^The dirfd function is unimplemented at/, "dirfd is unimplemented");
       chdir ".." or die $!;
a59 24

    # And now the ambiguous case
    {
	no warnings qw<io deprecated>;
	ok(opendir(H, "op"), "opendir op") or diag $!;
	ok(open(H, "<", "base"), "open base") or diag $!;
    }
    if ($has_dirfd) {
	ok(chdir(H), "fchdir to op");
	ok(-f "chdir.t", "verify that we are in 'op'");
	chdir ".." or die $!;
    }
    else {
	eval { chdir(H); };
	like($@@, qr/^The dirfd function is unimplemented at/,
	     "dirfd is unimplemented");
	SKIP: {
	    skip("dirfd is unimplemented");
	}
    }
    ok(closedir(H), "closedir");
    ok(chdir(H), "fchdir to base");
    ok(-f "cond.t", "verify that we are in 'base'");
    chdir ".." or die $!;
d63 1
a63 1
    skip("has fchdir", 1) if $has_fchdir;
a140 4

    # On VMS this must be deleted or process table is wrong on exit
    # when this script is run interactively.
    delete $ENV{'SYS$LOGIN'} if $IsVMS;
@


1.1.1.5
log
@import perl 5.10.1
@
text
@a16 14
my $vms_unix_rpt = 0;
my $vms_efs = 0;
if ($IsVMS) {
    if (eval 'require VMS::Feature') {
        $vms_unix_rpt = VMS::Feature::current("filename_unix_report");
        $vms_efs = VMS::Feature::current("efs_charset");
    } else {
        my $unix_rpt = $ENV{'DECC$FILENAME_UNIX_REPORT'} || '';
        my $efs_charset = $ENV{'DECC$EFS_CHARSET'} || '';
        $vms_unix_rpt = $unix_rpt =~ /^[ET1]/i; 
        $vms_efs = $efs_charset =~ /^[ET1]/i; 
    }
}

d28 2
d39 2
a40 8
    my $test_dir = 't';
    my $compare_dir = (splitdir($dir))[-1];

    # VMS is case insensitive but will preserve case in EFS mode.
    # So we must normalize the case for the compare.
 
    $compare_dir = lc($compare_dir) if $IsVMS;
    skip("Already in t/", 2) if $compare_dir eq $test_dir;
@


1.1.1.6
log
@Perl 5.12.2 from CPAN
@
text
@d15 1
d137 1
a137 1
    if( $key eq 'SYS$LOGIN' && !$IsVMS ) {
d185 4
a188 2
	# On VMS, %ENV is many layered.
	delete $ENV{$env} while exists $ENV{$env};
d221 1
a221 1
    if ($IsVMS && !$Config{'d_setenv'}) {
@


1.1.1.7
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@a7 7
    require "test.pl";
    # Really want to know if chdir is working, as the build process will all go
    # wrong if it is not.
    if (is_miniperl() && !eval {require File::Spec::Functions; 1}) {
	push @@INC, qw(dist/Cwd/lib dist/Cwd ../dist/Cwd/lib ../dist/Cwd);
    }
    plan(tests => 48);
d11 2
@


1.1.1.8
log
@Import perl-5.24.2
@
text
@a3 4
    # We really want to know if chdir is working, as the build process will
    # all go wrong if it is not.  So avoid clearing @@INC under miniperl.
    @@INC = () if defined &DynaLoader::boot_DynaLoader;

d7 1
a7 1
    unshift @@INC, qw(t . lib ../lib);
d9 6
a14 1
    plan(tests => 47);
a17 1
use Errno qw(ENOENT EBADF EINVAL);
d21 14
d71 1
a71 1
    skip("no fchdir", 23) unless $has_fchdir;
d124 1
a124 18
    ok(close(H), "close");
    $! = 0;
    {
        my $warn;
        local $SIG{__WARN__} = sub { $warn = shift };
        ok(!chdir(H), "check we can't chdir to closed handle");
        is(0+$!, EBADF, 'check $! set appropriately');
        like($warn, qr/on closed filehandle H/, 'like closed');
        $! = 0;
    }
    {
        my $warn;
        local $SIG{__WARN__} = sub { $warn = shift };
        ok(!chdir(NEVEROPENED), "check we can't chdir to never opened handle");
        is(0+$!, EBADF, 'check $! set appropriately');
        like($warn, qr/on unopened filehandle NEVEROPENED/, 'like never opened');
        chdir ".." or die $!;
    }
d144 1
a144 1
        pass( "  no need to test SYS\$LOGIN on $^O" ) for 1..4;
d154 23
a176 4
        $! = 0;
        ok(!chdir(''), "chdir('') no longer implied chdir()");
        is($!+0, ENOENT, 'check $! set appropriately');
        is($warning, '', 'should no longer warn about deprecation');
d187 1
d216 1
a216 1
    $ENV{$key} = catdir $Cwd, 'op';
d223 3
a225 5
  SKIP:
    {
        $IsVMS
          and skip "Can't delete SYS\$LOGIN, so chdir() test meaningless", 2;
        $! = 0;
a226 1
        is( $!+0, EINVAL,               'check $! set to EINVAL');
@


