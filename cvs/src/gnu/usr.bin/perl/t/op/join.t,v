head	1.10;
access;
symbols
	OPENBSD_6_1:1.10.0.4
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.9.0.10
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.4
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.9.0.6
	OPENBSD_5_8_BASE:1.9
	PERL_5_20_2:1.1.1.7
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	PERL_5_20_1:1.1.1.7
	OPENBSD_5_6:1.8.0.4
	OPENBSD_5_6_BASE:1.8
	PERL_5_18_2:1.1.1.6
	PERL:1.1.1
	OPENBSD_5_5:1.7.0.34
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.30
	OPENBSD_5_4_BASE:1.7
	PERL_5_16_3:1.1.1.5
	OPENBSD_5_3:1.7.0.28
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.26
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.24
	OPENBSD_5_0:1.7.0.22
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.20
	OPENBSD_4_9_BASE:1.7
	PERL_5_12_2:1.1.1.5
	OPENBSD_4_8:1.7.0.18
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.14
	OPENBSD_4_7_BASE:1.7
	PERL_5_10_1:1.1.1.5
	OPENBSD_4_6:1.7.0.16
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.12
	OPENBSD_4_5_BASE:1.7
	PERL_5_10_0:1.1.1.5
	OPENBSD_4_4:1.7.0.10
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.8
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.6
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.4
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.2
	OPENBSD_4_0_BASE:1.7
	PERL_5_8_8:1.1.1.5
	OPENBSD_3_9:1.6.0.8
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.6
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.4
	OPENBSD_3_7_BASE:1.6
	PERL_5_8_6:1.1.1.4
	OPENBSD_3_6:1.6.0.2
	OPENBSD_3_6_BASE:1.6
	PERL_5_8_5:1.1.1.4
	PERL_5_8_3:1.1.1.4
	OPENBSD_3_5:1.5.0.12
	OPENBSD_3_5_BASE:1.5
	PERL_5_8_2:1.1.1.3
	OPENBSD_3_4:1.5.0.10
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.8
	OPENBSD_3_3_BASE:1.5
	PERL_5_8_0:1.1.1.3
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.1
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.10
date	2017.02.05.00.32.20;	author afresh1;	state Exp;
branches;
next	1.9;
commitid	cxJ08BvJA9Pt2PTM;

1.9
date	2014.11.17.20.57.07;	author afresh1;	state Exp;
branches;
next	1.8;
commitid	QP75iYx42Uo7mMxO;

1.8
date	2014.03.24.15.05.33;	author afresh1;	state Exp;
branches;
next	1.7;

1.7
date	2006.03.28.19.23.12;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2004.04.07.21.33.09;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.36.19;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.08.25;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.52.36;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.08.05.25;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.13.19;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.13.19;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.04.06.16.10.49;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.05.24.18.25.39;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.04.07.21.13.43;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2006.03.28.18.49.45;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2014.03.24.14.59.10;	author afresh1;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2014.11.17.20.53.18;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.10
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl

BEGIN {
    chdir 't' if -d 't';
    @@INC = '../lib';
    require './test.pl';
}

plan tests => 29;

@@x = (1, 2, 3);
is( join(':',@@x), '1:2:3', 'join an array with character');

is( join('',1,2,3), '123', 'join list with no separator');

is( join(':',split(/ /,"1 2 3")), '1:2:3', 'join implicit array with character');

my $f = 'a';
$f = join ',', 'b', $f, 'e';
is( $f, 'b,a,e', 'join list back to self, middle of list');

$f = 'a';
$f = join ',', $f, 'b', 'e';
is( $f, 'a,b,e', 'join list back to self, beginning of list');

$f = 'a';
$f = join $f, 'b', 'e', 'k';
is( $f, 'baeak', 'join back to self, self is join character');

# 7,8 check for multiple read of tied objects
{ package X;
  sub TIESCALAR { my $x = 7; bless \$x };
  sub FETCH { my $y = shift; $$y += 5 };
  tie my $t, 'X';
  my $r = join ':', $t, 99, $t, 99;
  main::is($r, '12:99:17:99', 'check for multiple read of tied objects, with separator');
  $r = join '', $t, 99, $t, 99;
  main::is($r, '22992799', 'check for multiple read of tied objects, w/o separator, and magic');
};

# 9,10 and for multiple read of undef
{ my $s = 5;
  local ($^W, $SIG{__WARN__}) = ( 1, sub { $s+=4 } );
  my $r = join ':', 'a', undef, $s, 'b', undef, $s, 'c';
  is( $r, 'a::9:b::13:c', 'multiple read of undef, with separator');
  my $r = join '', 'a', undef, $s, 'b', undef, $s, 'c';
  is( $r, 'a17b21c', '... and without separator');
};

{ my $s = join("", chr(0x1234), chr(0xff));
  is( $s, "\x{1234}\x{ff}", 'join two characters with multiple bytes, get two characters');
}

{ my $s = join(chr(0xff), chr(0x1234), "");
  is( $s, "\x{1234}\x{ff}", 'high byte character as separator, 1 multi-byte character in front');
}

{ my $s = join(chr(0x1234), chr(0xff), chr(0x2345));
  is( $s, "\x{ff}\x{1234}\x{2345}", 'multibyte character as separator');
}

{ my $s = join(chr(0xff), chr(0x1234), chr(0xfe));
  is( $s, "\x{1234}\x{ff}\x{fe}", 'high byte as separator, multi-byte and high byte list');
}

{ my $s = join('x', ());
  is( $s, '', 'join should return empty string for empty list');
}

{ my $s = join('', ());
  is( $s, '', 'join should return empty string for empty list and empty separator as well');
}

{ my $w;
  local $SIG{__WARN__} = sub { $w = shift };
  use warnings "uninitialized";
  my $s = join(undef, ());
  is( $s, '', 'join should return empty string for empty list, when separator is undef');
  # this warning isn't normative, the implementation may choose to
  # not evaluate the separator as a string if the list has fewer than
  # two elements
  like $w, qr/^Use of uninitialized value in join/, "should warn if separator is undef";
}


{ # [perl #24846] $jb2 should be in bytes, not in utf8.
  my $b = "abc\304";
  my $u = "abc\x{0100}";

  sub join_into_my_variable {
    my $r = join("", @@_);
    return $r;
  }

  sub byte_is {
    use bytes;
    return $_[0] eq $_[1] ? pass($_[2]) : fail($_[2]);
  }

  my $jb1 = join_into_my_variable("", $b);
  my $ju1 = join_into_my_variable("", $u);
  my $jb2 = join_into_my_variable("", $b);
  my $ju2 = join_into_my_variable("", $u);

  note( 'utf8 and byte checks, perl #24846' );

  byte_is($jb1, $b);
  is( $jb1, $b );

  byte_is($ju1, $u);
  is( $ju1, $u );

  byte_is($jb2, $b);
  is( $jb2, $b );

  byte_is($ju2, $u);
  is( $ju2, $u );
}

package o { use overload q|""| => sub { ${$_[0]}++ } }
{
  my $o = bless \(my $dummy = "a"), o::;
  $_ = join $o, 1..10;
  is $_, "1a2a3a4a5a6a7a8a9a10", 'join, $overloaded, LIST';
  is $$o, "b", 'overloading was called once on overloaded separator';
}

for(1,2) { push @@_, \join "x", 1 }
isnt $_[1], $_[0],
    'join(const, const) still returns a new scalar each time';
@


1.9
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d9 1
a9 1
plan tests => 26;
d120 11
@


1.8
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d9 1
a9 1
plan tests => 22;
d65 20
@


1.7
log
@merge in perl 5.8.8
@
text
@d3 7
a9 1
print "1..22\n";
d12 1
a12 1
if (join(':',@@x) eq '1:2:3') {print "ok 1\n";} else {print "not ok 1\n";}
d14 1
a14 1
if (join('',1,2,3) eq '123') {print "ok 2\n";} else {print "not ok 2\n";}
d16 1
a16 1
if (join(':',split(/ /,"1 2 3")) eq '1:2:3') {print "ok 3\n";} else {print "not ok 3\n";}
d20 1
a20 1
if ($f eq 'b,a,e') {print "ok 4\n";} else {print "# '$f'\nnot ok 4\n";}
d24 1
a24 1
if ($f eq 'a,b,e') {print "ok 5\n";} else {print "not ok 5\n";}
d28 1
a28 1
if ($f eq 'baeak') {print "ok 6\n";} else {print "# '$f'\nnot ok 6\n";}
d36 1
a36 2
  print "# expected '12:99:17:99' got '$r'\nnot " if $r ne '12:99:17:99';
  print "ok 7\n";
d38 1
a38 2
  print "# expected '22992799' got '$r'\nnot " if $r ne '22992799';
  print "ok 8\n";
d45 1
a45 2
  print "# expected 'a::9:b::13:c' got '$r'\nnot " if $r ne 'a::9:b::13:c';
  print "ok 9\n";
d47 1
a47 2
  print "# expected 'a17b21c' got '$r'\nnot " if $r ne 'a17b21c';
  print "ok 10\n";
d51 1
a51 2
  print "not " unless length($s) == 2 && $s eq "\x{1234}\x{ff}";
  print "ok 11\n";
d55 1
a55 2
  print "not " unless length($s) == 2 && $s eq "\x{1234}\x{ff}";
  print "ok 12\n";
d59 1
a59 2
  print "not " unless length($s) == 3 && $s eq "\x{ff}\x{1234}\x{2345}";
  print "ok 13\n";
d63 1
a63 2
  print "not " unless length($s) == 3 && $s eq "\x{1234}\x{ff}\x{fe}";
  print "ok 14\n";
d75 5
d85 4
a88 7
  {
      use bytes;
      print "not " unless $jb1 eq $b;
      print "ok 15\n";
  }
  print "not " unless $jb1 eq $b;
  print "ok 16\n";
d90 2
a91 7
  {
      use bytes;
      print "not " unless $ju1 eq $u;
      print "ok 17\n";
  }
  print "not " unless $ju1 eq $u;
  print "ok 18\n";
d93 2
a94 7
  {
      use bytes;
      print "not " unless $jb2 eq $b;
      print "ok 19\n";
  }
  print "not " unless $jb2 eq $b;
  print "ok 20\n";
d96 2
a97 7
  {
      use bytes;
      print "not " unless $ju2 eq $u;
      print "ok 21\n";
  }
  print "not " unless $ju2 eq $u;
  print "ok 22\n";
d99 1
@


1.6
log
@merge local changes into perl-5.8.3
@
text
@d3 1
a3 1
print "1..18\n";
d82 7
a88 2
  print "not " unless unpack('H*', $jb1) eq unpack('H*', $b);
  print "ok 15\n";
d90 7
a96 2
  print "not " unless unpack('H*', $ju1) eq unpack('H*', $u);
  print "ok 16\n";
d98 7
a104 2
  print "not " unless unpack('H*', $jb2) eq unpack('H*', $b);
  print "ok 17\n";
d106 7
a112 2
  print "not " unless unpack('H*', $ju2) eq unpack('H*', $u);
  print "ok 18\n";
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d3 1
a3 1
print "1..14\n";
d68 26
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d3 1
a3 1
print "1..6\n";
d23 45
@


1.3
log
@perl5.005_03 (stock)
@
text
@d3 1
a3 3
# $RCSfile: join.t,v $$Revision: 4.1 $$Date: 92/08/07 18:28:01 $

print "1..3\n";
d11 12
@


1.2
log
@perl 5.004_04
@
text
@@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@virgin perl 5.6.0
@
text
@d3 3
a5 1
print "1..6\n";
a12 12

my $f = 'a';
$f = join ',', 'b', $f, 'e';
if ($f eq 'b,a,e') {print "ok 4\n";} else {print "# '$f'\nnot ok 4\n";}

$f = 'a';
$f = join ',', $f, 'b', 'e';
if ($f eq 'a,b,e') {print "ok 5\n";} else {print "not ok 5\n";}

$f = 'a';
$f = join $f, 'b', 'e', 'k';
if ($f eq 'baeak') {print "ok 6\n";} else {print "# '$f'\nnot ok 6\n";}
@


1.1.1.3
log
@stock perl 5.6.1
@
text
@d3 1
a3 1
print "1..14\n";
a22 45

# 7,8 check for multiple read of tied objects
{ package X;
  sub TIESCALAR { my $x = 7; bless \$x };
  sub FETCH { my $y = shift; $$y += 5 };
  tie my $t, 'X';
  my $r = join ':', $t, 99, $t, 99;
  print "# expected '12:99:17:99' got '$r'\nnot " if $r ne '12:99:17:99';
  print "ok 7\n";
  $r = join '', $t, 99, $t, 99;
  print "# expected '22992799' got '$r'\nnot " if $r ne '22992799';
  print "ok 8\n";
};

# 9,10 and for multiple read of undef
{ my $s = 5;
  local ($^W, $SIG{__WARN__}) = ( 1, sub { $s+=4 } );
  my $r = join ':', 'a', undef, $s, 'b', undef, $s, 'c';
  print "# expected 'a::9:b::13:c' got '$r'\nnot " if $r ne 'a::9:b::13:c';
  print "ok 9\n";
  my $r = join '', 'a', undef, $s, 'b', undef, $s, 'c';
  print "# expected 'a17b21c' got '$r'\nnot " if $r ne 'a17b21c';
  print "ok 10\n";
};

{ my $s = join("", chr(0x1234), chr(0xff));
  print "not " unless length($s) == 2 && $s eq "\x{1234}\x{ff}";
  print "ok 11\n";
}

{ my $s = join(chr(0xff), chr(0x1234), "");
  print "not " unless length($s) == 2 && $s eq "\x{1234}\x{ff}";
  print "ok 12\n";
}

{ my $s = join(chr(0x1234), chr(0xff), chr(0x2345));
  print "not " unless length($s) == 3 && $s eq "\x{ff}\x{1234}\x{2345}";
  print "ok 13\n";
}

{ my $s = join(chr(0xff), chr(0x1234), chr(0xfe));
  print "not " unless length($s) == 3 && $s eq "\x{1234}\x{ff}\x{fe}";
  print "ok 14\n";
}

@


1.1.1.4
log
@perl 5.8.3 from CPAN
@
text
@d3 1
a3 1
print "1..18\n";
a67 26
{ # [perl #24846] $jb2 should be in bytes, not in utf8.
  my $b = "abc\304";
  my $u = "abc\x{0100}";

  sub join_into_my_variable {
    my $r = join("", @@_);
    return $r;
  }

  my $jb1 = join_into_my_variable("", $b);
  my $ju1 = join_into_my_variable("", $u);
  my $jb2 = join_into_my_variable("", $b);
  my $ju2 = join_into_my_variable("", $u);

  print "not " unless unpack('H*', $jb1) eq unpack('H*', $b);
  print "ok 15\n";

  print "not " unless unpack('H*', $ju1) eq unpack('H*', $u);
  print "ok 16\n";

  print "not " unless unpack('H*', $jb2) eq unpack('H*', $b);
  print "ok 17\n";

  print "not " unless unpack('H*', $ju2) eq unpack('H*', $u);
  print "ok 18\n";
}
@


1.1.1.5
log
@perl 5.8.8 import
@
text
@d3 1
a3 1
print "1..22\n";
d82 4
a85 6
  {
      use bytes;
      print "not " unless $jb1 eq $b;
      print "ok 15\n";
  }
  print "not " unless $jb1 eq $b;
d88 4
a91 6
  {
      use bytes;
      print "not " unless $ju1 eq $u;
      print "ok 17\n";
  }
  print "not " unless $ju1 eq $u;
a92 16

  {
      use bytes;
      print "not " unless $jb2 eq $b;
      print "ok 19\n";
  }
  print "not " unless $jb2 eq $b;
  print "ok 20\n";

  {
      use bytes;
      print "not " unless $ju2 eq $u;
      print "ok 21\n";
  }
  print "not " unless $ju2 eq $u;
  print "ok 22\n";
@


1.1.1.6
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d3 1
a3 7
BEGIN {
    chdir 't' if -d 't';
    @@INC = '../lib';
    require './test.pl';
}

plan tests => 22;
d6 1
a6 1
is( join(':',@@x), '1:2:3', 'join an array with character');
d8 1
a8 1
is( join('',1,2,3), '123', 'join list with no separator');
d10 1
a10 1
is( join(':',split(/ /,"1 2 3")), '1:2:3', 'join implicit array with character');
d14 1
a14 1
is( $f, 'b,a,e', 'join list back to self, middle of list');
d18 1
a18 1
is( $f, 'a,b,e', 'join list back to self, beginning of list');
d22 1
a22 1
is( $f, 'baeak', 'join back to self, self is join character');
d30 2
a31 1
  main::is($r, '12:99:17:99', 'check for multiple read of tied objects, with separator');
d33 2
a34 1
  main::is($r, '22992799', 'check for multiple read of tied objects, w/o separator, and magic');
d41 2
a42 1
  is( $r, 'a::9:b::13:c', 'multiple read of undef, with separator');
d44 2
a45 1
  is( $r, 'a17b21c', '... and without separator');
d49 2
a50 1
  is( $s, "\x{1234}\x{ff}", 'join two characters with multiple bytes, get two characters');
d54 2
a55 1
  is( $s, "\x{1234}\x{ff}", 'high byte character as separator, 1 multi-byte character in front');
d59 2
a60 1
  is( $s, "\x{ff}\x{1234}\x{2345}", 'multibyte character as separator');
d64 2
a65 1
  is( $s, "\x{1234}\x{ff}\x{fe}", 'high byte as separator, multi-byte and high byte list');
a76 5
  sub byte_is {
    use bytes;
    return $_[0] eq $_[1] ? pass($_[2]) : fail($_[2]);
  }

d82 7
a88 1
  note( 'utf8 and byte checks, perl #24846' );
d90 7
a96 2
  byte_is($jb1, $b);
  is( $jb1, $b );
d98 7
a104 2
  byte_is($ju1, $u);
  is( $ju1, $u );
d106 7
a112 5
  byte_is($jb2, $b);
  is( $jb2, $b );

  byte_is($ju2, $u);
  is( $ju2, $u );
a113 1

@


1.1.1.7
log
@Import perl-5.20.1
@
text
@d9 1
a9 1
plan tests => 26;
a64 20

{ my $s = join('x', ());
  is( $s, '', 'join should return empty string for empty list');
}

{ my $s = join('', ());
  is( $s, '', 'join should return empty string for empty list and empty separator as well');
}

{ my $w;
  local $SIG{__WARN__} = sub { $w = shift };
  use warnings "uninitialized";
  my $s = join(undef, ());
  is( $s, '', 'join should return empty string for empty list, when separator is undef');
  # this warning isn't normative, the implementation may choose to
  # not evaluate the separator as a string if the list has fewer than
  # two elements
  like $w, qr/^Use of uninitialized value in join/, "should warn if separator is undef";
}

@


