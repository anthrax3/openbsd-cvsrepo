head	1.6;
access;
symbols
	OPENBSD_6_2:1.6.0.2
	OPENBSD_6_2_BASE:1.6
	PERL_5_24_2:1.1.1.6
	OPENBSD_6_1:1.6.0.4
	OPENBSD_6_1_BASE:1.6
	OPENBSD_6_0:1.5.0.26
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.20
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.22
	OPENBSD_5_8_BASE:1.5
	PERL_5_20_2:1.1.1.5
	OPENBSD_5_7:1.5.0.14
	OPENBSD_5_7_BASE:1.5
	PERL_5_20_1:1.1.1.5
	OPENBSD_5_6:1.5.0.18
	OPENBSD_5_6_BASE:1.5
	PERL_5_18_2:1.1.1.5
	PERL:1.1.1
	OPENBSD_5_5:1.5.0.16
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.12
	OPENBSD_5_4_BASE:1.5
	PERL_5_16_3:1.1.1.5
	OPENBSD_5_3:1.5.0.10
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.8
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.6
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	PERL_5_12_2:1.1.1.5
	OPENBSD_4_8:1.4.0.28
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.24
	OPENBSD_4_7_BASE:1.4
	PERL_5_10_1:1.1.1.4
	OPENBSD_4_6:1.4.0.26
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.22
	OPENBSD_4_5_BASE:1.4
	PERL_5_10_0:1.1.1.4
	OPENBSD_4_4:1.4.0.20
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.18
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.16
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.14
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.12
	OPENBSD_4_0_BASE:1.4
	PERL_5_8_8:1.1.1.4
	OPENBSD_3_9:1.4.0.10
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.8
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.6
	OPENBSD_3_7_BASE:1.4
	PERL_5_8_6:1.1.1.4
	OPENBSD_3_6:1.4.0.4
	OPENBSD_3_6_BASE:1.4
	PERL_5_8_5:1.1.1.4
	PERL_5_8_3:1.1.1.4
	OPENBSD_3_5:1.4.0.2
	OPENBSD_3_5_BASE:1.4
	PERL_5_8_2:1.1.1.4
	OPENBSD_3_4:1.3.0.4
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.3.0.2
	OPENBSD_3_3_BASE:1.3
	PERL_5_8_0:1.1.1.3
	OPENBSD_3_2:1.2.0.12
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.10
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.8
	OPENBSD_3_0_BASE:1.2
	PERL_5_6_1:1.1.1.2
	OPENBSD_2_9:1.2.0.6
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.1.0.8
	OPENBSD_2_6_BASE:1.1
	PERL_500503:1.1.1.1
	CPAN:1.1.1
	OPENBSD_2_5:1.1.0.6
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.4
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.2
	OPENBSD_2_3_BASE:1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.6
date	2017.02.05.00.32.20;	author afresh1;	state Exp;
branches;
next	1.5;
commitid	cxJ08BvJA9Pt2PTM;

1.5
date	2010.09.24.15.07.09;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2003.12.03.03.02.49;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2002.10.27.22.25.37;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.06.17.08.30;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	97.11.30.08.05.38;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.29.22.41.50;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.04.06.16.10.50;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.10.27.22.15.11;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.12.03.02.44.32;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2010.09.24.14.49.18;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2017.08.14.13.46.24;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@perl 5.004_04
@


1.6
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl

#
# test recursive functions.
#

BEGIN {
    chdir 't' if -d 't';
    @@INC = qw(. ../lib);
    require "./test.pl";
    plan(tests => 28);
}

use strict;

sub gcd {
    return gcd($_[0] - $_[1], $_[1]) if ($_[0] > $_[1]);
    return gcd($_[0], $_[1] - $_[0]) if ($_[0] < $_[1]);
    $_[0];
}

sub factorial {
    $_[0] < 2 ? 1 : $_[0] * factorial($_[0] - 1);
}

sub fibonacci {
    $_[0] < 2 ? 1 : fibonacci($_[0] - 2) + fibonacci($_[0] - 1);
}

# Highly recursive, highly aggressive.
# Kids, don't try this at home.
#
# For example ackermann(4,1) will take quite a long time.
# It will simply eat away your memory. Trust me.

sub ackermann {
    return $_[1] + 1               if ($_[0] == 0);
    return ackermann($_[0] - 1, 1) if ($_[1] == 0);
    ackermann($_[0] - 1, ackermann($_[0], $_[1] - 1));
}

# Highly recursive, highly boring.

sub takeuchi {
    $_[1] < $_[0] ?
	takeuchi(takeuchi($_[0] - 1, $_[1], $_[2]),
		 takeuchi($_[1] - 1, $_[2], $_[0]),
		 takeuchi($_[2] - 1, $_[0], $_[1]))
	    : $_[2];
}

is(gcd(1147, 1271), 31, "gcd(1147, 1271) == 31");

is(gcd(1908, 2016), 36, "gcd(1908, 2016) == 36");

is(factorial(10), 3628800, "factorial(10) == 3628800");

is(factorial(factorial(3)), 720, "factorial(factorial(3)) == 720");

is(fibonacci(10), 89, "fibonacci(10) == 89");

is(fibonacci(fibonacci(7)), 17711, "fibonacci(fibonacci(7)) == 17711");

my @@ack = qw(1 2 3 4 2 3 4 5 3 5 7 9 5 13 29 61);

for my $x (0..3) { 
    for my $y (0..3) {
	my $a = ackermann($x, $y);
	is($a, shift(@@ack), "ackermann($x, $y) == $a");
    }
}

my ($x, $y, $z) = (18, 12, 6);

is(takeuchi($x, $y, $z), $z + 1, "takeuchi($x, $y, $z) == $z + 1");

{
    sub get_first1 {
	get_list1(@@_)->[0];
    }

    sub get_list1 {
	return [curr_test] unless $_[0];
	my $u = get_first1(0);
	[$u];
    }
    my $x = get_first1(1);
    ok($x, "premature FREETMPS (change 5699)");
}

{
    sub get_first2 {
	return get_list2(@@_)->[0];
    }

    sub get_list2 {
	return [curr_test] unless $_[0];
	my $u = get_first2(0);
	return [$u];
    }
    my $x = get_first2(1);
    ok($x, "premature FREETMPS (change 5699)");
}

{
    local $^W = 0; # We do not need recursion depth warning.

    sub sillysum {
	return $_[0] + ($_[0] > 0 ? sillysum($_[0] - 1) : 0);
    }

    is(sillysum(1000), 1000*1001/2, "recursive sum of 1..1000");
}

# check ok for recursion depth > 65536
{
    my $r;
    eval { 
	$r = runperl(
		     nolib => 1,
		     stderr => 1,
		     prog => q{$d=0; $e=1; sub c { ++$d; if ($d > 66000) { $e=0 } else { c(); c() unless $d % 32768 } --$d } c(); exit $e});
    };
  SKIP: {
      skip("Out of memory -- increase your data/heap?", 2)
	  if $r =~ /Out of memory/i;
      is($r, '', "64K deep recursion - no output expected");
      is($?, 0, "64K deep recursion - no coredump expected");
  }
}

@


1.5
log
@merge in perl 5.12.2 plus local changes
@
text
@d10 1
a10 1
    require "test.pl";
@


1.4
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d128 1
a128 7

      if ($^O eq 'MacOS') {
          ok(1, "$^O: \$? is unreliable");
      } else {
          is($?, 0, "64K deep recursion - no coredump expected");
      }

@


1.3
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d11 1
a11 1
    plan(tests => 26);
d115 19
d135 2
a136 1

@


1.2
log
@perl-5.6.0 + local changes
@
text
@d7 8
a14 1
print "1..25\n";
d16 1
a16 1
sub gcd ($$) {
d22 1
a22 1
sub factorial ($) {
d26 1
a26 1
sub fibonacci ($) {
d36 1
a36 1
sub ackermann ($$) {
d44 1
a44 1
sub takeuchi ($$$) {
d52 1
a52 7
print 'not ' unless (($d = gcd(1147, 1271)) == 31);
print "ok 1\n";
print "# gcd(1147, 1271) = $d\n";

print 'not ' unless (($d = gcd(1908, 2016)) == 36);
print "ok 2\n";
print "# gcd(1908, 2016) = $d\n";
d54 1
a54 3
print 'not ' unless (($f = factorial(10)) == 3628800);
print "ok 3\n";
print "# factorial(10) = $f\n";
d56 1
a56 3
print 'not ' unless (($f = factorial(factorial(3))) == 720);
print "ok 4\n";
print "# factorial(factorial(3)) = $f\n";
d58 1
a58 3
print 'not ' unless (($f = fibonacci(10)) == 89);
print "ok 5\n";
print "# fibonacci(10) = $f\n";
d60 1
a60 3
print 'not ' unless (($f = fibonacci(fibonacci(7))) == 17711);
print "ok 6\n";
print "# fibonacci(fibonacci(7)) = $f\n";
d62 1
a62 1
$i = 7;
d64 1
a64 1
@@ack = qw(1 2 3 4 2 3 4 5 3 5 7 9 5 13 29 61);
d66 4
a69 6
for $x (0..3) { 
    for $y (0..3) {
	$a = ackermann($x, $y);
	print 'not ' unless ($a == shift(@@ack));
	print "ok ", $i++, "\n";
	print "# ackermann($x, $y) = $a\n";
d73 1
a73 1
($x, $y, $z) = (18, 12, 6);
d75 1
a75 3
print 'not ' unless (($t = takeuchi($x, $y, $z)) == $z + 1);
print "ok ", $i++, "\n";
print "# takeuchi($x, $y, $z) = $t\n";
d83 1
a83 1
	return [24] unless $_[0];
d88 1
a88 1
    print "ok $x\n";
d97 1
a97 1
	return [25] unless $_[0];
d102 11
a112 1
    print "ok $x\n";
d115 3
a117 1
$i = 26;
@


1.1
log
@perl 5.004_04
@
text
@d7 1
a7 1
print "1..23\n";
d87 30
@


1.1.1.1
log
@perl5.005_03
@
text
@@


1.1.1.2
log
@virgin perl 5.6.0
@
text
@d7 1
a7 1
print "1..25\n";
a86 30

{
    sub get_first1 {
	get_list1(@@_)->[0];
    }

    sub get_list1 {
	return [24] unless $_[0];
	my $u = get_first1(0);
	[$u];
    }
    my $x = get_first1(1);
    print "ok $x\n";
}

{
    sub get_first2 {
	return get_list2(@@_)->[0];
    }

    sub get_list2 {
	return [25] unless $_[0];
	my $u = get_first2(0);
	return [$u];
    }
    my $x = get_first2(1);
    print "ok $x\n";
}

$i = 26;
@


1.1.1.3
log
@stock perl 5.8.0 from CPAN
@
text
@d7 1
a7 8
BEGIN {
    chdir 't' if -d 't';
    @@INC = qw(. ../lib);
    require "test.pl";
    plan(tests => 26);
}

use strict;
d9 1
a9 1
sub gcd {
d15 1
a15 1
sub factorial {
d19 1
a19 1
sub fibonacci {
d29 1
a29 1
sub ackermann {
d37 1
a37 1
sub takeuchi {
d45 7
a51 1
is(gcd(1147, 1271), 31, "gcd(1147, 1271) == 31");
d53 3
a55 1
is(gcd(1908, 2016), 36, "gcd(1908, 2016) == 36");
d57 3
a59 1
is(factorial(10), 3628800, "factorial(10) == 3628800");
d61 3
a63 1
is(factorial(factorial(3)), 720, "factorial(factorial(3)) == 720");
d65 3
a67 1
is(fibonacci(10), 89, "fibonacci(10) == 89");
d69 1
a69 1
is(fibonacci(fibonacci(7)), 17711, "fibonacci(fibonacci(7)) == 17711");
d71 1
a71 1
my @@ack = qw(1 2 3 4 2 3 4 5 3 5 7 9 5 13 29 61);
d73 6
a78 4
for my $x (0..3) { 
    for my $y (0..3) {
	my $a = ackermann($x, $y);
	is($a, shift(@@ack), "ackermann($x, $y) == $a");
d82 1
a82 1
my ($x, $y, $z) = (18, 12, 6);
d84 3
a86 1
is(takeuchi($x, $y, $z), $z + 1, "takeuchi($x, $y, $z) == $z + 1");
d94 1
a94 1
	return [curr_test] unless $_[0];
d99 1
a99 1
    ok($x, "premature FREETMPS (change 5699)");
d108 1
a108 1
	return [curr_test] unless $_[0];
d113 1
a113 11
    ok($x, "premature FREETMPS (change 5699)");
}

{
    local $^W = 0; # We do not need recursion depth warning.

    sub sillysum {
	return $_[0] + ($_[0] > 0 ? sillysum($_[0] - 1) : 0);
    }

    is(sillysum(1000), 1000*1001/2, "recursive sum of 1..1000");
d116 1
a116 3



@


1.1.1.4
log
@perl 5.8.2 from CPAN
@
text
@d11 1
a11 1
    plan(tests => 28);
a114 19
# check ok for recursion depth > 65536
{
    my $r;
    eval { 
	$r = runperl(
		     nolib => 1,
		     stderr => 1,
		     prog => q{$d=0; $e=1; sub c { ++$d; if ($d > 66000) { $e=0 } else { c(); c() unless $d % 32768 } --$d } c(); exit $e});
    };
  SKIP: {
      skip("Out of memory -- increase your data/heap?", 2)
	  if $r =~ /Out of memory/i;
      is($r, '', "64K deep recursion - no output expected");

      if ($^O eq 'MacOS') {
          ok(1, "$^O: \$? is unreliable");
      } else {
          is($?, 0, "64K deep recursion - no coredump expected");
      }
d116 1
a116 2
  }
}
@


1.1.1.5
log
@Perl 5.12.2 from CPAN
@
text
@d128 7
a134 1
      is($?, 0, "64K deep recursion - no coredump expected");
@


1.1.1.6
log
@Import perl-5.24.2
@
text
@d10 1
a10 1
    require "./test.pl";
@


