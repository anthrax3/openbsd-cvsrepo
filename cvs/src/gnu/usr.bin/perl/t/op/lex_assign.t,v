head	1.2;
access;
symbols
	OPENBSD_6_2_BASE:1.2
	PERL_5_24_2:1.1.1.8
	OPENBSD_6_1:1.2.0.4
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.7.0.12
	OPENBSD_6_0_BASE:1.1.1.7
	OPENBSD_5_9:1.1.1.7.0.6
	OPENBSD_5_9_BASE:1.1.1.7
	OPENBSD_5_8:1.1.1.7.0.8
	OPENBSD_5_8_BASE:1.1.1.7
	PERL_5_20_2:1.1.1.7
	OPENBSD_5_7:1.1.1.7.0.2
	OPENBSD_5_7_BASE:1.1.1.7
	PERL_5_20_1:1.1.1.7
	OPENBSD_5_6:1.1.1.7.0.4
	OPENBSD_5_6_BASE:1.1.1.7
	PERL_5_18_2:1.1.1.7
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.6.0.6
	OPENBSD_5_5_BASE:1.1.1.6
	OPENBSD_5_4:1.1.1.6.0.2
	OPENBSD_5_4_BASE:1.1.1.6
	PERL_5_16_3:1.1.1.6
	OPENBSD_5_3:1.1.1.5.0.18
	OPENBSD_5_3_BASE:1.1.1.5
	OPENBSD_5_2:1.1.1.5.0.16
	OPENBSD_5_2_BASE:1.1.1.5
	OPENBSD_5_1_BASE:1.1.1.5
	OPENBSD_5_1:1.1.1.5.0.14
	OPENBSD_5_0:1.1.1.5.0.12
	OPENBSD_5_0_BASE:1.1.1.5
	OPENBSD_4_9:1.1.1.5.0.10
	OPENBSD_4_9_BASE:1.1.1.5
	PERL_5_12_2:1.1.1.5
	OPENBSD_4_8:1.1.1.5.0.8
	OPENBSD_4_8_BASE:1.1.1.5
	OPENBSD_4_7:1.1.1.5.0.4
	OPENBSD_4_7_BASE:1.1.1.5
	PERL_5_10_1:1.1.1.5
	OPENBSD_4_6:1.1.1.5.0.6
	OPENBSD_4_6_BASE:1.1.1.5
	OPENBSD_4_5:1.1.1.5.0.2
	OPENBSD_4_5_BASE:1.1.1.5
	PERL_5_10_0:1.1.1.5
	OPENBSD_4_4:1.1.1.4.0.10
	OPENBSD_4_4_BASE:1.1.1.4
	OPENBSD_4_3:1.1.1.4.0.8
	OPENBSD_4_3_BASE:1.1.1.4
	OPENBSD_4_2:1.1.1.4.0.6
	OPENBSD_4_2_BASE:1.1.1.4
	OPENBSD_4_1:1.1.1.4.0.4
	OPENBSD_4_1_BASE:1.1.1.4
	OPENBSD_4_0:1.1.1.4.0.2
	OPENBSD_4_0_BASE:1.1.1.4
	PERL_5_8_8:1.1.1.4
	OPENBSD_3_9:1.1.1.3.0.14
	OPENBSD_3_9_BASE:1.1.1.3
	OPENBSD_3_8:1.1.1.3.0.12
	OPENBSD_3_8_BASE:1.1.1.3
	OPENBSD_3_7:1.1.1.3.0.10
	OPENBSD_3_7_BASE:1.1.1.3
	PERL_5_8_6:1.1.1.3
	OPENBSD_3_6:1.1.1.3.0.8
	OPENBSD_3_6_BASE:1.1.1.3
	PERL_5_8_5:1.1.1.3
	PERL_5_8_3:1.1.1.3
	OPENBSD_3_5:1.1.1.3.0.6
	OPENBSD_3_5_BASE:1.1.1.3
	PERL_5_8_2:1.1.1.3
	OPENBSD_3_4:1.1.1.3.0.4
	OPENBSD_3_4_BASE:1.1.1.3
	OPENBSD_3_3:1.1.1.3.0.2
	OPENBSD_3_3_BASE:1.1.1.3
	PERL_5_8_0:1.1.1.3
	OPENBSD_3_2:1.1.1.2.0.6
	OPENBSD_3_2_BASE:1.1.1.2
	OPENBSD_3_1:1.1.1.2.0.4
	OPENBSD_3_1_BASE:1.1.1.2
	OPENBSD_3_0:1.1.1.2.0.2
	OPENBSD_3_0_BASE:1.1.1.2
	PERL_5_6_1:1.1.1.2
	OPENBSD_2_9:1.1.1.1.0.6
	OPENBSD_2_9_BASE:1.1.1.1
	OPENBSD_2_8:1.1.1.1.0.4
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.2
	OPENBSD_2_7_BASE:1.1.1.1
	PERL_5_6_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.32.20;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2000.04.06.16.10.49;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.04.06.16.10.49;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.05.24.18.25.39;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.10.27.22.15.10;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2006.03.28.18.49.45;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2008.09.29.17.19.01;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2013.03.25.20.09.36;	author sthen;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2014.03.24.14.59.10;	author afresh1;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2017.08.14.13.46.24;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl

# Test that $lexical = <some op> optimises the assignment away correctly
# and causes no ill side-effects.

BEGIN {
    chdir 't' if -d 't';
    @@INC = '../lib';
    require './test.pl';
}

$| = 1;
umask 0;
$xref = \ "";
$runme = $^X;
@@a = (1..5);
%h = (1..6);
$aref = \@@a;
$href = \%h;
open OP, qq{$runme -le "print 'aaa Ok ok' for 1..100"|};
$chopit = 'aaaaaa';
@@chopar = (113 .. 119);
$posstr = '123456';
$cstr = 'aBcD.eF';
pos $posstr = 3;
$nn = $n = 2;
sub subb {"in s"}

@@INPUT = <DATA>;
@@simple_input = grep /^\s*\w+\s*\$\w+\s*[#\n]/, @@INPUT;

sub wrn {"@@_"}

# Check correct optimization of ucfirst etc
my $a = "AB";
my $b = "\u\L$a";
is( $b, 'Ab', 'Check correct optimization of ucfirst, etc');

# Check correct destruction of objects:
my $dc = 0;
sub A::DESTROY {$dc += 1}
$a=8;
my $b;
{ my $c = 6; $b = bless \$c, "A"}

is($dc, 0, 'No destruction yet');

$b = $a+5;

is($dc, 1, 'object descruction via reassignment to variable');

my $xxx = 'b';
$xxx = 'c' . ($xxx || 'e');
is( $xxx, 'cb', 'variables can be read before being overwritten');

# Chains of assignments

my ($l1, $l2, $l3, $l4);
my $zzzz = 12;
$zzz1 = $l1 = $l2 = $zzz2 = $l3 = $l4 = 1 + $zzzz;

is($zzz1, 13, 'chain assignment, part1');
is($zzz2, 13, 'chain assignment, part2');
is($l1,   13, 'chain assignment, part3');
is($l2,   13, 'chain assignment, part4');
is($l3,   13, 'chain assignment, part5');
is($l4,   13, 'chain assignment, part6');

for (@@INPUT) {
  ($op, undef, $comment) = /^([^\#]+)(\#\s+(.*))?/;
  $comment = $op unless defined $comment;
  chomp;
  $op = "$op==$op" unless $op =~ /==/;
  ($op, $expectop) = $op =~ /(.*)==(.*)/;
  
  $skip = ($op =~ /^'\?\?\?'/ or $comment =~ /skip\(.*\Q$^O\E.*\)/i);
  $integer = ($comment =~ /^i_/) ? "use integer" : '' ;
  if ($skip) {
    SKIP: {
        skip $comment, 1;
    }
    next;
  }
  
  eval <<EOE;
  local \$SIG{__WARN__} = \\&wrn;
  my \$a = 'fake';
  $integer;
  \$a = $op;
  \$b = $expectop;
  is (\$a, \$b, \$comment);
EOE
  if ($@@) {
    $warning = $@@;
    chomp $warning;
    if ($@@ !~ /(?:is un|not )implemented/) {
      fail($_ . ' ' . $warning);
    }
  }
}

{				# Check calling STORE
  note('Tied variables, calling STORE');
  my $sc = 0;
  sub B::TIESCALAR {bless [11], 'B'}
  sub B::FETCH { -(shift->[0]) }
  sub B::STORE { $sc++; my $o = shift; $o->[0] = 17 + shift }

  my $m;
  tie $m, 'B';
  $m = 100;

  is( $sc, 1, 'STORE called when assigning scalar to tied variable' );

  my $t = 11;
  $m = $t + 89;
  
  is( $sc, 2, 'and again' );
  is( $m,  -117, 'checking the tied variable result' );

  $m += $t;

  is( $sc, 3, 'called on self-increment' );
  is( $m,  89, 'checking the tied variable result' );

  for (@@INPUT) {
    ($op, undef, $comment) = /^([^\#]+)(\#\s+(.*))?/;
    $comment = $op unless defined $comment;
    next if ($op =~ /^'\?\?\?'/ or $comment =~ /skip\(.*\Q$^O\E.*\)/i);
    $op =~ s/==.*//;
    
    $sc = 0;
    local $SIG{__WARN__} = \&wrn;
    eval "\$m = $op";
    is $sc, $@@ ? 0 : 1, "STORE count for $comment";
  }
}

for (@@simple_input) {
  ($op, undef, $comment) = /^([^\#]+)(\#\s+(.*))?/;
  $comment = $op unless defined $comment;
  chomp;
  ($operator, $variable) = /^\s*(\w+)\s*\$(\w+)/ or warn "misprocessed '$_'\n";
  eval <<EOE;
  local \$SIG{__WARN__} = \\&wrn;
  my \$$variable = "Ac# Ca\\nxxx";
  \$$variable = $operator \$$variable;
  \$toself = \$$variable;
  \$direct = $operator "Ac# Ca\\nxxx";
  is(\$toself, \$direct);
EOE
  if ($@@) {
    $warning = $@@;
    chomp $warning;
    if ($@@ =~ /(?:is un|not )implemented/) {
      SKIP: {
        skip $warning, 1;
        pass($comment);
      }
    } elsif ($@@ =~ /Can't (modify|take log of 0)/) {
      SKIP: {
        skip $warning . ' ' . $comment . ' syntax not good for selfassign', 1;
        pass();
      }
    } else {
      ##Something bad happened
      fail($_ . ' ' . $warning);
    }
  }
}

# [perl #123790] Assigning to a typeglob
# These used to die or crash.
# Once the bug is fixed for all ops, we can combine this with the tests
# above that use <DATA>.
for my $glob (*__) {
  $glob = $y x $z;
  { use integer; $glob = $y <=> $z; }
  $glob = $y cmp $z;
  $glob = vec 1, 2, 4;
  $glob = ~${\""};
  $glob = split;
}

# XXX This test does not really belong here, as it has nothing to do with
#     OPpTARGET_MY optimisation.  But where should it go?
eval {
    sub PVBM () { 'foo' }
    index 'foo', PVBM;
    my $x = PVBM;

    my $str = 'foo';
    my $pvlv = \substr $str, 0, 1;
    $x = $pvlv;

    1;
};
is($@@, '', 'ex-PVBM assert'.$@@);

# RT perl #127855
# Check that stringification and assignment to itself doesn't break
# anything. This is unlikely to actually fail the tests; its more something
# for valgrind to spot. It will also only fail if SvGROW or its caller
# decides to over-allocate (otherwise copying the string will skip the
# sv_grow(), as the new size is the same as the current size).

{
    my $s;
    for my $len (1..40) {
        $s = 'x' x $len;
        my $t = $s;
        $t = "$t";
        ok($s eq $t, "RT 127855: len=$len");
    }
}


done_testing();

__END__
ref $xref			# ref
ref $cstr			# ref nonref
`$runme -e "print qq[1\\n]"`				# backtick skip(MSWin32)
`$undefed`			# backtick undef skip(MSWin32)
<*>				# glob
<OP>				# readline
'faked'				# rcatline
(@@z = (1 .. 3))			# aassign
(chop (@@x=@@chopar))		# chop
chop $chopit			# schop
(chomp (@@x=@@chopar))		# chomp
chomp $chopit			# schomp
pos $posstr			# pos
pos $chopit			# pos returns undef
$nn++==2			# postinc
$nn++==3			# i_postinc
$nn--==4			# postdec
$nn--==3			# i_postdec
$n ** $n			# pow
$n * $n				# multiply
$n * $n				# i_multiply
$n / $n				# divide
$n / $n				# i_divide
$n % $n				# modulo
$n % $n				# i_modulo
$n x $n				# repeat
$n + $n				# add
$n + $n				# i_add
$n - $n				# subtract
$n - $n				# i_subtract
$n . $n				# concat
$n . $a=='2fake'		# concat with self
"3$a"=='3fake'			# concat with self in stringify
"$n"				# stringify
$n << $n			# left_shift
$n >> $n			# right_shift
$n <=> $n			# ncmp
$n <=> $n			# i_ncmp
$n cmp $n			# scmp
$n & $n				# bit_and
$n ^ $n				# bit_xor
$n | $n				# bit_or
-$n				# negate
-$n				# i_negate
-$a=="-fake"			# i_negate with string
~$n				# complement
atan2 $n,$n			# atan2
sin $n				# sin
cos $n				# cos
'???'				# rand
exp $n				# exp
log $n				# log
sqrt $n				# sqrt
int $n				# int
hex $n				# hex
oct $n				# oct
abs $n				# abs
length $posstr			# length
substr $posstr, 2, 2		# substr
vec("abc",2,8)			# vec
index $posstr, 2		# index
rindex $posstr, 2		# rindex
sprintf "%i%i", $n, $n		# sprintf
ord $n				# ord
chr $n				# chr
chr ${\256}			# chr $wide
crypt $n, $n			# crypt
ucfirst ($cstr . "a")		# ucfirst padtmp
ucfirst $cstr			# ucfirst
lcfirst $cstr			# lcfirst
uc $cstr			# uc
lc $cstr			# lc
quotemeta $cstr			# quotemeta
@@$aref				# rv2av
@@$undefed			# rv2av undef
(each %h) % 2 == 1		# each
values %h			# values
keys %h				# keys
%$href				# rv2hv
pack "C2", $n,$n		# pack
split /a/, "abad"		# split
join "a"; @@a			# join
push @@a,3==6			# push
unshift @@aaa			# unshift
reverse	@@a			# reverse
reverse	$cstr			# reverse - scal
grep $_, 1,0,2,0,3		# grepwhile
map "x$_", 1,0,2,0,3		# mapwhile
subb()				# entersub
caller				# caller
warn "ignore this\n"		# warn
'faked'				# die
open BLAH, "<non-existent"	# open
fileno STDERR			# fileno
umask 0				# umask
select STDOUT			# sselect
select undef,undef,undef,0	# select
getc OP				# getc
'???'				# read
'???'				# sysread
'???'				# syswrite
'???'				# send
'???'				# recv
'???'				# tell
'???'				# fcntl
'???'				# ioctl
'???'				# flock
'???'				# accept
'???'				# shutdown
'???'				# ftsize
'???'				# ftmtime
'???'				# ftatime
'???'				# ftctime
chdir 'non-existent'		# chdir
'???'				# chown
'???'				# chroot
unlink 'non-existent'		# unlink
chmod 'non-existent'		# chmod
utime 'non-existent'		# utime
rename 'non-existent', 'non-existent1'	# rename
link 'non-existent', 'non-existent1' # link
'???'				# symlink
readlink 'non-existent', 'non-existent1' # readlink
'???'				# mkdir
'???'				# rmdir
'???'				# telldir
'???'				# fork
'???'				# wait
'???'				# waitpid
system "$runme -e 0"		# system skip(VMS)
'???'				# exec
'???'				# kill
getppid				# getppid
getpgrp				# getpgrp
setpgrp				# setpgrp
getpriority $$, $$		# getpriority
'???'				# setpriority
time				# time
localtime $^T			# localtime
gmtime $^T			# gmtime
'???'				# sleep: can randomly fail
'???'				# alarm
'???'				# shmget
'???'				# shmctl
'???'				# shmread
'???'				# shmwrite
'???'				# msgget
'???'				# msgctl
'???'				# msgsnd
'???'				# msgrcv
'???'				# semget
'???'				# semctl
'???'				# semop
'???'				# getlogin
'???'				# syscall
@


1.1
log
@Initial revision
@
text
@d3 3
d8 2
a9 1
    unshift @@INC, '../lib';
a10 1
$ENV{PERL_DESTRUCT_LEVEL} = 0 unless $ENV{PERL_DESTRUCT_LEVEL} > 3; 
d12 1
d15 1
a15 1
$runme = ($^O eq 'VMS' ? 'MCR ' : '') . $^X;
a30 2
print "1..", (10 + @@INPUT + @@simple_input), "\n";
$ord = 0;
a34 1
$ord++;
d37 1
a37 2
print "not " unless $b eq 'Ab';
print "ok $ord\n";
d46 1
a46 3
$ord++;
print "not " unless $dc == 0;
print "ok $ord\n";
d50 1
a50 3
$ord++;
print "not " unless $dc == 1;
print "ok $ord\n";
a51 1
$ord++;
d54 1
a54 39
print "not " unless $xxx eq 'cb';
print "ok $ord\n";

{				# Check calling STORE
  my $sc = 0;
  sub B::TIESCALAR {bless [11], 'B'}
  sub B::FETCH { -(shift->[0]) }
  sub B::STORE { $sc++; my $o = shift; $o->[0] = 17 + shift }

  my $m;
  tie $m, 'B';
  $m = 100;

  $ord++;
  print "not " unless $sc == 1;
  print "ok $ord\n";

  my $t = 11;
  $m = $t + 89;
  
  $ord++;
  print "not " unless $sc == 2;
  print "ok $ord\n";

  $ord++;
  print "# $m\nnot " unless $m == -117;
  print "ok $ord\n";

  $m += $t;

  $ord++;
  print "not " unless $sc == 3;
  print "ok $ord\n";

  $ord++;
  print "# $m\nnot " unless $m == 89;
  print "ok $ord\n";

}
d62 6
a67 5
$ord++;
print "# $zzz1 = $l1 = $l2 = $zzz2 = $l3 = $l4 = 13\nnot "
  unless $zzz1 == 13 and $zzz2 == 13 and $l1 == 13
  and $l2 == 13 and $l3 == 13 and $l4 == 13;
print "ok $ord\n";
a69 1
  $ord++;
d72 1
d76 1
a76 2
  $skip = ($op =~ /^'\?\?\?'/ or $comment =~ /skip\(.*\Q$^O\E.*\)/i)
	  ? "skip" : "not";
d78 6
a83 1
  (print "#skipping $comment:\nok $ord\n"), next if $skip eq 'skip';
d91 1
a91 5
  if (\$a ne \$b) {
    print "# \$comment: got `\$a', expected `\$b'\n";
    print "\$skip " if \$a ne \$b or \$skip eq 'skip';
  }
  print "ok \$ord\\n";
d94 4
a97 5
    if ($@@ =~ /is unimplemented/) {
      print "# skipping $comment: unimplemented:\nok $ord\n";
    } else {
      warn $@@;
      print "not ok $ord\n";
d102 37
a139 1
  $ord++;
d142 1
d150 1
a150 3
  print "# \\\$$variable = $operator \\\$$variable\\nnot "
    unless \$toself eq \$direct;
  print "ok \$ord\\n";
d153 7
a159 2
    if ($@@ =~ /is unimplemented/) {
      print "# skipping $comment: unimplemented:\nok $ord\n";
d161 4
a164 1
      print "# skipping $comment: syntax not good for selfassign:\nok $ord\n";
d166 2
a167 2
      warn $@@;
      print "not ok $ord\n";
d171 49
d223 1
a223 1
`$runme -e "print qq[1\n]"`				# backtick skip(MSWin32)
d229 4
a232 4
chop $chopit			# chop
(chop (@@x=@@chopar))		# schop
chomp $chopit			# chomp
(chop (@@x=@@chopar))		# schomp
d265 1
d286 1
d296 1
a296 1
each %h==1			# each
d317 1
a317 1
select "","","",0		# select
d355 1
a355 1
'???'				# setpgrp
d361 1
a361 1
sleep 1				# sleep
@


1.1.1.1
log
@virgin perl 5.6.0
@
text
@@


1.1.1.2
log
@stock perl 5.6.1
@
text
@d5 1
a5 1
    @@INC = '../lib';
d7 1
a114 1
  chomp;
d119 1
a119 1
	  ? "skip" : "# '$_'\nnot";
d140 1
a140 1
      print "# '$_'\nnot ok $ord\n";
a148 1
  chomp;
d167 1
a167 1
      print "# '$_'\nnot ok $ord\n";
d174 1
a174 1
`$runme -e "print qq[1\\n]"`				# backtick skip(MSWin32)
d245 1
a245 1
(each %h) % 2 == 1		# each
d310 1
a310 1
'???'				# sleep: can randomly fail
@


1.1.1.3
log
@stock perl 5.8.0 from CPAN
@
text
@a7 1
$| = 1;
@


1.1.1.4
log
@perl 5.8.8 import
@
text
@d268 1
a268 1
select undef,undef,undef,0	# select
@


1.1.1.5
log
@import perl 5.10.0 from CPAN
@
text
@d11 1
a11 1
$runme = $^X;
d27 1
a27 1
print "1..", (11 + @@INPUT + @@simple_input), "\n";
a172 19

$ord++;
eval {
    sub PVBM () { 'foo' }
    index 'foo', PVBM;
    my $x = PVBM;

    my $str = 'foo';
    my $pvlv = \substr $str, 0, 1;
    $x = $pvlv;

    1;
};
if ($@@) {
    warn "# $@@";
    print 'not ';
}
print "ok $ord\n";

@


1.1.1.6
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d131 1
a131 1
    print "# \$comment: got '\$a', expected '\$b'\n";
@


1.1.1.7
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@a5 1
    require './test.pl';
d27 2
d33 1
d36 2
a37 1
is( $b, 'Ab', 'Check correct optimization of ucfirst, etc');
d46 3
a48 1
is($dc, 0, 'No destruction yet');
d52 3
a54 1
is($dc, 1, 'object descruction via reassignment to variable');
d56 1
d59 2
a60 1
is( $xxx, 'cb', 'variables can be read before being overwritten');
a62 1
  note('Tied variables, calling STORE');
d72 3
a74 1
  is( $sc, 1, 'STORE called when assigning scalar to tied variable' );
d79 7
a85 2
  is( $sc, 2, 'and again' );
  is( $m,  -117, 'checking the tied variable result' );
d89 7
a95 2
  is( $sc, 3, 'called on self-increment' );
  is( $m,  89, 'checking the tied variable result' );
d105 5
a109 6
is($zzz1, 13, 'chain assignment, part1');
is($zzz2, 13, 'chain assignment, part2');
is($l1,   13, 'chain assignment, part3');
is($l2,   13, 'chain assignment, part4');
is($l3,   13, 'chain assignment, part5');
is($l4,   13, 'chain assignment, part6');
d112 1
d122 1
a122 7
  if ($skip eq 'skip') {
    SKIP: {
        skip $comment, 1;
        pass();
    }
    next;
  }
d131 2
a132 4
    SKIP: {
        skip "\$comment: got '\$a', expected '\$b'", 1;
        pass("")
    }
d134 1
a134 1
  pass();
a136 2
    $warning = $@@;
    chomp $warning;
d138 1
a138 4
      SKIP: {
        skip $warning, 1;
        pass($comment);
      }
d140 2
a141 1
      fail($_ . ' ' . $warning);
d147 1
d158 3
a160 1
  is(\$toself, \$direct);
a162 2
    $warning = $@@;
    chomp $warning;
d164 1
a164 4
      SKIP: {
        skip $warning, 1;
        pass($comment);
      }
d166 1
a166 4
      SKIP: {
        skip $warning . ' ' . $comment . ' syntax not good for selfassign', 1;
        pass();
      }
d168 2
a169 2
      ##Something bad happened
      fail($_ . ' ' . $warning);
d174 1
d186 5
a190 3
is($@@, '', 'ex-PVBM assert'.$@@);

done_testing();
@


1.1.1.8
log
@Import perl-5.24.2
@
text
@a2 3
# Test that $lexical = <some op> optimises the assignment away correctly
# and causes no ill side-effects.

d53 26
d99 2
a100 1
  $skip = ($op =~ /^'\?\?\?'/ or $comment =~ /skip\(.*\Q$^O\E.*\)/i);
d102 1
a102 1
  if ($skip) {
d105 1
d116 7
a122 1
  is (\$a, \$b, \$comment);
d127 6
a132 1
    if ($@@ !~ /(?:is un|not )implemented/) {
a137 37
{				# Check calling STORE
  note('Tied variables, calling STORE');
  my $sc = 0;
  sub B::TIESCALAR {bless [11], 'B'}
  sub B::FETCH { -(shift->[0]) }
  sub B::STORE { $sc++; my $o = shift; $o->[0] = 17 + shift }

  my $m;
  tie $m, 'B';
  $m = 100;

  is( $sc, 1, 'STORE called when assigning scalar to tied variable' );

  my $t = 11;
  $m = $t + 89;
  
  is( $sc, 2, 'and again' );
  is( $m,  -117, 'checking the tied variable result' );

  $m += $t;

  is( $sc, 3, 'called on self-increment' );
  is( $m,  89, 'checking the tied variable result' );

  for (@@INPUT) {
    ($op, undef, $comment) = /^([^\#]+)(\#\s+(.*))?/;
    $comment = $op unless defined $comment;
    next if ($op =~ /^'\?\?\?'/ or $comment =~ /skip\(.*\Q$^O\E.*\)/i);
    $op =~ s/==.*//;
    
    $sc = 0;
    local $SIG{__WARN__} = \&wrn;
    eval "\$m = $op";
    is $sc, $@@ ? 0 : 1, "STORE count for $comment";
  }
}

d154 1
a154 1
    if ($@@ =~ /(?:is un|not )implemented/) {
a170 15
# [perl #123790] Assigning to a typeglob
# These used to die or crash.
# Once the bug is fixed for all ops, we can combine this with the tests
# above that use <DATA>.
for my $glob (*__) {
  $glob = $y x $z;
  { use integer; $glob = $y <=> $z; }
  $glob = $y cmp $z;
  $glob = vec 1, 2, 4;
  $glob = ~${\""};
  $glob = split;
}

# XXX This test does not really belong here, as it has nothing to do with
#     OPpTARGET_MY optimisation.  But where should it go?
a183 18
# RT perl #127855
# Check that stringification and assignment to itself doesn't break
# anything. This is unlikely to actually fail the tests; its more something
# for valgrind to spot. It will also only fail if SvGROW or its caller
# decides to over-allocate (otherwise copying the string will skip the
# sv_grow(), as the new size is the same as the current size).

{
    my $s;
    for my $len (1..40) {
        $s = 'x' x $len;
        my $t = $s;
        $t = "$t";
        ok($s eq $t, "RT 127855: len=$len");
    }
}


d195 4
a198 4
(chop (@@x=@@chopar))		# chop
chop $chopit			# schop
(chomp (@@x=@@chopar))		# chomp
chomp $chopit			# schomp
a230 1
-$a=="-fake"			# i_negate with string
a250 1
chr ${\256}			# chr $wide
d319 1
a319 1
setpgrp				# setpgrp
@


