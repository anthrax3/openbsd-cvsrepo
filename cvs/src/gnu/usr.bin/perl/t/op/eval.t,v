head	1.13;
access;
symbols
	OPENBSD_6_2:1.13.0.6
	OPENBSD_6_2_BASE:1.13
	PERL_5_24_2:1.1.1.12
	OPENBSD_6_1:1.13.0.4
	OPENBSD_6_1_BASE:1.13
	OPENBSD_6_0:1.12.0.10
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.12.0.4
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.12.0.6
	OPENBSD_5_8_BASE:1.12
	PERL_5_20_2:1.1.1.11
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	PERL_5_20_1:1.1.1.11
	OPENBSD_5_6:1.11.0.4
	OPENBSD_5_6_BASE:1.11
	PERL_5_18_2:1.1.1.10
	PERL:1.1.1
	OPENBSD_5_5:1.10.0.6
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.2
	OPENBSD_5_4_BASE:1.10
	PERL_5_16_3:1.1.1.9
	OPENBSD_5_3:1.9.0.10
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.8
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.6
	OPENBSD_5_0:1.9.0.4
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.2
	OPENBSD_4_9_BASE:1.9
	PERL_5_12_2:1.1.1.8
	OPENBSD_4_8:1.8.0.4
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	PERL_5_10_1:1.1.1.7
	OPENBSD_4_6:1.7.0.6
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.2
	OPENBSD_4_5_BASE:1.7
	PERL_5_10_0:1.1.1.6
	OPENBSD_4_4:1.6.0.20
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.18
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.16
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.14
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.12
	OPENBSD_4_0_BASE:1.6
	PERL_5_8_8:1.1.1.5
	OPENBSD_3_9:1.6.0.10
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.8
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.6
	OPENBSD_3_7_BASE:1.6
	PERL_5_8_6:1.1.1.5
	OPENBSD_3_6:1.6.0.4
	OPENBSD_3_6_BASE:1.6
	PERL_5_8_5:1.1.1.5
	PERL_5_8_3:1.1.1.5
	OPENBSD_3_5:1.6.0.2
	OPENBSD_3_5_BASE:1.6
	PERL_5_8_2:1.1.1.5
	OPENBSD_3_4:1.5.0.4
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.4.0.12
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.10
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.8
	OPENBSD_3_0_BASE:1.4
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.13
date	2017.02.05.00.32.20;	author afresh1;	state Exp;
branches;
next	1.12;
commitid	cxJ08BvJA9Pt2PTM;

1.12
date	2014.11.17.20.57.07;	author afresh1;	state Exp;
branches;
next	1.11;
commitid	QP75iYx42Uo7mMxO;

1.11
date	2014.03.24.15.05.33;	author afresh1;	state Exp;
branches;
next	1.10;

1.10
date	2013.03.25.20.40.59;	author sthen;	state Exp;
branches;
next	1.9;

1.9
date	2010.09.24.15.07.08;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2009.10.12.18.30.27;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2008.09.29.17.36.19;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2003.12.03.03.02.48;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.10.27.22.25.37;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.08.22;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.52.34;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.08.05.18;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.13.17;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.13.17;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.41.44;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.10.48;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.27.22.15.10;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.12.03.02.44.31;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2008.09.29.17.19.00;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2009.10.12.18.10.44;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2010.09.24.14.49.18;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2013.03.25.20.09.35;	author sthen;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2014.03.24.14.59.10;	author afresh1;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2014.11.17.20.53.17;	author afresh1;	state Exp;
branches;
next	1.1.1.12;
commitid	B31cAbBIXiCqnL97;

1.1.1.12
date	2017.08.14.13.46.23;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.13
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl

BEGIN {
    chdir 't' if -d 't';
    require './test.pl';
    set_up_inc('../lib');
}

plan(tests => 134);

eval 'pass();';

is($@@, '');

eval "\$foo\n    = # this is a comment\n'ok 3';";
is($foo, 'ok 3');

eval "\$foo\n    = # this is a comment\n'ok 4\n';";
is($foo, "ok 4\n");

print eval '
$foo =;';		# this tests for a call through yyerror()
like($@@, qr/line 2/);

print eval '$foo = /';	# this tests for a call through fatal()
like($@@, qr/Search/);

is scalar(eval '++'), undef, 'eval syntax error in scalar context';
is scalar(eval 'die'), undef, 'eval run-time error in scalar context';
is +()=eval '++', 0, 'eval syntax error in list context';
is +()=eval 'die', 0, 'eval run-time error in list context';

is(eval '"ok 7\n";', "ok 7\n");

$foo = 5;
$fact = 'if ($foo <= 1) {1;} else {push(@@x,$foo--); (eval $fact) * pop(@@x);}';
$ans = eval $fact;
is($ans, 120, 'calculate a factorial with recursive evals');

$foo = 5;
$fact = 'local($foo)=$foo; $foo <= 1 ? 1 : $foo-- * (eval $fact);';
$ans = eval $fact;
is($ans, 120, 'calculate a factorial with recursive evals');

my $curr_test = curr_test();
my $tempfile = tempfile();
open(try,'>',$tempfile);
print try 'print "ok $curr_test\n";',"\n";
close try;

do "./$tempfile"; print $@@;

# Test the singlequoted eval optimizer

$i = $curr_test + 1;
for (1..3) {
    eval 'print "ok ", $i++, "\n"';
}

$curr_test += 4;

eval {
    print "ok $curr_test\n";
    die sprintf "ok %d\n", $curr_test + 2;
    1;
} || printf "ok %d\n$@@", $curr_test + 1;

curr_test($curr_test + 3);

# check whether eval EXPR determines value of EXPR correctly

{
  my @@a = qw(a b c d);
  my @@b = eval @@a;
  is("@@b", '4');
  is($@@, '');

  my $a = q[defined(wantarray) ? (wantarray ? ($b='A') : ($b='S')) : ($b='V')];
  my $b;
  @@a = eval $a;
  is("@@a", 'A');
  is(  $b, 'A');
  $_ = eval $a;
  is(  $b, 'S');
  eval $a;
  is(  $b, 'V');

  $b = 'wrong';
  $x = sub {
     my $b = "right";
     is(eval('"$b"'), $b);
  };
  &$x();
}

{
  my $b = 'wrong';
  my $X = sub {
     my $b = "right";
     is(eval('"$b"'), $b);
  };
  &$X();
}

# check navigation of multiple eval boundaries to find lexicals

my $x = 'aa';
eval <<'EOT'; die if $@@;
  print "# $x\n";	# clone into eval's pad
  sub do_eval1 {
     eval $_[0]; die if $@@;
  }
EOT
do_eval1('is($x, "aa")');
$x++;
do_eval1('eval q[is($x, "ab")]');
$x++;
do_eval1('sub { print "# $x\n"; eval q[is($x, "ac")] }->()');
$x++;

# calls from within eval'' should clone outer lexicals

eval <<'EOT'; die if $@@;
  sub do_eval2 {
     eval $_[0]; die if $@@;
  }
do_eval2('is($x, "ad")');
$x++;
do_eval2('eval q[is($x, "ae")]');
$x++;
do_eval2('sub { print "# $x\n"; eval q[is($x, "af")] }->()');
EOT

# calls outside eval'' should NOT clone lexicals from called context

$main::ok = 'not ok';
my $ok = 'ok';
eval <<'EOT'; die if $@@;
  # $x unbound here
  sub do_eval3 {
     eval $_[0]; die if $@@;
  }
EOT
{
    my $ok = 'not ok';
    do_eval3('is($ok, q{ok})');
    do_eval3('eval q[is($ok, q{ok})]');
    do_eval3('sub { eval q[is($ok, q{ok})] }->()');
}

{
    my $x = curr_test();
    my $got;
    sub recurse {
	my $l = shift;
	if ($l < $x) {
	    ++$l;
	    eval 'print "# level $l\n"; recurse($l);';
	    die if $@@;
	}
	else {
	    $got = "ok $l";
	}
    }
    local $SIG{__WARN__} = sub { fail() if $_[0] =~ /^Deep recurs/ };
    recurse(curr_test() - 5);

    is($got, "ok $x",
       "recursive subroutine-call inside eval'' see its own lexicals");
}


eval <<'EOT';
  sub create_closure {
    my $self = shift;
    return sub {
       return $self;
    };
  }
EOT
is(create_closure("good")->(), "good",
   'closures created within eval bind correctly');

$main::r = "good";
sub terminal { eval '$r . q{!}' }
is(do {
   my $r = "bad";
   eval 'terminal($r)';
}, 'good!', 'lexical search terminates correctly at subroutine boundary');

{
    # Have we cured panic which occurred with require/eval in die handler ?
    local $SIG{__DIE__} = sub { eval {1}; die shift };
    eval { die "wham_eth\n" };
    is($@@, "wham_eth\n");
}

{
    my $c = eval "(1,2)x10";
    is($c, '2222222222', 'scalar eval"" pops stack correctly');
}

# return from eval {} should clear $@@ correctly
{
    my $status = eval {
	eval { die };
	print "# eval { return } test\n";
	return; # removing this changes behavior
    };
    is($@@, '', 'return from eval {} should clear $@@ correctly');
}

# ditto for eval ""
{
    my $status = eval q{
	eval q{ die };
	print "# eval q{ return } test\n";
	return; # removing this changes behavior
    };
    is($@@, '', 'return from eval "" should clear $@@ correctly');
}

# Check that eval catches bad goto calls
#   (BUG ID 20010305.003)
{
    eval {
	eval { goto foo; };
	like($@@, qr/Can't "goto" into the middle of a foreach loop/,
	     'eval catches bad goto calls');
	last;
	foreach my $i (1) {
	    foo: fail('jumped into foreach');
	}
    };
    fail("Outer eval didn't execute the last");
    diag($@@);
}

# Make sure that "my $$x" is forbidden
# 20011224 MJD
{
    foreach (qw($$x @@$x %$x $$$x)) {
	eval 'my ' . $_;
	isnt($@@, '', "my $_ is forbidden");
    }
}

{
    $@@ = 5;
    eval q{};
    cmp_ok(length $@@, '==', 0, '[ID 20020623.002] eval "" doesn\'t clear $@@');
}

# DAPM Nov-2002. Perl should now capture the full lexical context during
# evals.

$::zzz = $::zzz = 0;
my $zzz = 1;

eval q{
    sub fred1 {
	eval q{ is(eval '$zzz', 1); }
    }
    fred1(47);
    { my $zzz = 2; fred1(48) }
};

eval q{
    sub fred2 {
	is(eval('$zzz'), 1);
    }
};
fred2(49);
{ my $zzz = 2; fred2(50) }

# sort() starts a new context stack. Make sure we can still find
# the lexically enclosing sub

sub do_sort {
    my $zzz = 2;
    my @@a = sort
	    { is(eval('$zzz'), 2); $a <=> $b }
	    2, 1;
}
do_sort();

# more recursion and lexical scope leak tests

eval q{
    my $r = -1;
    my $yyy = 9;
    sub fred3 {
	my $l = shift;
	my $r = -2;
	return 1 if $l < 1;
	return 0 if eval '$zzz' != 1;
	return 0 if       $yyy  != 9;
	return 0 if eval '$yyy' != 9;
	return 0 if eval '$l' != $l;
	return $l * fred3($l-1);
    }
    my $r = fred3(5);
    is($r, 120);
    $r = eval'fred3(5)';
    is($r, 120);
    $r = 0;
    eval '$r = fred3(5)';
    is($r, 120);
    $r = 0;
    { my $yyy = 4; my $zzz = 5; my $l = 6; $r = eval 'fred3(5)' };
    is($r, 120);
};
my $r = fred3(5);
is($r, 120);
$r = eval'fred3(5)';
is($r, 120);
$r = 0;
eval'$r = fred3(5)';
is($r, 120);
$r = 0;
{ my $yyy = 4; my $zzz = 5; my $l = 6; $r = eval 'fred3(5)' };
is($r, 120);

# check that goto &sub within evals doesn't leak lexical scope

my $yyy = 2;

sub fred4 { 
    my $zzz = 3;
    is($zzz, 3);
    is(eval '$zzz', 3);
    is(eval '$yyy', 2);
}

eval q{
    fred4();
    sub fred5 {
	my $zzz = 4;
	is($zzz, 4);
	is(eval '$zzz', 4);
	is(eval '$yyy', 2);
	goto &fred4;
    }
    fred5();
};
fred5();
{ my $yyy = 88; my $zzz = 99; fred5(); }
eval q{ my $yyy = 888; my $zzz = 999; fred5(); };

{
   $eval = eval 'sub { eval "sub { %S }" }';
   $eval->({});
   pass('[perl #9728] used to dump core');
}

# evals that appear in the DB package should see the lexical scope of the
# thing outside DB that called them (usually the debugged code), rather
# than the usual surrounding scope

our $x = 1;
{
    my $x=2;
    sub db1	{ $x; eval '$x' }
    sub DB::db2	{ $x; eval '$x' }
    package DB;
    sub db3	{ eval '$x' }
    sub DB::db4	{ eval '$x' }
    sub db5	{ my $x=4; eval '$x' }
    package main;
    sub db6	{ my $x=4; eval '$x' }
}
{
    my $x = 3;
    is(db1(),      2);
    is(DB::db2(),  2);
    is(DB::db3(),  3);
    is(DB::db4(),  3);
    is(DB::db5(),  3);
    is(db6(),      4);
}

# [perl #19022] used to end up with shared hash warnings
# The program should generate no output, so anything we see is on stderr
my $got = runperl (prog => '$h{a}=1; foreach my $k (keys %h) {eval qq{\$k}}',
		   stderr => 1);
is ($got, '');

# And a buggy way of fixing #19022 made this fail - $k became undef after the
# eval for a build with copy on write
{
  my %h;
  $h{a}=1;
  foreach my $k (keys %h) {
    is($k, 'a');

    eval "\$k";

    is($k, 'a');
  }
}

sub Foo {} print Foo(eval {});
pass('#20798 (used to dump core)');

# check for context in string eval
{
  my(@@r,$r,$c);
  sub context { defined(wantarray) ? (wantarray ? ($c='A') : ($c='S')) : ($c='V') }

  my $code = q{ context() };
  @@r = qw( a b );
  $r = 'ab';
  @@r = eval $code;
  is("@@r$c", 'AA', 'string eval list context');
  $r = eval $code;
  is("$r$c", 'SS', 'string eval scalar context');
  eval $code;
  is("$c", 'V', 'string eval void context');
}

# [perl #34682] escaping an eval with last could coredump or dup output

$got = runperl (
    prog => 
    'sub A::TIEARRAY { L: { eval { last L } } } tie @@a, A; warn qq(ok\n)',
stderr => 1);

is($got, "ok\n", 'eval and last');

# eval undef should be the same as eval "" barring any warnings

{
    local $@@ = "foo";
    eval undef;
    is($@@, "", 'eval undef');
}

{
    no warnings;
    eval "&& $b;";
    like($@@, qr/^syntax error/, 'eval syntax error, no warnings');
}

# a syntax error in an eval called magically (eg via tie or overload)
# resulted in an assertion failure in S_docatch, since doeval_compile had
# already popped the EVAL context due to the failure, but S_docatch
# expected the context to still be there.

{
    my $ok  = 0;
    package Eval1;
    sub STORE { eval '('; $ok = 1 }
    sub TIESCALAR { bless [] }

    my $x;
    tie $x, bless [];
    $x = 1;
    ::is($ok, 1, 'eval docatch');
}

# [perl #51370] eval { die "\x{a10d}" } followed by eval { 1 } did not reset
# length $@@ 
$@@ = "";
eval { die "\x{a10d}"; };
$_ = length $@@;
eval { 1 };

cmp_ok($@@, 'eq', "", 'length of $@@ after eval');
cmp_ok(length $@@, '==', 0, 'length of $@@ after eval');

# Check if eval { 1 }; completely resets $@@
SKIP: {
    skip_if_miniperl('no dynamic loading on miniperl, no Devel::Peek', 2);
    require Config;
    skip('Devel::Peek was not built', 2)
	unless $Config::Config{extensions} =~ /\bDevel\/Peek\b/;

    my $tempfile = tempfile();
    open $prog, ">", $tempfile or die "Can't create test file";
    print $prog <<'END_EVAL_TEST';
    use Devel::Peek;
    $! = 0;
    $@@ = $!;
    Dump($@@);
    print STDERR "******\n";
    eval { die "\x{a10d}"; };
    $_ = length $@@;
    eval { 1 };
    Dump($@@);
    print STDERR "******\n";
    print STDERR "Done\n";
END_EVAL_TEST
    close $prog or die "Can't close $tempfile: $!";
    my $got = runperl(progfile => $tempfile, stderr => 1);
    my ($first, $second, $tombstone) = split (/\*\*\*\*\*\*\n/, $got);

    is($tombstone, "Done\n", 'Program completed successfully');

    $first =~ s/p?[NI]OK,//g;
    s/ PV = 0x[0-9a-f]+/ PV = 0x/ foreach $first, $second;
    s/ LEN = [0-9]+/ LEN = / foreach $first, $second;
    # Dump may double newlines through pipes, though not files
    # which is what this test used to use.
    $second =~ s/ IV = 0\n\n/ IV = 0\n/ if $^O eq 'VMS';

    is($second, $first, 'eval { 1 } completely resets $@@');
}

# Test that "use feature" and other hint transmission in evals and s///ee
# don't leak memory
{
    use feature qw(:5.10);
    my $count_expected = ($^H & 0x20000) ? 2 : 1;
    my $t;
    my $s = "a";
    $s =~ s/a/$t = \%^H;  qq( qq() );/ee;
    is(Internals::SvREFCNT(%$t), $count_expected, 'RT 63110');
}

# make sure default arg eval only adds a hints hash once to entereval
#
{
    local $_ = "21+12";
    is(eval, 33, 'argless eval without hints');
    use feature qw(:5.10);
    local $_ = "42+24";
    is(eval, 66, 'argless eval with hints');
}

{
    # test that the CV compiled for the eval is freed by checking that no additional 
    # reference to outside lexicals are made.
    my $x;
    is(Internals::SvREFCNT($x), 1, "originally only 1 reference");
    eval '$x';
    is(Internals::SvREFCNT($x), 1, "execution eval doesn't create new references");
}

fresh_perl_is(<<'EOP', "ok\n", undef, 'RT #70862');
$::{'@@'}='';
eval {};
print "ok\n";
EOP

fresh_perl_is(<<'EOP', "ok\n", undef, 'variant of RT #70862');
eval {
    $::{'@@'}='';
};
print "ok\n";
EOP

fresh_perl_is(<<'EOP', "ok\n", undef, 'related to RT #70862');
$::{'@@'}=\3;
eval {};
print "ok\n";
EOP

fresh_perl_is(<<'EOP', "ok\n", undef, 'related to RT #70862');
eval {
    $::{'@@'}=\3;
};
print "ok\n";
EOP

    fresh_perl_is(<<'EOP', "ok\n", undef, 'segfault on syntax errors in block evals');
# localize the hits hash so the eval ends up with the pad offset of a copy of it in its targ
BEGIN { $^H |= 0x00020000 }
eval q{ eval { + } };
print "ok\n";
EOP

fresh_perl_is(<<'EOP', "ok\n", undef, 'assert fail on non-string in Perl_lex_start');
use overload '""'  => sub { '1;' };
my $ov = bless [];
eval $ov;
print "ok\n";
EOP

for my $k (!0) {
  eval 'my $do_something_with = $k';
  eval { $k = 'mon' };
  is "a" =~ /a/, "1",
    "string eval leaves readonly lexicals readonly [perl #19135]";
}

# [perl #68750]
fresh_perl_is(<<'EOP', "ok\nok\nok\n", undef, 'eval clears %^H');
  BEGIN {
    require re; re->import('/x'); # should only affect surrounding scope
    eval '
      print "a b" =~ /a b/ ? "ok\n" : "nokay\n";
      use re "/m";
      print "a b" =~ /a b/ ? "ok\n" : "nokay\n";
   ';
  }
  print "ab" =~ /a b/ ? "ok\n" : "nokay\n";
EOP

# [perl #70151]
{
    BEGIN { eval 'require re; import re "/x"' }
    ok "ab" =~ /a b/, 'eval does not localise %^H at run time';
}

# The fix for perl #70151 caused an assertion failure that broke
# SNMP::Trapinfo, when toke.c finds no syntax errors but perly.y fails.
eval(q|""!=!~//|);
pass("phew! dodged the assertion after a parsing (not lexing) error");

# [perl #111462]
{
   local $ENV{PERL_DESTRUCT_LEVEL} = 1;
   unlike
     runperl(
      prog => 'BEGIN { $^H{foo} = bar }'
             .'our %FIELDS; my main $x; eval q[$x->{foo}]',
      stderr => 1,
     ),
     qr/Unbalanced string table/,
    'Errors in finalize_optree do not leak string eval op tree';
}

# [perl #114658] Line numbers at end of string eval
for("{;", "{") {
    eval $_; is $@@ =~ s/eval \d+/eval 1/rag, <<'EOE',
Missing right curly or square bracket at (eval 1) line 1, at end of line
syntax error at (eval 1) line 1, at EOF
EOE
	qq'Right line number for eval "$_"';
}

{
    my $w;
    local $SIG{__WARN__} = sub { $w .= shift };

    eval "\${\nfoobar\n} = 10; warn q{should be line 3}";
    is(
        $w =~ s/eval \d+/eval 1/ra,
        "should be line 3 at (eval 1) line 3.\n",
        'eval qq{\${\nfoo\n}; warn} updates the line number correctly'
    );
}

sub _117941 { package _117941; eval '$a' }
delete $::{"_117941::"};
_117941();
pass("eval in freed package does not crash");

# eval is supposed normally to clear $@@ on success

{
    $@@ = 1;
    eval q{$@@ = 2};
    ok(!$@@, 'eval clearing $@@');
}

# RT #127786
# this used to give an assertion failure

{
    package DB {
        sub f127786 { eval q/\$s/ }
    }
    my $s;
    sub { $s; DB::f127786}->();
    pass("RT #127786");
}
@


1.12
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@a4 1
    @@INC = '../lib';
d6 1
d9 1
a9 1
plan(tests => 130);
d445 3
a447 3
# resulted in an assertion failure in S_docatch, since doeval had already
# popped the EVAL context due to the failure, but S_docatch expected the
# context to still be there.
d520 10
d648 20
@


1.11
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d9 1
a9 1
plan(tests => 128);
d621 17
@


1.10
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d9 1
a9 1
plan(tests => 126);
d440 1
a440 1
    eval "/ /b;";
d499 1
a499 1
    $first =~ s/,pNOK//;
d611 9
@


1.9
log
@merge in perl 5.12.2 plus local changes
@
text
@d9 1
a9 1
print "1..106\n";
d11 1
a11 1
eval 'print "ok 1\n";';
d13 1
a13 1
if ($@@ eq '') {print "ok 2\n";} else {print "not ok 2\n";}
d16 1
a16 1
print $foo,"\n";
d19 1
a19 1
print $foo;
d23 1
a23 1
if ($@@ =~ /line 2/) {print "ok 5\n";} else {print "not ok 5\n";}
d26 1
a26 1
if ($@@ =~ /Search/) {print "ok 6\n";} else {print "not ok 6\n";}
d28 4
a31 1
print eval '"ok 7\n";';
d33 1
a33 1
# calculate a factorial with recursive evals
d38 1
a38 1
if ($ans == 120) {print "ok 8\n";} else {print "not ok 8\n";}
d43 1
a43 1
if ($ans == 120) {print "ok 9\n";} else {print "not ok 9 $ans\n";}
d45 1
d48 1
a48 1
print try 'print "ok 10\n";',"\n";
d55 1
a55 1
$i = 11;
d60 2
d63 2
a64 2
    print "ok 14\n";
    die "ok 16\n";
d66 3
a68 1
} || print "ok 15\n$@@";
d75 2
a76 2
  print "@@b" eq '4' ? "ok 17\n" : "not ok 17\n";
  print $@@ ? "not ok 18\n" : "ok 18\n";
d81 2
a82 2
  print "@@a" eq 'A' ? "ok 19\n" : "# $b\nnot ok 19\n";
  print   $b eq 'A' ? "ok 20\n" : "# $b\nnot ok 20\n";
d84 1
a84 1
  print   $b eq 'S' ? "ok 21\n" : "# $b\nnot ok 21\n";
d86 1
a86 1
  print   $b eq 'V' ? "ok 22\n" : "# $b\nnot ok 22\n";
d91 1
a91 1
     print eval('"$b"') eq $b ? "ok 23\n" : "not ok 23\n";
d96 8
a103 7
my $b = 'wrong';
my $X = sub {
   my $b = "right";
   print eval('"$b"') eq $b ? "ok 24\n" : "not ok 24\n";
};
&$X();

d107 1
a107 1
my $x = 25;
d114 1
a114 1
do_eval1('print "ok $x\n"');
d116 1
a116 1
do_eval1('eval q[print "ok $x\n"]');
d118 1
a118 1
do_eval1('sub { print "# $x\n"; eval q[print "ok $x\n"] }->()');
d127 1
a127 3
do_eval2('print "ok $x\n"');
$x++;
do_eval2('eval q[print "ok $x\n"]');
d129 1
a129 1
do_eval2('sub { print "# $x\n"; eval q[print "ok $x\n"] }->()');
d131 1
d146 3
a148 3
    do_eval3('print "$ok ' . $x++ . '\n"');
    do_eval3('eval q[print "$ok ' . $x++ . '\n"]');
    do_eval3('sub { eval q[print "$ok ' . $x++ . '\n"] }->()');
a150 12
# can recursive subroutine-call inside eval'' see its own lexicals?
sub recurse {
  my $l = shift;
  if ($l < $x) {
     ++$l;
     eval 'print "# level $l\n"; recurse($l);';
     die if $@@;
  }
  else {
    print "ok $l\n";
  }
}
d152 18
a169 2
  local $SIG{__WARN__} = sub { die "not ok $x\n" if $_[0] =~ /^Deep recurs/ };
  recurse($x-5);
a170 1
$x++;
d172 1
a172 1
# do closures created within eval bind correctly?
d177 1
a177 1
       print $self;
d181 9
a189 2
create_closure("ok $x\n")->();
$x++;
a190 3
# does lexical search terminate correctly at subroutine boundary?
$main::r = "ok $x\n";
sub terminal { eval 'print $r' }
d192 4
a195 2
   my $r = "not ok $x\n";
   eval 'terminal($r)';
a196 6
$x++;

# Have we cured panic which occurred with require/eval in die handler ?
$SIG{__DIE__} = sub { eval {1}; die shift }; 
eval { die "ok ".$x++,"\n" }; 
print $@@;
a197 1
# does scalar eval"" pop stack correctly?
d200 1
a200 2
    print $c eq '2222222222' ? "ok $x\n" : "# $c\nnot ok $x\n";
    $x++;
d210 1
a210 3
    print "not " if $@@;
    print "ok $x\n";
    $x++;
d220 1
a220 3
    print "not " if $@@;
    print "ok $x\n";
    $x++;
d228 2
a229 1
	print ($@@ ? "ok 41\n" : "not ok 41\n");
d232 1
a232 2
	    foo: print "not ok 41\n";
	    print "# jumped into foreach\n";
d235 2
a236 1
    print "not ok 41\n" if $@@;
d242 4
a245 8
  eval q{my $$x};
  print $@@ ? "ok 42\n" : "not ok 42\n";
  eval q{my @@$x};
  print $@@ ? "ok 43\n" : "not ok 43\n";
  eval q{my %$x};
  print $@@ ? "ok 44\n" : "not ok 44\n";
  eval q{my $$$x};
  print $@@ ? "ok 45\n" : "not ok 45\n";
a247 1
# [ID 20020623.002] eval "" doesn't clear $@@
d251 1
a251 1
    print length($@@) ? "not ok 46\t# \$\@@ = '$@@'\n" : "ok 46\n";
d262 1
a262 1
	eval q{ print eval '$zzz' == 1 ? 'ok' : 'not ok', " $_[0]\n"}
d270 1
a270 1
	print eval('$zzz') == 1 ? 'ok' : 'not ok', " $_[0]\n";
d282 1
a282 1
	    { print eval('$zzz') == 2 ? 'ok' : 'not ok', " 51\n"; $a <=> $b }
d303 1
a303 1
    print $r == 120 ? 'ok' : 'not ok', " 52\n";
d305 1
a305 1
    print $r == 120 ? 'ok' : 'not ok', " 53\n";
d308 1
a308 1
    print $r == 120 ? 'ok' : 'not ok', " 54\n";
d311 1
a311 1
    print $r == 120 ? 'ok' : 'not ok', " 55\n";
d314 1
a314 1
print $r == 120 ? 'ok' : 'not ok', " 56\n";
d316 1
a316 1
print $r == 120 ? 'ok' : 'not ok', " 57\n";
d319 1
a319 1
print $r == 120 ? 'ok' : 'not ok', " 58\n";
d322 1
a322 1
print $r == 120 ? 'ok' : 'not ok', " 59\n";
a327 1
my $test = 60;
d330 3
a332 4
    print +($zzz == 3  && eval '$zzz' == 3) ? 'ok' : 'not ok', " $test\n";
    $test++;
    print eval '$yyy' == 2 ? 'ok' : 'not ok', " $test\n";
    $test++;
d339 3
a341 4
	print +($zzz == 4  && eval '$zzz' == 4) ? 'ok' : 'not ok', " $test\n";
	$test++;
	print eval '$yyy' == 2 ? 'ok' : 'not ok', " $test\n";
	$test++;
a349 1
# [perl #9728] used to dump core
d353 1
a353 2
   print "ok $test\n";
   $test++;
a359 1
$test=79;
d374 6
a379 6
    print db1()     == 2 ? 'ok' : 'not ok', " $test\n"; $test++;
    print DB::db2() == 2 ? 'ok' : 'not ok', " $test\n"; $test++;
    print DB::db3() == 3 ? 'ok' : 'not ok', " $test\n"; $test++;
    print DB::db4() == 3 ? 'ok' : 'not ok', " $test\n"; $test++;
    print DB::db5() == 3 ? 'ok' : 'not ok', " $test\n"; $test++;
    print db6()     == 4 ? 'ok' : 'not ok', " $test\n"; $test++;
d381 1
a381 2
require './test.pl';
$NO_ENDING = 1;
d386 1
a386 8

if ($got eq '') {
  print "ok $test\n";
} else {
  print "not ok $test\n";
  _diag ("# Got '$got'\n");
}
$test++;
d394 1
a394 6
    if (defined $k and $k eq 'a') {
      print "ok $test\n";
    } else {
      print "not $test # got ", _q ($k), "\n";
    }
    $test++;
d398 1
a398 6
    if (defined $k and $k eq 'a') {
      print "ok $test\n";
    } else {
      print "not $test # got ", _q ($k), "\n";
    }
    $test++;
d403 1
a403 1
print "ok ",$test++," - #20798 (used to dump core)\n";
d414 1
a414 1
  print "@@r$c" eq 'AA' ? "ok " : "# '@@r$c' ne 'AA'\nnot ok ", $test++, "\n";
d416 1
a416 1
  print "$r$c" eq 'SS' ? "ok " : "# '$r$c' ne 'SS'\nnot ok ", $test++, "\n";
d418 1
a418 1
  print   $c   eq 'V'  ? "ok " : "# '$c' ne 'V'\nnot ok ", $test++, "\n";
d428 1
a428 2
print "not " unless $got eq "ok\n";
print "ok $test - eval and last\n"; $test++;
d435 1
a435 2
    print "not " unless $@@ eq "";
    print "ok $test # eval undef \n"; $test++;
d440 2
a441 3
    eval "/ /a;";
    print "not " unless $@@ =~ /^syntax error/;
    print "ok $test # eval syntax error, no warnings \n"; $test++;
d444 1
a444 2

# a syntax error in an eval called magically 9eg vie tie or overload)
d446 1
a446 1
# poppedthe EVAL context due to the failure, but S_docatch expected the
d458 1
a458 2
    print "not " unless $ok;
    print "ok $test # eval docatch \n"; $test++;
a460 1

d468 2
a469 5
print "not " if ($@@ ne "");
print "ok $test # length of \$@@ after eval\n"; $test++;

print "not " if (length $@@ != 0);
print "ok $test # length of \$@@ after eval\n"; $test++;
d471 10
a480 6
# Check if eval { 1 }; compeltly resets $@@
if (eval "use Devel::Peek; 1;") {
  $tempfile = tempfile();
  $outfile = tempfile();
  open PROG, ">", $tempfile or die "Can't create test file";
  my $prog = <<'END_EVAL_TEST';
d484 21
a504 20
    my $ok = 0;
    open(SAVERR, ">&STDERR") or die "Can't dup STDERR: $!";
    if (open(OUT, '>', '@@@@@@@@')) {
      open(STDERR, ">&OUT") or die "Can't dup OUT: $!";
      Dump($@@);
      print STDERR "******\n";
      eval { die "\x{a10d}"; };
      $_ = length $@@;
      eval { 1 };
      Dump($@@);
      open(STDERR, ">&SAVERR") or die "Can't restore STDERR: $!";
      close(OUT);
      if (open(IN, '<', '@@@@@@@@')) {
        local $/;
        my $in = <IN>;
        my ($first, $second) = split (/\*\*\*\*\*\*\n/, $in, 2);
        $first =~ s/,pNOK//;
        $ok = 1 if ($first eq $second);
      }
    }
d506 1
a506 9
    print $ok;
END_EVAL_TEST
    $prog =~ s/\@@\@@\@@\@@/$outfile/g;
    print PROG $prog;
   close PROG;

   my $ok = runperl(progfile => $tempfile);
   print "not " unless $ok;
   print "ok $test # eval { 1 } completly resets \$@@\n";
a507 4
else {
  print "ok $test # skipped - eval { 1 } completly resets \$@@\n";
}
$test++;
d517 1
a517 3
    print "not " if Internals::SvREFCNT(%$t) != $count_expected;
    print "ok $test - RT 63110\n";
    $test++;
a519 2
curr_test($test);

d524 1
a524 1
    is(Internals::SvREFCNT($x), 1, "originally only 1 referece");
d562 50
@


1.8
log
@Merge in perl 5.10.1; part two
@
text
@d9 1
a9 1
print "1..99\n";
d560 45
@


1.7
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d6 1
d9 1
a9 1
print "1..95\n";
d42 3
a44 2
open(try,'>Op.eval');
print try 'print "ok 10\n"; unlink "Op.eval";',"\n";
d47 1
a47 1
do './Op.eval'; print $@@;
d490 57
d548 12
@


1.6
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d8 1
a8 1
print "1..91\n";
d441 48
@


1.5
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d3 6
a8 1
print "1..46\n";
d126 2
a127 1
$main::x = 'ok';
d134 6
a139 6
do_eval3('print "$x ' . $x . '\n"');
$x++;
do_eval3('eval q[print "$x ' . $x . '\n"]');
$x++;
do_eval3('sub { eval q[print "$x ' . $x . '\n"] }->()');
$x++;
d249 191
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d3 1
a3 1
print "1..40\n";
d40 1
a40 1
do 'Op.eval'; print $@@;
d102 1
a102 1
do_eval1('sub { eval q[print "ok $x\n"] }->()');
d115 1
a115 1
do_eval2('sub { eval q[print "ok $x\n"] }->()');
d208 35
@


1.3
log
@perl5.005_03 (stock)
@
text
@d3 1
a3 1
print "1..36\n";
d174 35
@


1.2
log
@perl 5.004_04
@
text
@d3 1
a3 3
# $RCSfile: eval.t,v $$Revision: 4.1 $$Date: 92/08/07 18:27:48 $

print "1..16\n";
d55 118
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d3 3
a5 1
print "1..36\n";
a56 118
# check whether eval EXPR determines value of EXPR correctly

{
  my @@a = qw(a b c d);
  my @@b = eval @@a;
  print "@@b" eq '4' ? "ok 17\n" : "not ok 17\n";
  print $@@ ? "not ok 18\n" : "ok 18\n";

  my $a = q[defined(wantarray) ? (wantarray ? ($b='A') : ($b='S')) : ($b='V')];
  my $b;
  @@a = eval $a;
  print "@@a" eq 'A' ? "ok 19\n" : "# $b\nnot ok 19\n";
  print   $b eq 'A' ? "ok 20\n" : "# $b\nnot ok 20\n";
  $_ = eval $a;
  print   $b eq 'S' ? "ok 21\n" : "# $b\nnot ok 21\n";
  eval $a;
  print   $b eq 'V' ? "ok 22\n" : "# $b\nnot ok 22\n";

  $b = 'wrong';
  $x = sub {
     my $b = "right";
     print eval('"$b"') eq $b ? "ok 23\n" : "not ok 23\n";
  };
  &$x();
}

my $b = 'wrong';
my $X = sub {
   my $b = "right";
   print eval('"$b"') eq $b ? "ok 24\n" : "not ok 24\n";
};
&$X();


# check navigation of multiple eval boundaries to find lexicals

my $x = 25;
eval <<'EOT'; die if $@@;
  print "# $x\n";	# clone into eval's pad
  sub do_eval1 {
     eval $_[0]; die if $@@;
  }
EOT
do_eval1('print "ok $x\n"');
$x++;
do_eval1('eval q[print "ok $x\n"]');
$x++;
do_eval1('sub { eval q[print "ok $x\n"] }->()');
$x++;

# calls from within eval'' should clone outer lexicals

eval <<'EOT'; die if $@@;
  sub do_eval2 {
     eval $_[0]; die if $@@;
  }
do_eval2('print "ok $x\n"');
$x++;
do_eval2('eval q[print "ok $x\n"]');
$x++;
do_eval2('sub { eval q[print "ok $x\n"] }->()');
$x++;
EOT

# calls outside eval'' should NOT clone lexicals from called context

$main::x = 'ok';
eval <<'EOT'; die if $@@;
  # $x unbound here
  sub do_eval3 {
     eval $_[0]; die if $@@;
  }
EOT
do_eval3('print "$x ' . $x . '\n"');
$x++;
do_eval3('eval q[print "$x ' . $x . '\n"]');
$x++;
do_eval3('sub { eval q[print "$x ' . $x . '\n"] }->()');
$x++;

# can recursive subroutine-call inside eval'' see its own lexicals?
sub recurse {
  my $l = shift;
  if ($l < $x) {
     ++$l;
     eval 'print "# level $l\n"; recurse($l);';
     die if $@@;
  }
  else {
    print "ok $l\n";
  }
}
{
  local $SIG{__WARN__} = sub { die "not ok $x\n" if $_[0] =~ /^Deep recurs/ };
  recurse($x-5);
}
$x++;

# do closures created within eval bind correctly?
eval <<'EOT';
  sub create_closure {
    my $self = shift;
    return sub {
       print $self;
    };
  }
EOT
create_closure("ok $x\n")->();
$x++;

# does lexical search terminate correctly at subroutine boundary?
$main::r = "ok $x\n";
sub terminal { eval 'print $r' }
{
   my $r = "not ok $x\n";
   eval 'terminal($r)';
}
$x++;
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d3 1
a3 1
print "1..40\n";
a173 35
# Have we cured panic which occurred with require/eval in die handler ?
$SIG{__DIE__} = sub { eval {1}; die shift }; 
eval { die "ok ".$x++,"\n" }; 
print $@@;

# does scalar eval"" pop stack correctly?
{
    my $c = eval "(1,2)x10";
    print $c eq '2222222222' ? "ok $x\n" : "# $c\nnot ok $x\n";
    $x++;
}

# return from eval {} should clear $@@ correctly
{
    my $status = eval {
	eval { die };
	print "# eval { return } test\n";
	return; # removing this changes behavior
    };
    print "not " if $@@;
    print "ok $x\n";
    $x++;
}

# ditto for eval ""
{
    my $status = eval q{
	eval q{ die };
	print "# eval q{ return } test\n";
	return; # removing this changes behavior
    };
    print "not " if $@@;
    print "ok $x\n";
    $x++;
}
@


1.1.1.4
log
@stock perl 5.8.0 from CPAN
@
text
@d3 1
a3 1
print "1..46\n";
d40 1
a40 1
do './Op.eval'; print $@@;
d102 1
a102 1
do_eval1('sub { print "# $x\n"; eval q[print "ok $x\n"] }->()');
d115 1
a115 1
do_eval2('sub { print "# $x\n"; eval q[print "ok $x\n"] }->()');
a207 35
}

# Check that eval catches bad goto calls
#   (BUG ID 20010305.003)
{
    eval {
	eval { goto foo; };
	print ($@@ ? "ok 41\n" : "not ok 41\n");
	last;
	foreach my $i (1) {
	    foo: print "not ok 41\n";
	    print "# jumped into foreach\n";
	}
    };
    print "not ok 41\n" if $@@;
}

# Make sure that "my $$x" is forbidden
# 20011224 MJD
{
  eval q{my $$x};
  print $@@ ? "ok 42\n" : "not ok 42\n";
  eval q{my @@$x};
  print $@@ ? "ok 43\n" : "not ok 43\n";
  eval q{my %$x};
  print $@@ ? "ok 44\n" : "not ok 44\n";
  eval q{my $$$x};
  print $@@ ? "ok 45\n" : "not ok 45\n";
}

# [ID 20020623.002] eval "" doesn't clear $@@
{
    $@@ = 5;
    eval q{};
    print length($@@) ? "not ok 46\t# \$\@@ = '$@@'\n" : "ok 46\n";
@


1.1.1.5
log
@perl 5.8.2 from CPAN
@
text
@d3 1
a3 6
BEGIN {
    chdir 't' if -d 't';
    @@INC = '../lib';
}

print "1..91\n";
d121 1
a121 2
$main::ok = 'not ok';
my $ok = 'ok';
d128 6
a133 6
{
    my $ok = 'not ok';
    do_eval3('print "$ok ' . $x++ . '\n"');
    do_eval3('eval q[print "$ok ' . $x++ . '\n"]');
    do_eval3('sub { eval q[print "$ok ' . $x++ . '\n"] }->()');
}
a242 191
}

# DAPM Nov-2002. Perl should now capture the full lexical context during
# evals.

$::zzz = $::zzz = 0;
my $zzz = 1;

eval q{
    sub fred1 {
	eval q{ print eval '$zzz' == 1 ? 'ok' : 'not ok', " $_[0]\n"}
    }
    fred1(47);
    { my $zzz = 2; fred1(48) }
};

eval q{
    sub fred2 {
	print eval('$zzz') == 1 ? 'ok' : 'not ok', " $_[0]\n";
    }
};
fred2(49);
{ my $zzz = 2; fred2(50) }

# sort() starts a new context stack. Make sure we can still find
# the lexically enclosing sub

sub do_sort {
    my $zzz = 2;
    my @@a = sort
	    { print eval('$zzz') == 2 ? 'ok' : 'not ok', " 51\n"; $a <=> $b }
	    2, 1;
}
do_sort();

# more recursion and lexical scope leak tests

eval q{
    my $r = -1;
    my $yyy = 9;
    sub fred3 {
	my $l = shift;
	my $r = -2;
	return 1 if $l < 1;
	return 0 if eval '$zzz' != 1;
	return 0 if       $yyy  != 9;
	return 0 if eval '$yyy' != 9;
	return 0 if eval '$l' != $l;
	return $l * fred3($l-1);
    }
    my $r = fred3(5);
    print $r == 120 ? 'ok' : 'not ok', " 52\n";
    $r = eval'fred3(5)';
    print $r == 120 ? 'ok' : 'not ok', " 53\n";
    $r = 0;
    eval '$r = fred3(5)';
    print $r == 120 ? 'ok' : 'not ok', " 54\n";
    $r = 0;
    { my $yyy = 4; my $zzz = 5; my $l = 6; $r = eval 'fred3(5)' };
    print $r == 120 ? 'ok' : 'not ok', " 55\n";
};
my $r = fred3(5);
print $r == 120 ? 'ok' : 'not ok', " 56\n";
$r = eval'fred3(5)';
print $r == 120 ? 'ok' : 'not ok', " 57\n";
$r = 0;
eval'$r = fred3(5)';
print $r == 120 ? 'ok' : 'not ok', " 58\n";
$r = 0;
{ my $yyy = 4; my $zzz = 5; my $l = 6; $r = eval 'fred3(5)' };
print $r == 120 ? 'ok' : 'not ok', " 59\n";

# check that goto &sub within evals doesn't leak lexical scope

my $yyy = 2;

my $test = 60;
sub fred4 { 
    my $zzz = 3;
    print +($zzz == 3  && eval '$zzz' == 3) ? 'ok' : 'not ok', " $test\n";
    $test++;
    print eval '$yyy' == 2 ? 'ok' : 'not ok', " $test\n";
    $test++;
}

eval q{
    fred4();
    sub fred5 {
	my $zzz = 4;
	print +($zzz == 4  && eval '$zzz' == 4) ? 'ok' : 'not ok', " $test\n";
	$test++;
	print eval '$yyy' == 2 ? 'ok' : 'not ok', " $test\n";
	$test++;
	goto &fred4;
    }
    fred5();
};
fred5();
{ my $yyy = 88; my $zzz = 99; fred5(); }
eval q{ my $yyy = 888; my $zzz = 999; fred5(); };

# [perl #9728] used to dump core
{
   $eval = eval 'sub { eval "sub { %S }" }';
   $eval->({});
   print "ok $test\n";
   $test++;
}

# evals that appear in the DB package should see the lexical scope of the
# thing outside DB that called them (usually the debugged code), rather
# than the usual surrounding scope

$test=79;
our $x = 1;
{
    my $x=2;
    sub db1	{ $x; eval '$x' }
    sub DB::db2	{ $x; eval '$x' }
    package DB;
    sub db3	{ eval '$x' }
    sub DB::db4	{ eval '$x' }
    sub db5	{ my $x=4; eval '$x' }
    package main;
    sub db6	{ my $x=4; eval '$x' }
}
{
    my $x = 3;
    print db1()     == 2 ? 'ok' : 'not ok', " $test\n"; $test++;
    print DB::db2() == 2 ? 'ok' : 'not ok', " $test\n"; $test++;
    print DB::db3() == 3 ? 'ok' : 'not ok', " $test\n"; $test++;
    print DB::db4() == 3 ? 'ok' : 'not ok', " $test\n"; $test++;
    print DB::db5() == 3 ? 'ok' : 'not ok', " $test\n"; $test++;
    print db6()     == 4 ? 'ok' : 'not ok', " $test\n"; $test++;
}
require './test.pl';
$NO_ENDING = 1;
# [perl #19022] used to end up with shared hash warnings
# The program should generate no output, so anything we see is on stderr
my $got = runperl (prog => '$h{a}=1; foreach my $k (keys %h) {eval qq{\$k}}',
		   stderr => 1);

if ($got eq '') {
  print "ok $test\n";
} else {
  print "not ok $test\n";
  _diag ("# Got '$got'\n");
}
$test++;

# And a buggy way of fixing #19022 made this fail - $k became undef after the
# eval for a build with copy on write
{
  my %h;
  $h{a}=1;
  foreach my $k (keys %h) {
    if (defined $k and $k eq 'a') {
      print "ok $test\n";
    } else {
      print "not $test # got ", _q ($k), "\n";
    }
    $test++;

    eval "\$k";

    if (defined $k and $k eq 'a') {
      print "ok $test\n";
    } else {
      print "not $test # got ", _q ($k), "\n";
    }
    $test++;
  }
}

sub Foo {} print Foo(eval {});
print "ok ",$test++," - #20798 (used to dump core)\n";

# check for context in string eval
{
  my(@@r,$r,$c);
  sub context { defined(wantarray) ? (wantarray ? ($c='A') : ($c='S')) : ($c='V') }

  my $code = q{ context() };
  @@r = qw( a b );
  $r = 'ab';
  @@r = eval $code;
  print "@@r$c" eq 'AA' ? "ok " : "# '@@r$c' ne 'AA'\nnot ok ", $test++, "\n";
  $r = eval $code;
  print "$r$c" eq 'SS' ? "ok " : "# '$r$c' ne 'SS'\nnot ok ", $test++, "\n";
  eval $code;
  print   $c   eq 'V'  ? "ok " : "# '$c' ne 'V'\nnot ok ", $test++, "\n";
@


1.1.1.6
log
@import perl 5.10.0 from CPAN
@
text
@d8 1
a8 1
print "1..95\n";
a440 48

# [perl #34682] escaping an eval with last could coredump or dup output

$got = runperl (
    prog => 
    'sub A::TIEARRAY { L: { eval { last L } } } tie @@a, A; warn qq(ok\n)',
stderr => 1);

print "not " unless $got eq "ok\n";
print "ok $test - eval and last\n"; $test++;

# eval undef should be the same as eval "" barring any warnings

{
    local $@@ = "foo";
    eval undef;
    print "not " unless $@@ eq "";
    print "ok $test # eval undef \n"; $test++;
}

{
    no warnings;
    eval "/ /a;";
    print "not " unless $@@ =~ /^syntax error/;
    print "ok $test # eval syntax error, no warnings \n"; $test++;
}


# a syntax error in an eval called magically 9eg vie tie or overload)
# resulted in an assertion failure in S_docatch, since doeval had already
# poppedthe EVAL context due to the failure, but S_docatch expected the
# context to still be there.

{
    my $ok  = 0;
    package Eval1;
    sub STORE { eval '('; $ok = 1 }
    sub TIESCALAR { bless [] }

    my $x;
    tie $x, bless [];
    $x = 1;
    print "not " unless $ok;
    print "ok $test # eval docatch \n"; $test++;
}



@


1.1.1.7
log
@import perl 5.10.1
@
text
@a5 1
    require './test.pl';
d8 1
a8 1
print "1..99\n";
d41 2
a42 3
my $tempfile = tempfile();
open(try,'>',$tempfile);
print try 'print "ok 10\n";',"\n";
d45 1
a45 1
do "./$tempfile"; print $@@;
a487 57
# [perl #51370] eval { die "\x{a10d}" } followed by eval { 1 } did not reset
# length $@@ 
$@@ = "";
eval { die "\x{a10d}"; };
$_ = length $@@;
eval { 1 };

print "not " if ($@@ ne "");
print "ok $test # length of \$@@ after eval\n"; $test++;

print "not " if (length $@@ != 0);
print "ok $test # length of \$@@ after eval\n"; $test++;

# Check if eval { 1 }; compeltly resets $@@
if (eval "use Devel::Peek; 1;") {
  $tempfile = tempfile();
  $outfile = tempfile();
  open PROG, ">", $tempfile or die "Can't create test file";
  my $prog = <<'END_EVAL_TEST';
    use Devel::Peek;
    $! = 0;
    $@@ = $!;
    my $ok = 0;
    open(SAVERR, ">&STDERR") or die "Can't dup STDERR: $!";
    if (open(OUT, '>', '@@@@@@@@')) {
      open(STDERR, ">&OUT") or die "Can't dup OUT: $!";
      Dump($@@);
      print STDERR "******\n";
      eval { die "\x{a10d}"; };
      $_ = length $@@;
      eval { 1 };
      Dump($@@);
      open(STDERR, ">&SAVERR") or die "Can't restore STDERR: $!";
      close(OUT);
      if (open(IN, '<', '@@@@@@@@')) {
        local $/;
        my $in = <IN>;
        my ($first, $second) = split (/\*\*\*\*\*\*\n/, $in, 2);
        $first =~ s/,pNOK//;
        $ok = 1 if ($first eq $second);
      }
    }

    print $ok;
END_EVAL_TEST
    $prog =~ s/\@@\@@\@@\@@/$outfile/g;
    print PROG $prog;
   close PROG;

   my $ok = runperl(progfile => $tempfile);
   print "not " unless $ok;
   print "ok $test # eval { 1 } completly resets \$@@\n";
}
else {
  print "ok $test # skipped - eval { 1 } completly resets \$@@\n";
}
$test++;
a488 12
# Test that "use feature" and other hint transmission in evals and s///ee
# don't leak memory
{
    use feature qw(:5.10);
    my $count_expected = ($^H & 0x20000) ? 2 : 1;
    my $t;
    my $s = "a";
    $s =~ s/a/$t = \%^H;  qq( qq() );/ee;
    print "not " if Internals::SvREFCNT(%$t) != $count_expected;
    print "ok $test - RT 63110\n";
    $test++;
}
@


1.1.1.8
log
@Perl 5.12.2 from CPAN
@
text
@d9 1
a9 1
print "1..106\n";
a559 45

curr_test($test);

{
    # test that the CV compiled for the eval is freed by checking that no additional 
    # reference to outside lexicals are made.
    my $x;
    is(Internals::SvREFCNT($x), 1, "originally only 1 referece");
    eval '$x';
    is(Internals::SvREFCNT($x), 1, "execution eval doesn't create new references");
}

fresh_perl_is(<<'EOP', "ok\n", undef, 'RT #70862');
$::{'@@'}='';
eval {};
print "ok\n";
EOP

fresh_perl_is(<<'EOP', "ok\n", undef, 'variant of RT #70862');
eval {
    $::{'@@'}='';
};
print "ok\n";
EOP

fresh_perl_is(<<'EOP', "ok\n", undef, 'related to RT #70862');
$::{'@@'}=\3;
eval {};
print "ok\n";
EOP

fresh_perl_is(<<'EOP', "ok\n", undef, 'related to RT #70862');
eval {
    $::{'@@'}=\3;
};
print "ok\n";
EOP

    fresh_perl_is(<<'EOP', "ok\n", undef, 'segfault on syntax errors in block evals');
# localize the hits hash so the eval ends up with the pad offset of a copy of it in its targ
BEGIN { $^H |= 0x00020000 }
eval q{ eval { + } };
print "ok\n";
EOP

@


1.1.1.9
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d9 1
a9 1
plan(tests => 126);
d11 1
a11 1
eval 'pass();';
d13 1
a13 1
is($@@, '');
d16 1
a16 1
is($foo, 'ok 3');
d19 1
a19 1
is($foo, "ok 4\n");
d23 1
a23 1
like($@@, qr/line 2/);
d26 1
a26 1
like($@@, qr/Search/);
d28 1
a28 4
is scalar(eval '++'), undef, 'eval syntax error in scalar context';
is scalar(eval 'die'), undef, 'eval run-time error in scalar context';
is +()=eval '++', 0, 'eval syntax error in list context';
is +()=eval 'die', 0, 'eval run-time error in list context';
d30 1
a30 1
is(eval '"ok 7\n";', "ok 7\n");
d35 1
a35 1
is($ans, 120, 'calculate a factorial with recursive evals');
d40 1
a40 1
is($ans, 120, 'calculate a factorial with recursive evals');
a41 1
my $curr_test = curr_test();
d44 1
a44 1
print try 'print "ok $curr_test\n";',"\n";
d51 1
a51 1
$i = $curr_test + 1;
a55 2
$curr_test += 4;

d57 2
a58 2
    print "ok $curr_test\n";
    die sprintf "ok %d\n", $curr_test + 2;
d60 1
a60 3
} || printf "ok %d\n$@@", $curr_test + 1;

curr_test($curr_test + 3);
d67 2
a68 2
  is("@@b", '4');
  is($@@, '');
d73 2
a74 2
  is("@@a", 'A');
  is(  $b, 'A');
d76 1
a76 1
  is(  $b, 'S');
d78 1
a78 1
  is(  $b, 'V');
d83 1
a83 1
     is(eval('"$b"'), $b);
d88 7
a94 8
{
  my $b = 'wrong';
  my $X = sub {
     my $b = "right";
     is(eval('"$b"'), $b);
  };
  &$X();
}
d98 1
a98 1
my $x = 'aa';
d105 1
a105 1
do_eval1('is($x, "aa")');
d107 1
a107 1
do_eval1('eval q[is($x, "ab")]');
d109 1
a109 1
do_eval1('sub { print "# $x\n"; eval q[is($x, "ac")] }->()');
d118 3
a120 1
do_eval2('is($x, "ad")');
d122 1
a122 1
do_eval2('eval q[is($x, "ae")]');
a123 1
do_eval2('sub { print "# $x\n"; eval q[is($x, "af")] }->()');
d138 3
a140 3
    do_eval3('is($ok, q{ok})');
    do_eval3('eval q[is($ok, q{ok})]');
    do_eval3('sub { eval q[is($ok, q{ok})] }->()');
d143 12
d156 2
a157 18
    my $x = curr_test();
    my $got;
    sub recurse {
	my $l = shift;
	if ($l < $x) {
	    ++$l;
	    eval 'print "# level $l\n"; recurse($l);';
	    die if $@@;
	}
	else {
	    $got = "ok $l";
	}
    }
    local $SIG{__WARN__} = sub { fail() if $_[0] =~ /^Deep recurs/ };
    recurse(curr_test() - 5);

    is($got, "ok $x",
       "recursive subroutine-call inside eval'' see its own lexicals");
d159 1
d161 1
a161 1

d166 1
a166 1
       return $self;
d170 2
a171 2
is(create_closure("good")->(), "good",
   'closures created within eval bind correctly');
d173 5
a177 4
$main::r = "good";
sub terminal { eval '$r . q{!}' }
is(do {
   my $r = "bad";
d179 2
a180 1
}, 'good!', 'lexical search terminates correctly at subroutine boundary');
d182 4
a185 6
{
    # Have we cured panic which occurred with require/eval in die handler ?
    local $SIG{__DIE__} = sub { eval {1}; die shift };
    eval { die "wham_eth\n" };
    is($@@, "wham_eth\n");
}
d187 1
d190 2
a191 1
    is($c, '2222222222', 'scalar eval"" pops stack correctly');
d201 3
a203 1
    is($@@, '', 'return from eval {} should clear $@@ correctly');
d213 3
a215 1
    is($@@, '', 'return from eval "" should clear $@@ correctly');
d223 1
a223 2
	like($@@, qr/Can't "goto" into the middle of a foreach loop/,
	     'eval catches bad goto calls');
d226 2
a227 1
	    foo: fail('jumped into foreach');
d230 1
a230 2
    fail("Outer eval didn't execute the last");
    diag($@@);
d236 8
a243 4
    foreach (qw($$x @@$x %$x $$$x)) {
	eval 'my ' . $_;
	isnt($@@, '', "my $_ is forbidden");
    }
d246 1
d250 1
a250 1
    cmp_ok(length $@@, '==', 0, '[ID 20020623.002] eval "" doesn\'t clear $@@');
d261 1
a261 1
	eval q{ is(eval '$zzz', 1); }
d269 1
a269 1
	is(eval('$zzz'), 1);
d281 1
a281 1
	    { is(eval('$zzz'), 2); $a <=> $b }
d302 1
a302 1
    is($r, 120);
d304 1
a304 1
    is($r, 120);
d307 1
a307 1
    is($r, 120);
d310 1
a310 1
    is($r, 120);
d313 1
a313 1
is($r, 120);
d315 1
a315 1
is($r, 120);
d318 1
a318 1
is($r, 120);
d321 1
a321 1
is($r, 120);
d327 1
d330 4
a333 3
    is($zzz, 3);
    is(eval '$zzz', 3);
    is(eval '$yyy', 2);
d340 4
a343 3
	is($zzz, 4);
	is(eval '$zzz', 4);
	is(eval '$yyy', 2);
d352 1
d356 2
a357 1
   pass('[perl #9728] used to dump core');
d364 1
d379 6
a384 6
    is(db1(),      2);
    is(DB::db2(),  2);
    is(DB::db3(),  3);
    is(DB::db4(),  3);
    is(DB::db5(),  3);
    is(db6(),      4);
d386 2
a387 1

d392 8
a399 1
is ($got, '');
d407 6
a412 1
    is($k, 'a');
d416 6
a421 1
    is($k, 'a');
d426 1
a426 1
pass('#20798 (used to dump core)');
d437 1
a437 1
  is("@@r$c", 'AA', 'string eval list context');
d439 1
a439 1
  is("$r$c", 'SS', 'string eval scalar context');
d441 1
a441 1
  is("$c", 'V', 'string eval void context');
d451 2
a452 1
is($got, "ok\n", 'eval and last');
d459 2
a460 1
    is($@@, "", 'eval undef');
d465 3
a467 2
    eval "/ /b;";
    like($@@, qr/^syntax error/, 'eval syntax error, no warnings');
d470 2
a471 1
# a syntax error in an eval called magically (eg via tie or overload)
d473 1
a473 1
# popped the EVAL context due to the failure, but S_docatch expected the
d485 2
a486 1
    ::is($ok, 1, 'eval docatch');
d489 1
d497 5
a501 2
cmp_ok($@@, 'eq', "", 'length of $@@ after eval');
cmp_ok(length $@@, '==', 0, 'length of $@@ after eval');
d503 6
a508 10
# Check if eval { 1 }; completely resets $@@
SKIP: {
    skip_if_miniperl('no dynamic loading on miniperl, no Devel::Peek', 2);
    require Config;
    skip('Devel::Peek was not built', 2)
	unless $Config::Config{extensions} =~ /\bDevel\/Peek\b/;

    my $tempfile = tempfile();
    open $prog, ">", $tempfile or die "Can't create test file";
    print $prog <<'END_EVAL_TEST';
d512 22
a533 8
    Dump($@@);
    print STDERR "******\n";
    eval { die "\x{a10d}"; };
    $_ = length $@@;
    eval { 1 };
    Dump($@@);
    print STDERR "******\n";
    print STDERR "Done\n";
d535 10
a544 14
    close $prog or die "Can't close $tempfile: $!";
    my $got = runperl(progfile => $tempfile, stderr => 1);
    my ($first, $second, $tombstone) = split (/\*\*\*\*\*\*\n/, $got);

    is($tombstone, "Done\n", 'Program completed successfully');

    $first =~ s/,pNOK//;
    s/ PV = 0x[0-9a-f]+/ PV = 0x/ foreach $first, $second;
    s/ LEN = [0-9]+/ LEN = / foreach $first, $second;
    # Dump may double newlines through pipes, though not files
    # which is what this test used to use.
    $second =~ s/ IV = 0\n\n/ IV = 0\n/ if $^O eq 'VMS';

    is($second, $first, 'eval { 1 } completely resets $@@');
d546 1
d556 3
a558 1
    is(Internals::SvREFCNT(%$t), $count_expected, 'RT 63110');
d561 2
d567 1
a567 1
    is(Internals::SvREFCNT($x), 1, "originally only 1 reference");
a604 50
fresh_perl_is(<<'EOP', "ok\n", undef, 'assert fail on non-string in Perl_lex_start');
use overload '""'  => sub { '1;' };
my $ov = bless [];
eval $ov;
print "ok\n";
EOP

for my $k (!0) {
  eval 'my $do_something_with = $k';
  eval { $k = 'mon' };
  is "a" =~ /a/, "1",
    "string eval leaves readonly lexicals readonly [perl #19135]";
}

# [perl #68750]
fresh_perl_is(<<'EOP', "ok\nok\nok\n", undef, 'eval clears %^H');
  BEGIN {
    require re; re->import('/x'); # should only affect surrounding scope
    eval '
      print "a b" =~ /a b/ ? "ok\n" : "nokay\n";
      use re "/m";
      print "a b" =~ /a b/ ? "ok\n" : "nokay\n";
   ';
  }
  print "ab" =~ /a b/ ? "ok\n" : "nokay\n";
EOP

# [perl #70151]
{
    BEGIN { eval 'require re; import re "/x"' }
    ok "ab" =~ /a b/, 'eval does not localise %^H at run time';
}

# The fix for perl #70151 caused an assertion failure that broke
# SNMP::Trapinfo, when toke.c finds no syntax errors but perly.y fails.
eval(q|""!=!~//|);
pass("phew! dodged the assertion after a parsing (not lexing) error");

# [perl #111462]
{
   local $ENV{PERL_DESTRUCT_LEVEL} = 1;
   unlike
     runperl(
      prog => 'BEGIN { $^H{foo} = bar }'
             .'our %FIELDS; my main $x; eval q[$x->{foo}]',
      stderr => 1,
     ),
     qr/Unbalanced string table/,
    'Errors in finalize_optree do not leak string eval op tree';
}
@


1.1.1.10
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d9 1
a9 1
plan(tests => 128);
d440 1
a440 1
    eval "&& $b;";
d499 1
a499 1
    $first =~ s/p?[NI]OK,//g;
a610 9
}

# [perl #114658] Line numbers at end of string eval
for("{;", "{") {
    eval $_; is $@@ =~ s/eval \d+/eval 1/rag, <<'EOE',
Missing right curly or square bracket at (eval 1) line 1, at end of line
syntax error at (eval 1) line 1, at EOF
EOE
	qq'Right line number for eval "$_"';
@


1.1.1.11
log
@Import perl-5.20.1
@
text
@d9 1
a9 1
plan(tests => 130);
a620 17

{
    my $w;
    local $SIG{__WARN__} = sub { $w .= shift };

    eval "\${\nfoobar\n} = 10; warn q{should be line 3}";
    is(
        $w =~ s/eval \d+/eval 1/ra,
        "should be line 3 at (eval 1) line 3.\n",
        'eval qq{\${\nfoo\n}; warn} updates the line number correctly'
    );
}

sub _117941 { package _117941; eval '$a' }
delete $::{"_117941::"};
_117941();
pass("eval in freed package does not crash");
@


1.1.1.12
log
@Import perl-5.24.2
@
text
@d5 1
a6 1
    set_up_inc('../lib');
d9 1
a9 1
plan(tests => 134);
d445 3
a447 3
# resulted in an assertion failure in S_docatch, since doeval_compile had
# already popped the EVAL context due to the failure, but S_docatch
# expected the context to still be there.
a519 10
# make sure default arg eval only adds a hints hash once to entereval
#
{
    local $_ = "21+12";
    is(eval, 33, 'argless eval without hints');
    use feature qw(:5.10);
    local $_ = "42+24";
    is(eval, 66, 'argless eval with hints');
}

a637 20

# eval is supposed normally to clear $@@ on success

{
    $@@ = 1;
    eval q{$@@ = 2};
    ok(!$@@, 'eval clearing $@@');
}

# RT #127786
# this used to give an assertion failure

{
    package DB {
        sub f127786 { eval q/\$s/ }
    }
    my $s;
    sub { $s; DB::f127786}->();
    pass("RT #127786");
}
@


