head	1.11;
access;
symbols
	OPENBSD_6_0:1.10.0.10
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.4
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.10.0.6
	OPENBSD_5_8_BASE:1.10
	PERL_5_20_2:1.1.1.9
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	PERL_5_20_1:1.1.1.9
	OPENBSD_5_6:1.9.0.8
	OPENBSD_5_6_BASE:1.9
	PERL_5_18_2:1.1.1.8
	PERL:1.1.1
	OPENBSD_5_5:1.9.0.6
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.2
	OPENBSD_5_4_BASE:1.9
	PERL_5_16_3:1.1.1.8
	OPENBSD_5_3:1.8.0.10
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.8
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.6
	OPENBSD_5_0:1.8.0.4
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.2
	OPENBSD_4_9_BASE:1.8
	PERL_5_12_2:1.1.1.7
	OPENBSD_4_8:1.7.0.4
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.2
	OPENBSD_4_7_BASE:1.7
	PERL_5_10_1:1.1.1.6
	OPENBSD_4_6:1.6.0.26
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.22
	OPENBSD_4_5_BASE:1.6
	PERL_5_10_0:1.1.1.5
	OPENBSD_4_4:1.6.0.20
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.18
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.16
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.14
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.12
	OPENBSD_4_0_BASE:1.6
	PERL_5_8_8:1.1.1.5
	OPENBSD_3_9:1.6.0.10
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.8
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.6
	OPENBSD_3_7_BASE:1.6
	PERL_5_8_6:1.1.1.5
	OPENBSD_3_6:1.6.0.4
	OPENBSD_3_6_BASE:1.6
	PERL_5_8_5:1.1.1.5
	PERL_5_8_3:1.1.1.5
	OPENBSD_3_5:1.6.0.2
	OPENBSD_3_5_BASE:1.6
	PERL_5_8_2:1.1.1.5
	OPENBSD_3_4:1.5.0.10
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.8
	OPENBSD_3_3_BASE:1.5
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.11
date	2017.02.05.00.32.20;	author afresh1;	state Exp;
branches;
next	1.10;
commitid	cxJ08BvJA9Pt2PTM;

1.10
date	2014.11.17.20.57.07;	author afresh1;	state Exp;
branches;
next	1.9;
commitid	QP75iYx42Uo7mMxO;

1.9
date	2013.03.25.20.41.00;	author sthen;	state Exp;
branches;
next	1.8;

1.8
date	2010.09.24.15.07.09;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2009.10.12.18.30.28;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2003.12.03.03.02.49;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.36.23;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.08.34;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.52.39;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.08.05.48;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.13.23;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.13.23;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.41.53;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.10.52;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.25.49;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.12.03.02.44.33;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2009.10.12.18.10.44;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2010.09.24.14.49.17;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2013.03.25.20.09.37;	author sthen;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2014.11.17.20.53.18;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.11
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl

BEGIN {
    chdir 't' if -d 't';
    @@INC = '../lib';
    require './test.pl';
}

use strict;

use vars qw(@@ary %ary %hash);

plan 74;

ok !defined($a);

$a = 1+1;
ok defined($a);

undef $a;
ok !defined($a);

$a = "hi";
ok defined($a);

$a = $b;
ok !defined($a);

@@ary = ("1arg");
$a = pop(@@ary);
ok defined($a);
$a = pop(@@ary);
ok !defined($a);

@@ary = ("1arg");
$a = shift(@@ary);
ok defined($a);
$a = shift(@@ary);
ok !defined($a);

$ary{'foo'} = 'hi';
ok defined($ary{'foo'});
ok !defined($ary{'bar'});
undef $ary{'foo'};
ok !defined($ary{'foo'});

sub foo { pass; 1 }

&foo || fail;

ok defined &foo;
undef &foo;
ok !defined(&foo);

eval { undef $1 };
like $@@, qr/^Modification of a read/;

eval { $1 = undef };
like $@@, qr/^Modification of a read/;

{
    # [perl #17753] segfault when undef'ing unquoted string constant
    eval 'undef tcp';
    like $@@, qr/^Can't modify constant item/;
}

# bugid 3096
# undefing a hash may free objects with destructors that then try to
# modify the hash. Ensure that the hash remains consistent

{
    my (%hash, %mirror);

    my $iters = 5;

    for (1..$iters) {
	$hash{"k$_"} = bless ["k$_"], 'X';
	$mirror{"k$_"} = "k$_";
    }


    my $c = $iters;
    my $events;

    sub X::DESTROY {
	my $key = $_[0][0];
	$events .= 'D';
	note("----- DELETE($key) ------");
	delete $mirror{$key};

	is join('-', sort keys %hash), join('-', sort keys %mirror),
	    "$key: keys";
	is join('-', sort map $_->[0], values %hash),
	    join('-', sort values %mirror), "$key: values";

	# don't know exactly what we'll get from the iterator, but
	# it must be a sensible value
	my ($k, $v) = each %hash;
	ok defined $k ? exists($mirror{$k}) : (keys(%mirror) == 0),
	    "$key: each 1";

	is delete $hash{$key}, undef, "$key: delete";
	($k, $v) = each %hash;
	ok defined $k ? exists($mirror{$k}) : (keys(%mirror) <= 1),
	    "$key: each 2";

	$c++;
	if ($c <= $iters * 2) {
	    $hash{"k$c"} = bless ["k$c"], 'X';
	    $mirror{"k$c"} = "k$c";
	}
	$events .= 'E';
    }

    each %hash; # set eiter
    undef %hash;

    is scalar keys %hash, 0, "hash empty at end";
    is $events, ('DE' x ($iters*2)), "events";
    my ($k, $v) = each %hash;
    is $k, undef, 'each undef at end';
}

# part of #105906: inlined undef constant getting copied
BEGIN { $::{z} = \undef }
for (z,z) {
    push @@_, \$_;
}
is $_[0], $_[1], 'undef constants preserve identity';

# [perl #122556]
my $messages;
package Thingie;
DESTROY { $messages .= 'destroyed ' }
package main;
sub body {
    sub {
        my $t = bless [], 'Thingie';
        undef $t;
    }->(), $messages .= 'after ';

    return;
}
body();
is $messages, 'destroyed after ', 'undef $scalar frees refs immediately';


# this will segfault if it fails

sub PVBM () { 'foo' }
{ my $dummy = index 'foo', PVBM }

my $pvbm = PVBM;
undef $pvbm;
ok !defined $pvbm;
@


1.10
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d13 1
a13 1
plan 86;
a46 29
{
    no warnings 'deprecated';
    ok defined(@@ary);
    ok defined(%ary);
}
ok %ary;
undef @@ary;
{
    no warnings 'deprecated';
    ok !defined(@@ary);
}
undef %ary;
{
    no warnings 'deprecated';
    ok !defined(%ary);
}
ok !%ary;
@@ary = (1);
{
    no warnings 'deprecated';
    ok defined @@ary;
}
%ary = (1,1);
{
    no warnings 'deprecated';
    ok defined %ary;
}
ok %ary;

a61 18
    require Tie::Hash;
    tie my %foo, 'Tie::StdHash';
    no warnings 'deprecated';
    ok defined %foo;
    %foo = ( a => 1 );
    ok defined %foo;
}

{
    require Tie::Array;
    tie my @@foo, 'Tie::StdArray';
    no warnings 'deprecated';
    ok defined @@foo;
    @@foo = ( a => 1 );
    ok defined @@foo;
}

{
d130 17
@


1.9
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d13 1
a13 1
plan 85;
d170 7
@


1.8
log
@merge in perl 5.12.2 plus local changes
@
text
@d13 1
a13 1
plan 40;
a46 1
ok defined(@@ary);
d49 1
d54 4
a57 1
ok !defined(@@ary);
d65 4
a68 1
ok defined @@ary;
d116 6
a121 1
# modify the hash. To them, the hash should appear empty.
d123 46
a168 11
%hash = (
    key1 => bless({}, 'X'),
    key2 => bless({}, 'X'),
);
undef %hash;
sub X::DESTROY {
    is scalar keys %hash, 0;
    is scalar values %hash, 0;
    my @@l = each %hash;
    is @@l, 0;
    is delete $hash{'key2'}, undef;
@


1.7
log
@Merge in perl 5.10.1; part two
@
text
@d13 1
a13 1
plan 37;
d48 5
a52 1
ok defined(%ary);
d56 5
a60 1
ok !defined(%ary);
d64 5
a68 1
ok defined %ary;
d87 1
d96 1
@


1.6
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d6 1
d9 1
a9 1
print "1..36\n";
d11 5
a15 1
print defined($a) ? "not ok 1\n" : "ok 1\n";
d18 1
a18 1
print defined($a) ? "ok 2\n" : "not ok 2\n";
d21 1
a21 1
print defined($a) ? "not ok 3\n" : "ok 3\n";
d24 1
a24 1
print defined($a) ? "ok 4\n" : "not ok 4\n";
d27 1
a27 1
print defined($a) ? "not ok 5\n" : "ok 5\n";
d31 1
a31 1
print defined($a) ? "ok 6\n" : "not ok 6\n";
d33 1
a33 1
print defined($a) ? "not ok 7\n" : "ok 7\n";
d37 1
a37 1
print defined($a) ? "ok 8\n" : "not ok 8\n";
d39 1
a39 1
print defined($a) ? "not ok 9\n" : "ok 9\n";
d42 2
a43 2
print defined($ary{'foo'}) ? "ok 10\n" : "not ok 10\n";
print defined($ary{'bar'}) ? "not ok 11\n" : "ok 11\n";
d45 1
a45 1
print defined($ary{'foo'}) ? "not ok 12\n" : "ok 12\n";
d47 2
a48 2
print defined(@@ary) ? "ok 13\n" : "not ok 13\n";
print defined(%ary) ? "ok 14\n" : "not ok 14\n";
d50 1
a50 1
print defined(@@ary) ? "not ok 15\n" : "ok 15\n";
d52 1
a52 1
print defined(%ary) ? "not ok 16\n" : "ok 16\n";
d54 1
a54 1
print defined @@ary ? "ok 17\n" : "not ok 17\n";
d56 1
a56 1
print defined %ary ? "ok 18\n" : "not ok 18\n";
d58 1
a58 1
sub foo { print "ok 19\n"; }
d60 1
a60 1
&foo || print "not ok 19\n";
d62 1
a62 1
print defined &foo ? "ok 20\n" : "not ok 20\n";
d64 1
a64 1
print defined(&foo) ? "not ok 21\n" : "ok 21\n";
d67 1
a67 1
print $@@ =~ /^Modification of a read/ ? "ok 22\n" : "not ok 22\n";
d70 1
a70 1
print $@@ =~ /^Modification of a read/ ? "ok 23\n" : "not ok 23\n";
d75 1
a75 1
    print defined %foo ? "ok 24\n" : "not ok 24\n";
d77 1
a77 1
    print defined %foo ? "ok 25\n" : "not ok 25\n";
d83 1
a83 1
    print defined @@foo ? "ok 26\n" : "not ok 26\n";
d85 1
a85 1
    print defined @@foo ? "ok 27\n" : "not ok 27\n";
d91 1
a91 1
    print $@@ =~ /^Can't modify constant item/ ? "ok 28\n" : "not ok 28\n";
a97 1
$test = 29;
d104 5
a108 4
    print "not " if keys   %hash; print "ok $test\n"; $test++;
    print "not " if values %hash; print "ok $test\n"; $test++;
    print "not " if each   %hash; print "ok $test\n"; $test++;
    print "not " if defined delete $hash{'key2'}; print "ok $test\n"; $test++;
d110 9
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d8 1
a8 1
print "1..27\n";
d81 23
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d5 1
a5 1
    unshift @@INC, '../lib';
@


1.3
log
@perl5.005_03 (stock)
@
text
@d3 6
a8 1
print "1..23\n";
d67 15
@


1.2
log
@perl 5.004_04
@
text
@d3 1
a3 3
# $RCSfile: undef.t,v $$Revision: 4.1 $$Date: 92/08/07 18:28:34 $

print "1..21\n";
d55 7
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d3 3
a5 1
print "1..23\n";
a56 7

eval { undef $1 };
print $@@ =~ /^Modification of a read/ ? "ok 22\n" : "not ok 22\n";

eval { $1 = undef };
print $@@ =~ /^Modification of a read/ ? "ok 23\n" : "not ok 23\n";

@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d3 1
a3 6
BEGIN {
    chdir 't' if -d 't';
    unshift @@INC, '../lib';
}

print "1..27\n";
a61 15
{
    require Tie::Hash;
    tie my %foo, 'Tie::StdHash';
    print defined %foo ? "ok 24\n" : "not ok 24\n";
    %foo = ( a => 1 );
    print defined %foo ? "ok 25\n" : "not ok 25\n";
}

{
    require Tie::Array;
    tie my @@foo, 'Tie::StdArray';
    print defined @@foo ? "ok 26\n" : "not ok 26\n";
    @@foo = ( a => 1 );
    print defined @@foo ? "ok 27\n" : "not ok 27\n";
}
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d5 1
a5 1
    @@INC = '../lib';
@


1.1.1.5
log
@perl 5.8.2 from CPAN
@
text
@d8 1
a8 1
print "1..36\n";
a80 23
}

{
    # [perl #17753] segfault when undef'ing unquoted string constant
    eval 'undef tcp';
    print $@@ =~ /^Can't modify constant item/ ? "ok 28\n" : "not ok 28\n";
}

# bugid 3096
# undefing a hash may free objects with destructors that then try to
# modify the hash. To them, the hash should appear empty.

$test = 29;
%hash = (
    key1 => bless({}, 'X'),
    key2 => bless({}, 'X'),
);
undef %hash;
sub X::DESTROY {
    print "not " if keys   %hash; print "ok $test\n"; $test++;
    print "not " if values %hash; print "ok $test\n"; $test++;
    print "not " if each   %hash; print "ok $test\n"; $test++;
    print "not " if defined delete $hash{'key2'}; print "ok $test\n"; $test++;
@


1.1.1.6
log
@import perl 5.10.1
@
text
@a5 1
    require './test.pl';
d8 1
a8 1
use strict;
d10 1
a10 5
use vars qw(@@ary %ary %hash);

plan 37;

ok !defined($a);
d13 1
a13 1
ok defined($a);
d16 1
a16 1
ok !defined($a);
d19 1
a19 1
ok defined($a);
d22 1
a22 1
ok !defined($a);
d26 1
a26 1
ok defined($a);
d28 1
a28 1
ok !defined($a);
d32 1
a32 1
ok defined($a);
d34 1
a34 1
ok !defined($a);
d37 2
a38 2
ok defined($ary{'foo'});
ok !defined($ary{'bar'});
d40 1
a40 1
ok !defined($ary{'foo'});
d42 2
a43 2
ok defined(@@ary);
ok defined(%ary);
d45 1
a45 1
ok !defined(@@ary);
d47 1
a47 1
ok !defined(%ary);
d49 1
a49 1
ok defined @@ary;
d51 1
a51 1
ok defined %ary;
d53 1
a53 1
sub foo { pass; 1 }
d55 1
a55 1
&foo || fail;
d57 1
a57 1
ok defined &foo;
d59 1
a59 1
ok !defined(&foo);
d62 1
a62 1
like $@@, qr/^Modification of a read/;
d65 1
a65 1
like $@@, qr/^Modification of a read/;
d70 1
a70 1
    ok defined %foo;
d72 1
a72 1
    ok defined %foo;
d78 1
a78 1
    ok defined @@foo;
d80 1
a80 1
    ok defined @@foo;
d86 1
a86 1
    like $@@, qr/^Can't modify constant item/;
d93 1
d100 4
a103 5
    is scalar keys %hash, 0;
    is scalar values %hash, 0;
    my @@l = each %hash;
    is @@l, 0;
    is delete $hash{'key2'}, undef;
a104 9

# this will segfault if it fails

sub PVBM () { 'foo' }
{ my $dummy = index 'foo', PVBM }

my $pvbm = PVBM;
undef $pvbm;
ok !defined $pvbm;
@


1.1.1.7
log
@Perl 5.12.2 from CPAN
@
text
@d13 1
a13 1
plan 40;
d48 1
a48 5
{
    no warnings 'deprecated';
    ok defined(%ary);
}
ok %ary;
d52 1
a52 5
{
    no warnings 'deprecated';
    ok !defined(%ary);
}
ok !%ary;
d56 1
a56 5
{
    no warnings 'deprecated';
    ok defined %ary;
}
ok %ary;
a74 1
    no warnings 'deprecated';
a82 1
    no warnings 'deprecated';
@


1.1.1.8
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d13 1
a13 1
plan 85;
d47 1
a49 1
    ok defined(@@ary);
d54 1
a54 4
{
    no warnings 'deprecated';
    ok !defined(@@ary);
}
d62 1
a62 4
{
    no warnings 'deprecated';
    ok defined @@ary;
}
d110 1
a110 6
# modify the hash. Ensure that the hash remains consistent

{
    my (%hash, %mirror);

    my $iters = 5;
d112 11
a122 46
    for (1..$iters) {
	$hash{"k$_"} = bless ["k$_"], 'X';
	$mirror{"k$_"} = "k$_";
    }


    my $c = $iters;
    my $events;

    sub X::DESTROY {
	my $key = $_[0][0];
	$events .= 'D';
	note("----- DELETE($key) ------");
	delete $mirror{$key};

	is join('-', sort keys %hash), join('-', sort keys %mirror),
	    "$key: keys";
	is join('-', sort map $_->[0], values %hash),
	    join('-', sort values %mirror), "$key: values";

	# don't know exactly what we'll get from the iterator, but
	# it must be a sensible value
	my ($k, $v) = each %hash;
	ok defined $k ? exists($mirror{$k}) : (keys(%mirror) == 0),
	    "$key: each 1";

	is delete $hash{$key}, undef, "$key: delete";
	($k, $v) = each %hash;
	ok defined $k ? exists($mirror{$k}) : (keys(%mirror) <= 1),
	    "$key: each 2";

	$c++;
	if ($c <= $iters * 2) {
	    $hash{"k$c"} = bless ["k$c"], 'X';
	    $mirror{"k$c"} = "k$c";
	}
	$events .= 'E';
    }

    each %hash; # set eiter
    undef %hash;

    is scalar keys %hash, 0, "hash empty at end";
    is $events, ('DE' x ($iters*2)), "events";
    my ($k, $v) = each %hash;
    is $k, undef, 'each undef at end';
@


1.1.1.9
log
@Import perl-5.20.1
@
text
@d13 1
a13 1
plan 86;
a169 7

# part of #105906: inlined undef constant getting copied
BEGIN { $::{z} = \undef }
for (z,z) {
    push @@_, \$_;
}
is $_[0], $_[1], 'undef constants preserve identity';
@


