head	1.16;
access;
symbols
	OPENBSD_6_2:1.16.0.2
	OPENBSD_6_2_BASE:1.16
	PERL_5_24_2:1.1.1.15
	OPENBSD_6_1:1.16.0.4
	OPENBSD_6_1_BASE:1.16
	OPENBSD_6_0:1.15.0.10
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.15.0.4
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.15.0.6
	OPENBSD_5_8_BASE:1.15
	PERL_5_20_2:1.1.1.14
	OPENBSD_5_7:1.15.0.2
	OPENBSD_5_7_BASE:1.15
	PERL_5_20_1:1.1.1.14
	OPENBSD_5_6:1.14.0.4
	OPENBSD_5_6_BASE:1.14
	PERL_5_18_2:1.1.1.13
	PERL:1.1.1
	OPENBSD_5_5:1.13.0.6
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.2
	OPENBSD_5_4_BASE:1.13
	PERL_5_16_3:1.1.1.12
	OPENBSD_5_3:1.12.0.10
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.8
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.6
	OPENBSD_5_0:1.12.0.4
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.2
	OPENBSD_4_9_BASE:1.12
	PERL_5_12_2:1.1.1.11
	OPENBSD_4_8:1.11.0.4
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.2
	OPENBSD_4_7_BASE:1.11
	PERL_5_10_1:1.1.1.10
	OPENBSD_4_6:1.10.0.6
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.2
	OPENBSD_4_5_BASE:1.10
	PERL_5_10_0:1.1.1.9
	OPENBSD_4_4:1.9.0.10
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.8
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.6
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.4
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9
	PERL_5_8_8:1.1.1.8
	OPENBSD_3_9:1.8.0.6
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.4
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.2
	OPENBSD_3_7_BASE:1.8
	PERL_5_8_6:1.1.1.7
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7
	PERL_5_8_5:1.1.1.6
	PERL_5_8_3:1.1.1.5
	OPENBSD_3_5:1.6.0.2
	OPENBSD_3_5_BASE:1.6
	PERL_5_8_2:1.1.1.5
	OPENBSD_3_4:1.5.0.4
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.4.0.12
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.10
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.8
	OPENBSD_3_0_BASE:1.4
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.16
date	2017.02.05.00.32.20;	author afresh1;	state Exp;
branches;
next	1.15;
commitid	cxJ08BvJA9Pt2PTM;

1.15
date	2014.11.17.20.57.07;	author afresh1;	state Exp;
branches;
next	1.14;
commitid	QP75iYx42Uo7mMxO;

1.14
date	2014.03.24.15.05.33;	author afresh1;	state Exp;
branches;
next	1.13;

1.13
date	2013.03.25.20.40.59;	author sthen;	state Exp;
branches;
next	1.12;

1.12
date	2010.09.24.15.07.08;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2009.10.12.18.30.27;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2008.09.29.17.36.19;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2006.03.28.19.23.12;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2005.01.15.21.30.40;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2004.08.09.18.10.27;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2003.12.03.03.02.48;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.10.27.22.25.37;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.08.23;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.52.35;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.08.05.22;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.13.18;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.13.18;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.41.45;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.10.48;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.27.22.15.10;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.12.03.02.44.32;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.08.09.17.48.35;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2005.01.15.21.18.18;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2006.03.28.18.49.45;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2008.09.29.17.19.00;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2009.10.12.18.10.45;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2010.09.24.14.49.17;	author millert;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2013.03.25.20.09.35;	author sthen;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2014.03.24.14.59.10;	author afresh1;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2014.11.17.20.53.17;	author afresh1;	state Exp;
branches;
next	1.1.1.15;
commitid	B31cAbBIXiCqnL97;

1.1.1.15
date	2017.08.14.13.46.23;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.16
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl

# "This IS structured code.  It's just randomly structured."

BEGIN {
    chdir 't' if -d 't';
    @@INC = qw(. ../lib);
    require "./test.pl"; require './charset_tools.pl';
}

use warnings;
use strict;
plan tests => 98;
our $TODO;

my $deprecated = 0;
local $SIG{__WARN__} = sub { if ($_[0] =~ m/jump into a construct/) { $deprecated++; } else { warn $_[0] } };

our $foo;
while ($?) {
    $foo = 1;
  label1:
    is($deprecated, 1, "following label1");
    $deprecated = 0;
    $foo = 2;
    goto label2;
} continue {
    $foo = 0;
    goto label4;
  label3:
    is($deprecated, 1, "following label3");
    $deprecated = 0;
    $foo = 4;
    goto label4;
}
is($deprecated, 0, "after 'while' loop");
goto label1;

$foo = 3;

label2:
is($foo, 2, 'escape while loop');
is($deprecated, 0, "following label2");
goto label3;

label4:
is($foo, 4, 'second escape while loop');

my $r = run_perl(prog => 'goto foo;', stderr => 1);
like($r, qr/label/, 'cant find label');

my $ok = 0;
sub foo {
    goto bar;
    return;
bar:
    $ok = 1;
}

&foo;
ok($ok, 'goto in sub');

sub bar {
    my $x = 'bypass';
    eval "goto $x";
}

&bar;
exit;

FINALE:
is(curr_test(), 20, 'FINALE');

# does goto LABEL handle block contexts correctly?
# note that this scope-hopping differs from last & next,
# which always go up-scope strictly.
my $count = 0;
my $cond = 1;
for (1) {
    if ($cond == 1) {
	$cond = 0;
	goto OTHER;
    }
    elsif ($cond == 0) {
      OTHER:
	$cond = 2;
	is($count, 0, 'OTHER');
	$count++;
	goto THIRD;
    }
    else {
      THIRD:
	is($count, 1, 'THIRD');
	$count++;
    }
}
is($count, 2, 'end of loop');

# Does goto work correctly within a for(;;) loop?
#  (BUG ID 20010309.004)

for(my $i=0;!$i++;) {
  my $x=1;
  goto label;
  label: is($x, 1, 'goto inside a for(;;) loop body from inside the body');
}

# Does goto work correctly going *to* a for(;;) loop?
#  (make sure it doesn't skip the initializer)

my ($z, $y) = (0);
FORL1: for ($y=1; $z;) {
    ok($y, 'goto a for(;;) loop, from outside (does initializer)');
    goto TEST19}
($y,$z) = (0, 1);
goto FORL1;

# Even from within the loop?
TEST19: $z = 0;
FORL2: for($y=1; 1;) {
  if ($z) {
    ok($y, 'goto a for(;;) loop, from inside (does initializer)');
    last;
  }
  ($y, $z) = (0, 1);
  goto FORL2;
}

# Does goto work correctly within a try block?
#  (BUG ID 20000313.004) - [perl #2359]
$ok = 0;
eval {
  my $variable = 1;
  goto LABEL20;
  LABEL20: $ok = 1 if $variable;
};
ok($ok, 'works correctly within a try block');
is($@@, "", '...and $@@ not set');

# And within an eval-string?
$ok = 0;
eval q{
  my $variable = 1;
  goto LABEL21;
  LABEL21: $ok = 1 if $variable;
};
ok($ok, 'works correctly within an eval string');
is($@@, "", '...and $@@ still not set');


# Test that goto works in nested eval-string
$ok = 0;
{eval q{
  eval q{
    goto LABEL22;
  };
  $ok = 0;
  last;

  LABEL22: $ok = 1;
};
$ok = 0 if $@@;
}
ok($ok, 'works correctly in a nested eval string');

{
    my $false = 0;
    my $count;

    $ok = 0;
    { goto A; A: $ok = 1 } continue { }
    ok($ok, '#20357 goto inside /{ } continue { }/ loop');

    $ok = 0;
    { do { goto A; A: $ok = 1 } while $false }
    ok($ok, '#20154 goto inside /do { } while ()/ loop');
    $ok = 0;
    foreach(1) { goto A; A: $ok = 1 } continue { };
    ok($ok, 'goto inside /foreach () { } continue { }/ loop');

    $ok = 0;
    sub a {
	A: { if ($false) { redo A; B: $ok = 1; redo A; } }
	goto B unless $count++;
    }
    is($deprecated, 0, "before calling sub a()");
    a();
    ok($ok, '#19061 loop label wiped away by goto');
    is($deprecated, 1, "after calling sub a()");
    $deprecated = 0;

    $ok = 0;
    my $p;
    for ($p=1;$p && goto A;$p=0) { A: $ok = 1 }
    ok($ok, 'weird case of goto and for(;;) loop');
    is($deprecated, 1, "following goto and for(;;) loop");
    $deprecated = 0;
}

# bug #9990 - don't prematurely free the CV we're &going to.

sub f1 {
    my $x;
    goto sub { $x=0; ok(1,"don't prematurely free CV\n") }
}
f1();

# bug #99850, which is similar - freeing the subroutine we are about to
# go(in)to during a FREETMPS call should not crash perl.

package _99850 {
    sub reftype{}
    DESTROY { undef &reftype }
    eval { sub { my $guard = bless []; goto &reftype }->() };
}
like $@@, qr/^Goto undefined subroutine &_99850::reftype at /,
   'goto &foo undefining &foo on sub cleanup';

# When croaking after discovering that the new CV you're about to goto is
# undef, make sure that the old CV isn't doubly freed.

package Do_undef {
    my $count;

    # creating a new closure here encourages any prematurely freed
    # CV to be reallocated
    sub DESTROY { undef &undef_sub; my $x = sub { $count } }

    sub f {
        $count++;
        my $guard = bless []; # trigger DESTROY during goto
        *undef_sub = sub {};
        goto &undef_sub
    }

    for (1..10) {
        eval { f() };
    }
    ::is($count, 10, "goto undef_sub safe");
}

# make sure that nothing nasty happens if the old CV is freed while
# goto'ing

package Free_cv {
    my $results;
    sub f {
        no warnings 'redefine';
        *f = sub {};
        goto &g;
    }
    sub g { $results = "(@@_)" }

    f(1,2,3);
    ::is($results, "(1 2 3)", "Free_cv");
}


# bug #22181 - this used to coredump or make $x undefined, due to
# erroneous popping of the inner BLOCK context

undef $ok;
for ($count=0; $count<2; $count++) {
    my $x = 1;
    goto LABEL29;
    LABEL29:
    $ok = $x;
}
is($ok, 1, 'goto in for(;;) with continuation');

# bug #22299 - goto in require doesn't find label

open my $f, ">Op_goto01.pm" or die;
print $f <<'EOT';
package goto01;
goto YYY;
die;
YYY: print "OK\n";
1;
EOT
close $f;

$r = runperl(prog => 'use Op_goto01; print qq[DONE\n]');
is($r, "OK\nDONE\n", "goto within use-d file"); 
unlink_all "Op_goto01.pm";

# test for [perl #24108]
$ok = 1;
$count = 0;
sub i_return_a_label {
    $count++;
    return "returned_label";
}
eval { goto +i_return_a_label; };
$ok = 0;

returned_label:
is($count, 1, 'called i_return_a_label');
ok($ok, 'skipped to returned_label');

# [perl #29708] - goto &foo could leave foo() at depth two with
# @@_ == PL_sv_undef, causing a coredump


$r = runperl(
    prog =>
	'sub f { return if $d; $d=1; my $a=sub {goto &f}; &$a; f() } f(); print qq(ok\n)',
    stderr => 1
    );
is($r, "ok\n", 'avoid pad without an @@_');

goto moretests;
fail('goto moretests');
exit;

bypass:

is(curr_test(), 9, 'eval "goto $x"');

# Test autoloading mechanism.

sub two {
    my ($pack, $file, $line) = caller;	# Should indicate original call stats.
    is("@@_ $pack $file $line", "1 2 3 main $::FILE $::LINE",
	'autoloading mechanism.');
}

sub one {
    eval <<'END';
    no warnings 'redefine';
    sub one { pass('sub one'); goto &two; fail('sub one tail'); }
END
    goto &one;
}

$::FILE = __FILE__;
$::LINE = __LINE__ + 1;
&one(1,2,3);

{
    my $wherever = 'NOWHERE';
    eval { goto $wherever };
    like($@@, qr/Can't find label NOWHERE/, 'goto NOWHERE sets $@@');
}

# see if a modified @@_ propagates
{
  my $i;
  package Foo;
  sub DESTROY	{ my $s = shift; ::is($s->[0], $i, "destroy $i"); }
  sub show	{ ::is(+@@_, 5, "show $i",); }
  sub start	{ push @@_, 1, "foo", {}; goto &show; }
  for (1..3)	{ $i = $_; start(bless([$_]), 'bar'); }
}

sub auto {
    goto &loadit;
}

sub AUTOLOAD { $ok = 1 if "@@_" eq "foo" }

$ok = 0;
auto("foo");
ok($ok, 'autoload');

{
    my $wherever = 'FINALE';
    goto $wherever;
}
fail('goto $wherever');

moretests:
# test goto duplicated labels.
{
    my $z = 0;
    eval {
	$z = 0;
	for (0..1) {
	  L4: # not outer scope
	    $z += 10;
	    last;
	}
	goto L4 if $z == 10;
	last;
    };
    like($@@, qr/Can't "goto" into the middle of a foreach loop/,
	    'catch goto middle of foreach');

    $z = 0;
    # ambiguous label resolution (outer scope means endless loop!)
  L1:
    for my $x (0..1) {
	$z += 10;
	is($z, 10, 'prefer same scope (loop body) to outer scope (loop entry)');
	goto L1 unless $x;
	$z += 10;
      L1:
	is($z, 10, 'prefer same scope: second');
	last;
    }

    $z = 0;
  L2: 
    { 
	$z += 10;
	is($z, 10, 'prefer this scope (block body) to outer scope (block entry)');
	goto L2 if $z == 10;
	$z += 10;
      L2:
	is($z, 10, 'prefer this scope: second');
    }


    { 
	$z = 0;
	while (1) {
	  L3: # not inner scope
	    $z += 10;
	    last;
	}
	is($z, 10, 'prefer this scope to inner scope');
	goto L3 if $z == 10;
	$z += 10;
      L3: # this scope !
	is($z, 10, 'prefer this scope to inner scope: second');
    }

  L4: # not outer scope
    { 
	$z = 0;
	while (1) {
	  L4: # not inner scope
	    $z += 1;
	    last;
	}
	is($z, 1, 'prefer this scope to inner,outer scopes');
	goto L4 if $z == 1;
	$z += 10;
      L4: # this scope !
	is($z, 1, 'prefer this scope to inner,outer scopes: second');
    }

    {
	my $loop = 0;
	for my $x (0..1) { 
	  L2: # without this, fails 1 (middle) out of 3 iterations
	    $z = 0;
	  L2: 
	    $z += 10;
	    is($z, 10,
		"same label, multiple times in same scope (choose 1st) $loop");
	    goto L2 if $z == 10 and not $loop++;
	}
    }
}

# This bug was introduced in Aug 2010 by commit ac56e7de46621c6f
# Peephole optimise adjacent pairs of nextstate ops.
# and fixed in Oct 2014 by commit f5b5c2a37af87535
# Simplify double-nextstate optimisation

# The bug manifests as a warning
# Use of "goto" to jump into a construct is deprecated at t/op/goto.t line 442.
# and $out is undefined. Devel::Peek reveals that the lexical in the pad has
# been reset to undef. I infer that pp_goto thinks that it's leaving one scope
# and entering another, but I don't know *why* it thinks that. Whilst this bug
# has been fixed by Father C, because I don't understand why it happened, I am
# not confident that other related bugs remain (or have always existed).

sub DEBUG_TIME() {
    0;
}

{
    if (DEBUG_TIME) {
    }

    {
        my $out = "";
        $out .= 'perl rules';
        goto no_list;
    no_list:
        is($out, 'perl rules', '$out has not been erroneously reset to undef');
    };
}

is($deprecated, 0, 'no warning was emmitted');

# deep recursion with gotos eventually caused a stack reallocation
# which messed up buggy internals that didn't expect the stack to move

sub recurse1 {
    unshift @@_, "x";
    no warnings 'recursion';
    goto &recurse2;
}
sub recurse2 {
    my $x = shift;
    $_[0] ? +1 + recurse1($_[0] - 1) : 0
}
my $w = 0;
$SIG{__WARN__} = sub { ++$w };
is(recurse1(500), 500, 'recursive goto &foo');
is $w, 0, 'no recursion warnings for "no warnings; goto &sub"';
delete $SIG{__WARN__};

# [perl #32039] Chained goto &sub drops data too early. 

sub a32039 { @@_=("foo"); goto &b32039; }
sub b32039 { goto &c32039; }
sub c32039 { is($_[0], 'foo', 'chained &goto') }
a32039();

# [perl #35214] next and redo re-entered the loop with the wrong cop,
# causing a subsequent goto to crash

{
    my $r = runperl(
		stderr => 1,
		prog =>
'for ($_=0;$_<3;$_++){A: if($_==1){next} if($_==2){$_++;goto A}}print qq(ok\n)'
    );
    is($r, "ok\n", 'next and goto');

    $r = runperl(
		stderr => 1,
		prog =>
'for ($_=0;$_<3;$_++){A: if($_==1){$_++;redo} if($_==2){$_++;goto A}}print qq(ok\n)'
    );
    is($r, "ok\n", 'redo and goto');
}

# goto &foo not allowed in evals

sub null { 1 };
eval 'goto &null';
like($@@, qr/Can't goto subroutine from an eval-string/, 'eval string');
eval { goto &null };
like($@@, qr/Can't goto subroutine from an eval-block/, 'eval block');
 
# goto &foo leaves @@_ alone when called from a sub
sub returnarg { $_[0] };
is sub {
    local *_ = ["ick and queasy"];
    goto &returnarg;
}->("quick and easy"), "ick and queasy",
  'goto &foo with *_{ARRAY} replaced';
my @@__ = byte_utf8a_to_utf8n("\xc4\x80");
sub { local *_ = \@@__; goto &utf8::decode }->("no thinking aloud");
is "@@__", chr 256, 'goto &xsub with replaced *_{ARRAY}';

# And goto &foo should leave reified @@_ alone
sub { *__ = \@@_;  goto &null } -> ("rough and tubbery");
is ${*__}[0], 'rough and tubbery', 'goto &foo leaves reified @@_ alone';

# goto &xsub when @@_ has nonexistent elements
{
    no warnings "uninitialized";
    local @@_ = ();
    $#_++;
    & {sub { goto &utf8::encode }};
    is @@_, 1, 'num of elems in @@_ after goto &xsub with nonexistent $_[0]';
    is $_[0], "", 'content of nonexistent $_[0] is modified by goto &xsub';
}

# goto &xsub when @@_ itself does not exist
undef *_;
eval { & { sub { goto &utf8::encode } } };
# The main thing we are testing is that it did not crash.  But make sure 
# *_{ARRAY} was untouched, too.
is *_{ARRAY}, undef, 'goto &xsub when @@_ does not exist';

# goto &perlsub when @@_ itself does not exist [perl #119949]
# This was only crashing when the replaced sub call had an argument list.
# (I.e., &{ sub { goto ... } } did not crash.)
sub {
    undef *_;
    goto sub {
	is *_{ARRAY}, undef, 'goto &perlsub when @@_ does not exist';
    }
}->();
sub {
    local *_;
    goto sub {
	is *_{ARRAY}, undef, 'goto &sub when @@_ does not exist (local *_)';
    }
}->();


# [perl #36521] goto &foo in warn handler could defeat recursion avoider

{
    my $r = runperl(
		stderr => 1,
		prog => 'my $d; my $w = sub { return if $d++; warn q(bar)}; local $SIG{__WARN__} = sub { goto &$w; }; warn q(foo);'
    );
    like($r, qr/bar/, "goto &foo in warn");
}

TODO: {
    local $TODO = "[perl #43403] goto() from an if to an else doesn't undo local () changes";
    our $global = "unmodified";
    if ($global) { # true but not constant-folded
         local $global = "modified";
         goto ELSE;
    } else {
         ELSE: is($global, "unmodified");
    }
}

is($deprecated, 0, "following TODOed test for #43403");

#74290
{
    my $x;
    my $y;
    F1:++$x and eval 'return if ++$y == 10; goto F1;';
    is($x, 10,
       'labels outside evals can be distinguished from the start of the eval');
}

goto wham_eth;
die "You can't get here";

wham_eth: 1 if 0;
ouch_eth: pass('labels persist even if their statement is optimised away');

$foo = "(0)";
if($foo eq $foo) {
    goto bungo;
}
$foo .= "(9)";
bungo:
format CHOLET =
wellington
.
$foo .= "(1)";
SKIP: {
    skip_if_miniperl("no dynamic loading on miniperl, so can't load PerlIO::scalar", 1);
    my $cholet;
    open(CHOLET, ">", \$cholet);
    write CHOLET;
    close CHOLET;
    $foo .= "(".$cholet.")";
    is($foo, "(0)(1)(wellington\n)", "label before format decl");
}

$foo = "(A)";
if($foo eq $foo) {
    goto orinoco;
}
$foo .= "(X)";
orinoco:
sub alderney { return "tobermory"; }
$foo .= "(B)";
$foo .= "(".alderney().")";
is($foo, "(A)(B)(tobermory)", "label before sub decl");

$foo = "[0:".__PACKAGE__."]";
if($foo eq $foo) {
    goto bulgaria;
}
$foo .= "[9]";
bulgaria:
package Tomsk;
$foo .= "[1:".__PACKAGE__."]";
$foo .= "[2:".__PACKAGE__."]";
package main;
$foo .= "[3:".__PACKAGE__."]";
is($foo, "[0:main][1:Tomsk][2:Tomsk][3:main]", "label before package decl");

$foo = "[A:".__PACKAGE__."]";
if($foo eq $foo) {
    goto adelaide;
}
$foo .= "[Z]";
adelaide:
package Cairngorm {
    $foo .= "[B:".__PACKAGE__."]";
}
$foo .= "[C:".__PACKAGE__."]";
is($foo, "[A:main][B:Cairngorm][C:main]", "label before package block");

our $obidos;
$foo = "{0}";
if($foo eq $foo) {
    goto shansi;
}
$foo .= "{9}";
shansi:
BEGIN { $obidos = "x"; }
$foo .= "{1$obidos}";
is($foo, "{0}{1x}", "label before BEGIN block");

$foo = "{A:".(1.5+1.5)."}";
if($foo eq $foo) {
    goto stepney;
}
$foo .= "{Z}";
stepney:
use integer;
$foo .= "{B:".(1.5+1.5)."}";
is($foo, "{A:3}{B:2}", "label before use decl");

$foo = "<0>";
if($foo eq $foo) {
    goto tom;
}
$foo .= "<9>";
tom: dick: harry:
$foo .= "<1>";
$foo .= "<2>";
is($foo, "<0><1><2>", "first of three stacked labels");

$foo = "<A>";
if($foo eq $foo) {
    goto beta;
}
$foo .= "<Z>";
alpha: beta: gamma:
$foo .= "<B>";
$foo .= "<C>";
is($foo, "<A><B><C>", "second of three stacked labels");

$foo = ",0.";
if($foo eq $foo) {
    goto gimel;
}
$foo .= ",9.";
alef: bet: gimel:
$foo .= ",1.";
$foo .= ",2.";
is($foo, ",0.,1.,2.", "third of three stacked labels");

# [perl #112316] Wrong behavior regarding labels with same prefix
sub same_prefix_labels {
    my $pass;
    my $first_time = 1;
    CATCH: {
        if ( $first_time ) {
            CATCHLOOP: {
                if ( !$first_time ) {
                  return 0;
                }
                $first_time--;
                goto CATCH;
            }
        }
        else {
            return 1;
        }
    }
}

ok(
   same_prefix_labels(),
   "perl 112316: goto and labels with the same prefix doesn't get mixed up"
);

eval { my $x = ""; goto $x };
like $@@, qr/^goto must have label at /, 'goto $x where $x is empty string';
eval { goto "" };
like $@@, qr/^goto must have label at /, 'goto ""';
eval { goto };
like $@@, qr/^goto must have label at /, 'argless goto';

eval { my $x = "\0"; goto $x };
like $@@, qr/^Can't find label \0 at /, 'goto $x where $x begins with \0';
eval { goto "\0" };
like $@@, qr/^Can't find label \0 at /, 'goto "\0"';

sub TIESCALAR { bless [pop] }
sub FETCH     { $_[0][0] }
tie my $t, "", sub { "cluck up porridge" };
is eval { sub { goto $t }->() }//$@@, 'cluck up porridge',
  'tied arg returning sub ref';
@


1.15
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d8 1
a8 1
    require "test.pl";
d13 1
a13 1
plan tests => 94;
d219 40
d457 32
d548 1
a548 1
my @@__ = "\xc4\x80";
@


1.14
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d13 1
a13 1
plan tests => 89;
d483 33
@


1.13
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d13 1
a13 1
plan tests => 80;
d23 1
a23 1
    is($deprecated, 1);
d31 1
a31 1
    is($deprecated, 1);
d36 1
a36 1
is($deprecated, 0);
d43 1
a43 1
is($deprecated, 0);
d186 1
a186 1
    is($deprecated, 0);
d189 1
a189 1
    is($deprecated, 1);
d196 1
a196 1
    is($deprecated, 1);
a462 1

d468 16
d506 1
a506 1
is($deprecated, 0);
d654 18
@


1.12
log
@merge in perl 5.12.2 plus local changes
@
text
@d13 1
a13 1
plan tests => 67;
d208 11
d245 1
a245 1
unlink "Op_goto01.pm";
d429 2
d432 2
d501 138
@


1.11
log
@Merge in perl 5.10.1; part two
@
text
@d13 1
a13 1
plan tests => 58;
d16 3
d23 2
d31 2
d36 1
d43 1
d72 1
a72 1
is(curr_test(), 16, 'FINALE');
d186 1
d189 2
d196 2
d267 1
a267 1
is(curr_test(), 5, 'eval "goto $x"');
d476 10
@


1.10
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d208 1
a208 1
open my $f, ">goto01.pm" or die;
d218 1
a218 1
$r = runperl(prog => 'use goto01; print qq[DONE\n]');
d220 1
a220 1
unlink "goto01.pm";
@


1.9
log
@merge in perl 5.8.8
@
text
@d13 2
a14 1
plan tests => 57;
d450 12
@


1.8
log
@sync in-tree perl with 5.8.6
@
text
@d8 1
d11 3
a13 5
print "1..47\n";

require "test.pl";

$purpose; # update per test, and include in print ok's !
d15 1
d33 1
a33 2
print "#1\t:$foo: == 2\n";
if ($foo == 2) {print "ok 1\n";} else {print "not ok 1\n";}
d37 1
a37 2
print "#2\t:$foo: == 4\n";
if ($foo == 4) {print "ok 2\n";} else {print "not ok 2\n";}
d39 2
a40 5
$PERL = ($^O eq 'MSWin32') ? '.\perl' : ($^O eq 'MacOS') ? $^X : ($^O eq 'NetWare') ? 'perl' : './perl';
$CMD = qq[$PERL -e "goto foo;" 2>&1 ];
$x = `$CMD`;

if ($x =~ /label/) {print "ok 3\n";} else {print "not ok 3\n";}
d42 1
a44 1
    print "not ok 4\n";
d47 1
a47 1
    print "ok 4\n";
d51 1
d54 1
a54 1
    $x = 'bypass';
d62 1
a62 1
print "ok 13\n";
a64 1
$purpose = 'handles block contexts correctly (does scope-hopping)';
d67 1
d77 2
a78 1
	print "ok 14 - $purpose\n";
d83 2
a84 1
	print "ok 15 - $purpose\n";
d87 1
a87 1
print "ok 16\n";
a91 1
$purpose = 'goto inside a for(;;) loop body from inside the body';
d95 1
a95 1
  label: print (defined $x?"ok ": "not ok ", "17 - $purpose\n")
a100 1
$purpose = 'goto a for(;;) loop, from outside (does initializer)';
d102 4
a105 2
FORL1: for($y="ok 18 - $purpose\n"; $z;) {print $y; goto TEST19}
($y,$z) = ("not ok 18 - $purpose\n", 1);
d110 1
a110 2
$purpose = 'goto a for(;;) loop, from inside (does initializer)';
FORL2: for($y="ok 19 - $purpose\n"; 1;) {
d112 1
a112 1
    print $y;
d115 1
a115 1
  ($y, $z) = ("not ok 19 - $purpose\n", 1);
d120 2
a121 3
#  (BUG ID 20000313.004)
$purpose = 'works correctly within a try block';
my $ok = 0;
d127 2
a128 1
print ($ok&&!$@@ ? "ok 20" : "not ok 20", " - $purpose\n");
a130 1
$purpose = 'works correctly within an eval string';
d137 2
a138 1
print ($ok&&!$@@ ? "ok" : "not ok", " 21 - $purpose\n");
a141 1
$purpose = 'works correctly in a nested eval string';
d154 1
a154 1
print ($ok ? "ok" : "not ok", " 22 - $purpose\n");
d158 1
d162 1
a162 2
    print "not " unless $ok;
    print "ok 23 - #20357 goto inside /{ } continue { }/ loop\n";
d166 1
a166 3
    print "not " unless $ok;
    print "ok 24 - #20154 goto inside /do { } while ()/ loop\n";

d169 1
a169 2
    print "not " unless $ok;
    print "ok 25 - goto inside /foreach () { } continue { }/ loop\n";
d174 1
a174 1
	goto B unless $r++
d177 1
a177 2
    print "not " unless $ok;
    print "ok 26 - #19061 loop label wiped away by goto\n";
d180 1
d182 1
a182 2
    print "not " unless $ok;
    print "ok 27 - weird case of goto and for(;;) loop\n";
d189 1
a189 1
    goto sub { $x; print "ok 28 - don't prematurely free CV\n" }
d196 2
a197 1
for ($i=0; $i<2; $i++) {
d201 1
a201 1
    print "not " if !defined $x || $x != 1;
d203 1
a203 1
print "ok 29 - goto in for(;;) with continuation\n";
d217 1
a217 2
curr_test(30);
my $r = runperl(prog => 'use goto01; print qq[DONE\n]');
d222 2
d225 1
a225 1
    print "ok 31 - i_return_a_label called\n";
d229 5
a233 2
print "not ";
returned_label : print "ok 32 - done to returned_label\n";
d239 1
a239 1
my $r = runperl(
d244 1
a244 2
print "not " if $r ne "ok\n";
print "ok 33 - avoid pad without an \@@_\n";
d247 1
d251 2
a252 2
$purpose = 'eval "goto $x"';
print "ok 5 - $purpose\n";
d257 3
a259 5
    ($pack, $file, $line) = caller;	# Should indicate original call stats.
    $purpose = 'autoloading mechanism.';
    print "@@_ $pack $file $line" eq "1 2 3 main $FILE $LINE"
	? "ok 7 - $purpose\n"
	: "not ok 7 - $purpose\n";
d264 2
a265 1
    sub one { print "ok 6\n"; goto &two; print "not ok 6\n"; }
d270 2
a271 2
$FILE = __FILE__;
$LINE = __LINE__ + 1;
d274 5
a278 5
$purpose = 'goto NOWHERE sets $@@';
$wherever = NOWHERE;
eval { goto $wherever };
print $@@ =~ /Can't find label NOWHERE/
 ? "ok 8 - $purpose\n" : "not ok 8 - $purpose\n"; #'
d282 1
d284 2
a285 2
  sub DESTROY	{ my $s = shift; print "ok $s->[0]\n"; }
  sub show	{ print "# @@_\nnot ok $_[0][0]\n" if @@_ != 5; }
d287 1
a287 1
  for (9..11)	{ start(bless([$_]), 'bar'); }
d294 1
a294 1
sub AUTOLOAD { print @@_ }
d296 3
a298 1
auto("ok 12\n");
d300 5
a304 2
$wherever = FINALE;
goto $wherever;
a309 1
    $purpose = "catch goto middle of foreach";
d320 2
a321 2
    print ($@@ =~ /Can't "goto" into the middle of a foreach loop/ #'
	   ? "ok" : "not ok", " 34 - $purpose\n");    
a324 1
    $purpose = "prefer same scope (loop body) to outer scope (loop entry)";
d328 1
a328 1
	print $z == 10 ? "" : "not ", "ok 35 - $purpose\n";
d332 1
a332 1
	print $z == 10 ? "" : "not ", "ok 36 - $purpose\n";
a335 1
    $purpose = "prefer this scope (block body) to outer scope (block entry)";
d340 1
a340 1
	print $z == 10 ? "" : "not ", "ok 37 - $purpose\n";
d344 1
a344 1
	print $z == 10 ? "" : "not ", "ok 38 - $purpose\n";
a348 1
	$purpose = "prefer this scope to inner scope";
d355 1
a355 1
	print $z == 10 ? "": "not ", "ok 39 - $purpose\n";
d359 1
a359 1
	print $z == 10 ? "" : "not ", "ok 40 - $purpose\n";
a363 1
	$purpose = "prefer this scope to inner,outer scopes";
d370 1
a370 1
	print $z == 1 ? "": "not ", "ok 41 - $purpose\n";
d374 1
a374 1
	print $z == 1 ? "": "not ", "ok 42 - $purpose\n";
d378 2
a379 4
	$purpose = "same label, multiple times in same scope (choose 1st)";
	my $tnum = 43;
	my $loop;
	for $x (0..1) { 
d384 2
a385 2
	    print $z == 10 ? "": "not ", "ok $tnum - $purpose\n";
	    $tnum++;
d396 1
d400 1
a400 1
    $x = shift;
d403 1
a403 2
print "not " unless recurse1(500) == 500;
print "ok 46 - recursive goto &foo\n";
d409 1
a409 1
sub c32039 { print $_[0] eq 'foo' ? "" : "not ", "ok 47 - chained &goto\n" }
d412 18
d431 1
d433 16
@


1.7
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d10 1
a10 1
print "1..33\n";
d14 2
d69 3
a71 1

d81 1
a81 1
	print "ok 14\n";
d86 1
a86 1
	print "ok 15\n";
d94 1
d98 1
a98 1
  label: print (defined $x?"ok ": "not ok ", "17\n")
d104 1
d106 2
a107 2
FORL1: for($y="ok 18\n"; $z;) {print $y; goto TEST19}
($y,$z) = ("not ok 18\n", 1);
a110 1

d112 2
a113 1
FORL2: for($y="ok 19\n"; 1;) {
d118 1
a118 1
  ($y, $z) = ("not ok 19\n", 1);
d124 1
a124 1

d131 1
a131 1
print ($ok&&!$@@ ? "ok 20\n" : "not ok 20\n");
d134 1
a134 2


d141 1
a141 1
print ($ok&&!$@@ ? "ok 21\n" : "not ok 21\n");
d145 1
d158 1
a158 1
print ($ok ? "ok 22\n" : "not ok 22\n");
d250 1
a250 1

d254 2
a255 1
print "ok 5\n";
d261 1
d263 2
a264 2
	? "ok 7\n"
	: "not ok 7\n";
d278 1
d281 2
a282 1
print $@@ =~ /Can't find label NOWHERE/ ? "ok 8\n" : "not ok 8\n";
d303 116
@


1.6
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d10 1
a10 1
print "1..32\n";
d231 13
@


1.5
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d5 8
a12 1
print "1..22\n";
d153 78
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d5 1
a5 1
print "1..16\n";
d32 1
a32 1
$PERL = ($^O eq 'MSWin32') ? '.\perl' : './perl';
d79 68
@


1.3
log
@perl5.005_03 (stock)
@
text
@d5 1
a5 1
print "1..13\n";
d33 2
a34 2
$x = `$PERL -e "goto foo;" 2>&1`;
if ($x =~ /DCL-W-NOCOMD/) { $x = `\$ mcr sys\$disk:[]perl. -e "goto foo;"`; }
d58 21
@


1.2
log
@perl 5.004_04
@
text
@a2 2
# $RCSfile: goto.t,v $$Revision: 4.1 $$Date: 92/08/07 18:27:56 $

d5 1
a5 1
print "1..9\n";
d57 1
a57 1
print "ok 9\n";
d86 17
@


1.1
log
@Initial revision
@
text
@d34 2
a35 1
$x = `./perl -e 'goto foo;' 2>&1`;
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d3 2
d7 1
a7 1
print "1..13\n";
d34 1
a34 2
$PERL = ($^O eq 'MSWin32') ? '.\perl' : './perl';
$x = `$PERL -e "goto foo;" 2>&1`;
d58 1
a58 1
print "ok 13\n";
a86 17

# see if a modified @@_ propagates
{
  package Foo;
  sub DESTROY	{ my $s = shift; print "ok $s->[0]\n"; }
  sub show	{ print "# @@_\nnot ok $_[0][0]\n" if @@_ != 5; }
  sub start	{ push @@_, 1, "foo", {}; goto &show; }
  for (9..11)	{ start(bless([$_]), 'bar'); }
}

sub auto {
    goto &loadit;
}

sub AUTOLOAD { print @@_ }

auto("ok 12\n");
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d5 1
a5 1
print "1..16\n";
d33 2
a34 2
$CMD = qq[$PERL -e "goto foo;" 2>&1 ];
$x = `$CMD`;
a57 21

# does goto LABEL handle block contexts correctly?

my $cond = 1;
for (1) {
    if ($cond == 1) {
	$cond = 0;
	goto OTHER;
    }
    elsif ($cond == 0) {
      OTHER:
	$cond = 2;
	print "ok 14\n";
	goto THIRD;
    }
    else {
      THIRD:
	print "ok 15\n";
    }
}
print "ok 16\n";
@


1.1.1.4
log
@stock perl 5.8.0 from CPAN
@
text
@d5 1
a5 1
print "1..22\n";
d32 1
a32 1
$PERL = ($^O eq 'MSWin32') ? '.\perl' : ($^O eq 'MacOS') ? $^X : ($^O eq 'NetWare') ? 'perl' : './perl';
a78 68

# Does goto work correctly within a for(;;) loop?
#  (BUG ID 20010309.004)

for(my $i=0;!$i++;) {
  my $x=1;
  goto label;
  label: print (defined $x?"ok ": "not ok ", "17\n")
}

# Does goto work correctly going *to* a for(;;) loop?
#  (make sure it doesn't skip the initializer)

my ($z, $y) = (0);
FORL1: for($y="ok 18\n"; $z;) {print $y; goto TEST19}
($y,$z) = ("not ok 18\n", 1);
goto FORL1;

# Even from within the loop?

TEST19: $z = 0;
FORL2: for($y="ok 19\n"; 1;) {
  if ($z) {
    print $y;
    last;
  }
  ($y, $z) = ("not ok 19\n", 1);
  goto FORL2;
}

# Does goto work correctly within a try block?
#  (BUG ID 20000313.004)

my $ok = 0;
eval {
  my $variable = 1;
  goto LABEL20;
  LABEL20: $ok = 1 if $variable;
};
print ($ok&&!$@@ ? "ok 20\n" : "not ok 20\n");

# And within an eval-string?


$ok = 0;
eval q{
  my $variable = 1;
  goto LABEL21;
  LABEL21: $ok = 1 if $variable;
};
print ($ok&&!$@@ ? "ok 21\n" : "not ok 21\n");


# Test that goto works in nested eval-string
$ok = 0;
{eval q{
  eval q{
    goto LABEL22;
  };
  $ok = 0;
  last;

  LABEL22: $ok = 1;
};
$ok = 0 if $@@;
}
print ($ok ? "ok 22\n" : "not ok 22\n");

@


1.1.1.5
log
@perl 5.8.2 from CPAN
@
text
@d5 1
a5 8
BEGIN {
    chdir 't' if -d 't';
    @@INC = qw(. ../lib);
}

print "1..32\n";

require "test.pl";
a145 78

{
    my $false = 0;

    $ok = 0;
    { goto A; A: $ok = 1 } continue { }
    print "not " unless $ok;
    print "ok 23 - #20357 goto inside /{ } continue { }/ loop\n";

    $ok = 0;
    { do { goto A; A: $ok = 1 } while $false }
    print "not " unless $ok;
    print "ok 24 - #20154 goto inside /do { } while ()/ loop\n";

    $ok = 0;
    foreach(1) { goto A; A: $ok = 1 } continue { };
    print "not " unless $ok;
    print "ok 25 - goto inside /foreach () { } continue { }/ loop\n";

    $ok = 0;
    sub a {
	A: { if ($false) { redo A; B: $ok = 1; redo A; } }
	goto B unless $r++
    }
    a();
    print "not " unless $ok;
    print "ok 26 - #19061 loop label wiped away by goto\n";

    $ok = 0;
    for ($p=1;$p && goto A;$p=0) { A: $ok = 1 }
    print "not " unless $ok;
    print "ok 27 - weird case of goto and for(;;) loop\n";
}

# bug #9990 - don't prematurely free the CV we're &going to.

sub f1 {
    my $x;
    goto sub { $x; print "ok 28 - don't prematurely free CV\n" }
}
f1();

# bug #22181 - this used to coredump or make $x undefined, due to
# erroneous popping of the inner BLOCK context

for ($i=0; $i<2; $i++) {
    my $x = 1;
    goto LABEL29;
    LABEL29:
    print "not " if !defined $x || $x != 1;
}
print "ok 29 - goto in for(;;) with continuation\n";

# bug #22299 - goto in require doesn't find label

open my $f, ">goto01.pm" or die;
print $f <<'EOT';
package goto01;
goto YYY;
die;
YYY: print "OK\n";
1;
EOT
close $f;

curr_test(30);
my $r = runperl(prog => 'use goto01; print qq[DONE\n]');
is($r, "OK\nDONE\n", "goto within use-d file"); 
unlink "goto01.pm";

# test for [perl #24108]
sub i_return_a_label {
    print "ok 31 - i_return_a_label called\n";
    return "returned_label";
}
eval { goto +i_return_a_label; };
print "not ";
returned_label : print "ok 32 - done to returned_label\n";
@


1.1.1.6
log
@Import of stock perl 5.8.5
@
text
@d10 1
a10 1
print "1..33\n";
a230 13

# [perl #29708] - goto &foo could leave foo() at depth two with
# @@_ == PL_sv_undef, causing a coredump


my $r = runperl(
    prog =>
	'sub f { return if $d; $d=1; my $a=sub {goto &f}; &$a; f() } f(); print qq(ok\n)',
    stderr => 1
    );
print "not " if $r ne "ok\n";
print "ok 33 - avoid pad without an \@@_\n";

@


1.1.1.7
log
@perl 5.8.6 from CPAN
@
text
@d10 1
a10 1
print "1..47\n";
a13 2
$purpose; # update per test, and include in print ok's !

d67 1
a67 3
$purpose = 'handles block contexts correctly (does scope-hopping)';
# note that this scope-hopping differs from last & next,
# which always go up-scope strictly.
d77 1
a77 1
	print "ok 14 - $purpose\n";
d82 1
a82 1
	print "ok 15 - $purpose\n";
a89 1
$purpose = 'goto inside a for(;;) loop body from inside the body';
d93 1
a93 1
  label: print (defined $x?"ok ": "not ok ", "17 - $purpose\n")
a98 1
$purpose = 'goto a for(;;) loop, from outside (does initializer)';
d100 2
a101 2
FORL1: for($y="ok 18 - $purpose\n"; $z;) {print $y; goto TEST19}
($y,$z) = ("not ok 18 - $purpose\n", 1);
d105 1
d107 1
a107 2
$purpose = 'goto a for(;;) loop, from inside (does initializer)';
FORL2: for($y="ok 19 - $purpose\n"; 1;) {
d112 1
a112 1
  ($y, $z) = ("not ok 19 - $purpose\n", 1);
d118 1
a118 1
$purpose = 'works correctly within a try block';
d125 1
a125 1
print ($ok&&!$@@ ? "ok 20" : "not ok 20", " - $purpose\n");
d128 2
a129 1
$purpose = 'works correctly within an eval string';
d136 1
a136 1
print ($ok&&!$@@ ? "ok" : "not ok", " 21 - $purpose\n");
a139 1
$purpose = 'works correctly in a nested eval string';
d152 1
a152 1
print ($ok ? "ok" : "not ok", " 22 - $purpose\n");
d244 1
a244 1
goto moretests;
d248 1
a248 2
$purpose = 'eval "goto $x"';
print "ok 5 - $purpose\n";
a253 1
    $purpose = 'autoloading mechanism.';
d255 2
a256 2
	? "ok 7 - $purpose\n"
	: "not ok 7 - $purpose\n";
a269 1
$purpose = 'goto NOWHERE sets $@@';
d272 1
a272 2
print $@@ =~ /Can't find label NOWHERE/
 ? "ok 8 - $purpose\n" : "not ok 8 - $purpose\n"; #'
a292 116

moretests:
# test goto duplicated labels.
{
    my $z = 0;
    $purpose = "catch goto middle of foreach";
    eval {
	$z = 0;
	for (0..1) {
	  L4: # not outer scope
	    $z += 10;
	    last;
	}
	goto L4 if $z == 10;
	last;
    };
    print ($@@ =~ /Can't "goto" into the middle of a foreach loop/ #'
	   ? "ok" : "not ok", " 34 - $purpose\n");    

    $z = 0;
    # ambiguous label resolution (outer scope means endless loop!)
    $purpose = "prefer same scope (loop body) to outer scope (loop entry)";
  L1:
    for my $x (0..1) {
	$z += 10;
	print $z == 10 ? "" : "not ", "ok 35 - $purpose\n";
	goto L1 unless $x;
	$z += 10;
      L1:
	print $z == 10 ? "" : "not ", "ok 36 - $purpose\n";
	last;
    }

    $purpose = "prefer this scope (block body) to outer scope (block entry)";
    $z = 0;
  L2: 
    { 
	$z += 10;
	print $z == 10 ? "" : "not ", "ok 37 - $purpose\n";
	goto L2 if $z == 10;
	$z += 10;
      L2:
	print $z == 10 ? "" : "not ", "ok 38 - $purpose\n";
    }


    { 
	$purpose = "prefer this scope to inner scope";
	$z = 0;
	while (1) {
	  L3: # not inner scope
	    $z += 10;
	    last;
	}
	print $z == 10 ? "": "not ", "ok 39 - $purpose\n";
	goto L3 if $z == 10;
	$z += 10;
      L3: # this scope !
	print $z == 10 ? "" : "not ", "ok 40 - $purpose\n";
    }

  L4: # not outer scope
    { 
	$purpose = "prefer this scope to inner,outer scopes";
	$z = 0;
	while (1) {
	  L4: # not inner scope
	    $z += 1;
	    last;
	}
	print $z == 1 ? "": "not ", "ok 41 - $purpose\n";
	goto L4 if $z == 1;
	$z += 10;
      L4: # this scope !
	print $z == 1 ? "": "not ", "ok 42 - $purpose\n";
    }

    {
	$purpose = "same label, multiple times in same scope (choose 1st)";
	my $tnum = 43;
	my $loop;
	for $x (0..1) { 
	  L2: # without this, fails 1 (middle) out of 3 iterations
	    $z = 0;
	  L2: 
	    $z += 10;
	    print $z == 10 ? "": "not ", "ok $tnum - $purpose\n";
	    $tnum++;
	    goto L2 if $z == 10 and not $loop++;
	}
    }
}

# deep recursion with gotos eventually caused a stack reallocation
# which messed up buggy internals that didn't expect the stack to move

sub recurse1 {
    unshift @@_, "x";
    goto &recurse2;
}
sub recurse2 {
    $x = shift;
    $_[0] ? +1 + recurse1($_[0] - 1) : 0
}
print "not " unless recurse1(500) == 500;
print "ok 46 - recursive goto &foo\n";

# [perl #32039] Chained goto &sub drops data too early. 

sub a32039 { @@_=("foo"); goto &b32039; }
sub b32039 { goto &c32039; }
sub c32039 { print $_[0] eq 'foo' ? "" : "not ", "ok 47 - chained &goto\n" }
a32039();



@


1.1.1.8
log
@perl 5.8.8 import
@
text
@a7 1
    require "test.pl";
d10 5
a14 3
use warnings;
use strict;
plan tests => 57;
a15 1
our $foo;
d33 2
a34 1
is($foo, 2, 'escape while loop');
d38 2
a39 1
is($foo, 4, 'second escape while loop');
d41 5
a45 2
my $r = run_perl(prog => 'goto foo;', stderr => 1);
like($r, qr/label/, 'cant find label');
a46 1
my $ok = 0;
d49 1
d52 1
a52 1
    $ok = 1;
a55 1
ok($ok, 'goto in sub');
d58 1
a58 1
    my $x = 'bypass';
d66 1
a66 1
is(curr_test(), 16, 'FINALE');
d69 1
a71 1
my $count = 0;
d81 1
a81 2
	is($count, 0, 'OTHER');
	$count++;
d86 1
a86 2
	is($count, 1, 'THIRD');
	$count++;
d89 1
a89 1
is($count, 2, 'end of loop');
d94 1
d98 1
a98 1
  label: is($x, 1, 'goto inside a for(;;) loop body from inside the body');
d104 1
d106 2
a107 4
FORL1: for ($y=1; $z;) {
    ok($y, 'goto a for(;;) loop, from outside (does initializer)');
    goto TEST19}
($y,$z) = (0, 1);
d112 2
a113 1
FORL2: for($y=1; 1;) {
d115 1
a115 1
    ok($y, 'goto a for(;;) loop, from inside (does initializer)');
d118 1
a118 1
  ($y, $z) = (0, 1);
d123 3
a125 2
#  (BUG ID 20000313.004) - [perl #2359]
$ok = 0;
d131 1
a131 2
ok($ok, 'works correctly within a try block');
is($@@, "", '...and $@@ not set');
d134 1
d141 1
a141 2
ok($ok, 'works correctly within an eval string');
is($@@, "", '...and $@@ still not set');
d145 1
d158 1
a158 1
ok($ok, 'works correctly in a nested eval string');
a161 1
    my $count;
d165 2
a166 1
    ok($ok, '#20357 goto inside /{ } continue { }/ loop');
d170 3
a172 1
    ok($ok, '#20154 goto inside /do { } while ()/ loop');
d175 2
a176 1
    ok($ok, 'goto inside /foreach () { } continue { }/ loop');
d181 1
a181 1
	goto B unless $count++;
d184 2
a185 1
    ok($ok, '#19061 loop label wiped away by goto');
a187 1
    my $p;
d189 2
a190 1
    ok($ok, 'weird case of goto and for(;;) loop');
d197 1
a197 1
    goto sub { $x=0; ok(1,"don't prematurely free CV\n") }
d204 1
a204 2
undef $ok;
for ($count=0; $count<2; $count++) {
d208 1
a208 1
    $ok = $x;
d210 1
a210 1
is($ok, 1, 'goto in for(;;) with continuation');
d224 2
a225 1
$r = runperl(prog => 'use goto01; print qq[DONE\n]');
a229 2
$ok = 1;
$count = 0;
d231 1
a231 1
    $count++;
d235 2
a236 5
$ok = 0;

returned_label:
is($count, 1, 'called i_return_a_label');
ok($ok, 'skipped to returned_label');
d242 1
a242 1
$r = runperl(
d247 2
a248 1
is($r, "ok\n", 'avoid pad without an @@_');
a250 1
fail('goto moretests');
d254 2
a255 2

is(curr_test(), 5, 'eval "goto $x"');
d260 5
a264 3
    my ($pack, $file, $line) = caller;	# Should indicate original call stats.
    is("@@_ $pack $file $line", "1 2 3 main $::FILE $::LINE",
	'autoloading mechanism.');
d269 1
a269 2
    no warnings 'redefine';
    sub one { pass('sub one'); goto &two; fail('sub one tail'); }
d274 2
a275 2
$::FILE = __FILE__;
$::LINE = __LINE__ + 1;
d278 5
a282 5
{
    my $wherever = 'NOWHERE';
    eval { goto $wherever };
    like($@@, qr/Can't find label NOWHERE/, 'goto NOWHERE sets $@@');
}
a285 1
  my $i;
d287 2
a288 2
  sub DESTROY	{ my $s = shift; ::is($s->[0], $i, "destroy $i"); }
  sub show	{ ::is(+@@_, 5, "show $i",); }
d290 1
a290 1
  for (1..3)	{ $i = $_; start(bless([$_]), 'bar'); }
d297 1
a297 1
sub AUTOLOAD { $ok = 1 if "@@_" eq "foo" }
d299 1
a299 3
$ok = 0;
auto("foo");
ok($ok, 'autoload');
d301 2
a302 5
{
    my $wherever = 'FINALE';
    goto $wherever;
}
fail('goto $wherever');
d308 1
d319 2
a320 2
    like($@@, qr/Can't "goto" into the middle of a foreach loop/,
	    'catch goto middle of foreach');
d324 1
d328 1
a328 1
	is($z, 10, 'prefer same scope (loop body) to outer scope (loop entry)');
d332 1
a332 1
	is($z, 10, 'prefer same scope: second');
d336 1
d341 1
a341 1
	is($z, 10, 'prefer this scope (block body) to outer scope (block entry)');
d345 1
a345 1
	is($z, 10, 'prefer this scope: second');
d350 1
d357 1
a357 1
	is($z, 10, 'prefer this scope to inner scope');
d361 1
a361 1
	is($z, 10, 'prefer this scope to inner scope: second');
d366 1
d373 1
a373 1
	is($z, 1, 'prefer this scope to inner,outer scopes');
d377 1
a377 1
	is($z, 1, 'prefer this scope to inner,outer scopes: second');
d381 4
a384 2
	my $loop = 0;
	for my $x (0..1) { 
d389 2
a390 2
	    is($z, 10,
		"same label, multiple times in same scope (choose 1st) $loop");
a400 1
    no warnings 'recursion';
d404 1
a404 1
    my $x = shift;
d407 2
a408 1
is(recurse1(500), 500, 'recursive goto &foo');
d414 1
a414 1
sub c32039 { is($_[0], 'foo', 'chained &goto') }
a416 18
# [perl #35214] next and redo re-entered the loop with the wrong cop,
# causing a subsequent goto to crash

{
    my $r = runperl(
		stderr => 1,
		prog =>
'for ($_=0;$_<3;$_++){A: if($_==1){next} if($_==2){$_++;goto A}}print qq(ok\n)'
    );
    is($r, "ok\n", 'next and goto');

    $r = runperl(
		stderr => 1,
		prog =>
'for ($_=0;$_<3;$_++){A: if($_==1){$_++;redo} if($_==2){$_++;goto A}}print qq(ok\n)'
    );
    is($r, "ok\n", 'redo and goto');
}
a417 1
# goto &foo not allowed in evals
a418 16

sub null { 1 };
eval 'goto &null';
like($@@, qr/Can't goto subroutine from an eval-string/, 'eval string');
eval { goto &null };
like($@@, qr/Can't goto subroutine from an eval-block/, 'eval block');

# [perl #36521] goto &foo in warn handler could defeat recursion avoider

{
    my $r = runperl(
		stderr => 1,
		prog => 'my $d; my $w = sub { return if $d++; warn q(bar)}; local $SIG{__WARN__} = sub { goto &$w; }; warn q(foo);'
    );
    like($r, qr/bar/, "goto &foo in warn");
}
@


1.1.1.9
log
@import perl 5.10.0 from CPAN
@
text
@d13 1
a13 2
plan tests => 58;
our $TODO;
a448 12

TODO: {
    local $TODO = "[perl #43403] goto() from an if to an else doesn't undo local () changes";
    our $global = "unmodified";
    if ($global) { # true but not constant-folded
         local $global = "modified";
         goto ELSE;
    } else {
         ELSE: is($global, "unmodified");
    }
}

@


1.1.1.10
log
@import perl 5.10.1
@
text
@d208 1
a208 1
open my $f, ">Op_goto01.pm" or die;
d218 1
a218 1
$r = runperl(prog => 'use Op_goto01; print qq[DONE\n]');
d220 1
a220 1
unlink "Op_goto01.pm";
@


1.1.1.11
log
@Perl 5.12.2 from CPAN
@
text
@d13 1
a13 1
plan tests => 67;
a15 3
my $deprecated = 0;
local $SIG{__WARN__} = sub { if ($_[0] =~ m/jump into a construct/) { $deprecated++; } else { warn $_[0] } };

a19 2
    is($deprecated, 1);
    $deprecated = 0;
a25 2
    is($deprecated, 1);
    $deprecated = 0;
a28 1
is($deprecated, 0);
a34 1
is($deprecated, 0);
d63 1
a63 1
is(curr_test(), 20, 'FINALE');
a176 1
    is($deprecated, 0);
a178 2
    is($deprecated, 1);
    $deprecated = 0;
a183 2
    is($deprecated, 1);
    $deprecated = 0;
d253 1
a253 1
is(curr_test(), 9, 'eval "goto $x"');
a461 10
is($deprecated, 0);

#74290
{
    my $x;
    my $y;
    F1:++$x and eval 'return if ++$y == 10; goto F1;';
    is($x, 10,
       'labels outside evals can be distinguished from the start of the eval');
}
@


1.1.1.12
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d13 1
a13 1
plan tests => 80;
a207 11
# bug #99850, which is similar - freeing the subroutine we are about to
# go(in)to during a FREETMPS call should not crash perl.

package _99850 {
    sub reftype{}
    DESTROY { undef &reftype }
    eval { sub { my $guard = bless []; goto &reftype }->() };
}
like $@@, qr/^Goto undefined subroutine &_99850::reftype at /,
   'goto &foo undefining &foo on sub cleanup';

d234 1
a234 1
unlink_all "Op_goto01.pm";
a417 2
my $w = 0;
$SIG{__WARN__} = sub { ++$w };
a418 2
is $w, 0, 'no recursion warnings for "no warnings; goto &sub"';
delete $SIG{__WARN__};
a485 138

goto wham_eth;
die "You can't get here";

wham_eth: 1 if 0;
ouch_eth: pass('labels persist even if their statement is optimised away');

$foo = "(0)";
if($foo eq $foo) {
    goto bungo;
}
$foo .= "(9)";
bungo:
format CHOLET =
wellington
.
$foo .= "(1)";
SKIP: {
    skip_if_miniperl("no dynamic loading on miniperl, so can't load PerlIO::scalar", 1);
    my $cholet;
    open(CHOLET, ">", \$cholet);
    write CHOLET;
    close CHOLET;
    $foo .= "(".$cholet.")";
    is($foo, "(0)(1)(wellington\n)", "label before format decl");
}

$foo = "(A)";
if($foo eq $foo) {
    goto orinoco;
}
$foo .= "(X)";
orinoco:
sub alderney { return "tobermory"; }
$foo .= "(B)";
$foo .= "(".alderney().")";
is($foo, "(A)(B)(tobermory)", "label before sub decl");

$foo = "[0:".__PACKAGE__."]";
if($foo eq $foo) {
    goto bulgaria;
}
$foo .= "[9]";
bulgaria:
package Tomsk;
$foo .= "[1:".__PACKAGE__."]";
$foo .= "[2:".__PACKAGE__."]";
package main;
$foo .= "[3:".__PACKAGE__."]";
is($foo, "[0:main][1:Tomsk][2:Tomsk][3:main]", "label before package decl");

$foo = "[A:".__PACKAGE__."]";
if($foo eq $foo) {
    goto adelaide;
}
$foo .= "[Z]";
adelaide:
package Cairngorm {
    $foo .= "[B:".__PACKAGE__."]";
}
$foo .= "[C:".__PACKAGE__."]";
is($foo, "[A:main][B:Cairngorm][C:main]", "label before package block");

our $obidos;
$foo = "{0}";
if($foo eq $foo) {
    goto shansi;
}
$foo .= "{9}";
shansi:
BEGIN { $obidos = "x"; }
$foo .= "{1$obidos}";
is($foo, "{0}{1x}", "label before BEGIN block");

$foo = "{A:".(1.5+1.5)."}";
if($foo eq $foo) {
    goto stepney;
}
$foo .= "{Z}";
stepney:
use integer;
$foo .= "{B:".(1.5+1.5)."}";
is($foo, "{A:3}{B:2}", "label before use decl");

$foo = "<0>";
if($foo eq $foo) {
    goto tom;
}
$foo .= "<9>";
tom: dick: harry:
$foo .= "<1>";
$foo .= "<2>";
is($foo, "<0><1><2>", "first of three stacked labels");

$foo = "<A>";
if($foo eq $foo) {
    goto beta;
}
$foo .= "<Z>";
alpha: beta: gamma:
$foo .= "<B>";
$foo .= "<C>";
is($foo, "<A><B><C>", "second of three stacked labels");

$foo = ",0.";
if($foo eq $foo) {
    goto gimel;
}
$foo .= ",9.";
alef: bet: gimel:
$foo .= ",1.";
$foo .= ",2.";
is($foo, ",0.,1.,2.", "third of three stacked labels");

# [perl #112316] Wrong behavior regarding labels with same prefix
sub same_prefix_labels {
    my $pass;
    my $first_time = 1;
    CATCH: {
        if ( $first_time ) {
            CATCHLOOP: {
                if ( !$first_time ) {
                  return 0;
                }
                $first_time--;
                goto CATCH;
            }
        }
        else {
            return 1;
        }
    }
}

ok(
   same_prefix_labels(),
   "perl 112316: goto and labels with the same prefix doesn't get mixed up"
);
@


1.1.1.13
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d13 1
a13 1
plan tests => 89;
d23 1
a23 1
    is($deprecated, 1, "following label1");
d31 1
a31 1
    is($deprecated, 1, "following label3");
d36 1
a36 1
is($deprecated, 0, "after 'while' loop");
d43 1
a43 1
is($deprecated, 0, "following label2");
d186 1
a186 1
    is($deprecated, 0, "before calling sub a()");
d189 1
a189 1
    is($deprecated, 1, "after calling sub a()");
d196 1
a196 1
    is($deprecated, 1, "following goto and for(;;) loop");
d463 1
a468 16
 
# goto &foo leaves @@_ alone when called from a sub
sub returnarg { $_[0] };
is sub {
    local *_ = ["ick and queasy"];
    goto &returnarg;
}->("quick and easy"), "ick and queasy",
  'goto &foo with *_{ARRAY} replaced';
my @@__ = "\xc4\x80";
sub { local *_ = \@@__; goto &utf8::decode }->("no thinking aloud");
is "@@__", chr 256, 'goto &xsub with replaced *_{ARRAY}';

# And goto &foo should leave reified @@_ alone
sub { *__ = \@@_;  goto &null } -> ("rough and tubbery");
is ${*__}[0], 'rough and tubbery', 'goto &foo leaves reified @@_ alone';

d491 1
a491 1
is($deprecated, 0, "following TODOed test for #43403");
a638 18

eval { my $x = ""; goto $x };
like $@@, qr/^goto must have label at /, 'goto $x where $x is empty string';
eval { goto "" };
like $@@, qr/^goto must have label at /, 'goto ""';
eval { goto };
like $@@, qr/^goto must have label at /, 'argless goto';

eval { my $x = "\0"; goto $x };
like $@@, qr/^Can't find label \0 at /, 'goto $x where $x begins with \0';
eval { goto "\0" };
like $@@, qr/^Can't find label \0 at /, 'goto "\0"';

sub TIESCALAR { bless [pop] }
sub FETCH     { $_[0][0] }
tie my $t, "", sub { "cluck up porridge" };
is eval { sub { goto $t }->() }//$@@, 'cluck up porridge',
  'tied arg returning sub ref';
@


1.1.1.14
log
@Import perl-5.20.1
@
text
@d13 1
a13 1
plan tests => 94;
a482 33

# goto &xsub when @@_ has nonexistent elements
{
    no warnings "uninitialized";
    local @@_ = ();
    $#_++;
    & {sub { goto &utf8::encode }};
    is @@_, 1, 'num of elems in @@_ after goto &xsub with nonexistent $_[0]';
    is $_[0], "", 'content of nonexistent $_[0] is modified by goto &xsub';
}

# goto &xsub when @@_ itself does not exist
undef *_;
eval { & { sub { goto &utf8::encode } } };
# The main thing we are testing is that it did not crash.  But make sure 
# *_{ARRAY} was untouched, too.
is *_{ARRAY}, undef, 'goto &xsub when @@_ does not exist';

# goto &perlsub when @@_ itself does not exist [perl #119949]
# This was only crashing when the replaced sub call had an argument list.
# (I.e., &{ sub { goto ... } } did not crash.)
sub {
    undef *_;
    goto sub {
	is *_{ARRAY}, undef, 'goto &perlsub when @@_ does not exist';
    }
}->();
sub {
    local *_;
    goto sub {
	is *_{ARRAY}, undef, 'goto &sub when @@_ does not exist (local *_)';
    }
}->();
@


1.1.1.15
log
@Import perl-5.24.2
@
text
@d8 1
a8 1
    require "./test.pl"; require './charset_tools.pl';
d13 1
a13 1
plan tests => 98;
a218 40
# When croaking after discovering that the new CV you're about to goto is
# undef, make sure that the old CV isn't doubly freed.

package Do_undef {
    my $count;

    # creating a new closure here encourages any prematurely freed
    # CV to be reallocated
    sub DESTROY { undef &undef_sub; my $x = sub { $count } }

    sub f {
        $count++;
        my $guard = bless []; # trigger DESTROY during goto
        *undef_sub = sub {};
        goto &undef_sub
    }

    for (1..10) {
        eval { f() };
    }
    ::is($count, 10, "goto undef_sub safe");
}

# make sure that nothing nasty happens if the old CV is freed while
# goto'ing

package Free_cv {
    my $results;
    sub f {
        no warnings 'redefine';
        *f = sub {};
        goto &g;
    }
    sub g { $results = "(@@_)" }

    f(1,2,3);
    ::is($results, "(1 2 3)", "Free_cv");
}


a416 32
# This bug was introduced in Aug 2010 by commit ac56e7de46621c6f
# Peephole optimise adjacent pairs of nextstate ops.
# and fixed in Oct 2014 by commit f5b5c2a37af87535
# Simplify double-nextstate optimisation

# The bug manifests as a warning
# Use of "goto" to jump into a construct is deprecated at t/op/goto.t line 442.
# and $out is undefined. Devel::Peek reveals that the lexical in the pad has
# been reset to undef. I infer that pp_goto thinks that it's leaving one scope
# and entering another, but I don't know *why* it thinks that. Whilst this bug
# has been fixed by Father C, because I don't understand why it happened, I am
# not confident that other related bugs remain (or have always existed).

sub DEBUG_TIME() {
    0;
}

{
    if (DEBUG_TIME) {
    }

    {
        my $out = "";
        $out .= 'perl rules';
        goto no_list;
    no_list:
        is($out, 'perl rules', '$out has not been erroneously reset to undef');
    };
}

is($deprecated, 0, 'no warning was emmitted');

d476 1
a476 1
my @@__ = byte_utf8a_to_utf8n("\xc4\x80");
@


