head	1.9;
access;
symbols
	OPENBSD_6_1:1.9.0.14
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.12
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.6
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.9.0.8
	OPENBSD_5_8_BASE:1.9
	PERL_5_20_2:1.1.1.8
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	PERL_5_20_1:1.1.1.8
	OPENBSD_5_6:1.9.0.4
	OPENBSD_5_6_BASE:1.9
	PERL_5_18_2:1.1.1.8
	PERL:1.1.1
	OPENBSD_5_5:1.8.0.6
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	PERL_5_16_3:1.1.1.7
	OPENBSD_5_3:1.7.0.10
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.8
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.6
	OPENBSD_5_0:1.7.0.4
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.2
	OPENBSD_4_9_BASE:1.7
	PERL_5_12_2:1.1.1.6
	OPENBSD_4_8:1.6.0.4
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.2
	OPENBSD_4_7_BASE:1.6
	PERL_5_10_1:1.1.1.5
	OPENBSD_4_6:1.5.0.24
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.20
	OPENBSD_4_5_BASE:1.5
	PERL_5_10_0:1.1.1.4
	OPENBSD_4_4:1.5.0.18
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.16
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.14
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.12
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.10
	OPENBSD_4_0_BASE:1.5
	PERL_5_8_8:1.1.1.4
	OPENBSD_3_9:1.5.0.8
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.6
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.4
	OPENBSD_3_7_BASE:1.5
	PERL_5_8_6:1.1.1.4
	OPENBSD_3_6:1.5.0.2
	OPENBSD_3_6_BASE:1.5
	PERL_5_8_5:1.1.1.4
	PERL_5_8_3:1.1.1.3
	OPENBSD_3_5:1.4.0.6
	OPENBSD_3_5_BASE:1.4
	PERL_5_8_2:1.1.1.3
	OPENBSD_3_4:1.4.0.4
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.4.0.2
	OPENBSD_3_3_BASE:1.4
	PERL_5_8_0:1.1.1.3
	OPENBSD_3_2:1.3.0.12
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.10
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.8
	OPENBSD_3_0_BASE:1.3
	PERL_5_6_1:1.1.1.2
	OPENBSD_2_9:1.3.0.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	PERL_500503:1.1.1.1
	CPAN:1.1.1
	OPENBSD_2_5:1.1.0.6
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.4
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.2
	OPENBSD_2_3_BASE:1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.9
date	2014.03.24.15.05.33;	author afresh1;	state Exp;
branches;
next	1.8;

1.8
date	2013.03.25.20.41.00;	author sthen;	state Exp;
branches;
next	1.7;

1.7
date	2010.09.24.15.07.09;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2009.10.12.18.30.28;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2004.08.09.18.10.27;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2002.10.27.22.25.37;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.06.17.08.33;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	99.04.29.22.52.39;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	97.11.30.08.05.46;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.29.22.41.52;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.04.06.16.10.52;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.10.27.22.15.11;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.08.09.17.48.36;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2009.10.12.18.10.44;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2010.09.24.14.49.18;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2013.03.25.20.09.37;	author sthen;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2014.03.24.14.59.11;	author afresh1;	state Exp;
branches;
next	;


desc
@perl 5.004_04
@


1.9
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@#!./perl

BEGIN {
  chdir 't' if -d 't';
  @@INC = '../lib';
  require './test.pl';
}

plan tests => 48;

open(I, 'op/sysio.t') || die "sysio.t: cannot find myself: $!";

$reopen = ($^O eq 'VMS' ||
           $^O eq 'os2' ||
           $^O eq 'MSWin32' ||
           $^O eq 'NetWare' ||
           $^O eq 'dos');

$x = 'abc';

# should not be able to do negative lengths
eval { sysread(I, $x, -1) };
like($@@, qr/^Negative length /);

# $x should be intact
is($x, 'abc');

# should not be able to read before the buffer
eval { sysread(I, $x, 1, -4) };
like($@@, qr/^Offset outside string /);

# $x should be intact
is($x, 'abc');

$a ='0123456789';

# default offset 0
is(sysread(I, $a, 3), 3);

# $a should be as follows
is($a, '#!.');

# reading past the buffer should zero pad
is(sysread(I, $a, 2, 5), 2);

# the zero pad should be seen now
is($a, "#!.\0\0/p");

# try changing the last two characters of $a
is(sysread(I, $a, 3, -2), 3);

# the last two characters of $a should have changed (into three)
is($a, "#!.\0\0erl");

$outfile = tempfile();

open(O, ">$outfile") || die "sysio.t: cannot write $outfile: $!";

select(O); $|=1; select(STDOUT);

# cannot write negative lengths
eval { syswrite(O, $x, -1) };
like($@@, qr/^Negative length /);

# $x still intact
is($x, 'abc');

# $outfile still intact
ok(!-s $outfile);

# should not be able to write from after the buffer
eval { syswrite(O, $x, 1, 4) };
like($@@, qr/^Offset outside string /);

# $x still intact
is($x, 'abc');

# but it should be ok to write from the end of the buffer
syswrite(O, $x, 0, 3);
syswrite(O, $x, 1, 3);

# $outfile still intact
if ($reopen) {  # must close file to update EOF marker for stat
  close O; open(O, ">>$outfile") || die "sysio.t: cannot write $outfile: $!";
}
ok(!-s $outfile);

# should not be able to write from before the buffer

eval { syswrite(O, $x, 1, -4) };
like($@@, qr/^Offset outside string /);

# $x still intact
is($x, 'abc');

# $outfile still intact
if ($reopen) {  # must close file to update EOF marker for stat
  close O; open(O, ">>$outfile") || die "sysio.t: cannot write $outfile: $!";
}
ok(!-s $outfile);

# [perl #67912] syswrite prints garbage if called with empty scalar and non-zero offset
eval { my $buf = ''; syswrite(O, $buf, 1, 1) };
like($@@, qr/^Offset outside string /);

# $x still intact
is($x, 'abc');

# $outfile still intact
if ($reopen) {  # must close file to update EOF marker for stat
  close O; open(O, ">>$outfile") || die "sysio.t: cannot write $outfile: $!";
}
ok(!-s $outfile);

eval { my $buf = 'x'; syswrite(O, $buf, 1, 2) };
like($@@, qr/^Offset outside string /);

# $x still intact
is($x, 'abc');

# $outfile still intact
if ($reopen) {  # must close file to update EOF marker for stat
  close O; open(O, ">>$outfile") || die "sysio.t: cannot write $outfile: $!";
}
ok(!-s $outfile);

# default offset 0
if (syswrite(O, $a, 2) == 2){
  pass();
} else {
  diag($!);
  fail();
  # most other tests make no sense after e.g. "No space left on device"
  die $!;
}


# $a still intact
is($a, "#!.\0\0erl");

# $outfile should have grown now
if ($reopen) {  # must close file to update EOF marker for stat
  close O; open(O, ">>$outfile") || die "sysio.t: cannot write $outfile: $!";
}
is(-s $outfile, 2);

# with offset
is(syswrite(O, $a, 2, 5), 2);

# $a still intact
is($a, "#!.\0\0erl");

# $outfile should have grown now
if ($reopen) {  # must close file to update EOF marker for stat
  close O; open(O, ">>$outfile") || die "sysio.t: cannot write $outfile: $!";
}
is(-s $outfile, 4);

# with negative offset and a bit too much length
is(syswrite(O, $a, 5, -3), 3);

# $a still intact
is($a, "#!.\0\0erl");

# $outfile should have grown now
if ($reopen) {  # must close file to update EOF marker for stat
  close O; open(O, ">>$outfile") || die "sysio.t: cannot write $outfile: $!";
}
is(-s $outfile, 7);

# with implicit length argument
is(syswrite(O, $x), 3);

# $a still intact
is($x, "abc");

# $outfile should have grown now
if ($reopen) {  # must close file to update EOF marker for stat
  close O; open(O, ">>$outfile") || die "sysio.t: cannot write $outfile: $!";
}
is(-s $outfile, 10);

close(O);

open(I, $outfile) || die "sysio.t: cannot read $outfile: $!";

$b = 'xyz';

# reading too much only return as much as available
is(sysread(I, $b, 100), 10);

# this we should have
is($b, '#!ererlabc');

# test sysseek

is(sysseek(I, 2, 0), 2);
sysread(I, $b, 3);
is($b, 'ere');

is(sysseek(I, -2, 1), 3);
sysread(I, $b, 4);
is($b, 'rerl');

ok(sysseek(I, 0, 0) eq '0 but true');

ok(not defined sysseek(I, -1, 1));

close(I);

unlink_all $outfile;

# Check that utf8 IO doesn't upgrade the scalar
open(I, ">$outfile") || die "sysio.t: cannot write $outfile: $!";
# Will skip harmlessly on stdioperl
eval {binmode STDOUT, ":utf8"};
die $@@ if $@@ and $@@ !~ /^IO layers \(like ':utf8'\) unavailable/;

# y diaresis is \w when UTF8
$a = chr 255;

unlike($a, qr/\w/);

syswrite I, $a;

# Should not be upgraded as a side effect of syswrite.
unlike($a, qr/\w/);

# This should work
eval {syswrite I, 2;};
is($@@, '');

close(I);
unlink_all $outfile;

chdir('..');

1;

# eof
@


1.8
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d17 1
a17 2
           $^O eq 'dos' ||
	   $^O eq 'mpeix');
@


1.7
log
@merge in perl 5.12.2 plus local changes
@
text
@d4 3
a6 3
  chdir('op') || chdir('t/op') || die "sysio.t: cannot look for myself: $!";
  @@INC = '../../lib';
  require '../test.pl';
d11 1
a11 1
open(I, 'sysio.t') || die "sysio.t: cannot find myself: $!";
d212 1
a212 1
unlink $outfile;
d235 1
a235 1
unlink $outfile;
@


1.6
log
@Merge in perl 5.10.1; part two
@
text
@d3 5
a7 1
print "1..42\n";
d9 1
a9 3
chdir('op') || chdir('t/op') || die "sysio.t: cannot look for myself: $!";
@@INC = '../../lib';
require '../test.pl';
d24 1
a24 2
print 'not ' unless ($@@ =~ /^Negative length /);
print "ok 1\n";
d27 1
a27 2
print 'not ' unless ($x eq 'abc');
print "ok 2\n";
d31 1
a31 2
print 'not ' unless ($x eq 'abc');
print "ok 3\n";
d34 1
a34 2
print 'not ' unless ($x eq 'abc');
print "ok 4\n";
d39 1
a39 2
print 'not ' unless(sysread(I, $a, 3) == 3);
print "ok 5\n";
d42 1
a42 2
print 'not ' unless ($a eq '#!.');
print "ok 6\n";
d45 1
a45 2
print 'not ' unless(sysread(I, $a, 2, 5) == 2);
print "ok 7\n";
d48 1
a48 2
print 'not ' unless ($a eq "#!.\0\0/p");
print "ok 8\n";
d51 1
a51 2
print 'not ' unless(sysread(I, $a, 3, -2) == 3);
print "ok 9\n";
d54 1
a54 2
print 'not ' unless ($a eq "#!.\0\0erl");
print "ok 10\n";
d64 1
a64 2
print 'not ' unless ($@@ =~ /^Negative length /);
print "ok 11\n";
d67 1
a67 2
print 'not ' unless ($x eq 'abc');
print "ok 12\n";
d70 1
a70 2
print 'not ' if (-s $outfile);
print "ok 13\n";
d73 2
a74 3
eval { syswrite(O, $x, 1, 3) };
print 'not ' unless ($@@ =~ /^Offset outside string /);
print "ok 14\n";
d77 5
a81 2
print 'not ' unless ($x eq 'abc');
print "ok 15\n";
d87 1
a87 2
print 'not ' if (-s $outfile);
print "ok 16\n";
d92 14
a105 2
print 'not ' unless ($@@ =~ /^Offset outside string /);
print "ok 17\n";
d108 1
a108 2
print 'not ' unless ($x eq 'abc');
print "ok 18\n";
d114 13
a126 2
print 'not ' if (-s $outfile);
print "ok 19\n";
d130 1
a130 1
  print "ok 20\n";
d132 2
a133 1
  print "# $!\nnot ok 20\n";
d140 1
a140 2
print 'not ' unless ($a eq "#!.\0\0erl");
print "ok 21\n";
d146 1
a146 2
print 'not ' unless (-s $outfile == 2);
print "ok 22\n";
d149 1
a149 2
print 'not ' unless (syswrite(O, $a, 2, 5) == 2);
print "ok 23\n";
d152 1
a152 2
print 'not ' unless ($a eq "#!.\0\0erl");
print "ok 24\n";
d158 1
a158 2
print 'not ' unless (-s $outfile == 4);
print "ok 25\n";
d161 1
a161 2
print 'not ' unless (syswrite(O, $a, 5, -3) == 3);
print "ok 26\n";
d164 1
a164 2
print 'not ' unless ($a eq "#!.\0\0erl");
print "ok 27\n";
d170 1
a170 2
print 'not ' unless (-s $outfile == 7);
print "ok 28\n";
d173 1
a173 2
print 'not ' unless (syswrite(O, $x) == 3);
print "ok 29\n";
d176 1
a176 2
print 'not ' unless ($x eq "abc");
print "ok 30\n";
d182 1
a182 2
print 'not ' unless (-s $outfile == 10);
print "ok 31\n";
d191 2
a192 2
print 'not ' unless (sysread(I, $b, 100) == 10);
print "ok 32\n";
d194 1
a194 2
print 'not ' unless ($b eq '#!ererlabc');
print "ok 33\n";
d198 1
a198 2
print 'not ' unless sysseek(I, 2, 0) == 2;
print "ok 34\n";
d200 1
a200 2
print 'not ' unless $b eq 'ere';
print "ok 35\n";
d202 1
a202 2
print 'not ' unless sysseek(I, -2, 1) == 3;
print "ok 36\n";
d204 3
a206 2
print 'not ' unless $b eq 'rerl';
print "ok 37\n";
d208 1
a208 4
print 'not ' unless sysseek(I, 0, 0) eq '0 but true';
print "ok 38\n";
print 'not ' if defined sysseek(I, -1, 1);
print "ok 39\n";
d223 1
a223 1
print $a =~ /\w/ ? "not ok 40\n" : "ok 40\n";
d228 1
a228 1
print $a =~ /\w/ ? "not ok 41\n" : "ok 41\n";
d232 1
a232 1
print $@@ eq "" ? "ok 42\n" : "not ok 42 # $@@";
@


1.5
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d7 1
d64 1
a64 1
$outfile = 'sysio.out';
@


1.4
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d3 1
a3 1
print "1..39\n";
d6 1
d215 23
@


1.3
log
@perl-5.6.0 + local changes
@
text
@d9 5
a13 1
$reopen = ($^O eq 'VMS' || $^O eq 'os2' || $^O eq 'MSWin32' || $^O eq 'dos' ||
d115 8
a122 2
print 'not ' unless (syswrite(O, $a, 2) == 2);
print "ok 20\n";
d216 1
a216 1
chdir('..'); 
@


1.2
log
@perl5.005_03 (stock)
@
text
@d5 1
a5 1
chdir('op') || die "sysio.t: cannot look for myself: $!";
@


1.1
log
@perl 5.004_04
@
text
@d3 1
a3 1
print "1..36\n";
d9 2
a10 1
$reopen = ($^O eq 'VMS' || $^O eq 'os2' || $^O eq 'MSWin32');
d155 15
d177 2
a178 2
print 'not ' unless (sysread(I, $b, 100) == 7);
print "ok 29\n";
d180 2
a181 2
print 'not ' unless ($b eq '#!ererl');
print "ok 30\n";
d186 1
a186 1
print "ok 31\n";
d189 1
a189 1
print "ok 32\n";
d192 1
a192 1
print "ok 33\n";
d195 1
a195 1
print "ok 34\n";
d198 1
a198 1
print "ok 35\n";
d200 1
a200 1
print "ok 36\n";
@


1.1.1.1
log
@perl5.005_03
@
text
@d3 1
a3 1
print "1..39\n";
d9 1
a9 2
$reopen = ($^O eq 'VMS' || $^O eq 'os2' || $^O eq 'MSWin32' || $^O eq 'dos' ||
	   $^O eq 'mpeix');
a153 15
# with implicit length argument
print 'not ' unless (syswrite(O, $x) == 3);
print "ok 29\n";

# $a still intact
print 'not ' unless ($x eq "abc");
print "ok 30\n";

# $outfile should have grown now
if ($reopen) {  # must close file to update EOF marker for stat
  close O; open(O, ">>$outfile") || die "sysio.t: cannot write $outfile: $!";
}
print 'not ' unless (-s $outfile == 10);
print "ok 31\n";

d161 2
a162 2
print 'not ' unless (sysread(I, $b, 100) == 10);
print "ok 32\n";
d164 2
a165 2
print 'not ' unless ($b eq '#!ererlabc');
print "ok 33\n";
d170 1
a170 1
print "ok 34\n";
d173 1
a173 1
print "ok 35\n";
d176 1
a176 1
print "ok 36\n";
d179 1
a179 1
print "ok 37\n";
d182 1
a182 1
print "ok 38\n";
d184 1
a184 1
print "ok 39\n";
@


1.1.1.2
log
@virgin perl 5.6.0
@
text
@d5 1
a5 1
chdir('op') || chdir('t/op') || die "sysio.t: cannot look for myself: $!";
@


1.1.1.3
log
@stock perl 5.8.0 from CPAN
@
text
@d9 1
a9 5
$reopen = ($^O eq 'VMS' ||
           $^O eq 'os2' ||
           $^O eq 'MSWin32' ||
           $^O eq 'NetWare' ||
           $^O eq 'dos' ||
d111 2
a112 8
if (syswrite(O, $a, 2) == 2){
  print "ok 20\n";
} else {
  print "# $!\nnot ok 20\n";
  # most other tests make no sense after e.g. "No space left on device"
  die $!;
}

d206 1
a206 1
chdir('..');
@


1.1.1.4
log
@Import of stock perl 5.8.5
@
text
@d3 1
a3 1
print "1..42\n";
a5 1
@@INC = '../../lib';
a213 23
unlink $outfile;

# Check that utf8 IO doesn't upgrade the scalar
open(I, ">$outfile") || die "sysio.t: cannot write $outfile: $!";
# Will skip harmlessly on stdioperl
eval {binmode STDOUT, ":utf8"};
die $@@ if $@@ and $@@ !~ /^IO layers \(like ':utf8'\) unavailable/;

# y diaresis is \w when UTF8
$a = chr 255;

print $a =~ /\w/ ? "not ok 40\n" : "ok 40\n";

syswrite I, $a;

# Should not be upgraded as a side effect of syswrite.
print $a =~ /\w/ ? "not ok 41\n" : "ok 41\n";

# This should work
eval {syswrite I, 2;};
print $@@ eq "" ? "ok 42\n" : "not ok 42 # $@@";

close(I);
@


1.1.1.5
log
@import perl 5.10.1
@
text
@a6 1
require '../test.pl';
d63 1
a63 1
$outfile = tempfile();
@


1.1.1.6
log
@Perl 5.12.2 from CPAN
@
text
@d3 1
a3 5
BEGIN {
  chdir('op') || chdir('t/op') || die "sysio.t: cannot look for myself: $!";
  @@INC = '../../lib';
  require '../test.pl';
}
d5 3
a7 1
plan tests => 48;
d22 2
a23 1
like($@@, qr/^Negative length /);
d26 2
a27 1
is($x, 'abc');
d31 2
a32 1
like($@@, qr/^Offset outside string /);
d35 2
a36 1
is($x, 'abc');
d41 2
a42 1
is(sysread(I, $a, 3), 3);
d45 2
a46 1
is($a, '#!.');
d49 2
a50 1
is(sysread(I, $a, 2, 5), 2);
d53 2
a54 1
is($a, "#!.\0\0/p");
d57 2
a58 1
is(sysread(I, $a, 3, -2), 3);
d61 2
a62 1
is($a, "#!.\0\0erl");
d72 2
a73 1
like($@@, qr/^Negative length /);
d76 2
a77 1
is($x, 'abc');
d80 2
a81 1
ok(!-s $outfile);
d84 3
a86 2
eval { syswrite(O, $x, 1, 4) };
like($@@, qr/^Offset outside string /);
d89 2
a90 5
is($x, 'abc');

# but it should be ok to write from the end of the buffer
syswrite(O, $x, 0, 3);
syswrite(O, $x, 1, 3);
d96 2
a97 1
ok(!-s $outfile);
d102 2
a103 14
like($@@, qr/^Offset outside string /);

# $x still intact
is($x, 'abc');

# $outfile still intact
if ($reopen) {  # must close file to update EOF marker for stat
  close O; open(O, ">>$outfile") || die "sysio.t: cannot write $outfile: $!";
}
ok(!-s $outfile);

# [perl #67912] syswrite prints garbage if called with empty scalar and non-zero offset
eval { my $buf = ''; syswrite(O, $buf, 1, 1) };
like($@@, qr/^Offset outside string /);
d106 2
a107 1
is($x, 'abc');
d113 2
a114 13
ok(!-s $outfile);

eval { my $buf = 'x'; syswrite(O, $buf, 1, 2) };
like($@@, qr/^Offset outside string /);

# $x still intact
is($x, 'abc');

# $outfile still intact
if ($reopen) {  # must close file to update EOF marker for stat
  close O; open(O, ">>$outfile") || die "sysio.t: cannot write $outfile: $!";
}
ok(!-s $outfile);
d118 1
a118 1
  pass();
d120 1
a120 2
  diag($!);
  fail();
d127 2
a128 1
is($a, "#!.\0\0erl");
d134 2
a135 1
is(-s $outfile, 2);
d138 2
a139 1
is(syswrite(O, $a, 2, 5), 2);
d142 2
a143 1
is($a, "#!.\0\0erl");
d149 2
a150 1
is(-s $outfile, 4);
d153 2
a154 1
is(syswrite(O, $a, 5, -3), 3);
d157 2
a158 1
is($a, "#!.\0\0erl");
d164 2
a165 1
is(-s $outfile, 7);
d168 2
a169 1
is(syswrite(O, $x), 3);
d172 2
a173 1
is($x, "abc");
d179 2
a180 1
is(-s $outfile, 10);
d189 2
a190 2
is(sysread(I, $b, 100), 10);

d192 2
a193 1
is($b, '#!ererlabc');
d197 2
a198 1
is(sysseek(I, 2, 0), 2);
d200 2
a201 1
is($b, 'ere');
d203 2
a204 1
is(sysseek(I, -2, 1), 3);
d206 2
a207 3
is($b, 'rerl');

ok(sysseek(I, 0, 0) eq '0 but true');
d209 4
a212 1
ok(not defined sysseek(I, -1, 1));
d227 1
a227 1
unlike($a, qr/\w/);
d232 1
a232 1
unlike($a, qr/\w/);
d236 1
a236 1
is($@@, '');
@


1.1.1.7
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d4 3
a6 3
  chdir 't' if -d 't';
  @@INC = '../lib';
  require './test.pl';
d11 1
a11 1
open(I, 'op/sysio.t') || die "sysio.t: cannot find myself: $!";
d212 1
a212 1
unlink_all $outfile;
d235 1
a235 1
unlink_all $outfile;
@


1.1.1.8
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d17 2
a18 1
           $^O eq 'dos');
@


