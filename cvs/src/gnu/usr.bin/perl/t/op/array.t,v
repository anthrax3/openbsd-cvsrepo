head	1.14;
access;
symbols
	OPENBSD_6_2_BASE:1.14
	PERL_5_24_2:1.1.1.13
	OPENBSD_6_1:1.14.0.4
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.13.0.10
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.4
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.13.0.6
	OPENBSD_5_8_BASE:1.13
	PERL_5_20_2:1.1.1.12
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	PERL_5_20_1:1.1.1.12
	OPENBSD_5_6:1.12.0.8
	OPENBSD_5_6_BASE:1.12
	PERL_5_18_2:1.1.1.11
	PERL:1.1.1
	OPENBSD_5_5:1.12.0.6
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.2
	OPENBSD_5_4_BASE:1.12
	PERL_5_16_3:1.1.1.11
	OPENBSD_5_3:1.11.0.10
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.8
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.6
	OPENBSD_5_0:1.11.0.4
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.2
	OPENBSD_4_9_BASE:1.11
	PERL_5_12_2:1.1.1.10
	OPENBSD_4_8:1.10.0.8
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.4
	OPENBSD_4_7_BASE:1.10
	PERL_5_10_1:1.1.1.9
	OPENBSD_4_6:1.10.0.6
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.2
	OPENBSD_4_5_BASE:1.10
	PERL_5_10_0:1.1.1.9
	OPENBSD_4_4:1.9.0.10
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.8
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.6
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.4
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9
	PERL_5_8_8:1.1.1.8
	OPENBSD_3_9:1.8.0.8
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.6
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.4
	OPENBSD_3_7_BASE:1.8
	PERL_5_8_6:1.1.1.7
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	PERL_5_8_5:1.1.1.7
	PERL_5_8_3:1.1.1.6
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.14
date	2017.02.05.00.32.20;	author afresh1;	state Exp;
branches;
next	1.13;
commitid	cxJ08BvJA9Pt2PTM;

1.13
date	2014.11.17.20.57.07;	author afresh1;	state Exp;
branches;
next	1.12;
commitid	QP75iYx42Uo7mMxO;

1.12
date	2013.03.25.20.40.59;	author sthen;	state Exp;
branches;
next	1.11;

1.11
date	2010.09.24.15.07.08;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2008.09.29.17.36.19;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2006.03.28.19.23.12;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2004.08.09.18.10.27;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.48;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.37;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.36.16;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.08.19;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.52.33;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.08.05.13;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.13.16;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.13.16;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.41.42;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.10.47;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.25.33;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.15.10;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.44.31;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.08.09.17.48.34;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2006.03.28.18.49.44;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2008.09.29.17.19.00;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2010.09.24.14.49.17;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2013.03.25.20.09.35;	author sthen;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2014.11.17.20.53.17;	author afresh1;	state Exp;
branches;
next	1.1.1.13;
commitid	B31cAbBIXiCqnL97;

1.1.1.13
date	2017.08.14.13.46.23;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.14
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl

BEGIN {
    chdir 't' if -d 't';
    @@INC = ('.', '../lib');
    require './test.pl';
}

plan (173);

#
# @@foo, @@bar, and @@ary are also used from tie-stdarray after tie-ing them
#

@@ary = (1,2,3,4,5);
is(join('',@@ary), '12345');

$tmp = $ary[$#ary]; --$#ary;
is($tmp, 5);
is($#ary, 3);
is(join('',@@ary), '1234');

@@foo = ();
$r = join(',', $#foo, @@foo);
is($r, "-1");
$foo[0] = '0';
$r = join(',', $#foo, @@foo);
is($r, "0,0");
$foo[2] = '2';
$r = join(',', $#foo, @@foo);
is($r, "2,0,,2");
@@bar = ();
$bar[0] = '0';
$bar[1] = '1';
$r = join(',', $#bar, @@bar);
is($r, "1,0,1");
@@bar = ();
$r = join(',', $#bar, @@bar);
is($r, "-1");
$bar[0] = '0';
$r = join(',', $#bar, @@bar);
is($r, "0,0");
$bar[2] = '2';
$r = join(',', $#bar, @@bar);
is($r, "2,0,,2");
reset 'b' if $^O ne 'VMS';
@@bar = ();
$bar[0] = '0';
$r = join(',', $#bar, @@bar);
is($r, "0,0");
$bar[2] = '2';
$r = join(',', $#bar, @@bar);
is($r, "2,0,,2");

$foo = 'now is the time';
ok(scalar (($F1,$F2,$Etc) = ($foo =~ /^(\S+)\s+(\S+)\s*(.*)/)));
is($F1, 'now');
is($F2, 'is');
is($Etc, 'the time');

$foo = 'lskjdf';
ok(!($cnt = (($F1,$F2,$Etc) = ($foo =~ /^(\S+)\s+(\S+)\s*(.*)/))))
   or diag("$cnt $F1:$F2:$Etc");

%foo = ('blurfl','dyick','foo','bar','etc.','etc.');
%bar = %foo;
is($bar{'foo'}, 'bar');
%bar = ();
is($bar{'foo'}, undef);
(%bar,$a,$b) = (%foo,'how','now');
is($bar{'foo'}, 'bar');
is($bar{'how'}, 'now');
@@bar{keys %foo} = values %foo;
is($bar{'foo'}, 'bar');
is($bar{'how'}, 'now');

@@foo = grep(/e/,split(' ','now is the time for all good men to come to'));
is(join(' ',@@foo), 'the time men come');

@@foo = grep(!/e/,split(' ','now is the time for all good men to come to'));
is(join(' ',@@foo), 'now is for all good to to');

$foo = join('',('a','b','c','d','e','f')[0..5]);
is($foo, 'abcdef');

$foo = join('',('a','b','c','d','e','f')[0..1]);
is($foo, 'ab');

$foo = join('',('a','b','c','d','e','f')[6]);
is($foo, '');

@@foo = ('a','b','c','d','e','f')[0,2,4];
@@bar = ('a','b','c','d','e','f')[1,3,5];
$foo = join('',(@@foo,@@bar)[0..5]);
is($foo, 'acebdf');

$foo = ('a','b','c','d','e','f')[0,2,4];
is($foo, 'e');

$foo = ('a','b','c','d','e','f')[1];
is($foo, 'b');

@@foo = ( 'foo', 'bar', 'burbl', 'blah');

# various AASSIGN_COMMON checks (see newASSIGNOP() in op.c)

#curr_test(37);

@@foo = @@foo;
is("@@foo", "foo bar burbl blah");				# 37

(undef,@@foo) = @@foo;
is("@@foo", "bar burbl blah");					# 38

@@foo = ('XXX',@@foo, 'YYY');
is("@@foo", "XXX bar burbl blah YYY");				# 39

@@foo = @@foo = qw(foo b\a\r bu\\rbl blah);
is("@@foo", 'foo b\a\r bu\\rbl blah');				# 40

@@bar = @@foo = qw(foo bar);					# 41
is("@@foo", "foo bar");
is("@@bar", "foo bar");						# 42

# try the same with local
# XXX tie-stdarray fails the tests involving local, so we use
# different variable names to escape the 'tie'

@@bee = ( 'foo', 'bar', 'burbl', 'blah');
{

    local @@bee = @@bee;
    is("@@bee", "foo bar burbl blah");				# 43
    {
	local (undef,@@bee) = @@bee;
	is("@@bee", "bar burbl blah");				# 44
	{
	    local @@bee = ('XXX',@@bee,'YYY');
	    is("@@bee", "XXX bar burbl blah YYY");		# 45
	    {
		local @@bee = local(@@bee) = qw(foo bar burbl blah);
		is("@@bee", "foo bar burbl blah");		# 46
		{
		    local (@@bim) = local(@@bee) = qw(foo bar);
		    is("@@bee", "foo bar");			# 47
		    is("@@bim", "foo bar");			# 48
		}
		is("@@bee", "foo bar burbl blah");		# 49
	    }
	    is("@@bee", "XXX bar burbl blah YYY");		# 50
	}
	is("@@bee", "bar burbl blah");				# 51
    }
    is("@@bee", "foo bar burbl blah");				# 52
}

# try the same with my
{
    my @@bee = @@bee;
    is("@@bee", "foo bar burbl blah");				# 53
    {
	my (undef,@@bee) = @@bee;
	is("@@bee", "bar burbl blah");				# 54
	{
	    my @@bee = ('XXX',@@bee,'YYY');
	    is("@@bee", "XXX bar burbl blah YYY");		# 55
	    {
		my @@bee = my @@bee = qw(foo bar burbl blah);
		is("@@bee", "foo bar burbl blah");		# 56
		{
		    my (@@bim) = my(@@bee) = qw(foo bar);
		    is("@@bee", "foo bar");			# 57
		    is("@@bim", "foo bar");			# 58
		}
		is("@@bee", "foo bar burbl blah");		# 59
	    }
	    is("@@bee", "XXX bar burbl blah YYY");		# 60
	}
	is("@@bee", "bar burbl blah");				# 61
    }
    is("@@bee", "foo bar burbl blah");				# 62
}

# try the same with our (except that previous values aren't restored)
{
    our @@bee = @@bee;
    is("@@bee", "foo bar burbl blah");
    {
	our (undef,@@bee) = @@bee;
	is("@@bee", "bar burbl blah");
	{
	    our @@bee = ('XXX',@@bee,'YYY');
	    is("@@bee", "XXX bar burbl blah YYY");
	    {
		our @@bee = our @@bee = qw(foo bar burbl blah);
		is("@@bee", "foo bar burbl blah");
		{
		    our (@@bim) = our(@@bee) = qw(foo bar);
		    is("@@bee", "foo bar");
		    is("@@bim", "foo bar");
		}
	    }
	}
    }
}

# make sure reification behaves
my $t = curr_test();
sub reify { $_[1] = $t++; print "@@_\n"; }
reify('ok');
reify('ok');

curr_test($t);

# qw() is no longer a runtime split, it's compiletime.
is (qw(foo bar snorfle)[2], 'snorfle');

@@ary = (12,23,34,45,56);

is(shift(@@ary), 12);
is(pop(@@ary), 56);
is(push(@@ary,56), 4);
is(unshift(@@ary,12), 5);

sub foo { "a" }
@@foo=(foo())[0,0];
is ($foo[1], "a");

# bugid #15439 - clearing an array calls destructors which may try
# to modify the array - caused 'Attempt to free unreferenced scalar'

my $got = runperl (
	prog => q{
		    sub X::DESTROY { @@a = () }
		    @@a = (bless {}, q{X});
		    @@a = ();
		},
	stderr => 1
    );

$got =~ s/\n/ /g;
is ($got, '');

# Test negative and funky indices.


{
    my @@a = 0..4;
    is($a[-1], 4);
    is($a[-2], 3);
    is($a[-5], 0);
    ok(!defined $a[-6]);

    is($a[2.1]  , 2);
    is($a[2.9]  , 2);
    is($a[undef], 0);
    is($a["3rd"], 3);
}


{
    my @@a;
    eval '$a[-1] = 0';
    like($@@, qr/Modification of non-creatable array value attempted, subscript -1/, "\$a[-1] = 0");
}

sub test_arylen {
    my $ref = shift;
    local $^W = 1;
    is ($$ref, undef, "\$# on freed array is undef");
    my @@warn;
    local $SIG{__WARN__} = sub {push @@warn, "@@_"};
    $$ref = 1000;
    is (scalar @@warn, 1);
    like ($warn[0], qr/^Attempt to set length of freed array/);
}

{
    my $a = \$#{[]};
    # Need a new statement to make it go out of scope
    test_arylen ($a);
    test_arylen (do {my @@a; \$#a});
}

{
    use vars '@@array';

    my $outer = \$#array;
    is ($$outer, -1);
    is (scalar @@array, 0);

    $$outer = 3;
    is ($$outer, 3);
    is (scalar @@array, 4);

    my $ref = \@@array;

    my $inner;
    {
	local @@array;
	$inner = \$#array;

	is ($$inner, -1);
	is (scalar @@array, 0);
	$$outer = 6;

	is (scalar @@$ref, 7);

	is ($$inner, -1);
	is (scalar @@array, 0);

	$$inner = 42;
    }

    is (scalar @@array, 7);
    is ($$outer, 6);

    is ($$inner, undef, "orphaned $#foo is always undef");

    is (scalar @@array, 7);
    is ($$outer, 6);

    $$inner = 1;

    is (scalar @@array, 7);
    is ($$outer, 6);

    $$inner = 503; # Bang!

    is (scalar @@array, 7);
    is ($$outer, 6);
}

{
    # Bug #36211
    use vars '@@array';
    for (1,2) {
	{
	    local @@a;
	    is ($#a, -1);
	    @@a=(1..4)
	}
    }
}

{
    # Bug #37350
    my @@array = (1..4);
    $#{@@array} = 7;
    is ($#{4}, 7);

    my $x;
    $#{$x} = 3;
    is(scalar @@$x, 4);

    push @@{@@array}, 23;
    is ($4[8], 23);
}
{
    # Bug #37350 -- once more with a global
    use vars '@@array';
    @@array = (1..4);
    $#{@@array} = 7;
    is ($#{4}, 7);

    my $x;
    $#{$x} = 3;
    is(scalar @@$x, 4);

    push @@{@@array}, 23;
    is ($4[8], 23);
}

# more tests for AASSIGN_COMMON

{
    our($x,$y,$z) = (1..3);
    our($y,$z) = ($x,$y);
    is("$x $y $z", "1 1 2");
}
{
    our($x,$y,$z) = (1..3);
    (our $y, our $z) = ($x,$y);
    is("$x $y $z", "1 1 2");
}
{
    # AASSIGN_COMMON detection with logical operators
    my $true = 1;
    our($x,$y,$z) = (1..3);
    (our $y, our $z) = $true && ($x,$y);
    is("$x $y $z", "1 1 2");
}

# [perl #70171]
{
 my $x = get_x(); my %x = %$x; sub get_x { %x=(1..4); return \%x };
 is(
   join(" ", map +($_,$x{$_}), sort keys %x), "1 2 3 4",
  'bug 70171 (self-assignment via my %x = %$x)'
 );
 my $y = get_y(); my @@y = @@$y; sub get_y { @@y=(1..4); return \@@y };
 is(
  "@@y", "1 2 3 4",
  'bug 70171 (self-assignment via my @@x = @@$x)'
 );
}

# [perl #70171], [perl #82110]
{
    my ($i, $ra, $rh);
  again:
    my @@a = @@$ra; # common assignment on 2nd attempt
    my %h = %$rh; # common assignment on 2nd attempt
    @@a = qw(1 2 3 4);
    %h = qw(a 1 b 2 c 3 d 4);
    $ra = \@@a;
    $rh = \%h;
    goto again unless $i++;

    is("@@a", "1 2 3 4",
	'bug 70171 (self-assignment via my @@x = @@$x) - goto variant'
    );
    is(
	join(" ", map +($_,$h{$_}), sort keys %h), "a 1 b 2 c 3 d 4",
	'bug 70171 (self-assignment via my %x = %$x) - goto variant'
    );
}


*trit = *scile;  $trit[0];
ok(1, 'aelem_fast on a nonexistent array does not crash');

# [perl #107440]
sub A::DESTROY { $::ra = 0 }
$::ra = [ bless [], 'A' ];
undef @@$::ra;
pass 'no crash when freeing array that is being undeffed';
$::ra = [ bless [], 'A' ];
@@$::ra = ('a'..'z');
pass 'no crash when freeing array that is being cleared';

# [perl #85670] Copying magic to elements
SKIP: {
    skip "no Scalar::Util::weaken on miniperl", 1, if is_miniperl;
    require Scalar::Util;
    package glelp {
	Scalar::Util::weaken ($a = \@@ISA);
	@@ISA = qw(Foo);
	Scalar::Util::weaken ($a = \$ISA[0]);
	::is @@ISA, 1, 'backref magic is not copied to elements';
    }
}
package peen {
    $#ISA = -1;
    @@ISA = qw(Foo);
    $ISA[0] = qw(Sphare);

    sub Sphare::pling { 'pling' }

    ::is eval { pling peen }, 'pling',
	'arylen_p magic does not stop isa magic from being copied';
}

# Test that &PL_sv_undef is not special in arrays
sub {
    ok exists $_[0],
      'exists returns true for &PL_sv_undef elem [perl #7508]';
    is \$_[0], \undef, 'undef preserves identity in array [perl #109726]';
}->(undef);
# and that padav also knows how to handle the resulting NULLs
@@_ = sub { my @@a; $a[1]=1; @@a }->();
is join (" ", map $_//"undef", @@_), "undef 1",
  'returning my @@a with nonexistent elements'; 

# [perl #118691]
@@plink=@@plunk=();
$plink[3] = 1;
sub {
    $_[0] = 2;
    is $plink[0], 2, '@@_ alias to nonexistent elem within array';
    $_[1] = 3;
    is $plink[1], 3, '@@_ alias to nonexistent neg index within array';
    is $_[2], undef, 'reading alias to negative index past beginning';
    eval { $_[2] = 42 };
    like $@@, qr/Modification of non-creatable array value attempted, (?x:
               )subscript -5/,
         'error when setting alias to negative index past beginning';
    is $_[3], undef, 'reading alias to -1 elem of empty array';
    eval { $_[3] = 42 };
    like $@@, qr/Modification of non-creatable array value attempted, (?x:
               )subscript -1/,
         'error when setting alias to -1 elem of empty array';
}->($plink[0], $plink[-2], $plink[-5], $plunk[-1]);

$_ = \$#{[]};
$$_ = \1;
"$$_";
pass "no assertion failure after assigning ref to arylen when ary is gone";


{
    # Test aelemfast for both +ve and -ve indices, both lex and package vars.
    # Make especially careful that we don't have any edge cases around
    # fitting an I8 into a U8.
    my @@a = (0..299);
    is($a[-256], 300-256, 'lex -256');
    is($a[-255], 300-255, 'lex -255');
    is($a[-254], 300-254, 'lex -254');
    is($a[-129], 300-129, 'lex -129');
    is($a[-128], 300-128, 'lex -128');
    is($a[-127], 300-127, 'lex -127');
    is($a[-126], 300-126, 'lex -126');
    is($a[  -1], 300-  1, 'lex   -1');
    is($a[   0],       0, 'lex    0');
    is($a[   1],       1, 'lex    1');
    is($a[ 126],     126, 'lex  126');
    is($a[ 127],     127, 'lex  127');
    is($a[ 128],     128, 'lex  128');
    is($a[ 129],     129, 'lex  129');
    is($a[ 254],     254, 'lex  254');
    is($a[ 255],     255, 'lex  255');
    is($a[ 256],     256, 'lex  256');
    @@aelem =(0..299);
    is($aelem[-256], 300-256, 'pkg -256');
    is($aelem[-255], 300-255, 'pkg -255');
    is($aelem[-254], 300-254, 'pkg -254');
    is($aelem[-129], 300-129, 'pkg -129');
    is($aelem[-128], 300-128, 'pkg -128');
    is($aelem[-127], 300-127, 'pkg -127');
    is($aelem[-126], 300-126, 'pkg -126');
    is($aelem[  -1], 300-  1, 'pkg   -1');
    is($aelem[   0],       0, 'pkg    0');
    is($aelem[   1],       1, 'pkg    1');
    is($aelem[ 126],     126, 'pkg  126');
    is($aelem[ 127],     127, 'pkg  127');
    is($aelem[ 128],     128, 'pkg  128');
    is($aelem[ 129],     129, 'pkg  129');
    is($aelem[ 254],     254, 'pkg  254');
    is($aelem[ 255],     255, 'pkg  255');
    is($aelem[ 256],     256, 'pkg  256');
}

# Test aelemfast in list assignment
@@ary = ('a','b');
($ary[0],$ary[1]) = ($ary[1],$ary[0]);
is "@@ary", 'b a',
   'aelemfast with the same array on both sides of list assignment';

for(scalar $#foo) { $_ = 3 }
is $#foo, 3, 'assigning to arylen aliased in foreach(scalar $#arylen)';

{
    my @@a = qw(a b c);
    @@a = @@a;
    is "@@a", 'a b c', 'assigning to itself';
}

"We're included by lib/Tie/Array/std.t so we need to return something true";
@


1.13
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d6 1
a6 1
    require 'test.pl';
d9 1
a9 1
plan (171);
d103 1
a103 6
@@foo = ( 'foo', 'bar', 'burbl');
{
    no warnings 'deprecated';
    push(foo, 'blah');
}
is($#foo, 3);
d107 1
a107 1
#curr_test(38);
d110 1
a110 1
is("@@foo", "foo bar burbl blah");				# 38
d113 1
a113 1
is("@@foo", "bar burbl blah");					# 39
d116 1
a116 1
is("@@foo", "XXX bar burbl blah YYY");				# 40
d119 1
a119 1
is("@@foo", 'foo b\a\r bu\\rbl blah');				# 41
d121 1
a121 1
@@bar = @@foo = qw(foo bar);					# 42
d123 1
a123 1
is("@@bar", "foo bar");						# 43
d133 1
a133 1
    is("@@bee", "foo bar burbl blah");				# 44
d136 1
a136 1
	is("@@bee", "bar burbl blah");				# 45
d139 1
a139 1
	    is("@@bee", "XXX bar burbl blah YYY");		# 46
d142 1
a142 1
		is("@@bee", "foo bar burbl blah");		# 47
d145 2
a146 2
		    is("@@bee", "foo bar");			# 48
		    is("@@bim", "foo bar");			# 49
d148 1
a148 1
		is("@@bee", "foo bar burbl blah");		# 50
d150 1
a150 1
	    is("@@bee", "XXX bar burbl blah YYY");		# 51
d152 1
a152 1
	is("@@bee", "bar burbl blah");				# 52
d154 1
a154 1
    is("@@bee", "foo bar burbl blah");				# 53
d160 1
a160 1
    is("@@bee", "foo bar burbl blah");				# 54
d163 1
a163 1
	is("@@bee", "bar burbl blah");				# 55
d166 1
a166 1
	    is("@@bee", "XXX bar burbl blah YYY");		# 56
d169 1
a169 1
		is("@@bee", "foo bar burbl blah");		# 57
d172 2
a173 2
		    is("@@bee", "foo bar");			# 58
		    is("@@bim", "foo bar");			# 59
d175 1
a175 1
		is("@@bee", "foo bar burbl blah");		# 60
d177 1
a177 1
	    is("@@bee", "XXX bar burbl blah YYY");		# 61
d179 1
a179 1
	is("@@bee", "bar burbl blah");				# 62
d181 1
a181 1
    is("@@bee", "foo bar burbl blah");				# 63
d541 15
@


1.12
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d9 1
a9 1
plan (127);
a22 3
{
    no warnings 'deprecated';

a54 2
}

d469 78
@


1.11
log
@merge in perl 5.12.2 plus local changes
@
text
@d6 1
a8 2
require 'test.pl';

a25 17
$[ = 1;
@@ary = (1,2,3,4,5);
is(join('',@@ary), '12345');

$tmp = $ary[$#ary]; --$#ary;
is($tmp, 5);
# Must do == here beacuse $[ isn't 0
ok($#ary == 4);
is(join('',@@ary), '1234');

is($ary[5], undef);

$#ary += 1;	# see if element 5 gone for good
ok($#ary == 5);
ok(!defined $ary[5]);

$[ = 0;
a238 16
# $[ should have the same effect regardless of whether the aelem
#    op is optimized to aelemfast.



sub tary {
  no warnings 'deprecated';
  local $[ = 10;
  my $five = 5;
  is ($tary[5], $tary[$five]);
}

@@tary = (0..50);
tary();


d245 1
a245 1
		    @@a = (bless {}, 'X');
d396 7
d416 56
@


1.10
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d10 1
a10 1
plan (125);
d24 3
d76 2
d127 4
a130 1
push(foo, 'blah');
d263 1
d429 14
@


1.9
log
@merge in perl 5.8.8
@
text
@d5 1
a5 1
    @@INC = '.', '../lib';
d10 1
a10 1
plan (91);
a178 1

d204 23
d319 105
@


1.8
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d5 1
a5 1
    @@INC = '../lib';
d8 3
a10 1
print "1..82\n";
d17 1
a17 1
if (join('',@@ary) eq '12345') {print "ok 1\n";} else {print "not ok 1\n";}
d20 3
a22 3
if ($tmp == 5) {print "ok 2\n";} else {print "not ok 2\n";}
if ($#ary == 3) {print "ok 3\n";} else {print "not ok 3\n";}
if (join('',@@ary) eq '1234') {print "ok 4\n";} else {print "not ok 4\n";}
d26 1
a26 1
if (join('',@@ary) eq '12345') {print "ok 5\n";} else {print "not ok 5\n";}
d29 4
a32 3
if ($tmp == 5) {print "ok 6\n";} else {print "not ok 6\n";}
if ($#ary == 4) {print "ok 7\n";} else {print "not ok 7\n";}
if (join('',@@ary) eq '1234') {print "ok 8\n";} else {print "not ok 8\n";}
d34 1
a34 1
if ($ary[5] eq '') {print "ok 9\n";} else {print "not ok 9\n";}
d37 2
a38 2
if ($#ary == 5) {print "ok 10\n";} else {print "not ok 10\n";}
if (defined $ary[5]) {print "not ok 11\n";} else {print "ok 11\n";}
d43 1
a43 1
if ($r eq "-1") {print "ok 12\n";} else {print "not ok 12 $r\n";}
d46 1
a46 1
if ($r eq "0,0") {print "ok 13\n";} else {print "not ok 13 $r\n";}
d49 1
a49 1
if ($r eq "2,0,,2") {print "ok 14\n";} else {print "not ok 14 $r\n";}
d54 1
a54 1
if ($r eq "1,0,1") {print "ok 15\n";} else {print "not ok 15 $r\n";}
d57 1
a57 1
if ($r eq "-1") {print "ok 16\n";} else {print "not ok 16 $r\n";}
d60 1
a60 1
if ($r eq "0,0") {print "ok 17\n";} else {print "not ok 17 $r\n";}
d63 2
a64 2
if ($r eq "2,0,,2") {print "ok 18\n";} else {print "not ok 18 $r\n";}
reset 'b';
d68 1
a68 1
if ($r eq "0,0") {print "ok 19\n";} else {print "not ok 19 $r\n";}
d71 1
a71 1
if ($r eq "2,0,,2") {print "ok 20\n";} else {print "not ok 20 $r\n";}
d74 4
a77 11
if (($F1,$F2,$Etc) = ($foo =~ /^(\S+)\s+(\S+)\s*(.*)/)) {
    if ($F1 eq 'now' && $F2 eq 'is' && $Etc eq 'the time') {
	print "ok 21\n";
    }
    else {
	print "not ok 21\n";
    }
}
else {
    print "not ok 21\n";
}
d80 2
a81 6
if ($cnt = (($F1,$F2,$Etc) = ($foo =~ /^(\S+)\s+(\S+)\s*(.*)/))) {
    print "not ok 22 $cnt $F1:$F2:$Etc\n";
}
else {
    print "ok 22\n";
}
d85 1
a85 1
print $bar{'foo'} eq 'bar' ? "ok 23\n" : "not ok 23\n";
d87 1
a87 1
print $bar{'foo'} eq '' ? "ok 24\n" : "not ok 24\n";
d89 2
a90 2
print $bar{'foo'} eq 'bar' ? "ok 25\n" : "not ok 25\n";
print $bar{'how'} eq 'now' ? "ok 26\n" : "not ok 26\n";
d92 2
a93 2
print $bar{'foo'} eq 'bar' ? "ok 27\n" : "not ok 27\n";
print $bar{'how'} eq 'now' ? "ok 28\n" : "not ok 28\n";
d96 1
a96 1
print join(' ',@@foo) eq 'the time men come' ? "ok 29\n" : "not ok 29\n";
d99 1
a99 1
print join(' ',@@foo) eq 'now is for all good to to' ? "ok 30\n" : "not ok 30\n";
d102 1
a102 1
print $foo eq 'abcdef' ? "ok 31\n" : "not ok 31\n";
d105 1
a105 1
print $foo eq 'ab' ? "ok 32\n" : "not ok 32\n";
d108 1
a108 1
print $foo eq '' ? "ok 33\n" : "not ok 33\n";
d113 1
a113 1
print $foo eq 'acebdf' ? "ok 34\n" : "not ok 34\n";
d116 1
a116 1
print $foo eq 'e' ? "ok 35\n" : "not ok 35\n";
d119 1
a119 1
print $foo eq 'b' ? "ok 36\n" : "not ok 36\n";
d123 1
a123 1
print $#foo == 3 ? "ok 37\n" : "not ok 37\n";
d127 1
a127 2
$test = 37;
sub t { ++$test; print "not " unless $_[0]; print "ok $test\n"; }
d130 1
a130 1
t("@@foo" eq "foo bar burbl blah");				# 38
d133 1
a133 1
t("@@foo" eq "bar burbl blah");					# 39
d136 1
a136 1
t("@@foo" eq "XXX bar burbl blah YYY");				# 40
d139 1
a139 1
t("@@foo" eq 'foo b\a\r bu\\rbl blah');				# 41
d142 2
a143 2
t("@@foo" eq "foo bar");
t("@@bar" eq "foo bar");						# 43
d153 1
a153 1
    t("@@bee" eq "foo bar burbl blah");				# 44
d156 1
a156 1
	t("@@bee" eq "bar burbl blah");				# 45
d159 1
a159 1
	    t("@@bee" eq "XXX bar burbl blah YYY");		# 46
d162 1
a162 1
		t("@@bee" eq "foo bar burbl blah");		# 47
d165 2
a166 2
		    t("@@bee" eq "foo bar");			# 48
		    t("@@bim" eq "foo bar");			# 49
d168 1
a168 1
		t("@@bee" eq "foo bar burbl blah");		# 50
d170 1
a170 1
	    t("@@bee" eq "XXX bar burbl blah YYY");		# 51
d172 1
a172 1
	t("@@bee" eq "bar burbl blah");				# 52
d174 1
a174 1
    t("@@bee" eq "foo bar burbl blah");				# 53
d181 1
a181 1
    t("@@bee" eq "foo bar burbl blah");				# 54
d184 1
a184 1
	t("@@bee" eq "bar burbl blah");				# 55
d187 1
a187 1
	    t("@@bee" eq "XXX bar burbl blah YYY");		# 56
d190 1
a190 1
		t("@@bee" eq "foo bar burbl blah");		# 57
d193 2
a194 2
		    t("@@bee" eq "foo bar");			# 58
		    t("@@bim" eq "foo bar");			# 59
d196 1
a196 1
		t("@@bee" eq "foo bar burbl blah");		# 60
d198 1
a198 1
	    t("@@bee" eq "XXX bar burbl blah YYY");		# 61
d200 1
a200 1
	t("@@bee" eq "bar burbl blah");				# 62
d202 1
a202 1
    t("@@bee" eq "foo bar burbl blah");				# 63
d206 2
a207 2
my $t = 63;
sub reify { $_[1] = ++$t; print "@@_\n"; }
d211 4
a214 3
# qw() is no more a runtime split, it's compiletime.
print "not " unless qw(foo bar snorfle)[2] eq 'snorfle';
print "ok 66\n";
d218 4
a221 11
print "not " unless shift(@@ary) == 12;
print "ok 67\n";

print "not " unless pop(@@ary) == 56;
print "ok 68\n";

print "not " unless push(@@ary,56) == 4;
print "ok 69\n";

print "not " unless unshift(@@ary,12) == 5;
print "ok 70\n";
d225 1
a225 2
$foo[1] eq "a" or print "not ";
print "ok 71\n";
d230 2
d235 1
a235 2
  print "not " unless $tary[5] == $tary[$five];
  print "ok 72\n";
a241 2
require './test.pl';

d255 1
a255 2
print "# $got\nnot " unless $got eq '';
print "ok 73\n";
d259 1
d262 9
a270 9
    print $a[-1] == 4 ? "ok 74\n" : "not ok 74\n";
    print $a[-2] == 3 ? "ok 75\n" : "not ok 75\n";
    print $a[-5] == 0 ? "ok 76\n" : "not ok 76\n";
    print defined $a[-6] ? "not ok 77\n" : "ok 77\n";

    print $a[2.1]   == 2 ? "ok 78\n" : "not ok 78\n";
    print $a[2.9]   == 2 ? "ok 79\n" : "not ok 79\n";
    print $a[undef] == 0 ? "ok 80\n" : "not ok 80\n";
    print $a["3rd"] == 3 ? "ok 81\n" : "not ok 81\n";
a272 4
sub kindalike { # TODO: test.pl-ize the array.t.
    my ($s, $r, $m, $n) = @@_;
    print $s =~ /$r/ ? "ok $n - $m\n" : "not ok $n - $m ($s)\n";
}
d277 19
a295 1
    kindalike($@@, qr/Modification of non-creatable array value attempted, subscript -1/, "\$a[-1] = 0", 82);
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@a2 1

d8 1
a8 1
print "1..73\n";
d274 26
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d3 7
a9 1
print "1..72\n";
d256 19
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d3 1
a3 1
print "1..70\n";
d232 18
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d3 1
a3 1
print "1..66\n";
d142 2
a143 2
@@foo = @@foo = qw(foo bar burbl blah);
t("@@foo" eq "foo bar burbl blah");				# 41
d219 13
@


1.3
log
@perl5.005_03 (stock)
@
text
@d3 1
a3 1
print "1..65\n";
d214 5
@


1.2
log
@perl 5.004_04
@
text
@d3 1
a3 1
# $RCSfile: array.t,v $$Revision: 4.1 $$Date: 92/08/07 18:27:37 $
d5 3
a7 1
print "1..36\n";
d123 91
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d3 1
a3 1
print "1..65\n";
d5 1
a5 3
#
# @@foo, @@bar, and @@ary are also used from tie-stdarray after tie-ing them
#
a120 91

@@foo = ( 'foo', 'bar', 'burbl');
push(foo, 'blah');
print $#foo == 3 ? "ok 37\n" : "not ok 37\n";

# various AASSIGN_COMMON checks (see newASSIGNOP() in op.c)

$test = 37;
sub t { ++$test; print "not " unless $_[0]; print "ok $test\n"; }

@@foo = @@foo;
t("@@foo" eq "foo bar burbl blah");				# 38

(undef,@@foo) = @@foo;
t("@@foo" eq "bar burbl blah");					# 39

@@foo = ('XXX',@@foo, 'YYY');
t("@@foo" eq "XXX bar burbl blah YYY");				# 40

@@foo = @@foo = qw(foo bar burbl blah);
t("@@foo" eq "foo bar burbl blah");				# 41

@@bar = @@foo = qw(foo bar);					# 42
t("@@foo" eq "foo bar");
t("@@bar" eq "foo bar");						# 43

# try the same with local
# XXX tie-stdarray fails the tests involving local, so we use
# different variable names to escape the 'tie'

@@bee = ( 'foo', 'bar', 'burbl', 'blah');
{

    local @@bee = @@bee;
    t("@@bee" eq "foo bar burbl blah");				# 44
    {
	local (undef,@@bee) = @@bee;
	t("@@bee" eq "bar burbl blah");				# 45
	{
	    local @@bee = ('XXX',@@bee,'YYY');
	    t("@@bee" eq "XXX bar burbl blah YYY");		# 46
	    {
		local @@bee = local(@@bee) = qw(foo bar burbl blah);
		t("@@bee" eq "foo bar burbl blah");		# 47
		{
		    local (@@bim) = local(@@bee) = qw(foo bar);
		    t("@@bee" eq "foo bar");			# 48
		    t("@@bim" eq "foo bar");			# 49
		}
		t("@@bee" eq "foo bar burbl blah");		# 50
	    }
	    t("@@bee" eq "XXX bar burbl blah YYY");		# 51
	}
	t("@@bee" eq "bar burbl blah");				# 52
    }
    t("@@bee" eq "foo bar burbl blah");				# 53
}

# try the same with my
{

    my @@bee = @@bee;
    t("@@bee" eq "foo bar burbl blah");				# 54
    {
	my (undef,@@bee) = @@bee;
	t("@@bee" eq "bar burbl blah");				# 55
	{
	    my @@bee = ('XXX',@@bee,'YYY');
	    t("@@bee" eq "XXX bar burbl blah YYY");		# 56
	    {
		my @@bee = my @@bee = qw(foo bar burbl blah);
		t("@@bee" eq "foo bar burbl blah");		# 57
		{
		    my (@@bim) = my(@@bee) = qw(foo bar);
		    t("@@bee" eq "foo bar");			# 58
		    t("@@bim" eq "foo bar");			# 59
		}
		t("@@bee" eq "foo bar burbl blah");		# 60
	    }
	    t("@@bee" eq "XXX bar burbl blah YYY");		# 61
	}
	t("@@bee" eq "bar burbl blah");				# 62
    }
    t("@@bee" eq "foo bar burbl blah");				# 63
}

# make sure reification behaves
my $t = 63;
sub reify { $_[1] = ++$t; print "@@_\n"; }
reify('ok');
reify('ok');
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d3 1
a3 1
print "1..66\n";
a213 5

# qw() is no more a runtime split, it's compiletime.
print "not " unless qw(foo bar snorfle)[2] eq 'snorfle';
print "ok 66\n";

@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d3 1
a3 1
print "1..70\n";
d142 2
a143 2
@@foo = @@foo = qw(foo b\a\r bu\\rbl blah);
t("@@foo" eq 'foo b\a\r bu\\rbl blah');				# 41
a218 13
@@ary = (12,23,34,45,56);

print "not " unless shift(@@ary) == 12;
print "ok 67\n";

print "not " unless pop(@@ary) == 56;
print "ok 68\n";

print "not " unless push(@@ary,56) == 4;
print "ok 69\n";

print "not " unless unshift(@@ary,12) == 5;
print "ok 70\n";
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d3 1
a3 1
print "1..72\n";
a231 18

sub foo { "a" }
@@foo=(foo())[0,0];
$foo[1] eq "a" or print "not ";
print "ok 71\n";

# $[ should have the same effect regardless of whether the aelem
#    op is optimized to aelemfast.

sub tary {
  local $[ = 10;
  my $five = 5;
  print "not " unless $tary[5] == $tary[$five];
  print "ok 72\n";
}

@@tary = (0..50);
tary();
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@d3 1
a3 7

BEGIN {
    chdir 't' if -d 't';
    @@INC = '../lib';
}

print "1..73\n";
a249 19


require './test.pl';

# bugid #15439 - clearing an array calls destructors which may try
# to modify the array - caused 'Attempt to free unreferenced scalar'

my $got = runperl (
	prog => q{
		    sub X::DESTROY { @@a = () }
		    @@a = (bless {}, 'X');
		    @@a = ();
		},
	stderr => 1
    );

$got =~ s/\n/ /g;
print "# $got\nnot " unless $got eq '';
print "ok 73\n";
@


1.1.1.7
log
@Import of stock perl 5.8.5
@
text
@d3 1
d9 1
a9 1
print "1..82\n";
a274 26

# Test negative and funky indices.

{
    my @@a = 0..4;
    print $a[-1] == 4 ? "ok 74\n" : "not ok 74\n";
    print $a[-2] == 3 ? "ok 75\n" : "not ok 75\n";
    print $a[-5] == 0 ? "ok 76\n" : "not ok 76\n";
    print defined $a[-6] ? "not ok 77\n" : "ok 77\n";

    print $a[2.1]   == 2 ? "ok 78\n" : "not ok 78\n";
    print $a[2.9]   == 2 ? "ok 79\n" : "not ok 79\n";
    print $a[undef] == 0 ? "ok 80\n" : "not ok 80\n";
    print $a["3rd"] == 3 ? "ok 81\n" : "not ok 81\n";
}

sub kindalike { # TODO: test.pl-ize the array.t.
    my ($s, $r, $m, $n) = @@_;
    print $s =~ /$r/ ? "ok $n - $m\n" : "not ok $n - $m ($s)\n";
}

{
    my @@a;
    eval '$a[-1] = 0';
    kindalike($@@, qr/Modification of non-creatable array value attempted, subscript -1/, "\$a[-1] = 0", 82);
}
@


1.1.1.8
log
@perl 5.8.8 import
@
text
@d5 1
a5 1
    @@INC = '.', '../lib';
d8 1
a8 3
require 'test.pl';

plan (91);
d15 1
a15 1
is(join('',@@ary), '12345');
d18 3
a20 3
is($tmp, 5);
is($#ary, 3);
is(join('',@@ary), '1234');
d24 1
a24 1
is(join('',@@ary), '12345');
d27 3
a29 4
is($tmp, 5);
# Must do == here beacuse $[ isn't 0
ok($#ary == 4);
is(join('',@@ary), '1234');
d31 1
a31 1
is($ary[5], undef);
d34 2
a35 2
ok($#ary == 5);
ok(!defined $ary[5]);
d40 1
a40 1
is($r, "-1");
d43 1
a43 1
is($r, "0,0");
d46 1
a46 1
is($r, "2,0,,2");
d51 1
a51 1
is($r, "1,0,1");
d54 1
a54 1
is($r, "-1");
d57 1
a57 1
is($r, "0,0");
d60 2
a61 2
is($r, "2,0,,2");
reset 'b' if $^O ne 'VMS';
d65 1
a65 1
is($r, "0,0");
d68 1
a68 1
is($r, "2,0,,2");
d71 11
a81 4
ok(scalar (($F1,$F2,$Etc) = ($foo =~ /^(\S+)\s+(\S+)\s*(.*)/)));
is($F1, 'now');
is($F2, 'is');
is($Etc, 'the time');
d84 6
a89 2
ok(!($cnt = (($F1,$F2,$Etc) = ($foo =~ /^(\S+)\s+(\S+)\s*(.*)/))))
   or diag("$cnt $F1:$F2:$Etc");
d93 1
a93 1
is($bar{'foo'}, 'bar');
d95 1
a95 1
is($bar{'foo'}, undef);
d97 2
a98 2
is($bar{'foo'}, 'bar');
is($bar{'how'}, 'now');
d100 2
a101 2
is($bar{'foo'}, 'bar');
is($bar{'how'}, 'now');
d104 1
a104 1
is(join(' ',@@foo), 'the time men come');
d107 1
a107 1
is(join(' ',@@foo), 'now is for all good to to');
d110 1
a110 1
is($foo, 'abcdef');
d113 1
a113 1
is($foo, 'ab');
d116 1
a116 1
is($foo, '');
d121 1
a121 1
is($foo, 'acebdf');
d124 1
a124 1
is($foo, 'e');
d127 1
a127 1
is($foo, 'b');
d131 1
a131 1
is($#foo, 3);
d135 2
a136 1
#curr_test(38);
d139 1
a139 1
is("@@foo", "foo bar burbl blah");				# 38
d142 1
a142 1
is("@@foo", "bar burbl blah");					# 39
d145 1
a145 1
is("@@foo", "XXX bar burbl blah YYY");				# 40
d148 1
a148 1
is("@@foo", 'foo b\a\r bu\\rbl blah');				# 41
d151 2
a152 2
is("@@foo", "foo bar");
is("@@bar", "foo bar");						# 43
d162 1
a162 1
    is("@@bee", "foo bar burbl blah");				# 44
d165 1
a165 1
	is("@@bee", "bar burbl blah");				# 45
d168 1
a168 1
	    is("@@bee", "XXX bar burbl blah YYY");		# 46
d171 1
a171 1
		is("@@bee", "foo bar burbl blah");		# 47
d174 2
a175 2
		    is("@@bee", "foo bar");			# 48
		    is("@@bim", "foo bar");			# 49
d177 1
a177 1
		is("@@bee", "foo bar burbl blah");		# 50
d179 1
a179 1
	    is("@@bee", "XXX bar burbl blah YYY");		# 51
d181 1
a181 1
	is("@@bee", "bar burbl blah");				# 52
d183 1
a183 1
    is("@@bee", "foo bar burbl blah");				# 53
d190 1
a190 1
    is("@@bee", "foo bar burbl blah");				# 54
d193 1
a193 1
	is("@@bee", "bar burbl blah");				# 55
d196 1
a196 1
	    is("@@bee", "XXX bar burbl blah YYY");		# 56
d199 1
a199 1
		is("@@bee", "foo bar burbl blah");		# 57
d202 2
a203 2
		    is("@@bee", "foo bar");			# 58
		    is("@@bim", "foo bar");			# 59
d205 1
a205 1
		is("@@bee", "foo bar burbl blah");		# 60
d207 1
a207 1
	    is("@@bee", "XXX bar burbl blah YYY");		# 61
d209 1
a209 1
	is("@@bee", "bar burbl blah");				# 62
d211 1
a211 1
    is("@@bee", "foo bar burbl blah");				# 63
d215 2
a216 2
my $t = curr_test();
sub reify { $_[1] = $t++; print "@@_\n"; }
d220 5
a224 1
curr_test($t);
d226 2
a227 2
# qw() is no longer a runtime split, it's compiletime.
is (qw(foo bar snorfle)[2], 'snorfle');
d229 5
a233 1
@@ary = (12,23,34,45,56);
d235 2
a236 4
is(shift(@@ary), 12);
is(pop(@@ary), 56);
is(push(@@ary,56), 4);
is(unshift(@@ary,12), 5);
d240 2
a241 1
is ($foo[1], "a");
a245 2


d249 2
a250 1
  is ($tary[5], $tary[$five]);
d257 2
d272 2
a273 1
is ($got, '');
a276 1

d279 9
a287 9
    is($a[-1], 4);
    is($a[-2], 3);
    is($a[-5], 0);
    ok(!defined $a[-6]);

    is($a[2.1]  , 2);
    is($a[2.9]  , 2);
    is($a[undef], 0);
    is($a["3rd"], 3);
d290 4
d298 1
a298 19
    like($@@, qr/Modification of non-creatable array value attempted, subscript -1/, "\$a[-1] = 0");
}

sub test_arylen {
    my $ref = shift;
    local $^W = 1;
    is ($$ref, undef, "\$# on freed array is undef");
    my @@warn;
    local $SIG{__WARN__} = sub {push @@warn, "@@_"};
    $$ref = 1000;
    is (scalar @@warn, 1);
    like ($warn[0], qr/^Attempt to set length of freed array/);
}

{
    my $a = \$#{[]};
    # Need a new statement to make it go out of scope
    test_arylen ($a);
    test_arylen (do {my @@a; \$#a});
@


1.1.1.9
log
@import perl 5.10.0 from CPAN
@
text
@d5 1
a5 1
    @@INC = ('.', '../lib');
d10 1
a10 1
plan (125);
d179 1
a204 23
# try the same with our (except that previous values aren't restored)
{
    our @@bee = @@bee;
    is("@@bee", "foo bar burbl blah");
    {
	our (undef,@@bee) = @@bee;
	is("@@bee", "bar burbl blah");
	{
	    our @@bee = ('XXX',@@bee,'YYY');
	    is("@@bee", "XXX bar burbl blah YYY");
	    {
		our @@bee = our @@bee = qw(foo bar burbl blah);
		is("@@bee", "foo bar burbl blah");
		{
		    our (@@bim) = our(@@bee) = qw(foo bar);
		    is("@@bee", "foo bar");
		    is("@@bim", "foo bar");
		}
	    }
	}
    }
}

a296 105

{
    use vars '@@array';

    my $outer = \$#array;
    is ($$outer, -1);
    is (scalar @@array, 0);

    $$outer = 3;
    is ($$outer, 3);
    is (scalar @@array, 4);

    my $ref = \@@array;

    my $inner;
    {
	local @@array;
	$inner = \$#array;

	is ($$inner, -1);
	is (scalar @@array, 0);
	$$outer = 6;

	is (scalar @@$ref, 7);

	is ($$inner, -1);
	is (scalar @@array, 0);

	$$inner = 42;
    }

    is (scalar @@array, 7);
    is ($$outer, 6);

    is ($$inner, undef, "orphaned $#foo is always undef");

    is (scalar @@array, 7);
    is ($$outer, 6);

    $$inner = 1;

    is (scalar @@array, 7);
    is ($$outer, 6);

    $$inner = 503; # Bang!

    is (scalar @@array, 7);
    is ($$outer, 6);
}

{
    # Bug #36211
    use vars '@@array';
    for (1,2) {
	{
	    local @@a;
	    is ($#a, -1);
	    @@a=(1..4)
	}
    }
}

{
    # Bug #37350
    my @@array = (1..4);
    $#{@@array} = 7;
    is ($#{4}, 7);

    my $x;
    $#{$x} = 3;
    is(scalar @@$x, 4);

    push @@{@@array}, 23;
    is ($4[8], 23);
}
{
    # Bug #37350 -- once more with a global
    use vars '@@array';
    @@array = (1..4);
    $#{@@array} = 7;
    is ($#{4}, 7);

    my $x;
    $#{$x} = 3;
    is(scalar @@$x, 4);

    push @@{@@array}, 23;
    is ($4[8], 23);
}

# more tests for AASSIGN_COMMON

{
    our($x,$y,$z) = (1..3);
    our($y,$z) = ($x,$y);
    is("$x $y $z", "1 1 2");
}
{
    our($x,$y,$z) = (1..3);
    (our $y, our $z) = ($x,$y);
    is("$x $y $z", "1 1 2");
}


"We're included by lib/Tie/Array/std.t so we need to return something true";
@


1.1.1.10
log
@Perl 5.12.2 from CPAN
@
text
@d10 1
a10 1
plan (127);
a23 3
{
    no warnings 'deprecated';

a72 2
}

d122 1
a122 4
{
    no warnings 'deprecated';
    push(foo, 'blah');
}
a254 1
  no warnings 'deprecated';
a419 14
}

# [perl #70171]
{
 my $x = get_x(); my %x = %$x; sub get_x { %x=(1..4); return \%x };
 is(
   join(" ", map +($_,$x{$_}), sort keys %x), "1 2 3 4",
  'bug 70171 (self-assignment via my %x = %$x)'
 );
 my $y = get_y(); my @@y = @@$y; sub get_y { @@y=(1..4); return \@@y };
 is(
  "@@y", "1 2 3 4",
  'bug 70171 (self-assignment via my @@x = @@$x)'
 );
@


1.1.1.11
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@a5 1
    require 'test.pl';
d8 2
d27 17
d257 16
d279 1
a279 1
		    @@a = (bless {}, q{X});
a429 7
{
    # AASSIGN_COMMON detection with logical operators
    my $true = 1;
    our($x,$y,$z) = (1..3);
    (our $y, our $z) = $true && ($x,$y);
    is("$x $y $z", "1 1 2");
}
a442 56
}

# [perl #70171], [perl #82110]
{
    my ($i, $ra, $rh);
  again:
    my @@a = @@$ra; # common assignment on 2nd attempt
    my %h = %$rh; # common assignment on 2nd attempt
    @@a = qw(1 2 3 4);
    %h = qw(a 1 b 2 c 3 d 4);
    $ra = \@@a;
    $rh = \%h;
    goto again unless $i++;

    is("@@a", "1 2 3 4",
	'bug 70171 (self-assignment via my @@x = @@$x) - goto variant'
    );
    is(
	join(" ", map +($_,$h{$_}), sort keys %h), "a 1 b 2 c 3 d 4",
	'bug 70171 (self-assignment via my %x = %$x) - goto variant'
    );
}


*trit = *scile;  $trit[0];
ok(1, 'aelem_fast on a nonexistent array does not crash');

# [perl #107440]
sub A::DESTROY { $::ra = 0 }
$::ra = [ bless [], 'A' ];
undef @@$::ra;
pass 'no crash when freeing array that is being undeffed';
$::ra = [ bless [], 'A' ];
@@$::ra = ('a'..'z');
pass 'no crash when freeing array that is being cleared';

# [perl #85670] Copying magic to elements
SKIP: {
    skip "no Scalar::Util::weaken on miniperl", 1, if is_miniperl;
    require Scalar::Util;
    package glelp {
	Scalar::Util::weaken ($a = \@@ISA);
	@@ISA = qw(Foo);
	Scalar::Util::weaken ($a = \$ISA[0]);
	::is @@ISA, 1, 'backref magic is not copied to elements';
    }
}
package peen {
    $#ISA = -1;
    @@ISA = qw(Foo);
    $ISA[0] = qw(Sphare);

    sub Sphare::pling { 'pling' }

    ::is eval { pling peen }, 'pling',
	'arylen_p magic does not stop isa magic from being copied';
@


1.1.1.12
log
@Import perl-5.20.1
@
text
@d9 1
a9 1
plan (171);
d23 3
d58 2
a473 78
# Test that &PL_sv_undef is not special in arrays
sub {
    ok exists $_[0],
      'exists returns true for &PL_sv_undef elem [perl #7508]';
    is \$_[0], \undef, 'undef preserves identity in array [perl #109726]';
}->(undef);
# and that padav also knows how to handle the resulting NULLs
@@_ = sub { my @@a; $a[1]=1; @@a }->();
is join (" ", map $_//"undef", @@_), "undef 1",
  'returning my @@a with nonexistent elements'; 

# [perl #118691]
@@plink=@@plunk=();
$plink[3] = 1;
sub {
    $_[0] = 2;
    is $plink[0], 2, '@@_ alias to nonexistent elem within array';
    $_[1] = 3;
    is $plink[1], 3, '@@_ alias to nonexistent neg index within array';
    is $_[2], undef, 'reading alias to negative index past beginning';
    eval { $_[2] = 42 };
    like $@@, qr/Modification of non-creatable array value attempted, (?x:
               )subscript -5/,
         'error when setting alias to negative index past beginning';
    is $_[3], undef, 'reading alias to -1 elem of empty array';
    eval { $_[3] = 42 };
    like $@@, qr/Modification of non-creatable array value attempted, (?x:
               )subscript -1/,
         'error when setting alias to -1 elem of empty array';
}->($plink[0], $plink[-2], $plink[-5], $plunk[-1]);

$_ = \$#{[]};
$$_ = \1;
"$$_";
pass "no assertion failure after assigning ref to arylen when ary is gone";


{
    # Test aelemfast for both +ve and -ve indices, both lex and package vars.
    # Make especially careful that we don't have any edge cases around
    # fitting an I8 into a U8.
    my @@a = (0..299);
    is($a[-256], 300-256, 'lex -256');
    is($a[-255], 300-255, 'lex -255');
    is($a[-254], 300-254, 'lex -254');
    is($a[-129], 300-129, 'lex -129');
    is($a[-128], 300-128, 'lex -128');
    is($a[-127], 300-127, 'lex -127');
    is($a[-126], 300-126, 'lex -126');
    is($a[  -1], 300-  1, 'lex   -1');
    is($a[   0],       0, 'lex    0');
    is($a[   1],       1, 'lex    1');
    is($a[ 126],     126, 'lex  126');
    is($a[ 127],     127, 'lex  127');
    is($a[ 128],     128, 'lex  128');
    is($a[ 129],     129, 'lex  129');
    is($a[ 254],     254, 'lex  254');
    is($a[ 255],     255, 'lex  255');
    is($a[ 256],     256, 'lex  256');
    @@aelem =(0..299);
    is($aelem[-256], 300-256, 'pkg -256');
    is($aelem[-255], 300-255, 'pkg -255');
    is($aelem[-254], 300-254, 'pkg -254');
    is($aelem[-129], 300-129, 'pkg -129');
    is($aelem[-128], 300-128, 'pkg -128');
    is($aelem[-127], 300-127, 'pkg -127');
    is($aelem[-126], 300-126, 'pkg -126');
    is($aelem[  -1], 300-  1, 'pkg   -1');
    is($aelem[   0],       0, 'pkg    0');
    is($aelem[   1],       1, 'pkg    1');
    is($aelem[ 126],     126, 'pkg  126');
    is($aelem[ 127],     127, 'pkg  127');
    is($aelem[ 128],     128, 'pkg  128');
    is($aelem[ 129],     129, 'pkg  129');
    is($aelem[ 254],     254, 'pkg  254');
    is($aelem[ 255],     255, 'pkg  255');
    is($aelem[ 256],     256, 'pkg  256');
}
@


1.1.1.13
log
@Import perl-5.24.2
@
text
@d6 1
a6 1
    require './test.pl';
d9 1
a9 1
plan (173);
d103 6
a108 1
@@foo = ( 'foo', 'bar', 'burbl', 'blah');
d112 1
a112 1
#curr_test(37);
d115 1
a115 1
is("@@foo", "foo bar burbl blah");				# 37
d118 1
a118 1
is("@@foo", "bar burbl blah");					# 38
d121 1
a121 1
is("@@foo", "XXX bar burbl blah YYY");				# 39
d124 1
a124 1
is("@@foo", 'foo b\a\r bu\\rbl blah');				# 40
d126 1
a126 1
@@bar = @@foo = qw(foo bar);					# 41
d128 1
a128 1
is("@@bar", "foo bar");						# 42
d138 1
a138 1
    is("@@bee", "foo bar burbl blah");				# 43
d141 1
a141 1
	is("@@bee", "bar burbl blah");				# 44
d144 1
a144 1
	    is("@@bee", "XXX bar burbl blah YYY");		# 45
d147 1
a147 1
		is("@@bee", "foo bar burbl blah");		# 46
d150 2
a151 2
		    is("@@bee", "foo bar");			# 47
		    is("@@bim", "foo bar");			# 48
d153 1
a153 1
		is("@@bee", "foo bar burbl blah");		# 49
d155 1
a155 1
	    is("@@bee", "XXX bar burbl blah YYY");		# 50
d157 1
a157 1
	is("@@bee", "bar burbl blah");				# 51
d159 1
a159 1
    is("@@bee", "foo bar burbl blah");				# 52
d165 1
a165 1
    is("@@bee", "foo bar burbl blah");				# 53
d168 1
a168 1
	is("@@bee", "bar burbl blah");				# 54
d171 1
a171 1
	    is("@@bee", "XXX bar burbl blah YYY");		# 55
d174 1
a174 1
		is("@@bee", "foo bar burbl blah");		# 56
d177 2
a178 2
		    is("@@bee", "foo bar");			# 57
		    is("@@bim", "foo bar");			# 58
d180 1
a180 1
		is("@@bee", "foo bar burbl blah");		# 59
d182 1
a182 1
	    is("@@bee", "XXX bar burbl blah YYY");		# 60
d184 1
a184 1
	is("@@bee", "bar burbl blah");				# 61
d186 1
a186 1
    is("@@bee", "foo bar burbl blah");				# 62
a545 15
}

# Test aelemfast in list assignment
@@ary = ('a','b');
($ary[0],$ary[1]) = ($ary[1],$ary[0]);
is "@@ary", 'b a',
   'aelemfast with the same array on both sides of list assignment';

for(scalar $#foo) { $_ = 3 }
is $#foo, 3, 'assigning to arylen aliased in foreach(scalar $#arylen)';

{
    my @@a = qw(a b c);
    @@a = @@a;
    is "@@a", 'a b c', 'assigning to itself';
@


