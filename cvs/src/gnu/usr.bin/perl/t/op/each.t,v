head	1.10;
access;
symbols
	OPENBSD_6_2:1.10.0.2
	OPENBSD_6_2_BASE:1.10
	PERL_5_24_2:1.1.1.9
	OPENBSD_6_1:1.10.0.4
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.9.0.12
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.6
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.9.0.8
	OPENBSD_5_8_BASE:1.9
	PERL_5_20_2:1.1.1.8
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	PERL_5_20_1:1.1.1.8
	OPENBSD_5_6:1.9.0.4
	OPENBSD_5_6_BASE:1.9
	PERL_5_18_2:1.1.1.8
	PERL:1.1.1
	OPENBSD_5_5:1.8.0.6
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	PERL_5_16_3:1.1.1.7
	OPENBSD_5_3:1.7.0.10
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.8
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.6
	OPENBSD_5_0:1.7.0.4
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.2
	OPENBSD_4_9_BASE:1.7
	PERL_5_12_2:1.1.1.6
	OPENBSD_4_8:1.6.0.18
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.14
	OPENBSD_4_7_BASE:1.6
	PERL_5_10_1:1.1.1.5
	OPENBSD_4_6:1.6.0.16
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.12
	OPENBSD_4_5_BASE:1.6
	PERL_5_10_0:1.1.1.5
	OPENBSD_4_4:1.6.0.10
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.8
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.6
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.4
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.2
	OPENBSD_4_0_BASE:1.6
	PERL_5_8_8:1.1.1.5
	OPENBSD_3_9:1.5.0.14
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.12
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.10
	OPENBSD_3_7_BASE:1.5
	PERL_5_8_6:1.1.1.4
	OPENBSD_3_6:1.5.0.8
	OPENBSD_3_6_BASE:1.5
	PERL_5_8_5:1.1.1.4
	PERL_5_8_3:1.1.1.4
	OPENBSD_3_5:1.5.0.6
	OPENBSD_3_5_BASE:1.5
	PERL_5_8_2:1.1.1.4
	OPENBSD_3_4:1.5.0.4
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.4.0.12
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.10
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.8
	OPENBSD_3_0_BASE:1.4
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.10
date	2017.02.05.00.32.20;	author afresh1;	state Exp;
branches;
next	1.9;
commitid	cxJ08BvJA9Pt2PTM;

1.9
date	2014.03.24.15.05.33;	author afresh1;	state Exp;
branches;
next	1.8;

1.8
date	2013.03.25.20.40.59;	author sthen;	state Exp;
branches;
next	1.7;

1.7
date	2010.09.24.15.07.08;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2006.03.28.19.23.12;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.10.27.22.25.37;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.08.21;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.52.34;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.08.05.18;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.13.17;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.13.17;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.41.44;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.10.48;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.27.22.15.10;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2006.03.28.18.49.44;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2010.09.24.14.49.18;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2013.03.25.20.09.35;	author sthen;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2014.03.24.14.59.10;	author afresh1;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2017.08.14.13.46.23;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.10
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl

BEGIN {
    chdir 't' if -d 't';
    @@INC = '../lib';
    require './test.pl';
}

plan tests => 59;

$h{'abc'} = 'ABC';
$h{'def'} = 'DEF';
$h{'jkl','mno'} = "JKL\034MNO";
$h{'a',2,3,4,5} = join("\034",'A',2,3,4,5);
$h{'a'} = 'A';
$h{'b'} = 'B';
$h{'c'} = 'C';
$h{'d'} = 'D';
$h{'e'} = 'E';
$h{'f'} = 'F';
$h{'g'} = 'G';
$h{'h'} = 'H';
$h{'i'} = 'I';
$h{'j'} = 'J';
$h{'k'} = 'K';
$h{'l'} = 'L';
$h{'m'} = 'M';
$h{'n'} = 'N';
$h{'o'} = 'O';
$h{'p'} = 'P';
$h{'q'} = 'Q';
$h{'r'} = 'R';
$h{'s'} = 'S';
$h{'t'} = 'T';
$h{'u'} = 'U';
$h{'v'} = 'V';
$h{'w'} = 'W';
$h{'x'} = 'X';
$h{'y'} = 'Y';
$h{'z'} = 'Z';

@@keys = keys %h;
@@values = values %h;

is ($#keys, 29, "keys");
is ($#values, 29, "values");

$i = 0;		# stop -w complaints

while (($key,$value) = each(%h)) {
    if ($key eq $keys[$i] && $value eq $values[$i]
        && (('a' lt 'A' && $key lt $value) || $key gt $value)) {
	$key =~ y/a-z/A-Z/;
	$i++ if $key eq $value;
    }
}

is ($i, 30, "each count");

@@keys = ('blurfl', keys(%h), 'dyick');
is ($#keys, 31, "added a key");

$size = ((split('/',scalar %h))[1]);
keys %h = $size * 5;
$newsize = ((split('/',scalar %h))[1]);
is ($newsize, $size * 8, "resize");
keys %h = 1;
$size = ((split('/',scalar %h))[1]);
is ($size, $newsize, "same size");
%h = (1,1);
$size = ((split('/',scalar %h))[1]);
is ($size, $newsize, "still same size");
undef %h;
%h = (1,1);
$size = ((split('/',scalar %h))[1]);
is ($size, 8, "size 8");

# test scalar each
%hash = 1..20;
$total = 0;
$total += $key while $key = each %hash;
is ($total, 100, "test scalar each");

for (1..3) { @@foo = each %hash }
keys %hash;
$total = 0;
$total += $key while $key = each %hash;
is ($total, 100, "test scalar keys resets iterator");

for (1..3) { @@foo = each %hash }
$total = 0;
$total += $key while $key = each %hash;
isnt ($total, 100, "test iterator of each is being maintained");

for (1..3) { @@foo = each %hash }
values %hash;
$total = 0;
$total += $key while $key = each %hash;
is ($total, 100, "test values keys resets iterator");

$size = (split('/', scalar %hash))[1];
keys(%hash) = $size / 2;
is ($size, (split('/', scalar %hash))[1]);
keys(%hash) = $size + 100;
isnt ($size, (split('/', scalar %hash))[1]);

is (keys(%hash), 10, "keys (%hash)");

@@tests = (&next_test, &next_test, &next_test);
{
    package Obj;
    sub DESTROY { print "ok $::tests[1] # DESTROY called\n"; }
    {
	my $h = { A => bless [], __PACKAGE__ };
        while (my($k,$v) = each %$h) {
	    print "ok $::tests[0]\n" if $k eq 'A' and ref($v) eq 'Obj';
	}
    }
    print "ok $::tests[2]\n";
}

# Check for Unicode hash keys.
%u = ("\x{12}", "f", "\x{123}", "fo", "\x{1234}",  "foo");
$u{"\x{12345}"}  = "bar";
@@u{"\x{10FFFD}"} = "zap";

my %u2;
foreach (keys %u) {
    is (length(), 1, "Check length of " . _qq $_);
    $u2{$_} = $u{$_};
}
ok (eq_hash(\%u, \%u2), "copied unicode hash keys correctly?");

$a = "\xe3\x81\x82"; $A = "\x{3042}";
%b = ( $a => "non-utf8");
%u = ( $A => "utf8");

is (exists $b{$A}, '', "utf8 key in bytes hash");
is (exists $u{$a}, '', "bytes key in utf8 hash");
print "# $b{$_}\n" for keys %b; # Used to core dump before change #8056.
pass ("if we got here change 8056 worked");
print "# $u{$_}\n" for keys %u; # Used to core dump before change #8056.
pass ("change 8056 is thanks to Inaba Hiroto");

# on EBCDIC chars are mapped differently so pick something that needs encoding
# there too.
$d = pack("U*", 0xe3, 0x81, 0xAF);
{ use bytes; $ol = bytes::length($d) }
cmp_ok ($ol, '>', 3, "check encoding on EBCDIC");
%u = ($d => "downgrade");
for (keys %u) {
    is (length, 3, "check length"); 
    is ($_, pack("U*", 0xe3, 0x81, 0xAF), "check value");
}
{
    { use bytes; is (bytes::length($d), $ol) }
}

{
    my %u;
    my $u0 = pack("U0U", 0x00FF);
    my $b0 = "\xC3\xBF";          # 0xCB 0xBF is U+00FF in UTF-8
    my $u1 = pack("U0U", 0x0100);
    my $b1 = "\xC4\x80";          # 0xC4 0x80 is U+0100 in UTF-8

    $u{$u0} = 1;
    $u{$b0} = 2; 
    $u{$u1} = 3;
    $u{$b1} = 4;

    is(scalar keys %u, 4, "four different Unicode keys"); 
    is($u{$u0}, 1, "U+00FF        -> 1");
    is($u{$b0}, 2, "U+00C3 U+00BF -> 2");
    is($u{$u1}, 3, "U+0100        -> 3 ");
    is($u{$b1}, 4, "U+00C4 U+0080 -> 4");
}

# test for syntax errors
for my $k (qw(each keys values)) {
    eval $k;
    like($@@, qr/^Not enough arguments for $k/, "$k demands argument");
}

{
    my %foo=(1..10);
    my ($k,$v);
    my $count=keys %foo;
    my ($k1,$v1)=each(%foo);
    my $yes = 0;
    if (%foo) { $yes++ }
    my ($k2,$v2)=each(%foo);
    my $rest=0;
    while (each(%foo)) {$rest++};
    is($yes,1,"if(%foo) was true");
    isnt($k1,$k2,"if(%foo) didnt mess with each (key)");
    isnt($v1,$v2,"if(%foo) didnt mess with each (value)");
    is($rest,3,"Got the expect number of keys");
    my $hsv=1 && %foo;
    like($hsv,qr[/],"Got bucket stats from %foo in scalar assignment context");
    my @@arr=%foo&&%foo;
    is(@@arr,10,"Got expected number of elements in list context");
}    
{
    our %foo=(1..10);
    my ($k,$v);
    my $count=keys %foo;
    my ($k1,$v1)=each(%foo);
    my $yes = 0;
    if (%foo) { $yes++ }
    my ($k2,$v2)=each(%foo);
    my $rest=0;
    while (each(%foo)) {$rest++};
    is($yes,1,"if(%foo) was true");
    isnt($k1,$k2,"if(%foo) didnt mess with each (key)");
    isnt($v1,$v2,"if(%foo) didnt mess with each (value)");
    is($rest,3,"Got the expect number of keys");
    my $hsv=1 && %foo;
    like($hsv,qr[/],"Got bucket stats from %foo in scalar assignment context");
    my @@arr=%foo&&%foo;
    is(@@arr,10,"Got expected number of elements in list context");
}    
{
    # make sure a deleted active iterator gets freed timely, even if the
    # hash is otherwise empty

    package Single;

    my $c = 0;
    sub DESTROY { $c++ };

    {
	my %h = ("a" => bless []);
	my ($k,$v) = each %h;
	delete $h{$k};
	::is($c, 0, "single key not yet freed");
    }
    ::is($c, 1, "single key now freed");
}

{
    # Make sure each() does not leave the iterator in an inconsistent state
    # (RITER set to >= 0, with EITER null) if the active iterator is
    # deleted, leaving the hash apparently empty.
    my %h;
    $h{1} = 2;
    each %h;
    delete $h{1};
    each %h;
    $h{1}=2;
    is join ("-", each %h), '1-2',
	'each on apparently empty hash does not leave RITER set';
}
{
    my $warned= 0;
    local $SIG{__WARN__}= sub {
        /\QUse of each() on hash after insertion without resetting hash iterator results in undefined behavior\E/
            and $warned++ for @@_;
    };
    my %h= map { $_ => $_ } "A".."F";
    while (my ($k, $v)= each %h) {
        $h{"$k$k"}= $v;
    }
    ok($warned,"each() after insert produces warnings");
    no warnings 'internal';
    $warned= 0;
    %h= map { $_ => $_ } "A".."F";
    while (my ($k, $v)= each %h) {
        $h{"$k$k"}= $v;
    }
    ok(!$warned, "no warnings 'internal' silences each() after insert warnings");
}

use feature 'refaliasing';
no warnings 'experimental::refaliasing';
$a = 7;
\$h2{f} = \$a;
($a, $b) = (each %h2);
is "$a $b", "f 7", 'each in list assignment';
$a = 7;
($a, $b) = (3, values %h2);
is "$a $b", "3 7", 'values in list assignment';
@


1.9
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@a108 19
{
    no warnings 'deprecated';
    is (keys(hash), 10, "keys (hash)");
}

$i = 0;
%h = (a => A, b => B, c=> C, d => D, abc => ABC);
{
    no warnings 'deprecated';
    @@keys = keys(h);
    @@values = values(h);
    while (($key, $value) = each(h)) {
	if ($key eq $keys[$i] && $value eq $values[$i] && $key eq lc($value)) {
		$i++;
	}
    }
}
is ($i, 5);

d199 1
a199 1
    like($hsv,'/',"Got bucket stats from %foo in scalar assignment context");
d218 1
a218 1
    like($hsv,'/',"Got bucket stats from %foo in scalar assignment context");
d272 10
@


1.8
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d9 1
a9 1
plan tests => 57;
d271 19
@


1.7
log
@merge in perl 5.12.2 plus local changes
@
text
@d9 1
a9 1
plan tests => 54;
d241 31
@


1.6
log
@merge in perl 5.8.8
@
text
@d9 1
a9 1
plan tests => 39;
d109 4
a112 1
is (keys(hash), 10, "keys (hash)");
d116 5
a120 3
@@keys = keys(h);
@@values = values(h);
while (($key, $value) = each(h)) {
d124 1
d196 45
@


1.5
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d45 2
a46 2
ok ($#keys == 29, "keys");
ok ($#values == 29, "values");
d58 1
a58 1
ok ($i == 30, "each count");
d61 1
a61 1
ok ($#keys == 31, "added a key");
d66 1
a66 1
ok ($newsize == $size * 8, "resize");
d69 1
a69 1
ok ($size == $newsize, "same size");
d72 1
a72 1
ok ($size == $newsize, "still same size");
d76 1
a76 1
ok ($size == 8, "size 8");
d82 1
a82 1
ok ($total == 100, "test scalar each");
d88 1
a88 1
ok ($total == 100, "test scalar keys resets iterator");
d93 1
a93 1
ok ($total != 100, "test iterator of each is being maintained");
d99 1
a99 1
ok ($total == 100, "test values keys resets iterator");
d103 1
a103 1
ok ($size == (split('/', scalar %hash))[1]);
d105 1
a105 1
ok ($size != (split('/', scalar %hash))[1]);
d107 1
a107 1
ok (keys(%hash) == 10, "keys (%hash)");
d109 1
a109 1
ok (keys(hash) == 10, "keys (hash)");
d120 1
a120 1
ok ($i == 5);
d142 1
a142 1
    ok (length() == 1, "Check length of " . _qq $_);
d151 2
a152 2
ok (!exists $b{$A}, "utf8 key in bytes hash");
ok (!exists $u{$a}, "bytes key in utf8 hash");
d162 1
a162 1
ok ($ol > 3, "check encoding on EBCDIC");
d165 1
a165 1
    ok (length == 3, "check length"); 
d169 1
a169 1
    { use bytes; ok (bytes::length($d) == $ol) }
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d3 7
a9 1
print "1..19\n";
d45 2
a46 1
if ($#keys == 29 && $#values == 29) {print "ok 1\n";} else {print "not ok 1\n";}
d58 1
a58 1
if ($i == 30) {print "ok 2\n";} else {print "not ok 2\n";}
d61 1
a61 1
if ($#keys == 31) {print "ok 3\n";} else {print "not ok 3\n";}
d66 1
a66 1
if ($newsize == $size * 8) {print "ok 4\n";} else {print "not ok 4\n";}
d69 1
a69 1
if ($size == $newsize) {print "ok 5\n";} else {print "not ok 5\n";}
d72 1
a72 1
if ($size == $newsize) {print "ok 6\n";} else {print "not ok 6\n";}
d76 1
a76 1
if ($size == 8) {print "ok 7\n";} else {print "not ok 7\n";}
d82 1
a82 2
print "# Scalar each is bad.\nnot " unless $total == 100;
print "ok 8\n";
d88 1
a88 2
print "# Scalar keys isn't resetting the iterator.\nnot " if $total != 100;
print "ok 9\n";
d93 1
a93 2
print "# Iterator of each isn't being maintained.\nnot " if $total == 100;
print "ok 10\n";
d99 1
a99 2
print "# Scalar values isn't resetting the iterator.\nnot " if $total != 100;
print "ok 11\n";
d103 1
a103 2
print "not " if $size != (split('/', scalar %hash))[1];
print "ok 12\n";
d105 1
a105 2
print "not " if $size == (split('/', scalar %hash))[1];
print "ok 13\n";
d107 1
a107 2
print "not " if keys(%hash) != 10;
print "ok 14\n";
d109 1
a109 1
print keys(hash) != 10 ? "not ok 15\n" : "ok 15\n";
d120 1
a120 1
if ($i == 5) { print "ok 16\n" } else { print "not ok\n" }
d122 1
d125 1
a125 1
    sub DESTROY { print "ok 18\n"; }
d129 1
a129 1
	    print "ok 17\n" if $k eq 'A' and ref($v) eq 'Obj';
d132 38
a169 1
    print "ok 19\n";
d172 18
@


1.3
log
@perl5.005_03 (stock)
@
text
@d3 1
a3 3
# $RCSfile: each.t,v $$Revision: 4.1 $$Date: 92/08/07 18:27:47 $

print "1..16\n";
d121 13
@


1.2
log
@perl 5.004_04
@
text
@d5 1
a5 1
print "1..14\n";
d46 2
a47 1
    if ($key eq $keys[$i] && $value eq $values[$i] && $key eq lc($value)) {
d111 12
@


1.1
log
@Initial revision
@
text
@d5 1
a5 1
print "1..3\n";
d43 4
a46 2
while (($key,$value) = each(h)) {
    if ($key eq $keys[$i] && $value eq $values[$i] && $key gt $value) {
d56 54
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d5 1
a5 1
print "1..16\n";
d43 2
a44 5
$i = 0;		# stop -w complaints

while (($key,$value) = each(%h)) {
    if ($key eq $keys[$i] && $value eq $values[$i]
        && (('a' lt 'A' && $key lt $value) || $key gt $value)) {
a53 66

$size = ((split('/',scalar %h))[1]);
keys %h = $size * 5;
$newsize = ((split('/',scalar %h))[1]);
if ($newsize == $size * 8) {print "ok 4\n";} else {print "not ok 4\n";}
keys %h = 1;
$size = ((split('/',scalar %h))[1]);
if ($size == $newsize) {print "ok 5\n";} else {print "not ok 5\n";}
%h = (1,1);
$size = ((split('/',scalar %h))[1]);
if ($size == $newsize) {print "ok 6\n";} else {print "not ok 6\n";}
undef %h;
%h = (1,1);
$size = ((split('/',scalar %h))[1]);
if ($size == 8) {print "ok 7\n";} else {print "not ok 7\n";}

# test scalar each
%hash = 1..20;
$total = 0;
$total += $key while $key = each %hash;
print "# Scalar each is bad.\nnot " unless $total == 100;
print "ok 8\n";

for (1..3) { @@foo = each %hash }
keys %hash;
$total = 0;
$total += $key while $key = each %hash;
print "# Scalar keys isn't resetting the iterator.\nnot " if $total != 100;
print "ok 9\n";

for (1..3) { @@foo = each %hash }
$total = 0;
$total += $key while $key = each %hash;
print "# Iterator of each isn't being maintained.\nnot " if $total == 100;
print "ok 10\n";

for (1..3) { @@foo = each %hash }
values %hash;
$total = 0;
$total += $key while $key = each %hash;
print "# Scalar values isn't resetting the iterator.\nnot " if $total != 100;
print "ok 11\n";

$size = (split('/', scalar %hash))[1];
keys(%hash) = $size / 2;
print "not " if $size != (split('/', scalar %hash))[1];
print "ok 12\n";
keys(%hash) = $size + 100;
print "not " if $size == (split('/', scalar %hash))[1];
print "ok 13\n";

print "not " if keys(%hash) != 10;
print "ok 14\n";

print keys(hash) != 10 ? "not ok 15\n" : "ok 15\n";

$i = 0;
%h = (a => A, b => B, c=> C, d => D, abc => ABC);
@@keys = keys(h);
@@values = values(h);
while (($key, $value) = each(h)) {
	if ($key eq $keys[$i] && $value eq $values[$i] && $key eq lc($value)) {
		$i++;
	}
}
if ($i == 5) { print "ok 16\n" } else { print "not ok\n" }
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d3 3
a5 1
print "1..19\n";
a122 13

{
    package Obj;
    sub DESTROY { print "ok 18\n"; }
    {
	my $h = { A => bless [], __PACKAGE__ };
        while (my($k,$v) = each %$h) {
	    print "ok 17\n" if $k eq 'A' and ref($v) eq 'Obj';
	}
    }
    print "ok 19\n";
}

@


1.1.1.4
log
@stock perl 5.8.0 from CPAN
@
text
@d3 1
a3 7
BEGIN {
    chdir 't' if -d 't';
    @@INC = '../lib';
    require './test.pl';
}

plan tests => 39;
d39 1
a39 2
ok ($#keys == 29, "keys");
ok ($#values == 29, "values");
d51 1
a51 1
ok ($i == 30, "each count");
d54 1
a54 1
ok ($#keys == 31, "added a key");
d59 1
a59 1
ok ($newsize == $size * 8, "resize");
d62 1
a62 1
ok ($size == $newsize, "same size");
d65 1
a65 1
ok ($size == $newsize, "still same size");
d69 1
a69 1
ok ($size == 8, "size 8");
d75 2
a76 1
ok ($total == 100, "test scalar each");
d82 2
a83 1
ok ($total == 100, "test scalar keys resets iterator");
d88 2
a89 1
ok ($total != 100, "test iterator of each is being maintained");
d95 2
a96 1
ok ($total == 100, "test values keys resets iterator");
d100 2
a101 1
ok ($size == (split('/', scalar %hash))[1]);
d103 2
a104 1
ok ($size != (split('/', scalar %hash))[1]);
d106 2
a107 1
ok (keys(%hash) == 10, "keys (%hash)");
d109 1
a109 1
ok (keys(hash) == 10, "keys (hash)");
d120 1
a120 1
ok ($i == 5);
a121 1
@@tests = (&next_test, &next_test, &next_test);
d124 1
a124 1
    sub DESTROY { print "ok $::tests[1] # DESTROY called\n"; }
d128 1
a128 1
	    print "ok $::tests[0]\n" if $k eq 'A' and ref($v) eq 'Obj';
d131 1
a131 38
    print "ok $::tests[2]\n";
}

# Check for Unicode hash keys.
%u = ("\x{12}", "f", "\x{123}", "fo", "\x{1234}",  "foo");
$u{"\x{12345}"}  = "bar";
@@u{"\x{10FFFD}"} = "zap";

my %u2;
foreach (keys %u) {
    ok (length() == 1, "Check length of " . _qq $_);
    $u2{$_} = $u{$_};
}
ok (eq_hash(\%u, \%u2), "copied unicode hash keys correctly?");

$a = "\xe3\x81\x82"; $A = "\x{3042}";
%b = ( $a => "non-utf8");
%u = ( $A => "utf8");

ok (!exists $b{$A}, "utf8 key in bytes hash");
ok (!exists $u{$a}, "bytes key in utf8 hash");
print "# $b{$_}\n" for keys %b; # Used to core dump before change #8056.
pass ("if we got here change 8056 worked");
print "# $u{$_}\n" for keys %u; # Used to core dump before change #8056.
pass ("change 8056 is thanks to Inaba Hiroto");

# on EBCDIC chars are mapped differently so pick something that needs encoding
# there too.
$d = pack("U*", 0xe3, 0x81, 0xAF);
{ use bytes; $ol = bytes::length($d) }
ok ($ol > 3, "check encoding on EBCDIC");
%u = ($d => "downgrade");
for (keys %u) {
    ok (length == 3, "check length"); 
    is ($_, pack("U*", 0xe3, 0x81, 0xAF), "check value");
}
{
    { use bytes; ok (bytes::length($d) == $ol) }
a133 18
{
    my %u;
    my $u0 = pack("U0U", 0x00FF);
    my $b0 = "\xC3\xBF";          # 0xCB 0xBF is U+00FF in UTF-8
    my $u1 = pack("U0U", 0x0100);
    my $b1 = "\xC4\x80";          # 0xC4 0x80 is U+0100 in UTF-8

    $u{$u0} = 1;
    $u{$b0} = 2; 
    $u{$u1} = 3;
    $u{$b1} = 4;

    is(scalar keys %u, 4, "four different Unicode keys"); 
    is($u{$u0}, 1, "U+00FF        -> 1");
    is($u{$b0}, 2, "U+00C3 U+00BF -> 2");
    is($u{$u1}, 3, "U+0100        -> 3 ");
    is($u{$b1}, 4, "U+00C4 U+0080 -> 4");
}
@


1.1.1.5
log
@perl 5.8.8 import
@
text
@d45 2
a46 2
is ($#keys, 29, "keys");
is ($#values, 29, "values");
d58 1
a58 1
is ($i, 30, "each count");
d61 1
a61 1
is ($#keys, 31, "added a key");
d66 1
a66 1
is ($newsize, $size * 8, "resize");
d69 1
a69 1
is ($size, $newsize, "same size");
d72 1
a72 1
is ($size, $newsize, "still same size");
d76 1
a76 1
is ($size, 8, "size 8");
d82 1
a82 1
is ($total, 100, "test scalar each");
d88 1
a88 1
is ($total, 100, "test scalar keys resets iterator");
d93 1
a93 1
isnt ($total, 100, "test iterator of each is being maintained");
d99 1
a99 1
is ($total, 100, "test values keys resets iterator");
d103 1
a103 1
is ($size, (split('/', scalar %hash))[1]);
d105 1
a105 1
isnt ($size, (split('/', scalar %hash))[1]);
d107 1
a107 1
is (keys(%hash), 10, "keys (%hash)");
d109 1
a109 1
is (keys(hash), 10, "keys (hash)");
d120 1
a120 1
is ($i, 5);
d142 1
a142 1
    is (length(), 1, "Check length of " . _qq $_);
d151 2
a152 2
is (exists $b{$A}, '', "utf8 key in bytes hash");
is (exists $u{$a}, '', "bytes key in utf8 hash");
d162 1
a162 1
cmp_ok ($ol, '>', 3, "check encoding on EBCDIC");
d165 1
a165 1
    is (length, 3, "check length"); 
d169 1
a169 1
    { use bytes; is (bytes::length($d), $ol) }
@


1.1.1.6
log
@Perl 5.12.2 from CPAN
@
text
@d9 1
a9 1
plan tests => 54;
d109 1
a109 4
{
    no warnings 'deprecated';
    is (keys(hash), 10, "keys (hash)");
}
d113 3
a115 5
{
    no warnings 'deprecated';
    @@keys = keys(h);
    @@values = values(h);
    while (($key, $value) = each(h)) {
a118 1
    }
a189 45

# test for syntax errors
for my $k (qw(each keys values)) {
    eval $k;
    like($@@, qr/^Not enough arguments for $k/, "$k demands argument");
}

{
    my %foo=(1..10);
    my ($k,$v);
    my $count=keys %foo;
    my ($k1,$v1)=each(%foo);
    my $yes = 0;
    if (%foo) { $yes++ }
    my ($k2,$v2)=each(%foo);
    my $rest=0;
    while (each(%foo)) {$rest++};
    is($yes,1,"if(%foo) was true");
    isnt($k1,$k2,"if(%foo) didnt mess with each (key)");
    isnt($v1,$v2,"if(%foo) didnt mess with each (value)");
    is($rest,3,"Got the expect number of keys");
    my $hsv=1 && %foo;
    like($hsv,'/',"Got bucket stats from %foo in scalar assignment context");
    my @@arr=%foo&&%foo;
    is(@@arr,10,"Got expected number of elements in list context");
}    
{
    our %foo=(1..10);
    my ($k,$v);
    my $count=keys %foo;
    my ($k1,$v1)=each(%foo);
    my $yes = 0;
    if (%foo) { $yes++ }
    my ($k2,$v2)=each(%foo);
    my $rest=0;
    while (each(%foo)) {$rest++};
    is($yes,1,"if(%foo) was true");
    isnt($k1,$k2,"if(%foo) didnt mess with each (key)");
    isnt($v1,$v2,"if(%foo) didnt mess with each (value)");
    is($rest,3,"Got the expect number of keys");
    my $hsv=1 && %foo;
    like($hsv,'/',"Got bucket stats from %foo in scalar assignment context");
    my @@arr=%foo&&%foo;
    is(@@arr,10,"Got expected number of elements in list context");
}    
@


1.1.1.7
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d9 1
a9 1
plan tests => 57;
a240 31
{
    # make sure a deleted active iterator gets freed timely, even if the
    # hash is otherwise empty

    package Single;

    my $c = 0;
    sub DESTROY { $c++ };

    {
	my %h = ("a" => bless []);
	my ($k,$v) = each %h;
	delete $h{$k};
	::is($c, 0, "single key not yet freed");
    }
    ::is($c, 1, "single key now freed");
}

{
    # Make sure each() does not leave the iterator in an inconsistent state
    # (RITER set to >= 0, with EITER null) if the active iterator is
    # deleted, leaving the hash apparently empty.
    my %h;
    $h{1} = 2;
    each %h;
    delete $h{1};
    each %h;
    $h{1}=2;
    is join ("-", each %h), '1-2',
	'each on apparently empty hash does not leave RITER set';
}
@


1.1.1.8
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d9 1
a9 1
plan tests => 59;
a270 19
}
{
    my $warned= 0;
    local $SIG{__WARN__}= sub {
        /\QUse of each() on hash after insertion without resetting hash iterator results in undefined behavior\E/
            and $warned++ for @@_;
    };
    my %h= map { $_ => $_ } "A".."F";
    while (my ($k, $v)= each %h) {
        $h{"$k$k"}= $v;
    }
    ok($warned,"each() after insert produces warnings");
    no warnings 'internal';
    $warned= 0;
    %h= map { $_ => $_ } "A".."F";
    while (my ($k, $v)= each %h) {
        $h{"$k$k"}= $v;
    }
    ok(!$warned, "no warnings 'internal' silences each() after insert warnings");
@


1.1.1.9
log
@Import perl-5.24.2
@
text
@d109 19
d218 1
a218 1
    like($hsv,qr[/],"Got bucket stats from %foo in scalar assignment context");
d237 1
a237 1
    like($hsv,qr[/],"Got bucket stats from %foo in scalar assignment context");
a290 10

use feature 'refaliasing';
no warnings 'experimental::refaliasing';
$a = 7;
\$h2{f} = \$a;
($a, $b) = (each %h2);
is "$a $b", "f 7", 'each in list assignment';
$a = 7;
($a, $b) = (3, values %h2);
is "$a $b", "3 7", 'values in list assignment';
@


