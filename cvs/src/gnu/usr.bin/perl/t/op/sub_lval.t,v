head	1.2;
access;
symbols
	OPENBSD_6_0:1.1.1.8.0.10
	OPENBSD_6_0_BASE:1.1.1.8
	OPENBSD_5_9:1.1.1.8.0.4
	OPENBSD_5_9_BASE:1.1.1.8
	OPENBSD_5_8:1.1.1.8.0.6
	OPENBSD_5_8_BASE:1.1.1.8
	PERL_5_20_2:1.1.1.8
	OPENBSD_5_7:1.1.1.8.0.2
	OPENBSD_5_7_BASE:1.1.1.8
	PERL_5_20_1:1.1.1.8
	OPENBSD_5_6:1.1.1.7.0.4
	OPENBSD_5_6_BASE:1.1.1.7
	PERL_5_18_2:1.1.1.7
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.6.0.6
	OPENBSD_5_5_BASE:1.1.1.6
	OPENBSD_5_4:1.1.1.6.0.2
	OPENBSD_5_4_BASE:1.1.1.6
	PERL_5_16_3:1.1.1.6
	OPENBSD_5_3:1.1.1.5.0.10
	OPENBSD_5_3_BASE:1.1.1.5
	OPENBSD_5_2:1.1.1.5.0.8
	OPENBSD_5_2_BASE:1.1.1.5
	OPENBSD_5_1_BASE:1.1.1.5
	OPENBSD_5_1:1.1.1.5.0.6
	OPENBSD_5_0:1.1.1.5.0.4
	OPENBSD_5_0_BASE:1.1.1.5
	OPENBSD_4_9:1.1.1.5.0.2
	OPENBSD_4_9_BASE:1.1.1.5
	PERL_5_12_2:1.1.1.5
	OPENBSD_4_8:1.1.1.4.0.8
	OPENBSD_4_8_BASE:1.1.1.4
	OPENBSD_4_7:1.1.1.4.0.4
	OPENBSD_4_7_BASE:1.1.1.4
	PERL_5_10_1:1.1.1.4
	OPENBSD_4_6:1.1.1.4.0.6
	OPENBSD_4_6_BASE:1.1.1.4
	OPENBSD_4_5:1.1.1.4.0.2
	OPENBSD_4_5_BASE:1.1.1.4
	PERL_5_10_0:1.1.1.4
	OPENBSD_4_4:1.1.1.3.0.10
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.8
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_2:1.1.1.3.0.6
	OPENBSD_4_2_BASE:1.1.1.3
	OPENBSD_4_1:1.1.1.3.0.4
	OPENBSD_4_1_BASE:1.1.1.3
	OPENBSD_4_0:1.1.1.3.0.2
	OPENBSD_4_0_BASE:1.1.1.3
	PERL_5_8_8:1.1.1.3
	OPENBSD_3_9:1.1.1.2.0.10
	OPENBSD_3_9_BASE:1.1.1.2
	OPENBSD_3_8:1.1.1.2.0.8
	OPENBSD_3_8_BASE:1.1.1.2
	OPENBSD_3_7:1.1.1.2.0.6
	OPENBSD_3_7_BASE:1.1.1.2
	PERL_5_8_6:1.1.1.2
	OPENBSD_3_6:1.1.1.2.0.4
	OPENBSD_3_6_BASE:1.1.1.2
	PERL_5_8_5:1.1.1.2
	PERL_5_8_3:1.1.1.2
	OPENBSD_3_5:1.1.1.2.0.2
	OPENBSD_3_5_BASE:1.1.1.2
	PERL_5_8_2:1.1.1.2
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	PERL_5_8_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.32.20;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2002.10.27.22.15.11;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.27.22.15.11;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.12.03.02.44.32;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2006.03.28.18.49.46;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2008.09.29.17.19.02;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2010.09.24.14.49.18;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2013.03.25.20.09.37;	author sthen;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2014.03.24.14.59.10;	author afresh1;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2014.11.17.20.53.18;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl

BEGIN {
    chdir 't' if -d 't';
    @@INC = '../lib';
    require './test.pl';
}
plan tests=>209;

sub a : lvalue { my $a = 34; ${\(bless \$a)} }  # Return a temporary
sub b : lvalue { ${\shift} }

my $out = a(b());		# Check that temporaries are allowed.
is(ref $out, 'main'); # Not reached if error.

my @@out = grep /main/, a(b()); # Check that temporaries are allowed.
cmp_ok(scalar @@out, '==', 1); # Not reached if error.

my $in;

# Check that we can return localized values from subroutines:

sub in : lvalue { $in = shift; }
sub neg : lvalue {  #(num_str) return num_str
    local $_ = shift;
    s/^\+/-/;
    $_;
}
in(neg("+2"));


is($in, '-2');

sub get_lex : lvalue { $in }
sub get_st : lvalue { $blah }
sub id : lvalue { ${\shift} }
sub id1 : lvalue { $_[0] }
sub inc : lvalue { ${\++$_[0]} }

$in = 5;
$blah = 3;

get_st = 7;

cmp_ok($blah, '==', 7);

get_lex = 7;

cmp_ok($in, '==', 7);

++get_st;

cmp_ok($blah, '==', 8);

++get_lex;

cmp_ok($in, '==', 8);

id(get_st) = 10;

cmp_ok($blah, '==', 10);

id(get_lex) = 10;

cmp_ok($in, '==', 10);

++id(get_st);

cmp_ok($blah, '==', 11);

++id(get_lex);

cmp_ok($in, '==', 11);

id1(get_st) = 20;

cmp_ok($blah, '==', 20);

id1(get_lex) = 20;

cmp_ok($in, '==', 20);

++id1(get_st);

cmp_ok($blah, '==', 21);

++id1(get_lex);

cmp_ok($in, '==', 21);

inc(get_st);

cmp_ok($blah, '==', 22);

inc(get_lex);

cmp_ok($in, '==', 22);

inc(id(get_st));

cmp_ok($blah, '==', 23);

inc(id(get_lex));

cmp_ok($in, '==', 23);

++inc(id1(id(get_st)));

cmp_ok($blah, '==', 25);

++inc(id1(id(get_lex)));

cmp_ok($in, '==', 25);

@@a = (1) x 3;
@@b = (undef) x 2;
$#c = 3;			# These slots are not fillable.

# Explanation: empty slots contain &sv_undef.

=for disabled constructs

sub a3 :lvalue {@@a}
sub b2 : lvalue {@@b}
sub c4: lvalue {@@c}

$_ = '';

eval <<'EOE' or $_ = $@@;
  ($x, a3, $y, b2, $z, c4, $t) = (34 .. 78);
  1;
EOE

#@@out = ($x, a3, $y, b2, $z, c4, $t);
#@@in = (34 .. 41, (undef) x 4, 46);
#print "# '@@out' ne '@@in'\nnot " unless "@@out" eq "@@in";

like($_, qr/Can\'t return an uninitialized value from lvalue subroutine/);
print "ok 22\n";

=cut


my $var;

sub a::var : lvalue { $var }

"a"->var = 45;

cmp_ok($var, '==', 45);

my $oo;
$o = bless \$oo, "a";

$o->var = 47;

cmp_ok($var, '==', 47);

sub o : lvalue { $o }

o->var = 49;

cmp_ok($var, '==', 49);

sub nolv () { $x0, $x1 } # Not lvalue

$_ = '';

eval <<'EOE' or $_ = $@@;
  nolv = (2,3);
  1;
EOE

like($_, qr/Can\'t modify non-lvalue subroutine call of &main::nolv in scalar assignment/);

$_ = '';

eval <<'EOE' or $_ = $@@;
  nolv = (2,3) if $_;
  1;
EOE

like($_, qr/Can\'t modify non-lvalue subroutine call of &main::nolv in scalar assignment/);

$_ = '';

eval <<'EOE' or $_ = $@@;
  &nolv = (2,3) if $_;
  1;
EOE

like($_, qr/Can\'t modify non-lvalue subroutine call of &main::nolv in scalar assignment/);

$x0 = $x1 = $_ = undef;
$nolv = \&nolv;

eval <<'EOE' or $_ = $@@;
  $nolv->() = (2,3) if $_;
  1;
EOE

ok(!defined $_) or diag "'$_', '$x0', '$x1'";

$x0 = $x1 = $_ = undef;
$nolv = \&nolv;

eval <<'EOE' or $_ = $@@;
  $nolv->() = (2,3);
  1;
EOE

like($_, qr/Can\'t modify non-lvalue subroutine call/)
  or diag "'$_', '$x0', '$x1'";

sub lv0 : lvalue { }
sub rlv0 : lvalue { return }

$_ = undef;
eval <<'EOE' or $_ = $@@;
  lv0 = (2,3);
  1;
EOE

like($_, qr/Can't return undef from lvalue subroutine/);

$_ = undef;
eval <<'EOE' or $_ = $@@;
  rlv0 = (2,3);
  1;
EOE

like($_, qr/Can't return undef from lvalue subroutine/,
    'explicit return of nothing in scalar context');

$_ = undef;
eval <<'EOE' or $_ = $@@;
  (lv0) = (2,3);
  1;
EOE

ok(!defined $_) or diag $_;

$_ = undef;
eval <<'EOE' or $_ = $@@;
  (rlv0) = (2,3);
  1;
EOE

ok(!defined $_, 'explicit return of nothing in list context') or diag $_;

($a,$b)=();
(lv0($a,$b)) = (3,4);
is +($a//'undef') . ($b//'undef'), 'undefundef',
   'list assignment to empty lvalue sub';


sub lv1u :lvalue { undef }
sub rlv1u :lvalue { undef }

$_ = undef;
eval <<'EOE' or $_ = $@@;
  lv1u = (2,3);
  1;
EOE

like($_, qr/Can't return undef from lvalue subroutine/);

$_ = undef;
eval <<'EOE' or $_ = $@@;
  rlv1u = (2,3);
  1;
EOE

like($_, qr/Can't return undef from lvalue subroutine/,
     'explicitly returning undef in scalar context');

$_ = undef;
eval <<'EOE' or $_ = $@@;
  (lv1u) = (2,3);
  1;
EOE

ok(!defined, 'implicitly returning undef in list context');

$_ = undef;
eval <<'EOE' or $_ = $@@;
  (rlv1u) = (2,3);
  1;
EOE

ok(!defined, 'explicitly returning undef in list context');

$x = '1234567';

$_ = undef;
eval <<'EOE' or $_ = $@@;
  sub lv1t : lvalue { index $x, 2 }
  lv1t = (2,3);
  1;
EOE

like($_, qr/Can\'t return a temporary from lvalue subroutine/);

$_ = undef;
eval <<'EOE' or $_ = $@@;
  sub rlv1t : lvalue { index $x, 2 }
  rlv1t = (2,3);
  1;
EOE

like($_, qr/Can\'t return a temporary from lvalue subroutine/,
    'returning a PADTMP explicitly');

$_ = undef;
eval <<'EOE' or $_ = $@@;
  (rlv1t) = (2,3);
  1;
EOE

like($_, qr/Can\'t return a temporary from lvalue subroutine/,
    'returning a PADTMP explicitly (list context)');

# These next two tests are not necessarily normative.  But this way we will
# know if this discrepancy changes.

$_ = undef;
eval <<'EOE' or $_ = $@@;
  sub scalarray : lvalue { @@a || $b }
  @@a = 1;
  (scalarray) = (2,3);
  1;
EOE

like($_, qr/Can\'t return a temporary from lvalue subroutine/,
    'returning a scalar-context array via ||');

$_ = undef;
eval <<'EOE' or $_ = $@@;
  use warnings "FATAL" => "all";
  sub myscalarray : lvalue { my @@a = 1; @@a || $b }
  (myscalarray) = (2,3);
  1;
EOE

like($_, qr/Useless assignment to a temporary/,
    'returning a scalar-context lexical array via ||');

$_ = undef;
sub lv2t : lvalue { shift }
(lv2t($_)) = (2,3);
is($_, 2);

$xxx = 'xxx';
sub xxx () { $xxx }  # Not lvalue

$_ = undef;
eval <<'EOE' or $_ = $@@;
  sub lv1tmp : lvalue { xxx }			# is it a TEMP?
  lv1tmp = (2,3);
  1;
EOE

like($_, qr/Can\'t modify non-lvalue subroutine call of &main::xxx at /);

$_ = undef;
eval <<'EOE' or $_ = $@@;
  (lv1tmp) = (2,3);
  1;
EOE

like($_, qr/Can\'t modify non-lvalue subroutine call of &main::xxx at /);

sub yyy () { 'yyy' } # Const, not lvalue

$_ = undef;
eval <<'EOE' or $_ = $@@;
  sub lv1tmpr : lvalue { yyy }			# is it read-only?
  lv1tmpr = (2,3);
  1;
EOE

like($_, qr/Can\'t return a readonly value from lvalue subroutine at/);

$_ = undef;
eval <<'EOE' or $_ = $@@;
  (lv1tmpr) = (2,3);
  1;
EOE

like($_, qr/Can\'t return a readonly value from lvalue subroutine/);

eval <<'EOF';
  sub lv2tmpr : lvalue { my $x = *foo; Internals::SvREADONLY $x, 1; $x }
  lv2tmpr = (2,3);
EOF

like($@@, qr/Can\'t return a readonly value from lvalue subroutine at/);

eval <<'EOG';
  (lv2tmpr) = (2,3);
EOG

like($@@, qr/Can\'t return a readonly value from lvalue subroutine/);

sub lva : lvalue {@@a}

$_ = undef;
@@a = ();
$a[1] = 12;
eval <<'EOE' or $_ = $@@;
  (lva) = (2,3);
  1;
EOE

is("'@@a' $_", "'2 3' ");

$_ = undef;
@@a = ();
$a[0] = undef;
$a[1] = 12;
eval <<'EOE' or $_ = $@@;
  (lva) = (2,3);
  1;
EOE

is("'@@a' $_", "'2 3' ");

is lva->${\sub { return $_[0] }}, 2,
  'lvalue->$thing when lvalue returns array';

my @@my = qw/ a b c /;
sub lvmya : lvalue { @@my }

is lvmya->${\sub { return $_[0] }}, 3,
  'lvalue->$thing when lvalue returns lexical array';

sub lv1n : lvalue { $newvar }

$_ = undef;
eval <<'EOE' or $_ = $@@;
  lv1n = (3,4);
  1;
EOE

is("'$newvar' $_", "'4' ");

sub lv1nn : lvalue { $nnewvar }

$_ = undef;
eval <<'EOE' or $_ = $@@;
  (lv1nn) = (3,4);
  1;
EOE

is("'$nnewvar' $_", "'3' ");

$a = \&lv1nn;
$a->() = 8;
is($nnewvar, '8');

eval 'sub AUTOLOAD : lvalue { $newvar }';
foobar() = 12;
is($newvar, "12");

# But autoloading should only be triggered by a call to an undefined
# subroutine.
&{"lv1nn"} = 14;
is $newvar, 12, 'AUTOLOAD does not take precedence over lvalue sub';
eval { &{"xxx"} = 14 };
is $newvar, 12, 'AUTOLOAD does not take precedence over non-lvalue sub';

{
my %hash; my @@array;
sub alv : lvalue { $array[1] }
sub alv2 : lvalue { $array[$_[0]] }
sub hlv : lvalue { $hash{"foo"} }
sub hlv2 : lvalue { $hash{$_[0]} }
$array[1] = "not ok 51\n";
alv() = "ok 50\n";
is(alv(), "ok 50\n");

alv2(20) = "ok 51\n";
is($array[20], "ok 51\n");

$hash{"foo"} = "not ok 52\n";
hlv() = "ok 52\n";
is($hash{foo}, "ok 52\n");

$hash{bar} = "not ok 53\n";
hlv("bar") = "ok 53\n";
is(hlv("bar"), "ok 53\n");

sub array : lvalue  { @@array  }
sub array2 : lvalue { @@array2 } # This is a global.
sub hash : lvalue   { %hash   }
sub hash2 : lvalue  { %hash2  } # So's this.
@@array2 = qw(foo bar);
%hash2 = qw(foo bar);

(array()) = qw(ok 54);
is("@@array", "ok 54");

(array2()) = qw(ok 55);
is("@@array2", "ok 55");

(hash()) = qw(ok 56);
cmp_ok($hash{ok}, '==', 56);

(hash2()) = qw(ok 57);
cmp_ok($hash2{ok}, '==', 57);

@@array = qw(a b c d);
sub aslice1 : lvalue { @@array[0,2] };
(aslice1()) = ("ok", "already");
is("@@array", "ok b already d");

@@array2 = qw(a B c d);
sub aslice2 : lvalue { @@array2[0,2] };
(aslice2()) = ("ok", "already");
is("@@array2", "ok B already d");

%hash = qw(a Alpha b Beta c Gamma);
sub hslice : lvalue { @@hash{"c", "b"} }
(hslice()) = ("CISC", "BogoMIPS");
is(join("/",@@hash{"c","a","b"}), "CISC/Alpha/BogoMIPS");
}

$str = "Hello, world!";
sub sstr : lvalue { substr($str, 1, 4) }
sstr() = "i";
is($str, "Hi, world!");

$str = "Made w/ JavaScript";
sub veclv : lvalue { vec($str, 2, 32) }
if ($::IS_ASCII) {
    veclv() = 0x5065726C;
}
else { # EBCDIC?
    veclv() = 0xD7859993;
}
is($str, "Made w/ PerlScript");

sub position : lvalue { pos }
@@p = ();
$_ = "fee fi fo fum";
while (/f/g) {
    push @@p, position;
    position() += 6;
}
is("@@p", "1 8");

sub keeze : lvalue { keys %__ }
%__ = ("a","b");
keeze = 64;
is scalar %__, '1/64', 'keys assignment through lvalue sub';

# Bug 20001223.002: split thought that the list had only one element
@@ary = qw(4 5 6);
sub lval1 : lvalue { $ary[0]; }
sub lval2 : lvalue { $ary[1]; }
(lval1(), lval2()) = split ' ', "1 2 3 4";

is(join(':', @@ary), "1:2:6");

# check that an element of a tied hash/array can be assigned to via lvalueness

package Tie_Hash;

our ($key, $val);
sub TIEHASH { bless \my $v => __PACKAGE__ }
sub STORE   { ($key, $val) = @@_[1,2] }

package main;
sub lval_tie_hash : lvalue {
    tie my %t => 'Tie_Hash';
    $t{key};
}

eval { lval_tie_hash() = "value"; };

is($@@, "", "element of tied hash");

is("$Tie_Hash::key-$Tie_Hash::val", "key-value");


package Tie_Array;

our @@val;
sub TIEARRAY { bless \my $v => __PACKAGE__ }
sub STORE   { $val[ $_[1] ] = $_[2] }

package main;
sub lval_tie_array : lvalue {
    tie my @@t => 'Tie_Array';
    $t[0];
}

eval { lval_tie_array() = "value"; };


is($@@, "", "element of tied array");

is ($Tie_Array::val[0], "value");


# Check that tied pad vars that are returned can be assigned to
sub TIESCALAR { bless [] }
sub STORE {$wheel = $_[1]}
sub FETCH {$wheel}
sub tied_pad_var  :lvalue { tie my $tyre, ''; $tyre }
sub tied_pad_varr :lvalue { tie my $tyre, ''; return $tyre }
tied_pad_var = 1;
is $wheel, 1, 'tied pad var returned in scalar lvalue context';
tied_pad_var->${\sub{ $_[0] = 2 }};
is $wheel, 2, 'tied pad var returned in scalar ref context';
(tied_pad_var) = 3;
is $wheel, 3, 'tied pad var returned in list lvalue context';
$_ = 4 for tied_pad_var;
is $wheel, 4, 'tied pad var returned in list ref context';
tied_pad_varr = 5;
is $wheel, 5, 'tied pad var explicitly returned in scalar lvalue context';
tied_pad_varr->${\sub{ $_[0] = 6 }};
is $wheel, 6, 'tied pad var explicitly returned in scalar ref context';
(tied_pad_varr) = 7;
is $wheel, 7, 'tied pad var explicitly returned in list lvalue context';
$_ = 8 for tied_pad_varr;
is $wheel, 8, 'tied pad var explicitly returned in list ref context';


# Test explicit return of lvalue expression
{
    # subs are copies from tests 1-~18 with an explicit return added.
    # They used not to work, which is why they are ‘badly’ named.
    sub bad_get_lex : lvalue { return $in };
    sub bad_get_st  : lvalue { return $blah }

    sub bad_id  : lvalue { return ${\shift} }
    sub bad_id1 : lvalue { return $_[0] }
    sub bad_inc : lvalue { return ${\++$_[0]} }

    $in = 5;
    $blah = 3;

    bad_get_st = 7;

    is( $blah, 7 );

    bad_get_lex = 7;

    is($in, 7, "yada");

    ++bad_get_st;

    is($blah, 8, "yada");

    ++bad_get_lex;
    cmp_ok($in, '==', 8);

    bad_id(bad_get_st) = 10;
    cmp_ok($blah, '==', 10);

    bad_id(bad_get_lex) = 10;
    cmp_ok($in, '==', 10);

    ++bad_id(bad_get_st);
    cmp_ok($blah, '==', 11);

    ++bad_id(bad_get_lex);
    cmp_ok($in, '==', 11);

    bad_id1(bad_get_st) = 20;
    cmp_ok($blah, '==', 20);

    bad_id1(bad_get_lex) = 20;
    cmp_ok($in, '==', 20);

    ++bad_id1(bad_get_st);
    cmp_ok($blah, '==', 21);

    ++bad_id1(bad_get_lex);
    cmp_ok($in, '==', 21);

    bad_inc(bad_get_st);
    cmp_ok($blah, '==', 22);

    bad_inc(bad_get_lex);
    cmp_ok($in, '==', 22);

    bad_inc(bad_id(bad_get_st));
    cmp_ok($blah, '==', 23);

    bad_inc(bad_id(bad_get_lex));
    cmp_ok($in, '==', 23);

    ++bad_inc(bad_id1(bad_id(bad_get_st)));
    cmp_ok($blah, '==', 25);

    ++bad_inc(bad_id1(bad_id(bad_get_lex)));
    cmp_ok($in, '==', 25);

    # Recursive
    my $r;
    my $to_modify;
    $r = sub :lvalue {
      my $depth = shift//0;
      if ($depth == 2) { return $to_modify }
      return &$r($depth+1);
    };
    &$r(0) = 7;
    is $to_modify, 7, 'recursive lvalue sub';

    # Recursive with substr [perl #72706]
    my $val = '';
    my $pie;
    $pie = sub :lvalue {
	my $depth = shift;
	return &$pie($depth) if $depth--;
	substr $val, 0;
    };
    for my $depth (0, 1, 2) {
	my $value = "Good $depth";
	eval {
	    &$pie($depth) = $value;
	};
	is($@@, '', "recursive lvalue substr return depth $depth");
	is($val, $value,
	   "value assigned to recursive lvalue substr (depth $depth)");
    }
}

{ # bug #23790
    my @@arr  = qw /one two three/;
    my $line = "zero";
    sub lval_array () : lvalue {@@arr}

    for (lval_array) {
        $line .= $_;
    }

    is($line, "zeroonetwothree");

    sub trythislval { scalar(@@_)."x".join "", @@_ }
    is(trythislval(lval_array()), "3xonetwothree");

    sub changeme { $_[2] = "free" }
    changeme(lval_array);
    is("@@arr", "one two free");

    # test again, with explicit return
    sub rlval_array() : lvalue {return @@arr}
    @@arr  = qw /one two three/;
    $line = "zero";
    for (rlval_array) {
        $line .= $_;
    }
    is($line, "zeroonetwothree");
    is(trythislval(rlval_array()), "3xonetwothree");
    changeme(rlval_array);
    is("@@arr", "one two free");

    # Variations on the same theme, with multiple vars returned
    my $scalar = 'half';
    sub lval_scalar_array () : lvalue { $scalar, @@arr }
    @@arr  = qw /one two three/;
    $line = "zero";
    for (lval_scalar_array) {
        $line .= $_;
    }
    is($line, "zerohalfonetwothree");
    is(trythislval(lval_scalar_array()), "4xhalfonetwothree");
    changeme(lval_scalar_array);
    is("@@arr", "one free three");

    sub lval_array_scalar () : lvalue { @@arr, $scalar }
    @@arr  = qw /one two three/;
    $line = "zero";
    $scalar = 'four';
    for (lval_array_scalar) {
        $line .= $_;
    }
    is($line, "zeroonetwothreefour");
    is(trythislval(lval_array_scalar()), "4xonetwothreefour");
    changeme(lval_array_scalar);
    is("@@arr", "one two free");

    # Tests for specific ops not tested above
    # rv2av
    @@array2 = qw 'one two free';
    is join(',', map $_, sub:lvalue{@@array2}->()), 'one,two,free',
      'rv2av in reference context';
    is join(',', map $_, sub:lvalue{@@{\@@array2}}->()), 'one,two,free',
      'rv2av-with-ref in reference context';
    # padhv
    my %hash = qw[a b c d];
    like join(',', map $_, sub:lvalue{%hash}->()),
         qr/^(?:a,b,c,d|c,d,a,b)\z/, 'padhv in reference context';
    # rv2hv
    %hash2 = qw[a b c d];
    like join(',', map $_, sub:lvalue{%hash2}->()),
         qr/^(?:a,b,c,d|c,d,a,b)\z/, 'rv2hv in reference context';
    like join(',', map $_, sub:lvalue{%{\%hash2}}->()),
         qr/^(?:a,b,c,d|c,d,a,b)\z/, 'rv2hv-with-ref in reference context';
}

{
    package Foo;
    sub AUTOLOAD :lvalue { *{$AUTOLOAD} };
    package main;
    my $foo = bless {},"Foo";
    my $result;
    $foo->bar = sub { $result = "bar" };
    $foo->bar;
    is ($result, 'bar', "RT #41550");
}

SKIP: { skip 'no attributes.pm', 1 unless eval 'require attributes';
fresh_perl_is(<<'----', <<'====', {}, "lvalue can not be set after definition. [perl #68758]");
use warnings;
our $x;
sub foo { $x }
sub foo : lvalue;
sub MODIFY_CODE_ATTRIBUTES {}
sub foo : lvalue : fr0g;
foo = 3;
----
lvalue attribute ignored after the subroutine has been defined at - line 4.
lvalue attribute ignored after the subroutine has been defined at - line 6.
Can't modify non-lvalue subroutine call of &main::foo in scalar assignment at - line 7, near "3;"
Execution of - aborted due to compilation errors.
====
}

{
    my $x;
    sub lval_decl : lvalue;
    sub lval_decl { $x }
    lval_decl = 5;
    is($x, 5, "subroutine declared with lvalue before definition retains lvalue. [perl #68758]");
}

SKIP: { skip "no attributes.pm", 2 unless eval { require attributes };
  sub utf8::valid :lvalue;
  require attributes;
  is "@@{[ &attributes::get(\&utf8::valid) ]}", 'lvalue',
   'sub declaration with :lvalue applies it to XSUBs';

  BEGIN { *wonky = \&marjibberous }
  sub wonky :lvalue;
  is "@@{[ &attributes::get(\&wonky) ]}", 'lvalue',
   'sub declaration with :lvalue applies it to assigned stub';
}

sub fleen : lvalue { $pnare }
$pnare = __PACKAGE__;
ok eval { fleen = 1 }, "lvalues can return COWs (CATTLE?) [perl #75656]";\
is $pnare, 1, 'and returning CATTLE actually works';
$pnare = __PACKAGE__;
ok eval { (fleen) = 1 }, "lvalues can return COWs in list context";
is $pnare, 1, 'and returning COWs in list context actually works';
$pnare = __PACKAGE__;
ok eval { $_ = 1 for(fleen); 1 }, "lvalues can return COWs in ref cx";
is $pnare, 1, 'and returning COWs in reference context actually works';


# Returning an arbitrary expression, not necessarily lvalue
+sub :lvalue { return $ambaga || $ambaga }->() = 73;
is $ambaga, 73, 'explicit return of arbitrary expression (scalar context)';
(sub :lvalue { return $ambaga || $ambaga }->()) = 74;
is $ambaga, 74, 'explicit return of arbitrary expression (list context)';
+sub :lvalue { $ambaga || $ambaga }->() = 73;
is $ambaga, 73, 'implicit return of arbitrary expression (scalar context)';
(sub :lvalue { $ambaga || $ambaga }->()) = 74;
is $ambaga, 74, 'implicit return of arbitrary expression (list context)';
eval { +sub :lvalue { return 3 }->() = 4 };
like $@@, qr/Can\'t return a readonly value from lvalue subroutine at/,
      'assignment to numeric constant explicitly returned from lv sub';
eval { (sub :lvalue { return 3 }->()) = 4 };
like $@@, qr/Can\'t return a readonly value from lvalue subroutine at/,
      'assignment to num constant explicitly returned (list cx)';
eval { +sub :lvalue { 3 }->() = 4 };
like $@@, qr/Can\'t return a readonly value from lvalue subroutine at/,
      'assignment to numeric constant implicitly returned from lv sub';
eval { (sub :lvalue { 3 }->()) = 4 };
like $@@, qr/Can\'t return a readonly value from lvalue subroutine at/,
      'assignment to num constant implicitly returned (list cx)';

# reference (potential lvalue) context
$suffix = '';
for my $sub (sub :lvalue {$_}, sub :lvalue {return $_}) {
    &$sub()->${\sub { $_[0] = 37 }};
    is $_, '37', 'lvalue->method'.$suffix;
    ${\scalar &$sub()} = 38;
    is $_, '38', 'scalar(lvalue)'.$suffix;
    sub assign39_with_proto ($) { $_[0] = 39 }
    assign39_with_proto(&$sub());
    is $_, '39', 'func(lvalue) when func has $ proto'.$suffix;
    $_ = 1;
    ${\(&$sub()||undef)} = 40;
    is $_, '40', 'lvalue||...'.$suffix;
    ${\(${\undef}||&$sub())} = 41; # extra ${\...} to bypass const folding
    is $_, '41', '...||lvalue'.$suffix;
    $_ = 0;
    ${\(&$sub()&&undef)} = 42;
    is $_, '42', 'lvalue&&...'.$suffix;
    ${\(${\1}&&&$sub())} = 43;
    is $_, '43', '...&&lvalue'.$suffix;
    ${\(&$sub())[0]} = 44;
    is $_, '44', '(lvalue)[0]'.$suffix;
}
continue { $suffix = ' (explicit return)' }

# autovivification
$suffix = '';
for my $sub (sub :lvalue {$_}, sub :lvalue {return $_}) {
    undef $_;
    &$sub()->[3] = 4;
    is $_->[3], 4, 'func->[...] autovivification'.$suffix;
    undef $_;
    &$sub()->{3} = 4;
    is $_->{3}, 4, 'func->{...} autovivification'.$suffix;
    undef $_;
    ${&$sub()} = 4;
    is $$_, 4, '${func()} autovivification'      .$suffix;
    undef $_;
    @@{&$sub()} = 4;
    is "@@$_", 4, '@@{func()} autovivification'    .$suffix;
    undef $_;
    %{&$sub()} = (4,5);
    is join('-',%$_), '4-5', '%{func()} autovivification'.$suffix;
    undef $_;
    ${ (), &$sub()} = 4;
    is $$_, 4, '${ (), func()} autovivification'      .$suffix;
}
continue { $suffix = ' (explicit return)' }

# [perl #92406] [perl #92290] Returning a pad var in rvalue context
$suffix = '';
for my $sub (
         sub :lvalue { my $x = 72; $x },
         sub :lvalue { my $x = 72; return $x }
) {
    is scalar(&$sub), 72, "sub returning pad var in scalar context$suffix";
    is +(&$sub)[0], 72, "sub returning pad var in list context$suffix";
}
continue { $suffix = ' (explicit return)' }

# Returning read-only values in reference context
$suffix = '';
for (
         sub :lvalue { $] }->(),
         sub :lvalue { return $] }->()
) {
    is \$_, \$], 'read-only values are returned in reference context'
	         .$suffix             # (they used to be copied)
}
continue { $suffix = ' (explicit return)' }

# Returning unwritables from nested lvalue sub call in in rvalue context
# First, ensure we are testing what we think we are:
if (!Internals::SvREADONLY($])) { Internals::SvREADONLY($],1); }
sub squibble : lvalue { return $] }
sub squebble : lvalue {        squibble }
sub squabble : lvalue { return squibble }
is $x = squebble, $], 'returning ro from nested lv sub call in rv cx';
is $x = squabble, $], 'explct. returning ro from nested lv sub in rv cx';
is \squebble, \$], 'returning ro from nested lv sub call in ref cx';
is \squabble, \$], 'explct. returning ro from nested lv sub in ref cx';

# [perl #102486] Sub calls as the last statement of an lvalue sub
package _102486 {
  my $called;
  my $x = 'nonlv';
  sub strictlv :lvalue { use strict 'refs'; &$x }
  sub lv :lvalue { &$x }
  sub nonlv { ++$called }
  eval { strictlv };
  ::like $@@, qr/^Can't use string \("nonlv"\) as a subroutine ref while/,
        'strict mode applies to sub:lvalue{ &$string }';
  $called = 0;
  ::ok eval { lv },
      'sub:lvalue{&$x}->() does not die for non-lvalue inner sub call';
  ::is $called, 1, 'The &$x actually called the sub';
  eval { +sub :lvalue { &$x }->() = 3 };
  ::like $@@, qr/^Can't modify non-lvalue subroutine call of &_102486::nonlv at /,
        'sub:lvalue{&$x}->() dies in true lvalue context';
}

# TARG should be copied in rvalue context
sub ucf :lvalue { ucfirst $_[0] }
is ucf("just another ") . ucf("perl hacker,\n"),
   "Just another Perl hacker,\n", 'TARG is copied in rvalue scalar cx';
is join('',ucf("just another "), ucf "perl hacker,\n"),
   "Just another Perl hacker,\n", 'TARG is copied in rvalue list cx';
sub ucfr : lvalue {
    @@_ ? ucfirst $_[0] : do {
	is ucfr("just another ") . ucfr("perl hacker,\n"),
	   "Just another Perl hacker,\n",
	   'TARG is copied in recursive rvalue scalar cx';
	is join('',ucfr("just another "), ucfr("perl hacker,\n")),
	   "Just another Perl hacker,\n",
	   'TARG is copied in recursive rvalue list cx';
    }
}
ucfr();

# Test TARG with potential lvalue context, too
for (sub : lvalue { "$x" }->()) {
    is \$_, \$_, '\$_ == \$_ in for(sub :lvalue{"$x"}->()){...}'
}

# [perl #117947] XSUBs should not be treated as lvalues at run time
eval { &{\&utf8::is_utf8}("") = 3 };
like $@@, qr/^Can't modify non-lvalue subroutine call of &utf8::is_utf8 at /,
        'XSUB not seen at compile time dies in lvalue context';

# [perl #119797] else implicitly returning value
# This used to cause Bizarre copy of ARRAY in pp_leave
sub else119797 : lvalue {
    if ($_[0]) {
	1; # two statements force a leave op
	@@119797
    }
    else {
	@@119797
    }
}
eval { (else119797(0)) = 1..3 };
is $@@, "", '$@@ after writing to array returned by else';
is "@@119797", "1 2 3", 'writing to array returned by else';
eval { (else119797(1)) = 4..6 };
is $@@, "", '$@@ after writing to array returned by if (with else)';
is "@@119797", "4 5 6", 'writing to array returned by if (with else)';
sub if119797 : lvalue {
    if ($_[0]) {
	@@119797
    }
}
@@119797 = ();
eval { (if119797(1)) = 4..6 };
is $@@, "", '$@@ after writing to array returned by if';
is "@@119797", "4 5 6", 'writing to array returned by if';
sub unless119797 : lvalue {
    unless ($_[0]) {
	@@119797
    }
}
@@119797 = ();
eval { (unless119797(0)) = 4..6 };
is $@@, "", '$@@ after writing to array returned by unless';
is "@@119797", "4 5 6", 'writing to array returned by unless';
sub bare119797 : lvalue {
    {;
	@@119797
    }
}
@@119797 = ();
eval { (bare119797(0)) = 4..6 };
is $@@, "", '$@@ after writing to array returned by bare block';
is "@@119797", "4 5 6", 'writing to array returned by bare block';

# a sub with nested scopes must pop rubbish on the stack
{
    my $x = "a";
    sub loopreturn : lvalue {
        for (1,2) {
            return $x
        }
    }
    loopreturn = "b";
    is($x, "b", "loopreturn");
}

# a sub without nested scopes that still leaves rubbish on the stack
# which needs popping
{
    my $x = "a";
    sub junkreturn : lvalue {
        my $false;
        return $x unless $false and $false;
        1;
    }
    junkreturn = "b";
    is($x, "b", "junkreturn");
}
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
print "1..67\n";
d6 1
d8 1
d14 1
a14 2
print "# `$out'\nnot " unless ref $out eq 'main'; # Not reached if error.
print "ok 1\n";
d17 1
a17 2
print "# `@@out'\nnot " unless @@out==1; # Not reached if error.
print "ok 2\n";
d32 1
a32 2
print "# `$in'\nnot " unless $in eq '-2';
print "ok 3\n";
d45 1
a45 2
print "# `$blah' ne 7\nnot " unless $blah == 7;
print "ok 4\n";
d49 1
a49 2
print "# `$in' ne 7\nnot " unless $in == 7;
print "ok 5\n";
d53 1
a53 2
print "# `$blah' ne 8\nnot " unless $blah == 8;
print "ok 6\n";
d57 1
a57 2
print "# `$in' ne 8\nnot " unless $in == 8;
print "ok 7\n";
d61 1
a61 2
print "# `$blah' ne 10\nnot " unless $blah == 10;
print "ok 8\n";
d65 1
a65 2
print "# `$in' ne 10\nnot " unless $in == 10;
print "ok 9\n";
d69 1
a69 2
print "# `$blah' ne 11\nnot " unless $blah == 11;
print "ok 10\n";
d73 1
a73 2
print "# `$in' ne 11\nnot " unless $in == 11;
print "ok 11\n";
d77 1
a77 2
print "# `$blah' ne 20\nnot " unless $blah == 20;
print "ok 12\n";
d81 1
a81 2
print "# `$in' ne 20\nnot " unless $in == 20;
print "ok 13\n";
d85 1
a85 2
print "# `$blah' ne 21\nnot " unless $blah == 21;
print "ok 14\n";
d89 1
a89 2
print "# `$in' ne 21\nnot " unless $in == 21;
print "ok 15\n";
d93 1
a93 2
print "# `$blah' ne 22\nnot " unless $blah == 22;
print "ok 16\n";
d97 1
a97 2
print "# `$in' ne 22\nnot " unless $in == 22;
print "ok 17\n";
d101 1
a101 2
print "# `$blah' ne 23\nnot " unless $blah == 23;
print "ok 18\n";
d105 1
a105 2
print "# `$in' ne 23\nnot " unless $in == 23;
print "ok 19\n";
d109 1
a109 2
print "# `$blah' ne 25\nnot " unless $blah == 25;
print "ok 20\n";
d113 1
a113 2
print "# `$in' ne 25\nnot " unless $in == 25;
print "ok 21\n";
d136 4
a139 1
#print "# `@@out' ne `@@in'\nnot " unless "@@out" eq "@@in";
a140 2
print "# '$_'.\nnot "
  unless /Can\'t return an uninitialized value from lvalue subroutine/;
a142 1
print "ok 22\n";
d150 1
a150 2
print "# `$var' ne 45\nnot " unless $var == 45;
print "ok 23\n";
d157 1
a157 2
print "# `$var' ne 47\nnot " unless $var == 47;
print "ok 24\n";
d163 1
a163 2
print "# `$var' ne 49\nnot " unless $var == 49;
print "ok 25\n";
d174 1
a174 3
print "not "
  unless /Can\'t modify non-lvalue subroutine call in scalar assignment/;
print "ok 26\n";
d183 1
a183 3
print "not "
  unless /Can\'t modify non-lvalue subroutine call in scalar assignment/;
print "ok 27\n";
d192 1
a192 3
print "not "
  unless /Can\'t modify non-lvalue subroutine call in scalar assignment/;
print "ok 28\n";
d202 1
a202 2
print "# '$_', '$x0', '$x1'.\nnot " if defined $_;
print "ok 29\n";
d212 2
a213 3
print "# '$_', '$x0', '$x1'.\nnot "
  unless /Can\'t modify non-lvalue subroutine call/;
print "ok 30\n";
d215 2
a216 1
sub lv0 : lvalue { }		# Converted to lv10 in scalar context
d224 7
a230 3
print "# '$_'.\nnot "
  unless /Empty array returned from lvalue subroutine in scalar context/;
print "ok 31\n";
d232 2
a233 1
sub lv10 : lvalue {}
d241 15
a255 2
print "# '$_'.\nnot " if defined $_;
print "ok 32\n";
d258 1
d266 10
a275 3
print "# '$_'.\nnot "
  unless /Can\'t return a readonly value from lvalue subroutine/;
print "ok 33\n";
d283 9
a291 4
# Fixed by change @@10777
#print "# '$_'.\nnot "
#  unless /Can\'t return an uninitialized value from lvalue subroutine/;
print "ok 34 # Skip: removed test\n";
d302 34
a335 3
print "# '$_'.\nnot "
  unless /Can\'t modify index in lvalue subroutine return/;
print "ok 35\n";
d339 3
a341 2
  sub lv2t : lvalue { shift }
  (lv2t) = (2,3);
d345 7
a351 3
print "# '$_'.\nnot "
  unless /Can\'t modify shift in lvalue subroutine return/;
print "ok 36\n";
d363 1
a363 3
print "# '$_'.\nnot "
  unless /Can\'t modify non-lvalue subroutine call in lvalue subroutine return/;
print "ok 37\n";
d371 1
a371 3
print "# '$_'.\nnot "
  unless /Can\'t return a temporary from lvalue subroutine/;
print "ok 38\n";
d382 1
a382 3
print "# '$_'.\nnot "
  unless /Can\'t modify constant item in lvalue subroutine return/;
print "ok 39\n";
d390 14
a403 3
print "# '$_'.\nnot "
  unless /Can\'t return a readonly value from lvalue subroutine/;
print "ok 40\n";
d415 1
a415 2
print "# '$_'.\nnot " unless "'@@a' $_" eq "'2 3' ";
print "ok 41\n";
d426 1
a426 2
print "# '$_'.\nnot " unless "'@@a' $_" eq "'2 3' ";
print "ok 42\n";
d428 5
a432 8
$_ = undef;
@@a = ();
$a[0] = undef;
$a[1] = 12;
eval <<'EOE' or $_ = $@@;
  (lva) = (2,3);
  1;
EOE
d434 2
a435 2
print "# '$_'.\nnot " unless "'@@a' $_" eq "'2 3' ";
print "ok 43\n";
d445 1
a445 2
print "# '$_', '$newvar'.\nnot " unless "'$newvar' $_" eq "'4' ";
print "ok 44\n";
d455 1
a455 2
print "# '$_'.\nnot " unless "'$nnewvar' $_" eq "'3' ";
print "ok 45\n";
d459 1
a459 2
print "# '$nnewvar'.\nnot " unless $nnewvar eq '8';
print "ok 46\n";
d461 1
a461 4
# This must happen at run time
eval {
    sub AUTOLOAD : lvalue { $newvar };
};
d463 1
a463 2
print "# '$newvar'.\nnot " unless $newvar eq "12";
print "ok 47\n";
d465 6
a470 3
print "ok 48 # Skip: removed test\n";

print "ok 49 # Skip: removed test\n";
d480 1
a480 1
print alv();
d483 1
a483 1
print $array[20];
d487 1
a487 1
print $hash{foo};
d491 1
a491 1
print hlv("bar");
d501 1
a501 2
print "not " unless "@@array" eq "ok 54";
print "ok 54\n";
d504 1
a504 2
print "not " unless "@@array2" eq "ok 55";
print "ok 55\n";
d507 1
a507 2
print "not " unless $hash{ok} == 56;
print "ok 56\n";
d510 1
a510 2
print "not " unless $hash2{ok} == 57;
print "ok 57\n";
d515 1
a515 2
print "# @@array\nnot " unless "@@array" eq "ok b already d";
print "ok 58\n";
d520 1
a520 2
print "not " unless "@@array2" eq "ok B already d";
print "ok 59\n";
d525 1
a525 2
print "not " unless join("/",@@hash{"c","a","b"}) eq "CISC/Alpha/BogoMIPS";
print "ok 60\n";
d531 1
a531 2
print "not " unless $str eq "Hi, world!";
print "ok 61\n";
d535 1
a535 1
if (ord('A') != 193) {
d541 1
a541 2
print "# $str\nnot " unless $str eq "Made w/ PerlScript";
print "ok 62\n";
d550 6
a555 2
print "# @@p\nnot " unless "@@p" eq "1 8";
print "ok 63\n";
a561 2
print "not " unless join(':', @@ary) eq "1:2:6";
print "ok 64\n";
d563 36
a598 2
require './test.pl';
curr_test(65);
a599 2
TODO: {
    local $TODO = 'test explicit return of lval expr';
d601 33
a633 1
    # subs are corrupted copies from tests 1-~4
d655 159
d816 269
@


1.1.1.1
log
@stock perl 5.8.0 from CPAN
@
text
@@


1.1.1.2
log
@perl 5.8.2 from CPAN
@
text
@d254 1
a254 1
  unless /Can't return undef from lvalue subroutine/;
d277 1
a277 1
  unless /Can't return undef from lvalue subroutine/;
d426 4
a429 1
eval 'sub AUTOLOAD : lvalue { $newvar }';
@


1.1.1.3
log
@perl 5.8.8 import
@
text
@d1 1
a1 1
print "1..71\n";
a532 43
# check that an element of a tied hash/array can be assigned to via lvalueness

package Tie_Hash;

our ($key, $val);
sub TIEHASH { bless \my $v => __PACKAGE__ }
sub STORE   { ($key, $val) = @@_[1,2] }

package main;
sub lval_tie_hash : lvalue {
    tie my %t => 'Tie_Hash';
    $t{key};
}

eval { lval_tie_hash() = "value"; };

print "# element of tied hash: $@@\nnot " if $@@;
print "ok 65\n";

print "not " if "$Tie_Hash::key-$Tie_Hash::val" ne "key-value";
print "ok 66\n";


package Tie_Array;

our @@val;
sub TIEARRAY { bless \my $v => __PACKAGE__ }
sub STORE   { $val[ $_[1] ] = $_[2] }

package main;
sub lval_tie_array : lvalue {
    tie my @@t => 'Tie_Array';
    $t[0];
}

eval { lval_tie_array() = "value"; };

print "# element of tied array: $@@\nnot " if $@@;
print "ok 67\n";

print "not " if $Tie_Array::val[0] ne "value";
print "ok 68\n";

d534 1
a534 1
curr_test(69);
@


1.1.1.4
log
@import perl 5.10.0 from CPAN
@
text
@d1 2
a5 1
    require './test.pl';
a6 1
plan tests=>69;
d12 2
a13 1
is(ref $out, 'main'); # Not reached if error.
d16 2
a17 1
cmp_ok(scalar @@out, '==', 1); # Not reached if error.
d32 2
a33 1
is($in, '-2');
d46 2
a47 1
cmp_ok($blah, '==', 7);
d51 2
a52 1
cmp_ok($in, '==', 7);
d56 2
a57 1
cmp_ok($blah, '==', 8);
d61 2
a62 1
cmp_ok($in, '==', 8);
d66 2
a67 1
cmp_ok($blah, '==', 10);
d71 2
a72 1
cmp_ok($in, '==', 10);
d76 2
a77 1
cmp_ok($blah, '==', 11);
d81 2
a82 1
cmp_ok($in, '==', 11);
d86 2
a87 1
cmp_ok($blah, '==', 20);
d91 2
a92 1
cmp_ok($in, '==', 20);
d96 2
a97 1
cmp_ok($blah, '==', 21);
d101 2
a102 1
cmp_ok($in, '==', 21);
d106 2
a107 1
cmp_ok($blah, '==', 22);
d111 2
a112 1
cmp_ok($in, '==', 22);
d116 2
a117 1
cmp_ok($blah, '==', 23);
d121 2
a122 1
cmp_ok($in, '==', 23);
d126 2
a127 1
cmp_ok($blah, '==', 25);
d131 2
a132 1
cmp_ok($in, '==', 25);
d157 2
a158 3
like($_, qr/Can\'t return an uninitialized value from lvalue subroutine/);
print "ok 22\n";

d161 1
d169 2
a170 1
cmp_ok($var, '==', 45);
d177 2
a178 1
cmp_ok($var, '==', 47);
d184 2
a185 1
cmp_ok($var, '==', 49);
d196 3
a198 1
like($_, qr/Can\'t modify non-lvalue subroutine call in scalar assignment/);
d207 3
a209 1
like($_, qr/Can\'t modify non-lvalue subroutine call in scalar assignment/);
d218 3
a220 1
like($_, qr/Can\'t modify non-lvalue subroutine call in scalar assignment/);
d230 2
a231 1
ok(!defined $_) or diag "'$_', '$x0', '$x1'";
d241 3
a243 2
like($_, qr/Can\'t modify non-lvalue subroutine call/)
  or diag "'$_', '$x0', '$x1'";
d253 3
a255 1
like($_, qr/Can't return undef from lvalue subroutine/);
d265 2
a266 1
ok(!defined $_) or diag $_;
d276 3
a278 1
like($_, qr/Can't return undef from lvalue subroutine/);
d289 1
a289 1
# print "ok 34 # Skip: removed test\n";
d300 3
a302 1
like($_, qr/Can\'t modify index in lvalue subroutine return/);
d311 3
a313 1
like($_, qr/Can\'t modify shift in lvalue subroutine return/);
d325 3
a327 1
like($_, qr/Can\'t modify non-lvalue subroutine call in lvalue subroutine return/);
d335 3
a337 1
like($_, qr/Can\'t return a temporary from lvalue subroutine/);
d348 3
a350 1
like($_, qr/Can\'t modify constant item in lvalue subroutine return/);
d358 3
a360 1
like($_, qr/Can\'t return a readonly value from lvalue subroutine/);
d372 2
a373 1
is("'@@a' $_", "'2 3' ");
d384 2
a385 1
is("'@@a' $_", "'2 3' ");
d396 2
a397 1
is("'@@a' $_", "'2 3' ");
d407 2
a408 1
is("'$newvar' $_", "'4' ");
d418 2
a419 1
is("'$nnewvar' $_", "'3' ");
d423 2
a424 1
is($nnewvar, '8');
d428 6
a433 1
is($newvar, "12");
d443 1
a443 1
is(alv(), "ok 50\n");
d446 1
a446 1
is($array[20], "ok 51\n");
d450 1
a450 1
is($hash{foo}, "ok 52\n");
d454 1
a454 1
is(hlv("bar"), "ok 53\n");
d464 2
a465 1
is("@@array", "ok 54");
d468 2
a469 1
is("@@array2", "ok 55");
d472 2
a473 1
cmp_ok($hash{ok}, '==', 56);
d476 2
a477 1
cmp_ok($hash2{ok}, '==', 57);
d482 2
a483 1
is("@@array", "ok b already d");
d488 2
a489 1
is("@@array2", "ok B already d");
d494 2
a495 1
is(join("/",@@hash{"c","a","b"}), "CISC/Alpha/BogoMIPS");
d501 2
a502 1
is($str, "Hi, world!");
d512 2
a513 1
is($str, "Made w/ PerlScript");
d522 2
a523 1
is("@@p", "1 8");
d530 2
a531 2

is(join(':', @@ary), "1:2:6");
d549 2
a550 1
is($@@, "", "element of tied hash");
d552 2
a553 1
is("$Tie_Hash::key-$Tie_Hash::val", "key-value");
d570 2
d573 2
a574 1
is($@@, "", "element of tied array");
d576 2
a577 1
is ($Tie_Array::val[0], "value");
a605 23
TODO: {
    local $TODO = "bug #23790";
    my @@arr  = qw /one two three/;
    my $line = "zero";
    sub lval_array () : lvalue {@@arr}

    for (lval_array) {
        $line .= $_;
    }

    is($line, "zeroonetwothree");
}

{
    package Foo;
    sub AUTOLOAD :lvalue { *{$AUTOLOAD} };
    package main;
    my $foo = bless {},"Foo";
    my $result;
    $foo->bar = sub { $result = "bar" };
    $foo->bar;
    is ($result, 'bar', "RT #41550");
}
@


1.1.1.5
log
@Perl 5.12.2 from CPAN
@
text
@d6 1
a6 1
plan tests=>71;
a551 20
}

fresh_perl_is(<<'----', <<'====', "lvalue can not be set after definition. [perl #68758]");
use warnings;
our $x;
sub foo { $x }
sub foo : lvalue;
foo = 3;
----
lvalue attribute ignored after the subroutine has been defined at - line 4.
Can't modify non-lvalue subroutine call in scalar assignment at - line 5, near "3;"
Execution of - aborted due to compilation errors.
====

{
    my $x;
    sub lval_decl : lvalue;
    sub lval_decl { $x }
    lval_decl = 5;
    is($x, 5, "subroutine declared with lvalue before definition retains lvalue. [perl #68758]");
@


1.1.1.6
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d6 1
a6 1
plan tests=>191;
d134 1
a134 1
#print "# '@@out' ne '@@in'\nnot " unless "@@out" eq "@@in";
d213 1
a213 2
sub lv0 : lvalue { }
sub rlv0 : lvalue { return }
d223 1
a223 8
$_ = undef;
eval <<'EOE' or $_ = $@@;
  rlv0 = (2,3);
  1;
EOE

like($_, qr/Can't return undef from lvalue subroutine/,
    'explicit return of nothing in scalar context');
a232 14
$_ = undef;
eval <<'EOE' or $_ = $@@;
  (rlv0) = (2,3);
  1;
EOE

ok(!defined $_, 'explicit return of nothing in list context') or diag $_;

($a,$b)=();
(lv0($a,$b)) = (3,4);
is +($a//'undef') . ($b//'undef'), 'undefundef',
   'list assignment to empty lvalue sub';


a233 1
sub rlv1u :lvalue { undef }
a244 9
  rlv1u = (2,3);
  1;
EOE

like($_, qr/Can't return undef from lvalue subroutine/,
     'explicitly returning undef in scalar context');

$_ = undef;
eval <<'EOE' or $_ = $@@;
d249 4
a252 9
ok(!defined, 'implicitly returning undef in list context');

$_ = undef;
eval <<'EOE' or $_ = $@@;
  (rlv1u) = (2,3);
  1;
EOE

ok(!defined, 'explicitly returning undef in list context');
d263 1
a263 1
like($_, qr/Can\'t return a temporary from lvalue subroutine/);
d267 2
a268 2
  sub rlv1t : lvalue { index $x, 2 }
  rlv1t = (2,3);
d272 1
a272 16
like($_, qr/Can\'t return a temporary from lvalue subroutine/,
    'returning a PADTMP explicitly');

$_ = undef;
eval <<'EOE' or $_ = $@@;
  (rlv1t) = (2,3);
  1;
EOE

like($_, qr/Can\'t return a temporary from lvalue subroutine/,
    'returning a PADTMP explicitly (list context)');

$_ = undef;
sub lv2t : lvalue { shift }
(lv2t($_)) = (2,3);
is($_, 2);
d284 1
a284 1
like($_, qr/Can\'t modify non-lvalue subroutine call at /);
d292 1
a292 1
like($_, qr/Can\'t modify non-lvalue subroutine call at /);
d303 1
a303 1
like($_, qr/Can\'t return a readonly value from lvalue subroutine at/);
d336 8
a343 2
is lva->${\sub { return $_[0] }}, 2,
  'lvalue->$thing when lvalue returns array';
d345 1
a345 5
my @@my = qw/ a b c /;
sub lvmya : lvalue { @@my }

is lvmya->${\sub { return $_[0] }}, 3,
  'lvalue->$thing when lvalue returns lexical array';
a374 7
# But autoloading should only be triggered by a call to an undefined
# subroutine.
&{"lv1nn"} = 14;
is $newvar, 12, 'AUTOLOAD does not take precedence over lvalue sub';
eval { &{"xxx"} = 14 };
is $newvar, 12, 'AUTOLOAD does not take precedence over non-lvalue sub';

a454 5
sub keeze : lvalue { keys %__ }
%__ = ("a","b");
keeze = 64;
is scalar %__, '1/64', 'keys assignment through lvalue sub';

d503 2
d506 1
a506 28
# Check that tied pad vars that are returned can be assigned to
sub TIESCALAR { bless [] }
sub STORE {$wheel = $_[1]}
sub FETCH {$wheel}
sub tied_pad_var  :lvalue { tie my $tyre, ''; $tyre }
sub tied_pad_varr :lvalue { tie my $tyre, ''; return $tyre }
tied_pad_var = 1;
is $wheel, 1, 'tied pad var returned in scalar lvalue context';
tied_pad_var->${\sub{ $_[0] = 2 }};
is $wheel, 2, 'tied pad var returned in scalar ref context';
(tied_pad_var) = 3;
is $wheel, 3, 'tied pad var returned in list lvalue context';
$_ = 4 for tied_pad_var;
is $wheel, 4, 'tied pad var returned in list ref context';
tied_pad_varr = 5;
is $wheel, 5, 'tied pad var explicitly returned in scalar lvalue context';
tied_pad_varr->${\sub{ $_[0] = 6 }};
is $wheel, 6, 'tied pad var explicitly returned in scalar ref context';
(tied_pad_varr) = 7;
is $wheel, 7, 'tied pad var explicitly returned in list lvalue context';
$_ = 8 for tied_pad_varr;
is $wheel, 8, 'tied pad var explicitly returned in list ref context';


# Test explicit return of lvalue expression
{
    # subs are copies from tests 1-~18 with an explicit return added.
    # They used not to work, which is why they are ‘badly’ named.
a527 74

    ++bad_get_lex;
    cmp_ok($in, '==', 8);

    bad_id(bad_get_st) = 10;
    cmp_ok($blah, '==', 10);

    bad_id(bad_get_lex) = 10;
    cmp_ok($in, '==', 10);

    ++bad_id(bad_get_st);
    cmp_ok($blah, '==', 11);

    ++bad_id(bad_get_lex);
    cmp_ok($in, '==', 11);

    bad_id1(bad_get_st) = 20;
    cmp_ok($blah, '==', 20);

    bad_id1(bad_get_lex) = 20;
    cmp_ok($in, '==', 20);

    ++bad_id1(bad_get_st);
    cmp_ok($blah, '==', 21);

    ++bad_id1(bad_get_lex);
    cmp_ok($in, '==', 21);

    bad_inc(bad_get_st);
    cmp_ok($blah, '==', 22);

    bad_inc(bad_get_lex);
    cmp_ok($in, '==', 22);

    bad_inc(bad_id(bad_get_st));
    cmp_ok($blah, '==', 23);

    bad_inc(bad_id(bad_get_lex));
    cmp_ok($in, '==', 23);

    ++bad_inc(bad_id1(bad_id(bad_get_st)));
    cmp_ok($blah, '==', 25);

    ++bad_inc(bad_id1(bad_id(bad_get_lex)));
    cmp_ok($in, '==', 25);

    # Recursive
    my $r;
    my $to_modify;
    $r = sub :lvalue {
      my $depth = shift//0;
      if ($depth == 2) { return $to_modify }
      return &$r($depth+1);
    };
    &$r(0) = 7;
    is $to_modify, 7, 'recursive lvalue sub';

    # Recursive with substr [perl #72706]
    my $val = '';
    my $pie;
    $pie = sub :lvalue {
	my $depth = shift;
	return &$pie($depth) if $depth--;
	substr $val, 0;
    };
    for my $depth (0, 1, 2) {
	my $value = "Good $depth";
	eval {
	    &$pie($depth) = $value;
	};
	is($@@, '', "recursive lvalue substr return depth $depth");
	is($val, $value,
	   "value assigned to recursive lvalue substr (depth $depth)");
    }
d530 2
a531 1
{ # bug #23790
a540 62

    sub trythislval { scalar(@@_)."x".join "", @@_ }
    is(trythislval(lval_array()), "3xonetwothree");

    sub changeme { $_[2] = "free" }
    changeme(lval_array);
    is("@@arr", "one two free");

    # test again, with explicit return
    sub rlval_array() : lvalue {return @@arr}
    @@arr  = qw /one two three/;
    $line = "zero";
    for (rlval_array) {
        $line .= $_;
    }
    is($line, "zeroonetwothree");
    is(trythislval(rlval_array()), "3xonetwothree");
    changeme(rlval_array);
    is("@@arr", "one two free");

    # Variations on the same theme, with multiple vars returned
    my $scalar = 'half';
    sub lval_scalar_array () : lvalue { $scalar, @@arr }
    @@arr  = qw /one two three/;
    $line = "zero";
    for (lval_scalar_array) {
        $line .= $_;
    }
    is($line, "zerohalfonetwothree");
    is(trythislval(lval_scalar_array()), "4xhalfonetwothree");
    changeme(lval_scalar_array);
    is("@@arr", "one free three");

    sub lval_array_scalar () : lvalue { @@arr, $scalar }
    @@arr  = qw /one two three/;
    $line = "zero";
    $scalar = 'four';
    for (lval_array_scalar) {
        $line .= $_;
    }
    is($line, "zeroonetwothreefour");
    is(trythislval(lval_array_scalar()), "4xonetwothreefour");
    changeme(lval_array_scalar);
    is("@@arr", "one two free");

    # Tests for specific ops not tested above
    # rv2av
    @@array2 = qw 'one two free';
    is join(',', map $_, sub:lvalue{@@array2}->()), 'one,two,free',
      'rv2av in reference context';
    is join(',', map $_, sub:lvalue{@@{\@@array2}}->()), 'one,two,free',
      'rv2av-with-ref in reference context';
    # padhv
    my %hash = qw[a b c d];
    like join(',', map $_, sub:lvalue{%hash}->()),
         qr/^(?:a,b,c,d|c,d,a,b)\z/, 'padhv in reference context';
    # rv2hv
    %hash2 = qw[a b c d];
    like join(',', map $_, sub:lvalue{%hash2}->()),
         qr/^(?:a,b,c,d|c,d,a,b)\z/, 'rv2hv in reference context';
    like join(',', map $_, sub:lvalue{%{\%hash2}}->()),
         qr/^(?:a,b,c,d|c,d,a,b)\z/, 'rv2hv-with-ref in reference context';
a553 1
SKIP: { skip 'no attributes.pm', 1 unless eval 'require attributes';
a558 2
sub MODIFY_CODE_ATTRIBUTES {}
sub foo : lvalue : fr0g;
d562 1
a562 2
lvalue attribute ignored after the subroutine has been defined at - line 6.
Can't modify non-lvalue subroutine call in scalar assignment at - line 7, near "3;"
a564 1
}
a572 165

SKIP: { skip "no attributes.pm", 2 unless eval { require attributes };
  sub utf8::valid :lvalue;
  require attributes;
  is "@@{[ &attributes::get(\&utf8::valid) ]}", 'lvalue',
   'sub declaration with :lvalue applies it to XSUBs';

  BEGIN { *wonky = \&marjibberous }
  sub wonky :lvalue;
  is "@@{[ &attributes::get(\&wonky) ]}", 'lvalue',
   'sub declaration with :lvalue applies it to assigned stub';
}

sub fleen : lvalue { $pnare }
$pnare = __PACKAGE__;
ok eval { fleen = 1 }, "lvalues can return COWs (CATTLE?) [perl #75656]";\
is $pnare, 1, 'and returning CATTLE actually works';
$pnare = __PACKAGE__;
ok eval { (fleen) = 1 }, "lvalues can return COWs in list context";
is $pnare, 1, 'and returning COWs in list context actually works';
$pnare = __PACKAGE__;
ok eval { $_ = 1 for(fleen); 1 }, "lvalues can return COWs in ref cx";
is $pnare, 1, 'and returning COWs in reference context actually works';


# Returning an arbitrary expression, not necessarily lvalue
+sub :lvalue { return $ambaga || $ambaga }->() = 73;
is $ambaga, 73, 'explicit return of arbitrary expression (scalar context)';
(sub :lvalue { return $ambaga || $ambaga }->()) = 74;
is $ambaga, 74, 'explicit return of arbitrary expression (list context)';
+sub :lvalue { $ambaga || $ambaga }->() = 73;
is $ambaga, 73, 'implicit return of arbitrary expression (scalar context)';
(sub :lvalue { $ambaga || $ambaga }->()) = 74;
is $ambaga, 74, 'implicit return of arbitrary expression (list context)';
eval { +sub :lvalue { return 3 }->() = 4 };
like $@@, qr/Can\'t return a readonly value from lvalue subroutine at/,
      'assignment to numeric constant explicitly returned from lv sub';
eval { (sub :lvalue { return 3 }->()) = 4 };
like $@@, qr/Can\'t return a readonly value from lvalue subroutine at/,
      'assignment to num constant explicitly returned (list cx)';
eval { +sub :lvalue { 3 }->() = 4 };
like $@@, qr/Can\'t return a readonly value from lvalue subroutine at/,
      'assignment to numeric constant implicitly returned from lv sub';
eval { (sub :lvalue { 3 }->()) = 4 };
like $@@, qr/Can\'t return a readonly value from lvalue subroutine at/,
      'assignment to num constant implicitly returned (list cx)';

# reference (potential lvalue) context
$suffix = '';
for my $sub (sub :lvalue {$_}, sub :lvalue {return $_}) {
    &$sub()->${\sub { $_[0] = 37 }};
    is $_, '37', 'lvalue->method'.$suffix;
    ${\scalar &$sub()} = 38;
    is $_, '38', 'scalar(lvalue)'.$suffix;
    sub assign39_with_proto ($) { $_[0] = 39 }
    assign39_with_proto(&$sub());
    is $_, '39', 'func(lvalue) when func has $ proto'.$suffix;
    $_ = 1;
    ${\(&$sub()||undef)} = 40;
    is $_, '40', 'lvalue||...'.$suffix;
    ${\(${\undef}||&$sub())} = 41; # extra ${\...} to bypass const folding
    is $_, '41', '...||lvalue'.$suffix;
    $_ = 0;
    ${\(&$sub()&&undef)} = 42;
    is $_, '42', 'lvalue&&...'.$suffix;
    ${\(${\1}&&&$sub())} = 43;
    is $_, '43', '...&&lvalue'.$suffix;
    ${\(&$sub())[0]} = 44;
    is $_, '44', '(lvalue)[0]'.$suffix;
}
continue { $suffix = ' (explicit return)' }

# autovivification
$suffix = '';
for my $sub (sub :lvalue {$_}, sub :lvalue {return $_}) {
    undef $_;
    &$sub()->[3] = 4;
    is $_->[3], 4, 'func->[...] autovivification'.$suffix;
    undef $_;
    &$sub()->{3} = 4;
    is $_->{3}, 4, 'func->{...} autovivification'.$suffix;
    undef $_;
    ${&$sub()} = 4;
    is $$_, 4, '${func()} autovivification'      .$suffix;
    undef $_;
    @@{&$sub()} = 4;
    is "@@$_", 4, '@@{func()} autovivification'    .$suffix;
    undef $_;
    %{&$sub()} = (4,5);
    is join('-',%$_), '4-5', '%{func()} autovivification'.$suffix;
    undef $_;
    ${ (), &$sub()} = 4;
    is $$_, 4, '${ (), func()} autovivification'      .$suffix;
}
continue { $suffix = ' (explicit return)' }

# [perl #92406] [perl #92290] Returning a pad var in rvalue context
$suffix = '';
for my $sub (
         sub :lvalue { my $x = 72; $x },
         sub :lvalue { my $x = 72; return $x }
) {
    is scalar(&$sub), 72, "sub returning pad var in scalar context$suffix";
    is +(&$sub)[0], 72, "sub returning pad var in list context$suffix";
}
continue { $suffix = ' (explicit return)' }

# Returning read-only values in reference context
$suffix = '';
for (
         sub :lvalue { $] }->(),
         sub :lvalue { return $] }->()
) {
    is \$_, \$], 'read-only values are returned in reference context'
	         .$suffix             # (they used to be copied)
}
continue { $suffix = ' (explicit return)' }

# Returning unwritables from nested lvalue sub call in in rvalue context
# First, ensure we are testing what we think we are:
if (!Internals::SvREADONLY($])) { Internals::SvREADONLY($],1); }
sub squibble : lvalue { return $] }
sub squebble : lvalue {        squibble }
sub squabble : lvalue { return squibble }
is $x = squebble, $], 'returning ro from nested lv sub call in rv cx';
is $x = squabble, $], 'explct. returning ro from nested lv sub in rv cx';
is \squebble, \$], 'returning ro from nested lv sub call in ref cx';
is \squabble, \$], 'explct. returning ro from nested lv sub in ref cx';

# [perl #102486] Sub calls as the last statement of an lvalue sub
package _102486 {
  my $called;
  my $x = 'nonlv';
  sub strictlv :lvalue { use strict 'refs'; &$x }
  sub lv :lvalue { &$x }
  sub nonlv { ++$called }
  eval { strictlv };
  ::like $@@, qr/^Can't use string \("nonlv"\) as a subroutine ref while/,
        'strict mode applies to sub:lvalue{ &$string }';
  $called = 0;
  ::ok eval { lv },
      'sub:lvalue{&$x}->() does not die for non-lvalue inner sub call';
  ::is $called, 1, 'The &$x actually called the sub';
  eval { +sub :lvalue { &$x }->() = 3 };
  ::like $@@, qr/^Can't modify non-lvalue subroutine call at /,
        'sub:lvalue{&$x}->() dies in true lvalue context';
}

# TARG should be copied in rvalue context
sub ucf :lvalue { ucfirst $_[0] }
is ucf("just another ") . ucf("perl hacker,\n"),
   "Just another Perl hacker,\n", 'TARG is copied in rvalue scalar cx';
is join('',ucf("just another "), ucf "perl hacker,\n"),
   "Just another Perl hacker,\n", 'TARG is copied in rvalue list cx';
sub ucfr : lvalue {
    @@_ ? ucfirst $_[0] : do {
	is ucfr("just another ") . ucfr("perl hacker,\n"),
	   "Just another Perl hacker,\n",
	   'TARG is copied in recursive rvalue scalar cx';
	is join('',ucfr("just another "), ucfr("perl hacker,\n")),
	   "Just another Perl hacker,\n",
	   'TARG is copied in recursive rvalue list cx';
    }
}
ucfr();
@


1.1.1.7
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d6 1
a6 1
plan tests=>192;
a964 5

# [perl #117947] XSUBs should not be treated as lvalues at run time
eval { &{\&utf8::is_utf8}("") = 3 };
like $@@, qr/^Can't modify non-lvalue subroutine call at /,
        'XSUB not seen at compile time dies in lvalue context';
@


1.1.1.8
log
@Import perl-5.20.1
@
text
@d6 1
a6 1
plan tests=>205;
a320 25
# These next two tests are not necessarily normative.  But this way we will
# know if this discrepancy changes.

$_ = undef;
eval <<'EOE' or $_ = $@@;
  sub scalarray : lvalue { @@a || $b }
  @@a = 1;
  (scalarray) = (2,3);
  1;
EOE

like($_, qr/Can\'t return a temporary from lvalue subroutine/,
    'returning a scalar-context array via ||');

$_ = undef;
eval <<'EOE' or $_ = $@@;
  use warnings "FATAL" => "all";
  sub myscalarray : lvalue { my @@a = 1; @@a || $b }
  (myscalarray) = (2,3);
  1;
EOE

like($_, qr/Useless assignment to a temporary/,
    'returning a scalar-context lexical array via ||');

d777 1
a777 1
fresh_perl_is(<<'----', <<'====', {}, "lvalue can not be set after definition. [perl #68758]");
a965 5
# Test TARG with potential lvalue context, too
for (sub : lvalue { "$x" }->()) {
    is \$_, \$_, '\$_ == \$_ in for(sub :lvalue{"$x"}->()){...}'
}

a969 45

# [perl #119797] else implicitly returning value
# This used to cause Bizarre copy of ARRAY in pp_leave
sub else119797 : lvalue {
    if ($_[0]) {
	1; # two statements force a leave op
	@@119797
    }
    else {
	@@119797
    }
}
eval { (else119797(0)) = 1..3 };
is $@@, "", '$@@ after writing to array returned by else';
is "@@119797", "1 2 3", 'writing to array returned by else';
eval { (else119797(1)) = 4..6 };
is $@@, "", '$@@ after writing to array returned by if (with else)';
is "@@119797", "4 5 6", 'writing to array returned by if (with else)';
sub if119797 : lvalue {
    if ($_[0]) {
	@@119797
    }
}
@@119797 = ();
eval { (if119797(1)) = 4..6 };
is $@@, "", '$@@ after writing to array returned by if';
is "@@119797", "4 5 6", 'writing to array returned by if';
sub unless119797 : lvalue {
    unless ($_[0]) {
	@@119797
    }
}
@@119797 = ();
eval { (unless119797(0)) = 4..6 };
is $@@, "", '$@@ after writing to array returned by unless';
is "@@119797", "4 5 6", 'writing to array returned by unless';
sub bare119797 : lvalue {
    {;
	@@119797
    }
}
@@119797 = ();
eval { (bare119797(0)) = 4..6 };
is $@@, "", '$@@ after writing to array returned by bare block';
is "@@119797", "4 5 6", 'writing to array returned by bare block';
@


