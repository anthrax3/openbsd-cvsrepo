head	1.2;
access;
symbols
	OPENBSD_6_2:1.2.0.2
	OPENBSD_6_2_BASE:1.2
	PERL_5_24_2:1.1.1.6
	OPENBSD_6_1:1.2.0.4
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.5.0.8
	OPENBSD_6_0_BASE:1.1.1.5
	OPENBSD_5_9:1.1.1.5.0.2
	OPENBSD_5_9_BASE:1.1.1.5
	OPENBSD_5_8:1.1.1.5.0.4
	OPENBSD_5_8_BASE:1.1.1.5
	PERL_5_20_2:1.1.1.5
	OPENBSD_5_7:1.1.1.4.0.2
	OPENBSD_5_7_BASE:1.1.1.4
	PERL_5_20_1:1.1.1.4
	OPENBSD_5_6:1.1.1.3.0.4
	OPENBSD_5_6_BASE:1.1.1.3
	PERL_5_18_2:1.1.1.3
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.2.0.6
	OPENBSD_5_5_BASE:1.1.1.2
	OPENBSD_5_4:1.1.1.2.0.2
	OPENBSD_5_4_BASE:1.1.1.2
	PERL_5_16_3:1.1.1.2
	OPENBSD_5_3:1.1.1.1.0.10
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.8
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.6
	OPENBSD_5_0:1.1.1.1.0.4
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.2
	OPENBSD_4_9_BASE:1.1.1.1
	PERL_5_12_2:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.32.21;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2010.09.24.14.49.19;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.09.24.14.49.19;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.03.25.20.09.37;	author sthen;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.03.24.14.59.11;	author afresh1;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.11.17.20.53.18;	author afresh1;	state Exp;
branches;
next	1.1.1.5;
commitid	B31cAbBIXiCqnL97;

1.1.1.5
date	2015.04.25.19.10.48;	author afresh1;	state Exp;
branches;
next	1.1.1.6;
commitid	Wpcs5S8qILgEZC7F;

1.1.1.6
date	2017.08.14.13.46.24;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!/usr/bin/perl

BEGIN {
  @@INC = '..' if -f '../TestInit.pm';
}
use TestInit qw(T); # T is chdir to the top level

use warnings;
use strict;
use Config;

require 't/test.pl';

if ( $Config{usecrosscompile} ) {
  skip_all( "Not all files are available during cross-compilation" );
}

plan('no_plan');

# --make-exceptions-list outputs the list of strings that don't have
# perldiag.pod entries to STDERR without TAP formatting, so they can
# easily be put in the __DATA__ section of this file.  This was done
# initially so as to not create new test failures upon the initial
# creation of this test file.  You probably shouldn't do it again.
# Just add the documentation instead.
my $make_exceptions_list = ($ARGV[0]||'') eq '--make-exceptions-list'
  and shift;

require 'regen/embed_lib.pl';

# Look for functions that look like they could be diagnostic ones.
my @@functions;
foreach (@@{(setup_embed())[0]}) {
  next if @@$_ < 2;
  next unless $_->[2]  =~ /warn|(?<!ov)err|(\b|_)die|croak/i;
  # The flag p means that this function may have a 'Perl_' prefix
  # The flag s means that this function may have a 'S_' prefix
  push @@functions, $_->[2];
  push @@functions, 'Perl_' . $_->[2] if $_->[0] =~ /p/;
  push @@functions, 'S_' . $_->[2] if $_->[0] =~ /s/;
};
push @@functions, 'Perl_mess';

my $regcomp_fail_re = '\b(?:(?:Simple_)?v)?FAIL[2-4]?(?:utf8f)?\b';
my $regcomp_re =
   "(?<routine>ckWARN(?:\\d+)?reg\\w*|vWARN\\d+|$regcomp_fail_re)";
my $function_re = join '|', @@functions;
my $source_msg_re =
   "(?<routine>\\bDIE\\b|$function_re)";
my $text_re = '"(?<text>(?:\\\\"|[^"]|"\s*[A-Z_]+\s*")*)"';
my $source_msg_call_re = qr/$source_msg_re(?:_nocontext)? \s*
    \((?:aTHX_)? \s*
    (?:packWARN\d*\((?<category>.*?)\),)? \s*
    $text_re /x;
my $bad_version_re = qr{BADVERSION\([^"]*$text_re};
   $regcomp_fail_re = qr/$regcomp_fail_re\([^"]*$text_re/;
my $regcomp_call_re = qr/$regcomp_re.*?$text_re/;

my %entries;

# Get the ignores that are compiled into this file
my $reading_categorical_exceptions;
while (<DATA>) {
  chomp;
  $entries{$_}{todo} = 1;
  $reading_categorical_exceptions and $entries{$_}{cattodo}=1;
  /__CATEGORIES__/ and ++$reading_categorical_exceptions;
}

my $pod = "pod/perldiag.pod";
my $cur_entry;
open my $diagfh, "<", $pod
  or die "Can't open $pod: $!";

my $category_re = qr/ [a-z0-9_:]+?/;    # Note: requires an initial space
my $severity_re = qr/ . (?: \| . )* /x; # A severity is a single char, but can
                                        # be of the form 'S|P|W'
my @@same_descr;
while (<$diagfh>) {
  if (m/^=item (.*)/) {
    $cur_entry = $1;

    # Allow multi-line headers
    while (<$diagfh>) {
      if (/^\s*$/) {
        last;
      }

      $cur_entry =~ s/ ?\z/ $_/;
    }

    $cur_entry =~ s/\n/ /gs; # Fix multi-line headers if they have \n's
    $cur_entry =~ s/\s+\z//;
    $cur_entry =~ s/E<lt>/</g;
    $cur_entry =~ s/E<gt>/>/g;
    $cur_entry =~ s,E<sol>,/,g;
    $cur_entry =~ s/[BCIFS](?:<<< (.*?) >>>|<< (.*?) >>|<(.*?)>)/$+/g;

    if (exists $entries{$cur_entry} &&  $entries{$cur_entry}{todo}
                                    && !$entries{$cur_entry}{cattodo}) {
        TODO: {
            local $::TODO = "Remove the TODO entry \"$cur_entry\" from DATA as it is already in $pod near line $.";
            ok($cur_entry);
        }
    }
    # Make sure to init this here, so an actual entry in perldiag
    # overwrites one in DATA.
    $entries{$cur_entry}{todo} = 0;
    $entries{$cur_entry}{line_number} = $.;
  }

  next if ! defined $cur_entry;

  if (! $entries{$cur_entry}{severity}) {
    if (/^ \( ( $severity_re )

        # Can have multiple categories separated by commas
        ( $category_re (?: , $category_re)* )? \) /x)
    {
      $entries{$cur_entry}{severity} = $1;
      $entries{$cur_entry}{category} =
        $2 && join ", ", sort split " ", $2 =~ y/,//dr;

      # Record it also for other messages sharing the same description
      @@$_{qw<severity category>} =
        @@{$entries{$cur_entry}}{qw<severity category>}
       for @@same_descr;
    }
    elsif (! $entries{$cur_entry}{first_line} && $_ =~ /\S/) {

      # Keep track of first line of text if doesn't contain a severity, so
      # that can later examine it to determine if that is ok or not
      $entries{$cur_entry}{first_line} = $_;
    }
    if (/\S/) {
      @@same_descr = ();
    }
    else {
      push @@same_descr, $entries{$cur_entry};
    }
  }
}

foreach my $cur_entry ( keys %entries) {
    next if $entries{$cur_entry}{todo}; # If in this file, won't have a severity
    if (! exists $entries{$cur_entry}{severity}

            # If there is no first line, it was two =items in a row, so the
            # second one is the one with with text, not this one.
        && exists $entries{$cur_entry}{first_line}

            # If the first line refers to another message, no need for severity
        && $entries{$cur_entry}{first_line} !~ /^See/)
    {
        fail($cur_entry);
        diag(
            "   $pod entry at line $entries{$cur_entry}{line_number}\n"
          . "       \"$cur_entry\"\n"
          . "   is missing a severity and/or category"
        );
    }
}

# List from perlguts.pod "Formatted Printing of IVs, UVs, and NVs"
# Convert from internal formats to ones that the readers will be familiar
# with, while removing any format modifiers, such as precision, the
# presence of which would just confuse the pod's explanation
my %specialformats = (IVdf => 'd',
		      UVuf => 'd',
		      UVof => 'o',
		      UVxf => 'x',
		      UVXf => 'X',
		      NVef => 'f',
		      NVff => 'f',
		      NVgf => 'f',
		      HEKf256=>'s',
		      HEKf => 's',
		      UTF8f=> 's',
		      SVf256=>'s',
		      SVf32=> 's',
		      SVf  => 's',
		      PNf  => 's');
my $format_modifiers = qr/ [#0\ +-]*              # optional flags
			  (?: [1-9][0-9]* | \* )? # optional field width
			  (?: \. \d* )?           # optional precision
			  (?: h|l )?              # optional length modifier
			/x;

my $specialformats =
 join '|', sort { length $b cmp length $a } keys %specialformats;
my $specialformats_re = qr/%$format_modifiers"\s*($specialformats)(\s*")?/;

if (@@ARGV) {
  check_file($_) for @@ARGV;
  exit;
}
open my $fh, '<', 'MANIFEST' or die "Can't open MANIFEST: $!";
while (my $file = <$fh>) {
    chomp $file;
    $file =~ s/\s+.*//;
    next unless $file =~ /\.(?:c|cpp|h|xs|y)\z/ or $file =~ /^perly\./;
    # OS/2 extensions have never been migrated to ext/, hence the special case:
    next if $file =~ m!\A(?:ext|dist|cpan|lib|t|os2/OS2)/!
            && $file !~ m!\Aext/DynaLoader/!;
    check_file($file);
}
close $fh or die $!;

# Standardize messages with variants into the form that appears
# in perldiag.pod -- useful for things without a diag_listed_as annotation
sub standardize {
  my ($name) = @@_;

  if    ( $name =~ m/^(Invalid strict version format) \([^\)]*\)/ ) {
    $name = "$1 (\%s)";
  }
  elsif ( $name =~ m/^(Invalid version format) \([^\)]*\)/ ) {
    $name = "$1 (\%s)";
  }
  elsif ($name =~ m/^panic: /) {
    $name = "panic: \%s";
  }

  return $name;
}

sub check_file {
  my ($codefn) = @@_;

  print "# Checking $codefn\n";

  open my $codefh, "<", $codefn
    or die "Can't open $codefn: $!";

  my $listed_as;
  my $listed_as_line;
  my $sub = 'top of file';
  while (<$codefh>) {
    chomp;
    # Getting too much here isn't a problem; we only use this to skip
    # errors inside of XS modules, which should get documented in the
    # docs for the module.
    if (m<^[^#\s]> and $_ !~ m/^[{}]*$/) {
      $sub = $_;
    }
    next if $sub =~ m/^XS/;
    if (m</\*\s*diag_listed_as: (.*?)\s*\*/>) {
      $listed_as = $1;
      $listed_as_line = $.+1;
    }
    elsif (m</\*\s*diag_listed_as: (.*?)\s*\z>) {
      $listed_as = $1;
      my $finished;
      while (<$codefh>) {
        if (m<\*/>) {
          $listed_as .= $` =~ s/^\s*/ /r =~ s/\s+\z//r;
          $listed_as_line = $.+1;
          $finished = 1;
          last;
        }
        else {
          $listed_as .= s/^\s*/ /r =~ s/\s+\z//r;
        }
      }
      if (!$finished) { $listed_as = undef }
    }
    next if /^#/;

    my $multiline = 0;
    # Loop to accumulate the message text all on one line.
    if (m/(?!^)\b(?:$source_msg_re(?:_nocontext)?|$regcomp_re)\s*\(/) {
      while (not m/\);\s*$/) {
        my $nextline = <$codefh>;
        # Means we fell off the end of the file.  Not terribly surprising;
        # this code tries to merge a lot of things that aren't regular C
        # code (preprocessor stuff, long comments).  That's OK; we don't
        # need those anyway.
        last if not defined $nextline;
        chomp $nextline;
        $nextline =~ s/^\s+//;
        $_ =~ s/\\$//;
        # Note that we only want to do this where *both* are true.
        if ($_ =~ m/"\s*$/ and $nextline =~ m/^"/) {
          $_ =~ s/"\s*$//;
          $nextline =~ s/^"//;
        }
        $_ .= $nextline;
        ++$multiline;
      }
    }
    # This should happen *after* unwrapping, or we don't reformat the things
    # in later lines.

    s/$specialformats_re/"%$specialformats{$1}" .  (defined $2 ? '' : '"')/ge;

    # Remove any remaining format modifiers, but not in %%
    s/ (?<!%) % $format_modifiers ( [dioxXucsfeEgGp] ) /%$1/xg;

    # The %"foo" thing needs to happen *before* this regex.
    # diag($_);
    # DIE is just return Perl_die
    my ($name, $category, $routine);
    if (/\b$source_msg_call_re/) {
      ($name, $category, $routine) = ($+{'text'}, $+{'category'}, $+{'routine'});
      # Sometimes the regexp will pick up too much for the category
      # e.g., WARN_UNINITIALIZED), PL_warn_uninit_sv ... up to the next )
      $category && $category =~ s/\).*//s;
      if (/win32_croak_not_implemented\(/) {
        $name .= " not implemented!"
      }
    }
    elsif (/$bad_version_re/) {
      ($name, $category) = ($+{'text'}, undef);
    }
    elsif (/$regcomp_fail_re/) {
      #  FAIL("foo") -> "foo in regex m/%s/"
      # vFAIL("foo") -> "foo in regex; marked by <-- HERE in m/%s/"
      ($name, $category) = ($+{'text'}, undef);
      $name .=
        " in regex" . ("; marked by <-- HERE in" x /vFAIL/) . " m/%s/";
    }
    elsif (/$regcomp_call_re/) {
      # vWARN/ckWARNreg("foo") -> "foo in regex; marked by <-- HERE in m/%s/
      ($name, $category, $routine) = ($+{'text'}, undef, $+{'routine'});
      $name .= " in regex; marked by <-- HERE in m/%s/";
      $category = 'WARN_REGEXP';
      if ($routine =~ /dep/) {
        $category .= ',WARN_DEPRECATED';
      }
    }
    else {
      next;
    }

    # Try to guess what the severity should be.  In the case of
    # Perl_ck_warner and other _ck_ functions, we can tell whether it is
    # a severe/default warning or no by the _d suffix.  In the case of
    # other warn functions we cannot tell, because Perl_warner may be pre-
    # ceded by if(ckWARN) or if(ckWARN_d).
    my $severity = !$routine                   ? '[PFX]'
                 :  $routine =~ /warn.*_d\z/   ? '[DS]'
                 :  $routine =~ /ck_warn/      ?  'W'
                 :  $routine =~ /warner/       ? '[WDS]'
                 :  $routine =~ /warn/         ?  'S'
                 :  $routine =~ /ckWARN.*dep/  ?  'D'
                 :  $routine =~ /ckWARN\d*reg_d/? 'S'
                 :  $routine =~ /ckWARN\d*reg/ ?  'W'
                 :  $routine =~ /vWARN\d/      ? '[WDS]'
                 :                             '[PFX]';
    my $categories;
    if (defined $category) {
      $category =~ s/__/::/g;
      $categories =
        join ", ",
              sort map {s/^WARN_//; lc $_} split /\s*[|,]\s*/, $category;
    }
    if ($listed_as and $listed_as_line == $. - $multiline) {
      $name = $listed_as;
    } else {
      # The form listed in perldiag ignores most sorts of fancy printf
      # formatting, or makes it more perlish.
      $name =~ s/%%/%/g;
      $name =~ s/%l[ud]/%d/g;
      $name =~ s/%\.(\d+|\*)s/\%s/g;
      $name =~ s/(?:%s){2,}/%s/g;
      $name =~ s/(\\")|("\s*[A-Z_]+\s*")/$1 ? '"' : '%s'/egg;
      $name =~ s/\\t/\t/g;
      $name =~ s/\\n/\n/g;
      $name =~ s/\s+$//;
      $name =~ s/(\\)\\/$1/g;
    }

    # Extra explanatory info on an already-listed error, doesn't
    # need it's own listing.
    next if $name =~ m/^\t/;

    # Happens fairly often with PL_no_modify.
    next if $name eq '%s';

    # Special syntax for magic comment, allows ignoring the fact
    # that it isn't listed.  Only use in very special circumstances,
    # like this script failing to notice that the Perl_croak call is
    # inside an #if 0 block.
    next if $name eq 'SKIPME';

    next if $name=~/\[TESTING\]/; # ignore these as they are works in progress

    check_message(standardize($name),$codefn,$severity,$categories);
  }
}

sub check_message {
    my($name,$codefn,$severity,$categories,$partial) = @@_;
    my $key = $name =~ y/\n/ /r;
    my $ret;

    # Try to reduce printf() formats to simplest forms
    # Really this should be matching %s, etc like diagnostics.pm does

    # Kill flags
    $key =~ s/%[#0\-+]/%/g;

    # Kill width
    $key =~ s/\%(\d+|\*)/%/g;

    # Kill precision
    $key =~ s/\%\.(\d+|\*)/%/g;

    if (exists $entries{$key} and
          # todo + cattodo means it is not found and it is not in the
          # regular todo list, either
          !$entries{$key}{todo} || !$entries{$key}{cattodo}) {
      $ret = 1;
      if ( $entries{$key}{seen}++ ) {
        # no need to repeat entries we've tested
      } elsif ($entries{$key}{todo}) {
        TODO: {
          no warnings 'once';
          local $::TODO = 'in DATA';
          # There is no listing, but it is in the list of exceptions.  TODO FAIL.
          fail($key);
          diag(
            "    Message '$name'\n    from $codefn line $. is not listed in $pod\n".
            "    (but it wasn't documented in 5.10 either, so marking it TODO)."
          );
        }
      } else {
        # We found an actual valid entry in perldiag.pod for this error.
        pass($key);

        return $ret
          if $entries{$key}{cattodo};

        # Now check the category and severity

        # Cache our severity qr thingies
        use feature 'state';
        state %qrs;
        my $qr = $qrs{$severity} ||= qr/$severity/;

        like($entries{$key}{severity}, $qr,
          $severity =~ /\[/
            ? "severity is one of $severity for $key"
            : "severity is $severity for $key");

        is($entries{$key}{category}, $categories,
           ($categories ? "categories are [$categories]" : "no category")
             . " for $key");
      }
    } elsif ($partial) {
      # noop
    } else {
      my $ok;
      if ($name =~ /\n/) {
        $ok = 1;
        check_message($_,$codefn,$severity,$categories,1) or $ok = 0, last
          for split /\n/, $name;
      }
      if ($ok) {
        # noop
      } elsif ($make_exceptions_list) {
        # We're making an updated version of the exception list, to
        # stick in the __DATA__ section.  I honestly can't think of
        # a situation where this is the right thing to do, but I'm
        # leaving it here, just in case one of my descendents thinks
        # it's a good idea.
        print STDERR "$key\n";
      } else {
        # No listing found, and no excuse either.
        # Find the correct place in perldiag.pod, and add a stanza beginning =item $name.
        fail($name);
        diag("    Message '$name'\n    from $codefn line $. is not listed in $pod");
      }
      # seen it, so only fail once for this message
      $entries{$name}{seen}++;
    }

    die if $name =~ /%$/;
    return $ret;
}

# Lists all missing things as of the inauguration of this script, so we
# don't have to go from "meh" to perfect all at once.
# 
# PLEASE DO NOT ADD TO THIS LIST.  Instead, write an entry in
# pod/perldiag.pod for your new (warning|error).  Nevertheless,
# listing exceptions here when this script is not smart enough
# to recognize the messages is not so bad, as long as there are
# entries in perldiag.

# Entries after __CATEGORIES__ are those that are in perldiag but fail the
# severity/category test.

# Also FIXME this test, as the first entry in TODO *is* covered by the
# description: Malformed UTF-8 character (%s)
__DATA__
Malformed UTF-8 character (unexpected non-continuation byte 0x%x, immediately after start byte 0x%x)

Cannot apply "%s" in non-PerlIO perl
Cannot set timer
Can't find DLL name for the module `%s' by the handle %d, rc=%u=%x
Can't find string terminator %c%s%c anywhere before EOF
Can't fix broken locale name "%s"
Can't get short module name from a handle
Can't load DLL `%s', possible problematic module `%s'
Can't locate %s:   %s
Can't pipe "%s": %s
Can't set type on DOS
Can't spawn: %s
Can't spawn "%s": %s
Can't %s script `%s' with ARGV[0] being `%s'
Can't %s "%s": %s
Can't %s `%s' with ARGV[0] being `%s' (looking for executables only, not found)
Can't use string ("%s"%s) as a subroutine ref while "strict refs" in use
Character(s) in '%c' format wrapped in %s
chown not implemented!
clear %s
Code missing after '/' in pack
Code missing after '/' in unpack
Could not find version 1.1 of winsock dll
Could not find version 2.0 of winsock dll
'%c' outside of string in pack
Debug leaking scalars child failed%s with errno %d: %s
detach of a thread which could not start
detach on an already detached thread
detach on a thread with a waiter
'/' does not take a repeat count in %s
-Dp not implemented on this platform
Empty array reference given to mod2fname
endhostent not implemented!
endnetent not implemented!
endprotoent not implemented!
endservent not implemented!
Error loading module '%s': %s
Error reading "%s": %s
execl not implemented!
EVAL without pos change exceeded limit in regex
Filehandle opened only for %sput
Filehandle %s opened only for %sput
Filehandle STD%s reopened as %s only for input
file_type not implemented on DOS
filter_del can only delete in reverse order (currently)
fork() not available
fork() not implemented!
YOU HAVEN'T DISABLED SET-ID SCRIPTS IN THE KERNEL YET! FIX YOUR KERNEL, PUT A C WRAPPER AROUND THIS SCRIPT, OR USE -u AND UNDUMP!
free %s
Free to wrong pool %p not %p
Function "endnetent" not implemented in this version of perl.
Function "endprotoent" not implemented in this version of perl.
Function "endservent" not implemented in this version of perl.
Function "getnetbyaddr" not implemented in this version of perl.
Function "getnetbyname" not implemented in this version of perl.
Function "getnetent" not implemented in this version of perl.
Function "getprotobyname" not implemented in this version of perl.
Function "getprotobynumber" not implemented in this version of perl.
Function "getprotoent" not implemented in this version of perl.
Function "getservbyport" not implemented in this version of perl.
Function "getservent" not implemented in this version of perl.
Function "getsockopt" not implemented in this version of perl.
Function "recvmsg" not implemented in this version of perl.
Function "sendmsg" not implemented in this version of perl.
Function "sethostent" not implemented in this version of perl.
Function "setnetent" not implemented in this version of perl.
Function "setprotoent" not implemented in this version of perl.
Function "setservent"  not implemented in this version of perl.
Function "setsockopt" not implemented in this version of perl.
Function "tcdrain" not implemented in this version of perl.
Function "tcflow" not implemented in this version of perl.
Function "tcflush" not implemented in this version of perl.
Function "tcsendbreak" not implemented in this version of perl.
get %s %p %p %p
gethostent not implemented!
getnetbyaddr not implemented!
getnetbyname not implemented!
getnetent not implemented!
getprotoent not implemented!
getpwnam returned invalid UIC %o for user "%s"
getservent not implemented!
glob failed (can't start child: %s)
glob failed (child exited with status %d%s)
Got an error from DosAllocMem: %i
Goto undefined subroutine
Goto undefined subroutine &%s
Got signal %d
()-group starts with a count in %s
Illegal binary digit '%c' ignored
Illegal character %sin prototype for %s : %s
Illegal hexadecimal digit '%c' ignored
Illegal octal digit '%c' ignored
INSTALL_PREFIX too long: `%s'
Invalid argument to sv_cat_decode
Invalid range "%c-%c" in transliteration operator
Invalid separator character %c%c%c in PerlIO layer specification %s
Invalid TOKEN object ignored
Invalid type '%c' in pack
Invalid type '%c' in %s
Invalid type '%c' in unpack
Invalid type ',' in %s
ioctl implemented only on sockets
ioctlsocket not implemented!
join with a thread with a waiter
killpg not implemented!
List form of pipe open not implemented
Looks like we have no PM; will not load DLL %s without $ENV{PERL_ASIF_PM}
Malformed integer in [] in %s
Malformed %s
Malformed UTF-8 character (fatal)
Missing (suid) fd script name
More than one argument to open
More than one argument to open(,':%s')
No message queue
No %s allowed while running setgid
No %s allowed with (suid) fdscript
Not an XSUB reference
Not a reference given to mod2fname
Not array reference given to mod2fname
Operator or semicolon missing before %c%s
Out of memory during list extend
panic queryaddr
Parse error
PerlApp::TextQuery: no arguments, please
POSIX syntax [%c %c] is reserved for future extensions in regex; marked by <-- HERE in m/%s/
ptr wrong %p != %p fl=%x nl=%p e=%p for %d
QUITing...
Recompile perl with -DDEBUGGING to use -D switch (did you mean -d ?)
recursion detected in %s
Regexp *+ operand could be empty in regex; marked by <-- HERE in m/%s/
Reversed %c= operator
%s: Can't parse EXE/DLL name: '%s'
%s(%f) failed
%sCompilation failed in require
%s: Error stripping dirs from EXE/DLL/INSTALLDIR name
sethostent not implemented!
setnetent not implemented!
setprotoent not implemented!
set %s %p %p %p
setservent not implemented!
%s free() ignored (RMAGIC, PERL_CORE)
%s has too many errors.
SIG%s handler "%s" not defined.
%s in %s
Size magic not implemented
%s: name `%s' too long
%s not implemented!
%s number > %s non-portable
%srealloc() %signored
%s in regex m/%s/
%s on %s %s
socketpair not implemented!
%s: %s
Starting Full Screen process with flag=%d, mytype=%d
Starting PM process with flag=%d, mytype=%d
sv_2iv assumed (U_V(fabs((double)SvNVX(sv))) < (UV)IV_MAX) but SvNVX(sv)=%f U_V is 0x%x, IV_MAX is 0x%x
switching effective gid is not implemented
switching effective uid is not implemented
System V IPC is not implemented on this machine
Terminating on signal SIG%s(%d)
The crypt() function is not implemented on NetWare
The flock() function is not implemented on NetWare
The rewinddir() function is not implemented on NetWare
The seekdir() function is not implemented on NetWare
The telldir() function is not implemented on NetWare
This perl was compiled without taint support. Cowardly refusing to run with -t or -T flags
This version of OS/2 does not support %s.%s
Too deeply nested ()-groups in %s
Too many args on %s line of "%s"
U0 mode on a byte string
unable to find VMSPIPE.COM for i/o piping
Unable to locate winsock library!
Unexpected program mode %d when morphing back from PM
Unrecognized character %s; marked by <-- HERE after %s<-- HERE near column %d
Unstable directory path, current directory changed unexpectedly
Unterminated compressed integer in unpack
Usage: %s(%s)
Usage: %s::%s(%s)
Usage: CODE(0x%x)(%s)
Usage: File::Copy::rmscopy(from,to[,date_flag])
Usage: VMS::Filespec::candelete(spec)
Usage: VMS::Filespec::fileify(spec)
Usage: VMS::Filespec::pathify(spec)
Usage: VMS::Filespec::rmsexpand(spec[,defspec])
Usage: VMS::Filespec::unixify(spec)
Usage: VMS::Filespec::unixpath(spec)
Usage: VMS::Filespec::unixrealpath(spec)
Usage: VMS::Filespec::vmsify(spec)
Usage: VMS::Filespec::vmspath(spec)
Usage: VMS::Filespec::vmsrealpath(spec)
Use of inherited AUTOLOAD for non-method %s::%s() is deprecated
utf8 "\x%X" does not map to Unicode
Value of logical "%s" too long. Truncating to %i bytes
waitpid: process %x is not a child of process %x
Wide character
Wide character in $/
win32_get_osfhandle() TBD on this platform
win32_open_osfhandle() TBD on this platform
Within []-length '*' not allowed in %s
Within []-length '%c' not allowed in %s
Wrong size of loadOrdinals array: expected %d, actual %d
Wrong syntax (suid) fd script name "%s"
'X' outside of string in %s
'X' outside of string in unpack

__CATEGORIES__

# This is a warning, but is currently followed immediately by a croak (toke.c)
Illegal character \%o (carriage return)

# Because uses WARN_MISSING as a synonym for WARN_UNINITIALIZED (sv.c)
Missing argument in %s

# This message can be both fatal and non-
False [] range "%s" in regex; marked by <-- HERE in m/%s/
@


1.1
log
@Initial revision
@
text
@d2 6
d10 1
d12 5
a16 1
require './test.pl';
d20 38
a57 1
$|=1;
d59 1
a59 1
my $make_exceptions_list = ($ARGV[0]||'') eq '--make-exceptions-list';
d61 2
a62 7
chdir '..' or die "Can't chdir ..: $!";
BEGIN { defined $ENV{PERL_UNICODE} and push @@INC, "lib"; }

open my $diagfh, "<", "pod/perldiag.pod"
  or die "Can't open pod/perldiag.pod: $!";

my %entries;
d65 3
a67 1
  $entries{$_}{todo}=1;
d70 1
d72 7
d82 26
a107 3
  } elsif (m/^\((.)(?: ([a-z]+?))?\)/ and !$entries{$cur_entry}{severity}) {
    # Make sure to init this here, so an actual entry in perldiag overwrites
    # one in DATA.
d109 1
a109 2
    $entries{$cur_entry}{severity} = $1;
    $entries{$cur_entry}{category} = $2;
d111 51
d164 55
a218 10
my @@todo = <*>;
while (@@todo) {
  my $todo = shift @@todo;
  next if $todo ~~ ['t', 'lib', 'ext', 'dist', 'cpan'];
  # opmini.c is just a copy of op.c, so there's no need to check again.
  next if $todo eq 'opmini.c';
  if (-d $todo) {
    push @@todo, glob "$todo/*";
  } elsif ($todo =~ m/\.[ch]$/) {
    check_file($todo);
d220 5
d230 1
a230 1
  print "# $codefn\n";
d243 2
a244 2
    if (m<^([^#\s].*)> and $1 !~ m/^[{}]*$/) {
      $sub = $1;
d247 1
a247 1
    if (m</\* diag_listed_as: (.*) \*/>) {
d251 16
d268 21
a288 15
    next if /^ * /;
    while (m/\bDIE\b|Perl_(croak|die|warn(er)?)/ and not m/\);$/) {
      my $nextline = <$codefh>;
      # Means we fell off the end of the file.  Not terribly surprising;
      # this code tries to merge a lot of things that aren't regular C
      # code (preprocessor stuff, long comments).  That's OK; we don't
      # need those anyway.
      last if not defined $nextline;
      chomp $nextline;
      $nextline =~ s/^\s+//;
      # Note that we only want to do this where *both* are true.
      $_ =~ s/\\$//;
      if ($_ =~ m/"$/ and $nextline =~ m/^"/) {
        $_ =~ s/"$//;
        $nextline =~ s/^"//;
a289 1
      $_ = "$_$nextline";
d293 6
a298 14
    # List from perlguts.pod "Formatted Printing of IVs, UVs, and NVs"
    my %specialformats = (IVdf => 'd',
                          UVuf => 'd',
                          UVof => 'o',
                          UVxf => 'x',
                          UVXf => 'X',
                          NVef => 'f',
                          NVff => 'f',
                          NVgf => 'f',
                          SVf  => 's');
    for my $from (keys %specialformats) {
      s/%"\s*$from\s*"/\%$specialformats{$from}/g;
      s/%"\s*$from/\%$specialformats{$from}"/g;
    }
d300 10
a309 13
    if (m/(?:DIE|Perl_(croak|die|warn|warner))(?:_nocontext)? \s*
          \(aTHX_ \s*
          (?:packWARN\d*\((.*?)\),)? \s*
          "((?:\\"|[^"])*?)"/x) {
      # diag($_);
      # DIE is just return Perl_die
      my $severity = {croak => [qw/P F/],
                      die   => [qw/P F/],
                      warn  => [qw/W D S/],
                     }->{$1||'die'};
      my @@categories;
      if ($2) {
        @@categories = map {s/^WARN_//; lc $_} split /\s*[|,]\s*/, $2;
d311 18
a328 14
      my $name;
      if ($listed_as and $listed_as_line == $.) {
        $name = $listed_as;
      } else {
        $name = $3;
        # The form listed in perldiag ignores most sorts of fancy printf formatting,
        # or makes it more perlish.
        $name =~ s/%%/\\%/g;
        $name =~ s/%l[ud]/%d/g;
        $name =~ s/%\.(\d+|\*)s/\%s/g;
        $name =~ s/\\"/"/g;
        $name =~ s/\\t/\t/g;
        $name =~ s/\\n/ /g;
        $name =~ s/\s+$//;
d330 57
d388 3
a390 12
      # Extra explanatory info on an already-listed error, doesn't
      # need it's own listing.
      next if $name =~ m/^\t/;

      # Happens fairly often with PL_no_modify.
      next if $name eq '%s';

      # Special syntax for magic comment, allows ignoring the fact
      # that it isn't listed.  Only use in very special circumstances,
      # like this script failing to notice that the Perl_croak call is
      # inside an #if 0 block.
      next if $name eq 'SKIPME';
d392 25
a416 2
      if (exists $entries{$name}) {
        if ($entries{$name}{todo}) {
d418 8
a425 6
	    no warnings 'once';
            local $::TODO = 'in DATA';
            fail("Presence of '$name' from $codefn line $.");
          }
        } else {
          ok("Presence of '$name' from $codefn line $.");
a426 6
        # Later, should start checking that the severity is correct, too.
      } elsif ($name =~ m/^panic: /) {
        # Just too many panic:s, they are hard to diagnose, and there
        # is a generic "panic: %s" entry.  Leave these for another
        # pass.
        ok("Presence of '$name' from $codefn line $., covered by panic: %s entry");
d428 45
a472 5
        if ($make_exceptions_list) {
          print STDERR "$name\n";
        } else {
          fail("Presence of '$name' from $codefn line $.");
        }
d474 3
d478 2
a479 3
      die if $name =~ /%$/;
    }
  }
d481 2
a482 1
# Lists all missing things as of the inaguration of this script, so we
d484 12
d497 6
a502 23
Ambiguous call resolved as CORE::%s(), %s
Ambiguous use of %c resolved as operator %c
Ambiguous use of %c{%s} resolved to %c%s
Ambiguous use of %c{%s%s} resolved to %c%s%s
Ambiguous use of -%s resolved as -&%s()
Argument "%s" isn't numeric
Argument "%s" isn't numeric in %s
Attempt to clear deleted array
Attempt to free non-arena SV: 0x%x
Attempt to free non-existent shared string '%s'%s
Attempt to free temp prematurely: SV 0x%x
Attempt to free unreferenced scalar: SV 0x%x
Attempt to reload %s aborted. Compilation failed in require
av_reify called on tied array
Bad name after %s%s
Bad symbol for %s
bad top format reference
Bizarre copy of %s
Bizarre SvTYPE [%d]
Cannot copy to %s
Can't call method "%s" %s
Can't coerce readonly %s to string
Can't coerce readonly %s to string in %s
d505 5
a509 11
Can't goto subroutine from an eval-block
Can't goto subroutine from an eval-string
Can't locate object method "%s" via package "%s" (perhaps you forgot to load "%s"?)
Can't modify non-existent substring
Can't open
Can't open perl script "%s": %s
Can't open %s
Can't reset \%ENV on this system
Can't return array to lvalue scalar context
Can't return a %s from lvalue subroutine
Can't return hash to lvalue scalar context
a512 1
Can't %s %s%s%s
a513 2
Can't take %s of %f
Can't use '%c' after -mname
a514 3
Can't use \\%c to mean $%c in expression
Can't use when() outside a topicalizer
\\%c better written as $%c
d516 2
a517 2
$%c is no longer supported
Cloning substitution context is unimplemented
d520 2
a521 2
Compilation failed in require
Corrupted regexp opcode %d > %d
d523 5
a527 4
Debug leaking scalars child failed%s%s with errno %d: %s
Deep recursion on anonymous subroutine
defined(\%hash) is deprecated
Don't know how to handle magic of type \\%o
d529 6
a534 2
entering effective gid failed
entering effective uid failed
d536 2
a537 1
Exiting %s via %s
d541 4
d546 1
a546 1
Format STDOUT redefined
d548 23
d572 7
d581 1
d584 3
a586 2
Hash \%%s missing the \% in argument %d of %s()
Illegal character \\%03o (carriage return)
d588 4
a591 6
Integer overflow in decimal number
Integer overflow in version %d
internal \%<num>p might conflict with future printf extensions
invalid control request: '\\%03o'
Invalid module name %s with -%c option: contains single ':'
invalid option -D%c, use -D'' to see choices
d599 8
a606 19
Invalid strict version format (0 before decimal required)
Invalid strict version format (no leading zeros)
Invalid strict version format (no underscores)
Invalid strict version format (v1.2.3 required)
Invalid strict version format (version required)
Invalid strict version format (1.[0-9] required)
Invalid version format (alpha without decimal)
Invalid version format (misplaced _ in number)
Invalid version object
'j' not supported on this platform
'J' not supported on this platform
Layer does not match this perl
leaving effective gid failed
leaving effective uid failed
List form of piped open not implemented
Lost precision when decrementing %f by 1
Lost precision when incrementing %f by 1
%lx
Malformed UTF-16 surrogate
a607 1
'\%' may not be used in pack
d611 3
a613 5
mprotect for %p %d failed with %d
mprotect RW for %p %d failed with %d
No code specified for -%c
No directory specified for -I
No such class field "%s"
d615 2
a616 4
Not %s reference
Offset outside string
Opening dirhandle %s also as a file
Opening filehandle %s also as a directory
d618 7
a624 6
PERL_SIGNALS illegal: "%s"
Perl %s required (did you mean %s?)--this is only %s, stopped
Perl %s required--this is only %s, stopped
Perls since %s too modern--this is %s, stopped
Possible unintended interpolation of $\\ in regex
ptr wrong %p != %p fl=%08
d626 2
a627 6
Recursive call to Perl_load_module in PerlIO_find_layer
refcnt_dec: fd %d < 0
refcnt_dec: fd %d: %d <= 0
refcnt_dec: fd %d >= refcnt_size %d
refcnt_inc: fd %d < 0
refcnt_inc: fd %d: %d <= 0
d629 2
a630 5
Runaway prototype
%s(%.0f) failed
%s(%.0f) too large
Scalar value %s better written as $%s
%sCompilation failed in regexp
d632 4
d637 1
a640 1
%s: illegal mapping '%s'
d643 2
a644 2
%s limit (%d) exceeded
%s method "%s" overloading "%s" in package "%s"
a645 1
%s object version %s does not match %s%s%s%s %s
d647 4
a650 4
%s returned from lvalue subroutine in scalar context
%s%s has too many errors.
%s%s on %s %s
%s%s on %s %s %s
d653 6
a658 3
strxfrm() gets absurd
SWASHNEW didn't return an HV ref
-T and -B not implemented on filehandles
a661 1
The stat preceding lstat() wasn't an lstat
d663 2
a665 2
Too late to run CHECK block
Too late to run INIT block
d668 4
a671 7
Unbalanced string table refcount: (%d) for "%s"
Undefined top format called
Unexpected constant lvalue entersub entry via type/targ %d:%d
Unicode non-character 0x%04
Unknown PerlIO layer "scalar"
Unknown Unicode option letter '%c'
unrecognised control character '%c'
a672 4
Unsupported script encoding UTF-16BE
Unsupported script encoding UTF-16LE
Unsupported script encoding UTF-32BE
Unsupported script encoding UTF-32LE
a673 1
Usage: CODE(0x%x)(%s)
d676 8
d685 2
d689 1
a689 2
UTF-16 surrogate 0x%04
utf8 "\\x%02X" does not map to Unicode
d691 1
a691 4
value of node is %d in Offset macro
Value of %s%s can be "0"; test with defined()
Variable "%c%s" is not imported
vector argument not supported with alpha versions
d694 3
a696 2
Wide character in print
Wide character in %s
d698 1
d700 1
d702 11
@


1.1.1.1
log
@Perl 5.12.2 from CPAN
@
text
@@


1.1.1.2
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@a4 1
chdir 't';
a10 6
# --make-exceptions-list outputs the list of strings that don't have
# perldiag.pod entries to STDERR without TAP formatting, so they can
# easily be put in the __DATA__ section of this file.  This was done
# initially so as to not create new test failures upon the initial
# creation of this test file.  You probably shouldn't do it again.
# Just add the documentation instead.
d16 2
a17 37
my @@functions;

open my $func_fh, "<", "embed.fnc" or die "Can't open embed.fnc: $!";

# Look for functions in embed.fnc that look like they could be diagnostic ones.
while (<$func_fh>) {
  chomp;
  s/^\s+//;
  while (s/\s*\\$//) {      # Grab up all continuation lines, these end in \
    my $next = <$func_fh>;
    $next =~ s/^\s+//;
    chomp $next;
    $_ .= $next;
  }
  next if /^:/;     # Lines beginning with colon are comments.
  next unless /\|/; # Lines without a vertical bar are something we can't deal
                    # with
  my @@fields = split /\s*\|\s*/;
  next unless $fields[2] =~ /warn|err|(\b|_)die|croak/i;
  push @@functions, $fields[2];

  # The flag p means that this function may have a 'Perl_' prefix
  # The flag s means that this function may have a 'S_' prefix
  push @@functions, "Perl_$fields[2]", if $fields[0] =~ /p/;
  push @@functions, "S_$fields[2]", if $fields[0] =~ /s/;
}

close $func_fh;

my $function_re = join '|', @@functions;
my $source_msg_re = '(?<routine>\bDIE\b|$function_re)';
my $text_re = '"(?<text>(?:\\\\"|[^"]|"\s*[A-Z_]+\s*")*)"';
my $source_msg_call_re = qr/$source_msg_re(?:_nocontext)? \s*
    \(aTHX_ \s*
    (?:packWARN\d*\((?<category>.*?)\),)? \s*
    $text_re /x;
my $bad_version_re = qr{BADVERSION\([^"]*$text_re};
a19 2

# Get the ignores that are compiled into this file
a24 1
my $pod = "pod/perldiag.pod";
a25 6
open my $diagfh, "<", $pod
  or die "Can't open $pod: $!";

my $category_re = qr/ [a-z0-9_]+?/;      # Note: requires an initial space
my $severity_re = qr/ . (?: \| . )* /x; # A severity is a single char, but can
                                        # be of the form 'S|P|W'
d29 3
a31 9

    if (exists $entries{$cur_entry}) {
        TODO: {
            local $::TODO = "Remove the TODO entry \"$cur_entry\" from DATA as it is already in $pod near line $.";
            ok($cur_entry);
        }
    }
    # Make sure to init this here, so an actual entry in perldiag
    # overwrites one in DATA.
d33 2
a34 21
    $entries{$cur_entry}{line_number} = $.;
    next;
  }

  next if ! defined $cur_entry;

  if (! $entries{$cur_entry}{severity}) {
    if (/^ \( ( $severity_re )

        # Can have multiple categories separated by commas
        (?: ( $category_re ) (?: , $category_re)* )? \) /x)
    {
      $entries{$cur_entry}{severity} = $1;
      $entries{$cur_entry}{category} = $2;
    }
    elsif (! $entries{$cur_entry}{first_line} && $_ =~ /\S/) {

      # Keep track of first line of text if doesn't contain a severity, so
      # that can later examine it to determine if that is ok or not
      $entries{$cur_entry}{first_line} = $_;
    }
d38 1
a38 49
foreach my $cur_entry ( keys %entries) {
    next if $entries{$cur_entry}{todo}; # If in this file, won't have a severity
    if (! exists $entries{$cur_entry}{severity}

            # If there is no first line, it was two =items in a row, so the
            # second one is the one with with text, not this one.
        && exists $entries{$cur_entry}{first_line}

            # If the first line refers to another message, no need for severity
        && $entries{$cur_entry}{first_line} !~ /^See/)
    {
        fail($cur_entry);
        diag(
            "   $pod entry at line $entries{$cur_entry}{line_number}\n"
          . "       \"$cur_entry\"\n"
          . "   is missing a severity and/or category"
        );
    }
}

# List from perlguts.pod "Formatted Printing of IVs, UVs, and NVs"
# Convert from internal formats to ones that the readers will be familiar
# with, while removing any format modifiers, such as precision, the
# presence of which would just confuse the pod's explanation
my %specialformats = (IVdf => 'd',
		      UVuf => 'd',
		      UVof => 'o',
		      UVxf => 'x',
		      UVXf => 'X',
		      NVef => 'f',
		      NVff => 'f',
		      NVgf => 'f',
		      HEKf256=>'s',
		      HEKf => 's',
		      SVf256=>'s',
		      SVf32=> 's',
		      SVf  => 's');
my $format_modifiers = qr/ [#0\ +-]*              # optional flags
			  (?: [1-9][0-9]* | \* )? # optional field width
			  (?: \. \d* )?           # optional precision
			  (?: h|l )?              # optional length modifier
			/x;

my $specialformats =
 join '|', sort { length $b cmp length $a } keys %specialformats;
my $specialformats_re = qr/%$format_modifiers"\s*($specialformats)(\s*")?/;

# Recursively descend looking for source files.
my @@todo = sort <*>;
d45 1
a45 1
    unshift @@todo, sort glob "$todo/*";
a50 18
# Standardize messages with variants into the form that appears
# in perldiag.pod -- useful for things without a diag_listed_as annotation
sub standardize {
  my ($name) = @@_;

  if    ( $name =~ m/^(Invalid strict version format) \([^\)]*\)/ ) {
    $name = "$1 (\%s)";
  }
  elsif ( $name =~ m/^(Invalid version format) \([^\)]*\)/ ) {
    $name = "$1 (\%s)";
  }
  elsif ($name =~ m/^panic: /) {
    $name = "panic: \%s";
  }

  return $name;
}

d54 1
a54 1
  print "# Checking $codefn\n";
d67 2
a68 2
    if (m<^[^#\s]> and $_ !~ m/^[{}]*$/) {
      $sub = $_;
d76 15
a90 22
    next if /^ +/;

    my $multiline = 0;
    # Loop to accumulate the message text all on one line.
    if (m/$source_msg_re(?:_nocontext)?\s*\(/) {
      while (not m/\);$/) {
        my $nextline = <$codefh>;
        # Means we fell off the end of the file.  Not terribly surprising;
        # this code tries to merge a lot of things that aren't regular C
        # code (preprocessor stuff, long comments).  That's OK; we don't
        # need those anyway.
        last if not defined $nextline;
        chomp $nextline;
        $nextline =~ s/^\s+//;
        $_ =~ s/\\$//;
        # Note that we only want to do this where *both* are true.
        if ($_ =~ m/"$/ and $nextline =~ m/^"/) {
          $_ =~ s/"$//;
          $nextline =~ s/^"//;
        }
        $_ .= $nextline;
        ++$multiline;
d92 1
d96 14
a109 6

    s/$specialformats_re/"%$specialformats{$1}" .  (defined $2 ? '' : '"')/ge;

    # Remove any remaining format modifiers, but not in %%
    s/ (?<!%) % $format_modifiers ( [dioxXucsfeEgGp] ) /%$1/xg;

d111 7
a117 14
    # diag($_);
    # DIE is just return Perl_die
    my ($name, $category);
    if (/$source_msg_call_re/) {
      ($name, $category) = ($+{'text'}, $+{'category'});
    }
    elsif (/$bad_version_re/) {
      ($name, $category) = ($+{'text'}, undef);
    }
    else {
      next;
    }

    my $severity = {croak => [qw/P F/],
d120 20
a139 33
                     }->{$+{'routine'}||'die'};
    my @@categories;
    if (defined $category) {
      @@categories = map {s/^WARN_//; lc $_} split /\s*[|,]\s*/, $category;
    }
    if ($listed_as and $listed_as_line == $. - $multiline) {
      $name = $listed_as;
    } else {
      # The form listed in perldiag ignores most sorts of fancy printf
      # formatting, or makes it more perlish.
      $name =~ s/%%/%/g;
      $name =~ s/%l[ud]/%d/g;
      $name =~ s/%\.(\d+|\*)s/\%s/g;
      $name =~ s/(?:%s){2,}/%s/g;
      $name =~ s/(\\")|("\s*[A-Z_]+\s*")/$1 ? '"' : '%s'/egg;
      $name =~ s/\\t/\t/g;
      $name =~ s/\\n/\n/g;
      $name =~ s/\s+$//;
      $name =~ s/(\\)\\/$1/g;
    }

    # Extra explanatory info on an already-listed error, doesn't
    # need it's own listing.
    next if $name =~ m/^\t/;

    # Happens fairly often with PL_no_modify.
    next if $name eq '%s';

    # Special syntax for magic comment, allows ignoring the fact
    # that it isn't listed.  Only use in very special circumstances,
    # like this script failing to notice that the Perl_croak call is
    # inside an #if 0 block.
    next if $name eq 'SKIPME';
d141 12
a152 3
    check_message(standardize($name),$codefn);
  }
}
d154 2
a155 10
sub check_message {
    my($name,$codefn,$partial) = @@_;
    my $key = $name =~ y/\n/ /r;
    my $ret;

    if (exists $entries{$key}) {
      $ret = 1;
      if ( $entries{$key}{seen}++ ) {
        # no need to repeat entries we've tested
      } elsif ($entries{$name}{todo}) {
d157 6
a162 8
          no warnings 'once';
          local $::TODO = 'in DATA';
          # There is no listing, but it is in the list of exceptions.  TODO FAIL.
          fail($name);
          diag(
            "    Message '$name'\n    from $codefn line $. is not listed in $pod\n".
            "    (but it wasn't documented in 5.10 either, so marking it TODO)."
          );
d164 6
d171 5
a175 2
        # We found an actual valid entry in perldiag.pod for this error.
        pass($key);
d177 2
a178 26
      # Later, should start checking that the severity is correct, too.
    } elsif ($partial) {
      # noop
    } else {
      my $ok;
      if ($name =~ /\n/) {
        $ok = 1;
        check_message($_,$codefn,1) or $ok = 0, last for split /\n/, $name;
      }
      if ($ok) {
        # noop
      } elsif ($make_exceptions_list) {
        # We're making an updated version of the exception list, to
        # stick in the __DATA__ section.  I honestly can't think of
        # a situation where this is the right thing to do, but I'm
        # leaving it here, just in case one of my descendents thinks
        # it's a good idea.
        print STDERR "$key\n";
      } else {
        # No listing found, and no excuse either.
        # Find the correct place in perldiag.pod, and add a stanza beginning =item $name.
        fail($name);
        diag("    Message '$name'\n    from $codefn line $. is not listed in $pod");
      }
      # seen it, so only fail once for this message
      $entries{$name}{seen}++;
d180 1
a180 3

    die if $name =~ /%$/;
    return $ret;
d182 1
a182 2

# Lists all missing things as of the inauguration of this script, so we
a183 6
# 
# PLEASE DO NOT ADD TO THIS LIST.  Instead, write an entry in
# pod/perldiag.pod for your new (warning|error).

# Also FIXME this test, as the first entry in TODO *is* covered by the
# description: Malformed UTF-8 character (%s)
d185 16
a200 4
Malformed UTF-8 character (unexpected non-continuation byte 0x%x, immediately after start byte 0x%x)

%s (%d) does not match %s (%d),
%s (%d) smaller than %s (%d),
d202 4
d210 2
d213 8
d224 1
d226 2
d229 3
a231 1
\%c better written as $%c
d233 2
d237 1
d240 4
a243 2
Debug leaking scalars child failed%s with errno %d: %s
Don't know how to handle magic of type \%o
d245 2
d248 1
d253 1
d260 2
d263 1
d265 4
a268 2
internal %<num>p might conflict with future printf extensions
invalid control request: '\%o'
d276 9
d287 8
d296 1
d300 5
a304 2
mprotect for %p %u failed with %d
mprotect RW for %p %u failed with %d
d306 4
d311 2
d314 3
a316 1
ptr wrong %p != %p fl=%x nl=%p e=%p for %d
d318 6
d326 3
a328 1
%s(%f) failed
d335 1
d338 2
d341 1
a341 1
%s object version %s does not match %s %s
d343 4
a346 3
%s has too many errors.
%s on %s %s
%s on %s %s %s
d349 1
d355 1
d358 2
d362 1
d364 5
d370 4
d381 2
a382 1
utf8 "\x%X" does not map to Unicode
d385 1
d387 1
d391 1
@


1.1.1.3
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d5 2
a6 4
BEGIN {
  chdir 't';
  require './test.pl';
}
a51 1
my $regcomp_re = "(?<routine>(?:ckWARN(?:\\d+)?reg\\w*|vWARN\\d+))";
d53 1
a53 3
my $regcomp_fail_re = '\b(?:(?:Simple_)?v)?FAIL[2-4]?\b';
my $source_msg_re =
   "(?<routine>\\bDIE\\b|$function_re|$regcomp_fail_re)";
a59 2
   $regcomp_fail_re = qr/$regcomp_fail_re\([^"]*$text_re/;
my $regcomp_call_re = qr/$regcomp_re.*?$text_re/;
a63 1
my $reading_categorical_exceptions;
d66 1
a66 2
  $entries{$_}{$reading_categorical_exceptions ? 'cattodo' : 'todo'}=1;
  /__CATEGORIES__/ and ++$reading_categorical_exceptions;
d74 1
a74 1
my $category_re = qr/ [a-z0-9_:]+?/;    # Note: requires an initial space
a76 1
my @@same_descr;
d81 1
a81 13
    # Allow multi-line headers
    while (<$diagfh>) {
      if (/^\s*$/) {
        last;
      }

      $cur_entry .= $_;
    }

    $cur_entry =~ s/\n/ /gs; # Fix multi-line headers if they have \n's
    $cur_entry =~ s/\s+\z//;

    if (exists $entries{$cur_entry} && $entries{$cur_entry}{todo}) {
d91 1
d100 1
a100 1
        ( $category_re (?: , $category_re)* )? \) /x)
d103 1
a103 7
      $entries{$cur_entry}{category} =
        $2 && join ", ", sort split " ", $2 =~ y/,//dr;

      # Record it also for other messages sharing the same description
      @@$_{qw<severity category>} =
        @@{$entries{$cur_entry}}{qw<severity category>}
       for @@same_descr;
a110 6
    if (/\S/) {
      @@same_descr = ();
    }
    else {
      push @@same_descr, $entries{$cur_entry};
    }
d161 12
a172 9
open my $fh, '<', 'MANIFEST' or die "Can't open MANIFEST: $!";
while (my $file = <$fh>) {
    chomp $file;
    $file =~ s/\s+.*//;
    next unless $file =~ /\.(?:c|cpp|h|xs|y)\z/ or $file =~ /^perly\./;
    # OS/2 extensions have never been migrated to ext/, hence the special case:
    next if $file =~ m!\A(?:ext|dist|cpan|lib|t|os2/OS2)/!
            && $file !~ m!\Aext/DynaLoader/!;
    check_file($file);
a173 1
close $fh or die $!;
d213 1
a213 1
    if (m</\*\s*diag_listed_as: (.*?)\s*\*/>) {
d218 1
d222 1
a222 1
    if (m/(?:$source_msg_re(?:_nocontext)?|$regcomp_re)\s*\(/) {
d253 1
a253 1
    my ($name, $category, $routine);
d255 1
a255 4
      ($name, $category, $routine) = ($+{'text'}, $+{'category'}, $+{'routine'});
      # Sometimes the regexp will pick up too much for the category
      # e.g., WARN_UNINITIALIZED), PL_warn_uninit_sv ... up to the next )
      $category && $category =~ s/\).*//s;
a259 16
    elsif (/$regcomp_fail_re/) {
      #  FAIL("foo") -> "foo in regex m/%s/"
      # vFAIL("foo") -> "foo in regex; marked by <-- HERE in m/%s/"
      ($name, $category) = ($+{'text'}, undef);
      $name .=
        " in regex" . ("; marked by <-- HERE in" x /vFAIL/) . " m/%s/";
    }
    elsif (/$regcomp_call_re/) {
      # vWARN/ckWARNreg("foo") -> "foo in regex; marked by <-- HERE in m/%s/
      ($name, $category, $routine) = ($+{'text'}, undef, $+{'routine'});
      $name .= " in regex; marked by <-- HERE in m/%s/";
      $category = 'WARN_REGEXP';
      if ($routine =~ /dep/) {
        $category .= ',WARN_DEPRECATED';
      }
    }
d264 5
a268 14
    # Try to guess what the severity should be.  In the case of
    # Perl_ck_warner and other _ck_ functions, we can tell whether it is
    # a severe/default warning or no by the _d suffix.  In the case of
    # other warn functions we cannot tell, because Perl_warner may be pre-
    # ceded by if(ckWARN) or if(ckWARN_d).
    my $severity = !$routine                   ? '[PFX]'
                 :  $routine =~ /warn.*_d\z/   ? '[DS]'
                 :  $routine =~ /ck_warn/      ?  'W'
                 :  $routine =~ /warn/         ? '[WDS]'
                 :  $routine =~ /ckWARN.*dep/  ?  'D'
                 :  $routine =~ /ckWARN\d*reg/ ?  'W'
                 :  $routine =~ /vWARN\d/      ? '[WDS]'
                 :                             '[PFX]';
    my $categories;
d270 1
a270 4
      $category =~ s/__/::/g;
      $categories =
        join ", ",
              sort map {s/^WARN_//; lc $_} split /\s*[|,]\s*/, $category;
d301 1
a301 3
    next if $name=~/\[TESTING\]/; # ignore these as they are works in progress

    check_message(standardize($name),$codefn,$severity,$categories);
d306 1
a306 1
    my($name,$codefn,$severity,$categories,$partial) = @@_;
a309 12
    # Try to reduce printf() formats to simplest forms
    # Really this should be matching %s, etc like diagnostics.pm does

    # Kill flags
    $key =~ s/%[#0\-+]/%/g;

    # Kill width
    $key =~ s/\%(\d+|\*)/%/g;

    # Kill precision
    $key =~ s/\%\.(\d+|\*)/%/g;

d314 1
a314 1
      } elsif ($entries{$key}{todo}) {
d319 1
a319 1
          fail($key);
a327 19

        # Now check the category and severity

        # Cache our severity qr thingies
        use 5.01;
        state %qrs;
        my $qr = $qrs{$severity} ||= qr/$severity/;

        return $ret
          if $entries{$key}{cattodo};

        like $entries{$key}{severity}, $qr,
          $severity =~ /\[/
            ? "severity is one of $severity for $key"
            : "severity is $severity for $key";

        is $entries{$key}{category}, $categories,
           ($categories ? "categories are [$categories]" : "no category")
             . " for $key";
d336 1
a336 2
        check_message($_,$codefn,$severity,$categories,1) or $ok = 0, last
          for split /\n/, $name;
a366 3
# Entries after __CATEGORIES__ are those that are in perldiag but fail the
# severity/category test.

d372 2
a373 1
'%c' allowed only after types %s in %s
a374 4
Cannot apply "%s" in non-PerlIO perl
Can't %s big-endian %ss on this
Can't call mro_isa_changed_in() on anonymous symbol table
Can't call mro_method_changed_in() on anonymous symbol table
a376 1
Can't find string terminator %c%s%c anywhere before EOF
a379 2
Can't pipe "%s": %s
Can't spawn: %s
a386 2
chown not implemented!
clear %s
d389 1
a391 2
'/' does not take a repeat count in %s
Don't know how to get file name
a394 2
execl not implemented!
EVAL without pos change exceeded limit in regex
a397 1
filter_del can only delete in reverse order (currently)
a398 2
fork() not implemented!
free %s
a400 2
gethostent not implemented!
getpwnam returned invalid UIC %o for user "%s"
a404 3
Got signal %d
()-group starts with a count in %s
Illegal binary digit '%c' ignored
d406 1
a406 3
Illegal hexadecimal digit '%c' ignored
Illegal octal digit '%c' ignored
Infinite recursion in regex
d408 1
a408 1
Invalid argument to sv_cat_decode
a415 1
ioctlsocket not implemented!
a417 6
killpg not implemented!
length() used on %s (did you mean "scalar(%s)"?)
length() used on %hash (did you mean "scalar(keys %hash)"?)
length() used on @@array (did you mean "scalar(@@array)"?)
List form of pipe open not implemented
Malformed integer in [] in %s
a423 3
No %s allowed while running setgid
No %s allowed with (suid) fdscript
No such class field "%s"
a425 1
Pattern subroutine nesting without pos change exceeded limit in regex
a426 2
PerlApp::TextQuery: no arguments, please
POSIX syntax [%c %c] is reserved for future extensions in regex; marked by <-- HERE in m/%s/
a428 5
Regexp modifier "%c" may appear a maximum of twice in regex; marked by <-- HERE in m/%s/
Regexp modifier "%c" may not appear twice in regex; marked by <-- HERE in m/%s/
Regexp modifiers "%c" and "%c" are mutually exclusive in regex; marked by <-- HERE in m/%s/
Regexp *+ operand could be empty in regex; marked by <-- HERE in m/%s/
Repeated format line will never terminate (~~ and @@#)
d430 1
d432 1
a433 6
Sequence (?%c...) not implemented in regex; marked by <-- HERE in m/%s/
Sequence (%s...) not recognized in regex; marked by <-- HERE in m/%s/
Sequence %s... not terminated in regex; marked by <-- HERE in m/%s/
Sequence (?%c... not terminated in regex; marked by <-- HERE in m/%s/
Sequence (?(%c... not terminated in regex; marked by <-- HERE in m/%s/
Sequence (?R) not terminated in regex m/%s/
d441 1
d443 1
a443 1
%s in regex m/%s/
d445 1
a445 1
socketpair not implemented!
a447 1
sv_2iv assumed (U_V(fabs((double)SvNVX(sv))) < (UV)IV_MAX) but SvNVX(sv)=%f U_V is 0x%x, IV_MAX is 0x%x
a448 3
switching effective gid is not implemented
switching effective uid is not implemented
System V IPC is not implemented on this machine
a449 2
Terminating on signal SIG%s(%d)
The crypt() function is not implemented on NetWare
d457 1
a457 3
unable to find VMSPIPE.COM for i/o piping
Unknown Unicode option value %d
Unrecognized character %s; marked by <-- HERE after %s<-- HERE near column %d
a459 1
Unterminated \g... pattern in regex; marked by <-- HERE in m/%s/
a462 7
Usage: File::Copy::rmscopy(from,to[,date_flag])
Usage: VMS::Filespec::candelete(spec)
Usage: VMS::Filespec::fileify(spec)
Usage: VMS::Filespec::pathify(spec)
Usage: VMS::Filespec::rmsexpand(spec[,defspec])
Usage: VMS::Filespec::unixify(spec)
Usage: VMS::Filespec::unixpath(spec)
a463 2
Usage: VMS::Filespec::vmsify(spec)
Usage: VMS::Filespec::vmspath(spec)
d468 2
a469 1
waitpid: process %x is not a child of process %x
d472 1
a472 1
Within []-length '*' not allowed in %s
a474 1
'X' outside of string in %s
a475 15

__CATEGORIES__
Code point 0x%X is not Unicode, all \p{} matches fail; all \P{} matches succeed
Code point 0x%X is not Unicode, may not be portable
Illegal character \%o (carriage return)
Missing argument in %s
Unicode non-character U+%X is illegal for open interchange
Operation "%s" returns its argument for non-Unicode code point 0x%X
Operation "%s" returns its argument for UTF-16 surrogate U+%X
Unicode surrogate U+%X is illegal in UTF-8
UTF-16 surrogate U+%X
False [] range "%s" in regex; marked by <-- HERE in m/%s/
\N{} in character class restricted to one character in regex; marked by <-- HERE in m/%s/
Zero length \N{} in regex; marked by <-- HERE in m/%s/
Expecting '(?flags:(?[...' in regex; marked by <-- HERE in m/%s/
@


1.1.1.4
log
@Import perl-5.20.1
@
text
@a1 6

BEGIN {
  @@INC = '..' if -f '../TestInit.pm';
}
use TestInit qw(T); # T is chdir to the top level

a3 1
use Config;
d5 3
a7 4
require 't/test.pl';

if ( $Config{usecrosscompile} ) {
  skip_all( "Not all files are available during cross-compilation" );
d12 2
d20 1
a20 2
my $make_exceptions_list = ($ARGV[0]||'') eq '--make-exceptions-list'
  and shift;
d22 2
a23 1
require 'regen/embed_lib.pl';
a24 1
# Look for functions that look like they could be diagnostic ones.
d26 20
a45 3
foreach (@@{(setup_embed())[0]}) {
  next if @@$_ < 2;
  next unless $_->[2]  =~ /warn|(?<!ov)err|(\b|_)die|croak/i;
d48 7
a54 8
  push @@functions, $_->[2];
  push @@functions, 'Perl_' . $_->[2] if $_->[0] =~ /p/;
  push @@functions, 'S_' . $_->[2] if $_->[0] =~ /s/;
};

my $regcomp_fail_re = '\b(?:(?:Simple_)?v)?FAIL[2-4]?(?:utf8f)?\b';
my $regcomp_re =
   "(?<routine>ckWARN(?:\\d+)?reg\\w*|vWARN\\d+|$regcomp_fail_re)";
d56 1
d58 1
a58 1
   "(?<routine>\\bDIE\\b|$function_re)";
d61 1
a61 1
    \((?:aTHX_)? \s*
d74 1
a74 2
  $entries{$_}{todo} = 1;
  $reading_categorical_exceptions and $entries{$_}{cattodo}=1;
d97 1
a97 1
      $cur_entry =~ s/ ?\z/ $_/;
a101 1
    $cur_entry =~ s/[BCIFS](?:<<< (.*?) >>>|<< (.*?) >>|<(.*?)>)/$+/g;
d103 1
a103 2
    if (exists $entries{$cur_entry} &&  $entries{$cur_entry}{todo}
                                    && !$entries{$cur_entry}{cattodo}) {
a180 1
		      UTF8f=> 's',
a193 4
if (@@ARGV) {
  check_file($_) for @@ARGV;
  exit;
}
d200 1
a200 1
    next if $file =~ m!\A(?:ext|dist|cpan|lib|t|os2/OS2|x2p)/!
d252 1
a252 1
    if (m/(?!^)\b(?:$source_msg_re(?:_nocontext)?|$regcomp_re)\s*\(/) {
d264 2
a265 2
        if ($_ =~ m/"\s*$/ and $nextline =~ m/^"/) {
          $_ =~ s/"\s*$//;
d284 1
a284 1
    if (/\b$source_msg_call_re/) {
a288 3
      if (/win32_croak_not_implemented\(/) {
        $name .= " not implemented!"
      }
d321 1
a321 2
                 :  $routine =~ /warner/       ? '[WDS]'
                 :  $routine =~ /warn/         ?  'S'
a322 1
                 :  $routine =~ /ckWARN\d*reg_d/? 'S'
d385 1
a385 4
    if (exists $entries{$key} and
          # todo + cattodo means it is not found and it is not in the
          # regular todo list, either
          !$entries{$key}{todo} || !$entries{$key}{cattodo}) {
a403 3
        return $ret
          if $entries{$key}{cattodo};

d407 1
a407 1
        use feature 'state';
d411 4
a414 1
        like($entries{$key}{severity}, $qr,
d417 1
a417 1
            : "severity is $severity for $key");
d419 1
a419 1
        is($entries{$key}{category}, $categories,
d421 1
a421 1
             . " for $key");
d423 1
d460 1
a460 4
# pod/perldiag.pod for your new (warning|error).  Nevertheless,
# listing exceptions here when this script is not smart enough
# to recognize the messages is not so bad, as long as there are
# entries in perldiag.
d470 2
d473 5
a477 2
Cannot set timer
Can't find DLL name for the module `%s' by the handle %d, rc=%u=%x
a480 2
Can't load DLL `%s', possible problematic module `%s'
Can't locate %s:   %s
a482 1
Can't set type on DOS
d489 1
a494 2
Could not find version 1.1 of winsock dll
Could not find version 2.0 of winsock dll
a496 3
detach of a thread which could not start
detach on an already detached thread
detach on a thread with a waiter
d498 2
a500 6
Empty array reference given to mod2fname
endhostent not implemented!
endnetent not implemented!
endprotoent not implemented!
endservent not implemented!
Error loading module '%s': %s
a506 1
file_type not implemented on DOS
d508 1
a508 1
fork() not available
a509 1
YOU HAVEN'T DISABLED SET-ID SCRIPTS IN THE KERNEL YET! FIX YOUR KERNEL, PUT A C WRAPPER AROUND THIS SCRIPT, OR USE -u AND UNDUMP!
a511 23
Function "endnetent" not implemented in this version of perl.
Function "endprotoent" not implemented in this version of perl.
Function "endservent" not implemented in this version of perl.
Function "getnetbyaddr" not implemented in this version of perl.
Function "getnetbyname" not implemented in this version of perl.
Function "getnetent" not implemented in this version of perl.
Function "getprotobyname" not implemented in this version of perl.
Function "getprotobynumber" not implemented in this version of perl.
Function "getprotoent" not implemented in this version of perl.
Function "getservbyport" not implemented in this version of perl.
Function "getservent" not implemented in this version of perl.
Function "getsockopt" not implemented in this version of perl.
Function "recvmsg" not implemented in this version of perl.
Function "sendmsg" not implemented in this version of perl.
Function "sethostent" not implemented in this version of perl.
Function "setnetent" not implemented in this version of perl.
Function "setprotoent" not implemented in this version of perl.
Function "setservent"  not implemented in this version of perl.
Function "setsockopt" not implemented in this version of perl.
Function "tcdrain" not implemented in this version of perl.
Function "tcflow" not implemented in this version of perl.
Function "tcflush" not implemented in this version of perl.
Function "tcsendbreak" not implemented in this version of perl.
a513 4
getnetbyaddr not implemented!
getnetbyname not implemented!
getnetent not implemented!
getprotoent not implemented!
a514 1
getservent not implemented!
a516 1
Got an error from DosAllocMem: %i
d525 2
a526 1
INSTALL_PREFIX too long: `%s'
a534 1
ioctl implemented only on sockets
d536 2
a537 1
join with a thread with a waiter
d539 3
a542 1
Looks like we have no PM; will not load DLL %s without $ENV{PERL_ASIF_PM}
a543 1
Malformed %s
d548 2
a549 1
No message queue
d552 1
a553 2
Not a reference given to mod2fname
Not array reference given to mod2fname
d555 2
a556 2
Out of memory during list extend
panic queryaddr
a559 1
QUITing...
d561 3
a563 1
recursion detected in %s
d565 1
a566 1
%s: Can't parse EXE/DLL name: '%s'
d569 6
a574 4
%s: Error stripping dirs from EXE/DLL/INSTALLDIR name
sethostent not implemented!
setnetent not implemented!
setprotoent not implemented!
a575 1
setservent not implemented!
a580 2
%s: name `%s' too long
%s not implemented!
a585 1
%s: %s
d589 1
d593 1
a599 2
This perl was compiled without taint support. Cowardly refusing to run with -t or -T flags
This version of OS/2 does not support %s.%s
d604 1
a604 2
Unable to locate winsock library!
Unexpected program mode %d when morphing back from PM
d608 2
a611 1
Usage: CODE(0x%x)(%s)
a628 2
win32_get_osfhandle() TBD on this platform
win32_open_osfhandle() TBD on this platform
a630 1
Wrong size of loadOrdinals array: expected %d, actual %d
d636 2
a637 2

# This is a warning, but is currently followed immediately by a croak (toke.c)
a638 2

# Because uses WARN_MISSING as a synonym for WARN_UNINITIALIZED (sv.c)
d640 5
a644 2

# This message can be both fatal and non-
d646 3
@


1.1.1.5
log
@Import perl-5.20.2
@
text
@d486 1
@


1.1.1.6
log
@Import perl-5.24.2
@
text
@a41 1
push @@functions, 'Perl_mess';
a92 3
    $cur_entry =~ s/E<lt>/</g;
    $cur_entry =~ s/E<gt>/>/g;
    $cur_entry =~ s,E<sol>,/,g;
d177 1
a177 2
		      SVf  => 's',
		      PNf  => 's');
d198 1
a198 1
    next if $file =~ m!\A(?:ext|dist|cpan|lib|t|os2/OS2)/!
a245 16
    elsif (m</\*\s*diag_listed_as: (.*?)\s*\z>) {
      $listed_as = $1;
      my $finished;
      while (<$codefh>) {
        if (m<\*/>) {
          $listed_as .= $` =~ s/^\s*/ /r =~ s/\s+\z//r;
          $listed_as_line = $.+1;
          $finished = 1;
          last;
        }
        else {
          $listed_as .= s/^\s*/ /r =~ s/\s+\z//r;
        }
      }
      if (!$finished) { $listed_as = undef }
    }
d251 1
a251 1
      while (not m/\);\s*$/) {
a598 1
Parse error
@


