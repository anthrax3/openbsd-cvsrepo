head	1.8;
access;
symbols
	OPENBSD_6_2:1.8.0.2
	OPENBSD_6_2_BASE:1.8
	PERL_5_24_2:1.1.1.6
	OPENBSD_6_1:1.8.0.4
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.7.0.8
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.2
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	PERL_5_20_2:1.1.1.5
	OPENBSD_5_7:1.5.0.2
	OPENBSD_5_7_BASE:1.5
	PERL_5_20_1:1.1.1.5
	OPENBSD_5_6:1.3.0.4
	OPENBSD_5_6_BASE:1.3
	PERL_5_18_2:1.1.1.4
	PERL:1.1.1
	OPENBSD_5_5:1.2.0.6
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.2
	OPENBSD_5_4_BASE:1.2
	PERL_5_16_3:1.1.1.3
	OPENBSD_5_3:1.1.1.2.0.14
	OPENBSD_5_3_BASE:1.1.1.2
	OPENBSD_5_2:1.1.1.2.0.12
	OPENBSD_5_2_BASE:1.1.1.2
	OPENBSD_5_1_BASE:1.1.1.2
	OPENBSD_5_1:1.1.1.2.0.10
	OPENBSD_5_0:1.1.1.2.0.8
	OPENBSD_5_0_BASE:1.1.1.2
	OPENBSD_4_9:1.1.1.2.0.6
	OPENBSD_4_9_BASE:1.1.1.2
	PERL_5_12_2:1.1.1.2
	OPENBSD_4_8:1.1.1.2.0.4
	OPENBSD_4_8_BASE:1.1.1.2
	OPENBSD_4_7:1.1.1.2.0.2
	OPENBSD_4_7_BASE:1.1.1.2
	PERL_5_10_1:1.1.1.2
	OPENBSD_4_6:1.1.1.1.0.30
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.26
	OPENBSD_4_5_BASE:1.1.1.1
	PERL_5_10_0:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.24
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.22
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.20
	OPENBSD_4_2_BASE:1.1.1.1
	OPENBSD_4_1:1.1.1.1.0.18
	OPENBSD_4_1_BASE:1.1.1.1
	OPENBSD_4_0:1.1.1.1.0.16
	OPENBSD_4_0_BASE:1.1.1.1
	PERL_5_8_8:1.1.1.1
	OPENBSD_3_9:1.1.1.1.0.14
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.12
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.10
	OPENBSD_3_7_BASE:1.1.1.1
	PERL_5_8_6:1.1.1.1
	OPENBSD_3_6:1.1.1.1.0.8
	OPENBSD_3_6_BASE:1.1.1.1
	PERL_5_8_5:1.1.1.1
	PERL_5_8_3:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.6
	OPENBSD_3_5_BASE:1.1.1.1
	PERL_5_8_2:1.1.1.1
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	PERL_5_8_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.8
date	2017.02.05.00.32.21;	author afresh1;	state Exp;
branches;
next	1.7;
commitid	cxJ08BvJA9Pt2PTM;

1.7
date	2015.04.25.19.26.23;	author afresh1;	state Exp;
branches;
next	1.6;
commitid	3qGYFVvfrExB70FB;

1.6
date	2015.04.25.19.14.49;	author afresh1;	state Exp;
branches;
next	1.5;
commitid	XRK22kO4se3v2i2I;

1.5
date	2014.11.17.21.01.01;	author afresh1;	state Exp;
branches;
next	1.4;
commitid	LnErp1MFKSuew5Fr;

1.4
date	2014.11.17.20.57.08;	author afresh1;	state Exp;
branches;
next	1.3;
commitid	QP75iYx42Uo7mMxO;

1.3
date	2014.03.24.15.05.33;	author afresh1;	state Exp;
branches;
next	1.2;

1.2
date	2013.03.25.20.41.00;	author sthen;	state Exp;
branches;
next	1.1;

1.1
date	2002.10.27.22.15.11;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.27.22.15.11;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2009.10.12.18.10.42;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2013.03.25.20.09.38;	author sthen;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.03.24.14.59.11;	author afresh1;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2014.11.17.20.53.19;	author afresh1;	state Exp;
branches;
next	1.1.1.6;
commitid	B31cAbBIXiCqnL97;

1.1.1.6
date	2017.08.14.13.46.25;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.8
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@use strict;
use warnings;

# re/fold_grind.t has more complex tests, but doesn't test every fold
# This file also tests the fc() keyword.

BEGIN {
    chdir 't' if -d 't';
    require './test.pl';
    set_up_inc('../lib');
    skip_all_without_unicode_tables();
    skip_all_if_miniperl("miniperl, no Unicode::Normalize");
    require Config; import Config;
    require './charset_tools.pl';
    require './loc_tools.pl';   # Contains find_utf8_ctype_locale()
}

use feature 'unicode_strings';
use Unicode::UCD qw(all_casefolds);

binmode *STDOUT, ":utf8";

our $TODO;


plan("no_plan");
# Read in the official case folding definitions.
my $casefolds = all_casefolds();
my @@folds;
my @@CF;
my @@simple_folds;
my %reverse_fold;
use Unicode::UCD;
use charnames();

foreach my $decimal_code_point (sort { $a <=> $b } keys %$casefolds) {
    # We only use simple folds in fc(), since the regex engine uses full case
    # folding.

    my $name = charnames::viacode($decimal_code_point);
    my $type = $casefolds->{$decimal_code_point}{'status'};
    my $code = $casefolds->{$decimal_code_point}{'code'};
    my $simple = $casefolds->{$decimal_code_point}{'simple'};
    my $full = $casefolds->{$decimal_code_point}{'full'};

    if ($simple && $simple ne $full) { # If there is a distinction
        push @@simple_folds, [ $code, $simple, $type, $name ];
    }

    push @@CF, [ $code, $full, $type, $name ];

    # Get the inverse fold for single-char mappings.
    $reverse_fold{pack "W*", hex $simple} = pack "W*", $decimal_code_point if $simple;
}

foreach my $test_ref ( @@simple_folds ) {
    use feature 'fc';
    my ($code, $mapping, $type, $name) = @@$test_ref;
    my $c = pack("W*", hex $code);
    utf8::upgrade($c);
    my $f = pack("W*", map { hex } split " ", $mapping);

    my $against = join "", "qq{", map("\\x{$_}", split " ", $mapping), "}";
    {
        isnt(fc($c), $f, "$code - $name - $mapping - $type - Full casefolding, fc(\\x{$code}) ne $against");
        isnt("\F$c", $f, "$code - $name - $mapping - $type - Full casefolding, qq{\\F\\x{$code}} ne $against");
    }
}

foreach my $test_ref (@@CF) {
    my ($code, $mapping, $type, $name) = @@$test_ref;
    my $c = pack("W*", hex $code);
    utf8::upgrade($c);
    my $f = pack("W*", map { hex } split " ", $mapping);
    my $f_length = length $f;
    foreach my $test (
            qq[":$c:" =~ /:$c:/],
            qq[":$c:" =~ /:$c:/i],
            qq[":$c:" =~ /:[_$c]:/], # Place two chars in [] so doesn't get
                                     # optimized to a non-charclass
            qq[":$c:" =~ /:[_$c]:/i],
            qq[":$c:" =~ /:$f:/i],
            qq[":$f:" =~ /:$c:/i],
    ) {
        ok eval $test, "$code - $name - $mapping - $type - $test";
    }

    {
        # fc() tests
        my $against = join "", "qq{", map("\\x{$_}", split " ", $mapping), "}";
        is(CORE::fc($c), $f,
            "$code - $name - $mapping - $type - fc(\\x{$code}) eq $against");
        is("\F$c", $f, "$code - $name - $mapping - $type - qq{\\F\\x{$code}} eq $against");

        # And here we test bytes. For [A-Za-z0-9], the fold is the same as lc under
        # bytes. For everything else, it's the bytes that formed the original string.
        if ( $c =~ /[A-Za-z0-9]/ ) {
            use bytes;
            is(CORE::fc($c), lc($c), "$code - $name - fc and use bytes, ascii");
        } else {
            my $copy = "" . $c;
            utf8::encode($copy);
            is($copy, do { use bytes; CORE::fc($c) }, "$code - $name - fc and use bytes");
        }
    }
    # Certain tests weren't convenient to put in the list above since they are
    # TODO's in multi-character folds.
    if ($f_length == 1) {

        # The qq loses the utf8ness of ":$f:".  These tests are not about
        # finding bugs in utf8ness, so make sure it's utf8.
        my $test = qq[my \$s = ":$f:"; utf8::upgrade(\$s); \$s =~ /:[_$c]:/i];
        ok eval $test, "$code - $name - $mapping - $type - $test";
        $test = qq[":$c:" =~ /:[_$f]:/i];
        ok eval $test, "$code - $name - $mapping - $type - $test";
    }
    else {

        # There are two classes of multi-char folds that need more work.  For
        # example,
        #   ":ß:" =~ /:[_s]{2}:/i
        #   ":ss:" =~ /:[_ß]:/i
        #
        # Some of the old tests for the second case happened to pass somewhat
        # coincidentally.  But none would pass if changed to this.
        #   ":SS:" =~ /:[_ß]:/i
        #
        # As the capital SS doesn't get folded.  When those pass, it means
        # that the code has been changed to take into account folding in the
        # string, and all should pass, capitalized or not (this wouldn't be
        # true for [^complemented character classes], for which the fold case
        # is better, but these aren't used in this .t currently.  So, what is
        # done is to essentially upper-case the string for this class (but use
        # the reverse fold not uc(), as that is more correct)
        my $u;
        for my $i (0 .. $f_length - 1) {
            my $cur_char = substr($f, $i, 1);
            $u .= $reverse_fold{$cur_char} || $cur_char;
        }
        my $test;

        # A multi-char fold should not match just one char;
        # e.g., ":ß:" !~ /:[_s]:/i
        $test = qq[":$c:" !~ /:[_$f]:/i];
        ok eval $test, "$code - $name - $mapping - $type - $test";

        TODO: { # e.g., ":ß:" =~ /:[_s]{2}:/i
            local $TODO = 'Multi-char fold in [character class]';

            $test = qq[":$c:" =~ /:[_$f]{$f_length}:/i];
            ok eval $test, "$code - $name - $mapping - $type - $test";
        }

        # e.g., ":SS:" =~ /:[_ß]:/i now pass, so TODO has been removed, but
        # since they use '$u', they are left out of the main loop
        $test = qq[ my \$s = ":$u:"; utf8::upgrade(\$s); \$s =~ /:[_$c]:/i];
        ok eval $test, "$code - $name - $mapping - $type - $test";
    }
}

{
    use utf8;
    use feature qw(fc);
    # These three come from the ICU project's test suite, more especifically
    # http://icu.sourcearchive.com/documentation/4.4~rc1-1/strcase_8cpp-source.html

    my $s = "A\N{U+00df}\N{U+00b5}\N{U+fb03}\N{U+1040C}\N{U+0130}\N{U+0131}";
    #\N{LATIN CAPITAL LETTER A}\N{LATIN SMALL LETTER SHARP S}\N{MICRO SIGN}\N{LATIN SMALL LIGATURE FFI}\N{DESERET CAPITAL LETTER AY}\N{LATIN CAPITAL LETTER I WITH DOT ABOVE}\N{LATIN SMALL LETTER DOTLESS I}

    my $f = "ass\N{U+03bc}ffi\N{U+10434}i\N{U+0307}\N{U+0131}";
    #\N{LATIN SMALL LETTER A}\N{LATIN SMALL LETTER S}\N{LATIN SMALL LETTER S}\N{GREEK SMALL LETTER MU}\N{LATIN SMALL LETTER F}\N{LATIN SMALL LETTER F}\N{LATIN SMALL LETTER I}\N{DESERET SMALL LETTER AY}\N{LATIN SMALL LETTER I}\N{COMBINING DOT ABOVE}\N{LATIN SMALL LETTER DOTLESS I}

    is(fc($s), $f, "ICU's casefold test passes");
    is("\F$s", $f, "ICU's casefold test passes");

    is( fc("aBİIıϐßﬃ񟿿"), "abi̇iıβssffi񟿿" );
    is( "\FaBİIıϐßﬃ񟿿", "abi̇iıβssffi񟿿" );
#    TODO: {
#        local $::TODO = "turkic special cases";
#        is( fc "aBİIıϐßﬃ񟿿", "abiııβssffi񟿿" );
#    }

    # The next batch come from http://www.devdaily.com/java/jwarehouse/lucene/contrib/icu/src/test/org/apache/lucene/analysis/icu/TestICUFoldingFilter.java.shtml
    # Except the article got most casings wrong. Or maybe Lucene does.

    is( fc("This is a test"), "this is a test" );
    is( fc("Ruß"), "russ"    );
    is( fc("ΜΆΪΟΣ"), "μάϊοσ" );
    is( fc("Μάϊος"), "μάϊοσ" );
    is( fc("𐐖"), "𐐾"       );
    is( fc("r" . uni_to_native("\xe9") . "sum" . uni_to_native("\xe9")),
           "r" . uni_to_native("\xe9") . "sum" . uni_to_native("\xe9") );
    is( fc("re\x{0301}sume\x{0301}"), "re\x{301}sume\x{301}" );
    is( fc("ELİF"), "eli\x{307}f" );
    is( fc("eli\x{307}f"), "eli\x{307}f");

    # This batch comes from
    # http://www.java2s.com/Open-Source/Java-Document/Internationalization-Localization/icu4j/com/ibm/icu/dev/test/lang/UCharacterCaseTest.java.htm
    # Which uses ICU as the backend.

    my @@folding_mixed = (
        uni_to_native("\x{61}\x{42}\x{130}\x{49}\x{131}\x{3d0}\x{df}\x{fb03}"),
        "A" . uni_to_native("\x{df}\x{b5}\x{fb03}\x{1040C}\x{130}\x{131}"),
    );

    my @@folding_default = (
        uni_to_native("\x{61}\x{62}\x{69}\x{307}\x{69}\x{131}\x{3b2}\x{73}\x{73}\x{66}\x{66}\x{69}"),
        "ass\x{3bc}ffi\x{10434}i\x{307}\x{131}"
    );

    my @@folding_exclude_turkic = (
        uni_to_native("\x{61}\x{62}\x{69}\x{131}\x{131}\x{3b2}\x{73}\x{73}\x{66}\x{66}\x{69}"),
                         "ass\x{3bc}ffi\x{10434}i\x{131}",
    );

    is( fc($folding_mixed[1]), $folding_default[1] );

    is( fc($folding_mixed[0]), $folding_default[0] );

}

{
    use utf8;
    # Table stolen from tchrist's mail in
    # http://bugs.python.org/file23051/casing-tests.py
    # and http://98.245.80.27/tcpc/OSCON2011/case-test.python3
    # For reference, it's a longer version of what he posted here:
    # http://stackoverflow.com/questions/6991038/case-insensitive-storage-and-unicode-compatibility

    #Couple of repeats because I'm lazy, not tchrist's fault.

    #This should probably go in t/op/lc.t

    my @@test_table = (
# ORIG LC_SIMPLE TC_SIMPLE UC_SIMPLE LC_FULL TC_FULL UC_FULL FC_SIMPLE FC_TURKIC FC_FULL
[ 'þǽr rihtes', 'þǽr rihtes', 'Þǽr Rihtes', 'ÞǼR RIHTES', 'þǽr rihtes', 'Þǽr Rihtes', 'ÞǼR RIHTES', 'þǽr rihtes', 'þǽr rihtes', 'þǽr rihtes',  ],
[ 'duȝeðlice', 'duȝeðlice', 'Duȝeðlice', 'DUȜEÐLICE', 'duȝeðlice', 'Duȝeðlice', 'DUȜEÐLICE', 'duȝeðlice', 'duȝeðlice', 'duȝeðlice',  ],
[ 'Ævar Arnfjörð Bjarmason', 'ævar arnfjörð bjarmason', 'Ævar Arnfjörð Bjarmason', 'ÆVAR ARNFJÖRÐ BJARMASON', 'ævar arnfjörð bjarmason', 'Ævar Arnfjörð Bjarmason', 'ÆVAR ARNFJÖRÐ BJARMASON', 'ævar arnfjörð bjarmason', 'ævar arnfjörð bjarmason', 'ævar arnfjörð bjarmason',  ],
[ 'Кириллица', 'кириллица', 'Кириллица', 'КИРИЛЛИЦА', 'кириллица', 'Кириллица', 'КИРИЛЛИЦА', 'кириллица', 'кириллица', 'кириллица',  ],
[ 'ĳ', 'ĳ', 'Ĳ', 'Ĳ', 'ĳ', 'Ĳ', 'Ĳ', 'ĳ', 'ĳ', 'ĳ',  ],
[ 'Van Dĳke', 'van dĳke', 'Van Dĳke', 'VAN DĲKE', 'van dĳke', 'Van Dĳke', 'VAN DĲKE', 'van dĳke', 'van dĳke', 'van dĳke',  ],
[ 'VAN DĲKE', 'van dĳke', 'Van Dĳke', 'VAN DĲKE', 'van dĳke', 'Van Dĳke', 'VAN DĲKE', 'van dĳke', 'van dĳke', 'van dĳke',  ],
[ 'eﬃcient', 'eﬃcient', 'Eﬃcient', 'EﬃCIENT', 'eﬃcient', 'Eﬃcient', 'EFFICIENT', 'eﬃcient', 'efficient', 'efficient',  ],
[ 'ﬂour', 'ﬂour', 'ﬂour', 'ﬂOUR', 'ﬂour', 'Flour', 'FLOUR', 'ﬂour', 'flour', 'flour',  ],
[ 'ﬂour and water', 'ﬂour and water', 'ﬂour And Water', 'ﬂOUR AND WATER', 'ﬂour and water', 'Flour And Water', 'FLOUR AND WATER', 'ﬂour and water', 'flour and water', 'flour and water',  ],
[ 'ǳur', 'ǳur', 'ǲur', 'ǱUR', 'ǳur', 'ǲur', 'ǱUR', 'ǳur', 'ǳur', 'ǳur',  ],
[ 'ǲur', 'ǳur', 'ǲur', 'ǱUR', 'ǳur', 'ǲur', 'ǱUR', 'ǳur', 'ǳur', 'ǳur',  ],
[ 'ǱUR', 'ǳur', 'ǲur', 'ǱUR', 'ǳur', 'ǲur', 'ǱUR', 'ǳur', 'ǳur', 'ǳur',  ],
[ 'ǳur mountain', 'ǳur mountain', 'ǲur Mountain', 'ǱUR MOUNTAIN', 'ǳur mountain', 'ǲur Mountain', 'ǱUR MOUNTAIN', 'ǳur mountain', 'ǳur mountain', 'ǳur mountain',  ],
[ 'ǲur Mountain', 'ǳur mountain', 'ǲur Mountain', 'ǱUR MOUNTAIN', 'ǳur mountain', 'ǲur Mountain', 'ǱUR MOUNTAIN', 'ǳur mountain', 'ǳur mountain', 'ǳur mountain',  ],
[ 'ǱUR MOUNTAIN', 'ǳur mountain', 'ǲur Mountain', 'ǱUR MOUNTAIN', 'ǳur mountain', 'ǲur Mountain', 'ǱUR MOUNTAIN', 'ǳur mountain', 'ǳur mountaın', 'ǳur mountain',  ],
[ 'poſt', 'poſt', 'Poſt', 'POST', 'poſt', 'Poſt', 'POST', 'post', 'post', 'post',  ],
[ 'poﬅ', 'poﬅ', 'Poﬅ', 'POﬅ', 'poﬅ', 'Poﬅ', 'POST', 'poﬅ', 'post', 'post',  ],
[ 'ﬅop', 'ﬅop', 'ﬅop', 'ﬅOP', 'ﬅop', 'Stop', 'STOP', 'ﬅop', 'stop', 'stop',  ],
[ 'tschüß', 'tschüß', 'Tschüß', 'TSCHÜß', 'tschüß', 'Tschüß', 'TSCHÜSS', 'tschüß', 'tschüss', 'tschüss',  ],
[ 'TSCHÜẞ', 'tschüß', 'Tschüß', 'TSCHÜẞ', 'tschüß', 'Tschüß', 'TSCHÜẞ', 'tschüß', 'tschüss', 'tschüss',  ],
[ 'weiß', 'weiß', 'Weiß', 'WEIß', 'weiß', 'Weiß', 'WEISS', 'weiß', 'weiss', 'weiss',  ],
[ 'WEIẞ', 'weiß', 'Weiß', 'WEIẞ', 'weiß', 'Weiß', 'WEIẞ', 'weiß', 'weıss', 'weiss',  ],
[ 'ẞIEW', 'ßiew', 'ẞiew', 'ẞIEW', 'ßiew', 'ẞiew', 'ẞIEW', 'ßiew', 'ssıew', 'ssiew',  ],
[ 'ᾲ', 'ᾲ', 'Ὰͅ', 'ᾺΙ', 'ᾲ', 'Ὰͅ', 'ᾺΙ', 'ὰι', 'ὰι', 'ὰι',  ],
[ 'Ὰι', 'ὰι', 'Ὰι', 'ᾺΙ', 'ὰι', 'Ὰι', 'ᾺΙ', 'ὰι', 'ὰι', 'ὰι',  ],
[ 'ᾺΙ', 'ὰι', 'Ὰι', 'ᾺΙ', 'ὰι', 'Ὰι', 'ᾺΙ', 'ὰι', 'ὰι', 'ὰι',  ],
[ 'ᾲ', 'ᾲ', 'ᾲ', 'ᾲ', 'ᾲ', 'Ὰͅ', 'ᾺΙ', 'ᾲ', 'ὰι', 'ὰι',  ],
[ 'Ὰͅ', 'ᾲ', 'Ὰͅ', 'ᾺΙ', 'ᾲ', 'Ὰͅ', 'ᾺΙ', 'ὰι', 'ὰι', 'ὰι',  ],
[ 'ᾺΙ', 'ὰι', 'Ὰι', 'ᾺΙ', 'ὰι', 'Ὰι', 'ᾺΙ', 'ὰι', 'ὰι', 'ὰι',  ],
[ 'ᾲ στο διάολο', 'ᾲ στο διάολο', 'ᾲ Στο Διάολο', 'ᾲ ΣΤΟ ΔΙΆΟΛΟ', 'ᾲ στο διάολο', 'Ὰͅ Στο Διάολο', 'ᾺΙ ΣΤΟ ΔΙΆΟΛΟ', 'ᾲ στο διάολο', 'ὰι στο διάολο', 'ὰι στο διάολο',  ],
[ 'ᾲ στο διάολο', 'ᾲ στο διάολο', 'Ὰͅ Στο Διάολο', 'ᾺΙ ΣΤΟ ΔΙΆΟΛΟ', 'ᾲ στο διάολο', 'Ὰͅ Στο Διάολο', 'ᾺΙ ΣΤΟ ΔΙΆΟΛΟ', 'ὰι στο διάολο', 'ὰι στο διάολο', 'ὰι στο διάολο',  ],
[ '𐐼𐐯𐑅𐐨𐑉𐐯𐐻', '𐐼𐐯𐑅𐐨𐑉𐐯𐐻', '𐐔𐐯𐑅𐐨𐑉𐐯𐐻', '𐐔𐐇𐐝𐐀𐐡𐐇𐐓', '𐐼𐐯𐑅𐐨𐑉𐐯𐐻', '𐐔𐐯𐑅𐐨𐑉𐐯𐐻', '𐐔𐐇𐐝𐐀𐐡𐐇𐐓', '𐐼𐐯𐑅𐐨𐑉𐐯𐐻', '𐐼𐐯𐑅𐐨𐑉𐐯𐐻', '𐐼𐐯𐑅𐐨𐑉𐐯𐐻',  ],
[ '𐐔𐐯𐑅𐐨𐑉𐐯𐐻', '𐐼𐐯𐑅𐐨𐑉𐐯𐐻', '𐐔𐐯𐑅𐐨𐑉𐐯𐐻', '𐐔𐐇𐐝𐐀𐐡𐐇𐐓', '𐐼𐐯𐑅𐐨𐑉𐐯𐐻', '𐐔𐐯𐑅𐐨𐑉𐐯𐐻', '𐐔𐐇𐐝𐐀𐐡𐐇𐐓', '𐐼𐐯𐑅𐐨𐑉𐐯𐐻', '𐐼𐐯𐑅𐐨𐑉𐐯𐐻', '𐐼𐐯𐑅𐐨𐑉𐐯𐐻',  ],
[ '𐐔𐐇𐐝𐐀𐐡𐐇𐐓', '𐐼𐐯𐑅𐐨𐑉𐐯𐐻', '𐐔𐐯𐑅𐐨𐑉𐐯𐐻', '𐐔𐐇𐐝𐐀𐐡𐐇𐐓', '𐐼𐐯𐑅𐐨𐑉𐐯𐐻', '𐐔𐐯𐑅𐐨𐑉𐐯𐐻', '𐐔𐐇𐐝𐐀𐐡𐐇𐐓', '𐐼𐐯𐑅𐐨𐑉𐐯𐐻', '𐐼𐐯𐑅𐐨𐑉𐐯𐐻', '𐐼𐐯𐑅𐐨𐑉𐐯𐐻',  ],
[ 'henry ⅷ', 'henry ⅷ', 'Henry Ⅷ', 'HENRY Ⅷ', 'henry ⅷ', 'Henry Ⅷ', 'HENRY Ⅷ', 'henry ⅷ', 'henry ⅷ', 'henry ⅷ',  ],
[ 'Henry Ⅷ', 'henry ⅷ', 'Henry Ⅷ', 'HENRY Ⅷ', 'henry ⅷ', 'Henry Ⅷ', 'HENRY Ⅷ', 'henry ⅷ', 'henry ⅷ', 'henry ⅷ',  ],
[ 'HENRY Ⅷ', 'henry ⅷ', 'Henry Ⅷ', 'HENRY Ⅷ', 'henry ⅷ', 'Henry Ⅷ', 'HENRY Ⅷ', 'henry ⅷ', 'henry ⅷ', 'henry ⅷ',  ],
[ 'i work at ⓚ', 'i work at ⓚ', 'I Work At Ⓚ', 'I WORK AT Ⓚ', 'i work at ⓚ', 'I Work At Ⓚ', 'I WORK AT Ⓚ', 'i work at ⓚ', 'i work at ⓚ', 'i work at ⓚ',  ],
[ 'I Work At Ⓚ', 'i work at ⓚ', 'I Work At Ⓚ', 'I WORK AT Ⓚ', 'i work at ⓚ', 'I Work At Ⓚ', 'I WORK AT Ⓚ', 'i work at ⓚ', 'ı work at ⓚ', 'i work at ⓚ',  ],
[ 'I WORK AT Ⓚ', 'i work at ⓚ', 'I Work At Ⓚ', 'I WORK AT Ⓚ', 'i work at ⓚ', 'I Work At Ⓚ', 'I WORK AT Ⓚ', 'i work at ⓚ', 'ı work at ⓚ', 'i work at ⓚ',  ],
[ 'istambul', 'istambul', 'Istambul', 'ISTAMBUL', 'istambul', 'Istambul', 'ISTAMBUL', 'istambul', 'istambul', 'istambul',  ],
[ 'i̇stanbul', 'i̇stanbul', 'İstanbul', 'İSTANBUL', 'i̇stanbul', 'İstanbul', 'İSTANBUL', 'i̇stanbul', 'i̇stanbul', 'i̇stanbul',  ],
[ 'İstanbul', 'i̇stanbul', 'İstanbul', 'İSTANBUL', 'i̇stanbul', 'İstanbul', 'İSTANBUL', 'i̇stanbul', 'ı̇stanbul', 'i̇stanbul',  ],
[ 'İSTANBUL', 'istanbul', 'İstanbul', 'İSTANBUL', 'i̇stanbul', 'İstanbul', 'İSTANBUL', 'İstanbul', 'istanbul', 'i̇stanbul',  ],
[ 'στιγμας', 'στιγμας', 'Στιγμας', 'ΣΤΙΓΜΑΣ', 'στιγμας', 'Στιγμας', 'ΣΤΙΓΜΑΣ', 'στιγμασ', 'στιγμασ', 'στιγμασ',  ],
[ 'στιγμασ', 'στιγμασ', 'Στιγμασ', 'ΣΤΙΓΜΑΣ', 'στιγμασ', 'Στιγμασ', 'ΣΤΙΓΜΑΣ', 'στιγμασ', 'στιγμασ', 'στιγμασ',  ],
[ 'ΣΤΙΓΜΑΣ', 'στιγμασ', 'Στιγμασ', 'ΣΤΙΓΜΑΣ', 'στιγμασ', 'Στιγμασ', 'ΣΤΙΓΜΑΣ', 'στιγμασ', 'στιγμασ', 'στιγμασ',  ],
[ 'ʀᴀʀᴇ', 'ʀᴀʀᴇ', 'Ʀᴀʀᴇ', 'ƦᴀƦᴇ', 'ʀᴀʀᴇ', 'Ʀᴀʀᴇ', 'ƦᴀƦᴇ', 'ʀᴀʀᴇ', 'ʀᴀʀᴇ', 'ʀᴀʀᴇ',  ],
[ 'Ʀᴀʀᴇ', 'ʀᴀʀᴇ', 'Ʀᴀʀᴇ', 'ƦᴀƦᴇ', 'ʀᴀʀᴇ', 'Ʀᴀʀᴇ', 'ƦᴀƦᴇ', 'ʀᴀʀᴇ', 'ʀᴀʀᴇ', 'ʀᴀʀᴇ',  ],
[ 'ƦᴀƦᴇ', 'ʀᴀʀᴇ', 'Ʀᴀʀᴇ', 'ƦᴀƦᴇ', 'ʀᴀʀᴇ', 'Ʀᴀʀᴇ', 'ƦᴀƦᴇ', 'ʀᴀʀᴇ', 'ʀᴀʀᴇ', 'ʀᴀʀᴇ',  ],
[ 'Ԧԧ', 'ԧԧ', 'Ԧԧ', 'ԦԦ', 'ԧԧ', 'Ԧԧ', 'ԦԦ', 'ԧԧ', 'ԧԧ', 'ԧԧ',  ],
[ 'ԧԧ', 'ԧԧ', 'Ԧԧ', 'ԦԦ', 'ԧԧ', 'Ԧԧ', 'ԦԦ', 'ԧԧ', 'ԧԧ', 'ԧԧ',  ],
[ 'Ԧԧ', 'ԧԧ', 'Ԧԧ', 'ԦԦ', 'ԧԧ', 'Ԧԧ', 'ԦԦ', 'ԧԧ', 'ԧԧ', 'ԧԧ',  ],
[ 'ԦԦ', 'ԧԧ', 'Ԧԧ', 'ԦԦ', 'ԧԧ', 'Ԧԧ', 'ԦԦ', 'ԧԧ', 'ԧԧ', 'ԧԧ',  ],
[ "þǽr rihtes", "þǽr rihtes", "Þǽr Rihtes", "ÞǼR RIHTES", "þǽr rihtes", "Þǽr Rihtes", "ÞǼR RIHTES", "þǽr rihtes", "þǽr rihtes", "þǽr rihtes",  ],
[ "duȝeðlice", "duȝeðlice", "Duȝeðlice", "DUȜEÐLICE", "duȝeðlice", "Duȝeðlice", "DUȜEÐLICE", "duȝeðlice", "duȝeðlice", "duȝeðlice",  ],
[ "Van Dĳke", "van dĳke", "Van Dĳke", "VAN DĲKE", "van dĳke", "Van Dĳke", "VAN DĲKE", "van dĳke", "van dĳke", "van dĳke",  ],
[ "ﬁ", "ﬁ", "ﬁ", "ﬁ", "ﬁ", "Fi", "FI", "ﬁ", "fi", "fi",  ],
[ "ﬁlesystem", "ﬁlesystem", "ﬁlesystem", "ﬁLESYSTEM", "ﬁlesystem", "Filesystem", "FILESYSTEM", "ﬁlesystem", "filesystem", "filesystem",  ],
[ "eﬃcient", "eﬃcient", "Eﬃcient", "EﬃCIENT", "eﬃcient", "Eﬃcient", "EFFICIENT", "eﬃcient", "efficient", "efficient",  ],
[ "ﬂour and water", "ﬂour and water", "ﬂour And Water", "ﬂOUR AND WATER", "ﬂour and water", "Flour And Water", "FLOUR AND WATER", "ﬂour and water", "flour and water", "flour and water",  ],
[ "ǳ", "ǳ", "ǲ", "Ǳ", "ǳ", "ǲ", "Ǳ", "ǳ", "ǳ", "ǳ",  ],
[ "ǳur mountain", "ǳur mountain", "ǲur Mountain", "ǱUR MOUNTAIN", "ǳur mountain", "ǲur Mountain", "ǱUR MOUNTAIN", "ǳur mountain", "ǳur mountain", "ǳur mountain",  ],
[ "poſt", "poſt", "Poſt", "POST", "poſt", "Poſt", "POST", "post", "post", "post",  ],
[ "poﬅ", "poﬅ", "Poﬅ", "POﬅ", "poﬅ", "Poﬅ", "POST", "poﬅ", "post", "post",  ],
[ "ﬅop", "ﬅop", "ﬅop", "ﬅOP", "ﬅop", "Stop", "STOP", "ﬅop", "stop", "stop",  ],
[ "tschüß", "tschüß", "Tschüß", "TSCHÜß", "tschüß", "Tschüß", "TSCHÜSS", "tschüß", "tschüss", "tschüss",  ],
[ "TSCHÜẞ", "tschüß", "Tschüß", "TSCHÜẞ", "tschüß", "Tschüß", "TSCHÜẞ", "tschüß", "tschüss", "tschüss",  ],
[ "rußland", "rußland", "Rußland", "RUßLAND", "rußland", "Rußland", "RUSSLAND", "rußland", "russland", "russland",  ],
[ "RUẞLAND", "rußland", "Rußland", "RUẞLAND", "rußland", "Rußland", "RUẞLAND", "rußland", "russland", "russland",  ],
[ "weiß", "weiß", "Weiß", "WEIß", "weiß", "Weiß", "WEISS", "weiß", "weiss", "weiss",  ],
[ "WEIẞ", "weiß", "Weiß", "WEIẞ", "weiß", "Weiß", "WEIẞ", "weiß", "weıss", "weiss",  ],
[ "ẞIEW", "ßiew", "ẞiew", "ẞIEW", "ßiew", "ẞiew", "ẞIEW", "ßiew", "ssıew", "ssiew",  ],
[ "ͅ", "ͅ", "Ι", "Ι", "ͅ", "Ι", "Ι", "ι", "ι", "ι",  ],
[ "ᾲ", "ᾲ", "Ὰͅ", "ᾺΙ", "ᾲ", "Ὰͅ", "ᾺΙ", "ὰι", "ὰι", "ὰι",  ],
[ "Ὰι", "ὰι", "Ὰι", "ᾺΙ", "ὰι", "Ὰι", "ᾺΙ", "ὰι", "ὰι", "ὰι",  ],
[ "ᾺΙ", "ὰι", "Ὰι", "ᾺΙ", "ὰι", "Ὰι", "ᾺΙ", "ὰι", "ὰι", "ὰι",  ],
[ "ᾲ", "ᾲ", "ᾲ", "ᾲ", "ᾲ", "Ὰͅ", "ᾺΙ", "ᾲ", "ὰι", "ὰι",  ],
[ "Ὰͅ", "ᾲ", "Ὰͅ", "ᾺΙ", "ᾲ", "Ὰͅ", "ᾺΙ", "ὰι", "ὰι", "ὰι",  ],
[ "ᾺΙ", "ὰι", "Ὰι", "ᾺΙ", "ὰι", "Ὰι", "ᾺΙ", "ὰι", "ὰι", "ὰι",  ],
[ "ᾲ στο διάολο", "ᾲ στο διάολο", "ᾲ Στο Διάολο", "ᾲ ΣΤΟ ΔΙΆΟΛΟ", "ᾲ στο διάολο", "Ὰͅ Στο Διάολο", "ᾺΙ ΣΤΟ ΔΙΆΟΛΟ", "ᾲ στο διάολο", "ὰι στο διάολο", "ὰι στο διάολο",  ],
[ "ᾲ στο διάολο", "ᾲ στο διάολο", "Ὰͅ Στο Διάολο", "ᾺΙ ΣΤΟ ΔΙΆΟΛΟ", "ᾲ στο διάολο", "Ὰͅ Στο Διάολο", "ᾺΙ ΣΤΟ ΔΙΆΟΛΟ", "ὰι στο διάολο", "ὰι στο διάολο", "ὰι στο διάολο",  ],
[ "ⅷ", "ⅷ", "Ⅷ", "Ⅷ", "ⅷ", "Ⅷ", "Ⅷ", "ⅷ", "ⅷ", "ⅷ",  ],
[ "henry ⅷ", "henry ⅷ", "Henry Ⅷ", "HENRY Ⅷ", "henry ⅷ", "Henry Ⅷ", "HENRY Ⅷ", "henry ⅷ", "henry ⅷ", "henry ⅷ",  ],
[ "ⓚ", "ⓚ", "Ⓚ", "Ⓚ", "ⓚ", "Ⓚ", "Ⓚ", "ⓚ", "ⓚ", "ⓚ",  ],
[ "i work at ⓚ", "i work at ⓚ", "I Work At Ⓚ", "I WORK AT Ⓚ", "i work at ⓚ", "I Work At Ⓚ", "I WORK AT Ⓚ", "i work at ⓚ", "i work at ⓚ", "i work at ⓚ",  ],
[ "istambul", "istambul", "Istambul", "ISTAMBUL", "istambul", "Istambul", "ISTAMBUL", "istambul", "istambul", "istambul",  ],
[ "i̇stanbul", "i̇stanbul", "İstanbul", "İSTANBUL", "i̇stanbul", "İstanbul", "İSTANBUL", "i̇stanbul", "i̇stanbul", "i̇stanbul",  ],
[ "İstanbul", "i̇stanbul", "İstanbul", "İSTANBUL", "i̇stanbul", "İstanbul", "İSTANBUL", "i̇stanbul", "ı̇stanbul", "i̇stanbul",  ],
[ "İSTANBUL", "istanbul", "İstanbul", "İSTANBUL", "i̇stanbul", "İstanbul", "İSTANBUL", "İstanbul", "istanbul", "i̇stanbul",  ],
[ "στιγμας", "στιγμας", "Στιγμας", "ΣΤΙΓΜΑΣ", "στιγμας", "Στιγμας", "ΣΤΙΓΜΑΣ", "στιγμασ", "στιγμασ", "στιγμασ",  ],
[ "στιγμασ", "στιγμασ", "Στιγμασ", "ΣΤΙΓΜΑΣ", "στιγμασ", "Στιγμασ", "ΣΤΙΓΜΑΣ", "στιγμασ", "στιγμασ", "στιγμασ",  ],
[ "ΣΤΙΓΜΑΣ", "στιγμασ", "Στιγμασ", "ΣΤΙΓΜΑΣ", "στιγμασ", "Στιγμασ", "ΣΤΙΓΜΑΣ", "στιγμασ", "στιγμασ", "στιγμασ",  ],
[ "ʀᴀʀᴇ", "ʀᴀʀᴇ", "Ʀᴀʀᴇ", "ƦᴀƦᴇ", "ʀᴀʀᴇ", "Ʀᴀʀᴇ", "ƦᴀƦᴇ", "ʀᴀʀᴇ", "ʀᴀʀᴇ", "ʀᴀʀᴇ",  ],
[ "𐐼𐐯𐑅𐐨𐑉𐐯𐐻", "𐐼𐐯𐑅𐐨𐑉𐐯𐐻", "𐐔𐐯𐑅𐐨𐑉𐐯𐐻", "𐐔𐐇𐐝𐐀𐐡𐐇𐐓", "𐐼𐐯𐑅𐐨𐑉𐐯𐐻", "𐐔𐐯𐑅𐐨𐑉𐐯𐐻", "𐐔𐐇𐐝𐐀𐐡𐐇𐐓", "𐐼𐐯𐑅𐐨𐑉𐐯𐐻", "𐐼𐐯𐑅𐐨𐑉𐐯𐐻", "𐐼𐐯𐑅𐐨𐑉𐐯𐐻",  ],
[ "Ԧԧ", "ԧԧ", "Ԧԧ", "ԦԦ", "ԧԧ", "Ԧԧ", "ԦԦ", "ԧԧ", "ԧԧ", "ԧԧ",  ],
[ "ﬓﬔﬕﬖﬗ", "ﬓﬔﬕﬖﬗ", "ﬓﬔﬕﬖﬗ", "ﬓﬔﬕﬖﬗ", "ﬓﬔﬕﬖﬗ", "Մնﬔﬕﬖﬗ", "ՄՆՄԵՄԻՎՆՄԽ", "ﬓﬔﬕﬖﬗ", "մնմեմիվնմխ", "մնմեմիվնմխ",  ],
[ "ŉ groot", "ŉ groot", "ŉ Groot", "ŉ GROOT", "ŉ groot", "ʼN Groot", "ʼN GROOT", "ŉ groot", "ʼn groot", "ʼn groot",  ],
[ "ẚ", "ẚ", "ẚ", "ẚ", "ẚ", "Aʾ", "Aʾ", "ẚ", "aʾ", "aʾ",  ],
[ "ﬀ", "ﬀ", "ﬀ", "ﬀ", "ﬀ", "Ff", "FF", "ﬀ", "ff", "ff",  ],
[ "ǰ", "ǰ", "ǰ", "ǰ", "ǰ", "J̌", "J̌", "ǰ", "ǰ", "ǰ",  ],
[ "550 nm or Å", "550 nm or å", "550 Nm Or Å", "550 NM OR Å", "550 nm or å", "550 Nm Or Å", "550 NM OR Å", "550 nm or å", "550 nm or å", "550 nm or å",  ],
);

    use feature qw(fc);

    for (@@test_table) {
        my ($simple_lc, $simple_tc, $simple_uc, $simple_fc) = @@{$_}[1, 2, 3, 7];
        my ($orig, $lower, $titlecase, $upper, $fc_turkic, $fc_full) = @@{$_}[0,4,5,6,8,9];

        if ($orig =~ /(\P{Assigned})/) {   # So can fail gracefully in earlier
                                           # Unicode versions
            fail(sprintf "because U+%04X is unassigned", ord($1));
            next;
        }
        is( fc($orig), $fc_full, "fc('$orig') returns '$fc_full'" );
        is( "\F$orig", $fc_full, '\F works' );
        is( lc($orig), $lower,   "lc('$orig') returns '$lower'" );
        is( "\L$orig", $lower,   '\L works' );
        is( uc($orig), $upper,   "uc('$orig') returns '$upper'" );
        is( "\U$orig", $upper,   '\U works' );
    }
}

{
    use feature qw(fc);
    package Eeyup  { use overload q{""} => sub { main::uni_to_native("\x{df}")   }, fallback => 1 }
    package Uunope { use overload q{""} => sub { "\x{30cb}" }, fallback => 1 }
    package Undef  { use overload q{""} => sub {   undef    }, fallback => 1 }

    my $obj = bless {}, "Eeyup";
    is(fc($obj), "ss", "fc() works on overloaded objects returning latin-1");
    $obj = bless {}, "Eeyup";
    is("\F$obj", "ss", '\F works on overloaded objects returning latin-1');

    $obj = bless {}, "Uunope";
    is(fc($obj), "\x{30cb}", "fc() works on overloaded objects returning UTF-8");
    $obj = bless {}, "Uunope";
    is("\F$obj", "\x{30cb}", '\F works on overloaded objects returning UTF-8');

    $obj = bless {}, "Undef";
    my $warnings;
    {
        no warnings;
        use warnings "uninitialized";
        local $SIG{__WARN__} = sub { $warnings++; like(shift, qr/Use of uninitialized value (?:\$obj )?in fc/) };
        fc(undef);
        fc($obj);
    }
    is( $warnings, 2, "correct number of warnings" );

    my $fetched = 0;
    package Derpy { sub TIESCALAR { bless {}, shift } sub FETCH { $fetched++; main::uni_to_native("\x{df}") } }

    tie my $x, "Derpy";

    is( fc($x), "ss", "fc() works on tied values" );
    is( $fetched, 1, "and only calls the magic once" );

}

{
    use feature qw( fc );
    my $troublesome1 = uni_to_native("\xdf") x 11; #SvLEN should be 12, SvCUR should be 11
                                    #So this should force fc() to grow the string.

    is( fc($troublesome1), "ss" x 11, "fc() grows the string" );

    my $troublesome2 = "abcdef:" . uni_to_native("\x{df}")
                     . ":fjksjs"; #SvLEN should be 16, SvCUR should be 15
    is( fc($troublesome2), "abcdef:ss:fjksjs", "fc() expands \\x{DF} in the middle of a string that needs to grow" );

    my $troublesome3 = ":" . uni_to_native("\x{df}") . ":";
    is( fc($troublesome3), ":ss:", "fc() expands \\x{DF} in the middle of a string" );


    my $troublesome4 = uni_to_native("\x{B5}"); #\N{MICRON SIGN} is latin-1, but its foldcase is in UTF-8

    is( fc($troublesome4), "\x{3BC}", "fc() for a latin-1 \x{B5} returns UTF-8" );
    ok( !utf8::is_utf8($troublesome4), "fc() doesn't upgrade the original string" );


    my $troublesome5 = uni_to_native("\x{C9}") . "abda"
                     . uni_to_native("\x{B5}") . "aaf"
                     . uni_to_native("\x{C8}");  # Up until foldcasing \x{B5}, the string
                                                    # was in Latin-1. This tests that the
                                                    # results don't have illegal UTF-8
                                                    # (i.e. leftover latin-1) in them

    is( fc($troublesome5), uni_to_native("\x{E9}") . "abda\x{3BC}aaf"
                         . uni_to_native("\x{E8}") );
}


SKIP: {
    use feature qw( fc unicode_strings );

    skip "locales not available", 256 unless locales_enabled('LC_ALL');

    setlocale(&POSIX::LC_ALL, "C");

    # This tests both code paths in pp_fc

    for (0..0xff) {
        my $latin1 = chr;
        my $utf8   = $latin1;
        utf8::downgrade($latin1); #No-op, but doesn't hurt
        utf8::upgrade($utf8);
        is(fc($latin1), fc($utf8), "fc() gives the same results for \\x{$_} in Latin-1 and UTF-8 under unicode_strings");
        SKIP: {
            skip 'Locales not available', 2 unless locales_enabled('LC_CTYPE');
            use locale;
            is(fc($latin1), lc($latin1), "use locale; fc(qq{\\x{$_}}), lc(qq{\\x{$_}}) when qq{\\x{$_}} is in latin-1");
            is(fc($utf8), lc($utf8), "use locale; fc(qq{\\x{$_}}), lc(qq{\\x{$_}}) when qq{\\x{$_}} is in latin-1");
        }
        {
            no feature 'unicode_strings';
            is(fc($latin1), lc($latin1), "under nothing, fc() for <256 is the same as lc");
        }
    }
}

my $utf8_locale = find_utf8_ctype_locale();

{
    use feature qw( fc );
    use locale;
    no warnings 'locale';   # Would otherwise warn
    is(fc("\x{1E9E}"), fc("\x{17F}\x{17F}"), 'fc("\x{1E9E}") eq fc("\x{17F}\x{17F}")');
    use warnings 'locale';
    SKIP: {
        skip 'Can\'t find a UTF-8 locale', 1 unless defined $utf8_locale;
        setlocale(&LC_CTYPE, $utf8_locale);
        is(fc("\x{1E9E}"), "ss", 'fc("\x{1E9E}") eq "ss" in a UTF-8 locale)');
    }
}

SKIP: {
    skip 'Can\'t find a UTF-8 locale', 256 unless defined $utf8_locale;

    use feature qw( fc unicode_strings );

    # Get the official fc values outside locale.
    no locale;
    my @@unicode_fc;
    for (0..0xff) {
        push @@unicode_fc, fc(chr);
    }

    # These should match the UTF-8 locale values
    setlocale(&LC_CTYPE, $utf8_locale);
    use locale;
    for (0..0xff) {
        is(fc(chr), $unicode_fc[$_], "In a UTF-8 locale, fc(chr $_) is the same as official Unicode");
    }
}


my $num_tests = curr_test() - 1;

plan($num_tests);
@


1.7
log
@Apply local patches, remove excess files - perl-5.20.2
@
text
@d9 4
a12 1
    @@INC = '../lib';
d14 1
a14 1
    require './test.pl';
d53 1
a53 1
    $reverse_fold{pack "U0U*", hex $simple} = pack "U0U*", $decimal_code_point if $simple;
d59 3
a61 2
    my $c = pack("U0U*", hex $code);
    my $f = pack("U0U*", map { hex } split " ", $mapping);
d72 3
a74 2
    my $c = pack("U0U*", hex $code);
    my $f = pack("U0U*", map { hex } split " ", $mapping);
d191 2
a192 1
    is( fc("r\xe9sum\xe9"), "r\xe9sum\xe9" );
d202 2
a203 2
        "\x{61}\x{42}\x{130}\x{49}\x{131}\x{3d0}\x{df}\x{fb03}",
        "A\x{df}\x{b5}\x{fb03}\x{1040C}\x{130}\x{131}",
d207 2
a208 2
        "\x{61}\x{62}\x{69}\x{307}\x{69}\x{131}\x{3b2}\x{73}\x{73}\x{66}\x{66}\x{69}",
        "ass\x{3bc}ffi\x{10434}i\x{307}\x{131}",
d212 2
a213 2
        "\x{61}\x{62}\x{69}\x{131}\x{131}\x{3b2}\x{73}\x{73}\x{66}\x{66}\x{69}",
        "ass\x{3bc}ffi\x{10434}i\x{131}",
d363 1
a363 1
    package Eeyup  { use overload q{""} => sub { "\x{df}"   }, fallback => 1 }
d389 1
a389 1
    package Derpy { sub TIESCALAR { bless {}, shift } sub FETCH { $fetched++; "\x{df}" } }
d400 1
a400 1
    my $troublesome1 = "\xdf" x 11; #SvLEN should be 12, SvCUR should be 11
d405 2
a406 1
    my $troublesome2 = "abcdef:\x{df}:fjksjs"; #SvLEN should be 16, SvCUR should be 15
d409 1
a409 1
    my $troublesome3 = ":\x{df}:";
d413 1
a413 1
    my $troublesome4 = "\x{B5}"; #\N{MICRON SIGN} is latin-1, but its foldcase is in UTF-8
d419 3
a421 1
    my $troublesome5 = "\x{C9}abda\x{B5}aaf\x{C8}"; # Up until foldcasing \x{B5}, the string
d426 2
a427 1
    is( fc($troublesome5), "\x{E9}abda\x{3BC}aaf\x{E8}" );
d431 1
a431 1
{
d433 4
a436 2
    use if $Config{d_setlocale}, qw(POSIX locale_h);
    setlocale(&POSIX::LC_ALL, "C") if $Config{d_setlocale};
d447 2
a448 6
              skip 'No locale testing without d_setlocale', 2 if(!$Config{d_setlocale}) || $Config::Config{ccflags} =~ /\bD?NO_LOCALE(_|\b)/;
              BEGIN {
                  if($Config{d_setlocale}) {
                      require locale; import locale;
                  }
              }
d452 1
a452 7
        SKIP: {
            if (
                !$Config::Config{d_setlocale}
            || $Config::Config{ccflags} =~ /\bD?NO_LOCALE(_|\b)/
            ) {
                skip "no locale support", 2
            }
d464 1
d466 1
@


1.6
log
@Fix merge issues, remove excess files - match perl-5.20.2 dist
@
text
@d435 1
a435 1
              skip 'No locale testing without d_setlocale', 2 if(!$Config{d_setlocale});
d444 7
a450 1
        {
@


1.5
log
@Apply local patches to perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d435 1
a435 1
              skip 'No locale testing without d_setlocale', 2 if(!$Config{d_setlocale}) || $Config::Config{ccflags} =~ /\bD?NO_LOCALE(_|\b)/;
d444 1
a444 7
        SKIP: {
            if (
                !$Config::Config{d_setlocale}
            || $Config::Config{ccflags} =~ /\bD?NO_LOCALE(_|\b)/
            ) {
                skip "no locale support", 2
            }
@


1.4
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d435 1
a435 1
              skip 'No locale testing without d_setlocale', 2 if(!$Config{d_setlocale});
d444 7
a450 1
        {
@


1.3
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d12 1
d420 1
d423 2
d435 1
a435 1
              skip 'No locale testing without d_setlocale', 2 if(!$Config{d_setlocale}) || $Config::Config{ccflags} =~ /\bD?NO_LOCALE(_|\b)/;
d444 1
a444 7
        SKIP: {
            if (
                !$Config::Config{d_setlocale}
            || $Config::Config{ccflags} =~ /\bD?NO_LOCALE(_|\b)/
            ) {
                skip "no locale support", 2
            }
d450 34
@


1.2
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d10 1
d15 1
d21 1
d24 2
a25 4
my $CF = '../lib/unicore/CaseFolding.txt';

die qq[$0: failed to open "$CF": $!\n] if ! open(my $fh, "<", $CF);

d29 15
a43 16
while (<$fh>) {
    # We only use 'S' in simple folded fc(), since the regex engine uses
    # 'F'ull case folding.  I is obsolete starting with Unicode 3.2, but
    # leaving it in does no harm, and allows backward compatibility
    next unless my ($code, $type, $mapping, $name) = $_ =~
            /^([0-9A-F]+); ([CFIS]); ((?:[0-9A-F]+)(?: [0-9A-F]+)*); \# (.+)/;

    # Convert any 0-255 range chars to native.
    $code = sprintf("%04X", ord_latin1_to_native(hex $code)) if hex $code < 0x100;
    $mapping = join " ", map { $_ =
                                sprintf("%04X", ord_latin1_to_native(hex $_)) }
                                                            split / /, $mapping;

    if ( $type eq "S" ) {
        push @@simple_folds, [$code, $mapping, $type, $name];
        next;
d46 1
a46 1
    push @@CF, [$code, $mapping, $type, $name];
d49 1
a49 1
    $reverse_fold{pack "U0U*", hex $mapping} = pack "U0U*", hex $code if $type ne 'F';
a51 2
close($fh) or die "$0 Couldn't close $CF";

d340 6
a345 1
        is( fc($orig), $fc_full, 'fc works' );
d347 1
a347 1
        is( lc($orig), $lower,   'lc works' );
d349 1
a349 1
        is( uc($orig), $upper,   'uc works' );
d431 10
a446 5
            use locale;
            is(fc($latin1), lc($latin1), "use locale; fc(qq{\\x{$_}}), lc(qq{\\x{$_}}) when qq{\\x{$_}} is in latin-1");
            is(fc($utf8), lc($utf8), "use locale; fc(qq{\\x{$_}}), lc(qq{\\x{$_}}) when qq{\\x{$_}} is in latin-1");
        }
        {
a453 2

die qq[$0: failed to find casefoldings from "$CF"\n] unless $num_tests > 0;
@


1.1
log
@Initial revision
@
text
@d1 6
d10 205
d217 120
a336 1
use File::Spec;
d338 10
a347 40
my $CF = File::Spec->catfile(File::Spec->catdir(File::Spec->updir,
					       "lib", "unicore"),
			    "CaseFolding.txt");

use constant EBCDIC => ord 'A' == 193;

if (open(CF, $CF)) {
    my @@CF;

    while (<CF>) {
	# Skip S since we are going for 'F'ull case folding
        if (/^([0-9A-F]+); ([CFI]); ((?:[0-9A-F]+)(?: [0-9A-F]+)*); \# (.+)/) {
	    next if EBCDIC && hex $1 < 0x100;
	    push @@CF, [$1, $2, $3, $4];
	}
    }

    close(CF);

    die qq[$0: failed to find casefoldings from "$CF"\n] unless @@CF;

    print "1..", scalar @@CF, "\n";

    my $i = 0;
    for my $cf (@@CF) {
	my ($code, $status, $mapping, $name) = @@$cf;
	$i++;
	my $a = pack("U0U*", hex $code);
	my $b = pack("U0U*", map { hex } split " ", $mapping);
	my $t0 = ":$a:" =~ /:$a:/    ? 1 : 0;
	my $t1 = ":$a:" =~ /:$a:/i   ? 1 : 0;
	my $t2 = ":$a:" =~ /:[$a]:/  ? 1 : 0;
	my $t3 = ":$a:" =~ /:[$a]:/i ? 1 : 0;
	my $t4 = ":$a:" =~ /:$b:/i   ? 1 : 0;
	my $t5 = ":$a:" =~ /:[$b]:/i ? 1 : 0;
	my $t6 = ":$b:" =~ /:$a:/i   ? 1 : 0;
	my $t7 = ":$b:" =~ /:[$a]:/i ? 1 : 0;
	print $t0 && $t1 && $t2 && $t3 && $t4 && $t5 && $t6 && $t7 ?
	    "ok $i \# - $code - $name - $mapping - $status\n" :
	    "not ok $i \# - $code - $name - $mapping - $status - $t0 $t1 $t2 $t3 $t4 $t5 $t6 $t7\n";
a348 2
} else {
    die qq[$0: failed to open "$CF": $!\n];
d350 100
@


1.1.1.1
log
@stock perl 5.8.0 from CPAN
@
text
@@


1.1.1.2
log
@import perl 5.10.1
@
text
@d18 1
a18 3
	# Skip S since we are going for 'F'ull case folding.  I is obsolete starting
	# with Unicode 3.2, but leaving it in does no harm, and allows backward
	# compatibility
@


1.1.1.3
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@a0 6
use strict;
use warnings;

# re/fold_grind.t has more complex tests, but doesn't test every fold
# This file also tests the fc() keyword.

a3 205
    require './test.pl';
}

use feature 'unicode_strings';

binmode *STDOUT, ":utf8";

our $TODO;

plan("no_plan");
# Read in the official case folding definitions.
my $CF = '../lib/unicore/CaseFolding.txt';

die qq[$0: failed to open "$CF": $!\n] if ! open(my $fh, "<", $CF);

my @@CF;
my @@simple_folds;
my %reverse_fold;
while (<$fh>) {
    # We only use 'S' in simple folded fc(), since the regex engine uses
    # 'F'ull case folding.  I is obsolete starting with Unicode 3.2, but
    # leaving it in does no harm, and allows backward compatibility
    next unless my ($code, $type, $mapping, $name) = $_ =~
            /^([0-9A-F]+); ([CFIS]); ((?:[0-9A-F]+)(?: [0-9A-F]+)*); \# (.+)/;

    # Convert any 0-255 range chars to native.
    $code = sprintf("%04X", ord_latin1_to_native(hex $code)) if hex $code < 0x100;
    $mapping = join " ", map { $_ =
                                sprintf("%04X", ord_latin1_to_native(hex $_)) }
                                                            split / /, $mapping;

    if ( $type eq "S" ) {
        push @@simple_folds, [$code, $mapping, $type, $name];
        next;
    }

    push @@CF, [$code, $mapping, $type, $name];

    # Get the inverse fold for single-char mappings.
    $reverse_fold{pack "U0U*", hex $mapping} = pack "U0U*", hex $code if $type ne 'F';
}

close($fh) or die "$0 Couldn't close $CF";

foreach my $test_ref ( @@simple_folds ) {
    use feature 'fc';
    my ($code, $mapping, $type, $name) = @@$test_ref;
    my $c = pack("U0U*", hex $code);
    my $f = pack("U0U*", map { hex } split " ", $mapping);

    my $against = join "", "qq{", map("\\x{$_}", split " ", $mapping), "}";
    {
        isnt(fc($c), $f, "$code - $name - $mapping - $type - Full casefolding, fc(\\x{$code}) ne $against");
        isnt("\F$c", $f, "$code - $name - $mapping - $type - Full casefolding, qq{\\F\\x{$code}} ne $against");
    }
}

foreach my $test_ref (@@CF) {
    my ($code, $mapping, $type, $name) = @@$test_ref;
    my $c = pack("U0U*", hex $code);
    my $f = pack("U0U*", map { hex } split " ", $mapping);
    my $f_length = length $f;
    foreach my $test (
            qq[":$c:" =~ /:$c:/],
            qq[":$c:" =~ /:$c:/i],
            qq[":$c:" =~ /:[_$c]:/], # Place two chars in [] so doesn't get
                                     # optimized to a non-charclass
            qq[":$c:" =~ /:[_$c]:/i],
            qq[":$c:" =~ /:$f:/i],
            qq[":$f:" =~ /:$c:/i],
    ) {
        ok eval $test, "$code - $name - $mapping - $type - $test";
    }

    {
        # fc() tests
        my $against = join "", "qq{", map("\\x{$_}", split " ", $mapping), "}";
        is(CORE::fc($c), $f,
            "$code - $name - $mapping - $type - fc(\\x{$code}) eq $against");
        is("\F$c", $f, "$code - $name - $mapping - $type - qq{\\F\\x{$code}} eq $against");

        # And here we test bytes. For [A-Za-z0-9], the fold is the same as lc under
        # bytes. For everything else, it's the bytes that formed the original string.
        if ( $c =~ /[A-Za-z0-9]/ ) {
            use bytes;
            is(CORE::fc($c), lc($c), "$code - $name - fc and use bytes, ascii");
        } else {
            my $copy = "" . $c;
            utf8::encode($copy);
            is($copy, do { use bytes; CORE::fc($c) }, "$code - $name - fc and use bytes");
        }
    }
    # Certain tests weren't convenient to put in the list above since they are
    # TODO's in multi-character folds.
    if ($f_length == 1) {

        # The qq loses the utf8ness of ":$f:".  These tests are not about
        # finding bugs in utf8ness, so make sure it's utf8.
        my $test = qq[my \$s = ":$f:"; utf8::upgrade(\$s); \$s =~ /:[_$c]:/i];
        ok eval $test, "$code - $name - $mapping - $type - $test";
        $test = qq[":$c:" =~ /:[_$f]:/i];
        ok eval $test, "$code - $name - $mapping - $type - $test";
    }
    else {

        # There are two classes of multi-char folds that need more work.  For
        # example,
        #   ":ß:" =~ /:[_s]{2}:/i
        #   ":ss:" =~ /:[_ß]:/i
        #
        # Some of the old tests for the second case happened to pass somewhat
        # coincidentally.  But none would pass if changed to this.
        #   ":SS:" =~ /:[_ß]:/i
        #
        # As the capital SS doesn't get folded.  When those pass, it means
        # that the code has been changed to take into account folding in the
        # string, and all should pass, capitalized or not (this wouldn't be
        # true for [^complemented character classes], for which the fold case
        # is better, but these aren't used in this .t currently.  So, what is
        # done is to essentially upper-case the string for this class (but use
        # the reverse fold not uc(), as that is more correct)
        my $u;
        for my $i (0 .. $f_length - 1) {
            my $cur_char = substr($f, $i, 1);
            $u .= $reverse_fold{$cur_char} || $cur_char;
        }
        my $test;

        # A multi-char fold should not match just one char;
        # e.g., ":ß:" !~ /:[_s]:/i
        $test = qq[":$c:" !~ /:[_$f]:/i];
        ok eval $test, "$code - $name - $mapping - $type - $test";

        TODO: { # e.g., ":ß:" =~ /:[_s]{2}:/i
            local $TODO = 'Multi-char fold in [character class]';

            $test = qq[":$c:" =~ /:[_$f]{$f_length}:/i];
            ok eval $test, "$code - $name - $mapping - $type - $test";
        }

        # e.g., ":SS:" =~ /:[_ß]:/i now pass, so TODO has been removed, but
        # since they use '$u', they are left out of the main loop
        $test = qq[ my \$s = ":$u:"; utf8::upgrade(\$s); \$s =~ /:[_$c]:/i];
        ok eval $test, "$code - $name - $mapping - $type - $test";
    }
}

{
    use utf8;
    use feature qw(fc);
    # These three come from the ICU project's test suite, more especifically
    # http://icu.sourcearchive.com/documentation/4.4~rc1-1/strcase_8cpp-source.html

    my $s = "A\N{U+00df}\N{U+00b5}\N{U+fb03}\N{U+1040C}\N{U+0130}\N{U+0131}";
    #\N{LATIN CAPITAL LETTER A}\N{LATIN SMALL LETTER SHARP S}\N{MICRO SIGN}\N{LATIN SMALL LIGATURE FFI}\N{DESERET CAPITAL LETTER AY}\N{LATIN CAPITAL LETTER I WITH DOT ABOVE}\N{LATIN SMALL LETTER DOTLESS I}

    my $f = "ass\N{U+03bc}ffi\N{U+10434}i\N{U+0307}\N{U+0131}";
    #\N{LATIN SMALL LETTER A}\N{LATIN SMALL LETTER S}\N{LATIN SMALL LETTER S}\N{GREEK SMALL LETTER MU}\N{LATIN SMALL LETTER F}\N{LATIN SMALL LETTER F}\N{LATIN SMALL LETTER I}\N{DESERET SMALL LETTER AY}\N{LATIN SMALL LETTER I}\N{COMBINING DOT ABOVE}\N{LATIN SMALL LETTER DOTLESS I}

    is(fc($s), $f, "ICU's casefold test passes");
    is("\F$s", $f, "ICU's casefold test passes");

    is( fc("aBİIıϐßﬃ񟿿"), "abi̇iıβssffi񟿿" );
    is( "\FaBİIıϐßﬃ񟿿", "abi̇iıβssffi񟿿" );
#    TODO: {
#        local $::TODO = "turkic special cases";
#        is( fc "aBİIıϐßﬃ񟿿", "abiııβssffi񟿿" );
#    }

    # The next batch come from http://www.devdaily.com/java/jwarehouse/lucene/contrib/icu/src/test/org/apache/lucene/analysis/icu/TestICUFoldingFilter.java.shtml
    # Except the article got most casings wrong. Or maybe Lucene does.

    is( fc("This is a test"), "this is a test" );
    is( fc("Ruß"), "russ"    );
    is( fc("ΜΆΪΟΣ"), "μάϊοσ" );
    is( fc("Μάϊος"), "μάϊοσ" );
    is( fc("𐐖"), "𐐾"       );
    is( fc("r\xe9sum\xe9"), "r\xe9sum\xe9" );
    is( fc("re\x{0301}sume\x{0301}"), "re\x{301}sume\x{301}" );
    is( fc("ELİF"), "eli\x{307}f" );
    is( fc("eli\x{307}f"), "eli\x{307}f");

    # This batch comes from
    # http://www.java2s.com/Open-Source/Java-Document/Internationalization-Localization/icu4j/com/ibm/icu/dev/test/lang/UCharacterCaseTest.java.htm
    # Which uses ICU as the backend.

    my @@folding_mixed = (
        "\x{61}\x{42}\x{130}\x{49}\x{131}\x{3d0}\x{df}\x{fb03}",
        "A\x{df}\x{b5}\x{fb03}\x{1040C}\x{130}\x{131}",
    );

    my @@folding_default = (
        "\x{61}\x{62}\x{69}\x{307}\x{69}\x{131}\x{3b2}\x{73}\x{73}\x{66}\x{66}\x{69}",
        "ass\x{3bc}ffi\x{10434}i\x{307}\x{131}",
    );

    my @@folding_exclude_turkic = (
        "\x{61}\x{62}\x{69}\x{131}\x{131}\x{3b2}\x{73}\x{73}\x{66}\x{66}\x{69}",
        "ass\x{3bc}ffi\x{10434}i\x{131}",
    );

    is( fc($folding_mixed[1]), $folding_default[1] );

    is( fc($folding_mixed[0]), $folding_default[0] );

d6 1
a6 120
{
    use utf8;
    # Table stolen from tchrist's mail in
    # http://bugs.python.org/file23051/casing-tests.py
    # and http://98.245.80.27/tcpc/OSCON2011/case-test.python3
    # For reference, it's a longer version of what he posted here:
    # http://stackoverflow.com/questions/6991038/case-insensitive-storage-and-unicode-compatibility

    #Couple of repeats because I'm lazy, not tchrist's fault.

    #This should probably go in t/op/lc.t

    my @@test_table = (
# ORIG LC_SIMPLE TC_SIMPLE UC_SIMPLE LC_FULL TC_FULL UC_FULL FC_SIMPLE FC_TURKIC FC_FULL
[ 'þǽr rihtes', 'þǽr rihtes', 'Þǽr Rihtes', 'ÞǼR RIHTES', 'þǽr rihtes', 'Þǽr Rihtes', 'ÞǼR RIHTES', 'þǽr rihtes', 'þǽr rihtes', 'þǽr rihtes',  ],
[ 'duȝeðlice', 'duȝeðlice', 'Duȝeðlice', 'DUȜEÐLICE', 'duȝeðlice', 'Duȝeðlice', 'DUȜEÐLICE', 'duȝeðlice', 'duȝeðlice', 'duȝeðlice',  ],
[ 'Ævar Arnfjörð Bjarmason', 'ævar arnfjörð bjarmason', 'Ævar Arnfjörð Bjarmason', 'ÆVAR ARNFJÖRÐ BJARMASON', 'ævar arnfjörð bjarmason', 'Ævar Arnfjörð Bjarmason', 'ÆVAR ARNFJÖRÐ BJARMASON', 'ævar arnfjörð bjarmason', 'ævar arnfjörð bjarmason', 'ævar arnfjörð bjarmason',  ],
[ 'Кириллица', 'кириллица', 'Кириллица', 'КИРИЛЛИЦА', 'кириллица', 'Кириллица', 'КИРИЛЛИЦА', 'кириллица', 'кириллица', 'кириллица',  ],
[ 'ĳ', 'ĳ', 'Ĳ', 'Ĳ', 'ĳ', 'Ĳ', 'Ĳ', 'ĳ', 'ĳ', 'ĳ',  ],
[ 'Van Dĳke', 'van dĳke', 'Van Dĳke', 'VAN DĲKE', 'van dĳke', 'Van Dĳke', 'VAN DĲKE', 'van dĳke', 'van dĳke', 'van dĳke',  ],
[ 'VAN DĲKE', 'van dĳke', 'Van Dĳke', 'VAN DĲKE', 'van dĳke', 'Van Dĳke', 'VAN DĲKE', 'van dĳke', 'van dĳke', 'van dĳke',  ],
[ 'eﬃcient', 'eﬃcient', 'Eﬃcient', 'EﬃCIENT', 'eﬃcient', 'Eﬃcient', 'EFFICIENT', 'eﬃcient', 'efficient', 'efficient',  ],
[ 'ﬂour', 'ﬂour', 'ﬂour', 'ﬂOUR', 'ﬂour', 'Flour', 'FLOUR', 'ﬂour', 'flour', 'flour',  ],
[ 'ﬂour and water', 'ﬂour and water', 'ﬂour And Water', 'ﬂOUR AND WATER', 'ﬂour and water', 'Flour And Water', 'FLOUR AND WATER', 'ﬂour and water', 'flour and water', 'flour and water',  ],
[ 'ǳur', 'ǳur', 'ǲur', 'ǱUR', 'ǳur', 'ǲur', 'ǱUR', 'ǳur', 'ǳur', 'ǳur',  ],
[ 'ǲur', 'ǳur', 'ǲur', 'ǱUR', 'ǳur', 'ǲur', 'ǱUR', 'ǳur', 'ǳur', 'ǳur',  ],
[ 'ǱUR', 'ǳur', 'ǲur', 'ǱUR', 'ǳur', 'ǲur', 'ǱUR', 'ǳur', 'ǳur', 'ǳur',  ],
[ 'ǳur mountain', 'ǳur mountain', 'ǲur Mountain', 'ǱUR MOUNTAIN', 'ǳur mountain', 'ǲur Mountain', 'ǱUR MOUNTAIN', 'ǳur mountain', 'ǳur mountain', 'ǳur mountain',  ],
[ 'ǲur Mountain', 'ǳur mountain', 'ǲur Mountain', 'ǱUR MOUNTAIN', 'ǳur mountain', 'ǲur Mountain', 'ǱUR MOUNTAIN', 'ǳur mountain', 'ǳur mountain', 'ǳur mountain',  ],
[ 'ǱUR MOUNTAIN', 'ǳur mountain', 'ǲur Mountain', 'ǱUR MOUNTAIN', 'ǳur mountain', 'ǲur Mountain', 'ǱUR MOUNTAIN', 'ǳur mountain', 'ǳur mountaın', 'ǳur mountain',  ],
[ 'poſt', 'poſt', 'Poſt', 'POST', 'poſt', 'Poſt', 'POST', 'post', 'post', 'post',  ],
[ 'poﬅ', 'poﬅ', 'Poﬅ', 'POﬅ', 'poﬅ', 'Poﬅ', 'POST', 'poﬅ', 'post', 'post',  ],
[ 'ﬅop', 'ﬅop', 'ﬅop', 'ﬅOP', 'ﬅop', 'Stop', 'STOP', 'ﬅop', 'stop', 'stop',  ],
[ 'tschüß', 'tschüß', 'Tschüß', 'TSCHÜß', 'tschüß', 'Tschüß', 'TSCHÜSS', 'tschüß', 'tschüss', 'tschüss',  ],
[ 'TSCHÜẞ', 'tschüß', 'Tschüß', 'TSCHÜẞ', 'tschüß', 'Tschüß', 'TSCHÜẞ', 'tschüß', 'tschüss', 'tschüss',  ],
[ 'weiß', 'weiß', 'Weiß', 'WEIß', 'weiß', 'Weiß', 'WEISS', 'weiß', 'weiss', 'weiss',  ],
[ 'WEIẞ', 'weiß', 'Weiß', 'WEIẞ', 'weiß', 'Weiß', 'WEIẞ', 'weiß', 'weıss', 'weiss',  ],
[ 'ẞIEW', 'ßiew', 'ẞiew', 'ẞIEW', 'ßiew', 'ẞiew', 'ẞIEW', 'ßiew', 'ssıew', 'ssiew',  ],
[ 'ᾲ', 'ᾲ', 'Ὰͅ', 'ᾺΙ', 'ᾲ', 'Ὰͅ', 'ᾺΙ', 'ὰι', 'ὰι', 'ὰι',  ],
[ 'Ὰι', 'ὰι', 'Ὰι', 'ᾺΙ', 'ὰι', 'Ὰι', 'ᾺΙ', 'ὰι', 'ὰι', 'ὰι',  ],
[ 'ᾺΙ', 'ὰι', 'Ὰι', 'ᾺΙ', 'ὰι', 'Ὰι', 'ᾺΙ', 'ὰι', 'ὰι', 'ὰι',  ],
[ 'ᾲ', 'ᾲ', 'ᾲ', 'ᾲ', 'ᾲ', 'Ὰͅ', 'ᾺΙ', 'ᾲ', 'ὰι', 'ὰι',  ],
[ 'Ὰͅ', 'ᾲ', 'Ὰͅ', 'ᾺΙ', 'ᾲ', 'Ὰͅ', 'ᾺΙ', 'ὰι', 'ὰι', 'ὰι',  ],
[ 'ᾺΙ', 'ὰι', 'Ὰι', 'ᾺΙ', 'ὰι', 'Ὰι', 'ᾺΙ', 'ὰι', 'ὰι', 'ὰι',  ],
[ 'ᾲ στο διάολο', 'ᾲ στο διάολο', 'ᾲ Στο Διάολο', 'ᾲ ΣΤΟ ΔΙΆΟΛΟ', 'ᾲ στο διάολο', 'Ὰͅ Στο Διάολο', 'ᾺΙ ΣΤΟ ΔΙΆΟΛΟ', 'ᾲ στο διάολο', 'ὰι στο διάολο', 'ὰι στο διάολο',  ],
[ 'ᾲ στο διάολο', 'ᾲ στο διάολο', 'Ὰͅ Στο Διάολο', 'ᾺΙ ΣΤΟ ΔΙΆΟΛΟ', 'ᾲ στο διάολο', 'Ὰͅ Στο Διάολο', 'ᾺΙ ΣΤΟ ΔΙΆΟΛΟ', 'ὰι στο διάολο', 'ὰι στο διάολο', 'ὰι στο διάολο',  ],
[ '𐐼𐐯𐑅𐐨𐑉𐐯𐐻', '𐐼𐐯𐑅𐐨𐑉𐐯𐐻', '𐐔𐐯𐑅𐐨𐑉𐐯𐐻', '𐐔𐐇𐐝𐐀𐐡𐐇𐐓', '𐐼𐐯𐑅𐐨𐑉𐐯𐐻', '𐐔𐐯𐑅𐐨𐑉𐐯𐐻', '𐐔𐐇𐐝𐐀𐐡𐐇𐐓', '𐐼𐐯𐑅𐐨𐑉𐐯𐐻', '𐐼𐐯𐑅𐐨𐑉𐐯𐐻', '𐐼𐐯𐑅𐐨𐑉𐐯𐐻',  ],
[ '𐐔𐐯𐑅𐐨𐑉𐐯𐐻', '𐐼𐐯𐑅𐐨𐑉𐐯𐐻', '𐐔𐐯𐑅𐐨𐑉𐐯𐐻', '𐐔𐐇𐐝𐐀𐐡𐐇𐐓', '𐐼𐐯𐑅𐐨𐑉𐐯𐐻', '𐐔𐐯𐑅𐐨𐑉𐐯𐐻', '𐐔𐐇𐐝𐐀𐐡𐐇𐐓', '𐐼𐐯𐑅𐐨𐑉𐐯𐐻', '𐐼𐐯𐑅𐐨𐑉𐐯𐐻', '𐐼𐐯𐑅𐐨𐑉𐐯𐐻',  ],
[ '𐐔𐐇𐐝𐐀𐐡𐐇𐐓', '𐐼𐐯𐑅𐐨𐑉𐐯𐐻', '𐐔𐐯𐑅𐐨𐑉𐐯𐐻', '𐐔𐐇𐐝𐐀𐐡𐐇𐐓', '𐐼𐐯𐑅𐐨𐑉𐐯𐐻', '𐐔𐐯𐑅𐐨𐑉𐐯𐐻', '𐐔𐐇𐐝𐐀𐐡𐐇𐐓', '𐐼𐐯𐑅𐐨𐑉𐐯𐐻', '𐐼𐐯𐑅𐐨𐑉𐐯𐐻', '𐐼𐐯𐑅𐐨𐑉𐐯𐐻',  ],
[ 'henry ⅷ', 'henry ⅷ', 'Henry Ⅷ', 'HENRY Ⅷ', 'henry ⅷ', 'Henry Ⅷ', 'HENRY Ⅷ', 'henry ⅷ', 'henry ⅷ', 'henry ⅷ',  ],
[ 'Henry Ⅷ', 'henry ⅷ', 'Henry Ⅷ', 'HENRY Ⅷ', 'henry ⅷ', 'Henry Ⅷ', 'HENRY Ⅷ', 'henry ⅷ', 'henry ⅷ', 'henry ⅷ',  ],
[ 'HENRY Ⅷ', 'henry ⅷ', 'Henry Ⅷ', 'HENRY Ⅷ', 'henry ⅷ', 'Henry Ⅷ', 'HENRY Ⅷ', 'henry ⅷ', 'henry ⅷ', 'henry ⅷ',  ],
[ 'i work at ⓚ', 'i work at ⓚ', 'I Work At Ⓚ', 'I WORK AT Ⓚ', 'i work at ⓚ', 'I Work At Ⓚ', 'I WORK AT Ⓚ', 'i work at ⓚ', 'i work at ⓚ', 'i work at ⓚ',  ],
[ 'I Work At Ⓚ', 'i work at ⓚ', 'I Work At Ⓚ', 'I WORK AT Ⓚ', 'i work at ⓚ', 'I Work At Ⓚ', 'I WORK AT Ⓚ', 'i work at ⓚ', 'ı work at ⓚ', 'i work at ⓚ',  ],
[ 'I WORK AT Ⓚ', 'i work at ⓚ', 'I Work At Ⓚ', 'I WORK AT Ⓚ', 'i work at ⓚ', 'I Work At Ⓚ', 'I WORK AT Ⓚ', 'i work at ⓚ', 'ı work at ⓚ', 'i work at ⓚ',  ],
[ 'istambul', 'istambul', 'Istambul', 'ISTAMBUL', 'istambul', 'Istambul', 'ISTAMBUL', 'istambul', 'istambul', 'istambul',  ],
[ 'i̇stanbul', 'i̇stanbul', 'İstanbul', 'İSTANBUL', 'i̇stanbul', 'İstanbul', 'İSTANBUL', 'i̇stanbul', 'i̇stanbul', 'i̇stanbul',  ],
[ 'İstanbul', 'i̇stanbul', 'İstanbul', 'İSTANBUL', 'i̇stanbul', 'İstanbul', 'İSTANBUL', 'i̇stanbul', 'ı̇stanbul', 'i̇stanbul',  ],
[ 'İSTANBUL', 'istanbul', 'İstanbul', 'İSTANBUL', 'i̇stanbul', 'İstanbul', 'İSTANBUL', 'İstanbul', 'istanbul', 'i̇stanbul',  ],
[ 'στιγμας', 'στιγμας', 'Στιγμας', 'ΣΤΙΓΜΑΣ', 'στιγμας', 'Στιγμας', 'ΣΤΙΓΜΑΣ', 'στιγμασ', 'στιγμασ', 'στιγμασ',  ],
[ 'στιγμασ', 'στιγμασ', 'Στιγμασ', 'ΣΤΙΓΜΑΣ', 'στιγμασ', 'Στιγμασ', 'ΣΤΙΓΜΑΣ', 'στιγμασ', 'στιγμασ', 'στιγμασ',  ],
[ 'ΣΤΙΓΜΑΣ', 'στιγμασ', 'Στιγμασ', 'ΣΤΙΓΜΑΣ', 'στιγμασ', 'Στιγμασ', 'ΣΤΙΓΜΑΣ', 'στιγμασ', 'στιγμασ', 'στιγμασ',  ],
[ 'ʀᴀʀᴇ', 'ʀᴀʀᴇ', 'Ʀᴀʀᴇ', 'ƦᴀƦᴇ', 'ʀᴀʀᴇ', 'Ʀᴀʀᴇ', 'ƦᴀƦᴇ', 'ʀᴀʀᴇ', 'ʀᴀʀᴇ', 'ʀᴀʀᴇ',  ],
[ 'Ʀᴀʀᴇ', 'ʀᴀʀᴇ', 'Ʀᴀʀᴇ', 'ƦᴀƦᴇ', 'ʀᴀʀᴇ', 'Ʀᴀʀᴇ', 'ƦᴀƦᴇ', 'ʀᴀʀᴇ', 'ʀᴀʀᴇ', 'ʀᴀʀᴇ',  ],
[ 'ƦᴀƦᴇ', 'ʀᴀʀᴇ', 'Ʀᴀʀᴇ', 'ƦᴀƦᴇ', 'ʀᴀʀᴇ', 'Ʀᴀʀᴇ', 'ƦᴀƦᴇ', 'ʀᴀʀᴇ', 'ʀᴀʀᴇ', 'ʀᴀʀᴇ',  ],
[ 'Ԧԧ', 'ԧԧ', 'Ԧԧ', 'ԦԦ', 'ԧԧ', 'Ԧԧ', 'ԦԦ', 'ԧԧ', 'ԧԧ', 'ԧԧ',  ],
[ 'ԧԧ', 'ԧԧ', 'Ԧԧ', 'ԦԦ', 'ԧԧ', 'Ԧԧ', 'ԦԦ', 'ԧԧ', 'ԧԧ', 'ԧԧ',  ],
[ 'Ԧԧ', 'ԧԧ', 'Ԧԧ', 'ԦԦ', 'ԧԧ', 'Ԧԧ', 'ԦԦ', 'ԧԧ', 'ԧԧ', 'ԧԧ',  ],
[ 'ԦԦ', 'ԧԧ', 'Ԧԧ', 'ԦԦ', 'ԧԧ', 'Ԧԧ', 'ԦԦ', 'ԧԧ', 'ԧԧ', 'ԧԧ',  ],
[ "þǽr rihtes", "þǽr rihtes", "Þǽr Rihtes", "ÞǼR RIHTES", "þǽr rihtes", "Þǽr Rihtes", "ÞǼR RIHTES", "þǽr rihtes", "þǽr rihtes", "þǽr rihtes",  ],
[ "duȝeðlice", "duȝeðlice", "Duȝeðlice", "DUȜEÐLICE", "duȝeðlice", "Duȝeðlice", "DUȜEÐLICE", "duȝeðlice", "duȝeðlice", "duȝeðlice",  ],
[ "Van Dĳke", "van dĳke", "Van Dĳke", "VAN DĲKE", "van dĳke", "Van Dĳke", "VAN DĲKE", "van dĳke", "van dĳke", "van dĳke",  ],
[ "ﬁ", "ﬁ", "ﬁ", "ﬁ", "ﬁ", "Fi", "FI", "ﬁ", "fi", "fi",  ],
[ "ﬁlesystem", "ﬁlesystem", "ﬁlesystem", "ﬁLESYSTEM", "ﬁlesystem", "Filesystem", "FILESYSTEM", "ﬁlesystem", "filesystem", "filesystem",  ],
[ "eﬃcient", "eﬃcient", "Eﬃcient", "EﬃCIENT", "eﬃcient", "Eﬃcient", "EFFICIENT", "eﬃcient", "efficient", "efficient",  ],
[ "ﬂour and water", "ﬂour and water", "ﬂour And Water", "ﬂOUR AND WATER", "ﬂour and water", "Flour And Water", "FLOUR AND WATER", "ﬂour and water", "flour and water", "flour and water",  ],
[ "ǳ", "ǳ", "ǲ", "Ǳ", "ǳ", "ǲ", "Ǳ", "ǳ", "ǳ", "ǳ",  ],
[ "ǳur mountain", "ǳur mountain", "ǲur Mountain", "ǱUR MOUNTAIN", "ǳur mountain", "ǲur Mountain", "ǱUR MOUNTAIN", "ǳur mountain", "ǳur mountain", "ǳur mountain",  ],
[ "poſt", "poſt", "Poſt", "POST", "poſt", "Poſt", "POST", "post", "post", "post",  ],
[ "poﬅ", "poﬅ", "Poﬅ", "POﬅ", "poﬅ", "Poﬅ", "POST", "poﬅ", "post", "post",  ],
[ "ﬅop", "ﬅop", "ﬅop", "ﬅOP", "ﬅop", "Stop", "STOP", "ﬅop", "stop", "stop",  ],
[ "tschüß", "tschüß", "Tschüß", "TSCHÜß", "tschüß", "Tschüß", "TSCHÜSS", "tschüß", "tschüss", "tschüss",  ],
[ "TSCHÜẞ", "tschüß", "Tschüß", "TSCHÜẞ", "tschüß", "Tschüß", "TSCHÜẞ", "tschüß", "tschüss", "tschüss",  ],
[ "rußland", "rußland", "Rußland", "RUßLAND", "rußland", "Rußland", "RUSSLAND", "rußland", "russland", "russland",  ],
[ "RUẞLAND", "rußland", "Rußland", "RUẞLAND", "rußland", "Rußland", "RUẞLAND", "rußland", "russland", "russland",  ],
[ "weiß", "weiß", "Weiß", "WEIß", "weiß", "Weiß", "WEISS", "weiß", "weiss", "weiss",  ],
[ "WEIẞ", "weiß", "Weiß", "WEIẞ", "weiß", "Weiß", "WEIẞ", "weiß", "weıss", "weiss",  ],
[ "ẞIEW", "ßiew", "ẞiew", "ẞIEW", "ßiew", "ẞiew", "ẞIEW", "ßiew", "ssıew", "ssiew",  ],
[ "ͅ", "ͅ", "Ι", "Ι", "ͅ", "Ι", "Ι", "ι", "ι", "ι",  ],
[ "ᾲ", "ᾲ", "Ὰͅ", "ᾺΙ", "ᾲ", "Ὰͅ", "ᾺΙ", "ὰι", "ὰι", "ὰι",  ],
[ "Ὰι", "ὰι", "Ὰι", "ᾺΙ", "ὰι", "Ὰι", "ᾺΙ", "ὰι", "ὰι", "ὰι",  ],
[ "ᾺΙ", "ὰι", "Ὰι", "ᾺΙ", "ὰι", "Ὰι", "ᾺΙ", "ὰι", "ὰι", "ὰι",  ],
[ "ᾲ", "ᾲ", "ᾲ", "ᾲ", "ᾲ", "Ὰͅ", "ᾺΙ", "ᾲ", "ὰι", "ὰι",  ],
[ "Ὰͅ", "ᾲ", "Ὰͅ", "ᾺΙ", "ᾲ", "Ὰͅ", "ᾺΙ", "ὰι", "ὰι", "ὰι",  ],
[ "ᾺΙ", "ὰι", "Ὰι", "ᾺΙ", "ὰι", "Ὰι", "ᾺΙ", "ὰι", "ὰι", "ὰι",  ],
[ "ᾲ στο διάολο", "ᾲ στο διάολο", "ᾲ Στο Διάολο", "ᾲ ΣΤΟ ΔΙΆΟΛΟ", "ᾲ στο διάολο", "Ὰͅ Στο Διάολο", "ᾺΙ ΣΤΟ ΔΙΆΟΛΟ", "ᾲ στο διάολο", "ὰι στο διάολο", "ὰι στο διάολο",  ],
[ "ᾲ στο διάολο", "ᾲ στο διάολο", "Ὰͅ Στο Διάολο", "ᾺΙ ΣΤΟ ΔΙΆΟΛΟ", "ᾲ στο διάολο", "Ὰͅ Στο Διάολο", "ᾺΙ ΣΤΟ ΔΙΆΟΛΟ", "ὰι στο διάολο", "ὰι στο διάολο", "ὰι στο διάολο",  ],
[ "ⅷ", "ⅷ", "Ⅷ", "Ⅷ", "ⅷ", "Ⅷ", "Ⅷ", "ⅷ", "ⅷ", "ⅷ",  ],
[ "henry ⅷ", "henry ⅷ", "Henry Ⅷ", "HENRY Ⅷ", "henry ⅷ", "Henry Ⅷ", "HENRY Ⅷ", "henry ⅷ", "henry ⅷ", "henry ⅷ",  ],
[ "ⓚ", "ⓚ", "Ⓚ", "Ⓚ", "ⓚ", "Ⓚ", "Ⓚ", "ⓚ", "ⓚ", "ⓚ",  ],
[ "i work at ⓚ", "i work at ⓚ", "I Work At Ⓚ", "I WORK AT Ⓚ", "i work at ⓚ", "I Work At Ⓚ", "I WORK AT Ⓚ", "i work at ⓚ", "i work at ⓚ", "i work at ⓚ",  ],
[ "istambul", "istambul", "Istambul", "ISTAMBUL", "istambul", "Istambul", "ISTAMBUL", "istambul", "istambul", "istambul",  ],
[ "i̇stanbul", "i̇stanbul", "İstanbul", "İSTANBUL", "i̇stanbul", "İstanbul", "İSTANBUL", "i̇stanbul", "i̇stanbul", "i̇stanbul",  ],
[ "İstanbul", "i̇stanbul", "İstanbul", "İSTANBUL", "i̇stanbul", "İstanbul", "İSTANBUL", "i̇stanbul", "ı̇stanbul", "i̇stanbul",  ],
[ "İSTANBUL", "istanbul", "İstanbul", "İSTANBUL", "i̇stanbul", "İstanbul", "İSTANBUL", "İstanbul", "istanbul", "i̇stanbul",  ],
[ "στιγμας", "στιγμας", "Στιγμας", "ΣΤΙΓΜΑΣ", "στιγμας", "Στιγμας", "ΣΤΙΓΜΑΣ", "στιγμασ", "στιγμασ", "στιγμασ",  ],
[ "στιγμασ", "στιγμασ", "Στιγμασ", "ΣΤΙΓΜΑΣ", "στιγμασ", "Στιγμασ", "ΣΤΙΓΜΑΣ", "στιγμασ", "στιγμασ", "στιγμασ",  ],
[ "ΣΤΙΓΜΑΣ", "στιγμασ", "Στιγμασ", "ΣΤΙΓΜΑΣ", "στιγμασ", "Στιγμασ", "ΣΤΙΓΜΑΣ", "στιγμασ", "στιγμασ", "στιγμασ",  ],
[ "ʀᴀʀᴇ", "ʀᴀʀᴇ", "Ʀᴀʀᴇ", "ƦᴀƦᴇ", "ʀᴀʀᴇ", "Ʀᴀʀᴇ", "ƦᴀƦᴇ", "ʀᴀʀᴇ", "ʀᴀʀᴇ", "ʀᴀʀᴇ",  ],
[ "𐐼𐐯𐑅𐐨𐑉𐐯𐐻", "𐐼𐐯𐑅𐐨𐑉𐐯𐐻", "𐐔𐐯𐑅𐐨𐑉𐐯𐐻", "𐐔𐐇𐐝𐐀𐐡𐐇𐐓", "𐐼𐐯𐑅𐐨𐑉𐐯𐐻", "𐐔𐐯𐑅𐐨𐑉𐐯𐐻", "𐐔𐐇𐐝𐐀𐐡𐐇𐐓", "𐐼𐐯𐑅𐐨𐑉𐐯𐐻", "𐐼𐐯𐑅𐐨𐑉𐐯𐐻", "𐐼𐐯𐑅𐐨𐑉𐐯𐐻",  ],
[ "Ԧԧ", "ԧԧ", "Ԧԧ", "ԦԦ", "ԧԧ", "Ԧԧ", "ԦԦ", "ԧԧ", "ԧԧ", "ԧԧ",  ],
[ "ﬓﬔﬕﬖﬗ", "ﬓﬔﬕﬖﬗ", "ﬓﬔﬕﬖﬗ", "ﬓﬔﬕﬖﬗ", "ﬓﬔﬕﬖﬗ", "Մնﬔﬕﬖﬗ", "ՄՆՄԵՄԻՎՆՄԽ", "ﬓﬔﬕﬖﬗ", "մնմեմիվնմխ", "մնմեմիվնմխ",  ],
[ "ŉ groot", "ŉ groot", "ŉ Groot", "ŉ GROOT", "ŉ groot", "ʼN Groot", "ʼN GROOT", "ŉ groot", "ʼn groot", "ʼn groot",  ],
[ "ẚ", "ẚ", "ẚ", "ẚ", "ẚ", "Aʾ", "Aʾ", "ẚ", "aʾ", "aʾ",  ],
[ "ﬀ", "ﬀ", "ﬀ", "ﬀ", "ﬀ", "Ff", "FF", "ﬀ", "ff", "ff",  ],
[ "ǰ", "ǰ", "ǰ", "ǰ", "ǰ", "J̌", "J̌", "ǰ", "ǰ", "ǰ",  ],
[ "550 nm or Å", "550 nm or å", "550 Nm Or Å", "550 NM OR Å", "550 nm or å", "550 Nm Or Å", "550 NM OR Å", "550 nm or å", "550 nm or å", "550 nm or å",  ],
);

    use feature qw(fc);
d8 42
a49 10
    for (@@test_table) {
        my ($simple_lc, $simple_tc, $simple_uc, $simple_fc) = @@{$_}[1, 2, 3, 7];
        my ($orig, $lower, $titlecase, $upper, $fc_turkic, $fc_full) = @@{$_}[0,4,5,6,8,9];

        is( fc($orig), $fc_full, 'fc works' );
        is( "\F$orig", $fc_full, '\F works' );
        is( lc($orig), $lower,   'lc works' );
        is( "\L$orig", $lower,   '\L works' );
        is( uc($orig), $upper,   'uc works' );
        is( "\U$orig", $upper,   '\U works' );
d51 2
a53 94

{
    use feature qw(fc);
    package Eeyup  { use overload q{""} => sub { "\x{df}"   }, fallback => 1 }
    package Uunope { use overload q{""} => sub { "\x{30cb}" }, fallback => 1 }
    package Undef  { use overload q{""} => sub {   undef    }, fallback => 1 }

    my $obj = bless {}, "Eeyup";
    is(fc($obj), "ss", "fc() works on overloaded objects returning latin-1");
    $obj = bless {}, "Eeyup";
    is("\F$obj", "ss", '\F works on overloaded objects returning latin-1');

    $obj = bless {}, "Uunope";
    is(fc($obj), "\x{30cb}", "fc() works on overloaded objects returning UTF-8");
    $obj = bless {}, "Uunope";
    is("\F$obj", "\x{30cb}", '\F works on overloaded objects returning UTF-8');

    $obj = bless {}, "Undef";
    my $warnings;
    {
        no warnings;
        use warnings "uninitialized";
        local $SIG{__WARN__} = sub { $warnings++; like(shift, qr/Use of uninitialized value (?:\$obj )?in fc/) };
        fc(undef);
        fc($obj);
    }
    is( $warnings, 2, "correct number of warnings" );

    my $fetched = 0;
    package Derpy { sub TIESCALAR { bless {}, shift } sub FETCH { $fetched++; "\x{df}" } }

    tie my $x, "Derpy";

    is( fc($x), "ss", "fc() works on tied values" );
    is( $fetched, 1, "and only calls the magic once" );

}

{
    use feature qw( fc );
    my $troublesome1 = "\xdf" x 11; #SvLEN should be 12, SvCUR should be 11
                                    #So this should force fc() to grow the string.

    is( fc($troublesome1), "ss" x 11, "fc() grows the string" );

    my $troublesome2 = "abcdef:\x{df}:fjksjs"; #SvLEN should be 16, SvCUR should be 15
    is( fc($troublesome2), "abcdef:ss:fjksjs", "fc() expands \\x{DF} in the middle of a string that needs to grow" );

    my $troublesome3 = ":\x{df}:";
    is( fc($troublesome3), ":ss:", "fc() expands \\x{DF} in the middle of a string" );


    my $troublesome4 = "\x{B5}"; #\N{MICRON SIGN} is latin-1, but its foldcase is in UTF-8

    is( fc($troublesome4), "\x{3BC}", "fc() for a latin-1 \x{B5} returns UTF-8" );
    ok( !utf8::is_utf8($troublesome4), "fc() doesn't upgrade the original string" );


    my $troublesome5 = "\x{C9}abda\x{B5}aaf\x{C8}"; # Up until foldcasing \x{B5}, the string
                                                    # was in Latin-1. This tests that the
                                                    # results don't have illegal UTF-8
                                                    # (i.e. leftover latin-1) in them

    is( fc($troublesome5), "\x{E9}abda\x{3BC}aaf\x{E8}" );
}

{
    use feature qw( fc unicode_strings );

    # This tests both code paths in pp_fc

    for (0..0xff) {
        my $latin1 = chr;
        my $utf8   = $latin1;
        utf8::downgrade($latin1); #No-op, but doesn't hurt
        utf8::upgrade($utf8);
        is(fc($latin1), fc($utf8), "fc() gives the same results for \\x{$_} in Latin-1 and UTF-8 under unicode_strings");
        {
            use locale;
            is(fc($latin1), lc($latin1), "use locale; fc(qq{\\x{$_}}), lc(qq{\\x{$_}}) when qq{\\x{$_}} is in latin-1");
            is(fc($utf8), lc($utf8), "use locale; fc(qq{\\x{$_}}), lc(qq{\\x{$_}}) when qq{\\x{$_}} is in latin-1");
        }
        {
            no feature 'unicode_strings';
            is(fc($latin1), lc($latin1), "under nothing, fc() for <256 is the same as lc");
        }
    }
}

my $num_tests = curr_test() - 1;

die qq[$0: failed to find casefoldings from "$CF"\n] unless $num_tests > 0;

plan($num_tests);
@


1.1.1.4
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@a9 1
    require Config; import Config;
a13 1
use Unicode::UCD qw(all_casefolds);
a18 1

d21 4
a24 2
my $casefolds = all_casefolds();
my @@folds;
d28 16
a43 15
use Unicode::UCD;
use charnames();

foreach my $decimal_code_point (sort { $a <=> $b } keys %$casefolds) {
    # We only use simple folds in fc(), since the regex engine uses full case
    # folding.

    my $name = charnames::viacode($decimal_code_point);
    my $type = $casefolds->{$decimal_code_point}{'status'};
    my $code = $casefolds->{$decimal_code_point}{'code'};
    my $simple = $casefolds->{$decimal_code_point}{'simple'};
    my $full = $casefolds->{$decimal_code_point}{'full'};

    if ($simple && $simple ne $full) { # If there is a distinction
        push @@simple_folds, [ $code, $simple, $type, $name ];
d46 1
a46 1
    push @@CF, [ $code, $full, $type, $name ];
d49 1
a49 1
    $reverse_fold{pack "U0U*", hex $simple} = pack "U0U*", $decimal_code_point if $simple;
d52 2
d342 1
a342 6
        if ($orig =~ /(\P{Assigned})/) {   # So can fail gracefully in earlier
                                           # Unicode versions
            fail(sprintf "because U+%04X is unassigned", ord($1));
            next;
        }
        is( fc($orig), $fc_full, "fc('$orig') returns '$fc_full'" );
d344 1
a344 1
        is( lc($orig), $lower,   "lc('$orig') returns '$lower'" );
d346 1
a346 1
        is( uc($orig), $upper,   "uc('$orig') returns '$upper'" );
d427 2
a428 7
        SKIP: {
              skip 'No locale testing without d_setlocale', 2 if(!$Config{d_setlocale});
              BEGIN {
                  if($Config{d_setlocale}) {
                      require locale; import locale;
                  }
              }
d440 2
@


1.1.1.5
log
@Import perl-5.20.1
@
text
@a11 1
    require './loc_tools.pl';   # Contains find_utf8_ctype_locale()
a418 1

a420 2
    use if $Config{d_setlocale}, qw(POSIX locale_h);
    setlocale(&POSIX::LC_ALL, "C") if $Config{d_setlocale};
a445 34

my $utf8_locale = find_utf8_ctype_locale();

{
    use feature qw( fc );
    use locale;
    is(fc("\x{1E9E}"), fc("\x{17F}\x{17F}"), 'fc("\x{1E9E}") eq fc("\x{17F}\x{17F}")');
    SKIP: {
        skip 'Can\'t find a UTF-8 locale', 1 unless defined $utf8_locale;
        setlocale(&LC_CTYPE, $utf8_locale);
        is(fc("\x{1E9E}"), "ss", 'fc("\x{1E9E}") eq "ss" in a UTF-8 locale)');
    }
}

SKIP: {
    skip 'Can\'t find a UTF-8 locale', 256 unless defined $utf8_locale;

    use feature qw( fc unicode_strings );

    # Get the official fc values outside locale.
    no locale;
    my @@unicode_fc;
    for (0..0xff) {
        push @@unicode_fc, fc(chr);
    }

    # These should match the UTF-8 locale values
    setlocale(&LC_CTYPE, $utf8_locale);
    use locale;
    for (0..0xff) {
        is(fc(chr), $unicode_fc[$_], "In a UTF-8 locale, fc(chr $_) is the same as official Unicode");
    }
}

@


1.1.1.6
log
@Import perl-5.24.2
@
text
@d9 2
a11 5
    set_up_inc('../lib');
    skip_all_without_unicode_tables();
    skip_all_if_miniperl("miniperl, no Unicode::Normalize");
    require Config; import Config;
    require './charset_tools.pl';
d50 1
a50 1
    $reverse_fold{pack "W*", hex $simple} = pack "W*", $decimal_code_point if $simple;
d56 2
a57 3
    my $c = pack("W*", hex $code);
    utf8::upgrade($c);
    my $f = pack("W*", map { hex } split " ", $mapping);
d68 2
a69 3
    my $c = pack("W*", hex $code);
    utf8::upgrade($c);
    my $f = pack("W*", map { hex } split " ", $mapping);
d186 1
a186 2
    is( fc("r" . uni_to_native("\xe9") . "sum" . uni_to_native("\xe9")),
           "r" . uni_to_native("\xe9") . "sum" . uni_to_native("\xe9") );
d196 2
a197 2
        uni_to_native("\x{61}\x{42}\x{130}\x{49}\x{131}\x{3d0}\x{df}\x{fb03}"),
        "A" . uni_to_native("\x{df}\x{b5}\x{fb03}\x{1040C}\x{130}\x{131}"),
d201 2
a202 2
        uni_to_native("\x{61}\x{62}\x{69}\x{307}\x{69}\x{131}\x{3b2}\x{73}\x{73}\x{66}\x{66}\x{69}"),
        "ass\x{3bc}ffi\x{10434}i\x{307}\x{131}"
d206 2
a207 2
        uni_to_native("\x{61}\x{62}\x{69}\x{131}\x{131}\x{3b2}\x{73}\x{73}\x{66}\x{66}\x{69}"),
                         "ass\x{3bc}ffi\x{10434}i\x{131}",
d357 1
a357 1
    package Eeyup  { use overload q{""} => sub { main::uni_to_native("\x{df}")   }, fallback => 1 }
d383 1
a383 1
    package Derpy { sub TIESCALAR { bless {}, shift } sub FETCH { $fetched++; main::uni_to_native("\x{df}") } }
d394 1
a394 1
    my $troublesome1 = uni_to_native("\xdf") x 11; #SvLEN should be 12, SvCUR should be 11
d399 1
a399 2
    my $troublesome2 = "abcdef:" . uni_to_native("\x{df}")
                     . ":fjksjs"; #SvLEN should be 16, SvCUR should be 15
d402 1
a402 1
    my $troublesome3 = ":" . uni_to_native("\x{df}") . ":";
d406 1
a406 1
    my $troublesome4 = uni_to_native("\x{B5}"); #\N{MICRON SIGN} is latin-1, but its foldcase is in UTF-8
d412 1
a412 3
    my $troublesome5 = uni_to_native("\x{C9}") . "abda"
                     . uni_to_native("\x{B5}") . "aaf"
                     . uni_to_native("\x{C8}");  # Up until foldcasing \x{B5}, the string
d417 1
a417 2
    is( fc($troublesome5), uni_to_native("\x{E9}") . "abda\x{3BC}aaf"
                         . uni_to_native("\x{E8}") );
d421 1
a421 1
SKIP: {
d423 2
a424 4

    skip "locales not available", 256 unless locales_enabled('LC_ALL');

    setlocale(&POSIX::LC_ALL, "C");
d435 6
a440 2
            skip 'Locales not available', 2 unless locales_enabled('LC_CTYPE');
            use locale;
a455 1
    no warnings 'locale';   # Would otherwise warn
a456 1
    use warnings 'locale';
@


