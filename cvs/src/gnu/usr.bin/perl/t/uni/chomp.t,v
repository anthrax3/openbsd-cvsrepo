head	1.2;
access;
symbols
	PERL_5_24_2:1.1.1.4
	OPENBSD_6_1:1.2.0.4
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.3.0.16
	OPENBSD_6_0_BASE:1.1.1.3
	OPENBSD_5_9:1.1.1.3.0.10
	OPENBSD_5_9_BASE:1.1.1.3
	OPENBSD_5_8:1.1.1.3.0.12
	OPENBSD_5_8_BASE:1.1.1.3
	PERL_5_20_2:1.1.1.3
	OPENBSD_5_7:1.1.1.3.0.4
	OPENBSD_5_7_BASE:1.1.1.3
	PERL_5_20_1:1.1.1.3
	OPENBSD_5_6:1.1.1.3.0.8
	OPENBSD_5_6_BASE:1.1.1.3
	PERL_5_18_2:1.1.1.3
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.3.0.6
	OPENBSD_5_5_BASE:1.1.1.3
	OPENBSD_5_4:1.1.1.3.0.2
	OPENBSD_5_4_BASE:1.1.1.3
	PERL_5_16_3:1.1.1.3
	OPENBSD_5_3:1.1.1.2.0.10
	OPENBSD_5_3_BASE:1.1.1.2
	OPENBSD_5_2:1.1.1.2.0.8
	OPENBSD_5_2_BASE:1.1.1.2
	OPENBSD_5_1_BASE:1.1.1.2
	OPENBSD_5_1:1.1.1.2.0.6
	OPENBSD_5_0:1.1.1.2.0.4
	OPENBSD_5_0_BASE:1.1.1.2
	OPENBSD_4_9:1.1.1.2.0.2
	OPENBSD_4_9_BASE:1.1.1.2
	PERL_5_12_2:1.1.1.2
	OPENBSD_4_8:1.1.1.1.0.26
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.22
	OPENBSD_4_7_BASE:1.1.1.1
	PERL_5_10_1:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.24
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.20
	OPENBSD_4_5_BASE:1.1.1.1
	PERL_5_10_0:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.18
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.16
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.14
	OPENBSD_4_2_BASE:1.1.1.1
	OPENBSD_4_1:1.1.1.1.0.12
	OPENBSD_4_1_BASE:1.1.1.1
	OPENBSD_4_0:1.1.1.1.0.10
	OPENBSD_4_0_BASE:1.1.1.1
	PERL_5_8_8:1.1.1.1
	OPENBSD_3_9:1.1.1.1.0.8
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.6
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.4
	OPENBSD_3_7_BASE:1.1.1.1
	PERL_5_8_6:1.1.1.1
	OPENBSD_3_6:1.1.1.1.0.2
	OPENBSD_3_6_BASE:1.1.1.1
	PERL_5_8_5:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.32.21;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2004.08.09.17.48.37;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2004.08.09.17.48.37;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2010.09.24.14.49.16;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2013.03.25.20.09.38;	author sthen;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2017.08.14.13.46.25;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl -w

BEGIN {
    chdir 't' if -d 't';
    require './test.pl';
    skip_all_without_dynamic_extension('Encode');
    skip_all("encoding doesn't work with EBCDIC") if $::IS_EBCDIC;
    skip_all_without_perlio();
}

use strict;
use Encode;

# %mbchars = (encoding => { bytes => utf8, ... }, ...);
# * pack('C*') is expected to return bytes even if ${^ENCODING} is true.
our %mbchars = (
    'big-5' => {
	pack('C*', 0x40)       => pack('U*', 0x40), # COMMERCIAL AT
	pack('C*', 0xA4, 0x40) => "\x{4E00}",       # CJK-4E00
    },
    'euc-jp' => {
	pack('C*', 0xB0, 0xA1)       => "\x{4E9C}", # CJK-4E9C
	pack('C*', 0x8F, 0xB0, 0xA1) => "\x{4E02}", # CJK-4E02
    },
    'shift-jis' => {
	pack('C*', 0xA9)       => "\x{FF69}", # halfwidth katakana small U
	pack('C*', 0x82, 0xA9) => "\x{304B}", # hiragana KA
    },
);

# 4 == @@char; paired tests inside 3 nested loops,
# plus extra pair of tests in a loop, plus extra pair of tests.
plan tests => 2 * (4 ** 3 + 4 + 1) * (keys %mbchars);

for my $enc (sort keys %mbchars) {
    no warnings 'deprecated';
    local ${^ENCODING} = find_encoding($enc);
    use warnings 'deprecated';
    my @@char = (sort(keys   %{ $mbchars{$enc} }),
		sort(values %{ $mbchars{$enc} }));

    for my $rs (@@char) {
	local $/ = $rs;
	for my $start (@@char) {
	    for my $end (@@char) {
		my $string = $start.$end;
		my ($expect, $return);
		if ($end eq $rs) {
		    $expect = $start;
		    # The answer will always be a length in utf8, even if the
		    # scalar was encoded with a different length
		    $return = length ($end . "\x{100}") - 1;
		} else {
		    $expect = $string;
		    $return = 0;
		}
		is (chomp ($string), $return);
		is ($string, $expect); # "$enc \$/=$rs $start $end"
	    }
	}
	# chomp should not stringify references unless it decides to modify
	# them
	$_ = [];
	my $got = chomp();
	is ($got, 0);
	is (ref($_), "ARRAY", "chomp ref (no modify)");
    }

    $/ = ")";  # the last char of something like "ARRAY(0x80ff6e4)"
    my $got = chomp();
    is ($got, 1);
    ok (!ref($_), "chomp ref (modify)");
}
@


1.1
log
@Initial revision
@
text
@d4 5
a8 21
    if ($ENV{'PERL_CORE'}){
        chdir 't';
        @@INC = '../lib';
    }
    require Config; import Config;
    if ($Config{'extensions'} !~ /\bEncode\b/) {
      print "1..0 # Skip: Encode was not built\n";
      exit 0;
    }
    if (ord("A") == 193) {
        print "1..0 # Skip: EBCDIC\n";
        exit 0;
    }
    unless (PerlIO::Layer->find('perlio')){
        print "1..0 # Skip: PerlIO required\n";
        exit 0;
    }
    if ($ENV{PERL_CORE_MINITEST}) {
        print "1..0 # Skip: no dynamic loading on miniperl, no Encode\n";
        exit 0;
    }
d11 1
a12 2
use strict;
use Test::More;
d36 1
d38 1
@


1.1.1.1
log
@Import of stock perl 5.8.5
@
text
@@


1.1.1.2
log
@Perl 5.12.2 from CPAN
@
text
@d4 4
a24 2

    require './test.pl';
d27 1
d29 1
a29 1
use Encode;
@


1.1.1.3
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d4 18
a22 3
    skip_all_without_dynamic_extension('Encode');
    skip_all("EBCDIC") if $::IS_EBCDIC;
    skip_all_without_perlio();
@


1.1.1.4
log
@Import perl-5.24.2
@
text
@a3 1
    chdir 't' if -d 't';
d6 1
a6 1
    skip_all("encoding doesn't work with EBCDIC") if $::IS_EBCDIC;
a34 1
    no warnings 'deprecated';
a35 1
    use warnings 'deprecated';
@


