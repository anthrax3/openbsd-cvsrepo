head	1.8;
access;
symbols
	OPENBSD_6_1:1.8.0.2
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.7.0.8
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.2
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	PERL_5_20_2:1.1.1.3
	OPENBSD_5_7:1.5.0.2
	OPENBSD_5_7_BASE:1.5
	PERL_5_20_1:1.1.1.3
	OPENBSD_5_6:1.3.0.4
	OPENBSD_5_6_BASE:1.3
	PERL_5_18_2:1.1.1.3
	PERL:1.1.1
	OPENBSD_5_5:1.2.0.6
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.2
	OPENBSD_5_4_BASE:1.2
	PERL_5_16_3:1.1.1.2
	OPENBSD_5_3:1.1.1.2.0.10
	OPENBSD_5_3_BASE:1.1.1.2
	OPENBSD_5_2:1.1.1.2.0.8
	OPENBSD_5_2_BASE:1.1.1.2
	OPENBSD_5_1_BASE:1.1.1.2
	OPENBSD_5_1:1.1.1.2.0.6
	OPENBSD_5_0:1.1.1.2.0.4
	OPENBSD_5_0_BASE:1.1.1.2
	OPENBSD_4_9:1.1.1.2.0.2
	OPENBSD_4_9_BASE:1.1.1.2
	PERL_5_12_2:1.1.1.2
	OPENBSD_4_8:1.1.1.1.0.8
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.4
	OPENBSD_4_7_BASE:1.1.1.1
	PERL_5_10_1:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.6
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.2
	OPENBSD_4_5_BASE:1.1.1.1
	PERL_5_10_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.8
date	2017.02.05.00.32.21;	author afresh1;	state Exp;
branches;
next	1.7;
commitid	cxJ08BvJA9Pt2PTM;

1.7
date	2015.04.25.19.26.23;	author afresh1;	state Exp;
branches;
next	1.6;
commitid	3qGYFVvfrExB70FB;

1.6
date	2015.04.25.19.14.49;	author afresh1;	state Exp;
branches;
next	1.5;
commitid	XRK22kO4se3v2i2I;

1.5
date	2014.11.17.21.01.01;	author afresh1;	state Exp;
branches;
next	1.4;
commitid	LnErp1MFKSuew5Fr;

1.4
date	2014.11.17.20.57.08;	author afresh1;	state Exp;
branches;
next	1.3;
commitid	QP75iYx42Uo7mMxO;

1.3
date	2014.03.24.15.05.33;	author afresh1;	state Exp;
branches;
next	1.2;

1.2
date	2013.03.25.20.41.00;	author sthen;	state Exp;
branches;
next	1.1;

1.1
date	2008.09.29.17.19.03;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2008.09.29.17.19.03;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2010.09.24.14.49.16;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.03.24.14.59.11;	author afresh1;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!perl -w

BEGIN {
    chdir 't' if -d 't';
    @@INC = '../lib';
    require Config; import Config;
    require './test.pl';
    require './charset_tools.pl';
    require './loc_tools.pl';
}

plan(tests => 215);

package UTF8Toggle;
use strict;

use overload '""' => 'stringify', fallback => 1;

sub new {
    my $class = shift;
    my $value = shift;
    my $state = shift||0;
    return bless [$value, $state], $class;
}

sub stringify {
    my $self = shift;
    $self->[1] = ! $self->[1];
    if ($self->[1]) {
	utf8::downgrade($self->[0]);
    } else {
	utf8::upgrade($self->[0]);
    }
    $self->[0];
}

package main;

# These tests are based on characters 128-255 not having latin1, and hence
# Unicode, semantics
# no feature "unicode_strings";

# Bug 34297
foreach my $t ("ASCII", "B" . uni_to_native("\366") . "se") {
    my $length = length $t;

    my $u = UTF8Toggle->new($t);
    is (length $u, $length, "length of '$t'");
    is (length $u, $length, "length of '$t'");
    is (length $u, $length, "length of '$t'");
    is (length $u, $length, "length of '$t'");
}

my $E_acute = uni_to_native("\311");
my $e_acute = uni_to_native("\351");
my $u = UTF8Toggle->new($E_acute);
my $lc = lc $u;
is (length $lc, 1);
is ($lc, $E_acute, "E acute -> e acute");
$lc = lc $u;
is (length $lc, 1);
is ($lc, $e_acute, "E acute -> e acute");
$lc = lc $u;
is (length $lc, 1);
is ($lc, $E_acute, "E acute -> e acute");

$u = UTF8Toggle->new($e_acute);
my $uc = uc $u;
is (length $uc, 1);
is ($uc, $e_acute, "e acute -> E acute");
$uc = uc $u;
is (length $uc, 1);
is ($uc, $E_acute, "e acute -> E acute");
$uc = uc $u;
is (length $uc, 1);
is ($uc, $e_acute, "e acute -> E acute");

$u = UTF8Toggle->new($E_acute);
$lc = lcfirst $u;
is (length $lc, 1);
is ($lc, $E_acute, "E acute -> e acute");
$lc = lcfirst $u;
is (length $lc, 1);
is ($lc, $e_acute, "E acute -> e acute");
$lc = lcfirst $u;
is (length $lc, 1);
is ($lc, $E_acute, "E acute -> e acute");

$u = UTF8Toggle->new($e_acute);
$uc = ucfirst $u;
is (length $uc, 1);
is ($uc, $e_acute, "e acute -> E acute");
$uc = ucfirst $u;
is (length $uc, 1);
is ($uc, $E_acute, "e acute -> E acute");
$uc = ucfirst $u;
is (length $uc, 1);
is ($uc, $e_acute, "e acute -> E acute");

my $have_setlocale = locales_enabled('LC_ALL');

SKIP: {
    if (!$have_setlocale) {
	skip "No setlocale", 24;
    } elsif (!setlocale(&POSIX::LC_ALL, "en_GB.ISO8859-1")) {
	skip "Could not setlocale to en_GB.ISO8859-1", 24;
    } elsif ($^O eq 'dec_osf' || $^O eq 'VMS') {
	skip "$^O has broken en_GB.ISO8859-1 locale", 24;
    } else {
        use locale;
	my $u = UTF8Toggle->new($E_acute);
	my $lc = lc $u;
	is (length $lc, 1);
	is ($lc, $e_acute, "E acute -> e acute");
	$lc = lc $u;
	is (length $lc, 1);
	is ($lc, $e_acute, "E acute -> e acute");
	$lc = lc $u;
	is (length $lc, 1);
	is ($lc, $e_acute, "E acute -> e acute");

	$u = UTF8Toggle->new($e_acute);
	my $uc = uc $u;
	is (length $uc, 1);
	is ($uc, $E_acute, "e acute -> E acute");
	$uc = uc $u;
	is (length $uc, 1);
	is ($uc, $E_acute, "e acute -> E acute");
	$uc = uc $u;
	is (length $uc, 1);
	is ($uc, $E_acute, "e acute -> E acute");

	$u = UTF8Toggle->new($E_acute);
	$lc = lcfirst $u;
	is (length $lc, 1);
	is ($lc, $e_acute, "E acute -> e acute");
	$lc = lcfirst $u;
	is (length $lc, 1);
	is ($lc, $e_acute, "E acute -> e acute");
	$lc = lcfirst $u;
	is (length $lc, 1);
	is ($lc, $e_acute, "E acute -> e acute");

	$u = UTF8Toggle->new($e_acute);
	$uc = ucfirst $u;
	is (length $uc, 1);
	is ($uc, $E_acute, "e acute -> E acute");
	$uc = ucfirst $u;
	is (length $uc, 1);
	is ($uc, $E_acute, "e acute -> E acute");
	$uc = ucfirst $u;
	is (length $uc, 1);
	is ($uc, $E_acute, "e acute -> E acute");
    }
}

my $tmpfile = tempfile();

foreach my $operator ('print', 'syswrite', 'syswrite len', 'syswrite off',
		      'syswrite len off') {
    foreach my $layer ('', ':utf8') {
	open my $fh, "+>$layer", $tmpfile or die $!;
	my $pad = $operator =~ /\boff\b/ ? "\243" : "";
	my $trail = $operator =~ /\blen\b/ ? "!" : "";
	my $u = UTF8Toggle->new("$pad$E_acute\n$trail");
	my $l = UTF8Toggle->new("$pad$e_acute\n$trail", 1);
        no warnings 'deprecated';
	if ($operator eq 'print') {
	    no warnings 'utf8';
	    print $fh $u;
	    print $fh $u;
	    print $fh $u;
	    print $fh $l;
	    print $fh $l;
	    print $fh $l;
	} elsif ($operator eq 'syswrite') {
	    syswrite $fh, $u;
	    syswrite $fh, $u;
	    syswrite $fh, $u;
	    syswrite $fh, $l;
	    syswrite $fh, $l;
	    syswrite $fh, $l;
	} elsif ($operator eq 'syswrite len') {
	    syswrite $fh, $u, 2;
	    syswrite $fh, $u, 2;
	    syswrite $fh, $u, 2;
	    syswrite $fh, $l, 2;
	    syswrite $fh, $l, 2;
	    syswrite $fh, $l, 2;
	} elsif ($operator eq 'syswrite off'
		 || $operator eq 'syswrite len off') {
	    syswrite $fh, $u, 2, 1;
	    syswrite $fh, $u, 2, 1;
	    syswrite $fh, $u, 2, 1;
	    syswrite $fh, $l, 2, 1;
	    syswrite $fh, $l, 2, 1;
	    syswrite $fh, $l, 2, 1;
	} else {
	    die $operator;
	}

	seek $fh, 0, 0 or die $!;
	my $line;
	chomp ($line = <$fh>);
	is ($line, $E_acute, "$operator $layer");
	chomp ($line = <$fh>);
	is ($line, $E_acute, "$operator $layer");
	chomp ($line = <$fh>);
	is ($line, $E_acute, "$operator $layer");
	chomp ($line = <$fh>);
	is ($line, $e_acute, "$operator $layer");
	chomp ($line = <$fh>);
	is ($line, $e_acute, "$operator $layer");
	chomp ($line = <$fh>);
	is ($line, $e_acute, "$operator $layer");

	close $fh or die $!;
    }
}

my $little = "\243\243";
my $big = " \243 $little ! $little ! $little \243 ";
my $right = rindex $big, $little;
my $right1 = rindex $big, $little, 11;
my $left = index $big, $little;
my $left1 = index $big, $little, 4;

cmp_ok ($right, ">", $right1, "Sanity check our rindex tests");
cmp_ok ($left, "<", $left1, "Sanity check our index tests");

foreach my $b ($big, UTF8Toggle->new($big)) {
    foreach my $l ($little, UTF8Toggle->new($little),
		   UTF8Toggle->new($little, 1)) {
	is (rindex ($b, $l), $right, "rindex");
	is (rindex ($b, $l), $right, "rindex");
	is (rindex ($b, $l), $right, "rindex");

	is (rindex ($b, $l, 11), $right1, "rindex 11");
	is (rindex ($b, $l, 11), $right1, "rindex 11");
	is (rindex ($b, $l, 11), $right1, "rindex 11");

	is (index ($b, $l), $left, "index");
	is (index ($b, $l), $left, "index");
	is (index ($b, $l), $left, "index");

	is (index ($b, $l, 4), $left1, "index 4");
	is (index ($b, $l, 4), $left1, "index 4");
	is (index ($b, $l, 4), $left1, "index 4");
    }
}

my $bits = $E_acute;
foreach my $pieces ($bits, UTF8Toggle->new($bits)) {
    like ($bits ^ $pieces, qr/\A\0+\z/, "something xor itself is zeros");
    like ($bits ^ $pieces, qr/\A\0+\z/, "something xor itself is zeros");
    like ($bits ^ $pieces, qr/\A\0+\z/, "something xor itself is zeros");

    like ($pieces ^ $bits, qr/\A\0+\z/, "something xor itself is zeros");
    like ($pieces ^ $bits, qr/\A\0+\z/, "something xor itself is zeros");
    like ($pieces ^ $bits, qr/\A\0+\z/, "something xor itself is zeros");
}

foreach my $value ("\243", UTF8Toggle->new("\243")) {
    is (pack ("A/A", $value), pack ("A/A", "\243"),
	"pack copes with overloading");
    is (pack ("A/A", $value), pack ("A/A", "\243"));
    is (pack ("A/A", $value), pack ("A/A", "\243"));
}

foreach my $value ("\243", UTF8Toggle->new("\243")) {
    my $v;
    $v = substr $value, 0, 1;
    is ($v, "\243");
    $v = substr $value, 0, 1;
    is ($v, "\243");
    $v = substr $value, 0, 1;
    is ($v, "\243");
}

{
    package RT69422;
    use overload '""' => sub { $_[0]->{data} }
}

{
    my $text = bless { data => "\x{3075}" }, 'RT69422';
    my $p = substr $text, 0, 1;
    is ($p, "\x{3075}");
}
@


1.7
log
@Apply local patches, remove excess files - perl-5.20.2
@
text
@d4 1
a4 1
    chdir 't';
d8 2
d44 1
a44 1
foreach my $t ("ASCII", "B\366se") {
d54 3
a56 1
my $u = UTF8Toggle->new("\311");
d59 1
a59 1
is ($lc, "\311", "E acute -> e acute");
d62 1
a62 1
is ($lc, "\351", "E acute -> e acute");
d65 1
a65 1
is ($lc, "\311", "E acute -> e acute");
d67 1
a67 1
$u = UTF8Toggle->new("\351");
d70 1
a70 1
is ($uc, "\351", "e acute -> E acute");
d73 1
a73 1
is ($uc, "\311", "e acute -> E acute");
d76 1
a76 1
is ($uc, "\351", "e acute -> E acute");
d78 1
a78 1
$u = UTF8Toggle->new("\311");
d81 1
a81 1
is ($lc, "\311", "E acute -> e acute");
d84 1
a84 1
is ($lc, "\351", "E acute -> e acute");
d87 1
a87 1
is ($lc, "\311", "E acute -> e acute");
d89 1
a89 1
$u = UTF8Toggle->new("\351");
d92 1
a92 1
is ($uc, "\351", "e acute -> E acute");
d95 1
a95 1
is ($uc, "\311", "e acute -> E acute");
d98 1
a98 1
is ($uc, "\351", "e acute -> E acute");
d100 1
a100 14
my $have_setlocale = 0;
eval {
    require POSIX;
    if($Config{d_setlocale}) {
        import POSIX ':locale_h';
        $have_setlocale++;
    }
};
if (
    !$Config::Config{d_setlocale}
  || $Config::Config{ccflags} =~ /\bD?NO_LOCALE(_|\b)/
) {
    $have_setlocale = 0;
}
d110 2
a111 6
        BEGIN {
            if($Config{d_setlocale}) {
                require locale; import locale;
            }
        }
	my $u = UTF8Toggle->new("\311");
d114 1
a114 1
	is ($lc, "\351", "E acute -> e acute");
d117 1
a117 1
	is ($lc, "\351", "E acute -> e acute");
d120 1
a120 1
	is ($lc, "\351", "E acute -> e acute");
d122 1
a122 1
	$u = UTF8Toggle->new("\351");
d125 1
a125 1
	is ($uc, "\311", "e acute -> E acute");
d128 1
a128 1
	is ($uc, "\311", "e acute -> E acute");
d131 1
a131 1
	is ($uc, "\311", "e acute -> E acute");
d133 1
a133 1
	$u = UTF8Toggle->new("\311");
d136 1
a136 1
	is ($lc, "\351", "E acute -> e acute");
d139 1
a139 1
	is ($lc, "\351", "E acute -> e acute");
d142 1
a142 1
	is ($lc, "\351", "E acute -> e acute");
d144 1
a144 1
	$u = UTF8Toggle->new("\351");
d147 1
a147 1
	is ($uc, "\311", "e acute -> E acute");
d150 1
a150 1
	is ($uc, "\311", "e acute -> E acute");
d153 1
a153 1
	is ($uc, "\311", "e acute -> E acute");
d165 3
a167 2
	my $u = UTF8Toggle->new("$pad\311\n$trail");
	my $l = UTF8Toggle->new("$pad\351\n$trail", 1);
d205 1
a205 1
	is ($line, "\311", "$operator $layer");
d207 1
a207 1
	is ($line, "\311", "$operator $layer");
d209 1
a209 1
	is ($line, "\311", "$operator $layer");
d211 1
a211 1
	is ($line, "\351", "$operator $layer");
d213 1
a213 1
	is ($line, "\351", "$operator $layer");
d215 1
a215 1
	is ($line, "\351", "$operator $layer");
d252 1
a252 1
my $bits = "\311";
@


1.6
log
@Fix merge issues, remove excess files - match perl-5.20.2 dist
@
text
@d104 6
@


1.5
log
@Apply local patches to perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@a103 6
if (
    !$Config::Config{d_setlocale}
  || $Config::Config{ccflags} =~ /\bD?NO_LOCALE(_|\b)/
) {
    $have_setlocale = 0;
}
@


1.4
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d104 6
@


1.3
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@a103 6
if (
    !$Config::Config{d_setlocale}
  || $Config::Config{ccflags} =~ /\bD?NO_LOCALE(_|\b)/
) {
    $have_setlocale = 0;
}
@


1.2
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d6 1
d99 4
a102 2
    import POSIX ':locale_h';
    $have_setlocale++;
d119 5
a123 1
	use locale;
@


1.1
log
@Initial revision
@
text
@d4 3
a6 4
    if ($ENV{'PERL_CORE'}){
        chdir 't';
        @@INC = '../lib';
    }
d9 1
a9 1
use Test::More tests => 208;
d36 4
d101 6
d163 1
a163 1
my $tmpfile = 'overload.tmp';
a222 1
	unlink $tmpfile or die $!;
d275 19
a293 2
END {
    1 while -f $tmpfile and unlink $tmpfile || die "unlink '$tmpfile': $!";
@


1.1.1.1
log
@import perl 5.10.0 from CPAN
@
text
@@


1.1.1.2
log
@Perl 5.12.2 from CPAN
@
text
@d4 4
a7 3
    chdir 't';
    @@INC = '../lib';
    require './test.pl';
d10 1
a10 1
plan(tests => 215);
a36 4
# These tests are based on characters 128-255 not having latin1, and hence
# Unicode, semantics
# no feature "unicode_strings";

d154 1
a154 1
my $tmpfile = tempfile();
d214 1
d267 2
a268 19
foreach my $value ("\243", UTF8Toggle->new("\243")) {
    my $v;
    $v = substr $value, 0, 1;
    is ($v, "\243");
    $v = substr $value, 0, 1;
    is ($v, "\243");
    $v = substr $value, 0, 1;
    is ($v, "\243");
}

{
    package RT69422;
    use overload '""' => sub { $_[0]->{data} }
}

{
    my $text = bless { data => "\x{3075}" }, 'RT69422';
    my $p = substr $text, 0, 1;
    is ($p, "\x{3075}");
@


1.1.1.3
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@a5 1
    require Config; import Config;
d98 2
a99 4
    if($Config{d_setlocale}) {
        import POSIX ':locale_h';
        $have_setlocale++;
    }
d110 1
a110 5
        BEGIN {
            if($Config{d_setlocale}) {
                require locale; import locale;
            }
        }
@


