head	1.2;
access;
symbols
	OPENBSD_6_2:1.2.0.2
	OPENBSD_6_2_BASE:1.2
	PERL_5_24_2:1.1.1.7
	OPENBSD_6_1:1.2.0.4
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.6.0.12
	OPENBSD_6_0_BASE:1.1.1.6
	OPENBSD_5_9:1.1.1.6.0.6
	OPENBSD_5_9_BASE:1.1.1.6
	OPENBSD_5_8:1.1.1.6.0.8
	OPENBSD_5_8_BASE:1.1.1.6
	PERL_5_20_2:1.1.1.6
	OPENBSD_5_7:1.1.1.6.0.2
	OPENBSD_5_7_BASE:1.1.1.6
	PERL_5_20_1:1.1.1.6
	OPENBSD_5_6:1.1.1.6.0.4
	OPENBSD_5_6_BASE:1.1.1.6
	PERL_5_18_2:1.1.1.6
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.5.0.6
	OPENBSD_5_5_BASE:1.1.1.5
	OPENBSD_5_4:1.1.1.5.0.2
	OPENBSD_5_4_BASE:1.1.1.5
	PERL_5_16_3:1.1.1.5
	OPENBSD_5_3:1.1.1.4.0.18
	OPENBSD_5_3_BASE:1.1.1.4
	OPENBSD_5_2:1.1.1.4.0.16
	OPENBSD_5_2_BASE:1.1.1.4
	OPENBSD_5_1_BASE:1.1.1.4
	OPENBSD_5_1:1.1.1.4.0.14
	OPENBSD_5_0:1.1.1.4.0.12
	OPENBSD_5_0_BASE:1.1.1.4
	OPENBSD_4_9:1.1.1.4.0.10
	OPENBSD_4_9_BASE:1.1.1.4
	PERL_5_12_2:1.1.1.4
	OPENBSD_4_8:1.1.1.4.0.8
	OPENBSD_4_8_BASE:1.1.1.4
	OPENBSD_4_7:1.1.1.4.0.4
	OPENBSD_4_7_BASE:1.1.1.4
	PERL_5_10_1:1.1.1.4
	OPENBSD_4_6:1.1.1.4.0.6
	OPENBSD_4_6_BASE:1.1.1.4
	OPENBSD_4_5:1.1.1.4.0.2
	OPENBSD_4_5_BASE:1.1.1.4
	PERL_5_10_0:1.1.1.4
	OPENBSD_4_4:1.1.1.3.0.10
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.8
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_2:1.1.1.3.0.6
	OPENBSD_4_2_BASE:1.1.1.3
	OPENBSD_4_1:1.1.1.3.0.4
	OPENBSD_4_1_BASE:1.1.1.3
	OPENBSD_4_0:1.1.1.3.0.2
	OPENBSD_4_0_BASE:1.1.1.3
	PERL_5_8_8:1.1.1.3
	OPENBSD_3_9:1.1.1.2.0.8
	OPENBSD_3_9_BASE:1.1.1.2
	OPENBSD_3_8:1.1.1.2.0.6
	OPENBSD_3_8_BASE:1.1.1.2
	OPENBSD_3_7:1.1.1.2.0.4
	OPENBSD_3_7_BASE:1.1.1.2
	PERL_5_8_6:1.1.1.2
	OPENBSD_3_6:1.1.1.2.0.2
	OPENBSD_3_6_BASE:1.1.1.2
	PERL_5_8_5:1.1.1.2
	PERL_5_8_3:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.6
	OPENBSD_3_5_BASE:1.1.1.1
	PERL_5_8_2:1.1.1.1
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	PERL_5_8_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.32.21;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2002.10.27.22.15.11;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.27.22.15.11;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.08.09.17.48.37;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2006.03.28.18.49.48;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2008.09.29.17.19.03;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.03.25.20.09.38;	author sthen;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2014.03.24.14.59.11;	author afresh1;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2017.08.14.13.46.25;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@BEGIN {
    require "test.pl";
    set_up_inc(qw(../lib .));
    skip_all_without_unicode_tables();
}
use strict;
use warnings;
use feature 'unicode_strings';

sub unidump {
    join "", map { sprintf "\\x{%04X}", $_ } unpack "W*", $_[0];
}

sub casetest {
    my ($already_run, $base, %funcs) = @@_;

    my %spec;

    # For each provided function run it, and run a version with some extra
    # characters afterwards. Use a recycling symbol, as it doesn't change case.
    # $already_run is the number of extra tests the caller has run before this
    # call.
    my $ballast = chr (0x2672) x 3;
    foreach my $name (keys %funcs) {
        $funcs{"${name}_with_ballast"} =
		   sub {my $r = $funcs{$name}->($_[0] . $ballast); # Add it before
			$r =~ s/$ballast\z//so # Remove it afterwards
			    or die "'$_[0]' to '$r' mangled";
			$r; # Result with $ballast removed.
		    };
    }

    use Unicode::UCD 'prop_invmap';

    # Get the case mappings
    my ($invlist_ref, $invmap_ref, undef, $default) = prop_invmap($base);
    my %simple;

    for my $i (0 .. @@$invlist_ref - 1 - 1) {
        next if $invmap_ref->[$i] == $default;

        # Add simple mappings to the simples test list
        if (! ref $invmap_ref->[$i]) {

            # The returned map needs to have adjustments made.  Each
            # subsequent element of the range requires adjustment of +1 from
            # the previous element
            my $adjust = 0;
            for my $k ($invlist_ref->[$i] .. $invlist_ref->[$i+1] - 1) {
                $simple{$k} = $invmap_ref->[$i] + $adjust++;
            }
        }
        else {  # The return is a list of the characters mapped-to.
                # prop_invmap() guarantees a single element in the range in
                # this case, so no adjustments are needed.
            $spec{$invlist_ref->[$i]} = pack "W*" , @@{$invmap_ref->[$i]};
        }
    }

    my %seen;

    for my $i (sort keys %simple) {
	$seen{$i}++;
    }
    print "# ", scalar keys %simple, " simple mappings\n";

    for my $i (sort keys %spec) {
	if (++$seen{$i} == 2) {
	    warn sprintf "$base: $i seen twice\n";
	}
    }
    print "# ", scalar keys %spec, " special mappings\n";

    my %none;
    for my $i (map { ord } split //,
	       "\e !\"#\$%&'()+,-./0123456789:;<=>?\@@[\\]^_{|}~\b") {
	next if pack("W", $i) =~ /\w/;
	$none{$i}++ unless $seen{$i};
    }
    print "# ", scalar keys %none, " noncase mappings\n";


    my $test = $already_run + 1;

    for my $ord (sort { $a <=> $b } keys %simple) {
	my $char = pack "W", $ord;
        my $disp_input = unidump($char);

        my $expected = pack("W", $simple{$ord});
        my $disp_expected = unidump($expected);

	foreach my $name (sort keys %funcs) {
	    my $got = $funcs{$name}->($char);
	    is( $got, $expected,
               "Verify $name(\"$disp_input\") eq \"$disp_expected\"");
	}
    }

    for my $ord (sort { $a <=> $b } keys %spec) {
	my $char = pack "W", $ord;
        my $disp_input = unidump($char);

	my $expected = unidump($spec{$ord});

	foreach my $name (sort keys %funcs) {
	    my $got = $funcs{$name}->($char);
            is( unidump($got), $expected,
               "Verify $name(\"$disp_input\") eq \"$expected\"");
	}
    }

    for my $ord (sort { $a <=> $b } keys %none) {
	my $char = pack "W", $ord;
        my $disp_input = unidump($char);

	foreach my $name (sort keys %funcs) {
	    my $got = $funcs{$name}->($char);
            is( $got, $char,
               "Verify $name(\"$disp_input\") eq \"$disp_input\"");
	}
    }

    plan $already_run +
	((scalar keys %simple) +
	 (scalar keys %spec) +
	 (scalar keys %none)) * scalar keys %funcs;
}

1;
@


1.1
log
@Initial revision
@
text
@d1 8
a8 3
use File::Spec;

require "test.pl";
d11 1
a11 1
    join " ", map { sprintf "%04X", $_ } unpack "U*", $_[0];
d15 22
a36 5
    my ($base, $spec, $func) = @@_;
    my $file = File::Spec->catfile(File::Spec->catdir(File::Spec->updir,
						      "lib", "unicore", "To"),
				   "$base.pl");
    my $simple = do $file;
d38 20
a57 3
    for my $i (split(/\n/, $simple)) {
	my ($k, $v) = split(' ', $i);
	$simple{$k} = $v;
d59 1
d63 1
a63 1
	$seen{hex $i}++;
d67 3
a69 6
    my $both;

    for my $i (sort keys %$spec) {
	if (++$seen{hex $i} == 2) {
	    warn "$base: $i seen twice\n";
	    $both++;
d72 1
a72 3
    print "# ", scalar keys %$spec, " special mappings\n";

    exit(1) if $both;
d77 1
a77 1
	next if pack("U0U", $i) =~ /\w/;
d82 14
a95 70
    my $tests = 
	(scalar keys %simple) +
	(scalar keys %$spec) +
	(scalar keys %none);
    print "1..$tests\n";

    my $test = 1;

    for my $i (sort { hex $a <=> hex $b } keys %simple) {
	my $w = $simple{$i};
	my $c = pack "U0U", hex $i;
	my $d = $func->($c);
	my $e = unidump($d);
	print $d eq pack("U0U", hex $simple{$i}) ?
	    "ok $test # $i -> $w\n" : "not ok $test # $i -> $e ($w)\n";
	$test++;
    }

    for my $i (sort { hex $a <=> hex $b } keys %$spec) {
	my $w = unidump($spec->{$i});
	my $c = pack "U0U", hex $i;
	my $d = $func->($c);
	my $e = unidump($d);
	if (ord "A" == 193) { # EBCDIC
	    # We need to a little bit of remapping.
	    #
	    # For example, in titlecase (ucfirst) mapping
	    # of U+0149 the Unicode mapping is U+02BC U+004E.
	    # The 4E is N, which in EBCDIC is 2B--
	    # and the ucfirst() does that right.
	    # The problem is that our reference
	    # data is in Unicode code points.
	    #
	    # The Right Way here would be to use, say,
	    # Encode, to remap the less-than 0x100 code points,
	    # but let's try to be Encode-independent here. 
	    #
	    # These are the titlecase exceptions:
	    #
	    #         Unicode   Unicode+EBCDIC  
	    #
	    # 0149 -> 02BC 004E (02BC 002B)
	    # 01F0 -> 004A 030C (00A2 030C)
	    # 1E96 -> 0048 0331 (00E7 0331)
	    # 1E97 -> 0054 0308 (00E8 0308)
	    # 1E98 -> 0057 030A (00EF 030A)
	    # 1E99 -> 0059 030A (00DF 030A)
	    # 1E9A -> 0041 02BE (00A0 02BE)
	    #
	    # The uppercase exceptions are identical.
	    #
	    # The lowercase has one more:
	    #
	    #         Unicode   Unicode+EBCDIC  
	    #
	    # 0130 -> 0069 0307 (00D1 0307)
	    #
	    if ($i =~ /^(0130|0149|01F0|1E96|1E97|1E98|1E99|1E9A)$/) {
		$e =~ s/004E/002B/; # N
		$e =~ s/004A/00A2/; # J
		$e =~ s/0048/00E7/; # H
		$e =~ s/0054/00E8/; # T
		$e =~ s/0057/00EF/; # W
		$e =~ s/0059/00DF/; # Y
		$e =~ s/0041/00A0/; # A
		$e =~ s/0069/00D1/; # i
	    }
	    # We have to map the output, not the input, because
	    # pack/unpack U has been EBCDICified, too, it would
	    # just undo our remapping.
a96 3
	print $w eq $e ?
	    "ok $test # $i -> $w\n" : "not ok $test # $i -> $e ($w)\n";
	$test++;
d99 11
a109 8
    for my $i (sort { $a <=> $b } keys %none) {
	my $w = $i = sprintf "%04X", $i;
	my $c = pack "U0U", hex $i;
	my $d = $func->($c);
	my $e = unidump($d);
	print $d eq $c ?
	    "ok $test # $i -> $w\n" : "not ok $test # $i -> $e ($w)\n";
	$test++;
d111 16
@


1.1.1.1
log
@stock perl 5.8.0 from CPAN
@
text
@@


1.1.1.2
log
@Import of stock perl 5.8.5
@
text
@d23 1
a23 1
	$seen{$i}++;
d30 2
a31 2
	if (++$seen{$i} == 2) {
	    warn sprintf "$base: $i seen twice\n";
d55 1
a55 1
    for my $i (sort keys %simple) {
d65 1
a65 1
    for my $i (sort keys %$spec) {
d67 1
a67 3
	my $u = unpack "U0U", $i;
	my $h = sprintf "%04X", $u;
	my $c = chr($u); $c .= chr(0x100); chop $c;
d119 1
a119 1
	    "ok $test # $i -> $w\n" : "not ok $test # $h -> $e ($w)\n";
@


1.1.1.3
log
@perl 5.8.8 import
@
text
@d10 1
a10 13
    my ($base, $spec, @@funcs) = @@_;
    # For each provided function run it, and run a version with some extra
    # characters afterwards. Use a recylcing symbol, as it doesn't change case.
    my $ballast = chr (0x2672) x 3;
    @@funcs = map {my $f = $_;
		  ($f,
		   sub {my $r = $f->($_[0] . $ballast); # Add it before
			$r =~ s/$ballast\z//so # Remove it afterwards
			    or die "'$_[0]' to '$r' mangled";
			$r; # Result with $ballast removed.
		    },
		   )} @@funcs;

d48 3
a50 3
	((scalar keys %simple) +
	 (scalar keys %$spec) +
	 (scalar keys %none)) * @@funcs;
d58 5
a62 7
	foreach my $func (@@funcs) {
	    my $d = $func->($c);
	    my $e = unidump($d);
	    print $d eq pack("U0U", hex $simple{$i}) ?
		"ok $test # $i -> $w\n" : "not ok $test # $i -> $e ($w)\n";
		$test++;
	}
d70 45
a114 50
	foreach my $func (@@funcs) {
	    my $d = $func->($c);
	    my $e = unidump($d);
	    if (ord "A" == 193) { # EBCDIC
		# We need to a little bit of remapping.
		#
		# For example, in titlecase (ucfirst) mapping
		# of U+0149 the Unicode mapping is U+02BC U+004E.
		# The 4E is N, which in EBCDIC is 2B--
		# and the ucfirst() does that right.
		# The problem is that our reference
		# data is in Unicode code points.
		#
		# The Right Way here would be to use, say,
		# Encode, to remap the less-than 0x100 code points,
		# but let's try to be Encode-independent here. 
		#
		# These are the titlecase exceptions:
		#
		#         Unicode   Unicode+EBCDIC  
		#
		# 0149 -> 02BC 004E (02BC 002B)
		# 01F0 -> 004A 030C (00A2 030C)
		# 1E96 -> 0048 0331 (00E7 0331)
		# 1E97 -> 0054 0308 (00E8 0308)
		# 1E98 -> 0057 030A (00EF 030A)
		# 1E99 -> 0059 030A (00DF 030A)
		# 1E9A -> 0041 02BE (00A0 02BE)
		#
		# The uppercase exceptions are identical.
		#
		# The lowercase has one more:
		#
		#         Unicode   Unicode+EBCDIC  
		#
		# 0130 -> 0069 0307 (00D1 0307)
		#
		if ($i =~ /^(0130|0149|01F0|1E96|1E97|1E98|1E99|1E9A)$/) {
		    $e =~ s/004E/002B/; # N
		    $e =~ s/004A/00A2/; # J
		    $e =~ s/0048/00E7/; # H
		    $e =~ s/0054/00E8/; # T
		    $e =~ s/0057/00EF/; # W
		    $e =~ s/0059/00DF/; # Y
		    $e =~ s/0041/00A0/; # A
		    $e =~ s/0069/00D1/; # i
		}
		# We have to map the output, not the input, because
		# pack/unpack U has been EBCDICified, too, it would
		# just undo our remapping.
d116 3
a118 3
	    print $w eq $e ?
		"ok $test # $i -> $w\n" : "not ok $test # $h -> $e ($w)\n";
		$test++;
d120 3
d128 5
a132 7
	foreach my $func (@@funcs) {
	    my $d = $func->($c);
	    my $e = unidump($d);
	    print $d eq $c ?
		"ok $test # $i -> $w\n" : "not ok $test # $i -> $e ($w)\n";
		$test++;
	}
@


1.1.1.4
log
@import perl 5.10.0 from CPAN
@
text
@d12 1
a12 1
    # characters afterwards. Use a recycling symbol, as it doesn't change case.
d26 1
a26 1
    my $simple = do $file or die $@@;
d81 1
a81 4
	if (ord('A') == 193 && $i eq "\x8A\x73") {
	    $w = '0178'; # It's a Latin small Y with diaeresis and not a Latin small letter sharp 's'.
	}
	my $u = unpack "C0U", $i;
d121 1
a121 1
		if ($h =~ /^(0130|0149|01F0|1E96|1E97|1E98|1E99|1E9A)$/) {
@


1.1.1.5
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d1 2
d10 1
a10 1
    my ($already_run, $base, $spec, @@funcs) = @@_;
a12 2
    # $already_run is the number of extra tests the caller has run before this
    # call.
d23 3
a25 1
    my $file = "../lib/unicore/To/$base.pl";
d30 1
a30 6

        # Add the simple mapping to the simples test list, except the input
        # may include code points that the specials override, so don't add
        # those to the test list.  The specials keys are the code points,
        # encoded in utf8,, but without the utf8 flag on, so pack with C0.
	$simple{$k} = $v unless exists $spec->{pack("C0U", hex $k)};
a59 1
        $already_run +
d63 1
d65 1
a65 1
    my $test = $already_run + 1;
a154 2

    print "1..$tests\n";
@


1.1.1.6
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@a1 2
use strict;
use warnings;
d8 1
a8 4
    my ($already_run, $base, @@funcs) = @@_;

    my %spec;

d23 2
a24 4
    use Unicode::UCD 'prop_invmap';

    # Get the case mappings
    my ($invlist_ref, $invmap_ref, undef, $default) = prop_invmap($base);
d26 2
d29 5
a33 19
    for my $i (0 .. @@$invlist_ref - 1 - 1) {
        next if $invmap_ref->[$i] == $default;

        # Add simple mappings to the simples test list
        if (! ref $invmap_ref->[$i]) {

            # The returned map needs to have adjustments made.  Each
            # subsequent element of the range requires adjustment of +1 from
            # the previous element
            my $adjust = 0;
            for my $k ($invlist_ref->[$i] .. $invlist_ref->[$i+1] - 1) {
                $simple{$k} = $invmap_ref->[$i] + $adjust++;
            }
        }
        else {  # The return is a list of the characters mapped-to.
                # prop_invmap() guarantees a single element in the range in
                # this case, so no adjustments are needed.
            $spec{$invlist_ref->[$i]} = pack "U0U*" , @@{$invmap_ref->[$i]};
        }
a34 1

d42 3
a44 1
    for my $i (sort keys %spec) {
d47 1
d50 3
a52 1
    print "# ", scalar keys %spec, " special mappings\n";
d65 1
a65 1
	 (scalar keys %spec) +
d72 1
a72 1
	my $c = pack "U0U", $i;
d76 3
a78 1
	    is( $d, pack("U0U", $simple{$i}), "$i -> $e ($w)" );
d82 8
a89 4
    for my $i (sort keys %spec) {
	my $w = unidump($spec{$i});
	my $h = sprintf "%04X", $i;
	my $c = chr($i); $c .= chr(0x100); chop $c;
d93 51
a143 1
            is( $w, $e, "$h -> $e ($w)" );
a147 1
	my $c = pack "U0U", $i;
d149 1
d153 3
a155 1
            is( $d, $c, "$i -> $e ($w)" );
d159 1
a159 1
    done_testing();
@


1.1.1.7
log
@Import perl-5.24.2
@
text
@d1 1
a1 5
BEGIN {
    require "test.pl";
    set_up_inc(qw(../lib .));
    skip_all_without_unicode_tables();
}
a3 1
use feature 'unicode_strings';
d6 1
a6 1
    join "", map { sprintf "\\x{%04X}", $_ } unpack "W*", $_[0];
d10 1
a10 1
    my ($already_run, $base, %funcs) = @@_;
d19 3
a21 3
    foreach my $name (keys %funcs) {
        $funcs{"${name}_with_ballast"} =
		   sub {my $r = $funcs{$name}->($_[0] . $ballast); # Add it before
d25 2
a26 2
		    };
    }
d51 1
a51 1
            $spec{$invlist_ref->[$i]} = pack "W*" , @@{$invmap_ref->[$i]};
d72 1
a72 1
	next if pack("W", $i) =~ /\w/;
d77 5
d85 7
a91 11
    for my $ord (sort { $a <=> $b } keys %simple) {
	my $char = pack "W", $ord;
        my $disp_input = unidump($char);

        my $expected = pack("W", $simple{$ord});
        my $disp_expected = unidump($expected);

	foreach my $name (sort keys %funcs) {
	    my $got = $funcs{$name}->($char);
	    is( $got, $expected,
               "Verify $name(\"$disp_input\") eq \"$disp_expected\"");
d95 8
a102 10
    for my $ord (sort { $a <=> $b } keys %spec) {
	my $char = pack "W", $ord;
        my $disp_input = unidump($char);

	my $expected = unidump($spec{$ord});

	foreach my $name (sort keys %funcs) {
	    my $got = $funcs{$name}->($char);
            is( unidump($got), $expected,
               "Verify $name(\"$disp_input\") eq \"$expected\"");
d106 7
a112 8
    for my $ord (sort { $a <=> $b } keys %none) {
	my $char = pack "W", $ord;
        my $disp_input = unidump($char);

	foreach my $name (sort keys %funcs) {
	    my $got = $funcs{$name}->($char);
            is( $got, $char,
               "Verify $name(\"$disp_input\") eq \"$disp_input\"");
d116 1
a116 4
    plan $already_run +
	((scalar keys %simple) +
	 (scalar keys %spec) +
	 (scalar keys %none)) * scalar keys %funcs;
@


