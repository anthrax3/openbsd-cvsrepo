head	1.2;
access;
symbols
	PERL_5_24_2:1.1.1.5
	OPENBSD_6_1:1.2.0.4
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.4.0.10
	OPENBSD_6_0_BASE:1.1.1.4
	OPENBSD_5_9:1.1.1.4.0.4
	OPENBSD_5_9_BASE:1.1.1.4
	OPENBSD_5_8:1.1.1.4.0.6
	OPENBSD_5_8_BASE:1.1.1.4
	PERL_5_20_2:1.1.1.4
	OPENBSD_5_7:1.1.1.4.0.2
	OPENBSD_5_7_BASE:1.1.1.4
	PERL_5_20_1:1.1.1.4
	OPENBSD_5_6:1.1.1.3.0.8
	OPENBSD_5_6_BASE:1.1.1.3
	PERL_5_18_2:1.1.1.3
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.3.0.6
	OPENBSD_5_5_BASE:1.1.1.3
	OPENBSD_5_4:1.1.1.3.0.2
	OPENBSD_5_4_BASE:1.1.1.3
	PERL_5_16_3:1.1.1.3
	OPENBSD_5_3:1.1.1.2.0.10
	OPENBSD_5_3_BASE:1.1.1.2
	OPENBSD_5_2:1.1.1.2.0.8
	OPENBSD_5_2_BASE:1.1.1.2
	OPENBSD_5_1_BASE:1.1.1.2
	OPENBSD_5_1:1.1.1.2.0.6
	OPENBSD_5_0:1.1.1.2.0.4
	OPENBSD_5_0_BASE:1.1.1.2
	OPENBSD_4_9:1.1.1.2.0.2
	OPENBSD_4_9_BASE:1.1.1.2
	PERL_5_12_2:1.1.1.2
	OPENBSD_4_8:1.1.1.1.0.4
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.2
	OPENBSD_4_7_BASE:1.1.1.1
	PERL_5_10_1:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.32.21;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2009.10.12.18.10.42;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2009.10.12.18.10.42;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2010.09.24.14.49.16;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2013.03.25.20.09.38;	author sthen;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.11.17.20.53.19;	author afresh1;	state Exp;
branches;
next	1.1.1.5;
commitid	B31cAbBIXiCqnL97;

1.1.1.5
date	2017.08.14.13.46.25;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl -w
#
# This script is written intentionally in UTF-8

BEGIN {
    $| = 1;

    chdir 't' if -d 't';
    @@INC = '../lib';
    require './test.pl';
    require './charset_tools.pl';
    skip_all('no re module') unless defined &DynaLoader::boot_DynaLoader;
    skip_all_without_unicode_tables();
}

use strict;

plan (tests => 16);
use charnames ':full';

use utf8;

my $A_with_ogonek = "Ą";
my $micro_sign = "µ";
my $hex_first = "a\x{A2}Ą";
my $hex_last = "aĄ\x{A2}";
my $name_first = "b\N{MICRO SIGN}Ɓ";
my $name_last = "bƁ\N{MICRO SIGN}";
my $uname_first = "b\N{U+00B5}Ɓ";
my $uname_last = "bƁ\N{U+00B5}";
my $octal_first = "c\377Ć";
my $octal_last = "cĆ\377";

sub fixup (@@) {
    # @@_ is a list of strings.  Each string is comprised of the digits that
    # form a byte of the UTF-8 representation of a character, or sequence of
    # characters

    my $string = join "", map { chr 0 + $_ } @@_;
    $string = byte_utf8a_to_utf8n($string);

    # Return the concatenation of each byte of $string converted to a string of
    # its decimal ordinal value.  This is just the input array converted to
    # native, and joined together.
    return join "", map { sprintf "%d", ord $_ } split "", $string;
}

do {
	use bytes;
	is((join "", unpack("C*", $A_with_ogonek)), fixup("196", "132"), 'single char above 0x100');
	is((join "", unpack("C*", $micro_sign)), fixup("194", "181"), 'single char in 0x80 .. 0xFF');
        SKIP: {
            skip("ASCII-centric tests", 2) if $::IS_EBCDIC;
            is((join "", unpack("C*", $hex_first)), fixup("97", "194", "162", "196", "132"), 'a, \x{A2}, char above 0x100');
            is((join "", unpack("C*", $hex_last)), fixup("97", "196", "132", "194", "162"), 'a, char above 0x100, \x{A2}');
        }
	is((join "", unpack("C*", $name_first)), fixup("98", "194", "181", "198", "129"), 'b, \N{MICRO SIGN}, char above 0x100');
	is((join "", unpack("C*", $name_last)), fixup("98", "198", "129", "194", "181"), 'b, char above 0x100, \N{MICRO SIGN}');
	is((join "", unpack("C*", $uname_first)), fixup("98", "194", "181", "198", "129"), 'b, \N{U+00B5}, char above 0x100');
	is((join "", unpack("C*", $uname_last)), fixup("98", "198", "129", "194", "181"), 'b, char above 0x100, \N{U+00B5}');
        SKIP: {
            skip("ASCII-centric tests", 2) if $::IS_EBCDIC;
            is((join "", unpack("C*", $octal_first)), fixup("99", "195", "191", "196", "134"), 'c, \377, char above 0x100');
            is((join "", unpack("C*", $octal_last)), fixup("99", "196", "134", "195", "191"), 'c, char above 0x100, \377');
        }
};

{
    local $SIG{__WARN__} = sub {};
    eval "our $::\xe9; $\xe9";
    unlike $@@, qr/utf8_heavy/,
	'No utf8_heavy errors with our() syntax errors';
}

# [perl #120463]
$_ = "a";
eval 's αaαbα';
is $@@, "", 's/// compiles, where / is actually a wide character';
is $_, "b", 'substitution worked';
$_ = "a";
eval 'tr νaνbν';
is $@@, "", 'y/// compiles, where / is actually a wide character';
is $_, "b", 'transliteration worked';

SKIP: {
    skip("ASCII-centric test", 1) if $::IS_EBCDIC;
    use constant foofoo=>qq|\xc4\xb5|;
    { no strict; ()=${"\xc4\xb5::foo"} } # vivify Äµ package
    eval 'my foofoo $dog'; # foofoo was resolving to ĵ, not Äµ
    is $@@, '', 'my constant $var in utf8 scope where constant is not utf8';
}

__END__

@


1.1
log
@Initial revision
@
text
@d1 1
a5 4
    if (ord("A") == 193) {
        print "1..0 # Skip: EBCDIC\n";
        exit 0;
    }
d7 7
d18 1
a18 1
use Test::More tests => 10;
d34 14
d50 23
a72 10
	is((join "", unpack("C*", $A_with_ogonek)), "196" . "132", 'single char above 0x100');
	is((join "", unpack("C*", $micro_sign)), "194" . "181", 'single char in 0x80 .. 0xFF');
	is((join "", unpack("C*", $hex_first)), "97" . "194" . "162" . "196" . "132", 'a . \x{A2} . char above 0x100');
	is((join "", unpack("C*", $hex_last)), "97" . "196" . "132" . "194" . "162", 'a . char above 0x100 . \x{A2}');
	is((join "", unpack("C*", $name_first)), "98" . "194" . "181" . "198" . "129", 'b . \N{MICRO SIGN} . char above 0x100');
	is((join "", unpack("C*", $name_last)), "98" . "198" . "129" . "194" . "181", 'b . char above 0x100 . \N{MICRO SIGN}');
	is((join "", unpack("C*", $uname_first)), "98" . "194" . "181" . "198" . "129", 'b . \N{U+00B5} . char above 0x100');
	is((join "", unpack("C*", $uname_last)), "98" . "198" . "129" . "194" . "181", 'b . char above 0x100 . \N{U+00B5}');
	is((join "", unpack("C*", $octal_first)), "99" . "195" . "191" . "196" . "134", 'c . \377 . char above 0x100');
	is((join "", unpack("C*", $octal_last)), "99" . "196" . "134" . "195" . "191", 'c . char above 0x100 . \377');
d74 19
@


1.1.1.1
log
@import perl 5.10.1
@
text
@@


1.1.1.2
log
@Perl 5.12.2 from CPAN
@
text
@a0 1
#!./perl -w
a9 2

    require './test.pl';
d14 1
a14 1
plan (tests => 10);
@


1.1.1.3
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d6 4
a12 2
    skip_all_if_miniperl("no dynamic loading on miniperl, no re");
    skip_all('EBCDIC') if $::IS_EBCDIC;
d17 1
a17 1
plan (tests => 11);
a44 7
};

{
    local $SIG{__WARN__} = sub {};
    eval "our $::\xe9; $\xe9";
    unlike $@@, qr/utf8_heavy/,
	'No utf8_heavy errors with our() syntax errors';
@


1.1.1.4
log
@Import perl-5.20.1
@
text
@a7 2
    chdir 't';
    @@INC = '../lib';
d15 1
a15 1
plan (tests => 15);
a50 11

# [perl #120463]
$_ = "a";
eval 's αaαbα';
is $@@, "", 's/// compiles, where / is actually a wide character';
is $_, "b", 'substitution worked';
$_ = "a";
eval 'tr νaνbν';
is $@@, "", 'y/// compiles, where / is actually a wide character';
is $_, "b", 'transliteration worked';

@


1.1.1.5
log
@Import perl-5.24.2
@
text
@d8 1
a8 1
    chdir 't' if -d 't';
d11 2
a12 3
    require './charset_tools.pl';
    skip_all('no re module') unless defined &DynaLoader::boot_DynaLoader;
    skip_all_without_unicode_tables();
d17 1
a17 1
plan (tests => 16);
a32 14
sub fixup (@@) {
    # @@_ is a list of strings.  Each string is comprised of the digits that
    # form a byte of the UTF-8 representation of a character, or sequence of
    # characters

    my $string = join "", map { chr 0 + $_ } @@_;
    $string = byte_utf8a_to_utf8n($string);

    # Return the concatenation of each byte of $string converted to a string of
    # its decimal ordinal value.  This is just the input array converted to
    # native, and joined together.
    return join "", map { sprintf "%d", ord $_ } split "", $string;
}

d35 10
a44 16
	is((join "", unpack("C*", $A_with_ogonek)), fixup("196", "132"), 'single char above 0x100');
	is((join "", unpack("C*", $micro_sign)), fixup("194", "181"), 'single char in 0x80 .. 0xFF');
        SKIP: {
            skip("ASCII-centric tests", 2) if $::IS_EBCDIC;
            is((join "", unpack("C*", $hex_first)), fixup("97", "194", "162", "196", "132"), 'a, \x{A2}, char above 0x100');
            is((join "", unpack("C*", $hex_last)), fixup("97", "196", "132", "194", "162"), 'a, char above 0x100, \x{A2}');
        }
	is((join "", unpack("C*", $name_first)), fixup("98", "194", "181", "198", "129"), 'b, \N{MICRO SIGN}, char above 0x100');
	is((join "", unpack("C*", $name_last)), fixup("98", "198", "129", "194", "181"), 'b, char above 0x100, \N{MICRO SIGN}');
	is((join "", unpack("C*", $uname_first)), fixup("98", "194", "181", "198", "129"), 'b, \N{U+00B5}, char above 0x100');
	is((join "", unpack("C*", $uname_last)), fixup("98", "198", "129", "194", "181"), 'b, char above 0x100, \N{U+00B5}');
        SKIP: {
            skip("ASCII-centric tests", 2) if $::IS_EBCDIC;
            is((join "", unpack("C*", $octal_first)), fixup("99", "195", "191", "196", "134"), 'c, \377, char above 0x100');
            is((join "", unpack("C*", $octal_last)), fixup("99", "196", "134", "195", "191"), 'c, char above 0x100, \377');
        }
a62 8

SKIP: {
    skip("ASCII-centric test", 1) if $::IS_EBCDIC;
    use constant foofoo=>qq|\xc4\xb5|;
    { no strict; ()=${"\xc4\xb5::foo"} } # vivify Äµ package
    eval 'my foofoo $dog'; # foofoo was resolving to ĵ, not Äµ
    is $@@, '', 'my constant $var in utf8 scope where constant is not utf8';
}
@


