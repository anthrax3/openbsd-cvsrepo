head	1.15;
access;
symbols
	OPENBSD_6_2_BASE:1.15
	PERL_5_24_2:1.1.1.14
	OPENBSD_6_1:1.15.0.4
	OPENBSD_6_1_BASE:1.15
	OPENBSD_6_0:1.14.0.10
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.14.0.4
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.14.0.6
	OPENBSD_5_8_BASE:1.14
	PERL_5_20_2:1.1.1.13
	OPENBSD_5_7:1.14.0.2
	OPENBSD_5_7_BASE:1.14
	PERL_5_20_1:1.1.1.13
	OPENBSD_5_6:1.13.0.4
	OPENBSD_5_6_BASE:1.13
	PERL_5_18_2:1.1.1.12
	PERL:1.1.1
	OPENBSD_5_5:1.12.0.6
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.2
	OPENBSD_5_4_BASE:1.12
	PERL_5_16_3:1.1.1.11
	OPENBSD_5_3:1.11.0.10
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.8
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.6
	OPENBSD_5_0:1.11.0.4
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.2
	OPENBSD_4_9_BASE:1.11
	PERL_5_12_2:1.1.1.10
	OPENBSD_4_8:1.10.0.4
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.2
	OPENBSD_4_7_BASE:1.10
	PERL_5_10_1:1.1.1.9
	OPENBSD_4_6:1.9.0.6
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.2
	OPENBSD_4_5_BASE:1.9
	PERL_5_10_0:1.1.1.8
	OPENBSD_4_4:1.8.0.10
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.8
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.6
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.4
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.2
	OPENBSD_4_0_BASE:1.8
	PERL_5_8_8:1.1.1.7
	OPENBSD_3_9:1.7.0.10
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.8
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.6
	OPENBSD_3_7_BASE:1.7
	PERL_5_8_6:1.1.1.6
	OPENBSD_3_6:1.7.0.4
	OPENBSD_3_6_BASE:1.7
	PERL_5_8_5:1.1.1.6
	PERL_5_8_3:1.1.1.6
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.15
date	2017.02.05.00.32.19;	author afresh1;	state Exp;
branches;
next	1.14;
commitid	cxJ08BvJA9Pt2PTM;

1.14
date	2014.11.17.20.57.07;	author afresh1;	state Exp;
branches;
next	1.13;
commitid	QP75iYx42Uo7mMxO;

1.13
date	2014.03.24.15.05.33;	author afresh1;	state Exp;
branches;
next	1.12;

1.12
date	2013.03.25.20.40.59;	author sthen;	state Exp;
branches;
next	1.11;

1.11
date	2010.09.24.15.07.05;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2009.10.12.18.30.27;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2008.09.29.17.36.18;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2006.03.28.19.23.12;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.48;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.35;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.36.07;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.08.00;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.52.28;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.08.00.13;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.13.12;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.13.12;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.41.21;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.10.39;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.25.04;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.15.10;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.44.29;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2006.03.28.18.49.41;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2008.09.29.17.18.58;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2009.10.12.18.10.42;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2010.09.24.14.49.19;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2013.03.25.20.09.33;	author sthen;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2014.03.24.14.59.09;	author afresh1;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2014.11.17.20.53.17;	author afresh1;	state Exp;
branches;
next	1.1.1.14;
commitid	B31cAbBIXiCqnL97;

1.1.1.14
date	2017.08.14.13.46.22;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.15
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl

BEGIN {
    chdir 't' if -d 't';
    @@INC = '../lib';
    require "./test.pl";
}

use Config;

my $Is_VMSish = ($^O eq 'VMS');

if ($^O eq 'MSWin32') {
    # under minitest, buildcustomize sets this to 1, which means
    # nlinks isn't populated properly, allow our tests to pass
    ${^WIN32_SLOPPY_STAT} = 0;
}

if (($^O eq 'MSWin32') || ($^O eq 'NetWare')) {
    $wd = `cd`;
}
elsif ($^O eq 'VMS') {
    $wd = `show default`;
}
elsif ( $^O =~ /android/ || $^O eq 'nto' ) {
    # On Android and Blackberry 10, pwd is a shell builtin, so plain `pwd`
    # won't cut it
    $wd = `sh -c pwd`;
}
else {
    $wd = `pwd`;
}
chomp($wd);

die "Can't get current working directory" if(!$wd);

my $has_link            = $Config{d_link};
my $accurate_timestamps =
    !($^O eq 'MSWin32' || $^O eq 'NetWare' ||
      $^O eq 'dos'     || $^O eq 'os2'     ||
      $^O eq 'cygwin'  || $^O eq 'amigaos' ||
	  $wd =~ m#$Config{afsroot}/#
     );

if (defined &Win32::IsWinNT && Win32::IsWinNT()) {
    if (Win32::FsType() eq 'NTFS') {
        $has_link            = 1;
        $accurate_timestamps = 1;
    }
    else {
        $has_link            = 0;
    }
}

my $needs_fh_reopen =
    $^O eq 'dos'
    # Not needed on HPFS, but needed on HPFS386 ?!
    || $^O eq 'os2';

$needs_fh_reopen = 1 if (defined &Win32::IsWin95 && Win32::IsWin95());

my $skip_mode_checks =
    $^O eq 'cygwin' && $ENV{CYGWIN} !~ /ntsec/;

plan tests => 61;

my $tmpdir = tempfile();
my $tmpdir1 = tempfile();

if (($^O eq 'MSWin32') || ($^O eq 'NetWare')) {
    `rmdir /s /q $tmpdir 2>nul`;
    `mkdir $tmpdir`;
}
elsif ($^O eq 'VMS') {
    `if f\$search("[.$tmpdir]*.*") .nes. "" then delete/nolog/noconfirm [.$tmpdir]*.*.*`;
    `if f\$search("$tmpdir.dir") .nes. "" then set file/prot=o:rwed $tmpdir.dir;`;
    `if f\$search("$tmpdir.dir") .nes. "" then delete/nolog/noconfirm $tmpdir.dir;`;
    `create/directory [.$tmpdir]`;
}
else {
    `rm -f $tmpdir 2>/dev/null; mkdir $tmpdir 2>/dev/null`;
}

chdir $tmpdir;

`/bin/rm -rf a b c x` if -x '/bin/rm';

umask(022);

SKIP: {
    skip "bogus umask", 1 if ($^O eq 'MSWin32') || ($^O eq 'NetWare');

    is((umask(0)&0777), 022, 'umask'),
}

open(FH,'>x') || die "Can't create x";
close(FH);
open(FH,'>a') || die "Can't create a";
close(FH);

my ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,
    $blksize,$blocks,$a_mode);

SKIP: {
    skip("no link", 4) unless $has_link;

    ok(link('a','b'), "link a b");
    ok(link('b','c'), "link b c");

    $a_mode = (stat('a'))[2];

    ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,
     $blksize,$blocks) = stat('c');

    SKIP: {
        skip "no nlink", 1 if $Config{dont_use_nlink};

        is($nlink, 3, "link count of triply-linked file");
    }

    SKIP: {
        skip "hard links not that hard in $^O", 1 if $^O eq 'amigaos';
	skip "no mode checks", 1 if $skip_mode_checks;

#      if ($^O eq 'cygwin') { # new files on cygwin get rwx instead of rw-
#          is($mode & 0777, 0777, "mode of triply-linked file");
#      } else {
            is(sprintf("0%o", $mode & 0777), 
               sprintf("0%o", $a_mode & 0777), 
               "mode of triply-linked file");
#      }
    }
}

$newmode = (($^O eq 'MSWin32') || ($^O eq 'NetWare')) ? 0444 : 0777;

is(chmod($newmode,'a'), 1, "chmod succeeding");

SKIP: {
    skip("no link", 7) unless $has_link;

    ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,
     $blksize,$blocks) = stat('c');

    SKIP: {
	skip "no mode checks", 1 if $skip_mode_checks;

        is($mode & 0777, $newmode, "chmod going through");
    }

    $newmode = 0700;
    chmod 0444, 'x';
    $newmode = 0666;

    is(chmod($newmode,'c','x'), 2, "chmod two files");

    ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,
     $blksize,$blocks) = stat('c');

    SKIP: {
	skip "no mode checks", 1 if $skip_mode_checks;

        is($mode & 0777, $newmode, "chmod going through to c");
    }

    ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,
     $blksize,$blocks) = stat('x');

    SKIP: {
	skip "no mode checks", 1 if $skip_mode_checks;

        is($mode & 0777, $newmode, "chmod going through to x");
    }

    is(unlink('b','x'), 2, "unlink two files");

    ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,
     $blksize,$blocks) = stat('b');

    is($ino, undef, "ino of removed file b should be undef");

    ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,
     $blksize,$blocks) = stat('x');

    is($ino, undef, "ino of removed file x should be undef");
}

SKIP: {
    skip "no fchmod", 7 unless ($Config{d_fchmod} || "") eq "define";
    ok(open(my $fh, "<", "a"), "open a");
    is(chmod(0, $fh), 1, "fchmod");
    $mode = (stat "a")[2];
    SKIP: {
        skip "no mode checks", 1 if $skip_mode_checks;
        is($mode & 0777, 0, "perm reset");
    }
    is(chmod($newmode, "a"), 1, "fchmod");
    $mode = (stat $fh)[2];
    SKIP: { 
        skip "no mode checks", 1 if $skip_mode_checks;
        is($mode & 0777, $newmode, "perm restored");
    }

    # [perl #122703]
    close $fh;
    $! = 0;
    ok(!chmod(0666, $fh), "chmod through closed handle fails");
    isnt($!+0, 0, "and errno was set");
}

SKIP: {
    skip "no fchown", 3 unless ($Config{d_fchown} || "") eq "define";
    open(my $fh, "<", "a");
    is(chown($<, $(, $fh), 1, "fchown");

    # [perl #122703]
    # chown() behaved correctly, but there was no test for the chown()
    # on closed handle case
    close $fh;
    $! = 0;
    ok(!chown($<, $(, $fh), "chown on closed handle fails");
    isnt($!+0, 0, "and errno was set");
}

SKIP: {
    skip "has fchmod", 1 if ($Config{d_fchmod} || "") eq "define";
    open(my $fh, "<", "a");
    eval { chmod(0777, $fh); };
    like($@@, qr/^The fchmod function is unimplemented at/, "fchmod is unimplemented");
}

SKIP: {
    skip "has fchown", 1 if ($Config{d_fchown} || "") eq "define";
    open(my $fh, "<", "a");
    eval { chown(0, 0, $fh); };
    like($@@, qr/^The f?chown function is unimplemented at/, "fchown is unimplemented");
}

is(rename('a','b'), 1, "rename a b");

($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,
 $blksize,$blocks) = stat('a');

is($ino, undef, "ino of renamed file a should be undef");

$delta = $accurate_timestamps ? 1 : 2;	# Granularity of time on the filesystem
chmod 0777, 'b';

$foo = (utime 500000000,500000000 + $delta,'b');
is($foo, 1, "utime");
check_utime_result();

utime undef, undef, 'b';
($atime,$mtime) = (stat 'b')[8,9];
print "# utime undef, undef --> $atime, $mtime\n";
isnt($atime, 500000000, 'atime');
isnt($mtime, 500000000 + $delta, 'mtime');

SKIP: {
    skip "no futimes", 6 unless ($Config{d_futimes} || "") eq "define";
    open(my $fh, "<", 'b');
    $foo = (utime 500000000,500000000 + $delta, $fh);
    is($foo, 1, "futime");
    check_utime_result();
    # [perl #122703]
    close $fh;
    ok(!utime(500000000,500000000 + $delta, $fh),
       "utime fails on a closed file handle");
    isnt($!+0, 0, "and errno was set");
}


sub check_utime_result {
    ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,
     $blksize,$blocks) = stat('b');

 SKIP: {
	skip "bogus inode num", 1 if ($^O eq 'MSWin32') || ($^O eq 'NetWare');

	ok($ino,    'non-zero inode num');
    }

 SKIP: {
	skip "filesystem atime/mtime granularity too low", 2
	    unless $accurate_timestamps;

     if ($^O eq 'vos') {
	    skip ("# TODO - hit VOS bug posix-2055 - access time does not follow POSIX rules for an open file.", 2);
     }

	print "# atime - $atime  mtime - $mtime  delta - $delta\n";
	if($atime == 500000000 && $mtime == 500000000 + $delta) {
	    pass('atime');
	    pass('mtime');
	}
	else {
	    if ($^O =~ /\blinux\b/i) {
		print "# Maybe stat() cannot get the correct atime, ".
		    "as happens via NFS on linux?\n";
		$foo = (utime 400000000,500000000 + 2*$delta,'b');
		my ($new_atime, $new_mtime) = (stat('b'))[8,9];
		print "# newatime - $new_atime  nemtime - $new_mtime\n";
		if ($new_atime == $atime && $new_mtime - $mtime == $delta) {
		    pass("atime - accounted for possible NFS/glibc2.2 bug on linux");
		    pass("mtime - accounted for possible NFS/glibc2.2 bug on linux");
		}
		else {
		    fail("atime - $atime/$new_atime $mtime/$new_mtime");
		    fail("mtime - $atime/$new_atime $mtime/$new_mtime");
		}
	    }
	    elsif ($^O eq 'VMS') {
		# why is this 1 second off?
		is( $atime, 500000001,          'atime' );
		is( $mtime, 500000000 + $delta, 'mtime' );
	    }
	    elsif ($^O eq 'haiku') {
            SKIP: {
		    skip "atime not updated", 1;
		}
		is($mtime, 500000001, 'mtime');
	    }
	    else {
		fail("atime");
		fail("mtime");
	    }
	}
    }
}

SKIP: {
    skip "has futimes", 1 if ($Config{d_futimes} || "") eq "define";
    open(my $fh, "<", "b") || die;
    eval { utime(undef, undef, $fh); };
    like($@@, qr/^The futimes function is unimplemented at/, "futimes is unimplemented");
}

is(unlink('b'), 1, "unlink b");

($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,
    $blksize,$blocks) = stat('b');
is($ino, undef, "ino of unlinked file b should be undef");
unlink 'c';

chdir $wd || die "Can't cd back to '$wd' ($!)";

# Yet another way to look for links (perhaps those that cannot be
# created by perl?).  Hopefully there is an ls utility in your
# %PATH%. N.B. that $^O is 'cygwin' on Cygwin.

SKIP: {
    skip "Win32/Netware specific test", 2
      unless ($^O eq 'MSWin32') || ($^O eq 'NetWare');
    skip "No symbolic links found to test with", 2
      unless  `ls -l perl 2>nul` =~ /^l.*->/;

    system("cp TEST TEST$$");
    # we have to copy because e.g. GNU grep gets huffy if we have
    # a symlink forest to another disk (it complains about too many
    # levels of symbolic links, even if we have only two)
    is(symlink("TEST$$","c"), 1, "symlink");
    $foo = `grep perl c 2>&1`;
    ok($foo, "found perl in c");
    unlink 'c';
    unlink("TEST$$");
}

my $tmpfile = tempfile();
open IOFSCOM, ">$tmpfile" or die "Could not write IOfs.tmp: $!";
print IOFSCOM 'helloworld';
close(IOFSCOM);

# TODO: pp_truncate needs to be taught about F_CHSIZE and F_FREESP,
# as per UNIX FAQ.

SKIP: {
# Check truncating a closed file.
    eval { truncate $tmpfile, 5; };

    skip("no truncate - $@@", 8) if $@@;

    is(-s $tmpfile, 5, "truncation to five bytes");

    truncate $tmpfile, 0;

    ok(-z $tmpfile,    "truncation to zero bytes");

#these steps are necessary to check if file is really truncated
#On Win95, FH is updated, but file properties aren't
    open(FH, ">$tmpfile") or die "Can't create $tmpfile";
    print FH "x\n" x 200;
    close FH;

# Check truncating an open file.
    open(FH, ">>$tmpfile") or die "Can't open $tmpfile for appending";

    binmode FH;
    select FH;
    $| = 1;
    select STDOUT;

    {
	use strict;
	print FH "x\n" x 200;
	ok(truncate(FH, 200), "fh resize to 200");
    }

    if ($needs_fh_reopen) {
	close (FH); open (FH, ">>$tmpfile") or die "Can't reopen $tmpfile";
    }

	is(-s $tmpfile, 200, "fh resize to 200 working (filename check)");

	ok(truncate(FH, 0), "fh resize to zero");

	if ($needs_fh_reopen) {
	    close (FH); open (FH, ">>$tmpfile") or die "Can't reopen $tmpfile";
	}

	ok(-z $tmpfile, "fh resize to zero working (filename check)");

	close FH;

	open(FH, ">>$tmpfile") or die "Can't open $tmpfile for appending";

	binmode FH;
	select FH;
	$| = 1;
	select STDOUT;

	{
	    use strict;
	    print FH "x\n" x 200;
	    ok(truncate(*FH{IO}, 100), "fh resize by IO slot");
	}

	if ($needs_fh_reopen) {
	    close (FH); open (FH, ">>$tmpfile") or die "Can't reopen $tmpfile";
	}

	is(-s $tmpfile, 100, "fh resize by IO slot working");

	close FH;

	my $n = "for_fs_dot_t$$";
	open FH, ">$n" or die "open $n: $!";
	print FH "bloh blah bla\n";
	close FH or die "close $n: $!";
	eval "truncate $n, 0; 1" or die;
	ok !-z $n, 'truncate(word) does not fall back to file name';
	unlink $n;
}

# check if rename() can be used to just change case of filename
SKIP: {
    skip "Works in Cygwin only if check_case is set to relaxed", 1
      if ($ENV{'CYGWIN'} && ($ENV{'CYGWIN'} =~ /check_case:(?:adjust|strict)/));

    chdir "./$tmpdir";
    open(FH,'>x') || die "Can't create x";
    close(FH);
    rename('x', 'X');

    # this works on win32 only, because fs isn't casesensitive
    ok(-e 'X', "rename working");

    unlink_all 'X';
    chdir $wd || die "Can't cd back to $wd";
}

# check if rename() works on directories
if ($^O eq 'VMS') {
    # must have delete access to rename a directory
    `set file $tmpdir.dir/protection=o:d`;
    ok(rename("$tmpdir.dir", "$tmpdir1.dir"), "rename on directories") ||
      print "# errno: $!\n";
}
else {
    ok(rename($tmpdir, $tmpdir1), "rename on directories");
}

ok(-d $tmpdir1, "rename on directories working");

{
    # Change 26011: Re: A surprising segfault
    # to make sure only that these obfuscated sentences will not crash.

    map chmod(+()), ('')x68;
    ok(1, "extend sp in pp_chmod");

    map chown(+()), ('')x68;
    ok(1, "extend sp in pp_chown");
}

# Calling unlink on a directory without -U and privileges will always fail, but
# it should set errno to EISDIR even though unlink(2) is never called.
SKIP: {
    if (is_miniperl && !eval 'require Errno') {
        skip "Errno not built yet", 3;
    }
    require Errno;

    my $tmpdir = tempfile();
    if (($^O eq 'MSWin32') || ($^O eq 'NetWare')) {
        `mkdir $tmpdir`;
    }
    elsif ($^O eq 'VMS') {
        `create/directory [.$tmpdir]`;
    }
    else {
        `mkdir $tmpdir 2>/dev/null`;
    }

    # errno should be set even though unlink(2) is not called
    local $!;
    is(unlink($tmpdir), 0, "can't unlink directory without -U and privileges");
    is(0+$!, Errno::EISDIR(), "unlink directory without -U sets errno");

    rmdir $tmpdir;

    # errno should be set by failed lstat(2) call
    $! = 0;
    unlink($tmpdir);
    is(0+$!, Errno::ENOENT(), "unlink non-existent directory without -U sets ENOENT");
}

# need to remove $tmpdir if rename() in test 28 failed!
END { rmdir $tmpdir1; rmdir $tmpdir; }
@


1.14
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d13 6
d65 1
a65 1
plan tests => 55;
d189 1
a189 1
    skip "no fchmod", 5 unless ($Config{d_fchmod} || "") eq "define";
d203 6
d212 1
a212 1
    skip "no fchown", 1 unless ($Config{d_fchown} || "") eq "define";
d214 9
a222 1
    is(chown(-1, -1, $fh), 1, "fchown");
d260 1
a260 1
    skip "no futimes", 4 unless ($Config{d_futimes} || "") eq "define";
d265 5
d497 4
a500 1
{
@


1.13
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d19 5
d29 2
d44 3
d59 1
a59 1
plan tests => 52;
d262 4
d320 1
a320 1
chdir $wd || die "Can't cd back to $wd";
a386 5
    SKIP: {
        if ($^O eq 'vos') {
	    skip ("# TODO - hit VOS bug posix-973 - cannot resize an open file below the current file pos.", 6);
	}

a426 1
    }
d468 29
@


1.12
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d49 1
a49 1
plan tests => 51;
d75 1
a75 1
    skip "bogus umask", 1 if ($^O eq 'MSWin32') || ($^O eq 'NetWare') || ($^O eq 'epoc');
d278 1
a278 1
	    elsif ($^O eq 'beos' || $^O eq 'haiku') {
d375 1
a375 1
	    skip ("# TODO - hit VOS bug posix-973 - cannot resize an open file below the current file pos.", 5);
d410 8
@


1.11
log
@merge in perl 5.12.2 plus local changes
@
text
@a9 1
use File::Spec::Functions;
d68 1
a68 1
chdir catdir(curdir(), $tmpdir);
d426 1
a426 1
    1 while unlink 'X';
@


1.10
log
@Merge in perl 5.10.1; part two
@
text
@a11 1
my $Is_MacOS  = ($^O eq 'MacOS');
d29 2
a30 3
      $^O eq 'mint'    || $^O eq 'cygwin'  ||
      $^O eq 'amigaos' || $wd =~ m#$Config{afsroot}/# ||
      $Is_MacOS
a64 3
elsif ($Is_MacOS) {
    rmdir "$tmpdir"; mkdir "$tmpdir";
}
d76 1
a76 1
    skip "bogus umask", 1 if ($^O eq 'MSWin32') || ($^O eq 'NetWare') || ($^O eq 'epoc') || $Is_MacOS;
@


1.9
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d54 2
d58 2
a59 2
    `rmdir /s /q tmp 2>nul`;
    `mkdir tmp`;
d62 4
a65 4
    `if f\$search("[.tmp]*.*") .nes. "" then delete/nolog/noconfirm [.tmp]*.*.*`;
    `if f\$search("tmp.dir") .nes. "" then set file/prot=o:rwed tmp.dir;`;
    `if f\$search("tmp.dir") .nes. "" then delete/nolog/noconfirm tmp.dir;`;
    `create/directory [.tmp]`;
d68 1
a68 1
    rmdir "tmp"; mkdir "tmp";
d71 1
a71 1
    `rm -f tmp 2>/dev/null; mkdir tmp 2>/dev/null`;
d74 1
a74 1
chdir catdir(curdir(), 'tmp');
d92 1
a92 1
    $blksize,$blocks);
d100 2
d118 3
a120 1
            is($mode & 0777, 0666, "mode of triply-linked file");
d284 1
a284 1
	    elsif ($^O eq 'beos') {
d335 2
a336 2
unlink "Iofs.tmp";
open IOFSCOM, ">Iofs.tmp" or die "Could not write IOfs.tmp: $!";
d345 1
a345 1
    eval { truncate "Iofs.tmp", 5; };
d349 1
a349 1
    is(-s "Iofs.tmp", 5, "truncation to five bytes");
d351 1
a351 1
    truncate "Iofs.tmp", 0;
d353 1
a353 1
    ok(-z "Iofs.tmp",    "truncation to zero bytes");
d357 1
a357 1
    open(FH, ">Iofs.tmp") or die "Can't create Iofs.tmp";
d362 1
a362 1
    open(FH, ">>Iofs.tmp") or die "Can't open Iofs.tmp for appending";
d376 1
a376 1
	close (FH); open (FH, ">>Iofs.tmp") or die "Can't reopen Iofs.tmp";
d384 1
a384 1
	is(-s "Iofs.tmp", 200, "fh resize to 200 working (filename check)");
d389 1
a389 1
	    close (FH); open (FH, ">>Iofs.tmp") or die "Can't reopen Iofs.tmp";
d392 1
a392 1
	ok(-z "Iofs.tmp", "fh resize to zero working (filename check)");
d396 1
a396 1
	open(FH, ">>Iofs.tmp") or die "Can't open Iofs.tmp for appending";
d410 1
a410 1
	    close (FH); open (FH, ">>Iofs.tmp") or die "Can't reopen Iofs.tmp";
d413 1
a413 1
	is(-s "Iofs.tmp", 100, "fh resize by IO slot working");
d424 1
a424 1
    chdir './tmp';
d439 2
a440 2
    `set file tmp.dir/protection=o:d`;
    ok(rename('tmp.dir', 'tmp1.dir'), "rename on directories") ||
d444 1
a444 1
    ok(rename('tmp', 'tmp1'), "rename on directories");
d447 1
a447 1
ok(-d 'tmp1', "rename on directories working");
d460 2
a461 2
# need to remove 'tmp' if rename() in test 28 failed!
END { rmdir 'tmp1'; rmdir 'tmp'; 1 while unlink "Iofs.tmp"; }
@


1.8
log
@merge in perl 5.8.8
@
text
@d17 2
a18 1
} elsif ($^O eq 'VMS') {
d20 2
a21 1
} else {
d52 1
a52 1
plan tests => 42;
d61 1
d206 1
a206 1
    like($@@, qr/^The fchown function is unimplemented at/, "fchown is unimplemented");
d218 1
a219 1

d221 1
d223 5
a227 2
($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,
    $blksize,$blocks) = stat('b');
d230 11
a240 1
    skip "bogus inode num", 1 if ($^O eq 'MSWin32') || ($^O eq 'NetWare');
d242 48
a289 1
    ok($ino,    'non-zero inode num');
d293 4
a296 38
    skip "filesystem atime/mtime granularity too low", 2
      unless $accurate_timestamps;

    print "# atime - $atime  mtime - $mtime  delta - $delta\n";
    if($atime == 500000000 && $mtime == 500000000 + $delta) {
        pass('atime');
        pass('mtime');
    }
    else {
        if ($^O =~ /\blinux\b/i) {
            print "# Maybe stat() cannot get the correct atime, ".
                  "as happens via NFS on linux?\n";
            $foo = (utime 400000000,500000000 + 2*$delta,'b');
            my ($new_atime, $new_mtime) = (stat('b'))[8,9];
            print "# newatime - $new_atime  nemtime - $new_mtime\n";
            if ($new_atime == $atime && $new_mtime - $mtime == $delta) {
                pass("atime - accounted for possible NFS/glibc2.2 bug on linux");
                pass("mtime - accounted for possible NFS/glibc2.2 bug on linux");
            }
            else {
                fail("atime - $atime/$new_atime $mtime/$new_mtime");
                fail("mtime - $atime/$new_atime $mtime/$new_mtime");
            }
        }
        elsif ($^O eq 'VMS') {
            # why is this 1 second off?
            is( $atime, 500000001,          'atime' );
            is( $mtime, 500000000 + $delta, 'mtime' );
        }
        elsif ($^O eq 'beos') {
            SKIP: { skip "atime not updated", 1; }
            is($mtime, 500000001, 'mtime');
        }
        else {
            fail("atime");
            fail("mtime");
        }
    }
d416 1
a416 1
      if $^O eq 'cygwin';
d436 2
a437 1
} else {
d443 1
a443 16
# FIXME - for some reason change 26009/26011 merged as 26627 still segfaults
# after all the tests have completed:
# #0  0x08124dd0 in Perl_pop_scope (my_perl=0x81b5ec8) at scope.c:143
# #1  0x080e88d8 in Perl_pp_leave (my_perl=0x81b5ec8) at pp_hot.c:1843
# #2  0x080c7dc1 in Perl_runops_debug (my_perl=0x81b5ec8) at dump.c:1459
# #3  0x080660af in S_run_body (my_perl=0x81b5ec8, oldscope=1) at perl.c:2369
# #4  0x08065ab1 in perl_run (my_perl=0x81b5ec8) at perl.c:2286
# #5  0x080604c3 in main (argc=2, argv=0xbffffc64, env=0xbffffc70)
#     at perlmain.c:99
#
# 143         const I32 oldsave = PL_scopestack[--PL_scopestack_ix];
# (gdb) p my_perl->Tscopestack_ix
# $1 = 136787683
#

if (0) {
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d50 1
a50 1
plan tests => 34;
d81 4
a84 4
open(fh,'>x') || die "Can't create x";
close(fh);
open(fh,'>a') || die "Can't create a";
close(fh);
d169 37
d389 2
a390 2
    open(fh,'>x') || die "Can't create x";
    close(fh);
d412 26
d439 1
a439 1
END { rmdir 'tmp1'; rmdir 'tmp'; unlink "Iofs.tmp"; }
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d50 1
a50 1
plan tests => 32;
d274 1
a274 1
    skip("no truncate - $@@", 6) if $@@;
d306 18
a323 3
    if ($^O eq 'vos') {
        skip ("# TODO - hit VOS bug posix-973 - cannot resize an open file below the current file pos.", 3);
    }
d325 4
a328 1
    is(-s "Iofs.tmp", 200, "fh resize to 200 working (filename check)");
d330 5
a334 1
    ok(truncate(FH, 0), "fh resize to zero");
d336 3
a338 3
    if ($needs_fh_reopen) {
	close (FH); open (FH, ">>Iofs.tmp") or die "Can't reopen Iofs.tmp";
    }
d340 1
a340 1
    ok(-z "Iofs.tmp", "fh resize to zero working (filename check)");
d342 2
a343 1
    close FH;
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@a2 2
# $RCSfile: fs.t,v $$Revision: 4.1 $$Date: 92/08/07 18:27:28 $

d6 1
d10 13
d24 8
a31 2
$Is_Dosish = ($^O eq 'MSWin32' or $^O eq 'dos' or
	      $^O eq 'os2' or $^O eq 'mint');
d34 4
a37 1
    $Is_Dosish = '' if Win32::FsType() eq 'NTFS';
d40 9
a48 1
print "1..29\n";
d50 20
a69 2
$wd = (($^O eq 'MSWin32') ? `cd` : `pwd`);
chop($wd);
a70 3
if ($^O eq 'MSWin32') { `rmdir /s /q tmp 2>nul`; `mkdir tmp`; }
else {  `rm -f tmp 2>/dev/null; mkdir tmp 2>/dev/null`; }
chdir './tmp';
d75 6
a80 2
if ($^O eq 'MSWin32') { print "ok 1 # skipped: bogus umask()\n"; }
elsif ((umask(0)&0777) == 022) {print "ok 1\n";} else {print "not ok 1\n";}
d86 29
a114 7
if ($Is_Dosish) {print "ok 2 # skipped: no link\n";} 
elsif (eval {link('a','b')}) {print "ok 2\n";} 
else {print "not ok 2\n";}

if ($Is_Dosish) {print "ok 3 # skipped: no link\n";} 
elsif (eval {link('b','c')}) {print "ok 3\n";} 
else {print "not ok 3\n";}
d116 6
a121 2
($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,
    $blksize,$blocks) = stat('c');
d123 2
a124 11
if ($Config{dont_use_nlink} || $Is_Dosish)
    {print "ok 4 # skipped: no link\n";} 
elsif ($nlink == 3)
    {print "ok 4\n";} 
else {print "not ok 4\n";}

if ($^O eq 'amigaos' || $Is_Dosish)
    {print "ok 5 # skipped: no link\n";} 
elsif (($mode & 0777) == 0666)
    {print "ok 5\n";} 
else {print "not ok 5\n";}
d126 2
a127 2
$newmode = $^O eq 'MSWin32' ? 0444 : 0777;
if ((chmod $newmode,'a') == 1) {print "ok 6\n";} else {print "not ok 6\n";}
d129 2
a130 5
($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,
    $blksize,$blocks) = stat('c');
if ($Is_Dosish) {print "ok 7 # skipped: no link\n";} 
elsif (($mode & 0777) == $newmode) {print "ok 7\n";} 
else {print "not ok 7\n";}
d132 1
a132 2
$newmode = 0700;
if ($^O eq 'MSWin32') {
d135 32
d169 1
a169 3
if ($Is_Dosish) {print "ok 8 # skipped: no link\n";} 
elsif ((chmod $newmode,'c','x') == 2) {print "ok 8\n";} 
else {print "not ok 8\n";}
d172 1
a172 4
    $blksize,$blocks) = stat('c');
if ($Is_Dosish) {print "ok 9 # skipped: no link\n";} 
elsif (($mode & 0777) == $newmode) {print "ok 9\n";} 
else {print "not ok 9\n";}
d174 1
a174 15
($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,
    $blksize,$blocks) = stat('x');
if ($Is_Dosish) {print "ok 10 # skipped: no link\n";} 
elsif (($mode & 0777) == $newmode) {print "ok 10\n";} 
else {print "not ok 10\n";}

if ($Is_Dosish) {print "ok 11 # skipped: no link\n"; unlink 'b','x'; } 
elsif ((unlink 'b','x') == 2) {print "ok 11\n";} 
else {print "not ok 11\n";}
($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,
    $blksize,$blocks) = stat('b');
if ($ino == 0) {print "ok 12\n";} else {print "not ok 12\n";}
($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,
    $blksize,$blocks) = stat('x');
if ($ino == 0) {print "ok 13\n";} else {print "not ok 13\n";}
d176 1
a176 5
if (rename('a','b')) {print "ok 14\n";} else {print "not ok 14\n";}
($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,
    $blksize,$blocks) = stat('a');
if ($ino == 0) {print "ok 15\n";} else {print "not ok 15\n";}
$delta = $Is_Dosish ? 2 : 1;	# Granularity of time on the filesystem
d179 3
a181 1
if ($foo == 1) {print "ok 16\n";} else {print "not ok 16 $foo\n";}
a183 16
if ($^O eq 'MSWin32') { print "ok 17 # skipped: bogus (stat)[1]\n"; }
elsif ($ino) {print "ok 17\n";} else {print "not ok 17\n";}
if ($wd =~ m#/afs/# || $^O eq 'amigaos' || $^O eq 'dos' || $^O eq 'MSWin32')
    {print "ok 18 # skipped: granularity of the filetime\n";}
elsif ($atime == 500000000 && $mtime == 500000000 + $delta)
    {print "ok 18\n";}
elsif ($^O =~ /\blinux\b/i) {
    # Maybe stat() cannot get the correct atime, as happens via NFS on linux?
    $foo = (utime 400000000,500000000 + 2*$delta,'b');
    my ($new_atime, $new_mtime) = (stat('b'))[8,9];
    if ($new_atime == $atime && $new_mtime - $mtime == $delta)
	{print "ok 18 # accounted for possible NFS/glibc2.2 bug on linux\n";}
    else
	{print "not ok 18 $atime/$new_atime $mtime/$new_mtime\n";}
} else
    {print "not ok 18 $atime $mtime\n";}
d185 49
a233 1
if ((unlink 'b') == 1) {print "ok 19\n";} else {print "not ok 19\n";}
d236 1
a236 1
if ($ino == 0) {print "ok 20\n";} else {print "not ok 20\n";}
d241 10
a250 3
unlink 'c';
if ($^O ne 'MSWin32' and `ls -l perl 2>/dev/null` =~ /^l.*->/) {
    # we have symbolic links
d255 1
a255 1
    if (symlink("TEST$$","c")) {print "ok 21\n";} else {print "not ok 21\n";}
d257 1
a257 1
    if ($foo) {print "ok 22\n";} else {print "not ok 22\n";}
a260 3
else {
    print "ok 21\nok 22\n";
}
a261 1
# truncate (may not be implemented everywhere)
d263 22
a284 17
`echo helloworld > Iofs.tmp`;
eval { truncate "Iofs.tmp", 5; };
if ($@@ =~ /not implemented/) {
  print "# truncate not implemented -- skipping tests 23 through 26\n";
  for (23 .. 26) {
    print "ok $_\n";
  }
}
else {
  if (-s "Iofs.tmp" == 5) {print "ok 23\n"} else {print "not ok 23\n"}
  truncate "Iofs.tmp", 0;
  if (-z "Iofs.tmp") {print "ok 24\n"} else {print "not ok 24\n"}
  open(FH, ">Iofs.tmp") or die "Can't create Iofs.tmp";
  binmode FH;
  { select FH; $| = 1; select STDOUT }
  {
    use strict;
d286 35
a320 18
    truncate(FH, 200) or die "Can't truncate FH: $!";
  }
  if ($^O eq 'dos'
	# Not needed on HPFS, but needed on HPFS386 ?!
      or $^O eq 'os2')
  {
      close (FH); open (FH, ">>Iofs.tmp") or die "Can't reopen Iofs.tmp";
  }
  if (-s "Iofs.tmp" == 200) {print "ok 25\n"} else {print "not ok 25\n"}
  truncate FH, 0;
  if ($^O eq 'dos'
	# Not needed on HPFS, but needed on HPFS386 ?!
      or $^O eq 'os2')
  {
      close (FH); open (FH, ">>Iofs.tmp") or die "Can't reopen Iofs.tmp";
  }
  if (-z "Iofs.tmp") {print "ok 26\n"} else {print "not ok 26\n"}
  close FH;
d324 15
a338 8
chdir './tmp';
open(fh,'>x') || die "Can't create x";
close(fh);
rename('x', 'X');
print 'not ' unless -e 'X';
print "ok 27\n";
unlink 'X';
chdir $wd || die "Can't cd back to $wd";
d341 10
a350 4
rename 'tmp', 'tmp1' or print "not ";
print "ok 28\n";
-d 'tmp1' or print "not ";
print "ok 29\n";
d352 2
a353 1
END { rmdir 'tmp1'; unlink "Iofs.tmp"; }
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d7 1
a7 1
    unshift @@INC, '../lib';
d118 9
a126 1
else
d140 6
a145 2
    if (symlink("TEST","c")) {print "ok 21\n";} else {print "not ok 21\n";}
    $foo = `grep perl c`;
d148 1
@


1.3
log
@perl5.005_03 (stock)
@
text
@d7 1
a7 1
    @@INC = '../lib';
d15 5
a19 1
print "1..28\n";
d24 1
a24 1
if ($^O eq 'MSWin32') { `del tmp 2>nul`; `mkdir tmp`; }
d61 2
a62 1
if ((chmod 0777,'a') == 1) {print "ok 6\n";} else {print "not ok 6\n";}
d67 1
a67 1
elsif (($mode & 0777) == 0777) {print "ok 7\n";} 
d70 6
d77 1
a77 1
elsif ((chmod 0700,'c','x') == 2) {print "ok 8\n";} 
d83 1
a83 1
elsif (($mode & 0777) == 0700) {print "ok 9\n";} 
d89 1
a89 1
elsif (($mode & 0777) == 0700) {print "ok 10\n";} 
d107 1
d156 1
d158 9
a166 3
  print FH "helloworld\n";
  truncate FH, 5;
  if ($^O eq 'dos') {
d169 1
a169 1
  if (-s "Iofs.tmp" == 5) {print "ok 25\n"} else {print "not ok 25\n"}
d171 4
a174 1
  if ($^O eq 'dos') {
d181 10
d193 1
a193 1
print "ok 27\n";
d195 1
a195 1
print "ok 28\n";
@


1.2
log
@perl 5.004_04
@
text
@d12 2
a13 2
# avoid win32 (for now)
do { print "1..0\n"; exit(0); } if $^O eq 'MSWin32';
d15 1
a15 1
print "1..26\n";
d20 1
a20 1
if ($^O eq 'MSWin32') { `del tmp`; `mkdir tmp`; }
d27 2
a28 1
if ((umask(0)&0777) == 022) {print "ok 1\n";} else {print "not ok 1\n";}
d34 7
a40 3
if (eval {link('a','b')}) {print "ok 2\n";} else {print "not ok 2\n";}

if (eval {link('b','c')}) {print "ok 3\n";} else {print "not ok 3\n";}
d45 11
a55 5
if ($Config{dont_use_nlink} || $nlink == 3)
    {print "ok 4\n";} else {print "not ok 4\n";}

if (($mode & 0777) == 0666 || $^O eq 'amigaos')
    {print "ok 5\n";} else {print "not ok 5\n";}
d61 7
a67 3
if (($mode & 0777) == 0777) {print "ok 7\n";} else {print "not ok 7\n";}

if ((chmod 0700,'c','x') == 2) {print "ok 8\n";} else {print "not ok 8\n";}
d71 4
a74 1
if (($mode & 0777) == 0700) {print "ok 9\n";} else {print "not ok 9\n";}
d77 7
a83 3
if (($mode & 0777) == 0700) {print "ok 10\n";} else {print "not ok 10\n";}

if ((unlink 'b','x') == 2) {print "ok 11\n";} else {print "not ok 11\n";}
d95 2
a96 1
$foo = (utime 500000000,500000001,'b');
d100 5
a104 3
if ($ino) {print "ok 17\n";} else {print "not ok 17\n";}
if (($atime == 500000000 && $mtime == 500000001)
	|| $wd =~ m#/afs/# || $^O eq 'amigaos')
a115 1
rmdir 'tmp';
d147 3
d152 3
d158 8
a165 1
unlink "Iofs.tmp";
@


1.1
log
@Initial revision
@
text
@d5 9
a13 1
print "1..22\n";
d15 3
a17 1
$wd = `pwd`;
d20 2
a21 1
`rm -f tmp 2>/dev/null; mkdir tmp 2>/dev/null`;
d40 5
a44 2
if ($nlink == 3) {print "ok 4\n";} else {print "not ok 4\n";}
if (($mode & 0777) == 0666) {print "ok 5\n";} else {print "not ok 5\n";}
d78 2
a79 1
if (($atime == 500000000 && $mtime == 500000001) || $wd =~ m#/afs/#)
d91 1
d94 2
a95 1
if (`ls -l perl 2>/dev/null` =~ /^l.*->/) {  # we have symbolic links
d99 1
d104 25
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d5 1
a5 11
BEGIN {
    chdir 't' if -d 't';
    @@INC = '../lib';
}

use Config;

$Is_Dosish = ($^O eq 'MSWin32' or $^O eq 'dos' or
	      $^O eq 'os2' or $^O eq 'mint');

print "1..28\n";
d7 1
a7 1
$wd = (($^O eq 'MSWin32') ? `cd` : `pwd`);
d10 1
a10 2
if ($^O eq 'MSWin32') { `del tmp 2>nul`; `mkdir tmp`; }
else {  `rm -f tmp 2>/dev/null; mkdir tmp 2>/dev/null`; }
d16 1
a16 2
if ($^O eq 'MSWin32') { print "ok 1 # skipped: bogus umask()\n"; }
elsif ((umask(0)&0777) == 022) {print "ok 1\n";} else {print "not ok 1\n";}
d22 3
a24 7
if ($Is_Dosish) {print "ok 2 # skipped: no link\n";} 
elsif (eval {link('a','b')}) {print "ok 2\n";} 
else {print "not ok 2\n";}

if ($Is_Dosish) {print "ok 3 # skipped: no link\n";} 
elsif (eval {link('b','c')}) {print "ok 3\n";} 
else {print "not ok 3\n";}
d29 2
a30 11
if ($Config{dont_use_nlink} || $Is_Dosish)
    {print "ok 4 # skipped: no link\n";} 
elsif ($nlink == 3)
    {print "ok 4\n";} 
else {print "not ok 4\n";}

if ($^O eq 'amigaos' || $Is_Dosish)
    {print "ok 5 # skipped: no link\n";} 
elsif (($mode & 0777) == 0666)
    {print "ok 5\n";} 
else {print "not ok 5\n";}
d36 3
a38 7
if ($Is_Dosish) {print "ok 7 # skipped: no link\n";} 
elsif (($mode & 0777) == 0777) {print "ok 7\n";} 
else {print "not ok 7\n";}

if ($Is_Dosish) {print "ok 8 # skipped: no link\n";} 
elsif ((chmod 0700,'c','x') == 2) {print "ok 8\n";} 
else {print "not ok 8\n";}
d42 1
a42 4
if ($Is_Dosish) {print "ok 9 # skipped: no link\n";} 
elsif (($mode & 0777) == 0700) {print "ok 9\n";} 
else {print "not ok 9\n";}

d45 3
a47 7
if ($Is_Dosish) {print "ok 10 # skipped: no link\n";} 
elsif (($mode & 0777) == 0700) {print "ok 10\n";} 
else {print "not ok 10\n";}

if ($Is_Dosish) {print "ok 11 # skipped: no link\n"; unlink 'b','x'; } 
elsif ((unlink 'b','x') == 2) {print "ok 11\n";} 
else {print "not ok 11\n";}
d59 1
a59 2
$delta = $Is_Dosish ? 2 : 1;	# Granularity of time on the filesystem
$foo = (utime 500000000,500000000 + $delta,'b');
d63 2
a64 5
if ($^O eq 'MSWin32') { print "ok 17 # skipped: bogus (stat)[1]\n"; }
elsif ($ino) {print "ok 17\n";} else {print "not ok 17\n";}
if ($wd =~ m#/afs/# || $^O eq 'amigaos' || $^O eq 'dos' || $^O eq 'MSWin32')
    {print "ok 18 # skipped: granularity of the filetime\n";}
elsif ($atime == 500000000 && $mtime == 500000000 + $delta)
d78 1
a78 2
if ($^O ne 'MSWin32' and `ls -l perl 2>/dev/null` =~ /^l.*->/) {
    # we have symbolic links
a81 1
    unlink 'c';
a85 38

# truncate (may not be implemented everywhere)
unlink "Iofs.tmp";
`echo helloworld > Iofs.tmp`;
eval { truncate "Iofs.tmp", 5; };
if ($@@ =~ /not implemented/) {
  print "# truncate not implemented -- skipping tests 23 through 26\n";
  for (23 .. 26) {
    print "ok $_\n";
  }
}
else {
  if (-s "Iofs.tmp" == 5) {print "ok 23\n"} else {print "not ok 23\n"}
  truncate "Iofs.tmp", 0;
  if (-z "Iofs.tmp") {print "ok 24\n"} else {print "not ok 24\n"}
  open(FH, ">Iofs.tmp") or die "Can't create Iofs.tmp";
  { select FH; $| = 1; select STDOUT }
  print FH "helloworld\n";
  truncate FH, 5;
  if ($^O eq 'dos') {
      close (FH); open (FH, ">>Iofs.tmp") or die "Can't reopen Iofs.tmp";
  }
  if (-s "Iofs.tmp" == 5) {print "ok 25\n"} else {print "not ok 25\n"}
  truncate FH, 0;
  if ($^O eq 'dos') {
      close (FH); open (FH, ">>Iofs.tmp") or die "Can't reopen Iofs.tmp";
  }
  if (-z "Iofs.tmp") {print "ok 26\n"} else {print "not ok 26\n"}
  close FH;
}

# check if rename() works on directories
rename 'tmp', 'tmp1' or print "not ";
print "ok 27\n";
-d 'tmp1' or print "not ";
print "ok 28\n";

END { rmdir 'tmp1'; unlink "Iofs.tmp"; }
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d7 1
a7 1
    unshift @@INC, '../lib';
d15 1
a15 5
if (defined &Win32::IsWinNT && Win32::IsWinNT()) {
    $Is_Dosish = '' if Win32::FsType() eq 'NTFS';
}

print "1..29\n";
d20 1
a20 1
if ($^O eq 'MSWin32') { `rmdir /s /q tmp 2>nul`; `mkdir tmp`; }
d57 1
a57 2
$newmode = $^O eq 'MSWin32' ? 0444 : 0777;
if ((chmod $newmode,'a') == 1) {print "ok 6\n";} else {print "not ok 6\n";}
d62 1
a62 1
elsif (($mode & 0777) == $newmode) {print "ok 7\n";} 
a64 6
$newmode = 0700;
if ($^O eq 'MSWin32') {
    chmod 0444, 'x';
    $newmode = 0666;
}

d66 1
a66 1
elsif ((chmod $newmode,'c','x') == 2) {print "ok 8\n";} 
d72 1
a72 1
elsif (($mode & 0777) == $newmode) {print "ok 9\n";} 
d78 1
a78 1
elsif (($mode & 0777) == $newmode) {print "ok 10\n";} 
a95 1
chmod 0777, 'b';
a143 1
  binmode FH;
d145 3
a147 9
  {
    use strict;
    print FH "x\n" x 200;
    truncate(FH, 200) or die "Can't truncate FH: $!";
  }
  if ($^O eq 'dos'
	# Not needed on HPFS, but needed on HPFS386 ?!
      or $^O eq 'os2')
  {
d150 1
a150 1
  if (-s "Iofs.tmp" == 200) {print "ok 25\n"} else {print "not ok 25\n"}
d152 1
a152 4
  if ($^O eq 'dos'
	# Not needed on HPFS, but needed on HPFS386 ?!
      or $^O eq 'os2')
  {
a158 10
# check if rename() can be used to just change case of filename
chdir './tmp';
open(fh,'>x') || die "Can't create x";
close(fh);
rename('x', 'X');
print 'not ' unless -e 'X';
print "ok 27\n";
unlink 'X';
chdir $wd || die "Can't cd back to $wd";

d161 2
a163 2
-d 'tmp1' or print "not ";
print "ok 29\n";
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d7 1
a7 1
    @@INC = '../lib';
d118 1
a118 9
elsif ($^O =~ /\blinux\b/i) {
    # Maybe stat() cannot get the correct atime, as happens via NFS on linux?
    $foo = (utime 400000000,500000000 + 2*$delta,'b');
    my ($new_atime, $new_mtime) = (stat('b'))[8,9];
    if ($new_atime == $atime && $new_mtime - $mtime == $delta)
	{print "ok 18 # accounted for possible NFS/glibc2.2 bug on linux\n";}
    else
	{print "not ok 18 $atime/$new_atime $mtime/$new_mtime\n";}
} else
d132 2
a133 6
    system("cp TEST TEST$$");
    # we have to copy because e.g. GNU grep gets huffy if we have
    # a symlink forest to another disk (it complains about too many
    # levels of symbolic links, even if we have only two)
    if (symlink("TEST$$","c")) {print "ok 21\n";} else {print "not ok 21\n";}
    $foo = `grep perl c 2>&1`;
a135 1
    unlink("TEST$$");
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d3 2
a7 1
    require "./test.pl";
a10 13
use File::Spec::Functions;

my $Is_MacOS  = ($^O eq 'MacOS');
my $Is_VMSish = ($^O eq 'VMS');

if (($^O eq 'MSWin32') || ($^O eq 'NetWare')) {
    $wd = `cd`;
} elsif ($^O eq 'VMS') {
    $wd = `show default`;
} else {
    $wd = `pwd`;
}
chomp($wd);
d12 2
a13 8
my $has_link            = $Config{d_link};
my $accurate_timestamps =
    !($^O eq 'MSWin32' || $^O eq 'NetWare' ||
      $^O eq 'dos'     || $^O eq 'os2'     ||
      $^O eq 'mint'    || $^O eq 'cygwin'  ||
      $^O eq 'amigaos' || $wd =~ m#$Config{afsroot}/# ||
      $Is_MacOS
     );
d16 1
a16 4
    if (Win32::FsType() eq 'NTFS') {
        $has_link            = 1;
        $accurate_timestamps = 1;
    }
d19 1
a19 9
my $needs_fh_reopen =
    $^O eq 'dos'
    # Not needed on HPFS, but needed on HPFS386 ?!
    || $^O eq 'os2';

$needs_fh_reopen = 1 if (defined &Win32::IsWin95 && Win32::IsWin95());

my $skip_mode_checks =
    $^O eq 'cygwin' && $ENV{CYGWIN} !~ /ntsec/;
d21 2
a22 20
plan tests => 32;


if (($^O eq 'MSWin32') || ($^O eq 'NetWare')) {
    `rmdir /s /q tmp 2>nul`;
    `mkdir tmp`;
}
elsif ($^O eq 'VMS') {
    `if f\$search("[.tmp]*.*") .nes. "" then delete/nolog/noconfirm [.tmp]*.*.*`;
    `if f\$search("tmp.dir") .nes. "" then delete/nolog/noconfirm tmp.dir;`;
    `create/directory [.tmp]`;
}
elsif ($Is_MacOS) {
    rmdir "tmp"; mkdir "tmp";
}
else {
    `rm -f tmp 2>/dev/null; mkdir tmp 2>/dev/null`;
}

chdir catdir(curdir(), 'tmp');
d24 3
d31 2
a32 6
SKIP: {
    skip "bogus umask", 1 if ($^O eq 'MSWin32') || ($^O eq 'NetWare') || ($^O eq 'epoc') || $Is_MacOS;

    is((umask(0)&0777), 022, 'umask'),
}

d38 7
a44 2
my ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,
    $blksize,$blocks);
d46 2
a47 2
SKIP: {
    skip("no link", 4) unless $has_link;
d49 11
a59 2
    ok(link('a','b'), "link a b");
    ok(link('b','c'), "link b c");
d61 2
a62 20
    ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,
     $blksize,$blocks) = stat('c');

    SKIP: {
        skip "no nlink", 1 if $Config{dont_use_nlink};

        is($nlink, 3, "link count of triply-linked file");
    }

    SKIP: {
        skip "hard links not that hard in $^O", 1 if $^O eq 'amigaos';
	skip "no mode checks", 1 if $skip_mode_checks;

#      if ($^O eq 'cygwin') { # new files on cygwin get rwx instead of rw-
#          is($mode & 0777, 0777, "mode of triply-linked file");
#      } else {
            is($mode & 0777, 0666, "mode of triply-linked file");
#      }
    }
}
d64 5
a68 3
$newmode = (($^O eq 'MSWin32') || ($^O eq 'NetWare')) ? 0444 : 0777;

is(chmod($newmode,'a'), 1, "chmod succeeding");
d70 2
a71 13
SKIP: {
    skip("no link", 7) unless $has_link;

    ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,
     $blksize,$blocks) = stat('c');

    SKIP: {
	skip "no mode checks", 1 if $skip_mode_checks;

        is($mode & 0777, $newmode, "chmod going through");
    }

    $newmode = 0700;
a73 32

    is(chmod($newmode,'c','x'), 2, "chmod two files");

    ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,
     $blksize,$blocks) = stat('c');

    SKIP: {
	skip "no mode checks", 1 if $skip_mode_checks;

        is($mode & 0777, $newmode, "chmod going through to c");
    }

    ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,
     $blksize,$blocks) = stat('x');

    SKIP: {
	skip "no mode checks", 1 if $skip_mode_checks;

        is($mode & 0777, $newmode, "chmod going through to x");
    }

    is(unlink('b','x'), 2, "unlink two files");

    ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,
     $blksize,$blocks) = stat('b');

    is($ino, undef, "ino of removed file b should be undef");

    ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,
     $blksize,$blocks) = stat('x');

    is($ino, undef, "ino of removed file x should be undef");
d76 3
a78 1
is(rename('a','b'), 1, "rename a b");
d81 4
a84 1
 $blksize,$blocks) = stat('a');
d86 15
a100 1
is($ino, undef, "ino of renamed file a should be undef");
d102 5
a106 1
$delta = $accurate_timestamps ? 1 : 2;	# Granularity of time on the filesystem
d109 1
a109 3

is($foo, 1, "utime");

d112 16
d129 1
a129 49
SKIP: {
    skip "bogus inode num", 1 if ($^O eq 'MSWin32') || ($^O eq 'NetWare');

    ok($ino,    'non-zero inode num');
}

SKIP: {
    skip "filesystem atime/mtime granularity too low", 2
      unless $accurate_timestamps;

    print "# atime - $atime  mtime - $mtime  delta - $delta\n";
    if($atime == 500000000 && $mtime == 500000000 + $delta) {
        pass('atime');
        pass('mtime');
    }
    else {
        if ($^O =~ /\blinux\b/i) {
            print "# Maybe stat() cannot get the correct atime, ".
                  "as happens via NFS on linux?\n";
            $foo = (utime 400000000,500000000 + 2*$delta,'b');
            my ($new_atime, $new_mtime) = (stat('b'))[8,9];
            print "# newatime - $new_atime  nemtime - $new_mtime\n";
            if ($new_atime == $atime && $new_mtime - $mtime == $delta) {
                pass("atime - accounted for possible NFS/glibc2.2 bug on linux");
                pass("mtime - accounted for possible NFS/glibc2.2 bug on linux");
            }
            else {
                fail("atime - $atime/$new_atime $mtime/$new_mtime");
                fail("mtime - $atime/$new_atime $mtime/$new_mtime");
            }
        }
        elsif ($^O eq 'VMS') {
            # why is this 1 second off?
            is( $atime, 500000001,          'atime' );
            is( $mtime, 500000000 + $delta, 'mtime' );
        }
        elsif ($^O eq 'beos') {
            SKIP: { skip "atime not updated", 1; }
            is($mtime, 500000001, 'mtime');
        }
        else {
            fail("atime");
            fail("mtime");
        }
    }
}

is(unlink('b'), 1, "unlink b");

d132 1
a132 1
is($ino, undef, "ino of unlinked file b should be undef");
d137 3
a139 10
# Yet another way to look for links (perhaps those that cannot be
# created by perl?).  Hopefully there is an ls utility in your
# %PATH%. N.B. that $^O is 'cygwin' on Cygwin.

SKIP: {
    skip "Win32/Netware specific test", 2
      unless ($^O eq 'MSWin32') || ($^O eq 'NetWare');
    skip "No symbolic links found to test with", 2
      unless  `ls -l perl 2>nul` =~ /^l.*->/;

d144 1
a144 1
    is(symlink("TEST$$","c"), 1, "symlink");
d146 1
a146 1
    ok($foo, "found perl in c");
d150 3
d154 1
d156 17
a172 22
open IOFSCOM, ">Iofs.tmp" or die "Could not write IOfs.tmp: $!";
print IOFSCOM 'helloworld';
close(IOFSCOM);

# TODO: pp_truncate needs to be taught about F_CHSIZE and F_FREESP,
# as per UNIX FAQ.

SKIP: {
# Check truncating a closed file.
    eval { truncate "Iofs.tmp", 5; };

    skip("no truncate - $@@", 6) if $@@;

    is(-s "Iofs.tmp", 5, "truncation to five bytes");

    truncate "Iofs.tmp", 0;

    ok(-z "Iofs.tmp",    "truncation to zero bytes");

#these steps are necessary to check if file is really truncated
#On Win95, FH is updated, but file properties aren't
    open(FH, ">Iofs.tmp") or die "Can't create Iofs.tmp";
d174 18
a191 35
    close FH;

# Check truncating an open file.
    open(FH, ">>Iofs.tmp") or die "Can't open Iofs.tmp for appending";

    binmode FH;
    select FH;
    $| = 1;
    select STDOUT;

    {
	use strict;
	print FH "x\n" x 200;
	ok(truncate(FH, 200), "fh resize to 200");
    }

    if ($needs_fh_reopen) {
	close (FH); open (FH, ">>Iofs.tmp") or die "Can't reopen Iofs.tmp";
    }

    if ($^O eq 'vos') {
        skip ("# TODO - hit VOS bug posix-973 - cannot resize an open file below the current file pos.", 3);
    }

    is(-s "Iofs.tmp", 200, "fh resize to 200 working (filename check)");

    ok(truncate(FH, 0), "fh resize to zero");

    if ($needs_fh_reopen) {
	close (FH); open (FH, ">>Iofs.tmp") or die "Can't reopen Iofs.tmp";
    }

    ok(-z "Iofs.tmp", "fh resize to zero working (filename check)");

    close FH;
d195 8
a202 15
SKIP: {
    skip "Works in Cygwin only if check_case is set to relaxed", 1
      if $^O eq 'cygwin';

    chdir './tmp';
    open(fh,'>x') || die "Can't create x";
    close(fh);
    rename('x', 'X');

    # this works on win32 only, because fs isn't casesensitive
    ok(-e 'X', "rename working");

    1 while unlink 'X';
    chdir $wd || die "Can't cd back to $wd";
}
d205 4
a208 10
if ($^O eq 'VMS') {
    # must have delete access to rename a directory
    `set file tmp.dir/protection=o:d`;
    ok(rename('tmp.dir', 'tmp1.dir'), "rename on directories") ||
      print "# errno: $!\n";
} else {
    ok(rename('tmp', 'tmp1'), "rename on directories");
}

ok(-d 'tmp1', "rename on directories working");
d210 1
a210 2
# need to remove 'tmp' if rename() in test 28 failed!
END { rmdir 'tmp1'; rmdir 'tmp'; unlink "Iofs.tmp"; }
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@d50 1
a50 1
plan tests => 34;
d274 1
a274 1
    skip("no truncate - $@@", 8) if $@@;
d306 3
a308 4
    SKIP: {
        if ($^O eq 'vos') {
	    skip ("# TODO - hit VOS bug posix-973 - cannot resize an open file below the current file pos.", 5);
	}
d310 1
a310 1
	is(-s "Iofs.tmp", 200, "fh resize to 200 working (filename check)");
d312 1
a312 1
	ok(truncate(FH, 0), "fh resize to zero");
d314 3
a316 3
	if ($needs_fh_reopen) {
	    close (FH); open (FH, ">>Iofs.tmp") or die "Can't reopen Iofs.tmp";
	}
d318 1
a318 1
	ok(-z "Iofs.tmp", "fh resize to zero working (filename check)");
d320 1
a320 23
	close FH;

	open(FH, ">>Iofs.tmp") or die "Can't open Iofs.tmp for appending";

	binmode FH;
	select FH;
	$| = 1;
	select STDOUT;

	{
	    use strict;
	    print FH "x\n" x 200;
	    ok(truncate(*FH{IO}, 100), "fh resize by IO slot");
	}

	if ($needs_fh_reopen) {
	    close (FH); open (FH, ">>Iofs.tmp") or die "Can't reopen Iofs.tmp";
	}

	is(-s "Iofs.tmp", 100, "fh resize by IO slot working");

	close FH;
    }
@


1.1.1.7
log
@perl 5.8.8 import
@
text
@d50 1
a50 1
plan tests => 42;
d81 4
a84 4
open(FH,'>x') || die "Can't create x";
close(FH);
open(FH,'>a') || die "Can't create a";
close(FH);
a168 37
SKIP: {
    skip "no fchmod", 5 unless ($Config{d_fchmod} || "") eq "define";
    ok(open(my $fh, "<", "a"), "open a");
    is(chmod(0, $fh), 1, "fchmod");
    $mode = (stat "a")[2];
    SKIP: {
        skip "no mode checks", 1 if $skip_mode_checks;
        is($mode & 0777, 0, "perm reset");
    }
    is(chmod($newmode, "a"), 1, "fchmod");
    $mode = (stat $fh)[2];
    SKIP: { 
        skip "no mode checks", 1 if $skip_mode_checks;
        is($mode & 0777, $newmode, "perm restored");
    }
}

SKIP: {
    skip "no fchown", 1 unless ($Config{d_fchown} || "") eq "define";
    open(my $fh, "<", "a");
    is(chown(-1, -1, $fh), 1, "fchown");
}

SKIP: {
    skip "has fchmod", 1 if ($Config{d_fchmod} || "") eq "define";
    open(my $fh, "<", "a");
    eval { chmod(0777, $fh); };
    like($@@, qr/^The fchmod function is unimplemented at/, "fchmod is unimplemented");
}

SKIP: {
    skip "has fchown", 1 if ($Config{d_fchown} || "") eq "define";
    open(my $fh, "<", "a");
    eval { chown(0, 0, $fh); };
    like($@@, qr/^The fchown function is unimplemented at/, "fchown is unimplemented");
}

d352 2
a353 2
    open(FH,'>x') || die "Can't create x";
    close(FH);
a374 26
# FIXME - for some reason change 26009/26011 merged as 26627 still segfaults
# after all the tests have completed:
# #0  0x08124dd0 in Perl_pop_scope (my_perl=0x81b5ec8) at scope.c:143
# #1  0x080e88d8 in Perl_pp_leave (my_perl=0x81b5ec8) at pp_hot.c:1843
# #2  0x080c7dc1 in Perl_runops_debug (my_perl=0x81b5ec8) at dump.c:1459
# #3  0x080660af in S_run_body (my_perl=0x81b5ec8, oldscope=1) at perl.c:2369
# #4  0x08065ab1 in perl_run (my_perl=0x81b5ec8) at perl.c:2286
# #5  0x080604c3 in main (argc=2, argv=0xbffffc64, env=0xbffffc70)
#     at perlmain.c:99
#
# 143         const I32 oldsave = PL_scopestack[--PL_scopestack_ix];
# (gdb) p my_perl->Tscopestack_ix
# $1 = 136787683
#

if (0) {
    # Change 26011: Re: A surprising segfault
    # to make sure only that these obfuscated sentences will not crash.

    map chmod(+()), ('')x68;
    ok(1, "extend sp in pp_chmod");

    map chown(+()), ('')x68;
    ok(1, "extend sp in pp_chown");
}

d376 1
a376 1
END { rmdir 'tmp1'; rmdir 'tmp'; 1 while unlink "Iofs.tmp"; }
@


1.1.1.8
log
@import perl 5.10.0 from CPAN
@
text
@d17 1
a17 2
}
elsif ($^O eq 'VMS') {
d19 1
a19 2
}
else {
d50 1
a50 1
plan tests => 51;
a58 1
    `if f\$search("tmp.dir") .nes. "" then set file/prot=o:rwed tmp.dir;`;
d203 1
a203 1
    like($@@, qr/^The f?chown function is unimplemented at/, "fchown is unimplemented");
d215 1
a216 1
$foo = (utime 500000000,500000000 + $delta,'b');
a217 1
check_utime_result();
d219 2
a220 5
utime undef, undef, 'b';
($atime,$mtime) = (stat 'b')[8,9];
print "# utime undef, undef --> $atime, $mtime\n";
isnt($atime, 500000000, 'atime');
isnt($mtime, 500000000 + $delta, 'mtime');
d223 3
a225 5
    skip "no futimes", 4 unless ($Config{d_futimes} || "") eq "define";
    open(my $fh, "<", 'b');
    $foo = (utime 500000000,500000000 + $delta, $fh);
    is($foo, 1, "futime");
    check_utime_result();
d228 3
d232 34
a265 51
sub check_utime_result {
    ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,
     $blksize,$blocks) = stat('b');

 SKIP: {
	skip "bogus inode num", 1 if ($^O eq 'MSWin32') || ($^O eq 'NetWare');

	ok($ino,    'non-zero inode num');
    }

 SKIP: {
	skip "filesystem atime/mtime granularity too low", 2
	    unless $accurate_timestamps;

	print "# atime - $atime  mtime - $mtime  delta - $delta\n";
	if($atime == 500000000 && $mtime == 500000000 + $delta) {
	    pass('atime');
	    pass('mtime');
	}
	else {
	    if ($^O =~ /\blinux\b/i) {
		print "# Maybe stat() cannot get the correct atime, ".
		    "as happens via NFS on linux?\n";
		$foo = (utime 400000000,500000000 + 2*$delta,'b');
		my ($new_atime, $new_mtime) = (stat('b'))[8,9];
		print "# newatime - $new_atime  nemtime - $new_mtime\n";
		if ($new_atime == $atime && $new_mtime - $mtime == $delta) {
		    pass("atime - accounted for possible NFS/glibc2.2 bug on linux");
		    pass("mtime - accounted for possible NFS/glibc2.2 bug on linux");
		}
		else {
		    fail("atime - $atime/$new_atime $mtime/$new_mtime");
		    fail("mtime - $atime/$new_atime $mtime/$new_mtime");
		}
	    }
	    elsif ($^O eq 'VMS') {
		# why is this 1 second off?
		is( $atime, 500000001,          'atime' );
		is( $mtime, 500000000 + $delta, 'mtime' );
	    }
	    elsif ($^O eq 'beos') {
            SKIP: {
		    skip "atime not updated", 1;
		}
		is($mtime, 500000001, 'mtime');
	    }
	    else {
		fail("atime");
		fail("mtime");
	    }
	}
a268 7
SKIP: {
    skip "has futimes", 1 if ($Config{d_futimes} || "") eq "define";
    open(my $fh, "<", "b") || die;
    eval { utime(undef, undef, $fh); };
    like($@@, qr/^The futimes function is unimplemented at/, "futimes is unimplemented");
}

d386 1
a386 1
      if ($ENV{'CYGWIN'} && ($ENV{'CYGWIN'} =~ /check_case:(?:adjust|strict)/));
d406 1
a406 2
}
else {
d412 16
a427 1
{
@


1.1.1.9
log
@import perl 5.10.1
@
text
@a53 2
my $tmpdir = tempfile();
my $tmpdir1 = tempfile();
d56 2
a57 2
    `rmdir /s /q $tmpdir 2>nul`;
    `mkdir $tmpdir`;
d60 4
a63 4
    `if f\$search("[.$tmpdir]*.*") .nes. "" then delete/nolog/noconfirm [.$tmpdir]*.*.*`;
    `if f\$search("$tmpdir.dir") .nes. "" then set file/prot=o:rwed $tmpdir.dir;`;
    `if f\$search("$tmpdir.dir") .nes. "" then delete/nolog/noconfirm $tmpdir.dir;`;
    `create/directory [.$tmpdir]`;
d66 1
a66 1
    rmdir "$tmpdir"; mkdir "$tmpdir";
d69 1
a69 1
    `rm -f $tmpdir 2>/dev/null; mkdir $tmpdir 2>/dev/null`;
d72 1
a72 1
chdir catdir(curdir(), $tmpdir);
d90 1
a90 1
    $blksize,$blocks,$a_mode);
a97 2
    $a_mode = (stat('a'))[2];

d114 1
a114 3
            is(sprintf("0%o", $mode & 0777), 
               sprintf("0%o", $a_mode & 0777), 
               "mode of triply-linked file");
d278 1
a278 1
	    elsif ($^O eq 'beos' || $^O eq 'haiku') {
d329 2
a330 2
my $tmpfile = tempfile();
open IOFSCOM, ">$tmpfile" or die "Could not write IOfs.tmp: $!";
d339 1
a339 1
    eval { truncate $tmpfile, 5; };
d343 1
a343 1
    is(-s $tmpfile, 5, "truncation to five bytes");
d345 1
a345 1
    truncate $tmpfile, 0;
d347 1
a347 1
    ok(-z $tmpfile,    "truncation to zero bytes");
d351 1
a351 1
    open(FH, ">$tmpfile") or die "Can't create $tmpfile";
d356 1
a356 1
    open(FH, ">>$tmpfile") or die "Can't open $tmpfile for appending";
d370 1
a370 1
	close (FH); open (FH, ">>$tmpfile") or die "Can't reopen $tmpfile";
d378 1
a378 1
	is(-s $tmpfile, 200, "fh resize to 200 working (filename check)");
d383 1
a383 1
	    close (FH); open (FH, ">>$tmpfile") or die "Can't reopen $tmpfile";
d386 1
a386 1
	ok(-z $tmpfile, "fh resize to zero working (filename check)");
d390 1
a390 1
	open(FH, ">>$tmpfile") or die "Can't open $tmpfile for appending";
d404 1
a404 1
	    close (FH); open (FH, ">>$tmpfile") or die "Can't reopen $tmpfile";
d407 1
a407 1
	is(-s $tmpfile, 100, "fh resize by IO slot working");
d418 1
a418 1
    chdir "./$tmpdir";
d433 2
a434 2
    `set file $tmpdir.dir/protection=o:d`;
    ok(rename("$tmpdir.dir", "$tmpdir1.dir"), "rename on directories") ||
d438 1
a438 1
    ok(rename($tmpdir, $tmpdir1), "rename on directories");
d441 1
a441 1
ok(-d $tmpdir1, "rename on directories working");
d454 2
a455 2
# need to remove $tmpdir if rename() in test 28 failed!
END { rmdir $tmpdir1; rmdir $tmpdir; }
@


1.1.1.10
log
@Perl 5.12.2 from CPAN
@
text
@d12 1
d30 3
a32 2
      $^O eq 'cygwin'  || $^O eq 'amigaos' ||
	  $wd =~ m#$Config{afsroot}/#
d67 3
d81 1
a81 1
    skip "bogus umask", 1 if ($^O eq 'MSWin32') || ($^O eq 'NetWare') || ($^O eq 'epoc');
@


1.1.1.11
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d10 1
d69 1
a69 1
chdir $tmpdir;
d427 1
a427 1
    unlink_all 'X';
@


1.1.1.12
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d49 1
a49 1
plan tests => 52;
d75 1
a75 1
    skip "bogus umask", 1 if ($^O eq 'MSWin32') || ($^O eq 'NetWare');
d278 1
a278 1
	    elsif ($^O eq 'haiku') {
d375 1
a375 1
	    skip ("# TODO - hit VOS bug posix-973 - cannot resize an open file below the current file pos.", 6);
a409 8

	my $n = "for_fs_dot_t$$";
	open FH, ">$n" or die "open $n: $!";
	print FH "bloh blah bla\n";
	close FH or die "close $n: $!";
	eval "truncate $n, 0; 1" or die;
	ok !-z $n, 'truncate(word) does not fall back to file name';
	unlink $n;
@


1.1.1.13
log
@Import perl-5.20.1
@
text
@a18 5
elsif ( $^O =~ /android/ || $^O eq 'nto' ) {
    # On Android and Blackberry 10, pwd is a shell builtin, so plain `pwd`
    # won't cut it
    $wd = `sh -c pwd`;
}
a23 2
die "Can't get current working directory" if(!$wd);

a36 3
    else {
        $has_link            = 0;
    }
d49 1
a49 1
plan tests => 55;
a251 4
     if ($^O eq 'vos') {
	    skip ("# TODO - hit VOS bug posix-2055 - access time does not follow POSIX rules for an open file.", 2);
     }

d306 1
a306 1
chdir $wd || die "Can't cd back to '$wd' ($!)";
d373 5
d418 1
a459 29
}

# Calling unlink on a directory without -U and privileges will always fail, but
# it should set errno to EISDIR even though unlink(2) is never called.
{
    require Errno;

    my $tmpdir = tempfile();
    if (($^O eq 'MSWin32') || ($^O eq 'NetWare')) {
        `mkdir $tmpdir`;
    }
    elsif ($^O eq 'VMS') {
        `create/directory [.$tmpdir]`;
    }
    else {
        `mkdir $tmpdir 2>/dev/null`;
    }

    # errno should be set even though unlink(2) is not called
    local $!;
    is(unlink($tmpdir), 0, "can't unlink directory without -U and privileges");
    is(0+$!, Errno::EISDIR(), "unlink directory without -U sets errno");

    rmdir $tmpdir;

    # errno should be set by failed lstat(2) call
    $! = 0;
    unlink($tmpdir);
    is(0+$!, Errno::ENOENT(), "unlink non-existent directory without -U sets ENOENT");
@


1.1.1.14
log
@Import perl-5.24.2
@
text
@a12 6
if ($^O eq 'MSWin32') {
    # under minitest, buildcustomize sets this to 1, which means
    # nlinks isn't populated properly, allow our tests to pass
    ${^WIN32_SLOPPY_STAT} = 0;
}

d59 1
a59 1
plan tests => 61;
d183 1
a183 1
    skip "no fchmod", 7 unless ($Config{d_fchmod} || "") eq "define";
a196 6

    # [perl #122703]
    close $fh;
    $! = 0;
    ok(!chmod(0666, $fh), "chmod through closed handle fails");
    isnt($!+0, 0, "and errno was set");
d200 1
a200 1
    skip "no fchown", 3 unless ($Config{d_fchown} || "") eq "define";
d202 1
a202 9
    is(chown($<, $(, $fh), 1, "fchown");

    # [perl #122703]
    # chown() behaved correctly, but there was no test for the chown()
    # on closed handle case
    close $fh;
    $! = 0;
    ok(!chown($<, $(, $fh), "chown on closed handle fails");
    isnt($!+0, 0, "and errno was set");
d240 1
a240 1
    skip "no futimes", 6 unless ($Config{d_futimes} || "") eq "define";
a244 5
    # [perl #122703]
    close $fh;
    ok(!utime(500000000,500000000 + $delta, $fh),
       "utime fails on a closed file handle");
    isnt($!+0, 0, "and errno was set");
d472 1
a472 4
SKIP: {
    if (is_miniperl && !eval 'require Errno') {
        skip "Errno not built yet", 3;
    }
@


