head	1.11;
access;
symbols
	OPENBSD_6_2:1.11.0.14
	OPENBSD_6_2_BASE:1.11
	PERL_5_24_2:1.1.1.10
	OPENBSD_6_1:1.11.0.12
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.11.0.10
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.4
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.11.0.6
	OPENBSD_5_8_BASE:1.11
	PERL_5_20_2:1.1.1.10
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	PERL_5_20_1:1.1.1.10
	OPENBSD_5_6:1.10.0.4
	OPENBSD_5_6_BASE:1.10
	PERL_5_18_2:1.1.1.9
	PERL:1.1.1
	OPENBSD_5_5:1.9.0.16
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.12
	OPENBSD_5_4_BASE:1.9
	PERL_5_16_3:1.1.1.8
	OPENBSD_5_3:1.9.0.10
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.8
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.6
	OPENBSD_5_0:1.9.0.4
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.2
	OPENBSD_4_9_BASE:1.9
	PERL_5_12_2:1.1.1.8
	OPENBSD_4_8:1.8.0.8
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.4
	OPENBSD_4_7_BASE:1.8
	PERL_5_10_1:1.1.1.7
	OPENBSD_4_6:1.8.0.6
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.2
	OPENBSD_4_5_BASE:1.8
	PERL_5_10_0:1.1.1.7
	OPENBSD_4_4:1.7.0.10
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.8
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.6
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.4
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.2
	OPENBSD_4_0_BASE:1.7
	PERL_5_8_8:1.1.1.6
	OPENBSD_3_9:1.6.0.14
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.12
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.10
	OPENBSD_3_7_BASE:1.6
	PERL_5_8_6:1.1.1.5
	OPENBSD_3_6:1.6.0.8
	OPENBSD_3_6_BASE:1.6
	PERL_5_8_5:1.1.1.5
	PERL_5_8_3:1.1.1.5
	OPENBSD_3_5:1.6.0.6
	OPENBSD_3_5_BASE:1.6
	PERL_5_8_2:1.1.1.5
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.11
date	2014.11.17.20.57.07;	author afresh1;	state Exp;
branches;
next	1.10;
commitid	QP75iYx42Uo7mMxO;

1.10
date	2014.03.24.15.05.33;	author afresh1;	state Exp;
branches;
next	1.9;

1.9
date	2010.09.24.15.07.05;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2008.09.29.17.36.18;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2006.03.28.19.23.12;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.35;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.36.07;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.08.01;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.52.28;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.08.00.16;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.13.13;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.13.13;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.41.22;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.10.39;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.25.05;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.15.10;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2006.03.28.18.49.41;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2008.09.29.17.18.58;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2010.09.24.14.49.19;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2014.03.24.14.59.09;	author afresh1;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2014.11.17.20.53.17;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.11
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@#!./perl

BEGIN {
    chdir 't' if -d 't';
    @@INC = '../lib';
    require Config; import Config;
    require './test.pl';

    if (!$Config{'d_fork'}) {
        skip_all("fork required to pipe");
    }
    else {
        plan(tests => 24);
    }
}

my $Perl = which_perl();


$| = 1;

open(PIPE, "|-") || exec $Perl, '-pe', 'tr/YX/ko/';

printf PIPE "Xk %d - open |- || exec\n", curr_test();
next_test();
printf PIPE "oY %d -    again\n", curr_test();
next_test();
close PIPE;

{
    if (open(PIPE, "-|")) {
	while(<PIPE>) {
	    s/^not //;
	    print;
	}
	close PIPE;        # avoid zombies
    }
    else {
	printf STDOUT "not ok %d - open -|\n", curr_test();
        next_test();
        my $tnum = curr_test;
        next_test();
	exec $Perl, '-le', "print q{not ok $tnum -     again}";
    }

    # This has to be *outside* the fork
    next_test() for 1..2;

    my $raw = "abc\nrst\rxyz\r\nfoo\n";
    if (open(PIPE, "-|")) {
	$_ = join '', <PIPE>;
	(my $raw1 = $_) =~ s/not ok \d+ - //;
	my @@r  = map ord, split //, $raw;
	my @@r1 = map ord, split //, $raw1;
        if ($raw1 eq $raw) {
	    s/^not (ok \d+ -) .*/$1 '@@r1' passes through '-|'\n/s;
	} else {
	    s/^(not ok \d+ -) .*/$1 expect '@@r', got '@@r1'\n/s;
	}
	print;
	close PIPE;        # avoid zombies
    }
    else {
	printf STDOUT "not ok %d - $raw", curr_test();
        exec $Perl, '-e0';	# Do not run END()...
    }

    # This has to be *outside* the fork
    next_test();

    if (open(PIPE, "|-")) {
	printf PIPE "not ok %d - $raw", curr_test();
	close PIPE;        # avoid zombies
    }
    else {
	$_ = join '', <STDIN>;
	(my $raw1 = $_) =~ s/not ok \d+ - //;
	my @@r  = map ord, split //, $raw;
	my @@r1 = map ord, split //, $raw1;
        if ($raw1 eq $raw) {
	    s/^not (ok \d+ -) .*/$1 '@@r1' passes through '|-'\n/s;
	} else {
	    s/^(not ok \d+ -) .*/$1 expect '@@r', got '@@r1'\n/s;
	}
	print;
        exec $Perl, '-e0';	# Do not run END()...
    }

    # This has to be *outside* the fork
    next_test();

    SKIP: {
        skip "fork required", 2 unless $Config{d_fork};

        pipe(READER,WRITER) || die "Can't open pipe";

        if ($pid = fork) {
            close WRITER;
            while(<READER>) {
                s/^not //;
                y/A-Z/a-z/;
                print;
            }
            close READER;     # avoid zombies
        }
        else {
            die "Couldn't fork" unless defined $pid;
            close READER;
            printf WRITER "not ok %d - pipe & fork\n", curr_test;
            next_test;

            open(STDOUT,">&WRITER") || die "Can't dup WRITER to STDOUT";
            close WRITER;
            
            my $tnum = curr_test;
            next_test;
            exec $Perl, '-le', "print q{not ok $tnum -     with fh dup }";
        }

        # This has to be done *outside* the fork.
        next_test() for 1..2;
    }
} 
wait;				# Collect from $pid

pipe(READER,WRITER) || die "Can't open pipe";
close READER;

$SIG{'PIPE'} = 'broken_pipe';

sub broken_pipe {
    $SIG{'PIPE'} = 'IGNORE';       # loop preventer
    printf "ok %d - SIGPIPE\n", curr_test;
}

printf WRITER "not ok %d - SIGPIPE\n", curr_test;
close WRITER;
sleep 1;
next_test;
pass();

# VMS doesn't like spawning subprocesses that are still connected to
# STDOUT.  Someone should modify these tests to work with VMS.

SKIP: {
    skip "doesn't like spawning subprocesses that are still connected", 10
      if $^O eq 'VMS';

    SKIP: {
        # POSIX-BC doesn't report failure when closing a broken pipe
        # that has pending output.  Go figure.
        skip "Won't report failure on broken pipe", 1
          if $^O eq 'posix-bc';

        local $SIG{PIPE} = 'IGNORE';
        open NIL, qq{|$Perl -e "exit 0"} or die "open failed: $!";
        sleep 5;
        if (print NIL 'foo') {
            # If print was allowed we had better get an error on close
            ok( !close NIL,     'close error on broken pipe' );
        }
        else {
            ok(close NIL,       'print failed on broken pipe');
        }
    }

    {
        # check that errno gets forced to 0 if the piped program exited 
        # non-zero
        open NIL, qq{|$Perl -e "exit 23";} or die "fork failed: $!";
        $! = 1;
        ok(!close NIL,  'close failure on non-zero piped exit');
        is($!, '',      '       errno');
        isnt($?, 0,     '       status');

	# Former skip block:
        {
            # check that status for the correct process is collected
            my $zombie;
            unless( $zombie = fork ) {
                $NO_ENDING=1;
                exit 37;
            }
            my $pipe = open *FH, "sleep 2;exit 13|" or die "Open: $!\n";
            $SIG{ALRM} = sub { return };
            alarm(1);
            is( close FH, '',   'close failure for... umm, something' );
            is( $?, 13*256,     '       status' );
            is( $!, '',         '       errno');

            my $wait = wait;
            is( $?, 37*256,     'status correct after wait' );
            is( $wait, $zombie, '       wait pid' );
            is( $!, '',         '       errno');
        }
    }
}

# Test new semantics for missing command in piped open
# 19990114 M-J. Dominus mjd@@plover.com
{ local *P;
  no warnings 'pipe';
  ok( !open(P, "|    "),        'missing command in piped open input' );
  ok( !open(P, "     |"),       '                              output');
}

# check that status is unaffected by implicit close
{
    local(*NIL);
    open NIL, qq{|$Perl -e "exit 23"} or die "fork failed: $!";
    $? = 42;
    # NIL implicitly closed here
}
is($?, 42,      'status unaffected by implicit close');
$? = 0;

# check that child is reaped if the piped program can't be executed
SKIP: {
  skip "/no_such_process exists", 1 if -e "/no_such_process";
  open NIL, '/no_such_process |';
  close NIL;

  my $child = 0;
  eval {
    local $SIG{ALRM} = sub { die; };
    alarm 2;
    $child = wait;
    alarm 0;
  };

  is($child, -1, 'child reaped if piped program cannot be executed');
}
@


1.10
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d150 1
a150 1
        # Sfio doesn't report failure when closing a broken pipe
a151 1
        # Nor does POSIX-BC.
d153 1
a153 1
          if $Config{d_sfio} || $^O eq 'posix-bc';
@


1.9
log
@merge in perl 5.12.2 plus local changes
@
text
@d30 1
a30 5
SKIP: {
    # Technically this should be TODO.  Someone try it if you happen to
    # have a vmesa machine.
    skip "Doesn't work here yet", 6 if $^O eq 'vmesa';

a151 1
        # BeOS will not write to broken pipes, either.
d154 1
a154 2
          if $Config{d_sfio} || $^O eq 'beos' ||
             $^O eq 'posix-bc';
d168 1
a168 3
    SKIP: {
        skip "Don't work yet", 9 if $^O eq 'vmesa';

d177 2
a178 3
        SKIP: {
            skip "Don't work yet", 6 if $^O eq 'mpeix';

@


1.8
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d155 1
a155 2
        # that has pending output.  Go figure.  MachTen doesn't either,
        # but won't write to broken pipes, so nothing's pending at close.
d159 1
a159 1
          if $Config{d_sfio} || $^O eq 'machten' || $^O eq 'beos' || 
@


1.7
log
@merge in perl 5.8.8
@
text
@d13 1
a13 1
        plan(tests => 22);
d33 1
a33 1
    skip "Doesn't work here yet", 4 if $^O eq 'vmesa';
d53 43
d213 1
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d185 2
a186 1
{
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d7 7
a13 3
    unless ($Config{'d_fork'}) {
	print "1..0 # Skip: no fork\n";
	exit 0;
d17 3
a20 1
print "1..15\n";
d22 6
a27 4
# External program 'tr' assumed.
open(PIPE, "|-") || (exec 'tr', 'YX', 'ko');
print PIPE "Xk 1\n";
print PIPE "oY 2\n";
d30 5
a34 6
if ($^O eq 'vmesa') {
    # Doesn't work, yet.
    for (3..6) {
	print "ok $_ # skipped\n";
    }
} else {
d40 1
a40 1
	close PIPE;        # avoid zombies which disrupt test 12
d43 37
a79 4
	# External program 'echo' assumed.
	print STDOUT "not ok 3\n";
	exec 'echo', 'not ok 4';
    }
d81 2
a82 10
    pipe(READER,WRITER) || die "Can't open pipe";

    if ($pid = fork) {
	close WRITER;
	while(<READER>) {
	    s/^not //;
	    y/A-Z/a-z/;
	    print;
	}
	close READER;     # avoid zombies which disrupt test 12
d84 1
a84 10
    else {
	die "Couldn't fork" unless defined $pid;
	close READER;
	print WRITER "not ok 5\n";
	open(STDOUT,">&WRITER") || die "Can't dup WRITER to STDOUT";
	close WRITER;
	# External program 'echo' assumed.
	exec 'echo', 'not ok 6';
    }
}
d94 1
a94 1
    print "ok 7\n";
d97 1
a97 1
print WRITER "not ok 7\n";
d100 2
a101 1
print "ok 8\n";
d104 1
a104 30
# STDOUT.  Someone should modify tests #9 to #12 to work with VMS.

if ($^O eq 'VMS') {
    print "ok 9 # skipped\n";
    print "ok 10 # skipped\n";
    print "ok 11 # skipped\n";
    print "ok 12 # skipped\n";
    exit;
}

if ($Config{d_sfio} || $^O eq 'machten' || $^O eq 'beos' || $^O eq 'posix-bc') {
    # Sfio doesn't report failure when closing a broken pipe
    # that has pending output.  Go figure.  MachTen doesn't either,
    # but won't write to broken pipes, so nothing's pending at close.
    # BeOS will not write to broken pipes, either.
    # Nor does POSIX-BC.
    print "ok 9 # skipped\n";
}
else {
    local $SIG{PIPE} = 'IGNORE';
    open NIL, '|true'	or die "open failed: $!";
    sleep 5;
    print NIL 'foo'	or die "print failed: $!";
    if (close NIL) {
	print "not ok 9\n";
    }
    else {
	print "ok 9\n";
    }
}
d106 58
a163 44
if ($^O eq 'vmesa') {
    # These don't work, yet.
    print "ok 10 # skipped\n";
    print "ok 11 # skipped\n";
    print "ok 12 # skipped\n";
    exit;
}

# check that errno gets forced to 0 if the piped program exited non-zero
open NIL, '|exit 23;' or die "fork failed: $!";
$! = 1;
if (close NIL) {
    print "not ok 10\n# successful close\n";
}
elsif ($! != 0) {
    print "not ok 10\n# errno $!\n";
}
elsif ($? == 0) {
    print "not ok 10\n# status 0\n";
}
else {
    print "ok 10\n";
}

if ($^O eq 'mpeix') {
    print "ok 11 # skipped\n";
    print "ok 12 # skipped\n";
} else {
    # check that status for the correct process is collected
    my $zombie = fork or exit 37;
    my $pipe = open *FH, "sleep 2;exit 13|" or die "Open: $!\n";
    $SIG{ALRM} = sub { return };
    alarm(1);
    my $close = close FH;
    if ($? == 13*256 && ! length $close && ! $!) {
        print "ok 11\n";
    } else {
        print "not ok 11\n# close $close\$?=$?   \$!=", $!+0, ":$!\n";
    };
    my $wait = wait;
    if ($? == 37*256 && $wait == $zombie && ! $!) {
        print "ok 12\n";
    } else {
        print "not ok 12\n# pid=$wait first=$pid pipe=$pipe zombie=$zombie me=$$ \$?=$?   \$!=", $!+0, ":$!\n";
d170 2
a171 2
  print (((open P, "|    " ) ? "not " : ""), "ok 13\n");
  print (((open P, "     |" ) ? "not " : ""), "ok 14\n");
d177 1
a177 1
    open NIL, '|exit 23;' or die "fork failed: $!";
d181 17
a197 2
if ($? != 42) {
    print "# status $?, expected 42\nnot ";
a198 2
print "ok 15\n";
$? = 0;
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d5 1
a5 1
    unshift @@INC, '../lib';
@


1.3
log
@perl5.005_03 (stock)
@
text
@a2 2
# $RCSfile: pipe.t,v $$Revision: 4.1 $$Date: 92/08/07 18:27:31 $

d5 1
a5 1
    @@INC = '../lib';
d8 1
a8 1
	print "1..0\n";
d14 1
a14 1
print "1..12\n";
d16 1
d22 17
a38 4
if (open(PIPE, "-|")) {
    while(<PIPE>) {
	s/^not //;
	print;
a39 6
    close PIPE;        # avoid zombies which disrupt test 12
}
else {
    print STDOUT "not ok 3\n";
    exec 'echo', 'not ok 4';
}
d41 1
a41 1
pipe(READER,WRITER) || die "Can't open pipe";
d43 17
a59 6
if ($pid = fork) {
    close WRITER;
    while(<READER>) {
	s/^not //;
	y/A-Z/a-z/;
	print;
a60 1
    close READER;     # avoid zombies which disrupt test 12
d62 1
a62 9
else {
    die "Couldn't fork" unless defined $pid;
    close READER;
    print WRITER "not ok 5\n";
    open(STDOUT,">&WRITER") || die "Can't dup WRITER to STDOUT";
    close WRITER;
    exec 'echo', 'not ok 6';
}

d83 4
a86 4
    print "ok 9\n";
    print "ok 10\n";
    print "ok 11\n";
    print "ok 12\n";
d90 1
a90 1
if ($Config{d_sfio} || $^O eq machten || $^O eq beos) {
d95 2
a96 1
    print "ok 9\n";
d101 1
a101 1
    sleep 2;
d111 8
d135 3
a137 9
# check that status for the correct process is collected
wait;				# Collect from $pid
my $zombie = fork or exit 37;
my $pipe = open *FH, "sleep 2;exit 13|" or die "Open: $!\n";
$SIG{ALRM} = sub { return };
alarm(1);
my $close = close FH;
if ($? == 13*256 && ! length $close && ! $!) {
    print "ok 11\n";
d139 35
a173 7
    print "not ok 11\n# close $close\$?=$?   \$!=", $!+0, ":$!\n";
};
my $wait = wait;
if ($? == 37*256 && $wait == $zombie && ! $!) {
    print "ok 12\n";
} else {
    print "not ok 12\n# pid=$wait first=$pid pipe=$pipe zombie=$zombie me=$$ \$?=$?   \$!=", $!+0, ":$!\n";
d175 2
@


1.2
log
@perl 5.004_04
@
text
@d16 1
a16 1
print "1..10\n";
d28 1
d44 1
d62 1
d68 1
a68 1

d72 1
a72 1
# STDOUT.  Someone should modify tests #9 and #10 to work with VMS.
d77 2
d82 1
a82 1
if ($Config{d_sfio} || $^O eq machten) {
d86 1
d116 19
@


1.1
log
@Initial revision
@
text
@d5 10
d16 1
a16 1
print "1..8\n";
d67 44
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@a4 10
BEGIN {
    chdir 't' if -d 't';
    @@INC = '../lib';
    require Config; import Config;
    unless ($Config{'d_fork'}) {
	print "1..0\n";
	exit 0;
    }
}

d6 1
a6 1
print "1..12\n";
a17 1
    close PIPE;        # avoid zombies which disrupt test 12
a32 1
    close READER;     # avoid zombies which disrupt test 12
a49 1
    $SIG{'PIPE'} = 'IGNORE';       # loop preventer
d55 1
a55 1
sleep 1;
a56 66

# VMS doesn't like spawning subprocesses that are still connected to
# STDOUT.  Someone should modify tests #9 to #12 to work with VMS.

if ($^O eq 'VMS') {
    print "ok 9\n";
    print "ok 10\n";
    print "ok 11\n";
    print "ok 12\n";
    exit;
}

if ($Config{d_sfio} || $^O eq machten || $^O eq beos) {
    # Sfio doesn't report failure when closing a broken pipe
    # that has pending output.  Go figure.  MachTen doesn't either,
    # but won't write to broken pipes, so nothing's pending at close.
    # BeOS will not write to broken pipes, either.
    print "ok 9\n";
}
else {
    local $SIG{PIPE} = 'IGNORE';
    open NIL, '|true'	or die "open failed: $!";
    sleep 2;
    print NIL 'foo'	or die "print failed: $!";
    if (close NIL) {
	print "not ok 9\n";
    }
    else {
	print "ok 9\n";
    }
}

# check that errno gets forced to 0 if the piped program exited non-zero
open NIL, '|exit 23;' or die "fork failed: $!";
$! = 1;
if (close NIL) {
    print "not ok 10\n# successful close\n";
}
elsif ($! != 0) {
    print "not ok 10\n# errno $!\n";
}
elsif ($? == 0) {
    print "not ok 10\n# status 0\n";
}
else {
    print "ok 10\n";
}

# check that status for the correct process is collected
wait;				# Collect from $pid
my $zombie = fork or exit 37;
my $pipe = open *FH, "sleep 2;exit 13|" or die "Open: $!\n";
$SIG{ALRM} = sub { return };
alarm(1);
my $close = close FH;
if ($? == 13*256 && ! length $close && ! $!) {
    print "ok 11\n";
} else {
    print "not ok 11\n# close $close\$?=$?   \$!=", $!+0, ":$!\n";
};
my $wait = wait;
if ($? == 37*256 && $wait == $zombie && ! $!) {
    print "ok 12\n";
} else {
    print "not ok 12\n# pid=$wait first=$pid pipe=$pipe zombie=$zombie me=$$ \$?=$?   \$!=", $!+0, ":$!\n";
}
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d3 2
d7 1
a7 1
    unshift @@INC, '../lib';
d10 1
a10 1
	print "1..0 # Skip: no fork\n";
d16 1
a16 1
print "1..15\n";
a17 1
# External program 'tr' assumed.
d23 4
a26 17
if ($^O eq 'vmesa') {
    # Doesn't work, yet.
    for (3..6) {
	print "ok $_ # skipped\n";
    }
} else {
    if (open(PIPE, "-|")) {
	while(<PIPE>) {
	    s/^not //;
	    print;
	}
	close PIPE;        # avoid zombies which disrupt test 12
    }
    else {
	# External program 'echo' assumed.
	print STDOUT "not ok 3\n";
	exec 'echo', 'not ok 4';
d28 6
d35 1
a35 1
    pipe(READER,WRITER) || die "Can't open pipe";
d37 6
a42 17
    if ($pid = fork) {
	close WRITER;
	while(<READER>) {
	    s/^not //;
	    y/A-Z/a-z/;
	    print;
	}
	close READER;     # avoid zombies which disrupt test 12
    }
    else {
	die "Couldn't fork" unless defined $pid;
	close READER;
	print WRITER "not ok 5\n";
	open(STDOUT,">&WRITER") || die "Can't dup WRITER to STDOUT";
	close WRITER;
	# External program 'echo' assumed.
	exec 'echo', 'not ok 6';
d44 9
d54 1
a54 1
wait;				# Collect from $pid
d75 4
a78 4
    print "ok 9 # skipped\n";
    print "ok 10 # skipped\n";
    print "ok 11 # skipped\n";
    print "ok 12 # skipped\n";
d82 1
a82 1
if ($Config{d_sfio} || $^O eq 'machten' || $^O eq 'beos' || $^O eq 'posix-bc') {
d87 1
a87 2
    # Nor does POSIX-BC.
    print "ok 9 # skipped\n";
d92 1
a92 1
    sleep 5;
a101 8
if ($^O eq 'vmesa') {
    # These don't work, yet.
    print "ok 10 # skipped\n";
    print "ok 11 # skipped\n";
    print "ok 12 # skipped\n";
    exit;
}

d118 15
a132 3
if ($^O eq 'mpeix') {
    print "ok 11 # skipped\n";
    print "ok 12 # skipped\n";
d134 1
a134 35
    # check that status for the correct process is collected
    my $zombie = fork or exit 37;
    my $pipe = open *FH, "sleep 2;exit 13|" or die "Open: $!\n";
    $SIG{ALRM} = sub { return };
    alarm(1);
    my $close = close FH;
    if ($? == 13*256 && ! length $close && ! $!) {
        print "ok 11\n";
    } else {
        print "not ok 11\n# close $close\$?=$?   \$!=", $!+0, ":$!\n";
    };
    my $wait = wait;
    if ($? == 37*256 && $wait == $zombie && ! $!) {
        print "ok 12\n";
    } else {
        print "not ok 12\n# pid=$wait first=$pid pipe=$pipe zombie=$zombie me=$$ \$?=$?   \$!=", $!+0, ":$!\n";
    }
}

# Test new semantics for missing command in piped open
# 19990114 M-J. Dominus mjd@@plover.com
{ local *P;
  print (((open P, "|    " ) ? "not " : ""), "ok 13\n");
  print (((open P, "     |" ) ? "not " : ""), "ok 14\n");
}

# check that status is unaffected by implicit close
{
    local(*NIL);
    open NIL, '|exit 23;' or die "fork failed: $!";
    $? = 42;
    # NIL implicitly closed here
}
if ($? != 42) {
    print "# status $?, expected 42\nnot ";
a135 2
print "ok 15\n";
$? = 0;
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d5 1
a5 1
    @@INC = '../lib';
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d7 3
a9 7
    require './test.pl';

    if (!$Config{'d_fork'}) {
        skip_all("fork required to pipe");
    }
    else {
        plan(tests => 22);
a12 3
my $Perl = which_perl();


d14 1
d16 4
a19 6
open(PIPE, "|-") || exec $Perl, '-pe', 'tr/YX/ko/';

printf PIPE "Xk %d - open |- || exec\n", curr_test();
next_test();
printf PIPE "oY %d -    again\n", curr_test();
next_test();
d22 6
a27 5
SKIP: {
    # Technically this should be TODO.  Someone try it if you happen to
    # have a vmesa machine.
    skip "Doesn't work here yet", 4 if $^O eq 'vmesa';

d33 1
a33 1
	close PIPE;        # avoid zombies
d36 4
a39 37
	printf STDOUT "not ok %d - open -|\n", curr_test();
        next_test();
        my $tnum = curr_test;
        next_test();
	exec $Perl, '-le', "print q{not ok $tnum -     again}";
    }

    # This has to be *outside* the fork
    next_test() for 1..2;

    SKIP: {
        skip "fork required", 2 unless $Config{d_fork};

        pipe(READER,WRITER) || die "Can't open pipe";

        if ($pid = fork) {
            close WRITER;
            while(<READER>) {
                s/^not //;
                y/A-Z/a-z/;
                print;
            }
            close READER;     # avoid zombies
        }
        else {
            die "Couldn't fork" unless defined $pid;
            close READER;
            printf WRITER "not ok %d - pipe & fork\n", curr_test;
            next_test;

            open(STDOUT,">&WRITER") || die "Can't dup WRITER to STDOUT";
            close WRITER;
            
            my $tnum = curr_test;
            next_test;
            exec $Perl, '-le', "print q{not ok $tnum -     with fh dup }";
        }
d41 10
a50 2
        # This has to be done *outside* the fork.
        next_test() for 1..2;
d52 10
a61 1
} 
d71 1
a71 1
    printf "ok %d - SIGPIPE\n", curr_test;
d74 1
a74 1
printf WRITER "not ok %d - SIGPIPE\n", curr_test;
d77 1
a77 2
next_test;
pass();
d80 30
a109 1
# STDOUT.  Someone should modify these tests to work with VMS.
d111 44
a154 58
SKIP: {
    skip "doesn't like spawning subprocesses that are still connected", 10
      if $^O eq 'VMS';

    SKIP: {
        # Sfio doesn't report failure when closing a broken pipe
        # that has pending output.  Go figure.  MachTen doesn't either,
        # but won't write to broken pipes, so nothing's pending at close.
        # BeOS will not write to broken pipes, either.
        # Nor does POSIX-BC.
        skip "Won't report failure on broken pipe", 1
          if $Config{d_sfio} || $^O eq 'machten' || $^O eq 'beos' || 
             $^O eq 'posix-bc';

        local $SIG{PIPE} = 'IGNORE';
        open NIL, qq{|$Perl -e "exit 0"} or die "open failed: $!";
        sleep 5;
        if (print NIL 'foo') {
            # If print was allowed we had better get an error on close
            ok( !close NIL,     'close error on broken pipe' );
        }
        else {
            ok(close NIL,       'print failed on broken pipe');
        }
    }

    SKIP: {
        skip "Don't work yet", 9 if $^O eq 'vmesa';

        # check that errno gets forced to 0 if the piped program exited 
        # non-zero
        open NIL, qq{|$Perl -e "exit 23";} or die "fork failed: $!";
        $! = 1;
        ok(!close NIL,  'close failure on non-zero piped exit');
        is($!, '',      '       errno');
        isnt($?, 0,     '       status');

        SKIP: {
            skip "Don't work yet", 6 if $^O eq 'mpeix';

            # check that status for the correct process is collected
            my $zombie;
            unless( $zombie = fork ) {
                $NO_ENDING=1;
                exit 37;
            }
            my $pipe = open *FH, "sleep 2;exit 13|" or die "Open: $!\n";
            $SIG{ALRM} = sub { return };
            alarm(1);
            is( close FH, '',   'close failure for... umm, something' );
            is( $?, 13*256,     '       status' );
            is( $!, '',         '       errno');

            my $wait = wait;
            is( $?, 37*256,     'status correct after wait' );
            is( $wait, $zombie, '       wait pid' );
            is( $!, '',         '       errno');
        }
d161 2
a162 2
  ok( !open(P, "|    "),        'missing command in piped open input' );
  ok( !open(P, "     |"),       '                              output');
d168 1
a168 1
    open NIL, qq{|$Perl -e "exit 23"} or die "fork failed: $!";
d172 4
a175 1
is($?, 42,      'status unaffected by implicit close');
a176 16

# check that child is reaped if the piped program can't be executed
{
  open NIL, '/no_such_process |';
  close NIL;

  my $child = 0;
  eval {
    local $SIG{ALRM} = sub { die; };
    alarm 2;
    $child = wait;
    alarm 0;
  };

  is($child, -1, 'child reaped if piped program cannot be executed');
}
@


1.1.1.6
log
@perl 5.8.8 import
@
text
@d185 1
a185 2
SKIP: {
  skip "/no_such_process exists", 1 if -e "/no_such_process";
@


1.1.1.7
log
@import perl 5.10.0 from CPAN
@
text
@d13 1
a13 1
        plan(tests => 24);
d33 1
a33 1
    skip "Doesn't work here yet", 6 if $^O eq 'vmesa';
a52 43
    my $raw = "abc\nrst\rxyz\r\nfoo\n";
    if (open(PIPE, "-|")) {
	$_ = join '', <PIPE>;
	(my $raw1 = $_) =~ s/not ok \d+ - //;
	my @@r  = map ord, split //, $raw;
	my @@r1 = map ord, split //, $raw1;
        if ($raw1 eq $raw) {
	    s/^not (ok \d+ -) .*/$1 '@@r1' passes through '-|'\n/s;
	} else {
	    s/^(not ok \d+ -) .*/$1 expect '@@r', got '@@r1'\n/s;
	}
	print;
	close PIPE;        # avoid zombies
    }
    else {
	printf STDOUT "not ok %d - $raw", curr_test();
        exec $Perl, '-e0';	# Do not run END()...
    }

    # This has to be *outside* the fork
    next_test();

    if (open(PIPE, "|-")) {
	printf PIPE "not ok %d - $raw", curr_test();
	close PIPE;        # avoid zombies
    }
    else {
	$_ = join '', <STDIN>;
	(my $raw1 = $_) =~ s/not ok \d+ - //;
	my @@r  = map ord, split //, $raw;
	my @@r1 = map ord, split //, $raw1;
        if ($raw1 eq $raw) {
	    s/^not (ok \d+ -) .*/$1 '@@r1' passes through '|-'\n/s;
	} else {
	    s/^(not ok \d+ -) .*/$1 expect '@@r', got '@@r1'\n/s;
	}
	print;
        exec $Perl, '-e0';	# Do not run END()...
    }

    # This has to be *outside* the fork
    next_test();

a169 1
  no warnings 'pipe';
@


1.1.1.8
log
@Perl 5.12.2 from CPAN
@
text
@d155 2
a156 1
        # that has pending output.  Go figure.
d160 1
a160 1
          if $Config{d_sfio} || $^O eq 'beos' ||
@


1.1.1.9
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d30 5
a34 1
{
d156 1
d159 2
a160 1
          if $Config{d_sfio} || $^O eq 'posix-bc';
d174 3
a176 1
    {
d185 3
a187 2
	# Former skip block:
        {
@


1.1.1.10
log
@Import perl-5.20.1
@
text
@d150 1
a150 1
        # POSIX-BC doesn't report failure when closing a broken pipe
d152 1
d154 1
a154 1
          if $^O eq 'posix-bc';
@


