head	1.2;
access;
symbols
	OPENBSD_6_2:1.2.0.2
	OPENBSD_6_2_BASE:1.2
	PERL_5_24_2:1.1.1.10
	OPENBSD_6_1:1.2.0.4
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.9.0.10
	OPENBSD_6_0_BASE:1.1.1.9
	OPENBSD_5_9:1.1.1.9.0.4
	OPENBSD_5_9_BASE:1.1.1.9
	OPENBSD_5_8:1.1.1.9.0.6
	OPENBSD_5_8_BASE:1.1.1.9
	PERL_5_20_2:1.1.1.9
	OPENBSD_5_7:1.1.1.9.0.2
	OPENBSD_5_7_BASE:1.1.1.9
	PERL_5_20_1:1.1.1.9
	OPENBSD_5_6:1.1.1.8.0.4
	OPENBSD_5_6_BASE:1.1.1.8
	PERL_5_18_2:1.1.1.8
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.7.0.6
	OPENBSD_5_5_BASE:1.1.1.7
	OPENBSD_5_4:1.1.1.7.0.2
	OPENBSD_5_4_BASE:1.1.1.7
	PERL_5_16_3:1.1.1.7
	OPENBSD_5_3:1.1.1.6.0.14
	OPENBSD_5_3_BASE:1.1.1.6
	OPENBSD_5_2:1.1.1.6.0.12
	OPENBSD_5_2_BASE:1.1.1.6
	OPENBSD_5_1_BASE:1.1.1.6
	OPENBSD_5_1:1.1.1.6.0.10
	OPENBSD_5_0:1.1.1.6.0.8
	OPENBSD_5_0_BASE:1.1.1.6
	OPENBSD_4_9:1.1.1.6.0.6
	OPENBSD_4_9_BASE:1.1.1.6
	PERL_5_12_2:1.1.1.6
	OPENBSD_4_8:1.1.1.6.0.4
	OPENBSD_4_8_BASE:1.1.1.6
	OPENBSD_4_7:1.1.1.6.0.2
	OPENBSD_4_7_BASE:1.1.1.6
	PERL_5_10_1:1.1.1.6
	OPENBSD_4_6:1.1.1.5.0.6
	OPENBSD_4_6_BASE:1.1.1.5
	OPENBSD_4_5:1.1.1.5.0.2
	OPENBSD_4_5_BASE:1.1.1.5
	PERL_5_10_0:1.1.1.5
	OPENBSD_4_4:1.1.1.4.0.10
	OPENBSD_4_4_BASE:1.1.1.4
	OPENBSD_4_3:1.1.1.4.0.8
	OPENBSD_4_3_BASE:1.1.1.4
	OPENBSD_4_2:1.1.1.4.0.6
	OPENBSD_4_2_BASE:1.1.1.4
	OPENBSD_4_1:1.1.1.4.0.4
	OPENBSD_4_1_BASE:1.1.1.4
	OPENBSD_4_0:1.1.1.4.0.2
	OPENBSD_4_0_BASE:1.1.1.4
	PERL_5_8_8:1.1.1.4
	OPENBSD_3_9:1.1.1.3.0.8
	OPENBSD_3_9_BASE:1.1.1.3
	OPENBSD_3_8:1.1.1.3.0.6
	OPENBSD_3_8_BASE:1.1.1.3
	OPENBSD_3_7:1.1.1.3.0.4
	OPENBSD_3_7_BASE:1.1.1.3
	PERL_5_8_6:1.1.1.3
	OPENBSD_3_6:1.1.1.3.0.2
	OPENBSD_3_6_BASE:1.1.1.3
	PERL_5_8_5:1.1.1.3
	PERL_5_8_3:1.1.1.3
	OPENBSD_3_5:1.1.1.2.0.2
	OPENBSD_3_5_BASE:1.1.1.2
	PERL_5_8_2:1.1.1.2
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	PERL_5_8_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.32.19;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2002.10.27.22.15.10;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.27.22.15.10;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.12.03.02.44.30;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.04.07.21.13.42;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2006.03.28.18.49.41;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2008.09.29.17.18.58;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2009.10.12.18.10.42;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2013.03.25.20.09.33;	author sthen;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2014.03.24.14.59.09;	author afresh1;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2014.11.17.20.53.17;	author afresh1;	state Exp;
branches;
next	1.1.1.10;
commitid	B31cAbBIXiCqnL97;

1.1.1.10
date	2017.08.14.13.46.23;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl

BEGIN {
    chdir 't' if -d 't';
    @@INC = '../lib';
    require './test.pl'; require './charset_tools.pl';
    skip_all_without_perlio();
}

no utf8; # needed for use utf8 not griping about the raw octets


plan(tests => 63);

$| = 1;

my $a_file = tempfile();

open(F,"+>:utf8",$a_file);
print F chr(0x100).'£';
cmp_ok( tell(F), '==', 4, tell(F) );
print F "\n";
cmp_ok( tell(F), '>=', 5, tell(F) );
seek(F,0,0);
is( getc(F), chr(0x100) );
is( getc(F), "£" );
is( getc(F), "\n" );
seek(F,0,0);
binmode(F,":bytes");

# Byte representation of these characters
my $U_100 = byte_utf8a_to_utf8n("\xc4\x80");
my $POUND_SIGN = byte_utf8a_to_utf8n("\xc2\xa3");

my $chr = substr($U_100, 0, 1);
is( getc(F), $chr );
$chr = substr($U_100, 1, 1);
is( getc(F), $chr );
$chr = substr($POUND_SIGN, 0, 1);
is( getc(F), $chr );
$chr = substr($POUND_SIGN, 1, 1);
is( getc(F), $chr );
is( getc(F), "\n" );
seek(F,0,0);
binmode(F,":utf8");
is( scalar(<F>), "\x{100}£\n" );
seek(F,0,0);
$buf = chr(0x200);
$count = read(F,$buf,2,1);
cmp_ok( $count, '==', 2 );
is( $buf, "\x{200}\x{100}£" );
close(F);

{
    $a = chr(300); # This *is* UTF-encoded
    $b = chr(130); # This is not.

    open F, ">:utf8", $a_file or die $!;
    print F $a,"\n";
    close F;

    open F, "<:utf8", $a_file or die $!;
    $x = <F>;
    chomp($x);
    is( $x, chr(300) );

    open F, $a_file or die $!; # Not UTF
    binmode(F, ":bytes");
    $x = <F>;
    chomp($x);
    $chr = byte_utf8a_to_utf8n(chr(196).chr(172));
    is( $x, $chr );
    close F;

    open F, ">:utf8", $a_file or die $!;
    binmode(F);  # we write a "\n" and then tell() - avoid CRLF issues.
    binmode(F,":utf8"); # turn UTF-8-ness back on
    print F $a;
    my $y;
    { my $x = tell(F);
      { use bytes; $y = length($a);}
      cmp_ok( $x, '==', $y );
  }

    { # Check byte length of $b
	use bytes; my $y = length($b);
	cmp_ok( $y, '==', 1 );
    }

    print F $b,"\n"; # Don't upgrade $b

    { # Check byte length of $b
	use bytes; my $y = length($b);
	cmp_ok( $y, '==', 1 );
    }

    {
	my $x = tell(F);
	{ use bytes; if ($::IS_EBCDIC){$y += 2;}else{$y += 3;}} # EBCDIC ASCII
	cmp_ok( $x, '==', $y );
    }

    close F;

    open F, $a_file or die $!; # Not UTF
    binmode(F, ":bytes");
    $x = <F>;
    chomp($x);
    $chr = v196.172.194.130;
    if ($::IS_EBCDIC) { $chr = v141.83.130; } # EBCDIC
    is( $x, $chr, sprintf('(%vd)', $x) );

    open F, "<:utf8", $a_file or die $!;
    $x = <F>;
    chomp($x);
    close F;
    is( $x, chr(300).chr(130), sprintf('(%vd)', $x) );

    open F, ">", $a_file or die $!;
    binmode(F, ":bytes:");

    # Now let's make it suffer.
    my $w;
    {
	use warnings 'utf8';
	local $SIG{__WARN__} = sub { $w = $_[0] };
	print F $a;
        ok( (!$@@));
	like($w, qr/Wide character in print/i );
    }
}

# Hm. Time to get more evil.
open F, ">:utf8", $a_file or die $!;
print F $a;
binmode(F, ":bytes");
print F chr(130)."\n";
close F;

open F, "<", $a_file or die $!;
binmode(F, ":bytes");
$x = <F>; chomp $x;
$chr = v196.172.130;
if ($::IS_EBCDIC) { $chr = v141.83.130; } # EBCDIC
is( $x, $chr );

# Right.
open F, ">:utf8", $a_file or die $!;
print F $a;
close F;
open F, ">>", $a_file or die $!;
binmode(F, ":bytes");
print F chr(130)."\n";
close F;

open F, "<", $a_file or die $!;
binmode(F, ":bytes");
$x = <F>; chomp $x;
SKIP: {
    skip("Defaulting to UTF-8 output means that we can't generate a mangled file")
	if $UTF8_OUTPUT;
    is( $x, $chr );
}

# Now we have a deformed file.

SKIP: {
    if ($::IS_EBCDIC) {
	skip("EBCDIC The file isn't deformed in UTF-EBCDIC", 2);
    } else {
	my @@warnings;
	open F, "<:utf8", $a_file or die $!;
	$x = <F>; chomp $x;
	local $SIG{__WARN__} = sub { push @@warnings, $_[0]; };
	eval { sprintf "%vd\n", $x };
	is (scalar @@warnings, 1);
	like ($warnings[0], qr/Malformed UTF-8 character \(unexpected continuation byte 0x82, with no preceding start byte/);
    }
}

close F;
unlink($a_file);

open F, ">:utf8", $a_file;
@@a = map { chr(1 << ($_ << 2)) } 0..5; # 0x1, 0x10, .., 0x100000
unshift @@a, chr(0); # ... and a null byte in front just for fun
print F @@a;
close F;

my $c;

# read() should work on characters, not bytes
open F, "<:utf8", $a_file;
$a = 0;
my $failed;
for (@@a) {
    unless (($c = read(F, $b, 1) == 1)  &&
            length($b)           == 1  &&
            ord($b)              == ord($_) &&
            tell(F)              == ($a += bytes::length($b))) {
        print '# ord($_)           == ', ord($_), "\n";
        print '# ord($b)           == ', ord($b), "\n";
        print '# length($b)        == ', length($b), "\n";
        print '# bytes::length($b) == ', bytes::length($b), "\n";
        print '# tell(F)           == ', tell(F), "\n";
        print '# $a                == ', $a, "\n";
        print '# $c                == ', $c, "\n";
	$failed++;
        last;
    }
}
close F;
is($failed, undef);

{
    # Check that warnings are on on I/O, and that they can be muffled.

    local $SIG{__WARN__} = sub { $@@ = shift };

    undef $@@;
    open F, ">$a_file";
    binmode(F, ":bytes");
    print F chr(0x100);
    close(F);

    like( $@@, qr/Wide character in print/ );

    undef $@@;
    open F, ">:utf8", $a_file;
    print F chr(0x100);
    close(F);

    isnt( defined $@@, !0 );

    undef $@@;
    open F, ">$a_file";
    binmode(F, ":utf8");
    print F chr(0x100);
    close(F);

    isnt( defined $@@, !0 );

    no warnings 'utf8';

    undef $@@;
    open F, ">$a_file";
    print F chr(0x100);
    close(F);

    isnt( defined $@@, !0 );

    use warnings 'utf8';

    undef $@@;
    open F, ">$a_file";
    binmode(F, ":bytes");
    print F chr(0x100);
    close(F);

    like( $@@, qr/Wide character in print/ );
}

{
    open F, ">:bytes",$a_file; print F "\xde"; close F;

    open F, "<:bytes", $a_file;
    my $b = chr 0x100;
    $b .= <F>;
    is( $b, chr(0x100).chr(0xde), "21395 '.= <>' utf8 vs. bytes" );
    close F;
}

{
    open F, ">:utf8",$a_file; print F chr 0x100; close F;

    open F, "<:utf8", $a_file;
    my $b = "\xde";
    $b .= <F>;
    is( $b, chr(0xde).chr(0x100), "21395 '.= <>' bytes vs. utf8" );
    close F;
}

{
    my @@a = ( [ 0x007F, "bytes" ],
	      [ 0x0080, "bytes" ],
	      [ 0x0080, "utf8"  ],
	      [ 0x0100, "utf8"  ] );
    my $t = 34;
    for my $u (@@a) {
	for my $v (@@a) {
	    # print "# @@$u - @@$v\n";
	    open F, ">$a_file";
	    binmode(F, ":" . $u->[1]);
	    print F chr($u->[0]);
	    close F;

	    open F, "<$a_file";
	    binmode(F, ":" . $u->[1]);

	    my $s = chr($v->[0]);
	    utf8::upgrade($s) if $v->[1] eq "utf8";

	    $s .= <F>;
	    is( $s, chr($v->[0]) . chr($u->[0]), 'rcatline utf8' );
	    close F;
	    $t++;
	}
    }
    # last test here 49
}

{
    # [perl #23428] Somethings rotten in unicode semantics
    open F, ">$a_file";
    binmode F, ":utf8";
    syswrite(F, $a = chr(0x100));
    close F;
    is( ord($a), 0x100, '23428 syswrite should not downgrade scalar' );
    like( $a, qr/^\w+/, '23428 syswrite should not downgrade scalar' );
}

# sysread() and syswrite() tested in lib/open.t since Fcntl is used

{
    # <FH> on a :utf8 stream should complain immediately with -w
    # if it finds bad UTF-8 (:encoding(utf8) works this way)
    use warnings 'utf8';
    undef $@@;
    local $SIG{__WARN__} = sub { $@@ = shift };
    open F, ">$a_file";
    binmode F;
    my ($chrE4, $chrF6) = (chr(0xE4), chr(0xF6));
    if ($::IS_EBCDIC)	# EBCDIC
    { ($chrE4, $chrF6) = (chr(0x43), chr(0xEC)); }
    print F "foo", $chrE4, "\n";
    print F "foo", $chrF6, "\n";
    close F;
    open F, "<:utf8", $a_file;
    undef $@@;
    my $line = <F>;
    my ($chrE4, $chrF6) = ("E4", "F6");
    if ($::IS_EBCDIC) { ($chrE4, $chrF6) = ("43", "EC"); } # EBCDIC
    like( $@@, qr/utf8 "\\x$chrE4" does not map to Unicode .+ <F> line 1/,
	  "<:utf8 readline must warn about bad utf8");
    undef $@@;
    $line .= <F>;
    like( $@@, qr/utf8 "\\x$chrF6" does not map to Unicode .+ <F> line 2/,
	  "<:utf8 rcatline must warn about bad utf8");
    close F;
}

{
    # fixed record reads
    open F, ">:utf8", $a_file;
    print F "foo\xE4";
    print F "bar\xFE";
    print F "\xC0\xC8\xCC\xD2";
    print F "a\xE4ab";
    print F "a\xE4a";
    close F;
    open F, "<:utf8", $a_file;
    local $/ = \4;
    my $line = <F>;
    is($line, "foo\xE4", "readline with \$/ = \\4");
    $line .= <F>;
    is($line, "foo\xE4bar\xFE", "rcatline with \$/ = \\4");
    $line = <F>;
    is($line, "\xC0\xC8\xCC\xD2", "readline with several encoded characters");
    $line = <F>;
    is($line, "a\xE4ab", "readline with another boundary condition");
    $line = <F>;
    is($line, "a\xE4a", "readline with boundary condition");
    close F;

    # badly encoded at EOF
    open F, ">:raw", $a_file;
    print F "foo\xEF\xAC"; # truncated \x{FB04} small ligature ffl
    close F;

    use warnings 'utf8';
    open F, "<:utf8", $a_file;
    undef $@@;
    local $SIG{__WARN__} = sub { $@@ = shift };
    $line = <F>;

    like( $@@, qr/utf8 "\\xEF" does not map to Unicode .+ <F> chunk 1/,
	  "<:utf8 readline (fixed) must warn about bad utf8");
    close F;
}

# getc should reset the utf8 flag and not be affected by previous
# return values
SKIP: {
    skip "no PerlIO::scalar on miniperl", 2, if is_miniperl();
    open my $fh, "<:raw",  \($buf = chr 255);
    open my $uh, "<:utf8", \($uuf = $U_100);
    for([$uh,chr 256], [$fh,chr 255]) {
	is getc $$_[0], $$_[1],
	  'getc returning non-utf8 after utf8';
    }
}
@


1.1
log
@Initial revision
@
text
@d6 2
a7 4
    unless (find PerlIO::Layer 'perlio') {
	print "1..0 # Skip: not perlio\n";
	exit 0;
    }
d12 3
a15 1
print "1..31\n";
d17 3
a19 1
open(F,"+>:utf8",'a');
d21 1
a21 3
print '#'.tell(F)."\n";
print "not " unless tell(F) == 4;
print "ok 1\n";
d23 1
a23 3
print '#'.tell(F)."\n";
print "not " unless tell(F) >= 5;
print "ok 2\n";
d25 3
a27 6
print "not " unless getc(F) eq chr(0x100);
print "ok 3\n";
print "not " unless getc(F) eq "£";
print "ok 4\n";
print "not " unless getc(F) eq "\n";
print "ok 5\n";
d30 14
a43 18
my $chr = chr(0xc4);
if (ord('A') == 193) { $chr = chr(0x8c); } # EBCDIC
print "not " unless getc(F) eq $chr;
print "ok 6\n";
$chr = chr(0x80);
if (ord('A') == 193) { $chr = chr(0x41); } # EBCDIC
print "not " unless getc(F) eq $chr;
print "ok 7\n";
$chr = chr(0xc2);
if (ord('A') == 193) { $chr = chr(0x80); } # EBCDIC
print "not " unless getc(F) eq $chr;
print "ok 8\n";
$chr = chr(0xa3);
if (ord('A') == 193) { $chr = chr(0x44); } # EBCDIC
print "not " unless getc(F) eq $chr;
print "ok 9\n";
print "not " unless getc(F) eq "\n";
print "ok 10\n";
d46 1
a46 2
print "not " unless scalar(<F>) eq "\x{100}£\n";
print "ok 11\n";
d50 2
a51 4
print "not " unless $count == 2;
print "ok 12\n";
print "not " unless $buf eq "\x{200}\x{100}£";
print "ok 13\n";
d58 1
a58 1
    open F, ">:utf8", 'a' or die $!;
d62 1
a62 1
    open F, "<:utf8", 'a' or die $!;
d65 1
a65 2
    print "not " unless $x eq chr(300);
    print "ok 14\n";
d67 1
a67 1
    open F, "a" or die $!; # Not UTF
d71 2
a72 4
    $chr = chr(196).chr(172);
    if (ord('A') == 193) { $chr = chr(141).chr(83); } # EBCDIC
    print "not " unless $x eq $chr;
    print "ok 15\n";
d75 1
a75 1
    open F, ">:utf8", 'a' or die $!;
d82 1
a82 2
      print "not " unless $x == $y;
      print "ok 16\n";
d87 1
a87 2
	print "not " unless $y == 1;
	print "ok 17\n";
d90 1
a90 1
    print F $b,"\n"; # Don't upgrades $b
d94 1
a94 2
	print "not ($y) " unless $y == 1;
	print "ok 18\n";
d99 2
a100 3
	{ use bytes; if (ord('A')==193){$y += 2;}else{$y += 3;}} # EBCDIC ASCII
	print "not ($x,$y) " unless $x == $y;
	print "ok 19\n";
d105 1
a105 1
    open F, "a" or die $!; # Not UTF
d110 2
a111 3
    if (ord('A') == 193) { $chr = v141.83.130; } # EBCDIC
    printf "not (%vd) ", $x unless $x eq $chr;
    print "ok 20\n";
d113 1
a113 1
    open F, "<:utf8", "a" or die $!;
d117 1
a117 2
    printf "not (%vd) ", $x unless $x eq chr(300).chr(130);
    print "ok 21\n";
d119 2
a120 4
    open F, ">", "a" or die $!;
    if (${^OPEN} =~ /:utf8/) {
        binmode(F, ":bytes:");
    }
d128 2
a129 1
	print "not " if ($@@ || $w !~ /Wide character in print/i);
a130 1
    print "ok 22\n";
d134 1
a134 1
open F, ">:utf8", "a" or die $!;
d140 1
a140 1
open F, "<", "a" or die $!;
d144 2
a145 3
if (ord('A') == 193) { $chr = v141.83.130; } # EBCDIC
print "not " unless $x eq $chr;
print "ok 23\n";
d148 1
a148 1
open F, ">:utf8", "a" or die $!;
d151 2
a152 1
open F, ">>", "a" or die $!;
d156 2
a157 1
open F, "<", "a" or die $!;
d159 5
a163 2
print "not " unless $x eq $chr;
print "ok 24\n";
d167 12
a178 7
if (ord('A') == 193) {
    print "ok 25 # Skip: EBCDIC\n"; # EBCDIC doesn't complain
} else {
    open F, "<:utf8", "a" or die $!;
    $x = <F>; chomp $x;
    local $SIG{__WARN__} = sub { print "ok 25\n" };
    eval { sprintf "%vd\n", $x };
d182 1
a182 1
unlink('a');
d184 1
a184 1
open F, ">:utf8", "a";
d193 1
a193 1
open F, "<:utf8", "a";
d195 1
d208 1
a208 1
        print "not ";
d213 1
a213 1
print "ok 26\n";
d221 1
a221 1
    open F, ">a";
d226 1
a226 1
    print $@@ =~ /Wide character in print/ ? "ok 27\n" : "not ok 27\n";
d229 1
a229 1
    open F, ">:utf8", "a";
d233 1
a233 1
    print defined $@@ ? "not ok 28\n" : "ok 28\n";
d236 1
a236 1
    open F, ">a";
d241 1
a241 1
    print defined $@@ ? "not ok 29\n" : "ok 29\n";
d246 1
a246 1
    open F, ">a";
d250 1
a250 1
    print defined $@@ ? "not ok 30\n" : "ok 30\n";
d255 1
a255 1
    open F, ">a";
d260 11
a270 1
    print $@@ =~ /Wide character in print/ ? "ok 31\n" : "not ok 31\n";
d273 2
a274 1
# sysread() and syswrite() tested in lib/open.t since Fnctl is used
d276 5
a280 3
END {
    1 while unlink "a";
    1 while unlink "b";
d283 119
@


1.1.1.1
log
@stock perl 5.8.0 from CPAN
@
text
@@


1.1.1.2
log
@perl 5.8.2 from CPAN
@
text
@a13 4
require "./test.pl";

plan(tests => 53);

d15 1
d19 3
a21 1
ok( tell(F) == 4, tell(F) );
d23 3
a25 1
ok( tell(F) >= 5, tell(F) );
d27 6
a32 3
ok( getc(F) eq chr(0x100) );
ok( getc(F) eq "£" );
ok( getc(F) eq "\n" );
d37 2
a38 1
ok( getc(F) eq $chr );
d41 2
a42 1
ok( getc(F) eq $chr );
d45 2
a46 1
ok( getc(F) eq $chr );
d49 4
a52 2
ok( getc(F) eq $chr );
ok( getc(F) eq "\n" );
d55 2
a56 1
ok( scalar(<F>) eq "\x{100}£\n" );
d60 4
a63 2
ok( $count == 2 );
ok( $buf eq "\x{200}\x{100}£" );
d77 2
a78 1
    ok( $x eq chr(300) );
d86 2
a87 1
    ok( $x eq $chr );
d97 2
a98 1
      ok( $x == $y );
d103 2
a104 1
	ok( $y == 1 );
d111 2
a112 1
	ok( $y == 1 );
d118 2
a119 1
	ok( $x == $y );
d130 2
a131 1
    ok( $x eq $chr, sprintf('(%vd)', $x) );
d137 2
a138 1
    ok( $x eq chr(300).chr(130), sprintf('(%vd)', $x) );
d151 1
a151 1
        ok( !($@@ || $w !~ /Wide character in print/i) );
d153 1
d168 2
a169 1
ok( $x eq $chr );
d181 2
a182 1
ok( $x eq $chr );
d186 7
a192 9
SKIP: {
    if (ord('A') == 193) {
	skip( "EBCDIC doesn't complain" );
    } else {
	open F, "<:utf8", "a" or die $!;
	$x = <F>; chomp $x;
	local $SIG{__WARN__} = sub { ok( 1 ) };
	eval { sprintf "%vd\n", $x };
    }
d226 1
a226 1
ok( 1 );
d239 1
a239 1
    like( $@@, 'Wide character in print' );
d246 1
a246 1
    isnt( defined $@@ );
d254 1
a254 1
    isnt( defined $@@ );
d263 1
a263 1
    isnt( defined $@@ );
d273 1
a273 21
    like( $@@, 'Wide character in print' );
}

{
    open F, ">:bytes","a"; print F "\xde"; close F;

    open F, "<:bytes", "a";
    my $b = chr 0x100;
    $b .= <F>;
    ok( $b eq chr(0x100).chr(0xde), "21395 '.= <>' utf8 vs. bytes" );
    close F;
}

{
    open F, ">:utf8","a"; print F chr 0x100; close F;

    open F, "<:utf8", "a";
    my $b = "\xde";
    $b .= <F>;
    ok( $b eq chr(0xde).chr(0x100), "21395 '.= <>' bytes vs. utf8" );
    close F;
d276 1
a276 63
{
    my @@a = ( [ 0x007F, "bytes" ],
	      [ 0x0080, "bytes" ],
	      [ 0x0080, "utf8"  ],
	      [ 0x0100, "utf8"  ] );
    my $t = 34;
    for my $u (@@a) {
	for my $v (@@a) {
	    # print "# @@$u - @@$v\n";
	    open F, ">a";
	    binmode(F, ":" . $u->[1]);
	    print F chr($u->[0]);
	    close F;

	    open F, "<a";
	    binmode(F, ":" . $u->[1]);

	    my $s = chr($v->[0]);
	    utf8::upgrade($s) if $v->[1] eq "utf8";

	    $s .= <F>;
	    ok( $s eq chr($v->[0]) . chr($u->[0]), 'rcatline utf8' );
	    close F;
	    $t++;
	}
    }
    # last test here 49
}

{
    # [perl #23428] Somethings rotten in unicode semantics
    open F, ">a";
    binmode F, ":utf8";
    syswrite(F, $a = chr(0x100));
    close F;
    is( ord($a), 0x100, '23428 syswrite should not downgrade scalar' );
    like( $a, qr/^\w+/, '23428 syswrite should not downgrade scalar' );
}

# sysread() and syswrite() tested in lib/open.t since Fcntl is used

{
    # <FH> on a :utf8 stream should complain immediately with -w
    # if it finds bad UTF-8 (:encoding(utf8) works this way)
    use warnings 'utf8';
    undef $@@;
    local $SIG{__WARN__} = sub { $@@ = shift };
    open F, ">a";
    binmode F;
    print F "foo", chr(0xE4), "\n";
    print F "foo", chr(0xF6), "\n";
    close F;
    open F, "<:utf8", "a";
    undef $@@;
    my $line = <F>;
    like( $@@, qr/utf8 "\\xE4" does not map to Unicode .+ <F> line 1/,
	  "<:utf8 readline must warn about bad utf8");
    undef $@@;
    $line .= <F>;
    like( $@@, qr/utf8 "\\xF6" does not map to Unicode .+ <F> line 2/,
	  "<:utf8 rcatline must warn about bad utf8");
    close F;
}
d282 1
@


1.1.1.3
log
@perl 5.8.3 from CPAN
@
text
@d324 2
a325 5
    my ($chrE4, $chrF6) = (chr(0xE4), chr(0xF6));
    if (ord('A') == 193)	# EBCDIC
    { ($chrE4, $chrF6) = (chr(0x43), chr(0xEC)); }
    print F "foo", $chrE4, "\n";
    print F "foo", $chrF6, "\n";
d330 1
a330 3
    my ($chrE4, $chrF6) = ("E4", "F6");
    if (ord('A') == 193) { ($chrE4, $chrF6) = ("43", "EC"); } # EBCDIC
    like( $@@, qr/utf8 "\\x$chrE4" does not map to Unicode .+ <F> line 1/,
d334 1
a334 1
    like( $@@, qr/utf8 "\\x$chrF6" does not map to Unicode .+ <F> line 2/,
@


1.1.1.4
log
@perl 5.8.8 import
@
text
@d16 1
a16 1
plan(tests => 55);
d22 1
a22 1
cmp_ok( tell(F), '==', 4, tell(F) );
d24 1
a24 1
cmp_ok( tell(F), '>=', 5, tell(F) );
d26 3
a28 3
is( getc(F), chr(0x100) );
is( getc(F), "£" );
is( getc(F), "\n" );
d33 1
a33 1
is( getc(F), $chr );
d36 1
a36 1
is( getc(F), $chr );
d39 1
a39 1
is( getc(F), $chr );
d42 2
a43 2
is( getc(F), $chr );
is( getc(F), "\n" );
d46 1
a46 1
is( scalar(<F>), "\x{100}£\n" );
d50 2
a51 2
cmp_ok( $count, '==', 2 );
is( $buf, "\x{200}\x{100}£" );
d65 1
a65 1
    is( $x, chr(300) );
d73 1
a73 1
    is( $x, $chr );
d83 1
a83 1
      cmp_ok( $x, '==', $y );
d88 1
a88 1
	cmp_ok( $y, '==', 1 );
d95 1
a95 1
	cmp_ok( $y, '==', 1 );
d101 1
a101 1
	cmp_ok( $x, '==', $y );
d112 1
a112 1
    is( $x, $chr, sprintf('(%vd)', $x) );
d118 1
a118 1
    is( $x, chr(300).chr(130), sprintf('(%vd)', $x) );
d131 1
a131 2
        ok( (!$@@));
	like($w, qr/Wide character in print/i );
d147 1
a147 1
is( $x, $chr );
a153 1
binmode(F, ":bytes");
a157 1
binmode(F, ":bytes");
d159 1
a159 5
SKIP: {
    skip("Defaulting to UTF-8 output means that we can't generate a mangled file")
	if $UTF8_OUTPUT;
    is( $x, $chr );
}
d165 1
a165 1
	skip("EBCDIC doesn't complain", 2);
a166 1
	my @@warnings;
d169 1
a169 1
	local $SIG{__WARN__} = sub { push @@warnings, $_[0]; };
a170 2
	is (scalar @@warnings, 1);
	like ($warnings[0], qr/Malformed UTF-8 character \(unexpected continuation byte 0x82, with no preceding start byte/);
a187 1
my $failed;
d200 1
a200 1
	$failed++;
d205 1
a205 1
is($failed, undef);
d261 1
a261 1
    is( $b, chr(0x100).chr(0xde), "21395 '.= <>' utf8 vs. bytes" );
d271 1
a271 1
    is( $b, chr(0xde).chr(0x100), "21395 '.= <>' bytes vs. utf8" );
d296 1
a296 1
	    is( $s, chr($v->[0]) . chr($u->[0]), 'rcatline utf8' );
@


1.1.1.5
log
@import perl 5.10.0 from CPAN
@
text
@d14 1
a14 1
BEGIN { require "./test.pl"; }
d121 3
a123 1
    binmode(F, ":bytes:");
d236 1
a236 1
    isnt( defined $@@, !0 );
d244 1
a244 1
    isnt( defined $@@, !0 );
d253 1
a253 1
    isnt( defined $@@, !0 );
@


1.1.1.6
log
@import perl 5.10.1
@
text
@d20 1
a20 3
my $a_file = tempfile();

open(F,"+>:utf8",$a_file);
d32 1
a32 1
if (ord($a_file) == 193) { $chr = chr(0x8c); } # EBCDIC
d35 1
a35 1
if (ord($a_file) == 193) { $chr = chr(0x41); } # EBCDIC
d38 1
a38 1
if (ord($a_file) == 193) { $chr = chr(0x80); } # EBCDIC
d41 1
a41 1
if (ord($a_file) == 193) { $chr = chr(0x44); } # EBCDIC
d58 1
a58 1
    open F, ">:utf8", $a_file or die $!;
d62 1
a62 1
    open F, "<:utf8", $a_file or die $!;
d67 1
a67 1
    open F, $a_file or die $!; # Not UTF
d72 1
a72 1
    if (ord($a_file) == 193) { $chr = chr(141).chr(83); } # EBCDIC
d76 1
a76 1
    open F, ">:utf8", $a_file or die $!;
d106 1
a106 1
    open F, $a_file or die $!; # Not UTF
d114 1
a114 1
    open F, "<:utf8", $a_file or die $!;
d120 1
a120 1
    open F, ">", $a_file or die $!;
d135 1
a135 1
open F, ">:utf8", $a_file or die $!;
d141 1
a141 1
open F, "<", $a_file or die $!;
d149 1
a149 1
open F, ">:utf8", $a_file or die $!;
d152 1
a152 1
open F, ">>", $a_file or die $!;
d157 1
a157 1
open F, "<", $a_file or die $!;
d173 1
a173 1
	open F, "<:utf8", $a_file or die $!;
d183 1
a183 1
unlink($a_file);
d185 1
a185 1
open F, ">:utf8", $a_file;
d194 1
a194 1
open F, "<:utf8", $a_file;
d222 1
a222 1
    open F, ">$a_file";
d230 1
a230 1
    open F, ">:utf8", $a_file;
d237 1
a237 1
    open F, ">$a_file";
d247 1
a247 1
    open F, ">$a_file";
d256 1
a256 1
    open F, ">$a_file";
d265 1
a265 1
    open F, ">:bytes",$a_file; print F "\xde"; close F;
d267 1
a267 1
    open F, "<:bytes", $a_file;
d275 1
a275 1
    open F, ">:utf8",$a_file; print F chr 0x100; close F;
d277 1
a277 1
    open F, "<:utf8", $a_file;
d293 1
a293 1
	    open F, ">$a_file";
d298 1
a298 1
	    open F, "<$a_file";
d315 1
a315 1
    open F, ">$a_file";
d331 1
a331 1
    open F, ">$a_file";
d339 1
a339 1
    open F, "<:utf8", $a_file;
d351 5
@


1.1.1.7
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d6 4
a9 2
    require './test.pl';
    skip_all_without_perlio();
d14 1
@


1.1.1.8
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d13 1
a13 1
plan(tests => 61);
a349 38
}

{
    # fixed record reads
    open F, ">:utf8", $a_file;
    print F "foo\xE4";
    print F "bar\xFE";
    print F "\xC0\xC8\xCC\xD2";
    print F "a\xE4ab";
    print F "a\xE4a";
    close F;
    open F, "<:utf8", $a_file;
    local $/ = \4;
    my $line = <F>;
    is($line, "foo\xE4", "readline with \$/ = \\4");
    $line .= <F>;
    is($line, "foo\xE4bar\xFE", "rcatline with \$/ = \\4");
    $line = <F>;
    is($line, "\xC0\xC8\xCC\xD2", "readline with several encoded characters");
    $line = <F>;
    is($line, "a\xE4ab", "readline with another boundary condition");
    $line = <F>;
    is($line, "a\xE4a", "readline with boundary condition");
    close F;

    # badly encoded at EOF
    open F, ">:raw", $a_file;
    print F "foo\xEF\xAC"; # truncated \x{FB04} small ligature ffl
    close F;

    use warnings 'utf8';
    open F, "<:utf8", $a_file;
    undef $@@;
    local $SIG{__WARN__} = sub { $@@ = shift };
    $line = <F>;

    like( $@@, qr/utf8 "\\xEF" does not map to Unicode .+ <F> chunk 1/,
	  "<:utf8 readline (fixed) must warn about bad utf8");
@


1.1.1.9
log
@Import perl-5.20.1
@
text
@d13 1
a13 1
plan(tests => 63);
a387 13
    close F;
}

# getc should reset the utf8 flag and not be affected by previous
# return values
SKIP: {
    skip "no PerlIO::scalar on miniperl", 2, if is_miniperl();
    open my $fh, "<:raw",  \($buf = chr 255);
    open my $uh, "<:utf8", \($uuf = "\xc4\x80");
    for([$uh,chr 256], [$fh,chr 255]) {
	is getc $$_[0], $$_[1],
	  'getc returning non-utf8 after utf8';
    }
@


1.1.1.10
log
@Import perl-5.24.2
@
text
@d6 1
a6 1
    require './test.pl'; require './charset_tools.pl';
d30 2
a31 6

# Byte representation of these characters
my $U_100 = byte_utf8a_to_utf8n("\xc4\x80");
my $POUND_SIGN = byte_utf8a_to_utf8n("\xc2\xa3");

my $chr = substr($U_100, 0, 1);
d33 2
a34 1
$chr = substr($U_100, 1, 1);
d36 2
a37 1
$chr = substr($POUND_SIGN, 0, 1);
d39 2
a40 1
$chr = substr($POUND_SIGN, 1, 1);
d70 2
a71 1
    $chr = byte_utf8a_to_utf8n(chr(196).chr(172));
d90 1
a90 1
    print F $b,"\n"; # Don't upgrade $b
d99 1
a99 1
	{ use bytes; if ($::IS_EBCDIC){$y += 2;}else{$y += 3;}} # EBCDIC ASCII
d110 1
a110 1
    if ($::IS_EBCDIC) { $chr = v141.83.130; } # EBCDIC
d144 1
a144 1
if ($::IS_EBCDIC) { $chr = v141.83.130; } # EBCDIC
d168 2
a169 2
    if ($::IS_EBCDIC) {
	skip("EBCDIC The file isn't deformed in UTF-EBCDIC", 2);
d226 1
a226 1
    like( $@@, qr/Wide character in print/ );
d260 1
a260 1
    like( $@@, qr/Wide character in print/ );
d333 1
a333 1
    if ($::IS_EBCDIC)	# EBCDIC
d342 1
a342 1
    if ($::IS_EBCDIC) { ($chrE4, $chrF6) = ("43", "EC"); } # EBCDIC
d396 1
a396 1
    open my $uh, "<:utf8", \($uuf = $U_100);
@


