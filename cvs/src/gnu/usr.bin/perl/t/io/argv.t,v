head	1.12;
access;
symbols
	OPENBSD_6_1:1.12.0.2
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.11.0.10
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.4
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.11.0.6
	OPENBSD_5_8_BASE:1.11
	PERL_5_20_2:1.1.1.10
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	PERL_5_20_1:1.1.1.10
	OPENBSD_5_6:1.10.0.8
	OPENBSD_5_6_BASE:1.10
	PERL_5_18_2:1.1.1.9
	PERL:1.1.1
	OPENBSD_5_5:1.10.0.6
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.2
	OPENBSD_5_4_BASE:1.10
	PERL_5_16_3:1.1.1.9
	OPENBSD_5_3:1.9.0.18
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.16
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.14
	OPENBSD_5_0:1.9.0.12
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.10
	OPENBSD_4_9_BASE:1.9
	PERL_5_12_2:1.1.1.8
	OPENBSD_4_8:1.9.0.8
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.4
	OPENBSD_4_7_BASE:1.9
	PERL_5_10_1:1.1.1.8
	OPENBSD_4_6:1.9.0.6
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.2
	OPENBSD_4_5_BASE:1.9
	PERL_5_10_0:1.1.1.8
	OPENBSD_4_4:1.8.0.10
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.8
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.6
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.4
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.2
	OPENBSD_4_0_BASE:1.8
	PERL_5_8_8:1.1.1.7
	OPENBSD_3_9:1.7.0.10
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.8
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.6
	OPENBSD_3_7_BASE:1.7
	PERL_5_8_6:1.1.1.6
	OPENBSD_3_6:1.7.0.4
	OPENBSD_3_6_BASE:1.7
	PERL_5_8_5:1.1.1.6
	PERL_5_8_3:1.1.1.6
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.12
date	2017.02.05.00.32.19;	author afresh1;	state Exp;
branches;
next	1.11;
commitid	cxJ08BvJA9Pt2PTM;

1.11
date	2014.11.17.20.57.07;	author afresh1;	state Exp;
branches;
next	1.10;
commitid	QP75iYx42Uo7mMxO;

1.10
date	2013.03.25.20.40.59;	author sthen;	state Exp;
branches;
next	1.9;

1.9
date	2008.09.29.17.36.18;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2006.03.28.19.23.12;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.48;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.35;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.36.07;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.07.59;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.52.27;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.08.00.11;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.13.12;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.13.12;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.41.19;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.10.39;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.25.04;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.15.10;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.44.29;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2006.03.28.18.49.41;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2008.09.29.17.18.58;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2013.03.25.20.09.33;	author sthen;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2014.11.17.20.53.17;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.12
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl

BEGIN {
    chdir 't' if -d 't';
    @@INC = '../lib';
}

BEGIN { require "./test.pl"; }

plan(tests => 37);

my ($devnull, $no_devnull);

if (is_miniperl()) {
    $no_devnull = "no dynamic loading on miniperl, File::Spec not built, so can't determine /dev/null";
} else {
    require File::Spec;
    $devnull = File::Spec->devnull;
}

open(TRY, '>Io_argv1.tmp') || (die "Can't open temp file: $!");
print TRY "a line\n";
close TRY or die "Could not close: $!";
open(TRY, '>Io_argv2.tmp') || (die "Can't open temp file: $!");
print TRY "another line\n";
close TRY or die "Could not close: $!";

$x = runperl(
    prog	=> 'while (<>) { print $., $_; }',
    args	=> [ 'Io_argv1.tmp', 'Io_argv1.tmp' ],
);
is($x, "1a line\n2a line\n", '<> from two files');

{
    $x = runperl(
	prog	=> 'while (<>) { print $_; }',
	stdin	=> "foo\n",
	args	=> [ 'Io_argv1.tmp', '-' ],
    );
    is($x, "a line\nfoo\n", '<> from a file and STDIN');

    # readline should behave as <>, not <<>>
    $x = runperl(
        prog	=> 'while (readline) { print $_; }',
        stdin	=> "foo\n",
        stderr 	=> 1,
        args	=> [ '-' ],
    );
    is($x, "foo\n", 'readline() from STDIN');

    $x = runperl(
	prog	=> 'while (<>) { print $_; }',
	stdin	=> "foo\n",
    );
    is($x, "foo\n", '<> from just STDIN');

    $x = runperl(
	prog	=> 'while (<>) { print $ARGV.q/,/.$_ }',
	args	=> [ 'Io_argv1.tmp', 'Io_argv2.tmp' ],
    );
    is($x, "Io_argv1.tmp,a line\nIo_argv2.tmp,another line\n", '$ARGV is the file name');

TODO: {
        local $::TODO = "unrelated bug in redirection implementation" if $^O eq 'VMS';
        $x = runperl(
            prog	=> 'print $ARGV while <>',
            stdin	=> "foo\nbar\n",
            args   	=> [ '-' ],
        );
        is($x, "--", '$ARGV is - for explicit STDIN');

        $x = runperl(
            prog	=> 'print $ARGV while <>',
            stdin	=> "foo\nbar\n",
        );
        is($x, "--", '$ARGV is - for implicit STDIN');
    }
}

{
    # 5.10 stopped autovivifying scalars in globs leading to a
    # segfault when $ARGV is written to.
    runperl( prog => 'eof()', stdin => "nothing\n" );
    is( 0+$?, 0, q(eof() doesn't segfault) );
}

@@ARGV = is_miniperl() ? ('Io_argv1.tmp', 'Io_argv1.tmp', 'Io_argv1.tmp')
    : ('Io_argv1.tmp', 'Io_argv1.tmp', $devnull, 'Io_argv1.tmp');
while (<>) {
    $y .= $. . $_;
    if (eof()) {
	is($., 3, '$. counts <>');
    }
}

is($y, "1a line\n2a line\n3a line\n", '<> from @@ARGV');


open(TRY, '>Io_argv1.tmp') or die "Can't open temp file: $!";
close TRY or die "Could not close: $!";
open(TRY, '>Io_argv2.tmp') or die "Can't open temp file: $!";
close TRY or die "Could not close: $!";
@@ARGV = ('Io_argv1.tmp', 'Io_argv2.tmp');
$^I = '_bak';   # not .bak which confuses VMS
$/ = undef;
my $i = 11;
while (<>) {
    s/^/ok $i\n/;
    ++$i;
    print;
    next_test();
}
open(TRY, '<Io_argv1.tmp') or die "Can't open temp file: $!";
print while <TRY>;
open(TRY, '<Io_argv2.tmp') or die "Can't open temp file: $!";
print while <TRY>;
close TRY or die "Could not close: $!";
undef $^I;

ok( eof TRY );

{
    no warnings 'once';
    ok( eof NEVEROPENED,    'eof() true on unopened filehandle' );
}

open STDIN, 'Io_argv1.tmp' or die $!;
@@ARGV = ();
ok( !eof(),     'STDIN has something' );

is( <>, "ok 11\n" );

SKIP: {
    skip_if_miniperl($no_devnull, 4);
    open STDIN, $devnull or die $!;
    @@ARGV = ();
    ok( eof(),      'eof() true with empty @@ARGV' );

    @@ARGV = ('Io_argv1.tmp');
    ok( !eof() );

    @@ARGV = ($devnull, $devnull);
    ok( !eof() );

    close ARGV or die $!;
    ok( eof(),      'eof() true after closing ARGV' );
}

SKIP: {
    local $/;
    open my $fh, 'Io_argv1.tmp' or die "Could not open Io_argv1.tmp: $!";
    <$fh>;	# set $. = 1
    is( <$fh>, undef );

    skip_if_miniperl($no_devnull, 5);

    open $fh, $devnull or die;
    ok( defined(<$fh>) );

    is( <$fh>, undef );
    is( <$fh>, undef );

    open $fh, $devnull or die;	# restart cycle again
    ok( defined(<$fh>) );
    is( <$fh>, undef );
    close $fh or die "Could not close: $!";
}

open(TRY, '>Io_argv1.tmp') || (die "Can't open temp file: $!");
print TRY "one\n\nthree\n";
close TRY or die "Could not close: $!";

$x = runperl(
    prog	=> 'print $..$ARGV.$_ while <<>>',
    args	=> [ 'Io_argv1.tmp' ],
);
is($x, "1Io_argv1.tmpone\n2Io_argv1.tmp\n3Io_argv1.tmpthree\n", '<<>>');

$x = runperl(
    prog	=> '$w=q/b/;$w.=<<>>;print $w',
    args	=> [ 'Io_argv1.tmp' ],
);
is($x, "bone\n", '<<>> and rcatline');

$x = runperl(
    prog	=> 'while (<<>>) { print }',
    stdin	=> "foo\n",
);
is($x, "foo\n", '<<>> from just STDIN (no argument)');

TODO: {
    local $::TODO = "unrelated bug in redirection implementation" if $^O eq 'VMS';
    $x = runperl(
        prog	=> 'print $ARGV.q/,/ for <<>>',
        stdin	=> "foo\nbar\n",
    );
    is($x, "-,-,", '$ARGV is - for STDIN with <<>>');
}

$x = runperl(
    prog	=> 'while (<<>>) { print $_; }',
    stdin	=> "foo\n",
    stderr	=> 1,
    args	=> [ '-' ],
);
like($x, qr/^Can't open -: .* at -e line 1/, '<<>> does not treat - as STDIN');

{
    # tests for an empty string in @@ARGV
    $x = runperl(
        prog	=> 'push @@ARGV,q//;print while <>',
        stderr	=> 1,
    );
    like($x, qr/^Can't open : .* at -e line 1/, '<> does not open empty string in ARGV');

    $x = runperl(
        prog	=> 'push @@ARGV,q//;print while <<>>',
        stderr	=> 1,
    );
    like($x, qr/^Can't open : .* at -e line 1/, '<<>> does not open empty string in ARGV');
}

SKIP: {
    skip('no echo', 2) unless -x '/bin/echo';

    $x = runperl(
        prog	=> 'while (<<>>) { print $_; }',
        stderr	=> 1,
        args	=> [ '"echo foo |"' ],
    );
    like($x, qr/^Can't open echo foo \|: .* at -e line 1/, '<<>> does not treat ...| as fork');

    $x = runperl(
        prog	=> 'while (<<>>) { }',
        stderr	=> 1,
        args	=> [ 'Io_argv1.tmp', '"echo foo |"' ],
    );
    like($x, qr/^Can't open echo foo \|: .* at -e line 1, <> line 3/, '<<>> does not treat ...| as fork after eof');
}

# This used to dump core
fresh_perl_is( <<'**PROG**', "foobar", {}, "ARGV aliasing and eof()" ); 
open OUT, ">Io_argv3.tmp" or die "Can't open temp file: $!";
print OUT "foo";
close OUT;
open IN, "Io_argv3.tmp" or die "Can't open temp file: $!";
*ARGV = *IN;
while (<>) {
    print;
    print "bar" if eof();
}
close IN;
unlink "Io_argv3.tmp";
**PROG**

# This used to fail an assertion.
# The tricks with *x and $x are to make PL_argvgv point to a freed SV when
# the readline op does SvREFCNT_inc on it.  undef *x clears the scalar slot
# ++$x vivifies it, reusing the just-deleted GV that PL_argvgv still points
# to.  The BEGIN block ensures it is freed late enough that nothing else
# has reused it yet.
is runperl(prog => 'undef *x; delete $::{ARGV}; $x++;'
                  .'eval q-BEGIN{undef *x} readline-; print qq-ok\n-'),
  "ok\n", 'deleting $::{ARGV}';

END {
    unlink_all 'Io_argv1.tmp', 'Io_argv1.tmp_bak',
	'Io_argv2.tmp', 'Io_argv2.tmp_bak', 'Io_argv3.tmp';
}
@


1.11
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d10 1
a10 1
plan(tests => 24);
d24 3
d40 10
a49 1
    is($x, "a line\nfoo\n", '   from a file and STDIN');
d55 23
a77 1
    is($x, "foo\n", '   from just STDIN');
d106 1
a106 1
my $i = 7;
d131 1
a131 1
is( <>, "ok 7\n" );
d167 72
@


1.10
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d10 1
a10 1
plan(tests => 23);
d149 10
@


1.9
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d12 1
a12 1
use File::Spec;
d14 6
a19 1
my $devnull = File::Spec->devnull;
d53 2
a54 1
@@ARGV = ('Io_argv1.tmp', 'Io_argv1.tmp', $devnull, 'Io_argv1.tmp');
d99 5
a103 3
open STDIN, $devnull or die $!;
@@ARGV = ();
ok( eof(),      'eof() true with empty @@ARGV' );
d105 2
a106 2
@@ARGV = ('Io_argv1.tmp');
ok( !eof() );
d108 2
a109 2
@@ARGV = ($devnull, $devnull);
ok( !eof() );
d111 3
a113 2
close ARGV or die $!;
ok( eof(),      'eof() true after closing ARGV' );
d115 1
a115 1
{
d117 16
a132 14
    open F, 'Io_argv1.tmp' or die "Could not open Io_argv1.tmp: $!";
    <F>;	# set $. = 1
    is( <F>, undef );

    open F, $devnull or die;
    ok( defined(<F>) );

    is( <F>, undef );
    is( <F>, undef );

    open F, $devnull or die;	# restart cycle again
    ok( defined(<F>) );
    is( <F>, undef );
    close F or die "Could not close: $!";
d151 1
a151 1
    1 while unlink 'Io_argv1.tmp', 'Io_argv1.tmp_bak',
@


1.8
log
@merge in perl 5.8.8
@
text
@d8 1
a8 1
require "./test.pl";
d10 1
a10 1
plan(tests => 22);
d41 7
d66 1
a66 1
my $i = 6;
d91 1
a91 1
is( <>, "ok 6\n" );
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d75 4
a78 1
ok( eof NEVEROPENED,    'eof() true on unopened filehandle' );
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d130 1
a130 1
    unlink 'Io_argv1.tmp', 'Io_argv1.tmp_bak',
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d8 3
a10 1
print "1..21\n";
d16 9
a24 3
open(try, '>Io_argv1.tmp') || (die "Can't open temp file: $!");
print try "a line\n";
close try;
d26 13
a38 21
if ($^O eq 'MSWin32') {
  $x = `.\\perl -e "while (<>) {print \$.,\$_;}" Io_argv1.tmp Io_argv1.tmp`;
}
else {
  $x = `./perl -e 'while (<>) {print \$.,\$_;}' Io_argv1.tmp Io_argv1.tmp`;
}
if ($x eq "1a line\n2a line\n") {print "ok 1\n";} else {print "not ok 1\n";}

if ($^O eq 'MSWin32') {
  $x = `.\\perl -le "print 'foo'" | .\\perl -e "while (<>) {print \$_;}" Io_argv1.tmp -`;
}
else {
  $x = `echo foo|./perl -e 'while (<>) {print $_;}' Io_argv1.tmp -`;
}
if ($x eq "a line\nfoo\n") {print "ok 2\n";} else {print "not ok 2\n";}

if ($^O eq 'MSWin32') {
  $x = `.\\perl -le "print 'foo'" |.\\perl -e "while (<>) {print \$_;}"`;
}
else {
  $x = `echo foo|./perl -e 'while (<>) {print $_;}'`;
a39 1
if ($x eq "foo\n") {print "ok 3\n";} else {print "not ok 3 :$x:\n";}
d45 1
a45 1
	if ($. == 3) {print "ok 4\n";} else {print "not ok 4\n";}
d49 7
a55 9
if ($y eq "1a line\n2a line\n3a line\n")
    {print "ok 5\n";}
else
    {print "not ok 5\n";}

open(try, '>Io_argv1.tmp') or die "Can't open temp file: $!";
close try;
open(try, '>Io_argv2.tmp') or die "Can't open temp file: $!";
close try;
d57 1
a57 1
$^I = '.bak';
d64 1
d66 5
a70 5
open(try, '<Io_argv1.tmp') or die "Can't open temp file: $!";
print while <try>;
open(try, '<Io_argv2.tmp') or die "Can't open temp file: $!";
print while <try>;
close try;
d73 1
a73 2
eof try or print 'not ';
print "ok 8\n";
d75 1
a75 2
eof NEVEROPENED or print 'not ';
print "ok 9\n";
d79 1
a79 2
!eof() or print 'not ';
print "ok 10\n";
d81 1
a81 2
<> eq "ok 6\n" or print 'not ';
print "ok 11\n";
d85 1
a85 2
eof() or print 'not ';
print "ok 12\n";
d88 1
a88 2
!eof() or print 'not ';
print "ok 13\n";
d91 1
a91 2
!eof() or print 'not ';
print "ok 14\n";
d94 1
a94 2
eof() or print 'not ';
print "ok 15\n";
d98 1
a98 1
    open F, 'Io_argv1.tmp' or die;
d100 2
a101 2
    print "not " if defined(<F>); # should hit eof
    print "ok 16\n";
d103 5
a107 6
    print "not " unless defined(<F>);
    print "ok 17\n";
    print "not " if defined(<F>);
    print "ok 18\n";
    print "not " if defined(<F>);
    print "ok 19\n";
d109 3
a111 5
    print "not " unless defined(<F>);
    print "ok 20\n";
    print "not " if defined(<F>);
    print "ok 21\n";
    close F;
d114 19
a132 1
END { unlink 'Io_argv1.tmp', 'Io_argv1.tmp.bak', 'Io_argv2.tmp', 'Io_argv2.tmp.bak' }
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d5 1
a5 1
    unshift @@INC, '../lib';
d8 1
a8 1
print "1..20\n";
d110 2
a113 2
    print "ok 16\n";
    print "not " if defined(<F>);
d117 2
d121 1
a121 1
    print "ok 19\n";
d123 1
a123 1
    print "ok 20\n";
@


1.3
log
@perl5.005_03 (stock)
@
text
@d3 8
a10 1
print "1..6\n";
d12 3
a14 1
open(try, '>Io.argv.tmp') || (die "Can't open temp file: $!");
d19 1
a19 1
  $x = `.\\perl -e "while (<>) {print \$.,\$_;}" Io.argv.tmp Io.argv.tmp`;
d22 1
a22 1
  $x = `./perl -e 'while (<>) {print \$.,\$_;}' Io.argv.tmp Io.argv.tmp`;
d27 1
a27 1
  $x = `.\\perl -le "print 'foo'" | .\\perl -e "while (<>) {print \$_;}" Io.argv.tmp -`;
d30 1
a30 1
  $x = `echo foo|./perl -e 'while (<>) {print $_;}' Io.argv.tmp -`;
d42 1
a42 1
@@ARGV = ('Io.argv.tmp', 'Io.argv.tmp', '/dev/null', 'Io.argv.tmp');
d55 3
a57 1
open(try, '>Io.argv.tmp') or die "Can't open temp file: $!";
d59 1
a59 1
@@ARGV = 'Io.argv.tmp';
d62 1
d64 2
a65 1
    s/^/ok 6\n/;
d68 3
a70 1
open(try, '<Io.argv.tmp') or die "Can't open temp file: $!";
d73 51
d125 1
a125 1
END { unlink 'Io.argv.tmp', 'Io.argv.tmp.bak' }
@


1.2
log
@perl 5.004_04
@
text
@d3 1
a3 1
# $RCSfile: argv.t,v $$Revision: 4.1 $$Date: 92/08/07 18:27:25 $
d5 1
a5 3
print "1..5\n";

open(try, '>Io.argv.tmp') || (die "Can't open temp file.");
d46 14
a59 1
unlink 'Io.argv.tmp';
@


1.1
log
@Initial revision
@
text
@d11 6
a16 2
$x = `./perl -e 'while (<>) {print \$.,\$_;}' Io.argv.tmp Io.argv.tmp`;

d19 6
a24 2
$x = `echo foo|./perl -e 'while (<>) {print $_;}' Io.argv.tmp -`;

d27 6
a32 2
$x = `echo foo|./perl -e 'while (<>) {print $_;}'`;

d48 1
a48 1
`/bin/rm -f Io.argv.tmp` if -x '/bin/rm';
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d3 1
a3 1
print "1..6\n";
d5 3
a7 1
open(try, '>Io.argv.tmp') || (die "Can't open temp file: $!");
d11 2
a12 6
if ($^O eq 'MSWin32') {
  $x = `.\\perl -e "while (<>) {print \$.,\$_;}" Io.argv.tmp Io.argv.tmp`;
}
else {
  $x = `./perl -e 'while (<>) {print \$.,\$_;}' Io.argv.tmp Io.argv.tmp`;
}
d15 2
a16 6
if ($^O eq 'MSWin32') {
  $x = `.\\perl -le "print 'foo'" | .\\perl -e "while (<>) {print \$_;}" Io.argv.tmp -`;
}
else {
  $x = `echo foo|./perl -e 'while (<>) {print $_;}' Io.argv.tmp -`;
}
d19 2
a20 6
if ($^O eq 'MSWin32') {
  $x = `.\\perl -le "print 'foo'" |.\\perl -e "while (<>) {print \$_;}"`;
}
else {
  $x = `echo foo|./perl -e 'while (<>) {print $_;}'`;
}
d36 1
a36 14
open(try, '>Io.argv.tmp') or die "Can't open temp file: $!";
close try;
@@ARGV = 'Io.argv.tmp';
$^I = '.bak';
$/ = undef;
while (<>) {
    s/^/ok 6\n/;
    print;
}
open(try, '<Io.argv.tmp') or die "Can't open temp file: $!";
print while <try>;
close try;

END { unlink 'Io.argv.tmp', 'Io.argv.tmp.bak' }
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d3 1
a3 8
BEGIN {
    chdir 't' if -d 't';
    unshift @@INC, '../lib';
}

print "1..20\n";

use File::Spec;
d5 1
a5 3
my $devnull = File::Spec->devnull;

open(try, '>Io_argv1.tmp') || (die "Can't open temp file: $!");
d10 1
a10 1
  $x = `.\\perl -e "while (<>) {print \$.,\$_;}" Io_argv1.tmp Io_argv1.tmp`;
d13 1
a13 1
  $x = `./perl -e 'while (<>) {print \$.,\$_;}' Io_argv1.tmp Io_argv1.tmp`;
d18 1
a18 1
  $x = `.\\perl -le "print 'foo'" | .\\perl -e "while (<>) {print \$_;}" Io_argv1.tmp -`;
d21 1
a21 1
  $x = `echo foo|./perl -e 'while (<>) {print $_;}' Io_argv1.tmp -`;
d33 1
a33 1
@@ARGV = ('Io_argv1.tmp', 'Io_argv1.tmp', $devnull, 'Io_argv1.tmp');
d46 1
a46 3
open(try, '>Io_argv1.tmp') or die "Can't open temp file: $!";
close try;
open(try, '>Io_argv2.tmp') or die "Can't open temp file: $!";
d48 1
a48 1
@@ARGV = ('Io_argv1.tmp', 'Io_argv2.tmp');
a50 1
my $i = 6;
d52 1
a52 2
    s/^/ok $i\n/;
    ++$i;
d55 1
a55 3
open(try, '<Io_argv1.tmp') or die "Can't open temp file: $!";
print while <try>;
open(try, '<Io_argv2.tmp') or die "Can't open temp file: $!";
a57 51
undef $^I;

eof try or print 'not ';
print "ok 8\n";

eof NEVEROPENED or print 'not ';
print "ok 9\n";

open STDIN, 'Io_argv1.tmp' or die $!;
@@ARGV = ();
!eof() or print 'not ';
print "ok 10\n";

<> eq "ok 6\n" or print 'not ';
print "ok 11\n";

open STDIN, $devnull or die $!;
@@ARGV = ();
eof() or print 'not ';
print "ok 12\n";

@@ARGV = ('Io_argv1.tmp');
!eof() or print 'not ';
print "ok 13\n";

@@ARGV = ($devnull, $devnull);
!eof() or print 'not ';
print "ok 14\n";

close ARGV or die $!;
eof() or print 'not ';
print "ok 15\n";

{
    local $/;
    open F, 'Io_argv1.tmp' or die;
    <F>;	# set $. = 1
    open F, $devnull or die;
    print "not " unless defined(<F>);
    print "ok 16\n";
    print "not " if defined(<F>);
    print "ok 17\n";
    print "not " if defined(<F>);
    print "ok 18\n";
    open F, $devnull or die;	# restart cycle again
    print "not " unless defined(<F>);
    print "ok 19\n";
    print "not " if defined(<F>);
    print "ok 20\n";
    close F;
}
d59 1
a59 1
END { unlink 'Io_argv1.tmp', 'Io_argv1.tmp.bak', 'Io_argv2.tmp', 'Io_argv2.tmp.bak' }
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d5 1
a5 1
    @@INC = '../lib';
d8 1
a8 1
print "1..21\n";
a109 2
    print "not " if defined(<F>); # should hit eof
    print "ok 16\n";
d112 2
a116 2
    print "not " if defined(<F>);
    print "ok 19\n";
d119 2
a121 2
    print "not " if defined(<F>);
    print "ok 21\n";
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d8 1
a8 3
require "./test.pl";

plan(tests => 22);
d14 3
a16 9
open(TRY, '>Io_argv1.tmp') || (die "Can't open temp file: $!");
print TRY "a line\n";
close TRY or die "Could not close: $!";

$x = runperl(
    prog	=> 'while (<>) { print $., $_; }',
    args	=> [ 'Io_argv1.tmp', 'Io_argv1.tmp' ],
);
is($x, "1a line\n2a line\n", '<> from two files');
d18 21
a38 13
{
    $x = runperl(
	prog	=> 'while (<>) { print $_; }',
	stdin	=> "foo\n",
	args	=> [ 'Io_argv1.tmp', '-' ],
    );
    is($x, "a line\nfoo\n", '   from a file and STDIN');

    $x = runperl(
	prog	=> 'while (<>) { print $_; }',
	stdin	=> "foo\n",
    );
    is($x, "foo\n", '   from just STDIN');
d40 1
d46 1
a46 1
	is($., 3, '$. counts <>');
d50 9
a58 7
is($y, "1a line\n2a line\n3a line\n", '<> from @@ARGV');


open(TRY, '>Io_argv1.tmp') or die "Can't open temp file: $!";
close TRY or die "Could not close: $!";
open(TRY, '>Io_argv2.tmp') or die "Can't open temp file: $!";
close TRY or die "Could not close: $!";
d60 1
a60 1
$^I = '_bak';   # not .bak which confuses VMS
a66 1
    next_test();
d68 5
a72 5
open(TRY, '<Io_argv1.tmp') or die "Can't open temp file: $!";
print while <TRY>;
open(TRY, '<Io_argv2.tmp') or die "Can't open temp file: $!";
print while <TRY>;
close TRY or die "Could not close: $!";
d75 2
a76 1
ok( eof TRY );
d78 2
a79 1
ok( eof NEVEROPENED,    'eof() true on unopened filehandle' );
d83 2
a84 1
ok( !eof(),     'STDIN has something' );
d86 2
a87 1
is( <>, "ok 6\n" );
d91 2
a92 1
ok( eof(),      'eof() true with empty @@ARGV' );
d95 2
a96 1
ok( !eof() );
d99 2
a100 1
ok( !eof() );
d103 2
a104 1
ok( eof(),      'eof() true after closing ARGV' );
d108 1
a108 1
    open F, 'Io_argv1.tmp' or die "Could not open Io_argv1.tmp: $!";
d110 2
a111 2
    is( <F>, undef );

d113 6
a118 5
    ok( defined(<F>) );

    is( <F>, undef );
    is( <F>, undef );

d120 5
a124 3
    ok( defined(<F>) );
    is( <F>, undef );
    close F or die "Could not close: $!";
d127 1
a127 19
# This used to dump core
fresh_perl_is( <<'**PROG**', "foobar", {}, "ARGV aliasing and eof()" ); 
open OUT, ">Io_argv3.tmp" or die "Can't open temp file: $!";
print OUT "foo";
close OUT;
open IN, "Io_argv3.tmp" or die "Can't open temp file: $!";
*ARGV = *IN;
while (<>) {
    print;
    print "bar" if eof();
}
close IN;
unlink "Io_argv3.tmp";
**PROG**

END {
    unlink 'Io_argv1.tmp', 'Io_argv1.tmp_bak',
	'Io_argv2.tmp', 'Io_argv2.tmp_bak', 'Io_argv3.tmp';
}
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@d130 1
a130 1
    1 while unlink 'Io_argv1.tmp', 'Io_argv1.tmp_bak',
@


1.1.1.7
log
@perl 5.8.8 import
@
text
@d75 1
a75 4
{
    no warnings 'once';
    ok( eof NEVEROPENED,    'eof() true on unopened filehandle' );
}
@


1.1.1.8
log
@import perl 5.10.0 from CPAN
@
text
@d8 1
a8 1
BEGIN { require "./test.pl"; }
d10 1
a10 1
plan(tests => 23);
a40 7
{
    # 5.10 stopped autovivifying scalars in globs leading to a
    # segfault when $ARGV is written to.
    runperl( prog => 'eof()', stdin => "nothing\n" );
    is( 0+$?, 0, q(eof() doesn't segfault) );
}

d59 1
a59 1
my $i = 7;
d84 1
a84 1
is( <>, "ok 7\n" );
@


1.1.1.9
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d12 1
a12 1
my ($devnull, $no_devnull);
d14 1
a14 6
if (is_miniperl()) {
    $no_devnull = "no dynamic loading on miniperl, File::Spec not built, so can't determine /dev/null";
} else {
    require File::Spec;
    $devnull = File::Spec->devnull;
}
d48 1
a48 2
@@ARGV = is_miniperl() ? ('Io_argv1.tmp', 'Io_argv1.tmp', 'Io_argv1.tmp')
    : ('Io_argv1.tmp', 'Io_argv1.tmp', $devnull, 'Io_argv1.tmp');
d93 3
a95 5
SKIP: {
    skip_if_miniperl($no_devnull, 4);
    open STDIN, $devnull or die $!;
    @@ARGV = ();
    ok( eof(),      'eof() true with empty @@ARGV' );
d97 2
a98 2
    @@ARGV = ('Io_argv1.tmp');
    ok( !eof() );
d100 2
a101 2
    @@ARGV = ($devnull, $devnull);
    ok( !eof() );
d103 2
a104 3
    close ARGV or die $!;
    ok( eof(),      'eof() true after closing ARGV' );
}
d106 1
a106 1
SKIP: {
d108 14
a121 16
    open my $fh, 'Io_argv1.tmp' or die "Could not open Io_argv1.tmp: $!";
    <$fh>;	# set $. = 1
    is( <$fh>, undef );

    skip_if_miniperl($no_devnull, 5);

    open $fh, $devnull or die;
    ok( defined(<$fh>) );

    is( <$fh>, undef );
    is( <$fh>, undef );

    open $fh, $devnull or die;	# restart cycle again
    ok( defined(<$fh>) );
    is( <$fh>, undef );
    close $fh or die "Could not close: $!";
d140 1
a140 1
    unlink_all 'Io_argv1.tmp', 'Io_argv1.tmp_bak',
@


1.1.1.10
log
@Import perl-5.20.1
@
text
@d10 1
a10 1
plan(tests => 24);
a148 10

# This used to fail an assertion.
# The tricks with *x and $x are to make PL_argvgv point to a freed SV when
# the readline op does SvREFCNT_inc on it.  undef *x clears the scalar slot
# ++$x vivifies it, reusing the just-deleted GV that PL_argvgv still points
# to.  The BEGIN block ensures it is freed late enough that nothing else
# has reused it yet.
is runperl(prog => 'undef *x; delete $::{ARGV}; $x++;'
                  .'eval q-BEGIN{undef *x} readline-; print qq-ok\n-'),
  "ok\n", 'deleting $::{ARGV}';
@


