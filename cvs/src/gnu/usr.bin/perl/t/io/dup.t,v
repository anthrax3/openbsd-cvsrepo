head	1.11;
access;
symbols
	PERL_5_24_2:1.1.1.9
	OPENBSD_6_1:1.11.0.28
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.11.0.26
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.20
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.11.0.22
	OPENBSD_5_8_BASE:1.11
	PERL_5_20_2:1.1.1.9
	OPENBSD_5_7:1.11.0.14
	OPENBSD_5_7_BASE:1.11
	PERL_5_20_1:1.1.1.9
	OPENBSD_5_6:1.11.0.18
	OPENBSD_5_6_BASE:1.11
	PERL_5_18_2:1.1.1.9
	PERL:1.1.1
	OPENBSD_5_5:1.11.0.16
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.12
	OPENBSD_5_4_BASE:1.11
	PERL_5_16_3:1.1.1.9
	OPENBSD_5_3:1.11.0.10
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.8
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.6
	OPENBSD_5_0:1.11.0.4
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.2
	OPENBSD_4_9_BASE:1.11
	PERL_5_12_2:1.1.1.9
	OPENBSD_4_8:1.10.0.4
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.2
	OPENBSD_4_7_BASE:1.10
	PERL_5_10_1:1.1.1.8
	OPENBSD_4_6:1.9.0.6
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.2
	OPENBSD_4_5_BASE:1.9
	PERL_5_10_0:1.1.1.7
	OPENBSD_4_4:1.8.0.10
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.8
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.6
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.4
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.2
	OPENBSD_4_0_BASE:1.8
	PERL_5_8_8:1.1.1.6
	OPENBSD_3_9:1.7.0.10
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.8
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.6
	OPENBSD_3_7_BASE:1.7
	PERL_5_8_6:1.1.1.5
	OPENBSD_3_6:1.7.0.4
	OPENBSD_3_6_BASE:1.7
	PERL_5_8_5:1.1.1.5
	PERL_5_8_3:1.1.1.5
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.5
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.11
date	2010.09.24.15.07.05;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2009.10.12.18.30.27;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2008.09.29.17.36.18;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2006.03.28.19.23.12;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.48;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.35;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.36.07;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.08.00;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.52.27;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.08.00.12;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.13.12;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.13.12;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.41.20;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.10.39;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.27.22.15.10;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.12.03.02.44.29;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2006.03.28.18.49.41;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2008.09.29.17.18.58;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2009.10.12.18.10.42;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2010.09.24.14.49.19;	author millert;	state Exp;
branches;
next	;


desc
@@


1.11
log
@merge in perl 5.12.2 plus local changes
@
text
@#!./perl

BEGIN {
    chdir 't' if -d 't';
    @@INC = qw(. ../lib);
    require "./test.pl";
}

use Config;
no warnings 'once';

my $test = 1;
my $tests_needing_perlio = 17;
plan(12 + $tests_needing_perlio);
print "ok 1\n";

open(DUPOUT,">&STDOUT");
open(DUPERR,">&STDERR");

my $tempfile = tempfile();

open(STDOUT,">$tempfile")  || die "Can't open stdout";
open(STDERR,">&STDOUT") || die "Can't open stderr";

select(STDERR); $| = 1;
select(STDOUT); $| = 1;

print STDOUT "ok 2\n";
print STDERR "ok 3\n";

# Since some systems don't have echo, we use Perl.
$echo = qq{$^X -le "print q(ok %d)"};

$cmd = sprintf $echo, 4;
print `$cmd`;

$cmd = sprintf "$echo 1>&2", 5;
print `$cmd`;

system sprintf $echo, 6;
system sprintf "$echo 1>&2", 7;

close(STDOUT) or die "Could not close: $!";
close(STDERR) or die "Could not close: $!";

open(STDOUT,">&DUPOUT") or die "Could not open: $!";
open(STDERR,">&DUPERR") or die "Could not open: $!";

if (($^O eq 'MSWin32') || ($^O eq 'NetWare')) { print `type $tempfile` }
elsif ($^O eq 'VMS')   { system "type $tempfile.;" } # TYPE defaults to .LIS when there is no extension
else { system "cat $tempfile" }

print STDOUT "ok 8\n";

open(F,">&",1) or die "Cannot dup to numeric 1: $!";
print F "ok 9\n";
close(F);

open(F,">&",'1') or die "Cannot dup to string '1': $!";
print F "ok 10\n";
close(F);

open(F,">&=",1) or die "Cannot dup to numeric 1: $!";
print F "ok 11\n";
close(F);

if ($Config{useperlio}) {
    open(F,">&=",'1') or die "Cannot dup to string '1': $!";
    print F "ok 12\n";
    close(F);
} else {
    open(F, ">&DUPOUT") or die "Cannot dup stdout back: $!";
    print F "ok 12\n";
    close(F);
}

# To get STDOUT back.
open(F, ">&DUPOUT") or die "Cannot dup stdout back: $!";

curr_test(13);

SKIP: {
    skip("need perlio", $tests_needing_perlio) unless $Config{useperlio};
    
    ok(open(F, ">&", STDOUT));
    isnt(fileno(F), fileno(STDOUT));
    close F;

    ok(open(F, "<&=STDIN")) or _diag $!;
    is(fileno(F), fileno(STDIN));
    close F;

    ok(open(F, ">&=STDOUT"));
    is(fileno(F), fileno(STDOUT));
    close F;

    ok(open(F, ">&=STDERR"));
    is(fileno(F), fileno(STDERR));
    close F;

    open(G, ">$tempfile") or die;
    my $g = fileno(G);

    ok(open(F, ">&=$g"));
    is(fileno(F), $g);
    close F;

    ok(open(F, ">&=G"));
    is(fileno(F), $g);

    print G "ggg\n";
    print F "fff\n";

    close G; # flush first
    close F; # flush second

    open(G, "<$tempfile") or die;
    {
	my $line;
	$line = <G>; chomp $line; is($line, "ggg");
	$line = <G>; chomp $line; is($line, "fff");
    }
    close G;

    open UTFOUT, '>:utf8', $tempfile or die $!;
    open UTFDUP, '>&UTFOUT' or die $!;
    # some old greek saying.
    my $message = "\x{03A0}\x{0391}\x{039D}\x{03A4}\x{0391} \x{03A1}\x{0395}\x{0399}\n";
    print UTFOUT $message;
    print UTFDUP $message;
    binmode UTFDUP, ':utf8';
    print UTFDUP $message;
    close UTFOUT;
    close UTFDUP;
    open(UTFIN, "<:utf8", $tempfile) or die $!;
    {
	my $line;
	$line = <UTFIN>; is($line, $message);
	$line = <UTFIN>; is($line, $message);
	$line = <UTFIN>; is($line, $message);
    }
    close UTFIN;

}
@


1.10
log
@Merge in perl 5.10.1; part two
@
text
@a37 1
$cmd = sprintf $echo, 5 if $^O eq 'MacOS';  # don't know if we can do this ...
d41 1
a41 6
if ($^O eq 'MacOS') {
    system sprintf $echo, 7;
}
else {
    system sprintf "$echo 1>&2", 7;
}
d51 1
a51 2
elsif ($^O eq 'MacOS') { system "catenate $tempfile" }
else                   { system "cat $tempfile" }
@


1.9
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d20 3
a22 1
open(STDOUT,">Io.dup")  || die "Can't open stdout";
d41 3
a43 4
# KNOWN BUG system() does not honor STDOUT redirections on VMS.
if( $^O eq 'VMS' ) {
    print "not ok $_ # TODO system() not honoring STDOUT redirect on VMS\n"
      for 6..7;
d46 1
a46 7
    system sprintf $echo, 6;
    if ($^O eq 'MacOS') {
        system sprintf $echo, 7;
    }
    else {
        system sprintf "$echo 1>&2", 7;
    }
d55 4
a58 4
if (($^O eq 'MSWin32') || ($^O eq 'NetWare') || ($^O eq 'VMS')) { print `type Io.dup` }
elsif ($^O eq 'MacOS') { system 'catenate Io.dup' }
else                   { system 'cat Io.dup' }
unlink 'Io.dup';
d108 1
a108 1
    open(G, ">dup$$") or die;
d124 1
a124 1
    open(G, "<dup$$") or die;
d132 1
a132 1
    open UTFOUT, '>:utf8', "dup$$" or die $!;
d142 1
a142 1
    open(UTFIN, "<:utf8", "dup$$") or die $!;
a150 1
    END { 1 while unlink "dup$$" }
@


1.8
log
@merge in perl 5.8.8
@
text
@d13 2
a14 1
print "1..26\n";
d95 1
a95 1
    skip("need perlio", 14) unless $Config{useperlio};
d136 19
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d10 1
d100 1
a100 1
    ok(open(F, "<&=STDIN"));
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d5 2
a6 1
    @@INC = '../lib';
d9 2
d12 1
a12 1
print "1..8\n";
d39 1
a39 1
    print "not ok $_ # TODO system() not honoring STDOUT redirect on VMS\n" 
d65 72
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d3 4
a6 3
# $RCSfile: dup.t,v $$Revision: 4.1 $$Date: 92/08/07 18:27:27 $

print "1..6\n";
d8 2
d12 2
a13 2
open(dupout,">&STDOUT");
open(duperr,">&STDERR");
d15 1
a15 1
open(STDOUT,">Io.dup") || die "Can't open stdout";
d23 15
a37 3
if ($^O eq 'MSWin32') {
    print `echo ok 4`;
    print `echo ok 5 1>&2`; # does this work?
d40 7
a46 2
    system 'echo ok 4';
    system 'echo ok 5 1>&2';
d49 2
a50 2
close(STDOUT);
close(STDERR);
d52 2
a53 2
open(STDOUT,">&dupout");
open(STDERR,">&duperr");
d55 3
a57 2
if ($^O eq 'MSWin32') { print `type Io.dup` }
else                  { system 'cat Io.dup' }
d60 1
a60 1
print STDOUT "ok 6\n";
@


1.4
log
@perl-5.6.0 + local changes
@
text
@@


1.3
log
@perl5.005_03 (stock)
@
text
@d40 1
@


1.2
log
@perl 5.004_04
@
text
@@


1.1
log
@Initial revision
@
text
@d20 8
a27 2
system 'echo ok 4';
system 'echo ok 5 1>&2';
d35 2
a36 1
system 'cat Io.dup';
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d20 2
a21 8
if ($^O eq 'MSWin32') {
    print `echo ok 4`;
    print `echo ok 5 1>&2`; # does this work?
}
else {
    system 'echo ok 4';
    system 'echo ok 5 1>&2';
}
d29 1
a29 2
if ($^O eq 'MSWin32') { print `type Io.dup` }
else                  { system 'cat Io.dup' }
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@a39 1

@


1.1.1.4
log
@stock perl 5.8.0 from CPAN
@
text
@d3 3
a5 4
BEGIN {
    chdir 't' if -d 't';
    @@INC = '../lib';
}
a6 2
my $test = 1;
print "1..8\n";
d9 2
a10 2
open(DUPOUT,">&STDOUT");
open(DUPERR,">&STDERR");
d12 1
a12 1
open(STDOUT,">Io.dup")  || die "Can't open stdout";
d20 3
a22 15

# Since some systems don't have echo, we use Perl.
$echo = qq{$^X -le "print q(ok %d)"};

$cmd = sprintf $echo, 4;
print `$cmd`;

$cmd = sprintf "$echo 1>&2", 5;
$cmd = sprintf $echo, 5 if $^O eq 'MacOS';  # don't know if we can do this ...
print `$cmd`;

# KNOWN BUG system() does not honor STDOUT redirections on VMS.
if( $^O eq 'VMS' ) {
    print "not ok $_ # TODO system() not honoring STDOUT redirect on VMS\n" 
      for 6..7;
d25 2
a26 7
    system sprintf $echo, 6;
    if ($^O eq 'MacOS') {
        system sprintf $echo, 7;
    }
    else {
        system sprintf "$echo 1>&2", 7;
    }
d29 2
a30 2
close(STDOUT) or die "Could not close: $!";
close(STDERR) or die "Could not close: $!";
d32 2
a33 2
open(STDOUT,">&DUPOUT") or die "Could not open: $!";
open(STDERR,">&DUPERR") or die "Could not open: $!";
d35 2
a36 3
if (($^O eq 'MSWin32') || ($^O eq 'NetWare') || ($^O eq 'VMS')) { print `type Io.dup` }
elsif ($^O eq 'MacOS') { system 'catenate Io.dup' }
else                   { system 'cat Io.dup' }
d39 1
a39 1
print STDOUT "ok 8\n";
@


1.1.1.5
log
@perl 5.8.2 from CPAN
@
text
@d5 1
a5 2
    @@INC = qw(. ../lib);
    require "./test.pl";
a7 2
use Config;

d9 1
a9 1
print "1..26\n";
d36 1
a36 1
    print "not ok $_ # TODO system() not honoring STDOUT redirect on VMS\n"
a61 72
open(F,">&",1) or die "Cannot dup to numeric 1: $!";
print F "ok 9\n";
close(F);

open(F,">&",'1') or die "Cannot dup to string '1': $!";
print F "ok 10\n";
close(F);

open(F,">&=",1) or die "Cannot dup to numeric 1: $!";
print F "ok 11\n";
close(F);

if ($Config{useperlio}) {
    open(F,">&=",'1') or die "Cannot dup to string '1': $!";
    print F "ok 12\n";
    close(F);
} else {
    open(F, ">&DUPOUT") or die "Cannot dup stdout back: $!";
    print F "ok 12\n";
    close(F);
}

# To get STDOUT back.
open(F, ">&DUPOUT") or die "Cannot dup stdout back: $!";

curr_test(13);

SKIP: {
    skip("need perlio", 14) unless $Config{useperlio};
    
    ok(open(F, ">&", STDOUT));
    isnt(fileno(F), fileno(STDOUT));
    close F;

    ok(open(F, "<&=STDIN"));
    is(fileno(F), fileno(STDIN));
    close F;

    ok(open(F, ">&=STDOUT"));
    is(fileno(F), fileno(STDOUT));
    close F;

    ok(open(F, ">&=STDERR"));
    is(fileno(F), fileno(STDERR));
    close F;

    open(G, ">dup$$") or die;
    my $g = fileno(G);

    ok(open(F, ">&=$g"));
    is(fileno(F), $g);
    close F;

    ok(open(F, ">&=G"));
    is(fileno(F), $g);

    print G "ggg\n";
    print F "fff\n";

    close G; # flush first
    close F; # flush second

    open(G, "<dup$$") or die;
    {
	my $line;
	$line = <G>; chomp $line; is($line, "ggg");
	$line = <G>; chomp $line; is($line, "fff");
    }
    close G;

    END { 1 while unlink "dup$$" }
}
@


1.1.1.6
log
@perl 5.8.8 import
@
text
@a9 1
no warnings 'once';
d99 1
a99 1
    ok(open(F, "<&=STDIN")) or _diag $!;
@


1.1.1.7
log
@import perl 5.10.0 from CPAN
@
text
@d13 1
a13 2
my $tests_needing_perlio = 17;
plan(12 + $tests_needing_perlio);
d94 1
a94 1
    skip("need perlio", $tests_needing_perlio) unless $Config{useperlio};
a134 19

    open UTFOUT, '>:utf8', "dup$$" or die $!;
    open UTFDUP, '>&UTFOUT' or die $!;
    # some old greek saying.
    my $message = "\x{03A0}\x{0391}\x{039D}\x{03A4}\x{0391} \x{03A1}\x{0395}\x{0399}\n";
    print UTFOUT $message;
    print UTFDUP $message;
    binmode UTFDUP, ':utf8';
    print UTFDUP $message;
    close UTFOUT;
    close UTFDUP;
    open(UTFIN, "<:utf8", "dup$$") or die $!;
    {
	my $line;
	$line = <UTFIN>; is($line, $message);
	$line = <UTFIN>; is($line, $message);
	$line = <UTFIN>; is($line, $message);
    }
    close UTFIN;
@


1.1.1.8
log
@import perl 5.10.1
@
text
@d20 1
a20 3
my $tempfile = tempfile();

open(STDOUT,">$tempfile")  || die "Can't open stdout";
d39 4
a42 3
system sprintf $echo, 6;
if ($^O eq 'MacOS') {
    system sprintf $echo, 7;
d45 7
a51 1
    system sprintf "$echo 1>&2", 7;
d60 4
a63 4
if (($^O eq 'MSWin32') || ($^O eq 'NetWare')) { print `type $tempfile` }
elsif ($^O eq 'VMS')   { system "type $tempfile.;" } # TYPE defaults to .LIS when there is no extension
elsif ($^O eq 'MacOS') { system "catenate $tempfile" }
else                   { system "cat $tempfile" }
d113 1
a113 1
    open(G, ">$tempfile") or die;
d129 1
a129 1
    open(G, "<$tempfile") or die;
d137 1
a137 1
    open UTFOUT, '>:utf8', $tempfile or die $!;
d147 1
a147 1
    open(UTFIN, "<:utf8", $tempfile) or die $!;
d156 1
@


1.1.1.9
log
@Perl 5.12.2 from CPAN
@
text
@d38 1
d42 6
a47 1
system sprintf "$echo 1>&2", 7;
d57 2
a58 1
else { system "cat $tempfile" }
@


