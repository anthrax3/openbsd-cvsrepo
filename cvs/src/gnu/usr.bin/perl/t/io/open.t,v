head	1.15;
access;
symbols
	PERL_5_24_2:1.1.1.14
	OPENBSD_6_1:1.15.0.4
	OPENBSD_6_1_BASE:1.15
	OPENBSD_6_0:1.14.0.10
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.14.0.4
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.14.0.6
	OPENBSD_5_8_BASE:1.14
	PERL_5_20_2:1.1.1.13
	OPENBSD_5_7:1.14.0.2
	OPENBSD_5_7_BASE:1.14
	PERL_5_20_1:1.1.1.13
	OPENBSD_5_6:1.13.0.4
	OPENBSD_5_6_BASE:1.13
	PERL_5_18_2:1.1.1.12
	PERL:1.1.1
	OPENBSD_5_5:1.12.0.6
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.2
	OPENBSD_5_4_BASE:1.12
	PERL_5_16_3:1.1.1.11
	OPENBSD_5_3:1.11.0.10
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.8
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.6
	OPENBSD_5_0:1.11.0.4
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.2
	OPENBSD_4_9_BASE:1.11
	PERL_5_12_2:1.1.1.10
	OPENBSD_4_8:1.10.0.4
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.2
	OPENBSD_4_7_BASE:1.10
	PERL_5_10_1:1.1.1.9
	OPENBSD_4_6:1.9.0.6
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.2
	OPENBSD_4_5_BASE:1.9
	PERL_5_10_0:1.1.1.8
	OPENBSD_4_4:1.8.0.10
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.8
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.6
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.4
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.2
	OPENBSD_4_0_BASE:1.8
	PERL_5_8_8:1.1.1.7
	OPENBSD_3_9:1.7.0.6
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.4
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.2
	OPENBSD_3_7_BASE:1.7
	PERL_5_8_6:1.1.1.6
	OPENBSD_3_6:1.6.0.2
	OPENBSD_3_6_BASE:1.6
	PERL_5_8_5:1.1.1.5
	PERL_5_8_3:1.1.1.4
	OPENBSD_3_5:1.5.0.2
	OPENBSD_3_5_BASE:1.5
	PERL_5_8_2:1.1.1.4
	OPENBSD_3_4:1.4.0.4
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.4.0.2
	OPENBSD_3_3_BASE:1.4
	PERL_5_8_0:1.1.1.3
	OPENBSD_3_2:1.3.0.6
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.4
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.2
	OPENBSD_3_0_BASE:1.3
	PERL_5_6_1:1.1.1.2
	OPENBSD_2_9:1.2.0.6
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	PERL_5_6_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.15
date	2017.02.05.00.32.19;	author afresh1;	state Exp;
branches;
next	1.14;
commitid	cxJ08BvJA9Pt2PTM;

1.14
date	2014.11.17.20.57.07;	author afresh1;	state Exp;
branches;
next	1.13;
commitid	QP75iYx42Uo7mMxO;

1.13
date	2014.03.24.15.05.33;	author afresh1;	state Exp;
branches;
next	1.12;

1.12
date	2013.03.25.20.40.59;	author sthen;	state Exp;
branches;
next	1.11;

1.11
date	2010.09.24.15.07.05;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2009.10.12.18.30.27;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2008.09.29.17.36.18;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2006.03.28.19.23.12;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2005.01.15.21.30.39;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2004.08.09.18.10.25;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2003.12.03.03.02.48;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2002.10.27.22.25.35;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.05.24.18.36.07;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.06.17.08.01;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2000.04.06.16.10.39;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.04.06.16.10.39;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.05.24.18.25.05;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.10.27.22.15.10;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.12.03.02.44.30;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.08.09.17.48.31;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2005.01.15.21.18.14;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2006.03.28.18.49.41;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2008.09.29.17.18.58;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2009.10.12.18.10.42;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2010.09.24.14.49.19;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2013.03.25.20.09.33;	author sthen;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2014.03.24.14.59.09;	author afresh1;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2014.11.17.20.53.17;	author afresh1;	state Exp;
branches;
next	1.1.1.14;
commitid	B31cAbBIXiCqnL97;

1.1.1.14
date	2017.08.14.13.46.22;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.15
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl

BEGIN {
    chdir 't' if -d 't';
    @@INC = '../lib';
    require './test.pl';
}

$|  = 1;
use warnings;
use Config;

plan tests => 156;

my $Perl = which_perl();

my $afile = tempfile();
{
    unlink($afile) if -f $afile;

    $! = 0;  # the -f above will set $! if $afile doesn't exist.
    ok( open(my $f,"+>$afile"),  'open(my $f, "+>...")' );

    binmode $f;
    ok( -f $afile,              '       its a file');
    ok( (print $f "SomeData\n"),  '       we can print to it');
    is( tell($f), 9,            '       tell()' );
    ok( seek($f,0,0),           '       seek set' );

    $b = <$f>;
    is( $b, "SomeData\n",       '       readline' );
    ok( -f $f,                  '       still a file' );

    eval  { die "Message" };
    like( $@@, qr/<\$f> line 1/, '       die message correct' );
    
    ok( close($f),              '       close()' );
    ok( unlink($afile),         '       unlink()' );
}

{
    ok( open(my $f,'>', $afile),        "open(my \$f, '>', $afile)" );
    ok( (print $f "a row\n"),           '       print');
    ok( close($f),                      '       close' );
    ok( -s $afile < 10,                 '       -s' );
}

{
    ok( open(my $f,'>>', $afile),       "open(my \$f, '>>', $afile)" );
    ok( (print $f "a row\n"),           '       print' );
    ok( close($f),                      '       close' );
    ok( -s $afile > 10,                 '       -s'    );
}

{
    ok( open(my $f, '<', $afile),       "open(my \$f, '<', $afile)" );
    my @@rows = <$f>;
    is( scalar @@rows, 2,                '       readline, list context' );
    is( $rows[0], "a row\n",            '       first line read' );
    is( $rows[1], "a row\n",            '       second line' );
    ok( close($f),                      '       close' );
}

{
    ok( -s $afile < 20,                 '-s' );

    ok( open(my $f, '+<', $afile),      'open +<' );
    my @@rows = <$f>;
    is( scalar @@rows, 2,                '       readline, list context' );
    ok( seek($f, 0, 1),                 '       seek cur' );
    ok( (print $f "yet another row\n"), '       print' );
    ok( close($f),                      '       close' );
    ok( -s $afile > 20,                 '       -s' );

    unlink($afile);
}
{
    ok( open(my $f, '-|', <<EOC),     'open -|' );
    $Perl -e "print qq(a row\\n); print qq(another row\\n)"
EOC

    my @@rows = <$f>;
    is( scalar @@rows, 2,                '       readline, list context' );
    ok( close($f),                      '       close' );
}
{
    ok( open(my $f, '|-', <<EOC),     'open |-' );
    $Perl -pe "s/^not //"
EOC

    my @@rows = <$f>;
    my $test = curr_test;
    print $f "not ok $test - piped in\n";
    next_test;

    $test = curr_test;
    print $f "not ok $test - piped in\n";
    next_test;
    ok( close($f),                      '       close' );
    sleep 1;
    pass('flushing');
}


ok( !eval { open my $f, '<&', $afile; 1; },    '<& on a non-filehandle' );
like( $@@, qr/Bad filehandle:\s+$afile/,          '       right error' );

ok( !eval { *some_glob = 1; open my $f, '<&', *some_glob; 1; },    '<& on a non-filehandle glob' );
like( $@@, qr/Bad filehandle:\s+some_glob/,          '       right error' );

{
    use utf8;
    use open qw( :utf8 :std );
    ok( !eval { use utf8; *ǡﬁlḛ = 1; open my $f, '<&', *ǡﬁlḛ; 1; },    '<& on a non-filehandle glob' );
    like( $@@, qr/Bad filehandle:\s+ǡﬁlḛ/u,          '       right error' );
}

# local $file tests
{
    unlink($afile) if -f $afile;

    ok( open(local $f,"+>$afile"),       'open local $f, "+>", ...' );
    binmode $f;

    ok( -f $afile,                      '       -f' );
    ok( (print $f "SomeData\n"),        '       print' );
    is( tell($f), 9,                    '       tell' );
    ok( seek($f,0,0),                   '       seek set' );

    $b = <$f>;
    is( $b, "SomeData\n",               '       readline' );
    ok( -f $f,                          '       still a file' );

    eval  { die "Message" };
    like( $@@, qr/<\$f> line 1/,         '       proper die message' );
    ok( close($f),                      '       close' );

    unlink($afile);
}

{
    ok( open(local $f,'>', $afile),     'open local $f, ">", ...' );
    ok( (print $f "a row\n"),           '       print');
    ok( close($f),                      '       close');
    ok( -s $afile < 10,                 '       -s' );
}

{
    ok( open(local $f,'>>', $afile),    'open local $f, ">>", ...' );
    ok( (print $f "a row\n"),           '       print');
    ok( close($f),                      '       close');
    ok( -s $afile > 10,                 '       -s' );
}

{
    ok( open(local $f, '<', $afile),    'open local $f, "<", ...' );
    my @@rows = <$f>;
    is( scalar @@rows, 2,                '       readline list context' );
    ok( close($f),                      '       close' );
}

ok( -s $afile < 20,                     '       -s' );

{
    ok( open(local $f, '+<', $afile),  'open local $f, "+<", ...' );
    my @@rows = <$f>;
    is( scalar @@rows, 2,                '       readline list context' );
    ok( seek($f, 0, 1),                 '       seek cur' );
    ok( (print $f "yet another row\n"), '       print' );
    ok( close($f),                      '       close' );
    ok( -s $afile > 20,                 '       -s' );

    unlink($afile);
}

{
    ok( open(local $f, '-|', <<EOC),  'open local $f, "-|", ...' );
    $Perl -e "print qq(a row\\n); print qq(another row\\n)"
EOC
    my @@rows = <$f>;

    is( scalar @@rows, 2,                '       readline list context' );
    ok( close($f),                      '       close' );
}

{
    ok( open(local $f, '|-', <<EOC),  'open local $f, "|-", ...' );
    $Perl -pe "s/^not //"
EOC

    my @@rows = <$f>;
    my $test = curr_test;
    print $f "not ok $test - piping\n";
    next_test;

    $test = curr_test;
    print $f "not ok $test - piping\n";
    next_test;
    ok( close($f),                      '       close' );
    sleep 1;
    pass("Flush");
}


ok( !eval { open local $f, '<&', $afile; 1 },  'local <& on non-filehandle');
like( $@@, qr/Bad filehandle:\s+$afile/,          '       right error' );

{
    local *F;
    for (1..2) {
	ok( open(F, qq{$Perl -le "print 'ok'"|}), 'open to pipe' );
	is(scalar <F>, "ok\n",  '       readline');
	ok( close F,            '       close' );
    }

    for (1..2) {
	ok( open(F, "-|", qq{$Perl -le "print 'ok'"}), 'open -|');
	is( scalar <F>, "ok\n", '       readline');
	ok( close F,            '       close' );
    }
}


# other dupping techniques
{
    ok( open(my $stdout, ">&", \*STDOUT),       'dup \*STDOUT into lexical fh');
    ok( open(STDOUT,     ">&", $stdout),        'restore dupped STDOUT from lexical fh');

    {
	use strict; # the below should not warn
	ok( open(my $stdout, ">&", STDOUT),         'dup STDOUT into lexical fh');
    }

    # used to try to open a file [perl #17830]
    ok( open(my $stdin,  "<&", fileno STDIN),   'dup fileno(STDIN) into lexical fh') or _diag $!;

    fileno(STDIN) =~ /(.)/;
    ok open($stdin, "<&", $1), 'open ... "<&", $magical_fileno',
	||  _diag $!;
}

SKIP: {
    skip "This perl uses perlio", 1 if $Config{useperlio};
    skip_if_miniperl("miniperl can't rely on loading %Errno", 1);
    # Force the reference to %! to be run time by writing ! as {"!"}
    skip "This system doesn't understand EINVAL", 1
	unless exists ${"!"}{EINVAL};

    no warnings 'io';
    ok(!open(F,'>',\my $s) && ${"!"}{EINVAL}, 'open(reference) raises EINVAL');
}

{
    ok( !eval { open F, "BAR", "QUUX" },       'Unknown open() mode' );
    like( $@@, qr/\QUnknown open() mode 'BAR'/, '       right error' );
}

{
    local $SIG{__WARN__} = sub { $@@ = shift };

    sub gimme {
        my $tmphandle = shift;
	my $line = scalar <$tmphandle>;
	warn "gimme";
	return $line;
    }

    open($fh0[0], "TEST");
    gimme($fh0[0]);
    like($@@, qr/<\$fh0\[...\]> line 1\./, "autoviv fh package aelem");

    open($fh1{k}, "TEST");
    gimme($fh1{k});
    like($@@, qr/<\$fh1\{...}> line 1\./, "autoviv fh package helem");

    my @@fh2;
    open($fh2[0], "TEST");
    gimme($fh2[0]);
    like($@@, qr/<\$fh2\[...\]> line 1\./, "autoviv fh lexical aelem");

    my %fh3;
    open($fh3{k}, "TEST");
    gimme($fh3{k});
    like($@@, qr/<\$fh3\{...}> line 1\./, "autoviv fh lexical helem");

    local $/ = *F;  # used to cause an assertion failure
    gimme($fh3{k});
    like($@@, qr/<\$fh3\{...}> chunk 2\./,
	'<...> line 1 when $/ is set to a glob');
}
    
SKIP: {
    skip("These tests use perlio", 5) unless $Config{useperlio};
    my $w;
    use warnings 'layer';
    local $SIG{__WARN__} = sub { $w = shift };

    eval { open(F, ">>>", $afile) };
    like($w, qr/Invalid separator character '>' in PerlIO layer spec/,
	 "bad open (>>>) warning");
    like($@@, qr/Unknown open\(\) mode '>>>'/,
	 "bad open (>>>) failure");

    eval { open(F, ">:u", $afile ) };
    like($w, qr/Unknown PerlIO layer "u"/,
	 'bad layer ">:u" warning');
    eval { open(F, "<:u", $afile ) };
    like($w, qr/Unknown PerlIO layer "u"/,
	 'bad layer "<:u" warning');
    eval { open(F, ":c", $afile ) };
    like($@@, qr/Unknown open\(\) mode ':c'/,
	 'bad layer ":c" failure');
}

# [perl #28986] "open m" crashes Perl

fresh_perl_like('open m', qr/^Search pattern not terminated at/,
	{ stderr => 1 }, 'open m test');

fresh_perl_is(
    'sub f { open(my $fh, "xxx"); $fh = "f"; } f; f;print "ok"',
    'ok', { stderr => 1 },
    '#29102: Crash on assignment to lexical filehandle');

# [perl #31767] Using $1 as a filehandle via open $1, "file" doesn't raise
# an exception

eval { open $99, "foo" };
like($@@, qr/Modification of a read-only value attempted/, "readonly fh");
# But we do not want that exception applying to close(), since it does not
# modify the fh.
eval {
   no warnings "uninitialized";
   # make sure $+ is undefined
   "a" =~ /(b)?/;
   close $+
};
is($@@, '', 'no "Modification of a read-only value" when closing');

# [perl#73626] mg_get wasn't run on the pipe arg

{
    package p73626;
    sub TIESCALAR { bless {} }
    sub FETCH { "$Perl -e 1"}

    tie my $p, 'p73626';

    package main;

    ok( open(my $f, '-|', $p),     'open -| magic');
}

# [perl #77492] Crash when stringifying a glob, a reference to which has
#               been opened and written to.
fresh_perl_is(
    '
      open my $fh, ">", \*STDOUT;
      print $fh "hello";
     "".*STDOUT;
      print "ok";
      close $fh;
      unlink \*STDOUT;
    ',
    'ok', { stderr => 1 },
    '[perl #77492]: open $fh, ">", \*glob causes SEGV');

# [perl #77684] Opening a reference to a glob copy.
SKIP: {
    skip_if_miniperl("no dynamic loading on miniperl, so can't load PerlIO::scalar", 1);
    my $var = *STDOUT;
    open my $fh, ">", \$var;
    print $fh "hello";
    is $var, "hello", '[perl #77684]: open $fh, ">", \$glob_copy'
        # when this fails, it leaves an extra file:
        or unlink \*STDOUT;
}

# check that we can call methods on filehandles auto-magically
# and have IO::File loaded for us
SKIP: {
    skip_if_miniperl("no dynamic loading on miniperl, so can't load IO::File", 3);
    is( $INC{'IO/File.pm'}, undef, "IO::File not loaded" );
    my $var = "";
    open my $fh, ">", \$var;
    ok( eval { $fh->autoflush(1); 1 }, '$fh->autoflush(1) lives' );
    ok( $INC{'IO/File.pm'}, "IO::File now loaded" );
}

sub _117941 { package _117941; open my $a, "TEST" }
delete $::{"_117941::"};
_117941();
pass("no crash when open autovivifies glob in freed package");

# [perl #117265] check for embedded nul in pathnames, allow ending \0 though
{
    my $WARN;
    local $SIG{__WARN__} = sub { $WARN = shift };
    my $temp = tempfile();
    my $temp_match = quotemeta $temp;

    # create the file, so we can check nothing actually touched it
    open my $temp_fh, ">", $temp;
    close $temp_fh;
    ok(utime(time()-10, time(), $temp), "set mtime to a known value");
    ok(chmod(0666, $temp), "set mode to a known value");
    my ($final_mode, $final_mtime) = (stat $temp)[2, 9];

    my $fn = "$temp\0.invalid";
    my $fno = bless \(my $fn2 = "$temp\0.overload"), "OverloadTest";
    is(open(I, $fn), undef, "open with nul in pathnames since 5.18 [perl #117265]");
    like($WARN, qr/^Invalid \\0 character in pathname for open: $temp_match\\0\.invalid/,
         "warn on embedded nul"); $WARN = '';
    is(open(I, $fno), undef, "open with nul in pathnames since 5.18 [perl #117265] (overload)");
    like($WARN, qr/^Invalid \\0 character in pathname for open: $temp_match\\0\.overload/,
         "warn on embedded nul"); $WARN = '';

    is(chmod(0444, $fn), 0, "chmod fails with \\0 in name");
    like($WARN, qr/^Invalid \\0 character in pathname for chmod: $temp_match\\0\.invalid/,
         "also on chmod"); $WARN = '';

    is(chmod(0444, $fno), 0, "chmod fails with \\0 in name (overload)");
    like($WARN, qr/^Invalid \\0 character in pathname for chmod: $temp_match\\0\.overload/,
         "also on chmod"); $WARN = '';

    is (glob($fn), undef, "glob fails with \\0 in name");
    like($WARN, qr/^Invalid \\0 character in pattern for glob: $temp_match\\0\.invalid/,
         "also on glob"); $WARN = '';

    is (glob($fno), undef, "glob fails with \\0 in name (overload)");
    like($WARN, qr/^Invalid \\0 character in pattern for glob: $temp_match\\0\.overload/,
         "also on glob"); $WARN = '';

    {
        no warnings 'syscalls';
        $WARN = '';
        is(open(I, $fn), undef, "open with nul with no warnings syscalls");
        is($WARN, '', "ignore warning on embedded nul with no warnings syscalls");
    }

    SKIP: {
        if (is_miniperl && !eval 'require Errno') {
            skip "Errno not built yet", 8;
        }
        require Errno;
        import Errno 'ENOENT';
        # check handling of multiple arguments, which the original patch
        # mis-handled
        $! = 0;
        is (unlink($fn, $fn), 0, "check multiple arguments to unlink");
        is($!+0, &ENOENT, "check errno");
        $! = 0;
        is (chmod(0644, $fn, $fn), 0, "check multiple arguments to chmod");
        is($!+0, &ENOENT, "check errno");
        $! = 0;
        is (utime(time, time, $fn, $fn), 0, "check multiple arguments to utime");
        is($!+0, &ENOENT, "check errno");
        SKIP: {
            skip "no chown", 2 unless $Config{d_chown};
            $! = 0;
            is(chown(-1, -1, $fn, $fn), 0, "check multiple arguments to chown");
            is($!+0, &ENOENT, "check errno");
        }
    }

    is (unlink($fn), 0, "unlink fails with \\0 in name");
    like($WARN, qr/^Invalid \\0 character in pathname for unlink: $temp_match\\0\.invalid/,
         "also on unlink"); $WARN = '';

    is (unlink($fno), 0, "unlink fails with \\0 in name (overload)");
    like($WARN, qr/^Invalid \\0 character in pathname for unlink: $temp_match\\0\.overload/,
         "also on unlink"); $WARN = '';

    ok(-f $temp, "nothing removed the temp file");
    is((stat $temp)[2], $final_mode, "nothing changed its mode");
    is((stat $temp)[9], $final_mtime, "nothing changes its mtime");
}

# [perl #125115] Dup to closed filehandle creates file named GLOB(0x...)
{
    ok(open(my $fh, "<", "TEST"), "open a handle");
    ok(close $fh, "and close it again");
    ok(!open(my $fh2,  ">&", $fh), "should fail to dup the closed handle");
    # clean up if we failed
    unlink "$fh";
}

package OverloadTest;
use overload '""' => sub { ${$_[0]} };
@


1.14
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d13 1
a13 1
plan tests => 153;
a440 12
    use Errno 'ENOENT';
    # check handling of multiple arguments, which the original patch
    # mis-handled
    $! = 0;
    is (unlink($fn, $fn), 0, "check multiple arguments to unlink");
    is($!+0, ENOENT, "check errno");
    $! = 0;
    is (chmod(0644, $fn, $fn), 0, "check multiple arguments to chmod");
    is($!+0, ENOENT, "check errno");
    $! = 0;
    is (utime(time, time, $fn, $fn), 0, "check multiple arguments to utime");
    is($!+0, ENOENT, "check errno");
d442 7
a448 1
        skip "no chown", 2 unless $Config{d_chown};
d450 14
a463 2
        is(chown(-1, -1, $fn, $fn), 0, "check multiple arguments to chown");
        is($!+0, ENOENT, "check errno");
d479 8
@


1.13
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d13 1
a13 1
plan tests => 121;
d389 87
@


1.12
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d13 1
a13 1
plan tests => 119;
d236 4
d274 1
a274 1
    like($@@, qr/<\$fh1{...}> line 1\./, "autoviv fh package helem");
d284 6
a289 1
    like($@@, qr/<\$fh3{...}> line 1\./, "autoviv fh lexical helem");
@


1.11
log
@merge in perl 5.12.2 plus local changes
@
text
@d13 1
a13 1
plan tests => 108;
d108 9
d240 1
a240 2
    skip "miniperl cannot be relied on to load %Errno"
	if $ENV{PERL_CORE_MINITEST};
d321 59
@


1.10
log
@Merge in perl 5.10.1; part two
@
text
@a11 1
$Is_MacOS = $^O eq 'MacOS';
d86 1
a86 3
SKIP: {
    skip "Output for |- doesn't go to shell on MacOS", 5 if $Is_MacOS;

d177 1
a177 3
SKIP: {
    skip "Output for |- doesn't go to shell on MacOS", 5 if $Is_MacOS;

@


1.9
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@a11 1
$Is_VMS = $^O eq 'VMS';
d18 1
d20 1
a20 1
    unlink("afile") if -f "afile";
d22 2
a23 2
    $! = 0;  # the -f above will set $! if 'afile' doesn't exist.
    ok( open(my $f,"+>afile"),  'open(my $f, "+>...")' );
d26 1
a26 1
    ok( -f "afile",             '       its a file');
d39 1
a39 1
    ok( unlink("afile"),        '       unlink()' );
d43 1
a43 1
    ok( open(my $f,'>', 'afile'),       "open(my \$f, '>', 'afile')" );
d46 1
a46 1
    ok( -s 'afile' < 10,                '       -s' );
d50 1
a50 1
    ok( open(my $f,'>>', 'afile'),      "open(my \$f, '>>', 'afile')" );
d53 1
a53 1
    ok( -s 'afile' > 10,                '       -s'    );
d57 1
a57 1
    ok( open(my $f, '<', 'afile'),      "open(my \$f, '<', 'afile')" );
d66 1
a66 1
    ok( -s 'afile' < 20,                '-s' );
d68 1
a68 1
    ok( open(my $f, '+<', 'afile'),     'open +<' );
d74 1
a74 1
    ok( -s 'afile' > 20,                '       -s' );
d76 1
a76 1
    unlink("afile");
d78 1
a78 4

SKIP: {
    skip "open -| busted and noisy on VMS", 3 if $Is_VMS;

a86 1

d108 2
a109 2
ok( !eval { open my $f, '<&', 'afile'; 1; },    '<& on a non-filehandle' );
like( $@@, qr/Bad filehandle:\s+afile/,          '       right error' );
d114 1
a114 1
    unlink("afile") if -f "afile";
d116 1
a116 1
    ok( open(local $f,"+>afile"),       'open local $f, "+>", ...' );
d119 1
a119 1
    ok( -f "afile",                     '       -f' );
d132 1
a132 1
    unlink("afile");
d136 1
a136 1
    ok( open(local $f,'>', 'afile'),    'open local $f, ">", ...' );
d139 1
a139 1
    ok( -s 'afile' < 10,                '       -s' );
d143 1
a143 1
    ok( open(local $f,'>>', 'afile'),   'open local $f, ">>", ...' );
d146 1
a146 1
    ok( -s 'afile' > 10,                '       -s' );
d150 1
a150 1
    ok( open(local $f, '<', 'afile'),   'open local $f, "<", ...' );
d156 1
a156 1
ok( -s 'afile' < 20,                '       -s' );
d159 1
a159 1
    ok( open(local $f, '+<', 'afile'),  'open local $f, "+<", ...' );
d165 1
a165 1
    ok( -s 'afile' > 20,                '       -s' );
d167 1
a167 1
    unlink("afile");
d170 1
a170 3
SKIP: {
    skip "open -| busted and noisy on VMS", 3 if $Is_VMS;

d201 2
a202 2
ok( !eval { open local $f, '<&', 'afile'; 1 },  'local <& on non-filehandle');
like( $@@, qr/Bad filehandle:\s+afile/,          '       right error' );
d286 1
a286 1
    eval { open(F, ">>>", "afile") };
d292 1
a292 1
    eval { open(F, ">:u", "afile" ) };
d295 1
a295 1
    eval { open(F, "<:u", "afile" ) };
d298 1
a298 1
    eval { open(F, ":c", "afile" ) };
@


1.8
log
@merge in perl 5.8.8
@
text
@a8 6
# Cheat. Until we figure out a solution for BEGIN blocks not setting a new
# stack (and thus perl API calls possibly moving the stack by extending it)
# which doesn't in turn break calling exit from inside a signal handler inside
# a BEGIN block.
eval {require Errno};

@


1.7
log
@sync in-tree perl with 5.8.6
@
text
@d9 6
d243 1
a243 1
    ok( open(my $stdin,  "<&", fileno STDIN),   'dup fileno(STDIN) into lexical fh');
@


1.6
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d15 1
a15 1
plan tests => 107;
d318 6
@


1.5
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d15 1
a15 1
plan tests => 105;
d242 5
a246 1
    skip "This system doesn't understand EINVAL", 1 unless exists $!{EINVAL};
d249 1
a249 1
    ok( !open(F,'>',\my $s) && $!{EINVAL}, 'open(reference) raises EINVAL' );
d309 9
@


1.4
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d15 1
a15 1
plan tests => 94;
d213 1
a213 1
        ok( open(F, qq{$Perl -le "print 'ok'"|}), 'open to pipe' );
d215 1
a215 1
        ok( close F,            '       close' );
d219 2
a220 2
        ok( open(F, "-|", qq{$Perl -le "print 'ok'"}), 'open -|');
        is( scalar <F>, "ok\n", '       readline');
d228 10
a237 2
    ok( open(my $stdout, ">&", \*STDOUT), 'dup \*STDOUT into lexical fh');
    ok( open(STDOUT,     ">&", $stdout),  'restore dupped STDOUT from lexical fh');
d252 53
@


1.3
log
@merge in perl 5.6.1 with our local changes
@
text
@d6 2
a7 1
}    
a8 1
# $RCSfile$    
d11 1
d13 1
a13 1
$Is_Dos = $^O eq 'dos';
d15 1
a15 1
print "1..66\n";
d17 1
a17 1
my $test = 1;
d19 2
a20 1
sub ok { print "ok $test\n"; $test++ }
d22 2
a23 1
# my $file tests
a24 5
# 1..9
{
    unlink("afile") if -f "afile";     
    print "$!\nnot " unless open(my $f,"+>afile");
    ok;
d26 5
a30 8
    print "not " unless -f "afile";     
    ok;
    print "not " unless print $f "SomeData\n";
    ok;
    print "not " unless tell($f) == 9;
    ok;
    print "not " unless seek($f,0,0);
    ok;
d32 52
a83 72
    print "not " unless $b eq "SomeData\n";
    ok;
    print "not " unless -f $f;     
    ok;
    eval  { die "Message" };   
    # warn $@@;
    print "not " unless $@@ =~ /<\$f> line 1/;
    ok;
    print "not " unless close($f);
    ok;
    unlink("afile");     
}

# 10..12
{
    print "# \$!='$!'\nnot " unless open(my $f,'>', 'afile');
    ok;
    print $f "a row\n";
    print "not " unless close($f);
    ok;
    print "not " unless -s 'afile' < 10;
    ok;
}

# 13..15
{
    print "# \$!='$!'\nnot " unless open(my $f,'>>', 'afile');
    ok;
    print $f "a row\n";
    print "not " unless close($f);
    ok;
    print "not " unless -s 'afile' > 10;
    ok;
}

# 16..18
{
    print "# \$!='$!'\nnot " unless open(my $f, '<', 'afile');
    ok;
    @@rows = <$f>;
    print "not " unless @@rows == 2;
    ok;
    print "not " unless close($f);
    ok;
}

# 19..23
{
    print "not " unless -s 'afile' < 20;
    ok;
    print "# \$!='$!'\nnot " unless open(my $f, '+<', 'afile');
    ok;
    @@rows = <$f>;
    print "not " unless @@rows == 2;
    ok;
    seek $f, 0, 1;
    print $f "yet another row\n";
    print "not " unless close($f);
    ok;
    print "not " unless -s 'afile' > 20;
    ok;

    unlink("afile");     
}

# 24..26
if ($Is_VMS) {
    for (24..26) { print "ok $_ # skipped: not Unix fork\n"; $test++;}
}
else {
    print "# \$!='$!'\nnot " unless open(my $f, '-|', <<'EOC');
    ./perl -e "print qq(a row\n); print qq(another row\n)"
d85 4
a88 6
    ok;
    @@rows = <$f>;
    print "not " unless @@rows == 2;
    ok;
    print "not " unless close($f);
    ok;
d91 5
a95 7
# 27..30
if ($Is_VMS) {
    for (27..30) { print "ok $_ # skipped: not Unix fork\n"; $test++;}
}
else {
    print "# \$!='$!'\nnot " unless open(my $f, '|-', <<'EOC');
    ./perl -pe "s/^not //"
d97 10
a106 5
    ok;
    @@rows = <$f>;
    print $f "not ok $test\n"; $test++;
    print $f "not ok $test\n"; $test++;
    print "#\nnot " unless close($f);
d108 1
a108 1
    ok;
d111 4
a114 8
# 31..32
eval <<'EOE' and print "not ";
open my $f, '<&', 'afile';
1;
EOE
ok;
$@@ =~ /Unknown open\(\) mode \'<&\'/ or print "not ";
ok;
d117 2
d120 1
a120 5
# 33..41
{
    unlink("afile") if -f "afile";     
    print "$!\nnot " unless open(local $f,"+>afile");
    ok;
d122 6
a127 8
    print "not " unless -f "afile";     
    ok;
    print "not " unless print $f "SomeData\n";
    ok;
    print "not " unless tell($f) == 9;
    ok;
    print "not " unless seek($f,0,0);
    ok;
d129 50
a178 72
    print "not " unless $b eq "SomeData\n";
    ok;
    print "not " unless -f $f;     
    ok;
    eval  { die "Message" };   
    # warn $@@;
    print "not " unless $@@ =~ /<\$f> line 1/;
    ok;
    print "not " unless close($f);
    ok;
    unlink("afile");     
}

# 42..44
{
    print "# \$!='$!'\nnot " unless open(local $f,'>', 'afile');
    ok;
    print $f "a row\n";
    print "not " unless close($f);
    ok;
    print "not " unless -s 'afile' < 10;
    ok;
}

# 45..47
{
    print "# \$!='$!'\nnot " unless open(local $f,'>>', 'afile');
    ok;
    print $f "a row\n";
    print "not " unless close($f);
    ok;
    print "not " unless -s 'afile' > 10;
    ok;
}

# 48..50
{
    print "# \$!='$!'\nnot " unless open(local $f, '<', 'afile');
    ok;
    @@rows = <$f>;
    print "not " unless @@rows == 2;
    ok;
    print "not " unless close($f);
    ok;
}

# 51..55
{
    print "not " unless -s 'afile' < 20;
    ok;
    print "# \$!='$!'\nnot " unless open(local $f, '+<', 'afile');
    ok;
    @@rows = <$f>;
    print "not " unless @@rows == 2;
    ok;
    seek $f, 0, 1;
    print $f "yet another row\n";
    print "not " unless close($f);
    ok;
    print "not " unless -s 'afile' > 20;
    ok;

    unlink("afile");     
}

# 56..58
if ($Is_VMS) {
    for (56..58) { print "ok $_ # skipped: not Unix fork\n"; $test++;}
}
else {
    print "# \$!='$!'\nnot " unless open(local $f, '-|', <<'EOC');
    ./perl -e "print qq(a row\n); print qq(another row\n)"
d180 4
a183 6
    ok;
    @@rows = <$f>;
    print "not " unless @@rows == 2;
    ok;
    print "not " unless close($f);
    ok;
d186 5
a190 7
# 59..62
if ($Is_VMS) {
    for (59..62) { print "ok $_ # skipped: not Unix fork\n"; $test++;}
}
else {
    print "# \$!='$!'\nnot " unless open(local $f, '|-', <<'EOC');
    ./perl -pe "s/^not //"
d192 10
a201 5
    ok;
    @@rows = <$f>;
    print $f "not ok $test\n"; $test++;
    print $f "not ok $test\n"; $test++;
    print "#\nnot " unless close($f);
d203 1
a203 1
    ok;
a205 8
# 63..64
eval <<'EOE' and print "not ";
open local $f, '<&', 'afile';
1;
EOE
ok;
$@@ =~ /Unknown open\(\) mode \'<&\'/ or print "not ";
ok;
d207 3
a209 1
# 65..66
d213 3
a215 7
        if ($Is_Dos) {
        open(F, "echo \\#foo|") or print "not ";
        } else {
            open(F, "echo #foo|") or print "not ";
        }
	print <F>;
	close F;
d217 1
a217 1
    ok;
d219 3
a221 7
        if ($Is_Dos) {
	open(F, "-|", "echo \\#foo") or print "not ";
        } else {
            open(F, "-|", "echo #foo") or print "not ";
        }
	print <F>;
	close F;
d223 20
a242 1
    ok;
@


1.2
log
@perl-5.6.0 + local changes
@
text
@d5 1
a5 1
    unshift @@INC, '../lib';
d12 1
d272 5
a276 1
        open(F, "echo #foo|") or print "not ";
d282 5
a286 1
	open(F, "-|", "echo #foo") or print "not ";
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@virgin perl 5.6.0
@
text
@@


1.1.1.2
log
@stock perl 5.6.1
@
text
@d5 1
a5 1
    @@INC = '../lib';
a11 1
$Is_Dos = $^O eq 'dos';
d271 1
a271 5
        if ($Is_Dos) {
        open(F, "echo \\#foo|") or print "not ";
        } else {
            open(F, "echo #foo|") or print "not ";
        }
d277 1
a277 5
        if ($Is_Dos) {
	open(F, "-|", "echo \\#foo") or print "not ";
        } else {
            open(F, "-|", "echo #foo") or print "not ";
        }
@


1.1.1.3
log
@stock perl 5.8.0 from CPAN
@
text
@d6 1
a6 2
    require './test.pl';
}
d8 1
a10 1
use Config;
d12 1
a12 1
$Is_MacOS = $^O eq 'MacOS';
d14 1
a14 1
plan tests => 94;
d16 1
a16 1
my $Perl = which_perl();
d18 1
a18 2
{
    unlink("afile") if -f "afile";
d20 1
a20 2
    $! = 0;  # the -f above will set $! if 'afile' doesn't exist.
    ok( open(my $f,"+>afile"),  'open(my $f, "+>...")' );
d22 5
d28 8
a35 5
    ok( -f "afile",             '       its a file');
    ok( (print $f "SomeData\n"),  '       we can print to it');
    is( tell($f), 9,            '       tell()' );
    ok( seek($f,0,0),           '       seek set' );

d37 72
a108 52
    is( $b, "SomeData\n",       '       readline' );
    ok( -f $f,                  '       still a file' );

    eval  { die "Message" };
    like( $@@, qr/<\$f> line 1/, '       die message correct' );
    
    ok( close($f),              '       close()' );
    ok( unlink("afile"),        '       unlink()' );
}

{
    ok( open(my $f,'>', 'afile'),       "open(my \$f, '>', 'afile')" );
    ok( (print $f "a row\n"),           '       print');
    ok( close($f),                      '       close' );
    ok( -s 'afile' < 10,                '       -s' );
}

{
    ok( open(my $f,'>>', 'afile'),      "open(my \$f, '>>', 'afile')" );
    ok( (print $f "a row\n"),           '       print' );
    ok( close($f),                      '       close' );
    ok( -s 'afile' > 10,                '       -s'    );
}

{
    ok( open(my $f, '<', 'afile'),      "open(my \$f, '<', 'afile')" );
    my @@rows = <$f>;
    is( scalar @@rows, 2,                '       readline, list context' );
    is( $rows[0], "a row\n",            '       first line read' );
    is( $rows[1], "a row\n",            '       second line' );
    ok( close($f),                      '       close' );
}

{
    ok( -s 'afile' < 20,                '-s' );

    ok( open(my $f, '+<', 'afile'),     'open +<' );
    my @@rows = <$f>;
    is( scalar @@rows, 2,                '       readline, list context' );
    ok( seek($f, 0, 1),                 '       seek cur' );
    ok( (print $f "yet another row\n"), '       print' );
    ok( close($f),                      '       close' );
    ok( -s 'afile' > 20,                '       -s' );

    unlink("afile");
}

SKIP: {
    skip "open -| busted and noisy on VMS", 3 if $Is_VMS;

    ok( open(my $f, '-|', <<EOC),     'open -|' );
    $Perl -e "print qq(a row\\n); print qq(another row\\n)"
d110 6
a115 4

    my @@rows = <$f>;
    is( scalar @@rows, 2,                '       readline, list context' );
    ok( close($f),                      '       close' );
d118 7
a124 5
SKIP: {
    skip "Output for |- doesn't go to shell on MacOS", 5 if $Is_MacOS;

    ok( open(my $f, '|-', <<EOC),     'open |-' );
    $Perl -pe "s/^not //"
d126 5
a130 10

    my @@rows = <$f>;
    my $test = curr_test;
    print $f "not ok $test - piped in\n";
    next_test;

    $test = curr_test;
    print $f "not ok $test - piped in\n";
    next_test;
    ok( close($f),                      '       close' );
d132 1
a132 1
    pass('flushing');
d135 8
d144 1
a144 3
ok( !eval { open my $f, '<&', 'afile'; 1; },    '<& on a non-filehandle' );
like( $@@, qr/Bad filehandle:\s+afile/,          '       right error' );

d146 1
a146 1
# local $file tests
d148 3
a150 3
    unlink("afile") if -f "afile";

    ok( open(local $f,"+>afile"),       'open local $f, "+>", ...' );
d152 8
a159 6

    ok( -f "afile",                     '       -f' );
    ok( (print $f "SomeData\n"),        '       print' );
    is( tell($f), 9,                    '       tell' );
    ok( seek($f,0,0),                   '       seek set' );

d161 72
a232 50
    is( $b, "SomeData\n",               '       readline' );
    ok( -f $f,                          '       still a file' );

    eval  { die "Message" };
    like( $@@, qr/<\$f> line 1/,         '       proper die message' );
    ok( close($f),                      '       close' );

    unlink("afile");
}

{
    ok( open(local $f,'>', 'afile'),    'open local $f, ">", ...' );
    ok( (print $f "a row\n"),           '       print');
    ok( close($f),                      '       close');
    ok( -s 'afile' < 10,                '       -s' );
}

{
    ok( open(local $f,'>>', 'afile'),   'open local $f, ">>", ...' );
    ok( (print $f "a row\n"),           '       print');
    ok( close($f),                      '       close');
    ok( -s 'afile' > 10,                '       -s' );
}

{
    ok( open(local $f, '<', 'afile'),   'open local $f, "<", ...' );
    my @@rows = <$f>;
    is( scalar @@rows, 2,                '       readline list context' );
    ok( close($f),                      '       close' );
}

ok( -s 'afile' < 20,                '       -s' );

{
    ok( open(local $f, '+<', 'afile'),  'open local $f, "+<", ...' );
    my @@rows = <$f>;
    is( scalar @@rows, 2,                '       readline list context' );
    ok( seek($f, 0, 1),                 '       seek cur' );
    ok( (print $f "yet another row\n"), '       print' );
    ok( close($f),                      '       close' );
    ok( -s 'afile' > 20,                '       -s' );

    unlink("afile");
}

SKIP: {
    skip "open -| busted and noisy on VMS", 3 if $Is_VMS;

    ok( open(local $f, '-|', <<EOC),  'open local $f, "-|", ...' );
    $Perl -e "print qq(a row\\n); print qq(another row\\n)"
d234 6
a239 4
    my @@rows = <$f>;

    is( scalar @@rows, 2,                '       readline list context' );
    ok( close($f),                      '       close' );
d242 7
a248 5
SKIP: {
    skip "Output for |- doesn't go to shell on MacOS", 5 if $Is_MacOS;

    ok( open(local $f, '|-', <<EOC),  'open local $f, "|-", ...' );
    $Perl -pe "s/^not //"
d250 5
a254 10

    my @@rows = <$f>;
    my $test = curr_test;
    print $f "not ok $test - piping\n";
    next_test;

    $test = curr_test;
    print $f "not ok $test - piping\n";
    next_test;
    ok( close($f),                      '       close' );
d256 1
a256 1
    pass("Flush");
d259 8
d268 1
a268 3
ok( !eval { open local $f, '<&', 'afile'; 1 },  'local <& on non-filehandle');
like( $@@, qr/Bad filehandle:\s+afile/,          '       right error' );

d272 7
a278 3
        ok( open(F, qq{$Perl -le "print 'ok'"|}), 'open to pipe' );
	is(scalar <F>, "ok\n",  '       readline');
        ok( close F,            '       close' );
d280 1
a280 1

d282 7
a288 3
        ok( open(F, "-|", qq{$Perl -le "print 'ok'"}), 'open -|');
        is( scalar <F>, "ok\n", '       readline');
	ok( close F,            '       close' );
d290 1
a290 20
}


# other dupping techniques
{
    ok( open(my $stdout, ">&", \*STDOUT), 'dup \*STDOUT into lexical fh');
    ok( open(STDOUT,     ">&", $stdout),  'restore dupped STDOUT from lexical fh');
}

SKIP: {
    skip "This perl uses perlio", 1 if $Config{useperlio};
    skip "This system doesn't understand EINVAL", 1 unless exists $!{EINVAL};

    no warnings 'io';
    ok( !open(F,'>',\my $s) && $!{EINVAL}, 'open(reference) raises EINVAL' );
}

{
    ok( !eval { open F, "BAR", "QUUX" },       'Unknown open() mode' );
    like( $@@, qr/\QUnknown open() mode 'BAR'/, '       right error' );
@


1.1.1.4
log
@perl 5.8.2 from CPAN
@
text
@d15 1
a15 1
plan tests => 105;
d213 1
a213 1
	ok( open(F, qq{$Perl -le "print 'ok'"|}), 'open to pipe' );
d215 1
a215 1
	ok( close F,            '       close' );
d219 2
a220 2
	ok( open(F, "-|", qq{$Perl -le "print 'ok'"}), 'open -|');
	is( scalar <F>, "ok\n", '       readline');
d228 2
a229 10
    ok( open(my $stdout, ">&", \*STDOUT),       'dup \*STDOUT into lexical fh');
    ok( open(STDOUT,     ">&", $stdout),        'restore dupped STDOUT from lexical fh');

    {
	use strict; # the below should not warn
	ok( open(my $stdout, ">&", STDOUT),         'dup STDOUT into lexical fh');
    }

    # used to try to open a file [perl #17830]
    ok( open(my $stdin,  "<&", fileno STDIN),   'dup fileno(STDIN) into lexical fh');
a243 53

{
    local $SIG{__WARN__} = sub { $@@ = shift };

    sub gimme {
        my $tmphandle = shift;
	my $line = scalar <$tmphandle>;
	warn "gimme";
	return $line;
    }

    open($fh0[0], "TEST");
    gimme($fh0[0]);
    like($@@, qr/<\$fh0\[...\]> line 1\./, "autoviv fh package aelem");

    open($fh1{k}, "TEST");
    gimme($fh1{k});
    like($@@, qr/<\$fh1{...}> line 1\./, "autoviv fh package helem");

    my @@fh2;
    open($fh2[0], "TEST");
    gimme($fh2[0]);
    like($@@, qr/<\$fh2\[...\]> line 1\./, "autoviv fh lexical aelem");

    my %fh3;
    open($fh3{k}, "TEST");
    gimme($fh3{k});
    like($@@, qr/<\$fh3{...}> line 1\./, "autoviv fh lexical helem");
}
    
SKIP: {
    skip("These tests use perlio", 5) unless $Config{useperlio};
    my $w;
    use warnings 'layer';
    local $SIG{__WARN__} = sub { $w = shift };

    eval { open(F, ">>>", "afile") };
    like($w, qr/Invalid separator character '>' in PerlIO layer spec/,
	 "bad open (>>>) warning");
    like($@@, qr/Unknown open\(\) mode '>>>'/,
	 "bad open (>>>) failure");

    eval { open(F, ">:u", "afile" ) };
    like($w, qr/Unknown PerlIO layer "u"/,
	 'bad layer ">:u" warning');
    eval { open(F, "<:u", "afile" ) };
    like($w, qr/Unknown PerlIO layer "u"/,
	 'bad layer "<:u" warning');
    eval { open(F, ":c", "afile" ) };
    like($@@, qr/Unknown open\(\) mode ':c'/,
	 'bad layer ":c" failure');
}

@


1.1.1.5
log
@Import of stock perl 5.8.5
@
text
@d15 1
a15 1
plan tests => 107;
d242 1
a242 5
    skip "miniperl cannot be relied on to load %Errno"
	if $ENV{PERL_CORE_MINITEST};
    # Force the reference to %! to be run time by writing ! as {"!"}
    skip "This system doesn't understand EINVAL", 1
	unless exists ${"!"}{EINVAL};
d245 1
a245 1
    ok(!open(F,'>',\my $s) && ${"!"}{EINVAL}, 'open(reference) raises EINVAL');
a304 9
# [perl #28986] "open m" crashes Perl

fresh_perl_like('open m', qr/^Search pattern not terminated at/,
	{ stderr => 1 }, 'open m test');

fresh_perl_is(
    'sub f { open(my $fh, "xxx"); $fh = "f"; } f; f;print "ok"',
    'ok', { stderr => 1 },
    '#29102: Crash on assignment to lexical filehandle');
@


1.1.1.6
log
@perl 5.8.6 from CPAN
@
text
@d15 1
a15 1
plan tests => 108;
a317 6

# [perl #31767] Using $1 as a filehandle via open $1, "file" doesn't raise
# an exception

eval { open $99, "foo" };
like($@@, qr/Modification of a read-only value attempted/, "readonly fh");
@


1.1.1.7
log
@perl 5.8.8 import
@
text
@a8 6
# Cheat. Until we figure out a solution for BEGIN blocks not setting a new
# stack (and thus perl API calls possibly moving the stack by extending it)
# which doesn't in turn break calling exit from inside a signal handler inside
# a BEGIN block.
eval {require Errno};

d237 1
a237 1
    ok( open(my $stdin,  "<&", fileno STDIN),   'dup fileno(STDIN) into lexical fh') or _diag $!;
@


1.1.1.8
log
@import perl 5.10.0 from CPAN
@
text
@d9 6
@


1.1.1.9
log
@import perl 5.10.1
@
text
@d12 1
a18 1
my $afile = tempfile();
d20 1
a20 1
    unlink($afile) if -f $afile;
d22 2
a23 2
    $! = 0;  # the -f above will set $! if $afile doesn't exist.
    ok( open(my $f,"+>$afile"),  'open(my $f, "+>...")' );
d26 1
a26 1
    ok( -f $afile,              '       its a file');
d39 1
a39 1
    ok( unlink($afile),         '       unlink()' );
d43 1
a43 1
    ok( open(my $f,'>', $afile),        "open(my \$f, '>', $afile)" );
d46 1
a46 1
    ok( -s $afile < 10,                 '       -s' );
d50 1
a50 1
    ok( open(my $f,'>>', $afile),       "open(my \$f, '>>', $afile)" );
d53 1
a53 1
    ok( -s $afile > 10,                 '       -s'    );
d57 1
a57 1
    ok( open(my $f, '<', $afile),       "open(my \$f, '<', $afile)" );
d66 1
a66 1
    ok( -s $afile < 20,                 '-s' );
d68 1
a68 1
    ok( open(my $f, '+<', $afile),      'open +<' );
d74 1
a74 1
    ok( -s $afile > 20,                 '       -s' );
d76 1
a76 1
    unlink($afile);
d78 4
a81 1
{
d90 1
d112 2
a113 2
ok( !eval { open my $f, '<&', $afile; 1; },    '<& on a non-filehandle' );
like( $@@, qr/Bad filehandle:\s+$afile/,          '       right error' );
d118 1
a118 1
    unlink($afile) if -f $afile;
d120 1
a120 1
    ok( open(local $f,"+>$afile"),       'open local $f, "+>", ...' );
d123 1
a123 1
    ok( -f $afile,                      '       -f' );
d136 1
a136 1
    unlink($afile);
d140 1
a140 1
    ok( open(local $f,'>', $afile),     'open local $f, ">", ...' );
d143 1
a143 1
    ok( -s $afile < 10,                 '       -s' );
d147 1
a147 1
    ok( open(local $f,'>>', $afile),    'open local $f, ">>", ...' );
d150 1
a150 1
    ok( -s $afile > 10,                 '       -s' );
d154 1
a154 1
    ok( open(local $f, '<', $afile),    'open local $f, "<", ...' );
d160 1
a160 1
ok( -s $afile < 20,                     '       -s' );
d163 1
a163 1
    ok( open(local $f, '+<', $afile),  'open local $f, "+<", ...' );
d169 1
a169 1
    ok( -s $afile > 20,                 '       -s' );
d171 1
a171 1
    unlink($afile);
d174 3
a176 1
{
d207 2
a208 2
ok( !eval { open local $f, '<&', $afile; 1 },  'local <& on non-filehandle');
like( $@@, qr/Bad filehandle:\s+$afile/,          '       right error' );
d292 1
a292 1
    eval { open(F, ">>>", $afile) };
d298 1
a298 1
    eval { open(F, ">:u", $afile ) };
d301 1
a301 1
    eval { open(F, "<:u", $afile ) };
d304 1
a304 1
    eval { open(F, ":c", $afile ) };
@


1.1.1.10
log
@Perl 5.12.2 from CPAN
@
text
@d12 1
d87 3
a89 1
{
d180 3
a182 1
{
@


1.1.1.11
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d13 1
a13 1
plan tests => 119;
a107 9
ok( !eval { *some_glob = 1; open my $f, '<&', *some_glob; 1; },    '<& on a non-filehandle glob' );
like( $@@, qr/Bad filehandle:\s+some_glob/,          '       right error' );

{
    use utf8;
    use open qw( :utf8 :std );
    ok( !eval { use utf8; *ǡﬁlḛ = 1; open my $f, '<&', *ǡﬁlḛ; 1; },    '<& on a non-filehandle glob' );
    like( $@@, qr/Bad filehandle:\s+ǡﬁlḛ/u,          '       right error' );
}
d231 2
a232 1
    skip_if_miniperl("miniperl can't rely on loading %Errno", 1);
a312 59
# But we do not want that exception applying to close(), since it does not
# modify the fh.
eval {
   no warnings "uninitialized";
   # make sure $+ is undefined
   "a" =~ /(b)?/;
   close $+
};
is($@@, '', 'no "Modification of a read-only value" when closing');

# [perl#73626] mg_get wasn't run on the pipe arg

{
    package p73626;
    sub TIESCALAR { bless {} }
    sub FETCH { "$Perl -e 1"}

    tie my $p, 'p73626';

    package main;

    ok( open(my $f, '-|', $p),     'open -| magic');
}

# [perl #77492] Crash when stringifying a glob, a reference to which has
#               been opened and written to.
fresh_perl_is(
    '
      open my $fh, ">", \*STDOUT;
      print $fh "hello";
     "".*STDOUT;
      print "ok";
      close $fh;
      unlink \*STDOUT;
    ',
    'ok', { stderr => 1 },
    '[perl #77492]: open $fh, ">", \*glob causes SEGV');

# [perl #77684] Opening a reference to a glob copy.
SKIP: {
    skip_if_miniperl("no dynamic loading on miniperl, so can't load PerlIO::scalar", 1);
    my $var = *STDOUT;
    open my $fh, ">", \$var;
    print $fh "hello";
    is $var, "hello", '[perl #77684]: open $fh, ">", \$glob_copy'
        # when this fails, it leaves an extra file:
        or unlink \*STDOUT;
}

# check that we can call methods on filehandles auto-magically
# and have IO::File loaded for us
SKIP: {
    skip_if_miniperl("no dynamic loading on miniperl, so can't load IO::File", 3);
    is( $INC{'IO/File.pm'}, undef, "IO::File not loaded" );
    my $var = "";
    open my $fh, ">", \$var;
    ok( eval { $fh->autoflush(1); 1 }, '$fh->autoflush(1) lives' );
    ok( $INC{'IO/File.pm'}, "IO::File now loaded" );
}
@


1.1.1.12
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d13 1
a13 1
plan tests => 121;
a235 4

    fileno(STDIN) =~ /(.)/;
    ok open($stdin, "<&", $1), 'open ... "<&", $magical_fileno',
	||  _diag $!;
d270 1
a270 1
    like($@@, qr/<\$fh1\{...}> line 1\./, "autoviv fh package helem");
d280 1
a280 6
    like($@@, qr/<\$fh3\{...}> line 1\./, "autoviv fh lexical helem");

    local $/ = *F;  # used to cause an assertion failure
    gimme($fh3{k});
    like($@@, qr/<\$fh3\{...}> chunk 2\./,
	'<...> line 1 when $/ is set to a glob');
@


1.1.1.13
log
@Import perl-5.20.1
@
text
@d13 1
a13 1
plan tests => 153;
a388 87

sub _117941 { package _117941; open my $a, "TEST" }
delete $::{"_117941::"};
_117941();
pass("no crash when open autovivifies glob in freed package");

# [perl #117265] check for embedded nul in pathnames, allow ending \0 though
{
    my $WARN;
    local $SIG{__WARN__} = sub { $WARN = shift };
    my $temp = tempfile();
    my $temp_match = quotemeta $temp;

    # create the file, so we can check nothing actually touched it
    open my $temp_fh, ">", $temp;
    close $temp_fh;
    ok(utime(time()-10, time(), $temp), "set mtime to a known value");
    ok(chmod(0666, $temp), "set mode to a known value");
    my ($final_mode, $final_mtime) = (stat $temp)[2, 9];

    my $fn = "$temp\0.invalid";
    my $fno = bless \(my $fn2 = "$temp\0.overload"), "OverloadTest";
    is(open(I, $fn), undef, "open with nul in pathnames since 5.18 [perl #117265]");
    like($WARN, qr/^Invalid \\0 character in pathname for open: $temp_match\\0\.invalid/,
         "warn on embedded nul"); $WARN = '';
    is(open(I, $fno), undef, "open with nul in pathnames since 5.18 [perl #117265] (overload)");
    like($WARN, qr/^Invalid \\0 character in pathname for open: $temp_match\\0\.overload/,
         "warn on embedded nul"); $WARN = '';

    is(chmod(0444, $fn), 0, "chmod fails with \\0 in name");
    like($WARN, qr/^Invalid \\0 character in pathname for chmod: $temp_match\\0\.invalid/,
         "also on chmod"); $WARN = '';

    is(chmod(0444, $fno), 0, "chmod fails with \\0 in name (overload)");
    like($WARN, qr/^Invalid \\0 character in pathname for chmod: $temp_match\\0\.overload/,
         "also on chmod"); $WARN = '';

    is (glob($fn), undef, "glob fails with \\0 in name");
    like($WARN, qr/^Invalid \\0 character in pattern for glob: $temp_match\\0\.invalid/,
         "also on glob"); $WARN = '';

    is (glob($fno), undef, "glob fails with \\0 in name (overload)");
    like($WARN, qr/^Invalid \\0 character in pattern for glob: $temp_match\\0\.overload/,
         "also on glob"); $WARN = '';

    {
        no warnings 'syscalls';
        $WARN = '';
        is(open(I, $fn), undef, "open with nul with no warnings syscalls");
        is($WARN, '', "ignore warning on embedded nul with no warnings syscalls");
    }

    use Errno 'ENOENT';
    # check handling of multiple arguments, which the original patch
    # mis-handled
    $! = 0;
    is (unlink($fn, $fn), 0, "check multiple arguments to unlink");
    is($!+0, ENOENT, "check errno");
    $! = 0;
    is (chmod(0644, $fn, $fn), 0, "check multiple arguments to chmod");
    is($!+0, ENOENT, "check errno");
    $! = 0;
    is (utime(time, time, $fn, $fn), 0, "check multiple arguments to utime");
    is($!+0, ENOENT, "check errno");
    SKIP: {
        skip "no chown", 2 unless $Config{d_chown};
        $! = 0;
        is(chown(-1, -1, $fn, $fn), 0, "check multiple arguments to chown");
        is($!+0, ENOENT, "check errno");
    }

    is (unlink($fn), 0, "unlink fails with \\0 in name");
    like($WARN, qr/^Invalid \\0 character in pathname for unlink: $temp_match\\0\.invalid/,
         "also on unlink"); $WARN = '';

    is (unlink($fno), 0, "unlink fails with \\0 in name (overload)");
    like($WARN, qr/^Invalid \\0 character in pathname for unlink: $temp_match\\0\.overload/,
         "also on unlink"); $WARN = '';

    ok(-f $temp, "nothing removed the temp file");
    is((stat $temp)[2], $final_mode, "nothing changed its mode");
    is((stat $temp)[9], $final_mtime, "nothing changes its mtime");
}


package OverloadTest;
use overload '""' => sub { ${$_[0]} };
@


1.1.1.14
log
@Import perl-5.24.2
@
text
@d13 1
a13 1
plan tests => 156;
d441 12
d454 1
a454 7
        if (is_miniperl && !eval 'require Errno') {
            skip "Errno not built yet", 8;
        }
        require Errno;
        import Errno 'ENOENT';
        # check handling of multiple arguments, which the original patch
        # mis-handled
d456 2
a457 14
        is (unlink($fn, $fn), 0, "check multiple arguments to unlink");
        is($!+0, &ENOENT, "check errno");
        $! = 0;
        is (chmod(0644, $fn, $fn), 0, "check multiple arguments to chmod");
        is($!+0, &ENOENT, "check errno");
        $! = 0;
        is (utime(time, time, $fn, $fn), 0, "check multiple arguments to utime");
        is($!+0, &ENOENT, "check errno");
        SKIP: {
            skip "no chown", 2 unless $Config{d_chown};
            $! = 0;
            is(chown(-1, -1, $fn, $fn), 0, "check multiple arguments to chown");
            is($!+0, &ENOENT, "check errno");
        }
a472 8
# [perl #125115] Dup to closed filehandle creates file named GLOB(0x...)
{
    ok(open(my $fh, "<", "TEST"), "open a handle");
    ok(close $fh, "and close it again");
    ok(!open(my $fh2,  ">&", $fh), "should fail to dup the closed handle");
    # clean up if we failed
    unlink "$fh";
}
@


