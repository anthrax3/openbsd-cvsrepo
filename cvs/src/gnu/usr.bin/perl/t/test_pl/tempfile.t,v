head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1_BASE:1.1.1.2
	OPENBSD_6_0:1.1.1.2.0.10
	OPENBSD_6_0_BASE:1.1.1.2
	OPENBSD_5_9:1.1.1.2.0.4
	OPENBSD_5_9_BASE:1.1.1.2
	OPENBSD_5_8:1.1.1.2.0.6
	OPENBSD_5_8_BASE:1.1.1.2
	PERL_5_20_2:1.1.1.2
	OPENBSD_5_7:1.1.1.2.0.2
	OPENBSD_5_7_BASE:1.1.1.2
	PERL_5_20_1:1.1.1.2
	OPENBSD_5_6:1.1.1.1.0.4
	OPENBSD_5_6_BASE:1.1.1.1
	PERL_5_18_2:1.1.1.1
	PERL:1.1.1;
locks; strict;
comment	@# @;
expand	@b@;


1.1
date	2014.03.24.14.59.11;	author afresh1;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2014.03.24.14.59.11;	author afresh1;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2014.11.17.20.53.19;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.1
log
@Initial revision
@
text
@#!./perl

BEGIN {
    chdir 't' if -d 't';
    require './test.pl';
}
use strict;

my $prefix = 'tmp'.$$;

sub skip_files{
    my($skip,$to,$next) = @@_;
    my($last,$check);
    my $cmp = $prefix . $to;

    for( 1..$skip ){
        $check = tempfile();
        $last = $_;
        if( $check eq $cmp && $_ != $skip ){
            # let the next test pass
            last;
        }
    }

    my $common_mess = "skip $skip filenames to $to so that the next one will end with $next";
    if( $last == $skip ){
        if( $check eq $cmp ){
            pass( $common_mess );
        }else{
            my($alpha) = $check =~ /\Atmp\d+([A-Z][A-Z]?)\Z/;
            fail( $common_mess, "only skipped to $alpha" )
        }
    }else{
        fail( $common_mess, "only skipped $last files" );
    }
}

note("skipping the first filename because it is taken for use by _fresh_perl()");

is( tempfile(), "${prefix}B");
is( tempfile(), "${prefix}C");

skip_files(22,'Y','Z');

is( tempfile(), "${prefix}Z", 'Last single letter filename');
is( tempfile(), "${prefix}AA", 'First double letter filename');

skip_files(24,'AY','AZ');

is( tempfile(), "${prefix}AZ");
is( tempfile(), "${prefix}BA");

skip_files(26 * 24 + 24,'ZY','ZZ');

is( tempfile(), "${prefix}ZZ", 'Last available filename');
ok( !eval{tempfile()}, 'Should bail after Last available filename' );
my $err = "$@@";
like( $err, qr{^Can't find temporary file name starting}, 'check error string' );

done_testing();
@


1.1.1.1
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@@


1.1.1.2
log
@Import perl-5.20.1
@
text
@a24 2
    local $main::Level = $main::Level + 1;

d31 1
a31 2
            fail( $common_mess );
            diag( "only skipped to $alpha" );
d34 1
a34 2
        fail( $common_mess );
        diag( "only skipped $last out of $skip files" );
d43 1
a43 15
{
    ok( open( my $fh, '>', "${prefix}D" ), 'created file with the next filename' );
    is( tempfile(), "${prefix}E", 'properly skips files that already exist');

    if( close($fh) ){
        unlink_all("${prefix}D");
    }else{
        tempfile(); # allow the rest of the tests to work correctly
    }
}

ok( register_tempfile("${prefix}F"), 'registered the next file with register_tempfile' );
is( tempfile(), "${prefix}G", 'tempfile() properly skips files added with register_tempfile()' );

skip_files(18,'Y','Z');
a58 15

{
    my $returned = runperl( progs => [
        'require q[./test.pl];',
        'my $t = tempfile();',
        'print qq[$t|];',
        'print open(FH,q[>],$t) ? qq[ok|] : qq[not ok|] ;',
        'print -e $t ? qq[ok|] : qq[not ok|];',
    ] );
    my($filename,$opened,$existed) = split /\|/, $returned;

    is( $opened, 'ok', "$filename created" );
    is( $existed, 'ok', "$filename did exist" );
    ok( !-e $filename, "$filename doesn't exist now" );
}
@

