head	1.15;
access;
symbols
	OPENBSD_6_0:1.14.0.10
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.14.0.4
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.14.0.6
	OPENBSD_5_8_BASE:1.14
	PERL_5_20_2:1.1.1.13
	OPENBSD_5_7:1.14.0.2
	OPENBSD_5_7_BASE:1.14
	PERL_5_20_1:1.1.1.13
	OPENBSD_5_6:1.13.0.4
	OPENBSD_5_6_BASE:1.13
	PERL_5_18_2:1.1.1.12
	PERL:1.1.1
	OPENBSD_5_5:1.12.0.6
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.2
	OPENBSD_5_4_BASE:1.12
	PERL_5_16_3:1.1.1.11
	OPENBSD_5_3:1.11.0.10
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.8
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.6
	OPENBSD_5_0:1.11.0.4
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.2
	OPENBSD_4_9_BASE:1.11
	PERL_5_12_2:1.1.1.10
	OPENBSD_4_8:1.10.0.4
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.2
	OPENBSD_4_7_BASE:1.10
	PERL_5_10_1:1.1.1.9
	OPENBSD_4_6:1.9.0.6
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.2
	OPENBSD_4_5_BASE:1.9
	PERL_5_10_0:1.1.1.8
	OPENBSD_4_4:1.8.0.10
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.8
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.6
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.4
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.2
	OPENBSD_4_0_BASE:1.8
	PERL_5_8_8:1.1.1.7
	OPENBSD_3_9:1.7.0.6
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.4
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.2
	OPENBSD_3_7_BASE:1.7
	PERL_5_8_6:1.1.1.6
	OPENBSD_3_6:1.6.0.8
	OPENBSD_3_6_BASE:1.6
	PERL_5_8_5:1.1.1.5
	PERL_5_8_3:1.1.1.5
	OPENBSD_3_5:1.6.0.6
	OPENBSD_3_5_BASE:1.6
	PERL_5_8_2:1.1.1.5
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.15
date	2017.02.05.00.32.19;	author afresh1;	state Exp;
branches;
next	1.14;
commitid	cxJ08BvJA9Pt2PTM;

1.14
date	2014.11.17.20.57.07;	author afresh1;	state Exp;
branches;
next	1.13;
commitid	QP75iYx42Uo7mMxO;

1.13
date	2014.03.24.15.05.33;	author afresh1;	state Exp;
branches;
next	1.12;

1.12
date	2013.03.25.20.40.59;	author sthen;	state Exp;
branches;
next	1.11;

1.11
date	2010.09.24.15.07.05;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2009.10.12.18.24.48;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2008.09.29.17.36.18;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2006.03.28.19.23.12;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2005.01.15.21.30.39;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.35;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.36.03;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.07.49;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.52.24;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.59.48;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.13.08;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.13.08;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.41.13;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.10.36;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.25.00;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.15.09;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2005.01.15.21.18.13;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2006.03.28.18.49.40;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2008.09.29.17.18.58;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2009.10.12.18.10.41;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2010.09.24.14.49.14;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2013.03.25.20.09.32;	author sthen;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2014.03.24.14.59.09;	author afresh1;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2014.11.17.20.53.16;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.15
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl

# We suppose that perl _mostly_ works at this moment, so may use
# sophisticated testing.

BEGIN {
    chdir 't' if -d 't';
    @@INC = '../lib';              # pick up only this build's lib
}

my $torture; # torture testing?

use TAP::Harness 3.13;
use strict;
use Config;

$::do_nothing = $::do_nothing = 1;
require './TEST';
our $Valgrind_Log;

my $Verbose = 0;
$Verbose++ while @@ARGV && $ARGV[0] eq '-v' && shift;

# For valgrind summary output
my $htoolnm;
my $hgrind_ct;

if ($ARGV[0] && $ARGV[0] eq '-torture') {
    shift;
    $torture = 1;
}

# Let tests know they're running in the perl core.  Useful for modules
# which live dual lives on CPAN.
$ENV{PERL_CORE} = 1;

my (@@tests, $re);

# [.VMS]TEST.COM calls harness with empty arguments, so clean-up @@ARGV
@@ARGV = grep $_ && length( $_ ) => @@ARGV;

sub _extract_tests;
sub _extract_tests {
    # This can probably be done more tersely with a map, but I doubt that it
    # would be as clear
    my @@results;
    foreach (@@_) {
	my $ref = ref $_;
	if ($ref) {
	    if ($ref eq 'ARRAY') {
		push @@results, _extract_tests @@$_;
	    } elsif ($ref eq 'HASH') {
		push @@results, _extract_tests values %$_;
	    } else {
		die "Unknown reference type $ref";
	    }
	} else {
	    push @@results, glob $_;
	}
    }
    @@results;
}

if ($ARGV[0] && $ARGV[0]=~/^-re/) {
    if ($ARGV[0]!~/=/) {
        shift;
        $re=join "|",@@ARGV;
        @@ARGV=();
    } else {
        (undef,$re)=split/=/,shift;
    }
}

my $jobs = $ENV{TEST_JOBS};
my ($rules, $state, $color);
if ($ENV{HARNESS_OPTIONS}) {
    for my $opt ( split /:/, $ENV{HARNESS_OPTIONS} ) {
        if ( $opt =~ /^j(\d*)$/ ) {
            $jobs ||= $1 || 9;
        }
        elsif ( $opt eq 'c' ) {
            $color = 1;
        }
        else {
            die "Unknown HARNESS_OPTIONS item: $opt\n";
        }
    }
}

if (@@ARGV) {
    # If you want these run in speed order, just use prove
    if ($^O eq 'MSWin32') {
	@@tests = map(glob($_),@@ARGV);
    }
    else {
	@@tests = @@ARGV;
    }
    # This is a hack to force config_heavy.pl to be loaded, before the
    # prep work for running a test changes directory.
    1 if $Config{d_fork};
} else {
    # Ideally we'd get somewhere close to Tux's Oslo rules
    # my $rules = {
    #     par => [
    #         { seq => '../ext/DB_File/t/*' },
    #         { seq => '../ext/IO_Compress_Zlib/t/*' },
    #         { seq => '../lib/ExtUtils/t/*' },
    #         '*'
    #     ]
    # };

    # but for now, run all directories in sequence.

    unless (@@tests) {
	my @@seq = <base/*.t>;

	my @@next = qw(comp run cmd io re opbasic op uni mro lib porting perf);
	push @@next, 'japh' if $torture;
	push @@next, 'win32' if $^O eq 'MSWin32';
	push @@next, 'benchmark' if $ENV{PERL_BENCHMARK};
	push @@next, 'bigmem' if $ENV{PERL_TEST_MEMORY};
	# Hopefully TAP::Parser::Scheduler will support this syntax soon.
	# my $next = { par => '{' . join (',', @@next) . '}/*.t' };
	my $next = { par => [
			     map { "$_/*.t" } @@next
			    ] };
	@@tests = _extract_tests ($next);

	# This is a bit of a game, because we only want to sort these tests in
	# speed order. base/*.t wants to run first, and ext,lib etc last and in
	# MANIFEST order
	if ($jobs) {
	    require App::Prove::State;
	    $state = App::Prove::State->new({ store => 'test_state' });
	    $state->apply_switch('slow', 'save');
	    # For some reason get_tests returns *all* the tests previously run,
	    # (in the right order), not simply the selection in @@tests
	    # (in the right order). Not sure if this is a bug or a feature.
	    # Whatever, *we* are only interested in the ones that are in @@tests
	    my %seen;
	    @@seen{@@tests} = ();
	    @@tests = grep {exists $seen{$_} } $state->get_tests(0, @@tests);
	}
	@@tests = (@@seq, @@tests);
	push @@seq, $next;

	my @@last;
	push @@last,  sort { lc $a cmp lc $b }
	    _tests_from_manifest($Config{extensions}, $Config{known_extensions});
	my %times;
	if ($state) {
	    # Where known, collate the elapsed times by test name
	    foreach ($state->results->tests()) {
		$times{$_->name} = $_->elapsed();
	    }
	}

	my %dir;
	my %total_time;

	for (@@last) {
	    if ($^O eq 'MSWin32') {
		s,\\,/,g; # canonicalize path
	    };
	    # Treat every file matching lib/*.t as a "directory"
	    m!\A(\.\./lib/[^/]+\.t\z|.*[/])! or die "'$_'";
	    push @@{$dir{$1}}, $_;
	    $total_time{$1} += $times{$_} || 0;
	}

	push @@tests, @@last;

	# Generate T::H schedule rules that run the contents of each directory
	# sequentially.
	push @@seq, { par => [ map { s!/$!/*!; { seq => $_ } } sort {
	    # Directories, ordered by total time descending then name ascending
	    $total_time{$b} <=> $total_time{$a} || $a cmp $b
	} keys %dir ] };

	$rules = { seq => \@@seq };
    }
}
if ($^O eq 'MSWin32') {
    s,\\,/,g for @@tests;
}
@@tests=grep /$re/, @@tests 
    if $re;

# Allow eg ./perl t/harness t/op/lc.t
for (@@tests) {
    if (-f "../$_") {
        $_ = "../$_";
        s{^\.\./t/}{};
    }
}

my %options;

my $type = 'perl';

# Load TAP::Parser now as otherwise it could be required in the short time span
# in which the harness process chdirs into ext/Dist
require TAP::Parser;

my $h = TAP::Harness->new({
    rules       => $rules,
    color       => $color,
    jobs        => $jobs,
    verbosity   => $Verbose,
    timer       => $ENV{HARNESS_TIMER},
    exec        => sub {
	my ($harness, $test) = @@_;

	my $options = $options{$test};
	if (!defined $options) {
	    $options = $options{$test} = _scan_test($test, $type);
	}

	(local $Valgrind_Log = "$test.valgrind-current") =~ s/^.*\///;

	return [ split ' ', _cmd($options, $type) ];
    },
});

# Print valgrind output after test completes
if ($ENV{PERL_VALGRIND}) {
    $h->callback(
		 after_test => sub {
		     my ($job) = @@_;
		     my $test = $job->[0];
		     my $vfile = "$test.valgrind-current";
	             $vfile =~ s/^.*\///;

		     if ( (! -z $vfile) && open(my $voutput, '<', $vfile)) {
			print "$test: Valgrind output:\n";
			print "$test: $_" for <$voutput>;
			close($voutput);
		     }

		     (local $Valgrind_Log = "$test.valgrind-current") =~ s/^.*\///;

		     _check_valgrind(\$htoolnm, \$hgrind_ct, \$test);
		 }
		 );
}

if ($state) {
    $h->callback(
		 after_test => sub {
		     $state->observe_test(@@_);
		 }
		 );
    $h->callback(
		 after_runtests => sub {
		     $state->commit(@@_);
		 }
		 );
}

$h->callback(
	     parser_args => sub {
		 my ($args, $job) = @@_;
		 my $test = $job->[0];
		 _before_fork($options{$test});
		 push @@{ $args->{switches} }, "-I../../lib";
	     }
	     );

$h->callback(
	     made_parser => sub {
		 my ($parser, $job) = @@_;
		 my $test = $job->[0];
		 my $options = delete $options{$test};
		 _after_fork($options);
	     }
	     );

my $agg = $h->runtests(@@tests);
_cleanup_valgrind(\$htoolnm, \$hgrind_ct);
exit $agg->has_errors ? 1 : 0;
@


1.14
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d19 1
d24 4
a36 20
#fudge DATA for now.
my %datahandle = qw(
		lib/bigint.t		1
		lib/bigintpm.t		1
		lib/bigfloat.t	 	1
		lib/bigfloatpm.t	1
		op/gv.t			1
		lib/complex.t		1
		lib/ph.t		1
		lib/soundex.t		1
		op/misc.t		1
		op/runlevel.t		1
		op/tie.t		1
		op/lex_assign.t		1
		);

foreach (keys %datahandle) {
     unlink "$_.t";
}

d117 1
a117 1
	my @@next = qw(comp run cmd io re opbasic op uni mro lib porting);
a149 2
	push @@last, <x2p/*.t>;

d189 8
d210 1
d219 2
d225 22
d279 1
@


1.13
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@a121 1
    #         { seq => '../lib/CPANPLUS/*' },
@


1.12
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d128 1
a128 2
    # but for now, run all directories in sequence. In particular, it would be
    # nice to get the tests in t/op/*.t able to run in parallel.
d133 1
a133 1
	my @@next = qw(comp run cmd io re op uni mro lib porting);
d137 1
@


1.11
log
@merge in perl 5.12.2 plus local changes
@
text
@d15 1
d113 3
a163 1
	use Config;
d183 2
a184 1
	    m!(.*[/])! or die "'$_'";
d193 1
a193 1
	push @@seq, { par => [ map { { seq => "$_*" } } sort {
@


1.10
log
@Merge in perl 5.10.1
@
text
@a9 1
delete $ENV{PERL5LIB};
d13 1
a13 1
use Test::Harness;
d16 5
a20 2
$Test::Harness::switches = "";    # Too much noise otherwise
$Test::Harness::Verbose++ while @@ARGV && $ARGV[0] eq '-v' && shift;
a55 17
sub _populate_hash {
    return map {$_, 1} split /\s+/, $_[0];
}

# Generate T::H schedule rules that run the contents of each directory
# sequentially.
sub _seq_dir_rules {
    my @@tests = @@_;
    my %dir;
    for (@@tests) {
        s{[^/]+$}{\*};
        $dir{$_}++;
    }

    return { par => [ map { { seq => $_ } } sort keys %dir ] };
}

d89 1
a89 1
my ($fork, $rules, $state);
a94 3
        elsif ( $opt eq 'f' ) {
            $fork = 1;
        }
d96 1
a96 1
#            $args->{color} = 1;
d130 1
a130 1
	my @@next = qw(comp cmd run io op uni mro lib);
d133 1
d161 9
a169 6
	my %skip;
	{
	    my %extensions = _populate_hash $Config{'extensions'};
	    my %known_extensions = _populate_hash $Config{'known_extensions'};
	    foreach (keys %known_extensions) {
		$skip{$_}++ unless $extensions{$_};
d172 11
a182 25
	use File::Spec;
	my $updir = File::Spec->updir;
	my $mani  = File::Spec->catfile(File::Spec->updir, "MANIFEST");
	if (open(MANI, $mani)) {
	    my @@manitests = ();
	    while (<MANI>) { # similar code in t/TEST
		if (m!^(ext/(\S+)/+(?:[^/\s]+\.t|test\.pl)|lib/\S+?(?:\.t|test\.pl))\s!) {
		    my ($test, $extension) = ($1, $2);
		    if (defined $extension) {
			$extension =~ s!/t$!!;
			# XXX Do I want to warn that I'm skipping these?
			next if $skip{$extension};
			my $flat_extension = $extension;
			$flat_extension =~ s!-!/!g;
			next if $skip{$flat_extension}; # Foo/Bar may live in Foo-Bar
		    }
		    push @@manitests, File::Spec->catfile($updir, $test);
		}
	    }
	    close MANI;
	    # Sort the list of test files read from MANIFEST into a sensible
	    # order instead of using the order in which they are listed there
	    push @@last, sort { lc $a cmp lc $b } @@manitests;
	} else {
	    warn "$0: cannot open $mani: $!\n";
a183 2
	push @@last, <pod/*.t>;
	push @@last, <x2p/*.t>;
d187 6
a192 1
	push @@seq, _seq_dir_rules @@last;
d203 1
a203 2
if ($jobs) {
    eval 'use TAP::Harness 3.13; 1' or die $@@;
d205 29
a233 15
    # Test::Harness parses $ENV{HARNESS_OPTIONS}, TAP::Harness does not
    local $ENV{HARNESS_OPTIONS};
    my $h = TAP::Harness->new({ jobs => $jobs, rules => $rules, ($fork ? (fork => $fork) : ())});
    if ($state) {
	$h->callback(
		     after_test => sub {
			 $state->observe_test(@@_);
		     }
		    );
	$h->callback(
		     after_runtests => sub {
			 $state->commit(@@_);
		     }
		    );
    }
d235 2
a236 3
		 parser_args => sub {
		     my ( $args, $test ) = @@_;
		     push @@{ $args->{switches} }, '-I../lib';
d238 1
a238 4
		);
    $h->runtests(@@tests);
} else {
    Test::Harness::runtests @@tests;
d240 21
a260 1
exit(0);
@


1.9
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@a8 1
    $ENV{PERL5LIB} = '../lib';    # so children will see it too
d10 1
d15 1
d18 1
a18 1
$Test::Harness::verbose = shift if @@ARGV && $ARGV[0] eq '-v';
d30 1
a30 1
%datahandle = qw(
d49 1
a49 1
my @@tests = ();
d58 35
d103 19
d123 1
d131 14
d146 31
a176 11
	push @@tests, <base/*.t>;
        push @@tests, <comp/*.t>;
        push @@tests, <cmd/*.t>;
        push @@tests, <run/*.t>;
        push @@tests, <io/*.t>;
        push @@tests, <op/*.t>;
        push @@tests, <uni/*.t>;
        push @@tests, <mro/*.t>;
        push @@tests, <lib/*.t>;
        push @@tests, <japh/*.t> if $torture;
	push @@tests, <win32/*.t> if $^O eq 'MSWin32';
a190 1
	    my $ext_pat = $^O eq 'MSWin32' ? '(?:win32/)?ext' : 'ext';
d192 1
a192 1
		if (m!^($ext_pat/(\S+)/+(?:[^/\s]+\.t|test\.pl)|lib/\S+?(?:\.t|test\.pl))\s!) {
d198 3
d208 1
a208 1
	    push @@tests, sort { lc $a cmp lc $b } @@manitests;
d212 8
a219 3
	push @@tests, <Module_Pluggable/*.t>;
	push @@tests, <pod/*.t>;
	push @@tests, <x2p/*.t>;
d227 29
a255 1
Test::Harness::runtests @@tests;
@


1.8
log
@merge in perl 5.8.8
@
text
@d83 1
d100 2
d103 1
a103 1
		if (m!^(ext/(\S+)/+(?:[^/\s]+\.t|test\.pl)|lib/\S+?(?:\.t|test\.pl))\s!) {
d110 1
a110 1
		    push @@tests, File::Spec->catfile($updir, $test);
d114 3
d120 1
d131 1
a131 39
exit(0) unless -e "../testcompile";

# %infinite =  qw (
#        op/bop.t	1
#        lib/hostname.t	1
#	 op/lex_assign.t	1
#	 lib/ph.t	1
#        );

my $dhwrapper = <<'EOT';
open DATA,"<".__FILE__;
until (($_=<DATA>) =~ /^__END__/) {};
EOT

@@tests = grep (!$infinite{$_}, @@tests);
@@tests = map {
         my $new = $_;
	 if ($datahandle{$_} && !( -f "$new.t") ) {
             $new .= '.t';
             local(*F, *T);
             open(F,"<$_") or die "Can't open $_: $!";
             open(T,">$new") or die "Can't open $new: $!";
             print T $dhwrapper, <F>;
             close F;
             close T;
         }
         $new;
         } @@tests;

print "The tests ", join(' ', keys(%infinite)),
    " generate infinite loops! Skipping!\n";

$ENV{'HARNESS_COMPILE_TEST'} = 1;
$ENV{'PERLCC_TIMEOUT'} = 120 unless $ENV{'PERLCC_TIMEOUT'};

Test::Harness::runtests @@tests;
foreach (keys %datahandle) {
     unlink "$_.t";
}
@


1.7
log
@sync in-tree perl with 5.8.6
@
text
@d19 1
a19 1
if ($ARGV[0] eq '-torture') {
d53 14
d86 9
d100 8
a107 2
	    if (m!^(ext/\S+/?(?:[^/\s]+\.t|test\.pl)|lib/\S+?(?:\.t|test\.pl))\s!) {
		    push @@tests, File::Spec->catfile($updir, $1);
d121 2
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d50 3
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d8 1
a8 1
    unshift @@INC, '../lib';
d11 2
a12 1
use lib '../lib';
d19 9
a41 1
		pragma/subs.t   	1
d48 1
a48 2
@@tests = @@ARGV;
@@tests = <base/*.t comp/*.t cmd/*.t io/*.t op/*.t pragma/*.t lib/*.t> unless @@tests;
d50 39
d96 1
a96 1
#	 lib/ph.t	1  
d122 1
a122 1
$ENV{'HARNESS_COMPILE_TEST'} = 1; 
d125 1
a125 1
Test::Harness::runtests @@tests; 
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d45 6
a50 6
%infinite =  qw (
        op/bop.t	1
        lib/hostname.t	1
	op/lex_assign.t	1
	lib/ph.t	1  
        );
@


1.3
log
@perl5.005_03 (stock)
@
text
@d8 2
a9 2
    @@INC = '../lib';
    $ENV{PERL5LIB} = '../lib';	# so children will see it too
d15 1
a15 1
$Test::Harness::switches = "";	# Too much noise otherwise
d18 21
d43 1
d45 11
a55 1
%infinite = ('comp/require.t', 1, 'op/bop.t', 1, 'lib/hostname.t', 1 );
d58 23
a80 7

if (-e "../testcompile") 
{ 
	print "The tests ", join(' ', keys(%infinite)), 
							" generate infinite loops! Skipping!\n";

	$ENV{'COMPILE_TEST'} = 1; Test::Harness::runtests @@tests; 
@


1.2
log
@perl 5.004_04
@
text
@d9 1
d20 1
d22 12
@


1.1
log
@Initial revision
@
text
@d6 5
a10 1
# Note that _before install_ you may need to run it with -I ../lib flag
a11 1
use lib '../lib';
d15 1
d18 1
a18 1
@@tests = <*/*.t> unless @@tests;
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d6 2
a7 5
BEGIN {
    chdir 't' if -d 't';
    @@INC = '../lib';
    $ENV{PERL5LIB} = '../lib';	# so children will see it too
}
a8 1

a11 1
$Test::Harness::verbose = shift if @@ARGV && $ARGV[0] eq '-v';
d14 1
a14 2
@@tests = <base/*.t comp/*.t cmd/*.t io/*.t op/*.t pragma/*.t lib/*.t> unless @@tests;

a15 12

%infinite = ('comp/require.t', 1, 'op/bop.t', 1, 'lib/hostname.t', 1 );

@@tests = grep (!$infinite{$_}, @@tests);

if (-e "../testcompile") 
{ 
	print "The tests ", join(' ', keys(%infinite)), 
							" generate infinite loops! Skipping!\n";

	$ENV{'COMPILE_TEST'} = 1; Test::Harness::runtests @@tests; 
}
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d8 2
a9 2
    unshift @@INC, '../lib';
    $ENV{PERL5LIB} = '../lib';    # so children will see it too
d15 1
a15 1
$Test::Harness::switches = "";    # Too much noise otherwise
a17 21
#fudge DATA for now.
%datahandle = qw(
		lib/bigint.t		1
		lib/bigintpm.t		1
		lib/bigfloat.t	 	1
		lib/bigfloatpm.t	1
		op/gv.t			1
		lib/complex.t		1
		lib/ph.t		1
		lib/soundex.t		1
		op/misc.t		1
		op/runlevel.t		1
		op/tie.t		1
		op/lex_assign.t		1
		pragma/subs.t   	1
		);

foreach (keys %datahandle) {
     unlink "$_.t";
}

a21 1
exit(0) unless -e "../testcompile";
d23 1
a23 11
%infinite =  qw (
        op/bop.t	1
        lib/hostname.t	1
	op/lex_assign.t	1
	lib/ph.t	1  
        );

my $dhwrapper = <<'EOT';
open DATA,"<".__FILE__;
until (($_=<DATA>) =~ /^__END__/) {};
EOT
d26 7
a32 23
@@tests = map {
         my $new = $_;
	 if ($datahandle{$_} && !( -f "$new.t") ) {
             $new .= '.t';
             local(*F, *T);
             open(F,"<$_") or die "Can't open $_: $!";
             open(T,">$new") or die "Can't open $new: $!";
             print T $dhwrapper, <F>;
             close F;
             close T;
         }
         $new;
         } @@tests;

print "The tests ", join(' ', keys(%infinite)),
    " generate infinite loops! Skipping!\n";

$ENV{'HARNESS_COMPILE_TEST'} = 1; 
$ENV{'PERLCC_TIMEOUT'} = 120 unless $ENV{'PERLCC_TIMEOUT'};

Test::Harness::runtests @@tests; 
foreach (keys %datahandle) {
     unlink "$_.t";
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d45 6
a50 6
# %infinite =  qw (
#        op/bop.t	1
#        lib/hostname.t	1
#	 op/lex_assign.t	1
#	 lib/ph.t	1  
#        );
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d8 1
a8 1
    @@INC = '../lib';              # pick up only this build's lib
d11 1
a11 2

my $torture; # torture testing?
a17 9
if ($ARGV[0] eq '-torture') {
    shift;
    $torture = 1;
}

# Let tests know they're running in the perl core.  Useful for modules
# which live dual lives on CPAN.
$ENV{PERL_CORE} = 1;

d32 1
d39 2
a40 1
my @@tests = ();
a41 39
if (@@ARGV) {
    if ($^O eq 'MSWin32') {
	@@tests = map(glob($_),@@ARGV);
    }
    else {
	@@tests = @@ARGV;
    }
} else {
    unless (@@tests) {
	push @@tests, <base/*.t>;
        push @@tests, <comp/*.t>;
        push @@tests, <cmd/*.t>;
        push @@tests, <run/*.t>;
        push @@tests, <io/*.t>;
        push @@tests, <op/*.t>;
        push @@tests, <uni/*.t>;
        push @@tests, <lib/*.t>;
        push @@tests, <japh/*.t> if $torture;
	push @@tests, <win32/*.t> if $^O eq 'MSWin32';
	use File::Spec;
	my $updir = File::Spec->updir;
	my $mani  = File::Spec->catfile(File::Spec->updir, "MANIFEST");
	if (open(MANI, $mani)) {
	    while (<MANI>) { # similar code in t/TEST
	    if (m!^(ext/\S+/?(?:[^/\s]+\.t|test\.pl)|lib/\S+?(?:\.t|test\.pl))\s!) {
		    push @@tests, File::Spec->catfile($updir, $1);
		}
	    }
	    close MANI;
	} else {
	    warn "$0: cannot open $mani: $!\n";
	}
	push @@tests, <pod/*.t>;
	push @@tests, <x2p/*.t>;
    }
}
if ($^O eq 'MSWin32') {
    s,\\,/,g for @@tests;
}
d49 1
a49 1
#	 lib/ph.t	1
d75 1
a75 1
$ENV{'HARNESS_COMPILE_TEST'} = 1;
d78 1
a78 1
Test::Harness::runtests @@tests;
@


1.1.1.6
log
@perl 5.8.6 from CPAN
@
text
@a49 3
# [.VMS]TEST.COM calls harness with empty arguments, so clean-up @@ARGV
@@ARGV = grep $_ && length( $_ ) => @@ARGV;

@


1.1.1.7
log
@perl 5.8.8 import
@
text
@d19 1
a19 1
if ($ARGV[0] && $ARGV[0] eq '-torture') {
a52 14
sub _populate_hash {
    return map {$_, 1} split /\s+/, $_[0];
}

if ($ARGV[0] && $ARGV[0]=~/^-re/) {
    if ($ARGV[0]!~/=/) {
        shift;
        $re=join "|",@@ARGV;
        @@ARGV=();
    } else {
        (undef,$re)=split/=/,shift;
    }
}

a71 9
	use Config;
	my %skip;
	{
	    my %extensions = _populate_hash $Config{'extensions'};
	    my %known_extensions = _populate_hash $Config{'known_extensions'};
	    foreach (keys %known_extensions) {
		$skip{$_}++ unless $extensions{$_};
	    }
	}
d77 2
a78 8
		if (m!^(ext/(\S+)/+(?:[^/\s]+\.t|test\.pl)|lib/\S+?(?:\.t|test\.pl))\s!) {
		    my ($test, $extension) = ($1, $2);
		    if (defined $extension) {
			$extension =~ s!/t$!!;
			# XXX Do I want to warn that I'm skipping these?
			next if $skip{$extension};
		    }
		    push @@tests, File::Spec->catfile($updir, $test);
a91 2
@@tests=grep /$re/, @@tests 
    if $re;
@


1.1.1.8
log
@import perl 5.10.0 from CPAN
@
text
@a82 1
        push @@tests, <mro/*.t>;
a98 2
	    my @@manitests = ();
	    my $ext_pat = $^O eq 'MSWin32' ? '(?:win32/)?ext' : 'ext';
d100 1
a100 1
		if (m!^($ext_pat/(\S+)/+(?:[^/\s]+\.t|test\.pl)|lib/\S+?(?:\.t|test\.pl))\s!) {
d107 1
a107 1
		    push @@manitests, File::Spec->catfile($updir, $test);
a110 3
	    # Sort the list of test files read from MANIFEST into a sensible
	    # order instead of using the order in which they are listed there
	    push @@tests, sort { lc $a cmp lc $b } @@manitests;
a113 1
	push @@tests, <Module_Pluggable/*.t>;
d124 39
a162 1
exit(0);
@


1.1.1.9
log
@import perl 5.10.1
@
text
@d9 1
a10 1
delete $ENV{PERL5LIB};
a14 1
use strict;
d17 1
a17 1
$Test::Harness::Verbose++ while @@ARGV && $ARGV[0] eq '-v' && shift;
d29 1
a29 1
my %datahandle = qw(
d48 1
a48 1
my (@@tests, $re);
a56 35
# Generate T::H schedule rules that run the contents of each directory
# sequentially.
sub _seq_dir_rules {
    my @@tests = @@_;
    my %dir;
    for (@@tests) {
        s{[^/]+$}{\*};
        $dir{$_}++;
    }

    return { par => [ map { { seq => $_ } } sort keys %dir ] };
}

sub _extract_tests;
sub _extract_tests {
    # This can probably be done more tersely with a map, but I doubt that it
    # would be as clear
    my @@results;
    foreach (@@_) {
	my $ref = ref $_;
	if ($ref) {
	    if ($ref eq 'ARRAY') {
		push @@results, _extract_tests @@$_;
	    } elsif ($ref eq 'HASH') {
		push @@results, _extract_tests values %$_;
	    } else {
		die "Unknown reference type $ref";
	    }
	} else {
	    push @@results, glob $_;
	}
    }
    @@results;
}

a66 19
my $jobs = $ENV{TEST_JOBS};
my ($fork, $rules, $state);
if ($ENV{HARNESS_OPTIONS}) {
    for my $opt ( split /:/, $ENV{HARNESS_OPTIONS} ) {
        if ( $opt =~ /^j(\d*)$/ ) {
            $jobs ||= $1 || 9;
        }
        elsif ( $opt eq 'f' ) {
            $fork = 1;
        }
        elsif ( $opt eq 'c' ) {
#            $args->{color} = 1;
        }
        else {
            die "Unknown HARNESS_OPTIONS item: $opt\n";
        }
    }
}

a67 1
    # If you want these run in speed order, just use prove
a74 14
    # Ideally we'd get somewhere close to Tux's Oslo rules
    # my $rules = {
    #     par => [
    #         { seq => '../ext/DB_File/t/*' },
    #         { seq => '../ext/IO_Compress_Zlib/t/*' },
    #         { seq => '../lib/CPANPLUS/*' },
    #         { seq => '../lib/ExtUtils/t/*' },
    #         '*'
    #     ]
    # };

    # but for now, run all directories in sequence. In particular, it would be
    # nice to get the tests in t/op/*.t able to run in parallel.

d76 11
a86 31
	my @@seq = <base/*.t>;

	my @@next = qw(comp cmd run io op uni mro lib);
	push @@next, 'japh' if $torture;
	push @@next, 'win32' if $^O eq 'MSWin32';
	# Hopefully TAP::Parser::Scheduler will support this syntax soon.
	# my $next = { par => '{' . join (',', @@next) . '}/*.t' };
	my $next = { par => [
			     map { "$_/*.t" } @@next
			    ] };
	@@tests = _extract_tests ($next);

	# This is a bit of a game, because we only want to sort these tests in
	# speed order. base/*.t wants to run first, and ext,lib etc last and in
	# MANIFEST order
	if ($jobs) {
	    require App::Prove::State;
	    $state = App::Prove::State->new({ store => 'test_state' });
	    $state->apply_switch('slow', 'save');
	    # For some reason get_tests returns *all* the tests previously run,
	    # (in the right order), not simply the selection in @@tests
	    # (in the right order). Not sure if this is a bug or a feature.
	    # Whatever, *we* are only interested in the ones that are in @@tests
	    my %seen;
	    @@seen{@@tests} = ();
	    @@tests = grep {exists $seen{$_} } $state->get_tests(0, @@tests);
	}
	@@tests = (@@seq, @@tests);
	push @@seq, $next;

	my @@last;
d101 1
d103 1
a103 1
		if (m!^(ext/(\S+)/+(?:[^/\s]+\.t|test\.pl)|lib/\S+?(?:\.t|test\.pl))\s!) {
a108 3
			my $flat_extension = $extension;
			$flat_extension =~ s!-!/!g;
			next if $skip{$flat_extension}; # Foo/Bar may live in Foo-Bar
d116 1
a116 1
	    push @@last, sort { lc $a cmp lc $b } @@manitests;
d120 3
a122 8
	push @@last, <pod/*.t>;
	push @@last, <x2p/*.t>;

	push @@tests, @@last;

	push @@seq, _seq_dir_rules @@last;

	$rules = { seq => \@@seq };
d130 1
a130 29

if ($jobs) {
    eval 'use TAP::Harness 3.13; 1' or die $@@;

    # Test::Harness parses $ENV{HARNESS_OPTIONS}, TAP::Harness does not
    local $ENV{HARNESS_OPTIONS};
    my $h = TAP::Harness->new({ jobs => $jobs, rules => $rules, ($fork ? (fork => $fork) : ())});
    if ($state) {
	$h->callback(
		     after_test => sub {
			 $state->observe_test(@@_);
		     }
		    );
	$h->callback(
		     after_runtests => sub {
			 $state->commit(@@_);
		     }
		    );
    }
    $h->callback(
		 parser_args => sub {
		     my ( $args, $test ) = @@_;
		     push @@{ $args->{switches} }, '-I../lib';
		 }
		);
    $h->runtests(@@tests);
} else {
    Test::Harness::runtests @@tests;
}
@


1.1.1.10
log
@Perl 5.12.2 from CPAN
@
text
@d10 1
d14 1
a14 1
use TAP::Harness 3.13;
d17 2
a18 5
$::do_nothing = $::do_nothing = 1;
require './TEST';

my $Verbose = 0;
$Verbose++ while @@ARGV && $ARGV[0] eq '-v' && shift;
d54 17
d104 1
a104 1
my ($rules, $state, $color);
d110 3
d114 1
a114 1
            $color = 1;
d148 1
a148 1
	my @@next = qw(comp run cmd io re op uni mro lib porting);
a150 1
	push @@next, 'benchmark' if $ENV{PERL_BENCHMARK};
d178 6
a183 9
	push @@last,  sort { lc $a cmp lc $b }
	    _tests_from_manifest($Config{extensions}, $Config{known_extensions});
	push @@last, <x2p/*.t>;

	my %times;
	if ($state) {
	    # Where known, collate the elapsed times by test name
	    foreach ($state->results->tests()) {
		$times{$_->name} = $_->elapsed();
d186 25
a210 11

	my %dir;
	my %total_time;

	for (@@last) {
	    if ($^O eq 'MSWin32') {
		s,\\,/,g; # canonicalize path
	    };
	    m!(.*[/])! or die "'$_'";
	    push @@{$dir{$1}}, $_;
	    $total_time{$1} += $times{$_} || 0;
d212 2
d217 1
a217 6
	# Generate T::H schedule rules that run the contents of each directory
	# sequentially.
	push @@seq, { par => [ map { { seq => "$_*" } } sort {
	    # Directories, ordered by total time descending then name ascending
	    $total_time{$b} <=> $total_time{$a} || $a cmp $b
	} keys %dir ] };
d228 2
a229 1
my %options;
d231 15
a245 24
my $type = 'perl';

# Load TAP::Parser now as otherwise it could be required in the short time span
# in which the harness process chdirs into ext/Dist
require TAP::Parser;

my $h = TAP::Harness->new({
    rules       => $rules,
    color       => $color,
    jobs        => $jobs,
    verbosity   => $Verbose,
    exec        => sub {
	my ($harness, $test) = @@_;

	my $options = $options{$test};
	if (!defined $options) {
	    $options = $options{$test} = _scan_test($test, $type);
	}

	return [ split ' ', _cmd($options, $type) ];
    },
});

if ($state) {
d247 3
a249 2
		 after_test => sub {
		     $state->observe_test(@@_);
d251 4
a254 6
		 );
    $h->callback(
		 after_runtests => sub {
		     $state->commit(@@_);
		 }
		 );
d256 1
a256 21

$h->callback(
	     parser_args => sub {
		 my ($args, $job) = @@_;
		 my $test = $job->[0];
		 _before_fork($options{$test});
		 push @@{ $args->{switches} }, "-I../../lib";
	     }
	     );

$h->callback(
	     made_parser => sub {
		 my ($parser, $job) = @@_;
		 my $test = $job->[0];
		 my $options = delete $options{$test};
		 _after_fork($options);
	     }
	     );

my $agg = $h->runtests(@@tests);
exit $agg->has_errors ? 1 : 0;
@


1.1.1.11
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@a14 1
use Config;
a111 3
    # This is a hack to force config_heavy.pl to be loaded, before the
    # prep work for running a test changes directory.
    1 if $Config{d_fork};
d160 1
d180 1
a180 2
	    # Treat every file matching lib/*.t as a "directory"
	    m!\A(\.\./lib/[^/]+\.t\z|.*[/])! or die "'$_'";
d189 1
a189 1
	push @@seq, { par => [ map { s!/$!/*!; { seq => $_ } } sort {
@


1.1.1.12
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d128 2
a129 1
    # but for now, run all directories in sequence.
d134 1
a134 1
	my @@next = qw(comp run cmd io re opbasic op uni mro lib porting);
a137 1
	push @@next, 'bigmem' if $ENV{PERL_TEST_MEMORY};
@


1.1.1.13
log
@Import perl-5.20.1
@
text
@d122 1
@


