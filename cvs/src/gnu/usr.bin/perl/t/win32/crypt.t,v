head	1.1;
access;
symbols
	OPENBSD_6_2:1.1.0.2
	OPENBSD_6_2_BASE:1.1
	PERL_5_24_2:1.1.1.1
	PERL:1.1.1
	OPENBSD_6_1:1.1.0.4
	OPENBSD_6_1_BASE:1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.1
date	2017.02.05.00.32.21;	author afresh1;	state Exp;
branches
	1.1.1.1;
next	;
commitid	cxJ08BvJA9Pt2PTM;

1.1.1.1
date	2017.08.14.13.46.25;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.1
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl

BEGIN {
    chdir 't' if -d 't';
    @@INC = '../lib';
    require "./test.pl";
    eval 'use Errno';
    die $@@ if $@@ and !is_miniperl();
}

my @@bad_salts =
   (
    [ '',   'zero-length' ],
    [ 'a',  'length 1' ],
    [ '!a', 'bad first character' ],
    [ 'a!', 'bad second character' ],
    [ '@@a', 'fencepost before A' ],
    [ '[a', 'fencepost after Z' ],
    [ '`a', 'fencepost before a' ],
    [ '{a', 'fencepost after z' ],
    [ '-a', 'fencepost before .' ],
    [ ':a', 'fencepost after 9' ],
   );

my @@good_salts = qw(aa zz AA ZZ .. 99);

plan tests => 2 * @@bad_salts + 1 + @@good_salts;

for my $bad_salt (@@bad_salts) {
    my ($salt, $what) = @@$bad_salt;
    $! = 0;
    is(crypt("abc", $salt), undef, "bad salt ($what)");
    is(0+$!, &Errno::EINVAL, "check errno ($what)");
}

is(crypt("abcdef", "ab"), "abDMWw5NL.afs", "sanity check result");

# just to check we're not rejecting any good salts
for my $good_salt (@@good_salts) {
    isnt(crypt("abcdef", $good_salt), undef, "good salt $good_salt");
}
@


1.1.1.1
log
@Import perl-5.24.2
@
text
@@

