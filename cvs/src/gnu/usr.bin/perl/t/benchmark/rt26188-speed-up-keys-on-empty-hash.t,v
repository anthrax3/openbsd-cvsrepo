head	1.2;
access;
symbols
	OPENBSD_6_1:1.2.0.2
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.2.0.16
	OPENBSD_6_0_BASE:1.1.1.2
	OPENBSD_5_9:1.1.1.2.0.10
	OPENBSD_5_9_BASE:1.1.1.2
	OPENBSD_5_8:1.1.1.2.0.12
	OPENBSD_5_8_BASE:1.1.1.2
	PERL_5_20_2:1.1.1.2
	OPENBSD_5_7:1.1.1.2.0.4
	OPENBSD_5_7_BASE:1.1.1.2
	PERL_5_20_1:1.1.1.2
	OPENBSD_5_6:1.1.1.2.0.8
	OPENBSD_5_6_BASE:1.1.1.2
	PERL_5_18_2:1.1.1.2
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.2.0.6
	OPENBSD_5_5_BASE:1.1.1.2
	OPENBSD_5_4:1.1.1.2.0.2
	OPENBSD_5_4_BASE:1.1.1.2
	PERL_5_16_3:1.1.1.2
	OPENBSD_5_3:1.1.1.1.0.10
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.8
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.6
	OPENBSD_5_0:1.1.1.1.0.4
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.2
	OPENBSD_4_9_BASE:1.1.1.1
	PERL_5_12_2:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.32.19;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2010.09.24.14.49.18;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.09.24.14.49.18;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.03.25.20.09.32;	author sthen;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!/usr/bin/perl -w
use strict;
use Benchmark;
chdir 't' if -d 't';
require './test.pl';
plan(tests => 6);

=head1 NAME

rt26188 - benchmark speed for keys() on empty hashes

=head1 DESCRIPTION

If you have an empty hash, the speed of keys() depends
on how many keys the hash previously held.

For global hashes, getting the count for previously
big hashes was substantially slower than for lexical hashes.

This test checks that the speed difference for getting
the number or list of keys from an empty hash is about the same
(< 25%) for lexical and global hashes, both previously big and small.

=head1 REFERENCE

This test tests against RT ticket #26188

L<http://rt.perl.org/rt3/Public/Bug/Display.html?id=26188>

=cut

use vars qw(%h_big %h_small);
my %l_big = (1..50000);
my %l_small = (1..10);

%h_big = (1..50000);
%h_small = (1..10);

delete @@h_big{keys %h_big};
delete @@h_small{keys %h_small};
delete @@l_big{keys %l_big};
delete @@l_small{keys %l_small};

my $res = timethese shift || -3, {
    big => '1 for keys %h_big',
    small => '1 for keys %h_small',
    scalar_big => '$a = keys %h_big',
    scalar_small => '$a = keys %h_small',

    lex_big => '1 for keys %l_big',
    lex_small => '1 for keys %l_small',
    lex_scalar_big => '$a = keys %l_big',
    lex_scalar_small => '$a = keys %l_small',
}, 'none';

sub iters_per_second {
    $_[0]->iters / $_[0]->cpu_p
}

sub about_as_fast_ok {
    my ($res, $key1, $key2, $name) = @@_;
    $name ||= "Speed difference between $key1 and $key2 is less than 25%";
    my %iters_per_second = map { $_ => iters_per_second( $res->{ $_ }) } ($key1, $key2);

    my $ratio = abs(1 - $iters_per_second{ $key1 } / ($iters_per_second{ $key2 } || 1 ));
    if (! cmp_ok( $ratio, '<', 0.25, $name )) {
        diag( sprintf "%20s: %12.2f/s\n", $key1, $iters_per_second{ $key1 } );
        diag( sprintf "%20s: %12.2f/s\n", $key2, $iters_per_second{ $key2 } );
    };
};

about_as_fast_ok( $res, 'scalar_big', 'scalar_small',"Checking the count of hash keys in an empty hash (global)");

about_as_fast_ok( $res, 'big', 'small', "Checking the list of hash keys in an empty hash (global)");

about_as_fast_ok( $res, 'lex_scalar_big', 'lex_scalar_small',"Checking the count of hash keys in an empty hash (lexical)");

about_as_fast_ok( $res, 'lex_big', 'lex_small', "Checking the list of hash keys in an empty hash (lexical)");

about_as_fast_ok( $res, 'lex_scalar_big', 'scalar_big',"Checking the count of hash keys in an empty hash, global vs. lexical");

about_as_fast_ok( $res, 'lex_big', 'big', "Checking the list of hash keys in an empty hash, global vs. lexical");

__END__
@


1.1
log
@Initial revision
@
text
@d4 1
a84 7

# code written
    /* quick bailout if the hash is empty anyway.
       I don't know if placeholders are included in the KEYS count, so a defensive check
    */
    if (! HvKEYS(hv) && !(flags & HV_ITERNEXT_WANTPLACEHOLDERS) )
        return NULL;
@


1.1.1.1
log
@Perl 5.12.2 from CPAN
@
text
@@


1.1.1.2
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d84 7
@

