head	1.3;
access;
symbols
	OPENBSD_6_0:1.2.0.4
	OPENBSD_6_0_BASE:1.2
	OPENBSD_5_9:1.1.1.7.0.2
	OPENBSD_5_9_BASE:1.1.1.7
	OPENBSD_5_8:1.1.1.7.0.4
	OPENBSD_5_8_BASE:1.1.1.7
	PERL_5_20_2:1.1.1.7
	OPENBSD_5_7:1.1.1.6.0.2
	OPENBSD_5_7_BASE:1.1.1.6
	PERL_5_20_1:1.1.1.6
	OPENBSD_5_6:1.1.1.5.0.4
	OPENBSD_5_6_BASE:1.1.1.5
	PERL_5_18_2:1.1.1.5
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.4.0.6
	OPENBSD_5_5_BASE:1.1.1.4
	OPENBSD_5_4:1.1.1.4.0.2
	OPENBSD_5_4_BASE:1.1.1.4
	PERL_5_16_3:1.1.1.4
	OPENBSD_5_3:1.1.1.3.0.14
	OPENBSD_5_3_BASE:1.1.1.3
	OPENBSD_5_2:1.1.1.3.0.12
	OPENBSD_5_2_BASE:1.1.1.3
	OPENBSD_5_1_BASE:1.1.1.3
	OPENBSD_5_1:1.1.1.3.0.10
	OPENBSD_5_0:1.1.1.3.0.8
	OPENBSD_5_0_BASE:1.1.1.3
	OPENBSD_4_9:1.1.1.3.0.6
	OPENBSD_4_9_BASE:1.1.1.3
	PERL_5_12_2:1.1.1.3
	OPENBSD_4_8:1.1.1.3.0.4
	OPENBSD_4_8_BASE:1.1.1.3
	OPENBSD_4_7:1.1.1.3.0.2
	OPENBSD_4_7_BASE:1.1.1.3
	PERL_5_10_1:1.1.1.3
	OPENBSD_4_6:1.1.1.2.0.6
	OPENBSD_4_6_BASE:1.1.1.2
	OPENBSD_4_5:1.1.1.2.0.2
	OPENBSD_4_5_BASE:1.1.1.2
	PERL_5_10_0:1.1.1.2
	OPENBSD_4_4:1.1.1.1.0.20
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.18
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.16
	OPENBSD_4_2_BASE:1.1.1.1
	OPENBSD_4_1:1.1.1.1.0.14
	OPENBSD_4_1_BASE:1.1.1.1
	OPENBSD_4_0:1.1.1.1.0.12
	OPENBSD_4_0_BASE:1.1.1.1
	PERL_5_8_8:1.1.1.1
	OPENBSD_3_9:1.1.1.1.0.10
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.8
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.6
	OPENBSD_3_7_BASE:1.1.1.1
	PERL_5_8_6:1.1.1.1
	OPENBSD_3_6:1.1.1.1.0.4
	OPENBSD_3_6_BASE:1.1.1.1
	PERL_5_8_5:1.1.1.1
	PERL_5_8_3:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.2
	OPENBSD_3_5_BASE:1.1.1.1
	PERL_5_8_2:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.3
date	2017.02.05.00.32.21;	author afresh1;	state Exp;
branches;
next	1.2;
commitid	cxJ08BvJA9Pt2PTM;

1.2
date	2016.07.03.01.08.05;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	GzHqjSTnBjdF7Wcw;

1.1
date	2003.12.03.02.44.33;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.12.03.02.44.33;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2008.09.29.17.19.03;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2009.10.12.18.10.41;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2013.03.25.20.09.38;	author sthen;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2014.03.24.14.59.11;	author afresh1;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2014.11.17.20.53.19;	author afresh1;	state Exp;
branches;
next	1.1.1.7;
commitid	B31cAbBIXiCqnL97;

1.1.1.7
date	2015.04.25.19.10.49;	author afresh1;	state Exp;
branches;
next	;
commitid	Wpcs5S8qILgEZC7F;


desc
@@


1.3
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl -w

BEGIN {
    chdir 't' if -d 't';
    @@INC = qw(../lib lib);
    require "./test.pl";
}

# This test depends on t/lib/Devel/switchd*.pm.

plan(tests => 21);

my $r;

my $filename = tempfile();
SKIP: {
	open my $f, ">$filename"
	    or skip( "Can't write temp file $filename: $!" );
	print $f <<'__SWDTEST__';
package Bar;
sub bar { $_[0] * $_[0] }
package Foo;
sub foo {
  my $s;
  $s += Bar::bar($_) for 1..$_[0];
}
package main;
Foo::foo(3);
__SWDTEST__
    close $f;
    $| = 1; # Unbufferize.
    $r = runperl(
		 switches => [ '-Ilib', '-f', '-d:switchd' ],
		 progfile => $filename,
		 args => ['3'],
		);
    like($r,
qr/^sub<Devel::switchd::import>;import<Devel::switchd>;DB<main,$::tempfile_regexp,9>;sub<Foo::foo>;DB<Foo,$::tempfile_regexp,5>;DB<Foo,$::tempfile_regexp,6>;sub<Bar::bar>;DB<Bar,$::tempfile_regexp,2>;sub<Bar::bar>;DB<Bar,$::tempfile_regexp,2>;sub<Bar::bar>;DB<Bar,$::tempfile_regexp,2>;$/,
    'Got debugging output: 1');
    $r = runperl(
		 switches => [ '-Ilib', '-f', '-d:switchd=a,42' ],
		 progfile => $filename,
		 args => ['4'],
		);
    like($r,
qr/^sub<Devel::switchd::import>;import<Devel::switchd a 42>;DB<main,$::tempfile_regexp,9>;sub<Foo::foo>;DB<Foo,$::tempfile_regexp,5>;DB<Foo,$::tempfile_regexp,6>;sub<Bar::bar>;DB<Bar,$::tempfile_regexp,2>;sub<Bar::bar>;DB<Bar,$::tempfile_regexp,2>;sub<Bar::bar>;DB<Bar,$::tempfile_regexp,2>;$/,
    'Got debugging output: 2');
    $r = runperl(
		 switches => [ '-Ilib', '-f', '-d:-switchd=a,42' ],
		 progfile => $filename,
		 args => ['4'],
		);
    like($r,
qr/^sub<Devel::switchd::unimport>;unimport<Devel::switchd a 42>;DB<main,$::tempfile_regexp,9>;sub<Foo::foo>;DB<Foo,$::tempfile_regexp,5>;DB<Foo,$::tempfile_regexp,6>;sub<Bar::bar>;DB<Bar,$::tempfile_regexp,2>;sub<Bar::bar>;DB<Bar,$::tempfile_regexp,2>;sub<Bar::bar>;DB<Bar,$::tempfile_regexp,2>;$/,
    'Got debugging output: 3');
}

# [perl #71806]
cmp_ok(
  runperl(       # less is useful for something :-)
   switches => [ '"-Mless ++INC->{q-Devel/_.pm-}"' ],
   progs    => [
    '#!perl -d:_',
    'sub DB::DB{} print scalar @@{q/_</.__FILE__}',
   ],
  ),
 '>',
  0,
 'The debugger can see the lines of the main program under #!perl -d',
);

like
  runperl(
   switches => [ '"-Mless ++INC->{q-Devel/_.pm-}"' ],
   progs    => [
    '#!perl -d:_',
    'sub DB::DB{} print line=>__LINE__',
   ],
  ),
  qr/line2/,
 '#!perl -d:whatever does not throw line numbers off';

# [perl #48332]
like(
  runperl(
   switches => [ '-Ilib', '-d:switchd_empty' ],
   progs    => [
    'sub foo { print qq _1\n_ }',
    '*old_foo = \&foo;',
    '*foo = sub { print qq _2\n_ };',
    'old_foo(); foo();',
   ],
  ),
  qr "1\r?\n2\r?\n",
 'Subroutine redefinition works in the debugger [perl #48332]',
);

# [rt.cpan.org #69862]
like(
  runperl(
   switches => [ '-Ilib', '-d:switchd_empty' ],
   progs    => [
    'sub DB::sub { goto &$DB::sub }',
    'sub foo { print qq _1\n_ }',
    'sub bar { print qq _2\n_ }',
    'delete $::{foo}; eval { foo() };',
    'my $bar = *bar; undef *bar; eval { &$bar };',
   ],
  ),
  qr "1\r?\n2\r?\n",
 'Subroutines no longer found under their names can be called',
);

# [rt.cpan.org #69862]
like(
  runperl(
   switches => [ '-Ilib', '-d:switchd_empty' ],
   progs    => [
    'sub DB::sub { goto &$DB::sub }',
    'sub foo { goto &bar::baz; }',
    'sub bar::baz { print qq _ok\n_ }',
    'delete $::{bar::::};',
    'foo();',
   ],
  ),
  qr "ok\r?\n",
 'No crash when calling orphaned subroutine via goto &',
);

# test when DB::DB is seen but not defined [perl #114990]
like(
  runperl(
    switches => [ '-Ilib', '-d:nodb' ],
    prog     => [ '1' ],
    stderr   => 1,
  ),
  qr/^No DB::DB routine defined/,
  "No crash when *DB::DB exists but not &DB::DB",
);
like(
  runperl(
    switches => [ '-Ilib' ],
    prog     => 'sub DB::DB; BEGIN { $^P = 0x22; } for(0..9){ warn }',
    stderr   => 1,
  ),
  qr/^No DB::DB routine defined/,
  "No crash when &DB::DB exists but isn't actually defined",
);
# or seen and defined later
is(
  runperl(
    switches => [ '-Ilib', '-d:nodb' ], # nodb.pm contains *DB::DB...if 0
    prog     => 'warn; sub DB::DB { print qq-ok\n-; exit }',
    stderr   => 1,
  ),
  "ok\n",
  "DB::DB works after '*DB::DB if 0'",
);

# [perl #115742] Recursive DB::DB clobbering its own pad
like(
  runperl(
    switches => [ '-Ilib' ],
    progs    => [ split "\n", <<'='
     BEGIN {
      $^P = 0x22;
     }
     package DB;
     sub DB {
      my $x = 42;
      return if $__++;
      $^D |= 1 << 30; # allow recursive calls
      main::foo();
      print $x//q-u-, qq-\n-;
     }
     package main;
     chop;
     sub foo { chop; }
=
    ],
    stderr   => 1,
  ),
  qr/42/,
  "Recursive DB::DB does not clobber its own pad",
);

# [perl #118627]
like(
  runperl(
   switches => [ '-Ilib', '-d:switchd_empty' ],
   prog     => 'print @@{q|_<-e|}',
  ),
  qr "use Devel::switchd_empty;(?:BEGIN|\r?\nprint)",
                         # miniperl tacks a BEGIN block on to the same line
 'Copy on write does not mangle ${"_<-e"}[0] [perl #118627]',
);

# PERL5DB with embedded newlines
{
    local $ENV{PERL5DB} = "sub DB::DB{}\nwarn";
    is(
      runperl(
       switches => [ '-Ilib', '-ld' ],
       prog     => 'warn',
       stderr   => 1
      ),
      "Warning: something's wrong.\n"
     ."Warning: something's wrong at -e line 1.\n",
     'PERL5DB with embedded newlines',
    );
}

# test that DB::goto works
is(
  runperl(
   switches => [ '-Ilib', '-d:switchd_goto' ],
   prog => 'sub baz { print qq|hello;\n| } sub foo { goto &baz } foo()',
   stderr => 1,
  ),
  "goto<main::baz>;hello;\n",
  "DB::goto"
);

# Test that %DB::lsub is not vivified
is(
  runperl(
   switches => [ '-Ilib', '-d:switchd_empty' ],
   progs => ['sub DB::sub {} sub foo : lvalue {} foo();',
             'print qq-ok\n- unless defined *DB::lsub{HASH}'],
  ),
  "ok\n",
  "%DB::lsub is not vivified"
);

# Test setting of breakpoints without *DB::dbline aliased
is(
  runperl(
   switches => [ '-Ilib', '-d:nodb' ],
   progs => [ split "\n",
    'sub DB::DB {
      $DB::single = 0, return if $DB::single; print qq[ok\n]; exit
     }
     ${q(_<).__FILE__}{6} = 1; # set a breakpoint
     sub foo {
         die; # line 6
     }
     foo();
    '
   ],
   stderr => 1
  ),
  "ok\n",
  "setting breakpoints without *DB::dbline aliased"
);

# [perl #121255]
# Check that utf8 caches are flushed when $DB::sub is set
is(
  runperl(
   switches => [ '-Ilib', '-d:switchd_empty' ],
   progs => [ split "\n",
    'sub DB::sub{length($DB::sub); goto &$DB::sub}
     ${^UTF8CACHE}=-1;
     print
       eval qq|sub oo\x{25f} { 42 }
               sub ooooo\x{25f} { oo\x{25f}() }
               ooooo\x{25f}()| 
        || $@@,
       qq|\n|;
    '
   ],
   stderr => 1
  ),
  "42\n",
  'UTF8 length caches on $DB::sub are flushed'
);

# [perl #122771] -d conflicting with sort optimisations
is(
  runperl(
   switches => [ '-Ilib', '-d:switchd_empty' ],
   prog => 'BEGIN { $^P &= ~0x4 } sort { $$b <=> $$a } (); print qq-42\n-',
  ),
  "42\n",
  '-d does not conflict with sort optimisations'
);

SKIP: {
  skip_if_miniperl("under miniperl", 1);
is(
  runperl(
   switches => [ '-Ilib', '-d:switchd_empty' ],
   progs => [ split "\n",
    'use bignum;
     $DB::single=2;
     print qq/debugged\n/;
    '
   ],
   stderr => 1
  ),
  "debugged\n",
  "\$DB::single set to overload"
);
}

# [perl #123748]
#
# On some platforms, it's possible that calls to getenv() will
# return a pointer to statically allocated data that may be
# overwritten by subsequent calls to getenv/putenv/setenv/unsetenv.
#
# In perl.c, s = PerlEnv_GetEnv("PERL5OPT") is called, and
# then moreswitches(s), which, if -d:switchd_empty is given,
# will call my_setenv("PERL5DB", "use Devel::switchd_empty"),
# and then return to continue parsing s.
#
# This may need -Accflags="-DPERL_USE_SAFE_PUTENV" to fail on
# affected systems.
{
local $ENV{PERL5OPT} = '-d:switchd_empty';

like(
  runperl(
   switches => [ '-Ilib' ], prog => 'print q(hi)',
  ),
  qr/hi/,
 'putenv does not interfere with PERL5OPT parsing',
);
}
@


1.2
log
@Update to perl 5.20.3

OK bluhm@@
@
text
@d6 1
a8 2
BEGIN { require "./test.pl"; }

d11 1
a11 1
plan(tests => 20);
d288 18
d316 3
@


1.1
log
@Initial revision
@
text
@d8 1
a8 1
require "./test.pl";
d10 3
a12 1
plan(tests => 1);
a14 2
my @@tmpfiles = ();
END { unlink @@tmpfiles }
d16 1
a16 1
my $filename = 'swdtest.tmp';
a31 1
    push @@tmpfiles, $filename;
d34 17
a50 1
		 switches => [ '-Ilib', '-d:switchd' ],
d52 1
d54 158
a211 1
    like($r, qr/^main,swdtest.tmp,9;Foo,swdtest.tmp,5;Foo,swdtest.tmp,6;Foo,swdtest.tmp,6;Bar,swdtest.tmp,2;Bar,swdtest.tmp,2;Bar,swdtest.tmp,2;$/i);
d214 96
@


1.1.1.1
log
@perl 5.8.2 from CPAN
@
text
@@


1.1.1.2
log
@import perl 5.10.0 from CPAN
@
text
@d8 1
a8 1
BEGIN { require "./test.pl"; }
d10 1
a10 3
# This test depends on t/lib/Devel/switchd.pm.

plan(tests => 2);
d35 1
a35 7
		 switches => [ '-Ilib', '-f', '-d:switchd' ],
		 progfile => $filename,
		 args => ['3'],
		);
    like($r, qr/^sub<Devel::switchd::import>;import<Devel::switchd>;DB<main,swdtest.tmp,9>;sub<Foo::foo>;DB<Foo,swdtest.tmp,5>;DB<Foo,swdtest.tmp,6>;DB<Foo,swdtest.tmp,6>;sub<Bar::bar>;DB<Bar,swdtest.tmp,2>;sub<Bar::bar>;DB<Bar,swdtest.tmp,2>;sub<Bar::bar>;DB<Bar,swdtest.tmp,2>;$/);
    $r = runperl(
		 switches => [ '-Ilib', '-f', '-d:switchd=a,42' ],
a36 1
		 args => ['4'],
d38 1
a38 1
    like($r, qr/^sub<Devel::switchd::import>;import<Devel::switchd a 42>;DB<main,swdtest.tmp,9>;sub<Foo::foo>;DB<Foo,swdtest.tmp,5>;DB<Foo,swdtest.tmp,6>;DB<Foo,swdtest.tmp,6>;sub<Bar::bar>;DB<Bar,swdtest.tmp,2>;sub<Bar::bar>;DB<Bar,swdtest.tmp,2>;sub<Bar::bar>;DB<Bar,swdtest.tmp,2>;$/);
@


1.1.1.3
log
@import perl 5.10.1
@
text
@d15 2
d18 1
a18 1
my $filename = tempfile();
d34 1
d41 1
a41 1
    like($r, qr/^sub<Devel::switchd::import>;import<Devel::switchd>;DB<main,$::tempfile_regexp,9>;sub<Foo::foo>;DB<Foo,$::tempfile_regexp,5>;DB<Foo,$::tempfile_regexp,6>;DB<Foo,$::tempfile_regexp,6>;sub<Bar::bar>;DB<Bar,$::tempfile_regexp,2>;sub<Bar::bar>;DB<Bar,$::tempfile_regexp,2>;sub<Bar::bar>;DB<Bar,$::tempfile_regexp,2>;$/);
d47 1
a47 1
    like($r, qr/^sub<Devel::switchd::import>;import<Devel::switchd a 42>;DB<main,$::tempfile_regexp,9>;sub<Foo::foo>;DB<Foo,$::tempfile_regexp,5>;DB<Foo,$::tempfile_regexp,6>;DB<Foo,$::tempfile_regexp,6>;sub<Bar::bar>;DB<Bar,$::tempfile_regexp,2>;sub<Bar::bar>;DB<Bar,$::tempfile_regexp,2>;sub<Bar::bar>;DB<Bar,$::tempfile_regexp,2>;$/);
@


1.1.1.4
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d10 1
a10 1
# This test depends on t/lib/Devel/switchd*.pm.
d12 1
a12 1
plan(tests => 7);
d38 1
a38 1
    like($r, qr/^sub<Devel::switchd::import>;import<Devel::switchd>;DB<main,$::tempfile_regexp,9>;sub<Foo::foo>;DB<Foo,$::tempfile_regexp,5>;DB<Foo,$::tempfile_regexp,6>;sub<Bar::bar>;DB<Bar,$::tempfile_regexp,2>;sub<Bar::bar>;DB<Bar,$::tempfile_regexp,2>;sub<Bar::bar>;DB<Bar,$::tempfile_regexp,2>;$/);
d44 1
a44 7
    like($r, qr/^sub<Devel::switchd::import>;import<Devel::switchd a 42>;DB<main,$::tempfile_regexp,9>;sub<Foo::foo>;DB<Foo,$::tempfile_regexp,5>;DB<Foo,$::tempfile_regexp,6>;sub<Bar::bar>;DB<Bar,$::tempfile_regexp,2>;sub<Bar::bar>;DB<Bar,$::tempfile_regexp,2>;sub<Bar::bar>;DB<Bar,$::tempfile_regexp,2>;$/);
    $r = runperl(
		 switches => [ '-Ilib', '-f', '-d:-switchd=a,42' ],
		 progfile => $filename,
		 args => ['4'],
		);
    like($r, qr/^sub<Devel::switchd::unimport>;unimport<Devel::switchd a 42>;DB<main,$::tempfile_regexp,9>;sub<Foo::foo>;DB<Foo,$::tempfile_regexp,5>;DB<Foo,$::tempfile_regexp,6>;sub<Bar::bar>;DB<Bar,$::tempfile_regexp,2>;sub<Bar::bar>;DB<Bar,$::tempfile_regexp,2>;sub<Bar::bar>;DB<Bar,$::tempfile_regexp,2>;$/);
a46 60
# [perl #71806]
cmp_ok(
  runperl(       # less is useful for something :-)
   switches => [ '"-Mless ++INC->{q-Devel/_.pm-}"' ],
   progs    => [
    '#!perl -d:_',
    'sub DB::DB{} print scalar @@{q/_</.__FILE__}',
   ],
  ),
 '>',
  0,
 'The debugger can see the lines of the main program under #!perl -d',
);

# [perl #48332]
like(
  runperl(
   switches => [ '-Ilib', '-d:switchd_empty' ],
   progs    => [
    'sub foo { print qq _1\n_ }',
    '*old_foo = \&foo;',
    '*foo = sub { print qq _2\n_ };',
    'old_foo(); foo();',
   ],
  ),
  qr "1\r?\n2\r?\n",
 'Subroutine redefinition works in the debugger [perl #48332]',
);

# [rt.cpan.org #69862]
like(
  runperl(
   switches => [ '-Ilib', '-d:switchd_empty' ],
   progs    => [
    'sub DB::sub { goto &$DB::sub }',
    'sub foo { print qq _1\n_ }',
    'sub bar { print qq _2\n_ }',
    'delete $::{foo}; eval { foo() };',
    'my $bar = *bar; undef *bar; eval { &$bar };',
   ],
  ),
  qr "1\r?\n2\r?\n",
 'Subroutines no longer found under their names can be called',
);

# [rt.cpan.org #69862]
like(
  runperl(
   switches => [ '-Ilib', '-d:switchd_empty' ],
   progs    => [
    'sub DB::sub { goto &$DB::sub }',
    'sub foo { goto &bar::baz; }',
    'sub bar::baz { print qq _ok\n_ }',
    'delete $::{bar::::};',
    'foo();',
   ],
  ),
  qr "ok\r?\n",
 'No crash when calling orphaned subroutine via goto &',
);
@


1.1.1.5
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d12 1
a12 1
plan(tests => 10);
d38 1
a38 3
    like($r,
qr/^sub<Devel::switchd::import>;import<Devel::switchd>;DB<main,$::tempfile_regexp,9>;sub<Foo::foo>;DB<Foo,$::tempfile_regexp,5>;DB<Foo,$::tempfile_regexp,6>;sub<Bar::bar>;DB<Bar,$::tempfile_regexp,2>;sub<Bar::bar>;DB<Bar,$::tempfile_regexp,2>;sub<Bar::bar>;DB<Bar,$::tempfile_regexp,2>;$/,
    'Got debugging output: 1');
d44 1
a44 3
    like($r,
qr/^sub<Devel::switchd::import>;import<Devel::switchd a 42>;DB<main,$::tempfile_regexp,9>;sub<Foo::foo>;DB<Foo,$::tempfile_regexp,5>;DB<Foo,$::tempfile_regexp,6>;sub<Bar::bar>;DB<Bar,$::tempfile_regexp,2>;sub<Bar::bar>;DB<Bar,$::tempfile_regexp,2>;sub<Bar::bar>;DB<Bar,$::tempfile_regexp,2>;$/,
    'Got debugging output: 2');
d50 1
a50 3
    like($r,
qr/^sub<Devel::switchd::unimport>;unimport<Devel::switchd a 42>;DB<main,$::tempfile_regexp,9>;sub<Foo::foo>;DB<Foo,$::tempfile_regexp,5>;DB<Foo,$::tempfile_regexp,6>;sub<Bar::bar>;DB<Bar,$::tempfile_regexp,2>;sub<Bar::bar>;DB<Bar,$::tempfile_regexp,2>;sub<Bar::bar>;DB<Bar,$::tempfile_regexp,2>;$/,
    'Got debugging output: 3');
a111 47
);

# test when DB::DB is seen but not defined [perl #114990]
like(
  runperl(
    switches => [ '-Ilib', '-d:nodb' ],
    prog     => [ '1' ],
    stderr   => 1,
  ),
  qr/^No DB::DB routine defined/,
  "No crash when *DB::DB exists but not &DB::DB",
);
like(
  runperl(
    switches => [ '-Ilib' ],
    prog     => 'sub DB::DB; BEGIN { $^P = 0x22; } for(0..9){ warn }',
    stderr   => 1,
  ),
  qr/^No DB::DB routine defined/,
  "No crash when &DB::DB exists but isn't actually defined",
);

# [perl #115742] Recursive DB::DB clobbering its own pad
like(
  runperl(
    switches => [ '-Ilib' ],
    progs    => [ split "\n", <<'='
     BEGIN {
      $^P = 0x22;
     }
     package DB;
     sub DB {
      my $x = 42;
      return if $__++;
      $^D |= 1 << 30; # allow recursive calls
      main::foo();
      print $x//q-u-, qq-\n-;
     }
     package main;
     chop;
     sub foo { chop; }
=
    ],
    stderr   => 1,
  ),
  qr/42/,
  "Recursive DB::DB does not clobber its own pad",
@


1.1.1.6
log
@Import perl-5.20.1
@
text
@d12 1
a12 1
plan(tests => 18);
a72 11
like
  runperl(
   switches => [ '"-Mless ++INC->{q-Devel/_.pm-}"' ],
   progs    => [
    '#!perl -d:_',
    'sub DB::DB{} print line=>__LINE__',
   ],
  ),
  qr/line2/,
 '#!perl -d:whatever does not throw line numbers off';

a138 10
# or seen and defined later
is(
  runperl(
    switches => [ '-Ilib', '-d:nodb' ], # nodb.pm contains *DB::DB...if 0
    prog     => 'warn; sub DB::DB { print qq-ok\n-; exit }',
    stderr   => 1,
  ),
  "ok\n",
  "DB::DB works after '*DB::DB if 0'",
);
a164 91
);

# [perl #118627]
like(
  runperl(
   switches => [ '-Ilib', '-d:switchd_empty' ],
   prog     => 'print @@{q|_<-e|}',
  ),
  qr "use Devel::switchd_empty;(?:BEGIN|\r?\nprint)",
                         # miniperl tacks a BEGIN block on to the same line
 'Copy on write does not mangle ${"_<-e"}[0] [perl #118627]',
);

# PERL5DB with embedded newlines
{
    local $ENV{PERL5DB} = "sub DB::DB{}\nwarn";
    is(
      runperl(
       switches => [ '-Ilib', '-ld' ],
       prog     => 'warn',
       stderr   => 1
      ),
      "Warning: something's wrong.\n"
     ."Warning: something's wrong at -e line 1.\n",
     'PERL5DB with embedded newlines',
    );
}

# test that DB::goto works
is(
  runperl(
   switches => [ '-Ilib', '-d:switchd_goto' ],
   prog => 'sub baz { print qq|hello;\n| } sub foo { goto &baz } foo()',
   stderr => 1,
  ),
  "goto<main::baz>;hello;\n",
  "DB::goto"
);

# Test that %DB::lsub is not vivified
is(
  runperl(
   switches => [ '-Ilib', '-d:switchd_empty' ],
   progs => ['sub DB::sub {} sub foo : lvalue {} foo();',
             'print qq-ok\n- unless defined *DB::lsub{HASH}'],
  ),
  "ok\n",
  "%DB::lsub is not vivified"
);

# Test setting of breakpoints without *DB::dbline aliased
is(
  runperl(
   switches => [ '-Ilib', '-d:nodb' ],
   progs => [ split "\n",
    'sub DB::DB {
      $DB::single = 0, return if $DB::single; print qq[ok\n]; exit
     }
     ${q(_<).__FILE__}{6} = 1; # set a breakpoint
     sub foo {
         die; # line 6
     }
     foo();
    '
   ],
   stderr => 1
  ),
  "ok\n",
  "setting breakpoints without *DB::dbline aliased"
);

# [perl #121255]
# Check that utf8 caches are flushed when $DB::sub is set
is(
  runperl(
   switches => [ '-Ilib', '-d:switchd_empty' ],
   progs => [ split "\n",
    'sub DB::sub{length($DB::sub); goto &$DB::sub}
     ${^UTF8CACHE}=-1;
     print
       eval qq|sub oo\x{25f} { 42 }
               sub ooooo\x{25f} { oo\x{25f}() }
               ooooo\x{25f}()| 
        || $@@,
       qq|\n|;
    '
   ],
   stderr => 1
  ),
  "42\n",
  'UTF8 length caches on $DB::sub are flushed'
@


1.1.1.7
log
@Import perl-5.20.2
@
text
@d12 1
a12 1
plan(tests => 19);
a276 10
);

# [perl #122771] -d conflicting with sort optimisations
is(
  runperl(
   switches => [ '-Ilib', '-d:switchd_empty' ],
   prog => 'BEGIN { $^P &= ~0x4 } sort { $$b <=> $$a } (); print qq-42\n-',
  ),
  "42\n",
  '-d does not conflict with sort optimisations'
@


