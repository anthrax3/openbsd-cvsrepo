head	1.3;
access;
symbols
	OPENBSD_6_0:1.2.0.4
	OPENBSD_6_0_BASE:1.2
	OPENBSD_5_9:1.1.1.8.0.4
	OPENBSD_5_9_BASE:1.1.1.8
	OPENBSD_5_8:1.1.1.8.0.6
	OPENBSD_5_8_BASE:1.1.1.8
	PERL_5_20_2:1.1.1.8
	OPENBSD_5_7:1.1.1.8.0.2
	OPENBSD_5_7_BASE:1.1.1.8
	PERL_5_20_1:1.1.1.8
	OPENBSD_5_6:1.1.1.7.0.8
	OPENBSD_5_6_BASE:1.1.1.7
	PERL_5_18_2:1.1.1.7
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.7.0.6
	OPENBSD_5_5_BASE:1.1.1.7
	OPENBSD_5_4:1.1.1.7.0.2
	OPENBSD_5_4_BASE:1.1.1.7
	PERL_5_16_3:1.1.1.7
	OPENBSD_5_3:1.1.1.6.0.14
	OPENBSD_5_3_BASE:1.1.1.6
	OPENBSD_5_2:1.1.1.6.0.12
	OPENBSD_5_2_BASE:1.1.1.6
	OPENBSD_5_1_BASE:1.1.1.6
	OPENBSD_5_1:1.1.1.6.0.10
	OPENBSD_5_0:1.1.1.6.0.8
	OPENBSD_5_0_BASE:1.1.1.6
	OPENBSD_4_9:1.1.1.6.0.6
	OPENBSD_4_9_BASE:1.1.1.6
	PERL_5_12_2:1.1.1.6
	OPENBSD_4_8:1.1.1.6.0.4
	OPENBSD_4_8_BASE:1.1.1.6
	OPENBSD_4_7:1.1.1.6.0.2
	OPENBSD_4_7_BASE:1.1.1.6
	PERL_5_10_1:1.1.1.6
	OPENBSD_4_6:1.1.1.5.0.6
	OPENBSD_4_6_BASE:1.1.1.5
	OPENBSD_4_5:1.1.1.5.0.2
	OPENBSD_4_5_BASE:1.1.1.5
	PERL_5_10_0:1.1.1.5
	OPENBSD_4_4:1.1.1.4.0.24
	OPENBSD_4_4_BASE:1.1.1.4
	OPENBSD_4_3:1.1.1.4.0.22
	OPENBSD_4_3_BASE:1.1.1.4
	OPENBSD_4_2:1.1.1.4.0.20
	OPENBSD_4_2_BASE:1.1.1.4
	OPENBSD_4_1:1.1.1.4.0.18
	OPENBSD_4_1_BASE:1.1.1.4
	OPENBSD_4_0:1.1.1.4.0.16
	OPENBSD_4_0_BASE:1.1.1.4
	PERL_5_8_8:1.1.1.4
	OPENBSD_3_9:1.1.1.4.0.14
	OPENBSD_3_9_BASE:1.1.1.4
	OPENBSD_3_8:1.1.1.4.0.12
	OPENBSD_3_8_BASE:1.1.1.4
	OPENBSD_3_7:1.1.1.4.0.10
	OPENBSD_3_7_BASE:1.1.1.4
	PERL_5_8_6:1.1.1.4
	OPENBSD_3_6:1.1.1.4.0.8
	OPENBSD_3_6_BASE:1.1.1.4
	PERL_5_8_5:1.1.1.4
	PERL_5_8_3:1.1.1.4
	OPENBSD_3_5:1.1.1.4.0.6
	OPENBSD_3_5_BASE:1.1.1.4
	PERL_5_8_2:1.1.1.4
	OPENBSD_3_4:1.1.1.4.0.4
	OPENBSD_3_4_BASE:1.1.1.4
	OPENBSD_3_3:1.1.1.4.0.2
	OPENBSD_3_3_BASE:1.1.1.4
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.1.1.3.0.6
	OPENBSD_3_2_BASE:1.1.1.3
	OPENBSD_3_1:1.1.1.3.0.4
	OPENBSD_3_1_BASE:1.1.1.3
	OPENBSD_3_0:1.1.1.3.0.2
	OPENBSD_3_0_BASE:1.1.1.3
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.1.1.2.0.6
	OPENBSD_2_9_BASE:1.1.1.2
	OPENBSD_2_8:1.1.1.2.0.4
	OPENBSD_2_8_BASE:1.1.1.2
	OPENBSD_2_7:1.1.1.2.0.2
	OPENBSD_2_7_BASE:1.1.1.2
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.1.1.1.0.2
	OPENBSD_2_6_BASE:1.1.1.1
	PERL_500503:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.3
date	2017.02.05.00.32.19;	author afresh1;	state Exp;
branches;
next	1.2;
commitid	cxJ08BvJA9Pt2PTM;

1.2
date	2016.07.03.01.08.04;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	GzHqjSTnBjdF7Wcw;

1.1
date	99.04.29.22.41.14;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.29.22.41.14;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.04.06.16.10.37;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.05.24.18.25.01;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.27.22.15.09;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2008.09.29.17.18.58;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2009.10.12.18.10.42;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2013.03.25.20.09.32;	author sthen;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2014.11.17.20.53.16;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.3
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl
# Test $/

print "1..39\n";

$test_count = 1;
$teststring = "1\n12\n123\n1234\n1234\n12345\n\n123456\n1234567\n";
$teststring2 = "1234567890123456789012345678901234567890";

# Create our test datafile
1 while unlink 'foo';                # in case junk left around
rmdir 'foo';
open TESTFILE, ">./foo" or die "error $! $^E opening";
binmode TESTFILE;
print TESTFILE $teststring;
close TESTFILE or die "error $! $^E closing";

$test_count_start = $test_count;  # Needed to know how many tests to skip
open TESTFILE, "<./foo";
binmode TESTFILE;
test_string(*TESTFILE);
close TESTFILE;
unlink "./foo";

# try the record reading tests. New file so we don't have to worry about
# the size of \n.
open TESTFILE, ">./foo";
print TESTFILE $teststring2;
binmode TESTFILE;
close TESTFILE;
open TESTFILE, "<./foo";
binmode TESTFILE;
test_record(*TESTFILE);
close TESTFILE;
$test_count_end = $test_count;  # Needed to know how many tests to skip

$/ = "\n";
my $note = "\$/ preserved when set to bad value";
# none of the setting of $/ to bad values should modify its value
test_bad_setting();
print +($/ ne "\n" ? "not " : "") .
  "ok $test_count # \$/ preserved when set to bad value\n";
++$test_count;

# Now for the tricky bit--full record reading
if ($^O eq 'VMS') {
  # Create a temp file. We jump through these hoops 'cause CREATE really
  # doesn't like our methods for some reason.
  open FDLFILE, "> ./foo.fdl";
  print FDLFILE "RECORD\n FORMAT VARIABLE\n";
  close FDLFILE;
  open CREATEFILE, "> ./foo.com";
  print CREATEFILE '$ DEFINE/USER SYS$INPUT NL:', "\n";
  print CREATEFILE '$ DEFINE/USER SYS$OUTPUT NL:', "\n";
  print CREATEFILE '$ OPEN YOW []FOO.BAR/WRITE', "\n";
  print CREATEFILE '$ CLOSE YOW', "\n";
  print CREATEFILE "\$EXIT\n";
  close CREATEFILE;
  $throwaway = `\@@\[\]foo`, "\n";
  open(TEMPFILE, ">./foo.bar") or print "# open failed $! $^E\n";
  print TEMPFILE "foo\nfoobar\nbaz\n";
  close TEMPFILE;

  open TESTFILE, "<./foo.bar";
  $/ = \10;
  $bar = <TESTFILE>;
  if ($bar eq "foo\n") {print "ok $test_count\n";} else {print "not ok $test_count\n";}
  $test_count++;
  $bar = <TESTFILE>;
  if ($bar eq "foobar\n") {print "ok $test_count\n";} else {print "not ok $test_count\n";}
  $test_count++;
  # can we do a short read?
  $/ = \2;
  $bar = <TESTFILE>;
  if ($bar eq "ba") {print "ok $test_count\n";} else {print "not ok $test_count\n";}
  $test_count++;
  # do we get the rest of the record?
  $bar = <TESTFILE>;
  if ($bar eq "z\n") {print "ok $test_count\n";} else {print "not ok $test_count\n";}
  $test_count++;

  close TESTFILE;
  1 while unlink qw(foo.bar foo.com foo.fdl);
} else {
  # Nobody else does this at the moment (well, maybe OS/390, but they can
  # put their own tests in) so we just punt
  foreach $test ($test_count..$test_count + 3) {
      print "ok $test # skipped on non-VMS system\n";
      $test_count++;
  }
}

$/ = "\n";

# see if open/readline/close work on our and my variables
{
    if (open our $T, "./foo") {
        my $line = <$T>;
	print "# $line\n";
	length($line) == 40 or print "not ";
        close $T or print "not ";
    }
    else {
	print "not ";
    }
    print "ok $test_count # open/readline/close on our variable\n";
    $test_count++;
}

{
    if (open my $T, "./foo") {
        my $line = <$T>;
	print "# $line\n";
	length($line) == 40 or print "not ";
        close $T or print "not ";
    }
    else {
	print "not ";
    }
    print "ok $test_count # open/readline/close on my variable\n";
    $test_count++;
}


{
 # If we do not include the lib directories, we may end up picking up a
 # binary-incompatible previously-installed version. The eval wonâ€™t help in
 # intercepting a SIGTRAP.
 local @@INC = ("../lib", "lib", @@INC);
 if (not eval q/use PerlIO::scalar; 1/) {
  # In-memory files necessitate PerlIO::scalar, thus a perl with
  # perlio and dynaloading enabled. miniperl won't be able to run this
  # test, so skip it

  for $test ($test_count .. $test_count + ($test_count_end - $test_count_start - 1)) {
    print "ok $test # skipped - Can't test in memory file with miniperl/without PerlIO::Scalar\n";
    $test_count++;
  }
 }
 else {
  # Test if a file in memory behaves the same as a real file (= re-run the test with a file in memory)
  open TESTFILE, "<", \$teststring;
  test_string(*TESTFILE);
  close TESTFILE;

  open TESTFILE, "<", \$teststring2;
  test_record(*TESTFILE);
  close TESTFILE;
 }
}

# Get rid of the temp file
END { unlink "./foo"; }

sub test_string {
  *FH = shift;

  # Check the default $/
  $bar = <FH>;
  if ($bar ne "1\n") {print "not ";}
  print "ok $test_count # default \$/\n";
  $test_count++;

  # explicitly set to \n
  $/ = "\n";
  $bar = <FH>;
  if ($bar ne "12\n") {print "not ";}
  print "ok $test_count # \$/ = \"\\n\"\n";
  $test_count++;

  # Try a non line terminator
  $/ = 3;
  $bar = <FH>;
  if ($bar ne "123") {print "not ";}
  print "ok $test_count # \$/ = 3\n";
  $test_count++;

  # Eat the line terminator
  $/ = "\n";
  $bar = <FH>;

  # How about a larger terminator
  $/ = "34";
  $bar = <FH>;
  if ($bar ne "1234") {print "not ";}
  print "ok $test_count # \$/ = \"34\"\n";
  $test_count++;

  # Eat the line terminator
  $/ = "\n";
  $bar = <FH>;

  # Does paragraph mode work?
  $/ = '';
  $bar = <FH>;
  if ($bar ne "1234\n12345\n\n") {print "not ";}
  print "ok $test_count # \$/ = ''\n";
  $test_count++;

  # Try slurping the rest of the file
  $/ = undef;
  $bar = <FH>;
  if ($bar ne "123456\n1234567\n") {print "not ";}
  print "ok $test_count # \$/ = undef\n";
  $test_count++;
}

sub test_record {
  *FH = shift;

  # Test straight number
  $/ = \2;
  $bar = <FH>;
  if ($bar ne "12") {print "not ";}
  print "ok $test_count # \$/ = \\2\n";
  $test_count++;

  # Test stringified number
  $/ = \"2";
  $bar = <FH>;
  if ($bar ne "34") {print "not ";}
  print "ok $test_count # \$/ = \"2\"\n";
  $test_count++;

  # Integer variable
  $foo = 2;
  $/ = \$foo;
  $bar = <FH>;
  if ($bar ne "56") {print "not ";}
  print "ok $test_count # \$/ = \\\$foo (\$foo = 2)\n";
  $test_count++;

  # String variable
  $foo = "2";
  $/ = \$foo;
  $bar = <FH>;
  if ($bar ne "78") {print "not ";}
  print "ok $test_count # \$/ = \\\$foo (\$foo = \"2\")\n";
  $test_count++;

  # Naughty straight number - should get the rest of the file
  # no warnings 'deprecated'; # but not in t/base/*
  { local $SIG{__WARN__} = sub {}; $/ = \0 }
  $bar = <FH>;
  if ($bar ne "90123456789012345678901234567890") {print "not ";}
  print "ok $test_count # \$/ = \\0\n";
  $test_count++;
}

sub test_bad_setting {
  if (eval {$/ = []; 1}) {
    print "not ok ",$test_count++," # \$/ = []; should die\n";
    print "not ok ",$test_count++," # \$/ = []; produced expected error message\n";
  } else {
    my $msg= $@@ || "Zombie Error";
    print "ok ",$test_count++," # \$/ = []; should die\n";
    if ($msg!~m!Setting \$\/ to an ARRAY reference is forbidden!) {
      print "not ";
    }
    print "ok ",$test_count++," # \$/ = []; produced expected error message\n";
  }
  if (eval {$/ = {}; 1}) {
    print "not ok ",$test_count++," # \$/ = {}; should die\n";
    print "not ok ",$test_count++," # \$/ = {}; produced expected error message\n";
  } else {
    my $msg= $@@ || "Zombie Error";
    print "ok ",$test_count++," # \$/ = {}; should die\n";
    if ($msg!~m!Setting \$\/ to a HASH reference is forbidden!) {print "not ";}
    print "ok ",$test_count++," # \$/ = {}; produced expected error message\n";
  }
  if (eval {$/ = \\1; 1}) {
    print "not ok ",$test_count++," # \$/ = \\\\1; should die\n";
    print "not ok ",$test_count++," # \$/ = \\\\1; produced expected error message\n";
  } else {
    my $msg= $@@ || "Zombie Error";
    print "ok ",$test_count++," # \$/ = \\\\1; should die\n";
    if ($msg!~m!Setting \$\/ to a REF reference is forbidden!) {print "not ";}
    print "ok ",$test_count++," # \$/ = \\\\1; produced expected error message\n";
  }
  if (eval {$/ = qr/foo/; 1}) {
    print "not ok ",$test_count++," # \$/ = qr/foo/; should die\n";
    print "not ok ",$test_count++," # \$/ = qr/foo/; produced expected error message\n";
  } else {
    my $msg= $@@ || "Zombie Error";
    print "ok ",$test_count++," # \$/ = qr/foo/; should die\n";
    if ($msg!~m!Setting \$\/ to a REGEXP reference is forbidden!) {print "not ";}
    print "ok ",$test_count++," # \$/ = qr/foo/; produced expected error message\n";
  }
  if (eval {$/ = \*STDOUT; 1}) {
    print "not ok ",$test_count++," # \$/ = \\*STDOUT; should die\n";
    print "not ok ",$test_count++," # \$/ = \\*STDOUT; produced expected error message\n";
  } else {
    my $msg= $@@ || "Zombie Error";
    print "ok ",$test_count++," # \$/ = \\*STDOUT; should die\n";
    if ($msg!~m!Setting \$\/ to a GLOB reference is forbidden!) {print "not ";}
    print "ok ",$test_count++," # \$/ = \\*STDOUT; produced expected error message\n";
  }
}
@


1.2
log
@Update to perl 5.20.3

OK bluhm@@
@
text
@d130 2
a131 2
 if (not eval q/use PerlIO::scalar; use PerlIO::via::scalar; 1/) {
  # In-memory files necessitate PerlIO::via::scalar, thus a perl with
a134 3
  # PerlIO::via::scalar has to be tested as well.
  # use PerlIO::scalar succeeds with ./TEST and with ./perl harness but not with ./perl

d242 2
a243 1
  $/ = \0;
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
# Test $!
d4 1
a4 1
print "1..14\n";
d6 1
d8 1
d11 2
d16 1
a16 1
close TESTFILE;
d18 1
d21 3
a23 37

# Check the default $/
$bar = <TESTFILE>;
if ($bar eq "1\n") {print "ok 1\n";} else {print "not ok 1\n";}

# explicitly set to \n
$/ = "\n";
$bar = <TESTFILE>;
if ($bar eq "12\n") {print "ok 2\n";} else {print "not ok 2\n";}

# Try a non line terminator
$/ = "3";
$bar = <TESTFILE>;
if ($bar eq "123") {print "ok 3\n";} else {print "not ok 3\n";}

# Eat the line terminator
$/ = "\n";
$bar = <TESTFILE>;

# How about a larger terminator
$/ = "34";
$bar = <TESTFILE>;
if ($bar eq "1234") {print "ok 4\n";} else {print "not ok 4\n";}

# Eat the line terminator
$/ = "\n";
$bar = <TESTFILE>;

# Does paragraph mode work?
$/ = '';
$bar = <TESTFILE>;
if ($bar eq "1234\n12345\n\n") {print "ok 5\n";} else {print "not ok 5\n";}

# Try slurping the rest of the file
$/ = undef;
$bar = <TESTFILE>;
if ($bar eq "123456\n1234567\n") {print "ok 6\n";} else {print "not ok 6\n";}
a26 2
close TESTFILE;
unlink "./foo";
d28 1
a28 1
print TESTFILE "1234567890123456789012345678901234567890";
d33 3
d37 7
a43 25
# Test straight number
$/ = \2;
$bar = <TESTFILE>;
if ($bar eq "12") {print "ok 7\n";} else {print "not ok 7\n";}

# Test stringified number
$/ = \"2";
$bar = <TESTFILE>;
if ($bar eq "34") {print "ok 8\n";} else {print "not ok 8\n";}

# Integer variable
$foo = 2;
$/ = \$foo;
$bar = <TESTFILE>;
if ($bar eq "56") {print "ok 9\n";} else {print "not ok 9\n";}

# String variable
$foo = "2";
$/ = \$foo;
$bar = <TESTFILE>;
if ($bar eq "78") {print "ok 10\n";} else {print "not ok 10\n";}

# Get rid of the temp file
close TESTFILE;
unlink "./foo";
d67 2
a68 1
  if ($bar eq "foo\n") {print "ok 11\n";} else {print "not ok 11\n";}
d70 2
a71 1
  if ($bar eq "foobar\n") {print "ok 12\n";} else {print "not ok 12\n";}
d75 2
a76 1
  if ($bar eq "ba") {print "ok 13\n";} else {print "not ok 13\n";}
d79 2
a80 1
  if ($bar eq "z\n") {print "ok 14\n";} else {print "not ok 14\n";}
d83 1
a83 2
  unlink "./foo.bar";
  unlink "./foo.com";  
d87 213
a299 1
  foreach $test (11..14) {print "ok $test # skipped on non-VMS system\n"};
@


1.1.1.1
log
@perl5.005_03
@
text
@@


1.1.1.2
log
@virgin perl 5.6.0
@
text
@d27 1
a27 1
$/ = 3;
d125 2
a126 1
  1 while unlink qw(foo.bar foo.com foo.fdl);
@


1.1.1.3
log
@stock perl 5.6.1
@
text
@a8 2
1 while unlink 'foo';                # in case junk left around
rmdir 'foo';
@


1.1.1.4
log
@stock perl 5.8.0 from CPAN
@
text
@d4 1
a4 1
print "1..16\n";
d14 1
a14 1
close TESTFILE or die "error $! $^E closing";
d89 1
d91 1
a132 32

$/ = "\n";

# see if open/readline/close work on our and my variables
{
    if (open our $T, "./foo") {
        my $line = <$T>;
	print "# $line\n";
	length($line) == 40 or print "not ";
        close $T or print "not ";
    }
    else {
	print "not ";
    }
    print "ok 15\n";
}

{
    if (open my $T, "./foo") {
        my $line = <$T>;
	print "# $line\n";
	length($line) == 40 or print "not ";
        close $T or print "not ";
    }
    else {
	print "not ";
    }
    print "ok 16\n";
}

# Get rid of the temp file
END { unlink "./foo"; }
@


1.1.1.5
log
@import perl 5.10.0 from CPAN
@
text
@d4 1
a4 1
print "1..17\n";
a88 5
# Naughty straight number - should get the rest of the file
$/ = \0;
$bar = <TESTFILE>;
if ($bar eq "90123456789012345678901234567890") {print "ok 11\n";} else {print "not ok 11\n";}

d113 1
a113 1
  if ($bar eq "foo\n") {print "ok 12\n";} else {print "not ok 12\n";}
d115 1
a115 1
  if ($bar eq "foobar\n") {print "ok 13\n";} else {print "not ok 13\n";}
d119 1
a119 1
  if ($bar eq "ba") {print "ok 14\n";} else {print "not ok 14\n";}
d122 1
a122 1
  if ($bar eq "z\n") {print "ok 15\n";} else {print "not ok 15\n";}
d129 1
a129 1
  foreach $test (12..15) {print "ok $test # skipped on non-VMS system\n"};
d145 1
a145 1
    print "ok 16\n";
d158 1
a158 1
    print "ok 17\n";
@


1.1.1.6
log
@import perl 5.10.1
@
text
@d4 1
a4 1
print "1..28\n";
a5 1
$test_count = 1;
a6 1
$teststring2 = "1234567890123456789012345678901234567890";
a15 1
$test_count_start = $test_count;  # Needed to know how many tests to skip
d18 37
a54 3
test_string(*TESTFILE);
close TESTFILE;
unlink "./foo";
d58 2
d61 1
a61 1
print TESTFILE $teststring2;
d66 28
a93 1
test_record(*TESTFILE);
a94 2
$test_count_end = $test_count;  # Needed to know how many tests to skip

d118 1
a118 2
  if ($bar eq "foo\n") {print "ok $test_count\n";} else {print "not ok $test_count\n";}
  $test_count++;
d120 1
a120 2
  if ($bar eq "foobar\n") {print "ok $test_count\n";} else {print "not ok $test_count\n";}
  $test_count++;
d124 1
a124 2
  if ($bar eq "ba") {print "ok $test_count\n";} else {print "not ok $test_count\n";}
  $test_count++;
d127 1
a127 2
  if ($bar eq "z\n") {print "ok $test_count\n";} else {print "not ok $test_count\n";}
  $test_count++;
d134 1
a134 4
  foreach $test ($test_count..$test_count + 3) {
      print "ok $test # skipped on non-VMS system\n";
      $test_count++;
  }
d150 1
a150 2
    print "ok $test_count # open/readline/close on our variable\n";
    $test_count++;
d163 1
a163 27
    print "ok $test_count # open/readline/close on my variable\n";
    $test_count++;
}


if (not eval q/use PerlIO::scalar; use PerlIO::via::scalar; 1/) {
  # In-memory files necessitate PerlIO::via::scalar, thus a perl with
  # perlio and dynaloading enabled. miniperl won't be able to run this
  # test, so skip it

  # PerlIO::via::scalar has to be tested as well.
  # use PerlIO::scalar succeeds with ./TEST and with ./perl harness but not with ./perl

  for $test ($test_count .. $test_count + ($test_count_end - $test_count_start - 1)) {
    print "ok $test # skipped - Can't test in memory file with miniperl/without PerlIO::Scalar\n";
    $test_count++;
  }
}
else {
  # Test if a file in memory behaves the same as a real file (= re-run the test with a file in memory)
  open TESTFILE, "<", \$teststring;
  test_string(*TESTFILE);
  close TESTFILE;

  open TESTFILE, "<", \$teststring2;
  test_record(*TESTFILE);
  close TESTFILE;
a167 95

sub test_string {
  *FH = shift;

  # Check the default $/
  $bar = <FH>;
  if ($bar ne "1\n") {print "not ";}
  print "ok $test_count # default \$/\n";
  $test_count++;

  # explicitly set to \n
  $/ = "\n";
  $bar = <FH>;
  if ($bar ne "12\n") {print "not ";}
  print "ok $test_count # \$/ = \"\\n\"\n";
  $test_count++;

  # Try a non line terminator
  $/ = 3;
  $bar = <FH>;
  if ($bar ne "123") {print "not ";}
  print "ok $test_count # \$/ = 3\n";
  $test_count++;

  # Eat the line terminator
  $/ = "\n";
  $bar = <FH>;

  # How about a larger terminator
  $/ = "34";
  $bar = <FH>;
  if ($bar ne "1234") {print "not ";}
  print "ok $test_count # \$/ = \"34\"\n";
  $test_count++;

  # Eat the line terminator
  $/ = "\n";
  $bar = <FH>;

  # Does paragraph mode work?
  $/ = '';
  $bar = <FH>;
  if ($bar ne "1234\n12345\n\n") {print "not ";}
  print "ok $test_count # \$/ = ''\n";
  $test_count++;

  # Try slurping the rest of the file
  $/ = undef;
  $bar = <FH>;
  if ($bar ne "123456\n1234567\n") {print "not ";}
  print "ok $test_count # \$/ = undef\n";
  $test_count++;
}

sub test_record {
  *FH = shift;

  # Test straight number
  $/ = \2;
  $bar = <FH>;
  if ($bar ne "12") {print "not ";}
  print "ok $test_count # \$/ = \\2\n";
  $test_count++;

  # Test stringified number
  $/ = \"2";
  $bar = <FH>;
  if ($bar ne "34") {print "not ";}
  print "ok $test_count # \$/ = \"2\"\n";
  $test_count++;

  # Integer variable
  $foo = 2;
  $/ = \$foo;
  $bar = <FH>;
  if ($bar ne "56") {print "not ";}
  print "ok $test_count # \$/ = \\\$foo (\$foo = 2)\n";
  $test_count++;

  # String variable
  $foo = "2";
  $/ = \$foo;
  $bar = <FH>;
  if ($bar ne "78") {print "not ";}
  print "ok $test_count # \$/ = \\\$foo (\$foo = \"2\")\n";
  $test_count++;

  # Naughty straight number - should get the rest of the file
  $/ = \0;
  $bar = <FH>;
  if ($bar ne "90123456789012345678901234567890") {print "not ";}
  print "ok $test_count # \$/ = \\0\n";
  $test_count++;
}

@


1.1.1.7
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d118 1
a118 6
{
 # If we do not include the lib directories, we may end up picking up a
 # binary-incompatible previously-installed version. The eval wonâ€™t help in
 # intercepting a SIGTRAP.
 local @@INC = ("../lib", "lib", @@INC);
 if (not eval q/use PerlIO::scalar; use PerlIO::via::scalar; 1/) {
d130 2
a131 2
 }
 else {
a139 1
 }
@


1.1.1.8
log
@Import perl-5.20.1
@
text
@d4 1
a4 1
print "1..48\n";
a34 1
test_bad_setting();
a244 49
sub test_bad_setting {
  if (eval {$/ = []; 1}) {
    print "not ok ",$test_count++," # \$/ = []; should die\n";
    print "not ok ",$test_count++," # \$/ = []; produced expected error message\n";
  } else {
    my $msg= $@@ || "Zombie Error";
    print "ok ",$test_count++," # \$/ = []; should die\n";
    if ($msg!~m!Setting \$\/ to an ARRAY reference is forbidden!) {
      print "not ";
    }
    print "ok ",$test_count++," # \$/ = []; produced expected error message\n";
  }
  if (eval {$/ = {}; 1}) {
    print "not ok ",$test_count++," # \$/ = {}; should die\n";
    print "not ok ",$test_count++," # \$/ = {}; produced expected error message\n";
  } else {
    my $msg= $@@ || "Zombie Error";
    print "ok ",$test_count++," # \$/ = {}; should die\n";
    if ($msg!~m!Setting \$\/ to a HASH reference is forbidden!) {print "not ";}
    print "ok ",$test_count++," # \$/ = {}; produced expected error message\n";
  }
  if (eval {$/ = \\1; 1}) {
    print "not ok ",$test_count++," # \$/ = \\\\1; should die\n";
    print "not ok ",$test_count++," # \$/ = \\\\1; produced expected error message\n";
  } else {
    my $msg= $@@ || "Zombie Error";
    print "ok ",$test_count++," # \$/ = \\\\1; should die\n";
    if ($msg!~m!Setting \$\/ to a REF reference is forbidden!) {print "not ";}
    print "ok ",$test_count++," # \$/ = \\\\1; produced expected error message\n";
  }
  if (eval {$/ = qr/foo/; 1}) {
    print "not ok ",$test_count++," # \$/ = qr/foo/; should die\n";
    print "not ok ",$test_count++," # \$/ = qr/foo/; produced expected error message\n";
  } else {
    my $msg= $@@ || "Zombie Error";
    print "ok ",$test_count++," # \$/ = qr/foo/; should die\n";
    if ($msg!~m!Setting \$\/ to a REGEXP reference is forbidden!) {print "not ";}
    print "ok ",$test_count++," # \$/ = qr/foo/; produced expected error message\n";
  }
  if (eval {$/ = \*STDOUT; 1}) {
    print "not ok ",$test_count++," # \$/ = \\*STDOUT; should die\n";
    print "not ok ",$test_count++," # \$/ = \\*STDOUT; produced expected error message\n";
  } else {
    my $msg= $@@ || "Zombie Error";
    print "ok ",$test_count++," # \$/ = \\*STDOUT; should die\n";
    if ($msg!~m!Setting \$\/ to a GLOB reference is forbidden!) {print "not ";}
    print "ok ",$test_count++," # \$/ = \\*STDOUT; produced expected error message\n";
  }
}
@


