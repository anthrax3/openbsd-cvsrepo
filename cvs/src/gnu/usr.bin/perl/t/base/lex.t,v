head	1.15;
access;
symbols
	OPENBSD_6_2_BASE:1.15
	PERL_5_24_2:1.1.1.13
	OPENBSD_6_1:1.15.0.4
	OPENBSD_6_1_BASE:1.15
	OPENBSD_6_0:1.14.0.4
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.13.0.4
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.13.0.6
	OPENBSD_5_8_BASE:1.13
	PERL_5_20_2:1.1.1.12
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	PERL_5_20_1:1.1.1.12
	OPENBSD_5_6:1.12.0.4
	OPENBSD_5_6_BASE:1.12
	PERL_5_18_2:1.1.1.11
	PERL:1.1.1
	OPENBSD_5_5:1.11.0.6
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.2
	OPENBSD_5_4_BASE:1.11
	PERL_5_16_3:1.1.1.10
	OPENBSD_5_3:1.10.0.10
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.8
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.6
	OPENBSD_5_0:1.10.0.4
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.2
	OPENBSD_4_9_BASE:1.10
	PERL_5_12_2:1.1.1.9
	OPENBSD_4_8:1.9.0.4
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.2
	OPENBSD_4_7_BASE:1.9
	PERL_5_10_1:1.1.1.8
	OPENBSD_4_6:1.8.0.6
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.2
	OPENBSD_4_5_BASE:1.8
	PERL_5_10_0:1.1.1.7
	OPENBSD_4_4:1.7.0.20
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.18
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.16
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.14
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.12
	OPENBSD_4_0_BASE:1.7
	PERL_5_8_8:1.1.1.6
	OPENBSD_3_9:1.7.0.10
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.8
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.6
	OPENBSD_3_7_BASE:1.7
	PERL_5_8_6:1.1.1.6
	OPENBSD_3_6:1.7.0.4
	OPENBSD_3_6_BASE:1.7
	PERL_5_8_5:1.1.1.6
	PERL_5_8_3:1.1.1.6
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.15
date	2017.02.05.00.32.19;	author afresh1;	state Exp;
branches;
next	1.14;
commitid	cxJ08BvJA9Pt2PTM;

1.14
date	2016.07.03.01.08.04;	author afresh1;	state Exp;
branches;
next	1.13;
commitid	GzHqjSTnBjdF7Wcw;

1.13
date	2014.11.17.20.57.07;	author afresh1;	state Exp;
branches;
next	1.12;
commitid	QP75iYx42Uo7mMxO;

1.12
date	2014.03.24.15.05.33;	author afresh1;	state Exp;
branches;
next	1.11;

1.11
date	2013.03.25.20.40.59;	author sthen;	state Exp;
branches;
next	1.10;

1.10
date	2010.09.24.15.07.05;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2009.10.12.18.30.27;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2008.09.29.17.36.18;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.47;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.35;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.36.04;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.07.50;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.52.24;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.59.52;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.13.09;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.13.09;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.41.14;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.10.37;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.25.01;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.15.09;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.44.29;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2008.09.29.17.18.58;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2009.10.12.18.10.42;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2010.09.24.14.49.16;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2013.03.25.20.09.32;	author sthen;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2014.03.24.14.59.09;	author afresh1;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2014.11.17.20.53.16;	author afresh1;	state Exp;
branches;
next	1.1.1.13;
commitid	B31cAbBIXiCqnL97;

1.1.1.13
date	2017.08.14.13.46.22;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.15
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl

print "1..104\n";

$x = 'x';

print "#1	:$x: eq :x:\n";
if ($x eq 'x') {print "ok 1\n";} else {print "not ok 1\n";}

$x = $#[0];

if ($x eq '') {print "ok 2\n";} else {print "not ok 2\n";}

$x = $#x;

if ($x eq '-1') {print "ok 3\n";} else {print "not ok 3\n";}

$x = '\\'; # ';

if (length($x) == 1) {print "ok 4\n";} else {print "not ok 4\n";}

eval 'while (0) {
    print "foo\n";
}
/^/ && (print "ok 5\n");
';

eval '$foo{1} / 1;';
if (!$@@) {print "ok 6\n";} else {print "not ok 6 $@@\n";}

eval '$foo = 123+123.4+123e4+123.4E5+123.4e+5+.12;';

$foo = int($foo * 100 + .5);
if ($foo eq 2591024652) {print "ok 7\n";} else {print "not ok 7 :$foo:\n";}

print <<'EOF';
ok 8
EOF

$foo = 'ok 9';
print <<EOF;
$foo
EOF

eval <<\EOE, print $@@;
print <<'EOF';
ok 10
EOF

$foo = 'ok 11';
print <<EOF;
$foo
EOF
EOE

print <<'EOS' . <<\EOF;
ok 12 - make sure single quotes are honored \nnot ok
EOS
ok 13
EOF

print qq/ok 14\n/;
print qq(ok 15\n);

print qq
[ok 16\n]
;

print q<ok 17
>;

print "ok 18 - was the test for the deprecated use of bare << to mean <<\"\"\n";
#print <<;   # Yow!
#ok 18
#
## previous line intentionally left blank.

print <<E1 eq "foo\n\n" ? "ok 19\n" : "not ok 19\n";
@@{[ <<E2 ]}
foo
E2
E1

print <<E1 eq "foo\n\n" ? "ok 20\n" : "not ok 20\n";
@@{[
  <<E2
foo
E2
]}
E1

$foo = FOO;
$bar = BAR;
$foo{$bar} = BAZ;
$ary[0] = ABC;

print "$foo{$bar}" eq "BAZ" ? "ok 21\n" : "not ok 21\n";

print "${foo}{$bar}" eq "FOO{BAR}" ? "ok 22\n" : "not ok 22\n";
print "${foo{$bar}}" eq "BAZ" ? "ok 23\n" : "not ok 23\n";

print "FOO:" =~ /$foo[:]/ ? "ok 24\n" : "not ok 24\n";
print "ABC" =~ /^$ary[$A]$/ ? "ok 25\n" : "not ok 25\n";
print "FOOZ" =~ /^$foo[$A-Z]$/ ? "ok 26\n" : "not ok 26\n";

# MJD 19980425
($X, @@X) = qw(a b c d); 
print "d" =~ /^$X[-1]$/ ? "ok 27\n" : "not ok 27\n";
print "a1" !~ /^$X[-1]$/ ? "ok 28\n" : "not ok 28\n";

print (((q{{\{\(}} . q{{\)\}}}) eq '{{\(}{\)}}') ? "ok 29\n" : "not ok 29\n");


$foo = "not ok 30\n";
$foo =~ s/^not /substr(<<EOF, 0, 0)/e;
  Ignored
EOF
print $foo;

# Tests for new extended control-character variables
# MJD 19990227

my $test = 31;

{ my $CX = "\cX";
  my $CXY  ="\cXY";
  $ {$CX} = 17;
  $ {$CXY} = 23;
  if ($ {^XY} != 23) { print "not "  }
  print "ok $test\n"; $test++;
 
# Does the old UNBRACED syntax still do what it used to?
  if ("$^XY" ne "17Y") { print "not " }
  print "ok $test\n"; $test++;

  sub XX () { 6 }
  $ {"\cQ\cXX"} = 119; 
  $^Q = 5; #  This should be an unused ^Var.
  $N = 5;
  # The second caret here should be interpreted as an xor
  if (($^Q^XX) != 3) { print "not " } 
  print "ok $test\n"; $test++;

  # These next two tests are trying to make sure that
  # $^FOO is always global; it doesn't make sense to 'my' it.
  # 

  eval 'my $^X;';
  print "not " unless index ($@@, 'Can\'t use global $^X in "my"') > -1;
  print "ok $test\n"; $test++;
#  print "($@@)\n" if $@@;

  eval 'my $ {^XYZ};';
  print "not " unless index ($@@, 'Can\'t use global $^XYZ in "my"') > -1;
  print "ok $test\n"; $test++;
#  print "($@@)\n" if $@@;

# Now let's make sure that caret variables are all forced into the main package.
  package Someother;
  $^Q = 'Someother';
  $ {^Quixote} = 'Someother 2';
  $ {^M} = 'Someother 3';
  package main;
  print "not " unless $^Q eq 'Someother';
  print "ok $test\n"; $test++;
  print "not " unless $ {^Quixote} eq 'Someother 2';
  print "ok $test\n"; $test++;
  print "not " unless $ {^M} eq 'Someother 3';
  print "ok $test\n"; $test++;

  
}

# see if eval '', s///e, and heredocs mix

sub T {
    my ($where, $num) = @@_;
    my ($p,$f,$l) = caller;
    print "# $p:$f:$l vs /$where/\nnot " unless "$p:$f:$l" =~ /$where/;
    print "ok $num\n";
}

{
# line 42 "plink"
    local $_ = "not ok ";
    eval q{
	s/^not /<<EOT/e and T '^main:\(eval \d+\):2$', $test++;
# uggedaboudit
EOT
        print $_, $test++, "\n";
	T('^main:\(eval \d+\):6$', $test++);
# line 1 "plunk"
	T('^main:plunk:1$', $test++);
    };
    print "# $@@\nnot ok $test\n" if $@@;
    T '^main:plink:53$', $test++;
}

# tests 47--51 start here
# tests for new array interpolation semantics:
# arrays now *always* interpolate into "..." strings.
# 20000522 MJD (mjd@@plover.com)
{
  eval(q(">@@nosuch<" eq "><")) || print "# $@@", "not ";
  print "ok $test\n";
  ++$test;

  # Look at this!  This is going to be a common error in the future:
  eval(q("fred@@example.com" eq "fred.com")) || print "# $@@", "not ";
  print "ok $test\n";
  ++$test;

  # Let's make sure that normal array interpolation still works right
  # For some reason, this appears not to be tested anywhere else.
  my @@a = (1,2,3);
  print +((">@@a<" eq ">1 2 3<") ? '' : 'not '), "ok $test\n";
  ++$test;

  # Ditto.
  eval(q{@@nosuch = ('a', 'b', 'c'); ">@@nosuch<" eq ">a b c<"}) 
      || print "# $@@", "not ";
  print "ok $test\n";
  ++$test;

  # This isn't actually a lex test, but it's testing the same feature
  sub makearray {
    my @@array = ('fish', 'dog', 'carrot');
    *R::crackers = \@@array;
  }

  eval(q{makearray(); ">@@R::crackers<" eq ">fish dog carrot<"})
    || print "# $@@", "not ";
  print "ok $test\n";
  ++$test;
}

# Tests 52-54
# => should only quote foo::bar if it isn't a real sub. AMS, 20010621

sub xyz::foo { "bar" }
my %str = (
    foo      => 1,
    xyz::foo => 1,
    xyz::bar => 1,
);

print ((exists $str{foo}      ? "" : "not ")."ok $test\n"); ++$test;
print ((exists $str{bar}      ? "" : "not ")."ok $test\n"); ++$test;
print ((exists $str{xyz::bar} ? "" : "not ")."ok $test\n"); ++$test;

sub foo::::::bar { print "ok $test\n"; $test++ }
foo::::::bar;

# \xDF is a non-ASCII alpha on both ASCII and EBCDIC.
eval "\$x =\xDFfoo";
if ($@@ =~ /Unrecognized character \\xDF; marked by <-- HERE after \$x =<-- HERE near column 5/) { print "ok $test\n"; } else { print "not ok $test\n"; }
$test++;

# Is "[~" scanned correctly?
@@a = (1,2,3);
print "not " unless($a[~~2] == 3);
print "ok $test\n"; $test++;

$_ = "";
eval 's/(?:)/"ok $test" . "${\q||}".<<\END/e;
 - heredoc after "" in s/// in eval
END
';
print $_ || "not ok $test\n"; $test++;

$_ = "";
eval 's|(?:)|"ok $test" . "${\<<\END}"
 - heredoc in "" in multiline s///e in eval
END
|e
';
print $_ || "not ok $test\n"; $test++;

$_ = "";
eval "s/(?:)/<<foo/e #\0
ok $test - null on same line as heredoc in s/// in eval
foo
";
print $_ || "not ok $test\n"; $test++;

$_ = "";
eval ' s/(?:)/"${\<<END}"/e;
ok $test - heredoc in "" in single-line s///e in eval
END
';
print $_ || "not ok $test\n"; $test++;

$_ = "";
s|(?:)|"${\<<END}"
ok $test - heredoc in "" in multiline s///e outside eval
END
|e;
print $_ || "not ok $test\n"; $test++;

$_ = "not ok $test - s/// in s/// pattern\n";
s/${s|||;\""}not //;
print; $test++;

/(?{print <<END
ok $test - here-doc in re-eval
END
})/; $test++;

eval '/(?{print <<END
ok $test - here-doc in re-eval in string eval
END
})/'; $test++;

eval 'print qq ;ok $test - eval ending with semicolon\n;'
  or print "not ok $test - eval ending with semicolon\n"; $test++;

print "not " unless qr/(?{<<END})/ eq '(?^:(?{<<END}))';
foo
END
print "ok $test - here-doc in single-line re-eval\n"; $test++;

$_ = qr/(?{"${<<END}"
foo
END
})/;
print "not " unless /foo/;
print "ok $test - here-doc in quotes in multiline re-eval\n"; $test++;

eval 's//<<END/e if 0; $_ = "a
END
b"';
print "not " if $_ =~ /\n\n/;
print "ok $test - eval 's//<<END/' does not leave extra newlines\n"; $test++;

$_ = a;
eval "s/a/'b\0'#/e";
print 'not ' unless $_ eq "b\0";
print "ok $test - # after null in s/// repl\n"; $test++;

s//"#" . <<END/e;
foo
END
print "ok $test - s//'#' . <<END/e\n"; $test++;

eval "s//3}->{3/e";
print "not " unless $@@;
print "ok $test - s//3}->{3/e\n"; $test++;

$_ = "not ok $test";
$x{3} = "not ";
eval 's/${\%x}{3}//e';
print "$_ - s//\${\\%x}{3}/e\n"; $test++;

eval 's/${foo#}//e';
print "not " unless $@@;
print "ok $test - s/\${foo#}//e\n"; $test++;

eval 'warn ({$_ => 1} + 1) if 0';
print "not " if $@@;
print "ok $test - listop({$_ => 1} + 1)\n"; $test++;
print "# $@@" if $@@;

for(qw< require goto last next redo dump >) {
    eval "sub { $_ foo << 2 }";
    print "not " if $@@;
    print "ok ", $test++, " - [perl #105924] $_ WORD << ...\n";
    print "# $@@" if $@@;
}

# http://rt.perl.org/rt3/Ticket/Display.html?id=56880
my $counter = 0;
eval 'v23: $counter++; goto v23 unless $counter == 2';
print "not " unless $counter == 2;
print "ok $test - Use v[0-9]+ as a label\n"; $test++;
$counter = 0;
eval 'v23 : $counter++; goto v23 unless $counter == 2';
print "not " unless $counter == 2;
print "ok $test - Use v[0-9]+ as a label with space before colon\n"; $test++;
 
my $output = "";
eval "package v10::foo; sub test2 { return 'v10::foo' }
      package v10; sub test { return v10::foo::test2(); }
      package main; \$output = v10::test(); "; 
print "not " unless $output eq 'v10::foo';
print "ok $test - call a function in package v10::foo\n"; $test++;

print "not " unless (1?v65:"bar") eq chr(65);
print "ok $test - colon detection after vstring does not break ? vstring :\n"; $test++;

print ((ord("A") == 65) ? v35 : v123);  # NUMBER SIGN is the same for all
                                        # supported EBCDIC platforms
print "not ";
print ((ord("A") == 65) ? v10 : "\n");  # LF varies on EBCDIC, if the v123 for
                                        # '#' works above, consider it good
                                        # enough.
    print "ok $test - print vstring prints the vstring\n";
$test++;

# Test pyoq ops with comments before the first delim
q # comment
 "b"#
  eq 'b' or print "not ";
print "ok $test - q <comment> <newline> ...\n"; $test++;
qq # comment
 "b"#
  eq 'b' or print "not ";
print "ok $test - qq <comment> <newline> ...\n"; $test++;
qw # comment
 "b"#
  [0] eq 'b' or print "not ";
print "ok $test - qw <comment> <newline> ...\n"; $test++;
"b" =~ m # comment
 "b"#
   or print "not ";
print "ok $test - m <comment> <newline> ...\n"; $test++;
qr # comment
 "b"#
   eq qr/b/ or print "not ";
print "ok $test - qr <comment> <newline> ...\n"; $test++;
$_ = "a";
s # comment
 [a] #
 [b] #
 ;
print "not " unless $_ eq 'b';
print "ok $test - s <comment> <newline> ...\n"; $test++;
$_ = "a";
tr # comment
 [a] #
 [b] #
 ;
print "not " unless $_ eq 'b';
print "ok $test - tr <comment> <newline> ...\n"; $test++;
$_ = "a";
y # comment
 [a] #
 [b] #
 ;
print "not " unless $_ eq 'b';
print "ok $test - y <comment> <newline> ...\n"; $test++;

print "not " unless (time
                     =>) eq time=>;
print "ok $test - => quotes keywords across lines\n"; $test++;

# [perl #80368]
print "not " unless eval '"a\U="' eq "a=";
print "ok $test - [perl #80368] qq <a\\U=>\n"; $test++;

sub Function_with_side_effects { $_ = "sidekick function called" }
print "not " unless
    (eval '${Function_with_side_effects,\$_}' || $@@)
      eq "sidekick function called";
print "ok $test - \${...} where {...} looks like hash\n"; $test++;

@@_ = map{BEGIN {$_122782 = 'tst2'}; "rhu$_"} 'barb2';
print "not " unless "@@_" eq 'rhubarb2';
print "ok $test - map{BEGIN...\n"; $test++;
print "not " unless $_122782 eq 'tst2';
print "ok $test - map{BEGIN...\n"; $test++;
${
=pod
blah blah blah
=cut
\$_ } = 42;
print "not "unless $_ == 42;
print "ok $test - \${ <newline> =pod\n"; $test++;
@@_ = map{
=pod
blah blah blah
=cut
$_+1 } 1;
print "not "unless "@@_" eq 2;
print "ok $test - map{ <newline> =pod\n"; $test++;
eval { ${...}++ };
print "not " unless $@@ =~ /^Unimplemented at /;
print "ok $test - \${...} (literal triple-dot)\n"; $test++;
eval { () = map{...} @@_ };
print "not " unless $@@ =~ /^Unimplemented at /;
print "ok $test - map{...} (literal triple-dot)\n"; $test++;
print "not " unless &{sub :lvalue { "a" }} eq "a";
print "ok $test - &{sub :lvalue...}\n"; $test++;
print "not " unless ref +(map{sub :lvalue { "a" }} 1)[0] eq "CODE";
print "ok $test - map{sub :lvalue...}\n"; $test++;

# Used to crash [perl #123711]
0-5x-l{0};

# Used to fail an assertion [perl #123617] [perl #123955]
eval '"$a{ 1 m// }"; //';
eval '"@@0{0s 000";eval"$"';

# Pending token stack overflow [perl #123677]
{
 local $SIG{__WARN__}=sub{};
 eval q|s)$0{0h());qx(@@0);qx(@@0);qx(@@0)|;
}

# Used to crash [perl #123801]
eval q|s##[}#e|;

# Used to fail an assertion [perl #123763]
{
 local $SIG{__WARN__}=sub{};
 eval q|my($_);0=split|;
 eval q|my $_; @@x = split|;
}

{
 # Used to crash [perl #124187]
 eval q|qq{@@{[{}}*sub{]]}}}=u|;
}

{
 # Used to crash [perl #124385]
 eval '0; qq{@@{sub{]]}}}}}';
 print "ok $test - 124385\n"; $test++;
}

{
 # Used to crash [perl #125350]
 eval ('qq{@@{[0}*sub{]]}}}=sub{0' . "\c[");
 print "ok $test - 125350\n"; $test++;
}
@


1.14
log
@Update to perl 5.20.3

OK bluhm@@
@
text
@d3 1
a3 1
print "1..91\n";
a142 2
#  if (($N  ^  XX()) != 3) { print "not " } 
#  print "ok $test\n"; $test++;
d254 3
a256 2
eval "\$x =\xE2foo";
if ($@@ =~ /Unrecognized character \\xE2; marked by <-- HERE after \$x =<-- HERE near column 5/) { print "ok $test\n"; } else { print "not ok $test\n"; }
d387 1
a387 1
print "not " unless (1?v65:"bar") eq 'A';
d390 9
d446 40
d488 37
@


1.13
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d437 3
@


1.12
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d3 1
a3 1
print "1..85\n";
d123 2
d130 1
a130 1
  print "ok 31\n";
a131 10
# Does the syntax where we use the literal control character still work?
  if (eval "\$ {\cX}" != 17 or $@@) { print "not "  }
  print "ok 32\n";

  eval "\$\cQ = 24";                 # Literal control character
  if ($@@ or ${"\cQ"} != 24) {  print "not "  }
  print "ok 33\n";
  if ($^Q != 24) {  print "not "  }  # Control character escape sequence
  print "ok 34\n";

d134 1
a134 1
  print "ok 35\n";
d142 1
a142 1
  print "ok 36\n";
d144 1
a144 1
#  print "ok 32\n";
d152 1
a152 1
  print "ok 37\n";
d157 1
a157 1
  print "ok 38\n";
d167 1
a167 1
  print "ok 39\n";
d169 1
a169 1
  print "ok 40\n";
d171 1
a171 1
  print "ok 41\n";
a184 2
my $test = 42;

a205 1
  my $test = 47;
a248 1
my $test = 52;
d263 1
a263 1
print "ok 57\n";
d266 2
a267 2
eval 's/(?:)/"${\q||}".<<\END/e;
ok 58 - heredoc after "" in s/// in eval
d270 1
a270 1
print $_ || "not ok 58\n";
d273 2
a274 2
eval 's|(?:)|"${\<<\END}"
ok 59 - heredoc in "" in multiline s///e in eval
d278 1
a278 1
print $_ || "not ok 59\n";
d282 1
a282 1
ok 60 - null on same line as heredoc in s/// in eval
d285 1
a285 1
print $_ || "not ok 60\n";
d289 1
a289 1
ok 61 - heredoc in "" in single-line s///e in eval
d292 1
a292 1
print $_ || "not ok 61\n";
d296 1
a296 1
ok 62 - heredoc in "" in multiline s///e outside eval
d299 1
a299 1
print $_ || "not ok 62\n";
d301 1
a301 1
$_ = "not ok 63 - s/// in s/// pattern\n";
d303 1
a303 1
print;
d306 1
a306 1
ok 64 - here-doc in re-eval
d308 1
a308 1
})/;
d311 1
a311 1
ok 65 - here-doc in re-eval in string eval
d313 1
a313 1
})/';
d315 2
a316 2
eval 'print qq ;ok 66 - eval ending with semicolon\n;'
  or print "not ok 66 - eval ending with semicolon\n";
d321 1
a321 1
print "ok 67 - here-doc in single-line re-eval\n";
d328 1
a328 1
print "ok 68 - here-doc in quotes in multiline re-eval\n";
d334 1
a334 1
print "ok 69 - eval 's//<<END/' does not leave extra newlines\n";
d339 1
a339 1
print "ok 70 - # after null in s/// repl\n";
d344 1
a344 1
print "ok 71 - s//'#' . <<END/e\n";
d348 1
a348 1
print "ok 72 - s//3}->{3/e\n";
d350 1
a350 1
$_ = "not ok 73";
d353 1
a353 1
print "$_ - s//\${\\%x}{3}/e\n";
d357 1
a357 1
print "ok 74 - s/\${foo#}//e\n";
d361 1
a361 1
print "ok 75 - listop({$_ => 1} + 1)\n";
a363 1
$test = 76;
d375 1
a375 1
print "ok 82 - Use v[0-9]+ as a label\n";
d379 1
a379 1
print "ok 83 - Use v[0-9]+ as a label with space before colon\n";
d386 1
a386 1
print "ok 84 - call a function in package v10::foo\n";
d389 48
a436 1
print "ok 85 - colon detection after vstring does not break ? vstring :\n";
@


1.11
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d3 1
a3 1
print "1..57\n";
d200 1
a200 1
# fuggedaboudit
d276 127
@


1.10
log
@merge in perl 5.12.2 plus local changes
@
text
@d155 1
a155 1
  # $^FOO is always global; it doesn't make sense to `my' it.
@


1.9
log
@Merge in perl 5.10.1; part two
@
text
@d72 5
a76 4
print <<;   # Yow!
ok 18

# previous line intentionally left blank.
d269 1
a269 1
if ($@@ =~ /Unrecognized character \\xE2 in column 5/) { print "ok $test\n"; } else { print "not ok $test\n"; }
@


1.8
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d3 1
a3 1
print "1..56\n";
d270 5
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d3 1
a3 1
print "1..55\n";
d10 1
a10 1
$x = $#;	# this is the register $#
d266 4
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d3 1
a3 1
print "1..54\n";
d263 3
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d3 1
a3 1
print "1..51\n";
d56 2
a57 2
print <<`EOS` . <<\EOF;
echo ok 12
d133 2
a134 2
  eval "\$\cN = 24";                 # Literal control character
  if ($@@ or ${"\cN"} != 24) {  print "not "  }
d136 1
a136 1
  if ($^N != 24) {  print "not "  }  # Control character escape sequence
d144 2
a145 2
  $ {"\cN\cXX"} = 119; 
  $^N = 5; #  This should be an unused ^Var.
d148 1
a148 1
  if (($^N^XX) != 3) { print "not " } 
d169 2
a170 2
  $^N = 'Someother';
  $ {^Nostril} = 'Someother 2';
d173 1
a173 1
  print "not " unless $^N eq 'Someother';
d175 1
a175 1
  print "not " unless $ {^Nostril} eq 'Someother 2';
d248 15
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d3 1
a3 1
print "1..46\n";
d208 39
@


1.3
log
@perl5.005_03 (stock)
@
text
@d3 1
a3 1
print "1..35\n";
d119 64
d192 1
a192 1
my $test = 31;
@


1.2
log
@perl 5.004_04
@
text
@d3 1
a3 3
# $RCSfile: lex.t,v $$Revision: 4.1 $$Date: 92/08/07 18:27:04 $

print "1..27\n";
d105 40
a144 1
print (((q{{\{\(}} . q{{\)\}}}) eq '{{\(}{\)}}') ? "ok 27\n" : "not ok 27\n");
@


1.1
log
@Initial revision
@
text
@d5 1
a5 1
print "1..24\n";
d79 14
d98 4
a101 1
print "$foo{$bar}" eq "BAZ" ? "ok 19\n" : "not ok 19\n";
d103 3
a105 2
print "${foo}{$bar}" eq "FOO{BAR}" ? "ok 20\n" : "not ok 20\n";
print "${foo{$bar}}" eq "BAZ" ? "ok 21\n" : "not ok 21\n";
d107 1
a107 3
print "FOO:" =~ /$foo[:]/ ? "ok 22\n" : "not ok 22\n";
print "ABC" =~ /^$ary[$A]$/ ? "ok 23\n" : "not ok 23\n";
print "FOOZ" =~ /^$foo[$A-Z]$/ ? "ok 24\n" : "not ok 24\n";
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d3 3
a5 1
print "1..35\n";
a78 14
print <<E1 eq "foo\n\n" ? "ok 19\n" : "not ok 19\n";
@@{[ <<E2 ]}
foo
E2
E1

print <<E1 eq "foo\n\n" ? "ok 20\n" : "not ok 20\n";
@@{[
  <<E2
foo
E2
]}
E1

d84 1
a84 8
print "$foo{$bar}" eq "BAZ" ? "ok 21\n" : "not ok 21\n";

print "${foo}{$bar}" eq "FOO{BAR}" ? "ok 22\n" : "not ok 22\n";
print "${foo{$bar}}" eq "BAZ" ? "ok 23\n" : "not ok 23\n";

print "FOO:" =~ /$foo[:]/ ? "ok 24\n" : "not ok 24\n";
print "ABC" =~ /^$ary[$A]$/ ? "ok 25\n" : "not ok 25\n";
print "FOOZ" =~ /^$foo[$A-Z]$/ ? "ok 26\n" : "not ok 26\n";
d86 2
a87 4
# MJD 19980425
($X, @@X) = qw(a b c d); 
print "d" =~ /^$X[-1]$/ ? "ok 27\n" : "not ok 27\n";
print "a1" !~ /^$X[-1]$/ ? "ok 28\n" : "not ok 28\n";
d89 3
a91 35
print (((q{{\{\(}} . q{{\)\}}}) eq '{{\(}{\)}}') ? "ok 29\n" : "not ok 29\n");


$foo = "not ok 30\n";
$foo =~ s/^not /substr(<<EOF, 0, 0)/e;
  Ignored
EOF
print $foo;

# see if eval '', s///e, and heredocs mix

sub T {
    my ($where, $num) = @@_;
    my ($p,$f,$l) = caller;
    print "# $p:$f:$l vs /$where/\nnot " unless "$p:$f:$l" =~ /$where/;
    print "ok $num\n";
}

my $test = 31;

{
# line 42 "plink"
    local $_ = "not ok ";
    eval q{
	s/^not /<<EOT/e and T '^main:\(eval \d+\):2$', $test++;
# fuggedaboudit
EOT
        print $_, $test++, "\n";
	T('^main:\(eval \d+\):6$', $test++);
# line 1 "plunk"
	T('^main:plunk:1$', $test++);
    };
    print "# $@@\nnot ok $test\n" if $@@;
    T '^main:plink:53$', $test++;
}
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d3 1
a3 1
print "1..46\n";
a118 64
# Tests for new extended control-character variables
# MJD 19990227

{ my $CX = "\cX";
  my $CXY  ="\cXY";
  $ {$CX} = 17;
  $ {$CXY} = 23;
  if ($ {^XY} != 23) { print "not "  }
  print "ok 31\n";
 
# Does the syntax where we use the literal control character still work?
  if (eval "\$ {\cX}" != 17 or $@@) { print "not "  }
  print "ok 32\n";

  eval "\$\cN = 24";                 # Literal control character
  if ($@@ or ${"\cN"} != 24) {  print "not "  }
  print "ok 33\n";
  if ($^N != 24) {  print "not "  }  # Control character escape sequence
  print "ok 34\n";

# Does the old UNBRACED syntax still do what it used to?
  if ("$^XY" ne "17Y") { print "not " }
  print "ok 35\n";

  sub XX () { 6 }
  $ {"\cN\cXX"} = 119; 
  $^N = 5; #  This should be an unused ^Var.
  $N = 5;
  # The second caret here should be interpreted as an xor
  if (($^N^XX) != 3) { print "not " } 
  print "ok 36\n";
#  if (($N  ^  XX()) != 3) { print "not " } 
#  print "ok 32\n";

  # These next two tests are trying to make sure that
  # $^FOO is always global; it doesn't make sense to `my' it.
  # 

  eval 'my $^X;';
  print "not " unless index ($@@, 'Can\'t use global $^X in "my"') > -1;
  print "ok 37\n";
#  print "($@@)\n" if $@@;

  eval 'my $ {^XYZ};';
  print "not " unless index ($@@, 'Can\'t use global $^XYZ in "my"') > -1;
  print "ok 38\n";
#  print "($@@)\n" if $@@;

# Now let's make sure that caret variables are all forced into the main package.
  package Someother;
  $^N = 'Someother';
  $ {^Nostril} = 'Someother 2';
  $ {^M} = 'Someother 3';
  package main;
  print "not " unless $^N eq 'Someother';
  print "ok 39\n";
  print "not " unless $ {^Nostril} eq 'Someother 2';
  print "ok 40\n";
  print "not " unless $ {^M} eq 'Someother 3';
  print "ok 41\n";

  
}

d128 1
a128 1
my $test = 42;
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d3 1
a3 1
print "1..51\n";
a207 39
}

# tests 47--51 start here
# tests for new array interpolation semantics:
# arrays now *always* interpolate into "..." strings.
# 20000522 MJD (mjd@@plover.com)
{
  my $test = 47;
  eval(q(">@@nosuch<" eq "><")) || print "# $@@", "not ";
  print "ok $test\n";
  ++$test;

  # Look at this!  This is going to be a common error in the future:
  eval(q("fred@@example.com" eq "fred.com")) || print "# $@@", "not ";
  print "ok $test\n";
  ++$test;

  # Let's make sure that normal array interpolation still works right
  # For some reason, this appears not to be tested anywhere else.
  my @@a = (1,2,3);
  print +((">@@a<" eq ">1 2 3<") ? '' : 'not '), "ok $test\n";
  ++$test;

  # Ditto.
  eval(q{@@nosuch = ('a', 'b', 'c'); ">@@nosuch<" eq ">a b c<"}) 
      || print "# $@@", "not ";
  print "ok $test\n";
  ++$test;

  # This isn't actually a lex test, but it's testing the same feature
  sub makearray {
    my @@array = ('fish', 'dog', 'carrot');
    *R::crackers = \@@array;
  }

  eval(q{makearray(); ">@@R::crackers<" eq ">fish dog carrot<"})
    || print "# $@@", "not ";
  print "ok $test\n";
  ++$test;
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d3 1
a3 1
print "1..54\n";
d56 2
a57 2
print <<'EOS' . <<\EOF;
ok 12 - make sure single quotes are honored \nnot ok
d133 2
a134 2
  eval "\$\cQ = 24";                 # Literal control character
  if ($@@ or ${"\cQ"} != 24) {  print "not "  }
d136 1
a136 1
  if ($^Q != 24) {  print "not "  }  # Control character escape sequence
d144 2
a145 2
  $ {"\cQ\cXX"} = 119; 
  $^Q = 5; #  This should be an unused ^Var.
d148 1
a148 1
  if (($^Q^XX) != 3) { print "not " } 
d169 2
a170 2
  $^Q = 'Someother';
  $ {^Quixote} = 'Someother 2';
d173 1
a173 1
  print "not " unless $^Q eq 'Someother';
d175 1
a175 1
  print "not " unless $ {^Quixote} eq 'Someother 2';
a247 15

# Tests 52-54
# => should only quote foo::bar if it isn't a real sub. AMS, 20010621

sub xyz::foo { "bar" }
my %str = (
    foo      => 1,
    xyz::foo => 1,
    xyz::bar => 1,
);

my $test = 52;
print ((exists $str{foo}      ? "" : "not ")."ok $test\n"); ++$test;
print ((exists $str{bar}      ? "" : "not ")."ok $test\n"); ++$test;
print ((exists $str{xyz::bar} ? "" : "not ")."ok $test\n"); ++$test;
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@d3 1
a3 1
print "1..55\n";
a262 3

sub foo::::::bar { print "ok $test\n"; $test++ }
foo::::::bar;
@


1.1.1.7
log
@import perl 5.10.0 from CPAN
@
text
@d3 1
a3 1
print "1..56\n";
d10 1
a10 1
$x = $#[0];
a265 4

eval "\$x =\xE2foo";
if ($@@ =~ /Unrecognized character \\xE2 in column 5/) { print "ok $test\n"; } else { print "not ok $test\n"; }
$test++;
@


1.1.1.8
log
@import perl 5.10.1
@
text
@d3 1
a3 1
print "1..57\n";
a269 5

# Is "[~" scanned correctly?
@@a = (1,2,3);
print "not " unless($a[~~2] == 3);
print "ok 57\n";
@


1.1.1.9
log
@Perl 5.12.2 from CPAN
@
text
@d72 4
a75 5
print "ok 18 - was the test for the deprecated use of bare << to mean <<\"\"\n";
#print <<;   # Yow!
#ok 18
#
## previous line intentionally left blank.
d268 1
a268 1
if ($@@ =~ /Unrecognized character \\xE2; marked by <-- HERE after \$x =<-- HERE near column 5/) { print "ok $test\n"; } else { print "not ok $test\n"; }
@


1.1.1.10
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d155 1
a155 1
  # $^FOO is always global; it doesn't make sense to 'my' it.
@


1.1.1.11
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d3 1
a3 1
print "1..85\n";
d200 1
a200 1
# uggedaboudit
a275 127

$_ = "";
eval 's/(?:)/"${\q||}".<<\END/e;
ok 58 - heredoc after "" in s/// in eval
END
';
print $_ || "not ok 58\n";

$_ = "";
eval 's|(?:)|"${\<<\END}"
ok 59 - heredoc in "" in multiline s///e in eval
END
|e
';
print $_ || "not ok 59\n";

$_ = "";
eval "s/(?:)/<<foo/e #\0
ok 60 - null on same line as heredoc in s/// in eval
foo
";
print $_ || "not ok 60\n";

$_ = "";
eval ' s/(?:)/"${\<<END}"/e;
ok 61 - heredoc in "" in single-line s///e in eval
END
';
print $_ || "not ok 61\n";

$_ = "";
s|(?:)|"${\<<END}"
ok 62 - heredoc in "" in multiline s///e outside eval
END
|e;
print $_ || "not ok 62\n";

$_ = "not ok 63 - s/// in s/// pattern\n";
s/${s|||;\""}not //;
print;

/(?{print <<END
ok 64 - here-doc in re-eval
END
})/;

eval '/(?{print <<END
ok 65 - here-doc in re-eval in string eval
END
})/';

eval 'print qq ;ok 66 - eval ending with semicolon\n;'
  or print "not ok 66 - eval ending with semicolon\n";

print "not " unless qr/(?{<<END})/ eq '(?^:(?{<<END}))';
foo
END
print "ok 67 - here-doc in single-line re-eval\n";

$_ = qr/(?{"${<<END}"
foo
END
})/;
print "not " unless /foo/;
print "ok 68 - here-doc in quotes in multiline re-eval\n";

eval 's//<<END/e if 0; $_ = "a
END
b"';
print "not " if $_ =~ /\n\n/;
print "ok 69 - eval 's//<<END/' does not leave extra newlines\n";

$_ = a;
eval "s/a/'b\0'#/e";
print 'not ' unless $_ eq "b\0";
print "ok 70 - # after null in s/// repl\n";

s//"#" . <<END/e;
foo
END
print "ok 71 - s//'#' . <<END/e\n";

eval "s//3}->{3/e";
print "not " unless $@@;
print "ok 72 - s//3}->{3/e\n";

$_ = "not ok 73";
$x{3} = "not ";
eval 's/${\%x}{3}//e';
print "$_ - s//\${\\%x}{3}/e\n";

eval 's/${foo#}//e';
print "not " unless $@@;
print "ok 74 - s/\${foo#}//e\n";

eval 'warn ({$_ => 1} + 1) if 0';
print "not " if $@@;
print "ok 75 - listop({$_ => 1} + 1)\n";
print "# $@@" if $@@;

$test = 76;
for(qw< require goto last next redo dump >) {
    eval "sub { $_ foo << 2 }";
    print "not " if $@@;
    print "ok ", $test++, " - [perl #105924] $_ WORD << ...\n";
    print "# $@@" if $@@;
}

# http://rt.perl.org/rt3/Ticket/Display.html?id=56880
my $counter = 0;
eval 'v23: $counter++; goto v23 unless $counter == 2';
print "not " unless $counter == 2;
print "ok 82 - Use v[0-9]+ as a label\n";
$counter = 0;
eval 'v23 : $counter++; goto v23 unless $counter == 2';
print "not " unless $counter == 2;
print "ok 83 - Use v[0-9]+ as a label with space before colon\n";
 
my $output = "";
eval "package v10::foo; sub test2 { return 'v10::foo' }
      package v10; sub test { return v10::foo::test2(); }
      package main; \$output = v10::test(); "; 
print "not " unless $output eq 'v10::foo';
print "ok 84 - call a function in package v10::foo\n";

print "not " unless (1?v65:"bar") eq 'A';
print "ok 85 - colon detection after vstring does not break ? vstring :\n";
@


1.1.1.12
log
@Import perl-5.20.1
@
text
@d3 1
a3 1
print "1..91\n";
a122 2
my $test = 31;

d128 1
a128 1
  print "ok $test\n"; $test++;
d130 10
d142 1
a142 1
  print "ok $test\n"; $test++;
d150 1
a150 1
  print "ok $test\n"; $test++;
d152 1
a152 1
#  print "ok $test\n"; $test++;
d160 1
a160 1
  print "ok $test\n"; $test++;
d165 1
a165 1
  print "ok $test\n"; $test++;
d175 1
a175 1
  print "ok $test\n"; $test++;
d177 1
a177 1
  print "ok $test\n"; $test++;
d179 1
a179 1
  print "ok $test\n"; $test++;
d193 2
d216 1
d260 1
d275 1
a275 1
print "ok $test\n"; $test++;
d278 2
a279 2
eval 's/(?:)/"ok $test" . "${\q||}".<<\END/e;
 - heredoc after "" in s/// in eval
d282 1
a282 1
print $_ || "not ok $test\n"; $test++;
d285 2
a286 2
eval 's|(?:)|"ok $test" . "${\<<\END}"
 - heredoc in "" in multiline s///e in eval
d290 1
a290 1
print $_ || "not ok $test\n"; $test++;
d294 1
a294 1
ok $test - null on same line as heredoc in s/// in eval
d297 1
a297 1
print $_ || "not ok $test\n"; $test++;
d301 1
a301 1
ok $test - heredoc in "" in single-line s///e in eval
d304 1
a304 1
print $_ || "not ok $test\n"; $test++;
d308 1
a308 1
ok $test - heredoc in "" in multiline s///e outside eval
d311 1
a311 1
print $_ || "not ok $test\n"; $test++;
d313 1
a313 1
$_ = "not ok $test - s/// in s/// pattern\n";
d315 1
a315 1
print; $test++;
d318 1
a318 1
ok $test - here-doc in re-eval
d320 1
a320 1
})/; $test++;
d323 1
a323 1
ok $test - here-doc in re-eval in string eval
d325 1
a325 1
})/'; $test++;
d327 2
a328 2
eval 'print qq ;ok $test - eval ending with semicolon\n;'
  or print "not ok $test - eval ending with semicolon\n"; $test++;
d333 1
a333 1
print "ok $test - here-doc in single-line re-eval\n"; $test++;
d340 1
a340 1
print "ok $test - here-doc in quotes in multiline re-eval\n"; $test++;
d346 1
a346 1
print "ok $test - eval 's//<<END/' does not leave extra newlines\n"; $test++;
d351 1
a351 1
print "ok $test - # after null in s/// repl\n"; $test++;
d356 1
a356 1
print "ok $test - s//'#' . <<END/e\n"; $test++;
d360 1
a360 1
print "ok $test - s//3}->{3/e\n"; $test++;
d362 1
a362 1
$_ = "not ok $test";
d365 1
a365 1
print "$_ - s//\${\\%x}{3}/e\n"; $test++;
d369 1
a369 1
print "ok $test - s/\${foo#}//e\n"; $test++;
d373 1
a373 1
print "ok $test - listop({$_ => 1} + 1)\n"; $test++;
d376 1
d388 1
a388 1
print "ok $test - Use v[0-9]+ as a label\n"; $test++;
d392 1
a392 1
print "ok $test - Use v[0-9]+ as a label with space before colon\n"; $test++;
d399 1
a399 1
print "ok $test - call a function in package v10::foo\n"; $test++;
d402 1
a402 48
print "ok $test - colon detection after vstring does not break ? vstring :\n"; $test++;

# Test pyoq ops with comments before the first delim
q # comment
 "b"#
  eq 'b' or print "not ";
print "ok $test - q <comment> <newline> ...\n"; $test++;
qq # comment
 "b"#
  eq 'b' or print "not ";
print "ok $test - qq <comment> <newline> ...\n"; $test++;
qw # comment
 "b"#
  [0] eq 'b' or print "not ";
print "ok $test - qw <comment> <newline> ...\n"; $test++;
"b" =~ m # comment
 "b"#
   or print "not ";
print "ok $test - m <comment> <newline> ...\n"; $test++;
qr # comment
 "b"#
   eq qr/b/ or print "not ";
print "ok $test - qr <comment> <newline> ...\n"; $test++;
$_ = "a";
s # comment
 [a] #
 [b] #
 ;
print "not " unless $_ eq 'b';
print "ok $test - s <comment> <newline> ...\n"; $test++;
$_ = "a";
tr # comment
 [a] #
 [b] #
 ;
print "not " unless $_ eq 'b';
print "ok $test - tr <comment> <newline> ...\n"; $test++;
$_ = "a";
y # comment
 [a] #
 [b] #
 ;
print "not " unless $_ eq 'b';
print "ok $test - y <comment> <newline> ...\n"; $test++;

print "not " unless (time
                     =>) eq time=>;
print "ok $test - => quotes keywords across lines\n"; $test++;
@


1.1.1.13
log
@Import perl-5.24.2
@
text
@d3 1
a3 1
print "1..104\n";
d143 2
d256 2
a257 3
# \xDF is a non-ASCII alpha on both ASCII and EBCDIC.
eval "\$x =\xDFfoo";
if ($@@ =~ /Unrecognized character \\xDF; marked by <-- HERE after \$x =<-- HERE near column 5/) { print "ok $test\n"; } else { print "not ok $test\n"; }
d388 1
a388 1
print "not " unless (1?v65:"bar") eq chr(65);
a390 9
print ((ord("A") == 65) ? v35 : v123);  # NUMBER SIGN is the same for all
                                        # supported EBCDIC platforms
print "not ";
print ((ord("A") == 65) ? v10 : "\n");  # LF varies on EBCDIC, if the v123 for
                                        # '#' works above, consider it good
                                        # enough.
    print "ok $test - print vstring prints the vstring\n";
$test++;

a436 80

# [perl #80368]
print "not " unless eval '"a\U="' eq "a=";
print "ok $test - [perl #80368] qq <a\\U=>\n"; $test++;

sub Function_with_side_effects { $_ = "sidekick function called" }
print "not " unless
    (eval '${Function_with_side_effects,\$_}' || $@@)
      eq "sidekick function called";
print "ok $test - \${...} where {...} looks like hash\n"; $test++;

@@_ = map{BEGIN {$_122782 = 'tst2'}; "rhu$_"} 'barb2';
print "not " unless "@@_" eq 'rhubarb2';
print "ok $test - map{BEGIN...\n"; $test++;
print "not " unless $_122782 eq 'tst2';
print "ok $test - map{BEGIN...\n"; $test++;
${
=pod
blah blah blah
=cut
\$_ } = 42;
print "not "unless $_ == 42;
print "ok $test - \${ <newline> =pod\n"; $test++;
@@_ = map{
=pod
blah blah blah
=cut
$_+1 } 1;
print "not "unless "@@_" eq 2;
print "ok $test - map{ <newline> =pod\n"; $test++;
eval { ${...}++ };
print "not " unless $@@ =~ /^Unimplemented at /;
print "ok $test - \${...} (literal triple-dot)\n"; $test++;
eval { () = map{...} @@_ };
print "not " unless $@@ =~ /^Unimplemented at /;
print "ok $test - map{...} (literal triple-dot)\n"; $test++;
print "not " unless &{sub :lvalue { "a" }} eq "a";
print "ok $test - &{sub :lvalue...}\n"; $test++;
print "not " unless ref +(map{sub :lvalue { "a" }} 1)[0] eq "CODE";
print "ok $test - map{sub :lvalue...}\n"; $test++;

# Used to crash [perl #123711]
0-5x-l{0};

# Used to fail an assertion [perl #123617] [perl #123955]
eval '"$a{ 1 m// }"; //';
eval '"@@0{0s 000";eval"$"';

# Pending token stack overflow [perl #123677]
{
 local $SIG{__WARN__}=sub{};
 eval q|s)$0{0h());qx(@@0);qx(@@0);qx(@@0)|;
}

# Used to crash [perl #123801]
eval q|s##[}#e|;

# Used to fail an assertion [perl #123763]
{
 local $SIG{__WARN__}=sub{};
 eval q|my($_);0=split|;
 eval q|my $_; @@x = split|;
}

{
 # Used to crash [perl #124187]
 eval q|qq{@@{[{}}*sub{]]}}}=u|;
}

{
 # Used to crash [perl #124385]
 eval '0; qq{@@{sub{]]}}}}}';
 print "ok $test - 124385\n"; $test++;
}

{
 # Used to crash [perl #125350]
 eval ('qq{@@{[0}*sub{]]}}}=sub{0' . "\c[");
 print "ok $test - 125350\n"; $test++;
}
@


