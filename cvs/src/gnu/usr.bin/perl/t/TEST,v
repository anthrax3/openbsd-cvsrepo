head	1.17;
access;
symbols
	OPENBSD_6_1_BASE:1.17
	OPENBSD_6_0:1.16.0.10
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.16.0.4
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.16.0.6
	OPENBSD_5_8_BASE:1.16
	PERL_5_20_2:1.1.1.15
	OPENBSD_5_7:1.16.0.2
	OPENBSD_5_7_BASE:1.16
	PERL_5_20_1:1.1.1.15
	OPENBSD_5_6:1.15.0.4
	OPENBSD_5_6_BASE:1.15
	PERL_5_18_2:1.1.1.14
	PERL:1.1.1
	OPENBSD_5_5:1.14.0.6
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.2
	OPENBSD_5_4_BASE:1.14
	PERL_5_16_3:1.1.1.13
	OPENBSD_5_3:1.13.0.10
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.8
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.6
	OPENBSD_5_0:1.13.0.4
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.2
	OPENBSD_4_9_BASE:1.13
	PERL_5_12_2:1.1.1.12
	OPENBSD_4_8:1.12.0.4
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	PERL_5_10_1:1.1.1.11
	OPENBSD_4_6:1.11.0.6
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.2
	OPENBSD_4_5_BASE:1.11
	PERL_5_10_0:1.1.1.10
	OPENBSD_4_4:1.10.0.10
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.8
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.6
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.4
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.2
	OPENBSD_4_0_BASE:1.10
	PERL_5_8_8:1.1.1.9
	OPENBSD_3_9:1.9.0.6
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.4
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.2
	OPENBSD_3_7_BASE:1.9
	PERL_5_8_6:1.1.1.8
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	PERL_5_8_5:1.1.1.7
	PERL_5_8_3:1.1.1.6
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.17
date	2017.02.05.00.32.19;	author afresh1;	state Exp;
branches;
next	1.16;
commitid	cxJ08BvJA9Pt2PTM;

1.16
date	2014.11.17.20.57.07;	author afresh1;	state Exp;
branches;
next	1.15;
commitid	QP75iYx42Uo7mMxO;

1.15
date	2014.03.24.15.05.33;	author afresh1;	state Exp;
branches;
next	1.14;

1.14
date	2013.03.25.20.40.59;	author sthen;	state Exp;
branches;
next	1.13;

1.13
date	2010.09.24.15.07.05;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2009.10.12.18.24.48;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2008.09.29.17.36.18;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2006.03.28.19.23.12;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2005.01.15.21.30.39;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2004.08.09.18.10.19;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.47;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.35;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.36.03;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.07.49;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.52.24;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.59.48;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.13.08;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.13.08;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.41.13;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.10.36;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.25.00;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.15.09;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.44.29;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.08.09.17.48.30;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2005.01.15.21.18.13;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2006.03.28.18.49.40;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2008.09.29.17.18.58;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2009.10.12.18.10.41;	author millert;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2010.09.24.14.49.15;	author millert;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2013.03.25.20.09.32;	author sthen;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2014.03.24.14.59.09;	author afresh1;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	2014.11.17.20.53.16;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.17
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl

# This is written in a peculiar style, since we're trying to avoid
# most of the constructs we'll be testing for.  (This comment is
# probably obsolete on the avoidance side, though still current
# on the peculiarity side.)

# t/TEST and t/harness need to share code. The logical way to do this would be
# to have the common code in a file both require or use. However, t/TEST needs
# to still work, to generate test results, even if require isn't working, so
# we cannot do that. t/harness has no such restriction, so it is quite
# acceptable to have it require t/TEST.

# In which case, we need to stop t/TEST actually running tests, as all
# t/harness needs are its subroutines.

# Measure the elapsed wallclock time.
my $t0 = time();

# If we're doing deparse tests, ignore failures for these
my $deparse_failures;

# And skip even running these
my $deparse_skips;

# directories with special sets of test switches
my %dir_to_switch =
    (base => '',
     comp => '',
     run => '',
     '../ext/File-Glob/t' => '-I.. -MTestInit', # FIXME - tests assume t/
     );

# "not absolute" is the default, as it saves some fakery within TestInit
# which can perturb tests, and takes CPU. Working with the upstream author of
# any of these, to figure out how to remove them from this list, considered
# "a good thing".
my %abs = (
	   '../cpan/Archive-Tar' => 1,
	   '../cpan/AutoLoader' => 1,
	   '../cpan/CPAN' => 1,
	   '../cpan/Devel-PPPort' => 1,
	   '../cpan/Encode' => 1,
	   '../cpan/ExtUtils-Constant' => 1,
	   '../cpan/ExtUtils-Install' => 1,
	   '../cpan/ExtUtils-MakeMaker' => 1,
	   '../cpan/ExtUtils-Manifest' => 1,
	   '../cpan/File-Fetch' => 1,
	   '../cpan/IPC-Cmd' => 1,
	   '../cpan/IPC-SysV' => 1,
	   '../cpan/Locale-Codes' => 1,
	   '../cpan/Module-Load' => 1,
	   '../cpan/Module-Load-Conditional' => 1,
	   '../cpan/Parse-CPAN-Meta' => 1,
	   '../cpan/Pod-Simple' => 1,
	   '../cpan/Test-Simple' => 1,
	   '../cpan/podlators' => 1,
	   '../dist/Cwd' => 1,
	   '../dist/ExtUtils-ParseXS' => 1,
	   '../dist/Tie-File' => 1,
	  );

my %temp_no_core =
    ('../cpan/B-Debug' => 1,
     '../cpan/Compress-Raw-Bzip2' => 1,
     '../cpan/Compress-Raw-Zlib' => 1,
     '../cpan/Devel-PPPort' => 1,
     '../cpan/Getopt-Long' => 1,
     '../cpan/IO-Compress' => 1,
     '../cpan/MIME-Base64' => 1,
     '../cpan/parent' => 1,
     '../cpan/Parse-CPAN-Meta' => 1,
     '../cpan/Pod-Simple' => 1,
     '../cpan/podlators' => 1,
     '../cpan/Test-Simple' => 1,
     '../cpan/Tie-RefHash' => 1,
     '../cpan/Unicode-Collate' => 1,
     '../cpan/Unicode-Normalize' => 1,
    );

# delete env vars that may influence the results
# but allow override via *_TEST env var if wanted
# (e.g. PERL5OPT_TEST=-d:NYTProf)
my @@bad_env_vars = qw(
    PERL5LIB PERLLIB PERL5OPT
    PERL_YAML_BACKEND PERL_JSON_BACKEND
);

for my $envname (@@bad_env_vars) {
    my $override = $ENV{"${envname}_TEST"};
    if (defined $override) {
	warn "$0: $envname=$override\n";
	$ENV{$envname} = $override;
    }
    else {
	delete $ENV{$envname};
    }
}

# Location to put the Valgrind log.
our $Valgrind_Log;

my %skip = (
	    '.' => 1,
	    '..' => 1,
	    'CVS' => 1,
	    'RCS' => 1,
	    'SCCS' => 1,
	    '.svn' => 1,
	   );


if ($::do_nothing) {
    return 1;
}

$| = 1;

# for testing TEST only
#BEGIN { require '../lib/strict.pm'; "strict"->import() };
#BEGIN { require '../lib/warnings.pm'; "warnings"->import() };

# remove empty elements due to insertion of empty symbols via "''p1'" syntax
@@ARGV = grep($_,@@ARGV) if $^O eq 'VMS';

# String eval to avoid loading File::Glob on non-miniperl.
# (Windows only uses this script for miniperl.)
@@ARGV = eval 'map glob, @@ARGV' if $^O eq 'MSWin32';

our $show_elapsed_time = $ENV{HARNESS_TIMER} || 0;

# Cheesy version of Getopt::Std.  We can't replace it with that, because we
# can't rely on require working.
{
    my @@argv = ();
    foreach my $idx (0..$#ARGV) {
	push( @@argv, $ARGV[$idx] ), next unless $ARGV[$idx] =~ /^-(\S+)$/;
	$::benchmark = 1 if $1 eq 'benchmark';
	$::core    = 1 if $1 eq 'core';
	$::verbose = 1 if $1 eq 'v';
	$::torture = 1 if $1 eq 'torture';
	$::with_utf8 = 1 if $1 eq 'utf8';
	$::with_utf16 = 1 if $1 eq 'utf16';
	$::taintwarn = 1 if $1 eq 'taintwarn';
	if ($1 =~ /^deparse(,.+)?$/) {
	    $::deparse = 1;
	    $::deparse_opts = $1;
            _process_deparse_config();
	}
    }
    @@ARGV = @@argv;
}

chdir 't' if -f 't/TEST';
if (-f 'TEST' && -f 'harness' && -d '../lib') {
    @@INC = '../lib';
}

die "You need to run \"make test\" first to set things up.\n"
  unless -e 'perl' or -e 'perl.exe' or -e 'perl.pm';

# check leakage for embedders
$ENV{PERL_DESTRUCT_LEVEL} = 2 unless exists $ENV{PERL_DESTRUCT_LEVEL};
# check existence of all symbols
$ENV{PERL_DL_NONLAZY} = 1 unless exists $ENV{PERL_DL_NONLAZY};

$ENV{EMXSHELL} = 'sh';        # For OS/2

if ($show_elapsed_time) { require Time::HiRes }
my %timings = (); # testname => [@@et] pairs if $show_elapsed_time.

# Roll your own File::Find!
sub _find_tests { our @@found=(); push @@ARGV, _find_files('\.t$', $_[0]) }
sub _find_files {
    my($patt, @@dirs) = @@_;
    for my $dir (@@dirs) {
	opendir DIR, $dir or die "Trouble opening $dir: $!";
	foreach my $f (sort { $a cmp $b } readdir DIR) {
	    next if $skip{$f};

	    my $fullpath = "$dir/$f";
	    
	    if (-d $fullpath) {
		_find_files($patt, $fullpath);
	    } elsif ($f =~ /$patt/) {
		push @@found, $fullpath;
	    }
	}
    }
    @@found;
}


# Scan the text of the test program to find switches and special options
# we might need to apply.
sub _scan_test {
    my($test, $type) = @@_;

    open(my $script, "<", $test) or die "Can't read $test.\n";
    my $first_line = <$script>;

    $first_line =~ tr/\0//d if $::with_utf16;

    my $switch = "";
    if ($first_line =~ /#!.*\bperl.*\s-\w*([tT])/) {
        $switch = "-$1";
    } else {
        if ($::taintwarn) {
            # not all tests are expected to pass with this option
            $switch = '-t';
        } else {
            $switch = '';
        }
    }

    my $file_opts = "";
    if ($type eq 'deparse') {
        # Look for #line directives which change the filename
        while (<$script>) {
            $file_opts = $file_opts . ",-f$3$4"
              if /^#\s*line\s+(\d+)\s+((\w+)|"([^"]+)")/;
        }
    }

    close $script;

    my $perl = $^O eq 'MSWin32' ? '.\perl' : './perl';
    my $lib  = '../lib';
    my $run_dir;
    my $return_dir;

    $test =~ /^(.+)\/[^\/]+/;
    my $dir = $1;
    my $testswitch = $dir_to_switch{$dir};
    if (!defined $testswitch) {
	if ($test =~ s!^(\.\./(cpan|dist|ext)/[^/]+)/t!t!) {
	    $run_dir = $1;
	    $return_dir = '../../t';
	    $lib = '../../lib';
	    $perl = '../../t/perl';
	    $testswitch = "-I../.. -MTestInit=U2T";
	    if ($2 eq 'cpan' || $2 eq 'dist') {
		if($abs{$run_dir}) {
		    $testswitch = $testswitch . ',A';
		}
		if ($temp_no_core{$run_dir}) {
		    $testswitch = $testswitch . ',NC';
		}
	    }
	} elsif ($test =~ m!^\.\./lib!) {
	    $testswitch = '-I.. -MTestInit=U1'; # -T will remove . from @@INC
	} else {
	    $testswitch = '-I.. -MTestInit';  # -T will remove . from @@INC
	}
    }

    my $utf8 = ($::with_utf8 || $::with_utf16) ? "-I$lib -Mutf8" : '';

    my %options = (
	perl => $perl,
	lib => $lib,
	test => $test,
	run_dir => $run_dir,
	return_dir => $return_dir,
	testswitch => $testswitch,
	utf8 => $utf8,
	file => $file_opts,
	switch => $switch,
    );

    return \%options;
}

sub _cmd {
    my($options, $type) = @@_;

    my $test = $options->{test};

    my $cmd;
    if ($type eq 'deparse') {
        my $perl = "$options->{perl} $options->{testswitch}";
        my $lib = $options->{lib};

        $cmd = (
          "$perl $options->{switch} -I$lib -MO=-qq,Deparse,-sv1.,".
          "-l$::deparse_opts$options->{file} ".
          "$test > $test.dp ".
          "&& $perl $options->{switch} -I$lib $test.dp"
        );
    }
    elsif ($type eq 'perl') {
        my $perl = $options->{perl};
        my $redir = $^O eq 'VMS' ? '2>&1' : '';

        if ($ENV{PERL_VALGRIND}) {
            my $perl_supp = $options->{return_dir} ? "$options->{return_dir}/perl.supp" : "perl.supp";
            my $valgrind_exe = $ENV{VALGRIND} // 'valgrind';
            if ($options->{run_dir}) {
                $Valgrind_Log = "$options->{run_dir}/$Valgrind_Log";
            }
            my $vg_opts = $ENV{VG_OPTS}
	       //   "--log-file=$Valgrind_Log "
		  . "--suppressions=$perl_supp --leak-check=yes "
		  . "--leak-resolution=high --show-reachable=yes "
		  . "--num-callers=50 --track-origins=yes";
	    # Force logging if not asked for (so cachegrind reporting works below)
	    if ($vg_opts !~ /--log-file/) {
		$vg_opts = "--log-file=$Valgrind_Log $vg_opts";
	    }
            $perl = "$valgrind_exe $vg_opts $perl";
        }

        my $args = "$options->{testswitch} $options->{switch} $options->{utf8}";
        $cmd = $perl . _quote_args($args) . " $test $redir";
    }
    return $cmd;
}

sub _before_fork {
    my ($options) = @@_;

    if ($options->{run_dir}) {
	my $run_dir = $options->{run_dir};
	chdir $run_dir or die "Can't chdir to '$run_dir': $!";
    }

    # Remove previous valgrind output otherwise it will interfere
    my $test = $options->{test};

    (local $Valgrind_Log = "$test.valgrind-current") =~ s/^.*\///;

    if ($ENV{PERL_VALGRIND} && -e $Valgrind_Log) {
        unlink $Valgrind_Log
            or warn "$0: Failed to unlink '$Valgrind_Log': $!\n";
    }

    return;
}

sub _after_fork {
    my ($options) = @@_;

    if ($options->{return_dir}) {
	my $return_dir = $options->{return_dir};
	chdir $return_dir
	   or die "Can't chdir from '$options->{run_dir}' to '$return_dir': $!";
    }

    return;
}

sub _run_test {
    my ($test, $type) = @@_;

    my $options = _scan_test($test, $type);
    # $test might have changed if we're in ext/Foo, so don't use it anymore
    # from now on. Use $options->{test} instead.

    _before_fork($options);

    my $cmd = _cmd($options, $type);

    open(my $results, "$cmd |") or print "can't run '$cmd': $!.\n";

    _after_fork($options);

    # Our environment may force us to use UTF-8, but we can't be sure that
    # anything we're reading from will be generating (well formed) UTF-8
    # This may not be the best way - possibly we should unset ${^OPEN} up
    # top?
    binmode $results;

    return $results;
}

sub _quote_args {
    my ($args) = @@_;
    my $argstring = '';

    foreach (split(/\s+/,$args)) {
       # In VMS protect with doublequotes because otherwise
       # DCL will lowercase -- unless already doublequoted.
       $_ = q(").$_.q(") if ($^O eq 'VMS') && !/^\"/ && length($_) > 0;
       $argstring = $argstring . ' ' . $_;
    }
    return $argstring;
}

sub _populate_hash {
    return unless defined $_[0];
    return map {$_, 1} split /\s+/, $_[0];
}

sub _tests_from_manifest {
    my ($extensions, $known_extensions) = @@_;
    my %skip;
    my %extensions = _populate_hash($extensions);
    my %known_extensions = _populate_hash($known_extensions);

    foreach (keys %known_extensions) {
	$skip{$_} = 1 unless $extensions{$_};
    }

    my @@results;
    my $mani = '../MANIFEST';
    if (open(MANI, $mani)) {
	while (<MANI>) {
	    if (m!^((?:cpan|dist|ext)/(\S+)/+(?:[^/\s]+\.t|test\.pl)|lib/\S+?(?:\.t|test\.pl))\s!) {
		my $t = $1;
		my $extension = $2;

		# XXX Generates way too many error lines currently.  Skip for
		# v5.22
		next if $t =~ /^cpan/ && ord("A") != 65;

		if (!$::core || $t =~ m!^lib/[a-z]!) {
		    if (defined $extension) {
			$extension =~ s!/t(:?/\S+)*$!!;
			# XXX Do I want to warn that I'm skipping these?
			next if $skip{$extension};
			my $flat_extension = $extension;
			$flat_extension =~ s!-!/!g;
			next if $skip{$flat_extension}; # Foo/Bar may live in Foo-Bar
		    }
		    my $path = "../$t";
		    push @@results, $path;
		    $::path_to_name{$path} = $t;
		}
	    }
	}
	close MANI;
    } else {
	warn "$0: cannot open $mani: $!\n";
    }
    return @@results;
}

unless (@@ARGV) {
    # base first, as TEST bails out if that can't run
    # then comp, to validate that require works
    # then run, to validate that -M works
    # then we know we can -MTestInit for everything else, making life simpler
    foreach my $dir (qw(base comp run cmd io re opbasic op uni mro perf)) {
	_find_tests($dir);
    }
    unless ($::core) {
	_find_tests('porting');
	_find_tests("lib"); 
    }
    # Config.pm may be broken for make minitest. And this is only a refinement
    # for skipping tests on non-default builds, so it is allowed to fail.
    # What we want to to is make a list of extensions which we did not build.
    my $configsh = '../config.sh';
    my ($extensions, $known_extensions);
    if (-f $configsh) {
	open FH, $configsh or die "Can't open $configsh: $!";
	while (<FH>) {
	    if (/^extensions=['"](.*)['"]$/) {
		$extensions = $1;
	    }
	    elsif (/^known_extensions=['"](.*)['"]$/) {
		$known_extensions = $1;
	    }
	}
	if (!defined $known_extensions) {
	    warn "No known_extensions line found in $configsh";
	}
	if (!defined $extensions) {
	    warn "No extensions line found in $configsh";
	}
    }
    # The "complex" constructions of list return from a subroutine, and push of
    # a list, might fail if perl is really hosed, but they aren't needed for
    # make minitest, and the building of extensions will likely also fail if
    # something is that badly wrong.
    push @@ARGV, _tests_from_manifest($extensions, $known_extensions);
    unless ($::core) {
	_find_tests('japh') if $::torture;
	_find_tests('benchmark') if $::benchmark or $ENV{PERL_BENCHMARK};
	_find_tests('bigmem') if $ENV{PERL_TEST_MEMORY};
    }
}

if ($::deparse) {
    _testprogs('deparse', '',   @@ARGV);
}
elsif ($::with_utf16) {
    for my $e (0, 1) {
	for my $b (0, 1) {
	    print STDERR "# ENDIAN $e BOM $b\n";
	    my @@UARGV;
	    for my $a (@@ARGV) {
		my $u = $a . "." . ($e ? "l" : "b") . "e" . ($b ? "b" : "");
		my $f = $e ? "v" : "n";
		push @@UARGV, $u;
		unlink($u);
		if (open(A, $a)) {
		    if (open(U, ">$u")) {
			print U pack("$f", 0xFEFF) if $b;
			while (<A>) {
			    print U pack("$f*", unpack("C*", $_));
			}
			close(U);
		    }
		    close(A);
		}
	    }
	    _testprogs('perl', '', @@UARGV);
	    unlink(@@UARGV);
	}
    }
}
else {
    _testprogs('perl',    '',   @@ARGV);
}

sub _testprogs {
    my ($type, $args, @@tests) = @@_;

    print <<'EOT' if ($type eq 'deparse');
------------------------------------------------------------------------------
TESTING DEPARSER
------------------------------------------------------------------------------
EOT

    $::bad_files = 0;

    foreach my $t (@@tests) {
      unless (exists $::path_to_name{$t}) {
	my $tname = "t/$t";
	$::path_to_name{$t} = $tname;
      }
    }
    my $maxlen = 0;
    foreach (@@::path_to_name{@@tests}) {
	s/\.\w+\z/ /; # space gives easy doubleclick to select fname
	my $len = length ;
	$maxlen = $len if $len > $maxlen;
    }
    # + 3 : we want three dots between the test name and the "ok"
    my $dotdotdot = $maxlen + 3 ;
    my $grind_ct = 0;		# count of non-empty valgrind reports
    my $total_files = @@tests;
    my $good_files = 0;
    my $tested_files  = 0;
    my $totmax = 0;
    my %failed_tests;
    my $toolnm;		# valgrind, cachegrind, perf

    while (my $test = shift @@tests) {
        my ($test_start_time, @@starttimes) = 0;
	if ($show_elapsed_time) {
	    $test_start_time = Time::HiRes::time();
	    # times() reports usage by TEST, but we want usage of each
	    # testprog it calls, so record accumulated times now,
	    # subtract them out afterwards.  Ideally, we'd take times
	    # in BEGIN/END blocks (giving better visibility of self vs
	    # children of each testprog), but that would require some
	    # IPC to send results back here, or a completely different
	    # collection scheme (Storable isn't tuned for incremental use)
	    @@starttimes = times;
	}
	if ($test =~ /^$/) {
	    next;
	}
	if ($type eq 'deparse' && $test =~ $deparse_skips) {
	    next;
	}
	my $te = $::path_to_name{$test} . '.'
		    x ($dotdotdot - length($::path_to_name{$test})) .' ';

	if ($^O ne 'VMS') {  # defer printing on VMS due to piping bug
	    print $te;
	    $te = '';
	}

	(local $Valgrind_Log = "$test.valgrind-current") =~ s/^.*\///;

	my $results = _run_test($test, $type);

	my $failure;
	my $next = 0;
	my $seen_leader = 0;
	my $seen_ok = 0;
	my $trailing_leader = 0;
	my $max;
	my %todo;
	while (<$results>) {
	    next if /^\s*$/; # skip blank lines
	    if (/^1..$/ && ($^O eq 'VMS')) {
		# VMS pipe bug inserts blank lines.
		my $l2 = <$results>;
		if ($l2 =~ /^\s*$/) {
		    $l2 = <$results>;
		}
		$_ = '1..' . $l2;
	    }
	    if ($::verbose) {
		print $_;
	    }
	    unless (/^\#/) {
		if ($trailing_leader) {
		    # shouldn't be anything following a postfix 1..n
		    $failure = 'FAILED--extra output after trailing 1..n';
		    last;
		}
		if (/^1\.\.([0-9]+)( todo ([\d ]+))?/) {
		    if ($seen_leader) {
			$failure = 'FAILED--seen duplicate leader';
			last;
		    }
		    $max = $1;
		    %todo = map { $_ => 1 } split / /, $3 if $3;
		    $totmax = $totmax + $max;
		    $tested_files = $tested_files + 1;
		    if ($seen_ok) {
			# 1..n appears at end of file
			$trailing_leader = 1;
			if ($next != $max) {
			    $failure = "FAILED--expected $max tests, saw $next";
			    last;
			}
		    }
		    else {
			$next = 0;
		    }
		    $seen_leader = 1;
		}
		else {
		    if (/^(not )?ok(?: (\d+))?[^\#]*(\s*\#.*)?/) {
			unless ($seen_leader) {
			    unless ($seen_ok) {
				$next = 0;
			    }
			}
			$seen_ok = 1;
			$next = $next + 1;
			my($not, $num, $extra, $istodo) = ($1, $2, $3, 0);
			$num = $next unless $num;

			if ($num == $next) {

			    # SKIP is essentially the same as TODO for t/TEST
			    # this still conforms to TAP:
			    # http://testanything.org/wiki/index.php/TAP_specification
			    $extra and $istodo = $extra =~ /#\s*(?:TODO|SKIP)\b/;
			    $istodo = 1 if $todo{$num};

			    if( $not && !$istodo ) {
				$failure = "FAILED at test $num";
				last;
			    }
			}
			else {
			    $failure ="FAILED--expected test $next, saw test $num";
			    last;
			}
		    }
		    elsif (/^Bail out!\s*(.*)/i) { # magic words
			die "FAILED--Further testing stopped" . ($1 ? ": $1\n" : ".\n");
		    }
		    else {
			# module tests are allowed extra output,
			# because Test::Harness allows it
			next if $test =~ /^\W*(cpan|dist|ext|lib)\b/;
			$failure = "FAILED--unexpected output at test $next";
			last;
		    }
		}
	    }
	}
	my  @@junk = <$results>;  # dump remaining output to prevent SIGPIPE
				 # (so far happens only on os390)
	close $results;
	undef @@junk;

	if (not defined $failure) {
	    $failure = 'FAILED--no leader found' unless $seen_leader;
	}

	_check_valgrind(\$toolnm, \$grind_ct, \$test);

	if ($type eq 'deparse' && !$ENV{KEEP_DEPARSE_FILES}) {
	    unlink "./$test.dp";
	}
	if (not defined $failure and $next != $max) {
	    $failure="FAILED--expected $max tests, saw $next";
	}

	if( !defined $failure  # don't mask a test failure
	    and $? )
	{
	    $failure = "FAILED--non-zero wait status: $?";
	}

	# Deparse? Should it have passed or failed?
	if ($type eq 'deparse' && $test =~ $deparse_failures) {
	    if (!$failure) {
		# Wait, it didn't fail? Great news! Tell someone!
		$failure = "FAILED--all tests passed but test should have failed";
	    } else {
		# Bah, still failing. Mask it.
		print "${te}skipped\n";
		$tested_files = $tested_files - 1;
		next;
	    }
	}

	if (defined $failure) {
	    print "${te}$failure\n";
	    $::bad_files = $::bad_files + 1;
	    if ($test =~ /^base/ && ! defined &DynaLoader::boot_DynaLoader) {
		# Die if running under minitest (no DynaLoader).  Otherwise
		# keep going, as  we know that Perl basically works, or we
		# would not have been able to actually compile it all the way.
		die "Failed a basic test ($test) under minitest -- cannot continue.\n";
	    }
	    $failed_tests{$test} = 1;
	}
	else {
	    if ($max) {
		my ($elapsed, $etms) = ("", 0);
		if ( $show_elapsed_time ) {
		    $etms = (Time::HiRes::time() - $test_start_time) * 1000;
		    $elapsed = sprintf(" %8.0f ms", $etms);

		    my (@@endtimes) = times;
		    $endtimes[$_] -= $starttimes[$_] for 0..$#endtimes;
		    splice @@endtimes, 0, 2;    # drop self/harness times
		    $_ *= 1000 for @@endtimes;  # and scale to ms
		    $timings{$test} = [$etms,@@endtimes];
		    $elapsed .= sprintf(" %5.0f ms", $_) for @@endtimes;
		}
		print "${te}ok$elapsed\n";
		$good_files = $good_files + 1;
	    }
	    else {
		print "${te}skipped\n";
		$tested_files = $tested_files - 1;
	    }
	}
    } # while tests

    if ($::bad_files == 0) {
	if ($good_files) {
	    print "All tests successful.\n";
	    # XXX add mention of 'perlbug -ok' ?
	}
	else {
	    die "FAILED--no tests were run for some reason.\n";
	}
    }
    else {
	my $pct = $tested_files ? sprintf("%.2f", ($tested_files - $::bad_files) / $tested_files * 100) : "0.00";
	my $s = $::bad_files == 1 ? "" : "s";
	warn "Failed $::bad_files test$s out of $tested_files, $pct% okay.\n";
	for my $test ( sort keys %failed_tests ) {
	    print "\t$test\n";
	}
	warn <<'SHRDLU_1';
### Since not all tests were successful, you may want to run some of
### them individually and examine any diagnostic messages they produce.
### See the INSTALL document's section on "make test".
SHRDLU_1
	warn <<'SHRDLU_2' if $good_files / $total_files > 0.8;
### You have a good chance to get more information by running
###   ./perl harness
### in the 't' directory since most (>=80%) of the tests succeeded.
SHRDLU_2
	if (eval {require Config; import Config; 1}) {
	    if ($::Config{usedl} && (my $p = $::Config{ldlibpthname})) {
		warn <<SHRDLU_3;
### You may have to set your dynamic library search path,
### $p, to point to the build directory:
SHRDLU_3
		if (exists $ENV{$p} && $ENV{$p} ne '') {
		    warn <<SHRDLU_4a;
###   setenv $p `pwd`:\$$p; cd t; ./perl harness
###   $p=`pwd`:\$$p; export $p; cd t; ./perl harness
###   export $p=`pwd`:\$$p; cd t; ./perl harness
SHRDLU_4a
		} else {
		    warn <<SHRDLU_4b;
###   setenv $p `pwd`; cd t; ./perl harness
###   $p=`pwd`; export $p; cd t; ./perl harness
###   export $p=`pwd`; cd t; ./perl harness
SHRDLU_4b
		}
		warn <<SHRDLU_5;
### for csh-style shells, like tcsh; or for traditional/modern
### Bourne-style shells, like bash, ksh, and zsh, respectively.
SHRDLU_5
	    }
	}
    }
    printf "Elapsed: %d sec\n", time() - $t0;
    my ($user,$sys,$cuser,$csys) = times;
    my $tot = sprintf("u=%.2f  s=%.2f  cu=%.2f  cs=%.2f  scripts=%d  tests=%d",
		      $user,$sys,$cuser,$csys,$tested_files,$totmax);
    print "$tot\n";
    if ($good_files) {
	if (-d $show_elapsed_time) {
	    # HARNESS_TIMER = <a-directory>.  Save timings etc to
	    # storable file there.  NB: the test cds to ./t/, so
	    # relative path must account for that, ie ../../perf
	    # points to dir next to source tree.
	    require Storable;
	    my @@dt = localtime;
	    $dt[5] += 1900; $dt[4] += 1; # fix year, month
	    my $fn = "$show_elapsed_time/".join('-', @@dt[5,4,3,2,1]).".ttimes";
	    Storable::store({ perf => \%timings,
			      gather_conf_platform_info(),
			      total => $tot,
			    }, $fn);
	    print "wrote storable file: $fn\n";
	}
    }

    _cleanup_valgrind(\$toolnm, \$grind_ct);
}
exit ($::bad_files != 0);

# Collect platform, config data that should allow comparing
# performance data between different machines.  With enough data,
# and/or clever statistical analysis, it should be possible to
# determine the effect of config choices, more memory, etc

sub gather_conf_platform_info {
    # currently rather quick & dirty, and subject to change
    # for both content and format.
    require Config;
    my (%conf, @@platform) = ();
    $conf{$_} = $Config::Config{$_} for
	grep /cc|git|config_arg\d+/, keys %Config::Config;
    if (-f '/proc/cpuinfo') {
	open my $fh, '/proc/cpuinfo' or warn "$!: /proc/cpuinfo\n";
	@@platform = grep /name|cpu/, <$fh>;
	chomp $_ for @@platform;
    }
    unshift @@platform, $^O;

    return (
	conf => \%conf,
	platform => {cpu => \@@platform,
		     mem => [ grep s/\s+/ /,
			      grep chomp, `free` ],
		     load => [ grep chomp, `uptime` ],
	},
	host => (grep chomp, `hostname -f`),
	version => '0.03', # bump for conf, platform, or data collection changes
	);
}

sub _check_valgrind {
    return unless $ENV{PERL_VALGRIND};

    my ($toolnm, $grind_ct, $test) = @@_;

    $$toolnm = $ENV{VALGRIND};
    $$toolnm =~ s|.*/||;  # keep basename
    my @@valgrind;	# gets content of file
    if (-e $Valgrind_Log) {
	if (open(V, $Valgrind_Log)) {
	    @@valgrind = <V>;
	    close V;
	} else {
	    warn "$0: Failed to open '$Valgrind_Log': $!\n";
	}
    }
    if ($ENV{VG_OPTS} =~ /(cachegrind)/ or $$toolnm =~ /(perf)/) {
	$$toolnm = $1;
	if ($$toolnm eq 'perf') {
	    # append perfs subcommand, not just stat
	    my ($sub) = split /\s/, $ENV{VG_OPTS};
	    $$toolnm .= "-$sub";
	}
	if (rename $Valgrind_Log, "$$test.$$toolnm") {
	    $$grind_ct++;
	} else {
	    warn "$0: Failed to create '$$test.$$toolnm': $!\n";
	}
    }
    elsif (@@valgrind) {
	my $leaks = 0;
	my $errors = 0;
	for my $i (0..$#valgrind) {
	    local $_ = $valgrind[$i];
	    if (/^==\d+== ERROR SUMMARY: (\d+) errors? /) {
		$errors = $errors + $1;   # there may be multiple error summaries
	    } elsif (/^==\d+== LEAK SUMMARY:/) {
		for my $off (1 .. 4) {
		    if ($valgrind[$i+$off] =~
			/(?:lost|reachable):\s+\d+ bytes in (\d+) blocks/) {
			    $leaks = $leaks + $1;
		    }
		}
	    }
	}
	if ($errors or $leaks) {
	    if (rename $Valgrind_Log, "$$test.valgrind") {
		$$grind_ct = $$grind_ct + 1;
	    } else {
		warn "$0: Failed to create '$$test.valgrind': $!\n";
	    }
	}
    } else {
        # Quiet wasn't asked for? Something may be amiss
	if ($ENV{VG_OPTS} && $ENV{VG_OPTS} !~ /(^|\s)(-q|--quiet)(\s|$)/) {
	    warn "No valgrind output?\n";
	}
    }
    if (-e $Valgrind_Log) {
	unlink $Valgrind_Log
	    or warn "$0: Failed to unlink '$Valgrind_Log': $!\n";
    }
}

sub _cleanup_valgrind {
    return unless $ENV{PERL_VALGRIND};

    my ($toolnm, $grind_ct) = @@_;
    my $s = $$grind_ct == 1 ? '' : 's';
    print "$$grind_ct valgrind report$s created.\n", ;
    if ($$toolnm eq 'cachegrind') {
	# cachegrind leaves a lot of cachegrind.out.$pid litter
	# around the tree, find and delete them
	unlink _find_files('cachegrind.out.\d+$',
		     qw ( ../t ../cpan ../ext ../dist/ ));
    }
}

# Generate regexps of known bad filenames / skips from Porting/deparse-skips.txt
my $in;

sub _process_deparse_config {
    my @@deparse_failures;
    my @@deparse_skips;

    my $f = '../Porting/deparse-skips.txt';

    my $skips;
    if (!open($skips, '<', $f)) {
        warn "Failed to find $f: $!\n";
        return;
    }

    while(<$skips>) {
        if (/__DEPARSE_FAILURES__/) {
            $in = \@@deparse_failures; next;
        } elsif (/__DEPARSE_SKIPS__/) {
            $in = \@@deparse_skips; next;
        } elsif (!$in) {
            next;
	}

        s/#.*$//; # Kill comments
        s/\s+$//; # And trailing whitespace

        next unless $_;

        push @@$in, $_;
    }

    for my $f (@@deparse_failures, @@deparse_skips) {
        if ($f =~ m|/$|) { # Dir? Skip everything below it
            $f = qr/\Q$f\E.*/;
        } else {
            $f = qr/\Q$f\E/;
        }
    }

    $deparse_failures = join('|', @@deparse_failures);
    $deparse_failures = qr/^(?:$deparse_failures)$/;

    $deparse_skips = join('|', @@deparse_skips);
    $deparse_skips = qr/^(?:$deparse_skips)$/;
}

# ex: set ts=8 sts=4 sw=4 noet:
@


1.16
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d17 8
a41 1
	   '../cpan/Class-ISA' => 1,
d45 1
d47 1
a51 1
	   '../cpan/Module-Build' => 1,
a53 1
	   '../cpan/Package-Constants' => 1,
a58 3
	   '../dist/ExtUtils-Command' => 1,
	   '../dist/ExtUtils-Install' => 1,
	   '../dist/ExtUtils-Manifest' => 1,
d100 13
a116 3
# Location to put the Valgrind log.
our $Valgrind_Log;

d125 5
d148 1
a171 9
my %skip = (
	    '.' => 1,
	    '..' => 1,
	    'CVS' => 1,
	    'RCS' => 1,
	    'SCCS' => 1,
	    '.svn' => 1,
	   );

d227 1
a227 1
    my $perl = './perl';
d298 3
d302 1
a302 1
              // '--log-fd=3 '
d305 5
a309 1
                  . "--num-callers=50 --track-origins=yes";
a310 4
            $redir = "3>$Valgrind_Log";
            if ($options->{run_dir}) {
                $Valgrind_Log = "$options->{run_dir}/$Valgrind_Log";
            }
d327 10
d411 5
d443 1
a443 1
    foreach my $dir (qw(base comp run cmd io re opbasic op uni mro)) {
a477 1
	_find_tests('x2p');
d479 1
a479 1
	_find_tests('t/benchmark') if $::benchmark or $ENV{PERL_BENCHMARK};
d566 2
a567 9
	if ($type eq 'deparse') {
	    if ($test eq "comp/redef.t") {
		# Redefinition happens at compile time
		next;
	    }
	    elsif ($test =~ m{lib/Switch/t/}) {
		# B::Deparse doesn't support source filtering
		next;
	    }
d577 2
a578 1
        (local $Valgrind_Log = "$test.valgrind-current") =~ s/^.*\///;
d672 2
d675 1
d681 3
a683 57
	if ($ENV{PERL_VALGRIND}) {
	    $toolnm = $ENV{VALGRIND};
	    $toolnm =~ s|.*/||;  # keep basename
	    my @@valgrind;	# gets content of file
	    if (-e $Valgrind_Log) {
		if (open(V, $Valgrind_Log)) {
		    @@valgrind = <V>;
		    close V;
		} else {
		    warn "$0: Failed to open '$Valgrind_Log': $!\n";
		}
	    }
	    if ($ENV{VG_OPTS} =~ /(cachegrind)/ or $toolnm =~ /(perf)/) {
		$toolnm = $1;
		if ($toolnm eq 'perf') {
		    # append perfs subcommand, not just stat
		    my ($sub) = split /\s/, $ENV{VG_OPTS};
		    $toolnm .= "-$sub";
		}
		if (rename $Valgrind_Log, "$test.$toolnm") {
		    $grind_ct++;
		} else {
		    warn "$0: Failed to create '$test.$toolnm': $!\n";
		}
	    }
	    elsif (@@valgrind) {
		my $leaks = 0;
		my $errors = 0;
		for my $i (0..$#valgrind) {
		    local $_ = $valgrind[$i];
		    if (/^==\d+== ERROR SUMMARY: (\d+) errors? /) {
			$errors = $errors + $1;   # there may be multiple error summaries
		    } elsif (/^==\d+== LEAK SUMMARY:/) {
			for my $off (1 .. 4) {
			    if ($valgrind[$i+$off] =~
				/(?:lost|reachable):\s+\d+ bytes in (\d+) blocks/) {
				$leaks = $leaks + $1;
			    }
			}
		    }
		}
		if ($errors or $leaks) {
		    if (rename $Valgrind_Log, "$test.valgrind") {
			$grind_ct = $grind_ct + 1;
		    } else {
			warn "$0: Failed to create '$test.valgrind': $!\n";
		    }
		}
	    } else {
		warn "No valgrind output?\n";
	    }
	    if (-e $Valgrind_Log) {
		unlink $Valgrind_Log
		    or warn "$0: Failed to unlink '$Valgrind_Log': $!\n";
	    }
	}
	if ($type eq 'deparse') {
d696 13
d796 1
d818 2
a819 10
    if ($ENV{PERL_VALGRIND}) {
	my $s = $grind_ct == 1 ? '' : 's';
	print "$grind_ct valgrind report$s created.\n", ;
	if ($toolnm eq 'cachegrind') {
	    # cachegrind leaves a lot of cachegrind.out.$pid litter
	    # around the tree, find and delete them
	    unlink _find_files('cachegrind.out.\d+$',
			     qw ( ../t ../cpan ../ext ../dist/ ));
	}
    }
d852 125
@


1.15
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@a30 1
	   '../cpan/Archive-Extract' => 1,
a42 1
	   '../cpan/Log-Message' => 1,
a45 1
	   '../cpan/Object-Accessor' => 1,
a48 1
	   '../cpan/Term-UI' => 1,
a141 15
if ($ENV{PERL_3LOG}) { # Tru64 third(1) tool, see perlhack
    unless (-x 'perl.third') {
	unless (-x '../perl.third') {
	    die "You need to run \"make perl.third first.\n";
	}
	else {
	    print "Symlinking ../perl.third as perl.third...\n";
	    die "Failed to symlink: $!\n"
		unless symlink("../perl.third", "perl.third");
	    die "Symlinked but no executable perl.third: $!\n"
		unless -x 'perl.third';
	}
    }
}

a714 8
	if ($ENV{PERL_3LOG}) {
	    my $tpp = $test;
	    $tpp =~ s:^\.\./::;
	    $tpp =~ s:/:_:g;
	    $tpp =~ s:\.t$:.3log:;
	    rename("perl.3log", $tpp) ||
		die "rename: perl3.log to $tpp: $!\n";
	}
d728 5
a732 2
	    if ($test =~ /^base/) {
		die "Failed a basic test ($test) -- cannot continue.\n";
@


1.14
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d5 1
a5 1
# probably obsolete on the avoidance side, though still currrent
d26 2
a27 2
# "not absolute" is the the default, as it saves some fakery within TestInit
# which can peturb tests, and takes CPU. Working with the upstream author of
d433 1
a433 1
    foreach my $dir (qw(base comp run cmd io re op uni mro)) {
d471 1
d551 1
a551 1
	    # collection scheme (Storable isnt tuned for incremental use)
d589 1
a589 1
		my $l2 = <RESULTS>;
d591 1
a591 1
		    $l2 = <RESULTS>;
@


1.13
log
@merge in perl 5.12.2 plus local changes
@
text
@a35 1
	   '../cpan/Cwd' => 1,
a37 1
	   '../cpan/ExtUtils-Command' => 1,
a39 2
	   '../cpan/ExtUtils-Manifest' => 1,
	   '../cpan/ExtUtils-ParseXS' => 1,
a44 3
	   '../cpan/Math-BigInt' => 1,
	   '../cpan/Math-BigRat' => 1,
	   '../cpan/Math-Complex' => 1,
a53 2
	   '../cpan/Tie-File' => 1,
	   '../cpan/bignum' => 1,
d55 2
d58 3
d62 1
a62 1
	      
a69 2
     '../cpan/Math-BigInt' => 1,
     '../cpan/Math-BigRat' => 1,
a70 1
     '../cpan/NEXT' => 1,
a76 1
     '../cpan/Time-HiRes' => 1,
a80 13
if ($::do_nothing) {
    return 1;
}

# Location to put the Valgrind log.
my $Valgrind_Log = 'current.valgrind';

$| = 1;

# for testing TEST only
#BEGIN { require '../lib/strict.pm'; "strict"->import() };
#BEGIN { require '../lib/warnings.pm'; "warnings"->import() };

d84 6
a89 1
for my $envname (qw(PERL5LIB PERLLIB PERL5OPT)) {
d100 13
a129 1
	$ENV{PERL_CORE_MINITEST} = 1 if $1 eq 'minitest';
d163 2
d169 1
d181 15
a195 12
sub _find_tests {
    my($dir) = @@_;
    opendir DIR, $dir or die "Trouble opening $dir: $!";
    foreach my $f (sort { $a cmp $b } readdir DIR) {
	next if $skip{$f};

	my $fullpath = "$dir/$f";

	if (-d $fullpath) {
	    _find_tests($fullpath);
	} elsif ($f =~ /\.t$/) {
	    push @@ARGV, $fullpath;
d198 1
d258 2
d304 2
a305 1
            my $valgrind = $ENV{VALGRIND} // 'valgrind';
d307 5
a311 4
              //  "--suppressions=perl.supp --leak-check=yes "
                . "--leak-resolution=high --show-reachable=yes "
                  . "--num-callers=50";
            $perl = "$valgrind --log-fd=3 $vg_opts $perl";
d313 3
a320 1

d408 1
a408 1
			$extension =~ s!/t$!!;
d436 4
a439 1
    _find_tests("lib") unless $::core;
a468 1
	_find_tests('porting');
d526 1
a526 1
	s/\.\w+\z/./;
d532 1
a532 1
    my $valgrind = 0;
d538 1
d541 12
a552 2
        my $test_start_time = $show_elapsed_time ? Time::HiRes::time() : 0;

d567 1
a567 1
		    x ($dotdotdot - length($::path_to_name{$test}));
d574 1
d641 1
a641 1
			    # http://search.cpan.org/dist/TAP/TAP.pm
d675 3
a677 1
	    my @@valgrind;
d686 9
a694 3
	    if ($ENV{VG_OPTS} =~ /cachegrind/) {
		if (rename $Valgrind_Log, "$test.valgrind") {
		    $valgrind = $valgrind + 1;
d696 1
a696 1
		    warn "$0: Failed to create '$test.valgrind': $!\n";
d717 1
a717 1
			$valgrind = $valgrind + 1;
d761 1
a761 1
		my $elapsed;
d763 9
a771 4
		    $elapsed = sprintf( " %8.0f ms", (Time::HiRes::time() - $test_start_time) * 1000 );
		}
		else {
		    $elapsed = "";
d836 20
a855 2
    print sprintf("u=%.2f  s=%.2f  cu=%.2f  cs=%.2f  scripts=%d  tests=%d\n",
	$user,$sys,$cuser,$csys,$tested_files,$totmax);
d857 8
a864 2
	my $s = $valgrind == 1 ? '' : 's';
	print "$valgrind valgrind report$s created.\n", ;
d868 31
@


1.12
log
@Merge in perl 5.10.1
@
text
@d8 88
d99 2
a100 2
#BEGIN { require '../lib/strict.pm'; strict->import() };
#BEGIN { require '../lib/warnings.pm'; warnings->import() };
d102 13
a114 4
# Let tests know they're running in the perl core.  Useful for modules
# which live dual lives on CPAN.
$ENV{PERL_CORE} = 1;
delete $ENV{PERL5LIB};
d120 2
a121 1
# Cheesy version of Getopt::Std.  Maybe we should replace it with that.
d126 1
d143 3
a169 3
# Roll your own File::Find!
use TestInit;
use File::Spec;
a170 2
my $curdir = File::Spec->curdir;
my $updir  = File::Spec->updir;
d172 10
d186 87
a272 2
	next if $f eq $curdir or $f eq $updir or
	    $f =~ /^(?:CVS|RCS|SCCS|\.svn)$/;
d274 43
a316 1
	my $fullpath = File::Spec->catfile($dir, $f);
d318 3
a320 3
	_find_tests($fullpath) if -d $fullpath;
	$fullpath = VMS::Filespec::unixify($fullpath) if $^O eq 'VMS';
	push @@ARGV, $fullpath if $f =~ /\.t$/;
d322 38
d370 1
a370 1
       $argstring .= ' ' . $_;
d376 1
d380 2
a381 9
unless (@@ARGV) {
    foreach my $dir (qw(base comp cmd run io op uni mro)) {
	_find_tests($dir);
    }
    _find_tests("lib") unless $::core;
    # Config.pm may be broken for make minitest. And this is only a refinement
    # for skipping tests on non-default builds, so it is allowed to fail.
    # What we want to to is make a list of extensions which we did not build.
    my $configsh = File::Spec->catfile($updir, "config.sh");
d383 5
a387 24
    if (-f $configsh) {
	my (%extensions, %known_extensions);
	open FH, $configsh or die "Can't open $configsh: $!";
	while (<FH>) {
	    if (/^extensions=['"](.*)['"]$/) {
		# Deliberate string interpolation to avoid triggering possible
		# $1 resetting bugs.
		%extensions = _populate_hash ("$1");
	    }
	    elsif (/^known_extensions=['"](.*)['"]$/) {
		%known_extensions = _populate_hash ($1);
	    }
	}
	if (%extensions) {
	    if (%known_extensions) {
		foreach (keys %known_extensions) {
		    $skip{$_}++ unless $extensions{$_};
		}
	    } else {
		warn "No known_extensions line found in $configsh";
	    }
	} else {
	    warn "No extensions line found in $configsh";
	}
d389 3
a391 1
    my $mani = File::Spec->catfile($updir, "MANIFEST");
d393 2
a394 2
	while (<MANI>) { # similar code in t/harness
	    if (m!^(ext/(\S+)/+(?:[^/\s]+\.t|test\.pl)|lib/\S+?(?:\.t|test\.pl))\s!) {
d397 1
a397 2
		if (!$::core || $t =~ m!^lib/[a-z]!)
		{
d406 2
a407 2
		    my $path = File::Spec->catfile($updir, $t);
		    push @@ARGV, $path;
d416 39
a455 1
	_find_tests('pod');
d457 1
d459 1
d509 1
a509 2
	my $tname = File::Spec->catfile('t',$t);
	$tname = VMS::Filespec::unixify($tname) if $^O eq 'VMS';
a521 1
    my $valgrind_log = 'current.valgrind';
d552 1
a552 65
	# XXX DAPM %OVER not defined anywhere
	# $test = $OVER{$test} if exists $OVER{$test};

	open(SCRIPT,"<",$test) or die "Can't run $test.\n";
	$_ = <SCRIPT>;
	close(SCRIPT) unless ($type eq 'deparse');
	if ($::with_utf16) {
	    $_ =~ tr/\0//d;
	}
	my $switch;
	if (/#!.*\bperl.*\s-\w*([tT])/) {
	    $switch = qq{"-$1"};
	}
	else {
	    if ($::taintwarn) {
		# not all tests are expected to pass with this option
		$switch = '"-t"';
	    }
	    else {
		$switch = '';
	    }
	}

	my $file_opts = "";
	if ($type eq 'deparse') {
	    # Look for #line directives which change the filename
	    while (<SCRIPT>) {
		$file_opts .= ",-f$3$4"
			if /^#\s*line\s+(\d+)\s+((\w+)|"([^"]+)")/;
	    }
	    close(SCRIPT);
	}

	my $utf8 = $::with_utf8 ? '-I../lib -Mutf8' : '';
	my $testswitch = '-I. -MTestInit'; # -T will strict . from @@INC
	if ($type eq 'deparse') {
	    my $deparse_cmd =
		"./perl $testswitch $switch -I../lib -MO=-qq,Deparse,-sv1.,".
		"-l$::deparse_opts$file_opts ".
		"$test > $test.dp ".
		"&& ./perl $testswitch $switch -I../lib $test.dp |";
	    open(RESULTS, $deparse_cmd)
		or print "can't deparse '$deparse_cmd': $!.\n";
	}
	elsif ($type eq 'perl') {
	    my $perl = $ENV{PERL} || './perl';
	    my $redir = $^O eq 'VMS' ? '2>&1' : '';
	    if ($ENV{PERL_VALGRIND}) {
		my $valgrind = $ENV{VALGRIND} // 'valgrind';
		my $vg_opts = $ENV{VG_OPTS}
		    //  "--suppressions=perl.supp --leak-check=yes "
			. "--leak-resolution=high --show-reachable=yes "
			. "--num-callers=50"; 
		$perl = "$valgrind --log-fd=3 $vg_opts $perl";
		$redir = "3>$valgrind_log";
	    }
	    my $run = "$perl" . _quote_args("$testswitch $switch $utf8")
			      . " $test $redir|";
	    open(RESULTS,$run) or print "can't run '$run': $!.\n";
	}
	# Our environment may force us to use UTF-8, but we can't be sure that
	# anything we're reading from will be generating (well formed) UTF-8
	# This may not be the best way - possibly we should unset ${^OPEN} up
	# top?
	binmode RESULTS;
d561 1
a561 1
	while (<RESULTS>) {
d587 2
a588 2
		    $totmax += $max;
		    $tested_files++;
d610 1
a610 1
			$next++;
d618 1
a618 1
			    # http://search.cpan.org/dist/TAP/TAP.pod
d638 1
a638 1
			next if $test =~ /^\W*(ext|lib)\b/;
d645 1
a645 1
	close RESULTS;
d653 2
a654 2
	    if (-e $valgrind_log) {
		if (open(V, $valgrind_log)) {
d658 1
a658 1
		    warn "$0: Failed to open '$valgrind_log': $!\n";
d662 2
a663 2
		if (rename $valgrind_log, "$test.valgrind") {
		    $valgrind++;
d674 1
a674 1
			$errors += $1;   # there may be multiple error summaries
d679 1
a679 1
				$leaks += $1;
d685 2
a686 2
		    if (rename $valgrind_log, "$test.valgrind") {
			$valgrind++;
d694 3
a696 3
	    if (-e $valgrind_log) {
		unlink $valgrind_log
		    or warn "$0: Failed to unlink '$valgrind_log': $!\n";
d722 1
a722 1
	    $::bad_files++;
d726 1
a726 1
	    ++$failed_tests{$test};
d738 1
a738 1
		$good_files++;
d742 1
a742 1
		$tested_files -= 1;
@


1.11
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d17 1
a143 1
	my $ext_pat = $^O eq 'MSWin32' ? '(?:win32/)?ext' : 'ext';
d145 1
a145 1
	    if (m!^($ext_pat/(\S+)/+(?:[^/\s]+\.t|test\.pl)|lib/\S+?(?:\.t|test\.pl))\s!) {
d154 3
a168 1
	_find_tests('Module_Pluggable');
d341 8
d396 1
a396 1
			    # http://search.cpan.org/dist/Test-Harness/lib/Test/Harness/TAP.pod
@


1.10
log
@merge in perl 5.8.8
@
text
@a31 2
	$::bytecompile = 1 if $1 eq 'bytecompile';
	$::compile = 1 if $1 eq 'compile';
d107 1
a107 1
    foreach my $dir (qw(base comp cmd run io op uni)) {
d143 1
d145 1
a145 1
	    if (m!^(ext/(\S+)/+(?:[^/\s]+\.t|test\.pl)|lib/\S+?(?:\.t|test\.pl))\s!) {
d166 1
a172 4
# Tests known to cause infinite loops for the perlcc tests.
# %::infinite = ( 'comp/require.t', 1, 'op/bop.t', 1, 'lib/hostname.t', 1 );
%::infinite = ();

a175 6
elsif( $::compile ) {
    _testprogs('compile', '',   @@ARGV);
}
elsif( $::bytecompile ) {
    _testprogs('bytecompile', '', @@ARGV);
}
a202 1
    _testprogs('compile', '',   @@ARGV) if -e "../testcompile";
a208 6
    print <<'EOT' if ($type eq 'compile');
------------------------------------------------------------------------------
TESTING COMPILER
------------------------------------------------------------------------------
EOT

a214 9
    print <<EOT if ($type eq 'bytecompile');
------------------------------------------------------------------------------
TESTING BYTECODE COMPILER
------------------------------------------------------------------------------
EOT

    $ENV{PERLCC_TIMEOUT} = 120
	  if ($type eq 'compile' && !$ENV{PERLCC_TIMEOUT});

d238 1
a242 4
	if ( $::infinite{$test} && $type eq 'compile' ) {
	    print STDERR "$test creates infinite loop! Skipping.\n";
	    next;
	}
a286 1
	my $test_executable; # for 'compile' tests
a307 25
	elsif ($type eq 'bytecompile') {
	    my ($pwd, $null);
	    if( $^O eq 'MSWin32') {
		$pwd = `cd`;
		$null = 'nul';
	    } else {
		$pwd = `pwd`;
		$null = '/dev/null';
	    }
	    chomp $pwd;
	    my $perl = $ENV{PERL} || "$pwd/perl";
	    my $bswitch = "-MO=Bytecode,-H,-TI,-s$pwd/$test,";
	    $bswitch .= "-TF$test.plc,"
		if $test =~ m(chdir|pod/|CGI/t/carp|lib/DB);
	    $bswitch .= "-k,"
		if $test =~ m(deparse|terse|ext/Storable/t/code);
	    $bswitch .= "-b,"
		if $test =~ m(op/getpid);
	    my $bytecompile_cmd =
		"$perl $testswitch $switch -I../lib $bswitch".
		"-o$test.plc $test 2>$null &&".
		"$perl $testswitch $switch -I../lib $utf8 $test.plc |";
	    open(RESULTS,$bytecompile_cmd)
		or print "can't byte-compile '$bytecompile_cmd': $!.\n";
	}
d312 6
a317 3
		$perl = "valgrind --suppressions=perl.supp --leak-check=yes "
			       . "--leak-resolution=high --show-reachable=yes "
			       . "--num-callers=50 --logfile-fd=3 $perl";
d324 5
a328 32
	else {
	    my $compile_cmd;
	    my $pl2c = "$testswitch -I../lib ../utils/perlcc --testsuite " .
	      # -O9 for good measure, -fcog is broken ATM
		       "$switch -Wb=-O9,-fno-cog -L .. " .
		       "-I \".. ../lib/CORE\" $args $utf8 $test -o ";

	    if( $^O eq 'MSWin32' ) {
		$test_executable = "$test.exe";
		# hopefully unused name...
		open HACK, "> xweghyz.pl";
		print HACK <<EOT;
#!./perl

open HACK, '.\\perl $pl2c $test_executable |';
# cl.exe prints the name of the .c file on stdout (\%^\$^#)
while(<HACK>) {m/^\\w+\\.[cC]\$/ && next;print}
open HACK, '$test_executable |';
while(<HACK>) {print}
EOT
		close HACK;
		$compile_cmd = 'xweghyz.pl |';
	    }
	    else {
		$test_executable = "$test.plc";
		$compile_cmd
		    = "./perl $pl2c $test_executable && $test_executable |";
	    }
	    unlink $test_executable if -f $test_executable;
	    open(RESULTS, $compile_cmd)
		or print "can't compile '$compile_cmd': $!.\n";
	}
d404 3
d429 8
a436 1
	    if (@@valgrind) {
a477 4
	# test if the compiler compiled something
	if( $type eq 'compile' && !-e "$test_executable" ) {
	    $failure = "Test did not compile";
	}
d482 6
d491 2
a492 3
	    $_ = $test;
	    if (/^base/) {
		die "Failed a basic test--cannot continue.\n";
d494 1
d509 1
a509 1
		print "${te}skipping test on this platform\n";
d526 4
a529 5
	if ($::bad_files == 1) {
	    warn "Failed 1 test script out of $tested_files, $pct% okay.\n";
	}
	else {
	    warn "Failed $::bad_files test scripts out of $tested_files, $pct% okay.\n";
d576 2
@


1.9
log
@sync in-tree perl with 5.8.6
@
text
@d10 4
d20 1
d23 2
a24 2
@@argv = ();
if ($#ARGV >= 0) {
d27 8
a34 8
	$core    = 1 if $1 eq 'core';
	$verbose = 1 if $1 eq 'v';
	$torture = 1 if $1 eq 'torture';
	$with_utf8 = 1 if $1 eq 'utf8';
	$with_utf16 = 1 if $1 eq 'utf16';
	$bytecompile = 1 if $1 eq 'bytecompile';
	$compile = 1 if $1 eq 'compile';
	$taintwarn = 1 if $1 eq 'taintwarn';
d37 2
a38 2
	    $deparse = 1;
	    $deparse_opts = $1;
d41 1
a42 1
@@ARGV = @@argv;
d72 1
d80 1
a80 1
        next if $f eq $curdir or $f eq $updir or
d83 1
a83 1
        my $fullpath = File::Spec->catfile($dir, $f);
d85 3
a87 3
        _find_tests($fullpath) if -d $fullpath;
        $fullpath = VMS::Filespec::unixify($fullpath) if $^O eq 'VMS';
        push @@ARGV, $fullpath if $f =~ /\.t$/;
d104 4
d110 32
a141 1
        _find_tests($dir);
a142 1
    _find_tests("lib") unless $core;
d145 5
a149 4
        while (<MANI>) { # similar code in t/harness
	    if (m!^(ext/\S+/?(?:[^/\s]+\.t|test\.pl)|lib/\S+?(?:\.t|test\.pl))\s!) {
		$t = $1;
		if (!$core || $t =~ m!^lib/[a-z]!)
d151 6
a156 1
		    $path = File::Spec->catfile($updir, $t);
d158 1
a158 1
		    $name{$path} = $t;
d164 1
a164 1
        warn "$0: cannot open $mani: $!\n";
d166 1
a166 1
    unless ($core) {
d169 1
a169 1
	_find_tests('japh') if $torture;
d174 2
a175 2
# %infinite = ( 'comp/require.t', 1, 'op/bop.t', 1, 'lib/hostname.t', 1 );
%infinite = ();
d177 1
a177 1
if ($deparse) {
d180 1
a180 1
elsif( $compile ) { 
d183 1
a183 1
elsif( $bytecompile ) {
d186 1
a186 1
elsif ($with_utf16) {
d202 1
a202 1
			close(A);
d204 1
a204 1
		    close(B);
d218 1
a218 3
    $type = shift @@_;
    $args = shift;
    @@tests = @@_;
d239 1
a239 1
          if ($type eq 'compile' && !$ENV{PERLCC_TIMEOUT});
d241 1
a241 5
    $bad = 0;
    $good = 0;
    $total = @@tests;
    $files  = 0;
    $totmax = 0;
d244 4
a247 4
      unless (exists $name{$t}) {
        my $tname = File::Spec->catfile('t',$t);
        $tname = VMS::Filespec::unixify($tname) if $^O eq 'VMS';
        $name{$t} = $tname;
d251 1
a251 1
    foreach (@@name{@@tests}) {
d257 1
a257 1
    $dotdotdot = $maxlen + 3 ;
d260 7
a266 1
    while ($test = shift @@tests) {
d268 1
a268 1
	if ( $infinite{$test} && $type eq 'compile' ) {
d270 1
a270 1
            next;
d285 2
a286 1
	$te = $name{$test} . '.' x ($dotdotdot - length($name{$test}));
d293 2
a294 1
	$test = $OVER{$test} if exists $OVER{$test};
d296 4
a299 4
 	open(SCRIPT,"<$test") or die "Can't run $test.\n";
 	$_ = <SCRIPT>;
 	close(SCRIPT) unless ($type eq 'deparse');
	if ($with_utf16) {
d302 6
a307 5
 	if (/#!.*\bperl.*\s-\w*([tT])/) {
 	    $switch = qq{"-$1"};
 	}
 	else {
	    if ($taintwarn) {
d314 1
a314 1
 	}
d316 1
a316 1
        my $test_executable; # for 'compile' tests
d327 1
a327 1
	my $utf8 = $with_utf8 ? '-I../lib -Mutf8' : '';
d330 1
a330 1
	    my $deparse =
d332 1
a332 1
		"-l$deparse_opts$file_opts ".
d335 2
a336 2
	    open(RESULTS, $deparse)
		or print "can't deparse '$deparse': $!.\n";
d340 1
a340 1
            if( $^O eq 'MSWin32') {
d356 2
a357 2
	    my $bytecompile =
		"$perl $testswitch $switch -I../lib $bswitch". 
d360 2
a361 2
	    open(RESULTS,$bytecompile)
		or print "can't byte-compile '$bytecompile': $!.\n";
d368 2
a369 2
                               . "--leak-resolution=high --show-reachable=yes "
                               . "--num-callers=50 --logfile-fd=3 $perl";
d372 2
a373 1
	    my $run = "$perl" . _quote_args("$testswitch $switch $utf8") . " $test $redir|";
d377 11
a387 11
	    my $compile;
            my $pl2c = "$testswitch -I../lib ../utils/perlcc --testsuite " .
              # -O9 for good measure, -fcog is broken ATM
                       "$switch -Wb=-O9,-fno-cog -L .. " .
                       "-I \".. ../lib/CORE\" $args $utf8 $test -o ";

            if( $^O eq 'MSWin32' ) {
                $test_executable = "$test.exe";
                # hopefully unused name...
                open HACK, "> xweghyz.pl";
                print HACK <<EOT;
d396 20
a415 16
                close HACK;
                $compile = 'xweghyz.pl |';
            }
            else {
                $test_executable = "$test.plc";
                $compile = "./perl $pl2c $test_executable && $test_executable |";
            }
            unlink $test_executable if -f $test_executable;
	    open(RESULTS, $compile)
		or print "can't compile '$compile': $!.\n";
	}

        $ok = 0;
        $next = 0;
        my $seen_leader = 0;
        my $seen_ok = 0;
d418 1
a418 1
	    if ($verbose) {
d422 5
d428 4
d433 1
a433 1
                    %todo = map { $_ => 1 } split / /, $3 if $3;
d435 13
a447 6
		    $files += 1;
                    unless ($seen_ok) {
                      $next = 1;
                      $ok = 1;
                    }
                    $seen_leader = 1;
d450 1
a450 1
		    if (/^(not )?ok (\d+)[^\#]*(\s*\#.*)?/) {
d453 1
a453 2
				$next = 1;
				$ok = 1;
d457 10
a466 3
			if ($2 == $next) {
			    my($not, $num, $extra) = ($1, $2, $3);
			    my($istodo) = $extra =~ /^\s*#\s*TODO/ if $extra;
d470 1
a470 2
				$ok = 0;
				$next = $num;
a472 3
			    else {
				$next = $next + 1;
			    }
d474 7
a480 3
                    }
                    elsif (/^Bail out!\s*(.*)/i) { # magic words
                        die "FAILED--Further testing stopped" . ($1 ? ": $1\n" : ".\n");
d483 2
a484 1
			$ok = 0;
d490 5
d547 14
a560 14
	$next = $next - 1;
        # test if the compiler compiled something
        if( $type eq 'compile' && !-e "$test_executable" ) {
            $ok = 0;
            print "Test did not compile\n";
        }
	if ($ok && $next == $max ) {
	    if ($max) {
		print "${te}ok\n";
		$good = $good + 1;
	    }
	    else {
		print "${te}skipping test on this platform\n";
		$files -= 1;
d564 10
a573 3
	    $next += 1;
	    if ($next > $max) {
	        print "${te}FAILED at test $next\tpossibly due to extra output\n";
d576 2
a577 6
		print "${te}FAILED at test $next\n";
	    }
	    $bad = $bad + 1;
	    $_ = $test;
	    if (/^base/) {
		die "Failed a basic test--cannot continue.\n";
d580 1
a580 1
    }
d582 2
a583 2
    if ($bad == 0) {
	if ($ok) {
d592 3
a594 3
	$pct = $files ? sprintf("%.2f", ($files - $bad) / $files * 100) : "0.00";
	if ($bad == 1) {
	    warn "Failed 1 test script out of $files, $pct% okay.\n";
d597 1
a597 1
	    warn "Failed $bad test scripts out of $files, $pct% okay.\n";
d604 1
a604 1
	warn <<'SHRDLU_2' if $good / $total > 0.8;
d609 2
a610 2
        if (eval {require Config; import Config; 1}) {
	    if ($Config{usedl} && (my $p = $Config{ldlibpthname})) {
d615 1
a615 1
                if (exists $ENV{$p} && $ENV{$p} ne '') {
d621 1
a621 1
                } else {
d627 1
a627 1
                }    
d632 1
a632 1
            }
d635 3
a637 3
    ($user,$sys,$cuser,$csys) = times;
    print sprintf("u=%g  s=%g  cu=%g  cs=%g  scripts=%d  tests=%d\n",
	$user,$sys,$cuser,$csys,$files,$totmax);
d643 1
a643 1
exit ($bad != 0);
@


1.8
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d4 3
a6 1
# most of the constructs we'll be testing for.
d25 2
a26 1
	$with_utf= 1 if $1 eq 'utf8';
d140 26
d251 3
d278 1
a278 1
	my $utf = $with_utf ? '-I../lib -Mutf8' : '';
d310 1
a310 1
		"$perl $testswitch $switch -I../lib $utf $test.plc |";
d323 1
a323 1
	    my $run = "$perl" . _quote_args("$testswitch $switch $utf") . " $test $redir|";
d331 1
a331 1
                       "-I \".. ../lib/CORE\" $args $utf $test -o ";
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d27 1
d71 2
a72 1
        next if $f eq $curdir or $f eq $updir;
d451 6
a456 1
	    print "${te}FAILED at test $next\n";
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d24 3
a26 2
        $byte_compile = 1 if $1 eq 'bytecompile';
        $compile = 1 if $1 eq 'compile';
d68 1
a68 1
    opendir DIR, $dir || die "Trouble opening $dir: $!";
d116 1
a116 1
	_find_tests('pod');  
d129 5
a133 3
elsif( $compile || $byte_compile ) { 
    _testprogs('compile', '',   @@ARGV) if $compile;
    _testprogs('compile', '-B', @@ARGV) if $byte_compile;
d157 6
d187 2
d203 1
a203 1
	    elsif ($test eq "lib/switch.t") {
d224 7
a230 1
 	    $switch = '';
d248 1
a248 1
		"./perl $testswitch $switch -I../lib -MO=-qq,Deparse,".
d255 25
d282 7
a288 1
	    my $redir = ($^O eq 'VMS' ? '2>&1' : '');
d326 2
d333 1
a333 1
	    unless (/^#/) {
d339 5
a343 2
		    $next = 1;
		    $ok = 1;
d346 6
a351 11
		    if (/^(not )?ok (\d+)[^#]*(\s*#.*)?/ &&
			$2 == $next)
		    {
			my($not, $num, $extra) = ($1, $2, $3);
			my($istodo) = $extra =~ /^\s*#\s*TODO/ if $extra;
                        $istodo = 1 if $todo{$num};

			if( $not && !$istodo ) {
			    $ok = 0;
			    $next = $num;
			    last;
d353 14
a366 2
			else {
			    $next = $next + 1;
d379 41
d514 4
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@a2 2
# Last change: Fri May 28 03:16:57 BST 1999

d8 23
a30 3
if ($#ARGV >= 0 && $ARGV[0] eq '-v') {
    $verbose = 1;
    shift;
d32 1
d37 16
a52 1
  unless -e 'perl' or -e 'perl.exe';
d59 18
a76 3
if ($#ARGV == -1) {
    @@ARGV = split(/[ \n]/,
      `echo base/*.t comp/*.t cmd/*.t run/*.t io/*.t; echo op/*.t pragma/*.t lib/*.t`);
d79 12
a90 1
# %infinite = ( 'comp/require.t', 1, 'op/bop.t', 1, 'lib/hostname.t', 1 ); 
d92 44
a135 2
_testprogs('perl', @@ARGV);
_testprogs('compile', @@ARGV) if (-e "../testcompile"); 
d139 1
a141 1

d143 1
a143 1
--------------------------------------------------------------------------------
d145 7
a151 1
--------------------------------------------------------------------------------
d154 1
a154 1
    $ENV{PERLCC_TIMEOUT} = 120 
d162 12
a173 3
    $maxlen = 0;
    foreach (@@tests) {
	$len = length;
d176 2
a177 3
    # +3 : we want three dots between the test name and the "ok"
    # -2 : the .t suffix
    $dotdotdot = $maxlen + 3 - 2;
d181 1
a181 1
	    print STDERR "$test creates infinite loop! Skipping.\n"; 
d187 8
a194 12
	$te = $test;
	chop($te);
	print "$te" . '.' x ($dotdotdot - length($te));

	open(SCRIPT,"<$test") or die "Can't run $test.\n";
	$_ = <SCRIPT>;
	close(SCRIPT);
	if (/#!.*perl(.*)$/) {
	    $switch = $1;
	    if ($^O eq 'VMS') {
		# Must protect uppercase switches with "" on command line
		$switch =~ s/-([A-Z]\S*)/"-$1"/g;
d197 28
a224 2
	else {
	    $switch = '';
d227 16
a242 2
	if ($type eq 'perl') {
	    open(RESULTS,"./perl$switch $test |") or print "can't run.\n";
d245 29
a273 4
	    open(RESULTS, "./perl -I../lib ../utils/perlcc -o ./$test.plc ./$test "
	    		 ." && ./$test.plc |")
		or print "can't compile.\n";
        unlink "./$test.plc";
d276 2
a277 2
	$ok = 0;
	$next = 0;
d279 1
d284 1
a284 1
		if (/^1\.\.([0-9]+)/) {
d286 1
d293 18
a310 3
		    $next = $1, $ok = 0, last if /^not ok ([0-9]*)/;
		    if (/^ok (\d+)(\s*#.*)?$/ && $1 == $next) {
			$next = $next + 1;
d319 11
d331 6
a336 1
	if ($ok && $next == $max) {
d338 1
a338 1
		print "ok\n";
d342 1
a342 1
		print "skipping test on this platform\n";
d348 1
a348 1
	    print "FAILED at test $next\n";
d374 35
a408 16
	warn <<'SHRDLU';
   ### Since not all tests were successful, you may want to run some
   ### of them individually and examine any diagnostic messages they
   ### produce.  See the INSTALL document's section on "make test".
   ### If you are testing the compiler, then ignore this message 
   ### and run 
   ###      ./perl harness
   ### in the directory ./t.
SHRDLU
	warn <<'SHRDLU' if $good / $total > 0.8;
   ###
   ### Since most tests were successful, you have a good chance to
   ### get information with better granularity by running
   ###     ./perl harness 
   ### in directory ./t.
SHRDLU
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d27 1
a27 1
      `echo base/*.t comp/*.t cmd/*.t io/*.t; echo op/*.t pragma/*.t lib/*.t`);
d30 1
a30 1
%infinite = ( 'comp/require.t', 1, 'op/bop.t', 1, 'lib/hostname.t', 1 ); 
d93 2
a94 2
	    open(RESULTS, "./perl -I../lib ../utils/perlcc ./$test "
	    		 ."-run -verbose dcf -log ../compilelog |")
d96 1
@


1.3
log
@perl5.005_03 (stock)
@
text
@d3 1
a3 1
# Last change: Fri Jan 10 09:57:03 WET 1997
d46 3
d156 1
a156 1
	$pct = sprintf("%.2f", $good / $total * 100);
d158 1
a158 1
	    warn "Failed 1 test script out of $total, $pct% okay.\n";
d161 1
a161 1
	    warn "Failed $bad test scripts out of $total, $pct% okay.\n";
@


1.2
log
@perl 5.004_04
@
text
@d20 3
d30 41
a70 13
if ($^O eq 'os2' || $^O eq 'qnx') {
    $sharpbang = 0;
}
else {
    open(CONFIG, "../config.sh");
    while (<CONFIG>) {
	if (/sharpbang='(.*)'/) {
	    $sharpbang = ($1 eq '#!');
	    last;
	}
    }
    close(CONFIG);
}
d72 1
a72 17
$bad = 0;
$good = 0;
$total = @@ARGV;
$files  = 0;
$totmax = 0;
while ($test = shift) {
    if ($test =~ /^$/) {
	next;
    }
    $te = $test;
    chop($te);
    print "$te" . '.' x (18 - length($te));
    if ($sharpbang) {
	-x $test || (print "isn't executable.\n");
	open(RESULTS,"./$test |") || (print "can't run.\n");
    } else {
	open(SCRIPT,"$test") || die "Can't run $test.\n";
d75 1
a75 1
	if (/#!..perl(.*)/) {
d81 2
a82 1
	} else {
d85 32
a116 21
	open(RESULTS,"./perl$switch $test |") || (print "can't run.\n");
    }
    $ok = 0;
    $next = 0;
    while (<RESULTS>) {
	if ($verbose) {
	    print $_;
	}
	unless (/^#/) {
	    if (/^1\.\.([0-9]+)/) {
		$max = $1;
		$totmax += $max;
		$files += 1;
		$next = 1;
		$ok = 1;
	    } else {
		$next = $1, $ok = 0, last if /^not ok ([0-9]*)/;
		if (/^ok (.*)/ && $1 == $next) {
		    $next = $next + 1;
		} else {
		    $ok = 0;
d120 20
a139 17
    }
    $next = $next - 1;
    if ($ok && $next == $max) {
	if ($max) {
	    print "ok\n";
	    $good = $good + 1;
	} else {
	    print "skipping test on this platform\n";
	    $files -= 1;
	}
    } else {
	$next += 1;
	print "FAILED at test $next\n";
	$bad = $bad + 1;
	$_ = $test;
	if (/^base/) {
	    die "Failed a basic test--cannot continue.\n";
a141 1
}
d143 8
a150 6
if ($bad == 0) {
    if ($ok) {
	print "All tests successful.\n";
	# XXX add mention of 'perlbug -ok' ?
    } else {
	die "FAILED--no tests were run for some reason.\n";
d152 9
a160 8
} else {
    $pct = sprintf("%.2f", $good / $total * 100);
    if ($bad == 1) {
	warn "Failed 1 test script out of $total, $pct% okay.\n";
    } else {
	warn "Failed $bad test scripts out of $total, $pct% okay.\n";
    }
       warn <<'SHRDLU';
d164 4
d169 1
a169 1
       warn <<'SHRDLU' if $good / $total > 0.8;
d173 1
a173 1
   ###     ./perl harness
d176 4
a180 3
($user,$sys,$cuser,$csys) = times;
print sprintf("u=%g  s=%g  cu=%g  cs=%g  scripts=%d  tests=%d\n",
    $user,$sys,$cuser,$csys,$files,$totmax);
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
# $RCSfile: TEST,v $$Revision: 4.1 $$Date: 92/08/07 18:27:00 $
d10 1
a10 1
if ($ARGV[0] eq '-v') {
d17 1
a17 1
die "You need to run \"make test\" first to set things up.\n" 
d22 1
a22 1
if ($ARGV[0] eq '') {
d24 1
a24 1
      `echo base/*.t comp/*.t cmd/*.t io/*.t; echo op/*.t lib/*.t`);
d27 10
a36 5
open(CONFIG,"../config.sh");
while (<CONFIG>) {
    if (/sharpbang='(.*)'/) {
	$sharpbang = ($1 eq '#!');
	last;
d38 1
d40 1
a40 1
$sharpbang = 0 if $ENV{OS2_SHELL};		# OS/2
d44 2
d52 1
a52 1
    print "$te" . '.' x (15 - length($te));
d54 2
a55 1
	open(results,"./$test |") || (print "can't run.\n");
d57 3
a59 3
	open(script,"$test") || die "Can't run $test.\n";
	$_ = <script>;
	close(script);
d62 4
d69 1
a69 1
	open(results,"./perl$switch $test |") || (print "can't run.\n");
d73 1
a73 1
    while (<results>) {
d96 7
a102 2
	print "ok\n";
	$good = $good + 1;
d105 1
a105 1
	print "FAILED on test $next\n";
d117 1
d124 1
a124 1
	warn "Failed 1 test, $pct% okay.\n";
d126 1
a126 1
	die "Failed $bad/$total tests, $pct% okay.\n";
d128 12
d142 1
a142 1
print sprintf("u=%g  s=%g  cu=%g  cs=%g  files=%d  tests=%d\n",
d144 1
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d3 1
a3 1
# Last change: Fri Jan 10 09:57:03 WET 1997
d10 1
a10 1
if ($#ARGV >= 0 && $ARGV[0] eq '-v') {
d17 1
a17 1
die "You need to run \"make test\" first to set things up.\n"
a19 3
# check leakage for embedders
$ENV{PERL_DESTRUCT_LEVEL} = 2 unless exists $ENV{PERL_DESTRUCT_LEVEL};

d22 1
a22 1
if ($#ARGV == -1) {
d24 1
a24 1
      `echo base/*.t comp/*.t cmd/*.t io/*.t; echo op/*.t pragma/*.t lib/*.t`);
d27 25
a51 46
%infinite = ( 'comp/require.t', 1, 'op/bop.t', 1, 'lib/hostname.t', 1 ); 

_testprogs('perl', @@ARGV);
_testprogs('compile', @@ARGV) if (-e "../testcompile"); 

sub _testprogs {
    $type = shift @@_;
    @@tests = @@_;


    print <<'EOT' if ($type eq 'compile');
--------------------------------------------------------------------------------
TESTING COMPILER
--------------------------------------------------------------------------------
EOT

    $bad = 0;
    $good = 0;
    $total = @@tests;
    $files  = 0;
    $totmax = 0;
    $maxlen = 0;
    foreach (@@tests) {
	$len = length;
	$maxlen = $len if $len > $maxlen;
    }
    # +3 : we want three dots between the test name and the "ok"
    # -2 : the .t suffix
    $dotdotdot = $maxlen + 3 - 2;
    while ($test = shift @@tests) {

	if ( $infinite{$test} && $type eq 'compile' ) {
	    print STDERR "$test creates infinite loop! Skipping.\n"; 
            next;
	}
	if ($test =~ /^$/) {
	    next;
	}
	$te = $test;
	chop($te);
	print "$te" . '.' x ($dotdotdot - length($te));

	open(SCRIPT,"<$test") or die "Can't run $test.\n";
	$_ = <SCRIPT>;
	close(SCRIPT);
	if (/#!.*perl(.*)$/) {
d53 1
a53 6
	    if ($^O eq 'VMS') {
		# Must protect uppercase switches with "" on command line
		$switch =~ s/-([A-Z]\S*)/"-$1"/g;
	    }
	}
	else {
d56 21
a76 32

	if ($type eq 'perl') {
	    open(RESULTS,"./perl$switch $test |") or print "can't run.\n";
	}
	else {
	    open(RESULTS, "./perl -I../lib ../utils/perlcc ./$test "
	    		 ."-run -verbose dcf -log ../compilelog |")
		or print "can't compile.\n";
	}

	$ok = 0;
	$next = 0;
	while (<RESULTS>) {
	    if ($verbose) {
		print $_;
	    }
	    unless (/^#/) {
		if (/^1\.\.([0-9]+)/) {
		    $max = $1;
		    $totmax += $max;
		    $files += 1;
		    $next = 1;
		    $ok = 1;
		}
		else {
		    $next = $1, $ok = 0, last if /^not ok ([0-9]*)/;
		    if (/^ok (\d+)(\s*#.*)?$/ && $1 == $next) {
			$next = $next + 1;
		    }
		    else {
			$ok = 0;
		    }
d80 12
a91 20
	close RESULTS;
	$next = $next - 1;
	if ($ok && $next == $max) {
	    if ($max) {
		print "ok\n";
		$good = $good + 1;
	    }
	    else {
		print "skipping test on this platform\n";
		$files -= 1;
	    }
	}
	else {
	    $next += 1;
	    print "FAILED at test $next\n";
	    $bad = $bad + 1;
	    $_ = $test;
	    if (/^base/) {
		die "Failed a basic test--cannot continue.\n";
	    }
d94 1
d96 12
a107 8
    if ($bad == 0) {
	if ($ok) {
	    print "All tests successful.\n";
	    # XXX add mention of 'perlbug -ok' ?
	}
	else {
	    die "FAILED--no tests were run for some reason.\n";
	}
a108 28
    else {
	$pct = sprintf("%.2f", $good / $total * 100);
	if ($bad == 1) {
	    warn "Failed 1 test script out of $total, $pct% okay.\n";
	}
	else {
	    warn "Failed $bad test scripts out of $total, $pct% okay.\n";
	}
	warn <<'SHRDLU';
   ### Since not all tests were successful, you may want to run some
   ### of them individually and examine any diagnostic messages they
   ### produce.  See the INSTALL document's section on "make test".
   ### If you are testing the compiler, then ignore this message 
   ### and run 
   ###      ./perl harness
   ### in the directory ./t.
SHRDLU
	warn <<'SHRDLU' if $good / $total > 0.8;
   ###
   ### Since most tests were successful, you have a good chance to
   ### get information with better granularity by running
   ###     ./perl harness 
   ### in directory ./t.
SHRDLU
    }
    ($user,$sys,$cuser,$csys) = times;
    print sprintf("u=%g  s=%g  cu=%g  cs=%g  scripts=%d  tests=%d\n",
	$user,$sys,$cuser,$csys,$files,$totmax);
d110 3
a112 1
exit ($bad != 0);
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d3 1
a3 1
# Last change: Fri May 28 03:16:57 BST 1999
a45 3
    $ENV{PERLCC_TIMEOUT} = 120 
          if ($type eq 'compile' && !$ENV{PERLCC_TIMEOUT});

d153 1
a153 1
	$pct = $files ? sprintf("%.2f", ($files - $bad) / $files * 100) : "0.00";
d155 1
a155 1
	    warn "Failed 1 test script out of $files, $pct% okay.\n";
d158 1
a158 1
	    warn "Failed $bad test scripts out of $files, $pct% okay.\n";
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d27 1
a27 1
      `echo base/*.t comp/*.t cmd/*.t run/*.t io/*.t; echo op/*.t pragma/*.t lib/*.t`);
d30 1
a30 1
# %infinite = ( 'comp/require.t', 1, 'op/bop.t', 1, 'lib/hostname.t', 1 ); 
d93 2
a94 2
	    open(RESULTS, "./perl -I../lib ../utils/perlcc -o ./$test.plc ./$test "
	    		 ." && ./$test.plc |")
a95 1
        unlink "./$test.plc";
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d3 2
d10 3
a12 23
# Let tests know they're running in the perl core.  Useful for modules
# which live dual lives on CPAN.
$ENV{PERL_CORE} = 1;

# remove empty elements due to insertion of empty symbols via "''p1'" syntax
@@ARGV = grep($_,@@ARGV) if $^O eq 'VMS';

# Cheesy version of Getopt::Std.  Maybe we should replace it with that.
@@argv = ();
if ($#ARGV >= 0) {
    foreach my $idx (0..$#ARGV) {
	push( @@argv, $ARGV[$idx] ), next unless $ARGV[$idx] =~ /^-(\S+)$/;
	$core    = 1 if $1 eq 'core';
	$verbose = 1 if $1 eq 'v';
	$torture = 1 if $1 eq 'torture';
	$with_utf= 1 if $1 eq 'utf8';
        $byte_compile = 1 if $1 eq 'bytecompile';
        $compile = 1 if $1 eq 'compile';
	if ($1 =~ /^deparse(,.+)?$/) {
	    $deparse = 1;
	    $deparse_opts = $1;
	}
    }
a13 1
@@ARGV = @@argv;
d18 1
a18 16
  unless -e 'perl' or -e 'perl.exe' or -e 'perl.pm';

if ($ENV{PERL_3LOG}) { # Tru64 third(1) tool, see perlhack
    unless (-x 'perl.third') {
	unless (-x '../perl.third') {
	    die "You need to run \"make perl.third first.\n";
	}
	else {
	    print "Symlinking ../perl.third as perl.third...\n";
	    die "Failed to symlink: $!\n"
		unless symlink("../perl.third", "perl.third");
	    die "Symlinked but no executable perl.third: $!\n"
		unless -x 'perl.third';
	}
    }
}
d25 3
a27 18
# Roll your own File::Find!
use TestInit;
use File::Spec;
my $curdir = File::Spec->curdir;
my $updir  = File::Spec->updir;

sub _find_tests {
    my($dir) = @@_;
    opendir DIR, $dir || die "Trouble opening $dir: $!";
    foreach my $f (sort { $a cmp $b } readdir DIR) {
        next if $f eq $curdir or $f eq $updir;

        my $fullpath = File::Spec->catfile($dir, $f);

        _find_tests($fullpath) if -d $fullpath;
        $fullpath = VMS::Filespec::unixify($fullpath) if $^O eq 'VMS';
        push @@ARGV, $fullpath if $f =~ /\.t$/;
    }
d30 1
a30 12
sub _quote_args {
    my ($args) = @@_;
    my $argstring = '';

    foreach (split(/\s+/,$args)) {
       # In VMS protect with doublequotes because otherwise
       # DCL will lowercase -- unless already doublequoted.
       $_ = q(").$_.q(") if ($^O eq 'VMS') && !/^\"/ && length($_) > 0;
       $argstring .= ' ' . $_;
    }
    return $argstring;
}
d32 2
a33 44
unless (@@ARGV) {
    foreach my $dir (qw(base comp cmd run io op uni)) {
        _find_tests($dir);
    }
    _find_tests("lib") unless $core;
    my $mani = File::Spec->catfile($updir, "MANIFEST");
    if (open(MANI, $mani)) {
        while (<MANI>) { # similar code in t/harness
	    if (m!^(ext/\S+/?(?:[^/\s]+\.t|test\.pl)|lib/\S+?(?:\.t|test\.pl))\s!) {
		$t = $1;
		if (!$core || $t =~ m!^lib/[a-z]!)
		{
		    $path = File::Spec->catfile($updir, $t);
		    push @@ARGV, $path;
		    $name{$path} = $t;
		}
	    }
	}
	close MANI;
    } else {
        warn "$0: cannot open $mani: $!\n";
    }
    unless ($core) {
	_find_tests('pod');  
	_find_tests('x2p');
	_find_tests('japh') if $torture;
    }
}

# Tests known to cause infinite loops for the perlcc tests.
# %infinite = ( 'comp/require.t', 1, 'op/bop.t', 1, 'lib/hostname.t', 1 );
%infinite = ();

if ($deparse) {
    _testprogs('deparse', '',   @@ARGV);
}
elsif( $compile || $byte_compile ) { 
    _testprogs('compile', '',   @@ARGV) if $compile;
    _testprogs('compile', '-B', @@ARGV) if $byte_compile;
}
else {
    _testprogs('compile', '',   @@ARGV) if -e "../testcompile";
    _testprogs('perl',    '',   @@ARGV);
}
a36 1
    $args = shift;
d39 1
d41 1
a41 1
------------------------------------------------------------------------------
d43 1
a43 7
------------------------------------------------------------------------------
EOT

    print <<'EOT' if ($type eq 'deparse');
------------------------------------------------------------------------------
TESTING DEPARSER
------------------------------------------------------------------------------
d46 1
a46 1
    $ENV{PERLCC_TIMEOUT} = 120
d54 3
a56 12

    foreach my $t (@@tests) {
      unless (exists $name{$t}) {
        my $tname = File::Spec->catfile('t',$t);
        $tname = VMS::Filespec::unixify($tname) if $^O eq 'VMS';
        $name{$t} = $tname;
      }
    }
    my $maxlen = 0;
    foreach (@@name{@@tests}) {
	s/\.\w+\z/./;
	my $len = length ;
d59 3
a61 2
    # + 3 : we want three dots between the test name and the "ok"
    $dotdotdot = $maxlen + 3 ;
d65 1
a65 1
	    print STDERR "$test creates infinite loop! Skipping.\n";
d71 12
a82 8
	if ($type eq 'deparse') {
	    if ($test eq "comp/redef.t") {
		# Redefinition happens at compile time
		next;
	    }
	    elsif ($test eq "lib/switch.t") {
		# B::Deparse doesn't support source filtering
		next;
d85 2
a86 28
	$te = $name{$test} . '.' x ($dotdotdot - length($name{$test}));

	if ($^O ne 'VMS') {  # defer printing on VMS due to piping bug
	    print $te;
	    $te = '';
	}

	$test = $OVER{$test} if exists $OVER{$test};

 	open(SCRIPT,"<$test") or die "Can't run $test.\n";
 	$_ = <SCRIPT>;
 	close(SCRIPT) unless ($type eq 'deparse');
 	if (/#!.*\bperl.*\s-\w*([tT])/) {
 	    $switch = qq{"-$1"};
 	}
 	else {
 	    $switch = '';
 	}

        my $test_executable; # for 'compile' tests
	my $file_opts = "";
	if ($type eq 'deparse') {
	    # Look for #line directives which change the filename
	    while (<SCRIPT>) {
		$file_opts .= ",-f$3$4"
			if /^#\s*line\s+(\d+)\s+((\w+)|"([^"]+)")/;
	    }
	    close(SCRIPT);
d89 2
a90 16
	my $utf = $with_utf ? '-I../lib -Mutf8' : '';
	my $testswitch = '-I. -MTestInit'; # -T will strict . from @@INC
	if ($type eq 'deparse') {
	    my $deparse =
		"./perl $testswitch $switch -I../lib -MO=-qq,Deparse,".
		"-l$deparse_opts$file_opts ".
		"$test > $test.dp ".
		"&& ./perl $testswitch $switch -I../lib $test.dp |";
	    open(RESULTS, $deparse)
		or print "can't deparse '$deparse': $!.\n";
	}
	elsif ($type eq 'perl') {
	    my $perl = $ENV{PERL} || './perl';
	    my $redir = ($^O eq 'VMS' ? '2>&1' : '');
	    my $run = "$perl" . _quote_args("$testswitch $switch $utf") . " $test $redir|";
	    open(RESULTS,$run) or print "can't run '$run': $!.\n";
d93 4
a96 29
	    my $compile;
            my $pl2c = "$testswitch -I../lib ../utils/perlcc --testsuite " .
              # -O9 for good measure, -fcog is broken ATM
                       "$switch -Wb=-O9,-fno-cog -L .. " .
                       "-I \".. ../lib/CORE\" $args $utf $test -o ";

            if( $^O eq 'MSWin32' ) {
                $test_executable = "$test.exe";
                # hopefully unused name...
                open HACK, "> xweghyz.pl";
                print HACK <<EOT;
#!./perl

open HACK, '.\\perl $pl2c $test_executable |';
# cl.exe prints the name of the .c file on stdout (\%^\$^#)
while(<HACK>) {m/^\\w+\\.[cC]\$/ && next;print}
open HACK, '$test_executable |';
while(<HACK>) {print}
EOT
                close HACK;
                $compile = 'xweghyz.pl |';
            }
            else {
                $test_executable = "$test.plc";
                $compile = "./perl $pl2c $test_executable && $test_executable |";
            }
            unlink $test_executable if -f $test_executable;
	    open(RESULTS, $compile)
		or print "can't compile '$compile': $!.\n";
d99 2
a100 2
        $ok = 0;
        $next = 0;
a101 1
	    next if /^\s*$/; # skip blank lines
d106 1
a106 1
		if (/^1\.\.([0-9]+)( todo ([\d ]+))?/) {
a107 1
                    %todo = map { $_ => 1 } split / /, $3 if $3;
d114 3
a116 18
		    if (/^(not )?ok (\d+)[^#]*(\s*#.*)?/ &&
			$2 == $next)
		    {
			my($not, $num, $extra) = ($1, $2, $3);
			my($istodo) = $extra =~ /^\s*#\s*TODO/ if $extra;
                        $istodo = 1 if $todo{$num};

			if( $not && !$istodo ) {
			    $ok = 0;
			    $next = $num;
			    last;
			}
			else {
			    $next = $next + 1;
			}
                    }
                    elsif (/^Bail out!\s*(.*)/i) { # magic words
                        die "FAILED--Further testing stopped" . ($1 ? ": $1\n" : ".\n");
a124 11
	if ($type eq 'deparse') {
	    unlink "./$test.dp";
	}
	if ($ENV{PERL_3LOG}) {
	    my $tpp = $test;
	    $tpp =~ s:^\.\./::;
	    $tpp =~ s:/:_:g;
	    $tpp =~ s:\.t$:.3log:;
	    rename("perl.3log", $tpp) ||
		die "rename: perl3.log to $tpp: $!\n";
	}
d126 1
a126 6
        # test if the compiler compiled something
        if( $type eq 'compile' && !-e "$test_executable" ) {
            $ok = 0;
            print "Test did not compile\n";
        }
	if ($ok && $next == $max ) {
d128 1
a128 1
		print "${te}ok\n";
d132 1
a132 1
		print "${te}skipping test on this platform\n";
d138 1
a138 1
	    print "${te}FAILED at test $next\n";
d164 16
a179 35
	warn <<'SHRDLU_1';
### Since not all tests were successful, you may want to run some of
### them individually and examine any diagnostic messages they produce.
### See the INSTALL document's section on "make test".
SHRDLU_1
	warn <<'SHRDLU_2' if $good / $total > 0.8;
### You have a good chance to get more information by running
###   ./perl harness
### in the 't' directory since most (>=80%) of the tests succeeded.
SHRDLU_2
        if (eval {require Config; import Config; 1}) {
	    if ($Config{usedl} && (my $p = $Config{ldlibpthname})) {
		warn <<SHRDLU_3;
### You may have to set your dynamic library search path,
### $p, to point to the build directory:
SHRDLU_3
                if (exists $ENV{$p} && $ENV{$p} ne '') {
		    warn <<SHRDLU_4a;
###   setenv $p `pwd`:\$$p; cd t; ./perl harness
###   $p=`pwd`:\$$p; export $p; cd t; ./perl harness
###   export $p=`pwd`:\$$p; cd t; ./perl harness
SHRDLU_4a
                } else {
		    warn <<SHRDLU_4b;
###   setenv $p `pwd`; cd t; ./perl harness
###   $p=`pwd`; export $p; cd t; ./perl harness
###   export $p=`pwd`; cd t; ./perl harness
SHRDLU_4b
                }    
		warn <<SHRDLU_5;
### for csh-style shells, like tcsh; or for traditional/modern
### Bourne-style shells, like bash, ksh, and zsh, respectively.
SHRDLU_5
            }
	}
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@d24 2
a25 3
	$bytecompile = 1 if $1 eq 'bytecompile';
	$compile = 1 if $1 eq 'compile';
	$taintwarn = 1 if $1 eq 'taintwarn';
d67 1
a67 1
    opendir DIR, $dir or die "Trouble opening $dir: $!";
d115 1
a115 1
	_find_tests('pod');
d128 3
a130 5
elsif( $compile ) { 
    _testprogs('compile', '',   @@ARGV);
}
elsif( $bytecompile ) {
    _testprogs('bytecompile', '', @@ARGV);
a153 6
    print <<EOT if ($type eq 'bytecompile');
------------------------------------------------------------------------------
TESTING BYTECODE COMPILER
------------------------------------------------------------------------------
EOT

a177 2
    my $valgrind = 0;
    my $valgrind_log = 'current.valgrind';
d192 1
a192 1
	    elsif ($test =~ m{lib/Switch/t/}) {
d213 1
a213 7
	    if ($taintwarn) {
		# not all tests are expected to pass with this option
		$switch = '"-t"';
	    }
	    else {
		$switch = '';
	    }
d231 1
a231 1
		"./perl $testswitch $switch -I../lib -MO=-qq,Deparse,-sv1.,".
a237 25
	elsif ($type eq 'bytecompile') {
	    my ($pwd, $null);
            if( $^O eq 'MSWin32') {
		$pwd = `cd`;
		$null = 'nul';
	    } else {
		$pwd = `pwd`;
		$null = '/dev/null';
	    }
	    chomp $pwd;
	    my $perl = $ENV{PERL} || "$pwd/perl";
	    my $bswitch = "-MO=Bytecode,-H,-TI,-s$pwd/$test,";
	    $bswitch .= "-TF$test.plc,"
		if $test =~ m(chdir|pod/|CGI/t/carp|lib/DB);
	    $bswitch .= "-k,"
		if $test =~ m(deparse|terse|ext/Storable/t/code);
	    $bswitch .= "-b,"
		if $test =~ m(op/getpid);
	    my $bytecompile =
		"$perl $testswitch $switch -I../lib $bswitch". 
		"-o$test.plc $test 2>$null &&".
		"$perl $testswitch $switch -I../lib $utf $test.plc |";
	    open(RESULTS,$bytecompile)
		or print "can't byte-compile '$bytecompile': $!.\n";
	}
d240 1
a240 7
	    my $redir = $^O eq 'VMS' ? '2>&1' : '';
	    if ($ENV{PERL_VALGRIND}) {
		$perl = "valgrind --suppressions=perl.supp --leak-check=yes "
                               . "--leak-resolution=high --show-reachable=yes "
                               . "--num-callers=50 --logfile-fd=3 $perl";
		$redir = "3>$valgrind_log";
	    }
a277 2
        my $seen_leader = 0;
        my $seen_ok = 0;
d283 1
a283 1
	    unless (/^\#/) {
d289 2
a290 5
                    unless ($seen_ok) {
                      $next = 1;
                      $ok = 1;
                    }
                    $seen_leader = 1;
d293 11
a303 6
		    if (/^(not )?ok (\d+)[^\#]*(\s*\#.*)?/) {
			unless ($seen_leader) {
			    unless ($seen_ok) {
				$next = 1;
				$ok = 1;
			    }
d305 2
a306 14
			$seen_ok = 1;
			if ($2 == $next) {
			    my($not, $num, $extra) = ($1, $2, $3);
			    my($istodo) = $extra =~ /^\s*#\s*TODO/ if $extra;
			    $istodo = 1 if $todo{$num};

			    if( $not && !$istodo ) {
				$ok = 0;
				$next = $num;
				last;
			    }
			    else {
				$next = $next + 1;
			    }
a318 41
	if ($ENV{PERL_VALGRIND}) {
	    my @@valgrind;
	    if (-e $valgrind_log) {
		if (open(V, $valgrind_log)) {
		    @@valgrind = <V>;
		    close V;
		} else {
		    warn "$0: Failed to open '$valgrind_log': $!\n";
		}
	    }
	    if (@@valgrind) {
		my $leaks = 0;
		my $errors = 0;
		for my $i (0..$#valgrind) {
		    local $_ = $valgrind[$i];
		    if (/^==\d+== ERROR SUMMARY: (\d+) errors? /) {
			$errors += $1;   # there may be multiple error summaries
		    } elsif (/^==\d+== LEAK SUMMARY:/) {
			for my $off (1 .. 4) {
			    if ($valgrind[$i+$off] =~
				/(?:lost|reachable):\s+\d+ bytes in (\d+) blocks/) {
				$leaks += $1;
			    }
			}
		    }
		}
		if ($errors or $leaks) {
		    if (rename $valgrind_log, "$test.valgrind") {
			$valgrind++;
		    } else {
			warn "$0: Failed to create '$test.valgrind': $!\n";
		    }
		}
	    } else {
		warn "No valgrind output?\n";
	    }
	    if (-e $valgrind_log) {
		unlink $valgrind_log
		    or warn "$0: Failed to unlink '$valgrind_log': $!\n";
	    }
	}
a412 4
    if ($ENV{PERL_VALGRIND}) {
	my $s = $valgrind == 1 ? '' : 's';
	print "$valgrind valgrind report$s created.\n", ;
    }
@


1.1.1.7
log
@Import of stock perl 5.8.5
@
text
@a26 1
	$ENV{PERL_CORE_MINITEST} = 1 if $1 eq 'minitest';
d70 1
a70 2
        next if $f eq $curdir or $f eq $updir or
	    $f =~ /^(?:CVS|RCS|SCCS|\.svn)$/;
d449 1
a449 6
	    if ($next > $max) {
	        print "${te}FAILED at test $next\tpossibly due to extra output\n";
	    }
	    else {
		print "${te}FAILED at test $next\n";
	    }
@


1.1.1.8
log
@perl 5.8.6 from CPAN
@
text
@d4 1
a4 3
# most of the constructs we'll be testing for.  (This comment is
# probably obsolete on the avoidance side, though still currrent
# on the peculiarity side.)
d23 1
a23 2
	$with_utf8 = 1 if $1 eq 'utf8';
	$with_utf16 = 1 if $1 eq 'utf16';
a136 26
elsif ($with_utf16) {
    for my $e (0, 1) {
	for my $b (0, 1) {
	    print STDERR "# ENDIAN $e BOM $b\n";
	    my @@UARGV;
	    for my $a (@@ARGV) {
		my $u = $a . "." . ($e ? "l" : "b") . "e" . ($b ? "b" : "");
		my $f = $e ? "v" : "n";
		push @@UARGV, $u;
		unlink($u);
		if (open(A, $a)) {
		    if (open(U, ">$u")) {
			print U pack("$f", 0xFEFF) if $b;
			while (<A>) {
			    print U pack("$f*", unpack("C*", $_));
			}
			close(A);
		    }
		    close(B);
		}
	    }
	    _testprogs('perl', '', @@UARGV);
	    unlink(@@UARGV);
	}
    }
}
a221 3
	if ($with_utf16) {
	    $_ =~ tr/\0//d;
	}
d246 1
a246 1
	my $utf8 = $with_utf8 ? '-I../lib -Mutf8' : '';
d278 1
a278 1
		"$perl $testswitch $switch -I../lib $utf8 $test.plc |";
d291 1
a291 1
	    my $run = "$perl" . _quote_args("$testswitch $switch $utf8") . " $test $redir|";
d299 1
a299 1
                       "-I \".. ../lib/CORE\" $args $utf8 $test -o ";
@


1.1.1.9
log
@perl 5.8.8 import
@
text
@a9 4
# for testing TEST only
#BEGIN { require '../lib/strict.pm'; strict->import() };
#BEGIN { require '../lib/warnings.pm'; warnings->import() };

a15 1
our $show_elapsed_time = $ENV{HARNESS_TIMER} || 0;
d18 2
a19 2
{
    my @@argv = ();
d22 8
a29 8
	$::core    = 1 if $1 eq 'core';
	$::verbose = 1 if $1 eq 'v';
	$::torture = 1 if $1 eq 'torture';
	$::with_utf8 = 1 if $1 eq 'utf8';
	$::with_utf16 = 1 if $1 eq 'utf16';
	$::bytecompile = 1 if $1 eq 'bytecompile';
	$::compile = 1 if $1 eq 'compile';
	$::taintwarn = 1 if $1 eq 'taintwarn';
d32 2
a33 2
	    $::deparse = 1;
	    $::deparse_opts = $1;
a35 1
    @@ARGV = @@argv;
d37 1
a66 1
if ($show_elapsed_time) { require Time::HiRes }
d74 1
a74 1
	next if $f eq $curdir or $f eq $updir or
d77 1
a77 1
	my $fullpath = File::Spec->catfile($dir, $f);
d79 3
a81 3
	_find_tests($fullpath) if -d $fullpath;
	$fullpath = VMS::Filespec::unixify($fullpath) if $^O eq 'VMS';
	push @@ARGV, $fullpath if $f =~ /\.t$/;
a97 4
sub _populate_hash {
    return map {$_, 1} split /\s+/, $_[0];
}

d100 1
a100 32
	_find_tests($dir);
    }
    _find_tests("lib") unless $::core;
    # Config.pm may be broken for make minitest. And this is only a refinement
    # for skipping tests on non-default builds, so it is allowed to fail.
    # What we want to to is make a list of extensions which we did not build.
    my $configsh = File::Spec->catfile($updir, "config.sh");
    my %skip;
    if (-f $configsh) {
	my (%extensions, %known_extensions);
	open FH, $configsh or die "Can't open $configsh: $!";
	while (<FH>) {
	    if (/^extensions=['"](.*)['"]$/) {
		# Deliberate string interpolation to avoid triggering possible
		# $1 resetting bugs.
		%extensions = _populate_hash ("$1");
	    }
	    elsif (/^known_extensions=['"](.*)['"]$/) {
		%known_extensions = _populate_hash ($1);
	    }
	}
	if (%extensions) {
	    if (%known_extensions) {
		foreach (keys %known_extensions) {
		    $skip{$_}++ unless $extensions{$_};
		}
	    } else {
		warn "No known_extensions line found in $configsh";
	    }
	} else {
	    warn "No extensions line found in $configsh";
	}
d102 1
d105 4
a108 5
	while (<MANI>) { # similar code in t/harness
	    if (m!^(ext/(\S+)/+(?:[^/\s]+\.t|test\.pl)|lib/\S+?(?:\.t|test\.pl))\s!) {
		my $t = $1;
		my $extension = $2;
		if (!$::core || $t =~ m!^lib/[a-z]!)
d110 1
a110 6
		    if (defined $extension) {
			$extension =~ s!/t$!!;
			# XXX Do I want to warn that I'm skipping these?
			next if $skip{$extension};
		    }
		    my $path = File::Spec->catfile($updir, $t);
d112 1
a112 1
		    $::path_to_name{$path} = $t;
d118 1
a118 1
	warn "$0: cannot open $mani: $!\n";
d120 1
a120 1
    unless ($::core) {
d123 1
a123 1
	_find_tests('japh') if $::torture;
d128 2
a129 2
# %::infinite = ( 'comp/require.t', 1, 'op/bop.t', 1, 'lib/hostname.t', 1 );
%::infinite = ();
d131 1
a131 1
if ($::deparse) {
d134 1
a134 1
elsif( $::compile ) {
d137 1
a137 1
elsif( $::bytecompile ) {
d140 1
a140 1
elsif ($::with_utf16) {
d156 1
a156 1
			close(U);
d158 1
a158 1
		    close(A);
d172 3
a174 1
    my ($type, $args, @@tests) = @@_;
d195 1
a195 1
	  if ($type eq 'compile' && !$ENV{PERLCC_TIMEOUT});
d197 5
a201 1
    $::bad_files = 0;
d204 4
a207 4
      unless (exists $::path_to_name{$t}) {
	my $tname = File::Spec->catfile('t',$t);
	$tname = VMS::Filespec::unixify($tname) if $^O eq 'VMS';
	$::path_to_name{$t} = $tname;
d211 1
a211 1
    foreach (@@::path_to_name{@@tests}) {
d217 1
a217 1
    my $dotdotdot = $maxlen + 3 ;
d220 1
a220 7
    my $total_files = @@tests;
    my $good_files = 0;
    my $tested_files  = 0;
    my $totmax = 0;

    while (my $test = shift @@tests) {
        my $test_start_time = $show_elapsed_time ? Time::HiRes::time() : 0;
d222 1
a222 1
	if ( $::infinite{$test} && $type eq 'compile' ) {
d224 1
a224 1
	    next;
d239 1
a239 2
	my $te = $::path_to_name{$test} . '.'
		    x ($dotdotdot - length($::path_to_name{$test}));
d246 1
a246 2
	# XXX DAPM %OVER not defined anywhere
	# $test = $OVER{$test} if exists $OVER{$test};
d248 4
a251 4
	open(SCRIPT,"<",$test) or die "Can't run $test.\n";
	$_ = <SCRIPT>;
	close(SCRIPT) unless ($type eq 'deparse');
	if ($::with_utf16) {
d254 5
a258 6
	my $switch;
	if (/#!.*\bperl.*\s-\w*([tT])/) {
	    $switch = qq{"-$1"};
	}
	else {
	    if ($::taintwarn) {
d265 1
a265 1
	}
d267 1
a267 1
	my $test_executable; # for 'compile' tests
d278 1
a278 1
	my $utf8 = $::with_utf8 ? '-I../lib -Mutf8' : '';
d281 1
a281 1
	    my $deparse_cmd =
d283 1
a283 1
		"-l$::deparse_opts$file_opts ".
d286 2
a287 2
	    open(RESULTS, $deparse_cmd)
		or print "can't deparse '$deparse_cmd': $!.\n";
d291 1
a291 1
	    if( $^O eq 'MSWin32') {
d307 2
a308 2
	    my $bytecompile_cmd =
		"$perl $testswitch $switch -I../lib $bswitch".
d311 2
a312 2
	    open(RESULTS,$bytecompile_cmd)
		or print "can't byte-compile '$bytecompile_cmd': $!.\n";
d319 2
a320 2
			       . "--leak-resolution=high --show-reachable=yes "
			       . "--num-callers=50 --logfile-fd=3 $perl";
d323 1
a323 2
	    my $run = "$perl" . _quote_args("$testswitch $switch $utf8")
			      . " $test $redir|";
d327 11
a337 11
	    my $compile_cmd;
	    my $pl2c = "$testswitch -I../lib ../utils/perlcc --testsuite " .
	      # -O9 for good measure, -fcog is broken ATM
		       "$switch -Wb=-O9,-fno-cog -L .. " .
		       "-I \".. ../lib/CORE\" $args $utf8 $test -o ";

	    if( $^O eq 'MSWin32' ) {
		$test_executable = "$test.exe";
		# hopefully unused name...
		open HACK, "> xweghyz.pl";
		print HACK <<EOT;
d346 16
a361 20
		close HACK;
		$compile_cmd = 'xweghyz.pl |';
	    }
	    else {
		$test_executable = "$test.plc";
		$compile_cmd
		    = "./perl $pl2c $test_executable && $test_executable |";
	    }
	    unlink $test_executable if -f $test_executable;
	    open(RESULTS, $compile_cmd)
		or print "can't compile '$compile_cmd': $!.\n";
	}

	my $failure;
	my $next = 0;
	my $seen_leader = 0;
	my $seen_ok = 0;
	my $trailing_leader = 0;
	my $max;
	my %todo;
d364 1
a364 1
	    if ($::verbose) {
a367 5
		if ($trailing_leader) {
		    # shouldn't be anything following a postfix 1..n
		    $failure = 'FAILED--extra output after trailing 1..n';
		    last;
		}
a368 4
		    if ($seen_leader) {
			$failure = 'FAILED--seen duplicate leader';
			last;
		    }
d370 1
a370 1
		    %todo = map { $_ => 1 } split / /, $3 if $3;
d372 6
a377 13
		    $tested_files++;
		    if ($seen_ok) {
			# 1..n appears at end of file
			$trailing_leader = 1;
			if ($next != $max) {
			    $failure = "FAILED--expected $max tests, saw $next";
			    last;
			}
		    }
		    else {
			$next = 0;
		    }
		    $seen_leader = 1;
d380 1
a380 1
		    if (/^(not )?ok(?: (\d+))?[^\#]*(\s*\#.*)?/) {
d383 2
a384 1
				$next = 0;
d388 3
a390 10
			$next++;
			my($not, $num, $extra, $istodo) = ($1, $2, $3, 0);
			$num = $next unless $num;

			if ($num == $next) {

			    # SKIP is essentially the same as TODO for t/TEST
			    # this still conforms to TAP:
			    # http://search.cpan.org/dist/Test-Harness/lib/Test/Harness/TAP.pod
			    $extra and $istodo = $extra =~ /#\s*(?:TODO|SKIP)\b/;
d394 2
a395 1
				$failure = "FAILED at test $num";
d398 3
d402 3
a404 7
			else {
			    $failure ="FAILED--expected test $next, saw test $num";
			    last;
			}
		    }
		    elsif (/^Bail out!\s*(.*)/i) { # magic words
			die "FAILED--Further testing stopped" . ($1 ? ": $1\n" : ".\n");
d407 1
a407 2
			$failure = "FAILED--unexpected output at test $next";
			last;
a412 5

	if (not defined $failure) {
	    $failure = 'FAILED--no leader found' unless $seen_leader;
	}

d465 14
a478 14
	# test if the compiler compiled something
	if( $type eq 'compile' && !-e "$test_executable" ) {
	    $failure = "Test did not compile";
	}
	if (not defined $failure and $next != $max) {
	    $failure="FAILED--expected $max tests, saw $next";
	}

	if (defined $failure) {
	    print "${te}$failure\n";
	    $::bad_files++;
	    $_ = $test;
	    if (/^base/) {
		die "Failed a basic test--cannot continue.\n";
d482 3
a484 10
	    if ($max) {
		my $elapsed;
		if ( $show_elapsed_time ) {
		    $elapsed = sprintf( " %8.0f ms", (Time::HiRes::time() - $test_start_time) * 1000 );
		}
		else {
		    $elapsed = "";
		}
		print "${te}ok$elapsed\n";
		$good_files++;
d487 6
a492 2
		print "${te}skipping test on this platform\n";
		$tested_files -= 1;
d495 1
a495 1
    } # while tests
d497 2
a498 2
    if ($::bad_files == 0) {
	if ($good_files) {
d507 3
a509 3
	my $pct = $tested_files ? sprintf("%.2f", ($tested_files - $::bad_files) / $tested_files * 100) : "0.00";
	if ($::bad_files == 1) {
	    warn "Failed 1 test script out of $tested_files, $pct% okay.\n";
d512 1
a512 1
	    warn "Failed $::bad_files test scripts out of $tested_files, $pct% okay.\n";
d519 1
a519 1
	warn <<'SHRDLU_2' if $good_files / $total_files > 0.8;
d524 2
a525 2
	if (eval {require Config; import Config; 1}) {
	    if ($::Config{usedl} && (my $p = $::Config{ldlibpthname})) {
d530 1
a530 1
		if (exists $ENV{$p} && $ENV{$p} ne '') {
d536 1
a536 1
		} else {
d542 1
a542 1
		}
d547 1
a547 1
	    }
d550 3
a552 3
    my ($user,$sys,$cuser,$csys) = times;
    print sprintf("u=%.2f  s=%.2f  cu=%.2f  cs=%.2f  scripts=%d  tests=%d\n",
	$user,$sys,$cuser,$csys,$tested_files,$totmax);
d558 1
a558 1
exit ($::bad_files != 0);
@


1.1.1.10
log
@import perl 5.10.0 from CPAN
@
text
@d32 2
d109 1
a109 1
    foreach my $dir (qw(base comp cmd run io op uni mro)) {
a144 1
	my $ext_pat = $^O eq 'MSWin32' ? '(?:win32/)?ext' : 'ext';
d146 1
a146 1
	    if (m!^($ext_pat/(\S+)/+(?:[^/\s]+\.t|test\.pl)|lib/\S+?(?:\.t|test\.pl))\s!) {
a166 1
	_find_tests('Module_Pluggable');
d173 4
d180 6
d213 1
d220 6
d232 9
a263 1
    my %failed_tests;
d268 4
d316 1
d338 25
d367 3
a369 6
		my $valgrind = $ENV{VALGRIND} // 'valgrind';
		my $vg_opts = $ENV{VG_OPTS}
		    //  "--suppressions=perl.supp --leak-check=yes "
			. "--leak-resolution=high --show-reachable=yes "
			. "--num-callers=50"; 
		$perl = "$valgrind --log-fd=3 $vg_opts $perl";
d376 32
a407 5
	# Our environment may force us to use UTF-8, but we can't be sure that
	# anything we're reading from will be generating (well formed) UTF-8
	# This may not be the best way - possibly we should unset ${^OPEN} up
	# top?
	binmode RESULTS;
a482 3
			# module tests are allowed extra output,
			# because Test::Harness allows it
			next if $test =~ /^\W*(ext|lib)\b/;
d505 1
a505 8
	    if ($ENV{VG_OPTS} =~ /cachegrind/) {
		if (rename $valgrind_log, "$test.valgrind") {
		    $valgrind++;
		} else {
		    warn "$0: Failed to create '$test.valgrind': $!\n";
		}
	    }
	    elsif (@@valgrind) {
d547 4
a554 6
	if( !defined $failure  # don't mask a test failure
	    and $? )
	{
	    $failure = "FAILED--non-zero wait status: $?";
	}

d558 3
a560 2
	    if ($test =~ /^base/) {
		die "Failed a basic test ($test) -- cannot continue.\n";
a561 1
	    ++$failed_tests{$test};
d576 1
a576 1
		print "${te}skipped\n";
d593 5
a597 4
	my $s = $::bad_files == 1 ? "" : "s";
	warn "Failed $::bad_files test$s out of $tested_files, $pct% okay.\n";
	for my $test ( sort keys %failed_tests ) {
	    print "\t$test\n";
a643 2

# ex: set ts=8 sts=4 sw=4 noet:
@


1.1.1.11
log
@import perl 5.10.1
@
text
@a16 1
delete $ENV{PERL5LIB};
d143 1
d145 1
a145 1
	    if (m!^(ext/(\S+)/+(?:[^/\s]+\.t|test\.pl)|lib/\S+?(?:\.t|test\.pl))\s!) {
a153 3
			my $flat_extension = $extension;
			$flat_extension =~ s!-!/!g;
			next if $skip{$flat_extension}; # Foo/Bar may live in Foo-Bar
d166 1
a338 8
	    if (/^1..$/ && ($^O eq 'VMS')) {
		# VMS pipe bug inserts blank lines.
		my $l2 = <RESULTS>;
		if ($l2 =~ /^\s*$/) {
		    $l2 = <RESULTS>;
		}
		$_ = '1..' . $l2;
	    }
d386 1
a386 1
			    # http://search.cpan.org/dist/TAP/TAP.pod
@


1.1.1.12
log
@Perl 5.12.2 from CPAN
@
text
@a7 88
# t/TEST and t/harness need to share code. The logical way to do this would be
# to have the common code in a file both require or use. However, t/TEST needs
# to still work, to generate test results, even if require isn't working, so
# we cannot do that. t/harness has no such restriction, so it is quite
# acceptable to have it require t/TEST.

# In which case, we need to stop t/TEST actually running tests, as all
# t/harness needs are its subroutines.


# directories with special sets of test switches
my %dir_to_switch =
    (base => '',
     comp => '',
     run => '',
     '../ext/File-Glob/t' => '-I.. -MTestInit', # FIXME - tests assume t/
     );

# "not absolute" is the the default, as it saves some fakery within TestInit
# which can peturb tests, and takes CPU. Working with the upstream author of
# any of these, to figure out how to remove them from this list, considered
# "a good thing".
my %abs = (
	   '../cpan/Archive-Extract' => 1,
	   '../cpan/Archive-Tar' => 1,
	   '../cpan/AutoLoader' => 1,
	   '../cpan/CPAN' => 1,
	   '../cpan/Class-ISA' => 1,
	   '../cpan/Cwd' => 1,
	   '../cpan/Devel-PPPort' => 1,
	   '../cpan/Encode' => 1,
	   '../cpan/ExtUtils-Command' => 1,
	   '../cpan/ExtUtils-Constant' => 1,
	   '../cpan/ExtUtils-MakeMaker' => 1,
	   '../cpan/ExtUtils-Manifest' => 1,
	   '../cpan/ExtUtils-ParseXS' => 1,
	   '../cpan/File-Fetch' => 1,
	   '../cpan/IPC-Cmd' => 1,
	   '../cpan/IPC-SysV' => 1,
	   '../cpan/Locale-Codes' => 1,
	   '../cpan/Log-Message' => 1,
	   '../cpan/Math-BigInt' => 1,
	   '../cpan/Math-BigRat' => 1,
	   '../cpan/Math-Complex' => 1,
	   '../cpan/Module-Build' => 1,
	   '../cpan/Module-Load' => 1,
	   '../cpan/Module-Load-Conditional' => 1,
	   '../cpan/Object-Accessor' => 1,
	   '../cpan/Package-Constants' => 1,
	   '../cpan/Parse-CPAN-Meta' => 1,
	   '../cpan/Pod-Simple' => 1,
	   '../cpan/Term-UI' => 1,
	   '../cpan/Test-Simple' => 1,
	   '../cpan/Tie-File' => 1,
	   '../cpan/bignum' => 1,
	   '../cpan/podlators' => 1,
	   '../dist/ExtUtils-Install' => 1,
	  );
	      
my %temp_no_core =
    ('../cpan/B-Debug' => 1,
     '../cpan/Compress-Raw-Bzip2' => 1,
     '../cpan/Compress-Raw-Zlib' => 1,
     '../cpan/Devel-PPPort' => 1,
     '../cpan/Getopt-Long' => 1,
     '../cpan/IO-Compress' => 1,
     '../cpan/Math-BigInt' => 1,
     '../cpan/Math-BigRat' => 1,
     '../cpan/MIME-Base64' => 1,
     '../cpan/NEXT' => 1,
     '../cpan/parent' => 1,
     '../cpan/Parse-CPAN-Meta' => 1,
     '../cpan/Pod-Simple' => 1,
     '../cpan/podlators' => 1,
     '../cpan/Test-Simple' => 1,
     '../cpan/Tie-RefHash' => 1,
     '../cpan/Time-HiRes' => 1,
     '../cpan/Unicode-Collate' => 1,
     '../cpan/Unicode-Normalize' => 1,
    );

if ($::do_nothing) {
    return 1;
}

# Location to put the Valgrind log.
my $Valgrind_Log = 'current.valgrind';

d11 2
a12 2
#BEGIN { require '../lib/strict.pm'; "strict"->import() };
#BEGIN { require '../lib/warnings.pm'; "warnings"->import() };
d14 4
a17 13
# delete env vars that may influence the results
# but allow override via *_TEST env var if wanted
# (e.g. PERL5OPT_TEST=-d:NYTProf)
for my $envname (qw(PERL5LIB PERLLIB PERL5OPT)) {
    my $override = $ENV{"${envname}_TEST"};
    if (defined $override) {
	warn "$0: $envname=$override\n";
	$ENV{$envname} = $override;
    }
    else {
	delete $ENV{$envname};
    }
}
d23 1
a23 2
# Cheesy version of Getopt::Std.  We can't replace it with that, because we
# can't rely on require working.
a27 1
	$::benchmark = 1 if $1 eq 'benchmark';
a43 3
if (-f 'TEST' && -f 'harness' && -d '../lib') {
    @@INC = '../lib';
}
d68 3
d72 2
a74 10
my %skip = (
	    '.' => 1,
	    '..' => 1,
	    'CVS' => 1,
	    'RCS' => 1,
	    'SCCS' => 1,
	    '.svn' => 1,
	   );

# Roll your own File::Find!
d79 2
a80 87
	next if $skip{$f};

	my $fullpath = "$dir/$f";

	if (-d $fullpath) {
	    _find_tests($fullpath);
	} elsif ($f =~ /\.t$/) {
	    push @@ARGV, $fullpath;
	}
    }
}


# Scan the text of the test program to find switches and special options
# we might need to apply.
sub _scan_test {
    my($test, $type) = @@_;

    open(my $script, "<", $test) or die "Can't read $test.\n";
    my $first_line = <$script>;

    $first_line =~ tr/\0//d if $::with_utf16;

    my $switch = "";
    if ($first_line =~ /#!.*\bperl.*\s-\w*([tT])/) {
        $switch = "-$1";
    } else {
        if ($::taintwarn) {
            # not all tests are expected to pass with this option
            $switch = '-t';
        } else {
            $switch = '';
        }
    }

    my $file_opts = "";
    if ($type eq 'deparse') {
        # Look for #line directives which change the filename
        while (<$script>) {
            $file_opts = $file_opts . ",-f$3$4"
              if /^#\s*line\s+(\d+)\s+((\w+)|"([^"]+)")/;
        }
    }

    close $script;

    my $perl = './perl';
    my $lib  = '../lib';
    my $run_dir;
    my $return_dir;

    $test =~ /^(.+)\/[^\/]+/;
    my $dir = $1;
    my $testswitch = $dir_to_switch{$dir};
    if (!defined $testswitch) {
	if ($test =~ s!^(\.\./(cpan|dist|ext)/[^/]+)/t!t!) {
	    $run_dir = $1;
	    $return_dir = '../../t';
	    $lib = '../../lib';
	    $perl = '../../t/perl';
	    $testswitch = "-I../.. -MTestInit=U2T";
	    if ($2 eq 'cpan' || $2 eq 'dist') {
		if($abs{$run_dir}) {
		    $testswitch = $testswitch . ',A';
		}
		if ($temp_no_core{$run_dir}) {
		    $testswitch = $testswitch . ',NC';
		}
	    }
	} else {
	    $testswitch = '-I.. -MTestInit';  # -T will remove . from @@INC
	}
    }

    my $utf8 = ($::with_utf8 || $::with_utf16) ? "-I$lib -Mutf8" : '';

    my %options = (
	perl => $perl,
	lib => $lib,
	test => $test,
	run_dir => $run_dir,
	return_dir => $return_dir,
	testswitch => $testswitch,
	utf8 => $utf8,
	file => $file_opts,
	switch => $switch,
    );
d82 1
a82 43
    return \%options;
}

sub _cmd {
    my($options, $type) = @@_;

    my $test = $options->{test};

    my $cmd;
    if ($type eq 'deparse') {
        my $perl = "$options->{perl} $options->{testswitch}";
        my $lib = $options->{lib};

        $cmd = (
          "$perl $options->{switch} -I$lib -MO=-qq,Deparse,-sv1.,".
          "-l$::deparse_opts$options->{file} ".
          "$test > $test.dp ".
          "&& $perl $options->{switch} -I$lib $test.dp"
        );
    }
    elsif ($type eq 'perl') {
        my $perl = $options->{perl};
        my $redir = $^O eq 'VMS' ? '2>&1' : '';

        if ($ENV{PERL_VALGRIND}) {
            my $valgrind = $ENV{VALGRIND} // 'valgrind';
            my $vg_opts = $ENV{VG_OPTS}
              //  "--suppressions=perl.supp --leak-check=yes "
                . "--leak-resolution=high --show-reachable=yes "
                  . "--num-callers=50";
            $perl = "$valgrind --log-fd=3 $vg_opts $perl";
            $redir = "3>$Valgrind_Log";
        }

        my $args = "$options->{testswitch} $options->{switch} $options->{utf8}";
        $cmd = $perl . _quote_args($args) . " $test $redir";
    }

    return $cmd;
}

sub _before_fork {
    my ($options) = @@_;
d84 3
a86 3
    if ($options->{run_dir}) {
	my $run_dir = $options->{run_dir};
	chdir $run_dir or die "Can't chdir to '$run_dir': $!";
a87 38

    return;
}

sub _after_fork {
    my ($options) = @@_;

    if ($options->{return_dir}) {
	my $return_dir = $options->{return_dir};
	chdir $return_dir
	   or die "Can't chdir from '$options->{run_dir}' to '$return_dir': $!";
    }

    return;
}

sub _run_test {
    my ($test, $type) = @@_;

    my $options = _scan_test($test, $type);
    # $test might have changed if we're in ext/Foo, so don't use it anymore
    # from now on. Use $options->{test} instead.

    _before_fork($options);

    my $cmd = _cmd($options, $type);

    open(my $results, "$cmd |") or print "can't run '$cmd': $!.\n";

    _after_fork($options);

    # Our environment may force us to use UTF-8, but we can't be sure that
    # anything we're reading from will be generating (well formed) UTF-8
    # This may not be the best way - possibly we should unset ${^OPEN} up
    # top?
    binmode $results;

    return $results;
d98 1
a98 1
       $argstring = $argstring . ' ' . $_;
a103 1
    return unless defined $_[0];
d107 9
a115 2
sub _tests_from_manifest {
    my ($extensions, $known_extensions) = @@_;
d117 24
a140 5
    my %extensions = _populate_hash($extensions);
    my %known_extensions = _populate_hash($known_extensions);

    foreach (keys %known_extensions) {
	$skip{$_} = 1 unless $extensions{$_};
d142 1
a142 3

    my @@results;
    my $mani = '../MANIFEST';
d144 2
a145 2
	while (<MANI>) {
	    if (m!^((?:cpan|dist|ext)/(\S+)/+(?:[^/\s]+\.t|test\.pl)|lib/\S+?(?:\.t|test\.pl))\s!) {
d148 2
a149 1
		if (!$::core || $t =~ m!^lib/[a-z]!) {
d158 2
a159 2
		    my $path = "../$t";
		    push @@results, $path;
a167 39
    return @@results;
}

unless (@@ARGV) {
    # base first, as TEST bails out if that can't run
    # then comp, to validate that require works
    # then run, to validate that -M works
    # then we know we can -MTestInit for everything else, making life simpler
    foreach my $dir (qw(base comp run cmd io re op uni mro)) {
	_find_tests($dir);
    }
    _find_tests("lib") unless $::core;
    # Config.pm may be broken for make minitest. And this is only a refinement
    # for skipping tests on non-default builds, so it is allowed to fail.
    # What we want to to is make a list of extensions which we did not build.
    my $configsh = '../config.sh';
    my ($extensions, $known_extensions);
    if (-f $configsh) {
	open FH, $configsh or die "Can't open $configsh: $!";
	while (<FH>) {
	    if (/^extensions=['"](.*)['"]$/) {
		$extensions = $1;
	    }
	    elsif (/^known_extensions=['"](.*)['"]$/) {
		$known_extensions = $1;
	    }
	}
	if (!defined $known_extensions) {
	    warn "No known_extensions line found in $configsh";
	}
	if (!defined $extensions) {
	    warn "No extensions line found in $configsh";
	}
    }
    # The "complex" constructions of list return from a subroutine, and push of
    # a list, might fail if perl is really hosed, but they aren't needed for
    # make minitest, and the building of extensions will likely also fail if
    # something is that badly wrong.
    push @@ARGV, _tests_from_manifest($extensions, $known_extensions);
d169 1
a170 1
	_find_tests('porting');
a171 1
	_find_tests('t/benchmark') if $::benchmark or $ENV{PERL_BENCHMARK};
d221 2
a222 1
	my $tname = "t/$t";
d235 1
d266 65
a330 1
	my $results = _run_test($test, $type);
d339 1
a339 1
	while (<$results>) {
d365 2
a366 2
		    $totmax = $totmax + $max;
		    $tested_files = $tested_files + 1;
d388 1
a388 1
			$next = $next + 1;
d396 1
a396 1
			    # http://search.cpan.org/dist/TAP/TAP.pm
d416 1
a416 1
			next if $test =~ /^\W*(cpan|dist|ext|lib)\b/;
d423 1
a423 1
	close $results;
d431 2
a432 2
	    if (-e $Valgrind_Log) {
		if (open(V, $Valgrind_Log)) {
d436 1
a436 1
		    warn "$0: Failed to open '$Valgrind_Log': $!\n";
d440 2
a441 2
		if (rename $Valgrind_Log, "$test.valgrind") {
		    $valgrind = $valgrind + 1;
d452 1
a452 1
			$errors = $errors + $1;   # there may be multiple error summaries
d457 1
a457 1
				$leaks = $leaks + $1;
d463 2
a464 2
		    if (rename $Valgrind_Log, "$test.valgrind") {
			$valgrind = $valgrind + 1;
d472 3
a474 3
	    if (-e $Valgrind_Log) {
		unlink $Valgrind_Log
		    or warn "$0: Failed to unlink '$Valgrind_Log': $!\n";
d500 1
a500 1
	    $::bad_files = $::bad_files + 1;
d504 1
a504 1
	    $failed_tests{$test} = 1;
d516 1
a516 1
		$good_files = $good_files + 1;
d520 1
a520 1
		$tested_files = $tested_files - 1;
@


1.1.1.13
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d36 1
d39 1
d42 2
d49 3
d61 2
a63 2
	   '../dist/Cwd' => 1,
	   '../dist/ExtUtils-Command' => 1,
a64 3
	   '../dist/ExtUtils-Manifest' => 1,
	   '../dist/ExtUtils-ParseXS' => 1,
	   '../dist/Tie-File' => 1,
d66 1
a66 1

d74 2
d77 1
d84 1
d89 13
d105 1
a105 6
my @@bad_env_vars = qw(
    PERL5LIB PERLLIB PERL5OPT
    PERL_YAML_BACKEND PERL_JSON_BACKEND
);

for my $envname (@@bad_env_vars) {
a115 13
if ($::do_nothing) {
    return 1;
}

# Location to put the Valgrind log.
our $Valgrind_Log;

$| = 1;

# for testing TEST only
#BEGIN { require '../lib/strict.pm'; "strict"->import() };
#BEGIN { require '../lib/warnings.pm'; "warnings"->import() };

d133 1
a166 2
# check existence of all symbols
$ENV{PERL_DL_NONLAZY} = 1 unless exists $ENV{PERL_DL_NONLAZY};
a170 1
my %timings = (); # testname => [@@et] pairs if $show_elapsed_time.
d182 12
a193 15
sub _find_tests { our @@found=(); push @@ARGV, _find_files('\.t$', $_[0]) }
sub _find_files {
    my($patt, @@dirs) = @@_;
    for my $dir (@@dirs) {
	opendir DIR, $dir or die "Trouble opening $dir: $!";
	foreach my $f (sort { $a cmp $b } readdir DIR) {
	    next if $skip{$f};

	    my $fullpath = "$dir/$f";
	    
	    if (-d $fullpath) {
		_find_files($patt, $fullpath);
	    } elsif ($f =~ /$patt/) {
		push @@found, $fullpath;
	    }
a195 1
    @@found;
a254 2
	} elsif ($test =~ m!^\.\./lib!) {
	    $testswitch = '-I.. -MTestInit=U1'; # -T will remove . from @@INC
d299 1
a299 2
            my $perl_supp = $options->{return_dir} ? "$options->{return_dir}/perl.supp" : "perl.supp";
            my $valgrind_exe = $ENV{VALGRIND} // 'valgrind';
d301 4
a304 5
              // '--log-fd=3 '
		  . "--suppressions=$perl_supp --leak-check=yes "
		  . "--leak-resolution=high --show-reachable=yes "
                  . "--num-callers=50 --track-origins=yes";
            $perl = "$valgrind_exe $vg_opts $perl";
a305 3
            if ($options->{run_dir}) {
                $Valgrind_Log = "$options->{run_dir}/$Valgrind_Log";
            }
d311 1
d399 1
a399 1
			$extension =~ s!/t(:?/\S+)*$!!;
d427 1
a427 4
    unless ($::core) {
	_find_tests('porting');
	_find_tests("lib"); 
    }
d457 1
d515 1
a515 1
	s/\.\w+\z/ /; # space gives easy doubleclick to select fname
d521 1
a521 1
    my $grind_ct = 0;		# count of non-empty valgrind reports
a526 1
    my $toolnm;		# valgrind, cachegrind, perf
d529 2
a530 12
        my ($test_start_time, @@starttimes) = 0;
	if ($show_elapsed_time) {
	    $test_start_time = Time::HiRes::time();
	    # times() reports usage by TEST, but we want usage of each
	    # testprog it calls, so record accumulated times now,
	    # subtract them out afterwards.  Ideally, we'd take times
	    # in BEGIN/END blocks (giving better visibility of self vs
	    # children of each testprog), but that would require some
	    # IPC to send results back here, or a completely different
	    # collection scheme (Storable isnt tuned for incremental use)
	    @@starttimes = times;
	}
d545 1
a545 1
		    x ($dotdotdot - length($::path_to_name{$test})) .' ';
a551 1
        (local $Valgrind_Log = "$test.valgrind-current") =~ s/^.*\///;
d618 1
a618 1
			    # http://testanything.org/wiki/index.php/TAP_specification
d652 1
a652 3
	    $toolnm = $ENV{VALGRIND};
	    $toolnm =~ s|.*/||;  # keep basename
	    my @@valgrind;	# gets content of file
d661 3
a663 9
	    if ($ENV{VG_OPTS} =~ /(cachegrind)/ or $toolnm =~ /(perf)/) {
		$toolnm = $1;
		if ($toolnm eq 'perf') {
		    # append perfs subcommand, not just stat
		    my ($sub) = split /\s/, $ENV{VG_OPTS};
		    $toolnm .= "-$sub";
		}
		if (rename $Valgrind_Log, "$test.$toolnm") {
		    $grind_ct++;
d665 1
a665 1
		    warn "$0: Failed to create '$test.$toolnm': $!\n";
d686 1
a686 1
			$grind_ct = $grind_ct + 1;
d730 1
a730 1
		my ($elapsed, $etms) = ("", 0);
d732 4
a735 9
		    $etms = (Time::HiRes::time() - $test_start_time) * 1000;
		    $elapsed = sprintf(" %8.0f ms", $etms);

		    my (@@endtimes) = times;
		    $endtimes[$_] -= $starttimes[$_] for 0..$#endtimes;
		    splice @@endtimes, 0, 2;    # drop self/harness times
		    $_ *= 1000 for @@endtimes;  # and scale to ms
		    $timings{$test} = [$etms,@@endtimes];
		    $elapsed .= sprintf(" %5.0f ms", $_) for @@endtimes;
d800 2
a801 20
    my $tot = sprintf("u=%.2f  s=%.2f  cu=%.2f  cs=%.2f  scripts=%d  tests=%d",
		      $user,$sys,$cuser,$csys,$tested_files,$totmax);
    print "$tot\n";
    if ($good_files) {
	if (-d $show_elapsed_time) {
	    # HARNESS_TIMER = <a-directory>.  Save timings etc to
	    # storable file there.  NB: the test cds to ./t/, so
	    # relative path must account for that, ie ../../perf
	    # points to dir next to source tree.
	    require Storable;
	    my @@dt = localtime;
	    $dt[5] += 1900; $dt[4] += 1; # fix year, month
	    my $fn = "$show_elapsed_time/".join('-', @@dt[5,4,3,2,1]).".ttimes";
	    Storable::store({ perf => \%timings,
			      gather_conf_platform_info(),
			      total => $tot,
			    }, $fn);
	    print "wrote storable file: $fn\n";
	}
    }
d803 2
a804 8
	my $s = $grind_ct == 1 ? '' : 's';
	print "$grind_ct valgrind report$s created.\n", ;
	if ($toolnm eq 'cachegrind') {
	    # cachegrind leaves a lot of cachegrind.out.$pid litter
	    # around the tree, find and delete them
	    unlink _find_files('cachegrind.out.\d+$',
			     qw ( ../t ../cpan ../ext ../dist/ ));
	}
a807 31

# Collect platform, config data that should allow comparing
# performance data between different machines.  With enough data,
# and/or clever statistical analysis, it should be possible to
# determine the effect of config choices, more memory, etc

sub gather_conf_platform_info {
    # currently rather quick & dirty, and subject to change
    # for both content and format.
    require Config;
    my (%conf, @@platform) = ();
    $conf{$_} = $Config::Config{$_} for
	grep /cc|git|config_arg\d+/, keys %Config::Config;
    if (-f '/proc/cpuinfo') {
	open my $fh, '/proc/cpuinfo' or warn "$!: /proc/cpuinfo\n";
	@@platform = grep /name|cpu/, <$fh>;
	chomp $_ for @@platform;
    }
    unshift @@platform, $^O;

    return (
	conf => \%conf,
	platform => {cpu => \@@platform,
		     mem => [ grep s/\s+/ /,
			      grep chomp, `free` ],
		     load => [ grep chomp, `uptime` ],
	},
	host => (grep chomp, `hostname -f`),
	version => '0.03', # bump for conf, platform, or data collection changes
	);
}
@


1.1.1.14
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d5 1
a5 1
# probably obsolete on the avoidance side, though still current
d26 2
a27 2
# "not absolute" is the default, as it saves some fakery within TestInit
# which can perturb tests, and takes CPU. Working with the upstream author of
d433 1
a433 1
    foreach my $dir (qw(base comp run cmd io re opbasic op uni mro)) {
a470 1
	_find_tests('bigmem') if $ENV{PERL_TEST_MEMORY};
d550 1
a550 1
	    # collection scheme (Storable isn't tuned for incremental use)
d588 1
a588 1
		my $l2 = <$results>;
d590 1
a590 1
		    $l2 = <$results>;
@


1.1.1.15
log
@Import perl-5.20.1
@
text
@d31 1
d44 1
d48 1
d52 1
d146 15
d734 8
d755 2
a756 5
	    if ($test =~ /^base/ && ! defined &DynaLoader::boot_DynaLoader) {
		# Die if running under minitest (no DynaLoader).  Otherwise
		# keep going, as  we know that Perl basically works, or we
		# would not have been able to actually compile it all the way.
		die "Failed a basic test ($test) under minitest -- cannot continue.\n";
@


